{
  "module_name": "88pm860x-core.c",
  "hash_id": "db59d3ca78aed404e64ad933815f8e1a009dd5a16b1b6a006ae902d7c5cd9706",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/88pm860x-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/88pm860x.h>\n#include <linux/regulator/machine.h>\n#include <linux/power/charger-manager.h>\n\n#define INT_STATUS_NUM\t\t\t3\n\nstatic const struct resource bk0_resources[] = {\n\t{2, 2, \"duty cycle\", IORESOURCE_REG, },\n\t{3, 3, \"always on\",  IORESOURCE_REG, },\n\t{3, 3, \"current\",    IORESOURCE_REG, },\n};\nstatic const struct resource bk1_resources[] = {\n\t{4, 4, \"duty cycle\", IORESOURCE_REG, },\n\t{5, 5, \"always on\",  IORESOURCE_REG, },\n\t{5, 5, \"current\",    IORESOURCE_REG, },\n};\nstatic const struct resource bk2_resources[] = {\n\t{6, 6, \"duty cycle\", IORESOURCE_REG, },\n\t{7, 7, \"always on\",  IORESOURCE_REG, },\n\t{5, 5, \"current\",    IORESOURCE_REG, },\n};\n\nstatic const struct resource led0_resources[] = {\n\t \n\t{0xd, 0xd, \"control\", IORESOURCE_REG, },\n\t{0xc, 0xc, \"blink\",   IORESOURCE_REG, },\n};\nstatic const struct resource led1_resources[] = {\n\t \n\t{0xe, 0xe, \"control\", IORESOURCE_REG, },\n\t{0xc, 0xc, \"blink\",   IORESOURCE_REG, },\n};\nstatic const struct resource led2_resources[] = {\n\t \n\t{0xf, 0xf, \"control\", IORESOURCE_REG, },\n\t{0xc, 0xc, \"blink\",   IORESOURCE_REG, },\n};\nstatic const struct resource led3_resources[] = {\n\t \n\t{0x9, 0x9, \"control\", IORESOURCE_REG, },\n\t{0x8, 0x8, \"blink\",   IORESOURCE_REG, },\n};\nstatic const struct resource led4_resources[] = {\n\t \n\t{0xa, 0xa, \"control\", IORESOURCE_REG, },\n\t{0x8, 0x8, \"blink\",   IORESOURCE_REG, },\n};\nstatic const struct resource led5_resources[] = {\n\t \n\t{0xb, 0xb, \"control\", IORESOURCE_REG, },\n\t{0x8, 0x8, \"blink\",   IORESOURCE_REG, },\n};\n\nstatic const struct resource buck1_resources[] = {\n\t{0x24, 0x24, \"buck set\", IORESOURCE_REG, },\n};\nstatic const struct resource buck2_resources[] = {\n\t{0x25, 0x25, \"buck set\", IORESOURCE_REG, },\n};\nstatic const struct resource buck3_resources[] = {\n\t{0x26, 0x26, \"buck set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo1_resources[] = {\n\t{0x10, 0x10, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo2_resources[] = {\n\t{0x11, 0x11, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo3_resources[] = {\n\t{0x12, 0x12, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo4_resources[] = {\n\t{0x13, 0x13, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo5_resources[] = {\n\t{0x14, 0x14, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo6_resources[] = {\n\t{0x15, 0x15, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo7_resources[] = {\n\t{0x16, 0x16, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo8_resources[] = {\n\t{0x17, 0x17, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo9_resources[] = {\n\t{0x18, 0x18, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo10_resources[] = {\n\t{0x19, 0x19, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo12_resources[] = {\n\t{0x1a, 0x1a, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo_vibrator_resources[] = {\n\t{0x28, 0x28, \"ldo set\", IORESOURCE_REG, },\n};\nstatic const struct resource ldo14_resources[] = {\n\t{0x1b, 0x1b, \"ldo set\", IORESOURCE_REG, },\n};\n\nstatic struct resource touch_resources[] = {\n\t{PM8607_IRQ_PEN, PM8607_IRQ_PEN, \"touch\", IORESOURCE_IRQ,},\n};\n\nstatic struct resource onkey_resources[] = {\n\t{PM8607_IRQ_ONKEY, PM8607_IRQ_ONKEY, \"onkey\", IORESOURCE_IRQ,},\n};\n\nstatic struct resource codec_resources[] = {\n\t \n\t{PM8607_IRQ_MICIN,   PM8607_IRQ_MICIN,   \"micin\",   IORESOURCE_IRQ,},\n\t \n\t{PM8607_IRQ_HOOK,    PM8607_IRQ_HOOK,    \"hook\",    IORESOURCE_IRQ,},\n\t \n\t{PM8607_IRQ_HEADSET, PM8607_IRQ_HEADSET, \"headset\", IORESOURCE_IRQ,},\n\t \n\t{PM8607_IRQ_AUDIO_SHORT, PM8607_IRQ_AUDIO_SHORT, \"audio-short\",\n\t IORESOURCE_IRQ,},\n};\n\nstatic struct resource battery_resources[] = {\n\t{PM8607_IRQ_CC,  PM8607_IRQ_CC,  \"columb counter\", IORESOURCE_IRQ,},\n\t{PM8607_IRQ_BAT, PM8607_IRQ_BAT, \"battery\",        IORESOURCE_IRQ,},\n};\n\nstatic struct resource charger_resources[] = {\n\t{PM8607_IRQ_CHG,  PM8607_IRQ_CHG,  \"charger detect\",  IORESOURCE_IRQ,},\n\t{PM8607_IRQ_CHG_DONE,  PM8607_IRQ_CHG_DONE,  \"charging done\",\n\t IORESOURCE_IRQ,},\n\t{PM8607_IRQ_CHG_FAIL,  PM8607_IRQ_CHG_FAIL,  \"charging timeout\",\n\t IORESOURCE_IRQ,},\n\t{PM8607_IRQ_CHG_FAULT, PM8607_IRQ_CHG_FAULT, \"charging fault\",\n\t IORESOURCE_IRQ,},\n\t{PM8607_IRQ_GPADC1,    PM8607_IRQ_GPADC1,    \"battery temperature\",\n\t IORESOURCE_IRQ,},\n\t{PM8607_IRQ_VBAT, PM8607_IRQ_VBAT, \"battery voltage\", IORESOURCE_IRQ,},\n\t{PM8607_IRQ_VCHG, PM8607_IRQ_VCHG, \"vchg voltage\",    IORESOURCE_IRQ,},\n};\n\nstatic struct resource rtc_resources[] = {\n\t{PM8607_IRQ_RTC, PM8607_IRQ_RTC, \"rtc\", IORESOURCE_IRQ,},\n};\n\nstatic struct mfd_cell bk_devs[] = {\n\t{\n\t\t.name = \"88pm860x-backlight\",\n\t\t.id = 0,\n\t\t.num_resources = ARRAY_SIZE(bk0_resources),\n\t\t.resources = bk0_resources,\n\t}, {\n\t\t.name = \"88pm860x-backlight\",\n\t\t.id = 1,\n\t\t.num_resources = ARRAY_SIZE(bk1_resources),\n\t\t.resources = bk1_resources,\n\t}, {\n\t\t.name = \"88pm860x-backlight\",\n\t\t.id = 2,\n\t\t.num_resources = ARRAY_SIZE(bk2_resources),\n\t\t.resources = bk2_resources,\n\t},\n};\n\nstatic struct mfd_cell led_devs[] = {\n\t{\n\t\t.name = \"88pm860x-led\",\n\t\t.id = 0,\n\t\t.num_resources = ARRAY_SIZE(led0_resources),\n\t\t.resources = led0_resources,\n\t}, {\n\t\t.name = \"88pm860x-led\",\n\t\t.id = 1,\n\t\t.num_resources = ARRAY_SIZE(led1_resources),\n\t\t.resources = led1_resources,\n\t}, {\n\t\t.name = \"88pm860x-led\",\n\t\t.id = 2,\n\t\t.num_resources = ARRAY_SIZE(led2_resources),\n\t\t.resources = led2_resources,\n\t}, {\n\t\t.name = \"88pm860x-led\",\n\t\t.id = 3,\n\t\t.num_resources = ARRAY_SIZE(led3_resources),\n\t\t.resources = led3_resources,\n\t}, {\n\t\t.name = \"88pm860x-led\",\n\t\t.id = 4,\n\t\t.num_resources = ARRAY_SIZE(led4_resources),\n\t\t.resources = led4_resources,\n\t}, {\n\t\t.name = \"88pm860x-led\",\n\t\t.id = 5,\n\t\t.num_resources = ARRAY_SIZE(led5_resources),\n\t\t.resources = led5_resources,\n\t},\n};\n\nstatic struct mfd_cell reg_devs[] = {\n\t{\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 0,\n\t\t.num_resources = ARRAY_SIZE(buck1_resources),\n\t\t.resources = buck1_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 1,\n\t\t.num_resources = ARRAY_SIZE(buck2_resources),\n\t\t.resources = buck2_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 2,\n\t\t.num_resources = ARRAY_SIZE(buck3_resources),\n\t\t.resources = buck3_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 3,\n\t\t.num_resources = ARRAY_SIZE(ldo1_resources),\n\t\t.resources = ldo1_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 4,\n\t\t.num_resources = ARRAY_SIZE(ldo2_resources),\n\t\t.resources = ldo2_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 5,\n\t\t.num_resources = ARRAY_SIZE(ldo3_resources),\n\t\t.resources = ldo3_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 6,\n\t\t.num_resources = ARRAY_SIZE(ldo4_resources),\n\t\t.resources = ldo4_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 7,\n\t\t.num_resources = ARRAY_SIZE(ldo5_resources),\n\t\t.resources = ldo5_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 8,\n\t\t.num_resources = ARRAY_SIZE(ldo6_resources),\n\t\t.resources = ldo6_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 9,\n\t\t.num_resources = ARRAY_SIZE(ldo7_resources),\n\t\t.resources = ldo7_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 10,\n\t\t.num_resources = ARRAY_SIZE(ldo8_resources),\n\t\t.resources = ldo8_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 11,\n\t\t.num_resources = ARRAY_SIZE(ldo9_resources),\n\t\t.resources = ldo9_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 12,\n\t\t.num_resources = ARRAY_SIZE(ldo10_resources),\n\t\t.resources = ldo10_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 13,\n\t\t.num_resources = ARRAY_SIZE(ldo12_resources),\n\t\t.resources = ldo12_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 14,\n\t\t.num_resources = ARRAY_SIZE(ldo_vibrator_resources),\n\t\t.resources = ldo_vibrator_resources,\n\t}, {\n\t\t.name = \"88pm860x-regulator\",\n\t\t.id = 15,\n\t\t.num_resources = ARRAY_SIZE(ldo14_resources),\n\t\t.resources = ldo14_resources,\n\t},\n};\n\nstatic struct mfd_cell touch_devs[] = {\n\t{\"88pm860x-touch\", -1,},\n};\n\nstatic struct mfd_cell onkey_devs[] = {\n\t{\"88pm860x-onkey\", -1,},\n};\n\nstatic struct mfd_cell codec_devs[] = {\n\t{\"88pm860x-codec\", -1,},\n};\n\nstatic struct regulator_consumer_supply preg_supply[] = {\n\tREGULATOR_SUPPLY(\"preg\", \"charger-manager\"),\n};\n\nstatic struct regulator_init_data preg_init_data = {\n\t.num_consumer_supplies\t= ARRAY_SIZE(preg_supply),\n\t.consumer_supplies\t= &preg_supply[0],\n};\n\nstatic struct charger_regulator chg_desc_regulator_data[] = {\n\t{ .regulator_name = \"preg\", },\n};\n\nstatic struct mfd_cell power_devs[] = {\n\t{\"88pm860x-battery\", -1,},\n\t{\"88pm860x-charger\", -1,},\n\t{\"88pm860x-preg\",    -1,},\n\t{\"charger-manager\", -1,},\n};\n\nstatic struct mfd_cell rtc_devs[] = {\n\t{\"88pm860x-rtc\", -1,},\n};\n\n\nstruct pm860x_irq_data {\n\tint\treg;\n\tint\tmask_reg;\n\tint\tenable;\t\t \n\tint\toffs;\t\t \n};\n\nstatic struct pm860x_irq_data pm860x_irqs[] = {\n\t[PM8607_IRQ_ONKEY] = {\n\t\t.reg\t\t= PM8607_INT_STATUS1,\n\t\t.mask_reg\t= PM8607_INT_MASK_1,\n\t\t.offs\t\t= 1 << 0,\n\t},\n\t[PM8607_IRQ_EXTON] = {\n\t\t.reg\t\t= PM8607_INT_STATUS1,\n\t\t.mask_reg\t= PM8607_INT_MASK_1,\n\t\t.offs\t\t= 1 << 1,\n\t},\n\t[PM8607_IRQ_CHG] = {\n\t\t.reg\t\t= PM8607_INT_STATUS1,\n\t\t.mask_reg\t= PM8607_INT_MASK_1,\n\t\t.offs\t\t= 1 << 2,\n\t},\n\t[PM8607_IRQ_BAT] = {\n\t\t.reg\t\t= PM8607_INT_STATUS1,\n\t\t.mask_reg\t= PM8607_INT_MASK_1,\n\t\t.offs\t\t= 1 << 3,\n\t},\n\t[PM8607_IRQ_RTC] = {\n\t\t.reg\t\t= PM8607_INT_STATUS1,\n\t\t.mask_reg\t= PM8607_INT_MASK_1,\n\t\t.offs\t\t= 1 << 4,\n\t},\n\t[PM8607_IRQ_CC] = {\n\t\t.reg\t\t= PM8607_INT_STATUS1,\n\t\t.mask_reg\t= PM8607_INT_MASK_1,\n\t\t.offs\t\t= 1 << 5,\n\t},\n\t[PM8607_IRQ_VBAT] = {\n\t\t.reg\t\t= PM8607_INT_STATUS2,\n\t\t.mask_reg\t= PM8607_INT_MASK_2,\n\t\t.offs\t\t= 1 << 0,\n\t},\n\t[PM8607_IRQ_VCHG] = {\n\t\t.reg\t\t= PM8607_INT_STATUS2,\n\t\t.mask_reg\t= PM8607_INT_MASK_2,\n\t\t.offs\t\t= 1 << 1,\n\t},\n\t[PM8607_IRQ_VSYS] = {\n\t\t.reg\t\t= PM8607_INT_STATUS2,\n\t\t.mask_reg\t= PM8607_INT_MASK_2,\n\t\t.offs\t\t= 1 << 2,\n\t},\n\t[PM8607_IRQ_TINT] = {\n\t\t.reg\t\t= PM8607_INT_STATUS2,\n\t\t.mask_reg\t= PM8607_INT_MASK_2,\n\t\t.offs\t\t= 1 << 3,\n\t},\n\t[PM8607_IRQ_GPADC0] = {\n\t\t.reg\t\t= PM8607_INT_STATUS2,\n\t\t.mask_reg\t= PM8607_INT_MASK_2,\n\t\t.offs\t\t= 1 << 4,\n\t},\n\t[PM8607_IRQ_GPADC1] = {\n\t\t.reg\t\t= PM8607_INT_STATUS2,\n\t\t.mask_reg\t= PM8607_INT_MASK_2,\n\t\t.offs\t\t= 1 << 5,\n\t},\n\t[PM8607_IRQ_GPADC2] = {\n\t\t.reg\t\t= PM8607_INT_STATUS2,\n\t\t.mask_reg\t= PM8607_INT_MASK_2,\n\t\t.offs\t\t= 1 << 6,\n\t},\n\t[PM8607_IRQ_GPADC3] = {\n\t\t.reg\t\t= PM8607_INT_STATUS2,\n\t\t.mask_reg\t= PM8607_INT_MASK_2,\n\t\t.offs\t\t= 1 << 7,\n\t},\n\t[PM8607_IRQ_AUDIO_SHORT] = {\n\t\t.reg\t\t= PM8607_INT_STATUS3,\n\t\t.mask_reg\t= PM8607_INT_MASK_3,\n\t\t.offs\t\t= 1 << 0,\n\t},\n\t[PM8607_IRQ_PEN] = {\n\t\t.reg\t\t= PM8607_INT_STATUS3,\n\t\t.mask_reg\t= PM8607_INT_MASK_3,\n\t\t.offs\t\t= 1 << 1,\n\t},\n\t[PM8607_IRQ_HEADSET] = {\n\t\t.reg\t\t= PM8607_INT_STATUS3,\n\t\t.mask_reg\t= PM8607_INT_MASK_3,\n\t\t.offs\t\t= 1 << 2,\n\t},\n\t[PM8607_IRQ_HOOK] = {\n\t\t.reg\t\t= PM8607_INT_STATUS3,\n\t\t.mask_reg\t= PM8607_INT_MASK_3,\n\t\t.offs\t\t= 1 << 3,\n\t},\n\t[PM8607_IRQ_MICIN] = {\n\t\t.reg\t\t= PM8607_INT_STATUS3,\n\t\t.mask_reg\t= PM8607_INT_MASK_3,\n\t\t.offs\t\t= 1 << 4,\n\t},\n\t[PM8607_IRQ_CHG_FAIL] = {\n\t\t.reg\t\t= PM8607_INT_STATUS3,\n\t\t.mask_reg\t= PM8607_INT_MASK_3,\n\t\t.offs\t\t= 1 << 5,\n\t},\n\t[PM8607_IRQ_CHG_DONE] = {\n\t\t.reg\t\t= PM8607_INT_STATUS3,\n\t\t.mask_reg\t= PM8607_INT_MASK_3,\n\t\t.offs\t\t= 1 << 6,\n\t},\n\t[PM8607_IRQ_CHG_FAULT] = {\n\t\t.reg\t\t= PM8607_INT_STATUS3,\n\t\t.mask_reg\t= PM8607_INT_MASK_3,\n\t\t.offs\t\t= 1 << 7,\n\t},\n};\n\nstatic irqreturn_t pm860x_irq(int irq, void *data)\n{\n\tstruct pm860x_chip *chip = data;\n\tstruct pm860x_irq_data *irq_data;\n\tstruct i2c_client *i2c;\n\tint read_reg = -1, value = 0;\n\tint i;\n\n\ti2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;\n\tfor (i = 0; i < ARRAY_SIZE(pm860x_irqs); i++) {\n\t\tirq_data = &pm860x_irqs[i];\n\t\tif (read_reg != irq_data->reg) {\n\t\t\tread_reg = irq_data->reg;\n\t\t\tvalue = pm860x_reg_read(i2c, irq_data->reg);\n\t\t}\n\t\tif (value & irq_data->enable)\n\t\t\thandle_nested_irq(chip->irq_base + i);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void pm860x_irq_lock(struct irq_data *data)\n{\n\tstruct pm860x_chip *chip = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&chip->irq_lock);\n}\n\nstatic void pm860x_irq_sync_unlock(struct irq_data *data)\n{\n\tstruct pm860x_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct pm860x_irq_data *irq_data;\n\tstruct i2c_client *i2c;\n\tstatic unsigned char cached[3] = {0x0, 0x0, 0x0};\n\tunsigned char mask[3];\n\tint i;\n\n\ti2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tmask[i] = cached[i];\n\tfor (i = 0; i < ARRAY_SIZE(pm860x_irqs); i++) {\n\t\tirq_data = &pm860x_irqs[i];\n\t\tswitch (irq_data->mask_reg) {\n\t\tcase PM8607_INT_MASK_1:\n\t\t\tmask[0] &= ~irq_data->offs;\n\t\t\tmask[0] |= irq_data->enable;\n\t\t\tbreak;\n\t\tcase PM8607_INT_MASK_2:\n\t\t\tmask[1] &= ~irq_data->offs;\n\t\t\tmask[1] |= irq_data->enable;\n\t\t\tbreak;\n\t\tcase PM8607_INT_MASK_3:\n\t\t\tmask[2] &= ~irq_data->offs;\n\t\t\tmask[2] |= irq_data->enable;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(chip->dev, \"wrong IRQ\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tif (mask[i] != cached[i]) {\n\t\t\tcached[i] = mask[i];\n\t\t\tpm860x_reg_write(i2c, PM8607_INT_MASK_1 + i, mask[i]);\n\t\t}\n\t}\n\n\tmutex_unlock(&chip->irq_lock);\n}\n\nstatic void pm860x_irq_enable(struct irq_data *data)\n{\n\tpm860x_irqs[data->hwirq].enable = pm860x_irqs[data->hwirq].offs;\n}\n\nstatic void pm860x_irq_disable(struct irq_data *data)\n{\n\tpm860x_irqs[data->hwirq].enable = 0;\n}\n\nstatic struct irq_chip pm860x_irq_chip = {\n\t.name\t\t= \"88pm860x\",\n\t.irq_bus_lock\t= pm860x_irq_lock,\n\t.irq_bus_sync_unlock = pm860x_irq_sync_unlock,\n\t.irq_enable\t= pm860x_irq_enable,\n\t.irq_disable\t= pm860x_irq_disable,\n};\n\nstatic int pm860x_irq_domain_map(struct irq_domain *d, unsigned int virq,\n\t\t\t\t irq_hw_number_t hw)\n{\n\tirq_set_chip_data(virq, d->host_data);\n\tirq_set_chip_and_handler(virq, &pm860x_irq_chip, handle_edge_irq);\n\tirq_set_nested_thread(virq, 1);\n\tirq_set_noprobe(virq);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops pm860x_irq_domain_ops = {\n\t.map\t= pm860x_irq_domain_map,\n\t.xlate\t= irq_domain_xlate_onetwocell,\n};\n\nstatic int device_irq_init(struct pm860x_chip *chip,\n\t\t\t\t     struct pm860x_platform_data *pdata)\n{\n\tstruct i2c_client *i2c = (chip->id == CHIP_PM8607) ?\n\t\tchip->client : chip->companion;\n\tunsigned char status_buf[INT_STATUS_NUM];\n\tunsigned long flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;\n\tint data, mask, ret = -EINVAL;\n\tint nr_irqs, irq_base = -1;\n\tstruct device_node *node = i2c->dev.of_node;\n\n\tmask = PM8607_B0_MISC1_INV_INT | PM8607_B0_MISC1_INT_CLEAR\n\t\t| PM8607_B0_MISC1_INT_MASK;\n\tdata = 0;\n\tchip->irq_mode = 0;\n\tif (pdata && pdata->irq_mode) {\n\t\t \n\t\tdata |= PM8607_B0_MISC1_INT_CLEAR;\n\t\tchip->irq_mode = 1;\n\t}\n\tret = pm860x_set_bits(i2c, PM8607_B0_MISC1, mask, data);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tmemset(status_buf, 0, INT_STATUS_NUM);\n\tret = pm860x_bulk_write(i2c, PM8607_INT_MASK_1,\n\t\t\t\tINT_STATUS_NUM, status_buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (chip->irq_mode) {\n\t\t \n\t\tmemset(status_buf, 0xFF, INT_STATUS_NUM);\n\t\tret = pm860x_bulk_write(i2c, PM8607_INT_STATUS1,\n\t\t\t\t\tINT_STATUS_NUM, status_buf);\n\t} else {\n\t\t \n\t\tret = pm860x_bulk_read(i2c, PM8607_INT_STATUS1,\n\t\t\t\t\tINT_STATUS_NUM, status_buf);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmutex_init(&chip->irq_lock);\n\n\tif (pdata && pdata->irq_base)\n\t\tirq_base = pdata->irq_base;\n\tnr_irqs = ARRAY_SIZE(pm860x_irqs);\n\tchip->irq_base = irq_alloc_descs(irq_base, 0, nr_irqs, 0);\n\tif (chip->irq_base < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to allocate interrupts, ret:%d\\n\",\n\t\t\tchip->irq_base);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tirq_domain_add_legacy(node, nr_irqs, chip->irq_base, 0,\n\t\t\t      &pm860x_irq_domain_ops, chip);\n\tchip->core_irq = i2c->irq;\n\tif (!chip->core_irq)\n\t\tgoto out;\n\n\tret = request_threaded_irq(chip->core_irq, NULL, pm860x_irq,\n\t\t\t\t   flags | IRQF_ONESHOT, \"88pm860x\", chip);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to request IRQ: %d\\n\", ret);\n\t\tchip->core_irq = 0;\n\t}\n\n\treturn 0;\nout:\n\tchip->core_irq = 0;\n\treturn ret;\n}\n\nstatic void device_irq_exit(struct pm860x_chip *chip)\n{\n\tif (chip->core_irq)\n\t\tfree_irq(chip->core_irq, chip);\n}\n\nint pm8606_osc_enable(struct pm860x_chip *chip, unsigned short client)\n{\n\tint ret = -EIO;\n\tstruct i2c_client *i2c = (chip->id == CHIP_PM8606) ?\n\t\tchip->client : chip->companion;\n\n\tdev_dbg(chip->dev, \"%s(B): client=0x%x\\n\", __func__, client);\n\tdev_dbg(chip->dev, \"%s(B): vote=0x%x status=%d\\n\",\n\t\t\t__func__, chip->osc_vote,\n\t\t\tchip->osc_status);\n\n\tmutex_lock(&chip->osc_lock);\n\t \n\tchip->osc_vote |= client;\n\t \n\tif (chip->osc_status != PM8606_REF_GP_OSC_ON) {\n\t\tchip->osc_status = PM8606_REF_GP_OSC_UNKNOWN;\n\t\t \n\t\tif (pm860x_set_bits(i2c, PM8606_VSYS,\n\t\t\t\tPM8606_VSYS_EN, PM8606_VSYS_EN))\n\t\t\tgoto out;\n\n\t\t \n\t\tif (pm860x_set_bits(i2c, PM8606_MISC,\n\t\t\t\tPM8606_MISC_OSC_EN, PM8606_MISC_OSC_EN))\n\t\t\tgoto out;\n\t\t \n\t\tchip->osc_status = PM8606_REF_GP_OSC_ON;\n\t}\n\tmutex_unlock(&chip->osc_lock);\n\n\tdev_dbg(chip->dev, \"%s(A): vote=0x%x status=%d ret=%d\\n\",\n\t\t\t__func__, chip->osc_vote,\n\t\t\tchip->osc_status, ret);\n\treturn 0;\nout:\n\tmutex_unlock(&chip->osc_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(pm8606_osc_enable);\n\nint pm8606_osc_disable(struct pm860x_chip *chip, unsigned short client)\n{\n\tint ret = -EIO;\n\tstruct i2c_client *i2c = (chip->id == CHIP_PM8606) ?\n\t\tchip->client : chip->companion;\n\n\tdev_dbg(chip->dev, \"%s(B): client=0x%x\\n\", __func__, client);\n\tdev_dbg(chip->dev, \"%s(B): vote=0x%x status=%d\\n\",\n\t\t\t__func__, chip->osc_vote,\n\t\t\tchip->osc_status);\n\n\tmutex_lock(&chip->osc_lock);\n\t \n\tchip->osc_vote &= ~(client);\n\t \n\tif ((chip->osc_status != PM8606_REF_GP_OSC_OFF) &&\n\t\t\t(chip->osc_vote == REF_GP_NO_CLIENTS)) {\n\t\tchip->osc_status = PM8606_REF_GP_OSC_UNKNOWN;\n\t\t \n\t\tif (pm860x_set_bits(i2c, PM8606_VSYS, PM8606_VSYS_EN, 0))\n\t\t\tgoto out;\n\t\t \n\t\tif (pm860x_set_bits(i2c, PM8606_MISC, PM8606_MISC_OSC_EN, 0))\n\t\t\tgoto out;\n\t\tchip->osc_status = PM8606_REF_GP_OSC_OFF;\n\t}\n\tmutex_unlock(&chip->osc_lock);\n\n\tdev_dbg(chip->dev, \"%s(A): vote=0x%x status=%d ret=%d\\n\",\n\t\t\t__func__, chip->osc_vote,\n\t\t\tchip->osc_status, ret);\n\treturn 0;\nout:\n\tmutex_unlock(&chip->osc_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(pm8606_osc_disable);\n\nstatic void device_osc_init(struct i2c_client *i2c)\n{\n\tstruct pm860x_chip *chip = i2c_get_clientdata(i2c);\n\n\tmutex_init(&chip->osc_lock);\n\t \n\t \n\tpm860x_set_bits(i2c, PM8606_VSYS, PM8606_VSYS_EN, 0);\n\t \n\tpm860x_set_bits(i2c, PM8606_MISC, PM8606_MISC_OSC_EN, 0);\n\n\tchip->osc_vote = REF_GP_NO_CLIENTS;\n\tchip->osc_status = PM8606_REF_GP_OSC_OFF;\n}\n\nstatic void device_bk_init(struct pm860x_chip *chip,\n\t\t\t\t     struct pm860x_platform_data *pdata)\n{\n\tint ret, i;\n\n\tif (pdata && pdata->backlight) {\n\t\tif (pdata->num_backlights > ARRAY_SIZE(bk_devs))\n\t\t\tpdata->num_backlights = ARRAY_SIZE(bk_devs);\n\t\tfor (i = 0; i < pdata->num_backlights; i++) {\n\t\t\tbk_devs[i].platform_data = &pdata->backlight[i];\n\t\t\tbk_devs[i].pdata_size =\n\t\t\t\tsizeof(struct pm860x_backlight_pdata);\n\t\t}\n\t}\n\tret = mfd_add_devices(chip->dev, 0, bk_devs,\n\t\t\t      ARRAY_SIZE(bk_devs), NULL, 0, NULL);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to add backlight subdev\\n\");\n}\n\nstatic void device_led_init(struct pm860x_chip *chip,\n\t\t\t\t      struct pm860x_platform_data *pdata)\n{\n\tint ret, i;\n\n\tif (pdata && pdata->led) {\n\t\tif (pdata->num_leds > ARRAY_SIZE(led_devs))\n\t\t\tpdata->num_leds = ARRAY_SIZE(led_devs);\n\t\tfor (i = 0; i < pdata->num_leds; i++) {\n\t\t\tled_devs[i].platform_data = &pdata->led[i];\n\t\t\tled_devs[i].pdata_size =\n\t\t\t\tsizeof(struct pm860x_led_pdata);\n\t\t}\n\t}\n\tret = mfd_add_devices(chip->dev, 0, led_devs,\n\t\t\t      ARRAY_SIZE(led_devs), NULL, 0, NULL);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to add led subdev\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void device_regulator_init(struct pm860x_chip *chip,\n\t\t\t\t\t    struct pm860x_platform_data *pdata)\n{\n\tint ret;\n\n\tif (pdata == NULL)\n\t\treturn;\n\tif (pdata->buck1) {\n\t\treg_devs[0].platform_data = pdata->buck1;\n\t\treg_devs[0].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->buck2) {\n\t\treg_devs[1].platform_data = pdata->buck2;\n\t\treg_devs[1].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->buck3) {\n\t\treg_devs[2].platform_data = pdata->buck3;\n\t\treg_devs[2].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo1) {\n\t\treg_devs[3].platform_data = pdata->ldo1;\n\t\treg_devs[3].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo2) {\n\t\treg_devs[4].platform_data = pdata->ldo2;\n\t\treg_devs[4].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo3) {\n\t\treg_devs[5].platform_data = pdata->ldo3;\n\t\treg_devs[5].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo4) {\n\t\treg_devs[6].platform_data = pdata->ldo4;\n\t\treg_devs[6].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo5) {\n\t\treg_devs[7].platform_data = pdata->ldo5;\n\t\treg_devs[7].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo6) {\n\t\treg_devs[8].platform_data = pdata->ldo6;\n\t\treg_devs[8].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo7) {\n\t\treg_devs[9].platform_data = pdata->ldo7;\n\t\treg_devs[9].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo8) {\n\t\treg_devs[10].platform_data = pdata->ldo8;\n\t\treg_devs[10].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo9) {\n\t\treg_devs[11].platform_data = pdata->ldo9;\n\t\treg_devs[11].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo10) {\n\t\treg_devs[12].platform_data = pdata->ldo10;\n\t\treg_devs[12].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo12) {\n\t\treg_devs[13].platform_data = pdata->ldo12;\n\t\treg_devs[13].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo_vibrator) {\n\t\treg_devs[14].platform_data = pdata->ldo_vibrator;\n\t\treg_devs[14].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tif (pdata->ldo14) {\n\t\treg_devs[15].platform_data = pdata->ldo14;\n\t\treg_devs[15].pdata_size = sizeof(struct regulator_init_data);\n\t}\n\tret = mfd_add_devices(chip->dev, 0, reg_devs,\n\t\t\t      ARRAY_SIZE(reg_devs), NULL, 0, NULL);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to add regulator subdev\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void device_rtc_init(struct pm860x_chip *chip,\n\t\t\t\t      struct pm860x_platform_data *pdata)\n{\n\tint ret;\n\n\tif (!pdata)\n\t\treturn;\n\n\trtc_devs[0].platform_data = pdata->rtc;\n\trtc_devs[0].pdata_size = sizeof(struct pm860x_rtc_pdata);\n\trtc_devs[0].num_resources = ARRAY_SIZE(rtc_resources);\n\trtc_devs[0].resources = &rtc_resources[0];\n\tret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],\n\t\t\t      ARRAY_SIZE(rtc_devs), &rtc_resources[0],\n\t\t\t      chip->irq_base, NULL);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to add rtc subdev\\n\");\n}\n\nstatic void device_touch_init(struct pm860x_chip *chip,\n\t\t\t\t\tstruct pm860x_platform_data *pdata)\n{\n\tint ret;\n\n\tif (pdata == NULL)\n\t\treturn;\n\n\ttouch_devs[0].platform_data = pdata->touch;\n\ttouch_devs[0].pdata_size = sizeof(struct pm860x_touch_pdata);\n\ttouch_devs[0].num_resources = ARRAY_SIZE(touch_resources);\n\ttouch_devs[0].resources = &touch_resources[0];\n\tret = mfd_add_devices(chip->dev, 0, &touch_devs[0],\n\t\t\t      ARRAY_SIZE(touch_devs), &touch_resources[0],\n\t\t\t      chip->irq_base, NULL);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to add touch subdev\\n\");\n}\n\nstatic void device_power_init(struct pm860x_chip *chip,\n\t\t\t\t\tstruct pm860x_platform_data *pdata)\n{\n\tint ret;\n\n\tif (pdata == NULL)\n\t\treturn;\n\n\tpower_devs[0].platform_data = pdata->power;\n\tpower_devs[0].pdata_size = sizeof(struct pm860x_power_pdata);\n\tpower_devs[0].num_resources = ARRAY_SIZE(battery_resources);\n\tpower_devs[0].resources = &battery_resources[0],\n\tret = mfd_add_devices(chip->dev, 0, &power_devs[0], 1,\n\t\t\t      &battery_resources[0], chip->irq_base, NULL);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to add battery subdev\\n\");\n\n\tpower_devs[1].platform_data = pdata->power;\n\tpower_devs[1].pdata_size = sizeof(struct pm860x_power_pdata);\n\tpower_devs[1].num_resources = ARRAY_SIZE(charger_resources);\n\tpower_devs[1].resources = &charger_resources[0],\n\tret = mfd_add_devices(chip->dev, 0, &power_devs[1], 1,\n\t\t\t      &charger_resources[0], chip->irq_base, NULL);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to add charger subdev\\n\");\n\n\tpower_devs[2].platform_data = &preg_init_data;\n\tpower_devs[2].pdata_size = sizeof(struct regulator_init_data);\n\tret = mfd_add_devices(chip->dev, 0, &power_devs[2], 1,\n\t\t\t      NULL, chip->irq_base, NULL);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to add preg subdev\\n\");\n\n\tif (pdata->chg_desc) {\n\t\tpdata->chg_desc->charger_regulators =\n\t\t\t&chg_desc_regulator_data[0];\n\t\tpdata->chg_desc->num_charger_regulators\t=\n\t\t\tARRAY_SIZE(chg_desc_regulator_data),\n\t\tpower_devs[3].platform_data = pdata->chg_desc;\n\t\tpower_devs[3].pdata_size = sizeof(*pdata->chg_desc);\n\t\tret = mfd_add_devices(chip->dev, 0, &power_devs[3], 1,\n\t\t\t\t      NULL, chip->irq_base, NULL);\n\t\tif (ret < 0)\n\t\t\tdev_err(chip->dev, \"Failed to add chg-manager subdev\\n\");\n\t}\n}\n\nstatic void device_onkey_init(struct pm860x_chip *chip,\n\t\t\t\t\tstruct pm860x_platform_data *pdata)\n{\n\tint ret;\n\n\tonkey_devs[0].num_resources = ARRAY_SIZE(onkey_resources);\n\tonkey_devs[0].resources = &onkey_resources[0],\n\tret = mfd_add_devices(chip->dev, 0, &onkey_devs[0],\n\t\t\t      ARRAY_SIZE(onkey_devs), &onkey_resources[0],\n\t\t\t      chip->irq_base, NULL);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to add onkey subdev\\n\");\n}\n\nstatic void device_codec_init(struct pm860x_chip *chip,\n\t\t\t\t\tstruct pm860x_platform_data *pdata)\n{\n\tint ret;\n\n\tcodec_devs[0].num_resources = ARRAY_SIZE(codec_resources);\n\tcodec_devs[0].resources = &codec_resources[0],\n\tret = mfd_add_devices(chip->dev, 0, &codec_devs[0],\n\t\t\t      ARRAY_SIZE(codec_devs), &codec_resources[0], 0,\n\t\t\t      NULL);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to add codec subdev\\n\");\n}\n\nstatic void device_8607_init(struct pm860x_chip *chip,\n\t\t\t\t       struct i2c_client *i2c,\n\t\t\t\t       struct pm860x_platform_data *pdata)\n{\n\tint data, ret;\n\n\tret = pm860x_reg_read(i2c, PM8607_CHIP_ID);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to read CHIP ID: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tswitch (ret & PM8607_VERSION_MASK) {\n\tcase 0x40:\n\tcase 0x50:\n\t\tdev_info(chip->dev, \"Marvell 88PM8607 (ID: %02x) detected\\n\",\n\t\t\t ret);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->dev,\n\t\t\t\"Failed to detect Marvell 88PM8607. Chip ID: %02x\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tret = pm860x_reg_read(i2c, PM8607_BUCK3);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to read BUCK3 register: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (ret & PM8607_BUCK3_DOUBLE)\n\t\tchip->buck3_double = 1;\n\n\tret = pm860x_reg_read(i2c, PM8607_B0_MISC1);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to read MISC1 register: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (pdata && (pdata->i2c_port == PI2C_PORT))\n\t\tdata = PM8607_B0_MISC1_PI2C;\n\telse\n\t\tdata = 0;\n\tret = pm860x_set_bits(i2c, PM8607_B0_MISC1, PM8607_B0_MISC1_PI2C, data);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to access MISC1:%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = device_irq_init(chip, pdata);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdevice_regulator_init(chip, pdata);\n\tdevice_rtc_init(chip, pdata);\n\tdevice_onkey_init(chip, pdata);\n\tdevice_touch_init(chip, pdata);\n\tdevice_power_init(chip, pdata);\n\tdevice_codec_init(chip, pdata);\nout:\n\treturn;\n}\n\nstatic void device_8606_init(struct pm860x_chip *chip,\n\t\t\t\t       struct i2c_client *i2c,\n\t\t\t\t       struct pm860x_platform_data *pdata)\n{\n\tdevice_osc_init(i2c);\n\tdevice_bk_init(chip, pdata);\n\tdevice_led_init(chip, pdata);\n}\n\nstatic int pm860x_device_init(struct pm860x_chip *chip,\n\t\t\t\t\tstruct pm860x_platform_data *pdata)\n{\n\tchip->core_irq = 0;\n\n\tswitch (chip->id) {\n\tcase CHIP_PM8606:\n\t\tdevice_8606_init(chip, chip->client, pdata);\n\t\tbreak;\n\tcase CHIP_PM8607:\n\t\tdevice_8607_init(chip, chip->client, pdata);\n\t\tbreak;\n\t}\n\n\tif (chip->companion) {\n\t\tswitch (chip->id) {\n\t\tcase CHIP_PM8607:\n\t\t\tdevice_8606_init(chip, chip->companion, pdata);\n\t\t\tbreak;\n\t\tcase CHIP_PM8606:\n\t\t\tdevice_8607_init(chip, chip->companion, pdata);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void pm860x_device_exit(struct pm860x_chip *chip)\n{\n\tdevice_irq_exit(chip);\n\tmfd_remove_devices(chip->dev);\n}\n\nstatic int verify_addr(struct i2c_client *i2c)\n{\n\tunsigned short addr_8607[] = {0x30, 0x34};\n\tunsigned short addr_8606[] = {0x10, 0x11};\n\tint size, i;\n\n\tif (i2c == NULL)\n\t\treturn 0;\n\tsize = ARRAY_SIZE(addr_8606);\n\tfor (i = 0; i < size; i++) {\n\t\tif (i2c->addr == *(addr_8606 + i))\n\t\t\treturn CHIP_PM8606;\n\t}\n\tsize = ARRAY_SIZE(addr_8607);\n\tfor (i = 0; i < size; i++) {\n\t\tif (i2c->addr == *(addr_8607 + i))\n\t\t\treturn CHIP_PM8607;\n\t}\n\treturn 0;\n}\n\nstatic const struct regmap_config pm860x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int pm860x_dt_init(struct device_node *np,\n\t\t\t\t    struct device *dev,\n\t\t\t\t    struct pm860x_platform_data *pdata)\n{\n\tint ret;\n\n\tpdata->irq_mode = of_property_read_bool(np, \"marvell,88pm860x-irq-read-clr\");\n\tret = of_property_read_u32(np, \"marvell,88pm860x-slave-addr\",\n\t\t\t\t   &pdata->companion_addr);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Not found \\\"marvell,88pm860x-slave-addr\\\" property\\n\");\n\t\tpdata->companion_addr = 0;\n\t}\n\treturn 0;\n}\n\nstatic int pm860x_probe(struct i2c_client *client)\n{\n\tstruct pm860x_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct device_node *node = client->dev.of_node;\n\tstruct pm860x_chip *chip;\n\tint ret;\n\n\tif (node && !pdata) {\n\t\t \n\t\tpdata = devm_kzalloc(&client->dev,\n\t\t\t\t     sizeof(struct pm860x_platform_data),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\t\tret = pm860x_dt_init(node, &client->dev, pdata);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (!pdata) {\n\t\tpr_info(\"No platform data in %s!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tchip = devm_kzalloc(&client->dev,\n\t\t\t    sizeof(struct pm860x_chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\n\tchip->id = verify_addr(client);\n\tchip->regmap = devm_regmap_init_i2c(client, &pm860x_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\tret = PTR_ERR(chip->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\tchip->client = client;\n\ti2c_set_clientdata(client, chip);\n\tchip->dev = &client->dev;\n\n\t \n\tif (pdata->companion_addr && (pdata->companion_addr != client->addr)) {\n\t\tchip->companion_addr = pdata->companion_addr;\n\t\tchip->companion = i2c_new_dummy_device(chip->client->adapter,\n\t\t\t\t\t\tchip->companion_addr);\n\t\tif (IS_ERR(chip->companion)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to allocate I2C companion device\\n\");\n\t\t\treturn PTR_ERR(chip->companion);\n\t\t}\n\t\tchip->regmap_companion = regmap_init_i2c(chip->companion,\n\t\t\t\t\t\t\t&pm860x_regmap_config);\n\t\tif (IS_ERR(chip->regmap_companion)) {\n\t\t\tret = PTR_ERR(chip->regmap_companion);\n\t\t\tdev_err(&chip->companion->dev,\n\t\t\t\t\"Failed to allocate register map: %d\\n\", ret);\n\t\t\ti2c_unregister_device(chip->companion);\n\t\t\treturn ret;\n\t\t}\n\t\ti2c_set_clientdata(chip->companion, chip);\n\t}\n\n\tpm860x_device_init(chip, pdata);\n\treturn 0;\n}\n\nstatic void pm860x_remove(struct i2c_client *client)\n{\n\tstruct pm860x_chip *chip = i2c_get_clientdata(client);\n\n\tpm860x_device_exit(chip);\n\tif (chip->companion) {\n\t\tregmap_exit(chip->regmap_companion);\n\t\ti2c_unregister_device(chip->companion);\n\t}\n}\n\nstatic int pm860x_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pm860x_chip *chip = i2c_get_clientdata(client);\n\n\tif (device_may_wakeup(dev) && chip->wakeup_flag)\n\t\tenable_irq_wake(chip->core_irq);\n\treturn 0;\n}\n\nstatic int pm860x_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pm860x_chip *chip = i2c_get_clientdata(client);\n\n\tif (device_may_wakeup(dev) && chip->wakeup_flag)\n\t\tdisable_irq_wake(chip->core_irq);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pm860x_pm_ops, pm860x_suspend, pm860x_resume);\n\nstatic const struct i2c_device_id pm860x_id_table[] = {\n\t{ \"88PM860x\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, pm860x_id_table);\n\nstatic const struct of_device_id pm860x_dt_ids[] = {\n\t{ .compatible = \"marvell,88pm860x\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pm860x_dt_ids);\n\nstatic struct i2c_driver pm860x_driver = {\n\t.driver\t= {\n\t\t.name\t= \"88PM860x\",\n\t\t.pm     = pm_sleep_ptr(&pm860x_pm_ops),\n\t\t.of_match_table\t= pm860x_dt_ids,\n\t},\n\t.probe\t\t= pm860x_probe,\n\t.remove\t\t= pm860x_remove,\n\t.id_table\t= pm860x_id_table,\n};\n\nstatic int __init pm860x_i2c_init(void)\n{\n\tint ret;\n\n\tret = i2c_add_driver(&pm860x_driver);\n\tif (ret != 0)\n\t\tpr_err(\"Failed to register 88PM860x I2C driver: %d\\n\", ret);\n\treturn ret;\n}\nsubsys_initcall(pm860x_i2c_init);\n\nstatic void __exit pm860x_i2c_exit(void)\n{\n\ti2c_del_driver(&pm860x_driver);\n}\nmodule_exit(pm860x_i2c_exit);\n\nMODULE_DESCRIPTION(\"PMIC Driver for Marvell 88PM860x\");\nMODULE_AUTHOR(\"Haojian Zhuang <haojian.zhuang@marvell.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}