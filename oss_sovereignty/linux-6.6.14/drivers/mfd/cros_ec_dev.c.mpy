{
  "module_name": "cros_ec_dev.c",
  "hash_id": "eda3eb23d811d96cf7ad5047fceaec2bc94a61141eb84e59327bae75c23b3664",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/cros_ec_dev.c",
  "human_readable_source": "\n \n\n#include <linux/dmi.h>\n#include <linux/kconfig.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/cros_ec_chardev.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/slab.h>\n\n#define DRV_NAME \"cros-ec-dev\"\n\nstatic struct class cros_class = {\n\t.name           = \"chromeos\",\n};\n\n \nstruct cros_feature_to_name {\n\tunsigned int id;\n\tconst char *name;\n\tconst char *desc;\n};\n\n \nstruct cros_feature_to_cells {\n\tunsigned int id;\n\tconst struct mfd_cell *mfd_cells;\n\tunsigned int num_cells;\n};\n\nstatic const struct cros_feature_to_name cros_mcu_devices[] = {\n\t{\n\t\t.id\t= EC_FEATURE_FINGERPRINT,\n\t\t.name\t= CROS_EC_DEV_FP_NAME,\n\t\t.desc\t= \"Fingerprint\",\n\t},\n\t{\n\t\t.id\t= EC_FEATURE_ISH,\n\t\t.name\t= CROS_EC_DEV_ISH_NAME,\n\t\t.desc\t= \"Integrated Sensor Hub\",\n\t},\n\t{\n\t\t.id\t= EC_FEATURE_SCP,\n\t\t.name\t= CROS_EC_DEV_SCP_NAME,\n\t\t.desc\t= \"System Control Processor\",\n\t},\n\t{\n\t\t.id\t= EC_FEATURE_TOUCHPAD,\n\t\t.name\t= CROS_EC_DEV_TP_NAME,\n\t\t.desc\t= \"Touchpad\",\n\t},\n};\n\nstatic const struct mfd_cell cros_ec_cec_cells[] = {\n\t{ .name = \"cros-ec-cec\", },\n};\n\nstatic const struct mfd_cell cros_ec_rtc_cells[] = {\n\t{ .name = \"cros-ec-rtc\", },\n};\n\nstatic const struct mfd_cell cros_ec_sensorhub_cells[] = {\n\t{ .name = \"cros-ec-sensorhub\", },\n};\n\nstatic const struct mfd_cell cros_usbpd_charger_cells[] = {\n\t{ .name = \"cros-usbpd-charger\", },\n\t{ .name = \"cros-usbpd-logger\", },\n};\n\nstatic const struct mfd_cell cros_usbpd_notify_cells[] = {\n\t{ .name = \"cros-usbpd-notify\", },\n};\n\nstatic const struct cros_feature_to_cells cros_subdevices[] = {\n\t{\n\t\t.id\t\t= EC_FEATURE_CEC,\n\t\t.mfd_cells\t= cros_ec_cec_cells,\n\t\t.num_cells\t= ARRAY_SIZE(cros_ec_cec_cells),\n\t},\n\t{\n\t\t.id\t\t= EC_FEATURE_RTC,\n\t\t.mfd_cells\t= cros_ec_rtc_cells,\n\t\t.num_cells\t= ARRAY_SIZE(cros_ec_rtc_cells),\n\t},\n\t{\n\t\t.id\t\t= EC_FEATURE_USB_PD,\n\t\t.mfd_cells\t= cros_usbpd_charger_cells,\n\t\t.num_cells\t= ARRAY_SIZE(cros_usbpd_charger_cells),\n\t},\n};\n\nstatic const struct mfd_cell cros_ec_platform_cells[] = {\n\t{ .name = \"cros-ec-chardev\", },\n\t{ .name = \"cros-ec-debugfs\", },\n\t{ .name = \"cros-ec-sysfs\", },\n};\n\nstatic const struct mfd_cell cros_ec_pchg_cells[] = {\n\t{ .name = \"cros-ec-pchg\", },\n};\n\nstatic const struct mfd_cell cros_ec_lightbar_cells[] = {\n\t{ .name = \"cros-ec-lightbar\", }\n};\n\nstatic const struct mfd_cell cros_ec_vbc_cells[] = {\n\t{ .name = \"cros-ec-vbc\", }\n};\n\nstatic void cros_ec_class_release(struct device *dev)\n{\n\tkfree(to_cros_ec_dev(dev));\n}\n\nstatic int ec_device_probe(struct platform_device *pdev)\n{\n\tint retval = -ENOMEM;\n\tstruct device_node *node;\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_ec_platform *ec_platform = dev_get_platdata(dev);\n\tstruct cros_ec_dev *ec = kzalloc(sizeof(*ec), GFP_KERNEL);\n\tstruct ec_response_pchg_count pchg_count;\n\tint i;\n\n\tif (!ec)\n\t\treturn retval;\n\n\tdev_set_drvdata(dev, ec);\n\tec->ec_dev = dev_get_drvdata(dev->parent);\n\tec->dev = dev;\n\tec->cmd_offset = ec_platform->cmd_offset;\n\tec->features.flags[0] = -1U;  \n\tec->features.flags[1] = -1U;  \n\tdevice_initialize(&ec->class_dev);\n\n\tfor (i = 0; i < ARRAY_SIZE(cros_mcu_devices); i++) {\n\t\t \n\t\tif (cros_ec_check_features(ec, cros_mcu_devices[i].id)) {\n\t\t\tdev_info(dev, \"CrOS %s MCU detected\\n\",\n\t\t\t\t cros_mcu_devices[i].desc);\n\t\t\t \n\t\t\tec_platform->ec_name = cros_mcu_devices[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tec->class_dev.class = &cros_class;\n\tec->class_dev.parent = dev;\n\tec->class_dev.release = cros_ec_class_release;\n\n\tretval = dev_set_name(&ec->class_dev, \"%s\", ec_platform->ec_name);\n\tif (retval) {\n\t\tdev_err(dev, \"dev_set_name failed => %d\\n\", retval);\n\t\tgoto failed;\n\t}\n\n\tretval = device_add(&ec->class_dev);\n\tif (retval)\n\t\tgoto failed;\n\n\t \n\tif (cros_ec_get_sensor_count(ec) > 0) {\n\t\tretval = mfd_add_hotplug_devices(ec->dev,\n\t\t\t\tcros_ec_sensorhub_cells,\n\t\t\t\tARRAY_SIZE(cros_ec_sensorhub_cells));\n\t\tif (retval)\n\t\t\tdev_err(ec->dev, \"failed to add %s subdevice: %d\\n\",\n\t\t\t\tcros_ec_sensorhub_cells->name, retval);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cros_subdevices); i++) {\n\t\tif (cros_ec_check_features(ec, cros_subdevices[i].id)) {\n\t\t\tretval = mfd_add_hotplug_devices(ec->dev,\n\t\t\t\t\t\tcros_subdevices[i].mfd_cells,\n\t\t\t\t\t\tcros_subdevices[i].num_cells);\n\t\t\tif (retval)\n\t\t\t\tdev_err(ec->dev,\n\t\t\t\t\t\"failed to add %s subdevice: %d\\n\",\n\t\t\t\t\tcros_subdevices[i].mfd_cells->name,\n\t\t\t\t\tretval);\n\t\t}\n\t}\n\n\t \n\tif (cros_ec_check_features(ec, EC_FEATURE_LIGHTBAR) ||\n\t    dmi_match(DMI_PRODUCT_NAME, \"Link\")) {\n\t\tretval = mfd_add_hotplug_devices(ec->dev,\n\t\t\t\t\tcros_ec_lightbar_cells,\n\t\t\t\t\tARRAY_SIZE(cros_ec_lightbar_cells));\n\t\tif (retval)\n\t\t\tdev_warn(ec->dev, \"failed to add lightbar: %d\\n\",\n\t\t\t\t retval);\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_OF) && ec->ec_dev->dev->of_node) {\n\t\tif (cros_ec_check_features(ec, EC_FEATURE_USB_PD)) {\n\t\t\tretval = mfd_add_hotplug_devices(ec->dev,\n\t\t\t\t\tcros_usbpd_notify_cells,\n\t\t\t\t\tARRAY_SIZE(cros_usbpd_notify_cells));\n\t\t\tif (retval)\n\t\t\t\tdev_err(ec->dev,\n\t\t\t\t\t\"failed to add PD notify devices: %d\\n\",\n\t\t\t\t\tretval);\n\t\t}\n\t}\n\n\t \n\tretval = cros_ec_cmd(ec->ec_dev, 0, EC_CMD_PCHG_COUNT, NULL, 0,\n\t\t\t     &pchg_count, sizeof(pchg_count));\n\tif (retval >= 0 && pchg_count.port_count) {\n\t\tretval = mfd_add_hotplug_devices(ec->dev,\n\t\t\t\t\tcros_ec_pchg_cells,\n\t\t\t\t\tARRAY_SIZE(cros_ec_pchg_cells));\n\t\tif (retval)\n\t\t\tdev_warn(ec->dev, \"failed to add pchg: %d\\n\",\n\t\t\t\t retval);\n\t}\n\n\t \n\tretval = mfd_add_hotplug_devices(ec->dev, cros_ec_platform_cells,\n\t\t\t\t\t ARRAY_SIZE(cros_ec_platform_cells));\n\tif (retval)\n\t\tdev_warn(ec->dev,\n\t\t\t \"failed to add cros-ec platform devices: %d\\n\",\n\t\t\t retval);\n\n\t \n\tnode = ec->ec_dev->dev->of_node;\n\tif (of_property_read_bool(node, \"google,has-vbc-nvram\")) {\n\t\tretval = mfd_add_hotplug_devices(ec->dev, cros_ec_vbc_cells,\n\t\t\t\t\t\tARRAY_SIZE(cros_ec_vbc_cells));\n\t\tif (retval)\n\t\t\tdev_warn(ec->dev, \"failed to add VBC devices: %d\\n\",\n\t\t\t\t retval);\n\t}\n\n\treturn 0;\n\nfailed:\n\tput_device(&ec->class_dev);\n\treturn retval;\n}\n\nstatic int ec_device_remove(struct platform_device *pdev)\n{\n\tstruct cros_ec_dev *ec = dev_get_drvdata(&pdev->dev);\n\n\tmfd_remove_devices(ec->dev);\n\tdevice_unregister(&ec->class_dev);\n\treturn 0;\n}\n\nstatic const struct platform_device_id cros_ec_id[] = {\n\t{ DRV_NAME, 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, cros_ec_id);\n\nstatic struct platform_driver cros_ec_dev_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.id_table = cros_ec_id,\n\t.probe = ec_device_probe,\n\t.remove = ec_device_remove,\n};\n\nstatic int __init cros_ec_dev_init(void)\n{\n\tint ret;\n\n\tret  = class_register(&cros_class);\n\tif (ret) {\n\t\tpr_err(CROS_EC_DEV_NAME \": failed to register device class\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = platform_driver_register(&cros_ec_dev_driver);\n\tif (ret < 0) {\n\t\tpr_warn(CROS_EC_DEV_NAME \": can't register driver: %d\\n\", ret);\n\t\tgoto failed_devreg;\n\t}\n\treturn 0;\n\nfailed_devreg:\n\tclass_unregister(&cros_class);\n\treturn ret;\n}\n\nstatic void __exit cros_ec_dev_exit(void)\n{\n\tplatform_driver_unregister(&cros_ec_dev_driver);\n\tclass_unregister(&cros_class);\n}\n\nmodule_init(cros_ec_dev_init);\nmodule_exit(cros_ec_dev_exit);\n\nMODULE_AUTHOR(\"Bill Richardson <wfrichar@chromium.org>\");\nMODULE_DESCRIPTION(\"Userspace interface to the Chrome OS Embedded Controller\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}