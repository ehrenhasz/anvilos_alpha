{
  "module_name": "max8925-i2c.c",
  "hash_id": "71045c9baea284b546022208b479175e6706c16336f14068508680055d682ecb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/max8925-i2c.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/mfd/max8925.h>\n#include <linux/slab.h>\n\n#define RTC_I2C_ADDR\t\t0x68\n#define ADC_I2C_ADDR\t\t0x47\n\nstatic inline int max8925_read_device(struct i2c_client *i2c,\n\t\t\t\t      int reg, int bytes, void *dest)\n{\n\tint ret;\n\n\tif (bytes > 1)\n\t\tret = i2c_smbus_read_i2c_block_data(i2c, reg, bytes, dest);\n\telse {\n\t\tret = i2c_smbus_read_byte_data(i2c, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*(unsigned char *)dest = (unsigned char)ret;\n\t}\n\treturn ret;\n}\n\nstatic inline int max8925_write_device(struct i2c_client *i2c,\n\t\t\t\t       int reg, int bytes, void *src)\n{\n\tunsigned char buf[9];\n\tint ret;\n\n\tbuf[0] = (unsigned char)reg;\n\tmemcpy(&buf[1], src, bytes);\n\n\tret = i2c_master_send(i2c, buf, bytes + 1);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nint max8925_reg_read(struct i2c_client *i2c, int reg)\n{\n\tstruct max8925_chip *chip = i2c_get_clientdata(i2c);\n\tunsigned char data = 0;\n\tint ret;\n\n\tmutex_lock(&chip->io_lock);\n\tret = max8925_read_device(i2c, reg, 1, &data);\n\tmutex_unlock(&chip->io_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn (int)data;\n}\nEXPORT_SYMBOL(max8925_reg_read);\n\nint max8925_reg_write(struct i2c_client *i2c, int reg,\n\t\tunsigned char data)\n{\n\tstruct max8925_chip *chip = i2c_get_clientdata(i2c);\n\tint ret;\n\n\tmutex_lock(&chip->io_lock);\n\tret = max8925_write_device(i2c, reg, 1, &data);\n\tmutex_unlock(&chip->io_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(max8925_reg_write);\n\nint max8925_bulk_read(struct i2c_client *i2c, int reg,\n\t\tint count, unsigned char *buf)\n{\n\tstruct max8925_chip *chip = i2c_get_clientdata(i2c);\n\tint ret;\n\n\tmutex_lock(&chip->io_lock);\n\tret = max8925_read_device(i2c, reg, count, buf);\n\tmutex_unlock(&chip->io_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(max8925_bulk_read);\n\nint max8925_bulk_write(struct i2c_client *i2c, int reg,\n\t\tint count, unsigned char *buf)\n{\n\tstruct max8925_chip *chip = i2c_get_clientdata(i2c);\n\tint ret;\n\n\tmutex_lock(&chip->io_lock);\n\tret = max8925_write_device(i2c, reg, count, buf);\n\tmutex_unlock(&chip->io_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(max8925_bulk_write);\n\nint max8925_set_bits(struct i2c_client *i2c, int reg,\n\t\tunsigned char mask, unsigned char data)\n{\n\tstruct max8925_chip *chip = i2c_get_clientdata(i2c);\n\tunsigned char value;\n\tint ret;\n\n\tmutex_lock(&chip->io_lock);\n\tret = max8925_read_device(i2c, reg, 1, &value);\n\tif (ret < 0)\n\t\tgoto out;\n\tvalue &= ~mask;\n\tvalue |= data;\n\tret = max8925_write_device(i2c, reg, 1, &value);\nout:\n\tmutex_unlock(&chip->io_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(max8925_set_bits);\n\n\nstatic const struct i2c_device_id max8925_id_table[] = {\n\t{ \"max8925\", 0 },\n\t{ },\n};\n\nstatic int max8925_dt_init(struct device_node *np, struct device *dev,\n\t\t\t   struct max8925_platform_data *pdata)\n{\n\tint ret;\n\n\tret = of_property_read_u32(np, \"maxim,tsc-irq\", &pdata->tsc_irq);\n\tif (ret) {\n\t\tdev_err(dev, \"Not found maxim,tsc-irq property\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int max8925_probe(struct i2c_client *client)\n{\n\tstruct max8925_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct max8925_chip *chip;\n\tstruct device_node *node = client->dev.of_node;\n\n\tif (node && !pdata) {\n\t\t \n\t\tpdata = devm_kzalloc(&client->dev,\n\t\t\t\t     sizeof(struct max8925_platform_data),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tif (max8925_dt_init(node, &client->dev, pdata))\n\t\t\treturn -EINVAL;\n\t} else if (!pdata) {\n\t\tpr_info(\"%s: platform data is missing\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tchip = devm_kzalloc(&client->dev,\n\t\t\t    sizeof(struct max8925_chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\tchip->i2c = client;\n\tchip->dev = &client->dev;\n\ti2c_set_clientdata(client, chip);\n\tmutex_init(&chip->io_lock);\n\n\tchip->rtc = i2c_new_dummy_device(chip->i2c->adapter, RTC_I2C_ADDR);\n\tif (IS_ERR(chip->rtc)) {\n\t\tdev_err(chip->dev, \"Failed to allocate I2C device for RTC\\n\");\n\t\treturn PTR_ERR(chip->rtc);\n\t}\n\ti2c_set_clientdata(chip->rtc, chip);\n\n\tchip->adc = i2c_new_dummy_device(chip->i2c->adapter, ADC_I2C_ADDR);\n\tif (IS_ERR(chip->adc)) {\n\t\tdev_err(chip->dev, \"Failed to allocate I2C device for ADC\\n\");\n\t\ti2c_unregister_device(chip->rtc);\n\t\treturn PTR_ERR(chip->adc);\n\t}\n\ti2c_set_clientdata(chip->adc, chip);\n\n\tdevice_init_wakeup(&client->dev, 1);\n\n\tmax8925_device_init(chip, pdata);\n\n\treturn 0;\n}\n\nstatic void max8925_remove(struct i2c_client *client)\n{\n\tstruct max8925_chip *chip = i2c_get_clientdata(client);\n\n\tmax8925_device_exit(chip);\n\ti2c_unregister_device(chip->adc);\n\ti2c_unregister_device(chip->rtc);\n}\n\nstatic int max8925_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct max8925_chip *chip = i2c_get_clientdata(client);\n\n\tif (device_may_wakeup(dev) && chip->wakeup_flag)\n\t\tenable_irq_wake(chip->core_irq);\n\treturn 0;\n}\n\nstatic int max8925_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct max8925_chip *chip = i2c_get_clientdata(client);\n\n\tif (device_may_wakeup(dev) && chip->wakeup_flag)\n\t\tdisable_irq_wake(chip->core_irq);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(max8925_pm_ops,\n\t\t\t\tmax8925_suspend, max8925_resume);\n\nstatic const struct of_device_id max8925_dt_ids[] = {\n\t{ .compatible = \"maxim,max8925\", },\n\t{},\n};\n\nstatic struct i2c_driver max8925_driver = {\n\t.driver\t= {\n\t\t.name\t= \"max8925\",\n\t\t.pm     = pm_sleep_ptr(&max8925_pm_ops),\n\t\t.of_match_table = max8925_dt_ids,\n\t},\n\t.probe\t\t= max8925_probe,\n\t.remove\t\t= max8925_remove,\n\t.id_table\t= max8925_id_table,\n};\n\nstatic int __init max8925_i2c_init(void)\n{\n\tint ret;\n\n\tret = i2c_add_driver(&max8925_driver);\n\tif (ret != 0)\n\t\tpr_err(\"Failed to register MAX8925 I2C driver: %d\\n\", ret);\n\n\treturn ret;\n}\nsubsys_initcall(max8925_i2c_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}