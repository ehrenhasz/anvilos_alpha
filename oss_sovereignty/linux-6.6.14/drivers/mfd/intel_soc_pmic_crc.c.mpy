{
  "module_name": "intel_soc_pmic_crc.c",
  "hash_id": "bb6a3225228b25ddbeebb5c9a4aa5a86509246cef7cce302c19e35f85751bd36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/intel_soc_pmic_crc.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/platform_data/x86/soc.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n\n#define CRYSTAL_COVE_MAX_REGISTER\t0xC6\n\n#define CRYSTAL_COVE_REG_IRQLVL1\t0x02\n#define CRYSTAL_COVE_REG_MIRQLVL1\t0x0E\n\n#define CRYSTAL_COVE_IRQ_PWRSRC\t\t0\n#define CRYSTAL_COVE_IRQ_THRM\t\t1\n#define CRYSTAL_COVE_IRQ_BCU\t\t2\n#define CRYSTAL_COVE_IRQ_ADC\t\t3\n#define CRYSTAL_COVE_IRQ_CHGR\t\t4\n#define CRYSTAL_COVE_IRQ_GPIO\t\t5\n#define CRYSTAL_COVE_IRQ_VHDMIOCP\t6\n\nstatic const struct resource pwrsrc_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(CRYSTAL_COVE_IRQ_PWRSRC, \"PWRSRC\"),\n};\n\nstatic const struct resource thermal_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(CRYSTAL_COVE_IRQ_THRM, \"THERMAL\"),\n};\n\nstatic const struct resource bcu_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(CRYSTAL_COVE_IRQ_BCU, \"BCU\"),\n};\n\nstatic const struct resource adc_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(CRYSTAL_COVE_IRQ_ADC, \"ADC\"),\n};\n\nstatic const struct resource charger_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(CRYSTAL_COVE_IRQ_CHGR, \"CHGR\"),\n};\n\nstatic const struct resource gpio_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(CRYSTAL_COVE_IRQ_GPIO, \"GPIO\"),\n};\n\nstatic struct mfd_cell crystal_cove_byt_dev[] = {\n\t{\n\t\t.name = \"crystal_cove_pwrsrc\",\n\t\t.num_resources = ARRAY_SIZE(pwrsrc_resources),\n\t\t.resources = pwrsrc_resources,\n\t},\n\t{\n\t\t.name = \"crystal_cove_thermal\",\n\t\t.num_resources = ARRAY_SIZE(thermal_resources),\n\t\t.resources = thermal_resources,\n\t},\n\t{\n\t\t.name = \"crystal_cove_bcu\",\n\t\t.num_resources = ARRAY_SIZE(bcu_resources),\n\t\t.resources = bcu_resources,\n\t},\n\t{\n\t\t.name = \"crystal_cove_adc\",\n\t\t.num_resources = ARRAY_SIZE(adc_resources),\n\t\t.resources = adc_resources,\n\t},\n\t{\n\t\t.name = \"crystal_cove_charger\",\n\t\t.num_resources = ARRAY_SIZE(charger_resources),\n\t\t.resources = charger_resources,\n\t},\n\t{\n\t\t.name = \"crystal_cove_gpio\",\n\t\t.num_resources = ARRAY_SIZE(gpio_resources),\n\t\t.resources = gpio_resources,\n\t},\n\t{\n\t\t.name = \"byt_crystal_cove_pmic\",\n\t},\n\t{\n\t\t.name = \"crystal_cove_pwm\",\n\t},\n};\n\nstatic struct mfd_cell crystal_cove_cht_dev[] = {\n\t{\n\t\t.name = \"crystal_cove_gpio\",\n\t\t.num_resources = ARRAY_SIZE(gpio_resources),\n\t\t.resources = gpio_resources,\n\t},\n\t{\n\t\t.name = \"cht_crystal_cove_pmic\",\n\t},\n\t{\n\t\t.name = \"crystal_cove_pwm\",\n\t},\n};\n\nstatic const struct regmap_config crystal_cove_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CRYSTAL_COVE_MAX_REGISTER,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic const struct regmap_irq crystal_cove_irqs[] = {\n\tREGMAP_IRQ_REG(CRYSTAL_COVE_IRQ_PWRSRC, 0, BIT(CRYSTAL_COVE_IRQ_PWRSRC)),\n\tREGMAP_IRQ_REG(CRYSTAL_COVE_IRQ_THRM, 0, BIT(CRYSTAL_COVE_IRQ_THRM)),\n\tREGMAP_IRQ_REG(CRYSTAL_COVE_IRQ_BCU, 0, BIT(CRYSTAL_COVE_IRQ_BCU)),\n\tREGMAP_IRQ_REG(CRYSTAL_COVE_IRQ_ADC, 0, BIT(CRYSTAL_COVE_IRQ_ADC)),\n\tREGMAP_IRQ_REG(CRYSTAL_COVE_IRQ_CHGR, 0, BIT(CRYSTAL_COVE_IRQ_CHGR)),\n\tREGMAP_IRQ_REG(CRYSTAL_COVE_IRQ_GPIO, 0, BIT(CRYSTAL_COVE_IRQ_GPIO)),\n\tREGMAP_IRQ_REG(CRYSTAL_COVE_IRQ_VHDMIOCP, 0, BIT(CRYSTAL_COVE_IRQ_VHDMIOCP)),\n};\n\nstatic const struct regmap_irq_chip crystal_cove_irq_chip = {\n\t.name = \"Crystal Cove\",\n\t.irqs = crystal_cove_irqs,\n\t.num_irqs = ARRAY_SIZE(crystal_cove_irqs),\n\t.num_regs = 1,\n\t.status_base = CRYSTAL_COVE_REG_IRQLVL1,\n\t.mask_base = CRYSTAL_COVE_REG_MIRQLVL1,\n};\n\n \nstatic struct pwm_lookup crc_pwm_lookup[] = {\n\tPWM_LOOKUP(\"crystal_cove_pwm\", 0, \"0000:00:02.0\", \"pwm_pmic_backlight\", 0, PWM_POLARITY_NORMAL),\n};\n\nstruct crystal_cove_config {\n\tunsigned long irq_flags;\n\tstruct mfd_cell *cell_dev;\n\tint n_cell_devs;\n\tconst struct regmap_config *regmap_config;\n\tconst struct regmap_irq_chip *irq_chip;\n};\n\nstatic const struct crystal_cove_config crystal_cove_config_byt_crc = {\n\t.irq_flags = IRQF_TRIGGER_RISING,\n\t.cell_dev = crystal_cove_byt_dev,\n\t.n_cell_devs = ARRAY_SIZE(crystal_cove_byt_dev),\n\t.regmap_config = &crystal_cove_regmap_config,\n\t.irq_chip = &crystal_cove_irq_chip,\n};\n\nstatic const struct crystal_cove_config crystal_cove_config_cht_crc = {\n\t.irq_flags = IRQF_TRIGGER_RISING,\n\t.cell_dev = crystal_cove_cht_dev,\n\t.n_cell_devs = ARRAY_SIZE(crystal_cove_cht_dev),\n\t.regmap_config = &crystal_cove_regmap_config,\n\t.irq_chip = &crystal_cove_irq_chip,\n};\n\nstatic int crystal_cove_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct crystal_cove_config *config;\n\tstruct device *dev = &i2c->dev;\n\tstruct intel_soc_pmic *pmic;\n\tint ret;\n\n\tif (soc_intel_is_byt())\n\t\tconfig = &crystal_cove_config_byt_crc;\n\telse\n\t\tconfig = &crystal_cove_config_cht_crc;\n\n\tpmic = devm_kzalloc(dev, sizeof(*pmic), GFP_KERNEL);\n\tif (!pmic)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, pmic);\n\n\tpmic->regmap = devm_regmap_init_i2c(i2c, config->regmap_config);\n\tif (IS_ERR(pmic->regmap))\n\t\treturn PTR_ERR(pmic->regmap);\n\n\tpmic->irq = i2c->irq;\n\n\tret = devm_regmap_add_irq_chip(dev, pmic->regmap, pmic->irq,\n\t\t\t\t       config->irq_flags | IRQF_ONESHOT,\n\t\t\t\t       0, config->irq_chip, &pmic->irq_chip_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = enable_irq_wake(pmic->irq);\n\tif (ret)\n\t\tdev_warn(dev, \"Can't enable IRQ as wake source: %d\\n\", ret);\n\n\t \n\tpwm_add_table(crc_pwm_lookup, ARRAY_SIZE(crc_pwm_lookup));\n\n\t \n\tirq_domain_update_bus_token(regmap_irq_get_domain(pmic->irq_chip_data),\n\t\t\t\t    DOMAIN_BUS_NEXUS);\n\n\tret = mfd_add_devices(dev, PLATFORM_DEVID_NONE, config->cell_dev,\n\t\t\t      config->n_cell_devs, NULL, 0,\n\t\t\t      regmap_irq_get_domain(pmic->irq_chip_data));\n\tif (ret)\n\t\tpwm_remove_table(crc_pwm_lookup, ARRAY_SIZE(crc_pwm_lookup));\n\n\treturn ret;\n}\n\nstatic void crystal_cove_i2c_remove(struct i2c_client *i2c)\n{\n\t \n\tpwm_remove_table(crc_pwm_lookup, ARRAY_SIZE(crc_pwm_lookup));\n\n\tmfd_remove_devices(&i2c->dev);\n}\n\nstatic void crystal_cove_shutdown(struct i2c_client *i2c)\n{\n\tstruct intel_soc_pmic *pmic = i2c_get_clientdata(i2c);\n\n\tdisable_irq(pmic->irq);\n\n\treturn;\n}\n\nstatic int crystal_cove_suspend(struct device *dev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(dev);\n\n\tdisable_irq(pmic->irq);\n\n\treturn 0;\n}\n\nstatic int crystal_cove_resume(struct device *dev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(dev);\n\n\tenable_irq(pmic->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(crystal_cove_pm_ops, crystal_cove_suspend, crystal_cove_resume);\n\nstatic const struct acpi_device_id crystal_cove_acpi_match[] = {\n\t{ \"INT33FD\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, crystal_cove_acpi_match);\n\nstatic struct i2c_driver crystal_cove_i2c_driver = {\n\t.driver = {\n\t\t.name = \"crystal_cove_i2c\",\n\t\t.pm = pm_sleep_ptr(&crystal_cove_pm_ops),\n\t\t.acpi_match_table = crystal_cove_acpi_match,\n\t},\n\t.probe = crystal_cove_i2c_probe,\n\t.remove = crystal_cove_i2c_remove,\n\t.shutdown = crystal_cove_shutdown,\n};\n\nmodule_i2c_driver(crystal_cove_i2c_driver);\n\nMODULE_DESCRIPTION(\"I2C driver for Intel SoC PMIC\");\nMODULE_AUTHOR(\"Yang, Bin <bin.yang@intel.com>\");\nMODULE_AUTHOR(\"Zhu, Lejun <lejun.zhu@linux.intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}