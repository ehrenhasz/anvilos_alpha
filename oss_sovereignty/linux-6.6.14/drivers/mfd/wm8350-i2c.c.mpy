{
  "module_name": "wm8350-i2c.c",
  "hash_id": "a5f97f8dd132f97522e7a2731b8f7c38edccfc188c753b84e9eb2bb67d28786a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/wm8350-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/wm8350/core.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\nstatic int wm8350_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8350 *wm8350;\n\tstruct wm8350_platform_data *pdata = dev_get_platdata(&i2c->dev);\n\tint ret = 0;\n\n\twm8350 = devm_kzalloc(&i2c->dev, sizeof(struct wm8350), GFP_KERNEL);\n\tif (wm8350 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8350->regmap = devm_regmap_init_i2c(i2c, &wm8350_regmap);\n\tif (IS_ERR(wm8350->regmap)) {\n\t\tret = PTR_ERR(wm8350->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, wm8350);\n\twm8350->dev = &i2c->dev;\n\n\treturn wm8350_device_init(wm8350, i2c->irq, pdata);\n}\n\nstatic const struct i2c_device_id wm8350_i2c_id[] = {\n\t{ \"wm8350\", 0 },\n\t{ \"wm8351\", 0 },\n\t{ \"wm8352\", 0 },\n\t{ }\n};\n\nstatic struct i2c_driver wm8350_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"wm8350\",\n\t\t   .suppress_bind_attrs = true,\n\t},\n\t.probe = wm8350_i2c_probe,\n\t.id_table = wm8350_i2c_id,\n};\n\nstatic int __init wm8350_i2c_init(void)\n{\n\treturn i2c_add_driver(&wm8350_i2c_driver);\n}\n \nsubsys_initcall(wm8350_i2c_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}