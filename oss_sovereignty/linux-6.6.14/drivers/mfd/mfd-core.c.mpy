{
  "module_name": "mfd-core.c",
  "hash_id": "a2375571a92d64973f77f9302fff39397f9bdb3ff78c514c4749a4b5cbbe8536",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/mfd-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/acpi.h>\n#include <linux/list.h>\n#include <linux/property.h>\n#include <linux/mfd/core.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/regulator/consumer.h>\n\nstatic LIST_HEAD(mfd_of_node_list);\n\nstruct mfd_of_node_entry {\n\tstruct list_head list;\n\tstruct device *dev;\n\tstruct device_node *np;\n};\n\nstatic struct device_type mfd_dev_type = {\n\t.name\t= \"mfd_device\",\n};\n\n#if IS_ENABLED(CONFIG_ACPI)\nstruct match_ids_walk_data {\n\tstruct acpi_device_id *ids;\n\tstruct acpi_device *adev;\n};\n\nstatic int match_device_ids(struct acpi_device *adev, void *data)\n{\n\tstruct match_ids_walk_data *wd = data;\n\n\tif (!acpi_match_device_ids(adev, wd->ids)) {\n\t\twd->adev = adev;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void mfd_acpi_add_device(const struct mfd_cell *cell,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tconst struct mfd_cell_acpi_match *match = cell->acpi_match;\n\tstruct acpi_device *adev = NULL;\n\tstruct acpi_device *parent;\n\n\tparent = ACPI_COMPANION(pdev->dev.parent);\n\tif (!parent)\n\t\treturn;\n\n\t \n\tif (match) {\n\t\tif (match->pnpid) {\n\t\t\tstruct acpi_device_id ids[2] = {};\n\t\t\tstruct match_ids_walk_data wd = {\n\t\t\t\t.adev = NULL,\n\t\t\t\t.ids = ids,\n\t\t\t};\n\n\t\t\tstrscpy(ids[0].id, match->pnpid, sizeof(ids[0].id));\n\t\t\tacpi_dev_for_each_child(parent, match_device_ids, &wd);\n\t\t\tadev = wd.adev;\n\t\t} else {\n\t\t\tadev = acpi_find_child_device(parent, match->adr, false);\n\t\t}\n\t}\n\n\tACPI_COMPANION_SET(&pdev->dev, adev ?: parent);\n}\n#else\nstatic inline void mfd_acpi_add_device(const struct mfd_cell *cell,\n\t\t\t\t       struct platform_device *pdev)\n{\n}\n#endif\n\nstatic int mfd_match_of_node_to_dev(struct platform_device *pdev,\n\t\t\t\t    struct device_node *np,\n\t\t\t\t    const struct mfd_cell *cell)\n{\n#if IS_ENABLED(CONFIG_OF)\n\tstruct mfd_of_node_entry *of_entry;\n\tu64 of_node_addr;\n\n\t \n\tlist_for_each_entry(of_entry, &mfd_of_node_list, list)\n\t\tif (of_entry->np == np)\n\t\t\treturn -EAGAIN;\n\n\tif (!cell->use_of_reg)\n\t\t \n\t\tgoto allocate_of_node;\n\n\t \n\tif (of_property_read_reg(np, 0, &of_node_addr, NULL))\n\t\t \n\t\treturn -EAGAIN;\n\n\tif (cell->of_reg != of_node_addr)\n\t\t \n\t\treturn -EAGAIN;\n\nallocate_of_node:\n\tof_entry = kzalloc(sizeof(*of_entry), GFP_KERNEL);\n\tif (!of_entry)\n\t\treturn -ENOMEM;\n\n\tof_entry->dev = &pdev->dev;\n\tof_entry->np = np;\n\tlist_add_tail(&of_entry->list, &mfd_of_node_list);\n\n\tpdev->dev.of_node = np;\n\tpdev->dev.fwnode = &np->fwnode;\n#endif\n\treturn 0;\n}\n\nstatic int mfd_add_device(struct device *parent, int id,\n\t\t\t  const struct mfd_cell *cell,\n\t\t\t  struct resource *mem_base,\n\t\t\t  int irq_base, struct irq_domain *domain)\n{\n\tstruct resource *res;\n\tstruct platform_device *pdev;\n\tstruct device_node *np = NULL;\n\tstruct mfd_of_node_entry *of_entry, *tmp;\n\tbool disabled = false;\n\tint ret = -ENOMEM;\n\tint platform_id;\n\tint r;\n\n\tif (id == PLATFORM_DEVID_AUTO)\n\t\tplatform_id = id;\n\telse\n\t\tplatform_id = id + cell->id;\n\n\tpdev = platform_device_alloc(cell->name, platform_id);\n\tif (!pdev)\n\t\tgoto fail_alloc;\n\n\tpdev->mfd_cell = kmemdup(cell, sizeof(*cell), GFP_KERNEL);\n\tif (!pdev->mfd_cell)\n\t\tgoto fail_device;\n\n\tres = kcalloc(cell->num_resources, sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\tgoto fail_device;\n\n\tpdev->dev.parent = parent;\n\tpdev->dev.type = &mfd_dev_type;\n\tpdev->dev.dma_mask = parent->dma_mask;\n\tpdev->dev.dma_parms = parent->dma_parms;\n\tpdev->dev.coherent_dma_mask = parent->coherent_dma_mask;\n\n\tret = regulator_bulk_register_supply_alias(\n\t\t\t&pdev->dev, cell->parent_supplies,\n\t\t\tparent, cell->parent_supplies,\n\t\t\tcell->num_parent_supplies);\n\tif (ret < 0)\n\t\tgoto fail_res;\n\n\tif (IS_ENABLED(CONFIG_OF) && parent->of_node && cell->of_compatible) {\n\t\tfor_each_child_of_node(parent->of_node, np) {\n\t\t\tif (of_device_is_compatible(np, cell->of_compatible)) {\n\t\t\t\t \n\t\t\t\tif (!of_device_is_available(np)) {\n\t\t\t\t\tdisabled = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tret = mfd_match_of_node_to_dev(pdev, np, cell);\n\t\t\t\tif (ret == -EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t\tof_node_put(np);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail_alias;\n\n\t\t\t\tgoto match;\n\t\t\t}\n\t\t}\n\n\t\tif (disabled) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tgoto fail_alias;\n\t\t}\n\nmatch:\n\t\tif (!pdev->dev.of_node)\n\t\t\tpr_warn(\"%s: Failed to locate of_node [id: %d]\\n\",\n\t\t\t\tcell->name, platform_id);\n\t}\n\n\tmfd_acpi_add_device(cell, pdev);\n\n\tif (cell->pdata_size) {\n\t\tret = platform_device_add_data(pdev,\n\t\t\t\t\tcell->platform_data, cell->pdata_size);\n\t\tif (ret)\n\t\t\tgoto fail_of_entry;\n\t}\n\n\tif (cell->swnode) {\n\t\tret = device_add_software_node(&pdev->dev, cell->swnode);\n\t\tif (ret)\n\t\t\tgoto fail_of_entry;\n\t}\n\n\tfor (r = 0; r < cell->num_resources; r++) {\n\t\tres[r].name = cell->resources[r].name;\n\t\tres[r].flags = cell->resources[r].flags;\n\n\t\t \n\t\tif ((cell->resources[r].flags & IORESOURCE_MEM) && mem_base) {\n\t\t\tres[r].parent = mem_base;\n\t\t\tres[r].start = mem_base->start +\n\t\t\t\tcell->resources[r].start;\n\t\t\tres[r].end = mem_base->start +\n\t\t\t\tcell->resources[r].end;\n\t\t} else if (cell->resources[r].flags & IORESOURCE_IRQ) {\n\t\t\tif (domain) {\n\t\t\t\t \n\t\t\t\tWARN_ON(cell->resources[r].start !=\n\t\t\t\t\tcell->resources[r].end);\n\t\t\t\tres[r].start = res[r].end = irq_create_mapping(\n\t\t\t\t\tdomain, cell->resources[r].start);\n\t\t\t} else {\n\t\t\t\tres[r].start = irq_base +\n\t\t\t\t\tcell->resources[r].start;\n\t\t\t\tres[r].end   = irq_base +\n\t\t\t\t\tcell->resources[r].end;\n\t\t\t}\n\t\t} else {\n\t\t\tres[r].parent = cell->resources[r].parent;\n\t\t\tres[r].start = cell->resources[r].start;\n\t\t\tres[r].end   = cell->resources[r].end;\n\t\t}\n\n\t\tif (!cell->ignore_resource_conflicts) {\n\t\t\tif (has_acpi_companion(&pdev->dev)) {\n\t\t\t\tret = acpi_check_resource_conflict(&res[r]);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail_res_conflict;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = platform_device_add_resources(pdev, res, cell->num_resources);\n\tif (ret)\n\t\tgoto fail_res_conflict;\n\n\tret = platform_device_add(pdev);\n\tif (ret)\n\t\tgoto fail_res_conflict;\n\n\tif (cell->pm_runtime_no_callbacks)\n\t\tpm_runtime_no_callbacks(&pdev->dev);\n\n\tkfree(res);\n\n\treturn 0;\n\nfail_res_conflict:\n\tif (cell->swnode)\n\t\tdevice_remove_software_node(&pdev->dev);\nfail_of_entry:\n\tlist_for_each_entry_safe(of_entry, tmp, &mfd_of_node_list, list)\n\t\tif (of_entry->dev == &pdev->dev) {\n\t\t\tlist_del(&of_entry->list);\n\t\t\tkfree(of_entry);\n\t\t}\nfail_alias:\n\tregulator_bulk_unregister_supply_alias(&pdev->dev,\n\t\t\t\t\t       cell->parent_supplies,\n\t\t\t\t\t       cell->num_parent_supplies);\nfail_res:\n\tkfree(res);\nfail_device:\n\tplatform_device_put(pdev);\nfail_alloc:\n\treturn ret;\n}\n\n \nint mfd_add_devices(struct device *parent, int id,\n\t\t    const struct mfd_cell *cells, int n_devs,\n\t\t    struct resource *mem_base,\n\t\t    int irq_base, struct irq_domain *domain)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < n_devs; i++) {\n\t\tret = mfd_add_device(parent, id, cells + i, mem_base,\n\t\t\t\t     irq_base, domain);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tif (i)\n\t\tmfd_remove_devices(parent);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mfd_add_devices);\n\nstatic int mfd_remove_devices_fn(struct device *dev, void *data)\n{\n\tstruct platform_device *pdev;\n\tconst struct mfd_cell *cell;\n\tstruct mfd_of_node_entry *of_entry, *tmp;\n\tint *level = data;\n\n\tif (dev->type != &mfd_dev_type)\n\t\treturn 0;\n\n\tpdev = to_platform_device(dev);\n\tcell = mfd_get_cell(pdev);\n\n\tif (level && cell->level > *level)\n\t\treturn 0;\n\n\tif (cell->swnode)\n\t\tdevice_remove_software_node(&pdev->dev);\n\n\tlist_for_each_entry_safe(of_entry, tmp, &mfd_of_node_list, list)\n\t\tif (of_entry->dev == &pdev->dev) {\n\t\t\tlist_del(&of_entry->list);\n\t\t\tkfree(of_entry);\n\t\t}\n\n\tregulator_bulk_unregister_supply_alias(dev, cell->parent_supplies,\n\t\t\t\t\t       cell->num_parent_supplies);\n\n\tplatform_device_unregister(pdev);\n\treturn 0;\n}\n\nvoid mfd_remove_devices_late(struct device *parent)\n{\n\tint level = MFD_DEP_LEVEL_HIGH;\n\n\tdevice_for_each_child_reverse(parent, &level, mfd_remove_devices_fn);\n}\nEXPORT_SYMBOL(mfd_remove_devices_late);\n\nvoid mfd_remove_devices(struct device *parent)\n{\n\tint level = MFD_DEP_LEVEL_NORMAL;\n\n\tdevice_for_each_child_reverse(parent, &level, mfd_remove_devices_fn);\n}\nEXPORT_SYMBOL(mfd_remove_devices);\n\nstatic void devm_mfd_dev_release(struct device *dev, void *res)\n{\n\tmfd_remove_devices(dev);\n}\n\n \nint devm_mfd_add_devices(struct device *dev, int id,\n\t\t\t const struct mfd_cell *cells, int n_devs,\n\t\t\t struct resource *mem_base,\n\t\t\t int irq_base, struct irq_domain *domain)\n{\n\tstruct device **ptr;\n\tint ret;\n\n\tptr = devres_alloc(devm_mfd_dev_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tret = mfd_add_devices(dev, id, cells, n_devs, mem_base,\n\t\t\t      irq_base, domain);\n\tif (ret < 0) {\n\t\tdevres_free(ptr);\n\t\treturn ret;\n\t}\n\n\t*ptr = dev;\n\tdevres_add(dev, ptr);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(devm_mfd_add_devices);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ian Molton, Dmitry Baryshkov\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}