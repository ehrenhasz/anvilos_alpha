{
  "module_name": "arizona-i2c.c",
  "hash_id": "9d7bfb20d4137b4c744f8bc19671333e2c071d3512af95c5fc4d611cc9b42339",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/arizona-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#include <linux/mfd/arizona/core.h>\n\n#include \"arizona.h\"\n\nstatic int arizona_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tconst void *match_data;\n\tstruct arizona *arizona;\n\tconst struct regmap_config *regmap_config = NULL;\n\tunsigned long type = 0;\n\tint ret;\n\n\tmatch_data = device_get_match_data(&i2c->dev);\n\tif (match_data)\n\t\ttype = (unsigned long)match_data;\n\telse if (id)\n\t\ttype = id->driver_data;\n\n\tswitch (type) {\n\tcase WM5102:\n\t\tif (IS_ENABLED(CONFIG_MFD_WM5102))\n\t\t\tregmap_config = &wm5102_i2c_regmap;\n\t\tbreak;\n\tcase WM5110:\n\tcase WM8280:\n\t\tif (IS_ENABLED(CONFIG_MFD_WM5110))\n\t\t\tregmap_config = &wm5110_i2c_regmap;\n\t\tbreak;\n\tcase WM8997:\n\t\tif (IS_ENABLED(CONFIG_MFD_WM8997))\n\t\t\tregmap_config = &wm8997_i2c_regmap;\n\t\tbreak;\n\tcase WM8998:\n\tcase WM1814:\n\t\tif (IS_ENABLED(CONFIG_MFD_WM8998))\n\t\t\tregmap_config = &wm8998_i2c_regmap;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2c->dev, \"Unknown device type %ld\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!regmap_config) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"No kernel support for device type %ld\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tarizona = devm_kzalloc(&i2c->dev, sizeof(*arizona), GFP_KERNEL);\n\tif (arizona == NULL)\n\t\treturn -ENOMEM;\n\n\tarizona->regmap = devm_regmap_init_i2c(i2c, regmap_config);\n\tif (IS_ERR(arizona->regmap)) {\n\t\tret = PTR_ERR(arizona->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tarizona->type = type;\n\tarizona->dev = &i2c->dev;\n\tarizona->irq = i2c->irq;\n\n\treturn arizona_dev_init(arizona);\n}\n\nstatic void arizona_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct arizona *arizona = dev_get_drvdata(&i2c->dev);\n\n\tarizona_dev_exit(arizona);\n}\n\nstatic const struct i2c_device_id arizona_i2c_id[] = {\n\t{ \"wm5102\", WM5102 },\n\t{ \"wm5110\", WM5110 },\n\t{ \"wm8280\", WM8280 },\n\t{ \"wm8997\", WM8997 },\n\t{ \"wm8998\", WM8998 },\n\t{ \"wm1814\", WM1814 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, arizona_i2c_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id arizona_i2c_of_match[] = {\n\t{ .compatible = \"wlf,wm5102\", .data = (void *)WM5102 },\n\t{ .compatible = \"wlf,wm5110\", .data = (void *)WM5110 },\n\t{ .compatible = \"wlf,wm8280\", .data = (void *)WM8280 },\n\t{ .compatible = \"wlf,wm8997\", .data = (void *)WM8997 },\n\t{ .compatible = \"wlf,wm8998\", .data = (void *)WM8998 },\n\t{ .compatible = \"wlf,wm1814\", .data = (void *)WM1814 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, arizona_i2c_of_match);\n#endif\n\nstatic struct i2c_driver arizona_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"arizona\",\n\t\t.pm\t= pm_ptr(&arizona_pm_ops),\n\t\t.of_match_table\t= of_match_ptr(arizona_i2c_of_match),\n\t},\n\t.probe\t\t= arizona_i2c_probe,\n\t.remove\t\t= arizona_i2c_remove,\n\t.id_table\t= arizona_i2c_id,\n};\n\nmodule_i2c_driver(arizona_i2c_driver);\n\nMODULE_SOFTDEP(\"pre: arizona_ldo1\");\nMODULE_DESCRIPTION(\"Arizona I2C bus interface\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}