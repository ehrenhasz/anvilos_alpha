{
  "module_name": "lp8788.c",
  "hash_id": "bc47af4cad64ab517bf16aa0de75e0a6862a91435a29b19346f9ab30d8e396ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/lp8788.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/lp8788.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#define MAX_LP8788_REGISTERS\t\t0xA2\n\n#define MFD_DEV_SIMPLE(_name)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.name = LP8788_DEV_##_name,\t\t\t\t\\\n}\n\n#define MFD_DEV_WITH_ID(_name, _id)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.name = LP8788_DEV_##_name,\t\t\t\t\\\n\t.id = _id,\t\t\t\t\t\t\\\n}\n\n#define MFD_DEV_WITH_RESOURCE(_name, _resource, num_resource)\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.name = LP8788_DEV_##_name,\t\t\t\t\\\n\t.resources = _resource,\t\t\t\t\t\\\n\t.num_resources = num_resource,\t\t\t\t\\\n}\n\nstatic const struct resource chg_irqs[] = {\n\t \n\t{\n\t\t.start = LP8788_INT_CHG_INPUT_STATE,\n\t\t.end   = LP8788_INT_PRECHG_TIMEOUT,\n\t\t.name  = LP8788_CHG_IRQ,\n\t\t.flags = IORESOURCE_IRQ,\n\t},\n\t \n\t{\n\t\t.start = LP8788_INT_ENTER_SYS_SUPPORT,\n\t\t.end   = LP8788_INT_EXIT_SYS_SUPPORT,\n\t\t.name  = LP8788_PRSW_IRQ,\n\t\t.flags = IORESOURCE_IRQ,\n\t},\n\t \n\t{\n\t\t.start = LP8788_INT_BATT_LOW,\n\t\t.end   = LP8788_INT_NO_BATT,\n\t\t.name  = LP8788_BATT_IRQ,\n\t\t.flags = IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct resource rtc_irqs[] = {\n\t{\n\t\t.start = LP8788_INT_RTC_ALARM1,\n\t\t.end   = LP8788_INT_RTC_ALARM2,\n\t\t.name  = LP8788_ALM_IRQ,\n\t\t.flags = IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell lp8788_devs[] = {\n\t \n\tMFD_DEV_WITH_ID(BUCK, 1),\n\tMFD_DEV_WITH_ID(BUCK, 2),\n\tMFD_DEV_WITH_ID(BUCK, 3),\n\tMFD_DEV_WITH_ID(BUCK, 4),\n\n\t \n\tMFD_DEV_WITH_ID(DLDO, 1),\n\tMFD_DEV_WITH_ID(DLDO, 2),\n\tMFD_DEV_WITH_ID(DLDO, 3),\n\tMFD_DEV_WITH_ID(DLDO, 4),\n\tMFD_DEV_WITH_ID(DLDO, 5),\n\tMFD_DEV_WITH_ID(DLDO, 6),\n\tMFD_DEV_WITH_ID(DLDO, 7),\n\tMFD_DEV_WITH_ID(DLDO, 8),\n\tMFD_DEV_WITH_ID(DLDO, 9),\n\tMFD_DEV_WITH_ID(DLDO, 10),\n\tMFD_DEV_WITH_ID(DLDO, 11),\n\tMFD_DEV_WITH_ID(DLDO, 12),\n\n\t \n\tMFD_DEV_WITH_ID(ALDO, 1),\n\tMFD_DEV_WITH_ID(ALDO, 2),\n\tMFD_DEV_WITH_ID(ALDO, 3),\n\tMFD_DEV_WITH_ID(ALDO, 4),\n\tMFD_DEV_WITH_ID(ALDO, 5),\n\tMFD_DEV_WITH_ID(ALDO, 6),\n\tMFD_DEV_WITH_ID(ALDO, 7),\n\tMFD_DEV_WITH_ID(ALDO, 8),\n\tMFD_DEV_WITH_ID(ALDO, 9),\n\tMFD_DEV_WITH_ID(ALDO, 10),\n\n\t \n\tMFD_DEV_SIMPLE(ADC),\n\n\t \n\tMFD_DEV_WITH_RESOURCE(CHARGER, chg_irqs, ARRAY_SIZE(chg_irqs)),\n\n\t \n\tMFD_DEV_WITH_RESOURCE(RTC, rtc_irqs, ARRAY_SIZE(rtc_irqs)),\n\n\t \n\tMFD_DEV_SIMPLE(BACKLIGHT),\n\n\t \n\tMFD_DEV_SIMPLE(VIBRATOR),\n\n\t \n\tMFD_DEV_SIMPLE(KEYLED),\n};\n\nint lp8788_read_byte(struct lp8788 *lp, u8 reg, u8 *data)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(lp->regmap, reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(lp->dev, \"failed to read 0x%.2x\\n\", reg);\n\t\treturn ret;\n\t}\n\n\t*data = (u8)val;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lp8788_read_byte);\n\nint lp8788_read_multi_bytes(struct lp8788 *lp, u8 reg, u8 *data, size_t count)\n{\n\treturn regmap_bulk_read(lp->regmap, reg, data, count);\n}\nEXPORT_SYMBOL_GPL(lp8788_read_multi_bytes);\n\nint lp8788_write_byte(struct lp8788 *lp, u8 reg, u8 data)\n{\n\treturn regmap_write(lp->regmap, reg, data);\n}\nEXPORT_SYMBOL_GPL(lp8788_write_byte);\n\nint lp8788_update_bits(struct lp8788 *lp, u8 reg, u8 mask, u8 data)\n{\n\treturn regmap_update_bits(lp->regmap, reg, mask, data);\n}\nEXPORT_SYMBOL_GPL(lp8788_update_bits);\n\nstatic int lp8788_platform_init(struct lp8788 *lp)\n{\n\tstruct lp8788_platform_data *pdata = lp->pdata;\n\n\treturn (pdata && pdata->init_func) ? pdata->init_func(lp) : 0;\n}\n\nstatic const struct regmap_config lp8788_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MAX_LP8788_REGISTERS,\n};\n\nstatic int lp8788_probe(struct i2c_client *cl)\n{\n\tstruct lp8788 *lp;\n\tstruct lp8788_platform_data *pdata = dev_get_platdata(&cl->dev);\n\tint ret;\n\n\tlp = devm_kzalloc(&cl->dev, sizeof(struct lp8788), GFP_KERNEL);\n\tif (!lp)\n\t\treturn -ENOMEM;\n\n\tlp->regmap = devm_regmap_init_i2c(cl, &lp8788_regmap_config);\n\tif (IS_ERR(lp->regmap)) {\n\t\tret = PTR_ERR(lp->regmap);\n\t\tdev_err(&cl->dev, \"regmap init i2c err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tlp->pdata = pdata;\n\tlp->dev = &cl->dev;\n\ti2c_set_clientdata(cl, lp);\n\n\tret = lp8788_platform_init(lp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lp8788_irq_init(lp, cl->irq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mfd_add_devices(lp->dev, -1, lp8788_devs,\n\t\t\t      ARRAY_SIZE(lp8788_devs), NULL, 0, NULL);\n\tif (ret)\n\t\tgoto err_exit_irq;\n\n\treturn 0;\n\nerr_exit_irq:\n\tlp8788_irq_exit(lp);\n\treturn ret;\n}\n\nstatic void lp8788_remove(struct i2c_client *cl)\n{\n\tstruct lp8788 *lp = i2c_get_clientdata(cl);\n\n\tmfd_remove_devices(lp->dev);\n\tlp8788_irq_exit(lp);\n}\n\nstatic const struct i2c_device_id lp8788_ids[] = {\n\t{\"lp8788\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lp8788_ids);\n\nstatic struct i2c_driver lp8788_driver = {\n\t.driver = {\n\t\t.name = \"lp8788\",\n\t},\n\t.probe = lp8788_probe,\n\t.remove = lp8788_remove,\n\t.id_table = lp8788_ids,\n};\n\nstatic int __init lp8788_init(void)\n{\n\treturn i2c_add_driver(&lp8788_driver);\n}\nsubsys_initcall(lp8788_init);\n\nstatic void __exit lp8788_exit(void)\n{\n\ti2c_del_driver(&lp8788_driver);\n}\nmodule_exit(lp8788_exit);\n\nMODULE_DESCRIPTION(\"TI LP8788 MFD Driver\");\nMODULE_AUTHOR(\"Milo Kim\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}