{
  "module_name": "ab8500-core.c",
  "hash_id": "7d456c404963ac7cafed0df1f6edda921e96ac2d3f8acde75796395396202e80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ab8500-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/abx500.h>\n#include <linux/mfd/abx500/ab8500.h>\n#include <linux/mfd/dbx500-prcmu.h>\n#include <linux/of.h>\n\n \n#define AB8500_IT_SOURCE1_REG\t\t0x00\n#define AB8500_IT_SOURCE2_REG\t\t0x01\n#define AB8500_IT_SOURCE3_REG\t\t0x02\n#define AB8500_IT_SOURCE4_REG\t\t0x03\n#define AB8500_IT_SOURCE5_REG\t\t0x04\n#define AB8500_IT_SOURCE6_REG\t\t0x05\n#define AB8500_IT_SOURCE7_REG\t\t0x06\n#define AB8500_IT_SOURCE8_REG\t\t0x07\n#define AB9540_IT_SOURCE13_REG\t\t0x0C\n#define AB8500_IT_SOURCE19_REG\t\t0x12\n#define AB8500_IT_SOURCE20_REG\t\t0x13\n#define AB8500_IT_SOURCE21_REG\t\t0x14\n#define AB8500_IT_SOURCE22_REG\t\t0x15\n#define AB8500_IT_SOURCE23_REG\t\t0x16\n#define AB8500_IT_SOURCE24_REG\t\t0x17\n\n \n#define AB8500_IT_LATCH1_REG\t\t0x20\n#define AB8500_IT_LATCH2_REG\t\t0x21\n#define AB8500_IT_LATCH3_REG\t\t0x22\n#define AB8500_IT_LATCH4_REG\t\t0x23\n#define AB8500_IT_LATCH5_REG\t\t0x24\n#define AB8500_IT_LATCH6_REG\t\t0x25\n#define AB8500_IT_LATCH7_REG\t\t0x26\n#define AB8500_IT_LATCH8_REG\t\t0x27\n#define AB8500_IT_LATCH9_REG\t\t0x28\n#define AB8500_IT_LATCH10_REG\t\t0x29\n#define AB8500_IT_LATCH12_REG\t\t0x2B\n#define AB9540_IT_LATCH13_REG\t\t0x2C\n#define AB8500_IT_LATCH19_REG\t\t0x32\n#define AB8500_IT_LATCH20_REG\t\t0x33\n#define AB8500_IT_LATCH21_REG\t\t0x34\n#define AB8500_IT_LATCH22_REG\t\t0x35\n#define AB8500_IT_LATCH23_REG\t\t0x36\n#define AB8500_IT_LATCH24_REG\t\t0x37\n\n \n\n#define AB8500_IT_MASK1_REG\t\t0x40\n#define AB8500_IT_MASK2_REG\t\t0x41\n#define AB8500_IT_MASK3_REG\t\t0x42\n#define AB8500_IT_MASK4_REG\t\t0x43\n#define AB8500_IT_MASK5_REG\t\t0x44\n#define AB8500_IT_MASK6_REG\t\t0x45\n#define AB8500_IT_MASK7_REG\t\t0x46\n#define AB8500_IT_MASK8_REG\t\t0x47\n#define AB8500_IT_MASK9_REG\t\t0x48\n#define AB8500_IT_MASK10_REG\t\t0x49\n#define AB8500_IT_MASK11_REG\t\t0x4A\n#define AB8500_IT_MASK12_REG\t\t0x4B\n#define AB8500_IT_MASK13_REG\t\t0x4C\n#define AB8500_IT_MASK14_REG\t\t0x4D\n#define AB8500_IT_MASK15_REG\t\t0x4E\n#define AB8500_IT_MASK16_REG\t\t0x4F\n#define AB8500_IT_MASK17_REG\t\t0x50\n#define AB8500_IT_MASK18_REG\t\t0x51\n#define AB8500_IT_MASK19_REG\t\t0x52\n#define AB8500_IT_MASK20_REG\t\t0x53\n#define AB8500_IT_MASK21_REG\t\t0x54\n#define AB8500_IT_MASK22_REG\t\t0x55\n#define AB8500_IT_MASK23_REG\t\t0x56\n#define AB8500_IT_MASK24_REG\t\t0x57\n#define AB8500_IT_MASK25_REG\t\t0x58\n\n \n#define AB8500_IT_LATCHHIER1_REG\t0x60\n#define AB8500_IT_LATCHHIER2_REG\t0x61\n#define AB8500_IT_LATCHHIER3_REG\t0x62\n#define AB8540_IT_LATCHHIER4_REG\t0x63\n\n#define AB8500_IT_LATCHHIER_NUM\t\t3\n#define AB8540_IT_LATCHHIER_NUM\t\t4\n\n#define AB8500_REV_REG\t\t\t0x80\n#define AB8500_IC_NAME_REG\t\t0x82\n#define AB8500_SWITCH_OFF_STATUS\t0x00\n\n#define AB8500_TURN_ON_STATUS\t\t0x00\n#define AB8505_TURN_ON_STATUS_2\t\t0x04\n\n#define AB8500_CH_USBCH_STAT1_REG\t0x02\n#define VBUS_DET_DBNC100\t\t0x02\n#define VBUS_DET_DBNC1\t\t\t0x01\n\nstatic DEFINE_SPINLOCK(on_stat_lock);\nstatic u8 turn_on_stat_mask = 0xFF;\nstatic u8 turn_on_stat_set;\n\n#define AB9540_MODEM_CTRL2_REG\t\t\t0x23\n#define AB9540_MODEM_CTRL2_SWDBBRSTN_BIT\tBIT(2)\n\n \n \nstatic const int ab8500_irq_regoffset[AB8500_NUM_IRQ_REGS] = {\n\t0, 1, 2, 3, 4, 6, 7, 8, 9, 11, 18, 19, 20, 21,\n};\n\n \nstatic const int ab9540_irq_regoffset[AB9540_NUM_IRQ_REGS] = {\n\t0, 1, 2, 3, 4, 6, 7, 8, 9, 11, 18, 19, 20, 21, 12, 13, 24, 5, 22, 23\n};\n\n \nstatic const int ab8540_irq_regoffset[AB8540_NUM_IRQ_REGS] = {\n\t0, 1, 2, 3, 4, -1, -1, -1, -1, 11, 18, 19, 20, 21, 12, 13, 24, 5, 22,\n\t23, 25, 26, 27, 28, 29, 30, 31,\n};\n\nstatic const char ab8500_version_str[][7] = {\n\t[AB8500_VERSION_AB8500] = \"AB8500\",\n\t[AB8500_VERSION_AB8505] = \"AB8505\",\n\t[AB8500_VERSION_AB9540] = \"AB9540\",\n\t[AB8500_VERSION_AB8540] = \"AB8540\",\n};\n\nstatic int ab8500_prcmu_write(struct ab8500 *ab8500, u16 addr, u8 data)\n{\n\tint ret;\n\n\tret = prcmu_abb_write((u8)(addr >> 8), (u8)(addr & 0xFF), &data, 1);\n\tif (ret < 0)\n\t\tdev_err(ab8500->dev, \"prcmu i2c error %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int ab8500_prcmu_write_masked(struct ab8500 *ab8500, u16 addr, u8 mask,\n\tu8 data)\n{\n\tint ret;\n\n\tret = prcmu_abb_write_masked((u8)(addr >> 8), (u8)(addr & 0xFF), &data,\n\t\t&mask, 1);\n\tif (ret < 0)\n\t\tdev_err(ab8500->dev, \"prcmu i2c error %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int ab8500_prcmu_read(struct ab8500 *ab8500, u16 addr)\n{\n\tint ret;\n\tu8 data;\n\n\tret = prcmu_abb_read((u8)(addr >> 8), (u8)(addr & 0xFF), &data, 1);\n\tif (ret < 0) {\n\t\tdev_err(ab8500->dev, \"prcmu i2c error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn (int)data;\n}\n\nstatic int ab8500_get_chip_id(struct device *dev)\n{\n\tstruct ab8500 *ab8500;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\tab8500 = dev_get_drvdata(dev->parent);\n\treturn ab8500 ? (int)ab8500->chip_id : -EINVAL;\n}\n\nstatic int set_register_interruptible(struct ab8500 *ab8500, u8 bank,\n\tu8 reg, u8 data)\n{\n\tint ret;\n\t \n\tu16 addr = ((u16)bank) << 8 | reg;\n\n\tdev_vdbg(ab8500->dev, \"wr: addr %#x <= %#x\\n\", addr, data);\n\n\tmutex_lock(&ab8500->lock);\n\n\tret = ab8500->write(ab8500, addr, data);\n\tif (ret < 0)\n\t\tdev_err(ab8500->dev, \"failed to write reg %#x: %d\\n\",\n\t\t\taddr, ret);\n\tmutex_unlock(&ab8500->lock);\n\n\treturn ret;\n}\n\nstatic int ab8500_set_register(struct device *dev, u8 bank,\n\tu8 reg, u8 value)\n{\n\tint ret;\n\tstruct ab8500 *ab8500 = dev_get_drvdata(dev->parent);\n\n\tatomic_inc(&ab8500->transfer_ongoing);\n\tret = set_register_interruptible(ab8500, bank, reg, value);\n\tatomic_dec(&ab8500->transfer_ongoing);\n\treturn ret;\n}\n\nstatic int get_register_interruptible(struct ab8500 *ab8500, u8 bank,\n\tu8 reg, u8 *value)\n{\n\tint ret;\n\tu16 addr = ((u16)bank) << 8 | reg;\n\n\tmutex_lock(&ab8500->lock);\n\n\tret = ab8500->read(ab8500, addr);\n\tif (ret < 0)\n\t\tdev_err(ab8500->dev, \"failed to read reg %#x: %d\\n\",\n\t\t\taddr, ret);\n\telse\n\t\t*value = ret;\n\n\tmutex_unlock(&ab8500->lock);\n\tdev_vdbg(ab8500->dev, \"rd: addr %#x => data %#x\\n\", addr, ret);\n\n\treturn (ret < 0) ? ret : 0;\n}\n\nstatic int ab8500_get_register(struct device *dev, u8 bank,\n\tu8 reg, u8 *value)\n{\n\tint ret;\n\tstruct ab8500 *ab8500 = dev_get_drvdata(dev->parent);\n\n\tatomic_inc(&ab8500->transfer_ongoing);\n\tret = get_register_interruptible(ab8500, bank, reg, value);\n\tatomic_dec(&ab8500->transfer_ongoing);\n\treturn ret;\n}\n\nstatic int mask_and_set_register_interruptible(struct ab8500 *ab8500, u8 bank,\n\tu8 reg, u8 bitmask, u8 bitvalues)\n{\n\tint ret;\n\tu16 addr = ((u16)bank) << 8 | reg;\n\n\tmutex_lock(&ab8500->lock);\n\n\tif (ab8500->write_masked == NULL) {\n\t\tu8 data;\n\n\t\tret = ab8500->read(ab8500, addr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ab8500->dev, \"failed to read reg %#x: %d\\n\",\n\t\t\t\taddr, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata = (u8)ret;\n\t\tdata = (~bitmask & data) | (bitmask & bitvalues);\n\n\t\tret = ab8500->write(ab8500, addr, data);\n\t\tif (ret < 0)\n\t\t\tdev_err(ab8500->dev, \"failed to write reg %#x: %d\\n\",\n\t\t\t\taddr, ret);\n\n\t\tdev_vdbg(ab8500->dev, \"mask: addr %#x => data %#x\\n\", addr,\n\t\t\tdata);\n\t\tgoto out;\n\t}\n\tret = ab8500->write_masked(ab8500, addr, bitmask, bitvalues);\n\tif (ret < 0)\n\t\tdev_err(ab8500->dev, \"failed to modify reg %#x: %d\\n\", addr,\n\t\t\tret);\nout:\n\tmutex_unlock(&ab8500->lock);\n\treturn ret;\n}\n\nstatic int ab8500_mask_and_set_register(struct device *dev,\n\tu8 bank, u8 reg, u8 bitmask, u8 bitvalues)\n{\n\tint ret;\n\tstruct ab8500 *ab8500 = dev_get_drvdata(dev->parent);\n\n\tatomic_inc(&ab8500->transfer_ongoing);\n\tret = mask_and_set_register_interruptible(ab8500, bank, reg,\n\t\t\t\t\t\t bitmask, bitvalues);\n\tatomic_dec(&ab8500->transfer_ongoing);\n\treturn ret;\n}\n\nstatic struct abx500_ops ab8500_ops = {\n\t.get_chip_id = ab8500_get_chip_id,\n\t.get_register = ab8500_get_register,\n\t.set_register = ab8500_set_register,\n\t.get_register_page = NULL,\n\t.set_register_page = NULL,\n\t.mask_and_set_register = ab8500_mask_and_set_register,\n\t.event_registers_startup_state_get = NULL,\n\t.startup_irq_enabled = NULL,\n\t.dump_all_banks = ab8500_dump_all_banks,\n};\n\nstatic void ab8500_irq_lock(struct irq_data *data)\n{\n\tstruct ab8500 *ab8500 = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&ab8500->irq_lock);\n\tatomic_inc(&ab8500->transfer_ongoing);\n}\n\nstatic void ab8500_irq_sync_unlock(struct irq_data *data)\n{\n\tstruct ab8500 *ab8500 = irq_data_get_irq_chip_data(data);\n\tint i;\n\n\tfor (i = 0; i < ab8500->mask_size; i++) {\n\t\tu8 old = ab8500->oldmask[i];\n\t\tu8 new = ab8500->mask[i];\n\t\tint reg;\n\n\t\tif (new == old)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ab8500->irq_reg_offset[i] == 11 &&\n\t\t\tis_ab8500_1p1_or_earlier(ab8500))\n\t\t\tcontinue;\n\n\t\tif (ab8500->irq_reg_offset[i] < 0)\n\t\t\tcontinue;\n\n\t\tab8500->oldmask[i] = new;\n\n\t\treg = AB8500_IT_MASK1_REG + ab8500->irq_reg_offset[i];\n\t\tset_register_interruptible(ab8500, AB8500_INTERRUPT, reg, new);\n\t}\n\tatomic_dec(&ab8500->transfer_ongoing);\n\tmutex_unlock(&ab8500->irq_lock);\n}\n\nstatic void ab8500_irq_mask(struct irq_data *data)\n{\n\tstruct ab8500 *ab8500 = irq_data_get_irq_chip_data(data);\n\tint offset = data->hwirq;\n\tint index = offset / 8;\n\tint mask = 1 << (offset % 8);\n\n\tab8500->mask[index] |= mask;\n\n\t \n\tif (offset >= AB8500_INT_GPIO6R && offset <= AB8500_INT_GPIO41R)\n\t\tab8500->mask[index + 2] |= mask;\n\tif (offset >= AB9540_INT_GPIO50R && offset <= AB9540_INT_GPIO54R)\n\t\tab8500->mask[index + 1] |= mask;\n\tif (offset == AB8540_INT_GPIO43R || offset == AB8540_INT_GPIO44R)\n\t\t \n\t\tab8500->mask[index] |= (mask << 1);\n}\n\nstatic void ab8500_irq_unmask(struct irq_data *data)\n{\n\tstruct ab8500 *ab8500 = irq_data_get_irq_chip_data(data);\n\tunsigned int type = irqd_get_trigger_type(data);\n\tint offset = data->hwirq;\n\tint index = offset / 8;\n\tint mask = 1 << (offset % 8);\n\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tab8500->mask[index] &= ~mask;\n\n\t \n\tif (type & IRQ_TYPE_EDGE_FALLING) {\n\t\tif (offset >= AB8500_INT_GPIO6R && offset <= AB8500_INT_GPIO41R)\n\t\t\tab8500->mask[index + 2] &= ~mask;\n\t\telse if (offset >= AB9540_INT_GPIO50R &&\n\t\t\t offset <= AB9540_INT_GPIO54R)\n\t\t\tab8500->mask[index + 1] &= ~mask;\n\t\telse if (offset == AB8540_INT_GPIO43R ||\n\t\t\t offset == AB8540_INT_GPIO44R)\n\t\t\t \n\t\t\tab8500->mask[index] &= ~(mask << 1);\n\t\telse\n\t\t\tab8500->mask[index] &= ~mask;\n\t} else {\n\t\t \n\t\tab8500->mask[index] &= ~mask;\n\t}\n}\n\nstatic int ab8500_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\treturn 0;\n}\n\nstatic struct irq_chip ab8500_irq_chip = {\n\t.name\t\t\t= \"ab8500\",\n\t.irq_bus_lock\t\t= ab8500_irq_lock,\n\t.irq_bus_sync_unlock\t= ab8500_irq_sync_unlock,\n\t.irq_mask\t\t= ab8500_irq_mask,\n\t.irq_disable\t\t= ab8500_irq_mask,\n\t.irq_unmask\t\t= ab8500_irq_unmask,\n\t.irq_set_type\t\t= ab8500_irq_set_type,\n};\n\nstatic void update_latch_offset(u8 *offset, int i)\n{\n\t \n\tif (unlikely(*offset == 17))\n\t\t*offset = 24;\n\t \n\tif (unlikely(*offset == 16))\n\t\t*offset = 25;\n\tif ((i == 3) && (*offset >= 24))\n\t\t*offset += 2;\n}\n\nstatic int ab8500_handle_hierarchical_line(struct ab8500 *ab8500,\n\t\t\t\t\tint latch_offset, u8 latch_val)\n{\n\tint int_bit, line, i;\n\n\tfor (i = 0; i < ab8500->mask_size; i++)\n\t\tif (ab8500->irq_reg_offset[i] == latch_offset)\n\t\t\tbreak;\n\n\tif (i >= ab8500->mask_size) {\n\t\tdev_err(ab8500->dev, \"Register offset 0x%2x not declared\\n\",\n\t\t\t\tlatch_offset);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tlatch_val &= ~ab8500->mask[i];\n\n\twhile (latch_val) {\n\t\tint_bit = __ffs(latch_val);\n\t\tline = (i << 3) + int_bit;\n\t\tlatch_val &= ~(1 << int_bit);\n\n\t\t \n\t\tif (line >= AB8500_INT_GPIO6F && line <= AB8500_INT_GPIO41F)\n\t\t\tline -= 16;\n\t\tif (line >= AB9540_INT_GPIO50F && line <= AB9540_INT_GPIO54F)\n\t\t\tline -= 8;\n\t\tif (line == AB8540_INT_GPIO43F || line == AB8540_INT_GPIO44F)\n\t\t\tline += 1;\n\n\t\thandle_nested_irq(irq_find_mapping(ab8500->domain, line));\n\t}\n\n\treturn 0;\n}\n\nstatic int ab8500_handle_hierarchical_latch(struct ab8500 *ab8500,\n\t\t\t\t\tint hier_offset, u8 hier_val)\n{\n\tint latch_bit, status;\n\tu8 latch_offset, latch_val;\n\n\tdo {\n\t\tlatch_bit = __ffs(hier_val);\n\t\tlatch_offset = (hier_offset << 3) + latch_bit;\n\n\t\tupdate_latch_offset(&latch_offset, hier_offset);\n\n\t\tstatus = get_register_interruptible(ab8500,\n\t\t\t\tAB8500_INTERRUPT,\n\t\t\t\tAB8500_IT_LATCH1_REG + latch_offset,\n\t\t\t\t&latch_val);\n\t\tif (status < 0 || latch_val == 0)\n\t\t\tgoto discard;\n\n\t\tstatus = ab8500_handle_hierarchical_line(ab8500,\n\t\t\t\tlatch_offset, latch_val);\n\t\tif (status < 0)\n\t\t\treturn status;\ndiscard:\n\t\thier_val &= ~(1 << latch_bit);\n\t} while (hier_val);\n\n\treturn 0;\n}\n\nstatic irqreturn_t ab8500_hierarchical_irq(int irq, void *dev)\n{\n\tstruct ab8500 *ab8500 = dev;\n\tu8 i;\n\n\tdev_vdbg(ab8500->dev, \"interrupt\\n\");\n\n\t \n\tfor (i = 0; i < (ab8500->it_latchhier_num); i++) {\n\t\tint status;\n\t\tu8 hier_val;\n\n\t\tstatus = get_register_interruptible(ab8500, AB8500_INTERRUPT,\n\t\t\tAB8500_IT_LATCHHIER1_REG + i, &hier_val);\n\t\tif (status < 0 || hier_val == 0)\n\t\t\tcontinue;\n\n\t\tstatus = ab8500_handle_hierarchical_latch(ab8500, i, hier_val);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int ab8500_irq_map(struct irq_domain *d, unsigned int virq,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tstruct ab8500 *ab8500 = d->host_data;\n\n\tif (!ab8500)\n\t\treturn -EINVAL;\n\n\tirq_set_chip_data(virq, ab8500);\n\tirq_set_chip_and_handler(virq, &ab8500_irq_chip,\n\t\t\t\thandle_simple_irq);\n\tirq_set_nested_thread(virq, 1);\n\tirq_set_noprobe(virq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops ab8500_irq_ops = {\n\t.map    = ab8500_irq_map,\n\t.xlate  = irq_domain_xlate_twocell,\n};\n\nstatic int ab8500_irq_init(struct ab8500 *ab8500, struct device_node *np)\n{\n\tint num_irqs;\n\n\tif (is_ab8540(ab8500))\n\t\tnum_irqs = AB8540_NR_IRQS;\n\telse if (is_ab9540(ab8500))\n\t\tnum_irqs = AB9540_NR_IRQS;\n\telse if (is_ab8505(ab8500))\n\t\tnum_irqs = AB8505_NR_IRQS;\n\telse\n\t\tnum_irqs = AB8500_NR_IRQS;\n\n\t \n\tab8500->domain = irq_domain_add_simple(ab8500->dev->of_node,\n\t\t\t\t\t       num_irqs, 0,\n\t\t\t\t\t       &ab8500_irq_ops, ab8500);\n\n\tif (!ab8500->domain) {\n\t\tdev_err(ab8500->dev, \"Failed to create irqdomain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nint ab8500_suspend(struct ab8500 *ab8500)\n{\n\tif (atomic_read(&ab8500->transfer_ongoing))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct mfd_cell ab8500_bm_devs[] = {\n\tMFD_CELL_OF(\"ab8500-charger\", NULL, NULL, 0, 0,\n\t\t    \"stericsson,ab8500-charger\"),\n\tMFD_CELL_OF(\"ab8500-btemp\", NULL, NULL, 0, 0,\n\t\t    \"stericsson,ab8500-btemp\"),\n\tMFD_CELL_OF(\"ab8500-fg\", NULL, NULL, 0, 0,\n\t\t    \"stericsson,ab8500-fg\"),\n\tMFD_CELL_OF(\"ab8500-chargalg\", NULL, NULL, 0, 0,\n\t\t    \"stericsson,ab8500-chargalg\"),\n};\n\nstatic const struct mfd_cell ab8500_devs[] = {\n\tMFD_CELL_OF(\"ab8500-sysctrl\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-sysctrl\"),\n\tMFD_CELL_OF(\"ab8500-ext-regulator\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-ext-regulator\"),\n\tMFD_CELL_OF(\"ab8500-regulator\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-regulator\"),\n\tMFD_CELL_OF(\"ab8500-clk\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-clk\"),\n\tMFD_CELL_OF(\"ab8500-gpadc\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-gpadc\"),\n\tMFD_CELL_OF(\"ab8500-rtc\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-rtc\"),\n\tMFD_CELL_OF(\"ab8500-acc-det\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-acc-det\"),\n\tMFD_CELL_OF(\"ab8500-poweron-key\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-poweron-key\"),\n\tMFD_CELL_OF(\"ab8500-pwm\",\n\t\t    NULL, NULL, 0, 1, \"stericsson,ab8500-pwm\"),\n\tMFD_CELL_OF(\"ab8500-pwm\",\n\t\t    NULL, NULL, 0, 2, \"stericsson,ab8500-pwm\"),\n\tMFD_CELL_OF(\"ab8500-pwm\",\n\t\t    NULL, NULL, 0, 3, \"stericsson,ab8500-pwm\"),\n\tMFD_CELL_OF(\"ab8500-denc\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-denc\"),\n\tMFD_CELL_OF(\"pinctrl-ab8500\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-gpio\"),\n\tMFD_CELL_OF(\"abx500-temp\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,abx500-temp\"),\n\tMFD_CELL_OF(\"ab8500-usb\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-usb\"),\n\tMFD_CELL_OF(\"ab8500-codec\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,ab8500-codec\"),\n};\n\nstatic const struct mfd_cell ab9540_devs[] = {\n\t{\n\t\t.name = \"ab8500-sysctrl\",\n\t},\n\t{\n\t\t.name = \"ab8500-ext-regulator\",\n\t},\n\t{\n\t\t.name = \"ab8500-regulator\",\n\t},\n\t{\n\t\t.name = \"abx500-clk\",\n\t\t.of_compatible = \"stericsson,abx500-clk\",\n\t},\n\t{\n\t\t.name = \"ab8500-gpadc\",\n\t\t.of_compatible = \"stericsson,ab8500-gpadc\",\n\t},\n\t{\n\t\t.name = \"ab8500-rtc\",\n\t},\n\t{\n\t\t.name = \"ab8500-acc-det\",\n\t},\n\t{\n\t\t.name = \"ab8500-poweron-key\",\n\t},\n\t{\n\t\t.name = \"ab8500-pwm\",\n\t\t.id = 1,\n\t},\n\t{\n\t\t.name = \"abx500-temp\",\n\t},\n\t{\n\t\t.name = \"pinctrl-ab9540\",\n\t\t.of_compatible = \"stericsson,ab9540-gpio\",\n\t},\n\t{\n\t\t.name = \"ab9540-usb\",\n\t},\n\t{\n\t\t.name = \"ab9540-codec\",\n\t},\n\t{\n\t\t.name = \"ab-iddet\",\n\t},\n};\n\n \nstatic const struct mfd_cell ab8505_devs[] = {\n\t{\n\t\t.name = \"ab8500-sysctrl\",\n\t\t.of_compatible = \"stericsson,ab8500-sysctrl\",\n\t},\n\t{\n\t\t.name = \"ab8500-regulator\",\n\t\t.of_compatible = \"stericsson,ab8505-regulator\",\n\t},\n\t{\n\t\t.name = \"abx500-clk\",\n\t\t.of_compatible = \"stericsson,ab8500-clk\",\n\t},\n\t{\n\t\t.name = \"ab8500-gpadc\",\n\t\t.of_compatible = \"stericsson,ab8500-gpadc\",\n\t},\n\t{\n\t\t.name = \"ab8500-rtc\",\n\t\t.of_compatible = \"stericsson,ab8500-rtc\",\n\t},\n\t{\n\t\t.name = \"ab8500-acc-det\",\n\t\t.of_compatible = \"stericsson,ab8500-acc-det\",\n\t},\n\t{\n\t\t.name = \"ab8500-poweron-key\",\n\t\t.of_compatible = \"stericsson,ab8500-poweron-key\",\n\t},\n\t{\n\t\t.name = \"ab8500-pwm\",\n\t\t.of_compatible = \"stericsson,ab8500-pwm\",\n\t\t.id = 1,\n\t},\n\t{\n\t\t.name = \"pinctrl-ab8505\",\n\t\t.of_compatible = \"stericsson,ab8505-gpio\",\n\t},\n\t{\n\t\t.name = \"ab8500-usb\",\n\t\t.of_compatible = \"stericsson,ab8500-usb\",\n\t},\n\t{\n\t\t.name = \"ab8500-codec\",\n\t\t.of_compatible = \"stericsson,ab8500-codec\",\n\t},\n\t{\n\t\t.name = \"ab-iddet\",\n\t},\n};\n\nstatic const struct mfd_cell ab8540_devs[] = {\n\t{\n\t\t.name = \"ab8500-sysctrl\",\n\t},\n\t{\n\t\t.name = \"ab8500-ext-regulator\",\n\t},\n\t{\n\t\t.name = \"ab8500-regulator\",\n\t},\n\t{\n\t\t.name = \"abx500-clk\",\n\t\t.of_compatible = \"stericsson,abx500-clk\",\n\t},\n\t{\n\t\t.name = \"ab8500-gpadc\",\n\t\t.of_compatible = \"stericsson,ab8500-gpadc\",\n\t},\n\t{\n\t\t.name = \"ab8500-acc-det\",\n\t},\n\t{\n\t\t.name = \"ab8500-poweron-key\",\n\t},\n\t{\n\t\t.name = \"ab8500-pwm\",\n\t\t.id = 1,\n\t},\n\t{\n\t\t.name = \"abx500-temp\",\n\t},\n\t{\n\t\t.name = \"pinctrl-ab8540\",\n\t},\n\t{\n\t\t.name = \"ab8540-usb\",\n\t},\n\t{\n\t\t.name = \"ab8540-codec\",\n\t},\n\t{\n\t\t.name = \"ab-iddet\",\n\t},\n};\n\nstatic const struct mfd_cell ab8540_cut1_devs[] = {\n\t{\n\t\t.name = \"ab8500-rtc\",\n\t\t.of_compatible = \"stericsson,ab8500-rtc\",\n\t},\n};\n\nstatic const struct mfd_cell ab8540_cut2_devs[] = {\n\t{\n\t\t.name = \"ab8540-rtc\",\n\t\t.of_compatible = \"stericsson,ab8540-rtc\",\n\t},\n};\n\nstatic ssize_t chip_id_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ab8500 *ab8500;\n\n\tab8500 = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%#x\\n\", ab8500 ? ab8500->chip_id : -EINVAL);\n}\n\n \nstatic ssize_t switch_off_status_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tu8 value;\n\tstruct ab8500 *ab8500;\n\n\tab8500 = dev_get_drvdata(dev);\n\tret = get_register_interruptible(ab8500, AB8500_RTC,\n\t\tAB8500_SWITCH_OFF_STATUS, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sprintf(buf, \"%#x\\n\", value);\n}\n\n \nvoid ab8500_override_turn_on_stat(u8 mask, u8 set)\n{\n\tspin_lock(&on_stat_lock);\n\tturn_on_stat_mask = mask;\n\tturn_on_stat_set = set;\n\tspin_unlock(&on_stat_lock);\n}\n\n \nstatic ssize_t turn_on_status_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tu8 value;\n\tstruct ab8500 *ab8500;\n\n\tab8500 = dev_get_drvdata(dev);\n\tret = get_register_interruptible(ab8500, AB8500_SYS_CTRL1_BLOCK,\n\t\tAB8500_TURN_ON_STATUS, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (is_ab9540(ab8500)) {\n\t\tspin_lock(&on_stat_lock);\n\t\tvalue = (value & turn_on_stat_mask) | turn_on_stat_set;\n\t\tspin_unlock(&on_stat_lock);\n\t}\n\n\treturn sprintf(buf, \"%#x\\n\", value);\n}\n\nstatic ssize_t turn_on_status_2_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tu8 value;\n\tstruct ab8500 *ab8500;\n\n\tab8500 = dev_get_drvdata(dev);\n\tret = get_register_interruptible(ab8500, AB8500_SYS_CTRL1_BLOCK,\n\t\tAB8505_TURN_ON_STATUS_2, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sprintf(buf, \"%#x\\n\", (value & 0x1));\n}\n\nstatic ssize_t dbbrstn_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ab8500 *ab8500;\n\tint ret;\n\tu8 value;\n\n\tab8500 = dev_get_drvdata(dev);\n\n\tret = get_register_interruptible(ab8500, AB8500_REGU_CTRL2,\n\t\tAB9540_MODEM_CTRL2_REG, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t\t(value & AB9540_MODEM_CTRL2_SWDBBRSTN_BIT) ? 1 : 0);\n}\n\nstatic ssize_t dbbrstn_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct ab8500 *ab8500;\n\tint ret = count;\n\tint err;\n\tu8 bitvalues;\n\n\tab8500 = dev_get_drvdata(dev);\n\n\tif (count > 0) {\n\t\tswitch (buf[0]) {\n\t\tcase '0':\n\t\t\tbitvalues = 0;\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tbitvalues = AB9540_MODEM_CTRL2_SWDBBRSTN_BIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto exit;\n\t\t}\n\n\t\terr = mask_and_set_register_interruptible(ab8500,\n\t\t\tAB8500_REGU_CTRL2, AB9540_MODEM_CTRL2_REG,\n\t\t\tAB9540_MODEM_CTRL2_SWDBBRSTN_BIT, bitvalues);\n\t\tif (err)\n\t\t\tdev_info(ab8500->dev,\n\t\t\t\t\"Failed to set DBBRSTN %c, err %#x\\n\",\n\t\t\t\tbuf[0], err);\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RO(chip_id);\nstatic DEVICE_ATTR_RO(switch_off_status);\nstatic DEVICE_ATTR_RO(turn_on_status);\nstatic DEVICE_ATTR_RO(turn_on_status_2);\nstatic DEVICE_ATTR_RW(dbbrstn);\n\nstatic struct attribute *ab8500_sysfs_entries[] = {\n\t&dev_attr_chip_id.attr,\n\t&dev_attr_switch_off_status.attr,\n\t&dev_attr_turn_on_status.attr,\n\tNULL,\n};\n\nstatic struct attribute *ab8505_sysfs_entries[] = {\n\t&dev_attr_turn_on_status_2.attr,\n\tNULL,\n};\n\nstatic struct attribute *ab9540_sysfs_entries[] = {\n\t&dev_attr_chip_id.attr,\n\t&dev_attr_switch_off_status.attr,\n\t&dev_attr_turn_on_status.attr,\n\t&dev_attr_dbbrstn.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ab8500_attr_group = {\n\t.attrs\t= ab8500_sysfs_entries,\n};\n\nstatic const struct attribute_group ab8505_attr_group = {\n\t.attrs\t= ab8505_sysfs_entries,\n};\n\nstatic const struct attribute_group ab9540_attr_group = {\n\t.attrs\t= ab9540_sysfs_entries,\n};\n\nstatic int ab8500_probe(struct platform_device *pdev)\n{\n\tstatic const char * const switch_off_status[] = {\n\t\t\"Swoff bit programming\",\n\t\t\"Thermal protection activation\",\n\t\t\"Vbat lower then BattOk falling threshold\",\n\t\t\"Watchdog expired\",\n\t\t\"Non presence of 32kHz clock\",\n\t\t\"Battery level lower than power on reset threshold\",\n\t\t\"Power on key 1 pressed longer than 10 seconds\",\n\t\t\"DB8500 thermal shutdown\"};\n\tstatic const char * const turn_on_status[] = {\n\t\t\"Battery rising (Vbat)\",\n\t\t\"Power On Key 1 dbF\",\n\t\t\"Power On Key 2 dbF\",\n\t\t\"RTC Alarm\",\n\t\t\"Main Charger Detect\",\n\t\t\"Vbus Detect (USB)\",\n\t\t\"USB ID Detect\",\n\t\t\"UART Factory Mode Detect\"};\n\tconst struct platform_device_id *platid = platform_get_device_id(pdev);\n\tenum ab8500_version version = AB8500_VERSION_UNDEFINED;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct ab8500 *ab8500;\n\tint ret;\n\tint i;\n\tint irq;\n\tu8 value;\n\n\tab8500 = devm_kzalloc(&pdev->dev, sizeof(*ab8500), GFP_KERNEL);\n\tif (!ab8500)\n\t\treturn -ENOMEM;\n\n\tab8500->dev = &pdev->dev;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tab8500->irq = irq;\n\n\tab8500->read = ab8500_prcmu_read;\n\tab8500->write = ab8500_prcmu_write;\n\tab8500->write_masked = ab8500_prcmu_write_masked;\n\n\tmutex_init(&ab8500->lock);\n\tmutex_init(&ab8500->irq_lock);\n\tatomic_set(&ab8500->transfer_ongoing, 0);\n\n\tplatform_set_drvdata(pdev, ab8500);\n\n\tif (platid)\n\t\tversion = platid->driver_data;\n\n\tif (version != AB8500_VERSION_UNDEFINED)\n\t\tab8500->version = version;\n\telse {\n\t\tret = get_register_interruptible(ab8500, AB8500_MISC,\n\t\t\tAB8500_IC_NAME_REG, &value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"could not probe HW\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tab8500->version = value;\n\t}\n\n\tret = get_register_interruptible(ab8500, AB8500_MISC,\n\t\tAB8500_REV_REG, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tab8500->chip_id = value;\n\n\tdev_info(ab8500->dev, \"detected chip, %s rev. %1x.%1x\\n\",\n\t\t\tab8500_version_str[ab8500->version],\n\t\t\tab8500->chip_id >> 4,\n\t\t\tab8500->chip_id & 0x0F);\n\n\t \n\tif (is_ab8540(ab8500)) {\n\t\tab8500->mask_size = AB8540_NUM_IRQ_REGS;\n\t\tab8500->irq_reg_offset = ab8540_irq_regoffset;\n\t\tab8500->it_latchhier_num = AB8540_IT_LATCHHIER_NUM;\n\t}  \n\telse if (is_ab9540(ab8500) || is_ab8505(ab8500)) {\n\t\tab8500->mask_size = AB9540_NUM_IRQ_REGS;\n\t\tab8500->irq_reg_offset = ab9540_irq_regoffset;\n\t\tab8500->it_latchhier_num = AB8500_IT_LATCHHIER_NUM;\n\t} else {\n\t\tab8500->mask_size = AB8500_NUM_IRQ_REGS;\n\t\tab8500->irq_reg_offset = ab8500_irq_regoffset;\n\t\tab8500->it_latchhier_num = AB8500_IT_LATCHHIER_NUM;\n\t}\n\tab8500->mask = devm_kzalloc(&pdev->dev, ab8500->mask_size,\n\t\t\t\t    GFP_KERNEL);\n\tif (!ab8500->mask)\n\t\treturn -ENOMEM;\n\tab8500->oldmask = devm_kzalloc(&pdev->dev, ab8500->mask_size,\n\t\t\t\t       GFP_KERNEL);\n\tif (!ab8500->oldmask)\n\t\treturn -ENOMEM;\n\n\t \n\n\tret = get_register_interruptible(ab8500, AB8500_RTC,\n\t\tAB8500_SWITCH_OFF_STATUS, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev_info(ab8500->dev, \"switch off cause(s) (%#x): \", value);\n\n\tif (value) {\n\t\tfor (i = 0; i < ARRAY_SIZE(switch_off_status); i++) {\n\t\t\tif (value & 1)\n\t\t\t\tpr_cont(\" \\\"%s\\\"\", switch_off_status[i]);\n\t\t\tvalue = value >> 1;\n\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t} else {\n\t\tpr_cont(\" None\\n\");\n\t}\n\tret = get_register_interruptible(ab8500, AB8500_SYS_CTRL1_BLOCK,\n\t\tAB8500_TURN_ON_STATUS, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev_info(ab8500->dev, \"turn on reason(s) (%#x): \", value);\n\n\tif (value) {\n\t\tfor (i = 0; i < ARRAY_SIZE(turn_on_status); i++) {\n\t\t\tif (value & 1)\n\t\t\t\tpr_cont(\"\\\"%s\\\" \", turn_on_status[i]);\n\t\t\tvalue = value >> 1;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t} else {\n\t\tpr_cont(\"None\\n\");\n\t}\n\n\tif (is_ab9540(ab8500)) {\n\t\tret = get_register_interruptible(ab8500, AB8500_CHARGER,\n\t\t\tAB8500_CH_USBCH_STAT1_REG, &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif ((value & VBUS_DET_DBNC1) && (value & VBUS_DET_DBNC100))\n\t\t\tab8500_override_turn_on_stat(~AB8500_POW_KEY_1_ON,\n\t\t\t\t\t\t     AB8500_VBUS_DET);\n\t}\n\n\t \n\tfor (i = 0; i < ab8500->mask_size; i++) {\n\t\t \n\t\tif (ab8500->irq_reg_offset[i] == 11 &&\n\t\t\t\tis_ab8500_1p1_or_earlier(ab8500))\n\t\t\tcontinue;\n\n\t\tif (ab8500->irq_reg_offset[i] < 0)\n\t\t\tcontinue;\n\n\t\tget_register_interruptible(ab8500, AB8500_INTERRUPT,\n\t\t\tAB8500_IT_LATCH1_REG + ab8500->irq_reg_offset[i],\n\t\t\t&value);\n\t\tset_register_interruptible(ab8500, AB8500_INTERRUPT,\n\t\t\tAB8500_IT_MASK1_REG + ab8500->irq_reg_offset[i], 0xff);\n\t}\n\n\tret = abx500_register_ops(ab8500->dev, &ab8500_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ab8500->mask_size; i++)\n\t\tab8500->mask[i] = ab8500->oldmask[i] = 0xff;\n\n\tret = ab8500_irq_init(ab8500, np);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_threaded_irq(&pdev->dev, ab8500->irq, NULL,\n\t\t\tab8500_hierarchical_irq,\n\t\t\tIRQF_ONESHOT | IRQF_NO_SUSPEND,\n\t\t\t\"ab8500\", ab8500);\n\tif (ret)\n\t\treturn ret;\n\n\tif (is_ab9540(ab8500))\n\t\tret = mfd_add_devices(ab8500->dev, 0, ab9540_devs,\n\t\t\t\tARRAY_SIZE(ab9540_devs), NULL,\n\t\t\t\t0, ab8500->domain);\n\telse if (is_ab8540(ab8500)) {\n\t\tret = mfd_add_devices(ab8500->dev, 0, ab8540_devs,\n\t\t\t      ARRAY_SIZE(ab8540_devs), NULL,\n\t\t\t      0, ab8500->domain);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (is_ab8540_1p2_or_earlier(ab8500))\n\t\t\tret = mfd_add_devices(ab8500->dev, 0, ab8540_cut1_devs,\n\t\t\t      ARRAY_SIZE(ab8540_cut1_devs), NULL,\n\t\t\t      0, ab8500->domain);\n\t\telse  \n\t\t\tret = mfd_add_devices(ab8500->dev, 0, ab8540_cut2_devs,\n\t\t\t      ARRAY_SIZE(ab8540_cut2_devs), NULL,\n\t\t\t      0, ab8500->domain);\n\t} else if (is_ab8505(ab8500))\n\t\tret = mfd_add_devices(ab8500->dev, 0, ab8505_devs,\n\t\t\t      ARRAY_SIZE(ab8505_devs), NULL,\n\t\t\t      0, ab8500->domain);\n\telse\n\t\tret = mfd_add_devices(ab8500->dev, 0, ab8500_devs,\n\t\t\t\tARRAY_SIZE(ab8500_devs), NULL,\n\t\t\t\t0, ab8500->domain);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mfd_add_devices(ab8500->dev, 0, ab8500_bm_devs,\n\t\t\t      ARRAY_SIZE(ab8500_bm_devs), NULL,\n\t\t\t      0, ab8500->domain);\n\tif (ret)\n\t\tdev_err(ab8500->dev, \"error adding bm devices\\n\");\n\n\tif (((is_ab8505(ab8500) || is_ab9540(ab8500)) &&\n\t\t\tab8500->chip_id >= AB8500_CUT2P0) || is_ab8540(ab8500))\n\t\tret = sysfs_create_group(&ab8500->dev->kobj,\n\t\t\t\t\t&ab9540_attr_group);\n\telse\n\t\tret = sysfs_create_group(&ab8500->dev->kobj,\n\t\t\t\t\t&ab8500_attr_group);\n\n\tif ((is_ab8505(ab8500) || is_ab9540(ab8500)) &&\n\t\t\tab8500->chip_id >= AB8500_CUT2P0)\n\t\tret = sysfs_create_group(&ab8500->dev->kobj,\n\t\t\t\t\t &ab8505_attr_group);\n\n\tif (ret)\n\t\tdev_err(ab8500->dev, \"error creating sysfs entries\\n\");\n\n\treturn ret;\n}\n\nstatic const struct platform_device_id ab8500_id[] = {\n\t{ \"ab8500-core\", AB8500_VERSION_AB8500 },\n\t{ \"ab8505-core\", AB8500_VERSION_AB8505 },\n\t{ \"ab9540-i2c\", AB8500_VERSION_AB9540 },\n\t{ \"ab8540-i2c\", AB8500_VERSION_AB8540 },\n\t{ }\n};\n\nstatic struct platform_driver ab8500_core_driver = {\n\t.driver = {\n\t\t.name = \"ab8500-core\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t= ab8500_probe,\n\t.id_table = ab8500_id,\n};\n\nstatic int __init ab8500_core_init(void)\n{\n\treturn platform_driver_register(&ab8500_core_driver);\n}\ncore_initcall(ab8500_core_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}