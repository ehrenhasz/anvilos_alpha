{
  "module_name": "sta2x11-mfd.c",
  "hash_id": "160c07f1f3d268052acf21048bef1242304ad26551a2a62ad383519cd23f0a39",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/sta2x11-mfd.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/sta2x11-mfd.h>\n#include <linux/regmap.h>\n\n#include <asm/sta2x11.h>\n\nstatic inline int __reg_within_range(unsigned int r,\n\t\t\t\t     unsigned int start,\n\t\t\t\t     unsigned int end)\n{\n\treturn ((r >= start) && (r <= end));\n}\n\n \nstruct sta2x11_mfd {\n\tstruct sta2x11_instance *instance;\n\tstruct regmap *regmap[sta2x11_n_mfd_plat_devs];\n\tspinlock_t lock[sta2x11_n_mfd_plat_devs];\n\tstruct list_head list;\n\tvoid __iomem *regs[sta2x11_n_mfd_plat_devs];\n};\n\nstatic LIST_HEAD(sta2x11_mfd_list);\n\n \nstatic struct sta2x11_mfd *sta2x11_mfd_find(struct pci_dev *pdev)\n{\n\tstruct sta2x11_instance *instance;\n\tstruct sta2x11_mfd *mfd;\n\n\tif (!pdev && !list_empty(&sta2x11_mfd_list)) {\n\t\tpr_warn(\"%s: Unspecified device, using first instance\\n\",\n\t\t\t__func__);\n\t\treturn list_entry(sta2x11_mfd_list.next,\n\t\t\t\t  struct sta2x11_mfd, list);\n\t}\n\n\tinstance = sta2x11_get_instance(pdev);\n\tif (!instance)\n\t\treturn NULL;\n\tlist_for_each_entry(mfd, &sta2x11_mfd_list, list) {\n\t\tif (mfd->instance == instance)\n\t\t\treturn mfd;\n\t}\n\treturn NULL;\n}\n\nstatic int sta2x11_mfd_add(struct pci_dev *pdev, gfp_t flags)\n{\n\tint i;\n\tstruct sta2x11_mfd *mfd = sta2x11_mfd_find(pdev);\n\tstruct sta2x11_instance *instance;\n\n\tif (mfd)\n\t\treturn -EBUSY;\n\tinstance = sta2x11_get_instance(pdev);\n\tif (!instance)\n\t\treturn -EINVAL;\n\tmfd = kzalloc(sizeof(*mfd), flags);\n\tif (!mfd)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&mfd->list);\n\tfor (i = 0; i < ARRAY_SIZE(mfd->lock); i++)\n\t\tspin_lock_init(&mfd->lock[i]);\n\tmfd->instance = instance;\n\tlist_add(&mfd->list, &sta2x11_mfd_list);\n\treturn 0;\n}\n\n \nu32 __sta2x11_mfd_mask(struct pci_dev *pdev, u32 reg, u32 mask, u32 val,\n\t\t       enum sta2x11_mfd_plat_dev index)\n{\n\tstruct sta2x11_mfd *mfd = sta2x11_mfd_find(pdev);\n\tu32 r;\n\tunsigned long flags;\n\tvoid __iomem *regs;\n\n\tif (!mfd) {\n\t\tdev_warn(&pdev->dev, \": can't access sctl regs\\n\");\n\t\treturn 0;\n\t}\n\n\tregs = mfd->regs[index];\n\tif (!regs) {\n\t\tdev_warn(&pdev->dev, \": system ctl not initialized\\n\");\n\t\treturn 0;\n\t}\n\tspin_lock_irqsave(&mfd->lock[index], flags);\n\tr = readl(regs + reg);\n\tr &= ~mask;\n\tr |= val;\n\tif (mask)\n\t\twritel(r, regs + reg);\n\tspin_unlock_irqrestore(&mfd->lock[index], flags);\n\treturn r;\n}\nEXPORT_SYMBOL(__sta2x11_mfd_mask);\n\nint sta2x11_mfd_get_regs_data(struct platform_device *dev,\n\t\t\t      enum sta2x11_mfd_plat_dev index,\n\t\t\t      void __iomem **regs,\n\t\t\t      spinlock_t **lock)\n{\n\tstruct pci_dev *pdev = *(struct pci_dev **)dev_get_platdata(&dev->dev);\n\tstruct sta2x11_mfd *mfd;\n\n\tif (!pdev)\n\t\treturn -ENODEV;\n\tmfd = sta2x11_mfd_find(pdev);\n\tif (!mfd)\n\t\treturn -ENODEV;\n\tif (index >= sta2x11_n_mfd_plat_devs)\n\t\treturn -ENODEV;\n\t*regs = mfd->regs[index];\n\t*lock = &mfd->lock[index];\n\tpr_debug(\"%s %d *regs = %p\\n\", __func__, __LINE__, *regs);\n\treturn *regs ? 0 : -ENODEV;\n}\nEXPORT_SYMBOL(sta2x11_mfd_get_regs_data);\n\n \n\nstatic void sta2x11_regmap_lock(void *__lock)\n{\n\tspinlock_t *lock = __lock;\n\tspin_lock(lock);\n}\n\nstatic void sta2x11_regmap_unlock(void *__lock)\n{\n\tspinlock_t *lock = __lock;\n\tspin_unlock(lock);\n}\n\n \nstatic void sta2x11_regmap_nolock(void *__lock)\n{\n}\n\nstatic const char *sta2x11_mfd_names[sta2x11_n_mfd_plat_devs] = {\n\t[sta2x11_sctl] = STA2X11_MFD_SCTL_NAME,\n\t[sta2x11_apbreg] = STA2X11_MFD_APBREG_NAME,\n\t[sta2x11_apb_soc_regs] = STA2X11_MFD_APB_SOC_REGS_NAME,\n\t[sta2x11_scr] = STA2X11_MFD_SCR_NAME,\n};\n\nstatic bool sta2x11_sctl_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn !__reg_within_range(reg, SCTL_SCPCIECSBRST, SCTL_SCRSTSTA);\n}\n\nstatic struct regmap_config sta2x11_sctl_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.lock = sta2x11_regmap_lock,\n\t.unlock = sta2x11_regmap_unlock,\n\t.max_register = SCTL_SCRSTSTA,\n\t.writeable_reg = sta2x11_sctl_writeable_reg,\n};\n\nstatic bool sta2x11_scr_readable_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg == STA2X11_SECR_CR) ||\n\t\t__reg_within_range(reg, STA2X11_SECR_FVR0, STA2X11_SECR_FVR1);\n}\n\nstatic bool sta2x11_scr_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn false;\n}\n\nstatic struct regmap_config sta2x11_scr_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.lock = sta2x11_regmap_nolock,\n\t.unlock = sta2x11_regmap_nolock,\n\t.max_register = STA2X11_SECR_FVR1,\n\t.readable_reg = sta2x11_scr_readable_reg,\n\t.writeable_reg = sta2x11_scr_writeable_reg,\n};\n\nstatic bool sta2x11_apbreg_readable_reg(struct device *dev, unsigned int reg)\n{\n\t \n\tif (reg >= APBREG_BSR_SARAC)\n\t\treg -= APBREG_BSR_SARAC;\n\tswitch (reg) {\n\tcase APBREG_BSR:\n\tcase APBREG_PAER:\n\tcase APBREG_PWAC:\n\tcase APBREG_PRAC:\n\tcase APBREG_PCG:\n\tcase APBREG_PUR:\n\tcase APBREG_EMU_PCG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool sta2x11_apbreg_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg >= APBREG_BSR_SARAC)\n\t\treg -= APBREG_BSR_SARAC;\n\tif (!sta2x11_apbreg_readable_reg(dev, reg))\n\t\treturn false;\n\treturn reg != APBREG_PAER;\n}\n\nstatic struct regmap_config sta2x11_apbreg_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.lock = sta2x11_regmap_lock,\n\t.unlock = sta2x11_regmap_unlock,\n\t.max_register = APBREG_EMU_PCG_SARAC,\n\t.readable_reg = sta2x11_apbreg_readable_reg,\n\t.writeable_reg = sta2x11_apbreg_writeable_reg,\n};\n\nstatic bool sta2x11_apb_soc_regs_readable_reg(struct device *dev,\n\t\t\t\t\t      unsigned int reg)\n{\n\treturn reg <= PCIE_SoC_INT_ROUTER_STATUS3_REG ||\n\t\t__reg_within_range(reg, DMA_IP_CTRL_REG, SPARE3_RESERVED) ||\n\t\t__reg_within_range(reg, MASTER_LOCK_REG,\n\t\t\t\t   SYSTEM_CONFIG_STATUS_REG) ||\n\t\treg == MSP_CLK_CTRL_REG ||\n\t\t__reg_within_range(reg, COMPENSATION_REG1, TEST_CTL_REG);\n}\n\nstatic bool sta2x11_apb_soc_regs_writeable_reg(struct device *dev,\n\t\t\t\t\t       unsigned int reg)\n{\n\tif (!sta2x11_apb_soc_regs_readable_reg(dev, reg))\n\t\treturn false;\n\tswitch (reg) {\n\tcase PCIE_COMMON_CLOCK_CONFIG_0_4_0:\n\tcase SYSTEM_CONFIG_STATUS_REG:\n\tcase COMPENSATION_REG1:\n\tcase PCIE_SoC_INT_ROUTER_STATUS0_REG...PCIE_SoC_INT_ROUTER_STATUS3_REG:\n\tcase PCIE_PM_STATUS_0_PORT_0_4...PCIE_PM_STATUS_7_0_EP4:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic struct regmap_config sta2x11_apb_soc_regs_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.lock = sta2x11_regmap_lock,\n\t.unlock = sta2x11_regmap_unlock,\n\t.max_register = TEST_CTL_REG,\n\t.readable_reg = sta2x11_apb_soc_regs_readable_reg,\n\t.writeable_reg = sta2x11_apb_soc_regs_writeable_reg,\n};\n\nstatic struct regmap_config *\nsta2x11_mfd_regmap_configs[sta2x11_n_mfd_plat_devs] = {\n\t[sta2x11_sctl] = &sta2x11_sctl_regmap_config,\n\t[sta2x11_apbreg] = &sta2x11_apbreg_regmap_config,\n\t[sta2x11_apb_soc_regs] = &sta2x11_apb_soc_regs_regmap_config,\n\t[sta2x11_scr] = &sta2x11_scr_regmap_config,\n};\n\n \n\nstatic int sta2x11_mfd_platform_probe(struct platform_device *dev,\n\t\t\t\t      enum sta2x11_mfd_plat_dev index)\n{\n\tstruct pci_dev **pdev;\n\tstruct sta2x11_mfd *mfd;\n\tstruct resource *res;\n\tconst char *name = sta2x11_mfd_names[index];\n\tstruct regmap_config *regmap_config = sta2x11_mfd_regmap_configs[index];\n\n\tpdev = dev_get_platdata(&dev->dev);\n\tmfd = sta2x11_mfd_find(*pdev);\n\tif (!mfd)\n\t\treturn -ENODEV;\n\tif (!regmap_config)\n\t\treturn -ENODEV;\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tif (!request_mem_region(res->start, resource_size(res), name))\n\t\treturn -EBUSY;\n\n\tmfd->regs[index] = ioremap(res->start, resource_size(res));\n\tif (!mfd->regs[index]) {\n\t\trelease_mem_region(res->start, resource_size(res));\n\t\treturn -ENOMEM;\n\t}\n\tregmap_config->lock_arg = &mfd->lock;\n\t \n\tregmap_config->cache_type = REGCACHE_NONE;\n\tmfd->regmap[index] = devm_regmap_init_mmio(&dev->dev, mfd->regs[index],\n\t\t\t\t\t\t   regmap_config);\n\tWARN_ON(IS_ERR(mfd->regmap[index]));\n\n\treturn 0;\n}\n\nstatic int sta2x11_sctl_probe(struct platform_device *dev)\n{\n\treturn sta2x11_mfd_platform_probe(dev, sta2x11_sctl);\n}\n\nstatic int sta2x11_apbreg_probe(struct platform_device *dev)\n{\n\treturn sta2x11_mfd_platform_probe(dev, sta2x11_apbreg);\n}\n\nstatic int sta2x11_apb_soc_regs_probe(struct platform_device *dev)\n{\n\treturn sta2x11_mfd_platform_probe(dev, sta2x11_apb_soc_regs);\n}\n\nstatic int sta2x11_scr_probe(struct platform_device *dev)\n{\n\treturn sta2x11_mfd_platform_probe(dev, sta2x11_scr);\n}\n\n \nstatic struct platform_driver sta2x11_sctl_platform_driver = {\n\t.driver = {\n\t\t.name\t= STA2X11_MFD_SCTL_NAME,\n\t},\n\t.probe\t\t= sta2x11_sctl_probe,\n};\n\nstatic struct platform_driver sta2x11_platform_driver = {\n\t.driver = {\n\t\t.name\t= STA2X11_MFD_APBREG_NAME,\n\t},\n\t.probe\t\t= sta2x11_apbreg_probe,\n};\n\nstatic struct platform_driver sta2x11_apb_soc_regs_platform_driver = {\n\t.driver = {\n\t\t.name\t= STA2X11_MFD_APB_SOC_REGS_NAME,\n\t},\n\t.probe\t\t= sta2x11_apb_soc_regs_probe,\n};\n\nstatic struct platform_driver sta2x11_scr_platform_driver = {\n\t.driver = {\n\t\t.name = STA2X11_MFD_SCR_NAME,\n\t},\n\t.probe = sta2x11_scr_probe,\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&sta2x11_platform_driver,\n\t&sta2x11_sctl_platform_driver,\n\t&sta2x11_apb_soc_regs_platform_driver,\n\t&sta2x11_scr_platform_driver,\n};\n\nstatic int __init sta2x11_drivers_init(void)\n{\n\treturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n}\n\n \n\n \n\n \nenum mfd0_bar0_cells {\n\tSTA2X11_GPIO_0 = 0,\n\tSTA2X11_GPIO_1,\n\tSTA2X11_GPIO_2,\n\tSTA2X11_GPIO_3,\n\tSTA2X11_SCTL,\n\tSTA2X11_SCR,\n\tSTA2X11_TIME,\n};\n \nenum mfd0_bar1_cells {\n\tSTA2X11_APBREG = 0,\n};\n#define CELL_4K(_name, _cell) { \\\n\t\t.name = _name, \\\n\t\t.start = _cell * 4096, .end = _cell * 4096 + 4095, \\\n\t\t.flags = IORESOURCE_MEM, \\\n\t\t}\n\nstatic const struct resource gpio_resources[] = {\n\t{\n\t\t \n\t\t.name = STA2X11_MFD_GPIO_NAME,\n\t\t.start = 0,\n\t\t.end = (4 * 4096) - 1,\n\t\t.flags = IORESOURCE_MEM,\n\t}\n};\nstatic const struct resource sctl_resources[] = {\n\tCELL_4K(STA2X11_MFD_SCTL_NAME, STA2X11_SCTL),\n};\nstatic const struct resource scr_resources[] = {\n\tCELL_4K(STA2X11_MFD_SCR_NAME, STA2X11_SCR),\n};\nstatic const struct resource time_resources[] = {\n\tCELL_4K(STA2X11_MFD_TIME_NAME, STA2X11_TIME),\n};\n\nstatic const struct resource apbreg_resources[] = {\n\tCELL_4K(STA2X11_MFD_APBREG_NAME, STA2X11_APBREG),\n};\n\n#define DEV(_name, _r) \\\n\t{ .name = _name, .num_resources = ARRAY_SIZE(_r), .resources = _r, }\n\nstatic struct mfd_cell sta2x11_mfd0_bar0[] = {\n\t \n\tDEV(STA2X11_MFD_GPIO_NAME, gpio_resources),\n\tDEV(STA2X11_MFD_SCTL_NAME, sctl_resources),\n\tDEV(STA2X11_MFD_SCR_NAME,  scr_resources),\n\tDEV(STA2X11_MFD_TIME_NAME, time_resources),\n};\n\nstatic struct mfd_cell sta2x11_mfd0_bar1[] = {\n\tDEV(STA2X11_MFD_APBREG_NAME, apbreg_resources),\n};\n\n \n\n \nenum mfd1_bar0_cells {\n\tSTA2X11_VIC = 0,\n};\n\n \nenum mfd1_bar1_cells {\n\tSTA2X11_APB_SOC_REGS = 0,\n};\n\nstatic const struct resource vic_resources[] = {\n\tCELL_4K(STA2X11_MFD_VIC_NAME, STA2X11_VIC),\n};\n\nstatic const struct resource apb_soc_regs_resources[] = {\n\tCELL_4K(STA2X11_MFD_APB_SOC_REGS_NAME, STA2X11_APB_SOC_REGS),\n};\n\nstatic struct mfd_cell sta2x11_mfd1_bar0[] = {\n\tDEV(STA2X11_MFD_VIC_NAME, vic_resources),\n};\n\nstatic struct mfd_cell sta2x11_mfd1_bar1[] = {\n\tDEV(STA2X11_MFD_APB_SOC_REGS_NAME, apb_soc_regs_resources),\n};\n\n\nstatic int sta2x11_mfd_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\n\treturn 0;\n}\n\nstatic int sta2x11_mfd_resume(struct pci_dev *pdev)\n{\n\tint err;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\tpci_restore_state(pdev);\n\n\treturn 0;\n}\n\nstruct sta2x11_mfd_bar_setup_data {\n\tstruct mfd_cell *cells;\n\tint ncells;\n};\n\nstruct sta2x11_mfd_setup_data {\n\tstruct sta2x11_mfd_bar_setup_data bars[2];\n};\n\n#define STA2X11_MFD0 0\n#define STA2X11_MFD1 1\n\nstatic struct sta2x11_mfd_setup_data mfd_setup_data[] = {\n\t \n\t[STA2X11_MFD0] = {\n\t\t.bars = {\n\t\t\t[0] = {\n\t\t\t\t.cells = sta2x11_mfd0_bar0,\n\t\t\t\t.ncells = ARRAY_SIZE(sta2x11_mfd0_bar0),\n\t\t\t},\n\t\t\t[1] = {\n\t\t\t\t.cells = sta2x11_mfd0_bar1,\n\t\t\t\t.ncells = ARRAY_SIZE(sta2x11_mfd0_bar1),\n\t\t\t},\n\t\t},\n\t},\n\t \n\t[STA2X11_MFD1] = {\n\t\t.bars = {\n\t\t\t[0] = {\n\t\t\t\t.cells = sta2x11_mfd1_bar0,\n\t\t\t\t.ncells = ARRAY_SIZE(sta2x11_mfd1_bar0),\n\t\t\t},\n\t\t\t[1] = {\n\t\t\t\t.cells = sta2x11_mfd1_bar1,\n\t\t\t\t.ncells = ARRAY_SIZE(sta2x11_mfd1_bar1),\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic void sta2x11_mfd_setup(struct pci_dev *pdev,\n\t\t\t      struct sta2x11_mfd_setup_data *sd)\n{\n\tint i, j;\n\tfor (i = 0; i < ARRAY_SIZE(sd->bars); i++)\n\t\tfor (j = 0; j < sd->bars[i].ncells; j++) {\n\t\t\tsd->bars[i].cells[j].pdata_size = sizeof(pdev);\n\t\t\tsd->bars[i].cells[j].platform_data = &pdev;\n\t\t}\n}\n\nstatic int sta2x11_mfd_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *pci_id)\n{\n\tint err, i;\n\tstruct sta2x11_mfd_setup_data *setup_data;\n\n\tdev_info(&pdev->dev, \"%s\\n\", __func__);\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Can't enable device.\\n\");\n\t\treturn err;\n\t}\n\n\terr = pci_enable_msi(pdev);\n\tif (err)\n\t\tdev_info(&pdev->dev, \"Enable msi failed\\n\");\n\n\tsetup_data = pci_id->device == PCI_DEVICE_ID_STMICRO_GPIO ?\n\t\t&mfd_setup_data[STA2X11_MFD0] :\n\t\t&mfd_setup_data[STA2X11_MFD1];\n\n\t \n\tsta2x11_mfd_setup(pdev, setup_data);\n\n\t \n\tif (!sta2x11_mfd_find(pdev))\n\t\tsta2x11_mfd_add(pdev, GFP_KERNEL);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\terr = mfd_add_devices(&pdev->dev, -1,\n\t\t\t\t      setup_data->bars[i].cells,\n\t\t\t\t      setup_data->bars[i].ncells,\n\t\t\t\t      &pdev->resource[i],\n\t\t\t\t      0, NULL);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"mfd_add_devices[%d] failed: %d\\n\", i, err);\n\t\t\tgoto err_disable;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_disable:\n\tmfd_remove_devices(&pdev->dev);\n\tpci_disable_device(pdev);\n\tpci_disable_msi(pdev);\n\treturn err;\n}\n\nstatic const struct pci_device_id sta2x11_mfd_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_STMICRO, PCI_DEVICE_ID_STMICRO_GPIO)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_STMICRO, PCI_DEVICE_ID_STMICRO_VIC)},\n\t{0,},\n};\n\nstatic struct pci_driver sta2x11_mfd_driver = {\n\t.name =\t\t\"sta2x11-mfd\",\n\t.id_table =\tsta2x11_mfd_tbl,\n\t.probe =\tsta2x11_mfd_probe,\n\t.suspend =\tsta2x11_mfd_suspend,\n\t.resume =\tsta2x11_mfd_resume,\n};\n\nstatic int __init sta2x11_mfd_init(void)\n{\n\tpr_info(\"%s\\n\", __func__);\n\treturn pci_register_driver(&sta2x11_mfd_driver);\n}\n\n \nsubsys_initcall(sta2x11_drivers_init);\nrootfs_initcall(sta2x11_mfd_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}