{
  "module_name": "khadas-mcu.c",
  "hash_id": "11cf77f27dec9b1fcfdf4bc610c9427f3570aad951a5f69e54a9ec6918c1f1d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/khadas-mcu.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/i2c.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/khadas-mcu.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\nstatic bool khadas_mcu_reg_volatile(struct device *dev, unsigned int reg)\n{\n\tif (reg >= KHADAS_MCU_USER_DATA_0_REG &&\n\t    reg < KHADAS_MCU_PWR_OFF_CMD_REG)\n\t\treturn true;\n\n\tswitch (reg) {\n\tcase KHADAS_MCU_PWR_OFF_CMD_REG:\n\tcase KHADAS_MCU_PASSWD_START_REG:\n\tcase KHADAS_MCU_CHECK_VEN_PASSWD_REG:\n\tcase KHADAS_MCU_CHECK_USER_PASSWD_REG:\n\tcase KHADAS_MCU_WOL_INIT_START_REG:\n\tcase KHADAS_MCU_CMD_FAN_STATUS_CTRL_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool khadas_mcu_reg_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase KHADAS_MCU_PASSWD_VEN_0_REG:\n\tcase KHADAS_MCU_PASSWD_VEN_1_REG:\n\tcase KHADAS_MCU_PASSWD_VEN_2_REG:\n\tcase KHADAS_MCU_PASSWD_VEN_3_REG:\n\tcase KHADAS_MCU_PASSWD_VEN_4_REG:\n\tcase KHADAS_MCU_PASSWD_VEN_5_REG:\n\tcase KHADAS_MCU_MAC_0_REG:\n\tcase KHADAS_MCU_MAC_1_REG:\n\tcase KHADAS_MCU_MAC_2_REG:\n\tcase KHADAS_MCU_MAC_3_REG:\n\tcase KHADAS_MCU_MAC_4_REG:\n\tcase KHADAS_MCU_MAC_5_REG:\n\tcase KHADAS_MCU_USID_0_REG:\n\tcase KHADAS_MCU_USID_1_REG:\n\tcase KHADAS_MCU_USID_2_REG:\n\tcase KHADAS_MCU_USID_3_REG:\n\tcase KHADAS_MCU_USID_4_REG:\n\tcase KHADAS_MCU_USID_5_REG:\n\tcase KHADAS_MCU_VERSION_0_REG:\n\tcase KHADAS_MCU_VERSION_1_REG:\n\tcase KHADAS_MCU_DEVICE_NO_0_REG:\n\tcase KHADAS_MCU_DEVICE_NO_1_REG:\n\tcase KHADAS_MCU_FACTORY_TEST_REG:\n\tcase KHADAS_MCU_SHUTDOWN_NORMAL_STATUS_REG:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct regmap_config khadas_mcu_regmap_config = {\n\t.reg_bits\t= 8,\n\t.reg_stride\t= 1,\n\t.val_bits\t= 8,\n\t.max_register\t= KHADAS_MCU_CMD_FAN_STATUS_CTRL_REG,\n\t.volatile_reg\t= khadas_mcu_reg_volatile,\n\t.writeable_reg\t= khadas_mcu_reg_writeable,\n\t.cache_type\t= REGCACHE_RBTREE,\n};\n\nstatic struct mfd_cell khadas_mcu_fan_cells[] = {\n\t \n\t{ .name = \"khadas-mcu-fan-ctrl\", },\n};\n\nstatic struct mfd_cell khadas_mcu_cells[] = {\n\t{ .name = \"khadas-mcu-user-mem\", },\n};\n\nstatic int khadas_mcu_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct khadas_mcu *ddata;\n\tint ret;\n\n\tddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, ddata);\n\n\tddata->dev = dev;\n\n\tddata->regmap = devm_regmap_init_i2c(client, &khadas_mcu_regmap_config);\n\tif (IS_ERR(ddata->regmap)) {\n\t\tret = PTR_ERR(ddata->regmap);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,\n\t\t\t\t   khadas_mcu_cells,\n\t\t\t\t   ARRAY_SIZE(khadas_mcu_cells),\n\t\t\t\t   NULL, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_property_present(dev->of_node, \"#cooling-cells\"))\n\t\treturn devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,\n\t\t\t\t\t    khadas_mcu_fan_cells,\n\t\t\t\t\t    ARRAY_SIZE(khadas_mcu_fan_cells),\n\t\t\t\t\t    NULL, 0, NULL);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id khadas_mcu_of_match[] = {\n\t{ .compatible = \"khadas,mcu\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, khadas_mcu_of_match);\n#endif\n\nstatic struct i2c_driver khadas_mcu_driver = {\n\t.driver = {\n\t\t.name = \"khadas-mcu-core\",\n\t\t.of_match_table = of_match_ptr(khadas_mcu_of_match),\n\t},\n\t.probe = khadas_mcu_probe,\n};\nmodule_i2c_driver(khadas_mcu_driver);\n\nMODULE_DESCRIPTION(\"Khadas MCU core driver\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}