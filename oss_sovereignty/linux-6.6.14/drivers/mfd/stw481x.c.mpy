{
  "module_name": "stw481x.c",
  "hash_id": "bc7d02badba57c78b706b7dd5ce7a7b03d79b47b64d0eff362e67b6d25170801",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/stw481x.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/stw481x.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n \n\n \n#define STW_PC_VCORE_SEL\t0x05U\n#define STW_PC_VAUX_SEL\t\t0x06U\n#define STW_PC_VPLL_SEL\t\t0x07U\n\n \nstatic int stw481x_get_pctl_reg(struct stw481x *stw481x, u8 reg)\n{\n\tu8 msb = (reg >> 3) & 0x03;\n\tu8 lsb = (reg << 5) & 0xe0;\n\tunsigned int val;\n\tu8 vrfy;\n\tint ret;\n\n\tret = regmap_write(stw481x->map, STW_PCTL_REG_HI, msb);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(stw481x->map, STW_PCTL_REG_LO, lsb);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_read(stw481x->map, STW_PCTL_REG_HI, &val);\n\tif (ret)\n\t\treturn ret;\n\tvrfy = (val & 0x03) << 3;\n\tret = regmap_read(stw481x->map, STW_PCTL_REG_LO, &val);\n\tif (ret)\n\t\treturn ret;\n\tvrfy |= ((val >> 5) & 0x07);\n\tif (vrfy != reg)\n\t\treturn -EIO;\n\treturn (val >> 1) & 0x0f;\n}\n\nstatic int stw481x_startup(struct stw481x *stw481x)\n{\n\t \n\tstatic const u8 vcore_val[] = {\n\t\t100, 105, 110, 115, 120, 122, 124, 126, 128,\n\t\t130, 132, 134, 136, 138, 140, 145\n\t};\n\tstatic const u8 vpll_val[] = { 105, 120, 130, 180 };\n\tstatic const u8 vaux_val[] = { 15, 18, 25, 28 };\n\tu8 vcore;\n\tu8 vcore_slp;\n\tu8 vpll;\n\tu8 vaux;\n\tbool vaux_en;\n\tbool it_warn;\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(stw481x->map, STW_CONF1, &val);\n\tif (ret)\n\t\treturn ret;\n\tvaux_en = !!(val & STW_CONF1_PDN_VAUX);\n\tit_warn = !!(val & STW_CONF1_IT_WARN);\n\n\tdev_info(&stw481x->client->dev, \"voltages %s\\n\",\n\t\t(val & STW_CONF1_V_MONITORING) ? \"OK\" : \"LOW\");\n\tdev_info(&stw481x->client->dev, \"MMC level shifter %s\\n\",\n\t\t(val & STW_CONF1_MMC_LS_STATUS) ? \"high impedance\" : \"ON\");\n\tdev_info(&stw481x->client->dev, \"VMMC: %s\\n\",\n\t\t(val & STW_CONF1_PDN_VMMC) ? \"ON\" : \"disabled\");\n\n\tdev_info(&stw481x->client->dev, \"STw481x power control registers:\\n\");\n\n\tret = stw481x_get_pctl_reg(stw481x, STW_PC_VCORE_SEL);\n\tif (ret < 0)\n\t\treturn ret;\n\tvcore = ret & 0x0f;\n\n\tret = stw481x_get_pctl_reg(stw481x, STW_PC_VAUX_SEL);\n\tif (ret < 0)\n\t\treturn ret;\n\tvaux = (ret >> 2) & 3;\n\tvpll = (ret >> 4) & 1;  \n\n\tret = stw481x_get_pctl_reg(stw481x, STW_PC_VPLL_SEL);\n\tif (ret < 0)\n\t\treturn ret;\n\tvpll |= (ret >> 1) & 2;\n\n\tdev_info(&stw481x->client->dev, \"VCORE: %u.%uV %s\\n\",\n\t\tvcore_val[vcore] / 100, vcore_val[vcore] % 100,\n\t\t(ret & 4) ? \"ON\" : \"OFF\");\n\n\tdev_info(&stw481x->client->dev, \"VPLL:  %u.%uV %s\\n\",\n\t\tvpll_val[vpll] / 100, vpll_val[vpll] % 100,\n\t\t(ret & 0x10) ? \"ON\" : \"OFF\");\n\n\tdev_info(&stw481x->client->dev, \"VAUX:  %u.%uV %s\\n\",\n\t\tvaux_val[vaux] / 10, vaux_val[vaux] % 10,\n\t\tvaux_en ? \"ON\" : \"OFF\");\n\n\tret = regmap_read(stw481x->map, STW_CONF2, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(&stw481x->client->dev, \"TWARN: %s threshold, %s\\n\",\n\t\tit_warn ? \"below\" : \"above\",\n\t\t(val & STW_CONF2_MASK_TWARN) ?\n\t\t \"enabled\" : \"mask through VDDOK\");\n\tdev_info(&stw481x->client->dev, \"VMMC: %s\\n\",\n\t\t(val & STW_CONF2_VMMC_EXT) ? \"internal\" : \"external\");\n\tdev_info(&stw481x->client->dev, \"IT WAKE UP: %s\\n\",\n\t\t(val & STW_CONF2_MASK_IT_WAKE_UP) ? \"enabled\" : \"masked\");\n\tdev_info(&stw481x->client->dev, \"GPO1: %s\\n\",\n\t\t(val & STW_CONF2_GPO1) ? \"low\" : \"high impedance\");\n\tdev_info(&stw481x->client->dev, \"GPO2: %s\\n\",\n\t\t(val & STW_CONF2_GPO2) ? \"low\" : \"high impedance\");\n\n\tret = regmap_read(stw481x->map, STW_VCORE_SLEEP, &val);\n\tif (ret)\n\t\treturn ret;\n\tvcore_slp = val & 0x0f;\n\tdev_info(&stw481x->client->dev, \"VCORE SLEEP: %u.%uV\\n\",\n\t\tvcore_val[vcore_slp] / 100, vcore_val[vcore_slp] % 100);\n\n\treturn 0;\n}\n\n \nstatic struct mfd_cell stw481x_cells[] = {\n\t{\n\t\t.of_compatible = \"st,stw481x-vmmc\",\n\t\t.name = \"stw481x-vmmc-regulator\",\n\t\t.id = -1,\n\t},\n};\n\nstatic const struct regmap_config stw481x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int stw481x_probe(struct i2c_client *client)\n{\n\tstruct stw481x\t\t\t*stw481x;\n\tint ret;\n\tint i;\n\n\tstw481x = devm_kzalloc(&client->dev, sizeof(*stw481x), GFP_KERNEL);\n\tif (!stw481x)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, stw481x);\n\tstw481x->client = client;\n\tstw481x->map = devm_regmap_init_i2c(client, &stw481x_regmap_config);\n\tif (IS_ERR(stw481x->map)) {\n\t\tret = PTR_ERR(stw481x->map);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = stw481x_startup(stw481x);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"chip initialization failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(stw481x_cells); i++) {\n\t\t \n\t\tstw481x_cells[i].platform_data = stw481x;\n\t\tstw481x_cells[i].pdata_size = sizeof(*stw481x);\n\t}\n\n\tret = devm_mfd_add_devices(&client->dev, 0, stw481x_cells,\n\t\t\t\t   ARRAY_SIZE(stw481x_cells), NULL, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(&client->dev, \"initialized STw481x device\\n\");\n\n\treturn ret;\n}\n\n \nstatic const struct i2c_device_id stw481x_id[] = {\n\t{ \"stw481x\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, stw481x_id);\n\nstatic const struct of_device_id stw481x_match[] = {\n\t{ .compatible = \"st,stw4810\", },\n\t{ .compatible = \"st,stw4811\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, stw481x_match);\n\nstatic struct i2c_driver stw481x_driver = {\n\t.driver = {\n\t\t.name\t= \"stw481x\",\n\t\t.of_match_table = stw481x_match,\n\t},\n\t.probe\t\t= stw481x_probe,\n\t.id_table\t= stw481x_id,\n};\n\nmodule_i2c_driver(stw481x_driver);\n\nMODULE_AUTHOR(\"Linus Walleij\");\nMODULE_DESCRIPTION(\"STw481x PMIC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}