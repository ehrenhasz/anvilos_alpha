{
  "module_name": "si476x-i2c.c",
  "hash_id": "51a1000e80a34312c55b125294f6d47bdbd000e7da34216f9541395f3462eb73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/si476x-i2c.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/regulator/consumer.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n\n#include <linux/mfd/si476x-core.h>\n\n#define SI476X_MAX_IO_ERRORS\t\t10\n#define SI476X_DRIVER_RDS_FIFO_DEPTH\t128\n\n \nstatic int si476x_core_config_pinmux(struct si476x_core *core)\n{\n\tint err;\n\tdev_dbg(&core->client->dev, \"Configuring pinmux\\n\");\n\terr = si476x_core_cmd_dig_audio_pin_cfg(core,\n\t\t\t\t\t\tcore->pinmux.dclk,\n\t\t\t\t\t\tcore->pinmux.dfs,\n\t\t\t\t\t\tcore->pinmux.dout,\n\t\t\t\t\t\tcore->pinmux.xout);\n\tif (err < 0) {\n\t\tdev_err(&core->client->dev,\n\t\t\t\"Failed to configure digital audio pins(err = %d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\terr = si476x_core_cmd_zif_pin_cfg(core,\n\t\t\t\t\t  core->pinmux.iqclk,\n\t\t\t\t\t  core->pinmux.iqfs,\n\t\t\t\t\t  core->pinmux.iout,\n\t\t\t\t\t  core->pinmux.qout);\n\tif (err < 0) {\n\t\tdev_err(&core->client->dev,\n\t\t\t\"Failed to configure ZIF pins(err = %d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\terr = si476x_core_cmd_ic_link_gpo_ctl_pin_cfg(core,\n\t\t\t\t\t\t      core->pinmux.icin,\n\t\t\t\t\t\t      core->pinmux.icip,\n\t\t\t\t\t\t      core->pinmux.icon,\n\t\t\t\t\t\t      core->pinmux.icop);\n\tif (err < 0) {\n\t\tdev_err(&core->client->dev,\n\t\t\t\"Failed to configure IC-Link/GPO pins(err = %d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\terr = si476x_core_cmd_ana_audio_pin_cfg(core,\n\t\t\t\t\t\tcore->pinmux.lrout);\n\tif (err < 0) {\n\t\tdev_err(&core->client->dev,\n\t\t\t\"Failed to configure analog audio pins(err = %d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\terr = si476x_core_cmd_intb_pin_cfg(core,\n\t\t\t\t\t   core->pinmux.intb,\n\t\t\t\t\t   core->pinmux.a1);\n\tif (err < 0) {\n\t\tdev_err(&core->client->dev,\n\t\t\t\"Failed to configure interrupt pins(err = %d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void si476x_core_schedule_polling_work(struct si476x_core *core)\n{\n\tschedule_delayed_work(&core->status_monitor,\n\t\t\t      usecs_to_jiffies(SI476X_STATUS_POLL_US));\n}\n\n \nint si476x_core_start(struct si476x_core *core, bool soft)\n{\n\tstruct i2c_client *client = core->client;\n\tint err;\n\n\tif (!soft) {\n\t\tif (gpio_is_valid(core->gpio_reset))\n\t\t\tgpio_set_value_cansleep(core->gpio_reset, 1);\n\n\t\tif (client->irq)\n\t\t\tenable_irq(client->irq);\n\n\t\tudelay(100);\n\n\t\tif (!client->irq) {\n\t\t\tatomic_set(&core->is_alive, 1);\n\t\t\tsi476x_core_schedule_polling_work(core);\n\t\t}\n\t} else {\n\t\tif (client->irq)\n\t\t\tenable_irq(client->irq);\n\t\telse {\n\t\t\tatomic_set(&core->is_alive, 1);\n\t\t\tsi476x_core_schedule_polling_work(core);\n\t\t}\n\t}\n\n\terr = si476x_core_cmd_power_up(core,\n\t\t\t\t       &core->power_up_parameters);\n\n\tif (err < 0) {\n\t\tdev_err(&core->client->dev,\n\t\t\t\"Power up failure(err = %d)\\n\",\n\t\t\terr);\n\t\tgoto disable_irq;\n\t}\n\n\tif (client->irq)\n\t\tatomic_set(&core->is_alive, 1);\n\n\terr = si476x_core_config_pinmux(core);\n\tif (err < 0) {\n\t\tdev_err(&core->client->dev,\n\t\t\t\"Failed to configure pinmux(err = %d)\\n\",\n\t\t\terr);\n\t\tgoto disable_irq;\n\t}\n\n\tif (client->irq) {\n\t\terr = regmap_write(core->regmap,\n\t\t\t\t   SI476X_PROP_INT_CTL_ENABLE,\n\t\t\t\t   SI476X_RDSIEN |\n\t\t\t\t   SI476X_STCIEN |\n\t\t\t\t   SI476X_CTSIEN);\n\t\tif (err < 0) {\n\t\t\tdev_err(&core->client->dev,\n\t\t\t\t\"Failed to configure interrupt sources\"\n\t\t\t\t\"(err = %d)\\n\", err);\n\t\t\tgoto disable_irq;\n\t\t}\n\t}\n\n\treturn 0;\n\ndisable_irq:\n\tif (err == -ENODEV)\n\t\tatomic_set(&core->is_alive, 0);\n\n\tif (client->irq)\n\t\tdisable_irq(client->irq);\n\telse\n\t\tcancel_delayed_work_sync(&core->status_monitor);\n\n\tif (gpio_is_valid(core->gpio_reset))\n\t\tgpio_set_value_cansleep(core->gpio_reset, 0);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(si476x_core_start);\n\n \nint si476x_core_stop(struct si476x_core *core, bool soft)\n{\n\tint err = 0;\n\tatomic_set(&core->is_alive, 0);\n\n\tif (soft) {\n\t\t \n\t\tstruct si476x_power_down_args args = {\n\t\t\t.xosc = false,\n\t\t};\n\t\terr = si476x_core_cmd_power_down(core, &args);\n\t}\n\n\t \n\tif (core->client->irq)\n\t\tdisable_irq(core->client->irq);\n\telse\n\t\tcancel_delayed_work_sync(&core->status_monitor);\n\n\tif (!soft) {\n\t\tif (gpio_is_valid(core->gpio_reset))\n\t\t\tgpio_set_value_cansleep(core->gpio_reset, 0);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(si476x_core_stop);\n\n \nint si476x_core_set_power_state(struct si476x_core *core,\n\t\t\t\tenum si476x_power_state next_state)\n{\n\t \n\tint err = 0;\n\n\tif (core->power_state == SI476X_POWER_INCONSISTENT) {\n\t\tdev_err(&core->client->dev,\n\t\t\t\"The device in inconsistent power state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (next_state != core->power_state) {\n\t\tswitch (next_state) {\n\t\tcase SI476X_POWER_UP_FULL:\n\t\t\terr = regulator_bulk_enable(ARRAY_SIZE(core->supplies),\n\t\t\t\t\t\t    core->supplies);\n\t\t\tif (err < 0) {\n\t\t\t\tcore->power_state = SI476X_POWER_INCONSISTENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tudelay(100);\n\n\t\t\terr = si476x_core_start(core, false);\n\t\t\tif (err < 0)\n\t\t\t\tgoto disable_regulators;\n\n\t\t\tcore->power_state = next_state;\n\t\t\tbreak;\n\n\t\tcase SI476X_POWER_DOWN:\n\t\t\tcore->power_state = next_state;\n\t\t\terr = si476x_core_stop(core, false);\n\t\t\tif (err < 0)\n\t\t\t\tcore->power_state = SI476X_POWER_INCONSISTENT;\ndisable_regulators:\n\t\t\terr = regulator_bulk_disable(ARRAY_SIZE(core->supplies),\n\t\t\t\t\t\t     core->supplies);\n\t\t\tif (err < 0)\n\t\t\t\tcore->power_state = SI476X_POWER_INCONSISTENT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(si476x_core_set_power_state);\n\n \nstatic inline void si476x_core_report_drainer_stop(struct si476x_core *core)\n{\n\tmutex_lock(&core->rds_drainer_status_lock);\n\tcore->rds_drainer_is_working = false;\n\tmutex_unlock(&core->rds_drainer_status_lock);\n}\n\n \nstatic inline void si476x_core_start_rds_drainer_once(struct si476x_core *core)\n{\n\tmutex_lock(&core->rds_drainer_status_lock);\n\tif (!core->rds_drainer_is_working) {\n\t\tcore->rds_drainer_is_working = true;\n\t\tschedule_work(&core->rds_fifo_drainer);\n\t}\n\tmutex_unlock(&core->rds_drainer_status_lock);\n}\n \nstatic void si476x_core_drain_rds_fifo(struct work_struct *work)\n{\n\tint err;\n\n\tstruct si476x_core *core = container_of(work, struct si476x_core,\n\t\t\t\t\t\trds_fifo_drainer);\n\n\tstruct si476x_rds_status_report report;\n\n\tsi476x_core_lock(core);\n\terr = si476x_core_cmd_fm_rds_status(core, true, false, false, &report);\n\tif (!err) {\n\t\tint i = report.rdsfifoused;\n\t\tdev_dbg(&core->client->dev,\n\t\t\t\"%d elements in RDS FIFO. Draining.\\n\", i);\n\t\tfor (; i > 0; --i) {\n\t\t\terr = si476x_core_cmd_fm_rds_status(core, false, false,\n\t\t\t\t\t\t\t    (i == 1), &report);\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\n\t\t\tkfifo_in(&core->rds_fifo, report.rds,\n\t\t\t\t sizeof(report.rds));\n\t\t\tdev_dbg(&core->client->dev, \"RDS data:\\n %*ph\\n\",\n\t\t\t\t(int)sizeof(report.rds), report.rds);\n\t\t}\n\t\tdev_dbg(&core->client->dev, \"Drrrrained!\\n\");\n\t\twake_up_interruptible(&core->rds_read_queue);\n\t}\n\nunlock:\n\tsi476x_core_unlock(core);\n\tsi476x_core_report_drainer_stop(core);\n}\n\n \nstatic void si476x_core_pronounce_dead(struct si476x_core *core)\n{\n\tdev_info(&core->client->dev, \"Core device is dead.\\n\");\n\n\tatomic_set(&core->is_alive, 0);\n\n\t \n\twake_up_interruptible(&core->rds_read_queue);\n\n\tatomic_set(&core->cts, 1);\n\twake_up(&core->command);\n\n\tatomic_set(&core->stc, 1);\n\twake_up(&core->tuning);\n}\n\n \nint si476x_core_i2c_xfer(struct si476x_core *core,\n\t\t    enum si476x_i2c_type type,\n\t\t    char *buf, int count)\n{\n\tstatic int io_errors_count;\n\tint err;\n\tif (type == SI476X_I2C_SEND)\n\t\terr = i2c_master_send(core->client, buf, count);\n\telse\n\t\terr = i2c_master_recv(core->client, buf, count);\n\n\tif (err < 0) {\n\t\tif (io_errors_count++ > SI476X_MAX_IO_ERRORS)\n\t\t\tsi476x_core_pronounce_dead(core);\n\t} else {\n\t\tio_errors_count = 0;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(si476x_core_i2c_xfer);\n\n \nstatic int si476x_core_get_status(struct si476x_core *core)\n{\n\tu8 response;\n\tint err = si476x_core_i2c_xfer(core, SI476X_I2C_RECV,\n\t\t\t\t  &response, sizeof(response));\n\n\treturn (err < 0) ? err : response;\n}\n\n \nstatic void si476x_core_get_and_signal_status(struct si476x_core *core)\n{\n\tint status = si476x_core_get_status(core);\n\tif (status < 0) {\n\t\tdev_err(&core->client->dev, \"Failed to get status\\n\");\n\t\treturn;\n\t}\n\n\tif (status & SI476X_CTS) {\n\t\t \n\t\tdev_dbg(&core->client->dev, \"[interrupt] CTSINT\\n\");\n\t\tatomic_set(&core->cts, 1);\n\t\twake_up(&core->command);\n\t}\n\n\tif (status & SI476X_FM_RDS_INT) {\n\t\tdev_dbg(&core->client->dev, \"[interrupt] RDSINT\\n\");\n\t\tsi476x_core_start_rds_drainer_once(core);\n\t}\n\n\tif (status & SI476X_STC_INT) {\n\t\tdev_dbg(&core->client->dev, \"[interrupt] STCINT\\n\");\n\t\tatomic_set(&core->stc, 1);\n\t\twake_up(&core->tuning);\n\t}\n}\n\nstatic void si476x_core_poll_loop(struct work_struct *work)\n{\n\tstruct si476x_core *core = SI476X_WORK_TO_CORE(work);\n\n\tsi476x_core_get_and_signal_status(core);\n\n\tif (atomic_read(&core->is_alive))\n\t\tsi476x_core_schedule_polling_work(core);\n}\n\nstatic irqreturn_t si476x_core_interrupt(int irq, void *dev)\n{\n\tstruct si476x_core *core = dev;\n\n\tsi476x_core_get_and_signal_status(core);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int si476x_core_fwver_to_revision(struct si476x_core *core,\n\t\t\t\t\t int func, int major,\n\t\t\t\t\t int minor1, int minor2)\n{\n\tswitch (func) {\n\tcase SI476X_FUNC_FM_RECEIVER:\n\t\tswitch (major) {\n\t\tcase 5:\n\t\t\treturn SI476X_REVISION_A10;\n\t\tcase 8:\n\t\t\treturn SI476X_REVISION_A20;\n\t\tcase 10:\n\t\t\treturn SI476X_REVISION_A30;\n\t\tdefault:\n\t\t\tgoto unknown_revision;\n\t\t}\n\tcase SI476X_FUNC_AM_RECEIVER:\n\t\tswitch (major) {\n\t\tcase 5:\n\t\t\treturn SI476X_REVISION_A10;\n\t\tcase 7:\n\t\t\treturn SI476X_REVISION_A20;\n\t\tcase 9:\n\t\t\treturn SI476X_REVISION_A30;\n\t\tdefault:\n\t\t\tgoto unknown_revision;\n\t\t}\n\tcase SI476X_FUNC_WB_RECEIVER:\n\t\tswitch (major) {\n\t\tcase 3:\n\t\t\treturn SI476X_REVISION_A10;\n\t\tcase 5:\n\t\t\treturn SI476X_REVISION_A20;\n\t\tcase 7:\n\t\t\treturn SI476X_REVISION_A30;\n\t\tdefault:\n\t\t\tgoto unknown_revision;\n\t\t}\n\tcase SI476X_FUNC_BOOTLOADER:\n\tdefault:\t\t \n\t\tBUG();\n\t\treturn -1;\n\t}\n\nunknown_revision:\n\tdev_err(&core->client->dev,\n\t\t\"Unsupported version of the firmware: %d.%d.%d, \"\n\t\t\"reverting to A10 compatible functions\\n\",\n\t\tmajor, minor1, minor2);\n\n\treturn SI476X_REVISION_A10;\n}\n\n \nstatic int si476x_core_get_revision_info(struct si476x_core *core)\n{\n\tint rval;\n\tstruct si476x_func_info info;\n\n\tsi476x_core_lock(core);\n\trval = si476x_core_set_power_state(core, SI476X_POWER_UP_FULL);\n\tif (rval < 0)\n\t\tgoto exit;\n\n\trval = si476x_core_cmd_func_info(core, &info);\n\tif (rval < 0)\n\t\tgoto power_down;\n\n\tcore->revision = si476x_core_fwver_to_revision(core, info.func,\n\t\t\t\t\t\t       info.firmware.major,\n\t\t\t\t\t\t       info.firmware.minor[0],\n\t\t\t\t\t\t       info.firmware.minor[1]);\npower_down:\n\tsi476x_core_set_power_state(core, SI476X_POWER_DOWN);\nexit:\n\tsi476x_core_unlock(core);\n\n\treturn rval;\n}\n\nbool si476x_core_has_am(struct si476x_core *core)\n{\n\treturn core->chip_id == SI476X_CHIP_SI4761 ||\n\t\tcore->chip_id == SI476X_CHIP_SI4764;\n}\nEXPORT_SYMBOL_GPL(si476x_core_has_am);\n\nbool si476x_core_has_diversity(struct si476x_core *core)\n{\n\treturn core->chip_id == SI476X_CHIP_SI4764;\n}\nEXPORT_SYMBOL_GPL(si476x_core_has_diversity);\n\nbool si476x_core_is_a_secondary_tuner(struct si476x_core *core)\n{\n\treturn si476x_core_has_diversity(core) &&\n\t\t(core->diversity_mode == SI476X_PHDIV_SECONDARY_ANTENNA ||\n\t\t core->diversity_mode == SI476X_PHDIV_SECONDARY_COMBINING);\n}\nEXPORT_SYMBOL_GPL(si476x_core_is_a_secondary_tuner);\n\nbool si476x_core_is_a_primary_tuner(struct si476x_core *core)\n{\n\treturn si476x_core_has_diversity(core) &&\n\t\t(core->diversity_mode == SI476X_PHDIV_PRIMARY_ANTENNA ||\n\t\t core->diversity_mode == SI476X_PHDIV_PRIMARY_COMBINING);\n}\nEXPORT_SYMBOL_GPL(si476x_core_is_a_primary_tuner);\n\nbool si476x_core_is_in_am_receiver_mode(struct si476x_core *core)\n{\n\treturn si476x_core_has_am(core) &&\n\t\t(core->power_up_parameters.func == SI476X_FUNC_AM_RECEIVER);\n}\nEXPORT_SYMBOL_GPL(si476x_core_is_in_am_receiver_mode);\n\nbool si476x_core_is_powered_up(struct si476x_core *core)\n{\n\treturn core->power_state == SI476X_POWER_UP_FULL;\n}\nEXPORT_SYMBOL_GPL(si476x_core_is_powered_up);\n\nstatic int si476x_core_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tint rval;\n\tstruct si476x_core          *core;\n\tstruct si476x_platform_data *pdata;\n\tstruct mfd_cell *cell;\n\tint              cell_num;\n\n\tcore = devm_kzalloc(&client->dev, sizeof(*core), GFP_KERNEL);\n\tif (!core)\n\t\treturn -ENOMEM;\n\n\tcore->client = client;\n\n\tcore->regmap = devm_regmap_init_si476x(core);\n\tif (IS_ERR(core->regmap)) {\n\t\trval = PTR_ERR(core->regmap);\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to allocate register map: %d\\n\",\n\t\t\trval);\n\t\treturn rval;\n\t}\n\n\ti2c_set_clientdata(client, core);\n\n\tatomic_set(&core->is_alive, 0);\n\tcore->power_state = SI476X_POWER_DOWN;\n\n\tpdata = dev_get_platdata(&client->dev);\n\tif (pdata) {\n\t\tmemcpy(&core->power_up_parameters,\n\t\t       &pdata->power_up_parameters,\n\t\t       sizeof(core->power_up_parameters));\n\n\t\tcore->gpio_reset = -1;\n\t\tif (gpio_is_valid(pdata->gpio_reset)) {\n\t\t\trval = gpio_request(pdata->gpio_reset, \"si476x reset\");\n\t\t\tif (rval) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Failed to request gpio: %d\\n\", rval);\n\t\t\t\treturn rval;\n\t\t\t}\n\t\t\tcore->gpio_reset = pdata->gpio_reset;\n\t\t\tgpio_direction_output(core->gpio_reset, 0);\n\t\t}\n\n\t\tcore->diversity_mode = pdata->diversity_mode;\n\t\tmemcpy(&core->pinmux, &pdata->pinmux,\n\t\t       sizeof(struct si476x_pinmux));\n\t} else {\n\t\tdev_err(&client->dev, \"No platform data provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcore->supplies[0].supply = \"vd\";\n\tcore->supplies[1].supply = \"va\";\n\tcore->supplies[2].supply = \"vio1\";\n\tcore->supplies[3].supply = \"vio2\";\n\n\trval = devm_regulator_bulk_get(&client->dev,\n\t\t\t\t       ARRAY_SIZE(core->supplies),\n\t\t\t\t       core->supplies);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"Failed to get all of the regulators\\n\");\n\t\tgoto free_gpio;\n\t}\n\n\tmutex_init(&core->cmd_lock);\n\tinit_waitqueue_head(&core->command);\n\tinit_waitqueue_head(&core->tuning);\n\n\trval = kfifo_alloc(&core->rds_fifo,\n\t\t\t   SI476X_DRIVER_RDS_FIFO_DEPTH *\n\t\t\t   sizeof(struct v4l2_rds_data),\n\t\t\t   GFP_KERNEL);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"Could not allocate the FIFO\\n\");\n\t\tgoto free_gpio;\n\t}\n\tmutex_init(&core->rds_drainer_status_lock);\n\tinit_waitqueue_head(&core->rds_read_queue);\n\tINIT_WORK(&core->rds_fifo_drainer, si476x_core_drain_rds_fifo);\n\n\tif (client->irq) {\n\t\trval = devm_request_threaded_irq(&client->dev,\n\t\t\t\t\t\t client->irq, NULL,\n\t\t\t\t\t\t si476x_core_interrupt,\n\t\t\t\t\t\t IRQF_TRIGGER_FALLING |\n\t\t\t\t\t\t IRQF_ONESHOT,\n\t\t\t\t\t\t client->name, core);\n\t\tif (rval < 0) {\n\t\t\tdev_err(&client->dev, \"Could not request IRQ %d\\n\",\n\t\t\t\tclient->irq);\n\t\t\tgoto free_kfifo;\n\t\t}\n\t\tdisable_irq(client->irq);\n\t\tdev_dbg(&client->dev, \"IRQ requested.\\n\");\n\n\t\tcore->rds_fifo_depth = 20;\n\t} else {\n\t\tINIT_DELAYED_WORK(&core->status_monitor,\n\t\t\t\t  si476x_core_poll_loop);\n\t\tdev_info(&client->dev,\n\t\t\t \"No IRQ number specified, will use polling\\n\");\n\n\t\tcore->rds_fifo_depth = 5;\n\t}\n\n\tcore->chip_id = id->driver_data;\n\n\trval = si476x_core_get_revision_info(core);\n\tif (rval < 0) {\n\t\trval = -ENODEV;\n\t\tgoto free_kfifo;\n\t}\n\n\tcell_num = 0;\n\n\tcell = &core->cells[SI476X_RADIO_CELL];\n\tcell->name = \"si476x-radio\";\n\tcell_num++;\n\n#ifdef CONFIG_SND_SOC_SI476X\n\tif ((core->chip_id == SI476X_CHIP_SI4761 ||\n\t     core->chip_id == SI476X_CHIP_SI4764)\t&&\n\t    core->pinmux.dclk == SI476X_DCLK_DAUDIO     &&\n\t    core->pinmux.dfs  == SI476X_DFS_DAUDIO      &&\n\t    core->pinmux.dout == SI476X_DOUT_I2S_OUTPUT &&\n\t    core->pinmux.xout == SI476X_XOUT_TRISTATE) {\n\t\tcell = &core->cells[SI476X_CODEC_CELL];\n\t\tcell->name          = \"si476x-codec\";\n\t\tcell_num++;\n\t}\n#endif\n\trval = mfd_add_devices(&client->dev,\n\t\t\t       (client->adapter->nr << 8) + client->addr,\n\t\t\t       core->cells, cell_num,\n\t\t\t       NULL, 0, NULL);\n\tif (!rval)\n\t\treturn 0;\n\nfree_kfifo:\n\tkfifo_free(&core->rds_fifo);\n\nfree_gpio:\n\tif (gpio_is_valid(core->gpio_reset))\n\t\tgpio_free(core->gpio_reset);\n\n\treturn rval;\n}\n\nstatic void si476x_core_remove(struct i2c_client *client)\n{\n\tstruct si476x_core *core = i2c_get_clientdata(client);\n\n\tsi476x_core_pronounce_dead(core);\n\tmfd_remove_devices(&client->dev);\n\n\tif (client->irq)\n\t\tdisable_irq(client->irq);\n\telse\n\t\tcancel_delayed_work_sync(&core->status_monitor);\n\n\tkfifo_free(&core->rds_fifo);\n\n\tif (gpio_is_valid(core->gpio_reset))\n\t\tgpio_free(core->gpio_reset);\n}\n\n\nstatic const struct i2c_device_id si476x_id[] = {\n\t{ \"si4761\", SI476X_CHIP_SI4761 },\n\t{ \"si4764\", SI476X_CHIP_SI4764 },\n\t{ \"si4768\", SI476X_CHIP_SI4768 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, si476x_id);\n\nstatic struct i2c_driver si476x_core_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"si476x-core\",\n\t},\n\t.probe\t\t= si476x_core_probe,\n\t.remove         = si476x_core_remove,\n\t.id_table       = si476x_id,\n};\nmodule_i2c_driver(si476x_core_driver);\n\n\nMODULE_AUTHOR(\"Andrey Smirnov <andrew.smirnov@gmail.com>\");\nMODULE_DESCRIPTION(\"Si4761/64/68 AM/FM MFD core device driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}