{
  "module_name": "smpro-core.c",
  "hash_id": "9ec48941da05e80b73bdce2a89e65fac41222bf7602ba5363acb07f06f79ee5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/smpro-core.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n\n \n#define MANUFACTURER_ID_REG     0x02\n#define AMPERE_MANUFACTURER_ID  0xCD3A\n\n#define CORE_CE_ERR_DATA        0x82\n#define CORE_UE_ERR_DATA        0x85\n#define MEM_CE_ERR_DATA         0x92\n#define MEM_UE_ERR_DATA         0x95\n#define PCIE_CE_ERR_DATA        0xC2\n#define PCIE_UE_ERR_DATA        0xC5\n#define OTHER_CE_ERR_DATA       0xD2\n#define OTHER_UE_ERR_DATA       0xDA\n\nstatic int smpro_core_write(void *context, const void *data, size_t count)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tint ret;\n\n\tret = i2c_master_send(i2c, data, count);\n\tif (unlikely(ret != count))\n\t\treturn (ret < 0) ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic int smpro_core_read(void *context, const void *reg, size_t reg_size,\n\t\t\t   void *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct i2c_msg xfer[2];\n\tunsigned char buf[2];\n\tint ret;\n\n\txfer[0].addr = i2c->addr;\n\txfer[0].flags = 0;\n\n\tbuf[0] = *(u8 *)reg;\n\tbuf[1] = val_size;\n\txfer[0].len = 2;\n\txfer[0].buf = buf;\n\n\txfer[1].addr = i2c->addr;\n\txfer[1].flags = I2C_M_RD;\n\txfer[1].len = val_size;\n\txfer[1].buf = val;\n\n\tret = i2c_transfer(i2c->adapter, xfer, 2);\n\tif (unlikely(ret != 2))\n\t\treturn (ret < 0) ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic const struct regmap_bus smpro_regmap_bus = {\n\t.read = smpro_core_read,\n\t.write = smpro_core_write,\n\t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n};\n\nstatic bool smpro_core_readable_noinc_reg(struct device *dev, unsigned int reg)\n{\n\treturn  (reg == CORE_CE_ERR_DATA || reg == CORE_UE_ERR_DATA ||\n\t\t reg == MEM_CE_ERR_DATA || reg == MEM_UE_ERR_DATA ||\n\t\t reg == PCIE_CE_ERR_DATA || reg == PCIE_UE_ERR_DATA ||\n\t\t reg == OTHER_CE_ERR_DATA || reg == OTHER_UE_ERR_DATA);\n}\n\nstatic const struct regmap_config smpro_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.readable_noinc_reg = smpro_core_readable_noinc_reg,\n};\n\nstatic const struct mfd_cell smpro_devs[] = {\n\tMFD_CELL_NAME(\"smpro-hwmon\"),\n\tMFD_CELL_NAME(\"smpro-errmon\"),\n\tMFD_CELL_NAME(\"smpro-misc\"),\n};\n\nstatic int smpro_core_probe(struct i2c_client *i2c)\n{\n\tconst struct regmap_config *config;\n\tstruct regmap *regmap;\n\tunsigned int val;\n\tint ret;\n\n\tconfig = device_get_match_data(&i2c->dev);\n\tif (!config)\n\t\treturn -EINVAL;\n\n\tregmap = devm_regmap_init(&i2c->dev, &smpro_regmap_bus, &i2c->dev, config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tret = regmap_read(regmap, MANUFACTURER_ID_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != AMPERE_MANUFACTURER_ID)\n\t\treturn -ENODEV;\n\n\treturn devm_mfd_add_devices(&i2c->dev, PLATFORM_DEVID_AUTO,\n\t\t\t\t    smpro_devs, ARRAY_SIZE(smpro_devs), NULL, 0, NULL);\n}\n\nstatic const struct of_device_id smpro_core_of_match[] = {\n\t{ .compatible = \"ampere,smpro\", .data = &smpro_regmap_config },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, smpro_core_of_match);\n\nstatic struct i2c_driver smpro_core_driver = {\n\t.probe = smpro_core_probe,\n\t.driver = {\n\t\t.name = \"smpro-core\",\n\t\t.of_match_table = smpro_core_of_match,\n\t},\n};\nmodule_i2c_driver(smpro_core_driver);\n\nMODULE_AUTHOR(\"Quan Nguyen <quan@os.amperecomputing.com>\");\nMODULE_DESCRIPTION(\"SMPRO CORE - I2C driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}