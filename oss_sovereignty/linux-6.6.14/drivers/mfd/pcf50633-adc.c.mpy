{
  "module_name": "pcf50633-adc.c",
  "hash_id": "be3b55968d81a1b83301b0e709a116ef8402b74d68cf9c9520b878384ac3a41d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/pcf50633-adc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/completion.h>\n\n#include <linux/mfd/pcf50633/core.h>\n#include <linux/mfd/pcf50633/adc.h>\n\nstruct pcf50633_adc_request {\n\tint mux;\n\tint avg;\n\tvoid (*callback)(struct pcf50633 *, void *, int);\n\tvoid *callback_param;\n};\n\nstruct pcf50633_adc_sync_request {\n\tint result;\n\tstruct completion completion;\n};\n\n#define PCF50633_MAX_ADC_FIFO_DEPTH 8\n\nstruct pcf50633_adc {\n\tstruct pcf50633 *pcf;\n\n\t \n\tstruct pcf50633_adc_request *queue[PCF50633_MAX_ADC_FIFO_DEPTH];\n\tint queue_head;\n\tint queue_tail;\n\tstruct mutex queue_mutex;\n};\n\nstatic inline struct pcf50633_adc *__to_adc(struct pcf50633 *pcf)\n{\n\treturn platform_get_drvdata(pcf->adc_pdev);\n}\n\nstatic void adc_setup(struct pcf50633 *pcf, int channel, int avg)\n{\n\tchannel &= PCF50633_ADCC1_ADCMUX_MASK;\n\n\t \n\tpcf50633_reg_write(pcf, PCF50633_REG_ADCC2, 0x00);\n\tpcf50633_reg_write(pcf, PCF50633_REG_ADCC3, 0x01);\n\n\t \n\tpcf50633_reg_write(pcf, PCF50633_REG_ADCC1, channel | avg |\n\t\t    PCF50633_ADCC1_ADCSTART | PCF50633_ADCC1_RES_10BIT);\n}\n\nstatic void trigger_next_adc_job_if_any(struct pcf50633 *pcf)\n{\n\tstruct pcf50633_adc *adc = __to_adc(pcf);\n\tint head;\n\n\thead = adc->queue_head;\n\n\tif (!adc->queue[head])\n\t\treturn;\n\n\tadc_setup(pcf, adc->queue[head]->mux, adc->queue[head]->avg);\n}\n\nstatic int\nadc_enqueue_request(struct pcf50633 *pcf, struct pcf50633_adc_request *req)\n{\n\tstruct pcf50633_adc *adc = __to_adc(pcf);\n\tint head, tail;\n\n\tmutex_lock(&adc->queue_mutex);\n\n\thead = adc->queue_head;\n\ttail = adc->queue_tail;\n\n\tif (adc->queue[tail]) {\n\t\tmutex_unlock(&adc->queue_mutex);\n\t\tdev_err(pcf->dev, \"ADC queue is full, dropping request\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tadc->queue[tail] = req;\n\tif (head == tail)\n\t\ttrigger_next_adc_job_if_any(pcf);\n\tadc->queue_tail = (tail + 1) & (PCF50633_MAX_ADC_FIFO_DEPTH - 1);\n\n\tmutex_unlock(&adc->queue_mutex);\n\n\treturn 0;\n}\n\nstatic void pcf50633_adc_sync_read_callback(struct pcf50633 *pcf, void *param,\n\tint result)\n{\n\tstruct pcf50633_adc_sync_request *req = param;\n\n\treq->result = result;\n\tcomplete(&req->completion);\n}\n\nint pcf50633_adc_sync_read(struct pcf50633 *pcf, int mux, int avg)\n{\n\tstruct pcf50633_adc_sync_request req;\n\tint ret;\n\n\tinit_completion(&req.completion);\n\n\tret = pcf50633_adc_async_read(pcf, mux, avg,\n\t\tpcf50633_adc_sync_read_callback, &req);\n\tif (ret)\n\t\treturn ret;\n\n\twait_for_completion(&req.completion);\n\n\treturn req.result;\n}\nEXPORT_SYMBOL_GPL(pcf50633_adc_sync_read);\n\nint pcf50633_adc_async_read(struct pcf50633 *pcf, int mux, int avg,\n\t\t\t     void (*callback)(struct pcf50633 *, void *, int),\n\t\t\t     void *callback_param)\n{\n\tstruct pcf50633_adc_request *req;\n\tint ret;\n\n\t \n\treq = kmalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->mux = mux;\n\treq->avg = avg;\n\treq->callback = callback;\n\treq->callback_param = callback_param;\n\n\tret = adc_enqueue_request(pcf, req);\n\tif (ret)\n\t\tkfree(req);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pcf50633_adc_async_read);\n\nstatic int adc_result(struct pcf50633 *pcf)\n{\n\tu8 adcs1, adcs3;\n\tu16 result;\n\n\tadcs1 = pcf50633_reg_read(pcf, PCF50633_REG_ADCS1);\n\tadcs3 = pcf50633_reg_read(pcf, PCF50633_REG_ADCS3);\n\tresult = (adcs1 << 2) | (adcs3 & PCF50633_ADCS3_ADCDAT1L_MASK);\n\n\tdev_dbg(pcf->dev, \"adc result = %d\\n\", result);\n\n\treturn result;\n}\n\nstatic void pcf50633_adc_irq(int irq, void *data)\n{\n\tstruct pcf50633_adc *adc = data;\n\tstruct pcf50633 *pcf = adc->pcf;\n\tstruct pcf50633_adc_request *req;\n\tint head, res;\n\n\tmutex_lock(&adc->queue_mutex);\n\thead = adc->queue_head;\n\n\treq = adc->queue[head];\n\tif (WARN_ON(!req)) {\n\t\tdev_err(pcf->dev, \"pcf50633-adc irq: ADC queue empty!\\n\");\n\t\tmutex_unlock(&adc->queue_mutex);\n\t\treturn;\n\t}\n\tadc->queue[head] = NULL;\n\tadc->queue_head = (head + 1) &\n\t\t\t\t      (PCF50633_MAX_ADC_FIFO_DEPTH - 1);\n\n\tres = adc_result(pcf);\n\ttrigger_next_adc_job_if_any(pcf);\n\n\tmutex_unlock(&adc->queue_mutex);\n\n\treq->callback(pcf, req->callback_param, res);\n\tkfree(req);\n}\n\nstatic int pcf50633_adc_probe(struct platform_device *pdev)\n{\n\tstruct pcf50633_adc *adc;\n\n\tadc = devm_kzalloc(&pdev->dev, sizeof(*adc), GFP_KERNEL);\n\tif (!adc)\n\t\treturn -ENOMEM;\n\n\tadc->pcf = dev_to_pcf50633(pdev->dev.parent);\n\tplatform_set_drvdata(pdev, adc);\n\n\tpcf50633_register_irq(adc->pcf, PCF50633_IRQ_ADCRDY,\n\t\t\t\t\tpcf50633_adc_irq, adc);\n\n\tmutex_init(&adc->queue_mutex);\n\n\treturn 0;\n}\n\nstatic int pcf50633_adc_remove(struct platform_device *pdev)\n{\n\tstruct pcf50633_adc *adc = platform_get_drvdata(pdev);\n\tint i, head;\n\n\tpcf50633_free_irq(adc->pcf, PCF50633_IRQ_ADCRDY);\n\n\tmutex_lock(&adc->queue_mutex);\n\thead = adc->queue_head;\n\n\tif (WARN_ON(adc->queue[head]))\n\t\tdev_err(adc->pcf->dev,\n\t\t\t\"adc driver removed with request pending\\n\");\n\n\tfor (i = 0; i < PCF50633_MAX_ADC_FIFO_DEPTH; i++)\n\t\tkfree(adc->queue[i]);\n\n\tmutex_unlock(&adc->queue_mutex);\n\n\treturn 0;\n}\n\nstatic struct platform_driver pcf50633_adc_driver = {\n\t.driver = {\n\t\t.name = \"pcf50633-adc\",\n\t},\n\t.probe = pcf50633_adc_probe,\n\t.remove = pcf50633_adc_remove,\n};\n\nmodule_platform_driver(pcf50633_adc_driver);\n\nMODULE_AUTHOR(\"Balaji Rao <balajirrao@openmoko.org>\");\nMODULE_DESCRIPTION(\"PCF50633 adc driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pcf50633-adc\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}