{
  "module_name": "max77693.c",
  "hash_id": "9240c480789921a5cc6f31935607711d0f9096c9c77a88bdc406b21d21cedec3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/max77693.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/mutex.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/max77693.h>\n#include <linux/mfd/max77693-common.h>\n#include <linux/mfd/max77693-private.h>\n#include <linux/regulator/machine.h>\n#include <linux/regmap.h>\n\n#define I2C_ADDR_PMIC\t(0xCC >> 1)\t \n#define I2C_ADDR_MUIC\t(0x4A >> 1)\n#define I2C_ADDR_HAPTIC\t(0x90 >> 1)\n\nstatic const struct mfd_cell max77693_devs[] = {\n\t{ .name = \"max77693-pmic\", },\n\t{\n\t\t.name = \"max77693-charger\",\n\t\t.of_compatible = \"maxim,max77693-charger\",\n\t},\n\t{\n\t\t.name = \"max77693-muic\",\n\t\t.of_compatible = \"maxim,max77693-muic\",\n\t},\n\t{\n\t\t.name = \"max77693-haptic\",\n\t\t.of_compatible = \"maxim,max77693-haptic\",\n\t},\n\t{\n\t\t.name = \"max77693-led\",\n\t\t.of_compatible = \"maxim,max77693-led\",\n\t},\n};\n\nstatic const struct regmap_config max77693_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MAX77693_PMIC_REG_END,\n};\n\nstatic const struct regmap_irq max77693_led_irqs[] = {\n\t{ .mask = LED_IRQ_FLED2_OPEN,  },\n\t{ .mask = LED_IRQ_FLED2_SHORT, },\n\t{ .mask = LED_IRQ_FLED1_OPEN,  },\n\t{ .mask = LED_IRQ_FLED1_SHORT, },\n\t{ .mask = LED_IRQ_MAX_FLASH,   },\n};\n\nstatic const struct regmap_irq_chip max77693_led_irq_chip = {\n\t.name\t\t\t= \"max77693-led\",\n\t.status_base\t\t= MAX77693_LED_REG_FLASH_INT,\n\t.mask_base\t\t= MAX77693_LED_REG_FLASH_INT_MASK,\n\t.num_regs\t\t= 1,\n\t.irqs\t\t\t= max77693_led_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(max77693_led_irqs),\n};\n\nstatic const struct regmap_irq max77693_topsys_irqs[] = {\n\t{ .mask = TOPSYS_IRQ_T120C_INT,  },\n\t{ .mask = TOPSYS_IRQ_T140C_INT,  },\n\t{ .mask = TOPSYS_IRQ_LOWSYS_INT, },\n};\n\nstatic const struct regmap_irq_chip max77693_topsys_irq_chip = {\n\t.name\t\t\t= \"max77693-topsys\",\n\t.status_base\t\t= MAX77693_PMIC_REG_TOPSYS_INT,\n\t.mask_base\t\t= MAX77693_PMIC_REG_TOPSYS_INT_MASK,\n\t.num_regs\t\t= 1,\n\t.irqs\t\t\t= max77693_topsys_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(max77693_topsys_irqs),\n};\n\nstatic const struct regmap_irq max77693_charger_irqs[] = {\n\t{ .mask = CHG_IRQ_BYP_I,   },\n\t{ .mask = CHG_IRQ_THM_I,   },\n\t{ .mask = CHG_IRQ_BAT_I,   },\n\t{ .mask = CHG_IRQ_CHG_I,   },\n\t{ .mask = CHG_IRQ_CHGIN_I, },\n};\n\nstatic const struct regmap_irq_chip max77693_charger_irq_chip = {\n\t.name\t\t\t= \"max77693-charger\",\n\t.status_base\t\t= MAX77693_CHG_REG_CHG_INT,\n\t.mask_base\t\t= MAX77693_CHG_REG_CHG_INT_MASK,\n\t.num_regs\t\t= 1,\n\t.irqs\t\t\t= max77693_charger_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(max77693_charger_irqs),\n};\n\nstatic const struct regmap_config max77693_regmap_muic_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MAX77693_MUIC_REG_END,\n};\n\nstatic const struct regmap_irq max77693_muic_irqs[] = {\n\t{ .reg_offset = 0, .mask = MUIC_IRQ_INT1_ADC,\t\t},\n\t{ .reg_offset = 0, .mask = MUIC_IRQ_INT1_ADC_LOW,\t},\n\t{ .reg_offset = 0, .mask = MUIC_IRQ_INT1_ADC_ERR,\t},\n\t{ .reg_offset = 0, .mask = MUIC_IRQ_INT1_ADC1K,\t\t},\n\n\t{ .reg_offset = 1, .mask = MUIC_IRQ_INT2_CHGTYP,\t},\n\t{ .reg_offset = 1, .mask = MUIC_IRQ_INT2_CHGDETREUN,\t},\n\t{ .reg_offset = 1, .mask = MUIC_IRQ_INT2_DCDTMR,\t},\n\t{ .reg_offset = 1, .mask = MUIC_IRQ_INT2_DXOVP,\t\t},\n\t{ .reg_offset = 1, .mask = MUIC_IRQ_INT2_VBVOLT,\t},\n\t{ .reg_offset = 1, .mask = MUIC_IRQ_INT2_VIDRM,\t\t},\n\n\t{ .reg_offset = 2, .mask = MUIC_IRQ_INT3_EOC,\t\t},\n\t{ .reg_offset = 2, .mask = MUIC_IRQ_INT3_CGMBC,\t\t},\n\t{ .reg_offset = 2, .mask = MUIC_IRQ_INT3_OVP,\t\t},\n\t{ .reg_offset = 2, .mask = MUIC_IRQ_INT3_MBCCHG_ERR,\t},\n\t{ .reg_offset = 2, .mask = MUIC_IRQ_INT3_CHG_ENABLED,\t},\n\t{ .reg_offset = 2, .mask = MUIC_IRQ_INT3_BAT_DET,\t},\n};\n\nstatic const struct regmap_irq_chip max77693_muic_irq_chip = {\n\t.name\t\t\t= \"max77693-muic\",\n\t.status_base\t\t= MAX77693_MUIC_REG_INT1,\n\t.unmask_base\t\t= MAX77693_MUIC_REG_INTMASK1,\n\t.num_regs\t\t= 3,\n\t.irqs\t\t\t= max77693_muic_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(max77693_muic_irqs),\n};\n\nstatic const struct regmap_config max77693_regmap_haptic_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MAX77693_HAPTIC_REG_END,\n};\n\nstatic int max77693_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tstruct max77693_dev *max77693;\n\tunsigned int reg_data;\n\tint ret = 0;\n\n\tmax77693 = devm_kzalloc(&i2c->dev,\n\t\t\tsizeof(struct max77693_dev), GFP_KERNEL);\n\tif (max77693 == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, max77693);\n\tmax77693->dev = &i2c->dev;\n\tmax77693->i2c = i2c;\n\tmax77693->irq = i2c->irq;\n\tmax77693->type = id->driver_data;\n\n\tmax77693->regmap = devm_regmap_init_i2c(i2c, &max77693_regmap_config);\n\tif (IS_ERR(max77693->regmap)) {\n\t\tret = PTR_ERR(max77693->regmap);\n\t\tdev_err(max77693->dev, \"failed to allocate register map: %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(max77693->regmap, MAX77693_PMIC_REG_PMIC_ID2,\n\t\t\t\t&reg_data);\n\tif (ret < 0) {\n\t\tdev_err(max77693->dev, \"device not found on this channel\\n\");\n\t\treturn ret;\n\t} else\n\t\tdev_info(max77693->dev, \"device ID: 0x%x\\n\", reg_data);\n\n\tmax77693->i2c_muic = i2c_new_dummy_device(i2c->adapter, I2C_ADDR_MUIC);\n\tif (IS_ERR(max77693->i2c_muic)) {\n\t\tdev_err(max77693->dev, \"Failed to allocate I2C device for MUIC\\n\");\n\t\treturn PTR_ERR(max77693->i2c_muic);\n\t}\n\ti2c_set_clientdata(max77693->i2c_muic, max77693);\n\n\tmax77693->i2c_haptic = i2c_new_dummy_device(i2c->adapter, I2C_ADDR_HAPTIC);\n\tif (IS_ERR(max77693->i2c_haptic)) {\n\t\tdev_err(max77693->dev, \"Failed to allocate I2C device for Haptic\\n\");\n\t\tret = PTR_ERR(max77693->i2c_haptic);\n\t\tgoto err_i2c_haptic;\n\t}\n\ti2c_set_clientdata(max77693->i2c_haptic, max77693);\n\n\tmax77693->regmap_haptic = devm_regmap_init_i2c(max77693->i2c_haptic,\n\t\t\t\t\t&max77693_regmap_haptic_config);\n\tif (IS_ERR(max77693->regmap_haptic)) {\n\t\tret = PTR_ERR(max77693->regmap_haptic);\n\t\tdev_err(max77693->dev,\n\t\t\t\"failed to initialize haptic register map: %d\\n\", ret);\n\t\tgoto err_regmap;\n\t}\n\n\t \n\tmax77693->regmap_muic = devm_regmap_init_i2c(max77693->i2c_muic,\n\t\t\t\t\t &max77693_regmap_muic_config);\n\tif (IS_ERR(max77693->regmap_muic)) {\n\t\tret = PTR_ERR(max77693->regmap_muic);\n\t\tdev_err(max77693->dev,\n\t\t\t\"failed to allocate register map: %d\\n\", ret);\n\t\tgoto err_regmap;\n\t}\n\n\tret = regmap_add_irq_chip(max77693->regmap, max77693->irq,\n\t\t\t\tIRQF_ONESHOT | IRQF_SHARED, 0,\n\t\t\t\t&max77693_led_irq_chip,\n\t\t\t\t&max77693->irq_data_led);\n\tif (ret) {\n\t\tdev_err(max77693->dev, \"failed to add irq chip: %d\\n\", ret);\n\t\tgoto err_regmap;\n\t}\n\n\tret = regmap_add_irq_chip(max77693->regmap, max77693->irq,\n\t\t\t\tIRQF_ONESHOT | IRQF_SHARED, 0,\n\t\t\t\t&max77693_topsys_irq_chip,\n\t\t\t\t&max77693->irq_data_topsys);\n\tif (ret) {\n\t\tdev_err(max77693->dev, \"failed to add irq chip: %d\\n\", ret);\n\t\tgoto err_irq_topsys;\n\t}\n\n\tret = regmap_add_irq_chip(max77693->regmap, max77693->irq,\n\t\t\t\tIRQF_ONESHOT | IRQF_SHARED, 0,\n\t\t\t\t&max77693_charger_irq_chip,\n\t\t\t\t&max77693->irq_data_chg);\n\tif (ret) {\n\t\tdev_err(max77693->dev, \"failed to add irq chip: %d\\n\", ret);\n\t\tgoto err_irq_charger;\n\t}\n\n\tret = regmap_add_irq_chip(max77693->regmap_muic, max77693->irq,\n\t\t\t\tIRQF_ONESHOT | IRQF_SHARED, 0,\n\t\t\t\t&max77693_muic_irq_chip,\n\t\t\t\t&max77693->irq_data_muic);\n\tif (ret) {\n\t\tdev_err(max77693->dev, \"failed to add irq chip: %d\\n\", ret);\n\t\tgoto err_irq_muic;\n\t}\n\n\t \n\tret = regmap_update_bits(max77693->regmap,\n\t\t\t\tMAX77693_PMIC_REG_INTSRC_MASK,\n\t\t\t\tSRC_IRQ_ALL, (unsigned int)~SRC_IRQ_ALL);\n\tif (ret < 0) {\n\t\tdev_err(max77693->dev,\n\t\t\t\"Could not unmask interrupts in INTSRC: %d\\n\",\n\t\t\tret);\n\t\tgoto err_intsrc;\n\t}\n\n\tpm_runtime_set_active(max77693->dev);\n\n\tret = mfd_add_devices(max77693->dev, -1, max77693_devs,\n\t\t\t      ARRAY_SIZE(max77693_devs), NULL, 0, NULL);\n\tif (ret < 0)\n\t\tgoto err_mfd;\n\n\treturn ret;\n\nerr_mfd:\n\tmfd_remove_devices(max77693->dev);\nerr_intsrc:\n\tregmap_del_irq_chip(max77693->irq, max77693->irq_data_muic);\nerr_irq_muic:\n\tregmap_del_irq_chip(max77693->irq, max77693->irq_data_chg);\nerr_irq_charger:\n\tregmap_del_irq_chip(max77693->irq, max77693->irq_data_topsys);\nerr_irq_topsys:\n\tregmap_del_irq_chip(max77693->irq, max77693->irq_data_led);\nerr_regmap:\n\ti2c_unregister_device(max77693->i2c_haptic);\nerr_i2c_haptic:\n\ti2c_unregister_device(max77693->i2c_muic);\n\treturn ret;\n}\n\nstatic void max77693_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct max77693_dev *max77693 = i2c_get_clientdata(i2c);\n\n\tmfd_remove_devices(max77693->dev);\n\n\tregmap_del_irq_chip(max77693->irq, max77693->irq_data_muic);\n\tregmap_del_irq_chip(max77693->irq, max77693->irq_data_chg);\n\tregmap_del_irq_chip(max77693->irq, max77693->irq_data_topsys);\n\tregmap_del_irq_chip(max77693->irq, max77693->irq_data_led);\n\n\ti2c_unregister_device(max77693->i2c_muic);\n\ti2c_unregister_device(max77693->i2c_haptic);\n}\n\nstatic const struct i2c_device_id max77693_i2c_id[] = {\n\t{ \"max77693\", TYPE_MAX77693 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max77693_i2c_id);\n\nstatic int max77693_suspend(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct max77693_dev *max77693 = i2c_get_clientdata(i2c);\n\n\tif (device_may_wakeup(dev)) {\n\t\tenable_irq_wake(max77693->irq);\n\t\tdisable_irq(max77693->irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int max77693_resume(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct max77693_dev *max77693 = i2c_get_clientdata(i2c);\n\n\tif (device_may_wakeup(dev)) {\n\t\tdisable_irq_wake(max77693->irq);\n\t\tenable_irq(max77693->irq);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops max77693_pm = {\n\t.suspend = max77693_suspend,\n\t.resume = max77693_resume,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max77693_dt_match[] = {\n\t{ .compatible = \"maxim,max77693\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max77693_dt_match);\n#endif\n\nstatic struct i2c_driver max77693_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"max77693\",\n\t\t   .pm = &max77693_pm,\n\t\t   .of_match_table = of_match_ptr(max77693_dt_match),\n\t},\n\t.probe = max77693_i2c_probe,\n\t.remove = max77693_i2c_remove,\n\t.id_table = max77693_i2c_id,\n};\n\nmodule_i2c_driver(max77693_i2c_driver);\n\nMODULE_DESCRIPTION(\"MAXIM 77693 multi-function core driver\");\nMODULE_AUTHOR(\"SangYoung, Son <hello.son@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}