{
  "module_name": "as3711.c",
  "hash_id": "bebf69b37076bb472a91738733bdb16bcd8696c84ebff46bc3adea969fa4224f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/as3711.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mfd/as3711.h>\n#include <linux/mfd/core.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\nenum {\n\tAS3711_REGULATOR,\n\tAS3711_BACKLIGHT,\n};\n\n \nstatic struct mfd_cell as3711_subdevs[] = {\n\t[AS3711_REGULATOR] = {.name = \"as3711-regulator\",},\n\t[AS3711_BACKLIGHT] = {.name = \"as3711-backlight\",},\n};\n\nstatic bool as3711_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AS3711_GPIO_SIGNAL_IN:\n\tcase AS3711_INTERRUPT_STATUS_1:\n\tcase AS3711_INTERRUPT_STATUS_2:\n\tcase AS3711_INTERRUPT_STATUS_3:\n\tcase AS3711_CHARGER_STATUS_1:\n\tcase AS3711_CHARGER_STATUS_2:\n\tcase AS3711_REG_STATUS:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool as3711_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AS3711_INTERRUPT_STATUS_1:\n\tcase AS3711_INTERRUPT_STATUS_2:\n\tcase AS3711_INTERRUPT_STATUS_3:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool as3711_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AS3711_SD_1_VOLTAGE:\n\tcase AS3711_SD_2_VOLTAGE:\n\tcase AS3711_SD_3_VOLTAGE:\n\tcase AS3711_SD_4_VOLTAGE:\n\tcase AS3711_LDO_1_VOLTAGE:\n\tcase AS3711_LDO_2_VOLTAGE:\n\tcase AS3711_LDO_3_VOLTAGE:\n\tcase AS3711_LDO_4_VOLTAGE:\n\tcase AS3711_LDO_5_VOLTAGE:\n\tcase AS3711_LDO_6_VOLTAGE:\n\tcase AS3711_LDO_7_VOLTAGE:\n\tcase AS3711_LDO_8_VOLTAGE:\n\tcase AS3711_SD_CONTROL:\n\tcase AS3711_GPIO_SIGNAL_OUT:\n\tcase AS3711_GPIO_SIGNAL_IN:\n\tcase AS3711_SD_CONTROL_1:\n\tcase AS3711_SD_CONTROL_2:\n\tcase AS3711_CURR_CONTROL:\n\tcase AS3711_CURR1_VALUE:\n\tcase AS3711_CURR2_VALUE:\n\tcase AS3711_CURR3_VALUE:\n\tcase AS3711_STEPUP_CONTROL_1:\n\tcase AS3711_STEPUP_CONTROL_2:\n\tcase AS3711_STEPUP_CONTROL_4:\n\tcase AS3711_STEPUP_CONTROL_5:\n\tcase AS3711_REG_STATUS:\n\tcase AS3711_INTERRUPT_STATUS_1:\n\tcase AS3711_INTERRUPT_STATUS_2:\n\tcase AS3711_INTERRUPT_STATUS_3:\n\tcase AS3711_CHARGER_STATUS_1:\n\tcase AS3711_CHARGER_STATUS_2:\n\tcase AS3711_ASIC_ID_1:\n\tcase AS3711_ASIC_ID_2:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct regmap_config as3711_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_reg = as3711_volatile_reg,\n\t.readable_reg = as3711_readable_reg,\n\t.precious_reg = as3711_precious_reg,\n\t.max_register = AS3711_MAX_REG,\n\t.num_reg_defaults_raw = AS3711_NUM_REGS,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id as3711_of_match[] = {\n\t{.compatible = \"ams,as3711\",},\n\t{}\n};\n#endif\n\nstatic int as3711_i2c_probe(struct i2c_client *client)\n{\n\tstruct as3711 *as3711;\n\tstruct as3711_platform_data *pdata;\n\tunsigned int id1, id2;\n\tint ret;\n\n\tif (!client->dev.of_node) {\n\t\tpdata = dev_get_platdata(&client->dev);\n\t\tif (!pdata)\n\t\t\tdev_dbg(&client->dev, \"Platform data not found\\n\");\n\t} else {\n\t\tpdata = devm_kzalloc(&client->dev,\n\t\t\t\t     sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tas3711 = devm_kzalloc(&client->dev, sizeof(struct as3711), GFP_KERNEL);\n\tif (!as3711)\n\t\treturn -ENOMEM;\n\n\tas3711->dev = &client->dev;\n\ti2c_set_clientdata(client, as3711);\n\n\tif (client->irq)\n\t\tdev_notice(&client->dev, \"IRQ not supported yet\\n\");\n\n\tas3711->regmap = devm_regmap_init_i2c(client, &as3711_regmap_config);\n\tif (IS_ERR(as3711->regmap)) {\n\t\tret = PTR_ERR(as3711->regmap);\n\t\tdev_err(&client->dev,\n\t\t\t\"regmap initialization failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(as3711->regmap, AS3711_ASIC_ID_1, &id1);\n\tif (!ret)\n\t\tret = regmap_read(as3711->regmap, AS3711_ASIC_ID_2, &id2);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"regmap_read() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (id1 != 0x8b)\n\t\treturn -ENODEV;\n\tdev_info(as3711->dev, \"AS3711 detected: %x:%x\\n\", id1, id2);\n\n\t \n\tif (pdata) {\n\t\tas3711_subdevs[AS3711_REGULATOR].platform_data =\n\t\t\t&pdata->regulator;\n\t\tas3711_subdevs[AS3711_REGULATOR].pdata_size =\n\t\t\tsizeof(pdata->regulator);\n\t\tas3711_subdevs[AS3711_BACKLIGHT].platform_data =\n\t\t\t&pdata->backlight;\n\t\tas3711_subdevs[AS3711_BACKLIGHT].pdata_size =\n\t\t\tsizeof(pdata->backlight);\n\t} else {\n\t\tas3711_subdevs[AS3711_REGULATOR].platform_data = NULL;\n\t\tas3711_subdevs[AS3711_REGULATOR].pdata_size = 0;\n\t\tas3711_subdevs[AS3711_BACKLIGHT].platform_data = NULL;\n\t\tas3711_subdevs[AS3711_BACKLIGHT].pdata_size = 0;\n\t}\n\n\tret = devm_mfd_add_devices(as3711->dev, -1, as3711_subdevs,\n\t\t\t\t   ARRAY_SIZE(as3711_subdevs), NULL, 0, NULL);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"add mfd devices failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id as3711_i2c_id[] = {\n\t{.name = \"as3711\", .driver_data = 0},\n\t{}\n};\n\nstatic struct i2c_driver as3711_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"as3711\",\n\t\t   .of_match_table = of_match_ptr(as3711_of_match),\n\t},\n\t.probe = as3711_i2c_probe,\n\t.id_table = as3711_i2c_id,\n};\n\nstatic int __init as3711_i2c_init(void)\n{\n\treturn i2c_add_driver(&as3711_i2c_driver);\n}\n \nsubsys_initcall(as3711_i2c_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}