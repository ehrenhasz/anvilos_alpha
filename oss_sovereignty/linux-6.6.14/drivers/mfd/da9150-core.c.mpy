{
  "module_name": "da9150-core.c",
  "hash_id": "0fe1f1fe5545376d2e6332624db2eeca09aa9814d0541995829f94841deb5525",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/da9150-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/da9150/core.h>\n#include <linux/mfd/da9150/registers.h>\n\n \nstatic int da9150_i2c_read_device(struct i2c_client *client, u8 addr, int count,\n\t\t\t\t  u8 *buf)\n{\n\tstruct i2c_msg xfer;\n\tint ret;\n\n\t \n\n\t \n\txfer.addr = client->addr;\n\txfer.flags = 0;\n\txfer.len = 1;\n\txfer.buf = &addr;\n\n\tret = i2c_transfer(client->adapter, &xfer, 1);\n\tif (ret != 1) {\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\n\t \n\txfer.addr = client->addr;\n\txfer.flags = I2C_M_RD;\n\txfer.len = count;\n\txfer.buf = buf;\n\n\tret = i2c_transfer(client->adapter, &xfer, 1);\n\tif (ret == 1)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int da9150_i2c_write_device(struct i2c_client *client, u8 addr,\n\t\t\t\t   int count, const u8 *buf)\n{\n\tstruct i2c_msg xfer;\n\tu8 *reg_data;\n\tint ret;\n\n\treg_data = kzalloc(1 + count, GFP_KERNEL);\n\tif (!reg_data)\n\t\treturn -ENOMEM;\n\n\treg_data[0] = addr;\n\tmemcpy(&reg_data[1], buf, count);\n\n\t \n\txfer.addr = client->addr;\n\txfer.flags = 0;\n\txfer.len = 1 + count;\n\txfer.buf = reg_data;\n\n\tret = i2c_transfer(client->adapter, &xfer, 1);\n\tkfree(reg_data);\n\tif (ret == 1)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic bool da9150_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase DA9150_PAGE_CON:\n\tcase DA9150_STATUS_A:\n\tcase DA9150_STATUS_B:\n\tcase DA9150_STATUS_C:\n\tcase DA9150_STATUS_D:\n\tcase DA9150_STATUS_E:\n\tcase DA9150_STATUS_F:\n\tcase DA9150_STATUS_G:\n\tcase DA9150_STATUS_H:\n\tcase DA9150_STATUS_I:\n\tcase DA9150_STATUS_J:\n\tcase DA9150_STATUS_K:\n\tcase DA9150_STATUS_L:\n\tcase DA9150_STATUS_N:\n\tcase DA9150_FAULT_LOG_A:\n\tcase DA9150_FAULT_LOG_B:\n\tcase DA9150_EVENT_E:\n\tcase DA9150_EVENT_F:\n\tcase DA9150_EVENT_G:\n\tcase DA9150_EVENT_H:\n\tcase DA9150_CONTROL_B:\n\tcase DA9150_CONTROL_C:\n\tcase DA9150_GPADC_MAN:\n\tcase DA9150_GPADC_RES_A:\n\tcase DA9150_GPADC_RES_B:\n\tcase DA9150_ADETVB_CFG_C:\n\tcase DA9150_ADETD_STAT:\n\tcase DA9150_ADET_CMPSTAT:\n\tcase DA9150_ADET_CTRL_A:\n\tcase DA9150_PPR_TCTR_B:\n\tcase DA9150_COREBTLD_STAT_A:\n\tcase DA9150_CORE_DATA_A:\n\tcase DA9150_CORE_DATA_B:\n\tcase DA9150_CORE_DATA_C:\n\tcase DA9150_CORE_DATA_D:\n\tcase DA9150_CORE2WIRE_STAT_A:\n\tcase DA9150_FW_CTRL_C:\n\tcase DA9150_FG_CTRL_B:\n\tcase DA9150_FW_CTRL_B:\n\tcase DA9150_GPADC_CMAN:\n\tcase DA9150_GPADC_CRES_A:\n\tcase DA9150_GPADC_CRES_B:\n\tcase DA9150_CC_ICHG_RES_A:\n\tcase DA9150_CC_ICHG_RES_B:\n\tcase DA9150_CC_IAVG_RES_A:\n\tcase DA9150_CC_IAVG_RES_B:\n\tcase DA9150_TAUX_CTRL_A:\n\tcase DA9150_TAUX_VALUE_H:\n\tcase DA9150_TAUX_VALUE_L:\n\tcase DA9150_TBAT_RES_A:\n\tcase DA9150_TBAT_RES_B:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_range_cfg da9150_range_cfg[] = {\n\t{\n\t\t.range_min = DA9150_PAGE_CON,\n\t\t.range_max = DA9150_TBAT_RES_B,\n\t\t.selector_reg = DA9150_PAGE_CON,\n\t\t.selector_mask = DA9150_I2C_PAGE_MASK,\n\t\t.selector_shift = DA9150_I2C_PAGE_SHIFT,\n\t\t.window_start = 0,\n\t\t.window_len = 256,\n\t},\n};\n\nstatic const struct regmap_config da9150_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.ranges = da9150_range_cfg,\n\t.num_ranges = ARRAY_SIZE(da9150_range_cfg),\n\t.max_register = DA9150_TBAT_RES_B,\n\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.volatile_reg = da9150_volatile_reg,\n};\n\nvoid da9150_read_qif(struct da9150 *da9150, u8 addr, int count, u8 *buf)\n{\n\tint ret;\n\n\tret = da9150_i2c_read_device(da9150->core_qif, addr, count, buf);\n\tif (ret < 0)\n\t\tdev_err(da9150->dev, \"Failed to read from QIF 0x%x: %d\\n\",\n\t\t\taddr, ret);\n}\nEXPORT_SYMBOL_GPL(da9150_read_qif);\n\nvoid da9150_write_qif(struct da9150 *da9150, u8 addr, int count, const u8 *buf)\n{\n\tint ret;\n\n\tret = da9150_i2c_write_device(da9150->core_qif, addr, count, buf);\n\tif (ret < 0)\n\t\tdev_err(da9150->dev, \"Failed to write to QIF 0x%x: %d\\n\",\n\t\t\taddr, ret);\n}\nEXPORT_SYMBOL_GPL(da9150_write_qif);\n\nu8 da9150_reg_read(struct da9150 *da9150, u16 reg)\n{\n\tint val, ret;\n\n\tret = regmap_read(da9150->regmap, reg, &val);\n\tif (ret)\n\t\tdev_err(da9150->dev, \"Failed to read from reg 0x%x: %d\\n\",\n\t\t\treg, ret);\n\n\treturn (u8) val;\n}\nEXPORT_SYMBOL_GPL(da9150_reg_read);\n\nvoid da9150_reg_write(struct da9150 *da9150, u16 reg, u8 val)\n{\n\tint ret;\n\n\tret = regmap_write(da9150->regmap, reg, val);\n\tif (ret)\n\t\tdev_err(da9150->dev, \"Failed to write to reg 0x%x: %d\\n\",\n\t\t\treg, ret);\n}\nEXPORT_SYMBOL_GPL(da9150_reg_write);\n\nvoid da9150_set_bits(struct da9150 *da9150, u16 reg, u8 mask, u8 val)\n{\n\tint ret;\n\n\tret = regmap_update_bits(da9150->regmap, reg, mask, val);\n\tif (ret)\n\t\tdev_err(da9150->dev, \"Failed to set bits in reg 0x%x: %d\\n\",\n\t\t\treg, ret);\n}\nEXPORT_SYMBOL_GPL(da9150_set_bits);\n\nvoid da9150_bulk_read(struct da9150 *da9150, u16 reg, int count, u8 *buf)\n{\n\tint ret;\n\n\tret = regmap_bulk_read(da9150->regmap, reg, buf, count);\n\tif (ret)\n\t\tdev_err(da9150->dev, \"Failed to bulk read from reg 0x%x: %d\\n\",\n\t\t\treg, ret);\n}\nEXPORT_SYMBOL_GPL(da9150_bulk_read);\n\nvoid da9150_bulk_write(struct da9150 *da9150, u16 reg, int count, const u8 *buf)\n{\n\tint ret;\n\n\tret = regmap_raw_write(da9150->regmap, reg, buf, count);\n\tif (ret)\n\t\tdev_err(da9150->dev, \"Failed to bulk write to reg 0x%x %d\\n\",\n\t\t\treg, ret);\n}\nEXPORT_SYMBOL_GPL(da9150_bulk_write);\n\nstatic const struct regmap_irq da9150_irqs[] = {\n\t[DA9150_IRQ_VBUS] = {\n\t\t.reg_offset = 0,\n\t\t.mask = DA9150_E_VBUS_MASK,\n\t},\n\t[DA9150_IRQ_CHG] = {\n\t\t.reg_offset = 0,\n\t\t.mask = DA9150_E_CHG_MASK,\n\t},\n\t[DA9150_IRQ_TCLASS] = {\n\t\t.reg_offset = 0,\n\t\t.mask = DA9150_E_TCLASS_MASK,\n\t},\n\t[DA9150_IRQ_TJUNC] = {\n\t\t.reg_offset = 0,\n\t\t.mask = DA9150_E_TJUNC_MASK,\n\t},\n\t[DA9150_IRQ_VFAULT] = {\n\t\t.reg_offset = 0,\n\t\t.mask = DA9150_E_VFAULT_MASK,\n\t},\n\t[DA9150_IRQ_CONF] = {\n\t\t.reg_offset = 1,\n\t\t.mask = DA9150_E_CONF_MASK,\n\t},\n\t[DA9150_IRQ_DAT] = {\n\t\t.reg_offset = 1,\n\t\t.mask = DA9150_E_DAT_MASK,\n\t},\n\t[DA9150_IRQ_DTYPE] = {\n\t\t.reg_offset = 1,\n\t\t.mask = DA9150_E_DTYPE_MASK,\n\t},\n\t[DA9150_IRQ_ID] = {\n\t\t.reg_offset = 1,\n\t\t.mask = DA9150_E_ID_MASK,\n\t},\n\t[DA9150_IRQ_ADP] = {\n\t\t.reg_offset = 1,\n\t\t.mask = DA9150_E_ADP_MASK,\n\t},\n\t[DA9150_IRQ_SESS_END] = {\n\t\t.reg_offset = 1,\n\t\t.mask = DA9150_E_SESS_END_MASK,\n\t},\n\t[DA9150_IRQ_SESS_VLD] = {\n\t\t.reg_offset = 1,\n\t\t.mask = DA9150_E_SESS_VLD_MASK,\n\t},\n\t[DA9150_IRQ_FG] = {\n\t\t.reg_offset = 2,\n\t\t.mask = DA9150_E_FG_MASK,\n\t},\n\t[DA9150_IRQ_GP] = {\n\t\t.reg_offset = 2,\n\t\t.mask = DA9150_E_GP_MASK,\n\t},\n\t[DA9150_IRQ_TBAT] = {\n\t\t.reg_offset = 2,\n\t\t.mask = DA9150_E_TBAT_MASK,\n\t},\n\t[DA9150_IRQ_GPIOA] = {\n\t\t.reg_offset = 2,\n\t\t.mask = DA9150_E_GPIOA_MASK,\n\t},\n\t[DA9150_IRQ_GPIOB] = {\n\t\t.reg_offset = 2,\n\t\t.mask = DA9150_E_GPIOB_MASK,\n\t},\n\t[DA9150_IRQ_GPIOC] = {\n\t\t.reg_offset = 2,\n\t\t.mask = DA9150_E_GPIOC_MASK,\n\t},\n\t[DA9150_IRQ_GPIOD] = {\n\t\t.reg_offset = 2,\n\t\t.mask = DA9150_E_GPIOD_MASK,\n\t},\n\t[DA9150_IRQ_GPADC] = {\n\t\t.reg_offset = 2,\n\t\t.mask = DA9150_E_GPADC_MASK,\n\t},\n\t[DA9150_IRQ_WKUP] = {\n\t\t.reg_offset = 3,\n\t\t.mask = DA9150_E_WKUP_MASK,\n\t},\n};\n\nstatic const struct regmap_irq_chip da9150_regmap_irq_chip = {\n\t.name = \"da9150_irq\",\n\t.status_base = DA9150_EVENT_E,\n\t.mask_base = DA9150_IRQ_MASK_E,\n\t.ack_base = DA9150_EVENT_E,\n\t.num_regs = DA9150_NUM_IRQ_REGS,\n\t.irqs = da9150_irqs,\n\t.num_irqs = ARRAY_SIZE(da9150_irqs),\n};\n\nstatic const struct resource da9150_gpadc_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(DA9150_IRQ_GPADC, \"GPADC\"),\n};\n\nstatic const struct resource da9150_charger_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(DA9150_IRQ_CHG, \"CHG_STATUS\"),\n\tDEFINE_RES_IRQ_NAMED(DA9150_IRQ_TJUNC, \"CHG_TJUNC\"),\n\tDEFINE_RES_IRQ_NAMED(DA9150_IRQ_VFAULT, \"CHG_VFAULT\"),\n\tDEFINE_RES_IRQ_NAMED(DA9150_IRQ_VBUS, \"CHG_VBUS\"),\n};\n\nstatic const struct resource da9150_fg_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(DA9150_IRQ_FG, \"FG\"),\n};\n\nenum da9150_dev_idx {\n\tDA9150_GPADC_IDX = 0,\n\tDA9150_CHARGER_IDX,\n\tDA9150_FG_IDX,\n};\n\nstatic struct mfd_cell da9150_devs[] = {\n\t[DA9150_GPADC_IDX] = {\n\t\t.name = \"da9150-gpadc\",\n\t\t.of_compatible = \"dlg,da9150-gpadc\",\n\t\t.resources = da9150_gpadc_resources,\n\t\t.num_resources = ARRAY_SIZE(da9150_gpadc_resources),\n\t},\n\t[DA9150_CHARGER_IDX] = {\n\t\t.name = \"da9150-charger\",\n\t\t.of_compatible = \"dlg,da9150-charger\",\n\t\t.resources = da9150_charger_resources,\n\t\t.num_resources = ARRAY_SIZE(da9150_charger_resources),\n\t},\n\t[DA9150_FG_IDX] = {\n\t\t.name = \"da9150-fuel-gauge\",\n\t\t.of_compatible = \"dlg,da9150-fuel-gauge\",\n\t\t.resources = da9150_fg_resources,\n\t\t.num_resources = ARRAY_SIZE(da9150_fg_resources),\n\t},\n};\n\nstatic int da9150_probe(struct i2c_client *client)\n{\n\tstruct da9150 *da9150;\n\tstruct da9150_pdata *pdata = dev_get_platdata(&client->dev);\n\tint qif_addr;\n\tint ret;\n\n\tda9150 = devm_kzalloc(&client->dev, sizeof(*da9150), GFP_KERNEL);\n\tif (!da9150)\n\t\treturn -ENOMEM;\n\n\tda9150->dev = &client->dev;\n\tda9150->irq = client->irq;\n\ti2c_set_clientdata(client, da9150);\n\n\tda9150->regmap = devm_regmap_init_i2c(client, &da9150_regmap_config);\n\tif (IS_ERR(da9150->regmap)) {\n\t\tret = PTR_ERR(da9150->regmap);\n\t\tdev_err(da9150->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tqif_addr = da9150_reg_read(da9150, DA9150_CORE2WIRE_CTRL_A);\n\tqif_addr = (qif_addr & DA9150_CORE_BASE_ADDR_MASK) >> 1;\n\tqif_addr |= DA9150_QIF_I2C_ADDR_LSB;\n\tda9150->core_qif = i2c_new_dummy_device(client->adapter, qif_addr);\n\tif (IS_ERR(da9150->core_qif)) {\n\t\tdev_err(da9150->dev, \"Failed to attach QIF client\\n\");\n\t\treturn PTR_ERR(da9150->core_qif);\n\t}\n\n\ti2c_set_clientdata(da9150->core_qif, da9150);\n\n\tif (pdata) {\n\t\tda9150->irq_base = pdata->irq_base;\n\n\t\tda9150_devs[DA9150_FG_IDX].platform_data = pdata->fg_pdata;\n\t\tda9150_devs[DA9150_FG_IDX].pdata_size =\n\t\t\tsizeof(struct da9150_fg_pdata);\n\t} else {\n\t\tda9150->irq_base = -1;\n\t}\n\n\tret = regmap_add_irq_chip(da9150->regmap, da9150->irq,\n\t\t\t\t  IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t  da9150->irq_base, &da9150_regmap_irq_chip,\n\t\t\t\t  &da9150->regmap_irq_data);\n\tif (ret) {\n\t\tdev_err(da9150->dev, \"Failed to add regmap irq chip: %d\\n\",\n\t\t\tret);\n\t\tgoto regmap_irq_fail;\n\t}\n\n\n\tda9150->irq_base = regmap_irq_chip_get_base(da9150->regmap_irq_data);\n\n\tenable_irq_wake(da9150->irq);\n\n\tret = mfd_add_devices(da9150->dev, -1, da9150_devs,\n\t\t\t      ARRAY_SIZE(da9150_devs), NULL,\n\t\t\t      da9150->irq_base, NULL);\n\tif (ret) {\n\t\tdev_err(da9150->dev, \"Failed to add child devices: %d\\n\", ret);\n\t\tgoto mfd_fail;\n\t}\n\n\treturn 0;\n\nmfd_fail:\n\tregmap_del_irq_chip(da9150->irq, da9150->regmap_irq_data);\nregmap_irq_fail:\n\ti2c_unregister_device(da9150->core_qif);\n\n\treturn ret;\n}\n\nstatic void da9150_remove(struct i2c_client *client)\n{\n\tstruct da9150 *da9150 = i2c_get_clientdata(client);\n\n\tregmap_del_irq_chip(da9150->irq, da9150->regmap_irq_data);\n\tmfd_remove_devices(da9150->dev);\n\ti2c_unregister_device(da9150->core_qif);\n}\n\nstatic void da9150_shutdown(struct i2c_client *client)\n{\n\tstruct da9150 *da9150 = i2c_get_clientdata(client);\n\n\t \n\tda9150_set_bits(da9150, DA9150_CONFIG_D,\n\t\t\tDA9150_WKUP_PM_EN_MASK,\n\t\t\tDA9150_WKUP_PM_EN_MASK);\n\n\t \n\tda9150_set_bits(da9150, DA9150_CONTROL_C,\n\t\t\tDA9150_DISABLE_MASK, DA9150_DISABLE_MASK);\n}\n\nstatic const struct i2c_device_id da9150_i2c_id[] = {\n\t{ \"da9150\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, da9150_i2c_id);\n\nstatic const struct of_device_id da9150_of_match[] = {\n\t{ .compatible = \"dlg,da9150\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, da9150_of_match);\n\nstatic struct i2c_driver da9150_driver = {\n\t.driver\t= {\n\t\t.name\t= \"da9150\",\n\t\t.of_match_table = da9150_of_match,\n\t},\n\t.probe\t\t= da9150_probe,\n\t.remove\t\t= da9150_remove,\n\t.shutdown\t= da9150_shutdown,\n\t.id_table\t= da9150_i2c_id,\n};\n\nmodule_i2c_driver(da9150_driver);\n\nMODULE_DESCRIPTION(\"MFD Core Driver for DA9150\");\nMODULE_AUTHOR(\"Adam Thomson <Adam.Thomson.Opensource@diasemi.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}