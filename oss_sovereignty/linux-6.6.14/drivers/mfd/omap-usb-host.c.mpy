{
  "module_name": "omap-usb-host.c",
  "hash_id": "bd8d628a33e09611e11562091e7047d95803802a45e2111d0ac4c072d5291673",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/omap-usb-host.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/gpio.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/usb-omap.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/err.h>\n\n#include \"omap-usb.h\"\n\n#define USBHS_DRIVER_NAME\t\"usbhs_omap\"\n#define OMAP_EHCI_DEVICE\t\"ehci-omap\"\n#define OMAP_OHCI_DEVICE\t\"ohci-omap3\"\n\n \n\n \n#define\tOMAP_UHH_REVISION\t\t\t\t(0x00)\n#define\tOMAP_UHH_SYSCONFIG\t\t\t\t(0x10)\n#define\tOMAP_UHH_SYSCONFIG_MIDLEMODE\t\t\t(1 << 12)\n#define\tOMAP_UHH_SYSCONFIG_CACTIVITY\t\t\t(1 << 8)\n#define\tOMAP_UHH_SYSCONFIG_SIDLEMODE\t\t\t(1 << 3)\n#define\tOMAP_UHH_SYSCONFIG_ENAWAKEUP\t\t\t(1 << 2)\n#define\tOMAP_UHH_SYSCONFIG_SOFTRESET\t\t\t(1 << 1)\n#define\tOMAP_UHH_SYSCONFIG_AUTOIDLE\t\t\t(1 << 0)\n\n#define\tOMAP_UHH_SYSSTATUS\t\t\t\t(0x14)\n#define\tOMAP_UHH_HOSTCONFIG\t\t\t\t(0x40)\n#define\tOMAP_UHH_HOSTCONFIG_ULPI_BYPASS\t\t\t(1 << 0)\n#define\tOMAP_UHH_HOSTCONFIG_ULPI_P1_BYPASS\t\t(1 << 0)\n#define\tOMAP_UHH_HOSTCONFIG_ULPI_P2_BYPASS\t\t(1 << 11)\n#define\tOMAP_UHH_HOSTCONFIG_ULPI_P3_BYPASS\t\t(1 << 12)\n#define OMAP_UHH_HOSTCONFIG_INCR4_BURST_EN\t\t(1 << 2)\n#define OMAP_UHH_HOSTCONFIG_INCR8_BURST_EN\t\t(1 << 3)\n#define OMAP_UHH_HOSTCONFIG_INCR16_BURST_EN\t\t(1 << 4)\n#define OMAP_UHH_HOSTCONFIG_INCRX_ALIGN_EN\t\t(1 << 5)\n#define OMAP_UHH_HOSTCONFIG_P1_CONNECT_STATUS\t\t(1 << 8)\n#define OMAP_UHH_HOSTCONFIG_P2_CONNECT_STATUS\t\t(1 << 9)\n#define OMAP_UHH_HOSTCONFIG_P3_CONNECT_STATUS\t\t(1 << 10)\n#define OMAP4_UHH_HOSTCONFIG_APP_START_CLK\t\t(1 << 31)\n\n \n#define OMAP4_UHH_SYSCONFIG_IDLEMODE_CLEAR\t\t(3 << 2)\n#define OMAP4_UHH_SYSCONFIG_NOIDLE\t\t\t(1 << 2)\n#define OMAP4_UHH_SYSCONFIG_STDBYMODE_CLEAR\t\t(3 << 4)\n#define OMAP4_UHH_SYSCONFIG_NOSTDBY\t\t\t(1 << 4)\n#define OMAP4_UHH_SYSCONFIG_SOFTRESET\t\t\t(1 << 0)\n\n#define OMAP4_P1_MODE_CLEAR\t\t\t\t(3 << 16)\n#define OMAP4_P1_MODE_TLL\t\t\t\t(1 << 16)\n#define OMAP4_P1_MODE_HSIC\t\t\t\t(3 << 16)\n#define OMAP4_P2_MODE_CLEAR\t\t\t\t(3 << 18)\n#define OMAP4_P2_MODE_TLL\t\t\t\t(1 << 18)\n#define OMAP4_P2_MODE_HSIC\t\t\t\t(3 << 18)\n\n#define\tOMAP_UHH_DEBUG_CSR\t\t\t\t(0x44)\n\n \n#define OMAP_USBHS_REV1\t\t0x00000010\t \n#define OMAP_USBHS_REV2\t\t0x50700100\t \n\n#define is_omap_usbhs_rev1(x)\t(x->usbhs_rev == OMAP_USBHS_REV1)\n#define is_omap_usbhs_rev2(x)\t(x->usbhs_rev == OMAP_USBHS_REV2)\n\n#define is_ehci_phy_mode(x)\t(x == OMAP_EHCI_PORT_MODE_PHY)\n#define is_ehci_tll_mode(x)\t(x == OMAP_EHCI_PORT_MODE_TLL)\n#define is_ehci_hsic_mode(x)\t(x == OMAP_EHCI_PORT_MODE_HSIC)\n\n\nstruct usbhs_hcd_omap {\n\tint\t\t\t\tnports;\n\tstruct clk\t\t\t**utmi_clk;\n\tstruct clk\t\t\t**hsic60m_clk;\n\tstruct clk\t\t\t**hsic480m_clk;\n\n\tstruct clk\t\t\t*xclk60mhsp1_ck;\n\tstruct clk\t\t\t*xclk60mhsp2_ck;\n\tstruct clk\t\t\t*utmi_p1_gfclk;\n\tstruct clk\t\t\t*utmi_p2_gfclk;\n\tstruct clk\t\t\t*init_60m_fclk;\n\tstruct clk\t\t\t*ehci_logic_fck;\n\n\tvoid __iomem\t\t\t*uhh_base;\n\n\tstruct usbhs_omap_platform_data\t*pdata;\n\n\tu32\t\t\t\tusbhs_rev;\n};\n \n\nstatic const char usbhs_driver_name[] = USBHS_DRIVER_NAME;\nstatic u64 usbhs_dmamask = DMA_BIT_MASK(32);\n\n \n\nstatic inline void usbhs_write(void __iomem *base, u32 reg, u32 val)\n{\n\twritel_relaxed(val, base + reg);\n}\n\nstatic inline u32 usbhs_read(void __iomem *base, u32 reg)\n{\n\treturn readl_relaxed(base + reg);\n}\n\n \n\n \nstatic const char * const port_modes[] = {\n\t[OMAP_USBHS_PORT_MODE_UNUSED]\t= \"\",\n\t[OMAP_EHCI_PORT_MODE_PHY]\t= \"ehci-phy\",\n\t[OMAP_EHCI_PORT_MODE_TLL]\t= \"ehci-tll\",\n\t[OMAP_EHCI_PORT_MODE_HSIC]\t= \"ehci-hsic\",\n\t[OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0]\t= \"ohci-phy-6pin-datse0\",\n\t[OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM]\t= \"ohci-phy-6pin-dpdm\",\n\t[OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0]\t= \"ohci-phy-3pin-datse0\",\n\t[OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM]\t= \"ohci-phy-4pin-dpdm\",\n\t[OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0]\t= \"ohci-tll-6pin-datse0\",\n\t[OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM]\t= \"ohci-tll-6pin-dpdm\",\n\t[OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0]\t= \"ohci-tll-3pin-datse0\",\n\t[OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM]\t= \"ohci-tll-4pin-dpdm\",\n\t[OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0]\t= \"ohci-tll-2pin-datse0\",\n\t[OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM]\t= \"ohci-tll-2pin-dpdm\",\n};\n\nstatic struct platform_device *omap_usbhs_alloc_child(const char *name,\n\t\t\tstruct resource\t*res, int num_resources, void *pdata,\n\t\t\tsize_t pdata_size, struct device *dev)\n{\n\tstruct platform_device\t*child;\n\tint\t\t\tret;\n\n\tchild = platform_device_alloc(name, 0);\n\n\tif (!child) {\n\t\tdev_err(dev, \"platform_device_alloc %s failed\\n\", name);\n\t\tgoto err_end;\n\t}\n\n\tret = platform_device_add_resources(child, res, num_resources);\n\tif (ret) {\n\t\tdev_err(dev, \"platform_device_add_resources failed\\n\");\n\t\tgoto err_alloc;\n\t}\n\n\tret = platform_device_add_data(child, pdata, pdata_size);\n\tif (ret) {\n\t\tdev_err(dev, \"platform_device_add_data failed\\n\");\n\t\tgoto err_alloc;\n\t}\n\n\tchild->dev.dma_mask\t\t= &usbhs_dmamask;\n\tdma_set_coherent_mask(&child->dev, DMA_BIT_MASK(32));\n\tchild->dev.parent\t\t= dev;\n\n\tret = platform_device_add(child);\n\tif (ret) {\n\t\tdev_err(dev, \"platform_device_add failed\\n\");\n\t\tgoto err_alloc;\n\t}\n\n\treturn child;\n\nerr_alloc:\n\tplatform_device_put(child);\n\nerr_end:\n\treturn NULL;\n}\n\nstatic int omap_usbhs_alloc_children(struct platform_device *pdev)\n{\n\tstruct device\t\t\t\t*dev = &pdev->dev;\n\tstruct usbhs_omap_platform_data\t\t*pdata = dev_get_platdata(dev);\n\tstruct platform_device\t\t\t*ehci;\n\tstruct platform_device\t\t\t*ohci;\n\tstruct resource\t\t\t\t*res;\n\tstruct resource\t\t\t\tresources[2];\n\tint\t\t\t\t\tret;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"ehci\");\n\tif (!res) {\n\t\tdev_err(dev, \"EHCI get resource IORESOURCE_MEM failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_end;\n\t}\n\tresources[0] = *res;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_IRQ, \"ehci-irq\");\n\tif (!res) {\n\t\tdev_err(dev, \" EHCI get resource IORESOURCE_IRQ failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_end;\n\t}\n\tresources[1] = *res;\n\n\tehci = omap_usbhs_alloc_child(OMAP_EHCI_DEVICE, resources, 2, pdata,\n\t\tsizeof(*pdata), dev);\n\n\tif (!ehci) {\n\t\tdev_err(dev, \"omap_usbhs_alloc_child failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_end;\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"ohci\");\n\tif (!res) {\n\t\tdev_err(dev, \"OHCI get resource IORESOURCE_MEM failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_ehci;\n\t}\n\tresources[0] = *res;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_IRQ, \"ohci-irq\");\n\tif (!res) {\n\t\tdev_err(dev, \"OHCI get resource IORESOURCE_IRQ failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_ehci;\n\t}\n\tresources[1] = *res;\n\n\tohci = omap_usbhs_alloc_child(OMAP_OHCI_DEVICE, resources, 2, pdata,\n\t\tsizeof(*pdata), dev);\n\tif (!ohci) {\n\t\tdev_err(dev, \"omap_usbhs_alloc_child failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_ehci;\n\t}\n\n\treturn 0;\n\nerr_ehci:\n\tplatform_device_unregister(ehci);\n\nerr_end:\n\treturn ret;\n}\n\nstatic bool is_ohci_port(enum usbhs_omap_port_mode pmode)\n{\n\tswitch (pmode) {\n\tcase OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0:\n\tcase OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM:\n\tcase OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0:\n\tcase OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM:\n\tcase OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0:\n\tcase OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM:\n\tcase OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0:\n\tcase OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM:\n\tcase OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0:\n\tcase OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int usbhs_runtime_resume(struct device *dev)\n{\n\tstruct usbhs_hcd_omap\t\t*omap = dev_get_drvdata(dev);\n\tstruct usbhs_omap_platform_data\t*pdata = omap->pdata;\n\tint i, r;\n\n\tdev_dbg(dev, \"usbhs_runtime_resume\\n\");\n\n\tomap_tll_enable(pdata);\n\n\tif (!IS_ERR(omap->ehci_logic_fck))\n\t\tclk_prepare_enable(omap->ehci_logic_fck);\n\n\tfor (i = 0; i < omap->nports; i++) {\n\t\tswitch (pdata->port_mode[i]) {\n\t\tcase OMAP_EHCI_PORT_MODE_HSIC:\n\t\t\tif (!IS_ERR(omap->hsic60m_clk[i])) {\n\t\t\t\tr = clk_prepare_enable(omap->hsic60m_clk[i]);\n\t\t\t\tif (r) {\n\t\t\t\t\tdev_err(dev,\n\t\t\t\t\t \"Can't enable port %d hsic60m clk:%d\\n\",\n\t\t\t\t\t i, r);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!IS_ERR(omap->hsic480m_clk[i])) {\n\t\t\t\tr = clk_prepare_enable(omap->hsic480m_clk[i]);\n\t\t\t\tif (r) {\n\t\t\t\t\tdev_err(dev,\n\t\t\t\t\t \"Can't enable port %d hsic480m clk:%d\\n\",\n\t\t\t\t\t i, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfallthrough;\t \n\n\t\tcase OMAP_EHCI_PORT_MODE_TLL:\n\t\t\tif (!IS_ERR(omap->utmi_clk[i])) {\n\t\t\t\tr = clk_prepare_enable(omap->utmi_clk[i]);\n\t\t\t\tif (r) {\n\t\t\t\t\tdev_err(dev,\n\t\t\t\t\t \"Can't enable port %d clk : %d\\n\",\n\t\t\t\t\t i, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int usbhs_runtime_suspend(struct device *dev)\n{\n\tstruct usbhs_hcd_omap\t\t*omap = dev_get_drvdata(dev);\n\tstruct usbhs_omap_platform_data\t*pdata = omap->pdata;\n\tint i;\n\n\tdev_dbg(dev, \"usbhs_runtime_suspend\\n\");\n\n\tfor (i = 0; i < omap->nports; i++) {\n\t\tswitch (pdata->port_mode[i]) {\n\t\tcase OMAP_EHCI_PORT_MODE_HSIC:\n\t\t\tif (!IS_ERR(omap->hsic60m_clk[i]))\n\t\t\t\tclk_disable_unprepare(omap->hsic60m_clk[i]);\n\n\t\t\tif (!IS_ERR(omap->hsic480m_clk[i]))\n\t\t\t\tclk_disable_unprepare(omap->hsic480m_clk[i]);\n\t\t\tfallthrough;\t \n\n\t\tcase OMAP_EHCI_PORT_MODE_TLL:\n\t\t\tif (!IS_ERR(omap->utmi_clk[i]))\n\t\t\t\tclk_disable_unprepare(omap->utmi_clk[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!IS_ERR(omap->ehci_logic_fck))\n\t\tclk_disable_unprepare(omap->ehci_logic_fck);\n\n\tomap_tll_disable(pdata);\n\n\treturn 0;\n}\n\nstatic unsigned omap_usbhs_rev1_hostconfig(struct usbhs_hcd_omap *omap,\n\t\t\t\t\t\tunsigned reg)\n{\n\tstruct usbhs_omap_platform_data\t*pdata = omap->pdata;\n\tint i;\n\n\tfor (i = 0; i < omap->nports; i++) {\n\t\tswitch (pdata->port_mode[i]) {\n\t\tcase OMAP_USBHS_PORT_MODE_UNUSED:\n\t\t\treg &= ~(OMAP_UHH_HOSTCONFIG_P1_CONNECT_STATUS << i);\n\t\t\tbreak;\n\t\tcase OMAP_EHCI_PORT_MODE_PHY:\n\t\t\tif (pdata->single_ulpi_bypass)\n\t\t\t\tbreak;\n\n\t\t\tif (i == 0)\n\t\t\t\treg &= ~OMAP_UHH_HOSTCONFIG_ULPI_P1_BYPASS;\n\t\t\telse\n\t\t\t\treg &= ~(OMAP_UHH_HOSTCONFIG_ULPI_P2_BYPASS\n\t\t\t\t\t\t\t\t<< (i-1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (pdata->single_ulpi_bypass)\n\t\t\t\tbreak;\n\n\t\t\tif (i == 0)\n\t\t\t\treg |= OMAP_UHH_HOSTCONFIG_ULPI_P1_BYPASS;\n\t\t\telse\n\t\t\t\treg |= OMAP_UHH_HOSTCONFIG_ULPI_P2_BYPASS\n\t\t\t\t\t\t\t\t<< (i-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pdata->single_ulpi_bypass) {\n\t\t \n\t\treg |= OMAP_UHH_HOSTCONFIG_ULPI_BYPASS;\n\n\t\tfor (i = 0; i < omap->nports; i++) {\n\t\t\tif (is_ehci_phy_mode(pdata->port_mode[i])) {\n\t\t\t\treg &= ~OMAP_UHH_HOSTCONFIG_ULPI_BYPASS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn reg;\n}\n\nstatic unsigned omap_usbhs_rev2_hostconfig(struct usbhs_hcd_omap *omap,\n\t\t\t\t\t\tunsigned reg)\n{\n\tstruct usbhs_omap_platform_data\t*pdata = omap->pdata;\n\tint i;\n\n\tfor (i = 0; i < omap->nports; i++) {\n\t\t \n\t\treg &= ~(OMAP4_P1_MODE_CLEAR << 2 * i);\n\n\t\tif (is_ehci_tll_mode(pdata->port_mode[i]) ||\n\t\t\t\t(is_ohci_port(pdata->port_mode[i])))\n\t\t\treg |= OMAP4_P1_MODE_TLL << 2 * i;\n\t\telse if (is_ehci_hsic_mode(pdata->port_mode[i]))\n\t\t\treg |= OMAP4_P1_MODE_HSIC << 2 * i;\n\t}\n\n\treturn reg;\n}\n\nstatic void omap_usbhs_init(struct device *dev)\n{\n\tstruct usbhs_hcd_omap\t\t*omap = dev_get_drvdata(dev);\n\tunsigned\t\t\treg;\n\n\tdev_dbg(dev, \"starting TI HSUSB Controller\\n\");\n\n\tpm_runtime_get_sync(dev);\n\n\treg = usbhs_read(omap->uhh_base, OMAP_UHH_HOSTCONFIG);\n\t \n\treg |= (OMAP_UHH_HOSTCONFIG_INCR4_BURST_EN\n\t\t\t| OMAP_UHH_HOSTCONFIG_INCR8_BURST_EN\n\t\t\t| OMAP_UHH_HOSTCONFIG_INCR16_BURST_EN);\n\treg |= OMAP4_UHH_HOSTCONFIG_APP_START_CLK;\n\treg &= ~OMAP_UHH_HOSTCONFIG_INCRX_ALIGN_EN;\n\n\tswitch (omap->usbhs_rev) {\n\tcase OMAP_USBHS_REV1:\n\t\treg = omap_usbhs_rev1_hostconfig(omap, reg);\n\t\tbreak;\n\n\tcase OMAP_USBHS_REV2:\n\t\treg = omap_usbhs_rev2_hostconfig(omap, reg);\n\t\tbreak;\n\n\tdefault:\t \n\t\treg = omap_usbhs_rev2_hostconfig(omap, reg);\n\t\tbreak;\n\t}\n\n\tusbhs_write(omap->uhh_base, OMAP_UHH_HOSTCONFIG, reg);\n\tdev_dbg(dev, \"UHH setup done, uhh_hostconfig=%x\\n\", reg);\n\n\tpm_runtime_put_sync(dev);\n}\n\nstatic int usbhs_omap_get_dt_pdata(struct device *dev,\n\t\t\t\t\tstruct usbhs_omap_platform_data *pdata)\n{\n\tint ret, i;\n\tstruct device_node *node = dev->of_node;\n\n\tret = of_property_read_u32(node, \"num-ports\", &pdata->nports);\n\tif (ret)\n\t\tpdata->nports = 0;\n\n\tif (pdata->nports > OMAP3_HS_USB_PORTS) {\n\t\tdev_warn(dev, \"Too many num_ports <%d> in device tree. Max %d\\n\",\n\t\t\t\tpdata->nports, OMAP3_HS_USB_PORTS);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 0; i < OMAP3_HS_USB_PORTS; i++) {\n\t\tchar prop[11];\n\t\tconst char *mode;\n\n\t\tpdata->port_mode[i] = OMAP_USBHS_PORT_MODE_UNUSED;\n\n\t\tsnprintf(prop, sizeof(prop), \"port%d-mode\", i + 1);\n\t\tret = of_property_read_string(node, prop, &mode);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = match_string(port_modes, ARRAY_SIZE(port_modes), mode);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(dev, \"Invalid port%d-mode \\\"%s\\\" in device tree\\n\",\n\t\t\t\t\ti, mode);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tdev_dbg(dev, \"port%d-mode: %s -> %d\\n\", i, mode, ret);\n\t\tpdata->port_mode[i] = ret;\n\t}\n\n\t \n\tpdata->single_ulpi_bypass = of_property_read_bool(node,\n\t\t\t\t\t\t\"single-ulpi-bypass\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id usbhs_child_match_table[] = {\n\t{ .compatible = \"ti,ehci-omap\", },\n\t{ .compatible = \"ti,ohci-omap3\", },\n\t{ }\n};\n\n \nstatic int usbhs_omap_probe(struct platform_device *pdev)\n{\n\tstruct device\t\t\t*dev =  &pdev->dev;\n\tstruct usbhs_omap_platform_data\t*pdata = dev_get_platdata(dev);\n\tstruct usbhs_hcd_omap\t\t*omap;\n\tint\t\t\t\tret = 0;\n\tint\t\t\t\ti;\n\tbool\t\t\t\tneed_logic_fck;\n\n\tif (dev->of_node) {\n\t\t \n\t\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tret = usbhs_omap_get_dt_pdata(dev, pdata);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev->platform_data = pdata;\n\t}\n\n\tif (!pdata) {\n\t\tdev_err(dev, \"Missing platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pdata->nports > OMAP3_HS_USB_PORTS) {\n\t\tdev_info(dev, \"Too many num_ports <%d> in platform_data. Max %d\\n\",\n\t\t\t\tpdata->nports, OMAP3_HS_USB_PORTS);\n\t\treturn -ENODEV;\n\t}\n\n\tomap = devm_kzalloc(dev, sizeof(*omap), GFP_KERNEL);\n\tif (!omap) {\n\t\tdev_err(dev, \"Memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tomap->uhh_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(omap->uhh_base))\n\t\treturn PTR_ERR(omap->uhh_base);\n\n\tomap->pdata = pdata;\n\n\t \n\tomap_tll_init(pdata);\n\n\tpm_runtime_enable(dev);\n\n\tplatform_set_drvdata(pdev, omap);\n\tpm_runtime_get_sync(dev);\n\n\tomap->usbhs_rev = usbhs_read(omap->uhh_base, OMAP_UHH_REVISION);\n\n\t \n\tpm_runtime_put_sync(dev);\n\n\t \n\tif (pdata->nports) {\n\t\tomap->nports = pdata->nports;\n\t} else {\n\t\tswitch (omap->usbhs_rev) {\n\t\tcase OMAP_USBHS_REV1:\n\t\t\tomap->nports = 3;\n\t\t\tbreak;\n\t\tcase OMAP_USBHS_REV2:\n\t\t\tomap->nports = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tomap->nports = OMAP3_HS_USB_PORTS;\n\t\t\tdev_dbg(dev,\n\t\t\t \"USB HOST Rev:0x%x not recognized, assuming %d ports\\n\",\n\t\t\t omap->usbhs_rev, omap->nports);\n\t\t\tbreak;\n\t\t}\n\t\tpdata->nports = omap->nports;\n\t}\n\n\ti = sizeof(struct clk *) * omap->nports;\n\tomap->utmi_clk = devm_kzalloc(dev, i, GFP_KERNEL);\n\tomap->hsic480m_clk = devm_kzalloc(dev, i, GFP_KERNEL);\n\tomap->hsic60m_clk = devm_kzalloc(dev, i, GFP_KERNEL);\n\n\tif (!omap->utmi_clk || !omap->hsic480m_clk || !omap->hsic60m_clk) {\n\t\tdev_err(dev, \"Memory allocation failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_mem;\n\t}\n\n\t \n\tomap->ehci_logic_fck = ERR_PTR(-ENODEV);\n\tomap->init_60m_fclk = ERR_PTR(-ENODEV);\n\tomap->utmi_p1_gfclk = ERR_PTR(-ENODEV);\n\tomap->utmi_p2_gfclk = ERR_PTR(-ENODEV);\n\tomap->xclk60mhsp1_ck = ERR_PTR(-ENODEV);\n\tomap->xclk60mhsp2_ck = ERR_PTR(-ENODEV);\n\n\tfor (i = 0; i < omap->nports; i++) {\n\t\tomap->utmi_clk[i] = ERR_PTR(-ENODEV);\n\t\tomap->hsic480m_clk[i] = ERR_PTR(-ENODEV);\n\t\tomap->hsic60m_clk[i] = ERR_PTR(-ENODEV);\n\t}\n\n\t \n\tif (omap->usbhs_rev == OMAP_USBHS_REV1) {\n\t\tneed_logic_fck = false;\n\t\tfor (i = 0; i < omap->nports; i++) {\n\t\t\tif (is_ehci_phy_mode(pdata->port_mode[i]) ||\n\t\t\t    is_ehci_tll_mode(pdata->port_mode[i]) ||\n\t\t\t    is_ehci_hsic_mode(pdata->port_mode[i]))\n\n\t\t\t\tneed_logic_fck |= true;\n\t\t}\n\n\t\tif (need_logic_fck) {\n\t\t\tomap->ehci_logic_fck = devm_clk_get(dev,\n\t\t\t\t\t\t\t    \"usbhost_120m_fck\");\n\t\t\tif (IS_ERR(omap->ehci_logic_fck)) {\n\t\t\t\tret = PTR_ERR(omap->ehci_logic_fck);\n\t\t\t\tdev_err(dev, \"usbhost_120m_fck failed:%d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto err_mem;\n\t\t\t}\n\t\t}\n\t\tgoto initialize;\n\t}\n\n\t \n\tomap->utmi_p1_gfclk = devm_clk_get(dev, \"utmi_p1_gfclk\");\n\tif (IS_ERR(omap->utmi_p1_gfclk)) {\n\t\tret = PTR_ERR(omap->utmi_p1_gfclk);\n\t\tdev_err(dev, \"utmi_p1_gfclk failed error:%d\\n\", ret);\n\t\tgoto err_mem;\n\t}\n\n\tomap->utmi_p2_gfclk = devm_clk_get(dev, \"utmi_p2_gfclk\");\n\tif (IS_ERR(omap->utmi_p2_gfclk)) {\n\t\tret = PTR_ERR(omap->utmi_p2_gfclk);\n\t\tdev_err(dev, \"utmi_p2_gfclk failed error:%d\\n\", ret);\n\t\tgoto err_mem;\n\t}\n\n\tomap->xclk60mhsp1_ck = devm_clk_get(dev, \"refclk_60m_ext_p1\");\n\tif (IS_ERR(omap->xclk60mhsp1_ck)) {\n\t\tret = PTR_ERR(omap->xclk60mhsp1_ck);\n\t\tdev_err(dev, \"refclk_60m_ext_p1 failed error:%d\\n\", ret);\n\t\tgoto err_mem;\n\t}\n\n\tomap->xclk60mhsp2_ck = devm_clk_get(dev, \"refclk_60m_ext_p2\");\n\tif (IS_ERR(omap->xclk60mhsp2_ck)) {\n\t\tret = PTR_ERR(omap->xclk60mhsp2_ck);\n\t\tdev_err(dev, \"refclk_60m_ext_p2 failed error:%d\\n\", ret);\n\t\tgoto err_mem;\n\t}\n\n\tomap->init_60m_fclk = devm_clk_get(dev, \"refclk_60m_int\");\n\tif (IS_ERR(omap->init_60m_fclk)) {\n\t\tret = PTR_ERR(omap->init_60m_fclk);\n\t\tdev_err(dev, \"refclk_60m_int failed error:%d\\n\", ret);\n\t\tgoto err_mem;\n\t}\n\n\tfor (i = 0; i < omap->nports; i++) {\n\t\tchar clkname[30];\n\n\t\t \n\t\tsnprintf(clkname, sizeof(clkname),\n\t\t\t\t\"usb_host_hs_utmi_p%d_clk\", i + 1);\n\n\t\t \n\t\tomap->utmi_clk[i] = devm_clk_get(dev, clkname);\n\t\tif (IS_ERR(omap->utmi_clk[i])) {\n\t\t\tret = PTR_ERR(omap->utmi_clk[i]);\n\t\t\tdev_err(dev, \"Failed to get clock : %s : %d\\n\",\n\t\t\t\tclkname, ret);\n\t\t\tgoto err_mem;\n\t\t}\n\n\t\tsnprintf(clkname, sizeof(clkname),\n\t\t\t\t\"usb_host_hs_hsic480m_p%d_clk\", i + 1);\n\t\tomap->hsic480m_clk[i] = devm_clk_get(dev, clkname);\n\t\tif (IS_ERR(omap->hsic480m_clk[i])) {\n\t\t\tret = PTR_ERR(omap->hsic480m_clk[i]);\n\t\t\tdev_err(dev, \"Failed to get clock : %s : %d\\n\",\n\t\t\t\tclkname, ret);\n\t\t\tgoto err_mem;\n\t\t}\n\n\t\tsnprintf(clkname, sizeof(clkname),\n\t\t\t\t\"usb_host_hs_hsic60m_p%d_clk\", i + 1);\n\t\tomap->hsic60m_clk[i] = devm_clk_get(dev, clkname);\n\t\tif (IS_ERR(omap->hsic60m_clk[i])) {\n\t\t\tret = PTR_ERR(omap->hsic60m_clk[i]);\n\t\t\tdev_err(dev, \"Failed to get clock : %s : %d\\n\",\n\t\t\t\tclkname, ret);\n\t\t\tgoto err_mem;\n\t\t}\n\t}\n\n\tif (is_ehci_phy_mode(pdata->port_mode[0])) {\n\t\tret = clk_set_parent(omap->utmi_p1_gfclk,\n\t\t\t\t\tomap->xclk60mhsp1_ck);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"xclk60mhsp1_ck set parent failed: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_mem;\n\t\t}\n\t} else if (is_ehci_tll_mode(pdata->port_mode[0])) {\n\t\tret = clk_set_parent(omap->utmi_p1_gfclk,\n\t\t\t\t\tomap->init_60m_fclk);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"P0 init_60m_fclk set parent failed: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_mem;\n\t\t}\n\t}\n\n\tif (is_ehci_phy_mode(pdata->port_mode[1])) {\n\t\tret = clk_set_parent(omap->utmi_p2_gfclk,\n\t\t\t\t\tomap->xclk60mhsp2_ck);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"xclk60mhsp2_ck set parent failed: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_mem;\n\t\t}\n\t} else if (is_ehci_tll_mode(pdata->port_mode[1])) {\n\t\tret = clk_set_parent(omap->utmi_p2_gfclk,\n\t\t\t\t\t\tomap->init_60m_fclk);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"P1 init_60m_fclk set parent failed: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_mem;\n\t\t}\n\t}\n\ninitialize:\n\tomap_usbhs_init(dev);\n\n\tif (dev->of_node) {\n\t\tret = of_platform_populate(dev->of_node,\n\t\t\t\tusbhs_child_match_table, NULL, dev);\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to create DT children: %d\\n\", ret);\n\t\t\tgoto err_mem;\n\t\t}\n\n\t} else {\n\t\tret = omap_usbhs_alloc_children(pdev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"omap_usbhs_alloc_children failed: %d\\n\",\n\t\t\t\t\t\tret);\n\t\t\tgoto err_mem;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_mem:\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic int usbhs_omap_remove_child(struct device *dev, void *data)\n{\n\tdev_info(dev, \"unregistering\\n\");\n\tplatform_device_unregister(to_platform_device(dev));\n\treturn 0;\n}\n\n \nstatic int usbhs_omap_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n\n\t \n\tdevice_for_each_child(&pdev->dev, NULL, usbhs_omap_remove_child);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops usbhsomap_dev_pm_ops = {\n\t.runtime_suspend\t= usbhs_runtime_suspend,\n\t.runtime_resume\t\t= usbhs_runtime_resume,\n};\n\nstatic const struct of_device_id usbhs_omap_dt_ids[] = {\n\t{ .compatible = \"ti,usbhs-host\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, usbhs_omap_dt_ids);\n\n\nstatic struct platform_driver usbhs_omap_driver = {\n\t.driver = {\n\t\t.name\t\t= usbhs_driver_name,\n\t\t.pm\t\t= &usbhsomap_dev_pm_ops,\n\t\t.of_match_table = usbhs_omap_dt_ids,\n\t},\n\t.probe\t\t= usbhs_omap_probe,\n\t.remove\t\t= usbhs_omap_remove,\n};\n\nMODULE_AUTHOR(\"Keshava Munegowda <keshava_mgowda@ti.com>\");\nMODULE_AUTHOR(\"Roger Quadros <rogerq@ti.com>\");\nMODULE_ALIAS(\"platform:\" USBHS_DRIVER_NAME);\nMODULE_DESCRIPTION(\"usb host common core driver for omap EHCI and OHCI\");\n\nstatic int omap_usbhs_drvinit(void)\n{\n\treturn platform_driver_register(&usbhs_omap_driver);\n}\n\n \nfs_initcall_sync(omap_usbhs_drvinit);\n\nstatic void omap_usbhs_drvexit(void)\n{\n\tplatform_driver_unregister(&usbhs_omap_driver);\n}\nmodule_exit(omap_usbhs_drvexit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}