{
  "module_name": "tps65217.c",
  "hash_id": "db464d63488ea2960ee41357151b2a1d18bdc09f401719cbd1b27aa9e61dc221",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tps65217.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <linux/mfd/core.h>\n#include <linux/mfd/tps65217.h>\n\nstatic const struct resource charger_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(TPS65217_IRQ_AC, \"AC\"),\n\tDEFINE_RES_IRQ_NAMED(TPS65217_IRQ_USB, \"USB\"),\n};\n\nstatic const struct resource pb_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(TPS65217_IRQ_PB, \"PB\"),\n};\n\nstatic void tps65217_irq_lock(struct irq_data *data)\n{\n\tstruct tps65217 *tps = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&tps->irq_lock);\n}\n\nstatic void tps65217_irq_sync_unlock(struct irq_data *data)\n{\n\tstruct tps65217 *tps = irq_data_get_irq_chip_data(data);\n\tint ret;\n\n\tret = tps65217_set_bits(tps, TPS65217_REG_INT, TPS65217_INT_MASK,\n\t\t\t\ttps->irq_mask, TPS65217_PROTECT_NONE);\n\tif (ret != 0)\n\t\tdev_err(tps->dev, \"Failed to sync IRQ masks\\n\");\n\n\tmutex_unlock(&tps->irq_lock);\n}\n\nstatic void tps65217_irq_enable(struct irq_data *data)\n{\n\tstruct tps65217 *tps = irq_data_get_irq_chip_data(data);\n\tu8 mask = BIT(data->hwirq) << TPS65217_INT_SHIFT;\n\n\ttps->irq_mask &= ~mask;\n}\n\nstatic void tps65217_irq_disable(struct irq_data *data)\n{\n\tstruct tps65217 *tps = irq_data_get_irq_chip_data(data);\n\tu8 mask = BIT(data->hwirq) << TPS65217_INT_SHIFT;\n\n\ttps->irq_mask |= mask;\n}\n\nstatic struct irq_chip tps65217_irq_chip = {\n\t.name\t\t\t= \"tps65217\",\n\t.irq_bus_lock\t\t= tps65217_irq_lock,\n\t.irq_bus_sync_unlock\t= tps65217_irq_sync_unlock,\n\t.irq_enable\t\t= tps65217_irq_enable,\n\t.irq_disable\t\t= tps65217_irq_disable,\n};\n\nstatic struct mfd_cell tps65217s[] = {\n\t{\n\t\t.name = \"tps65217-pmic\",\n\t\t.of_compatible = \"ti,tps65217-pmic\",\n\t},\n\t{\n\t\t.name = \"tps65217-bl\",\n\t\t.of_compatible = \"ti,tps65217-bl\",\n\t},\n\t{\n\t\t.name = \"tps65217-charger\",\n\t\t.num_resources = ARRAY_SIZE(charger_resources),\n\t\t.resources = charger_resources,\n\t\t.of_compatible = \"ti,tps65217-charger\",\n\t},\n\t{\n\t\t.name = \"tps65217-pwrbutton\",\n\t\t.num_resources = ARRAY_SIZE(pb_resources),\n\t\t.resources = pb_resources,\n\t\t.of_compatible = \"ti,tps65217-pwrbutton\",\n\t},\n};\n\nstatic irqreturn_t tps65217_irq_thread(int irq, void *data)\n{\n\tstruct tps65217 *tps = data;\n\tunsigned int status;\n\tbool handled = false;\n\tint i;\n\tint ret;\n\n\tret = tps65217_reg_read(tps, TPS65217_REG_INT, &status);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev, \"Failed to read IRQ status: %d\\n\",\n\t\t\tret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tfor (i = 0; i < TPS65217_NUM_IRQ; i++) {\n\t\tif (status & BIT(i)) {\n\t\t\thandle_nested_irq(irq_find_mapping(tps->irq_domain, i));\n\t\t\thandled = true;\n\t\t}\n\t}\n\n\tif (handled)\n\t\treturn IRQ_HANDLED;\n\n\treturn IRQ_NONE;\n}\n\nstatic int tps65217_irq_map(struct irq_domain *h, unsigned int virq,\n\t\t\tirq_hw_number_t hw)\n{\n\tstruct tps65217 *tps = h->host_data;\n\n\tirq_set_chip_data(virq, tps);\n\tirq_set_chip_and_handler(virq, &tps65217_irq_chip, handle_edge_irq);\n\tirq_set_nested_thread(virq, 1);\n\tirq_set_parent(virq, tps->irq);\n\tirq_set_noprobe(virq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops tps65217_irq_domain_ops = {\n\t.map = tps65217_irq_map,\n};\n\nstatic int tps65217_irq_init(struct tps65217 *tps, int irq)\n{\n\tint ret;\n\n\tmutex_init(&tps->irq_lock);\n\ttps->irq = irq;\n\n\t \n\ttps->irq_mask = TPS65217_INT_MASK;\n\ttps65217_set_bits(tps, TPS65217_REG_INT, TPS65217_INT_MASK,\n\t\t\t  TPS65217_INT_MASK, TPS65217_PROTECT_NONE);\n\n\ttps->irq_domain = irq_domain_add_linear(tps->dev->of_node,\n\t\tTPS65217_NUM_IRQ, &tps65217_irq_domain_ops, tps);\n\tif (!tps->irq_domain) {\n\t\tdev_err(tps->dev, \"Could not create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = devm_request_threaded_irq(tps->dev, irq, NULL,\n\t\t\t\t\ttps65217_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\t\"tps65217-irq\", tps);\n\tif (ret) {\n\t\tdev_err(tps->dev, \"Failed to request IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\treturn ret;\n\t}\n\n\tenable_irq_wake(irq);\n\n\treturn 0;\n}\n\n \nint tps65217_reg_read(struct tps65217 *tps, unsigned int reg,\n\t\t\tunsigned int *val)\n{\n\treturn regmap_read(tps->regmap, reg, val);\n}\nEXPORT_SYMBOL_GPL(tps65217_reg_read);\n\n \nint tps65217_reg_write(struct tps65217 *tps, unsigned int reg,\n\t\t\tunsigned int val, unsigned int level)\n{\n\tint ret;\n\tunsigned int xor_reg_val;\n\n\tswitch (level) {\n\tcase TPS65217_PROTECT_NONE:\n\t\treturn regmap_write(tps->regmap, reg, val);\n\tcase TPS65217_PROTECT_L1:\n\t\txor_reg_val = reg ^ TPS65217_PASSWORD_REGS_UNLOCK;\n\t\tret = regmap_write(tps->regmap, TPS65217_REG_PASSWORD,\n\t\t\t\t\t\t\txor_reg_val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn regmap_write(tps->regmap, reg, val);\n\tcase TPS65217_PROTECT_L2:\n\t\txor_reg_val = reg ^ TPS65217_PASSWORD_REGS_UNLOCK;\n\t\tret = regmap_write(tps->regmap, TPS65217_REG_PASSWORD,\n\t\t\t\t\t\t\txor_reg_val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_write(tps->regmap, reg, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_write(tps->regmap, TPS65217_REG_PASSWORD,\n\t\t\t\t\t\t\txor_reg_val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn regmap_write(tps->regmap, reg, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL_GPL(tps65217_reg_write);\n\n \nstatic int tps65217_update_bits(struct tps65217 *tps, unsigned int reg,\n\t\tunsigned int mask, unsigned int val, unsigned int level)\n{\n\tint ret;\n\tunsigned int data;\n\n\tret = tps65217_reg_read(tps, reg, &data);\n\tif (ret) {\n\t\tdev_err(tps->dev, \"Read from reg 0x%x failed\\n\", reg);\n\t\treturn ret;\n\t}\n\n\tdata &= ~mask;\n\tdata |= val & mask;\n\n\tret = tps65217_reg_write(tps, reg, data, level);\n\tif (ret)\n\t\tdev_err(tps->dev, \"Write for reg 0x%x failed\\n\", reg);\n\n\treturn ret;\n}\n\nint tps65217_set_bits(struct tps65217 *tps, unsigned int reg,\n\t\tunsigned int mask, unsigned int val, unsigned int level)\n{\n\treturn tps65217_update_bits(tps, reg, mask, val, level);\n}\nEXPORT_SYMBOL_GPL(tps65217_set_bits);\n\nint tps65217_clear_bits(struct tps65217 *tps, unsigned int reg,\n\t\tunsigned int mask, unsigned int level)\n{\n\treturn tps65217_update_bits(tps, reg, mask, 0, level);\n}\nEXPORT_SYMBOL_GPL(tps65217_clear_bits);\n\nstatic bool tps65217_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TPS65217_REG_INT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config tps65217_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = TPS65217_REG_MAX,\n\t.volatile_reg = tps65217_volatile_reg,\n};\n\nstatic const struct of_device_id tps65217_of_match[] = {\n\t{ .compatible = \"ti,tps65217\"},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, tps65217_of_match);\n\nstatic int tps65217_probe(struct i2c_client *client)\n{\n\tstruct tps65217 *tps;\n\tunsigned int version;\n\tbool status_off = false;\n\tint ret;\n\n\tstatus_off = of_property_read_bool(client->dev.of_node,\n\t\t\t\t\t   \"ti,pmic-shutdown-controller\");\n\n\ttps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, tps);\n\ttps->dev = &client->dev;\n\n\ttps->regmap = devm_regmap_init_i2c(client, &tps65217_regmap_config);\n\tif (IS_ERR(tps->regmap)) {\n\t\tret = PTR_ERR(tps->regmap);\n\t\tdev_err(tps->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (client->irq) {\n\t\ttps65217_irq_init(tps, client->irq);\n\t} else {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(tps65217s); i++)\n\t\t\ttps65217s[i].num_resources = 0;\n\t}\n\n\tret = devm_mfd_add_devices(tps->dev, -1, tps65217s,\n\t\t\t\t   ARRAY_SIZE(tps65217s), NULL, 0,\n\t\t\t\t   tps->irq_domain);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev, \"mfd_add_devices failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = tps65217_reg_read(tps, TPS65217_REG_CHIPID, &version);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev, \"Failed to read revision register: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (status_off) {\n\t\tret = tps65217_set_bits(tps, TPS65217_REG_STATUS,\n\t\t\t\tTPS65217_STATUS_OFF, TPS65217_STATUS_OFF,\n\t\t\t\tTPS65217_PROTECT_NONE);\n\t\tif (ret)\n\t\t\tdev_warn(tps->dev, \"unable to set the status OFF\\n\");\n\t}\n\n\tdev_info(tps->dev, \"TPS65217 ID %#x version 1.%d\\n\",\n\t\t\t(version & TPS65217_CHIPID_CHIP_MASK) >> 4,\n\t\t\tversion & TPS65217_CHIPID_REV_MASK);\n\n\treturn 0;\n}\n\nstatic void tps65217_remove(struct i2c_client *client)\n{\n\tstruct tps65217 *tps = i2c_get_clientdata(client);\n\tunsigned int virq;\n\tint i;\n\n\tfor (i = 0; i < TPS65217_NUM_IRQ; i++) {\n\t\tvirq = irq_find_mapping(tps->irq_domain, i);\n\t\tif (virq)\n\t\t\tirq_dispose_mapping(virq);\n\t}\n\n\tirq_domain_remove(tps->irq_domain);\n\ttps->irq_domain = NULL;\n}\n\nstatic const struct i2c_device_id tps65217_id_table[] = {\n\t{\"tps65217\", TPS65217},\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, tps65217_id_table);\n\nstatic struct i2c_driver tps65217_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"tps65217\",\n\t\t.of_match_table = tps65217_of_match,\n\t},\n\t.id_table\t= tps65217_id_table,\n\t.probe\t\t= tps65217_probe,\n\t.remove\t\t= tps65217_remove,\n};\n\nstatic int __init tps65217_init(void)\n{\n\treturn i2c_add_driver(&tps65217_driver);\n}\nsubsys_initcall(tps65217_init);\n\nstatic void __exit tps65217_exit(void)\n{\n\ti2c_del_driver(&tps65217_driver);\n}\nmodule_exit(tps65217_exit);\n\nMODULE_AUTHOR(\"AnilKumar Ch <anilkumar@ti.com>\");\nMODULE_DESCRIPTION(\"TPS65217 chip family multi-function driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}