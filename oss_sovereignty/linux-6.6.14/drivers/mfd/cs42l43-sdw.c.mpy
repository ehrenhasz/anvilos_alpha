{
  "module_name": "cs42l43-sdw.c",
  "hash_id": "f49fd64cea8d777d7ca93ee2b3418c8087057afbfc663233e467b93071dc6d16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/cs42l43-sdw.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/mfd/cs42l43-regs.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw_type.h>\n\n#include \"cs42l43.h\"\n\n#define CS42L43_SDW_PORT(port, chans) { \\\n\t.num = port, \\\n\t.max_ch = chans, \\\n\t.type = SDW_DPN_FULL, \\\n\t.max_word = 24, \\\n}\n\nstatic const struct regmap_config cs42l43_sdw_regmap = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.reg_format_endian\t= REGMAP_ENDIAN_LITTLE,\n\t.val_format_endian\t= REGMAP_ENDIAN_LITTLE,\n\n\t.max_register\t\t= CS42L43_MCU_RAM_MAX,\n\t.readable_reg\t\t= cs42l43_readable_register,\n\t.volatile_reg\t\t= cs42l43_volatile_register,\n\t.precious_reg\t\t= cs42l43_precious_register,\n\n\t.cache_type\t\t= REGCACHE_MAPLE,\n\t.reg_defaults\t\t= cs42l43_reg_default,\n\t.num_reg_defaults\t= ARRAY_SIZE(cs42l43_reg_default),\n};\n\nstatic const struct sdw_dpn_prop cs42l43_src_port_props[] = {\n\tCS42L43_SDW_PORT(1, 4),\n\tCS42L43_SDW_PORT(2, 2),\n\tCS42L43_SDW_PORT(3, 2),\n\tCS42L43_SDW_PORT(4, 2),\n};\n\nstatic const struct sdw_dpn_prop cs42l43_sink_port_props[] = {\n\tCS42L43_SDW_PORT(5, 2),\n\tCS42L43_SDW_PORT(6, 2),\n\tCS42L43_SDW_PORT(7, 2),\n};\n\nstatic int cs42l43_read_prop(struct sdw_slave *sdw)\n{\n\tstruct sdw_slave_prop *prop = &sdw->prop;\n\tstruct device *dev = &sdw->dev;\n\tint i;\n\n\tprop->use_domain_irq = true;\n\tprop->paging_support = true;\n\tprop->wake_capable = true;\n\tprop->quirks = SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY;\n\tprop->scp_int1_mask = SDW_SCP_INT1_BUS_CLASH | SDW_SCP_INT1_PARITY |\n\t\t\t      SDW_SCP_INT1_IMPL_DEF;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs42l43_src_port_props); i++)\n\t\tprop->source_ports |= BIT(cs42l43_src_port_props[i].num);\n\n\tprop->src_dpn_prop = devm_kmemdup(dev, cs42l43_src_port_props,\n\t\t\t\t\t  sizeof(cs42l43_src_port_props), GFP_KERNEL);\n\tif (!prop->src_dpn_prop)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs42l43_sink_port_props); i++)\n\t\tprop->sink_ports |= BIT(cs42l43_sink_port_props[i].num);\n\n\tprop->sink_dpn_prop = devm_kmemdup(dev, cs42l43_sink_port_props,\n\t\t\t\t\t   sizeof(cs42l43_sink_port_props), GFP_KERNEL);\n\tif (!prop->sink_dpn_prop)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int cs42l43_sdw_update_status(struct sdw_slave *sdw, enum sdw_slave_status status)\n{\n\tstruct cs42l43 *cs42l43 = dev_get_drvdata(&sdw->dev);\n\n\tswitch (status) {\n\tcase SDW_SLAVE_ATTACHED:\n\t\tdev_dbg(cs42l43->dev, \"Device attach\\n\");\n\n\t\tsdw_write_no_pm(sdw, CS42L43_GEN_INT_MASK_1,\n\t\t\t\tCS42L43_INT_STAT_GEN1_MASK);\n\n\t\tcs42l43->attached = true;\n\n\t\tcomplete(&cs42l43->device_attach);\n\t\tbreak;\n\tcase SDW_SLAVE_UNATTACHED:\n\t\tdev_dbg(cs42l43->dev, \"Device detach\\n\");\n\n\t\tcs42l43->attached = false;\n\n\t\treinit_completion(&cs42l43->device_attach);\n\t\tcomplete(&cs42l43->device_detach);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs42l43_sdw_interrupt(struct sdw_slave *sdw,\n\t\t\t\t struct sdw_slave_intr_status *status)\n{\n\t \n\tsdw_read_no_pm(sdw, CS42L43_GEN_INT_STAT_1);\n\tsdw_write_no_pm(sdw, CS42L43_GEN_INT_STAT_1, CS42L43_INT_STAT_GEN1_MASK);\n\n\treturn 0;\n}\n\nstatic int cs42l43_sdw_bus_config(struct sdw_slave *sdw,\n\t\t\t\t  struct sdw_bus_params *params)\n{\n\tstruct cs42l43 *cs42l43 = dev_get_drvdata(&sdw->dev);\n\tint ret = 0;\n\n\tmutex_lock(&cs42l43->pll_lock);\n\n\tif (cs42l43->sdw_freq != params->curr_dr_freq / 2) {\n\t\tif (cs42l43->sdw_pll_active) {\n\t\t\tdev_err(cs42l43->dev,\n\t\t\t\t\"PLL active can't change SoundWire bus clock\\n\");\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tcs42l43->sdw_freq = params->curr_dr_freq / 2;\n\t\t}\n\t}\n\n\tmutex_unlock(&cs42l43->pll_lock);\n\n\treturn ret;\n}\n\nstatic const struct sdw_slave_ops cs42l43_sdw_ops = {\n\t.read_prop\t\t= cs42l43_read_prop,\n\t.update_status\t\t= cs42l43_sdw_update_status,\n\t.interrupt_callback\t= cs42l43_sdw_interrupt,\n\t.bus_config\t\t= cs42l43_sdw_bus_config,\n};\n\nstatic int cs42l43_sdw_probe(struct sdw_slave *sdw, const struct sdw_device_id *id)\n{\n\tstruct cs42l43 *cs42l43;\n\tstruct device *dev = &sdw->dev;\n\tint ret;\n\n\tcs42l43 = devm_kzalloc(dev, sizeof(*cs42l43), GFP_KERNEL);\n\tif (!cs42l43)\n\t\treturn -ENOMEM;\n\n\tcs42l43->dev = dev;\n\tcs42l43->sdw = sdw;\n\n\tcs42l43->regmap = devm_regmap_init_sdw(sdw, &cs42l43_sdw_regmap);\n\tif (IS_ERR(cs42l43->regmap)) {\n\t\tret = PTR_ERR(cs42l43->regmap);\n\t\tdev_err(cs42l43->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn cs42l43_dev_probe(cs42l43);\n}\n\nstatic int cs42l43_sdw_remove(struct sdw_slave *sdw)\n{\n\tstruct cs42l43 *cs42l43 = dev_get_drvdata(&sdw->dev);\n\n\tcs42l43_dev_remove(cs42l43);\n\n\treturn 0;\n}\n\nstatic const struct sdw_device_id cs42l43_sdw_id[] = {\n\tSDW_SLAVE_ENTRY(0x01FA, 0x4243, 0),\n\t{}\n};\nMODULE_DEVICE_TABLE(sdw, cs42l43_sdw_id);\n\nstatic struct sdw_driver cs42l43_sdw_driver = {\n\t.driver = {\n\t\t.name\t\t= \"cs42l43\",\n\t\t.pm\t\t= pm_ptr(&cs42l43_pm_ops),\n\t},\n\n\t.probe\t\t= cs42l43_sdw_probe,\n\t.remove\t\t= cs42l43_sdw_remove,\n\t.id_table\t= cs42l43_sdw_id,\n\t.ops\t\t= &cs42l43_sdw_ops,\n};\nmodule_sdw_driver(cs42l43_sdw_driver);\n\nMODULE_IMPORT_NS(MFD_CS42L43);\n\nMODULE_DESCRIPTION(\"CS42L43 SoundWire Driver\");\nMODULE_AUTHOR(\"Lucas Tanure <tanureal@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}