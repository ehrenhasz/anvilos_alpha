{
  "module_name": "rsmu_spi.c",
  "hash_id": "af1411de089b410f73c9de7acce3a30f2ed865edcf2301aae7e901bac23a3f37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rsmu_spi.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/rsmu.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n\n#include \"rsmu.h\"\n\n#define\tRSMU_CM_PAGE_ADDR\t\t0x7C\n#define\tRSMU_SABRE_PAGE_ADDR\t\t0x7F\n#define\tRSMU_PAGE_MASK\t\t\t0xFFFFFF80\n#define\tRSMU_ADDR_MASK\t\t\t0x7F\n\nstatic int rsmu_read_device(struct rsmu_ddata *rsmu, u8 reg, u8 *buf, u16 bytes)\n{\n\tstruct spi_device *client = to_spi_device(rsmu->dev);\n\tstruct spi_transfer xfer = {0};\n\tstruct spi_message msg;\n\tu8 cmd[RSMU_MAX_READ_COUNT + 1] = {0};\n\tu8 rsp[RSMU_MAX_READ_COUNT + 1] = {0};\n\tint ret;\n\n\tif (bytes > RSMU_MAX_READ_COUNT)\n\t\treturn -EINVAL;\n\n\tcmd[0] = reg | 0x80;\n\txfer.rx_buf = rsp;\n\txfer.len = bytes + 1;\n\txfer.tx_buf = cmd;\n\txfer.bits_per_word = client->bits_per_word;\n\txfer.speed_hz = client->max_speed_hz;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer, &msg);\n\n\t \n\tret = spi_sync(client, &msg);\n\tif (ret >= 0)\n\t\tmemcpy(buf, &rsp[1], xfer.len-1);\n\n\treturn ret;\n}\n\nstatic int rsmu_write_device(struct rsmu_ddata *rsmu, u8 reg, u8 *buf, u16 bytes)\n{\n\tstruct spi_device *client = to_spi_device(rsmu->dev);\n\tstruct spi_transfer xfer = {0};\n\tstruct spi_message msg;\n\tu8 cmd[RSMU_MAX_WRITE_COUNT + 1] = {0};\n\n\tif (bytes > RSMU_MAX_WRITE_COUNT)\n\t\treturn -EINVAL;\n\n\tcmd[0] = reg;\n\tmemcpy(&cmd[1], buf, bytes);\n\n\txfer.len = bytes + 1;\n\txfer.tx_buf = cmd;\n\txfer.bits_per_word = client->bits_per_word;\n\txfer.speed_hz = client->max_speed_hz;\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer, &msg);\n\n\treturn  spi_sync(client, &msg);\n}\n\n \nstatic int rsmu_write_page_register(struct rsmu_ddata *rsmu, u32 reg)\n{\n\tu8 page_reg;\n\tu8 buf[4];\n\tu16 bytes;\n\tu32 page;\n\tint err;\n\n\tswitch (rsmu->type) {\n\tcase RSMU_CM:\n\t\t \n\t\tif (reg < RSMU_CM_SCSR_BASE)\n\t\t\treturn 0;\n\t\tpage_reg = RSMU_CM_PAGE_ADDR;\n\t\tpage = reg & RSMU_PAGE_MASK;\n\t\tbuf[0] = (u8)(page & 0xff);\n\t\tbuf[1] = (u8)((page >> 8) & 0xff);\n\t\tbuf[2] = (u8)((page >> 16) & 0xff);\n\t\tbuf[3] = (u8)((page >> 24) & 0xff);\n\t\tbytes = 4;\n\t\tbreak;\n\tcase RSMU_SABRE:\n\t\t \n\t\tif ((reg & RSMU_ADDR_MASK) == RSMU_ADDR_MASK)\n\t\t\treturn 0;\n\t\tpage_reg = RSMU_SABRE_PAGE_ADDR;\n\t\tpage = reg & RSMU_PAGE_MASK;\n\t\t \n\t\tbuf[0] = (u8)((page >> 7) & 0x7);\n\t\tbytes = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rsmu->dev, \"Unsupported RSMU device type: %d\\n\", rsmu->type);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (rsmu->page == page)\n\t\treturn 0;\n\n\terr = rsmu_write_device(rsmu, page_reg, buf, bytes);\n\tif (err)\n\t\tdev_err(rsmu->dev, \"Failed to set page offset 0x%x\\n\", page);\n\telse\n\t\t \n\t\trsmu->page = page;\n\n\treturn err;\n}\n\nstatic int rsmu_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct rsmu_ddata *rsmu = spi_get_drvdata((struct spi_device *)context);\n\tu8 addr = (u8)(reg & RSMU_ADDR_MASK);\n\tint err;\n\n\terr = rsmu_write_page_register(rsmu, reg);\n\tif (err)\n\t\treturn err;\n\n\terr = rsmu_read_device(rsmu, addr, (u8 *)val, 1);\n\tif (err)\n\t\tdev_err(rsmu->dev, \"Failed to read offset address 0x%x\\n\", addr);\n\n\treturn err;\n}\n\nstatic int rsmu_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct rsmu_ddata *rsmu = spi_get_drvdata((struct spi_device *)context);\n\tu8 addr = (u8)(reg & RSMU_ADDR_MASK);\n\tu8 data = (u8)val;\n\tint err;\n\n\terr = rsmu_write_page_register(rsmu, reg);\n\tif (err)\n\t\treturn err;\n\n\terr = rsmu_write_device(rsmu, addr, &data, 1);\n\tif (err)\n\t\tdev_err(rsmu->dev,\n\t\t\t\"Failed to write offset address 0x%x\\n\", addr);\n\n\treturn err;\n}\n\nstatic const struct regmap_config rsmu_cm_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.max_register = 0x20120000,\n\t.reg_read = rsmu_reg_read,\n\t.reg_write = rsmu_reg_write,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic const struct regmap_config rsmu_sabre_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = 0x400,\n\t.reg_read = rsmu_reg_read,\n\t.reg_write = rsmu_reg_write,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic int rsmu_spi_probe(struct spi_device *client)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(client);\n\tconst struct regmap_config *cfg;\n\tstruct rsmu_ddata *rsmu;\n\tint ret;\n\n\trsmu = devm_kzalloc(&client->dev, sizeof(*rsmu), GFP_KERNEL);\n\tif (!rsmu)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(client, rsmu);\n\n\trsmu->dev = &client->dev;\n\trsmu->type = (enum rsmu_type)id->driver_data;\n\n\t \n\tswitch (rsmu->type) {\n\tcase RSMU_CM:\n\t\tcfg = &rsmu_cm_regmap_config;\n\t\tbreak;\n\tcase RSMU_SABRE:\n\t\tcfg = &rsmu_sabre_regmap_config;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rsmu->dev, \"Unsupported RSMU device type: %d\\n\", rsmu->type);\n\t\treturn -ENODEV;\n\t}\n\n\trsmu->regmap = devm_regmap_init(&client->dev, NULL, client, cfg);\n\tif (IS_ERR(rsmu->regmap)) {\n\t\tret = PTR_ERR(rsmu->regmap);\n\t\tdev_err(rsmu->dev, \"Failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn rsmu_core_init(rsmu);\n}\n\nstatic void rsmu_spi_remove(struct spi_device *client)\n{\n\tstruct rsmu_ddata *rsmu = spi_get_drvdata(client);\n\n\trsmu_core_exit(rsmu);\n}\n\nstatic const struct spi_device_id rsmu_spi_id[] = {\n\t{ \"8a34000\",  RSMU_CM },\n\t{ \"8a34001\",  RSMU_CM },\n\t{ \"82p33810\", RSMU_SABRE },\n\t{ \"82p33811\", RSMU_SABRE },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, rsmu_spi_id);\n\nstatic const struct of_device_id rsmu_spi_of_match[] = {\n\t{ .compatible = \"idt,8a34000\",  .data = (void *)RSMU_CM },\n\t{ .compatible = \"idt,8a34001\",  .data = (void *)RSMU_CM },\n\t{ .compatible = \"idt,82p33810\", .data = (void *)RSMU_SABRE },\n\t{ .compatible = \"idt,82p33811\", .data = (void *)RSMU_SABRE },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rsmu_spi_of_match);\n\nstatic struct spi_driver rsmu_spi_driver = {\n\t.driver = {\n\t\t.name = \"rsmu-spi\",\n\t\t.of_match_table = rsmu_spi_of_match,\n\t},\n\t.probe = rsmu_spi_probe,\n\t.remove\t= rsmu_spi_remove,\n\t.id_table = rsmu_spi_id,\n};\n\nstatic int __init rsmu_spi_init(void)\n{\n\treturn spi_register_driver(&rsmu_spi_driver);\n}\nsubsys_initcall(rsmu_spi_init);\n\nstatic void __exit rsmu_spi_exit(void)\n{\n\tspi_unregister_driver(&rsmu_spi_driver);\n}\nmodule_exit(rsmu_spi_exit);\n\nMODULE_DESCRIPTION(\"Renesas SMU SPI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}