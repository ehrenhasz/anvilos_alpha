{
  "module_name": "max77620.c",
  "hash_id": "6f6d403c050cee31d0f787180e17f2c8dc567ff281e3581e4058d0e1768e0040",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/max77620.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/max77620.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\nstatic struct max77620_chip *max77620_scratch;\n\nstatic const struct resource gpio_resources[] = {\n\tDEFINE_RES_IRQ(MAX77620_IRQ_TOP_GPIO),\n};\n\nstatic const struct resource power_resources[] = {\n\tDEFINE_RES_IRQ(MAX77620_IRQ_LBT_MBATLOW),\n};\n\nstatic const struct resource rtc_resources[] = {\n\tDEFINE_RES_IRQ(MAX77620_IRQ_TOP_RTC),\n};\n\nstatic const struct resource thermal_resources[] = {\n\tDEFINE_RES_IRQ(MAX77620_IRQ_LBT_TJALRM1),\n\tDEFINE_RES_IRQ(MAX77620_IRQ_LBT_TJALRM2),\n};\n\nstatic const struct regmap_irq max77620_top_irqs[] = {\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_GLBL, 0, MAX77620_IRQ_TOP_GLBL_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_SD, 0, MAX77620_IRQ_TOP_SD_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_LDO, 0, MAX77620_IRQ_TOP_LDO_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_GPIO, 0, MAX77620_IRQ_TOP_GPIO_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_RTC, 0, MAX77620_IRQ_TOP_RTC_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_32K, 0, MAX77620_IRQ_TOP_32K_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_ONOFF, 0, MAX77620_IRQ_TOP_ONOFF_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_LBT_MBATLOW, 1, MAX77620_IRQ_LBM_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_LBT_TJALRM1, 1, MAX77620_IRQ_TJALRM1_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_LBT_TJALRM2, 1, MAX77620_IRQ_TJALRM2_MASK),\n};\n\nstatic const struct mfd_cell max77620_children[] = {\n\t{ .name = \"max77620-pinctrl\", },\n\t{ .name = \"max77620-clock\", },\n\t{ .name = \"max77620-pmic\", },\n\t{ .name = \"max77620-watchdog\", },\n\t{\n\t\t.name = \"max77620-gpio\",\n\t\t.resources = gpio_resources,\n\t\t.num_resources = ARRAY_SIZE(gpio_resources),\n\t}, {\n\t\t.name = \"max77620-rtc\",\n\t\t.resources = rtc_resources,\n\t\t.num_resources = ARRAY_SIZE(rtc_resources),\n\t}, {\n\t\t.name = \"max77620-power\",\n\t\t.resources = power_resources,\n\t\t.num_resources = ARRAY_SIZE(power_resources),\n\t}, {\n\t\t.name = \"max77620-thermal\",\n\t\t.resources = thermal_resources,\n\t\t.num_resources = ARRAY_SIZE(thermal_resources),\n\t},\n};\n\nstatic const struct mfd_cell max20024_children[] = {\n\t{ .name = \"max20024-pinctrl\", },\n\t{ .name = \"max77620-clock\", },\n\t{ .name = \"max20024-pmic\", },\n\t{ .name = \"max77620-watchdog\", },\n\t{\n\t\t.name = \"max77620-gpio\",\n\t\t.resources = gpio_resources,\n\t\t.num_resources = ARRAY_SIZE(gpio_resources),\n\t}, {\n\t\t.name = \"max77620-rtc\",\n\t\t.resources = rtc_resources,\n\t\t.num_resources = ARRAY_SIZE(rtc_resources),\n\t}, {\n\t\t.name = \"max20024-power\",\n\t\t.resources = power_resources,\n\t\t.num_resources = ARRAY_SIZE(power_resources),\n\t},\n};\n\nstatic const struct mfd_cell max77663_children[] = {\n\t{ .name = \"max77620-pinctrl\", },\n\t{ .name = \"max77620-clock\", },\n\t{ .name = \"max77663-pmic\", },\n\t{ .name = \"max77620-watchdog\", },\n\t{\n\t\t.name = \"max77620-gpio\",\n\t\t.resources = gpio_resources,\n\t\t.num_resources = ARRAY_SIZE(gpio_resources),\n\t}, {\n\t\t.name = \"max77620-rtc\",\n\t\t.resources = rtc_resources,\n\t\t.num_resources = ARRAY_SIZE(rtc_resources),\n\t}, {\n\t\t.name = \"max77663-power\",\n\t\t.resources = power_resources,\n\t\t.num_resources = ARRAY_SIZE(power_resources),\n\t},\n};\n\nstatic const struct regmap_range max77620_readable_ranges[] = {\n\tregmap_reg_range(MAX77620_REG_CNFGGLBL1, MAX77620_REG_DVSSD4),\n};\n\nstatic const struct regmap_access_table max77620_readable_table = {\n\t.yes_ranges = max77620_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(max77620_readable_ranges),\n};\n\nstatic const struct regmap_range max20024_readable_ranges[] = {\n\tregmap_reg_range(MAX77620_REG_CNFGGLBL1, MAX77620_REG_DVSSD4),\n\tregmap_reg_range(MAX20024_REG_MAX_ADD, MAX20024_REG_MAX_ADD),\n};\n\nstatic const struct regmap_access_table max20024_readable_table = {\n\t.yes_ranges = max20024_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(max20024_readable_ranges),\n};\n\nstatic const struct regmap_range max77620_writable_ranges[] = {\n\tregmap_reg_range(MAX77620_REG_CNFGGLBL1, MAX77620_REG_DVSSD4),\n};\n\nstatic const struct regmap_access_table max77620_writable_table = {\n\t.yes_ranges = max77620_writable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(max77620_writable_ranges),\n};\n\nstatic const struct regmap_range max77620_cacheable_ranges[] = {\n\tregmap_reg_range(MAX77620_REG_SD0_CFG, MAX77620_REG_LDO_CFG3),\n\tregmap_reg_range(MAX77620_REG_FPS_CFG0, MAX77620_REG_FPS_SD3),\n};\n\nstatic const struct regmap_access_table max77620_volatile_table = {\n\t.no_ranges = max77620_cacheable_ranges,\n\t.n_no_ranges = ARRAY_SIZE(max77620_cacheable_ranges),\n};\n\nstatic const struct regmap_config max77620_regmap_config = {\n\t.name = \"power-slave\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MAX77620_REG_DVSSD4 + 1,\n\t.cache_type = REGCACHE_RBTREE,\n\t.rd_table = &max77620_readable_table,\n\t.wr_table = &max77620_writable_table,\n\t.volatile_table = &max77620_volatile_table,\n\t.use_single_write = true,\n};\n\nstatic const struct regmap_config max20024_regmap_config = {\n\t.name = \"power-slave\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MAX20024_REG_MAX_ADD + 1,\n\t.cache_type = REGCACHE_RBTREE,\n\t.rd_table = &max20024_readable_table,\n\t.wr_table = &max77620_writable_table,\n\t.volatile_table = &max77620_volatile_table,\n};\n\nstatic const struct regmap_range max77663_readable_ranges[] = {\n\tregmap_reg_range(MAX77620_REG_CNFGGLBL1, MAX77620_REG_CID5),\n};\n\nstatic const struct regmap_access_table max77663_readable_table = {\n\t.yes_ranges = max77663_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(max77663_readable_ranges),\n};\n\nstatic const struct regmap_range max77663_writable_ranges[] = {\n\tregmap_reg_range(MAX77620_REG_CNFGGLBL1, MAX77620_REG_CID5),\n};\n\nstatic const struct regmap_access_table max77663_writable_table = {\n\t.yes_ranges = max77663_writable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(max77663_writable_ranges),\n};\n\nstatic const struct regmap_config max77663_regmap_config = {\n\t.name = \"power-slave\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MAX77620_REG_CID5 + 1,\n\t.cache_type = REGCACHE_RBTREE,\n\t.rd_table = &max77663_readable_table,\n\t.wr_table = &max77663_writable_table,\n\t.volatile_table = &max77620_volatile_table,\n};\n\n \nstatic int max77620_irq_global_mask(void *irq_drv_data)\n{\n\tstruct max77620_chip *chip = irq_drv_data;\n\tint ret;\n\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_INTENLBT,\n\t\t\t\t MAX77620_GLBLM_MASK, MAX77620_GLBLM_MASK);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to set GLBLM: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int max77620_irq_global_unmask(void *irq_drv_data)\n{\n\tstruct max77620_chip *chip = irq_drv_data;\n\tint ret;\n\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_INTENLBT,\n\t\t\t\t MAX77620_GLBLM_MASK, 0);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to reset GLBLM: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct regmap_irq_chip max77620_top_irq_chip = {\n\t.name = \"max77620-top\",\n\t.irqs = max77620_top_irqs,\n\t.num_irqs = ARRAY_SIZE(max77620_top_irqs),\n\t.num_regs = 2,\n\t.status_base = MAX77620_REG_IRQTOP,\n\t.mask_base = MAX77620_REG_IRQTOPM,\n\t.handle_pre_irq = max77620_irq_global_mask,\n\t.handle_post_irq = max77620_irq_global_unmask,\n};\n\n \nstatic int max77620_get_fps_period_reg_value(struct max77620_chip *chip,\n\t\t\t\t\t     int tperiod)\n{\n\tint fps_min_period;\n\tint i;\n\n\tswitch (chip->chip_id) {\n\tcase MAX20024:\n\t\tfps_min_period = MAX20024_FPS_PERIOD_MIN_US;\n\t\tbreak;\n\tcase MAX77620:\n\t\tfps_min_period = MAX77620_FPS_PERIOD_MIN_US;\n\t\tbreak;\n\tcase MAX77663:\n\t\tfps_min_period = MAX20024_FPS_PERIOD_MIN_US;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < 7; i++) {\n\t\tif (fps_min_period >= tperiod)\n\t\t\treturn i;\n\t\tfps_min_period *= 2;\n\t}\n\n\treturn i;\n}\n\n \nstatic int max77620_config_fps(struct max77620_chip *chip,\n\t\t\t       struct device_node *fps_np)\n{\n\tstruct device *dev = chip->dev;\n\tunsigned int mask = 0, config = 0;\n\tu32 fps_max_period;\n\tu32 param_val;\n\tint tperiod, fps_id;\n\tint ret;\n\tchar fps_name[10];\n\n\tswitch (chip->chip_id) {\n\tcase MAX20024:\n\t\tfps_max_period = MAX20024_FPS_PERIOD_MAX_US;\n\t\tbreak;\n\tcase MAX77620:\n\t\tfps_max_period = MAX77620_FPS_PERIOD_MAX_US;\n\t\tbreak;\n\tcase MAX77663:\n\t\tfps_max_period = MAX20024_FPS_PERIOD_MAX_US;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (fps_id = 0; fps_id < MAX77620_FPS_COUNT; fps_id++) {\n\t\tsprintf(fps_name, \"fps%d\", fps_id);\n\t\tif (of_node_name_eq(fps_np, fps_name))\n\t\t\tbreak;\n\t}\n\n\tif (fps_id == MAX77620_FPS_COUNT) {\n\t\tdev_err(dev, \"FPS node name %pOFn is not valid\\n\", fps_np);\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(fps_np, \"maxim,shutdown-fps-time-period-us\",\n\t\t\t\t   &param_val);\n\tif (!ret) {\n\t\tmask |= MAX77620_FPS_TIME_PERIOD_MASK;\n\t\tchip->shutdown_fps_period[fps_id] = min(param_val,\n\t\t\t\t\t\t\tfps_max_period);\n\t\ttperiod = max77620_get_fps_period_reg_value(chip,\n\t\t\t\tchip->shutdown_fps_period[fps_id]);\n\t\tconfig |= tperiod << MAX77620_FPS_TIME_PERIOD_SHIFT;\n\t}\n\n\tret = of_property_read_u32(fps_np, \"maxim,suspend-fps-time-period-us\",\n\t\t\t\t   &param_val);\n\tif (!ret)\n\t\tchip->suspend_fps_period[fps_id] = min(param_val,\n\t\t\t\t\t\t       fps_max_period);\n\n\tret = of_property_read_u32(fps_np, \"maxim,fps-event-source\",\n\t\t\t\t   &param_val);\n\tif (!ret) {\n\t\tif (param_val > 2) {\n\t\t\tdev_err(dev, \"FPS%d event-source invalid\\n\", fps_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmask |= MAX77620_FPS_EN_SRC_MASK;\n\t\tconfig |= param_val << MAX77620_FPS_EN_SRC_SHIFT;\n\t\tif (param_val == 2) {\n\t\t\tmask |= MAX77620_FPS_ENFPS_SW_MASK;\n\t\t\tconfig |= MAX77620_FPS_ENFPS_SW;\n\t\t}\n\t}\n\n\tif (!chip->sleep_enable && !chip->enable_global_lpm) {\n\t\tret = of_property_read_u32(fps_np,\n\t\t\t\t\"maxim,device-state-on-disabled-event\",\n\t\t\t\t&param_val);\n\t\tif (!ret) {\n\t\t\tif (param_val == 0)\n\t\t\t\tchip->sleep_enable = true;\n\t\t\telse if (param_val == 1)\n\t\t\t\tchip->enable_global_lpm = true;\n\t\t}\n\t}\n\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_FPS_CFG0 + fps_id,\n\t\t\t\t mask, config);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to update FPS CFG: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int max77620_initialise_fps(struct max77620_chip *chip)\n{\n\tstruct device *dev = chip->dev;\n\tstruct device_node *fps_np, *fps_child;\n\tu8 config;\n\tint fps_id;\n\tint ret;\n\n\tfor (fps_id = 0; fps_id < MAX77620_FPS_COUNT; fps_id++) {\n\t\tchip->shutdown_fps_period[fps_id] = -1;\n\t\tchip->suspend_fps_period[fps_id] = -1;\n\t}\n\n\tfps_np = of_get_child_by_name(dev->of_node, \"fps\");\n\tif (!fps_np)\n\t\tgoto skip_fps;\n\n\tfor_each_child_of_node(fps_np, fps_child) {\n\t\tret = max77620_config_fps(chip, fps_child);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(fps_child);\n\t\t\tof_node_put(fps_np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tof_node_put(fps_np);\n\n\tconfig = chip->enable_global_lpm ? MAX77620_ONOFFCNFG2_SLP_LPM_MSK : 0;\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,\n\t\t\t\t MAX77620_ONOFFCNFG2_SLP_LPM_MSK, config);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to update SLP_LPM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\nskip_fps:\n\tif (chip->chip_id == MAX77663)\n\t\treturn 0;\n\n\t \n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,\n\t\t\t\t MAX77620_ONOFFCNFG2_WK_EN0,\n\t\t\t\t MAX77620_ONOFFCNFG2_WK_EN0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to update WK_EN0: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif ((chip->chip_id == MAX20024) && chip->sleep_enable) {\n\t\tconfig = MAX77620_ONOFFCNFG1_SLPEN | MAX20024_ONOFFCNFG1_CLRSE;\n\t\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG1,\n\t\t\t\t\t config, config);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to update SLPEN: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int max77620_read_es_version(struct max77620_chip *chip)\n{\n\tunsigned int val;\n\tu8 cid_val[6];\n\tint i;\n\tint ret;\n\n\tfor (i = MAX77620_REG_CID0; i <= MAX77620_REG_CID5; i++) {\n\t\tret = regmap_read(chip->rmap, i, &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev, \"Failed to read CID: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(chip->dev, \"CID%d: 0x%02x\\n\",\n\t\t\ti - MAX77620_REG_CID0, val);\n\t\tcid_val[i - MAX77620_REG_CID0] = val;\n\t}\n\n\t \n\tdev_info(chip->dev, \"PMIC Version OTP:0x%02X and ES:0x%X\\n\",\n\t\t cid_val[4], MAX77620_CID5_DIDM(cid_val[5]));\n\n\treturn ret;\n}\n\nstatic void max77620_pm_power_off(void)\n{\n\tstruct max77620_chip *chip = max77620_scratch;\n\n\tregmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG1,\n\t\t\t   MAX77620_ONOFFCNFG1_SFT_RST,\n\t\t\t   MAX77620_ONOFFCNFG1_SFT_RST);\n}\n\nstatic int max77620_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tconst struct regmap_config *rmap_config;\n\tstruct max77620_chip *chip;\n\tconst struct mfd_cell *mfd_cells;\n\tint n_mfd_cells;\n\tbool pm_off;\n\tint ret;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, chip);\n\tchip->dev = &client->dev;\n\tchip->chip_irq = client->irq;\n\tchip->chip_id = (enum max77620_chip_id)id->driver_data;\n\n\tswitch (chip->chip_id) {\n\tcase MAX77620:\n\t\tmfd_cells = max77620_children;\n\t\tn_mfd_cells = ARRAY_SIZE(max77620_children);\n\t\trmap_config = &max77620_regmap_config;\n\t\tbreak;\n\tcase MAX20024:\n\t\tmfd_cells = max20024_children;\n\t\tn_mfd_cells = ARRAY_SIZE(max20024_children);\n\t\trmap_config = &max20024_regmap_config;\n\t\tbreak;\n\tcase MAX77663:\n\t\tmfd_cells = max77663_children;\n\t\tn_mfd_cells = ARRAY_SIZE(max77663_children);\n\t\trmap_config = &max77663_regmap_config;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->dev, \"ChipID is invalid %d\\n\", chip->chip_id);\n\t\treturn -EINVAL;\n\t}\n\n\tchip->rmap = devm_regmap_init_i2c(client, rmap_config);\n\tif (IS_ERR(chip->rmap)) {\n\t\tret = PTR_ERR(chip->rmap);\n\t\tdev_err(chip->dev, \"Failed to initialise regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = max77620_read_es_version(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmax77620_top_irq_chip.irq_drv_data = chip;\n\tret = devm_regmap_add_irq_chip(chip->dev, chip->rmap, client->irq,\n\t\t\t\t       IRQF_ONESHOT | IRQF_SHARED, 0,\n\t\t\t\t       &max77620_top_irq_chip,\n\t\t\t\t       &chip->top_irq_data);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to add regmap irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = max77620_initialise_fps(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret =  devm_mfd_add_devices(chip->dev, PLATFORM_DEVID_NONE,\n\t\t\t\t    mfd_cells, n_mfd_cells, NULL, 0,\n\t\t\t\t    regmap_irq_get_domain(chip->top_irq_data));\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to add MFD children: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpm_off = of_device_is_system_power_controller(client->dev.of_node);\n\tif (pm_off && !pm_power_off) {\n\t\tmax77620_scratch = chip;\n\t\tpm_power_off = max77620_pm_power_off;\n\t}\n\n\treturn 0;\n}\n\nstatic int max77620_set_fps_period(struct max77620_chip *chip,\n\t\t\t\t   int fps_id, int time_period)\n{\n\tint period = max77620_get_fps_period_reg_value(chip, time_period);\n\tint ret;\n\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_FPS_CFG0 + fps_id,\n\t\t\t\t MAX77620_FPS_TIME_PERIOD_MASK,\n\t\t\t\t period << MAX77620_FPS_TIME_PERIOD_SHIFT);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to update FPS period: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int max77620_i2c_suspend(struct device *dev)\n{\n\tstruct max77620_chip *chip = dev_get_drvdata(dev);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned int config;\n\tint fps;\n\tint ret;\n\n\tfor (fps = 0; fps < MAX77620_FPS_COUNT; fps++) {\n\t\tif (chip->suspend_fps_period[fps] < 0)\n\t\t\tcontinue;\n\n\t\tret = max77620_set_fps_period(chip, fps,\n\t\t\t\t\t      chip->suspend_fps_period[fps]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (chip->chip_id == MAX20024)\n\t\tgoto out;\n\n\tconfig = (chip->sleep_enable) ? MAX77620_ONOFFCNFG1_SLPEN : 0;\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG1,\n\t\t\t\t MAX77620_ONOFFCNFG1_SLPEN,\n\t\t\t\t config);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to configure sleep in suspend: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (chip->chip_id == MAX77663)\n\t\tgoto out;\n\n\t \n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,\n\t\t\t\t MAX77620_ONOFFCNFG2_WK_EN0, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to configure WK_EN in suspend: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\nout:\n\tdisable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic int max77620_i2c_resume(struct device *dev)\n{\n\tstruct max77620_chip *chip = dev_get_drvdata(dev);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\tint fps;\n\n\tfor (fps = 0; fps < MAX77620_FPS_COUNT; fps++) {\n\t\tif (chip->shutdown_fps_period[fps] < 0)\n\t\t\tcontinue;\n\n\t\tret = max77620_set_fps_period(chip, fps,\n\t\t\t\t\t      chip->shutdown_fps_period[fps]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (chip->chip_id == MAX20024 || chip->chip_id == MAX77663)\n\t\tgoto out;\n\n\t \n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,\n\t\t\t\t MAX77620_ONOFFCNFG2_WK_EN0,\n\t\t\t\t MAX77620_ONOFFCNFG2_WK_EN0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to configure WK_EN0 n resume: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\nout:\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max77620_id[] = {\n\t{\"max77620\", MAX77620},\n\t{\"max20024\", MAX20024},\n\t{\"max77663\", MAX77663},\n\t{},\n};\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(max77620_pm_ops,\n\t\t\t\tmax77620_i2c_suspend, max77620_i2c_resume);\n\nstatic struct i2c_driver max77620_driver = {\n\t.driver = {\n\t\t.name = \"max77620\",\n\t\t.pm = pm_sleep_ptr(&max77620_pm_ops),\n\t},\n\t.probe = max77620_probe,\n\t.id_table = max77620_id,\n};\nbuiltin_i2c_driver(max77620_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}