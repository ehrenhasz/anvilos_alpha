{
  "module_name": "88pm800.c",
  "hash_id": "9f0730160c7f72473cd81edd72b81dc6529c6914edb0b4b40365508e27733ffc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/88pm800.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/88pm80x.h>\n#include <linux/slab.h>\n\n \n#define PM800_INT_STATUS1\t\t(0x05)\n#define PM800_ONKEY_INT_STS1\t\t(1 << 0)\n#define PM800_EXTON_INT_STS1\t\t(1 << 1)\n#define PM800_CHG_INT_STS1\t\t\t(1 << 2)\n#define PM800_BAT_INT_STS1\t\t\t(1 << 3)\n#define PM800_RTC_INT_STS1\t\t\t(1 << 4)\n#define PM800_CLASSD_OC_INT_STS1\t(1 << 5)\n\n#define PM800_INT_STATUS2\t\t(0x06)\n#define PM800_VBAT_INT_STS2\t\t(1 << 0)\n#define PM800_VSYS_INT_STS2\t\t(1 << 1)\n#define PM800_VCHG_INT_STS2\t\t(1 << 2)\n#define PM800_TINT_INT_STS2\t\t(1 << 3)\n#define PM800_GPADC0_INT_STS2\t(1 << 4)\n#define PM800_TBAT_INT_STS2\t\t(1 << 5)\n#define PM800_GPADC2_INT_STS2\t(1 << 6)\n#define PM800_GPADC3_INT_STS2\t(1 << 7)\n\n#define PM800_INT_STATUS3\t\t(0x07)\n\n#define PM800_INT_STATUS4\t\t(0x08)\n#define PM800_GPIO0_INT_STS4\t\t(1 << 0)\n#define PM800_GPIO1_INT_STS4\t\t(1 << 1)\n#define PM800_GPIO2_INT_STS4\t\t(1 << 2)\n#define PM800_GPIO3_INT_STS4\t\t(1 << 3)\n#define PM800_GPIO4_INT_STS4\t\t(1 << 4)\n\n#define PM800_INT_ENA_1\t\t(0x09)\n#define PM800_ONKEY_INT_ENA1\t\t(1 << 0)\n#define PM800_EXTON_INT_ENA1\t\t(1 << 1)\n#define PM800_CHG_INT_ENA1\t\t\t(1 << 2)\n#define PM800_BAT_INT_ENA1\t\t\t(1 << 3)\n#define PM800_RTC_INT_ENA1\t\t\t(1 << 4)\n#define PM800_CLASSD_OC_INT_ENA1\t(1 << 5)\n\n#define PM800_INT_ENA_2\t\t(0x0A)\n#define PM800_VBAT_INT_ENA2\t\t(1 << 0)\n#define PM800_VSYS_INT_ENA2\t\t(1 << 1)\n#define PM800_VCHG_INT_ENA2\t\t(1 << 2)\n#define PM800_TINT_INT_ENA2\t\t(1 << 3)\n\n#define PM800_INT_ENA_3\t\t(0x0B)\n#define PM800_GPADC0_INT_ENA3\t\t(1 << 0)\n#define PM800_GPADC1_INT_ENA3\t\t(1 << 1)\n#define PM800_GPADC2_INT_ENA3\t\t(1 << 2)\n#define PM800_GPADC3_INT_ENA3\t\t(1 << 3)\n#define PM800_GPADC4_INT_ENA3\t\t(1 << 4)\n\n#define PM800_INT_ENA_4\t\t(0x0C)\n#define PM800_GPIO0_INT_ENA4\t\t(1 << 0)\n#define PM800_GPIO1_INT_ENA4\t\t(1 << 1)\n#define PM800_GPIO2_INT_ENA4\t\t(1 << 2)\n#define PM800_GPIO3_INT_ENA4\t\t(1 << 3)\n#define PM800_GPIO4_INT_ENA4\t\t(1 << 4)\n\n \n#define PM800_INT_REG_NUM\t\t\t(4)\n\n \nenum {\n\tPM800_IRQ_ONKEY,\t \n\tPM800_IRQ_CHG,\t\t \n\tPM800_IRQ_BAT,\t\t \n\tPM800_IRQ_RTC,\t\t \n\tPM800_IRQ_CLASSD,\t \n\tPM800_IRQ_VSYS,\t\t \n\tPM800_IRQ_VCHG,\t\t \n\tPM800_IRQ_TINT,\t\t \n\tPM800_IRQ_GPADC0,\t \n\tPM800_IRQ_GPADC2,\t \n\tPM800_IRQ_GPADC3,\t \n\tPM800_IRQ_GPADC4,\t \n\tPM800_IRQ_GPIO0,\t \n\tPM800_IRQ_GPIO2,\t \n\tPM800_IRQ_GPIO3,\t \n\tPM800_IRQ_GPIO4,\t \n#define PM800_CHIP_GEN_ID_NUM\t0x3\n\nstatic const struct i2c_device_id pm80x_id_table[] = {\n\t{\"88PM800\", 0},\n\t{}  \n};\nMODULE_DEVICE_TABLE(i2c, pm80x_id_table);\n\nstatic const struct resource rtc_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(PM800_IRQ_RTC, \"88pm80x-rtc\"),\n};\n\nstatic struct mfd_cell rtc_devs[] = {\n\t{\n\t .name = \"88pm80x-rtc\",\n\t .num_resources = ARRAY_SIZE(rtc_resources),\n\t .resources = &rtc_resources[0],\n\t .id = -1,\n\t },\n};\n\nstatic struct resource onkey_resources[] = {\n\tDEFINE_RES_IRQ_NAMED(PM800_IRQ_ONKEY, \"88pm80x-onkey\"),\n};\n\nstatic const struct mfd_cell onkey_devs[] = {\n\t{\n\t .name = \"88pm80x-onkey\",\n\t .num_resources = 1,\n\t .resources = &onkey_resources[0],\n\t .id = -1,\n\t },\n};\n\nstatic const struct mfd_cell regulator_devs[] = {\n\t{\n\t .name = \"88pm80x-regulator\",\n\t .id = -1,\n\t},\n};\n\nstatic const struct regmap_irq pm800_irqs[] = {\n\t \n\t[PM800_IRQ_ONKEY] = {\n\t\t.mask = PM800_ONKEY_INT_ENA1,\n\t},\n\t[PM800_IRQ_EXTON] = {\n\t\t.mask = PM800_EXTON_INT_ENA1,\n\t},\n\t[PM800_IRQ_CHG] = {\n\t\t.mask = PM800_CHG_INT_ENA1,\n\t},\n\t[PM800_IRQ_BAT] = {\n\t\t.mask = PM800_BAT_INT_ENA1,\n\t},\n\t[PM800_IRQ_RTC] = {\n\t\t.mask = PM800_RTC_INT_ENA1,\n\t},\n\t[PM800_IRQ_CLASSD] = {\n\t\t.mask = PM800_CLASSD_OC_INT_ENA1,\n\t},\n\t \n\t[PM800_IRQ_VBAT] = {\n\t\t.reg_offset = 1,\n\t\t.mask = PM800_VBAT_INT_ENA2,\n\t},\n\t[PM800_IRQ_VSYS] = {\n\t\t.reg_offset = 1,\n\t\t.mask = PM800_VSYS_INT_ENA2,\n\t},\n\t[PM800_IRQ_VCHG] = {\n\t\t.reg_offset = 1,\n\t\t.mask = PM800_VCHG_INT_ENA2,\n\t},\n\t[PM800_IRQ_TINT] = {\n\t\t.reg_offset = 1,\n\t\t.mask = PM800_TINT_INT_ENA2,\n\t},\n\t \n\t[PM800_IRQ_GPADC0] = {\n\t\t.reg_offset = 2,\n\t\t.mask = PM800_GPADC0_INT_ENA3,\n\t},\n\t[PM800_IRQ_GPADC1] = {\n\t\t.reg_offset = 2,\n\t\t.mask = PM800_GPADC1_INT_ENA3,\n\t},\n\t[PM800_IRQ_GPADC2] = {\n\t\t.reg_offset = 2,\n\t\t.mask = PM800_GPADC2_INT_ENA3,\n\t},\n\t[PM800_IRQ_GPADC3] = {\n\t\t.reg_offset = 2,\n\t\t.mask = PM800_GPADC3_INT_ENA3,\n\t},\n\t[PM800_IRQ_GPADC4] = {\n\t\t.reg_offset = 2,\n\t\t.mask = PM800_GPADC4_INT_ENA3,\n\t},\n\t \n\t[PM800_IRQ_GPIO0] = {\n\t\t.reg_offset = 3,\n\t\t.mask = PM800_GPIO0_INT_ENA4,\n\t},\n\t[PM800_IRQ_GPIO1] = {\n\t\t.reg_offset = 3,\n\t\t.mask = PM800_GPIO1_INT_ENA4,\n\t},\n\t[PM800_IRQ_GPIO2] = {\n\t\t.reg_offset = 3,\n\t\t.mask = PM800_GPIO2_INT_ENA4,\n\t},\n\t[PM800_IRQ_GPIO3] = {\n\t\t.reg_offset = 3,\n\t\t.mask = PM800_GPIO3_INT_ENA4,\n\t},\n\t[PM800_IRQ_GPIO4] = {\n\t\t.reg_offset = 3,\n\t\t.mask = PM800_GPIO4_INT_ENA4,\n\t},\n};\n\nstatic int device_gpadc_init(struct pm80x_chip *chip,\n\t\t\t\t       struct pm80x_platform_data *pdata)\n{\n\tstruct pm80x_subchip *subchip = chip->subchip;\n\tstruct regmap *map = subchip->regmap_gpadc;\n\tint data = 0, mask = 0, ret = 0;\n\n\tif (!map) {\n\t\tdev_warn(chip->dev,\n\t\t\t \"Warning: gpadc regmap is not available!\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tret = regmap_update_bits(map,\n\t\t\t\t PM800_GPADC_MISC_CONFIG2,\n\t\t\t\t PM800_GPADC_MISC_GPFSM_EN,\n\t\t\t\t PM800_GPADC_MISC_GPFSM_EN);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tret = regmap_update_bits(map, PM800_GPADC_MEAS_EN1,\n\t\t\t\t PM800_MEAS_EN1_VBAT, PM800_MEAS_EN1_VBAT);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = regmap_update_bits(map, PM800_GPADC_MEAS_EN2,\n\t\t\t\t (PM800_MEAS_EN2_RFTMP | PM800_MEAS_GP0_EN),\n\t\t\t\t (PM800_MEAS_EN2_RFTMP | PM800_MEAS_GP0_EN));\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tmask = (PM800_GPADC_GP_BIAS_EN0 | PM800_GPADC_GP_BIAS_EN1 |\n\t\tPM800_GPADC_GP_BIAS_EN2 | PM800_GPADC_GP_BIAS_EN3);\n\n\tif (pdata && (pdata->batt_det == 0))\n\t\tdata = (PM800_GPADC_GP_BIAS_EN0 | PM800_GPADC_GP_BIAS_EN1 |\n\t\t\tPM800_GPADC_GP_BIAS_EN2 | PM800_GPADC_GP_BIAS_EN3);\n\telse\n\t\tdata = (PM800_GPADC_GP_BIAS_EN0 | PM800_GPADC_GP_BIAS_EN2 |\n\t\t\tPM800_GPADC_GP_BIAS_EN3);\n\n\tret = regmap_update_bits(map, PM800_GP_BIAS_ENA1, mask, data);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdev_info(chip->dev, \"pm800 device_gpadc_init: Done\\n\");\n\treturn 0;\n\nout:\n\tdev_info(chip->dev, \"pm800 device_gpadc_init: Failed!\\n\");\n\treturn ret;\n}\n\nstatic int device_onkey_init(struct pm80x_chip *chip,\n\t\t\t\tstruct pm80x_platform_data *pdata)\n{\n\tint ret;\n\n\tret = mfd_add_devices(chip->dev, 0, &onkey_devs[0],\n\t\t\t      ARRAY_SIZE(onkey_devs), &onkey_resources[0], 0,\n\t\t\t      NULL);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to add onkey subdev\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int device_rtc_init(struct pm80x_chip *chip,\n\t\t\t\tstruct pm80x_platform_data *pdata)\n{\n\tint ret;\n\n\tif (pdata) {\n\t\trtc_devs[0].platform_data = pdata->rtc;\n\t\trtc_devs[0].pdata_size =\n\t\t\t\tpdata->rtc ? sizeof(struct pm80x_rtc_pdata) : 0;\n\t}\n\tret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],\n\t\t\t      ARRAY_SIZE(rtc_devs), NULL, 0, NULL);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to add rtc subdev\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int device_regulator_init(struct pm80x_chip *chip,\n\t\t\t\t\t   struct pm80x_platform_data *pdata)\n{\n\tint ret;\n\n\tret = mfd_add_devices(chip->dev, 0, &regulator_devs[0],\n\t\t\t      ARRAY_SIZE(regulator_devs), NULL, 0, NULL);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to add regulator subdev\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int device_irq_init_800(struct pm80x_chip *chip)\n{\n\tstruct regmap *map = chip->regmap;\n\tunsigned long flags = IRQF_ONESHOT;\n\tint data, mask, ret = -EINVAL;\n\n\tif (!map || !chip->irq) {\n\t\tdev_err(chip->dev, \"incorrect parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmask =\n\t    PM800_WAKEUP2_INV_INT | PM800_WAKEUP2_INT_CLEAR |\n\t    PM800_WAKEUP2_INT_MASK;\n\n\tdata = PM800_WAKEUP2_INT_CLEAR;\n\tret = regmap_update_bits(map, PM800_WAKEUP2, mask, data);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret =\n\t    regmap_add_irq_chip(chip->regmap, chip->irq, flags, -1,\n\t\t\t\tchip->regmap_irq_chip, &chip->irq_data);\n\nout:\n\treturn ret;\n}\n\nstatic void device_irq_exit_800(struct pm80x_chip *chip)\n{\n\tregmap_del_irq_chip(chip->irq, chip->irq_data);\n}\n\nstatic struct regmap_irq_chip pm800_irq_chip = {\n\t.name = \"88pm800\",\n\t.irqs = pm800_irqs,\n\t.num_irqs = ARRAY_SIZE(pm800_irqs),\n\n\t.num_regs = 4,\n\t.status_base = PM800_INT_STATUS1,\n\t.unmask_base = PM800_INT_ENA_1,\n\t.ack_base = PM800_INT_STATUS1,\n};\n\nstatic int pm800_pages_init(struct pm80x_chip *chip)\n{\n\tstruct pm80x_subchip *subchip;\n\tstruct i2c_client *client = chip->client;\n\n\tint ret = 0;\n\n\tsubchip = chip->subchip;\n\tif (!subchip || !subchip->power_page_addr || !subchip->gpadc_page_addr)\n\t\treturn -ENODEV;\n\n\t \n\tsubchip->power_page = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\t    subchip->power_page_addr);\n\tif (IS_ERR(subchip->power_page)) {\n\t\tret = PTR_ERR(subchip->power_page);\n\t\tgoto out;\n\t}\n\n\tsubchip->regmap_power = devm_regmap_init_i2c(subchip->power_page,\n\t\t\t\t\t\t     &pm80x_regmap_config);\n\tif (IS_ERR(subchip->regmap_power)) {\n\t\tret = PTR_ERR(subchip->regmap_power);\n\t\tdev_err(chip->dev,\n\t\t\t\"Failed to allocate regmap_power: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\ti2c_set_clientdata(subchip->power_page, chip);\n\n\t \n\tsubchip->gpadc_page = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\t    subchip->gpadc_page_addr);\n\tif (IS_ERR(subchip->gpadc_page)) {\n\t\tret = PTR_ERR(subchip->gpadc_page);\n\t\tgoto out;\n\t}\n\n\tsubchip->regmap_gpadc = devm_regmap_init_i2c(subchip->gpadc_page,\n\t\t\t\t\t\t     &pm80x_regmap_config);\n\tif (IS_ERR(subchip->regmap_gpadc)) {\n\t\tret = PTR_ERR(subchip->regmap_gpadc);\n\t\tdev_err(chip->dev,\n\t\t\t\"Failed to allocate regmap_gpadc: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\ti2c_set_clientdata(subchip->gpadc_page, chip);\n\nout:\n\treturn ret;\n}\n\nstatic void pm800_pages_exit(struct pm80x_chip *chip)\n{\n\tstruct pm80x_subchip *subchip;\n\n\tsubchip = chip->subchip;\n\n\tif (subchip && subchip->power_page)\n\t\ti2c_unregister_device(subchip->power_page);\n\n\tif (subchip && subchip->gpadc_page)\n\t\ti2c_unregister_device(subchip->gpadc_page);\n}\n\nstatic int device_800_init(struct pm80x_chip *chip,\n\t\t\t\t     struct pm80x_platform_data *pdata)\n{\n\tint ret;\n\tunsigned int val;\n\n\t \n\tret = regmap_read(chip->regmap, PM800_RTC_CONTROL, &val);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to read RTC register: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (val & PM800_ALARM_WAKEUP) {\n\t\tif (pdata && pdata->rtc)\n\t\t\tpdata->rtc->rtc_wakeup = 1;\n\t}\n\n\tret = device_gpadc_init(chip, pdata);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"[%s]Failed to init gpadc\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tchip->regmap_irq_chip = &pm800_irq_chip;\n\n\tret = device_irq_init_800(chip);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"[%s]Failed to init pm800 irq\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tret = device_onkey_init(chip, pdata);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to add onkey subdev\\n\");\n\t\tgoto out_dev;\n\t}\n\n\tret = device_rtc_init(chip, pdata);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to add rtc subdev\\n\");\n\t\tgoto out;\n\t}\n\n\tret = device_regulator_init(chip, pdata);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to add regulators subdev\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 0;\nout_dev:\n\tmfd_remove_devices(chip->dev);\n\tdevice_irq_exit_800(chip);\nout:\n\treturn ret;\n}\n\nstatic int pm800_probe(struct i2c_client *client)\n{\n\tint ret = 0;\n\tstruct pm80x_chip *chip;\n\tstruct pm80x_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct pm80x_subchip *subchip;\n\n\tret = pm80x_init(client);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"pm800_init fail\\n\");\n\t\tgoto out_init;\n\t}\n\n\tchip = i2c_get_clientdata(client);\n\n\t \n\tsubchip =\n\t    devm_kzalloc(&client->dev, sizeof(struct pm80x_subchip),\n\t\t\t GFP_KERNEL);\n\tif (!subchip) {\n\t\tret = -ENOMEM;\n\t\tgoto err_subchip_alloc;\n\t}\n\n\t \n\tsubchip->power_page_addr = client->addr + 1;\n\tsubchip->gpadc_page_addr = client->addr + 2;\n\tchip->subchip = subchip;\n\n\tret = pm800_pages_init(chip);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"pm800_pages_init failed!\\n\");\n\t\tgoto err_device_init;\n\t}\n\n\tret = device_800_init(chip, pdata);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to initialize 88pm800 devices\\n\");\n\t\tgoto err_device_init;\n\t}\n\n\tif (pdata && pdata->plat_config)\n\t\tpdata->plat_config(chip, pdata);\n\n\treturn 0;\n\nerr_device_init:\n\tpm800_pages_exit(chip);\nerr_subchip_alloc:\n\tpm80x_deinit();\nout_init:\n\treturn ret;\n}\n\nstatic void pm800_remove(struct i2c_client *client)\n{\n\tstruct pm80x_chip *chip = i2c_get_clientdata(client);\n\n\tmfd_remove_devices(chip->dev);\n\tdevice_irq_exit_800(chip);\n\n\tpm800_pages_exit(chip);\n\tpm80x_deinit();\n}\n\nstatic struct i2c_driver pm800_driver = {\n\t.driver = {\n\t\t.name = \"88PM800\",\n\t\t.pm = pm_sleep_ptr(&pm80x_pm_ops),\n\t\t},\n\t.probe = pm800_probe,\n\t.remove = pm800_remove,\n\t.id_table = pm80x_id_table,\n};\n\nstatic int __init pm800_i2c_init(void)\n{\n\treturn i2c_add_driver(&pm800_driver);\n}\nsubsys_initcall(pm800_i2c_init);\n\nstatic void __exit pm800_i2c_exit(void)\n{\n\ti2c_del_driver(&pm800_driver);\n}\nmodule_exit(pm800_i2c_exit);\n\nMODULE_DESCRIPTION(\"PMIC Driver for Marvell 88PM800\");\nMODULE_AUTHOR(\"Qiao Zhou <zhouqiao@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}