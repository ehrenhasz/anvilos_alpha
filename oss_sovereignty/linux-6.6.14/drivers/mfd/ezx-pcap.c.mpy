{
  "module_name": "ezx-pcap.c",
  "hash_id": "75f2a58475f3a9dc27e8fdd772f013e870b9b2e3f444db6bb4a2151baa9f80db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ezx-pcap.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/mfd/ezx-pcap.h>\n#include <linux/spi/spi.h>\n#include <linux/gpio.h>\n#include <linux/slab.h>\n\n#define PCAP_ADC_MAXQ\t\t8\nstruct pcap_adc_request {\n\tu8 bank;\n\tu8 ch[2];\n\tu32 flags;\n\tvoid (*callback)(void *, u16[]);\n\tvoid *data;\n};\n\nstruct pcap_adc_sync_request {\n\tu16 res[2];\n\tstruct completion completion;\n};\n\nstruct pcap_chip {\n\tstruct spi_device *spi;\n\n\t \n\tu32 buf;\n\tspinlock_t io_lock;\n\n\t \n\tunsigned int irq_base;\n\tu32 msr;\n\tstruct work_struct isr_work;\n\tstruct work_struct msr_work;\n\tstruct workqueue_struct *workqueue;\n\n\t \n\tstruct pcap_adc_request *adc_queue[PCAP_ADC_MAXQ];\n\tu8 adc_head;\n\tu8 adc_tail;\n\tspinlock_t adc_lock;\n};\n\n \nstatic int ezx_pcap_putget(struct pcap_chip *pcap, u32 *data)\n{\n\tstruct spi_transfer t;\n\tstruct spi_message m;\n\tint status;\n\n\tmemset(&t, 0, sizeof(t));\n\tspi_message_init(&m);\n\tt.len = sizeof(u32);\n\tspi_message_add_tail(&t, &m);\n\n\tpcap->buf = *data;\n\tt.tx_buf = (u8 *) &pcap->buf;\n\tt.rx_buf = (u8 *) &pcap->buf;\n\tstatus = spi_sync(pcap->spi, &m);\n\n\tif (status == 0)\n\t\t*data = pcap->buf;\n\n\treturn status;\n}\n\nint ezx_pcap_write(struct pcap_chip *pcap, u8 reg_num, u32 value)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pcap->io_lock, flags);\n\tvalue &= PCAP_REGISTER_VALUE_MASK;\n\tvalue |= PCAP_REGISTER_WRITE_OP_BIT\n\t\t| (reg_num << PCAP_REGISTER_ADDRESS_SHIFT);\n\tret = ezx_pcap_putget(pcap, &value);\n\tspin_unlock_irqrestore(&pcap->io_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ezx_pcap_write);\n\nint ezx_pcap_read(struct pcap_chip *pcap, u8 reg_num, u32 *value)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pcap->io_lock, flags);\n\t*value = PCAP_REGISTER_READ_OP_BIT\n\t\t| (reg_num << PCAP_REGISTER_ADDRESS_SHIFT);\n\n\tret = ezx_pcap_putget(pcap, value);\n\tspin_unlock_irqrestore(&pcap->io_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ezx_pcap_read);\n\nint ezx_pcap_set_bits(struct pcap_chip *pcap, u8 reg_num, u32 mask, u32 val)\n{\n\tunsigned long flags;\n\tint ret;\n\tu32 tmp = PCAP_REGISTER_READ_OP_BIT |\n\t\t(reg_num << PCAP_REGISTER_ADDRESS_SHIFT);\n\n\tspin_lock_irqsave(&pcap->io_lock, flags);\n\tret = ezx_pcap_putget(pcap, &tmp);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\ttmp &= (PCAP_REGISTER_VALUE_MASK & ~mask);\n\ttmp |= (val & mask) | PCAP_REGISTER_WRITE_OP_BIT |\n\t\t(reg_num << PCAP_REGISTER_ADDRESS_SHIFT);\n\n\tret = ezx_pcap_putget(pcap, &tmp);\nout_unlock:\n\tspin_unlock_irqrestore(&pcap->io_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ezx_pcap_set_bits);\n\n \nint irq_to_pcap(struct pcap_chip *pcap, int irq)\n{\n\treturn irq - pcap->irq_base;\n}\nEXPORT_SYMBOL_GPL(irq_to_pcap);\n\nint pcap_to_irq(struct pcap_chip *pcap, int irq)\n{\n\treturn pcap->irq_base + irq;\n}\nEXPORT_SYMBOL_GPL(pcap_to_irq);\n\nstatic void pcap_mask_irq(struct irq_data *d)\n{\n\tstruct pcap_chip *pcap = irq_data_get_irq_chip_data(d);\n\n\tpcap->msr |= 1 << irq_to_pcap(pcap, d->irq);\n\tqueue_work(pcap->workqueue, &pcap->msr_work);\n}\n\nstatic void pcap_unmask_irq(struct irq_data *d)\n{\n\tstruct pcap_chip *pcap = irq_data_get_irq_chip_data(d);\n\n\tpcap->msr &= ~(1 << irq_to_pcap(pcap, d->irq));\n\tqueue_work(pcap->workqueue, &pcap->msr_work);\n}\n\nstatic struct irq_chip pcap_irq_chip = {\n\t.name\t\t= \"pcap\",\n\t.irq_disable\t= pcap_mask_irq,\n\t.irq_mask\t= pcap_mask_irq,\n\t.irq_unmask\t= pcap_unmask_irq,\n};\n\nstatic void pcap_msr_work(struct work_struct *work)\n{\n\tstruct pcap_chip *pcap = container_of(work, struct pcap_chip, msr_work);\n\n\tezx_pcap_write(pcap, PCAP_REG_MSR, pcap->msr);\n}\n\nstatic void pcap_isr_work(struct work_struct *work)\n{\n\tstruct pcap_chip *pcap = container_of(work, struct pcap_chip, isr_work);\n\tstruct pcap_platform_data *pdata = dev_get_platdata(&pcap->spi->dev);\n\tu32 msr, isr, int_sel, service;\n\tint irq;\n\n\tdo {\n\t\tezx_pcap_read(pcap, PCAP_REG_MSR, &msr);\n\t\tezx_pcap_read(pcap, PCAP_REG_ISR, &isr);\n\n\t\t \n\t\tif (!(pdata->config & PCAP_SECOND_PORT)) {\n\t\t\tezx_pcap_read(pcap, PCAP_REG_INT_SEL, &int_sel);\n\t\t\tisr &= ~int_sel;\n\t\t}\n\n\t\tezx_pcap_write(pcap, PCAP_REG_MSR, isr | msr);\n\t\tezx_pcap_write(pcap, PCAP_REG_ISR, isr);\n\n\t\tservice = isr & ~msr;\n\t\tfor (irq = pcap->irq_base; service; service >>= 1, irq++) {\n\t\t\tif (service & 1)\n\t\t\t\tgeneric_handle_irq_safe(irq);\n\t\t}\n\t\tezx_pcap_write(pcap, PCAP_REG_MSR, pcap->msr);\n\t} while (gpio_get_value(pdata->gpio));\n}\n\nstatic void pcap_irq_handler(struct irq_desc *desc)\n{\n\tstruct pcap_chip *pcap = irq_desc_get_handler_data(desc);\n\n\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\tqueue_work(pcap->workqueue, &pcap->isr_work);\n}\n\n \nvoid pcap_set_ts_bits(struct pcap_chip *pcap, u32 bits)\n{\n\tunsigned long flags;\n\tu32 tmp;\n\n\tspin_lock_irqsave(&pcap->adc_lock, flags);\n\tezx_pcap_read(pcap, PCAP_REG_ADC, &tmp);\n\ttmp &= ~(PCAP_ADC_TS_M_MASK | PCAP_ADC_TS_REF_LOWPWR);\n\ttmp |= bits & (PCAP_ADC_TS_M_MASK | PCAP_ADC_TS_REF_LOWPWR);\n\tezx_pcap_write(pcap, PCAP_REG_ADC, tmp);\n\tspin_unlock_irqrestore(&pcap->adc_lock, flags);\n}\nEXPORT_SYMBOL_GPL(pcap_set_ts_bits);\n\nstatic void pcap_disable_adc(struct pcap_chip *pcap)\n{\n\tu32 tmp;\n\n\tezx_pcap_read(pcap, PCAP_REG_ADC, &tmp);\n\ttmp &= ~(PCAP_ADC_ADEN|PCAP_ADC_BATT_I_ADC|PCAP_ADC_BATT_I_POLARITY);\n\tezx_pcap_write(pcap, PCAP_REG_ADC, tmp);\n}\n\nstatic void pcap_adc_trigger(struct pcap_chip *pcap)\n{\n\tunsigned long flags;\n\tu32 tmp;\n\tu8 head;\n\n\tspin_lock_irqsave(&pcap->adc_lock, flags);\n\thead = pcap->adc_head;\n\tif (!pcap->adc_queue[head]) {\n\t\t \n\t\tpcap_disable_adc(pcap);\n\t\tspin_unlock_irqrestore(&pcap->adc_lock, flags);\n\t\treturn;\n\t}\n\t \n\tezx_pcap_read(pcap, PCAP_REG_ADC, &tmp);\n\ttmp &= (PCAP_ADC_TS_M_MASK | PCAP_ADC_TS_REF_LOWPWR);\n\ttmp |= pcap->adc_queue[head]->flags | PCAP_ADC_ADEN;\n\n\tif (pcap->adc_queue[head]->bank == PCAP_ADC_BANK_1)\n\t\ttmp |= PCAP_ADC_AD_SEL1;\n\n\tezx_pcap_write(pcap, PCAP_REG_ADC, tmp);\n\tspin_unlock_irqrestore(&pcap->adc_lock, flags);\n\tezx_pcap_write(pcap, PCAP_REG_ADR, PCAP_ADR_ASC);\n}\n\nstatic irqreturn_t pcap_adc_irq(int irq, void *_pcap)\n{\n\tstruct pcap_chip *pcap = _pcap;\n\tstruct pcap_adc_request *req;\n\tu16 res[2];\n\tu32 tmp;\n\n\tspin_lock(&pcap->adc_lock);\n\treq = pcap->adc_queue[pcap->adc_head];\n\n\tif (WARN(!req, \"adc irq without pending request\\n\")) {\n\t\tspin_unlock(&pcap->adc_lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tezx_pcap_read(pcap, PCAP_REG_ADC, &tmp);\n\ttmp &= ~(PCAP_ADC_ADA1_MASK | PCAP_ADC_ADA2_MASK);\n\ttmp |= (req->ch[0] << PCAP_ADC_ADA1_SHIFT);\n\ttmp |= (req->ch[1] << PCAP_ADC_ADA2_SHIFT);\n\tezx_pcap_write(pcap, PCAP_REG_ADC, tmp);\n\tezx_pcap_read(pcap, PCAP_REG_ADR, &tmp);\n\tres[0] = (tmp & PCAP_ADR_ADD1_MASK) >> PCAP_ADR_ADD1_SHIFT;\n\tres[1] = (tmp & PCAP_ADR_ADD2_MASK) >> PCAP_ADR_ADD2_SHIFT;\n\n\tpcap->adc_queue[pcap->adc_head] = NULL;\n\tpcap->adc_head = (pcap->adc_head + 1) & (PCAP_ADC_MAXQ - 1);\n\tspin_unlock(&pcap->adc_lock);\n\n\t \n\treq->callback(req->data, res);\n\tkfree(req);\n\n\t \n\tpcap_adc_trigger(pcap);\n\n\treturn IRQ_HANDLED;\n}\n\nint pcap_adc_async(struct pcap_chip *pcap, u8 bank, u32 flags, u8 ch[],\n\t\t\t\t\t\tvoid *callback, void *data)\n{\n\tstruct pcap_adc_request *req;\n\tunsigned long irq_flags;\n\n\t \n\treq = kmalloc(sizeof(struct pcap_adc_request), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->bank = bank;\n\treq->flags = flags;\n\treq->ch[0] = ch[0];\n\treq->ch[1] = ch[1];\n\treq->callback = callback;\n\treq->data = data;\n\n\tspin_lock_irqsave(&pcap->adc_lock, irq_flags);\n\tif (pcap->adc_queue[pcap->adc_tail]) {\n\t\tspin_unlock_irqrestore(&pcap->adc_lock, irq_flags);\n\t\tkfree(req);\n\t\treturn -EBUSY;\n\t}\n\tpcap->adc_queue[pcap->adc_tail] = req;\n\tpcap->adc_tail = (pcap->adc_tail + 1) & (PCAP_ADC_MAXQ - 1);\n\tspin_unlock_irqrestore(&pcap->adc_lock, irq_flags);\n\n\t \n\tpcap_adc_trigger(pcap);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pcap_adc_async);\n\nstatic void pcap_adc_sync_cb(void *param, u16 res[])\n{\n\tstruct pcap_adc_sync_request *req = param;\n\n\treq->res[0] = res[0];\n\treq->res[1] = res[1];\n\tcomplete(&req->completion);\n}\n\nint pcap_adc_sync(struct pcap_chip *pcap, u8 bank, u32 flags, u8 ch[],\n\t\t\t\t\t\t\t\tu16 res[])\n{\n\tstruct pcap_adc_sync_request sync_data;\n\tint ret;\n\n\tinit_completion(&sync_data.completion);\n\tret = pcap_adc_async(pcap, bank, flags, ch, pcap_adc_sync_cb,\n\t\t\t\t\t\t\t\t&sync_data);\n\tif (ret)\n\t\treturn ret;\n\twait_for_completion(&sync_data.completion);\n\tres[0] = sync_data.res[0];\n\tres[1] = sync_data.res[1];\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pcap_adc_sync);\n\n \nstatic int pcap_remove_subdev(struct device *dev, void *unused)\n{\n\tplatform_device_unregister(to_platform_device(dev));\n\treturn 0;\n}\n\nstatic int pcap_add_subdev(struct pcap_chip *pcap,\n\t\t\t\t\t\tstruct pcap_subdev *subdev)\n{\n\tstruct platform_device *pdev;\n\tint ret;\n\n\tpdev = platform_device_alloc(subdev->name, subdev->id);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\tpdev->dev.parent = &pcap->spi->dev;\n\tpdev->dev.platform_data = subdev->platform_data;\n\n\tret = platform_device_add(pdev);\n\tif (ret)\n\t\tplatform_device_put(pdev);\n\n\treturn ret;\n}\n\nstatic void ezx_pcap_remove(struct spi_device *spi)\n{\n\tstruct pcap_chip *pcap = spi_get_drvdata(spi);\n\tunsigned long flags;\n\tint i;\n\n\t \n\tdevice_for_each_child(&spi->dev, NULL, pcap_remove_subdev);\n\n\t \n\tspin_lock_irqsave(&pcap->adc_lock, flags);\n\tfor (i = 0; i < PCAP_ADC_MAXQ; i++)\n\t\tkfree(pcap->adc_queue[i]);\n\tspin_unlock_irqrestore(&pcap->adc_lock, flags);\n\n\t \n\tfor (i = pcap->irq_base; i < (pcap->irq_base + PCAP_NIRQS); i++)\n\t\tirq_set_chip_and_handler(i, NULL, NULL);\n\n\tdestroy_workqueue(pcap->workqueue);\n}\n\nstatic int ezx_pcap_probe(struct spi_device *spi)\n{\n\tstruct pcap_platform_data *pdata = dev_get_platdata(&spi->dev);\n\tstruct pcap_chip *pcap;\n\tint i, adc_irq;\n\tint ret = -ENODEV;\n\n\t \n\tif (!pdata)\n\t\tgoto ret;\n\n\tpcap = devm_kzalloc(&spi->dev, sizeof(*pcap), GFP_KERNEL);\n\tif (!pcap) {\n\t\tret = -ENOMEM;\n\t\tgoto ret;\n\t}\n\n\tspin_lock_init(&pcap->io_lock);\n\tspin_lock_init(&pcap->adc_lock);\n\tINIT_WORK(&pcap->isr_work, pcap_isr_work);\n\tINIT_WORK(&pcap->msr_work, pcap_msr_work);\n\tspi_set_drvdata(spi, pcap);\n\n\t \n\tspi->bits_per_word = 32;\n\tspi->mode = SPI_MODE_0 | (pdata->config & PCAP_CS_AH ? SPI_CS_HIGH : 0);\n\tret = spi_setup(spi);\n\tif (ret)\n\t\tgoto ret;\n\n\tpcap->spi = spi;\n\n\t \n\tpcap->irq_base = pdata->irq_base;\n\tpcap->workqueue = create_singlethread_workqueue(\"pcapd\");\n\tif (!pcap->workqueue) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&spi->dev, \"can't create pcap thread\\n\");\n\t\tgoto ret;\n\t}\n\n\t \n\tif (!(pdata->config & PCAP_SECOND_PORT))\n\t\tezx_pcap_write(pcap, PCAP_REG_INT_SEL,\n\t\t\t\t\t(1 << PCAP_IRQ_ADCDONE2));\n\n\t \n\tfor (i = pcap->irq_base; i < (pcap->irq_base + PCAP_NIRQS); i++) {\n\t\tirq_set_chip_and_handler(i, &pcap_irq_chip, handle_simple_irq);\n\t\tirq_set_chip_data(i, pcap);\n\t\tirq_clear_status_flags(i, IRQ_NOREQUEST | IRQ_NOPROBE);\n\t}\n\n\t \n\tezx_pcap_write(pcap, PCAP_REG_MSR, PCAP_MASK_ALL_INTERRUPT);\n\tezx_pcap_write(pcap, PCAP_REG_ISR, PCAP_CLEAR_INTERRUPT_REGISTER);\n\tpcap->msr = PCAP_MASK_ALL_INTERRUPT;\n\n\tirq_set_irq_type(spi->irq, IRQ_TYPE_EDGE_RISING);\n\tirq_set_chained_handler_and_data(spi->irq, pcap_irq_handler, pcap);\n\tirq_set_irq_wake(spi->irq, 1);\n\n\t \n\tadc_irq = pcap_to_irq(pcap, (pdata->config & PCAP_SECOND_PORT) ?\n\t\t\t\t\tPCAP_IRQ_ADCDONE2 : PCAP_IRQ_ADCDONE);\n\n\tret = devm_request_irq(&spi->dev, adc_irq, pcap_adc_irq, 0, \"ADC\",\n\t\t\t\tpcap);\n\tif (ret)\n\t\tgoto free_irqchip;\n\n\t \n\tfor (i = 0; i < pdata->num_subdevs; i++) {\n\t\tret = pcap_add_subdev(pcap, &pdata->subdevs[i]);\n\t\tif (ret)\n\t\t\tgoto remove_subdevs;\n\t}\n\n\t \n\tif (pdata->init)\n\t\tpdata->init(pcap);\n\n\treturn 0;\n\nremove_subdevs:\n\tdevice_for_each_child(&spi->dev, NULL, pcap_remove_subdev);\nfree_irqchip:\n\tfor (i = pcap->irq_base; i < (pcap->irq_base + PCAP_NIRQS); i++)\n\t\tirq_set_chip_and_handler(i, NULL, NULL);\n \n\tdestroy_workqueue(pcap->workqueue);\nret:\n\treturn ret;\n}\n\nstatic struct spi_driver ezxpcap_driver = {\n\t.probe\t= ezx_pcap_probe,\n\t.remove = ezx_pcap_remove,\n\t.driver = {\n\t\t.name\t= \"ezx-pcap\",\n\t},\n};\n\nstatic int __init ezx_pcap_init(void)\n{\n\treturn spi_register_driver(&ezxpcap_driver);\n}\n\nstatic void __exit ezx_pcap_exit(void)\n{\n\tspi_unregister_driver(&ezxpcap_driver);\n}\n\nsubsys_initcall(ezx_pcap_init);\nmodule_exit(ezx_pcap_exit);\n\nMODULE_AUTHOR(\"Daniel Ribeiro / Harald Welte\");\nMODULE_DESCRIPTION(\"Motorola PCAP2 ASIC Driver\");\nMODULE_ALIAS(\"spi:ezx-pcap\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}