{
  "module_name": "lm3533-core.c",
  "hash_id": "cffa3e350f3cf31469fca41e1b9dc025d8e19fcd8f891f5b4a309f8ff99417eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/lm3533-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/gpio.h>\n#include <linux/i2c.h>\n#include <linux/mfd/core.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <linux/mfd/lm3533.h>\n\n\n#define LM3533_BOOST_OVP_MASK\t\t0x06\n#define LM3533_BOOST_OVP_SHIFT\t\t1\n\n#define LM3533_BOOST_FREQ_MASK\t\t0x01\n#define LM3533_BOOST_FREQ_SHIFT\t\t0\n\n#define LM3533_BL_ID_MASK\t\t1\n#define LM3533_LED_ID_MASK\t\t3\n#define LM3533_BL_ID_MAX\t\t1\n#define LM3533_LED_ID_MAX\t\t3\n\n#define LM3533_HVLED_ID_MAX\t\t2\n#define LM3533_LVLED_ID_MAX\t\t5\n\n#define LM3533_REG_OUTPUT_CONF1\t\t0x10\n#define LM3533_REG_OUTPUT_CONF2\t\t0x11\n#define LM3533_REG_BOOST_PWM\t\t0x2c\n\n#define LM3533_REG_MAX\t\t\t0xb2\n\n\nstatic struct mfd_cell lm3533_als_devs[] = {\n\t{\n\t\t.name\t= \"lm3533-als\",\n\t\t.id\t= -1,\n\t},\n};\n\nstatic struct mfd_cell lm3533_bl_devs[] = {\n\t{\n\t\t.name\t= \"lm3533-backlight\",\n\t\t.id\t= 0,\n\t},\n\t{\n\t\t.name\t= \"lm3533-backlight\",\n\t\t.id\t= 1,\n\t},\n};\n\nstatic struct mfd_cell lm3533_led_devs[] = {\n\t{\n\t\t.name\t= \"lm3533-leds\",\n\t\t.id\t= 0,\n\t},\n\t{\n\t\t.name\t= \"lm3533-leds\",\n\t\t.id\t= 1,\n\t},\n\t{\n\t\t.name\t= \"lm3533-leds\",\n\t\t.id\t= 2,\n\t},\n\t{\n\t\t.name\t= \"lm3533-leds\",\n\t\t.id\t= 3,\n\t},\n};\n\nint lm3533_read(struct lm3533 *lm3533, u8 reg, u8 *val)\n{\n\tint tmp;\n\tint ret;\n\n\tret = regmap_read(lm3533->regmap, reg, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(lm3533->dev, \"failed to read register %02x: %d\\n\",\n\t\t\t\t\t\t\t\treg, ret);\n\t\treturn ret;\n\t}\n\n\t*val = tmp;\n\n\tdev_dbg(lm3533->dev, \"read [%02x]: %02x\\n\", reg, *val);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lm3533_read);\n\nint lm3533_write(struct lm3533 *lm3533, u8 reg, u8 val)\n{\n\tint ret;\n\n\tdev_dbg(lm3533->dev, \"write [%02x]: %02x\\n\", reg, val);\n\n\tret = regmap_write(lm3533->regmap, reg, val);\n\tif (ret < 0) {\n\t\tdev_err(lm3533->dev, \"failed to write register %02x: %d\\n\",\n\t\t\t\t\t\t\t\treg, ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lm3533_write);\n\nint lm3533_update(struct lm3533 *lm3533, u8 reg, u8 val, u8 mask)\n{\n\tint ret;\n\n\tdev_dbg(lm3533->dev, \"update [%02x]: %02x/%02x\\n\", reg, val, mask);\n\n\tret = regmap_update_bits(lm3533->regmap, reg, mask, val);\n\tif (ret < 0) {\n\t\tdev_err(lm3533->dev, \"failed to update register %02x: %d\\n\",\n\t\t\t\t\t\t\t\treg, ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lm3533_update);\n\nstatic int lm3533_set_boost_freq(struct lm3533 *lm3533,\n\t\t\t\t\t\tenum lm3533_boost_freq freq)\n{\n\tint ret;\n\n\tret = lm3533_update(lm3533, LM3533_REG_BOOST_PWM,\n\t\t\t\t\tfreq << LM3533_BOOST_FREQ_SHIFT,\n\t\t\t\t\tLM3533_BOOST_FREQ_MASK);\n\tif (ret)\n\t\tdev_err(lm3533->dev, \"failed to set boost frequency\\n\");\n\n\treturn ret;\n}\n\n\nstatic int lm3533_set_boost_ovp(struct lm3533 *lm3533,\n\t\t\t\t\t\tenum lm3533_boost_ovp ovp)\n{\n\tint ret;\n\n\tret = lm3533_update(lm3533, LM3533_REG_BOOST_PWM,\n\t\t\t\t\tovp << LM3533_BOOST_OVP_SHIFT,\n\t\t\t\t\tLM3533_BOOST_OVP_MASK);\n\tif (ret)\n\t\tdev_err(lm3533->dev, \"failed to set boost ovp\\n\");\n\n\treturn ret;\n}\n\n \nstatic int lm3533_set_hvled_config(struct lm3533 *lm3533, u8 hvled, u8 bl)\n{\n\tu8 val;\n\tu8 mask;\n\tint shift;\n\tint ret;\n\n\tif (hvled == 0 || hvled > LM3533_HVLED_ID_MAX)\n\t\treturn -EINVAL;\n\n\tif (bl > LM3533_BL_ID_MAX)\n\t\treturn -EINVAL;\n\n\tshift = hvled - 1;\n\tmask = LM3533_BL_ID_MASK << shift;\n\tval = bl << shift;\n\n\tret = lm3533_update(lm3533, LM3533_REG_OUTPUT_CONF1, val, mask);\n\tif (ret)\n\t\tdev_err(lm3533->dev, \"failed to set hvled config\\n\");\n\n\treturn ret;\n}\n\n \nstatic int lm3533_set_lvled_config(struct lm3533 *lm3533, u8 lvled, u8 led)\n{\n\tu8 reg;\n\tu8 val;\n\tu8 mask;\n\tint shift;\n\tint ret;\n\n\tif (lvled == 0 || lvled > LM3533_LVLED_ID_MAX)\n\t\treturn -EINVAL;\n\n\tif (led > LM3533_LED_ID_MAX)\n\t\treturn -EINVAL;\n\n\tif (lvled < 4) {\n\t\treg = LM3533_REG_OUTPUT_CONF1;\n\t\tshift = 2 * lvled;\n\t} else {\n\t\treg = LM3533_REG_OUTPUT_CONF2;\n\t\tshift = 2 * (lvled - 4);\n\t}\n\n\tmask = LM3533_LED_ID_MASK << shift;\n\tval = led << shift;\n\n\tret = lm3533_update(lm3533, reg, val, mask);\n\tif (ret)\n\t\tdev_err(lm3533->dev, \"failed to set lvled config\\n\");\n\n\treturn ret;\n}\n\nstatic void lm3533_enable(struct lm3533 *lm3533)\n{\n\tif (gpio_is_valid(lm3533->gpio_hwen))\n\t\tgpio_set_value(lm3533->gpio_hwen, 1);\n}\n\nstatic void lm3533_disable(struct lm3533 *lm3533)\n{\n\tif (gpio_is_valid(lm3533->gpio_hwen))\n\t\tgpio_set_value(lm3533->gpio_hwen, 0);\n}\n\nenum lm3533_attribute_type {\n\tLM3533_ATTR_TYPE_BACKLIGHT,\n\tLM3533_ATTR_TYPE_LED,\n};\n\nstruct lm3533_device_attribute {\n\tstruct device_attribute dev_attr;\n\tenum lm3533_attribute_type type;\n\tunion {\n\t\tstruct {\n\t\t\tu8 id;\n\t\t} output;\n\t} u;\n};\n\n#define to_lm3533_dev_attr(_attr) \\\n\tcontainer_of(_attr, struct lm3533_device_attribute, dev_attr)\n\nstatic ssize_t show_output(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lm3533 *lm3533 = dev_get_drvdata(dev);\n\tstruct lm3533_device_attribute *lattr = to_lm3533_dev_attr(attr);\n\tint id = lattr->u.output.id;\n\tu8 reg;\n\tu8 val;\n\tu8 mask;\n\tint shift;\n\tint ret;\n\n\tif (lattr->type == LM3533_ATTR_TYPE_BACKLIGHT) {\n\t\treg = LM3533_REG_OUTPUT_CONF1;\n\t\tshift = id - 1;\n\t\tmask = LM3533_BL_ID_MASK << shift;\n\t} else {\n\t\tif (id < 4) {\n\t\t\treg = LM3533_REG_OUTPUT_CONF1;\n\t\t\tshift = 2 * id;\n\t\t} else {\n\t\t\treg = LM3533_REG_OUTPUT_CONF2;\n\t\t\tshift = 2 * (id - 4);\n\t\t}\n\t\tmask = LM3533_LED_ID_MASK << shift;\n\t}\n\n\tret = lm3533_read(lm3533, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = (val & mask) >> shift;\n\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t store_output(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct lm3533 *lm3533 = dev_get_drvdata(dev);\n\tstruct lm3533_device_attribute *lattr = to_lm3533_dev_attr(attr);\n\tint id = lattr->u.output.id;\n\tu8 val;\n\tint ret;\n\n\tif (kstrtou8(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (lattr->type == LM3533_ATTR_TYPE_BACKLIGHT)\n\t\tret = lm3533_set_hvled_config(lm3533, id, val);\n\telse\n\t\tret = lm3533_set_lvled_config(lm3533, id, val);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\n#define LM3533_OUTPUT_ATTR(_name, _mode, _show, _store, _type, _id) \\\n\tstruct lm3533_device_attribute lm3533_dev_attr_##_name = \\\n\t\t{ .dev_attr\t= __ATTR(_name, _mode, _show, _store), \\\n\t\t  .type\t\t= _type, \\\n\t\t  .u.output\t= { .id = _id }, }\n\n#define LM3533_OUTPUT_ATTR_RW(_name, _type, _id) \\\n\tLM3533_OUTPUT_ATTR(output_##_name, S_IRUGO | S_IWUSR, \\\n\t\t\t\t\tshow_output, store_output, _type, _id)\n\n#define LM3533_OUTPUT_HVLED_ATTR_RW(_nr) \\\n\tLM3533_OUTPUT_ATTR_RW(hvled##_nr, LM3533_ATTR_TYPE_BACKLIGHT, _nr)\n#define LM3533_OUTPUT_LVLED_ATTR_RW(_nr) \\\n\tLM3533_OUTPUT_ATTR_RW(lvled##_nr, LM3533_ATTR_TYPE_LED, _nr)\n \nstatic LM3533_OUTPUT_HVLED_ATTR_RW(1);\nstatic LM3533_OUTPUT_HVLED_ATTR_RW(2);\nstatic LM3533_OUTPUT_LVLED_ATTR_RW(1);\nstatic LM3533_OUTPUT_LVLED_ATTR_RW(2);\nstatic LM3533_OUTPUT_LVLED_ATTR_RW(3);\nstatic LM3533_OUTPUT_LVLED_ATTR_RW(4);\nstatic LM3533_OUTPUT_LVLED_ATTR_RW(5);\n\nstatic struct attribute *lm3533_attributes[] = {\n\t&lm3533_dev_attr_output_hvled1.dev_attr.attr,\n\t&lm3533_dev_attr_output_hvled2.dev_attr.attr,\n\t&lm3533_dev_attr_output_lvled1.dev_attr.attr,\n\t&lm3533_dev_attr_output_lvled2.dev_attr.attr,\n\t&lm3533_dev_attr_output_lvled3.dev_attr.attr,\n\t&lm3533_dev_attr_output_lvled4.dev_attr.attr,\n\t&lm3533_dev_attr_output_lvled5.dev_attr.attr,\n\tNULL,\n};\n\n#define to_dev_attr(_attr) \\\n\tcontainer_of(_attr, struct device_attribute, attr)\n\nstatic umode_t lm3533_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct lm3533 *lm3533 = dev_get_drvdata(dev);\n\tstruct device_attribute *dattr = to_dev_attr(attr);\n\tstruct lm3533_device_attribute *lattr = to_lm3533_dev_attr(dattr);\n\tenum lm3533_attribute_type type = lattr->type;\n\tumode_t mode = attr->mode;\n\n\tif (!lm3533->have_backlights && type == LM3533_ATTR_TYPE_BACKLIGHT)\n\t\tmode = 0;\n\telse if (!lm3533->have_leds && type == LM3533_ATTR_TYPE_LED)\n\t\tmode = 0;\n\n\treturn mode;\n};\n\nstatic struct attribute_group lm3533_attribute_group = {\n\t.is_visible\t= lm3533_attr_is_visible,\n\t.attrs\t\t= lm3533_attributes\n};\n\nstatic int lm3533_device_als_init(struct lm3533 *lm3533)\n{\n\tstruct lm3533_platform_data *pdata = dev_get_platdata(lm3533->dev);\n\tint ret;\n\n\tif (!pdata->als)\n\t\treturn 0;\n\n\tlm3533_als_devs[0].platform_data = pdata->als;\n\tlm3533_als_devs[0].pdata_size = sizeof(*pdata->als);\n\n\tret = mfd_add_devices(lm3533->dev, 0, lm3533_als_devs, 1, NULL,\n\t\t\t      0, NULL);\n\tif (ret) {\n\t\tdev_err(lm3533->dev, \"failed to add ALS device\\n\");\n\t\treturn ret;\n\t}\n\n\tlm3533->have_als = 1;\n\n\treturn 0;\n}\n\nstatic int lm3533_device_bl_init(struct lm3533 *lm3533)\n{\n\tstruct lm3533_platform_data *pdata = dev_get_platdata(lm3533->dev);\n\tint i;\n\tint ret;\n\n\tif (!pdata->backlights || pdata->num_backlights == 0)\n\t\treturn 0;\n\n\tif (pdata->num_backlights > ARRAY_SIZE(lm3533_bl_devs))\n\t\tpdata->num_backlights = ARRAY_SIZE(lm3533_bl_devs);\n\n\tfor (i = 0; i < pdata->num_backlights; ++i) {\n\t\tlm3533_bl_devs[i].platform_data = &pdata->backlights[i];\n\t\tlm3533_bl_devs[i].pdata_size = sizeof(pdata->backlights[i]);\n\t}\n\n\tret = mfd_add_devices(lm3533->dev, 0, lm3533_bl_devs,\n\t\t\t      pdata->num_backlights, NULL, 0, NULL);\n\tif (ret) {\n\t\tdev_err(lm3533->dev, \"failed to add backlight devices\\n\");\n\t\treturn ret;\n\t}\n\n\tlm3533->have_backlights = 1;\n\n\treturn 0;\n}\n\nstatic int lm3533_device_led_init(struct lm3533 *lm3533)\n{\n\tstruct lm3533_platform_data *pdata = dev_get_platdata(lm3533->dev);\n\tint i;\n\tint ret;\n\n\tif (!pdata->leds || pdata->num_leds == 0)\n\t\treturn 0;\n\n\tif (pdata->num_leds > ARRAY_SIZE(lm3533_led_devs))\n\t\tpdata->num_leds = ARRAY_SIZE(lm3533_led_devs);\n\n\tfor (i = 0; i < pdata->num_leds; ++i) {\n\t\tlm3533_led_devs[i].platform_data = &pdata->leds[i];\n\t\tlm3533_led_devs[i].pdata_size = sizeof(pdata->leds[i]);\n\t}\n\n\tret = mfd_add_devices(lm3533->dev, 0, lm3533_led_devs,\n\t\t\t      pdata->num_leds, NULL, 0, NULL);\n\tif (ret) {\n\t\tdev_err(lm3533->dev, \"failed to add LED devices\\n\");\n\t\treturn ret;\n\t}\n\n\tlm3533->have_leds = 1;\n\n\treturn 0;\n}\n\nstatic int lm3533_device_setup(struct lm3533 *lm3533,\n\t\t\t\t\tstruct lm3533_platform_data *pdata)\n{\n\tint ret;\n\n\tret = lm3533_set_boost_freq(lm3533, pdata->boost_freq);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lm3533_set_boost_ovp(lm3533, pdata->boost_ovp);\n}\n\nstatic int lm3533_device_init(struct lm3533 *lm3533)\n{\n\tstruct lm3533_platform_data *pdata = dev_get_platdata(lm3533->dev);\n\tint ret;\n\n\tdev_dbg(lm3533->dev, \"%s\\n\", __func__);\n\n\tif (!pdata) {\n\t\tdev_err(lm3533->dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlm3533->gpio_hwen = pdata->gpio_hwen;\n\n\tif (gpio_is_valid(lm3533->gpio_hwen)) {\n\t\tret = devm_gpio_request_one(lm3533->dev, lm3533->gpio_hwen,\n\t\t\t\t\tGPIOF_OUT_INIT_LOW, \"lm3533-hwen\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(lm3533->dev,\n\t\t\t\t\"failed to request HWEN GPIO %d\\n\",\n\t\t\t\tlm3533->gpio_hwen);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlm3533_enable(lm3533);\n\n\tret = lm3533_device_setup(lm3533, pdata);\n\tif (ret)\n\t\tgoto err_disable;\n\n\tlm3533_device_als_init(lm3533);\n\tlm3533_device_bl_init(lm3533);\n\tlm3533_device_led_init(lm3533);\n\n\tret = sysfs_create_group(&lm3533->dev->kobj, &lm3533_attribute_group);\n\tif (ret < 0) {\n\t\tdev_err(lm3533->dev, \"failed to create sysfs attributes\\n\");\n\t\tgoto err_unregister;\n\t}\n\n\treturn 0;\n\nerr_unregister:\n\tmfd_remove_devices(lm3533->dev);\nerr_disable:\n\tlm3533_disable(lm3533);\n\n\treturn ret;\n}\n\nstatic void lm3533_device_exit(struct lm3533 *lm3533)\n{\n\tdev_dbg(lm3533->dev, \"%s\\n\", __func__);\n\n\tsysfs_remove_group(&lm3533->dev->kobj, &lm3533_attribute_group);\n\n\tmfd_remove_devices(lm3533->dev);\n\tlm3533_disable(lm3533);\n}\n\nstatic bool lm3533_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x10 ... 0x2c:\n\tcase 0x30 ... 0x38:\n\tcase 0x40 ... 0x45:\n\tcase 0x50 ... 0x57:\n\tcase 0x60 ... 0x6e:\n\tcase 0x70 ... 0x75:\n\tcase 0x80 ... 0x85:\n\tcase 0x90 ... 0x95:\n\tcase 0xa0 ... 0xa5:\n\tcase 0xb0 ... 0xb2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool lm3533_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x34 ... 0x36:\t \n\tcase 0x37 ... 0x38:\t \n\tcase 0xb0 ... 0xb1:\t \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool lm3533_precious_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x34:\t\t \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= LM3533_REG_MAX,\n\t.readable_reg\t= lm3533_readable_register,\n\t.volatile_reg\t= lm3533_volatile_register,\n\t.precious_reg\t= lm3533_precious_register,\n};\n\nstatic int lm3533_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct lm3533 *lm3533;\n\n\tdev_dbg(&i2c->dev, \"%s\\n\", __func__);\n\n\tlm3533 = devm_kzalloc(&i2c->dev, sizeof(*lm3533), GFP_KERNEL);\n\tif (!lm3533)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, lm3533);\n\n\tlm3533->regmap = devm_regmap_init_i2c(i2c, &regmap_config);\n\tif (IS_ERR(lm3533->regmap))\n\t\treturn PTR_ERR(lm3533->regmap);\n\n\tlm3533->dev = &i2c->dev;\n\tlm3533->irq = i2c->irq;\n\n\treturn lm3533_device_init(lm3533);\n}\n\nstatic void lm3533_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct lm3533 *lm3533 = i2c_get_clientdata(i2c);\n\n\tdev_dbg(&i2c->dev, \"%s\\n\", __func__);\n\n\tlm3533_device_exit(lm3533);\n}\n\nstatic const struct i2c_device_id lm3533_i2c_ids[] = {\n\t{ \"lm3533\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, lm3533_i2c_ids);\n\nstatic struct i2c_driver lm3533_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"lm3533\",\n\t},\n\t.id_table\t= lm3533_i2c_ids,\n\t.probe\t\t= lm3533_i2c_probe,\n\t.remove\t\t= lm3533_i2c_remove,\n};\n\nstatic int __init lm3533_i2c_init(void)\n{\n\treturn i2c_add_driver(&lm3533_i2c_driver);\n}\nsubsys_initcall(lm3533_i2c_init);\n\nstatic void __exit lm3533_i2c_exit(void)\n{\n\ti2c_del_driver(&lm3533_i2c_driver);\n}\nmodule_exit(lm3533_i2c_exit);\n\nMODULE_AUTHOR(\"Johan Hovold <jhovold@gmail.com>\");\nMODULE_DESCRIPTION(\"LM3533 Core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}