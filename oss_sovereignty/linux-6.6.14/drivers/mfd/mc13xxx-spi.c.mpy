{
  "module_name": "mc13xxx-spi.c",
  "hash_id": "b557c5f93345e7c369381f285f38c9aa9f8bb555c5c8ebdf0fa3dbe08ee4504f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/mc13xxx-spi.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/mc13xxx.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/err.h>\n#include <linux/spi/spi.h>\n\n#include \"mc13xxx.h\"\n\nstatic const struct spi_device_id mc13xxx_device_id[] = {\n\t{\n\t\t.name = \"mc13783\",\n\t\t.driver_data = (kernel_ulong_t)&mc13xxx_variant_mc13783,\n\t}, {\n\t\t.name = \"mc13892\",\n\t\t.driver_data = (kernel_ulong_t)&mc13xxx_variant_mc13892,\n\t}, {\n\t\t.name = \"mc34708\",\n\t\t.driver_data = (kernel_ulong_t)&mc13xxx_variant_mc34708,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(spi, mc13xxx_device_id);\n\nstatic const struct of_device_id mc13xxx_dt_ids[] = {\n\t{ .compatible = \"fsl,mc13783\", .data = &mc13xxx_variant_mc13783, },\n\t{ .compatible = \"fsl,mc13892\", .data = &mc13xxx_variant_mc13892, },\n\t{ .compatible = \"fsl,mc34708\", .data = &mc13xxx_variant_mc34708, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mc13xxx_dt_ids);\n\nstatic const struct regmap_config mc13xxx_regmap_spi_config = {\n\t.reg_bits = 7,\n\t.pad_bits = 1,\n\t.val_bits = 24,\n\t.write_flag_mask = 0x80,\n\n\t.max_register = MC13XXX_NUMREGS,\n\n\t.cache_type = REGCACHE_NONE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int mc13xxx_spi_read(void *context, const void *reg, size_t reg_size,\n\t\t\t\tvoid *val, size_t val_size)\n{\n\tunsigned char w[4] = { *((unsigned char *) reg), 0, 0, 0};\n\tunsigned char r[4];\n\tunsigned char *p = val;\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct spi_transfer t = {\n\t\t.tx_buf = w,\n\t\t.rx_buf = r,\n\t\t.len = 4,\n\t};\n\n\tstruct spi_message m;\n\tint ret;\n\n\tif (val_size != 3 || reg_size != 1)\n\t\treturn -ENOTSUPP;\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\tret = spi_sync(spi, &m);\n\n\tmemcpy(p, &r[1], 3);\n\n\treturn ret;\n}\n\nstatic int mc13xxx_spi_write(void *context, const void *data, size_t count)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\tconst char *reg = data;\n\n\tif (count != 4)\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (*reg == MC13783_AUDIO_CODEC || *reg == MC13783_AUDIO_DAC)\n\t\tspi_write(spi, data, count);\n\n\treturn spi_write(spi, data, count);\n}\n\n \n\nstatic struct regmap_bus regmap_mc13xxx_bus = {\n\t.write = mc13xxx_spi_write,\n\t.read = mc13xxx_spi_read,\n};\n\nstatic int mc13xxx_spi_probe(struct spi_device *spi)\n{\n\tstruct mc13xxx *mc13xxx;\n\tint ret;\n\n\tmc13xxx = devm_kzalloc(&spi->dev, sizeof(*mc13xxx), GFP_KERNEL);\n\tif (!mc13xxx)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&spi->dev, mc13xxx);\n\n\tspi->mode = SPI_MODE_0 | SPI_CS_HIGH;\n\n\tmc13xxx->irq = spi->irq;\n\n\tspi->max_speed_hz = spi->max_speed_hz ? : 26000000;\n\tret = spi_setup(spi);\n\tif (ret)\n\t\treturn ret;\n\n\tmc13xxx->regmap = devm_regmap_init(&spi->dev, &regmap_mc13xxx_bus,\n\t\t\t\t\t   &spi->dev,\n\t\t\t\t\t   &mc13xxx_regmap_spi_config);\n\tif (IS_ERR(mc13xxx->regmap)) {\n\t\tret = PTR_ERR(mc13xxx->regmap);\n\t\tdev_err(&spi->dev, \"Failed to initialize regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (spi->dev.of_node) {\n\t\tconst struct of_device_id *of_id =\n\t\t\tof_match_device(mc13xxx_dt_ids, &spi->dev);\n\n\t\tmc13xxx->variant = of_id->data;\n\t} else {\n\t\tconst struct spi_device_id *id_entry = spi_get_device_id(spi);\n\n\t\tmc13xxx->variant = (void *)id_entry->driver_data;\n\t}\n\n\treturn mc13xxx_common_init(&spi->dev);\n}\n\nstatic void mc13xxx_spi_remove(struct spi_device *spi)\n{\n\tmc13xxx_common_exit(&spi->dev);\n}\n\nstatic struct spi_driver mc13xxx_spi_driver = {\n\t.id_table = mc13xxx_device_id,\n\t.driver = {\n\t\t.name = \"mc13xxx\",\n\t\t.of_match_table = mc13xxx_dt_ids,\n\t},\n\t.probe = mc13xxx_spi_probe,\n\t.remove = mc13xxx_spi_remove,\n};\n\nstatic int __init mc13xxx_init(void)\n{\n\treturn spi_register_driver(&mc13xxx_spi_driver);\n}\nsubsys_initcall(mc13xxx_init);\n\nstatic void __exit mc13xxx_exit(void)\n{\n\tspi_unregister_driver(&mc13xxx_spi_driver);\n}\nmodule_exit(mc13xxx_exit);\n\nMODULE_DESCRIPTION(\"Core driver for Freescale MC13XXX PMIC\");\nMODULE_AUTHOR(\"Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}