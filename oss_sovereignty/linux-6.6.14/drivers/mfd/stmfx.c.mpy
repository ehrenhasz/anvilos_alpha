{
  "module_name": "stmfx.c",
  "hash_id": "220bfcfd375789e232b01e4f594963970c4add412e656e205b854b8cedeeaf78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/stmfx.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/stmfx.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n\nstatic bool stmfx_reg_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STMFX_REG_SYS_CTRL:\n\tcase STMFX_REG_IRQ_SRC_EN:\n\tcase STMFX_REG_IRQ_PENDING:\n\tcase STMFX_REG_IRQ_GPI_PENDING1:\n\tcase STMFX_REG_IRQ_GPI_PENDING2:\n\tcase STMFX_REG_IRQ_GPI_PENDING3:\n\tcase STMFX_REG_GPIO_STATE1:\n\tcase STMFX_REG_GPIO_STATE2:\n\tcase STMFX_REG_GPIO_STATE3:\n\tcase STMFX_REG_IRQ_GPI_SRC1:\n\tcase STMFX_REG_IRQ_GPI_SRC2:\n\tcase STMFX_REG_IRQ_GPI_SRC3:\n\tcase STMFX_REG_GPO_SET1:\n\tcase STMFX_REG_GPO_SET2:\n\tcase STMFX_REG_GPO_SET3:\n\tcase STMFX_REG_GPO_CLR1:\n\tcase STMFX_REG_GPO_CLR2:\n\tcase STMFX_REG_GPO_CLR3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool stmfx_reg_writeable(struct device *dev, unsigned int reg)\n{\n\treturn (reg >= STMFX_REG_SYS_CTRL);\n}\n\nstatic const struct regmap_config stmfx_regmap_config = {\n\t.reg_bits\t= 8,\n\t.reg_stride\t= 1,\n\t.val_bits\t= 8,\n\t.max_register\t= STMFX_REG_MAX,\n\t.volatile_reg\t= stmfx_reg_volatile,\n\t.writeable_reg\t= stmfx_reg_writeable,\n\t.cache_type\t= REGCACHE_RBTREE,\n};\n\nstatic const struct resource stmfx_pinctrl_resources[] = {\n\tDEFINE_RES_IRQ(STMFX_REG_IRQ_SRC_EN_GPIO),\n};\n\nstatic const struct resource stmfx_idd_resources[] = {\n\tDEFINE_RES_IRQ(STMFX_REG_IRQ_SRC_EN_IDD),\n\tDEFINE_RES_IRQ(STMFX_REG_IRQ_SRC_EN_ERROR),\n};\n\nstatic const struct resource stmfx_ts_resources[] = {\n\tDEFINE_RES_IRQ(STMFX_REG_IRQ_SRC_EN_TS_DET),\n\tDEFINE_RES_IRQ(STMFX_REG_IRQ_SRC_EN_TS_NE),\n\tDEFINE_RES_IRQ(STMFX_REG_IRQ_SRC_EN_TS_TH),\n\tDEFINE_RES_IRQ(STMFX_REG_IRQ_SRC_EN_TS_FULL),\n\tDEFINE_RES_IRQ(STMFX_REG_IRQ_SRC_EN_TS_OVF),\n};\n\nstatic struct mfd_cell stmfx_cells[] = {\n\t{\n\t\t.of_compatible = \"st,stmfx-0300-pinctrl\",\n\t\t.name = \"stmfx-pinctrl\",\n\t\t.resources = stmfx_pinctrl_resources,\n\t\t.num_resources = ARRAY_SIZE(stmfx_pinctrl_resources),\n\t},\n\t{\n\t\t.of_compatible = \"st,stmfx-0300-idd\",\n\t\t.name = \"stmfx-idd\",\n\t\t.resources = stmfx_idd_resources,\n\t\t.num_resources = ARRAY_SIZE(stmfx_idd_resources),\n\t},\n\t{\n\t\t.of_compatible = \"st,stmfx-0300-ts\",\n\t\t.name = \"stmfx-ts\",\n\t\t.resources = stmfx_ts_resources,\n\t\t.num_resources = ARRAY_SIZE(stmfx_ts_resources),\n\t},\n};\n\nstatic u8 stmfx_func_to_mask(u32 func)\n{\n\tu8 mask = 0;\n\n\tif (func & STMFX_FUNC_GPIO)\n\t\tmask |= STMFX_REG_SYS_CTRL_GPIO_EN;\n\n\tif ((func & STMFX_FUNC_ALTGPIO_LOW) || (func & STMFX_FUNC_ALTGPIO_HIGH))\n\t\tmask |= STMFX_REG_SYS_CTRL_ALTGPIO_EN;\n\n\tif (func & STMFX_FUNC_TS)\n\t\tmask |= STMFX_REG_SYS_CTRL_TS_EN;\n\n\tif (func & STMFX_FUNC_IDD)\n\t\tmask |= STMFX_REG_SYS_CTRL_IDD_EN;\n\n\treturn mask;\n}\n\nint stmfx_function_enable(struct stmfx *stmfx, u32 func)\n{\n\tu32 sys_ctrl;\n\tu8 mask;\n\tint ret;\n\n\tret = regmap_read(stmfx->map, STMFX_REG_SYS_CTRL, &sys_ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (((func & STMFX_FUNC_IDD) || (func & STMFX_FUNC_TS)) &&\n\t    (sys_ctrl & STMFX_REG_SYS_CTRL_ALTGPIO_EN)) {\n\t\tdev_err(stmfx->dev, \"ALTGPIO function already enabled\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif ((func & STMFX_FUNC_ALTGPIO_LOW) &&\n\t    (sys_ctrl & STMFX_REG_SYS_CTRL_TS_EN)) {\n\t\tdev_err(stmfx->dev, \"TS in use, aGPIO[3:0] unavailable\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif ((func & STMFX_FUNC_ALTGPIO_HIGH) &&\n\t    (sys_ctrl & STMFX_REG_SYS_CTRL_IDD_EN)) {\n\t\tdev_err(stmfx->dev, \"IDD in use, aGPIO[7:4] unavailable\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tmask = stmfx_func_to_mask(func);\n\n\treturn regmap_update_bits(stmfx->map, STMFX_REG_SYS_CTRL, mask, mask);\n}\nEXPORT_SYMBOL_GPL(stmfx_function_enable);\n\nint stmfx_function_disable(struct stmfx *stmfx, u32 func)\n{\n\tu8 mask = stmfx_func_to_mask(func);\n\n\treturn regmap_update_bits(stmfx->map, STMFX_REG_SYS_CTRL, mask, 0);\n}\nEXPORT_SYMBOL_GPL(stmfx_function_disable);\n\nstatic void stmfx_irq_bus_lock(struct irq_data *data)\n{\n\tstruct stmfx *stmfx = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&stmfx->lock);\n}\n\nstatic void stmfx_irq_bus_sync_unlock(struct irq_data *data)\n{\n\tstruct stmfx *stmfx = irq_data_get_irq_chip_data(data);\n\n\tregmap_write(stmfx->map, STMFX_REG_IRQ_SRC_EN, stmfx->irq_src);\n\n\tmutex_unlock(&stmfx->lock);\n}\n\nstatic void stmfx_irq_mask(struct irq_data *data)\n{\n\tstruct stmfx *stmfx = irq_data_get_irq_chip_data(data);\n\n\tstmfx->irq_src &= ~BIT(data->hwirq % 8);\n}\n\nstatic void stmfx_irq_unmask(struct irq_data *data)\n{\n\tstruct stmfx *stmfx = irq_data_get_irq_chip_data(data);\n\n\tstmfx->irq_src |= BIT(data->hwirq % 8);\n}\n\nstatic struct irq_chip stmfx_irq_chip = {\n\t.name\t\t\t= \"stmfx-core\",\n\t.irq_bus_lock\t\t= stmfx_irq_bus_lock,\n\t.irq_bus_sync_unlock\t= stmfx_irq_bus_sync_unlock,\n\t.irq_mask\t\t= stmfx_irq_mask,\n\t.irq_unmask\t\t= stmfx_irq_unmask,\n};\n\nstatic irqreturn_t stmfx_irq_handler(int irq, void *data)\n{\n\tstruct stmfx *stmfx = data;\n\tunsigned long bits;\n\tu32 pending, ack;\n\tint n, ret;\n\n\tret = regmap_read(stmfx->map, STMFX_REG_IRQ_PENDING, &pending);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\t \n\tack = pending & ~BIT(STMFX_REG_IRQ_SRC_EN_GPIO);\n\tif (ack) {\n\t\tret = regmap_write(stmfx->map, STMFX_REG_IRQ_ACK, ack);\n\t\tif (ret)\n\t\t\treturn IRQ_NONE;\n\t}\n\n\tbits = pending;\n\tfor_each_set_bit(n, &bits, STMFX_REG_IRQ_SRC_MAX)\n\t\thandle_nested_irq(irq_find_mapping(stmfx->irq_domain, n));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int stmfx_irq_map(struct irq_domain *d, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tirq_set_chip_data(virq, d->host_data);\n\tirq_set_chip_and_handler(virq, &stmfx_irq_chip, handle_simple_irq);\n\tirq_set_nested_thread(virq, 1);\n\tirq_set_noprobe(virq);\n\n\treturn 0;\n}\n\nstatic void stmfx_irq_unmap(struct irq_domain *d, unsigned int virq)\n{\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tirq_set_chip_data(virq, NULL);\n}\n\nstatic const struct irq_domain_ops stmfx_irq_ops = {\n\t.map\t= stmfx_irq_map,\n\t.unmap\t= stmfx_irq_unmap,\n};\n\nstatic void stmfx_irq_exit(struct i2c_client *client)\n{\n\tstruct stmfx *stmfx = i2c_get_clientdata(client);\n\tint hwirq;\n\n\tfor (hwirq = 0; hwirq < STMFX_REG_IRQ_SRC_MAX; hwirq++)\n\t\tirq_dispose_mapping(irq_find_mapping(stmfx->irq_domain, hwirq));\n\n\tirq_domain_remove(stmfx->irq_domain);\n}\n\nstatic int stmfx_irq_init(struct i2c_client *client)\n{\n\tstruct stmfx *stmfx = i2c_get_clientdata(client);\n\tu32 irqoutpin = 0, irqtrigger;\n\tint ret;\n\n\tstmfx->irq_domain = irq_domain_add_simple(stmfx->dev->of_node,\n\t\t\t\t\t\t  STMFX_REG_IRQ_SRC_MAX, 0,\n\t\t\t\t\t\t  &stmfx_irq_ops, stmfx);\n\tif (!stmfx->irq_domain) {\n\t\tdev_err(stmfx->dev, \"Failed to create IRQ domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!of_property_read_bool(stmfx->dev->of_node, \"drive-open-drain\"))\n\t\tirqoutpin |= STMFX_REG_IRQ_OUT_PIN_TYPE;\n\n\tirqtrigger = irq_get_trigger_type(client->irq);\n\tif ((irqtrigger & IRQ_TYPE_EDGE_RISING) ||\n\t    (irqtrigger & IRQ_TYPE_LEVEL_HIGH))\n\t\tirqoutpin |= STMFX_REG_IRQ_OUT_PIN_POL;\n\n\tret = regmap_write(stmfx->map, STMFX_REG_IRQ_OUT_PIN, irqoutpin);\n\tif (ret)\n\t\tgoto irq_exit;\n\n\tret = devm_request_threaded_irq(stmfx->dev, client->irq,\n\t\t\t\t\tNULL, stmfx_irq_handler,\n\t\t\t\t\tirqtrigger | IRQF_ONESHOT,\n\t\t\t\t\t\"stmfx\", stmfx);\n\tif (ret)\n\t\tgoto irq_exit;\n\n\tstmfx->irq = client->irq;\n\n\treturn 0;\n\nirq_exit:\n\tstmfx_irq_exit(client);\n\n\treturn ret;\n}\n\nstatic int stmfx_chip_reset(struct stmfx *stmfx)\n{\n\tint ret;\n\n\tret = regmap_write(stmfx->map, STMFX_REG_SYS_CTRL,\n\t\t\t   STMFX_REG_SYS_CTRL_SWRST);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(STMFX_BOOT_TIME_MS);\n\n\treturn ret;\n}\n\nstatic int stmfx_chip_init(struct i2c_client *client)\n{\n\tstruct stmfx *stmfx = i2c_get_clientdata(client);\n\tu32 id;\n\tu8 version[2];\n\tint ret;\n\n\tstmfx->vdd = devm_regulator_get_optional(&client->dev, \"vdd\");\n\tret = PTR_ERR_OR_ZERO(stmfx->vdd);\n\tif (ret) {\n\t\tstmfx->vdd = NULL;\n\t\tif (ret != -ENODEV)\n\t\t\treturn dev_err_probe(&client->dev, ret, \"Failed to get VDD regulator\\n\");\n\t}\n\n\tif (stmfx->vdd) {\n\t\tret = regulator_enable(stmfx->vdd);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"VDD enable failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = regmap_read(stmfx->map, STMFX_REG_CHIP_ID, &id);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Error reading chip ID: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\tif (FIELD_GET(STMFX_REG_CHIP_ID_MASK, ~id) != (client->addr << 1)) {\n\t\tdev_err(&client->dev, \"Unknown chip ID: %#x\\n\", id);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_bulk_read(stmfx->map, STMFX_REG_FW_VERSION_MSB,\n\t\t\t       version, ARRAY_SIZE(version));\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Error reading FW version: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tdev_info(&client->dev, \"STMFX id: %#x, fw version: %x.%02x\\n\",\n\t\t id, version[0], version[1]);\n\n\tret = stmfx_chip_reset(stmfx);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to reset chip: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tif (stmfx->vdd)\n\t\tregulator_disable(stmfx->vdd);\n\n\treturn ret;\n}\n\nstatic void stmfx_chip_exit(struct i2c_client *client)\n{\n\tstruct stmfx *stmfx = i2c_get_clientdata(client);\n\n\tregmap_write(stmfx->map, STMFX_REG_IRQ_SRC_EN, 0);\n\tregmap_write(stmfx->map, STMFX_REG_SYS_CTRL, 0);\n\n\tif (stmfx->vdd) {\n\t\tint ret;\n\n\t\tret = regulator_disable(stmfx->vdd);\n\t\tif (ret)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to disable vdd regulator: %pe\\n\",\n\t\t\t\tERR_PTR(ret));\n\t}\n}\n\nstatic int stmfx_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct stmfx *stmfx;\n\tint ret;\n\n\tstmfx = devm_kzalloc(dev, sizeof(*stmfx), GFP_KERNEL);\n\tif (!stmfx)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, stmfx);\n\n\tstmfx->dev = dev;\n\n\tstmfx->map = devm_regmap_init_i2c(client, &stmfx_regmap_config);\n\tif (IS_ERR(stmfx->map)) {\n\t\tret = PTR_ERR(stmfx->map);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&stmfx->lock);\n\n\tret = stmfx_chip_init(client);\n\tif (ret) {\n\t\tif (ret == -ETIMEDOUT)\n\t\t\treturn -EPROBE_DEFER;\n\t\treturn ret;\n\t}\n\n\tif (client->irq < 0) {\n\t\tdev_err(dev, \"Failed to get IRQ: %d\\n\", client->irq);\n\t\tret = client->irq;\n\t\tgoto err_chip_exit;\n\t}\n\n\tret = stmfx_irq_init(client);\n\tif (ret)\n\t\tgoto err_chip_exit;\n\n\tret = devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,\n\t\t\t\t   stmfx_cells, ARRAY_SIZE(stmfx_cells), NULL,\n\t\t\t\t   0, stmfx->irq_domain);\n\tif (ret)\n\t\tgoto err_irq_exit;\n\n\treturn 0;\n\nerr_irq_exit:\n\tstmfx_irq_exit(client);\nerr_chip_exit:\n\tstmfx_chip_exit(client);\n\n\treturn ret;\n}\n\nstatic void stmfx_remove(struct i2c_client *client)\n{\n\tstmfx_irq_exit(client);\n\n\tstmfx_chip_exit(client);\n}\n\nstatic int stmfx_suspend(struct device *dev)\n{\n\tstruct stmfx *stmfx = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_raw_read(stmfx->map, STMFX_REG_SYS_CTRL,\n\t\t\t      &stmfx->bkp_sysctrl, sizeof(stmfx->bkp_sysctrl));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_raw_read(stmfx->map, STMFX_REG_IRQ_OUT_PIN,\n\t\t\t      &stmfx->bkp_irqoutpin,\n\t\t\t      sizeof(stmfx->bkp_irqoutpin));\n\tif (ret)\n\t\treturn ret;\n\n\tdisable_irq(stmfx->irq);\n\n\tif (stmfx->vdd)\n\t\treturn regulator_disable(stmfx->vdd);\n\n\treturn 0;\n}\n\nstatic int stmfx_resume(struct device *dev)\n{\n\tstruct stmfx *stmfx = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (stmfx->vdd) {\n\t\tret = regulator_enable(stmfx->vdd);\n\t\tif (ret) {\n\t\t\tdev_err(stmfx->dev,\n\t\t\t\t\"VDD enable failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = stmfx_chip_reset(stmfx);\n\tif (ret) {\n\t\tdev_err(stmfx->dev, \"Failed to reset chip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_raw_write(stmfx->map, STMFX_REG_SYS_CTRL,\n\t\t\t       &stmfx->bkp_sysctrl, sizeof(stmfx->bkp_sysctrl));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_raw_write(stmfx->map, STMFX_REG_IRQ_OUT_PIN,\n\t\t\t       &stmfx->bkp_irqoutpin,\n\t\t\t       sizeof(stmfx->bkp_irqoutpin));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_raw_write(stmfx->map, STMFX_REG_IRQ_SRC_EN,\n\t\t\t       &stmfx->irq_src, sizeof(stmfx->irq_src));\n\tif (ret)\n\t\treturn ret;\n\n\tenable_irq(stmfx->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(stmfx_dev_pm_ops, stmfx_suspend, stmfx_resume);\n\nstatic const struct of_device_id stmfx_of_match[] = {\n\t{ .compatible = \"st,stmfx-0300\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stmfx_of_match);\n\nstatic struct i2c_driver stmfx_driver = {\n\t.driver = {\n\t\t.name = \"stmfx-core\",\n\t\t.of_match_table = stmfx_of_match,\n\t\t.pm = pm_sleep_ptr(&stmfx_dev_pm_ops),\n\t},\n\t.probe = stmfx_probe,\n\t.remove = stmfx_remove,\n};\nmodule_i2c_driver(stmfx_driver);\n\nMODULE_DESCRIPTION(\"STMFX core driver\");\nMODULE_AUTHOR(\"Amelie Delaunay <amelie.delaunay@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}