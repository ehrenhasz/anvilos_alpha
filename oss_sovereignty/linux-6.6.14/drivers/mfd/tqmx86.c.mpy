{
  "module_name": "tqmx86.c",
  "hash_id": "a0fc494f421d1ef7ef8e8d0479738a4848c58a25f80bcf2539dd2f3aa8ef0629",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tqmx86.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/platform_data/i2c-ocores.h>\n#include <linux/platform_device.h>\n\n#define TQMX86_IOBASE\t0x180\n#define TQMX86_IOSIZE\t0x20\n#define TQMX86_IOBASE_I2C\t0x1a0\n#define TQMX86_IOSIZE_I2C\t0xa\n#define TQMX86_IOBASE_WATCHDOG\t0x18b\n#define TQMX86_IOSIZE_WATCHDOG\t0x2\n#define TQMX86_IOBASE_GPIO\t0x18d\n#define TQMX86_IOSIZE_GPIO\t0x4\n\n#define TQMX86_REG_BOARD_ID\t0x00\n#define TQMX86_REG_BOARD_ID_E38M\t1\n#define TQMX86_REG_BOARD_ID_50UC\t2\n#define TQMX86_REG_BOARD_ID_E38C\t3\n#define TQMX86_REG_BOARD_ID_60EB\t4\n#define TQMX86_REG_BOARD_ID_E39MS\t5\n#define TQMX86_REG_BOARD_ID_E39C1\t6\n#define TQMX86_REG_BOARD_ID_E39C2\t7\n#define TQMX86_REG_BOARD_ID_70EB\t8\n#define TQMX86_REG_BOARD_ID_80UC\t9\n#define TQMX86_REG_BOARD_ID_110EB\t11\n#define TQMX86_REG_BOARD_ID_E40M\t12\n#define TQMX86_REG_BOARD_ID_E40S\t13\n#define TQMX86_REG_BOARD_ID_E40C1\t14\n#define TQMX86_REG_BOARD_ID_E40C2\t15\n#define TQMX86_REG_BOARD_REV\t0x01\n#define TQMX86_REG_IO_EXT_INT\t0x06\n#define TQMX86_REG_IO_EXT_INT_NONE\t\t0\n#define TQMX86_REG_IO_EXT_INT_7\t\t\t1\n#define TQMX86_REG_IO_EXT_INT_9\t\t\t2\n#define TQMX86_REG_IO_EXT_INT_12\t\t3\n#define TQMX86_REG_IO_EXT_INT_MASK\t\t0x3\n#define TQMX86_REG_IO_EXT_INT_GPIO_SHIFT\t4\n#define TQMX86_REG_SAUC\t\t0x17\n\n#define TQMX86_REG_I2C_DETECT\t0x1a7\n#define TQMX86_REG_I2C_DETECT_SOFT\t\t0xa5\n\nstatic uint gpio_irq;\nmodule_param(gpio_irq, uint, 0);\nMODULE_PARM_DESC(gpio_irq, \"GPIO IRQ number (7, 9, 12)\");\n\nstatic const struct resource tqmx_i2c_soft_resources[] = {\n\tDEFINE_RES_IO(TQMX86_IOBASE_I2C, TQMX86_IOSIZE_I2C),\n};\n\nstatic const struct resource tqmx_watchdog_resources[] = {\n\tDEFINE_RES_IO(TQMX86_IOBASE_WATCHDOG, TQMX86_IOSIZE_WATCHDOG),\n};\n\n \nstatic struct resource tqmx_gpio_resources[] = {\n\tDEFINE_RES_IRQ(0),\n\tDEFINE_RES_IO(TQMX86_IOBASE_GPIO, TQMX86_IOSIZE_GPIO),\n};\n\nstatic struct i2c_board_info tqmx86_i2c_devices[] = {\n\t{\n\t\t \n\t\tI2C_BOARD_INFO(\"24c32\", 0x50),\n\t},\n};\n\nstatic struct ocores_i2c_platform_data ocores_platform_data = {\n\t.num_devices = ARRAY_SIZE(tqmx86_i2c_devices),\n\t.devices = tqmx86_i2c_devices,\n};\n\nstatic const struct mfd_cell tqmx86_i2c_soft_dev[] = {\n\t{\n\t\t.name = \"ocores-i2c\",\n\t\t.platform_data = &ocores_platform_data,\n\t\t.pdata_size = sizeof(ocores_platform_data),\n\t\t.resources = tqmx_i2c_soft_resources,\n\t\t.num_resources = ARRAY_SIZE(tqmx_i2c_soft_resources),\n\t},\n};\n\nstatic const struct mfd_cell tqmx86_devs[] = {\n\t{\n\t\t.name = \"tqmx86-wdt\",\n\t\t.resources = tqmx_watchdog_resources,\n\t\t.num_resources = ARRAY_SIZE(tqmx_watchdog_resources),\n\t\t.ignore_resource_conflicts = true,\n\t},\n\t{\n\t\t.name = \"tqmx86-gpio\",\n\t\t.resources = tqmx_gpio_resources,\n\t\t.num_resources = ARRAY_SIZE(tqmx_gpio_resources),\n\t\t.ignore_resource_conflicts = true,\n\t},\n};\n\nstatic const char *tqmx86_board_id_to_name(u8 board_id, u8 sauc)\n{\n\tswitch (board_id) {\n\tcase TQMX86_REG_BOARD_ID_E38M:\n\t\treturn \"TQMxE38M\";\n\tcase TQMX86_REG_BOARD_ID_50UC:\n\t\treturn \"TQMx50UC\";\n\tcase TQMX86_REG_BOARD_ID_E38C:\n\t\treturn \"TQMxE38C\";\n\tcase TQMX86_REG_BOARD_ID_60EB:\n\t\treturn \"TQMx60EB\";\n\tcase TQMX86_REG_BOARD_ID_E39MS:\n\t\treturn (sauc == 0xff) ? \"TQMxE39M\" : \"TQMxE39S\";\n\tcase TQMX86_REG_BOARD_ID_E39C1:\n\t\treturn \"TQMxE39C1\";\n\tcase TQMX86_REG_BOARD_ID_E39C2:\n\t\treturn \"TQMxE39C2\";\n\tcase TQMX86_REG_BOARD_ID_70EB:\n\t\treturn \"TQMx70EB\";\n\tcase TQMX86_REG_BOARD_ID_80UC:\n\t\treturn \"TQMx80UC\";\n\tcase TQMX86_REG_BOARD_ID_110EB:\n\t\treturn \"TQMx110EB\";\n\tcase TQMX86_REG_BOARD_ID_E40M:\n\t\treturn \"TQMxE40M\";\n\tcase TQMX86_REG_BOARD_ID_E40S:\n\t\treturn \"TQMxE40S\";\n\tcase TQMX86_REG_BOARD_ID_E40C1:\n\t\treturn \"TQMxE40C1\";\n\tcase TQMX86_REG_BOARD_ID_E40C2:\n\t\treturn \"TQMxE40C2\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic int tqmx86_board_id_to_clk_rate(struct device *dev, u8 board_id)\n{\n\tswitch (board_id) {\n\tcase TQMX86_REG_BOARD_ID_50UC:\n\tcase TQMX86_REG_BOARD_ID_60EB:\n\tcase TQMX86_REG_BOARD_ID_70EB:\n\tcase TQMX86_REG_BOARD_ID_80UC:\n\tcase TQMX86_REG_BOARD_ID_110EB:\n\tcase TQMX86_REG_BOARD_ID_E40M:\n\tcase TQMX86_REG_BOARD_ID_E40S:\n\tcase TQMX86_REG_BOARD_ID_E40C1:\n\tcase TQMX86_REG_BOARD_ID_E40C2:\n\t\treturn 24000;\n\tcase TQMX86_REG_BOARD_ID_E39MS:\n\tcase TQMX86_REG_BOARD_ID_E39C1:\n\tcase TQMX86_REG_BOARD_ID_E39C2:\n\t\treturn 25000;\n\tcase TQMX86_REG_BOARD_ID_E38M:\n\tcase TQMX86_REG_BOARD_ID_E38C:\n\t\treturn 33000;\n\tdefault:\n\t\tdev_warn(dev, \"unknown board %d, assuming 24MHz LPC clock\\n\",\n\t\t\t board_id);\n\t\treturn 24000;\n\t}\n}\n\nstatic int tqmx86_probe(struct platform_device *pdev)\n{\n\tu8 board_id, sauc, rev, i2c_det, io_ext_int_val;\n\tstruct device *dev = &pdev->dev;\n\tu8 gpio_irq_cfg, readback;\n\tconst char *board_name;\n\tvoid __iomem *io_base;\n\tint err;\n\n\tswitch (gpio_irq) {\n\tcase 0:\n\t\tgpio_irq_cfg = TQMX86_REG_IO_EXT_INT_NONE;\n\t\tbreak;\n\tcase 7:\n\t\tgpio_irq_cfg = TQMX86_REG_IO_EXT_INT_7;\n\t\tbreak;\n\tcase 9:\n\t\tgpio_irq_cfg = TQMX86_REG_IO_EXT_INT_9;\n\t\tbreak;\n\tcase 12:\n\t\tgpio_irq_cfg = TQMX86_REG_IO_EXT_INT_12;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"tqmx86: Invalid GPIO IRQ (%d)\\n\", gpio_irq);\n\t\treturn -EINVAL;\n\t}\n\n\tio_base = devm_ioport_map(dev, TQMX86_IOBASE, TQMX86_IOSIZE);\n\tif (!io_base)\n\t\treturn -ENOMEM;\n\n\tboard_id = ioread8(io_base + TQMX86_REG_BOARD_ID);\n\tsauc = ioread8(io_base + TQMX86_REG_SAUC);\n\tboard_name = tqmx86_board_id_to_name(board_id, sauc);\n\trev = ioread8(io_base + TQMX86_REG_BOARD_REV);\n\n\tdev_info(dev,\n\t\t \"Found %s - Board ID %d, PCB Revision %d, PLD Revision %d\\n\",\n\t\t board_name, board_id, rev >> 4, rev & 0xf);\n\n\t \n\ti2c_det = inb(TQMX86_REG_I2C_DETECT);\n\n\tif (gpio_irq_cfg) {\n\t\tio_ext_int_val =\n\t\t\tgpio_irq_cfg << TQMX86_REG_IO_EXT_INT_GPIO_SHIFT;\n\t\tiowrite8(io_ext_int_val, io_base + TQMX86_REG_IO_EXT_INT);\n\t\treadback = ioread8(io_base + TQMX86_REG_IO_EXT_INT);\n\t\tif (readback != io_ext_int_val) {\n\t\t\tdev_warn(dev, \"GPIO interrupts not supported.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\ttqmx_gpio_resources[0].start = gpio_irq;\n\t} else {\n\t\ttqmx_gpio_resources[0].flags = 0;\n\t}\n\n\tocores_platform_data.clock_khz = tqmx86_board_id_to_clk_rate(dev, board_id);\n\n\tif (i2c_det == TQMX86_REG_I2C_DETECT_SOFT) {\n\t\terr = devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,\n\t\t\t\t\t   tqmx86_i2c_soft_dev,\n\t\t\t\t\t   ARRAY_SIZE(tqmx86_i2c_soft_dev),\n\t\t\t\t\t   NULL, 0, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,\n\t\t\t\t    tqmx86_devs,\n\t\t\t\t    ARRAY_SIZE(tqmx86_devs),\n\t\t\t\t    NULL, 0, NULL);\n}\n\nstatic int tqmx86_create_platform_device(const struct dmi_system_id *id)\n{\n\tstruct platform_device *pdev;\n\tint err;\n\n\tpdev = platform_device_alloc(\"tqmx86\", -1);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\terr = platform_device_add(pdev);\n\tif (err)\n\t\tplatform_device_put(pdev);\n\n\treturn err;\n}\n\nstatic const struct dmi_system_id tqmx86_dmi_table[] __initconst = {\n\t{\n\t\t.ident = \"TQMX86\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TQ-Group\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TQMx\"),\n\t\t},\n\t\t.callback = tqmx86_create_platform_device,\n\t},\n\t{\n\t\t.ident = \"TQMX86\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TQ-Systems\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TQMx\"),\n\t\t},\n\t\t.callback = tqmx86_create_platform_device,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(dmi, tqmx86_dmi_table);\n\nstatic struct platform_driver tqmx86_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"tqmx86\",\n\t},\n\t.probe\t\t= tqmx86_probe,\n};\n\nstatic int __init tqmx86_init(void)\n{\n\tif (!dmi_check_system(tqmx86_dmi_table))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&tqmx86_driver);\n}\n\nmodule_init(tqmx86_init);\n\nMODULE_DESCRIPTION(\"TQMx86 PLD Core Driver\");\nMODULE_AUTHOR(\"Andrew Lunn <andrew@lunn.ch>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:tqmx86\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}