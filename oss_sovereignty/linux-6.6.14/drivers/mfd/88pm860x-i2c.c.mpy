{
  "module_name": "88pm860x-i2c.c",
  "hash_id": "1a92dd826b4cad0870be3a0a811b24fd7624732ac00a28d453725db778edc9a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/88pm860x-i2c.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/mfd/88pm860x.h>\n\nint pm860x_reg_read(struct i2c_client *i2c, int reg)\n{\n\tstruct pm860x_chip *chip = i2c_get_clientdata(i2c);\n\tstruct regmap *map = (i2c == chip->client) ? chip->regmap\n\t\t\t\t: chip->regmap_companion;\n\tunsigned int data;\n\tint ret;\n\n\tret = regmap_read(map, reg, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn (int)data;\n}\nEXPORT_SYMBOL(pm860x_reg_read);\n\nint pm860x_reg_write(struct i2c_client *i2c, int reg,\n\t\t     unsigned char data)\n{\n\tstruct pm860x_chip *chip = i2c_get_clientdata(i2c);\n\tstruct regmap *map = (i2c == chip->client) ? chip->regmap\n\t\t\t\t: chip->regmap_companion;\n\tint ret;\n\n\tret = regmap_write(map, reg, data);\n\treturn ret;\n}\nEXPORT_SYMBOL(pm860x_reg_write);\n\nint pm860x_bulk_read(struct i2c_client *i2c, int reg,\n\t\t     int count, unsigned char *buf)\n{\n\tstruct pm860x_chip *chip = i2c_get_clientdata(i2c);\n\tstruct regmap *map = (i2c == chip->client) ? chip->regmap\n\t\t\t\t: chip->regmap_companion;\n\tint ret;\n\n\tret = regmap_raw_read(map, reg, buf, count);\n\treturn ret;\n}\nEXPORT_SYMBOL(pm860x_bulk_read);\n\nint pm860x_bulk_write(struct i2c_client *i2c, int reg,\n\t\t      int count, unsigned char *buf)\n{\n\tstruct pm860x_chip *chip = i2c_get_clientdata(i2c);\n\tstruct regmap *map = (i2c == chip->client) ? chip->regmap\n\t\t\t\t: chip->regmap_companion;\n\tint ret;\n\n\tret = regmap_raw_write(map, reg, buf, count);\n\treturn ret;\n}\nEXPORT_SYMBOL(pm860x_bulk_write);\n\nint pm860x_set_bits(struct i2c_client *i2c, int reg,\n\t\t    unsigned char mask, unsigned char data)\n{\n\tstruct pm860x_chip *chip = i2c_get_clientdata(i2c);\n\tstruct regmap *map = (i2c == chip->client) ? chip->regmap\n\t\t\t\t: chip->regmap_companion;\n\tint ret;\n\n\tret = regmap_update_bits(map, reg, mask, data);\n\treturn ret;\n}\nEXPORT_SYMBOL(pm860x_set_bits);\n\nstatic int read_device(struct i2c_client *i2c, int reg,\n\t\t       int bytes, void *dest)\n{\n\tunsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX + 3];\n\tunsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX + 2];\n\tstruct i2c_adapter *adap = i2c->adapter;\n\tstruct i2c_msg msg[2] = {\n\t\t\t\t\t{\n\t\t\t\t\t\t.addr = i2c->addr,\n\t\t\t\t\t\t.flags = 0,\n\t\t\t\t\t\t.len = 1,\n\t\t\t\t\t\t.buf = msgbuf0\n\t\t\t\t\t},\n\t\t\t\t\t{\t.addr = i2c->addr,\n\t\t\t\t\t\t.flags = I2C_M_RD,\n\t\t\t\t\t\t.len = 0,\n\t\t\t\t\t\t.buf = msgbuf1\n\t\t\t\t\t},\n\t\t\t\t};\n\tint num = 1, ret = 0;\n\n\tif (dest == NULL)\n\t\treturn -EINVAL;\n\tmsgbuf0[0] = (unsigned char)reg;\t \n\tmsg[1].len = bytes;\n\n\t \n\tif (bytes > 0)\n\t\tnum = 2;\n\tret = adap->algo->master_xfer(adap, msg, num);\n\tmemcpy(dest, msgbuf1, bytes);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int write_device(struct i2c_client *i2c, int reg,\n\t\t\tint bytes, void *src)\n{\n\tunsigned char buf[2];\n\tstruct i2c_adapter *adap = i2c->adapter;\n\tstruct i2c_msg msg;\n\tint ret;\n\n\tbuf[0] = (unsigned char)reg;\n\tmemcpy(&buf[1], src, bytes);\n\tmsg.addr = i2c->addr;\n\tmsg.flags = 0;\n\tmsg.len = bytes + 1;\n\tmsg.buf = buf;\n\n\tret = adap->algo->master_xfer(adap, &msg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nint pm860x_page_reg_write(struct i2c_client *i2c, int reg,\n\t\t\t  unsigned char data)\n{\n\tunsigned char zero;\n\tint ret;\n\n\ti2c_lock_bus(i2c->adapter, I2C_LOCK_SEGMENT);\n\tread_device(i2c, 0xFA, 0, &zero);\n\tread_device(i2c, 0xFB, 0, &zero);\n\tread_device(i2c, 0xFF, 0, &zero);\n\tret = write_device(i2c, reg, 1, &data);\n\tread_device(i2c, 0xFE, 0, &zero);\n\tread_device(i2c, 0xFC, 0, &zero);\n\ti2c_unlock_bus(i2c->adapter, I2C_LOCK_SEGMENT);\n\treturn ret;\n}\nEXPORT_SYMBOL(pm860x_page_reg_write);\n\nint pm860x_page_bulk_read(struct i2c_client *i2c, int reg,\n\t\t\t  int count, unsigned char *buf)\n{\n\tunsigned char zero = 0;\n\tint ret;\n\n\ti2c_lock_bus(i2c->adapter, I2C_LOCK_SEGMENT);\n\tread_device(i2c, 0xfa, 0, &zero);\n\tread_device(i2c, 0xfb, 0, &zero);\n\tread_device(i2c, 0xff, 0, &zero);\n\tret = read_device(i2c, reg, count, buf);\n\tread_device(i2c, 0xFE, 0, &zero);\n\tread_device(i2c, 0xFC, 0, &zero);\n\ti2c_unlock_bus(i2c->adapter, I2C_LOCK_SEGMENT);\n\treturn ret;\n}\nEXPORT_SYMBOL(pm860x_page_bulk_read);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}