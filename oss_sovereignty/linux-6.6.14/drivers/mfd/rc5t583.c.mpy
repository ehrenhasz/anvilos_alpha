{
  "module_name": "rc5t583.c",
  "hash_id": "1244118b1331d5fda9cec40a2108841af7b422a767e9c374cceed2645656cf53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rc5t583.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/rc5t583.h>\n#include <linux/regmap.h>\n\n#define RICOH_ONOFFSEL_REG\t0x10\n#define RICOH_SWCTL_REG\t\t0x5E\n\nstruct deepsleep_control_data {\n\tu8 reg_add;\n\tu8 ds_pos_bit;\n};\n\n#define DEEPSLEEP_INIT(_id, _reg, _pos)\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.reg_add = RC5T583_##_reg,\t\\\n\t\t.ds_pos_bit = _pos,\t\t\\\n\t}\n\nstatic struct deepsleep_control_data deepsleep_data[] = {\n\tDEEPSLEEP_INIT(DC0, SLPSEQ1, 0),\n\tDEEPSLEEP_INIT(DC1, SLPSEQ1, 4),\n\tDEEPSLEEP_INIT(DC2, SLPSEQ2, 0),\n\tDEEPSLEEP_INIT(DC3, SLPSEQ2, 4),\n\tDEEPSLEEP_INIT(LDO0, SLPSEQ3, 0),\n\tDEEPSLEEP_INIT(LDO1, SLPSEQ3, 4),\n\tDEEPSLEEP_INIT(LDO2, SLPSEQ4, 0),\n\tDEEPSLEEP_INIT(LDO3, SLPSEQ4, 4),\n\tDEEPSLEEP_INIT(LDO4, SLPSEQ5, 0),\n\tDEEPSLEEP_INIT(LDO5, SLPSEQ5, 4),\n\tDEEPSLEEP_INIT(LDO6, SLPSEQ6, 0),\n\tDEEPSLEEP_INIT(LDO7, SLPSEQ6, 4),\n\tDEEPSLEEP_INIT(LDO8, SLPSEQ7, 0),\n\tDEEPSLEEP_INIT(LDO9, SLPSEQ7, 4),\n\tDEEPSLEEP_INIT(PSO0, SLPSEQ8, 0),\n\tDEEPSLEEP_INIT(PSO1, SLPSEQ8, 4),\n\tDEEPSLEEP_INIT(PSO2, SLPSEQ9, 0),\n\tDEEPSLEEP_INIT(PSO3, SLPSEQ9, 4),\n\tDEEPSLEEP_INIT(PSO4, SLPSEQ10, 0),\n\tDEEPSLEEP_INIT(PSO5, SLPSEQ10, 4),\n\tDEEPSLEEP_INIT(PSO6, SLPSEQ11, 0),\n\tDEEPSLEEP_INIT(PSO7, SLPSEQ11, 4),\n};\n\n#define EXT_PWR_REQ\t\t\\\n\t(RC5T583_EXT_PWRREQ1_CONTROL | RC5T583_EXT_PWRREQ2_CONTROL)\n\nstatic const struct mfd_cell rc5t583_subdevs[] = {\n\t{.name = \"rc5t583-gpio\",},\n\t{.name = \"rc5t583-regulator\",},\n\t{.name = \"rc5t583-rtc\",      },\n\t{.name = \"rc5t583-key\",      }\n};\n\nstatic int __rc5t583_set_ext_pwrreq1_control(struct device *dev,\n\tint id, int ext_pwr, int slots)\n{\n\tint ret;\n\tuint8_t sleepseq_val = 0;\n\tunsigned int en_bit;\n\tunsigned int slot_bit;\n\n\tif (id == RC5T583_DS_DC0) {\n\t\tdev_err(dev, \"PWRREQ1 is invalid control for rail %d\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\ten_bit = deepsleep_data[id].ds_pos_bit;\n\tslot_bit = en_bit + 1;\n\tret = rc5t583_read(dev, deepsleep_data[id].reg_add, &sleepseq_val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error in reading reg 0x%x\\n\",\n\t\t\t\tdeepsleep_data[id].reg_add);\n\t\treturn ret;\n\t}\n\n\tsleepseq_val &= ~(0xF << en_bit);\n\tsleepseq_val |= BIT(en_bit);\n\tsleepseq_val |= ((slots & 0x7) << slot_bit);\n\tret = rc5t583_set_bits(dev, RICOH_ONOFFSEL_REG, BIT(1));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error in updating the 0x%02x register\\n\",\n\t\t\t\tRICOH_ONOFFSEL_REG);\n\t\treturn ret;\n\t}\n\n\tret = rc5t583_write(dev, deepsleep_data[id].reg_add, sleepseq_val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error in writing reg 0x%x\\n\",\n\t\t\t\tdeepsleep_data[id].reg_add);\n\t\treturn ret;\n\t}\n\n\tif (id == RC5T583_DS_LDO4) {\n\t\tret = rc5t583_write(dev, RICOH_SWCTL_REG, 0x1);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"Error in writing reg 0x%x\\n\",\n\t\t\t\tRICOH_SWCTL_REG);\n\t}\n\treturn ret;\n}\n\nstatic int __rc5t583_set_ext_pwrreq2_control(struct device *dev,\n\tint id, int ext_pwr)\n{\n\tint ret;\n\n\tif (id != RC5T583_DS_DC0) {\n\t\tdev_err(dev, \"PWRREQ2 is invalid control for rail %d\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rc5t583_set_bits(dev, RICOH_ONOFFSEL_REG, BIT(2));\n\tif (ret < 0)\n\t\tdev_err(dev, \"Error in updating the ONOFFSEL 0x10 register\\n\");\n\treturn ret;\n}\n\nint rc5t583_ext_power_req_config(struct device *dev, int ds_id,\n\tint ext_pwr_req, int deepsleep_slot_nr)\n{\n\tif ((ext_pwr_req & EXT_PWR_REQ) == EXT_PWR_REQ)\n\t\treturn -EINVAL;\n\n\tif (ext_pwr_req & RC5T583_EXT_PWRREQ1_CONTROL)\n\t\treturn __rc5t583_set_ext_pwrreq1_control(dev, ds_id,\n\t\t\t\text_pwr_req, deepsleep_slot_nr);\n\n\tif (ext_pwr_req & RC5T583_EXT_PWRREQ2_CONTROL)\n\t\treturn __rc5t583_set_ext_pwrreq2_control(dev,\n\t\t\tds_id, ext_pwr_req);\n\treturn 0;\n}\nEXPORT_SYMBOL(rc5t583_ext_power_req_config);\n\nstatic int rc5t583_clear_ext_power_req(struct rc5t583 *rc5t583,\n\tstruct rc5t583_platform_data *pdata)\n{\n\tint ret;\n\tint i;\n\tuint8_t on_off_val = 0;\n\n\t \n\tif (pdata->enable_shutdown)\n\t\ton_off_val = 0x1;\n\n\tret = rc5t583_write(rc5t583->dev, RICOH_ONOFFSEL_REG, on_off_val);\n\tif (ret < 0)\n\t\tdev_warn(rc5t583->dev, \"Error in writing reg %d error: %d\\n\",\n\t\t\t\t\tRICOH_ONOFFSEL_REG, ret);\n\n\tret = rc5t583_write(rc5t583->dev, RICOH_SWCTL_REG, 0x0);\n\tif (ret < 0)\n\t\tdev_warn(rc5t583->dev, \"Error in writing reg %d error: %d\\n\",\n\t\t\t\t\tRICOH_SWCTL_REG, ret);\n\n\t \n\tfor (i = RC5T583_SLPSEQ1; i <= RC5T583_SLPSEQ11; ++i) {\n\t\tret = rc5t583_write(rc5t583->dev, i, 0x0);\n\t\tif (ret < 0)\n\t\t\tdev_warn(rc5t583->dev,\n\t\t\t\t\"Error in writing reg 0x%02x error: %d\\n\",\n\t\t\t\ti, ret);\n\t}\n\treturn 0;\n}\n\nstatic bool volatile_reg(struct device *dev, unsigned int reg)\n{\n\t \n\tswitch (reg) {\n\tcase RC5T583_INT_EN_SYS1:\n\tcase RC5T583_INT_EN_SYS2:\n\tcase RC5T583_INT_EN_DCDC:\n\tcase RC5T583_INT_EN_RTC:\n\tcase RC5T583_INT_EN_ADC1:\n\tcase RC5T583_INT_EN_ADC2:\n\tcase RC5T583_INT_EN_ADC3:\n\tcase RC5T583_GPIO_GPEDGE1:\n\tcase RC5T583_GPIO_GPEDGE2:\n\tcase RC5T583_GPIO_EN_INT:\n\t\treturn false;\n\n\tcase RC5T583_GPIO_MON_IOIN:\n\t\t \n\t\treturn true;\n\n\tdefault:\n\t\t \n\t\tif ((reg >= RC5T583_GPIO_IOSEL) &&\n\t\t\t\t(reg <= RC5T583_GPIO_GPOFUNC))\n\t\t\treturn false;\n\n\t\t \n\t\tif ((reg >= RC5T583_SLPSEQ1) && (reg <= RC5T583_SLPSEQ11))\n\t\t\treturn false;\n\n\t\t \n\t\tif ((reg >= RC5T583_REG_DC0CTL) && (reg <= RC5T583_REG_SR3CTL))\n\t\t\treturn false;\n\t\tif ((reg >= RC5T583_REG_LDOEN1) &&\n\t\t\t\t\t(reg <= RC5T583_REG_LDO9DAC_DS))\n\t\t\treturn false;\n\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic const struct regmap_config rc5t583_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_reg = volatile_reg,\n\t.max_register = RC5T583_MAX_REG,\n\t.num_reg_defaults_raw = RC5T583_NUM_REGS,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int rc5t583_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct rc5t583 *rc5t583;\n\tstruct rc5t583_platform_data *pdata = dev_get_platdata(&i2c->dev);\n\tint ret;\n\n\tif (!pdata) {\n\t\tdev_err(&i2c->dev, \"Err: Platform data not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc5t583 = devm_kzalloc(&i2c->dev, sizeof(*rc5t583), GFP_KERNEL);\n\tif (!rc5t583)\n\t\treturn -ENOMEM;\n\n\trc5t583->dev = &i2c->dev;\n\ti2c_set_clientdata(i2c, rc5t583);\n\n\trc5t583->regmap = devm_regmap_init_i2c(i2c, &rc5t583_regmap_config);\n\tif (IS_ERR(rc5t583->regmap)) {\n\t\tret = PTR_ERR(rc5t583->regmap);\n\t\tdev_err(&i2c->dev, \"regmap initialization failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rc5t583_clear_ext_power_req(rc5t583, pdata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (i2c->irq) {\n\t\tret = rc5t583_irq_init(rc5t583, i2c->irq, pdata->irq_base);\n\t\t \n\t\tif (ret)\n\t\t\tdev_warn(&i2c->dev, \"IRQ init failed: %d\\n\", ret);\n\t}\n\n\tret = devm_mfd_add_devices(rc5t583->dev, -1, rc5t583_subdevs,\n\t\t\t\t   ARRAY_SIZE(rc5t583_subdevs), NULL, 0, NULL);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"add mfd devices failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id rc5t583_i2c_id[] = {\n\t{.name = \"rc5t583\", .driver_data = 0},\n\t{}\n};\n\nstatic struct i2c_driver rc5t583_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"rc5t583\",\n\t\t   },\n\t.probe = rc5t583_i2c_probe,\n\t.id_table = rc5t583_i2c_id,\n};\n\nstatic int __init rc5t583_i2c_init(void)\n{\n\treturn i2c_add_driver(&rc5t583_i2c_driver);\n}\nsubsys_initcall(rc5t583_i2c_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}