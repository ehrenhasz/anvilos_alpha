{
  "module_name": "db8500-prcmu.c",
  "hash_id": "139f9ab9816e2f5fca9d0357848e5d77f3294510c6f946c95ea83f1b37fe5931",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/db8500-prcmu.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/completion.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/dbx500-prcmu.h>\n#include <linux/mfd/abx500/ab8500.h>\n#include <linux/regulator/db8500-prcmu.h>\n#include <linux/regulator/machine.h>\n#include \"db8500-prcmu-regs.h\"\n\n \n#define PRCM_AVS_BASE\t\t0x2FC\n#define PRCM_AVS_VBB_RET\t(PRCM_AVS_BASE + 0x0)\n#define PRCM_AVS_VBB_MAX_OPP\t(PRCM_AVS_BASE + 0x1)\n#define PRCM_AVS_VBB_100_OPP\t(PRCM_AVS_BASE + 0x2)\n#define PRCM_AVS_VBB_50_OPP\t(PRCM_AVS_BASE + 0x3)\n#define PRCM_AVS_VARM_MAX_OPP\t(PRCM_AVS_BASE + 0x4)\n#define PRCM_AVS_VARM_100_OPP\t(PRCM_AVS_BASE + 0x5)\n#define PRCM_AVS_VARM_50_OPP\t(PRCM_AVS_BASE + 0x6)\n#define PRCM_AVS_VARM_RET\t(PRCM_AVS_BASE + 0x7)\n#define PRCM_AVS_VAPE_100_OPP\t(PRCM_AVS_BASE + 0x8)\n#define PRCM_AVS_VAPE_50_OPP\t(PRCM_AVS_BASE + 0x9)\n#define PRCM_AVS_VMOD_100_OPP\t(PRCM_AVS_BASE + 0xA)\n#define PRCM_AVS_VMOD_50_OPP\t(PRCM_AVS_BASE + 0xB)\n#define PRCM_AVS_VSAFE\t\t(PRCM_AVS_BASE + 0xC)\n\n#define PRCM_AVS_VOLTAGE\t\t0\n#define PRCM_AVS_VOLTAGE_MASK\t\t0x3f\n#define PRCM_AVS_ISSLOWSTARTUP\t\t6\n#define PRCM_AVS_ISSLOWSTARTUP_MASK\t(1 << PRCM_AVS_ISSLOWSTARTUP)\n#define PRCM_AVS_ISMODEENABLE\t\t7\n#define PRCM_AVS_ISMODEENABLE_MASK\t(1 << PRCM_AVS_ISMODEENABLE)\n\n#define PRCM_BOOT_STATUS\t0xFFF\n#define PRCM_ROMCODE_A2P\t0xFFE\n#define PRCM_ROMCODE_P2A\t0xFFD\n#define PRCM_XP70_CUR_PWR_STATE 0xFFC       \n\n#define PRCM_SW_RST_REASON 0xFF8  \n\n#define _PRCM_MBOX_HEADER\t\t0xFE8  \n#define PRCM_MBOX_HEADER_REQ_MB0\t(_PRCM_MBOX_HEADER + 0x0)\n#define PRCM_MBOX_HEADER_REQ_MB1\t(_PRCM_MBOX_HEADER + 0x1)\n#define PRCM_MBOX_HEADER_REQ_MB2\t(_PRCM_MBOX_HEADER + 0x2)\n#define PRCM_MBOX_HEADER_REQ_MB3\t(_PRCM_MBOX_HEADER + 0x3)\n#define PRCM_MBOX_HEADER_REQ_MB4\t(_PRCM_MBOX_HEADER + 0x4)\n#define PRCM_MBOX_HEADER_REQ_MB5\t(_PRCM_MBOX_HEADER + 0x5)\n#define PRCM_MBOX_HEADER_ACK_MB0\t(_PRCM_MBOX_HEADER + 0x8)\n\n \n#define PRCM_REQ_MB0 0xFDC  \n#define PRCM_REQ_MB1 0xFD0  \n#define PRCM_REQ_MB2 0xFC0  \n#define PRCM_REQ_MB3 0xE4C  \n#define PRCM_REQ_MB4 0xE48  \n#define PRCM_REQ_MB5 0xE44  \n\n \n#define PRCM_ACK_MB0 0xE08  \n#define PRCM_ACK_MB1 0xE04  \n#define PRCM_ACK_MB2 0xE00  \n#define PRCM_ACK_MB3 0xDFC  \n#define PRCM_ACK_MB4 0xDF8  \n#define PRCM_ACK_MB5 0xDF4  \n\n \n#define MB0H_POWER_STATE_TRANS\t\t0\n#define MB0H_CONFIG_WAKEUPS_EXE\t\t1\n#define MB0H_READ_WAKEUP_ACK\t\t3\n#define MB0H_CONFIG_WAKEUPS_SLEEP\t4\n\n#define MB0H_WAKEUP_EXE 2\n#define MB0H_WAKEUP_SLEEP 5\n\n \n#define PRCM_REQ_MB0_AP_POWER_STATE\t(PRCM_REQ_MB0 + 0x0)\n#define PRCM_REQ_MB0_AP_PLL_STATE\t(PRCM_REQ_MB0 + 0x1)\n#define PRCM_REQ_MB0_ULP_CLOCK_STATE\t(PRCM_REQ_MB0 + 0x2)\n#define PRCM_REQ_MB0_DO_NOT_WFI\t\t(PRCM_REQ_MB0 + 0x3)\n#define PRCM_REQ_MB0_WAKEUP_8500\t(PRCM_REQ_MB0 + 0x4)\n#define PRCM_REQ_MB0_WAKEUP_4500\t(PRCM_REQ_MB0 + 0x8)\n\n \n#define PRCM_ACK_MB0_AP_PWRSTTR_STATUS\t(PRCM_ACK_MB0 + 0x0)\n#define PRCM_ACK_MB0_READ_POINTER\t(PRCM_ACK_MB0 + 0x1)\n#define PRCM_ACK_MB0_WAKEUP_0_8500\t(PRCM_ACK_MB0 + 0x4)\n#define PRCM_ACK_MB0_WAKEUP_0_4500\t(PRCM_ACK_MB0 + 0x8)\n#define PRCM_ACK_MB0_WAKEUP_1_8500\t(PRCM_ACK_MB0 + 0x1C)\n#define PRCM_ACK_MB0_WAKEUP_1_4500\t(PRCM_ACK_MB0 + 0x20)\n#define PRCM_ACK_MB0_EVENT_4500_NUMBERS\t20\n\n \n#define MB1H_ARM_APE_OPP 0x0\n#define MB1H_RESET_MODEM 0x2\n#define MB1H_REQUEST_APE_OPP_100_VOLT 0x3\n#define MB1H_RELEASE_APE_OPP_100_VOLT 0x4\n#define MB1H_RELEASE_USB_WAKEUP 0x5\n#define MB1H_PLL_ON_OFF 0x6\n\n \n#define PRCM_REQ_MB1_ARM_OPP\t\t\t(PRCM_REQ_MB1 + 0x0)\n#define PRCM_REQ_MB1_APE_OPP\t\t\t(PRCM_REQ_MB1 + 0x1)\n#define PRCM_REQ_MB1_PLL_ON_OFF\t\t\t(PRCM_REQ_MB1 + 0x4)\n#define PLL_SOC0_OFF\t0x1\n#define PLL_SOC0_ON\t0x2\n#define PLL_SOC1_OFF\t0x4\n#define PLL_SOC1_ON\t0x8\n\n \n#define PRCM_ACK_MB1_CURRENT_ARM_OPP\t(PRCM_ACK_MB1 + 0x0)\n#define PRCM_ACK_MB1_CURRENT_APE_OPP\t(PRCM_ACK_MB1 + 0x1)\n#define PRCM_ACK_MB1_APE_VOLTAGE_STATUS\t(PRCM_ACK_MB1 + 0x2)\n#define PRCM_ACK_MB1_DVFS_STATUS\t(PRCM_ACK_MB1 + 0x3)\n\n \n#define MB2H_DPS\t0x0\n#define MB2H_AUTO_PWR\t0x1\n\n \n#define PRCM_REQ_MB2_SVA_MMDSP\t\t(PRCM_REQ_MB2 + 0x0)\n#define PRCM_REQ_MB2_SVA_PIPE\t\t(PRCM_REQ_MB2 + 0x1)\n#define PRCM_REQ_MB2_SIA_MMDSP\t\t(PRCM_REQ_MB2 + 0x2)\n#define PRCM_REQ_MB2_SIA_PIPE\t\t(PRCM_REQ_MB2 + 0x3)\n#define PRCM_REQ_MB2_SGA\t\t(PRCM_REQ_MB2 + 0x4)\n#define PRCM_REQ_MB2_B2R2_MCDE\t\t(PRCM_REQ_MB2 + 0x5)\n#define PRCM_REQ_MB2_ESRAM12\t\t(PRCM_REQ_MB2 + 0x6)\n#define PRCM_REQ_MB2_ESRAM34\t\t(PRCM_REQ_MB2 + 0x7)\n#define PRCM_REQ_MB2_AUTO_PM_SLEEP\t(PRCM_REQ_MB2 + 0x8)\n#define PRCM_REQ_MB2_AUTO_PM_IDLE\t(PRCM_REQ_MB2 + 0xC)\n\n \n#define PRCM_ACK_MB2_DPS_STATUS (PRCM_ACK_MB2 + 0x0)\n#define HWACC_PWR_ST_OK 0xFE\n\n \n#define MB3H_ANC\t0x0\n#define MB3H_SIDETONE\t0x1\n#define MB3H_SYSCLK\t0xE\n\n \n#define PRCM_REQ_MB3_ANC_FIR_COEFF\t(PRCM_REQ_MB3 + 0x0)\n#define PRCM_REQ_MB3_ANC_IIR_COEFF\t(PRCM_REQ_MB3 + 0x20)\n#define PRCM_REQ_MB3_ANC_SHIFTER\t(PRCM_REQ_MB3 + 0x60)\n#define PRCM_REQ_MB3_ANC_WARP\t\t(PRCM_REQ_MB3 + 0x64)\n#define PRCM_REQ_MB3_SIDETONE_FIR_GAIN\t(PRCM_REQ_MB3 + 0x68)\n#define PRCM_REQ_MB3_SIDETONE_FIR_COEFF\t(PRCM_REQ_MB3 + 0x6C)\n#define PRCM_REQ_MB3_SYSCLK_MGT\t\t(PRCM_REQ_MB3 + 0x16C)\n\n \n#define MB4H_DDR_INIT\t0x0\n#define MB4H_MEM_ST\t0x1\n#define MB4H_HOTDOG\t0x12\n#define MB4H_HOTMON\t0x13\n#define MB4H_HOT_PERIOD\t0x14\n#define MB4H_A9WDOG_CONF 0x16\n#define MB4H_A9WDOG_EN   0x17\n#define MB4H_A9WDOG_DIS  0x18\n#define MB4H_A9WDOG_LOAD 0x19\n#define MB4H_A9WDOG_KICK 0x20\n\n \n#define PRCM_REQ_MB4_DDR_ST_AP_SLEEP_IDLE\t(PRCM_REQ_MB4 + 0x0)\n#define PRCM_REQ_MB4_DDR_ST_AP_DEEP_IDLE\t(PRCM_REQ_MB4 + 0x1)\n#define PRCM_REQ_MB4_ESRAM0_ST\t\t\t(PRCM_REQ_MB4 + 0x3)\n#define PRCM_REQ_MB4_HOTDOG_THRESHOLD\t\t(PRCM_REQ_MB4 + 0x0)\n#define PRCM_REQ_MB4_HOTMON_LOW\t\t\t(PRCM_REQ_MB4 + 0x0)\n#define PRCM_REQ_MB4_HOTMON_HIGH\t\t(PRCM_REQ_MB4 + 0x1)\n#define PRCM_REQ_MB4_HOTMON_CONFIG\t\t(PRCM_REQ_MB4 + 0x2)\n#define PRCM_REQ_MB4_HOT_PERIOD\t\t\t(PRCM_REQ_MB4 + 0x0)\n#define HOTMON_CONFIG_LOW\t\t\tBIT(0)\n#define HOTMON_CONFIG_HIGH\t\t\tBIT(1)\n#define PRCM_REQ_MB4_A9WDOG_0\t\t\t(PRCM_REQ_MB4 + 0x0)\n#define PRCM_REQ_MB4_A9WDOG_1\t\t\t(PRCM_REQ_MB4 + 0x1)\n#define PRCM_REQ_MB4_A9WDOG_2\t\t\t(PRCM_REQ_MB4 + 0x2)\n#define PRCM_REQ_MB4_A9WDOG_3\t\t\t(PRCM_REQ_MB4 + 0x3)\n#define A9WDOG_AUTO_OFF_EN\t\t\tBIT(7)\n#define A9WDOG_AUTO_OFF_DIS\t\t\t0\n#define A9WDOG_ID_MASK\t\t\t\t0xf\n\n \n#define PRCM_REQ_MB5_I2C_SLAVE_OP\t(PRCM_REQ_MB5 + 0x0)\n#define PRCM_REQ_MB5_I2C_HW_BITS\t(PRCM_REQ_MB5 + 0x1)\n#define PRCM_REQ_MB5_I2C_REG\t\t(PRCM_REQ_MB5 + 0x2)\n#define PRCM_REQ_MB5_I2C_VAL\t\t(PRCM_REQ_MB5 + 0x3)\n#define PRCMU_I2C_WRITE(slave) (((slave) << 1) | BIT(6))\n#define PRCMU_I2C_READ(slave) (((slave) << 1) | BIT(0) | BIT(6))\n#define PRCMU_I2C_STOP_EN\t\tBIT(3)\n\n \n#define PRCM_ACK_MB5_I2C_STATUS\t(PRCM_ACK_MB5 + 0x1)\n#define PRCM_ACK_MB5_I2C_VAL\t(PRCM_ACK_MB5 + 0x3)\n#define I2C_WR_OK 0x1\n#define I2C_RD_OK 0x2\n\n#define NUM_MB 8\n#define MBOX_BIT BIT\n#define ALL_MBOX_BITS (MBOX_BIT(NUM_MB) - 1)\n\n \n\n#define WAKEUP_BIT_RTC BIT(0)\n#define WAKEUP_BIT_RTT0 BIT(1)\n#define WAKEUP_BIT_RTT1 BIT(2)\n#define WAKEUP_BIT_HSI0 BIT(3)\n#define WAKEUP_BIT_HSI1 BIT(4)\n#define WAKEUP_BIT_CA_WAKE BIT(5)\n#define WAKEUP_BIT_USB BIT(6)\n#define WAKEUP_BIT_ABB BIT(7)\n#define WAKEUP_BIT_ABB_FIFO BIT(8)\n#define WAKEUP_BIT_SYSCLK_OK BIT(9)\n#define WAKEUP_BIT_CA_SLEEP BIT(10)\n#define WAKEUP_BIT_AC_WAKE_ACK BIT(11)\n#define WAKEUP_BIT_SIDE_TONE_OK BIT(12)\n#define WAKEUP_BIT_ANC_OK BIT(13)\n#define WAKEUP_BIT_SW_ERROR BIT(14)\n#define WAKEUP_BIT_AC_SLEEP_ACK BIT(15)\n#define WAKEUP_BIT_ARM BIT(17)\n#define WAKEUP_BIT_HOTMON_LOW BIT(18)\n#define WAKEUP_BIT_HOTMON_HIGH BIT(19)\n#define WAKEUP_BIT_MODEM_SW_RESET_REQ BIT(20)\n#define WAKEUP_BIT_GPIO0 BIT(23)\n#define WAKEUP_BIT_GPIO1 BIT(24)\n#define WAKEUP_BIT_GPIO2 BIT(25)\n#define WAKEUP_BIT_GPIO3 BIT(26)\n#define WAKEUP_BIT_GPIO4 BIT(27)\n#define WAKEUP_BIT_GPIO5 BIT(28)\n#define WAKEUP_BIT_GPIO6 BIT(29)\n#define WAKEUP_BIT_GPIO7 BIT(30)\n#define WAKEUP_BIT_GPIO8 BIT(31)\n\nstatic struct {\n\tbool valid;\n\tstruct prcmu_fw_version version;\n} fw_info;\n\nstatic struct irq_domain *db8500_irq_domain;\n\n \n#define IRQ_INDEX(_name) ((IRQ_PRCMU_##_name))\n#define IRQ_ENTRY(_name)[IRQ_INDEX(_name)] = (WAKEUP_BIT_##_name)\n\n#define IRQ_PRCMU_RTC 0\n#define IRQ_PRCMU_RTT0 1\n#define IRQ_PRCMU_RTT1 2\n#define IRQ_PRCMU_HSI0 3\n#define IRQ_PRCMU_HSI1 4\n#define IRQ_PRCMU_CA_WAKE 5\n#define IRQ_PRCMU_USB 6\n#define IRQ_PRCMU_ABB 7\n#define IRQ_PRCMU_ABB_FIFO 8\n#define IRQ_PRCMU_ARM 9\n#define IRQ_PRCMU_MODEM_SW_RESET_REQ 10\n#define IRQ_PRCMU_GPIO0 11\n#define IRQ_PRCMU_GPIO1 12\n#define IRQ_PRCMU_GPIO2 13\n#define IRQ_PRCMU_GPIO3 14\n#define IRQ_PRCMU_GPIO4 15\n#define IRQ_PRCMU_GPIO5 16\n#define IRQ_PRCMU_GPIO6 17\n#define IRQ_PRCMU_GPIO7 18\n#define IRQ_PRCMU_GPIO8 19\n#define IRQ_PRCMU_CA_SLEEP 20\n#define IRQ_PRCMU_HOTMON_LOW 21\n#define IRQ_PRCMU_HOTMON_HIGH 22\n#define NUM_PRCMU_WAKEUPS 23\n\nstatic u32 prcmu_irq_bit[NUM_PRCMU_WAKEUPS] = {\n\tIRQ_ENTRY(RTC),\n\tIRQ_ENTRY(RTT0),\n\tIRQ_ENTRY(RTT1),\n\tIRQ_ENTRY(HSI0),\n\tIRQ_ENTRY(HSI1),\n\tIRQ_ENTRY(CA_WAKE),\n\tIRQ_ENTRY(USB),\n\tIRQ_ENTRY(ABB),\n\tIRQ_ENTRY(ABB_FIFO),\n\tIRQ_ENTRY(CA_SLEEP),\n\tIRQ_ENTRY(ARM),\n\tIRQ_ENTRY(HOTMON_LOW),\n\tIRQ_ENTRY(HOTMON_HIGH),\n\tIRQ_ENTRY(MODEM_SW_RESET_REQ),\n\tIRQ_ENTRY(GPIO0),\n\tIRQ_ENTRY(GPIO1),\n\tIRQ_ENTRY(GPIO2),\n\tIRQ_ENTRY(GPIO3),\n\tIRQ_ENTRY(GPIO4),\n\tIRQ_ENTRY(GPIO5),\n\tIRQ_ENTRY(GPIO6),\n\tIRQ_ENTRY(GPIO7),\n\tIRQ_ENTRY(GPIO8)\n};\n\n#define VALID_WAKEUPS (BIT(NUM_PRCMU_WAKEUP_INDICES) - 1)\n#define WAKEUP_ENTRY(_name)[PRCMU_WAKEUP_INDEX_##_name] = (WAKEUP_BIT_##_name)\nstatic u32 prcmu_wakeup_bit[NUM_PRCMU_WAKEUP_INDICES] = {\n\tWAKEUP_ENTRY(RTC),\n\tWAKEUP_ENTRY(RTT0),\n\tWAKEUP_ENTRY(RTT1),\n\tWAKEUP_ENTRY(HSI0),\n\tWAKEUP_ENTRY(HSI1),\n\tWAKEUP_ENTRY(USB),\n\tWAKEUP_ENTRY(ABB),\n\tWAKEUP_ENTRY(ABB_FIFO),\n\tWAKEUP_ENTRY(ARM)\n};\n\n \nstatic struct {\n\tspinlock_t lock;\n\tspinlock_t dbb_irqs_lock;\n\tstruct work_struct mask_work;\n\tstruct mutex ac_wake_lock;\n\tstruct completion ac_wake_work;\n\tstruct {\n\t\tu32 dbb_irqs;\n\t\tu32 dbb_wakeups;\n\t\tu32 abb_events;\n\t} req;\n} mb0_transfer;\n\n \nstatic struct {\n\tstruct mutex lock;\n\tstruct completion work;\n\tu8 ape_opp;\n\tstruct {\n\t\tu8 header;\n\t\tu8 arm_opp;\n\t\tu8 ape_opp;\n\t\tu8 ape_voltage_status;\n\t} ack;\n} mb1_transfer;\n\n \nstatic struct {\n\tstruct mutex lock;\n\tstruct completion work;\n\tspinlock_t auto_pm_lock;\n\tbool auto_pm_enabled;\n\tstruct {\n\t\tu8 status;\n\t} ack;\n} mb2_transfer;\n\n \nstatic struct {\n\tspinlock_t lock;\n\tstruct mutex sysclk_lock;\n\tstruct completion sysclk_work;\n} mb3_transfer;\n\n \nstatic struct {\n\tstruct mutex lock;\n\tstruct completion work;\n} mb4_transfer;\n\n \nstatic struct {\n\tstruct mutex lock;\n\tstruct completion work;\n\tstruct {\n\t\tu8 status;\n\t\tu8 value;\n\t} ack;\n} mb5_transfer;\n\nstatic atomic_t ac_wake_req_state = ATOMIC_INIT(0);\n\n \nstatic DEFINE_SPINLOCK(prcmu_lock);\nstatic DEFINE_SPINLOCK(clkout_lock);\n\n \nstatic __iomem void *tcdm_base;\nstatic __iomem void *prcmu_base;\n\nstruct clk_mgt {\n\tu32 offset;\n\tu32 pllsw;\n\tint branch;\n\tbool clk38div;\n};\n\nenum {\n\tPLL_RAW,\n\tPLL_FIX,\n\tPLL_DIV\n};\n\nstatic DEFINE_SPINLOCK(clk_mgt_lock);\n\n#define CLK_MGT_ENTRY(_name, _branch, _clk38div)[PRCMU_##_name] = \\\n\t{ (PRCM_##_name##_MGT), 0 , _branch, _clk38div}\nstatic struct clk_mgt clk_mgt[PRCMU_NUM_REG_CLOCKS] = {\n\tCLK_MGT_ENTRY(SGACLK, PLL_DIV, false),\n\tCLK_MGT_ENTRY(UARTCLK, PLL_FIX, true),\n\tCLK_MGT_ENTRY(MSP02CLK, PLL_FIX, true),\n\tCLK_MGT_ENTRY(MSP1CLK, PLL_FIX, true),\n\tCLK_MGT_ENTRY(I2CCLK, PLL_FIX, true),\n\tCLK_MGT_ENTRY(SDMMCCLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(SLIMCLK, PLL_FIX, true),\n\tCLK_MGT_ENTRY(PER1CLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(PER2CLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(PER3CLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(PER5CLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(PER6CLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(PER7CLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(LCDCLK, PLL_FIX, true),\n\tCLK_MGT_ENTRY(BMLCLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(HSITXCLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(HSIRXCLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(HDMICLK, PLL_FIX, false),\n\tCLK_MGT_ENTRY(APEATCLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(APETRACECLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(MCDECLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(IPI2CCLK, PLL_FIX, true),\n\tCLK_MGT_ENTRY(DSIALTCLK, PLL_FIX, false),\n\tCLK_MGT_ENTRY(DMACLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(B2R2CLK, PLL_DIV, true),\n\tCLK_MGT_ENTRY(TVCLK, PLL_FIX, true),\n\tCLK_MGT_ENTRY(SSPCLK, PLL_FIX, true),\n\tCLK_MGT_ENTRY(RNGCLK, PLL_FIX, true),\n\tCLK_MGT_ENTRY(UICCCLK, PLL_FIX, false),\n};\n\nstruct dsiclk {\n\tu32 divsel_mask;\n\tu32 divsel_shift;\n\tu32 divsel;\n};\n\nstatic struct dsiclk dsiclk[2] = {\n\t{\n\t\t.divsel_mask = PRCM_DSI_PLLOUT_SEL_DSI0_PLLOUT_DIVSEL_MASK,\n\t\t.divsel_shift = PRCM_DSI_PLLOUT_SEL_DSI0_PLLOUT_DIVSEL_SHIFT,\n\t\t.divsel = PRCM_DSI_PLLOUT_SEL_PHI,\n\t},\n\t{\n\t\t.divsel_mask = PRCM_DSI_PLLOUT_SEL_DSI1_PLLOUT_DIVSEL_MASK,\n\t\t.divsel_shift = PRCM_DSI_PLLOUT_SEL_DSI1_PLLOUT_DIVSEL_SHIFT,\n\t\t.divsel = PRCM_DSI_PLLOUT_SEL_PHI,\n\t}\n};\n\nstruct dsiescclk {\n\tu32 en;\n\tu32 div_mask;\n\tu32 div_shift;\n};\n\nstatic struct dsiescclk dsiescclk[3] = {\n\t{\n\t\t.en = PRCM_DSITVCLK_DIV_DSI0_ESC_CLK_EN,\n\t\t.div_mask = PRCM_DSITVCLK_DIV_DSI0_ESC_CLK_DIV_MASK,\n\t\t.div_shift = PRCM_DSITVCLK_DIV_DSI0_ESC_CLK_DIV_SHIFT,\n\t},\n\t{\n\t\t.en = PRCM_DSITVCLK_DIV_DSI1_ESC_CLK_EN,\n\t\t.div_mask = PRCM_DSITVCLK_DIV_DSI1_ESC_CLK_DIV_MASK,\n\t\t.div_shift = PRCM_DSITVCLK_DIV_DSI1_ESC_CLK_DIV_SHIFT,\n\t},\n\t{\n\t\t.en = PRCM_DSITVCLK_DIV_DSI2_ESC_CLK_EN,\n\t\t.div_mask = PRCM_DSITVCLK_DIV_DSI2_ESC_CLK_DIV_MASK,\n\t\t.div_shift = PRCM_DSITVCLK_DIV_DSI2_ESC_CLK_DIV_SHIFT,\n\t}\n};\n\nu32 db8500_prcmu_read(unsigned int reg)\n{\n\treturn readl(prcmu_base + reg);\n}\n\nvoid db8500_prcmu_write(unsigned int reg, u32 value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prcmu_lock, flags);\n\twritel(value, (prcmu_base + reg));\n\tspin_unlock_irqrestore(&prcmu_lock, flags);\n}\n\nvoid db8500_prcmu_write_masked(unsigned int reg, u32 mask, u32 value)\n{\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prcmu_lock, flags);\n\tval = readl(prcmu_base + reg);\n\tval = ((val & ~mask) | (value & mask));\n\twritel(val, (prcmu_base + reg));\n\tspin_unlock_irqrestore(&prcmu_lock, flags);\n}\n\nstruct prcmu_fw_version *prcmu_get_fw_version(void)\n{\n\treturn fw_info.valid ? &fw_info.version : NULL;\n}\n\nstatic bool prcmu_is_ulppll_disabled(void)\n{\n\tstruct prcmu_fw_version *ver;\n\n\tver = prcmu_get_fw_version();\n\treturn ver && ver->project == PRCMU_FW_PROJECT_U8420_SYSCLK;\n}\n\nbool prcmu_has_arm_maxopp(void)\n{\n\treturn (readb(tcdm_base + PRCM_AVS_VARM_MAX_OPP) &\n\t\tPRCM_AVS_ISMODEENABLE_MASK) == PRCM_AVS_ISMODEENABLE_MASK;\n}\n\n \nint prcmu_set_rc_a2p(enum romcode_write val)\n{\n\tif (val < RDY_2_DS || val > RDY_2_XP70_RST)\n\t\treturn -EINVAL;\n\twriteb(val, (tcdm_base + PRCM_ROMCODE_A2P));\n\treturn 0;\n}\n\n \nenum romcode_read prcmu_get_rc_p2a(void)\n{\n\treturn readb(tcdm_base + PRCM_ROMCODE_P2A);\n}\n\n \nenum ap_pwrst prcmu_get_xp70_current_state(void)\n{\n\treturn readb(tcdm_base + PRCM_XP70_CUR_PWR_STATE);\n}\n\n \nint prcmu_config_clkout(u8 clkout, u8 source, u8 div)\n{\n\tstatic int requests[2];\n\tint r = 0;\n\tunsigned long flags;\n\tu32 val;\n\tu32 bits;\n\tu32 mask;\n\tu32 div_mask;\n\n\tBUG_ON(clkout > 1);\n\tBUG_ON(div > 63);\n\tBUG_ON((clkout == 0) && (source > PRCMU_CLKSRC_CLK009));\n\n\tif (!div && !requests[clkout])\n\t\treturn -EINVAL;\n\n\tif (clkout == 0) {\n\t\tdiv_mask = PRCM_CLKOCR_CLKODIV0_MASK;\n\t\tmask = (PRCM_CLKOCR_CLKODIV0_MASK | PRCM_CLKOCR_CLKOSEL0_MASK);\n\t\tbits = ((source << PRCM_CLKOCR_CLKOSEL0_SHIFT) |\n\t\t\t(div << PRCM_CLKOCR_CLKODIV0_SHIFT));\n\t} else {\n\t\tdiv_mask = PRCM_CLKOCR_CLKODIV1_MASK;\n\t\tmask = (PRCM_CLKOCR_CLKODIV1_MASK | PRCM_CLKOCR_CLKOSEL1_MASK |\n\t\t\tPRCM_CLKOCR_CLK1TYPE);\n\t\tbits = ((source << PRCM_CLKOCR_CLKOSEL1_SHIFT) |\n\t\t\t(div << PRCM_CLKOCR_CLKODIV1_SHIFT));\n\t}\n\tbits &= mask;\n\n\tspin_lock_irqsave(&clkout_lock, flags);\n\n\tval = readl(PRCM_CLKOCR);\n\tif (val & div_mask) {\n\t\tif (div) {\n\t\t\tif ((val & mask) != bits) {\n\t\t\t\tr = -EBUSY;\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((val & mask & ~div_mask) != bits) {\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t}\n\t}\n\twritel((bits | (val & ~mask)), PRCM_CLKOCR);\n\trequests[clkout] += (div ? 1 : -1);\n\nunlock_and_return:\n\tspin_unlock_irqrestore(&clkout_lock, flags);\n\n\treturn r;\n}\n\nint db8500_prcmu_set_power_state(u8 state, bool keep_ulp_clk, bool keep_ap_pll)\n{\n\tunsigned long flags;\n\n\tBUG_ON((state < PRCMU_AP_SLEEP) || (PRCMU_AP_DEEP_IDLE < state));\n\n\tspin_lock_irqsave(&mb0_transfer.lock, flags);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(0))\n\t\tcpu_relax();\n\n\twriteb(MB0H_POWER_STATE_TRANS, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB0));\n\twriteb(state, (tcdm_base + PRCM_REQ_MB0_AP_POWER_STATE));\n\twriteb((keep_ap_pll ? 1 : 0), (tcdm_base + PRCM_REQ_MB0_AP_PLL_STATE));\n\twriteb((keep_ulp_clk ? 1 : 0),\n\t\t(tcdm_base + PRCM_REQ_MB0_ULP_CLOCK_STATE));\n\twriteb(0, (tcdm_base + PRCM_REQ_MB0_DO_NOT_WFI));\n\twritel(MBOX_BIT(0), PRCM_MBOX_CPU_SET);\n\n\tspin_unlock_irqrestore(&mb0_transfer.lock, flags);\n\n\treturn 0;\n}\n\nu8 db8500_prcmu_get_power_state_result(void)\n{\n\treturn readb(tcdm_base + PRCM_ACK_MB0_AP_PWRSTTR_STATUS);\n}\n\n \nstatic void config_wakeups(void)\n{\n\tconst u8 header[2] = {\n\t\tMB0H_CONFIG_WAKEUPS_EXE,\n\t\tMB0H_CONFIG_WAKEUPS_SLEEP\n\t};\n\tstatic u32 last_dbb_events;\n\tstatic u32 last_abb_events;\n\tu32 dbb_events;\n\tu32 abb_events;\n\tunsigned int i;\n\n\tdbb_events = mb0_transfer.req.dbb_irqs | mb0_transfer.req.dbb_wakeups;\n\tdbb_events |= (WAKEUP_BIT_AC_WAKE_ACK | WAKEUP_BIT_AC_SLEEP_ACK);\n\n\tabb_events = mb0_transfer.req.abb_events;\n\n\tif ((dbb_events == last_dbb_events) && (abb_events == last_abb_events))\n\t\treturn;\n\n\tfor (i = 0; i < 2; i++) {\n\t\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(0))\n\t\t\tcpu_relax();\n\t\twritel(dbb_events, (tcdm_base + PRCM_REQ_MB0_WAKEUP_8500));\n\t\twritel(abb_events, (tcdm_base + PRCM_REQ_MB0_WAKEUP_4500));\n\t\twriteb(header[i], (tcdm_base + PRCM_MBOX_HEADER_REQ_MB0));\n\t\twritel(MBOX_BIT(0), PRCM_MBOX_CPU_SET);\n\t}\n\tlast_dbb_events = dbb_events;\n\tlast_abb_events = abb_events;\n}\n\nvoid db8500_prcmu_enable_wakeups(u32 wakeups)\n{\n\tunsigned long flags;\n\tu32 bits;\n\tint i;\n\n\tBUG_ON(wakeups != (wakeups & VALID_WAKEUPS));\n\n\tfor (i = 0, bits = 0; i < NUM_PRCMU_WAKEUP_INDICES; i++) {\n\t\tif (wakeups & BIT(i))\n\t\t\tbits |= prcmu_wakeup_bit[i];\n\t}\n\n\tspin_lock_irqsave(&mb0_transfer.lock, flags);\n\n\tmb0_transfer.req.dbb_wakeups = bits;\n\tconfig_wakeups();\n\n\tspin_unlock_irqrestore(&mb0_transfer.lock, flags);\n}\n\nvoid db8500_prcmu_config_abb_event_readout(u32 abb_events)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mb0_transfer.lock, flags);\n\n\tmb0_transfer.req.abb_events = abb_events;\n\tconfig_wakeups();\n\n\tspin_unlock_irqrestore(&mb0_transfer.lock, flags);\n}\n\nvoid db8500_prcmu_get_abb_event_buffer(void __iomem **buf)\n{\n\tif (readb(tcdm_base + PRCM_ACK_MB0_READ_POINTER) & 1)\n\t\t*buf = (tcdm_base + PRCM_ACK_MB0_WAKEUP_1_4500);\n\telse\n\t\t*buf = (tcdm_base + PRCM_ACK_MB0_WAKEUP_0_4500);\n}\n\n \nint db8500_prcmu_set_arm_opp(u8 opp)\n{\n\tint r;\n\n\tif (opp < ARM_NO_CHANGE || opp > ARM_EXTCLK)\n\t\treturn -EINVAL;\n\n\tr = 0;\n\n\tmutex_lock(&mb1_transfer.lock);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\n\t\tcpu_relax();\n\n\twriteb(MB1H_ARM_APE_OPP, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\n\twriteb(opp, (tcdm_base + PRCM_REQ_MB1_ARM_OPP));\n\twriteb(APE_NO_CHANGE, (tcdm_base + PRCM_REQ_MB1_APE_OPP));\n\n\twritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\n\twait_for_completion(&mb1_transfer.work);\n\n\tif ((mb1_transfer.ack.header != MB1H_ARM_APE_OPP) ||\n\t\t(mb1_transfer.ack.arm_opp != opp))\n\t\tr = -EIO;\n\n\tmutex_unlock(&mb1_transfer.lock);\n\n\treturn r;\n}\n\n \nint db8500_prcmu_get_arm_opp(void)\n{\n\treturn readb(tcdm_base + PRCM_ACK_MB1_CURRENT_ARM_OPP);\n}\n\n \nint db8500_prcmu_get_ddr_opp(void)\n{\n\treturn readb(PRCM_DDR_SUBSYS_APE_MINBW);\n}\n\n \nstatic void request_even_slower_clocks(bool enable)\n{\n\tu32 clock_reg[] = {\n\t\tPRCM_ACLK_MGT,\n\t\tPRCM_DMACLK_MGT\n\t};\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&clk_mgt_lock, flags);\n\n\t \n\twhile ((readl(PRCM_SEM) & PRCM_SEM_PRCM_SEM) != 0)\n\t\tcpu_relax();\n\n\tfor (i = 0; i < ARRAY_SIZE(clock_reg); i++) {\n\t\tu32 val;\n\t\tu32 div;\n\n\t\tval = readl(prcmu_base + clock_reg[i]);\n\t\tdiv = (val & PRCM_CLK_MGT_CLKPLLDIV_MASK);\n\t\tif (enable) {\n\t\t\tif ((div <= 1) || (div > 15)) {\n\t\t\t\tpr_err(\"prcmu: Bad clock divider %d in %s\\n\",\n\t\t\t\t\tdiv, __func__);\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tdiv <<= 1;\n\t\t} else {\n\t\t\tif (div <= 2)\n\t\t\t\tgoto unlock_and_return;\n\t\t\tdiv >>= 1;\n\t\t}\n\t\tval = ((val & ~PRCM_CLK_MGT_CLKPLLDIV_MASK) |\n\t\t\t(div & PRCM_CLK_MGT_CLKPLLDIV_MASK));\n\t\twritel(val, prcmu_base + clock_reg[i]);\n\t}\n\nunlock_and_return:\n\t \n\twritel(0, PRCM_SEM);\n\n\tspin_unlock_irqrestore(&clk_mgt_lock, flags);\n}\n\n \nint db8500_prcmu_set_ape_opp(u8 opp)\n{\n\tint r = 0;\n\n\tif (opp == mb1_transfer.ape_opp)\n\t\treturn 0;\n\n\tmutex_lock(&mb1_transfer.lock);\n\n\tif (mb1_transfer.ape_opp == APE_50_PARTLY_25_OPP)\n\t\trequest_even_slower_clocks(false);\n\n\tif ((opp != APE_100_OPP) && (mb1_transfer.ape_opp != APE_100_OPP))\n\t\tgoto skip_message;\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\n\t\tcpu_relax();\n\n\twriteb(MB1H_ARM_APE_OPP, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\n\twriteb(ARM_NO_CHANGE, (tcdm_base + PRCM_REQ_MB1_ARM_OPP));\n\twriteb(((opp == APE_50_PARTLY_25_OPP) ? APE_50_OPP : opp),\n\t\t(tcdm_base + PRCM_REQ_MB1_APE_OPP));\n\n\twritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\n\twait_for_completion(&mb1_transfer.work);\n\n\tif ((mb1_transfer.ack.header != MB1H_ARM_APE_OPP) ||\n\t\t(mb1_transfer.ack.ape_opp != opp))\n\t\tr = -EIO;\n\nskip_message:\n\tif ((!r && (opp == APE_50_PARTLY_25_OPP)) ||\n\t\t(r && (mb1_transfer.ape_opp == APE_50_PARTLY_25_OPP)))\n\t\trequest_even_slower_clocks(true);\n\tif (!r)\n\t\tmb1_transfer.ape_opp = opp;\n\n\tmutex_unlock(&mb1_transfer.lock);\n\n\treturn r;\n}\n\n \nint db8500_prcmu_get_ape_opp(void)\n{\n\treturn readb(tcdm_base + PRCM_ACK_MB1_CURRENT_APE_OPP);\n}\n\n \nint db8500_prcmu_request_ape_opp_100_voltage(bool enable)\n{\n\tint r = 0;\n\tu8 header;\n\tstatic unsigned int requests;\n\n\tmutex_lock(&mb1_transfer.lock);\n\n\tif (enable) {\n\t\tif (0 != requests++)\n\t\t\tgoto unlock_and_return;\n\t\theader = MB1H_REQUEST_APE_OPP_100_VOLT;\n\t} else {\n\t\tif (requests == 0) {\n\t\t\tr = -EIO;\n\t\t\tgoto unlock_and_return;\n\t\t} else if (1 != requests--) {\n\t\t\tgoto unlock_and_return;\n\t\t}\n\t\theader = MB1H_RELEASE_APE_OPP_100_VOLT;\n\t}\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\n\t\tcpu_relax();\n\n\twriteb(header, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\n\n\twritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\n\twait_for_completion(&mb1_transfer.work);\n\n\tif ((mb1_transfer.ack.header != header) ||\n\t\t((mb1_transfer.ack.ape_voltage_status & BIT(0)) != 0))\n\t\tr = -EIO;\n\nunlock_and_return:\n\tmutex_unlock(&mb1_transfer.lock);\n\n\treturn r;\n}\n\n \nint prcmu_release_usb_wakeup_state(void)\n{\n\tint r = 0;\n\n\tmutex_lock(&mb1_transfer.lock);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\n\t\tcpu_relax();\n\n\twriteb(MB1H_RELEASE_USB_WAKEUP,\n\t\t(tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\n\n\twritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\n\twait_for_completion(&mb1_transfer.work);\n\n\tif ((mb1_transfer.ack.header != MB1H_RELEASE_USB_WAKEUP) ||\n\t\t((mb1_transfer.ack.ape_voltage_status & BIT(0)) != 0))\n\t\tr = -EIO;\n\n\tmutex_unlock(&mb1_transfer.lock);\n\n\treturn r;\n}\n\nstatic int request_pll(u8 clock, bool enable)\n{\n\tint r = 0;\n\n\tif (clock == PRCMU_PLLSOC0)\n\t\tclock = (enable ? PLL_SOC0_ON : PLL_SOC0_OFF);\n\telse if (clock == PRCMU_PLLSOC1)\n\t\tclock = (enable ? PLL_SOC1_ON : PLL_SOC1_OFF);\n\telse\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mb1_transfer.lock);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\n\t\tcpu_relax();\n\n\twriteb(MB1H_PLL_ON_OFF, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\n\twriteb(clock, (tcdm_base + PRCM_REQ_MB1_PLL_ON_OFF));\n\n\twritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\n\twait_for_completion(&mb1_transfer.work);\n\n\tif (mb1_transfer.ack.header != MB1H_PLL_ON_OFF)\n\t\tr = -EIO;\n\n\tmutex_unlock(&mb1_transfer.lock);\n\n\treturn r;\n}\n\n \nint db8500_prcmu_set_epod(u16 epod_id, u8 epod_state)\n{\n\tint r = 0;\n\tbool ram_retention = false;\n\tint i;\n\n\t \n\tBUG_ON(epod_id >= NUM_EPOD_ID);\n\n\t \n\tswitch (epod_id) {\n\tcase EPOD_ID_SVAMMDSP:\n\tcase EPOD_ID_SIAMMDSP:\n\tcase EPOD_ID_ESRAM12:\n\tcase EPOD_ID_ESRAM34:\n\t\tram_retention = true;\n\t\tbreak;\n\t}\n\n\t \n\tBUG_ON(epod_state > EPOD_STATE_ON);\n\tBUG_ON(epod_state == EPOD_STATE_RAMRET && !ram_retention);\n\n\t \n\tmutex_lock(&mb2_transfer.lock);\n\n\t \n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(2))\n\t\tcpu_relax();\n\n\t \n\tfor (i = 0; i < NUM_EPOD_ID; i++)\n\t\twriteb(EPOD_STATE_NO_CHANGE, (tcdm_base + PRCM_REQ_MB2 + i));\n\twriteb(epod_state, (tcdm_base + PRCM_REQ_MB2 + epod_id));\n\n\twriteb(MB2H_DPS, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB2));\n\n\twritel(MBOX_BIT(2), PRCM_MBOX_CPU_SET);\n\n\t \n\tif (!wait_for_completion_timeout(&mb2_transfer.work,\n\t\t\tmsecs_to_jiffies(20000))) {\n\t\tpr_err(\"prcmu: %s timed out (20 s) waiting for a reply.\\n\",\n\t\t\t__func__);\n\t\tr = -EIO;\n\t\tgoto unlock_and_return;\n\t}\n\n\tif (mb2_transfer.ack.status != HWACC_PWR_ST_OK)\n\t\tr = -EIO;\n\nunlock_and_return:\n\tmutex_unlock(&mb2_transfer.lock);\n\treturn r;\n}\n\n \nvoid prcmu_configure_auto_pm(struct prcmu_auto_pm_config *sleep,\n\tstruct prcmu_auto_pm_config *idle)\n{\n\tu32 sleep_cfg;\n\tu32 idle_cfg;\n\tunsigned long flags;\n\n\tBUG_ON((sleep == NULL) || (idle == NULL));\n\n\tsleep_cfg = (sleep->sva_auto_pm_enable & 0xF);\n\tsleep_cfg = ((sleep_cfg << 4) | (sleep->sia_auto_pm_enable & 0xF));\n\tsleep_cfg = ((sleep_cfg << 8) | (sleep->sva_power_on & 0xFF));\n\tsleep_cfg = ((sleep_cfg << 8) | (sleep->sia_power_on & 0xFF));\n\tsleep_cfg = ((sleep_cfg << 4) | (sleep->sva_policy & 0xF));\n\tsleep_cfg = ((sleep_cfg << 4) | (sleep->sia_policy & 0xF));\n\n\tidle_cfg = (idle->sva_auto_pm_enable & 0xF);\n\tidle_cfg = ((idle_cfg << 4) | (idle->sia_auto_pm_enable & 0xF));\n\tidle_cfg = ((idle_cfg << 8) | (idle->sva_power_on & 0xFF));\n\tidle_cfg = ((idle_cfg << 8) | (idle->sia_power_on & 0xFF));\n\tidle_cfg = ((idle_cfg << 4) | (idle->sva_policy & 0xF));\n\tidle_cfg = ((idle_cfg << 4) | (idle->sia_policy & 0xF));\n\n\tspin_lock_irqsave(&mb2_transfer.auto_pm_lock, flags);\n\n\t \n\twritel(sleep_cfg, (tcdm_base + PRCM_REQ_MB2_AUTO_PM_SLEEP));\n\twritel(idle_cfg, (tcdm_base + PRCM_REQ_MB2_AUTO_PM_IDLE));\n\n\tmb2_transfer.auto_pm_enabled =\n\t\t((sleep->sva_auto_pm_enable == PRCMU_AUTO_PM_ON) ||\n\t\t (sleep->sia_auto_pm_enable == PRCMU_AUTO_PM_ON) ||\n\t\t (idle->sva_auto_pm_enable == PRCMU_AUTO_PM_ON) ||\n\t\t (idle->sia_auto_pm_enable == PRCMU_AUTO_PM_ON));\n\n\tspin_unlock_irqrestore(&mb2_transfer.auto_pm_lock, flags);\n}\nEXPORT_SYMBOL(prcmu_configure_auto_pm);\n\nbool prcmu_is_auto_pm_enabled(void)\n{\n\treturn mb2_transfer.auto_pm_enabled;\n}\n\nstatic int request_sysclk(bool enable)\n{\n\tint r;\n\tunsigned long flags;\n\n\tr = 0;\n\n\tmutex_lock(&mb3_transfer.sysclk_lock);\n\n\tspin_lock_irqsave(&mb3_transfer.lock, flags);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(3))\n\t\tcpu_relax();\n\n\twriteb((enable ? ON : OFF), (tcdm_base + PRCM_REQ_MB3_SYSCLK_MGT));\n\n\twriteb(MB3H_SYSCLK, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB3));\n\twritel(MBOX_BIT(3), PRCM_MBOX_CPU_SET);\n\n\tspin_unlock_irqrestore(&mb3_transfer.lock, flags);\n\n\t \n\tif (enable && !wait_for_completion_timeout(&mb3_transfer.sysclk_work,\n\t\t\tmsecs_to_jiffies(20000))) {\n\t\tpr_err(\"prcmu: %s timed out (20 s) waiting for a reply.\\n\",\n\t\t\t__func__);\n\t\tr = -EIO;\n\t}\n\n\tmutex_unlock(&mb3_transfer.sysclk_lock);\n\n\treturn r;\n}\n\nstatic int request_timclk(bool enable)\n{\n\tu32 val;\n\n\t \n\tif (prcmu_is_ulppll_disabled())\n\t\tval = 0;\n\telse\n\t\tval = (PRCM_TCR_DOZE_MODE | PRCM_TCR_TENSEL_MASK);\n\n\tif (!enable)\n\t\tval |= PRCM_TCR_STOP_TIMERS |\n\t\t\tPRCM_TCR_DOZE_MODE |\n\t\t\tPRCM_TCR_TENSEL_MASK;\n\n\twritel(val, PRCM_TCR);\n\n\treturn 0;\n}\n\nstatic int request_clock(u8 clock, bool enable)\n{\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&clk_mgt_lock, flags);\n\n\t \n\twhile ((readl(PRCM_SEM) & PRCM_SEM_PRCM_SEM) != 0)\n\t\tcpu_relax();\n\n\tval = readl(prcmu_base + clk_mgt[clock].offset);\n\tif (enable) {\n\t\tval |= (PRCM_CLK_MGT_CLKEN | clk_mgt[clock].pllsw);\n\t} else {\n\t\tclk_mgt[clock].pllsw = (val & PRCM_CLK_MGT_CLKPLLSW_MASK);\n\t\tval &= ~(PRCM_CLK_MGT_CLKEN | PRCM_CLK_MGT_CLKPLLSW_MASK);\n\t}\n\twritel(val, prcmu_base + clk_mgt[clock].offset);\n\n\t \n\twritel(0, PRCM_SEM);\n\n\tspin_unlock_irqrestore(&clk_mgt_lock, flags);\n\n\treturn 0;\n}\n\nstatic int request_sga_clock(u8 clock, bool enable)\n{\n\tu32 val;\n\tint ret;\n\n\tif (enable) {\n\t\tval = readl(PRCM_CGATING_BYPASS);\n\t\twritel(val | PRCM_CGATING_BYPASS_ICN2, PRCM_CGATING_BYPASS);\n\t}\n\n\tret = request_clock(clock, enable);\n\n\tif (!ret && !enable) {\n\t\tval = readl(PRCM_CGATING_BYPASS);\n\t\twritel(val & ~PRCM_CGATING_BYPASS_ICN2, PRCM_CGATING_BYPASS);\n\t}\n\n\treturn ret;\n}\n\nstatic inline bool plldsi_locked(void)\n{\n\treturn (readl(PRCM_PLLDSI_LOCKP) &\n\t\t(PRCM_PLLDSI_LOCKP_PRCM_PLLDSI_LOCKP10 |\n\t\t PRCM_PLLDSI_LOCKP_PRCM_PLLDSI_LOCKP3)) ==\n\t\t(PRCM_PLLDSI_LOCKP_PRCM_PLLDSI_LOCKP10 |\n\t\t PRCM_PLLDSI_LOCKP_PRCM_PLLDSI_LOCKP3);\n}\n\nstatic int request_plldsi(bool enable)\n{\n\tint r = 0;\n\tu32 val;\n\n\twritel((PRCM_MMIP_LS_CLAMP_DSIPLL_CLAMP |\n\t\tPRCM_MMIP_LS_CLAMP_DSIPLL_CLAMPI), (enable ?\n\t\tPRCM_MMIP_LS_CLAMP_CLR : PRCM_MMIP_LS_CLAMP_SET));\n\n\tval = readl(PRCM_PLLDSI_ENABLE);\n\tif (enable)\n\t\tval |= PRCM_PLLDSI_ENABLE_PRCM_PLLDSI_ENABLE;\n\telse\n\t\tval &= ~PRCM_PLLDSI_ENABLE_PRCM_PLLDSI_ENABLE;\n\twritel(val, PRCM_PLLDSI_ENABLE);\n\n\tif (enable) {\n\t\tunsigned int i;\n\t\tbool locked = plldsi_locked();\n\n\t\tfor (i = 10; !locked && (i > 0); --i) {\n\t\t\tudelay(100);\n\t\t\tlocked = plldsi_locked();\n\t\t}\n\t\tif (locked) {\n\t\t\twritel(PRCM_APE_RESETN_DSIPLL_RESETN,\n\t\t\t\tPRCM_APE_RESETN_SET);\n\t\t} else {\n\t\t\twritel((PRCM_MMIP_LS_CLAMP_DSIPLL_CLAMP |\n\t\t\t\tPRCM_MMIP_LS_CLAMP_DSIPLL_CLAMPI),\n\t\t\t\tPRCM_MMIP_LS_CLAMP_SET);\n\t\t\tval &= ~PRCM_PLLDSI_ENABLE_PRCM_PLLDSI_ENABLE;\n\t\t\twritel(val, PRCM_PLLDSI_ENABLE);\n\t\t\tr = -EAGAIN;\n\t\t}\n\t} else {\n\t\twritel(PRCM_APE_RESETN_DSIPLL_RESETN, PRCM_APE_RESETN_CLR);\n\t}\n\treturn r;\n}\n\nstatic int request_dsiclk(u8 n, bool enable)\n{\n\tu32 val;\n\n\tval = readl(PRCM_DSI_PLLOUT_SEL);\n\tval &= ~dsiclk[n].divsel_mask;\n\tval |= ((enable ? dsiclk[n].divsel : PRCM_DSI_PLLOUT_SEL_OFF) <<\n\t\tdsiclk[n].divsel_shift);\n\twritel(val, PRCM_DSI_PLLOUT_SEL);\n\treturn 0;\n}\n\nstatic int request_dsiescclk(u8 n, bool enable)\n{\n\tu32 val;\n\n\tval = readl(PRCM_DSITVCLK_DIV);\n\tenable ? (val |= dsiescclk[n].en) : (val &= ~dsiescclk[n].en);\n\twritel(val, PRCM_DSITVCLK_DIV);\n\treturn 0;\n}\n\n \nint db8500_prcmu_request_clock(u8 clock, bool enable)\n{\n\tif (clock == PRCMU_SGACLK)\n\t\treturn request_sga_clock(clock, enable);\n\telse if (clock < PRCMU_NUM_REG_CLOCKS)\n\t\treturn request_clock(clock, enable);\n\telse if (clock == PRCMU_TIMCLK)\n\t\treturn request_timclk(enable);\n\telse if ((clock == PRCMU_DSI0CLK) || (clock == PRCMU_DSI1CLK))\n\t\treturn request_dsiclk((clock - PRCMU_DSI0CLK), enable);\n\telse if ((PRCMU_DSI0ESCCLK <= clock) && (clock <= PRCMU_DSI2ESCCLK))\n\t\treturn request_dsiescclk((clock - PRCMU_DSI0ESCCLK), enable);\n\telse if (clock == PRCMU_PLLDSI)\n\t\treturn request_plldsi(enable);\n\telse if (clock == PRCMU_SYSCLK)\n\t\treturn request_sysclk(enable);\n\telse if ((clock == PRCMU_PLLSOC0) || (clock == PRCMU_PLLSOC1))\n\t\treturn request_pll(clock, enable);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic unsigned long pll_rate(void __iomem *reg, unsigned long src_rate,\n\tint branch)\n{\n\tu64 rate;\n\tu32 val;\n\tu32 d;\n\tu32 div = 1;\n\n\tval = readl(reg);\n\n\trate = src_rate;\n\trate *= ((val & PRCM_PLL_FREQ_D_MASK) >> PRCM_PLL_FREQ_D_SHIFT);\n\n\td = ((val & PRCM_PLL_FREQ_N_MASK) >> PRCM_PLL_FREQ_N_SHIFT);\n\tif (d > 1)\n\t\tdiv *= d;\n\n\td = ((val & PRCM_PLL_FREQ_R_MASK) >> PRCM_PLL_FREQ_R_SHIFT);\n\tif (d > 1)\n\t\tdiv *= d;\n\n\tif (val & PRCM_PLL_FREQ_SELDIV2)\n\t\tdiv *= 2;\n\n\tif ((branch == PLL_FIX) || ((branch == PLL_DIV) &&\n\t\t(val & PRCM_PLL_FREQ_DIV2EN) &&\n\t\t((reg == PRCM_PLLSOC0_FREQ) ||\n\t\t (reg == PRCM_PLLARM_FREQ) ||\n\t\t (reg == PRCM_PLLDDR_FREQ))))\n\t\tdiv *= 2;\n\n\t(void)do_div(rate, div);\n\n\treturn (unsigned long)rate;\n}\n\n#define ROOT_CLOCK_RATE 38400000\n\nstatic unsigned long clock_rate(u8 clock)\n{\n\tu32 val;\n\tu32 pllsw;\n\tunsigned long rate = ROOT_CLOCK_RATE;\n\n\tval = readl(prcmu_base + clk_mgt[clock].offset);\n\n\tif (val & PRCM_CLK_MGT_CLK38) {\n\t\tif (clk_mgt[clock].clk38div && (val & PRCM_CLK_MGT_CLK38DIV))\n\t\t\trate /= 2;\n\t\treturn rate;\n\t}\n\n\tval |= clk_mgt[clock].pllsw;\n\tpllsw = (val & PRCM_CLK_MGT_CLKPLLSW_MASK);\n\n\tif (pllsw == PRCM_CLK_MGT_CLKPLLSW_SOC0)\n\t\trate = pll_rate(PRCM_PLLSOC0_FREQ, rate, clk_mgt[clock].branch);\n\telse if (pllsw == PRCM_CLK_MGT_CLKPLLSW_SOC1)\n\t\trate = pll_rate(PRCM_PLLSOC1_FREQ, rate, clk_mgt[clock].branch);\n\telse if (pllsw == PRCM_CLK_MGT_CLKPLLSW_DDR)\n\t\trate = pll_rate(PRCM_PLLDDR_FREQ, rate, clk_mgt[clock].branch);\n\telse\n\t\treturn 0;\n\n\tif ((clock == PRCMU_SGACLK) &&\n\t\t(val & PRCM_SGACLK_MGT_SGACLKDIV_BY_2_5_EN)) {\n\t\tu64 r = (rate * 10);\n\n\t\t(void)do_div(r, 25);\n\t\treturn (unsigned long)r;\n\t}\n\tval &= PRCM_CLK_MGT_CLKPLLDIV_MASK;\n\tif (val)\n\t\treturn rate / val;\n\telse\n\t\treturn 0;\n}\n\nstatic unsigned long armss_rate(void)\n{\n\tu32 r;\n\tunsigned long rate;\n\n\tr = readl(PRCM_ARM_CHGCLKREQ);\n\n\tif (r & PRCM_ARM_CHGCLKREQ_PRCM_ARM_CHGCLKREQ) {\n\t\t \n\n\t\trate = pll_rate(PRCM_PLLDDR_FREQ, ROOT_CLOCK_RATE, PLL_FIX);\n\n\t\t \n\t\tif (!(r & PRCM_ARM_CHGCLKREQ_PRCM_ARM_DIVSEL))\n\t\t\trate /= 2;\n\n\t\t \n\t\tr = readl(PRCM_ARMCLKFIX_MGT);\n\t\tr &= PRCM_CLK_MGT_CLKPLLDIV_MASK;\n\t\trate /= r;\n\n\t} else { \n\t\trate = pll_rate(PRCM_PLLARM_FREQ, ROOT_CLOCK_RATE, PLL_DIV);\n\t}\n\n\treturn rate;\n}\n\nstatic unsigned long dsiclk_rate(u8 n)\n{\n\tu32 divsel;\n\tu32 div = 1;\n\n\tdivsel = readl(PRCM_DSI_PLLOUT_SEL);\n\tdivsel = ((divsel & dsiclk[n].divsel_mask) >> dsiclk[n].divsel_shift);\n\n\tif (divsel == PRCM_DSI_PLLOUT_SEL_OFF)\n\t\tdivsel = dsiclk[n].divsel;\n\telse\n\t\tdsiclk[n].divsel = divsel;\n\n\tswitch (divsel) {\n\tcase PRCM_DSI_PLLOUT_SEL_PHI_4:\n\t\tdiv *= 2;\n\t\tfallthrough;\n\tcase PRCM_DSI_PLLOUT_SEL_PHI_2:\n\t\tdiv *= 2;\n\t\tfallthrough;\n\tcase PRCM_DSI_PLLOUT_SEL_PHI:\n\t\treturn pll_rate(PRCM_PLLDSI_FREQ, clock_rate(PRCMU_HDMICLK),\n\t\t\tPLL_RAW) / div;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic unsigned long dsiescclk_rate(u8 n)\n{\n\tu32 div;\n\n\tdiv = readl(PRCM_DSITVCLK_DIV);\n\tdiv = ((div & dsiescclk[n].div_mask) >> (dsiescclk[n].div_shift));\n\treturn clock_rate(PRCMU_TVCLK) / max((u32)1, div);\n}\n\nunsigned long prcmu_clock_rate(u8 clock)\n{\n\tif (clock < PRCMU_NUM_REG_CLOCKS)\n\t\treturn clock_rate(clock);\n\telse if (clock == PRCMU_TIMCLK)\n\t\treturn prcmu_is_ulppll_disabled() ?\n\t\t\t32768 : ROOT_CLOCK_RATE / 16;\n\telse if (clock == PRCMU_SYSCLK)\n\t\treturn ROOT_CLOCK_RATE;\n\telse if (clock == PRCMU_PLLSOC0)\n\t\treturn pll_rate(PRCM_PLLSOC0_FREQ, ROOT_CLOCK_RATE, PLL_RAW);\n\telse if (clock == PRCMU_PLLSOC1)\n\t\treturn pll_rate(PRCM_PLLSOC1_FREQ, ROOT_CLOCK_RATE, PLL_RAW);\n\telse if (clock == PRCMU_ARMSS)\n\t\treturn armss_rate();\n\telse if (clock == PRCMU_PLLDDR)\n\t\treturn pll_rate(PRCM_PLLDDR_FREQ, ROOT_CLOCK_RATE, PLL_RAW);\n\telse if (clock == PRCMU_PLLDSI)\n\t\treturn pll_rate(PRCM_PLLDSI_FREQ, clock_rate(PRCMU_HDMICLK),\n\t\t\tPLL_RAW);\n\telse if ((clock == PRCMU_DSI0CLK) || (clock == PRCMU_DSI1CLK))\n\t\treturn dsiclk_rate(clock - PRCMU_DSI0CLK);\n\telse if ((PRCMU_DSI0ESCCLK <= clock) && (clock <= PRCMU_DSI2ESCCLK))\n\t\treturn dsiescclk_rate(clock - PRCMU_DSI0ESCCLK);\n\telse\n\t\treturn 0;\n}\n\nstatic unsigned long clock_source_rate(u32 clk_mgt_val, int branch)\n{\n\tif (clk_mgt_val & PRCM_CLK_MGT_CLK38)\n\t\treturn ROOT_CLOCK_RATE;\n\tclk_mgt_val &= PRCM_CLK_MGT_CLKPLLSW_MASK;\n\tif (clk_mgt_val == PRCM_CLK_MGT_CLKPLLSW_SOC0)\n\t\treturn pll_rate(PRCM_PLLSOC0_FREQ, ROOT_CLOCK_RATE, branch);\n\telse if (clk_mgt_val == PRCM_CLK_MGT_CLKPLLSW_SOC1)\n\t\treturn pll_rate(PRCM_PLLSOC1_FREQ, ROOT_CLOCK_RATE, branch);\n\telse if (clk_mgt_val == PRCM_CLK_MGT_CLKPLLSW_DDR)\n\t\treturn pll_rate(PRCM_PLLDDR_FREQ, ROOT_CLOCK_RATE, branch);\n\telse\n\t\treturn 0;\n}\n\nstatic u32 clock_divider(unsigned long src_rate, unsigned long rate)\n{\n\tu32 div;\n\n\tdiv = (src_rate / rate);\n\tif (div == 0)\n\t\treturn 1;\n\tif (rate < (src_rate / div))\n\t\tdiv++;\n\treturn div;\n}\n\nstatic long round_clock_rate(u8 clock, unsigned long rate)\n{\n\tu32 val;\n\tu32 div;\n\tunsigned long src_rate;\n\tlong rounded_rate;\n\n\tval = readl(prcmu_base + clk_mgt[clock].offset);\n\tsrc_rate = clock_source_rate((val | clk_mgt[clock].pllsw),\n\t\tclk_mgt[clock].branch);\n\tdiv = clock_divider(src_rate, rate);\n\tif (val & PRCM_CLK_MGT_CLK38) {\n\t\tif (clk_mgt[clock].clk38div) {\n\t\t\tif (div > 2)\n\t\t\t\tdiv = 2;\n\t\t} else {\n\t\t\tdiv = 1;\n\t\t}\n\t} else if ((clock == PRCMU_SGACLK) && (div == 3)) {\n\t\tu64 r = (src_rate * 10);\n\n\t\t(void)do_div(r, 25);\n\t\tif (r <= rate)\n\t\t\treturn (unsigned long)r;\n\t}\n\trounded_rate = (src_rate / min(div, (u32)31));\n\n\treturn rounded_rate;\n}\n\nstatic const unsigned long db8500_armss_freqs[] = {\n\t199680000,\n\t399360000,\n\t798720000,\n\t998400000\n};\n\n \nstatic const unsigned long db8520_armss_freqs[] = {\n\t199680000,\n\t399360000,\n\t798720000,\n\t1152000000\n};\n\nstatic long round_armss_rate(unsigned long rate)\n{\n\tunsigned long freq = 0;\n\tconst unsigned long *freqs;\n\tint nfreqs;\n\tint i;\n\n\tif (fw_info.version.project == PRCMU_FW_PROJECT_U8520) {\n\t\tfreqs = db8520_armss_freqs;\n\t\tnfreqs = ARRAY_SIZE(db8520_armss_freqs);\n\t} else {\n\t\tfreqs = db8500_armss_freqs;\n\t\tnfreqs = ARRAY_SIZE(db8500_armss_freqs);\n\t}\n\n\t \n\tfor (i = 0; i < nfreqs; i++) {\n\t\tfreq = freqs[i];\n\t\tif (rate <= freq)\n\t\t\tbreak;\n\t}\n\n\t \n\treturn freq;\n}\n\n#define MIN_PLL_VCO_RATE 600000000ULL\n#define MAX_PLL_VCO_RATE 1680640000ULL\n\nstatic long round_plldsi_rate(unsigned long rate)\n{\n\tlong rounded_rate = 0;\n\tunsigned long src_rate;\n\tunsigned long rem;\n\tu32 r;\n\n\tsrc_rate = clock_rate(PRCMU_HDMICLK);\n\trem = rate;\n\n\tfor (r = 7; (rem > 0) && (r > 0); r--) {\n\t\tu64 d;\n\n\t\td = (r * rate);\n\t\t(void)do_div(d, src_rate);\n\t\tif (d < 6)\n\t\t\td = 6;\n\t\telse if (d > 255)\n\t\t\td = 255;\n\t\td *= src_rate;\n\t\tif (((2 * d) < (r * MIN_PLL_VCO_RATE)) ||\n\t\t\t((r * MAX_PLL_VCO_RATE) < (2 * d)))\n\t\t\tcontinue;\n\t\t(void)do_div(d, r);\n\t\tif (rate < d) {\n\t\t\tif (rounded_rate == 0)\n\t\t\t\trounded_rate = (long)d;\n\t\t\tbreak;\n\t\t}\n\t\tif ((rate - d) < rem) {\n\t\t\trem = (rate - d);\n\t\t\trounded_rate = (long)d;\n\t\t}\n\t}\n\treturn rounded_rate;\n}\n\nstatic long round_dsiclk_rate(unsigned long rate)\n{\n\tu32 div;\n\tunsigned long src_rate;\n\tlong rounded_rate;\n\n\tsrc_rate = pll_rate(PRCM_PLLDSI_FREQ, clock_rate(PRCMU_HDMICLK),\n\t\tPLL_RAW);\n\tdiv = clock_divider(src_rate, rate);\n\trounded_rate = (src_rate / ((div > 2) ? 4 : div));\n\n\treturn rounded_rate;\n}\n\nstatic long round_dsiescclk_rate(unsigned long rate)\n{\n\tu32 div;\n\tunsigned long src_rate;\n\tlong rounded_rate;\n\n\tsrc_rate = clock_rate(PRCMU_TVCLK);\n\tdiv = clock_divider(src_rate, rate);\n\trounded_rate = (src_rate / min(div, (u32)255));\n\n\treturn rounded_rate;\n}\n\nlong prcmu_round_clock_rate(u8 clock, unsigned long rate)\n{\n\tif (clock < PRCMU_NUM_REG_CLOCKS)\n\t\treturn round_clock_rate(clock, rate);\n\telse if (clock == PRCMU_ARMSS)\n\t\treturn round_armss_rate(rate);\n\telse if (clock == PRCMU_PLLDSI)\n\t\treturn round_plldsi_rate(rate);\n\telse if ((clock == PRCMU_DSI0CLK) || (clock == PRCMU_DSI1CLK))\n\t\treturn round_dsiclk_rate(rate);\n\telse if ((PRCMU_DSI0ESCCLK <= clock) && (clock <= PRCMU_DSI2ESCCLK))\n\t\treturn round_dsiescclk_rate(rate);\n\telse\n\t\treturn (long)prcmu_clock_rate(clock);\n}\n\nstatic void set_clock_rate(u8 clock, unsigned long rate)\n{\n\tu32 val;\n\tu32 div;\n\tunsigned long src_rate;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&clk_mgt_lock, flags);\n\n\t \n\twhile ((readl(PRCM_SEM) & PRCM_SEM_PRCM_SEM) != 0)\n\t\tcpu_relax();\n\n\tval = readl(prcmu_base + clk_mgt[clock].offset);\n\tsrc_rate = clock_source_rate((val | clk_mgt[clock].pllsw),\n\t\tclk_mgt[clock].branch);\n\tdiv = clock_divider(src_rate, rate);\n\tif (val & PRCM_CLK_MGT_CLK38) {\n\t\tif (clk_mgt[clock].clk38div) {\n\t\t\tif (div > 1)\n\t\t\t\tval |= PRCM_CLK_MGT_CLK38DIV;\n\t\t\telse\n\t\t\t\tval &= ~PRCM_CLK_MGT_CLK38DIV;\n\t\t}\n\t} else if (clock == PRCMU_SGACLK) {\n\t\tval &= ~(PRCM_CLK_MGT_CLKPLLDIV_MASK |\n\t\t\tPRCM_SGACLK_MGT_SGACLKDIV_BY_2_5_EN);\n\t\tif (div == 3) {\n\t\t\tu64 r = (src_rate * 10);\n\n\t\t\t(void)do_div(r, 25);\n\t\t\tif (r <= rate) {\n\t\t\t\tval |= PRCM_SGACLK_MGT_SGACLKDIV_BY_2_5_EN;\n\t\t\t\tdiv = 0;\n\t\t\t}\n\t\t}\n\t\tval |= min(div, (u32)31);\n\t} else {\n\t\tval &= ~PRCM_CLK_MGT_CLKPLLDIV_MASK;\n\t\tval |= min(div, (u32)31);\n\t}\n\twritel(val, prcmu_base + clk_mgt[clock].offset);\n\n\t \n\twritel(0, PRCM_SEM);\n\n\tspin_unlock_irqrestore(&clk_mgt_lock, flags);\n}\n\nstatic int set_armss_rate(unsigned long rate)\n{\n\tunsigned long freq;\n\tu8 opps[] = { ARM_EXTCLK, ARM_50_OPP, ARM_100_OPP, ARM_MAX_OPP };\n\tconst unsigned long *freqs;\n\tint nfreqs;\n\tint i;\n\n\tif (fw_info.version.project == PRCMU_FW_PROJECT_U8520) {\n\t\tfreqs = db8520_armss_freqs;\n\t\tnfreqs = ARRAY_SIZE(db8520_armss_freqs);\n\t} else {\n\t\tfreqs = db8500_armss_freqs;\n\t\tnfreqs = ARRAY_SIZE(db8500_armss_freqs);\n\t}\n\n\t \n\tfor (i = 0; i < nfreqs; i++) {\n\t\tfreq = freqs[i];\n\t\tif (rate == freq)\n\t\t\tbreak;\n\t}\n\n\tif (rate != freq)\n\t\treturn -EINVAL;\n\n\t \n\tpr_debug(\"SET ARM OPP 0x%02x\\n\", opps[i]);\n\treturn db8500_prcmu_set_arm_opp(opps[i]);\n}\n\nstatic int set_plldsi_rate(unsigned long rate)\n{\n\tunsigned long src_rate;\n\tunsigned long rem;\n\tu32 pll_freq = 0;\n\tu32 r;\n\n\tsrc_rate = clock_rate(PRCMU_HDMICLK);\n\trem = rate;\n\n\tfor (r = 7; (rem > 0) && (r > 0); r--) {\n\t\tu64 d;\n\t\tu64 hwrate;\n\n\t\td = (r * rate);\n\t\t(void)do_div(d, src_rate);\n\t\tif (d < 6)\n\t\t\td = 6;\n\t\telse if (d > 255)\n\t\t\td = 255;\n\t\thwrate = (d * src_rate);\n\t\tif (((2 * hwrate) < (r * MIN_PLL_VCO_RATE)) ||\n\t\t\t((r * MAX_PLL_VCO_RATE) < (2 * hwrate)))\n\t\t\tcontinue;\n\t\t(void)do_div(hwrate, r);\n\t\tif (rate < hwrate) {\n\t\t\tif (pll_freq == 0)\n\t\t\t\tpll_freq = (((u32)d << PRCM_PLL_FREQ_D_SHIFT) |\n\t\t\t\t\t(r << PRCM_PLL_FREQ_R_SHIFT));\n\t\t\tbreak;\n\t\t}\n\t\tif ((rate - hwrate) < rem) {\n\t\t\trem = (rate - hwrate);\n\t\t\tpll_freq = (((u32)d << PRCM_PLL_FREQ_D_SHIFT) |\n\t\t\t\t(r << PRCM_PLL_FREQ_R_SHIFT));\n\t\t}\n\t}\n\tif (pll_freq == 0)\n\t\treturn -EINVAL;\n\n\tpll_freq |= (1 << PRCM_PLL_FREQ_N_SHIFT);\n\twritel(pll_freq, PRCM_PLLDSI_FREQ);\n\n\treturn 0;\n}\n\nstatic void set_dsiclk_rate(u8 n, unsigned long rate)\n{\n\tu32 val;\n\tu32 div;\n\n\tdiv = clock_divider(pll_rate(PRCM_PLLDSI_FREQ,\n\t\t\tclock_rate(PRCMU_HDMICLK), PLL_RAW), rate);\n\n\tdsiclk[n].divsel = (div == 1) ? PRCM_DSI_PLLOUT_SEL_PHI :\n\t\t\t   (div == 2) ? PRCM_DSI_PLLOUT_SEL_PHI_2 :\n\t\t\t    \tPRCM_DSI_PLLOUT_SEL_PHI_4;\n\n\tval = readl(PRCM_DSI_PLLOUT_SEL);\n\tval &= ~dsiclk[n].divsel_mask;\n\tval |= (dsiclk[n].divsel << dsiclk[n].divsel_shift);\n\twritel(val, PRCM_DSI_PLLOUT_SEL);\n}\n\nstatic void set_dsiescclk_rate(u8 n, unsigned long rate)\n{\n\tu32 val;\n\tu32 div;\n\n\tdiv = clock_divider(clock_rate(PRCMU_TVCLK), rate);\n\tval = readl(PRCM_DSITVCLK_DIV);\n\tval &= ~dsiescclk[n].div_mask;\n\tval |= (min(div, (u32)255) << dsiescclk[n].div_shift);\n\twritel(val, PRCM_DSITVCLK_DIV);\n}\n\nint prcmu_set_clock_rate(u8 clock, unsigned long rate)\n{\n\tif (clock < PRCMU_NUM_REG_CLOCKS)\n\t\tset_clock_rate(clock, rate);\n\telse if (clock == PRCMU_ARMSS)\n\t\treturn set_armss_rate(rate);\n\telse if (clock == PRCMU_PLLDSI)\n\t\treturn set_plldsi_rate(rate);\n\telse if ((clock == PRCMU_DSI0CLK) || (clock == PRCMU_DSI1CLK))\n\t\tset_dsiclk_rate((clock - PRCMU_DSI0CLK), rate);\n\telse if ((PRCMU_DSI0ESCCLK <= clock) && (clock <= PRCMU_DSI2ESCCLK))\n\t\tset_dsiescclk_rate((clock - PRCMU_DSI0ESCCLK), rate);\n\treturn 0;\n}\n\nint db8500_prcmu_config_esram0_deep_sleep(u8 state)\n{\n\tif ((state > ESRAM0_DEEP_SLEEP_STATE_RET) ||\n\t    (state < ESRAM0_DEEP_SLEEP_STATE_OFF))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mb4_transfer.lock);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\n\t\tcpu_relax();\n\n\twriteb(MB4H_MEM_ST, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\n\twriteb(((DDR_PWR_STATE_OFFHIGHLAT << 4) | DDR_PWR_STATE_ON),\n\t       (tcdm_base + PRCM_REQ_MB4_DDR_ST_AP_SLEEP_IDLE));\n\twriteb(DDR_PWR_STATE_ON,\n\t       (tcdm_base + PRCM_REQ_MB4_DDR_ST_AP_DEEP_IDLE));\n\twriteb(state, (tcdm_base + PRCM_REQ_MB4_ESRAM0_ST));\n\n\twritel(MBOX_BIT(4), PRCM_MBOX_CPU_SET);\n\twait_for_completion(&mb4_transfer.work);\n\n\tmutex_unlock(&mb4_transfer.lock);\n\n\treturn 0;\n}\n\nint db8500_prcmu_config_hotdog(u8 threshold)\n{\n\tmutex_lock(&mb4_transfer.lock);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\n\t\tcpu_relax();\n\n\twriteb(threshold, (tcdm_base + PRCM_REQ_MB4_HOTDOG_THRESHOLD));\n\twriteb(MB4H_HOTDOG, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\n\n\twritel(MBOX_BIT(4), PRCM_MBOX_CPU_SET);\n\twait_for_completion(&mb4_transfer.work);\n\n\tmutex_unlock(&mb4_transfer.lock);\n\n\treturn 0;\n}\n\nint db8500_prcmu_config_hotmon(u8 low, u8 high)\n{\n\tmutex_lock(&mb4_transfer.lock);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\n\t\tcpu_relax();\n\n\twriteb(low, (tcdm_base + PRCM_REQ_MB4_HOTMON_LOW));\n\twriteb(high, (tcdm_base + PRCM_REQ_MB4_HOTMON_HIGH));\n\twriteb((HOTMON_CONFIG_LOW | HOTMON_CONFIG_HIGH),\n\t\t(tcdm_base + PRCM_REQ_MB4_HOTMON_CONFIG));\n\twriteb(MB4H_HOTMON, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\n\n\twritel(MBOX_BIT(4), PRCM_MBOX_CPU_SET);\n\twait_for_completion(&mb4_transfer.work);\n\n\tmutex_unlock(&mb4_transfer.lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(db8500_prcmu_config_hotmon);\n\nstatic int config_hot_period(u16 val)\n{\n\tmutex_lock(&mb4_transfer.lock);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\n\t\tcpu_relax();\n\n\twritew(val, (tcdm_base + PRCM_REQ_MB4_HOT_PERIOD));\n\twriteb(MB4H_HOT_PERIOD, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\n\n\twritel(MBOX_BIT(4), PRCM_MBOX_CPU_SET);\n\twait_for_completion(&mb4_transfer.work);\n\n\tmutex_unlock(&mb4_transfer.lock);\n\n\treturn 0;\n}\n\nint db8500_prcmu_start_temp_sense(u16 cycles32k)\n{\n\tif (cycles32k == 0xFFFF)\n\t\treturn -EINVAL;\n\n\treturn config_hot_period(cycles32k);\n}\nEXPORT_SYMBOL_GPL(db8500_prcmu_start_temp_sense);\n\nint db8500_prcmu_stop_temp_sense(void)\n{\n\treturn config_hot_period(0xFFFF);\n}\nEXPORT_SYMBOL_GPL(db8500_prcmu_stop_temp_sense);\n\nstatic int prcmu_a9wdog(u8 cmd, u8 d0, u8 d1, u8 d2, u8 d3)\n{\n\n\tmutex_lock(&mb4_transfer.lock);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\n\t\tcpu_relax();\n\n\twriteb(d0, (tcdm_base + PRCM_REQ_MB4_A9WDOG_0));\n\twriteb(d1, (tcdm_base + PRCM_REQ_MB4_A9WDOG_1));\n\twriteb(d2, (tcdm_base + PRCM_REQ_MB4_A9WDOG_2));\n\twriteb(d3, (tcdm_base + PRCM_REQ_MB4_A9WDOG_3));\n\n\twriteb(cmd, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\n\n\twritel(MBOX_BIT(4), PRCM_MBOX_CPU_SET);\n\twait_for_completion(&mb4_transfer.work);\n\n\tmutex_unlock(&mb4_transfer.lock);\n\n\treturn 0;\n\n}\n\nint db8500_prcmu_config_a9wdog(u8 num, bool sleep_auto_off)\n{\n\tBUG_ON(num == 0 || num > 0xf);\n\treturn prcmu_a9wdog(MB4H_A9WDOG_CONF, num, 0, 0,\n\t\t\t    sleep_auto_off ? A9WDOG_AUTO_OFF_EN :\n\t\t\t    A9WDOG_AUTO_OFF_DIS);\n}\nEXPORT_SYMBOL(db8500_prcmu_config_a9wdog);\n\nint db8500_prcmu_enable_a9wdog(u8 id)\n{\n\treturn prcmu_a9wdog(MB4H_A9WDOG_EN, id, 0, 0, 0);\n}\nEXPORT_SYMBOL(db8500_prcmu_enable_a9wdog);\n\nint db8500_prcmu_disable_a9wdog(u8 id)\n{\n\treturn prcmu_a9wdog(MB4H_A9WDOG_DIS, id, 0, 0, 0);\n}\nEXPORT_SYMBOL(db8500_prcmu_disable_a9wdog);\n\nint db8500_prcmu_kick_a9wdog(u8 id)\n{\n\treturn prcmu_a9wdog(MB4H_A9WDOG_KICK, id, 0, 0, 0);\n}\nEXPORT_SYMBOL(db8500_prcmu_kick_a9wdog);\n\n \nint db8500_prcmu_load_a9wdog(u8 id, u32 timeout)\n{\n\treturn prcmu_a9wdog(MB4H_A9WDOG_LOAD,\n\t\t\t    (id & A9WDOG_ID_MASK) |\n\t\t\t     \n\t\t\t    (u8)((timeout << 4) & 0xf0),\n\t\t\t    (u8)((timeout >> 4) & 0xff),\n\t\t\t    (u8)((timeout >> 12) & 0xff),\n\t\t\t    (u8)((timeout >> 20) & 0xff));\n}\nEXPORT_SYMBOL(db8500_prcmu_load_a9wdog);\n\n \nint prcmu_abb_read(u8 slave, u8 reg, u8 *value, u8 size)\n{\n\tint r;\n\n\tif (size != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mb5_transfer.lock);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(5))\n\t\tcpu_relax();\n\n\twriteb(0, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB5));\n\twriteb(PRCMU_I2C_READ(slave), (tcdm_base + PRCM_REQ_MB5_I2C_SLAVE_OP));\n\twriteb(PRCMU_I2C_STOP_EN, (tcdm_base + PRCM_REQ_MB5_I2C_HW_BITS));\n\twriteb(reg, (tcdm_base + PRCM_REQ_MB5_I2C_REG));\n\twriteb(0, (tcdm_base + PRCM_REQ_MB5_I2C_VAL));\n\n\twritel(MBOX_BIT(5), PRCM_MBOX_CPU_SET);\n\n\tif (!wait_for_completion_timeout(&mb5_transfer.work,\n\t\t\t\tmsecs_to_jiffies(20000))) {\n\t\tpr_err(\"prcmu: %s timed out (20 s) waiting for a reply.\\n\",\n\t\t\t__func__);\n\t\tr = -EIO;\n\t} else {\n\t\tr = ((mb5_transfer.ack.status == I2C_RD_OK) ? 0 : -EIO);\n\t}\n\n\tif (!r)\n\t\t*value = mb5_transfer.ack.value;\n\n\tmutex_unlock(&mb5_transfer.lock);\n\n\treturn r;\n}\n\n \nint prcmu_abb_write_masked(u8 slave, u8 reg, u8 *value, u8 *mask, u8 size)\n{\n\tint r;\n\n\tif (size != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mb5_transfer.lock);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(5))\n\t\tcpu_relax();\n\n\twriteb(~*mask, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB5));\n\twriteb(PRCMU_I2C_WRITE(slave), (tcdm_base + PRCM_REQ_MB5_I2C_SLAVE_OP));\n\twriteb(PRCMU_I2C_STOP_EN, (tcdm_base + PRCM_REQ_MB5_I2C_HW_BITS));\n\twriteb(reg, (tcdm_base + PRCM_REQ_MB5_I2C_REG));\n\twriteb(*value, (tcdm_base + PRCM_REQ_MB5_I2C_VAL));\n\n\twritel(MBOX_BIT(5), PRCM_MBOX_CPU_SET);\n\n\tif (!wait_for_completion_timeout(&mb5_transfer.work,\n\t\t\t\tmsecs_to_jiffies(20000))) {\n\t\tpr_err(\"prcmu: %s timed out (20 s) waiting for a reply.\\n\",\n\t\t\t__func__);\n\t\tr = -EIO;\n\t} else {\n\t\tr = ((mb5_transfer.ack.status == I2C_WR_OK) ? 0 : -EIO);\n\t}\n\n\tmutex_unlock(&mb5_transfer.lock);\n\n\treturn r;\n}\n\n \nint prcmu_abb_write(u8 slave, u8 reg, u8 *value, u8 size)\n{\n\tu8 mask = ~0;\n\n\treturn prcmu_abb_write_masked(slave, reg, value, &mask, size);\n}\n\n \nint prcmu_ac_wake_req(void)\n{\n\tu32 val;\n\tint ret = 0;\n\n\tmutex_lock(&mb0_transfer.ac_wake_lock);\n\n\tval = readl(PRCM_HOSTACCESS_REQ);\n\tif (val & PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ)\n\t\tgoto unlock_and_return;\n\n\tatomic_set(&ac_wake_req_state, 1);\n\n\t \n\tval |= PRCM_HOSTACCESS_REQ_WAKE_REQ;\n\twritel(val, PRCM_HOSTACCESS_REQ);\n\n\tudelay(31);\n\n\tval |= PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ;\n\twritel(val, PRCM_HOSTACCESS_REQ);\n\n\tif (!wait_for_completion_timeout(&mb0_transfer.ac_wake_work,\n\t\t\tmsecs_to_jiffies(5000))) {\n\t\tpr_crit(\"prcmu: %s timed out (5 s) waiting for a reply.\\n\",\n\t\t\t__func__);\n\t\tret = -EFAULT;\n\t}\n\nunlock_and_return:\n\tmutex_unlock(&mb0_transfer.ac_wake_lock);\n\treturn ret;\n}\n\n \nvoid prcmu_ac_sleep_req(void)\n{\n\tu32 val;\n\n\tmutex_lock(&mb0_transfer.ac_wake_lock);\n\n\tval = readl(PRCM_HOSTACCESS_REQ);\n\tif (!(val & PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ))\n\t\tgoto unlock_and_return;\n\n\twritel((val & ~PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ),\n\t\tPRCM_HOSTACCESS_REQ);\n\n\tif (!wait_for_completion_timeout(&mb0_transfer.ac_wake_work,\n\t\t\tmsecs_to_jiffies(5000))) {\n\t\tpr_crit(\"prcmu: %s timed out (5 s) waiting for a reply.\\n\",\n\t\t\t__func__);\n\t}\n\n\tatomic_set(&ac_wake_req_state, 0);\n\nunlock_and_return:\n\tmutex_unlock(&mb0_transfer.ac_wake_lock);\n}\n\nbool db8500_prcmu_is_ac_wake_requested(void)\n{\n\treturn (atomic_read(&ac_wake_req_state) != 0);\n}\n\n \nvoid db8500_prcmu_system_reset(u16 reset_code)\n{\n\twritew(reset_code, (tcdm_base + PRCM_SW_RST_REASON));\n\twritel(1, PRCM_APE_SOFTRST);\n}\n\n \nu16 db8500_prcmu_get_reset_code(void)\n{\n\treturn readw(tcdm_base + PRCM_SW_RST_REASON);\n}\n\n \nvoid db8500_prcmu_modem_reset(void)\n{\n\tmutex_lock(&mb1_transfer.lock);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\n\t\tcpu_relax();\n\n\twriteb(MB1H_RESET_MODEM, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\n\twritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\n\twait_for_completion(&mb1_transfer.work);\n\n\t \n\n\tmutex_unlock(&mb1_transfer.lock);\n}\n\nstatic void ack_dbb_wakeup(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mb0_transfer.lock, flags);\n\n\twhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(0))\n\t\tcpu_relax();\n\n\twriteb(MB0H_READ_WAKEUP_ACK, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB0));\n\twritel(MBOX_BIT(0), PRCM_MBOX_CPU_SET);\n\n\tspin_unlock_irqrestore(&mb0_transfer.lock, flags);\n}\n\nstatic inline void print_unknown_header_warning(u8 n, u8 header)\n{\n\tpr_warn(\"prcmu: Unknown message header (%d) in mailbox %d\\n\",\n\t\theader, n);\n}\n\nstatic bool read_mailbox_0(void)\n{\n\tbool r;\n\tu32 ev;\n\tunsigned int n;\n\tu8 header;\n\n\theader = readb(tcdm_base + PRCM_MBOX_HEADER_ACK_MB0);\n\tswitch (header) {\n\tcase MB0H_WAKEUP_EXE:\n\tcase MB0H_WAKEUP_SLEEP:\n\t\tif (readb(tcdm_base + PRCM_ACK_MB0_READ_POINTER) & 1)\n\t\t\tev = readl(tcdm_base + PRCM_ACK_MB0_WAKEUP_1_8500);\n\t\telse\n\t\t\tev = readl(tcdm_base + PRCM_ACK_MB0_WAKEUP_0_8500);\n\n\t\tif (ev & (WAKEUP_BIT_AC_WAKE_ACK | WAKEUP_BIT_AC_SLEEP_ACK))\n\t\t\tcomplete(&mb0_transfer.ac_wake_work);\n\t\tif (ev & WAKEUP_BIT_SYSCLK_OK)\n\t\t\tcomplete(&mb3_transfer.sysclk_work);\n\n\t\tev &= mb0_transfer.req.dbb_irqs;\n\n\t\tfor (n = 0; n < NUM_PRCMU_WAKEUPS; n++) {\n\t\t\tif (ev & prcmu_irq_bit[n])\n\t\t\t\tgeneric_handle_domain_irq(db8500_irq_domain, n);\n\t\t}\n\t\tr = true;\n\t\tbreak;\n\tdefault:\n\t\tprint_unknown_header_warning(0, header);\n\t\tr = false;\n\t\tbreak;\n\t}\n\twritel(MBOX_BIT(0), PRCM_ARM_IT1_CLR);\n\treturn r;\n}\n\nstatic bool read_mailbox_1(void)\n{\n\tmb1_transfer.ack.header = readb(tcdm_base + PRCM_MBOX_HEADER_REQ_MB1);\n\tmb1_transfer.ack.arm_opp = readb(tcdm_base +\n\t\tPRCM_ACK_MB1_CURRENT_ARM_OPP);\n\tmb1_transfer.ack.ape_opp = readb(tcdm_base +\n\t\tPRCM_ACK_MB1_CURRENT_APE_OPP);\n\tmb1_transfer.ack.ape_voltage_status = readb(tcdm_base +\n\t\tPRCM_ACK_MB1_APE_VOLTAGE_STATUS);\n\twritel(MBOX_BIT(1), PRCM_ARM_IT1_CLR);\n\tcomplete(&mb1_transfer.work);\n\treturn false;\n}\n\nstatic bool read_mailbox_2(void)\n{\n\tmb2_transfer.ack.status = readb(tcdm_base + PRCM_ACK_MB2_DPS_STATUS);\n\twritel(MBOX_BIT(2), PRCM_ARM_IT1_CLR);\n\tcomplete(&mb2_transfer.work);\n\treturn false;\n}\n\nstatic bool read_mailbox_3(void)\n{\n\twritel(MBOX_BIT(3), PRCM_ARM_IT1_CLR);\n\treturn false;\n}\n\nstatic bool read_mailbox_4(void)\n{\n\tu8 header;\n\tbool do_complete = true;\n\n\theader = readb(tcdm_base + PRCM_MBOX_HEADER_REQ_MB4);\n\tswitch (header) {\n\tcase MB4H_MEM_ST:\n\tcase MB4H_HOTDOG:\n\tcase MB4H_HOTMON:\n\tcase MB4H_HOT_PERIOD:\n\tcase MB4H_A9WDOG_CONF:\n\tcase MB4H_A9WDOG_EN:\n\tcase MB4H_A9WDOG_DIS:\n\tcase MB4H_A9WDOG_LOAD:\n\tcase MB4H_A9WDOG_KICK:\n\t\tbreak;\n\tdefault:\n\t\tprint_unknown_header_warning(4, header);\n\t\tdo_complete = false;\n\t\tbreak;\n\t}\n\n\twritel(MBOX_BIT(4), PRCM_ARM_IT1_CLR);\n\n\tif (do_complete)\n\t\tcomplete(&mb4_transfer.work);\n\n\treturn false;\n}\n\nstatic bool read_mailbox_5(void)\n{\n\tmb5_transfer.ack.status = readb(tcdm_base + PRCM_ACK_MB5_I2C_STATUS);\n\tmb5_transfer.ack.value = readb(tcdm_base + PRCM_ACK_MB5_I2C_VAL);\n\twritel(MBOX_BIT(5), PRCM_ARM_IT1_CLR);\n\tcomplete(&mb5_transfer.work);\n\treturn false;\n}\n\nstatic bool read_mailbox_6(void)\n{\n\twritel(MBOX_BIT(6), PRCM_ARM_IT1_CLR);\n\treturn false;\n}\n\nstatic bool read_mailbox_7(void)\n{\n\twritel(MBOX_BIT(7), PRCM_ARM_IT1_CLR);\n\treturn false;\n}\n\nstatic bool (* const read_mailbox[NUM_MB])(void) = {\n\tread_mailbox_0,\n\tread_mailbox_1,\n\tread_mailbox_2,\n\tread_mailbox_3,\n\tread_mailbox_4,\n\tread_mailbox_5,\n\tread_mailbox_6,\n\tread_mailbox_7\n};\n\nstatic irqreturn_t prcmu_irq_handler(int irq, void *data)\n{\n\tu32 bits;\n\tu8 n;\n\tirqreturn_t r;\n\n\tbits = (readl(PRCM_ARM_IT1_VAL) & ALL_MBOX_BITS);\n\tif (unlikely(!bits))\n\t\treturn IRQ_NONE;\n\n\tr = IRQ_HANDLED;\n\tfor (n = 0; bits; n++) {\n\t\tif (bits & MBOX_BIT(n)) {\n\t\t\tbits -= MBOX_BIT(n);\n\t\t\tif (read_mailbox[n]())\n\t\t\t\tr = IRQ_WAKE_THREAD;\n\t\t}\n\t}\n\treturn r;\n}\n\nstatic irqreturn_t prcmu_irq_thread_fn(int irq, void *data)\n{\n\tack_dbb_wakeup();\n\treturn IRQ_HANDLED;\n}\n\nstatic void prcmu_mask_work(struct work_struct *work)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mb0_transfer.lock, flags);\n\n\tconfig_wakeups();\n\n\tspin_unlock_irqrestore(&mb0_transfer.lock, flags);\n}\n\nstatic void prcmu_irq_mask(struct irq_data *d)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mb0_transfer.dbb_irqs_lock, flags);\n\n\tmb0_transfer.req.dbb_irqs &= ~prcmu_irq_bit[d->hwirq];\n\n\tspin_unlock_irqrestore(&mb0_transfer.dbb_irqs_lock, flags);\n\n\tif (d->irq != IRQ_PRCMU_CA_SLEEP)\n\t\tschedule_work(&mb0_transfer.mask_work);\n}\n\nstatic void prcmu_irq_unmask(struct irq_data *d)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mb0_transfer.dbb_irqs_lock, flags);\n\n\tmb0_transfer.req.dbb_irqs |= prcmu_irq_bit[d->hwirq];\n\n\tspin_unlock_irqrestore(&mb0_transfer.dbb_irqs_lock, flags);\n\n\tif (d->irq != IRQ_PRCMU_CA_SLEEP)\n\t\tschedule_work(&mb0_transfer.mask_work);\n}\n\nstatic void noop(struct irq_data *d)\n{\n}\n\nstatic struct irq_chip prcmu_irq_chip = {\n\t.name\t\t= \"prcmu\",\n\t.irq_disable\t= prcmu_irq_mask,\n\t.irq_ack\t= noop,\n\t.irq_mask\t= prcmu_irq_mask,\n\t.irq_unmask\t= prcmu_irq_unmask,\n};\n\nstatic char *fw_project_name(u32 project)\n{\n\tswitch (project) {\n\tcase PRCMU_FW_PROJECT_U8500:\n\t\treturn \"U8500\";\n\tcase PRCMU_FW_PROJECT_U8400:\n\t\treturn \"U8400\";\n\tcase PRCMU_FW_PROJECT_U9500:\n\t\treturn \"U9500\";\n\tcase PRCMU_FW_PROJECT_U8500_MBB:\n\t\treturn \"U8500 MBB\";\n\tcase PRCMU_FW_PROJECT_U8500_C1:\n\t\treturn \"U8500 C1\";\n\tcase PRCMU_FW_PROJECT_U8500_C2:\n\t\treturn \"U8500 C2\";\n\tcase PRCMU_FW_PROJECT_U8500_C3:\n\t\treturn \"U8500 C3\";\n\tcase PRCMU_FW_PROJECT_U8500_C4:\n\t\treturn \"U8500 C4\";\n\tcase PRCMU_FW_PROJECT_U9500_MBL:\n\t\treturn \"U9500 MBL\";\n\tcase PRCMU_FW_PROJECT_U8500_SSG1:\n\t\treturn \"U8500 Samsung 1\";\n\tcase PRCMU_FW_PROJECT_U8500_MBL2:\n\t\treturn \"U8500 MBL2\";\n\tcase PRCMU_FW_PROJECT_U8520:\n\t\treturn \"U8520 MBL\";\n\tcase PRCMU_FW_PROJECT_U8420:\n\t\treturn \"U8420\";\n\tcase PRCMU_FW_PROJECT_U8500_SSG2:\n\t\treturn \"U8500 Samsung 2\";\n\tcase PRCMU_FW_PROJECT_U8420_SYSCLK:\n\t\treturn \"U8420-sysclk\";\n\tcase PRCMU_FW_PROJECT_U9540:\n\t\treturn \"U9540\";\n\tcase PRCMU_FW_PROJECT_A9420:\n\t\treturn \"A9420\";\n\tcase PRCMU_FW_PROJECT_L8540:\n\t\treturn \"L8540\";\n\tcase PRCMU_FW_PROJECT_L8580:\n\t\treturn \"L8580\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic int db8500_irq_map(struct irq_domain *d, unsigned int virq,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(virq, &prcmu_irq_chip,\n\t\t\t\thandle_simple_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops db8500_irq_ops = {\n\t.map    = db8500_irq_map,\n\t.xlate  = irq_domain_xlate_twocell,\n};\n\nstatic int db8500_irq_init(struct device_node *np)\n{\n\tint i;\n\n\tdb8500_irq_domain = irq_domain_add_simple(\n\t\tnp, NUM_PRCMU_WAKEUPS, 0,\n\t\t&db8500_irq_ops, NULL);\n\n\tif (!db8500_irq_domain) {\n\t\tpr_err(\"Failed to create irqdomain\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_PRCMU_WAKEUPS; i++)\n\t\tirq_create_mapping(db8500_irq_domain, i);\n\n\treturn 0;\n}\n\nstatic void dbx500_fw_version_init(struct device_node *np)\n{\n\tvoid __iomem *tcpm_base;\n\tu32 version;\n\n\ttcpm_base = of_iomap(np, 1);\n\tif (!tcpm_base) {\n\t\tpr_err(\"no prcmu tcpm mem region provided\\n\");\n\t\treturn;\n\t}\n\n\tversion = readl(tcpm_base + DB8500_PRCMU_FW_VERSION_OFFSET);\n\tfw_info.version.project = (version & 0xFF);\n\tfw_info.version.api_version = (version >> 8) & 0xFF;\n\tfw_info.version.func_version = (version >> 16) & 0xFF;\n\tfw_info.version.errata = (version >> 24) & 0xFF;\n\tstrncpy(fw_info.version.project_name,\n\t\tfw_project_name(fw_info.version.project),\n\t\tPRCMU_FW_PROJECT_NAME_LEN);\n\tfw_info.valid = true;\n\tpr_info(\"PRCMU firmware: %s(%d), version %d.%d.%d\\n\",\n\t\tfw_info.version.project_name,\n\t\tfw_info.version.project,\n\t\tfw_info.version.api_version,\n\t\tfw_info.version.func_version,\n\t\tfw_info.version.errata);\n\tiounmap(tcpm_base);\n}\n\nvoid __init db8500_prcmu_early_init(void)\n{\n\t \n\tstruct device_node *np;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"stericsson,db8500-prcmu\");\n\tprcmu_base = of_iomap(np, 0);\n\tif (!prcmu_base) {\n\t\tof_node_put(np);\n\t\tpr_err(\"%s: ioremap() of prcmu registers failed!\\n\", __func__);\n\t\treturn;\n\t}\n\tdbx500_fw_version_init(np);\n\tof_node_put(np);\n\n\tspin_lock_init(&mb0_transfer.lock);\n\tspin_lock_init(&mb0_transfer.dbb_irqs_lock);\n\tmutex_init(&mb0_transfer.ac_wake_lock);\n\tinit_completion(&mb0_transfer.ac_wake_work);\n\tmutex_init(&mb1_transfer.lock);\n\tinit_completion(&mb1_transfer.work);\n\tmb1_transfer.ape_opp = APE_NO_CHANGE;\n\tmutex_init(&mb2_transfer.lock);\n\tinit_completion(&mb2_transfer.work);\n\tspin_lock_init(&mb2_transfer.auto_pm_lock);\n\tspin_lock_init(&mb3_transfer.lock);\n\tmutex_init(&mb3_transfer.sysclk_lock);\n\tinit_completion(&mb3_transfer.sysclk_work);\n\tmutex_init(&mb4_transfer.lock);\n\tinit_completion(&mb4_transfer.work);\n\tmutex_init(&mb5_transfer.lock);\n\tinit_completion(&mb5_transfer.work);\n\n\tINIT_WORK(&mb0_transfer.mask_work, prcmu_mask_work);\n}\n\nstatic void init_prcm_registers(void)\n{\n\tu32 val;\n\n\tval = readl(PRCM_A9PL_FORCE_CLKEN);\n\tval &= ~(PRCM_A9PL_FORCE_CLKEN_PRCM_A9PL_FORCE_CLKEN |\n\t\tPRCM_A9PL_FORCE_CLKEN_PRCM_A9AXI_FORCE_CLKEN);\n\twritel(val, (PRCM_A9PL_FORCE_CLKEN));\n}\n\n \nstatic struct regulator_consumer_supply db8500_vape_consumers[] = {\n\tREGULATOR_SUPPLY(\"v-ape\", NULL),\n\tREGULATOR_SUPPLY(\"v-i2c\", \"nmk-i2c.0\"),\n\tREGULATOR_SUPPLY(\"v-i2c\", \"nmk-i2c.1\"),\n\tREGULATOR_SUPPLY(\"v-i2c\", \"nmk-i2c.2\"),\n\tREGULATOR_SUPPLY(\"v-i2c\", \"nmk-i2c.3\"),\n\tREGULATOR_SUPPLY(\"v-i2c\", \"nmk-i2c.4\"),\n\t \n\tREGULATOR_SUPPLY(\"vcore\", \"sdi0\"),\n\tREGULATOR_SUPPLY(\"vcore\", \"sdi1\"),\n\tREGULATOR_SUPPLY(\"vcore\", \"sdi2\"),\n\tREGULATOR_SUPPLY(\"vcore\", \"sdi3\"),\n\tREGULATOR_SUPPLY(\"vcore\", \"sdi4\"),\n\tREGULATOR_SUPPLY(\"v-dma\", \"dma40.0\"),\n\tREGULATOR_SUPPLY(\"v-ape\", \"ab8500-usb.0\"),\n\t \n\tREGULATOR_SUPPLY(\"vcore\", \"uart0\"),\n\tREGULATOR_SUPPLY(\"vcore\", \"uart1\"),\n\tREGULATOR_SUPPLY(\"vcore\", \"uart2\"),\n\tREGULATOR_SUPPLY(\"v-ape\", \"nmk-ske-keypad.0\"),\n\tREGULATOR_SUPPLY(\"v-hsi\", \"ste_hsi.0\"),\n\tREGULATOR_SUPPLY(\"vddvario\", \"smsc911x.0\"),\n};\n\nstatic struct regulator_consumer_supply db8500_vsmps2_consumers[] = {\n\tREGULATOR_SUPPLY(\"musb_1v8\", \"ab8500-usb.0\"),\n\t \n\tREGULATOR_SUPPLY(\"hdmi_1v8\", \"0-0070\"),\n};\n\nstatic struct regulator_consumer_supply db8500_b2r2_mcde_consumers[] = {\n\tREGULATOR_SUPPLY(\"vsupply\", \"b2r2_bus\"),\n\tREGULATOR_SUPPLY(\"vsupply\", \"mcde\"),\n};\n\n \nstatic struct regulator_consumer_supply db8500_svammdsp_consumers[] = {\n\tREGULATOR_SUPPLY(\"sva-mmdsp\", \"cm_control\"),\n};\n\n \nstatic struct regulator_consumer_supply db8500_svapipe_consumers[] = {\n\tREGULATOR_SUPPLY(\"sva-pipe\", \"cm_control\"),\n};\n\n \nstatic struct regulator_consumer_supply db8500_siammdsp_consumers[] = {\n\tREGULATOR_SUPPLY(\"sia-mmdsp\", \"cm_control\"),\n};\n\n \nstatic struct regulator_consumer_supply db8500_siapipe_consumers[] = {\n\tREGULATOR_SUPPLY(\"sia-pipe\", \"cm_control\"),\n};\n\nstatic struct regulator_consumer_supply db8500_sga_consumers[] = {\n\tREGULATOR_SUPPLY(\"v-mali\", NULL),\n};\n\n \nstatic struct regulator_consumer_supply db8500_esram12_consumers[] = {\n\tREGULATOR_SUPPLY(\"esram12\", \"cm_control\"),\n};\n\n \nstatic struct regulator_consumer_supply db8500_esram34_consumers[] = {\n\tREGULATOR_SUPPLY(\"v-esram34\", \"mcde\"),\n\tREGULATOR_SUPPLY(\"esram34\", \"cm_control\"),\n\tREGULATOR_SUPPLY(\"lcla_esram\", \"dma40.0\"),\n};\n\nstatic struct regulator_init_data db8500_regulators[DB8500_NUM_REGULATORS] = {\n\t[DB8500_REGULATOR_VAPE] = {\n\t\t.constraints = {\n\t\t\t.name = \"db8500-vape\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t\t.always_on = true,\n\t\t},\n\t\t.consumer_supplies = db8500_vape_consumers,\n\t\t.num_consumer_supplies = ARRAY_SIZE(db8500_vape_consumers),\n\t},\n\t[DB8500_REGULATOR_VARM] = {\n\t\t.constraints = {\n\t\t\t.name = \"db8500-varm\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t},\n\t[DB8500_REGULATOR_VMODEM] = {\n\t\t.constraints = {\n\t\t\t.name = \"db8500-vmodem\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t},\n\t[DB8500_REGULATOR_VPLL] = {\n\t\t.constraints = {\n\t\t\t.name = \"db8500-vpll\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t},\n\t[DB8500_REGULATOR_VSMPS1] = {\n\t\t.constraints = {\n\t\t\t.name = \"db8500-vsmps1\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t},\n\t[DB8500_REGULATOR_VSMPS2] = {\n\t\t.constraints = {\n\t\t\t.name = \"db8500-vsmps2\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t\t.consumer_supplies = db8500_vsmps2_consumers,\n\t\t.num_consumer_supplies = ARRAY_SIZE(db8500_vsmps2_consumers),\n\t},\n\t[DB8500_REGULATOR_VSMPS3] = {\n\t\t.constraints = {\n\t\t\t.name = \"db8500-vsmps3\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t},\n\t[DB8500_REGULATOR_VRF1] = {\n\t\t.constraints = {\n\t\t\t.name = \"db8500-vrf1\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t},\n\t[DB8500_REGULATOR_SWITCH_SVAMMDSP] = {\n\t\t \n\t\t.constraints = {\n\t\t\t.name = \"db8500-sva-mmdsp\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t\t.consumer_supplies = db8500_svammdsp_consumers,\n\t\t.num_consumer_supplies = ARRAY_SIZE(db8500_svammdsp_consumers),\n\t},\n\t[DB8500_REGULATOR_SWITCH_SVAMMDSPRET] = {\n\t\t.constraints = {\n\t\t\t \n\t\t\t.name = \"db8500-sva-mmdsp-ret\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t},\n\t[DB8500_REGULATOR_SWITCH_SVAPIPE] = {\n\t\t \n\t\t.constraints = {\n\t\t\t.name = \"db8500-sva-pipe\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t\t.consumer_supplies = db8500_svapipe_consumers,\n\t\t.num_consumer_supplies = ARRAY_SIZE(db8500_svapipe_consumers),\n\t},\n\t[DB8500_REGULATOR_SWITCH_SIAMMDSP] = {\n\t\t \n\t\t.constraints = {\n\t\t\t.name = \"db8500-sia-mmdsp\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t\t.consumer_supplies = db8500_siammdsp_consumers,\n\t\t.num_consumer_supplies = ARRAY_SIZE(db8500_siammdsp_consumers),\n\t},\n\t[DB8500_REGULATOR_SWITCH_SIAMMDSPRET] = {\n\t\t.constraints = {\n\t\t\t.name = \"db8500-sia-mmdsp-ret\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t},\n\t[DB8500_REGULATOR_SWITCH_SIAPIPE] = {\n\t\t \n\t\t.constraints = {\n\t\t\t.name = \"db8500-sia-pipe\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t\t.consumer_supplies = db8500_siapipe_consumers,\n\t\t.num_consumer_supplies = ARRAY_SIZE(db8500_siapipe_consumers),\n\t},\n\t[DB8500_REGULATOR_SWITCH_SGA] = {\n\t\t.supply_regulator = \"db8500-vape\",\n\t\t.constraints = {\n\t\t\t.name = \"db8500-sga\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t\t.consumer_supplies = db8500_sga_consumers,\n\t\t.num_consumer_supplies = ARRAY_SIZE(db8500_sga_consumers),\n\n\t},\n\t[DB8500_REGULATOR_SWITCH_B2R2_MCDE] = {\n\t\t.supply_regulator = \"db8500-vape\",\n\t\t.constraints = {\n\t\t\t.name = \"db8500-b2r2-mcde\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t\t.consumer_supplies = db8500_b2r2_mcde_consumers,\n\t\t.num_consumer_supplies = ARRAY_SIZE(db8500_b2r2_mcde_consumers),\n\t},\n\t[DB8500_REGULATOR_SWITCH_ESRAM12] = {\n\t\t \n\t\t.constraints = {\n\t\t\t.name = \"db8500-esram12\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t\t.consumer_supplies = db8500_esram12_consumers,\n\t\t.num_consumer_supplies = ARRAY_SIZE(db8500_esram12_consumers),\n\t},\n\t[DB8500_REGULATOR_SWITCH_ESRAM12RET] = {\n\t\t.constraints = {\n\t\t\t.name = \"db8500-esram12-ret\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t},\n\t[DB8500_REGULATOR_SWITCH_ESRAM34] = {\n\t\t \n\t\t.constraints = {\n\t\t\t.name = \"db8500-esram34\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t\t.consumer_supplies = db8500_esram34_consumers,\n\t\t.num_consumer_supplies = ARRAY_SIZE(db8500_esram34_consumers),\n\t},\n\t[DB8500_REGULATOR_SWITCH_ESRAM34RET] = {\n\t\t.constraints = {\n\t\t\t.name = \"db8500-esram34-ret\",\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t},\n\t},\n};\n\nstatic const struct mfd_cell common_prcmu_devs[] = {\n\tMFD_CELL_NAME(\"db8500_wdt\"),\n\tMFD_CELL_NAME(\"db8500-cpuidle\"),\n};\n\nstatic const struct mfd_cell db8500_prcmu_devs[] = {\n\tMFD_CELL_OF(\"db8500-prcmu-regulators\", NULL,\n\t\t    &db8500_regulators, sizeof(db8500_regulators), 0,\n\t\t    \"stericsson,db8500-prcmu-regulator\"),\n\tMFD_CELL_OF(\"db8500-thermal\",\n\t\t    NULL, NULL, 0, 0, \"stericsson,db8500-thermal\"),\n};\n\nstatic int db8500_prcmu_register_ab8500(struct device *parent)\n{\n\tstruct device_node *np;\n\tstruct resource ab850x_resource;\n\tconst struct mfd_cell ab8500_cell = {\n\t\t.name = \"ab8500-core\",\n\t\t.of_compatible = \"stericsson,ab8500\",\n\t\t.id = AB8500_VERSION_AB8500,\n\t\t.resources = &ab850x_resource,\n\t\t.num_resources = 1,\n\t};\n\tconst struct mfd_cell ab8505_cell = {\n\t\t.name = \"ab8505-core\",\n\t\t.of_compatible = \"stericsson,ab8505\",\n\t\t.id = AB8500_VERSION_AB8505,\n\t\t.resources = &ab850x_resource,\n\t\t.num_resources = 1,\n\t};\n\tconst struct mfd_cell *ab850x_cell;\n\n\tif (!parent->of_node)\n\t\treturn -ENODEV;\n\n\t \n\tfor_each_child_of_node(parent->of_node, np) {\n\t\tif (of_device_is_compatible(np, ab8500_cell.of_compatible)) {\n\t\t\tab850x_cell = &ab8500_cell;\n\t\t\tbreak;\n\t\t}\n\t\tif (of_device_is_compatible(np, ab8505_cell.of_compatible)) {\n\t\t\tab850x_cell = &ab8505_cell;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!np) {\n\t\tdev_info(parent, \"could not find AB850X node in the device tree\\n\");\n\t\treturn -ENODEV;\n\t}\n\tof_irq_to_resource_table(np, &ab850x_resource, 1);\n\n\treturn mfd_add_devices(parent, 0, ab850x_cell, 1, NULL, 0, NULL);\n}\n\nstatic int db8500_prcmu_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint irq = 0, err = 0;\n\tstruct resource *res;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"prcmu\");\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"no prcmu memory region provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\tprcmu_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!prcmu_base) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to ioremap prcmu register memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tinit_prcm_registers();\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"prcmu-tcdm\");\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"no prcmu tcdm region provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttcdm_base = devm_ioremap(&pdev->dev, res->start,\n\t\t\tresource_size(res));\n\tif (!tcdm_base) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to ioremap prcmu-tcdm register memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\twritel(ALL_MBOX_BITS, PRCM_ARM_IT1_CLR);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq <= 0)\n\t\treturn irq;\n\n\terr = request_threaded_irq(irq, prcmu_irq_handler,\n\t        prcmu_irq_thread_fn, IRQF_NO_SUSPEND, \"prcmu\", NULL);\n\tif (err < 0) {\n\t\tpr_err(\"prcmu: Failed to allocate IRQ_DB8500_PRCMU1.\\n\");\n\t\treturn err;\n\t}\n\n\tdb8500_irq_init(np);\n\n\tprcmu_config_esram0_deep_sleep(ESRAM0_DEEP_SLEEP_STATE_RET);\n\n\terr = mfd_add_devices(&pdev->dev, 0, common_prcmu_devs,\n\t\t\t      ARRAY_SIZE(common_prcmu_devs), NULL, 0, db8500_irq_domain);\n\tif (err) {\n\t\tpr_err(\"prcmu: Failed to add subdevices\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (!of_machine_is_compatible(\"st-ericsson,u8540\")) {\n\t\terr = mfd_add_devices(&pdev->dev, 0, db8500_prcmu_devs,\n\t\t\t\t      ARRAY_SIZE(db8500_prcmu_devs), NULL, 0,\n\t\t\t\t      db8500_irq_domain);\n\t\tif (err) {\n\t\t\tmfd_remove_devices(&pdev->dev);\n\t\t\tpr_err(\"prcmu: Failed to add subdevices\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = db8500_prcmu_register_ab8500(&pdev->dev);\n\tif (err) {\n\t\tmfd_remove_devices(&pdev->dev);\n\t\tpr_err(\"prcmu: Failed to add ab8500 subdevice\\n\");\n\t\treturn err;\n\t}\n\n\tpr_info(\"DB8500 PRCMU initialized\\n\");\n\treturn err;\n}\nstatic const struct of_device_id db8500_prcmu_match[] = {\n\t{ .compatible = \"stericsson,db8500-prcmu\"},\n\t{ },\n};\n\nstatic struct platform_driver db8500_prcmu_driver = {\n\t.driver = {\n\t\t.name = \"db8500-prcmu\",\n\t\t.of_match_table = db8500_prcmu_match,\n\t},\n\t.probe = db8500_prcmu_probe,\n};\n\nstatic int __init db8500_prcmu_init(void)\n{\n\treturn platform_driver_register(&db8500_prcmu_driver);\n}\ncore_initcall(db8500_prcmu_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}