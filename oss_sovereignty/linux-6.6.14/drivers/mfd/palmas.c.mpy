{
  "module_name": "palmas.c",
  "hash_id": "e89104df54971cfe4dfdd3e30c1bfdfa9c9d7d44f3ca8053a4bf18c0581f68a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/palmas.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/regmap.h>\n#include <linux/err.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/palmas.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n\nstatic const struct regmap_config palmas_regmap_config[PALMAS_NUM_CLIENTS] = {\n\t{\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = PALMAS_BASE_TO_REG(PALMAS_PU_PD_OD_BASE,\n\t\t\t\t\tPALMAS_PRIMARY_SECONDARY_PAD3),\n\t},\n\t{\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = PALMAS_BASE_TO_REG(PALMAS_GPADC_BASE,\n\t\t\t\t\tPALMAS_GPADC_SMPS_VSEL_MONITORING),\n\t},\n\t{\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = PALMAS_BASE_TO_REG(PALMAS_TRIM_GPADC_BASE,\n\t\t\t\t\tPALMAS_GPADC_TRIM16),\n\t},\n};\n\nstatic const struct regmap_irq tps65917_irqs[] = {\n\t \n\t[TPS65917_RESERVED1] = {\n\t\t.mask = TPS65917_RESERVED,\n\t},\n\t[TPS65917_PWRON_IRQ] = {\n\t\t.mask = TPS65917_INT1_STATUS_PWRON,\n\t},\n\t[TPS65917_LONG_PRESS_KEY_IRQ] = {\n\t\t.mask = TPS65917_INT1_STATUS_LONG_PRESS_KEY,\n\t},\n\t[TPS65917_RESERVED2] = {\n\t\t.mask = TPS65917_RESERVED,\n\t},\n\t[TPS65917_PWRDOWN_IRQ] = {\n\t\t.mask = TPS65917_INT1_STATUS_PWRDOWN,\n\t},\n\t[TPS65917_HOTDIE_IRQ] = {\n\t\t.mask = TPS65917_INT1_STATUS_HOTDIE,\n\t},\n\t[TPS65917_VSYS_MON_IRQ] = {\n\t\t.mask = TPS65917_INT1_STATUS_VSYS_MON,\n\t},\n\t[TPS65917_RESERVED3] = {\n\t\t.mask = TPS65917_RESERVED,\n\t},\n\t \n\t[TPS65917_RESERVED4] = {\n\t\t.mask = TPS65917_RESERVED,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65917_OTP_ERROR_IRQ] = {\n\t\t.mask = TPS65917_INT2_STATUS_OTP_ERROR,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65917_WDT_IRQ] = {\n\t\t.mask = TPS65917_INT2_STATUS_WDT,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65917_RESERVED5] = {\n\t\t.mask = TPS65917_RESERVED,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65917_RESET_IN_IRQ] = {\n\t\t.mask = TPS65917_INT2_STATUS_RESET_IN,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65917_FSD_IRQ] = {\n\t\t.mask = TPS65917_INT2_STATUS_FSD,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65917_SHORT_IRQ] = {\n\t\t.mask = TPS65917_INT2_STATUS_SHORT,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65917_RESERVED6] = {\n\t\t.mask = TPS65917_RESERVED,\n\t\t.reg_offset = 1,\n\t},\n\t \n\t[TPS65917_GPADC_AUTO_0_IRQ] = {\n\t\t.mask = TPS65917_INT3_STATUS_GPADC_AUTO_0,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65917_GPADC_AUTO_1_IRQ] = {\n\t\t.mask = TPS65917_INT3_STATUS_GPADC_AUTO_1,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65917_GPADC_EOC_SW_IRQ] = {\n\t\t.mask = TPS65917_INT3_STATUS_GPADC_EOC_SW,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65917_RESREVED6] = {\n\t\t.mask = TPS65917_RESERVED6,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65917_RESERVED7] = {\n\t\t.mask = TPS65917_RESERVED,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65917_RESERVED8] = {\n\t\t.mask = TPS65917_RESERVED,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65917_RESERVED9] = {\n\t\t.mask = TPS65917_RESERVED,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65917_VBUS_IRQ] = {\n\t\t.mask = TPS65917_INT3_STATUS_VBUS,\n\t\t.reg_offset = 2,\n\t},\n\t \n\t[TPS65917_GPIO_0_IRQ] = {\n\t\t.mask = TPS65917_INT4_STATUS_GPIO_0,\n\t\t.reg_offset = 3,\n\t},\n\t[TPS65917_GPIO_1_IRQ] = {\n\t\t.mask = TPS65917_INT4_STATUS_GPIO_1,\n\t\t.reg_offset = 3,\n\t},\n\t[TPS65917_GPIO_2_IRQ] = {\n\t\t.mask = TPS65917_INT4_STATUS_GPIO_2,\n\t\t.reg_offset = 3,\n\t},\n\t[TPS65917_GPIO_3_IRQ] = {\n\t\t.mask = TPS65917_INT4_STATUS_GPIO_3,\n\t\t.reg_offset = 3,\n\t},\n\t[TPS65917_GPIO_4_IRQ] = {\n\t\t.mask = TPS65917_INT4_STATUS_GPIO_4,\n\t\t.reg_offset = 3,\n\t},\n\t[TPS65917_GPIO_5_IRQ] = {\n\t\t.mask = TPS65917_INT4_STATUS_GPIO_5,\n\t\t.reg_offset = 3,\n\t},\n\t[TPS65917_GPIO_6_IRQ] = {\n\t\t.mask = TPS65917_INT4_STATUS_GPIO_6,\n\t\t.reg_offset = 3,\n\t},\n\t[TPS65917_RESERVED10] = {\n\t\t.mask = TPS65917_RESERVED10,\n\t\t.reg_offset = 3,\n\t},\n};\n\nstatic const struct regmap_irq palmas_irqs[] = {\n\t \n\t[PALMAS_CHARG_DET_N_VBUS_OVV_IRQ] = {\n\t\t.mask = PALMAS_INT1_STATUS_CHARG_DET_N_VBUS_OVV,\n\t},\n\t[PALMAS_PWRON_IRQ] = {\n\t\t.mask = PALMAS_INT1_STATUS_PWRON,\n\t},\n\t[PALMAS_LONG_PRESS_KEY_IRQ] = {\n\t\t.mask = PALMAS_INT1_STATUS_LONG_PRESS_KEY,\n\t},\n\t[PALMAS_RPWRON_IRQ] = {\n\t\t.mask = PALMAS_INT1_STATUS_RPWRON,\n\t},\n\t[PALMAS_PWRDOWN_IRQ] = {\n\t\t.mask = PALMAS_INT1_STATUS_PWRDOWN,\n\t},\n\t[PALMAS_HOTDIE_IRQ] = {\n\t\t.mask = PALMAS_INT1_STATUS_HOTDIE,\n\t},\n\t[PALMAS_VSYS_MON_IRQ] = {\n\t\t.mask = PALMAS_INT1_STATUS_VSYS_MON,\n\t},\n\t[PALMAS_VBAT_MON_IRQ] = {\n\t\t.mask = PALMAS_INT1_STATUS_VBAT_MON,\n\t},\n\t \n\t[PALMAS_RTC_ALARM_IRQ] = {\n\t\t.mask = PALMAS_INT2_STATUS_RTC_ALARM,\n\t\t.reg_offset = 1,\n\t},\n\t[PALMAS_RTC_TIMER_IRQ] = {\n\t\t.mask = PALMAS_INT2_STATUS_RTC_TIMER,\n\t\t.reg_offset = 1,\n\t},\n\t[PALMAS_WDT_IRQ] = {\n\t\t.mask = PALMAS_INT2_STATUS_WDT,\n\t\t.reg_offset = 1,\n\t},\n\t[PALMAS_BATREMOVAL_IRQ] = {\n\t\t.mask = PALMAS_INT2_STATUS_BATREMOVAL,\n\t\t.reg_offset = 1,\n\t},\n\t[PALMAS_RESET_IN_IRQ] = {\n\t\t.mask = PALMAS_INT2_STATUS_RESET_IN,\n\t\t.reg_offset = 1,\n\t},\n\t[PALMAS_FBI_BB_IRQ] = {\n\t\t.mask = PALMAS_INT2_STATUS_FBI_BB,\n\t\t.reg_offset = 1,\n\t},\n\t[PALMAS_SHORT_IRQ] = {\n\t\t.mask = PALMAS_INT2_STATUS_SHORT,\n\t\t.reg_offset = 1,\n\t},\n\t[PALMAS_VAC_ACOK_IRQ] = {\n\t\t.mask = PALMAS_INT2_STATUS_VAC_ACOK,\n\t\t.reg_offset = 1,\n\t},\n\t \n\t[PALMAS_GPADC_AUTO_0_IRQ] = {\n\t\t.mask = PALMAS_INT3_STATUS_GPADC_AUTO_0,\n\t\t.reg_offset = 2,\n\t},\n\t[PALMAS_GPADC_AUTO_1_IRQ] = {\n\t\t.mask = PALMAS_INT3_STATUS_GPADC_AUTO_1,\n\t\t.reg_offset = 2,\n\t},\n\t[PALMAS_GPADC_EOC_SW_IRQ] = {\n\t\t.mask = PALMAS_INT3_STATUS_GPADC_EOC_SW,\n\t\t.reg_offset = 2,\n\t},\n\t[PALMAS_GPADC_EOC_RT_IRQ] = {\n\t\t.mask = PALMAS_INT3_STATUS_GPADC_EOC_RT,\n\t\t.reg_offset = 2,\n\t},\n\t[PALMAS_ID_OTG_IRQ] = {\n\t\t.mask = PALMAS_INT3_STATUS_ID_OTG,\n\t\t.reg_offset = 2,\n\t},\n\t[PALMAS_ID_IRQ] = {\n\t\t.mask = PALMAS_INT3_STATUS_ID,\n\t\t.reg_offset = 2,\n\t},\n\t[PALMAS_VBUS_OTG_IRQ] = {\n\t\t.mask = PALMAS_INT3_STATUS_VBUS_OTG,\n\t\t.reg_offset = 2,\n\t},\n\t[PALMAS_VBUS_IRQ] = {\n\t\t.mask = PALMAS_INT3_STATUS_VBUS,\n\t\t.reg_offset = 2,\n\t},\n\t \n\t[PALMAS_GPIO_0_IRQ] = {\n\t\t.mask = PALMAS_INT4_STATUS_GPIO_0,\n\t\t.reg_offset = 3,\n\t},\n\t[PALMAS_GPIO_1_IRQ] = {\n\t\t.mask = PALMAS_INT4_STATUS_GPIO_1,\n\t\t.reg_offset = 3,\n\t},\n\t[PALMAS_GPIO_2_IRQ] = {\n\t\t.mask = PALMAS_INT4_STATUS_GPIO_2,\n\t\t.reg_offset = 3,\n\t},\n\t[PALMAS_GPIO_3_IRQ] = {\n\t\t.mask = PALMAS_INT4_STATUS_GPIO_3,\n\t\t.reg_offset = 3,\n\t},\n\t[PALMAS_GPIO_4_IRQ] = {\n\t\t.mask = PALMAS_INT4_STATUS_GPIO_4,\n\t\t.reg_offset = 3,\n\t},\n\t[PALMAS_GPIO_5_IRQ] = {\n\t\t.mask = PALMAS_INT4_STATUS_GPIO_5,\n\t\t.reg_offset = 3,\n\t},\n\t[PALMAS_GPIO_6_IRQ] = {\n\t\t.mask = PALMAS_INT4_STATUS_GPIO_6,\n\t\t.reg_offset = 3,\n\t},\n\t[PALMAS_GPIO_7_IRQ] = {\n\t\t.mask = PALMAS_INT4_STATUS_GPIO_7,\n\t\t.reg_offset = 3,\n\t},\n};\n\nstatic struct regmap_irq_chip palmas_irq_chip = {\n\t.name = \"palmas\",\n\t.irqs = palmas_irqs,\n\t.num_irqs = ARRAY_SIZE(palmas_irqs),\n\n\t.num_regs = 4,\n\t.irq_reg_stride = 5,\n\t.status_base = PALMAS_BASE_TO_REG(PALMAS_INTERRUPT_BASE,\n\t\t\tPALMAS_INT1_STATUS),\n\t.mask_base = PALMAS_BASE_TO_REG(PALMAS_INTERRUPT_BASE,\n\t\t\tPALMAS_INT1_MASK),\n};\n\nstatic struct regmap_irq_chip tps65917_irq_chip = {\n\t.name = \"tps65917\",\n\t.irqs = tps65917_irqs,\n\t.num_irqs = ARRAY_SIZE(tps65917_irqs),\n\n\t.num_regs = 4,\n\t.irq_reg_stride = 5,\n\t.status_base = PALMAS_BASE_TO_REG(PALMAS_INTERRUPT_BASE,\n\t\t\tPALMAS_INT1_STATUS),\n\t.mask_base = PALMAS_BASE_TO_REG(PALMAS_INTERRUPT_BASE,\n\t\t\tPALMAS_INT1_MASK),\n};\n\nint palmas_ext_control_req_config(struct palmas *palmas,\n\tenum palmas_external_requestor_id id,  int ext_ctrl, bool enable)\n{\n\tstruct palmas_pmic_driver_data *pmic_ddata = palmas->pmic_ddata;\n\tint preq_mask_bit = 0;\n\tint reg_add = 0;\n\tint bit_pos, ret;\n\n\tif (!(ext_ctrl & PALMAS_EXT_REQ))\n\t\treturn 0;\n\n\tif (id >= PALMAS_EXTERNAL_REQSTR_ID_MAX)\n\t\treturn 0;\n\n\tif (ext_ctrl & PALMAS_EXT_CONTROL_NSLEEP) {\n\t\treg_add = PALMAS_NSLEEP_RES_ASSIGN;\n\t\tpreq_mask_bit = 0;\n\t} else if (ext_ctrl & PALMAS_EXT_CONTROL_ENABLE1) {\n\t\treg_add = PALMAS_ENABLE1_RES_ASSIGN;\n\t\tpreq_mask_bit = 1;\n\t} else if (ext_ctrl & PALMAS_EXT_CONTROL_ENABLE2) {\n\t\treg_add = PALMAS_ENABLE2_RES_ASSIGN;\n\t\tpreq_mask_bit = 2;\n\t}\n\n\tbit_pos = pmic_ddata->sleep_req_info[id].bit_pos;\n\treg_add += pmic_ddata->sleep_req_info[id].reg_offset;\n\tif (enable)\n\t\tret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,\n\t\t\t\treg_add, BIT(bit_pos), BIT(bit_pos));\n\telse\n\t\tret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,\n\t\t\t\treg_add, BIT(bit_pos), 0);\n\tif (ret < 0) {\n\t\tdev_err(palmas->dev, \"Resource reg 0x%02x update failed %d\\n\",\n\t\t\treg_add, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = palmas_update_bits(palmas, PALMAS_PMU_CONTROL_BASE,\n\t\t\tPALMAS_POWER_CTRL, BIT(preq_mask_bit), 0);\n\tif (ret < 0) {\n\t\tdev_err(palmas->dev, \"POWER_CTRL register update failed %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(palmas_ext_control_req_config);\n\nstatic int palmas_set_pdata_irq_flag(struct i2c_client *i2c,\n\t\tstruct palmas_platform_data *pdata)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(i2c->irq);\n\tif (!irq_data) {\n\t\tdev_err(&i2c->dev, \"Invalid IRQ: %d\\n\", i2c->irq);\n\t\treturn -EINVAL;\n\t}\n\n\tpdata->irq_flags = irqd_get_trigger_type(irq_data);\n\tdev_info(&i2c->dev, \"Irq flag is 0x%08x\\n\", pdata->irq_flags);\n\treturn 0;\n}\n\nstatic void palmas_dt_to_pdata(struct i2c_client *i2c,\n\t\tstruct palmas_platform_data *pdata)\n{\n\tstruct device_node *node = i2c->dev.of_node;\n\tint ret;\n\tu32 prop;\n\n\tret = of_property_read_u32(node, \"ti,mux-pad1\", &prop);\n\tif (!ret) {\n\t\tpdata->mux_from_pdata = 1;\n\t\tpdata->pad1 = prop;\n\t}\n\n\tret = of_property_read_u32(node, \"ti,mux-pad2\", &prop);\n\tif (!ret) {\n\t\tpdata->mux_from_pdata = 1;\n\t\tpdata->pad2 = prop;\n\t}\n\n\t \n\tret = of_property_read_u32(node, \"ti,power-ctrl\", &prop);\n\tif (!ret)\n\t\tpdata->power_ctrl = prop;\n\telse\n\t\tpdata->power_ctrl = PALMAS_POWER_CTRL_NSLEEP_MASK |\n\t\t\t\t\tPALMAS_POWER_CTRL_ENABLE1_MASK |\n\t\t\t\t\tPALMAS_POWER_CTRL_ENABLE2_MASK;\n\tif (i2c->irq)\n\t\tpalmas_set_pdata_irq_flag(i2c, pdata);\n\n\tpdata->pm_off = of_property_read_bool(node,\n\t\t\t\"ti,system-power-controller\");\n}\n\nstatic struct palmas *palmas_dev;\nstatic void palmas_power_off(void)\n{\n\tunsigned int addr;\n\tint ret, slave;\n\tu8 powerhold_mask;\n\tstruct device_node *np = palmas_dev->dev->of_node;\n\n\tif (of_property_read_bool(np, \"ti,palmas-override-powerhold\")) {\n\t\taddr = PALMAS_BASE_TO_REG(PALMAS_PU_PD_OD_BASE,\n\t\t\t\t\t  PALMAS_PRIMARY_SECONDARY_PAD2);\n\t\tslave = PALMAS_BASE_TO_SLAVE(PALMAS_PU_PD_OD_BASE);\n\n\t\tif (of_device_is_compatible(np, \"ti,tps65917\"))\n\t\t\tpowerhold_mask =\n\t\t\t\tTPS65917_PRIMARY_SECONDARY_PAD2_GPIO_5_MASK;\n\t\telse\n\t\t\tpowerhold_mask =\n\t\t\t\tPALMAS_PRIMARY_SECONDARY_PAD2_GPIO_7_MASK;\n\n\t\tret = regmap_update_bits(palmas_dev->regmap[slave], addr,\n\t\t\t\t\t powerhold_mask, 0);\n\t\tif (ret)\n\t\t\tdev_err(palmas_dev->dev,\n\t\t\t\t\"Unable to write PRIMARY_SECONDARY_PAD2 %d\\n\",\n\t\t\t\tret);\n\t}\n\n\tslave = PALMAS_BASE_TO_SLAVE(PALMAS_PMU_CONTROL_BASE);\n\taddr = PALMAS_BASE_TO_REG(PALMAS_PMU_CONTROL_BASE, PALMAS_DEV_CTRL);\n\n\tret = regmap_update_bits(\n\t\t\tpalmas_dev->regmap[slave],\n\t\t\taddr,\n\t\t\tPALMAS_DEV_CTRL_DEV_ON,\n\t\t\t0);\n\n\tif (ret)\n\t\tpr_err(\"%s: Unable to write to DEV_CTRL_DEV_ON: %d\\n\",\n\t\t\t\t__func__, ret);\n}\n\nstatic unsigned int palmas_features = PALMAS_PMIC_FEATURE_SMPS10_BOOST;\nstatic unsigned int tps659038_features;\n\nstruct palmas_driver_data {\n\tunsigned int *features;\n\tstruct regmap_irq_chip *irq_chip;\n};\n\nstatic struct palmas_driver_data palmas_data = {\n\t.features = &palmas_features,\n\t.irq_chip = &palmas_irq_chip,\n};\n\nstatic struct palmas_driver_data tps659038_data = {\n\t.features = &tps659038_features,\n\t.irq_chip = &palmas_irq_chip,\n};\n\nstatic struct palmas_driver_data tps65917_data = {\n\t.features = &tps659038_features,\n\t.irq_chip = &tps65917_irq_chip,\n};\n\nstatic const struct of_device_id of_palmas_match_tbl[] = {\n\t{\n\t\t.compatible = \"ti,palmas\",\n\t\t.data = &palmas_data,\n\t},\n\t{\n\t\t.compatible = \"ti,tps659038\",\n\t\t.data = &tps659038_data,\n\t},\n\t{\n\t\t.compatible = \"ti,tps65917\",\n\t\t.data = &tps65917_data,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, of_palmas_match_tbl);\n\nstatic int palmas_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct palmas *palmas;\n\tstruct palmas_platform_data *pdata;\n\tstruct palmas_driver_data *driver_data;\n\tstruct device_node *node = i2c->dev.of_node;\n\tint ret = 0, i;\n\tunsigned int reg, addr;\n\tint slave;\n\n\tpdata = dev_get_platdata(&i2c->dev);\n\n\tif (node && !pdata) {\n\t\tpdata = devm_kzalloc(&i2c->dev, sizeof(*pdata), GFP_KERNEL);\n\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tpalmas_dt_to_pdata(i2c, pdata);\n\t}\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tpalmas = devm_kzalloc(&i2c->dev, sizeof(struct palmas), GFP_KERNEL);\n\tif (palmas == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, palmas);\n\tpalmas->dev = &i2c->dev;\n\tpalmas->irq = i2c->irq;\n\n\tdriver_data = (struct palmas_driver_data *) device_get_match_data(&i2c->dev);\n\tpalmas->features = *driver_data->features;\n\n\tfor (i = 0; i < PALMAS_NUM_CLIENTS; i++) {\n\t\tif (i == 0)\n\t\t\tpalmas->i2c_clients[i] = i2c;\n\t\telse {\n\t\t\tpalmas->i2c_clients[i] =\n\t\t\t\t\ti2c_new_dummy_device(i2c->adapter,\n\t\t\t\t\t\t\ti2c->addr + i);\n\t\t\tif (IS_ERR(palmas->i2c_clients[i])) {\n\t\t\t\tdev_err(palmas->dev,\n\t\t\t\t\t\"can't attach client %d\\n\", i);\n\t\t\t\tret = PTR_ERR(palmas->i2c_clients[i]);\n\t\t\t\tgoto err_i2c;\n\t\t\t}\n\t\t\tpalmas->i2c_clients[i]->dev.of_node = of_node_get(node);\n\t\t}\n\t\tpalmas->regmap[i] = devm_regmap_init_i2c(palmas->i2c_clients[i],\n\t\t\t\t&palmas_regmap_config[i]);\n\t\tif (IS_ERR(palmas->regmap[i])) {\n\t\t\tret = PTR_ERR(palmas->regmap[i]);\n\t\t\tdev_err(palmas->dev,\n\t\t\t\t\"Failed to allocate regmap %d, err: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\tgoto err_i2c;\n\t\t}\n\t}\n\n\tif (!palmas->irq) {\n\t\tdev_warn(palmas->dev, \"IRQ missing: skipping irq request\\n\");\n\t\tgoto no_irq;\n\t}\n\n\t \n\tif (pdata->irq_flags & IRQ_TYPE_LEVEL_HIGH)\n\t\treg = PALMAS_POLARITY_CTRL_INT_POLARITY;\n\telse\n\t\treg = 0;\n\tret = palmas_update_bits(palmas, PALMAS_PU_PD_OD_BASE,\n\t\t\tPALMAS_POLARITY_CTRL, PALMAS_POLARITY_CTRL_INT_POLARITY,\n\t\t\treg);\n\tif (ret < 0) {\n\t\tdev_err(palmas->dev, \"POLARITY_CTRL update failed: %d\\n\", ret);\n\t\tgoto err_i2c;\n\t}\n\n\t \n\tslave = PALMAS_BASE_TO_SLAVE(PALMAS_INTERRUPT_BASE);\n\taddr = PALMAS_BASE_TO_REG(PALMAS_INTERRUPT_BASE, PALMAS_INT_CTRL);\n\treg = PALMAS_INT_CTRL_INT_CLEAR;\n\n\tregmap_write(palmas->regmap[slave], addr, reg);\n\n\tret = regmap_add_irq_chip(palmas->regmap[slave], palmas->irq,\n\t\t\t\t  IRQF_ONESHOT | pdata->irq_flags, 0,\n\t\t\t\t  driver_data->irq_chip, &palmas->irq_data);\n\tif (ret < 0)\n\t\tgoto err_i2c;\n\nno_irq:\n\tslave = PALMAS_BASE_TO_SLAVE(PALMAS_PU_PD_OD_BASE);\n\taddr = PALMAS_BASE_TO_REG(PALMAS_PU_PD_OD_BASE,\n\t\t\tPALMAS_PRIMARY_SECONDARY_PAD1);\n\n\tif (pdata->mux_from_pdata) {\n\t\treg = pdata->pad1;\n\t\tret = regmap_write(palmas->regmap[slave], addr, reg);\n\t\tif (ret)\n\t\t\tgoto err_irq;\n\t} else {\n\t\tret = regmap_read(palmas->regmap[slave], addr, &reg);\n\t\tif (ret)\n\t\t\tgoto err_irq;\n\t}\n\n\tif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_0))\n\t\tpalmas->gpio_muxed |= PALMAS_GPIO_0_MUXED;\n\tif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_MASK))\n\t\tpalmas->gpio_muxed |= PALMAS_GPIO_1_MUXED;\n\telse if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_MASK) ==\n\t\t\t(2 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_SHIFT))\n\t\tpalmas->led_muxed |= PALMAS_LED1_MUXED;\n\telse if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_MASK) ==\n\t\t\t(3 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_SHIFT))\n\t\tpalmas->pwm_muxed |= PALMAS_PWM1_MUXED;\n\tif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_MASK))\n\t\tpalmas->gpio_muxed |= PALMAS_GPIO_2_MUXED;\n\telse if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_MASK) ==\n\t\t\t(2 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_SHIFT))\n\t\tpalmas->led_muxed |= PALMAS_LED2_MUXED;\n\telse if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_MASK) ==\n\t\t\t(3 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_SHIFT))\n\t\tpalmas->pwm_muxed |= PALMAS_PWM2_MUXED;\n\tif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_3))\n\t\tpalmas->gpio_muxed |= PALMAS_GPIO_3_MUXED;\n\n\taddr = PALMAS_BASE_TO_REG(PALMAS_PU_PD_OD_BASE,\n\t\t\tPALMAS_PRIMARY_SECONDARY_PAD2);\n\n\tif (pdata->mux_from_pdata) {\n\t\treg = pdata->pad2;\n\t\tret = regmap_write(palmas->regmap[slave], addr, reg);\n\t\tif (ret)\n\t\t\tgoto err_irq;\n\t} else {\n\t\tret = regmap_read(palmas->regmap[slave], addr, &reg);\n\t\tif (ret)\n\t\t\tgoto err_irq;\n\t}\n\n\tif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_4))\n\t\tpalmas->gpio_muxed |= PALMAS_GPIO_4_MUXED;\n\tif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_5_MASK))\n\t\tpalmas->gpio_muxed |= PALMAS_GPIO_5_MUXED;\n\tif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_6))\n\t\tpalmas->gpio_muxed |= PALMAS_GPIO_6_MUXED;\n\tif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_7_MASK))\n\t\tpalmas->gpio_muxed |= PALMAS_GPIO_7_MUXED;\n\n\tdev_info(palmas->dev, \"Muxing GPIO %x, PWM %x, LED %x\\n\",\n\t\t\tpalmas->gpio_muxed, palmas->pwm_muxed,\n\t\t\tpalmas->led_muxed);\n\n\treg = pdata->power_ctrl;\n\n\tslave = PALMAS_BASE_TO_SLAVE(PALMAS_PMU_CONTROL_BASE);\n\taddr = PALMAS_BASE_TO_REG(PALMAS_PMU_CONTROL_BASE, PALMAS_POWER_CTRL);\n\n\tret = regmap_write(palmas->regmap[slave], addr, reg);\n\tif (ret)\n\t\tgoto err_irq;\n\n\t \n\tif (node) {\n\t\tret = devm_of_platform_populate(&i2c->dev);\n\t\tif (ret < 0) {\n\t\t\tgoto err_irq;\n\t\t} else if (pdata->pm_off && !pm_power_off) {\n\t\t\tpalmas_dev = palmas;\n\t\t\tpm_power_off = palmas_power_off;\n\t\t}\n\t}\n\n\treturn ret;\n\nerr_irq:\n\tregmap_del_irq_chip(palmas->irq, palmas->irq_data);\nerr_i2c:\n\tfor (i = 1; i < PALMAS_NUM_CLIENTS; i++) {\n\t\tif (palmas->i2c_clients[i])\n\t\t\ti2c_unregister_device(palmas->i2c_clients[i]);\n\t}\n\treturn ret;\n}\n\nstatic void palmas_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct palmas *palmas = i2c_get_clientdata(i2c);\n\tint i;\n\n\tregmap_del_irq_chip(palmas->irq, palmas->irq_data);\n\n\tfor (i = 1; i < PALMAS_NUM_CLIENTS; i++) {\n\t\tif (palmas->i2c_clients[i])\n\t\t\ti2c_unregister_device(palmas->i2c_clients[i]);\n\t}\n\n\tif (palmas == palmas_dev) {\n\t\tpm_power_off = NULL;\n\t\tpalmas_dev = NULL;\n\t}\n}\n\nstatic const struct i2c_device_id palmas_i2c_id[] = {\n\t{ \"palmas\", },\n\t{ \"twl6035\", },\n\t{ \"twl6037\", },\n\t{ \"tps65913\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, palmas_i2c_id);\n\nstatic struct i2c_driver palmas_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"palmas\",\n\t\t   .of_match_table = of_palmas_match_tbl,\n\t},\n\t.probe = palmas_i2c_probe,\n\t.remove = palmas_i2c_remove,\n\t.id_table = palmas_i2c_id,\n};\n\nstatic int __init palmas_i2c_init(void)\n{\n\treturn i2c_add_driver(&palmas_i2c_driver);\n}\n \nsubsys_initcall(palmas_i2c_init);\n\nstatic void __exit palmas_i2c_exit(void)\n{\n\ti2c_del_driver(&palmas_i2c_driver);\n}\nmodule_exit(palmas_i2c_exit);\n\nMODULE_AUTHOR(\"Graeme Gregory <gg@slimlogic.co.uk>\");\nMODULE_DESCRIPTION(\"Palmas chip family multi-function driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}