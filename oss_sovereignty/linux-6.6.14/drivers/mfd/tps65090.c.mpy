{
  "module_name": "tps65090.c",
  "hash_id": "747d75749a85fb11f72c0512f76a3d002069fdb903e7412eda3ad16497a07803",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tps65090.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/tps65090.h>\n#include <linux/of.h>\n#include <linux/err.h>\n\n#define NUM_INT_REG 2\n\n#define TPS65090_INT1_MASK_VAC_STATUS_CHANGE\t\t1\n#define TPS65090_INT1_MASK_VSYS_STATUS_CHANGE\t\t2\n#define TPS65090_INT1_MASK_BAT_STATUS_CHANGE\t\t3\n#define TPS65090_INT1_MASK_CHARGING_STATUS_CHANGE\t4\n#define TPS65090_INT1_MASK_CHARGING_COMPLETE\t\t5\n#define TPS65090_INT1_MASK_OVERLOAD_DCDC1\t\t6\n#define TPS65090_INT1_MASK_OVERLOAD_DCDC2\t\t7\n#define TPS65090_INT2_MASK_OVERLOAD_DCDC3\t\t0\n#define TPS65090_INT2_MASK_OVERLOAD_FET1\t\t1\n#define TPS65090_INT2_MASK_OVERLOAD_FET2\t\t2\n#define TPS65090_INT2_MASK_OVERLOAD_FET3\t\t3\n#define TPS65090_INT2_MASK_OVERLOAD_FET4\t\t4\n#define TPS65090_INT2_MASK_OVERLOAD_FET5\t\t5\n#define TPS65090_INT2_MASK_OVERLOAD_FET6\t\t6\n#define TPS65090_INT2_MASK_OVERLOAD_FET7\t\t7\n\nstatic const struct resource charger_resources[] = {\n\t{\n\t\t.start  = TPS65090_IRQ_VAC_STATUS_CHANGE,\n\t\t.end    = TPS65090_IRQ_VAC_STATUS_CHANGE,\n\t\t.flags  = IORESOURCE_IRQ,\n\t}\n};\n\nenum tps65090_cells {\n\tPMIC = 0,\n\tCHARGER = 1,\n};\n\nstatic struct mfd_cell tps65090s[] = {\n\t[PMIC] = {\n\t\t.name = \"tps65090-pmic\",\n\t},\n\t[CHARGER] = {\n\t\t.name = \"tps65090-charger\",\n\t\t.num_resources = ARRAY_SIZE(charger_resources),\n\t\t.resources = &charger_resources[0],\n\t\t.of_compatible = \"ti,tps65090-charger\",\n\t},\n};\n\nstatic const struct regmap_irq tps65090_irqs[] = {\n\t \n\t[TPS65090_IRQ_VAC_STATUS_CHANGE] = {\n\t\t.mask = TPS65090_INT1_MASK_VAC_STATUS_CHANGE,\n\t},\n\t[TPS65090_IRQ_VSYS_STATUS_CHANGE] = {\n\t\t.mask = TPS65090_INT1_MASK_VSYS_STATUS_CHANGE,\n\t},\n\t[TPS65090_IRQ_BAT_STATUS_CHANGE] = {\n\t\t.mask = TPS65090_INT1_MASK_BAT_STATUS_CHANGE,\n\t},\n\t[TPS65090_IRQ_CHARGING_STATUS_CHANGE] = {\n\t\t.mask = TPS65090_INT1_MASK_CHARGING_STATUS_CHANGE,\n\t},\n\t[TPS65090_IRQ_CHARGING_COMPLETE] = {\n\t\t.mask = TPS65090_INT1_MASK_CHARGING_COMPLETE,\n\t},\n\t[TPS65090_IRQ_OVERLOAD_DCDC1] = {\n\t\t.mask = TPS65090_INT1_MASK_OVERLOAD_DCDC1,\n\t},\n\t[TPS65090_IRQ_OVERLOAD_DCDC2] = {\n\t\t.mask = TPS65090_INT1_MASK_OVERLOAD_DCDC2,\n\t},\n\t \n\t[TPS65090_IRQ_OVERLOAD_DCDC3] = {\n\t\t.reg_offset = 1,\n\t\t.mask = TPS65090_INT2_MASK_OVERLOAD_DCDC3,\n\t},\n\t[TPS65090_IRQ_OVERLOAD_FET1] = {\n\t\t.reg_offset = 1,\n\t\t.mask = TPS65090_INT2_MASK_OVERLOAD_FET1,\n\t},\n\t[TPS65090_IRQ_OVERLOAD_FET2] = {\n\t\t.reg_offset = 1,\n\t\t.mask = TPS65090_INT2_MASK_OVERLOAD_FET2,\n\t},\n\t[TPS65090_IRQ_OVERLOAD_FET3] = {\n\t\t.reg_offset = 1,\n\t\t.mask = TPS65090_INT2_MASK_OVERLOAD_FET3,\n\t},\n\t[TPS65090_IRQ_OVERLOAD_FET4] = {\n\t\t.reg_offset = 1,\n\t\t.mask = TPS65090_INT2_MASK_OVERLOAD_FET4,\n\t},\n\t[TPS65090_IRQ_OVERLOAD_FET5] = {\n\t\t.reg_offset = 1,\n\t\t.mask = TPS65090_INT2_MASK_OVERLOAD_FET5,\n\t},\n\t[TPS65090_IRQ_OVERLOAD_FET6] = {\n\t\t.reg_offset = 1,\n\t\t.mask = TPS65090_INT2_MASK_OVERLOAD_FET6,\n\t},\n\t[TPS65090_IRQ_OVERLOAD_FET7] = {\n\t\t.reg_offset = 1,\n\t\t.mask = TPS65090_INT2_MASK_OVERLOAD_FET7,\n\t},\n};\n\nstatic struct regmap_irq_chip tps65090_irq_chip = {\n\t.name = \"tps65090\",\n\t.irqs = tps65090_irqs,\n\t.num_irqs = ARRAY_SIZE(tps65090_irqs),\n\t.num_regs = NUM_INT_REG,\n\t.status_base = TPS65090_REG_INTR_STS,\n\t.unmask_base = TPS65090_REG_INTR_MASK,\n};\n\nstatic bool is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\t \n\tswitch (reg) {\n\tcase TPS65090_REG_INTR_MASK:\n\tcase TPS65090_REG_INTR_MASK2:\n\tcase TPS65090_REG_CG_CTRL0:\n\tcase TPS65090_REG_CG_CTRL1:\n\tcase TPS65090_REG_CG_CTRL2:\n\tcase TPS65090_REG_CG_CTRL3:\n\tcase TPS65090_REG_CG_CTRL4:\n\tcase TPS65090_REG_CG_CTRL5:\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const struct regmap_config tps65090_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = TPS65090_MAX_REG,\n\t.num_reg_defaults_raw = TPS65090_NUM_REGS,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = is_volatile_reg,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tps65090_of_match[] = {\n\t{ .compatible = \"ti,tps65090\",},\n\t{},\n};\n#endif\n\nstatic int tps65090_i2c_probe(struct i2c_client *client)\n{\n\tstruct tps65090_platform_data *pdata = dev_get_platdata(&client->dev);\n\tint irq_base = 0;\n\tstruct tps65090 *tps65090;\n\tint ret;\n\n\tif (!pdata && !client->dev.of_node) {\n\t\tdev_err(&client->dev,\n\t\t\t\"tps65090 requires platform data or of_node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata)\n\t\tirq_base = pdata->irq_base;\n\n\ttps65090 = devm_kzalloc(&client->dev, sizeof(*tps65090), GFP_KERNEL);\n\tif (!tps65090)\n\t\treturn -ENOMEM;\n\n\ttps65090->dev = &client->dev;\n\ti2c_set_clientdata(client, tps65090);\n\n\ttps65090->rmap = devm_regmap_init_i2c(client, &tps65090_regmap_config);\n\tif (IS_ERR(tps65090->rmap)) {\n\t\tret = PTR_ERR(tps65090->rmap);\n\t\tdev_err(&client->dev, \"regmap_init failed with err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (client->irq) {\n\t\tret = regmap_add_irq_chip(tps65090->rmap, client->irq,\n\t\t\t\t\t  IRQF_ONESHOT | IRQF_TRIGGER_LOW, irq_base,\n\t\t\t\t\t  &tps65090_irq_chip, &tps65090->irq_data);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"IRQ init failed with err: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\ttps65090s[CHARGER].num_resources = 0;\n\t}\n\n\tret = mfd_add_devices(tps65090->dev, -1, tps65090s,\n\t\t\t      ARRAY_SIZE(tps65090s), NULL,\n\t\t\t      0, regmap_irq_get_domain(tps65090->irq_data));\n\tif (ret) {\n\t\tdev_err(&client->dev, \"add mfd devices failed with err: %d\\n\",\n\t\t\tret);\n\t\tgoto err_irq_exit;\n\t}\n\n\treturn 0;\n\nerr_irq_exit:\n\tif (client->irq)\n\t\tregmap_del_irq_chip(client->irq, tps65090->irq_data);\n\treturn ret;\n}\n\n\nstatic const struct i2c_device_id tps65090_id_table[] = {\n\t{ \"tps65090\", 0 },\n\t{ },\n};\n\nstatic struct i2c_driver tps65090_driver = {\n\t.driver\t= {\n\t\t.name\t= \"tps65090\",\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = of_match_ptr(tps65090_of_match),\n\t},\n\t.probe\t\t= tps65090_i2c_probe,\n\t.id_table\t= tps65090_id_table,\n};\n\nstatic int __init tps65090_init(void)\n{\n\treturn i2c_add_driver(&tps65090_driver);\n}\nsubsys_initcall(tps65090_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}