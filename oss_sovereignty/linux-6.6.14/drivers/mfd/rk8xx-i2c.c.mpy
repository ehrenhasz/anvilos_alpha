{
  "module_name": "rk8xx-i2c.c",
  "hash_id": "8b95c14d5515eef2e0e4d96f7b4c083439dda7e33da4f3071cf4eef0aaf8286b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rk8xx-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/mfd/rk808.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\nstruct rk8xx_i2c_platform_data {\n\tconst struct regmap_config *regmap_cfg;\n\tint variant;\n};\n\nstatic bool rk808_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\t \n\n\tswitch (reg) {\n\tcase RK808_SECONDS_REG ... RK808_WEEKS_REG:\n\tcase RK808_RTC_STATUS_REG:\n\tcase RK808_VB_MON_REG:\n\tcase RK808_THERMAL_REG:\n\tcase RK808_DCDC_UV_STS_REG:\n\tcase RK808_LDO_UV_STS_REG:\n\tcase RK808_DCDC_PG_REG:\n\tcase RK808_LDO_PG_REG:\n\tcase RK808_DEVCTRL_REG:\n\tcase RK808_INT_STS_REG1:\n\tcase RK808_INT_STS_REG2:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool rk817_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\t \n\n\tswitch (reg) {\n\tcase RK817_SECONDS_REG ... RK817_WEEKS_REG:\n\tcase RK817_RTC_STATUS_REG:\n\tcase RK817_CODEC_DTOP_LPT_SRST:\n\tcase RK817_GAS_GAUGE_ADC_CONFIG0 ... RK817_GAS_GAUGE_CUR_ADC_K0:\n\tcase RK817_PMIC_CHRG_STS:\n\tcase RK817_PMIC_CHRG_OUT:\n\tcase RK817_PMIC_CHRG_IN:\n\tcase RK817_INT_STS_REG0:\n\tcase RK817_INT_STS_REG1:\n\tcase RK817_INT_STS_REG2:\n\tcase RK817_SYS_STS:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\nstatic const struct regmap_config rk818_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RK818_USB_CTRL_REG,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = rk808_is_volatile_reg,\n};\n\nstatic const struct regmap_config rk805_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RK805_OFF_SOURCE_REG,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = rk808_is_volatile_reg,\n};\n\nstatic const struct regmap_config rk808_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RK808_IO_POL_REG,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = rk808_is_volatile_reg,\n};\n\nstatic const struct regmap_config rk817_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RK817_GPIO_INT_CFG,\n\t.cache_type = REGCACHE_NONE,\n\t.volatile_reg = rk817_is_volatile_reg,\n};\n\nstatic const struct rk8xx_i2c_platform_data rk805_data = {\n\t.regmap_cfg = &rk805_regmap_config,\n\t.variant = RK805_ID,\n};\n\nstatic const struct rk8xx_i2c_platform_data rk808_data = {\n\t.regmap_cfg = &rk808_regmap_config,\n\t.variant = RK808_ID,\n};\n\nstatic const struct rk8xx_i2c_platform_data rk809_data = {\n\t.regmap_cfg = &rk817_regmap_config,\n\t.variant = RK809_ID,\n};\n\nstatic const struct rk8xx_i2c_platform_data rk817_data = {\n\t.regmap_cfg = &rk817_regmap_config,\n\t.variant = RK817_ID,\n};\n\nstatic const struct rk8xx_i2c_platform_data rk818_data = {\n\t.regmap_cfg = &rk818_regmap_config,\n\t.variant = RK818_ID,\n};\n\nstatic int rk8xx_i2c_probe(struct i2c_client *client)\n{\n\tconst struct rk8xx_i2c_platform_data *data;\n\tstruct regmap *regmap;\n\n\tdata = device_get_match_data(&client->dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tregmap = devm_regmap_init_i2c(client, data->regmap_cfg);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(regmap),\n\t\t\t\t     \"regmap initialization failed\\n\");\n\n\treturn rk8xx_probe(&client->dev, data->variant, client->irq, regmap);\n}\n\nstatic void rk8xx_i2c_shutdown(struct i2c_client *client)\n{\n\trk8xx_shutdown(&client->dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(rk8xx_i2c_pm_ops, rk8xx_suspend, rk8xx_resume);\n\nstatic const struct of_device_id rk8xx_i2c_of_match[] = {\n\t{ .compatible = \"rockchip,rk805\", .data = &rk805_data },\n\t{ .compatible = \"rockchip,rk808\", .data = &rk808_data },\n\t{ .compatible = \"rockchip,rk809\", .data = &rk809_data },\n\t{ .compatible = \"rockchip,rk817\", .data = &rk817_data },\n\t{ .compatible = \"rockchip,rk818\", .data = &rk818_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rk8xx_i2c_of_match);\n\nstatic struct i2c_driver rk8xx_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rk8xx-i2c\",\n\t\t.of_match_table = rk8xx_i2c_of_match,\n\t\t.pm = &rk8xx_i2c_pm_ops,\n\t},\n\t.probe = rk8xx_i2c_probe,\n\t.shutdown  = rk8xx_i2c_shutdown,\n};\nmodule_i2c_driver(rk8xx_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Chris Zhong <zyw@rock-chips.com>\");\nMODULE_AUTHOR(\"Zhang Qing <zhangqing@rock-chips.com>\");\nMODULE_AUTHOR(\"Wadim Egorov <w.egorov@phytec.de>\");\nMODULE_DESCRIPTION(\"RK8xx I2C PMIC driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}