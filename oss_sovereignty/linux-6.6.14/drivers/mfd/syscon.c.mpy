{
  "module_name": "syscon.c",
  "hash_id": "0b39211a59d868bf110078754fc5b5565038543009b93713a9e60dc0b607d24e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/syscon.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/hwspinlock.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_data/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/mfd/syscon.h>\n#include <linux/slab.h>\n\nstatic struct platform_driver syscon_driver;\n\nstatic DEFINE_SPINLOCK(syscon_list_slock);\nstatic LIST_HEAD(syscon_list);\n\nstruct syscon {\n\tstruct device_node *np;\n\tstruct regmap *regmap;\n\tstruct reset_control *reset;\n\tstruct list_head list;\n};\n\nstatic const struct regmap_config syscon_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic struct syscon *of_syscon_register(struct device_node *np, bool check_res)\n{\n\tstruct clk *clk;\n\tstruct syscon *syscon;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tu32 reg_io_width;\n\tint ret;\n\tstruct regmap_config syscon_config = syscon_regmap_config;\n\tstruct resource res;\n\tstruct reset_control *reset;\n\n\tsyscon = kzalloc(sizeof(*syscon), GFP_KERNEL);\n\tif (!syscon)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (of_address_to_resource(np, 0, &res)) {\n\t\tret = -ENOMEM;\n\t\tgoto err_map;\n\t}\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tret = -ENOMEM;\n\t\tgoto err_map;\n\t}\n\n\t \n\tif (of_property_read_bool(np, \"big-endian\"))\n\t\tsyscon_config.val_format_endian = REGMAP_ENDIAN_BIG;\n\telse if (of_property_read_bool(np, \"little-endian\"))\n\t\tsyscon_config.val_format_endian = REGMAP_ENDIAN_LITTLE;\n\telse if (of_property_read_bool(np, \"native-endian\"))\n\t\tsyscon_config.val_format_endian = REGMAP_ENDIAN_NATIVE;\n\n\t \n\tret = of_property_read_u32(np, \"reg-io-width\", &reg_io_width);\n\tif (ret)\n\t\treg_io_width = 4;\n\n\tret = of_hwspin_lock_get_id(np, 0);\n\tif (ret > 0 || (IS_ENABLED(CONFIG_HWSPINLOCK) && ret == 0)) {\n\t\tsyscon_config.use_hwlock = true;\n\t\tsyscon_config.hwlock_id = ret;\n\t\tsyscon_config.hwlock_mode = HWLOCK_IRQSTATE;\n\t} else if (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -ENOENT:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Failed to retrieve valid hwlock: %d\\n\", ret);\n\t\t\tfallthrough;\n\t\tcase -EPROBE_DEFER:\n\t\t\tgoto err_regmap;\n\t\t}\n\t}\n\n\tsyscon_config.name = kasprintf(GFP_KERNEL, \"%pOFn@%pa\", np, &res.start);\n\tif (!syscon_config.name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_regmap;\n\t}\n\tsyscon_config.reg_stride = reg_io_width;\n\tsyscon_config.val_bits = reg_io_width * 8;\n\tsyscon_config.max_register = resource_size(&res) - reg_io_width;\n\n\tregmap = regmap_init_mmio(NULL, base, &syscon_config);\n\tkfree(syscon_config.name);\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"regmap init failed\\n\");\n\t\tret = PTR_ERR(regmap);\n\t\tgoto err_regmap;\n\t}\n\n\tif (check_res) {\n\t\tclk = of_clk_get(np, 0);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\t \n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto err_clk;\n\t\t} else {\n\t\t\tret = regmap_mmio_attach_clk(regmap, clk);\n\t\t\tif (ret)\n\t\t\t\tgoto err_attach_clk;\n\t\t}\n\n\t\treset = of_reset_control_get_optional_exclusive(np, NULL);\n\t\tif (IS_ERR(reset)) {\n\t\t\tret = PTR_ERR(reset);\n\t\t\tgoto err_attach_clk;\n\t\t}\n\n\t\tret = reset_control_deassert(reset);\n\t\tif (ret)\n\t\t\tgoto err_reset;\n\t}\n\n\tsyscon->regmap = regmap;\n\tsyscon->np = np;\n\n\tspin_lock(&syscon_list_slock);\n\tlist_add_tail(&syscon->list, &syscon_list);\n\tspin_unlock(&syscon_list_slock);\n\n\treturn syscon;\n\nerr_reset:\n\treset_control_put(reset);\nerr_attach_clk:\n\tif (!IS_ERR(clk))\n\t\tclk_put(clk);\nerr_clk:\n\tregmap_exit(regmap);\nerr_regmap:\n\tiounmap(base);\nerr_map:\n\tkfree(syscon);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct regmap *device_node_get_regmap(struct device_node *np,\n\t\t\t\t\t     bool check_res)\n{\n\tstruct syscon *entry, *syscon = NULL;\n\n\tspin_lock(&syscon_list_slock);\n\n\tlist_for_each_entry(entry, &syscon_list, list)\n\t\tif (entry->np == np) {\n\t\t\tsyscon = entry;\n\t\t\tbreak;\n\t\t}\n\n\tspin_unlock(&syscon_list_slock);\n\n\tif (!syscon)\n\t\tsyscon = of_syscon_register(np, check_res);\n\n\tif (IS_ERR(syscon))\n\t\treturn ERR_CAST(syscon);\n\n\treturn syscon->regmap;\n}\n\nstruct regmap *device_node_to_regmap(struct device_node *np)\n{\n\treturn device_node_get_regmap(np, false);\n}\nEXPORT_SYMBOL_GPL(device_node_to_regmap);\n\nstruct regmap *syscon_node_to_regmap(struct device_node *np)\n{\n\tif (!of_device_is_compatible(np, \"syscon\"))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn device_node_get_regmap(np, true);\n}\nEXPORT_SYMBOL_GPL(syscon_node_to_regmap);\n\nstruct regmap *syscon_regmap_lookup_by_compatible(const char *s)\n{\n\tstruct device_node *syscon_np;\n\tstruct regmap *regmap;\n\n\tsyscon_np = of_find_compatible_node(NULL, NULL, s);\n\tif (!syscon_np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tregmap = syscon_node_to_regmap(syscon_np);\n\tof_node_put(syscon_np);\n\n\treturn regmap;\n}\nEXPORT_SYMBOL_GPL(syscon_regmap_lookup_by_compatible);\n\nstruct regmap *syscon_regmap_lookup_by_phandle(struct device_node *np,\n\t\t\t\t\tconst char *property)\n{\n\tstruct device_node *syscon_np;\n\tstruct regmap *regmap;\n\n\tif (property)\n\t\tsyscon_np = of_parse_phandle(np, property, 0);\n\telse\n\t\tsyscon_np = np;\n\n\tif (!syscon_np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tregmap = syscon_node_to_regmap(syscon_np);\n\tof_node_put(syscon_np);\n\n\treturn regmap;\n}\nEXPORT_SYMBOL_GPL(syscon_regmap_lookup_by_phandle);\n\nstruct regmap *syscon_regmap_lookup_by_phandle_args(struct device_node *np,\n\t\t\t\t\tconst char *property,\n\t\t\t\t\tint arg_count,\n\t\t\t\t\tunsigned int *out_args)\n{\n\tstruct device_node *syscon_np;\n\tstruct of_phandle_args args;\n\tstruct regmap *regmap;\n\tunsigned int index;\n\tint rc;\n\n\trc = of_parse_phandle_with_fixed_args(np, property, arg_count,\n\t\t\t0, &args);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\tsyscon_np = args.np;\n\tif (!syscon_np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tregmap = syscon_node_to_regmap(syscon_np);\n\tfor (index = 0; index < arg_count; index++)\n\t\tout_args[index] = args.args[index];\n\tof_node_put(syscon_np);\n\n\treturn regmap;\n}\nEXPORT_SYMBOL_GPL(syscon_regmap_lookup_by_phandle_args);\n\n \nstruct regmap *syscon_regmap_lookup_by_phandle_optional(struct device_node *np,\n\t\t\t\t\tconst char *property)\n{\n\tstruct regmap *regmap;\n\n\tregmap = syscon_regmap_lookup_by_phandle(np, property);\n\tif (IS_ERR(regmap) && PTR_ERR(regmap) == -ENODEV)\n\t\treturn NULL;\n\n\treturn regmap;\n}\nEXPORT_SYMBOL_GPL(syscon_regmap_lookup_by_phandle_optional);\n\nstatic int syscon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct syscon_platform_data *pdata = dev_get_platdata(dev);\n\tstruct syscon *syscon;\n\tstruct regmap_config syscon_config = syscon_regmap_config;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\n\tsyscon = devm_kzalloc(dev, sizeof(*syscon), GFP_KERNEL);\n\tif (!syscon)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENOENT;\n\n\tbase = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tsyscon_config.max_register = resource_size(res) - 4;\n\tif (pdata)\n\t\tsyscon_config.name = pdata->label;\n\tsyscon->regmap = devm_regmap_init_mmio(dev, base, &syscon_config);\n\tif (IS_ERR(syscon->regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(syscon->regmap);\n\t}\n\n\tplatform_set_drvdata(pdev, syscon);\n\n\tdev_dbg(dev, \"regmap %pR registered\\n\", res);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id syscon_ids[] = {\n\t{ \"syscon\", },\n\t{ }\n};\n\nstatic struct platform_driver syscon_driver = {\n\t.driver = {\n\t\t.name = \"syscon\",\n\t},\n\t.probe\t\t= syscon_probe,\n\t.id_table\t= syscon_ids,\n};\n\nstatic int __init syscon_init(void)\n{\n\treturn platform_driver_register(&syscon_driver);\n}\npostcore_initcall(syscon_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}