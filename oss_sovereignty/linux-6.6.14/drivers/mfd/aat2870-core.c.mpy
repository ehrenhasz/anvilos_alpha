{
  "module_name": "aat2870-core.c",
  "hash_id": "155bf5e77fd66daa0ea18b79b803b13655f3872b556d312cf230801334cbeeef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/aat2870-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/aat2870.h>\n#include <linux/regulator/machine.h>\n\nstatic struct aat2870_register aat2870_regs[AAT2870_REG_NUM] = {\n\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x16 },\t \n\t{ 0, 1, 0x16 },\t \n\t{ 0, 1, 0x56 },\t \n\t{ 0, 1, 0x56 },\t \n\t{ 0, 1, 0x56 },\t \n\t{ 0, 1, 0x56 },\t \n\t{ 0, 1, 0x56 },\t \n\t{ 0, 1, 0x56 },\t \n\t{ 0, 1, 0x56 },\t \n\t{ 0, 1, 0x56 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x03 },\t \n\t{ 0, 1, 0x03 },\t \n\t{ 0, 1, 0x10 },\t \n\t{ 0, 1, 0x06 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 1, 0, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n\t{ 0, 1, 0x00 },\t \n};\n\nstatic struct mfd_cell aat2870_devs[] = {\n\t{\n\t\t.name = \"aat2870-backlight\",\n\t\t.id = AAT2870_ID_BL,\n\t\t.pdata_size = sizeof(struct aat2870_bl_platform_data),\n\t},\n\t{\n\t\t.name = \"aat2870-regulator\",\n\t\t.id = AAT2870_ID_LDOA,\n\t\t.pdata_size = sizeof(struct regulator_init_data),\n\t},\n\t{\n\t\t.name = \"aat2870-regulator\",\n\t\t.id = AAT2870_ID_LDOB,\n\t\t.pdata_size = sizeof(struct regulator_init_data),\n\t},\n\t{\n\t\t.name = \"aat2870-regulator\",\n\t\t.id = AAT2870_ID_LDOC,\n\t\t.pdata_size = sizeof(struct regulator_init_data),\n\t},\n\t{\n\t\t.name = \"aat2870-regulator\",\n\t\t.id = AAT2870_ID_LDOD,\n\t\t.pdata_size = sizeof(struct regulator_init_data),\n\t},\n};\n\nstatic int __aat2870_read(struct aat2870_data *aat2870, u8 addr, u8 *val)\n{\n\tint ret;\n\n\tif (addr >= AAT2870_REG_NUM) {\n\t\tdev_err(aat2870->dev, \"Invalid address, 0x%02x\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!aat2870->reg_cache[addr].readable) {\n\t\t*val = aat2870->reg_cache[addr].value;\n\t\tgoto out;\n\t}\n\n\tret = i2c_master_send(aat2870->client, &addr, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != 1)\n\t\treturn -EIO;\n\n\tret = i2c_master_recv(aat2870->client, val, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != 1)\n\t\treturn -EIO;\n\nout:\n\tdev_dbg(aat2870->dev, \"read: addr=0x%02x, val=0x%02x\\n\", addr, *val);\n\treturn 0;\n}\n\nstatic int __aat2870_write(struct aat2870_data *aat2870, u8 addr, u8 val)\n{\n\tu8 msg[2];\n\tint ret;\n\n\tif (addr >= AAT2870_REG_NUM) {\n\t\tdev_err(aat2870->dev, \"Invalid address, 0x%02x\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!aat2870->reg_cache[addr].writeable) {\n\t\tdev_err(aat2870->dev, \"Address 0x%02x is not writeable\\n\",\n\t\t\taddr);\n\t\treturn -EINVAL;\n\t}\n\n\tmsg[0] = addr;\n\tmsg[1] = val;\n\tret = i2c_master_send(aat2870->client, msg, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != 2)\n\t\treturn -EIO;\n\n\taat2870->reg_cache[addr].value = val;\n\n\tdev_dbg(aat2870->dev, \"write: addr=0x%02x, val=0x%02x\\n\", addr, val);\n\treturn 0;\n}\n\nstatic int aat2870_read(struct aat2870_data *aat2870, u8 addr, u8 *val)\n{\n\tint ret;\n\n\tmutex_lock(&aat2870->io_lock);\n\tret = __aat2870_read(aat2870, addr, val);\n\tmutex_unlock(&aat2870->io_lock);\n\n\treturn ret;\n}\n\nstatic int aat2870_write(struct aat2870_data *aat2870, u8 addr, u8 val)\n{\n\tint ret;\n\n\tmutex_lock(&aat2870->io_lock);\n\tret = __aat2870_write(aat2870, addr, val);\n\tmutex_unlock(&aat2870->io_lock);\n\n\treturn ret;\n}\n\nstatic int aat2870_update(struct aat2870_data *aat2870, u8 addr, u8 mask,\n\t\t\t  u8 val)\n{\n\tint change;\n\tu8 old_val, new_val;\n\tint ret;\n\n\tmutex_lock(&aat2870->io_lock);\n\n\tret = __aat2870_read(aat2870, addr, &old_val);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tnew_val = (old_val & ~mask) | (val & mask);\n\tchange = old_val != new_val;\n\tif (change)\n\t\tret = __aat2870_write(aat2870, addr, new_val);\n\nout_unlock:\n\tmutex_unlock(&aat2870->io_lock);\n\n\treturn ret;\n}\n\nstatic inline void aat2870_enable(struct aat2870_data *aat2870)\n{\n\tif (aat2870->en_pin >= 0)\n\t\tgpio_set_value(aat2870->en_pin, 1);\n\n\taat2870->is_enable = 1;\n}\n\nstatic inline void aat2870_disable(struct aat2870_data *aat2870)\n{\n\tif (aat2870->en_pin >= 0)\n\t\tgpio_set_value(aat2870->en_pin, 0);\n\n\taat2870->is_enable = 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic ssize_t aat2870_dump_reg(struct aat2870_data *aat2870, char *buf)\n{\n\tu8 addr, val;\n\tssize_t count = 0;\n\tint ret;\n\n\tcount += sprintf(buf, \"aat2870 registers\\n\");\n\tfor (addr = 0; addr < AAT2870_REG_NUM; addr++) {\n\t\tcount += snprintf(buf + count, PAGE_SIZE - count, \"0x%02x: \", addr);\n\t\tif (count >= PAGE_SIZE - 1)\n\t\t\tbreak;\n\n\t\tret = aat2870->read(aat2870, addr, &val);\n\t\tif (ret == 0)\n\t\t\tcount += snprintf(buf + count, PAGE_SIZE - count,\n\t\t\t\t\t  \"0x%02x\", val);\n\t\telse\n\t\t\tcount += snprintf(buf + count, PAGE_SIZE - count,\n\t\t\t\t\t  \"<read fail: %d>\", ret);\n\n\t\tif (count >= PAGE_SIZE - 1)\n\t\t\tbreak;\n\n\t\tcount += snprintf(buf + count, PAGE_SIZE - count, \"\\n\");\n\t\tif (count >= PAGE_SIZE - 1)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (count >= PAGE_SIZE)\n\t\tcount = PAGE_SIZE - 1;\n\n\treturn count;\n}\n\nstatic ssize_t aat2870_reg_read_file(struct file *file, char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct aat2870_data *aat2870 = file->private_data;\n\tchar *buf;\n\tssize_t ret;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = aat2870_dump_reg(aat2870, buf);\n\tif (ret >= 0)\n\t\tret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic ssize_t aat2870_reg_write_file(struct file *file,\n\t\t\t\t      const char __user *user_buf, size_t count,\n\t\t\t\t      loff_t *ppos)\n{\n\tstruct aat2870_data *aat2870 = file->private_data;\n\tchar buf[32];\n\tssize_t buf_size;\n\tchar *start = buf;\n\tunsigned long addr, val;\n\tint ret;\n\n\tbuf_size = min(count, (size_t)(sizeof(buf)-1));\n\tif (copy_from_user(buf, user_buf, buf_size)) {\n\t\tdev_err(aat2870->dev, \"Failed to copy from user\\n\");\n\t\treturn -EFAULT;\n\t}\n\tbuf[buf_size] = 0;\n\n\twhile (*start == ' ')\n\t\tstart++;\n\n\tret = kstrtoul(start, 16, &addr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (addr >= AAT2870_REG_NUM) {\n\t\tdev_err(aat2870->dev, \"Invalid address, 0x%lx\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (*start == ' ')\n\t\tstart++;\n\n\tret = kstrtoul(start, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = aat2870->write(aat2870, (u8)addr, (u8)val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn buf_size;\n}\n\nstatic const struct file_operations aat2870_reg_fops = {\n\t.open = simple_open,\n\t.read = aat2870_reg_read_file,\n\t.write = aat2870_reg_write_file,\n};\n\nstatic void aat2870_init_debugfs(struct aat2870_data *aat2870)\n{\n\taat2870->dentry_root = debugfs_create_dir(\"aat2870\", NULL);\n\n\tdebugfs_create_file(\"regs\", 0644, aat2870->dentry_root, aat2870,\n\t\t\t    &aat2870_reg_fops);\n}\n\n#else\nstatic inline void aat2870_init_debugfs(struct aat2870_data *aat2870)\n{\n}\n#endif  \n\nstatic int aat2870_i2c_probe(struct i2c_client *client)\n{\n\tstruct aat2870_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct aat2870_data *aat2870;\n\tint i, j;\n\tint ret = 0;\n\n\taat2870 = devm_kzalloc(&client->dev, sizeof(struct aat2870_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!aat2870)\n\t\treturn -ENOMEM;\n\n\taat2870->dev = &client->dev;\n\taat2870->client = client;\n\ti2c_set_clientdata(client, aat2870);\n\n\taat2870->reg_cache = aat2870_regs;\n\n\tif (pdata->en_pin < 0)\n\t\taat2870->en_pin = -1;\n\telse\n\t\taat2870->en_pin = pdata->en_pin;\n\n\taat2870->init = pdata->init;\n\taat2870->uninit = pdata->uninit;\n\taat2870->read = aat2870_read;\n\taat2870->write = aat2870_write;\n\taat2870->update = aat2870_update;\n\n\tmutex_init(&aat2870->io_lock);\n\n\tif (aat2870->init)\n\t\taat2870->init(aat2870);\n\n\tif (aat2870->en_pin >= 0) {\n\t\tret = devm_gpio_request_one(&client->dev, aat2870->en_pin,\n\t\t\t\t\tGPIOF_OUT_INIT_HIGH, \"aat2870-en\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to request GPIO %d\\n\", aat2870->en_pin);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\taat2870_enable(aat2870);\n\n\tfor (i = 0; i < pdata->num_subdevs; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(aat2870_devs); j++) {\n\t\t\tif ((pdata->subdevs[i].id == aat2870_devs[j].id) &&\n\t\t\t\t\t!strcmp(pdata->subdevs[i].name,\n\t\t\t\t\t\taat2870_devs[j].name)) {\n\t\t\t\taat2870_devs[j].platform_data =\n\t\t\t\t\tpdata->subdevs[i].platform_data;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = mfd_add_devices(aat2870->dev, 0, aat2870_devs,\n\t\t\t      ARRAY_SIZE(aat2870_devs), NULL, 0, NULL);\n\tif (ret != 0) {\n\t\tdev_err(aat2870->dev, \"Failed to add subdev: %d\\n\", ret);\n\t\tgoto out_disable;\n\t}\n\n\taat2870_init_debugfs(aat2870);\n\n\treturn 0;\n\nout_disable:\n\taat2870_disable(aat2870);\n\treturn ret;\n}\n\nstatic int aat2870_i2c_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct aat2870_data *aat2870 = i2c_get_clientdata(client);\n\n\taat2870_disable(aat2870);\n\n\treturn 0;\n}\n\nstatic int aat2870_i2c_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct aat2870_data *aat2870 = i2c_get_clientdata(client);\n\tstruct aat2870_register *reg = NULL;\n\tint i;\n\n\taat2870_enable(aat2870);\n\n\t \n\tfor (i = 0; i < AAT2870_REG_NUM; i++) {\n\t\treg = &aat2870->reg_cache[i];\n\t\tif (reg->writeable)\n\t\t\taat2870->write(aat2870, i, reg->value);\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(aat2870_pm_ops, aat2870_i2c_suspend,\n\t\t\t\taat2870_i2c_resume);\n\nstatic const struct i2c_device_id aat2870_i2c_id_table[] = {\n\t{ \"aat2870\", 0 },\n\t{ }\n};\n\nstatic struct i2c_driver aat2870_i2c_driver = {\n\t.driver = {\n\t\t.name\t\t\t= \"aat2870\",\n\t\t.pm\t\t\t= pm_sleep_ptr(&aat2870_pm_ops),\n\t\t.suppress_bind_attrs\t= true,\n\t},\n\t.probe\t\t= aat2870_i2c_probe,\n\t.id_table\t= aat2870_i2c_id_table,\n};\n\nstatic int __init aat2870_init(void)\n{\n\treturn i2c_add_driver(&aat2870_i2c_driver);\n}\nsubsys_initcall(aat2870_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}