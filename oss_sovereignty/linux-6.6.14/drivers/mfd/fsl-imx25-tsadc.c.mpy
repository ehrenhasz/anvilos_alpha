{
  "module_name": "fsl-imx25-tsadc.c",
  "hash_id": "126325665d75614cf992d1ada5d8f4b3e736395b4f0e6899894d32eb7f32a640",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/fsl-imx25-tsadc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdesc.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/mfd/imx25-tsadc.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\nstatic struct regmap_config mx25_tsadc_regmap_config = {\n\t.fast_io = true,\n\t.max_register = 8,\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic void mx25_tsadc_irq_handler(struct irq_desc *desc)\n{\n\tstruct mx25_tsadc *tsadc = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tu32 status;\n\n\tchained_irq_enter(chip, desc);\n\n\tregmap_read(tsadc->regs, MX25_TSC_TGSR, &status);\n\n\tif (status & MX25_TGSR_GCQ_INT)\n\t\tgeneric_handle_domain_irq(tsadc->domain, 1);\n\n\tif (status & MX25_TGSR_TCQ_INT)\n\t\tgeneric_handle_domain_irq(tsadc->domain, 0);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int mx25_tsadc_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct mx25_tsadc *tsadc = d->host_data;\n\n\tirq_set_chip_data(irq, tsadc);\n\tirq_set_chip_and_handler(irq, &dummy_irq_chip,\n\t\t\t\t handle_level_irq);\n\tirq_modify_status(irq, IRQ_NOREQUEST, IRQ_NOPROBE);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mx25_tsadc_domain_ops = {\n\t.map = mx25_tsadc_domain_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic int mx25_tsadc_setup_irq(struct platform_device *pdev,\n\t\t\t\tstruct mx25_tsadc *tsadc)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\ttsadc->domain = irq_domain_add_simple(np, 2, 0, &mx25_tsadc_domain_ops,\n\t\t\t\t\t      tsadc);\n\tif (!tsadc->domain) {\n\t\tdev_err(dev, \"Failed to add irq domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirq_set_chained_handler_and_data(irq, mx25_tsadc_irq_handler, tsadc);\n\n\treturn 0;\n}\n\nstatic int mx25_tsadc_unset_irq(struct platform_device *pdev)\n{\n\tstruct mx25_tsadc *tsadc = platform_get_drvdata(pdev);\n\tint irq = platform_get_irq(pdev, 0);\n\n\tif (irq >= 0) {\n\t\tirq_set_chained_handler_and_data(irq, NULL, NULL);\n\t\tirq_domain_remove(tsadc->domain);\n\t}\n\n\treturn 0;\n}\n\nstatic void mx25_tsadc_setup_clk(struct platform_device *pdev,\n\t\t\t\t struct mx25_tsadc *tsadc)\n{\n\tunsigned clk_div;\n\n\t \n\n\tdev_dbg(&pdev->dev, \"Found master clock at %lu Hz\\n\",\n\t\tclk_get_rate(tsadc->clk));\n\n\tclk_div = DIV_ROUND_UP(clk_get_rate(tsadc->clk), 1750000);\n\tdev_dbg(&pdev->dev, \"Setting up ADC clock divider to %u\\n\", clk_div);\n\n\t \n\tclk_div -= 2;\n\tclk_div /= 2;\n\n\t \n\tclk_div = max_t(unsigned, 4, clk_div);\n\n\tdev_dbg(&pdev->dev, \"Resulting ADC conversion clock at %lu Hz\\n\",\n\t\tclk_get_rate(tsadc->clk) / (2 * clk_div + 2));\n\n\tregmap_update_bits(tsadc->regs, MX25_TSC_TGCR,\n\t\t\t   MX25_TGCR_ADCCLKCFG(0x1f),\n\t\t\t   MX25_TGCR_ADCCLKCFG(clk_div));\n}\n\nstatic int mx25_tsadc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mx25_tsadc *tsadc;\n\tint ret;\n\tvoid __iomem *iomem;\n\n\ttsadc = devm_kzalloc(dev, sizeof(*tsadc), GFP_KERNEL);\n\tif (!tsadc)\n\t\treturn -ENOMEM;\n\n\tiomem = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(iomem))\n\t\treturn PTR_ERR(iomem);\n\n\ttsadc->regs = devm_regmap_init_mmio(dev, iomem,\n\t\t\t\t\t    &mx25_tsadc_regmap_config);\n\tif (IS_ERR(tsadc->regs)) {\n\t\tdev_err(dev, \"Failed to initialize regmap\\n\");\n\t\treturn PTR_ERR(tsadc->regs);\n\t}\n\n\ttsadc->clk = devm_clk_get(dev, \"ipg\");\n\tif (IS_ERR(tsadc->clk)) {\n\t\tdev_err(dev, \"Failed to get ipg clock\\n\");\n\t\treturn PTR_ERR(tsadc->clk);\n\t}\n\n\t \n\tmx25_tsadc_setup_clk(pdev, tsadc);\n\n\t \n\tregmap_update_bits(tsadc->regs, MX25_TSC_TGCR, MX25_TGCR_CLK_EN,\n\t\t\t   MX25_TGCR_CLK_EN);\n\tregmap_update_bits(tsadc->regs, MX25_TSC_TGCR, MX25_TGCR_TSC_RST,\n\t\t\t   MX25_TGCR_TSC_RST);\n\n\t \n\tregmap_update_bits(tsadc->regs, MX25_TSC_TGCR, MX25_TGCR_POWERMODE_MASK,\n\t\t\t   MX25_TGCR_POWERMODE_SAVE);\n\tregmap_update_bits(tsadc->regs, MX25_TSC_TGCR, MX25_TGCR_INTREFEN,\n\t\t\t   MX25_TGCR_INTREFEN);\n\n\tret = mx25_tsadc_setup_irq(pdev, tsadc);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, tsadc);\n\n\tret = devm_of_platform_populate(dev);\n\tif (ret)\n\t\tgoto err_irq;\n\n\treturn 0;\n\nerr_irq:\n\tmx25_tsadc_unset_irq(pdev);\n\n\treturn ret;\n}\n\nstatic int mx25_tsadc_remove(struct platform_device *pdev)\n{\n\tmx25_tsadc_unset_irq(pdev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mx25_tsadc_ids[] = {\n\t{ .compatible = \"fsl,imx25-tsadc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mx25_tsadc_ids);\n\nstatic struct platform_driver mx25_tsadc_driver = {\n\t.driver = {\n\t\t.name = \"mx25-tsadc\",\n\t\t.of_match_table = mx25_tsadc_ids,\n\t},\n\t.probe = mx25_tsadc_probe,\n\t.remove = mx25_tsadc_remove,\n};\nmodule_platform_driver(mx25_tsadc_driver);\n\nMODULE_DESCRIPTION(\"MFD for ADC/TSC for Freescale mx25\");\nMODULE_AUTHOR(\"Markus Pargmann <mpa@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:mx25-tsadc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}