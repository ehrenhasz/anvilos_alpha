{
  "module_name": "twl6030-irq.c",
  "hash_id": "2bd8be5a3f354b32d078f7861c0c342bc329d397f86b09bb9439f6788043e49e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/twl6030-irq.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kthread.h>\n#include <linux/mfd/twl.h>\n#include <linux/platform_device.h>\n#include <linux/suspend.h>\n#include <linux/of.h>\n#include <linux/irqdomain.h>\n#include <linux/of_device.h>\n\n#include \"twl-core.h\"\n\n \n#define TWL6030_NR_IRQS    20\n\nstatic int twl6030_interrupt_mapping[24] = {\n\tPWR_INTR_OFFSET,\t \n\tPWR_INTR_OFFSET,\t \n\tPWR_INTR_OFFSET,\t \n\tRTC_INTR_OFFSET,\t \n\tRTC_INTR_OFFSET,\t \n\tHOTDIE_INTR_OFFSET,\t \n\tSMPSLDO_INTR_OFFSET,\t \n\tSMPSLDO_INTR_OFFSET,\t \n\n\tSMPSLDO_INTR_OFFSET,\t \n\tBATDETECT_INTR_OFFSET,\t \n\tSIMDETECT_INTR_OFFSET,\t \n\tMMCDETECT_INTR_OFFSET,\t \n\tRSV_INTR_OFFSET,\t \n\tMADC_INTR_OFFSET,\t \n\tMADC_INTR_OFFSET,\t \n\tGASGAUGE_INTR_OFFSET,\t \n\n\tUSBOTG_INTR_OFFSET,\t \n\tUSBOTG_INTR_OFFSET,\t \n\tUSBOTG_INTR_OFFSET,\t \n\tUSB_PRES_INTR_OFFSET,\t \n\tCHARGER_INTR_OFFSET,\t \n\tCHARGERFAULT_INTR_OFFSET,\t \n\tCHARGERFAULT_INTR_OFFSET,\t \n\tRSV_INTR_OFFSET,\t \n};\n\nstatic int twl6032_interrupt_mapping[24] = {\n\tPWR_INTR_OFFSET,\t \n\tPWR_INTR_OFFSET,\t \n\tPWR_INTR_OFFSET,\t \n\tRTC_INTR_OFFSET,\t \n\tRTC_INTR_OFFSET,\t \n\tHOTDIE_INTR_OFFSET,\t \n\tSMPSLDO_INTR_OFFSET,\t \n\tPWR_INTR_OFFSET,\t \n\n\tPWR_INTR_OFFSET,\t \n\tBATDETECT_INTR_OFFSET,\t \n\tSIMDETECT_INTR_OFFSET,\t \n\tMMCDETECT_INTR_OFFSET,\t \n\tMADC_INTR_OFFSET,\t \n\tMADC_INTR_OFFSET,\t \n\tGASGAUGE_INTR_OFFSET,\t \n\tGASGAUGE_INTR_OFFSET,\t \n\n\tUSBOTG_INTR_OFFSET,\t \n\tUSBOTG_INTR_OFFSET,\t \n\tUSBOTG_INTR_OFFSET,\t \n\tUSB_PRES_INTR_OFFSET,\t \n\tCHARGER_INTR_OFFSET,\t \n\tCHARGERFAULT_INTR_OFFSET,\t \n\tCHARGERFAULT_INTR_OFFSET,\t \n\tRSV_INTR_OFFSET,\t \n};\n\n \n\nstruct twl6030_irq {\n\tunsigned int\t\tirq_base;\n\tint\t\t\ttwl_irq;\n\tbool\t\t\tirq_wake_enabled;\n\tatomic_t\t\twakeirqs;\n\tstruct notifier_block\tpm_nb;\n\tstruct irq_chip\t\tirq_chip;\n\tstruct irq_domain\t*irq_domain;\n\tconst int\t\t*irq_mapping_tbl;\n};\n\nstatic struct twl6030_irq *twl6030_irq;\n\nstatic int twl6030_irq_pm_notifier(struct notifier_block *notifier,\n\t\t\t\t   unsigned long pm_event, void *unused)\n{\n\tint chained_wakeups;\n\tstruct twl6030_irq *pdata = container_of(notifier, struct twl6030_irq,\n\t\t\t\t\t\t  pm_nb);\n\n\tswitch (pm_event) {\n\tcase PM_SUSPEND_PREPARE:\n\t\tchained_wakeups = atomic_read(&pdata->wakeirqs);\n\n\t\tif (chained_wakeups && !pdata->irq_wake_enabled) {\n\t\t\tif (enable_irq_wake(pdata->twl_irq))\n\t\t\t\tpr_err(\"twl6030 IRQ wake enable failed\\n\");\n\t\t\telse\n\t\t\t\tpdata->irq_wake_enabled = true;\n\t\t} else if (!chained_wakeups && pdata->irq_wake_enabled) {\n\t\t\tdisable_irq_wake(pdata->twl_irq);\n\t\t\tpdata->irq_wake_enabled = false;\n\t\t}\n\n\t\tdisable_irq(pdata->twl_irq);\n\t\tbreak;\n\n\tcase PM_POST_SUSPEND:\n\t\tenable_irq(pdata->twl_irq);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic irqreturn_t twl6030_irq_thread(int irq, void *data)\n{\n\tint i, ret;\n\tunion {\n\t\tu8 bytes[4];\n\t\t__le32 int_sts;\n\t} sts;\n\tu32 int_sts;  \n\tstruct twl6030_irq *pdata = data;\n\n\t \n\tret = twl_i2c_read(TWL_MODULE_PIH, sts.bytes, REG_INT_STS_A, 3);\n\tif (ret) {\n\t\tpr_warn(\"twl6030_irq: I2C error %d reading PIH ISR\\n\", ret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tsts.bytes[3] = 0;  \n\n\t \n\tif (sts.bytes[2] & 0x10)\n\t\tsts.bytes[2] |= 0x08;\n\n\tint_sts = le32_to_cpu(sts.int_sts);\n\tfor (i = 0; int_sts; int_sts >>= 1, i++)\n\t\tif (int_sts & 0x1) {\n\t\t\tint module_irq =\n\t\t\t\tirq_find_mapping(pdata->irq_domain,\n\t\t\t\t\t\t pdata->irq_mapping_tbl[i]);\n\t\t\tif (module_irq)\n\t\t\t\thandle_nested_irq(module_irq);\n\t\t\telse\n\t\t\t\tpr_err(\"twl6030_irq: Unmapped PIH ISR %u detected\\n\",\n\t\t\t\t       i);\n\t\t\tpr_debug(\"twl6030_irq: PIH ISR %u, virq%u\\n\",\n\t\t\t\t i, module_irq);\n\t\t}\n\n\t \n\tret = twl_i2c_write_u8(TWL_MODULE_PIH, 0x00, REG_INT_STS_A);\n\tif (ret)\n\t\tpr_warn(\"twl6030_irq: I2C error in clearing PIH ISR\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int twl6030_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct twl6030_irq *pdata = irq_data_get_irq_chip_data(d);\n\n\tif (on)\n\t\tatomic_inc(&pdata->wakeirqs);\n\telse\n\t\tatomic_dec(&pdata->wakeirqs);\n\n\treturn 0;\n}\n\nint twl6030_interrupt_unmask(u8 bit_mask, u8 offset)\n{\n\tint ret;\n\tu8 unmask_value;\n\n\tret = twl_i2c_read_u8(TWL_MODULE_PIH, &unmask_value,\n\t\t\tREG_INT_STS_A + offset);\n\tunmask_value &= (~(bit_mask));\n\tret |= twl_i2c_write_u8(TWL_MODULE_PIH, unmask_value,\n\t\t\tREG_INT_STS_A + offset);  \n\treturn ret;\n}\nEXPORT_SYMBOL(twl6030_interrupt_unmask);\n\nint twl6030_interrupt_mask(u8 bit_mask, u8 offset)\n{\n\tint ret;\n\tu8 mask_value;\n\n\tret = twl_i2c_read_u8(TWL_MODULE_PIH, &mask_value,\n\t\t\tREG_INT_STS_A + offset);\n\tmask_value |= (bit_mask);\n\tret |= twl_i2c_write_u8(TWL_MODULE_PIH, mask_value,\n\t\t\tREG_INT_STS_A + offset);  \n\treturn ret;\n}\nEXPORT_SYMBOL(twl6030_interrupt_mask);\n\nint twl6030_mmc_card_detect_config(void)\n{\n\tint ret;\n\tu8 reg_val = 0;\n\n\t \n\ttwl6030_interrupt_unmask(TWL6030_MMCDETECT_INT_MASK,\n\t\t\t\t\t\tREG_INT_MSK_LINE_B);\n\ttwl6030_interrupt_unmask(TWL6030_MMCDETECT_INT_MASK,\n\t\t\t\t\t\tREG_INT_MSK_STS_B);\n\t \n\tret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &reg_val, TWL6030_MMCCTRL);\n\tif (ret < 0) {\n\t\tpr_err(\"twl6030: Failed to read MMCCTRL, error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treg_val &= ~VMMC_AUTO_OFF;\n\treg_val |= SW_FC;\n\tret = twl_i2c_write_u8(TWL6030_MODULE_ID0, reg_val, TWL6030_MMCCTRL);\n\tif (ret < 0) {\n\t\tpr_err(\"twl6030: Failed to write MMCCTRL, error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &reg_val,\n\t\t\t\t\t\tTWL6030_CFG_INPUT_PUPD3);\n\tif (ret < 0) {\n\t\tpr_err(\"twl6030: Failed to read CFG_INPUT_PUPD3, error %d\\n\",\n\t\t\t\t\t\t\t\t\tret);\n\t\treturn ret;\n\t}\n\treg_val &= ~(MMC_PU | MMC_PD);\n\tret = twl_i2c_write_u8(TWL6030_MODULE_ID0, reg_val,\n\t\t\t\t\t\tTWL6030_CFG_INPUT_PUPD3);\n\tif (ret < 0) {\n\t\tpr_err(\"twl6030: Failed to write CFG_INPUT_PUPD3, error %d\\n\",\n\t\t\t\t\t\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn irq_find_mapping(twl6030_irq->irq_domain,\n\t\t\t\t MMCDETECT_INTR_OFFSET);\n}\nEXPORT_SYMBOL(twl6030_mmc_card_detect_config);\n\nint twl6030_mmc_card_detect(struct device *dev, int slot)\n{\n\tint ret = -EIO;\n\tu8 read_reg = 0;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tif (pdev->id) {\n\t\t \n\t\tpr_err(\"Unknown MMC controller %d in %s\\n\", pdev->id, __func__);\n\t\treturn ret;\n\t}\n\t \n\tret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &read_reg,\n\t\t\t\t\t\tTWL6030_MMCCTRL);\n\tif (ret >= 0)\n\t\tret = read_reg & STS_MMC;\n\treturn ret;\n}\nEXPORT_SYMBOL(twl6030_mmc_card_detect);\n\nstatic int twl6030_irq_map(struct irq_domain *d, unsigned int virq,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct twl6030_irq *pdata = d->host_data;\n\n\tirq_set_chip_data(virq, pdata);\n\tirq_set_chip_and_handler(virq,  &pdata->irq_chip, handle_simple_irq);\n\tirq_set_nested_thread(virq, true);\n\tirq_set_parent(virq, pdata->twl_irq);\n\tirq_set_noprobe(virq);\n\n\treturn 0;\n}\n\nstatic void twl6030_irq_unmap(struct irq_domain *d, unsigned int virq)\n{\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tirq_set_chip_data(virq, NULL);\n}\n\nstatic const struct irq_domain_ops twl6030_irq_domain_ops = {\n\t.map\t= twl6030_irq_map,\n\t.unmap\t= twl6030_irq_unmap,\n\t.xlate\t= irq_domain_xlate_onetwocell,\n};\n\nstatic const struct of_device_id twl6030_of_match[] __maybe_unused = {\n\t{.compatible = \"ti,twl6030\", &twl6030_interrupt_mapping},\n\t{.compatible = \"ti,twl6032\", &twl6032_interrupt_mapping},\n\t{ },\n};\n\nint twl6030_init_irq(struct device *dev, int irq_num)\n{\n\tstruct\t\t\tdevice_node *node = dev->of_node;\n\tint\t\t\tnr_irqs;\n\tint\t\t\tstatus;\n\tu8\t\t\tmask[3];\n\tconst struct of_device_id *of_id;\n\n\tof_id = of_match_device(twl6030_of_match, dev);\n\tif (!of_id || !of_id->data) {\n\t\tdev_err(dev, \"Unknown TWL device model\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnr_irqs = TWL6030_NR_IRQS;\n\n\ttwl6030_irq = devm_kzalloc(dev, sizeof(*twl6030_irq), GFP_KERNEL);\n\tif (!twl6030_irq)\n\t\treturn -ENOMEM;\n\n\tmask[0] = 0xFF;\n\tmask[1] = 0xFF;\n\tmask[2] = 0xFF;\n\n\t \n\tstatus = twl_i2c_write(TWL_MODULE_PIH, &mask[0], REG_INT_MSK_LINE_A, 3);\n\t \n\tstatus |= twl_i2c_write(TWL_MODULE_PIH, &mask[0], REG_INT_MSK_STS_A, 3);\n\t \n\tstatus |= twl_i2c_write(TWL_MODULE_PIH, &mask[0], REG_INT_STS_A, 3);\n\n\tif (status < 0) {\n\t\tdev_err(dev, \"I2C err writing TWL_MODULE_PIH: %d\\n\", status);\n\t\treturn status;\n\t}\n\n\t \n\ttwl6030_irq->irq_chip = dummy_irq_chip;\n\ttwl6030_irq->irq_chip.name = \"twl6030\";\n\ttwl6030_irq->irq_chip.irq_set_type = NULL;\n\ttwl6030_irq->irq_chip.irq_set_wake = twl6030_irq_set_wake;\n\n\ttwl6030_irq->pm_nb.notifier_call = twl6030_irq_pm_notifier;\n\tatomic_set(&twl6030_irq->wakeirqs, 0);\n\ttwl6030_irq->irq_mapping_tbl = of_id->data;\n\n\ttwl6030_irq->irq_domain =\n\t\tirq_domain_add_linear(node, nr_irqs,\n\t\t\t\t      &twl6030_irq_domain_ops, twl6030_irq);\n\tif (!twl6030_irq->irq_domain) {\n\t\tdev_err(dev, \"Can't add irq_domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_info(dev, \"PIH (irq %d) nested IRQs\\n\", irq_num);\n\n\t \n\tstatus = request_threaded_irq(irq_num, NULL, twl6030_irq_thread,\n\t\t\t\t      IRQF_ONESHOT, \"TWL6030-PIH\", twl6030_irq);\n\tif (status < 0) {\n\t\tdev_err(dev, \"could not claim irq %d: %d\\n\", irq_num, status);\n\t\tgoto fail_irq;\n\t}\n\n\ttwl6030_irq->twl_irq = irq_num;\n\tregister_pm_notifier(&twl6030_irq->pm_nb);\n\treturn 0;\n\nfail_irq:\n\tirq_domain_remove(twl6030_irq->irq_domain);\n\treturn status;\n}\n\nvoid twl6030_exit_irq(void)\n{\n\tif (twl6030_irq && twl6030_irq->twl_irq) {\n\t\tunregister_pm_notifier(&twl6030_irq->pm_nb);\n\t\tfree_irq(twl6030_irq->twl_irq, NULL);\n\t\t \n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}