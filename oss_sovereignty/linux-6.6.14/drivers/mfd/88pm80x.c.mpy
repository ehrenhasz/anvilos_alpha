{
  "module_name": "88pm80x.c",
  "hash_id": "af1bbd4a72f7c0f342640e0e978acad8e20a127bc2fc621d0e1c49520389c6c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/88pm80x.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/mfd/88pm80x.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n\n \n#define PM80X_CHIP_ID\t\t\t(0x00)\n#define PM80X_CHIP_ID_NUM(x)\t\t(((x) >> 5) & 0x7)\n#define PM80X_CHIP_ID_REVISION(x)\t((x) & 0x1F)\n\nstruct pm80x_chip_mapping {\n\tunsigned int\tid;\n\tint\t\ttype;\n};\n\nstatic struct pm80x_chip_mapping chip_mapping[] = {\n\t \n\t{0x3,\tCHIP_PM800},\n\t \n\t{0x0,\tCHIP_PM805},\n\t \n\t{0x4,\tCHIP_PM860},\n};\n\n \nstatic struct pm80x_chip *g_pm80x_chip;\n\nconst struct regmap_config pm80x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\nEXPORT_SYMBOL_GPL(pm80x_regmap_config);\n\n\nint pm80x_init(struct i2c_client *client)\n{\n\tstruct pm80x_chip *chip;\n\tstruct regmap *map;\n\tunsigned int val;\n\tint i, ret = 0;\n\n\tchip =\n\t    devm_kzalloc(&client->dev, sizeof(struct pm80x_chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tmap = devm_regmap_init_i2c(client, &pm80x_regmap_config);\n\tif (IS_ERR(map)) {\n\t\tret = PTR_ERR(map);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tchip->client = client;\n\tchip->regmap = map;\n\n\tchip->irq = client->irq;\n\n\tchip->dev = &client->dev;\n\ti2c_set_clientdata(chip->client, chip);\n\n\tret = regmap_read(chip->regmap, PM80X_CHIP_ID, &val);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to read CHIP ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(chip_mapping); i++) {\n\t\tif (chip_mapping[i].id == PM80X_CHIP_ID_NUM(val)) {\n\t\t\tchip->type = chip_mapping[i].type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(chip_mapping)) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Failed to detect Marvell 88PM800:ChipID[0x%x]\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_init_wakeup(&client->dev, 1);\n\n\t \n\tif (!g_pm80x_chip)\n\t\tg_pm80x_chip = chip;\n\telse {\n\t\tchip->companion = g_pm80x_chip->client;\n\t\tg_pm80x_chip->companion = chip->client;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pm80x_init);\n\nint pm80x_deinit(void)\n{\n\t \n\tif (g_pm80x_chip->companion)\n\t\tg_pm80x_chip->companion = NULL;\n\telse\n\t\tg_pm80x_chip = NULL;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pm80x_deinit);\n\nstatic int pm80x_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pm80x_chip *chip = i2c_get_clientdata(client);\n\n\tif (chip && chip->wu_flag)\n\t\tif (device_may_wakeup(chip->dev))\n\t\t\tenable_irq_wake(chip->irq);\n\n\treturn 0;\n}\n\nstatic int pm80x_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pm80x_chip *chip = i2c_get_clientdata(client);\n\n\tif (chip && chip->wu_flag)\n\t\tif (device_may_wakeup(chip->dev))\n\t\t\tdisable_irq_wake(chip->irq);\n\n\treturn 0;\n}\n\nEXPORT_GPL_SIMPLE_DEV_PM_OPS(pm80x_pm_ops, pm80x_suspend, pm80x_resume);\n\nMODULE_DESCRIPTION(\"I2C Driver for Marvell 88PM80x\");\nMODULE_AUTHOR(\"Qiao Zhou <zhouqiao@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}