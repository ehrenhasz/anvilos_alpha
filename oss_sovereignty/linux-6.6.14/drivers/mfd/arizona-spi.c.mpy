{
  "module_name": "arizona-spi.c",
  "hash_id": "12100807e4c747cd870e0fd7f6ca111159534d7938f95d2c35e3511f003be198",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/arizona-spi.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/of.h>\n#include <uapi/linux/input-event-codes.h>\n\n#include <linux/mfd/arizona/core.h>\n\n#include \"arizona.h\"\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_gpio_params reset_gpios = { 1, 0, false };\nstatic const struct acpi_gpio_params ldoena_gpios = { 2, 0, false };\n\nstatic const struct acpi_gpio_mapping arizona_acpi_gpios[] = {\n\t{ \"reset-gpios\", &reset_gpios, 1, },\n\t{ \"wlf,ldoena-gpios\", &ldoena_gpios, 1 },\n\t{ }\n};\n\n \nstatic const struct gpiod_lookup arizona_soc_gpios[] = {\n\t{ \"arizona\", 2, \"wlf,spkvdd-ena\", 0, GPIO_ACTIVE_HIGH },\n\t{ \"arizona\", 4, \"wlf,micd-pol\", 0, GPIO_ACTIVE_LOW },\n};\n\nstatic void arizona_spi_acpi_remove_lookup(void *lookup)\n{\n\tgpiod_remove_lookup_table(lookup);\n}\n\n \nstatic int arizona_spi_acpi_windows_probe(struct arizona *arizona)\n{\n\tstruct gpiod_lookup_table *lookup;\n\tacpi_status status;\n\tint ret;\n\n\t \n\tdevm_acpi_dev_add_driver_gpios(arizona->dev, arizona_acpi_gpios);\n\n\t \n\tlookup = devm_kzalloc(arizona->dev,\n\t\t\t      struct_size(lookup, table, ARRAY_SIZE(arizona_soc_gpios) + 1),\n\t\t\t      GFP_KERNEL);\n\tif (!lookup)\n\t\treturn -ENOMEM;\n\n\tlookup->dev_id = dev_name(arizona->dev);\n\tmemcpy(lookup->table, arizona_soc_gpios, sizeof(arizona_soc_gpios));\n\n\tgpiod_add_lookup_table(lookup);\n\tret = devm_add_action_or_reset(arizona->dev, arizona_spi_acpi_remove_lookup, lookup);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstatus = acpi_evaluate_object(ACPI_HANDLE(arizona->dev), \"CLKE\", NULL, NULL);\n\tif (ACPI_FAILURE(status))\n\t\tdev_warn(arizona->dev, \"Failed to enable 32KHz clk ACPI error %d\\n\", status);\n\n\treturn 0;\n}\n\n \nstatic int arizona_spi_acpi_android_probe(struct arizona *arizona)\n{\n\tint ret;\n\n\t \n\tarizona->pdata.reset = devm_gpiod_get(arizona->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(arizona->pdata.reset)) {\n\t\tret = PTR_ERR(arizona->pdata.reset);\n\t\tif (ret == -ENOENT) {\n\t\t\tdev_info_once(arizona->dev,\n\t\t\t\t      \"Deferring probe till GPIO lookup is registered\\n\");\n\t\t\tret = -EPROBE_DEFER;\n\t\t}\n\t\treturn dev_err_probe(arizona->dev, ret, \"getting reset GPIO\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct arizona_micd_range arizona_micd_aosp_ranges[] = {\n\t{ .max =  11, .key = KEY_PLAYPAUSE },\n\t{ .max = 186, .key = KEY_VOICECOMMAND },\n\t{ .max = 348, .key = KEY_VOLUMEUP },\n\t{ .max = 752, .key = KEY_VOLUMEDOWN },\n};\n\nstatic int arizona_spi_acpi_probe(struct arizona *arizona)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(arizona->dev);\n\tint ret;\n\n\tif (acpi_dev_hid_uid_match(adev, \"10WM5102\", NULL))\n\t\tret = arizona_spi_acpi_android_probe(arizona);\n\telse\n\t\tret = arizona_spi_acpi_windows_probe(arizona);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tarizona->pdata.irq_flags = IRQF_TRIGGER_LOW;\n\n\t \n\tarizona->pdata.micd_detect_debounce = 200;\n\n\t \n\tarizona->pdata.micd_ranges = arizona_micd_aosp_ranges;\n\tarizona->pdata.num_micd_ranges = ARRAY_SIZE(arizona_micd_aosp_ranges);\n\n\t \n\tarizona->pdata.hpdet_channel = ARIZONA_ACCDET_MODE_HPL;\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id arizona_acpi_match[] = {\n\t{\n\t\t.id = \"WM510204\",\n\t\t.driver_data = WM5102,\n\t},\n\t{\n\t\t.id = \"WM510205\",\n\t\t.driver_data = WM5102,\n\t},\n\t{\n\t\t.id = \"10WM5102\",\n\t\t.driver_data = WM5102,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, arizona_acpi_match);\n#else\nstatic int arizona_spi_acpi_probe(struct arizona *arizona)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic int arizona_spi_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tconst void *match_data;\n\tstruct arizona *arizona;\n\tconst struct regmap_config *regmap_config = NULL;\n\tunsigned long type = 0;\n\tint ret;\n\n\tmatch_data = device_get_match_data(&spi->dev);\n\tif (match_data)\n\t\ttype = (unsigned long)match_data;\n\telse if (id)\n\t\ttype = id->driver_data;\n\n\tswitch (type) {\n\tcase WM5102:\n\t\tif (IS_ENABLED(CONFIG_MFD_WM5102))\n\t\t\tregmap_config = &wm5102_spi_regmap;\n\t\tbreak;\n\tcase WM5110:\n\tcase WM8280:\n\t\tif (IS_ENABLED(CONFIG_MFD_WM5110))\n\t\t\tregmap_config = &wm5110_spi_regmap;\n\t\tbreak;\n\tcase WM1831:\n\tcase CS47L24:\n\t\tif (IS_ENABLED(CONFIG_MFD_CS47L24))\n\t\t\tregmap_config = &cs47l24_spi_regmap;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&spi->dev, \"Unknown device type %ld\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!regmap_config) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"No kernel support for device type %ld\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tarizona = devm_kzalloc(&spi->dev, sizeof(*arizona), GFP_KERNEL);\n\tif (arizona == NULL)\n\t\treturn -ENOMEM;\n\n\tarizona->regmap = devm_regmap_init_spi(spi, regmap_config);\n\tif (IS_ERR(arizona->regmap)) {\n\t\tret = PTR_ERR(arizona->regmap);\n\t\tdev_err(&spi->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tarizona->type = type;\n\tarizona->dev = &spi->dev;\n\tarizona->irq = spi->irq;\n\n\tif (has_acpi_companion(&spi->dev)) {\n\t\tret = arizona_spi_acpi_probe(arizona);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn arizona_dev_init(arizona);\n}\n\nstatic void arizona_spi_remove(struct spi_device *spi)\n{\n\tstruct arizona *arizona = spi_get_drvdata(spi);\n\n\tarizona_dev_exit(arizona);\n}\n\nstatic const struct spi_device_id arizona_spi_ids[] = {\n\t{ \"wm5102\", WM5102 },\n\t{ \"wm5110\", WM5110 },\n\t{ \"wm8280\", WM8280 },\n\t{ \"wm1831\", WM1831 },\n\t{ \"cs47l24\", CS47L24 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, arizona_spi_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id arizona_spi_of_match[] = {\n\t{ .compatible = \"wlf,wm5102\", .data = (void *)WM5102 },\n\t{ .compatible = \"wlf,wm5110\", .data = (void *)WM5110 },\n\t{ .compatible = \"wlf,wm8280\", .data = (void *)WM8280 },\n\t{ .compatible = \"wlf,wm1831\", .data = (void *)WM1831 },\n\t{ .compatible = \"cirrus,cs47l24\", .data = (void *)CS47L24 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, arizona_spi_of_match);\n#endif\n\nstatic struct spi_driver arizona_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"arizona\",\n\t\t.pm\t= pm_ptr(&arizona_pm_ops),\n\t\t.of_match_table\t= of_match_ptr(arizona_spi_of_match),\n\t\t.acpi_match_table = ACPI_PTR(arizona_acpi_match),\n\t},\n\t.probe\t\t= arizona_spi_probe,\n\t.remove\t\t= arizona_spi_remove,\n\t.id_table\t= arizona_spi_ids,\n};\n\nmodule_spi_driver(arizona_spi_driver);\n\nMODULE_SOFTDEP(\"pre: arizona_ldo1\");\nMODULE_DESCRIPTION(\"Arizona SPI bus interface\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}