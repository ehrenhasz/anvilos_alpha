{
  "module_name": "tps65910.c",
  "hash_id": "e17da47ab4c795663bc2d0140b5a4cd5db57d65a0971ed27b36201f2c4d29c34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tps65910.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/core.h>\n#include <linux/regmap.h>\n#include <linux/mfd/tps65910.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n\nstatic const struct resource rtc_resources[] = {\n\t{\n\t\t.start  = TPS65910_IRQ_RTC_ALARM,\n\t\t.end    = TPS65910_IRQ_RTC_ALARM,\n\t\t.flags  = IORESOURCE_IRQ,\n\t}\n};\n\nstatic const struct mfd_cell tps65910s[] = {\n\t{\n\t\t.name = \"tps65910-gpio\",\n\t},\n\t{\n\t\t.name = \"tps65910-pmic\",\n\t},\n\t{\n\t\t.name = \"tps65910-rtc\",\n\t\t.num_resources = ARRAY_SIZE(rtc_resources),\n\t\t.resources = &rtc_resources[0],\n\t},\n\t{\n\t\t.name = \"tps65910-power\",\n\t},\n};\n\n\nstatic const struct regmap_irq tps65911_irqs[] = {\n\t \n\t[TPS65911_IRQ_PWRHOLD_F] = {\n\t\t.mask = INT_MSK_PWRHOLD_F_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65911_IRQ_VBAT_VMHI] = {\n\t\t.mask = INT_MSK_VMBHI_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65911_IRQ_PWRON] = {\n\t\t.mask = INT_MSK_PWRON_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65911_IRQ_PWRON_LP] = {\n\t\t.mask = INT_MSK_PWRON_LP_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65911_IRQ_PWRHOLD_R] = {\n\t\t.mask = INT_MSK_PWRHOLD_R_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65911_IRQ_HOTDIE] = {\n\t\t.mask = INT_MSK_HOTDIE_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65911_IRQ_RTC_ALARM] = {\n\t\t.mask = INT_MSK_RTC_ALARM_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65911_IRQ_RTC_PERIOD] = {\n\t\t.mask = INT_MSK_RTC_PERIOD_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\n\t \n\t[TPS65911_IRQ_GPIO0_R] = {\n\t\t.mask = INT_MSK2_GPIO0_R_IT_MSK_MASK,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65911_IRQ_GPIO0_F] = {\n\t\t.mask = INT_MSK2_GPIO0_F_IT_MSK_MASK,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65911_IRQ_GPIO1_R] = {\n\t\t.mask = INT_MSK2_GPIO1_R_IT_MSK_MASK,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65911_IRQ_GPIO1_F] = {\n\t\t.mask = INT_MSK2_GPIO1_F_IT_MSK_MASK,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65911_IRQ_GPIO2_R] = {\n\t\t.mask = INT_MSK2_GPIO2_R_IT_MSK_MASK,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65911_IRQ_GPIO2_F] = {\n\t\t.mask = INT_MSK2_GPIO2_F_IT_MSK_MASK,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65911_IRQ_GPIO3_R] = {\n\t\t.mask = INT_MSK2_GPIO3_R_IT_MSK_MASK,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65911_IRQ_GPIO3_F] = {\n\t\t.mask = INT_MSK2_GPIO3_F_IT_MSK_MASK,\n\t\t.reg_offset = 1,\n\t},\n\n\t \n\t[TPS65911_IRQ_GPIO4_R] = {\n\t\t.mask = INT_MSK3_GPIO4_R_IT_MSK_MASK,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65911_IRQ_GPIO4_F] = {\n\t\t.mask = INT_MSK3_GPIO4_F_IT_MSK_MASK,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65911_IRQ_GPIO5_R] = {\n\t\t.mask = INT_MSK3_GPIO5_R_IT_MSK_MASK,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65911_IRQ_GPIO5_F] = {\n\t\t.mask = INT_MSK3_GPIO5_F_IT_MSK_MASK,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65911_IRQ_WTCHDG] = {\n\t\t.mask = INT_MSK3_WTCHDG_IT_MSK_MASK,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65911_IRQ_VMBCH2_H] = {\n\t\t.mask = INT_MSK3_VMBCH2_H_IT_MSK_MASK,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65911_IRQ_VMBCH2_L] = {\n\t\t.mask = INT_MSK3_VMBCH2_L_IT_MSK_MASK,\n\t\t.reg_offset = 2,\n\t},\n\t[TPS65911_IRQ_PWRDN] = {\n\t\t.mask = INT_MSK3_PWRDN_IT_MSK_MASK,\n\t\t.reg_offset = 2,\n\t},\n};\n\nstatic const struct regmap_irq tps65910_irqs[] = {\n\t \n\t[TPS65910_IRQ_VBAT_VMBDCH] = {\n\t\t.mask = TPS65910_INT_MSK_VMBDCH_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65910_IRQ_VBAT_VMHI] = {\n\t\t.mask = TPS65910_INT_MSK_VMBHI_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65910_IRQ_PWRON] = {\n\t\t.mask = TPS65910_INT_MSK_PWRON_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65910_IRQ_PWRON_LP] = {\n\t\t.mask = TPS65910_INT_MSK_PWRON_LP_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65910_IRQ_PWRHOLD] = {\n\t\t.mask = TPS65910_INT_MSK_PWRHOLD_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65910_IRQ_HOTDIE] = {\n\t\t.mask = TPS65910_INT_MSK_HOTDIE_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65910_IRQ_RTC_ALARM] = {\n\t\t.mask = TPS65910_INT_MSK_RTC_ALARM_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\t[TPS65910_IRQ_RTC_PERIOD] = {\n\t\t.mask = TPS65910_INT_MSK_RTC_PERIOD_IT_MSK_MASK,\n\t\t.reg_offset = 0,\n\t},\n\n\t \n\t[TPS65910_IRQ_GPIO_R] = {\n\t\t.mask = TPS65910_INT_MSK2_GPIO0_F_IT_MSK_MASK,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65910_IRQ_GPIO_F] = {\n\t\t.mask = TPS65910_INT_MSK2_GPIO0_R_IT_MSK_MASK,\n\t\t.reg_offset = 1,\n\t},\n};\n\nstatic struct regmap_irq_chip tps65911_irq_chip = {\n\t.name = \"tps65910\",\n\t.irqs = tps65911_irqs,\n\t.num_irqs = ARRAY_SIZE(tps65911_irqs),\n\t.num_regs = 3,\n\t.irq_reg_stride = 2,\n\t.status_base = TPS65910_INT_STS,\n\t.mask_base = TPS65910_INT_MSK,\n\t.ack_base = TPS65910_INT_STS,\n};\n\nstatic struct regmap_irq_chip tps65910_irq_chip = {\n\t.name = \"tps65910\",\n\t.irqs = tps65910_irqs,\n\t.num_irqs = ARRAY_SIZE(tps65910_irqs),\n\t.num_regs = 2,\n\t.irq_reg_stride = 2,\n\t.status_base = TPS65910_INT_STS,\n\t.mask_base = TPS65910_INT_MSK,\n\t.ack_base = TPS65910_INT_STS,\n};\n\nstatic int tps65910_irq_init(struct tps65910 *tps65910, int irq,\n\t\t    struct tps65910_platform_data *pdata)\n{\n\tint ret;\n\tstatic struct regmap_irq_chip *tps6591x_irqs_chip;\n\n\tif (!irq) {\n\t\tdev_warn(tps65910->dev, \"No interrupt support, no core IRQ\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdata) {\n\t\tdev_warn(tps65910->dev, \"No interrupt support, no pdata\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (tps65910_chip_id(tps65910)) {\n\tcase TPS65910:\n\t\ttps6591x_irqs_chip = &tps65910_irq_chip;\n\t\tbreak;\n\tcase TPS65911:\n\t\ttps6591x_irqs_chip = &tps65911_irq_chip;\n\t\tbreak;\n\t}\n\n\ttps65910->chip_irq = irq;\n\tret = devm_regmap_add_irq_chip(tps65910->dev, tps65910->regmap,\n\t\t\t\t       tps65910->chip_irq,\n\t\t\t\t       IRQF_ONESHOT, pdata->irq_base,\n\t\t\t\t       tps6591x_irqs_chip, &tps65910->irq_data);\n\tif (ret < 0) {\n\t\tdev_warn(tps65910->dev, \"Failed to add irq_chip %d\\n\", ret);\n\t\ttps65910->chip_irq = 0;\n\t}\n\treturn ret;\n}\n\nstatic bool is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tstruct tps65910 *tps65910 = dev_get_drvdata(dev);\n\n\t \n\tif ((reg >= TPS65910_VIO) && (reg <= TPS65910_VDAC)) {\n\t\t \n\t\tif (tps65910_chip_id(tps65910) == TPS65910)\n\t\t\tif ((reg == TPS65911_VDDCTRL_OP) ||\n\t\t\t\t(reg == TPS65911_VDDCTRL_SR))\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const struct regmap_config tps65910_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_reg = is_volatile_reg,\n\t.max_register = TPS65910_MAX_REGISTER - 1,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int tps65910_ck32k_init(struct tps65910 *tps65910,\n\t\t\t\t\tstruct tps65910_board *pmic_pdata)\n{\n\tint ret;\n\n\tif (!pmic_pdata->en_ck32k_xtal)\n\t\treturn 0;\n\n\tret = regmap_clear_bits(tps65910->regmap, TPS65910_DEVCTRL,\n\t\t\t\tDEVCTRL_CK32K_CTRL_MASK);\n\tif (ret < 0) {\n\t\tdev_err(tps65910->dev, \"clear ck32k_ctrl failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tps65910_sleepinit(struct tps65910 *tps65910,\n\t\tstruct tps65910_board *pmic_pdata)\n{\n\tstruct device *dev;\n\tint ret;\n\n\tif (!pmic_pdata->en_dev_slp)\n\t\treturn 0;\n\n\tdev = tps65910->dev;\n\n\t \n\tret = regmap_set_bits(tps65910->regmap, TPS65910_DEVCTRL,\n\t\t\t      DEVCTRL_DEV_SLP_MASK);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"set dev_slp failed: %d\\n\", ret);\n\t\tgoto err_sleep_init;\n\t}\n\n\tif (pmic_pdata->slp_keepon.therm_keepon) {\n\t\tret = regmap_set_bits(tps65910->regmap,\n\t\t\t\t      TPS65910_SLEEP_KEEP_RES_ON,\n\t\t\t\t      SLEEP_KEEP_RES_ON_THERM_KEEPON_MASK);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"set therm_keepon failed: %d\\n\", ret);\n\t\t\tgoto disable_dev_slp;\n\t\t}\n\t}\n\n\tif (pmic_pdata->slp_keepon.clkout32k_keepon) {\n\t\tret = regmap_set_bits(tps65910->regmap,\n\t\t\t\t      TPS65910_SLEEP_KEEP_RES_ON,\n\t\t\t\t      SLEEP_KEEP_RES_ON_CLKOUT32K_KEEPON_MASK);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"set clkout32k_keepon failed: %d\\n\", ret);\n\t\t\tgoto disable_dev_slp;\n\t\t}\n\t}\n\n\tif (pmic_pdata->slp_keepon.i2chs_keepon) {\n\t\tret = regmap_set_bits(tps65910->regmap,\n\t\t\t\t      TPS65910_SLEEP_KEEP_RES_ON,\n\t\t\t\t      SLEEP_KEEP_RES_ON_I2CHS_KEEPON_MASK);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"set i2chs_keepon failed: %d\\n\", ret);\n\t\t\tgoto disable_dev_slp;\n\t\t}\n\t}\n\n\treturn 0;\n\ndisable_dev_slp:\n\tregmap_clear_bits(tps65910->regmap, TPS65910_DEVCTRL,\n\t\t\t  DEVCTRL_DEV_SLP_MASK);\n\nerr_sleep_init:\n\treturn ret;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tps65910_of_match[] = {\n\t{ .compatible = \"ti,tps65910\", .data = (void *)TPS65910},\n\t{ .compatible = \"ti,tps65911\", .data = (void *)TPS65911},\n\t{ },\n};\n\nstatic struct tps65910_board *tps65910_parse_dt(struct i2c_client *client,\n\t\t\t\t\t\tunsigned long *chip_id)\n{\n\tstruct device_node *np = client->dev.of_node;\n\tstruct tps65910_board *board_info;\n\tunsigned int prop;\n\tconst struct of_device_id *match;\n\tint ret;\n\n\tmatch = of_match_device(tps65910_of_match, &client->dev);\n\tif (!match) {\n\t\tdev_err(&client->dev, \"Failed to find matching dt id\\n\");\n\t\treturn NULL;\n\t}\n\n\t*chip_id  = (unsigned long)match->data;\n\n\tboard_info = devm_kzalloc(&client->dev, sizeof(*board_info),\n\t\t\tGFP_KERNEL);\n\tif (!board_info)\n\t\treturn NULL;\n\n\tret = of_property_read_u32(np, \"ti,vmbch-threshold\", &prop);\n\tif (!ret)\n\t\tboard_info->vmbch_threshold = prop;\n\n\tret = of_property_read_u32(np, \"ti,vmbch2-threshold\", &prop);\n\tif (!ret)\n\t\tboard_info->vmbch2_threshold = prop;\n\n\tprop = of_property_read_bool(np, \"ti,en-ck32k-xtal\");\n\tboard_info->en_ck32k_xtal = prop;\n\n\tprop = of_property_read_bool(np, \"ti,sleep-enable\");\n\tboard_info->en_dev_slp = prop;\n\n\tprop = of_property_read_bool(np, \"ti,sleep-keep-therm\");\n\tboard_info->slp_keepon.therm_keepon = prop;\n\n\tprop = of_property_read_bool(np, \"ti,sleep-keep-ck32k\");\n\tboard_info->slp_keepon.clkout32k_keepon = prop;\n\n\tprop = of_property_read_bool(np, \"ti,sleep-keep-hsclk\");\n\tboard_info->slp_keepon.i2chs_keepon = prop;\n\n\tboard_info->irq = client->irq;\n\tboard_info->irq_base = -1;\n\tboard_info->pm_off = of_property_read_bool(np,\n\t\t\t\"ti,system-power-controller\");\n\n\treturn board_info;\n}\n#else\nstatic inline\nstruct tps65910_board *tps65910_parse_dt(struct i2c_client *client,\n\t\t\t\t\t unsigned long *chip_id)\n{\n\treturn NULL;\n}\n#endif\n\nstatic struct i2c_client *tps65910_i2c_client;\nstatic void tps65910_power_off(void)\n{\n\tstruct tps65910 *tps65910;\n\n\ttps65910 = dev_get_drvdata(&tps65910_i2c_client->dev);\n\n\tregmap_update_bits(tps65910->regmap, TPS65910_DEVCTRL,\n\t\t\t   DEVCTRL_DEV_OFF_MASK | DEVCTRL_DEV_ON_MASK,\n\t\t\t   DEVCTRL_DEV_OFF_MASK);\n}\n\nstatic int tps65910_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tstruct tps65910 *tps65910;\n\tstruct tps65910_board *pmic_plat_data;\n\tstruct tps65910_board *of_pmic_plat_data = NULL;\n\tstruct tps65910_platform_data *init_data;\n\tunsigned long chip_id = id->driver_data;\n\tint ret;\n\n\tpmic_plat_data = dev_get_platdata(&i2c->dev);\n\n\tif (!pmic_plat_data && i2c->dev.of_node) {\n\t\tpmic_plat_data = tps65910_parse_dt(i2c, &chip_id);\n\t\tof_pmic_plat_data = pmic_plat_data;\n\t}\n\n\tif (!pmic_plat_data)\n\t\treturn -EINVAL;\n\n\tinit_data = devm_kzalloc(&i2c->dev, sizeof(*init_data), GFP_KERNEL);\n\tif (init_data == NULL)\n\t\treturn -ENOMEM;\n\n\ttps65910 = devm_kzalloc(&i2c->dev, sizeof(*tps65910), GFP_KERNEL);\n\tif (tps65910 == NULL)\n\t\treturn -ENOMEM;\n\n\ttps65910->of_plat_data = of_pmic_plat_data;\n\ti2c_set_clientdata(i2c, tps65910);\n\ttps65910->dev = &i2c->dev;\n\ttps65910->i2c_client = i2c;\n\ttps65910->id = chip_id;\n\n\t \n\ti2c_master_send(i2c, \"\", 1);\n\ttps65910->regmap = devm_regmap_init_i2c(i2c, &tps65910_regmap_config);\n\tif (IS_ERR(tps65910->regmap)) {\n\t\tret = PTR_ERR(tps65910->regmap);\n\t\tdev_err(&i2c->dev, \"regmap initialization failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinit_data->irq = pmic_plat_data->irq;\n\tinit_data->irq_base = pmic_plat_data->irq_base;\n\n\ttps65910_irq_init(tps65910, init_data->irq, init_data);\n\ttps65910_ck32k_init(tps65910, pmic_plat_data);\n\ttps65910_sleepinit(tps65910, pmic_plat_data);\n\n\tif (pmic_plat_data->pm_off && !pm_power_off) {\n\t\t \n\t\tret = regmap_set_bits(tps65910->regmap, TPS65910_DEVCTRL,\n\t\t\t\t      DEVCTRL_PWR_OFF_MASK);\n\t\tif (ret) {\n\t\t\tdev_err(&i2c->dev, \"failed to set power-off mode: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttps65910_i2c_client = i2c;\n\t\tpm_power_off = tps65910_power_off;\n\t}\n\n\tret = devm_mfd_add_devices(tps65910->dev, -1,\n\t\t\t\t   tps65910s, ARRAY_SIZE(tps65910s),\n\t\t\t\t   NULL, 0,\n\t\t\t\t   regmap_irq_get_domain(tps65910->irq_data));\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"mfd_add_devices failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id tps65910_i2c_id[] = {\n       { \"tps65910\", TPS65910 },\n       { \"tps65911\", TPS65911 },\n       { }\n};\n\nstatic struct i2c_driver tps65910_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"tps65910\",\n\t\t   .of_match_table = of_match_ptr(tps65910_of_match),\n\t},\n\t.probe = tps65910_i2c_probe,\n\t.id_table = tps65910_i2c_id,\n};\n\nstatic int __init tps65910_i2c_init(void)\n{\n\treturn i2c_add_driver(&tps65910_i2c_driver);\n}\n \nsubsys_initcall(tps65910_i2c_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}