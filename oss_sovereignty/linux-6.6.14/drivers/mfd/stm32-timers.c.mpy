{
  "module_name": "stm32-timers.c",
  "hash_id": "3d85f557f86855e3deda3ab4b1f3d7ba1eaae8f2c03f702b285eaec898ff63fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/stm32-timers.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/mfd/stm32-timers.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#define STM32_TIMERS_MAX_REGISTERS\t0x3fc\n\n \nstatic const u32 stm32_timers_dier_dmaen[STM32_TIMERS_MAX_DMAS] = {\n\tTIM_DIER_CC1DE,\n\tTIM_DIER_CC2DE,\n\tTIM_DIER_CC3DE,\n\tTIM_DIER_CC4DE,\n\tTIM_DIER_UIE,\n\tTIM_DIER_TDE,\n\tTIM_DIER_COMDE\n};\n\nstatic void stm32_timers_dma_done(void *p)\n{\n\tstruct stm32_timers_dma *dma = p;\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\n\tstatus = dmaengine_tx_status(dma->chan, dma->chan->cookie, &state);\n\tif (status == DMA_COMPLETE)\n\t\tcomplete(&dma->completion);\n}\n\n \nint stm32_timers_dma_burst_read(struct device *dev, u32 *buf,\n\t\t\t\tenum stm32_timers_dmas id, u32 reg,\n\t\t\t\tunsigned int num_reg, unsigned int bursts,\n\t\t\t\tunsigned long tmo_ms)\n{\n\tstruct stm32_timers *ddata = dev_get_drvdata(dev);\n\tunsigned long timeout = msecs_to_jiffies(tmo_ms);\n\tstruct regmap *regmap = ddata->regmap;\n\tstruct stm32_timers_dma *dma = &ddata->dma;\n\tsize_t len = num_reg * bursts * sizeof(u32);\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct dma_slave_config config;\n\tdma_cookie_t cookie;\n\tdma_addr_t dma_buf;\n\tu32 dbl, dba;\n\tlong err;\n\tint ret;\n\n\t \n\tif (id < STM32_TIMERS_DMA_CH1 || id >= STM32_TIMERS_MAX_DMAS)\n\t\treturn -EINVAL;\n\n\tif (!num_reg || !bursts || reg > STM32_TIMERS_MAX_REGISTERS ||\n\t    (reg + num_reg * sizeof(u32)) > STM32_TIMERS_MAX_REGISTERS)\n\t\treturn -EINVAL;\n\n\tif (!dma->chans[id])\n\t\treturn -ENODEV;\n\tmutex_lock(&dma->lock);\n\n\t \n\tdma->chan = dma->chans[id];\n\tdma_buf = dma_map_single(dev, buf, len, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, dma_buf)) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\t \n\tmemset(&config, 0, sizeof(config));\n\tconfig.src_addr = (dma_addr_t)dma->phys_base + TIM_DMAR;\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tret = dmaengine_slave_config(dma->chan, &config);\n\tif (ret)\n\t\tgoto unmap;\n\n\tdesc = dmaengine_prep_slave_single(dma->chan, dma_buf, len,\n\t\t\t\t\t   DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);\n\tif (!desc) {\n\t\tret = -EBUSY;\n\t\tgoto unmap;\n\t}\n\n\tdesc->callback = stm32_timers_dma_done;\n\tdesc->callback_param = dma;\n\tcookie = dmaengine_submit(desc);\n\tret = dma_submit_error(cookie);\n\tif (ret)\n\t\tgoto dma_term;\n\n\treinit_completion(&dma->completion);\n\tdma_async_issue_pending(dma->chan);\n\n\t \n\tdbl = FIELD_PREP(TIM_DCR_DBL, bursts - 1);\n\tdba = FIELD_PREP(TIM_DCR_DBA, reg >> 2);\n\tret = regmap_write(regmap, TIM_DCR, dbl | dba);\n\tif (ret)\n\t\tgoto dma_term;\n\n\t \n\tret = regmap_write(regmap, TIM_SR, 0);\n\tif (ret)\n\t\tgoto dcr_clr;\n\n\tret = regmap_update_bits(regmap, TIM_DIER, stm32_timers_dier_dmaen[id],\n\t\t\t\t stm32_timers_dier_dmaen[id]);\n\tif (ret)\n\t\tgoto dcr_clr;\n\n\terr = wait_for_completion_interruptible_timeout(&dma->completion,\n\t\t\t\t\t\t\ttimeout);\n\tif (err == 0)\n\t\tret = -ETIMEDOUT;\n\telse if (err < 0)\n\t\tret = err;\n\n\tregmap_update_bits(regmap, TIM_DIER, stm32_timers_dier_dmaen[id], 0);\n\tregmap_write(regmap, TIM_SR, 0);\ndcr_clr:\n\tregmap_write(regmap, TIM_DCR, 0);\ndma_term:\n\tdmaengine_terminate_all(dma->chan);\nunmap:\n\tdma_unmap_single(dev, dma_buf, len, DMA_FROM_DEVICE);\nunlock:\n\tdma->chan = NULL;\n\tmutex_unlock(&dma->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stm32_timers_dma_burst_read);\n\nstatic const struct regmap_config stm32_timers_regmap_cfg = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = sizeof(u32),\n\t.max_register = STM32_TIMERS_MAX_REGISTERS,\n};\n\nstatic void stm32_timers_get_arr_size(struct stm32_timers *ddata)\n{\n\tu32 arr;\n\n\t \n\tregmap_read(ddata->regmap, TIM_ARR, &arr);\n\n\t \n\tregmap_write(ddata->regmap, TIM_ARR, ~0L);\n\tregmap_read(ddata->regmap, TIM_ARR, &ddata->max_arr);\n\tregmap_write(ddata->regmap, TIM_ARR, arr);\n}\n\nstatic int stm32_timers_dma_probe(struct device *dev,\n\t\t\t\t   struct stm32_timers *ddata)\n{\n\tint i;\n\tint ret = 0;\n\tchar name[4];\n\n\tinit_completion(&ddata->dma.completion);\n\tmutex_init(&ddata->dma.lock);\n\n\t \n\tfor (i = STM32_TIMERS_DMA_CH1; i <= STM32_TIMERS_DMA_CH4; i++) {\n\t\tsnprintf(name, ARRAY_SIZE(name), \"ch%1d\", i + 1);\n\t\tddata->dma.chans[i] = dma_request_chan(dev, name);\n\t}\n\tddata->dma.chans[STM32_TIMERS_DMA_UP] = dma_request_chan(dev, \"up\");\n\tddata->dma.chans[STM32_TIMERS_DMA_TRIG] = dma_request_chan(dev, \"trig\");\n\tddata->dma.chans[STM32_TIMERS_DMA_COM] = dma_request_chan(dev, \"com\");\n\n\tfor (i = STM32_TIMERS_DMA_CH1; i < STM32_TIMERS_MAX_DMAS; i++) {\n\t\tif (IS_ERR(ddata->dma.chans[i])) {\n\t\t\t \n\t\t\tif (PTR_ERR(ddata->dma.chans[i]) != -ENODEV && !ret)\n\t\t\t\tret = PTR_ERR(ddata->dma.chans[i]);\n\n\t\t\tddata->dma.chans[i] = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void stm32_timers_dma_remove(struct device *dev,\n\t\t\t\t    struct stm32_timers *ddata)\n{\n\tint i;\n\n\tfor (i = STM32_TIMERS_DMA_CH1; i < STM32_TIMERS_MAX_DMAS; i++)\n\t\tif (ddata->dma.chans[i])\n\t\t\tdma_release_channel(ddata->dma.chans[i]);\n}\n\nstatic int stm32_timers_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_timers *ddata;\n\tstruct resource *res;\n\tvoid __iomem *mmio;\n\tint ret;\n\n\tddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tmmio = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(mmio))\n\t\treturn PTR_ERR(mmio);\n\n\t \n\tddata->dma.phys_base = res->start;\n\n\tddata->regmap = devm_regmap_init_mmio_clk(dev, \"int\", mmio,\n\t\t\t\t\t\t  &stm32_timers_regmap_cfg);\n\tif (IS_ERR(ddata->regmap))\n\t\treturn PTR_ERR(ddata->regmap);\n\n\tddata->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ddata->clk))\n\t\treturn PTR_ERR(ddata->clk);\n\n\tstm32_timers_get_arr_size(ddata);\n\n\tret = stm32_timers_dma_probe(dev, ddata);\n\tif (ret) {\n\t\tstm32_timers_dma_remove(dev, ddata);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, ddata);\n\n\tret = of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);\n\tif (ret)\n\t\tstm32_timers_dma_remove(dev, ddata);\n\n\treturn ret;\n}\n\nstatic int stm32_timers_remove(struct platform_device *pdev)\n{\n\tstruct stm32_timers *ddata = platform_get_drvdata(pdev);\n\n\t \n\tof_platform_depopulate(&pdev->dev);\n\tstm32_timers_dma_remove(&pdev->dev, ddata);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id stm32_timers_of_match[] = {\n\t{ .compatible = \"st,stm32-timers\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, stm32_timers_of_match);\n\nstatic struct platform_driver stm32_timers_driver = {\n\t.probe = stm32_timers_probe,\n\t.remove = stm32_timers_remove,\n\t.driver\t= {\n\t\t.name = \"stm32-timers\",\n\t\t.of_match_table = stm32_timers_of_match,\n\t},\n};\nmodule_platform_driver(stm32_timers_driver);\n\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 Timers\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}