{
  "module_name": "qcom-pm8008.c",
  "hash_id": "b7f3d4c61918540d6756c5bd12e7193a7c7b28ac3e87028a78d82ba6ececbff4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/qcom-pm8008.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/mfd/qcom-pm8008.h>\n\n#define I2C_INTR_STATUS_BASE\t\t0x0550\n#define INT_RT_STS_OFFSET\t\t0x10\n#define INT_SET_TYPE_OFFSET\t\t0x11\n#define INT_POL_HIGH_OFFSET\t\t0x12\n#define INT_POL_LOW_OFFSET\t\t0x13\n#define INT_LATCHED_CLR_OFFSET\t\t0x14\n#define INT_EN_SET_OFFSET\t\t0x15\n#define INT_EN_CLR_OFFSET\t\t0x16\n#define INT_LATCHED_STS_OFFSET\t\t0x18\n\nenum {\n\tPM8008_MISC,\n\tPM8008_TEMP_ALARM,\n\tPM8008_GPIO1,\n\tPM8008_GPIO2,\n\tPM8008_NUM_PERIPHS,\n};\n\n#define PM8008_PERIPH_0_BASE\t0x900\n#define PM8008_PERIPH_1_BASE\t0x2400\n#define PM8008_PERIPH_2_BASE\t0xC000\n#define PM8008_PERIPH_3_BASE\t0xC100\n\n#define PM8008_TEMP_ALARM_ADDR\tPM8008_PERIPH_1_BASE\n#define PM8008_GPIO1_ADDR\tPM8008_PERIPH_2_BASE\n#define PM8008_GPIO2_ADDR\tPM8008_PERIPH_3_BASE\n\nenum {\n\tSET_TYPE_INDEX,\n\tPOLARITY_HI_INDEX,\n\tPOLARITY_LO_INDEX,\n};\n\nstatic unsigned int pm8008_config_regs[] = {\n\tINT_SET_TYPE_OFFSET,\n\tINT_POL_HIGH_OFFSET,\n\tINT_POL_LOW_OFFSET,\n};\n\nstatic struct regmap_irq pm8008_irqs[] = {\n\tREGMAP_IRQ_REG(PM8008_IRQ_MISC_UVLO,\tPM8008_MISC,\tBIT(0)),\n\tREGMAP_IRQ_REG(PM8008_IRQ_MISC_OVLO,\tPM8008_MISC,\tBIT(1)),\n\tREGMAP_IRQ_REG(PM8008_IRQ_MISC_OTST2,\tPM8008_MISC,\tBIT(2)),\n\tREGMAP_IRQ_REG(PM8008_IRQ_MISC_OTST3,\tPM8008_MISC,\tBIT(3)),\n\tREGMAP_IRQ_REG(PM8008_IRQ_MISC_LDO_OCP,\tPM8008_MISC,\tBIT(4)),\n\tREGMAP_IRQ_REG(PM8008_IRQ_TEMP_ALARM,\tPM8008_TEMP_ALARM, BIT(0)),\n\tREGMAP_IRQ_REG(PM8008_IRQ_GPIO1,\tPM8008_GPIO1,\tBIT(0)),\n\tREGMAP_IRQ_REG(PM8008_IRQ_GPIO2,\tPM8008_GPIO2,\tBIT(0)),\n};\n\nstatic const unsigned int pm8008_periph_base[] = {\n\tPM8008_PERIPH_0_BASE,\n\tPM8008_PERIPH_1_BASE,\n\tPM8008_PERIPH_2_BASE,\n\tPM8008_PERIPH_3_BASE,\n};\n\nstatic unsigned int pm8008_get_irq_reg(struct regmap_irq_chip_data *data,\n\t\t\t\t       unsigned int base, int index)\n{\n\t \n\tif (base == I2C_INTR_STATUS_BASE)\n\t\treturn base + index;\n\n\treturn pm8008_periph_base[index] + base;\n}\n\nstatic int pm8008_set_type_config(unsigned int **buf, unsigned int type,\n\t\t\t\t  const struct regmap_irq *irq_data, int idx,\n\t\t\t\t  void *irq_drv_data)\n{\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tbuf[POLARITY_HI_INDEX][idx] &= ~irq_data->mask;\n\t\tbuf[POLARITY_LO_INDEX][idx] |= irq_data->mask;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tbuf[POLARITY_HI_INDEX][idx] |= irq_data->mask;\n\t\tbuf[POLARITY_LO_INDEX][idx] &= ~irq_data->mask;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tbuf[POLARITY_HI_INDEX][idx] |= irq_data->mask;\n\t\tbuf[POLARITY_LO_INDEX][idx] |= irq_data->mask;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tbuf[SET_TYPE_INDEX][idx] |= irq_data->mask;\n\telse\n\t\tbuf[SET_TYPE_INDEX][idx] &= ~irq_data->mask;\n\n\treturn 0;\n}\n\nstatic struct regmap_irq_chip pm8008_irq_chip = {\n\t.name\t\t\t= \"pm8008_irq\",\n\t.main_status\t\t= I2C_INTR_STATUS_BASE,\n\t.num_main_regs\t\t= 1,\n\t.irqs\t\t\t= pm8008_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(pm8008_irqs),\n\t.num_regs\t\t= PM8008_NUM_PERIPHS,\n\t.status_base\t\t= INT_LATCHED_STS_OFFSET,\n\t.mask_base\t\t= INT_EN_CLR_OFFSET,\n\t.unmask_base\t\t= INT_EN_SET_OFFSET,\n\t.mask_unmask_non_inverted = true,\n\t.ack_base\t\t= INT_LATCHED_CLR_OFFSET,\n\t.config_base\t\t= pm8008_config_regs,\n\t.num_config_bases\t= ARRAY_SIZE(pm8008_config_regs),\n\t.num_config_regs\t= PM8008_NUM_PERIPHS,\n\t.set_type_config\t= pm8008_set_type_config,\n\t.get_irq_reg\t\t= pm8008_get_irq_reg,\n};\n\nstatic struct regmap_config qcom_mfd_regmap_cfg = {\n\t.reg_bits\t= 16,\n\t.val_bits\t= 8,\n\t.max_register\t= 0xFFFF,\n};\n\nstatic int pm8008_probe_irq_peripherals(struct device *dev,\n\t\t\t\t\tstruct regmap *regmap,\n\t\t\t\t\tint client_irq)\n{\n\tint rc, i;\n\tstruct regmap_irq_type *type;\n\tstruct regmap_irq_chip_data *irq_data;\n\n\tfor (i = 0; i < ARRAY_SIZE(pm8008_irqs); i++) {\n\t\ttype = &pm8008_irqs[i].type;\n\n\t\ttype->type_reg_offset = pm8008_irqs[i].reg_offset;\n\n\t\tif (type->type_reg_offset == PM8008_MISC)\n\t\t\ttype->types_supported = IRQ_TYPE_EDGE_RISING;\n\t\telse\n\t\t\ttype->types_supported = (IRQ_TYPE_EDGE_BOTH |\n\t\t\t\tIRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW);\n\t}\n\n\trc = devm_regmap_add_irq_chip(dev, regmap, client_irq,\n\t\t\tIRQF_SHARED, 0, &pm8008_irq_chip, &irq_data);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to add IRQ chip: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int pm8008_probe(struct i2c_client *client)\n{\n\tint rc;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\n\tdev = &client->dev;\n\tregmap = devm_regmap_init_i2c(client, &qcom_mfd_regmap_cfg);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\ti2c_set_clientdata(client, regmap);\n\n\tif (of_property_read_bool(dev->of_node, \"interrupt-controller\")) {\n\t\trc = pm8008_probe_irq_peripherals(dev, regmap, client->irq);\n\t\tif (rc)\n\t\t\tdev_err(dev, \"Failed to probe irq periphs: %d\\n\", rc);\n\t}\n\n\treturn devm_of_platform_populate(dev);\n}\n\nstatic const struct of_device_id pm8008_match[] = {\n\t{ .compatible = \"qcom,pm8008\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pm8008_match);\n\nstatic struct i2c_driver pm8008_mfd_driver = {\n\t.driver = {\n\t\t.name = \"pm8008\",\n\t\t.of_match_table = pm8008_match,\n\t},\n\t.probe = pm8008_probe,\n};\nmodule_i2c_driver(pm8008_mfd_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}