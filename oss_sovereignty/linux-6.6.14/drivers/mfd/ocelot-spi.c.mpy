{
  "module_name": "ocelot-spi.c",
  "hash_id": "9b0cb2b6a46e334011ca866ecb8b0d907f60238971b153c80086f74cc952bcc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ocelot-spi.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/ioport.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/types.h>\n#include <linux/units.h>\n\n#include \"ocelot.h\"\n\n#define REG_DEV_CPUORG_IF_CTRL\t\t0x0000\n#define REG_DEV_CPUORG_IF_CFGSTAT\t0x0004\n\n#define CFGSTAT_IF_NUM_VCORE\t\t(0 << 24)\n#define CFGSTAT_IF_NUM_VRAP\t\t(1 << 24)\n#define CFGSTAT_IF_NUM_SI\t\t(2 << 24)\n#define CFGSTAT_IF_NUM_MIIM\t\t(3 << 24)\n\n#define VSC7512_DEVCPU_ORG_RES_START\t0x71000000\n#define VSC7512_DEVCPU_ORG_RES_SIZE\t0x38\n\n#define VSC7512_CHIP_REGS_RES_START\t0x71070000\n#define VSC7512_CHIP_REGS_RES_SIZE\t0x14\n\nstatic const struct resource vsc7512_dev_cpuorg_resource =\n\tDEFINE_RES_REG_NAMED(VSC7512_DEVCPU_ORG_RES_START,\n\t\t\t     VSC7512_DEVCPU_ORG_RES_SIZE,\n\t\t\t     \"devcpu_org\");\n\nstatic const struct resource vsc7512_gcb_resource =\n\tDEFINE_RES_REG_NAMED(VSC7512_CHIP_REGS_RES_START,\n\t\t\t     VSC7512_CHIP_REGS_RES_SIZE,\n\t\t\t     \"devcpu_gcb_chip_regs\");\n\nstatic int ocelot_spi_initialize(struct device *dev)\n{\n\tstruct ocelot_ddata *ddata = dev_get_drvdata(dev);\n\tu32 val, check;\n\tint err;\n\n\tval = OCELOT_SPI_BYTE_ORDER;\n\n\t \n\terr = regmap_write(ddata->cpuorg_regmap, REG_DEV_CPUORG_IF_CTRL, val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tval = ddata->spi_padding_bytes;\n\terr = regmap_write(ddata->cpuorg_regmap, REG_DEV_CPUORG_IF_CFGSTAT, val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tcheck = val | CFGSTAT_IF_NUM_SI;\n\n\terr = regmap_read(ddata->cpuorg_regmap, REG_DEV_CPUORG_IF_CFGSTAT, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (check != val)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic const struct regmap_config ocelot_spi_regmap_config = {\n\t.reg_bits = 24,\n\t.reg_stride = 4,\n\t.reg_shift = REGMAP_DOWNSHIFT(2),\n\t.val_bits = 32,\n\n\t.write_flag_mask = 0x80,\n\n\t.use_single_read = true,\n\t.use_single_write = true,\n\t.can_multi_write = false,\n\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_NATIVE,\n};\n\nstatic int ocelot_spi_regmap_bus_read(void *context, const void *reg, size_t reg_size,\n\t\t\t\t      void *val, size_t val_size)\n{\n\tstruct spi_transfer xfers[3] = {0};\n\tstruct device *dev = context;\n\tstruct ocelot_ddata *ddata;\n\tstruct spi_device *spi;\n\tstruct spi_message msg;\n\tunsigned int index = 0;\n\n\tddata = dev_get_drvdata(dev);\n\tspi = to_spi_device(dev);\n\n\txfers[index].tx_buf = reg;\n\txfers[index].len = reg_size;\n\tindex++;\n\n\tif (ddata->spi_padding_bytes) {\n\t\txfers[index].len = ddata->spi_padding_bytes;\n\t\txfers[index].tx_buf = ddata->dummy_buf;\n\t\txfers[index].dummy_data = 1;\n\t\tindex++;\n\t}\n\n\txfers[index].rx_buf = val;\n\txfers[index].len = val_size;\n\tindex++;\n\n\tspi_message_init_with_transfers(&msg, xfers, index);\n\n\treturn spi_sync(spi, &msg);\n}\n\nstatic int ocelot_spi_regmap_bus_write(void *context, const void *data, size_t count)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\treturn spi_write(spi, data, count);\n}\n\nstatic const struct regmap_bus ocelot_spi_regmap_bus = {\n\t.write = ocelot_spi_regmap_bus_write,\n\t.read = ocelot_spi_regmap_bus_read,\n};\n\nstruct regmap *ocelot_spi_init_regmap(struct device *dev, const struct resource *res)\n{\n\tstruct regmap_config regmap_config;\n\n\tmemcpy(&regmap_config, &ocelot_spi_regmap_config, sizeof(regmap_config));\n\n\tregmap_config.name = res->name;\n\tregmap_config.max_register = resource_size(res) - 1;\n\tregmap_config.reg_base = res->start;\n\n\treturn devm_regmap_init(dev, &ocelot_spi_regmap_bus, dev, &regmap_config);\n}\nEXPORT_SYMBOL_NS(ocelot_spi_init_regmap, MFD_OCELOT_SPI);\n\nstatic int ocelot_spi_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct ocelot_ddata *ddata;\n\tstruct regmap *r;\n\tint err;\n\n\tddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, ddata);\n\n\tif (spi->max_speed_hz <= 500000) {\n\t\tddata->spi_padding_bytes = 0;\n\t} else {\n\t\t \n\t\tddata->spi_padding_bytes = 1 + (spi->max_speed_hz / HZ_PER_MHZ + 2) / 8;\n\n\t\tddata->dummy_buf = devm_kzalloc(dev, ddata->spi_padding_bytes, GFP_KERNEL);\n\t\tif (!ddata->dummy_buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspi->bits_per_word = 8;\n\n\terr = spi_setup(spi);\n\tif (err)\n\t\treturn dev_err_probe(&spi->dev, err, \"Error performing SPI setup\\n\");\n\n\tr = ocelot_spi_init_regmap(dev, &vsc7512_dev_cpuorg_resource);\n\tif (IS_ERR(r))\n\t\treturn PTR_ERR(r);\n\n\tddata->cpuorg_regmap = r;\n\n\tr = ocelot_spi_init_regmap(dev, &vsc7512_gcb_resource);\n\tif (IS_ERR(r))\n\t\treturn PTR_ERR(r);\n\n\tddata->gcb_regmap = r;\n\n\t \n\terr = ocelot_spi_initialize(dev);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Error initializing SPI bus\\n\");\n\n\terr = ocelot_chip_reset(dev);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Error resetting device\\n\");\n\n\t \n\terr = ocelot_spi_initialize(dev);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Error initializing SPI bus after reset\\n\");\n\n\terr = ocelot_core_init(dev);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Error initializing Ocelot core\\n\");\n\n\treturn 0;\n}\n\nstatic const struct spi_device_id ocelot_spi_ids[] = {\n\t{ \"vsc7512\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ocelot_spi_ids);\n\nstatic const struct of_device_id ocelot_spi_of_match[] = {\n\t{ .compatible = \"mscc,vsc7512\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ocelot_spi_of_match);\n\nstatic struct spi_driver ocelot_spi_driver = {\n\t.driver = {\n\t\t.name = \"ocelot-soc\",\n\t\t.of_match_table = ocelot_spi_of_match,\n\t},\n\t.id_table = ocelot_spi_ids,\n\t.probe = ocelot_spi_probe,\n};\nmodule_spi_driver(ocelot_spi_driver);\n\nMODULE_DESCRIPTION(\"SPI Controlled Ocelot Chip Driver\");\nMODULE_AUTHOR(\"Colin Foster <colin.foster@in-advantage.com>\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_IMPORT_NS(MFD_OCELOT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}