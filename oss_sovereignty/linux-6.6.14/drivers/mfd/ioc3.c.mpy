{
  "module_name": "ioc3.c",
  "hash_id": "8b611a743b0d858c35cdcace70a65b5cb0b0902633083ebf37e4bcff97541c66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ioc3.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/sgi-w1.h>\n#include <linux/rtc/ds1685.h>\n\n#include <asm/pci/bridge.h>\n#include <asm/sn/ioc3.h>\n\n#define IOC3_IRQ_SERIAL_A\t6\n#define IOC3_IRQ_SERIAL_B\t15\n#define IOC3_IRQ_KBD\t\t22\n\n \n#define IOC3_LVL_MASK\t(BIT(IOC3_IRQ_SERIAL_A) | BIT(IOC3_IRQ_SERIAL_B))\n\n#define M48T35_REG_SIZE\t32768\t \n\n \n#define IOC3_LATENCY\t40\n\nstruct ioc3_priv_data {\n\tstruct irq_domain *domain;\n\tstruct ioc3 __iomem *regs;\n\tstruct pci_dev *pdev;\n\tint domain_irq;\n};\n\nstatic void ioc3_irq_ack(struct irq_data *d)\n{\n\tstruct ioc3_priv_data *ipd = irq_data_get_irq_chip_data(d);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\n\twritel(BIT(hwirq), &ipd->regs->sio_ir);\n}\n\nstatic void ioc3_irq_mask(struct irq_data *d)\n{\n\tstruct ioc3_priv_data *ipd = irq_data_get_irq_chip_data(d);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\n\twritel(BIT(hwirq), &ipd->regs->sio_iec);\n}\n\nstatic void ioc3_irq_unmask(struct irq_data *d)\n{\n\tstruct ioc3_priv_data *ipd = irq_data_get_irq_chip_data(d);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\n\twritel(BIT(hwirq), &ipd->regs->sio_ies);\n}\n\nstatic struct irq_chip ioc3_irq_chip = {\n\t.name\t\t= \"IOC3\",\n\t.irq_ack\t= ioc3_irq_ack,\n\t.irq_mask\t= ioc3_irq_mask,\n\t.irq_unmask\t= ioc3_irq_unmask,\n};\n\nstatic int ioc3_irq_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\t \n\tif (BIT(hwirq) & IOC3_LVL_MASK)\n\t\tirq_set_chip_and_handler(irq, &ioc3_irq_chip, handle_level_irq);\n\telse\n\t\tirq_set_chip_and_handler(irq, &ioc3_irq_chip, handle_edge_irq);\n\n\tirq_set_chip_data(irq, d->host_data);\n\treturn 0;\n}\n\nstatic void ioc3_irq_domain_unmap(struct irq_domain *d, unsigned int irq)\n{\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\tirq_set_chip_data(irq, NULL);\n}\n\nstatic const struct irq_domain_ops ioc3_irq_domain_ops = {\n\t.map = ioc3_irq_domain_map,\n\t.unmap = ioc3_irq_domain_unmap,\n};\n\nstatic void ioc3_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_domain *domain = irq_desc_get_handler_data(desc);\n\tstruct ioc3_priv_data *ipd = domain->host_data;\n\tstruct ioc3 __iomem *regs = ipd->regs;\n\tu32 pending, mask;\n\n\tpending = readl(&regs->sio_ir);\n\tmask = readl(&regs->sio_ies);\n\tpending &= mask;  \n\n\tif (pending)\n\t\tgeneric_handle_domain_irq(domain, __ffs(pending));\n\telse\n\t\tspurious_interrupt();\n}\n\n \nstatic int ioc3_map_irq(struct pci_dev *pdev, int slot, int pin)\n{\n\tstruct pci_host_bridge *hbrg = pci_find_host_bridge(pdev->bus);\n\n\treturn hbrg->map_irq(pdev, slot, pin);\n}\n\nstatic int ioc3_irq_domain_setup(struct ioc3_priv_data *ipd, int irq)\n{\n\tstruct irq_domain *domain;\n\tstruct fwnode_handle *fn;\n\n\tfn = irq_domain_alloc_named_fwnode(\"IOC3\");\n\tif (!fn)\n\t\tgoto err;\n\n\tdomain = irq_domain_create_linear(fn, 24, &ioc3_irq_domain_ops, ipd);\n\tif (!domain) {\n\t\tirq_domain_free_fwnode(fn);\n\t\tgoto err;\n\t}\n\n\tipd->domain = domain;\n\n\tirq_set_chained_handler_and_data(irq, ioc3_irq_handler, domain);\n\tipd->domain_irq = irq;\n\treturn 0;\n\nerr:\n\tdev_err(&ipd->pdev->dev, \"irq domain setup failed\\n\");\n\treturn -ENOMEM;\n}\n\nstatic const struct resource ioc3_uarta_resources[] = {\n\tDEFINE_RES_MEM(offsetof(struct ioc3, sregs.uarta),\n\t\t       sizeof_field(struct ioc3, sregs.uarta)),\n\tDEFINE_RES_IRQ(IOC3_IRQ_SERIAL_A)\n};\n\nstatic const struct resource ioc3_uartb_resources[] = {\n\tDEFINE_RES_MEM(offsetof(struct ioc3, sregs.uartb),\n\t\t       sizeof_field(struct ioc3, sregs.uartb)),\n\tDEFINE_RES_IRQ(IOC3_IRQ_SERIAL_B)\n};\n\nstatic struct mfd_cell ioc3_serial_cells[] = {\n\t{\n\t\t.name = \"ioc3-serial8250\",\n\t\t.resources = ioc3_uarta_resources,\n\t\t.num_resources = ARRAY_SIZE(ioc3_uarta_resources),\n\t},\n\t{\n\t\t.name = \"ioc3-serial8250\",\n\t\t.resources = ioc3_uartb_resources,\n\t\t.num_resources = ARRAY_SIZE(ioc3_uartb_resources),\n\t}\n};\n\nstatic int ioc3_serial_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret;\n\n\t \n\twritel(GPCR_UARTA_MODESEL | GPCR_UARTB_MODESEL,\n\t\t&ipd->regs->gpcr_s);\n\t \n\twritel(0, &ipd->regs->gppr[6]);\n\t \n\twritel(0, &ipd->regs->gppr[7]);\n\n\t \n\twritel(readl(&ipd->regs->port_a.sscr) & ~SSCR_DMA_EN,\n\t       &ipd->regs->port_a.sscr);\n\twritel(readl(&ipd->regs->port_b.sscr) & ~SSCR_DMA_EN,\n\t       &ipd->regs->port_b.sscr);\n\tudelay(1000);  \n\n\tret = mfd_add_devices(&ipd->pdev->dev, PLATFORM_DEVID_AUTO,\n\t\t\t      ioc3_serial_cells, ARRAY_SIZE(ioc3_serial_cells),\n\t\t\t      &ipd->pdev->resource[0], 0, ipd->domain);\n\tif (ret) {\n\t\tdev_err(&ipd->pdev->dev, \"Failed to add 16550 subdevs\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct resource ioc3_kbd_resources[] = {\n\tDEFINE_RES_MEM(offsetof(struct ioc3, serio),\n\t\t       sizeof_field(struct ioc3, serio)),\n\tDEFINE_RES_IRQ(IOC3_IRQ_KBD)\n};\n\nstatic struct mfd_cell ioc3_kbd_cells[] = {\n\t{\n\t\t.name = \"ioc3-kbd\",\n\t\t.resources = ioc3_kbd_resources,\n\t\t.num_resources = ARRAY_SIZE(ioc3_kbd_resources),\n\t}\n};\n\nstatic int ioc3_kbd_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret;\n\n\tret = mfd_add_devices(&ipd->pdev->dev, PLATFORM_DEVID_AUTO,\n\t\t\t      ioc3_kbd_cells, ARRAY_SIZE(ioc3_kbd_cells),\n\t\t\t      &ipd->pdev->resource[0], 0, ipd->domain);\n\tif (ret) {\n\t\tdev_err(&ipd->pdev->dev, \"Failed to add 16550 subdevs\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct resource ioc3_eth_resources[] = {\n\tDEFINE_RES_MEM(offsetof(struct ioc3, eth),\n\t\t       sizeof_field(struct ioc3, eth)),\n\tDEFINE_RES_MEM(offsetof(struct ioc3, ssram),\n\t\t       sizeof_field(struct ioc3, ssram)),\n\tDEFINE_RES_IRQ(0)\n};\n\nstatic const struct resource ioc3_w1_resources[] = {\n\tDEFINE_RES_MEM(offsetof(struct ioc3, mcr),\n\t\t       sizeof_field(struct ioc3, mcr)),\n};\nstatic struct sgi_w1_platform_data ioc3_w1_platform_data;\n\nstatic struct mfd_cell ioc3_eth_cells[] = {\n\t{\n\t\t.name = \"ioc3-eth\",\n\t\t.resources = ioc3_eth_resources,\n\t\t.num_resources = ARRAY_SIZE(ioc3_eth_resources),\n\t},\n\t{\n\t\t.name = \"sgi_w1\",\n\t\t.resources = ioc3_w1_resources,\n\t\t.num_resources = ARRAY_SIZE(ioc3_w1_resources),\n\t\t.platform_data = &ioc3_w1_platform_data,\n\t\t.pdata_size = sizeof(ioc3_w1_platform_data),\n\t}\n};\n\nstatic int ioc3_eth_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret;\n\n\t \n\twritel(GPCR_MLAN_EN, &ipd->regs->gpcr_s);\n\n\t \n\tsnprintf(ioc3_w1_platform_data.dev_id,\n\t\t sizeof(ioc3_w1_platform_data.dev_id), \"ioc3-%012llx\",\n\t\t ipd->pdev->resource->start);\n\n\tret = mfd_add_devices(&ipd->pdev->dev, PLATFORM_DEVID_AUTO,\n\t\t\t      ioc3_eth_cells, ARRAY_SIZE(ioc3_eth_cells),\n\t\t\t      &ipd->pdev->resource[0], ipd->pdev->irq, NULL);\n\tif (ret) {\n\t\tdev_err(&ipd->pdev->dev, \"Failed to add ETH/W1 subdev\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct resource ioc3_m48t35_resources[] = {\n\tDEFINE_RES_MEM(IOC3_BYTEBUS_DEV0, M48T35_REG_SIZE)\n};\n\nstatic struct mfd_cell ioc3_m48t35_cells[] = {\n\t{\n\t\t.name = \"rtc-m48t35\",\n\t\t.resources = ioc3_m48t35_resources,\n\t\t.num_resources = ARRAY_SIZE(ioc3_m48t35_resources),\n\t}\n};\n\nstatic int ioc3_m48t35_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret;\n\n\tret = mfd_add_devices(&ipd->pdev->dev, PLATFORM_DEVID_AUTO,\n\t\t\t      ioc3_m48t35_cells, ARRAY_SIZE(ioc3_m48t35_cells),\n\t\t\t      &ipd->pdev->resource[0], 0, ipd->domain);\n\tif (ret)\n\t\tdev_err(&ipd->pdev->dev, \"Failed to add M48T35 subdev\\n\");\n\n\treturn ret;\n}\n\nstatic struct ds1685_rtc_platform_data ip30_rtc_platform_data = {\n\t.bcd_mode = false,\n\t.no_irq = false,\n\t.uie_unsupported = true,\n\t.access_type = ds1685_reg_indirect,\n};\n\nstatic const struct resource ioc3_rtc_ds1685_resources[] = {\n\tDEFINE_RES_MEM(IOC3_BYTEBUS_DEV1, 1),\n\tDEFINE_RES_MEM(IOC3_BYTEBUS_DEV2, 1),\n\tDEFINE_RES_IRQ(0)\n};\n\nstatic struct mfd_cell ioc3_ds1685_cells[] = {\n\t{\n\t\t.name = \"rtc-ds1685\",\n\t\t.resources = ioc3_rtc_ds1685_resources,\n\t\t.num_resources = ARRAY_SIZE(ioc3_rtc_ds1685_resources),\n\t\t.platform_data = &ip30_rtc_platform_data,\n\t\t.pdata_size = sizeof(ip30_rtc_platform_data),\n\t\t.id = PLATFORM_DEVID_NONE,\n\t}\n};\n\nstatic int ioc3_ds1685_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret, irq;\n\n\tirq = ioc3_map_irq(ipd->pdev, 6, 0);\n\n\tret = mfd_add_devices(&ipd->pdev->dev, 0, ioc3_ds1685_cells,\n\t\t\t      ARRAY_SIZE(ioc3_ds1685_cells),\n\t\t\t      &ipd->pdev->resource[0], irq, NULL);\n\tif (ret)\n\t\tdev_err(&ipd->pdev->dev, \"Failed to add DS1685 subdev\\n\");\n\n\treturn ret;\n};\n\n\nstatic const struct resource ioc3_leds_resources[] = {\n\tDEFINE_RES_MEM(offsetof(struct ioc3, gppr[0]),\n\t\t       sizeof_field(struct ioc3, gppr[0])),\n\tDEFINE_RES_MEM(offsetof(struct ioc3, gppr[1]),\n\t\t       sizeof_field(struct ioc3, gppr[1])),\n};\n\nstatic struct mfd_cell ioc3_led_cells[] = {\n\t{\n\t\t.name = \"ip30-leds\",\n\t\t.resources = ioc3_leds_resources,\n\t\t.num_resources = ARRAY_SIZE(ioc3_leds_resources),\n\t\t.id = PLATFORM_DEVID_NONE,\n\t}\n};\n\nstatic int ioc3_led_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret;\n\n\tret = mfd_add_devices(&ipd->pdev->dev, 0, ioc3_led_cells,\n\t\t\t      ARRAY_SIZE(ioc3_led_cells),\n\t\t\t      &ipd->pdev->resource[0], 0, ipd->domain);\n\tif (ret)\n\t\tdev_err(&ipd->pdev->dev, \"Failed to add LED subdev\\n\");\n\n\treturn ret;\n}\n\nstatic int ip27_baseio_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret, io_irq;\n\n\tio_irq = ioc3_map_irq(ipd->pdev, PCI_SLOT(ipd->pdev->devfn),\n\t\t\t      PCI_INTERRUPT_INTB);\n\tret = ioc3_irq_domain_setup(ipd, io_irq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_eth_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_serial_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ioc3_m48t35_setup(ipd);\n}\n\nstatic int ip27_baseio6g_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret, io_irq;\n\n\tio_irq = ioc3_map_irq(ipd->pdev, PCI_SLOT(ipd->pdev->devfn),\n\t\t\t      PCI_INTERRUPT_INTB);\n\tret = ioc3_irq_domain_setup(ipd, io_irq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_eth_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_serial_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_m48t35_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ioc3_kbd_setup(ipd);\n}\n\nstatic int ip27_mio_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret;\n\n\tret = ioc3_irq_domain_setup(ipd, ipd->pdev->irq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_serial_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ioc3_kbd_setup(ipd);\n}\n\nstatic int ip30_sysboard_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret, io_irq;\n\n\tio_irq = ioc3_map_irq(ipd->pdev, PCI_SLOT(ipd->pdev->devfn),\n\t\t\t      PCI_INTERRUPT_INTB);\n\tret = ioc3_irq_domain_setup(ipd, io_irq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_eth_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_serial_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_kbd_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_ds1685_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ioc3_led_setup(ipd);\n}\n\nstatic int ioc3_menet_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret, io_irq;\n\n\tio_irq = ioc3_map_irq(ipd->pdev, PCI_SLOT(ipd->pdev->devfn),\n\t\t\t      PCI_INTERRUPT_INTB);\n\tret = ioc3_irq_domain_setup(ipd, io_irq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_eth_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ioc3_serial_setup(ipd);\n}\n\nstatic int ioc3_menet4_setup(struct ioc3_priv_data *ipd)\n{\n\treturn ioc3_eth_setup(ipd);\n}\n\nstatic int ioc3_cad_duo_setup(struct ioc3_priv_data *ipd)\n{\n\tint ret, io_irq;\n\n\tio_irq = ioc3_map_irq(ipd->pdev, PCI_SLOT(ipd->pdev->devfn),\n\t\t\t      PCI_INTERRUPT_INTB);\n\tret = ioc3_irq_domain_setup(ipd, io_irq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ioc3_eth_setup(ipd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ioc3_kbd_setup(ipd);\n}\n\n \n#define IOC3_SID(_name, _sid, _setup) \\\n\t{\t\t\t\t\t\t\t\t   \\\n\t\t.name = _name,\t\t\t\t\t\t   \\\n\t\t.sid = PCI_VENDOR_ID_SGI | (IOC3_SUBSYS_ ## _sid << 16),   \\\n\t\t.setup = _setup,\t\t\t\t\t   \\\n\t}\n\nstatic struct {\n\tconst char *name;\n\tu32 sid;\n\tint (*setup)(struct ioc3_priv_data *ipd);\n} ioc3_infos[] = {\n\tIOC3_SID(\"IP27 BaseIO6G\", IP27_BASEIO6G, &ip27_baseio6g_setup),\n\tIOC3_SID(\"IP27 MIO\", IP27_MIO, &ip27_mio_setup),\n\tIOC3_SID(\"IP27 BaseIO\", IP27_BASEIO, &ip27_baseio_setup),\n\tIOC3_SID(\"IP29 System Board\", IP29_SYSBOARD, &ip27_baseio6g_setup),\n\tIOC3_SID(\"IP30 System Board\", IP30_SYSBOARD, &ip30_sysboard_setup),\n\tIOC3_SID(\"MENET\", MENET, &ioc3_menet_setup),\n\tIOC3_SID(\"MENET4\", MENET4, &ioc3_menet4_setup)\n};\n#undef IOC3_SID\n\nstatic int ioc3_setup(struct ioc3_priv_data *ipd)\n{\n\tu32 sid;\n\tint i;\n\n\t \n\twritel(~0, &ipd->regs->sio_iec);\n\twritel(~0, &ipd->regs->sio_ir);\n\twritel(0, &ipd->regs->eth.eier);\n\twritel(~0, &ipd->regs->eth.eisr);\n\n\t \n\tpci_read_config_dword(ipd->pdev, PCI_SUBSYSTEM_VENDOR_ID, &sid);\n\n\tfor (i = 0; i < ARRAY_SIZE(ioc3_infos); i++)\n\t\tif (sid == ioc3_infos[i].sid) {\n\t\t\tpr_info(\"ioc3: %s\\n\", ioc3_infos[i].name);\n\t\t\treturn ioc3_infos[i].setup(ipd);\n\t\t}\n\n\t \n\tpr_info(\"ioc3: CAD DUO\\n\");\n\treturn ioc3_cad_duo_setup(ipd);\n}\n\nstatic int ioc3_mfd_probe(struct pci_dev *pdev,\n\t\t\t  const struct pci_device_id *pci_id)\n{\n\tstruct ioc3_priv_data *ipd;\n\tstruct ioc3 __iomem *regs;\n\tint ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, IOC3_LATENCY);\n\tpci_set_master(pdev);\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\tpr_err(\"%s: No usable DMA configuration, aborting.\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto out_disable_device;\n\t}\n\n\t \n\tipd = devm_kzalloc(&pdev->dev, sizeof(struct ioc3_priv_data),\n\t\t\t   GFP_KERNEL);\n\tif (!ipd) {\n\t\tret = -ENOMEM;\n\t\tgoto out_disable_device;\n\t}\n\tipd->pdev = pdev;\n\n\t \n\tregs = pci_ioremap_bar(pdev, 0);\n\tif (!regs) {\n\t\tdev_warn(&pdev->dev, \"ioc3: Unable to remap PCI BAR for %s.\\n\",\n\t\t\t pci_name(pdev));\n\t\tret = -ENOMEM;\n\t\tgoto out_disable_device;\n\t}\n\tipd->regs = regs;\n\n\t \n\tpci_set_drvdata(pdev, ipd);\n\n\tret = ioc3_setup(ipd);\n\tif (ret) {\n\t\t \n\t\tmfd_remove_devices(&ipd->pdev->dev);\n\t\tif (ipd->domain) {\n\t\t\tstruct fwnode_handle *fn = ipd->domain->fwnode;\n\n\t\t\tirq_domain_remove(ipd->domain);\n\t\t\tirq_domain_free_fwnode(fn);\n\t\t\tfree_irq(ipd->domain_irq, (void *)ipd);\n\t\t}\n\t\tpci_iounmap(pdev, regs);\n\t\tgoto out_disable_device;\n\t}\n\n\treturn 0;\n\nout_disable_device:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic void ioc3_mfd_remove(struct pci_dev *pdev)\n{\n\tstruct ioc3_priv_data *ipd;\n\n\tipd = pci_get_drvdata(pdev);\n\n\t \n\twritel(~0, &ipd->regs->sio_iec);\n\twritel(~0, &ipd->regs->sio_ir);\n\n\t \n\tmfd_remove_devices(&ipd->pdev->dev);\n\tif (ipd->domain) {\n\t\tstruct fwnode_handle *fn = ipd->domain->fwnode;\n\n\t\tirq_domain_remove(ipd->domain);\n\t\tirq_domain_free_fwnode(fn);\n\t\tfree_irq(ipd->domain_irq, (void *)ipd);\n\t}\n\tpci_iounmap(pdev, ipd->regs);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_device_id ioc3_mfd_id_table[] = {\n\t{ PCI_VENDOR_ID_SGI, PCI_DEVICE_ID_SGI_IOC3, PCI_ANY_ID, PCI_ANY_ID },\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, ioc3_mfd_id_table);\n\nstatic struct pci_driver ioc3_mfd_driver = {\n\t.name = \"IOC3\",\n\t.id_table = ioc3_mfd_id_table,\n\t.probe = ioc3_mfd_probe,\n\t.remove = ioc3_mfd_remove,\n};\n\nmodule_pci_driver(ioc3_mfd_driver);\n\nMODULE_AUTHOR(\"Thomas Bogendoerfer <tbogendoerfer@suse.de>\");\nMODULE_DESCRIPTION(\"SGI IOC3 MFD driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}