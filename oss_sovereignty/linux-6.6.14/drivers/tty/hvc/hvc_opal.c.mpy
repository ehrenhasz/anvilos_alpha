{
  "module_name": "hvc_opal.c",
  "hash_id": "c72b51773a01004e46591b1a9d3a0d6be2bddbc8a7ece16d2a6c628d1b3a420f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/hvc/hvc_opal.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/console.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n\n#include <asm/hvconsole.h>\n#include <asm/firmware.h>\n#include <asm/hvsi.h>\n#include <asm/udbg.h>\n#include <asm/opal.h>\n\n#include \"hvc_console.h\"\n\nstatic const char hvc_opal_name[] = \"hvc_opal\";\n\nstatic const struct of_device_id hvc_opal_match[] = {\n\t{ .name = \"serial\", .compatible = \"ibm,opal-console-raw\" },\n\t{ .name = \"serial\", .compatible = \"ibm,opal-console-hvsi\" },\n\t{ },\n};\n\ntypedef enum hv_protocol {\n\tHV_PROTOCOL_RAW,\n\tHV_PROTOCOL_HVSI\n} hv_protocol_t;\n\nstruct hvc_opal_priv {\n\thv_protocol_t\t\tproto;\t \n\tstruct hvsi_priv\thvsi;\t \n};\nstatic struct hvc_opal_priv *hvc_opal_privs[MAX_NR_HVC_CONSOLES];\n\n \nstatic struct hvc_opal_priv hvc_opal_boot_priv;\nstatic u32 hvc_opal_boot_termno;\n\nstatic const struct hv_ops hvc_opal_raw_ops = {\n\t.get_chars = opal_get_chars,\n\t.put_chars = opal_put_chars,\n\t.flush = opal_flush_chars,\n\t.notifier_add = notifier_add_irq,\n\t.notifier_del = notifier_del_irq,\n\t.notifier_hangup = notifier_hangup_irq,\n};\n\nstatic int hvc_opal_hvsi_get_chars(uint32_t vtermno, char *buf, int count)\n{\n\tstruct hvc_opal_priv *pv = hvc_opal_privs[vtermno];\n\n\tif (WARN_ON(!pv))\n\t\treturn -ENODEV;\n\n\treturn hvsilib_get_chars(&pv->hvsi, buf, count);\n}\n\nstatic int hvc_opal_hvsi_put_chars(uint32_t vtermno, const char *buf, int count)\n{\n\tstruct hvc_opal_priv *pv = hvc_opal_privs[vtermno];\n\n\tif (WARN_ON(!pv))\n\t\treturn -ENODEV;\n\n\treturn hvsilib_put_chars(&pv->hvsi, buf, count);\n}\n\nstatic int hvc_opal_hvsi_open(struct hvc_struct *hp, int data)\n{\n\tstruct hvc_opal_priv *pv = hvc_opal_privs[hp->vtermno];\n\tint rc;\n\n\tpr_devel(\"HVSI@%x: do open !\\n\", hp->vtermno);\n\n\trc = notifier_add_irq(hp, data);\n\tif (rc)\n\t\treturn rc;\n\n\treturn hvsilib_open(&pv->hvsi, hp);\n}\n\nstatic void hvc_opal_hvsi_close(struct hvc_struct *hp, int data)\n{\n\tstruct hvc_opal_priv *pv = hvc_opal_privs[hp->vtermno];\n\n\tpr_devel(\"HVSI@%x: do close !\\n\", hp->vtermno);\n\n\thvsilib_close(&pv->hvsi, hp);\n\n\tnotifier_del_irq(hp, data);\n}\n\nstatic void hvc_opal_hvsi_hangup(struct hvc_struct *hp, int data)\n{\n\tstruct hvc_opal_priv *pv = hvc_opal_privs[hp->vtermno];\n\n\tpr_devel(\"HVSI@%x: do hangup !\\n\", hp->vtermno);\n\n\thvsilib_close(&pv->hvsi, hp);\n\n\tnotifier_hangup_irq(hp, data);\n}\n\nstatic int hvc_opal_hvsi_tiocmget(struct hvc_struct *hp)\n{\n\tstruct hvc_opal_priv *pv = hvc_opal_privs[hp->vtermno];\n\n\tif (!pv)\n\t\treturn -EINVAL;\n\treturn pv->hvsi.mctrl;\n}\n\nstatic int hvc_opal_hvsi_tiocmset(struct hvc_struct *hp, unsigned int set,\n\t\t\t\tunsigned int clear)\n{\n\tstruct hvc_opal_priv *pv = hvc_opal_privs[hp->vtermno];\n\n\tpr_devel(\"HVSI@%x: Set modem control, set=%x,clr=%x\\n\",\n\t\t hp->vtermno, set, clear);\n\n\tif (set & TIOCM_DTR)\n\t\thvsilib_write_mctrl(&pv->hvsi, 1);\n\telse if (clear & TIOCM_DTR)\n\t\thvsilib_write_mctrl(&pv->hvsi, 0);\n\n\treturn 0;\n}\n\nstatic const struct hv_ops hvc_opal_hvsi_ops = {\n\t.get_chars = hvc_opal_hvsi_get_chars,\n\t.put_chars = hvc_opal_hvsi_put_chars,\n\t.flush = opal_flush_chars,\n\t.notifier_add = hvc_opal_hvsi_open,\n\t.notifier_del = hvc_opal_hvsi_close,\n\t.notifier_hangup = hvc_opal_hvsi_hangup,\n\t.tiocmget = hvc_opal_hvsi_tiocmget,\n\t.tiocmset = hvc_opal_hvsi_tiocmset,\n};\n\nstatic int hvc_opal_probe(struct platform_device *dev)\n{\n\tconst struct hv_ops *ops;\n\tstruct hvc_struct *hp;\n\tstruct hvc_opal_priv *pv;\n\thv_protocol_t proto;\n\tunsigned int termno, irq, boot = 0;\n\tconst __be32 *reg;\n\n\tif (of_device_is_compatible(dev->dev.of_node, \"ibm,opal-console-raw\")) {\n\t\tproto = HV_PROTOCOL_RAW;\n\t\tops = &hvc_opal_raw_ops;\n\t} else if (of_device_is_compatible(dev->dev.of_node,\n\t\t\t\t\t   \"ibm,opal-console-hvsi\")) {\n\t\tproto = HV_PROTOCOL_HVSI;\n\t\tops = &hvc_opal_hvsi_ops;\n\t} else {\n\t\tpr_err(\"hvc_opal: Unknown protocol for %pOF\\n\",\n\t\t       dev->dev.of_node);\n\t\treturn -ENXIO;\n\t}\n\n\treg = of_get_property(dev->dev.of_node, \"reg\", NULL);\n\ttermno = reg ? be32_to_cpup(reg) : 0;\n\n\t \n\tif (hvc_opal_privs[termno] == &hvc_opal_boot_priv) {\n\t\tpv = hvc_opal_privs[termno];\n\t\tboot = 1;\n\t} else if (hvc_opal_privs[termno] == NULL) {\n\t\tpv = kzalloc(sizeof(struct hvc_opal_priv), GFP_KERNEL);\n\t\tif (!pv)\n\t\t\treturn -ENOMEM;\n\t\tpv->proto = proto;\n\t\thvc_opal_privs[termno] = pv;\n\t\tif (proto == HV_PROTOCOL_HVSI) {\n\t\t\t \n\t\t\thvsilib_init(&pv->hvsi,\n\t\t\t\t     opal_get_chars, opal_put_chars_atomic,\n\t\t\t\t     termno, 0);\n\t\t}\n\n\t\t \n\t\thvc_instantiate(termno, termno, ops);\n\t} else {\n\t\tpr_err(\"hvc_opal: Device %pOF has duplicate terminal number #%d\\n\",\n\t\t       dev->dev.of_node, termno);\n\t\treturn -ENXIO;\n\t}\n\n\tpr_info(\"hvc%d: %s protocol on %pOF%s\\n\", termno,\n\t\tproto == HV_PROTOCOL_RAW ? \"raw\" : \"hvsi\",\n\t\tdev->dev.of_node,\n\t\tboot ? \" (boot console)\" : \"\");\n\n\tirq = irq_of_parse_and_map(dev->dev.of_node, 0);\n\tif (!irq) {\n\t\tpr_info(\"hvc%d: No interrupts property, using OPAL event\\n\",\n\t\t\t\ttermno);\n\t\tirq = opal_event_request(ilog2(OPAL_EVENT_CONSOLE_INPUT));\n\t}\n\n\tif (!irq) {\n\t\tpr_err(\"hvc_opal: Unable to map interrupt for device %pOF\\n\",\n\t\t\tdev->dev.of_node);\n\t\treturn irq;\n\t}\n\n\thp = hvc_alloc(termno, irq, ops, MAX_VIO_PUT_CHARS);\n\tif (IS_ERR(hp))\n\t\treturn PTR_ERR(hp);\n\n\t \n\thp->flags = IRQF_SHARED;\n\tdev_set_drvdata(&dev->dev, hp);\n\n\treturn 0;\n}\n\nstatic int hvc_opal_remove(struct platform_device *dev)\n{\n\tstruct hvc_struct *hp = dev_get_drvdata(&dev->dev);\n\tint rc, termno;\n\n\ttermno = hp->vtermno;\n\trc = hvc_remove(hp);\n\tif (rc == 0) {\n\t\tif (hvc_opal_privs[termno] != &hvc_opal_boot_priv)\n\t\t\tkfree(hvc_opal_privs[termno]);\n\t\thvc_opal_privs[termno] = NULL;\n\t}\n\treturn rc;\n}\n\nstatic struct platform_driver hvc_opal_driver = {\n\t.probe\t\t= hvc_opal_probe,\n\t.remove\t\t= hvc_opal_remove,\n\t.driver\t\t= {\n\t\t.name\t= hvc_opal_name,\n\t\t.of_match_table\t= hvc_opal_match,\n\t}\n};\n\nstatic int __init hvc_opal_init(void)\n{\n\tif (!firmware_has_feature(FW_FEATURE_OPAL))\n\t\treturn -ENODEV;\n\n\t \n\treturn platform_driver_register(&hvc_opal_driver);\n}\ndevice_initcall(hvc_opal_init);\n\nstatic void udbg_opal_putc(char c)\n{\n\tunsigned int termno = hvc_opal_boot_termno;\n\tint count = -1;\n\n\tif (c == '\\n')\n\t\tudbg_opal_putc('\\r');\n\n\tdo {\n\t\tswitch(hvc_opal_boot_priv.proto) {\n\t\tcase HV_PROTOCOL_RAW:\n\t\t\tcount = opal_put_chars(termno, &c, 1);\n\t\t\tbreak;\n\t\tcase HV_PROTOCOL_HVSI:\n\t\t\tcount = hvc_opal_hvsi_put_chars(termno, &c, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\topal_flush_console(termno);\n\t} while(count == 0 || count == -EAGAIN);\n}\n\nstatic int udbg_opal_getc_poll(void)\n{\n\tunsigned int termno = hvc_opal_boot_termno;\n\tint rc = 0;\n\tchar c;\n\n\tswitch(hvc_opal_boot_priv.proto) {\n\tcase HV_PROTOCOL_RAW:\n\t\trc = opal_get_chars(termno, &c, 1);\n\t\tbreak;\n\tcase HV_PROTOCOL_HVSI:\n\t\trc = hvc_opal_hvsi_get_chars(termno, &c, 1);\n\t\tbreak;\n\t}\n\tif (!rc)\n\t\treturn -1;\n\treturn c;\n}\n\nstatic int udbg_opal_getc(void)\n{\n\tint ch;\n\tfor (;;) {\n\t\tch = udbg_opal_getc_poll();\n\t\tif (ch != -1)\n\t\t\treturn ch;\n\t}\n}\n\nstatic void udbg_init_opal_common(void)\n{\n\tudbg_putc = udbg_opal_putc;\n\tudbg_getc = udbg_opal_getc;\n\tudbg_getc_poll = udbg_opal_getc_poll;\n}\n\nvoid __init hvc_opal_init_early(void)\n{\n\tstruct device_node *stdout_node = of_node_get(of_stdout);\n\tconst __be32 *termno;\n\tconst struct hv_ops *ops;\n\tu32 index;\n\n\t \n\tif (!stdout_node) {\n\t\tstruct device_node *opal, *np;\n\n\t\t \n\t\topal = of_find_node_by_path(\"/ibm,opal/consoles\");\n\t\tif (opal) {\n\t\t\tpr_devel(\"hvc_opal: Found consoles in new location\\n\");\n\t\t} else {\n\t\t\topal = of_find_node_by_path(\"/ibm,opal\");\n\t\t\tif (opal)\n\t\t\t\tpr_devel(\"hvc_opal: \"\n\t\t\t\t\t \"Found consoles in old location\\n\");\n\t\t}\n\t\tif (!opal)\n\t\t\treturn;\n\t\tfor_each_child_of_node(opal, np) {\n\t\t\tif (of_node_name_eq(np, \"serial\")) {\n\t\t\t\tstdout_node = np;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tof_node_put(opal);\n\t}\n\tif (!stdout_node)\n\t\treturn;\n\ttermno = of_get_property(stdout_node, \"reg\", NULL);\n\tindex = termno ? be32_to_cpup(termno) : 0;\n\tif (index >= MAX_NR_HVC_CONSOLES)\n\t\treturn;\n\thvc_opal_privs[index] = &hvc_opal_boot_priv;\n\n\t \n\tif (of_device_is_compatible(stdout_node, \"ibm,opal-console-raw\")) {\n\t\thvc_opal_boot_priv.proto = HV_PROTOCOL_RAW;\n\t\tops = &hvc_opal_raw_ops;\n\t\tpr_devel(\"hvc_opal: Found RAW console\\n\");\n\t}\n\telse if (of_device_is_compatible(stdout_node,\"ibm,opal-console-hvsi\")) {\n\t\thvc_opal_boot_priv.proto = HV_PROTOCOL_HVSI;\n\t\tops = &hvc_opal_hvsi_ops;\n\t\thvsilib_init(&hvc_opal_boot_priv.hvsi,\n\t\t\t     opal_get_chars, opal_put_chars_atomic,\n\t\t\t     index, 1);\n\t\t \n\t\thvsilib_establish(&hvc_opal_boot_priv.hvsi);\n\t\tpr_devel(\"hvc_opal: Found HVSI console\\n\");\n\t} else\n\t\tgoto out;\n\thvc_opal_boot_termno = index;\n\tudbg_init_opal_common();\n\tadd_preferred_console(\"hvc\", index, NULL);\n\thvc_instantiate(index, index, ops);\nout:\n\tof_node_put(stdout_node);\n}\n\n#ifdef CONFIG_PPC_EARLY_DEBUG_OPAL_RAW\nvoid __init udbg_init_debug_opal_raw(void)\n{\n\tu32 index = CONFIG_PPC_EARLY_DEBUG_OPAL_VTERMNO;\n\thvc_opal_privs[index] = &hvc_opal_boot_priv;\n\thvc_opal_boot_priv.proto = HV_PROTOCOL_RAW;\n\thvc_opal_boot_termno = index;\n\tudbg_init_opal_common();\n}\n#endif  \n\n#ifdef CONFIG_PPC_EARLY_DEBUG_OPAL_HVSI\nvoid __init udbg_init_debug_opal_hvsi(void)\n{\n\tu32 index = CONFIG_PPC_EARLY_DEBUG_OPAL_VTERMNO;\n\thvc_opal_privs[index] = &hvc_opal_boot_priv;\n\thvc_opal_boot_termno = index;\n\tudbg_init_opal_common();\n\thvsilib_init(&hvc_opal_boot_priv.hvsi,\n\t\t     opal_get_chars, opal_put_chars_atomic,\n\t\t     index, 1);\n\thvsilib_establish(&hvc_opal_boot_priv.hvsi);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}