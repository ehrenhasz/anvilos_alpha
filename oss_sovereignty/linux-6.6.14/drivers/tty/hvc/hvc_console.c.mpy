{
  "module_name": "hvc_console.c",
  "hash_id": "d0ec9b24ad4f81ccb54fa9ba2012afb287a8fe213a134aee433e711a841fa5a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/hvc/hvc_console.c",
  "human_readable_source": "\n \n\n#include <linux/console.h>\n#include <linux/cpumask.h>\n#include <linux/init.h>\n#include <linux/kbd_kern.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/list.h>\n#include <linux/major.h>\n#include <linux/atomic.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/serial_core.h>\n\n#include <linux/uaccess.h>\n\n#include \"hvc_console.h\"\n\n#define HVC_MAJOR\t229\n#define HVC_MINOR\t0\n\n \n#define HVC_CLOSE_WAIT (HZ/100)  \n\n \n#define N_OUTBUF\t16\n#define N_INBUF\t\t16\n\n#define __ALIGNED__ __attribute__((__aligned__(L1_CACHE_BYTES)))\n\nstatic struct tty_driver *hvc_driver;\nstatic struct task_struct *hvc_task;\n\n \nstatic int hvc_kicked;\n\n \nstatic atomic_t hvc_needs_init __read_mostly = ATOMIC_INIT(-1);\n\nstatic int hvc_init(void);\n\n#ifdef CONFIG_MAGIC_SYSRQ\nstatic int sysrq_pressed;\n#endif\n\n \nstatic LIST_HEAD(hvc_structs);\n\n \nstatic DEFINE_MUTEX(hvc_structs_mutex);\n\n \nstatic int last_hvc = -1;\n\n \nstatic struct hvc_struct *hvc_get_by_index(int index)\n{\n\tstruct hvc_struct *hp;\n\tunsigned long flags;\n\n\tmutex_lock(&hvc_structs_mutex);\n\n\tlist_for_each_entry(hp, &hvc_structs, next) {\n\t\tspin_lock_irqsave(&hp->lock, flags);\n\t\tif (hp->index == index) {\n\t\t\ttty_port_get(&hp->port);\n\t\t\tspin_unlock_irqrestore(&hp->lock, flags);\n\t\t\tmutex_unlock(&hvc_structs_mutex);\n\t\t\treturn hp;\n\t\t}\n\t\tspin_unlock_irqrestore(&hp->lock, flags);\n\t}\n\thp = NULL;\n\tmutex_unlock(&hvc_structs_mutex);\n\n\treturn hp;\n}\n\nstatic int __hvc_flush(const struct hv_ops *ops, uint32_t vtermno, bool wait)\n{\n\tif (wait)\n\t\tmight_sleep();\n\n\tif (ops->flush)\n\t\treturn ops->flush(vtermno, wait);\n\treturn 0;\n}\n\nstatic int hvc_console_flush(const struct hv_ops *ops, uint32_t vtermno)\n{\n\treturn __hvc_flush(ops, vtermno, false);\n}\n\n \nstatic int hvc_flush(struct hvc_struct *hp)\n{\n\treturn __hvc_flush(hp->ops, hp->vtermno, true);\n}\n\n \nstatic const struct hv_ops *cons_ops[MAX_NR_HVC_CONSOLES];\nstatic uint32_t vtermnos[MAX_NR_HVC_CONSOLES] =\n\t{[0 ... MAX_NR_HVC_CONSOLES - 1] = -1};\n\n \n\nstatic void hvc_console_print(struct console *co, const char *b,\n\t\t\t      unsigned count)\n{\n\tchar c[N_OUTBUF] __ALIGNED__;\n\tunsigned i = 0, n = 0;\n\tint r, donecr = 0, index = co->index;\n\n\t \n\tif (index >= MAX_NR_HVC_CONSOLES)\n\t\treturn;\n\n\t \n\tif (vtermnos[index] == -1)\n\t\treturn;\n\n\twhile (count > 0 || i > 0) {\n\t\tif (count > 0 && i < sizeof(c)) {\n\t\t\tif (b[n] == '\\n' && !donecr) {\n\t\t\t\tc[i++] = '\\r';\n\t\t\t\tdonecr = 1;\n\t\t\t} else {\n\t\t\t\tc[i++] = b[n++];\n\t\t\t\tdonecr = 0;\n\t\t\t\t--count;\n\t\t\t}\n\t\t} else {\n\t\t\tr = cons_ops[index]->put_chars(vtermnos[index], c, i);\n\t\t\tif (r <= 0) {\n\t\t\t\t \n\t\t\t\tif (r != -EAGAIN) {\n\t\t\t\t\ti = 0;\n\t\t\t\t} else {\n\t\t\t\t\thvc_console_flush(cons_ops[index],\n\t\t\t\t\t\t      vtermnos[index]);\n\t\t\t\t}\n\t\t\t} else if (r > 0) {\n\t\t\t\ti -= r;\n\t\t\t\tif (i > 0)\n\t\t\t\t\tmemmove(c, c+r, i);\n\t\t\t}\n\t\t}\n\t}\n\thvc_console_flush(cons_ops[index], vtermnos[index]);\n}\n\nstatic struct tty_driver *hvc_console_device(struct console *c, int *index)\n{\n\tif (vtermnos[c->index] == -1)\n\t\treturn NULL;\n\n\t*index = c->index;\n\treturn hvc_driver;\n}\n\nstatic int hvc_console_setup(struct console *co, char *options)\n{\t\n\tif (co->index < 0 || co->index >= MAX_NR_HVC_CONSOLES)\n\t\treturn -ENODEV;\n\n\tif (vtermnos[co->index] == -1)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct console hvc_console = {\n\t.name\t\t= \"hvc\",\n\t.write\t\t= hvc_console_print,\n\t.device\t\t= hvc_console_device,\n\t.setup\t\t= hvc_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n};\n\n \nstatic int __init hvc_console_init(void)\n{\n\tregister_console(&hvc_console);\n\treturn 0;\n}\nconsole_initcall(hvc_console_init);\n\n \nstatic void hvc_port_destruct(struct tty_port *port)\n{\n\tstruct hvc_struct *hp = container_of(port, struct hvc_struct, port);\n\tunsigned long flags;\n\n\tmutex_lock(&hvc_structs_mutex);\n\n\tspin_lock_irqsave(&hp->lock, flags);\n\tlist_del(&(hp->next));\n\tspin_unlock_irqrestore(&hp->lock, flags);\n\n\tmutex_unlock(&hvc_structs_mutex);\n\n\tkfree(hp);\n}\n\nstatic void hvc_check_console(int index)\n{\n\t \n\tif (console_is_registered(&hvc_console))\n\t\treturn;\n\n \t \n\tif (index == hvc_console.index)\n\t\tregister_console(&hvc_console);\n}\n\n \nint hvc_instantiate(uint32_t vtermno, int index, const struct hv_ops *ops)\n{\n\tstruct hvc_struct *hp;\n\n\tif (index < 0 || index >= MAX_NR_HVC_CONSOLES)\n\t\treturn -1;\n\n\tif (vtermnos[index] != -1)\n\t\treturn -1;\n\n\t \n\thp = hvc_get_by_index(index);\n\tif (hp) {\n\t\ttty_port_put(&hp->port);\n\t\treturn -1;\n\t}\n\n\tvtermnos[index] = vtermno;\n\tcons_ops[index] = ops;\n\n\t \n\thvc_check_console(index);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hvc_instantiate);\n\n \nvoid hvc_kick(void)\n{\n\thvc_kicked = 1;\n\twake_up_process(hvc_task);\n}\nEXPORT_SYMBOL_GPL(hvc_kick);\n\nstatic void hvc_unthrottle(struct tty_struct *tty)\n{\n\thvc_kick();\n}\n\nstatic int hvc_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct hvc_struct *hp;\n\tint rc;\n\n\t \n\thp = hvc_get_by_index(tty->index);\n\tif (!hp)\n\t\treturn -ENODEV;\n\n\ttty->driver_data = hp;\n\n\trc = tty_port_install(&hp->port, driver, tty);\n\tif (rc)\n\t\ttty_port_put(&hp->port);\n\treturn rc;\n}\n\n \nstatic int hvc_open(struct tty_struct *tty, struct file * filp)\n{\n\tstruct hvc_struct *hp = tty->driver_data;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&hp->port.lock, flags);\n\t \n\tif (hp->port.count++ > 0) {\n\t\tspin_unlock_irqrestore(&hp->port.lock, flags);\n\t\thvc_kick();\n\t\treturn 0;\n\t}  \n\tspin_unlock_irqrestore(&hp->port.lock, flags);\n\n\ttty_port_tty_set(&hp->port, tty);\n\n\tif (hp->ops->notifier_add)\n\t\trc = hp->ops->notifier_add(hp, hp->data);\n\n\t \n\tif (rc) {\n\t\tprintk(KERN_ERR \"hvc_open: request_irq failed with rc %d.\\n\", rc);\n\t} else {\n\t\t \n\t\tif (C_BAUD(tty))\n\t\t\tif (hp->ops->dtr_rts)\n\t\t\t\thp->ops->dtr_rts(hp, true);\n\t\ttty_port_set_initialized(&hp->port, true);\n\t}\n\n\t \n\thvc_kick();\n\n\treturn rc;\n}\n\nstatic void hvc_close(struct tty_struct *tty, struct file * filp)\n{\n\tstruct hvc_struct *hp = tty->driver_data;\n\tunsigned long flags;\n\n\tif (tty_hung_up_p(filp))\n\t\treturn;\n\n\tspin_lock_irqsave(&hp->port.lock, flags);\n\n\tif (--hp->port.count == 0) {\n\t\tspin_unlock_irqrestore(&hp->port.lock, flags);\n\t\t \n\t\ttty_port_tty_set(&hp->port, NULL);\n\n\t\tif (!tty_port_initialized(&hp->port))\n\t\t\treturn;\n\n\t\tif (C_HUPCL(tty))\n\t\t\tif (hp->ops->dtr_rts)\n\t\t\t\thp->ops->dtr_rts(hp, false);\n\n\t\tif (hp->ops->notifier_del)\n\t\t\thp->ops->notifier_del(hp, hp->data);\n\n\t\t \n\t\tcancel_work_sync(&hp->tty_resize);\n\n\t\t \n\t\ttty_wait_until_sent(tty, HVC_CLOSE_WAIT);\n\t\ttty_port_set_initialized(&hp->port, false);\n\t} else {\n\t\tif (hp->port.count < 0)\n\t\t\tprintk(KERN_ERR \"hvc_close %X: oops, count is %d\\n\",\n\t\t\t\thp->vtermno, hp->port.count);\n\t\tspin_unlock_irqrestore(&hp->port.lock, flags);\n\t}\n}\n\nstatic void hvc_cleanup(struct tty_struct *tty)\n{\n\tstruct hvc_struct *hp = tty->driver_data;\n\n\ttty_port_put(&hp->port);\n}\n\nstatic void hvc_hangup(struct tty_struct *tty)\n{\n\tstruct hvc_struct *hp = tty->driver_data;\n\tunsigned long flags;\n\n\tif (!hp)\n\t\treturn;\n\n\t \n\tcancel_work_sync(&hp->tty_resize);\n\n\tspin_lock_irqsave(&hp->port.lock, flags);\n\n\t \n\tif (hp->port.count <= 0) {\n\t\tspin_unlock_irqrestore(&hp->port.lock, flags);\n\t\treturn;\n\t}\n\n\thp->port.count = 0;\n\tspin_unlock_irqrestore(&hp->port.lock, flags);\n\ttty_port_tty_set(&hp->port, NULL);\n\n\thp->n_outbuf = 0;\n\n\tif (hp->ops->notifier_hangup)\n\t\thp->ops->notifier_hangup(hp, hp->data);\n}\n\n \nstatic int hvc_push(struct hvc_struct *hp)\n{\n\tint n;\n\n\tn = hp->ops->put_chars(hp->vtermno, hp->outbuf, hp->n_outbuf);\n\tif (n <= 0) {\n\t\tif (n == 0 || n == -EAGAIN) {\n\t\t\thp->do_wakeup = 1;\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\thp->n_outbuf = 0;\n\t} else\n\t\thp->n_outbuf -= n;\n\tif (hp->n_outbuf > 0)\n\t\tmemmove(hp->outbuf, hp->outbuf + n, hp->n_outbuf);\n\telse\n\t\thp->do_wakeup = 1;\n\n\treturn n;\n}\n\nstatic ssize_t hvc_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tstruct hvc_struct *hp = tty->driver_data;\n\tunsigned long flags;\n\tsize_t rsize, written = 0;\n\n\t \n\tif (!hp)\n\t\treturn -EPIPE;\n\n\t \n\tif (hp->port.count <= 0)\n\t\treturn -EIO;\n\n\twhile (count > 0) {\n\t\tint ret = 0;\n\n\t\tspin_lock_irqsave(&hp->lock, flags);\n\n\t\trsize = hp->outbuf_size - hp->n_outbuf;\n\n\t\tif (rsize) {\n\t\t\tif (rsize > count)\n\t\t\t\trsize = count;\n\t\t\tmemcpy(hp->outbuf + hp->n_outbuf, buf, rsize);\n\t\t\tcount -= rsize;\n\t\t\tbuf += rsize;\n\t\t\thp->n_outbuf += rsize;\n\t\t\twritten += rsize;\n\t\t}\n\n\t\tif (hp->n_outbuf > 0)\n\t\t\tret = hvc_push(hp);\n\n\t\tspin_unlock_irqrestore(&hp->lock, flags);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tif (count) {\n\t\t\tif (hp->n_outbuf > 0)\n\t\t\t\thvc_flush(hp);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\t \n\tif (hp->n_outbuf)\n\t\thvc_kick();\n\n\treturn written;\n}\n\n \nstatic void hvc_set_winsz(struct work_struct *work)\n{\n\tstruct hvc_struct *hp;\n\tunsigned long hvc_flags;\n\tstruct tty_struct *tty;\n\tstruct winsize ws;\n\n\thp = container_of(work, struct hvc_struct, tty_resize);\n\n\ttty = tty_port_tty_get(&hp->port);\n\tif (!tty)\n\t\treturn;\n\n\tspin_lock_irqsave(&hp->lock, hvc_flags);\n\tws = hp->ws;\n\tspin_unlock_irqrestore(&hp->lock, hvc_flags);\n\n\ttty_do_resize(tty, &ws);\n\ttty_kref_put(tty);\n}\n\n \nstatic unsigned int hvc_write_room(struct tty_struct *tty)\n{\n\tstruct hvc_struct *hp = tty->driver_data;\n\n\tif (!hp)\n\t\treturn 0;\n\n\treturn hp->outbuf_size - hp->n_outbuf;\n}\n\nstatic unsigned int hvc_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct hvc_struct *hp = tty->driver_data;\n\n\tif (!hp)\n\t\treturn 0;\n\treturn hp->n_outbuf;\n}\n\n \n#define MIN_TIMEOUT\t\t(10)\n#define MAX_TIMEOUT\t\t(2000)\nstatic u32 timeout = MIN_TIMEOUT;\n\n \n#define HVC_ATOMIC_READ_MAX\t128\n\n#define HVC_POLL_READ\t0x00000001\n#define HVC_POLL_WRITE\t0x00000002\n\nstatic int __hvc_poll(struct hvc_struct *hp, bool may_sleep)\n{\n\tstruct tty_struct *tty;\n\tint i, n, count, poll_mask = 0;\n\tchar buf[N_INBUF] __ALIGNED__;\n\tunsigned long flags;\n\tint read_total = 0;\n\tint written_total = 0;\n\n\tspin_lock_irqsave(&hp->lock, flags);\n\n\t \n\tif (hp->n_outbuf > 0)\n\t\twritten_total = hvc_push(hp);\n\n\t \n\tif (hp->n_outbuf > 0) {\n\t\tpoll_mask |= HVC_POLL_WRITE;\n\t\t \n\t\ttimeout = (written_total) ? 0 : MIN_TIMEOUT;\n\t}\n\n\tif (may_sleep) {\n\t\tspin_unlock_irqrestore(&hp->lock, flags);\n\t\tcond_resched();\n\t\tspin_lock_irqsave(&hp->lock, flags);\n\t}\n\n\t \n\ttty = tty_port_tty_get(&hp->port);\n\tif (tty == NULL)\n\t\tgoto bail;\n\n\t \n\tif (tty_throttled(tty))\n\t\tgoto out;\n\n\t \n\tif (!hp->irq_requested)\n\t\tpoll_mask |= HVC_POLL_READ;\n\n read_again:\n\t \n\tcount = tty_buffer_request_room(&hp->port, N_INBUF);\n\n\t \n\tif (count == 0) {\n\t\tpoll_mask |= HVC_POLL_READ;\n\t\tgoto out;\n\t}\n\n\tn = hp->ops->get_chars(hp->vtermno, buf, count);\n\tif (n <= 0) {\n\t\t \n\t\tif (n == -EPIPE) {\n\t\t\tspin_unlock_irqrestore(&hp->lock, flags);\n\t\t\ttty_hangup(tty);\n\t\t\tspin_lock_irqsave(&hp->lock, flags);\n\t\t} else if ( n == -EAGAIN ) {\n\t\t\t \n\t\t\tpoll_mask |= HVC_POLL_READ;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n; ++i) {\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tif (hp->index == hvc_console.index) {\n\t\t\t \n\t\t\t \n\t\t\tif (buf[i] == '\\x0f') {\t \n\t\t\t\t \n\t\t\t\tsysrq_pressed = !sysrq_pressed;\n\t\t\t\tif (sysrq_pressed)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (sysrq_pressed) {\n\t\t\t\thandle_sysrq(buf[i]);\n\t\t\t\tsysrq_pressed = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif  \n\t\ttty_insert_flip_char(&hp->port, buf[i], 0);\n\t}\n\tread_total += n;\n\n\tif (may_sleep) {\n\t\t \n\t\tspin_unlock_irqrestore(&hp->lock, flags);\n\t\tcond_resched();\n\t\tspin_lock_irqsave(&hp->lock, flags);\n\t\tgoto read_again;\n\t} else if (read_total < HVC_ATOMIC_READ_MAX) {\n\t\t \n\t\tgoto read_again;\n\t}\n\n\t \n\tpoll_mask |= HVC_POLL_READ;\n\n out:\n\t \n\tif (hp->do_wakeup) {\n\t\thp->do_wakeup = 0;\n\t\ttty_wakeup(tty);\n\t}\n bail:\n\tspin_unlock_irqrestore(&hp->lock, flags);\n\n\tif (read_total) {\n\t\t \n\t\ttimeout = MIN_TIMEOUT;\n\n\t\ttty_flip_buffer_push(&hp->port);\n\t}\n\ttty_kref_put(tty);\n\n\treturn poll_mask;\n}\n\nint hvc_poll(struct hvc_struct *hp)\n{\n\treturn __hvc_poll(hp, false);\n}\nEXPORT_SYMBOL_GPL(hvc_poll);\n\n \nvoid __hvc_resize(struct hvc_struct *hp, struct winsize ws)\n{\n\thp->ws = ws;\n\tschedule_work(&hp->tty_resize);\n}\nEXPORT_SYMBOL_GPL(__hvc_resize);\n\n \nstatic int khvcd(void *unused)\n{\n\tint poll_mask;\n\tstruct hvc_struct *hp;\n\n\tset_freezable();\n\tdo {\n\t\tpoll_mask = 0;\n\t\thvc_kicked = 0;\n\t\ttry_to_freeze();\n\t\twmb();\n\t\tif (!cpus_are_in_xmon()) {\n\t\t\tmutex_lock(&hvc_structs_mutex);\n\t\t\tlist_for_each_entry(hp, &hvc_structs, next) {\n\t\t\t\tpoll_mask |= __hvc_poll(hp, true);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tmutex_unlock(&hvc_structs_mutex);\n\t\t} else\n\t\t\tpoll_mask |= HVC_POLL_READ;\n\t\tif (hvc_kicked)\n\t\t\tcontinue;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!hvc_kicked) {\n\t\t\tif (poll_mask == 0)\n\t\t\t\tschedule();\n\t\t\telse {\n\t\t\t\tunsigned long j_timeout;\n\n\t\t\t\tif (timeout < MAX_TIMEOUT)\n\t\t\t\t\ttimeout += (timeout >> 6) + 1;\n\n\t\t\t\t \n\t\t\t\tj_timeout = msecs_to_jiffies(timeout) + 1;\n\t\t\t\tschedule_timeout_interruptible(j_timeout);\n\t\t\t}\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t} while (!kthread_should_stop());\n\n\treturn 0;\n}\n\nstatic int hvc_tiocmget(struct tty_struct *tty)\n{\n\tstruct hvc_struct *hp = tty->driver_data;\n\n\tif (!hp || !hp->ops->tiocmget)\n\t\treturn -EINVAL;\n\treturn hp->ops->tiocmget(hp);\n}\n\nstatic int hvc_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct hvc_struct *hp = tty->driver_data;\n\n\tif (!hp || !hp->ops->tiocmset)\n\t\treturn -EINVAL;\n\treturn hp->ops->tiocmset(hp, set, clear);\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int hvc_poll_init(struct tty_driver *driver, int line, char *options)\n{\n\treturn 0;\n}\n\nstatic int hvc_poll_get_char(struct tty_driver *driver, int line)\n{\n\tstruct tty_struct *tty = driver->ttys[0];\n\tstruct hvc_struct *hp = tty->driver_data;\n\tint n;\n\tchar ch;\n\n\tn = hp->ops->get_chars(hp->vtermno, &ch, 1);\n\n\tif (n <= 0)\n\t\treturn NO_POLL_CHAR;\n\n\treturn ch;\n}\n\nstatic void hvc_poll_put_char(struct tty_driver *driver, int line, char ch)\n{\n\tstruct tty_struct *tty = driver->ttys[0];\n\tstruct hvc_struct *hp = tty->driver_data;\n\tint n;\n\n\tdo {\n\t\tn = hp->ops->put_chars(hp->vtermno, &ch, 1);\n\t} while (n <= 0);\n}\n#endif\n\nstatic const struct tty_operations hvc_ops = {\n\t.install = hvc_install,\n\t.open = hvc_open,\n\t.close = hvc_close,\n\t.cleanup = hvc_cleanup,\n\t.write = hvc_write,\n\t.hangup = hvc_hangup,\n\t.unthrottle = hvc_unthrottle,\n\t.write_room = hvc_write_room,\n\t.chars_in_buffer = hvc_chars_in_buffer,\n\t.tiocmget = hvc_tiocmget,\n\t.tiocmset = hvc_tiocmset,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_init = hvc_poll_init,\n\t.poll_get_char = hvc_poll_get_char,\n\t.poll_put_char = hvc_poll_put_char,\n#endif\n};\n\nstatic const struct tty_port_operations hvc_port_ops = {\n\t.destruct = hvc_port_destruct,\n};\n\nstruct hvc_struct *hvc_alloc(uint32_t vtermno, int data,\n\t\t\t     const struct hv_ops *ops,\n\t\t\t     int outbuf_size)\n{\n\tstruct hvc_struct *hp;\n\tint i;\n\n\t \n\tif (atomic_inc_not_zero(&hvc_needs_init)) {\n\t\tint err = hvc_init();\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\thp = kzalloc(ALIGN(sizeof(*hp), sizeof(long)) + outbuf_size,\n\t\t\tGFP_KERNEL);\n\tif (!hp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thp->vtermno = vtermno;\n\thp->data = data;\n\thp->ops = ops;\n\thp->outbuf_size = outbuf_size;\n\thp->outbuf = &((char *)hp)[ALIGN(sizeof(*hp), sizeof(long))];\n\n\ttty_port_init(&hp->port);\n\thp->port.ops = &hvc_port_ops;\n\n\tINIT_WORK(&hp->tty_resize, hvc_set_winsz);\n\tspin_lock_init(&hp->lock);\n\tmutex_lock(&hvc_structs_mutex);\n\n\t \n\tfor (i=0; i < MAX_NR_HVC_CONSOLES; i++)\n\t\tif (vtermnos[i] == hp->vtermno &&\n\t\t    cons_ops[i] == hp->ops)\n\t\t\tbreak;\n\n\tif (i >= MAX_NR_HVC_CONSOLES) {\n\n\t\t \n\t\tfor (i = 0; i < MAX_NR_HVC_CONSOLES && vtermnos[i] != -1; i++) {\n\t\t}\n\n\t\t \n\t\tif (i == MAX_NR_HVC_CONSOLES)\n\t\t\ti = ++last_hvc + MAX_NR_HVC_CONSOLES;\n\t}\n\n\thp->index = i;\n\tif (i < MAX_NR_HVC_CONSOLES) {\n\t\tcons_ops[i] = ops;\n\t\tvtermnos[i] = vtermno;\n\t}\n\n\tlist_add_tail(&(hp->next), &hvc_structs);\n\tmutex_unlock(&hvc_structs_mutex);\n\n\t \n\thvc_check_console(i);\n\n\treturn hp;\n}\nEXPORT_SYMBOL_GPL(hvc_alloc);\n\nint hvc_remove(struct hvc_struct *hp)\n{\n\tunsigned long flags;\n\tstruct tty_struct *tty;\n\n\ttty = tty_port_tty_get(&hp->port);\n\n\tconsole_lock();\n\tspin_lock_irqsave(&hp->lock, flags);\n\tif (hp->index < MAX_NR_HVC_CONSOLES) {\n\t\tvtermnos[hp->index] = -1;\n\t\tcons_ops[hp->index] = NULL;\n\t}\n\n\t \n\n\tspin_unlock_irqrestore(&hp->lock, flags);\n\tconsole_unlock();\n\n\t \n\ttty_port_put(&hp->port);\n\n\t \n\tif (tty) {\n\t\ttty_vhangup(tty);\n\t\ttty_kref_put(tty);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hvc_remove);\n\n \nstatic int hvc_init(void)\n{\n\tstruct tty_driver *drv;\n\tint err;\n\n\t \n\tdrv = tty_alloc_driver(HVC_ALLOC_TTY_ADAPTERS, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_RESET_TERMIOS);\n\tif (IS_ERR(drv)) {\n\t\terr = PTR_ERR(drv);\n\t\tgoto out;\n\t}\n\n\tdrv->driver_name = \"hvc\";\n\tdrv->name = \"hvc\";\n\tdrv->major = HVC_MAJOR;\n\tdrv->minor_start = HVC_MINOR;\n\tdrv->type = TTY_DRIVER_TYPE_SYSTEM;\n\tdrv->init_termios = tty_std_termios;\n\ttty_set_operations(drv, &hvc_ops);\n\n\t \n\thvc_task = kthread_run(khvcd, NULL, \"khvcd\");\n\tif (IS_ERR(hvc_task)) {\n\t\tprintk(KERN_ERR \"Couldn't create kthread for console.\\n\");\n\t\terr = PTR_ERR(hvc_task);\n\t\tgoto put_tty;\n\t}\n\n\terr = tty_register_driver(drv);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Couldn't register hvc console driver\\n\");\n\t\tgoto stop_thread;\n\t}\n\n\t \n\tsmp_mb();\n\thvc_driver = drv;\n\treturn 0;\n\nstop_thread:\n\tkthread_stop(hvc_task);\n\thvc_task = NULL;\nput_tty:\n\ttty_driver_kref_put(drv);\nout:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}