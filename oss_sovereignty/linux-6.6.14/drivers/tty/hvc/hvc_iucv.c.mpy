{
  "module_name": "hvc_iucv.c",
  "hash_id": "8f735e702a6d7b90e1ec5c2d87d16c391b7da976a99ca6a64b98d75d748aebc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/hvc/hvc_iucv.c",
  "human_readable_source": "\n \n#define KMSG_COMPONENT\t\t\"hvc_iucv\"\n#define pr_fmt(fmt)\t\tKMSG_COMPONENT \": \" fmt\n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <asm/ebcdic.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/mempool.h>\n#include <linux/moduleparam.h>\n#include <linux/tty.h>\n#include <linux/wait.h>\n#include <net/iucv/iucv.h>\n\n#include \"hvc_console.h\"\n\n\n \n#define MAX_HVC_IUCV_LINES\tHVC_ALLOC_TTY_ADAPTERS\n#define MEMPOOL_MIN_NR\t\t(PAGE_SIZE / sizeof(struct iucv_tty_buffer)/4)\n\n \n#define MSG_VERSION\t\t0x02\t \n#define MSG_TYPE_ERROR\t\t0x01\t \n#define MSG_TYPE_TERMENV\t0x02\t \n#define MSG_TYPE_TERMIOS\t0x04\t \n#define MSG_TYPE_WINSIZE\t0x08\t \n#define MSG_TYPE_DATA\t\t0x10\t \n\nstruct iucv_tty_msg {\n\tu8\tversion;\t\t \n\tu8\ttype;\t\t\t \n#define MSG_MAX_DATALEN\t\t((u16)(~0))\n\tu16\tdatalen;\t\t \n\tu8\tdata[];\t\t\t \n} __attribute__((packed));\n#define MSG_SIZE(s)\t\t((s) + offsetof(struct iucv_tty_msg, data))\n\nenum iucv_state_t {\n\tIUCV_DISCONN\t= 0,\n\tIUCV_CONNECTED\t= 1,\n\tIUCV_SEVERED\t= 2,\n};\n\nenum tty_state_t {\n\tTTY_CLOSED\t= 0,\n\tTTY_OPENED\t= 1,\n};\n\nstruct hvc_iucv_private {\n\tstruct hvc_struct\t*hvc;\t\t \n\tu8\t\t\tsrv_name[8];\t \n\tunsigned char\t\tis_console;\t \n\tenum iucv_state_t\tiucv_state;\t \n\tenum tty_state_t\ttty_state;\t \n\tstruct iucv_path\t*path;\t\t \n\tspinlock_t\t\tlock;\t\t \n#define SNDBUF_SIZE\t\t(PAGE_SIZE)\t \n\tvoid\t\t\t*sndbuf;\t \n\tsize_t\t\t\tsndbuf_len;\t \n#define QUEUE_SNDBUF_DELAY\t(HZ / 25)\n\tstruct delayed_work\tsndbuf_work;\t \n\twait_queue_head_t\tsndbuf_waitq;\t \n\tstruct list_head\ttty_outqueue;\t \n\tstruct list_head\ttty_inqueue;\t \n\tstruct device\t\t*dev;\t\t \n\tu8\t\t\tinfo_path[16];\t \n};\n\nstruct iucv_tty_buffer {\n\tstruct list_head\tlist;\t \n\tstruct iucv_message\tmsg;\t \n\tsize_t\t\t\toffset;\t \n\tstruct iucv_tty_msg\t*mbuf;\t \n};\n\n \nstatic\tint hvc_iucv_path_pending(struct iucv_path *, u8 *, u8 *);\nstatic void hvc_iucv_path_severed(struct iucv_path *, u8 *);\nstatic void hvc_iucv_msg_pending(struct iucv_path *, struct iucv_message *);\nstatic void hvc_iucv_msg_complete(struct iucv_path *, struct iucv_message *);\n\n\n \nstatic unsigned long hvc_iucv_devices = 1;\n\n \nstatic struct hvc_iucv_private *hvc_iucv_table[MAX_HVC_IUCV_LINES];\n#define IUCV_HVC_CON_IDX\t(0)\n \n#define MAX_VMID_FILTER\t\t(500)\n#define FILTER_WILDCARD_CHAR\t'*'\nstatic size_t hvc_iucv_filter_size;\nstatic void *hvc_iucv_filter;\nstatic const char *hvc_iucv_filter_string;\nstatic DEFINE_RWLOCK(hvc_iucv_filter_lock);\n\n \nstatic struct kmem_cache *hvc_iucv_buffer_cache;\nstatic mempool_t *hvc_iucv_mempool;\n\n \nstatic struct iucv_handler hvc_iucv_handler = {\n\t.path_pending  = hvc_iucv_path_pending,\n\t.path_severed  = hvc_iucv_path_severed,\n\t.message_complete = hvc_iucv_msg_complete,\n\t.message_pending  = hvc_iucv_msg_pending,\n};\n\n\n \nstatic struct hvc_iucv_private *hvc_iucv_get_private(uint32_t num)\n{\n\tif (num > hvc_iucv_devices)\n\t\treturn NULL;\n\treturn hvc_iucv_table[num];\n}\n\n \nstatic struct iucv_tty_buffer *alloc_tty_buffer(size_t size, gfp_t flags)\n{\n\tstruct iucv_tty_buffer *bufp;\n\n\tbufp = mempool_alloc(hvc_iucv_mempool, flags);\n\tif (!bufp)\n\t\treturn NULL;\n\tmemset(bufp, 0, sizeof(*bufp));\n\n\tif (size > 0) {\n\t\tbufp->msg.length = MSG_SIZE(size);\n\t\tbufp->mbuf = kmalloc(bufp->msg.length, flags | GFP_DMA);\n\t\tif (!bufp->mbuf) {\n\t\t\tmempool_free(bufp, hvc_iucv_mempool);\n\t\t\treturn NULL;\n\t\t}\n\t\tbufp->mbuf->version = MSG_VERSION;\n\t\tbufp->mbuf->type    = MSG_TYPE_DATA;\n\t\tbufp->mbuf->datalen = (u16) size;\n\t}\n\treturn bufp;\n}\n\n \nstatic void destroy_tty_buffer(struct iucv_tty_buffer *bufp)\n{\n\tkfree(bufp->mbuf);\n\tmempool_free(bufp, hvc_iucv_mempool);\n}\n\n \nstatic void destroy_tty_buffer_list(struct list_head *list)\n{\n\tstruct iucv_tty_buffer *ent, *next;\n\n\tlist_for_each_entry_safe(ent, next, list, list) {\n\t\tlist_del(&ent->list);\n\t\tdestroy_tty_buffer(ent);\n\t}\n}\n\n \nstatic int hvc_iucv_write(struct hvc_iucv_private *priv,\n\t\t\t  char *buf, int count, int *has_more_data)\n{\n\tstruct iucv_tty_buffer *rb;\n\tint written;\n\tint rc;\n\n\t \n\tif (priv->iucv_state == IUCV_DISCONN)\n\t\treturn 0;\n\n\t \n\tif (priv->iucv_state == IUCV_SEVERED)\n\t\treturn -EPIPE;\n\n\t \n\tif (list_empty(&priv->tty_inqueue))\n\t\treturn 0;\n\n\t \n\trb = list_first_entry(&priv->tty_inqueue, struct iucv_tty_buffer, list);\n\n\twritten = 0;\n\tif (!rb->mbuf) {  \n\t\t \n\t\trb->mbuf = kmalloc(rb->msg.length, GFP_ATOMIC | GFP_DMA);\n\t\tif (!rb->mbuf)\n\t\t\treturn -ENOMEM;\n\n\t\trc = __iucv_message_receive(priv->path, &rb->msg, 0,\n\t\t\t\t\t    rb->mbuf, rb->msg.length, NULL);\n\t\tswitch (rc) {\n\t\tcase 0:  \n\t\t\tbreak;\n\t\tcase 2:\t \n\t\tcase 9:  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\twritten = -EIO;\n\t\t}\n\t\t \n\t\tif (rc || (rb->mbuf->version != MSG_VERSION) ||\n\t\t\t  (rb->msg.length    != MSG_SIZE(rb->mbuf->datalen)))\n\t\t\tgoto out_remove_buffer;\n\t}\n\n\tswitch (rb->mbuf->type) {\n\tcase MSG_TYPE_DATA:\n\t\twritten = min_t(int, rb->mbuf->datalen - rb->offset, count);\n\t\tmemcpy(buf, rb->mbuf->data + rb->offset, written);\n\t\tif (written < (rb->mbuf->datalen - rb->offset)) {\n\t\t\trb->offset += written;\n\t\t\t*has_more_data = 1;\n\t\t\tgoto out_written;\n\t\t}\n\t\tbreak;\n\n\tcase MSG_TYPE_WINSIZE:\n\t\tif (rb->mbuf->datalen != sizeof(struct winsize))\n\t\t\tbreak;\n\t\t \n\t\t__hvc_resize(priv->hvc, *((struct winsize *) rb->mbuf->data));\n\t\tbreak;\n\n\tcase MSG_TYPE_ERROR:\t \n\tcase MSG_TYPE_TERMENV:\t \n\tcase MSG_TYPE_TERMIOS:\t \n\t\tbreak;\n\t}\n\nout_remove_buffer:\n\tlist_del(&rb->list);\n\tdestroy_tty_buffer(rb);\n\t*has_more_data = !list_empty(&priv->tty_inqueue);\n\nout_written:\n\treturn written;\n}\n\n \nstatic int hvc_iucv_get_chars(uint32_t vtermno, char *buf, int count)\n{\n\tstruct hvc_iucv_private *priv = hvc_iucv_get_private(vtermno);\n\tint written;\n\tint has_more_data;\n\n\tif (count <= 0)\n\t\treturn 0;\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tspin_lock(&priv->lock);\n\thas_more_data = 0;\n\twritten = hvc_iucv_write(priv, buf, count, &has_more_data);\n\tspin_unlock(&priv->lock);\n\n\t \n\tif (has_more_data)\n\t\thvc_kick();\n\n\treturn written;\n}\n\n \nstatic int hvc_iucv_queue(struct hvc_iucv_private *priv, const char *buf,\n\t\t\t  int count)\n{\n\tsize_t len;\n\n\tif (priv->iucv_state == IUCV_DISCONN)\n\t\treturn count;\t\t\t \n\n\tif (priv->iucv_state == IUCV_SEVERED)\n\t\treturn -EPIPE;\n\n\tlen = min_t(size_t, count, SNDBUF_SIZE - priv->sndbuf_len);\n\tif (!len)\n\t\treturn 0;\n\n\tmemcpy(priv->sndbuf + priv->sndbuf_len, buf, len);\n\tpriv->sndbuf_len += len;\n\n\tif (priv->iucv_state == IUCV_CONNECTED)\n\t\tschedule_delayed_work(&priv->sndbuf_work, QUEUE_SNDBUF_DELAY);\n\n\treturn len;\n}\n\n \nstatic int hvc_iucv_send(struct hvc_iucv_private *priv)\n{\n\tstruct iucv_tty_buffer *sb;\n\tint rc, len;\n\n\tif (priv->iucv_state == IUCV_SEVERED)\n\t\treturn -EPIPE;\n\n\tif (priv->iucv_state == IUCV_DISCONN)\n\t\treturn -EIO;\n\n\tif (!priv->sndbuf_len)\n\t\treturn 0;\n\n\t \n\tsb = alloc_tty_buffer(priv->sndbuf_len, GFP_ATOMIC);\n\tif (!sb)\n\t\treturn -ENOMEM;\n\n\tmemcpy(sb->mbuf->data, priv->sndbuf, priv->sndbuf_len);\n\tsb->mbuf->datalen = (u16) priv->sndbuf_len;\n\tsb->msg.length = MSG_SIZE(sb->mbuf->datalen);\n\n\tlist_add_tail(&sb->list, &priv->tty_outqueue);\n\n\trc = __iucv_message_send(priv->path, &sb->msg, 0, 0,\n\t\t\t\t (void *) sb->mbuf, sb->msg.length);\n\tif (rc) {\n\t\t \n\t\tlist_del(&sb->list);\n\t\tdestroy_tty_buffer(sb);\n\t}\n\tlen = priv->sndbuf_len;\n\tpriv->sndbuf_len = 0;\n\n\treturn len;\n}\n\n \nstatic void hvc_iucv_sndbuf_work(struct work_struct *work)\n{\n\tstruct hvc_iucv_private *priv;\n\n\tpriv = container_of(work, struct hvc_iucv_private, sndbuf_work.work);\n\n\tspin_lock_bh(&priv->lock);\n\thvc_iucv_send(priv);\n\tspin_unlock_bh(&priv->lock);\n}\n\n \nstatic int hvc_iucv_put_chars(uint32_t vtermno, const char *buf, int count)\n{\n\tstruct hvc_iucv_private *priv = hvc_iucv_get_private(vtermno);\n\tint queued;\n\n\tif (count <= 0)\n\t\treturn 0;\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tspin_lock(&priv->lock);\n\tqueued = hvc_iucv_queue(priv, buf, count);\n\tspin_unlock(&priv->lock);\n\n\treturn queued;\n}\n\n \nstatic int hvc_iucv_notifier_add(struct hvc_struct *hp, int id)\n{\n\tstruct hvc_iucv_private *priv;\n\n\tpriv = hvc_iucv_get_private(id);\n\tif (!priv)\n\t\treturn 0;\n\n\tspin_lock_bh(&priv->lock);\n\tpriv->tty_state = TTY_OPENED;\n\tspin_unlock_bh(&priv->lock);\n\n\treturn 0;\n}\n\n \nstatic void hvc_iucv_cleanup(struct hvc_iucv_private *priv)\n{\n\tdestroy_tty_buffer_list(&priv->tty_outqueue);\n\tdestroy_tty_buffer_list(&priv->tty_inqueue);\n\n\tpriv->tty_state = TTY_CLOSED;\n\tpriv->iucv_state = IUCV_DISCONN;\n\n\tpriv->sndbuf_len = 0;\n}\n\n \nstatic inline int tty_outqueue_empty(struct hvc_iucv_private *priv)\n{\n\tint rc;\n\n\tspin_lock_bh(&priv->lock);\n\trc = list_empty(&priv->tty_outqueue);\n\tspin_unlock_bh(&priv->lock);\n\n\treturn rc;\n}\n\n \nstatic void flush_sndbuf_sync(struct hvc_iucv_private *priv)\n{\n\tint sync_wait;\n\n\tcancel_delayed_work_sync(&priv->sndbuf_work);\n\n\tspin_lock_bh(&priv->lock);\n\thvc_iucv_send(priv);\t\t \n\tsync_wait = !list_empty(&priv->tty_outqueue);  \n\tspin_unlock_bh(&priv->lock);\n\n\tif (sync_wait)\n\t\twait_event_timeout(priv->sndbuf_waitq,\n\t\t\t\t   tty_outqueue_empty(priv), HZ/10);\n}\n\n \nstatic void hvc_iucv_hangup(struct hvc_iucv_private *priv)\n{\n\tstruct iucv_path *path;\n\n\tpath = NULL;\n\tspin_lock(&priv->lock);\n\tif (priv->iucv_state == IUCV_CONNECTED) {\n\t\tpath = priv->path;\n\t\tpriv->path = NULL;\n\t\tpriv->iucv_state = IUCV_SEVERED;\n\t\tif (priv->tty_state == TTY_CLOSED)\n\t\t\thvc_iucv_cleanup(priv);\n\t\telse\n\t\t\t \n\t\t\tif (priv->is_console) {\n\t\t\t\thvc_iucv_cleanup(priv);\n\t\t\t\tpriv->tty_state = TTY_OPENED;\n\t\t\t} else\n\t\t\t\thvc_kick();\n\t}\n\tspin_unlock(&priv->lock);\n\n\t \n\tif (path) {\n\t\tiucv_path_sever(path, NULL);\n\t\tiucv_path_free(path);\n\t}\n}\n\n \nstatic void hvc_iucv_notifier_hangup(struct hvc_struct *hp, int id)\n{\n\tstruct hvc_iucv_private *priv;\n\n\tpriv = hvc_iucv_get_private(id);\n\tif (!priv)\n\t\treturn;\n\n\tflush_sndbuf_sync(priv);\n\n\tspin_lock_bh(&priv->lock);\n\t \n\tpriv->tty_state = TTY_CLOSED;\n\n\tif (priv->iucv_state == IUCV_SEVERED)\n\t\thvc_iucv_cleanup(priv);\n\tspin_unlock_bh(&priv->lock);\n}\n\n \nstatic void hvc_iucv_dtr_rts(struct hvc_struct *hp, bool active)\n{\n\tstruct hvc_iucv_private *priv;\n\tstruct iucv_path        *path;\n\n\t \n\tif (active)\n\t\treturn;\n\n\tpriv = hvc_iucv_get_private(hp->vtermno);\n\tif (!priv)\n\t\treturn;\n\n\t \n\tflush_sndbuf_sync(priv);\n\n\tspin_lock_bh(&priv->lock);\n\tpath = priv->path;\t\t \n\tpriv->path = NULL;\n\tpriv->iucv_state = IUCV_DISCONN;\n\tspin_unlock_bh(&priv->lock);\n\n\t \n\tif (path) {\n\t\tiucv_path_sever(path, NULL);\n\t\tiucv_path_free(path);\n\t}\n}\n\n \nstatic void hvc_iucv_notifier_del(struct hvc_struct *hp, int id)\n{\n\tstruct hvc_iucv_private *priv;\n\n\tpriv = hvc_iucv_get_private(id);\n\tif (!priv)\n\t\treturn;\n\n\tflush_sndbuf_sync(priv);\n\n\tspin_lock_bh(&priv->lock);\n\tdestroy_tty_buffer_list(&priv->tty_outqueue);\n\tdestroy_tty_buffer_list(&priv->tty_inqueue);\n\tpriv->tty_state = TTY_CLOSED;\n\tpriv->sndbuf_len = 0;\n\tspin_unlock_bh(&priv->lock);\n}\n\n \nstatic int hvc_iucv_filter_connreq(u8 ipvmid[8])\n{\n\tconst char *wildcard, *filter_entry;\n\tsize_t i, len;\n\n\t \n\tif (!hvc_iucv_filter_size)\n\t\treturn 0;\n\n\tfor (i = 0; i < hvc_iucv_filter_size; i++) {\n\t\tfilter_entry = hvc_iucv_filter + (8 * i);\n\n\t\t \n\t\twildcard = strnchr(filter_entry, 8, FILTER_WILDCARD_CHAR);\n\t\tlen = (wildcard) ? wildcard - filter_entry : 8;\n\t\tif (0 == memcmp(ipvmid, filter_entry, len))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic\tint hvc_iucv_path_pending(struct iucv_path *path, u8 *ipvmid,\n\t\t\t\t  u8 *ipuser)\n{\n\tstruct hvc_iucv_private *priv, *tmp;\n\tu8 wildcard[9] = \"lnxhvc  \";\n\tint i, rc, find_unused;\n\tu8 nuser_data[16];\n\tu8 vm_user_id[9];\n\n\tASCEBC(wildcard, sizeof(wildcard));\n\tfind_unused = !memcmp(wildcard, ipuser, 8);\n\n\t \n\tpriv = NULL;\n\tfor (i = 0; i < hvc_iucv_devices; i++) {\n\t\ttmp = hvc_iucv_table[i];\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tif (find_unused) {\n\t\t\tspin_lock(&tmp->lock);\n\t\t\tif (tmp->iucv_state == IUCV_DISCONN)\n\t\t\t\tpriv = tmp;\n\t\t\tspin_unlock(&tmp->lock);\n\n\t\t} else if (!memcmp(tmp->srv_name, ipuser, 8))\n\t\t\t\tpriv = tmp;\n\t\tif (priv)\n\t\t\tbreak;\n\t}\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\t \n\tread_lock(&hvc_iucv_filter_lock);\n\trc = hvc_iucv_filter_connreq(ipvmid);\n\tread_unlock(&hvc_iucv_filter_lock);\n\tif (rc) {\n\t\tiucv_path_sever(path, ipuser);\n\t\tiucv_path_free(path);\n\t\tmemcpy(vm_user_id, ipvmid, 8);\n\t\tvm_user_id[8] = 0;\n\t\tpr_info(\"A connection request from z/VM user ID %s \"\n\t\t\t\"was refused\\n\", vm_user_id);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&priv->lock);\n\n\t \n\tif (priv->iucv_state != IUCV_DISCONN) {\n\t\tiucv_path_sever(path, ipuser);\n\t\tiucv_path_free(path);\n\t\tgoto out_path_handled;\n\t}\n\n\t \n\tmemcpy(nuser_data, ipuser + 8, 8);   \n\tmemcpy(nuser_data + 8, ipuser, 8);   \n\tpath->msglim = 0xffff;\t\t     \n\tpath->flags &= ~IUCV_IPRMDATA;\t     \n\trc = iucv_path_accept(path, &hvc_iucv_handler, nuser_data, priv);\n\tif (rc) {\n\t\tiucv_path_sever(path, ipuser);\n\t\tiucv_path_free(path);\n\t\tgoto out_path_handled;\n\t}\n\tpriv->path = path;\n\tpriv->iucv_state = IUCV_CONNECTED;\n\n\t \n\tmemcpy(priv->info_path, ipvmid, 8);\n\tmemcpy(priv->info_path + 8, ipuser + 8, 8);\n\n\t \n\tschedule_delayed_work(&priv->sndbuf_work, 5);\n\nout_path_handled:\n\tspin_unlock(&priv->lock);\n\treturn 0;\n}\n\n \nstatic void hvc_iucv_path_severed(struct iucv_path *path, u8 *ipuser)\n{\n\tstruct hvc_iucv_private *priv = path->private;\n\n\thvc_iucv_hangup(priv);\n}\n\n \nstatic void hvc_iucv_msg_pending(struct iucv_path *path,\n\t\t\t\t struct iucv_message *msg)\n{\n\tstruct hvc_iucv_private *priv = path->private;\n\tstruct iucv_tty_buffer *rb;\n\n\t \n\tif (msg->length > MSG_SIZE(MSG_MAX_DATALEN)) {\n\t\tiucv_message_reject(path, msg);\n\t\treturn;\n\t}\n\n\tspin_lock(&priv->lock);\n\n\t \n\tif (priv->tty_state == TTY_CLOSED) {\n\t\tiucv_message_reject(path, msg);\n\t\tgoto unlock_return;\n\t}\n\n\t \n\trb = alloc_tty_buffer(0, GFP_ATOMIC);\n\tif (!rb) {\n\t\tiucv_message_reject(path, msg);\n\t\tgoto unlock_return;\t \n\t}\n\trb->msg = *msg;\n\n\tlist_add_tail(&rb->list, &priv->tty_inqueue);\n\n\thvc_kick();\t \n\nunlock_return:\n\tspin_unlock(&priv->lock);\n}\n\n \nstatic void hvc_iucv_msg_complete(struct iucv_path *path,\n\t\t\t\t  struct iucv_message *msg)\n{\n\tstruct hvc_iucv_private *priv = path->private;\n\tstruct iucv_tty_buffer\t*ent, *next;\n\tLIST_HEAD(list_remove);\n\n\tspin_lock(&priv->lock);\n\tlist_for_each_entry_safe(ent, next, &priv->tty_outqueue, list)\n\t\tif (ent->msg.id == msg->id) {\n\t\t\tlist_move(&ent->list, &list_remove);\n\t\t\tbreak;\n\t\t}\n\twake_up(&priv->sndbuf_waitq);\n\tspin_unlock(&priv->lock);\n\tdestroy_tty_buffer_list(&list_remove);\n}\n\nstatic ssize_t hvc_iucv_dev_termid_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct hvc_iucv_private *priv = dev_get_drvdata(dev);\n\tsize_t len;\n\n\tlen = sizeof(priv->srv_name);\n\tmemcpy(buf, priv->srv_name, len);\n\tEBCASC(buf, len);\n\tbuf[len++] = '\\n';\n\treturn len;\n}\n\nstatic ssize_t hvc_iucv_dev_state_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct hvc_iucv_private *priv = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%u:%u\\n\", priv->iucv_state, priv->tty_state);\n}\n\nstatic ssize_t hvc_iucv_dev_peer_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct hvc_iucv_private *priv = dev_get_drvdata(dev);\n\tchar vmid[9], ipuser[9];\n\n\tmemset(vmid, 0, sizeof(vmid));\n\tmemset(ipuser, 0, sizeof(ipuser));\n\n\tspin_lock_bh(&priv->lock);\n\tif (priv->iucv_state == IUCV_CONNECTED) {\n\t\tmemcpy(vmid, priv->info_path, 8);\n\t\tmemcpy(ipuser, priv->info_path + 8, 8);\n\t}\n\tspin_unlock_bh(&priv->lock);\n\tEBCASC(ipuser, 8);\n\n\treturn sprintf(buf, \"%s:%s\\n\", vmid, ipuser);\n}\n\n\n \nstatic const struct hv_ops hvc_iucv_ops = {\n\t.get_chars = hvc_iucv_get_chars,\n\t.put_chars = hvc_iucv_put_chars,\n\t.notifier_add = hvc_iucv_notifier_add,\n\t.notifier_del = hvc_iucv_notifier_del,\n\t.notifier_hangup = hvc_iucv_notifier_hangup,\n\t.dtr_rts = hvc_iucv_dtr_rts,\n};\n\n \nstatic DEVICE_ATTR(termid, 0640, hvc_iucv_dev_termid_show, NULL);\nstatic DEVICE_ATTR(state, 0640, hvc_iucv_dev_state_show, NULL);\nstatic DEVICE_ATTR(peer, 0640, hvc_iucv_dev_peer_show, NULL);\nstatic struct attribute *hvc_iucv_dev_attrs[] = {\n\t&dev_attr_termid.attr,\n\t&dev_attr_state.attr,\n\t&dev_attr_peer.attr,\n\tNULL,\n};\nstatic struct attribute_group hvc_iucv_dev_attr_group = {\n\t.attrs = hvc_iucv_dev_attrs,\n};\nstatic const struct attribute_group *hvc_iucv_dev_attr_groups[] = {\n\t&hvc_iucv_dev_attr_group,\n\tNULL,\n};\n\n\n \nstatic int __init hvc_iucv_alloc(int id, unsigned int is_console)\n{\n\tstruct hvc_iucv_private *priv;\n\tchar name[9];\n\tint rc;\n\n\tpriv = kzalloc(sizeof(struct hvc_iucv_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\tINIT_LIST_HEAD(&priv->tty_outqueue);\n\tINIT_LIST_HEAD(&priv->tty_inqueue);\n\tINIT_DELAYED_WORK(&priv->sndbuf_work, hvc_iucv_sndbuf_work);\n\tinit_waitqueue_head(&priv->sndbuf_waitq);\n\n\tpriv->sndbuf = (void *) get_zeroed_page(GFP_KERNEL);\n\tif (!priv->sndbuf) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpriv->is_console = is_console;\n\n\t \n\tpriv->hvc = hvc_alloc(id,  \n\t\t\t      id, &hvc_iucv_ops, 256);\n\tif (IS_ERR(priv->hvc)) {\n\t\trc = PTR_ERR(priv->hvc);\n\t\tgoto out_error_hvc;\n\t}\n\n\t \n\tpriv->hvc->irq_requested = 1;\n\n\t \n\tsnprintf(name, 9, \"lnxhvc%-2d\", id);\n\tmemcpy(priv->srv_name, name, 8);\n\tASCEBC(priv->srv_name, 8);\n\n\t \n\tpriv->dev = kzalloc(sizeof(*priv->dev), GFP_KERNEL);\n\tif (!priv->dev) {\n\t\trc = -ENOMEM;\n\t\tgoto out_error_dev;\n\t}\n\tdev_set_name(priv->dev, \"hvc_iucv%d\", id);\n\tdev_set_drvdata(priv->dev, priv);\n\tpriv->dev->bus = &iucv_bus;\n\tpriv->dev->parent = iucv_root;\n\tpriv->dev->groups = hvc_iucv_dev_attr_groups;\n\tpriv->dev->release = (void (*)(struct device *)) kfree;\n\trc = device_register(priv->dev);\n\tif (rc) {\n\t\tput_device(priv->dev);\n\t\tgoto out_error_dev;\n\t}\n\n\thvc_iucv_table[id] = priv;\n\treturn 0;\n\nout_error_dev:\n\thvc_remove(priv->hvc);\nout_error_hvc:\n\tfree_page((unsigned long) priv->sndbuf);\n\tkfree(priv);\n\n\treturn rc;\n}\n\n \nstatic void __init hvc_iucv_destroy(struct hvc_iucv_private *priv)\n{\n\thvc_remove(priv->hvc);\n\tdevice_unregister(priv->dev);\n\tfree_page((unsigned long) priv->sndbuf);\n\tkfree(priv);\n}\n\n \nstatic const char *hvc_iucv_parse_filter(const char *filter, char *dest)\n{\n\tconst char *nextdelim, *residual;\n\tsize_t len;\n\n\tnextdelim = strchr(filter, ',');\n\tif (nextdelim) {\n\t\tlen = nextdelim - filter;\n\t\tresidual = nextdelim + 1;\n\t} else {\n\t\tlen = strlen(filter);\n\t\tresidual = filter + len;\n\t}\n\n\tif (len == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (filter[len - 1] == '\\n')\n\t\tlen--;\n\n\t \n\tif (len == 1 && *filter == FILTER_WILDCARD_CHAR)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (len > 8)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tmemset(dest, ' ', 8);\n\twhile (len--)\n\t\tdest[len] = toupper(filter[len]);\n\treturn residual;\n}\n\n \nstatic int hvc_iucv_setup_filter(const char *val)\n{\n\tconst char *residual;\n\tint err;\n\tsize_t size, count;\n\tvoid *array, *old_filter;\n\n\tcount = strlen(val);\n\tif (count == 0 || (count == 1 && val[0] == '\\n')) {\n\t\tsize  = 0;\n\t\tarray = NULL;\n\t\tgoto out_replace_filter;\t \n\t}\n\n\t \n\tsize = 1;\n\tresidual = val;\n\twhile ((residual = strchr(residual, ',')) != NULL) {\n\t\tresidual++;\n\t\tsize++;\n\t}\n\n\t \n\tif (size > MAX_VMID_FILTER)\n\t\treturn -ENOSPC;\n\n\tarray = kcalloc(size, 8, GFP_KERNEL);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tcount = size;\n\tresidual = val;\n\twhile (*residual && count) {\n\t\tresidual = hvc_iucv_parse_filter(residual,\n\t\t\t\t\t\t array + ((size - count) * 8));\n\t\tif (IS_ERR(residual)) {\n\t\t\terr = PTR_ERR(residual);\n\t\t\tkfree(array);\n\t\t\tgoto out_err;\n\t\t}\n\t\tcount--;\n\t}\n\nout_replace_filter:\n\twrite_lock_bh(&hvc_iucv_filter_lock);\n\told_filter = hvc_iucv_filter;\n\thvc_iucv_filter_size = size;\n\thvc_iucv_filter = array;\n\twrite_unlock_bh(&hvc_iucv_filter_lock);\n\tkfree(old_filter);\n\n\terr = 0;\nout_err:\n\treturn err;\n}\n\n \nstatic int param_set_vmidfilter(const char *val, const struct kernel_param *kp)\n{\n\tint rc;\n\n\tif (!MACHINE_IS_VM || !hvc_iucv_devices)\n\t\treturn -ENODEV;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\trc = 0;\n\tif (slab_is_available())\n\t\trc = hvc_iucv_setup_filter(val);\n\telse\n\t\thvc_iucv_filter_string = val;\t \n\treturn rc;\n}\n\n \nstatic int param_get_vmidfilter(char *buffer, const struct kernel_param *kp)\n{\n\tint rc;\n\tsize_t index, len;\n\tvoid *start, *end;\n\n\tif (!MACHINE_IS_VM || !hvc_iucv_devices)\n\t\treturn -ENODEV;\n\n\trc = 0;\n\tread_lock_bh(&hvc_iucv_filter_lock);\n\tfor (index = 0; index < hvc_iucv_filter_size; index++) {\n\t\tstart = hvc_iucv_filter + (8 * index);\n\t\tend   = memchr(start, ' ', 8);\n\t\tlen   = (end) ? end - start : 8;\n\t\tmemcpy(buffer + rc, start, len);\n\t\trc += len;\n\t\tbuffer[rc++] = ',';\n\t}\n\tread_unlock_bh(&hvc_iucv_filter_lock);\n\tif (rc)\n\t\tbuffer[--rc] = '\\0';\t \n\treturn rc;\n}\n\n#define param_check_vmidfilter(name, p) __param_check(name, p, void)\n\nstatic const struct kernel_param_ops param_ops_vmidfilter = {\n\t.set = param_set_vmidfilter,\n\t.get = param_get_vmidfilter,\n};\n\n \nstatic int __init hvc_iucv_init(void)\n{\n\tint rc;\n\tunsigned int i;\n\n\tif (!hvc_iucv_devices)\n\t\treturn -ENODEV;\n\n\tif (!MACHINE_IS_VM) {\n\t\tpr_notice(\"The z/VM IUCV HVC device driver cannot \"\n\t\t\t   \"be used without z/VM\\n\");\n\t\trc = -ENODEV;\n\t\tgoto out_error;\n\t}\n\n\tif (hvc_iucv_devices > MAX_HVC_IUCV_LINES) {\n\t\tpr_err(\"%lu is not a valid value for the hvc_iucv= \"\n\t\t\t\"kernel parameter\\n\", hvc_iucv_devices);\n\t\trc = -EINVAL;\n\t\tgoto out_error;\n\t}\n\n\t \n\tif (hvc_iucv_filter_string) {\n\t\trc = hvc_iucv_setup_filter(hvc_iucv_filter_string);\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -ENOMEM:\n\t\t\tpr_err(\"Allocating memory failed with \"\n\t\t\t\t\"reason code=%d\\n\", 3);\n\t\t\tgoto out_error;\n\t\tcase -EINVAL:\n\t\t\tpr_err(\"hvc_iucv_allow= does not specify a valid \"\n\t\t\t\t\"z/VM user ID list\\n\");\n\t\t\tgoto out_error;\n\t\tcase -ENOSPC:\n\t\t\tpr_err(\"hvc_iucv_allow= specifies too many \"\n\t\t\t\t\"z/VM user IDs\\n\");\n\t\t\tgoto out_error;\n\t\tdefault:\n\t\t\tgoto out_error;\n\t\t}\n\t}\n\n\thvc_iucv_buffer_cache = kmem_cache_create(KMSG_COMPONENT,\n\t\t\t\t\t   sizeof(struct iucv_tty_buffer),\n\t\t\t\t\t   0, 0, NULL);\n\tif (!hvc_iucv_buffer_cache) {\n\t\tpr_err(\"Allocating memory failed with reason code=%d\\n\", 1);\n\t\trc = -ENOMEM;\n\t\tgoto out_error;\n\t}\n\n\thvc_iucv_mempool = mempool_create_slab_pool(MEMPOOL_MIN_NR,\n\t\t\t\t\t\t    hvc_iucv_buffer_cache);\n\tif (!hvc_iucv_mempool) {\n\t\tpr_err(\"Allocating memory failed with reason code=%d\\n\", 2);\n\t\tkmem_cache_destroy(hvc_iucv_buffer_cache);\n\t\trc = -ENOMEM;\n\t\tgoto out_error;\n\t}\n\n\t \n\trc = hvc_instantiate(0, IUCV_HVC_CON_IDX, &hvc_iucv_ops);\n\tif (rc) {\n\t\tpr_err(\"Registering HVC terminal device as \"\n\t\t       \"Linux console failed\\n\");\n\t\tgoto out_error_memory;\n\t}\n\n\t \n\tfor (i = 0; i < hvc_iucv_devices; i++) {\n\t\trc = hvc_iucv_alloc(i, (i == IUCV_HVC_CON_IDX) ? 1 : 0);\n\t\tif (rc) {\n\t\t\tpr_err(\"Creating a new HVC terminal device \"\n\t\t\t\t\"failed with error code=%d\\n\", rc);\n\t\t\tgoto out_error_hvc;\n\t\t}\n\t}\n\n\t \n\trc = iucv_register(&hvc_iucv_handler, 0);\n\tif (rc) {\n\t\tpr_err(\"Registering IUCV handlers failed with error code=%d\\n\",\n\t\t\trc);\n\t\tgoto out_error_hvc;\n\t}\n\n\treturn 0;\n\nout_error_hvc:\n\tfor (i = 0; i < hvc_iucv_devices; i++)\n\t\tif (hvc_iucv_table[i])\n\t\t\thvc_iucv_destroy(hvc_iucv_table[i]);\nout_error_memory:\n\tmempool_destroy(hvc_iucv_mempool);\n\tkmem_cache_destroy(hvc_iucv_buffer_cache);\nout_error:\n\tkfree(hvc_iucv_filter);\n\thvc_iucv_devices = 0;  \n\treturn rc;\n}\n\n \nstatic\tint __init hvc_iucv_config(char *val)\n{\n\tif (kstrtoul(val, 10, &hvc_iucv_devices))\n\t\tpr_warn(\"hvc_iucv= invalid parameter value '%s'\\n\", val);\n\treturn 1;\n}\n\n\ndevice_initcall(hvc_iucv_init);\n__setup(\"hvc_iucv=\", hvc_iucv_config);\ncore_param(hvc_iucv_allow, hvc_iucv_filter, vmidfilter, 0640);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}