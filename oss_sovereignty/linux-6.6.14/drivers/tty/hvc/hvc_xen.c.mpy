{
  "module_name": "hvc_xen.c",
  "hash_id": "d33861df76ab768a810138386e26403ec783c175267ff80e7c7cea6f993888f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/hvc/hvc_xen.c",
  "human_readable_source": "\n \n\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/irq.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/serial_core.h>\n\n#include <asm/io.h>\n#include <asm/xen/hypervisor.h>\n\n#include <xen/xen.h>\n#include <xen/interface/xen.h>\n#include <xen/hvm.h>\n#include <xen/grant_table.h>\n#include <xen/page.h>\n#include <xen/events.h>\n#include <xen/interface/io/console.h>\n#include <xen/interface/sched.h>\n#include <xen/hvc-console.h>\n#include <xen/xenbus.h>\n\n#include \"hvc_console.h\"\n\n#define HVC_COOKIE   0x58656e  \n\nstruct xencons_info {\n\tstruct list_head list;\n\tstruct xenbus_device *xbdev;\n\tstruct xencons_interface *intf;\n\tunsigned int evtchn;\n\tXENCONS_RING_IDX out_cons;\n\tunsigned int out_cons_same;\n\tstruct hvc_struct *hvc;\n\tint irq;\n\tint vtermno;\n\tgrant_ref_t gntref;\n\tspinlock_t ring_lock;\n};\n\nstatic LIST_HEAD(xenconsoles);\nstatic DEFINE_SPINLOCK(xencons_lock);\n\n \n\nstatic struct xencons_info *vtermno_to_xencons(int vtermno)\n{\n\tstruct xencons_info *entry, *ret = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&xencons_lock, flags);\n\tif (list_empty(&xenconsoles)) {\n\t\tspin_unlock_irqrestore(&xencons_lock, flags);\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(entry, &xenconsoles, list) {\n\t\tif (entry->vtermno == vtermno) {\n\t\t\tret  = entry;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&xencons_lock, flags);\n\n\treturn ret;\n}\n\nstatic inline int xenbus_devid_to_vtermno(int devid)\n{\n\treturn devid + HVC_COOKIE;\n}\n\nstatic inline void notify_daemon(struct xencons_info *cons)\n{\n\t \n\tnotify_remote_via_evtchn(cons->evtchn);\n}\n\nstatic int __write_console(struct xencons_info *xencons,\n\t\tconst char *data, int len)\n{\n\tXENCONS_RING_IDX cons, prod;\n\tstruct xencons_interface *intf = xencons->intf;\n\tint sent = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&xencons->ring_lock, flags);\n\tcons = intf->out_cons;\n\tprod = intf->out_prod;\n\tmb();\t\t\t \n\n\tif ((prod - cons) > sizeof(intf->out)) {\n\t\tspin_unlock_irqrestore(&xencons->ring_lock, flags);\n\t\tpr_err_once(\"xencons: Illegal ring page indices\");\n\t\treturn -EINVAL;\n\t}\n\n\twhile ((sent < len) && ((prod - cons) < sizeof(intf->out)))\n\t\tintf->out[MASK_XENCONS_IDX(prod++, intf->out)] = data[sent++];\n\n\twmb();\t\t\t \n\tintf->out_prod = prod;\n\tspin_unlock_irqrestore(&xencons->ring_lock, flags);\n\n\tif (sent)\n\t\tnotify_daemon(xencons);\n\treturn sent;\n}\n\nstatic int domU_write_console(uint32_t vtermno, const char *data, int len)\n{\n\tint ret = len;\n\tstruct xencons_info *cons = vtermno_to_xencons(vtermno);\n\tif (cons == NULL)\n\t\treturn -EINVAL;\n\n\t \n\twhile (len) {\n\t\tint sent = __write_console(cons, data, len);\n\n\t\tif (sent < 0)\n\t\t\treturn sent;\n\n\t\tdata += sent;\n\t\tlen -= sent;\n\n\t\tif (unlikely(len))\n\t\t\tHYPERVISOR_sched_op(SCHEDOP_yield, NULL);\n\t}\n\n\treturn ret;\n}\n\nstatic int domU_read_console(uint32_t vtermno, char *buf, int len)\n{\n\tstruct xencons_interface *intf;\n\tXENCONS_RING_IDX cons, prod;\n\tint recv = 0;\n\tstruct xencons_info *xencons = vtermno_to_xencons(vtermno);\n\tunsigned int eoiflag = 0;\n\tunsigned long flags;\n\n\tif (xencons == NULL)\n\t\treturn -EINVAL;\n\tintf = xencons->intf;\n\n\tspin_lock_irqsave(&xencons->ring_lock, flags);\n\tcons = intf->in_cons;\n\tprod = intf->in_prod;\n\tmb();\t\t\t \n\n\tif ((prod - cons) > sizeof(intf->in)) {\n\t\tspin_unlock_irqrestore(&xencons->ring_lock, flags);\n\t\tpr_err_once(\"xencons: Illegal ring page indices\");\n\t\treturn -EINVAL;\n\t}\n\n\twhile (cons != prod && recv < len)\n\t\tbuf[recv++] = intf->in[MASK_XENCONS_IDX(cons++, intf->in)];\n\n\tmb();\t\t\t \n\tintf->in_cons = cons;\n\n\t \n\tif (intf->out_cons != xencons->out_cons) {\n\t\txencons->out_cons = intf->out_cons;\n\t\txencons->out_cons_same = 0;\n\t}\n\tif (!recv && xencons->out_cons_same++ > 1) {\n\t\teoiflag = XEN_EOI_FLAG_SPURIOUS;\n\t}\n\tspin_unlock_irqrestore(&xencons->ring_lock, flags);\n\n\tif (recv) {\n\t\tnotify_daemon(xencons);\n\t}\n\n\txen_irq_lateeoi(xencons->irq, eoiflag);\n\n\treturn recv;\n}\n\nstatic const struct hv_ops domU_hvc_ops = {\n\t.get_chars = domU_read_console,\n\t.put_chars = domU_write_console,\n\t.notifier_add = notifier_add_irq,\n\t.notifier_del = notifier_del_irq,\n\t.notifier_hangup = notifier_hangup_irq,\n};\n\nstatic int dom0_read_console(uint32_t vtermno, char *buf, int len)\n{\n\treturn HYPERVISOR_console_io(CONSOLEIO_read, len, buf);\n}\n\n \nstatic int dom0_write_console(uint32_t vtermno, const char *str, int len)\n{\n\tint rc = HYPERVISOR_console_io(CONSOLEIO_write, len, (char *)str);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn len;\n}\n\nstatic const struct hv_ops dom0_hvc_ops = {\n\t.get_chars = dom0_read_console,\n\t.put_chars = dom0_write_console,\n\t.notifier_add = notifier_add_irq,\n\t.notifier_del = notifier_del_irq,\n\t.notifier_hangup = notifier_hangup_irq,\n};\n\nstatic int xen_hvm_console_init(void)\n{\n\tint r;\n\tuint64_t v = 0;\n\tunsigned long gfn, flags;\n\tstruct xencons_info *info;\n\n\tif (!xen_hvm_domain())\n\t\treturn -ENODEV;\n\n\tinfo = vtermno_to_xencons(HVC_COOKIE);\n\tif (!info) {\n\t\tinfo = kzalloc(sizeof(struct xencons_info), GFP_KERNEL);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_init(&info->ring_lock);\n\t} else if (info->intf != NULL) {\n\t\t \n\t\treturn 0;\n\t}\n\t \n\tr = hvm_get_parameter(HVM_PARAM_CONSOLE_EVTCHN, &v);\n\tif (r < 0 || v == 0)\n\t\tgoto err;\n\tinfo->evtchn = v;\n\tv = 0;\n\tr = hvm_get_parameter(HVM_PARAM_CONSOLE_PFN, &v);\n\tif (r < 0 || v == 0)\n\t\tgoto err;\n\tgfn = v;\n\tinfo->intf = memremap(gfn << XEN_PAGE_SHIFT, XEN_PAGE_SIZE, MEMREMAP_WB);\n\tif (info->intf == NULL)\n\t\tgoto err;\n\tinfo->vtermno = HVC_COOKIE;\n\n\tspin_lock_irqsave(&xencons_lock, flags);\n\tlist_add_tail(&info->list, &xenconsoles);\n\tspin_unlock_irqrestore(&xencons_lock, flags);\n\n\treturn 0;\nerr:\n\tkfree(info);\n\treturn -ENODEV;\n}\n\nstatic int xencons_info_pv_init(struct xencons_info *info, int vtermno)\n{\n\tspin_lock_init(&info->ring_lock);\n\tinfo->evtchn = xen_start_info->console.domU.evtchn;\n\t \n\tinfo->intf = gfn_to_virt(xen_start_info->console.domU.mfn);\n\tinfo->vtermno = vtermno;\n\n\tlist_add_tail(&info->list, &xenconsoles);\n\n\treturn 0;\n}\n\nstatic int xen_pv_console_init(void)\n{\n\tstruct xencons_info *info;\n\tunsigned long flags;\n\n\tif (!xen_pv_domain())\n\t\treturn -ENODEV;\n\n\tif (!xen_start_info->console.domU.evtchn)\n\t\treturn -ENODEV;\n\n\tinfo = vtermno_to_xencons(HVC_COOKIE);\n\tif (!info) {\n\t\tinfo = kzalloc(sizeof(struct xencons_info), GFP_KERNEL);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t} else if (info->intf != NULL) {\n\t\t \n\t\treturn 0;\n\t}\n\tspin_lock_irqsave(&xencons_lock, flags);\n\txencons_info_pv_init(info, HVC_COOKIE);\n\tspin_unlock_irqrestore(&xencons_lock, flags);\n\n\treturn 0;\n}\n\nstatic int xen_initial_domain_console_init(void)\n{\n\tstruct xencons_info *info;\n\tunsigned long flags;\n\n\tif (!xen_initial_domain())\n\t\treturn -ENODEV;\n\n\tinfo = vtermno_to_xencons(HVC_COOKIE);\n\tif (!info) {\n\t\tinfo = kzalloc(sizeof(struct xencons_info), GFP_KERNEL);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_init(&info->ring_lock);\n\t}\n\n\tinfo->irq = bind_virq_to_irq(VIRQ_CONSOLE, 0, false);\n\tinfo->vtermno = HVC_COOKIE;\n\n\tspin_lock_irqsave(&xencons_lock, flags);\n\tlist_add_tail(&info->list, &xenconsoles);\n\tspin_unlock_irqrestore(&xencons_lock, flags);\n\n\treturn 0;\n}\n\nstatic void xen_console_update_evtchn(struct xencons_info *info)\n{\n\tif (xen_hvm_domain()) {\n\t\tuint64_t v = 0;\n\t\tint err;\n\n\t\terr = hvm_get_parameter(HVM_PARAM_CONSOLE_EVTCHN, &v);\n\t\tif (!err && v)\n\t\t\tinfo->evtchn = v;\n\t} else\n\t\tinfo->evtchn = xen_start_info->console.domU.evtchn;\n}\n\nvoid xen_console_resume(void)\n{\n\tstruct xencons_info *info = vtermno_to_xencons(HVC_COOKIE);\n\tif (info != NULL && info->irq) {\n\t\tif (!xen_initial_domain())\n\t\t\txen_console_update_evtchn(info);\n\t\trebind_evtchn_irq(info->evtchn, info->irq);\n\t}\n}\n\n#ifdef CONFIG_HVC_XEN_FRONTEND\nstatic void xencons_disconnect_backend(struct xencons_info *info)\n{\n\tif (info->hvc != NULL)\n\t\thvc_remove(info->hvc);\n\tinfo->hvc = NULL;\n\tif (info->irq > 0) {\n\t\tevtchn_put(info->evtchn);\n\t\tinfo->irq = 0;\n\t\tinfo->evtchn = 0;\n\t}\n\t \n\tif (info->evtchn > 0)\n\t\txenbus_free_evtchn(info->xbdev, info->evtchn);\n\tinfo->evtchn = 0;\n\tif (info->gntref > 0)\n\t\tgnttab_free_grant_references(info->gntref);\n\tinfo->gntref = 0;\n}\n\nstatic void xencons_free(struct xencons_info *info)\n{\n\tfree_page((unsigned long)info->intf);\n\tinfo->intf = NULL;\n\tinfo->vtermno = 0;\n\tkfree(info);\n}\n\nstatic int xen_console_remove(struct xencons_info *info)\n{\n\tunsigned long flags;\n\n\txencons_disconnect_backend(info);\n\tspin_lock_irqsave(&xencons_lock, flags);\n\tlist_del(&info->list);\n\tspin_unlock_irqrestore(&xencons_lock, flags);\n\tif (info->xbdev != NULL)\n\t\txencons_free(info);\n\telse {\n\t\tif (xen_hvm_domain())\n\t\t\tiounmap(info->intf);\n\t\tkfree(info);\n\t}\n\treturn 0;\n}\n\nstatic void xencons_remove(struct xenbus_device *dev)\n{\n\txen_console_remove(dev_get_drvdata(&dev->dev));\n}\n\nstatic int xencons_connect_backend(struct xenbus_device *dev,\n\t\t\t\t  struct xencons_info *info)\n{\n\tint ret, evtchn, devid, ref, irq;\n\tstruct xenbus_transaction xbt;\n\tgrant_ref_t gref_head;\n\n\tret = xenbus_alloc_evtchn(dev, &evtchn);\n\tif (ret)\n\t\treturn ret;\n\tinfo->evtchn = evtchn;\n\tirq = bind_evtchn_to_irq_lateeoi(evtchn);\n\tif (irq < 0)\n\t\treturn irq;\n\tinfo->irq = irq;\n\tdevid = dev->nodename[strlen(dev->nodename) - 1] - '0';\n\tinfo->hvc = hvc_alloc(xenbus_devid_to_vtermno(devid),\n\t\t\tirq, &domU_hvc_ops, 256);\n\tif (IS_ERR(info->hvc))\n\t\treturn PTR_ERR(info->hvc);\n\tret = gnttab_alloc_grant_references(1, &gref_head);\n\tif (ret < 0)\n\t\treturn ret;\n\tinfo->gntref = gref_head;\n\tref = gnttab_claim_grant_reference(&gref_head);\n\tif (ref < 0)\n\t\treturn ref;\n\tgnttab_grant_foreign_access_ref(ref, info->xbdev->otherend_id,\n\t\t\t\t\tvirt_to_gfn(info->intf), 0);\n\n again:\n\tret = xenbus_transaction_start(&xbt);\n\tif (ret) {\n\t\txenbus_dev_fatal(dev, ret, \"starting transaction\");\n\t\treturn ret;\n\t}\n\tret = xenbus_printf(xbt, dev->nodename, \"ring-ref\", \"%d\", ref);\n\tif (ret)\n\t\tgoto error_xenbus;\n\tret = xenbus_printf(xbt, dev->nodename, \"port\", \"%u\",\n\t\t\t    evtchn);\n\tif (ret)\n\t\tgoto error_xenbus;\n\tret = xenbus_transaction_end(xbt, 0);\n\tif (ret) {\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\t\txenbus_dev_fatal(dev, ret, \"completing transaction\");\n\t\treturn ret;\n\t}\n\n\txenbus_switch_state(dev, XenbusStateInitialised);\n\treturn 0;\n\n error_xenbus:\n\txenbus_transaction_end(xbt, 1);\n\txenbus_dev_fatal(dev, ret, \"writing xenstore\");\n\treturn ret;\n}\n\nstatic int xencons_probe(struct xenbus_device *dev,\n\t\t\t\t  const struct xenbus_device_id *id)\n{\n\tint ret, devid;\n\tstruct xencons_info *info;\n\tunsigned long flags;\n\n\tdevid = dev->nodename[strlen(dev->nodename) - 1] - '0';\n\tif (devid == 0)\n\t\treturn -ENODEV;\n\n\tinfo = kzalloc(sizeof(struct xencons_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&info->ring_lock);\n\tdev_set_drvdata(&dev->dev, info);\n\tinfo->xbdev = dev;\n\tinfo->vtermno = xenbus_devid_to_vtermno(devid);\n\tinfo->intf = (void *)__get_free_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!info->intf)\n\t\tgoto error_nomem;\n\n\tret = xencons_connect_backend(dev, info);\n\tif (ret < 0)\n\t\tgoto error;\n\tspin_lock_irqsave(&xencons_lock, flags);\n\tlist_add_tail(&info->list, &xenconsoles);\n\tspin_unlock_irqrestore(&xencons_lock, flags);\n\n\treturn 0;\n\n error_nomem:\n\tret = -ENOMEM;\n\txenbus_dev_fatal(dev, ret, \"allocating device memory\");\n error:\n\txencons_disconnect_backend(info);\n\txencons_free(info);\n\treturn ret;\n}\n\nstatic int xencons_resume(struct xenbus_device *dev)\n{\n\tstruct xencons_info *info = dev_get_drvdata(&dev->dev);\n\n\txencons_disconnect_backend(info);\n\tmemset(info->intf, 0, XEN_PAGE_SIZE);\n\treturn xencons_connect_backend(dev, info);\n}\n\nstatic void xencons_backend_changed(struct xenbus_device *dev,\n\t\t\t\t   enum xenbus_state backend_state)\n{\n\tswitch (backend_state) {\n\tcase XenbusStateReconfiguring:\n\tcase XenbusStateReconfigured:\n\tcase XenbusStateInitialising:\n\tcase XenbusStateInitialised:\n\tcase XenbusStateUnknown:\n\t\tbreak;\n\n\tcase XenbusStateInitWait:\n\t\tbreak;\n\n\tcase XenbusStateConnected:\n\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateClosed:\n\t\tif (dev->state == XenbusStateClosed)\n\t\t\tbreak;\n\t\tfallthrough;\t \n\tcase XenbusStateClosing: {\n\t\tstruct xencons_info *info = dev_get_drvdata(&dev->dev);;\n\n\t\t \n\t\tif (info->hvc) {\n\t\t\thvc_remove(info->hvc);\n\t\t\tinfo->hvc = NULL;\n\t\t}\n\n\t\txenbus_frontend_closed(dev);\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic const struct xenbus_device_id xencons_ids[] = {\n\t{ \"console\" },\n\t{ \"\" }\n};\n\nstatic struct xenbus_driver xencons_driver = {\n\t.name = \"xenconsole\",\n\t.ids = xencons_ids,\n\t.probe = xencons_probe,\n\t.remove = xencons_remove,\n\t.resume = xencons_resume,\n\t.otherend_changed = xencons_backend_changed,\n\t.not_essential = true,\n};\n#endif  \n\nstatic int __init xen_hvc_init(void)\n{\n\tint r;\n\tstruct xencons_info *info;\n\tconst struct hv_ops *ops;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tif (xen_initial_domain()) {\n\t\tops = &dom0_hvc_ops;\n\t\tr = xen_initial_domain_console_init();\n\t\tif (r < 0)\n\t\t\tgoto register_fe;\n\t\tinfo = vtermno_to_xencons(HVC_COOKIE);\n\t} else {\n\t\tops = &domU_hvc_ops;\n\t\tif (xen_hvm_domain())\n\t\t\tr = xen_hvm_console_init();\n\t\telse\n\t\t\tr = xen_pv_console_init();\n\t\tif (r < 0)\n\t\t\tgoto register_fe;\n\n\t\tinfo = vtermno_to_xencons(HVC_COOKIE);\n\t\tinfo->irq = bind_evtchn_to_irq_lateeoi(info->evtchn);\n\t}\n\tif (info->irq < 0)\n\t\tinfo->irq = 0;  \n\telse\n\t\tirq_set_noprobe(info->irq);\n\n\tinfo->hvc = hvc_alloc(HVC_COOKIE, info->irq, ops, 256);\n\tif (IS_ERR(info->hvc)) {\n\t\tunsigned long flags;\n\n\t\tr = PTR_ERR(info->hvc);\n\t\tspin_lock_irqsave(&xencons_lock, flags);\n\t\tlist_del(&info->list);\n\t\tspin_unlock_irqrestore(&xencons_lock, flags);\n\t\tif (info->irq)\n\t\t\tevtchn_put(info->evtchn);\n\t\tkfree(info);\n\t\treturn r;\n\t}\n\n\tr = 0;\n register_fe:\n#ifdef CONFIG_HVC_XEN_FRONTEND\n\tr = xenbus_register_frontend(&xencons_driver);\n#endif\n\treturn r;\n}\ndevice_initcall(xen_hvc_init);\n\nstatic int xen_cons_init(void)\n{\n\tconst struct hv_ops *ops;\n\n\tif (!xen_domain())\n\t\treturn 0;\n\n\tif (xen_initial_domain())\n\t\tops = &dom0_hvc_ops;\n\telse {\n\t\tint r;\n\t\tops = &domU_hvc_ops;\n\n\t\tif (xen_hvm_domain())\n\t\t\tr = xen_hvm_console_init();\n\t\telse\n\t\t\tr = xen_pv_console_init();\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\thvc_instantiate(HVC_COOKIE, 0, ops);\n\treturn 0;\n}\nconsole_initcall(xen_cons_init);\n\n#ifdef CONFIG_X86\nstatic void xen_hvm_early_write(uint32_t vtermno, const char *str, int len)\n{\n\tif (xen_cpuid_base())\n\t\toutsb(0xe9, str, len);\n}\n#else\nstatic void xen_hvm_early_write(uint32_t vtermno, const char *str, int len) { }\n#endif\n\n#ifdef CONFIG_EARLY_PRINTK\nstatic int __init xenboot_console_setup(struct console *console, char *string)\n{\n\tstatic struct xencons_info xenboot;\n\n\tif (xen_initial_domain() || !xen_pv_domain())\n\t\treturn 0;\n\n\treturn xencons_info_pv_init(&xenboot, 0);\n}\n\nstatic void xenboot_write_console(struct console *console, const char *string,\n\t\t\t\t  unsigned len)\n{\n\tunsigned int linelen, off = 0;\n\tconst char *pos;\n\n\tif (dom0_write_console(0, string, len) >= 0)\n\t\treturn;\n\n\tif (!xen_pv_domain()) {\n\t\txen_hvm_early_write(0, string, len);\n\t\treturn;\n\t}\n\n\tif (domU_write_console(0, \"(early) \", 8) < 0)\n\t\treturn;\n\twhile (off < len && NULL != (pos = strchr(string+off, '\\n'))) {\n\t\tlinelen = pos-string+off;\n\t\tif (off + linelen > len)\n\t\t\tbreak;\n\t\tdomU_write_console(0, string+off, linelen);\n\t\tdomU_write_console(0, \"\\r\\n\", 2);\n\t\toff += linelen + 1;\n\t}\n\tif (off < len)\n\t\tdomU_write_console(0, string+off, len-off);\n}\n\nstruct console xenboot_console = {\n\t.name\t\t= \"xenboot\",\n\t.write\t\t= xenboot_write_console,\n\t.setup\t\t= xenboot_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER | CON_BOOT | CON_ANYTIME,\n\t.index\t\t= -1,\n};\n#endif\t \n\nvoid xen_raw_console_write(const char *str)\n{\n\tssize_t len = strlen(str);\n\tint rc = 0;\n\n\tif (xen_domain()) {\n\t\trc = dom0_write_console(0, str, len);\n\t\tif (rc != -ENOSYS || !xen_hvm_domain())\n\t\t\treturn;\n\t}\n\txen_hvm_early_write(0, str, len);\n}\n\nvoid xen_raw_printk(const char *fmt, ...)\n{\n\tstatic char buf[512];\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, ap);\n\tva_end(ap);\n\n\txen_raw_console_write(buf);\n}\n\nstatic void xenboot_earlycon_write(struct console *console,\n\t\t\t\t  const char *string,\n\t\t\t\t  unsigned len)\n{\n\tdom0_write_console(0, string, len);\n}\n\nstatic int __init xenboot_earlycon_setup(struct earlycon_device *device,\n\t\t\t\t\t    const char *opt)\n{\n\tdevice->con->write = xenboot_earlycon_write;\n\treturn 0;\n}\nEARLYCON_DECLARE(xenboot, xenboot_earlycon_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}