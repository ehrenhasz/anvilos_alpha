{
  "module_name": "hvsi_lib.c",
  "hash_id": "15285160817444cfeea440c131bf94748081d9ae710edcefa66135292dfd3dd1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/hvc/hvsi_lib.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/console.h>\n#include <asm/hvsi.h>\n\n#include \"hvc_console.h\"\n\nstatic int hvsi_send_packet(struct hvsi_priv *pv, struct hvsi_header *packet)\n{\n\tpacket->seqno = cpu_to_be16(atomic_inc_return(&pv->seqno));\n\n\t \n\treturn pv->put_chars(pv->termno, (char *)packet, packet->len);\n}\n\nstatic void hvsi_start_handshake(struct hvsi_priv *pv)\n{\n\tstruct hvsi_query q;\n\n\t \n\tpv->established = 0;\n\tatomic_set(&pv->seqno, 0);\n\n\tpr_devel(\"HVSI@%x: Handshaking started\\n\", pv->termno);\n\n\t \n\tq.hdr.type = VS_QUERY_PACKET_HEADER;\n\tq.hdr.len = sizeof(struct hvsi_query);\n\tq.verb = cpu_to_be16(VSV_SEND_VERSION_NUMBER);\n\thvsi_send_packet(pv, &q.hdr);\n}\n\nstatic int hvsi_send_close(struct hvsi_priv *pv)\n{\n\tstruct hvsi_control ctrl;\n\n\tpv->established = 0;\n\n\tctrl.hdr.type = VS_CONTROL_PACKET_HEADER;\n\tctrl.hdr.len = sizeof(struct hvsi_control);\n\tctrl.verb = cpu_to_be16(VSV_CLOSE_PROTOCOL);\n\treturn hvsi_send_packet(pv, &ctrl.hdr);\n}\n\nstatic void hvsi_cd_change(struct hvsi_priv *pv, int cd)\n{\n\tif (cd)\n\t\tpv->mctrl |= TIOCM_CD;\n\telse {\n\t\tpv->mctrl &= ~TIOCM_CD;\n\n\t\t \n\t\tif (!pv->is_console && pv->opened) {\n\t\t\tpr_devel(\"HVSI@%x Carrier lost, hanging up !\\n\",\n\t\t\t\t pv->termno);\n\t\t\thvsi_send_close(pv);\n\t\t}\n\t}\n}\n\nstatic void hvsi_got_control(struct hvsi_priv *pv)\n{\n\tstruct hvsi_control *pkt = (struct hvsi_control *)pv->inbuf;\n\n\tswitch (be16_to_cpu(pkt->verb)) {\n\tcase VSV_CLOSE_PROTOCOL:\n\t\t \n\t\thvsi_start_handshake(pv);\n\t\tbreak;\n\tcase VSV_MODEM_CTL_UPDATE:\n\t\t \n\t\thvsi_cd_change(pv, be32_to_cpu(pkt->word) & HVSI_TSCD);\n\t\tbreak;\n\t}\n}\n\nstatic void hvsi_got_query(struct hvsi_priv *pv)\n{\n\tstruct hvsi_query *pkt = (struct hvsi_query *)pv->inbuf;\n\tstruct hvsi_query_response r;\n\n\t \n\tif (be16_to_cpu(pkt->verb) != VSV_SEND_VERSION_NUMBER)\n\t\treturn;\n\n\tpr_devel(\"HVSI@%x: Got version query, sending response...\\n\",\n\t\t pv->termno);\n\n\t \n\tr.hdr.type = VS_QUERY_RESPONSE_PACKET_HEADER;\n\tr.hdr.len = sizeof(struct hvsi_query_response);\n\tr.verb = cpu_to_be16(VSV_SEND_VERSION_NUMBER);\n\tr.u.version = HVSI_VERSION;\n\tr.query_seqno = pkt->hdr.seqno;\n\thvsi_send_packet(pv, &r.hdr);\n\n\t \n\tpv->established = 1;\n}\n\nstatic void hvsi_got_response(struct hvsi_priv *pv)\n{\n\tstruct hvsi_query_response *r =\n\t\t(struct hvsi_query_response *)pv->inbuf;\n\n\tswitch(r->verb) {\n\tcase VSV_SEND_MODEM_CTL_STATUS:\n\t\thvsi_cd_change(pv, be32_to_cpu(r->u.mctrl_word) & HVSI_TSCD);\n\t\tpv->mctrl_update = 1;\n\t\tbreak;\n\t}\n}\n\nstatic int hvsi_check_packet(struct hvsi_priv *pv)\n{\n\tu8 len, type;\n\n\t \n\tif (pv->inbuf[0] < 0xfc) {\n\t\tpv->inbuf_len = pv->inbuf_pktlen = 0;\n\t\treturn 0;\n\t}\n\ttype = pv->inbuf[0];\n\tlen = pv->inbuf[1];\n\n\t \n\tif (pv->inbuf_len < len)\n\t\treturn 0;\n\n\tpr_devel(\"HVSI@%x: Got packet type %x len %d bytes:\\n\",\n\t\t pv->termno, type, len);\n\n\t \n\tswitch(type) {\n\tcase VS_DATA_PACKET_HEADER:\n\t\tpv->inbuf_pktlen = len - 4;\n\t\tpv->inbuf_cur = 4;\n\t\treturn 1;\n\tcase VS_CONTROL_PACKET_HEADER:\n\t\thvsi_got_control(pv);\n\t\tbreak;\n\tcase VS_QUERY_PACKET_HEADER:\n\t\thvsi_got_query(pv);\n\t\tbreak;\n\tcase VS_QUERY_RESPONSE_PACKET_HEADER:\n\t\thvsi_got_response(pv);\n\t\tbreak;\n\t}\n\n\t \n\tpv->inbuf_len -= len;\n\tmemmove(pv->inbuf, &pv->inbuf[len], pv->inbuf_len);\n\treturn 1;\n}\n\nstatic int hvsi_get_packet(struct hvsi_priv *pv)\n{\n\t \n\tif (pv->inbuf_len < HVSI_INBUF_SIZE)\n\t\tpv->inbuf_len += pv->get_chars(pv->termno,\n\t\t\t\t\t     &pv->inbuf[pv->inbuf_len],\n\t\t\t\t\t     HVSI_INBUF_SIZE - pv->inbuf_len);\n\t \n\tif (pv->inbuf_len >= 4)\n\t\treturn hvsi_check_packet(pv);\n\treturn 0;\n}\n\nint hvsilib_get_chars(struct hvsi_priv *pv, char *buf, int count)\n{\n\tunsigned int tries, read = 0;\n\n\tif (WARN_ON(!pv))\n\t\treturn -ENXIO;\n\n\t \n\tif (!pv->opened)\n\t\treturn 0;\n\n\t \n\tfor (tries = 1; count && tries < 2; tries++) {\n\t\t \n\t\tif (pv->inbuf_pktlen) {\n\t\t\tunsigned int l = min(count, (int)pv->inbuf_pktlen);\n\t\t\tmemcpy(&buf[read], &pv->inbuf[pv->inbuf_cur], l);\n\t\t\tpv->inbuf_cur += l;\n\t\t\tpv->inbuf_pktlen -= l;\n\t\t\tcount -= l;\n\t\t\tread += l;\n\t\t}\n\t\tif (count == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (pv->inbuf_cur) {\n\t\t\tpv->inbuf_len -= pv->inbuf_cur;\n\t\t\tmemmove(pv->inbuf, &pv->inbuf[pv->inbuf_cur],\n\t\t\t\tpv->inbuf_len);\n\t\t\tpv->inbuf_cur = 0;\n\t\t}\n\n\t\t \n\t\tif (hvsi_get_packet(pv))\n\t\t\ttries--;\n\t}\n\tif (!pv->established) {\n\t\tpr_devel(\"HVSI@%x: returning -EPIPE\\n\", pv->termno);\n\t\treturn -EPIPE;\n\t}\n\treturn read;\n}\n\nint hvsilib_put_chars(struct hvsi_priv *pv, const char *buf, int count)\n{\n\tstruct hvsi_data dp;\n\tint rc, adjcount = min(count, HVSI_MAX_OUTGOING_DATA);\n\n\tif (WARN_ON(!pv))\n\t\treturn -ENODEV;\n\n\tdp.hdr.type = VS_DATA_PACKET_HEADER;\n\tdp.hdr.len = adjcount + sizeof(struct hvsi_header);\n\tmemcpy(dp.data, buf, adjcount);\n\trc = hvsi_send_packet(pv, &dp.hdr);\n\tif (rc <= 0)\n\t\treturn rc;\n\treturn adjcount;\n}\n\nstatic void maybe_msleep(unsigned long ms)\n{\n\t \n\tif (irqs_disabled())\n\t\tmdelay(ms);\n\telse\n\t\tmsleep(ms);\n}\n\nint hvsilib_read_mctrl(struct hvsi_priv *pv)\n{\n\tstruct hvsi_query q;\n\tint rc, timeout;\n\n\tpr_devel(\"HVSI@%x: Querying modem control status...\\n\",\n\t\t pv->termno);\n\n\tpv->mctrl_update = 0;\n\tq.hdr.type = VS_QUERY_PACKET_HEADER;\n\tq.hdr.len = sizeof(struct hvsi_query);\n\tq.verb = cpu_to_be16(VSV_SEND_MODEM_CTL_STATUS);\n\trc = hvsi_send_packet(pv, &q.hdr);\n\tif (rc <= 0) {\n\t\tpr_devel(\"HVSI@%x: Error %d...\\n\", pv->termno, rc);\n\t\treturn rc;\n\t}\n\n\t \n\tfor (timeout = 0; timeout < 20; timeout++) {\n\t\tif (!pv->established)\n\t\t\treturn -ENXIO;\n\t\tif (pv->mctrl_update)\n\t\t\treturn 0;\n\t\tif (!hvsi_get_packet(pv))\n\t\t\tmaybe_msleep(10);\n\t}\n\treturn -EIO;\n}\n\nint hvsilib_write_mctrl(struct hvsi_priv *pv, int dtr)\n{\n\tstruct hvsi_control ctrl;\n\tunsigned short mctrl;\n\n\tmctrl = pv->mctrl;\n\tif (dtr)\n\t\tmctrl |= TIOCM_DTR;\n\telse\n\t\tmctrl &= ~TIOCM_DTR;\n\tif (mctrl == pv->mctrl)\n\t\treturn 0;\n\tpv->mctrl = mctrl;\n\n\tpr_devel(\"HVSI@%x: %s DTR...\\n\", pv->termno,\n\t\t dtr ? \"Setting\" : \"Clearing\");\n\n\tctrl.hdr.type = VS_CONTROL_PACKET_HEADER,\n\tctrl.hdr.len = sizeof(struct hvsi_control);\n\tctrl.verb = cpu_to_be16(VSV_SET_MODEM_CTL);\n\tctrl.mask = cpu_to_be32(HVSI_TSDTR);\n\tctrl.word = cpu_to_be32(dtr ? HVSI_TSDTR : 0);\n\treturn hvsi_send_packet(pv, &ctrl.hdr);\n}\n\nvoid hvsilib_establish(struct hvsi_priv *pv)\n{\n\tint timeout;\n\n\tpr_devel(\"HVSI@%x: Establishing...\\n\", pv->termno);\n\n\t \n\tfor (timeout = 0; timeout < 20; timeout++) {\n\t\tif (pv->established)\n\t\t\tgoto established;\n\t\tif (!hvsi_get_packet(pv))\n\t\t\tmaybe_msleep(10);\n\t}\n\n\t \n\tpr_devel(\"HVSI@%x:   ... sending close\\n\", pv->termno);\n\n\thvsi_send_close(pv);\n\n\t \n\n\tpr_devel(\"HVSI@%x:   ... restarting handshake\\n\", pv->termno);\n\n\thvsi_start_handshake(pv);\n\n\tpr_devel(\"HVSI@%x:   ... waiting handshake\\n\", pv->termno);\n\n\t \n\tfor (timeout = 0; timeout < 40; timeout++) {\n\t\tif (pv->established)\n\t\t\tgoto established;\n\t\tif (!hvsi_get_packet(pv))\n\t\t\tmaybe_msleep(10);\n\t}\n\n\tif (!pv->established) {\n\t\tpr_devel(\"HVSI@%x: Timeout handshaking, giving up !\\n\",\n\t\t\t pv->termno);\n\t\treturn;\n\t}\n established:\n\t \n\n\tpr_devel(\"HVSI@%x:   ... established, reading mctrl\\n\", pv->termno);\n\n\thvsilib_read_mctrl(pv);\n\n\t \n\n\tpr_devel(\"HVSI@%x:   ... setting mctrl\\n\", pv->termno);\n\n\thvsilib_write_mctrl(pv, 1);\n\n\t \n\twmb();\n\tpv->opened = 1;\n}\n\nint hvsilib_open(struct hvsi_priv *pv, struct hvc_struct *hp)\n{\n\tpr_devel(\"HVSI@%x: open !\\n\", pv->termno);\n\n\t \n\tpv->tty = tty_port_tty_get(&hp->port);\n\n\thvsilib_establish(pv);\n\n\treturn 0;\n}\n\nvoid hvsilib_close(struct hvsi_priv *pv, struct hvc_struct *hp)\n{\n\tunsigned long flags;\n\n\tpr_devel(\"HVSI@%x: close !\\n\", pv->termno);\n\n\tif (!pv->is_console) {\n\t\tpr_devel(\"HVSI@%x: Not a console, tearing down\\n\",\n\t\t\t pv->termno);\n\n\t\t \n\t\tspin_lock_irqsave(&hp->lock, flags);\n\t\tpv->opened = 0;\n\t\tspin_unlock_irqrestore(&hp->lock, flags);\n\n\t\t \n\t\tif (!pv->tty || (pv->tty->termios.c_cflag & HUPCL))\n\t\t\thvsilib_write_mctrl(pv, 0);\n\n\t\t \n\t\thvsi_send_close(pv);\n\t}\n\n\ttty_kref_put(pv->tty);\n\tpv->tty = NULL;\n}\n\nvoid hvsilib_init(struct hvsi_priv *pv,\n\t\t  int (*get_chars)(uint32_t termno, char *buf, int count),\n\t\t  int (*put_chars)(uint32_t termno, const char *buf,\n\t\t\t\t   int count),\n\t\t  int termno, int is_console)\n{\n\tmemset(pv, 0, sizeof(*pv));\n\tpv->get_chars = get_chars;\n\tpv->put_chars = put_chars;\n\tpv->termno = termno;\n\tpv->is_console = is_console;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}