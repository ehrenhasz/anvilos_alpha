{
  "module_name": "hvc_dcc.c",
  "hash_id": "4f39951fc60c046550925d599c934388e78d1839489920bcfbe9516281f36016",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/hvc/hvc_dcc.c",
  "human_readable_source": "\n \n\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/init.h>\n#include <linux/kfifo.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n\n#include <asm/dcc.h>\n#include <asm/processor.h>\n\n#include \"hvc_console.h\"\n\n \n#define DCC_STATUS_RX\t\t(1 << 30)\n#define DCC_STATUS_TX\t\t(1 << 29)\n\n#define DCC_INBUF_SIZE\t\t128\n#define DCC_OUTBUF_SIZE\t\t1024\n\n \nstatic DEFINE_SPINLOCK(dcc_lock);\n\nstatic DEFINE_KFIFO(inbuf, unsigned char, DCC_INBUF_SIZE);\nstatic DEFINE_KFIFO(outbuf, unsigned char, DCC_OUTBUF_SIZE);\n\nstatic void dcc_uart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\twhile (__dcc_getstatus() & DCC_STATUS_TX)\n\t\tcpu_relax();\n\n\t__dcc_putchar(ch);\n}\n\nstatic void dcc_early_write(struct console *con, const char *s, unsigned n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, dcc_uart_console_putchar);\n}\n\nstatic int __init dcc_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t  const char *opt)\n{\n\tdevice->con->write = dcc_early_write;\n\n\treturn 0;\n}\n\nEARLYCON_DECLARE(dcc, dcc_early_console_setup);\n\nstatic int hvc_dcc_put_chars(uint32_t vt, const char *buf, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\twhile (__dcc_getstatus() & DCC_STATUS_TX)\n\t\t\tcpu_relax();\n\n\t\t__dcc_putchar(buf[i]);\n\t}\n\n\treturn count;\n}\n\nstatic int hvc_dcc_get_chars(uint32_t vt, char *buf, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; ++i)\n\t\tif (__dcc_getstatus() & DCC_STATUS_RX)\n\t\t\tbuf[i] = __dcc_getchar();\n\t\telse\n\t\t\tbreak;\n\n\treturn i;\n}\n\n \nstatic bool hvc_dcc_check(void)\n{\n\tunsigned long time = jiffies + (HZ / 10);\n\tstatic bool dcc_core0_available;\n\n\t \n\tint cpu = get_cpu();\n\n\tif (IS_ENABLED(CONFIG_HVC_DCC_SERIALIZE_SMP) && cpu && dcc_core0_available) {\n\t\tput_cpu();\n\t\treturn true;\n\t}\n\n\tput_cpu();\n\n\t \n\t__dcc_putchar('\\n');\n\n\twhile (time_is_after_jiffies(time)) {\n\t\tif (!(__dcc_getstatus() & DCC_STATUS_TX)) {\n\t\t\tdcc_core0_available = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic void dcc_put_work(struct work_struct *work)\n{\n\tunsigned char ch;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&dcc_lock, irqflags);\n\n\t \n\twhile (kfifo_get(&outbuf, &ch))\n\t\thvc_dcc_put_chars(0, &ch, 1);\n\n\t \n\twhile (!kfifo_is_full(&inbuf)) {\n\t\tif (!hvc_dcc_get_chars(0, &ch, 1))\n\t\t\tbreak;\n\t\tkfifo_put(&inbuf, ch);\n\t}\n\n\tspin_unlock_irqrestore(&dcc_lock, irqflags);\n}\n\nstatic DECLARE_WORK(dcc_pwork, dcc_put_work);\n\n \nstatic void dcc_get_work(struct work_struct *work)\n{\n\tunsigned char ch;\n\tunsigned long irqflags;\n\n\t \n\tspin_lock_irqsave(&dcc_lock, irqflags);\n\n\twhile (!kfifo_is_full(&inbuf)) {\n\t\tif (!hvc_dcc_get_chars(0, &ch, 1))\n\t\t\tbreak;\n\t\tkfifo_put(&inbuf, ch);\n\t}\n\tspin_unlock_irqrestore(&dcc_lock, irqflags);\n}\n\nstatic DECLARE_WORK(dcc_gwork, dcc_get_work);\n\n \nstatic int hvc_dcc0_put_chars(u32 vt, const char *buf, int count)\n{\n\tint len;\n\tunsigned long irqflags;\n\n\tif (!IS_ENABLED(CONFIG_HVC_DCC_SERIALIZE_SMP))\n\t\treturn hvc_dcc_put_chars(vt, buf, count);\n\n\tspin_lock_irqsave(&dcc_lock, irqflags);\n\tif (smp_processor_id() || (!kfifo_is_empty(&outbuf))) {\n\t\tlen = kfifo_in(&outbuf, buf, count);\n\t\tspin_unlock_irqrestore(&dcc_lock, irqflags);\n\n\t\t \n\t\tif (cpu_online(0))\n\t\t\tschedule_work_on(0, &dcc_pwork);\n\n\t\treturn len;\n\t}\n\n\t \n\tlen = hvc_dcc_put_chars(vt, buf, count);\n\tspin_unlock_irqrestore(&dcc_lock, irqflags);\n\n\treturn len;\n}\n\n \nstatic int hvc_dcc0_get_chars(u32 vt, char *buf, int count)\n{\n\tint len;\n\tunsigned long irqflags;\n\n\tif (!IS_ENABLED(CONFIG_HVC_DCC_SERIALIZE_SMP))\n\t\treturn hvc_dcc_get_chars(vt, buf, count);\n\n\tspin_lock_irqsave(&dcc_lock, irqflags);\n\n\tif (smp_processor_id() || (!kfifo_is_empty(&inbuf))) {\n\t\tlen = kfifo_out(&inbuf, buf, count);\n\t\tspin_unlock_irqrestore(&dcc_lock, irqflags);\n\n\t\t \n\t\tif (!len && cpu_online(0))\n\t\t\tschedule_work_on(0, &dcc_gwork);\n\n\t\treturn len;\n\t}\n\n\t \n\tlen = hvc_dcc_get_chars(vt, buf, count);\n\tspin_unlock_irqrestore(&dcc_lock, irqflags);\n\n\treturn len;\n}\n\nstatic const struct hv_ops hvc_dcc_get_put_ops = {\n\t.get_chars = hvc_dcc0_get_chars,\n\t.put_chars = hvc_dcc0_put_chars,\n};\n\nstatic int __init hvc_dcc_console_init(void)\n{\n\tint ret;\n\n\tif (!hvc_dcc_check())\n\t\treturn -ENODEV;\n\n\t \n\tret = hvc_instantiate(0, 0, &hvc_dcc_get_put_ops);\n\n\treturn ret < 0 ? -ENODEV : 0;\n}\nconsole_initcall(hvc_dcc_console_init);\n\nstatic int __init hvc_dcc_init(void)\n{\n\tstruct hvc_struct *p;\n\n\tif (!hvc_dcc_check())\n\t\treturn -ENODEV;\n\n\tif (IS_ENABLED(CONFIG_HVC_DCC_SERIALIZE_SMP)) {\n\t\tpr_warn(\"\\n\");\n\t\tpr_warn(\"********************************************************************\\n\");\n\t\tpr_warn(\"**     NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE           **\\n\");\n\t\tpr_warn(\"**                                                                **\\n\");\n\t\tpr_warn(\"**  HVC_DCC_SERIALIZE_SMP SUPPORT HAS BEEN ENABLED IN THIS KERNEL **\\n\");\n\t\tpr_warn(\"**                                                                **\\n\");\n\t\tpr_warn(\"** This means that this is a DEBUG kernel and unsafe for          **\\n\");\n\t\tpr_warn(\"** production use and has important feature like CPU hotplug      **\\n\");\n\t\tpr_warn(\"** disabled.                                                      **\\n\");\n\t\tpr_warn(\"**                                                                **\\n\");\n\t\tpr_warn(\"** If you see this message and you are not debugging the          **\\n\");\n\t\tpr_warn(\"** kernel, report this immediately to your vendor!                **\\n\");\n\t\tpr_warn(\"**                                                                **\\n\");\n\t\tpr_warn(\"**     NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE           **\\n\");\n\t\tpr_warn(\"********************************************************************\\n\");\n\n\t\tcpu_hotplug_disable();\n\t}\n\n\tp = hvc_alloc(0, 0, &hvc_dcc_get_put_ops, 128);\n\n\treturn PTR_ERR_OR_ZERO(p);\n}\ndevice_initcall(hvc_dcc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}