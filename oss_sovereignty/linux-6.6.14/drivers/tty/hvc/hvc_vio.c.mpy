{
  "module_name": "hvc_vio.c",
  "hash_id": "8e450eeff1b89586c56cd1f08228bf8545a33e355f52d089dc1c9a9c76bd099d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/hvc/hvc_vio.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/console.h>\n#include <linux/of.h>\n\n#include <asm/hvconsole.h>\n#include <asm/vio.h>\n#include <asm/hvsi.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n\n#include \"hvc_console.h\"\n\nstatic const char hvc_driver_name[] = \"hvc_console\";\n\nstatic const struct vio_device_id hvc_driver_table[] = {\n\t{\"serial\", \"hvterm1\"},\n#ifndef HVC_OLD_HVSI\n\t{\"serial\", \"hvterm-protocol\"},\n#endif\n\t{ \"\", \"\" }\n};\n\ntypedef enum hv_protocol {\n\tHV_PROTOCOL_RAW,\n\tHV_PROTOCOL_HVSI\n} hv_protocol_t;\n\nstruct hvterm_priv {\n\tu32\t\t\ttermno;\t \n\thv_protocol_t\t\tproto;\t \n\tstruct hvsi_priv\thvsi;\t \n\tspinlock_t\t\tbuf_lock;\n\tchar\t\t\tbuf[SIZE_VIO_GET_CHARS];\n\tint\t\t\tleft;\n\tint\t\t\toffset;\n};\nstatic struct hvterm_priv *hvterm_privs[MAX_NR_HVC_CONSOLES];\n \nstatic struct hvterm_priv hvterm_priv0;\n\nstatic int hvterm_raw_get_chars(uint32_t vtermno, char *buf, int count)\n{\n\tstruct hvterm_priv *pv = hvterm_privs[vtermno];\n\tunsigned long i;\n\tunsigned long flags;\n\tint got;\n\n\tif (WARN_ON(!pv))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&pv->buf_lock, flags);\n\n\tif (pv->left == 0) {\n\t\tpv->offset = 0;\n\t\tpv->left = hvc_get_chars(pv->termno, pv->buf, count);\n\n\t\t \n\t\tfor (i = 1; i < pv->left; ++i) {\n\t\t\tif (pv->buf[i] == 0 && pv->buf[i-1] == '\\r') {\n\t\t\t\t--pv->left;\n\t\t\t\tif (i < pv->left) {\n\t\t\t\t\tmemmove(&pv->buf[i], &pv->buf[i+1],\n\t\t\t\t\t\tpv->left - i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgot = min(count, pv->left);\n\tmemcpy(buf, &pv->buf[pv->offset], got);\n\tpv->offset += got;\n\tpv->left -= got;\n\n\tspin_unlock_irqrestore(&pv->buf_lock, flags);\n\n\treturn got;\n}\n\n \nstatic int hvterm_raw_put_chars(uint32_t vtermno, const char *buf, int count)\n{\n\tstruct hvterm_priv *pv = hvterm_privs[vtermno];\n\n\tif (WARN_ON(!pv))\n\t\treturn 0;\n\n\treturn hvc_put_chars(pv->termno, buf, count);\n}\n\nstatic const struct hv_ops hvterm_raw_ops = {\n\t.get_chars = hvterm_raw_get_chars,\n\t.put_chars = hvterm_raw_put_chars,\n\t.notifier_add = notifier_add_irq,\n\t.notifier_del = notifier_del_irq,\n\t.notifier_hangup = notifier_hangup_irq,\n};\n\nstatic int hvterm_hvsi_get_chars(uint32_t vtermno, char *buf, int count)\n{\n\tstruct hvterm_priv *pv = hvterm_privs[vtermno];\n\n\tif (WARN_ON(!pv))\n\t\treturn 0;\n\n\treturn hvsilib_get_chars(&pv->hvsi, buf, count);\n}\n\nstatic int hvterm_hvsi_put_chars(uint32_t vtermno, const char *buf, int count)\n{\n\tstruct hvterm_priv *pv = hvterm_privs[vtermno];\n\n\tif (WARN_ON(!pv))\n\t\treturn 0;\n\n\treturn hvsilib_put_chars(&pv->hvsi, buf, count);\n}\n\nstatic int hvterm_hvsi_open(struct hvc_struct *hp, int data)\n{\n\tstruct hvterm_priv *pv = hvterm_privs[hp->vtermno];\n\tint rc;\n\n\tpr_devel(\"HVSI@%x: open !\\n\", pv->termno);\n\n\trc = notifier_add_irq(hp, data);\n\tif (rc)\n\t\treturn rc;\n\n\treturn hvsilib_open(&pv->hvsi, hp);\n}\n\nstatic void hvterm_hvsi_close(struct hvc_struct *hp, int data)\n{\n\tstruct hvterm_priv *pv = hvterm_privs[hp->vtermno];\n\n\tpr_devel(\"HVSI@%x: do close !\\n\", pv->termno);\n\n\thvsilib_close(&pv->hvsi, hp);\n\n\tnotifier_del_irq(hp, data);\n}\n\nstatic void hvterm_hvsi_hangup(struct hvc_struct *hp, int data)\n{\n\tstruct hvterm_priv *pv = hvterm_privs[hp->vtermno];\n\n\tpr_devel(\"HVSI@%x: do hangup !\\n\", pv->termno);\n\n\thvsilib_close(&pv->hvsi, hp);\n\n\tnotifier_hangup_irq(hp, data);\n}\n\nstatic int hvterm_hvsi_tiocmget(struct hvc_struct *hp)\n{\n\tstruct hvterm_priv *pv = hvterm_privs[hp->vtermno];\n\n\tif (!pv)\n\t\treturn -EINVAL;\n\treturn pv->hvsi.mctrl;\n}\n\nstatic int hvterm_hvsi_tiocmset(struct hvc_struct *hp, unsigned int set,\n\t\t\t\tunsigned int clear)\n{\n\tstruct hvterm_priv *pv = hvterm_privs[hp->vtermno];\n\n\tpr_devel(\"HVSI@%x: Set modem control, set=%x,clr=%x\\n\",\n\t\t pv->termno, set, clear);\n\n\tif (set & TIOCM_DTR)\n\t\thvsilib_write_mctrl(&pv->hvsi, 1);\n\telse if (clear & TIOCM_DTR)\n\t\thvsilib_write_mctrl(&pv->hvsi, 0);\n\n\treturn 0;\n}\n\nstatic const struct hv_ops hvterm_hvsi_ops = {\n\t.get_chars = hvterm_hvsi_get_chars,\n\t.put_chars = hvterm_hvsi_put_chars,\n\t.notifier_add = hvterm_hvsi_open,\n\t.notifier_del = hvterm_hvsi_close,\n\t.notifier_hangup = hvterm_hvsi_hangup,\n\t.tiocmget = hvterm_hvsi_tiocmget,\n\t.tiocmset = hvterm_hvsi_tiocmset,\n};\n\nstatic void udbg_hvc_putc(char c)\n{\n\tint count = -1;\n\tunsigned char bounce_buffer[16];\n\n\tif (!hvterm_privs[0])\n\t\treturn;\n\n\tif (c == '\\n')\n\t\tudbg_hvc_putc('\\r');\n\n\tdo {\n\t\tswitch(hvterm_privs[0]->proto) {\n\t\tcase HV_PROTOCOL_RAW:\n\t\t\t \n\t\t\tbounce_buffer[0] = c;\n\t\t\tcount = hvterm_raw_put_chars(0, bounce_buffer, 1);\n\t\t\tbreak;\n\t\tcase HV_PROTOCOL_HVSI:\n\t\t\tcount = hvterm_hvsi_put_chars(0, &c, 1);\n\t\t\tbreak;\n\t\t}\n\t} while (count == 0 || count == -EAGAIN);\n}\n\nstatic int udbg_hvc_getc_poll(void)\n{\n\tint rc = 0;\n\tchar c;\n\n\tif (!hvterm_privs[0])\n\t\treturn -1;\n\n\tswitch(hvterm_privs[0]->proto) {\n\tcase HV_PROTOCOL_RAW:\n\t\trc = hvterm_raw_get_chars(0, &c, 1);\n\t\tbreak;\n\tcase HV_PROTOCOL_HVSI:\n\t\trc = hvterm_hvsi_get_chars(0, &c, 1);\n\t\tbreak;\n\t}\n\tif (!rc)\n\t\treturn -1;\n\treturn c;\n}\n\nstatic int udbg_hvc_getc(void)\n{\n\tint ch;\n\n\tif (!hvterm_privs[0])\n\t\treturn -1;\n\n\tfor (;;) {\n\t\tch = udbg_hvc_getc_poll();\n\t\tif (ch == -1) {\n\t\t\t \n\t\t\tvolatile unsigned long delay;\n\t\t\tfor (delay=0; delay < 2000000; delay++)\n\t\t\t\t;\n\t\t} else {\n\t\t\treturn ch;\n\t\t}\n\t}\n}\n\nstatic int hvc_vio_probe(struct vio_dev *vdev,\n\t\t\t\t   const struct vio_device_id *id)\n{\n\tconst struct hv_ops *ops;\n\tstruct hvc_struct *hp;\n\tstruct hvterm_priv *pv;\n\thv_protocol_t proto;\n\tint i, termno = -1;\n\n\t \n\tif (!vdev || !id)\n\t\treturn -EPERM;\n\n\tif (of_device_is_compatible(vdev->dev.of_node, \"hvterm1\")) {\n\t\tproto = HV_PROTOCOL_RAW;\n\t\tops = &hvterm_raw_ops;\n\t} else if (of_device_is_compatible(vdev->dev.of_node, \"hvterm-protocol\")) {\n\t\tproto = HV_PROTOCOL_HVSI;\n\t\tops = &hvterm_hvsi_ops;\n\t} else {\n\t\tpr_err(\"hvc_vio: Unknown protocol for %pOF\\n\", vdev->dev.of_node);\n\t\treturn -ENXIO;\n\t}\n\n\tpr_devel(\"hvc_vio_probe() device %pOF, using %s protocol\\n\",\n\t\t vdev->dev.of_node,\n\t\t proto == HV_PROTOCOL_RAW ? \"raw\" : \"hvsi\");\n\n\t \n\tif (hvterm_privs[0] == &hvterm_priv0 &&\n\t    vdev->unit_address == hvterm_priv0.termno) {\n\t\tpv = hvterm_privs[0];\n\t\ttermno = 0;\n\t\tpr_devel(\"->boot console, using termno 0\\n\");\n\t}\n\t \n\telse {\n\t\tfor (i = 0; i < MAX_NR_HVC_CONSOLES && termno < 0; i++)\n\t\t\tif (!hvterm_privs[i])\n\t\t\t\ttermno = i;\n\t\tpr_devel(\"->non-boot console, using termno %d\\n\", termno);\n\t\tif (termno < 0)\n\t\t\treturn -ENODEV;\n\t\tpv = kzalloc(sizeof(struct hvterm_priv), GFP_KERNEL);\n\t\tif (!pv)\n\t\t\treturn -ENOMEM;\n\t\tpv->termno = vdev->unit_address;\n\t\tpv->proto = proto;\n\t\tspin_lock_init(&pv->buf_lock);\n\t\thvterm_privs[termno] = pv;\n\t\thvsilib_init(&pv->hvsi, hvc_get_chars, hvc_put_chars,\n\t\t\t     pv->termno, 0);\n\t}\n\n\thp = hvc_alloc(termno, vdev->irq, ops, MAX_VIO_PUT_CHARS);\n\tif (IS_ERR(hp))\n\t\treturn PTR_ERR(hp);\n\tdev_set_drvdata(&vdev->dev, hp);\n\n\t \n\tif (hp->index == 0 && !udbg_putc) {\n\t\tudbg_putc = udbg_hvc_putc;\n\t\tudbg_getc = udbg_hvc_getc;\n\t\tudbg_getc_poll = udbg_hvc_getc_poll;\n\t}\n\n\treturn 0;\n}\n\nstatic struct vio_driver hvc_vio_driver = {\n\t.id_table\t= hvc_driver_table,\n\t.probe\t\t= hvc_vio_probe,\n\t.name\t\t= hvc_driver_name,\n\t.driver = {\n\t\t.suppress_bind_attrs\t= true,\n\t},\n};\n\nstatic int __init hvc_vio_init(void)\n{\n\tint rc;\n\n\t \n\trc = vio_register_driver(&hvc_vio_driver);\n\n\treturn rc;\n}\ndevice_initcall(hvc_vio_init);  \n\nvoid __init hvc_vio_init_early(void)\n{\n\tconst __be32 *termno;\n\tconst struct hv_ops *ops;\n\n\t \n\t \n\tif (!of_node_name_prefix(of_stdout, \"vty\"))\n\t\treturn;\n\ttermno = of_get_property(of_stdout, \"reg\", NULL);\n\tif (termno == NULL)\n\t\treturn;\n\thvterm_priv0.termno = of_read_number(termno, 1);\n\tspin_lock_init(&hvterm_priv0.buf_lock);\n\thvterm_privs[0] = &hvterm_priv0;\n\n\t \n\tif (of_device_is_compatible(of_stdout, \"hvterm1\")) {\n\t\thvterm_priv0.proto = HV_PROTOCOL_RAW;\n\t\tops = &hvterm_raw_ops;\n\t}\n\telse if (of_device_is_compatible(of_stdout, \"hvterm-protocol\")) {\n\t\thvterm_priv0.proto = HV_PROTOCOL_HVSI;\n\t\tops = &hvterm_hvsi_ops;\n\t\thvsilib_init(&hvterm_priv0.hvsi, hvc_get_chars, hvc_put_chars,\n\t\t\t     hvterm_priv0.termno, 1);\n\t\t \n\t\thvsilib_establish(&hvterm_priv0.hvsi);\n\t} else\n\t\treturn;\n\tudbg_putc = udbg_hvc_putc;\n\tudbg_getc = udbg_hvc_getc;\n\tudbg_getc_poll = udbg_hvc_getc_poll;\n#ifdef HVC_OLD_HVSI\n\t \n\tif (hvterm_priv0.proto == HV_PROTOCOL_HVSI)\n\t\treturn;\n#endif\n\t \n\tif (!strstr(boot_command_line, \"console=\"))\n\t\tadd_preferred_console(\"hvc\", 0, NULL);\n\thvc_instantiate(0, 0, ops);\n}\n\n \n#ifdef CONFIG_PPC_EARLY_DEBUG_LPAR\nvoid __init udbg_init_debug_lpar(void)\n{\n\t \n\tif (mfmsr() & MSR_HV)\n\t\treturn;\n\n\thvterm_privs[0] = &hvterm_priv0;\n\thvterm_priv0.termno = 0;\n\thvterm_priv0.proto = HV_PROTOCOL_RAW;\n\tspin_lock_init(&hvterm_priv0.buf_lock);\n\tudbg_putc = udbg_hvc_putc;\n\tudbg_getc = udbg_hvc_getc;\n\tudbg_getc_poll = udbg_hvc_getc_poll;\n}\n#endif  \n\n#ifdef CONFIG_PPC_EARLY_DEBUG_LPAR_HVSI\nvoid __init udbg_init_debug_lpar_hvsi(void)\n{\n\t \n\tif (mfmsr() & MSR_HV)\n\t\treturn;\n\n\thvterm_privs[0] = &hvterm_priv0;\n\thvterm_priv0.termno = CONFIG_PPC_EARLY_DEBUG_HVSI_VTERMNO;\n\thvterm_priv0.proto = HV_PROTOCOL_HVSI;\n\tspin_lock_init(&hvterm_priv0.buf_lock);\n\tudbg_putc = udbg_hvc_putc;\n\tudbg_getc = udbg_hvc_getc;\n\tudbg_getc_poll = udbg_hvc_getc_poll;\n\thvsilib_init(&hvterm_priv0.hvsi, hvc_get_chars, hvc_put_chars,\n\t\t     hvterm_priv0.termno, 1);\n\thvsilib_establish(&hvterm_priv0.hvsi);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}