{
  "module_name": "hvsi.c",
  "hash_id": "7dc474dc02f877eb0eb2c3c7109180e9a55d97798187960c87e313cfb564f337",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/hvc/hvsi.c",
  "human_readable_source": "\n \n\n \n\n#undef DEBUG\n\n#include <linux/console.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/major.h>\n#include <linux/kernel.h>\n#include <linux/of_irq.h>\n#include <linux/spinlock.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <asm/hvcall.h>\n#include <asm/hvconsole.h>\n#include <linux/uaccess.h>\n#include <asm/vio.h>\n#include <asm/param.h>\n#include <asm/hvsi.h>\n\n#define HVSI_MAJOR\t229\n#define HVSI_MINOR\t128\n#define MAX_NR_HVSI_CONSOLES 4\n\n#define HVSI_TIMEOUT (5*HZ)\n#define HVSI_VERSION 1\n#define HVSI_MAX_PACKET 256\n#define HVSI_MAX_READ 16\n#define HVSI_MAX_OUTGOING_DATA 12\n#define N_OUTBUF 12\n\n \n#define __ALIGNED__\t__attribute__((__aligned__(sizeof(long))))\n\nstruct hvsi_struct {\n\tstruct tty_port port;\n\tstruct delayed_work writer;\n\tstruct work_struct handshaker;\n\twait_queue_head_t emptyq;  \n\twait_queue_head_t stateq;  \n\tspinlock_t lock;\n\tint index;\n\tuint8_t throttle_buf[128];\n\tuint8_t outbuf[N_OUTBUF];  \n\t \n\tuint8_t inbuf[HVSI_MAX_PACKET + HVSI_MAX_READ];\n\tuint8_t *inbuf_end;\n\tint n_throttle;\n\tint n_outbuf;\n\tuint32_t vtermno;\n\tuint32_t virq;\n\tatomic_t seqno;  \n\tuint16_t mctrl;\n\tuint8_t state;   \n\tuint8_t flags;\n#ifdef CONFIG_MAGIC_SYSRQ\n\tuint8_t sysrq;\n#endif  \n};\nstatic struct hvsi_struct hvsi_ports[MAX_NR_HVSI_CONSOLES];\n\nstatic struct tty_driver *hvsi_driver;\nstatic int hvsi_count;\nstatic int (*hvsi_wait)(struct hvsi_struct *hp, int state);\n\nenum HVSI_PROTOCOL_STATE {\n\tHVSI_CLOSED,\n\tHVSI_WAIT_FOR_VER_RESPONSE,\n\tHVSI_WAIT_FOR_VER_QUERY,\n\tHVSI_OPEN,\n\tHVSI_WAIT_FOR_MCTRL_RESPONSE,\n\tHVSI_FSP_DIED,\n};\n#define HVSI_CONSOLE 0x1\n\nstatic inline int is_console(struct hvsi_struct *hp)\n{\n\treturn hp->flags & HVSI_CONSOLE;\n}\n\nstatic inline int is_open(struct hvsi_struct *hp)\n{\n\t \n\treturn (hp->state == HVSI_OPEN)\n\t\t\t|| (hp->state == HVSI_WAIT_FOR_MCTRL_RESPONSE);\n}\n\nstatic inline void print_state(struct hvsi_struct *hp)\n{\n#ifdef DEBUG\n\tstatic const char *state_names[] = {\n\t\t\"HVSI_CLOSED\",\n\t\t\"HVSI_WAIT_FOR_VER_RESPONSE\",\n\t\t\"HVSI_WAIT_FOR_VER_QUERY\",\n\t\t\"HVSI_OPEN\",\n\t\t\"HVSI_WAIT_FOR_MCTRL_RESPONSE\",\n\t\t\"HVSI_FSP_DIED\",\n\t};\n\tconst char *name = (hp->state < ARRAY_SIZE(state_names))\n\t\t? state_names[hp->state] : \"UNKNOWN\";\n\n\tpr_debug(\"hvsi%i: state = %s\\n\", hp->index, name);\n#endif  \n}\n\nstatic inline void __set_state(struct hvsi_struct *hp, int state)\n{\n\thp->state = state;\n\tprint_state(hp);\n\twake_up_all(&hp->stateq);\n}\n\nstatic inline void set_state(struct hvsi_struct *hp, int state)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hp->lock, flags);\n\t__set_state(hp, state);\n\tspin_unlock_irqrestore(&hp->lock, flags);\n}\n\nstatic inline int len_packet(const uint8_t *packet)\n{\n\treturn (int)((struct hvsi_header *)packet)->len;\n}\n\nstatic inline int is_header(const uint8_t *packet)\n{\n\tstruct hvsi_header *header = (struct hvsi_header *)packet;\n\treturn header->type >= VS_QUERY_RESPONSE_PACKET_HEADER;\n}\n\nstatic inline int got_packet(const struct hvsi_struct *hp, uint8_t *packet)\n{\n\tif (hp->inbuf_end < packet + sizeof(struct hvsi_header))\n\t\treturn 0;  \n\n\tif (hp->inbuf_end < (packet + len_packet(packet)))\n\t\treturn 0;  \n\n\treturn 1;\n}\n\n \nstatic void compact_inbuf(struct hvsi_struct *hp, uint8_t *read_to)\n{\n\tint remaining = (int)(hp->inbuf_end - read_to);\n\n\tpr_debug(\"%s: %i chars remain\\n\", __func__, remaining);\n\n\tif (read_to != hp->inbuf)\n\t\tmemmove(hp->inbuf, read_to, remaining);\n\n\thp->inbuf_end = hp->inbuf + remaining;\n}\n\n#ifdef DEBUG\n#define dbg_dump_packet(packet) dump_packet(packet)\n#define dbg_dump_hex(data, len) dump_hex(data, len)\n#else\n#define dbg_dump_packet(packet) do { } while (0)\n#define dbg_dump_hex(data, len) do { } while (0)\n#endif\n\nstatic void dump_hex(const uint8_t *data, int len)\n{\n\tint i;\n\n\tprintk(\"    \");\n\tfor (i=0; i < len; i++)\n\t\tprintk(\"%.2x\", data[i]);\n\n\tprintk(\"\\n    \");\n\tfor (i=0; i < len; i++) {\n\t\tif (isprint(data[i]))\n\t\t\tprintk(\"%c\", data[i]);\n\t\telse\n\t\t\tprintk(\".\");\n\t}\n\tprintk(\"\\n\");\n}\n\nstatic void dump_packet(uint8_t *packet)\n{\n\tstruct hvsi_header *header = (struct hvsi_header *)packet;\n\n\tprintk(\"type 0x%x, len %i, seqno %i:\\n\", header->type, header->len,\n\t\t\theader->seqno);\n\n\tdump_hex(packet, header->len);\n}\n\nstatic int hvsi_read(struct hvsi_struct *hp, char *buf, int count)\n{\n\tunsigned long got;\n\n\tgot = hvc_get_chars(hp->vtermno, buf, count);\n\n\treturn got;\n}\n\nstatic void hvsi_recv_control(struct hvsi_struct *hp, uint8_t *packet,\n\tstruct tty_struct *tty, struct hvsi_struct **to_handshake)\n{\n\tstruct hvsi_control *header = (struct hvsi_control *)packet;\n\n\tswitch (be16_to_cpu(header->verb)) {\n\t\tcase VSV_MODEM_CTL_UPDATE:\n\t\t\tif ((be32_to_cpu(header->word) & HVSI_TSCD) == 0) {\n\t\t\t\t \n\t\t\t\tpr_debug(\"hvsi%i: CD dropped\\n\", hp->index);\n\t\t\t\thp->mctrl &= TIOCM_CD;\n\t\t\t\tif (tty && !C_CLOCAL(tty))\n\t\t\t\t\ttty_hangup(tty);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VSV_CLOSE_PROTOCOL:\n\t\t\tpr_debug(\"hvsi%i: service processor came back\\n\", hp->index);\n\t\t\tif (hp->state != HVSI_CLOSED) {\n\t\t\t\t*to_handshake = hp;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING \"hvsi%i: unknown HVSI control packet: \",\n\t\t\t\thp->index);\n\t\t\tdump_packet(packet);\n\t\t\tbreak;\n\t}\n}\n\nstatic void hvsi_recv_response(struct hvsi_struct *hp, uint8_t *packet)\n{\n\tstruct hvsi_query_response *resp = (struct hvsi_query_response *)packet;\n\tuint32_t mctrl_word;\n\n\tswitch (hp->state) {\n\t\tcase HVSI_WAIT_FOR_VER_RESPONSE:\n\t\t\t__set_state(hp, HVSI_WAIT_FOR_VER_QUERY);\n\t\t\tbreak;\n\t\tcase HVSI_WAIT_FOR_MCTRL_RESPONSE:\n\t\t\thp->mctrl = 0;\n\t\t\tmctrl_word = be32_to_cpu(resp->u.mctrl_word);\n\t\t\tif (mctrl_word & HVSI_TSDTR)\n\t\t\t\thp->mctrl |= TIOCM_DTR;\n\t\t\tif (mctrl_word & HVSI_TSCD)\n\t\t\t\thp->mctrl |= TIOCM_CD;\n\t\t\t__set_state(hp, HVSI_OPEN);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"hvsi%i: unexpected query response: \", hp->index);\n\t\t\tdump_packet(packet);\n\t\t\tbreak;\n\t}\n}\n\n \nstatic int hvsi_version_respond(struct hvsi_struct *hp, uint16_t query_seqno)\n{\n\tstruct hvsi_query_response packet __ALIGNED__;\n\tint wrote;\n\n\tpacket.hdr.type = VS_QUERY_RESPONSE_PACKET_HEADER;\n\tpacket.hdr.len = sizeof(struct hvsi_query_response);\n\tpacket.hdr.seqno = cpu_to_be16(atomic_inc_return(&hp->seqno));\n\tpacket.verb = cpu_to_be16(VSV_SEND_VERSION_NUMBER);\n\tpacket.u.version = HVSI_VERSION;\n\tpacket.query_seqno = cpu_to_be16(query_seqno+1);\n\n\tpr_debug(\"%s: sending %i bytes\\n\", __func__, packet.hdr.len);\n\tdbg_dump_hex((uint8_t*)&packet, packet.hdr.len);\n\n\twrote = hvc_put_chars(hp->vtermno, (char *)&packet, packet.hdr.len);\n\tif (wrote != packet.hdr.len) {\n\t\tprintk(KERN_ERR \"hvsi%i: couldn't send query response!\\n\",\n\t\t\thp->index);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void hvsi_recv_query(struct hvsi_struct *hp, uint8_t *packet)\n{\n\tstruct hvsi_query *query = (struct hvsi_query *)packet;\n\n\tswitch (hp->state) {\n\t\tcase HVSI_WAIT_FOR_VER_QUERY:\n\t\t\thvsi_version_respond(hp, be16_to_cpu(query->hdr.seqno));\n\t\t\t__set_state(hp, HVSI_OPEN);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"hvsi%i: unexpected query: \", hp->index);\n\t\t\tdump_packet(packet);\n\t\t\tbreak;\n\t}\n}\n\nstatic void hvsi_insert_chars(struct hvsi_struct *hp, const char *buf, int len)\n{\n\tint i;\n\n\tfor (i=0; i < len; i++) {\n\t\tchar c = buf[i];\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tif (c == '\\0') {\n\t\t\thp->sysrq = 1;\n\t\t\tcontinue;\n\t\t} else if (hp->sysrq) {\n\t\t\thandle_sysrq(c);\n\t\t\thp->sysrq = 0;\n\t\t\tcontinue;\n\t\t}\n#endif  \n\t\ttty_insert_flip_char(&hp->port, c, 0);\n\t}\n}\n\n \n#define TTY_THRESHOLD_THROTTLE 128\nstatic bool hvsi_recv_data(struct hvsi_struct *hp, const uint8_t *packet)\n{\n\tconst struct hvsi_header *header = (const struct hvsi_header *)packet;\n\tconst uint8_t *data = packet + sizeof(struct hvsi_header);\n\tint datalen = header->len - sizeof(struct hvsi_header);\n\tint overflow = datalen - TTY_THRESHOLD_THROTTLE;\n\n\tpr_debug(\"queueing %i chars '%.*s'\\n\", datalen, datalen, data);\n\n\tif (datalen == 0)\n\t\treturn false;\n\n\tif (overflow > 0) {\n\t\tpr_debug(\"%s: got >TTY_THRESHOLD_THROTTLE bytes\\n\", __func__);\n\t\tdatalen = TTY_THRESHOLD_THROTTLE;\n\t}\n\n\thvsi_insert_chars(hp, data, datalen);\n\n\tif (overflow > 0) {\n\t\t \n\t\tpr_debug(\"%s: deferring overflow\\n\", __func__);\n\t\tmemcpy(hp->throttle_buf, data + TTY_THRESHOLD_THROTTLE, overflow);\n\t\thp->n_throttle = overflow;\n\t}\n\n\treturn true;\n}\n\n \nstatic int hvsi_load_chunk(struct hvsi_struct *hp, struct tty_struct *tty,\n\t\tstruct hvsi_struct **handshake)\n{\n\tuint8_t *packet = hp->inbuf;\n\tint chunklen;\n\tbool flip = false;\n\n\t*handshake = NULL;\n\n\tchunklen = hvsi_read(hp, hp->inbuf_end, HVSI_MAX_READ);\n\tif (chunklen == 0) {\n\t\tpr_debug(\"%s: 0-length read\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s: got %i bytes\\n\", __func__, chunklen);\n\tdbg_dump_hex(hp->inbuf_end, chunklen);\n\n\thp->inbuf_end += chunklen;\n\n\t \n\twhile ((packet < hp->inbuf_end) && got_packet(hp, packet)) {\n\t\tstruct hvsi_header *header = (struct hvsi_header *)packet;\n\n\t\tif (!is_header(packet)) {\n\t\t\tprintk(KERN_ERR \"hvsi%i: got malformed packet\\n\", hp->index);\n\t\t\t \n\t\t\twhile ((packet < hp->inbuf_end) && (!is_header(packet)))\n\t\t\t\tpacket++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"%s: handling %i-byte packet\\n\", __func__,\n\t\t\t\tlen_packet(packet));\n\t\tdbg_dump_packet(packet);\n\n\t\tswitch (header->type) {\n\t\t\tcase VS_DATA_PACKET_HEADER:\n\t\t\t\tif (!is_open(hp))\n\t\t\t\t\tbreak;\n\t\t\t\tflip = hvsi_recv_data(hp, packet);\n\t\t\t\tbreak;\n\t\t\tcase VS_CONTROL_PACKET_HEADER:\n\t\t\t\thvsi_recv_control(hp, packet, tty, handshake);\n\t\t\t\tbreak;\n\t\t\tcase VS_QUERY_RESPONSE_PACKET_HEADER:\n\t\t\t\thvsi_recv_response(hp, packet);\n\t\t\t\tbreak;\n\t\t\tcase VS_QUERY_PACKET_HEADER:\n\t\t\t\thvsi_recv_query(hp, packet);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"hvsi%i: unknown HVSI packet type 0x%x\\n\",\n\t\t\t\t\t\thp->index, header->type);\n\t\t\t\tdump_packet(packet);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpacket += len_packet(packet);\n\n\t\tif (*handshake) {\n\t\t\tpr_debug(\"%s: handshake\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcompact_inbuf(hp, packet);\n\n\tif (flip)\n\t\ttty_flip_buffer_push(&hp->port);\n\n\treturn 1;\n}\n\nstatic void hvsi_send_overflow(struct hvsi_struct *hp)\n{\n\tpr_debug(\"%s: delivering %i bytes overflow\\n\", __func__,\n\t\t\thp->n_throttle);\n\n\thvsi_insert_chars(hp, hp->throttle_buf, hp->n_throttle);\n\thp->n_throttle = 0;\n}\n\n \nstatic irqreturn_t hvsi_interrupt(int irq, void *arg)\n{\n\tstruct hvsi_struct *hp = (struct hvsi_struct *)arg;\n\tstruct hvsi_struct *handshake;\n\tstruct tty_struct *tty;\n\tunsigned long flags;\n\tint again = 1;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\ttty = tty_port_tty_get(&hp->port);\n\n\twhile (again) {\n\t\tspin_lock_irqsave(&hp->lock, flags);\n\t\tagain = hvsi_load_chunk(hp, tty, &handshake);\n\t\tspin_unlock_irqrestore(&hp->lock, flags);\n\n\t\tif (handshake) {\n\t\t\tpr_debug(\"hvsi%i: attempting re-handshake\\n\", handshake->index);\n\t\t\tschedule_work(&handshake->handshaker);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&hp->lock, flags);\n\tif (tty && hp->n_throttle && !tty_throttled(tty)) {\n\t\t \n\t\thvsi_send_overflow(hp);\n\t\ttty_flip_buffer_push(&hp->port);\n\t}\n\tspin_unlock_irqrestore(&hp->lock, flags);\n\n\ttty_kref_put(tty);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int __init poll_for_state(struct hvsi_struct *hp, int state)\n{\n\tunsigned long end_jiffies = jiffies + HVSI_TIMEOUT;\n\n\tfor (;;) {\n\t\thvsi_interrupt(hp->virq, (void *)hp);  \n\n\t\tif (hp->state == state)\n\t\t\treturn 0;\n\n\t\tmdelay(5);\n\t\tif (time_after(jiffies, end_jiffies))\n\t\t\treturn -EIO;\n\t}\n}\n\n \nstatic int wait_for_state(struct hvsi_struct *hp, int state)\n{\n\tint ret = 0;\n\n\tif (!wait_event_timeout(hp->stateq, (hp->state == state), HVSI_TIMEOUT))\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nstatic int hvsi_query(struct hvsi_struct *hp, uint16_t verb)\n{\n\tstruct hvsi_query packet __ALIGNED__;\n\tint wrote;\n\n\tpacket.hdr.type = VS_QUERY_PACKET_HEADER;\n\tpacket.hdr.len = sizeof(struct hvsi_query);\n\tpacket.hdr.seqno = cpu_to_be16(atomic_inc_return(&hp->seqno));\n\tpacket.verb = cpu_to_be16(verb);\n\n\tpr_debug(\"%s: sending %i bytes\\n\", __func__, packet.hdr.len);\n\tdbg_dump_hex((uint8_t*)&packet, packet.hdr.len);\n\n\twrote = hvc_put_chars(hp->vtermno, (char *)&packet, packet.hdr.len);\n\tif (wrote != packet.hdr.len) {\n\t\tprintk(KERN_ERR \"hvsi%i: couldn't send query (%i)!\\n\", hp->index,\n\t\t\twrote);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int hvsi_get_mctrl(struct hvsi_struct *hp)\n{\n\tint ret;\n\n\tset_state(hp, HVSI_WAIT_FOR_MCTRL_RESPONSE);\n\thvsi_query(hp, VSV_SEND_MODEM_CTL_STATUS);\n\n\tret = hvsi_wait(hp, HVSI_OPEN);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"hvsi%i: didn't get modem flags\\n\", hp->index);\n\t\tset_state(hp, HVSI_OPEN);\n\t\treturn ret;\n\t}\n\n\tpr_debug(\"%s: mctrl 0x%x\\n\", __func__, hp->mctrl);\n\n\treturn 0;\n}\n\n \nstatic int hvsi_set_mctrl(struct hvsi_struct *hp, uint16_t mctrl)\n{\n\tstruct hvsi_control packet __ALIGNED__;\n\tint wrote;\n\n\tpacket.hdr.type = VS_CONTROL_PACKET_HEADER;\n\tpacket.hdr.seqno = cpu_to_be16(atomic_inc_return(&hp->seqno));\n\tpacket.hdr.len = sizeof(struct hvsi_control);\n\tpacket.verb = cpu_to_be16(VSV_SET_MODEM_CTL);\n\tpacket.mask = cpu_to_be32(HVSI_TSDTR);\n\n\tif (mctrl & TIOCM_DTR)\n\t\tpacket.word = cpu_to_be32(HVSI_TSDTR);\n\n\tpr_debug(\"%s: sending %i bytes\\n\", __func__, packet.hdr.len);\n\tdbg_dump_hex((uint8_t*)&packet, packet.hdr.len);\n\n\twrote = hvc_put_chars(hp->vtermno, (char *)&packet, packet.hdr.len);\n\tif (wrote != packet.hdr.len) {\n\t\tprintk(KERN_ERR \"hvsi%i: couldn't set DTR!\\n\", hp->index);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void hvsi_drain_input(struct hvsi_struct *hp)\n{\n\tuint8_t buf[HVSI_MAX_READ] __ALIGNED__;\n\tunsigned long end_jiffies = jiffies + HVSI_TIMEOUT;\n\n\twhile (time_before(end_jiffies, jiffies))\n\t\tif (0 == hvsi_read(hp, buf, HVSI_MAX_READ))\n\t\t\tbreak;\n}\n\nstatic int hvsi_handshake(struct hvsi_struct *hp)\n{\n\tint ret;\n\n\t \n\thvsi_drain_input(hp);\n\n\tset_state(hp, HVSI_WAIT_FOR_VER_RESPONSE);\n\tret = hvsi_query(hp, VSV_SEND_VERSION_NUMBER);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"hvsi%i: couldn't send version query\\n\", hp->index);\n\t\treturn ret;\n\t}\n\n\tret = hvsi_wait(hp, HVSI_OPEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void hvsi_handshaker(struct work_struct *work)\n{\n\tstruct hvsi_struct *hp =\n\t\tcontainer_of(work, struct hvsi_struct, handshaker);\n\n\tif (hvsi_handshake(hp) >= 0)\n\t\treturn;\n\n\tprintk(KERN_ERR \"hvsi%i: re-handshaking failed\\n\", hp->index);\n\tif (is_console(hp)) {\n\t\t \n\t\tprintk(KERN_ERR \"hvsi%i: lost console!\\n\", hp->index);\n\t}\n}\n\nstatic int hvsi_put_chars(struct hvsi_struct *hp, const char *buf, int count)\n{\n\tstruct hvsi_data packet __ALIGNED__;\n\tint ret;\n\n\tBUG_ON(count > HVSI_MAX_OUTGOING_DATA);\n\n\tpacket.hdr.type = VS_DATA_PACKET_HEADER;\n\tpacket.hdr.seqno = cpu_to_be16(atomic_inc_return(&hp->seqno));\n\tpacket.hdr.len = count + sizeof(struct hvsi_header);\n\tmemcpy(&packet.data, buf, count);\n\n\tret = hvc_put_chars(hp->vtermno, (char *)&packet, packet.hdr.len);\n\tif (ret == packet.hdr.len) {\n\t\t \n\t\treturn count;\n\t}\n\treturn ret;  \n}\n\nstatic void hvsi_close_protocol(struct hvsi_struct *hp)\n{\n\tstruct hvsi_control packet __ALIGNED__;\n\n\tpacket.hdr.type = VS_CONTROL_PACKET_HEADER;\n\tpacket.hdr.seqno = cpu_to_be16(atomic_inc_return(&hp->seqno));\n\tpacket.hdr.len = 6;\n\tpacket.verb = cpu_to_be16(VSV_CLOSE_PROTOCOL);\n\n\tpr_debug(\"%s: sending %i bytes\\n\", __func__, packet.hdr.len);\n\tdbg_dump_hex((uint8_t*)&packet, packet.hdr.len);\n\n\thvc_put_chars(hp->vtermno, (char *)&packet, packet.hdr.len);\n}\n\nstatic int hvsi_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct hvsi_struct *hp;\n\tunsigned long flags;\n\tint ret;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\thp = &hvsi_ports[tty->index];\n\n\ttty->driver_data = hp;\n\n\tmb();\n\tif (hp->state == HVSI_FSP_DIED)\n\t\treturn -EIO;\n\n\ttty_port_tty_set(&hp->port, tty);\n\tspin_lock_irqsave(&hp->lock, flags);\n\thp->port.count++;\n\tatomic_set(&hp->seqno, 0);\n\th_vio_signal(hp->vtermno, VIO_IRQ_ENABLE);\n\tspin_unlock_irqrestore(&hp->lock, flags);\n\n\tif (is_console(hp))\n\t\treturn 0;  \n\n\tret = hvsi_handshake(hp);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"%s: HVSI handshaking failed\\n\", tty->name);\n\t\treturn ret;\n\t}\n\n\tret = hvsi_get_mctrl(hp);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"%s: couldn't get initial modem flags\\n\", tty->name);\n\t\treturn ret;\n\t}\n\n\tret = hvsi_set_mctrl(hp, hp->mctrl | TIOCM_DTR);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"%s: couldn't set DTR\\n\", tty->name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void hvsi_flush_output(struct hvsi_struct *hp)\n{\n\twait_event_timeout(hp->emptyq, (hp->n_outbuf <= 0), HVSI_TIMEOUT);\n\n\t \n\tcancel_delayed_work_sync(&hp->writer);\n\tflush_work(&hp->handshaker);\n\n\t \n\thp->n_outbuf = 0;\n}\n\nstatic void hvsi_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct hvsi_struct *hp = tty->driver_data;\n\tunsigned long flags;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tif (tty_hung_up_p(filp))\n\t\treturn;\n\n\tspin_lock_irqsave(&hp->lock, flags);\n\n\tif (--hp->port.count == 0) {\n\t\ttty_port_tty_set(&hp->port, NULL);\n\t\thp->inbuf_end = hp->inbuf;  \n\n\t\t \n\t\tif (!is_console(hp)) {\n\t\t\th_vio_signal(hp->vtermno, VIO_IRQ_DISABLE);  \n\t\t\t__set_state(hp, HVSI_CLOSED);\n\t\t\t \n\t\t\ttty->closing = 1;\n\n\t\t\tspin_unlock_irqrestore(&hp->lock, flags);\n\n\t\t\t \n\t\t\tsynchronize_irq(hp->virq);\n\n\t\t\t \n\t\t\thvsi_flush_output(hp);\n\n\t\t\t \n\t\t\thvsi_close_protocol(hp);\n\n\t\t\t \n\t\t\thvsi_drain_input(hp);\n\n\t\t\tspin_lock_irqsave(&hp->lock, flags);\n\t\t}\n\t} else if (hp->port.count < 0)\n\t\tprintk(KERN_ERR \"hvsi_close %lu: oops, count is %d\\n\",\n\t\t       hp - hvsi_ports, hp->port.count);\n\n\tspin_unlock_irqrestore(&hp->lock, flags);\n}\n\nstatic void hvsi_hangup(struct tty_struct *tty)\n{\n\tstruct hvsi_struct *hp = tty->driver_data;\n\tunsigned long flags;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\ttty_port_tty_set(&hp->port, NULL);\n\n\tspin_lock_irqsave(&hp->lock, flags);\n\thp->port.count = 0;\n\thp->n_outbuf = 0;\n\tspin_unlock_irqrestore(&hp->lock, flags);\n}\n\n \nstatic void hvsi_push(struct hvsi_struct *hp)\n{\n\tint n;\n\n\tif (hp->n_outbuf <= 0)\n\t\treturn;\n\n\tn = hvsi_put_chars(hp, hp->outbuf, hp->n_outbuf);\n\tif (n > 0) {\n\t\t \n\t\tpr_debug(\"%s: wrote %i chars\\n\", __func__, n);\n\t\thp->n_outbuf = 0;\n\t} else if (n == -EIO) {\n\t\t__set_state(hp, HVSI_FSP_DIED);\n\t\tprintk(KERN_ERR \"hvsi%i: service processor died\\n\", hp->index);\n\t}\n}\n\n \nstatic void hvsi_write_worker(struct work_struct *work)\n{\n\tstruct hvsi_struct *hp =\n\t\tcontainer_of(work, struct hvsi_struct, writer.work);\n\tunsigned long flags;\n#ifdef DEBUG\n\tstatic long start_j = 0;\n\n\tif (start_j == 0)\n\t\tstart_j = jiffies;\n#endif  \n\n\tspin_lock_irqsave(&hp->lock, flags);\n\n\tpr_debug(\"%s: %i chars in buffer\\n\", __func__, hp->n_outbuf);\n\n\tif (!is_open(hp)) {\n\t\t \n\t\tschedule_delayed_work(&hp->writer, HZ);\n\t\tgoto out;\n\t}\n\n\thvsi_push(hp);\n\tif (hp->n_outbuf > 0)\n\t\tschedule_delayed_work(&hp->writer, 10);\n\telse {\n#ifdef DEBUG\n\t\tpr_debug(\"%s: outbuf emptied after %li jiffies\\n\", __func__,\n\t\t\t\tjiffies - start_j);\n\t\tstart_j = 0;\n#endif  \n\t\twake_up_all(&hp->emptyq);\n\t\ttty_port_tty_wakeup(&hp->port);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&hp->lock, flags);\n}\n\nstatic unsigned int hvsi_write_room(struct tty_struct *tty)\n{\n\tstruct hvsi_struct *hp = tty->driver_data;\n\n\treturn N_OUTBUF - hp->n_outbuf;\n}\n\nstatic unsigned int hvsi_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct hvsi_struct *hp = tty->driver_data;\n\n\treturn hp->n_outbuf;\n}\n\nstatic ssize_t hvsi_write(struct tty_struct *tty, const u8 *source,\n\t\t\t  size_t count)\n{\n\tstruct hvsi_struct *hp = tty->driver_data;\n\tunsigned long flags;\n\tsize_t total = 0;\n\tsize_t origcount = count;\n\n\tspin_lock_irqsave(&hp->lock, flags);\n\n\tpr_debug(\"%s: %i chars in buffer\\n\", __func__, hp->n_outbuf);\n\n\tif (!is_open(hp)) {\n\t\t \n\t\tpr_debug(\"%s: not open\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t \n\twhile ((count > 0) && (hvsi_write_room(tty) > 0)) {\n\t\tsize_t chunksize = min_t(size_t, count, hvsi_write_room(tty));\n\n\t\tBUG_ON(hp->n_outbuf < 0);\n\t\tmemcpy(hp->outbuf + hp->n_outbuf, source, chunksize);\n\t\thp->n_outbuf += chunksize;\n\n\t\ttotal += chunksize;\n\t\tsource += chunksize;\n\t\tcount -= chunksize;\n\t\thvsi_push(hp);\n\t}\n\n\tif (hp->n_outbuf > 0) {\n\t\t \n\t\tschedule_delayed_work(&hp->writer, 10);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&hp->lock, flags);\n\n\tif (total != origcount)\n\t\tpr_debug(\"%s: wanted %zu, only wrote %zu\\n\", __func__,\n\t\t\t origcount, total);\n\n\treturn total;\n}\n\n \nstatic void hvsi_throttle(struct tty_struct *tty)\n{\n\tstruct hvsi_struct *hp = tty->driver_data;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\th_vio_signal(hp->vtermno, VIO_IRQ_DISABLE);\n}\n\nstatic void hvsi_unthrottle(struct tty_struct *tty)\n{\n\tstruct hvsi_struct *hp = tty->driver_data;\n\tunsigned long flags;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tspin_lock_irqsave(&hp->lock, flags);\n\tif (hp->n_throttle) {\n\t\thvsi_send_overflow(hp);\n\t\ttty_flip_buffer_push(&hp->port);\n\t}\n\tspin_unlock_irqrestore(&hp->lock, flags);\n\n\n\th_vio_signal(hp->vtermno, VIO_IRQ_ENABLE);\n}\n\nstatic int hvsi_tiocmget(struct tty_struct *tty)\n{\n\tstruct hvsi_struct *hp = tty->driver_data;\n\n\thvsi_get_mctrl(hp);\n\treturn hp->mctrl;\n}\n\nstatic int hvsi_tiocmset(struct tty_struct *tty,\n\t\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct hvsi_struct *hp = tty->driver_data;\n\tunsigned long flags;\n\tuint16_t new_mctrl;\n\n\t \n\tclear &= TIOCM_DTR;\n\tset &= TIOCM_DTR;\n\n\tspin_lock_irqsave(&hp->lock, flags);\n\n\tnew_mctrl = (hp->mctrl & ~clear) | set;\n\n\tif (hp->mctrl != new_mctrl) {\n\t\thvsi_set_mctrl(hp, new_mctrl);\n\t\thp->mctrl = new_mctrl;\n\t}\n\tspin_unlock_irqrestore(&hp->lock, flags);\n\n\treturn 0;\n}\n\n\nstatic const struct tty_operations hvsi_ops = {\n\t.open = hvsi_open,\n\t.close = hvsi_close,\n\t.write = hvsi_write,\n\t.hangup = hvsi_hangup,\n\t.write_room = hvsi_write_room,\n\t.chars_in_buffer = hvsi_chars_in_buffer,\n\t.throttle = hvsi_throttle,\n\t.unthrottle = hvsi_unthrottle,\n\t.tiocmget = hvsi_tiocmget,\n\t.tiocmset = hvsi_tiocmset,\n};\n\nstatic int __init hvsi_init(void)\n{\n\tstruct tty_driver *driver;\n\tint i, ret;\n\n\tdriver = tty_alloc_driver(hvsi_count, TTY_DRIVER_REAL_RAW);\n\tif (IS_ERR(driver))\n\t\treturn PTR_ERR(driver);\n\n\tdriver->driver_name = \"hvsi\";\n\tdriver->name = \"hvsi\";\n\tdriver->major = HVSI_MAJOR;\n\tdriver->minor_start = HVSI_MINOR;\n\tdriver->type = TTY_DRIVER_TYPE_SYSTEM;\n\tdriver->init_termios = tty_std_termios;\n\tdriver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL;\n\tdriver->init_termios.c_ispeed = 9600;\n\tdriver->init_termios.c_ospeed = 9600;\n\ttty_set_operations(driver, &hvsi_ops);\n\n\tfor (i=0; i < hvsi_count; i++) {\n\t\tstruct hvsi_struct *hp = &hvsi_ports[i];\n\t\tint ret = 1;\n\n\t\ttty_port_link_device(&hp->port, driver, i);\n\n\t\tret = request_irq(hp->virq, hvsi_interrupt, 0, \"hvsi\", hp);\n\t\tif (ret)\n\t\t\tprintk(KERN_ERR \"HVSI: couldn't reserve irq 0x%x (error %i)\\n\",\n\t\t\t\thp->virq, ret);\n\t}\n\thvsi_wait = wait_for_state;  \n\n\tret = tty_register_driver(driver);\n\tif (ret) {\n\t\tpr_err(\"Couldn't register hvsi console driver\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\thvsi_driver = driver;\n\n\tprintk(KERN_DEBUG \"HVSI: registered %i devices\\n\", hvsi_count);\n\n\treturn 0;\nerr_free_irq:\n\thvsi_wait = poll_for_state;\n\tfor (i = 0; i < hvsi_count; i++) {\n\t\tstruct hvsi_struct *hp = &hvsi_ports[i];\n\n\t\tfree_irq(hp->virq, hp);\n\t}\n\ttty_driver_kref_put(driver);\n\n\treturn ret;\n}\ndevice_initcall(hvsi_init);\n\n \n\nstatic void hvsi_console_print(struct console *console, const char *buf,\n\t\tunsigned int count)\n{\n\tstruct hvsi_struct *hp = &hvsi_ports[console->index];\n\tchar c[HVSI_MAX_OUTGOING_DATA] __ALIGNED__;\n\tunsigned int i = 0, n = 0;\n\tint ret, donecr = 0;\n\n\tmb();\n\tif (!is_open(hp))\n\t\treturn;\n\n\t \n\twhile (count > 0 || i > 0) {\n\t\tif (count > 0 && i < sizeof(c)) {\n\t\t\tif (buf[n] == '\\n' && !donecr) {\n\t\t\t\tc[i++] = '\\r';\n\t\t\t\tdonecr = 1;\n\t\t\t} else {\n\t\t\t\tc[i++] = buf[n++];\n\t\t\t\tdonecr = 0;\n\t\t\t\t--count;\n\t\t\t}\n\t\t} else {\n\t\t\tret = hvsi_put_chars(hp, c, i);\n\t\t\tif (ret < 0)\n\t\t\t\ti = 0;\n\t\t\ti -= ret;\n\t\t}\n\t}\n}\n\nstatic struct tty_driver *hvsi_console_device(struct console *console,\n\tint *index)\n{\n\t*index = console->index;\n\treturn hvsi_driver;\n}\n\nstatic int __init hvsi_console_setup(struct console *console, char *options)\n{\n\tstruct hvsi_struct *hp;\n\tint ret;\n\n\tif (console->index < 0 || console->index >= hvsi_count)\n\t\treturn -EINVAL;\n\thp = &hvsi_ports[console->index];\n\n\t \n\thvsi_close_protocol(hp);\n\n\tret = hvsi_handshake(hp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = hvsi_get_mctrl(hp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = hvsi_set_mctrl(hp, hp->mctrl | TIOCM_DTR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thp->flags |= HVSI_CONSOLE;\n\n\treturn 0;\n}\n\nstatic struct console hvsi_console = {\n\t.name\t\t= \"hvsi\",\n\t.write\t\t= hvsi_console_print,\n\t.device\t\t= hvsi_console_device,\n\t.setup\t\t= hvsi_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n};\n\nstatic int __init hvsi_console_init(void)\n{\n\tstruct device_node *vty;\n\n\thvsi_wait = poll_for_state;  \n\n\t \n\tfor_each_compatible_node(vty, \"serial\", \"hvterm-protocol\") {\n\t\tstruct hvsi_struct *hp;\n\t\tconst __be32 *vtermno, *irq;\n\n\t\tvtermno = of_get_property(vty, \"reg\", NULL);\n\t\tirq = of_get_property(vty, \"interrupts\", NULL);\n\t\tif (!vtermno || !irq)\n\t\t\tcontinue;\n\n\t\tif (hvsi_count >= MAX_NR_HVSI_CONSOLES) {\n\t\t\tof_node_put(vty);\n\t\t\tbreak;\n\t\t}\n\n\t\thp = &hvsi_ports[hvsi_count];\n\t\tINIT_DELAYED_WORK(&hp->writer, hvsi_write_worker);\n\t\tINIT_WORK(&hp->handshaker, hvsi_handshaker);\n\t\tinit_waitqueue_head(&hp->emptyq);\n\t\tinit_waitqueue_head(&hp->stateq);\n\t\tspin_lock_init(&hp->lock);\n\t\ttty_port_init(&hp->port);\n\t\thp->index = hvsi_count;\n\t\thp->inbuf_end = hp->inbuf;\n\t\thp->state = HVSI_CLOSED;\n\t\thp->vtermno = be32_to_cpup(vtermno);\n\t\thp->virq = irq_create_mapping(NULL, be32_to_cpup(irq));\n\t\tif (hp->virq == 0) {\n\t\t\tprintk(KERN_ERR \"%s: couldn't create irq mapping for 0x%x\\n\",\n\t\t\t       __func__, be32_to_cpup(irq));\n\t\t\ttty_port_destroy(&hp->port);\n\t\t\tcontinue;\n\t\t}\n\n\t\thvsi_count++;\n\t}\n\n\tif (hvsi_count)\n\t\tregister_console(&hvsi_console);\n\treturn 0;\n}\nconsole_initcall(hvsi_console_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}