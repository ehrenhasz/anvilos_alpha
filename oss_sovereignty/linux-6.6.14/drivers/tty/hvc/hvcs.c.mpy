{
  "module_name": "hvcs.c",
  "hash_id": "3eea4eb386ca97f28876024687166124364a82a6577d60c1ee0dbdf091ce980b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/hvc/hvcs.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kthread.h>\n#include <linux/list.h>\n#include <linux/major.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <asm/hvconsole.h>\n#include <asm/hvcserver.h>\n#include <linux/uaccess.h>\n#include <linux/termios_internal.h>\n#include <asm/vio.h>\n\n \n\n#define HVCS_DRIVER_VERSION \"1.3.3\"\n\nMODULE_AUTHOR(\"Ryan S. Arnold <rsa@us.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM hvcs (Hypervisor Virtual Console Server) Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(HVCS_DRIVER_VERSION);\n\n \n#define HVCS_CLOSE_WAIT (HZ/100)  \n\n \n#define HVCS_DEFAULT_SERVER_ADAPTERS\t64\n\n \n#define HVCS_MAX_SERVER_ADAPTERS\t1024\n\n \n#define HVCS_MINOR_START\t0\n\n \n#define __ALIGNED__\t__attribute__((__aligned__(8)))\n\n \n#define HVCS_BUFF_LEN\t16\n\n \n#define HVCS_MAX_FROM_USER\t4096\n\n \nstatic const struct ktermios hvcs_tty_termios = {\n\t.c_iflag = IGNBRK | IGNPAR,\n\t.c_oflag = OPOST,\n\t.c_cflag = B38400 | CS8 | CREAD | HUPCL,\n\t.c_cc = INIT_C_CC,\n\t.c_ispeed = 38400,\n\t.c_ospeed = 38400\n};\n\n \nstatic int hvcs_parm_num_devs = -1;\nmodule_param(hvcs_parm_num_devs, int, 0);\n\nstatic const char hvcs_driver_name[] = \"hvcs\";\nstatic const char hvcs_device_node[] = \"hvcs\";\n\n \nstatic int hvcs_rescan_status;\n\nstatic struct tty_driver *hvcs_tty_driver;\n\n \nstatic int *hvcs_index_list;\n\n \nstatic int hvcs_index_count;\n\n \nstatic int hvcs_kicked;\n\n \nstatic struct task_struct *hvcs_task;\n\n \nstatic unsigned long *hvcs_pi_buff;\n\n \nstatic DEFINE_SPINLOCK(hvcs_pi_lock);\n\n \nstruct hvcs_struct {\n\tstruct tty_port port;\n\tspinlock_t lock;\n\n\t \n\tunsigned int index;\n\n\t \n\tint todo_mask;\n\n\t \n\tchar buffer[HVCS_BUFF_LEN];\n\tint chars_in_buffer;\n\n\t \n\tint connected;  \n\tuint32_t p_unit_address;  \n\tuint32_t p_partition_ID;  \n\tchar p_location_code[HVCS_CLC_LENGTH + 1];  \n\tstruct list_head next;  \n\tstruct vio_dev *vdev;\n\tstruct completion *destroyed;\n};\n\nstatic LIST_HEAD(hvcs_structs);\nstatic DEFINE_SPINLOCK(hvcs_structs_lock);\nstatic DEFINE_MUTEX(hvcs_init_mutex);\n\nstatic int hvcs_get_pi(struct hvcs_struct *hvcsd);\nstatic int hvcs_rescan_devices_list(void);\n\nstatic void hvcs_partner_free(struct hvcs_struct *hvcsd);\n\nstatic int hvcs_initialize(void);\n\n#define HVCS_SCHED_READ\t0x00000001\n#define HVCS_QUICK_READ\t0x00000002\n#define HVCS_TRY_WRITE\t0x00000004\n#define HVCS_READ_MASK\t(HVCS_SCHED_READ | HVCS_QUICK_READ)\n\nstatic inline struct hvcs_struct *from_vio_dev(struct vio_dev *viod)\n{\n\treturn dev_get_drvdata(&viod->dev);\n}\n \n\nstatic ssize_t hvcs_partner_vtys_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct vio_dev *viod = to_vio_dev(dev);\n\tstruct hvcs_struct *hvcsd = from_vio_dev(viod);\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\tretval = sprintf(buf, \"%X\\n\", hvcsd->p_unit_address);\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\treturn retval;\n}\nstatic DEVICE_ATTR(partner_vtys, S_IRUGO, hvcs_partner_vtys_show, NULL);\n\nstatic ssize_t hvcs_partner_clcs_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct vio_dev *viod = to_vio_dev(dev);\n\tstruct hvcs_struct *hvcsd = from_vio_dev(viod);\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\tretval = sprintf(buf, \"%s\\n\", &hvcsd->p_location_code[0]);\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\treturn retval;\n}\nstatic DEVICE_ATTR(partner_clcs, S_IRUGO, hvcs_partner_clcs_show, NULL);\n\nstatic ssize_t hvcs_current_vty_store(struct device *dev, struct device_attribute *attr, const char * buf,\n\t\tsize_t count)\n{\n\t \n\tprintk(KERN_INFO \"HVCS: Denied current_vty change: -EPERM.\\n\");\n\treturn -EPERM;\n}\n\nstatic ssize_t hvcs_current_vty_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct vio_dev *viod = to_vio_dev(dev);\n\tstruct hvcs_struct *hvcsd = from_vio_dev(viod);\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\tretval = sprintf(buf, \"%s\\n\", &hvcsd->p_location_code[0]);\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\treturn retval;\n}\n\nstatic DEVICE_ATTR(current_vty,\n\tS_IRUGO | S_IWUSR, hvcs_current_vty_show, hvcs_current_vty_store);\n\nstatic ssize_t hvcs_vterm_state_store(struct device *dev, struct device_attribute *attr, const char *buf,\n\t\tsize_t count)\n{\n\tstruct vio_dev *viod = to_vio_dev(dev);\n\tstruct hvcs_struct *hvcsd = from_vio_dev(viod);\n\tunsigned long flags;\n\n\t \n\tif (simple_strtol(buf, NULL, 0) != 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\n\tif (hvcsd->port.count > 0) {\n\t\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\t\tprintk(KERN_INFO \"HVCS: vterm state unchanged.  \"\n\t\t\t\t\"The hvcs device node is still in use.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (hvcsd->connected == 0) {\n\t\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\t\tprintk(KERN_INFO \"HVCS: vterm state unchanged. The\"\n\t\t\t\t\" vty-server is not connected to a vty.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\thvcs_partner_free(hvcsd);\n\tprintk(KERN_INFO \"HVCS: Closed vty-server@%X and\"\n\t\t\t\" partner vty@%X:%d connection.\\n\",\n\t\t\thvcsd->vdev->unit_address,\n\t\t\thvcsd->p_unit_address,\n\t\t\t(uint32_t)hvcsd->p_partition_ID);\n\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\treturn count;\n}\n\nstatic ssize_t hvcs_vterm_state_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct vio_dev *viod = to_vio_dev(dev);\n\tstruct hvcs_struct *hvcsd = from_vio_dev(viod);\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\tretval = sprintf(buf, \"%d\\n\", hvcsd->connected);\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\treturn retval;\n}\nstatic DEVICE_ATTR(vterm_state, S_IRUGO | S_IWUSR,\n\t\thvcs_vterm_state_show, hvcs_vterm_state_store);\n\nstatic ssize_t hvcs_index_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct vio_dev *viod = to_vio_dev(dev);\n\tstruct hvcs_struct *hvcsd = from_vio_dev(viod);\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\tretval = sprintf(buf, \"%d\\n\", hvcsd->index);\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\treturn retval;\n}\n\nstatic DEVICE_ATTR(index, S_IRUGO, hvcs_index_show, NULL);\n\nstatic struct attribute *hvcs_dev_attrs[] = {\n\t&dev_attr_partner_vtys.attr,\n\t&dev_attr_partner_clcs.attr,\n\t&dev_attr_current_vty.attr,\n\t&dev_attr_vterm_state.attr,\n\t&dev_attr_index.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(hvcs_dev);\n\nstatic ssize_t rescan_show(struct device_driver *ddp, char *buf)\n{\n\t \n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", hvcs_rescan_status);\n}\n\nstatic ssize_t rescan_store(struct device_driver *ddp, const char * buf,\n\t\tsize_t count)\n{\n\tif ((simple_strtol(buf, NULL, 0) != 1)\n\t\t&& (hvcs_rescan_status != 0))\n\t\treturn -EINVAL;\n\n\thvcs_rescan_status = 1;\n\tprintk(KERN_INFO \"HVCS: rescanning partner info for all\"\n\t\t\" vty-servers.\\n\");\n\thvcs_rescan_devices_list();\n\thvcs_rescan_status = 0;\n\treturn count;\n}\n\nstatic DRIVER_ATTR_RW(rescan);\n\nstatic struct attribute *hvcs_attrs[] = {\n\t&driver_attr_rescan.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(hvcs);\n\nstatic void hvcs_kick(void)\n{\n\thvcs_kicked = 1;\n\twmb();\n\twake_up_process(hvcs_task);\n}\n\nstatic void hvcs_unthrottle(struct tty_struct *tty)\n{\n\tstruct hvcs_struct *hvcsd = tty->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\thvcsd->todo_mask |= HVCS_SCHED_READ;\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\thvcs_kick();\n}\n\nstatic void hvcs_throttle(struct tty_struct *tty)\n{\n\tstruct hvcs_struct *hvcsd = tty->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\tvio_disable_interrupts(hvcsd->vdev);\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n}\n\n \nstatic irqreturn_t hvcs_handle_interrupt(int irq, void *dev_instance)\n{\n\tstruct hvcs_struct *hvcsd = dev_instance;\n\n\tspin_lock(&hvcsd->lock);\n\tvio_disable_interrupts(hvcsd->vdev);\n\thvcsd->todo_mask |= HVCS_SCHED_READ;\n\tspin_unlock(&hvcsd->lock);\n\thvcs_kick();\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void hvcs_try_write(struct hvcs_struct *hvcsd)\n{\n\tuint32_t unit_address = hvcsd->vdev->unit_address;\n\tstruct tty_struct *tty = hvcsd->port.tty;\n\tint sent;\n\n\tif (hvcsd->todo_mask & HVCS_TRY_WRITE) {\n\t\t \n\t\tsent = hvc_put_chars(unit_address,\n\t\t\t\t&hvcsd->buffer[0],\n\t\t\t\thvcsd->chars_in_buffer );\n\t\tif (sent > 0) {\n\t\t\thvcsd->chars_in_buffer = 0;\n\t\t\t \n\t\t\thvcsd->todo_mask &= ~(HVCS_TRY_WRITE);\n\t\t\t \n\n\t\t\t \n\t\t\tif (tty) {\n\t\t\t\ttty_wakeup(tty);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int hvcs_io(struct hvcs_struct *hvcsd)\n{\n\tuint32_t unit_address;\n\tstruct tty_struct *tty;\n\tchar buf[HVCS_BUFF_LEN] __ALIGNED__;\n\tunsigned long flags;\n\tint got = 0;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\n\tunit_address = hvcsd->vdev->unit_address;\n\ttty = hvcsd->port.tty;\n\n\thvcs_try_write(hvcsd);\n\n\tif (!tty || tty_throttled(tty)) {\n\t\thvcsd->todo_mask &= ~(HVCS_READ_MASK);\n\t\tgoto bail;\n\t} else if (!(hvcsd->todo_mask & (HVCS_READ_MASK)))\n\t\tgoto bail;\n\n\t \n\thvcsd->todo_mask &= ~(HVCS_READ_MASK);\n\n\tif (tty_buffer_request_room(&hvcsd->port, HVCS_BUFF_LEN) >= HVCS_BUFF_LEN) {\n\t\tgot = hvc_get_chars(unit_address,\n\t\t\t\t&buf[0],\n\t\t\t\tHVCS_BUFF_LEN);\n\t\ttty_insert_flip_string(&hvcsd->port, buf, got);\n\t}\n\n\t \n\tif (got)\n\t\thvcsd->todo_mask |= HVCS_QUICK_READ;\n\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\t \n\tif (got)\n\t\ttty_flip_buffer_push(&hvcsd->port);\n\telse {\n\t\t \n\t\tspin_lock_irqsave(&hvcsd->lock, flags);\n\t\tvio_enable_interrupts(hvcsd->vdev);\n\t\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\t}\n\n\treturn hvcsd->todo_mask;\n\n bail:\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\treturn hvcsd->todo_mask;\n}\n\nstatic int khvcsd(void *unused)\n{\n\tstruct hvcs_struct *hvcsd;\n\tint hvcs_todo_mask;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdo {\n\t\thvcs_todo_mask = 0;\n\t\thvcs_kicked = 0;\n\t\twmb();\n\n\t\tspin_lock(&hvcs_structs_lock);\n\t\tlist_for_each_entry(hvcsd, &hvcs_structs, next) {\n\t\t\thvcs_todo_mask |= hvcs_io(hvcsd);\n\t\t}\n\t\tspin_unlock(&hvcs_structs_lock);\n\n\t\t \n\t\t if (hvcs_todo_mask & (HVCS_TRY_WRITE | HVCS_QUICK_READ)) {\n\t\t\tyield();\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!hvcs_kicked)\n\t\t\tschedule();\n\t\t__set_current_state(TASK_RUNNING);\n\t} while (!kthread_should_stop());\n\n\treturn 0;\n}\n\nstatic const struct vio_device_id hvcs_driver_table[] = {\n\t{\"serial-server\", \"hvterm2\"},\n\t{ \"\", \"\" }\n};\nMODULE_DEVICE_TABLE(vio, hvcs_driver_table);\n\nstatic void hvcs_return_index(int index)\n{\n\t \n\tif (!hvcs_index_list)\n\t\treturn;\n\tif (index < 0 || index >= hvcs_index_count)\n\t\treturn;\n\tif (hvcs_index_list[index] == -1)\n\t\treturn;\n\telse\n\t\thvcs_index_list[index] = -1;\n}\n\nstatic void hvcs_destruct_port(struct tty_port *p)\n{\n\tstruct hvcs_struct *hvcsd = container_of(p, struct hvcs_struct, port);\n\tstruct vio_dev *vdev;\n\tstruct completion *comp;\n\tunsigned long flags;\n\n\tspin_lock(&hvcs_structs_lock);\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\n\tcomp = hvcsd->destroyed;\n\t \n\tlist_del(&(hvcsd->next));\n\n\tif (hvcsd->connected == 1) {\n\t\thvcs_partner_free(hvcsd);\n\t\tprintk(KERN_INFO \"HVCS: Closed vty-server@%X and\"\n\t\t\t\t\" partner vty@%X:%d connection.\\n\",\n\t\t\t\thvcsd->vdev->unit_address,\n\t\t\t\thvcsd->p_unit_address,\n\t\t\t\t(uint32_t)hvcsd->p_partition_ID);\n\t}\n\tprintk(KERN_INFO \"HVCS: Destroyed hvcs_struct for vty-server@%X.\\n\",\n\t\t\thvcsd->vdev->unit_address);\n\n\tvdev = hvcsd->vdev;\n\thvcsd->vdev = NULL;\n\n\thvcsd->p_unit_address = 0;\n\thvcsd->p_partition_ID = 0;\n\thvcsd->destroyed = NULL;\n\thvcs_return_index(hvcsd->index);\n\tmemset(&hvcsd->p_location_code[0], 0x00, HVCS_CLC_LENGTH + 1);\n\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\tspin_unlock(&hvcs_structs_lock);\n\n\tkfree(hvcsd);\n\tif (comp)\n\t\tcomplete(comp);\n}\n\nstatic const struct tty_port_operations hvcs_port_ops = {\n\t.destruct = hvcs_destruct_port,\n};\n\nstatic int hvcs_get_index(void)\n{\n\tint i;\n\t \n\tif (!hvcs_index_list) {\n\t\tprintk(KERN_ERR \"HVCS: hvcs_index_list NOT valid!.\\n\");\n\t\treturn -EFAULT;\n\t}\n\t \n\tfor(i = 0; i < hvcs_index_count; i++) {\n\t\tif (hvcs_index_list[i] == -1) {\n\t\t\thvcs_index_list[i] = 0;\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int hvcs_probe(\n\tstruct vio_dev *dev,\n\tconst struct vio_device_id *id)\n{\n\tstruct hvcs_struct *hvcsd;\n\tint index, rc;\n\n\tif (!dev || !id) {\n\t\tprintk(KERN_ERR \"HVCS: probed with invalid parameter.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\trc = hvcs_initialize();\n\tif (rc) {\n\t\tpr_err(\"HVCS: Failed to initialize core driver.\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tindex = hvcs_get_index();\n\tif (index < 0) {\n\t\treturn -EFAULT;\n\t}\n\n\thvcsd = kzalloc(sizeof(*hvcsd), GFP_KERNEL);\n\tif (!hvcsd)\n\t\treturn -ENODEV;\n\n\ttty_port_init(&hvcsd->port);\n\thvcsd->port.ops = &hvcs_port_ops;\n\tspin_lock_init(&hvcsd->lock);\n\n\thvcsd->vdev = dev;\n\tdev_set_drvdata(&dev->dev, hvcsd);\n\n\thvcsd->index = index;\n\n\t \n\thvcsd->chars_in_buffer = 0;\n\thvcsd->todo_mask = 0;\n\thvcsd->connected = 0;\n\n\t \n\tif (hvcs_get_pi(hvcsd)) {\n\t\tprintk(KERN_ERR \"HVCS: Failed to fetch partner\"\n\t\t\t\" info for vty-server@%X on device probe.\\n\",\n\t\t\thvcsd->vdev->unit_address);\n\t}\n\n\t \n\tspin_lock(&hvcs_structs_lock);\n\tlist_add_tail(&(hvcsd->next), &hvcs_structs);\n\tspin_unlock(&hvcs_structs_lock);\n\n\tprintk(KERN_INFO \"HVCS: vty-server@%X added to the vio bus.\\n\", dev->unit_address);\n\n\t \n\treturn 0;\n}\n\nstatic void hvcs_remove(struct vio_dev *dev)\n{\n\tstruct hvcs_struct *hvcsd = dev_get_drvdata(&dev->dev);\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\tunsigned long flags;\n\tstruct tty_struct *tty;\n\n\t \n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\n\thvcsd->destroyed = &comp;\n\ttty = tty_port_tty_get(&hvcsd->port);\n\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\n\t \n\tif (tty) {\n\t\ttty_vhangup(tty);\n\t\ttty_kref_put(tty);\n\t}\n\n\ttty_port_put(&hvcsd->port);\n\twait_for_completion(&comp);\n\tprintk(KERN_INFO \"HVCS: vty-server@%X removed from the\"\n\t\t\t\" vio bus.\\n\", dev->unit_address);\n};\n\nstatic struct vio_driver hvcs_vio_driver = {\n\t.id_table\t= hvcs_driver_table,\n\t.probe\t\t= hvcs_probe,\n\t.remove\t\t= hvcs_remove,\n\t.name\t\t= hvcs_driver_name,\n\t.driver = {\n\t\t.groups = hvcs_groups,\n\t\t.dev_groups = hvcs_dev_groups,\n\t},\n};\n\n \nstatic void hvcs_set_pi(struct hvcs_partner_info *pi, struct hvcs_struct *hvcsd)\n{\n\thvcsd->p_unit_address = pi->unit_address;\n\thvcsd->p_partition_ID  = pi->partition_ID;\n\n\t \n\tstrscpy(hvcsd->p_location_code, pi->location_code,\n\t\tsizeof(hvcsd->p_location_code));\n}\n\n \nstatic int hvcs_get_pi(struct hvcs_struct *hvcsd)\n{\n\tstruct hvcs_partner_info *pi;\n\tuint32_t unit_address = hvcsd->vdev->unit_address;\n\tstruct list_head head;\n\tint retval;\n\n\tspin_lock(&hvcs_pi_lock);\n\tif (!hvcs_pi_buff) {\n\t\tspin_unlock(&hvcs_pi_lock);\n\t\treturn -EFAULT;\n\t}\n\tretval = hvcs_get_partner_info(unit_address, &head, hvcs_pi_buff);\n\tspin_unlock(&hvcs_pi_lock);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"HVCS: Failed to fetch partner\"\n\t\t\t\" info for vty-server@%x.\\n\", unit_address);\n\t\treturn retval;\n\t}\n\n\t \n\thvcsd->p_unit_address = 0;\n\thvcsd->p_partition_ID = 0;\n\n\tlist_for_each_entry(pi, &head, node)\n\t\thvcs_set_pi(pi, hvcsd);\n\n\thvcs_free_partner_info(&head);\n\treturn 0;\n}\n\n \nstatic int hvcs_rescan_devices_list(void)\n{\n\tstruct hvcs_struct *hvcsd;\n\tunsigned long flags;\n\n\tspin_lock(&hvcs_structs_lock);\n\n\tlist_for_each_entry(hvcsd, &hvcs_structs, next) {\n\t\tspin_lock_irqsave(&hvcsd->lock, flags);\n\t\thvcs_get_pi(hvcsd);\n\t\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\t}\n\n\tspin_unlock(&hvcs_structs_lock);\n\n\treturn 0;\n}\n\n \nstatic int hvcs_has_pi(struct hvcs_struct *hvcsd)\n{\n\tif ((!hvcsd->p_unit_address) || (!hvcsd->p_partition_ID))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int hvcs_partner_connect(struct hvcs_struct *hvcsd)\n{\n\tint retval;\n\tunsigned int unit_address = hvcsd->vdev->unit_address;\n\n\t \n\tretval = hvcs_register_connection(unit_address,\n\t\t\thvcsd->p_partition_ID,\n\t\t\thvcsd->p_unit_address);\n\tif (!retval) {\n\t\thvcsd->connected = 1;\n\t\treturn 0;\n\t} else if (retval != -EINVAL)\n\t\treturn retval;\n\n\t \n\tif (hvcs_get_pi(hvcsd))\n\t\treturn -ENOMEM;\n\n\tif (!hvcs_has_pi(hvcsd))\n\t\treturn -ENODEV;\n\n\tretval = hvcs_register_connection(unit_address,\n\t\t\thvcsd->p_partition_ID,\n\t\t\thvcsd->p_unit_address);\n\tif (retval != -EINVAL) {\n\t\thvcsd->connected = 1;\n\t\treturn retval;\n\t}\n\n\t \n\tprintk(KERN_INFO \"HVCS: vty-server or partner\"\n\t\t\t\" vty is busy.  Try again later.\\n\");\n\treturn -EBUSY;\n}\n\n \nstatic void hvcs_partner_free(struct hvcs_struct *hvcsd)\n{\n\tint retval;\n\tdo {\n\t\tretval = hvcs_free_connection(hvcsd->vdev->unit_address);\n\t} while (retval == -EBUSY);\n\thvcsd->connected = 0;\n}\n\n \nstatic int hvcs_enable_device(struct hvcs_struct *hvcsd, uint32_t unit_address,\n\t\tunsigned int irq, struct vio_dev *vdev)\n{\n\tunsigned long flags;\n\tint rc;\n\n\t \n\trc = request_irq(irq, &hvcs_handle_interrupt, 0, \"ibmhvcs\", hvcsd);\n\tif (!rc) {\n\t\t \n\t\tif (vio_enable_interrupts(vdev) == H_SUCCESS)\n\t\t\treturn 0;\n\t\telse {\n\t\t\tprintk(KERN_ERR \"HVCS: int enable failed for\"\n\t\t\t\t\t\" vty-server@%X.\\n\", unit_address);\n\t\t\tfree_irq(irq, hvcsd);\n\t\t}\n\t} else\n\t\tprintk(KERN_ERR \"HVCS: irq req failed for\"\n\t\t\t\t\" vty-server@%X.\\n\", unit_address);\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\thvcs_partner_free(hvcsd);\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\n\treturn rc;\n\n}\n\n \nstatic struct hvcs_struct *hvcs_get_by_index(int index)\n{\n\tstruct hvcs_struct *hvcsd;\n\tunsigned long flags;\n\n\tspin_lock(&hvcs_structs_lock);\n\tlist_for_each_entry(hvcsd, &hvcs_structs, next) {\n\t\tspin_lock_irqsave(&hvcsd->lock, flags);\n\t\tif (hvcsd->index == index) {\n\t\t\ttty_port_get(&hvcsd->port);\n\t\t\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\t\t\tspin_unlock(&hvcs_structs_lock);\n\t\t\treturn hvcsd;\n\t\t}\n\t\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\t}\n\tspin_unlock(&hvcs_structs_lock);\n\n\treturn NULL;\n}\n\nstatic int hvcs_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct hvcs_struct *hvcsd;\n\tstruct vio_dev *vdev;\n\tunsigned long unit_address, flags;\n\tunsigned int irq;\n\tint retval;\n\n\t \n\thvcsd = hvcs_get_by_index(tty->index);\n\tif (!hvcsd) {\n\t\tprintk(KERN_WARNING \"HVCS: open failed, no device associated\"\n\t\t\t\t\" with tty->index %d.\\n\", tty->index);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\n\tif (hvcsd->connected == 0) {\n\t\tretval = hvcs_partner_connect(hvcsd);\n\t\tif (retval) {\n\t\t\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\t\t\tprintk(KERN_WARNING \"HVCS: partner connect failed.\\n\");\n\t\t\tgoto err_put;\n\t\t}\n\t}\n\n\thvcsd->port.count = 0;\n\thvcsd->port.tty = tty;\n\ttty->driver_data = hvcsd;\n\n\tmemset(&hvcsd->buffer[0], 0x00, HVCS_BUFF_LEN);\n\n\t \n\tirq = hvcsd->vdev->irq;\n\tvdev = hvcsd->vdev;\n\tunit_address = hvcsd->vdev->unit_address;\n\n\thvcsd->todo_mask |= HVCS_SCHED_READ;\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\n\t \n\tretval = hvcs_enable_device(hvcsd, unit_address, irq, vdev);\n\tif (retval) {\n\t\tprintk(KERN_WARNING \"HVCS: enable device failed.\\n\");\n\t\tgoto err_put;\n\t}\n\n\tretval = tty_port_install(&hvcsd->port, driver, tty);\n\tif (retval)\n\t\tgoto err_irq;\n\n\treturn 0;\nerr_irq:\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\tvio_disable_interrupts(hvcsd->vdev);\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\tfree_irq(irq, hvcsd);\nerr_put:\n\ttty_port_put(&hvcsd->port);\n\n\treturn retval;\n}\n\n \nstatic int hvcs_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct hvcs_struct *hvcsd = tty->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\thvcsd->port.count++;\n\thvcsd->todo_mask |= HVCS_SCHED_READ;\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\n\thvcs_kick();\n\n\tprintk(KERN_INFO \"HVCS: vty-server@%X connection opened.\\n\",\n\t\thvcsd->vdev->unit_address );\n\n\treturn 0;\n}\n\nstatic void hvcs_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct hvcs_struct *hvcsd;\n\tunsigned long flags;\n\tint irq;\n\n\t \n\tif (tty_hung_up_p(filp))\n\t\treturn;\n\n\t \n\tif (!tty->driver_data)\n\t\treturn;\n\n\thvcsd = tty->driver_data;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\tif (hvcsd->port.count == 0) {\n\t\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\t\treturn;\n\t} else if (--hvcsd->port.count == 0) {\n\n\t\tvio_disable_interrupts(hvcsd->vdev);\n\n\t\t \n\t\thvcsd->port.tty = NULL;\n\n\t\tirq = hvcsd->vdev->irq;\n\t\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\n\t\ttty_wait_until_sent(tty, HVCS_CLOSE_WAIT);\n\n\t\tfree_irq(irq, hvcsd);\n\t\treturn;\n\t} else if (hvcsd->port.count < 0) {\n\t\tprintk(KERN_ERR \"HVCS: vty-server@%X open_count: %d is mismanaged.\\n\",\n\t\thvcsd->vdev->unit_address, hvcsd->port.count);\n\t}\n\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n}\n\nstatic void hvcs_cleanup(struct tty_struct * tty)\n{\n\tstruct hvcs_struct *hvcsd = tty->driver_data;\n\n\t \n\ttty->driver_data = NULL;\n\n\ttty_port_put(&hvcsd->port);\n}\n\nstatic void hvcs_hangup(struct tty_struct * tty)\n{\n\tstruct hvcs_struct *hvcsd = tty->driver_data;\n\tunsigned long flags;\n\tint irq;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\n\t \n\tvio_disable_interrupts(hvcsd->vdev);\n\n\thvcsd->todo_mask = 0;\n\thvcsd->port.tty = NULL;\n\thvcsd->port.count = 0;\n\n\t \n\tmemset(&hvcsd->buffer[0], 0x00, HVCS_BUFF_LEN);\n\thvcsd->chars_in_buffer = 0;\n\n\tirq = hvcsd->vdev->irq;\n\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\n\tfree_irq(irq, hvcsd);\n}\n\n \nstatic ssize_t hvcs_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tstruct hvcs_struct *hvcsd = tty->driver_data;\n\tunsigned int unit_address;\n\tconst unsigned char *charbuf;\n\tunsigned long flags;\n\tsize_t total_sent = 0;\n\tsize_t tosend = 0;\n\tint result = 0;\n\n\t \n\tif (!hvcsd)\n\t\treturn -ENODEV;\n\n\t \n\tif (count > HVCS_MAX_FROM_USER) {\n\t\tprintk(KERN_WARNING \"HVCS write: count being truncated to\"\n\t\t\t\t\" HVCS_MAX_FROM_USER.\\n\");\n\t\tcount = HVCS_MAX_FROM_USER;\n\t}\n\n\tcharbuf = buf;\n\n\tspin_lock_irqsave(&hvcsd->lock, flags);\n\n\t \n\tif (hvcsd->port.count <= 0) {\n\t\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tunit_address = hvcsd->vdev->unit_address;\n\n\twhile (count > 0) {\n\t\ttosend = min_t(size_t, count,\n\t\t\t       (HVCS_BUFF_LEN - hvcsd->chars_in_buffer));\n\t\t \n\t\tif (!tosend)\n\t\t\tbreak;\n\n\t\tmemcpy(&hvcsd->buffer[hvcsd->chars_in_buffer],\n\t\t\t\t&charbuf[total_sent],\n\t\t\t\ttosend);\n\n\t\thvcsd->chars_in_buffer += tosend;\n\n\t\tresult = 0;\n\n\t\t \n\t\tif (!(hvcsd->todo_mask & HVCS_TRY_WRITE))\n\t\t\t \n\t\t\tresult = hvc_put_chars(unit_address,\n\t\t\t\t\t&hvcsd->buffer[0],\n\t\t\t\t\thvcsd->chars_in_buffer);\n\n\t\t \n\t\ttotal_sent+=tosend;\n\t\tcount-=tosend;\n\t\tif (result == 0) {\n\t\t\thvcsd->todo_mask |= HVCS_TRY_WRITE;\n\t\t\thvcs_kick();\n\t\t\tbreak;\n\t\t}\n\n\t\thvcsd->chars_in_buffer = 0;\n\t\t \n\t\tif (result < 0)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&hvcsd->lock, flags);\n\n\tif (result == -1)\n\t\treturn -EIO;\n\telse\n\t\treturn total_sent;\n}\n\n \nstatic unsigned int hvcs_write_room(struct tty_struct *tty)\n{\n\tstruct hvcs_struct *hvcsd = tty->driver_data;\n\n\tif (!hvcsd || hvcsd->port.count <= 0)\n\t\treturn 0;\n\n\treturn HVCS_BUFF_LEN - hvcsd->chars_in_buffer;\n}\n\nstatic unsigned int hvcs_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct hvcs_struct *hvcsd = tty->driver_data;\n\n\treturn hvcsd->chars_in_buffer;\n}\n\nstatic const struct tty_operations hvcs_ops = {\n\t.install = hvcs_install,\n\t.open = hvcs_open,\n\t.close = hvcs_close,\n\t.cleanup = hvcs_cleanup,\n\t.hangup = hvcs_hangup,\n\t.write = hvcs_write,\n\t.write_room = hvcs_write_room,\n\t.chars_in_buffer = hvcs_chars_in_buffer,\n\t.unthrottle = hvcs_unthrottle,\n\t.throttle = hvcs_throttle,\n};\n\nstatic int hvcs_alloc_index_list(int n)\n{\n\tint i;\n\n\thvcs_index_list = kmalloc_array(n, sizeof(hvcs_index_count),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!hvcs_index_list)\n\t\treturn -ENOMEM;\n\thvcs_index_count = n;\n\tfor (i = 0; i < hvcs_index_count; i++)\n\t\thvcs_index_list[i] = -1;\n\treturn 0;\n}\n\nstatic void hvcs_free_index_list(void)\n{\n\t \n\tkfree(hvcs_index_list);\n\thvcs_index_list = NULL;\n\thvcs_index_count = 0;\n}\n\nstatic int hvcs_initialize(void)\n{\n\tint rc, num_ttys_to_alloc;\n\n\tmutex_lock(&hvcs_init_mutex);\n\tif (hvcs_task) {\n\t\tmutex_unlock(&hvcs_init_mutex);\n\t\treturn 0;\n\t}\n\n\t \n\tif (hvcs_parm_num_devs <= 0 ||\n\t\t(hvcs_parm_num_devs > HVCS_MAX_SERVER_ADAPTERS)) {\n\t\tnum_ttys_to_alloc = HVCS_DEFAULT_SERVER_ADAPTERS;\n\t} else\n\t\tnum_ttys_to_alloc = hvcs_parm_num_devs;\n\n\thvcs_tty_driver = tty_alloc_driver(num_ttys_to_alloc,\n\t\t\tTTY_DRIVER_REAL_RAW);\n\tif (IS_ERR(hvcs_tty_driver)) {\n\t\tmutex_unlock(&hvcs_init_mutex);\n\t\treturn PTR_ERR(hvcs_tty_driver);\n\t}\n\n\tif (hvcs_alloc_index_list(num_ttys_to_alloc)) {\n\t\trc = -ENOMEM;\n\t\tgoto index_fail;\n\t}\n\n\thvcs_tty_driver->driver_name = hvcs_driver_name;\n\thvcs_tty_driver->name = hvcs_device_node;\n\n\t \n\n\thvcs_tty_driver->minor_start = HVCS_MINOR_START;\n\thvcs_tty_driver->type = TTY_DRIVER_TYPE_SYSTEM;\n\n\t \n\thvcs_tty_driver->init_termios = hvcs_tty_termios;\n\n\ttty_set_operations(hvcs_tty_driver, &hvcs_ops);\n\n\t \n\tif (tty_register_driver(hvcs_tty_driver)) {\n\t\tprintk(KERN_ERR \"HVCS: registration as a tty driver failed.\\n\");\n\t\trc = -EIO;\n\t\tgoto register_fail;\n\t}\n\n\thvcs_pi_buff = (unsigned long *) __get_free_page(GFP_KERNEL);\n\tif (!hvcs_pi_buff) {\n\t\trc = -ENOMEM;\n\t\tgoto buff_alloc_fail;\n\t}\n\n\thvcs_task = kthread_run(khvcsd, NULL, \"khvcsd\");\n\tif (IS_ERR(hvcs_task)) {\n\t\tprintk(KERN_ERR \"HVCS: khvcsd creation failed.\\n\");\n\t\trc = -EIO;\n\t\tgoto kthread_fail;\n\t}\n\tmutex_unlock(&hvcs_init_mutex);\n\treturn 0;\n\nkthread_fail:\n\tfree_page((unsigned long)hvcs_pi_buff);\nbuff_alloc_fail:\n\ttty_unregister_driver(hvcs_tty_driver);\nregister_fail:\n\thvcs_free_index_list();\nindex_fail:\n\ttty_driver_kref_put(hvcs_tty_driver);\n\thvcs_tty_driver = NULL;\n\tmutex_unlock(&hvcs_init_mutex);\n\treturn rc;\n}\n\nstatic int __init hvcs_module_init(void)\n{\n\tint rc = vio_register_driver(&hvcs_vio_driver);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"HVCS: can't register vio driver\\n\");\n\t\treturn rc;\n\t}\n\n\tpr_info(\"HVCS: Driver registered.\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit hvcs_module_exit(void)\n{\n\t \n\tvio_unregister_driver(&hvcs_vio_driver);\n\tif (!hvcs_task)\n\t\treturn;\n\n\t \n\tkthread_stop(hvcs_task);\n\n\tspin_lock(&hvcs_pi_lock);\n\tfree_page((unsigned long)hvcs_pi_buff);\n\thvcs_pi_buff = NULL;\n\tspin_unlock(&hvcs_pi_lock);\n\n\ttty_unregister_driver(hvcs_tty_driver);\n\n\thvcs_free_index_list();\n\n\ttty_driver_kref_put(hvcs_tty_driver);\n\n\tprintk(KERN_INFO \"HVCS: driver module removed.\\n\");\n}\n\nmodule_init(hvcs_module_init);\nmodule_exit(hvcs_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}