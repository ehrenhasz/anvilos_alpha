{
  "module_name": "tty_io.c",
  "hash_id": "f003f0508b6a752b0178a8b96fb436660c5452d1d5877c76fa4a3e3b3cb706d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/tty_io.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/fcntl.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/devpts_fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/console.h>\n#include <linux/timer.h>\n#include <linux/ctype.h>\n#include <linux/kd.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/wait.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/seq_file.h>\n#include <linux/serial.h>\n#include <linux/ratelimit.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/termios_internal.h>\n#include <linux/fs.h>\n\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/selection.h>\n\n#include <linux/kmod.h>\n#include <linux/nsproxy.h>\n#include \"tty.h\"\n\n#undef TTY_DEBUG_HANGUP\n#ifdef TTY_DEBUG_HANGUP\n# define tty_debug_hangup(tty, f, args...)\ttty_debug(tty, f, ##args)\n#else\n# define tty_debug_hangup(tty, f, args...)\tdo { } while (0)\n#endif\n\n#define TTY_PARANOIA_CHECK 1\n#define CHECK_TTY_COUNT 1\n\nstruct ktermios tty_std_termios = {\t \n\t.c_iflag = ICRNL | IXON,\n\t.c_oflag = OPOST | ONLCR,\n\t.c_cflag = B38400 | CS8 | CREAD | HUPCL,\n\t.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK |\n\t\t   ECHOCTL | ECHOKE | IEXTEN,\n\t.c_cc = INIT_C_CC,\n\t.c_ispeed = 38400,\n\t.c_ospeed = 38400,\n\t \n};\nEXPORT_SYMBOL(tty_std_termios);\n\n \n\nLIST_HEAD(tty_drivers);\t\t\t \n\n \nDEFINE_MUTEX(tty_mutex);\n\nstatic ssize_t tty_read(struct kiocb *, struct iov_iter *);\nstatic ssize_t tty_write(struct kiocb *, struct iov_iter *);\nstatic __poll_t tty_poll(struct file *, poll_table *);\nstatic int tty_open(struct inode *, struct file *);\n#ifdef CONFIG_COMPAT\nstatic long tty_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg);\n#else\n#define tty_compat_ioctl NULL\n#endif\nstatic int __tty_fasync(int fd, struct file *filp, int on);\nstatic int tty_fasync(int fd, struct file *filp, int on);\nstatic void release_tty(struct tty_struct *tty, int idx);\n\n \nstatic void free_tty_struct(struct tty_struct *tty)\n{\n\ttty_ldisc_deinit(tty);\n\tput_device(tty->dev);\n\tkvfree(tty->write_buf);\n\tkfree(tty);\n}\n\nstatic inline struct tty_struct *file_tty(struct file *file)\n{\n\treturn ((struct tty_file_private *)file->private_data)->tty;\n}\n\nint tty_alloc_file(struct file *file)\n{\n\tstruct tty_file_private *priv;\n\n\tpriv = kmalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tfile->private_data = priv;\n\n\treturn 0;\n}\n\n \nvoid tty_add_file(struct tty_struct *tty, struct file *file)\n{\n\tstruct tty_file_private *priv = file->private_data;\n\n\tpriv->tty = tty;\n\tpriv->file = file;\n\n\tspin_lock(&tty->files_lock);\n\tlist_add(&priv->list, &tty->tty_files);\n\tspin_unlock(&tty->files_lock);\n}\n\n \nvoid tty_free_file(struct file *file)\n{\n\tstruct tty_file_private *priv = file->private_data;\n\n\tfile->private_data = NULL;\n\tkfree(priv);\n}\n\n \nstatic void tty_del_file(struct file *file)\n{\n\tstruct tty_file_private *priv = file->private_data;\n\tstruct tty_struct *tty = priv->tty;\n\n\tspin_lock(&tty->files_lock);\n\tlist_del(&priv->list);\n\tspin_unlock(&tty->files_lock);\n\ttty_free_file(file);\n}\n\n \nconst char *tty_name(const struct tty_struct *tty)\n{\n\tif (!tty)  \n\t\treturn \"NULL tty\";\n\treturn tty->name;\n}\nEXPORT_SYMBOL(tty_name);\n\nconst char *tty_driver_name(const struct tty_struct *tty)\n{\n\tif (!tty || !tty->driver)\n\t\treturn \"\";\n\treturn tty->driver->name;\n}\n\nstatic int tty_paranoia_check(struct tty_struct *tty, struct inode *inode,\n\t\t\t      const char *routine)\n{\n#ifdef TTY_PARANOIA_CHECK\n\tif (!tty) {\n\t\tpr_warn(\"(%d:%d): %s: NULL tty\\n\",\n\t\t\timajor(inode), iminor(inode), routine);\n\t\treturn 1;\n\t}\n#endif\n\treturn 0;\n}\n\n \nstatic void check_tty_count(struct tty_struct *tty, const char *routine)\n{\n#ifdef CHECK_TTY_COUNT\n\tstruct list_head *p;\n\tint count = 0, kopen_count = 0;\n\n\tspin_lock(&tty->files_lock);\n\tlist_for_each(p, &tty->tty_files) {\n\t\tcount++;\n\t}\n\tspin_unlock(&tty->files_lock);\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\n\t    tty->driver->subtype == PTY_TYPE_SLAVE &&\n\t    tty->link && tty->link->count)\n\t\tcount++;\n\tif (tty_port_kopened(tty->port))\n\t\tkopen_count++;\n\tif (tty->count != (count + kopen_count)) {\n\t\ttty_warn(tty, \"%s: tty->count(%d) != (#fd's(%d) + #kopen's(%d))\\n\",\n\t\t\t routine, tty->count, count, kopen_count);\n\t}\n#endif\n}\n\n \nstatic struct tty_driver *get_tty_driver(dev_t device, int *index)\n{\n\tstruct tty_driver *p;\n\n\tlist_for_each_entry(p, &tty_drivers, tty_drivers) {\n\t\tdev_t base = MKDEV(p->major, p->minor_start);\n\n\t\tif (device < base || device >= base + p->num)\n\t\t\tcontinue;\n\t\t*index = device - base;\n\t\treturn tty_driver_kref_get(p);\n\t}\n\treturn NULL;\n}\n\n \nint tty_dev_name_to_number(const char *name, dev_t *number)\n{\n\tstruct tty_driver *p;\n\tint ret;\n\tint index, prefix_length = 0;\n\tconst char *str;\n\n\tfor (str = name; *str && !isdigit(*str); str++)\n\t\t;\n\n\tif (!*str)\n\t\treturn -EINVAL;\n\n\tret = kstrtoint(str, 10, &index);\n\tif (ret)\n\t\treturn ret;\n\n\tprefix_length = str - name;\n\tmutex_lock(&tty_mutex);\n\n\tlist_for_each_entry(p, &tty_drivers, tty_drivers)\n\t\tif (prefix_length == strlen(p->name) && strncmp(name,\n\t\t\t\t\tp->name, prefix_length) == 0) {\n\t\t\tif (index < p->num) {\n\t\t\t\t*number = MKDEV(p->major, p->minor_start + index);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t \n\tret = -ENODEV;\nout:\n\tmutex_unlock(&tty_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tty_dev_name_to_number);\n\n#ifdef CONFIG_CONSOLE_POLL\n\n \nstruct tty_driver *tty_find_polling_driver(char *name, int *line)\n{\n\tstruct tty_driver *p, *res = NULL;\n\tint tty_line = 0;\n\tint len;\n\tchar *str, *stp;\n\n\tfor (str = name; *str; str++)\n\t\tif ((*str >= '0' && *str <= '9') || *str == ',')\n\t\t\tbreak;\n\tif (!*str)\n\t\treturn NULL;\n\n\tlen = str - name;\n\ttty_line = simple_strtoul(str, &str, 10);\n\n\tmutex_lock(&tty_mutex);\n\t \n\tlist_for_each_entry(p, &tty_drivers, tty_drivers) {\n\t\tif (!len || strncmp(name, p->name, len) != 0)\n\t\t\tcontinue;\n\t\tstp = str;\n\t\tif (*stp == ',')\n\t\t\tstp++;\n\t\tif (*stp == '\\0')\n\t\t\tstp = NULL;\n\n\t\tif (tty_line >= 0 && tty_line < p->num && p->ops &&\n\t\t    p->ops->poll_init && !p->ops->poll_init(p, tty_line, stp)) {\n\t\t\tres = tty_driver_kref_get(p);\n\t\t\t*line = tty_line;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&tty_mutex);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(tty_find_polling_driver);\n#endif\n\nstatic ssize_t hung_up_tty_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\treturn 0;\n}\n\nstatic ssize_t hung_up_tty_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\treturn -EIO;\n}\n\n \nstatic __poll_t hung_up_tty_poll(struct file *filp, poll_table *wait)\n{\n\treturn EPOLLIN | EPOLLOUT | EPOLLERR | EPOLLHUP | EPOLLRDNORM | EPOLLWRNORM;\n}\n\nstatic long hung_up_tty_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\treturn cmd == TIOCSPGRP ? -ENOTTY : -EIO;\n}\n\nstatic long hung_up_tty_compat_ioctl(struct file *file,\n\t\t\t\t     unsigned int cmd, unsigned long arg)\n{\n\treturn cmd == TIOCSPGRP ? -ENOTTY : -EIO;\n}\n\nstatic int hung_up_tty_fasync(int fd, struct file *file, int on)\n{\n\treturn -ENOTTY;\n}\n\nstatic void tty_show_fdinfo(struct seq_file *m, struct file *file)\n{\n\tstruct tty_struct *tty = file_tty(file);\n\n\tif (tty && tty->ops && tty->ops->show_fdinfo)\n\t\ttty->ops->show_fdinfo(tty, m);\n}\n\nstatic const struct file_operations tty_fops = {\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= tty_read,\n\t.write_iter\t= tty_write,\n\t.splice_read\t= copy_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.poll\t\t= tty_poll,\n\t.unlocked_ioctl\t= tty_ioctl,\n\t.compat_ioctl\t= tty_compat_ioctl,\n\t.open\t\t= tty_open,\n\t.release\t= tty_release,\n\t.fasync\t\t= tty_fasync,\n\t.show_fdinfo\t= tty_show_fdinfo,\n};\n\nstatic const struct file_operations console_fops = {\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= tty_read,\n\t.write_iter\t= redirected_tty_write,\n\t.splice_read\t= copy_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.poll\t\t= tty_poll,\n\t.unlocked_ioctl\t= tty_ioctl,\n\t.compat_ioctl\t= tty_compat_ioctl,\n\t.open\t\t= tty_open,\n\t.release\t= tty_release,\n\t.fasync\t\t= tty_fasync,\n};\n\nstatic const struct file_operations hung_up_tty_fops = {\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= hung_up_tty_read,\n\t.write_iter\t= hung_up_tty_write,\n\t.poll\t\t= hung_up_tty_poll,\n\t.unlocked_ioctl\t= hung_up_tty_ioctl,\n\t.compat_ioctl\t= hung_up_tty_compat_ioctl,\n\t.release\t= tty_release,\n\t.fasync\t\t= hung_up_tty_fasync,\n};\n\nstatic DEFINE_SPINLOCK(redirect_lock);\nstatic struct file *redirect;\n\n \nvoid tty_wakeup(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld;\n\n\tif (test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) {\n\t\tld = tty_ldisc_ref(tty);\n\t\tif (ld) {\n\t\t\tif (ld->ops->write_wakeup)\n\t\t\t\tld->ops->write_wakeup(tty);\n\t\t\ttty_ldisc_deref(ld);\n\t\t}\n\t}\n\twake_up_interruptible_poll(&tty->write_wait, EPOLLOUT);\n}\nEXPORT_SYMBOL_GPL(tty_wakeup);\n\n \nstatic struct file *tty_release_redirect(struct tty_struct *tty)\n{\n\tstruct file *f = NULL;\n\n\tspin_lock(&redirect_lock);\n\tif (redirect && file_tty(redirect) == tty) {\n\t\tf = redirect;\n\t\tredirect = NULL;\n\t}\n\tspin_unlock(&redirect_lock);\n\n\treturn f;\n}\n\n \nstatic void __tty_hangup(struct tty_struct *tty, int exit_session)\n{\n\tstruct file *cons_filp = NULL;\n\tstruct file *filp, *f;\n\tstruct tty_file_private *priv;\n\tint    closecount = 0, n;\n\tint refs;\n\n\tif (!tty)\n\t\treturn;\n\n\tf = tty_release_redirect(tty);\n\n\ttty_lock(tty);\n\n\tif (test_bit(TTY_HUPPED, &tty->flags)) {\n\t\ttty_unlock(tty);\n\t\treturn;\n\t}\n\n\t \n\tset_bit(TTY_HUPPING, &tty->flags);\n\n\t \n\tcheck_tty_count(tty, \"tty_hangup\");\n\n\tspin_lock(&tty->files_lock);\n\t \n\tlist_for_each_entry(priv, &tty->tty_files, list) {\n\t\tfilp = priv->file;\n\t\tif (filp->f_op->write_iter == redirected_tty_write)\n\t\t\tcons_filp = filp;\n\t\tif (filp->f_op->write_iter != tty_write)\n\t\t\tcontinue;\n\t\tclosecount++;\n\t\t__tty_fasync(-1, filp, 0);\t \n\t\tfilp->f_op = &hung_up_tty_fops;\n\t}\n\tspin_unlock(&tty->files_lock);\n\n\trefs = tty_signal_session_leader(tty, exit_session);\n\t \n\twhile (refs--)\n\t\ttty_kref_put(tty);\n\n\ttty_ldisc_hangup(tty, cons_filp != NULL);\n\n\tspin_lock_irq(&tty->ctrl.lock);\n\tclear_bit(TTY_THROTTLED, &tty->flags);\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tput_pid(tty->ctrl.session);\n\tput_pid(tty->ctrl.pgrp);\n\ttty->ctrl.session = NULL;\n\ttty->ctrl.pgrp = NULL;\n\ttty->ctrl.pktstatus = 0;\n\tspin_unlock_irq(&tty->ctrl.lock);\n\n\t \n\tif (cons_filp) {\n\t\tif (tty->ops->close)\n\t\t\tfor (n = 0; n < closecount; n++)\n\t\t\t\ttty->ops->close(tty, cons_filp);\n\t} else if (tty->ops->hangup)\n\t\ttty->ops->hangup(tty);\n\t \n\tset_bit(TTY_HUPPED, &tty->flags);\n\tclear_bit(TTY_HUPPING, &tty->flags);\n\ttty_unlock(tty);\n\n\tif (f)\n\t\tfput(f);\n}\n\nstatic void do_tty_hangup(struct work_struct *work)\n{\n\tstruct tty_struct *tty =\n\t\tcontainer_of(work, struct tty_struct, hangup_work);\n\n\t__tty_hangup(tty, 0);\n}\n\n \nvoid tty_hangup(struct tty_struct *tty)\n{\n\ttty_debug_hangup(tty, \"hangup\\n\");\n\tschedule_work(&tty->hangup_work);\n}\nEXPORT_SYMBOL(tty_hangup);\n\n \nvoid tty_vhangup(struct tty_struct *tty)\n{\n\ttty_debug_hangup(tty, \"vhangup\\n\");\n\t__tty_hangup(tty, 0);\n}\nEXPORT_SYMBOL(tty_vhangup);\n\n\n \nvoid tty_vhangup_self(void)\n{\n\tstruct tty_struct *tty;\n\n\ttty = get_current_tty();\n\tif (tty) {\n\t\ttty_vhangup(tty);\n\t\ttty_kref_put(tty);\n\t}\n}\n\n \nvoid tty_vhangup_session(struct tty_struct *tty)\n{\n\ttty_debug_hangup(tty, \"session hangup\\n\");\n\t__tty_hangup(tty, 1);\n}\n\n \nint tty_hung_up_p(struct file *filp)\n{\n\treturn (filp && filp->f_op == &hung_up_tty_fops);\n}\nEXPORT_SYMBOL(tty_hung_up_p);\n\nvoid __stop_tty(struct tty_struct *tty)\n{\n\tif (tty->flow.stopped)\n\t\treturn;\n\ttty->flow.stopped = true;\n\tif (tty->ops->stop)\n\t\ttty->ops->stop(tty);\n}\n\n \nvoid stop_tty(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tty->flow.lock, flags);\n\t__stop_tty(tty);\n\tspin_unlock_irqrestore(&tty->flow.lock, flags);\n}\nEXPORT_SYMBOL(stop_tty);\n\nvoid __start_tty(struct tty_struct *tty)\n{\n\tif (!tty->flow.stopped || tty->flow.tco_stopped)\n\t\treturn;\n\ttty->flow.stopped = false;\n\tif (tty->ops->start)\n\t\ttty->ops->start(tty);\n\ttty_wakeup(tty);\n}\n\n \nvoid start_tty(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tty->flow.lock, flags);\n\t__start_tty(tty);\n\tspin_unlock_irqrestore(&tty->flow.lock, flags);\n}\nEXPORT_SYMBOL(start_tty);\n\nstatic void tty_update_time(struct tty_struct *tty, bool mtime)\n{\n\ttime64_t sec = ktime_get_real_seconds();\n\tstruct tty_file_private *priv;\n\n\tspin_lock(&tty->files_lock);\n\tlist_for_each_entry(priv, &tty->tty_files, list) {\n\t\tstruct inode *inode = file_inode(priv->file);\n\t\tstruct timespec64 *time = mtime ? &inode->i_mtime : &inode->i_atime;\n\n\t\t \n\t\tif ((sec ^ time->tv_sec) & ~7)\n\t\t\ttime->tv_sec = sec;\n\t}\n\tspin_unlock(&tty->files_lock);\n}\n\n \nstatic ssize_t iterate_tty_read(struct tty_ldisc *ld, struct tty_struct *tty,\n\t\t\t\tstruct file *file, struct iov_iter *to)\n{\n\tvoid *cookie = NULL;\n\tunsigned long offset = 0;\n\tchar kernel_buf[64];\n\tssize_t retval = 0;\n\tsize_t copied, count = iov_iter_count(to);\n\n\tdo {\n\t\tssize_t size = min(count, sizeof(kernel_buf));\n\n\t\tsize = ld->ops->read(tty, file, kernel_buf, size, &cookie, offset);\n\t\tif (!size)\n\t\t\tbreak;\n\n\t\tif (size < 0) {\n\t\t\t \n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t\tretval = size;\n\n\t\t\t \n\t\t\tif (retval == -EOVERFLOW)\n\t\t\t\toffset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcopied = copy_to_iter(kernel_buf, size, to);\n\t\toffset += copied;\n\t\tcount -= copied;\n\n\t\t \n\t\tif (unlikely(copied != size)) {\n\t\t\tcount = 0;\n\t\t\tretval = -EFAULT;\n\t\t}\n\t} while (cookie);\n\n\t \n\tmemzero_explicit(kernel_buf, sizeof(kernel_buf));\n\treturn offset ? offset : retval;\n}\n\n\n \nstatic ssize_t tty_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct tty_struct *tty = file_tty(file);\n\tstruct tty_ldisc *ld;\n\tssize_t ret;\n\n\tif (tty_paranoia_check(tty, inode, \"tty_read\"))\n\t\treturn -EIO;\n\tif (!tty || tty_io_error(tty))\n\t\treturn -EIO;\n\n\t \n\tld = tty_ldisc_ref_wait(tty);\n\tif (!ld)\n\t\treturn hung_up_tty_read(iocb, to);\n\tret = -EIO;\n\tif (ld->ops->read)\n\t\tret = iterate_tty_read(ld, tty, file, to);\n\ttty_ldisc_deref(ld);\n\n\tif (ret > 0)\n\t\ttty_update_time(tty, false);\n\n\treturn ret;\n}\n\nvoid tty_write_unlock(struct tty_struct *tty)\n{\n\tmutex_unlock(&tty->atomic_write_lock);\n\twake_up_interruptible_poll(&tty->write_wait, EPOLLOUT);\n}\n\nint tty_write_lock(struct tty_struct *tty, bool ndelay)\n{\n\tif (!mutex_trylock(&tty->atomic_write_lock)) {\n\t\tif (ndelay)\n\t\t\treturn -EAGAIN;\n\t\tif (mutex_lock_interruptible(&tty->atomic_write_lock))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\treturn 0;\n}\n\n \nstatic ssize_t iterate_tty_write(struct tty_ldisc *ld, struct tty_struct *tty,\n\t\t\t\t struct file *file, struct iov_iter *from)\n{\n\tsize_t chunk, count = iov_iter_count(from);\n\tssize_t ret, written = 0;\n\n\tret = tty_write_lock(tty, file->f_flags & O_NDELAY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tchunk = 2048;\n\tif (test_bit(TTY_NO_WRITE_SPLIT, &tty->flags))\n\t\tchunk = 65536;\n\tif (count < chunk)\n\t\tchunk = count;\n\n\t \n\tif (tty->write_cnt < chunk) {\n\t\tunsigned char *buf_chunk;\n\n\t\tif (chunk < 1024)\n\t\t\tchunk = 1024;\n\n\t\tbuf_chunk = kvmalloc(chunk, GFP_KERNEL | __GFP_RETRY_MAYFAIL);\n\t\tif (!buf_chunk) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tkvfree(tty->write_buf);\n\t\ttty->write_cnt = chunk;\n\t\ttty->write_buf = buf_chunk;\n\t}\n\n\t \n\tfor (;;) {\n\t\tsize_t size = min(chunk, count);\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_iter(tty->write_buf, size, from) != size)\n\t\t\tbreak;\n\n\t\tret = ld->ops->write(tty, file, tty->write_buf, size);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\twritten += ret;\n\t\tif (ret > size)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ret != size)\n\t\t\tiov_iter_revert(from, size-ret);\n\n\t\tcount -= ret;\n\t\tif (!count)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (written) {\n\t\ttty_update_time(tty, true);\n\t\tret = written;\n\t}\nout:\n\ttty_write_unlock(tty);\n\treturn ret;\n}\n\n \nvoid tty_write_message(struct tty_struct *tty, char *msg)\n{\n\tif (tty) {\n\t\tmutex_lock(&tty->atomic_write_lock);\n\t\ttty_lock(tty);\n\t\tif (tty->ops->write && tty->count > 0)\n\t\t\ttty->ops->write(tty, msg, strlen(msg));\n\t\ttty_unlock(tty);\n\t\ttty_write_unlock(tty);\n\t}\n}\n\nstatic ssize_t file_tty_write(struct file *file, struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct tty_struct *tty = file_tty(file);\n\tstruct tty_ldisc *ld;\n\tssize_t ret;\n\n\tif (tty_paranoia_check(tty, file_inode(file), \"tty_write\"))\n\t\treturn -EIO;\n\tif (!tty || !tty->ops->write ||\ttty_io_error(tty))\n\t\treturn -EIO;\n\t \n\tif (tty->ops->write_room == NULL)\n\t\ttty_err(tty, \"missing write_room method\\n\");\n\tld = tty_ldisc_ref_wait(tty);\n\tif (!ld)\n\t\treturn hung_up_tty_write(iocb, from);\n\tif (!ld->ops->write)\n\t\tret = -EIO;\n\telse\n\t\tret = iterate_tty_write(ld, tty, file, from);\n\ttty_ldisc_deref(ld);\n\treturn ret;\n}\n\n \nstatic ssize_t tty_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\treturn file_tty_write(iocb->ki_filp, iocb, from);\n}\n\nssize_t redirected_tty_write(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *p = NULL;\n\n\tspin_lock(&redirect_lock);\n\tif (redirect)\n\t\tp = get_file(redirect);\n\tspin_unlock(&redirect_lock);\n\n\t \n\tif (p) {\n\t\tssize_t res;\n\n\t\tres = file_tty_write(p, iocb, iter);\n\t\tfput(p);\n\t\treturn res;\n\t}\n\treturn tty_write(iocb, iter);\n}\n\n \nint tty_send_xchar(struct tty_struct *tty, char ch)\n{\n\tbool was_stopped = tty->flow.stopped;\n\n\tif (tty->ops->send_xchar) {\n\t\tdown_read(&tty->termios_rwsem);\n\t\ttty->ops->send_xchar(tty, ch);\n\t\tup_read(&tty->termios_rwsem);\n\t\treturn 0;\n\t}\n\n\tif (tty_write_lock(tty, false) < 0)\n\t\treturn -ERESTARTSYS;\n\n\tdown_read(&tty->termios_rwsem);\n\tif (was_stopped)\n\t\tstart_tty(tty);\n\ttty->ops->write(tty, &ch, 1);\n\tif (was_stopped)\n\t\tstop_tty(tty);\n\tup_read(&tty->termios_rwsem);\n\ttty_write_unlock(tty);\n\treturn 0;\n}\n\n \nstatic void pty_line_name(struct tty_driver *driver, int index, char *p)\n{\n\tstatic const char ptychar[] = \"pqrstuvwxyzabcde\";\n\tint i = index + driver->name_base;\n\t \n\tsprintf(p, \"%s%c%x\",\n\t\tdriver->subtype == PTY_TYPE_SLAVE ? \"tty\" : driver->name,\n\t\tptychar[i >> 4 & 0xf], i & 0xf);\n}\n\n \nstatic ssize_t tty_line_name(struct tty_driver *driver, int index, char *p)\n{\n\tif (driver->flags & TTY_DRIVER_UNNUMBERED_NODE)\n\t\treturn sprintf(p, \"%s\", driver->name);\n\telse\n\t\treturn sprintf(p, \"%s%d\", driver->name,\n\t\t\t       index + driver->name_base);\n}\n\n \nstatic struct tty_struct *tty_driver_lookup_tty(struct tty_driver *driver,\n\t\tstruct file *file, int idx)\n{\n\tstruct tty_struct *tty;\n\n\tif (driver->ops->lookup) {\n\t\tif (!file)\n\t\t\ttty = ERR_PTR(-EIO);\n\t\telse\n\t\t\ttty = driver->ops->lookup(driver, file, idx);\n\t} else {\n\t\tif (idx >= driver->num)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\ttty = driver->ttys[idx];\n\t}\n\tif (!IS_ERR(tty))\n\t\ttty_kref_get(tty);\n\treturn tty;\n}\n\n \nvoid tty_init_termios(struct tty_struct *tty)\n{\n\tstruct ktermios *tp;\n\tint idx = tty->index;\n\n\tif (tty->driver->flags & TTY_DRIVER_RESET_TERMIOS)\n\t\ttty->termios = tty->driver->init_termios;\n\telse {\n\t\t \n\t\ttp = tty->driver->termios[idx];\n\t\tif (tp != NULL) {\n\t\t\ttty->termios = *tp;\n\t\t\ttty->termios.c_line  = tty->driver->init_termios.c_line;\n\t\t} else\n\t\t\ttty->termios = tty->driver->init_termios;\n\t}\n\t \n\ttty->termios.c_ispeed = tty_termios_input_baud_rate(&tty->termios);\n\ttty->termios.c_ospeed = tty_termios_baud_rate(&tty->termios);\n}\nEXPORT_SYMBOL_GPL(tty_init_termios);\n\n \nint tty_standard_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\ttty_init_termios(tty);\n\ttty_driver_kref_get(driver);\n\ttty->count++;\n\tdriver->ttys[tty->index] = tty;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tty_standard_install);\n\n \nstatic int tty_driver_install_tty(struct tty_driver *driver,\n\t\t\t\t\t\tstruct tty_struct *tty)\n{\n\treturn driver->ops->install ? driver->ops->install(driver, tty) :\n\t\ttty_standard_install(driver, tty);\n}\n\n \nstatic void tty_driver_remove_tty(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tif (driver->ops->remove)\n\t\tdriver->ops->remove(driver, tty);\n\telse\n\t\tdriver->ttys[tty->index] = NULL;\n}\n\n \nstatic int tty_reopen(struct tty_struct *tty)\n{\n\tstruct tty_driver *driver = tty->driver;\n\tstruct tty_ldisc *ld;\n\tint retval = 0;\n\n\tif (driver->type == TTY_DRIVER_TYPE_PTY &&\n\t    driver->subtype == PTY_TYPE_MASTER)\n\t\treturn -EIO;\n\n\tif (!tty->count)\n\t\treturn -EAGAIN;\n\n\tif (test_bit(TTY_EXCLUSIVE, &tty->flags) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EBUSY;\n\n\tld = tty_ldisc_ref_wait(tty);\n\tif (ld) {\n\t\ttty_ldisc_deref(ld);\n\t} else {\n\t\tretval = tty_ldisc_lock(tty, 5 * HZ);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tif (!tty->ldisc)\n\t\t\tretval = tty_ldisc_reinit(tty, tty->termios.c_line);\n\t\ttty_ldisc_unlock(tty);\n\t}\n\n\tif (retval == 0)\n\t\ttty->count++;\n\n\treturn retval;\n}\n\n \nstruct tty_struct *tty_init_dev(struct tty_driver *driver, int idx)\n{\n\tstruct tty_struct *tty;\n\tint retval;\n\n\t \n\n\tif (!try_module_get(driver->owner))\n\t\treturn ERR_PTR(-ENODEV);\n\n\ttty = alloc_tty_struct(driver, idx);\n\tif (!tty) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_module_put;\n\t}\n\n\ttty_lock(tty);\n\tretval = tty_driver_install_tty(driver, tty);\n\tif (retval < 0)\n\t\tgoto err_free_tty;\n\n\tif (!tty->port)\n\t\ttty->port = driver->ports[idx];\n\n\tif (WARN_RATELIMIT(!tty->port,\n\t\t\t\"%s: %s driver does not set tty->port. This would crash the kernel. Fix the driver!\\n\",\n\t\t\t__func__, tty->driver->name)) {\n\t\tretval = -EINVAL;\n\t\tgoto err_release_lock;\n\t}\n\n\tretval = tty_ldisc_lock(tty, 5 * HZ);\n\tif (retval)\n\t\tgoto err_release_lock;\n\ttty->port->itty = tty;\n\n\t \n\tretval = tty_ldisc_setup(tty, tty->link);\n\tif (retval)\n\t\tgoto err_release_tty;\n\ttty_ldisc_unlock(tty);\n\t \n\treturn tty;\n\nerr_free_tty:\n\ttty_unlock(tty);\n\tfree_tty_struct(tty);\nerr_module_put:\n\tmodule_put(driver->owner);\n\treturn ERR_PTR(retval);\n\n\t \nerr_release_tty:\n\ttty_ldisc_unlock(tty);\n\ttty_info_ratelimited(tty, \"ldisc open failed (%d), clearing slot %d\\n\",\n\t\t\t     retval, idx);\nerr_release_lock:\n\ttty_unlock(tty);\n\trelease_tty(tty, idx);\n\treturn ERR_PTR(retval);\n}\n\n \nvoid tty_save_termios(struct tty_struct *tty)\n{\n\tstruct ktermios *tp;\n\tint idx = tty->index;\n\n\t \n\tif (tty->driver->flags & TTY_DRIVER_RESET_TERMIOS)\n\t\treturn;\n\n\t \n\ttp = tty->driver->termios[idx];\n\tif (tp == NULL) {\n\t\ttp = kmalloc(sizeof(*tp), GFP_KERNEL);\n\t\tif (tp == NULL)\n\t\t\treturn;\n\t\ttty->driver->termios[idx] = tp;\n\t}\n\t*tp = tty->termios;\n}\nEXPORT_SYMBOL_GPL(tty_save_termios);\n\n \nstatic void tty_flush_works(struct tty_struct *tty)\n{\n\tflush_work(&tty->SAK_work);\n\tflush_work(&tty->hangup_work);\n\tif (tty->link) {\n\t\tflush_work(&tty->link->SAK_work);\n\t\tflush_work(&tty->link->hangup_work);\n\t}\n}\n\n \nstatic void release_one_tty(struct work_struct *work)\n{\n\tstruct tty_struct *tty =\n\t\tcontainer_of(work, struct tty_struct, hangup_work);\n\tstruct tty_driver *driver = tty->driver;\n\tstruct module *owner = driver->owner;\n\n\tif (tty->ops->cleanup)\n\t\ttty->ops->cleanup(tty);\n\n\ttty_driver_kref_put(driver);\n\tmodule_put(owner);\n\n\tspin_lock(&tty->files_lock);\n\tlist_del_init(&tty->tty_files);\n\tspin_unlock(&tty->files_lock);\n\n\tput_pid(tty->ctrl.pgrp);\n\tput_pid(tty->ctrl.session);\n\tfree_tty_struct(tty);\n}\n\nstatic void queue_release_one_tty(struct kref *kref)\n{\n\tstruct tty_struct *tty = container_of(kref, struct tty_struct, kref);\n\n\t \n\tINIT_WORK(&tty->hangup_work, release_one_tty);\n\tschedule_work(&tty->hangup_work);\n}\n\n \nvoid tty_kref_put(struct tty_struct *tty)\n{\n\tif (tty)\n\t\tkref_put(&tty->kref, queue_release_one_tty);\n}\nEXPORT_SYMBOL(tty_kref_put);\n\n \nstatic void release_tty(struct tty_struct *tty, int idx)\n{\n\t \n\tWARN_ON(tty->index != idx);\n\tWARN_ON(!mutex_is_locked(&tty_mutex));\n\tif (tty->ops->shutdown)\n\t\ttty->ops->shutdown(tty);\n\ttty_save_termios(tty);\n\ttty_driver_remove_tty(tty->driver, tty);\n\tif (tty->port)\n\t\ttty->port->itty = NULL;\n\tif (tty->link)\n\t\ttty->link->port->itty = NULL;\n\tif (tty->port)\n\t\ttty_buffer_cancel_work(tty->port);\n\tif (tty->link)\n\t\ttty_buffer_cancel_work(tty->link->port);\n\n\ttty_kref_put(tty->link);\n\ttty_kref_put(tty);\n}\n\n \nstatic int tty_release_checks(struct tty_struct *tty, int idx)\n{\n#ifdef TTY_PARANOIA_CHECK\n\tif (idx < 0 || idx >= tty->driver->num) {\n\t\ttty_debug(tty, \"bad idx %d\\n\", idx);\n\t\treturn -1;\n\t}\n\n\t \n\tif (tty->driver->flags & TTY_DRIVER_DEVPTS_MEM)\n\t\treturn 0;\n\n\tif (tty != tty->driver->ttys[idx]) {\n\t\ttty_debug(tty, \"bad driver table[%d] = %p\\n\",\n\t\t\t  idx, tty->driver->ttys[idx]);\n\t\treturn -1;\n\t}\n\tif (tty->driver->other) {\n\t\tstruct tty_struct *o_tty = tty->link;\n\n\t\tif (o_tty != tty->driver->other->ttys[idx]) {\n\t\t\ttty_debug(tty, \"bad other table[%d] = %p\\n\",\n\t\t\t\t  idx, tty->driver->other->ttys[idx]);\n\t\t\treturn -1;\n\t\t}\n\t\tif (o_tty->link != tty) {\n\t\t\ttty_debug(tty, \"bad link = %p\\n\", o_tty->link);\n\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n \nvoid tty_kclose(struct tty_struct *tty)\n{\n\t \n\ttty_ldisc_release(tty);\n\n\t \n\ttty_flush_works(tty);\n\n\ttty_debug_hangup(tty, \"freeing structure\\n\");\n\t \n\tmutex_lock(&tty_mutex);\n\ttty_port_set_kopened(tty->port, 0);\n\trelease_tty(tty, tty->index);\n\tmutex_unlock(&tty_mutex);\n}\nEXPORT_SYMBOL_GPL(tty_kclose);\n\n \nvoid tty_release_struct(struct tty_struct *tty, int idx)\n{\n\t \n\ttty_ldisc_release(tty);\n\n\t \n\ttty_flush_works(tty);\n\n\ttty_debug_hangup(tty, \"freeing structure\\n\");\n\t \n\tmutex_lock(&tty_mutex);\n\trelease_tty(tty, idx);\n\tmutex_unlock(&tty_mutex);\n}\nEXPORT_SYMBOL_GPL(tty_release_struct);\n\n \nint tty_release(struct inode *inode, struct file *filp)\n{\n\tstruct tty_struct *tty = file_tty(filp);\n\tstruct tty_struct *o_tty = NULL;\n\tint\tdo_sleep, final;\n\tint\tidx;\n\tlong\ttimeout = 0;\n\tint\tonce = 1;\n\n\tif (tty_paranoia_check(tty, inode, __func__))\n\t\treturn 0;\n\n\ttty_lock(tty);\n\tcheck_tty_count(tty, __func__);\n\n\t__tty_fasync(-1, filp, 0);\n\n\tidx = tty->index;\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\n\t    tty->driver->subtype == PTY_TYPE_MASTER)\n\t\to_tty = tty->link;\n\n\tif (tty_release_checks(tty, idx)) {\n\t\ttty_unlock(tty);\n\t\treturn 0;\n\t}\n\n\ttty_debug_hangup(tty, \"releasing (count=%d)\\n\", tty->count);\n\n\tif (tty->ops->close)\n\t\ttty->ops->close(tty, filp);\n\n\t \n\ttty_lock_slave(o_tty);\n\n\t \n\twhile (1) {\n\t\tdo_sleep = 0;\n\n\t\tif (tty->count <= 1) {\n\t\t\tif (waitqueue_active(&tty->read_wait)) {\n\t\t\t\twake_up_poll(&tty->read_wait, EPOLLIN);\n\t\t\t\tdo_sleep++;\n\t\t\t}\n\t\t\tif (waitqueue_active(&tty->write_wait)) {\n\t\t\t\twake_up_poll(&tty->write_wait, EPOLLOUT);\n\t\t\t\tdo_sleep++;\n\t\t\t}\n\t\t}\n\t\tif (o_tty && o_tty->count <= 1) {\n\t\t\tif (waitqueue_active(&o_tty->read_wait)) {\n\t\t\t\twake_up_poll(&o_tty->read_wait, EPOLLIN);\n\t\t\t\tdo_sleep++;\n\t\t\t}\n\t\t\tif (waitqueue_active(&o_tty->write_wait)) {\n\t\t\t\twake_up_poll(&o_tty->write_wait, EPOLLOUT);\n\t\t\t\tdo_sleep++;\n\t\t\t}\n\t\t}\n\t\tif (!do_sleep)\n\t\t\tbreak;\n\n\t\tif (once) {\n\t\t\tonce = 0;\n\t\t\ttty_warn(tty, \"read/write wait queue active!\\n\");\n\t\t}\n\t\tschedule_timeout_killable(timeout);\n\t\tif (timeout < 120 * HZ)\n\t\t\ttimeout = 2 * timeout + 1;\n\t\telse\n\t\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t}\n\n\tif (o_tty) {\n\t\tif (--o_tty->count < 0) {\n\t\t\ttty_warn(tty, \"bad slave count (%d)\\n\", o_tty->count);\n\t\t\to_tty->count = 0;\n\t\t}\n\t}\n\tif (--tty->count < 0) {\n\t\ttty_warn(tty, \"bad tty->count (%d)\\n\", tty->count);\n\t\ttty->count = 0;\n\t}\n\n\t \n\ttty_del_file(filp);\n\n\t \n\tif (!tty->count) {\n\t\tread_lock(&tasklist_lock);\n\t\tsession_clear_tty(tty->ctrl.session);\n\t\tif (o_tty)\n\t\t\tsession_clear_tty(o_tty->ctrl.session);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t \n\tfinal = !tty->count && !(o_tty && o_tty->count);\n\n\ttty_unlock_slave(o_tty);\n\ttty_unlock(tty);\n\n\t \n\n\tif (!final)\n\t\treturn 0;\n\n\ttty_debug_hangup(tty, \"final close\\n\");\n\n\ttty_release_struct(tty, idx);\n\treturn 0;\n}\n\n \nstatic struct tty_struct *tty_open_current_tty(dev_t device, struct file *filp)\n{\n\tstruct tty_struct *tty;\n\tint retval;\n\n\tif (device != MKDEV(TTYAUX_MAJOR, 0))\n\t\treturn NULL;\n\n\ttty = get_current_tty();\n\tif (!tty)\n\t\treturn ERR_PTR(-ENXIO);\n\n\tfilp->f_flags |= O_NONBLOCK;  \n\t \n\ttty_lock(tty);\n\ttty_kref_put(tty);\t \n\n\tretval = tty_reopen(tty);\n\tif (retval < 0) {\n\t\ttty_unlock(tty);\n\t\ttty = ERR_PTR(retval);\n\t}\n\treturn tty;\n}\n\n \nstatic struct tty_driver *tty_lookup_driver(dev_t device, struct file *filp,\n\t\tint *index)\n{\n\tstruct tty_driver *driver = NULL;\n\n\tswitch (device) {\n#ifdef CONFIG_VT\n\tcase MKDEV(TTY_MAJOR, 0): {\n\t\textern struct tty_driver *console_driver;\n\n\t\tdriver = tty_driver_kref_get(console_driver);\n\t\t*index = fg_console;\n\t\tbreak;\n\t}\n#endif\n\tcase MKDEV(TTYAUX_MAJOR, 1): {\n\t\tstruct tty_driver *console_driver = console_device(index);\n\n\t\tif (console_driver) {\n\t\t\tdriver = tty_driver_kref_get(console_driver);\n\t\t\tif (driver && filp) {\n\t\t\t\t \n\t\t\t\tfilp->f_flags |= O_NONBLOCK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (driver)\n\t\t\ttty_driver_kref_put(driver);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tdefault:\n\t\tdriver = get_tty_driver(device, index);\n\t\tif (!driver)\n\t\t\treturn ERR_PTR(-ENODEV);\n\t\tbreak;\n\t}\n\treturn driver;\n}\n\nstatic struct tty_struct *tty_kopen(dev_t device, int shared)\n{\n\tstruct tty_struct *tty;\n\tstruct tty_driver *driver;\n\tint index = -1;\n\n\tmutex_lock(&tty_mutex);\n\tdriver = tty_lookup_driver(device, NULL, &index);\n\tif (IS_ERR(driver)) {\n\t\tmutex_unlock(&tty_mutex);\n\t\treturn ERR_CAST(driver);\n\t}\n\n\t \n\ttty = tty_driver_lookup_tty(driver, NULL, index);\n\tif (IS_ERR(tty) || shared)\n\t\tgoto out;\n\n\tif (tty) {\n\t\t \n\t\ttty_kref_put(tty);\n\t\ttty = ERR_PTR(-EBUSY);\n\t} else {  \n\t\ttty = tty_init_dev(driver, index);\n\t\tif (IS_ERR(tty))\n\t\t\tgoto out;\n\t\ttty_port_set_kopened(tty->port, 1);\n\t}\nout:\n\tmutex_unlock(&tty_mutex);\n\ttty_driver_kref_put(driver);\n\treturn tty;\n}\n\n \nstruct tty_struct *tty_kopen_exclusive(dev_t device)\n{\n\treturn tty_kopen(device, 0);\n}\nEXPORT_SYMBOL_GPL(tty_kopen_exclusive);\n\n \nstruct tty_struct *tty_kopen_shared(dev_t device)\n{\n\treturn tty_kopen(device, 1);\n}\nEXPORT_SYMBOL_GPL(tty_kopen_shared);\n\n \nstatic struct tty_struct *tty_open_by_driver(dev_t device,\n\t\t\t\t\t     struct file *filp)\n{\n\tstruct tty_struct *tty;\n\tstruct tty_driver *driver = NULL;\n\tint index = -1;\n\tint retval;\n\n\tmutex_lock(&tty_mutex);\n\tdriver = tty_lookup_driver(device, filp, &index);\n\tif (IS_ERR(driver)) {\n\t\tmutex_unlock(&tty_mutex);\n\t\treturn ERR_CAST(driver);\n\t}\n\n\t \n\ttty = tty_driver_lookup_tty(driver, filp, index);\n\tif (IS_ERR(tty)) {\n\t\tmutex_unlock(&tty_mutex);\n\t\tgoto out;\n\t}\n\n\tif (tty) {\n\t\tif (tty_port_kopened(tty->port)) {\n\t\t\ttty_kref_put(tty);\n\t\t\tmutex_unlock(&tty_mutex);\n\t\t\ttty = ERR_PTR(-EBUSY);\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_unlock(&tty_mutex);\n\t\tretval = tty_lock_interruptible(tty);\n\t\ttty_kref_put(tty);   \n\t\tif (retval) {\n\t\t\tif (retval == -EINTR)\n\t\t\t\tretval = -ERESTARTSYS;\n\t\t\ttty = ERR_PTR(retval);\n\t\t\tgoto out;\n\t\t}\n\t\tretval = tty_reopen(tty);\n\t\tif (retval < 0) {\n\t\t\ttty_unlock(tty);\n\t\t\ttty = ERR_PTR(retval);\n\t\t}\n\t} else {  \n\t\ttty = tty_init_dev(driver, index);\n\t\tmutex_unlock(&tty_mutex);\n\t}\nout:\n\ttty_driver_kref_put(driver);\n\treturn tty;\n}\n\n \nstatic int tty_open(struct inode *inode, struct file *filp)\n{\n\tstruct tty_struct *tty;\n\tint noctty, retval;\n\tdev_t device = inode->i_rdev;\n\tunsigned saved_flags = filp->f_flags;\n\n\tnonseekable_open(inode, filp);\n\nretry_open:\n\tretval = tty_alloc_file(filp);\n\tif (retval)\n\t\treturn -ENOMEM;\n\n\ttty = tty_open_current_tty(device, filp);\n\tif (!tty)\n\t\ttty = tty_open_by_driver(device, filp);\n\n\tif (IS_ERR(tty)) {\n\t\ttty_free_file(filp);\n\t\tretval = PTR_ERR(tty);\n\t\tif (retval != -EAGAIN || signal_pending(current))\n\t\t\treturn retval;\n\t\tschedule();\n\t\tgoto retry_open;\n\t}\n\n\ttty_add_file(tty, filp);\n\n\tcheck_tty_count(tty, __func__);\n\ttty_debug_hangup(tty, \"opening (count=%d)\\n\", tty->count);\n\n\tif (tty->ops->open)\n\t\tretval = tty->ops->open(tty, filp);\n\telse\n\t\tretval = -ENODEV;\n\tfilp->f_flags = saved_flags;\n\n\tif (retval) {\n\t\ttty_debug_hangup(tty, \"open error %d, releasing\\n\", retval);\n\n\t\ttty_unlock(tty);  \n\t\ttty_release(inode, filp);\n\t\tif (retval != -ERESTARTSYS)\n\t\t\treturn retval;\n\n\t\tif (signal_pending(current))\n\t\t\treturn retval;\n\n\t\tschedule();\n\t\t \n\t\tif (tty_hung_up_p(filp))\n\t\t\tfilp->f_op = &tty_fops;\n\t\tgoto retry_open;\n\t}\n\tclear_bit(TTY_HUPPED, &tty->flags);\n\n\tnoctty = (filp->f_flags & O_NOCTTY) ||\n\t\t (IS_ENABLED(CONFIG_VT) && device == MKDEV(TTY_MAJOR, 0)) ||\n\t\t device == MKDEV(TTYAUX_MAJOR, 1) ||\n\t\t (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\n\t\t  tty->driver->subtype == PTY_TYPE_MASTER);\n\tif (!noctty)\n\t\ttty_open_proc_set_tty(filp, tty);\n\ttty_unlock(tty);\n\treturn 0;\n}\n\n\n \nstatic __poll_t tty_poll(struct file *filp, poll_table *wait)\n{\n\tstruct tty_struct *tty = file_tty(filp);\n\tstruct tty_ldisc *ld;\n\t__poll_t ret = 0;\n\n\tif (tty_paranoia_check(tty, file_inode(filp), \"tty_poll\"))\n\t\treturn 0;\n\n\tld = tty_ldisc_ref_wait(tty);\n\tif (!ld)\n\t\treturn hung_up_tty_poll(filp, wait);\n\tif (ld->ops->poll)\n\t\tret = ld->ops->poll(tty, filp, wait);\n\ttty_ldisc_deref(ld);\n\treturn ret;\n}\n\nstatic int __tty_fasync(int fd, struct file *filp, int on)\n{\n\tstruct tty_struct *tty = file_tty(filp);\n\tunsigned long flags;\n\tint retval = 0;\n\n\tif (tty_paranoia_check(tty, file_inode(filp), \"tty_fasync\"))\n\t\tgoto out;\n\n\tretval = fasync_helper(fd, filp, on, &tty->fasync);\n\tif (retval <= 0)\n\t\tgoto out;\n\n\tif (on) {\n\t\tenum pid_type type;\n\t\tstruct pid *pid;\n\n\t\tspin_lock_irqsave(&tty->ctrl.lock, flags);\n\t\tif (tty->ctrl.pgrp) {\n\t\t\tpid = tty->ctrl.pgrp;\n\t\t\ttype = PIDTYPE_PGID;\n\t\t} else {\n\t\t\tpid = task_pid(current);\n\t\t\ttype = PIDTYPE_TGID;\n\t\t}\n\t\tget_pid(pid);\n\t\tspin_unlock_irqrestore(&tty->ctrl.lock, flags);\n\t\t__f_setown(filp, pid, type, 0);\n\t\tput_pid(pid);\n\t\tretval = 0;\n\t}\nout:\n\treturn retval;\n}\n\nstatic int tty_fasync(int fd, struct file *filp, int on)\n{\n\tstruct tty_struct *tty = file_tty(filp);\n\tint retval = -ENOTTY;\n\n\ttty_lock(tty);\n\tif (!tty_hung_up_p(filp))\n\t\tretval = __tty_fasync(fd, filp, on);\n\ttty_unlock(tty);\n\n\treturn retval;\n}\n\nstatic bool tty_legacy_tiocsti __read_mostly = IS_ENABLED(CONFIG_LEGACY_TIOCSTI);\n \nstatic int tiocsti(struct tty_struct *tty, char __user *p)\n{\n\tchar ch, mbz = 0;\n\tstruct tty_ldisc *ld;\n\n\tif (!tty_legacy_tiocsti && !capable(CAP_SYS_ADMIN))\n\t\treturn -EIO;\n\n\tif ((current->signal->tty != tty) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (get_user(ch, p))\n\t\treturn -EFAULT;\n\ttty_audit_tiocsti(tty, ch);\n\tld = tty_ldisc_ref_wait(tty);\n\tif (!ld)\n\t\treturn -EIO;\n\ttty_buffer_lock_exclusive(tty->port);\n\tif (ld->ops->receive_buf)\n\t\tld->ops->receive_buf(tty, &ch, &mbz, 1);\n\ttty_buffer_unlock_exclusive(tty->port);\n\ttty_ldisc_deref(ld);\n\treturn 0;\n}\n\n \nstatic int tiocgwinsz(struct tty_struct *tty, struct winsize __user *arg)\n{\n\tint err;\n\n\tmutex_lock(&tty->winsize_mutex);\n\terr = copy_to_user(arg, &tty->winsize, sizeof(*arg));\n\tmutex_unlock(&tty->winsize_mutex);\n\n\treturn err ? -EFAULT : 0;\n}\n\n \nint tty_do_resize(struct tty_struct *tty, struct winsize *ws)\n{\n\tstruct pid *pgrp;\n\n\t \n\tmutex_lock(&tty->winsize_mutex);\n\tif (!memcmp(ws, &tty->winsize, sizeof(*ws)))\n\t\tgoto done;\n\n\t \n\tpgrp = tty_get_pgrp(tty);\n\tif (pgrp)\n\t\tkill_pgrp(pgrp, SIGWINCH, 1);\n\tput_pid(pgrp);\n\n\ttty->winsize = *ws;\ndone:\n\tmutex_unlock(&tty->winsize_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(tty_do_resize);\n\n \nstatic int tiocswinsz(struct tty_struct *tty, struct winsize __user *arg)\n{\n\tstruct winsize tmp_ws;\n\n\tif (copy_from_user(&tmp_ws, arg, sizeof(*arg)))\n\t\treturn -EFAULT;\n\n\tif (tty->ops->resize)\n\t\treturn tty->ops->resize(tty, &tmp_ws);\n\telse\n\t\treturn tty_do_resize(tty, &tmp_ws);\n}\n\n \nstatic int tioccons(struct file *file)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (file->f_op->write_iter == redirected_tty_write) {\n\t\tstruct file *f;\n\n\t\tspin_lock(&redirect_lock);\n\t\tf = redirect;\n\t\tredirect = NULL;\n\t\tspin_unlock(&redirect_lock);\n\t\tif (f)\n\t\t\tfput(f);\n\t\treturn 0;\n\t}\n\tif (file->f_op->write_iter != tty_write)\n\t\treturn -ENOTTY;\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tspin_lock(&redirect_lock);\n\tif (redirect) {\n\t\tspin_unlock(&redirect_lock);\n\t\treturn -EBUSY;\n\t}\n\tredirect = get_file(file);\n\tspin_unlock(&redirect_lock);\n\treturn 0;\n}\n\n \nstatic int tiocsetd(struct tty_struct *tty, int __user *p)\n{\n\tint disc;\n\tint ret;\n\n\tif (get_user(disc, p))\n\t\treturn -EFAULT;\n\n\tret = tty_set_ldisc(tty, disc);\n\n\treturn ret;\n}\n\n \nstatic int tiocgetd(struct tty_struct *tty, int __user *p)\n{\n\tstruct tty_ldisc *ld;\n\tint ret;\n\n\tld = tty_ldisc_ref_wait(tty);\n\tif (!ld)\n\t\treturn -EIO;\n\tret = put_user(ld->ops->num, p);\n\ttty_ldisc_deref(ld);\n\treturn ret;\n}\n\n \nstatic int send_break(struct tty_struct *tty, unsigned int duration)\n{\n\tint retval;\n\n\tif (tty->ops->break_ctl == NULL)\n\t\treturn 0;\n\n\tif (tty->driver->flags & TTY_DRIVER_HARDWARE_BREAK)\n\t\treturn tty->ops->break_ctl(tty, duration);\n\n\t \n\tif (tty_write_lock(tty, false) < 0)\n\t\treturn -EINTR;\n\n\tretval = tty->ops->break_ctl(tty, -1);\n\tif (!retval) {\n\t\tmsleep_interruptible(duration);\n\t\tretval = tty->ops->break_ctl(tty, 0);\n\t} else if (retval == -EOPNOTSUPP) {\n\t\t \n\t\tretval = 0;\n\t}\n\ttty_write_unlock(tty);\n\n\tif (signal_pending(current))\n\t\tretval = -EINTR;\n\n\treturn retval;\n}\n\n \nstatic int tty_tiocmget(struct tty_struct *tty, int __user *p)\n{\n\tint retval = -ENOTTY;\n\n\tif (tty->ops->tiocmget) {\n\t\tretval = tty->ops->tiocmget(tty);\n\n\t\tif (retval >= 0)\n\t\t\tretval = put_user(retval, p);\n\t}\n\treturn retval;\n}\n\n \nstatic int tty_tiocmset(struct tty_struct *tty, unsigned int cmd,\n\t     unsigned __user *p)\n{\n\tint retval;\n\tunsigned int set, clear, val;\n\n\tif (tty->ops->tiocmset == NULL)\n\t\treturn -ENOTTY;\n\n\tretval = get_user(val, p);\n\tif (retval)\n\t\treturn retval;\n\tset = clear = 0;\n\tswitch (cmd) {\n\tcase TIOCMBIS:\n\t\tset = val;\n\t\tbreak;\n\tcase TIOCMBIC:\n\t\tclear = val;\n\t\tbreak;\n\tcase TIOCMSET:\n\t\tset = val;\n\t\tclear = ~val;\n\t\tbreak;\n\t}\n\tset &= TIOCM_DTR|TIOCM_RTS|TIOCM_OUT1|TIOCM_OUT2|TIOCM_LOOP;\n\tclear &= TIOCM_DTR|TIOCM_RTS|TIOCM_OUT1|TIOCM_OUT2|TIOCM_LOOP;\n\treturn tty->ops->tiocmset(tty, set, clear);\n}\n\n \nint tty_get_icount(struct tty_struct *tty,\n\t\t   struct serial_icounter_struct *icount)\n{\n\tmemset(icount, 0, sizeof(*icount));\n\n\tif (tty->ops->get_icount)\n\t\treturn tty->ops->get_icount(tty, icount);\n\telse\n\t\treturn -ENOTTY;\n}\nEXPORT_SYMBOL_GPL(tty_get_icount);\n\nstatic int tty_tiocgicount(struct tty_struct *tty, void __user *arg)\n{\n\tstruct serial_icounter_struct icount;\n\tint retval;\n\n\tretval = tty_get_icount(tty, &icount);\n\tif (retval != 0)\n\t\treturn retval;\n\n\tif (copy_to_user(arg, &icount, sizeof(icount)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int tty_set_serial(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tchar comm[TASK_COMM_LEN];\n\tint flags;\n\n\tflags = ss->flags & ASYNC_DEPRECATED;\n\n\tif (flags)\n\t\tpr_warn_ratelimited(\"%s: '%s' is using deprecated serial flags (with no effect): %.8x\\n\",\n\t\t\t\t__func__, get_task_comm(comm, current), flags);\n\n\tif (!tty->ops->set_serial)\n\t\treturn -ENOTTY;\n\n\treturn tty->ops->set_serial(tty, ss);\n}\n\nstatic int tty_tiocsserial(struct tty_struct *tty, struct serial_struct __user *ss)\n{\n\tstruct serial_struct v;\n\n\tif (copy_from_user(&v, ss, sizeof(*ss)))\n\t\treturn -EFAULT;\n\n\treturn tty_set_serial(tty, &v);\n}\n\nstatic int tty_tiocgserial(struct tty_struct *tty, struct serial_struct __user *ss)\n{\n\tstruct serial_struct v;\n\tint err;\n\n\tmemset(&v, 0, sizeof(v));\n\tif (!tty->ops->get_serial)\n\t\treturn -ENOTTY;\n\terr = tty->ops->get_serial(tty, &v);\n\tif (!err && copy_to_user(ss, &v, sizeof(v)))\n\t\terr = -EFAULT;\n\treturn err;\n}\n\n \nstatic struct tty_struct *tty_pair_get_tty(struct tty_struct *tty)\n{\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\n\t    tty->driver->subtype == PTY_TYPE_MASTER)\n\t\ttty = tty->link;\n\treturn tty;\n}\n\n \nlong tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct tty_struct *tty = file_tty(file);\n\tstruct tty_struct *real_tty;\n\tvoid __user *p = (void __user *)arg;\n\tint retval;\n\tstruct tty_ldisc *ld;\n\n\tif (tty_paranoia_check(tty, file_inode(file), \"tty_ioctl\"))\n\t\treturn -EINVAL;\n\n\treal_tty = tty_pair_get_tty(tty);\n\n\t \n\tswitch (cmd) {\n\tcase TIOCSETD:\n\tcase TIOCSBRK:\n\tcase TIOCCBRK:\n\tcase TCSBRK:\n\tcase TCSBRKP:\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tif (cmd != TIOCCBRK) {\n\t\t\ttty_wait_until_sent(tty, 0);\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tswitch (cmd) {\n\tcase TIOCSTI:\n\t\treturn tiocsti(tty, p);\n\tcase TIOCGWINSZ:\n\t\treturn tiocgwinsz(real_tty, p);\n\tcase TIOCSWINSZ:\n\t\treturn tiocswinsz(real_tty, p);\n\tcase TIOCCONS:\n\t\treturn real_tty != tty ? -EINVAL : tioccons(file);\n\tcase TIOCEXCL:\n\t\tset_bit(TTY_EXCLUSIVE, &tty->flags);\n\t\treturn 0;\n\tcase TIOCNXCL:\n\t\tclear_bit(TTY_EXCLUSIVE, &tty->flags);\n\t\treturn 0;\n\tcase TIOCGEXCL:\n\t{\n\t\tint excl = test_bit(TTY_EXCLUSIVE, &tty->flags);\n\n\t\treturn put_user(excl, (int __user *)p);\n\t}\n\tcase TIOCGETD:\n\t\treturn tiocgetd(tty, p);\n\tcase TIOCSETD:\n\t\treturn tiocsetd(tty, p);\n\tcase TIOCVHANGUP:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\ttty_vhangup(tty);\n\t\treturn 0;\n\tcase TIOCGDEV:\n\t{\n\t\tunsigned int ret = new_encode_dev(tty_devnum(real_tty));\n\n\t\treturn put_user(ret, (unsigned int __user *)p);\n\t}\n\t \n\tcase TIOCSBRK:\t \n\t\tif (tty->ops->break_ctl)\n\t\t\treturn tty->ops->break_ctl(tty, -1);\n\t\treturn 0;\n\tcase TIOCCBRK:\t \n\t\tif (tty->ops->break_ctl)\n\t\t\treturn tty->ops->break_ctl(tty, 0);\n\t\treturn 0;\n\tcase TCSBRK:    \n\t\t \n\t\tif (!arg)\n\t\t\treturn send_break(tty, 250);\n\t\treturn 0;\n\tcase TCSBRKP:\t \n\t\treturn send_break(tty, arg ? arg*100 : 250);\n\n\tcase TIOCMGET:\n\t\treturn tty_tiocmget(tty, p);\n\tcase TIOCMSET:\n\tcase TIOCMBIC:\n\tcase TIOCMBIS:\n\t\treturn tty_tiocmset(tty, cmd, p);\n\tcase TIOCGICOUNT:\n\t\treturn tty_tiocgicount(tty, p);\n\tcase TCFLSH:\n\t\tswitch (arg) {\n\t\tcase TCIFLUSH:\n\t\tcase TCIOFLUSH:\n\t\t \n\t\t\ttty_buffer_flush(tty, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TIOCSSERIAL:\n\t\treturn tty_tiocsserial(tty, p);\n\tcase TIOCGSERIAL:\n\t\treturn tty_tiocgserial(tty, p);\n\tcase TIOCGPTPEER:\n\t\t \n\t\treturn ptm_open_peer(file, tty, (int)arg);\n\tdefault:\n\t\tretval = tty_jobctrl_ioctl(tty, real_tty, file, cmd, arg);\n\t\tif (retval != -ENOIOCTLCMD)\n\t\t\treturn retval;\n\t}\n\tif (tty->ops->ioctl) {\n\t\tretval = tty->ops->ioctl(tty, cmd, arg);\n\t\tif (retval != -ENOIOCTLCMD)\n\t\t\treturn retval;\n\t}\n\tld = tty_ldisc_ref_wait(tty);\n\tif (!ld)\n\t\treturn hung_up_tty_ioctl(file, cmd, arg);\n\tretval = -EINVAL;\n\tif (ld->ops->ioctl) {\n\t\tretval = ld->ops->ioctl(tty, cmd, arg);\n\t\tif (retval == -ENOIOCTLCMD)\n\t\t\tretval = -ENOTTY;\n\t}\n\ttty_ldisc_deref(ld);\n\treturn retval;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct serial_struct32 {\n\tcompat_int_t    type;\n\tcompat_int_t    line;\n\tcompat_uint_t   port;\n\tcompat_int_t    irq;\n\tcompat_int_t    flags;\n\tcompat_int_t    xmit_fifo_size;\n\tcompat_int_t    custom_divisor;\n\tcompat_int_t    baud_base;\n\tunsigned short  close_delay;\n\tchar    io_type;\n\tchar    reserved_char;\n\tcompat_int_t    hub6;\n\tunsigned short  closing_wait;  \n\tunsigned short  closing_wait2;  \n\tcompat_uint_t   iomem_base;\n\tunsigned short  iomem_reg_shift;\n\tunsigned int    port_high;\n\t \n\tcompat_int_t    reserved;\n};\n\nstatic int compat_tty_tiocsserial(struct tty_struct *tty,\n\t\tstruct serial_struct32 __user *ss)\n{\n\tstruct serial_struct32 v32;\n\tstruct serial_struct v;\n\n\tif (copy_from_user(&v32, ss, sizeof(*ss)))\n\t\treturn -EFAULT;\n\n\tmemcpy(&v, &v32, offsetof(struct serial_struct32, iomem_base));\n\tv.iomem_base = compat_ptr(v32.iomem_base);\n\tv.iomem_reg_shift = v32.iomem_reg_shift;\n\tv.port_high = v32.port_high;\n\tv.iomap_base = 0;\n\n\treturn tty_set_serial(tty, &v);\n}\n\nstatic int compat_tty_tiocgserial(struct tty_struct *tty,\n\t\t\tstruct serial_struct32 __user *ss)\n{\n\tstruct serial_struct32 v32;\n\tstruct serial_struct v;\n\tint err;\n\n\tmemset(&v, 0, sizeof(v));\n\tmemset(&v32, 0, sizeof(v32));\n\n\tif (!tty->ops->get_serial)\n\t\treturn -ENOTTY;\n\terr = tty->ops->get_serial(tty, &v);\n\tif (!err) {\n\t\tmemcpy(&v32, &v, offsetof(struct serial_struct32, iomem_base));\n\t\tv32.iomem_base = (unsigned long)v.iomem_base >> 32 ?\n\t\t\t0xfffffff : ptr_to_compat(v.iomem_base);\n\t\tv32.iomem_reg_shift = v.iomem_reg_shift;\n\t\tv32.port_high = v.port_high;\n\t\tif (copy_to_user(ss, &v32, sizeof(v32)))\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}\nstatic long tty_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct tty_struct *tty = file_tty(file);\n\tstruct tty_ldisc *ld;\n\tint retval = -ENOIOCTLCMD;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\tcase TIOCSTI:\n\tcase TIOCGWINSZ:\n\tcase TIOCSWINSZ:\n\tcase TIOCGEXCL:\n\tcase TIOCGETD:\n\tcase TIOCSETD:\n\tcase TIOCGDEV:\n\tcase TIOCMGET:\n\tcase TIOCMSET:\n\tcase TIOCMBIC:\n\tcase TIOCMBIS:\n\tcase TIOCGICOUNT:\n\tcase TIOCGPGRP:\n\tcase TIOCSPGRP:\n\tcase TIOCGSID:\n\tcase TIOCSERGETLSR:\n\tcase TIOCGRS485:\n\tcase TIOCSRS485:\n#ifdef TIOCGETP\n\tcase TIOCGETP:\n\tcase TIOCSETP:\n\tcase TIOCSETN:\n#endif\n#ifdef TIOCGETC\n\tcase TIOCGETC:\n\tcase TIOCSETC:\n#endif\n#ifdef TIOCGLTC\n\tcase TIOCGLTC:\n\tcase TIOCSLTC:\n#endif\n\tcase TCSETSF:\n\tcase TCSETSW:\n\tcase TCSETS:\n\tcase TCGETS:\n#ifdef TCGETS2\n\tcase TCGETS2:\n\tcase TCSETSF2:\n\tcase TCSETSW2:\n\tcase TCSETS2:\n#endif\n\tcase TCGETA:\n\tcase TCSETAF:\n\tcase TCSETAW:\n\tcase TCSETA:\n\tcase TIOCGLCKTRMIOS:\n\tcase TIOCSLCKTRMIOS:\n#ifdef TCGETX\n\tcase TCGETX:\n\tcase TCSETX:\n\tcase TCSETXW:\n\tcase TCSETXF:\n#endif\n\tcase TIOCGSOFTCAR:\n\tcase TIOCSSOFTCAR:\n\n\tcase PPPIOCGCHAN:\n\tcase PPPIOCGUNIT:\n\t\treturn tty_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n\tcase TIOCCONS:\n\tcase TIOCEXCL:\n\tcase TIOCNXCL:\n\tcase TIOCVHANGUP:\n\tcase TIOCSBRK:\n\tcase TIOCCBRK:\n\tcase TCSBRK:\n\tcase TCSBRKP:\n\tcase TCFLSH:\n\tcase TIOCGPTPEER:\n\tcase TIOCNOTTY:\n\tcase TIOCSCTTY:\n\tcase TCXONC:\n\tcase TIOCMIWAIT:\n\tcase TIOCSERCONFIG:\n\t\treturn tty_ioctl(file, cmd, arg);\n\t}\n\n\tif (tty_paranoia_check(tty, file_inode(file), \"tty_ioctl\"))\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase TIOCSSERIAL:\n\t\treturn compat_tty_tiocsserial(tty, compat_ptr(arg));\n\tcase TIOCGSERIAL:\n\t\treturn compat_tty_tiocgserial(tty, compat_ptr(arg));\n\t}\n\tif (tty->ops->compat_ioctl) {\n\t\tretval = tty->ops->compat_ioctl(tty, cmd, arg);\n\t\tif (retval != -ENOIOCTLCMD)\n\t\t\treturn retval;\n\t}\n\n\tld = tty_ldisc_ref_wait(tty);\n\tif (!ld)\n\t\treturn hung_up_tty_compat_ioctl(file, cmd, arg);\n\tif (ld->ops->compat_ioctl)\n\t\tretval = ld->ops->compat_ioctl(tty, cmd, arg);\n\tif (retval == -ENOIOCTLCMD && ld->ops->ioctl)\n\t\tretval = ld->ops->ioctl(tty, (unsigned long)compat_ptr(cmd),\n\t\t\t\targ);\n\ttty_ldisc_deref(ld);\n\n\treturn retval;\n}\n#endif\n\nstatic int this_tty(const void *t, struct file *file, unsigned fd)\n{\n\tif (likely(file->f_op->read_iter != tty_read))\n\t\treturn 0;\n\treturn file_tty(file) != t ? 0 : fd + 1;\n}\n\n \nvoid __do_SAK(struct tty_struct *tty)\n{\n\tstruct task_struct *g, *p;\n\tstruct pid *session;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tty->ctrl.lock, flags);\n\tsession = get_pid(tty->ctrl.session);\n\tspin_unlock_irqrestore(&tty->ctrl.lock, flags);\n\n\ttty_ldisc_flush(tty);\n\n\ttty_driver_flush_buffer(tty);\n\n\tread_lock(&tasklist_lock);\n\t \n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\ttty_notice(tty, \"SAK: killed process %d (%s): by session\\n\",\n\t\t\t   task_pid_nr(p), p->comm);\n\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n\n\t \n\tfor_each_process_thread(g, p) {\n\t\tif (p->signal->tty == tty) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by controlling tty\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p,\n\t\t\t\t\tPIDTYPE_SID);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_lock(p);\n\t\ti = iterate_fd(p->files, 0, this_tty, tty);\n\t\tif (i != 0) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by fd#%d\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p,\n\t\t\t\t\tPIDTYPE_SID);\n\t\t}\n\t\ttask_unlock(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\tput_pid(session);\n}\n\nstatic void do_SAK_work(struct work_struct *work)\n{\n\tstruct tty_struct *tty =\n\t\tcontainer_of(work, struct tty_struct, SAK_work);\n\t__do_SAK(tty);\n}\n\n \nvoid do_SAK(struct tty_struct *tty)\n{\n\tif (!tty)\n\t\treturn;\n\tschedule_work(&tty->SAK_work);\n}\nEXPORT_SYMBOL(do_SAK);\n\n \nstatic struct device *tty_get_device(struct tty_struct *tty)\n{\n\tdev_t devt = tty_devnum(tty);\n\n\treturn class_find_device_by_devt(&tty_class, devt);\n}\n\n\n \nstruct tty_struct *alloc_tty_struct(struct tty_driver *driver, int idx)\n{\n\tstruct tty_struct *tty;\n\n\ttty = kzalloc(sizeof(*tty), GFP_KERNEL_ACCOUNT);\n\tif (!tty)\n\t\treturn NULL;\n\n\tkref_init(&tty->kref);\n\tif (tty_ldisc_init(tty)) {\n\t\tkfree(tty);\n\t\treturn NULL;\n\t}\n\ttty->ctrl.session = NULL;\n\ttty->ctrl.pgrp = NULL;\n\tmutex_init(&tty->legacy_mutex);\n\tmutex_init(&tty->throttle_mutex);\n\tinit_rwsem(&tty->termios_rwsem);\n\tmutex_init(&tty->winsize_mutex);\n\tinit_ldsem(&tty->ldisc_sem);\n\tinit_waitqueue_head(&tty->write_wait);\n\tinit_waitqueue_head(&tty->read_wait);\n\tINIT_WORK(&tty->hangup_work, do_tty_hangup);\n\tmutex_init(&tty->atomic_write_lock);\n\tspin_lock_init(&tty->ctrl.lock);\n\tspin_lock_init(&tty->flow.lock);\n\tspin_lock_init(&tty->files_lock);\n\tINIT_LIST_HEAD(&tty->tty_files);\n\tINIT_WORK(&tty->SAK_work, do_SAK_work);\n\n\ttty->driver = driver;\n\ttty->ops = driver->ops;\n\ttty->index = idx;\n\ttty_line_name(driver, idx, tty->name);\n\ttty->dev = tty_get_device(tty);\n\n\treturn tty;\n}\n\n \nint tty_put_char(struct tty_struct *tty, unsigned char ch)\n{\n\tif (tty->ops->put_char)\n\t\treturn tty->ops->put_char(tty, ch);\n\treturn tty->ops->write(tty, &ch, 1);\n}\nEXPORT_SYMBOL_GPL(tty_put_char);\n\nstatic int tty_cdev_add(struct tty_driver *driver, dev_t dev,\n\t\tunsigned int index, unsigned int count)\n{\n\tint err;\n\n\t \n\tdriver->cdevs[index] = cdev_alloc();\n\tif (!driver->cdevs[index])\n\t\treturn -ENOMEM;\n\tdriver->cdevs[index]->ops = &tty_fops;\n\tdriver->cdevs[index]->owner = driver->owner;\n\terr = cdev_add(driver->cdevs[index], dev, count);\n\tif (err)\n\t\tkobject_put(&driver->cdevs[index]->kobj);\n\treturn err;\n}\n\n \nstruct device *tty_register_device(struct tty_driver *driver, unsigned index,\n\t\t\t\t   struct device *device)\n{\n\treturn tty_register_device_attr(driver, index, device, NULL, NULL);\n}\nEXPORT_SYMBOL(tty_register_device);\n\nstatic void tty_device_create_release(struct device *dev)\n{\n\tdev_dbg(dev, \"releasing...\\n\");\n\tkfree(dev);\n}\n\n \nstruct device *tty_register_device_attr(struct tty_driver *driver,\n\t\t\t\t   unsigned index, struct device *device,\n\t\t\t\t   void *drvdata,\n\t\t\t\t   const struct attribute_group **attr_grp)\n{\n\tchar name[64];\n\tdev_t devt = MKDEV(driver->major, driver->minor_start) + index;\n\tstruct ktermios *tp;\n\tstruct device *dev;\n\tint retval;\n\n\tif (index >= driver->num) {\n\t\tpr_err(\"%s: Attempt to register invalid tty line number (%d)\\n\",\n\t\t       driver->name, index);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (driver->type == TTY_DRIVER_TYPE_PTY)\n\t\tpty_line_name(driver, index, name);\n\telse\n\t\ttty_line_name(driver, index, name);\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev->devt = devt;\n\tdev->class = &tty_class;\n\tdev->parent = device;\n\tdev->release = tty_device_create_release;\n\tdev_set_name(dev, \"%s\", name);\n\tdev->groups = attr_grp;\n\tdev_set_drvdata(dev, drvdata);\n\n\tdev_set_uevent_suppress(dev, 1);\n\n\tretval = device_register(dev);\n\tif (retval)\n\t\tgoto err_put;\n\n\tif (!(driver->flags & TTY_DRIVER_DYNAMIC_ALLOC)) {\n\t\t \n\t\ttp = driver->termios[index];\n\t\tif (tp) {\n\t\t\tdriver->termios[index] = NULL;\n\t\t\tkfree(tp);\n\t\t}\n\n\t\tretval = tty_cdev_add(driver, devt, index, 1);\n\t\tif (retval)\n\t\t\tgoto err_del;\n\t}\n\n\tdev_set_uevent_suppress(dev, 0);\n\tkobject_uevent(&dev->kobj, KOBJ_ADD);\n\n\treturn dev;\n\nerr_del:\n\tdevice_del(dev);\nerr_put:\n\tput_device(dev);\n\n\treturn ERR_PTR(retval);\n}\nEXPORT_SYMBOL_GPL(tty_register_device_attr);\n\n \nvoid tty_unregister_device(struct tty_driver *driver, unsigned index)\n{\n\tdevice_destroy(&tty_class, MKDEV(driver->major, driver->minor_start) + index);\n\tif (!(driver->flags & TTY_DRIVER_DYNAMIC_ALLOC)) {\n\t\tcdev_del(driver->cdevs[index]);\n\t\tdriver->cdevs[index] = NULL;\n\t}\n}\nEXPORT_SYMBOL(tty_unregister_device);\n\n \nstruct tty_driver *__tty_alloc_driver(unsigned int lines, struct module *owner,\n\t\tunsigned long flags)\n{\n\tstruct tty_driver *driver;\n\tunsigned int cdevs = 1;\n\tint err;\n\n\tif (!lines || (flags & TTY_DRIVER_UNNUMBERED_NODE && lines > 1))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdriver = kzalloc(sizeof(*driver), GFP_KERNEL);\n\tif (!driver)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkref_init(&driver->kref);\n\tdriver->num = lines;\n\tdriver->owner = owner;\n\tdriver->flags = flags;\n\n\tif (!(flags & TTY_DRIVER_DEVPTS_MEM)) {\n\t\tdriver->ttys = kcalloc(lines, sizeof(*driver->ttys),\n\t\t\t\tGFP_KERNEL);\n\t\tdriver->termios = kcalloc(lines, sizeof(*driver->termios),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!driver->ttys || !driver->termios) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_all;\n\t\t}\n\t}\n\n\tif (!(flags & TTY_DRIVER_DYNAMIC_ALLOC)) {\n\t\tdriver->ports = kcalloc(lines, sizeof(*driver->ports),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!driver->ports) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_all;\n\t\t}\n\t\tcdevs = lines;\n\t}\n\n\tdriver->cdevs = kcalloc(cdevs, sizeof(*driver->cdevs), GFP_KERNEL);\n\tif (!driver->cdevs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_all;\n\t}\n\n\treturn driver;\nerr_free_all:\n\tkfree(driver->ports);\n\tkfree(driver->ttys);\n\tkfree(driver->termios);\n\tkfree(driver->cdevs);\n\tkfree(driver);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(__tty_alloc_driver);\n\nstatic void destruct_tty_driver(struct kref *kref)\n{\n\tstruct tty_driver *driver = container_of(kref, struct tty_driver, kref);\n\tint i;\n\tstruct ktermios *tp;\n\n\tif (driver->flags & TTY_DRIVER_INSTALLED) {\n\t\tfor (i = 0; i < driver->num; i++) {\n\t\t\ttp = driver->termios[i];\n\t\t\tif (tp) {\n\t\t\t\tdriver->termios[i] = NULL;\n\t\t\t\tkfree(tp);\n\t\t\t}\n\t\t\tif (!(driver->flags & TTY_DRIVER_DYNAMIC_DEV))\n\t\t\t\ttty_unregister_device(driver, i);\n\t\t}\n\t\tproc_tty_unregister_driver(driver);\n\t\tif (driver->flags & TTY_DRIVER_DYNAMIC_ALLOC)\n\t\t\tcdev_del(driver->cdevs[0]);\n\t}\n\tkfree(driver->cdevs);\n\tkfree(driver->ports);\n\tkfree(driver->termios);\n\tkfree(driver->ttys);\n\tkfree(driver);\n}\n\n \nvoid tty_driver_kref_put(struct tty_driver *driver)\n{\n\tkref_put(&driver->kref, destruct_tty_driver);\n}\nEXPORT_SYMBOL(tty_driver_kref_put);\n\n \nint tty_register_driver(struct tty_driver *driver)\n{\n\tint error;\n\tint i;\n\tdev_t dev;\n\tstruct device *d;\n\n\tif (!driver->major) {\n\t\terror = alloc_chrdev_region(&dev, driver->minor_start,\n\t\t\t\t\t\tdriver->num, driver->name);\n\t\tif (!error) {\n\t\t\tdriver->major = MAJOR(dev);\n\t\t\tdriver->minor_start = MINOR(dev);\n\t\t}\n\t} else {\n\t\tdev = MKDEV(driver->major, driver->minor_start);\n\t\terror = register_chrdev_region(dev, driver->num, driver->name);\n\t}\n\tif (error < 0)\n\t\tgoto err;\n\n\tif (driver->flags & TTY_DRIVER_DYNAMIC_ALLOC) {\n\t\terror = tty_cdev_add(driver, dev, 0, driver->num);\n\t\tif (error)\n\t\t\tgoto err_unreg_char;\n\t}\n\n\tmutex_lock(&tty_mutex);\n\tlist_add(&driver->tty_drivers, &tty_drivers);\n\tmutex_unlock(&tty_mutex);\n\n\tif (!(driver->flags & TTY_DRIVER_DYNAMIC_DEV)) {\n\t\tfor (i = 0; i < driver->num; i++) {\n\t\t\td = tty_register_device(driver, i, NULL);\n\t\t\tif (IS_ERR(d)) {\n\t\t\t\terror = PTR_ERR(d);\n\t\t\t\tgoto err_unreg_devs;\n\t\t\t}\n\t\t}\n\t}\n\tproc_tty_register_driver(driver);\n\tdriver->flags |= TTY_DRIVER_INSTALLED;\n\treturn 0;\n\nerr_unreg_devs:\n\tfor (i--; i >= 0; i--)\n\t\ttty_unregister_device(driver, i);\n\n\tmutex_lock(&tty_mutex);\n\tlist_del(&driver->tty_drivers);\n\tmutex_unlock(&tty_mutex);\n\nerr_unreg_char:\n\tunregister_chrdev_region(dev, driver->num);\nerr:\n\treturn error;\n}\nEXPORT_SYMBOL(tty_register_driver);\n\n \nvoid tty_unregister_driver(struct tty_driver *driver)\n{\n\tunregister_chrdev_region(MKDEV(driver->major, driver->minor_start),\n\t\t\t\tdriver->num);\n\tmutex_lock(&tty_mutex);\n\tlist_del(&driver->tty_drivers);\n\tmutex_unlock(&tty_mutex);\n}\nEXPORT_SYMBOL(tty_unregister_driver);\n\ndev_t tty_devnum(struct tty_struct *tty)\n{\n\treturn MKDEV(tty->driver->major, tty->driver->minor_start) + tty->index;\n}\nEXPORT_SYMBOL(tty_devnum);\n\nvoid tty_default_fops(struct file_operations *fops)\n{\n\t*fops = tty_fops;\n}\n\nstatic char *tty_devnode(const struct device *dev, umode_t *mode)\n{\n\tif (!mode)\n\t\treturn NULL;\n\tif (dev->devt == MKDEV(TTYAUX_MAJOR, 0) ||\n\t    dev->devt == MKDEV(TTYAUX_MAJOR, 2))\n\t\t*mode = 0666;\n\treturn NULL;\n}\n\nconst struct class tty_class = {\n\t.name\t\t= \"tty\",\n\t.devnode\t= tty_devnode,\n};\n\nstatic int __init tty_class_init(void)\n{\n\treturn class_register(&tty_class);\n}\n\npostcore_initcall(tty_class_init);\n\n \nstatic struct cdev tty_cdev, console_cdev;\n\nstatic ssize_t show_cons_active(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct console *cs[16];\n\tint i = 0;\n\tstruct console *c;\n\tssize_t count = 0;\n\n\t \n\tconsole_list_lock();\n\n\tfor_each_console(c) {\n\t\tif (!c->device)\n\t\t\tcontinue;\n\t\tif (!c->write)\n\t\t\tcontinue;\n\t\tif ((c->flags & CON_ENABLED) == 0)\n\t\t\tcontinue;\n\t\tcs[i++] = c;\n\t\tif (i >= ARRAY_SIZE(cs))\n\t\t\tbreak;\n\t}\n\n\t \n\tconsole_lock();\n\twhile (i--) {\n\t\tint index = cs[i]->index;\n\t\tstruct tty_driver *drv = cs[i]->device(cs[i], &index);\n\n\t\t \n\t\tif (drv && (cs[i]->index > 0 || drv->major != TTY_MAJOR))\n\t\t\tcount += tty_line_name(drv, index, buf + count);\n\t\telse\n\t\t\tcount += sprintf(buf + count, \"%s%d\",\n\t\t\t\t\t cs[i]->name, cs[i]->index);\n\n\t\tcount += sprintf(buf + count, \"%c\", i ? ' ':'\\n');\n\t}\n\tconsole_unlock();\n\n\tconsole_list_unlock();\n\n\treturn count;\n}\nstatic DEVICE_ATTR(active, S_IRUGO, show_cons_active, NULL);\n\nstatic struct attribute *cons_dev_attrs[] = {\n\t&dev_attr_active.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(cons_dev);\n\nstatic struct device *consdev;\n\nvoid console_sysfs_notify(void)\n{\n\tif (consdev)\n\t\tsysfs_notify(&consdev->kobj, NULL, \"active\");\n}\n\nstatic struct ctl_table tty_table[] = {\n\t{\n\t\t.procname\t= \"legacy_tiocsti\",\n\t\t.data\t\t= &tty_legacy_tiocsti,\n\t\t.maxlen\t\t= sizeof(tty_legacy_tiocsti),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dobool,\n\t},\n\t{\n\t\t.procname\t= \"ldisc_autoload\",\n\t\t.data\t\t= &tty_ldisc_autoload,\n\t\t.maxlen\t\t= sizeof(tty_ldisc_autoload),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{ }\n};\n\n \nint __init tty_init(void)\n{\n\tregister_sysctl_init(\"dev/tty\", tty_table);\n\tcdev_init(&tty_cdev, &tty_fops);\n\tif (cdev_add(&tty_cdev, MKDEV(TTYAUX_MAJOR, 0), 1) ||\n\t    register_chrdev_region(MKDEV(TTYAUX_MAJOR, 0), 1, \"/dev/tty\") < 0)\n\t\tpanic(\"Couldn't register /dev/tty driver\\n\");\n\tdevice_create(&tty_class, NULL, MKDEV(TTYAUX_MAJOR, 0), NULL, \"tty\");\n\n\tcdev_init(&console_cdev, &console_fops);\n\tif (cdev_add(&console_cdev, MKDEV(TTYAUX_MAJOR, 1), 1) ||\n\t    register_chrdev_region(MKDEV(TTYAUX_MAJOR, 1), 1, \"/dev/console\") < 0)\n\t\tpanic(\"Couldn't register /dev/console driver\\n\");\n\tconsdev = device_create_with_groups(&tty_class, NULL,\n\t\t\t\t\t    MKDEV(TTYAUX_MAJOR, 1), NULL,\n\t\t\t\t\t    cons_dev_groups, \"console\");\n\tif (IS_ERR(consdev))\n\t\tconsdev = NULL;\n\n#ifdef CONFIG_VT\n\tvty_init(&console_fops);\n#endif\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}