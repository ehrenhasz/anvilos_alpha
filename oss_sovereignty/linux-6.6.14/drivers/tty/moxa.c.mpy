{
  "module_name": "moxa.c",
  "hash_id": "c501133ee0240c0a2ce8a8ce8f3981c95487418598799ff4d899c19251e8deeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/moxa.c",
  "human_readable_source": "\n \n \n\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/firmware.h>\n#include <linux/signal.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/ptrace.h>\n#include <linux/serial.h>\n#include <linux/tty_driver.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/ratelimit.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#define\tMOXA\t\t\t0x400\n#define MOXA_GET_IQUEUE\t\t(MOXA + 1)\t \n#define MOXA_GET_OQUEUE\t\t(MOXA + 2)\t \n#define MOXA_GETDATACOUNT       (MOXA + 23)\n#define MOXA_GET_IOQUEUE\t(MOXA + 27)\n#define MOXA_FLUSH_QUEUE\t(MOXA + 28)\n#define MOXA_GETMSTATUS         (MOXA + 65)\n\n \n\n#define Magic_code\t0x404\n\n \n#define C218_ConfBase\t0x800\n#define C218_status\t(C218_ConfBase + 0)\t \n#define C218_diag\t(C218_ConfBase + 2)\t \n#define C218_key\t(C218_ConfBase + 4)\t \n#define C218DLoad_len\t(C218_ConfBase + 6)\t \n#define C218check_sum\t(C218_ConfBase + 8)\t \n#define C218chksum_ok\t(C218_ConfBase + 0x0a)\t \n#define C218_TestRx\t(C218_ConfBase + 0x10)\t \n#define C218_TestTx\t(C218_ConfBase + 0x18)\t \n#define C218_RXerr\t(C218_ConfBase + 0x20)\t \n#define C218_ErrFlag\t(C218_ConfBase + 0x28)\t \n\n#define C218_LoadBuf\t0x0F00\n#define C218_KeyCode\t0x218\n#define CP204J_KeyCode\t0x204\n\n \n#define C320_ConfBase\t0x800\n#define C320_LoadBuf\t0x0f00\n#define STS_init\t0x05\t \n\n#define C320_status\tC320_ConfBase + 0\t \n#define C320_diag\tC320_ConfBase + 2\t \n#define C320_key\tC320_ConfBase + 4\t \n#define C320DLoad_len\tC320_ConfBase + 6\t \n#define C320check_sum\tC320_ConfBase + 8\t \n#define C320chksum_ok\tC320_ConfBase + 0x0a\t \n#define C320bapi_len\tC320_ConfBase + 0x0c\t \n#define C320UART_no\tC320_ConfBase + 0x0e\t \n\n#define C320_KeyCode\t0x320\n\n#define FixPage_addr\t0x0000\t \n#define DynPage_addr\t0x2000\t \n#define C218_start\t0x3000\t \n#define Control_reg\t0x1ff0\t \n#define HW_reset\t0x80\n\n \n#define FC_CardReset\t0x80\n#define FC_ChannelReset 1\t \n#define FC_EnableCH\t2\n#define FC_DisableCH\t3\n#define FC_SetParam\t4\n#define FC_SetMode\t5\n#define FC_SetRate\t6\n#define FC_LineControl\t7\n#define FC_LineStatus\t8\n#define FC_XmitControl\t9\n#define FC_FlushQueue\t10\n#define FC_SendBreak\t11\n#define FC_StopBreak\t12\n#define FC_LoopbackON\t13\n#define FC_LoopbackOFF\t14\n#define FC_ClrIrqTable\t15\n#define FC_SendXon\t16\n#define FC_SetTermIrq\t17\t \n#define FC_SetCntIrq\t18\t \n#define FC_SetBreakIrq\t19\n#define FC_SetLineIrq\t20\n#define FC_SetFlowCtl\t21\n#define FC_GenIrq\t22\n#define FC_InCD180\t23\n#define FC_OutCD180\t24\n#define FC_InUARTreg\t23\n#define FC_OutUARTreg\t24\n#define FC_SetXonXoff\t25\n#define FC_OutCD180CCR\t26\n#define FC_ExtIQueue\t27\n#define FC_ExtOQueue\t28\n#define FC_ClrLineIrq\t29\n#define FC_HWFlowCtl\t30\n#define FC_GetClockRate 35\n#define FC_SetBaud\t36\n#define FC_SetDataMode  41\n#define FC_GetCCSR      43\n#define FC_GetDataError 45\n#define FC_RxControl\t50\n#define FC_ImmSend\t51\n#define FC_SetXonState\t52\n#define FC_SetXoffState\t53\n#define FC_SetRxFIFOTrig 54\n#define FC_SetTxFIFOCnt 55\n#define FC_UnixRate\t56\n#define FC_UnixResetTimer 57\n\n#define\tRxFIFOTrig1\t0\n#define\tRxFIFOTrig4\t1\n#define\tRxFIFOTrig8\t2\n#define\tRxFIFOTrig14\t3\n\n \n#define DRAM_global\t0\n#define INT_data\t(DRAM_global + 0)\n#define Config_base\t(DRAM_global + 0x108)\n\n#define IRQindex\t(INT_data + 0)\n#define IRQpending\t(INT_data + 4)\n#define IRQtable\t(INT_data + 8)\n\n \n#define IntrRx\t\t0x01\t \n#define IntrTx\t\t0x02\t \n#define IntrFunc\t0x04\t \n#define IntrBreak\t0x08\t \n#define IntrLine\t0x10\t \n#define IntrIntr\t0x20\t \n#define IntrQuit\t0x40\t \n#define IntrEOF\t\t0x80\t \n\n#define IntrRxTrigger\t0x100\t \n#define IntrTxTrigger\t0x200\t \n\n#define Magic_no\t(Config_base + 0)\n#define Card_model_no\t(Config_base + 2)\n#define Total_ports\t(Config_base + 4)\n#define Module_cnt\t(Config_base + 8)\n#define Module_no\t(Config_base + 10)\n#define Timer_10ms\t(Config_base + 14)\n#define Disable_IRQ\t(Config_base + 20)\n#define TMS320_PORT1\t(Config_base + 22)\n#define TMS320_PORT2\t(Config_base + 24)\n#define TMS320_CLOCK\t(Config_base + 26)\n\n \n#define Extern_table\t0x400\t \n#define Extern_size\t0x60\t \n#define RXrptr\t\t0x00\t \n#define RXwptr\t\t0x02\t \n#define TXrptr\t\t0x04\t \n#define TXwptr\t\t0x06\t \n#define HostStat\t0x08\t \n#define FlagStat\t0x0A\n#define FlowControl\t0x0C\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n#define Break_cnt\t0x0E\t \n#define CD180TXirq\t0x10\t \n#define RX_mask\t\t0x12\n#define TX_mask\t\t0x14\n#define Ofs_rxb\t\t0x16\n#define Ofs_txb\t\t0x18\n#define Page_rxb\t0x1A\n#define Page_txb\t0x1C\n#define EndPage_rxb\t0x1E\n#define EndPage_txb\t0x20\n#define Data_error\t0x22\n#define RxTrigger\t0x28\n#define TxTrigger\t0x2a\n\n#define rRXwptr\t\t0x34\n#define Low_water\t0x36\n\n#define FuncCode\t0x40\n#define FuncArg\t\t0x42\n#define FuncArg1\t0x44\n\n#define C218rx_size\t0x2000\t \n#define C218tx_size\t0x8000\t \n\n#define C218rx_mask\t(C218rx_size - 1)\n#define C218tx_mask\t(C218tx_size - 1)\n\n#define C320p8rx_size\t0x2000\n#define C320p8tx_size\t0x8000\n#define C320p8rx_mask\t(C320p8rx_size - 1)\n#define C320p8tx_mask\t(C320p8tx_size - 1)\n\n#define C320p16rx_size\t0x2000\n#define C320p16tx_size\t0x4000\n#define C320p16rx_mask\t(C320p16rx_size - 1)\n#define C320p16tx_mask\t(C320p16tx_size - 1)\n\n#define C320p24rx_size\t0x2000\n#define C320p24tx_size\t0x2000\n#define C320p24rx_mask\t(C320p24rx_size - 1)\n#define C320p24tx_mask\t(C320p24tx_size - 1)\n\n#define C320p32rx_size\t0x1000\n#define C320p32tx_size\t0x1000\n#define C320p32rx_mask\t(C320p32rx_size - 1)\n#define C320p32tx_mask\t(C320p32tx_size - 1)\n\n#define Page_size\t0x2000U\n#define Page_mask\t(Page_size - 1)\n#define C218rx_spage\t3\n#define C218tx_spage\t4\n#define C218rx_pageno\t1\n#define C218tx_pageno\t4\n#define C218buf_pageno\t5\n\n#define C320p8rx_spage\t3\n#define C320p8tx_spage\t4\n#define C320p8rx_pgno\t1\n#define C320p8tx_pgno\t4\n#define C320p8buf_pgno\t5\n\n#define C320p16rx_spage 3\n#define C320p16tx_spage 4\n#define C320p16rx_pgno\t1\n#define C320p16tx_pgno\t2\n#define C320p16buf_pgno 3\n\n#define C320p24rx_spage 3\n#define C320p24tx_spage 4\n#define C320p24rx_pgno\t1\n#define C320p24tx_pgno\t1\n#define C320p24buf_pgno 2\n\n#define C320p32rx_spage 3\n#define C320p32tx_ofs\tC320p32rx_size\n#define C320p32tx_spage 3\n#define C320p32buf_pgno 1\n\n \n#define WakeupRx\t0x01\n#define WakeupTx\t0x02\n#define WakeupBreak\t0x08\n#define WakeupLine\t0x10\n#define WakeupIntr\t0x20\n#define WakeupQuit\t0x40\n#define WakeupEOF\t0x80\t \n#define WakeupRxTrigger\t0x100\n#define WakeupTxTrigger\t0x200\n \n#define Rx_over\t\t0x01\n#define Xoff_state\t0x02\n#define Tx_flowOff\t0x04\n#define Tx_enable\t0x08\n#define CTS_state\t0x10\n#define DSR_state\t0x20\n#define DCD_state\t0x80\n \n#define CTS_FlowCtl\t1\n#define RTS_FlowCtl\t2\n#define Tx_FlowCtl\t4\n#define Rx_FlowCtl\t8\n#define IXM_IXANY\t0x10\n\n#define LowWater\t128\n\n#define DTR_ON\t\t1\n#define RTS_ON\t\t2\n#define CTS_ON\t\t1\n#define DSR_ON\t\t2\n#define DCD_ON\t\t8\n\n \n#define\tMX_CS8\t\t0x03\n#define\tMX_CS7\t\t0x02\n#define\tMX_CS6\t\t0x01\n#define\tMX_CS5\t\t0x00\n\n#define\tMX_STOP1\t0x00\n#define\tMX_STOP15\t0x04\n#define\tMX_STOP2\t0x08\n\n#define\tMX_PARNONE\t0x00\n#define\tMX_PAREVEN\t0x40\n#define\tMX_PARODD\t0xC0\n#define\tMX_PARMARK\t0xA0\n#define\tMX_PARSPACE\t0x20\n\n#define MOXA_VERSION\t\t\"6.0k\"\n\n#define MOXA_FW_HDRLEN\t\t32\n\n#define MOXAMAJOR\t\t172\n\n#define MAX_BOARDS\t\t4\t \n#define MAX_PORTS_PER_BOARD\t32\t \n#define MAX_PORTS\t\t(MAX_BOARDS * MAX_PORTS_PER_BOARD)\n\n#define MOXA_IS_320(brd) ((brd)->boardType == MOXA_BOARD_C320_ISA || \\\n\t\t(brd)->boardType == MOXA_BOARD_C320_PCI)\n\n \n#define MOXA_BUS_TYPE_ISA\t0\n#define MOXA_BUS_TYPE_PCI\t1\n\nenum {\n\tMOXA_BOARD_C218_PCI = 1,\n\tMOXA_BOARD_C218_ISA,\n\tMOXA_BOARD_C320_PCI,\n\tMOXA_BOARD_C320_ISA,\n\tMOXA_BOARD_CP204J,\n};\n\nstatic char *moxa_brdname[] =\n{\n\t\"C218 Turbo PCI series\",\n\t\"C218 Turbo ISA series\",\n\t\"C320 Turbo PCI series\",\n\t\"C320 Turbo ISA series\",\n\t\"CP-204J series\",\n};\n\n#ifdef CONFIG_PCI\nstatic const struct pci_device_id moxa_pcibrds[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_C218),\n\t\t.driver_data = MOXA_BOARD_C218_PCI },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_C320),\n\t\t.driver_data = MOXA_BOARD_C320_PCI },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP204J),\n\t\t.driver_data = MOXA_BOARD_CP204J },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, moxa_pcibrds);\n#endif  \n\nstruct moxa_port;\n\nstatic struct moxa_board_conf {\n\tint boardType;\n\tint numPorts;\n\tint busType;\n\n\tunsigned int ready;\n\n\tstruct moxa_port *ports;\n\n\tvoid __iomem *basemem;\n\tvoid __iomem *intNdx;\n\tvoid __iomem *intPend;\n\tvoid __iomem *intTable;\n} moxa_boards[MAX_BOARDS];\n\nstruct mxser_mstatus {\n\ttcflag_t cflag;\n\tint cts;\n\tint dsr;\n\tint ri;\n\tint dcd;\n};\n\nstruct moxaq_str {\n\tint inq;\n\tint outq;\n};\n\nstruct moxa_port {\n\tstruct tty_port port;\n\tstruct moxa_board_conf *board;\n\tvoid __iomem *tableAddr;\n\n\tint type;\n\tint cflag;\n\tunsigned long statusflags;\n\n\tu8 DCDState;\t\t \n\tu8 lineCtrl;\n\tu8 lowChkFlag;\n};\n\nstruct mon_str {\n\tint tick;\n\tint rxcnt[MAX_PORTS];\n\tint txcnt[MAX_PORTS];\n};\n\n \n#define TXSTOPPED\t1\n#define LOWWAIT \t2\n#define EMPTYWAIT\t3\n\n\n#define WAKEUP_CHARS\t\t256\n\nstatic int ttymajor = MOXAMAJOR;\nstatic struct mon_str moxaLog;\nstatic unsigned int moxaFuncTout = HZ / 2;\nstatic unsigned int moxaLowWaterChk;\nstatic DEFINE_MUTEX(moxa_openlock);\nstatic DEFINE_SPINLOCK(moxa_lock);\n\nstatic unsigned long baseaddr[MAX_BOARDS];\nstatic unsigned int type[MAX_BOARDS];\nstatic unsigned int numports[MAX_BOARDS];\nstatic struct tty_port moxa_service_port;\n\nMODULE_AUTHOR(\"William Chen\");\nMODULE_DESCRIPTION(\"MOXA Intellio Family Multiport Board Device Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"c218tunx.cod\");\nMODULE_FIRMWARE(\"cp204unx.cod\");\nMODULE_FIRMWARE(\"c320tunx.cod\");\n\nmodule_param_array(type, uint, NULL, 0);\nMODULE_PARM_DESC(type, \"card type: C218=2, C320=4\");\nmodule_param_hw_array(baseaddr, ulong, ioport, NULL, 0);\nMODULE_PARM_DESC(baseaddr, \"base address\");\nmodule_param_array(numports, uint, NULL, 0);\nMODULE_PARM_DESC(numports, \"numports (ignored for C218)\");\n\nmodule_param(ttymajor, int, 0);\n\n \nstatic int moxa_open(struct tty_struct *, struct file *);\nstatic void moxa_close(struct tty_struct *, struct file *);\nstatic ssize_t moxa_write(struct tty_struct *, const u8 *, size_t);\nstatic unsigned int moxa_write_room(struct tty_struct *);\nstatic void moxa_flush_buffer(struct tty_struct *);\nstatic unsigned int moxa_chars_in_buffer(struct tty_struct *);\nstatic void moxa_set_termios(struct tty_struct *, const struct ktermios *);\nstatic void moxa_stop(struct tty_struct *);\nstatic void moxa_start(struct tty_struct *);\nstatic void moxa_hangup(struct tty_struct *);\nstatic int moxa_tiocmget(struct tty_struct *tty);\nstatic int moxa_tiocmset(struct tty_struct *tty,\n\t\t\t unsigned int set, unsigned int clear);\nstatic void moxa_poll(struct timer_list *);\nstatic void moxa_set_tty_param(struct tty_struct *, const struct ktermios *);\nstatic void moxa_shutdown(struct tty_port *);\nstatic bool moxa_carrier_raised(struct tty_port *);\nstatic void moxa_dtr_rts(struct tty_port *, bool);\n \nstatic void MoxaPortEnable(struct moxa_port *);\nstatic void MoxaPortDisable(struct moxa_port *);\nstatic int MoxaPortSetTermio(struct moxa_port *, struct ktermios *, speed_t);\nstatic int MoxaPortGetLineOut(struct moxa_port *, bool *, bool *);\nstatic void MoxaPortLineCtrl(struct moxa_port *, bool, bool);\nstatic void MoxaPortFlowCtrl(struct moxa_port *, int, int, int, int, int);\nstatic int MoxaPortLineStatus(struct moxa_port *);\nstatic void MoxaPortFlushData(struct moxa_port *, int);\nstatic int MoxaPortWriteData(struct tty_struct *, const unsigned char *, int);\nstatic int MoxaPortReadData(struct moxa_port *);\nstatic unsigned int MoxaPortTxQueue(struct moxa_port *);\nstatic int MoxaPortRxQueue(struct moxa_port *);\nstatic unsigned int MoxaPortTxFree(struct moxa_port *);\nstatic void MoxaPortTxDisable(struct moxa_port *);\nstatic void MoxaPortTxEnable(struct moxa_port *);\nstatic int moxa_get_serial_info(struct tty_struct *, struct serial_struct *);\nstatic int moxa_set_serial_info(struct tty_struct *, struct serial_struct *);\nstatic void MoxaSetFifo(struct moxa_port *port, int enable);\n\n \n\nstatic DEFINE_SPINLOCK(moxafunc_lock);\n\nstatic void moxa_wait_finish(void __iomem *ofsAddr)\n{\n\tunsigned long end = jiffies + moxaFuncTout;\n\n\twhile (readw(ofsAddr + FuncCode) != 0)\n\t\tif (time_after(jiffies, end))\n\t\t\treturn;\n\tif (readw(ofsAddr + FuncCode) != 0)\n\t\tprintk_ratelimited(KERN_WARNING \"moxa function expired\\n\");\n}\n\nstatic void moxafunc(void __iomem *ofsAddr, u16 cmd, u16 arg)\n{\n        unsigned long flags;\n        spin_lock_irqsave(&moxafunc_lock, flags);\n\twritew(arg, ofsAddr + FuncArg);\n\twritew(cmd, ofsAddr + FuncCode);\n\tmoxa_wait_finish(ofsAddr);\n\tspin_unlock_irqrestore(&moxafunc_lock, flags);\n}\n\nstatic int moxafuncret(void __iomem *ofsAddr, u16 cmd, u16 arg)\n{\n        unsigned long flags;\n        u16 ret;\n        spin_lock_irqsave(&moxafunc_lock, flags);\n\twritew(arg, ofsAddr + FuncArg);\n\twritew(cmd, ofsAddr + FuncCode);\n\tmoxa_wait_finish(ofsAddr);\n\tret = readw(ofsAddr + FuncArg);\n\tspin_unlock_irqrestore(&moxafunc_lock, flags);\n\treturn ret;\n}\n\nstatic void moxa_low_water_check(void __iomem *ofsAddr)\n{\n\tu16 rptr, wptr, mask, len;\n\n\tif (readb(ofsAddr + FlagStat) & Xoff_state) {\n\t\trptr = readw(ofsAddr + RXrptr);\n\t\twptr = readw(ofsAddr + RXwptr);\n\t\tmask = readw(ofsAddr + RX_mask);\n\t\tlen = (wptr - rptr) & mask;\n\t\tif (len <= Low_water)\n\t\t\tmoxafunc(ofsAddr, FC_SendXon, 0);\n\t}\n}\n\n \n\nstatic int moxa_ioctl(struct tty_struct *tty,\n\t\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct moxa_port *ch = tty->driver_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint status, ret = 0;\n\n\tif (tty->index == MAX_PORTS) {\n\t\tif (cmd != MOXA_GETDATACOUNT && cmd != MOXA_GET_IOQUEUE &&\n\t\t\t\tcmd != MOXA_GETMSTATUS)\n\t\t\treturn -EINVAL;\n\t} else if (!ch)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase MOXA_GETDATACOUNT:\n\t\tmoxaLog.tick = jiffies;\n\t\tif (copy_to_user(argp, &moxaLog, sizeof(moxaLog)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase MOXA_FLUSH_QUEUE:\n\t\tMoxaPortFlushData(ch, arg);\n\t\tbreak;\n\tcase MOXA_GET_IOQUEUE: {\n\t\tstruct moxaq_str __user *argm = argp;\n\t\tstruct moxaq_str tmp;\n\t\tstruct moxa_port *p;\n\t\tunsigned int i, j;\n\n\t\tfor (i = 0; i < MAX_BOARDS; i++) {\n\t\t\tp = moxa_boards[i].ports;\n\t\t\tfor (j = 0; j < MAX_PORTS_PER_BOARD; j++, p++, argm++) {\n\t\t\t\tmemset(&tmp, 0, sizeof(tmp));\n\t\t\t\tspin_lock_bh(&moxa_lock);\n\t\t\t\tif (moxa_boards[i].ready) {\n\t\t\t\t\ttmp.inq = MoxaPortRxQueue(p);\n\t\t\t\t\ttmp.outq = MoxaPortTxQueue(p);\n\t\t\t\t}\n\t\t\t\tspin_unlock_bh(&moxa_lock);\n\t\t\t\tif (copy_to_user(argm, &tmp, sizeof(tmp)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t} case MOXA_GET_OQUEUE:\n\t\tstatus = MoxaPortTxQueue(ch);\n\t\tret = put_user(status, (unsigned long __user *)argp);\n\t\tbreak;\n\tcase MOXA_GET_IQUEUE:\n\t\tstatus = MoxaPortRxQueue(ch);\n\t\tret = put_user(status, (unsigned long __user *)argp);\n\t\tbreak;\n\tcase MOXA_GETMSTATUS: {\n\t\tstruct mxser_mstatus __user *argm = argp;\n\t\tstruct mxser_mstatus tmp;\n\t\tstruct moxa_port *p;\n\t\tunsigned int i, j;\n\n\t\tfor (i = 0; i < MAX_BOARDS; i++) {\n\t\t\tp = moxa_boards[i].ports;\n\t\t\tfor (j = 0; j < MAX_PORTS_PER_BOARD; j++, p++, argm++) {\n\t\t\t\tstruct tty_struct *ttyp;\n\t\t\t\tmemset(&tmp, 0, sizeof(tmp));\n\t\t\t\tspin_lock_bh(&moxa_lock);\n\t\t\t\tif (!moxa_boards[i].ready) {\n\t\t\t\t        spin_unlock_bh(&moxa_lock);\n\t\t\t\t\tgoto copy;\n                                }\n\n\t\t\t\tstatus = MoxaPortLineStatus(p);\n\t\t\t\tspin_unlock_bh(&moxa_lock);\n\n\t\t\t\tif (status & 1)\n\t\t\t\t\ttmp.cts = 1;\n\t\t\t\tif (status & 2)\n\t\t\t\t\ttmp.dsr = 1;\n\t\t\t\tif (status & 4)\n\t\t\t\t\ttmp.dcd = 1;\n\n\t\t\t\tttyp = tty_port_tty_get(&p->port);\n\t\t\t\tif (!ttyp)\n\t\t\t\t\ttmp.cflag = p->cflag;\n\t\t\t\telse\n\t\t\t\t\ttmp.cflag = ttyp->termios.c_cflag;\n\t\t\t\ttty_kref_put(ttyp);\ncopy:\n\t\t\t\tif (copy_to_user(argm, &tmp, sizeof(tmp)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\treturn ret;\n}\n\nstatic int moxa_break_ctl(struct tty_struct *tty, int state)\n{\n\tstruct moxa_port *port = tty->driver_data;\n\n\tmoxafunc(port->tableAddr, state ? FC_SendBreak : FC_StopBreak,\n\t\t\tMagic_code);\n\treturn 0;\n}\n\nstatic const struct tty_operations moxa_ops = {\n\t.open = moxa_open,\n\t.close = moxa_close,\n\t.write = moxa_write,\n\t.write_room = moxa_write_room,\n\t.flush_buffer = moxa_flush_buffer,\n\t.chars_in_buffer = moxa_chars_in_buffer,\n\t.ioctl = moxa_ioctl,\n\t.set_termios = moxa_set_termios,\n\t.stop = moxa_stop,\n\t.start = moxa_start,\n\t.hangup = moxa_hangup,\n\t.break_ctl = moxa_break_ctl,\n\t.tiocmget = moxa_tiocmget,\n\t.tiocmset = moxa_tiocmset,\n\t.set_serial = moxa_set_serial_info,\n\t.get_serial = moxa_get_serial_info,\n};\n\nstatic const struct tty_port_operations moxa_port_ops = {\n\t.carrier_raised = moxa_carrier_raised,\n\t.dtr_rts = moxa_dtr_rts,\n\t.shutdown = moxa_shutdown,\n};\n\nstatic struct tty_driver *moxaDriver;\nstatic DEFINE_TIMER(moxaTimer, moxa_poll);\n\n \n\nstatic int moxa_check_fw_model(struct moxa_board_conf *brd, u8 model)\n{\n\tswitch (brd->boardType) {\n\tcase MOXA_BOARD_C218_ISA:\n\tcase MOXA_BOARD_C218_PCI:\n\t\tif (model != 1)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase MOXA_BOARD_CP204J:\n\t\tif (model != 3)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tif (model != 2)\n\t\t\tgoto err;\n\t\tbreak;\n\t}\n\treturn 0;\nerr:\n\treturn -EINVAL;\n}\n\nstatic int moxa_check_fw(const void *ptr)\n{\n\tconst __le16 *lptr = ptr;\n\n\tif (*lptr != cpu_to_le16(0x7980))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int moxa_load_bios(struct moxa_board_conf *brd, const u8 *buf,\n\t\tsize_t len)\n{\n\tvoid __iomem *baseAddr = brd->basemem;\n\tu16 tmp;\n\n\twriteb(HW_reset, baseAddr + Control_reg);\t \n\tmsleep(10);\n\tmemset_io(baseAddr, 0, 4096);\n\tmemcpy_toio(baseAddr, buf, len);\t \n\twriteb(0, baseAddr + Control_reg);\t \n\n\tmsleep(2000);\n\n\tswitch (brd->boardType) {\n\tcase MOXA_BOARD_C218_ISA:\n\tcase MOXA_BOARD_C218_PCI:\n\t\ttmp = readw(baseAddr + C218_key);\n\t\tif (tmp != C218_KeyCode)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase MOXA_BOARD_CP204J:\n\t\ttmp = readw(baseAddr + C218_key);\n\t\tif (tmp != CP204J_KeyCode)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\ttmp = readw(baseAddr + C320_key);\n\t\tif (tmp != C320_KeyCode)\n\t\t\tgoto err;\n\t\ttmp = readw(baseAddr + C320_status);\n\t\tif (tmp != STS_init) {\n\t\t\tprintk(KERN_ERR \"MOXA: bios upload failed -- CPU/Basic \"\n\t\t\t\t\t\"module not found\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\nerr:\n\tprintk(KERN_ERR \"MOXA: bios upload failed -- board not found\\n\");\n\treturn -EIO;\n}\n\nstatic int moxa_load_320b(struct moxa_board_conf *brd, const u8 *ptr,\n\t\tsize_t len)\n{\n\tvoid __iomem *baseAddr = brd->basemem;\n\n\tif (len < 7168) {\n\t\tprintk(KERN_ERR \"MOXA: invalid 320 bios -- too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twritew(len - 7168 - 2, baseAddr + C320bapi_len);\n\twriteb(1, baseAddr + Control_reg);\t \n\tmemcpy_toio(baseAddr + DynPage_addr, ptr, 7168);\n\twriteb(2, baseAddr + Control_reg);\t \n\tmemcpy_toio(baseAddr + DynPage_addr, ptr + 7168, len - 7168);\n\n\treturn 0;\n}\n\nstatic int moxa_real_load_code(struct moxa_board_conf *brd, const void *ptr,\n\t\tsize_t len)\n{\n\tvoid __iomem *baseAddr = brd->basemem;\n\tconst __le16 *uptr = ptr;\n\tsize_t wlen, len2, j;\n\tunsigned long key, loadbuf, loadlen, checksum, checksum_ok;\n\tunsigned int i, retry;\n\tu16 usum, keycode;\n\n\tkeycode = (brd->boardType == MOXA_BOARD_CP204J) ? CP204J_KeyCode :\n\t\t\t\tC218_KeyCode;\n\n\tswitch (brd->boardType) {\n\tcase MOXA_BOARD_CP204J:\n\tcase MOXA_BOARD_C218_ISA:\n\tcase MOXA_BOARD_C218_PCI:\n\t\tkey = C218_key;\n\t\tloadbuf = C218_LoadBuf;\n\t\tloadlen = C218DLoad_len;\n\t\tchecksum = C218check_sum;\n\t\tchecksum_ok = C218chksum_ok;\n\t\tbreak;\n\tdefault:\n\t\tkey = C320_key;\n\t\tkeycode = C320_KeyCode;\n\t\tloadbuf = C320_LoadBuf;\n\t\tloadlen = C320DLoad_len;\n\t\tchecksum = C320check_sum;\n\t\tchecksum_ok = C320chksum_ok;\n\t\tbreak;\n\t}\n\n\tusum = 0;\n\twlen = len >> 1;\n\tfor (i = 0; i < wlen; i++)\n\t\tusum += le16_to_cpu(uptr[i]);\n\tretry = 0;\n\tdo {\n\t\twlen = len >> 1;\n\t\tj = 0;\n\t\twhile (wlen) {\n\t\t\tlen2 = (wlen > 2048) ? 2048 : wlen;\n\t\t\twlen -= len2;\n\t\t\tmemcpy_toio(baseAddr + loadbuf, ptr + j, len2 << 1);\n\t\t\tj += len2 << 1;\n\n\t\t\twritew(len2, baseAddr + loadlen);\n\t\t\twritew(0, baseAddr + key);\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (readw(baseAddr + key) == keycode)\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(10);\n\t\t\t}\n\t\t\tif (readw(baseAddr + key) != keycode)\n\t\t\t\treturn -EIO;\n\t\t}\n\t\twritew(0, baseAddr + loadlen);\n\t\twritew(usum, baseAddr + checksum);\n\t\twritew(0, baseAddr + key);\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tif (readw(baseAddr + key) == keycode)\n\t\t\t\tbreak;\n\t\t\tmsleep(10);\n\t\t}\n\t\tretry++;\n\t} while ((readb(baseAddr + checksum_ok) != 1) && (retry < 3));\n\tif (readb(baseAddr + checksum_ok) != 1)\n\t\treturn -EIO;\n\n\twritew(0, baseAddr + key);\n\tfor (i = 0; i < 600; i++) {\n\t\tif (readw(baseAddr + Magic_no) == Magic_code)\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\tif (readw(baseAddr + Magic_no) != Magic_code)\n\t\treturn -EIO;\n\n\tif (MOXA_IS_320(brd)) {\n\t\tif (brd->busType == MOXA_BUS_TYPE_PCI) {\t \n\t\t\twritew(0x3800, baseAddr + TMS320_PORT1);\n\t\t\twritew(0x3900, baseAddr + TMS320_PORT2);\n\t\t\twritew(28499, baseAddr + TMS320_CLOCK);\n\t\t} else {\n\t\t\twritew(0x3200, baseAddr + TMS320_PORT1);\n\t\t\twritew(0x3400, baseAddr + TMS320_PORT2);\n\t\t\twritew(19999, baseAddr + TMS320_CLOCK);\n\t\t}\n\t}\n\twritew(1, baseAddr + Disable_IRQ);\n\twritew(0, baseAddr + Magic_no);\n\tfor (i = 0; i < 500; i++) {\n\t\tif (readw(baseAddr + Magic_no) == Magic_code)\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\tif (readw(baseAddr + Magic_no) != Magic_code)\n\t\treturn -EIO;\n\n\tif (MOXA_IS_320(brd)) {\n\t\tj = readw(baseAddr + Module_cnt);\n\t\tif (j <= 0)\n\t\t\treturn -EIO;\n\t\tbrd->numPorts = j * 8;\n\t\twritew(j, baseAddr + Module_no);\n\t\twritew(0, baseAddr + Magic_no);\n\t\tfor (i = 0; i < 600; i++) {\n\t\t\tif (readw(baseAddr + Magic_no) == Magic_code)\n\t\t\t\tbreak;\n\t\t\tmsleep(10);\n\t\t}\n\t\tif (readw(baseAddr + Magic_no) != Magic_code)\n\t\t\treturn -EIO;\n\t}\n\tbrd->intNdx = baseAddr + IRQindex;\n\tbrd->intPend = baseAddr + IRQpending;\n\tbrd->intTable = baseAddr + IRQtable;\n\n\treturn 0;\n}\n\nstatic int moxa_load_code(struct moxa_board_conf *brd, const void *ptr,\n\t\tsize_t len)\n{\n\tvoid __iomem *ofsAddr, *baseAddr = brd->basemem;\n\tstruct moxa_port *port;\n\tint retval, i;\n\n\tif (len % 2) {\n\t\tprintk(KERN_ERR \"MOXA: bios length is not even\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tretval = moxa_real_load_code(brd, ptr, len);  \n\tif (retval)\n\t\treturn retval;\n\n\tswitch (brd->boardType) {\n\tcase MOXA_BOARD_C218_ISA:\n\tcase MOXA_BOARD_C218_PCI:\n\tcase MOXA_BOARD_CP204J:\n\t\tport = brd->ports;\n\t\tfor (i = 0; i < brd->numPorts; i++, port++) {\n\t\t\tport->board = brd;\n\t\t\tport->DCDState = 0;\n\t\t\tport->tableAddr = baseAddr + Extern_table +\n\t\t\t\t\tExtern_size * i;\n\t\t\tofsAddr = port->tableAddr;\n\t\t\twritew(C218rx_mask, ofsAddr + RX_mask);\n\t\t\twritew(C218tx_mask, ofsAddr + TX_mask);\n\t\t\twritew(C218rx_spage + i * C218buf_pageno, ofsAddr + Page_rxb);\n\t\t\twritew(readw(ofsAddr + Page_rxb) + C218rx_pageno, ofsAddr + EndPage_rxb);\n\n\t\t\twritew(C218tx_spage + i * C218buf_pageno, ofsAddr + Page_txb);\n\t\t\twritew(readw(ofsAddr + Page_txb) + C218tx_pageno, ofsAddr + EndPage_txb);\n\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tport = brd->ports;\n\t\tfor (i = 0; i < brd->numPorts; i++, port++) {\n\t\t\tport->board = brd;\n\t\t\tport->DCDState = 0;\n\t\t\tport->tableAddr = baseAddr + Extern_table +\n\t\t\t\t\tExtern_size * i;\n\t\t\tofsAddr = port->tableAddr;\n\t\t\tswitch (brd->numPorts) {\n\t\t\tcase 8:\n\t\t\t\twritew(C320p8rx_mask, ofsAddr + RX_mask);\n\t\t\t\twritew(C320p8tx_mask, ofsAddr + TX_mask);\n\t\t\t\twritew(C320p8rx_spage + i * C320p8buf_pgno, ofsAddr + Page_rxb);\n\t\t\t\twritew(readw(ofsAddr + Page_rxb) + C320p8rx_pgno, ofsAddr + EndPage_rxb);\n\t\t\t\twritew(C320p8tx_spage + i * C320p8buf_pgno, ofsAddr + Page_txb);\n\t\t\t\twritew(readw(ofsAddr + Page_txb) + C320p8tx_pgno, ofsAddr + EndPage_txb);\n\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\twritew(C320p16rx_mask, ofsAddr + RX_mask);\n\t\t\t\twritew(C320p16tx_mask, ofsAddr + TX_mask);\n\t\t\t\twritew(C320p16rx_spage + i * C320p16buf_pgno, ofsAddr + Page_rxb);\n\t\t\t\twritew(readw(ofsAddr + Page_rxb) + C320p16rx_pgno, ofsAddr + EndPage_rxb);\n\t\t\t\twritew(C320p16tx_spage + i * C320p16buf_pgno, ofsAddr + Page_txb);\n\t\t\t\twritew(readw(ofsAddr + Page_txb) + C320p16tx_pgno, ofsAddr + EndPage_txb);\n\t\t\t\tbreak;\n\n\t\t\tcase 24:\n\t\t\t\twritew(C320p24rx_mask, ofsAddr + RX_mask);\n\t\t\t\twritew(C320p24tx_mask, ofsAddr + TX_mask);\n\t\t\t\twritew(C320p24rx_spage + i * C320p24buf_pgno, ofsAddr + Page_rxb);\n\t\t\t\twritew(readw(ofsAddr + Page_rxb) + C320p24rx_pgno, ofsAddr + EndPage_rxb);\n\t\t\t\twritew(C320p24tx_spage + i * C320p24buf_pgno, ofsAddr + Page_txb);\n\t\t\t\twritew(readw(ofsAddr + Page_txb), ofsAddr + EndPage_txb);\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\twritew(C320p32rx_mask, ofsAddr + RX_mask);\n\t\t\t\twritew(C320p32tx_mask, ofsAddr + TX_mask);\n\t\t\t\twritew(C320p32tx_ofs, ofsAddr + Ofs_txb);\n\t\t\t\twritew(C320p32rx_spage + i * C320p32buf_pgno, ofsAddr + Page_rxb);\n\t\t\t\twritew(readb(ofsAddr + Page_rxb), ofsAddr + EndPage_rxb);\n\t\t\t\twritew(C320p32tx_spage + i * C320p32buf_pgno, ofsAddr + Page_txb);\n\t\t\t\twritew(readw(ofsAddr + Page_txb), ofsAddr + EndPage_txb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int moxa_load_fw(struct moxa_board_conf *brd, const struct firmware *fw)\n{\n\tconst void *ptr = fw->data;\n\tchar rsn[64];\n\tu16 lens[5];\n\tsize_t len;\n\tunsigned int a, lenp, lencnt;\n\tint ret = -EINVAL;\n\tstruct {\n\t\t__le32 magic;\t \n\t\tu8 reserved1[2];\n\t\tu8 type;\t \n\t\tu8 model;\t \n\t\tu8 reserved2[8];\n\t\t__le16 len[5];\n\t} const *hdr = ptr;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(hdr->len) != ARRAY_SIZE(lens));\n\n\tif (fw->size < MOXA_FW_HDRLEN) {\n\t\tstrcpy(rsn, \"too short (even header won't fit)\");\n\t\tgoto err;\n\t}\n\tif (hdr->magic != cpu_to_le32(0x30343034)) {\n\t\tsprintf(rsn, \"bad magic: %.8x\", le32_to_cpu(hdr->magic));\n\t\tgoto err;\n\t}\n\tif (hdr->type != 3) {\n\t\tsprintf(rsn, \"not for linux, type is %u\", hdr->type);\n\t\tgoto err;\n\t}\n\tif (moxa_check_fw_model(brd, hdr->model)) {\n\t\tsprintf(rsn, \"not for this card, model is %u\", hdr->model);\n\t\tgoto err;\n\t}\n\n\tlen = MOXA_FW_HDRLEN;\n\tlencnt = hdr->model == 2 ? 5 : 3;\n\tfor (a = 0; a < ARRAY_SIZE(lens); a++) {\n\t\tlens[a] = le16_to_cpu(hdr->len[a]);\n\t\tif (lens[a] && len + lens[a] <= fw->size &&\n\t\t\t\tmoxa_check_fw(&fw->data[len]))\n\t\t\tprintk(KERN_WARNING \"MOXA firmware: unexpected input \"\n\t\t\t\t\"at offset %u, but going on\\n\", (u32)len);\n\t\tif (!lens[a] && a < lencnt) {\n\t\t\tsprintf(rsn, \"too few entries in fw file\");\n\t\t\tgoto err;\n\t\t}\n\t\tlen += lens[a];\n\t}\n\n\tif (len != fw->size) {\n\t\tsprintf(rsn, \"bad length: %u (should be %u)\", (u32)fw->size,\n\t\t\t\t(u32)len);\n\t\tgoto err;\n\t}\n\n\tptr += MOXA_FW_HDRLEN;\n\tlenp = 0;  \n\n\tstrcpy(rsn, \"read above\");\n\n\tret = moxa_load_bios(brd, ptr, lens[lenp]);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tptr += lens[lenp] + lens[lenp + 1];\n\tlenp += 2;  \n\n\tif (hdr->model == 2) {\n\t\tret = moxa_load_320b(brd, ptr, lens[lenp]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\t \n\t\tptr += lens[lenp] + lens[lenp + 1];\n\t\tlenp += 2;\n\t}\n\n\tret = moxa_load_code(brd, ptr, lens[lenp]);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tprintk(KERN_ERR \"firmware failed to load, reason: %s\\n\", rsn);\n\treturn ret;\n}\n\nstatic int moxa_init_board(struct moxa_board_conf *brd, struct device *dev)\n{\n\tconst struct firmware *fw;\n\tconst char *file;\n\tstruct moxa_port *p;\n\tunsigned int i, first_idx;\n\tint ret;\n\n\tbrd->ports = kcalloc(MAX_PORTS_PER_BOARD, sizeof(*brd->ports),\n\t\t\tGFP_KERNEL);\n\tif (brd->ports == NULL) {\n\t\tprintk(KERN_ERR \"cannot allocate memory for ports\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0, p = brd->ports; i < MAX_PORTS_PER_BOARD; i++, p++) {\n\t\ttty_port_init(&p->port);\n\t\tp->port.ops = &moxa_port_ops;\n\t\tp->type = PORT_16550A;\n\t\tp->cflag = B9600 | CS8 | CREAD | CLOCAL | HUPCL;\n\t}\n\n\tswitch (brd->boardType) {\n\tcase MOXA_BOARD_C218_ISA:\n\tcase MOXA_BOARD_C218_PCI:\n\t\tfile = \"c218tunx.cod\";\n\t\tbreak;\n\tcase MOXA_BOARD_CP204J:\n\t\tfile = \"cp204unx.cod\";\n\t\tbreak;\n\tdefault:\n\t\tfile = \"c320tunx.cod\";\n\t\tbreak;\n\t}\n\n\tret = request_firmware(&fw, file, dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"MOXA: request_firmware failed. Make sure \"\n\t\t\t\t\"you've placed '%s' file into your firmware \"\n\t\t\t\t\"loader directory (e.g. /lib/firmware)\\n\",\n\t\t\t\tfile);\n\t\tgoto err_free;\n\t}\n\n\tret = moxa_load_fw(brd, fw);\n\n\trelease_firmware(fw);\n\n\tif (ret)\n\t\tgoto err_free;\n\n\tspin_lock_bh(&moxa_lock);\n\tbrd->ready = 1;\n\tif (!timer_pending(&moxaTimer))\n\t\tmod_timer(&moxaTimer, jiffies + HZ / 50);\n\tspin_unlock_bh(&moxa_lock);\n\n\tfirst_idx = (brd - moxa_boards) * MAX_PORTS_PER_BOARD;\n\tfor (i = 0; i < brd->numPorts; i++)\n\t\ttty_port_register_device(&brd->ports[i].port, moxaDriver,\n\t\t\t\tfirst_idx + i, dev);\n\n\treturn 0;\nerr_free:\n\tfor (i = 0; i < MAX_PORTS_PER_BOARD; i++)\n\t\ttty_port_destroy(&brd->ports[i].port);\n\tkfree(brd->ports);\nerr:\n\treturn ret;\n}\n\nstatic void moxa_board_deinit(struct moxa_board_conf *brd)\n{\n\tunsigned int a, opened, first_idx;\n\n\tmutex_lock(&moxa_openlock);\n\tspin_lock_bh(&moxa_lock);\n\tbrd->ready = 0;\n\tspin_unlock_bh(&moxa_lock);\n\n\t \n\tfor (a = 0; a < brd->numPorts; a++)\n\t\tif (tty_port_initialized(&brd->ports[a].port))\n\t\t\ttty_port_tty_hangup(&brd->ports[a].port, false);\n\n\tfor (a = 0; a < MAX_PORTS_PER_BOARD; a++)\n\t\ttty_port_destroy(&brd->ports[a].port);\n\n\twhile (1) {\n\t\topened = 0;\n\t\tfor (a = 0; a < brd->numPorts; a++)\n\t\t\tif (tty_port_initialized(&brd->ports[a].port))\n\t\t\t\topened++;\n\t\tmutex_unlock(&moxa_openlock);\n\t\tif (!opened)\n\t\t\tbreak;\n\t\tmsleep(50);\n\t\tmutex_lock(&moxa_openlock);\n\t}\n\n\tfirst_idx = (brd - moxa_boards) * MAX_PORTS_PER_BOARD;\n\tfor (a = 0; a < brd->numPorts; a++)\n\t\ttty_unregister_device(moxaDriver, first_idx + a);\n\n\tiounmap(brd->basemem);\n\tbrd->basemem = NULL;\n\tkfree(brd->ports);\n}\n\n#ifdef CONFIG_PCI\nstatic int moxa_pci_probe(struct pci_dev *pdev,\n\t\tconst struct pci_device_id *ent)\n{\n\tstruct moxa_board_conf *board;\n\tunsigned int i;\n\tint board_type = ent->driver_data;\n\tint retval;\n\n\tretval = pci_enable_device(pdev);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"can't enable pci device\\n\");\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < MAX_BOARDS; i++)\n\t\tif (moxa_boards[i].basemem == NULL)\n\t\t\tbreak;\n\n\tretval = -ENODEV;\n\tif (i >= MAX_BOARDS) {\n\t\tdev_warn(&pdev->dev, \"more than %u MOXA Intellio family boards \"\n\t\t\t\t\"found. Board is ignored.\\n\", MAX_BOARDS);\n\t\tgoto err;\n\t}\n\n\tboard = &moxa_boards[i];\n\n\tretval = pci_request_region(pdev, 2, \"moxa-base\");\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"can't request pci region 2\\n\");\n\t\tgoto err;\n\t}\n\n\tboard->basemem = ioremap(pci_resource_start(pdev, 2), 0x4000);\n\tif (board->basemem == NULL) {\n\t\tdev_err(&pdev->dev, \"can't remap io space 2\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err_reg;\n\t}\n\n\tboard->boardType = board_type;\n\tswitch (board_type) {\n\tcase MOXA_BOARD_C218_ISA:\n\tcase MOXA_BOARD_C218_PCI:\n\t\tboard->numPorts = 8;\n\t\tbreak;\n\n\tcase MOXA_BOARD_CP204J:\n\t\tboard->numPorts = 4;\n\t\tbreak;\n\tdefault:\n\t\tboard->numPorts = 0;\n\t\tbreak;\n\t}\n\tboard->busType = MOXA_BUS_TYPE_PCI;\n\n\tretval = moxa_init_board(board, &pdev->dev);\n\tif (retval)\n\t\tgoto err_base;\n\n\tpci_set_drvdata(pdev, board);\n\n\tdev_info(&pdev->dev, \"board '%s' ready (%u ports, firmware loaded)\\n\",\n\t\t\tmoxa_brdname[board_type - 1], board->numPorts);\n\n\treturn 0;\nerr_base:\n\tiounmap(board->basemem);\n\tboard->basemem = NULL;\nerr_reg:\n\tpci_release_region(pdev, 2);\nerr:\n\treturn retval;\n}\n\nstatic void moxa_pci_remove(struct pci_dev *pdev)\n{\n\tstruct moxa_board_conf *brd = pci_get_drvdata(pdev);\n\n\tmoxa_board_deinit(brd);\n\n\tpci_release_region(pdev, 2);\n}\n\nstatic struct pci_driver moxa_pci_driver = {\n\t.name = \"moxa\",\n\t.id_table = moxa_pcibrds,\n\t.probe = moxa_pci_probe,\n\t.remove = moxa_pci_remove\n};\n#endif  \n\nstatic int __init moxa_init(void)\n{\n\tunsigned int isabrds = 0;\n\tint retval = 0;\n\tstruct moxa_board_conf *brd = moxa_boards;\n\tunsigned int i;\n\n\tprintk(KERN_INFO \"MOXA Intellio family driver version %s\\n\",\n\t\t\tMOXA_VERSION);\n\n\ttty_port_init(&moxa_service_port);\n\n\tmoxaDriver = tty_alloc_driver(MAX_PORTS + 1,\n\t\t\tTTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(moxaDriver))\n\t\treturn PTR_ERR(moxaDriver);\n\n\tmoxaDriver->name = \"ttyMX\";\n\tmoxaDriver->major = ttymajor;\n\tmoxaDriver->minor_start = 0;\n\tmoxaDriver->type = TTY_DRIVER_TYPE_SERIAL;\n\tmoxaDriver->subtype = SERIAL_TYPE_NORMAL;\n\tmoxaDriver->init_termios = tty_std_termios;\n\tmoxaDriver->init_termios.c_cflag = B9600 | CS8 | CREAD | CLOCAL | HUPCL;\n\tmoxaDriver->init_termios.c_ispeed = 9600;\n\tmoxaDriver->init_termios.c_ospeed = 9600;\n\ttty_set_operations(moxaDriver, &moxa_ops);\n\t \n\ttty_port_link_device(&moxa_service_port, moxaDriver, MAX_PORTS);\n\n\tif (tty_register_driver(moxaDriver)) {\n\t\tprintk(KERN_ERR \"can't register MOXA Smartio tty driver!\\n\");\n\t\ttty_driver_kref_put(moxaDriver);\n\t\treturn -1;\n\t}\n\n\t \n\n\tfor (i = 0; i < MAX_BOARDS; i++) {\n\t\tif (!baseaddr[i])\n\t\t\tbreak;\n\t\tif (type[i] == MOXA_BOARD_C218_ISA ||\n\t\t\t\ttype[i] == MOXA_BOARD_C320_ISA) {\n\t\t\tpr_debug(\"Moxa board %2d: %s board(baseAddr=%lx)\\n\",\n\t\t\t\t\tisabrds + 1, moxa_brdname[type[i] - 1],\n\t\t\t\t\tbaseaddr[i]);\n\t\t\tbrd->boardType = type[i];\n\t\t\tbrd->numPorts = type[i] == MOXA_BOARD_C218_ISA ? 8 :\n\t\t\t\t\tnumports[i];\n\t\t\tbrd->busType = MOXA_BUS_TYPE_ISA;\n\t\t\tbrd->basemem = ioremap(baseaddr[i], 0x4000);\n\t\t\tif (!brd->basemem) {\n\t\t\t\tprintk(KERN_ERR \"MOXA: can't remap %lx\\n\",\n\t\t\t\t\t\tbaseaddr[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (moxa_init_board(brd, NULL)) {\n\t\t\t\tiounmap(brd->basemem);\n\t\t\t\tbrd->basemem = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintk(KERN_INFO \"MOXA isa board found at 0x%.8lx and \"\n\t\t\t\t\t\"ready (%u ports, firmware loaded)\\n\",\n\t\t\t\t\tbaseaddr[i], brd->numPorts);\n\n\t\t\tbrd++;\n\t\t\tisabrds++;\n\t\t}\n\t}\n\n#ifdef CONFIG_PCI\n\tretval = pci_register_driver(&moxa_pci_driver);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"Can't register MOXA pci driver!\\n\");\n\t\tif (isabrds)\n\t\t\tretval = 0;\n\t}\n#endif\n\n\treturn retval;\n}\n\nstatic void __exit moxa_exit(void)\n{\n\tunsigned int i;\n\n#ifdef CONFIG_PCI\n\tpci_unregister_driver(&moxa_pci_driver);\n#endif\n\n\tfor (i = 0; i < MAX_BOARDS; i++)  \n\t\tif (moxa_boards[i].ready)\n\t\t\tmoxa_board_deinit(&moxa_boards[i]);\n\n\tdel_timer_sync(&moxaTimer);\n\n\ttty_unregister_driver(moxaDriver);\n\ttty_driver_kref_put(moxaDriver);\n}\n\nmodule_init(moxa_init);\nmodule_exit(moxa_exit);\n\nstatic void moxa_shutdown(struct tty_port *port)\n{\n\tstruct moxa_port *ch = container_of(port, struct moxa_port, port);\n        MoxaPortDisable(ch);\n\tMoxaPortFlushData(ch, 2);\n}\n\nstatic bool moxa_carrier_raised(struct tty_port *port)\n{\n\tstruct moxa_port *ch = container_of(port, struct moxa_port, port);\n\tint dcd;\n\n\tspin_lock_irq(&port->lock);\n\tdcd = ch->DCDState;\n\tspin_unlock_irq(&port->lock);\n\treturn dcd;\n}\n\nstatic void moxa_dtr_rts(struct tty_port *port, bool active)\n{\n\tstruct moxa_port *ch = container_of(port, struct moxa_port, port);\n\tMoxaPortLineCtrl(ch, active, active);\n}\n\n\nstatic int moxa_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct moxa_board_conf *brd;\n\tstruct moxa_port *ch;\n\tint port;\n\n\tport = tty->index;\n\tif (port == MAX_PORTS) {\n\t\treturn capable(CAP_SYS_ADMIN) ? 0 : -EPERM;\n\t}\n\tif (mutex_lock_interruptible(&moxa_openlock))\n\t\treturn -ERESTARTSYS;\n\tbrd = &moxa_boards[port / MAX_PORTS_PER_BOARD];\n\tif (!brd->ready) {\n\t\tmutex_unlock(&moxa_openlock);\n\t\treturn -ENODEV;\n\t}\n\n\tif (port % MAX_PORTS_PER_BOARD >= brd->numPorts) {\n\t\tmutex_unlock(&moxa_openlock);\n\t\treturn -ENODEV;\n\t}\n\n\tch = &brd->ports[port % MAX_PORTS_PER_BOARD];\n\tch->port.count++;\n\ttty->driver_data = ch;\n\ttty_port_tty_set(&ch->port, tty);\n\tmutex_lock(&ch->port.mutex);\n\tif (!tty_port_initialized(&ch->port)) {\n\t\tch->statusflags = 0;\n\t\tmoxa_set_tty_param(tty, &tty->termios);\n\t\tMoxaPortLineCtrl(ch, true, true);\n\t\tMoxaPortEnable(ch);\n\t\tMoxaSetFifo(ch, ch->type == PORT_16550A);\n\t\ttty_port_set_initialized(&ch->port, true);\n\t}\n\tmutex_unlock(&ch->port.mutex);\n\tmutex_unlock(&moxa_openlock);\n\n\treturn tty_port_block_til_ready(&ch->port, tty, filp);\n}\n\nstatic void moxa_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct moxa_port *ch = tty->driver_data;\n\tch->cflag = tty->termios.c_cflag;\n\ttty_port_close(&ch->port, tty, filp);\n}\n\nstatic ssize_t moxa_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tstruct moxa_port *ch = tty->driver_data;\n\tunsigned long flags;\n\tint len;\n\n\tif (ch == NULL)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&moxa_lock, flags);\n\tlen = MoxaPortWriteData(tty, buf, count);\n\tspin_unlock_irqrestore(&moxa_lock, flags);\n\n\tset_bit(LOWWAIT, &ch->statusflags);\n\treturn len;\n}\n\nstatic unsigned int moxa_write_room(struct tty_struct *tty)\n{\n\tstruct moxa_port *ch;\n\n\tif (tty->flow.stopped)\n\t\treturn 0;\n\tch = tty->driver_data;\n\tif (ch == NULL)\n\t\treturn 0;\n\treturn MoxaPortTxFree(ch);\n}\n\nstatic void moxa_flush_buffer(struct tty_struct *tty)\n{\n\tstruct moxa_port *ch = tty->driver_data;\n\n\tif (ch == NULL)\n\t\treturn;\n\tMoxaPortFlushData(ch, 1);\n\ttty_wakeup(tty);\n}\n\nstatic unsigned int moxa_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct moxa_port *ch = tty->driver_data;\n\tunsigned int chars;\n\n\tchars = MoxaPortTxQueue(ch);\n\tif (chars)\n\t\t \n        \tset_bit(EMPTYWAIT, &ch->statusflags);\n\treturn chars;\n}\n\nstatic int moxa_tiocmget(struct tty_struct *tty)\n{\n\tstruct moxa_port *ch = tty->driver_data;\n\tbool dtr_active, rts_active;\n\tint flag = 0;\n\tint status;\n\n\tMoxaPortGetLineOut(ch, &dtr_active, &rts_active);\n\tif (dtr_active)\n\t\tflag |= TIOCM_DTR;\n\tif (rts_active)\n\t\tflag |= TIOCM_RTS;\n\tstatus = MoxaPortLineStatus(ch);\n\tif (status & 1)\n\t\tflag |= TIOCM_CTS;\n\tif (status & 2)\n\t\tflag |= TIOCM_DSR;\n\tif (status & 4)\n\t\tflag |= TIOCM_CD;\n\treturn flag;\n}\n\nstatic int moxa_tiocmset(struct tty_struct *tty,\n\t\t\t unsigned int set, unsigned int clear)\n{\n\tbool dtr_active, rts_active;\n\tstruct moxa_port *ch;\n\n\tmutex_lock(&moxa_openlock);\n\tch = tty->driver_data;\n\tif (!ch) {\n\t\tmutex_unlock(&moxa_openlock);\n\t\treturn -EINVAL;\n\t}\n\n\tMoxaPortGetLineOut(ch, &dtr_active, &rts_active);\n\tif (set & TIOCM_RTS)\n\t\trts_active = true;\n\tif (set & TIOCM_DTR)\n\t\tdtr_active = true;\n\tif (clear & TIOCM_RTS)\n\t\trts_active = false;\n\tif (clear & TIOCM_DTR)\n\t\tdtr_active = false;\n\tMoxaPortLineCtrl(ch, dtr_active, rts_active);\n\tmutex_unlock(&moxa_openlock);\n\treturn 0;\n}\n\nstatic void moxa_set_termios(struct tty_struct *tty,\n\t\t             const struct ktermios *old_termios)\n{\n\tstruct moxa_port *ch = tty->driver_data;\n\n\tif (ch == NULL)\n\t\treturn;\n\tmoxa_set_tty_param(tty, old_termios);\n\tif (!(old_termios->c_cflag & CLOCAL) && C_CLOCAL(tty))\n\t\twake_up_interruptible(&ch->port.open_wait);\n}\n\nstatic void moxa_stop(struct tty_struct *tty)\n{\n\tstruct moxa_port *ch = tty->driver_data;\n\n\tif (ch == NULL)\n\t\treturn;\n\tMoxaPortTxDisable(ch);\n\tset_bit(TXSTOPPED, &ch->statusflags);\n}\n\n\nstatic void moxa_start(struct tty_struct *tty)\n{\n\tstruct moxa_port *ch = tty->driver_data;\n\n\tif (ch == NULL)\n\t\treturn;\n\n\tif (!test_bit(TXSTOPPED, &ch->statusflags))\n\t\treturn;\n\n\tMoxaPortTxEnable(ch);\n\tclear_bit(TXSTOPPED, &ch->statusflags);\n}\n\nstatic void moxa_hangup(struct tty_struct *tty)\n{\n\tstruct moxa_port *ch = tty->driver_data;\n\ttty_port_hangup(&ch->port);\n}\n\nstatic void moxa_new_dcdstate(struct moxa_port *p, u8 dcd)\n{\n\tunsigned long flags;\n\tdcd = !!dcd;\n\n\tspin_lock_irqsave(&p->port.lock, flags);\n\tif (dcd != p->DCDState) {\n        \tp->DCDState = dcd;\n        \tspin_unlock_irqrestore(&p->port.lock, flags);\n\t\tif (!dcd)\n\t\t\ttty_port_tty_hangup(&p->port, true);\n\t}\n\telse\n\t\tspin_unlock_irqrestore(&p->port.lock, flags);\n}\n\nstatic int moxa_poll_port(struct moxa_port *p, unsigned int handle,\n\t\tu16 __iomem *ip)\n{\n\tstruct tty_struct *tty = tty_port_tty_get(&p->port);\n\tbool inited = tty_port_initialized(&p->port);\n\tvoid __iomem *ofsAddr;\n\tu16 intr;\n\n\tif (tty) {\n\t\tif (test_bit(EMPTYWAIT, &p->statusflags) &&\n\t\t\t\tMoxaPortTxQueue(p) == 0) {\n\t\t\tclear_bit(EMPTYWAIT, &p->statusflags);\n\t\t\ttty_wakeup(tty);\n\t\t}\n\t\tif (test_bit(LOWWAIT, &p->statusflags) && !tty->flow.stopped &&\n\t\t\t\tMoxaPortTxQueue(p) <= WAKEUP_CHARS) {\n\t\t\tclear_bit(LOWWAIT, &p->statusflags);\n\t\t\ttty_wakeup(tty);\n\t\t}\n\n\t\tif (inited && !tty_throttled(tty) &&\n\t\t\t\tMoxaPortRxQueue(p) > 0) {  \n\t\t\tMoxaPortReadData(p);\n\t\t\ttty_flip_buffer_push(&p->port);\n\t\t}\n\t} else {\n\t\tclear_bit(EMPTYWAIT, &p->statusflags);\n\t\tMoxaPortFlushData(p, 0);  \n\t}\n\n\tif (!handle)  \n\t\tgoto put;\n\n\tintr = readw(ip);  \n\tif (intr == 0)\n\t\tgoto put;\n\n\twritew(0, ip);  \n\tofsAddr = p->tableAddr;\n\tif (intr & IntrTx)  \n\t\twritew(readw(ofsAddr + HostStat) & ~WakeupTx,\n\t\t\t\tofsAddr + HostStat);\n\n\tif (!inited)\n\t\tgoto put;\n\n\tif (tty && (intr & IntrBreak) && !I_IGNBRK(tty)) {  \n\t\ttty_insert_flip_char(&p->port, 0, TTY_BREAK);\n\t\ttty_flip_buffer_push(&p->port);\n\t}\n\n\tif (intr & IntrLine)\n\t\tmoxa_new_dcdstate(p, readb(ofsAddr + FlagStat) & DCD_state);\nput:\n\ttty_kref_put(tty);\n\n\treturn 0;\n}\n\nstatic void moxa_poll(struct timer_list *unused)\n{\n\tstruct moxa_board_conf *brd;\n\tu16 __iomem *ip;\n\tunsigned int card, port, served = 0;\n\n\tspin_lock(&moxa_lock);\n\tfor (card = 0; card < MAX_BOARDS; card++) {\n\t\tbrd = &moxa_boards[card];\n\t\tif (!brd->ready)\n\t\t\tcontinue;\n\n\t\tserved++;\n\n\t\tip = NULL;\n\t\tif (readb(brd->intPend) == 0xff)\n\t\t\tip = brd->intTable + readb(brd->intNdx);\n\n\t\tfor (port = 0; port < brd->numPorts; port++)\n\t\t\tmoxa_poll_port(&brd->ports[port], !!ip, ip + port);\n\n\t\tif (ip)\n\t\t\twriteb(0, brd->intPend);  \n\n\t\tif (moxaLowWaterChk) {\n\t\t\tstruct moxa_port *p = brd->ports;\n\t\t\tfor (port = 0; port < brd->numPorts; port++, p++)\n\t\t\t\tif (p->lowChkFlag) {\n\t\t\t\t\tp->lowChkFlag = 0;\n\t\t\t\t\tmoxa_low_water_check(p->tableAddr);\n\t\t\t\t}\n\t\t}\n\t}\n\tmoxaLowWaterChk = 0;\n\n\tif (served)\n\t\tmod_timer(&moxaTimer, jiffies + HZ / 50);\n\tspin_unlock(&moxa_lock);\n}\n\n \n\nstatic void moxa_set_tty_param(struct tty_struct *tty,\n\t\t\t       const struct ktermios *old_termios)\n{\n\tregister struct ktermios *ts = &tty->termios;\n\tstruct moxa_port *ch = tty->driver_data;\n\tint rts, cts, txflow, rxflow, xany, baud;\n\n\trts = cts = txflow = rxflow = xany = 0;\n\tif (ts->c_cflag & CRTSCTS)\n\t\trts = cts = 1;\n\tif (ts->c_iflag & IXON)\n\t\ttxflow = 1;\n\tif (ts->c_iflag & IXOFF)\n\t\trxflow = 1;\n\tif (ts->c_iflag & IXANY)\n\t\txany = 1;\n\n\tMoxaPortFlowCtrl(ch, rts, cts, txflow, rxflow, xany);\n\tbaud = MoxaPortSetTermio(ch, ts, tty_get_baud_rate(tty));\n\tif (baud == -1)\n\t\tbaud = tty_termios_baud_rate(old_termios);\n\t \n\ttty_encode_baud_rate(tty, baud, baud);\n}\n\n \n\nstatic void MoxaPortFlushData(struct moxa_port *port, int mode)\n{\n\tvoid __iomem *ofsAddr;\n\tif (mode < 0 || mode > 2)\n\t\treturn;\n\tofsAddr = port->tableAddr;\n\tmoxafunc(ofsAddr, FC_FlushQueue, mode);\n\tif (mode != 1) {\n\t\tport->lowChkFlag = 0;\n\t\tmoxa_low_water_check(ofsAddr);\n\t}\n}\n\n \n\nstatic void MoxaPortEnable(struct moxa_port *port)\n{\n\tvoid __iomem *ofsAddr;\n\tu16 lowwater = 512;\n\n\tofsAddr = port->tableAddr;\n\twritew(lowwater, ofsAddr + Low_water);\n\tif (MOXA_IS_320(port->board))\n\t\tmoxafunc(ofsAddr, FC_SetBreakIrq, 0);\n\telse\n\t\twritew(readw(ofsAddr + HostStat) | WakeupBreak,\n\t\t\t\tofsAddr + HostStat);\n\n\tmoxafunc(ofsAddr, FC_SetLineIrq, Magic_code);\n\tmoxafunc(ofsAddr, FC_FlushQueue, 2);\n\n\tmoxafunc(ofsAddr, FC_EnableCH, Magic_code);\n\tMoxaPortLineStatus(port);\n}\n\nstatic void MoxaPortDisable(struct moxa_port *port)\n{\n\tvoid __iomem *ofsAddr = port->tableAddr;\n\n\tmoxafunc(ofsAddr, FC_SetFlowCtl, 0);\t \n\tmoxafunc(ofsAddr, FC_ClrLineIrq, Magic_code);\n\twritew(0, ofsAddr + HostStat);\n\tmoxafunc(ofsAddr, FC_DisableCH, Magic_code);\n}\n\nstatic speed_t MoxaPortSetBaud(struct moxa_port *port, speed_t baud)\n{\n\tvoid __iomem *ofsAddr = port->tableAddr;\n\tunsigned int clock, val;\n\tspeed_t max;\n\n\tmax = MOXA_IS_320(port->board) ? 460800 : 921600;\n\tif (baud < 50)\n\t\treturn 0;\n\tif (baud > max)\n\t\tbaud = max;\n\tclock = 921600;\n\tval = clock / baud;\n\tmoxafunc(ofsAddr, FC_SetBaud, val);\n\tbaud = clock / val;\n\treturn baud;\n}\n\nstatic int MoxaPortSetTermio(struct moxa_port *port, struct ktermios *termio,\n\t\tspeed_t baud)\n{\n\tvoid __iomem *ofsAddr;\n\ttcflag_t mode = 0;\n\n\tofsAddr = port->tableAddr;\n\n\tmode = termio->c_cflag & CSIZE;\n\tif (mode == CS5)\n\t\tmode = MX_CS5;\n\telse if (mode == CS6)\n\t\tmode = MX_CS6;\n\telse if (mode == CS7)\n\t\tmode = MX_CS7;\n\telse if (mode == CS8)\n\t\tmode = MX_CS8;\n\n\tif (termio->c_cflag & CSTOPB) {\n\t\tif (mode == MX_CS5)\n\t\t\tmode |= MX_STOP15;\n\t\telse\n\t\t\tmode |= MX_STOP2;\n\t} else\n\t\tmode |= MX_STOP1;\n\n\tif (termio->c_cflag & PARENB) {\n\t\tif (termio->c_cflag & PARODD) {\n\t\t\tif (termio->c_cflag & CMSPAR)\n\t\t\t\tmode |= MX_PARMARK;\n\t\t\telse\n\t\t\t\tmode |= MX_PARODD;\n\t\t} else {\n\t\t\tif (termio->c_cflag & CMSPAR)\n\t\t\t\tmode |= MX_PARSPACE;\n\t\t\telse\n\t\t\t\tmode |= MX_PAREVEN;\n\t\t}\n\t} else\n\t\tmode |= MX_PARNONE;\n\n\tmoxafunc(ofsAddr, FC_SetDataMode, (u16)mode);\n\n\tif (MOXA_IS_320(port->board) && baud >= 921600)\n\t\treturn -1;\n\n\tbaud = MoxaPortSetBaud(port, baud);\n\n\tif (termio->c_iflag & (IXON | IXOFF | IXANY)) {\n\t        spin_lock_irq(&moxafunc_lock);\n\t\twriteb(termio->c_cc[VSTART], ofsAddr + FuncArg);\n\t\twriteb(termio->c_cc[VSTOP], ofsAddr + FuncArg1);\n\t\twriteb(FC_SetXonXoff, ofsAddr + FuncCode);\n\t\tmoxa_wait_finish(ofsAddr);\n\t\tspin_unlock_irq(&moxafunc_lock);\n\n\t}\n\treturn baud;\n}\n\nstatic int MoxaPortGetLineOut(struct moxa_port *port, bool *dtr_active,\n\t\tbool *rts_active)\n{\n\tif (dtr_active)\n\t\t*dtr_active = port->lineCtrl & DTR_ON;\n\tif (rts_active)\n\t\t*rts_active = port->lineCtrl & RTS_ON;\n\n\treturn 0;\n}\n\nstatic void MoxaPortLineCtrl(struct moxa_port *port, bool dtr_active, bool rts_active)\n{\n\tu8 mode = 0;\n\n\tif (dtr_active)\n\t\tmode |= DTR_ON;\n\tif (rts_active)\n\t\tmode |= RTS_ON;\n\tport->lineCtrl = mode;\n\tmoxafunc(port->tableAddr, FC_LineControl, mode);\n}\n\nstatic void MoxaPortFlowCtrl(struct moxa_port *port, int rts, int cts,\n\t\tint txflow, int rxflow, int txany)\n{\n\tint mode = 0;\n\n\tif (rts)\n\t\tmode |= RTS_FlowCtl;\n\tif (cts)\n\t\tmode |= CTS_FlowCtl;\n\tif (txflow)\n\t\tmode |= Tx_FlowCtl;\n\tif (rxflow)\n\t\tmode |= Rx_FlowCtl;\n\tif (txany)\n\t\tmode |= IXM_IXANY;\n\tmoxafunc(port->tableAddr, FC_SetFlowCtl, mode);\n}\n\nstatic int MoxaPortLineStatus(struct moxa_port *port)\n{\n\tvoid __iomem *ofsAddr;\n\tint val;\n\n\tofsAddr = port->tableAddr;\n\tif (MOXA_IS_320(port->board))\n\t\tval = moxafuncret(ofsAddr, FC_LineStatus, 0);\n\telse\n\t\tval = readw(ofsAddr + FlagStat) >> 4;\n\tval &= 0x0B;\n\tif (val & 8)\n\t\tval |= 4;\n\tmoxa_new_dcdstate(port, val & 8);\n\tval &= 7;\n\treturn val;\n}\n\nstatic int MoxaPortWriteData(struct tty_struct *tty, const u8 *buffer, int len)\n{\n\tstruct moxa_port *port = tty->driver_data;\n\tvoid __iomem *baseAddr, *ofsAddr, *ofs;\n\tunsigned int c, total;\n\tu16 head, tail, tx_mask, spage, epage;\n\tu16 pageno, pageofs, bufhead;\n\n\tofsAddr = port->tableAddr;\n\tbaseAddr = port->board->basemem;\n\ttx_mask = readw(ofsAddr + TX_mask);\n\tspage = readw(ofsAddr + Page_txb);\n\tepage = readw(ofsAddr + EndPage_txb);\n\ttail = readw(ofsAddr + TXwptr);\n\thead = readw(ofsAddr + TXrptr);\n\tc = (head > tail) ? (head - tail - 1) : (head - tail + tx_mask);\n\tif (c > len)\n\t\tc = len;\n\tmoxaLog.txcnt[port->port.tty->index] += c;\n\ttotal = c;\n\tif (spage == epage) {\n\t\tbufhead = readw(ofsAddr + Ofs_txb);\n\t\twritew(spage, baseAddr + Control_reg);\n\t\twhile (c > 0) {\n\t\t\tif (head > tail)\n\t\t\t\tlen = head - tail - 1;\n\t\t\telse\n\t\t\t\tlen = tx_mask + 1 - tail;\n\t\t\tlen = (c > len) ? len : c;\n\t\t\tofs = baseAddr + DynPage_addr + bufhead + tail;\n\t\t\tmemcpy_toio(ofs, buffer, len);\n\t\t\tbuffer += len;\n\t\t\ttail = (tail + len) & tx_mask;\n\t\t\tc -= len;\n\t\t}\n\t} else {\n\t\tpageno = spage + (tail >> 13);\n\t\tpageofs = tail & Page_mask;\n\t\twhile (c > 0) {\n\t\t\tlen = Page_size - pageofs;\n\t\t\tif (len > c)\n\t\t\t\tlen = c;\n\t\t\twriteb(pageno, baseAddr + Control_reg);\n\t\t\tofs = baseAddr + DynPage_addr + pageofs;\n\t\t\tmemcpy_toio(ofs, buffer, len);\n\t\t\tbuffer += len;\n\t\t\tif (++pageno == epage)\n\t\t\t\tpageno = spage;\n\t\t\tpageofs = 0;\n\t\t\tc -= len;\n\t\t}\n\t\ttail = (tail + total) & tx_mask;\n\t}\n\twritew(tail, ofsAddr + TXwptr);\n\twriteb(1, ofsAddr + CD180TXirq);\t \n\treturn total;\n}\n\nstatic int MoxaPortReadData(struct moxa_port *port)\n{\n\tstruct tty_struct *tty = port->port.tty;\n\tunsigned char *dst;\n\tvoid __iomem *baseAddr, *ofsAddr, *ofs;\n\tunsigned int count, len, total;\n\tu16 tail, rx_mask, spage, epage;\n\tu16 pageno, pageofs, bufhead, head;\n\n\tofsAddr = port->tableAddr;\n\tbaseAddr = port->board->basemem;\n\thead = readw(ofsAddr + RXrptr);\n\ttail = readw(ofsAddr + RXwptr);\n\trx_mask = readw(ofsAddr + RX_mask);\n\tspage = readw(ofsAddr + Page_rxb);\n\tepage = readw(ofsAddr + EndPage_rxb);\n\tcount = (tail >= head) ? (tail - head) : (tail - head + rx_mask + 1);\n\tif (count == 0)\n\t\treturn 0;\n\n\ttotal = count;\n\tmoxaLog.rxcnt[tty->index] += total;\n\tif (spage == epage) {\n\t\tbufhead = readw(ofsAddr + Ofs_rxb);\n\t\twritew(spage, baseAddr + Control_reg);\n\t\twhile (count > 0) {\n\t\t\tofs = baseAddr + DynPage_addr + bufhead + head;\n\t\t\tlen = (tail >= head) ? (tail - head) :\n\t\t\t\t\t(rx_mask + 1 - head);\n\t\t\tlen = tty_prepare_flip_string(&port->port, &dst,\n\t\t\t\t\tmin(len, count));\n\t\t\tmemcpy_fromio(dst, ofs, len);\n\t\t\thead = (head + len) & rx_mask;\n\t\t\tcount -= len;\n\t\t}\n\t} else {\n\t\tpageno = spage + (head >> 13);\n\t\tpageofs = head & Page_mask;\n\t\twhile (count > 0) {\n\t\t\twritew(pageno, baseAddr + Control_reg);\n\t\t\tofs = baseAddr + DynPage_addr + pageofs;\n\t\t\tlen = tty_prepare_flip_string(&port->port, &dst,\n\t\t\t\t\tmin(Page_size - pageofs, count));\n\t\t\tmemcpy_fromio(dst, ofs, len);\n\n\t\t\tcount -= len;\n\t\t\tpageofs = (pageofs + len) & Page_mask;\n\t\t\tif (pageofs == 0 && ++pageno == epage)\n\t\t\t\tpageno = spage;\n\t\t}\n\t\thead = (head + total) & rx_mask;\n\t}\n\twritew(head, ofsAddr + RXrptr);\n\tif (readb(ofsAddr + FlagStat) & Xoff_state) {\n\t\tmoxaLowWaterChk = 1;\n\t\tport->lowChkFlag = 1;\n\t}\n\treturn total;\n}\n\n\nstatic unsigned int MoxaPortTxQueue(struct moxa_port *port)\n{\n\tvoid __iomem *ofsAddr = port->tableAddr;\n\tu16 rptr, wptr, mask;\n\n\trptr = readw(ofsAddr + TXrptr);\n\twptr = readw(ofsAddr + TXwptr);\n\tmask = readw(ofsAddr + TX_mask);\n\treturn (wptr - rptr) & mask;\n}\n\nstatic unsigned int MoxaPortTxFree(struct moxa_port *port)\n{\n\tvoid __iomem *ofsAddr = port->tableAddr;\n\tu16 rptr, wptr, mask;\n\n\trptr = readw(ofsAddr + TXrptr);\n\twptr = readw(ofsAddr + TXwptr);\n\tmask = readw(ofsAddr + TX_mask);\n\treturn mask - ((wptr - rptr) & mask);\n}\n\nstatic int MoxaPortRxQueue(struct moxa_port *port)\n{\n\tvoid __iomem *ofsAddr = port->tableAddr;\n\tu16 rptr, wptr, mask;\n\n\trptr = readw(ofsAddr + RXrptr);\n\twptr = readw(ofsAddr + RXwptr);\n\tmask = readw(ofsAddr + RX_mask);\n\treturn (wptr - rptr) & mask;\n}\n\nstatic void MoxaPortTxDisable(struct moxa_port *port)\n{\n\tmoxafunc(port->tableAddr, FC_SetXoffState, Magic_code);\n}\n\nstatic void MoxaPortTxEnable(struct moxa_port *port)\n{\n\tmoxafunc(port->tableAddr, FC_SetXonState, Magic_code);\n}\n\nstatic int moxa_get_serial_info(struct tty_struct *tty,\n\t\tstruct serial_struct *ss)\n{\n\tstruct moxa_port *info = tty->driver_data;\n\n\tif (tty->index == MAX_PORTS)\n\t\treturn -EINVAL;\n\tif (!info)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->port.mutex);\n\tss->type = info->type;\n\tss->line = info->port.tty->index;\n\tss->flags = info->port.flags;\n\tss->baud_base = 921600;\n\tss->close_delay = jiffies_to_msecs(info->port.close_delay) / 10;\n\tmutex_unlock(&info->port.mutex);\n\treturn 0;\n}\n\n\nstatic int moxa_set_serial_info(struct tty_struct *tty,\n\t\tstruct serial_struct *ss)\n{\n\tstruct moxa_port *info = tty->driver_data;\n\tunsigned int close_delay;\n\n\tif (tty->index == MAX_PORTS)\n\t\treturn -EINVAL;\n\tif (!info)\n\t\treturn -ENODEV;\n\n\tclose_delay = msecs_to_jiffies(ss->close_delay * 10);\n\n\tmutex_lock(&info->port.mutex);\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tif (close_delay != info->port.close_delay ||\n\t\t    ss->type != info->type ||\n\t\t    ((ss->flags & ~ASYNC_USR_MASK) !=\n\t\t     (info->port.flags & ~ASYNC_USR_MASK))) {\n\t\t\tmutex_unlock(&info->port.mutex);\n\t\t\treturn -EPERM;\n\t\t}\n\t} else {\n\t\tinfo->port.close_delay = close_delay;\n\n\t\tMoxaSetFifo(info, ss->type == PORT_16550A);\n\n\t\tinfo->type = ss->type;\n\t}\n\tmutex_unlock(&info->port.mutex);\n\treturn 0;\n}\n\n\n\n \n\nstatic void MoxaSetFifo(struct moxa_port *port, int enable)\n{\n\tvoid __iomem *ofsAddr = port->tableAddr;\n\n\tif (!enable) {\n\t\tmoxafunc(ofsAddr, FC_SetRxFIFOTrig, 0);\n\t\tmoxafunc(ofsAddr, FC_SetTxFIFOCnt, 1);\n\t} else {\n\t\tmoxafunc(ofsAddr, FC_SetRxFIFOTrig, 3);\n\t\tmoxafunc(ofsAddr, FC_SetTxFIFOCnt, 16);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}