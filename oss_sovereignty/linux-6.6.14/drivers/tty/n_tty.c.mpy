{
  "module_name": "n_tty.c",
  "hash_id": "cb9e332d2008687b4b910f7228308572cbfd5afe3c546c8d25776b8cba1ca3f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/n_tty.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/ctype.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n#include <linux/math.h>\n#include <linux/poll.h>\n#include <linux/ratelimit.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/tty.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n\n#include \"tty.h\"\n\n \n#define WAKEUP_CHARS 256\n\n \n#define TTY_THRESHOLD_THROTTLE\t\t128  \n#define TTY_THRESHOLD_UNTHROTTLE\t128\n\n \n#define ECHO_OP_START 0xff\n#define ECHO_OP_MOVE_BACK_COL 0x80\n#define ECHO_OP_SET_CANON_COL 0x81\n#define ECHO_OP_ERASE_TAB 0x82\n\n#define ECHO_COMMIT_WATERMARK\t256\n#define ECHO_BLOCK\t\t256\n#define ECHO_DISCARD_WATERMARK\tN_TTY_BUF_SIZE - (ECHO_BLOCK + 32)\n\n\n#undef N_TTY_TRACE\n#ifdef N_TTY_TRACE\n# define n_tty_trace(f, args...)\ttrace_printk(f, ##args)\n#else\n# define n_tty_trace(f, args...)\tno_printk(f, ##args)\n#endif\n\nstruct n_tty_data {\n\t \n\tsize_t read_head;\n\tsize_t commit_head;\n\tsize_t canon_head;\n\tsize_t echo_head;\n\tsize_t echo_commit;\n\tsize_t echo_mark;\n\tDECLARE_BITMAP(char_map, 256);\n\n\t \n\tunsigned long overrun_time;\n\tunsigned int num_overrun;\n\n\t \n\tbool no_room;\n\n\t \n\tunsigned char lnext:1, erasing:1, raw:1, real_raw:1, icanon:1;\n\tunsigned char push:1;\n\n\t \n\tu8 read_buf[N_TTY_BUF_SIZE];\n\tDECLARE_BITMAP(read_flags, N_TTY_BUF_SIZE);\n\tu8 echo_buf[N_TTY_BUF_SIZE];\n\n\t \n\tsize_t read_tail;\n\tsize_t line_start;\n\n\t \n\tsize_t lookahead_count;\n\n\t \n\tunsigned int column;\n\tunsigned int canon_column;\n\tsize_t echo_tail;\n\n\tstruct mutex atomic_read_lock;\n\tstruct mutex output_lock;\n};\n\n#define MASK(x) ((x) & (N_TTY_BUF_SIZE - 1))\n\nstatic inline size_t read_cnt(struct n_tty_data *ldata)\n{\n\treturn ldata->read_head - ldata->read_tail;\n}\n\nstatic inline u8 read_buf(struct n_tty_data *ldata, size_t i)\n{\n\treturn ldata->read_buf[MASK(i)];\n}\n\nstatic inline u8 *read_buf_addr(struct n_tty_data *ldata, size_t i)\n{\n\treturn &ldata->read_buf[MASK(i)];\n}\n\nstatic inline u8 echo_buf(struct n_tty_data *ldata, size_t i)\n{\n\tsmp_rmb();  \n\treturn ldata->echo_buf[MASK(i)];\n}\n\nstatic inline u8 *echo_buf_addr(struct n_tty_data *ldata, size_t i)\n{\n\treturn &ldata->echo_buf[MASK(i)];\n}\n\n \nstatic void zero_buffer(const struct tty_struct *tty, u8 *buffer, size_t size)\n{\n\tif (L_ICANON(tty) && !L_ECHO(tty))\n\t\tmemset(buffer, 0, size);\n}\n\nstatic void tty_copy(const struct tty_struct *tty, void *to, size_t tail,\n\t\t     size_t n)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t size = N_TTY_BUF_SIZE - tail;\n\tvoid *from = read_buf_addr(ldata, tail);\n\n\tif (n > size) {\n\t\ttty_audit_add_data(tty, from, size);\n\t\tmemcpy(to, from, size);\n\t\tzero_buffer(tty, from, size);\n\t\tto += size;\n\t\tn -= size;\n\t\tfrom = ldata->read_buf;\n\t}\n\n\ttty_audit_add_data(tty, from, n);\n\tmemcpy(to, from, n);\n\tzero_buffer(tty, from, n);\n}\n\n \nstatic void n_tty_kick_worker(const struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t \n\tif (unlikely(READ_ONCE(ldata->no_room))) {\n\t\tWRITE_ONCE(ldata->no_room, 0);\n\n\t\tWARN_RATELIMIT(tty->port->itty == NULL,\n\t\t\t\t\"scheduling with invalid itty\\n\");\n\t\t \n\t\tWARN_RATELIMIT(test_bit(TTY_LDISC_HALTED, &tty->flags),\n\t\t\t       \"scheduling buffer work for halted ldisc\\n\");\n\t\ttty_buffer_restart_work(tty->port);\n\t}\n}\n\nstatic ssize_t chars_in_buffer(const struct tty_struct *tty)\n{\n\tconst struct n_tty_data *ldata = tty->disc_data;\n\tsize_t head = ldata->icanon ? ldata->canon_head : ldata->commit_head;\n\n\treturn head - ldata->read_tail;\n}\n\n \nstatic void n_tty_write_wakeup(struct tty_struct *tty)\n{\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tkill_fasync(&tty->fasync, SIGIO, POLL_OUT);\n}\n\nstatic void n_tty_check_throttle(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t \n\tif (ldata->icanon && ldata->canon_head == ldata->read_tail)\n\t\treturn;\n\n\twhile (1) {\n\t\tint throttled;\n\t\ttty_set_flow_change(tty, TTY_THROTTLE_SAFE);\n\t\tif (N_TTY_BUF_SIZE - read_cnt(ldata) >= TTY_THRESHOLD_THROTTLE)\n\t\t\tbreak;\n\t\tthrottled = tty_throttle_safe(tty);\n\t\tif (!throttled)\n\t\t\tbreak;\n\t}\n\t__tty_set_flow_change(tty, 0);\n}\n\nstatic void n_tty_check_unthrottle(struct tty_struct *tty)\n{\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY) {\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\treturn;\n\t\tn_tty_kick_worker(tty);\n\t\ttty_wakeup(tty->link);\n\t\treturn;\n\t}\n\n\t \n\n\twhile (1) {\n\t\tint unthrottled;\n\t\ttty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\tbreak;\n\t\tn_tty_kick_worker(tty);\n\t\tunthrottled = tty_unthrottle_safe(tty);\n\t\tif (!unthrottled)\n\t\t\tbreak;\n\t}\n\t__tty_set_flow_change(tty, 0);\n}\n\n \nstatic inline void put_tty_queue(u8 c, struct n_tty_data *ldata)\n{\n\t*read_buf_addr(ldata, ldata->read_head) = c;\n\tldata->read_head++;\n}\n\n \nstatic void reset_buffer_flags(struct n_tty_data *ldata)\n{\n\tldata->read_head = ldata->canon_head = ldata->read_tail = 0;\n\tldata->commit_head = 0;\n\tldata->line_start = 0;\n\n\tldata->erasing = 0;\n\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\tldata->push = 0;\n\n\tldata->lookahead_count = 0;\n}\n\nstatic void n_tty_packet_mode_flush(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tif (tty->link->ctrl.packet) {\n\t\tspin_lock_irqsave(&tty->ctrl.lock, flags);\n\t\ttty->ctrl.pktstatus |= TIOCPKT_FLUSHREAD;\n\t\tspin_unlock_irqrestore(&tty->ctrl.lock, flags);\n\t\twake_up_interruptible(&tty->link->read_wait);\n\t}\n}\n\n \nstatic void n_tty_flush_buffer(struct tty_struct *tty)\n{\n\tdown_write(&tty->termios_rwsem);\n\treset_buffer_flags(tty->disc_data);\n\tn_tty_kick_worker(tty);\n\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\tup_write(&tty->termios_rwsem);\n}\n\n \nstatic inline int is_utf8_continuation(u8 c)\n{\n\treturn (c & 0xc0) == 0x80;\n}\n\n \nstatic inline int is_continuation(u8 c, const struct tty_struct *tty)\n{\n\treturn I_IUTF8(tty) && is_utf8_continuation(c);\n}\n\n \nstatic int do_output_char(u8 c, struct tty_struct *tty, int space)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspaces;\n\n\tif (!space)\n\t\treturn -1;\n\n\tswitch (c) {\n\tcase '\\n':\n\t\tif (O_ONLRET(tty))\n\t\t\tldata->column = 0;\n\t\tif (O_ONLCR(tty)) {\n\t\t\tif (space < 2)\n\t\t\t\treturn -1;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\ttty->ops->write(tty, \"\\r\\n\", 2);\n\t\t\treturn 2;\n\t\t}\n\t\tldata->canon_column = ldata->column;\n\t\tbreak;\n\tcase '\\r':\n\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\treturn 0;\n\t\tif (O_OCRNL(tty)) {\n\t\t\tc = '\\n';\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\t}\n\t\tldata->canon_column = ldata->column = 0;\n\t\tbreak;\n\tcase '\\t':\n\t\tspaces = 8 - (ldata->column & 7);\n\t\tif (O_TABDLY(tty) == XTABS) {\n\t\t\tif (space < spaces)\n\t\t\t\treturn -1;\n\t\t\tldata->column += spaces;\n\t\t\ttty->ops->write(tty, \"        \", spaces);\n\t\t\treturn spaces;\n\t\t}\n\t\tldata->column += spaces;\n\t\tbreak;\n\tcase '\\b':\n\t\tif (ldata->column > 0)\n\t\t\tldata->column--;\n\t\tbreak;\n\tdefault:\n\t\tif (!iscntrl(c)) {\n\t\t\tif (O_OLCUC(tty))\n\t\t\t\tc = toupper(c);\n\t\t\tif (!is_continuation(c, tty))\n\t\t\t\tldata->column++;\n\t\t}\n\t\tbreak;\n\t}\n\n\ttty_put_char(tty, c);\n\treturn 1;\n}\n\n \nstatic int process_output(u8 c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace, retval;\n\n\tmutex_lock(&ldata->output_lock);\n\n\tspace = tty_write_room(tty);\n\tretval = do_output_char(c, tty, space);\n\n\tmutex_unlock(&ldata->output_lock);\n\tif (retval < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic ssize_t process_output_block(struct tty_struct *tty,\n\t\t\t\t    const u8 *buf, unsigned int nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace;\n\tint\ti;\n\tconst u8 *cp;\n\n\tmutex_lock(&ldata->output_lock);\n\n\tspace = tty_write_room(tty);\n\tif (space <= 0) {\n\t\tmutex_unlock(&ldata->output_lock);\n\t\treturn space;\n\t}\n\tif (nr > space)\n\t\tnr = space;\n\n\tfor (i = 0, cp = buf; i < nr; i++, cp++) {\n\t\tu8 c = *cp;\n\n\t\tswitch (c) {\n\t\tcase '\\n':\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->column = 0;\n\t\t\tif (O_ONLCR(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column;\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\t\tgoto break_out;\n\t\t\tif (O_OCRNL(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tgoto break_out;\n\t\tcase '\\b':\n\t\t\tif (ldata->column > 0)\n\t\t\t\tldata->column--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!iscntrl(c)) {\n\t\t\t\tif (O_OLCUC(tty))\n\t\t\t\t\tgoto break_out;\n\t\t\t\tif (!is_continuation(c, tty))\n\t\t\t\t\tldata->column++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nbreak_out:\n\ti = tty->ops->write(tty, buf, i);\n\n\tmutex_unlock(&ldata->output_lock);\n\treturn i;\n}\n\nstatic int n_tty_process_echo_ops(struct tty_struct *tty, size_t *tail,\n\t\t\t\t  int space)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tu8 op;\n\n\t \n\tif (MASK(ldata->echo_commit) == MASK(*tail + 1))\n\t\treturn -ENODATA;\n\n\t \n\top = echo_buf(ldata, *tail + 1);\n\n\tswitch (op) {\n\tcase ECHO_OP_ERASE_TAB: {\n\t\tunsigned int num_chars, num_bs;\n\n\t\tif (MASK(ldata->echo_commit) == MASK(*tail + 2))\n\t\t\treturn -ENODATA;\n\n\t\tnum_chars = echo_buf(ldata, *tail + 2);\n\n\t\t \n\t\tif (!(num_chars & 0x80))\n\t\t\tnum_chars += ldata->canon_column;\n\t\tnum_bs = 8 - (num_chars & 7);\n\n\t\tif (num_bs > space)\n\t\t\treturn -ENOSPC;\n\n\t\tspace -= num_bs;\n\t\twhile (num_bs--) {\n\t\t\ttty_put_char(tty, '\\b');\n\t\t\tif (ldata->column > 0)\n\t\t\t\tldata->column--;\n\t\t}\n\t\t*tail += 3;\n\t\tbreak;\n\t}\n\tcase ECHO_OP_SET_CANON_COL:\n\t\tldata->canon_column = ldata->column;\n\t\t*tail += 2;\n\t\tbreak;\n\n\tcase ECHO_OP_MOVE_BACK_COL:\n\t\tif (ldata->column > 0)\n\t\t\tldata->column--;\n\t\t*tail += 2;\n\t\tbreak;\n\n\tcase ECHO_OP_START:\n\t\t \n\t\tif (!space)\n\t\t\treturn -ENOSPC;\n\n\t\ttty_put_char(tty, ECHO_OP_START);\n\t\tldata->column++;\n\t\tspace--;\n\t\t*tail += 2;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tif (space < 2)\n\t\t\treturn -ENOSPC;\n\n\t\ttty_put_char(tty, '^');\n\t\ttty_put_char(tty, op ^ 0100);\n\t\tldata->column += 2;\n\t\tspace -= 2;\n\t\t*tail += 2;\n\t\tbreak;\n\t}\n\n\treturn space;\n}\n\n \nstatic size_t __process_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace, old_space;\n\tsize_t tail;\n\tu8 c;\n\n\told_space = space = tty_write_room(tty);\n\n\ttail = ldata->echo_tail;\n\twhile (MASK(ldata->echo_commit) != MASK(tail)) {\n\t\tc = echo_buf(ldata, tail);\n\t\tif (c == ECHO_OP_START) {\n\t\t\tint ret = n_tty_process_echo_ops(tty, &tail, space);\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tgoto not_yet_stored;\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tspace = ret;\n\t\t} else {\n\t\t\tif (O_OPOST(tty)) {\n\t\t\t\tint retval = do_output_char(c, tty, space);\n\t\t\t\tif (retval < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tspace -= retval;\n\t\t\t} else {\n\t\t\t\tif (!space)\n\t\t\t\t\tbreak;\n\t\t\t\ttty_put_char(tty, c);\n\t\t\t\tspace -= 1;\n\t\t\t}\n\t\t\ttail += 1;\n\t\t}\n\t}\n\n\t \n\twhile (ldata->echo_commit > tail &&\n\t       ldata->echo_commit - tail >= ECHO_DISCARD_WATERMARK) {\n\t\tif (echo_buf(ldata, tail) == ECHO_OP_START) {\n\t\t\tif (echo_buf(ldata, tail + 1) == ECHO_OP_ERASE_TAB)\n\t\t\t\ttail += 3;\n\t\t\telse\n\t\t\t\ttail += 2;\n\t\t} else\n\t\t\ttail++;\n\t}\n\n not_yet_stored:\n\tldata->echo_tail = tail;\n\treturn old_space - space;\n}\n\nstatic void commit_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t nr, old, echoed;\n\tsize_t head;\n\n\tmutex_lock(&ldata->output_lock);\n\thead = ldata->echo_head;\n\tldata->echo_mark = head;\n\told = ldata->echo_commit - ldata->echo_tail;\n\n\t \n\tnr = head - ldata->echo_tail;\n\tif (nr < ECHO_COMMIT_WATERMARK ||\n\t    (nr % ECHO_BLOCK > old % ECHO_BLOCK)) {\n\t\tmutex_unlock(&ldata->output_lock);\n\t\treturn;\n\t}\n\n\tldata->echo_commit = head;\n\techoed = __process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n\n\tif (echoed && tty->ops->flush_chars)\n\t\ttty->ops->flush_chars(tty);\n}\n\nstatic void process_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t echoed;\n\n\tif (ldata->echo_mark == ldata->echo_tail)\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = ldata->echo_mark;\n\techoed = __process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n\n\tif (echoed && tty->ops->flush_chars)\n\t\ttty->ops->flush_chars(tty);\n}\n\n \nstatic void flush_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif ((!L_ECHO(tty) && !L_ECHONL(tty)) ||\n\t    ldata->echo_commit == ldata->echo_head)\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = ldata->echo_head;\n\t__process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n}\n\n \nstatic inline void add_echo_byte(u8 c, struct n_tty_data *ldata)\n{\n\t*echo_buf_addr(ldata, ldata->echo_head) = c;\n\tsmp_wmb();  \n\tldata->echo_head++;\n}\n\n \nstatic void echo_move_back_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_MOVE_BACK_COL, ldata);\n}\n\n \nstatic void echo_set_canon_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_SET_CANON_COL, ldata);\n}\n\n \nstatic void echo_erase_tab(unsigned int num_chars, int after_tab,\n\t\t\t   struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_ERASE_TAB, ldata);\n\n\t \n\tnum_chars &= 7;\n\n\t \n\tif (after_tab)\n\t\tnum_chars |= 0x80;\n\n\tadd_echo_byte(num_chars, ldata);\n}\n\n \nstatic void echo_char_raw(u8 c, struct n_tty_data *ldata)\n{\n\tif (c == ECHO_OP_START) {\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t} else {\n\t\tadd_echo_byte(c, ldata);\n\t}\n}\n\n \nstatic void echo_char(u8 c, const struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (c == ECHO_OP_START) {\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t} else {\n\t\tif (L_ECHOCTL(tty) && iscntrl(c) && c != '\\t')\n\t\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(c, ldata);\n\t}\n}\n\n \nstatic inline void finish_erasing(struct n_tty_data *ldata)\n{\n\tif (ldata->erasing) {\n\t\techo_char_raw('/', ldata);\n\t\tldata->erasing = 0;\n\t}\n}\n\n \nstatic void eraser(u8 c, const struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tenum { ERASE, WERASE, KILL } kill_type;\n\tsize_t head;\n\tsize_t cnt;\n\tint seen_alnums;\n\n\tif (ldata->read_head == ldata->canon_head) {\n\t\t   \n\t\treturn;\n\t}\n\tif (c == ERASE_CHAR(tty))\n\t\tkill_type = ERASE;\n\telse if (c == WERASE_CHAR(tty))\n\t\tkill_type = WERASE;\n\telse {\n\t\tif (!L_ECHO(tty)) {\n\t\t\tldata->read_head = ldata->canon_head;\n\t\t\treturn;\n\t\t}\n\t\tif (!L_ECHOK(tty) || !L_ECHOKE(tty) || !L_ECHOE(tty)) {\n\t\t\tldata->read_head = ldata->canon_head;\n\t\t\tfinish_erasing(ldata);\n\t\t\techo_char(KILL_CHAR(tty), tty);\n\t\t\t \n\t\t\tif (L_ECHOK(tty))\n\t\t\t\techo_char_raw('\\n', ldata);\n\t\t\treturn;\n\t\t}\n\t\tkill_type = KILL;\n\t}\n\n\tseen_alnums = 0;\n\twhile (MASK(ldata->read_head) != MASK(ldata->canon_head)) {\n\t\thead = ldata->read_head;\n\n\t\t \n\t\tdo {\n\t\t\thead--;\n\t\t\tc = read_buf(ldata, head);\n\t\t} while (is_continuation(c, tty) &&\n\t\t\t MASK(head) != MASK(ldata->canon_head));\n\n\t\t \n\t\tif (is_continuation(c, tty))\n\t\t\tbreak;\n\n\t\tif (kill_type == WERASE) {\n\t\t\t \n\t\t\tif (isalnum(c) || c == '_')\n\t\t\t\tseen_alnums++;\n\t\t\telse if (seen_alnums)\n\t\t\t\tbreak;\n\t\t}\n\t\tcnt = ldata->read_head - head;\n\t\tldata->read_head = head;\n\t\tif (L_ECHO(tty)) {\n\t\t\tif (L_ECHOPRT(tty)) {\n\t\t\t\tif (!ldata->erasing) {\n\t\t\t\t\techo_char_raw('\\\\', ldata);\n\t\t\t\t\tldata->erasing = 1;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\techo_char(c, tty);\n\t\t\t\twhile (--cnt > 0) {\n\t\t\t\t\thead++;\n\t\t\t\t\techo_char_raw(read_buf(ldata, head), ldata);\n\t\t\t\t\techo_move_back_col(ldata);\n\t\t\t\t}\n\t\t\t} else if (kill_type == ERASE && !L_ECHOE(tty)) {\n\t\t\t\techo_char(ERASE_CHAR(tty), tty);\n\t\t\t} else if (c == '\\t') {\n\t\t\t\tunsigned int num_chars = 0;\n\t\t\t\tint after_tab = 0;\n\t\t\t\tsize_t tail = ldata->read_head;\n\n\t\t\t\t \n\t\t\t\twhile (MASK(tail) != MASK(ldata->canon_head)) {\n\t\t\t\t\ttail--;\n\t\t\t\t\tc = read_buf(ldata, tail);\n\t\t\t\t\tif (c == '\\t') {\n\t\t\t\t\t\tafter_tab = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (iscntrl(c)) {\n\t\t\t\t\t\tif (L_ECHOCTL(tty))\n\t\t\t\t\t\t\tnum_chars += 2;\n\t\t\t\t\t} else if (!is_continuation(c, tty)) {\n\t\t\t\t\t\tnum_chars++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\techo_erase_tab(num_chars, after_tab, ldata);\n\t\t\t} else {\n\t\t\t\tif (iscntrl(c) && L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\techo_char_raw(' ', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t}\n\t\t\t\tif (!iscntrl(c) || L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\techo_char_raw(' ', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (kill_type == ERASE)\n\t\t\tbreak;\n\t}\n\tif (ldata->read_head == ldata->canon_head && L_ECHO(tty))\n\t\tfinish_erasing(ldata);\n}\n\n\nstatic void __isig(int sig, struct tty_struct *tty)\n{\n\tstruct pid *tty_pgrp = tty_get_pgrp(tty);\n\tif (tty_pgrp) {\n\t\tkill_pgrp(tty_pgrp, sig, 1);\n\t\tput_pid(tty_pgrp);\n\t}\n}\n\n \nstatic void isig(int sig, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (L_NOFLSH(tty)) {\n\t\t \n\t\t__isig(sig, tty);\n\n\t} else {  \n\t\tup_read(&tty->termios_rwsem);\n\t\tdown_write(&tty->termios_rwsem);\n\n\t\t__isig(sig, tty);\n\n\t\t \n\t\tmutex_lock(&ldata->output_lock);\n\t\tldata->echo_head = ldata->echo_tail = 0;\n\t\tldata->echo_mark = ldata->echo_commit = 0;\n\t\tmutex_unlock(&ldata->output_lock);\n\n\t\t \n\t\ttty_driver_flush_buffer(tty);\n\n\t\t \n\t\treset_buffer_flags(tty->disc_data);\n\n\t\t \n\t\tif (tty->link)\n\t\t\tn_tty_packet_mode_flush(tty);\n\n\t\tup_write(&tty->termios_rwsem);\n\t\tdown_read(&tty->termios_rwsem);\n\t}\n}\n\n \nstatic void n_tty_receive_break(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IGNBRK(tty))\n\t\treturn;\n\tif (I_BRKINT(tty)) {\n\t\tisig(SIGINT, tty);\n\t\treturn;\n\t}\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t}\n\tput_tty_queue('\\0', ldata);\n}\n\n \nstatic void n_tty_receive_overrun(const struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tldata->num_overrun++;\n\tif (time_is_before_jiffies(ldata->overrun_time + HZ)) {\n\t\ttty_warn(tty, \"%u input overrun(s)\\n\", ldata->num_overrun);\n\t\tldata->overrun_time = jiffies;\n\t\tldata->num_overrun = 0;\n\t}\n}\n\n \nstatic void n_tty_receive_parity_error(const struct tty_struct *tty,\n\t\t\t\t       u8 c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_INPCK(tty)) {\n\t\tif (I_IGNPAR(tty))\n\t\t\treturn;\n\t\tif (I_PARMRK(tty)) {\n\t\t\tput_tty_queue('\\377', ldata);\n\t\t\tput_tty_queue('\\0', ldata);\n\t\t\tput_tty_queue(c, ldata);\n\t\t} else\n\t\t\tput_tty_queue('\\0', ldata);\n\t} else\n\t\tput_tty_queue(c, ldata);\n}\n\nstatic void\nn_tty_receive_signal_char(struct tty_struct *tty, int signal, u8 c)\n{\n\tisig(signal, tty);\n\tif (I_IXON(tty))\n\t\tstart_tty(tty);\n\tif (L_ECHO(tty)) {\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t} else\n\t\tprocess_echoes(tty);\n}\n\nstatic bool n_tty_is_char_flow_ctrl(struct tty_struct *tty, u8 c)\n{\n\treturn c == START_CHAR(tty) || c == STOP_CHAR(tty);\n}\n\n \nstatic bool n_tty_receive_char_flow_ctrl(struct tty_struct *tty, u8 c,\n\t\t\t\t\t bool lookahead_done)\n{\n\tif (!n_tty_is_char_flow_ctrl(tty, c))\n\t\treturn false;\n\n\tif (lookahead_done)\n\t\treturn true;\n\n\tif (c == START_CHAR(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t\treturn true;\n\t}\n\n\t \n\tstop_tty(tty);\n\treturn true;\n}\n\nstatic void n_tty_receive_handle_newline(struct tty_struct *tty, u8 c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tset_bit(MASK(ldata->read_head), ldata->read_flags);\n\tput_tty_queue(c, ldata);\n\tsmp_store_release(&ldata->canon_head, ldata->read_head);\n\tkill_fasync(&tty->fasync, SIGIO, POLL_IN);\n\twake_up_interruptible_poll(&tty->read_wait, EPOLLIN | EPOLLRDNORM);\n}\n\nstatic bool n_tty_receive_char_canon(struct tty_struct *tty, u8 c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (c == ERASE_CHAR(tty) || c == KILL_CHAR(tty) ||\n\t    (c == WERASE_CHAR(tty) && L_IEXTEN(tty))) {\n\t\teraser(c, tty);\n\t\tcommit_echoes(tty);\n\n\t\treturn true;\n\t}\n\n\tif (c == LNEXT_CHAR(tty) && L_IEXTEN(tty)) {\n\t\tldata->lnext = 1;\n\t\tif (L_ECHO(tty)) {\n\t\t\tfinish_erasing(ldata);\n\t\t\tif (L_ECHOCTL(tty)) {\n\t\t\t\techo_char_raw('^', ldata);\n\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\tcommit_echoes(tty);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tif (c == REPRINT_CHAR(tty) && L_ECHO(tty) && L_IEXTEN(tty)) {\n\t\tsize_t tail = ldata->canon_head;\n\n\t\tfinish_erasing(ldata);\n\t\techo_char(c, tty);\n\t\techo_char_raw('\\n', ldata);\n\t\twhile (MASK(tail) != MASK(ldata->read_head)) {\n\t\t\techo_char(read_buf(ldata, tail), tty);\n\t\t\ttail++;\n\t\t}\n\t\tcommit_echoes(tty);\n\n\t\treturn true;\n\t}\n\n\tif (c == '\\n') {\n\t\tif (L_ECHO(tty) || L_ECHONL(tty)) {\n\t\t\techo_char_raw('\\n', ldata);\n\t\t\tcommit_echoes(tty);\n\t\t}\n\t\tn_tty_receive_handle_newline(tty, c);\n\n\t\treturn true;\n\t}\n\n\tif (c == EOF_CHAR(tty)) {\n\t\tc = __DISABLED_CHAR;\n\t\tn_tty_receive_handle_newline(tty, c);\n\n\t\treturn true;\n\t}\n\n\tif ((c == EOL_CHAR(tty)) ||\n\t    (c == EOL2_CHAR(tty) && L_IEXTEN(tty))) {\n\t\t \n\t\tif (L_ECHO(tty)) {\n\t\t\t \n\t\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\t\techo_set_canon_col(ldata);\n\t\t\techo_char(c, tty);\n\t\t\tcommit_echoes(tty);\n\t\t}\n\t\t \n\t\tif (c == '\\377' && I_PARMRK(tty))\n\t\t\tput_tty_queue(c, ldata);\n\n\t\tn_tty_receive_handle_newline(tty, c);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void n_tty_receive_char_special(struct tty_struct *tty, u8 c,\n\t\t\t\t       bool lookahead_done)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IXON(tty) && n_tty_receive_char_flow_ctrl(tty, c, lookahead_done))\n\t\treturn;\n\n\tif (L_ISIG(tty)) {\n\t\tif (c == INTR_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGINT, c);\n\t\t\treturn;\n\t\t} else if (c == QUIT_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGQUIT, c);\n\t\t\treturn;\n\t\t} else if (c == SUSP_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGTSTP, c);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (tty->flow.stopped && !tty->flow.tco_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\tif (c == '\\r') {\n\t\tif (I_IGNCR(tty))\n\t\t\treturn;\n\t\tif (I_ICRNL(tty))\n\t\t\tc = '\\n';\n\t} else if (c == '\\n' && I_INLCR(tty))\n\t\tc = '\\r';\n\n\tif (ldata->icanon && n_tty_receive_char_canon(tty, c))\n\t\treturn;\n\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\tif (c == '\\n')\n\t\t\techo_char_raw('\\n', ldata);\n\t\telse {\n\t\t\t \n\t\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\t\techo_set_canon_col(ldata);\n\t\t\techo_char(c, tty);\n\t\t}\n\t\tcommit_echoes(tty);\n\t}\n\n\t \n\tif (c == '\\377' && I_PARMRK(tty))\n\t\tput_tty_queue(c, ldata);\n\n\tput_tty_queue(c, ldata);\n}\n\n \nstatic void n_tty_receive_char(struct tty_struct *tty, u8 c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->flow.stopped && !tty->flow.tco_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\t \n\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\techo_set_canon_col(ldata);\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t}\n\t \n\tif (c == '\\377' && I_PARMRK(tty))\n\t\tput_tty_queue(c, ldata);\n\tput_tty_queue(c, ldata);\n}\n\nstatic void n_tty_receive_char_closing(struct tty_struct *tty, u8 c,\n\t\t\t\t       bool lookahead_done)\n{\n\tif (I_ISTRIP(tty))\n\t\tc &= 0x7f;\n\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\tc = tolower(c);\n\n\tif (I_IXON(tty)) {\n\t\tif (!n_tty_receive_char_flow_ctrl(tty, c, lookahead_done) &&\n\t\t    tty->flow.stopped && !tty->flow.tco_stopped && I_IXANY(tty) &&\n\t\t    c != INTR_CHAR(tty) && c != QUIT_CHAR(tty) &&\n\t\t    c != SUSP_CHAR(tty)) {\n\t\t\tstart_tty(tty);\n\t\t\tprocess_echoes(tty);\n\t\t}\n\t}\n}\n\nstatic void\nn_tty_receive_char_flagged(struct tty_struct *tty, u8 c, u8 flag)\n{\n\tswitch (flag) {\n\tcase TTY_BREAK:\n\t\tn_tty_receive_break(tty);\n\t\tbreak;\n\tcase TTY_PARITY:\n\tcase TTY_FRAME:\n\t\tn_tty_receive_parity_error(tty, c);\n\t\tbreak;\n\tcase TTY_OVERRUN:\n\t\tn_tty_receive_overrun(tty);\n\t\tbreak;\n\tdefault:\n\t\ttty_err(tty, \"unknown flag %u\\n\", flag);\n\t\tbreak;\n\t}\n}\n\nstatic void\nn_tty_receive_char_lnext(struct tty_struct *tty, u8 c, u8 flag)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tldata->lnext = 0;\n\tif (likely(flag == TTY_NORMAL)) {\n\t\tif (I_ISTRIP(tty))\n\t\t\tc &= 0x7f;\n\t\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\t\tc = tolower(c);\n\t\tn_tty_receive_char(tty, c);\n\t} else\n\t\tn_tty_receive_char_flagged(tty, c, flag);\n}\n\n \nstatic void n_tty_lookahead_flow_ctrl(struct tty_struct *tty, const u8 *cp,\n\t\t\t\t      const u8 *fp, size_t count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tu8 flag = TTY_NORMAL;\n\n\tldata->lookahead_count += count;\n\n\tif (!I_IXON(tty))\n\t\treturn;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tn_tty_receive_char_flow_ctrl(tty, *cp, false);\n\t\tcp++;\n\t}\n}\n\nstatic void\nn_tty_receive_buf_real_raw(const struct tty_struct *tty, const u8 *cp,\n\t\t\t   size_t count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t \n\tfor (unsigned int i = 0; i < 2; i++) {\n\t\tsize_t head = MASK(ldata->read_head);\n\t\tsize_t n = min(count, N_TTY_BUF_SIZE - head);\n\n\t\tmemcpy(read_buf_addr(ldata, head), cp, n);\n\n\t\tldata->read_head += n;\n\t\tcp += n;\n\t\tcount -= n;\n\t}\n}\n\nstatic void\nn_tty_receive_buf_raw(struct tty_struct *tty, const u8 *cp, const u8 *fp,\n\t\t      size_t count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tu8 flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tput_tty_queue(*cp++, ldata);\n\t\telse\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_closing(struct tty_struct *tty, const u8 *cp, const u8 *fp,\n\t\t\t  size_t count, bool lookahead_done)\n{\n\tu8 flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tn_tty_receive_char_closing(tty, *cp++, lookahead_done);\n\t}\n}\n\nstatic void n_tty_receive_buf_standard(struct tty_struct *tty, const u8 *cp,\n\t\t\t\t       const u8 *fp, size_t count,\n\t\t\t\t       bool lookahead_done)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tu8 flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tu8 c = *cp++;\n\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\n\t\tif (ldata->lnext) {\n\t\t\tn_tty_receive_char_lnext(tty, c, flag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(flag != TTY_NORMAL)) {\n\t\t\tn_tty_receive_char_flagged(tty, c, flag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (I_ISTRIP(tty))\n\t\t\tc &= 0x7f;\n\t\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\t\tc = tolower(c);\n\t\tif (L_EXTPROC(tty)) {\n\t\t\tput_tty_queue(c, ldata);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(c, ldata->char_map))\n\t\t\tn_tty_receive_char_special(tty, c, lookahead_done);\n\t\telse\n\t\t\tn_tty_receive_char(tty, c);\n\t}\n}\n\nstatic void __receive_buf(struct tty_struct *tty, const u8 *cp, const u8 *fp,\n\t\t\t  size_t count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tbool preops = I_ISTRIP(tty) || (I_IUCLC(tty) && L_IEXTEN(tty));\n\tsize_t la_count = min(ldata->lookahead_count, count);\n\n\tif (ldata->real_raw)\n\t\tn_tty_receive_buf_real_raw(tty, cp, count);\n\telse if (ldata->raw || (L_EXTPROC(tty) && !preops))\n\t\tn_tty_receive_buf_raw(tty, cp, fp, count);\n\telse if (tty->closing && !L_EXTPROC(tty)) {\n\t\tif (la_count > 0)\n\t\t\tn_tty_receive_buf_closing(tty, cp, fp, la_count, true);\n\t\tif (count > la_count)\n\t\t\tn_tty_receive_buf_closing(tty, cp, fp, count - la_count, false);\n\t} else {\n\t\tif (la_count > 0)\n\t\t\tn_tty_receive_buf_standard(tty, cp, fp, la_count, true);\n\t\tif (count > la_count)\n\t\t\tn_tty_receive_buf_standard(tty, cp, fp, count - la_count, false);\n\n\t\tflush_echoes(tty);\n\t\tif (tty->ops->flush_chars)\n\t\t\ttty->ops->flush_chars(tty);\n\t}\n\n\tldata->lookahead_count -= la_count;\n\n\tif (ldata->icanon && !L_EXTPROC(tty))\n\t\treturn;\n\n\t \n\tsmp_store_release(&ldata->commit_head, ldata->read_head);\n\n\tif (read_cnt(ldata)) {\n\t\tkill_fasync(&tty->fasync, SIGIO, POLL_IN);\n\t\twake_up_interruptible_poll(&tty->read_wait, EPOLLIN | EPOLLRDNORM);\n\t}\n}\n\n \nstatic size_t\nn_tty_receive_buf_common(struct tty_struct *tty, const u8 *cp, const u8 *fp,\n\t\t\t size_t count, bool flow)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, rcvd = 0;\n\tint room, overflow;\n\n\tdown_read(&tty->termios_rwsem);\n\n\tdo {\n\t\t \n\t\tsize_t tail = smp_load_acquire(&ldata->read_tail);\n\n\t\troom = N_TTY_BUF_SIZE - (ldata->read_head - tail);\n\t\tif (I_PARMRK(tty))\n\t\t\troom = DIV_ROUND_UP(room, 3);\n\t\troom--;\n\t\tif (room <= 0) {\n\t\t\toverflow = ldata->icanon && ldata->canon_head == tail;\n\t\t\tif (overflow && room < 0)\n\t\t\t\tldata->read_head--;\n\t\t\troom = overflow;\n\t\t\tWRITE_ONCE(ldata->no_room, flow && !room);\n\t\t} else\n\t\t\toverflow = 0;\n\n\t\tn = min_t(size_t, count, room);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!overflow || !fp || *fp != TTY_PARITY)\n\t\t\t__receive_buf(tty, cp, fp, n);\n\n\t\tcp += n;\n\t\tif (fp)\n\t\t\tfp += n;\n\t\tcount -= n;\n\t\trcvd += n;\n\t} while (!test_bit(TTY_LDISC_CHANGING, &tty->flags));\n\n\ttty->receive_room = room;\n\n\t \n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY) {\n\t\tif (overflow) {\n\t\t\ttty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\n\t\t\ttty_unthrottle_safe(tty);\n\t\t\t__tty_set_flow_change(tty, 0);\n\t\t}\n\t} else\n\t\tn_tty_check_throttle(tty);\n\n\tif (unlikely(ldata->no_room)) {\n\t\t \n\t\tsmp_mb();\n\t\tif (!chars_in_buffer(tty))\n\t\t\tn_tty_kick_worker(tty);\n\t}\n\n\tup_read(&tty->termios_rwsem);\n\n\treturn rcvd;\n}\n\nstatic void n_tty_receive_buf(struct tty_struct *tty, const u8 *cp,\n\t\t\t      const u8 *fp, size_t count)\n{\n\tn_tty_receive_buf_common(tty, cp, fp, count, false);\n}\n\nstatic size_t n_tty_receive_buf2(struct tty_struct *tty, const u8 *cp,\n\t\t\t\t const u8 *fp, size_t count)\n{\n\treturn n_tty_receive_buf_common(tty, cp, fp, count, true);\n}\n\n \nstatic void n_tty_set_termios(struct tty_struct *tty, const struct ktermios *old)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {\n\t\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\t\tldata->line_start = ldata->read_tail;\n\t\tif (!L_ICANON(tty) || !read_cnt(ldata)) {\n\t\t\tldata->canon_head = ldata->read_tail;\n\t\t\tldata->push = 0;\n\t\t} else {\n\t\t\tset_bit(MASK(ldata->read_head - 1), ldata->read_flags);\n\t\t\tldata->canon_head = ldata->read_head;\n\t\t\tldata->push = 1;\n\t\t}\n\t\tldata->commit_head = ldata->read_head;\n\t\tldata->erasing = 0;\n\t\tldata->lnext = 0;\n\t}\n\n\tldata->icanon = (L_ICANON(tty) != 0);\n\n\tif (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||\n\t    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||\n\t    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||\n\t    I_PARMRK(tty)) {\n\t\tbitmap_zero(ldata->char_map, 256);\n\n\t\tif (I_IGNCR(tty) || I_ICRNL(tty))\n\t\t\tset_bit('\\r', ldata->char_map);\n\t\tif (I_INLCR(tty))\n\t\t\tset_bit('\\n', ldata->char_map);\n\n\t\tif (L_ICANON(tty)) {\n\t\t\tset_bit(ERASE_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(KILL_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(EOF_CHAR(tty), ldata->char_map);\n\t\t\tset_bit('\\n', ldata->char_map);\n\t\t\tset_bit(EOL_CHAR(tty), ldata->char_map);\n\t\t\tif (L_IEXTEN(tty)) {\n\t\t\t\tset_bit(WERASE_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(LNEXT_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(EOL2_CHAR(tty), ldata->char_map);\n\t\t\t\tif (L_ECHO(tty))\n\t\t\t\t\tset_bit(REPRINT_CHAR(tty),\n\t\t\t\t\t\tldata->char_map);\n\t\t\t}\n\t\t}\n\t\tif (I_IXON(tty)) {\n\t\t\tset_bit(START_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(STOP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tif (L_ISIG(tty)) {\n\t\t\tset_bit(INTR_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(QUIT_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(SUSP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tclear_bit(__DISABLED_CHAR, ldata->char_map);\n\t\tldata->raw = 0;\n\t\tldata->real_raw = 0;\n\t} else {\n\t\tldata->raw = 1;\n\t\tif ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&\n\t\t    (I_IGNPAR(tty) || !I_INPCK(tty)) &&\n\t\t    (tty->driver->flags & TTY_DRIVER_REAL_RAW))\n\t\t\tldata->real_raw = 1;\n\t\telse\n\t\t\tldata->real_raw = 0;\n\t}\n\t \n\tif (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow.tco_stopped) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\t \n\twake_up_interruptible(&tty->write_wait);\n\twake_up_interruptible(&tty->read_wait);\n}\n\n \nstatic void n_tty_close(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\n\tdown_write(&tty->termios_rwsem);\n\tvfree(ldata);\n\ttty->disc_data = NULL;\n\tup_write(&tty->termios_rwsem);\n}\n\n \nstatic int n_tty_open(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata;\n\n\t \n\tldata = vzalloc(sizeof(*ldata));\n\tif (!ldata)\n\t\treturn -ENOMEM;\n\n\tldata->overrun_time = jiffies;\n\tmutex_init(&ldata->atomic_read_lock);\n\tmutex_init(&ldata->output_lock);\n\n\ttty->disc_data = ldata;\n\ttty->closing = 0;\n\t \n\tclear_bit(TTY_LDISC_HALTED, &tty->flags);\n\tn_tty_set_termios(tty, NULL);\n\ttty_unthrottle(tty);\n\treturn 0;\n}\n\nstatic inline int input_available_p(const struct tty_struct *tty, int poll)\n{\n\tconst struct n_tty_data *ldata = tty->disc_data;\n\tint amt = poll && !TIME_CHAR(tty) && MIN_CHAR(tty) ? MIN_CHAR(tty) : 1;\n\n\tif (ldata->icanon && !L_EXTPROC(tty))\n\t\treturn ldata->canon_head != ldata->read_tail;\n\telse\n\t\treturn ldata->commit_head - ldata->read_tail >= amt;\n}\n\n \nstatic bool copy_from_read_buf(const struct tty_struct *tty, u8 **kbp,\n\t\t\t       size_t *nr)\n\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n;\n\tbool is_eof;\n\tsize_t head = smp_load_acquire(&ldata->commit_head);\n\tsize_t tail = MASK(ldata->read_tail);\n\n\tn = min(head - ldata->read_tail, N_TTY_BUF_SIZE - tail);\n\tn = min(*nr, n);\n\tif (n) {\n\t\tu8 *from = read_buf_addr(ldata, tail);\n\t\tmemcpy(*kbp, from, n);\n\t\tis_eof = n == 1 && *from == EOF_CHAR(tty);\n\t\ttty_audit_add_data(tty, from, n);\n\t\tzero_buffer(tty, from, n);\n\t\tsmp_store_release(&ldata->read_tail, ldata->read_tail + n);\n\t\t \n\t\tif (L_EXTPROC(tty) && ldata->icanon && is_eof &&\n\t\t    (head == ldata->read_tail))\n\t\t\treturn false;\n\t\t*kbp += n;\n\t\t*nr -= n;\n\n\t\t \n\t\treturn head != ldata->read_tail;\n\t}\n\treturn false;\n}\n\n \nstatic bool canon_copy_from_read_buf(const struct tty_struct *tty, u8 **kbp,\n\t\t\t\t     size_t *nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, size, more, c;\n\tsize_t eol;\n\tsize_t tail, canon_head;\n\tint found = 0;\n\n\t \n\tif (!*nr)\n\t\treturn false;\n\n\tcanon_head = smp_load_acquire(&ldata->canon_head);\n\tn = min(*nr, canon_head - ldata->read_tail);\n\n\ttail = MASK(ldata->read_tail);\n\tsize = min_t(size_t, tail + n, N_TTY_BUF_SIZE);\n\n\tn_tty_trace(\"%s: nr:%zu tail:%zu n:%zu size:%zu\\n\",\n\t\t    __func__, *nr, tail, n, size);\n\n\teol = find_next_bit(ldata->read_flags, size, tail);\n\tmore = n - (size - tail);\n\tif (eol == N_TTY_BUF_SIZE && more) {\n\t\t \n\t\teol = find_first_bit(ldata->read_flags, more);\n\t\tfound = eol != more;\n\t} else\n\t\tfound = eol != size;\n\n\tn = eol - tail;\n\tif (n > N_TTY_BUF_SIZE)\n\t\tn += N_TTY_BUF_SIZE;\n\tc = n + found;\n\n\tif (!found || read_buf(ldata, eol) != __DISABLED_CHAR)\n\t\tn = c;\n\n\tn_tty_trace(\"%s: eol:%zu found:%d n:%zu c:%zu tail:%zu more:%zu\\n\",\n\t\t    __func__, eol, found, n, c, tail, more);\n\n\ttty_copy(tty, *kbp, tail, n);\n\t*kbp += n;\n\t*nr -= n;\n\n\tif (found)\n\t\tclear_bit(eol, ldata->read_flags);\n\tsmp_store_release(&ldata->read_tail, ldata->read_tail + c);\n\n\tif (found) {\n\t\tif (!ldata->push)\n\t\t\tldata->line_start = ldata->read_tail;\n\t\telse\n\t\t\tldata->push = 0;\n\t\ttty_audit_push();\n\t\treturn false;\n\t}\n\n\t \n\treturn ldata->read_tail != canon_head;\n}\n\n \nstatic void canon_skip_eof(struct n_tty_data *ldata)\n{\n\tsize_t tail, canon_head;\n\n\tcanon_head = smp_load_acquire(&ldata->canon_head);\n\ttail = ldata->read_tail;\n\n\t \n\tif (tail == canon_head)\n\t\treturn;\n\n\t \n\ttail &= (N_TTY_BUF_SIZE - 1);\n\tif (!test_bit(tail, ldata->read_flags))\n\t\treturn;\n\tif (read_buf(ldata, tail) != __DISABLED_CHAR)\n\t\treturn;\n\n\t \n\tclear_bit(tail, ldata->read_flags);\n\tsmp_store_release(&ldata->read_tail, ldata->read_tail + 1);\n}\n\n \nstatic int job_control(struct tty_struct *tty, struct file *file)\n{\n\t \n\t \n\t \n\tif (file->f_op->write_iter == redirected_tty_write)\n\t\treturn 0;\n\n\treturn __tty_check_change(tty, SIGTTIN);\n}\n\n\n \nstatic ssize_t n_tty_read(struct tty_struct *tty, struct file *file, u8 *kbuf,\n\t\t\t  size_t nr, void **cookie, unsigned long offset)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tu8 *kb = kbuf;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint c;\n\tint minimum, time;\n\tssize_t retval = 0;\n\tlong timeout;\n\tbool packet;\n\tsize_t old_tail;\n\n\t \n\tif (*cookie) {\n\t\tif (ldata->icanon && !L_EXTPROC(tty)) {\n\t\t\t \n\t\t\tif (!nr)\n\t\t\t\tcanon_skip_eof(ldata);\n\t\t\telse if (canon_copy_from_read_buf(tty, &kb, &nr))\n\t\t\t\treturn kb - kbuf;\n\t\t} else {\n\t\t\tif (copy_from_read_buf(tty, &kb, &nr))\n\t\t\t\treturn kb - kbuf;\n\t\t}\n\n\t\t \n\t\tn_tty_kick_worker(tty);\n\t\tn_tty_check_unthrottle(tty);\n\t\tup_read(&tty->termios_rwsem);\n\t\tmutex_unlock(&ldata->atomic_read_lock);\n\t\t*cookie = NULL;\n\t\treturn kb - kbuf;\n\t}\n\n\tc = job_control(tty, file);\n\tif (c < 0)\n\t\treturn c;\n\n\t \n\tif (file->f_flags & O_NONBLOCK) {\n\t\tif (!mutex_trylock(&ldata->atomic_read_lock))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (mutex_lock_interruptible(&ldata->atomic_read_lock))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\tminimum = time = 0;\n\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\tif (!ldata->icanon) {\n\t\tminimum = MIN_CHAR(tty);\n\t\tif (minimum) {\n\t\t\ttime = (HZ / 10) * TIME_CHAR(tty);\n\t\t} else {\n\t\t\ttimeout = (HZ / 10) * TIME_CHAR(tty);\n\t\t\tminimum = 1;\n\t\t}\n\t}\n\n\tpacket = tty->ctrl.packet;\n\told_tail = ldata->read_tail;\n\n\tadd_wait_queue(&tty->read_wait, &wait);\n\twhile (nr) {\n\t\t \n\t\tif (packet && tty->link->ctrl.pktstatus) {\n\t\t\tu8 cs;\n\t\t\tif (kb != kbuf)\n\t\t\t\tbreak;\n\t\t\tspin_lock_irq(&tty->link->ctrl.lock);\n\t\t\tcs = tty->link->ctrl.pktstatus;\n\t\t\ttty->link->ctrl.pktstatus = 0;\n\t\t\tspin_unlock_irq(&tty->link->ctrl.lock);\n\t\t\t*kb++ = cs;\n\t\t\tnr--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!input_available_p(tty, 0)) {\n\t\t\tup_read(&tty->termios_rwsem);\n\t\t\ttty_buffer_flush_work(tty->port);\n\t\t\tdown_read(&tty->termios_rwsem);\n\t\t\tif (!input_available_p(tty, 0)) {\n\t\t\t\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {\n\t\t\t\t\tretval = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (tty_hung_up_p(file))\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tif (test_bit(TTY_HUPPING, &tty->flags))\n\t\t\t\t\tbreak;\n\t\t\t\tif (!timeout)\n\t\t\t\t\tbreak;\n\t\t\t\tif (tty_io_nonblock(tty, file)) {\n\t\t\t\t\tretval = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tretval = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tup_read(&tty->termios_rwsem);\n\n\t\t\t\ttimeout = wait_woken(&wait, TASK_INTERRUPTIBLE,\n\t\t\t\t\t\ttimeout);\n\n\t\t\t\tdown_read(&tty->termios_rwsem);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ldata->icanon && !L_EXTPROC(tty)) {\n\t\t\tif (canon_copy_from_read_buf(tty, &kb, &nr))\n\t\t\t\tgoto more_to_be_read;\n\t\t} else {\n\t\t\t \n\t\t\tif (packet && kb == kbuf) {\n\t\t\t\t*kb++ = TIOCPKT_DATA;\n\t\t\t\tnr--;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (copy_from_read_buf(tty, &kb, &nr) && kb - kbuf >= minimum) {\nmore_to_be_read:\n\t\t\t\tremove_wait_queue(&tty->read_wait, &wait);\n\t\t\t\t*cookie = cookie;\n\t\t\t\treturn kb - kbuf;\n\t\t\t}\n\t\t}\n\n\t\tn_tty_check_unthrottle(tty);\n\n\t\tif (kb - kbuf >= minimum)\n\t\t\tbreak;\n\t\tif (time)\n\t\t\ttimeout = time;\n\t}\n\tif (old_tail != ldata->read_tail) {\n\t\t \n\t\tsmp_mb();\n\t\tn_tty_kick_worker(tty);\n\t}\n\tup_read(&tty->termios_rwsem);\n\n\tremove_wait_queue(&tty->read_wait, &wait);\n\tmutex_unlock(&ldata->atomic_read_lock);\n\n\tif (kb - kbuf)\n\t\tretval = kb - kbuf;\n\n\treturn retval;\n}\n\n \n\nstatic ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const u8 *buf, size_t nr)\n{\n\tconst u8 *b = buf;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tssize_t num, retval = 0;\n\n\t \n\tif (L_TOSTOP(tty) && file->f_op->write_iter != redirected_tty_write) {\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\t \n\tprocess_echoes(tty);\n\n\tadd_wait_queue(&tty->write_wait, &wait);\n\twhile (1) {\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (O_OPOST(tty)) {\n\t\t\twhile (nr > 0) {\n\t\t\t\tnum = process_output_block(tty, b, nr);\n\t\t\t\tif (num < 0) {\n\t\t\t\t\tif (num == -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t\tif (nr == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (process_output(*b, tty) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb++; nr--;\n\t\t\t}\n\t\t\tif (tty->ops->flush_chars)\n\t\t\t\ttty->ops->flush_chars(tty);\n\t\t} else {\n\t\t\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t\t\twhile (nr > 0) {\n\t\t\t\tmutex_lock(&ldata->output_lock);\n\t\t\t\tnum = tty->ops->write(tty, b, nr);\n\t\t\t\tmutex_unlock(&ldata->output_lock);\n\t\t\t\tif (num < 0) {\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tif (!num)\n\t\t\t\t\tbreak;\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t}\n\t\t}\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (tty_io_nonblock(tty, file)) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tup_read(&tty->termios_rwsem);\n\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\n\t\tdown_read(&tty->termios_rwsem);\n\t}\nbreak_out:\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (nr && tty->fasync)\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tup_read(&tty->termios_rwsem);\n\treturn (b - buf) ? b - buf : retval;\n}\n\n \nstatic __poll_t n_tty_poll(struct tty_struct *tty, struct file *file,\n\t\t\t\t\t\t\tpoll_table *wait)\n{\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &tty->read_wait, wait);\n\tpoll_wait(file, &tty->write_wait, wait);\n\tif (input_available_p(tty, 1))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\telse {\n\t\ttty_buffer_flush_work(tty->port);\n\t\tif (input_available_p(tty, 1))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t}\n\tif (tty->ctrl.packet && tty->link->ctrl.pktstatus)\n\t\tmask |= EPOLLPRI | EPOLLIN | EPOLLRDNORM;\n\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\n\t\tmask |= EPOLLHUP;\n\tif (tty_hung_up_p(file))\n\t\tmask |= EPOLLHUP;\n\tif (tty->ops->write && !tty_is_writelocked(tty) &&\n\t\t\ttty_chars_in_buffer(tty) < WAKEUP_CHARS &&\n\t\t\ttty_write_room(tty) > 0)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\treturn mask;\n}\n\nstatic unsigned long inq_canon(struct n_tty_data *ldata)\n{\n\tsize_t nr, head, tail;\n\n\tif (ldata->canon_head == ldata->read_tail)\n\t\treturn 0;\n\thead = ldata->canon_head;\n\ttail = ldata->read_tail;\n\tnr = head - tail;\n\t \n\twhile (MASK(head) != MASK(tail)) {\n\t\tif (test_bit(MASK(tail), ldata->read_flags) &&\n\t\t    read_buf(ldata, tail) == __DISABLED_CHAR)\n\t\t\tnr--;\n\t\ttail++;\n\t}\n\treturn nr;\n}\n\nstatic int n_tty_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t       unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty) && !L_EXTPROC(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, cmd, arg);\n\t}\n}\n\nstatic struct tty_ldisc_ops n_tty_ops = {\n\t.owner\t\t = THIS_MODULE,\n\t.num\t\t = N_TTY,\n\t.name            = \"n_tty\",\n\t.open            = n_tty_open,\n\t.close           = n_tty_close,\n\t.flush_buffer    = n_tty_flush_buffer,\n\t.read            = n_tty_read,\n\t.write           = n_tty_write,\n\t.ioctl           = n_tty_ioctl,\n\t.set_termios     = n_tty_set_termios,\n\t.poll            = n_tty_poll,\n\t.receive_buf     = n_tty_receive_buf,\n\t.write_wakeup    = n_tty_write_wakeup,\n\t.receive_buf2\t = n_tty_receive_buf2,\n\t.lookahead_buf\t = n_tty_lookahead_flow_ctrl,\n};\n\n \n\nvoid n_tty_inherit_ops(struct tty_ldisc_ops *ops)\n{\n\t*ops = n_tty_ops;\n\tops->owner = NULL;\n}\nEXPORT_SYMBOL_GPL(n_tty_inherit_ops);\n\nvoid __init n_tty_init(void)\n{\n\ttty_register_ldisc(&n_tty_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}