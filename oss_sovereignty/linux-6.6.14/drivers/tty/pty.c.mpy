{
  "module_name": "pty.c",
  "hash_id": "d8070bcbe5a6dcc513625af60d3324f25a2865eb7b3e2214cf488b1b32276d9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/pty.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/fcntl.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/major.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/devpts_fs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n#include \"tty.h\"\n\n#undef TTY_DEBUG_HANGUP\n#ifdef TTY_DEBUG_HANGUP\n# define tty_debug_hangup(tty, f, args...)\ttty_debug(tty, f, ##args)\n#else\n# define tty_debug_hangup(tty, f, args...)\tdo {} while (0)\n#endif\n\n#ifdef CONFIG_UNIX98_PTYS\nstatic struct tty_driver *ptm_driver;\nstatic struct tty_driver *pts_driver;\nstatic DEFINE_MUTEX(devpts_mutex);\n#endif\n\nstatic void pty_close(struct tty_struct *tty, struct file *filp)\n{\n\tif (tty->driver->subtype == PTY_TYPE_MASTER)\n\t\tWARN_ON(tty->count > 1);\n\telse {\n\t\tif (tty_io_error(tty))\n\t\t\treturn;\n\t\tif (tty->count > 2)\n\t\t\treturn;\n\t}\n\tset_bit(TTY_IO_ERROR, &tty->flags);\n\twake_up_interruptible(&tty->read_wait);\n\twake_up_interruptible(&tty->write_wait);\n\tspin_lock_irq(&tty->ctrl.lock);\n\ttty->ctrl.packet = false;\n\tspin_unlock_irq(&tty->ctrl.lock);\n\t \n\tif (!tty->link)\n\t\treturn;\n\tset_bit(TTY_OTHER_CLOSED, &tty->link->flags);\n\twake_up_interruptible(&tty->link->read_wait);\n\twake_up_interruptible(&tty->link->write_wait);\n\tif (tty->driver->subtype == PTY_TYPE_MASTER) {\n\t\tset_bit(TTY_OTHER_CLOSED, &tty->flags);\n#ifdef CONFIG_UNIX98_PTYS\n\t\tif (tty->driver == ptm_driver) {\n\t\t\tmutex_lock(&devpts_mutex);\n\t\t\tif (tty->link->driver_data)\n\t\t\t\tdevpts_pty_kill(tty->link->driver_data);\n\t\t\tmutex_unlock(&devpts_mutex);\n\t\t}\n#endif\n\t\ttty_vhangup(tty->link);\n\t}\n}\n\n \nstatic void pty_unthrottle(struct tty_struct *tty)\n{\n\ttty_wakeup(tty->link);\n\tset_bit(TTY_THROTTLED, &tty->flags);\n}\n\n \n\nstatic ssize_t pty_write(struct tty_struct *tty, const u8 *buf, size_t c)\n{\n\tstruct tty_struct *to = tty->link;\n\n\tif (tty->flow.stopped || !c)\n\t\treturn 0;\n\n\treturn tty_insert_flip_string_and_push_buffer(to->port, buf, c);\n}\n\n \n\nstatic unsigned int pty_write_room(struct tty_struct *tty)\n{\n\tif (tty->flow.stopped)\n\t\treturn 0;\n\treturn tty_buffer_space_avail(tty->link->port);\n}\n\n \nstatic int pty_set_lock(struct tty_struct *tty, int __user *arg)\n{\n\tint val;\n\n\tif (get_user(val, arg))\n\t\treturn -EFAULT;\n\tif (val)\n\t\tset_bit(TTY_PTY_LOCK, &tty->flags);\n\telse\n\t\tclear_bit(TTY_PTY_LOCK, &tty->flags);\n\treturn 0;\n}\n\nstatic int pty_get_lock(struct tty_struct *tty, int __user *arg)\n{\n\tint locked = test_bit(TTY_PTY_LOCK, &tty->flags);\n\n\treturn put_user(locked, arg);\n}\n\n \nstatic int pty_set_pktmode(struct tty_struct *tty, int __user *arg)\n{\n\tint pktmode;\n\n\tif (get_user(pktmode, arg))\n\t\treturn -EFAULT;\n\n\tspin_lock_irq(&tty->ctrl.lock);\n\tif (pktmode) {\n\t\tif (!tty->ctrl.packet) {\n\t\t\ttty->link->ctrl.pktstatus = 0;\n\t\t\tsmp_mb();\n\t\t\ttty->ctrl.packet = true;\n\t\t}\n\t} else\n\t\ttty->ctrl.packet = false;\n\tspin_unlock_irq(&tty->ctrl.lock);\n\n\treturn 0;\n}\n\n \nstatic int pty_get_pktmode(struct tty_struct *tty, int __user *arg)\n{\n\tint pktmode = tty->ctrl.packet;\n\n\treturn put_user(pktmode, arg);\n}\n\n \nstatic int pty_signal(struct tty_struct *tty, int sig)\n{\n\tstruct pid *pgrp;\n\n\tif (sig != SIGINT && sig != SIGQUIT && sig != SIGTSTP)\n\t\treturn -EINVAL;\n\n\tif (tty->link) {\n\t\tpgrp = tty_get_pgrp(tty->link);\n\t\tif (pgrp)\n\t\t\tkill_pgrp(pgrp, sig, 1);\n\t\tput_pid(pgrp);\n\t}\n\treturn 0;\n}\n\nstatic void pty_flush_buffer(struct tty_struct *tty)\n{\n\tstruct tty_struct *to = tty->link;\n\n\tif (!to)\n\t\treturn;\n\n\ttty_buffer_flush(to, NULL);\n\tif (to->ctrl.packet) {\n\t\tspin_lock_irq(&tty->ctrl.lock);\n\t\ttty->ctrl.pktstatus |= TIOCPKT_FLUSHWRITE;\n\t\twake_up_interruptible(&to->read_wait);\n\t\tspin_unlock_irq(&tty->ctrl.lock);\n\t}\n}\n\nstatic int pty_open(struct tty_struct *tty, struct file *filp)\n{\n\tif (!tty || !tty->link)\n\t\treturn -ENODEV;\n\n\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\n\t\tgoto out;\n\tif (test_bit(TTY_PTY_LOCK, &tty->link->flags))\n\t\tgoto out;\n\tif (tty->driver->subtype == PTY_TYPE_SLAVE && tty->link->count != 1)\n\t\tgoto out;\n\n\tclear_bit(TTY_IO_ERROR, &tty->flags);\n\tclear_bit(TTY_OTHER_CLOSED, &tty->link->flags);\n\tset_bit(TTY_THROTTLED, &tty->flags);\n\treturn 0;\n\nout:\n\tset_bit(TTY_IO_ERROR, &tty->flags);\n\treturn -EIO;\n}\n\nstatic void pty_set_termios(struct tty_struct *tty,\n\t\t\t    const struct ktermios *old_termios)\n{\n\t \n\tif (tty->link && tty->link->ctrl.packet) {\n\t\tint extproc = (old_termios->c_lflag & EXTPROC) | L_EXTPROC(tty);\n\t\tint old_flow = ((old_termios->c_iflag & IXON) &&\n\t\t\t\t(old_termios->c_cc[VSTOP] == '\\023') &&\n\t\t\t\t(old_termios->c_cc[VSTART] == '\\021'));\n\t\tint new_flow = (I_IXON(tty) &&\n\t\t\t\tSTOP_CHAR(tty) == '\\023' &&\n\t\t\t\tSTART_CHAR(tty) == '\\021');\n\t\tif ((old_flow != new_flow) || extproc) {\n\t\t\tspin_lock_irq(&tty->ctrl.lock);\n\t\t\tif (old_flow != new_flow) {\n\t\t\t\ttty->ctrl.pktstatus &= ~(TIOCPKT_DOSTOP | TIOCPKT_NOSTOP);\n\t\t\t\tif (new_flow)\n\t\t\t\t\ttty->ctrl.pktstatus |= TIOCPKT_DOSTOP;\n\t\t\t\telse\n\t\t\t\t\ttty->ctrl.pktstatus |= TIOCPKT_NOSTOP;\n\t\t\t}\n\t\t\tif (extproc)\n\t\t\t\ttty->ctrl.pktstatus |= TIOCPKT_IOCTL;\n\t\t\tspin_unlock_irq(&tty->ctrl.lock);\n\t\t\twake_up_interruptible(&tty->link->read_wait);\n\t\t}\n\t}\n\n\ttty->termios.c_cflag &= ~(CSIZE | PARENB);\n\ttty->termios.c_cflag |= (CS8 | CREAD);\n}\n\n \n\nstatic int pty_resize(struct tty_struct *tty,  struct winsize *ws)\n{\n\tstruct pid *pgrp, *rpgrp;\n\tstruct tty_struct *pty = tty->link;\n\n\t \n\tmutex_lock(&tty->winsize_mutex);\n\tif (!memcmp(ws, &tty->winsize, sizeof(*ws)))\n\t\tgoto done;\n\n\t \n\tpgrp = tty_get_pgrp(tty);\n\trpgrp = tty_get_pgrp(pty);\n\n\tif (pgrp)\n\t\tkill_pgrp(pgrp, SIGWINCH, 1);\n\tif (rpgrp != pgrp && rpgrp)\n\t\tkill_pgrp(rpgrp, SIGWINCH, 1);\n\n\tput_pid(pgrp);\n\tput_pid(rpgrp);\n\n\ttty->winsize = *ws;\n\tpty->winsize = *ws;\t \ndone:\n\tmutex_unlock(&tty->winsize_mutex);\n\treturn 0;\n}\n\n \nstatic void pty_start(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tif (tty->link && tty->link->ctrl.packet) {\n\t\tspin_lock_irqsave(&tty->ctrl.lock, flags);\n\t\ttty->ctrl.pktstatus &= ~TIOCPKT_STOP;\n\t\ttty->ctrl.pktstatus |= TIOCPKT_START;\n\t\tspin_unlock_irqrestore(&tty->ctrl.lock, flags);\n\t\twake_up_interruptible_poll(&tty->link->read_wait, EPOLLIN);\n\t}\n}\n\nstatic void pty_stop(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tif (tty->link && tty->link->ctrl.packet) {\n\t\tspin_lock_irqsave(&tty->ctrl.lock, flags);\n\t\ttty->ctrl.pktstatus &= ~TIOCPKT_START;\n\t\ttty->ctrl.pktstatus |= TIOCPKT_STOP;\n\t\tspin_unlock_irqrestore(&tty->ctrl.lock, flags);\n\t\twake_up_interruptible_poll(&tty->link->read_wait, EPOLLIN);\n\t}\n}\n\n \nstatic int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,\n\t\tbool legacy)\n{\n\tstruct tty_struct *o_tty;\n\tstruct tty_port *ports[2];\n\tint idx = tty->index;\n\tint retval = -ENOMEM;\n\n\t \n\tif (driver->subtype != PTY_TYPE_MASTER)\n\t\treturn -EIO;\n\n\tports[0] = kmalloc(sizeof **ports, GFP_KERNEL);\n\tports[1] = kmalloc(sizeof **ports, GFP_KERNEL);\n\tif (!ports[0] || !ports[1])\n\t\tgoto err;\n\tif (!try_module_get(driver->other->owner)) {\n\t\t \n\t\tgoto err;\n\t}\n\to_tty = alloc_tty_struct(driver->other, idx);\n\tif (!o_tty)\n\t\tgoto err_put_module;\n\n\ttty_set_lock_subclass(o_tty);\n\tlockdep_set_subclass(&o_tty->termios_rwsem, TTY_LOCK_SLAVE);\n\n\tif (legacy) {\n\t\t \n\t\ttty_init_termios(tty);\n\t\ttty_init_termios(o_tty);\n\n\t\tdriver->other->ttys[idx] = o_tty;\n\t\tdriver->ttys[idx] = tty;\n\t} else {\n\t\tmemset(&tty->termios_locked, 0, sizeof(tty->termios_locked));\n\t\ttty->termios = driver->init_termios;\n\t\tmemset(&o_tty->termios_locked, 0, sizeof(tty->termios_locked));\n\t\to_tty->termios = driver->other->init_termios;\n\t}\n\n\t \n\ttty_driver_kref_get(driver->other);\n\t \n\ttty->link   = o_tty;\n\to_tty->link = tty;\n\ttty_port_init(ports[0]);\n\ttty_port_init(ports[1]);\n\ttty_buffer_set_limit(ports[0], 8192);\n\ttty_buffer_set_limit(ports[1], 8192);\n\to_tty->port = ports[0];\n\ttty->port = ports[1];\n\to_tty->port->itty = o_tty;\n\n\ttty_buffer_set_lock_subclass(o_tty->port);\n\n\ttty_driver_kref_get(driver);\n\ttty->count++;\n\to_tty->count++;\n\treturn 0;\n\nerr_put_module:\n\tmodule_put(driver->other->owner);\nerr:\n\tkfree(ports[0]);\n\tkfree(ports[1]);\n\treturn retval;\n}\n\nstatic void pty_cleanup(struct tty_struct *tty)\n{\n\ttty_port_put(tty->port);\n}\n\n \n#ifdef CONFIG_LEGACY_PTYS\n\nstatic int pty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\treturn pty_common_install(driver, tty, true);\n}\n\nstatic void pty_remove(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct tty_struct *pair = tty->link;\n\n\tdriver->ttys[tty->index] = NULL;\n\tif (pair)\n\t\tpair->driver->ttys[pair->index] = NULL;\n}\n\nstatic int pty_bsd_ioctl(struct tty_struct *tty,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase TIOCSPTLCK:  \n\t\treturn pty_set_lock(tty, (int __user *) arg);\n\tcase TIOCGPTLCK:  \n\t\treturn pty_get_lock(tty, (int __user *)arg);\n\tcase TIOCPKT:  \n\t\treturn pty_set_pktmode(tty, (int __user *)arg);\n\tcase TIOCGPKT:  \n\t\treturn pty_get_pktmode(tty, (int __user *)arg);\n\tcase TIOCSIG:     \n\t\treturn pty_signal(tty, (int) arg);\n\tcase TIOCGPTN:  \n\t\treturn -EINVAL;\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long pty_bsd_compat_ioctl(struct tty_struct *tty,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\t \n\treturn pty_bsd_ioctl(tty, cmd, (unsigned long)compat_ptr(arg));\n}\n#else\n#define pty_bsd_compat_ioctl NULL\n#endif\n\nstatic int legacy_count = CONFIG_LEGACY_PTY_COUNT;\n \nmodule_param(legacy_count, int, 0);\n\n \nstatic const struct tty_operations master_pty_ops_bsd = {\n\t.install = pty_install,\n\t.open = pty_open,\n\t.close = pty_close,\n\t.write = pty_write,\n\t.write_room = pty_write_room,\n\t.flush_buffer = pty_flush_buffer,\n\t.unthrottle = pty_unthrottle,\n\t.ioctl = pty_bsd_ioctl,\n\t.compat_ioctl = pty_bsd_compat_ioctl,\n\t.cleanup = pty_cleanup,\n\t.resize = pty_resize,\n\t.remove = pty_remove\n};\n\nstatic const struct tty_operations slave_pty_ops_bsd = {\n\t.install = pty_install,\n\t.open = pty_open,\n\t.close = pty_close,\n\t.write = pty_write,\n\t.write_room = pty_write_room,\n\t.flush_buffer = pty_flush_buffer,\n\t.unthrottle = pty_unthrottle,\n\t.set_termios = pty_set_termios,\n\t.cleanup = pty_cleanup,\n\t.resize = pty_resize,\n\t.start = pty_start,\n\t.stop = pty_stop,\n\t.remove = pty_remove\n};\n\nstatic void __init legacy_pty_init(void)\n{\n\tstruct tty_driver *pty_driver, *pty_slave_driver;\n\n\tif (legacy_count <= 0)\n\t\treturn;\n\n\tpty_driver = tty_alloc_driver(legacy_count,\n\t\t\tTTY_DRIVER_RESET_TERMIOS |\n\t\t\tTTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_ALLOC);\n\tif (IS_ERR(pty_driver))\n\t\tpanic(\"Couldn't allocate pty driver\");\n\n\tpty_slave_driver = tty_alloc_driver(legacy_count,\n\t\t\tTTY_DRIVER_RESET_TERMIOS |\n\t\t\tTTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_ALLOC);\n\tif (IS_ERR(pty_slave_driver))\n\t\tpanic(\"Couldn't allocate pty slave driver\");\n\n\tpty_driver->driver_name = \"pty_master\";\n\tpty_driver->name = \"pty\";\n\tpty_driver->major = PTY_MASTER_MAJOR;\n\tpty_driver->minor_start = 0;\n\tpty_driver->type = TTY_DRIVER_TYPE_PTY;\n\tpty_driver->subtype = PTY_TYPE_MASTER;\n\tpty_driver->init_termios = tty_std_termios;\n\tpty_driver->init_termios.c_iflag = 0;\n\tpty_driver->init_termios.c_oflag = 0;\n\tpty_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;\n\tpty_driver->init_termios.c_lflag = 0;\n\tpty_driver->init_termios.c_ispeed = 38400;\n\tpty_driver->init_termios.c_ospeed = 38400;\n\tpty_driver->other = pty_slave_driver;\n\ttty_set_operations(pty_driver, &master_pty_ops_bsd);\n\n\tpty_slave_driver->driver_name = \"pty_slave\";\n\tpty_slave_driver->name = \"ttyp\";\n\tpty_slave_driver->major = PTY_SLAVE_MAJOR;\n\tpty_slave_driver->minor_start = 0;\n\tpty_slave_driver->type = TTY_DRIVER_TYPE_PTY;\n\tpty_slave_driver->subtype = PTY_TYPE_SLAVE;\n\tpty_slave_driver->init_termios = tty_std_termios;\n\tpty_slave_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;\n\tpty_slave_driver->init_termios.c_ispeed = 38400;\n\tpty_slave_driver->init_termios.c_ospeed = 38400;\n\tpty_slave_driver->other = pty_driver;\n\ttty_set_operations(pty_slave_driver, &slave_pty_ops_bsd);\n\n\tif (tty_register_driver(pty_driver))\n\t\tpanic(\"Couldn't register pty driver\");\n\tif (tty_register_driver(pty_slave_driver))\n\t\tpanic(\"Couldn't register pty slave driver\");\n}\n#else\nstatic inline void legacy_pty_init(void) { }\n#endif\n\n \n#ifdef CONFIG_UNIX98_PTYS\nstatic struct cdev ptmx_cdev;\n\n \nint ptm_open_peer(struct file *master, struct tty_struct *tty, int flags)\n{\n\tint fd;\n\tstruct file *filp;\n\tint retval = -EINVAL;\n\tstruct path path;\n\n\tif (tty->driver != ptm_driver)\n\t\treturn -EIO;\n\n\tfd = get_unused_fd_flags(flags);\n\tif (fd < 0) {\n\t\tretval = fd;\n\t\tgoto err;\n\t}\n\n\t \n\tpath.mnt = devpts_mntget(master, tty->driver_data);\n\tif (IS_ERR(path.mnt)) {\n\t\tretval = PTR_ERR(path.mnt);\n\t\tgoto err_put;\n\t}\n\tpath.dentry = tty->link->driver_data;\n\n\tfilp = dentry_open(&path, flags, current_cred());\n\tmntput(path.mnt);\n\tif (IS_ERR(filp)) {\n\t\tretval = PTR_ERR(filp);\n\t\tgoto err_put;\n\t}\n\n\tfd_install(fd, filp);\n\treturn fd;\n\nerr_put:\n\tput_unused_fd(fd);\nerr:\n\treturn retval;\n}\n\nstatic int pty_unix98_ioctl(struct tty_struct *tty,\n\t\t\t    unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase TIOCSPTLCK:  \n\t\treturn pty_set_lock(tty, (int __user *)arg);\n\tcase TIOCGPTLCK:  \n\t\treturn pty_get_lock(tty, (int __user *)arg);\n\tcase TIOCPKT:  \n\t\treturn pty_set_pktmode(tty, (int __user *)arg);\n\tcase TIOCGPKT:  \n\t\treturn pty_get_pktmode(tty, (int __user *)arg);\n\tcase TIOCGPTN:  \n\t\treturn put_user(tty->index, (unsigned int __user *)arg);\n\tcase TIOCSIG:     \n\t\treturn pty_signal(tty, (int) arg);\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long pty_unix98_compat_ioctl(struct tty_struct *tty,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\t \n\treturn pty_unix98_ioctl(tty, cmd,\n\t\tcmd == TIOCSIG ? arg : (unsigned long)compat_ptr(arg));\n}\n#else\n#define pty_unix98_compat_ioctl NULL\n#endif\n\n \n\nstatic struct tty_struct *ptm_unix98_lookup(struct tty_driver *driver,\n\t\tstruct file *file, int idx)\n{\n\t \n\treturn ERR_PTR(-EIO);\n}\n\n \n\nstatic struct tty_struct *pts_unix98_lookup(struct tty_driver *driver,\n\t\tstruct file *file, int idx)\n{\n\tstruct tty_struct *tty;\n\n\tmutex_lock(&devpts_mutex);\n\ttty = devpts_get_priv(file->f_path.dentry);\n\tmutex_unlock(&devpts_mutex);\n\t \n\tif (!tty)\n\t\treturn ERR_PTR(-EIO);\n\treturn tty;\n}\n\nstatic int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\treturn pty_common_install(driver, tty, false);\n}\n\n \nstatic void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct pts_fs_info *fsi;\n\n\tif (tty->driver->subtype == PTY_TYPE_MASTER)\n\t\tfsi = tty->driver_data;\n\telse\n\t\tfsi = tty->link->driver_data;\n\n\tif (fsi) {\n\t\tdevpts_kill_index(fsi, tty->index);\n\t\tdevpts_release(fsi);\n\t}\n}\n\nstatic void pty_show_fdinfo(struct tty_struct *tty, struct seq_file *m)\n{\n\tseq_printf(m, \"tty-index:\\t%d\\n\", tty->index);\n}\n\nstatic const struct tty_operations ptm_unix98_ops = {\n\t.lookup = ptm_unix98_lookup,\n\t.install = pty_unix98_install,\n\t.remove = pty_unix98_remove,\n\t.open = pty_open,\n\t.close = pty_close,\n\t.write = pty_write,\n\t.write_room = pty_write_room,\n\t.flush_buffer = pty_flush_buffer,\n\t.unthrottle = pty_unthrottle,\n\t.ioctl = pty_unix98_ioctl,\n\t.compat_ioctl = pty_unix98_compat_ioctl,\n\t.resize = pty_resize,\n\t.cleanup = pty_cleanup,\n\t.show_fdinfo = pty_show_fdinfo,\n};\n\nstatic const struct tty_operations pty_unix98_ops = {\n\t.lookup = pts_unix98_lookup,\n\t.install = pty_unix98_install,\n\t.remove = pty_unix98_remove,\n\t.open = pty_open,\n\t.close = pty_close,\n\t.write = pty_write,\n\t.write_room = pty_write_room,\n\t.flush_buffer = pty_flush_buffer,\n\t.unthrottle = pty_unthrottle,\n\t.set_termios = pty_set_termios,\n\t.start = pty_start,\n\t.stop = pty_stop,\n\t.cleanup = pty_cleanup,\n};\n\n \n\nstatic int ptmx_open(struct inode *inode, struct file *filp)\n{\n\tstruct pts_fs_info *fsi;\n\tstruct tty_struct *tty;\n\tstruct dentry *dentry;\n\tint retval;\n\tint index;\n\n\tnonseekable_open(inode, filp);\n\n\t \n\tfilp->f_mode |= FMODE_NONOTIFY;\n\n\tretval = tty_alloc_file(filp);\n\tif (retval)\n\t\treturn retval;\n\n\tfsi = devpts_acquire(filp);\n\tif (IS_ERR(fsi)) {\n\t\tretval = PTR_ERR(fsi);\n\t\tgoto out_free_file;\n\t}\n\n\t \n\tmutex_lock(&devpts_mutex);\n\tindex = devpts_new_index(fsi);\n\tmutex_unlock(&devpts_mutex);\n\n\tretval = index;\n\tif (index < 0)\n\t\tgoto out_put_fsi;\n\n\n\tmutex_lock(&tty_mutex);\n\ttty = tty_init_dev(ptm_driver, index);\n\t \n\tmutex_unlock(&tty_mutex);\n\n\tretval = PTR_ERR(tty);\n\tif (IS_ERR(tty))\n\t\tgoto out;\n\n\t \n\tset_bit(TTY_PTY_LOCK, &tty->flags);  \n\ttty->driver_data = fsi;\n\n\ttty_add_file(tty, filp);\n\n\tdentry = devpts_pty_new(fsi, index, tty->link);\n\tif (IS_ERR(dentry)) {\n\t\tretval = PTR_ERR(dentry);\n\t\tgoto err_release;\n\t}\n\ttty->link->driver_data = dentry;\n\n\tretval = ptm_driver->ops->open(tty, filp);\n\tif (retval)\n\t\tgoto err_release;\n\n\ttty_debug_hangup(tty, \"opening (count=%d)\\n\", tty->count);\n\n\ttty_unlock(tty);\n\treturn 0;\nerr_release:\n\ttty_unlock(tty);\n\t \n\ttty_release(inode, filp);\n\treturn retval;\nout:\n\tdevpts_kill_index(fsi, index);\nout_put_fsi:\n\tdevpts_release(fsi);\nout_free_file:\n\ttty_free_file(filp);\n\treturn retval;\n}\n\nstatic struct file_operations ptmx_fops __ro_after_init;\n\nstatic void __init unix98_pty_init(void)\n{\n\tptm_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX,\n\t\t\tTTY_DRIVER_RESET_TERMIOS |\n\t\t\tTTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV |\n\t\t\tTTY_DRIVER_DEVPTS_MEM |\n\t\t\tTTY_DRIVER_DYNAMIC_ALLOC);\n\tif (IS_ERR(ptm_driver))\n\t\tpanic(\"Couldn't allocate Unix98 ptm driver\");\n\tpts_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX,\n\t\t\tTTY_DRIVER_RESET_TERMIOS |\n\t\t\tTTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV |\n\t\t\tTTY_DRIVER_DEVPTS_MEM |\n\t\t\tTTY_DRIVER_DYNAMIC_ALLOC);\n\tif (IS_ERR(pts_driver))\n\t\tpanic(\"Couldn't allocate Unix98 pts driver\");\n\n\tptm_driver->driver_name = \"pty_master\";\n\tptm_driver->name = \"ptm\";\n\tptm_driver->major = UNIX98_PTY_MASTER_MAJOR;\n\tptm_driver->minor_start = 0;\n\tptm_driver->type = TTY_DRIVER_TYPE_PTY;\n\tptm_driver->subtype = PTY_TYPE_MASTER;\n\tptm_driver->init_termios = tty_std_termios;\n\tptm_driver->init_termios.c_iflag = 0;\n\tptm_driver->init_termios.c_oflag = 0;\n\tptm_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;\n\tptm_driver->init_termios.c_lflag = 0;\n\tptm_driver->init_termios.c_ispeed = 38400;\n\tptm_driver->init_termios.c_ospeed = 38400;\n\tptm_driver->other = pts_driver;\n\ttty_set_operations(ptm_driver, &ptm_unix98_ops);\n\n\tpts_driver->driver_name = \"pty_slave\";\n\tpts_driver->name = \"pts\";\n\tpts_driver->major = UNIX98_PTY_SLAVE_MAJOR;\n\tpts_driver->minor_start = 0;\n\tpts_driver->type = TTY_DRIVER_TYPE_PTY;\n\tpts_driver->subtype = PTY_TYPE_SLAVE;\n\tpts_driver->init_termios = tty_std_termios;\n\tpts_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;\n\tpts_driver->init_termios.c_ispeed = 38400;\n\tpts_driver->init_termios.c_ospeed = 38400;\n\tpts_driver->other = ptm_driver;\n\ttty_set_operations(pts_driver, &pty_unix98_ops);\n\n\tif (tty_register_driver(ptm_driver))\n\t\tpanic(\"Couldn't register Unix98 ptm driver\");\n\tif (tty_register_driver(pts_driver))\n\t\tpanic(\"Couldn't register Unix98 pts driver\");\n\n\t \n\ttty_default_fops(&ptmx_fops);\n\tptmx_fops.open = ptmx_open;\n\n\tcdev_init(&ptmx_cdev, &ptmx_fops);\n\tif (cdev_add(&ptmx_cdev, MKDEV(TTYAUX_MAJOR, 2), 1) ||\n\t    register_chrdev_region(MKDEV(TTYAUX_MAJOR, 2), 1, \"/dev/ptmx\") < 0)\n\t\tpanic(\"Couldn't register /dev/ptmx driver\");\n\tdevice_create(&tty_class, NULL, MKDEV(TTYAUX_MAJOR, 2), NULL, \"ptmx\");\n}\n\n#else\nstatic inline void unix98_pty_init(void) { }\n#endif\n\nstatic int __init pty_init(void)\n{\n\tlegacy_pty_init();\n\tunix98_pty_init();\n\treturn 0;\n}\ndevice_initcall(pty_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}