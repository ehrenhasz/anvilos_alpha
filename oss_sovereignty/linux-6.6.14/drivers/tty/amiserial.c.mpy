{
  "module_name": "amiserial.c",
  "hash_id": "30548d2115f0f881fb2fcd56140c81ab7d9fd89d2bd67cf0c17d4df4e6bf1193",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/amiserial.c",
  "human_readable_source": "\n \n\n \n\n#undef SERIAL_DEBUG_INTR\n#undef SERIAL_DEBUG_OPEN\n#undef SERIAL_DEBUG_FLOW\n#undef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\n\n \n\n#include <linux/bitops.h>\n#include <linux/circ_buf.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/ptrace.h>\n#include <linux/seq_file.h>\n#include <linux/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/serial_core.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/tty_flip.h>\n#include <linux/tty.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#include <asm/amigahw.h>\n#include <asm/amigaints.h>\n#include <asm/irq.h>\n#include <asm/setup.h>\n\nstruct serial_state {\n\tstruct tty_port\t\ttport;\n\tstruct circ_buf\t\txmit;\n\tstruct async_icount\ticount;\n\n\tunsigned long\t\tport;\n\tint\t\t\tbaud_base;\n\tint\t\t\tcustom_divisor;\n\tint\t\t\tread_status_mask;\n\tint\t\t\tignore_status_mask;\n\tint\t\t\ttimeout;\n\tint\t\t\tquot;\n\tint\t\t\tIER; \t \n\tint\t\t\tMCR; \t \n\tint\t\t\tx_char;\t \n};\n\nstatic struct tty_driver *serial_driver;\n\n \n#define WAKEUP_CHARS 256\n\n#define XMIT_FIFO_SIZE 1\n\nstatic unsigned char current_ctl_bits;\n\nstatic void change_speed(struct tty_struct *tty, struct serial_state *info,\n\t\t\t const struct ktermios *old);\nstatic void rs_wait_until_sent(struct tty_struct *tty, int timeout);\n\n\nstatic struct serial_state serial_state;\n\n \n#define SDR_OVRUN   (1<<15)\n#define SDR_RBF     (1<<14)\n#define SDR_TBE     (1<<13)\n#define SDR_TSRE    (1<<12)\n\n#define SERPER_PARENB    (1<<15)\n\n#define AC_SETCLR   (1<<15)\n#define AC_UARTBRK  (1<<11)\n\n#define SER_DTR     (1<<7)\n#define SER_RTS     (1<<6)\n#define SER_DCD     (1<<5)\n#define SER_CTS     (1<<4)\n#define SER_DSR     (1<<3)\n\nstatic __inline__ void rtsdtr_ctrl(int bits)\n{\n    ciab.pra = ((bits & (SER_RTS | SER_DTR)) ^ (SER_RTS | SER_DTR)) | (ciab.pra & ~(SER_RTS | SER_DTR));\n}\n\n \nstatic void rs_stop(struct tty_struct *tty)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tif (info->IER & UART_IER_THRI) {\n\t\tinfo->IER &= ~UART_IER_THRI;\n\t\t \n\t\tamiga_custom.intena = IF_TBE;\n\t\tmb();\n\t\tamiga_custom.intreq = IF_TBE;\n\t\tmb();\n\t}\n\tlocal_irq_restore(flags);\n}\n\nstatic void rs_start(struct tty_struct *tty)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tif (info->xmit.head != info->xmit.tail\n\t    && info->xmit.buf\n\t    && !(info->IER & UART_IER_THRI)) {\n\t\tinfo->IER |= UART_IER_THRI;\n\t\tamiga_custom.intena = IF_SETCLR | IF_TBE;\n\t\tmb();\n\t\t \n\t\tamiga_custom.intreq = IF_SETCLR | IF_TBE;\n\t\tmb();\n\t}\n\tlocal_irq_restore(flags);\n}\n\n \n\nstatic void receive_chars(struct serial_state *info)\n{\n        int status;\n\tint serdatr;\n\tunsigned char ch, flag;\n\tstruct\tasync_icount *icount;\n\tint oe = 0;\n\n\ticount = &info->icount;\n\n\tstatus = UART_LSR_DR;  \n\tserdatr = amiga_custom.serdatr;\n\tmb();\n\tamiga_custom.intreq = IF_RBF;\n\tmb();\n\n\tif((serdatr & 0x1ff) == 0)\n\t    status |= UART_LSR_BI;\n\tif(serdatr & SDR_OVRUN)\n\t    status |= UART_LSR_OE;\n\n\tch = serdatr & 0xff;\n\ticount->rx++;\n\n#ifdef SERIAL_DEBUG_INTR\n\tprintk(\"DR%02x:%02x...\", ch, status);\n#endif\n\tflag = TTY_NORMAL;\n\n\t \n\n\tif (status & (UART_LSR_BI | UART_LSR_PE |\n\t\t      UART_LSR_FE | UART_LSR_OE)) {\n\t   \n\t  if (status & UART_LSR_BI) {\n\t    status &= ~(UART_LSR_FE | UART_LSR_PE);\n\t    icount->brk++;\n\t  } else if (status & UART_LSR_PE)\n\t    icount->parity++;\n\t  else if (status & UART_LSR_FE)\n\t    icount->frame++;\n\t  if (status & UART_LSR_OE)\n\t    icount->overrun++;\n\n\t   \n\t  if (status & info->ignore_status_mask)\n\t    goto out;\n\n\t  status &= info->read_status_mask;\n\n\t  if (status & (UART_LSR_BI)) {\n#ifdef SERIAL_DEBUG_INTR\n\t    printk(\"handling break....\");\n#endif\n\t    flag = TTY_BREAK;\n\t    if (info->tport.flags & ASYNC_SAK)\n\t      do_SAK(info->tport.tty);\n\t  } else if (status & UART_LSR_PE)\n\t    flag = TTY_PARITY;\n\t  else if (status & UART_LSR_FE)\n\t    flag = TTY_FRAME;\n\t  if (status & UART_LSR_OE) {\n\t     \n\t     oe = 1;\n\t  }\n\t}\n\ttty_insert_flip_char(&info->tport, ch, flag);\n\tif (oe == 1)\n\t\ttty_insert_flip_char(&info->tport, 0, TTY_OVERRUN);\n\ttty_flip_buffer_push(&info->tport);\nout:\n\treturn;\n}\n\nstatic void transmit_chars(struct serial_state *info)\n{\n\tamiga_custom.intreq = IF_TBE;\n\tmb();\n\tif (info->x_char) {\n\t        amiga_custom.serdat = info->x_char | 0x100;\n\t\tmb();\n\t\tinfo->icount.tx++;\n\t\tinfo->x_char = 0;\n\t\treturn;\n\t}\n\tif (info->xmit.head == info->xmit.tail\n\t    || info->tport.tty->flow.stopped\n\t    || info->tport.tty->hw_stopped) {\n\t\tinfo->IER &= ~UART_IER_THRI;\n\t        amiga_custom.intena = IF_TBE;\n\t\tmb();\n\t\treturn;\n\t}\n\n\tamiga_custom.serdat = info->xmit.buf[info->xmit.tail++] | 0x100;\n\tmb();\n\tinfo->xmit.tail = info->xmit.tail & (UART_XMIT_SIZE - 1);\n\tinfo->icount.tx++;\n\n\tif (CIRC_CNT(info->xmit.head,\n\t\t     info->xmit.tail,\n\t\t     UART_XMIT_SIZE) < WAKEUP_CHARS)\n\t\ttty_wakeup(info->tport.tty);\n\n#ifdef SERIAL_DEBUG_INTR\n\tprintk(\"THRE...\");\n#endif\n\tif (info->xmit.head == info->xmit.tail) {\n\t        amiga_custom.intena = IF_TBE;\n\t\tmb();\n\t\tinfo->IER &= ~UART_IER_THRI;\n\t}\n}\n\nstatic void check_modem_status(struct serial_state *info)\n{\n\tstruct tty_port *port = &info->tport;\n\tunsigned char status = ciab.pra & (SER_DCD | SER_CTS | SER_DSR);\n\tunsigned char dstatus;\n\tstruct\tasync_icount *icount;\n\n\t \n\tdstatus = status ^ current_ctl_bits;\n\tcurrent_ctl_bits = status;\n\n\tif (dstatus) {\n\t\ticount = &info->icount;\n\t\t \n\t\tif (dstatus & SER_DSR)\n\t\t\ticount->dsr++;\n\t\tif (dstatus & SER_DCD) {\n\t\t\ticount->dcd++;\n\t\t}\n\t\tif (dstatus & SER_CTS)\n\t\t\ticount->cts++;\n\t\twake_up_interruptible(&port->delta_msr_wait);\n\t}\n\n\tif (tty_port_check_carrier(port) && (dstatus & SER_DCD)) {\n#if (defined(SERIAL_DEBUG_OPEN) || defined(SERIAL_DEBUG_INTR))\n\t\tprintk(\"ttyS%d CD now %s...\", info->line,\n\t\t       (!(status & SER_DCD)) ? \"on\" : \"off\");\n#endif\n\t\tif (!(status & SER_DCD))\n\t\t\twake_up_interruptible(&port->open_wait);\n\t\telse {\n#ifdef SERIAL_DEBUG_OPEN\n\t\t\tprintk(\"doing serial hangup...\");\n#endif\n\t\t\tif (port->tty)\n\t\t\t\ttty_hangup(port->tty);\n\t\t}\n\t}\n\tif (tty_port_cts_enabled(port)) {\n\t\tif (port->tty->hw_stopped) {\n\t\t\tif (!(status & SER_CTS)) {\n#if (defined(SERIAL_DEBUG_INTR) || defined(SERIAL_DEBUG_FLOW))\n\t\t\t\tprintk(\"CTS tx start...\");\n#endif\n\t\t\t\tport->tty->hw_stopped = false;\n\t\t\t\tinfo->IER |= UART_IER_THRI;\n\t\t\t\tamiga_custom.intena = IF_SETCLR | IF_TBE;\n\t\t\t\tmb();\n\t\t\t\t \n\t\t\t\tamiga_custom.intreq = IF_SETCLR | IF_TBE;\n\t\t\t\tmb();\n\t\t\t\ttty_wakeup(port->tty);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((status & SER_CTS)) {\n#if (defined(SERIAL_DEBUG_INTR) || defined(SERIAL_DEBUG_FLOW))\n\t\t\t\tprintk(\"CTS tx stop...\");\n#endif\n\t\t\t\tport->tty->hw_stopped = true;\n\t\t\t\tinfo->IER &= ~UART_IER_THRI;\n\t\t\t\t \n\t\t\t\tamiga_custom.intena = IF_TBE;\n\t\t\t\tmb();\n\t\t\t\tamiga_custom.intreq = IF_TBE;\n\t\t\t\tmb();\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic irqreturn_t ser_vbl_int( int irq, void *data)\n{\n         \n\tstruct serial_state *info = data;\n\t \n\tif(info->IER & UART_IER_MSI)\n\t  check_modem_status(info);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ser_rx_int(int irq, void *dev_id)\n{\n\tstruct serial_state *info = dev_id;\n\n#ifdef SERIAL_DEBUG_INTR\n\tprintk(\"ser_rx_int...\");\n#endif\n\n\tif (!info->tport.tty)\n\t\treturn IRQ_NONE;\n\n\treceive_chars(info);\n#ifdef SERIAL_DEBUG_INTR\n\tprintk(\"end.\\n\");\n#endif\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ser_tx_int(int irq, void *dev_id)\n{\n\tstruct serial_state *info = dev_id;\n\n\tif (amiga_custom.serdatr & SDR_TBE) {\n#ifdef SERIAL_DEBUG_INTR\n\t  printk(\"ser_tx_int...\");\n#endif\n\n\t  if (!info->tport.tty)\n\t\treturn IRQ_NONE;\n\n\t  transmit_chars(info);\n#ifdef SERIAL_DEBUG_INTR\n\t  printk(\"end.\\n\");\n#endif\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \n\n \n\nstatic int startup(struct tty_struct *tty, struct serial_state *info)\n{\n\tstruct tty_port *port = &info->tport;\n\tunsigned long flags;\n\tint\tretval=0;\n\tunsigned long page;\n\n\tpage = get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlocal_irq_save(flags);\n\n\tif (tty_port_initialized(port)) {\n\t\tfree_page(page);\n\t\tgoto errout;\n\t}\n\n\tif (info->xmit.buf)\n\t\tfree_page(page);\n\telse\n\t\tinfo->xmit.buf = (unsigned char *) page;\n\n#ifdef SERIAL_DEBUG_OPEN\n\tprintk(\"starting up ttys%d ...\", info->line);\n#endif\n\n\t \n\n\tamiga_custom.intreq = IF_RBF;\n\tmb();\n\n\tretval = request_irq(IRQ_AMIGA_VERTB, ser_vbl_int, 0, \"serial status\", info);\n\tif (retval) {\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tset_bit(TTY_IO_ERROR, &tty->flags);\n\t\t\tretval = 0;\n\t\t}\n\t\tgoto errout;\n\t}\n\n\t \n\tamiga_custom.intena = IF_SETCLR | IF_RBF | IF_TBE;\n\tmb();\n\tinfo->IER = UART_IER_MSI;\n\n\t \n\tcurrent_ctl_bits = ciab.pra & (SER_DCD | SER_CTS | SER_DSR);\n\n\tinfo->MCR = 0;\n\tif (C_BAUD(tty))\n\t  info->MCR = SER_DTR | SER_RTS;\n\trtsdtr_ctrl(info->MCR);\n\n\tclear_bit(TTY_IO_ERROR, &tty->flags);\n\tinfo->xmit.head = info->xmit.tail = 0;\n\n\t \n\tchange_speed(tty, info, NULL);\n\n\ttty_port_set_initialized(port, true);\n\tlocal_irq_restore(flags);\n\treturn 0;\n\nerrout:\n\tlocal_irq_restore(flags);\n\treturn retval;\n}\n\n \nstatic void shutdown(struct tty_struct *tty, struct serial_state *info)\n{\n\tunsigned long\tflags;\n\n\tif (!tty_port_initialized(&info->tport))\n\t\treturn;\n\n#ifdef SERIAL_DEBUG_OPEN\n\tprintk(\"Shutting down serial port %d ....\\n\", info->line);\n#endif\n\n\tlocal_irq_save(flags);  \n\n\t \n\twake_up_interruptible(&info->tport.delta_msr_wait);\n\n\t \n\tfree_irq(IRQ_AMIGA_VERTB, info);\n\n\tfree_page((unsigned long)info->xmit.buf);\n\tinfo->xmit.buf = NULL;\n\n\tinfo->IER = 0;\n\tamiga_custom.intena = IF_RBF | IF_TBE;\n\tmb();\n\n\t \n\tamiga_custom.adkcon = AC_UARTBRK;\n\tmb();\n\n\tif (C_HUPCL(tty))\n\t\tinfo->MCR &= ~(SER_DTR|SER_RTS);\n\trtsdtr_ctrl(info->MCR);\n\n\tset_bit(TTY_IO_ERROR, &tty->flags);\n\n\ttty_port_set_initialized(&info->tport, false);\n\tlocal_irq_restore(flags);\n}\n\n\n \nstatic void change_speed(struct tty_struct *tty, struct serial_state *info,\n\t\t\t const struct ktermios *old_termios)\n{\n\tstruct tty_port *port = &info->tport;\n\tint\tquot = 0, baud_base, baud;\n\tunsigned cflag, cval = 0;\n\tint\tbits;\n\tunsigned long\tflags;\n\n\tcflag = tty->termios.c_cflag;\n\n\t \n\n\tcval = 3; bits = 10;\n\tif (cflag & CSTOPB) {\n\t\tcval |= 0x04;\n\t\tbits++;\n\t}\n\tif (cflag & PARENB) {\n\t\tcval |= UART_LCR_PARITY;\n\t\tbits++;\n\t}\n\tif (!(cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\tif (cflag & CMSPAR)\n\t\tcval |= UART_LCR_SPAR;\n\n\t \n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud)\n\t\tbaud = 9600;\t \n\tbaud_base = info->baud_base;\n\tif (baud == 38400 && (port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)\n\t\tquot = info->custom_divisor;\n\telse {\n\t\tif (baud == 134)\n\t\t\t \n\t\t\tquot = (2*baud_base / 269);\n\t\telse if (baud)\n\t\t\tquot = baud_base / baud;\n\t}\n\t \n\tif (!quot && old_termios) {\n\t\t \n\t\ttty->termios.c_cflag &= ~CBAUD;\n\t\ttty->termios.c_cflag |= (old_termios->c_cflag & CBAUD);\n\t\tbaud = tty_get_baud_rate(tty);\n\t\tif (!baud)\n\t\t\tbaud = 9600;\n\t\tif (baud == 38400 &&\n\t\t    (port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)\n\t\t\tquot = info->custom_divisor;\n\t\telse {\n\t\t\tif (baud == 134)\n\t\t\t\t \n\t\t\t\tquot = (2*baud_base / 269);\n\t\t\telse if (baud)\n\t\t\t\tquot = baud_base / baud;\n\t\t}\n\t}\n\t \n\tif (!quot)\n\t\tquot = baud_base / 9600;\n\tinfo->quot = quot;\n\tinfo->timeout = (XMIT_FIFO_SIZE*HZ*bits*quot) / baud_base;\n\tinfo->timeout += HZ/50;\t\t \n\n\t \n\tinfo->IER &= ~UART_IER_MSI;\n\tif (port->flags & ASYNC_HARDPPS_CD)\n\t\tinfo->IER |= UART_IER_MSI;\n\ttty_port_set_cts_flow(port, cflag & CRTSCTS);\n\tif (cflag & CRTSCTS)\n\t\tinfo->IER |= UART_IER_MSI;\n\ttty_port_set_check_carrier(port, ~cflag & CLOCAL);\n\tif (~cflag & CLOCAL)\n\t\tinfo->IER |= UART_IER_MSI;\n\t \n\n\t \n\n\tinfo->read_status_mask = UART_LSR_OE | UART_LSR_DR;\n\tif (I_INPCK(tty))\n\t\tinfo->read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (I_BRKINT(tty) || I_PARMRK(tty))\n\t\tinfo->read_status_mask |= UART_LSR_BI;\n\n\t \n\tinfo->ignore_status_mask = 0;\n\tif (I_IGNPAR(tty))\n\t\tinfo->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\n\tif (I_IGNBRK(tty)) {\n\t\tinfo->ignore_status_mask |= UART_LSR_BI;\n\t\t \n\t\tif (I_IGNPAR(tty))\n\t\t\tinfo->ignore_status_mask |= UART_LSR_OE;\n\t}\n\t \n\tif ((cflag & CREAD) == 0)\n\t\tinfo->ignore_status_mask |= UART_LSR_DR;\n\tlocal_irq_save(flags);\n\n\t{\n\t  short serper;\n\n\t \n\t  serper = quot - 1;\n\n\t \n\n\tif(cval & UART_LCR_PARITY)\n\t  serper |= (SERPER_PARENB);\n\n\tamiga_custom.serper = serper;\n\tmb();\n\t}\n\n\tlocal_irq_restore(flags);\n}\n\nstatic int rs_put_char(struct tty_struct *tty, u8 ch)\n{\n\tstruct serial_state *info;\n\tunsigned long flags;\n\n\tinfo = tty->driver_data;\n\n\tif (!info->xmit.buf)\n\t\treturn 0;\n\n\tlocal_irq_save(flags);\n\tif (CIRC_SPACE(info->xmit.head,\n\t\t       info->xmit.tail,\n\t\t       UART_XMIT_SIZE) == 0) {\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\tinfo->xmit.buf[info->xmit.head++] = ch;\n\tinfo->xmit.head &= UART_XMIT_SIZE - 1;\n\tlocal_irq_restore(flags);\n\treturn 1;\n}\n\nstatic void rs_flush_chars(struct tty_struct *tty)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (info->xmit.head == info->xmit.tail\n\t    || tty->flow.stopped\n\t    || tty->hw_stopped\n\t    || !info->xmit.buf)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tinfo->IER |= UART_IER_THRI;\n\tamiga_custom.intena = IF_SETCLR | IF_TBE;\n\tmb();\n\t \n\tamiga_custom.intreq = IF_SETCLR | IF_TBE;\n\tmb();\n\tlocal_irq_restore(flags);\n}\n\nstatic ssize_t rs_write(struct tty_struct * tty, const u8 *buf, size_t count)\n{\n\tint\tc, ret = 0;\n\tstruct serial_state *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (!info->xmit.buf)\n\t\treturn 0;\n\n\tlocal_irq_save(flags);\n\twhile (1) {\n\t\tc = CIRC_SPACE_TO_END(info->xmit.head,\n\t\t\t\t      info->xmit.tail,\n\t\t\t\t      UART_XMIT_SIZE);\n\t\tif (count < c)\n\t\t\tc = count;\n\t\tif (c <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(info->xmit.buf + info->xmit.head, buf, c);\n\t\tinfo->xmit.head = (info->xmit.head + c) & (UART_XMIT_SIZE - 1);\n\t\tbuf += c;\n\t\tcount -= c;\n\t\tret += c;\n\t}\n\tlocal_irq_restore(flags);\n\n\tif (info->xmit.head != info->xmit.tail\n\t    && !tty->flow.stopped\n\t    && !tty->hw_stopped\n\t    && !(info->IER & UART_IER_THRI)) {\n\t\tinfo->IER |= UART_IER_THRI;\n\t\tlocal_irq_disable();\n\t\tamiga_custom.intena = IF_SETCLR | IF_TBE;\n\t\tmb();\n\t\t \n\t\tamiga_custom.intreq = IF_SETCLR | IF_TBE;\n\t\tmb();\n\t\tlocal_irq_restore(flags);\n\t}\n\treturn ret;\n}\n\nstatic unsigned int rs_write_room(struct tty_struct *tty)\n{\n\tstruct serial_state *info = tty->driver_data;\n\n\treturn CIRC_SPACE(info->xmit.head, info->xmit.tail, UART_XMIT_SIZE);\n}\n\nstatic unsigned int rs_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct serial_state *info = tty->driver_data;\n\n\treturn CIRC_CNT(info->xmit.head, info->xmit.tail, UART_XMIT_SIZE);\n}\n\nstatic void rs_flush_buffer(struct tty_struct *tty)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tinfo->xmit.head = info->xmit.tail = 0;\n\tlocal_irq_restore(flags);\n\ttty_wakeup(tty);\n}\n\n \nstatic void rs_send_xchar(struct tty_struct *tty, char ch)\n{\n\tstruct serial_state *info = tty->driver_data;\n        unsigned long flags;\n\n\tinfo->x_char = ch;\n\tif (ch) {\n\t\t \n\n\t         \n\t        local_irq_save(flags);\n\t\tif(!(amiga_custom.intenar & IF_TBE)) {\n\t\t    amiga_custom.intena = IF_SETCLR | IF_TBE;\n\t\t    mb();\n\t\t     \n\t\t    amiga_custom.intreq = IF_SETCLR | IF_TBE;\n\t\t    mb();\n\t\t}\n\t\tlocal_irq_restore(flags);\n\n\t\tinfo->IER |= UART_IER_THRI;\n\t}\n}\n\n \nstatic void rs_throttle(struct tty_struct * tty)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tunsigned long flags;\n#ifdef SERIAL_DEBUG_THROTTLE\n\tprintk(\"throttle %s ....\\n\", tty_name(tty));\n#endif\n\n\tif (I_IXOFF(tty))\n\t\trs_send_xchar(tty, STOP_CHAR(tty));\n\n\tif (C_CRTSCTS(tty))\n\t\tinfo->MCR &= ~SER_RTS;\n\n\tlocal_irq_save(flags);\n\trtsdtr_ctrl(info->MCR);\n\tlocal_irq_restore(flags);\n}\n\nstatic void rs_unthrottle(struct tty_struct * tty)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tunsigned long flags;\n#ifdef SERIAL_DEBUG_THROTTLE\n\tprintk(\"unthrottle %s ....\\n\", tty_name(tty));\n#endif\n\n\tif (I_IXOFF(tty)) {\n\t\tif (info->x_char)\n\t\t\tinfo->x_char = 0;\n\t\telse\n\t\t\trs_send_xchar(tty, START_CHAR(tty));\n\t}\n\tif (C_CRTSCTS(tty))\n\t\tinfo->MCR |= SER_RTS;\n\tlocal_irq_save(flags);\n\trtsdtr_ctrl(info->MCR);\n\tlocal_irq_restore(flags);\n}\n\n \n\nstatic int get_serial_info(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct serial_state *state = tty->driver_data;\n\tunsigned int close_delay, closing_wait;\n\n\ttty_lock(tty);\n\tclose_delay = jiffies_to_msecs(state->tport.close_delay) / 10;\n\tclosing_wait = state->tport.closing_wait;\n\tif (closing_wait != ASYNC_CLOSING_WAIT_NONE)\n\t\tclosing_wait = jiffies_to_msecs(closing_wait) / 10;\n\n\tss->line = tty->index;\n\tss->port = state->port;\n\tss->flags = state->tport.flags;\n\tss->xmit_fifo_size = XMIT_FIFO_SIZE;\n\tss->baud_base = state->baud_base;\n\tss->close_delay = close_delay;\n\tss->closing_wait = closing_wait;\n\tss->custom_divisor = state->custom_divisor;\n\ttty_unlock(tty);\n\treturn 0;\n}\n\nstatic int set_serial_info(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct serial_state *state = tty->driver_data;\n\tstruct tty_port *port = &state->tport;\n\tbool change_spd;\n\tint \t\t\tretval = 0;\n\tunsigned int close_delay, closing_wait;\n\n\ttty_lock(tty);\n\tchange_spd = ((ss->flags ^ port->flags) & ASYNC_SPD_MASK) ||\n\t\tss->custom_divisor != state->custom_divisor;\n\tif (ss->irq || ss->port != state->port ||\n\t\t\tss->xmit_fifo_size != XMIT_FIFO_SIZE) {\n\t\ttty_unlock(tty);\n\t\treturn -EINVAL;\n\t}\n\n\tclose_delay = msecs_to_jiffies(ss->close_delay * 10);\n\tclosing_wait = ss->closing_wait;\n\tif (closing_wait != ASYNC_CLOSING_WAIT_NONE)\n\t\tclosing_wait = msecs_to_jiffies(closing_wait * 10);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tif ((ss->baud_base != state->baud_base) ||\n\t\t    (close_delay != port->close_delay) ||\n\t\t    (closing_wait != port->closing_wait) ||\n\t\t    ((ss->flags & ~ASYNC_USR_MASK) !=\n\t\t     (port->flags & ~ASYNC_USR_MASK))) {\n\t\t\ttty_unlock(tty);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tport->flags = ((port->flags & ~ASYNC_USR_MASK) |\n\t\t\t       (ss->flags & ASYNC_USR_MASK));\n\t\tstate->custom_divisor = ss->custom_divisor;\n\t\tgoto check_and_exit;\n\t}\n\n\tif (ss->baud_base < 9600) {\n\t\ttty_unlock(tty);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tstate->baud_base = ss->baud_base;\n\tport->flags = ((port->flags & ~ASYNC_FLAGS) |\n\t\t\t(ss->flags & ASYNC_FLAGS));\n\tstate->custom_divisor = ss->custom_divisor;\n\tport->close_delay = close_delay;\n\tport->closing_wait = closing_wait;\n\ncheck_and_exit:\n\tif (tty_port_initialized(port)) {\n\t\tif (change_spd) {\n\t\t\t \n\t\t\tif (ss->flags & ASYNC_SPD_MASK)\n\t\t\t\tdev_warn_ratelimited(tty->dev, \"use of SPD flags is deprecated\\n\");\n\t\t\tchange_speed(tty, state, NULL);\n\t\t}\n\t} else\n\t\tretval = startup(tty, state);\n\ttty_unlock(tty);\n\treturn retval;\n}\n\n \nstatic int get_lsr_info(struct serial_state *info, unsigned int __user *value)\n{\n\tunsigned char status;\n\tunsigned int result;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tstatus = amiga_custom.serdatr;\n\tmb();\n\tlocal_irq_restore(flags);\n\tresult = ((status & SDR_TSRE) ? TIOCSER_TEMT : 0);\n\tif (copy_to_user(value, &result, sizeof(int)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n\nstatic int rs_tiocmget(struct tty_struct *tty)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tunsigned char control, status;\n\tunsigned long flags;\n\n\tif (tty_io_error(tty))\n\t\treturn -EIO;\n\n\tcontrol = info->MCR;\n\tlocal_irq_save(flags);\n\tstatus = ciab.pra;\n\tlocal_irq_restore(flags);\n\treturn    ((control & SER_RTS) ? TIOCM_RTS : 0)\n\t\t| ((control & SER_DTR) ? TIOCM_DTR : 0)\n\t\t| (!(status  & SER_DCD) ? TIOCM_CAR : 0)\n\t\t| (!(status  & SER_DSR) ? TIOCM_DSR : 0)\n\t\t| (!(status  & SER_CTS) ? TIOCM_CTS : 0);\n}\n\nstatic int rs_tiocmset(struct tty_struct *tty, unsigned int set,\n\t\t\t\t\t\tunsigned int clear)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (tty_io_error(tty))\n\t\treturn -EIO;\n\n\tlocal_irq_save(flags);\n\tif (set & TIOCM_RTS)\n\t\tinfo->MCR |= SER_RTS;\n\tif (set & TIOCM_DTR)\n\t\tinfo->MCR |= SER_DTR;\n\tif (clear & TIOCM_RTS)\n\t\tinfo->MCR &= ~SER_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tinfo->MCR &= ~SER_DTR;\n\trtsdtr_ctrl(info->MCR);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}\n\n \nstatic int rs_break(struct tty_struct *tty, int break_state)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tif (break_state == -1)\n\t  amiga_custom.adkcon = AC_SETCLR | AC_UARTBRK;\n\telse\n\t  amiga_custom.adkcon = AC_UARTBRK;\n\tmb();\n\tlocal_irq_restore(flags);\n\treturn 0;\n}\n\n \nstatic int rs_get_icount(struct tty_struct *tty,\n\t\t\t\tstruct serial_icounter_struct *icount)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tstruct async_icount cnow;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tcnow = info->icount;\n\tlocal_irq_restore(flags);\n\ticount->cts = cnow.cts;\n\ticount->dsr = cnow.dsr;\n\ticount->rng = cnow.rng;\n\ticount->dcd = cnow.dcd;\n\ticount->rx = cnow.rx;\n\ticount->tx = cnow.tx;\n\ticount->frame = cnow.frame;\n\ticount->overrun = cnow.overrun;\n\ticount->parity = cnow.parity;\n\ticount->brk = cnow.brk;\n\ticount->buf_overrun = cnow.buf_overrun;\n\n\treturn 0;\n}\n\nstatic int rs_ioctl(struct tty_struct *tty,\n\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tstruct async_icount cprev, cnow;\t \n\tvoid __user *argp = (void __user *)arg;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\tint ret;\n\n\tif ((cmd != TIOCSERCONFIG) &&\n\t    (cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {\n\t\tif (tty_io_error(tty))\n\t\t    return -EIO;\n\t}\n\n\tswitch (cmd) {\n\t\tcase TIOCSERCONFIG:\n\t\t\treturn 0;\n\n\t\tcase TIOCSERGETLSR:  \n\t\t\treturn get_lsr_info(info, argp);\n\n\t\t \n\t\tcase TIOCMIWAIT:\n\t\t\tlocal_irq_save(flags);\n\t\t\t \n\t\t\tcprev = info->icount;\n\t\t\tlocal_irq_restore(flags);\n\t\t\twhile (1) {\n\t\t\t\tprepare_to_wait(&info->tport.delta_msr_wait,\n\t\t\t\t\t\t&wait, TASK_INTERRUPTIBLE);\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t\tcnow = info->icount;  \n\t\t\t\tlocal_irq_restore(flags);\n\t\t\t\tif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr && \n\t\t\t\t    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {\n\t\t\t\t\tret = -EIO;  \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( ((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\n\t\t\t\t     ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\n\t\t\t\t     ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||\n\t\t\t\t     ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)) ) {\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tschedule();\n\t\t\t\t \n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcprev = cnow;\n\t\t\t}\n\t\t\tfinish_wait(&info->tport.delta_msr_wait, &wait);\n\t\t\treturn ret;\n\n\t\tdefault:\n\t\t\treturn -ENOIOCTLCMD;\n\t\t}\n\treturn 0;\n}\n\nstatic void rs_set_termios(struct tty_struct *tty, const struct ktermios *old_termios)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tunsigned long flags;\n\tunsigned int cflag = tty->termios.c_cflag;\n\n\tchange_speed(tty, info, old_termios);\n\n\t \n\tif ((old_termios->c_cflag & CBAUD) && !(cflag & CBAUD)) {\n\t\tinfo->MCR &= ~(SER_DTR|SER_RTS);\n\t\tlocal_irq_save(flags);\n\t\trtsdtr_ctrl(info->MCR);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\t \n\tif (!(old_termios->c_cflag & CBAUD) && (cflag & CBAUD)) {\n\t\tinfo->MCR |= SER_DTR;\n\t\tif (!C_CRTSCTS(tty) || !tty_throttled(tty))\n\t\t\tinfo->MCR |= SER_RTS;\n\t\tlocal_irq_save(flags);\n\t\trtsdtr_ctrl(info->MCR);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\t \n\tif ((old_termios->c_cflag & CRTSCTS) && !C_CRTSCTS(tty)) {\n\t\ttty->hw_stopped = false;\n\t\trs_start(tty);\n\t}\n\n#if 0\n\t \n\tif (!(old_termios->c_cflag & CLOCAL) && C_CLOCAL(tty))\n\t\twake_up_interruptible(&info->open_wait);\n#endif\n}\n\n \nstatic void rs_close(struct tty_struct *tty, struct file * filp)\n{\n\tstruct serial_state *state = tty->driver_data;\n\tstruct tty_port *port = &state->tport;\n\n\tif (tty_port_close_start(port, tty, filp) == 0)\n\t\treturn;\n\n\t \n\tstate->read_status_mask &= ~UART_LSR_DR;\n\tif (tty_port_initialized(port)) {\n\t         \n\t        amiga_custom.intena = IF_RBF;\n\t\tmb();\n\t\t \n\t\tamiga_custom.intreq = IF_RBF;\n\t\tmb();\n\n\t\t \n\t\trs_wait_until_sent(tty, state->timeout);\n\t}\n\tshutdown(tty, state);\n\trs_flush_buffer(tty);\n\t\t\n\ttty_ldisc_flush(tty);\n\tport->tty = NULL;\n\n\ttty_port_close_end(port, tty);\n}\n\n \nstatic void rs_wait_until_sent(struct tty_struct *tty, int timeout)\n{\n\tstruct serial_state *info = tty->driver_data;\n\tunsigned long orig_jiffies, char_time;\n\tint lsr;\n\n\torig_jiffies = jiffies;\n\n\t \n\tchar_time = (info->timeout - HZ/50) / XMIT_FIFO_SIZE;\n\tchar_time = char_time / 5;\n\tif (char_time == 0)\n\t\tchar_time = 1;\n\tif (timeout)\n\t  char_time = min_t(unsigned long, char_time, timeout);\n\t \n\tif (!timeout || timeout > 2*info->timeout)\n\t\ttimeout = 2*info->timeout;\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\n\tprintk(\"In rs_wait_until_sent(%d) check=%lu...\", timeout, char_time);\n\tprintk(\"jiff=%lu...\", jiffies);\n#endif\n\twhile(!((lsr = amiga_custom.serdatr) & SDR_TSRE)) {\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\n\t\tprintk(\"serdatr = %d (jiff=%lu)...\", lsr, jiffies);\n#endif\n\t\tmsleep_interruptible(jiffies_to_msecs(char_time));\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tif (timeout && time_after(jiffies, orig_jiffies + timeout))\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\n\tprintk(\"lsr = %d (jiff=%lu)...done\\n\", lsr, jiffies);\n#endif\n}\n\n \nstatic void rs_hangup(struct tty_struct *tty)\n{\n\tstruct serial_state *info = tty->driver_data;\n\n\trs_flush_buffer(tty);\n\tshutdown(tty, info);\n\tinfo->tport.count = 0;\n\ttty_port_set_active(&info->tport, false);\n\tinfo->tport.tty = NULL;\n\twake_up_interruptible(&info->tport.open_wait);\n}\n\n \nstatic int rs_open(struct tty_struct *tty, struct file * filp)\n{\n\tstruct tty_port *port = tty->port;\n\tstruct serial_state *info = container_of(port, struct serial_state,\n\t\t\ttport);\n\tint retval;\n\n\tport->count++;\n\tport->tty = tty;\n\ttty->driver_data = info;\n\n\tretval = startup(tty, info);\n\tif (retval) {\n\t\treturn retval;\n\t}\n\n\treturn tty_port_block_til_ready(port, tty, filp);\n}\n\n \n\nstatic inline void line_info(struct seq_file *m, int line,\n\t\tstruct serial_state *state)\n{\n\tchar\tstat_buf[30], control, status;\n\tunsigned long flags;\n\n\tseq_printf(m, \"%d: uart:amiga_builtin\", line);\n\n\tlocal_irq_save(flags);\n\tstatus = ciab.pra;\n\tcontrol = tty_port_initialized(&state->tport) ? state->MCR : status;\n\tlocal_irq_restore(flags);\n\n\tstat_buf[0] = 0;\n\tstat_buf[1] = 0;\n\tif(!(control & SER_RTS))\n\t\tstrcat(stat_buf, \"|RTS\");\n\tif(!(status & SER_CTS))\n\t\tstrcat(stat_buf, \"|CTS\");\n\tif(!(control & SER_DTR))\n\t\tstrcat(stat_buf, \"|DTR\");\n\tif(!(status & SER_DSR))\n\t\tstrcat(stat_buf, \"|DSR\");\n\tif(!(status & SER_DCD))\n\t\tstrcat(stat_buf, \"|CD\");\n\n\tif (state->quot)\n\t\tseq_printf(m, \" baud:%d\", state->baud_base / state->quot);\n\n\tseq_printf(m, \" tx:%d rx:%d\", state->icount.tx, state->icount.rx);\n\n\tif (state->icount.frame)\n\t\tseq_printf(m, \" fe:%d\", state->icount.frame);\n\n\tif (state->icount.parity)\n\t\tseq_printf(m, \" pe:%d\", state->icount.parity);\n\n\tif (state->icount.brk)\n\t\tseq_printf(m, \" brk:%d\", state->icount.brk);\n\n\tif (state->icount.overrun)\n\t\tseq_printf(m, \" oe:%d\", state->icount.overrun);\n\n\t \n\tseq_printf(m, \" %s\\n\", stat_buf+1);\n}\n\nstatic int rs_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"serinfo:1.0 driver:4.30\\n\");\n\tline_info(m, 0, &serial_state);\n\treturn 0;\n}\n\n \n\nstatic const struct tty_operations serial_ops = {\n\t.open = rs_open,\n\t.close = rs_close,\n\t.write = rs_write,\n\t.put_char = rs_put_char,\n\t.flush_chars = rs_flush_chars,\n\t.write_room = rs_write_room,\n\t.chars_in_buffer = rs_chars_in_buffer,\n\t.flush_buffer = rs_flush_buffer,\n\t.ioctl = rs_ioctl,\n\t.throttle = rs_throttle,\n\t.unthrottle = rs_unthrottle,\n\t.set_termios = rs_set_termios,\n\t.stop = rs_stop,\n\t.start = rs_start,\n\t.hangup = rs_hangup,\n\t.break_ctl = rs_break,\n\t.send_xchar = rs_send_xchar,\n\t.wait_until_sent = rs_wait_until_sent,\n\t.tiocmget = rs_tiocmget,\n\t.tiocmset = rs_tiocmset,\n\t.get_icount = rs_get_icount,\n\t.set_serial = set_serial_info,\n\t.get_serial = get_serial_info,\n\t.proc_show = rs_proc_show,\n};\n\nstatic bool amiga_carrier_raised(struct tty_port *port)\n{\n\treturn !(ciab.pra & SER_DCD);\n}\n\nstatic void amiga_dtr_rts(struct tty_port *port, bool active)\n{\n\tstruct serial_state *info = container_of(port, struct serial_state,\n\t\t\ttport);\n\tunsigned long flags;\n\n\tif (active)\n\t\tinfo->MCR |= SER_DTR|SER_RTS;\n\telse\n\t\tinfo->MCR &= ~(SER_DTR|SER_RTS);\n\n\tlocal_irq_save(flags);\n\trtsdtr_ctrl(info->MCR);\n\tlocal_irq_restore(flags);\n}\n\nstatic const struct tty_port_operations amiga_port_ops = {\n\t.carrier_raised = amiga_carrier_raised,\n\t.dtr_rts = amiga_dtr_rts,\n};\n\n \nstatic int __init amiga_serial_probe(struct platform_device *pdev)\n{\n\tstruct serial_state *state = &serial_state;\n\tstruct tty_driver *driver;\n\tunsigned long flags;\n\tint error;\n\n\tdriver = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW);\n\tif (IS_ERR(driver))\n\t\treturn PTR_ERR(driver);\n\n\t \n\n\tdriver->driver_name = \"amiserial\";\n\tdriver->name = \"ttyS\";\n\tdriver->major = TTY_MAJOR;\n\tdriver->minor_start = 64;\n\tdriver->type = TTY_DRIVER_TYPE_SERIAL;\n\tdriver->subtype = SERIAL_TYPE_NORMAL;\n\tdriver->init_termios = tty_std_termios;\n\tdriver->init_termios.c_cflag =\n\t\tB9600 | CS8 | CREAD | HUPCL | CLOCAL;\n\ttty_set_operations(driver, &serial_ops);\n\n\tmemset(state, 0, sizeof(*state));\n\tstate->port = (int)&amiga_custom.serdatr;  \n\ttty_port_init(&state->tport);\n\tstate->tport.ops = &amiga_port_ops;\n\ttty_port_link_device(&state->tport, driver, 0);\n\n\terror = tty_register_driver(driver);\n\tif (error)\n\t\tgoto fail_tty_driver_kref_put;\n\n\tprintk(KERN_INFO \"ttyS0 is the amiga builtin serial port\\n\");\n\n\t \n\n\tstate->baud_base = amiga_colorclock;\n\n\t \n\terror = request_irq(IRQ_AMIGA_TBE, ser_tx_int, 0, \"serial TX\", state);\n\tif (error)\n\t\tgoto fail_unregister;\n\n\terror = request_irq(IRQ_AMIGA_RBF, ser_rx_int, 0,\n\t\t\t    \"serial RX\", state);\n\tif (error)\n\t\tgoto fail_free_irq;\n\n\tlocal_irq_save(flags);\n\n\t \n\tamiga_custom.intena = IF_RBF | IF_TBE;\n\tmb();\n\n\t \n\tamiga_custom.intreq = IF_RBF | IF_TBE;\n\tmb();\n\n\tlocal_irq_restore(flags);\n\n\t \n\tciab.ddra |= (SER_DTR | SER_RTS);    \n\tciab.ddra &= ~(SER_DCD | SER_CTS | SER_DSR);   \n\n\tplatform_set_drvdata(pdev, state);\n\n\tserial_driver = driver;\n\n\treturn 0;\n\nfail_free_irq:\n\tfree_irq(IRQ_AMIGA_TBE, state);\nfail_unregister:\n\ttty_unregister_driver(driver);\nfail_tty_driver_kref_put:\n\ttty_port_destroy(&state->tport);\n\ttty_driver_kref_put(driver);\n\treturn error;\n}\n\nstatic int __exit amiga_serial_remove(struct platform_device *pdev)\n{\n\tstruct serial_state *state = platform_get_drvdata(pdev);\n\n\ttty_unregister_driver(serial_driver);\n\ttty_driver_kref_put(serial_driver);\n\ttty_port_destroy(&state->tport);\n\n\tfree_irq(IRQ_AMIGA_TBE, state);\n\tfree_irq(IRQ_AMIGA_RBF, state);\n\n\treturn 0;\n}\n\nstatic struct platform_driver amiga_serial_driver = {\n\t.remove = __exit_p(amiga_serial_remove),\n\t.driver   = {\n\t\t.name\t= \"amiga-serial\",\n\t},\n};\n\nmodule_platform_driver_probe(amiga_serial_driver, amiga_serial_probe);\n\n\n#if defined(CONFIG_SERIAL_CONSOLE) && !defined(MODULE)\n\n \n\nstatic void amiga_serial_putc(char c)\n{\n\tamiga_custom.serdat = (unsigned char)c | 0x100;\n\twhile (!(amiga_custom.serdatr & 0x2000))\n\t\tbarrier();\n}\n\n \nstatic void serial_console_write(struct console *co, const char *s,\n\t\t\t\tunsigned count)\n{\n\tunsigned short intena = amiga_custom.intenar;\n\n\tamiga_custom.intena = IF_TBE;\n\n\twhile (count--) {\n\t\tif (*s == '\\n')\n\t\t\tamiga_serial_putc('\\r');\n\t\tamiga_serial_putc(*s++);\n\t}\n\n\tamiga_custom.intena = IF_SETCLR | (intena & IF_TBE);\n}\n\nstatic struct tty_driver *serial_console_device(struct console *c, int *index)\n{\n\t*index = 0;\n\treturn serial_driver;\n}\n\nstatic struct console sercons = {\n\t.name =\t\t\"ttyS\",\n\t.write =\tserial_console_write,\n\t.device =\tserial_console_device,\n\t.flags =\tCON_PRINTBUFFER,\n\t.index =\t-1,\n};\n\n \nstatic int __init amiserial_console_init(void)\n{\n\tif (!MACH_IS_AMIGA)\n\t\treturn -ENODEV;\n\n\tregister_console(&sercons);\n\treturn 0;\n}\nconsole_initcall(amiserial_console_init);\n\n#endif  \n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:amiga-serial\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}