{
  "module_name": "goldfish.c",
  "hash_id": "76b7557680127c9197b998634d25f8ee6a332482cb2b506f06be1ac9ee896b06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/goldfish.c",
  "human_readable_source": "\n \n\n#include <linux/console.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/goldfish.h>\n#include <linux/mm.h>\n#include <linux/dma-mapping.h>\n#include <linux/serial_core.h>\n\n \n#define\tGOLDFISH_TTY_REG_BYTES_READY\t0x04\n#define\tGOLDFISH_TTY_REG_CMD\t\t0x08\n#define\tGOLDFISH_TTY_REG_DATA_PTR\t0x10\n#define\tGOLDFISH_TTY_REG_DATA_LEN\t0x14\n#define\tGOLDFISH_TTY_REG_DATA_PTR_HIGH\t0x18\n#define\tGOLDFISH_TTY_REG_VERSION\t0x20\n\n \n#define\tGOLDFISH_TTY_CMD_INT_DISABLE\t0\n#define\tGOLDFISH_TTY_CMD_INT_ENABLE\t1\n#define\tGOLDFISH_TTY_CMD_WRITE_BUFFER\t2\n#define\tGOLDFISH_TTY_CMD_READ_BUFFER\t3\n\nstruct goldfish_tty {\n\tstruct tty_port port;\n\tspinlock_t lock;\n\tvoid __iomem *base;\n\tu32 irq;\n\tint opencount;\n\tstruct console console;\n\tu32 version;\n\tstruct device *dev;\n};\n\nstatic DEFINE_MUTEX(goldfish_tty_lock);\nstatic struct tty_driver *goldfish_tty_driver;\nstatic u32 goldfish_tty_line_count = 8;\nstatic u32 goldfish_tty_current_line_count;\nstatic struct goldfish_tty *goldfish_ttys;\n\nstatic void do_rw_io(struct goldfish_tty *qtty,\n\t\t     unsigned long address,\n\t\t     unsigned int count,\n\t\t     int is_write)\n{\n\tunsigned long irq_flags;\n\tvoid __iomem *base = qtty->base;\n\n\tspin_lock_irqsave(&qtty->lock, irq_flags);\n\tgf_write_ptr((void *)address, base + GOLDFISH_TTY_REG_DATA_PTR,\n\t\t     base + GOLDFISH_TTY_REG_DATA_PTR_HIGH);\n\tgf_iowrite32(count, base + GOLDFISH_TTY_REG_DATA_LEN);\n\n\tif (is_write)\n\t\tgf_iowrite32(GOLDFISH_TTY_CMD_WRITE_BUFFER,\n\t\t       base + GOLDFISH_TTY_REG_CMD);\n\telse\n\t\tgf_iowrite32(GOLDFISH_TTY_CMD_READ_BUFFER,\n\t\t       base + GOLDFISH_TTY_REG_CMD);\n\n\tspin_unlock_irqrestore(&qtty->lock, irq_flags);\n}\n\nstatic void goldfish_tty_rw(struct goldfish_tty *qtty,\n\t\t\t    unsigned long addr,\n\t\t\t    unsigned int count,\n\t\t\t    int is_write)\n{\n\tdma_addr_t dma_handle;\n\tenum dma_data_direction dma_dir;\n\n\tdma_dir = (is_write ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\tif (qtty->version > 0) {\n\t\t \n\t\tunsigned long addr_end = addr + count;\n\n\t\twhile (addr < addr_end) {\n\t\t\tunsigned long pg_end = (addr & PAGE_MASK) + PAGE_SIZE;\n\t\t\tunsigned long next =\n\t\t\t\t\tpg_end < addr_end ? pg_end : addr_end;\n\t\t\tunsigned long avail = next - addr;\n\n\t\t\t \n\t\t\tdma_handle = dma_map_single(qtty->dev, (void *)addr,\n\t\t\t\t\t\t    avail, dma_dir);\n\n\t\t\tif (dma_mapping_error(qtty->dev, dma_handle)) {\n\t\t\t\tdev_err(qtty->dev, \"tty: DMA mapping error.\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdo_rw_io(qtty, dma_handle, avail, is_write);\n\n\t\t\t \n\t\t\tdma_unmap_single(qtty->dev, dma_handle, avail, dma_dir);\n\n\t\t\taddr += avail;\n\t\t}\n\t} else {\n\t\t \n\t\tdo_rw_io(qtty, addr, count, is_write);\n\t}\n}\n\nstatic void goldfish_tty_do_write(int line, const u8 *buf, unsigned int count)\n{\n\tstruct goldfish_tty *qtty = &goldfish_ttys[line];\n\tunsigned long address = (unsigned long)(void *)buf;\n\n\tgoldfish_tty_rw(qtty, address, count, 1);\n}\n\nstatic irqreturn_t goldfish_tty_interrupt(int irq, void *dev_id)\n{\n\tstruct goldfish_tty *qtty = dev_id;\n\tvoid __iomem *base = qtty->base;\n\tunsigned long address;\n\tunsigned char *buf;\n\tu32 count;\n\n\tcount = gf_ioread32(base + GOLDFISH_TTY_REG_BYTES_READY);\n\tif (count == 0)\n\t\treturn IRQ_NONE;\n\n\tcount = tty_prepare_flip_string(&qtty->port, &buf, count);\n\n\taddress = (unsigned long)(void *)buf;\n\tgoldfish_tty_rw(qtty, address, count, 0);\n\n\ttty_flip_buffer_push(&qtty->port);\n\treturn IRQ_HANDLED;\n}\n\nstatic int goldfish_tty_activate(struct tty_port *port, struct tty_struct *tty)\n{\n\tstruct goldfish_tty *qtty = container_of(port, struct goldfish_tty,\n\t\t\t\t\t\t\t\t\tport);\n\tgf_iowrite32(GOLDFISH_TTY_CMD_INT_ENABLE, qtty->base + GOLDFISH_TTY_REG_CMD);\n\treturn 0;\n}\n\nstatic void goldfish_tty_shutdown(struct tty_port *port)\n{\n\tstruct goldfish_tty *qtty = container_of(port, struct goldfish_tty,\n\t\t\t\t\t\t\t\t\tport);\n\tgf_iowrite32(GOLDFISH_TTY_CMD_INT_DISABLE, qtty->base + GOLDFISH_TTY_REG_CMD);\n}\n\nstatic int goldfish_tty_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct goldfish_tty *qtty = &goldfish_ttys[tty->index];\n\treturn tty_port_open(&qtty->port, tty, filp);\n}\n\nstatic void goldfish_tty_close(struct tty_struct *tty, struct file *filp)\n{\n\ttty_port_close(tty->port, tty, filp);\n}\n\nstatic void goldfish_tty_hangup(struct tty_struct *tty)\n{\n\ttty_port_hangup(tty->port);\n}\n\nstatic ssize_t goldfish_tty_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t\t  size_t count)\n{\n\tgoldfish_tty_do_write(tty->index, buf, count);\n\treturn count;\n}\n\nstatic unsigned int goldfish_tty_write_room(struct tty_struct *tty)\n{\n\treturn 0x10000;\n}\n\nstatic unsigned int goldfish_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct goldfish_tty *qtty = &goldfish_ttys[tty->index];\n\tvoid __iomem *base = qtty->base;\n\treturn gf_ioread32(base + GOLDFISH_TTY_REG_BYTES_READY);\n}\n\nstatic void goldfish_tty_console_write(struct console *co, const char *b,\n\t\t\t\t\t\t\t\tunsigned count)\n{\n\tgoldfish_tty_do_write(co->index, b, count);\n}\n\nstatic struct tty_driver *goldfish_tty_console_device(struct console *c,\n\t\t\t\t\t\t\t\tint *index)\n{\n\t*index = c->index;\n\treturn goldfish_tty_driver;\n}\n\nstatic int goldfish_tty_console_setup(struct console *co, char *options)\n{\n\tif ((unsigned)co->index >= goldfish_tty_line_count)\n\t\treturn -ENODEV;\n\tif (!goldfish_ttys[co->index].base)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic const struct tty_port_operations goldfish_port_ops = {\n\t.activate = goldfish_tty_activate,\n\t.shutdown = goldfish_tty_shutdown\n};\n\nstatic const struct tty_operations goldfish_tty_ops = {\n\t.open = goldfish_tty_open,\n\t.close = goldfish_tty_close,\n\t.hangup = goldfish_tty_hangup,\n\t.write = goldfish_tty_write,\n\t.write_room = goldfish_tty_write_room,\n\t.chars_in_buffer = goldfish_tty_chars_in_buffer,\n};\n\nstatic int goldfish_tty_create_driver(void)\n{\n\tint ret;\n\tstruct tty_driver *tty;\n\n\tgoldfish_ttys = kcalloc(goldfish_tty_line_count,\n\t\t\t\tsizeof(*goldfish_ttys),\n\t\t\t\tGFP_KERNEL);\n\tif (goldfish_ttys == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_goldfish_ttys_failed;\n\t}\n\ttty = tty_alloc_driver(goldfish_tty_line_count,\n\t\t\tTTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(tty)) {\n\t\tret = PTR_ERR(tty);\n\t\tgoto err_tty_alloc_driver_failed;\n\t}\n\ttty->driver_name = \"goldfish\";\n\ttty->name = \"ttyGF\";\n\ttty->type = TTY_DRIVER_TYPE_SERIAL;\n\ttty->subtype = SERIAL_TYPE_NORMAL;\n\ttty->init_termios = tty_std_termios;\n\ttty_set_operations(tty, &goldfish_tty_ops);\n\tret = tty_register_driver(tty);\n\tif (ret)\n\t\tgoto err_tty_register_driver_failed;\n\n\tgoldfish_tty_driver = tty;\n\treturn 0;\n\nerr_tty_register_driver_failed:\n\ttty_driver_kref_put(tty);\nerr_tty_alloc_driver_failed:\n\tkfree(goldfish_ttys);\n\tgoldfish_ttys = NULL;\nerr_alloc_goldfish_ttys_failed:\n\treturn ret;\n}\n\nstatic void goldfish_tty_delete_driver(void)\n{\n\ttty_unregister_driver(goldfish_tty_driver);\n\ttty_driver_kref_put(goldfish_tty_driver);\n\tgoldfish_tty_driver = NULL;\n\tkfree(goldfish_ttys);\n\tgoldfish_ttys = NULL;\n}\n\nstatic int goldfish_tty_probe(struct platform_device *pdev)\n{\n\tstruct goldfish_tty *qtty;\n\tint ret = -ENODEV;\n\tstruct resource *r;\n\tstruct device *ttydev;\n\tvoid __iomem *base;\n\tint irq;\n\tunsigned int line;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tpr_err(\"goldfish_tty: No MEM resource available!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbase = ioremap(r->start, 0x1000);\n\tif (!base) {\n\t\tpr_err(\"goldfish_tty: Unable to ioremap base!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_unmap;\n\t}\n\n\tmutex_lock(&goldfish_tty_lock);\n\n\tif (pdev->id == PLATFORM_DEVID_NONE)\n\t\tline = goldfish_tty_current_line_count;\n\telse\n\t\tline = pdev->id;\n\n\tif (line >= goldfish_tty_line_count) {\n\t\tpr_err(\"goldfish_tty: Reached maximum tty number of %d.\\n\",\n\t\t       goldfish_tty_current_line_count);\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\tif (goldfish_tty_current_line_count == 0) {\n\t\tret = goldfish_tty_create_driver();\n\t\tif (ret)\n\t\t\tgoto err_unlock;\n\t}\n\tgoldfish_tty_current_line_count++;\n\n\tqtty = &goldfish_ttys[line];\n\tspin_lock_init(&qtty->lock);\n\ttty_port_init(&qtty->port);\n\tqtty->port.ops = &goldfish_port_ops;\n\tqtty->base = base;\n\tqtty->irq = irq;\n\tqtty->dev = &pdev->dev;\n\n\t \n\tqtty->version = gf_ioread32(base + GOLDFISH_TTY_REG_VERSION);\n\n\t \n\tif (qtty->version > 0) {\n\t\t \n\t\tif (!pdev->dev.dma_mask)\n\t\t\tpdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;\n\t\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"No suitable DMA available.\\n\");\n\t\t\tgoto err_dec_line_count;\n\t\t}\n\t}\n\n\tgf_iowrite32(GOLDFISH_TTY_CMD_INT_DISABLE, base + GOLDFISH_TTY_REG_CMD);\n\n\tret = request_irq(irq, goldfish_tty_interrupt, IRQF_SHARED,\n\t\t\t  \"goldfish_tty\", qtty);\n\tif (ret) {\n\t\tpr_err(\"goldfish_tty: No IRQ available!\\n\");\n\t\tgoto err_dec_line_count;\n\t}\n\n\tttydev = tty_port_register_device(&qtty->port, goldfish_tty_driver,\n\t\t\t\t\t  line, &pdev->dev);\n\tif (IS_ERR(ttydev)) {\n\t\tret = PTR_ERR(ttydev);\n\t\tgoto err_tty_register_device_failed;\n\t}\n\n\tstrcpy(qtty->console.name, \"ttyGF\");\n\tqtty->console.write = goldfish_tty_console_write;\n\tqtty->console.device = goldfish_tty_console_device;\n\tqtty->console.setup = goldfish_tty_console_setup;\n\tqtty->console.flags = CON_PRINTBUFFER;\n\tqtty->console.index = line;\n\tregister_console(&qtty->console);\n\tplatform_set_drvdata(pdev, qtty);\n\n\tmutex_unlock(&goldfish_tty_lock);\n\treturn 0;\n\nerr_tty_register_device_failed:\n\tfree_irq(irq, qtty);\nerr_dec_line_count:\n\ttty_port_destroy(&qtty->port);\n\tgoldfish_tty_current_line_count--;\n\tif (goldfish_tty_current_line_count == 0)\n\t\tgoldfish_tty_delete_driver();\nerr_unlock:\n\tmutex_unlock(&goldfish_tty_lock);\nerr_unmap:\n\tiounmap(base);\n\treturn ret;\n}\n\nstatic int goldfish_tty_remove(struct platform_device *pdev)\n{\n\tstruct goldfish_tty *qtty = platform_get_drvdata(pdev);\n\n\tmutex_lock(&goldfish_tty_lock);\n\n\tunregister_console(&qtty->console);\n\ttty_unregister_device(goldfish_tty_driver, qtty->console.index);\n\tiounmap(qtty->base);\n\tqtty->base = NULL;\n\tfree_irq(qtty->irq, qtty);\n\ttty_port_destroy(&qtty->port);\n\tgoldfish_tty_current_line_count--;\n\tif (goldfish_tty_current_line_count == 0)\n\t\tgoldfish_tty_delete_driver();\n\tmutex_unlock(&goldfish_tty_lock);\n\treturn 0;\n}\n\n#ifdef CONFIG_GOLDFISH_TTY_EARLY_CONSOLE\nstatic void gf_early_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tgf_iowrite32(ch, port->membase);\n}\n\nstatic void gf_early_write(struct console *con, const char *s, unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, gf_early_console_putchar);\n}\n\nstatic int __init gf_earlycon_setup(struct earlycon_device *device,\n\t\t\t\t    const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = gf_early_write;\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(early_gf_tty, \"google,goldfish-tty\", gf_earlycon_setup);\n#endif\n\nstatic const struct of_device_id goldfish_tty_of_match[] = {\n\t{ .compatible = \"google,goldfish-tty\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, goldfish_tty_of_match);\n\nstatic struct platform_driver goldfish_tty_platform_driver = {\n\t.probe = goldfish_tty_probe,\n\t.remove = goldfish_tty_remove,\n\t.driver = {\n\t\t.name = \"goldfish_tty\",\n\t\t.of_match_table = goldfish_tty_of_match,\n\t}\n};\n\nmodule_platform_driver(goldfish_tty_platform_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}