{
  "module_name": "mips_ejtag_fdc.c",
  "hash_id": "b2b1f10bb31e65f854ae8388f9b648c6bc44db73e359eaa49ae3820090cec16c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/mips_ejtag_fdc.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/completion.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/kgdb.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/uaccess.h>\n\n#include <asm/cdmm.h>\n#include <asm/irq.h>\n\n \n#define REG_FDACSR\t0x00\t \n#define REG_FDCFG\t0x08\t \n#define REG_FDSTAT\t0x10\t \n#define REG_FDRX\t0x18\t \n#define REG_FDTX(N)\t(0x20+0x8*(N))\t \n\n \n\n#define REG_FDCFG_TXINTTHRES_SHIFT\t18\n#define REG_FDCFG_TXINTTHRES\t\t(0x3 << REG_FDCFG_TXINTTHRES_SHIFT)\n#define REG_FDCFG_TXINTTHRES_DISABLED\t(0x0 << REG_FDCFG_TXINTTHRES_SHIFT)\n#define REG_FDCFG_TXINTTHRES_EMPTY\t(0x1 << REG_FDCFG_TXINTTHRES_SHIFT)\n#define REG_FDCFG_TXINTTHRES_NOTFULL\t(0x2 << REG_FDCFG_TXINTTHRES_SHIFT)\n#define REG_FDCFG_TXINTTHRES_NEAREMPTY\t(0x3 << REG_FDCFG_TXINTTHRES_SHIFT)\n#define REG_FDCFG_RXINTTHRES_SHIFT\t16\n#define REG_FDCFG_RXINTTHRES\t\t(0x3 << REG_FDCFG_RXINTTHRES_SHIFT)\n#define REG_FDCFG_RXINTTHRES_DISABLED\t(0x0 << REG_FDCFG_RXINTTHRES_SHIFT)\n#define REG_FDCFG_RXINTTHRES_FULL\t(0x1 << REG_FDCFG_RXINTTHRES_SHIFT)\n#define REG_FDCFG_RXINTTHRES_NOTEMPTY\t(0x2 << REG_FDCFG_RXINTTHRES_SHIFT)\n#define REG_FDCFG_RXINTTHRES_NEARFULL\t(0x3 << REG_FDCFG_RXINTTHRES_SHIFT)\n#define REG_FDCFG_TXFIFOSIZE_SHIFT\t8\n#define REG_FDCFG_TXFIFOSIZE\t\t(0xff << REG_FDCFG_TXFIFOSIZE_SHIFT)\n#define REG_FDCFG_RXFIFOSIZE_SHIFT\t0\n#define REG_FDCFG_RXFIFOSIZE\t\t(0xff << REG_FDCFG_RXFIFOSIZE_SHIFT)\n\n#define REG_FDSTAT_TXCOUNT_SHIFT\t24\n#define REG_FDSTAT_TXCOUNT\t\t(0xff << REG_FDSTAT_TXCOUNT_SHIFT)\n#define REG_FDSTAT_RXCOUNT_SHIFT\t16\n#define REG_FDSTAT_RXCOUNT\t\t(0xff << REG_FDSTAT_RXCOUNT_SHIFT)\n#define REG_FDSTAT_RXCHAN_SHIFT\t\t4\n#define REG_FDSTAT_RXCHAN\t\t(0xf << REG_FDSTAT_RXCHAN_SHIFT)\n#define REG_FDSTAT_RXE\t\t\tBIT(3)\t \n#define REG_FDSTAT_RXF\t\t\tBIT(2)\t \n#define REG_FDSTAT_TXE\t\t\tBIT(1)\t \n#define REG_FDSTAT_TXF\t\t\tBIT(0)\t \n\n \n#define CONSOLE_CHANNEL      1\n\n#define NUM_TTY_CHANNELS     16\n\n#define RX_BUF_SIZE 1024\n\n \n#define FDC_TTY_POLL (HZ / 50)\n\nstruct mips_ejtag_fdc_tty;\n\n \nstruct mips_ejtag_fdc_tty_port {\n\tstruct tty_port\t\t\t port;\n\tstruct mips_ejtag_fdc_tty\t*driver;\n\traw_spinlock_t\t\t\t rx_lock;\n\tvoid\t\t\t\t*rx_buf;\n\tspinlock_t\t\t\t xmit_lock;\n\tunsigned int\t\t\t xmit_cnt;\n\tunsigned int\t\t\t xmit_head;\n\tunsigned int\t\t\t xmit_tail;\n\tstruct completion\t\t xmit_empty;\n};\n\n \nstruct mips_ejtag_fdc_tty {\n\tstruct device\t\t\t*dev;\n\tstruct tty_driver\t\t*driver;\n\tunsigned int\t\t\t cpu;\n\tchar\t\t\t\t fdc_name[16];\n\tchar\t\t\t\t driver_name[16];\n\tstruct mips_ejtag_fdc_tty_port\t ports[NUM_TTY_CHANNELS];\n\twait_queue_head_t\t\t waitqueue;\n\traw_spinlock_t\t\t\t lock;\n\tstruct task_struct\t\t*thread;\n\n\tvoid __iomem\t\t\t*reg;\n\tu8\t\t\t\t tx_fifo;\n\n\tunsigned int\t\t\t xmit_size;\n\tatomic_t\t\t\t xmit_total;\n\tunsigned int\t\t\t xmit_next;\n\tbool\t\t\t\t xmit_full;\n\n\tint\t\t\t\t irq;\n\tbool\t\t\t\t removing;\n\tstruct timer_list\t\t poll_timer;\n\n#ifdef CONFIG_MAGIC_SYSRQ\n\tbool\t\t\t\t sysrq_pressed;\n#endif\n};\n\n \n\nstatic inline void mips_ejtag_fdc_write(struct mips_ejtag_fdc_tty *priv,\n\t\t\t\t\tunsigned int offs, unsigned int data)\n{\n\t__raw_writel(data, priv->reg + offs);\n}\n\nstatic inline unsigned int mips_ejtag_fdc_read(struct mips_ejtag_fdc_tty *priv,\n\t\t\t\t\t       unsigned int offs)\n{\n\treturn __raw_readl(priv->reg + offs);\n}\n\n \n\n \nstruct fdc_word {\n\tu32\t\tword;\n\tunsigned int\tbytes;\n};\n\n \n\n \nstatic struct fdc_word mips_ejtag_fdc_encode(const char **ptrs,\n\t\t\t\t\t     unsigned int *sizes,\n\t\t\t\t\t     unsigned int ranges)\n{\n\tstruct fdc_word word = { 0, 0 };\n\tconst char **ptrs_end = ptrs + ranges;\n\n\tfor (; ptrs < ptrs_end; ++ptrs) {\n\t\tconst char *ptr = *(ptrs++);\n\t\tconst char *end = ptr + *(sizes++);\n\n\t\tfor (; ptr < end; ++ptr) {\n\t\t\tword.word |= (u8)*ptr << (8*word.bytes);\n\t\t\t++word.bytes;\n\t\t\tif (word.bytes == 4)\n\t\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\t \n\tswitch (word.bytes) {\n\tcase 4:\n\t\t \n\t\tif ((word.word >> 8) != 0x808080 &&\n\t\t    (word.word >> 16) != 0x8181 &&\n\t\t    (word.word >> 24) != 0x82)\n\t\t\tbreak;\n\t\t \n\t\tword.bytes = 3;\n\t\tword.word &= 0x00ffffff;\n\t\tfallthrough;\n\tcase 3:\n\t\t \n\t\tword.word |= 0x82000000;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tword.word |= 0x81810000;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tword.word |= 0x80808000;\n\t\tbreak;\n\t}\n\treturn word;\n}\n\nstatic unsigned int mips_ejtag_fdc_decode(u32 word, char *buf)\n{\n\tbuf[0] = (u8)word;\n\tword >>= 8;\n\tif (word == 0x808080)\n\t\treturn 1;\n\tbuf[1] = (u8)word;\n\tword >>= 8;\n\tif (word == 0x8181)\n\t\treturn 2;\n\tbuf[2] = (u8)word;\n\tword >>= 8;\n\tif (word == 0x82)\n\t\treturn 3;\n\tbuf[3] = (u8)word;\n\treturn 4;\n}\n\n \n\n \nstruct mips_ejtag_fdc_console {\n\tstruct console\t\t cons;\n\tstruct tty_driver\t*tty_drv;\n\traw_spinlock_t\t\t lock;\n\tbool\t\t\t initialised;\n\tvoid __iomem\t\t*regs[NR_CPUS];\n};\n\n \nstatic void mips_ejtag_fdc_console_write(struct console *c, const char *s,\n\t\t\t\t\t unsigned int count)\n{\n\tstruct mips_ejtag_fdc_console *cons =\n\t\tcontainer_of(c, struct mips_ejtag_fdc_console, cons);\n\tvoid __iomem *regs;\n\tstruct fdc_word word;\n\tunsigned long flags;\n\tunsigned int i, buf_len, cpu;\n\tbool done_cr = false;\n\tchar buf[4];\n\tconst char *buf_ptr = buf;\n\t \n\tu8 inc[4];\n\n\tlocal_irq_save(flags);\n\tcpu = smp_processor_id();\n\tregs = cons->regs[cpu];\n\t \n\tif (!regs) {\n\t\tregs = mips_cdmm_early_probe(0xfd);\n\t\tcons->regs[cpu] = regs;\n\t}\n\t \n\tif (IS_ERR(regs))\n\t\tgoto out;\n\twhile (count) {\n\t\t \n\t\tfor (buf_len = 0, i = 0; buf_len < 4 && i < count; ++buf_len) {\n\t\t\tif (s[i] == '\\n' && !done_cr) {\n\t\t\t\tbuf[buf_len] = '\\r';\n\t\t\t\tdone_cr = true;\n\t\t\t} else {\n\t\t\t\tbuf[buf_len] = s[i];\n\t\t\t\tdone_cr = false;\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tinc[buf_len] = i;\n\t\t}\n\t\tword = mips_ejtag_fdc_encode(&buf_ptr, &buf_len, 1);\n\t\tcount -= inc[word.bytes - 1];\n\t\ts += inc[word.bytes - 1];\n\n\t\t \n\t\twhile (__raw_readl(regs + REG_FDSTAT) & REG_FDSTAT_TXF)\n\t\t\t;\n\t\t__raw_writel(word.word, regs + REG_FDTX(c->index));\n\t}\nout:\n\tlocal_irq_restore(flags);\n}\n\nstatic struct tty_driver *mips_ejtag_fdc_console_device(struct console *c,\n\t\t\t\t\t\t\tint *index)\n{\n\tstruct mips_ejtag_fdc_console *cons =\n\t\tcontainer_of(c, struct mips_ejtag_fdc_console, cons);\n\n\t*index = c->index;\n\treturn cons->tty_drv;\n}\n\n \nstatic int __init mips_ejtag_fdc_console_init(struct mips_ejtag_fdc_console *c)\n{\n\tvoid __iomem *regs;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&c->lock, flags);\n\t \n\tif (c->initialised)\n\t\tgoto out;\n\t \n\tregs = mips_cdmm_early_probe(0xfd);\n\tif (IS_ERR(regs)) {\n\t\tret = PTR_ERR(regs);\n\t\tgoto out;\n\t}\n\n\tc->initialised = true;\n\tc->regs[smp_processor_id()] = regs;\n\tregister_console(&c->cons);\nout:\n\traw_spin_unlock_irqrestore(&c->lock, flags);\n\treturn ret;\n}\n\nstatic struct mips_ejtag_fdc_console mips_ejtag_fdc_con = {\n\t.cons\t= {\n\t\t.name\t= \"fdc\",\n\t\t.write\t= mips_ejtag_fdc_console_write,\n\t\t.device\t= mips_ejtag_fdc_console_device,\n\t\t.flags\t= CON_PRINTBUFFER,\n\t\t.index\t= -1,\n\t},\n\t.lock\t= __RAW_SPIN_LOCK_UNLOCKED(mips_ejtag_fdc_con.lock),\n};\n\n \n\n \nstatic unsigned int mips_ejtag_fdc_put_chan(struct mips_ejtag_fdc_tty *priv,\n\t\t\t\t\t    unsigned int chan)\n{\n\tstruct mips_ejtag_fdc_tty_port *dport;\n\tstruct tty_struct *tty;\n\tconst char *ptrs[2];\n\tunsigned int sizes[2] = { 0 };\n\tstruct fdc_word word = { .bytes = 0 };\n\tunsigned long flags;\n\n\tdport = &priv->ports[chan];\n\tspin_lock(&dport->xmit_lock);\n\tif (dport->xmit_cnt) {\n\t\tptrs[0] = dport->port.xmit_buf + dport->xmit_tail;\n\t\tsizes[0] = min_t(unsigned int,\n\t\t\t\t priv->xmit_size - dport->xmit_tail,\n\t\t\t\t dport->xmit_cnt);\n\t\tptrs[1] = dport->port.xmit_buf;\n\t\tsizes[1] = dport->xmit_cnt - sizes[0];\n\t\tword = mips_ejtag_fdc_encode(ptrs, sizes, 1 + !!sizes[1]);\n\n\t\tdev_dbg(priv->dev, \"%s%u: out %08x: \\\"%*pE%*pE\\\"\\n\",\n\t\t\tpriv->driver_name, chan, word.word,\n\t\t\tmin_t(int, word.bytes, sizes[0]), ptrs[0],\n\t\t\tmax_t(int, 0, word.bytes - sizes[0]), ptrs[1]);\n\n\t\tlocal_irq_save(flags);\n\t\t \n\t\tif (mips_ejtag_fdc_read(priv, REG_FDSTAT) & REG_FDSTAT_TXF)\n\t\t\tword.bytes = 0;\n\t\telse\n\t\t\tmips_ejtag_fdc_write(priv, REG_FDTX(chan), word.word);\n\t\tlocal_irq_restore(flags);\n\n\t\tdport->xmit_cnt -= word.bytes;\n\t\tif (!dport->xmit_cnt) {\n\t\t\t \n\t\t\tdport->xmit_head = 0;\n\t\t\tdport->xmit_tail = 0;\n\t\t\tcomplete(&dport->xmit_empty);\n\t\t} else {\n\t\t\tdport->xmit_tail += word.bytes;\n\t\t\tif (dport->xmit_tail >= priv->xmit_size)\n\t\t\t\tdport->xmit_tail -= priv->xmit_size;\n\t\t}\n\t\tatomic_sub(word.bytes, &priv->xmit_total);\n\t}\n\tspin_unlock(&dport->xmit_lock);\n\n\t \n\tif (sizes[0] && word.bytes) {\n\t\ttty = tty_port_tty_get(&dport->port);\n\t\tif (tty) {\n\t\t\ttty_wakeup(tty);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t}\n\n\treturn word.bytes;\n}\n\n \nstatic int mips_ejtag_fdc_put(void *arg)\n{\n\tstruct mips_ejtag_fdc_tty *priv = arg;\n\tstruct mips_ejtag_fdc_tty_port *dport;\n\tunsigned int ret;\n\tu32 cfg;\n\n\t__set_current_state(TASK_RUNNING);\n\twhile (!kthread_should_stop()) {\n\t\t \n\t\twait_event_interruptible(priv->waitqueue,\n\t\t\t\t\t atomic_read(&priv->xmit_total) ||\n\t\t\t\t\t kthread_should_stop());\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\t \n\t\traw_spin_lock_irq(&priv->lock);\n\t\tif (mips_ejtag_fdc_read(priv, REG_FDSTAT) & REG_FDSTAT_TXF) {\n\t\t\tpriv->xmit_full = true;\n\t\t\tif (priv->irq >= 0) {\n\t\t\t\t \n\t\t\t\tcfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\n\t\t\t\tcfg &= ~REG_FDCFG_TXINTTHRES;\n\t\t\t\tcfg |= REG_FDCFG_TXINTTHRES_NOTFULL;\n\t\t\t\tmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\n\t\t\t}\n\t\t}\n\t\traw_spin_unlock_irq(&priv->lock);\n\t\twait_event_interruptible(priv->waitqueue,\n\t\t\t\t\t !(mips_ejtag_fdc_read(priv, REG_FDSTAT)\n\t\t\t\t\t   & REG_FDSTAT_TXF) ||\n\t\t\t\t\t kthread_should_stop());\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\t \n\t\tfor (;;) {\n\t\t\tdport = &priv->ports[priv->xmit_next];\n\t\t\tspin_lock(&dport->xmit_lock);\n\t\t\tret = dport->xmit_cnt;\n\t\t\tspin_unlock(&dport->xmit_lock);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\t++priv->xmit_next;\n\t\t\tif (priv->xmit_next >= NUM_TTY_CHANNELS)\n\t\t\t\tpriv->xmit_next = 0;\n\t\t}\n\n\t\t \n\t\tret = mips_ejtag_fdc_put_chan(priv, priv->xmit_next);\n\n\t\t \n\t\tif (ret) {\n\t\t\t++priv->xmit_next;\n\t\t\tif (priv->xmit_next >= NUM_TTY_CHANNELS)\n\t\t\t\tpriv->xmit_next = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void mips_ejtag_fdc_handle(struct mips_ejtag_fdc_tty *priv)\n{\n\tstruct mips_ejtag_fdc_tty_port *dport;\n\tunsigned int stat, channel, data, cfg, i, flipped;\n\tint len;\n\tchar buf[4];\n\n\tfor (;;) {\n\t\t \n\t\tstat = mips_ejtag_fdc_read(priv, REG_FDSTAT);\n\t\tif (stat & REG_FDSTAT_RXE)\n\t\t\tbreak;\n\t\tchannel = (stat & REG_FDSTAT_RXCHAN) >> REG_FDSTAT_RXCHAN_SHIFT;\n\t\tdport = &priv->ports[channel];\n\n\t\t \n\t\traw_spin_lock(&dport->rx_lock);\n\t\tdata = mips_ejtag_fdc_read(priv, REG_FDRX);\n\n\t\tlen = mips_ejtag_fdc_decode(data, buf);\n\t\tdev_dbg(priv->dev, \"%s%u: in  %08x: \\\"%*pE\\\"\\n\",\n\t\t\tpriv->driver_name, channel, data, len, buf);\n\n\t\tflipped = 0;\n\t\tfor (i = 0; i < len; ++i) {\n#ifdef CONFIG_MAGIC_SYSRQ\n#ifdef CONFIG_MIPS_EJTAG_FDC_KGDB\n\t\t\t \n\t\t\tif (channel == CONFIG_MIPS_EJTAG_FDC_KGDB_CHAN) {\n\t\t\t\tif (buf[i] == '\\x03') {  \n\t\t\t\t\thandle_sysrq('g');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\t \n\t\t\tif (channel == mips_ejtag_fdc_con.cons.index) {\n\t\t\t\tif (buf[i] == '\\x0f') {\t \n\t\t\t\t\tpriv->sysrq_pressed =\n\t\t\t\t\t\t!priv->sysrq_pressed;\n\t\t\t\t\tif (priv->sysrq_pressed)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (priv->sysrq_pressed) {\n\t\t\t\t\thandle_sysrq(buf[i]);\n\t\t\t\t\tpriv->sysrq_pressed = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n#endif  \n\n\t\t\t \n\t\t\tif (!dport->rx_buf)\n\t\t\t\tcontinue;\n\n\t\t\tflipped += tty_insert_flip_char(&dport->port, buf[i],\n\t\t\t\t\t\t\tTTY_NORMAL);\n\t\t}\n\t\tif (flipped)\n\t\t\ttty_flip_buffer_push(&dport->port);\n\n\t\traw_spin_unlock(&dport->rx_lock);\n\t}\n\n\t \n\traw_spin_lock(&priv->lock);\n\tif (priv->xmit_full && !(stat & REG_FDSTAT_TXF)) {\n\t\tpriv->xmit_full = false;\n\n\t\t \n\t\tcfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\n\t\tcfg &= ~REG_FDCFG_TXINTTHRES;\n\t\tcfg |= REG_FDCFG_TXINTTHRES_DISABLED;\n\t\tmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\n\n\t\t \n\t\twake_up_interruptible(&priv->waitqueue);\n\t}\n\traw_spin_unlock(&priv->lock);\n}\n\n \nstatic irqreturn_t mips_ejtag_fdc_isr(int irq, void *dev_id)\n{\n\tstruct mips_ejtag_fdc_tty *priv = dev_id;\n\n\t \n\tif (smp_processor_id() != priv->cpu)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (!(read_c0_cause() & CAUSEF_FDCI))\n\t\treturn IRQ_NONE;\n\n\tmips_ejtag_fdc_handle(priv);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void mips_ejtag_fdc_tty_timer(struct timer_list *t)\n{\n\tstruct mips_ejtag_fdc_tty *priv = from_timer(priv, t, poll_timer);\n\n\tmips_ejtag_fdc_handle(priv);\n\tif (!priv->removing)\n\t\tmod_timer(&priv->poll_timer, jiffies + FDC_TTY_POLL);\n}\n\n \n\nstatic int mips_ejtag_fdc_tty_port_activate(struct tty_port *port,\n\t\t\t\t\t    struct tty_struct *tty)\n{\n\tstruct mips_ejtag_fdc_tty_port *dport =\n\t\tcontainer_of(port, struct mips_ejtag_fdc_tty_port, port);\n\tvoid *rx_buf;\n\n\t \n\tif (tty_port_alloc_xmit_buf(port) < 0)\n\t\tgoto err;\n\n\t \n\trx_buf = kzalloc(RX_BUF_SIZE, GFP_KERNEL);\n\tif (!rx_buf)\n\t\tgoto err_free_xmit;\n\n\traw_spin_lock_irq(&dport->rx_lock);\n\tdport->rx_buf = rx_buf;\n\traw_spin_unlock_irq(&dport->rx_lock);\n\n\treturn 0;\nerr_free_xmit:\n\ttty_port_free_xmit_buf(port);\nerr:\n\treturn -ENOMEM;\n}\n\nstatic void mips_ejtag_fdc_tty_port_shutdown(struct tty_port *port)\n{\n\tstruct mips_ejtag_fdc_tty_port *dport =\n\t\tcontainer_of(port, struct mips_ejtag_fdc_tty_port, port);\n\tstruct mips_ejtag_fdc_tty *priv = dport->driver;\n\tvoid *rx_buf;\n\tunsigned int count;\n\n\tspin_lock(&dport->xmit_lock);\n\tcount = dport->xmit_cnt;\n\tspin_unlock(&dport->xmit_lock);\n\tif (count) {\n\t\t \n\t\twake_up_interruptible(&priv->waitqueue);\n\t\twait_for_completion(&dport->xmit_empty);\n\t}\n\n\t \n\traw_spin_lock_irq(&dport->rx_lock);\n\trx_buf = dport->rx_buf;\n\tdport->rx_buf = NULL;\n\traw_spin_unlock_irq(&dport->rx_lock);\n\t \n\tkfree(rx_buf);\n\n\t \n\ttty_port_free_xmit_buf(port);\n}\n\nstatic const struct tty_port_operations mips_ejtag_fdc_tty_port_ops = {\n\t.activate\t= mips_ejtag_fdc_tty_port_activate,\n\t.shutdown\t= mips_ejtag_fdc_tty_port_shutdown,\n};\n\n \n\nstatic int mips_ejtag_fdc_tty_install(struct tty_driver *driver,\n\t\t\t\t      struct tty_struct *tty)\n{\n\tstruct mips_ejtag_fdc_tty *priv = driver->driver_state;\n\n\ttty->driver_data = &priv->ports[tty->index];\n\treturn tty_port_install(&priv->ports[tty->index].port, driver, tty);\n}\n\nstatic int mips_ejtag_fdc_tty_open(struct tty_struct *tty, struct file *filp)\n{\n\treturn tty_port_open(tty->port, tty, filp);\n}\n\nstatic void mips_ejtag_fdc_tty_close(struct tty_struct *tty, struct file *filp)\n{\n\treturn tty_port_close(tty->port, tty, filp);\n}\n\nstatic void mips_ejtag_fdc_tty_hangup(struct tty_struct *tty)\n{\n\tstruct mips_ejtag_fdc_tty_port *dport = tty->driver_data;\n\tstruct mips_ejtag_fdc_tty *priv = dport->driver;\n\n\t \n\tspin_lock(&dport->xmit_lock);\n\tif (dport->xmit_cnt) {\n\t\tatomic_sub(dport->xmit_cnt, &priv->xmit_total);\n\t\tdport->xmit_cnt = 0;\n\t\tdport->xmit_head = 0;\n\t\tdport->xmit_tail = 0;\n\t\tcomplete(&dport->xmit_empty);\n\t}\n\tspin_unlock(&dport->xmit_lock);\n\n\ttty_port_hangup(tty->port);\n}\n\nstatic ssize_t mips_ejtag_fdc_tty_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t\t\tsize_t total)\n{\n\tint count, block;\n\tstruct mips_ejtag_fdc_tty_port *dport = tty->driver_data;\n\tstruct mips_ejtag_fdc_tty *priv = dport->driver;\n\n\t \n\tspin_lock(&dport->xmit_lock);\n\t \n\ttotal = min_t(size_t, total, priv->xmit_size - dport->xmit_cnt);\n\tatomic_add(total, &priv->xmit_total);\n\tdport->xmit_cnt += total;\n\t \n\tfor (count = total; count; count -= block) {\n\t\tblock = min(count, (int)(priv->xmit_size - dport->xmit_head));\n\t\tmemcpy(dport->port.xmit_buf + dport->xmit_head, buf, block);\n\t\tdport->xmit_head += block;\n\t\tif (dport->xmit_head >= priv->xmit_size)\n\t\t\tdport->xmit_head -= priv->xmit_size;\n\t\tbuf += block;\n\t}\n\tcount = dport->xmit_cnt;\n\t \n\tif (count)\n\t\treinit_completion(&dport->xmit_empty);\n\tspin_unlock(&dport->xmit_lock);\n\n\t \n\tif (total)\n\t\twake_up_interruptible(&priv->waitqueue);\n\treturn total;\n}\n\nstatic unsigned int mips_ejtag_fdc_tty_write_room(struct tty_struct *tty)\n{\n\tstruct mips_ejtag_fdc_tty_port *dport = tty->driver_data;\n\tstruct mips_ejtag_fdc_tty *priv = dport->driver;\n\tunsigned int room;\n\n\t \n\tspin_lock(&dport->xmit_lock);\n\troom = priv->xmit_size - dport->xmit_cnt;\n\tspin_unlock(&dport->xmit_lock);\n\n\treturn room;\n}\n\nstatic unsigned int mips_ejtag_fdc_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct mips_ejtag_fdc_tty_port *dport = tty->driver_data;\n\tunsigned int chars;\n\n\t \n\tspin_lock(&dport->xmit_lock);\n\tchars = dport->xmit_cnt;\n\tspin_unlock(&dport->xmit_lock);\n\n\treturn chars;\n}\n\nstatic const struct tty_operations mips_ejtag_fdc_tty_ops = {\n\t.install\t\t= mips_ejtag_fdc_tty_install,\n\t.open\t\t\t= mips_ejtag_fdc_tty_open,\n\t.close\t\t\t= mips_ejtag_fdc_tty_close,\n\t.hangup\t\t\t= mips_ejtag_fdc_tty_hangup,\n\t.write\t\t\t= mips_ejtag_fdc_tty_write,\n\t.write_room\t\t= mips_ejtag_fdc_tty_write_room,\n\t.chars_in_buffer\t= mips_ejtag_fdc_tty_chars_in_buffer,\n};\n\nint __weak get_c0_fdc_int(void)\n{\n\treturn -1;\n}\n\nstatic int mips_ejtag_fdc_tty_probe(struct mips_cdmm_device *dev)\n{\n\tint ret, nport;\n\tstruct mips_ejtag_fdc_tty_port *dport;\n\tstruct mips_ejtag_fdc_tty *priv;\n\tstruct tty_driver *driver;\n\tunsigned int cfg, tx_fifo;\n\n\tpriv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->cpu = dev->cpu;\n\tpriv->dev = &dev->dev;\n\tmips_cdmm_set_drvdata(dev, priv);\n\tatomic_set(&priv->xmit_total, 0);\n\traw_spin_lock_init(&priv->lock);\n\n\tpriv->reg = devm_ioremap(priv->dev, dev->res.start,\n\t\t\t\t\t resource_size(&dev->res));\n\tif (!priv->reg) {\n\t\tdev_err(priv->dev, \"ioremap failed for resource %pR\\n\",\n\t\t\t&dev->res);\n\t\treturn -ENOMEM;\n\t}\n\n\tcfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\n\ttx_fifo = (cfg & REG_FDCFG_TXFIFOSIZE) >> REG_FDCFG_TXFIFOSIZE_SHIFT;\n\t \n\tcfg &= ~(REG_FDCFG_TXINTTHRES | REG_FDCFG_RXINTTHRES);\n\tcfg |= REG_FDCFG_TXINTTHRES_DISABLED;\n\tcfg |= REG_FDCFG_RXINTTHRES_DISABLED;\n\tmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\n\n\t \n\tpriv->xmit_size = min(tx_fifo * 4, (unsigned int)UART_XMIT_SIZE);\n\n\tdriver = tty_alloc_driver(NUM_TTY_CHANNELS, TTY_DRIVER_REAL_RAW);\n\tif (IS_ERR(driver))\n\t\treturn PTR_ERR(driver);\n\tpriv->driver = driver;\n\n\tdriver->driver_name = \"ejtag_fdc\";\n\tsnprintf(priv->fdc_name, sizeof(priv->fdc_name), \"ttyFDC%u\", dev->cpu);\n\tsnprintf(priv->driver_name, sizeof(priv->driver_name), \"%sc\",\n\t\t priv->fdc_name);\n\tdriver->name = priv->driver_name;\n\tdriver->major = 0;  \n\tdriver->minor_start = 0;\n\tdriver->type = TTY_DRIVER_TYPE_SERIAL;\n\tdriver->subtype = SERIAL_TYPE_NORMAL;\n\tdriver->init_termios = tty_std_termios;\n\tdriver->init_termios.c_cflag |= CLOCAL;\n\tdriver->driver_state = priv;\n\n\ttty_set_operations(driver, &mips_ejtag_fdc_tty_ops);\n\tfor (nport = 0; nport < NUM_TTY_CHANNELS; nport++) {\n\t\tdport = &priv->ports[nport];\n\t\tdport->driver = priv;\n\t\ttty_port_init(&dport->port);\n\t\tdport->port.ops = &mips_ejtag_fdc_tty_port_ops;\n\t\traw_spin_lock_init(&dport->rx_lock);\n\t\tspin_lock_init(&dport->xmit_lock);\n\t\t \n\t\tinit_completion(&dport->xmit_empty);\n\t\tcomplete(&dport->xmit_empty);\n\t}\n\n\t \n\tmips_ejtag_fdc_con.regs[dev->cpu] = priv->reg;\n\tif (dev->cpu == 0)\n\t\tmips_ejtag_fdc_con.tty_drv = driver;\n\n\tinit_waitqueue_head(&priv->waitqueue);\n\t \n\tpriv->thread = kthread_run_on_cpu(mips_ejtag_fdc_put, priv,\n\t\t\t\t\t  dev->cpu, \"ttyFDC/%u\");\n\tif (IS_ERR(priv->thread)) {\n\t\tret = PTR_ERR(priv->thread);\n\t\tdev_err(priv->dev, \"Couldn't create kthread (%d)\\n\", ret);\n\t\tgoto err_destroy_ports;\n\t}\n\n\t \n\tpriv->irq = get_c0_fdc_int();\n\n\t \n\tif (priv->irq >= 0) {\n\t\t \n\t\tret = devm_request_irq(priv->dev, priv->irq, mips_ejtag_fdc_isr,\n\t\t\t\t       IRQF_PERCPU | IRQF_SHARED |\n\t\t\t\t       IRQF_NO_THREAD | IRQF_COND_SUSPEND,\n\t\t\t\t       priv->fdc_name, priv);\n\t\tif (ret)\n\t\t\tpriv->irq = -1;\n\t}\n\tif (priv->irq >= 0) {\n\t\t \n\t\traw_spin_lock_irq(&priv->lock);\n\t\tcfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\n\t\tcfg &= ~REG_FDCFG_RXINTTHRES;\n\t\tcfg |= REG_FDCFG_RXINTTHRES_NOTEMPTY;\n\t\tmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\n\t\traw_spin_unlock_irq(&priv->lock);\n\t} else {\n\t\t \n\t\ttimer_setup(&priv->poll_timer, mips_ejtag_fdc_tty_timer,\n\t\t\t    TIMER_PINNED);\n\t\tpriv->poll_timer.expires = jiffies + FDC_TTY_POLL;\n\t\t \n\t\tadd_timer_on(&priv->poll_timer, dev->cpu);\n\n\t\tdev_info(priv->dev, \"No usable IRQ, polling enabled\\n\");\n\t}\n\n\tret = tty_register_driver(driver);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"Couldn't install tty driver (%d)\\n\", ret);\n\t\tgoto err_stop_irq;\n\t}\n\n\treturn 0;\n\nerr_stop_irq:\n\tif (priv->irq >= 0) {\n\t\traw_spin_lock_irq(&priv->lock);\n\t\tcfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\n\t\t \n\t\tcfg &= ~(REG_FDCFG_TXINTTHRES | REG_FDCFG_RXINTTHRES);\n\t\tcfg |= REG_FDCFG_TXINTTHRES_DISABLED;\n\t\tcfg |= REG_FDCFG_RXINTTHRES_DISABLED;\n\t\tmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\n\t\traw_spin_unlock_irq(&priv->lock);\n\t} else {\n\t\tpriv->removing = true;\n\t\tdel_timer_sync(&priv->poll_timer);\n\t}\n\tkthread_stop(priv->thread);\nerr_destroy_ports:\n\tif (dev->cpu == 0)\n\t\tmips_ejtag_fdc_con.tty_drv = NULL;\n\tfor (nport = 0; nport < NUM_TTY_CHANNELS; nport++) {\n\t\tdport = &priv->ports[nport];\n\t\ttty_port_destroy(&dport->port);\n\t}\n\ttty_driver_kref_put(priv->driver);\n\treturn ret;\n}\n\nstatic int mips_ejtag_fdc_tty_cpu_down(struct mips_cdmm_device *dev)\n{\n\tstruct mips_ejtag_fdc_tty *priv = mips_cdmm_get_drvdata(dev);\n\tunsigned int cfg;\n\n\tif (priv->irq >= 0) {\n\t\traw_spin_lock_irq(&priv->lock);\n\t\tcfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\n\t\t \n\t\tcfg &= ~(REG_FDCFG_TXINTTHRES | REG_FDCFG_RXINTTHRES);\n\t\tcfg |= REG_FDCFG_TXINTTHRES_DISABLED;\n\t\tcfg |= REG_FDCFG_RXINTTHRES_DISABLED;\n\t\tmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\n\t\traw_spin_unlock_irq(&priv->lock);\n\t} else {\n\t\tpriv->removing = true;\n\t\tdel_timer_sync(&priv->poll_timer);\n\t}\n\tkthread_stop(priv->thread);\n\n\treturn 0;\n}\n\nstatic int mips_ejtag_fdc_tty_cpu_up(struct mips_cdmm_device *dev)\n{\n\tstruct mips_ejtag_fdc_tty *priv = mips_cdmm_get_drvdata(dev);\n\tunsigned int cfg;\n\tint ret = 0;\n\n\tif (priv->irq >= 0) {\n\t\t \n\t\traw_spin_lock_irq(&priv->lock);\n\t\tcfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\n\t\tcfg &= ~(REG_FDCFG_TXINTTHRES | REG_FDCFG_RXINTTHRES);\n\t\tcfg |= REG_FDCFG_TXINTTHRES_DISABLED;\n\t\tcfg |= REG_FDCFG_RXINTTHRES_NOTEMPTY;\n\t\tmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\n\t\traw_spin_unlock_irq(&priv->lock);\n\t} else {\n\t\t \n\t\tpriv->removing = false;\n\t\tadd_timer_on(&priv->poll_timer, dev->cpu);\n\t}\n\n\t \n\t \n\tpriv->thread = kthread_run_on_cpu(mips_ejtag_fdc_put, priv,\n\t\t\t\t\t  dev->cpu, \"ttyFDC/%u\");\n\tif (IS_ERR(priv->thread)) {\n\t\tret = PTR_ERR(priv->thread);\n\t\tdev_err(priv->dev, \"Couldn't re-create kthread (%d)\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\treturn ret;\n}\n\nstatic const struct mips_cdmm_device_id mips_ejtag_fdc_tty_ids[] = {\n\t{ .type = 0xfd },\n\t{ }\n};\n\nstatic struct mips_cdmm_driver mips_ejtag_fdc_tty_driver = {\n\t.drv\t\t= {\n\t\t.name\t= \"mips_ejtag_fdc\",\n\t},\n\t.probe\t\t= mips_ejtag_fdc_tty_probe,\n\t.cpu_down\t= mips_ejtag_fdc_tty_cpu_down,\n\t.cpu_up\t\t= mips_ejtag_fdc_tty_cpu_up,\n\t.id_table\t= mips_ejtag_fdc_tty_ids,\n};\nbuiltin_mips_cdmm_driver(mips_ejtag_fdc_tty_driver);\n\nstatic int __init mips_ejtag_fdc_init_console(void)\n{\n\treturn mips_ejtag_fdc_console_init(&mips_ejtag_fdc_con);\n}\nconsole_initcall(mips_ejtag_fdc_init_console);\n\n#ifdef CONFIG_MIPS_EJTAG_FDC_EARLYCON\nstatic struct mips_ejtag_fdc_console mips_ejtag_fdc_earlycon = {\n\t.cons\t= {\n\t\t.name\t= \"early_fdc\",\n\t\t.write\t= mips_ejtag_fdc_console_write,\n\t\t.flags\t= CON_PRINTBUFFER | CON_BOOT,\n\t\t.index\t= CONSOLE_CHANNEL,\n\t},\n\t.lock\t= __RAW_SPIN_LOCK_UNLOCKED(mips_ejtag_fdc_earlycon.lock),\n};\n\nint __init setup_early_fdc_console(void)\n{\n\treturn mips_ejtag_fdc_console_init(&mips_ejtag_fdc_earlycon);\n}\n#endif\n\n#ifdef CONFIG_MIPS_EJTAG_FDC_KGDB\n\n \nstatic unsigned int kgdbfdc_rbuflen;\nstatic unsigned int kgdbfdc_rpos;\nstatic char kgdbfdc_rbuf[4];\n\n \nstatic unsigned int kgdbfdc_wbuflen;\nstatic char kgdbfdc_wbuf[4];\n\nstatic void __iomem *kgdbfdc_setup(void)\n{\n\tvoid __iomem *regs;\n\tunsigned int cpu;\n\n\t \n\tcpu = smp_processor_id();\n\tregs = mips_ejtag_fdc_con.regs[cpu];\n\t \n\tif (!regs) {\n\t\tregs = mips_cdmm_early_probe(0xfd);\n\t\tmips_ejtag_fdc_con.regs[cpu] = regs;\n\t}\n\t \n\tif (IS_ERR(regs))\n\t\treturn regs;\n\n\treturn regs;\n}\n\n \nstatic int kgdbfdc_read_char(void)\n{\n\tunsigned int stat, channel, data;\n\tvoid __iomem *regs;\n\n\t \n\tif (kgdbfdc_rpos >= kgdbfdc_rbuflen) {\n\t\tkgdbfdc_rpos = 0;\n\t\tkgdbfdc_rbuflen = 0;\n\n\t\tregs = kgdbfdc_setup();\n\t\tif (IS_ERR(regs))\n\t\t\treturn NO_POLL_CHAR;\n\n\t\t \n\t\tdo {\n\t\t\tstat = __raw_readl(regs + REG_FDSTAT);\n\n\t\t\t \n\t\t\tif (stat & REG_FDSTAT_RXE)\n\t\t\t\treturn NO_POLL_CHAR;\n\n\t\t\t \n\t\t\tchannel = (stat & REG_FDSTAT_RXCHAN) >>\n\t\t\t\t\tREG_FDSTAT_RXCHAN_SHIFT;\n\t\t\tdata = __raw_readl(regs + REG_FDRX);\n\t\t} while (channel != CONFIG_MIPS_EJTAG_FDC_KGDB_CHAN);\n\n\t\t \n\t\tkgdbfdc_rbuflen = mips_ejtag_fdc_decode(data, kgdbfdc_rbuf);\n\t}\n\tpr_devel(\"kgdbfdc r %c\\n\", kgdbfdc_rbuf[kgdbfdc_rpos]);\n\treturn kgdbfdc_rbuf[kgdbfdc_rpos++];\n}\n\n \nstatic void kgdbfdc_push_one(void)\n{\n\tconst char *bufs[1] = { kgdbfdc_wbuf };\n\tstruct fdc_word word;\n\tvoid __iomem *regs;\n\tunsigned int i;\n\n\t \n\tword = mips_ejtag_fdc_encode(bufs, &kgdbfdc_wbuflen, 1);\n\t \n\tkgdbfdc_wbuflen -= word.bytes;\n\tfor (i = 0; i < kgdbfdc_wbuflen; ++i)\n\t\tkgdbfdc_wbuf[i] = kgdbfdc_wbuf[i + word.bytes];\n\n\tregs = kgdbfdc_setup();\n\tif (IS_ERR(regs))\n\t\treturn;\n\n\t \n\twhile (__raw_readl(regs + REG_FDSTAT) & REG_FDSTAT_TXF)\n\t\t;\n\t__raw_writel(word.word,\n\t\t     regs + REG_FDTX(CONFIG_MIPS_EJTAG_FDC_KGDB_CHAN));\n}\n\n \nstatic void kgdbfdc_flush(void)\n{\n\twhile (kgdbfdc_wbuflen)\n\t\tkgdbfdc_push_one();\n}\n\n \nstatic void kgdbfdc_write_char(u8 chr)\n{\n\tpr_devel(\"kgdbfdc w %c\\n\", chr);\n\tkgdbfdc_wbuf[kgdbfdc_wbuflen++] = chr;\n\tif (kgdbfdc_wbuflen >= sizeof(kgdbfdc_wbuf))\n\t\tkgdbfdc_push_one();\n}\n\nstatic struct kgdb_io kgdbfdc_io_ops = {\n\t.name\t\t= \"kgdbfdc\",\n\t.read_char\t= kgdbfdc_read_char,\n\t.write_char\t= kgdbfdc_write_char,\n\t.flush\t\t= kgdbfdc_flush,\n};\n\nstatic int __init kgdbfdc_init(void)\n{\n\tkgdb_register_io_module(&kgdbfdc_io_ops);\n\treturn 0;\n}\nearly_initcall(kgdbfdc_init);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}