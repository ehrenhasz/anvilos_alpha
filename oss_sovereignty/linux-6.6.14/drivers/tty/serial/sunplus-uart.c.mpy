{
  "module_name": "sunplus-uart.c",
  "hash_id": "5aa032fdc1bdce6a962e305de02b266e44d6baaeeb992899e03e14bc1f9b2820",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sunplus-uart.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/serial_core.h>\n#include <linux/serial_reg.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <asm/irq.h>\n\n \n#define SUP_UART_DATA\t\t\t0x00\n#define SUP_UART_LSR\t\t\t0x04\n#define SUP_UART_MSR\t\t\t0x08\n#define SUP_UART_LCR\t\t\t0x0C\n#define SUP_UART_MCR\t\t\t0x10\n#define SUP_UART_DIV_L\t\t\t0x14\n#define SUP_UART_DIV_H\t\t\t0x18\n#define SUP_UART_ISC\t\t\t0x1C\n#define SUP_UART_TX_RESIDUE\t\t0x20\n#define SUP_UART_RX_RESIDUE\t\t0x24\n\n \n#define SUP_UART_LSR_BC\t\t\tBIT(5)  \n#define SUP_UART_LSR_FE\t\t\tBIT(4)  \n#define SUP_UART_LSR_OE\t\t\tBIT(3)  \n#define SUP_UART_LSR_PE\t\t\tBIT(2)  \n#define SUP_UART_LSR_RX\t\t\tBIT(1)  \n#define SUP_UART_LSR_TX\t\t\tBIT(0)  \n#define SUP_UART_LSR_TX_NOT_FULL\t1\n#define SUP_UART_LSR_BRK_ERROR_BITS\tGENMASK(5, 2)\n\n \n#define SUP_UART_LCR_SBC\t\tBIT(5)  \n\n \n#define SUP_UART_MCR_RI\t\t\tBIT(3)  \n#define SUP_UART_MCR_DCD\t\tBIT(2)  \n\n \n#define SUP_UART_ISC_RXM\t\tBIT(5)  \n#define SUP_UART_ISC_TXM\t\tBIT(4)  \n#define SUP_UART_ISC_RX\t\t\tBIT(1)  \n#define SUP_UART_ISC_TX\t\t\tBIT(0)  \n\n#define SUP_DUMMY_READ\t\t\tBIT(16)  \n#define SUP_UART_NR\t\t\t5\n\nstruct sunplus_uart_port {\n\tstruct uart_port port;\n\tstruct clk *clk;\n\tstruct reset_control *rstc;\n};\n\nstatic void sp_uart_put_char(struct uart_port *port, unsigned int ch)\n{\n\twritel(ch, port->membase + SUP_UART_DATA);\n}\n\nstatic u32 sunplus_tx_buf_not_full(struct uart_port *port)\n{\n\tunsigned int lsr = readl(port->membase + SUP_UART_LSR);\n\n\treturn (lsr & SUP_UART_LSR_TX) ? SUP_UART_LSR_TX_NOT_FULL : 0;\n}\n\nstatic unsigned int sunplus_tx_empty(struct uart_port *port)\n{\n\tunsigned int lsr = readl(port->membase + SUP_UART_LSR);\n\n\treturn (lsr & UART_LSR_TEMT) ? TIOCSER_TEMT : 0;\n}\n\nstatic void sunplus_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tunsigned int mcr = readl(port->membase + SUP_UART_MCR);\n\n\tif (mctrl & TIOCM_DTR)\n\t\tmcr |= UART_MCR_DTR;\n\telse\n\t\tmcr &= ~UART_MCR_DTR;\n\n\tif (mctrl & TIOCM_RTS)\n\t\tmcr |= UART_MCR_RTS;\n\telse\n\t\tmcr &= ~UART_MCR_RTS;\n\n\tif (mctrl & TIOCM_CAR)\n\t\tmcr |= SUP_UART_MCR_DCD;\n\telse\n\t\tmcr &= ~SUP_UART_MCR_DCD;\n\n\tif (mctrl & TIOCM_RI)\n\t\tmcr |= SUP_UART_MCR_RI;\n\telse\n\t\tmcr &= ~SUP_UART_MCR_RI;\n\n\tif (mctrl & TIOCM_LOOP)\n\t\tmcr |= UART_MCR_LOOP;\n\telse\n\t\tmcr &= ~UART_MCR_LOOP;\n\n\twritel(mcr, port->membase + SUP_UART_MCR);\n}\n\nstatic unsigned int sunplus_get_mctrl(struct uart_port *port)\n{\n\tunsigned int mcr, ret = 0;\n\n\tmcr = readl(port->membase + SUP_UART_MCR);\n\n\tif (mcr & UART_MCR_DTR)\n\t\tret |= TIOCM_DTR;\n\n\tif (mcr & UART_MCR_RTS)\n\t\tret |= TIOCM_RTS;\n\n\tif (mcr & SUP_UART_MCR_DCD)\n\t\tret |= TIOCM_CAR;\n\n\tif (mcr & SUP_UART_MCR_RI)\n\t\tret |= TIOCM_RI;\n\n\tif (mcr & UART_MCR_LOOP)\n\t\tret |= TIOCM_LOOP;\n\n\treturn ret;\n}\n\nstatic void sunplus_stop_tx(struct uart_port *port)\n{\n\tunsigned int isc;\n\n\tisc = readl(port->membase + SUP_UART_ISC);\n\tisc &= ~SUP_UART_ISC_TXM;\n\twritel(isc, port->membase + SUP_UART_ISC);\n}\n\nstatic void sunplus_start_tx(struct uart_port *port)\n{\n\tunsigned int isc;\n\n\tisc = readl(port->membase + SUP_UART_ISC);\n\tisc |= SUP_UART_ISC_TXM;\n\twritel(isc, port->membase + SUP_UART_ISC);\n}\n\nstatic void sunplus_stop_rx(struct uart_port *port)\n{\n\tunsigned int isc;\n\n\tisc = readl(port->membase + SUP_UART_ISC);\n\tisc &= ~SUP_UART_ISC_RXM;\n\twritel(isc, port->membase + SUP_UART_ISC);\n}\n\nstatic void sunplus_break_ctl(struct uart_port *port, int ctl)\n{\n\tunsigned long flags;\n\tunsigned int lcr;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tlcr = readl(port->membase + SUP_UART_LCR);\n\n\tif (ctl)\n\t\tlcr |= SUP_UART_LCR_SBC;  \n\telse\n\t\tlcr &= ~SUP_UART_LCR_SBC;  \n\n\twritel(lcr, port->membase + SUP_UART_LCR);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void transmit_chars(struct uart_port *port)\n{\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\tif (port->x_char) {\n\t\tsp_uart_put_char(port, port->x_char);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\tsunplus_stop_tx(port);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tsp_uart_put_char(port, xmit->buf[xmit->tail]);\n\t\tuart_xmit_advance(port, 1);\n\t\tif (uart_circ_empty(xmit))\n\t\t\tbreak;\n\t} while (sunplus_tx_buf_not_full(port));\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (uart_circ_empty(xmit))\n\t\tsunplus_stop_tx(port);\n}\n\nstatic void receive_chars(struct uart_port *port)\n{\n\tunsigned int lsr = readl(port->membase + SUP_UART_LSR);\n\tu8 ch, flag;\n\n\tdo {\n\t\tch = readl(port->membase + SUP_UART_DATA);\n\t\tflag = TTY_NORMAL;\n\t\tport->icount.rx++;\n\n\t\tif (unlikely(lsr & SUP_UART_LSR_BRK_ERROR_BITS)) {\n\t\t\tif (lsr & SUP_UART_LSR_BC) {\n\t\t\t\tlsr &= ~(SUP_UART_LSR_FE | SUP_UART_LSR_PE);\n\t\t\t\tport->icount.brk++;\n\t\t\t\tflag = TTY_BREAK;\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tgoto ignore_char;\n\t\t\t} else if (lsr & SUP_UART_LSR_PE) {\n\t\t\t\tport->icount.parity++;\n\t\t\t\tflag = TTY_PARITY;\n\t\t\t} else if (lsr & SUP_UART_LSR_FE) {\n\t\t\t\tport->icount.frame++;\n\t\t\t\tflag = TTY_FRAME;\n\t\t\t}\n\n\t\t\tif (lsr & SUP_UART_LSR_OE)\n\t\t\t\tport->icount.overrun++;\n\t\t}\n\n\t\tif (port->ignore_status_mask & SUP_DUMMY_READ)\n\t\t\tgoto ignore_char;\n\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tgoto ignore_char;\n\n\t\tuart_insert_char(port, lsr, SUP_UART_LSR_OE, ch, flag);\n\nignore_char:\n\t\tlsr = readl(port->membase + SUP_UART_LSR);\n\t} while (lsr & SUP_UART_LSR_RX);\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic irqreturn_t sunplus_uart_irq(int irq, void *args)\n{\n\tstruct uart_port *port = args;\n\tunsigned int isc;\n\n\tspin_lock(&port->lock);\n\n\tisc = readl(port->membase + SUP_UART_ISC);\n\n\tif (isc & SUP_UART_ISC_RX)\n\t\treceive_chars(port);\n\n\tif (isc & SUP_UART_ISC_TX)\n\t\ttransmit_chars(port);\n\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sunplus_startup(struct uart_port *port)\n{\n\tunsigned long flags;\n\tunsigned int isc = 0;\n\tint ret;\n\n\tret = request_irq(port->irq, sunplus_uart_irq, 0, \"sunplus_uart\", port);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\t \n\tisc |= SUP_UART_ISC_RXM;\n\twritel(isc, port->membase + SUP_UART_ISC);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn 0;\n}\n\nstatic void sunplus_shutdown(struct uart_port *port)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\t \n\twritel(0, port->membase + SUP_UART_ISC);  \n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tfree_irq(port->irq, port);\n}\n\nstatic void sunplus_set_termios(struct uart_port *port,\n\t\t\t\tstruct ktermios *termios,\n\t\t\t\tconst struct ktermios *oldtermios)\n{\n\tu32 ext, div, div_l, div_h, baud, lcr;\n\tu32 clk = port->uartclk;\n\tunsigned long flags;\n\n\tbaud = uart_get_baud_rate(port, termios, oldtermios, 0, port->uartclk / 16);\n\n\t \n\tclk += baud >> 1;\n\tdiv = clk / baud;\n\text = div & 0x0F;\n\tdiv = (div >> 4) - 1;\n\tdiv_l = (div & 0xFF) | (ext << 12);\n\tdiv_h = div >> 8;\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tlcr = UART_LCR_WLEN5;\n\t\tbreak;\n\tcase CS6:\n\t\tlcr = UART_LCR_WLEN6;\n\t\tbreak;\n\tcase CS7:\n\t\tlcr = UART_LCR_WLEN7;\n\t\tbreak;\n\tdefault:\n\t\tlcr = UART_LCR_WLEN8;\n\t\tbreak;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tlcr |= UART_LCR_STOP;\n\n\tif (termios->c_cflag & PARENB) {\n\t\tlcr |= UART_LCR_PARITY;\n\n\t\tif (!(termios->c_cflag & PARODD))\n\t\t\tlcr |= UART_LCR_EPAR;\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tport->read_status_mask = 0;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= SUP_UART_LSR_PE | SUP_UART_LSR_FE;\n\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tport->read_status_mask |= SUP_UART_LSR_BC;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= SUP_UART_LSR_FE | SUP_UART_LSR_PE;\n\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= SUP_UART_LSR_BC;\n\n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= SUP_UART_LSR_OE;\n\t}\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0) {\n\t\tport->ignore_status_mask |= SUP_DUMMY_READ;\n\t\t \n\t\twritel(0, port->membase + SUP_UART_RX_RESIDUE);\n\t}\n\n\t \n\twritel(div_h, port->membase + SUP_UART_DIV_H);\n\twritel(div_l, port->membase + SUP_UART_DIV_L);\n\twritel(lcr, port->membase + SUP_UART_LCR);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void sunplus_set_ldisc(struct uart_port *port, struct ktermios *termios)\n{\n\tint new = termios->c_line;\n\n\tif (new == N_PPS)\n\t\tport->flags |= UPF_HARDPPS_CD;\n\telse\n\t\tport->flags &= ~UPF_HARDPPS_CD;\n}\n\nstatic const char *sunplus_type(struct uart_port *port)\n{\n\treturn port->type == PORT_SUNPLUS ? \"sunplus_uart\" : NULL;\n}\n\nstatic void sunplus_config_port(struct uart_port *port, int type)\n{\n\tif (type & UART_CONFIG_TYPE)\n\t\tport->type = PORT_SUNPLUS;\n}\n\nstatic int sunplus_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_SUNPLUS)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n#if defined(CONFIG_SERIAL_SUNPLUS_CONSOLE) || defined(CONFIG_CONSOLE_POLL)\nstatic void wait_for_xmitr(struct uart_port *port)\n{\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = readl_poll_timeout_atomic(port->membase + SUP_UART_LSR, val,\n\t\t\t\t\t(val & SUP_UART_LSR_TX), 1, 10000);\n\n\tif (ret == -ETIMEDOUT) {\n\t\tdev_err(port->dev, \"Timeout waiting while UART TX FULL\\n\");\n\t\treturn;\n\t}\n}\n#endif\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic void sunplus_poll_put_char(struct uart_port *port, unsigned char data)\n{\n\twait_for_xmitr(port);\n\tsp_uart_put_char(port, data);\n}\n\nstatic int sunplus_poll_get_char(struct uart_port *port)\n{\n\tunsigned int lsr = readl(port->membase + SUP_UART_LSR);\n\n\tif (!(lsr & SUP_UART_LSR_RX))\n\t\treturn NO_POLL_CHAR;\n\n\treturn readl(port->membase + SUP_UART_DATA);\n}\n#endif\n\nstatic const struct uart_ops sunplus_uart_ops = {\n\t.tx_empty\t= sunplus_tx_empty,\n\t.set_mctrl\t= sunplus_set_mctrl,\n\t.get_mctrl\t= sunplus_get_mctrl,\n\t.stop_tx\t= sunplus_stop_tx,\n\t.start_tx\t= sunplus_start_tx,\n\t.stop_rx\t= sunplus_stop_rx,\n\t.break_ctl\t= sunplus_break_ctl,\n\t.startup\t= sunplus_startup,\n\t.shutdown\t= sunplus_shutdown,\n\t.set_termios\t= sunplus_set_termios,\n\t.set_ldisc\t= sunplus_set_ldisc,\n\t.type\t\t= sunplus_type,\n\t.config_port\t= sunplus_config_port,\n\t.verify_port\t= sunplus_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_put_char\t= sunplus_poll_put_char,\n\t.poll_get_char\t= sunplus_poll_get_char,\n#endif\n};\n\n#ifdef CONFIG_SERIAL_SUNPLUS_CONSOLE\nstatic struct sunplus_uart_port *sunplus_console_ports[SUP_UART_NR];\n\nstatic void sunplus_uart_console_putchar(struct uart_port *port,\n\t\t\t\t\t unsigned char ch)\n{\n\twait_for_xmitr(port);\n\tsp_uart_put_char(port, ch);\n}\n\nstatic void sunplus_console_write(struct console *co,\n\t\t\t\t  const char *s,\n\t\t\t\t  unsigned int count)\n{\n\tunsigned long flags;\n\tint locked = 1;\n\n\tlocal_irq_save(flags);\n\n\tif (sunplus_console_ports[co->index]->port.sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock(&sunplus_console_ports[co->index]->port.lock);\n\telse\n\t\tspin_lock(&sunplus_console_ports[co->index]->port.lock);\n\n\tuart_console_write(&sunplus_console_ports[co->index]->port, s, count,\n\t\t\t   sunplus_uart_console_putchar);\n\n\tif (locked)\n\t\tspin_unlock(&sunplus_console_ports[co->index]->port.lock);\n\n\tlocal_irq_restore(flags);\n}\n\nstatic int __init sunplus_console_setup(struct console *co, char *options)\n{\n\tstruct sunplus_uart_port *sup;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index < 0 || co->index >= SUP_UART_NR)\n\t\treturn -EINVAL;\n\n\tsup = sunplus_console_ports[co->index];\n\tif (!sup)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&sup->port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver sunplus_uart_driver;\nstatic struct console sunplus_uart_console = {\n\t.name\t\t= \"ttySUP\",\n\t.write\t\t= sunplus_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= sunplus_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &sunplus_uart_driver\n};\n\n#define\tSERIAL_SUNPLUS_CONSOLE\t(&sunplus_uart_console)\n#else\n#define\tSERIAL_SUNPLUS_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver sunplus_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"sunplus_uart\",\n\t.dev_name\t= \"ttySUP\",\n\t.major\t\t= TTY_MAJOR,\n\t.minor\t\t= 64,\n\t.nr\t\t= SUP_UART_NR,\n\t.cons\t\t= SERIAL_SUNPLUS_CONSOLE,\n};\n\nstatic void sunplus_uart_disable_unprepare(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic void sunplus_uart_reset_control_assert(void *data)\n{\n\treset_control_assert(data);\n}\n\nstatic int sunplus_uart_probe(struct platform_device *pdev)\n{\n\tstruct sunplus_uart_port *sup;\n\tstruct uart_port *port;\n\tstruct resource *res;\n\tint ret, irq;\n\n\tpdev->id = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\n\tif (pdev->id < 0 || pdev->id >= SUP_UART_NR)\n\t\treturn -EINVAL;\n\n\tsup = devm_kzalloc(&pdev->dev, sizeof(*sup), GFP_KERNEL);\n\tif (!sup)\n\t\treturn -ENOMEM;\n\n\tsup->clk = devm_clk_get_optional(&pdev->dev, NULL);\n\tif (IS_ERR(sup->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sup->clk), \"clk not found\\n\");\n\n\tret = clk_prepare_enable(sup->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&pdev->dev, sunplus_uart_disable_unprepare, sup->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tsup->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(sup->rstc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sup->rstc), \"rstc not found\\n\");\n\n\tport = &sup->port;\n\n\tport->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(port->membase))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(port->membase), \"membase not found\\n\");\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tport->mapbase = res->start;\n\tport->uartclk = clk_get_rate(sup->clk);\n\tport->line = pdev->id;\n\tport->irq = irq;\n\tport->dev = &pdev->dev;\n\tport->iotype = UPIO_MEM;\n\tport->ops = &sunplus_uart_ops;\n\tport->flags = UPF_BOOT_AUTOCONF;\n\tport->fifosize = 128;\n\n\tret = reset_control_deassert(sup->rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&pdev->dev, sunplus_uart_reset_control_assert, sup->rstc);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_SERIAL_SUNPLUS_CONSOLE\n\tsunplus_console_ports[sup->port.line] = sup;\n#endif\n\n\tplatform_set_drvdata(pdev, &sup->port);\n\n\tret = uart_add_one_port(&sunplus_uart_driver, &sup->port);\n#ifdef CONFIG_SERIAL_SUNPLUS_CONSOLE\n\tif (ret)\n\t\tsunplus_console_ports[sup->port.line] = NULL;\n#endif\n\n\treturn ret;\n}\n\nstatic int sunplus_uart_remove(struct platform_device *pdev)\n{\n\tstruct sunplus_uart_port *sup = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&sunplus_uart_driver, &sup->port);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sunplus_uart_suspend(struct device *dev)\n{\n\tstruct sunplus_uart_port *sup = dev_get_drvdata(dev);\n\n\tif (!uart_console(&sup->port))\n\t\tuart_suspend_port(&sunplus_uart_driver, &sup->port);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sunplus_uart_resume(struct device *dev)\n{\n\tstruct sunplus_uart_port *sup = dev_get_drvdata(dev);\n\n\tif (!uart_console(&sup->port))\n\t\tuart_resume_port(&sunplus_uart_driver, &sup->port);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops sunplus_uart_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sunplus_uart_suspend, sunplus_uart_resume)\n};\n\nstatic const struct of_device_id sp_uart_of_match[] = {\n\t{ .compatible = \"sunplus,sp7021-uart\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sp_uart_of_match);\n\nstatic struct platform_driver sunplus_uart_platform_driver = {\n\t.probe\t\t= sunplus_uart_probe,\n\t.remove\t\t= sunplus_uart_remove,\n\t.driver = {\n\t\t.name\t= \"sunplus_uart\",\n\t\t.of_match_table = sp_uart_of_match,\n\t\t.pm     = &sunplus_uart_pm_ops,\n\t}\n};\n\nstatic int __init sunplus_uart_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&sunplus_uart_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&sunplus_uart_platform_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&sunplus_uart_driver);\n\n\treturn ret;\n}\nmodule_init(sunplus_uart_init);\n\nstatic void __exit sunplus_uart_exit(void)\n{\n\tplatform_driver_unregister(&sunplus_uart_platform_driver);\n\tuart_unregister_driver(&sunplus_uart_driver);\n}\nmodule_exit(sunplus_uart_exit);\n\n#ifdef CONFIG_SERIAL_EARLYCON\nstatic void sunplus_uart_putc(struct uart_port *port, unsigned char c)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = readl_poll_timeout_atomic(port->membase + SUP_UART_LSR, val,\n\t\t\t\t\t(val & UART_LSR_TEMT), 1, 10000);\n\tif (ret)\n\t\treturn;\n\n\twritel(c, port->membase + SUP_UART_DATA);\n}\n\nstatic void sunplus_uart_early_write(struct console *con, const char *s, unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, sunplus_uart_putc);\n}\n\nstatic int __init\nsunplus_uart_early_setup(struct earlycon_device *dev, const char *opt)\n{\n\tif (!(dev->port.membase || dev->port.iobase))\n\t\treturn -ENODEV;\n\n\tdev->con->write = sunplus_uart_early_write;\n\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(sunplus_uart, \"sunplus,sp7021-uart\", sunplus_uart_early_setup);\n#endif\n\nMODULE_DESCRIPTION(\"Sunplus UART driver\");\nMODULE_AUTHOR(\"Hammer Hsieh <hammerh0314@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}