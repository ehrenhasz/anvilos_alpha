{
  "module_name": "rp2.c",
  "hash_id": "6586987eed43aa52eead891ed214a65f60703b0c5e5c2a5b5888fa274df561ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/rp2.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/compiler.h>\n#include <linux/completion.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/types.h>\n\n#define DRV_NAME\t\t\t\"rp2\"\n\n#define RP2_FW_NAME\t\t\t\"rp2.fw\"\n#define RP2_UCODE_BYTES\t\t\t0x3f\n\n#define PORTS_PER_ASIC\t\t\t16\n#define ALL_PORTS_MASK\t\t\t(BIT(PORTS_PER_ASIC) - 1)\n\n#define UART_CLOCK\t\t\t44236800\n#define DEFAULT_BAUD_DIV\t\t(UART_CLOCK / (9600 * 16))\n#define FIFO_SIZE\t\t\t512\n\n \n#define RP2_FPGA_CTL0\t\t\t0x110\n#define RP2_FPGA_CTL1\t\t\t0x11c\n#define RP2_IRQ_MASK\t\t\t0x1ec\n#define RP2_IRQ_MASK_EN_m\t\tBIT(0)\n#define RP2_IRQ_STATUS\t\t\t0x1f0\n\n \n#define RP2_ASIC_SPACING\t\t0x1000\n#define RP2_ASIC_OFFSET(i)\t\t((i) << ilog2(RP2_ASIC_SPACING))\n\n#define RP2_PORT_BASE\t\t\t0x000\n#define RP2_PORT_SPACING\t\t0x040\n\n#define RP2_UCODE_BASE\t\t\t0x400\n#define RP2_UCODE_SPACING\t\t0x80\n\n#define RP2_CLK_PRESCALER\t\t0xc00\n#define RP2_CH_IRQ_STAT\t\t\t0xc04\n#define RP2_CH_IRQ_MASK\t\t\t0xc08\n#define RP2_ASIC_IRQ\t\t\t0xd00\n#define RP2_ASIC_IRQ_EN_m\t\tBIT(20)\n#define RP2_GLOBAL_CMD\t\t\t0xd0c\n#define RP2_ASIC_CFG\t\t\t0xd04\n\n \n#define RP2_DATA_DWORD\t\t\t0x000\n\n#define RP2_DATA_BYTE\t\t\t0x008\n#define RP2_DATA_BYTE_ERR_PARITY_m\tBIT(8)\n#define RP2_DATA_BYTE_ERR_OVERRUN_m\tBIT(9)\n#define RP2_DATA_BYTE_ERR_FRAMING_m\tBIT(10)\n#define RP2_DATA_BYTE_BREAK_m\t\tBIT(11)\n\n \n#define RP2_DUMMY_READ\t\t\tBIT(16)\n\n#define RP2_DATA_BYTE_EXCEPTION_MASK\t(RP2_DATA_BYTE_ERR_PARITY_m | \\\n\t\t\t\t\t RP2_DATA_BYTE_ERR_OVERRUN_m | \\\n\t\t\t\t\t RP2_DATA_BYTE_ERR_FRAMING_m | \\\n\t\t\t\t\t RP2_DATA_BYTE_BREAK_m)\n\n#define RP2_RX_FIFO_COUNT\t\t0x00c\n#define RP2_TX_FIFO_COUNT\t\t0x00e\n\n#define RP2_CHAN_STAT\t\t\t0x010\n#define RP2_CHAN_STAT_RXDATA_m\t\tBIT(0)\n#define RP2_CHAN_STAT_DCD_m\t\tBIT(3)\n#define RP2_CHAN_STAT_DSR_m\t\tBIT(4)\n#define RP2_CHAN_STAT_CTS_m\t\tBIT(5)\n#define RP2_CHAN_STAT_RI_m\t\tBIT(6)\n#define RP2_CHAN_STAT_OVERRUN_m\t\tBIT(13)\n#define RP2_CHAN_STAT_DSR_CHANGED_m\tBIT(16)\n#define RP2_CHAN_STAT_CTS_CHANGED_m\tBIT(17)\n#define RP2_CHAN_STAT_CD_CHANGED_m\tBIT(18)\n#define RP2_CHAN_STAT_RI_CHANGED_m\tBIT(22)\n#define RP2_CHAN_STAT_TXEMPTY_m\t\tBIT(25)\n\n#define RP2_CHAN_STAT_MS_CHANGED_MASK\t(RP2_CHAN_STAT_DSR_CHANGED_m | \\\n\t\t\t\t\t RP2_CHAN_STAT_CTS_CHANGED_m | \\\n\t\t\t\t\t RP2_CHAN_STAT_CD_CHANGED_m | \\\n\t\t\t\t\t RP2_CHAN_STAT_RI_CHANGED_m)\n\n#define RP2_TXRX_CTL\t\t\t0x014\n#define RP2_TXRX_CTL_MSRIRQ_m\t\tBIT(0)\n#define RP2_TXRX_CTL_RXIRQ_m\t\tBIT(2)\n#define RP2_TXRX_CTL_RX_TRIG_s\t\t3\n#define RP2_TXRX_CTL_RX_TRIG_m\t\t(0x3 << RP2_TXRX_CTL_RX_TRIG_s)\n#define RP2_TXRX_CTL_RX_TRIG_1\t\t(0x1 << RP2_TXRX_CTL_RX_TRIG_s)\n#define RP2_TXRX_CTL_RX_TRIG_256\t(0x2 << RP2_TXRX_CTL_RX_TRIG_s)\n#define RP2_TXRX_CTL_RX_TRIG_448\t(0x3 << RP2_TXRX_CTL_RX_TRIG_s)\n#define RP2_TXRX_CTL_RX_EN_m\t\tBIT(5)\n#define RP2_TXRX_CTL_RTSFLOW_m\t\tBIT(6)\n#define RP2_TXRX_CTL_DTRFLOW_m\t\tBIT(7)\n#define RP2_TXRX_CTL_TX_TRIG_s\t\t16\n#define RP2_TXRX_CTL_TX_TRIG_m\t\t(0x3 << RP2_TXRX_CTL_RX_TRIG_s)\n#define RP2_TXRX_CTL_DSRFLOW_m\t\tBIT(18)\n#define RP2_TXRX_CTL_TXIRQ_m\t\tBIT(19)\n#define RP2_TXRX_CTL_CTSFLOW_m\t\tBIT(23)\n#define RP2_TXRX_CTL_TX_EN_m\t\tBIT(24)\n#define RP2_TXRX_CTL_RTS_m\t\tBIT(25)\n#define RP2_TXRX_CTL_DTR_m\t\tBIT(26)\n#define RP2_TXRX_CTL_LOOP_m\t\tBIT(27)\n#define RP2_TXRX_CTL_BREAK_m\t\tBIT(28)\n#define RP2_TXRX_CTL_CMSPAR_m\t\tBIT(29)\n#define RP2_TXRX_CTL_nPARODD_m\t\tBIT(30)\n#define RP2_TXRX_CTL_PARENB_m\t\tBIT(31)\n\n#define RP2_UART_CTL\t\t\t0x018\n#define RP2_UART_CTL_MODE_s\t\t0\n#define RP2_UART_CTL_MODE_m\t\t(0x7 << RP2_UART_CTL_MODE_s)\n#define RP2_UART_CTL_MODE_rs232\t\t(0x1 << RP2_UART_CTL_MODE_s)\n#define RP2_UART_CTL_FLUSH_RX_m\t\tBIT(3)\n#define RP2_UART_CTL_FLUSH_TX_m\t\tBIT(4)\n#define RP2_UART_CTL_RESET_CH_m\t\tBIT(5)\n#define RP2_UART_CTL_XMIT_EN_m\t\tBIT(6)\n#define RP2_UART_CTL_DATABITS_s\t\t8\n#define RP2_UART_CTL_DATABITS_m\t\t(0x3 << RP2_UART_CTL_DATABITS_s)\n#define RP2_UART_CTL_DATABITS_8\t\t(0x3 << RP2_UART_CTL_DATABITS_s)\n#define RP2_UART_CTL_DATABITS_7\t\t(0x2 << RP2_UART_CTL_DATABITS_s)\n#define RP2_UART_CTL_DATABITS_6\t\t(0x1 << RP2_UART_CTL_DATABITS_s)\n#define RP2_UART_CTL_DATABITS_5\t\t(0x0 << RP2_UART_CTL_DATABITS_s)\n#define RP2_UART_CTL_STOPBITS_m\t\tBIT(10)\n\n#define RP2_BAUD\t\t\t0x01c\n\n \n#define RP2_TX_SWFLOW\t\t\t0x02\n#define RP2_TX_SWFLOW_ena\t\t0x81\n#define RP2_TX_SWFLOW_dis\t\t0x9d\n\n#define RP2_RX_SWFLOW\t\t\t0x0c\n#define RP2_RX_SWFLOW_ena\t\t0x81\n#define RP2_RX_SWFLOW_dis\t\t0x8d\n\n#define RP2_RX_FIFO\t\t\t0x37\n#define RP2_RX_FIFO_ena\t\t\t0x08\n#define RP2_RX_FIFO_dis\t\t\t0x81\n\nstatic struct uart_driver rp2_uart_driver = {\n\t.owner\t\t\t\t= THIS_MODULE,\n\t.driver_name\t\t\t= DRV_NAME,\n\t.dev_name\t\t\t= \"ttyRP\",\n\t.nr\t\t\t\t= CONFIG_SERIAL_RP2_NR_UARTS,\n};\n\nstruct rp2_card;\n\nstruct rp2_uart_port {\n\tstruct uart_port\t\tport;\n\tint\t\t\t\tidx;\n\tint\t\t\t\tignore_rx;\n\tstruct rp2_card\t\t\t*card;\n\tvoid __iomem\t\t\t*asic_base;\n\tvoid __iomem\t\t\t*base;\n\tvoid __iomem\t\t\t*ucode;\n};\n\nstruct rp2_card {\n\tstruct pci_dev\t\t\t*pdev;\n\tstruct rp2_uart_port\t\t*ports;\n\tint\t\t\t\tn_ports;\n\tint\t\t\t\tinitialized_ports;\n\tint\t\t\t\tminor_start;\n\tint\t\t\t\tsmpte;\n\tvoid __iomem\t\t\t*bar0;\n\tvoid __iomem\t\t\t*bar1;\n\tspinlock_t\t\t\tcard_lock;\n};\n\n#define RP_ID(prod) PCI_VDEVICE(RP, (prod))\n#define RP_CAP(ports, smpte) (((ports) << 8) | ((smpte) << 0))\n\nstatic inline void rp2_decode_cap(const struct pci_device_id *id,\n\t\t\t\t  int *ports, int *smpte)\n{\n\t*ports = id->driver_data >> 8;\n\t*smpte = id->driver_data & 0xff;\n}\n\nstatic DEFINE_SPINLOCK(rp2_minor_lock);\nstatic int rp2_minor_next;\n\nstatic int rp2_alloc_ports(int n_ports)\n{\n\tint ret = -ENOSPC;\n\n\tspin_lock(&rp2_minor_lock);\n\tif (rp2_minor_next + n_ports <= CONFIG_SERIAL_RP2_NR_UARTS) {\n\t\t \n\t\tret = rp2_minor_next;\n\t\trp2_minor_next += n_ports;\n\t}\n\tspin_unlock(&rp2_minor_lock);\n\n\treturn ret;\n}\n\nstatic inline struct rp2_uart_port *port_to_up(struct uart_port *port)\n{\n\treturn container_of(port, struct rp2_uart_port, port);\n}\n\nstatic void rp2_rmw(struct rp2_uart_port *up, int reg,\n\t\t    u32 clr_bits, u32 set_bits)\n{\n\tu32 tmp = readl(up->base + reg);\n\ttmp &= ~clr_bits;\n\ttmp |= set_bits;\n\twritel(tmp, up->base + reg);\n}\n\nstatic void rp2_rmw_clr(struct rp2_uart_port *up, int reg, u32 val)\n{\n\trp2_rmw(up, reg, val, 0);\n}\n\nstatic void rp2_rmw_set(struct rp2_uart_port *up, int reg, u32 val)\n{\n\trp2_rmw(up, reg, 0, val);\n}\n\nstatic void rp2_mask_ch_irq(struct rp2_uart_port *up, int ch_num,\n\t\t\t    int is_enabled)\n{\n\tunsigned long flags, irq_mask;\n\n\tspin_lock_irqsave(&up->card->card_lock, flags);\n\n\tirq_mask = readl(up->asic_base + RP2_CH_IRQ_MASK);\n\tif (is_enabled)\n\t\tirq_mask &= ~BIT(ch_num);\n\telse\n\t\tirq_mask |= BIT(ch_num);\n\twritel(irq_mask, up->asic_base + RP2_CH_IRQ_MASK);\n\n\tspin_unlock_irqrestore(&up->card->card_lock, flags);\n}\n\nstatic unsigned int rp2_uart_tx_empty(struct uart_port *port)\n{\n\tstruct rp2_uart_port *up = port_to_up(port);\n\tunsigned long tx_fifo_bytes, flags;\n\n\t \n\tspin_lock_irqsave(&up->port.lock, flags);\n\ttx_fifo_bytes = readw(up->base + RP2_TX_FIFO_COUNT);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\treturn tx_fifo_bytes ? 0 : TIOCSER_TEMT;\n}\n\nstatic unsigned int rp2_uart_get_mctrl(struct uart_port *port)\n{\n\tstruct rp2_uart_port *up = port_to_up(port);\n\tu32 status;\n\n\tstatus = readl(up->base + RP2_CHAN_STAT);\n\treturn ((status & RP2_CHAN_STAT_DCD_m) ? TIOCM_CAR : 0) |\n\t       ((status & RP2_CHAN_STAT_DSR_m) ? TIOCM_DSR : 0) |\n\t       ((status & RP2_CHAN_STAT_CTS_m) ? TIOCM_CTS : 0) |\n\t       ((status & RP2_CHAN_STAT_RI_m) ? TIOCM_RI : 0);\n}\n\nstatic void rp2_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\trp2_rmw(port_to_up(port), RP2_TXRX_CTL,\n\t\tRP2_TXRX_CTL_DTR_m | RP2_TXRX_CTL_RTS_m | RP2_TXRX_CTL_LOOP_m,\n\t\t((mctrl & TIOCM_DTR) ? RP2_TXRX_CTL_DTR_m : 0) |\n\t\t((mctrl & TIOCM_RTS) ? RP2_TXRX_CTL_RTS_m : 0) |\n\t\t((mctrl & TIOCM_LOOP) ? RP2_TXRX_CTL_LOOP_m : 0));\n}\n\nstatic void rp2_uart_start_tx(struct uart_port *port)\n{\n\trp2_rmw_set(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_TXIRQ_m);\n}\n\nstatic void rp2_uart_stop_tx(struct uart_port *port)\n{\n\trp2_rmw_clr(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_TXIRQ_m);\n}\n\nstatic void rp2_uart_stop_rx(struct uart_port *port)\n{\n\trp2_rmw_clr(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_RXIRQ_m);\n}\n\nstatic void rp2_uart_break_ctl(struct uart_port *port, int break_state)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\trp2_rmw(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_BREAK_m,\n\t\tbreak_state ? RP2_TXRX_CTL_BREAK_m : 0);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void rp2_uart_enable_ms(struct uart_port *port)\n{\n\trp2_rmw_set(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_MSRIRQ_m);\n}\n\nstatic void __rp2_uart_set_termios(struct rp2_uart_port *up,\n\t\t\t\t   unsigned long cfl,\n\t\t\t\t   unsigned long ifl,\n\t\t\t\t   unsigned int baud_div)\n{\n\t \n\twritew(baud_div - 1, up->base + RP2_BAUD);\n\n\t \n\trp2_rmw(up, RP2_UART_CTL,\n\t\tRP2_UART_CTL_STOPBITS_m | RP2_UART_CTL_DATABITS_m,\n\t\t((cfl & CSTOPB) ? RP2_UART_CTL_STOPBITS_m : 0) |\n\t\t(((cfl & CSIZE) == CS8) ? RP2_UART_CTL_DATABITS_8 : 0) |\n\t\t(((cfl & CSIZE) == CS7) ? RP2_UART_CTL_DATABITS_7 : 0) |\n\t\t(((cfl & CSIZE) == CS6) ? RP2_UART_CTL_DATABITS_6 : 0) |\n\t\t(((cfl & CSIZE) == CS5) ? RP2_UART_CTL_DATABITS_5 : 0));\n\n\t \n\trp2_rmw(up, RP2_TXRX_CTL,\n\t\tRP2_TXRX_CTL_PARENB_m | RP2_TXRX_CTL_nPARODD_m |\n\t\tRP2_TXRX_CTL_CMSPAR_m | RP2_TXRX_CTL_DTRFLOW_m |\n\t\tRP2_TXRX_CTL_DSRFLOW_m | RP2_TXRX_CTL_RTSFLOW_m |\n\t\tRP2_TXRX_CTL_CTSFLOW_m,\n\t\t((cfl & PARENB) ? RP2_TXRX_CTL_PARENB_m : 0) |\n\t\t((cfl & PARODD) ? 0 : RP2_TXRX_CTL_nPARODD_m) |\n\t\t((cfl & CMSPAR) ? RP2_TXRX_CTL_CMSPAR_m : 0) |\n\t\t((cfl & CRTSCTS) ? (RP2_TXRX_CTL_RTSFLOW_m |\n\t\t\t\t    RP2_TXRX_CTL_CTSFLOW_m) : 0));\n\n\t \n\twriteb((ifl & IXON) ? RP2_TX_SWFLOW_ena : RP2_TX_SWFLOW_dis,\n\t       up->ucode + RP2_TX_SWFLOW);\n\twriteb((ifl & IXOFF) ? RP2_RX_SWFLOW_ena : RP2_RX_SWFLOW_dis,\n\t       up->ucode + RP2_RX_SWFLOW);\n}\n\nstatic void rp2_uart_set_termios(struct uart_port *port, struct ktermios *new,\n\t\t\t\t const struct ktermios *old)\n{\n\tstruct rp2_uart_port *up = port_to_up(port);\n\tunsigned long flags;\n\tunsigned int baud, baud_div;\n\n\tbaud = uart_get_baud_rate(port, new, old, 0, port->uartclk / 16);\n\tbaud_div = uart_get_divisor(port, baud);\n\n\tif (tty_termios_baud_rate(new))\n\t\ttty_termios_encode_baud_rate(new, baud, baud);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tport->ignore_status_mask = (new->c_cflag & CREAD) ? 0 : RP2_DUMMY_READ;\n\n\t__rp2_uart_set_termios(up, new->c_cflag, new->c_iflag, baud_div);\n\tuart_update_timeout(port, new->c_cflag, baud);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void rp2_rx_chars(struct rp2_uart_port *up)\n{\n\tu16 bytes = readw(up->base + RP2_RX_FIFO_COUNT);\n\tstruct tty_port *port = &up->port.state->port;\n\n\tfor (; bytes != 0; bytes--) {\n\t\tu32 byte = readw(up->base + RP2_DATA_BYTE) | RP2_DUMMY_READ;\n\t\tu8 ch = byte & 0xff;\n\n\t\tif (likely(!(byte & RP2_DATA_BYTE_EXCEPTION_MASK))) {\n\t\t\tif (!uart_handle_sysrq_char(&up->port, ch))\n\t\t\t\tuart_insert_char(&up->port, byte, 0, ch,\n\t\t\t\t\t\t TTY_NORMAL);\n\t\t} else {\n\t\t\tu8 flag = TTY_NORMAL;\n\n\t\t\tif (byte & RP2_DATA_BYTE_BREAK_m)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (byte & RP2_DATA_BYTE_ERR_FRAMING_m)\n\t\t\t\tflag = TTY_FRAME;\n\t\t\telse if (byte & RP2_DATA_BYTE_ERR_PARITY_m)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\tuart_insert_char(&up->port, byte,\n\t\t\t\t\t RP2_DATA_BYTE_ERR_OVERRUN_m, ch, flag);\n\t\t}\n\t\tup->port.icount.rx++;\n\t}\n\n\ttty_flip_buffer_push(port);\n}\n\nstatic void rp2_tx_chars(struct rp2_uart_port *up)\n{\n\tu8 ch;\n\n\tuart_port_tx_limited(&up->port, ch,\n\t\tFIFO_SIZE - readw(up->base + RP2_TX_FIFO_COUNT),\n\t\ttrue,\n\t\twriteb(ch, up->base + RP2_DATA_BYTE),\n\t\t({}));\n}\n\nstatic void rp2_ch_interrupt(struct rp2_uart_port *up)\n{\n\tu32 status;\n\n\tspin_lock(&up->port.lock);\n\n\t \n\tstatus = readl(up->base + RP2_CHAN_STAT);\n\twritel(status, up->base + RP2_CHAN_STAT);\n\n\tif (status & RP2_CHAN_STAT_RXDATA_m)\n\t\trp2_rx_chars(up);\n\tif (status & RP2_CHAN_STAT_TXEMPTY_m)\n\t\trp2_tx_chars(up);\n\tif (status & RP2_CHAN_STAT_MS_CHANGED_MASK)\n\t\twake_up_interruptible(&up->port.state->port.delta_msr_wait);\n\n\tspin_unlock(&up->port.lock);\n}\n\nstatic int rp2_asic_interrupt(struct rp2_card *card, unsigned int asic_id)\n{\n\tvoid __iomem *base = card->bar1 + RP2_ASIC_OFFSET(asic_id);\n\tint ch, handled = 0;\n\tunsigned long status = readl(base + RP2_CH_IRQ_STAT) &\n\t\t\t       ~readl(base + RP2_CH_IRQ_MASK);\n\n\tfor_each_set_bit(ch, &status, PORTS_PER_ASIC) {\n\t\trp2_ch_interrupt(&card->ports[ch]);\n\t\thandled++;\n\t}\n\treturn handled;\n}\n\nstatic irqreturn_t rp2_uart_interrupt(int irq, void *dev_id)\n{\n\tstruct rp2_card *card = dev_id;\n\tint handled;\n\n\thandled = rp2_asic_interrupt(card, 0);\n\tif (card->n_ports >= PORTS_PER_ASIC)\n\t\thandled += rp2_asic_interrupt(card, 1);\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic inline void rp2_flush_fifos(struct rp2_uart_port *up)\n{\n\trp2_rmw_set(up, RP2_UART_CTL,\n\t\t    RP2_UART_CTL_FLUSH_RX_m | RP2_UART_CTL_FLUSH_TX_m);\n\treadl(up->base + RP2_UART_CTL);\n\tudelay(10);\n\trp2_rmw_clr(up, RP2_UART_CTL,\n\t\t    RP2_UART_CTL_FLUSH_RX_m | RP2_UART_CTL_FLUSH_TX_m);\n}\n\nstatic int rp2_uart_startup(struct uart_port *port)\n{\n\tstruct rp2_uart_port *up = port_to_up(port);\n\n\trp2_flush_fifos(up);\n\trp2_rmw(up, RP2_TXRX_CTL, RP2_TXRX_CTL_MSRIRQ_m, RP2_TXRX_CTL_RXIRQ_m);\n\trp2_rmw(up, RP2_TXRX_CTL, RP2_TXRX_CTL_RX_TRIG_m,\n\t\tRP2_TXRX_CTL_RX_TRIG_1);\n\trp2_rmw(up, RP2_CHAN_STAT, 0, 0);\n\trp2_mask_ch_irq(up, up->idx, 1);\n\n\treturn 0;\n}\n\nstatic void rp2_uart_shutdown(struct uart_port *port)\n{\n\tstruct rp2_uart_port *up = port_to_up(port);\n\tunsigned long flags;\n\n\trp2_uart_break_ctl(port, 0);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\trp2_mask_ch_irq(up, up->idx, 0);\n\trp2_rmw(up, RP2_CHAN_STAT, 0, 0);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *rp2_uart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_RP2) ? \"RocketPort 2 UART\" : NULL;\n}\n\nstatic void rp2_uart_release_port(struct uart_port *port)\n{\n\t \n}\n\nstatic int rp2_uart_request_port(struct uart_port *port)\n{\n\t \n\treturn 0;\n}\n\nstatic void rp2_uart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_RP2;\n}\n\nstatic int rp2_uart_verify_port(struct uart_port *port,\n\t\t\t\t   struct serial_struct *ser)\n{\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_RP2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct uart_ops rp2_uart_ops = {\n\t.tx_empty\t= rp2_uart_tx_empty,\n\t.set_mctrl\t= rp2_uart_set_mctrl,\n\t.get_mctrl\t= rp2_uart_get_mctrl,\n\t.stop_tx\t= rp2_uart_stop_tx,\n\t.start_tx\t= rp2_uart_start_tx,\n\t.stop_rx\t= rp2_uart_stop_rx,\n\t.enable_ms\t= rp2_uart_enable_ms,\n\t.break_ctl\t= rp2_uart_break_ctl,\n\t.startup\t= rp2_uart_startup,\n\t.shutdown\t= rp2_uart_shutdown,\n\t.set_termios\t= rp2_uart_set_termios,\n\t.type\t\t= rp2_uart_type,\n\t.release_port\t= rp2_uart_release_port,\n\t.request_port\t= rp2_uart_request_port,\n\t.config_port\t= rp2_uart_config_port,\n\t.verify_port\t= rp2_uart_verify_port,\n};\n\nstatic void rp2_reset_asic(struct rp2_card *card, unsigned int asic_id)\n{\n\tvoid __iomem *base = card->bar1 + RP2_ASIC_OFFSET(asic_id);\n\tu32 clk_cfg;\n\n\twritew(1, base + RP2_GLOBAL_CMD);\n\treadw(base + RP2_GLOBAL_CMD);\n\tmsleep(100);\n\twritel(0, base + RP2_CLK_PRESCALER);\n\n\t \n\tclk_cfg = readw(base + RP2_ASIC_CFG);\n\tclk_cfg = (clk_cfg & ~BIT(8)) | BIT(9);\n\twritew(clk_cfg, base + RP2_ASIC_CFG);\n\n\t \n\twritel(ALL_PORTS_MASK, base + RP2_CH_IRQ_MASK);\n\twritel(RP2_ASIC_IRQ_EN_m, base + RP2_ASIC_IRQ);\n}\n\nstatic void rp2_init_card(struct rp2_card *card)\n{\n\twritel(4, card->bar0 + RP2_FPGA_CTL0);\n\twritel(0, card->bar0 + RP2_FPGA_CTL1);\n\n\trp2_reset_asic(card, 0);\n\tif (card->n_ports >= PORTS_PER_ASIC)\n\t\trp2_reset_asic(card, 1);\n\n\twritel(RP2_IRQ_MASK_EN_m, card->bar0 + RP2_IRQ_MASK);\n}\n\nstatic void rp2_init_port(struct rp2_uart_port *up, const struct firmware *fw)\n{\n\tint i;\n\n\twritel(RP2_UART_CTL_RESET_CH_m, up->base + RP2_UART_CTL);\n\treadl(up->base + RP2_UART_CTL);\n\tudelay(1);\n\n\twritel(0, up->base + RP2_TXRX_CTL);\n\twritel(0, up->base + RP2_UART_CTL);\n\treadl(up->base + RP2_UART_CTL);\n\tudelay(1);\n\n\trp2_flush_fifos(up);\n\n\tfor (i = 0; i < min_t(int, fw->size, RP2_UCODE_BYTES); i++)\n\t\twriteb(fw->data[i], up->ucode + i);\n\n\t__rp2_uart_set_termios(up, CS8 | CREAD | CLOCAL, 0, DEFAULT_BAUD_DIV);\n\trp2_uart_set_mctrl(&up->port, 0);\n\n\twriteb(RP2_RX_FIFO_ena, up->ucode + RP2_RX_FIFO);\n\trp2_rmw(up, RP2_UART_CTL, RP2_UART_CTL_MODE_m,\n\t\tRP2_UART_CTL_XMIT_EN_m | RP2_UART_CTL_MODE_rs232);\n\trp2_rmw_set(up, RP2_TXRX_CTL,\n\t\t    RP2_TXRX_CTL_TX_EN_m | RP2_TXRX_CTL_RX_EN_m);\n}\n\nstatic void rp2_remove_ports(struct rp2_card *card)\n{\n\tint i;\n\n\tfor (i = 0; i < card->initialized_ports; i++)\n\t\tuart_remove_one_port(&rp2_uart_driver, &card->ports[i].port);\n\tcard->initialized_ports = 0;\n}\n\nstatic int rp2_load_firmware(struct rp2_card *card, const struct firmware *fw)\n{\n\tresource_size_t phys_base;\n\tint i, rc = 0;\n\n\tphys_base = pci_resource_start(card->pdev, 1);\n\n\tfor (i = 0; i < card->n_ports; i++) {\n\t\tstruct rp2_uart_port *rp = &card->ports[i];\n\t\tstruct uart_port *p;\n\t\tint j = (unsigned)i % PORTS_PER_ASIC;\n\n\t\trp->asic_base = card->bar1;\n\t\trp->base = card->bar1 + RP2_PORT_BASE + j*RP2_PORT_SPACING;\n\t\trp->ucode = card->bar1 + RP2_UCODE_BASE + j*RP2_UCODE_SPACING;\n\t\trp->card = card;\n\t\trp->idx = j;\n\n\t\tp = &rp->port;\n\t\tp->line = card->minor_start + i;\n\t\tp->dev = &card->pdev->dev;\n\t\tp->type = PORT_RP2;\n\t\tp->iotype = UPIO_MEM32;\n\t\tp->uartclk = UART_CLOCK;\n\t\tp->regshift = 2;\n\t\tp->fifosize = FIFO_SIZE;\n\t\tp->ops = &rp2_uart_ops;\n\t\tp->irq = card->pdev->irq;\n\t\tp->membase = rp->base;\n\t\tp->mapbase = phys_base + RP2_PORT_BASE + j*RP2_PORT_SPACING;\n\n\t\tif (i >= PORTS_PER_ASIC) {\n\t\t\trp->asic_base += RP2_ASIC_SPACING;\n\t\t\trp->base += RP2_ASIC_SPACING;\n\t\t\trp->ucode += RP2_ASIC_SPACING;\n\t\t\tp->mapbase += RP2_ASIC_SPACING;\n\t\t}\n\n\t\trp2_init_port(rp, fw);\n\t\trc = uart_add_one_port(&rp2_uart_driver, p);\n\t\tif (rc) {\n\t\t\tdev_err(&card->pdev->dev,\n\t\t\t\t\"error registering port %d: %d\\n\", i, rc);\n\t\t\trp2_remove_ports(card);\n\t\t\tbreak;\n\t\t}\n\t\tcard->initialized_ports++;\n\t}\n\n\treturn rc;\n}\n\nstatic int rp2_probe(struct pci_dev *pdev,\n\t\t\t\t   const struct pci_device_id *id)\n{\n\tconst struct firmware *fw;\n\tstruct rp2_card *card;\n\tstruct rp2_uart_port *ports;\n\tvoid __iomem * const *bars;\n\tint rc;\n\n\tcard = devm_kzalloc(&pdev->dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\tpci_set_drvdata(pdev, card);\n\tspin_lock_init(&card->card_lock);\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pcim_iomap_regions_request_all(pdev, 0x03, DRV_NAME);\n\tif (rc)\n\t\treturn rc;\n\n\tbars = pcim_iomap_table(pdev);\n\tcard->bar0 = bars[0];\n\tcard->bar1 = bars[1];\n\tcard->pdev = pdev;\n\n\trp2_decode_cap(id, &card->n_ports, &card->smpte);\n\tdev_info(&pdev->dev, \"found new card with %d ports\\n\", card->n_ports);\n\n\tcard->minor_start = rp2_alloc_ports(card->n_ports);\n\tif (card->minor_start < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"too many ports (try increasing CONFIG_SERIAL_RP2_NR_UARTS)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trp2_init_card(card);\n\n\tports = devm_kcalloc(&pdev->dev, card->n_ports, sizeof(*ports),\n\t\t\t     GFP_KERNEL);\n\tif (!ports)\n\t\treturn -ENOMEM;\n\tcard->ports = ports;\n\n\trc = request_firmware(&fw, RP2_FW_NAME, &pdev->dev);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"cannot find '%s' firmware image\\n\",\n\t\t\tRP2_FW_NAME);\n\t\treturn rc;\n\t}\n\n\trc = rp2_load_firmware(card, fw);\n\n\trelease_firmware(fw);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = devm_request_irq(&pdev->dev, pdev->irq, rp2_uart_interrupt,\n\t\t\t      IRQF_SHARED, DRV_NAME, card);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic void rp2_remove(struct pci_dev *pdev)\n{\n\tstruct rp2_card *card = pci_get_drvdata(pdev);\n\n\trp2_remove_ports(card);\n}\n\nstatic const struct pci_device_id rp2_pci_tbl[] = {\n\n\t \n\n\t{ RP_ID(0x0040), RP_CAP(8,  0) },  \n\t{ RP_ID(0x0041), RP_CAP(32, 0) },  \n\t{ RP_ID(0x0042), RP_CAP(8,  0) },  \n\t{ RP_ID(0x0043), RP_CAP(16, 0) },  \n\t{ RP_ID(0x0044), RP_CAP(4,  0) },  \n\t{ RP_ID(0x0045), RP_CAP(8,  0) },  \n\t{ RP_ID(0x0046), RP_CAP(4,  0) },  \n\t{ RP_ID(0x0047), RP_CAP(4,  0) },  \n\t{ RP_ID(0x004a), RP_CAP(4,  0) },  \n\t{ RP_ID(0x004b), RP_CAP(8,  0) },  \n\t{ RP_ID(0x004c), RP_CAP(8,  0) },  \n\t{ RP_ID(0x004d), RP_CAP(4,  0) },  \n\t{ RP_ID(0x004e), RP_CAP(2,  0) },  \n\t{ RP_ID(0x004f), RP_CAP(2,  1) },  \n\t{ RP_ID(0x0050), RP_CAP(4,  0) },  \n\t{ RP_ID(0x0051), RP_CAP(8,  0) },  \n\t{ RP_ID(0x0052), RP_CAP(8,  1) },  \n\n\t \n\n\t{ RP_ID(0x0060), RP_CAP(8,  0) },  \n\t{ RP_ID(0x0061), RP_CAP(32, 0) },  \n\t{ RP_ID(0x0062), RP_CAP(8,  0) },  \n\t{ RP_ID(0x0063), RP_CAP(16, 0) },  \n\t{ RP_ID(0x0064), RP_CAP(4,  0) },  \n\t{ RP_ID(0x0065), RP_CAP(8,  0) },  \n\t{ RP_ID(0x0066), RP_CAP(4,  0) },  \n\t{ RP_ID(0x0067), RP_CAP(4,  0) },  \n\t{ RP_ID(0x0068), RP_CAP(8,  0) },  \n\t{ RP_ID(0x0072), RP_CAP(8,  1) },  \n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, rp2_pci_tbl);\n\nstatic struct pci_driver rp2_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= rp2_pci_tbl,\n\t.probe\t\t= rp2_probe,\n\t.remove\t\t= rp2_remove,\n};\n\nstatic int __init rp2_uart_init(void)\n{\n\tint rc;\n\n\trc = uart_register_driver(&rp2_uart_driver);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pci_register_driver(&rp2_pci_driver);\n\tif (rc) {\n\t\tuart_unregister_driver(&rp2_uart_driver);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit rp2_uart_exit(void)\n{\n\tpci_unregister_driver(&rp2_pci_driver);\n\tuart_unregister_driver(&rp2_uart_driver);\n}\n\nmodule_init(rp2_uart_init);\nmodule_exit(rp2_uart_exit);\n\nMODULE_DESCRIPTION(\"Comtrol RocketPort EXPRESS/INFINITY driver\");\nMODULE_AUTHOR(\"Kevin Cernekee <cernekee@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_FIRMWARE(RP2_FW_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}