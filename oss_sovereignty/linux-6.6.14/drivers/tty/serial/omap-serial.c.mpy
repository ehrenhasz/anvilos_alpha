{
  "module_name": "omap-serial.c",
  "hash_id": "5b086304d8a0bb524b6fd9f9f1215bc412a56cc6630675cc79d56b617287a041",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/omap-serial.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/serial_core.h>\n#include <linux/irq.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_data/serial-omap.h>\n\n#define OMAP_MAX_HSUART_PORTS\t10\n\n#define UART_BUILD_REVISION(x, y)\t(((x) << 8) | (y))\n\n#define OMAP_UART_REV_42 0x0402\n#define OMAP_UART_REV_46 0x0406\n#define OMAP_UART_REV_52 0x0502\n#define OMAP_UART_REV_63 0x0603\n\n#define OMAP_UART_TX_WAKEUP_EN\t\tBIT(7)\n\n \n#define OMAP_UART_WER_HAS_TX_WAKEUP\tBIT(0)\n\n#define UART_ERRATA_i202_MDR1_ACCESS\tBIT(0)\n#define UART_ERRATA_i291_DMA_FORCEIDLE\tBIT(1)\n\n#define DEFAULT_CLK_SPEED 48000000  \n\n \n#define OMAP_UART_SCR_RX_TRIG_GRANU1_MASK\t\t(1 << 7)\n#define OMAP_UART_SCR_TX_TRIG_GRANU1_MASK\t\t(1 << 6)\n#define OMAP_UART_SCR_TX_EMPTY\t\t\t(1 << 3)\n\n \n#define OMAP_UART_FCR_RX_FIFO_TRIG_MASK\t\t\t(0x3 << 6)\n#define OMAP_UART_FCR_TX_FIFO_TRIG_MASK\t\t\t(0x3 << 4)\n\n \n#define OMAP_UART_MVR_SCHEME_SHIFT\t30\n\n#define OMAP_UART_LEGACY_MVR_MAJ_MASK\t0xf0\n#define OMAP_UART_LEGACY_MVR_MAJ_SHIFT\t4\n#define OMAP_UART_LEGACY_MVR_MIN_MASK\t0x0f\n\n#define OMAP_UART_MVR_MAJ_MASK\t\t0x700\n#define OMAP_UART_MVR_MAJ_SHIFT\t\t8\n#define OMAP_UART_MVR_MIN_MASK\t\t0x3f\n\n#define OMAP_UART_DMA_CH_FREE\t-1\n\n#define MSR_SAVE_FLAGS\t\tUART_MSR_ANY_DELTA\n#define OMAP_MODE13X_SPEED\t230400\n\n \n#define OMAP_UART_WER_MOD_WKUP\t0x7F\n\n \n#define OMAP_UART_SW_TX\t\t0x08\n\n \n#define OMAP_UART_SW_RX\t\t0x02\n\n#define OMAP_UART_SW_CLR\t0xF0\n\n#define OMAP_UART_TCR_TRIG\t0x0F\n\nstruct uart_omap_dma {\n\tu8\t\t\tuart_dma_tx;\n\tu8\t\t\tuart_dma_rx;\n\tint\t\t\trx_dma_channel;\n\tint\t\t\ttx_dma_channel;\n\tdma_addr_t\t\trx_buf_dma_phys;\n\tdma_addr_t\t\ttx_buf_dma_phys;\n\tunsigned int\t\tuart_base;\n\t \n\tunsigned char\t\t*rx_buf;\n\tunsigned int\t\tprev_rx_dma_pos;\n\tint\t\t\ttx_buf_size;\n\tint\t\t\ttx_dma_used;\n\tint\t\t\trx_dma_used;\n\tspinlock_t\t\ttx_lock;\n\tspinlock_t\t\trx_lock;\n\t \n\tstruct timer_list\trx_timer;\n\tunsigned int\t\trx_buf_size;\n\tunsigned int\t\trx_poll_rate;\n\tunsigned int\t\trx_timeout;\n};\n\nstruct uart_omap_port {\n\tstruct uart_port\tport;\n\tstruct uart_omap_dma\tuart_dma;\n\tstruct device\t\t*dev;\n\tint\t\t\twakeirq;\n\n\tunsigned char\t\tier;\n\tunsigned char\t\tlcr;\n\tunsigned char\t\tmcr;\n\tunsigned char\t\tfcr;\n\tunsigned char\t\tefr;\n\tunsigned char\t\tdll;\n\tunsigned char\t\tdlh;\n\tunsigned char\t\tmdr1;\n\tunsigned char\t\tscr;\n\tunsigned char\t\twer;\n\n\tint\t\t\tuse_dma;\n\t \n\tunsigned int\t\tlsr_break_flag;\n\tunsigned char\t\tmsr_saved_flags;\n\tchar\t\t\tname[20];\n\tunsigned long\t\tport_activity;\n\tint\t\t\tcontext_loss_cnt;\n\tu32\t\t\terrata;\n\tu32\t\t\tfeatures;\n\n\tstruct gpio_desc\t*rts_gpiod;\n\n\tstruct pm_qos_request\tpm_qos_request;\n\tu32\t\t\tlatency;\n\tu32\t\t\tcalc_latency;\n\tstruct work_struct\tqos_work;\n\tbool\t\t\tis_suspending;\n\n\tunsigned int\t\trs485_tx_filter_count;\n};\n\n#define to_uart_omap_port(p) ((container_of((p), struct uart_omap_port, port)))\n\nstatic struct uart_omap_port *ui[OMAP_MAX_HSUART_PORTS];\n\n \nstatic void serial_omap_mdr1_errataset(struct uart_omap_port *up, u8 mdr1);\n\nstatic inline unsigned int serial_in(struct uart_omap_port *up, int offset)\n{\n\toffset <<= up->port.regshift;\n\treturn readw(up->port.membase + offset);\n}\n\nstatic inline void serial_out(struct uart_omap_port *up, int offset, int value)\n{\n\toffset <<= up->port.regshift;\n\twritew(value, up->port.membase + offset);\n}\n\nstatic inline void serial_omap_clear_fifos(struct uart_omap_port *up)\n{\n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t       UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\tserial_out(up, UART_FCR, 0);\n}\n\n#ifdef CONFIG_PM\nstatic int serial_omap_get_context_loss_count(struct uart_omap_port *up)\n{\n\tstruct omap_uart_port_info *pdata = dev_get_platdata(up->dev);\n\n\tif (!pdata || !pdata->get_context_loss_count)\n\t\treturn -EINVAL;\n\n\treturn pdata->get_context_loss_count(up->dev);\n}\n\n \nstatic void serial_omap_enable_wakeup(struct uart_omap_port *up, bool enable)\n{\n\tstruct omap_uart_port_info *pdata = dev_get_platdata(up->dev);\n\n\tif (!pdata || !pdata->enable_wakeup)\n\t\treturn;\n\n\tpdata->enable_wakeup(up->dev, enable);\n}\n#endif  \n\n \nstatic inline int calculate_baud_abs_diff(struct uart_port *port,\n\t\t\t\tunsigned int baud, unsigned int mode)\n{\n\tunsigned int n = port->uartclk / (mode * baud);\n\n\tif (n == 0)\n\t\tn = 1;\n\n\treturn abs_diff(baud, port->uartclk / (mode * n));\n}\n\n \nstatic bool\nserial_omap_baud_is_mode16(struct uart_port *port, unsigned int baud)\n{\n\tint abs_diff_13 = calculate_baud_abs_diff(port, baud, 13);\n\tint abs_diff_16 = calculate_baud_abs_diff(port, baud, 16);\n\n\treturn (abs_diff_13 >= abs_diff_16);\n}\n\n \nstatic unsigned int\nserial_omap_get_divisor(struct uart_port *port, unsigned int baud)\n{\n\tunsigned int mode;\n\n\tif (!serial_omap_baud_is_mode16(port, baud))\n\t\tmode = 13;\n\telse\n\t\tmode = 16;\n\treturn port->uartclk/(mode * baud);\n}\n\nstatic void serial_omap_enable_ms(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\n\tdev_dbg(up->port.dev, \"serial_omap_enable_ms+%d\\n\", up->port.line);\n\n\tup->ier |= UART_IER_MSI;\n\tserial_out(up, UART_IER, up->ier);\n}\n\nstatic void serial_omap_stop_tx(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tint res;\n\n\t \n\tif (port->rs485.flags & SER_RS485_ENABLED) {\n\t\tif (up->scr & OMAP_UART_SCR_TX_EMPTY) {\n\t\t\t \n\t\t\tup->scr &= ~OMAP_UART_SCR_TX_EMPTY;\n\t\t\tserial_out(up, UART_OMAP_SCR, up->scr);\n\t\t\tres = (port->rs485.flags & SER_RS485_RTS_AFTER_SEND) ?\n\t\t\t\t1 : 0;\n\t\t\tif (gpiod_get_value(up->rts_gpiod) != res) {\n\t\t\t\tif (port->rs485.delay_rts_after_send > 0)\n\t\t\t\t\tmdelay(\n\t\t\t\t\tport->rs485.delay_rts_after_send);\n\t\t\t\tgpiod_set_value(up->rts_gpiod, res);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tup->scr |= OMAP_UART_SCR_TX_EMPTY;\n\t\t\tserial_out(up, UART_OMAP_SCR, up->scr);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (up->ier & UART_IER_THRI) {\n\t\tup->ier &= ~UART_IER_THRI;\n\t\tserial_out(up, UART_IER, up->ier);\n\t}\n}\n\nstatic void serial_omap_stop_rx(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\n\tup->ier &= ~(UART_IER_RLSI | UART_IER_RDI);\n\tup->port.read_status_mask &= ~UART_LSR_DR;\n\tserial_out(up, UART_IER, up->ier);\n}\n\nstatic void serial_omap_put_char(struct uart_omap_port *up, unsigned char ch)\n{\n\tserial_out(up, UART_TX, ch);\n\n\tif ((up->port.rs485.flags & SER_RS485_ENABLED) &&\n\t\t\t!(up->port.rs485.flags & SER_RS485_RX_DURING_TX))\n\t\tup->rs485_tx_filter_count++;\n}\n\nstatic void transmit_chars(struct uart_omap_port *up, unsigned int lsr)\n{\n\tu8 ch;\n\n\tuart_port_tx_limited(&up->port, ch, up->port.fifosize / 4,\n\t\ttrue,\n\t\tserial_omap_put_char(up, ch),\n\t\t({}));\n}\n\nstatic inline void serial_omap_enable_ier_thri(struct uart_omap_port *up)\n{\n\tif (!(up->ier & UART_IER_THRI)) {\n\t\tup->ier |= UART_IER_THRI;\n\t\tserial_out(up, UART_IER, up->ier);\n\t}\n}\n\nstatic void serial_omap_start_tx(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tint res;\n\n\t \n\tif (port->rs485.flags & SER_RS485_ENABLED) {\n\t\t \n\t\tup->scr &= ~OMAP_UART_SCR_TX_EMPTY;\n\t\tserial_out(up, UART_OMAP_SCR, up->scr);\n\n\t\t \n\t\tres = (port->rs485.flags & SER_RS485_RTS_ON_SEND) ? 1 : 0;\n\t\tif (gpiod_get_value(up->rts_gpiod) != res) {\n\t\t\tgpiod_set_value(up->rts_gpiod, res);\n\t\t\tif (port->rs485.delay_rts_before_send > 0)\n\t\t\t\tmdelay(port->rs485.delay_rts_before_send);\n\t\t}\n\t}\n\n\tif ((port->rs485.flags & SER_RS485_ENABLED) &&\n\t    !(port->rs485.flags & SER_RS485_RX_DURING_TX))\n\t\tup->rs485_tx_filter_count = 0;\n\n\tserial_omap_enable_ier_thri(up);\n}\n\nstatic void serial_omap_throttle(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tup->ier &= ~(UART_IER_RLSI | UART_IER_RDI);\n\tserial_out(up, UART_IER, up->ier);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic void serial_omap_unthrottle(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tup->ier |= UART_IER_RLSI | UART_IER_RDI;\n\tserial_out(up, UART_IER, up->ier);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic unsigned int check_modem_status(struct uart_omap_port *up)\n{\n\tunsigned int status;\n\n\tstatus = serial_in(up, UART_MSR);\n\tstatus |= up->msr_saved_flags;\n\tup->msr_saved_flags = 0;\n\tif ((status & UART_MSR_ANY_DELTA) == 0)\n\t\treturn status;\n\n\tif (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&\n\t    up->port.state != NULL) {\n\t\tif (status & UART_MSR_TERI)\n\t\t\tup->port.icount.rng++;\n\t\tif (status & UART_MSR_DDSR)\n\t\t\tup->port.icount.dsr++;\n\t\tif (status & UART_MSR_DDCD)\n\t\t\tuart_handle_dcd_change\n\t\t\t\t(&up->port, status & UART_MSR_DCD);\n\t\tif (status & UART_MSR_DCTS)\n\t\t\tuart_handle_cts_change\n\t\t\t\t(&up->port, status & UART_MSR_CTS);\n\t\twake_up_interruptible(&up->port.state->port.delta_msr_wait);\n\t}\n\n\treturn status;\n}\n\nstatic void serial_omap_rlsi(struct uart_omap_port *up, unsigned int lsr)\n{\n\tu8 flag;\n\n\t \n\tif (likely(lsr & UART_LSR_DR)) {\n\t\tserial_in(up, UART_RX);\n\t\tif ((up->port.rs485.flags & SER_RS485_ENABLED) &&\n\t\t    !(up->port.rs485.flags & SER_RS485_RX_DURING_TX) &&\n\t\t    up->rs485_tx_filter_count)\n\t\t\tup->rs485_tx_filter_count--;\n\t}\n\n\tup->port.icount.rx++;\n\tflag = TTY_NORMAL;\n\n\tif (lsr & UART_LSR_BI) {\n\t\tflag = TTY_BREAK;\n\t\tlsr &= ~(UART_LSR_FE | UART_LSR_PE);\n\t\tup->port.icount.brk++;\n\t\t \n\t\tif (uart_handle_break(&up->port))\n\t\t\treturn;\n\n\t}\n\n\tif (lsr & UART_LSR_PE) {\n\t\tflag = TTY_PARITY;\n\t\tup->port.icount.parity++;\n\t}\n\n\tif (lsr & UART_LSR_FE) {\n\t\tflag = TTY_FRAME;\n\t\tup->port.icount.frame++;\n\t}\n\n\tif (lsr & UART_LSR_OE)\n\t\tup->port.icount.overrun++;\n\n#ifdef CONFIG_SERIAL_OMAP_CONSOLE\n\tif (up->port.line == up->port.cons->index) {\n\t\t \n\t\tlsr |= up->lsr_break_flag;\n\t}\n#endif\n\tuart_insert_char(&up->port, lsr, UART_LSR_OE, 0, flag);\n}\n\nstatic void serial_omap_rdi(struct uart_omap_port *up, unsigned int lsr)\n{\n\tu8 ch;\n\n\tif (!(lsr & UART_LSR_DR))\n\t\treturn;\n\n\tch = serial_in(up, UART_RX);\n\tif ((up->port.rs485.flags & SER_RS485_ENABLED) &&\n\t    !(up->port.rs485.flags & SER_RS485_RX_DURING_TX) &&\n\t    up->rs485_tx_filter_count) {\n\t\tup->rs485_tx_filter_count--;\n\t\treturn;\n\t}\n\n\tup->port.icount.rx++;\n\n\tif (uart_handle_sysrq_char(&up->port, ch))\n\t\treturn;\n\n\tuart_insert_char(&up->port, lsr, UART_LSR_OE, ch, TTY_NORMAL);\n}\n\n \nstatic irqreturn_t serial_omap_irq(int irq, void *dev_id)\n{\n\tstruct uart_omap_port *up = dev_id;\n\tunsigned int iir, lsr;\n\tunsigned int type;\n\tirqreturn_t ret = IRQ_NONE;\n\tint max_count = 256;\n\n\tspin_lock(&up->port.lock);\n\n\tdo {\n\t\tiir = serial_in(up, UART_IIR);\n\t\tif (iir & UART_IIR_NO_INT)\n\t\t\tbreak;\n\n\t\tret = IRQ_HANDLED;\n\t\tlsr = serial_in(up, UART_LSR);\n\n\t\t \n\t\ttype = iir & 0x3e;\n\n\t\tswitch (type) {\n\t\tcase UART_IIR_MSI:\n\t\t\tcheck_modem_status(up);\n\t\t\tbreak;\n\t\tcase UART_IIR_THRI:\n\t\t\ttransmit_chars(up, lsr);\n\t\t\tbreak;\n\t\tcase UART_IIR_RX_TIMEOUT:\n\t\tcase UART_IIR_RDI:\n\t\t\tserial_omap_rdi(up, lsr);\n\t\t\tbreak;\n\t\tcase UART_IIR_RLSI:\n\t\t\tserial_omap_rlsi(up, lsr);\n\t\t\tbreak;\n\t\tcase UART_IIR_CTS_RTS_DSR:\n\t\t\t \n\t\t\tbreak;\n\t\tcase UART_IIR_XOFF:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while (max_count--);\n\n\tspin_unlock(&up->port.lock);\n\n\ttty_flip_buffer_push(&up->port.state->port);\n\n\tup->port_activity = jiffies;\n\n\treturn ret;\n}\n\nstatic unsigned int serial_omap_tx_empty(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned long flags;\n\tunsigned int ret = 0;\n\n\tdev_dbg(up->port.dev, \"serial_omap_tx_empty+%d\\n\", up->port.line);\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\treturn ret;\n}\n\nstatic unsigned int serial_omap_get_mctrl(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned int status;\n\tunsigned int ret = 0;\n\n\tstatus = check_modem_status(up);\n\n\tdev_dbg(up->port.dev, \"serial_omap_get_mctrl+%d\\n\", up->port.line);\n\n\tif (status & UART_MSR_DCD)\n\t\tret |= TIOCM_CAR;\n\tif (status & UART_MSR_RI)\n\t\tret |= TIOCM_RNG;\n\tif (status & UART_MSR_DSR)\n\t\tret |= TIOCM_DSR;\n\tif (status & UART_MSR_CTS)\n\t\tret |= TIOCM_CTS;\n\treturn ret;\n}\n\nstatic void serial_omap_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned char mcr = 0, old_mcr, lcr;\n\n\tdev_dbg(up->port.dev, \"serial_omap_set_mctrl+%d\\n\", up->port.line);\n\tif (mctrl & TIOCM_RTS)\n\t\tmcr |= UART_MCR_RTS;\n\tif (mctrl & TIOCM_DTR)\n\t\tmcr |= UART_MCR_DTR;\n\tif (mctrl & TIOCM_OUT1)\n\t\tmcr |= UART_MCR_OUT1;\n\tif (mctrl & TIOCM_OUT2)\n\t\tmcr |= UART_MCR_OUT2;\n\tif (mctrl & TIOCM_LOOP)\n\t\tmcr |= UART_MCR_LOOP;\n\n\told_mcr = serial_in(up, UART_MCR);\n\told_mcr &= ~(UART_MCR_LOOP | UART_MCR_OUT2 | UART_MCR_OUT1 |\n\t\t     UART_MCR_DTR | UART_MCR_RTS);\n\tup->mcr = old_mcr | mcr;\n\tserial_out(up, UART_MCR, up->mcr);\n\n\t \n\tlcr = serial_in(up, UART_LCR);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tif ((mctrl & TIOCM_RTS) && (port->status & UPSTAT_AUTORTS))\n\t\tup->efr |= UART_EFR_RTS;\n\telse\n\t\tup->efr &= ~UART_EFR_RTS;\n\tserial_out(up, UART_EFR, up->efr);\n\tserial_out(up, UART_LCR, lcr);\n}\n\nstatic void serial_omap_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned long flags;\n\n\tdev_dbg(up->port.dev, \"serial_omap_break_ctl+%d\\n\", up->port.line);\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tif (break_state == -1)\n\t\tup->lcr |= UART_LCR_SBC;\n\telse\n\t\tup->lcr &= ~UART_LCR_SBC;\n\tserial_out(up, UART_LCR, up->lcr);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic int serial_omap_startup(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned long flags;\n\tint retval;\n\n\t \n\tretval = request_irq(up->port.irq, serial_omap_irq, up->port.irqflags,\n\t\t\t\tup->name, up);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tif (up->wakeirq) {\n\t\tretval = dev_pm_set_dedicated_wake_irq(up->dev, up->wakeirq);\n\t\tif (retval) {\n\t\t\tfree_irq(up->port.irq, up);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tdev_dbg(up->port.dev, \"serial_omap_startup+%d\\n\", up->port.line);\n\n\tpm_runtime_get_sync(up->dev);\n\t \n\tserial_omap_clear_fifos(up);\n\n\t \n\t(void) serial_in(up, UART_LSR);\n\tif (serial_in(up, UART_LSR) & UART_LSR_DR)\n\t\t(void) serial_in(up, UART_RX);\n\t(void) serial_in(up, UART_IIR);\n\t(void) serial_in(up, UART_MSR);\n\n\t \n\tserial_out(up, UART_LCR, UART_LCR_WLEN8);\n\tspin_lock_irqsave(&up->port.lock, flags);\n\t \n\tup->port.mctrl |= TIOCM_OUT2;\n\tserial_omap_set_mctrl(&up->port, up->port.mctrl);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\tup->msr_saved_flags = 0;\n\t \n\tup->ier = UART_IER_RLSI | UART_IER_RDI;\n\tserial_out(up, UART_IER, up->ier);\n\n\t \n\tup->wer = OMAP_UART_WER_MOD_WKUP;\n\tif (up->features & OMAP_UART_WER_HAS_TX_WAKEUP)\n\t\tup->wer |= OMAP_UART_TX_WAKEUP_EN;\n\n\tserial_out(up, UART_OMAP_WER, up->wer);\n\n\tup->port_activity = jiffies;\n\treturn 0;\n}\n\nstatic void serial_omap_shutdown(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned long flags;\n\n\tdev_dbg(up->port.dev, \"serial_omap_shutdown+%d\\n\", up->port.line);\n\n\t \n\tup->ier = 0;\n\tserial_out(up, UART_IER, 0);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tup->port.mctrl &= ~TIOCM_OUT2;\n\tserial_omap_set_mctrl(&up->port, up->port.mctrl);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\t \n\tserial_out(up, UART_LCR, serial_in(up, UART_LCR) & ~UART_LCR_SBC);\n\tserial_omap_clear_fifos(up);\n\n\t \n\tif (serial_in(up, UART_LSR) & UART_LSR_DR)\n\t\t(void) serial_in(up, UART_RX);\n\n\tpm_runtime_put_sync(up->dev);\n\tfree_irq(up->port.irq, up);\n\tdev_pm_clear_wake_irq(up->dev);\n}\n\nstatic void serial_omap_uart_qos_work(struct work_struct *work)\n{\n\tstruct uart_omap_port *up = container_of(work, struct uart_omap_port,\n\t\t\t\t\t\tqos_work);\n\n\tcpu_latency_qos_update_request(&up->pm_qos_request, up->latency);\n}\n\nstatic void\nserial_omap_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t\tconst struct ktermios *old)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned char cval = 0;\n\tunsigned long flags;\n\tunsigned int baud, quot;\n\n\tcval = UART_LCR_WLEN(tty_get_char_size(termios->c_cflag));\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tcval |= UART_LCR_STOP;\n\tif (termios->c_cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(termios->c_cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\tif (termios->c_cflag & CMSPAR)\n\t\tcval |= UART_LCR_SPAR;\n\n\t \n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/13);\n\tquot = serial_omap_get_divisor(port, baud);\n\n\t \n\tup->calc_latency = (USEC_PER_SEC * up->port.fifosize) / (baud / 8);\n\tup->latency = up->calc_latency;\n\tschedule_work(&up->qos_work);\n\n\tup->dll = quot & 0xff;\n\tup->dlh = quot >> 8;\n\tup->mdr1 = UART_OMAP_MDR1_DISABLE;\n\n\tup->fcr = UART_FCR_R_TRIG_01 | UART_FCR_T_TRIG_01 |\n\t\t\tUART_FCR_ENABLE_FIFO;\n\n\t \n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tup->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\n\tif (termios->c_iflag & INPCK)\n\t\tup->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tup->port.read_status_mask |= UART_LSR_BI;\n\n\t \n\tup->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tup->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tup->port.ignore_status_mask |= UART_LSR_BI;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tup->port.ignore_status_mask |= UART_LSR_OE;\n\t}\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tup->port.ignore_status_mask |= UART_LSR_DR;\n\n\t \n\tup->ier &= ~UART_IER_MSI;\n\tif (UART_ENABLE_MS(&up->port, termios->c_cflag))\n\t\tup->ier |= UART_IER_MSI;\n\tserial_out(up, UART_IER, up->ier);\n\tserial_out(up, UART_LCR, cval);\t\t \n\tup->lcr = cval;\n\tup->scr = 0;\n\n\t \n\n\t \n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\n\tserial_out(up, UART_DLL, 0);\n\tserial_out(up, UART_DLM, 0);\n\tserial_out(up, UART_LCR, 0);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\n\tup->efr = serial_in(up, UART_EFR) & ~UART_EFR_ECB;\n\tup->efr &= ~UART_EFR_SCD;\n\tserial_out(up, UART_EFR, up->efr | UART_EFR_ECB);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\n\tup->mcr = serial_in(up, UART_MCR) & ~UART_MCR_TCRTLR;\n\tserial_out(up, UART_MCR, up->mcr | UART_MCR_TCRTLR);\n\t \n\n\tup->scr |= OMAP_UART_SCR_RX_TRIG_GRANU1_MASK;\n\t \n\n\t \n\tup->fcr &= ~OMAP_UART_FCR_RX_FIFO_TRIG_MASK;\n\tup->fcr &= ~OMAP_UART_FCR_TX_FIFO_TRIG_MASK;\n\tup->fcr |= UART_FCR6_R_TRIGGER_16 | UART_FCR6_T_TRIGGER_24 |\n\t\tUART_FCR_ENABLE_FIFO;\n\n\tserial_out(up, UART_FCR, up->fcr);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\n\tserial_out(up, UART_OMAP_SCR, up->scr);\n\n\t \n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\n\tserial_out(up, UART_MCR, up->mcr);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_out(up, UART_EFR, up->efr);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\n\n\t \n\n\tif (up->errata & UART_ERRATA_i202_MDR1_ACCESS)\n\t\tserial_omap_mdr1_errataset(up, up->mdr1);\n\telse\n\t\tserial_out(up, UART_OMAP_MDR1, up->mdr1);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_out(up, UART_EFR, up->efr | UART_EFR_ECB);\n\n\tserial_out(up, UART_LCR, 0);\n\tserial_out(up, UART_IER, 0);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\n\tserial_out(up, UART_DLL, up->dll);\t \n\tserial_out(up, UART_DLM, up->dlh);\t \n\n\tserial_out(up, UART_LCR, 0);\n\tserial_out(up, UART_IER, up->ier);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\n\tserial_out(up, UART_EFR, up->efr);\n\tserial_out(up, UART_LCR, cval);\n\n\tif (!serial_omap_baud_is_mode16(port, baud))\n\t\tup->mdr1 = UART_OMAP_MDR1_13X_MODE;\n\telse\n\t\tup->mdr1 = UART_OMAP_MDR1_16X_MODE;\n\n\tif (up->errata & UART_ERRATA_i202_MDR1_ACCESS)\n\t\tserial_omap_mdr1_errataset(up, up->mdr1);\n\telse\n\t\tserial_out(up, UART_OMAP_MDR1, up->mdr1);\n\n\t \n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\n\t \n\tserial_out(up, UART_XON1, termios->c_cc[VSTART]);\n\tserial_out(up, UART_XOFF1, termios->c_cc[VSTOP]);\n\n\t \n\tserial_out(up, UART_EFR, up->efr | UART_EFR_ECB);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\n\tserial_out(up, UART_MCR, up->mcr | UART_MCR_TCRTLR);\n\n\tserial_out(up, UART_TI752_TCR, OMAP_UART_TCR_TRIG);\n\n\tup->port.status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS | UPSTAT_AUTOXOFF);\n\n\tif (termios->c_cflag & CRTSCTS && up->port.flags & UPF_HARD_FLOW) {\n\t\t \n\t\tup->port.status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;\n\t\tup->efr |= UART_EFR_CTS;\n\t} else {\n\t\t \n\t\tup->efr &= ~(UART_EFR_CTS | UART_EFR_RTS);\n\t}\n\n\tif (up->port.flags & UPF_SOFT_FLOW) {\n\t\t \n\t\tup->efr &= OMAP_UART_SW_CLR;\n\n\t\t \n\t\tif (termios->c_iflag & IXON)\n\t\t\tup->efr |= OMAP_UART_SW_RX;\n\n\t\t \n\t\tif (termios->c_iflag & IXOFF) {\n\t\t\tup->port.status |= UPSTAT_AUTOXOFF;\n\t\t\tup->efr |= OMAP_UART_SW_TX;\n\t\t}\n\n\t\t \n\t\tif (termios->c_iflag & IXANY)\n\t\t\tup->mcr |= UART_MCR_XONANY;\n\t\telse\n\t\t\tup->mcr &= ~UART_MCR_XONANY;\n\t}\n\tserial_out(up, UART_MCR, up->mcr);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_out(up, UART_EFR, up->efr);\n\tserial_out(up, UART_LCR, up->lcr);\n\n\tserial_omap_set_mctrl(&up->port, up->port.mctrl);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\tdev_dbg(up->port.dev, \"serial_omap_set_termios+%d\\n\", up->port.line);\n}\n\nstatic void\nserial_omap_pm(struct uart_port *port, unsigned int state,\n\t       unsigned int oldstate)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned char efr;\n\n\tdev_dbg(up->port.dev, \"serial_omap_pm+%d\\n\", up->port.line);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tefr = serial_in(up, UART_EFR);\n\tserial_out(up, UART_EFR, efr | UART_EFR_ECB);\n\tserial_out(up, UART_LCR, 0);\n\n\tserial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_out(up, UART_EFR, efr);\n\tserial_out(up, UART_LCR, 0);\n}\n\nstatic void serial_omap_release_port(struct uart_port *port)\n{\n\tdev_dbg(port->dev, \"serial_omap_release_port+\\n\");\n}\n\nstatic int serial_omap_request_port(struct uart_port *port)\n{\n\tdev_dbg(port->dev, \"serial_omap_request_port+\\n\");\n\treturn 0;\n}\n\nstatic void serial_omap_config_port(struct uart_port *port, int flags)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\n\tdev_dbg(up->port.dev, \"serial_omap_config_port+%d\\n\",\n\t\t\t\t\t\t\tup->port.line);\n\tup->port.type = PORT_OMAP;\n\tup->port.flags |= UPF_SOFT_FLOW | UPF_HARD_FLOW;\n}\n\nstatic int\nserial_omap_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\t \n\tdev_dbg(port->dev, \"serial_omap_verify_port+\\n\");\n\treturn -EINVAL;\n}\n\nstatic const char *\nserial_omap_type(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\n\tdev_dbg(up->port.dev, \"serial_omap_type+%d\\n\", up->port.line);\n\treturn up->name;\n}\n\nstatic void __maybe_unused wait_for_xmitr(struct uart_omap_port *up)\n{\n\tunsigned int status, tmout = 10000;\n\n\t \n\tdo {\n\t\tstatus = serial_in(up, UART_LSR);\n\n\t\tif (status & UART_LSR_BI)\n\t\t\tup->lsr_break_flag = UART_LSR_BI;\n\n\t\tif (--tmout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (!uart_lsr_tx_empty(status));\n\n\t \n\tif (up->port.flags & UPF_CONS_FLOW) {\n\t\ttmout = 1000000;\n\t\tfor (tmout = 1000000; tmout; tmout--) {\n\t\t\tunsigned int msr = serial_in(up, UART_MSR);\n\n\t\t\tup->msr_saved_flags |= msr & MSR_SAVE_FLAGS;\n\t\t\tif (msr & UART_MSR_CTS)\n\t\t\t\tbreak;\n\n\t\t\tudelay(1);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n\nstatic void serial_omap_poll_put_char(struct uart_port *port, unsigned char ch)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\n\twait_for_xmitr(up);\n\tserial_out(up, UART_TX, ch);\n}\n\nstatic int serial_omap_poll_get_char(struct uart_port *port)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned int status;\n\n\tstatus = serial_in(up, UART_LSR);\n\tif (!(status & UART_LSR_DR)) {\n\t\tstatus = NO_POLL_CHAR;\n\t\tgoto out;\n\t}\n\n\tstatus = serial_in(up, UART_RX);\n\nout:\n\treturn status;\n}\n\n#endif  \n\n#ifdef CONFIG_SERIAL_OMAP_CONSOLE\n\n#ifdef CONFIG_SERIAL_EARLYCON\nstatic unsigned int omap_serial_early_in(struct uart_port *port, int offset)\n{\n\toffset <<= port->regshift;\n\treturn readw(port->membase + offset);\n}\n\nstatic void omap_serial_early_out(struct uart_port *port, int offset,\n\t\t\t\t  int value)\n{\n\toffset <<= port->regshift;\n\twritew(value, port->membase + offset);\n}\n\nstatic void omap_serial_early_putc(struct uart_port *port, unsigned char c)\n{\n\tunsigned int status;\n\n\tfor (;;) {\n\t\tstatus = omap_serial_early_in(port, UART_LSR);\n\t\tif (uart_lsr_tx_empty(status))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\tomap_serial_early_out(port, UART_TX, c);\n}\n\nstatic void early_omap_serial_write(struct console *console, const char *s,\n\t\t\t\t    unsigned int count)\n{\n\tstruct earlycon_device *device = console->data;\n\tstruct uart_port *port = &device->port;\n\n\tuart_console_write(port, s, count, omap_serial_early_putc);\n}\n\nstatic int __init early_omap_serial_setup(struct earlycon_device *device,\n\t\t\t\t\t  const char *options)\n{\n\tstruct uart_port *port = &device->port;\n\n\tif (!(device->port.membase || device->port.iobase))\n\t\treturn -ENODEV;\n\n\tport->regshift = 2;\n\tdevice->con->write = early_omap_serial_write;\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(omapserial, \"ti,omap2-uart\", early_omap_serial_setup);\nOF_EARLYCON_DECLARE(omapserial, \"ti,omap3-uart\", early_omap_serial_setup);\nOF_EARLYCON_DECLARE(omapserial, \"ti,omap4-uart\", early_omap_serial_setup);\n#endif  \n\nstatic struct uart_omap_port *serial_omap_console_ports[OMAP_MAX_HSUART_PORTS];\n\nstatic struct uart_driver serial_omap_reg;\n\nstatic void serial_omap_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\n\twait_for_xmitr(up);\n\tserial_out(up, UART_TX, ch);\n}\n\nstatic void\nserial_omap_console_write(struct console *co, const char *s,\n\t\tunsigned int count)\n{\n\tstruct uart_omap_port *up = serial_omap_console_ports[co->index];\n\tunsigned long flags;\n\tunsigned int ier;\n\tint locked = 1;\n\n\tlocal_irq_save(flags);\n\tif (up->port.sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock(&up->port.lock);\n\telse\n\t\tspin_lock(&up->port.lock);\n\n\t \n\tier = serial_in(up, UART_IER);\n\tserial_out(up, UART_IER, 0);\n\n\tuart_console_write(&up->port, s, count, serial_omap_console_putchar);\n\n\t \n\twait_for_xmitr(up);\n\tserial_out(up, UART_IER, ier);\n\t \n\tif (up->msr_saved_flags)\n\t\tcheck_modem_status(up);\n\n\tif (locked)\n\t\tspin_unlock(&up->port.lock);\n\tlocal_irq_restore(flags);\n}\n\nstatic int __init\nserial_omap_console_setup(struct console *co, char *options)\n{\n\tstruct uart_omap_port *up;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (serial_omap_console_ports[co->index] == NULL)\n\t\treturn -ENODEV;\n\tup = serial_omap_console_ports[co->index];\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&up->port, co, baud, parity, bits, flow);\n}\n\nstatic struct console serial_omap_console = {\n\t.name\t\t= OMAP_SERIAL_NAME,\n\t.write\t\t= serial_omap_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= serial_omap_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &serial_omap_reg,\n};\n\nstatic void serial_omap_add_console_port(struct uart_omap_port *up)\n{\n\tserial_omap_console_ports[up->port.line] = up;\n}\n\n#define OMAP_CONSOLE\t(&serial_omap_console)\n\n#else\n\n#define OMAP_CONSOLE\tNULL\n\nstatic inline void serial_omap_add_console_port(struct uart_omap_port *up)\n{}\n\n#endif\n\n \nstatic int\nserial_omap_config_rs485(struct uart_port *port, struct ktermios *termios,\n\t\t\t struct serial_rs485 *rs485)\n{\n\tstruct uart_omap_port *up = to_uart_omap_port(port);\n\tunsigned int mode;\n\tint val;\n\n\t \n\tmode = up->ier;\n\tup->ier = 0;\n\tserial_out(up, UART_IER, 0);\n\n\t \n\tval = (rs485->flags & SER_RS485_ENABLED) ?\n\t      SER_RS485_RTS_AFTER_SEND : SER_RS485_RTS_ON_SEND;\n\tval = (rs485->flags & val) ? 1 : 0;\n\tgpiod_set_value(up->rts_gpiod, val);\n\n\t \n\tup->ier = mode;\n\tserial_out(up, UART_IER, up->ier);\n\n\t \n\tif (!(rs485->flags & SER_RS485_ENABLED) &&\n\t    (up->scr & OMAP_UART_SCR_TX_EMPTY)) {\n\t\tup->scr &= ~OMAP_UART_SCR_TX_EMPTY;\n\t\tserial_out(up, UART_OMAP_SCR, up->scr);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct uart_ops serial_omap_pops = {\n\t.tx_empty\t= serial_omap_tx_empty,\n\t.set_mctrl\t= serial_omap_set_mctrl,\n\t.get_mctrl\t= serial_omap_get_mctrl,\n\t.stop_tx\t= serial_omap_stop_tx,\n\t.start_tx\t= serial_omap_start_tx,\n\t.throttle\t= serial_omap_throttle,\n\t.unthrottle\t= serial_omap_unthrottle,\n\t.stop_rx\t= serial_omap_stop_rx,\n\t.enable_ms\t= serial_omap_enable_ms,\n\t.break_ctl\t= serial_omap_break_ctl,\n\t.startup\t= serial_omap_startup,\n\t.shutdown\t= serial_omap_shutdown,\n\t.set_termios\t= serial_omap_set_termios,\n\t.pm\t\t= serial_omap_pm,\n\t.type\t\t= serial_omap_type,\n\t.release_port\t= serial_omap_release_port,\n\t.request_port\t= serial_omap_request_port,\n\t.config_port\t= serial_omap_config_port,\n\t.verify_port\t= serial_omap_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_put_char  = serial_omap_poll_put_char,\n\t.poll_get_char  = serial_omap_poll_get_char,\n#endif\n};\n\nstatic struct uart_driver serial_omap_reg = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"OMAP-SERIAL\",\n\t.dev_name\t= OMAP_SERIAL_NAME,\n\t.nr\t\t= OMAP_MAX_HSUART_PORTS,\n\t.cons\t\t= OMAP_CONSOLE,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int serial_omap_prepare(struct device *dev)\n{\n\tstruct uart_omap_port *up = dev_get_drvdata(dev);\n\n\tup->is_suspending = true;\n\n\treturn 0;\n}\n\nstatic void serial_omap_complete(struct device *dev)\n{\n\tstruct uart_omap_port *up = dev_get_drvdata(dev);\n\n\tup->is_suspending = false;\n}\n\nstatic int serial_omap_suspend(struct device *dev)\n{\n\tstruct uart_omap_port *up = dev_get_drvdata(dev);\n\n\tuart_suspend_port(&serial_omap_reg, &up->port);\n\tflush_work(&up->qos_work);\n\n\tif (device_may_wakeup(dev))\n\t\tserial_omap_enable_wakeup(up, true);\n\telse\n\t\tserial_omap_enable_wakeup(up, false);\n\n\treturn 0;\n}\n\nstatic int serial_omap_resume(struct device *dev)\n{\n\tstruct uart_omap_port *up = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tserial_omap_enable_wakeup(up, false);\n\n\tuart_resume_port(&serial_omap_reg, &up->port);\n\n\treturn 0;\n}\n#else\n#define serial_omap_prepare NULL\n#define serial_omap_complete NULL\n#endif  \n\nstatic void omap_serial_fill_features_erratas(struct uart_omap_port *up)\n{\n\tu32 mvr, scheme;\n\tu16 revision, major, minor;\n\n\tmvr = readl(up->port.membase + (UART_OMAP_MVER << up->port.regshift));\n\n\t \n\tscheme = mvr >> OMAP_UART_MVR_SCHEME_SHIFT;\n\n\tswitch (scheme) {\n\tcase 0:  \n\t\t \n\t\tmajor = (mvr & OMAP_UART_LEGACY_MVR_MAJ_MASK) >>\n\t\t\t\t\tOMAP_UART_LEGACY_MVR_MAJ_SHIFT;\n\t\tminor = (mvr & OMAP_UART_LEGACY_MVR_MIN_MASK);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\t \n\t\tmajor = (mvr & OMAP_UART_MVR_MAJ_MASK) >>\n\t\t\t\t\tOMAP_UART_MVR_MAJ_SHIFT;\n\t\tminor = (mvr & OMAP_UART_MVR_MIN_MASK);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(up->dev,\n\t\t\t\"Unknown %s revision, defaulting to highest\\n\",\n\t\t\tup->name);\n\t\t \n\t\tmajor = 0xff;\n\t\tminor = 0xff;\n\t}\n\n\t \n\trevision = UART_BUILD_REVISION(major, minor);\n\n\tswitch (revision) {\n\tcase OMAP_UART_REV_46:\n\t\tup->errata |= (UART_ERRATA_i202_MDR1_ACCESS |\n\t\t\t\tUART_ERRATA_i291_DMA_FORCEIDLE);\n\t\tbreak;\n\tcase OMAP_UART_REV_52:\n\t\tup->errata |= (UART_ERRATA_i202_MDR1_ACCESS |\n\t\t\t\tUART_ERRATA_i291_DMA_FORCEIDLE);\n\t\tup->features |= OMAP_UART_WER_HAS_TX_WAKEUP;\n\t\tbreak;\n\tcase OMAP_UART_REV_63:\n\t\tup->errata |= UART_ERRATA_i202_MDR1_ACCESS;\n\t\tup->features |= OMAP_UART_WER_HAS_TX_WAKEUP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic struct omap_uart_port_info *of_get_uart_port_info(struct device *dev)\n{\n\tstruct omap_uart_port_info *omap_up_info;\n\n\tomap_up_info = devm_kzalloc(dev, sizeof(*omap_up_info), GFP_KERNEL);\n\tif (!omap_up_info)\n\t\treturn NULL;  \n\n\tof_property_read_u32(dev->of_node, \"clock-frequency\",\n\t\t\t\t\t &omap_up_info->uartclk);\n\n\tomap_up_info->flags = UPF_BOOT_AUTOCONF;\n\n\treturn omap_up_info;\n}\n\nstatic const struct serial_rs485 serial_omap_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | SER_RS485_RTS_AFTER_SEND |\n\t\t SER_RS485_RX_DURING_TX,\n\t.delay_rts_before_send = 1,\n\t.delay_rts_after_send = 1,\n};\n\nstatic int serial_omap_probe_rs485(struct uart_omap_port *up,\n\t\t\t\t   struct device *dev)\n{\n\tstruct serial_rs485 *rs485conf = &up->port.rs485;\n\tstruct device_node *np = dev->of_node;\n\tenum gpiod_flags gflags;\n\tint ret;\n\n\trs485conf->flags = 0;\n\tup->rts_gpiod = NULL;\n\n\tif (!np)\n\t\treturn 0;\n\n\tup->port.rs485_config = serial_omap_config_rs485;\n\tup->port.rs485_supported = serial_omap_rs485_supported;\n\n\tret = uart_get_rs485_mode(&up->port);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_property_read_bool(np, \"rs485-rts-active-high\")) {\n\t\trs485conf->flags |= SER_RS485_RTS_ON_SEND;\n\t\trs485conf->flags &= ~SER_RS485_RTS_AFTER_SEND;\n\t} else {\n\t\trs485conf->flags &= ~SER_RS485_RTS_ON_SEND;\n\t\trs485conf->flags |= SER_RS485_RTS_AFTER_SEND;\n\t}\n\n\t \n\tgflags = rs485conf->flags & SER_RS485_RTS_AFTER_SEND ?\n\t\tGPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\tup->rts_gpiod = devm_gpiod_get_optional(dev, \"rts\", gflags);\n\tif (IS_ERR(up->rts_gpiod)) {\n\t\tret = PTR_ERR(up->rts_gpiod);\n\t        if (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\tup->rts_gpiod = NULL;\n\t\tup->port.rs485_supported = (const struct serial_rs485) { };\n\t\tif (rs485conf->flags & SER_RS485_ENABLED) {\n\t\t\tdev_err(dev, \"disabling RS-485 (rts-gpio missing in device tree)\\n\");\n\t\t\tmemset(rs485conf, 0, sizeof(*rs485conf));\n\t\t}\n\t} else {\n\t\tgpiod_set_consumer_name(up->rts_gpiod, \"omap-serial\");\n\t}\n\n\treturn 0;\n}\n\nstatic int serial_omap_probe(struct platform_device *pdev)\n{\n\tstruct omap_uart_port_info *omap_up_info = dev_get_platdata(&pdev->dev);\n\tstruct uart_omap_port *up;\n\tstruct resource *mem;\n\tvoid __iomem *base;\n\tint uartirq = 0;\n\tint wakeirq = 0;\n\tint ret;\n\n\t \n\tif (pdev->dev.of_node) {\n\t\tuartirq = irq_of_parse_and_map(pdev->dev.of_node, 0);\n\t\tif (!uartirq)\n\t\t\treturn -EPROBE_DEFER;\n\t\twakeirq = irq_of_parse_and_map(pdev->dev.of_node, 1);\n\t\tomap_up_info = of_get_uart_port_info(&pdev->dev);\n\t\tpdev->dev.platform_data = omap_up_info;\n\t} else {\n\t\tuartirq = platform_get_irq(pdev, 0);\n\t\tif (uartirq < 0)\n\t\t\treturn -EPROBE_DEFER;\n\t}\n\n\tup = devm_kzalloc(&pdev->dev, sizeof(*up), GFP_KERNEL);\n\tif (!up)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tup->dev = &pdev->dev;\n\tup->port.dev = &pdev->dev;\n\tup->port.type = PORT_OMAP;\n\tup->port.iotype = UPIO_MEM;\n\tup->port.irq = uartirq;\n\tup->port.regshift = 2;\n\tup->port.fifosize = 64;\n\tup->port.ops = &serial_omap_pops;\n\tup->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_OMAP_CONSOLE);\n\n\tif (pdev->dev.of_node)\n\t\tret = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\telse\n\t\tret = pdev->id;\n\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias/pdev id, errno %d\\n\",\n\t\t\tret);\n\t\tgoto err_port_line;\n\t}\n\tup->port.line = ret;\n\n\tif (up->port.line >= OMAP_MAX_HSUART_PORTS) {\n\t\tdev_err(&pdev->dev, \"uart ID %d >  MAX %d.\\n\", up->port.line,\n\t\t\tOMAP_MAX_HSUART_PORTS);\n\t\tret = -ENXIO;\n\t\tgoto err_port_line;\n\t}\n\n\tup->wakeirq = wakeirq;\n\tif (!up->wakeirq)\n\t\tdev_info(up->port.dev, \"no wakeirq for uart%d\\n\",\n\t\t\t up->port.line);\n\n\tsprintf(up->name, \"OMAP UART%d\", up->port.line);\n\tup->port.mapbase = mem->start;\n\tup->port.membase = base;\n\tup->port.flags = omap_up_info->flags;\n\tup->port.uartclk = omap_up_info->uartclk;\n\tif (!up->port.uartclk) {\n\t\tup->port.uartclk = DEFAULT_CLK_SPEED;\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"No clock speed specified: using default: %d\\n\",\n\t\t\t DEFAULT_CLK_SPEED);\n\t}\n\n\tret = serial_omap_probe_rs485(up, &pdev->dev);\n\tif (ret < 0)\n\t\tgoto err_rs485;\n\n\tup->latency = PM_QOS_CPU_LATENCY_DEFAULT_VALUE;\n\tup->calc_latency = PM_QOS_CPU_LATENCY_DEFAULT_VALUE;\n\tcpu_latency_qos_add_request(&up->pm_qos_request, up->latency);\n\tINIT_WORK(&up->qos_work, serial_omap_uart_qos_work);\n\n\tplatform_set_drvdata(pdev, up);\n\tif (omap_up_info->autosuspend_timeout == 0)\n\t\tomap_up_info->autosuspend_timeout = -1;\n\n\tdevice_init_wakeup(up->dev, true);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tomap_serial_fill_features_erratas(up);\n\n\tui[up->port.line] = up;\n\tserial_omap_add_console_port(up);\n\n\tret = uart_add_one_port(&serial_omap_reg, &up->port);\n\tif (ret != 0)\n\t\tgoto err_add_port;\n\n\treturn 0;\n\nerr_add_port:\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tcpu_latency_qos_remove_request(&up->pm_qos_request);\n\tdevice_init_wakeup(up->dev, false);\nerr_rs485:\nerr_port_line:\n\treturn ret;\n}\n\nstatic int serial_omap_remove(struct platform_device *dev)\n{\n\tstruct uart_omap_port *up = platform_get_drvdata(dev);\n\n\tpm_runtime_get_sync(up->dev);\n\n\tuart_remove_one_port(&serial_omap_reg, &up->port);\n\n\tpm_runtime_put_sync(up->dev);\n\tpm_runtime_disable(up->dev);\n\tcpu_latency_qos_remove_request(&up->pm_qos_request);\n\tdevice_init_wakeup(&dev->dev, false);\n\n\treturn 0;\n}\n\n \nstatic void serial_omap_mdr1_errataset(struct uart_omap_port *up, u8 mdr1)\n{\n\tu8 timeout = 255;\n\n\tserial_out(up, UART_OMAP_MDR1, mdr1);\n\tudelay(2);\n\tserial_out(up, UART_FCR, up->fcr | UART_FCR_CLEAR_XMIT |\n\t\t\tUART_FCR_CLEAR_RCVR);\n\t \n\twhile (UART_LSR_THRE != (serial_in(up, UART_LSR) &\n\t\t\t\t(UART_LSR_THRE | UART_LSR_DR))) {\n\t\ttimeout--;\n\t\tif (!timeout) {\n\t\t\t \n\t\t\tdev_crit(up->dev, \"Errata i202: timedout %x\\n\",\n\t\t\t\t\t\tserial_in(up, UART_LSR));\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic void serial_omap_restore_context(struct uart_omap_port *up)\n{\n\tif (up->errata & UART_ERRATA_i202_MDR1_ACCESS)\n\t\tserial_omap_mdr1_errataset(up, UART_OMAP_MDR1_DISABLE);\n\telse\n\t\tserial_out(up, UART_OMAP_MDR1, UART_OMAP_MDR1_DISABLE);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);  \n\tserial_out(up, UART_EFR, UART_EFR_ECB);\n\tserial_out(up, UART_LCR, 0x0);  \n\tserial_out(up, UART_IER, 0x0);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);  \n\tserial_out(up, UART_DLL, up->dll);\n\tserial_out(up, UART_DLM, up->dlh);\n\tserial_out(up, UART_LCR, 0x0);  \n\tserial_out(up, UART_IER, up->ier);\n\tserial_out(up, UART_FCR, up->fcr);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\n\tserial_out(up, UART_MCR, up->mcr);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);  \n\tserial_out(up, UART_OMAP_SCR, up->scr);\n\tserial_out(up, UART_EFR, up->efr);\n\tserial_out(up, UART_LCR, up->lcr);\n\tif (up->errata & UART_ERRATA_i202_MDR1_ACCESS)\n\t\tserial_omap_mdr1_errataset(up, up->mdr1);\n\telse\n\t\tserial_out(up, UART_OMAP_MDR1, up->mdr1);\n\tserial_out(up, UART_OMAP_WER, up->wer);\n}\n\nstatic int serial_omap_runtime_suspend(struct device *dev)\n{\n\tstruct uart_omap_port *up = dev_get_drvdata(dev);\n\n\tif (!up)\n\t\treturn -EINVAL;\n\n\t \n\tif (up->is_suspending && !console_suspend_enabled &&\n\t    uart_console(&up->port))\n\t\treturn -EBUSY;\n\n\tup->context_loss_cnt = serial_omap_get_context_loss_count(up);\n\n\tserial_omap_enable_wakeup(up, true);\n\n\tup->latency = PM_QOS_CPU_LATENCY_DEFAULT_VALUE;\n\tschedule_work(&up->qos_work);\n\n\treturn 0;\n}\n\nstatic int serial_omap_runtime_resume(struct device *dev)\n{\n\tstruct uart_omap_port *up = dev_get_drvdata(dev);\n\n\tint loss_cnt = serial_omap_get_context_loss_count(up);\n\n\tserial_omap_enable_wakeup(up, false);\n\n\tif (loss_cnt < 0) {\n\t\tdev_dbg(dev, \"serial_omap_get_context_loss_count failed : %d\\n\",\n\t\t\tloss_cnt);\n\t\tserial_omap_restore_context(up);\n\t} else if (up->context_loss_cnt != loss_cnt) {\n\t\tserial_omap_restore_context(up);\n\t}\n\tup->latency = up->calc_latency;\n\tschedule_work(&up->qos_work);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops serial_omap_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(serial_omap_suspend, serial_omap_resume)\n\tSET_RUNTIME_PM_OPS(serial_omap_runtime_suspend,\n\t\t\t\tserial_omap_runtime_resume, NULL)\n\t.prepare        = serial_omap_prepare,\n\t.complete       = serial_omap_complete,\n};\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id omap_serial_of_match[] = {\n\t{ .compatible = \"ti,omap2-uart\" },\n\t{ .compatible = \"ti,omap3-uart\" },\n\t{ .compatible = \"ti,omap4-uart\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_serial_of_match);\n#endif\n\nstatic struct platform_driver serial_omap_driver = {\n\t.probe          = serial_omap_probe,\n\t.remove         = serial_omap_remove,\n\t.driver\t\t= {\n\t\t.name\t= OMAP_SERIAL_DRIVER_NAME,\n\t\t.pm\t= &serial_omap_dev_pm_ops,\n\t\t.of_match_table = of_match_ptr(omap_serial_of_match),\n\t},\n};\n\nstatic int __init serial_omap_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&serial_omap_reg);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = platform_driver_register(&serial_omap_driver);\n\tif (ret != 0)\n\t\tuart_unregister_driver(&serial_omap_reg);\n\treturn ret;\n}\n\nstatic void __exit serial_omap_exit(void)\n{\n\tplatform_driver_unregister(&serial_omap_driver);\n\tuart_unregister_driver(&serial_omap_reg);\n}\n\nmodule_init(serial_omap_init);\nmodule_exit(serial_omap_exit);\n\nMODULE_DESCRIPTION(\"OMAP High Speed UART driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Texas Instruments Inc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}