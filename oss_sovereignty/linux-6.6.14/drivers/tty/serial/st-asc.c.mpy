{
  "module_name": "st-asc.c",
  "hash_id": "a81e2b4048aa963440254fd9d05a17a3792723bd41a7599ced6fc2b0a8b904bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/st-asc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/serial.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/serial_core.h>\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n\n#define DRIVER_NAME \"st-asc\"\n#define ASC_SERIAL_NAME \"ttyAS\"\n#define ASC_FIFO_SIZE 16\n#define ASC_MAX_PORTS 8\n\n \n#define DEFAULT\t\t0\n#define NO_HW_FLOWCTRL\t1\n\nstruct asc_port {\n\tstruct uart_port port;\n\tstruct gpio_desc *rts;\n\tstruct clk *clk;\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *states[2];\n\tunsigned int hw_flow_control:1;\n\tunsigned int force_m1:1;\n};\n\nstatic struct asc_port asc_ports[ASC_MAX_PORTS];\nstatic struct uart_driver asc_uart_driver;\n\n \n\n \n\n#define ASC_BAUDRATE\t\t\t0x00\n#define ASC_TXBUF\t\t\t0x04\n#define ASC_RXBUF\t\t\t0x08\n#define ASC_CTL\t\t\t\t0x0C\n#define ASC_INTEN\t\t\t0x10\n#define ASC_STA\t\t\t\t0x14\n#define ASC_GUARDTIME\t\t\t0x18\n#define ASC_TIMEOUT\t\t\t0x1C\n#define ASC_TXRESET\t\t\t0x20\n#define ASC_RXRESET\t\t\t0x24\n#define ASC_RETRIES\t\t\t0x28\n\n \n#define ASC_RXBUF_PE\t\t\t0x100\n#define ASC_RXBUF_FE\t\t\t0x200\n \n#define ASC_RXBUF_DUMMY_RX\t\t0x10000\n#define ASC_RXBUF_DUMMY_BE\t\t0x20000\n#define ASC_RXBUF_DUMMY_OE\t\t0x40000\n\n \n\n#define ASC_CTL_MODE_MSK\t\t0x0007\n#define  ASC_CTL_MODE_8BIT\t\t0x0001\n#define  ASC_CTL_MODE_7BIT_PAR\t\t0x0003\n#define  ASC_CTL_MODE_9BIT\t\t0x0004\n#define  ASC_CTL_MODE_8BIT_WKUP\t\t0x0005\n#define  ASC_CTL_MODE_8BIT_PAR\t\t0x0007\n#define ASC_CTL_STOP_MSK\t\t0x0018\n#define  ASC_CTL_STOP_HALFBIT\t\t0x0000\n#define  ASC_CTL_STOP_1BIT\t\t0x0008\n#define  ASC_CTL_STOP_1_HALFBIT\t\t0x0010\n#define  ASC_CTL_STOP_2BIT\t\t0x0018\n#define ASC_CTL_PARITYODD\t\t0x0020\n#define ASC_CTL_LOOPBACK\t\t0x0040\n#define ASC_CTL_RUN\t\t\t0x0080\n#define ASC_CTL_RXENABLE\t\t0x0100\n#define ASC_CTL_SCENABLE\t\t0x0200\n#define ASC_CTL_FIFOENABLE\t\t0x0400\n#define ASC_CTL_CTSENABLE\t\t0x0800\n#define ASC_CTL_BAUDMODE\t\t0x1000\n\n \n\n#define ASC_GUARDTIME_MSK\t\t0x00FF\n\n \n\n#define ASC_INTEN_RBE\t\t\t0x0001\n#define ASC_INTEN_TE\t\t\t0x0002\n#define ASC_INTEN_THE\t\t\t0x0004\n#define ASC_INTEN_PE\t\t\t0x0008\n#define ASC_INTEN_FE\t\t\t0x0010\n#define ASC_INTEN_OE\t\t\t0x0020\n#define ASC_INTEN_TNE\t\t\t0x0040\n#define ASC_INTEN_TOI\t\t\t0x0080\n#define ASC_INTEN_RHF\t\t\t0x0100\n\n \n\n#define ASC_RETRIES_MSK\t\t\t0x00FF\n\n \n\n#define ASC_RXBUF_MSK\t\t\t0x03FF\n\n \n\n#define ASC_STA_RBF\t\t\t0x0001\n#define ASC_STA_TE\t\t\t0x0002\n#define ASC_STA_THE\t\t\t0x0004\n#define ASC_STA_PE\t\t\t0x0008\n#define ASC_STA_FE\t\t\t0x0010\n#define ASC_STA_OE\t\t\t0x0020\n#define ASC_STA_TNE\t\t\t0x0040\n#define ASC_STA_TOI\t\t\t0x0080\n#define ASC_STA_RHF\t\t\t0x0100\n#define ASC_STA_TF\t\t\t0x0200\n#define ASC_STA_NKD\t\t\t0x0400\n\n \n\n#define ASC_TIMEOUT_MSK\t\t\t0x00FF\n\n \n\n#define ASC_TXBUF_MSK\t\t\t0x01FF\n\n \n\nstatic inline struct asc_port *to_asc_port(struct uart_port *port)\n{\n\treturn container_of(port, struct asc_port, port);\n}\n\nstatic inline u32 asc_in(struct uart_port *port, u32 offset)\n{\n#ifdef readl_relaxed\n\treturn readl_relaxed(port->membase + offset);\n#else\n\treturn readl(port->membase + offset);\n#endif\n}\n\nstatic inline void asc_out(struct uart_port *port, u32 offset, u32 value)\n{\n#ifdef writel_relaxed\n\twritel_relaxed(value, port->membase + offset);\n#else\n\twritel(value, port->membase + offset);\n#endif\n}\n\n \nstatic inline void asc_disable_tx_interrupts(struct uart_port *port)\n{\n\tu32 intenable = asc_in(port, ASC_INTEN) & ~ASC_INTEN_THE;\n\tasc_out(port, ASC_INTEN, intenable);\n\t(void)asc_in(port, ASC_INTEN);\t \n}\n\nstatic inline void asc_enable_tx_interrupts(struct uart_port *port)\n{\n\tu32 intenable = asc_in(port, ASC_INTEN) | ASC_INTEN_THE;\n\tasc_out(port, ASC_INTEN, intenable);\n}\n\nstatic inline void asc_disable_rx_interrupts(struct uart_port *port)\n{\n\tu32 intenable = asc_in(port, ASC_INTEN) & ~ASC_INTEN_RBE;\n\tasc_out(port, ASC_INTEN, intenable);\n\t(void)asc_in(port, ASC_INTEN);\t \n}\n\nstatic inline void asc_enable_rx_interrupts(struct uart_port *port)\n{\n\tu32 intenable = asc_in(port, ASC_INTEN) | ASC_INTEN_RBE;\n\tasc_out(port, ASC_INTEN, intenable);\n}\n\nstatic inline u32 asc_txfifo_is_empty(struct uart_port *port)\n{\n\treturn asc_in(port, ASC_STA) & ASC_STA_TE;\n}\n\nstatic inline u32 asc_txfifo_is_half_empty(struct uart_port *port)\n{\n\treturn asc_in(port, ASC_STA) & ASC_STA_THE;\n}\n\nstatic inline const char *asc_port_name(struct uart_port *port)\n{\n\treturn to_platform_device(port->dev)->name;\n}\n\n \n\n \n\nstatic inline unsigned asc_hw_txroom(struct uart_port *port)\n{\n\tu32 status = asc_in(port, ASC_STA);\n\n\tif (status & ASC_STA_THE)\n\t\treturn port->fifosize / 2;\n\telse if (!(status & ASC_STA_TF))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic void asc_transmit_chars(struct uart_port *port)\n{\n\tu8 ch;\n\n\tuart_port_tx_limited(port, ch, asc_hw_txroom(port),\n\t\ttrue,\n\t\tasc_out(port, ASC_TXBUF, ch),\n\t\t({}));\n}\n\nstatic void asc_receive_chars(struct uart_port *port)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned long status, mode;\n\tunsigned long c = 0;\n\tu8 flag;\n\tbool ignore_pe = false;\n\n\t \n\tmode = asc_in(port, ASC_CTL) & ASC_CTL_MODE_MSK;\n\tif (mode == ASC_CTL_MODE_8BIT || mode == ASC_CTL_MODE_8BIT_PAR)\n\t\tignore_pe = true;\n\n\tif (irqd_is_wakeup_set(irq_get_irq_data(port->irq)))\n\t\tpm_wakeup_event(tport->tty->dev, 0);\n\n\twhile ((status = asc_in(port, ASC_STA)) & ASC_STA_RBF) {\n\t\tc = asc_in(port, ASC_RXBUF) | ASC_RXBUF_DUMMY_RX;\n\t\tflag = TTY_NORMAL;\n\t\tport->icount.rx++;\n\n\t\tif (status & ASC_STA_OE || c & ASC_RXBUF_FE ||\n\t\t    (c & ASC_RXBUF_PE && !ignore_pe)) {\n\n\t\t\tif (c & ASC_RXBUF_FE) {\n\t\t\t\tif (c == (ASC_RXBUF_FE | ASC_RXBUF_DUMMY_RX)) {\n\t\t\t\t\tport->icount.brk++;\n\t\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tc |= ASC_RXBUF_DUMMY_BE;\n\t\t\t\t} else {\n\t\t\t\t\tport->icount.frame++;\n\t\t\t\t}\n\t\t\t} else if (c & ASC_RXBUF_PE) {\n\t\t\t\tport->icount.parity++;\n\t\t\t}\n\t\t\t \n\t\t\tif (status & ASC_STA_OE) {\n\t\t\t\tport->icount.overrun++;\n\t\t\t\tc |= ASC_RXBUF_DUMMY_OE;\n\t\t\t}\n\n\t\t\tc &= port->read_status_mask;\n\n\t\t\tif (c & ASC_RXBUF_DUMMY_BE)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (c & ASC_RXBUF_PE)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (c & ASC_RXBUF_FE)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, c & 0xff))\n\t\t\tcontinue;\n\n\t\tuart_insert_char(port, c, ASC_RXBUF_DUMMY_OE, c & 0xff, flag);\n\t}\n\n\t \n\ttty_flip_buffer_push(tport);\n}\n\nstatic irqreturn_t asc_interrupt(int irq, void *ptr)\n{\n\tstruct uart_port *port = ptr;\n\tu32 status;\n\n\tspin_lock(&port->lock);\n\n\tstatus = asc_in(port, ASC_STA);\n\n\tif (status & ASC_STA_RBF) {\n\t\t \n\t\tasc_receive_chars(port);\n\t}\n\n\tif ((status & ASC_STA_THE) &&\n\t    (asc_in(port, ASC_INTEN) & ASC_INTEN_THE)) {\n\t\t \n\t\tasc_transmit_chars(port);\n\t}\n\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n \n\nstatic unsigned int asc_tx_empty(struct uart_port *port)\n{\n\treturn asc_txfifo_is_empty(port) ? TIOCSER_TEMT : 0;\n}\n\nstatic void asc_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct asc_port *ascport = to_asc_port(port);\n\n\t \n\n\tif (!ascport->rts)\n\t\treturn;\n\n\t \n\tif (asc_in(port, ASC_CTL) & ASC_CTL_CTSENABLE)\n\t\treturn;\n\n\tgpiod_set_value(ascport->rts, mctrl & TIOCM_RTS);\n}\n\nstatic unsigned int asc_get_mctrl(struct uart_port *port)\n{\n\t \n\treturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n}\n\n \nstatic void asc_start_tx(struct uart_port *port)\n{\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\tif (!uart_circ_empty(xmit))\n\t\tasc_enable_tx_interrupts(port);\n}\n\n \nstatic void asc_stop_tx(struct uart_port *port)\n{\n\tasc_disable_tx_interrupts(port);\n}\n\n \nstatic void asc_stop_rx(struct uart_port *port)\n{\n\tasc_disable_rx_interrupts(port);\n}\n\n \nstatic void asc_break_ctl(struct uart_port *port, int break_state)\n{\n\t \n}\n\n \nstatic int asc_startup(struct uart_port *port)\n{\n\tif (request_irq(port->irq, asc_interrupt, 0,\n\t\t\tasc_port_name(port), port)) {\n\t\tdev_err(port->dev, \"cannot allocate irq.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tasc_transmit_chars(port);\n\tasc_enable_rx_interrupts(port);\n\n\treturn 0;\n}\n\nstatic void asc_shutdown(struct uart_port *port)\n{\n\tasc_disable_tx_interrupts(port);\n\tasc_disable_rx_interrupts(port);\n\tfree_irq(port->irq, port);\n}\n\nstatic void asc_pm(struct uart_port *port, unsigned int state,\n\t\tunsigned int oldstate)\n{\n\tstruct asc_port *ascport = to_asc_port(port);\n\tunsigned long flags;\n\tu32 ctl;\n\n\tswitch (state) {\n\tcase UART_PM_STATE_ON:\n\t\tclk_prepare_enable(ascport->clk);\n\t\tbreak;\n\tcase UART_PM_STATE_OFF:\n\t\t \n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tctl = asc_in(port, ASC_CTL) & ~ASC_CTL_RUN;\n\t\tasc_out(port, ASC_CTL, ctl);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tclk_disable_unprepare(ascport->clk);\n\t\tbreak;\n\t}\n}\n\nstatic void asc_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t\t    const struct ktermios *old)\n{\n\tstruct asc_port *ascport = to_asc_port(port);\n\tstruct gpio_desc *gpiod;\n\tunsigned int baud;\n\tu32 ctrl_val;\n\ttcflag_t cflag;\n\tunsigned long flags;\n\n\t \n\ttermios->c_cflag &= ~(CMSPAR |\n\t\t\t (ascport->hw_flow_control ? 0 : CRTSCTS));\n\n\tport->uartclk = clk_get_rate(ascport->clk);\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\n\tcflag = termios->c_cflag;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tctrl_val = asc_in(port, ASC_CTL);\n\n\t \n\tasc_out(port, ASC_CTL, (ctrl_val & ~ASC_CTL_RUN));\n\tctrl_val = ASC_CTL_RXENABLE | ASC_CTL_FIFOENABLE;\n\n\t \n\tasc_out(port, ASC_TXRESET, 1);\n\tasc_out(port, ASC_RXRESET, 1);\n\n\t \n\tif ((cflag & CSIZE) == CS7) {\n\t\tctrl_val |= ASC_CTL_MODE_7BIT_PAR;\n\t\tcflag |= PARENB;\n\t} else {\n\t\tctrl_val |= (cflag & PARENB) ?  ASC_CTL_MODE_8BIT_PAR :\n\t\t\t\t\t\tASC_CTL_MODE_8BIT;\n\t\tcflag &= ~CSIZE;\n\t\tcflag |= CS8;\n\t}\n\ttermios->c_cflag = cflag;\n\n\t \n\tctrl_val |= (cflag & CSTOPB) ? ASC_CTL_STOP_2BIT : ASC_CTL_STOP_1BIT;\n\n\t \n\tif (cflag & PARODD)\n\t\tctrl_val |= ASC_CTL_PARITYODD;\n\n\t \n\tif ((cflag & CRTSCTS)) {\n\t\tctrl_val |= ASC_CTL_CTSENABLE;\n\n\t\t \n\t\tif (ascport->rts) {\n\t\t\tdevm_gpiod_put(port->dev, ascport->rts);\n\t\t\tascport->rts = NULL;\n\n\t\t\tpinctrl_select_state(ascport->pinctrl,\n\t\t\t\t\t     ascport->states[DEFAULT]);\n\t\t}\n\t} else {\n\t\t \n\t\tif (!ascport->rts && ascport->states[NO_HW_FLOWCTRL]) {\n\t\t\tpinctrl_select_state(ascport->pinctrl,\n\t\t\t\t\t     ascport->states[NO_HW_FLOWCTRL]);\n\n\t\t\tgpiod = devm_gpiod_get(port->dev, \"rts\", GPIOD_OUT_LOW);\n\t\t\tif (!IS_ERR(gpiod)) {\n\t\t\t\tgpiod_set_consumer_name(gpiod,\n\t\t\t\t\t\tport->dev->of_node->name);\n\t\t\t\tascport->rts = gpiod;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((baud < 19200) && !ascport->force_m1) {\n\t\tasc_out(port, ASC_BAUDRATE, (port->uartclk / (16 * baud)));\n\t} else {\n\t\t \n\t\tu64 dividend = (u64)baud * (1 << 16);\n\n\t\tdo_div(dividend, port->uartclk / 16);\n\t\tasc_out(port, ASC_BAUDRATE, dividend);\n\t\tctrl_val |= ASC_CTL_BAUDMODE;\n\t}\n\n\tuart_update_timeout(port, cflag, baud);\n\n\tascport->port.read_status_mask = ASC_RXBUF_DUMMY_OE;\n\tif (termios->c_iflag & INPCK)\n\t\tascport->port.read_status_mask |= ASC_RXBUF_FE | ASC_RXBUF_PE;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tascport->port.read_status_mask |= ASC_RXBUF_DUMMY_BE;\n\n\t \n\tascport->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tascport->port.ignore_status_mask |= ASC_RXBUF_FE | ASC_RXBUF_PE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tascport->port.ignore_status_mask |= ASC_RXBUF_DUMMY_BE;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tascport->port.ignore_status_mask |= ASC_RXBUF_DUMMY_OE;\n\t}\n\n\t \n\tif (!(termios->c_cflag & CREAD))\n\t\tascport->port.ignore_status_mask |= ASC_RXBUF_DUMMY_RX;\n\n\t \n\tasc_out(port, ASC_TIMEOUT, 20);\n\n\t \n\tasc_out(port, ASC_CTL, (ctrl_val | ASC_CTL_RUN));\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *asc_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_ASC) ? DRIVER_NAME : NULL;\n}\n\nstatic void asc_release_port(struct uart_port *port)\n{\n}\n\nstatic int asc_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\n \nstatic void asc_config_port(struct uart_port *port, int flags)\n{\n\tif ((flags & UART_CONFIG_TYPE))\n\t\tport->type = PORT_ASC;\n}\n\nstatic int\nasc_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\t \n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n \n\nstatic int asc_get_poll_char(struct uart_port *port)\n{\n\tif (!(asc_in(port, ASC_STA) & ASC_STA_RBF))\n\t\treturn NO_POLL_CHAR;\n\n\treturn asc_in(port, ASC_RXBUF);\n}\n\nstatic void asc_put_poll_char(struct uart_port *port, unsigned char c)\n{\n\twhile (!asc_txfifo_is_half_empty(port))\n\t\tcpu_relax();\n\tasc_out(port, ASC_TXBUF, c);\n}\n\n#endif  \n\n \n\nstatic const struct uart_ops asc_uart_ops = {\n\t.tx_empty\t= asc_tx_empty,\n\t.set_mctrl\t= asc_set_mctrl,\n\t.get_mctrl\t= asc_get_mctrl,\n\t.start_tx\t= asc_start_tx,\n\t.stop_tx\t= asc_stop_tx,\n\t.stop_rx\t= asc_stop_rx,\n\t.break_ctl\t= asc_break_ctl,\n\t.startup\t= asc_startup,\n\t.shutdown\t= asc_shutdown,\n\t.set_termios\t= asc_set_termios,\n\t.type\t\t= asc_type,\n\t.release_port\t= asc_release_port,\n\t.request_port\t= asc_request_port,\n\t.config_port\t= asc_config_port,\n\t.verify_port\t= asc_verify_port,\n\t.pm\t\t= asc_pm,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char = asc_get_poll_char,\n\t.poll_put_char = asc_put_poll_char,\n#endif  \n};\n\nstatic int asc_init_port(struct asc_port *ascport,\n\t\t\t  struct platform_device *pdev)\n{\n\tstruct uart_port *port = &ascport->port;\n\tstruct resource *res;\n\tint ret;\n\n\tport->iotype\t= UPIO_MEM;\n\tport->flags\t= UPF_BOOT_AUTOCONF;\n\tport->ops\t= &asc_uart_ops;\n\tport->fifosize\t= ASC_FIFO_SIZE;\n\tport->dev\t= &pdev->dev;\n\tport->irq\t= platform_get_irq(pdev, 0);\n\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_ST_ASC_CONSOLE);\n\n\tport->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(port->membase))\n\t\treturn PTR_ERR(port->membase);\n\tport->mapbase = res->start;\n\n\tspin_lock_init(&port->lock);\n\n\tascport->clk = devm_clk_get(&pdev->dev, NULL);\n\n\tif (WARN_ON(IS_ERR(ascport->clk)))\n\t\treturn -EINVAL;\n\t \n\tret = clk_prepare_enable(ascport->clk);\n\tif (ret)\n\t\treturn ret;\n\tascport->port.uartclk = clk_get_rate(ascport->clk);\n\tWARN_ON(ascport->port.uartclk == 0);\n\tclk_disable_unprepare(ascport->clk);\n\n\tascport->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (IS_ERR(ascport->pinctrl)) {\n\t\tret = PTR_ERR(ascport->pinctrl);\n\t\tdev_err(&pdev->dev, \"Failed to get Pinctrl: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tascport->states[DEFAULT] =\n\t\tpinctrl_lookup_state(ascport->pinctrl, \"default\");\n\tif (IS_ERR(ascport->states[DEFAULT])) {\n\t\tret = PTR_ERR(ascport->states[DEFAULT]);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to look up Pinctrl state 'default': %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tascport->states[NO_HW_FLOWCTRL] =\n\t\tpinctrl_lookup_state(ascport->pinctrl, \"no-hw-flowctrl\");\n\tif (IS_ERR(ascport->states[NO_HW_FLOWCTRL]))\n\t\tascport->states[NO_HW_FLOWCTRL] = NULL;\n\n\treturn 0;\n}\n\nstatic struct asc_port *asc_of_get_asc_port(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint id;\n\n\tif (!np)\n\t\treturn NULL;\n\n\tid = of_alias_get_id(np, \"serial\");\n\tif (id < 0)\n\t\tid = of_alias_get_id(np, ASC_SERIAL_NAME);\n\n\tif (id < 0)\n\t\tid = 0;\n\n\tif (WARN_ON(id >= ASC_MAX_PORTS))\n\t\treturn NULL;\n\n\tasc_ports[id].hw_flow_control = of_property_read_bool(np,\n\t\t\t\t\t\t\t\"uart-has-rtscts\");\n\tasc_ports[id].force_m1 =  of_property_read_bool(np, \"st,force-m1\");\n\tasc_ports[id].port.line = id;\n\tasc_ports[id].rts = NULL;\n\n\treturn &asc_ports[id];\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id asc_match[] = {\n\t{ .compatible = \"st,asc\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, asc_match);\n#endif\n\nstatic int asc_serial_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct asc_port *ascport;\n\n\tascport = asc_of_get_asc_port(pdev);\n\tif (!ascport)\n\t\treturn -ENODEV;\n\n\tret = asc_init_port(ascport, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uart_add_one_port(&asc_uart_driver, &ascport->port);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, &ascport->port);\n\n\treturn 0;\n}\n\nstatic int asc_serial_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&asc_uart_driver, port);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int asc_serial_suspend(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\n\treturn uart_suspend_port(&asc_uart_driver, port);\n}\n\nstatic int asc_serial_resume(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\n\treturn uart_resume_port(&asc_uart_driver, port);\n}\n\n#endif  \n\n \n\n#ifdef CONFIG_SERIAL_ST_ASC_CONSOLE\nstatic void asc_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tunsigned int timeout = 1000000;\n\n\t \n\twhile (--timeout && !asc_txfifo_is_half_empty(port))\n\t\tudelay(1);\n\n\tasc_out(port, ASC_TXBUF, ch);\n}\n\n \n\nstatic void asc_console_write(struct console *co, const char *s, unsigned count)\n{\n\tstruct uart_port *port = &asc_ports[co->index].port;\n\tunsigned long flags;\n\tunsigned long timeout = 1000000;\n\tint locked = 1;\n\tu32 intenable;\n\n\tif (port->sysrq)\n\t\tlocked = 0;  \n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&port->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tintenable = asc_in(port, ASC_INTEN);\n\tasc_out(port, ASC_INTEN, 0);\n\t(void)asc_in(port, ASC_INTEN);\t \n\n\tuart_console_write(port, s, count, asc_console_putchar);\n\n\twhile (--timeout && !asc_txfifo_is_empty(port))\n\t\tudelay(1);\n\n\tasc_out(port, ASC_INTEN, intenable);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int asc_console_setup(struct console *co, char *options)\n{\n\tstruct asc_port *ascport;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index >= ASC_MAX_PORTS)\n\t\treturn -ENODEV;\n\n\tascport = &asc_ports[co->index];\n\n\t \n\tif (ascport->port.mapbase == 0 || ascport->port.membase == NULL)\n\t\treturn -ENXIO;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&ascport->port, co, baud, parity, bits, flow);\n}\n\nstatic struct console asc_console = {\n\t.name\t\t= ASC_SERIAL_NAME,\n\t.device\t\t= uart_console_device,\n\t.write\t\t= asc_console_write,\n\t.setup\t\t= asc_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &asc_uart_driver,\n};\n\n#define ASC_SERIAL_CONSOLE (&asc_console)\n\n#else\n#define ASC_SERIAL_CONSOLE NULL\n#endif  \n\nstatic struct uart_driver asc_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= DRIVER_NAME,\n\t.dev_name\t= ASC_SERIAL_NAME,\n\t.major\t\t= 0,\n\t.minor\t\t= 0,\n\t.nr\t\t= ASC_MAX_PORTS,\n\t.cons\t\t= ASC_SERIAL_CONSOLE,\n};\n\nstatic const struct dev_pm_ops asc_serial_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(asc_serial_suspend, asc_serial_resume)\n};\n\nstatic struct platform_driver asc_serial_driver = {\n\t.probe\t\t= asc_serial_probe,\n\t.remove\t\t= asc_serial_remove,\n\t.driver\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= &asc_serial_pm_ops,\n\t\t.of_match_table = of_match_ptr(asc_match),\n\t},\n};\n\nstatic int __init asc_init(void)\n{\n\tint ret;\n\tstatic const char banner[] __initconst =\n\t\tKERN_INFO \"STMicroelectronics ASC driver initialized\\n\";\n\n\tprintk(banner);\n\n\tret = uart_register_driver(&asc_uart_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&asc_serial_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&asc_uart_driver);\n\n\treturn ret;\n}\n\nstatic void __exit asc_exit(void)\n{\n\tplatform_driver_unregister(&asc_serial_driver);\n\tuart_unregister_driver(&asc_uart_driver);\n}\n\nmodule_init(asc_init);\nmodule_exit(asc_exit);\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_AUTHOR(\"STMicroelectronics (R&D) Limited\");\nMODULE_DESCRIPTION(\"STMicroelectronics ASC serial port driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}