{
  "module_name": "kgdboc.c",
  "hash_id": "19d055c86f48d0ab51c73f5aa7bb622402dc2c3d1d37fb75cbd7ec03fa0a6ba2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/kgdboc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/tty.h>\n#include <linux/console.h>\n#include <linux/vt_kern.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/serial_core.h>\n\n#define MAX_CONFIG_LEN\t\t40\n\nstatic struct kgdb_io\t\tkgdboc_io_ops;\n\n \nstatic int configured\t\t= -1;\nstatic DEFINE_MUTEX(config_mutex);\n\nstatic char config[MAX_CONFIG_LEN];\nstatic struct kparam_string kps = {\n\t.string\t\t\t= config,\n\t.maxlen\t\t\t= MAX_CONFIG_LEN,\n};\n\nstatic int kgdboc_use_kms;   \nstatic struct tty_driver\t*kgdb_tty_driver;\nstatic int\t\t\tkgdb_tty_line;\n\nstatic struct platform_device *kgdboc_pdev;\n\n#if IS_BUILTIN(CONFIG_KGDB_SERIAL_CONSOLE)\nstatic struct kgdb_io\t\tkgdboc_earlycon_io_ops;\nstatic int                      (*earlycon_orig_exit)(struct console *con);\n#endif  \n\n#ifdef CONFIG_KDB_KEYBOARD\nstatic int kgdboc_reset_connect(struct input_handler *handler,\n\t\t\t\tstruct input_dev *dev,\n\t\t\t\tconst struct input_device_id *id)\n{\n\tinput_reset_device(dev);\n\n\t \n\treturn -ENODEV;\n}\n\nstatic void kgdboc_reset_disconnect(struct input_handle *handle)\n{\n\t \n\tBUG();\n}\n\nstatic const struct input_device_id kgdboc_reset_ids[] = {\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t},\n\t{ }\n};\n\nstatic struct input_handler kgdboc_reset_handler = {\n\t.connect\t= kgdboc_reset_connect,\n\t.disconnect\t= kgdboc_reset_disconnect,\n\t.name\t\t= \"kgdboc_reset\",\n\t.id_table\t= kgdboc_reset_ids,\n};\n\nstatic DEFINE_MUTEX(kgdboc_reset_mutex);\n\nstatic void kgdboc_restore_input_helper(struct work_struct *dummy)\n{\n\t \n\tmutex_lock(&kgdboc_reset_mutex);\n\n\tif (input_register_handler(&kgdboc_reset_handler) == 0)\n\t\tinput_unregister_handler(&kgdboc_reset_handler);\n\n\tmutex_unlock(&kgdboc_reset_mutex);\n}\n\nstatic DECLARE_WORK(kgdboc_restore_input_work, kgdboc_restore_input_helper);\n\nstatic void kgdboc_restore_input(void)\n{\n\tif (likely(system_state == SYSTEM_RUNNING))\n\t\tschedule_work(&kgdboc_restore_input_work);\n}\n\nstatic int kgdboc_register_kbd(char **cptr)\n{\n\tif (strncmp(*cptr, \"kbd\", 3) == 0 ||\n\t\tstrncmp(*cptr, \"kdb\", 3) == 0) {\n\t\tif (kdb_poll_idx < KDB_POLL_FUNC_MAX) {\n\t\t\tkdb_poll_funcs[kdb_poll_idx] = kdb_get_kbd_char;\n\t\t\tkdb_poll_idx++;\n\t\t\tif (cptr[0][3] == ',')\n\t\t\t\t*cptr += 4;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void kgdboc_unregister_kbd(void)\n{\n\tint i;\n\n\tfor (i = 0; i < kdb_poll_idx; i++) {\n\t\tif (kdb_poll_funcs[i] == kdb_get_kbd_char) {\n\t\t\tkdb_poll_idx--;\n\t\t\tkdb_poll_funcs[i] = kdb_poll_funcs[kdb_poll_idx];\n\t\t\tkdb_poll_funcs[kdb_poll_idx] = NULL;\n\t\t\ti--;\n\t\t}\n\t}\n\tflush_work(&kgdboc_restore_input_work);\n}\n#else  \n#define kgdboc_register_kbd(x) 0\n#define kgdboc_unregister_kbd()\n#define kgdboc_restore_input()\n#endif  \n\n#if IS_BUILTIN(CONFIG_KGDB_SERIAL_CONSOLE)\nstatic void cleanup_earlycon(void)\n{\n\tif (kgdboc_earlycon_io_ops.cons)\n\t\tkgdb_unregister_io_module(&kgdboc_earlycon_io_ops);\n}\n#else  \nstatic inline void cleanup_earlycon(void) { }\n#endif  \n\nstatic void cleanup_kgdboc(void)\n{\n\tcleanup_earlycon();\n\n\tif (configured != 1)\n\t\treturn;\n\n\tif (kgdb_unregister_nmi_console())\n\t\treturn;\n\tkgdboc_unregister_kbd();\n\tkgdb_unregister_io_module(&kgdboc_io_ops);\n}\n\nstatic int configure_kgdboc(void)\n{\n\tstruct tty_driver *p;\n\tint tty_line = 0;\n\tint err = -ENODEV;\n\tchar *cptr = config;\n\tstruct console *cons;\n\tint cookie;\n\n\tif (!strlen(config) || isspace(config[0])) {\n\t\terr = 0;\n\t\tgoto noconfig;\n\t}\n\n\tkgdboc_io_ops.cons = NULL;\n\tkgdb_tty_driver = NULL;\n\n\tkgdboc_use_kms = 0;\n\tif (strncmp(cptr, \"kms,\", 4) == 0) {\n\t\tcptr += 4;\n\t\tkgdboc_use_kms = 1;\n\t}\n\n\tif (kgdboc_register_kbd(&cptr))\n\t\tgoto do_register;\n\n\tp = tty_find_polling_driver(cptr, &tty_line);\n\tif (!p)\n\t\tgoto noconfig;\n\n\t \n\tconsole_lock();\n\n\tcookie = console_srcu_read_lock();\n\tfor_each_console_srcu(cons) {\n\t\tint idx;\n\t\tif (cons->device && cons->device(cons, &idx) == p &&\n\t\t    idx == tty_line) {\n\t\t\tkgdboc_io_ops.cons = cons;\n\t\t\tbreak;\n\t\t}\n\t}\n\tconsole_srcu_read_unlock(cookie);\n\n\tconsole_unlock();\n\n\tkgdb_tty_driver = p;\n\tkgdb_tty_line = tty_line;\n\ndo_register:\n\terr = kgdb_register_io_module(&kgdboc_io_ops);\n\tif (err)\n\t\tgoto noconfig;\n\n\terr = kgdb_register_nmi_console();\n\tif (err)\n\t\tgoto nmi_con_failed;\n\n\tconfigured = 1;\n\n\treturn 0;\n\nnmi_con_failed:\n\tkgdb_unregister_io_module(&kgdboc_io_ops);\nnoconfig:\n\tkgdboc_unregister_kbd();\n\tconfigured = 0;\n\n\treturn err;\n}\n\nstatic int kgdboc_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\n\tmutex_lock(&config_mutex);\n\tif (configured != 1) {\n\t\tret = configure_kgdboc();\n\n\t\t \n\t\tif (ret == -ENODEV)\n\t\t\tret = -EPROBE_DEFER;\n\t}\n\tmutex_unlock(&config_mutex);\n\n\treturn ret;\n}\n\nstatic struct platform_driver kgdboc_platform_driver = {\n\t.probe = kgdboc_probe,\n\t.driver = {\n\t\t.name = \"kgdboc\",\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nstatic int __init init_kgdboc(void)\n{\n\tint ret;\n\n\t \n\tret = platform_driver_register(&kgdboc_platform_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tkgdboc_pdev = platform_device_alloc(\"kgdboc\", PLATFORM_DEVID_NONE);\n\tif (!kgdboc_pdev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_did_register;\n\t}\n\n\tret = platform_device_add(kgdboc_pdev);\n\tif (!ret)\n\t\treturn 0;\n\n\tplatform_device_put(kgdboc_pdev);\n\nerr_did_register:\n\tplatform_driver_unregister(&kgdboc_platform_driver);\n\treturn ret;\n}\n\nstatic void exit_kgdboc(void)\n{\n\tmutex_lock(&config_mutex);\n\tcleanup_kgdboc();\n\tmutex_unlock(&config_mutex);\n\n\tplatform_device_unregister(kgdboc_pdev);\n\tplatform_driver_unregister(&kgdboc_platform_driver);\n}\n\nstatic int kgdboc_get_char(void)\n{\n\tif (!kgdb_tty_driver)\n\t\treturn -1;\n\treturn kgdb_tty_driver->ops->poll_get_char(kgdb_tty_driver,\n\t\t\t\t\t\tkgdb_tty_line);\n}\n\nstatic void kgdboc_put_char(u8 chr)\n{\n\tif (!kgdb_tty_driver)\n\t\treturn;\n\tkgdb_tty_driver->ops->poll_put_char(kgdb_tty_driver,\n\t\t\t\t\tkgdb_tty_line, chr);\n}\n\nstatic int param_set_kgdboc_var(const char *kmessage,\n\t\t\t\tconst struct kernel_param *kp)\n{\n\tsize_t len = strlen(kmessage);\n\tint ret = 0;\n\n\tif (len >= MAX_CONFIG_LEN) {\n\t\tpr_err(\"config string too long\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (kgdb_connected) {\n\t\tpr_err(\"Cannot reconfigure while KGDB is connected.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tmutex_lock(&config_mutex);\n\n\tstrcpy(config, kmessage);\n\t \n\tif (len && config[len - 1] == '\\n')\n\t\tconfig[len - 1] = '\\0';\n\n\tif (configured == 1)\n\t\tcleanup_kgdboc();\n\n\t \n\tif (configured >= 0)\n\t\tret = configure_kgdboc();\n\n\t \n\tif (ret)\n\t\tconfig[0] = '\\0';\n\n\tmutex_unlock(&config_mutex);\n\n\treturn ret;\n}\n\nstatic int dbg_restore_graphics;\n\nstatic void kgdboc_pre_exp_handler(void)\n{\n\tif (!dbg_restore_graphics && kgdboc_use_kms) {\n\t\tdbg_restore_graphics = 1;\n\t\tcon_debug_enter(vc_cons[fg_console].d);\n\t}\n\t \n\tif (!kgdb_connected)\n\t\ttry_module_get(THIS_MODULE);\n}\n\nstatic void kgdboc_post_exp_handler(void)\n{\n\t \n\tif (!kgdb_connected)\n\t\tmodule_put(THIS_MODULE);\n\tif (kgdboc_use_kms && dbg_restore_graphics) {\n\t\tdbg_restore_graphics = 0;\n\t\tcon_debug_leave();\n\t}\n\tkgdboc_restore_input();\n}\n\nstatic struct kgdb_io kgdboc_io_ops = {\n\t.name\t\t\t= \"kgdboc\",\n\t.read_char\t\t= kgdboc_get_char,\n\t.write_char\t\t= kgdboc_put_char,\n\t.pre_exception\t\t= kgdboc_pre_exp_handler,\n\t.post_exception\t\t= kgdboc_post_exp_handler,\n};\n\n#if IS_BUILTIN(CONFIG_KGDB_SERIAL_CONSOLE)\nstatic int kgdboc_option_setup(char *opt)\n{\n\tif (!opt) {\n\t\tpr_err(\"config string not provided\\n\");\n\t\treturn 1;\n\t}\n\n\tif (strlen(opt) >= MAX_CONFIG_LEN) {\n\t\tpr_err(\"config string too long\\n\");\n\t\treturn 1;\n\t}\n\tstrcpy(config, opt);\n\n\treturn 1;\n}\n\n__setup(\"kgdboc=\", kgdboc_option_setup);\n\n\n \nstatic int __init kgdboc_early_init(char *opt)\n{\n\tkgdboc_option_setup(opt);\n\tconfigure_kgdboc();\n\treturn 0;\n}\n\nearly_param(\"ekgdboc\", kgdboc_early_init);\n\nstatic int kgdboc_earlycon_get_char(void)\n{\n\tchar c;\n\n\tif (!kgdboc_earlycon_io_ops.cons->read(kgdboc_earlycon_io_ops.cons,\n\t\t\t\t\t       &c, 1))\n\t\treturn NO_POLL_CHAR;\n\n\treturn c;\n}\n\nstatic void kgdboc_earlycon_put_char(u8 chr)\n{\n\tkgdboc_earlycon_io_ops.cons->write(kgdboc_earlycon_io_ops.cons, &chr,\n\t\t\t\t\t   1);\n}\n\nstatic void kgdboc_earlycon_pre_exp_handler(void)\n{\n\tstruct console *con;\n\tstatic bool already_warned;\n\tint cookie;\n\n\tif (already_warned)\n\t\treturn;\n\n\t \n\tcookie = console_srcu_read_lock();\n\tfor_each_console_srcu(con) {\n\t\tif (con == kgdboc_earlycon_io_ops.cons)\n\t\t\tbreak;\n\t}\n\tconsole_srcu_read_unlock(cookie);\n\tif (con)\n\t\treturn;\n\n\talready_warned = true;\n\tpr_warn(\"kgdboc_earlycon is still using bootconsole\\n\");\n}\n\nstatic int kgdboc_earlycon_deferred_exit(struct console *con)\n{\n\t \n\tcon->exit = earlycon_orig_exit;\n\n\treturn 0;\n}\n\nstatic void kgdboc_earlycon_deinit(void)\n{\n\tif (!kgdboc_earlycon_io_ops.cons)\n\t\treturn;\n\n\tif (kgdboc_earlycon_io_ops.cons->exit == kgdboc_earlycon_deferred_exit)\n\t\t \n\t\tkgdboc_earlycon_io_ops.cons->exit = earlycon_orig_exit;\n\telse if (kgdboc_earlycon_io_ops.cons->exit)\n\t\t \n\t\tkgdboc_earlycon_io_ops.cons->exit(kgdboc_earlycon_io_ops.cons);\n\n\tkgdboc_earlycon_io_ops.cons = NULL;\n}\n\nstatic struct kgdb_io kgdboc_earlycon_io_ops = {\n\t.name\t\t\t= \"kgdboc_earlycon\",\n\t.read_char\t\t= kgdboc_earlycon_get_char,\n\t.write_char\t\t= kgdboc_earlycon_put_char,\n\t.pre_exception\t\t= kgdboc_earlycon_pre_exp_handler,\n\t.deinit\t\t\t= kgdboc_earlycon_deinit,\n};\n\n#define MAX_CONSOLE_NAME_LEN (sizeof((struct console *) 0)->name)\nstatic char kgdboc_earlycon_param[MAX_CONSOLE_NAME_LEN] __initdata;\nstatic bool kgdboc_earlycon_late_enable __initdata;\n\nstatic int __init kgdboc_earlycon_init(char *opt)\n{\n\tstruct console *con;\n\n\tkdb_init(KDB_INIT_EARLY);\n\n\t \n\n\t \n\tconsole_list_lock();\n\tfor_each_console(con) {\n\t\tif (con->write && con->read &&\n\t\t    (con->flags & (CON_BOOT | CON_ENABLED)) &&\n\t\t    (!opt || !opt[0] || strcmp(con->name, opt) == 0))\n\t\t\tbreak;\n\t}\n\n\tif (!con) {\n\t\t \n\t\tif (!kgdboc_earlycon_late_enable) {\n\t\t\tpr_info(\"No suitable earlycon yet, will try later\\n\");\n\t\t\tif (opt)\n\t\t\t\tstrscpy(kgdboc_earlycon_param, opt,\n\t\t\t\t\tsizeof(kgdboc_earlycon_param));\n\t\t\tkgdboc_earlycon_late_enable = true;\n\t\t} else {\n\t\t\tpr_info(\"Couldn't find kgdb earlycon\\n\");\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tkgdboc_earlycon_io_ops.cons = con;\n\tpr_info(\"Going to register kgdb with earlycon '%s'\\n\", con->name);\n\tif (kgdb_register_io_module(&kgdboc_earlycon_io_ops) != 0) {\n\t\tkgdboc_earlycon_io_ops.cons = NULL;\n\t\tpr_info(\"Failed to register kgdb with earlycon\\n\");\n\t} else {\n\t\t \n\t\tearlycon_orig_exit = con->exit;\n\t\tcon->exit = kgdboc_earlycon_deferred_exit;\n\t}\n\nunlock:\n\tconsole_list_unlock();\n\n\t \n\treturn 0;\n}\n\nearly_param(\"kgdboc_earlycon\", kgdboc_earlycon_init);\n\n \nstatic int __init kgdboc_earlycon_late_init(void)\n{\n\tif (kgdboc_earlycon_late_enable)\n\t\tkgdboc_earlycon_init(kgdboc_earlycon_param);\n\treturn 0;\n}\nconsole_initcall(kgdboc_earlycon_late_init);\n\n#endif  \n\nmodule_init(init_kgdboc);\nmodule_exit(exit_kgdboc);\nmodule_param_call(kgdboc, param_set_kgdboc_var, param_get_string, &kps, 0644);\nMODULE_PARM_DESC(kgdboc, \"<serial_device>[,baud]\");\nMODULE_DESCRIPTION(\"KGDB Console TTY Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}