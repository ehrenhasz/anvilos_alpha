{
  "module_name": "pch_uart.c",
  "hash_id": "b7a397eecf6ed63a0a38394612ccac22ed32a291e579ef47dda7d2f27d3575fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/pch_uart.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/dmi.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n\n#include <linux/debugfs.h>\n#include <linux/dmaengine.h>\n#include <linux/pch_dma.h>\n\nenum {\n\tPCH_UART_HANDLED_RX_INT_SHIFT,\n\tPCH_UART_HANDLED_TX_INT_SHIFT,\n\tPCH_UART_HANDLED_RX_ERR_INT_SHIFT,\n\tPCH_UART_HANDLED_RX_TRG_INT_SHIFT,\n\tPCH_UART_HANDLED_MS_INT_SHIFT,\n\tPCH_UART_HANDLED_LS_INT_SHIFT,\n};\n\n#define PCH_UART_DRIVER_DEVICE \"ttyPCH\"\n\n \n#define PCH_UART_NR\t4\n\n#define PCH_UART_HANDLED_RX_INT\t(1<<((PCH_UART_HANDLED_RX_INT_SHIFT)<<1))\n#define PCH_UART_HANDLED_TX_INT\t(1<<((PCH_UART_HANDLED_TX_INT_SHIFT)<<1))\n#define PCH_UART_HANDLED_RX_ERR_INT\t(1<<((\\\n\t\t\t\t\tPCH_UART_HANDLED_RX_ERR_INT_SHIFT)<<1))\n#define PCH_UART_HANDLED_RX_TRG_INT\t(1<<((\\\n\t\t\t\t\tPCH_UART_HANDLED_RX_TRG_INT_SHIFT)<<1))\n#define PCH_UART_HANDLED_MS_INT\t(1<<((PCH_UART_HANDLED_MS_INT_SHIFT)<<1))\n\n#define PCH_UART_HANDLED_LS_INT\t(1<<((PCH_UART_HANDLED_LS_INT_SHIFT)<<1))\n\n#define PCH_UART_RBR\t\t0x00\n#define PCH_UART_THR\t\t0x00\n\n#define PCH_UART_IER_MASK\t(PCH_UART_IER_ERBFI|PCH_UART_IER_ETBEI|\\\n\t\t\t\tPCH_UART_IER_ELSI|PCH_UART_IER_EDSSI)\n#define PCH_UART_IER_ERBFI\t0x00000001\n#define PCH_UART_IER_ETBEI\t0x00000002\n#define PCH_UART_IER_ELSI\t0x00000004\n#define PCH_UART_IER_EDSSI\t0x00000008\n\n#define PCH_UART_IIR_IP\t\t\t0x00000001\n#define PCH_UART_IIR_IID\t\t0x00000006\n#define PCH_UART_IIR_MSI\t\t0x00000000\n#define PCH_UART_IIR_TRI\t\t0x00000002\n#define PCH_UART_IIR_RRI\t\t0x00000004\n#define PCH_UART_IIR_REI\t\t0x00000006\n#define PCH_UART_IIR_TOI\t\t0x00000008\n#define PCH_UART_IIR_FIFO256\t\t0x00000020\n#define PCH_UART_IIR_FIFO64\t\tPCH_UART_IIR_FIFO256\n#define PCH_UART_IIR_FE\t\t\t0x000000C0\n\n#define PCH_UART_FCR_FIFOE\t\t0x00000001\n#define PCH_UART_FCR_RFR\t\t0x00000002\n#define PCH_UART_FCR_TFR\t\t0x00000004\n#define PCH_UART_FCR_DMS\t\t0x00000008\n#define PCH_UART_FCR_FIFO256\t\t0x00000020\n#define PCH_UART_FCR_RFTL\t\t0x000000C0\n\n#define PCH_UART_FCR_RFTL1\t\t0x00000000\n#define PCH_UART_FCR_RFTL64\t\t0x00000040\n#define PCH_UART_FCR_RFTL128\t\t0x00000080\n#define PCH_UART_FCR_RFTL224\t\t0x000000C0\n#define PCH_UART_FCR_RFTL16\t\tPCH_UART_FCR_RFTL64\n#define PCH_UART_FCR_RFTL32\t\tPCH_UART_FCR_RFTL128\n#define PCH_UART_FCR_RFTL56\t\tPCH_UART_FCR_RFTL224\n#define PCH_UART_FCR_RFTL4\t\tPCH_UART_FCR_RFTL64\n#define PCH_UART_FCR_RFTL8\t\tPCH_UART_FCR_RFTL128\n#define PCH_UART_FCR_RFTL14\t\tPCH_UART_FCR_RFTL224\n#define PCH_UART_FCR_RFTL_SHIFT\t\t6\n\n#define PCH_UART_LCR_WLS\t0x00000003\n#define PCH_UART_LCR_STB\t0x00000004\n#define PCH_UART_LCR_PEN\t0x00000008\n#define PCH_UART_LCR_EPS\t0x00000010\n#define PCH_UART_LCR_SP\t\t0x00000020\n#define PCH_UART_LCR_SB\t\t0x00000040\n#define PCH_UART_LCR_DLAB\t0x00000080\n#define PCH_UART_LCR_NP\t\t0x00000000\n#define PCH_UART_LCR_OP\t\tPCH_UART_LCR_PEN\n#define PCH_UART_LCR_EP\t\t(PCH_UART_LCR_PEN | PCH_UART_LCR_EPS)\n#define PCH_UART_LCR_1P\t\t(PCH_UART_LCR_PEN | PCH_UART_LCR_SP)\n#define PCH_UART_LCR_0P\t\t(PCH_UART_LCR_PEN | PCH_UART_LCR_EPS |\\\n\t\t\t\tPCH_UART_LCR_SP)\n\n#define PCH_UART_LCR_5BIT\t0x00000000\n#define PCH_UART_LCR_6BIT\t0x00000001\n#define PCH_UART_LCR_7BIT\t0x00000002\n#define PCH_UART_LCR_8BIT\t0x00000003\n\n#define PCH_UART_MCR_DTR\t0x00000001\n#define PCH_UART_MCR_RTS\t0x00000002\n#define PCH_UART_MCR_OUT\t0x0000000C\n#define PCH_UART_MCR_LOOP\t0x00000010\n#define PCH_UART_MCR_AFE\t0x00000020\n\n#define PCH_UART_LSR_DR\t\t0x00000001\n#define PCH_UART_LSR_ERR\t(1<<7)\n\n#define PCH_UART_MSR_DCTS\t0x00000001\n#define PCH_UART_MSR_DDSR\t0x00000002\n#define PCH_UART_MSR_TERI\t0x00000004\n#define PCH_UART_MSR_DDCD\t0x00000008\n#define PCH_UART_MSR_CTS\t0x00000010\n#define PCH_UART_MSR_DSR\t0x00000020\n#define PCH_UART_MSR_RI\t\t0x00000040\n#define PCH_UART_MSR_DCD\t0x00000080\n#define PCH_UART_MSR_DELTA\t(PCH_UART_MSR_DCTS | PCH_UART_MSR_DDSR |\\\n\t\t\t\tPCH_UART_MSR_TERI | PCH_UART_MSR_DDCD)\n\n#define PCH_UART_DLL\t\t0x00\n#define PCH_UART_DLM\t\t0x01\n\n#define PCH_UART_BRCSR\t\t0x0E\n\n#define PCH_UART_IID_RLS\t(PCH_UART_IIR_REI)\n#define PCH_UART_IID_RDR\t(PCH_UART_IIR_RRI)\n#define PCH_UART_IID_RDR_TO\t(PCH_UART_IIR_RRI | PCH_UART_IIR_TOI)\n#define PCH_UART_IID_THRE\t(PCH_UART_IIR_TRI)\n#define PCH_UART_IID_MS\t\t(PCH_UART_IIR_MSI)\n\n#define PCH_UART_HAL_PARITY_NONE\t(PCH_UART_LCR_NP)\n#define PCH_UART_HAL_PARITY_ODD\t\t(PCH_UART_LCR_OP)\n#define PCH_UART_HAL_PARITY_EVEN\t(PCH_UART_LCR_EP)\n#define PCH_UART_HAL_PARITY_FIX1\t(PCH_UART_LCR_1P)\n#define PCH_UART_HAL_PARITY_FIX0\t(PCH_UART_LCR_0P)\n#define PCH_UART_HAL_5BIT\t\t(PCH_UART_LCR_5BIT)\n#define PCH_UART_HAL_6BIT\t\t(PCH_UART_LCR_6BIT)\n#define PCH_UART_HAL_7BIT\t\t(PCH_UART_LCR_7BIT)\n#define PCH_UART_HAL_8BIT\t\t(PCH_UART_LCR_8BIT)\n#define PCH_UART_HAL_STB1\t\t0\n#define PCH_UART_HAL_STB2\t\t(PCH_UART_LCR_STB)\n\n#define PCH_UART_HAL_CLR_TX_FIFO\t(PCH_UART_FCR_TFR)\n#define PCH_UART_HAL_CLR_RX_FIFO\t(PCH_UART_FCR_RFR)\n#define PCH_UART_HAL_CLR_ALL_FIFO\t(PCH_UART_HAL_CLR_TX_FIFO | \\\n\t\t\t\t\tPCH_UART_HAL_CLR_RX_FIFO)\n\n#define PCH_UART_HAL_DMA_MODE0\t\t0\n#define PCH_UART_HAL_FIFO_DIS\t\t0\n#define PCH_UART_HAL_FIFO16\t\t(PCH_UART_FCR_FIFOE)\n#define PCH_UART_HAL_FIFO256\t\t(PCH_UART_FCR_FIFOE | \\\n\t\t\t\t\tPCH_UART_FCR_FIFO256)\n#define PCH_UART_HAL_FIFO64\t\t(PCH_UART_HAL_FIFO256)\n#define PCH_UART_HAL_TRIGGER1\t\t(PCH_UART_FCR_RFTL1)\n#define PCH_UART_HAL_TRIGGER64\t\t(PCH_UART_FCR_RFTL64)\n#define PCH_UART_HAL_TRIGGER128\t\t(PCH_UART_FCR_RFTL128)\n#define PCH_UART_HAL_TRIGGER224\t\t(PCH_UART_FCR_RFTL224)\n#define PCH_UART_HAL_TRIGGER16\t\t(PCH_UART_FCR_RFTL16)\n#define PCH_UART_HAL_TRIGGER32\t\t(PCH_UART_FCR_RFTL32)\n#define PCH_UART_HAL_TRIGGER56\t\t(PCH_UART_FCR_RFTL56)\n#define PCH_UART_HAL_TRIGGER4\t\t(PCH_UART_FCR_RFTL4)\n#define PCH_UART_HAL_TRIGGER8\t\t(PCH_UART_FCR_RFTL8)\n#define PCH_UART_HAL_TRIGGER14\t\t(PCH_UART_FCR_RFTL14)\n#define PCH_UART_HAL_TRIGGER_L\t\t(PCH_UART_FCR_RFTL64)\n#define PCH_UART_HAL_TRIGGER_M\t\t(PCH_UART_FCR_RFTL128)\n#define PCH_UART_HAL_TRIGGER_H\t\t(PCH_UART_FCR_RFTL224)\n\n#define PCH_UART_HAL_RX_INT\t\t(PCH_UART_IER_ERBFI)\n#define PCH_UART_HAL_TX_INT\t\t(PCH_UART_IER_ETBEI)\n#define PCH_UART_HAL_RX_ERR_INT\t\t(PCH_UART_IER_ELSI)\n#define PCH_UART_HAL_MS_INT\t\t(PCH_UART_IER_EDSSI)\n#define PCH_UART_HAL_ALL_INT\t\t(PCH_UART_IER_MASK)\n\n#define PCH_UART_HAL_DTR\t\t(PCH_UART_MCR_DTR)\n#define PCH_UART_HAL_RTS\t\t(PCH_UART_MCR_RTS)\n#define PCH_UART_HAL_OUT\t\t(PCH_UART_MCR_OUT)\n#define PCH_UART_HAL_LOOP\t\t(PCH_UART_MCR_LOOP)\n#define PCH_UART_HAL_AFE\t\t(PCH_UART_MCR_AFE)\n\n#define DEFAULT_UARTCLK   1843200  \n#define CMITC_UARTCLK   192000000  \n#define FRI2_64_UARTCLK  64000000  \n#define FRI2_48_UARTCLK  48000000  \n#define NTC1_UARTCLK     64000000  \n#define MINNOW_UARTCLK   50000000  \n\nstruct pch_uart_buffer {\n\tunsigned char *buf;\n\tint size;\n};\n\nstruct eg20t_port {\n\tstruct uart_port port;\n\tint port_type;\n\tvoid __iomem *membase;\n\tresource_size_t mapbase;\n\tunsigned int iobase;\n\tstruct pci_dev *pdev;\n\tint fifo_size;\n\tunsigned int uartclk;\n\tint start_tx;\n\tint start_rx;\n\tint tx_empty;\n\tint trigger;\n\tint trigger_level;\n\tstruct pch_uart_buffer rxbuf;\n\tunsigned int dmsr;\n\tunsigned int fcr;\n\tunsigned int mcr;\n\tunsigned int use_dma;\n\tstruct dma_async_tx_descriptor\t*desc_tx;\n\tstruct dma_async_tx_descriptor\t*desc_rx;\n\tstruct pch_dma_slave\t\tparam_tx;\n\tstruct pch_dma_slave\t\tparam_rx;\n\tstruct dma_chan\t\t\t*chan_tx;\n\tstruct dma_chan\t\t\t*chan_rx;\n\tstruct scatterlist\t\t*sg_tx_p;\n\tint\t\t\t\tnent;\n\tint\t\t\t\torig_nent;\n\tstruct scatterlist\t\tsg_rx;\n\tint\t\t\t\ttx_dma_use;\n\tvoid\t\t\t\t*rx_buf_virt;\n\tdma_addr_t\t\t\trx_buf_dma;\n\n#define IRQ_NAME_SIZE 17\n\tchar\t\t\t\tirq_name[IRQ_NAME_SIZE];\n\n\t \n\tspinlock_t lock;\n};\n\n \nstruct pch_uart_driver_data {\n\tint port_type;\n\tint line_no;\n};\n\nenum pch_uart_num_t {\n\tpch_et20t_uart0 = 0,\n\tpch_et20t_uart1,\n\tpch_et20t_uart2,\n\tpch_et20t_uart3,\n\tpch_ml7213_uart0,\n\tpch_ml7213_uart1,\n\tpch_ml7213_uart2,\n\tpch_ml7223_uart0,\n\tpch_ml7223_uart1,\n\tpch_ml7831_uart0,\n\tpch_ml7831_uart1,\n};\n\nstatic struct pch_uart_driver_data drv_dat[] = {\n\t[pch_et20t_uart0] = {PORT_PCH_8LINE, 0},\n\t[pch_et20t_uart1] = {PORT_PCH_2LINE, 1},\n\t[pch_et20t_uart2] = {PORT_PCH_2LINE, 2},\n\t[pch_et20t_uart3] = {PORT_PCH_2LINE, 3},\n\t[pch_ml7213_uart0] = {PORT_PCH_8LINE, 0},\n\t[pch_ml7213_uart1] = {PORT_PCH_2LINE, 1},\n\t[pch_ml7213_uart2] = {PORT_PCH_2LINE, 2},\n\t[pch_ml7223_uart0] = {PORT_PCH_8LINE, 0},\n\t[pch_ml7223_uart1] = {PORT_PCH_2LINE, 1},\n\t[pch_ml7831_uart0] = {PORT_PCH_8LINE, 0},\n\t[pch_ml7831_uart1] = {PORT_PCH_2LINE, 1},\n};\n\n#ifdef CONFIG_SERIAL_PCH_UART_CONSOLE\nstatic struct eg20t_port *pch_uart_ports[PCH_UART_NR];\n#endif\nstatic unsigned int default_baud = 9600;\nstatic unsigned int user_uartclk = 0;\nstatic const int trigger_level_256[4] = { 1, 64, 128, 224 };\nstatic const int trigger_level_64[4] = { 1, 16, 32, 56 };\nstatic const int trigger_level_16[4] = { 1, 4, 8, 14 };\nstatic const int trigger_level_1[4] = { 1, 1, 1, 1 };\n\n#define PCH_REGS_BUFSIZE\t1024\n\n\nstatic ssize_t port_show_regs(struct file *file, char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct eg20t_port *priv = file->private_data;\n\tchar *buf;\n\tu32 len = 0;\n\tssize_t ret;\n\tunsigned char lcr;\n\n\tbuf = kzalloc(PCH_REGS_BUFSIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn 0;\n\n\tlen += scnprintf(buf + len, PCH_REGS_BUFSIZE - len,\n\t\t\t\"PCH EG20T port[%d] regs:\\n\", priv->port.line);\n\n\tlen += scnprintf(buf + len, PCH_REGS_BUFSIZE - len,\n\t\t\t\"=================================\\n\");\n\tlen += scnprintf(buf + len, PCH_REGS_BUFSIZE - len,\n\t\t\t\"IER: \\t0x%02x\\n\", ioread8(priv->membase + UART_IER));\n\tlen += scnprintf(buf + len, PCH_REGS_BUFSIZE - len,\n\t\t\t\"IIR: \\t0x%02x\\n\", ioread8(priv->membase + UART_IIR));\n\tlen += scnprintf(buf + len, PCH_REGS_BUFSIZE - len,\n\t\t\t\"LCR: \\t0x%02x\\n\", ioread8(priv->membase + UART_LCR));\n\tlen += scnprintf(buf + len, PCH_REGS_BUFSIZE - len,\n\t\t\t\"MCR: \\t0x%02x\\n\", ioread8(priv->membase + UART_MCR));\n\tlen += scnprintf(buf + len, PCH_REGS_BUFSIZE - len,\n\t\t\t\"LSR: \\t0x%02x\\n\", ioread8(priv->membase + UART_LSR));\n\tlen += scnprintf(buf + len, PCH_REGS_BUFSIZE - len,\n\t\t\t\"MSR: \\t0x%02x\\n\", ioread8(priv->membase + UART_MSR));\n\tlen += scnprintf(buf + len, PCH_REGS_BUFSIZE - len,\n\t\t\t\"BRCSR: \\t0x%02x\\n\",\n\t\t\tioread8(priv->membase + PCH_UART_BRCSR));\n\n\tlcr = ioread8(priv->membase + UART_LCR);\n\tiowrite8(PCH_UART_LCR_DLAB, priv->membase + UART_LCR);\n\tlen += scnprintf(buf + len, PCH_REGS_BUFSIZE - len,\n\t\t\t\"DLL: \\t0x%02x\\n\", ioread8(priv->membase + UART_DLL));\n\tlen += scnprintf(buf + len, PCH_REGS_BUFSIZE - len,\n\t\t\t\"DLM: \\t0x%02x\\n\", ioread8(priv->membase + UART_DLM));\n\tiowrite8(lcr, priv->membase + UART_LCR);\n\n\tif (len > PCH_REGS_BUFSIZE)\n\t\tlen = PCH_REGS_BUFSIZE;\n\n\tret =  simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations port_regs_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= simple_open,\n\t.read\t\t= port_show_regs,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct dmi_system_id pch_uart_dmi_table[] = {\n\t{\n\t\t.ident = \"CM-iTC\",\n\t\t{\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"CM-iTC\"),\n\t\t},\n\t\t(void *)CMITC_UARTCLK,\n\t},\n\t{\n\t\t.ident = \"FRI2\",\n\t\t{\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"FRI2\"),\n\t\t},\n\t\t(void *)FRI2_64_UARTCLK,\n\t},\n\t{\n\t\t.ident = \"Fish River Island II\",\n\t\t{\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Fish River Island II\"),\n\t\t},\n\t\t(void *)FRI2_48_UARTCLK,\n\t},\n\t{\n\t\t.ident = \"COMe-mTT\",\n\t\t{\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-mTT\"),\n\t\t},\n\t\t(void *)NTC1_UARTCLK,\n\t},\n\t{\n\t\t.ident = \"nanoETXexpress-TT\",\n\t\t{\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"nanoETXexpress-TT\"),\n\t\t},\n\t\t(void *)NTC1_UARTCLK,\n\t},\n\t{\n\t\t.ident = \"MinnowBoard\",\n\t\t{\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"MinnowBoard\"),\n\t\t},\n\t\t(void *)MINNOW_UARTCLK,\n\t},\n\t{ }\n};\n\n \nstatic unsigned int pch_uart_get_uartclk(void)\n{\n\tconst struct dmi_system_id *d;\n\n\tif (user_uartclk)\n\t\treturn user_uartclk;\n\n\td = dmi_first_match(pch_uart_dmi_table);\n\tif (d)\n\t\treturn (unsigned long)d->driver_data;\n\n\treturn DEFAULT_UARTCLK;\n}\n\nstatic void pch_uart_hal_enable_interrupt(struct eg20t_port *priv,\n\t\t\t\t\t  unsigned int flag)\n{\n\tu8 ier = ioread8(priv->membase + UART_IER);\n\tier |= flag & PCH_UART_IER_MASK;\n\tiowrite8(ier, priv->membase + UART_IER);\n}\n\nstatic void pch_uart_hal_disable_interrupt(struct eg20t_port *priv,\n\t\t\t\t\t   unsigned int flag)\n{\n\tu8 ier = ioread8(priv->membase + UART_IER);\n\tier &= ~(flag & PCH_UART_IER_MASK);\n\tiowrite8(ier, priv->membase + UART_IER);\n}\n\nstatic int pch_uart_hal_set_line(struct eg20t_port *priv, unsigned int baud,\n\t\t\t\t unsigned int parity, unsigned int bits,\n\t\t\t\t unsigned int stb)\n{\n\tunsigned int dll, dlm, lcr;\n\tint div;\n\n\tdiv = DIV_ROUND_CLOSEST(priv->uartclk / 16, baud);\n\tif (div < 0 || USHRT_MAX <= div) {\n\t\tdev_err(priv->port.dev, \"Invalid Baud(div=0x%x)\\n\", div);\n\t\treturn -EINVAL;\n\t}\n\n\tdll = (unsigned int)div & 0x00FFU;\n\tdlm = ((unsigned int)div >> 8) & 0x00FFU;\n\n\tif (parity & ~(PCH_UART_LCR_PEN | PCH_UART_LCR_EPS | PCH_UART_LCR_SP)) {\n\t\tdev_err(priv->port.dev, \"Invalid parity(0x%x)\\n\", parity);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bits & ~PCH_UART_LCR_WLS) {\n\t\tdev_err(priv->port.dev, \"Invalid bits(0x%x)\\n\", bits);\n\t\treturn -EINVAL;\n\t}\n\n\tif (stb & ~PCH_UART_LCR_STB) {\n\t\tdev_err(priv->port.dev, \"Invalid STB(0x%x)\\n\", stb);\n\t\treturn -EINVAL;\n\t}\n\n\tlcr = parity;\n\tlcr |= bits;\n\tlcr |= stb;\n\n\tdev_dbg(priv->port.dev, \"%s:baud = %u, div = %04x, lcr = %02x (%lu)\\n\",\n\t\t __func__, baud, div, lcr, jiffies);\n\tiowrite8(PCH_UART_LCR_DLAB, priv->membase + UART_LCR);\n\tiowrite8(dll, priv->membase + PCH_UART_DLL);\n\tiowrite8(dlm, priv->membase + PCH_UART_DLM);\n\tiowrite8(lcr, priv->membase + UART_LCR);\n\n\treturn 0;\n}\n\nstatic int pch_uart_hal_fifo_reset(struct eg20t_port *priv,\n\t\t\t\t    unsigned int flag)\n{\n\tif (flag & ~(PCH_UART_FCR_TFR | PCH_UART_FCR_RFR)) {\n\t\tdev_err(priv->port.dev, \"%s:Invalid flag(0x%x)\\n\",\n\t\t\t__func__, flag);\n\t\treturn -EINVAL;\n\t}\n\n\tiowrite8(PCH_UART_FCR_FIFOE | priv->fcr, priv->membase + UART_FCR);\n\tiowrite8(PCH_UART_FCR_FIFOE | priv->fcr | flag,\n\t\t priv->membase + UART_FCR);\n\tiowrite8(priv->fcr, priv->membase + UART_FCR);\n\n\treturn 0;\n}\n\nstatic int pch_uart_hal_set_fifo(struct eg20t_port *priv,\n\t\t\t\t unsigned int dmamode,\n\t\t\t\t unsigned int fifo_size, unsigned int trigger)\n{\n\tu8 fcr;\n\n\tif (dmamode & ~PCH_UART_FCR_DMS) {\n\t\tdev_err(priv->port.dev, \"%s:Invalid DMA Mode(0x%x)\\n\",\n\t\t\t__func__, dmamode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fifo_size & ~(PCH_UART_FCR_FIFOE | PCH_UART_FCR_FIFO256)) {\n\t\tdev_err(priv->port.dev, \"%s:Invalid FIFO SIZE(0x%x)\\n\",\n\t\t\t__func__, fifo_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (trigger & ~PCH_UART_FCR_RFTL) {\n\t\tdev_err(priv->port.dev, \"%s:Invalid TRIGGER(0x%x)\\n\",\n\t\t\t__func__, trigger);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (priv->fifo_size) {\n\tcase 256:\n\t\tpriv->trigger_level =\n\t\t    trigger_level_256[trigger >> PCH_UART_FCR_RFTL_SHIFT];\n\t\tbreak;\n\tcase 64:\n\t\tpriv->trigger_level =\n\t\t    trigger_level_64[trigger >> PCH_UART_FCR_RFTL_SHIFT];\n\t\tbreak;\n\tcase 16:\n\t\tpriv->trigger_level =\n\t\t    trigger_level_16[trigger >> PCH_UART_FCR_RFTL_SHIFT];\n\t\tbreak;\n\tdefault:\n\t\tpriv->trigger_level =\n\t\t    trigger_level_1[trigger >> PCH_UART_FCR_RFTL_SHIFT];\n\t\tbreak;\n\t}\n\tfcr =\n\t    dmamode | fifo_size | trigger | PCH_UART_FCR_RFR | PCH_UART_FCR_TFR;\n\tiowrite8(PCH_UART_FCR_FIFOE, priv->membase + UART_FCR);\n\tiowrite8(PCH_UART_FCR_FIFOE | PCH_UART_FCR_RFR | PCH_UART_FCR_TFR,\n\t\t priv->membase + UART_FCR);\n\tiowrite8(fcr, priv->membase + UART_FCR);\n\tpriv->fcr = fcr;\n\n\treturn 0;\n}\n\nstatic u8 pch_uart_hal_get_modem(struct eg20t_port *priv)\n{\n\tunsigned int msr = ioread8(priv->membase + UART_MSR);\n\tpriv->dmsr = msr & PCH_UART_MSR_DELTA;\n\treturn (u8)msr;\n}\n\nstatic int pch_uart_hal_read(struct eg20t_port *priv, unsigned char *buf,\n\t\t\t     int rx_size)\n{\n\tint i;\n\tu8 rbr, lsr;\n\tstruct uart_port *port = &priv->port;\n\n\tlsr = ioread8(priv->membase + UART_LSR);\n\tfor (i = 0, lsr = ioread8(priv->membase + UART_LSR);\n\t     i < rx_size && lsr & (UART_LSR_DR | UART_LSR_BI);\n\t     lsr = ioread8(priv->membase + UART_LSR)) {\n\t\trbr = ioread8(priv->membase + PCH_UART_RBR);\n\n\t\tif (lsr & UART_LSR_BI) {\n\t\t\tport->icount.brk++;\n\t\t\tif (uart_handle_break(port))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (uart_handle_sysrq_char(port, rbr))\n\t\t\tcontinue;\n\n\t\tbuf[i++] = rbr;\n\t}\n\treturn i;\n}\n\nstatic unsigned char pch_uart_hal_get_iid(struct eg20t_port *priv)\n{\n\treturn ioread8(priv->membase + UART_IIR) &\\\n\t\t      (PCH_UART_IIR_IID | PCH_UART_IIR_TOI | PCH_UART_IIR_IP);\n}\n\nstatic u8 pch_uart_hal_get_line_status(struct eg20t_port *priv)\n{\n\treturn ioread8(priv->membase + UART_LSR);\n}\n\nstatic void pch_uart_hal_set_break(struct eg20t_port *priv, int on)\n{\n\tunsigned int lcr;\n\n\tlcr = ioread8(priv->membase + UART_LCR);\n\tif (on)\n\t\tlcr |= PCH_UART_LCR_SB;\n\telse\n\t\tlcr &= ~PCH_UART_LCR_SB;\n\n\tiowrite8(lcr, priv->membase + UART_LCR);\n}\n\nstatic int push_rx(struct eg20t_port *priv, const unsigned char *buf,\n\t\t   int size)\n{\n\tstruct uart_port *port = &priv->port;\n\tstruct tty_port *tport = &port->state->port;\n\n\ttty_insert_flip_string(tport, buf, size);\n\ttty_flip_buffer_push(tport);\n\n\treturn 0;\n}\n\nstatic int dma_push_rx(struct eg20t_port *priv, int size)\n{\n\tint room;\n\tstruct uart_port *port = &priv->port;\n\tstruct tty_port *tport = &port->state->port;\n\n\troom = tty_buffer_request_room(tport, size);\n\n\tif (room < size)\n\t\tdev_warn(port->dev, \"Rx overrun: dropping %u bytes\\n\",\n\t\t\t size - room);\n\tif (!room)\n\t\treturn 0;\n\n\ttty_insert_flip_string(tport, sg_virt(&priv->sg_rx), size);\n\n\tport->icount.rx += room;\n\n\treturn room;\n}\n\nstatic void pch_free_dma(struct uart_port *port)\n{\n\tstruct eg20t_port *priv;\n\tpriv = container_of(port, struct eg20t_port, port);\n\n\tif (priv->chan_tx) {\n\t\tdma_release_channel(priv->chan_tx);\n\t\tpriv->chan_tx = NULL;\n\t}\n\tif (priv->chan_rx) {\n\t\tdma_release_channel(priv->chan_rx);\n\t\tpriv->chan_rx = NULL;\n\t}\n\n\tif (priv->rx_buf_dma) {\n\t\tdma_free_coherent(port->dev, port->fifosize, priv->rx_buf_virt,\n\t\t\t\t  priv->rx_buf_dma);\n\t\tpriv->rx_buf_virt = NULL;\n\t\tpriv->rx_buf_dma = 0;\n\t}\n\n\treturn;\n}\n\nstatic bool filter(struct dma_chan *chan, void *slave)\n{\n\tstruct pch_dma_slave *param = slave;\n\n\tif ((chan->chan_id == param->chan_id) && (param->dma_dev ==\n\t\t\t\t\t\t  chan->device->dev)) {\n\t\tchan->private = param;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nstatic void pch_request_dma(struct uart_port *port)\n{\n\tdma_cap_mask_t mask;\n\tstruct dma_chan *chan;\n\tstruct pci_dev *dma_dev;\n\tstruct pch_dma_slave *param;\n\tstruct eg20t_port *priv =\n\t\t\t\tcontainer_of(port, struct eg20t_port, port);\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\t \n\tdma_dev = pci_get_slot(priv->pdev->bus,\n\t\t\tPCI_DEVFN(PCI_SLOT(priv->pdev->devfn), 0));\n\n\t \n\tparam = &priv->param_tx;\n\tparam->dma_dev = &dma_dev->dev;\n\tparam->chan_id = priv->port.line * 2;  \n\n\tparam->tx_reg = port->mapbase + UART_TX;\n\tchan = dma_request_channel(mask, filter, param);\n\tif (!chan) {\n\t\tdev_err(priv->port.dev, \"%s:dma_request_channel FAILS(Tx)\\n\",\n\t\t\t__func__);\n\t\tpci_dev_put(dma_dev);\n\t\treturn;\n\t}\n\tpriv->chan_tx = chan;\n\n\t \n\tparam = &priv->param_rx;\n\tparam->dma_dev = &dma_dev->dev;\n\tparam->chan_id = priv->port.line * 2 + 1;  \n\n\tparam->rx_reg = port->mapbase + UART_RX;\n\tchan = dma_request_channel(mask, filter, param);\n\tif (!chan) {\n\t\tdev_err(priv->port.dev, \"%s:dma_request_channel FAILS(Rx)\\n\",\n\t\t\t__func__);\n\t\tdma_release_channel(priv->chan_tx);\n\t\tpriv->chan_tx = NULL;\n\t\tpci_dev_put(dma_dev);\n\t\treturn;\n\t}\n\n\t \n\tpriv->rx_buf_virt = dma_alloc_coherent(port->dev, port->fifosize,\n\t\t\t\t    &priv->rx_buf_dma, GFP_KERNEL);\n\tpriv->chan_rx = chan;\n\n\tpci_dev_put(dma_dev);\n}\n\nstatic void pch_dma_rx_complete(void *arg)\n{\n\tstruct eg20t_port *priv = arg;\n\tstruct uart_port *port = &priv->port;\n\tint count;\n\n\tdma_sync_sg_for_cpu(port->dev, &priv->sg_rx, 1, DMA_FROM_DEVICE);\n\tcount = dma_push_rx(priv, priv->trigger_level);\n\tif (count)\n\t\ttty_flip_buffer_push(&port->state->port);\n\tasync_tx_ack(priv->desc_rx);\n\tpch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_RX_INT |\n\t\t\t\t\t    PCH_UART_HAL_RX_ERR_INT);\n}\n\nstatic void pch_dma_tx_complete(void *arg)\n{\n\tstruct eg20t_port *priv = arg;\n\tstruct uart_port *port = &priv->port;\n\tstruct scatterlist *sg = priv->sg_tx_p;\n\tint i;\n\n\tfor (i = 0; i < priv->nent; i++, sg++)\n\t\tuart_xmit_advance(port, sg_dma_len(sg));\n\n\tasync_tx_ack(priv->desc_tx);\n\tdma_unmap_sg(port->dev, priv->sg_tx_p, priv->orig_nent, DMA_TO_DEVICE);\n\tpriv->tx_dma_use = 0;\n\tpriv->nent = 0;\n\tpriv->orig_nent = 0;\n\tkfree(priv->sg_tx_p);\n\tpch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_TX_INT);\n}\n\nstatic int handle_rx_to(struct eg20t_port *priv)\n{\n\tstruct pch_uart_buffer *buf;\n\tint rx_size;\n\tint ret;\n\tif (!priv->start_rx) {\n\t\tpch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_RX_INT |\n\t\t\t\t\t\t     PCH_UART_HAL_RX_ERR_INT);\n\t\treturn 0;\n\t}\n\tbuf = &priv->rxbuf;\n\tdo {\n\t\trx_size = pch_uart_hal_read(priv, buf->buf, buf->size);\n\t\tret = push_rx(priv, buf->buf, rx_size);\n\t\tif (ret)\n\t\t\treturn 0;\n\t} while (rx_size == buf->size);\n\n\treturn PCH_UART_HANDLED_RX_INT;\n}\n\nstatic int handle_rx(struct eg20t_port *priv)\n{\n\treturn handle_rx_to(priv);\n}\n\nstatic int dma_handle_rx(struct eg20t_port *priv)\n{\n\tstruct uart_port *port = &priv->port;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct scatterlist *sg;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\tsg = &priv->sg_rx;\n\n\tsg_init_table(&priv->sg_rx, 1);  \n\n\tsg_dma_len(sg) = priv->trigger_level;\n\n\tsg_set_page(&priv->sg_rx, virt_to_page(priv->rx_buf_virt),\n\t\t     sg_dma_len(sg), offset_in_page(priv->rx_buf_virt));\n\n\tsg_dma_address(sg) = priv->rx_buf_dma;\n\n\tdesc = dmaengine_prep_slave_sg(priv->chan_rx,\n\t\t\tsg, 1, DMA_DEV_TO_MEM,\n\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\n\tif (!desc)\n\t\treturn 0;\n\n\tpriv->desc_rx = desc;\n\tdesc->callback = pch_dma_rx_complete;\n\tdesc->callback_param = priv;\n\tdesc->tx_submit(desc);\n\tdma_async_issue_pending(priv->chan_rx);\n\n\treturn PCH_UART_HANDLED_RX_INT;\n}\n\nstatic unsigned int handle_tx(struct eg20t_port *priv)\n{\n\tstruct uart_port *port = &priv->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tint fifo_size;\n\tint tx_empty;\n\n\tif (!priv->start_tx) {\n\t\tdev_info(priv->port.dev, \"%s:Tx isn't started. (%lu)\\n\",\n\t\t\t__func__, jiffies);\n\t\tpch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_TX_INT);\n\t\tpriv->tx_empty = 1;\n\t\treturn 0;\n\t}\n\n\tfifo_size = max(priv->fifo_size, 1);\n\ttx_empty = 1;\n\tif (port->x_char) {\n\t\tiowrite8(port->x_char, priv->membase + PCH_UART_THR);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\ttx_empty = 0;\n\t\tfifo_size--;\n\t}\n\n\twhile (!uart_tx_stopped(port) && !uart_circ_empty(xmit) && fifo_size) {\n\t\tiowrite8(xmit->buf[xmit->tail], priv->membase + PCH_UART_THR);\n\t\tuart_xmit_advance(port, 1);\n\t\tfifo_size--;\n\t\ttx_empty = 0;\n\t}\n\n\tpriv->tx_empty = tx_empty;\n\n\tif (tx_empty) {\n\t\tpch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_TX_INT);\n\t\tuart_write_wakeup(port);\n\t}\n\n\treturn PCH_UART_HANDLED_TX_INT;\n}\n\nstatic unsigned int dma_handle_tx(struct eg20t_port *priv)\n{\n\tstruct uart_port *port = &priv->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tstruct scatterlist *sg;\n\tint nent;\n\tint fifo_size;\n\tstruct dma_async_tx_descriptor *desc;\n\tint num;\n\tint i;\n\tint bytes;\n\tint size;\n\tint rem;\n\n\tif (!priv->start_tx) {\n\t\tdev_info(priv->port.dev, \"%s:Tx isn't started. (%lu)\\n\",\n\t\t\t__func__, jiffies);\n\t\tpch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_TX_INT);\n\t\tpriv->tx_empty = 1;\n\t\treturn 0;\n\t}\n\n\tif (priv->tx_dma_use) {\n\t\tdev_dbg(priv->port.dev, \"%s:Tx is not completed. (%lu)\\n\",\n\t\t\t__func__, jiffies);\n\t\tpch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_TX_INT);\n\t\tpriv->tx_empty = 1;\n\t\treturn 0;\n\t}\n\n\tfifo_size = max(priv->fifo_size, 1);\n\n\tif (port->x_char) {\n\t\tiowrite8(port->x_char, priv->membase + PCH_UART_THR);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\tfifo_size--;\n\t}\n\n\tbytes = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\tif (!bytes) {\n\t\tdev_dbg(priv->port.dev, \"%s 0 bytes return\\n\", __func__);\n\t\tpch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_TX_INT);\n\t\tuart_write_wakeup(port);\n\t\treturn 0;\n\t}\n\n\tif (bytes > fifo_size) {\n\t\tnum = bytes / fifo_size + 1;\n\t\tsize = fifo_size;\n\t\trem = bytes % fifo_size;\n\t} else {\n\t\tnum = 1;\n\t\tsize = bytes;\n\t\trem = bytes;\n\t}\n\n\tdev_dbg(priv->port.dev, \"%s num=%d size=%d rem=%d\\n\",\n\t\t__func__, num, size, rem);\n\n\tpriv->tx_dma_use = 1;\n\n\tpriv->sg_tx_p = kmalloc_array(num, sizeof(struct scatterlist), GFP_ATOMIC);\n\tif (!priv->sg_tx_p) {\n\t\tdev_err(priv->port.dev, \"%s:kzalloc Failed\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tsg_init_table(priv->sg_tx_p, num);  \n\tsg = priv->sg_tx_p;\n\n\tfor (i = 0; i < num; i++, sg++) {\n\t\tif (i == (num - 1))\n\t\t\tsg_set_page(sg, virt_to_page(xmit->buf),\n\t\t\t\t    rem, fifo_size * i);\n\t\telse\n\t\t\tsg_set_page(sg, virt_to_page(xmit->buf),\n\t\t\t\t    size, fifo_size * i);\n\t}\n\n\tsg = priv->sg_tx_p;\n\tnent = dma_map_sg(port->dev, sg, num, DMA_TO_DEVICE);\n\tif (!nent) {\n\t\tdev_err(priv->port.dev, \"%s:dma_map_sg Failed\\n\", __func__);\n\t\treturn 0;\n\t}\n\tpriv->orig_nent = num;\n\tpriv->nent = nent;\n\n\tfor (i = 0; i < nent; i++, sg++) {\n\t\tsg->offset = (xmit->tail & (UART_XMIT_SIZE - 1)) +\n\t\t\t      fifo_size * i;\n\t\tsg_dma_address(sg) = (sg_dma_address(sg) &\n\t\t\t\t    ~(UART_XMIT_SIZE - 1)) + sg->offset;\n\t\tif (i == (nent - 1))\n\t\t\tsg_dma_len(sg) = rem;\n\t\telse\n\t\t\tsg_dma_len(sg) = size;\n\t}\n\n\tdesc = dmaengine_prep_slave_sg(priv->chan_tx,\n\t\t\t\t\tpriv->sg_tx_p, nent, DMA_MEM_TO_DEV,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdev_err(priv->port.dev, \"%s:dmaengine_prep_slave_sg Failed\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\tdma_sync_sg_for_device(port->dev, priv->sg_tx_p, nent, DMA_TO_DEVICE);\n\tpriv->desc_tx = desc;\n\tdesc->callback = pch_dma_tx_complete;\n\tdesc->callback_param = priv;\n\n\tdesc->tx_submit(desc);\n\n\tdma_async_issue_pending(priv->chan_tx);\n\n\treturn PCH_UART_HANDLED_TX_INT;\n}\n\nstatic void pch_uart_err_ir(struct eg20t_port *priv, unsigned int lsr)\n{\n\tstruct uart_port *port = &priv->port;\n\tstruct tty_struct *tty = tty_port_tty_get(&port->state->port);\n\tchar   *error_msg[5] = {};\n\tint    i = 0;\n\n\tif (lsr & PCH_UART_LSR_ERR)\n\t\terror_msg[i++] = \"Error data in FIFO\\n\";\n\n\tif (lsr & UART_LSR_FE) {\n\t\tport->icount.frame++;\n\t\terror_msg[i++] = \"  Framing Error\\n\";\n\t}\n\n\tif (lsr & UART_LSR_PE) {\n\t\tport->icount.parity++;\n\t\terror_msg[i++] = \"  Parity Error\\n\";\n\t}\n\n\tif (lsr & UART_LSR_OE) {\n\t\tport->icount.overrun++;\n\t\terror_msg[i++] = \"  Overrun Error\\n\";\n\t}\n\n\tif (tty == NULL) {\n\t\tfor (i = 0; error_msg[i] != NULL; i++)\n\t\t\tdev_err(&priv->pdev->dev, error_msg[i]);\n\t} else {\n\t\ttty_kref_put(tty);\n\t}\n}\n\nstatic irqreturn_t pch_uart_interrupt(int irq, void *dev_id)\n{\n\tstruct eg20t_port *priv = dev_id;\n\tunsigned int handled;\n\tu8 lsr;\n\tint ret = 0;\n\tunsigned char iid;\n\tunsigned long flags;\n\tint next = 1;\n\tu8 msr;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\thandled = 0;\n\twhile (next) {\n\t\tiid = pch_uart_hal_get_iid(priv);\n\t\tif (iid & PCH_UART_IIR_IP)  \n\t\t\tbreak;\n\t\tswitch (iid) {\n\t\tcase PCH_UART_IID_RLS:\t \n\t\t\tlsr = pch_uart_hal_get_line_status(priv);\n\t\t\tif (lsr & (PCH_UART_LSR_ERR | UART_LSR_FE |\n\t\t\t\t\t\tUART_LSR_PE | UART_LSR_OE)) {\n\t\t\t\tpch_uart_err_ir(priv, lsr);\n\t\t\t\tret = PCH_UART_HANDLED_RX_ERR_INT;\n\t\t\t} else {\n\t\t\t\tret = PCH_UART_HANDLED_LS_INT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCH_UART_IID_RDR:\t \n\t\t\tif (priv->use_dma) {\n\t\t\t\tpch_uart_hal_disable_interrupt(priv,\n\t\t\t\t\t\tPCH_UART_HAL_RX_INT |\n\t\t\t\t\t\tPCH_UART_HAL_RX_ERR_INT);\n\t\t\t\tret = dma_handle_rx(priv);\n\t\t\t\tif (!ret)\n\t\t\t\t\tpch_uart_hal_enable_interrupt(priv,\n\t\t\t\t\t\tPCH_UART_HAL_RX_INT |\n\t\t\t\t\t\tPCH_UART_HAL_RX_ERR_INT);\n\t\t\t} else {\n\t\t\t\tret = handle_rx(priv);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCH_UART_IID_RDR_TO:\t \n\t\t\tret = handle_rx_to(priv);\n\t\t\tbreak;\n\t\tcase PCH_UART_IID_THRE:\t \n\t\t\tif (priv->use_dma)\n\t\t\t\tret = dma_handle_tx(priv);\n\t\t\telse\n\t\t\t\tret = handle_tx(priv);\n\t\t\tbreak;\n\t\tcase PCH_UART_IID_MS:\t \n\t\t\tmsr = pch_uart_hal_get_modem(priv);\n\t\t\tnext = 0;  \n\t\t\tif ((msr & UART_MSR_ANY_DELTA) == 0)\n\t\t\t\tbreak;\n\t\t\tret |= PCH_UART_HANDLED_MS_INT;\n\t\t\tbreak;\n\t\tdefault:\t \n\t\t\tdev_err(priv->port.dev, \"%s:iid=%02x (%lu)\\n\", __func__,\n\t\t\t\tiid, jiffies);\n\t\t\tret = -1;\n\t\t\tnext = 0;\n\t\t\tbreak;\n\t\t}\n\t\thandled |= (unsigned int)ret;\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn IRQ_RETVAL(handled);\n}\n\n \nstatic unsigned int pch_uart_tx_empty(struct uart_port *port)\n{\n\tstruct eg20t_port *priv;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\tif (priv->tx_empty)\n\t\treturn TIOCSER_TEMT;\n\telse\n\t\treturn 0;\n}\n\n \nstatic unsigned int pch_uart_get_mctrl(struct uart_port *port)\n{\n\tstruct eg20t_port *priv;\n\tu8 modem;\n\tunsigned int ret = 0;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\tmodem = pch_uart_hal_get_modem(priv);\n\n\tif (modem & UART_MSR_DCD)\n\t\tret |= TIOCM_CAR;\n\n\tif (modem & UART_MSR_RI)\n\t\tret |= TIOCM_RNG;\n\n\tif (modem & UART_MSR_DSR)\n\t\tret |= TIOCM_DSR;\n\n\tif (modem & UART_MSR_CTS)\n\t\tret |= TIOCM_CTS;\n\n\treturn ret;\n}\n\nstatic void pch_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tu32 mcr = 0;\n\tstruct eg20t_port *priv = container_of(port, struct eg20t_port, port);\n\n\tif (mctrl & TIOCM_DTR)\n\t\tmcr |= UART_MCR_DTR;\n\tif (mctrl & TIOCM_RTS)\n\t\tmcr |= UART_MCR_RTS;\n\tif (mctrl & TIOCM_LOOP)\n\t\tmcr |= UART_MCR_LOOP;\n\n\tif (priv->mcr & UART_MCR_AFE)\n\t\tmcr |= UART_MCR_AFE;\n\n\tif (mctrl)\n\t\tiowrite8(mcr, priv->membase + UART_MCR);\n}\n\nstatic void pch_uart_stop_tx(struct uart_port *port)\n{\n\tstruct eg20t_port *priv;\n\tpriv = container_of(port, struct eg20t_port, port);\n\tpriv->start_tx = 0;\n\tpriv->tx_dma_use = 0;\n}\n\nstatic void pch_uart_start_tx(struct uart_port *port)\n{\n\tstruct eg20t_port *priv;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\n\tif (priv->use_dma) {\n\t\tif (priv->tx_dma_use) {\n\t\t\tdev_dbg(priv->port.dev, \"%s : Tx DMA is NOT empty.\\n\",\n\t\t\t\t__func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpriv->start_tx = 1;\n\tpch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_TX_INT);\n}\n\nstatic void pch_uart_stop_rx(struct uart_port *port)\n{\n\tstruct eg20t_port *priv;\n\tpriv = container_of(port, struct eg20t_port, port);\n\tpriv->start_rx = 0;\n\tpch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_RX_INT |\n\t\t\t\t\t     PCH_UART_HAL_RX_ERR_INT);\n}\n\n \nstatic void pch_uart_enable_ms(struct uart_port *port)\n{\n\tstruct eg20t_port *priv;\n\tpriv = container_of(port, struct eg20t_port, port);\n\tpch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_MS_INT);\n}\n\n \nstatic void pch_uart_break_ctl(struct uart_port *port, int ctl)\n{\n\tstruct eg20t_port *priv;\n\tunsigned long flags;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpch_uart_hal_set_break(priv, ctl);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\n \nstatic int pch_uart_startup(struct uart_port *port)\n{\n\tstruct eg20t_port *priv;\n\tint ret;\n\tint fifo_size;\n\tint trigger_level;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\tpriv->tx_empty = 1;\n\n\tif (port->uartclk)\n\t\tpriv->uartclk = port->uartclk;\n\telse\n\t\tport->uartclk = priv->uartclk;\n\n\tpch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_ALL_INT);\n\tret = pch_uart_hal_set_line(priv, default_baud,\n\t\t\t      PCH_UART_HAL_PARITY_NONE, PCH_UART_HAL_8BIT,\n\t\t\t      PCH_UART_HAL_STB1);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (priv->fifo_size) {\n\tcase 256:\n\t\tfifo_size = PCH_UART_HAL_FIFO256;\n\t\tbreak;\n\tcase 64:\n\t\tfifo_size = PCH_UART_HAL_FIFO64;\n\t\tbreak;\n\tcase 16:\n\t\tfifo_size = PCH_UART_HAL_FIFO16;\n\t\tbreak;\n\tcase 1:\n\tdefault:\n\t\tfifo_size = PCH_UART_HAL_FIFO_DIS;\n\t\tbreak;\n\t}\n\n\tswitch (priv->trigger) {\n\tcase PCH_UART_HAL_TRIGGER1:\n\t\ttrigger_level = 1;\n\t\tbreak;\n\tcase PCH_UART_HAL_TRIGGER_L:\n\t\ttrigger_level = priv->fifo_size / 4;\n\t\tbreak;\n\tcase PCH_UART_HAL_TRIGGER_M:\n\t\ttrigger_level = priv->fifo_size / 2;\n\t\tbreak;\n\tcase PCH_UART_HAL_TRIGGER_H:\n\tdefault:\n\t\ttrigger_level = priv->fifo_size - (priv->fifo_size / 8);\n\t\tbreak;\n\t}\n\n\tpriv->trigger_level = trigger_level;\n\tret = pch_uart_hal_set_fifo(priv, PCH_UART_HAL_DMA_MODE0,\n\t\t\t\t    fifo_size, priv->trigger);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = request_irq(priv->port.irq, pch_uart_interrupt, IRQF_SHARED,\n\t\t\tpriv->irq_name, priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (priv->use_dma)\n\t\tpch_request_dma(port);\n\n\tpriv->start_rx = 1;\n\tpch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_RX_INT |\n\t\t\t\t\t    PCH_UART_HAL_RX_ERR_INT);\n\tuart_update_timeout(port, CS8, default_baud);\n\n\treturn 0;\n}\n\nstatic void pch_uart_shutdown(struct uart_port *port)\n{\n\tstruct eg20t_port *priv;\n\tint ret;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\tpch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_ALL_INT);\n\tpch_uart_hal_fifo_reset(priv, PCH_UART_HAL_CLR_ALL_FIFO);\n\tret = pch_uart_hal_set_fifo(priv, PCH_UART_HAL_DMA_MODE0,\n\t\t\t      PCH_UART_HAL_FIFO_DIS, PCH_UART_HAL_TRIGGER1);\n\tif (ret)\n\t\tdev_err(priv->port.dev,\n\t\t\t\"pch_uart_hal_set_fifo Failed(ret=%d)\\n\", ret);\n\n\tpch_free_dma(port);\n\n\tfree_irq(priv->port.irq, priv);\n}\n\n \nstatic void pch_uart_set_termios(struct uart_port *port,\n\t\t\t\t struct ktermios *termios,\n\t\t\t\t const struct ktermios *old)\n{\n\tint rtn;\n\tunsigned int baud, parity, bits, stb;\n\tstruct eg20t_port *priv;\n\tunsigned long flags;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tbits = PCH_UART_HAL_5BIT;\n\t\tbreak;\n\tcase CS6:\n\t\tbits = PCH_UART_HAL_6BIT;\n\t\tbreak;\n\tcase CS7:\n\t\tbits = PCH_UART_HAL_7BIT;\n\t\tbreak;\n\tdefault:\t\t \n\t\tbits = PCH_UART_HAL_8BIT;\n\t\tbreak;\n\t}\n\tif (termios->c_cflag & CSTOPB)\n\t\tstb = PCH_UART_HAL_STB2;\n\telse\n\t\tstb = PCH_UART_HAL_STB1;\n\n\tif (termios->c_cflag & PARENB) {\n\t\tif (termios->c_cflag & PARODD)\n\t\t\tparity = PCH_UART_HAL_PARITY_ODD;\n\t\telse\n\t\t\tparity = PCH_UART_HAL_PARITY_EVEN;\n\n\t} else\n\t\tparity = PCH_UART_HAL_PARITY_NONE;\n\n\t \n\tif ((termios->c_cflag & CRTSCTS) && (priv->fifo_size == 256))\n\t\tpriv->mcr |= UART_MCR_AFE;\n\telse\n\t\tpriv->mcr &= ~UART_MCR_AFE;\n\n\ttermios->c_cflag &= ~CMSPAR;  \n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tspin_lock(&port->lock);\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\trtn = pch_uart_hal_set_line(priv, baud, parity, bits, stb);\n\tif (rtn)\n\t\tgoto out;\n\n\tpch_uart_set_mctrl(&priv->port, priv->port.mctrl);\n\t \n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\nout:\n\tspin_unlock(&port->lock);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic const char *pch_uart_type(struct uart_port *port)\n{\n\treturn KBUILD_MODNAME;\n}\n\nstatic void pch_uart_release_port(struct uart_port *port)\n{\n\tstruct eg20t_port *priv;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\tpci_iounmap(priv->pdev, priv->membase);\n\tpci_release_regions(priv->pdev);\n}\n\nstatic int pch_uart_request_port(struct uart_port *port)\n{\n\tstruct eg20t_port *priv;\n\tint ret;\n\tvoid __iomem *membase;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\tret = pci_request_regions(priv->pdev, KBUILD_MODNAME);\n\tif (ret < 0)\n\t\treturn -EBUSY;\n\n\tmembase = pci_iomap(priv->pdev, 1, 0);\n\tif (!membase) {\n\t\tpci_release_regions(priv->pdev);\n\t\treturn -EBUSY;\n\t}\n\tpriv->membase = port->membase = membase;\n\n\treturn 0;\n}\n\nstatic void pch_uart_config_port(struct uart_port *port, int type)\n{\n\tstruct eg20t_port *priv;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\tif (type & UART_CONFIG_TYPE) {\n\t\tport->type = priv->port_type;\n\t\tpch_uart_request_port(port);\n\t}\n}\n\nstatic int pch_uart_verify_port(struct uart_port *port,\n\t\t\t\tstruct serial_struct *serinfo)\n{\n\tstruct eg20t_port *priv;\n\n\tpriv = container_of(port, struct eg20t_port, port);\n\tif (serinfo->flags & UPF_LOW_LATENCY) {\n\t\tdev_info(priv->port.dev,\n\t\t\t\"PCH UART : Use PIO Mode (without DMA)\\n\");\n\t\tpriv->use_dma = 0;\n\t\tserinfo->flags &= ~UPF_LOW_LATENCY;\n\t} else {\n#ifndef CONFIG_PCH_DMA\n\t\tdev_err(priv->port.dev, \"%s : PCH DMA is not Loaded.\\n\",\n\t\t\t__func__);\n\t\treturn -EOPNOTSUPP;\n#endif\n\t\tif (!priv->use_dma) {\n\t\t\tpch_request_dma(port);\n\t\t\tif (priv->chan_rx)\n\t\t\t\tpriv->use_dma = 1;\n\t\t}\n\t\tdev_info(priv->port.dev, \"PCH UART: %s\\n\",\n\t\t\t\tpriv->use_dma ?\n\t\t\t\t\"Use DMA Mode\" : \"No DMA\");\n\t}\n\n\treturn 0;\n}\n\n#if defined(CONFIG_CONSOLE_POLL) || defined(CONFIG_SERIAL_PCH_UART_CONSOLE)\n \nstatic void wait_for_xmitr(struct eg20t_port *up, int bits)\n{\n\tunsigned int status, tmout = 10000;\n\n\t \n\tfor (;;) {\n\t\tstatus = ioread8(up->membase + UART_LSR);\n\n\t\tif ((status & bits) == bits)\n\t\t\tbreak;\n\t\tif (--tmout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\t \n\tif (up->port.flags & UPF_CONS_FLOW) {\n\t\tunsigned int tmout;\n\t\tfor (tmout = 1000000; tmout; tmout--) {\n\t\t\tunsigned int msr = ioread8(up->membase + UART_MSR);\n\t\t\tif (msr & UART_MSR_CTS)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n}\n#endif  \n\n#ifdef CONFIG_CONSOLE_POLL\n \nstatic int pch_uart_get_poll_char(struct uart_port *port)\n{\n\tstruct eg20t_port *priv =\n\t\tcontainer_of(port, struct eg20t_port, port);\n\tu8 lsr = ioread8(priv->membase + UART_LSR);\n\n\tif (!(lsr & UART_LSR_DR))\n\t\treturn NO_POLL_CHAR;\n\n\treturn ioread8(priv->membase + PCH_UART_RBR);\n}\n\n\nstatic void pch_uart_put_poll_char(struct uart_port *port,\n\t\t\t unsigned char c)\n{\n\tunsigned int ier;\n\tstruct eg20t_port *priv =\n\t\tcontainer_of(port, struct eg20t_port, port);\n\n\t \n\tier = ioread8(priv->membase + UART_IER);\n\tpch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_ALL_INT);\n\n\twait_for_xmitr(priv, UART_LSR_THRE);\n\t \n\tiowrite8(c, priv->membase + PCH_UART_THR);\n\n\t \n\twait_for_xmitr(priv, UART_LSR_BOTH_EMPTY);\n\tiowrite8(ier, priv->membase + UART_IER);\n}\n#endif  \n\nstatic const struct uart_ops pch_uart_ops = {\n\t.tx_empty = pch_uart_tx_empty,\n\t.set_mctrl = pch_uart_set_mctrl,\n\t.get_mctrl = pch_uart_get_mctrl,\n\t.stop_tx = pch_uart_stop_tx,\n\t.start_tx = pch_uart_start_tx,\n\t.stop_rx = pch_uart_stop_rx,\n\t.enable_ms = pch_uart_enable_ms,\n\t.break_ctl = pch_uart_break_ctl,\n\t.startup = pch_uart_startup,\n\t.shutdown = pch_uart_shutdown,\n\t.set_termios = pch_uart_set_termios,\n \n\t.type = pch_uart_type,\n\t.release_port = pch_uart_release_port,\n\t.request_port = pch_uart_request_port,\n\t.config_port = pch_uart_config_port,\n\t.verify_port = pch_uart_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char = pch_uart_get_poll_char,\n\t.poll_put_char = pch_uart_put_poll_char,\n#endif\n};\n\n#ifdef CONFIG_SERIAL_PCH_UART_CONSOLE\n\nstatic void pch_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct eg20t_port *priv =\n\t\tcontainer_of(port, struct eg20t_port, port);\n\n\twait_for_xmitr(priv, UART_LSR_THRE);\n\tiowrite8(ch, priv->membase + PCH_UART_THR);\n}\n\n \nstatic void\npch_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct eg20t_port *priv;\n\tunsigned long flags;\n\tint priv_locked = 1;\n\tint port_locked = 1;\n\tu8 ier;\n\n\tpriv = pch_uart_ports[co->index];\n\n\ttouch_nmi_watchdog();\n\n\tlocal_irq_save(flags);\n\tif (priv->port.sysrq) {\n\t\t \n\t\tpriv_locked = 0;\n\t\t \n\t\tport_locked = 0;\n\t} else if (oops_in_progress) {\n\t\tpriv_locked = spin_trylock(&priv->lock);\n\t\tport_locked = spin_trylock(&priv->port.lock);\n\t} else {\n\t\tspin_lock(&priv->lock);\n\t\tspin_lock(&priv->port.lock);\n\t}\n\n\t \n\tier = ioread8(priv->membase + UART_IER);\n\n\tpch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_ALL_INT);\n\n\tuart_console_write(&priv->port, s, count, pch_console_putchar);\n\n\t \n\twait_for_xmitr(priv, UART_LSR_BOTH_EMPTY);\n\tiowrite8(ier, priv->membase + UART_IER);\n\n\tif (port_locked)\n\t\tspin_unlock(&priv->port.lock);\n\tif (priv_locked)\n\t\tspin_unlock(&priv->lock);\n\tlocal_irq_restore(flags);\n}\n\nstatic int __init pch_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint baud = default_baud;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\t \n\tif (co->index >= PCH_UART_NR)\n\t\tco->index = 0;\n\tport = &pch_uart_ports[co->index]->port;\n\n\tif (!port || (!port->iobase && !port->membase))\n\t\treturn -ENODEV;\n\n\tport->uartclk = pch_uart_get_uartclk();\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver pch_uart_driver;\n\nstatic struct console pch_console = {\n\t.name\t\t= PCH_UART_DRIVER_DEVICE,\n\t.write\t\t= pch_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= pch_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ANYTIME,\n\t.index\t\t= -1,\n\t.data\t\t= &pch_uart_driver,\n};\n\n#define PCH_CONSOLE\t(&pch_console)\n#else\n#define PCH_CONSOLE\tNULL\n#endif\t \n\nstatic struct uart_driver pch_uart_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = KBUILD_MODNAME,\n\t.dev_name = PCH_UART_DRIVER_DEVICE,\n\t.major = 0,\n\t.minor = 0,\n\t.nr = PCH_UART_NR,\n\t.cons = PCH_CONSOLE,\n};\n\nstatic struct eg20t_port *pch_uart_init_port(struct pci_dev *pdev,\n\t\t\t\t\t     const struct pci_device_id *id)\n{\n\tstruct eg20t_port *priv;\n\tint ret;\n\tunsigned int iobase;\n\tunsigned int mapbase;\n\tunsigned char *rxbuf;\n\tint fifosize;\n\tint port_type;\n\tstruct pch_uart_driver_data *board;\n\tchar name[32];\n\n\tboard = &drv_dat[id->driver_data];\n\tport_type = board->port_type;\n\n\tpriv = kzalloc(sizeof(struct eg20t_port), GFP_KERNEL);\n\tif (priv == NULL)\n\t\tgoto init_port_alloc_err;\n\n\trxbuf = (unsigned char *)__get_free_page(GFP_KERNEL);\n\tif (!rxbuf)\n\t\tgoto init_port_free_txbuf;\n\n\tswitch (port_type) {\n\tcase PORT_PCH_8LINE:\n\t\tfifosize = 256;  \n\t\tbreak;\n\tcase PORT_PCH_2LINE:\n\t\tfifosize = 64;  \n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Invalid Port Type(=%d)\\n\", port_type);\n\t\tgoto init_port_hal_free;\n\t}\n\n\tpci_enable_msi(pdev);\n\tpci_set_master(pdev);\n\n\tspin_lock_init(&priv->lock);\n\n\tiobase = pci_resource_start(pdev, 0);\n\tmapbase = pci_resource_start(pdev, 1);\n\tpriv->mapbase = mapbase;\n\tpriv->iobase = iobase;\n\tpriv->pdev = pdev;\n\tpriv->tx_empty = 1;\n\tpriv->rxbuf.buf = rxbuf;\n\tpriv->rxbuf.size = PAGE_SIZE;\n\n\tpriv->fifo_size = fifosize;\n\tpriv->uartclk = pch_uart_get_uartclk();\n\tpriv->port_type = port_type;\n\tpriv->port.dev = &pdev->dev;\n\tpriv->port.iobase = iobase;\n\tpriv->port.membase = NULL;\n\tpriv->port.mapbase = mapbase;\n\tpriv->port.irq = pdev->irq;\n\tpriv->port.iotype = UPIO_PORT;\n\tpriv->port.ops = &pch_uart_ops;\n\tpriv->port.flags = UPF_BOOT_AUTOCONF;\n\tpriv->port.fifosize = fifosize;\n\tpriv->port.line = board->line_no;\n\tpriv->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_PCH_UART_CONSOLE);\n\tpriv->trigger = PCH_UART_HAL_TRIGGER_M;\n\n\tsnprintf(priv->irq_name, IRQ_NAME_SIZE,\n\t\t KBUILD_MODNAME \":\" PCH_UART_DRIVER_DEVICE \"%d\",\n\t\t priv->port.line);\n\n\tspin_lock_init(&priv->port.lock);\n\n\tpci_set_drvdata(pdev, priv);\n\tpriv->trigger_level = 1;\n\tpriv->fcr = 0;\n\n\tif (pdev->dev.of_node)\n\t\tof_property_read_u32(pdev->dev.of_node, \"clock-frequency\"\n\t\t\t\t\t , &user_uartclk);\n\n#ifdef CONFIG_SERIAL_PCH_UART_CONSOLE\n\tpch_uart_ports[board->line_no] = priv;\n#endif\n\tret = uart_add_one_port(&pch_uart_driver, &priv->port);\n\tif (ret < 0)\n\t\tgoto init_port_hal_free;\n\n\tsnprintf(name, sizeof(name), \"uart%d_regs\", priv->port.line);\n\tdebugfs_create_file(name, S_IFREG | S_IRUGO, NULL, priv,\n\t\t\t    &port_regs_ops);\n\n\treturn priv;\n\ninit_port_hal_free:\n#ifdef CONFIG_SERIAL_PCH_UART_CONSOLE\n\tpch_uart_ports[board->line_no] = NULL;\n#endif\n\tfree_page((unsigned long)rxbuf);\ninit_port_free_txbuf:\n\tkfree(priv);\ninit_port_alloc_err:\n\n\treturn NULL;\n}\n\nstatic void pch_uart_exit_port(struct eg20t_port *priv)\n{\n\tchar name[32];\n\n\tsnprintf(name, sizeof(name), \"uart%d_regs\", priv->port.line);\n\tdebugfs_lookup_and_remove(name, NULL);\n\tuart_remove_one_port(&pch_uart_driver, &priv->port);\n\tfree_page((unsigned long)priv->rxbuf.buf);\n}\n\nstatic void pch_uart_pci_remove(struct pci_dev *pdev)\n{\n\tstruct eg20t_port *priv = pci_get_drvdata(pdev);\n\n\tpci_disable_msi(pdev);\n\n#ifdef CONFIG_SERIAL_PCH_UART_CONSOLE\n\tpch_uart_ports[priv->port.line] = NULL;\n#endif\n\tpch_uart_exit_port(priv);\n\tpci_disable_device(pdev);\n\tkfree(priv);\n\treturn;\n}\n\nstatic int __maybe_unused pch_uart_pci_suspend(struct device *dev)\n{\n\tstruct eg20t_port *priv = dev_get_drvdata(dev);\n\n\tuart_suspend_port(&pch_uart_driver, &priv->port);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pch_uart_pci_resume(struct device *dev)\n{\n\tstruct eg20t_port *priv = dev_get_drvdata(dev);\n\n\tuart_resume_port(&pch_uart_driver, &priv->port);\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id pch_uart_pci_id[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x8811),\n\t .driver_data = pch_et20t_uart0},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x8812),\n\t .driver_data = pch_et20t_uart1},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x8813),\n\t .driver_data = pch_et20t_uart2},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x8814),\n\t .driver_data = pch_et20t_uart3},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ROHM, 0x8027),\n\t .driver_data = pch_ml7213_uart0},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ROHM, 0x8028),\n\t .driver_data = pch_ml7213_uart1},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ROHM, 0x8029),\n\t .driver_data = pch_ml7213_uart2},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ROHM, 0x800C),\n\t .driver_data = pch_ml7223_uart0},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ROHM, 0x800D),\n\t .driver_data = pch_ml7223_uart1},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ROHM, 0x8811),\n\t .driver_data = pch_ml7831_uart0},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ROHM, 0x8812),\n\t .driver_data = pch_ml7831_uart1},\n\t{0,},\n};\n\nstatic int pch_uart_pci_probe(struct pci_dev *pdev,\n\t\t\t\t\tconst struct pci_device_id *id)\n{\n\tint ret;\n\tstruct eg20t_port *priv;\n\n\tret = pci_enable_device(pdev);\n\tif (ret < 0)\n\t\tgoto probe_error;\n\n\tpriv = pch_uart_init_port(pdev, id);\n\tif (!priv) {\n\t\tret = -EBUSY;\n\t\tgoto probe_disable_device;\n\t}\n\tpci_set_drvdata(pdev, priv);\n\n\treturn ret;\n\nprobe_disable_device:\n\tpci_disable_msi(pdev);\n\tpci_disable_device(pdev);\nprobe_error:\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(pch_uart_pci_pm_ops,\n\t\t\t pch_uart_pci_suspend,\n\t\t\t pch_uart_pci_resume);\n\nstatic struct pci_driver pch_uart_pci_driver = {\n\t.name = \"pch_uart\",\n\t.id_table = pch_uart_pci_id,\n\t.probe = pch_uart_pci_probe,\n\t.remove = pch_uart_pci_remove,\n\t.driver.pm = &pch_uart_pci_pm_ops,\n};\n\nstatic int __init pch_uart_module_init(void)\n{\n\tint ret;\n\n\t \n\tret = uart_register_driver(&pch_uart_driver);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = pci_register_driver(&pch_uart_pci_driver);\n\tif (ret < 0)\n\t\tuart_unregister_driver(&pch_uart_driver);\n\n\treturn ret;\n}\nmodule_init(pch_uart_module_init);\n\nstatic void __exit pch_uart_module_exit(void)\n{\n\tpci_unregister_driver(&pch_uart_pci_driver);\n\tuart_unregister_driver(&pch_uart_driver);\n}\nmodule_exit(pch_uart_module_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel EG20T PCH UART PCI Driver\");\nMODULE_DEVICE_TABLE(pci, pch_uart_pci_id);\n\nmodule_param(default_baud, uint, S_IRUGO);\nMODULE_PARM_DESC(default_baud,\n                 \"Default BAUD for initial driver state and console (default 9600)\");\nmodule_param(user_uartclk, uint, S_IRUGO);\nMODULE_PARM_DESC(user_uartclk,\n                 \"Override UART default or board specific UART clock\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}