{
  "module_name": "lpc32xx_hs.c",
  "hash_id": "f4d7d410572fadbd1031fde50b8282ae3e8fe40c46f4d0a4911e49a94c4d0d4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/lpc32xx_hs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/sizes.h>\n#include <linux/soc/nxp/lpc32xx-misc.h>\n\n \n#define LPC32XX_HSUART_FIFO(x)\t\t\t((x) + 0x00)\n#define LPC32XX_HSUART_LEVEL(x)\t\t\t((x) + 0x04)\n#define LPC32XX_HSUART_IIR(x)\t\t\t((x) + 0x08)\n#define LPC32XX_HSUART_CTRL(x)\t\t\t((x) + 0x0C)\n#define LPC32XX_HSUART_RATE(x)\t\t\t((x) + 0x10)\n\n#define LPC32XX_HSU_BREAK_DATA\t\t\t(1 << 10)\n#define LPC32XX_HSU_ERROR_DATA\t\t\t(1 << 9)\n#define LPC32XX_HSU_RX_EMPTY\t\t\t(1 << 8)\n\n#define LPC32XX_HSU_TX_LEV(n)\t\t\t(((n) >> 8) & 0xFF)\n#define LPC32XX_HSU_RX_LEV(n)\t\t\t((n) & 0xFF)\n\n#define LPC32XX_HSU_TX_INT_SET\t\t\t(1 << 6)\n#define LPC32XX_HSU_RX_OE_INT\t\t\t(1 << 5)\n#define LPC32XX_HSU_BRK_INT\t\t\t(1 << 4)\n#define LPC32XX_HSU_FE_INT\t\t\t(1 << 3)\n#define LPC32XX_HSU_RX_TIMEOUT_INT\t\t(1 << 2)\n#define LPC32XX_HSU_RX_TRIG_INT\t\t\t(1 << 1)\n#define LPC32XX_HSU_TX_INT\t\t\t(1 << 0)\n\n#define LPC32XX_HSU_HRTS_INV\t\t\t(1 << 21)\n#define LPC32XX_HSU_HRTS_TRIG_8B\t\t(0x0 << 19)\n#define LPC32XX_HSU_HRTS_TRIG_16B\t\t(0x1 << 19)\n#define LPC32XX_HSU_HRTS_TRIG_32B\t\t(0x2 << 19)\n#define LPC32XX_HSU_HRTS_TRIG_48B\t\t(0x3 << 19)\n#define LPC32XX_HSU_HRTS_EN\t\t\t(1 << 18)\n#define LPC32XX_HSU_TMO_DISABLED\t\t(0x0 << 16)\n#define LPC32XX_HSU_TMO_INACT_4B\t\t(0x1 << 16)\n#define LPC32XX_HSU_TMO_INACT_8B\t\t(0x2 << 16)\n#define LPC32XX_HSU_TMO_INACT_16B\t\t(0x3 << 16)\n#define LPC32XX_HSU_HCTS_INV\t\t\t(1 << 15)\n#define LPC32XX_HSU_HCTS_EN\t\t\t(1 << 14)\n#define LPC32XX_HSU_OFFSET(n)\t\t\t((n) << 9)\n#define LPC32XX_HSU_BREAK\t\t\t(1 << 8)\n#define LPC32XX_HSU_ERR_INT_EN\t\t\t(1 << 7)\n#define LPC32XX_HSU_RX_INT_EN\t\t\t(1 << 6)\n#define LPC32XX_HSU_TX_INT_EN\t\t\t(1 << 5)\n#define LPC32XX_HSU_RX_TL1B\t\t\t(0x0 << 2)\n#define LPC32XX_HSU_RX_TL4B\t\t\t(0x1 << 2)\n#define LPC32XX_HSU_RX_TL8B\t\t\t(0x2 << 2)\n#define LPC32XX_HSU_RX_TL16B\t\t\t(0x3 << 2)\n#define LPC32XX_HSU_RX_TL32B\t\t\t(0x4 << 2)\n#define LPC32XX_HSU_RX_TL48B\t\t\t(0x5 << 2)\n#define LPC32XX_HSU_TX_TLEMPTY\t\t\t(0x0 << 0)\n#define LPC32XX_HSU_TX_TL0B\t\t\t(0x0 << 0)\n#define LPC32XX_HSU_TX_TL4B\t\t\t(0x1 << 0)\n#define LPC32XX_HSU_TX_TL8B\t\t\t(0x2 << 0)\n#define LPC32XX_HSU_TX_TL16B\t\t\t(0x3 << 0)\n\n#define LPC32XX_MAIN_OSC_FREQ\t\t\t13000000\n\n#define MODNAME \"lpc32xx_hsuart\"\n\nstruct lpc32xx_hsuart_port {\n\tstruct uart_port port;\n};\n\n#define FIFO_READ_LIMIT 128\n#define MAX_PORTS 3\n#define LPC32XX_TTY_NAME \"ttyTX\"\nstatic struct lpc32xx_hsuart_port lpc32xx_hs_ports[MAX_PORTS];\n\n#ifdef CONFIG_SERIAL_HS_LPC32XX_CONSOLE\nstatic void wait_for_xmit_empty(struct uart_port *port)\n{\n\tunsigned int timeout = 10000;\n\n\tdo {\n\t\tif (LPC32XX_HSU_TX_LEV(readl(LPC32XX_HSUART_LEVEL(\n\t\t\t\t\t\t\tport->membase))) == 0)\n\t\t\tbreak;\n\t\tif (--timeout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (1);\n}\n\nstatic void wait_for_xmit_ready(struct uart_port *port)\n{\n\tunsigned int timeout = 10000;\n\n\twhile (1) {\n\t\tif (LPC32XX_HSU_TX_LEV(readl(LPC32XX_HSUART_LEVEL(\n\t\t\t\t\t\t\tport->membase))) < 32)\n\t\t\tbreak;\n\t\tif (--timeout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void lpc32xx_hsuart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\twait_for_xmit_ready(port);\n\twritel((u32)ch, LPC32XX_HSUART_FIFO(port->membase));\n}\n\nstatic void lpc32xx_hsuart_console_write(struct console *co, const char *s,\n\t\t\t\t\t unsigned int count)\n{\n\tstruct lpc32xx_hsuart_port *up = &lpc32xx_hs_ports[co->index];\n\tunsigned long flags;\n\tint locked = 1;\n\n\ttouch_nmi_watchdog();\n\tlocal_irq_save(flags);\n\tif (up->port.sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock(&up->port.lock);\n\telse\n\t\tspin_lock(&up->port.lock);\n\n\tuart_console_write(&up->port, s, count, lpc32xx_hsuart_console_putchar);\n\twait_for_xmit_empty(&up->port);\n\n\tif (locked)\n\t\tspin_unlock(&up->port.lock);\n\tlocal_irq_restore(flags);\n}\n\nstatic int __init lpc32xx_hsuart_console_setup(struct console *co,\n\t\t\t\t\t       char *options)\n{\n\tstruct uart_port *port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index >= MAX_PORTS)\n\t\tco->index = 0;\n\n\tport = &lpc32xx_hs_ports[co->index].port;\n\tif (!port->membase)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\tlpc32xx_loopback_set(port->mapbase, 0);  \n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver lpc32xx_hsuart_reg;\nstatic struct console lpc32xx_hsuart_console = {\n\t.name\t\t= LPC32XX_TTY_NAME,\n\t.write\t\t= lpc32xx_hsuart_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= lpc32xx_hsuart_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &lpc32xx_hsuart_reg,\n};\n\nstatic int __init lpc32xx_hsuart_console_init(void)\n{\n\tregister_console(&lpc32xx_hsuart_console);\n\treturn 0;\n}\nconsole_initcall(lpc32xx_hsuart_console_init);\n\n#define LPC32XX_HSUART_CONSOLE (&lpc32xx_hsuart_console)\n#else\n#define LPC32XX_HSUART_CONSOLE NULL\n#endif\n\nstatic struct uart_driver lpc32xx_hs_reg = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= MODNAME,\n\t.dev_name\t= LPC32XX_TTY_NAME,\n\t.nr\t\t= MAX_PORTS,\n\t.cons\t\t= LPC32XX_HSUART_CONSOLE,\n};\nstatic int uarts_registered;\n\nstatic unsigned int __serial_get_clock_div(unsigned long uartclk,\n\t\t\t\t\t   unsigned long rate)\n{\n\tu32 div, goodrate, hsu_rate, l_hsu_rate, comprate;\n\tu32 rate_diff;\n\n\t \n\tdiv = uartclk / rate;\n\tgoodrate = hsu_rate = (div / 14) - 1;\n\tif (hsu_rate != 0)\n\t\thsu_rate--;\n\n\t \n\tl_hsu_rate = hsu_rate + 3;\n\trate_diff = 0xFFFFFFFF;\n\n\twhile (hsu_rate < l_hsu_rate) {\n\t\tcomprate = uartclk / ((hsu_rate + 1) * 14);\n\t\tif (abs(comprate - rate) < rate_diff) {\n\t\t\tgoodrate = hsu_rate;\n\t\t\trate_diff = abs(comprate - rate);\n\t\t}\n\n\t\thsu_rate++;\n\t}\n\tif (hsu_rate > 0xFF)\n\t\thsu_rate = 0xFF;\n\n\treturn goodrate;\n}\n\nstatic void __serial_uart_flush(struct uart_port *port)\n{\n\tint cnt = 0;\n\n\twhile ((readl(LPC32XX_HSUART_LEVEL(port->membase)) > 0) &&\n\t       (cnt++ < FIFO_READ_LIMIT))\n\t\treadl(LPC32XX_HSUART_FIFO(port->membase));\n}\n\nstatic void __serial_lpc32xx_rx(struct uart_port *port)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned int tmp, flag;\n\n\t \n\ttmp = readl(LPC32XX_HSUART_FIFO(port->membase));\n\twhile (!(tmp & LPC32XX_HSU_RX_EMPTY)) {\n\t\tflag = TTY_NORMAL;\n\t\tport->icount.rx++;\n\n\t\tif (tmp & LPC32XX_HSU_ERROR_DATA) {\n\t\t\t \n\t\t\twritel(LPC32XX_HSU_FE_INT,\n\t\t\t       LPC32XX_HSUART_IIR(port->membase));\n\t\t\tport->icount.frame++;\n\t\t\tflag = TTY_FRAME;\n\t\t\ttty_insert_flip_char(tport, 0, TTY_FRAME);\n\t\t}\n\n\t\ttty_insert_flip_char(tport, (tmp & 0xFF), flag);\n\n\t\ttmp = readl(LPC32XX_HSUART_FIFO(port->membase));\n\t}\n\n\ttty_flip_buffer_push(tport);\n}\n\nstatic bool serial_lpc32xx_tx_ready(struct uart_port *port)\n{\n\tu32 level = readl(LPC32XX_HSUART_LEVEL(port->membase));\n\n\treturn LPC32XX_HSU_TX_LEV(level) < 64;\n}\n\nstatic void __serial_lpc32xx_tx(struct uart_port *port)\n{\n\tu8 ch;\n\n\tuart_port_tx(port, ch,\n\t\tserial_lpc32xx_tx_ready(port),\n\t\twritel(ch, LPC32XX_HSUART_FIFO(port->membase)));\n}\n\nstatic irqreturn_t serial_lpc32xx_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tstruct tty_port *tport = &port->state->port;\n\tu32 status;\n\n\tspin_lock(&port->lock);\n\n\t \n\tstatus = readl(LPC32XX_HSUART_IIR(port->membase));\n\n\tif (status & LPC32XX_HSU_BRK_INT) {\n\t\t \n\t\twritel(LPC32XX_HSU_BRK_INT, LPC32XX_HSUART_IIR(port->membase));\n\t\tport->icount.brk++;\n\t\tuart_handle_break(port);\n\t}\n\n\t \n\tif (status & LPC32XX_HSU_FE_INT)\n\t\twritel(LPC32XX_HSU_FE_INT, LPC32XX_HSUART_IIR(port->membase));\n\n\tif (status & LPC32XX_HSU_RX_OE_INT) {\n\t\t \n\t\twritel(LPC32XX_HSU_RX_OE_INT,\n\t\t       LPC32XX_HSUART_IIR(port->membase));\n\t\tport->icount.overrun++;\n\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\t\ttty_flip_buffer_push(tport);\n\t}\n\n\t \n\tif (status & (LPC32XX_HSU_RX_TIMEOUT_INT | LPC32XX_HSU_RX_TRIG_INT))\n\t\t__serial_lpc32xx_rx(port);\n\n\t \n\tif ((status & LPC32XX_HSU_TX_INT) && (!uart_tx_stopped(port))) {\n\t\twritel(LPC32XX_HSU_TX_INT, LPC32XX_HSUART_IIR(port->membase));\n\t\t__serial_lpc32xx_tx(port);\n\t}\n\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic unsigned int serial_lpc32xx_tx_empty(struct uart_port *port)\n{\n\tunsigned int ret = 0;\n\n\tif (LPC32XX_HSU_TX_LEV(readl(LPC32XX_HSUART_LEVEL(port->membase))) == 0)\n\t\tret = TIOCSER_TEMT;\n\n\treturn ret;\n}\n\n \nstatic void serial_lpc32xx_set_mctrl(struct uart_port *port,\n\t\t\t\t     unsigned int mctrl)\n{\n\t \n}\n\n \nstatic unsigned int serial_lpc32xx_get_mctrl(struct uart_port *port)\n{\n\t \n\treturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n}\n\n \nstatic void serial_lpc32xx_stop_tx(struct uart_port *port)\n{\n\tu32 tmp;\n\n\ttmp = readl(LPC32XX_HSUART_CTRL(port->membase));\n\ttmp &= ~LPC32XX_HSU_TX_INT_EN;\n\twritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\n}\n\n \nstatic void serial_lpc32xx_start_tx(struct uart_port *port)\n{\n\tu32 tmp;\n\n\t__serial_lpc32xx_tx(port);\n\ttmp = readl(LPC32XX_HSUART_CTRL(port->membase));\n\ttmp |= LPC32XX_HSU_TX_INT_EN;\n\twritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\n}\n\n \nstatic void serial_lpc32xx_stop_rx(struct uart_port *port)\n{\n\tu32 tmp;\n\n\ttmp = readl(LPC32XX_HSUART_CTRL(port->membase));\n\ttmp &= ~(LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN);\n\twritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\n\n\twritel((LPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT |\n\t\tLPC32XX_HSU_FE_INT), LPC32XX_HSUART_IIR(port->membase));\n}\n\n \nstatic void serial_lpc32xx_break_ctl(struct uart_port *port,\n\t\t\t\t     int break_state)\n{\n\tunsigned long flags;\n\tu32 tmp;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\ttmp = readl(LPC32XX_HSUART_CTRL(port->membase));\n\tif (break_state != 0)\n\t\ttmp |= LPC32XX_HSU_BREAK;\n\telse\n\t\ttmp &= ~LPC32XX_HSU_BREAK;\n\twritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic int serial_lpc32xx_startup(struct uart_port *port)\n{\n\tint retval;\n\tunsigned long flags;\n\tu32 tmp;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t__serial_uart_flush(port);\n\n\twritel((LPC32XX_HSU_TX_INT | LPC32XX_HSU_FE_INT |\n\t\tLPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT),\n\t       LPC32XX_HSUART_IIR(port->membase));\n\n\twritel(0xFF, LPC32XX_HSUART_RATE(port->membase));\n\n\t \n\ttmp = LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |\n\t\tLPC32XX_HSU_OFFSET(20) | LPC32XX_HSU_TMO_INACT_4B;\n\twritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\n\n\tlpc32xx_loopback_set(port->mapbase, 0);  \n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tretval = request_irq(port->irq, serial_lpc32xx_interrupt,\n\t\t\t     0, MODNAME, port);\n\tif (!retval)\n\t\twritel((tmp | LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN),\n\t\t       LPC32XX_HSUART_CTRL(port->membase));\n\n\treturn retval;\n}\n\n \nstatic void serial_lpc32xx_shutdown(struct uart_port *port)\n{\n\tu32 tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\ttmp = LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |\n\t\tLPC32XX_HSU_OFFSET(20) | LPC32XX_HSU_TMO_INACT_4B;\n\twritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\n\n\tlpc32xx_loopback_set(port->mapbase, 1);  \n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tfree_irq(port->irq, port);\n}\n\n \nstatic void serial_lpc32xx_set_termios(struct uart_port *port,\n\t\t\t\t       struct ktermios *termios,\n\t\t\t\t       const struct ktermios *old)\n{\n\tunsigned long flags;\n\tunsigned int baud, quot;\n\tu32 tmp;\n\n\t \n\ttermios->c_cflag &= ~(CSIZE | CSTOPB | PARENB | PARODD);\n\ttermios->c_cflag |= CS8;\n\n\ttermios->c_cflag &= ~(HUPCL | CMSPAR | CLOCAL | CRTSCTS);\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0,\n\t\t\t\t  port->uartclk / 14);\n\n\tquot = __serial_get_clock_div(port->uartclk, baud);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\ttmp = readl(LPC32XX_HSUART_CTRL(port->membase));\n\tif ((termios->c_cflag & CREAD) == 0)\n\t\ttmp &= ~(LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN);\n\telse\n\t\ttmp |= LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN;\n\twritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\n\n\twritel(quot, LPC32XX_HSUART_RATE(port->membase));\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n}\n\nstatic const char *serial_lpc32xx_type(struct uart_port *port)\n{\n\treturn MODNAME;\n}\n\nstatic void serial_lpc32xx_release_port(struct uart_port *port)\n{\n\tif ((port->iotype == UPIO_MEM32) && (port->mapbase)) {\n\t\tif (port->flags & UPF_IOREMAP) {\n\t\t\tiounmap(port->membase);\n\t\t\tport->membase = NULL;\n\t\t}\n\n\t\trelease_mem_region(port->mapbase, SZ_4K);\n\t}\n}\n\nstatic int serial_lpc32xx_request_port(struct uart_port *port)\n{\n\tint ret = -ENODEV;\n\n\tif ((port->iotype == UPIO_MEM32) && (port->mapbase)) {\n\t\tret = 0;\n\n\t\tif (!request_mem_region(port->mapbase, SZ_4K, MODNAME))\n\t\t\tret = -EBUSY;\n\t\telse if (port->flags & UPF_IOREMAP) {\n\t\t\tport->membase = ioremap(port->mapbase, SZ_4K);\n\t\t\tif (!port->membase) {\n\t\t\t\trelease_mem_region(port->mapbase, SZ_4K);\n\t\t\t\tret = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void serial_lpc32xx_config_port(struct uart_port *port, int uflags)\n{\n\tint ret;\n\n\tret = serial_lpc32xx_request_port(port);\n\tif (ret < 0)\n\t\treturn;\n\tport->type = PORT_UART00;\n\tport->fifosize = 64;\n\n\t__serial_uart_flush(port);\n\n\twritel((LPC32XX_HSU_TX_INT | LPC32XX_HSU_FE_INT |\n\t\tLPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT),\n\t       LPC32XX_HSUART_IIR(port->membase));\n\n\twritel(0xFF, LPC32XX_HSUART_RATE(port->membase));\n\n\t \n\twritel(LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |\n\t       LPC32XX_HSU_OFFSET(20) | LPC32XX_HSU_TMO_INACT_4B,\n\t       LPC32XX_HSUART_CTRL(port->membase));\n}\n\nstatic int serial_lpc32xx_verify_port(struct uart_port *port,\n\t\t\t\t      struct serial_struct *ser)\n{\n\tint ret = 0;\n\n\tif (ser->type != PORT_UART00)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic const struct uart_ops serial_lpc32xx_pops = {\n\t.tx_empty\t= serial_lpc32xx_tx_empty,\n\t.set_mctrl\t= serial_lpc32xx_set_mctrl,\n\t.get_mctrl\t= serial_lpc32xx_get_mctrl,\n\t.stop_tx\t= serial_lpc32xx_stop_tx,\n\t.start_tx\t= serial_lpc32xx_start_tx,\n\t.stop_rx\t= serial_lpc32xx_stop_rx,\n\t.break_ctl\t= serial_lpc32xx_break_ctl,\n\t.startup\t= serial_lpc32xx_startup,\n\t.shutdown\t= serial_lpc32xx_shutdown,\n\t.set_termios\t= serial_lpc32xx_set_termios,\n\t.type\t\t= serial_lpc32xx_type,\n\t.release_port\t= serial_lpc32xx_release_port,\n\t.request_port\t= serial_lpc32xx_request_port,\n\t.config_port\t= serial_lpc32xx_config_port,\n\t.verify_port\t= serial_lpc32xx_verify_port,\n};\n\n \nstatic int serial_hs_lpc32xx_probe(struct platform_device *pdev)\n{\n\tstruct lpc32xx_hsuart_port *p = &lpc32xx_hs_ports[uarts_registered];\n\tint ret = 0;\n\tstruct resource *res;\n\n\tif (uarts_registered >= MAX_PORTS) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Error: Number of possible ports exceeded (%d)!\\n\",\n\t\t\tuarts_registered + 1);\n\t\treturn -ENXIO;\n\t}\n\n\tmemset(p, 0, sizeof(*p));\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Error getting mem resource for HS UART port %d\\n\",\n\t\t\tuarts_registered);\n\t\treturn -ENXIO;\n\t}\n\tp->port.mapbase = res->start;\n\tp->port.membase = NULL;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tp->port.irq = ret;\n\n\tp->port.iotype = UPIO_MEM32;\n\tp->port.uartclk = LPC32XX_MAIN_OSC_FREQ;\n\tp->port.regshift = 2;\n\tp->port.flags = UPF_BOOT_AUTOCONF | UPF_FIXED_PORT | UPF_IOREMAP;\n\tp->port.dev = &pdev->dev;\n\tp->port.ops = &serial_lpc32xx_pops;\n\tp->port.line = uarts_registered++;\n\tspin_lock_init(&p->port.lock);\n\n\t \n\tlpc32xx_loopback_set(p->port.mapbase, 1);\n\n\tret = uart_add_one_port(&lpc32xx_hs_reg, &p->port);\n\n\tplatform_set_drvdata(pdev, p);\n\n\treturn ret;\n}\n\n \nstatic int serial_hs_lpc32xx_remove(struct platform_device *pdev)\n{\n\tstruct lpc32xx_hsuart_port *p = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&lpc32xx_hs_reg, &p->port);\n\n\treturn 0;\n}\n\n\n#ifdef CONFIG_PM\nstatic int serial_hs_lpc32xx_suspend(struct platform_device *pdev,\n\t\t\t\t     pm_message_t state)\n{\n\tstruct lpc32xx_hsuart_port *p = platform_get_drvdata(pdev);\n\n\tuart_suspend_port(&lpc32xx_hs_reg, &p->port);\n\n\treturn 0;\n}\n\nstatic int serial_hs_lpc32xx_resume(struct platform_device *pdev)\n{\n\tstruct lpc32xx_hsuart_port *p = platform_get_drvdata(pdev);\n\n\tuart_resume_port(&lpc32xx_hs_reg, &p->port);\n\n\treturn 0;\n}\n#else\n#define serial_hs_lpc32xx_suspend\tNULL\n#define serial_hs_lpc32xx_resume\tNULL\n#endif\n\nstatic const struct of_device_id serial_hs_lpc32xx_dt_ids[] = {\n\t{ .compatible = \"nxp,lpc3220-hsuart\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, serial_hs_lpc32xx_dt_ids);\n\nstatic struct platform_driver serial_hs_lpc32xx_driver = {\n\t.probe\t\t= serial_hs_lpc32xx_probe,\n\t.remove\t\t= serial_hs_lpc32xx_remove,\n\t.suspend\t= serial_hs_lpc32xx_suspend,\n\t.resume\t\t= serial_hs_lpc32xx_resume,\n\t.driver\t\t= {\n\t\t.name\t= MODNAME,\n\t\t.of_match_table\t= serial_hs_lpc32xx_dt_ids,\n\t},\n};\n\nstatic int __init lpc32xx_hsuart_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&lpc32xx_hs_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&serial_hs_lpc32xx_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&lpc32xx_hs_reg);\n\n\treturn ret;\n}\n\nstatic void __exit lpc32xx_hsuart_exit(void)\n{\n\tplatform_driver_unregister(&serial_hs_lpc32xx_driver);\n\tuart_unregister_driver(&lpc32xx_hs_reg);\n}\n\nmodule_init(lpc32xx_hsuart_init);\nmodule_exit(lpc32xx_hsuart_exit);\n\nMODULE_AUTHOR(\"Kevin Wells <kevin.wells@nxp.com>\");\nMODULE_AUTHOR(\"Roland Stigge <stigge@antcom.de>\");\nMODULE_DESCRIPTION(\"NXP LPC32XX High Speed UART driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}