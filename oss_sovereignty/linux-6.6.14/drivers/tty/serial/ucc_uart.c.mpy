{
  "module_name": "ucc_uart.c",
  "hash_id": "aef5443dc55b74117c4760c3d325917fa6cd80c7621dac959608f8bad0eda903",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/ucc_uart.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/dma-mapping.h>\n\n#include <soc/fsl/qe/ucc_slow.h>\n\n#include <linux/firmware.h>\n#include <soc/fsl/cpm.h>\n\n#ifdef CONFIG_PPC32\n#include <asm/reg.h>  \n#endif\n\n \n#define UCC_SLOW_GUMR_H_SUART   \t0x00004000       \n\n \nstatic int soft_uart;\n \nstatic int firmware_loaded;\n\n \n \n\n \n#define SERIAL_QE_MAJOR 204\n#define SERIAL_QE_MINOR 46\n\n \n#define UCC_MAX_UART    4\n\n \n#define RX_NUM_FIFO     4\n\n \n#define TX_NUM_FIFO     4\n\n \n#define RX_BUF_SIZE     32\n\n \n#define TX_BUF_SIZE     32\n\n \n#define UCC_WAIT_CLOSING 100\n\nstruct ucc_uart_pram {\n\tstruct ucc_slow_pram common;\n\tu8 res1[8];     \t \n\t__be16 maxidl;  \t \n\t__be16 idlc;    \t \n\t__be16 brkcr;   \t \n\t__be16 parec;   \t \n\t__be16 frmec;   \t \n\t__be16 nosec;   \t \n\t__be16 brkec;   \t \n\t__be16 brkln;   \t \n\t__be16 uaddr[2];\t \n\t__be16 rtemp;   \t \n\t__be16 toseq;   \t \n\t__be16 cchars[8];        \n\t__be16 rccm;    \t \n\t__be16 rccr;    \t \n\t__be16 rlbc;    \t \n\t__be16 res2;    \t \n\t__be32 res3;    \t \n\tu8 res4;\t\t \n\tu8 res5[3];     \t \n\t__be32 res6;    \t \n\t__be32 res7;    \t \n\t__be32 res8;    \t \n\t__be32 res9;    \t \n\t__be32 res10;   \t \n\t__be32 res11;   \t \n\t__be32 res12;   \t \n\t__be32 res13;   \t \n \n\t__be16 supsmr;  \t \n\t__be16 res92;   \t \n\t__be32 rx_state;\t \n\t__be32 rx_cnt;  \t \n\tu8 rx_length;   \t \n\tu8 rx_bitmark;  \t \n\tu8 rx_temp_dlst_qe;      \n\tu8 res14[0xBC - 0x9F];   \n\t__be32 dump_ptr;\t \n\t__be32 rx_frame_rem;     \n\tu8 rx_frame_rem_size;    \n\tu8 tx_mode;     \t \n\t__be16 tx_state;\t \n\tu8 res15[0xD0 - 0xC8];   \n\t__be32 resD0;   \t \n\tu8 resD4;       \t \n\t__be16 resD5;   \t \n} __attribute__ ((packed));\n\n \n#define UCC_UART_SUPSMR_SL      \t0x8000\n#define UCC_UART_SUPSMR_RPM_MASK\t0x6000\n#define UCC_UART_SUPSMR_RPM_ODD \t0x0000\n#define UCC_UART_SUPSMR_RPM_LOW \t0x2000\n#define UCC_UART_SUPSMR_RPM_EVEN\t0x4000\n#define UCC_UART_SUPSMR_RPM_HIGH\t0x6000\n#define UCC_UART_SUPSMR_PEN     \t0x1000\n#define UCC_UART_SUPSMR_TPM_MASK\t0x0C00\n#define UCC_UART_SUPSMR_TPM_ODD \t0x0000\n#define UCC_UART_SUPSMR_TPM_LOW \t0x0400\n#define UCC_UART_SUPSMR_TPM_EVEN\t0x0800\n#define UCC_UART_SUPSMR_TPM_HIGH\t0x0C00\n#define UCC_UART_SUPSMR_FRZ     \t0x0100\n#define UCC_UART_SUPSMR_UM_MASK \t0x00c0\n#define UCC_UART_SUPSMR_UM_NORMAL       0x0000\n#define UCC_UART_SUPSMR_UM_MAN_MULTI    0x0040\n#define UCC_UART_SUPSMR_UM_AUTO_MULTI   0x00c0\n#define UCC_UART_SUPSMR_CL_MASK \t0x0030\n#define UCC_UART_SUPSMR_CL_8    \t0x0030\n#define UCC_UART_SUPSMR_CL_7    \t0x0020\n#define UCC_UART_SUPSMR_CL_6    \t0x0010\n#define UCC_UART_SUPSMR_CL_5    \t0x0000\n\n#define UCC_UART_TX_STATE_AHDLC \t0x00\n#define UCC_UART_TX_STATE_UART  \t0x01\n#define UCC_UART_TX_STATE_X1    \t0x00\n#define UCC_UART_TX_STATE_X16   \t0x80\n\n#define UCC_UART_PRAM_ALIGNMENT 0x100\n\n#define UCC_UART_SIZE_OF_BD     UCC_SLOW_SIZE_OF_BD\n#define NUM_CONTROL_CHARS       8\n\n \nstruct uart_qe_port {\n\tstruct uart_port port;\n\tstruct ucc_slow __iomem *uccp;\n\tstruct ucc_uart_pram __iomem *uccup;\n\tstruct ucc_slow_info us_info;\n\tstruct ucc_slow_private *us_private;\n\tstruct device_node *np;\n\tunsigned int ucc_num;    \n\n\tu16 rx_nrfifos;\n\tu16 rx_fifosize;\n\tu16 tx_nrfifos;\n\tu16 tx_fifosize;\n\tint wait_closing;\n\tu32 flags;\n\tstruct qe_bd *rx_bd_base;\n\tstruct qe_bd *rx_cur;\n\tstruct qe_bd *tx_bd_base;\n\tstruct qe_bd *tx_cur;\n\tunsigned char *tx_buf;\n\tunsigned char *rx_buf;\n\tvoid *bd_virt;  \t \n\tdma_addr_t bd_dma_addr;  \n\tunsigned int bd_size;    \n};\n\nstatic struct uart_driver ucc_uart_driver = {\n\t.owner  \t= THIS_MODULE,\n\t.driver_name    = \"ucc_uart\",\n\t.dev_name       = \"ttyQE\",\n\t.major  \t= SERIAL_QE_MAJOR,\n\t.minor  \t= SERIAL_QE_MINOR,\n\t.nr     \t= UCC_MAX_UART,\n};\n\n \nstatic inline dma_addr_t cpu2qe_addr(void *addr, struct uart_qe_port *qe_port)\n{\n\tif (likely((addr >= qe_port->bd_virt)) &&\n\t    (addr < (qe_port->bd_virt + qe_port->bd_size)))\n\t\treturn qe_port->bd_dma_addr + (addr - qe_port->bd_virt);\n\n\t \n\tprintk(KERN_ERR \"%s: addr=%p\\n\", __func__, addr);\n\tBUG();\n\treturn 0;\n}\n\n \nstatic inline void *qe2cpu_addr(dma_addr_t addr, struct uart_qe_port *qe_port)\n{\n\t \n\tif (likely((addr >= qe_port->bd_dma_addr) &&\n\t\t   (addr < (qe_port->bd_dma_addr + qe_port->bd_size))))\n\t\treturn qe_port->bd_virt + (addr - qe_port->bd_dma_addr);\n\n\t \n\tprintk(KERN_ERR \"%s: addr=%llx\\n\", __func__, (u64)addr);\n\tBUG();\n\treturn NULL;\n}\n\n \nstatic unsigned int qe_uart_tx_empty(struct uart_port *port)\n{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tstruct qe_bd *bdp = qe_port->tx_bd_base;\n\n\twhile (1) {\n\t\tif (ioread16be(&bdp->status) & BD_SC_READY)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tif (ioread16be(&bdp->status) & BD_SC_WRAP)\n\t\t\t \n\t\t\treturn 1;\n\n\t\tbdp++;\n\t}\n}\n\n \nstatic void qe_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n}\n\n \nstatic unsigned int qe_uart_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n}\n\n \nstatic void qe_uart_stop_tx(struct uart_port *port)\n{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\n\tqe_clrbits_be16(&qe_port->uccp->uccm, UCC_UART_UCCE_TX);\n}\n\n \nstatic int qe_uart_tx_pump(struct uart_qe_port *qe_port)\n{\n\tstruct qe_bd *bdp;\n\tunsigned char *p;\n\tunsigned int count;\n\tstruct uart_port *port = &qe_port->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\t \n\tif (port->x_char) {\n\t\t \n\t\tbdp = qe_port->tx_cur;\n\n\t\tp = qe2cpu_addr(be32_to_cpu(bdp->buf), qe_port);\n\n\t\t*p++ = port->x_char;\n\t\tiowrite16be(1, &bdp->length);\n\t\tqe_setbits_be16(&bdp->status, BD_SC_READY);\n\t\t \n\t\tif (ioread16be(&bdp->status) & BD_SC_WRAP)\n\t\t\tbdp = qe_port->tx_bd_base;\n\t\telse\n\t\t\tbdp++;\n\t\tqe_port->tx_cur = bdp;\n\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn 1;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\tqe_uart_stop_tx(port);\n\t\treturn 0;\n\t}\n\n\t \n\tbdp = qe_port->tx_cur;\n\n\twhile (!(ioread16be(&bdp->status) & BD_SC_READY) && !uart_circ_empty(xmit)) {\n\t\tcount = 0;\n\t\tp = qe2cpu_addr(be32_to_cpu(bdp->buf), qe_port);\n\t\twhile (count < qe_port->tx_fifosize) {\n\t\t\t*p++ = xmit->buf[xmit->tail];\n\t\t\tuart_xmit_advance(port, 1);\n\t\t\tcount++;\n\t\t\tif (uart_circ_empty(xmit))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tiowrite16be(count, &bdp->length);\n\t\tqe_setbits_be16(&bdp->status, BD_SC_READY);\n\n\t\t \n\t\tif (ioread16be(&bdp->status) & BD_SC_WRAP)\n\t\t\tbdp = qe_port->tx_bd_base;\n\t\telse\n\t\t\tbdp++;\n\t}\n\tqe_port->tx_cur = bdp;\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (uart_circ_empty(xmit)) {\n\t\t \n\t\tqe_uart_stop_tx(port);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic void qe_uart_start_tx(struct uart_port *port)\n{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\n\t \n\tif (ioread16be(&qe_port->uccp->uccm) & UCC_UART_UCCE_TX)\n\t\treturn;\n\n\t \n\tif (qe_uart_tx_pump(qe_port))\n\t\tqe_setbits_be16(&qe_port->uccp->uccm, UCC_UART_UCCE_TX);\n}\n\n \nstatic void qe_uart_stop_rx(struct uart_port *port)\n{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\n\tqe_clrbits_be16(&qe_port->uccp->uccm, UCC_UART_UCCE_RX);\n}\n\n \nstatic void qe_uart_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\n\tif (break_state)\n\t\tucc_slow_stop_tx(qe_port->us_private);\n\telse\n\t\tucc_slow_restart_tx(qe_port->us_private);\n}\n\n \nstatic void qe_uart_int_rx(struct uart_qe_port *qe_port)\n{\n\tint i;\n\tunsigned char ch, *cp;\n\tstruct uart_port *port = &qe_port->port;\n\tstruct tty_port *tport = &port->state->port;\n\tstruct qe_bd *bdp;\n\tu16 status;\n\tunsigned int flg;\n\n\t \n\tbdp = qe_port->rx_cur;\n\twhile (1) {\n\t\tstatus = ioread16be(&bdp->status);\n\n\t\t \n\t\tif (status & BD_SC_EMPTY)\n\t\t\tbreak;\n\n\t\t \n\t\ti = ioread16be(&bdp->length);\n\n\t\t \n\t\tif (tty_buffer_request_room(tport, i) < i) {\n\t\t\tdev_dbg(port->dev, \"ucc-uart: no room in RX buffer\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tcp = qe2cpu_addr(be32_to_cpu(bdp->buf), qe_port);\n\n\t\t \n\t\twhile (i-- > 0) {\n\t\t\tch = *cp++;\n\t\t\tport->icount.rx++;\n\t\t\tflg = TTY_NORMAL;\n\n\t\t\tif (!i && status &\n\t\t\t    (BD_SC_BR | BD_SC_FR | BD_SC_PR | BD_SC_OV))\n\t\t\t\tgoto handle_error;\n\t\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\t\tcontinue;\n\nerror_return:\n\t\t\ttty_insert_flip_char(tport, ch, flg);\n\n\t\t}\n\n\t\t \n\t\tqe_clrsetbits_be16(&bdp->status,\n\t\t\t\t   BD_SC_BR | BD_SC_FR | BD_SC_PR | BD_SC_OV | BD_SC_ID,\n\t\t\t\t   BD_SC_EMPTY);\n\t\tif (ioread16be(&bdp->status) & BD_SC_WRAP)\n\t\t\tbdp = qe_port->rx_bd_base;\n\t\telse\n\t\t\tbdp++;\n\n\t}\n\n\t \n\tqe_port->rx_cur = bdp;\n\n\t \n\ttty_flip_buffer_push(tport);\n\n\treturn;\n\n\t \n\nhandle_error:\n\t \n\tif (status & BD_SC_BR)\n\t\tport->icount.brk++;\n\tif (status & BD_SC_PR)\n\t\tport->icount.parity++;\n\tif (status & BD_SC_FR)\n\t\tport->icount.frame++;\n\tif (status & BD_SC_OV)\n\t\tport->icount.overrun++;\n\n\t \n\tstatus &= port->read_status_mask;\n\n\t \n\tif (status & BD_SC_BR)\n\t\tflg = TTY_BREAK;\n\telse if (status & BD_SC_PR)\n\t\tflg = TTY_PARITY;\n\telse if (status & BD_SC_FR)\n\t\tflg = TTY_FRAME;\n\n\t \n\tif (status & BD_SC_OV)\n\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\tport->sysrq = 0;\n\tgoto error_return;\n}\n\n \nstatic irqreturn_t qe_uart_int(int irq, void *data)\n{\n\tstruct uart_qe_port *qe_port = (struct uart_qe_port *) data;\n\tstruct ucc_slow __iomem *uccp = qe_port->uccp;\n\tu16 events;\n\n\t \n\tevents = ioread16be(&uccp->ucce);\n\tiowrite16be(events, &uccp->ucce);\n\n\tif (events & UCC_UART_UCCE_BRKE)\n\t\tuart_handle_break(&qe_port->port);\n\n\tif (events & UCC_UART_UCCE_RX)\n\t\tqe_uart_int_rx(qe_port);\n\n\tif (events & UCC_UART_UCCE_TX)\n\t\tqe_uart_tx_pump(qe_port);\n\n\treturn events ? IRQ_HANDLED : IRQ_NONE;\n}\n\n \nstatic void qe_uart_initbd(struct uart_qe_port *qe_port)\n{\n\tint i;\n\tvoid *bd_virt;\n\tstruct qe_bd *bdp;\n\n\t \n\tbd_virt = qe_port->bd_virt;\n\tbdp = qe_port->rx_bd_base;\n\tqe_port->rx_cur = qe_port->rx_bd_base;\n\tfor (i = 0; i < (qe_port->rx_nrfifos - 1); i++) {\n\t\tiowrite16be(BD_SC_EMPTY | BD_SC_INTRPT, &bdp->status);\n\t\tiowrite32be(cpu2qe_addr(bd_virt, qe_port), &bdp->buf);\n\t\tiowrite16be(0, &bdp->length);\n\t\tbd_virt += qe_port->rx_fifosize;\n\t\tbdp++;\n\t}\n\n\t \n\tiowrite16be(BD_SC_WRAP | BD_SC_EMPTY | BD_SC_INTRPT, &bdp->status);\n\tiowrite32be(cpu2qe_addr(bd_virt, qe_port), &bdp->buf);\n\tiowrite16be(0, &bdp->length);\n\n\t \n\tbd_virt = qe_port->bd_virt +\n\t\tL1_CACHE_ALIGN(qe_port->rx_nrfifos * qe_port->rx_fifosize);\n\tqe_port->tx_cur = qe_port->tx_bd_base;\n\tbdp = qe_port->tx_bd_base;\n\tfor (i = 0; i < (qe_port->tx_nrfifos - 1); i++) {\n\t\tiowrite16be(BD_SC_INTRPT, &bdp->status);\n\t\tiowrite32be(cpu2qe_addr(bd_virt, qe_port), &bdp->buf);\n\t\tiowrite16be(0, &bdp->length);\n\t\tbd_virt += qe_port->tx_fifosize;\n\t\tbdp++;\n\t}\n\n\t \n#ifdef LOOPBACK\n\tqe_setbits_be16(&qe_port->tx_cur->status, BD_SC_P);\n#endif\n\n\tiowrite16be(BD_SC_WRAP | BD_SC_INTRPT, &bdp->status);\n\tiowrite32be(cpu2qe_addr(bd_virt, qe_port), &bdp->buf);\n\tiowrite16be(0, &bdp->length);\n}\n\n \nstatic void qe_uart_init_ucc(struct uart_qe_port *qe_port)\n{\n\tu32 cecr_subblock;\n\tstruct ucc_slow __iomem *uccp = qe_port->uccp;\n\tstruct ucc_uart_pram *uccup = qe_port->uccup;\n\n\tunsigned int i;\n\n\t \n\tucc_slow_disable(qe_port->us_private, COMM_DIR_RX_AND_TX);\n\n\t \n\tiowrite8(UCC_BMR_GBL | UCC_BMR_BO_BE, &uccup->common.rbmr);\n\tiowrite8(UCC_BMR_GBL | UCC_BMR_BO_BE, &uccup->common.tbmr);\n\tiowrite16be(qe_port->rx_fifosize, &uccup->common.mrblr);\n\tiowrite16be(0x10, &uccup->maxidl);\n\tiowrite16be(1, &uccup->brkcr);\n\tiowrite16be(0, &uccup->parec);\n\tiowrite16be(0, &uccup->frmec);\n\tiowrite16be(0, &uccup->nosec);\n\tiowrite16be(0, &uccup->brkec);\n\tiowrite16be(0, &uccup->uaddr[0]);\n\tiowrite16be(0, &uccup->uaddr[1]);\n\tiowrite16be(0, &uccup->toseq);\n\tfor (i = 0; i < 8; i++)\n\t\tiowrite16be(0xC000, &uccup->cchars[i]);\n\tiowrite16be(0xc0ff, &uccup->rccm);\n\n\t \n\tif (soft_uart) {\n\t\t \n\t\tqe_clrsetbits_be32(&uccp->gumr_l,\n\t\t\t\t   UCC_SLOW_GUMR_L_MODE_MASK | UCC_SLOW_GUMR_L_TDCR_MASK | UCC_SLOW_GUMR_L_RDCR_MASK,\n\t\t\t\t   UCC_SLOW_GUMR_L_MODE_UART | UCC_SLOW_GUMR_L_TDCR_1 | UCC_SLOW_GUMR_L_RDCR_16);\n\n\t\tqe_clrsetbits_be32(&uccp->gumr_h, UCC_SLOW_GUMR_H_RFW,\n\t\t\t\t   UCC_SLOW_GUMR_H_TRX | UCC_SLOW_GUMR_H_TTX);\n\t} else {\n\t\tqe_clrsetbits_be32(&uccp->gumr_l,\n\t\t\t\t   UCC_SLOW_GUMR_L_MODE_MASK | UCC_SLOW_GUMR_L_TDCR_MASK | UCC_SLOW_GUMR_L_RDCR_MASK,\n\t\t\t\t   UCC_SLOW_GUMR_L_MODE_UART | UCC_SLOW_GUMR_L_TDCR_16 | UCC_SLOW_GUMR_L_RDCR_16);\n\n\t\tqe_clrsetbits_be32(&uccp->gumr_h,\n\t\t\t\t   UCC_SLOW_GUMR_H_TRX | UCC_SLOW_GUMR_H_TTX,\n\t\t\t\t   UCC_SLOW_GUMR_H_RFW);\n\t}\n\n#ifdef LOOPBACK\n\tqe_clrsetbits_be32(&uccp->gumr_l, UCC_SLOW_GUMR_L_DIAG_MASK,\n\t\t\t   UCC_SLOW_GUMR_L_DIAG_LOOP);\n\tqe_clrsetbits_be32(&uccp->gumr_h,\n\t\t\t   UCC_SLOW_GUMR_H_CTSP | UCC_SLOW_GUMR_H_RSYN,\n\t\t\t   UCC_SLOW_GUMR_H_CDS);\n#endif\n\n\t \n\tiowrite16be(0, &uccp->uccm);\n\tiowrite16be(0xffff, &uccp->ucce);\n\tiowrite16be(0x7e7e, &uccp->udsr);\n\n\t \n\tiowrite16be(0, &uccp->upsmr);\n\n\tif (soft_uart) {\n\t\tiowrite16be(0x30, &uccup->supsmr);\n\t\tiowrite16be(0, &uccup->res92);\n\t\tiowrite32be(0, &uccup->rx_state);\n\t\tiowrite32be(0, &uccup->rx_cnt);\n\t\tiowrite8(0, &uccup->rx_bitmark);\n\t\tiowrite8(10, &uccup->rx_length);\n\t\tiowrite32be(0x4000, &uccup->dump_ptr);\n\t\tiowrite8(0, &uccup->rx_temp_dlst_qe);\n\t\tiowrite32be(0, &uccup->rx_frame_rem);\n\t\tiowrite8(0, &uccup->rx_frame_rem_size);\n\t\t \n\t\tiowrite8(UCC_UART_TX_STATE_UART | UCC_UART_TX_STATE_X1,\n\t\t\t    &uccup->tx_mode);\n\t\tiowrite16be(0, &uccup->tx_state);\n\t\tiowrite8(0, &uccup->resD4);\n\t\tiowrite16be(0, &uccup->resD5);\n\n\t\t \n\n\t\t \n\t\tqe_clrsetbits_be32(&uccp->gumr_l,\n\t\t\t\t   UCC_SLOW_GUMR_L_MODE_MASK | UCC_SLOW_GUMR_L_TDCR_MASK | UCC_SLOW_GUMR_L_RDCR_MASK,\n\t\t\t\t   UCC_SLOW_GUMR_L_MODE_QMC | UCC_SLOW_GUMR_L_TDCR_16 | UCC_SLOW_GUMR_L_RDCR_16);\n\n\t\tqe_clrsetbits_be32(&uccp->gumr_h,\n\t\t\t\t   UCC_SLOW_GUMR_H_RFW | UCC_SLOW_GUMR_H_RSYN,\n\t\t\t\t   UCC_SLOW_GUMR_H_SUART | UCC_SLOW_GUMR_H_TRX | UCC_SLOW_GUMR_H_TTX | UCC_SLOW_GUMR_H_TFL);\n\n#ifdef LOOPBACK\n\t\tqe_clrsetbits_be32(&uccp->gumr_l, UCC_SLOW_GUMR_L_DIAG_MASK,\n\t\t\t\t   UCC_SLOW_GUMR_L_DIAG_LOOP);\n\t\tqe_clrbits_be32(&uccp->gumr_h,\n\t\t\t\tUCC_SLOW_GUMR_H_CTSP | UCC_SLOW_GUMR_H_CDS);\n#endif\n\n\t\tcecr_subblock = ucc_slow_get_qe_cr_subblock(qe_port->ucc_num);\n\t\tqe_issue_cmd(QE_INIT_TX_RX, cecr_subblock,\n\t\t\tQE_CR_PROTOCOL_UNSPECIFIED, 0);\n\t} else {\n\t\tcecr_subblock = ucc_slow_get_qe_cr_subblock(qe_port->ucc_num);\n\t\tqe_issue_cmd(QE_INIT_TX_RX, cecr_subblock,\n\t\t\tQE_CR_PROTOCOL_UART, 0);\n\t}\n}\n\n \nstatic int qe_uart_startup(struct uart_port *port)\n{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tint ret;\n\n\t \n\tif (soft_uart && !firmware_loaded) {\n\t\tdev_err(port->dev, \"Soft-UART firmware not uploaded\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tqe_uart_initbd(qe_port);\n\tqe_uart_init_ucc(qe_port);\n\n\t \n\tret = request_irq(port->irq, qe_uart_int, IRQF_SHARED, \"ucc-uart\",\n\t\tqe_port);\n\tif (ret) {\n\t\tdev_err(port->dev, \"could not claim IRQ %u\\n\", port->irq);\n\t\treturn ret;\n\t}\n\n\t \n\tqe_setbits_be16(&qe_port->uccp->uccm, UCC_UART_UCCE_RX);\n\tucc_slow_enable(qe_port->us_private, COMM_DIR_RX_AND_TX);\n\n\treturn 0;\n}\n\n \nstatic void qe_uart_shutdown(struct uart_port *port)\n{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tstruct ucc_slow __iomem *uccp = qe_port->uccp;\n\tunsigned int timeout = 20;\n\n\t \n\n\t \n\twhile (!qe_uart_tx_empty(port)) {\n\t\tif (!--timeout) {\n\t\t\tdev_warn(port->dev, \"shutdown timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(2);\n\t}\n\n\tif (qe_port->wait_closing) {\n\t\t \n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(qe_port->wait_closing);\n\t}\n\n\t \n\tucc_slow_disable(qe_port->us_private, COMM_DIR_RX_AND_TX);\n\tqe_clrbits_be16(&uccp->uccm, UCC_UART_UCCE_TX | UCC_UART_UCCE_RX);\n\n\t \n\tucc_slow_graceful_stop_tx(qe_port->us_private);\n\tqe_uart_initbd(qe_port);\n\n\tfree_irq(port->irq, qe_port);\n}\n\n \nstatic void qe_uart_set_termios(struct uart_port *port,\n\t\t\t\tstruct ktermios *termios,\n\t\t\t\tconst struct ktermios *old)\n{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tstruct ucc_slow __iomem *uccp = qe_port->uccp;\n\tunsigned int baud;\n\tunsigned long flags;\n\tu16 upsmr = ioread16be(&uccp->upsmr);\n\tstruct ucc_uart_pram __iomem *uccup = qe_port->uccup;\n\tu16 supsmr = ioread16be(&uccup->supsmr);\n\n\t \n\tupsmr &= UCC_UART_UPSMR_CL_MASK;\n\tsupsmr &= UCC_UART_SUPSMR_CL_MASK;\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tupsmr |= UCC_UART_UPSMR_CL_5;\n\t\tsupsmr |= UCC_UART_SUPSMR_CL_5;\n\t\tbreak;\n\tcase CS6:\n\t\tupsmr |= UCC_UART_UPSMR_CL_6;\n\t\tsupsmr |= UCC_UART_SUPSMR_CL_6;\n\t\tbreak;\n\tcase CS7:\n\t\tupsmr |= UCC_UART_UPSMR_CL_7;\n\t\tsupsmr |= UCC_UART_SUPSMR_CL_7;\n\t\tbreak;\n\tdefault:\t \n\t\tupsmr |= UCC_UART_UPSMR_CL_8;\n\t\tsupsmr |= UCC_UART_SUPSMR_CL_8;\n\t\tbreak;\n\t}\n\n\t \n\tif (termios->c_cflag & CSTOPB) {\n\t\tupsmr |= UCC_UART_UPSMR_SL;\n\t\tsupsmr |= UCC_UART_SUPSMR_SL;\n\t}\n\n\tif (termios->c_cflag & PARENB) {\n\t\tupsmr |= UCC_UART_UPSMR_PEN;\n\t\tsupsmr |= UCC_UART_SUPSMR_PEN;\n\n\t\tif (!(termios->c_cflag & PARODD)) {\n\t\t\tupsmr &= ~(UCC_UART_UPSMR_RPM_MASK |\n\t\t\t\t   UCC_UART_UPSMR_TPM_MASK);\n\t\t\tupsmr |= UCC_UART_UPSMR_RPM_EVEN |\n\t\t\t\tUCC_UART_UPSMR_TPM_EVEN;\n\t\t\tsupsmr &= ~(UCC_UART_SUPSMR_RPM_MASK |\n\t\t\t\t    UCC_UART_SUPSMR_TPM_MASK);\n\t\t\tsupsmr |= UCC_UART_SUPSMR_RPM_EVEN |\n\t\t\t\tUCC_UART_SUPSMR_TPM_EVEN;\n\t\t}\n\t}\n\n\t \n\tport->read_status_mask = BD_SC_EMPTY | BD_SC_OV;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= BD_SC_FR | BD_SC_PR;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tport->read_status_mask |= BD_SC_BR;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= BD_SC_PR | BD_SC_FR;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= BD_SC_BR;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= BD_SC_OV;\n\t}\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->read_status_mask &= ~BD_SC_EMPTY;\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tiowrite16be(upsmr, &uccp->upsmr);\n\tif (soft_uart) {\n\t\tiowrite16be(supsmr, &uccup->supsmr);\n\t\tiowrite8(tty_get_frame_size(termios->c_cflag), &uccup->rx_length);\n\n\t\t \n\t\tqe_setbrg(qe_port->us_info.rx_clock, baud, 16);\n\t\tqe_setbrg(qe_port->us_info.tx_clock, baud, 1);\n\t} else {\n\t\tqe_setbrg(qe_port->us_info.rx_clock, baud, 16);\n\t\tqe_setbrg(qe_port->us_info.tx_clock, baud, 16);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic const char *qe_uart_type(struct uart_port *port)\n{\n\treturn \"QE\";\n}\n\n \nstatic int qe_uart_request_port(struct uart_port *port)\n{\n\tint ret;\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tstruct ucc_slow_info *us_info = &qe_port->us_info;\n\tstruct ucc_slow_private *uccs;\n\tunsigned int rx_size, tx_size;\n\tvoid *bd_virt;\n\tdma_addr_t bd_dma_addr = 0;\n\n\tret = ucc_slow_init(us_info, &uccs);\n\tif (ret) {\n\t\tdev_err(port->dev, \"could not initialize UCC%u\\n\",\n\t\t       qe_port->ucc_num);\n\t\treturn ret;\n\t}\n\n\tqe_port->us_private = uccs;\n\tqe_port->uccp = uccs->us_regs;\n\tqe_port->uccup = (struct ucc_uart_pram *) uccs->us_pram;\n\tqe_port->rx_bd_base = uccs->rx_bd;\n\tqe_port->tx_bd_base = uccs->tx_bd;\n\n\t \n\n\trx_size = L1_CACHE_ALIGN(qe_port->rx_nrfifos * qe_port->rx_fifosize);\n\ttx_size = L1_CACHE_ALIGN(qe_port->tx_nrfifos * qe_port->tx_fifosize);\n\n\tbd_virt = dma_alloc_coherent(port->dev, rx_size + tx_size, &bd_dma_addr,\n\t\tGFP_KERNEL);\n\tif (!bd_virt) {\n\t\tdev_err(port->dev, \"could not allocate buffer descriptors\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tqe_port->bd_virt = bd_virt;\n\tqe_port->bd_dma_addr = bd_dma_addr;\n\tqe_port->bd_size = rx_size + tx_size;\n\n\tqe_port->rx_buf = bd_virt;\n\tqe_port->tx_buf = qe_port->rx_buf + rx_size;\n\n\treturn 0;\n}\n\n \nstatic void qe_uart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_CPM;\n\t\tqe_uart_request_port(port);\n\t}\n}\n\n \nstatic void qe_uart_release_port(struct uart_port *port)\n{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tstruct ucc_slow_private *uccs = qe_port->us_private;\n\n\tdma_free_coherent(port->dev, qe_port->bd_size, qe_port->bd_virt,\n\t\t\t  qe_port->bd_dma_addr);\n\n\tucc_slow_free(uccs);\n}\n\n \nstatic int qe_uart_verify_port(struct uart_port *port,\n\t\t\t       struct serial_struct *ser)\n{\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_CPM)\n\t\treturn -EINVAL;\n\n\tif (ser->irq < 0 || ser->irq >= nr_irqs)\n\t\treturn -EINVAL;\n\n\tif (ser->baud_base < 9600)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n \nstatic const struct uart_ops qe_uart_pops = {\n\t.tx_empty       = qe_uart_tx_empty,\n\t.set_mctrl      = qe_uart_set_mctrl,\n\t.get_mctrl      = qe_uart_get_mctrl,\n\t.stop_tx\t= qe_uart_stop_tx,\n\t.start_tx       = qe_uart_start_tx,\n\t.stop_rx\t= qe_uart_stop_rx,\n\t.break_ctl      = qe_uart_break_ctl,\n\t.startup\t= qe_uart_startup,\n\t.shutdown       = qe_uart_shutdown,\n\t.set_termios    = qe_uart_set_termios,\n\t.type   \t= qe_uart_type,\n\t.release_port   = qe_uart_release_port,\n\t.request_port   = qe_uart_request_port,\n\t.config_port    = qe_uart_config_port,\n\t.verify_port    = qe_uart_verify_port,\n};\n\n\n#ifdef CONFIG_PPC32\n \nstatic unsigned int soc_info(unsigned int *rev_h, unsigned int *rev_l)\n{\n\tstruct device_node *np;\n\tconst char *soc_string;\n\tunsigned int svr;\n\tunsigned int soc;\n\n\t \n\tnp = of_find_node_by_type(NULL, \"cpu\");\n\tif (!np)\n\t\treturn 0;\n\t \n\tsoc_string = of_get_property(np, \"compatible\", NULL);\n\tif (!soc_string)\n\t\t \n\t\tsoc_string = np->name;\n\n\tof_node_put(np);\n\n\t \n\tif ((sscanf(soc_string, \"PowerPC,%u\", &soc) != 1) || !soc)\n\t\treturn 0;\n\n\t \n\tsvr = mfspr(SPRN_SVR);\n\t*rev_h = (svr >> 4) & 0xf;\n\t*rev_l = svr & 0xf;\n\n\treturn soc;\n}\n\n \nstatic void uart_firmware_cont(const struct firmware *fw, void *context)\n{\n\tstruct qe_firmware *firmware;\n\tstruct device *dev = context;\n\tint ret;\n\n\tif (!fw) {\n\t\tdev_err(dev, \"firmware not found\\n\");\n\t\treturn;\n\t}\n\n\tfirmware = (struct qe_firmware *) fw->data;\n\n\tif (firmware->header.length != fw->size) {\n\t\tdev_err(dev, \"invalid firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tret = qe_upload_firmware(firmware);\n\tif (ret) {\n\t\tdev_err(dev, \"could not load firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tfirmware_loaded = 1;\n out:\n\trelease_firmware(fw);\n}\n\nstatic int soft_uart_init(struct platform_device *ofdev)\n{\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct qe_firmware_info *qe_fw_info;\n\tint ret;\n\n\tif (of_property_read_bool(np, \"soft-uart\")) {\n\t\tdev_dbg(&ofdev->dev, \"using Soft-UART mode\\n\");\n\t\tsoft_uart = 1;\n\t} else {\n\t\treturn 0;\n\t}\n\n\tqe_fw_info = qe_get_firmware_info();\n\n\t \n\tif (qe_fw_info && strstr(qe_fw_info->id, \"Soft-UART\")) {\n\t\tfirmware_loaded = 1;\n\t} else {\n\t\tchar filename[32];\n\t\tunsigned int soc;\n\t\tunsigned int rev_h;\n\t\tunsigned int rev_l;\n\n\t\tsoc = soc_info(&rev_h, &rev_l);\n\t\tif (!soc) {\n\t\t\tdev_err(&ofdev->dev, \"unknown CPU model\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tsprintf(filename, \"fsl_qe_ucode_uart_%u_%u%u.bin\",\n\t\t\tsoc, rev_h, rev_l);\n\n\t\tdev_info(&ofdev->dev, \"waiting for firmware %s\\n\",\n\t\t\t filename);\n\n\t\t \n\t\tret = request_firmware_nowait(THIS_MODULE,\n\t\t\t\t\t      FW_ACTION_UEVENT, filename, &ofdev->dev,\n\t\t\t\t\t      GFP_KERNEL, &ofdev->dev, uart_firmware_cont);\n\t\tif (ret) {\n\t\t\tdev_err(&ofdev->dev,\n\t\t\t\t\"could not load firmware %s\\n\",\n\t\t\t\tfilename);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#else  \n\nstatic int soft_uart_init(struct platform_device *ofdev)\n{\n\treturn 0;\n}\n\n#endif\n\n\nstatic int ucc_uart_probe(struct platform_device *ofdev)\n{\n\tstruct device_node *np = ofdev->dev.of_node;\n\tconst char *sprop;       \n\tstruct uart_qe_port *qe_port = NULL;\n\tstruct resource res;\n\tu32 val;\n\tint ret;\n\n\t \n\tret = soft_uart_init(ofdev);\n\tif (ret)\n\t\treturn ret;\n\n\tqe_port = kzalloc(sizeof(struct uart_qe_port), GFP_KERNEL);\n\tif (!qe_port) {\n\t\tdev_err(&ofdev->dev, \"can't allocate QE port structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = of_address_to_resource(np, 0, &res);\n\tif (ret) {\n\t\tdev_err(&ofdev->dev, \"missing 'reg' property in device tree\\n\");\n\t\tgoto out_free;\n\t}\n\tif (!res.start) {\n\t\tdev_err(&ofdev->dev, \"invalid 'reg' property in device tree\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tqe_port->port.mapbase = res.start;\n\n\t \n\t \n\tif (of_property_read_u32(np, \"cell-index\", &val)) {\n\t\tif (of_property_read_u32(np, \"device-id\", &val)) {\n\t\t\tdev_err(&ofdev->dev, \"UCC is unspecified in device tree\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (val < 1 || val > UCC_MAX_NUM) {\n\t\tdev_err(&ofdev->dev, \"no support for UCC%u\\n\", val);\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\tqe_port->ucc_num = val - 1;\n\n\t \n\n\tsprop = of_get_property(np, \"rx-clock-name\", NULL);\n\tif (!sprop) {\n\t\tdev_err(&ofdev->dev, \"missing rx-clock-name in device tree\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tqe_port->us_info.rx_clock = qe_clock_source(sprop);\n\tif ((qe_port->us_info.rx_clock < QE_BRG1) ||\n\t    (qe_port->us_info.rx_clock > QE_BRG16)) {\n\t\tdev_err(&ofdev->dev, \"rx-clock-name must be a BRG for UART\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n#ifdef LOOPBACK\n\t \n\tqe_port->us_info.tx_clock = qe_port->us_info.rx_clock;\n#else\n\tsprop = of_get_property(np, \"tx-clock-name\", NULL);\n\tif (!sprop) {\n\t\tdev_err(&ofdev->dev, \"missing tx-clock-name in device tree\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\tqe_port->us_info.tx_clock = qe_clock_source(sprop);\n#endif\n\tif ((qe_port->us_info.tx_clock < QE_BRG1) ||\n\t    (qe_port->us_info.tx_clock > QE_BRG16)) {\n\t\tdev_err(&ofdev->dev, \"tx-clock-name must be a BRG for UART\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\t \n\tif (of_property_read_u32(np, \"port-number\", &val)) {\n\t\tdev_err(&ofdev->dev, \"missing port-number in device tree\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tqe_port->port.line = val;\n\tif (qe_port->port.line >= UCC_MAX_UART) {\n\t\tdev_err(&ofdev->dev, \"port-number must be 0-%u\\n\",\n\t\t\tUCC_MAX_UART - 1);\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tqe_port->port.irq = irq_of_parse_and_map(np, 0);\n\tif (qe_port->port.irq == 0) {\n\t\tdev_err(&ofdev->dev, \"could not map IRQ for UCC%u\\n\",\n\t\t       qe_port->ucc_num + 1);\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t \n\tnp = of_find_compatible_node(NULL, NULL, \"fsl,qe\");\n\tif (!np) {\n\t\tnp = of_find_node_by_type(NULL, \"qe\");\n\t\tif (!np) {\n\t\t\tdev_err(&ofdev->dev, \"could not find 'qe' node\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (of_property_read_u32(np, \"brg-frequency\", &val)) {\n\t\tdev_err(&ofdev->dev,\n\t\t       \"missing brg-frequency in device tree\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_np;\n\t}\n\n\tif (val)\n\t\tqe_port->port.uartclk = val;\n\telse {\n\t\tif (!IS_ENABLED(CONFIG_PPC32)) {\n\t\t\tdev_err(&ofdev->dev,\n\t\t\t\t\"invalid brg-frequency in device tree\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_np;\n\t\t}\n\n\t\t \n\t\tif (of_property_read_u32(np, \"bus-frequency\", &val)) {\n\t\t\tdev_err(&ofdev->dev,\n\t\t\t\t\"missing QE bus-frequency in device tree\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_np;\n\t\t}\n\t\tif (val)\n\t\t\tqe_port->port.uartclk = val / 2;\n\t\telse {\n\t\t\tdev_err(&ofdev->dev,\n\t\t\t\t\"invalid QE bus-frequency in device tree\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_np;\n\t\t}\n\t}\n\n\tspin_lock_init(&qe_port->port.lock);\n\tqe_port->np = np;\n\tqe_port->port.dev = &ofdev->dev;\n\tqe_port->port.ops = &qe_uart_pops;\n\tqe_port->port.iotype = UPIO_MEM;\n\n\tqe_port->tx_nrfifos = TX_NUM_FIFO;\n\tqe_port->tx_fifosize = TX_BUF_SIZE;\n\tqe_port->rx_nrfifos = RX_NUM_FIFO;\n\tqe_port->rx_fifosize = RX_BUF_SIZE;\n\n\tqe_port->wait_closing = UCC_WAIT_CLOSING;\n\tqe_port->port.fifosize = 512;\n\tqe_port->port.flags = UPF_BOOT_AUTOCONF | UPF_IOREMAP;\n\n\tqe_port->us_info.ucc_num = qe_port->ucc_num;\n\tqe_port->us_info.regs = (phys_addr_t) res.start;\n\tqe_port->us_info.irq = qe_port->port.irq;\n\n\tqe_port->us_info.rx_bd_ring_len = qe_port->rx_nrfifos;\n\tqe_port->us_info.tx_bd_ring_len = qe_port->tx_nrfifos;\n\n\t \n\tqe_port->us_info.init_tx = 1;\n\tqe_port->us_info.init_rx = 1;\n\n\t \n\tret = uart_add_one_port(&ucc_uart_driver, &qe_port->port);\n\tif (ret) {\n\t\tdev_err(&ofdev->dev, \"could not add /dev/ttyQE%u\\n\",\n\t\t       qe_port->port.line);\n\t\tgoto out_np;\n\t}\n\n\tplatform_set_drvdata(ofdev, qe_port);\n\n\tdev_info(&ofdev->dev, \"UCC%u assigned to /dev/ttyQE%u\\n\",\n\t\tqe_port->ucc_num + 1, qe_port->port.line);\n\n\t \n\tdev_dbg(&ofdev->dev, \"mknod command is 'mknod /dev/ttyQE%u c %u %u'\\n\",\n\t       qe_port->port.line, SERIAL_QE_MAJOR,\n\t       SERIAL_QE_MINOR + qe_port->port.line);\n\n\treturn 0;\nout_np:\n\tof_node_put(np);\nout_free:\n\tkfree(qe_port);\n\treturn ret;\n}\n\nstatic int ucc_uart_remove(struct platform_device *ofdev)\n{\n\tstruct uart_qe_port *qe_port = platform_get_drvdata(ofdev);\n\n\tdev_info(&ofdev->dev, \"removing /dev/ttyQE%u\\n\", qe_port->port.line);\n\n\tuart_remove_one_port(&ucc_uart_driver, &qe_port->port);\n\n\tof_node_put(qe_port->np);\n\n\tkfree(qe_port);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ucc_uart_match[] = {\n\t{\n\t\t.type = \"serial\",\n\t\t.compatible = \"ucc_uart\",\n\t},\n\t{\n\t\t.compatible = \"fsl,t1040-ucc-uart\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ucc_uart_match);\n\nstatic struct platform_driver ucc_uart_of_driver = {\n\t.driver = {\n\t\t.name = \"ucc_uart\",\n\t\t.of_match_table    = ucc_uart_match,\n\t},\n\t.probe  \t= ucc_uart_probe,\n\t.remove \t= ucc_uart_remove,\n};\n\nstatic int __init ucc_uart_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO \"Freescale QUICC Engine UART device driver\\n\");\n#ifdef LOOPBACK\n\tprintk(KERN_INFO \"ucc-uart: Using loopback mode\\n\");\n#endif\n\n\tret = uart_register_driver(&ucc_uart_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"ucc-uart: could not register UART driver\\n\");\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&ucc_uart_of_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR\n\t\t       \"ucc-uart: could not register platform driver\\n\");\n\t\tuart_unregister_driver(&ucc_uart_driver);\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit ucc_uart_exit(void)\n{\n\tprintk(KERN_INFO\n\t       \"Freescale QUICC Engine UART device driver unloading\\n\");\n\n\tplatform_driver_unregister(&ucc_uart_of_driver);\n\tuart_unregister_driver(&ucc_uart_driver);\n}\n\nmodule_init(ucc_uart_init);\nmodule_exit(ucc_uart_exit);\n\nMODULE_DESCRIPTION(\"Freescale QUICC Engine (QE) UART\");\nMODULE_AUTHOR(\"Timur Tabi <timur@freescale.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS_CHARDEV_MAJOR(SERIAL_QE_MAJOR);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}