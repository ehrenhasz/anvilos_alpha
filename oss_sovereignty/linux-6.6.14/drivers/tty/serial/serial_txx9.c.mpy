{
  "module_name": "serial_txx9.c",
  "hash_id": "63f9df490120ff8c6115fd6ea1a9cd711eb79a8f7c9b82063386bdbc2fa678b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/serial_txx9.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#include <linux/io.h>\n\n#define PASS_LIMIT\t256\n\n#if !defined(CONFIG_SERIAL_TXX9_STDSERIAL)\n \n#define TXX9_TTY_NAME \"ttyTX\"\n#define TXX9_TTY_MINOR_START\t196\n#define TXX9_TTY_MAJOR\t204\n#else\n \n#define TXX9_TTY_NAME \"ttyS\"\n#define TXX9_TTY_MINOR_START\t64\n#define TXX9_TTY_MAJOR\tTTY_MAJOR\n#endif\n\n \n#define UPF_TXX9_HAVE_CTS_LINE\tUPF_BUGGY_UART\n#define UPF_TXX9_USE_SCLK\tUPF_MAGIC_MULTIPLIER\n\n#ifdef CONFIG_PCI\n \n#define ENABLE_SERIAL_TXX9_PCI\n#endif\n\n \n#define UART_NR  CONFIG_SERIAL_TXX9_NR_UARTS\n\n#define TXX9_REGION_SIZE\t0x24\n\n \n#define TXX9_SILCR\t0x00\n#define TXX9_SIDICR\t0x04\n#define TXX9_SIDISR\t0x08\n#define TXX9_SICISR\t0x0c\n#define TXX9_SIFCR\t0x10\n#define TXX9_SIFLCR\t0x14\n#define TXX9_SIBGR\t0x18\n#define TXX9_SITFIFO\t0x1c\n#define TXX9_SIRFIFO\t0x20\n\n \n#define TXX9_SILCR_SCS_MASK\t0x00000060\n#define TXX9_SILCR_SCS_IMCLK\t0x00000000\n#define TXX9_SILCR_SCS_IMCLK_BG\t0x00000020\n#define TXX9_SILCR_SCS_SCLK\t0x00000040\n#define TXX9_SILCR_SCS_SCLK_BG\t0x00000060\n#define TXX9_SILCR_UEPS\t0x00000010\n#define TXX9_SILCR_UPEN\t0x00000008\n#define TXX9_SILCR_USBL_MASK\t0x00000004\n#define TXX9_SILCR_USBL_1BIT\t0x00000000\n#define TXX9_SILCR_USBL_2BIT\t0x00000004\n#define TXX9_SILCR_UMODE_MASK\t0x00000003\n#define TXX9_SILCR_UMODE_8BIT\t0x00000000\n#define TXX9_SILCR_UMODE_7BIT\t0x00000001\n\n \n#define TXX9_SIDICR_TDE\t0x00008000\n#define TXX9_SIDICR_RDE\t0x00004000\n#define TXX9_SIDICR_TIE\t0x00002000\n#define TXX9_SIDICR_RIE\t0x00001000\n#define TXX9_SIDICR_SPIE\t0x00000800\n#define TXX9_SIDICR_CTSAC\t0x00000600\n#define TXX9_SIDICR_STIE_MASK\t0x0000003f\n#define TXX9_SIDICR_STIE_OERS\t\t0x00000020\n#define TXX9_SIDICR_STIE_CTSS\t\t0x00000010\n#define TXX9_SIDICR_STIE_RBRKD\t0x00000008\n#define TXX9_SIDICR_STIE_TRDY\t\t0x00000004\n#define TXX9_SIDICR_STIE_TXALS\t0x00000002\n#define TXX9_SIDICR_STIE_UBRKD\t0x00000001\n\n \n#define TXX9_SIDISR_UBRK\t0x00008000\n#define TXX9_SIDISR_UVALID\t0x00004000\n#define TXX9_SIDISR_UFER\t0x00002000\n#define TXX9_SIDISR_UPER\t0x00001000\n#define TXX9_SIDISR_UOER\t0x00000800\n#define TXX9_SIDISR_ERI\t0x00000400\n#define TXX9_SIDISR_TOUT\t0x00000200\n#define TXX9_SIDISR_TDIS\t0x00000100\n#define TXX9_SIDISR_RDIS\t0x00000080\n#define TXX9_SIDISR_STIS\t0x00000040\n#define TXX9_SIDISR_RFDN_MASK\t0x0000001f\n\n \n#define TXX9_SICISR_OERS\t0x00000020\n#define TXX9_SICISR_CTSS\t0x00000010\n#define TXX9_SICISR_RBRKD\t0x00000008\n#define TXX9_SICISR_TRDY\t0x00000004\n#define TXX9_SICISR_TXALS\t0x00000002\n#define TXX9_SICISR_UBRKD\t0x00000001\n\n \n#define TXX9_SIFCR_SWRST\t0x00008000\n#define TXX9_SIFCR_RDIL_MASK\t0x00000180\n#define TXX9_SIFCR_RDIL_1\t0x00000000\n#define TXX9_SIFCR_RDIL_4\t0x00000080\n#define TXX9_SIFCR_RDIL_8\t0x00000100\n#define TXX9_SIFCR_RDIL_12\t0x00000180\n#define TXX9_SIFCR_RDIL_MAX\t0x00000180\n#define TXX9_SIFCR_TDIL_MASK\t0x00000018\n#define TXX9_SIFCR_TDIL_1\t0x00000000\n#define TXX9_SIFCR_TDIL_4\t0x00000001\n#define TXX9_SIFCR_TDIL_8\t0x00000010\n#define TXX9_SIFCR_TDIL_MAX\t0x00000010\n#define TXX9_SIFCR_TFRST\t0x00000004\n#define TXX9_SIFCR_RFRST\t0x00000002\n#define TXX9_SIFCR_FRSTE\t0x00000001\n#define TXX9_SIO_TX_FIFO\t8\n#define TXX9_SIO_RX_FIFO\t16\n\n \n#define TXX9_SIFLCR_RCS\t0x00001000\n#define TXX9_SIFLCR_TES\t0x00000800\n#define TXX9_SIFLCR_RTSSC\t0x00000200\n#define TXX9_SIFLCR_RSDE\t0x00000100\n#define TXX9_SIFLCR_TSDE\t0x00000080\n#define TXX9_SIFLCR_RTSTL_MASK\t0x0000001e\n#define TXX9_SIFLCR_RTSTL_MAX\t0x0000001e\n#define TXX9_SIFLCR_TBRK\t0x00000001\n\n \n#define TXX9_SIBGR_BCLK_MASK\t0x00000300\n#define TXX9_SIBGR_BCLK_T0\t0x00000000\n#define TXX9_SIBGR_BCLK_T2\t0x00000100\n#define TXX9_SIBGR_BCLK_T4\t0x00000200\n#define TXX9_SIBGR_BCLK_T6\t0x00000300\n#define TXX9_SIBGR_BRD_MASK\t0x000000ff\n\nstatic inline unsigned int sio_in(struct uart_port *up, int offset)\n{\n\tswitch (up->iotype) {\n\tdefault:\n\t\treturn __raw_readl(up->membase + offset);\n\tcase UPIO_PORT:\n\t\treturn inl(up->iobase + offset);\n\t}\n}\n\nstatic inline void\nsio_out(struct uart_port *up, int offset, int value)\n{\n\tswitch (up->iotype) {\n\tdefault:\n\t\t__raw_writel(value, up->membase + offset);\n\t\tbreak;\n\tcase UPIO_PORT:\n\t\toutl(value, up->iobase + offset);\n\t\tbreak;\n\t}\n}\n\nstatic inline void\nsio_mask(struct uart_port *up, int offset, unsigned int value)\n{\n\tsio_out(up, offset, sio_in(up, offset) & ~value);\n}\nstatic inline void\nsio_set(struct uart_port *up, int offset, unsigned int value)\n{\n\tsio_out(up, offset, sio_in(up, offset) | value);\n}\n\nstatic inline void\nsio_quot_set(struct uart_port *up, int quot)\n{\n\tquot >>= 1;\n\tif (quot < 256)\n\t\tsio_out(up, TXX9_SIBGR, quot | TXX9_SIBGR_BCLK_T0);\n\telse if (quot < (256 << 2))\n\t\tsio_out(up, TXX9_SIBGR, (quot >> 2) | TXX9_SIBGR_BCLK_T2);\n\telse if (quot < (256 << 4))\n\t\tsio_out(up, TXX9_SIBGR, (quot >> 4) | TXX9_SIBGR_BCLK_T4);\n\telse if (quot < (256 << 6))\n\t\tsio_out(up, TXX9_SIBGR, (quot >> 6) | TXX9_SIBGR_BCLK_T6);\n\telse\n\t\tsio_out(up, TXX9_SIBGR, 0xff | TXX9_SIBGR_BCLK_T6);\n}\n\nstatic void serial_txx9_stop_tx(struct uart_port *up)\n{\n\tsio_mask(up, TXX9_SIDICR, TXX9_SIDICR_TIE);\n}\n\nstatic void serial_txx9_start_tx(struct uart_port *up)\n{\n\tsio_set(up, TXX9_SIDICR, TXX9_SIDICR_TIE);\n}\n\nstatic void serial_txx9_stop_rx(struct uart_port *up)\n{\n\tup->read_status_mask &= ~TXX9_SIDISR_RDIS;\n}\n\nstatic void serial_txx9_initialize(struct uart_port *up)\n{\n\tunsigned int tmout = 10000;\n\n\tsio_out(up, TXX9_SIFCR, TXX9_SIFCR_SWRST);\n\t \n\tudelay(1);\n\twhile ((sio_in(up, TXX9_SIFCR) & TXX9_SIFCR_SWRST) && --tmout)\n\t\tudelay(1);\n\t \n\tsio_set(up, TXX9_SIFCR,\n\t\tTXX9_SIFCR_TDIL_MAX | TXX9_SIFCR_RDIL_1);\n\t \n\tsio_out(up, TXX9_SILCR,\n\t\tTXX9_SILCR_UMODE_8BIT | TXX9_SILCR_USBL_1BIT |\n\t\t((up->flags & UPF_TXX9_USE_SCLK) ?\n\t\t TXX9_SILCR_SCS_SCLK_BG : TXX9_SILCR_SCS_IMCLK_BG));\n\tsio_quot_set(up, uart_get_divisor(up, 9600));\n\tsio_out(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSTL_MAX  );\n\tsio_out(up, TXX9_SIDICR, 0);\n}\n\nstatic inline void\nreceive_chars(struct uart_port *up, unsigned int *status)\n{\n\tunsigned int disr = *status;\n\tint max_count = 256;\n\tunsigned int next_ignore_status_mask;\n\tu8 ch, flag;\n\n\tdo {\n\t\tch = sio_in(up, TXX9_SIRFIFO);\n\t\tflag = TTY_NORMAL;\n\t\tup->icount.rx++;\n\n\t\t \n\t\tnext_ignore_status_mask =\n\t\t\tup->ignore_status_mask & ~TXX9_SIDISR_RFDN_MASK;\n\t\tif (unlikely(disr & (TXX9_SIDISR_UBRK | TXX9_SIDISR_UPER |\n\t\t\t\t     TXX9_SIDISR_UFER | TXX9_SIDISR_UOER))) {\n\t\t\t \n\t\t\tif (disr & TXX9_SIDISR_UBRK) {\n\t\t\t\tdisr &= ~(TXX9_SIDISR_UFER | TXX9_SIDISR_UPER);\n\t\t\t\tup->icount.brk++;\n\t\t\t\t \n\t\t\t\tif (uart_handle_break(up))\n\t\t\t\t\tgoto ignore_char;\n\t\t\t} else if (disr & TXX9_SIDISR_UPER)\n\t\t\t\tup->icount.parity++;\n\t\t\telse if (disr & TXX9_SIDISR_UFER)\n\t\t\t\tup->icount.frame++;\n\t\t\tif (disr & TXX9_SIDISR_UOER) {\n\t\t\t\tup->icount.overrun++;\n\t\t\t\t \n\t\t\t\tnext_ignore_status_mask |=\n\t\t\t\t\tTXX9_SIDISR_RFDN_MASK;\n\t\t\t}\n\n\t\t\t \n\t\t\tdisr &= up->read_status_mask;\n\n\t\t\tif (disr & TXX9_SIDISR_UBRK) {\n\t\t\t\tflag = TTY_BREAK;\n\t\t\t} else if (disr & TXX9_SIDISR_UPER)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (disr & TXX9_SIDISR_UFER)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\t\tif (uart_handle_sysrq_char(up, ch))\n\t\t\tgoto ignore_char;\n\n\t\tuart_insert_char(up, disr, TXX9_SIDISR_UOER, ch, flag);\n\n\tignore_char:\n\t\tup->ignore_status_mask = next_ignore_status_mask;\n\t\tdisr = sio_in(up, TXX9_SIDISR);\n\t} while (!(disr & TXX9_SIDISR_UVALID) && (max_count-- > 0));\n\n\ttty_flip_buffer_push(&up->state->port);\n\n\t*status = disr;\n}\n\nstatic inline void transmit_chars(struct uart_port *up)\n{\n\tu8 ch;\n\n\tuart_port_tx_limited(up, ch, TXX9_SIO_TX_FIFO,\n\t\ttrue,\n\t\tsio_out(up, TXX9_SITFIFO, ch),\n\t\t({}));\n}\n\nstatic irqreturn_t serial_txx9_interrupt(int irq, void *dev_id)\n{\n\tint pass_counter = 0;\n\tstruct uart_port *up = dev_id;\n\tunsigned int status;\n\n\twhile (1) {\n\t\tspin_lock(&up->lock);\n\t\tstatus = sio_in(up, TXX9_SIDISR);\n\t\tif (!(sio_in(up, TXX9_SIDICR) & TXX9_SIDICR_TIE))\n\t\t\tstatus &= ~TXX9_SIDISR_TDIS;\n\t\tif (!(status & (TXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS |\n\t\t\t\tTXX9_SIDISR_TOUT))) {\n\t\t\tspin_unlock(&up->lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (status & TXX9_SIDISR_RDIS)\n\t\t\treceive_chars(up, &status);\n\t\tif (status & TXX9_SIDISR_TDIS)\n\t\t\ttransmit_chars(up);\n\t\t \n\t\tsio_mask(up, TXX9_SIDISR,\n\t\t\t TXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS |\n\t\t\t TXX9_SIDISR_TOUT);\n\t\tspin_unlock(&up->lock);\n\n\t\tif (pass_counter++ > PASS_LIMIT)\n\t\t\tbreak;\n\t}\n\n\treturn pass_counter ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic unsigned int serial_txx9_tx_empty(struct uart_port *up)\n{\n\tunsigned long flags;\n\tunsigned int ret;\n\n\tspin_lock_irqsave(&up->lock, flags);\n\tret = (sio_in(up, TXX9_SICISR) & TXX9_SICISR_TXALS) ? TIOCSER_TEMT : 0;\n\tspin_unlock_irqrestore(&up->lock, flags);\n\n\treturn ret;\n}\n\nstatic unsigned int serial_txx9_get_mctrl(struct uart_port *up)\n{\n\tunsigned int ret;\n\n\t \n\tret = TIOCM_CAR | TIOCM_DSR;\n\tret |= (sio_in(up, TXX9_SIFLCR) & TXX9_SIFLCR_RTSSC) ? 0 : TIOCM_RTS;\n\tret |= (sio_in(up, TXX9_SICISR) & TXX9_SICISR_CTSS) ? 0 : TIOCM_CTS;\n\n\treturn ret;\n}\n\nstatic void serial_txx9_set_mctrl(struct uart_port *up, unsigned int mctrl)\n{\n\n\tif (mctrl & TIOCM_RTS)\n\t\tsio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSSC);\n\telse\n\t\tsio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSSC);\n}\n\nstatic void serial_txx9_break_ctl(struct uart_port *up, int break_state)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&up->lock, flags);\n\tif (break_state == -1)\n\t\tsio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);\n\telse\n\t\tsio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);\n\tspin_unlock_irqrestore(&up->lock, flags);\n}\n\n#if defined(CONFIG_SERIAL_TXX9_CONSOLE) || defined(CONFIG_CONSOLE_POLL)\n \nstatic void wait_for_xmitr(struct uart_port *up)\n{\n\tunsigned int tmout = 10000;\n\n\t \n\twhile (--tmout &&\n\t       !(sio_in(up, TXX9_SICISR) & TXX9_SICISR_TXALS))\n\t\tudelay(1);\n\n\t \n\tif (up->flags & UPF_CONS_FLOW) {\n\t\ttmout = 1000000;\n\t\twhile (--tmout &&\n\t\t       (sio_in(up, TXX9_SICISR) & TXX9_SICISR_CTSS))\n\t\t\tudelay(1);\n\t}\n}\n#endif\n\n#ifdef CONFIG_CONSOLE_POLL\n \n\nstatic int serial_txx9_get_poll_char(struct uart_port *up)\n{\n\tunsigned int ier;\n\tunsigned char c;\n\n\t \n\tier = sio_in(up, TXX9_SIDICR);\n\tsio_out(up, TXX9_SIDICR, 0);\n\n\twhile (sio_in(up, TXX9_SIDISR) & TXX9_SIDISR_UVALID)\n\t\t;\n\n\tc = sio_in(up, TXX9_SIRFIFO);\n\n\t \n\tsio_mask(up, TXX9_SIDISR, TXX9_SIDISR_RDIS);\n\tsio_out(up, TXX9_SIDICR, ier);\n\treturn c;\n}\n\n\nstatic void serial_txx9_put_poll_char(struct uart_port *up, unsigned char c)\n{\n\tunsigned int ier;\n\n\t \n\tier = sio_in(up, TXX9_SIDICR);\n\tsio_out(up, TXX9_SIDICR, 0);\n\n\twait_for_xmitr(up);\n\t \n\tsio_out(up, TXX9_SITFIFO, c);\n\n\t \n\twait_for_xmitr(up);\n\tsio_out(up, TXX9_SIDICR, ier);\n}\n\n#endif  \n\nstatic int serial_txx9_startup(struct uart_port *up)\n{\n\tunsigned long flags;\n\tint retval;\n\n\t \n\tsio_set(up, TXX9_SIFCR,\n\t\tTXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);\n\t \n\tsio_mask(up, TXX9_SIFCR,\n\t\t TXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);\n\tsio_out(up, TXX9_SIDICR, 0);\n\n\t \n\tsio_out(up, TXX9_SIDISR, 0);\n\n\tretval = request_irq(up->irq, serial_txx9_interrupt,\n\t\t\t     IRQF_SHARED, \"serial_txx9\", up);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tspin_lock_irqsave(&up->lock, flags);\n\tserial_txx9_set_mctrl(up, up->mctrl);\n\tspin_unlock_irqrestore(&up->lock, flags);\n\n\t \n\tsio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_RSDE | TXX9_SIFLCR_TSDE);\n\n\t \n\tsio_set(up, TXX9_SIDICR, TXX9_SIDICR_RIE);\n\n\treturn 0;\n}\n\nstatic void serial_txx9_shutdown(struct uart_port *up)\n{\n\tunsigned long flags;\n\n\t \n\tsio_out(up, TXX9_SIDICR, 0);\t \n\n\tspin_lock_irqsave(&up->lock, flags);\n\tserial_txx9_set_mctrl(up, up->mctrl);\n\tspin_unlock_irqrestore(&up->lock, flags);\n\n\t \n\tsio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);\n\n#ifdef CONFIG_SERIAL_TXX9_CONSOLE\n\tif (up->cons && up->line == up->cons->index) {\n\t\tfree_irq(up->irq, up);\n\t\treturn;\n\t}\n#endif\n\t \n\tsio_set(up, TXX9_SIFCR,\n\t\tTXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);\n\t \n\tsio_mask(up, TXX9_SIFCR,\n\t\t TXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);\n\n\t \n\tsio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_RSDE | TXX9_SIFLCR_TSDE);\n\n\tfree_irq(up->irq, up);\n}\n\nstatic void\nserial_txx9_set_termios(struct uart_port *up, struct ktermios *termios,\n\t\t\tconst struct ktermios *old)\n{\n\tunsigned int cval, fcr = 0;\n\tunsigned long flags;\n\tunsigned int baud, quot;\n\n\t \n\ttermios->c_cflag &= ~(HUPCL | CMSPAR);\n\ttermios->c_cflag |= CLOCAL;\n\n\tcval = sio_in(up, TXX9_SILCR);\n\t \n\tcval &= ~TXX9_SILCR_UMODE_MASK;\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS7:\n\t\tcval |= TXX9_SILCR_UMODE_7BIT;\n\t\tbreak;\n\tdefault:\n\tcase CS5:\t \n\tcase CS6:\t \n\tcase CS8:\n\t\tcval |= TXX9_SILCR_UMODE_8BIT;\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= CS8;\n\t\tbreak;\n\t}\n\n\tcval &= ~TXX9_SILCR_USBL_MASK;\n\tif (termios->c_cflag & CSTOPB)\n\t\tcval |= TXX9_SILCR_USBL_2BIT;\n\telse\n\t\tcval |= TXX9_SILCR_USBL_1BIT;\n\tcval &= ~(TXX9_SILCR_UPEN | TXX9_SILCR_UEPS);\n\tif (termios->c_cflag & PARENB)\n\t\tcval |= TXX9_SILCR_UPEN;\n\tif (!(termios->c_cflag & PARODD))\n\t\tcval |= TXX9_SILCR_UEPS;\n\n\t \n\tbaud = uart_get_baud_rate(up, termios, old, 0, up->uartclk/16/2);\n\tquot = uart_get_divisor(up, baud);\n\n\t \n\t \n\tfcr = TXX9_SIFCR_TDIL_MAX | TXX9_SIFCR_RDIL_1;\n\n\t \n\tspin_lock_irqsave(&up->lock, flags);\n\n\t \n\tuart_update_timeout(up, termios->c_cflag, baud);\n\n\tup->read_status_mask = TXX9_SIDISR_UOER |\n\t\tTXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS;\n\tif (termios->c_iflag & INPCK)\n\t\tup->read_status_mask |= TXX9_SIDISR_UFER | TXX9_SIDISR_UPER;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tup->read_status_mask |= TXX9_SIDISR_UBRK;\n\n\t \n\tup->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tup->ignore_status_mask |= TXX9_SIDISR_UPER | TXX9_SIDISR_UFER;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tup->ignore_status_mask |= TXX9_SIDISR_UBRK;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tup->ignore_status_mask |= TXX9_SIDISR_UOER;\n\t}\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tup->ignore_status_mask |= TXX9_SIDISR_RDIS;\n\n\t \n\tif ((termios->c_cflag & CRTSCTS) &&\n\t    (up->flags & UPF_TXX9_HAVE_CTS_LINE)) {\n\t\tsio_set(up, TXX9_SIFLCR,\n\t\t\tTXX9_SIFLCR_RCS | TXX9_SIFLCR_TES);\n\t} else {\n\t\tsio_mask(up, TXX9_SIFLCR,\n\t\t\t TXX9_SIFLCR_RCS | TXX9_SIFLCR_TES);\n\t}\n\n\tsio_out(up, TXX9_SILCR, cval);\n\tsio_quot_set(up, quot);\n\tsio_out(up, TXX9_SIFCR, fcr);\n\n\tserial_txx9_set_mctrl(up, up->mctrl);\n\tspin_unlock_irqrestore(&up->lock, flags);\n}\n\nstatic void\nserial_txx9_pm(struct uart_port *port, unsigned int state,\n\t      unsigned int oldstate)\n{\n\t \n\tif (state == 0 && oldstate != -1)\n\t\tserial_txx9_initialize(port);\n}\n\nstatic int serial_txx9_request_resource(struct uart_port *up)\n{\n\tunsigned int size = TXX9_REGION_SIZE;\n\tint ret = 0;\n\n\tswitch (up->iotype) {\n\tdefault:\n\t\tif (!up->mapbase)\n\t\t\tbreak;\n\n\t\tif (!request_mem_region(up->mapbase, size, \"serial_txx9\")) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (up->flags & UPF_IOREMAP) {\n\t\t\tup->membase = ioremap(up->mapbase, size);\n\t\t\tif (!up->membase) {\n\t\t\t\trelease_mem_region(up->mapbase, size);\n\t\t\t\tret = -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase UPIO_PORT:\n\t\tif (!request_region(up->iobase, size, \"serial_txx9\"))\n\t\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void serial_txx9_release_resource(struct uart_port *up)\n{\n\tunsigned int size = TXX9_REGION_SIZE;\n\n\tswitch (up->iotype) {\n\tdefault:\n\t\tif (!up->mapbase)\n\t\t\tbreak;\n\n\t\tif (up->flags & UPF_IOREMAP) {\n\t\t\tiounmap(up->membase);\n\t\t\tup->membase = NULL;\n\t\t}\n\n\t\trelease_mem_region(up->mapbase, size);\n\t\tbreak;\n\n\tcase UPIO_PORT:\n\t\trelease_region(up->iobase, size);\n\t\tbreak;\n\t}\n}\n\nstatic void serial_txx9_release_port(struct uart_port *up)\n{\n\tserial_txx9_release_resource(up);\n}\n\nstatic int serial_txx9_request_port(struct uart_port *up)\n{\n\treturn serial_txx9_request_resource(up);\n}\n\nstatic void serial_txx9_config_port(struct uart_port *up, int uflags)\n{\n\tint ret;\n\n\t \n\tret = serial_txx9_request_resource(up);\n\tif (ret < 0)\n\t\treturn;\n\tup->type = PORT_TXX9;\n\tup->fifosize = TXX9_SIO_TX_FIFO;\n\n#ifdef CONFIG_SERIAL_TXX9_CONSOLE\n\tif (up->line == up->cons->index)\n\t\treturn;\n#endif\n\tserial_txx9_initialize(up);\n}\n\nstatic const char *\nserial_txx9_type(struct uart_port *port)\n{\n\treturn \"txx9\";\n}\n\nstatic const struct uart_ops serial_txx9_pops = {\n\t.tx_empty\t= serial_txx9_tx_empty,\n\t.set_mctrl\t= serial_txx9_set_mctrl,\n\t.get_mctrl\t= serial_txx9_get_mctrl,\n\t.stop_tx\t= serial_txx9_stop_tx,\n\t.start_tx\t= serial_txx9_start_tx,\n\t.stop_rx\t= serial_txx9_stop_rx,\n\t.break_ctl\t= serial_txx9_break_ctl,\n\t.startup\t= serial_txx9_startup,\n\t.shutdown\t= serial_txx9_shutdown,\n\t.set_termios\t= serial_txx9_set_termios,\n\t.pm\t\t= serial_txx9_pm,\n\t.type\t\t= serial_txx9_type,\n\t.release_port\t= serial_txx9_release_port,\n\t.request_port\t= serial_txx9_request_port,\n\t.config_port\t= serial_txx9_config_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= serial_txx9_get_poll_char,\n\t.poll_put_char\t= serial_txx9_put_poll_char,\n#endif\n};\n\nstatic struct uart_port serial_txx9_ports[UART_NR];\n\nstatic void __init serial_txx9_register_ports(struct uart_driver *drv,\n\t\t\t\t\t      struct device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < UART_NR; i++) {\n\t\tstruct uart_port *up = &serial_txx9_ports[i];\n\n\t\tup->line = i;\n\t\tup->ops = &serial_txx9_pops;\n\t\tup->dev = dev;\n\t\tif (up->iobase || up->mapbase)\n\t\t\tuart_add_one_port(drv, up);\n\t}\n}\n\n#ifdef CONFIG_SERIAL_TXX9_CONSOLE\n\nstatic void serial_txx9_console_putchar(struct uart_port *up, unsigned char ch)\n{\n\twait_for_xmitr(up);\n\tsio_out(up, TXX9_SITFIFO, ch);\n}\n\n \nstatic void\nserial_txx9_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct uart_port *up = &serial_txx9_ports[co->index];\n\tunsigned int ier, flcr;\n\n\t \n\tier = sio_in(up, TXX9_SIDICR);\n\tsio_out(up, TXX9_SIDICR, 0);\n\t \n\tflcr = sio_in(up, TXX9_SIFLCR);\n\tif (!(up->flags & UPF_CONS_FLOW) && (flcr & TXX9_SIFLCR_TES))\n\t\tsio_out(up, TXX9_SIFLCR, flcr & ~TXX9_SIFLCR_TES);\n\n\tuart_console_write(up, s, count, serial_txx9_console_putchar);\n\n\t \n\twait_for_xmitr(up);\n\tsio_out(up, TXX9_SIFLCR, flcr);\n\tsio_out(up, TXX9_SIDICR, ier);\n}\n\nstatic int __init serial_txx9_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *up;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\t \n\tif (co->index >= UART_NR)\n\t\tco->index = 0;\n\tup = &serial_txx9_ports[co->index];\n\tif (!up->ops)\n\t\treturn -ENODEV;\n\n\tserial_txx9_initialize(up);\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(up, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver serial_txx9_reg;\nstatic struct console serial_txx9_console = {\n\t.name\t\t= TXX9_TTY_NAME,\n\t.write\t\t= serial_txx9_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= serial_txx9_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &serial_txx9_reg,\n};\n\nstatic int __init serial_txx9_console_init(void)\n{\n\tregister_console(&serial_txx9_console);\n\treturn 0;\n}\nconsole_initcall(serial_txx9_console_init);\n\n#define SERIAL_TXX9_CONSOLE\t&serial_txx9_console\n#else\n#define SERIAL_TXX9_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver serial_txx9_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"serial_txx9\",\n\t.dev_name\t\t= TXX9_TTY_NAME,\n\t.major\t\t\t= TXX9_TTY_MAJOR,\n\t.minor\t\t\t= TXX9_TTY_MINOR_START,\n\t.nr\t\t\t= UART_NR,\n\t.cons\t\t\t= SERIAL_TXX9_CONSOLE,\n};\n\nint __init early_serial_txx9_setup(struct uart_port *port)\n{\n\tif (port->line >= ARRAY_SIZE(serial_txx9_ports))\n\t\treturn -ENODEV;\n\n\tserial_txx9_ports[port->line] = *port;\n\tserial_txx9_ports[port->line].ops = &serial_txx9_pops;\n\tserial_txx9_ports[port->line].flags |=\n\t\tUPF_BOOT_AUTOCONF | UPF_FIXED_PORT;\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(serial_txx9_mutex);\n\n \nstatic int serial_txx9_register_port(struct uart_port *port)\n{\n\tint i;\n\tstruct uart_port *uart;\n\tint ret = -ENOSPC;\n\n\tmutex_lock(&serial_txx9_mutex);\n\tfor (i = 0; i < UART_NR; i++) {\n\t\tuart = &serial_txx9_ports[i];\n\t\tif (uart_match_port(uart, port)) {\n\t\t\tuart_remove_one_port(&serial_txx9_reg, uart);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == UART_NR) {\n\t\t \n\t\tfor (i = 0; i < UART_NR; i++) {\n\t\t\tuart = &serial_txx9_ports[i];\n\t\t\tif (!(uart->iobase || uart->mapbase))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i < UART_NR) {\n\t\tuart->iobase = port->iobase;\n\t\tuart->membase = port->membase;\n\t\tuart->irq      = port->irq;\n\t\tuart->uartclk  = port->uartclk;\n\t\tuart->iotype   = port->iotype;\n\t\tuart->flags    = port->flags\n\t\t\t| UPF_BOOT_AUTOCONF | UPF_FIXED_PORT;\n\t\tuart->mapbase  = port->mapbase;\n\t\tif (port->dev)\n\t\t\tuart->dev = port->dev;\n\t\tret = uart_add_one_port(&serial_txx9_reg, uart);\n\t\tif (ret == 0)\n\t\t\tret = uart->line;\n\t}\n\tmutex_unlock(&serial_txx9_mutex);\n\treturn ret;\n}\n\n \nstatic void serial_txx9_unregister_port(int line)\n{\n\tstruct uart_port *uart = &serial_txx9_ports[line];\n\n\tmutex_lock(&serial_txx9_mutex);\n\tuart_remove_one_port(&serial_txx9_reg, uart);\n\tuart->flags = 0;\n\tuart->type = PORT_UNKNOWN;\n\tuart->iobase = 0;\n\tuart->mapbase = 0;\n\tuart->membase = NULL;\n\tuart->dev = NULL;\n\tmutex_unlock(&serial_txx9_mutex);\n}\n\n \nstatic int serial_txx9_probe(struct platform_device *dev)\n{\n\tstruct uart_port *p = dev_get_platdata(&dev->dev);\n\tstruct uart_port port;\n\tint ret, i;\n\n\tmemset(&port, 0, sizeof(struct uart_port));\n\tfor (i = 0; p && p->uartclk != 0; p++, i++) {\n\t\tport.iobase\t= p->iobase;\n\t\tport.membase\t= p->membase;\n\t\tport.irq\t= p->irq;\n\t\tport.uartclk\t= p->uartclk;\n\t\tport.iotype\t= p->iotype;\n\t\tport.flags\t= p->flags;\n\t\tport.mapbase\t= p->mapbase;\n\t\tport.dev\t= &dev->dev;\n\t\tport.has_sysrq\t= IS_ENABLED(CONFIG_SERIAL_TXX9_CONSOLE);\n\t\tret = serial_txx9_register_port(&port);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->dev, \"unable to register port at index %d \"\n\t\t\t\t\"(IO%lx MEM%llx IRQ%d): %d\\n\", i,\n\t\t\t\tp->iobase, (unsigned long long)p->mapbase,\n\t\t\t\tp->irq, ret);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int serial_txx9_remove(struct platform_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < UART_NR; i++) {\n\t\tstruct uart_port *up = &serial_txx9_ports[i];\n\n\t\tif (up->dev == &dev->dev)\n\t\t\tserial_txx9_unregister_port(i);\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int serial_txx9_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tint i;\n\n\tfor (i = 0; i < UART_NR; i++) {\n\t\tstruct uart_port *up = &serial_txx9_ports[i];\n\n\t\tif (up->type != PORT_UNKNOWN && up->dev == &dev->dev)\n\t\t\tuart_suspend_port(&serial_txx9_reg, up);\n\t}\n\n\treturn 0;\n}\n\nstatic int serial_txx9_resume(struct platform_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < UART_NR; i++) {\n\t\tstruct uart_port *up = &serial_txx9_ports[i];\n\n\t\tif (up->type != PORT_UNKNOWN && up->dev == &dev->dev)\n\t\t\tuart_resume_port(&serial_txx9_reg, up);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic struct platform_driver serial_txx9_plat_driver = {\n\t.probe\t\t= serial_txx9_probe,\n\t.remove\t\t= serial_txx9_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= serial_txx9_suspend,\n\t.resume\t\t= serial_txx9_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= \"serial_txx9\",\n\t},\n};\n\n#ifdef ENABLE_SERIAL_TXX9_PCI\n \nstatic int\npciserial_txx9_init_one(struct pci_dev *dev, const struct pci_device_id *ent)\n{\n\tstruct uart_port port;\n\tint line;\n\tint rc;\n\n\trc = pci_enable_device(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tmemset(&port, 0, sizeof(port));\n\tport.ops = &serial_txx9_pops;\n\tport.flags |= UPF_TXX9_HAVE_CTS_LINE;\n\tport.uartclk = 66670000;\n\tport.irq = dev->irq;\n\tport.iotype = UPIO_PORT;\n\tport.iobase = pci_resource_start(dev, 1);\n\tport.dev = &dev->dev;\n\tline = serial_txx9_register_port(&port);\n\tif (line < 0) {\n\t\tprintk(KERN_WARNING \"Couldn't register serial port %s: %d\\n\", pci_name(dev), line);\n\t\tpci_disable_device(dev);\n\t\treturn line;\n\t}\n\tpci_set_drvdata(dev, &serial_txx9_ports[line]);\n\n\treturn 0;\n}\n\nstatic void pciserial_txx9_remove_one(struct pci_dev *dev)\n{\n\tstruct uart_port *up = pci_get_drvdata(dev);\n\n\tif (up) {\n\t\tserial_txx9_unregister_port(up->line);\n\t\tpci_disable_device(dev);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int pciserial_txx9_suspend_one(struct pci_dev *dev, pm_message_t state)\n{\n\tstruct uart_port *up = pci_get_drvdata(dev);\n\n\tif (up)\n\t\tuart_suspend_port(&serial_txx9_reg, up);\n\tpci_save_state(dev);\n\tpci_set_power_state(dev, pci_choose_state(dev, state));\n\treturn 0;\n}\n\nstatic int pciserial_txx9_resume_one(struct pci_dev *dev)\n{\n\tstruct uart_port *up = pci_get_drvdata(dev);\n\n\tpci_set_power_state(dev, PCI_D0);\n\tpci_restore_state(dev);\n\tif (up)\n\t\tuart_resume_port(&serial_txx9_reg, up);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id serial_txx9_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA_2, PCI_DEVICE_ID_TOSHIBA_TC86C001_MISC) },\n\t{ 0, }\n};\n\nstatic struct pci_driver serial_txx9_pci_driver = {\n\t.name\t\t= \"serial_txx9\",\n\t.probe\t\t= pciserial_txx9_init_one,\n\t.remove\t\t= pciserial_txx9_remove_one,\n#ifdef CONFIG_PM\n\t.suspend\t= pciserial_txx9_suspend_one,\n\t.resume\t\t= pciserial_txx9_resume_one,\n#endif\n\t.id_table\t= serial_txx9_pci_tbl,\n};\n\nMODULE_DEVICE_TABLE(pci, serial_txx9_pci_tbl);\n#endif  \n\nstatic struct platform_device *serial_txx9_plat_devs;\n\nstatic int __init serial_txx9_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&serial_txx9_reg);\n\tif (ret)\n\t\tgoto out;\n\n\tserial_txx9_plat_devs = platform_device_alloc(\"serial_txx9\", -1);\n\tif (!serial_txx9_plat_devs) {\n\t\tret = -ENOMEM;\n\t\tgoto unreg_uart_drv;\n\t}\n\n\tret = platform_device_add(serial_txx9_plat_devs);\n\tif (ret)\n\t\tgoto put_dev;\n\n\tserial_txx9_register_ports(&serial_txx9_reg,\n\t\t\t\t   &serial_txx9_plat_devs->dev);\n\n\tret = platform_driver_register(&serial_txx9_plat_driver);\n\tif (ret)\n\t\tgoto del_dev;\n\n#ifdef ENABLE_SERIAL_TXX9_PCI\n\tret = pci_register_driver(&serial_txx9_pci_driver);\n\tif (ret) {\n\t\tplatform_driver_unregister(&serial_txx9_plat_driver);\n\t}\n#endif\n\tif (ret == 0)\n\t\tgoto out;\n\n del_dev:\n\tplatform_device_del(serial_txx9_plat_devs);\n put_dev:\n\tplatform_device_put(serial_txx9_plat_devs);\n unreg_uart_drv:\n\tuart_unregister_driver(&serial_txx9_reg);\n out:\n\treturn ret;\n}\n\nstatic void __exit serial_txx9_exit(void)\n{\n\tint i;\n\n#ifdef ENABLE_SERIAL_TXX9_PCI\n\tpci_unregister_driver(&serial_txx9_pci_driver);\n#endif\n\tplatform_driver_unregister(&serial_txx9_plat_driver);\n\tplatform_device_unregister(serial_txx9_plat_devs);\n\tfor (i = 0; i < UART_NR; i++) {\n\t\tstruct uart_port *up = &serial_txx9_ports[i];\n\t\tif (up->iobase || up->mapbase)\n\t\t\tuart_remove_one_port(&serial_txx9_reg, up);\n\t}\n\n\tuart_unregister_driver(&serial_txx9_reg);\n}\n\nmodule_init(serial_txx9_init);\nmodule_exit(serial_txx9_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TX39/49 serial driver\");\n\nMODULE_ALIAS_CHARDEV_MAJOR(TXX9_TTY_MAJOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}