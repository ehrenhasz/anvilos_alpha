{
  "module_name": "earlycon.c",
  "hash_id": "d5e3f2fcda658f8978545215f7452d631b6de9859b07c2b432396c6365e2a0c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/earlycon.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/console.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/serial_core.h>\n#include <linux/sizes.h>\n#include <linux/of.h>\n#include <linux/of_fdt.h>\n#include <linux/acpi.h>\n\n#ifdef CONFIG_FIX_EARLYCON_MEM\n#include <asm/fixmap.h>\n#endif\n\n#include <asm/serial.h>\n\nstatic struct console early_con = {\n\t.name =\t\t\"uart\",\t\t \n\t.flags =\tCON_PRINTBUFFER | CON_BOOT,\n\t.index =\t0,\n};\n\nstatic struct earlycon_device early_console_dev = {\n\t.con = &early_con,\n};\n\nstatic void __iomem * __init earlycon_map(resource_size_t paddr, size_t size)\n{\n\tvoid __iomem *base;\n#ifdef CONFIG_FIX_EARLYCON_MEM\n\tset_fixmap_io(FIX_EARLYCON_MEM_BASE, paddr & PAGE_MASK);\n\tbase = (void __iomem *)__fix_to_virt(FIX_EARLYCON_MEM_BASE);\n\tbase += paddr & ~PAGE_MASK;\n#else\n\tbase = ioremap(paddr, size);\n#endif\n\tif (!base)\n\t\tpr_err(\"%s: Couldn't map %pa\\n\", __func__, &paddr);\n\n\treturn base;\n}\n\nstatic void __init earlycon_init(struct earlycon_device *device,\n\t\t\t\t const char *name)\n{\n\tstruct console *earlycon = device->con;\n\tconst char *s;\n\tsize_t len;\n\n\t \n\tfor (s = name + strlen(name);\n\t     s > name && s[-1] >= '0' && s[-1] <= '9';\n\t     s--)\n\t\t;\n\tif (*s)\n\t\tearlycon->index = simple_strtoul(s, NULL, 10);\n\tlen = s - name;\n\tstrscpy(earlycon->name, name, min(len + 1, sizeof(earlycon->name)));\n\tearlycon->data = &early_console_dev;\n}\n\nstatic void __init earlycon_print_info(struct earlycon_device *device)\n{\n\tstruct console *earlycon = device->con;\n\tstruct uart_port *port = &device->port;\n\n\tif (port->iotype == UPIO_MEM || port->iotype == UPIO_MEM16 ||\n\t    port->iotype == UPIO_MEM32 || port->iotype == UPIO_MEM32BE)\n\t\tpr_info(\"%s%d at MMIO%s %pa (options '%s')\\n\",\n\t\t\tearlycon->name, earlycon->index,\n\t\t\t(port->iotype == UPIO_MEM) ? \"\" :\n\t\t\t(port->iotype == UPIO_MEM16) ? \"16\" :\n\t\t\t(port->iotype == UPIO_MEM32) ? \"32\" : \"32be\",\n\t\t\t&port->mapbase, device->options);\n\telse\n\t\tpr_info(\"%s%d at I/O port 0x%lx (options '%s')\\n\",\n\t\t\tearlycon->name, earlycon->index,\n\t\t\tport->iobase, device->options);\n}\n\nstatic int __init parse_options(struct earlycon_device *device, char *options)\n{\n\tstruct uart_port *port = &device->port;\n\tint length;\n\tresource_size_t addr;\n\n\tif (uart_parse_earlycon(options, &port->iotype, &addr, &options))\n\t\treturn -EINVAL;\n\n\tswitch (port->iotype) {\n\tcase UPIO_MEM:\n\t\tport->mapbase = addr;\n\t\tbreak;\n\tcase UPIO_MEM16:\n\t\tport->regshift = 1;\n\t\tport->mapbase = addr;\n\t\tbreak;\n\tcase UPIO_MEM32:\n\tcase UPIO_MEM32BE:\n\t\tport->regshift = 2;\n\t\tport->mapbase = addr;\n\t\tbreak;\n\tcase UPIO_PORT:\n\t\tport->iobase = addr;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (options) {\n\t\tchar *uartclk;\n\n\t\tdevice->baud = simple_strtoul(options, NULL, 0);\n\t\tuartclk = strchr(options, ',');\n\t\tif (uartclk && kstrtouint(uartclk + 1, 0, &port->uartclk) < 0)\n\t\t\tpr_warn(\"[%s] unsupported earlycon uart clkrate option\\n\",\n\t\t\t\toptions);\n\t\tlength = min(strcspn(options, \" \") + 1,\n\t\t\t     (size_t)(sizeof(device->options)));\n\t\tstrscpy(device->options, options, length);\n\t}\n\n\treturn 0;\n}\n\nstatic int __init register_earlycon(char *buf, const struct earlycon_id *match)\n{\n\tint err;\n\tstruct uart_port *port = &early_console_dev.port;\n\n\t \n\tif (buf && !parse_options(&early_console_dev, buf))\n\t\tbuf = NULL;\n\n\tspin_lock_init(&port->lock);\n\tif (!port->uartclk)\n\t\tport->uartclk = BASE_BAUD * 16;\n\tif (port->mapbase)\n\t\tport->membase = earlycon_map(port->mapbase, 64);\n\n\tearlycon_init(&early_console_dev, match->name);\n\terr = match->setup(&early_console_dev, buf);\n\tearlycon_print_info(&early_console_dev);\n\tif (err < 0)\n\t\treturn err;\n\tif (!early_console_dev.con->write)\n\t\treturn -ENODEV;\n\n\tregister_console(early_console_dev.con);\n\treturn 0;\n}\n\n \nint __init setup_earlycon(char *buf)\n{\n\tconst struct earlycon_id *match;\n\tbool empty_compatible = true;\n\n\tif (!buf || !buf[0])\n\t\treturn -EINVAL;\n\n\tif (console_is_registered(&early_con))\n\t\treturn -EALREADY;\n\nagain:\n\tfor (match = __earlycon_table; match < __earlycon_table_end; match++) {\n\t\tsize_t len = strlen(match->name);\n\n\t\tif (strncmp(buf, match->name, len))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (empty_compatible && *match->compatible)\n\t\t\tcontinue;\n\n\t\tif (buf[len]) {\n\t\t\tif (buf[len] != ',')\n\t\t\t\tcontinue;\n\t\t\tbuf += len + 1;\n\t\t} else\n\t\t\tbuf = NULL;\n\n\t\treturn register_earlycon(buf, match);\n\t}\n\n\tif (empty_compatible) {\n\t\tempty_compatible = false;\n\t\tgoto again;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nbool earlycon_acpi_spcr_enable __initdata;\n\n \nstatic int __init param_setup_earlycon(char *buf)\n{\n\tint err;\n\n\t \n\tif (!buf || !buf[0]) {\n\t\tif (IS_ENABLED(CONFIG_ACPI_SPCR_TABLE)) {\n\t\t\tearlycon_acpi_spcr_enable = true;\n\t\t\treturn 0;\n\t\t} else if (!buf) {\n\t\t\treturn early_init_dt_scan_chosen_stdout();\n\t\t}\n\t}\n\n\terr = setup_earlycon(buf);\n\tif (err == -ENOENT || err == -EALREADY)\n\t\treturn 0;\n\treturn err;\n}\nearly_param(\"earlycon\", param_setup_earlycon);\n\n#ifdef CONFIG_OF_EARLY_FLATTREE\n\nint __init of_setup_earlycon(const struct earlycon_id *match,\n\t\t\t     unsigned long node,\n\t\t\t     const char *options)\n{\n\tint err;\n\tstruct uart_port *port = &early_console_dev.port;\n\tconst __be32 *val;\n\tbool big_endian;\n\tu64 addr;\n\n\tif (console_is_registered(&early_con))\n\t\treturn -EALREADY;\n\n\tspin_lock_init(&port->lock);\n\tport->iotype = UPIO_MEM;\n\taddr = of_flat_dt_translate_address(node);\n\tif (addr == OF_BAD_ADDR) {\n\t\tpr_warn(\"[%s] bad address\\n\", match->name);\n\t\treturn -ENXIO;\n\t}\n\tport->mapbase = addr;\n\n\tval = of_get_flat_dt_prop(node, \"reg-offset\", NULL);\n\tif (val)\n\t\tport->mapbase += be32_to_cpu(*val);\n\tport->membase = earlycon_map(port->mapbase, SZ_4K);\n\n\tval = of_get_flat_dt_prop(node, \"reg-shift\", NULL);\n\tif (val)\n\t\tport->regshift = be32_to_cpu(*val);\n\tbig_endian = of_get_flat_dt_prop(node, \"big-endian\", NULL) != NULL ||\n\t\t(IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&\n\t\t of_get_flat_dt_prop(node, \"native-endian\", NULL) != NULL);\n\tval = of_get_flat_dt_prop(node, \"reg-io-width\", NULL);\n\tif (val) {\n\t\tswitch (be32_to_cpu(*val)) {\n\t\tcase 1:\n\t\t\tport->iotype = UPIO_MEM;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tport->iotype = UPIO_MEM16;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tport->iotype = (big_endian) ? UPIO_MEM32BE : UPIO_MEM32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"[%s] unsupported reg-io-width\\n\", match->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tval = of_get_flat_dt_prop(node, \"current-speed\", NULL);\n\tif (val)\n\t\tearly_console_dev.baud = be32_to_cpu(*val);\n\n\tval = of_get_flat_dt_prop(node, \"clock-frequency\", NULL);\n\tif (val)\n\t\tport->uartclk = be32_to_cpu(*val);\n\n\tif (options) {\n\t\tearly_console_dev.baud = simple_strtoul(options, NULL, 0);\n\t\tstrscpy(early_console_dev.options, options,\n\t\t\tsizeof(early_console_dev.options));\n\t}\n\tearlycon_init(&early_console_dev, match->name);\n\terr = match->setup(&early_console_dev, options);\n\tearlycon_print_info(&early_console_dev);\n\tif (err < 0)\n\t\treturn err;\n\tif (!early_console_dev.con->write)\n\t\treturn -ENODEV;\n\n\n\tregister_console(early_console_dev.con);\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}