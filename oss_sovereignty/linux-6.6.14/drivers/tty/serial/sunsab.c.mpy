{
  "module_name": "sunsab.c",
  "hash_id": "910dd6198748436eeef60a0a0d1b9f90df203aa057658eb5e728f81a4496467d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sunsab.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/circ_buf.h>\n#include <linux/serial.h>\n#include <linux/sysrq.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/setup.h>\n\n#include <linux/serial_core.h>\n#include <linux/sunserialcore.h>\n\n#include \"sunsab.h\"\n\nstruct uart_sunsab_port {\n\tstruct uart_port\t\tport;\t\t \n\tunion sab82532_async_regs\t__iomem *regs;\t \n\tunsigned long\t\t\tirqflags;\t \n\tint\t\t\t\tdsr;\t\t \n\tunsigned int\t\t\tcec_timeout;\t \n\tunsigned int\t\t\ttec_timeout;\t \n\tunsigned char\t\t\tinterrupt_mask0; \n\tunsigned char\t\t\tinterrupt_mask1; \n\tunsigned char\t\t\tpvr_dtr_bit;\t \n\tunsigned char\t\t\tpvr_dsr_bit;\t \n\tunsigned int\t\t\tgis_shift;\n\tint\t\t\t\ttype;\t\t \n\n\t \n\tunsigned int\t\t\tcached_ebrg;\n\tunsigned char\t\t\tcached_mode;\n\tunsigned char\t\t\tcached_pvr;\n\tunsigned char\t\t\tcached_dafo;\n};\n\n \n#define SAB_BASE_BAUD ( 29491200 / 16 )\n\nstatic char *sab82532_version[16] = {\n\t\"V1.0\", \"V2.0\", \"V3.2\", \"V(0x03)\",\n\t\"V(0x04)\", \"V(0x05)\", \"V(0x06)\", \"V(0x07)\",\n\t\"V(0x08)\", \"V(0x09)\", \"V(0x0a)\", \"V(0x0b)\",\n\t\"V(0x0c)\", \"V(0x0d)\", \"V(0x0e)\", \"V(0x0f)\"\n};\n\n#define SAB82532_MAX_TEC_TIMEOUT 200000\t \n#define SAB82532_MAX_CEC_TIMEOUT  50000\t \n\n#define SAB82532_RECV_FIFO_SIZE\t32       \n#define SAB82532_XMIT_FIFO_SIZE\t32\n\nstatic __inline__ void sunsab_tec_wait(struct uart_sunsab_port *up)\n{\n\tint timeout = up->tec_timeout;\n\n\twhile ((readb(&up->regs->r.star) & SAB82532_STAR_TEC) && --timeout)\n\t\tudelay(1);\n}\n\nstatic __inline__ void sunsab_cec_wait(struct uart_sunsab_port *up)\n{\n\tint timeout = up->cec_timeout;\n\n\twhile ((readb(&up->regs->r.star) & SAB82532_STAR_CEC) && --timeout)\n\t\tudelay(1);\n}\n\nstatic struct tty_port *\nreceive_chars(struct uart_sunsab_port *up,\n\t      union sab82532_irq_status *stat)\n{\n\tstruct tty_port *port = NULL;\n\tunsigned char buf[32];\n\tint saw_console_brk = 0;\n\tint free_fifo = 0;\n\tint count = 0;\n\tint i;\n\n\tif (up->port.state != NULL)\t\t \n\t\tport = &up->port.state->port;\n\n\t \n\tif (stat->sreg.isr0 & SAB82532_ISR0_RPF) {\n\t\tcount = SAB82532_RECV_FIFO_SIZE;\n\t\tfree_fifo++;\n\t}\n\n\tif (stat->sreg.isr0 & SAB82532_ISR0_TCD) {\n\t\tcount = readb(&up->regs->r.rbcl) & (SAB82532_RECV_FIFO_SIZE - 1);\n\t\tfree_fifo++;\n\t}\n\n\t \n\tif (stat->sreg.isr0 & SAB82532_ISR0_TIME) {\n\t\tsunsab_cec_wait(up);\n\t\twriteb(SAB82532_CMDR_RFRD, &up->regs->w.cmdr);\n\t\treturn port;\n\t}\n\n\tif (stat->sreg.isr0 & SAB82532_ISR0_RFO)\n\t\tfree_fifo++;\n\n\t \n\tfor (i = 0; i < count; i++)\n\t\tbuf[i] = readb(&up->regs->r.rfifo[i]);\n\n\t \n\tif (free_fifo) {\n\t\tsunsab_cec_wait(up);\n\t\twriteb(SAB82532_CMDR_RMC, &up->regs->w.cmdr);\n\t}\n\n\t \n\tif ((stat->sreg.isr1 & SAB82532_ISR1_BRK) &&\n\t    (up->port.line == up->port.cons->index))\n\t\tsaw_console_brk = 1;\n\n\tif (count == 0) {\n\t\tif (unlikely(stat->sreg.isr1 & SAB82532_ISR1_BRK)) {\n\t\t\tstat->sreg.isr0 &= ~(SAB82532_ISR0_PERR |\n\t\t\t\t\t     SAB82532_ISR0_FERR);\n\t\t\tup->port.icount.brk++;\n\t\t\tuart_handle_break(&up->port);\n\t\t}\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tunsigned char ch = buf[i], flag;\n\n\t\tflag = TTY_NORMAL;\n\t\tup->port.icount.rx++;\n\n\t\tif (unlikely(stat->sreg.isr0 & (SAB82532_ISR0_PERR |\n\t\t\t\t\t\tSAB82532_ISR0_FERR |\n\t\t\t\t\t\tSAB82532_ISR0_RFO)) ||\n\t\t    unlikely(stat->sreg.isr1 & SAB82532_ISR1_BRK)) {\n\t\t\t \n\t\t\tif (stat->sreg.isr1 & SAB82532_ISR1_BRK) {\n\t\t\t\tstat->sreg.isr0 &= ~(SAB82532_ISR0_PERR |\n\t\t\t\t\t\t     SAB82532_ISR0_FERR);\n\t\t\t\tup->port.icount.brk++;\n\t\t\t\t \n\t\t\t\tif (uart_handle_break(&up->port))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (stat->sreg.isr0 & SAB82532_ISR0_PERR)\n\t\t\t\tup->port.icount.parity++;\n\t\t\telse if (stat->sreg.isr0 & SAB82532_ISR0_FERR)\n\t\t\t\tup->port.icount.frame++;\n\t\t\tif (stat->sreg.isr0 & SAB82532_ISR0_RFO)\n\t\t\t\tup->port.icount.overrun++;\n\n\t\t\t \n\t\t\tstat->sreg.isr0 &= (up->port.read_status_mask & 0xff);\n\t\t\tstat->sreg.isr1 &= ((up->port.read_status_mask >> 8) & 0xff);\n\n\t\t\tif (stat->sreg.isr1 & SAB82532_ISR1_BRK) {\n\t\t\t\tflag = TTY_BREAK;\n\t\t\t} else if (stat->sreg.isr0 & SAB82532_ISR0_PERR)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (stat->sreg.isr0 & SAB82532_ISR0_FERR)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(&up->port, ch) || !port)\n\t\t\tcontinue;\n\n\t\tif ((stat->sreg.isr0 & (up->port.ignore_status_mask & 0xff)) == 0 &&\n\t\t    (stat->sreg.isr1 & ((up->port.ignore_status_mask >> 8) & 0xff)) == 0)\n\t\t\ttty_insert_flip_char(port, ch, flag);\n\t\tif (stat->sreg.isr0 & SAB82532_ISR0_RFO)\n\t\t\ttty_insert_flip_char(port, 0, TTY_OVERRUN);\n\t}\n\n\tif (saw_console_brk)\n\t\tsun_do_break();\n\n\treturn port;\n}\n\nstatic void sunsab_stop_tx(struct uart_port *);\nstatic void sunsab_tx_idle(struct uart_sunsab_port *);\n\nstatic void transmit_chars(struct uart_sunsab_port *up,\n\t\t\t   union sab82532_irq_status *stat)\n{\n\tstruct circ_buf *xmit = &up->port.state->xmit;\n\tint i;\n\n\tif (stat->sreg.isr1 & SAB82532_ISR1_ALLS) {\n\t\tup->interrupt_mask1 |= SAB82532_IMR1_ALLS;\n\t\twriteb(up->interrupt_mask1, &up->regs->w.imr1);\n\t\tset_bit(SAB82532_ALLS, &up->irqflags);\n\t}\n\n#if 0  \n\tif (!(stat->sreg.isr1 & SAB82532_ISR1_XPR))\n\t\treturn;\n#endif\n\n\tif (!(readb(&up->regs->r.star) & SAB82532_STAR_XFW))\n\t\treturn;\n\n\tset_bit(SAB82532_XPR, &up->irqflags);\n\tsunsab_tx_idle(up);\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {\n\t\tup->interrupt_mask1 |= SAB82532_IMR1_XPR;\n\t\twriteb(up->interrupt_mask1, &up->regs->w.imr1);\n\t\treturn;\n\t}\n\n\tup->interrupt_mask1 &= ~(SAB82532_IMR1_ALLS|SAB82532_IMR1_XPR);\n\twriteb(up->interrupt_mask1, &up->regs->w.imr1);\n\tclear_bit(SAB82532_ALLS, &up->irqflags);\n\n\t \n\tclear_bit(SAB82532_XPR, &up->irqflags);\n\tfor (i = 0; i < up->port.fifosize; i++) {\n\t\twriteb(xmit->buf[xmit->tail],\n\t\t       &up->regs->w.xfifo[i]);\n\t\tuart_xmit_advance(&up->port, 1);\n\t\tif (uart_circ_empty(xmit))\n\t\t\tbreak;\n\t}\n\n\t \n\tsunsab_cec_wait(up);\n\twriteb(SAB82532_CMDR_XF, &up->regs->w.cmdr);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&up->port);\n\n\tif (uart_circ_empty(xmit))\n\t\tsunsab_stop_tx(&up->port);\n}\n\nstatic void check_status(struct uart_sunsab_port *up,\n\t\t\t union sab82532_irq_status *stat)\n{\n\tif (stat->sreg.isr0 & SAB82532_ISR0_CDSC)\n\t\tuart_handle_dcd_change(&up->port,\n\t\t\t\t       !(readb(&up->regs->r.vstr) & SAB82532_VSTR_CD));\n\n\tif (stat->sreg.isr1 & SAB82532_ISR1_CSC)\n\t\tuart_handle_cts_change(&up->port,\n\t\t\t\t       (readb(&up->regs->r.star) & SAB82532_STAR_CTS));\n\n\tif ((readb(&up->regs->r.pvr) & up->pvr_dsr_bit) ^ up->dsr) {\n\t\tup->dsr = (readb(&up->regs->r.pvr) & up->pvr_dsr_bit) ? 0 : 1;\n\t\tup->port.icount.dsr++;\n\t}\n\n\twake_up_interruptible(&up->port.state->port.delta_msr_wait);\n}\n\nstatic irqreturn_t sunsab_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_sunsab_port *up = dev_id;\n\tstruct tty_port *port = NULL;\n\tunion sab82532_irq_status status;\n\tunsigned long flags;\n\tunsigned char gis;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tstatus.stat = 0;\n\tgis = readb(&up->regs->r.gis) >> up->gis_shift;\n\tif (gis & 1)\n\t\tstatus.sreg.isr0 = readb(&up->regs->r.isr0);\n\tif (gis & 2)\n\t\tstatus.sreg.isr1 = readb(&up->regs->r.isr1);\n\n\tif (status.stat) {\n\t\tif ((status.sreg.isr0 & (SAB82532_ISR0_TCD | SAB82532_ISR0_TIME |\n\t\t\t\t\t SAB82532_ISR0_RFO | SAB82532_ISR0_RPF)) ||\n\t\t    (status.sreg.isr1 & SAB82532_ISR1_BRK))\n\t\t\tport = receive_chars(up, &status);\n\t\tif ((status.sreg.isr0 & SAB82532_ISR0_CDSC) ||\n\t\t    (status.sreg.isr1 & SAB82532_ISR1_CSC))\n\t\t\tcheck_status(up, &status);\n\t\tif (status.sreg.isr1 & (SAB82532_ISR1_ALLS | SAB82532_ISR1_XPR))\n\t\t\ttransmit_chars(up, &status);\n\t}\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\tif (port)\n\t\ttty_flip_buffer_push(port);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic unsigned int sunsab_tx_empty(struct uart_port *port)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\tint ret;\n\n\t \n\tif (test_bit(SAB82532_ALLS, &up->irqflags))\n\t\tret = TIOCSER_TEMT;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\n \nstatic void sunsab_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\n\tif (mctrl & TIOCM_RTS) {\n\t\tup->cached_mode &= ~SAB82532_MODE_FRTS;\n\t\tup->cached_mode |= SAB82532_MODE_RTS;\n\t} else {\n\t\tup->cached_mode |= (SAB82532_MODE_FRTS |\n\t\t\t\t    SAB82532_MODE_RTS);\n\t}\n\tif (mctrl & TIOCM_DTR) {\n\t\tup->cached_pvr &= ~(up->pvr_dtr_bit);\n\t} else {\n\t\tup->cached_pvr |= up->pvr_dtr_bit;\n\t}\n\n\tset_bit(SAB82532_REGS_PENDING, &up->irqflags);\n\tif (test_bit(SAB82532_XPR, &up->irqflags))\n\t\tsunsab_tx_idle(up);\n}\n\n \nstatic unsigned int sunsab_get_mctrl(struct uart_port *port)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\tunsigned char val;\n\tunsigned int result;\n\n\tresult = 0;\n\n\tval = readb(&up->regs->r.pvr);\n\tresult |= (val & up->pvr_dsr_bit) ? 0 : TIOCM_DSR;\n\n\tval = readb(&up->regs->r.vstr);\n\tresult |= (val & SAB82532_VSTR_CD) ? 0 : TIOCM_CAR;\n\n\tval = readb(&up->regs->r.star);\n\tresult |= (val & SAB82532_STAR_CTS) ? TIOCM_CTS : 0;\n\n\treturn result;\n}\n\n \nstatic void sunsab_stop_tx(struct uart_port *port)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\n\tup->interrupt_mask1 |= SAB82532_IMR1_XPR;\n\twriteb(up->interrupt_mask1, &up->regs->w.imr1);\n}\n\n \nstatic void sunsab_tx_idle(struct uart_sunsab_port *up)\n{\n\tif (test_bit(SAB82532_REGS_PENDING, &up->irqflags)) {\n\t\tu8 tmp;\n\n\t\tclear_bit(SAB82532_REGS_PENDING, &up->irqflags);\n\t\twriteb(up->cached_mode, &up->regs->rw.mode);\n\t\twriteb(up->cached_pvr, &up->regs->rw.pvr);\n\t\twriteb(up->cached_dafo, &up->regs->w.dafo);\n\n\t\twriteb(up->cached_ebrg & 0xff, &up->regs->w.bgr);\n\t\ttmp = readb(&up->regs->rw.ccr2);\n\t\ttmp &= ~0xc0;\n\t\ttmp |= (up->cached_ebrg >> 2) & 0xc0;\n\t\twriteb(tmp, &up->regs->rw.ccr2);\n\t}\n}\n\n \nstatic void sunsab_start_tx(struct uart_port *port)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\tstruct circ_buf *xmit = &up->port.state->xmit;\n\tint i;\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port))\n\t\treturn;\n\n\tup->interrupt_mask1 &= ~(SAB82532_IMR1_ALLS|SAB82532_IMR1_XPR);\n\twriteb(up->interrupt_mask1, &up->regs->w.imr1);\n\t\n\tif (!test_bit(SAB82532_XPR, &up->irqflags))\n\t\treturn;\n\n\tclear_bit(SAB82532_ALLS, &up->irqflags);\n\tclear_bit(SAB82532_XPR, &up->irqflags);\n\n\tfor (i = 0; i < up->port.fifosize; i++) {\n\t\twriteb(xmit->buf[xmit->tail],\n\t\t       &up->regs->w.xfifo[i]);\n\t\tuart_xmit_advance(&up->port, 1);\n\t\tif (uart_circ_empty(xmit))\n\t\t\tbreak;\n\t}\n\n\t \n\tsunsab_cec_wait(up);\n\twriteb(SAB82532_CMDR_XF, &up->regs->w.cmdr);\n}\n\n \nstatic void sunsab_send_xchar(struct uart_port *port, char ch)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\tunsigned long flags;\n\n\tif (ch == __DISABLED_CHAR)\n\t\treturn;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tsunsab_tec_wait(up);\n\twriteb(ch, &up->regs->w.tic);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\n \nstatic void sunsab_stop_rx(struct uart_port *port)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\n\tup->interrupt_mask0 |= SAB82532_IMR0_TCD;\n\twriteb(up->interrupt_mask1, &up->regs->w.imr0);\n}\n\n \nstatic void sunsab_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\tunsigned long flags;\n\tunsigned char val;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tval = up->cached_dafo;\n\tif (break_state)\n\t\tval |= SAB82532_DAFO_XBRK;\n\telse\n\t\tval &= ~SAB82532_DAFO_XBRK;\n\tup->cached_dafo = val;\n\n\tset_bit(SAB82532_REGS_PENDING, &up->irqflags);\n\tif (test_bit(SAB82532_XPR, &up->irqflags))\n\t\tsunsab_tx_idle(up);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\n \nstatic int sunsab_startup(struct uart_port *port)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\tunsigned long flags;\n\tunsigned char tmp;\n\tint err = request_irq(up->port.irq, sunsab_interrupt,\n\t\t\t      IRQF_SHARED, \"sab\", up);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t \n\tsunsab_cec_wait(up);\n\tsunsab_tec_wait(up);\n\n\t \n\twriteb(SAB82532_CMDR_RRES, &up->regs->w.cmdr);\n\tsunsab_cec_wait(up);\n\twriteb(SAB82532_CMDR_XRES, &up->regs->w.cmdr);\n\n\t \n\t(void) readb(&up->regs->r.isr0);\n\t(void) readb(&up->regs->r.isr1);\n\n\t \n\twriteb(0, &up->regs->w.ccr0);\t\t\t\t \n\twriteb(SAB82532_CCR0_MCE | SAB82532_CCR0_SC_NRZ |\n\t       SAB82532_CCR0_SM_ASYNC, &up->regs->w.ccr0);\n\twriteb(SAB82532_CCR1_ODS | SAB82532_CCR1_BCR | 7, &up->regs->w.ccr1);\n\twriteb(SAB82532_CCR2_BDF | SAB82532_CCR2_SSEL |\n\t       SAB82532_CCR2_TOE, &up->regs->w.ccr2);\n\twriteb(0, &up->regs->w.ccr3);\n\twriteb(SAB82532_CCR4_MCK4 | SAB82532_CCR4_EBRG, &up->regs->w.ccr4);\n\tup->cached_mode = (SAB82532_MODE_RTS | SAB82532_MODE_FCTS |\n\t\t\t   SAB82532_MODE_RAC);\n\twriteb(up->cached_mode, &up->regs->w.mode);\n\twriteb(SAB82532_RFC_DPS|SAB82532_RFC_RFTH_32, &up->regs->w.rfc);\n\t\n\ttmp = readb(&up->regs->rw.ccr0);\n\ttmp |= SAB82532_CCR0_PU;\t \n\twriteb(tmp, &up->regs->rw.ccr0);\n\n\t \n\tup->interrupt_mask0 = (SAB82532_IMR0_PERR | SAB82532_IMR0_FERR |\n\t\t\t       SAB82532_IMR0_PLLA);\n\twriteb(up->interrupt_mask0, &up->regs->w.imr0);\n\tup->interrupt_mask1 = (SAB82532_IMR1_BRKT | SAB82532_IMR1_ALLS |\n\t\t\t       SAB82532_IMR1_XOFF | SAB82532_IMR1_TIN |\n\t\t\t       SAB82532_IMR1_CSC | SAB82532_IMR1_XON |\n\t\t\t       SAB82532_IMR1_XPR);\n\twriteb(up->interrupt_mask1, &up->regs->w.imr1);\n\tset_bit(SAB82532_ALLS, &up->irqflags);\n\tset_bit(SAB82532_XPR, &up->irqflags);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void sunsab_shutdown(struct uart_port *port)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t \n\tup->interrupt_mask0 = 0xff;\n\twriteb(up->interrupt_mask0, &up->regs->w.imr0);\n\tup->interrupt_mask1 = 0xff;\n\twriteb(up->interrupt_mask1, &up->regs->w.imr1);\n\n\t \n\tup->cached_dafo = readb(&up->regs->rw.dafo);\n\tup->cached_dafo &= ~SAB82532_DAFO_XBRK;\n\twriteb(up->cached_dafo, &up->regs->rw.dafo);\n\n\t \t\n\tup->cached_mode &= ~SAB82532_MODE_RAC;\n\twriteb(up->cached_mode, &up->regs->rw.mode);\n\n\t \n#if 0\n\t \t\n\ttmp = readb(&up->regs->rw.ccr0);\n\ttmp &= ~SAB82532_CCR0_PU;\n\twriteb(tmp, &up->regs->rw.ccr0);\n#endif\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\tfree_irq(up->port.irq, up);\n}\n\n \n\nstatic void calc_ebrg(int baud, int *n_ret, int *m_ret)\n{\n\tint\tn, m;\n\n\tif (baud == 0) {\n\t\t*n_ret = 0;\n\t\t*m_ret = 0;\n\t\treturn;\n\t}\n     \n\t \n\tn = (SAB_BASE_BAUD * 10) / baud;\n\tm = 0;\n\twhile (n >= 640) {\n\t\tn = n / 2;\n\t\tm++;\n\t}\n\tn = (n+5) / 10;\n\t \n\tif ((m == 0) && ((n & 1) == 0)) {\n\t\tn = n / 2;\n\t\tm++;\n\t}\n\t*n_ret = n - 1;\n\t*m_ret = m;\n}\n\n \nstatic void sunsab_convert_to_sab(struct uart_sunsab_port *up, unsigned int cflag,\n\t\t\t\t  unsigned int iflag, unsigned int baud,\n\t\t\t\t  unsigned int quot)\n{\n\tunsigned char dafo;\n\tint n, m;\n\n\t \n\tswitch (cflag & CSIZE) {\n\t      case CS5: dafo = SAB82532_DAFO_CHL5; break;\n\t      case CS6: dafo = SAB82532_DAFO_CHL6; break;\n\t      case CS7: dafo = SAB82532_DAFO_CHL7; break;\n\t      case CS8: dafo = SAB82532_DAFO_CHL8; break;\n\t       \n\t      default:  dafo = SAB82532_DAFO_CHL5; break;\n\t}\n\n\tif (cflag & CSTOPB)\n\t\tdafo |= SAB82532_DAFO_STOP;\n\n\tif (cflag & PARENB)\n\t\tdafo |= SAB82532_DAFO_PARE;\n\n\tif (cflag & PARODD) {\n\t\tdafo |= SAB82532_DAFO_PAR_ODD;\n\t} else {\n\t\tdafo |= SAB82532_DAFO_PAR_EVEN;\n\t}\n\tup->cached_dafo = dafo;\n\n\tcalc_ebrg(baud, &n, &m);\n\n\tup->cached_ebrg = n | (m << 6);\n\n\tup->tec_timeout = (10 * 1000000) / baud;\n\tup->cec_timeout = up->tec_timeout >> 2;\n\n\t \n\t \n\n\tup->port.read_status_mask = (SAB82532_ISR0_TCD | SAB82532_ISR0_TIME |\n\t\t\t\t     SAB82532_ISR0_RFO | SAB82532_ISR0_RPF |\n\t\t\t\t     SAB82532_ISR0_CDSC);\n\tup->port.read_status_mask |= (SAB82532_ISR1_CSC |\n\t\t\t\t      SAB82532_ISR1_ALLS |\n\t\t\t\t      SAB82532_ISR1_XPR) << 8;\n\tif (iflag & INPCK)\n\t\tup->port.read_status_mask |= (SAB82532_ISR0_PERR |\n\t\t\t\t\t      SAB82532_ISR0_FERR);\n\tif (iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tup->port.read_status_mask |= (SAB82532_ISR1_BRK << 8);\n\n\t \n\tup->port.ignore_status_mask = 0;\n\tif (iflag & IGNPAR)\n\t\tup->port.ignore_status_mask |= (SAB82532_ISR0_PERR |\n\t\t\t\t\t\tSAB82532_ISR0_FERR);\n\tif (iflag & IGNBRK) {\n\t\tup->port.ignore_status_mask |= (SAB82532_ISR1_BRK << 8);\n\t\t \n\t\tif (iflag & IGNPAR)\n\t\t\tup->port.ignore_status_mask |= SAB82532_ISR0_RFO;\n\t}\n\n\t \n\tif ((cflag & CREAD) == 0)\n\t\tup->port.ignore_status_mask |= (SAB82532_ISR0_RPF |\n\t\t\t\t\t\tSAB82532_ISR0_TCD);\n\n\tuart_update_timeout(&up->port, cflag,\n\t\t\t    (up->port.uartclk / (16 * quot)));\n\n\t \n\tup->cached_mode |= SAB82532_MODE_RAC;\n\tset_bit(SAB82532_REGS_PENDING, &up->irqflags);\n\tif (test_bit(SAB82532_XPR, &up->irqflags))\n\t\tsunsab_tx_idle(up);\n}\n\n \nstatic void sunsab_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t\t       const struct ktermios *old)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\tunsigned long flags;\n\tunsigned int baud = uart_get_baud_rate(port, termios, old, 0, 4000000);\n\tunsigned int quot = uart_get_divisor(port, baud);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tsunsab_convert_to_sab(up, termios->c_cflag, termios->c_iflag, baud, quot);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic const char *sunsab_type(struct uart_port *port)\n{\n\tstruct uart_sunsab_port *up = (void *)port;\n\tstatic char buf[36];\n\t\n\tsprintf(buf, \"SAB82532 %s\", sab82532_version[up->type]);\n\treturn buf;\n}\n\nstatic void sunsab_release_port(struct uart_port *port)\n{\n}\n\nstatic int sunsab_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void sunsab_config_port(struct uart_port *port, int flags)\n{\n}\n\nstatic int sunsab_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct uart_ops sunsab_pops = {\n\t.tx_empty\t= sunsab_tx_empty,\n\t.set_mctrl\t= sunsab_set_mctrl,\n\t.get_mctrl\t= sunsab_get_mctrl,\n\t.stop_tx\t= sunsab_stop_tx,\n\t.start_tx\t= sunsab_start_tx,\n\t.send_xchar\t= sunsab_send_xchar,\n\t.stop_rx\t= sunsab_stop_rx,\n\t.break_ctl\t= sunsab_break_ctl,\n\t.startup\t= sunsab_startup,\n\t.shutdown\t= sunsab_shutdown,\n\t.set_termios\t= sunsab_set_termios,\n\t.type\t\t= sunsab_type,\n\t.release_port\t= sunsab_release_port,\n\t.request_port\t= sunsab_request_port,\n\t.config_port\t= sunsab_config_port,\n\t.verify_port\t= sunsab_verify_port,\n};\n\nstatic struct uart_driver sunsab_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"sunsab\",\n\t.dev_name\t\t= \"ttyS\",\n\t.major\t\t\t= TTY_MAJOR,\n};\n\nstatic struct uart_sunsab_port *sunsab_ports;\n\n#ifdef CONFIG_SERIAL_SUNSAB_CONSOLE\n\nstatic void sunsab_console_putchar(struct uart_port *port, unsigned char c)\n{\n\tstruct uart_sunsab_port *up =\n\t\tcontainer_of(port, struct uart_sunsab_port, port);\n\n\tsunsab_tec_wait(up);\n\twriteb(c, &up->regs->w.tic);\n}\n\nstatic void sunsab_console_write(struct console *con, const char *s, unsigned n)\n{\n\tstruct uart_sunsab_port *up = &sunsab_ports[con->index];\n\tunsigned long flags;\n\tint locked = 1;\n\n\tif (up->port.sysrq || oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&up->port.lock, flags);\n\telse\n\t\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tuart_console_write(&up->port, s, n, sunsab_console_putchar);\n\tsunsab_tec_wait(up);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic int sunsab_console_setup(struct console *con, char *options)\n{\n\tstruct uart_sunsab_port *up = &sunsab_ports[con->index];\n\tunsigned long flags;\n\tunsigned int baud, quot;\n\n\t \n\tif (up->port.type != PORT_SUNSAB)\n\t\treturn -EINVAL;\n\n\tprintk(\"Console: ttyS%d (SAB82532)\\n\",\n\t       (sunsab_reg.minor - 64) + con->index);\n\n\tsunserial_console_termios(con, up->port.dev->of_node);\n\n\tswitch (con->cflag & CBAUD) {\n\tcase B150: baud = 150; break;\n\tcase B300: baud = 300; break;\n\tcase B600: baud = 600; break;\n\tcase B1200: baud = 1200; break;\n\tcase B2400: baud = 2400; break;\n\tcase B4800: baud = 4800; break;\n\tdefault: case B9600: baud = 9600; break;\n\tcase B19200: baud = 19200; break;\n\tcase B38400: baud = 38400; break;\n\tcase B57600: baud = 57600; break;\n\tcase B115200: baud = 115200; break;\n\tcase B230400: baud = 230400; break;\n\tcase B460800: baud = 460800; break;\n\t}\n\n\t \n\tspin_lock_init(&up->port.lock);\n\n\t \n\tsunsab_startup(&up->port);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t \n\tup->interrupt_mask0 = SAB82532_IMR0_PERR | SAB82532_IMR0_FERR |\n\t\t\t\tSAB82532_IMR0_PLLA | SAB82532_IMR0_CDSC;\n\twriteb(up->interrupt_mask0, &up->regs->w.imr0);\n\tup->interrupt_mask1 = SAB82532_IMR1_BRKT | SAB82532_IMR1_ALLS |\n\t\t\t\tSAB82532_IMR1_XOFF | SAB82532_IMR1_TIN |\n\t\t\t\tSAB82532_IMR1_CSC | SAB82532_IMR1_XON |\n\t\t\t\tSAB82532_IMR1_XPR;\n\twriteb(up->interrupt_mask1, &up->regs->w.imr1);\n\n\tquot = uart_get_divisor(&up->port, baud);\n\tsunsab_convert_to_sab(up, con->cflag, 0, baud, quot);\n\tsunsab_set_mctrl(&up->port, TIOCM_DTR | TIOCM_RTS);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\t\n\treturn 0;\n}\n\nstatic struct console sunsab_console = {\n\t.name\t=\t\"ttyS\",\n\t.write\t=\tsunsab_console_write,\n\t.device\t=\tuart_console_device,\n\t.setup\t=\tsunsab_console_setup,\n\t.flags\t=\tCON_PRINTBUFFER,\n\t.index\t=\t-1,\n\t.data\t=\t&sunsab_reg,\n};\n\nstatic inline struct console *SUNSAB_CONSOLE(void)\n{\n\treturn &sunsab_console;\n}\n#else\n#define SUNSAB_CONSOLE()\t(NULL)\n#define sunsab_console_init()\tdo { } while (0)\n#endif\n\nstatic int sunsab_init_one(struct uart_sunsab_port *up,\n\t\t\t\t     struct platform_device *op,\n\t\t\t\t     unsigned long offset,\n\t\t\t\t     int line)\n{\n\tup->port.line = line;\n\tup->port.dev = &op->dev;\n\n\tup->port.mapbase = op->resource[0].start + offset;\n\tup->port.membase = of_ioremap(&op->resource[0], offset,\n\t\t\t\t      sizeof(union sab82532_async_regs),\n\t\t\t\t      \"sab\");\n\tif (!up->port.membase)\n\t\treturn -ENOMEM;\n\tup->regs = (union sab82532_async_regs __iomem *) up->port.membase;\n\n\tup->port.irq = op->archdata.irqs[0];\n\n\tup->port.fifosize = SAB82532_XMIT_FIFO_SIZE;\n\tup->port.iotype = UPIO_MEM;\n\tup->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_SUNSAB_CONSOLE);\n\n\twriteb(SAB82532_IPC_IC_ACT_LOW, &up->regs->w.ipc);\n\n\tup->port.ops = &sunsab_pops;\n\tup->port.type = PORT_SUNSAB;\n\tup->port.uartclk = SAB_BASE_BAUD;\n\n\tup->type = readb(&up->regs->r.vstr) & 0x0f;\n\twriteb(~((1 << 1) | (1 << 2) | (1 << 4)), &up->regs->w.pcr);\n\twriteb(0xff, &up->regs->w.pim);\n\tif ((up->port.line & 0x1) == 0) {\n\t\tup->pvr_dsr_bit = (1 << 0);\n\t\tup->pvr_dtr_bit = (1 << 1);\n\t\tup->gis_shift = 2;\n\t} else {\n\t\tup->pvr_dsr_bit = (1 << 3);\n\t\tup->pvr_dtr_bit = (1 << 2);\n\t\tup->gis_shift = 0;\n\t}\n\tup->cached_pvr = (1 << 1) | (1 << 2) | (1 << 4);\n\twriteb(up->cached_pvr, &up->regs->w.pvr);\n\tup->cached_mode = readb(&up->regs->rw.mode);\n\tup->cached_mode |= SAB82532_MODE_FRTS;\n\twriteb(up->cached_mode, &up->regs->rw.mode);\n\tup->cached_mode |= SAB82532_MODE_RTS;\n\twriteb(up->cached_mode, &up->regs->rw.mode);\n\n\tup->tec_timeout = SAB82532_MAX_TEC_TIMEOUT;\n\tup->cec_timeout = SAB82532_MAX_CEC_TIMEOUT;\n\n\treturn 0;\n}\n\nstatic int sab_probe(struct platform_device *op)\n{\n\tstatic int inst;\n\tstruct uart_sunsab_port *up;\n\tint err;\n\n\tup = &sunsab_ports[inst * 2];\n\n\terr = sunsab_init_one(&up[0], op,\n\t\t\t      0,\n\t\t\t      (inst * 2) + 0);\n\tif (err)\n\t\tgoto out;\n\n\terr = sunsab_init_one(&up[1], op,\n\t\t\t      sizeof(union sab82532_async_regs),\n\t\t\t      (inst * 2) + 1);\n\tif (err)\n\t\tgoto out1;\n\n\tsunserial_console_match(SUNSAB_CONSOLE(), op->dev.of_node,\n\t\t\t\t&sunsab_reg, up[0].port.line,\n\t\t\t\tfalse);\n\n\tsunserial_console_match(SUNSAB_CONSOLE(), op->dev.of_node,\n\t\t\t\t&sunsab_reg, up[1].port.line,\n\t\t\t\tfalse);\n\n\terr = uart_add_one_port(&sunsab_reg, &up[0].port);\n\tif (err)\n\t\tgoto out2;\n\n\terr = uart_add_one_port(&sunsab_reg, &up[1].port);\n\tif (err)\n\t\tgoto out3;\n\n\tplatform_set_drvdata(op, &up[0]);\n\n\tinst++;\n\n\treturn 0;\n\nout3:\n\tuart_remove_one_port(&sunsab_reg, &up[0].port);\nout2:\n\tof_iounmap(&op->resource[0],\n\t\t   up[1].port.membase,\n\t\t   sizeof(union sab82532_async_regs));\nout1:\n\tof_iounmap(&op->resource[0],\n\t\t   up[0].port.membase,\n\t\t   sizeof(union sab82532_async_regs));\nout:\n\treturn err;\n}\n\nstatic int sab_remove(struct platform_device *op)\n{\n\tstruct uart_sunsab_port *up = platform_get_drvdata(op);\n\n\tuart_remove_one_port(&sunsab_reg, &up[1].port);\n\tuart_remove_one_port(&sunsab_reg, &up[0].port);\n\tof_iounmap(&op->resource[0],\n\t\t   up[1].port.membase,\n\t\t   sizeof(union sab82532_async_regs));\n\tof_iounmap(&op->resource[0],\n\t\t   up[0].port.membase,\n\t\t   sizeof(union sab82532_async_regs));\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sab_match[] = {\n\t{\n\t\t.name = \"se\",\n\t},\n\t{\n\t\t.name = \"serial\",\n\t\t.compatible = \"sab82532\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sab_match);\n\nstatic struct platform_driver sab_driver = {\n\t.driver = {\n\t\t.name = \"sab\",\n\t\t.of_match_table = sab_match,\n\t},\n\t.probe\t\t= sab_probe,\n\t.remove\t\t= sab_remove,\n};\n\nstatic int __init sunsab_init(void)\n{\n\tstruct device_node *dp;\n\tint err;\n\tint num_channels = 0;\n\n\tfor_each_node_by_name(dp, \"se\")\n\t\tnum_channels += 2;\n\tfor_each_node_by_name(dp, \"serial\") {\n\t\tif (of_device_is_compatible(dp, \"sab82532\"))\n\t\t\tnum_channels += 2;\n\t}\n\n\tif (num_channels) {\n\t\tsunsab_ports = kcalloc(num_channels,\n\t\t\t\t       sizeof(struct uart_sunsab_port),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!sunsab_ports)\n\t\t\treturn -ENOMEM;\n\n\t\terr = sunserial_register_minors(&sunsab_reg, num_channels);\n\t\tif (err) {\n\t\t\tkfree(sunsab_ports);\n\t\t\tsunsab_ports = NULL;\n\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = platform_driver_register(&sab_driver);\n\tif (err) {\n\t\tkfree(sunsab_ports);\n\t\tsunsab_ports = NULL;\n\t}\n\n\treturn err;\n}\n\nstatic void __exit sunsab_exit(void)\n{\n\tplatform_driver_unregister(&sab_driver);\n\tif (sunsab_reg.nr) {\n\t\tsunserial_unregister_minors(&sunsab_reg, sunsab_reg.nr);\n\t}\n\n\tkfree(sunsab_ports);\n\tsunsab_ports = NULL;\n}\n\nmodule_init(sunsab_init);\nmodule_exit(sunsab_exit);\n\nMODULE_AUTHOR(\"Eddie C. Dost and David S. Miller\");\nMODULE_DESCRIPTION(\"Sun SAB82532 serial port driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}