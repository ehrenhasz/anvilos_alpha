{
  "module_name": "icom.c",
  "hash_id": "f9f7a0d78e03e27b35e672642183fe2c03cbc20efc50c7837a59208d6700e934",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/icom.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/termios.h>\n#include <linux/fs.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/serial_reg.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/kref.h>\n#include <linux/firmware.h>\n#include <linux/bitops.h>\n\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n \n\n#define ICOM_DRIVER_NAME \"icom\"\n#define NR_PORTS\t       128\n\nstatic const unsigned int icom_acfg_baud[] = {\n\t300,\n\t600,\n\t900,\n\t1200,\n\t1800,\n\t2400,\n\t3600,\n\t4800,\n\t7200,\n\t9600,\n\t14400,\n\t19200,\n\t28800,\n\t38400,\n\t57600,\n\t76800,\n\t115200,\n\t153600,\n\t230400,\n\t307200,\n\t460800,\n};\n#define BAUD_TABLE_LIMIT\t(ARRAY_SIZE(icom_acfg_baud) - 1)\n\nstruct icom_regs {\n\tu32 control;\t\t \n\tu32 interrupt;\t\t \n\tu32 int_mask;\t\t \n\tu32 int_pri;\t\t \n\tu32 int_reg_b;\t\t \n\tu32 resvd01;\n\tu32 resvd02;\n\tu32 resvd03;\n\tu32 control_2;\t\t \n\tu32 interrupt_2;\t \n\tu32 int_mask_2;\t\t \n\tu32 int_pri_2;\t\t \n\tu32 int_reg_2b;\t\t \n};\n\nstruct func_dram {\n\tu32 reserved[108];\t \n\tu32 RcvStatusAddr;\t \n\tu8 RcvStnAddr;\t\t \n\tu8 IdleState;\t\t \n\tu8 IdleMonitor;\t\t \n\tu8 FlagFillIdleTimer;\t \n\tu32 XmitStatusAddr;\t \n\tu8 StartXmitCmd;\t \n\tu8 HDLCConfigReg;\t \n\tu8 CauseCode;\t\t \n\tu8 xchar;\t\t \n\tu32 reserved3;\t\t \n\tu8 PrevCmdReg;\t\t \n\tu8 CmdReg;\t\t \n\tu8 async_config2;\t \n\tu8 async_config3;\t \n\tu8 dce_resvd[20];\t \n\tu8 dce_resvd21;\t\t \n\tu8 misc_flags;\t\t \n#define V2_HARDWARE     0x40\n#define ICOM_HDW_ACTIVE 0x01\n\tu8 call_length;\t\t \n\tu8 call_length2;\t \n\tu32 call_addr;\t\t \n\tu16 timer_value;\t \n\tu8 timer_command;\t \n\tu8 dce_command;\t\t \n\tu8 dce_cmd_status;\t \n\tu8 x21_r1_ioff;\t\t \n\tu8 x21_r0_ioff;\t\t \n\tu8 x21_ralt_ioff;\t \n\tu8 x21_r1_ion;\t\t \n\tu8 rsvd_ier;\t\t \n\tu8 ier;\t\t\t \n\tu8 isr;\t\t\t \n\tu8 osr;\t\t\t \n\tu8 reset;\t\t \n\tu8 disable;\t\t \n\tu8 sync;\t\t \n\tu8 error_stat;\t\t \n\tu8 cable_id;\t\t \n\tu8 cs_length;\t\t \n\tu8 mac_length;\t\t \n\tu32 cs_load_addr;\t \n\tu32 mac_load_addr;\t \n};\n\n \n#define ICOM_CONTROL_START_A         0x00000008\n#define ICOM_CONTROL_STOP_A          0x00000004\n#define ICOM_CONTROL_START_B         0x00000002\n#define ICOM_CONTROL_STOP_B          0x00000001\n#define ICOM_CONTROL_START_C         0x00000008\n#define ICOM_CONTROL_STOP_C          0x00000004\n#define ICOM_CONTROL_START_D         0x00000002\n#define ICOM_CONTROL_STOP_D          0x00000001\n#define ICOM_IRAM_OFFSET             0x1000\n#define ICOM_IRAM_SIZE               0x0C00\n#define ICOM_DCE_IRAM_OFFSET         0x0A00\n#define ICOM_CABLE_ID_VALID          0x01\n#define ICOM_CABLE_ID_MASK           0xF0\n#define ICOM_DISABLE                 0x80\n#define CMD_XMIT_RCV_ENABLE          0xC0\n#define CMD_XMIT_ENABLE              0x40\n#define CMD_RCV_DISABLE              0x00\n#define CMD_RCV_ENABLE               0x80\n#define CMD_RESTART                  0x01\n#define CMD_HOLD_XMIT                0x02\n#define CMD_SND_BREAK                0x04\n#define RS232_CABLE                  0x06\n#define V24_CABLE                    0x0E\n#define V35_CABLE                    0x0C\n#define V36_CABLE                    0x02\n#define NO_CABLE                     0x00\n#define START_DOWNLOAD               0x80\n#define ICOM_INT_MASK_PRC_A          0x00003FFF\n#define ICOM_INT_MASK_PRC_B          0x3FFF0000\n#define ICOM_INT_MASK_PRC_C          0x00003FFF\n#define ICOM_INT_MASK_PRC_D          0x3FFF0000\n#define INT_RCV_COMPLETED            0x1000\n#define INT_XMIT_COMPLETED           0x2000\n#define INT_IDLE_DETECT              0x0800\n#define INT_RCV_DISABLED             0x0400\n#define INT_XMIT_DISABLED            0x0200\n#define INT_RCV_XMIT_SHUTDOWN        0x0100\n#define INT_FATAL_ERROR              0x0080\n#define INT_CABLE_PULL               0x0020\n#define INT_SIGNAL_CHANGE            0x0010\n#define HDLC_PPP_PURE_ASYNC          0x02\n#define HDLC_FF_FILL                 0x00\n#define HDLC_HDW_FLOW                0x01\n#define START_XMIT                   0x80\n#define ICOM_ACFG_DRIVE1             0x20\n#define ICOM_ACFG_NO_PARITY          0x00\n#define ICOM_ACFG_PARITY_ENAB        0x02\n#define ICOM_ACFG_PARITY_ODD         0x01\n#define ICOM_ACFG_8BPC               0x00\n#define ICOM_ACFG_7BPC               0x04\n#define ICOM_ACFG_6BPC               0x08\n#define ICOM_ACFG_5BPC               0x0C\n#define ICOM_ACFG_1STOP_BIT          0x00\n#define ICOM_ACFG_2STOP_BIT          0x10\n#define ICOM_DTR                     0x80\n#define ICOM_RTS                     0x40\n#define ICOM_RI                      0x08\n#define ICOM_DSR                     0x80\n#define ICOM_DCD                     0x20\n#define ICOM_CTS                     0x40\n\n#define NUM_XBUFFS 1\n#define NUM_RBUFFS 2\n#define RCV_BUFF_SZ 0x0200\n#define XMIT_BUFF_SZ 0x1000\nstruct statusArea {\n     \n\t \n     \n\tstruct xmit_status_area{\n\t\t__le32 leNext;\t \n\t\t__le32 leNextASD;\n\t\t__le32 leBuffer;\t \n\t\t__le16 leLengthASD;\n\t\t__le16 leOffsetASD;\n\t\t__le16 leLength;\t \n\t\t__le16 flags;\n#define SA_FLAGS_DONE           0x0080\t \n#define SA_FLAGS_CONTINUED      0x8000\t \n#define SA_FLAGS_IDLE           0x4000\t \n#define SA_FLAGS_READY_TO_XMIT  0x0800\n#define SA_FLAGS_STAT_MASK      0x007F\n\t} xmit[NUM_XBUFFS];\n\n     \n\t \n     \n\tstruct {\n\t\t__le32 leNext;\t \n\t\t__le32 leNextASD;\n\t\t__le32 leBuffer;\t \n\t\t__le16 WorkingLength;\t \n\t\t__le16 reserv01;\n\t\t__le16 leLength;\t \n\t\t__le16 flags;\n#define SA_FL_RCV_DONE           0x0010\t \n#define SA_FLAGS_OVERRUN         0x0040\n#define SA_FLAGS_PARITY_ERROR    0x0080\n#define SA_FLAGS_FRAME_ERROR     0x0001\n#define SA_FLAGS_FRAME_TRUNC     0x0002\n#define SA_FLAGS_BREAK_DET       0x0004\t \n#define SA_FLAGS_RCV_MASK        0xFFE6\n\t} rcv[NUM_RBUFFS];\n};\n\nstruct icom_adapter;\n\n\n#define ICOM_MAJOR       243\n#define ICOM_MINOR_START 0\n\nstruct icom_port {\n\tstruct uart_port uart_port;\n\tunsigned char cable_id;\n\tunsigned char read_status_mask;\n\tunsigned char ignore_status_mask;\n\tvoid __iomem * int_reg;\n\tstruct icom_regs __iomem *global_reg;\n\tstruct func_dram __iomem *dram;\n\tint port;\n\tstruct statusArea *statStg;\n\tdma_addr_t statStg_pci;\n\t__le32 *xmitRestart;\n\tdma_addr_t xmitRestart_pci;\n\tunsigned char *xmit_buf;\n\tdma_addr_t xmit_buf_pci;\n\tunsigned char *recv_buf;\n\tdma_addr_t recv_buf_pci;\n\tint next_rcv;\n\tint status;\n#define ICOM_PORT_ACTIVE\t1\t \n#define ICOM_PORT_OFF\t\t0\t \n\tstruct icom_adapter *adapter;\n};\n\nstruct icom_adapter {\n\tvoid __iomem * base_addr;\n\tunsigned long base_addr_pci;\n\tstruct pci_dev *pci_dev;\n\tstruct icom_port port_info[4];\n\tint index;\n\tint version;\n#define ADAPTER_V1\t0x0001\n#define ADAPTER_V2\t0x0002\n\tu32 subsystem_id;\n#define FOUR_PORT_MODEL\t\t\t\t0x0252\n#define V2_TWO_PORTS_RVX\t\t\t0x021A\n#define V2_ONE_PORT_RVX_ONE_PORT_IMBED_MDM\t0x0251\n\tint numb_ports;\n\tstruct list_head icom_adapter_entry;\n\tstruct kref kref;\n};\n\n \nextern void iCom_sercons_init(void);\n\nstruct lookup_proc_table {\n\tu32\t__iomem *global_control_reg;\n\tunsigned long\tprocessor_id;\n};\n\nstruct lookup_int_table {\n\tu32\t__iomem *global_int_mask;\n\tunsigned long\tprocessor_id;\n};\n\nstatic inline struct icom_port *to_icom_port(struct uart_port *port)\n{\n\treturn container_of(port, struct icom_port, uart_port);\n}\n\nstatic const struct pci_device_id icom_pci_table[] = {\n\t{\n\t\t.vendor = PCI_VENDOR_ID_IBM,\n\t\t.device = PCI_DEVICE_ID_IBM_ICOM_DEV_ID_1,\n\t\t.subvendor = PCI_ANY_ID,\n\t\t.subdevice = PCI_ANY_ID,\n\t\t.driver_data = ADAPTER_V1,\n\t},\n\t{\n\t\t.vendor = PCI_VENDOR_ID_IBM,\n\t\t.device = PCI_DEVICE_ID_IBM_ICOM_DEV_ID_2,\n\t\t.subvendor = PCI_VENDOR_ID_IBM,\n\t\t.subdevice = PCI_DEVICE_ID_IBM_ICOM_V2_TWO_PORTS_RVX,\n\t\t.driver_data = ADAPTER_V2,\n\t},\n\t{\n\t\t.vendor = PCI_VENDOR_ID_IBM,\n\t\t.device = PCI_DEVICE_ID_IBM_ICOM_DEV_ID_2,\n\t\t.subvendor = PCI_VENDOR_ID_IBM,\n\t\t.subdevice = PCI_DEVICE_ID_IBM_ICOM_V2_ONE_PORT_RVX_ONE_PORT_MDM,\n\t\t.driver_data = ADAPTER_V2,\n\t},\n\t{\n\t\t.vendor = PCI_VENDOR_ID_IBM,\n\t\t.device = PCI_DEVICE_ID_IBM_ICOM_DEV_ID_2,\n\t\t.subvendor = PCI_VENDOR_ID_IBM,\n\t\t.subdevice = PCI_DEVICE_ID_IBM_ICOM_FOUR_PORT_MODEL,\n\t\t.driver_data = ADAPTER_V2,\n\t},\n\t{\n\t\t.vendor = PCI_VENDOR_ID_IBM,\n\t\t.device = PCI_DEVICE_ID_IBM_ICOM_DEV_ID_2,\n\t\t.subvendor = PCI_VENDOR_ID_IBM,\n\t\t.subdevice = PCI_DEVICE_ID_IBM_ICOM_V2_ONE_PORT_RVX_ONE_PORT_MDM_PCIE,\n\t\t.driver_data = ADAPTER_V2,\n\t},\n\t{}\n};\n\nstatic struct lookup_proc_table start_proc[4] = {\n\t{NULL, ICOM_CONTROL_START_A},\n\t{NULL, ICOM_CONTROL_START_B},\n\t{NULL, ICOM_CONTROL_START_C},\n\t{NULL, ICOM_CONTROL_START_D}\n};\n\n\nstatic struct lookup_proc_table stop_proc[4] = {\n\t{NULL, ICOM_CONTROL_STOP_A},\n\t{NULL, ICOM_CONTROL_STOP_B},\n\t{NULL, ICOM_CONTROL_STOP_C},\n\t{NULL, ICOM_CONTROL_STOP_D}\n};\n\nstatic struct lookup_int_table int_mask_tbl[4] = {\n\t{NULL, ICOM_INT_MASK_PRC_A},\n\t{NULL, ICOM_INT_MASK_PRC_B},\n\t{NULL, ICOM_INT_MASK_PRC_C},\n\t{NULL, ICOM_INT_MASK_PRC_D},\n};\n\n\nMODULE_DEVICE_TABLE(pci, icom_pci_table);\n\nstatic LIST_HEAD(icom_adapter_head);\n\n \nstatic DEFINE_SPINLOCK(icom_lock);\n\n#ifdef ICOM_TRACE\nstatic inline void trace(struct icom_port *icom_port, char *trace_pt,\n\t\t\tunsigned long trace_data)\n{\n\tdev_info(&icom_port->adapter->pci_dev->dev, \":%d:%s - %lx\\n\",\n\ticom_port->port, trace_pt, trace_data);\n}\n#else\nstatic inline void trace(struct icom_port *icom_port, char *trace_pt, unsigned long trace_data) {};\n#endif\nstatic void icom_kref_release(struct kref *kref);\n\nstatic void free_port_memory(struct icom_port *icom_port)\n{\n\tstruct pci_dev *dev = icom_port->adapter->pci_dev;\n\n\ttrace(icom_port, \"RET_PORT_MEM\", 0);\n\tif (icom_port->recv_buf) {\n\t\tdma_free_coherent(&dev->dev, 4096, icom_port->recv_buf,\n\t\t\t\t  icom_port->recv_buf_pci);\n\t\ticom_port->recv_buf = NULL;\n\t}\n\tif (icom_port->xmit_buf) {\n\t\tdma_free_coherent(&dev->dev, 4096, icom_port->xmit_buf,\n\t\t\t\t  icom_port->xmit_buf_pci);\n\t\ticom_port->xmit_buf = NULL;\n\t}\n\tif (icom_port->statStg) {\n\t\tdma_free_coherent(&dev->dev, 4096, icom_port->statStg,\n\t\t\t\t  icom_port->statStg_pci);\n\t\ticom_port->statStg = NULL;\n\t}\n\n\tif (icom_port->xmitRestart) {\n\t\tdma_free_coherent(&dev->dev, 4096, icom_port->xmitRestart,\n\t\t\t\t  icom_port->xmitRestart_pci);\n\t\ticom_port->xmitRestart = NULL;\n\t}\n}\n\nstatic int get_port_memory(struct icom_port *icom_port)\n{\n\tint index;\n\tunsigned long stgAddr;\n\tunsigned long startStgAddr;\n\tunsigned long offset;\n\tstruct pci_dev *dev = icom_port->adapter->pci_dev;\n\n\ticom_port->xmit_buf =\n\t    dma_alloc_coherent(&dev->dev, 4096, &icom_port->xmit_buf_pci,\n\t\t\t       GFP_KERNEL);\n\tif (!icom_port->xmit_buf) {\n\t\tdev_err(&dev->dev, \"Can not allocate Transmit buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace(icom_port, \"GET_PORT_MEM\",\n\t      (unsigned long) icom_port->xmit_buf);\n\n\ticom_port->recv_buf =\n\t    dma_alloc_coherent(&dev->dev, 4096, &icom_port->recv_buf_pci,\n\t\t\t       GFP_KERNEL);\n\tif (!icom_port->recv_buf) {\n\t\tdev_err(&dev->dev, \"Can not allocate Receive buffer\\n\");\n\t\tfree_port_memory(icom_port);\n\t\treturn -ENOMEM;\n\t}\n\ttrace(icom_port, \"GET_PORT_MEM\",\n\t      (unsigned long) icom_port->recv_buf);\n\n\ticom_port->statStg =\n\t    dma_alloc_coherent(&dev->dev, 4096, &icom_port->statStg_pci,\n\t\t\t       GFP_KERNEL);\n\tif (!icom_port->statStg) {\n\t\tdev_err(&dev->dev, \"Can not allocate Status buffer\\n\");\n\t\tfree_port_memory(icom_port);\n\t\treturn -ENOMEM;\n\t}\n\ttrace(icom_port, \"GET_PORT_MEM\",\n\t      (unsigned long) icom_port->statStg);\n\n\ticom_port->xmitRestart =\n\t    dma_alloc_coherent(&dev->dev, 4096, &icom_port->xmitRestart_pci,\n\t\t\t       GFP_KERNEL);\n\tif (!icom_port->xmitRestart) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Can not allocate xmit Restart buffer\\n\");\n\t\tfree_port_memory(icom_port);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\n\tstgAddr = (unsigned long) icom_port->statStg;\n\tfor (index = 0; index < NUM_XBUFFS; index++) {\n\t\ttrace(icom_port, \"FOD_ADDR\", stgAddr);\n\t\tstgAddr = stgAddr + sizeof(icom_port->statStg->xmit[0]);\n\t\tif (index < (NUM_XBUFFS - 1)) {\n\t\t\tmemset(&icom_port->statStg->xmit[index], 0, sizeof(struct xmit_status_area));\n\t\t\ticom_port->statStg->xmit[index].leLengthASD =\n\t\t\t    cpu_to_le16(XMIT_BUFF_SZ);\n\t\t\ttrace(icom_port, \"FOD_ADDR\", stgAddr);\n\t\t\ttrace(icom_port, \"FOD_XBUFF\",\n\t\t\t      (unsigned long) icom_port->xmit_buf);\n\t\t\ticom_port->statStg->xmit[index].leBuffer =\n\t\t\t    cpu_to_le32(icom_port->xmit_buf_pci);\n\t\t} else if (index == (NUM_XBUFFS - 1)) {\n\t\t\tmemset(&icom_port->statStg->xmit[index], 0, sizeof(struct xmit_status_area));\n\t\t\ticom_port->statStg->xmit[index].leLengthASD =\n\t\t\t    cpu_to_le16(XMIT_BUFF_SZ);\n\t\t\ttrace(icom_port, \"FOD_XBUFF\",\n\t\t\t      (unsigned long) icom_port->xmit_buf);\n\t\t\ticom_port->statStg->xmit[index].leBuffer =\n\t\t\t    cpu_to_le32(icom_port->xmit_buf_pci);\n\t\t} else {\n\t\t\tmemset(&icom_port->statStg->xmit[index], 0, sizeof(struct xmit_status_area));\n\t\t}\n\t}\n\t \n\tstartStgAddr = stgAddr;\n\n\t \n\tfor (index = 0; index <  NUM_RBUFFS; index++) {\n\t\ttrace(icom_port, \"FID_ADDR\", stgAddr);\n\t\tstgAddr = stgAddr + sizeof(icom_port->statStg->rcv[0]);\n\t\ticom_port->statStg->rcv[index].leLength = 0;\n\t\ticom_port->statStg->rcv[index].WorkingLength =\n\t\t    cpu_to_le16(RCV_BUFF_SZ);\n\t\tif (index < (NUM_RBUFFS - 1) ) {\n\t\t\toffset = stgAddr - (unsigned long) icom_port->statStg;\n\t\t\ticom_port->statStg->rcv[index].leNext =\n\t\t\t      cpu_to_le32(icom_port-> statStg_pci + offset);\n\t\t\ttrace(icom_port, \"FID_RBUFF\",\n\t\t\t      (unsigned long) icom_port->recv_buf);\n\t\t\ticom_port->statStg->rcv[index].leBuffer =\n\t\t\t    cpu_to_le32(icom_port->recv_buf_pci);\n\t\t} else if (index == (NUM_RBUFFS -1) ) {\n\t\t\toffset = startStgAddr - (unsigned long) icom_port->statStg;\n\t\t\ticom_port->statStg->rcv[index].leNext =\n\t\t\t    cpu_to_le32(icom_port-> statStg_pci + offset);\n\t\t\ttrace(icom_port, \"FID_RBUFF\",\n\t\t\t      (unsigned long) icom_port->recv_buf + 2048);\n\t\t\ticom_port->statStg->rcv[index].leBuffer =\n\t\t\t    cpu_to_le32(icom_port->recv_buf_pci + 2048);\n\t\t} else {\n\t\t\ticom_port->statStg->rcv[index].leNext = 0;\n\t\t\ticom_port->statStg->rcv[index].leBuffer = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void stop_processor(struct icom_port *icom_port)\n{\n\tunsigned long temp;\n\tunsigned long flags;\n\tint port;\n\n\tspin_lock_irqsave(&icom_lock, flags);\n\n\tport = icom_port->port;\n\tif (port >= ARRAY_SIZE(stop_proc)) {\n\t\tdev_err(&icom_port->adapter->pci_dev->dev,\n\t\t\t\"Invalid port assignment\\n\");\n\t\tgoto unlock;\n\t}\n\n\tif (port == 0 || port == 1)\n\t\tstop_proc[port].global_control_reg = &icom_port->global_reg->control;\n\telse\n\t\tstop_proc[port].global_control_reg = &icom_port->global_reg->control_2;\n\n\ttemp = readl(stop_proc[port].global_control_reg);\n\ttemp = (temp & ~start_proc[port].processor_id) | stop_proc[port].processor_id;\n\twritel(temp, stop_proc[port].global_control_reg);\n\n\t \n\treadl(stop_proc[port].global_control_reg);\n\nunlock:\n\tspin_unlock_irqrestore(&icom_lock, flags);\n}\n\nstatic void start_processor(struct icom_port *icom_port)\n{\n\tunsigned long temp;\n\tunsigned long flags;\n\tint port;\n\n\tspin_lock_irqsave(&icom_lock, flags);\n\n\tport = icom_port->port;\n\tif (port >= ARRAY_SIZE(start_proc)) {\n\t\tdev_err(&icom_port->adapter->pci_dev->dev,\n\t\t\t\"Invalid port assignment\\n\");\n\t\tgoto unlock;\n\t}\n\n\tif (port == 0 || port == 1)\n\t\tstart_proc[port].global_control_reg = &icom_port->global_reg->control;\n\telse\n\t\tstart_proc[port].global_control_reg = &icom_port->global_reg->control_2;\n\n\ttemp = readl(start_proc[port].global_control_reg);\n\ttemp = (temp & ~stop_proc[port].processor_id) | start_proc[port].processor_id;\n\twritel(temp, start_proc[port].global_control_reg);\n\n\t \n\treadl(start_proc[port].global_control_reg);\n\nunlock:\n\tspin_unlock_irqrestore(&icom_lock, flags);\n}\n\nstatic void load_code(struct icom_port *icom_port)\n{\n\tconst struct firmware *fw;\n\tchar __iomem *iram_ptr;\n\tint index;\n\tint status = 0;\n\tvoid __iomem *dram_ptr = icom_port->dram;\n\tdma_addr_t temp_pci;\n\tunsigned char *new_page = NULL;\n\tunsigned char cable_id = NO_CABLE;\n\tstruct pci_dev *dev = icom_port->adapter->pci_dev;\n\n\t \n\twritew(0x3FFF, icom_port->int_reg);\n\n\ttrace(icom_port, \"CLEAR_INTERRUPTS\", 0);\n\n\t \n\tstop_processor(icom_port);\n\n\t \n\tmemset_io(dram_ptr, 0, 512);\n\n\t \n\tif (request_firmware(&fw, \"icom_call_setup.bin\", &dev->dev) < 0) {\n\t\tdev_err(&dev->dev,\"Unable to load icom_call_setup.bin firmware image\\n\");\n\t\tstatus = -1;\n\t\tgoto load_code_exit;\n\t}\n\n\tif (fw->size > ICOM_DCE_IRAM_OFFSET) {\n\t\tdev_err(&dev->dev, \"Invalid firmware image for icom_call_setup.bin found.\\n\");\n\t\trelease_firmware(fw);\n\t\tstatus = -1;\n\t\tgoto load_code_exit;\n\t}\n\n\tiram_ptr = (char __iomem *)icom_port->dram + ICOM_IRAM_OFFSET;\n\tfor (index = 0; index < fw->size; index++)\n\t\twriteb(fw->data[index], &iram_ptr[index]);\n\n\trelease_firmware(fw);\n\n\t \n\tif (request_firmware(&fw, \"icom_res_dce.bin\", &dev->dev) < 0) {\n\t\tdev_err(&dev->dev,\"Unable to load icom_res_dce.bin firmware image\\n\");\n\t\tstatus = -1;\n\t\tgoto load_code_exit;\n\t}\n\n\tif (fw->size > ICOM_IRAM_SIZE) {\n\t\tdev_err(&dev->dev, \"Invalid firmware image for icom_res_dce.bin found.\\n\");\n\t\trelease_firmware(fw);\n\t\tstatus = -1;\n\t\tgoto load_code_exit;\n\t}\n\n\tiram_ptr = (char __iomem *) icom_port->dram + ICOM_IRAM_OFFSET;\n\tfor (index = ICOM_DCE_IRAM_OFFSET; index < fw->size; index++)\n\t\twriteb(fw->data[index], &iram_ptr[index]);\n\n\trelease_firmware(fw);\n\n\t \n\tif (icom_port->adapter->version == ADAPTER_V2)\n\t\twriteb(V2_HARDWARE, &(icom_port->dram->misc_flags));\n\n\t \n\tstart_processor(icom_port);\n\n\twriteb((HDLC_PPP_PURE_ASYNC | HDLC_FF_FILL),\n\t       &(icom_port->dram->HDLCConfigReg));\n\twriteb(0x04, &(icom_port->dram->FlagFillIdleTimer));\t \n\twriteb(0x00, &(icom_port->dram->CmdReg));\n\twriteb(0x10, &(icom_port->dram->async_config3));\n\twriteb((ICOM_ACFG_DRIVE1 | ICOM_ACFG_NO_PARITY | ICOM_ACFG_8BPC |\n\t\tICOM_ACFG_1STOP_BIT), &(icom_port->dram->async_config2));\n\n\t \n\tnew_page = dma_alloc_coherent(&dev->dev, 4096, &temp_pci, GFP_KERNEL);\n\n\tif (!new_page) {\n\t\tdev_err(&dev->dev, \"Can not allocate DMA buffer\\n\");\n\t\tstatus = -1;\n\t\tgoto load_code_exit;\n\t}\n\n\tif (request_firmware(&fw, \"icom_asc.bin\", &dev->dev) < 0) {\n\t\tdev_err(&dev->dev,\"Unable to load icom_asc.bin firmware image\\n\");\n\t\tstatus = -1;\n\t\tgoto load_code_exit;\n\t}\n\n\tif (fw->size > ICOM_DCE_IRAM_OFFSET) {\n\t\tdev_err(&dev->dev, \"Invalid firmware image for icom_asc.bin found.\\n\");\n\t\trelease_firmware(fw);\n\t\tstatus = -1;\n\t\tgoto load_code_exit;\n\t}\n\n\tfor (index = 0; index < fw->size; index++)\n\t\tnew_page[index] = fw->data[index];\n\n\twriteb((char) ((fw->size + 16)/16), &icom_port->dram->mac_length);\n\twritel(temp_pci, &icom_port->dram->mac_load_addr);\n\n\trelease_firmware(fw);\n\n\t \n\t \n\twriteb(START_DOWNLOAD, &icom_port->dram->sync);\n\n\t \n\tfor (index = 0; index < 10; index++) {\n\t\tmsleep(100);\n\t\tif (readb(&icom_port->dram->misc_flags) & ICOM_HDW_ACTIVE)\n\t\t\tbreak;\n\t}\n\n\tif (index == 10)\n\t\tstatus = -1;\n\n\t \n\tcable_id = readb(&icom_port->dram->cable_id);\n\n\tif (cable_id & ICOM_CABLE_ID_VALID) {\n\t\t \n\t\tcable_id = (cable_id & ICOM_CABLE_ID_MASK) >> 4;\n\t\ticom_port->cable_id = cable_id;\n\t} else {\n\t\tdev_err(&dev->dev,\"Invalid or no cable attached\\n\");\n\t\ticom_port->cable_id = NO_CABLE;\n\t}\n\n      load_code_exit:\n\n\tif (status != 0) {\n\t\t \n\t\twritew(0x3FFF, icom_port->int_reg);\n\n\t\t \n\t\twriteb(ICOM_DISABLE, &(icom_port->dram->disable));\n\n\t\t \n\t\tstop_processor(icom_port);\n\n\t\tdev_err(&icom_port->adapter->pci_dev->dev,\"Port not operational\\n\");\n\t}\n\n\tif (new_page != NULL)\n\t\tdma_free_coherent(&dev->dev, 4096, new_page, temp_pci);\n}\n\nstatic int startup(struct icom_port *icom_port)\n{\n\tunsigned long temp;\n\tunsigned char cable_id, raw_cable_id;\n\tunsigned long flags;\n\tint port;\n\n\ttrace(icom_port, \"STARTUP\", 0);\n\n\tif (!icom_port->dram) {\n\t\t \n\t\tdev_err(&icom_port->adapter->pci_dev->dev,\n\t\t\t\"Unusable Port, port configuration missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\traw_cable_id = readb(&icom_port->dram->cable_id);\n\ttrace(icom_port, \"CABLE_ID\", raw_cable_id);\n\n\t \n\tcable_id = (raw_cable_id & ICOM_CABLE_ID_MASK) >> 4;\n\n\t \n\tif (!(raw_cable_id & ICOM_CABLE_ID_VALID) ||\n\t    (cable_id != icom_port->cable_id)) {\n\n\t\t \n\t\tload_code(icom_port);\n\n\t\t \n\t\traw_cable_id = readb(&icom_port->dram->cable_id);\n\t\tcable_id = (raw_cable_id & ICOM_CABLE_ID_MASK) >> 4;\n\t\tif (!(raw_cable_id & ICOM_CABLE_ID_VALID) ||\n\t\t    (icom_port->cable_id == NO_CABLE))\n\t\t\treturn -EIO;\n\t}\n\n\t \n\tspin_lock_irqsave(&icom_lock, flags);\n\tport = icom_port->port;\n\tif (port >= ARRAY_SIZE(int_mask_tbl)) {\n\t\tdev_err(&icom_port->adapter->pci_dev->dev,\n\t\t\t\"Invalid port assignment\\n\");\n\t\tgoto unlock;\n\t}\n\n\tif (port == 0 || port == 1)\n\t\tint_mask_tbl[port].global_int_mask = &icom_port->global_reg->int_mask;\n\telse\n\t\tint_mask_tbl[port].global_int_mask = &icom_port->global_reg->int_mask_2;\n\n\tif (port == 0 || port == 2)\n\t\twritew(0x00FF, icom_port->int_reg);\n\telse\n\t\twritew(0x3F00, icom_port->int_reg);\n\n\ttemp = readl(int_mask_tbl[port].global_int_mask);\n\twritel(temp & ~int_mask_tbl[port].processor_id, int_mask_tbl[port].global_int_mask);\n\n\t \n\treadl(int_mask_tbl[port].global_int_mask);\n\nunlock:\n\tspin_unlock_irqrestore(&icom_lock, flags);\n\treturn 0;\n}\n\nstatic void shutdown(struct icom_port *icom_port)\n{\n\tunsigned long temp;\n\tunsigned char cmdReg;\n\tunsigned long flags;\n\tint port;\n\n\tspin_lock_irqsave(&icom_lock, flags);\n\ttrace(icom_port, \"SHUTDOWN\", 0);\n\n\t \n\tport = icom_port->port;\n\tif (port >= ARRAY_SIZE(int_mask_tbl)) {\n\t\tdev_err(&icom_port->adapter->pci_dev->dev,\n\t\t\t\"Invalid port assignment\\n\");\n\t\tgoto unlock;\n\t}\n\tif (port == 0 || port == 1)\n\t\tint_mask_tbl[port].global_int_mask = &icom_port->global_reg->int_mask;\n\telse\n\t\tint_mask_tbl[port].global_int_mask = &icom_port->global_reg->int_mask_2;\n\n\ttemp = readl(int_mask_tbl[port].global_int_mask);\n\twritel(temp | int_mask_tbl[port].processor_id, int_mask_tbl[port].global_int_mask);\n\n\t \n\treadl(int_mask_tbl[port].global_int_mask);\n\nunlock:\n\tspin_unlock_irqrestore(&icom_lock, flags);\n\n\t \n\tcmdReg = readb(&icom_port->dram->CmdReg);\n\tif (cmdReg & CMD_SND_BREAK) {\n\t\twriteb(cmdReg & ~CMD_SND_BREAK, &icom_port->dram->CmdReg);\n\t}\n}\n\nstatic int icom_write(struct uart_port *port)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tunsigned long data_count;\n\tunsigned char cmdReg;\n\tunsigned long offset;\n\tint temp_tail = port->state->xmit.tail;\n\n\ttrace(icom_port, \"WRITE\", 0);\n\n\tif (le16_to_cpu(icom_port->statStg->xmit[0].flags) &\n\t    SA_FLAGS_READY_TO_XMIT) {\n\t\ttrace(icom_port, \"WRITE_FULL\", 0);\n\t\treturn 0;\n\t}\n\n\tdata_count = 0;\n\twhile ((port->state->xmit.head != temp_tail) &&\n\t       (data_count <= XMIT_BUFF_SZ)) {\n\n\t\ticom_port->xmit_buf[data_count++] =\n\t\t    port->state->xmit.buf[temp_tail];\n\n\t\ttemp_tail++;\n\t\ttemp_tail &= (UART_XMIT_SIZE - 1);\n\t}\n\n\tif (data_count) {\n\t\ticom_port->statStg->xmit[0].flags =\n\t\t    cpu_to_le16(SA_FLAGS_READY_TO_XMIT);\n\t\ticom_port->statStg->xmit[0].leLength =\n\t\t    cpu_to_le16(data_count);\n\t\toffset =\n\t\t    (unsigned long) &icom_port->statStg->xmit[0] -\n\t\t    (unsigned long) icom_port->statStg;\n\t\t*icom_port->xmitRestart =\n\t\t    cpu_to_le32(icom_port->statStg_pci + offset);\n\t\tcmdReg = readb(&icom_port->dram->CmdReg);\n\t\twriteb(cmdReg | CMD_XMIT_RCV_ENABLE,\n\t\t       &icom_port->dram->CmdReg);\n\t\twriteb(START_XMIT, &icom_port->dram->StartXmitCmd);\n\t\ttrace(icom_port, \"WRITE_START\", data_count);\n\t\t \n\t\treadb(&icom_port->dram->StartXmitCmd);\n\t}\n\n\treturn data_count;\n}\n\nstatic inline void check_modem_status(struct icom_port *icom_port)\n{\n\tstatic char old_status = 0;\n\tchar delta_status;\n\tunsigned char status;\n\n\tspin_lock(&icom_port->uart_port.lock);\n\n\t \n\tstatus = readb(&icom_port->dram->isr);\n\ttrace(icom_port, \"CHECK_MODEM\", status);\n\tdelta_status = status ^ old_status;\n\tif (delta_status) {\n\t\tif (delta_status & ICOM_RI)\n\t\t\ticom_port->uart_port.icount.rng++;\n\t\tif (delta_status & ICOM_DSR)\n\t\t\ticom_port->uart_port.icount.dsr++;\n\t\tif (delta_status & ICOM_DCD)\n\t\t\tuart_handle_dcd_change(&icom_port->uart_port,\n\t\t\t\t\t       delta_status & ICOM_DCD);\n\t\tif (delta_status & ICOM_CTS)\n\t\t\tuart_handle_cts_change(&icom_port->uart_port,\n\t\t\t\t\t       delta_status & ICOM_CTS);\n\n\t\twake_up_interruptible(&icom_port->uart_port.state->\n\t\t\t\t      port.delta_msr_wait);\n\t\told_status = status;\n\t}\n\tspin_unlock(&icom_port->uart_port.lock);\n}\n\nstatic void xmit_interrupt(u16 port_int_reg, struct icom_port *icom_port)\n{\n\tu16 count, i;\n\n\tif (port_int_reg & (INT_XMIT_COMPLETED)) {\n\t\ttrace(icom_port, \"XMIT_COMPLETE\", 0);\n\n\t\t \n\t\ticom_port->statStg->xmit[0].flags &=\n\t\t\tcpu_to_le16(~SA_FLAGS_READY_TO_XMIT);\n\n\t\tcount = le16_to_cpu(icom_port->statStg->xmit[0].leLength);\n\t\ticom_port->uart_port.icount.tx += count;\n\n\t\tfor (i=0; i<count &&\n\t\t\t!uart_circ_empty(&icom_port->uart_port.state->xmit); i++) {\n\n\t\t\ticom_port->uart_port.state->xmit.tail++;\n\t\t\ticom_port->uart_port.state->xmit.tail &=\n\t\t\t\t(UART_XMIT_SIZE - 1);\n\t\t}\n\n\t\tif (!icom_write(&icom_port->uart_port))\n\t\t\t \n\t\t\tuart_write_wakeup(&icom_port->uart_port);\n\t} else\n\t\ttrace(icom_port, \"XMIT_DISABLED\", 0);\n}\n\nstatic void recv_interrupt(u16 port_int_reg, struct icom_port *icom_port)\n{\n\tshort int count, rcv_buff;\n\tstruct tty_port *port = &icom_port->uart_port.state->port;\n\tu16 status;\n\tstruct uart_icount *icount;\n\tunsigned long offset;\n\tunsigned char flag;\n\n\ttrace(icom_port, \"RCV_COMPLETE\", 0);\n\trcv_buff = icom_port->next_rcv;\n\n\tstatus = le16_to_cpu(icom_port->statStg->rcv[rcv_buff].flags);\n\twhile (status & SA_FL_RCV_DONE) {\n\t\tint first = -1;\n\n\t\ttrace(icom_port, \"FID_STATUS\", status);\n\t\tcount = le16_to_cpu(icom_port->statStg->rcv[rcv_buff].leLength);\n\n\t\ttrace(icom_port, \"RCV_COUNT\", count);\n\n\t\ttrace(icom_port, \"REAL_COUNT\", count);\n\n\t\toffset = le32_to_cpu(icom_port->statStg->rcv[rcv_buff].leBuffer) -\n\t\t\ticom_port->recv_buf_pci;\n\n\t\t \n\t\tif (count > 0) {\n\t\t\tfirst = icom_port->recv_buf[offset];\n\t\t\ttty_insert_flip_string(port, icom_port->recv_buf + offset, count - 1);\n\t\t}\n\n\t\ticount = &icom_port->uart_port.icount;\n\t\ticount->rx += count;\n\n\t\t \n\t\tif ((status & SA_FLAGS_FRAME_ERROR)\n\t\t    && first == 0) {\n\t\t\tstatus &= ~SA_FLAGS_FRAME_ERROR;\n\t\t\tstatus |= SA_FLAGS_BREAK_DET;\n\t\t\ttrace(icom_port, \"BREAK_DET\", 0);\n\t\t}\n\n\t\tflag = TTY_NORMAL;\n\n\t\tif (status &\n\t\t    (SA_FLAGS_BREAK_DET | SA_FLAGS_PARITY_ERROR |\n\t\t     SA_FLAGS_FRAME_ERROR | SA_FLAGS_OVERRUN)) {\n\n\t\t\tif (status & SA_FLAGS_BREAK_DET)\n\t\t\t\ticount->brk++;\n\t\t\tif (status & SA_FLAGS_PARITY_ERROR)\n\t\t\t\ticount->parity++;\n\t\t\tif (status & SA_FLAGS_FRAME_ERROR)\n\t\t\t\ticount->frame++;\n\t\t\tif (status & SA_FLAGS_OVERRUN)\n\t\t\t\ticount->overrun++;\n\n\t\t\t \n\t\t\tif (status & icom_port->ignore_status_mask) {\n\t\t\t\ttrace(icom_port, \"IGNORE_CHAR\", 0);\n\t\t\t\tgoto ignore_char;\n\t\t\t}\n\n\t\t\tstatus &= icom_port->read_status_mask;\n\n\t\t\tif (status & SA_FLAGS_BREAK_DET) {\n\t\t\t\tflag = TTY_BREAK;\n\t\t\t} else if (status & SA_FLAGS_PARITY_ERROR) {\n\t\t\t\ttrace(icom_port, \"PARITY_ERROR\", 0);\n\t\t\t\tflag = TTY_PARITY;\n\t\t\t} else if (status & SA_FLAGS_FRAME_ERROR)\n\t\t\t\tflag = TTY_FRAME;\n\n\t\t}\n\n\t\ttty_insert_flip_char(port, *(icom_port->recv_buf + offset + count - 1), flag);\n\n\t\tif (status & SA_FLAGS_OVERRUN)\n\t\t\t \n\t\t\ttty_insert_flip_char(port, 0, TTY_OVERRUN);\nignore_char:\n\t\ticom_port->statStg->rcv[rcv_buff].flags = 0;\n\t\ticom_port->statStg->rcv[rcv_buff].leLength = 0;\n\t\ticom_port->statStg->rcv[rcv_buff].WorkingLength =\n\t\t\tcpu_to_le16(RCV_BUFF_SZ);\n\n\t\trcv_buff++;\n\t\tif (rcv_buff == NUM_RBUFFS)\n\t\t\trcv_buff = 0;\n\n\t\tstatus = le16_to_cpu(icom_port->statStg->rcv[rcv_buff].flags);\n\t}\n\ticom_port->next_rcv = rcv_buff;\n\n\ttty_flip_buffer_push(port);\n}\n\nstatic void process_interrupt(u16 port_int_reg,\n\t\t\t      struct icom_port *icom_port)\n{\n\n\tspin_lock(&icom_port->uart_port.lock);\n\ttrace(icom_port, \"INTERRUPT\", port_int_reg);\n\n\tif (port_int_reg & (INT_XMIT_COMPLETED | INT_XMIT_DISABLED))\n\t\txmit_interrupt(port_int_reg, icom_port);\n\n\tif (port_int_reg & INT_RCV_COMPLETED)\n\t\trecv_interrupt(port_int_reg, icom_port);\n\n\tspin_unlock(&icom_port->uart_port.lock);\n}\n\nstatic irqreturn_t icom_interrupt(int irq, void *dev_id)\n{\n\tvoid __iomem * int_reg;\n\tu32 adapter_interrupts;\n\tu16 port_int_reg;\n\tstruct icom_adapter *icom_adapter;\n\tstruct icom_port *icom_port;\n\n\t \n\ticom_adapter = (struct icom_adapter *) dev_id;\n\n\tif (icom_adapter->version == ADAPTER_V2) {\n\t\tint_reg = icom_adapter->base_addr + 0x8024;\n\n\t\tadapter_interrupts = readl(int_reg);\n\n\t\tif (adapter_interrupts & 0x00003FFF) {\n\t\t\t \n\t\t\ticom_port = &icom_adapter->port_info[2];\n\t\t\tport_int_reg = (u16) adapter_interrupts;\n\t\t\tprocess_interrupt(port_int_reg, icom_port);\n\t\t\tcheck_modem_status(icom_port);\n\t\t}\n\t\tif (adapter_interrupts & 0x3FFF0000) {\n\t\t\t \n\t\t\ticom_port = &icom_adapter->port_info[3];\n\t\t\tif (icom_port->status == ICOM_PORT_ACTIVE) {\n\t\t\t\tport_int_reg =\n\t\t\t\t    (u16) (adapter_interrupts >> 16);\n\t\t\t\tprocess_interrupt(port_int_reg, icom_port);\n\t\t\t\tcheck_modem_status(icom_port);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twritel(adapter_interrupts, int_reg);\n\n\t\tint_reg = icom_adapter->base_addr + 0x8004;\n\t} else {\n\t\tint_reg = icom_adapter->base_addr + 0x4004;\n\t}\n\n\tadapter_interrupts = readl(int_reg);\n\n\tif (adapter_interrupts & 0x00003FFF) {\n\t\t \n\t\ticom_port = &icom_adapter->port_info[0];\n\t\tport_int_reg = (u16) adapter_interrupts;\n\t\tprocess_interrupt(port_int_reg, icom_port);\n\t\tcheck_modem_status(icom_port);\n\t}\n\tif (adapter_interrupts & 0x3FFF0000) {\n\t\t \n\t\ticom_port = &icom_adapter->port_info[1];\n\t\tif (icom_port->status == ICOM_PORT_ACTIVE) {\n\t\t\tport_int_reg = (u16) (adapter_interrupts >> 16);\n\t\t\tprocess_interrupt(port_int_reg, icom_port);\n\t\t\tcheck_modem_status(icom_port);\n\t\t}\n\t}\n\n\t \n\twritel(adapter_interrupts, int_reg);\n\n\t \n\tadapter_interrupts = readl(int_reg);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic unsigned int icom_tx_empty(struct uart_port *port)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (le16_to_cpu(icom_port->statStg->xmit[0].flags) &\n\t    SA_FLAGS_READY_TO_XMIT)\n\t\tret = TIOCSER_TEMT;\n\telse\n\t\tret = 0;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\treturn ret;\n}\n\nstatic void icom_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tunsigned char local_osr;\n\n\ttrace(icom_port, \"SET_MODEM\", 0);\n\tlocal_osr = readb(&icom_port->dram->osr);\n\n\tif (mctrl & TIOCM_RTS) {\n\t\ttrace(icom_port, \"RAISE_RTS\", 0);\n\t\tlocal_osr |= ICOM_RTS;\n\t} else {\n\t\ttrace(icom_port, \"LOWER_RTS\", 0);\n\t\tlocal_osr &= ~ICOM_RTS;\n\t}\n\n\tif (mctrl & TIOCM_DTR) {\n\t\ttrace(icom_port, \"RAISE_DTR\", 0);\n\t\tlocal_osr |= ICOM_DTR;\n\t} else {\n\t\ttrace(icom_port, \"LOWER_DTR\", 0);\n\t\tlocal_osr &= ~ICOM_DTR;\n\t}\n\n\twriteb(local_osr, &icom_port->dram->osr);\n}\n\nstatic unsigned int icom_get_mctrl(struct uart_port *port)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tunsigned char status;\n\tunsigned int result;\n\n\ttrace(icom_port, \"GET_MODEM\", 0);\n\n\tstatus = readb(&icom_port->dram->isr);\n\n\tresult = ((status & ICOM_DCD) ? TIOCM_CAR : 0)\n\t    | ((status & ICOM_RI) ? TIOCM_RNG : 0)\n\t    | ((status & ICOM_DSR) ? TIOCM_DSR : 0)\n\t    | ((status & ICOM_CTS) ? TIOCM_CTS : 0);\n\treturn result;\n}\n\nstatic void icom_stop_tx(struct uart_port *port)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tunsigned char cmdReg;\n\n\ttrace(icom_port, \"STOP\", 0);\n\tcmdReg = readb(&icom_port->dram->CmdReg);\n\twriteb(cmdReg | CMD_HOLD_XMIT, &icom_port->dram->CmdReg);\n}\n\nstatic void icom_start_tx(struct uart_port *port)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tunsigned char cmdReg;\n\n\ttrace(icom_port, \"START\", 0);\n\tcmdReg = readb(&icom_port->dram->CmdReg);\n\tif ((cmdReg & CMD_HOLD_XMIT) == CMD_HOLD_XMIT)\n\t\twriteb(cmdReg & ~CMD_HOLD_XMIT,\n\t\t       &icom_port->dram->CmdReg);\n\n\ticom_write(port);\n}\n\nstatic void icom_send_xchar(struct uart_port *port, char ch)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tunsigned char xdata;\n\tint index;\n\tunsigned long flags;\n\n\ttrace(icom_port, \"SEND_XCHAR\", ch);\n\n\t \n\tfor (index = 0; index < 10; index++) {\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\txdata = readb(&icom_port->dram->xchar);\n\t\tif (xdata == 0x00) {\n\t\t\ttrace(icom_port, \"QUICK_WRITE\", 0);\n\t\t\twriteb(ch, &icom_port->dram->xchar);\n\n\t\t\t \n\t\t\txdata = readb(&icom_port->dram->xchar);\n\t\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tmsleep(10);\n\t}\n}\n\nstatic void icom_stop_rx(struct uart_port *port)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tunsigned char cmdReg;\n\n\tcmdReg = readb(&icom_port->dram->CmdReg);\n\twriteb(cmdReg & ~CMD_RCV_ENABLE, &icom_port->dram->CmdReg);\n}\n\nstatic void icom_break(struct uart_port *port, int break_state)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tunsigned char cmdReg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\ttrace(icom_port, \"BREAK\", 0);\n\tcmdReg = readb(&icom_port->dram->CmdReg);\n\tif (break_state == -1) {\n\t\twriteb(cmdReg | CMD_SND_BREAK, &icom_port->dram->CmdReg);\n\t} else {\n\t\twriteb(cmdReg & ~CMD_SND_BREAK, &icom_port->dram->CmdReg);\n\t}\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int icom_open(struct uart_port *port)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tint retval;\n\n\tkref_get(&icom_port->adapter->kref);\n\tretval = startup(icom_port);\n\n\tif (retval) {\n\t\tkref_put(&icom_port->adapter->kref, icom_kref_release);\n\t\ttrace(icom_port, \"STARTUP_ERROR\", 0);\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\nstatic void icom_close(struct uart_port *port)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tunsigned char cmdReg;\n\n\ttrace(icom_port, \"CLOSE\", 0);\n\n\t \n\tcmdReg = readb(&icom_port->dram->CmdReg);\n\twriteb(cmdReg & ~CMD_RCV_ENABLE, &icom_port->dram->CmdReg);\n\n\tshutdown(icom_port);\n\n\tkref_put(&icom_port->adapter->kref, icom_kref_release);\n}\n\nstatic void icom_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t\t     const struct ktermios *old_termios)\n{\n\tstruct icom_port *icom_port = to_icom_port(port);\n\tint baud;\n\tunsigned cflag, iflag;\n\tchar new_config2;\n\tchar new_config3 = 0;\n\tchar tmp_byte;\n\tint index;\n\tint rcv_buff, xmit_buff;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\ttrace(icom_port, \"CHANGE_SPEED\", 0);\n\n\tcflag = termios->c_cflag;\n\tiflag = termios->c_iflag;\n\n\tnew_config2 = ICOM_ACFG_DRIVE1;\n\n\t \n\tswitch (cflag & CSIZE) {\n\tcase CS5:\t\t \n\t\tnew_config2 |= ICOM_ACFG_5BPC;\n\t\tbreak;\n\tcase CS6:\t\t \n\t\tnew_config2 |= ICOM_ACFG_6BPC;\n\t\tbreak;\n\tcase CS7:\t\t \n\t\tnew_config2 |= ICOM_ACFG_7BPC;\n\t\tbreak;\n\tcase CS8:\t\t \n\t\tnew_config2 |= ICOM_ACFG_8BPC;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (cflag & CSTOPB) {\n\t\t \n\t\tnew_config2 |= ICOM_ACFG_2STOP_BIT;\n\t}\n\tif (cflag & PARENB) {\n\t\t \n\t\tnew_config2 |= ICOM_ACFG_PARITY_ENAB;\n\t\ttrace(icom_port, \"PARENB\", 0);\n\t}\n\tif (cflag & PARODD) {\n\t\t \n\t\tnew_config2 |= ICOM_ACFG_PARITY_ODD;\n\t\ttrace(icom_port, \"PARODD\", 0);\n\t}\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old_termios,\n\t\t\t\t  icom_acfg_baud[0],\n\t\t\t\t  icom_acfg_baud[BAUD_TABLE_LIMIT]);\n\tif (!baud)\n\t\tbaud = 9600;\t \n\n\tfor (index = 0; index < BAUD_TABLE_LIMIT; index++) {\n\t\tif (icom_acfg_baud[index] == baud) {\n\t\t\tnew_config3 = index;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tuart_update_timeout(port, cflag, baud);\n\n\t \n\ttmp_byte = readb(&(icom_port->dram->HDLCConfigReg));\n\tif (cflag & CRTSCTS)\n\t\ttmp_byte |= HDLC_HDW_FLOW;\n\telse\n\t\ttmp_byte &= ~HDLC_HDW_FLOW;\n\twriteb(tmp_byte, &(icom_port->dram->HDLCConfigReg));\n\n\t \n\ticom_port->read_status_mask = SA_FLAGS_OVERRUN | SA_FL_RCV_DONE;\n\tif (iflag & INPCK)\n\t\ticom_port->read_status_mask |=\n\t\t    SA_FLAGS_FRAME_ERROR | SA_FLAGS_PARITY_ERROR;\n\n\tif ((iflag & BRKINT) || (iflag & PARMRK))\n\t\ticom_port->read_status_mask |= SA_FLAGS_BREAK_DET;\n\n\t \n\ticom_port->ignore_status_mask = 0;\n\tif (iflag & IGNPAR)\n\t\ticom_port->ignore_status_mask |=\n\t\t    SA_FLAGS_PARITY_ERROR | SA_FLAGS_FRAME_ERROR;\n\tif (iflag & IGNBRK) {\n\t\ticom_port->ignore_status_mask |= SA_FLAGS_BREAK_DET;\n\t\t \n\t\tif (iflag & IGNPAR)\n\t\t\ticom_port->ignore_status_mask |= SA_FLAGS_OVERRUN;\n\t}\n\n\t \n\tif ((cflag & CREAD) == 0)\n\t\ticom_port->ignore_status_mask |= SA_FL_RCV_DONE;\n\n\t \n\twriteb(CMD_RCV_DISABLE, &icom_port->dram->CmdReg);\n\n\tfor (index = 0; index < 10; index++) {\n\t\tif (readb(&icom_port->dram->PrevCmdReg) == 0x00) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (rcv_buff = 0; rcv_buff < NUM_RBUFFS; rcv_buff++) {\n\t\ticom_port->statStg->rcv[rcv_buff].flags = 0;\n\t\ticom_port->statStg->rcv[rcv_buff].leLength = 0;\n\t\ticom_port->statStg->rcv[rcv_buff].WorkingLength =\n\t\t    cpu_to_le16(RCV_BUFF_SZ);\n\t}\n\n\tfor (xmit_buff = 0; xmit_buff < NUM_XBUFFS; xmit_buff++) {\n\t\ticom_port->statStg->xmit[xmit_buff].flags = 0;\n\t}\n\n\t \n\t \n\twriteb(new_config3, &(icom_port->dram->async_config3));\n\twriteb(new_config2, &(icom_port->dram->async_config2));\n\ttmp_byte = readb(&(icom_port->dram->HDLCConfigReg));\n\ttmp_byte |= HDLC_PPP_PURE_ASYNC | HDLC_FF_FILL;\n\twriteb(tmp_byte, &(icom_port->dram->HDLCConfigReg));\n\twriteb(0x04, &(icom_port->dram->FlagFillIdleTimer));\t \n\twriteb(0xFF, &(icom_port->dram->ier));\t \n\n\t \n\twriteb(CMD_RESTART, &icom_port->dram->CmdReg);\n\n\tfor (index = 0; index < 10; index++) {\n\t\tif (readb(&icom_port->dram->CmdReg) == 0x00) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\toffset =\n\t    (unsigned long) &icom_port->statStg->rcv[0] -\n\t    (unsigned long) icom_port->statStg;\n\twritel(icom_port->statStg_pci + offset,\n\t       &icom_port->dram->RcvStatusAddr);\n\ticom_port->next_rcv = 0;\n\t*icom_port->xmitRestart = 0;\n\twritel(icom_port->xmitRestart_pci,\n\t       &icom_port->dram->XmitStatusAddr);\n\ttrace(icom_port, \"XR_ENAB\", 0);\n\twriteb(CMD_XMIT_RCV_ENABLE, &icom_port->dram->CmdReg);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *icom_type(struct uart_port *port)\n{\n\treturn \"icom\";\n}\n\nstatic void icom_config_port(struct uart_port *port, int flags)\n{\n\tport->type = PORT_ICOM;\n}\n\nstatic const struct uart_ops icom_ops = {\n\t.tx_empty = icom_tx_empty,\n\t.set_mctrl = icom_set_mctrl,\n\t.get_mctrl = icom_get_mctrl,\n\t.stop_tx = icom_stop_tx,\n\t.start_tx = icom_start_tx,\n\t.send_xchar = icom_send_xchar,\n\t.stop_rx = icom_stop_rx,\n\t.break_ctl = icom_break,\n\t.startup = icom_open,\n\t.shutdown = icom_close,\n\t.set_termios = icom_set_termios,\n\t.type = icom_type,\n\t.config_port = icom_config_port,\n};\n\n#define ICOM_CONSOLE NULL\n\nstatic struct uart_driver icom_uart_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = ICOM_DRIVER_NAME,\n\t.dev_name = \"ttyA\",\n\t.major = ICOM_MAJOR,\n\t.minor = ICOM_MINOR_START,\n\t.nr = NR_PORTS,\n\t.cons = ICOM_CONSOLE,\n};\n\nstatic int icom_init_ports(struct icom_adapter *icom_adapter)\n{\n\tu32 subsystem_id = icom_adapter->subsystem_id;\n\tint i;\n\tstruct icom_port *icom_port;\n\n\tif (icom_adapter->version == ADAPTER_V1) {\n\t\ticom_adapter->numb_ports = 2;\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\ticom_port = &icom_adapter->port_info[i];\n\t\t\ticom_port->port = i;\n\t\t\ticom_port->status = ICOM_PORT_ACTIVE;\n\t\t}\n\t} else {\n\t\tif (subsystem_id == PCI_DEVICE_ID_IBM_ICOM_FOUR_PORT_MODEL) {\n\t\t\ticom_adapter->numb_ports = 4;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\ticom_port = &icom_adapter->port_info[i];\n\n\t\t\t\ticom_port->port = i;\n\t\t\t\ticom_port->status = ICOM_PORT_ACTIVE;\n\t\t\t}\n\t\t} else {\n\t\t\ticom_adapter->numb_ports = 4;\n\n\t\t\ticom_adapter->port_info[0].port = 0;\n\t\t\ticom_adapter->port_info[0].status = ICOM_PORT_ACTIVE;\n\t\t\ticom_adapter->port_info[1].status = ICOM_PORT_OFF;\n\t\t\ticom_adapter->port_info[2].port = 2;\n\t\t\ticom_adapter->port_info[2].status = ICOM_PORT_ACTIVE;\n\t\t\ticom_adapter->port_info[3].status = ICOM_PORT_OFF;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void icom_port_active(struct icom_port *icom_port, struct icom_adapter *icom_adapter, int port_num)\n{\n\tif (icom_adapter->version == ADAPTER_V1) {\n\t\ticom_port->global_reg = icom_adapter->base_addr + 0x4000;\n\t\ticom_port->int_reg = icom_adapter->base_addr +\n\t\t    0x4004 + 2 - 2 * port_num;\n\t} else {\n\t\ticom_port->global_reg = icom_adapter->base_addr + 0x8000;\n\t\tif (icom_port->port < 2)\n\t\t\ticom_port->int_reg = icom_adapter->base_addr +\n\t\t\t    0x8004 + 2 - 2 * icom_port->port;\n\t\telse\n\t\t\ticom_port->int_reg = icom_adapter->base_addr +\n\t\t\t    0x8024 + 2 - 2 * (icom_port->port - 2);\n\t}\n}\nstatic int icom_load_ports(struct icom_adapter *icom_adapter)\n{\n\tstruct icom_port *icom_port;\n\tint port_num;\n\n\tfor (port_num = 0; port_num < icom_adapter->numb_ports; port_num++) {\n\n\t\ticom_port = &icom_adapter->port_info[port_num];\n\n\t\tif (icom_port->status == ICOM_PORT_ACTIVE) {\n\t\t\ticom_port_active(icom_port, icom_adapter, port_num);\n\t\t\ticom_port->dram = icom_adapter->base_addr +\n\t\t\t\t\t0x2000 * icom_port->port;\n\n\t\t\ticom_port->adapter = icom_adapter;\n\n\t\t\t \n\t\t\tif (get_port_memory(icom_port) != 0) {\n\t\t\t\tdev_err(&icom_port->adapter->pci_dev->dev,\n\t\t\t\t\t\"Memory allocation for port FAILED\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int icom_alloc_adapter(struct icom_adapter\n\t\t\t\t\t**icom_adapter_ref)\n{\n\tint adapter_count = 0;\n\tstruct icom_adapter *icom_adapter;\n\tstruct icom_adapter *cur_adapter_entry;\n\n\ticom_adapter = kzalloc(sizeof(struct icom_adapter), GFP_KERNEL);\n\n\tif (!icom_adapter) {\n\t\treturn -ENOMEM;\n\t}\n\n\tlist_for_each_entry(cur_adapter_entry, &icom_adapter_head,\n\t\t\ticom_adapter_entry) {\n\t\tif (cur_adapter_entry->index != adapter_count) {\n\t\t\tbreak;\n\t\t}\n\t\tadapter_count++;\n\t}\n\n\ticom_adapter->index = adapter_count;\n\tlist_add_tail(&icom_adapter->icom_adapter_entry,\n\t\t\t&cur_adapter_entry->icom_adapter_entry);\n\n\t*icom_adapter_ref = icom_adapter;\n\treturn 0;\n}\n\nstatic void icom_free_adapter(struct icom_adapter *icom_adapter)\n{\n\tlist_del(&icom_adapter->icom_adapter_entry);\n\tkfree(icom_adapter);\n}\n\nstatic void icom_kref_release(struct kref *kref)\n{\n\tstruct icom_adapter *icom_adapter = container_of(kref,\n\t\t\tstruct icom_adapter, kref);\n\tstruct icom_port *icom_port;\n\tint index;\n\n\tfor (index = 0; index < icom_adapter->numb_ports; index++) {\n\t\ticom_port = &icom_adapter->port_info[index];\n\n\t\tif (icom_port->status == ICOM_PORT_ACTIVE) {\n\t\t\tdev_info(&icom_adapter->pci_dev->dev,\n\t\t\t\t \"Device removed\\n\");\n\n\t\t\tuart_remove_one_port(&icom_uart_driver,\n\t\t\t\t\t     &icom_port->uart_port);\n\n\t\t\t \n\t\t\twriteb(0x00, &icom_port->dram->osr);\n\n\t\t\t \n\t\t\tmsleep(100);\n\n\t\t\t \n\t\t\tstop_processor(icom_port);\n\n\t\t\tfree_port_memory(icom_port);\n\t\t}\n\t}\n\n\tfree_irq(icom_adapter->pci_dev->irq, (void *) icom_adapter);\n\tiounmap(icom_adapter->base_addr);\n\tpci_release_regions(icom_adapter->pci_dev);\n\ticom_free_adapter(icom_adapter);\n}\n\nstatic int icom_probe(struct pci_dev *dev,\n\t\t\t\tconst struct pci_device_id *ent)\n{\n\tint index;\n\tunsigned int command_reg;\n\tint retval;\n\tstruct icom_adapter *icom_adapter;\n\tstruct icom_port *icom_port;\n\n\tretval = pci_enable_device(dev);\n\tif (retval) {\n\t\tdev_err(&dev->dev, \"Device enable FAILED\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = pci_request_regions(dev, \"icom\");\n\tif (retval) {\n\t\t dev_err(&dev->dev, \"pci_request_regions FAILED\\n\");\n\t\t pci_disable_device(dev);\n\t\t return retval;\n\t }\n\n\tpci_set_master(dev);\n\n\tretval = pci_read_config_dword(dev, PCI_COMMAND, &command_reg);\n\tif (retval) {\n\t\tdev_err(&dev->dev, \"PCI Config read FAILED\\n\");\n\t\tgoto probe_exit0;\n\t}\n\n\tpci_write_config_dword(dev, PCI_COMMAND,\n\t\tcommand_reg | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER\n \t\t| PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\n\n\tif (ent->driver_data == ADAPTER_V1) {\n\t\tpci_write_config_dword(dev, 0x44, 0x8300830A);\n\t} else {\n\t\tpci_write_config_dword(dev, 0x44, 0x42004200);\n\t\tpci_write_config_dword(dev, 0x48, 0x42004200);\n\t}\n\n\n\tretval = icom_alloc_adapter(&icom_adapter);\n\tif (retval) {\n\t\t dev_err(&dev->dev, \"icom_alloc_adapter FAILED\\n\");\n\t\t retval = -EIO;\n\t\t goto probe_exit0;\n\t}\n\n\ticom_adapter->base_addr_pci = pci_resource_start(dev, 0);\n\ticom_adapter->pci_dev = dev;\n\ticom_adapter->version = ent->driver_data;\n\ticom_adapter->subsystem_id = ent->subdevice;\n\n\n\tretval = icom_init_ports(icom_adapter);\n\tif (retval) {\n\t\tdev_err(&dev->dev, \"Port configuration failed\\n\");\n\t\tgoto probe_exit1;\n\t}\n\n\ticom_adapter->base_addr = pci_ioremap_bar(dev, 0);\n\n\tif (!icom_adapter->base_addr) {\n\t\tretval = -ENOMEM;\n\t\tgoto probe_exit1;\n\t}\n\n\t  \n\t retval = request_irq(dev->irq, icom_interrupt, IRQF_SHARED, ICOM_DRIVER_NAME, (void *)icom_adapter);\n\t if (retval) {\n\t\t  goto probe_exit2;\n\t }\n\n\tretval = icom_load_ports(icom_adapter);\n\n\tfor (index = 0; index < icom_adapter->numb_ports; index++) {\n\t\ticom_port = &icom_adapter->port_info[index];\n\n\t\tif (icom_port->status == ICOM_PORT_ACTIVE) {\n\t\t\ticom_port->uart_port.irq = icom_port->adapter->pci_dev->irq;\n\t\t\ticom_port->uart_port.type = PORT_ICOM;\n\t\t\ticom_port->uart_port.iotype = UPIO_MEM;\n\t\t\ticom_port->uart_port.membase =\n\t\t\t\t(unsigned char __iomem *)icom_adapter->base_addr_pci;\n\t\t\ticom_port->uart_port.fifosize = 16;\n\t\t\ticom_port->uart_port.ops = &icom_ops;\n\t\t\ticom_port->uart_port.line =\n\t\t        icom_port->port + icom_adapter->index * 4;\n\t\t\tif (uart_add_one_port (&icom_uart_driver, &icom_port->uart_port)) {\n\t\t\t\ticom_port->status = ICOM_PORT_OFF;\n\t\t\t\tdev_err(&dev->dev, \"Device add failed\\n\");\n\t\t\t } else\n\t\t\t\tdev_info(&dev->dev, \"Device added\\n\");\n\t\t}\n\t}\n\n\tkref_init(&icom_adapter->kref);\n\treturn 0;\n\nprobe_exit2:\n\tiounmap(icom_adapter->base_addr);\nprobe_exit1:\n\ticom_free_adapter(icom_adapter);\n\nprobe_exit0:\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n\n\treturn retval;\n}\n\nstatic void icom_remove(struct pci_dev *dev)\n{\n\tstruct icom_adapter *icom_adapter;\n\n\tlist_for_each_entry(icom_adapter, &icom_adapter_head,\n\t\t\ticom_adapter_entry) {\n\t\tif (icom_adapter->pci_dev == dev) {\n\t\t\tkref_put(&icom_adapter->kref, icom_kref_release);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdev_err(&dev->dev, \"Unable to find device to remove\\n\");\n}\n\nstatic struct pci_driver icom_pci_driver = {\n\t.name = ICOM_DRIVER_NAME,\n\t.id_table = icom_pci_table,\n\t.probe = icom_probe,\n\t.remove = icom_remove,\n};\n\nstatic int __init icom_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&icom_uart_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_register_driver(&icom_pci_driver);\n\n\tif (ret < 0)\n\t\tuart_unregister_driver(&icom_uart_driver);\n\n\treturn ret;\n}\n\nstatic void __exit icom_exit(void)\n{\n\tpci_unregister_driver(&icom_pci_driver);\n\tuart_unregister_driver(&icom_uart_driver);\n}\n\nmodule_init(icom_init);\nmodule_exit(icom_exit);\n\nMODULE_AUTHOR(\"Michael Anderson <mjanders@us.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM iSeries Serial IOA driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"icom_call_setup.bin\");\nMODULE_FIRMWARE(\"icom_res_dce.bin\");\nMODULE_FIRMWARE(\"icom_asc.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}