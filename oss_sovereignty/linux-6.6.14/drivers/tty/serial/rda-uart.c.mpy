{
  "module_name": "rda-uart.c",
  "hash_id": "67b069f0f49ae4009ee0484a64c00d3ba724540d4cc4621d0841719acb850799",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/rda-uart.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#define RDA_UART_PORT_NUM 3\n#define RDA_UART_DEV_NAME \"ttyRDA\"\n\n#define RDA_UART_CTRL\t\t0x00\n#define RDA_UART_STATUS\t\t0x04\n#define RDA_UART_RXTX_BUFFER\t0x08\n#define RDA_UART_IRQ_MASK\t0x0c\n#define RDA_UART_IRQ_CAUSE\t0x10\n#define RDA_UART_IRQ_TRIGGERS\t0x14\n#define RDA_UART_CMD_SET\t0x18\n#define RDA_UART_CMD_CLR\t0x1c\n\n \n#define RDA_UART_ENABLE\t\t\tBIT(0)\n#define RDA_UART_DBITS_8\t\tBIT(1)\n#define RDA_UART_TX_SBITS_2\t\tBIT(2)\n#define RDA_UART_PARITY_EN\t\tBIT(3)\n#define RDA_UART_PARITY(x)\t\t(((x) & 0x3) << 4)\n#define RDA_UART_PARITY_ODD\t\tRDA_UART_PARITY(0)\n#define RDA_UART_PARITY_EVEN\t\tRDA_UART_PARITY(1)\n#define RDA_UART_PARITY_SPACE\t\tRDA_UART_PARITY(2)\n#define RDA_UART_PARITY_MARK\t\tRDA_UART_PARITY(3)\n#define RDA_UART_DIV_MODE\t\tBIT(20)\n#define RDA_UART_IRDA_EN\t\tBIT(21)\n#define RDA_UART_DMA_EN\t\t\tBIT(22)\n#define RDA_UART_FLOW_CNT_EN\t\tBIT(23)\n#define RDA_UART_LOOP_BACK_EN\t\tBIT(24)\n#define RDA_UART_RX_LOCK_ERR\t\tBIT(25)\n#define RDA_UART_RX_BREAK_LEN(x)\t(((x) & 0xf) << 28)\n\n \n#define RDA_UART_RX_FIFO(x)\t\t(((x) & 0x7f) << 0)\n#define RDA_UART_RX_FIFO_MASK\t\t(0x7f << 0)\n#define RDA_UART_TX_FIFO(x)\t\t(((x) & 0x1f) << 8)\n#define RDA_UART_TX_FIFO_MASK\t\t(0x1f << 8)\n#define RDA_UART_TX_ACTIVE\t\tBIT(14)\n#define RDA_UART_RX_ACTIVE\t\tBIT(15)\n#define RDA_UART_RX_OVERFLOW_ERR\tBIT(16)\n#define RDA_UART_TX_OVERFLOW_ERR\tBIT(17)\n#define RDA_UART_RX_PARITY_ERR\t\tBIT(18)\n#define RDA_UART_RX_FRAMING_ERR\t\tBIT(19)\n#define RDA_UART_RX_BREAK_INT\t\tBIT(20)\n#define RDA_UART_DCTS\t\t\tBIT(24)\n#define RDA_UART_CTS\t\t\tBIT(25)\n#define RDA_UART_DTR\t\t\tBIT(28)\n#define RDA_UART_CLK_ENABLED\t\tBIT(31)\n\n \n#define RDA_UART_RX_DATA(x)\t\t(((x) & 0xff) << 0)\n#define RDA_UART_TX_DATA(x)\t\t(((x) & 0xff) << 0)\n\n \n#define RDA_UART_TX_MODEM_STATUS\tBIT(0)\n#define RDA_UART_RX_DATA_AVAILABLE\tBIT(1)\n#define RDA_UART_TX_DATA_NEEDED\t\tBIT(2)\n#define RDA_UART_RX_TIMEOUT\t\tBIT(3)\n#define RDA_UART_RX_LINE_ERR\t\tBIT(4)\n#define RDA_UART_TX_DMA_DONE\t\tBIT(5)\n#define RDA_UART_RX_DMA_DONE\t\tBIT(6)\n#define RDA_UART_RX_DMA_TIMEOUT\t\tBIT(7)\n#define RDA_UART_DTR_RISE\t\tBIT(8)\n#define RDA_UART_DTR_FALL\t\tBIT(9)\n\n \n#define RDA_UART_TX_MODEM_STATUS_U\tBIT(16)\n#define RDA_UART_RX_DATA_AVAILABLE_U\tBIT(17)\n#define RDA_UART_TX_DATA_NEEDED_U\tBIT(18)\n#define RDA_UART_RX_TIMEOUT_U\t\tBIT(19)\n#define RDA_UART_RX_LINE_ERR_U\t\tBIT(20)\n#define RDA_UART_TX_DMA_DONE_U\t\tBIT(21)\n#define RDA_UART_RX_DMA_DONE_U\t\tBIT(22)\n#define RDA_UART_RX_DMA_TIMEOUT_U\tBIT(23)\n#define RDA_UART_DTR_RISE_U\t\tBIT(24)\n#define RDA_UART_DTR_FALL_U\t\tBIT(25)\n\n \n#define RDA_UART_RX_TRIGGER(x)\t\t(((x) & 0x1f) << 0)\n#define RDA_UART_TX_TRIGGER(x)\t\t(((x) & 0xf) << 8)\n#define RDA_UART_AFC_LEVEL(x)\t\t(((x) & 0x1f) << 16)\n\n \n#define RDA_UART_RI\t\t\tBIT(0)\n#define RDA_UART_DCD\t\t\tBIT(1)\n#define RDA_UART_DSR\t\t\tBIT(2)\n#define RDA_UART_TX_BREAK_CONTROL\tBIT(3)\n#define RDA_UART_TX_FINISH_N_WAIT\tBIT(4)\n#define RDA_UART_RTS\t\t\tBIT(5)\n#define RDA_UART_RX_FIFO_RESET\t\tBIT(6)\n#define RDA_UART_TX_FIFO_RESET\t\tBIT(7)\n\n#define RDA_UART_TX_FIFO_SIZE\t16\n\nstatic struct uart_driver rda_uart_driver;\n\nstruct rda_uart_port {\n\tstruct uart_port port;\n\tstruct clk *clk;\n};\n\n#define to_rda_uart_port(port) container_of(port, struct rda_uart_port, port)\n\nstatic struct rda_uart_port *rda_uart_ports[RDA_UART_PORT_NUM];\n\nstatic inline void rda_uart_write(struct uart_port *port, u32 val,\n\t\t\t\t  unsigned int off)\n{\n\twritel(val, port->membase + off);\n}\n\nstatic inline u32 rda_uart_read(struct uart_port *port, unsigned int off)\n{\n\treturn readl(port->membase + off);\n}\n\nstatic unsigned int rda_uart_tx_empty(struct uart_port *port)\n{\n\tunsigned long flags;\n\tunsigned int ret;\n\tu32 val;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tval = rda_uart_read(port, RDA_UART_STATUS);\n\tret = (val & RDA_UART_TX_FIFO_MASK) ? TIOCSER_TEMT : 0;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn ret;\n}\n\nstatic unsigned int rda_uart_get_mctrl(struct uart_port *port)\n{\n\tunsigned int mctrl = 0;\n\tu32 cmd_set, status;\n\n\tcmd_set = rda_uart_read(port, RDA_UART_CMD_SET);\n\tstatus = rda_uart_read(port, RDA_UART_STATUS);\n\tif (cmd_set & RDA_UART_RTS)\n\t\tmctrl |= TIOCM_RTS;\n\tif (!(status & RDA_UART_CTS))\n\t\tmctrl |= TIOCM_CTS;\n\n\treturn mctrl;\n}\n\nstatic void rda_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tu32 val;\n\n\tif (mctrl & TIOCM_RTS) {\n\t\tval = rda_uart_read(port, RDA_UART_CMD_SET);\n\t\trda_uart_write(port, (val | RDA_UART_RTS), RDA_UART_CMD_SET);\n\t} else {\n\t\t \n\t\tval = rda_uart_read(port, RDA_UART_CMD_CLR);\n\t\trda_uart_write(port, (val | RDA_UART_RTS), RDA_UART_CMD_CLR);\n\t}\n\n\tval = rda_uart_read(port, RDA_UART_CTRL);\n\n\tif (mctrl & TIOCM_LOOP)\n\t\tval |= RDA_UART_LOOP_BACK_EN;\n\telse\n\t\tval &= ~RDA_UART_LOOP_BACK_EN;\n\n\trda_uart_write(port, val, RDA_UART_CTRL);\n}\n\nstatic void rda_uart_stop_tx(struct uart_port *port)\n{\n\tu32 val;\n\n\tval = rda_uart_read(port, RDA_UART_IRQ_MASK);\n\tval &= ~RDA_UART_TX_DATA_NEEDED;\n\trda_uart_write(port, val, RDA_UART_IRQ_MASK);\n\n\tval = rda_uart_read(port, RDA_UART_CMD_SET);\n\tval |= RDA_UART_TX_FIFO_RESET;\n\trda_uart_write(port, val, RDA_UART_CMD_SET);\n}\n\nstatic void rda_uart_stop_rx(struct uart_port *port)\n{\n\tu32 val;\n\n\tval = rda_uart_read(port, RDA_UART_IRQ_MASK);\n\tval &= ~(RDA_UART_RX_DATA_AVAILABLE | RDA_UART_RX_TIMEOUT);\n\trda_uart_write(port, val, RDA_UART_IRQ_MASK);\n\n\t \n\tval = rda_uart_read(port, RDA_UART_RXTX_BUFFER);\n\n\tval = rda_uart_read(port, RDA_UART_CMD_SET);\n\tval |= RDA_UART_RX_FIFO_RESET;\n\trda_uart_write(port, val, RDA_UART_CMD_SET);\n}\n\nstatic void rda_uart_start_tx(struct uart_port *port)\n{\n\tu32 val;\n\n\tif (uart_tx_stopped(port)) {\n\t\trda_uart_stop_tx(port);\n\t\treturn;\n\t}\n\n\tval = rda_uart_read(port, RDA_UART_IRQ_MASK);\n\tval |= RDA_UART_TX_DATA_NEEDED;\n\trda_uart_write(port, val, RDA_UART_IRQ_MASK);\n}\n\nstatic void rda_uart_change_baudrate(struct rda_uart_port *rda_port,\n\t\t\t\t     unsigned long baud)\n{\n\tclk_set_rate(rda_port->clk, baud * 8);\n}\n\nstatic void rda_uart_set_termios(struct uart_port *port,\n\t\t\t\t struct ktermios *termios,\n\t\t\t\t const struct ktermios *old)\n{\n\tstruct rda_uart_port *rda_port = to_rda_uart_port(port);\n\tunsigned long flags;\n\tunsigned int ctrl, cmd_set, cmd_clr, triggers;\n\tunsigned int baud;\n\tu32 irq_mask;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tbaud = uart_get_baud_rate(port, termios, old, 9600, port->uartclk / 4);\n\trda_uart_change_baudrate(rda_port, baud);\n\n\tctrl = rda_uart_read(port, RDA_UART_CTRL);\n\tcmd_set = rda_uart_read(port, RDA_UART_CMD_SET);\n\tcmd_clr = rda_uart_read(port, RDA_UART_CMD_CLR);\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\tcase CS6:\n\t\tdev_warn(port->dev, \"bit size not supported, using 7 bits\\n\");\n\t\tfallthrough;\n\tcase CS7:\n\t\tctrl &= ~RDA_UART_DBITS_8;\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= CS7;\n\t\tbreak;\n\tdefault:\n\t\tctrl |= RDA_UART_DBITS_8;\n\t\tbreak;\n\t}\n\n\t \n\tif (termios->c_cflag & CSTOPB)\n\t\tctrl |= RDA_UART_TX_SBITS_2;\n\telse\n\t\tctrl &= ~RDA_UART_TX_SBITS_2;\n\n\t \n\tif (termios->c_cflag & PARENB) {\n\t\tctrl |= RDA_UART_PARITY_EN;\n\n\t\t \n\t\tif (termios->c_cflag & CMSPAR) {\n\t\t\tif (termios->c_cflag & PARODD)\n\t\t\t\tctrl |= RDA_UART_PARITY_MARK;\n\t\t\telse\n\t\t\t\tctrl |= RDA_UART_PARITY_SPACE;\n\t\t} else if (termios->c_cflag & PARODD) {\n\t\t\tctrl |= RDA_UART_PARITY_ODD;\n\t\t} else {\n\t\t\tctrl |= RDA_UART_PARITY_EVEN;\n\t\t}\n\t} else {\n\t\tctrl &= ~RDA_UART_PARITY_EN;\n\t}\n\n\t \n\tif (termios->c_cflag & CRTSCTS) {\n\t\tctrl   |= RDA_UART_FLOW_CNT_EN;\n\t\tcmd_set |= RDA_UART_RTS;\n\t} else {\n\t\tctrl   &= ~RDA_UART_FLOW_CNT_EN;\n\t\tcmd_clr |= RDA_UART_RTS;\n\t}\n\n\tctrl |= RDA_UART_ENABLE;\n\tctrl &= ~RDA_UART_DMA_EN;\n\n\ttriggers  = (RDA_UART_AFC_LEVEL(20) | RDA_UART_RX_TRIGGER(16));\n\tirq_mask = rda_uart_read(port, RDA_UART_IRQ_MASK);\n\trda_uart_write(port, 0, RDA_UART_IRQ_MASK);\n\n\trda_uart_write(port, triggers, RDA_UART_IRQ_TRIGGERS);\n\trda_uart_write(port, ctrl, RDA_UART_CTRL);\n\trda_uart_write(port, cmd_set, RDA_UART_CMD_SET);\n\trda_uart_write(port, cmd_clr, RDA_UART_CMD_CLR);\n\n\trda_uart_write(port, irq_mask, RDA_UART_IRQ_MASK);\n\n\t \n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void rda_uart_send_chars(struct uart_port *port)\n{\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned int ch;\n\tu32 val;\n\n\tif (uart_tx_stopped(port))\n\t\treturn;\n\n\tif (port->x_char) {\n\t\twhile (!(rda_uart_read(port, RDA_UART_STATUS) &\n\t\t\t RDA_UART_TX_FIFO_MASK))\n\t\t\tcpu_relax();\n\n\t\trda_uart_write(port, port->x_char, RDA_UART_RXTX_BUFFER);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t}\n\n\twhile (rda_uart_read(port, RDA_UART_STATUS) & RDA_UART_TX_FIFO_MASK) {\n\t\tif (uart_circ_empty(xmit))\n\t\t\tbreak;\n\n\t\tch = xmit->buf[xmit->tail];\n\t\trda_uart_write(port, ch, RDA_UART_RXTX_BUFFER);\n\t\tuart_xmit_advance(port, 1);\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (!uart_circ_empty(xmit)) {\n\t\t \n\t\tval = rda_uart_read(port, RDA_UART_IRQ_MASK);\n\t\tval |= RDA_UART_TX_DATA_NEEDED;\n\t\trda_uart_write(port, val, RDA_UART_IRQ_MASK);\n\t}\n}\n\nstatic void rda_uart_receive_chars(struct uart_port *port)\n{\n\tu32 status, val;\n\n\tstatus = rda_uart_read(port, RDA_UART_STATUS);\n\twhile ((status & RDA_UART_RX_FIFO_MASK)) {\n\t\tchar flag = TTY_NORMAL;\n\n\t\tif (status & RDA_UART_RX_PARITY_ERR) {\n\t\t\tport->icount.parity++;\n\t\t\tflag = TTY_PARITY;\n\t\t}\n\n\t\tif (status & RDA_UART_RX_FRAMING_ERR) {\n\t\t\tport->icount.frame++;\n\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif (status & RDA_UART_RX_OVERFLOW_ERR) {\n\t\t\tport->icount.overrun++;\n\t\t\tflag = TTY_OVERRUN;\n\t\t}\n\n\t\tval = rda_uart_read(port, RDA_UART_RXTX_BUFFER);\n\t\tval &= 0xff;\n\n\t\tport->icount.rx++;\n\t\ttty_insert_flip_char(&port->state->port, val, flag);\n\n\t\tstatus = rda_uart_read(port, RDA_UART_STATUS);\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic irqreturn_t rda_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tunsigned long flags;\n\tu32 val, irq_mask;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tval = rda_uart_read(port, RDA_UART_IRQ_CAUSE);\n\trda_uart_write(port, val, RDA_UART_IRQ_CAUSE);\n\n\tif (val & (RDA_UART_RX_DATA_AVAILABLE | RDA_UART_RX_TIMEOUT))\n\t\trda_uart_receive_chars(port);\n\n\tif (val & (RDA_UART_TX_DATA_NEEDED)) {\n\t\tirq_mask = rda_uart_read(port, RDA_UART_IRQ_MASK);\n\t\tirq_mask &= ~RDA_UART_TX_DATA_NEEDED;\n\t\trda_uart_write(port, irq_mask, RDA_UART_IRQ_MASK);\n\n\t\trda_uart_send_chars(port);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rda_uart_startup(struct uart_port *port)\n{\n\tunsigned long flags;\n\tint ret;\n\tu32 val;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\trda_uart_write(port, 0, RDA_UART_IRQ_MASK);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tret = request_irq(port->irq, rda_interrupt, IRQF_NO_SUSPEND,\n\t\t\t  \"rda-uart\", port);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tval = rda_uart_read(port, RDA_UART_CTRL);\n\tval |= RDA_UART_ENABLE;\n\trda_uart_write(port, val, RDA_UART_CTRL);\n\n\t \n\tval = rda_uart_read(port, RDA_UART_IRQ_MASK);\n\tval |= (RDA_UART_RX_DATA_AVAILABLE | RDA_UART_RX_TIMEOUT);\n\trda_uart_write(port, val, RDA_UART_IRQ_MASK);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn 0;\n}\n\nstatic void rda_uart_shutdown(struct uart_port *port)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\trda_uart_stop_tx(port);\n\trda_uart_stop_rx(port);\n\n\tval = rda_uart_read(port, RDA_UART_CTRL);\n\tval &= ~RDA_UART_ENABLE;\n\trda_uart_write(port, val, RDA_UART_CTRL);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *rda_uart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_RDA) ? \"rda-uart\" : NULL;\n}\n\nstatic int rda_uart_request_port(struct uart_port *port)\n{\n\tstruct platform_device *pdev = to_platform_device(port->dev);\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENXIO;\n\n\tif (!devm_request_mem_region(port->dev, port->mapbase,\n\t\t\t\t     resource_size(res), dev_name(port->dev)))\n\t\treturn -EBUSY;\n\n\tif (port->flags & UPF_IOREMAP) {\n\t\tport->membase = devm_ioremap(port->dev, port->mapbase,\n\t\t\t\t\t\t     resource_size(res));\n\t\tif (!port->membase)\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void rda_uart_config_port(struct uart_port *port, int flags)\n{\n\tunsigned long irq_flags;\n\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_RDA;\n\t\trda_uart_request_port(port);\n\t}\n\n\tspin_lock_irqsave(&port->lock, irq_flags);\n\n\t \n\trda_uart_write(port, 0, RDA_UART_IRQ_MASK);\n\n\t \n\trda_uart_write(port, 0, RDA_UART_STATUS);\n\n\tspin_unlock_irqrestore(&port->lock, irq_flags);\n}\n\nstatic void rda_uart_release_port(struct uart_port *port)\n{\n\tstruct platform_device *pdev = to_platform_device(port->dev);\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn;\n\n\tif (port->flags & UPF_IOREMAP) {\n\t\tdevm_release_mem_region(port->dev, port->mapbase,\n\t\t\t\t\tresource_size(res));\n\t\tdevm_iounmap(port->dev, port->membase);\n\t\tport->membase = NULL;\n\t}\n}\n\nstatic int rda_uart_verify_port(struct uart_port *port,\n\t\t\t\tstruct serial_struct *ser)\n{\n\tif (port->type != PORT_RDA)\n\t\treturn -EINVAL;\n\n\tif (port->irq != ser->irq)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct uart_ops rda_uart_ops = {\n\t.tx_empty       = rda_uart_tx_empty,\n\t.get_mctrl      = rda_uart_get_mctrl,\n\t.set_mctrl      = rda_uart_set_mctrl,\n\t.start_tx       = rda_uart_start_tx,\n\t.stop_tx        = rda_uart_stop_tx,\n\t.stop_rx        = rda_uart_stop_rx,\n\t.startup        = rda_uart_startup,\n\t.shutdown       = rda_uart_shutdown,\n\t.set_termios    = rda_uart_set_termios,\n\t.type           = rda_uart_type,\n\t.request_port\t= rda_uart_request_port,\n\t.release_port\t= rda_uart_release_port,\n\t.config_port\t= rda_uart_config_port,\n\t.verify_port\t= rda_uart_verify_port,\n};\n\n#ifdef CONFIG_SERIAL_RDA_CONSOLE\n\nstatic void rda_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tif (!port->membase)\n\t\treturn;\n\n\twhile (!(rda_uart_read(port, RDA_UART_STATUS) & RDA_UART_TX_FIFO_MASK))\n\t\tcpu_relax();\n\n\trda_uart_write(port, ch, RDA_UART_RXTX_BUFFER);\n}\n\nstatic void rda_uart_port_write(struct uart_port *port, const char *s,\n\t\t\t\tu_int count)\n{\n\tu32 old_irq_mask;\n\tunsigned long flags;\n\tint locked;\n\n\tlocal_irq_save(flags);\n\n\tif (port->sysrq) {\n\t\tlocked = 0;\n\t} else if (oops_in_progress) {\n\t\tlocked = spin_trylock(&port->lock);\n\t} else {\n\t\tspin_lock(&port->lock);\n\t\tlocked = 1;\n\t}\n\n\told_irq_mask = rda_uart_read(port, RDA_UART_IRQ_MASK);\n\trda_uart_write(port, 0, RDA_UART_IRQ_MASK);\n\n\tuart_console_write(port, s, count, rda_console_putchar);\n\n\t \n\twhile (!(rda_uart_read(port, RDA_UART_STATUS) & RDA_UART_TX_FIFO_MASK))\n\t\tcpu_relax();\n\n\trda_uart_write(port, old_irq_mask, RDA_UART_IRQ_MASK);\n\n\tif (locked)\n\t\tspin_unlock(&port->lock);\n\n\tlocal_irq_restore(flags);\n}\n\nstatic void rda_uart_console_write(struct console *co, const char *s,\n\t\t\t\t   u_int count)\n{\n\tstruct rda_uart_port *rda_port;\n\n\trda_port = rda_uart_ports[co->index];\n\tif (!rda_port)\n\t\treturn;\n\n\trda_uart_port_write(&rda_port->port, s, count);\n}\n\nstatic int rda_uart_console_setup(struct console *co, char *options)\n{\n\tstruct rda_uart_port *rda_port;\n\tint baud = 921600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index < 0 || co->index >= RDA_UART_PORT_NUM)\n\t\treturn -EINVAL;\n\n\trda_port = rda_uart_ports[co->index];\n\tif (!rda_port || !rda_port->port.membase)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&rda_port->port, co, baud, parity, bits, flow);\n}\n\nstatic struct console rda_uart_console = {\n\t.name = RDA_UART_DEV_NAME,\n\t.write = rda_uart_console_write,\n\t.device = uart_console_device,\n\t.setup = rda_uart_console_setup,\n\t.flags = CON_PRINTBUFFER,\n\t.index = -1,\n\t.data = &rda_uart_driver,\n};\n\nstatic int __init rda_uart_console_init(void)\n{\n\tregister_console(&rda_uart_console);\n\n\treturn 0;\n}\nconsole_initcall(rda_uart_console_init);\n\nstatic void rda_uart_early_console_write(struct console *co,\n\t\t\t\t\t const char *s,\n\t\t\t\t\t u_int count)\n{\n\tstruct earlycon_device *dev = co->data;\n\n\trda_uart_port_write(&dev->port, s, count);\n}\n\nstatic int __init\nrda_uart_early_console_setup(struct earlycon_device *device, const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = rda_uart_early_console_write;\n\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(rda, \"rda,8810pl-uart\",\n\t\t    rda_uart_early_console_setup);\n\n#define RDA_UART_CONSOLE (&rda_uart_console)\n#else\n#define RDA_UART_CONSOLE NULL\n#endif  \n\nstatic struct uart_driver rda_uart_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = \"rda-uart\",\n\t.dev_name = RDA_UART_DEV_NAME,\n\t.nr = RDA_UART_PORT_NUM,\n\t.cons = RDA_UART_CONSOLE,\n};\n\nstatic const struct of_device_id rda_uart_dt_matches[] = {\n\t{ .compatible = \"rda,8810pl-uart\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rda_uart_dt_matches);\n\nstatic int rda_uart_probe(struct platform_device *pdev)\n{\n\tstruct resource *res_mem;\n\tstruct rda_uart_port *rda_port;\n\tint ret, irq;\n\n\tif (pdev->dev.of_node)\n\t\tpdev->id = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\n\tif (pdev->id < 0 || pdev->id >= RDA_UART_PORT_NUM) {\n\t\tdev_err(&pdev->dev, \"id %d out of range\\n\", pdev->id);\n\t\treturn -EINVAL;\n\t}\n\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res_mem) {\n\t\tdev_err(&pdev->dev, \"could not get mem\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tif (rda_uart_ports[pdev->id]) {\n\t\tdev_err(&pdev->dev, \"port %d already allocated\\n\", pdev->id);\n\t\treturn -EBUSY;\n\t}\n\n\trda_port = devm_kzalloc(&pdev->dev, sizeof(*rda_port), GFP_KERNEL);\n\tif (!rda_port)\n\t\treturn -ENOMEM;\n\n\trda_port->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(rda_port->clk)) {\n\t\tdev_err(&pdev->dev, \"could not get clk\\n\");\n\t\treturn PTR_ERR(rda_port->clk);\n\t}\n\n\trda_port->port.dev = &pdev->dev;\n\trda_port->port.regshift = 0;\n\trda_port->port.line = pdev->id;\n\trda_port->port.type = PORT_RDA;\n\trda_port->port.iotype = UPIO_MEM;\n\trda_port->port.mapbase = res_mem->start;\n\trda_port->port.irq = irq;\n\trda_port->port.uartclk = clk_get_rate(rda_port->clk);\n\tif (rda_port->port.uartclk == 0) {\n\t\tdev_err(&pdev->dev, \"clock rate is zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\trda_port->port.flags = UPF_BOOT_AUTOCONF | UPF_IOREMAP |\n\t\t\t       UPF_LOW_LATENCY;\n\trda_port->port.x_char = 0;\n\trda_port->port.fifosize = RDA_UART_TX_FIFO_SIZE;\n\trda_port->port.ops = &rda_uart_ops;\n\n\trda_uart_ports[pdev->id] = rda_port;\n\tplatform_set_drvdata(pdev, rda_port);\n\n\tret = uart_add_one_port(&rda_uart_driver, &rda_port->port);\n\tif (ret)\n\t\trda_uart_ports[pdev->id] = NULL;\n\n\treturn ret;\n}\n\nstatic int rda_uart_remove(struct platform_device *pdev)\n{\n\tstruct rda_uart_port *rda_port = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&rda_uart_driver, &rda_port->port);\n\trda_uart_ports[pdev->id] = NULL;\n\n\treturn 0;\n}\n\nstatic struct platform_driver rda_uart_platform_driver = {\n\t.probe = rda_uart_probe,\n\t.remove = rda_uart_remove,\n\t.driver = {\n\t\t.name = \"rda-uart\",\n\t\t.of_match_table = rda_uart_dt_matches,\n\t},\n};\n\nstatic int __init rda_uart_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&rda_uart_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&rda_uart_platform_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&rda_uart_driver);\n\n\treturn ret;\n}\n\nstatic void __exit rda_uart_exit(void)\n{\n\tplatform_driver_unregister(&rda_uart_platform_driver);\n\tuart_unregister_driver(&rda_uart_driver);\n}\n\nmodule_init(rda_uart_init);\nmodule_exit(rda_uart_exit);\n\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_DESCRIPTION(\"RDA8810PL serial device driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}