{
  "module_name": "atmel_serial.c",
  "hash_id": "8ba0053616b742ff9a1785097febc84c1a98cc9666faedae5254da1ebf9b0752",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/atmel_serial.c",
  "human_readable_source": "\n \n#include <linux/circ_buf.h>\n#include <linux/tty.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/serial.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/tty_flip.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/atmel_pdc.h>\n#include <linux/uaccess.h>\n#include <linux/platform_data/atmel.h>\n#include <linux/timer.h>\n#include <linux/err.h>\n#include <linux/irq.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/io.h>\n\n#include <asm/div64.h>\n#include <asm/ioctls.h>\n\n#define PDC_BUFFER_SIZE\t\t512\n \n#define PDC_RX_TIMEOUT\t\t(3 * 10)\t\t \n\n \n#define ATMEL_MIN_FIFO_SIZE\t8\n \n#define ATMEL_RTS_HIGH_OFFSET\t16\n#define ATMEL_RTS_LOW_OFFSET\t20\n\n#include <linux/serial_core.h>\n\n#include \"serial_mctrl_gpio.h\"\n#include \"atmel_serial.h\"\n\nstatic void atmel_start_rx(struct uart_port *port);\nstatic void atmel_stop_rx(struct uart_port *port);\n\n#ifdef CONFIG_SERIAL_ATMEL_TTYAT\n\n \n#define SERIAL_ATMEL_MAJOR\t204\n#define MINOR_START\t\t154\n#define ATMEL_DEVICENAME\t\"ttyAT\"\n\n#else\n\n \n#define SERIAL_ATMEL_MAJOR\tTTY_MAJOR\n#define MINOR_START\t\t64\n#define ATMEL_DEVICENAME\t\"ttyS\"\n\n#endif\n\n#define ATMEL_ISR_PASS_LIMIT\t256\n\nstruct atmel_dma_buffer {\n\tunsigned char\t*buf;\n\tdma_addr_t\tdma_addr;\n\tunsigned int\tdma_size;\n\tunsigned int\tofs;\n};\n\nstruct atmel_uart_char {\n\tu16\t\tstatus;\n\tu16\t\tch;\n};\n\n \n#define ATMEL_SERIAL_RINGSIZE 1024\n\n \n#define ATMEL_MAX_UART\t\t8\n\n \nstruct atmel_uart_port {\n\tstruct uart_port\tuart;\t\t \n\tstruct clk\t\t*clk;\t\t \n\tstruct clk\t\t*gclk;\t\t \n\tint\t\t\tmay_wakeup;\t \n\tu32\t\t\tbackup_imr;\t \n\tint\t\t\tbreak_active;\t \n\n\tbool\t\t\tuse_dma_rx;\t \n\tbool\t\t\tuse_pdc_rx;\t \n\tshort\t\t\tpdc_rx_idx;\t \n\tstruct atmel_dma_buffer\tpdc_rx[2];\t \n\n\tbool\t\t\tuse_dma_tx;      \n\tbool\t\t\tuse_pdc_tx;\t \n\tstruct atmel_dma_buffer\tpdc_tx;\t\t \n\n\tspinlock_t\t\t\tlock_tx;\t \n\tspinlock_t\t\t\tlock_rx;\t \n\tstruct dma_chan\t\t\t*chan_tx;\n\tstruct dma_chan\t\t\t*chan_rx;\n\tstruct dma_async_tx_descriptor\t*desc_tx;\n\tstruct dma_async_tx_descriptor\t*desc_rx;\n\tdma_cookie_t\t\t\tcookie_tx;\n\tdma_cookie_t\t\t\tcookie_rx;\n\tstruct scatterlist\t\tsg_tx;\n\tstruct scatterlist\t\tsg_rx;\n\tstruct tasklet_struct\ttasklet_rx;\n\tstruct tasklet_struct\ttasklet_tx;\n\tatomic_t\t\ttasklet_shutdown;\n\tunsigned int\t\tirq_status_prev;\n\tunsigned int\t\ttx_len;\n\n\tstruct circ_buf\t\trx_ring;\n\n\tstruct mctrl_gpios\t*gpios;\n\tu32\t\t\tbackup_mode;\t \n\tu32\t\t\tbackup_brgr;\t \n\tunsigned int\t\ttx_done_mask;\n\tu32\t\t\tfifo_size;\n\tu32\t\t\trts_high;\n\tu32\t\t\trts_low;\n\tbool\t\t\tms_irq_enabled;\n\tu32\t\t\trtor;\t \n\tbool\t\t\tis_usart;\n\tbool\t\t\thas_frac_baudrate;\n\tbool\t\t\thas_hw_timer;\n\tstruct timer_list\tuart_timer;\n\n\tbool\t\t\ttx_stopped;\n\tbool\t\t\tsuspended;\n\tunsigned int\t\tpending;\n\tunsigned int\t\tpending_status;\n\tspinlock_t\t\tlock_suspended;\n\n\tbool\t\t\thd_start_rx;\t \n\n\t \n\tunsigned int\t\tfidi_min;\n\tunsigned int\t\tfidi_max;\n\n\tstruct {\n\t\tu32\t\tcr;\n\t\tu32\t\tmr;\n\t\tu32\t\timr;\n\t\tu32\t\tbrgr;\n\t\tu32\t\trtor;\n\t\tu32\t\tttgr;\n\t\tu32\t\tfmr;\n\t\tu32\t\tfimr;\n\t} cache;\n\n\tint (*prepare_rx)(struct uart_port *port);\n\tint (*prepare_tx)(struct uart_port *port);\n\tvoid (*schedule_rx)(struct uart_port *port);\n\tvoid (*schedule_tx)(struct uart_port *port);\n\tvoid (*release_rx)(struct uart_port *port);\n\tvoid (*release_tx)(struct uart_port *port);\n};\n\nstatic struct atmel_uart_port atmel_ports[ATMEL_MAX_UART];\nstatic DECLARE_BITMAP(atmel_ports_in_use, ATMEL_MAX_UART);\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id atmel_serial_dt_ids[] = {\n\t{ .compatible = \"atmel,at91rm9200-usart-serial\" },\n\t{   }\n};\n#endif\n\nstatic inline struct atmel_uart_port *\nto_atmel_uart_port(struct uart_port *uart)\n{\n\treturn container_of(uart, struct atmel_uart_port, uart);\n}\n\nstatic inline u32 atmel_uart_readl(struct uart_port *port, u32 reg)\n{\n\treturn __raw_readl(port->membase + reg);\n}\n\nstatic inline void atmel_uart_writel(struct uart_port *port, u32 reg, u32 value)\n{\n\t__raw_writel(value, port->membase + reg);\n}\n\nstatic inline u8 atmel_uart_read_char(struct uart_port *port)\n{\n\treturn __raw_readb(port->membase + ATMEL_US_RHR);\n}\n\nstatic inline void atmel_uart_write_char(struct uart_port *port, u8 value)\n{\n\t__raw_writeb(value, port->membase + ATMEL_US_THR);\n}\n\nstatic inline int atmel_uart_is_half_duplex(struct uart_port *port)\n{\n\treturn ((port->rs485.flags & SER_RS485_ENABLED) &&\n\t\t!(port->rs485.flags & SER_RS485_RX_DURING_TX)) ||\n\t\t(port->iso7816.flags & SER_ISO7816_ENABLED);\n}\n\nstatic inline int atmel_error_rate(int desired_value, int actual_value)\n{\n\treturn 100 - (desired_value * 100) / actual_value;\n}\n\n#ifdef CONFIG_SERIAL_ATMEL_PDC\nstatic bool atmel_use_pdc_rx(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\treturn atmel_port->use_pdc_rx;\n}\n\nstatic bool atmel_use_pdc_tx(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\treturn atmel_port->use_pdc_tx;\n}\n#else\nstatic bool atmel_use_pdc_rx(struct uart_port *port)\n{\n\treturn false;\n}\n\nstatic bool atmel_use_pdc_tx(struct uart_port *port)\n{\n\treturn false;\n}\n#endif\n\nstatic bool atmel_use_dma_tx(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\treturn atmel_port->use_dma_tx;\n}\n\nstatic bool atmel_use_dma_rx(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\treturn atmel_port->use_dma_rx;\n}\n\nstatic bool atmel_use_fifo(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\treturn atmel_port->fifo_size;\n}\n\nstatic void atmel_tasklet_schedule(struct atmel_uart_port *atmel_port,\n\t\t\t\t   struct tasklet_struct *t)\n{\n\tif (!atomic_read(&atmel_port->tasklet_shutdown))\n\t\ttasklet_schedule(t);\n}\n\n \nstatic int atmel_config_rs485(struct uart_port *port, struct ktermios *termios,\n\t\t\t      struct serial_rs485 *rs485conf)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tunsigned int mode;\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_IDR, atmel_port->tx_done_mask);\n\n\tmode = atmel_uart_readl(port, ATMEL_US_MR);\n\n\tif (rs485conf->flags & SER_RS485_ENABLED) {\n\t\tdev_dbg(port->dev, \"Setting UART to RS485\\n\");\n\t\tif (rs485conf->flags & SER_RS485_RX_DURING_TX)\n\t\t\tatmel_port->tx_done_mask = ATMEL_US_TXRDY;\n\t\telse\n\t\t\tatmel_port->tx_done_mask = ATMEL_US_TXEMPTY;\n\n\t\tatmel_uart_writel(port, ATMEL_US_TTGR,\n\t\t\t\t  rs485conf->delay_rts_after_send);\n\t\tmode &= ~ATMEL_US_USMODE;\n\t\tmode |= ATMEL_US_USMODE_RS485;\n\t} else {\n\t\tdev_dbg(port->dev, \"Setting UART to RS232\\n\");\n\t\tif (atmel_use_pdc_tx(port))\n\t\t\tatmel_port->tx_done_mask = ATMEL_US_ENDTX |\n\t\t\t\tATMEL_US_TXBUFE;\n\t\telse\n\t\t\tatmel_port->tx_done_mask = ATMEL_US_TXRDY;\n\t}\n\tatmel_uart_writel(port, ATMEL_US_MR, mode);\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_IER, atmel_port->tx_done_mask);\n\n\treturn 0;\n}\n\nstatic unsigned int atmel_calc_cd(struct uart_port *port,\n\t\t\t\t  struct serial_iso7816 *iso7816conf)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tunsigned int cd;\n\tu64 mck_rate;\n\n\tmck_rate = (u64)clk_get_rate(atmel_port->clk);\n\tdo_div(mck_rate, iso7816conf->clk);\n\tcd = mck_rate;\n\treturn cd;\n}\n\nstatic unsigned int atmel_calc_fidi(struct uart_port *port,\n\t\t\t\t    struct serial_iso7816 *iso7816conf)\n{\n\tu64 fidi = 0;\n\n\tif (iso7816conf->sc_fi && iso7816conf->sc_di) {\n\t\tfidi = (u64)iso7816conf->sc_fi;\n\t\tdo_div(fidi, iso7816conf->sc_di);\n\t}\n\treturn (u32)fidi;\n}\n\n \n \nstatic int atmel_config_iso7816(struct uart_port *port,\n\t\t\t\tstruct serial_iso7816 *iso7816conf)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tunsigned int mode;\n\tunsigned int cd, fidi;\n\tint ret = 0;\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_IDR, atmel_port->tx_done_mask);\n\n\tmode = atmel_uart_readl(port, ATMEL_US_MR);\n\n\tif (iso7816conf->flags & SER_ISO7816_ENABLED) {\n\t\tmode &= ~ATMEL_US_USMODE;\n\n\t\tif (iso7816conf->tg > 255) {\n\t\t\tdev_err(port->dev, \"ISO7816: Timeguard exceeding 255\\n\");\n\t\t\tmemset(iso7816conf, 0, sizeof(struct serial_iso7816));\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif ((iso7816conf->flags & SER_ISO7816_T_PARAM)\n\t\t    == SER_ISO7816_T(0)) {\n\t\t\tmode |= ATMEL_US_USMODE_ISO7816_T0 | ATMEL_US_DSNACK;\n\t\t} else if ((iso7816conf->flags & SER_ISO7816_T_PARAM)\n\t\t\t   == SER_ISO7816_T(1)) {\n\t\t\tmode |= ATMEL_US_USMODE_ISO7816_T1 | ATMEL_US_INACK;\n\t\t} else {\n\t\t\tdev_err(port->dev, \"ISO7816: Type not supported\\n\");\n\t\t\tmemset(iso7816conf, 0, sizeof(struct serial_iso7816));\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tmode &= ~(ATMEL_US_USCLKS | ATMEL_US_NBSTOP | ATMEL_US_PAR);\n\n\t\t \n\t\tmode |= ATMEL_US_USCLKS_MCK | ATMEL_US_CLKO;\n\t\t \n\t\tmode |= ATMEL_US_PAR_EVEN | ATMEL_US_NBSTOP_1 | ATMEL_US_MAX_ITER(3);\n\n\t\tcd = atmel_calc_cd(port, iso7816conf);\n\t\tfidi = atmel_calc_fidi(port, iso7816conf);\n\t\tif (fidi == 0) {\n\t\t\tdev_warn(port->dev, \"ISO7816 fidi = 0, Generator generates no signal\\n\");\n\t\t} else if (fidi < atmel_port->fidi_min\n\t\t\t   || fidi > atmel_port->fidi_max) {\n\t\t\tdev_err(port->dev, \"ISO7816 fidi = %u, value not supported\\n\", fidi);\n\t\t\tmemset(iso7816conf, 0, sizeof(struct serial_iso7816));\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (!(port->iso7816.flags & SER_ISO7816_ENABLED)) {\n\t\t\t \n\t\t\tatmel_port->backup_mode = atmel_uart_readl(port, ATMEL_US_MR);\n\t\t\tatmel_port->backup_brgr = atmel_uart_readl(port, ATMEL_US_BRGR);\n\t\t}\n\n\t\tatmel_uart_writel(port, ATMEL_US_TTGR, iso7816conf->tg);\n\t\tatmel_uart_writel(port, ATMEL_US_BRGR, cd);\n\t\tatmel_uart_writel(port, ATMEL_US_FIDI, fidi);\n\n\t\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXDIS | ATMEL_US_RXEN);\n\t\tatmel_port->tx_done_mask = ATMEL_US_TXEMPTY | ATMEL_US_NACK | ATMEL_US_ITERATION;\n\t} else {\n\t\tdev_dbg(port->dev, \"Setting UART back to RS232\\n\");\n\t\t \n\t\tmode = atmel_port->backup_mode;\n\t\tmemset(iso7816conf, 0, sizeof(struct serial_iso7816));\n\t\tatmel_uart_writel(port, ATMEL_US_TTGR, 0);\n\t\tatmel_uart_writel(port, ATMEL_US_BRGR, atmel_port->backup_brgr);\n\t\tatmel_uart_writel(port, ATMEL_US_FIDI, 0x174);\n\n\t\tif (atmel_use_pdc_tx(port))\n\t\t\tatmel_port->tx_done_mask = ATMEL_US_ENDTX |\n\t\t\t\t\t\t   ATMEL_US_TXBUFE;\n\t\telse\n\t\t\tatmel_port->tx_done_mask = ATMEL_US_TXRDY;\n\t}\n\n\tport->iso7816 = *iso7816conf;\n\n\tatmel_uart_writel(port, ATMEL_US_MR, mode);\n\nerr_out:\n\t \n\tatmel_uart_writel(port, ATMEL_US_IER, atmel_port->tx_done_mask);\n\n\treturn ret;\n}\n\n \nstatic u_int atmel_tx_empty(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\tif (atmel_port->tx_stopped)\n\t\treturn TIOCSER_TEMT;\n\treturn (atmel_uart_readl(port, ATMEL_US_CSR) & ATMEL_US_TXEMPTY) ?\n\t\tTIOCSER_TEMT :\n\t\t0;\n}\n\n \nstatic void atmel_set_mctrl(struct uart_port *port, u_int mctrl)\n{\n\tunsigned int control = 0;\n\tunsigned int mode = atmel_uart_readl(port, ATMEL_US_MR);\n\tunsigned int rts_paused, rts_ready;\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\t \n\tif (port->rs485.flags & SER_RS485_ENABLED) {\n\t\tatmel_uart_writel(port, ATMEL_US_TTGR,\n\t\t\t\t  port->rs485.delay_rts_after_send);\n\t\tmode &= ~ATMEL_US_USMODE;\n\t\tmode |= ATMEL_US_USMODE_RS485;\n\t}\n\n\t \n\tif ((mode & ATMEL_US_USMODE) == ATMEL_US_USMODE_HWHS) {\n\t\t \n\t\trts_paused = ATMEL_US_RTSEN;\n\n\t\t \n\t\trts_ready = ATMEL_US_RTSDIS;\n\t} else {\n\t\t \n\t\trts_paused = ATMEL_US_RTSDIS;\n\n\t\t \n\t\trts_ready = ATMEL_US_RTSEN;\n\t}\n\n\tif (mctrl & TIOCM_RTS)\n\t\tcontrol |= rts_ready;\n\telse\n\t\tcontrol |= rts_paused;\n\n\tif (mctrl & TIOCM_DTR)\n\t\tcontrol |= ATMEL_US_DTREN;\n\telse\n\t\tcontrol |= ATMEL_US_DTRDIS;\n\n\tatmel_uart_writel(port, ATMEL_US_CR, control);\n\n\tmctrl_gpio_set(atmel_port->gpios, mctrl);\n\n\t \n\tmode &= ~ATMEL_US_CHMODE;\n\tif (mctrl & TIOCM_LOOP)\n\t\tmode |= ATMEL_US_CHMODE_LOC_LOOP;\n\telse\n\t\tmode |= ATMEL_US_CHMODE_NORMAL;\n\n\tatmel_uart_writel(port, ATMEL_US_MR, mode);\n}\n\n \nstatic u_int atmel_get_mctrl(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tunsigned int ret = 0, status;\n\n\tstatus = atmel_uart_readl(port, ATMEL_US_CSR);\n\n\t \n\tif (!(status & ATMEL_US_DCD))\n\t\tret |= TIOCM_CD;\n\tif (!(status & ATMEL_US_CTS))\n\t\tret |= TIOCM_CTS;\n\tif (!(status & ATMEL_US_DSR))\n\t\tret |= TIOCM_DSR;\n\tif (!(status & ATMEL_US_RI))\n\t\tret |= TIOCM_RI;\n\n\treturn mctrl_gpio_get(atmel_port->gpios, &ret);\n}\n\n \nstatic void atmel_stop_tx(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tbool is_pdc = atmel_use_pdc_tx(port);\n\tbool is_dma = is_pdc || atmel_use_dma_tx(port);\n\n\tif (is_pdc) {\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTDIS);\n\t}\n\n\tif (is_dma) {\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXDIS);\n\t\tatmel_port->tx_stopped = true;\n\t}\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_IDR, atmel_port->tx_done_mask);\n\n\tif (atmel_uart_is_half_duplex(port))\n\t\tif (!atomic_read(&atmel_port->tasklet_shutdown))\n\t\t\tatmel_start_rx(port);\n}\n\n \nstatic void atmel_start_tx(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tbool is_pdc = atmel_use_pdc_tx(port);\n\tbool is_dma = is_pdc || atmel_use_dma_tx(port);\n\n\tif (is_pdc && (atmel_uart_readl(port, ATMEL_PDC_PTSR)\n\t\t\t\t       & ATMEL_PDC_TXTEN))\n\t\t \n\t\treturn;\n\n\tif (is_dma && atmel_uart_is_half_duplex(port))\n\t\tatmel_stop_rx(port);\n\n\tif (is_pdc) {\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);\n\t}\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_IER, atmel_port->tx_done_mask);\n\n\tif (is_dma) {\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN);\n\t\tatmel_port->tx_stopped = false;\n\t}\n}\n\n \nstatic void atmel_start_rx(struct uart_port *port)\n{\n\t \n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA);\n\n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RXEN);\n\n\tif (atmel_use_pdc_rx(port)) {\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_IER,\n\t\t\t\t  ATMEL_US_ENDRX | ATMEL_US_TIMEOUT |\n\t\t\t\t  port->read_status_mask);\n\t\tatmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_RXTEN);\n\t} else {\n\t\tatmel_uart_writel(port, ATMEL_US_IER, ATMEL_US_RXRDY);\n\t}\n}\n\n \nstatic void atmel_stop_rx(struct uart_port *port)\n{\n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RXDIS);\n\n\tif (atmel_use_pdc_rx(port)) {\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS);\n\t\tatmel_uart_writel(port, ATMEL_US_IDR,\n\t\t\t\t  ATMEL_US_ENDRX | ATMEL_US_TIMEOUT |\n\t\t\t\t  port->read_status_mask);\n\t} else {\n\t\tatmel_uart_writel(port, ATMEL_US_IDR, ATMEL_US_RXRDY);\n\t}\n}\n\n \nstatic void atmel_enable_ms(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tuint32_t ier = 0;\n\n\t \n\tif (atmel_port->ms_irq_enabled)\n\t\treturn;\n\n\tatmel_port->ms_irq_enabled = true;\n\n\tif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_CTS))\n\t\tier |= ATMEL_US_CTSIC;\n\n\tif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_DSR))\n\t\tier |= ATMEL_US_DSRIC;\n\n\tif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_RI))\n\t\tier |= ATMEL_US_RIIC;\n\n\tif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_DCD))\n\t\tier |= ATMEL_US_DCDIC;\n\n\tatmel_uart_writel(port, ATMEL_US_IER, ier);\n\n\tmctrl_gpio_enable_ms(atmel_port->gpios);\n}\n\n \nstatic void atmel_disable_ms(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tuint32_t idr = 0;\n\n\t \n\tif (!atmel_port->ms_irq_enabled)\n\t\treturn;\n\n\tatmel_port->ms_irq_enabled = false;\n\n\tmctrl_gpio_disable_ms(atmel_port->gpios);\n\n\tif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_CTS))\n\t\tidr |= ATMEL_US_CTSIC;\n\n\tif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_DSR))\n\t\tidr |= ATMEL_US_DSRIC;\n\n\tif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_RI))\n\t\tidr |= ATMEL_US_RIIC;\n\n\tif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_DCD))\n\t\tidr |= ATMEL_US_DCDIC;\n\n\tatmel_uart_writel(port, ATMEL_US_IDR, idr);\n}\n\n \nstatic void atmel_break_ctl(struct uart_port *port, int break_state)\n{\n\tif (break_state != 0)\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STTBRK);\n\telse\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STPBRK);\n}\n\n \nstatic void\natmel_buffer_rx_char(struct uart_port *port, unsigned int status,\n\t\t     unsigned int ch)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct circ_buf *ring = &atmel_port->rx_ring;\n\tstruct atmel_uart_char *c;\n\n\tif (!CIRC_SPACE(ring->head, ring->tail, ATMEL_SERIAL_RINGSIZE))\n\t\t \n\t\treturn;\n\n\tc = &((struct atmel_uart_char *)ring->buf)[ring->head];\n\tc->status\t= status;\n\tc->ch\t\t= ch;\n\n\t \n\tsmp_wmb();\n\n\tring->head = (ring->head + 1) & (ATMEL_SERIAL_RINGSIZE - 1);\n}\n\n \nstatic void atmel_pdc_rxerr(struct uart_port *port, unsigned int status)\n{\n\t \n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA);\n\n\tif (status & ATMEL_US_RXBRK) {\n\t\t \n\t\tstatus &= ~(ATMEL_US_PARE | ATMEL_US_FRAME);\n\t\tport->icount.brk++;\n\t}\n\tif (status & ATMEL_US_PARE)\n\t\tport->icount.parity++;\n\tif (status & ATMEL_US_FRAME)\n\t\tport->icount.frame++;\n\tif (status & ATMEL_US_OVRE)\n\t\tport->icount.overrun++;\n}\n\n \nstatic void atmel_rx_chars(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tunsigned int status, ch;\n\n\tstatus = atmel_uart_readl(port, ATMEL_US_CSR);\n\twhile (status & ATMEL_US_RXRDY) {\n\t\tch = atmel_uart_read_char(port);\n\n\t\t \n\t\tif (unlikely(status & (ATMEL_US_PARE | ATMEL_US_FRAME\n\t\t\t\t       | ATMEL_US_OVRE | ATMEL_US_RXBRK)\n\t\t\t     || atmel_port->break_active)) {\n\n\t\t\t \n\t\t\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA);\n\n\t\t\tif (status & ATMEL_US_RXBRK\n\t\t\t    && !atmel_port->break_active) {\n\t\t\t\tatmel_port->break_active = 1;\n\t\t\t\tatmel_uart_writel(port, ATMEL_US_IER,\n\t\t\t\t\t\t  ATMEL_US_RXBRK);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tatmel_uart_writel(port, ATMEL_US_IDR,\n\t\t\t\t\t\t  ATMEL_US_RXBRK);\n\t\t\t\tstatus &= ~ATMEL_US_RXBRK;\n\t\t\t\tatmel_port->break_active = 0;\n\t\t\t}\n\t\t}\n\n\t\tatmel_buffer_rx_char(port, status, ch);\n\t\tstatus = atmel_uart_readl(port, ATMEL_US_CSR);\n\t}\n\n\tatmel_tasklet_schedule(atmel_port, &atmel_port->tasklet_rx);\n}\n\n \nstatic void atmel_tx_chars(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tbool pending;\n\tu8 ch;\n\n\tpending = uart_port_tx(port, ch,\n\t\tatmel_uart_readl(port, ATMEL_US_CSR) & ATMEL_US_TXRDY,\n\t\tatmel_uart_write_char(port, ch));\n\tif (pending) {\n\t\t \n\t\tatmel_port->tx_done_mask |= ATMEL_US_TXRDY;\n\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_IER,\n\t\t\t\t  atmel_port->tx_done_mask);\n\t} else {\n\t\tif (atmel_uart_is_half_duplex(port))\n\t\t\tatmel_port->tx_done_mask &= ~ATMEL_US_TXRDY;\n\t}\n}\n\nstatic void atmel_complete_tx_dma(void *arg)\n{\n\tstruct atmel_uart_port *atmel_port = arg;\n\tstruct uart_port *port = &atmel_port->uart;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tstruct dma_chan *chan = atmel_port->chan_tx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (chan)\n\t\tdmaengine_terminate_all(chan);\n\tuart_xmit_advance(port, atmel_port->tx_len);\n\n\tspin_lock(&atmel_port->lock_tx);\n\tasync_tx_ack(atmel_port->desc_tx);\n\tatmel_port->cookie_tx = -EINVAL;\n\tatmel_port->desc_tx = NULL;\n\tspin_unlock(&atmel_port->lock_tx);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\t \n\tif (!uart_circ_empty(xmit))\n\t\tatmel_tasklet_schedule(atmel_port, &atmel_port->tasklet_tx);\n\telse if (atmel_uart_is_half_duplex(port)) {\n\t\t \n\t\tatmel_port->hd_start_rx = true;\n\t\tatmel_uart_writel(port, ATMEL_US_IER,\n\t\t\t\t  atmel_port->tx_done_mask);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void atmel_release_tx_dma(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct dma_chan *chan = atmel_port->chan_tx;\n\n\tif (chan) {\n\t\tdmaengine_terminate_all(chan);\n\t\tdma_release_channel(chan);\n\t\tdma_unmap_sg(port->dev, &atmel_port->sg_tx, 1,\n\t\t\t\tDMA_TO_DEVICE);\n\t}\n\n\tatmel_port->desc_tx = NULL;\n\tatmel_port->chan_tx = NULL;\n\tatmel_port->cookie_tx = -EINVAL;\n}\n\n \nstatic void atmel_tx_dma(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tstruct dma_chan *chan = atmel_port->chan_tx;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct scatterlist sgl[2], *sg, *sg_tx = &atmel_port->sg_tx;\n\tunsigned int tx_len, part1_len, part2_len, sg_len;\n\tdma_addr_t phys_addr;\n\n\t \n\tif (atmel_port->desc_tx != NULL)\n\t\treturn;\n\n\tif (!uart_circ_empty(xmit) && !uart_tx_stopped(port)) {\n\t\t \n\t\ttx_len = CIRC_CNT_TO_END(xmit->head,\n\t\t\t\t\t xmit->tail,\n\t\t\t\t\t UART_XMIT_SIZE);\n\n\t\tif (atmel_port->fifo_size) {\n\t\t\t \n\t\t\tpart1_len = (tx_len & ~0x3);  \n\t\t\tpart2_len = (tx_len & 0x3);  \n\t\t} else {\n\t\t\t \n\t\t\tpart1_len = 0;\n\t\t\tpart2_len = tx_len;  \n\t\t}\n\n\t\tsg_init_table(sgl, 2);\n\t\tsg_len = 0;\n\t\tphys_addr = sg_dma_address(sg_tx) + xmit->tail;\n\t\tif (part1_len) {\n\t\t\tsg = &sgl[sg_len++];\n\t\t\tsg_dma_address(sg) = phys_addr;\n\t\t\tsg_dma_len(sg) = part1_len;\n\n\t\t\tphys_addr += part1_len;\n\t\t}\n\n\t\tif (part2_len) {\n\t\t\tsg = &sgl[sg_len++];\n\t\t\tsg_dma_address(sg) = phys_addr;\n\t\t\tsg_dma_len(sg) = part2_len;\n\t\t}\n\n\t\t \n\t\tatmel_port->tx_len = tx_len;\n\n\t\tdesc = dmaengine_prep_slave_sg(chan,\n\t\t\t\t\t       sgl,\n\t\t\t\t\t       sg_len,\n\t\t\t\t\t       DMA_MEM_TO_DEV,\n\t\t\t\t\t       DMA_PREP_INTERRUPT |\n\t\t\t\t\t       DMA_CTRL_ACK);\n\t\tif (!desc) {\n\t\t\tdev_err(port->dev, \"Failed to send via dma!\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tdma_sync_sg_for_device(port->dev, sg_tx, 1, DMA_TO_DEVICE);\n\n\t\tatmel_port->desc_tx = desc;\n\t\tdesc->callback = atmel_complete_tx_dma;\n\t\tdesc->callback_param = atmel_port;\n\t\tatmel_port->cookie_tx = dmaengine_submit(desc);\n\t\tif (dma_submit_error(atmel_port->cookie_tx)) {\n\t\t\tdev_err(port->dev, \"dma_submit_error %d\\n\",\n\t\t\t\tatmel_port->cookie_tx);\n\t\t\treturn;\n\t\t}\n\n\t\tdma_async_issue_pending(chan);\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n}\n\nstatic int atmel_prepare_tx_dma(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct device *mfd_dev = port->dev->parent;\n\tdma_cap_mask_t\t\tmask;\n\tstruct dma_slave_config config;\n\tint ret, nent;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\tatmel_port->chan_tx = dma_request_slave_channel(mfd_dev, \"tx\");\n\tif (atmel_port->chan_tx == NULL)\n\t\tgoto chan_err;\n\tdev_info(port->dev, \"using %s for tx DMA transfers\\n\",\n\t\tdma_chan_name(atmel_port->chan_tx));\n\n\tspin_lock_init(&atmel_port->lock_tx);\n\tsg_init_table(&atmel_port->sg_tx, 1);\n\t \n\tBUG_ON(!PAGE_ALIGNED(port->state->xmit.buf));\n\tsg_set_page(&atmel_port->sg_tx,\n\t\t\tvirt_to_page(port->state->xmit.buf),\n\t\t\tUART_XMIT_SIZE,\n\t\t\toffset_in_page(port->state->xmit.buf));\n\tnent = dma_map_sg(port->dev,\n\t\t\t\t&atmel_port->sg_tx,\n\t\t\t\t1,\n\t\t\t\tDMA_TO_DEVICE);\n\n\tif (!nent) {\n\t\tdev_dbg(port->dev, \"need to release resource of dma\\n\");\n\t\tgoto chan_err;\n\t} else {\n\t\tdev_dbg(port->dev, \"%s: mapped %d@%p to %pad\\n\", __func__,\n\t\t\tsg_dma_len(&atmel_port->sg_tx),\n\t\t\tport->state->xmit.buf,\n\t\t\t&sg_dma_address(&atmel_port->sg_tx));\n\t}\n\n\t \n\tmemset(&config, 0, sizeof(config));\n\tconfig.direction = DMA_MEM_TO_DEV;\n\tconfig.dst_addr_width = (atmel_port->fifo_size) ?\n\t\t\t\tDMA_SLAVE_BUSWIDTH_4_BYTES :\n\t\t\t\tDMA_SLAVE_BUSWIDTH_1_BYTE;\n\tconfig.dst_addr = port->mapbase + ATMEL_US_THR;\n\tconfig.dst_maxburst = 1;\n\n\tret = dmaengine_slave_config(atmel_port->chan_tx,\n\t\t\t\t     &config);\n\tif (ret) {\n\t\tdev_err(port->dev, \"DMA tx slave configuration failed\\n\");\n\t\tgoto chan_err;\n\t}\n\n\treturn 0;\n\nchan_err:\n\tdev_err(port->dev, \"TX channel not available, switch to pio\\n\");\n\tatmel_port->use_dma_tx = false;\n\tif (atmel_port->chan_tx)\n\t\tatmel_release_tx_dma(port);\n\treturn -EINVAL;\n}\n\nstatic void atmel_complete_rx_dma(void *arg)\n{\n\tstruct uart_port *port = arg;\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\tatmel_tasklet_schedule(atmel_port, &atmel_port->tasklet_rx);\n}\n\nstatic void atmel_release_rx_dma(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct dma_chan *chan = atmel_port->chan_rx;\n\n\tif (chan) {\n\t\tdmaengine_terminate_all(chan);\n\t\tdma_release_channel(chan);\n\t\tdma_unmap_sg(port->dev, &atmel_port->sg_rx, 1,\n\t\t\t\tDMA_FROM_DEVICE);\n\t}\n\n\tatmel_port->desc_rx = NULL;\n\tatmel_port->chan_rx = NULL;\n\tatmel_port->cookie_rx = -EINVAL;\n}\n\nstatic void atmel_rx_from_dma(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct tty_port *tport = &port->state->port;\n\tstruct circ_buf *ring = &atmel_port->rx_ring;\n\tstruct dma_chan *chan = atmel_port->chan_rx;\n\tstruct dma_tx_state state;\n\tenum dma_status dmastat;\n\tsize_t count;\n\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STTTO);\n\tdmastat = dmaengine_tx_status(chan,\n\t\t\t\tatmel_port->cookie_rx,\n\t\t\t\t&state);\n\t \n\tif (dmastat == DMA_ERROR) {\n\t\tdev_dbg(port->dev, \"Get residue error, restart tasklet\\n\");\n\t\tatmel_uart_writel(port, ATMEL_US_IER, ATMEL_US_TIMEOUT);\n\t\tatmel_tasklet_schedule(atmel_port, &atmel_port->tasklet_rx);\n\t\treturn;\n\t}\n\n\t \n\tdma_sync_sg_for_cpu(port->dev,\n\t\t\t    &atmel_port->sg_rx,\n\t\t\t    1,\n\t\t\t    DMA_FROM_DEVICE);\n\n\t \n\tring->head = sg_dma_len(&atmel_port->sg_rx) - state.residue;\n\tBUG_ON(ring->head > sg_dma_len(&atmel_port->sg_rx));\n\t \n\tif (ring->head < ring->tail) {\n\t\tcount = sg_dma_len(&atmel_port->sg_rx) - ring->tail;\n\n\t\ttty_insert_flip_string(tport, ring->buf + ring->tail, count);\n\t\tring->tail = 0;\n\t\tport->icount.rx += count;\n\t}\n\n\t \n\tif (ring->tail < ring->head) {\n\t\tcount = ring->head - ring->tail;\n\n\t\ttty_insert_flip_string(tport, ring->buf + ring->tail, count);\n\t\t \n\t\tif (ring->head >= sg_dma_len(&atmel_port->sg_rx))\n\t\t\tring->head = 0;\n\t\tring->tail = ring->head;\n\t\tport->icount.rx += count;\n\t}\n\n\t \n\tdma_sync_sg_for_device(port->dev,\n\t\t\t       &atmel_port->sg_rx,\n\t\t\t       1,\n\t\t\t       DMA_FROM_DEVICE);\n\n\ttty_flip_buffer_push(tport);\n\n\tatmel_uart_writel(port, ATMEL_US_IER, ATMEL_US_TIMEOUT);\n}\n\nstatic int atmel_prepare_rx_dma(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct device *mfd_dev = port->dev->parent;\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cap_mask_t\t\tmask;\n\tstruct dma_slave_config config;\n\tstruct circ_buf\t\t*ring;\n\tint ret, nent;\n\n\tring = &atmel_port->rx_ring;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_CYCLIC, mask);\n\n\tatmel_port->chan_rx = dma_request_slave_channel(mfd_dev, \"rx\");\n\tif (atmel_port->chan_rx == NULL)\n\t\tgoto chan_err;\n\tdev_info(port->dev, \"using %s for rx DMA transfers\\n\",\n\t\tdma_chan_name(atmel_port->chan_rx));\n\n\tspin_lock_init(&atmel_port->lock_rx);\n\tsg_init_table(&atmel_port->sg_rx, 1);\n\t \n\tBUG_ON(!PAGE_ALIGNED(ring->buf));\n\tsg_set_page(&atmel_port->sg_rx,\n\t\t    virt_to_page(ring->buf),\n\t\t    sizeof(struct atmel_uart_char) * ATMEL_SERIAL_RINGSIZE,\n\t\t    offset_in_page(ring->buf));\n\tnent = dma_map_sg(port->dev,\n\t\t\t  &atmel_port->sg_rx,\n\t\t\t  1,\n\t\t\t  DMA_FROM_DEVICE);\n\n\tif (!nent) {\n\t\tdev_dbg(port->dev, \"need to release resource of dma\\n\");\n\t\tgoto chan_err;\n\t} else {\n\t\tdev_dbg(port->dev, \"%s: mapped %d@%p to %pad\\n\", __func__,\n\t\t\tsg_dma_len(&atmel_port->sg_rx),\n\t\t\tring->buf,\n\t\t\t&sg_dma_address(&atmel_port->sg_rx));\n\t}\n\n\t \n\tmemset(&config, 0, sizeof(config));\n\tconfig.direction = DMA_DEV_TO_MEM;\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tconfig.src_addr = port->mapbase + ATMEL_US_RHR;\n\tconfig.src_maxburst = 1;\n\n\tret = dmaengine_slave_config(atmel_port->chan_rx,\n\t\t\t\t     &config);\n\tif (ret) {\n\t\tdev_err(port->dev, \"DMA rx slave configuration failed\\n\");\n\t\tgoto chan_err;\n\t}\n\t \n\tdesc = dmaengine_prep_dma_cyclic(atmel_port->chan_rx,\n\t\t\t\t\t sg_dma_address(&atmel_port->sg_rx),\n\t\t\t\t\t sg_dma_len(&atmel_port->sg_rx),\n\t\t\t\t\t sg_dma_len(&atmel_port->sg_rx)/2,\n\t\t\t\t\t DMA_DEV_TO_MEM,\n\t\t\t\t\t DMA_PREP_INTERRUPT);\n\tif (!desc) {\n\t\tdev_err(port->dev, \"Preparing DMA cyclic failed\\n\");\n\t\tgoto chan_err;\n\t}\n\tdesc->callback = atmel_complete_rx_dma;\n\tdesc->callback_param = port;\n\tatmel_port->desc_rx = desc;\n\tatmel_port->cookie_rx = dmaengine_submit(desc);\n\tif (dma_submit_error(atmel_port->cookie_rx)) {\n\t\tdev_err(port->dev, \"dma_submit_error %d\\n\",\n\t\t\tatmel_port->cookie_rx);\n\t\tgoto chan_err;\n\t}\n\n\tdma_async_issue_pending(atmel_port->chan_rx);\n\n\treturn 0;\n\nchan_err:\n\tdev_err(port->dev, \"RX channel not available, switch to pio\\n\");\n\tatmel_port->use_dma_rx = false;\n\tif (atmel_port->chan_rx)\n\t\tatmel_release_rx_dma(port);\n\treturn -EINVAL;\n}\n\nstatic void atmel_uart_timer_callback(struct timer_list *t)\n{\n\tstruct atmel_uart_port *atmel_port = from_timer(atmel_port, t,\n\t\t\t\t\t\t\tuart_timer);\n\tstruct uart_port *port = &atmel_port->uart;\n\n\tif (!atomic_read(&atmel_port->tasklet_shutdown)) {\n\t\ttasklet_schedule(&atmel_port->tasklet_rx);\n\t\tmod_timer(&atmel_port->uart_timer,\n\t\t\t  jiffies + uart_poll_timeout(port));\n\t}\n}\n\n \nstatic void\natmel_handle_receive(struct uart_port *port, unsigned int pending)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\tif (atmel_use_pdc_rx(port)) {\n\t\t \n\t\tif (pending & (ATMEL_US_ENDRX | ATMEL_US_TIMEOUT)) {\n\t\t\tatmel_uart_writel(port, ATMEL_US_IDR,\n\t\t\t\t\t  (ATMEL_US_ENDRX | ATMEL_US_TIMEOUT));\n\t\t\tatmel_tasklet_schedule(atmel_port,\n\t\t\t\t\t       &atmel_port->tasklet_rx);\n\t\t}\n\n\t\tif (pending & (ATMEL_US_RXBRK | ATMEL_US_OVRE |\n\t\t\t\tATMEL_US_FRAME | ATMEL_US_PARE))\n\t\t\tatmel_pdc_rxerr(port, pending);\n\t}\n\n\tif (atmel_use_dma_rx(port)) {\n\t\tif (pending & ATMEL_US_TIMEOUT) {\n\t\t\tatmel_uart_writel(port, ATMEL_US_IDR,\n\t\t\t\t\t  ATMEL_US_TIMEOUT);\n\t\t\tatmel_tasklet_schedule(atmel_port,\n\t\t\t\t\t       &atmel_port->tasklet_rx);\n\t\t}\n\t}\n\n\t \n\tif (pending & ATMEL_US_RXRDY)\n\t\tatmel_rx_chars(port);\n\telse if (pending & ATMEL_US_RXBRK) {\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA);\n\t\tatmel_uart_writel(port, ATMEL_US_IDR, ATMEL_US_RXBRK);\n\t\tatmel_port->break_active = 0;\n\t}\n}\n\n \nstatic void\natmel_handle_transmit(struct uart_port *port, unsigned int pending)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\tif (pending & atmel_port->tx_done_mask) {\n\t\tatmel_uart_writel(port, ATMEL_US_IDR,\n\t\t\t\t  atmel_port->tx_done_mask);\n\n\t\t \n\t\tif (atmel_port->hd_start_rx) {\n\t\t\tif (!(atmel_uart_readl(port, ATMEL_US_CSR)\n\t\t\t\t\t& ATMEL_US_TXEMPTY))\n\t\t\t\tdev_warn(port->dev, \"Should start RX, but TX fifo is not empty\\n\");\n\n\t\t\tatmel_port->hd_start_rx = false;\n\t\t\tatmel_start_rx(port);\n\t\t}\n\n\t\tatmel_tasklet_schedule(atmel_port, &atmel_port->tasklet_tx);\n\t}\n}\n\n \nstatic void\natmel_handle_status(struct uart_port *port, unsigned int pending,\n\t\t    unsigned int status)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tunsigned int status_change;\n\n\tif (pending & (ATMEL_US_RIIC | ATMEL_US_DSRIC | ATMEL_US_DCDIC\n\t\t\t\t| ATMEL_US_CTSIC)) {\n\t\tstatus_change = status ^ atmel_port->irq_status_prev;\n\t\tatmel_port->irq_status_prev = status;\n\n\t\tif (status_change & (ATMEL_US_RI | ATMEL_US_DSR\n\t\t\t\t\t| ATMEL_US_DCD | ATMEL_US_CTS)) {\n\t\t\t \n\t\t\tif (status_change & ATMEL_US_RI)\n\t\t\t\tport->icount.rng++;\n\t\t\tif (status_change & ATMEL_US_DSR)\n\t\t\t\tport->icount.dsr++;\n\t\t\tif (status_change & ATMEL_US_DCD)\n\t\t\t\tuart_handle_dcd_change(port, !(status & ATMEL_US_DCD));\n\t\t\tif (status_change & ATMEL_US_CTS)\n\t\t\t\tuart_handle_cts_change(port, !(status & ATMEL_US_CTS));\n\n\t\t\twake_up_interruptible(&port->state->port.delta_msr_wait);\n\t\t}\n\t}\n\n\tif (pending & (ATMEL_US_NACK | ATMEL_US_ITERATION))\n\t\tdev_dbg(port->dev, \"ISO7816 ERROR (0x%08x)\\n\", pending);\n}\n\n \nstatic irqreturn_t atmel_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tunsigned int status, pending, mask, pass_counter = 0;\n\n\tspin_lock(&atmel_port->lock_suspended);\n\n\tdo {\n\t\tstatus = atmel_uart_readl(port, ATMEL_US_CSR);\n\t\tmask = atmel_uart_readl(port, ATMEL_US_IMR);\n\t\tpending = status & mask;\n\t\tif (!pending)\n\t\t\tbreak;\n\n\t\tif (atmel_port->suspended) {\n\t\t\tatmel_port->pending |= pending;\n\t\t\tatmel_port->pending_status = status;\n\t\t\tatmel_uart_writel(port, ATMEL_US_IDR, mask);\n\t\t\tpm_system_wakeup();\n\t\t\tbreak;\n\t\t}\n\n\t\tatmel_handle_receive(port, pending);\n\t\tatmel_handle_status(port, pending, status);\n\t\tatmel_handle_transmit(port, pending);\n\t} while (pass_counter++ < ATMEL_ISR_PASS_LIMIT);\n\n\tspin_unlock(&atmel_port->lock_suspended);\n\n\treturn pass_counter ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic void atmel_release_tx_pdc(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;\n\n\tdma_unmap_single(port->dev,\n\t\t\t pdc->dma_addr,\n\t\t\t pdc->dma_size,\n\t\t\t DMA_TO_DEVICE);\n}\n\n \nstatic void atmel_tx_pdc(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tstruct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;\n\tint count;\n\n\t \n\tif (atmel_uart_readl(port, ATMEL_PDC_TCR))\n\t\treturn;\n\tuart_xmit_advance(port, pdc->ofs);\n\tpdc->ofs = 0;\n\n\t \n\n\t \n\tatmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTDIS);\n\n\tif (!uart_circ_empty(xmit) && !uart_tx_stopped(port)) {\n\t\tdma_sync_single_for_device(port->dev,\n\t\t\t\t\t   pdc->dma_addr,\n\t\t\t\t\t   pdc->dma_size,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\n\t\tcount = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\t\tpdc->ofs = count;\n\n\t\tatmel_uart_writel(port, ATMEL_PDC_TPR,\n\t\t\t\t  pdc->dma_addr + xmit->tail);\n\t\tatmel_uart_writel(port, ATMEL_PDC_TCR, count);\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_IER,\n\t\t\t\t  atmel_port->tx_done_mask);\n\t} else {\n\t\tif (atmel_uart_is_half_duplex(port)) {\n\t\t\t \n\t\t\tatmel_start_rx(port);\n\t\t}\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n}\n\nstatic int atmel_prepare_tx_pdc(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\tpdc->buf = xmit->buf;\n\tpdc->dma_addr = dma_map_single(port->dev,\n\t\t\t\t\tpdc->buf,\n\t\t\t\t\tUART_XMIT_SIZE,\n\t\t\t\t\tDMA_TO_DEVICE);\n\tpdc->dma_size = UART_XMIT_SIZE;\n\tpdc->ofs = 0;\n\n\treturn 0;\n}\n\nstatic void atmel_rx_from_ring(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct circ_buf *ring = &atmel_port->rx_ring;\n\tunsigned int status;\n\tu8 flg;\n\n\twhile (ring->head != ring->tail) {\n\t\tstruct atmel_uart_char c;\n\n\t\t \n\t\tsmp_rmb();\n\n\t\tc = ((struct atmel_uart_char *)ring->buf)[ring->tail];\n\n\t\tring->tail = (ring->tail + 1) & (ATMEL_SERIAL_RINGSIZE - 1);\n\n\t\tport->icount.rx++;\n\t\tstatus = c.status;\n\t\tflg = TTY_NORMAL;\n\n\t\t \n\t\tif (unlikely(status & (ATMEL_US_PARE | ATMEL_US_FRAME\n\t\t\t\t       | ATMEL_US_OVRE | ATMEL_US_RXBRK))) {\n\t\t\tif (status & ATMEL_US_RXBRK) {\n\t\t\t\t \n\t\t\t\tstatus &= ~(ATMEL_US_PARE | ATMEL_US_FRAME);\n\n\t\t\t\tport->icount.brk++;\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (status & ATMEL_US_PARE)\n\t\t\t\tport->icount.parity++;\n\t\t\tif (status & ATMEL_US_FRAME)\n\t\t\t\tport->icount.frame++;\n\t\t\tif (status & ATMEL_US_OVRE)\n\t\t\t\tport->icount.overrun++;\n\n\t\t\tstatus &= port->read_status_mask;\n\n\t\t\tif (status & ATMEL_US_RXBRK)\n\t\t\t\tflg = TTY_BREAK;\n\t\t\telse if (status & ATMEL_US_PARE)\n\t\t\t\tflg = TTY_PARITY;\n\t\t\telse if (status & ATMEL_US_FRAME)\n\t\t\t\tflg = TTY_FRAME;\n\t\t}\n\n\n\t\tif (uart_handle_sysrq_char(port, c.ch))\n\t\t\tcontinue;\n\n\t\tuart_insert_char(port, status, ATMEL_US_OVRE, c.ch, flg);\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic void atmel_release_rx_pdc(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct atmel_dma_buffer *pdc = &atmel_port->pdc_rx[i];\n\n\t\tdma_unmap_single(port->dev,\n\t\t\t\t pdc->dma_addr,\n\t\t\t\t pdc->dma_size,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tkfree(pdc->buf);\n\t}\n}\n\nstatic void atmel_rx_from_pdc(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tstruct tty_port *tport = &port->state->port;\n\tstruct atmel_dma_buffer *pdc;\n\tint rx_idx = atmel_port->pdc_rx_idx;\n\tunsigned int head;\n\tunsigned int tail;\n\tunsigned int count;\n\n\tdo {\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STTTO);\n\n\t\tpdc = &atmel_port->pdc_rx[rx_idx];\n\t\thead = atmel_uart_readl(port, ATMEL_PDC_RPR) - pdc->dma_addr;\n\t\ttail = pdc->ofs;\n\n\t\t \n\t\thead = min(head, pdc->dma_size);\n\n\t\tif (likely(head != tail)) {\n\t\t\tdma_sync_single_for_cpu(port->dev, pdc->dma_addr,\n\t\t\t\t\tpdc->dma_size, DMA_FROM_DEVICE);\n\n\t\t\t \n\t\t\tcount = head - tail;\n\n\t\t\ttty_insert_flip_string(tport, pdc->buf + pdc->ofs,\n\t\t\t\t\t\tcount);\n\n\t\t\tdma_sync_single_for_device(port->dev, pdc->dma_addr,\n\t\t\t\t\tpdc->dma_size, DMA_FROM_DEVICE);\n\n\t\t\tport->icount.rx += count;\n\t\t\tpdc->ofs = head;\n\t\t}\n\n\t\t \n\t\tif (head >= pdc->dma_size) {\n\t\t\tpdc->ofs = 0;\n\t\t\tatmel_uart_writel(port, ATMEL_PDC_RNPR, pdc->dma_addr);\n\t\t\tatmel_uart_writel(port, ATMEL_PDC_RNCR, pdc->dma_size);\n\n\t\t\trx_idx = !rx_idx;\n\t\t\tatmel_port->pdc_rx_idx = rx_idx;\n\t\t}\n\t} while (head >= pdc->dma_size);\n\n\ttty_flip_buffer_push(tport);\n\n\tatmel_uart_writel(port, ATMEL_US_IER,\n\t\t\t  ATMEL_US_ENDRX | ATMEL_US_TIMEOUT);\n}\n\nstatic int atmel_prepare_rx_pdc(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct atmel_dma_buffer *pdc = &atmel_port->pdc_rx[i];\n\n\t\tpdc->buf = kmalloc(PDC_BUFFER_SIZE, GFP_KERNEL);\n\t\tif (pdc->buf == NULL) {\n\t\t\tif (i != 0) {\n\t\t\t\tdma_unmap_single(port->dev,\n\t\t\t\t\tatmel_port->pdc_rx[0].dma_addr,\n\t\t\t\t\tPDC_BUFFER_SIZE,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\tkfree(atmel_port->pdc_rx[0].buf);\n\t\t\t}\n\t\t\tatmel_port->use_pdc_rx = false;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpdc->dma_addr = dma_map_single(port->dev,\n\t\t\t\t\t\tpdc->buf,\n\t\t\t\t\t\tPDC_BUFFER_SIZE,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tpdc->dma_size = PDC_BUFFER_SIZE;\n\t\tpdc->ofs = 0;\n\t}\n\n\tatmel_port->pdc_rx_idx = 0;\n\n\tatmel_uart_writel(port, ATMEL_PDC_RPR, atmel_port->pdc_rx[0].dma_addr);\n\tatmel_uart_writel(port, ATMEL_PDC_RCR, PDC_BUFFER_SIZE);\n\n\tatmel_uart_writel(port, ATMEL_PDC_RNPR,\n\t\t\t  atmel_port->pdc_rx[1].dma_addr);\n\tatmel_uart_writel(port, ATMEL_PDC_RNCR, PDC_BUFFER_SIZE);\n\n\treturn 0;\n}\n\n \nstatic void atmel_tasklet_rx_func(struct tasklet_struct *t)\n{\n\tstruct atmel_uart_port *atmel_port = from_tasklet(atmel_port, t,\n\t\t\t\t\t\t\t  tasklet_rx);\n\tstruct uart_port *port = &atmel_port->uart;\n\n\t \n\tspin_lock(&port->lock);\n\tatmel_port->schedule_rx(port);\n\tspin_unlock(&port->lock);\n}\n\nstatic void atmel_tasklet_tx_func(struct tasklet_struct *t)\n{\n\tstruct atmel_uart_port *atmel_port = from_tasklet(atmel_port, t,\n\t\t\t\t\t\t\t  tasklet_tx);\n\tstruct uart_port *port = &atmel_port->uart;\n\n\t \n\tspin_lock(&port->lock);\n\tatmel_port->schedule_tx(port);\n\tspin_unlock(&port->lock);\n}\n\nstatic void atmel_init_property(struct atmel_uart_port *atmel_port,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\n\t \n\tif (of_property_read_bool(np, \"atmel,use-dma-rx\")) {\n\t\tif (of_property_read_bool(np, \"dmas\")) {\n\t\t\tatmel_port->use_dma_rx  = true;\n\t\t\tatmel_port->use_pdc_rx  = false;\n\t\t} else {\n\t\t\tatmel_port->use_dma_rx  = false;\n\t\t\tatmel_port->use_pdc_rx  = true;\n\t\t}\n\t} else {\n\t\tatmel_port->use_dma_rx  = false;\n\t\tatmel_port->use_pdc_rx  = false;\n\t}\n\n\tif (of_property_read_bool(np, \"atmel,use-dma-tx\")) {\n\t\tif (of_property_read_bool(np, \"dmas\")) {\n\t\t\tatmel_port->use_dma_tx  = true;\n\t\t\tatmel_port->use_pdc_tx  = false;\n\t\t} else {\n\t\t\tatmel_port->use_dma_tx  = false;\n\t\t\tatmel_port->use_pdc_tx  = true;\n\t\t}\n\t} else {\n\t\tatmel_port->use_dma_tx  = false;\n\t\tatmel_port->use_pdc_tx  = false;\n\t}\n}\n\nstatic void atmel_set_ops(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\tif (atmel_use_dma_rx(port)) {\n\t\tatmel_port->prepare_rx = &atmel_prepare_rx_dma;\n\t\tatmel_port->schedule_rx = &atmel_rx_from_dma;\n\t\tatmel_port->release_rx = &atmel_release_rx_dma;\n\t} else if (atmel_use_pdc_rx(port)) {\n\t\tatmel_port->prepare_rx = &atmel_prepare_rx_pdc;\n\t\tatmel_port->schedule_rx = &atmel_rx_from_pdc;\n\t\tatmel_port->release_rx = &atmel_release_rx_pdc;\n\t} else {\n\t\tatmel_port->prepare_rx = NULL;\n\t\tatmel_port->schedule_rx = &atmel_rx_from_ring;\n\t\tatmel_port->release_rx = NULL;\n\t}\n\n\tif (atmel_use_dma_tx(port)) {\n\t\tatmel_port->prepare_tx = &atmel_prepare_tx_dma;\n\t\tatmel_port->schedule_tx = &atmel_tx_dma;\n\t\tatmel_port->release_tx = &atmel_release_tx_dma;\n\t} else if (atmel_use_pdc_tx(port)) {\n\t\tatmel_port->prepare_tx = &atmel_prepare_tx_pdc;\n\t\tatmel_port->schedule_tx = &atmel_tx_pdc;\n\t\tatmel_port->release_tx = &atmel_release_tx_pdc;\n\t} else {\n\t\tatmel_port->prepare_tx = NULL;\n\t\tatmel_port->schedule_tx = &atmel_tx_chars;\n\t\tatmel_port->release_tx = NULL;\n\t}\n}\n\n \nstatic void atmel_get_ip_name(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tint name = atmel_uart_readl(port, ATMEL_US_NAME);\n\tu32 version;\n\tu32 usart, dbgu_uart, new_uart;\n\t \n\tusart = 0x55534152;\t \n\tdbgu_uart = 0x44424755;\t \n\tnew_uart = 0x55415254;\t \n\n\t \n\tatmel_port->has_frac_baudrate = false;\n\tatmel_port->has_hw_timer = false;\n\tatmel_port->is_usart = false;\n\n\tif (name == new_uart) {\n\t\tdev_dbg(port->dev, \"Uart with hw timer\");\n\t\tatmel_port->has_hw_timer = true;\n\t\tatmel_port->rtor = ATMEL_UA_RTOR;\n\t} else if (name == usart) {\n\t\tdev_dbg(port->dev, \"Usart\\n\");\n\t\tatmel_port->has_frac_baudrate = true;\n\t\tatmel_port->has_hw_timer = true;\n\t\tatmel_port->is_usart = true;\n\t\tatmel_port->rtor = ATMEL_US_RTOR;\n\t\tversion = atmel_uart_readl(port, ATMEL_US_VERSION);\n\t\tswitch (version) {\n\t\tcase 0x814:\t \n\t\t\tfallthrough;\n\t\tcase 0x701:\t \n\t\t\tatmel_port->fidi_min = 3;\n\t\t\tatmel_port->fidi_max = 65535;\n\t\t\tbreak;\n\t\tcase 0x502:\t \n\t\t\tatmel_port->fidi_min = 3;\n\t\t\tatmel_port->fidi_max = 2047;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tatmel_port->fidi_min = 1;\n\t\t\tatmel_port->fidi_max = 2047;\n\t\t}\n\t} else if (name == dbgu_uart) {\n\t\tdev_dbg(port->dev, \"Dbgu or uart without hw timer\\n\");\n\t} else {\n\t\t \n\t\tversion = atmel_uart_readl(port, ATMEL_US_VERSION);\n\t\tswitch (version) {\n\t\tcase 0x302:\n\t\tcase 0x10213:\n\t\tcase 0x10302:\n\t\t\tdev_dbg(port->dev, \"This version is usart\\n\");\n\t\t\tatmel_port->has_frac_baudrate = true;\n\t\t\tatmel_port->has_hw_timer = true;\n\t\t\tatmel_port->is_usart = true;\n\t\t\tatmel_port->rtor = ATMEL_US_RTOR;\n\t\t\tbreak;\n\t\tcase 0x203:\n\t\tcase 0x10202:\n\t\t\tdev_dbg(port->dev, \"This version is uart\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(port->dev, \"Not supported ip name nor version, set to uart\\n\");\n\t\t}\n\t}\n}\n\n \nstatic int atmel_startup(struct uart_port *port)\n{\n\tstruct platform_device *pdev = to_platform_device(port->dev);\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tint retval;\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_IDR, -1);\n\tatmel_port->ms_irq_enabled = false;\n\n\t \n\tretval = request_irq(port->irq, atmel_interrupt,\n\t\t\t     IRQF_SHARED | IRQF_COND_SUSPEND,\n\t\t\t     dev_name(&pdev->dev), port);\n\tif (retval) {\n\t\tdev_err(port->dev, \"atmel_startup - Can't get irq\\n\");\n\t\treturn retval;\n\t}\n\n\tatomic_set(&atmel_port->tasklet_shutdown, 0);\n\ttasklet_setup(&atmel_port->tasklet_rx, atmel_tasklet_rx_func);\n\ttasklet_setup(&atmel_port->tasklet_tx, atmel_tasklet_tx_func);\n\n\t \n\tatmel_init_property(atmel_port, pdev);\n\tatmel_set_ops(port);\n\n\tif (atmel_port->prepare_rx) {\n\t\tretval = atmel_port->prepare_rx(port);\n\t\tif (retval < 0)\n\t\t\tatmel_set_ops(port);\n\t}\n\n\tif (atmel_port->prepare_tx) {\n\t\tretval = atmel_port->prepare_tx(port);\n\t\tif (retval < 0)\n\t\t\tatmel_set_ops(port);\n\t}\n\n\t \n\tif (atmel_port->fifo_size) {\n\t\tunsigned int txrdym = ATMEL_US_ONE_DATA;\n\t\tunsigned int rxrdym = ATMEL_US_ONE_DATA;\n\t\tunsigned int fmr;\n\n\t\tatmel_uart_writel(port, ATMEL_US_CR,\n\t\t\t\t  ATMEL_US_FIFOEN |\n\t\t\t\t  ATMEL_US_RXFCLR |\n\t\t\t\t  ATMEL_US_TXFLCLR);\n\n\t\tif (atmel_use_dma_tx(port))\n\t\t\ttxrdym = ATMEL_US_FOUR_DATA;\n\n\t\tfmr = ATMEL_US_TXRDYM(txrdym) | ATMEL_US_RXRDYM(rxrdym);\n\t\tif (atmel_port->rts_high &&\n\t\t    atmel_port->rts_low)\n\t\t\tfmr |=\tATMEL_US_FRTSC |\n\t\t\t\tATMEL_US_RXFTHRES(atmel_port->rts_high) |\n\t\t\t\tATMEL_US_RXFTHRES2(atmel_port->rts_low);\n\n\t\tatmel_uart_writel(port, ATMEL_US_FMR, fmr);\n\t}\n\n\t \n\tatmel_port->irq_status_prev = atmel_uart_readl(port, ATMEL_US_CSR);\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);\n\t \n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN | ATMEL_US_RXEN);\n\tatmel_port->tx_stopped = false;\n\n\ttimer_setup(&atmel_port->uart_timer, atmel_uart_timer_callback, 0);\n\n\tif (atmel_use_pdc_rx(port)) {\n\t\t \n\t\tif (!atmel_port->has_hw_timer) {\n\t\t\tmod_timer(&atmel_port->uart_timer,\n\t\t\t\t\tjiffies + uart_poll_timeout(port));\n\t\t \n\t\t} else {\n\t\t\tatmel_uart_writel(port, atmel_port->rtor,\n\t\t\t\t\t  PDC_RX_TIMEOUT);\n\t\t\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STTTO);\n\n\t\t\tatmel_uart_writel(port, ATMEL_US_IER,\n\t\t\t\t\t  ATMEL_US_ENDRX | ATMEL_US_TIMEOUT);\n\t\t}\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_RXTEN);\n\t} else if (atmel_use_dma_rx(port)) {\n\t\t \n\t\tif (!atmel_port->has_hw_timer) {\n\t\t\tmod_timer(&atmel_port->uart_timer,\n\t\t\t\t\tjiffies + uart_poll_timeout(port));\n\t\t \n\t\t} else {\n\t\t\tatmel_uart_writel(port, atmel_port->rtor,\n\t\t\t\t\t  PDC_RX_TIMEOUT);\n\t\t\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STTTO);\n\n\t\t\tatmel_uart_writel(port, ATMEL_US_IER,\n\t\t\t\t\t  ATMEL_US_TIMEOUT);\n\t\t}\n\t} else {\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_IER, ATMEL_US_RXRDY);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void atmel_flush_buffer(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\tif (atmel_use_pdc_tx(port)) {\n\t\tatmel_uart_writel(port, ATMEL_PDC_TCR, 0);\n\t\tatmel_port->pdc_tx.ofs = 0;\n\t}\n\t \n\tatmel_port->tx_len = 0;\n}\n\n \nstatic void atmel_shutdown(struct uart_port *port)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\t \n\tatmel_disable_ms(port);\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_IDR, -1);\n\n\t \n\tatomic_inc(&atmel_port->tasklet_shutdown);\n\n\t \n\tdel_timer_sync(&atmel_port->uart_timer);\n\n\t \n\tsynchronize_irq(port->irq);\n\n\t \n\ttasklet_kill(&atmel_port->tasklet_rx);\n\ttasklet_kill(&atmel_port->tasklet_tx);\n\n\t \n\tatmel_stop_rx(port);\n\tatmel_stop_tx(port);\n\n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA);\n\n\t \n\tif (atmel_port->release_rx)\n\t\tatmel_port->release_rx(port);\n\tif (atmel_port->release_tx)\n\t\tatmel_port->release_tx(port);\n\n\t \n\tatmel_port->rx_ring.head = 0;\n\tatmel_port->rx_ring.tail = 0;\n\n\t \n\tfree_irq(port->irq, port);\n\n\tatmel_flush_buffer(port);\n}\n\n \nstatic void atmel_serial_pm(struct uart_port *port, unsigned int state,\n\t\t\t    unsigned int oldstate)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\tswitch (state) {\n\tcase UART_PM_STATE_ON:\n\t\t \n\t\tclk_prepare_enable(atmel_port->clk);\n\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_IER, atmel_port->backup_imr);\n\t\tbreak;\n\tcase UART_PM_STATE_OFF:\n\t\t \n\t\tatmel_port->backup_imr = atmel_uart_readl(port, ATMEL_US_IMR);\n\t\tatmel_uart_writel(port, ATMEL_US_IDR, -1);\n\n\t\t \n\t\tclk_disable_unprepare(atmel_port->clk);\n\t\tif (__clk_is_enabled(atmel_port->gclk))\n\t\t\tclk_disable_unprepare(atmel_port->gclk);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(port->dev, \"atmel_serial: unknown pm %d\\n\", state);\n\t}\n}\n\n \nstatic void atmel_set_termios(struct uart_port *port,\n\t\t\t      struct ktermios *termios,\n\t\t\t      const struct ktermios *old)\n{\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tunsigned long flags;\n\tunsigned int old_mode, mode, imr, quot, div, cd, fp = 0;\n\tunsigned int baud, actual_baud, gclk_rate;\n\tint ret;\n\n\t \n\tmode = old_mode = atmel_uart_readl(port, ATMEL_US_MR);\n\n\t \n\tif (atmel_port->is_usart)\n\t\tmode &= ~(ATMEL_US_NBSTOP | ATMEL_US_PAR | ATMEL_US_CHRL |\n\t\t\t  ATMEL_US_USCLKS | ATMEL_US_USMODE);\n\telse\n\t\tmode &= ~(ATMEL_UA_BRSRCCK | ATMEL_US_PAR | ATMEL_UA_FILTER);\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\n\n\t \n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tmode |= ATMEL_US_CHRL_5;\n\t\tbreak;\n\tcase CS6:\n\t\tmode |= ATMEL_US_CHRL_6;\n\t\tbreak;\n\tcase CS7:\n\t\tmode |= ATMEL_US_CHRL_7;\n\t\tbreak;\n\tdefault:\n\t\tmode |= ATMEL_US_CHRL_8;\n\t\tbreak;\n\t}\n\n\t \n\tif (termios->c_cflag & CSTOPB)\n\t\tmode |= ATMEL_US_NBSTOP_2;\n\n\t \n\tif (termios->c_cflag & PARENB) {\n\t\t \n\t\tif (termios->c_cflag & CMSPAR) {\n\t\t\tif (termios->c_cflag & PARODD)\n\t\t\t\tmode |= ATMEL_US_PAR_MARK;\n\t\t\telse\n\t\t\t\tmode |= ATMEL_US_PAR_SPACE;\n\t\t} else if (termios->c_cflag & PARODD)\n\t\t\tmode |= ATMEL_US_PAR_ODD;\n\t\telse\n\t\t\tmode |= ATMEL_US_PAR_EVEN;\n\t} else\n\t\tmode |= ATMEL_US_PAR_NONE;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tport->read_status_mask = ATMEL_US_OVRE;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= (ATMEL_US_FRAME | ATMEL_US_PARE);\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tport->read_status_mask |= ATMEL_US_RXBRK;\n\n\tif (atmel_use_pdc_rx(port))\n\t\t \n\t\tatmel_uart_writel(port, ATMEL_US_IER, port->read_status_mask);\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= (ATMEL_US_FRAME | ATMEL_US_PARE);\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= ATMEL_US_RXBRK;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= ATMEL_US_OVRE;\n\t}\n\t \n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\timr = atmel_uart_readl(port, ATMEL_US_IMR);\n\tatmel_uart_writel(port, ATMEL_US_IDR, -1);\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXDIS | ATMEL_US_RXDIS);\n\tatmel_port->tx_stopped = true;\n\n\t \n\tif (port->rs485.flags & SER_RS485_ENABLED) {\n\t\tatmel_uart_writel(port, ATMEL_US_TTGR,\n\t\t\t\t  port->rs485.delay_rts_after_send);\n\t\tmode |= ATMEL_US_USMODE_RS485;\n\t} else if (port->iso7816.flags & SER_ISO7816_ENABLED) {\n\t\tatmel_uart_writel(port, ATMEL_US_TTGR, port->iso7816.tg);\n\t\t \n\t\tmode |= ATMEL_US_USCLKS_MCK | ATMEL_US_CLKO;\n\t\t \n\t\tmode |= ATMEL_US_MAX_ITER(3);\n\t\tif ((port->iso7816.flags & SER_ISO7816_T_PARAM)\n\t\t\t\t== SER_ISO7816_T(0))\n\t\t\tmode |= ATMEL_US_USMODE_ISO7816_T0;\n\t\telse\n\t\t\tmode |= ATMEL_US_USMODE_ISO7816_T1;\n\t} else if (termios->c_cflag & CRTSCTS) {\n\t\t \n\t\tif (atmel_use_fifo(port) &&\n\t\t    !mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_CTS)) {\n\t\t\t \n\t\t\tmode |= ATMEL_US_USMODE_HWHS;\n\t\t} else {\n\t\t\t \n\t\t\tmode |= ATMEL_US_USMODE_NORMAL;\n\t\t}\n\t} else {\n\t\t \n\t\tmode |= ATMEL_US_USMODE_NORMAL;\n\t}\n\n\t \n\tif (atmel_port->has_frac_baudrate) {\n\t\tdiv = DIV_ROUND_CLOSEST(port->uartclk, baud * 2);\n\t\tcd = div >> 3;\n\t\tfp = div & ATMEL_US_FP_MASK;\n\t} else {\n\t\tcd = uart_get_divisor(port, baud);\n\t}\n\n\t \n\tif (atmel_port->is_usart && cd > ATMEL_US_CD) {\n\t\tcd /= 8;\n\t\tmode |= ATMEL_US_USCLKS_MCK_DIV8;\n\t} else {\n\t\tcd = min_t(unsigned int, cd, ATMEL_US_CD);\n\t}\n\n\t \n\tif (!atmel_port->has_frac_baudrate) {\n\t\tif (__clk_is_enabled(atmel_port->gclk))\n\t\t\tclk_disable_unprepare(atmel_port->gclk);\n\t\tgclk_rate = clk_round_rate(atmel_port->gclk, 16 * baud);\n\t\tactual_baud = clk_get_rate(atmel_port->clk) / (16 * cd);\n\t\tif (gclk_rate && abs(atmel_error_rate(baud, actual_baud)) >\n\t\t    abs(atmel_error_rate(baud, gclk_rate / 16))) {\n\t\t\tclk_set_rate(atmel_port->gclk, 16 * baud);\n\t\t\tret = clk_prepare_enable(atmel_port->gclk);\n\t\t\tif (ret)\n\t\t\t\tgoto gclk_fail;\n\n\t\t\tif (atmel_port->is_usart) {\n\t\t\t\tmode &= ~ATMEL_US_USCLKS;\n\t\t\t\tmode |= ATMEL_US_USCLKS_GCLK;\n\t\t\t} else {\n\t\t\t\tmode |= ATMEL_UA_BRSRCCK;\n\t\t\t}\n\n\t\t\t \n\t\t\tcd = 1;\n\t\t}\n\t}\n\ngclk_fail:\n\tquot = cd | fp << ATMEL_US_FP_OFFSET;\n\n\tif (!(port->iso7816.flags & SER_ISO7816_ENABLED))\n\t\tatmel_uart_writel(port, ATMEL_US_BRGR, quot);\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_MR, mode);\n\n\t \n\tif ((old_mode & ATMEL_US_USMODE) != (mode & ATMEL_US_USMODE)) {\n\t\tunsigned int rts_state;\n\n\t\tif ((mode & ATMEL_US_USMODE) == ATMEL_US_USMODE_HWHS) {\n\t\t\t \n\t\t\trts_state = ATMEL_US_RTSDIS;\n\t\t} else {\n\t\t\t \n\t\t\trts_state = ATMEL_US_RTSEN;\n\t\t}\n\n\t\tatmel_uart_writel(port, ATMEL_US_CR, rts_state);\n\t}\n\n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);\n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN | ATMEL_US_RXEN);\n\tatmel_port->tx_stopped = false;\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_IER, imr);\n\n\t \n\tif (UART_ENABLE_MS(port, termios->c_cflag))\n\t\tatmel_enable_ms(port);\n\telse\n\t\tatmel_disable_ms(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void atmel_set_ldisc(struct uart_port *port, struct ktermios *termios)\n{\n\tif (termios->c_line == N_PPS) {\n\t\tport->flags |= UPF_HARDPPS_CD;\n\t\tspin_lock_irq(&port->lock);\n\t\tatmel_enable_ms(port);\n\t\tspin_unlock_irq(&port->lock);\n\t} else {\n\t\tport->flags &= ~UPF_HARDPPS_CD;\n\t\tif (!UART_ENABLE_MS(port, termios->c_cflag)) {\n\t\t\tspin_lock_irq(&port->lock);\n\t\t\tatmel_disable_ms(port);\n\t\t\tspin_unlock_irq(&port->lock);\n\t\t}\n\t}\n}\n\n \nstatic const char *atmel_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_ATMEL) ? \"ATMEL_SERIAL\" : NULL;\n}\n\n \nstatic void atmel_release_port(struct uart_port *port)\n{\n\tstruct platform_device *mpdev = to_platform_device(port->dev->parent);\n\tint size = resource_size(mpdev->resource);\n\n\trelease_mem_region(port->mapbase, size);\n\n\tif (port->flags & UPF_IOREMAP) {\n\t\tiounmap(port->membase);\n\t\tport->membase = NULL;\n\t}\n}\n\n \nstatic int atmel_request_port(struct uart_port *port)\n{\n\tstruct platform_device *mpdev = to_platform_device(port->dev->parent);\n\tint size = resource_size(mpdev->resource);\n\n\tif (!request_mem_region(port->mapbase, size, \"atmel_serial\"))\n\t\treturn -EBUSY;\n\n\tif (port->flags & UPF_IOREMAP) {\n\t\tport->membase = ioremap(port->mapbase, size);\n\t\tif (port->membase == NULL) {\n\t\t\trelease_mem_region(port->mapbase, size);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void atmel_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_ATMEL;\n\t\tatmel_request_port(port);\n\t}\n}\n\n \nstatic int atmel_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tint ret = 0;\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_ATMEL)\n\t\tret = -EINVAL;\n\tif (port->irq != ser->irq)\n\t\tret = -EINVAL;\n\tif (ser->io_type != SERIAL_IO_MEM)\n\t\tret = -EINVAL;\n\tif (port->uartclk / 16 != ser->baud_base)\n\t\tret = -EINVAL;\n\tif (port->mapbase != (unsigned long)ser->iomem_base)\n\t\tret = -EINVAL;\n\tif (port->iobase != ser->port)\n\t\tret = -EINVAL;\n\tif (ser->hub6 != 0)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int atmel_poll_get_char(struct uart_port *port)\n{\n\twhile (!(atmel_uart_readl(port, ATMEL_US_CSR) & ATMEL_US_RXRDY))\n\t\tcpu_relax();\n\n\treturn atmel_uart_read_char(port);\n}\n\nstatic void atmel_poll_put_char(struct uart_port *port, unsigned char ch)\n{\n\twhile (!(atmel_uart_readl(port, ATMEL_US_CSR) & ATMEL_US_TXRDY))\n\t\tcpu_relax();\n\n\tatmel_uart_write_char(port, ch);\n}\n#endif\n\nstatic const struct uart_ops atmel_pops = {\n\t.tx_empty\t= atmel_tx_empty,\n\t.set_mctrl\t= atmel_set_mctrl,\n\t.get_mctrl\t= atmel_get_mctrl,\n\t.stop_tx\t= atmel_stop_tx,\n\t.start_tx\t= atmel_start_tx,\n\t.stop_rx\t= atmel_stop_rx,\n\t.enable_ms\t= atmel_enable_ms,\n\t.break_ctl\t= atmel_break_ctl,\n\t.startup\t= atmel_startup,\n\t.shutdown\t= atmel_shutdown,\n\t.flush_buffer\t= atmel_flush_buffer,\n\t.set_termios\t= atmel_set_termios,\n\t.set_ldisc\t= atmel_set_ldisc,\n\t.type\t\t= atmel_type,\n\t.release_port\t= atmel_release_port,\n\t.request_port\t= atmel_request_port,\n\t.config_port\t= atmel_config_port,\n\t.verify_port\t= atmel_verify_port,\n\t.pm\t\t= atmel_serial_pm,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= atmel_poll_get_char,\n\t.poll_put_char\t= atmel_poll_put_char,\n#endif\n};\n\nstatic const struct serial_rs485 atmel_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_AFTER_SEND | SER_RS485_RX_DURING_TX,\n\t.delay_rts_before_send = 1,\n\t.delay_rts_after_send = 1,\n};\n\n \nstatic int atmel_init_port(struct atmel_uart_port *atmel_port,\n\t\t\t\t      struct platform_device *pdev)\n{\n\tint ret;\n\tstruct uart_port *port = &atmel_port->uart;\n\tstruct platform_device *mpdev = to_platform_device(pdev->dev.parent);\n\n\tatmel_init_property(atmel_port, pdev);\n\tatmel_set_ops(port);\n\n\tport->iotype\t\t= UPIO_MEM;\n\tport->flags\t\t= UPF_BOOT_AUTOCONF | UPF_IOREMAP;\n\tport->ops\t\t= &atmel_pops;\n\tport->fifosize\t\t= 1;\n\tport->dev\t\t= &pdev->dev;\n\tport->mapbase\t\t= mpdev->resource[0].start;\n\tport->irq\t\t= platform_get_irq(mpdev, 0);\n\tport->rs485_config\t= atmel_config_rs485;\n\tport->rs485_supported\t= atmel_rs485_supported;\n\tport->iso7816_config\t= atmel_config_iso7816;\n\tport->membase\t\t= NULL;\n\n\tmemset(&atmel_port->rx_ring, 0, sizeof(atmel_port->rx_ring));\n\n\tret = uart_get_rs485_mode(port);\n\tif (ret)\n\t\treturn ret;\n\n\tport->uartclk = clk_get_rate(atmel_port->clk);\n\n\t \n\tif (atmel_uart_is_half_duplex(port))\n\t\tatmel_port->tx_done_mask = ATMEL_US_TXEMPTY;\n\telse if (atmel_use_pdc_tx(port)) {\n\t\tport->fifosize = PDC_BUFFER_SIZE;\n\t\tatmel_port->tx_done_mask = ATMEL_US_ENDTX | ATMEL_US_TXBUFE;\n\t} else {\n\t\tatmel_port->tx_done_mask = ATMEL_US_TXRDY;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SERIAL_ATMEL_CONSOLE\nstatic void atmel_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\twhile (!(atmel_uart_readl(port, ATMEL_US_CSR) & ATMEL_US_TXRDY))\n\t\tcpu_relax();\n\tatmel_uart_write_char(port, ch);\n}\n\n \nstatic void atmel_console_write(struct console *co, const char *s, u_int count)\n{\n\tstruct uart_port *port = &atmel_ports[co->index].uart;\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tunsigned int status, imr;\n\tunsigned int pdc_tx;\n\n\t \n\timr = atmel_uart_readl(port, ATMEL_US_IMR);\n\tatmel_uart_writel(port, ATMEL_US_IDR,\n\t\t\t  ATMEL_US_RXRDY | atmel_port->tx_done_mask);\n\n\t \n\tpdc_tx = atmel_uart_readl(port, ATMEL_PDC_PTSR) & ATMEL_PDC_TXTEN;\n\tatmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTDIS);\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN);\n\tatmel_port->tx_stopped = false;\n\n\tuart_console_write(port, s, count, atmel_console_putchar);\n\n\t \n\tdo {\n\t\tstatus = atmel_uart_readl(port, ATMEL_US_CSR);\n\t} while (!(status & ATMEL_US_TXRDY));\n\n\t \n\tif (pdc_tx)\n\t\tatmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);\n\n\t \n\tatmel_uart_writel(port, ATMEL_US_IER, imr);\n}\n\n \nstatic void __init atmel_console_get_options(struct uart_port *port, int *baud,\n\t\t\t\t\t     int *parity, int *bits)\n{\n\tunsigned int mr, quot;\n\n\t \n\tquot = atmel_uart_readl(port, ATMEL_US_BRGR) & ATMEL_US_CD;\n\tif (!quot)\n\t\treturn;\n\n\tmr = atmel_uart_readl(port, ATMEL_US_MR) & ATMEL_US_CHRL;\n\tif (mr == ATMEL_US_CHRL_8)\n\t\t*bits = 8;\n\telse\n\t\t*bits = 7;\n\n\tmr = atmel_uart_readl(port, ATMEL_US_MR) & ATMEL_US_PAR;\n\tif (mr == ATMEL_US_PAR_EVEN)\n\t\t*parity = 'e';\n\telse if (mr == ATMEL_US_PAR_ODD)\n\t\t*parity = 'o';\n\n\t*baud = port->uartclk / (16 * quot);\n}\n\nstatic int __init atmel_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port = &atmel_ports[co->index].uart;\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (port->membase == NULL) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tatmel_uart_writel(port, ATMEL_US_IDR, -1);\n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);\n\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN | ATMEL_US_RXEN);\n\tatmel_port->tx_stopped = false;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse\n\t\tatmel_console_get_options(port, &baud, &parity, &bits);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver atmel_uart;\n\nstatic struct console atmel_console = {\n\t.name\t\t= ATMEL_DEVICENAME,\n\t.write\t\t= atmel_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= atmel_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &atmel_uart,\n};\n\nstatic void atmel_serial_early_write(struct console *con, const char *s,\n\t\t\t\t     unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, atmel_console_putchar);\n}\n\nstatic int __init atmel_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t    const char *options)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = atmel_serial_early_write;\n\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(atmel_serial, \"atmel,at91rm9200-usart\",\n\t\t    atmel_early_console_setup);\nOF_EARLYCON_DECLARE(atmel_serial, \"atmel,at91sam9260-usart\",\n\t\t    atmel_early_console_setup);\n\n#define ATMEL_CONSOLE_DEVICE\t(&atmel_console)\n\n#else\n#define ATMEL_CONSOLE_DEVICE\tNULL\n#endif\n\nstatic struct uart_driver atmel_uart = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"atmel_serial\",\n\t.dev_name\t= ATMEL_DEVICENAME,\n\t.major\t\t= SERIAL_ATMEL_MAJOR,\n\t.minor\t\t= MINOR_START,\n\t.nr\t\t= ATMEL_MAX_UART,\n\t.cons\t\t= ATMEL_CONSOLE_DEVICE,\n};\n\nstatic bool atmel_serial_clk_will_stop(void)\n{\n#ifdef CONFIG_ARCH_AT91\n\treturn at91_suspend_entering_slow_clock();\n#else\n\treturn false;\n#endif\n}\n\nstatic int __maybe_unused atmel_serial_suspend(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\tif (uart_console(port) && console_suspend_enabled) {\n\t\t \n\t\twhile (!(atmel_uart_readl(port, ATMEL_US_CSR) &\n\t\t\t ATMEL_US_TXEMPTY))\n\t\t\tcpu_relax();\n\t}\n\n\tif (uart_console(port) && !console_suspend_enabled) {\n\t\t \n\t\tatmel_port->cache.mr = atmel_uart_readl(port, ATMEL_US_MR);\n\t\tatmel_port->cache.imr = atmel_uart_readl(port, ATMEL_US_IMR);\n\t\tatmel_port->cache.brgr = atmel_uart_readl(port, ATMEL_US_BRGR);\n\t\tatmel_port->cache.rtor = atmel_uart_readl(port,\n\t\t\t\t\t\t\t  atmel_port->rtor);\n\t\tatmel_port->cache.ttgr = atmel_uart_readl(port, ATMEL_US_TTGR);\n\t\tatmel_port->cache.fmr = atmel_uart_readl(port, ATMEL_US_FMR);\n\t\tatmel_port->cache.fimr = atmel_uart_readl(port, ATMEL_US_FIMR);\n\t}\n\n\t \n\tatmel_port->may_wakeup = device_may_wakeup(dev);\n\tif (atmel_serial_clk_will_stop()) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&atmel_port->lock_suspended, flags);\n\t\tatmel_port->suspended = true;\n\t\tspin_unlock_irqrestore(&atmel_port->lock_suspended, flags);\n\t\tdevice_set_wakeup_enable(dev, 0);\n\t}\n\n\tuart_suspend_port(&atmel_uart, port);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused atmel_serial_resume(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\tunsigned long flags;\n\n\tif (uart_console(port) && !console_suspend_enabled) {\n\t\tatmel_uart_writel(port, ATMEL_US_MR, atmel_port->cache.mr);\n\t\tatmel_uart_writel(port, ATMEL_US_IER, atmel_port->cache.imr);\n\t\tatmel_uart_writel(port, ATMEL_US_BRGR, atmel_port->cache.brgr);\n\t\tatmel_uart_writel(port, atmel_port->rtor,\n\t\t\t\t  atmel_port->cache.rtor);\n\t\tatmel_uart_writel(port, ATMEL_US_TTGR, atmel_port->cache.ttgr);\n\n\t\tif (atmel_port->fifo_size) {\n\t\t\tatmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_FIFOEN |\n\t\t\t\t\t  ATMEL_US_RXFCLR | ATMEL_US_TXFLCLR);\n\t\t\tatmel_uart_writel(port, ATMEL_US_FMR,\n\t\t\t\t\t  atmel_port->cache.fmr);\n\t\t\tatmel_uart_writel(port, ATMEL_US_FIER,\n\t\t\t\t\t  atmel_port->cache.fimr);\n\t\t}\n\t\tatmel_start_rx(port);\n\t}\n\n\tspin_lock_irqsave(&atmel_port->lock_suspended, flags);\n\tif (atmel_port->pending) {\n\t\tatmel_handle_receive(port, atmel_port->pending);\n\t\tatmel_handle_status(port, atmel_port->pending,\n\t\t\t\t    atmel_port->pending_status);\n\t\tatmel_handle_transmit(port, atmel_port->pending);\n\t\tatmel_port->pending = 0;\n\t}\n\tatmel_port->suspended = false;\n\tspin_unlock_irqrestore(&atmel_port->lock_suspended, flags);\n\n\tuart_resume_port(&atmel_uart, port);\n\tdevice_set_wakeup_enable(dev, atmel_port->may_wakeup);\n\n\treturn 0;\n}\n\nstatic void atmel_serial_probe_fifos(struct atmel_uart_port *atmel_port,\n\t\t\t\t     struct platform_device *pdev)\n{\n\tatmel_port->fifo_size = 0;\n\tatmel_port->rts_low = 0;\n\tatmel_port->rts_high = 0;\n\n\tif (of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t \"atmel,fifo-size\",\n\t\t\t\t &atmel_port->fifo_size))\n\t\treturn;\n\n\tif (!atmel_port->fifo_size)\n\t\treturn;\n\n\tif (atmel_port->fifo_size < ATMEL_MIN_FIFO_SIZE) {\n\t\tatmel_port->fifo_size = 0;\n\t\tdev_err(&pdev->dev, \"Invalid FIFO size\\n\");\n\t\treturn;\n\t}\n\n\t \n\tatmel_port->rts_high = max_t(int, atmel_port->fifo_size >> 1,\n\t\t\t       atmel_port->fifo_size - ATMEL_RTS_HIGH_OFFSET);\n\tatmel_port->rts_low  = max_t(int, atmel_port->fifo_size >> 2,\n\t\t\t       atmel_port->fifo_size - ATMEL_RTS_LOW_OFFSET);\n\n\tdev_info(&pdev->dev, \"Using FIFO (%u data)\\n\",\n\t\t atmel_port->fifo_size);\n\tdev_dbg(&pdev->dev, \"RTS High Threshold : %2u data\\n\",\n\t\tatmel_port->rts_high);\n\tdev_dbg(&pdev->dev, \"RTS Low Threshold  : %2u data\\n\",\n\t\tatmel_port->rts_low);\n}\n\nstatic int atmel_serial_probe(struct platform_device *pdev)\n{\n\tstruct atmel_uart_port *atmel_port;\n\tstruct device_node *np = pdev->dev.parent->of_node;\n\tvoid *data;\n\tint ret;\n\tbool rs485_enabled;\n\n\tBUILD_BUG_ON(ATMEL_SERIAL_RINGSIZE & (ATMEL_SERIAL_RINGSIZE - 1));\n\n\t \n\tpdev->dev.of_node = np;\n\n\tret = of_alias_get_id(np, \"serial\");\n\tif (ret < 0)\n\t\t \n\t\tret = find_first_zero_bit(atmel_ports_in_use, ATMEL_MAX_UART);\n\n\tif (ret >= ATMEL_MAX_UART) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tif (test_and_set_bit(ret, atmel_ports_in_use)) {\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tatmel_port = &atmel_ports[ret];\n\tatmel_port->backup_imr = 0;\n\tatmel_port->uart.line = ret;\n\tatmel_port->uart.has_sysrq = IS_ENABLED(CONFIG_SERIAL_ATMEL_CONSOLE);\n\tatmel_serial_probe_fifos(atmel_port, pdev);\n\n\tatomic_set(&atmel_port->tasklet_shutdown, 0);\n\tspin_lock_init(&atmel_port->lock_suspended);\n\n\tatmel_port->clk = devm_clk_get(&pdev->dev, \"usart\");\n\tif (IS_ERR(atmel_port->clk)) {\n\t\tret = PTR_ERR(atmel_port->clk);\n\t\tgoto err;\n\t}\n\tret = clk_prepare_enable(atmel_port->clk);\n\tif (ret)\n\t\tgoto err;\n\n\tatmel_port->gclk = devm_clk_get_optional(&pdev->dev, \"gclk\");\n\tif (IS_ERR(atmel_port->gclk)) {\n\t\tret = PTR_ERR(atmel_port->gclk);\n\t\tgoto err_clk_disable_unprepare;\n\t}\n\n\tret = atmel_init_port(atmel_port, pdev);\n\tif (ret)\n\t\tgoto err_clk_disable_unprepare;\n\n\tatmel_port->gpios = mctrl_gpio_init(&atmel_port->uart, 0);\n\tif (IS_ERR(atmel_port->gpios)) {\n\t\tret = PTR_ERR(atmel_port->gpios);\n\t\tgoto err_clk_disable_unprepare;\n\t}\n\n\tif (!atmel_use_pdc_rx(&atmel_port->uart)) {\n\t\tret = -ENOMEM;\n\t\tdata = kmalloc_array(ATMEL_SERIAL_RINGSIZE,\n\t\t\t\t     sizeof(struct atmel_uart_char),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!data)\n\t\t\tgoto err_clk_disable_unprepare;\n\t\tatmel_port->rx_ring.buf = data;\n\t}\n\n\trs485_enabled = atmel_port->uart.rs485.flags & SER_RS485_ENABLED;\n\n\tret = uart_add_one_port(&atmel_uart, &atmel_port->uart);\n\tif (ret)\n\t\tgoto err_add_port;\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\tplatform_set_drvdata(pdev, atmel_port);\n\n\tif (rs485_enabled) {\n\t\tatmel_uart_writel(&atmel_port->uart, ATMEL_US_MR,\n\t\t\t\t  ATMEL_US_USMODE_NORMAL);\n\t\tatmel_uart_writel(&atmel_port->uart, ATMEL_US_CR,\n\t\t\t\t  ATMEL_US_RTSEN);\n\t}\n\n\t \n\tatmel_get_ip_name(&atmel_port->uart);\n\n\t \n\tclk_disable_unprepare(atmel_port->clk);\n\n\treturn 0;\n\nerr_add_port:\n\tkfree(atmel_port->rx_ring.buf);\n\tatmel_port->rx_ring.buf = NULL;\nerr_clk_disable_unprepare:\n\tclk_disable_unprepare(atmel_port->clk);\n\tclear_bit(atmel_port->uart.line, atmel_ports_in_use);\nerr:\n\treturn ret;\n}\n\n \nstatic int atmel_serial_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = platform_get_drvdata(pdev);\n\tstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\n\n\ttasklet_kill(&atmel_port->tasklet_rx);\n\ttasklet_kill(&atmel_port->tasklet_tx);\n\n\tdevice_init_wakeup(&pdev->dev, 0);\n\n\tuart_remove_one_port(&atmel_uart, port);\n\n\tkfree(atmel_port->rx_ring.buf);\n\n\t \n\n\tclear_bit(port->line, atmel_ports_in_use);\n\n\tpdev->dev.of_node = NULL;\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(atmel_serial_pm_ops, atmel_serial_suspend,\n\t\t\t atmel_serial_resume);\n\nstatic struct platform_driver atmel_serial_driver = {\n\t.probe\t\t= atmel_serial_probe,\n\t.remove\t\t= atmel_serial_remove,\n\t.driver\t\t= {\n\t\t.name\t\t\t= \"atmel_usart_serial\",\n\t\t.of_match_table\t\t= of_match_ptr(atmel_serial_dt_ids),\n\t\t.pm\t\t\t= pm_ptr(&atmel_serial_pm_ops),\n\t},\n};\n\nstatic int __init atmel_serial_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&atmel_uart);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&atmel_serial_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&atmel_uart);\n\n\treturn ret;\n}\ndevice_initcall(atmel_serial_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}