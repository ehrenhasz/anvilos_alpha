{
  "module_name": "tegra-tcu.c",
  "hash_id": "0ef386bdd894c1ab26ef8fea62e8242ef7aee1c46ea141a1ea5164fc935014b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/tegra-tcu.c",
  "human_readable_source": "\n \n\n#include <linux/console.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#define TCU_MBOX_BYTE(i, x)\t\t\t((x) << (i * 8))\n#define TCU_MBOX_BYTE_V(x, i)\t\t\t(((x) >> (i * 8)) & 0xff)\n#define TCU_MBOX_NUM_BYTES(x)\t\t\t((x) << 24)\n#define TCU_MBOX_NUM_BYTES_V(x)\t\t\t(((x) >> 24) & 0x3)\n\nstruct tegra_tcu {\n\tstruct uart_driver driver;\n#if IS_ENABLED(CONFIG_SERIAL_TEGRA_TCU_CONSOLE)\n\tstruct console console;\n#endif\n\tstruct uart_port port;\n\n\tstruct mbox_client tx_client, rx_client;\n\tstruct mbox_chan *tx, *rx;\n};\n\nstatic unsigned int tegra_tcu_uart_tx_empty(struct uart_port *port)\n{\n\treturn TIOCSER_TEMT;\n}\n\nstatic void tegra_tcu_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n}\n\nstatic unsigned int tegra_tcu_uart_get_mctrl(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void tegra_tcu_uart_stop_tx(struct uart_port *port)\n{\n}\n\nstatic void tegra_tcu_write_one(struct tegra_tcu *tcu, u32 value,\n\t\t\t\tunsigned int count)\n{\n\tvoid *msg;\n\n\tvalue |= TCU_MBOX_NUM_BYTES(count);\n\tmsg = (void *)(unsigned long)value;\n\tmbox_send_message(tcu->tx, msg);\n\tmbox_flush(tcu->tx, 1000);\n}\n\nstatic void tegra_tcu_write(struct tegra_tcu *tcu, const char *s,\n\t\t\t    unsigned int count)\n{\n\tunsigned int written = 0, i = 0;\n\tbool insert_nl = false;\n\tu32 value = 0;\n\n\twhile (i < count) {\n\t\tif (insert_nl) {\n\t\t\tvalue |= TCU_MBOX_BYTE(written++, '\\n');\n\t\t\tinsert_nl = false;\n\t\t\ti++;\n\t\t} else if (s[i] == '\\n') {\n\t\t\tvalue |= TCU_MBOX_BYTE(written++, '\\r');\n\t\t\tinsert_nl = true;\n\t\t} else {\n\t\t\tvalue |= TCU_MBOX_BYTE(written++, s[i++]);\n\t\t}\n\n\t\tif (written == 3) {\n\t\t\ttegra_tcu_write_one(tcu, value, 3);\n\t\t\tvalue = written = 0;\n\t\t}\n\t}\n\n\tif (written)\n\t\ttegra_tcu_write_one(tcu, value, written);\n}\n\nstatic void tegra_tcu_uart_start_tx(struct uart_port *port)\n{\n\tstruct tegra_tcu *tcu = port->private_data;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned long count;\n\n\tfor (;;) {\n\t\tcount = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\t\tif (!count)\n\t\t\tbreak;\n\n\t\ttegra_tcu_write(tcu, &xmit->buf[xmit->tail], count);\n\t\tuart_xmit_advance(port, count);\n\t}\n\n\tuart_write_wakeup(port);\n}\n\nstatic void tegra_tcu_uart_stop_rx(struct uart_port *port)\n{\n}\n\nstatic void tegra_tcu_uart_break_ctl(struct uart_port *port, int ctl)\n{\n}\n\nstatic int tegra_tcu_uart_startup(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void tegra_tcu_uart_shutdown(struct uart_port *port)\n{\n}\n\nstatic void tegra_tcu_uart_set_termios(struct uart_port *port,\n\t\t\t\t       struct ktermios *new,\n\t\t\t\t       const struct ktermios *old)\n{\n}\n\nstatic const struct uart_ops tegra_tcu_uart_ops = {\n\t.tx_empty = tegra_tcu_uart_tx_empty,\n\t.set_mctrl = tegra_tcu_uart_set_mctrl,\n\t.get_mctrl = tegra_tcu_uart_get_mctrl,\n\t.stop_tx = tegra_tcu_uart_stop_tx,\n\t.start_tx = tegra_tcu_uart_start_tx,\n\t.stop_rx = tegra_tcu_uart_stop_rx,\n\t.break_ctl = tegra_tcu_uart_break_ctl,\n\t.startup = tegra_tcu_uart_startup,\n\t.shutdown = tegra_tcu_uart_shutdown,\n\t.set_termios = tegra_tcu_uart_set_termios,\n};\n\n#if IS_ENABLED(CONFIG_SERIAL_TEGRA_TCU_CONSOLE)\nstatic void tegra_tcu_console_write(struct console *cons, const char *s,\n\t\t\t\t    unsigned int count)\n{\n\tstruct tegra_tcu *tcu = container_of(cons, struct tegra_tcu, console);\n\n\ttegra_tcu_write(tcu, s, count);\n}\n\nstatic int tegra_tcu_console_setup(struct console *cons, char *options)\n{\n\treturn 0;\n}\n#endif\n\nstatic void tegra_tcu_receive(struct mbox_client *cl, void *msg)\n{\n\tstruct tegra_tcu *tcu = container_of(cl, struct tegra_tcu, rx_client);\n\tstruct tty_port *port = &tcu->port.state->port;\n\tu32 value = (u32)(unsigned long)msg;\n\tunsigned int num_bytes, i;\n\n\tnum_bytes = TCU_MBOX_NUM_BYTES_V(value);\n\n\tfor (i = 0; i < num_bytes; i++)\n\t\ttty_insert_flip_char(port, TCU_MBOX_BYTE_V(value, i),\n\t\t\t\t     TTY_NORMAL);\n\n\ttty_flip_buffer_push(port);\n}\n\nstatic int tegra_tcu_probe(struct platform_device *pdev)\n{\n\tstruct uart_port *port;\n\tstruct tegra_tcu *tcu;\n\tint err;\n\n\ttcu = devm_kzalloc(&pdev->dev, sizeof(*tcu), GFP_KERNEL);\n\tif (!tcu)\n\t\treturn -ENOMEM;\n\n\ttcu->tx_client.dev = &pdev->dev;\n\ttcu->rx_client.dev = &pdev->dev;\n\ttcu->rx_client.rx_callback = tegra_tcu_receive;\n\n\ttcu->tx = mbox_request_channel_byname(&tcu->tx_client, \"tx\");\n\tif (IS_ERR(tcu->tx)) {\n\t\terr = PTR_ERR(tcu->tx);\n\t\tdev_err(&pdev->dev, \"failed to get tx mailbox: %d\\n\", err);\n\t\treturn err;\n\t}\n\n#if IS_ENABLED(CONFIG_SERIAL_TEGRA_TCU_CONSOLE)\n\t \n\tstrcpy(tcu->console.name, \"ttyTCU\");\n\ttcu->console.device = uart_console_device;\n\ttcu->console.flags = CON_PRINTBUFFER | CON_ANYTIME;\n\ttcu->console.index = -1;\n\ttcu->console.write = tegra_tcu_console_write;\n\ttcu->console.setup = tegra_tcu_console_setup;\n\ttcu->console.data = &tcu->driver;\n#endif\n\n\t \n\ttcu->driver.owner = THIS_MODULE;\n\ttcu->driver.driver_name = \"tegra-tcu\";\n\ttcu->driver.dev_name = \"ttyTCU\";\n#if IS_ENABLED(CONFIG_SERIAL_TEGRA_TCU_CONSOLE)\n\ttcu->driver.cons = &tcu->console;\n#endif\n\ttcu->driver.nr = 1;\n\n\terr = uart_register_driver(&tcu->driver);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register UART driver: %d\\n\",\n\t\t\terr);\n\t\tgoto free_tx;\n\t}\n\n\t \n\tport = &tcu->port;\n\tspin_lock_init(&port->lock);\n\tport->dev = &pdev->dev;\n\tport->type = PORT_TEGRA_TCU;\n\tport->ops = &tegra_tcu_uart_ops;\n\tport->fifosize = 1;\n\tport->iotype = UPIO_MEM;\n\tport->flags = UPF_BOOT_AUTOCONF;\n\tport->private_data = tcu;\n\n\terr = uart_add_one_port(&tcu->driver, port);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to add UART port: %d\\n\", err);\n\t\tgoto unregister_uart;\n\t}\n\n\t \n\ttcu->rx = mbox_request_channel_byname(&tcu->rx_client, \"rx\");\n\tif (IS_ERR(tcu->rx)) {\n\t\terr = PTR_ERR(tcu->rx);\n\t\tdev_err(&pdev->dev, \"failed to get rx mailbox: %d\\n\", err);\n\t\tgoto remove_uart_port;\n\t}\n\n\tplatform_set_drvdata(pdev, tcu);\n#if IS_ENABLED(CONFIG_SERIAL_TEGRA_TCU_CONSOLE)\n\tregister_console(&tcu->console);\n#endif\n\n\treturn 0;\n\nremove_uart_port:\n\tuart_remove_one_port(&tcu->driver, &tcu->port);\nunregister_uart:\n\tuart_unregister_driver(&tcu->driver);\nfree_tx:\n\tmbox_free_channel(tcu->tx);\n\n\treturn err;\n}\n\nstatic int tegra_tcu_remove(struct platform_device *pdev)\n{\n\tstruct tegra_tcu *tcu = platform_get_drvdata(pdev);\n\n#if IS_ENABLED(CONFIG_SERIAL_TEGRA_TCU_CONSOLE)\n\tunregister_console(&tcu->console);\n#endif\n\tmbox_free_channel(tcu->rx);\n\tuart_remove_one_port(&tcu->driver, &tcu->port);\n\tuart_unregister_driver(&tcu->driver);\n\tmbox_free_channel(tcu->tx);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tegra_tcu_match[] = {\n\t{ .compatible = \"nvidia,tegra194-tcu\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_tcu_match);\n\nstatic struct platform_driver tegra_tcu_driver = {\n\t.driver = {\n\t\t.name = \"tegra-tcu\",\n\t\t.of_match_table = tegra_tcu_match,\n\t},\n\t.probe = tegra_tcu_probe,\n\t.remove = tegra_tcu_remove,\n};\nmodule_platform_driver(tegra_tcu_driver);\n\nMODULE_AUTHOR(\"Mikko Perttunen <mperttunen@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra Combined UART driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}