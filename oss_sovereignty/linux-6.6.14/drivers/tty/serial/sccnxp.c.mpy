{
  "module_name": "sccnxp.c",
  "hash_id": "6dc039cae1ebcbb9344f41301399fabb7e7790e5b14841e07e4b21167c8001ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sccnxp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/device.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/io.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/serial-sccnxp.h>\n#include <linux/regulator/consumer.h>\n\n#define SCCNXP_NAME\t\t\t\"uart-sccnxp\"\n#define SCCNXP_MAJOR\t\t\t204\n#define SCCNXP_MINOR\t\t\t205\n\n#define SCCNXP_MR_REG\t\t\t(0x00)\n#\tdefine MR0_BAUD_NORMAL\t\t(0 << 0)\n#\tdefine MR0_BAUD_EXT1\t\t(1 << 0)\n#\tdefine MR0_BAUD_EXT2\t\t(5 << 0)\n#\tdefine MR0_FIFO\t\t\t(1 << 3)\n#\tdefine MR0_TXLVL\t\t(1 << 4)\n#\tdefine MR1_BITS_5\t\t(0 << 0)\n#\tdefine MR1_BITS_6\t\t(1 << 0)\n#\tdefine MR1_BITS_7\t\t(2 << 0)\n#\tdefine MR1_BITS_8\t\t(3 << 0)\n#\tdefine MR1_PAR_EVN\t\t(0 << 2)\n#\tdefine MR1_PAR_ODD\t\t(1 << 2)\n#\tdefine MR1_PAR_NO\t\t(4 << 2)\n#\tdefine MR2_STOP1\t\t(7 << 0)\n#\tdefine MR2_STOP2\t\t(0xf << 0)\n#define SCCNXP_SR_REG\t\t\t(0x01)\n#\tdefine SR_RXRDY\t\t\t(1 << 0)\n#\tdefine SR_FULL\t\t\t(1 << 1)\n#\tdefine SR_TXRDY\t\t\t(1 << 2)\n#\tdefine SR_TXEMT\t\t\t(1 << 3)\n#\tdefine SR_OVR\t\t\t(1 << 4)\n#\tdefine SR_PE\t\t\t(1 << 5)\n#\tdefine SR_FE\t\t\t(1 << 6)\n#\tdefine SR_BRK\t\t\t(1 << 7)\n#define SCCNXP_CSR_REG\t\t\t(SCCNXP_SR_REG)\n#\tdefine CSR_TIMER_MODE\t\t(0x0d)\n#define SCCNXP_CR_REG\t\t\t(0x02)\n#\tdefine CR_RX_ENABLE\t\t(1 << 0)\n#\tdefine CR_RX_DISABLE\t\t(1 << 1)\n#\tdefine CR_TX_ENABLE\t\t(1 << 2)\n#\tdefine CR_TX_DISABLE\t\t(1 << 3)\n#\tdefine CR_CMD_MRPTR1\t\t(0x01 << 4)\n#\tdefine CR_CMD_RX_RESET\t\t(0x02 << 4)\n#\tdefine CR_CMD_TX_RESET\t\t(0x03 << 4)\n#\tdefine CR_CMD_STATUS_RESET\t(0x04 << 4)\n#\tdefine CR_CMD_BREAK_RESET\t(0x05 << 4)\n#\tdefine CR_CMD_START_BREAK\t(0x06 << 4)\n#\tdefine CR_CMD_STOP_BREAK\t(0x07 << 4)\n#\tdefine CR_CMD_MRPTR0\t\t(0x0b << 4)\n#define SCCNXP_RHR_REG\t\t\t(0x03)\n#define SCCNXP_THR_REG\t\t\tSCCNXP_RHR_REG\n#define SCCNXP_IPCR_REG\t\t\t(0x04)\n#define SCCNXP_ACR_REG\t\t\tSCCNXP_IPCR_REG\n#\tdefine ACR_BAUD0\t\t(0 << 7)\n#\tdefine ACR_BAUD1\t\t(1 << 7)\n#\tdefine ACR_TIMER_MODE\t\t(6 << 4)\n#define SCCNXP_ISR_REG\t\t\t(0x05)\n#define SCCNXP_IMR_REG\t\t\tSCCNXP_ISR_REG\n#\tdefine IMR_TXRDY\t\t(1 << 0)\n#\tdefine IMR_RXRDY\t\t(1 << 1)\n#\tdefine ISR_TXRDY(x)\t\t(1 << ((x * 4) + 0))\n#\tdefine ISR_RXRDY(x)\t\t(1 << ((x * 4) + 1))\n#define SCCNXP_CTPU_REG\t\t\t(0x06)\n#define SCCNXP_CTPL_REG\t\t\t(0x07)\n#define SCCNXP_IPR_REG\t\t\t(0x0d)\n#define SCCNXP_OPCR_REG\t\t\tSCCNXP_IPR_REG\n#define SCCNXP_SOP_REG\t\t\t(0x0e)\n#define SCCNXP_START_COUNTER_REG\tSCCNXP_SOP_REG\n#define SCCNXP_ROP_REG\t\t\t(0x0f)\n\n \n#define MCTRL_MASK(sig)\t\t\t(0xf << (sig))\n#define MCTRL_IBIT(cfg, sig)\t\t((((cfg) >> (sig)) & 0xf) - LINE_IP0)\n#define MCTRL_OBIT(cfg, sig)\t\t((((cfg) >> (sig)) & 0xf) - LINE_OP0)\n\n#define SCCNXP_HAVE_IO\t\t0x00000001\n#define SCCNXP_HAVE_MR0\t\t0x00000002\n\nstruct sccnxp_chip {\n\tconst char\t\t*name;\n\tunsigned int\t\tnr;\n\tunsigned long\t\tfreq_min;\n\tunsigned long\t\tfreq_std;\n\tunsigned long\t\tfreq_max;\n\tunsigned int\t\tflags;\n\tunsigned int\t\tfifosize;\n\t \n\tunsigned int\t\ttrwd;\n};\n\nstruct sccnxp_port {\n\tstruct uart_driver\tuart;\n\tstruct uart_port\tport[SCCNXP_MAX_UARTS];\n\tbool\t\t\topened[SCCNXP_MAX_UARTS];\n\n\tint\t\t\tirq;\n\tu8\t\t\timr;\n\n\tstruct sccnxp_chip\t*chip;\n\n#ifdef CONFIG_SERIAL_SCCNXP_CONSOLE\n\tstruct console\t\tconsole;\n#endif\n\n\tspinlock_t\t\tlock;\n\n\tbool\t\t\tpoll;\n\tstruct timer_list\ttimer;\n\n\tstruct sccnxp_pdata\tpdata;\n\n\tstruct regulator\t*regulator;\n};\n\nstatic const struct sccnxp_chip sc2681 = {\n\t.name\t\t= \"SC2681\",\n\t.nr\t\t= 2,\n\t.freq_min\t= 1000000,\n\t.freq_std\t= 3686400,\n\t.freq_max\t= 4000000,\n\t.flags\t\t= SCCNXP_HAVE_IO,\n\t.fifosize\t= 3,\n\t.trwd\t\t= 200,\n};\n\nstatic const struct sccnxp_chip sc2691 = {\n\t.name\t\t= \"SC2691\",\n\t.nr\t\t= 1,\n\t.freq_min\t= 1000000,\n\t.freq_std\t= 3686400,\n\t.freq_max\t= 4000000,\n\t.flags\t\t= 0,\n\t.fifosize\t= 3,\n\t.trwd\t\t= 150,\n};\n\nstatic const struct sccnxp_chip sc2692 = {\n\t.name\t\t= \"SC2692\",\n\t.nr\t\t= 2,\n\t.freq_min\t= 1000000,\n\t.freq_std\t= 3686400,\n\t.freq_max\t= 4000000,\n\t.flags\t\t= SCCNXP_HAVE_IO,\n\t.fifosize\t= 3,\n\t.trwd\t\t= 30,\n};\n\nstatic const struct sccnxp_chip sc2891 = {\n\t.name\t\t= \"SC2891\",\n\t.nr\t\t= 1,\n\t.freq_min\t= 100000,\n\t.freq_std\t= 3686400,\n\t.freq_max\t= 8000000,\n\t.flags\t\t= SCCNXP_HAVE_IO | SCCNXP_HAVE_MR0,\n\t.fifosize\t= 16,\n\t.trwd\t\t= 27,\n};\n\nstatic const struct sccnxp_chip sc2892 = {\n\t.name\t\t= \"SC2892\",\n\t.nr\t\t= 2,\n\t.freq_min\t= 100000,\n\t.freq_std\t= 3686400,\n\t.freq_max\t= 8000000,\n\t.flags\t\t= SCCNXP_HAVE_IO | SCCNXP_HAVE_MR0,\n\t.fifosize\t= 16,\n\t.trwd\t\t= 17,\n};\n\nstatic const struct sccnxp_chip sc28202 = {\n\t.name\t\t= \"SC28202\",\n\t.nr\t\t= 2,\n\t.freq_min\t= 1000000,\n\t.freq_std\t= 14745600,\n\t.freq_max\t= 50000000,\n\t.flags\t\t= SCCNXP_HAVE_IO | SCCNXP_HAVE_MR0,\n\t.fifosize\t= 256,\n\t.trwd\t\t= 10,\n};\n\nstatic const struct sccnxp_chip sc68681 = {\n\t.name\t\t= \"SC68681\",\n\t.nr\t\t= 2,\n\t.freq_min\t= 1000000,\n\t.freq_std\t= 3686400,\n\t.freq_max\t= 4000000,\n\t.flags\t\t= SCCNXP_HAVE_IO,\n\t.fifosize\t= 3,\n\t.trwd\t\t= 200,\n};\n\nstatic const struct sccnxp_chip sc68692 = {\n\t.name\t\t= \"SC68692\",\n\t.nr\t\t= 2,\n\t.freq_min\t= 1000000,\n\t.freq_std\t= 3686400,\n\t.freq_max\t= 4000000,\n\t.flags\t\t= SCCNXP_HAVE_IO,\n\t.fifosize\t= 3,\n\t.trwd\t\t= 200,\n};\n\nstatic u8 sccnxp_read(struct uart_port *port, u8 reg)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\tu8 ret;\n\n\tret = readb(port->membase + (reg << port->regshift));\n\n\tndelay(s->chip->trwd);\n\n\treturn ret;\n}\n\nstatic void sccnxp_write(struct uart_port *port, u8 reg, u8 v)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\n\twriteb(v, port->membase + (reg << port->regshift));\n\n\tndelay(s->chip->trwd);\n}\n\nstatic u8 sccnxp_port_read(struct uart_port *port, u8 reg)\n{\n\treturn sccnxp_read(port, (port->line << 3) + reg);\n}\n\nstatic void sccnxp_port_write(struct uart_port *port, u8 reg, u8 v)\n{\n\tsccnxp_write(port, (port->line << 3) + reg, v);\n}\n\nstatic int sccnxp_update_best_err(int a, int b, int *besterr)\n{\n\tint err = abs(a - b);\n\n\tif (*besterr > err) {\n\t\t*besterr = err;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic const struct {\n\tu8\tcsr;\n\tu8\tacr;\n\tu8\tmr0;\n\tint\tbaud;\n} baud_std[] = {\n\t{ 0,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t50, },\n\t{ 0,\tACR_BAUD1,\tMR0_BAUD_NORMAL,\t75, },\n\t{ 1,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t110, },\n\t{ 2,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t134, },\n\t{ 3,\tACR_BAUD1,\tMR0_BAUD_NORMAL,\t150, },\n\t{ 3,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t200, },\n\t{ 4,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t300, },\n\t{ 0,\tACR_BAUD1,\tMR0_BAUD_EXT1,\t\t450, },\n\t{ 1,\tACR_BAUD0,\tMR0_BAUD_EXT2,\t\t880, },\n\t{ 3,\tACR_BAUD1,\tMR0_BAUD_EXT1,\t\t900, },\n\t{ 5,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t600, },\n\t{ 7,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t1050, },\n\t{ 2,\tACR_BAUD0,\tMR0_BAUD_EXT2,\t\t1076, },\n\t{ 6,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t1200, },\n\t{ 10,\tACR_BAUD1,\tMR0_BAUD_NORMAL,\t1800, },\n\t{ 7,\tACR_BAUD1,\tMR0_BAUD_NORMAL,\t2000, },\n\t{ 8,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t2400, },\n\t{ 5,\tACR_BAUD1,\tMR0_BAUD_EXT1,\t\t3600, },\n\t{ 9,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t4800, },\n\t{ 10,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t7200, },\n\t{ 11,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t9600, },\n\t{ 8,\tACR_BAUD0,\tMR0_BAUD_EXT1,\t\t14400, },\n\t{ 12,\tACR_BAUD1,\tMR0_BAUD_NORMAL,\t19200, },\n\t{ 9,\tACR_BAUD0,\tMR0_BAUD_EXT1,\t\t28800, },\n\t{ 12,\tACR_BAUD0,\tMR0_BAUD_NORMAL,\t38400, },\n\t{ 11,\tACR_BAUD0,\tMR0_BAUD_EXT1,\t\t57600, },\n\t{ 12,\tACR_BAUD1,\tMR0_BAUD_EXT1,\t\t115200, },\n\t{ 12,\tACR_BAUD0,\tMR0_BAUD_EXT1,\t\t230400, },\n\t{ 0, 0, 0, 0 }\n};\n\nstatic int sccnxp_set_baud(struct uart_port *port, int baud)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\tint div_std, tmp_baud, bestbaud = INT_MAX, besterr = INT_MAX;\n\tstruct sccnxp_chip *chip = s->chip;\n\tu8 i, acr = 0, csr = 0, mr0 = 0;\n\n\t \n\tdiv_std = DIV_ROUND_CLOSEST(port->uartclk, 2 * 16 * baud);\n\tif ((div_std >= 2) && (div_std <= 0xffff)) {\n\t\tbestbaud = DIV_ROUND_CLOSEST(port->uartclk, 2 * 16 * div_std);\n\t\tsccnxp_update_best_err(baud, bestbaud, &besterr);\n\t\tcsr = CSR_TIMER_MODE;\n\t\tsccnxp_port_write(port, SCCNXP_CTPU_REG, div_std >> 8);\n\t\tsccnxp_port_write(port, SCCNXP_CTPL_REG, div_std);\n\t\t \n\t\tsccnxp_port_read(port, SCCNXP_START_COUNTER_REG);\n\t}\n\n\t \n\tfor (i = 0; baud_std[i].baud && besterr; i++) {\n\t\tif (baud_std[i].mr0 && !(chip->flags & SCCNXP_HAVE_MR0))\n\t\t\tcontinue;\n\t\tdiv_std = DIV_ROUND_CLOSEST(chip->freq_std, baud_std[i].baud);\n\t\ttmp_baud = DIV_ROUND_CLOSEST(port->uartclk, div_std);\n\t\tif (!sccnxp_update_best_err(baud, tmp_baud, &besterr)) {\n\t\t\tacr = baud_std[i].acr;\n\t\t\tcsr = baud_std[i].csr;\n\t\t\tmr0 = baud_std[i].mr0;\n\t\t\tbestbaud = tmp_baud;\n\t\t}\n\t}\n\n\tif (chip->flags & SCCNXP_HAVE_MR0) {\n\t\t \n\t\tmr0 |= MR0_FIFO | MR0_TXLVL;\n\t\t \n\t\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_MRPTR0);\n\t\tsccnxp_port_write(port, SCCNXP_MR_REG, mr0);\n\t}\n\n\tsccnxp_port_write(port, SCCNXP_ACR_REG, acr | ACR_TIMER_MODE);\n\tsccnxp_port_write(port, SCCNXP_CSR_REG, (csr << 4) | csr);\n\n\tif (baud != bestbaud)\n\t\tdev_dbg(port->dev, \"Baudrate desired: %i, calculated: %i\\n\",\n\t\t\tbaud, bestbaud);\n\n\treturn bestbaud;\n}\n\nstatic void sccnxp_enable_irq(struct uart_port *port, int mask)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\n\ts->imr |= mask << (port->line * 4);\n\tsccnxp_write(port, SCCNXP_IMR_REG, s->imr);\n}\n\nstatic void sccnxp_disable_irq(struct uart_port *port, int mask)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\n\ts->imr &= ~(mask << (port->line * 4));\n\tsccnxp_write(port, SCCNXP_IMR_REG, s->imr);\n}\n\nstatic void sccnxp_set_bit(struct uart_port *port, int sig, int state)\n{\n\tu8 bitmask;\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\n\tif (s->pdata.mctrl_cfg[port->line] & MCTRL_MASK(sig)) {\n\t\tbitmask = 1 << MCTRL_OBIT(s->pdata.mctrl_cfg[port->line], sig);\n\t\tif (state)\n\t\t\tsccnxp_write(port, SCCNXP_SOP_REG, bitmask);\n\t\telse\n\t\t\tsccnxp_write(port, SCCNXP_ROP_REG, bitmask);\n\t}\n}\n\nstatic void sccnxp_handle_rx(struct uart_port *port)\n{\n\tu8 sr, ch, flag;\n\n\tfor (;;) {\n\t\tsr = sccnxp_port_read(port, SCCNXP_SR_REG);\n\t\tif (!(sr & SR_RXRDY))\n\t\t\tbreak;\n\t\tsr &= SR_PE | SR_FE | SR_OVR | SR_BRK;\n\n\t\tch = sccnxp_port_read(port, SCCNXP_RHR_REG);\n\n\t\tport->icount.rx++;\n\t\tflag = TTY_NORMAL;\n\n\t\tif (unlikely(sr)) {\n\t\t\tif (sr & SR_BRK) {\n\t\t\t\tport->icount.brk++;\n\t\t\t\tsccnxp_port_write(port, SCCNXP_CR_REG,\n\t\t\t\t\t\t  CR_CMD_BREAK_RESET);\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (sr & SR_PE)\n\t\t\t\tport->icount.parity++;\n\t\t\telse if (sr & SR_FE)\n\t\t\t\tport->icount.frame++;\n\t\t\telse if (sr & SR_OVR) {\n\t\t\t\tport->icount.overrun++;\n\t\t\t\tsccnxp_port_write(port, SCCNXP_CR_REG,\n\t\t\t\t\t\t  CR_CMD_STATUS_RESET);\n\t\t\t}\n\n\t\t\tsr &= port->read_status_mask;\n\t\t\tif (sr & SR_BRK)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (sr & SR_PE)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (sr & SR_FE)\n\t\t\t\tflag = TTY_FRAME;\n\t\t\telse if (sr & SR_OVR)\n\t\t\t\tflag = TTY_OVERRUN;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tcontinue;\n\n\t\tif (sr & port->ignore_status_mask)\n\t\t\tcontinue;\n\n\t\tuart_insert_char(port, sr, SR_OVR, ch, flag);\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic void sccnxp_handle_tx(struct uart_port *port)\n{\n\tu8 sr;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\n\tif (unlikely(port->x_char)) {\n\t\tsccnxp_port_write(port, SCCNXP_THR_REG, port->x_char);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\t \n\t\tif (sccnxp_port_read(port, SCCNXP_SR_REG) & SR_TXEMT) {\n\t\t\tsccnxp_disable_irq(port, IMR_TXRDY);\n\n\t\t\t \n\t\t\tif (s->chip->flags & SCCNXP_HAVE_IO)\n\t\t\t\tsccnxp_set_bit(port, DIR_OP, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\twhile (!uart_circ_empty(xmit)) {\n\t\tsr = sccnxp_port_read(port, SCCNXP_SR_REG);\n\t\tif (!(sr & SR_TXRDY))\n\t\t\tbreak;\n\n\t\tsccnxp_port_write(port, SCCNXP_THR_REG, xmit->buf[xmit->tail]);\n\t\tuart_xmit_advance(port, 1);\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n}\n\nstatic void sccnxp_handle_events(struct sccnxp_port *s)\n{\n\tint i;\n\tu8 isr;\n\n\tdo {\n\t\tisr = sccnxp_read(&s->port[0], SCCNXP_ISR_REG);\n\t\tisr &= s->imr;\n\t\tif (!isr)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < s->uart.nr; i++) {\n\t\t\tif (s->opened[i] && (isr & ISR_RXRDY(i)))\n\t\t\t\tsccnxp_handle_rx(&s->port[i]);\n\t\t\tif (s->opened[i] && (isr & ISR_TXRDY(i)))\n\t\t\t\tsccnxp_handle_tx(&s->port[i]);\n\t\t}\n\t} while (1);\n}\n\nstatic void sccnxp_timer(struct timer_list *t)\n{\n\tstruct sccnxp_port *s = from_timer(s, t, timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tsccnxp_handle_events(s);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\tmod_timer(&s->timer, jiffies + usecs_to_jiffies(s->pdata.poll_time_us));\n}\n\nstatic irqreturn_t sccnxp_ist(int irq, void *dev_id)\n{\n\tstruct sccnxp_port *s = (struct sccnxp_port *)dev_id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tsccnxp_handle_events(s);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sccnxp_start_tx(struct uart_port *port)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\n\t \n\tif (s->chip->flags & SCCNXP_HAVE_IO)\n\t\tsccnxp_set_bit(port, DIR_OP, 1);\n\n\tsccnxp_enable_irq(port, IMR_TXRDY);\n\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic void sccnxp_stop_tx(struct uart_port *port)\n{\n\t \n}\n\nstatic void sccnxp_stop_rx(struct uart_port *port)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_RX_DISABLE);\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic unsigned int sccnxp_tx_empty(struct uart_port *port)\n{\n\tu8 val;\n\tunsigned long flags;\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tval = sccnxp_port_read(port, SCCNXP_SR_REG);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn (val & SR_TXEMT) ? TIOCSER_TEMT : 0;\n}\n\nstatic void sccnxp_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\tunsigned long flags;\n\n\tif (!(s->chip->flags & SCCNXP_HAVE_IO))\n\t\treturn;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\n\tsccnxp_set_bit(port, DTR_OP, mctrl & TIOCM_DTR);\n\tsccnxp_set_bit(port, RTS_OP, mctrl & TIOCM_RTS);\n\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic unsigned int sccnxp_get_mctrl(struct uart_port *port)\n{\n\tu8 bitmask, ipr;\n\tunsigned long flags;\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\tunsigned int mctrl = TIOCM_DSR | TIOCM_CTS | TIOCM_CAR;\n\n\tif (!(s->chip->flags & SCCNXP_HAVE_IO))\n\t\treturn mctrl;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\n\tipr = ~sccnxp_read(port, SCCNXP_IPCR_REG);\n\n\tif (s->pdata.mctrl_cfg[port->line] & MCTRL_MASK(DSR_IP)) {\n\t\tbitmask = 1 << MCTRL_IBIT(s->pdata.mctrl_cfg[port->line],\n\t\t\t\t\t  DSR_IP);\n\t\tmctrl &= ~TIOCM_DSR;\n\t\tmctrl |= (ipr & bitmask) ? TIOCM_DSR : 0;\n\t}\n\tif (s->pdata.mctrl_cfg[port->line] & MCTRL_MASK(CTS_IP)) {\n\t\tbitmask = 1 << MCTRL_IBIT(s->pdata.mctrl_cfg[port->line],\n\t\t\t\t\t  CTS_IP);\n\t\tmctrl &= ~TIOCM_CTS;\n\t\tmctrl |= (ipr & bitmask) ? TIOCM_CTS : 0;\n\t}\n\tif (s->pdata.mctrl_cfg[port->line] & MCTRL_MASK(DCD_IP)) {\n\t\tbitmask = 1 << MCTRL_IBIT(s->pdata.mctrl_cfg[port->line],\n\t\t\t\t\t  DCD_IP);\n\t\tmctrl &= ~TIOCM_CAR;\n\t\tmctrl |= (ipr & bitmask) ? TIOCM_CAR : 0;\n\t}\n\tif (s->pdata.mctrl_cfg[port->line] & MCTRL_MASK(RNG_IP)) {\n\t\tbitmask = 1 << MCTRL_IBIT(s->pdata.mctrl_cfg[port->line],\n\t\t\t\t\t  RNG_IP);\n\t\tmctrl &= ~TIOCM_RNG;\n\t\tmctrl |= (ipr & bitmask) ? TIOCM_RNG : 0;\n\t}\n\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn mctrl;\n}\n\nstatic void sccnxp_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tsccnxp_port_write(port, SCCNXP_CR_REG, break_state ?\n\t\t\t  CR_CMD_START_BREAK : CR_CMD_STOP_BREAK);\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic void sccnxp_set_termios(struct uart_port *port,\n\t\t\t       struct ktermios *termios,\n\t\t\t       const struct ktermios *old)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\tunsigned long flags;\n\tu8 mr1, mr2;\n\tint baud;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\n\t \n\ttermios->c_cflag &= ~CMSPAR;\n\n\t \n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_RX_RESET |\n\t\t\t\t\t       CR_RX_DISABLE | CR_TX_DISABLE);\n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_TX_RESET);\n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_STATUS_RESET);\n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_BREAK_RESET);\n\n\t \n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tmr1 = MR1_BITS_5;\n\t\tbreak;\n\tcase CS6:\n\t\tmr1 = MR1_BITS_6;\n\t\tbreak;\n\tcase CS7:\n\t\tmr1 = MR1_BITS_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tmr1 = MR1_BITS_8;\n\t\tbreak;\n\t}\n\n\t \n\tif (termios->c_cflag & PARENB) {\n\t\tif (termios->c_cflag & PARODD)\n\t\t\tmr1 |= MR1_PAR_ODD;\n\t} else\n\t\tmr1 |= MR1_PAR_NO;\n\n\t \n\tmr2 = (termios->c_cflag & CSTOPB) ? MR2_STOP2 : MR2_STOP1;\n\n\t \n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_MRPTR1);\n\tsccnxp_port_write(port, SCCNXP_MR_REG, mr1);\n\tsccnxp_port_write(port, SCCNXP_MR_REG, mr2);\n\n\t \n\tport->read_status_mask = SR_OVR;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= SR_PE | SR_FE;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tport->read_status_mask |= SR_BRK;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNBRK)\n\t\tport->ignore_status_mask |= SR_BRK;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= SR_PE;\n\tif (!(termios->c_cflag & CREAD))\n\t\tport->ignore_status_mask |= SR_PE | SR_OVR | SR_FE | SR_BRK;\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 50,\n\t\t\t\t  (s->chip->flags & SCCNXP_HAVE_MR0) ?\n\t\t\t\t  230400 : 38400);\n\tbaud = sccnxp_set_baud(port, baud);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\n\t \n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_RX_ENABLE | CR_TX_ENABLE);\n\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic int sccnxp_startup(struct uart_port *port)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\n\tif (s->chip->flags & SCCNXP_HAVE_IO) {\n\t\t \n\t\tsccnxp_write(port, SCCNXP_OPCR_REG, 0);\n\t}\n\n\t \n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_RX_RESET);\n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_TX_RESET);\n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_STATUS_RESET);\n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_BREAK_RESET);\n\n\t \n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_RX_ENABLE | CR_TX_ENABLE);\n\n\t \n\tsccnxp_enable_irq(port, IMR_RXRDY);\n\n\ts->opened[port->line] = 1;\n\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\treturn 0;\n}\n\nstatic void sccnxp_shutdown(struct uart_port *port)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\n\ts->opened[port->line] = 0;\n\n\t \n\tsccnxp_disable_irq(port, IMR_TXRDY | IMR_RXRDY);\n\n\t \n\tsccnxp_port_write(port, SCCNXP_CR_REG, CR_RX_DISABLE | CR_TX_DISABLE);\n\n\t \n\tif (s->chip->flags & SCCNXP_HAVE_IO)\n\t\tsccnxp_set_bit(port, DIR_OP, 0);\n\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic const char *sccnxp_type(struct uart_port *port)\n{\n\tstruct sccnxp_port *s = dev_get_drvdata(port->dev);\n\n\treturn (port->type == PORT_SC26XX) ? s->chip->name : NULL;\n}\n\nstatic void sccnxp_release_port(struct uart_port *port)\n{\n\t \n}\n\nstatic int sccnxp_request_port(struct uart_port *port)\n{\n\t \n\treturn 0;\n}\n\nstatic void sccnxp_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_SC26XX;\n}\n\nstatic int sccnxp_verify_port(struct uart_port *port, struct serial_struct *s)\n{\n\tif ((s->type == PORT_UNKNOWN) || (s->type == PORT_SC26XX))\n\t\treturn 0;\n\tif (s->irq == port->irq)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic const struct uart_ops sccnxp_ops = {\n\t.tx_empty\t= sccnxp_tx_empty,\n\t.set_mctrl\t= sccnxp_set_mctrl,\n\t.get_mctrl\t= sccnxp_get_mctrl,\n\t.stop_tx\t= sccnxp_stop_tx,\n\t.start_tx\t= sccnxp_start_tx,\n\t.stop_rx\t= sccnxp_stop_rx,\n\t.break_ctl\t= sccnxp_break_ctl,\n\t.startup\t= sccnxp_startup,\n\t.shutdown\t= sccnxp_shutdown,\n\t.set_termios\t= sccnxp_set_termios,\n\t.type\t\t= sccnxp_type,\n\t.release_port\t= sccnxp_release_port,\n\t.request_port\t= sccnxp_request_port,\n\t.config_port\t= sccnxp_config_port,\n\t.verify_port\t= sccnxp_verify_port,\n};\n\n#ifdef CONFIG_SERIAL_SCCNXP_CONSOLE\nstatic void sccnxp_console_putchar(struct uart_port *port, unsigned char c)\n{\n\tint tryes = 100000;\n\n\twhile (tryes--) {\n\t\tif (sccnxp_port_read(port, SCCNXP_SR_REG) & SR_TXRDY) {\n\t\t\tsccnxp_port_write(port, SCCNXP_THR_REG, c);\n\t\t\tbreak;\n\t\t}\n\t\tbarrier();\n\t}\n}\n\nstatic void sccnxp_console_write(struct console *co, const char *c, unsigned n)\n{\n\tstruct sccnxp_port *s = (struct sccnxp_port *)co->data;\n\tstruct uart_port *port = &s->port[co->index];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tuart_console_write(port, c, n, sccnxp_console_putchar);\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic int sccnxp_console_setup(struct console *co, char *options)\n{\n\tstruct sccnxp_port *s = (struct sccnxp_port *)co->data;\n\tstruct uart_port *port = &s->port[(co->index > 0) ? co->index : 0];\n\tint baud = 9600, bits = 8, parity = 'n', flow = 'n';\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n#endif\n\nstatic const struct platform_device_id sccnxp_id_table[] = {\n\t{ .name = \"sc2681\",\t.driver_data = (kernel_ulong_t)&sc2681, },\n\t{ .name = \"sc2691\",\t.driver_data = (kernel_ulong_t)&sc2691, },\n\t{ .name = \"sc2692\",\t.driver_data = (kernel_ulong_t)&sc2692, },\n\t{ .name = \"sc2891\",\t.driver_data = (kernel_ulong_t)&sc2891, },\n\t{ .name = \"sc2892\",\t.driver_data = (kernel_ulong_t)&sc2892, },\n\t{ .name = \"sc28202\",\t.driver_data = (kernel_ulong_t)&sc28202, },\n\t{ .name = \"sc68681\",\t.driver_data = (kernel_ulong_t)&sc68681, },\n\t{ .name = \"sc68692\",\t.driver_data = (kernel_ulong_t)&sc68692, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, sccnxp_id_table);\n\nstatic int sccnxp_probe(struct platform_device *pdev)\n{\n\tstruct sccnxp_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tstruct resource *res;\n\tint i, ret, uartclk;\n\tstruct sccnxp_port *s;\n\tvoid __iomem *membase;\n\tstruct clk *clk;\n\n\tmembase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(membase))\n\t\treturn PTR_ERR(membase);\n\n\ts = devm_kzalloc(&pdev->dev, sizeof(struct sccnxp_port), GFP_KERNEL);\n\tif (!s) {\n\t\tdev_err(&pdev->dev, \"Error allocating port structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tplatform_set_drvdata(pdev, s);\n\n\tspin_lock_init(&s->lock);\n\n\ts->chip = (struct sccnxp_chip *)pdev->id_entry->driver_data;\n\n\ts->regulator = devm_regulator_get(&pdev->dev, \"vcc\");\n\tif (!IS_ERR(s->regulator)) {\n\t\tret = regulator_enable(s->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to enable regulator: %i\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else if (PTR_ERR(s->regulator) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tclk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto err_out;\n\t\tuartclk = 0;\n\t} else {\n\t\tuartclk = clk_get_rate(clk);\n\t}\n\n\tif (!uartclk) {\n\t\tdev_notice(&pdev->dev, \"Using default clock frequency\\n\");\n\t\tuartclk = s->chip->freq_std;\n\t}\n\n\t \n\tif ((uartclk < s->chip->freq_min) || (uartclk > s->chip->freq_max)) {\n\t\tdev_err(&pdev->dev, \"Frequency out of bounds\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (pdata)\n\t\tmemcpy(&s->pdata, pdata, sizeof(struct sccnxp_pdata));\n\n\tif (s->pdata.poll_time_us) {\n\t\tdev_info(&pdev->dev, \"Using poll mode, resolution %u usecs\\n\",\n\t\t\t s->pdata.poll_time_us);\n\t\ts->poll = 1;\n\t}\n\n\tif (!s->poll) {\n\t\ts->irq = platform_get_irq(pdev, 0);\n\t\tif (s->irq < 0) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\ts->uart.owner\t\t= THIS_MODULE;\n\ts->uart.dev_name\t= \"ttySC\";\n\ts->uart.major\t\t= SCCNXP_MAJOR;\n\ts->uart.minor\t\t= SCCNXP_MINOR;\n\ts->uart.nr\t\t= s->chip->nr;\n#ifdef CONFIG_SERIAL_SCCNXP_CONSOLE\n\ts->uart.cons\t\t= &s->console;\n\ts->uart.cons->device\t= uart_console_device;\n\ts->uart.cons->write\t= sccnxp_console_write;\n\ts->uart.cons->setup\t= sccnxp_console_setup;\n\ts->uart.cons->flags\t= CON_PRINTBUFFER;\n\ts->uart.cons->index\t= -1;\n\ts->uart.cons->data\t= s;\n\tstrcpy(s->uart.cons->name, \"ttySC\");\n#endif\n\tret = uart_register_driver(&s->uart);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Registering UART driver failed\\n\");\n\t\tgoto err_out;\n\t}\n\n\tfor (i = 0; i < s->uart.nr; i++) {\n\t\ts->port[i].line\t\t= i;\n\t\ts->port[i].dev\t\t= &pdev->dev;\n\t\ts->port[i].irq\t\t= s->irq;\n\t\ts->port[i].type\t\t= PORT_SC26XX;\n\t\ts->port[i].fifosize\t= s->chip->fifosize;\n\t\ts->port[i].flags\t= UPF_SKIP_TEST | UPF_FIXED_TYPE;\n\t\ts->port[i].iotype\t= UPIO_MEM;\n\t\ts->port[i].mapbase\t= res->start;\n\t\ts->port[i].membase\t= membase;\n\t\ts->port[i].regshift\t= s->pdata.reg_shift;\n\t\ts->port[i].uartclk\t= uartclk;\n\t\ts->port[i].ops\t\t= &sccnxp_ops;\n\t\ts->port[i].has_sysrq = IS_ENABLED(CONFIG_SERIAL_SCCNXP_CONSOLE);\n\t\tuart_add_one_port(&s->uart, &s->port[i]);\n\t\t \n\t\tif (s->chip->flags & SCCNXP_HAVE_IO)\n\t\t\tsccnxp_set_bit(&s->port[i], DIR_OP, 0);\n\t}\n\n\t \n\ts->imr = 0;\n\tsccnxp_write(&s->port[0], SCCNXP_IMR_REG, 0);\n\n\tif (!s->poll) {\n\t\tret = devm_request_threaded_irq(&pdev->dev, s->irq, NULL,\n\t\t\t\t\t\tsccnxp_ist,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(&pdev->dev), s);\n\t\tif (!ret)\n\t\t\treturn 0;\n\n\t\tdev_err(&pdev->dev, \"Unable to reguest IRQ %i\\n\", s->irq);\n\t} else {\n\t\ttimer_setup(&s->timer, sccnxp_timer, 0);\n\t\tmod_timer(&s->timer, jiffies +\n\t\t\t  usecs_to_jiffies(s->pdata.poll_time_us));\n\t\treturn 0;\n\t}\n\n\tuart_unregister_driver(&s->uart);\nerr_out:\n\tif (!IS_ERR(s->regulator))\n\t\tregulator_disable(s->regulator);\n\n\treturn ret;\n}\n\nstatic int sccnxp_remove(struct platform_device *pdev)\n{\n\tint i;\n\tstruct sccnxp_port *s = platform_get_drvdata(pdev);\n\n\tif (!s->poll)\n\t\tdevm_free_irq(&pdev->dev, s->irq, s);\n\telse\n\t\tdel_timer_sync(&s->timer);\n\n\tfor (i = 0; i < s->uart.nr; i++)\n\t\tuart_remove_one_port(&s->uart, &s->port[i]);\n\n\tuart_unregister_driver(&s->uart);\n\n\tif (!IS_ERR(s->regulator))\n\t\treturn regulator_disable(s->regulator);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sccnxp_uart_driver = {\n\t.driver = {\n\t\t.name\t= SCCNXP_NAME,\n\t},\n\t.probe\t\t= sccnxp_probe,\n\t.remove\t\t= sccnxp_remove,\n\t.id_table\t= sccnxp_id_table,\n};\nmodule_platform_driver(sccnxp_uart_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Alexander Shiyan <shc_work@mail.ru>\");\nMODULE_DESCRIPTION(\"SCCNXP serial driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}