{
  "module_name": "uartlite.c",
  "hash_id": "65773bec7f3b6857a7f962f3c43c0dad0de8d6504ca140c073b2e678185c2cd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/uartlite.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/bitfield.h>\n#include <linux/console.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/pm_runtime.h>\n\n#define ULITE_NAME\t\t\"ttyUL\"\n#define ULITE_MAJOR\t\t204\n#define ULITE_MINOR\t\t187\n#define ULITE_NR_UARTS\t\tCONFIG_SERIAL_UARTLITE_NR_UARTS\n\n \n\n#define ULITE_RX\t\t0x00\n#define ULITE_TX\t\t0x04\n#define ULITE_STATUS\t\t0x08\n#define ULITE_CONTROL\t\t0x0c\n\n#define ULITE_REGION\t\t16\n\n#define ULITE_STATUS_RXVALID\t0x01\n#define ULITE_STATUS_RXFULL\t0x02\n#define ULITE_STATUS_TXEMPTY\t0x04\n#define ULITE_STATUS_TXFULL\t0x08\n#define ULITE_STATUS_IE\t\t0x10\n#define ULITE_STATUS_OVERRUN\t0x20\n#define ULITE_STATUS_FRAME\t0x40\n#define ULITE_STATUS_PARITY\t0x80\n\n#define ULITE_CONTROL_RST_TX\t0x01\n#define ULITE_CONTROL_RST_RX\t0x02\n#define ULITE_CONTROL_IE\t0x10\n#define UART_AUTOSUSPEND_TIMEOUT\t3000\t \n\n \n#ifdef CONFIG_SERIAL_UARTLITE_CONSOLE\nstatic struct uart_port *console_port;\n#endif\n\n \nstruct uartlite_data {\n\tconst struct uartlite_reg_ops *reg_ops;\n\tstruct clk *clk;\n\tunsigned int baud;\n\ttcflag_t cflags;\n};\n\nstruct uartlite_reg_ops {\n\tu32 (*in)(void __iomem *addr);\n\tvoid (*out)(u32 val, void __iomem *addr);\n};\n\nstatic u32 uartlite_inbe32(void __iomem *addr)\n{\n\treturn ioread32be(addr);\n}\n\nstatic void uartlite_outbe32(u32 val, void __iomem *addr)\n{\n\tiowrite32be(val, addr);\n}\n\nstatic const struct uartlite_reg_ops uartlite_be = {\n\t.in = uartlite_inbe32,\n\t.out = uartlite_outbe32,\n};\n\nstatic u32 uartlite_inle32(void __iomem *addr)\n{\n\treturn ioread32(addr);\n}\n\nstatic void uartlite_outle32(u32 val, void __iomem *addr)\n{\n\tiowrite32(val, addr);\n}\n\nstatic const struct uartlite_reg_ops uartlite_le = {\n\t.in = uartlite_inle32,\n\t.out = uartlite_outle32,\n};\n\nstatic inline u32 uart_in32(u32 offset, struct uart_port *port)\n{\n\tstruct uartlite_data *pdata = port->private_data;\n\n\treturn pdata->reg_ops->in(port->membase + offset);\n}\n\nstatic inline void uart_out32(u32 val, u32 offset, struct uart_port *port)\n{\n\tstruct uartlite_data *pdata = port->private_data;\n\n\tpdata->reg_ops->out(val, port->membase + offset);\n}\n\nstatic struct uart_port ulite_ports[ULITE_NR_UARTS];\n\nstatic struct uart_driver ulite_uart_driver;\n\n \n\nstatic int ulite_receive(struct uart_port *port, int stat)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned char ch = 0;\n\tchar flag = TTY_NORMAL;\n\n\tif ((stat & (ULITE_STATUS_RXVALID | ULITE_STATUS_OVERRUN\n\t\t     | ULITE_STATUS_FRAME)) == 0)\n\t\treturn 0;\n\n\t \n\tif (stat & ULITE_STATUS_RXVALID) {\n\t\tport->icount.rx++;\n\t\tch = uart_in32(ULITE_RX, port);\n\n\t\tif (stat & ULITE_STATUS_PARITY)\n\t\t\tport->icount.parity++;\n\t}\n\n\tif (stat & ULITE_STATUS_OVERRUN)\n\t\tport->icount.overrun++;\n\n\tif (stat & ULITE_STATUS_FRAME)\n\t\tport->icount.frame++;\n\n\n\t \n\tif (stat & port->ignore_status_mask & ULITE_STATUS_PARITY)\n\t\tstat &= ~ULITE_STATUS_RXVALID;\n\n\tstat &= port->read_status_mask;\n\n\tif (stat & ULITE_STATUS_PARITY)\n\t\tflag = TTY_PARITY;\n\n\n\tstat &= ~port->ignore_status_mask;\n\n\tif (stat & ULITE_STATUS_RXVALID)\n\t\ttty_insert_flip_char(tport, ch, flag);\n\n\tif (stat & ULITE_STATUS_FRAME)\n\t\ttty_insert_flip_char(tport, 0, TTY_FRAME);\n\n\tif (stat & ULITE_STATUS_OVERRUN)\n\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\n\treturn 1;\n}\n\nstatic int ulite_transmit(struct uart_port *port, int stat)\n{\n\tstruct circ_buf *xmit  = &port->state->xmit;\n\n\tif (stat & ULITE_STATUS_TXFULL)\n\t\treturn 0;\n\n\tif (port->x_char) {\n\t\tuart_out32(port->x_char, ULITE_TX, port);\n\t\tport->x_char = 0;\n\t\tport->icount.tx++;\n\t\treturn 1;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port))\n\t\treturn 0;\n\n\tuart_out32(xmit->buf[xmit->tail], ULITE_TX, port);\n\tuart_xmit_advance(port, 1);\n\n\t \n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\treturn 1;\n}\n\nstatic irqreturn_t ulite_isr(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tint stat, busy, n = 0;\n\tunsigned long flags;\n\n\tdo {\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tstat = uart_in32(ULITE_STATUS, port);\n\t\tbusy  = ulite_receive(port, stat);\n\t\tbusy |= ulite_transmit(port, stat);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tn++;\n\t} while (busy);\n\n\t \n\tif (n > 1) {\n\t\ttty_flip_buffer_push(&port->state->port);\n\t\treturn IRQ_HANDLED;\n\t} else {\n\t\treturn IRQ_NONE;\n\t}\n}\n\nstatic unsigned int ulite_tx_empty(struct uart_port *port)\n{\n\tunsigned long flags;\n\tunsigned int ret;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tret = uart_in32(ULITE_STATUS, port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn ret & ULITE_STATUS_TXEMPTY ? TIOCSER_TEMT : 0;\n}\n\nstatic unsigned int ulite_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\n}\n\nstatic void ulite_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\t \n}\n\nstatic void ulite_stop_tx(struct uart_port *port)\n{\n\t \n}\n\nstatic void ulite_start_tx(struct uart_port *port)\n{\n\tulite_transmit(port, uart_in32(ULITE_STATUS, port));\n}\n\nstatic void ulite_stop_rx(struct uart_port *port)\n{\n\t \n\tport->ignore_status_mask = ULITE_STATUS_RXVALID | ULITE_STATUS_PARITY\n\t\t| ULITE_STATUS_FRAME | ULITE_STATUS_OVERRUN;\n}\n\nstatic void ulite_break_ctl(struct uart_port *port, int ctl)\n{\n\t \n}\n\nstatic int ulite_startup(struct uart_port *port)\n{\n\tstruct uartlite_data *pdata = port->private_data;\n\tint ret;\n\n\tret = clk_enable(pdata->clk);\n\tif (ret) {\n\t\tdev_err(port->dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = request_irq(port->irq, ulite_isr, IRQF_SHARED | IRQF_TRIGGER_RISING,\n\t\t\t  \"uartlite\", port);\n\tif (ret)\n\t\treturn ret;\n\n\tuart_out32(ULITE_CONTROL_RST_RX | ULITE_CONTROL_RST_TX,\n\t\tULITE_CONTROL, port);\n\tuart_out32(ULITE_CONTROL_IE, ULITE_CONTROL, port);\n\n\treturn 0;\n}\n\nstatic void ulite_shutdown(struct uart_port *port)\n{\n\tstruct uartlite_data *pdata = port->private_data;\n\n\tuart_out32(0, ULITE_CONTROL, port);\n\tuart_in32(ULITE_CONTROL, port);  \n\tfree_irq(port->irq, port);\n\tclk_disable(pdata->clk);\n}\n\nstatic void ulite_set_termios(struct uart_port *port,\n\t\t\t      struct ktermios *termios,\n\t\t\t      const struct ktermios *old)\n{\n\tunsigned long flags;\n\tstruct uartlite_data *pdata = port->private_data;\n\n\t \n\ttermios->c_iflag &= ~BRKINT;\n\ttermios->c_cflag &= ~(CSTOPB | PARENB | PARODD | CSIZE);\n\ttermios->c_cflag |= pdata->cflags & (PARENB | PARODD | CSIZE);\n\ttty_termios_encode_baud_rate(termios, pdata->baud, pdata->baud);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tport->read_status_mask = ULITE_STATUS_RXVALID | ULITE_STATUS_OVERRUN\n\t\t| ULITE_STATUS_TXFULL;\n\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |=\n\t\t\tULITE_STATUS_PARITY | ULITE_STATUS_FRAME;\n\n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= ULITE_STATUS_PARITY\n\t\t\t| ULITE_STATUS_FRAME | ULITE_STATUS_OVERRUN;\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |=\n\t\t\tULITE_STATUS_RXVALID | ULITE_STATUS_PARITY\n\t\t\t| ULITE_STATUS_FRAME | ULITE_STATUS_OVERRUN;\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, pdata->baud);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *ulite_type(struct uart_port *port)\n{\n\treturn port->type == PORT_UARTLITE ? \"uartlite\" : NULL;\n}\n\nstatic void ulite_release_port(struct uart_port *port)\n{\n\trelease_mem_region(port->mapbase, ULITE_REGION);\n\tiounmap(port->membase);\n\tport->membase = NULL;\n}\n\nstatic int ulite_request_port(struct uart_port *port)\n{\n\tstruct uartlite_data *pdata = port->private_data;\n\tint ret;\n\n\tpr_debug(\"ulite console: port=%p; port->mapbase=%llx\\n\",\n\t\t port, (unsigned long long) port->mapbase);\n\n\tif (!request_mem_region(port->mapbase, ULITE_REGION, \"uartlite\")) {\n\t\tdev_err(port->dev, \"Memory region busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tport->membase = ioremap(port->mapbase, ULITE_REGION);\n\tif (!port->membase) {\n\t\tdev_err(port->dev, \"Unable to map registers\\n\");\n\t\trelease_mem_region(port->mapbase, ULITE_REGION);\n\t\treturn -EBUSY;\n\t}\n\n\tpdata->reg_ops = &uartlite_be;\n\tret = uart_in32(ULITE_CONTROL, port);\n\tuart_out32(ULITE_CONTROL_RST_TX, ULITE_CONTROL, port);\n\tret = uart_in32(ULITE_STATUS, port);\n\t \n\tif ((ret & ULITE_STATUS_TXEMPTY) != ULITE_STATUS_TXEMPTY)\n\t\tpdata->reg_ops = &uartlite_le;\n\n\treturn 0;\n}\n\nstatic void ulite_config_port(struct uart_port *port, int flags)\n{\n\tif (!ulite_request_port(port))\n\t\tport->type = PORT_UARTLITE;\n}\n\nstatic int ulite_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic void ulite_pm(struct uart_port *port, unsigned int state,\n\t\t     unsigned int oldstate)\n{\n\tint ret;\n\n\tif (!state) {\n\t\tret = pm_runtime_get_sync(port->dev);\n\t\tif (ret < 0)\n\t\t\tdev_err(port->dev, \"Failed to enable clocks\\n\");\n\t} else {\n\t\tpm_runtime_mark_last_busy(port->dev);\n\t\tpm_runtime_put_autosuspend(port->dev);\n\t}\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int ulite_get_poll_char(struct uart_port *port)\n{\n\tif (!(uart_in32(ULITE_STATUS, port) & ULITE_STATUS_RXVALID))\n\t\treturn NO_POLL_CHAR;\n\n\treturn uart_in32(ULITE_RX, port);\n}\n\nstatic void ulite_put_poll_char(struct uart_port *port, unsigned char ch)\n{\n\twhile (uart_in32(ULITE_STATUS, port) & ULITE_STATUS_TXFULL)\n\t\tcpu_relax();\n\n\t \n\tuart_out32(ch, ULITE_TX, port);\n}\n#endif\n\nstatic const struct uart_ops ulite_ops = {\n\t.tx_empty\t= ulite_tx_empty,\n\t.set_mctrl\t= ulite_set_mctrl,\n\t.get_mctrl\t= ulite_get_mctrl,\n\t.stop_tx\t= ulite_stop_tx,\n\t.start_tx\t= ulite_start_tx,\n\t.stop_rx\t= ulite_stop_rx,\n\t.break_ctl\t= ulite_break_ctl,\n\t.startup\t= ulite_startup,\n\t.shutdown\t= ulite_shutdown,\n\t.set_termios\t= ulite_set_termios,\n\t.type\t\t= ulite_type,\n\t.release_port\t= ulite_release_port,\n\t.request_port\t= ulite_request_port,\n\t.config_port\t= ulite_config_port,\n\t.verify_port\t= ulite_verify_port,\n\t.pm\t\t= ulite_pm,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= ulite_get_poll_char,\n\t.poll_put_char\t= ulite_put_poll_char,\n#endif\n};\n\n \n\n#ifdef CONFIG_SERIAL_UARTLITE_CONSOLE\nstatic void ulite_console_wait_tx(struct uart_port *port)\n{\n\tu8 val;\n\n\t \n\tif (read_poll_timeout_atomic(uart_in32, val, !(val & ULITE_STATUS_TXFULL),\n\t\t\t\t     0, 1000000, false, ULITE_STATUS, port))\n\t\tdev_warn(port->dev,\n\t\t\t \"timeout waiting for TX buffer empty\\n\");\n}\n\nstatic void ulite_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tulite_console_wait_tx(port);\n\tuart_out32(ch, ULITE_TX, port);\n}\n\nstatic void ulite_console_write(struct console *co, const char *s,\n\t\t\t\tunsigned int count)\n{\n\tstruct uart_port *port = console_port;\n\tunsigned long flags;\n\tunsigned int ier;\n\tint locked = 1;\n\n\tif (oops_in_progress) {\n\t\tlocked = spin_trylock_irqsave(&port->lock, flags);\n\t} else\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tier = uart_in32(ULITE_STATUS, port) & ULITE_STATUS_IE;\n\tuart_out32(0, ULITE_CONTROL, port);\n\n\tuart_console_write(port, s, count, ulite_console_putchar);\n\n\tulite_console_wait_tx(port);\n\n\t \n\tif (ier)\n\t\tuart_out32(ULITE_CONTROL_IE, ULITE_CONTROL, port);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int ulite_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port = NULL;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index >= 0 && co->index < ULITE_NR_UARTS)\n\t\tport = ulite_ports + co->index;\n\n\t \n\tif (!port || !port->mapbase) {\n\t\tpr_debug(\"console on ttyUL%i not present\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\n\tconsole_port = port;\n\n\t \n\tif (!port->membase) {\n\t\tif (ulite_request_port(port))\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct console ulite_console = {\n\t.name\t= ULITE_NAME,\n\t.write\t= ulite_console_write,\n\t.device\t= uart_console_device,\n\t.setup\t= ulite_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,  \n\t.data\t= &ulite_uart_driver,\n};\n\nstatic void early_uartlite_putc(struct uart_port *port, unsigned char c)\n{\n\t \n\tunsigned retries = 1000000;\n\n\twhile (--retries &&\n\t       (readl(port->membase + ULITE_STATUS) & ULITE_STATUS_TXFULL))\n\t\t;\n\n\t \n\tif (retries)\n\t\twritel(c & 0xff, port->membase + ULITE_TX);\n}\n\nstatic void early_uartlite_write(struct console *console,\n\t\t\t\t const char *s, unsigned n)\n{\n\tstruct earlycon_device *device = console->data;\n\tuart_console_write(&device->port, s, n, early_uartlite_putc);\n}\n\nstatic int __init early_uartlite_setup(struct earlycon_device *device,\n\t\t\t\t       const char *options)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = early_uartlite_write;\n\treturn 0;\n}\nEARLYCON_DECLARE(uartlite, early_uartlite_setup);\nOF_EARLYCON_DECLARE(uartlite_b, \"xlnx,opb-uartlite-1.00.b\", early_uartlite_setup);\nOF_EARLYCON_DECLARE(uartlite_a, \"xlnx,xps-uartlite-1.00.a\", early_uartlite_setup);\n\n#endif  \n\nstatic struct uart_driver ulite_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"uartlite\",\n\t.dev_name\t= ULITE_NAME,\n\t.major\t\t= ULITE_MAJOR,\n\t.minor\t\t= ULITE_MINOR,\n\t.nr\t\t= ULITE_NR_UARTS,\n#ifdef CONFIG_SERIAL_UARTLITE_CONSOLE\n\t.cons\t\t= &ulite_console,\n#endif\n};\n\n \n\n \nstatic int ulite_assign(struct device *dev, int id, phys_addr_t base, int irq,\n\t\t\tstruct uartlite_data *pdata)\n{\n\tstruct uart_port *port;\n\tint rc;\n\n\t \n\tif (id < 0) {\n\t\tfor (id = 0; id < ULITE_NR_UARTS; id++)\n\t\t\tif (ulite_ports[id].mapbase == 0)\n\t\t\t\tbreak;\n\t}\n\tif (id < 0 || id >= ULITE_NR_UARTS) {\n\t\tdev_err(dev, \"%s%i too large\\n\", ULITE_NAME, id);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ulite_ports[id].mapbase) && (ulite_ports[id].mapbase != base)) {\n\t\tdev_err(dev, \"cannot assign to %s%i; it is already in use\\n\",\n\t\t\tULITE_NAME, id);\n\t\treturn -EBUSY;\n\t}\n\n\tport = &ulite_ports[id];\n\n\tspin_lock_init(&port->lock);\n\tport->fifosize = 16;\n\tport->regshift = 2;\n\tport->iotype = UPIO_MEM;\n\tport->iobase = 1;  \n\tport->mapbase = base;\n\tport->membase = NULL;\n\tport->ops = &ulite_ops;\n\tport->irq = irq;\n\tport->flags = UPF_BOOT_AUTOCONF;\n\tport->dev = dev;\n\tport->type = PORT_UNKNOWN;\n\tport->line = id;\n\tport->private_data = pdata;\n\n\tdev_set_drvdata(dev, port);\n\n\t \n\trc = uart_add_one_port(&ulite_uart_driver, port);\n\tif (rc) {\n\t\tdev_err(dev, \"uart_add_one_port() failed; err=%i\\n\", rc);\n\t\tport->mapbase = 0;\n\t\tdev_set_drvdata(dev, NULL);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ulite_release(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\n\tif (port) {\n\t\tuart_remove_one_port(&ulite_uart_driver, port);\n\t\tdev_set_drvdata(dev, NULL);\n\t\tport->mapbase = 0;\n\t}\n}\n\n \nstatic int __maybe_unused ulite_suspend(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\n\tif (port)\n\t\tuart_suspend_port(&ulite_uart_driver, port);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused ulite_resume(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\n\tif (port)\n\t\tuart_resume_port(&ulite_uart_driver, port);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ulite_runtime_suspend(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct uartlite_data *pdata = port->private_data;\n\n\tclk_disable(pdata->clk);\n\treturn 0;\n};\n\nstatic int __maybe_unused ulite_runtime_resume(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct uartlite_data *pdata = port->private_data;\n\tint ret;\n\n\tret = clk_enable(pdata->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable clock.\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \n\nstatic const struct dev_pm_ops ulite_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ulite_suspend, ulite_resume)\n\tSET_RUNTIME_PM_OPS(ulite_runtime_suspend,\n\t\t\t   ulite_runtime_resume, NULL)\n};\n\n#if defined(CONFIG_OF)\n \nstatic const struct of_device_id ulite_of_match[] = {\n\t{ .compatible = \"xlnx,opb-uartlite-1.00.b\", },\n\t{ .compatible = \"xlnx,xps-uartlite-1.00.a\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ulite_of_match);\n#endif  \n\nstatic int ulite_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct uartlite_data *pdata;\n\tint irq, ret;\n\tint id = pdev->id;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(struct uartlite_data),\n\t\t\t     GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tif (IS_ENABLED(CONFIG_OF)) {\n\t\tconst char *prop;\n\t\tstruct device_node *np = pdev->dev.of_node;\n\t\tu32 val = 0;\n\n\t\tprop = \"port-number\";\n\t\tret = of_property_read_u32(np, prop, &id);\n\t\tif (ret && ret != -EINVAL)\nof_err:\n\t\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t\t     \"could not read %s\\n\", prop);\n\n\t\tprop = \"current-speed\";\n\t\tret = of_property_read_u32(np, prop, &pdata->baud);\n\t\tif (ret)\n\t\t\tgoto of_err;\n\n\t\tprop = \"xlnx,use-parity\";\n\t\tret = of_property_read_u32(np, prop, &val);\n\t\tif (ret && ret != -EINVAL)\n\t\t\tgoto of_err;\n\n\t\tif (val) {\n\t\t\tprop = \"xlnx,odd-parity\";\n\t\t\tret = of_property_read_u32(np, prop, &val);\n\t\t\tif (ret)\n\t\t\t\tgoto of_err;\n\n\t\t\tif (val)\n\t\t\t\tpdata->cflags |= PARODD;\n\t\t\tpdata->cflags |= PARENB;\n\t\t}\n\n\t\tval = 8;\n\t\tprop = \"xlnx,data-bits\";\n\t\tret = of_property_read_u32(np, prop, &val);\n\t\tif (ret && ret != -EINVAL)\n\t\t\tgoto of_err;\n\n\t\tswitch (val) {\n\t\tcase 5:\n\t\t\tpdata->cflags |= CS5;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tpdata->cflags |= CS6;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tpdata->cflags |= CS7;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tpdata->cflags |= CS8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn dev_err_probe(&pdev->dev, -EINVAL,\n\t\t\t\t\t     \"bad data bits %d\\n\", val);\n\t\t}\n\t} else {\n\t\tpdata->baud = 9600;\n\t\tpdata->cflags = CS8;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tpdata->clk = devm_clk_get(&pdev->dev, \"s_axi_aclk\");\n\tif (IS_ERR(pdata->clk)) {\n\t\tif (PTR_ERR(pdata->clk) != -ENOENT)\n\t\t\treturn PTR_ERR(pdata->clk);\n\n\t\t \n\t\tpdata->clk = NULL;\n\t}\n\n\tret = clk_prepare_enable(pdata->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to prepare clock\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, UART_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tif (!ulite_uart_driver.state) {\n\t\tdev_dbg(&pdev->dev, \"uartlite: calling uart_register_driver()\\n\");\n\t\tret = uart_register_driver(&ulite_uart_driver);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register driver\\n\");\n\t\t\tclk_disable_unprepare(pdata->clk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ulite_assign(&pdev->dev, id, res->start, irq, pdata);\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic int ulite_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = dev_get_drvdata(&pdev->dev);\n\tstruct uartlite_data *pdata = port->private_data;\n\n\tclk_disable_unprepare(pdata->clk);\n\tulite_release(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\treturn 0;\n}\n\n \nMODULE_ALIAS(\"platform:uartlite\");\n\nstatic struct platform_driver ulite_platform_driver = {\n\t.probe = ulite_probe,\n\t.remove = ulite_remove,\n\t.driver = {\n\t\t.name  = \"uartlite\",\n\t\t.of_match_table = of_match_ptr(ulite_of_match),\n\t\t.pm = &ulite_pm_ops,\n\t},\n};\n\n \n\nstatic int __init ulite_init(void)\n{\n\n\tpr_debug(\"uartlite: calling platform_driver_register()\\n\");\n\treturn platform_driver_register(&ulite_platform_driver);\n}\n\nstatic void __exit ulite_exit(void)\n{\n\tplatform_driver_unregister(&ulite_platform_driver);\n\tif (ulite_uart_driver.state)\n\t\tuart_unregister_driver(&ulite_uart_driver);\n}\n\nmodule_init(ulite_init);\nmodule_exit(ulite_exit);\n\nMODULE_AUTHOR(\"Peter Korsgaard <jacmet@sunsite.dk>\");\nMODULE_DESCRIPTION(\"Xilinx uartlite serial driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}