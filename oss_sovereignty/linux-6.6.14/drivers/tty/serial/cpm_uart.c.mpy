{
  "module_name": "cpm_uart.c",
  "hash_id": "69acf8e5f42d65b63459cc0433c1310173a919315996f7f09b969549cf6a10eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/cpm_uart.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/serial.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/device.h>\n#include <linux/memblock.h>\n#include <linux/dma-mapping.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/gpio/consumer.h>\n#include <linux/clk.h>\n\n#include <sysdev/fsl_soc.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/delay.h>\n#include <asm/udbg.h>\n\n#include <linux/serial_core.h>\n#include <linux/kernel.h>\n\n#include \"cpm_uart.h\"\n\n\n \n\nstatic int  cpm_uart_tx_pump(struct uart_port *port);\nstatic void cpm_uart_initbd(struct uart_cpm_port *pinfo);\n\n \n\n#define HW_BUF_SPD_THRESHOLD    2400\n\nstatic void cpm_line_cr_cmd(struct uart_cpm_port *port, int cmd)\n{\n\tcpm_command(port->command, cmd);\n}\n\n \nstatic unsigned int cpm_uart_tx_empty(struct uart_port *port)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\tcbd_t __iomem *bdp = pinfo->tx_bd_base;\n\tint ret = 0;\n\n\twhile (1) {\n\t\tif (in_be16(&bdp->cbd_sc) & BD_SC_READY)\n\t\t\tbreak;\n\n\t\tif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP) {\n\t\t\tret = TIOCSER_TEMT;\n\t\t\tbreak;\n\t\t}\n\t\tbdp++;\n\t}\n\n\tpr_debug(\"CPM uart[%d]:tx_empty: %d\\n\", port->line, ret);\n\n\treturn ret;\n}\n\nstatic void cpm_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\n\tif (pinfo->gpios[GPIO_RTS])\n\t\tgpiod_set_value(pinfo->gpios[GPIO_RTS], !(mctrl & TIOCM_RTS));\n\n\tif (pinfo->gpios[GPIO_DTR])\n\t\tgpiod_set_value(pinfo->gpios[GPIO_DTR], !(mctrl & TIOCM_DTR));\n}\n\nstatic unsigned int cpm_uart_get_mctrl(struct uart_port *port)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\tunsigned int mctrl = TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\n\n\tif (pinfo->gpios[GPIO_CTS]) {\n\t\tif (gpiod_get_value(pinfo->gpios[GPIO_CTS]))\n\t\t\tmctrl &= ~TIOCM_CTS;\n\t}\n\n\tif (pinfo->gpios[GPIO_DSR]) {\n\t\tif (gpiod_get_value(pinfo->gpios[GPIO_DSR]))\n\t\t\tmctrl &= ~TIOCM_DSR;\n\t}\n\n\tif (pinfo->gpios[GPIO_DCD]) {\n\t\tif (gpiod_get_value(pinfo->gpios[GPIO_DCD]))\n\t\t\tmctrl &= ~TIOCM_CAR;\n\t}\n\n\tif (pinfo->gpios[GPIO_RI]) {\n\t\tif (!gpiod_get_value(pinfo->gpios[GPIO_RI]))\n\t\t\tmctrl |= TIOCM_RNG;\n\t}\n\n\treturn mctrl;\n}\n\n \nstatic void cpm_uart_stop_tx(struct uart_port *port)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\tsmc_t __iomem *smcp = pinfo->smcp;\n\tscc_t __iomem *sccp = pinfo->sccp;\n\n\tpr_debug(\"CPM uart[%d]:stop tx\\n\", port->line);\n\n\tif (IS_SMC(pinfo))\n\t\tclrbits8(&smcp->smc_smcm, SMCM_TX);\n\telse\n\t\tclrbits16(&sccp->scc_sccm, UART_SCCM_TX);\n}\n\n \nstatic void cpm_uart_start_tx(struct uart_port *port)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\tsmc_t __iomem *smcp = pinfo->smcp;\n\tscc_t __iomem *sccp = pinfo->sccp;\n\n\tpr_debug(\"CPM uart[%d]:start tx\\n\", port->line);\n\n\tif (IS_SMC(pinfo)) {\n\t\tif (in_8(&smcp->smc_smcm) & SMCM_TX)\n\t\t\treturn;\n\t} else {\n\t\tif (in_be16(&sccp->scc_sccm) & UART_SCCM_TX)\n\t\t\treturn;\n\t}\n\n\tif (cpm_uart_tx_pump(port) != 0) {\n\t\tif (IS_SMC(pinfo)) {\n\t\t\tsetbits8(&smcp->smc_smcm, SMCM_TX);\n\t\t} else {\n\t\t\tsetbits16(&sccp->scc_sccm, UART_SCCM_TX);\n\t\t}\n\t}\n}\n\n \nstatic void cpm_uart_stop_rx(struct uart_port *port)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\tsmc_t __iomem *smcp = pinfo->smcp;\n\tscc_t __iomem *sccp = pinfo->sccp;\n\n\tpr_debug(\"CPM uart[%d]:stop rx\\n\", port->line);\n\n\tif (IS_SMC(pinfo))\n\t\tclrbits8(&smcp->smc_smcm, SMCM_RX);\n\telse\n\t\tclrbits16(&sccp->scc_sccm, UART_SCCM_RX);\n}\n\n \nstatic void cpm_uart_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\n\tpr_debug(\"CPM uart[%d]:break ctrl, break_state: %d\\n\", port->line,\n\t\tbreak_state);\n\n\tif (break_state)\n\t\tcpm_line_cr_cmd(pinfo, CPM_CR_STOP_TX);\n\telse\n\t\tcpm_line_cr_cmd(pinfo, CPM_CR_RESTART_TX);\n}\n\n \nstatic void cpm_uart_int_tx(struct uart_port *port)\n{\n\tpr_debug(\"CPM uart[%d]:TX INT\\n\", port->line);\n\n\tcpm_uart_tx_pump(port);\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int serial_polled;\n#endif\n\n \nstatic void cpm_uart_int_rx(struct uart_port *port)\n{\n\tint i;\n\tunsigned char ch;\n\tu8 *cp;\n\tstruct tty_port *tport = &port->state->port;\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\tcbd_t __iomem *bdp;\n\tu16 status;\n\tunsigned int flg;\n\n\tpr_debug(\"CPM uart[%d]:RX INT\\n\", port->line);\n\n\t \n\tbdp = pinfo->rx_cur;\n\tfor (;;) {\n#ifdef CONFIG_CONSOLE_POLL\n\t\tif (unlikely(serial_polled)) {\n\t\t\tserial_polled = 0;\n\t\t\treturn;\n\t\t}\n#endif\n\t\t \n\t\tstatus = in_be16(&bdp->cbd_sc);\n\t\t \n\t\tif (status & BD_SC_EMPTY)\n\t\t\tbreak;\n\n\t\t \n\t\ti = in_be16(&bdp->cbd_datlen);\n\n\t\t \n\t\tif (tty_buffer_request_room(tport, i) < i) {\n\t\t\tprintk(KERN_WARNING \"No room in flip buffer\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tcp = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr), pinfo);\n\n\t\t \n\t\twhile (i-- > 0) {\n\t\t\tch = *cp++;\n\t\t\tport->icount.rx++;\n\t\t\tflg = TTY_NORMAL;\n\n\t\t\tif (status &\n\t\t\t    (BD_SC_BR | BD_SC_FR | BD_SC_PR | BD_SC_OV))\n\t\t\t\tgoto handle_error;\n\t\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\t\tcontinue;\n#ifdef CONFIG_CONSOLE_POLL\n\t\t\tif (unlikely(serial_polled)) {\n\t\t\t\tserial_polled = 0;\n\t\t\t\treturn;\n\t\t\t}\n#endif\n\t\t      error_return:\n\t\t\ttty_insert_flip_char(tport, ch, flg);\n\n\t\t}\t\t \n\n\t\t \n\t\tclrbits16(&bdp->cbd_sc, BD_SC_BR | BD_SC_FR | BD_SC_PR |\n\t\t                        BD_SC_OV | BD_SC_ID);\n\t\tsetbits16(&bdp->cbd_sc, BD_SC_EMPTY);\n\n\t\tif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)\n\t\t\tbdp = pinfo->rx_bd_base;\n\t\telse\n\t\t\tbdp++;\n\n\t}  \n\n\t \n\tpinfo->rx_cur = bdp;\n\n\t \n\ttty_flip_buffer_push(tport);\n\n\treturn;\n\n\t \n\n      handle_error:\n\t \n\tif (status & BD_SC_BR)\n\t\tport->icount.brk++;\n\tif (status & BD_SC_PR)\n\t\tport->icount.parity++;\n\tif (status & BD_SC_FR)\n\t\tport->icount.frame++;\n\tif (status & BD_SC_OV)\n\t\tport->icount.overrun++;\n\n\t \n\tstatus &= port->read_status_mask;\n\n\t \n\tif (status & BD_SC_BR)\n\t\tflg = TTY_BREAK;\n\telse if (status & BD_SC_PR)\n\t\tflg = TTY_PARITY;\n\telse if (status & BD_SC_FR)\n\t\tflg = TTY_FRAME;\n\n\t \n\tif (status & BD_SC_OV) {\n\t\tch = 0;\n\t\tflg = TTY_OVERRUN;\n\t\t \n\t\t \n\t\t \n\t\ti = 0;\n\t}\n\tport->sysrq = 0;\n\tgoto error_return;\n}\n\n \nstatic irqreturn_t cpm_uart_int(int irq, void *data)\n{\n\tu8 events;\n\tstruct uart_port *port = data;\n\tstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\n\tsmc_t __iomem *smcp = pinfo->smcp;\n\tscc_t __iomem *sccp = pinfo->sccp;\n\n\tpr_debug(\"CPM uart[%d]:IRQ\\n\", port->line);\n\n\tif (IS_SMC(pinfo)) {\n\t\tevents = in_8(&smcp->smc_smce);\n\t\tout_8(&smcp->smc_smce, events);\n\t\tif (events & SMCM_BRKE)\n\t\t\tuart_handle_break(port);\n\t\tif (events & SMCM_RX)\n\t\t\tcpm_uart_int_rx(port);\n\t\tif (events & SMCM_TX)\n\t\t\tcpm_uart_int_tx(port);\n\t} else {\n\t\tevents = in_be16(&sccp->scc_scce);\n\t\tout_be16(&sccp->scc_scce, events);\n\t\tif (events & UART_SCCM_BRKE)\n\t\t\tuart_handle_break(port);\n\t\tif (events & UART_SCCM_RX)\n\t\t\tcpm_uart_int_rx(port);\n\t\tif (events & UART_SCCM_TX)\n\t\t\tcpm_uart_int_tx(port);\n\t}\n\treturn (events) ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int cpm_uart_startup(struct uart_port *port)\n{\n\tint retval;\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\n\tpr_debug(\"CPM uart[%d]:startup\\n\", port->line);\n\n\t \n\tif (!(pinfo->flags & FLAG_CONSOLE)) {\n\t\t \n\t\tif (IS_SMC(pinfo)) {\n\t\t\tclrbits16(&pinfo->smcp->smc_smcmr, SMCMR_REN);\n\t\t\tclrbits8(&pinfo->smcp->smc_smcm, SMCM_RX);\n\t\t} else {\n\t\t\tclrbits32(&pinfo->sccp->scc_gsmrl, SCC_GSMRL_ENR);\n\t\t\tclrbits16(&pinfo->sccp->scc_sccm, UART_SCCM_RX);\n\t\t}\n\t\tcpm_uart_initbd(pinfo);\n\t\tif (IS_SMC(pinfo)) {\n\t\t\tout_be32(&pinfo->smcup->smc_rstate, 0);\n\t\t\tout_be32(&pinfo->smcup->smc_tstate, 0);\n\t\t\tout_be16(&pinfo->smcup->smc_rbptr,\n\t\t\t\t in_be16(&pinfo->smcup->smc_rbase));\n\t\t\tout_be16(&pinfo->smcup->smc_tbptr,\n\t\t\t\t in_be16(&pinfo->smcup->smc_tbase));\n\t\t} else {\n\t\t\tcpm_line_cr_cmd(pinfo, CPM_CR_INIT_TRX);\n\t\t}\n\t}\n\t \n\tretval = request_irq(port->irq, cpm_uart_int, 0, \"cpm_uart\", port);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tif (IS_SMC(pinfo)) {\n\t\tsetbits8(&pinfo->smcp->smc_smcm, SMCM_RX);\n\t\tsetbits16(&pinfo->smcp->smc_smcmr, (SMCMR_REN | SMCMR_TEN));\n\t} else {\n\t\tsetbits16(&pinfo->sccp->scc_sccm, UART_SCCM_RX);\n\t\tsetbits32(&pinfo->sccp->scc_gsmrl, (SCC_GSMRL_ENR | SCC_GSMRL_ENT));\n\t}\n\n\treturn 0;\n}\n\ninline void cpm_uart_wait_until_send(struct uart_cpm_port *pinfo)\n{\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule_timeout(pinfo->wait_closing);\n}\n\n \nstatic void cpm_uart_shutdown(struct uart_port *port)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\n\tpr_debug(\"CPM uart[%d]:shutdown\\n\", port->line);\n\n\t \n\tfree_irq(port->irq, port);\n\n\t \n\tif (!(pinfo->flags & FLAG_CONSOLE)) {\n\t\t \n\t\twhile(!cpm_uart_tx_empty(port)) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_timeout(2);\n\t\t}\n\n\t\tif (pinfo->wait_closing)\n\t\t\tcpm_uart_wait_until_send(pinfo);\n\n\t\t \n\t\tif (IS_SMC(pinfo)) {\n\t\t\tsmc_t __iomem *smcp = pinfo->smcp;\n\t\t\tclrbits16(&smcp->smc_smcmr, SMCMR_REN | SMCMR_TEN);\n\t\t\tclrbits8(&smcp->smc_smcm, SMCM_RX | SMCM_TX);\n\t\t} else {\n\t\t\tscc_t __iomem *sccp = pinfo->sccp;\n\t\t\tclrbits32(&sccp->scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\n\t\t\tclrbits16(&sccp->scc_sccm, UART_SCCM_TX | UART_SCCM_RX);\n\t\t}\n\n\t\t \n\t\tif (IS_SMC(pinfo)) {\n\t\t\tout_be16(&pinfo->smcup->smc_brkcr, 0);\n\t\t\tcpm_line_cr_cmd(pinfo, CPM_CR_STOP_TX);\n\t\t} else {\n\t\t\tout_be16(&pinfo->sccup->scc_brkcr, 0);\n\t\t\tcpm_line_cr_cmd(pinfo, CPM_CR_GRA_STOP_TX);\n\t\t}\n\n\t\tcpm_uart_initbd(pinfo);\n\t}\n}\n\nstatic void cpm_uart_set_termios(struct uart_port *port,\n                                 struct ktermios *termios,\n                                 const struct ktermios *old)\n{\n\tint baud;\n\tunsigned long flags;\n\tu16 cval, scval, prev_mode;\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\tsmc_t __iomem *smcp = pinfo->smcp;\n\tscc_t __iomem *sccp = pinfo->sccp;\n\tint maxidl;\n\n\tpr_debug(\"CPM uart[%d]:set_termios\\n\", port->line);\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\n\tif (baud < HW_BUF_SPD_THRESHOLD || port->flags & UPF_LOW_LATENCY)\n\t\tpinfo->rx_fifosize = 1;\n\telse\n\t\tpinfo->rx_fifosize = RX_BUF_SIZE;\n\n\t \n\tmaxidl = baud / 2400;\n\tif (maxidl < 1)\n\t\tmaxidl = 1;\n\tif (maxidl > 0x10)\n\t\tmaxidl = 0x10;\n\n\tcval = 0;\n\tscval = 0;\n\n\tif (termios->c_cflag & CSTOPB) {\n\t\tcval |= SMCMR_SL;\t \n\t\tscval |= SCU_PSMR_SL;\n\t}\n\n\tif (termios->c_cflag & PARENB) {\n\t\tcval |= SMCMR_PEN;\n\t\tscval |= SCU_PSMR_PEN;\n\t\tif (!(termios->c_cflag & PARODD)) {\n\t\t\tcval |= SMCMR_PM_EVEN;\n\t\t\tscval |= (SCU_PSMR_REVP | SCU_PSMR_TEVP);\n\t\t}\n\t}\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tport->read_status_mask = (BD_SC_EMPTY | BD_SC_OV);\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= BD_SC_FR | BD_SC_PR;\n\tif ((termios->c_iflag & BRKINT) || (termios->c_iflag & PARMRK))\n\t\tport->read_status_mask |= BD_SC_BR;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= BD_SC_PR | BD_SC_FR;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= BD_SC_BR;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= BD_SC_OV;\n\t}\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->read_status_mask &= ~BD_SC_EMPTY;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (IS_SMC(pinfo)) {\n\t\tunsigned int bits = tty_get_frame_size(termios->c_cflag);\n\n\t\t \n\t\tout_be16(&pinfo->smcup->smc_mrblr, pinfo->rx_fifosize);\n\t\tout_be16(&pinfo->smcup->smc_maxidl, maxidl);\n\n\t\t \n\t\tprev_mode = in_be16(&smcp->smc_smcmr) & (SMCMR_REN | SMCMR_TEN);\n\t\t \n\t\tout_be16(&smcp->smc_smcmr, smcr_mk_clen(bits - 1) | cval |\n\t\t\t\t\t   SMCMR_SM_UART | prev_mode);\n\t} else {\n\t\tunsigned int bits = tty_get_char_size(termios->c_cflag);\n\n\t\tout_be16(&pinfo->sccup->scc_genscc.scc_mrblr, pinfo->rx_fifosize);\n\t\tout_be16(&pinfo->sccup->scc_maxidl, maxidl);\n\t\tout_be16(&sccp->scc_psmr, (UART_LCR_WLEN(bits) << 12) | scval);\n\t}\n\n\tif (pinfo->clk)\n\t\tclk_set_rate(pinfo->clk, baud);\n\telse\n\t\tcpm_setbrg(pinfo->brg - 1, baud);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *cpm_uart_type(struct uart_port *port)\n{\n\tpr_debug(\"CPM uart[%d]:uart_type\\n\", port->line);\n\n\treturn port->type == PORT_CPM ? \"CPM UART\" : NULL;\n}\n\n \nstatic int cpm_uart_verify_port(struct uart_port *port,\n\t\t\t\tstruct serial_struct *ser)\n{\n\tint ret = 0;\n\n\tpr_debug(\"CPM uart[%d]:verify_port\\n\", port->line);\n\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_CPM)\n\t\tret = -EINVAL;\n\tif (ser->irq < 0 || ser->irq >= nr_irqs)\n\t\tret = -EINVAL;\n\tif (ser->baud_base < 9600)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\n \nstatic int cpm_uart_tx_pump(struct uart_port *port)\n{\n\tcbd_t __iomem *bdp;\n\tu8 *p;\n\tint count;\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\t \n\tif (port->x_char) {\n\t\t \n\t\tbdp = pinfo->tx_cur;\n\n\t\tp = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr), pinfo);\n\n\t\t*p++ = port->x_char;\n\n\t\tout_be16(&bdp->cbd_datlen, 1);\n\t\tsetbits16(&bdp->cbd_sc, BD_SC_READY);\n\t\t \n\t\tif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)\n\t\t\tbdp = pinfo->tx_bd_base;\n\t\telse\n\t\t\tbdp++;\n\t\tpinfo->tx_cur = bdp;\n\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn 1;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\tcpm_uart_stop_tx(port);\n\t\treturn 0;\n\t}\n\n\t \n\tbdp = pinfo->tx_cur;\n\n\twhile (!(in_be16(&bdp->cbd_sc) & BD_SC_READY) && !uart_circ_empty(xmit)) {\n\t\tcount = 0;\n\t\tp = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr), pinfo);\n\t\twhile (count < pinfo->tx_fifosize) {\n\t\t\t*p++ = xmit->buf[xmit->tail];\n\t\t\tuart_xmit_advance(port, 1);\n\t\t\tcount++;\n\t\t\tif (uart_circ_empty(xmit))\n\t\t\t\tbreak;\n\t\t}\n\t\tout_be16(&bdp->cbd_datlen, count);\n\t\tsetbits16(&bdp->cbd_sc, BD_SC_READY);\n\t\t \n\t\tif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)\n\t\t\tbdp = pinfo->tx_bd_base;\n\t\telse\n\t\t\tbdp++;\n\t}\n\tpinfo->tx_cur = bdp;\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (uart_circ_empty(xmit)) {\n\t\tcpm_uart_stop_tx(port);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic void cpm_uart_initbd(struct uart_cpm_port *pinfo)\n{\n\tint i;\n\tu8 *mem_addr;\n\tcbd_t __iomem *bdp;\n\n\tpr_debug(\"CPM uart[%d]:initbd\\n\", pinfo->port.line);\n\n\t \n\tmem_addr = pinfo->mem_addr;\n\tbdp = pinfo->rx_cur = pinfo->rx_bd_base;\n\tfor (i = 0; i < (pinfo->rx_nrfifos - 1); i++, bdp++) {\n\t\tout_be32(&bdp->cbd_bufaddr, cpu2cpm_addr(mem_addr, pinfo));\n\t\tout_be16(&bdp->cbd_sc, BD_SC_EMPTY | BD_SC_INTRPT);\n\t\tmem_addr += pinfo->rx_fifosize;\n\t}\n\n\tout_be32(&bdp->cbd_bufaddr, cpu2cpm_addr(mem_addr, pinfo));\n\tout_be16(&bdp->cbd_sc, BD_SC_WRAP | BD_SC_EMPTY | BD_SC_INTRPT);\n\n\t \n\tmem_addr = pinfo->mem_addr + L1_CACHE_ALIGN(pinfo->rx_nrfifos * pinfo->rx_fifosize);\n\tbdp = pinfo->tx_cur = pinfo->tx_bd_base;\n\tfor (i = 0; i < (pinfo->tx_nrfifos - 1); i++, bdp++) {\n\t\tout_be32(&bdp->cbd_bufaddr, cpu2cpm_addr(mem_addr, pinfo));\n\t\tout_be16(&bdp->cbd_sc, BD_SC_INTRPT);\n\t\tmem_addr += pinfo->tx_fifosize;\n\t}\n\n\tout_be32(&bdp->cbd_bufaddr, cpu2cpm_addr(mem_addr, pinfo));\n\tout_be16(&bdp->cbd_sc, BD_SC_WRAP | BD_SC_INTRPT);\n}\n\nstatic void cpm_uart_init_scc(struct uart_cpm_port *pinfo)\n{\n\tscc_t __iomem *scp;\n\tscc_uart_t __iomem *sup;\n\n\tpr_debug(\"CPM uart[%d]:init_scc\\n\", pinfo->port.line);\n\n\tscp = pinfo->sccp;\n\tsup = pinfo->sccup;\n\n\t \n\tout_be16(&pinfo->sccup->scc_genscc.scc_rbase,\n\t         (u8 __iomem *)pinfo->rx_bd_base - DPRAM_BASE);\n\tout_be16(&pinfo->sccup->scc_genscc.scc_tbase,\n\t         (u8 __iomem *)pinfo->tx_bd_base - DPRAM_BASE);\n\n\t \n\n\tout_8(&sup->scc_genscc.scc_rfcr, CPMFCR_GBL | CPMFCR_EB);\n\tout_8(&sup->scc_genscc.scc_tfcr, CPMFCR_GBL | CPMFCR_EB);\n\n\tout_be16(&sup->scc_genscc.scc_mrblr, pinfo->rx_fifosize);\n\tout_be16(&sup->scc_maxidl, 0x10);\n\tout_be16(&sup->scc_brkcr, 1);\n\tout_be16(&sup->scc_parec, 0);\n\tout_be16(&sup->scc_frmec, 0);\n\tout_be16(&sup->scc_nosec, 0);\n\tout_be16(&sup->scc_brkec, 0);\n\tout_be16(&sup->scc_uaddr1, 0);\n\tout_be16(&sup->scc_uaddr2, 0);\n\tout_be16(&sup->scc_toseq, 0);\n\tout_be16(&sup->scc_char1, 0x8000);\n\tout_be16(&sup->scc_char2, 0x8000);\n\tout_be16(&sup->scc_char3, 0x8000);\n\tout_be16(&sup->scc_char4, 0x8000);\n\tout_be16(&sup->scc_char5, 0x8000);\n\tout_be16(&sup->scc_char6, 0x8000);\n\tout_be16(&sup->scc_char7, 0x8000);\n\tout_be16(&sup->scc_char8, 0x8000);\n\tout_be16(&sup->scc_rccm, 0xc0ff);\n\n\t \n\tcpm_line_cr_cmd(pinfo, CPM_CR_INIT_TRX);\n\n\t \n\tout_be32(&scp->scc_gsmrh, 0);\n\tout_be32(&scp->scc_gsmrl,\n\t         SCC_GSMRL_MODE_UART | SCC_GSMRL_TDCR_16 | SCC_GSMRL_RDCR_16);\n\n\t \n\tout_be16(&scp->scc_sccm, 0);\n\tout_be16(&scp->scc_scce, 0xffff);\n\tout_be16(&scp->scc_dsr, 0x7e7e);\n\tout_be16(&scp->scc_psmr, 0x3000);\n\n\tsetbits32(&scp->scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\n}\n\nstatic void cpm_uart_init_smc(struct uart_cpm_port *pinfo)\n{\n\tsmc_t __iomem *sp;\n\tsmc_uart_t __iomem *up;\n\n\tpr_debug(\"CPM uart[%d]:init_smc\\n\", pinfo->port.line);\n\n\tsp = pinfo->smcp;\n\tup = pinfo->smcup;\n\n\t \n\tout_be16(&pinfo->smcup->smc_rbase,\n\t         (u8 __iomem *)pinfo->rx_bd_base - DPRAM_BASE);\n\tout_be16(&pinfo->smcup->smc_tbase,\n\t         (u8 __iomem *)pinfo->tx_bd_base - DPRAM_BASE);\n\n \n\tout_be16(&up->smc_rbptr, in_be16(&pinfo->smcup->smc_rbase));\n\tout_be16(&up->smc_tbptr, in_be16(&pinfo->smcup->smc_tbase));\n\tout_be32(&up->smc_rstate, 0);\n\tout_be32(&up->smc_tstate, 0);\n\tout_be16(&up->smc_brkcr, 1);               \n\tout_be16(&up->smc_brkec, 0);\n\n\t \n\tout_8(&up->smc_rfcr, CPMFCR_GBL | CPMFCR_EB);\n\tout_8(&up->smc_tfcr, CPMFCR_GBL | CPMFCR_EB);\n\n\t \n\tout_be16(&up->smc_mrblr, pinfo->rx_fifosize);\n\tout_be16(&up->smc_maxidl, 0x10);\n\tout_be16(&up->smc_brklen, 0);\n\tout_be16(&up->smc_brkec, 0);\n\tout_be16(&up->smc_brkcr, 1);\n\n\t \n\tout_be16(&sp->smc_smcmr, smcr_mk_clen(9) | SMCMR_SM_UART);\n\n\t \n\tout_8(&sp->smc_smcm, 0);\n\tout_8(&sp->smc_smce, 0xff);\n\n\tsetbits16(&sp->smc_smcmr, SMCMR_REN | SMCMR_TEN);\n}\n\n \nstatic int cpm_uart_allocbuf(struct uart_cpm_port *pinfo, unsigned int is_con)\n{\n\tint dpmemsz, memsz;\n\tu8 __iomem *dp_mem;\n\tunsigned long dp_offset;\n\tu8 *mem_addr;\n\tdma_addr_t dma_addr = 0;\n\n\tpr_debug(\"CPM uart[%d]:allocbuf\\n\", pinfo->port.line);\n\n\tdpmemsz = sizeof(cbd_t) * (pinfo->rx_nrfifos + pinfo->tx_nrfifos);\n\tdp_offset = cpm_muram_alloc(dpmemsz, 8);\n\tif (IS_ERR_VALUE(dp_offset)) {\n\t\tpr_err(\"%s: could not allocate buffer descriptors\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdp_mem = cpm_muram_addr(dp_offset);\n\n\tmemsz = L1_CACHE_ALIGN(pinfo->rx_nrfifos * pinfo->rx_fifosize) +\n\t    L1_CACHE_ALIGN(pinfo->tx_nrfifos * pinfo->tx_fifosize);\n\tif (IS_ENABLED(CONFIG_CPM1) && is_con) {\n\t\t \n\t\t \n\t\tmem_addr = (u8 __force *)cpm_muram_addr(cpm_muram_alloc(memsz, 8));\n\t\tdma_addr = cpm_muram_dma((void __iomem *)mem_addr);\n\t} else if (is_con) {\n\t\tmem_addr = kzalloc(memsz, GFP_NOWAIT);\n\t\tdma_addr = virt_to_bus(mem_addr);\n\t} else {\n\t\tmem_addr = dma_alloc_coherent(pinfo->port.dev, memsz, &dma_addr,\n\t\t\t\t\t      GFP_KERNEL);\n\t}\n\n\tif (!mem_addr) {\n\t\tcpm_muram_free(dp_offset);\n\t\tpr_err(\"%s: could not allocate coherent memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tpinfo->dp_addr = dp_offset;\n\tpinfo->mem_addr = mem_addr;\n\tpinfo->dma_addr = dma_addr;\n\tpinfo->mem_size = memsz;\n\n\tpinfo->rx_buf = mem_addr;\n\tpinfo->tx_buf = pinfo->rx_buf + L1_CACHE_ALIGN(pinfo->rx_nrfifos\n\t\t\t\t\t\t       * pinfo->rx_fifosize);\n\n\tpinfo->rx_bd_base = (cbd_t __iomem *)dp_mem;\n\tpinfo->tx_bd_base = pinfo->rx_bd_base + pinfo->rx_nrfifos;\n\n\treturn 0;\n}\n\nstatic void cpm_uart_freebuf(struct uart_cpm_port *pinfo)\n{\n\tdma_free_coherent(pinfo->port.dev, L1_CACHE_ALIGN(pinfo->rx_nrfifos *\n\t\t\t\t\t\t\t  pinfo->rx_fifosize) +\n\t\t\t  L1_CACHE_ALIGN(pinfo->tx_nrfifos *\n\t\t\t\t\t pinfo->tx_fifosize), (void __force *)pinfo->mem_addr,\n\t\t\t  pinfo->dma_addr);\n\n\tcpm_muram_free(pinfo->dp_addr);\n}\n\n \nstatic int cpm_uart_request_port(struct uart_port *port)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\tint ret;\n\n\tpr_debug(\"CPM uart[%d]:request port\\n\", port->line);\n\n\tif (pinfo->flags & FLAG_CONSOLE)\n\t\treturn 0;\n\n\tif (IS_SMC(pinfo)) {\n\t\tclrbits8(&pinfo->smcp->smc_smcm, SMCM_RX | SMCM_TX);\n\t\tclrbits16(&pinfo->smcp->smc_smcmr, SMCMR_REN | SMCMR_TEN);\n\t} else {\n\t\tclrbits16(&pinfo->sccp->scc_sccm, UART_SCCM_TX | UART_SCCM_RX);\n\t\tclrbits32(&pinfo->sccp->scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\n\t}\n\n\tret = cpm_uart_allocbuf(pinfo, 0);\n\n\tif (ret)\n\t\treturn ret;\n\n\tcpm_uart_initbd(pinfo);\n\tif (IS_SMC(pinfo))\n\t\tcpm_uart_init_smc(pinfo);\n\telse\n\t\tcpm_uart_init_scc(pinfo);\n\n\treturn 0;\n}\n\nstatic void cpm_uart_release_port(struct uart_port *port)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\n\tif (!(pinfo->flags & FLAG_CONSOLE))\n\t\tcpm_uart_freebuf(pinfo);\n}\n\n \nstatic void cpm_uart_config_port(struct uart_port *port, int flags)\n{\n\tpr_debug(\"CPM uart[%d]:config_port\\n\", port->line);\n\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_CPM;\n\t\tcpm_uart_request_port(port);\n\t}\n}\n\n#if defined(CONFIG_CONSOLE_POLL) || defined(CONFIG_SERIAL_CPM_CONSOLE)\n \nstatic void cpm_uart_early_write(struct uart_cpm_port *pinfo,\n\t\tconst char *string, u_int count, bool handle_linefeed)\n{\n\tunsigned int i;\n\tcbd_t __iomem *bdp, *bdbase;\n\tunsigned char *cpm_outp_addr;\n\n\t \n\tbdp = pinfo->tx_cur;\n\tbdbase = pinfo->tx_bd_base;\n\n\t \n\tfor (i = 0; i < count; i++, string++) {\n\t\t \n\t\twhile ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)\n\t\t\t;\n\n\t\t \n\t\tcpm_outp_addr = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr),\n\t\t\t\t\tpinfo);\n\t\t*cpm_outp_addr = *string;\n\n\t\tout_be16(&bdp->cbd_datlen, 1);\n\t\tsetbits16(&bdp->cbd_sc, BD_SC_READY);\n\n\t\tif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)\n\t\t\tbdp = bdbase;\n\t\telse\n\t\t\tbdp++;\n\n\t\t \n\t\tif (handle_linefeed && *string == 10) {\n\t\t\twhile ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)\n\t\t\t\t;\n\n\t\t\tcpm_outp_addr = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr),\n\t\t\t\t\t\tpinfo);\n\t\t\t*cpm_outp_addr = 13;\n\n\t\t\tout_be16(&bdp->cbd_datlen, 1);\n\t\t\tsetbits16(&bdp->cbd_sc, BD_SC_READY);\n\n\t\t\tif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)\n\t\t\t\tbdp = bdbase;\n\t\t\telse\n\t\t\t\tbdp++;\n\t\t}\n\t}\n\n\t \n\twhile ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)\n\t\t;\n\n\tpinfo->tx_cur = bdp;\n}\n#endif\n\n#ifdef CONFIG_CONSOLE_POLL\n \n\n#define GDB_BUF_SIZE\t512\t \n\nstatic char poll_buf[GDB_BUF_SIZE];\nstatic char *pollp;\nstatic int poll_chars;\n\nstatic int poll_wait_key(char *obuf, struct uart_cpm_port *pinfo)\n{\n\tu_char\t\tc, *cp;\n\tvolatile cbd_t\t*bdp;\n\tint\t\ti;\n\n\t \n\tbdp = pinfo->rx_cur;\n\tif (bdp->cbd_sc & BD_SC_EMPTY)\n\t\treturn NO_POLL_CHAR;\n\n\t \n\tcp = cpm2cpu_addr(bdp->cbd_bufaddr, pinfo);\n\n\tif (obuf) {\n\t\ti = c = bdp->cbd_datlen;\n\t\twhile (i-- > 0)\n\t\t\t*obuf++ = *cp++;\n\t} else\n\t\tc = *cp;\n\tbdp->cbd_sc &= ~(BD_SC_BR | BD_SC_FR | BD_SC_PR | BD_SC_OV | BD_SC_ID);\n\tbdp->cbd_sc |= BD_SC_EMPTY;\n\n\tif (bdp->cbd_sc & BD_SC_WRAP)\n\t\tbdp = pinfo->rx_bd_base;\n\telse\n\t\tbdp++;\n\tpinfo->rx_cur = (cbd_t *)bdp;\n\n\treturn (int)c;\n}\n\nstatic int cpm_get_poll_char(struct uart_port *port)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\n\tif (!serial_polled) {\n\t\tserial_polled = 1;\n\t\tpoll_chars = 0;\n\t}\n\tif (poll_chars <= 0) {\n\t\tint ret = poll_wait_key(poll_buf, pinfo);\n\n\t\tif (ret == NO_POLL_CHAR)\n\t\t\treturn ret;\n\t\tpoll_chars = ret;\n\t\tpollp = poll_buf;\n\t}\n\tpoll_chars--;\n\treturn *pollp++;\n}\n\nstatic void cpm_put_poll_char(struct uart_port *port,\n\t\t\t unsigned char c)\n{\n\tstruct uart_cpm_port *pinfo =\n\t\tcontainer_of(port, struct uart_cpm_port, port);\n\tstatic char ch[2];\n\n\tch[0] = (char)c;\n\tcpm_uart_early_write(pinfo, ch, 1, false);\n}\n\n#ifdef CONFIG_SERIAL_CPM_CONSOLE\nstatic struct uart_port *udbg_port;\n\nstatic void udbg_cpm_putc(char c)\n{\n\tif (c == '\\n')\n\t\tcpm_put_poll_char(udbg_port, '\\r');\n\tcpm_put_poll_char(udbg_port, c);\n}\n\nstatic int udbg_cpm_getc_poll(void)\n{\n\tint c = cpm_get_poll_char(udbg_port);\n\n\treturn c == NO_POLL_CHAR ? -1 : c;\n}\n\nstatic int udbg_cpm_getc(void)\n{\n\tint c;\n\n\twhile ((c = udbg_cpm_getc_poll()) == -1)\n\t\tcpu_relax();\n\treturn c;\n}\n#endif  \n\n#endif  \n\nstatic const struct uart_ops cpm_uart_pops = {\n\t.tx_empty\t= cpm_uart_tx_empty,\n\t.set_mctrl\t= cpm_uart_set_mctrl,\n\t.get_mctrl\t= cpm_uart_get_mctrl,\n\t.stop_tx\t= cpm_uart_stop_tx,\n\t.start_tx\t= cpm_uart_start_tx,\n\t.stop_rx\t= cpm_uart_stop_rx,\n\t.break_ctl\t= cpm_uart_break_ctl,\n\t.startup\t= cpm_uart_startup,\n\t.shutdown\t= cpm_uart_shutdown,\n\t.set_termios\t= cpm_uart_set_termios,\n\t.type\t\t= cpm_uart_type,\n\t.release_port\t= cpm_uart_release_port,\n\t.request_port\t= cpm_uart_request_port,\n\t.config_port\t= cpm_uart_config_port,\n\t.verify_port\t= cpm_uart_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char = cpm_get_poll_char,\n\t.poll_put_char = cpm_put_poll_char,\n#endif\n};\n\nstatic struct uart_cpm_port cpm_uart_ports[UART_NR];\n\nstatic void __iomem *cpm_uart_map_pram(struct uart_cpm_port *port,\n\t\t\t\t       struct device_node *np)\n{\n\tvoid __iomem *pram;\n\tunsigned long offset;\n\tstruct resource res;\n\tresource_size_t len;\n\n\t \n\tif (IS_SMC(port) && port->smcup)\n\t\treturn port->smcup;\n\telse if (!IS_SMC(port) && port->sccup)\n\t\treturn port->sccup;\n\n\tif (of_address_to_resource(np, 1, &res))\n\t\treturn NULL;\n\n\tlen = resource_size(&res);\n\tpram = ioremap(res.start, len);\n\tif (!pram)\n\t\treturn NULL;\n\n\tif (!IS_ENABLED(CONFIG_CPM2) || !IS_SMC(port))\n\t\treturn pram;\n\n\tif (len != 2) {\n\t\tpr_warn(\"cpm_uart[%d]: device tree references \"\n\t\t\t\"SMC pram, using boot loader/wrapper pram mapping. \"\n\t\t\t\"Please fix your device tree to reference the pram \"\n\t\t\t\"base register instead.\\n\",\n\t\t\tport->port.line);\n\t\treturn pram;\n\t}\n\n\toffset = cpm_muram_alloc(64, 64);\n\tout_be16(pram, offset);\n\tiounmap(pram);\n\treturn cpm_muram_addr(offset);\n}\n\nstatic void cpm_uart_unmap_pram(struct uart_cpm_port *port, void __iomem *pram)\n{\n\tif (!IS_ENABLED(CONFIG_CPM2) || !IS_SMC(port))\n\t\tiounmap(pram);\n}\n\nstatic int cpm_uart_init_port(struct device_node *np,\n                              struct uart_cpm_port *pinfo)\n{\n\tconst u32 *data;\n\tvoid __iomem *mem, *pram;\n\tstruct device *dev = pinfo->port.dev;\n\tint len;\n\tint ret;\n\tint i;\n\n\tdata = of_get_property(np, \"clock\", NULL);\n\tif (data) {\n\t\tstruct clk *clk = clk_get(NULL, (const char*)data);\n\t\tif (!IS_ERR(clk))\n\t\t\tpinfo->clk = clk;\n\t}\n\tif (!pinfo->clk) {\n\t\tdata = of_get_property(np, \"fsl,cpm-brg\", &len);\n\t\tif (!data || len != 4) {\n\t\t\tprintk(KERN_ERR \"CPM UART %pOFn has no/invalid \"\n\t\t\t                \"fsl,cpm-brg property.\\n\", np);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpinfo->brg = *data;\n\t}\n\n\tdata = of_get_property(np, \"fsl,cpm-command\", &len);\n\tif (!data || len != 4) {\n\t\tprintk(KERN_ERR \"CPM UART %pOFn has no/invalid \"\n\t\t                \"fsl,cpm-command property.\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\tpinfo->command = *data;\n\n\tmem = of_iomap(np, 0);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\tif (of_device_is_compatible(np, \"fsl,cpm1-scc-uart\") ||\n\t    of_device_is_compatible(np, \"fsl,cpm2-scc-uart\")) {\n\t\tpinfo->sccp = mem;\n\t\tpinfo->sccup = pram = cpm_uart_map_pram(pinfo, np);\n\t} else if (of_device_is_compatible(np, \"fsl,cpm1-smc-uart\") ||\n\t           of_device_is_compatible(np, \"fsl,cpm2-smc-uart\")) {\n\t\tpinfo->flags |= FLAG_SMC;\n\t\tpinfo->smcp = mem;\n\t\tpinfo->smcup = pram = cpm_uart_map_pram(pinfo, np);\n\t} else {\n\t\tret = -ENODEV;\n\t\tgoto out_mem;\n\t}\n\n\tif (!pram) {\n\t\tret = -ENOMEM;\n\t\tgoto out_mem;\n\t}\n\n\tpinfo->tx_nrfifos = TX_NUM_FIFO;\n\tpinfo->tx_fifosize = TX_BUF_SIZE;\n\tpinfo->rx_nrfifos = RX_NUM_FIFO;\n\tpinfo->rx_fifosize = RX_BUF_SIZE;\n\n\tpinfo->port.uartclk = ppc_proc_freq;\n\tpinfo->port.mapbase = (unsigned long)mem;\n\tpinfo->port.type = PORT_CPM;\n\tpinfo->port.ops = &cpm_uart_pops;\n\tpinfo->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_CPM_CONSOLE);\n\tpinfo->port.iotype = UPIO_MEM;\n\tpinfo->port.fifosize = pinfo->tx_nrfifos * pinfo->tx_fifosize;\n\tspin_lock_init(&pinfo->port.lock);\n\n\tfor (i = 0; i < NUM_GPIOS; i++) {\n\t\tstruct gpio_desc *gpiod;\n\n\t\tpinfo->gpios[i] = NULL;\n\n\t\tgpiod = devm_gpiod_get_index_optional(dev, NULL, i, GPIOD_ASIS);\n\n\t\tif (IS_ERR(gpiod)) {\n\t\t\tret = PTR_ERR(gpiod);\n\t\t\tgoto out_pram;\n\t\t}\n\n\t\tif (gpiod) {\n\t\t\tif (i == GPIO_RTS || i == GPIO_DTR)\n\t\t\t\tret = gpiod_direction_output(gpiod, 0);\n\t\t\telse\n\t\t\t\tret = gpiod_direction_input(gpiod);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"can't set direction for gpio #%d: %d\\n\",\n\t\t\t\t\ti, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpinfo->gpios[i] = gpiod;\n\t\t}\n\t}\n\n#ifdef CONFIG_PPC_EARLY_DEBUG_CPM\n#if defined(CONFIG_CONSOLE_POLL) && defined(CONFIG_SERIAL_CPM_CONSOLE)\n\tif (!udbg_port)\n#endif\n\t\tudbg_putc = NULL;\n#endif\n\n\treturn cpm_uart_request_port(&pinfo->port);\n\nout_pram:\n\tcpm_uart_unmap_pram(pinfo, pram);\nout_mem:\n\tiounmap(mem);\n\treturn ret;\n}\n\n#ifdef CONFIG_SERIAL_CPM_CONSOLE\n \nstatic void cpm_uart_console_write(struct console *co, const char *s,\n\t\t\t\t   u_int count)\n{\n\tstruct uart_cpm_port *pinfo = &cpm_uart_ports[co->index];\n\tunsigned long flags;\n\n\tif (unlikely(oops_in_progress)) {\n\t\tlocal_irq_save(flags);\n\t\tcpm_uart_early_write(pinfo, s, count, true);\n\t\tlocal_irq_restore(flags);\n\t} else {\n\t\tspin_lock_irqsave(&pinfo->port.lock, flags);\n\t\tcpm_uart_early_write(pinfo, s, count, true);\n\t\tspin_unlock_irqrestore(&pinfo->port.lock, flags);\n\t}\n}\n\n\nstatic int __init cpm_uart_console_setup(struct console *co, char *options)\n{\n\tint baud = 38400;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret;\n\tstruct uart_cpm_port *pinfo;\n\tstruct uart_port *port;\n\n\tstruct device_node *np;\n\tint i = 0;\n\n\tif (co->index >= UART_NR) {\n\t\tprintk(KERN_ERR \"cpm_uart: console index %d too high\\n\",\n\t\t       co->index);\n\t\treturn -ENODEV;\n\t}\n\n\tfor_each_node_by_type(np, \"serial\") {\n\t\tif (!of_device_is_compatible(np, \"fsl,cpm1-smc-uart\") &&\n\t\t    !of_device_is_compatible(np, \"fsl,cpm1-scc-uart\") &&\n\t\t    !of_device_is_compatible(np, \"fsl,cpm2-smc-uart\") &&\n\t\t    !of_device_is_compatible(np, \"fsl,cpm2-scc-uart\"))\n\t\t\tcontinue;\n\n\t\tif (i++ == co->index)\n\t\t\tbreak;\n\t}\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tpinfo = &cpm_uart_ports[co->index];\n\n\tpinfo->flags |= FLAG_CONSOLE;\n\tport = &pinfo->port;\n\n\tret = cpm_uart_init_port(np, pinfo);\n\tof_node_put(np);\n\tif (ret)\n\t\treturn ret;\n\n\tif (options) {\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\t} else {\n\t\tbaud = get_baudrate();\n\t\tif (baud == -1)\n\t\t\tbaud = 9600;\n\t}\n\n\tif (IS_SMC(pinfo)) {\n\t\tout_be16(&pinfo->smcup->smc_brkcr, 0);\n\t\tcpm_line_cr_cmd(pinfo, CPM_CR_STOP_TX);\n\t\tclrbits8(&pinfo->smcp->smc_smcm, SMCM_RX | SMCM_TX);\n\t\tclrbits16(&pinfo->smcp->smc_smcmr, SMCMR_REN | SMCMR_TEN);\n\t} else {\n\t\tout_be16(&pinfo->sccup->scc_brkcr, 0);\n\t\tcpm_line_cr_cmd(pinfo, CPM_CR_GRA_STOP_TX);\n\t\tclrbits16(&pinfo->sccp->scc_sccm, UART_SCCM_TX | UART_SCCM_RX);\n\t\tclrbits32(&pinfo->sccp->scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\n\t}\n\n\tret = cpm_uart_allocbuf(pinfo, 1);\n\n\tif (ret)\n\t\treturn ret;\n\n\tcpm_uart_initbd(pinfo);\n\n\tif (IS_SMC(pinfo))\n\t\tcpm_uart_init_smc(pinfo);\n\telse\n\t\tcpm_uart_init_scc(pinfo);\n\n\tuart_set_options(port, co, baud, parity, bits, flow);\n\tcpm_line_cr_cmd(pinfo, CPM_CR_RESTART_TX);\n\n#ifdef CONFIG_CONSOLE_POLL\n\tif (!udbg_port) {\n\t\tudbg_port = &pinfo->port;\n\t\tudbg_putc = udbg_cpm_putc;\n\t\tudbg_getc = udbg_cpm_getc;\n\t\tudbg_getc_poll = udbg_cpm_getc_poll;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic struct uart_driver cpm_reg;\nstatic struct console cpm_scc_uart_console = {\n\t.name\t\t= \"ttyCPM\",\n\t.write\t\t= cpm_uart_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= cpm_uart_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &cpm_reg,\n};\n\nstatic int __init cpm_uart_console_init(void)\n{\n\tcpm_muram_init();\n\tregister_console(&cpm_scc_uart_console);\n\treturn 0;\n}\n\nconsole_initcall(cpm_uart_console_init);\n\n#define CPM_UART_CONSOLE\t&cpm_scc_uart_console\n#else\n#define CPM_UART_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver cpm_reg = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"ttyCPM\",\n\t.dev_name\t= \"ttyCPM\",\n\t.major\t\t= SERIAL_CPM_MAJOR,\n\t.minor\t\t= SERIAL_CPM_MINOR,\n\t.cons\t\t= CPM_UART_CONSOLE,\n\t.nr\t\t= UART_NR,\n};\n\nstatic int probe_index;\n\nstatic int cpm_uart_probe(struct platform_device *ofdev)\n{\n\tint index = probe_index++;\n\tstruct uart_cpm_port *pinfo = &cpm_uart_ports[index];\n\tint ret;\n\n\tpinfo->port.line = index;\n\n\tif (index >= UART_NR)\n\t\treturn -ENODEV;\n\n\tplatform_set_drvdata(ofdev, pinfo);\n\n\t \n\tpinfo->port.dev = &ofdev->dev;\n\n\tpinfo->port.irq = irq_of_parse_and_map(ofdev->dev.of_node, 0);\n\tif (!pinfo->port.irq)\n\t\treturn -EINVAL;\n\n\tret = cpm_uart_init_port(ofdev->dev.of_node, pinfo);\n\tif (!ret)\n\t\treturn uart_add_one_port(&cpm_reg, &pinfo->port);\n\n\tirq_dispose_mapping(pinfo->port.irq);\n\n\treturn ret;\n}\n\nstatic int cpm_uart_remove(struct platform_device *ofdev)\n{\n\tstruct uart_cpm_port *pinfo = platform_get_drvdata(ofdev);\n\n\tuart_remove_one_port(&cpm_reg, &pinfo->port);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cpm_uart_match[] = {\n\t{\n\t\t.compatible = \"fsl,cpm1-smc-uart\",\n\t},\n\t{\n\t\t.compatible = \"fsl,cpm1-scc-uart\",\n\t},\n\t{\n\t\t.compatible = \"fsl,cpm2-smc-uart\",\n\t},\n\t{\n\t\t.compatible = \"fsl,cpm2-scc-uart\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, cpm_uart_match);\n\nstatic struct platform_driver cpm_uart_driver = {\n\t.driver = {\n\t\t.name = \"cpm_uart\",\n\t\t.of_match_table = cpm_uart_match,\n\t},\n\t.probe = cpm_uart_probe,\n\t.remove = cpm_uart_remove,\n };\n\nstatic int __init cpm_uart_init(void)\n{\n\tint ret = uart_register_driver(&cpm_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&cpm_uart_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&cpm_reg);\n\n\treturn ret;\n}\n\nstatic void __exit cpm_uart_exit(void)\n{\n\tplatform_driver_unregister(&cpm_uart_driver);\n\tuart_unregister_driver(&cpm_reg);\n}\n\nmodule_init(cpm_uart_init);\nmodule_exit(cpm_uart_exit);\n\nMODULE_AUTHOR(\"Kumar Gala/Antoniou Pantelis\");\nMODULE_DESCRIPTION(\"CPM SCC/SMC port driver $Revision: 0.01 $\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CHARDEV(SERIAL_CPM_MAJOR, SERIAL_CPM_MINOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}