{
  "module_name": "sa1100.c",
  "hash_id": "60d32eeb3c2af3e038d51cc87279410a0fdd0280ecdf1c3ef06cdc1d1bb9e858",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sa1100.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/platform_data/sa11x0-serial.h>\n#include <linux/platform_device.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/io.h>\n\n#include <asm/irq.h>\n#include <mach/hardware.h>\n#include <mach/irqs.h>\n\n#include \"serial_mctrl_gpio.h\"\n\n \n#define SERIAL_SA1100_MAJOR\t204\n#define MINOR_START\t\t5\n\n#define NR_PORTS\t\t3\n\n#define SA1100_ISR_PASS_LIMIT\t256\n\n \n#define SM_TO_UTSR0(x)\t((x) & 0xff)\n#define SM_TO_UTSR1(x)\t((x) >> 8)\n#define UTSR0_TO_SM(x)\t((x))\n#define UTSR1_TO_SM(x)\t((x) << 8)\n\n#define UART_GET_UTCR0(sport)\t__raw_readl((sport)->port.membase + UTCR0)\n#define UART_GET_UTCR1(sport)\t__raw_readl((sport)->port.membase + UTCR1)\n#define UART_GET_UTCR2(sport)\t__raw_readl((sport)->port.membase + UTCR2)\n#define UART_GET_UTCR3(sport)\t__raw_readl((sport)->port.membase + UTCR3)\n#define UART_GET_UTSR0(sport)\t__raw_readl((sport)->port.membase + UTSR0)\n#define UART_GET_UTSR1(sport)\t__raw_readl((sport)->port.membase + UTSR1)\n#define UART_GET_CHAR(sport)\t__raw_readl((sport)->port.membase + UTDR)\n\n#define UART_PUT_UTCR0(sport,v)\t__raw_writel((v),(sport)->port.membase + UTCR0)\n#define UART_PUT_UTCR1(sport,v)\t__raw_writel((v),(sport)->port.membase + UTCR1)\n#define UART_PUT_UTCR2(sport,v)\t__raw_writel((v),(sport)->port.membase + UTCR2)\n#define UART_PUT_UTCR3(sport,v)\t__raw_writel((v),(sport)->port.membase + UTCR3)\n#define UART_PUT_UTSR0(sport,v)\t__raw_writel((v),(sport)->port.membase + UTSR0)\n#define UART_PUT_UTSR1(sport,v)\t__raw_writel((v),(sport)->port.membase + UTSR1)\n#define UART_PUT_CHAR(sport,v)\t__raw_writel((v),(sport)->port.membase + UTDR)\n\n \n#define UART_PORT_SIZE\t0x24\n\n \n#define MCTRL_TIMEOUT\t(250*HZ/1000)\n\nstruct sa1100_port {\n\tstruct uart_port\tport;\n\tstruct timer_list\ttimer;\n\tunsigned int\t\told_status;\n\tstruct mctrl_gpios\t*gpios;\n};\n\n \nstatic void sa1100_mctrl_check(struct sa1100_port *sport)\n{\n\tunsigned int status, changed;\n\n\tstatus = sport->port.ops->get_mctrl(&sport->port);\n\tchanged = status ^ sport->old_status;\n\n\tif (changed == 0)\n\t\treturn;\n\n\tsport->old_status = status;\n\n\tif (changed & TIOCM_RI)\n\t\tsport->port.icount.rng++;\n\tif (changed & TIOCM_DSR)\n\t\tsport->port.icount.dsr++;\n\tif (changed & TIOCM_CAR)\n\t\tuart_handle_dcd_change(&sport->port, status & TIOCM_CAR);\n\tif (changed & TIOCM_CTS)\n\t\tuart_handle_cts_change(&sport->port, status & TIOCM_CTS);\n\n\twake_up_interruptible(&sport->port.state->port.delta_msr_wait);\n}\n\n \nstatic void sa1100_timeout(struct timer_list *t)\n{\n\tstruct sa1100_port *sport = from_timer(sport, t, timer);\n\tunsigned long flags;\n\n\tif (sport->port.state) {\n\t\tspin_lock_irqsave(&sport->port.lock, flags);\n\t\tsa1100_mctrl_check(sport);\n\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\t\tmod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);\n\t}\n}\n\n \nstatic void sa1100_stop_tx(struct uart_port *port)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\tu32 utcr3;\n\n\tutcr3 = UART_GET_UTCR3(sport);\n\tUART_PUT_UTCR3(sport, utcr3 & ~UTCR3_TIE);\n\tsport->port.read_status_mask &= ~UTSR0_TO_SM(UTSR0_TFS);\n}\n\n \nstatic void sa1100_start_tx(struct uart_port *port)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\tu32 utcr3;\n\n\tutcr3 = UART_GET_UTCR3(sport);\n\tsport->port.read_status_mask |= UTSR0_TO_SM(UTSR0_TFS);\n\tUART_PUT_UTCR3(sport, utcr3 | UTCR3_TIE);\n}\n\n \nstatic void sa1100_stop_rx(struct uart_port *port)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\tu32 utcr3;\n\n\tutcr3 = UART_GET_UTCR3(sport);\n\tUART_PUT_UTCR3(sport, utcr3 & ~UTCR3_RIE);\n}\n\n \nstatic void sa1100_enable_ms(struct uart_port *port)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\n\tmod_timer(&sport->timer, jiffies);\n\n\tmctrl_gpio_enable_ms(sport->gpios);\n}\n\nstatic void\nsa1100_rx_chars(struct sa1100_port *sport)\n{\n\tunsigned int status;\n\tu8 ch, flg;\n\n\tstatus = UTSR1_TO_SM(UART_GET_UTSR1(sport)) |\n\t\t UTSR0_TO_SM(UART_GET_UTSR0(sport));\n\twhile (status & UTSR1_TO_SM(UTSR1_RNE)) {\n\t\tch = UART_GET_CHAR(sport);\n\n\t\tsport->port.icount.rx++;\n\n\t\tflg = TTY_NORMAL;\n\n\t\t \n\t\tif (status & UTSR1_TO_SM(UTSR1_PRE | UTSR1_FRE | UTSR1_ROR)) {\n\t\t\tif (status & UTSR1_TO_SM(UTSR1_PRE))\n\t\t\t\tsport->port.icount.parity++;\n\t\t\telse if (status & UTSR1_TO_SM(UTSR1_FRE))\n\t\t\t\tsport->port.icount.frame++;\n\t\t\tif (status & UTSR1_TO_SM(UTSR1_ROR))\n\t\t\t\tsport->port.icount.overrun++;\n\n\t\t\tstatus &= sport->port.read_status_mask;\n\n\t\t\tif (status & UTSR1_TO_SM(UTSR1_PRE))\n\t\t\t\tflg = TTY_PARITY;\n\t\t\telse if (status & UTSR1_TO_SM(UTSR1_FRE))\n\t\t\t\tflg = TTY_FRAME;\n\n\t\t\tsport->port.sysrq = 0;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(&sport->port, ch))\n\t\t\tgoto ignore_char;\n\n\t\tuart_insert_char(&sport->port, status, UTSR1_TO_SM(UTSR1_ROR), ch, flg);\n\n\tignore_char:\n\t\tstatus = UTSR1_TO_SM(UART_GET_UTSR1(sport)) |\n\t\t\t UTSR0_TO_SM(UART_GET_UTSR0(sport));\n\t}\n\n\ttty_flip_buffer_push(&sport->port.state->port);\n}\n\nstatic void sa1100_tx_chars(struct sa1100_port *sport)\n{\n\tu8 ch;\n\n\t \n\tsa1100_mctrl_check(sport);\n\n\tuart_port_tx(&sport->port, ch,\n\t\t\tUART_GET_UTSR1(sport) & UTSR1_TNF,\n\t\t\tUART_PUT_CHAR(sport, ch));\n}\n\nstatic irqreturn_t sa1100_int(int irq, void *dev_id)\n{\n\tstruct sa1100_port *sport = dev_id;\n\tunsigned int status, pass_counter = 0;\n\n\tspin_lock(&sport->port.lock);\n\tstatus = UART_GET_UTSR0(sport);\n\tstatus &= SM_TO_UTSR0(sport->port.read_status_mask) | ~UTSR0_TFS;\n\tdo {\n\t\tif (status & (UTSR0_RFS | UTSR0_RID)) {\n\t\t\t \n\t\t\tif (status & UTSR0_RID)\n\t\t\t\tUART_PUT_UTSR0(sport, UTSR0_RID);\n\t\t\tsa1100_rx_chars(sport);\n\t\t}\n\n\t\t \n\t\tif (status & (UTSR0_RBB | UTSR0_REB))\n\t\t\tUART_PUT_UTSR0(sport, status & (UTSR0_RBB | UTSR0_REB));\n\n\t\tif (status & UTSR0_RBB)\n\t\t\tsport->port.icount.brk++;\n\n\t\tif (status & UTSR0_REB)\n\t\t\tuart_handle_break(&sport->port);\n\n\t\tif (status & UTSR0_TFS)\n\t\t\tsa1100_tx_chars(sport);\n\t\tif (pass_counter++ > SA1100_ISR_PASS_LIMIT)\n\t\t\tbreak;\n\t\tstatus = UART_GET_UTSR0(sport);\n\t\tstatus &= SM_TO_UTSR0(sport->port.read_status_mask) |\n\t\t\t  ~UTSR0_TFS;\n\t} while (status & (UTSR0_TFS | UTSR0_RFS | UTSR0_RID));\n\tspin_unlock(&sport->port.lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic unsigned int sa1100_tx_empty(struct uart_port *port)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\n\treturn UART_GET_UTSR1(sport) & UTSR1_TBY ? 0 : TIOCSER_TEMT;\n}\n\nstatic unsigned int sa1100_get_mctrl(struct uart_port *port)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\tint ret = TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\n\n\tmctrl_gpio_get(sport->gpios, &ret);\n\n\treturn ret;\n}\n\nstatic void sa1100_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\n\tmctrl_gpio_set(sport->gpios, mctrl);\n}\n\n \nstatic void sa1100_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\tunsigned long flags;\n\tunsigned int utcr3;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\tutcr3 = UART_GET_UTCR3(sport);\n\tif (break_state == -1)\n\t\tutcr3 |= UTCR3_BRK;\n\telse\n\t\tutcr3 &= ~UTCR3_BRK;\n\tUART_PUT_UTCR3(sport, utcr3);\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\nstatic int sa1100_startup(struct uart_port *port)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\tint retval;\n\n\t \n\tretval = request_irq(sport->port.irq, sa1100_int, 0,\n\t\t\t     \"sa11x0-uart\", sport);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tUART_PUT_UTSR0(sport, -1);\n\tUART_PUT_UTCR3(sport, UTCR3_RXE | UTCR3_TXE | UTCR3_RIE);\n\n\t \n\tspin_lock_irq(&sport->port.lock);\n\tsa1100_enable_ms(&sport->port);\n\tspin_unlock_irq(&sport->port.lock);\n\n\treturn 0;\n}\n\nstatic void sa1100_shutdown(struct uart_port *port)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\n\t \n\tdel_timer_sync(&sport->timer);\n\n\t \n\tfree_irq(sport->port.irq, sport);\n\n\t \n\tUART_PUT_UTCR3(sport, 0);\n}\n\nstatic void\nsa1100_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t   const struct ktermios *old)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\tunsigned long flags;\n\tunsigned int utcr0, old_utcr3, baud, quot;\n\tunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\n\n\t \n\twhile ((termios->c_cflag & CSIZE) != CS7 &&\n\t       (termios->c_cflag & CSIZE) != CS8) {\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= old_csize;\n\t\told_csize = CS8;\n\t}\n\n\tif ((termios->c_cflag & CSIZE) == CS8)\n\t\tutcr0 = UTCR0_DSS;\n\telse\n\t\tutcr0 = 0;\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tutcr0 |= UTCR0_SBS;\n\tif (termios->c_cflag & PARENB) {\n\t\tutcr0 |= UTCR0_PE;\n\t\tif (!(termios->c_cflag & PARODD))\n\t\t\tutcr0 |= UTCR0_OES;\n\t}\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16); \n\tquot = uart_get_divisor(port, baud);\n\n\tdel_timer_sync(&sport->timer);\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\tsport->port.read_status_mask &= UTSR0_TO_SM(UTSR0_TFS);\n\tsport->port.read_status_mask |= UTSR1_TO_SM(UTSR1_ROR);\n\tif (termios->c_iflag & INPCK)\n\t\tsport->port.read_status_mask |=\n\t\t\t\tUTSR1_TO_SM(UTSR1_FRE | UTSR1_PRE);\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tsport->port.read_status_mask |=\n\t\t\t\tUTSR0_TO_SM(UTSR0_RBB | UTSR0_REB);\n\n\t \n\tsport->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tsport->port.ignore_status_mask |=\n\t\t\t\tUTSR1_TO_SM(UTSR1_FRE | UTSR1_PRE);\n\tif (termios->c_iflag & IGNBRK) {\n\t\tsport->port.ignore_status_mask |=\n\t\t\t\tUTSR0_TO_SM(UTSR0_RBB | UTSR0_REB);\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tsport->port.ignore_status_mask |=\n\t\t\t\tUTSR1_TO_SM(UTSR1_ROR);\n\t}\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\told_utcr3 = UART_GET_UTCR3(sport);\n\tUART_PUT_UTCR3(sport, old_utcr3 & ~(UTCR3_RIE | UTCR3_TIE));\n\n\twhile (UART_GET_UTSR1(sport) & UTSR1_TBY)\n\t\tbarrier();\n\n\t \n\tUART_PUT_UTCR3(sport, 0);\n\n\t \n\tUART_PUT_UTCR0(sport, utcr0);\n\n\t \n\tquot -= 1;\n\tUART_PUT_UTCR1(sport, ((quot & 0xf00) >> 8));\n\tUART_PUT_UTCR2(sport, (quot & 0xff));\n\n\tUART_PUT_UTSR0(sport, -1);\n\n\tUART_PUT_UTCR3(sport, old_utcr3);\n\n\tif (UART_ENABLE_MS(&sport->port, termios->c_cflag))\n\t\tsa1100_enable_ms(&sport->port);\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\nstatic const char *sa1100_type(struct uart_port *port)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\n\treturn sport->port.type == PORT_SA1100 ? \"SA1100\" : NULL;\n}\n\n \nstatic void sa1100_release_port(struct uart_port *port)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\n\trelease_mem_region(sport->port.mapbase, UART_PORT_SIZE);\n}\n\n \nstatic int sa1100_request_port(struct uart_port *port)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\n\treturn request_mem_region(sport->port.mapbase, UART_PORT_SIZE,\n\t\t\t\"sa11x0-uart\") != NULL ? 0 : -EBUSY;\n}\n\n \nstatic void sa1100_config_port(struct uart_port *port, int flags)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\n\tif (flags & UART_CONFIG_TYPE &&\n\t    sa1100_request_port(&sport->port) == 0)\n\t\tsport->port.type = PORT_SA1100;\n}\n\n \nstatic int\nsa1100_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\tint ret = 0;\n\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_SA1100)\n\t\tret = -EINVAL;\n\tif (sport->port.irq != ser->irq)\n\t\tret = -EINVAL;\n\tif (ser->io_type != SERIAL_IO_MEM)\n\t\tret = -EINVAL;\n\tif (sport->port.uartclk / 16 != ser->baud_base)\n\t\tret = -EINVAL;\n\tif ((void *)sport->port.mapbase != ser->iomem_base)\n\t\tret = -EINVAL;\n\tif (sport->port.iobase != ser->port)\n\t\tret = -EINVAL;\n\tif (ser->hub6 != 0)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\nstatic struct uart_ops sa1100_pops = {\n\t.tx_empty\t= sa1100_tx_empty,\n\t.set_mctrl\t= sa1100_set_mctrl,\n\t.get_mctrl\t= sa1100_get_mctrl,\n\t.stop_tx\t= sa1100_stop_tx,\n\t.start_tx\t= sa1100_start_tx,\n\t.stop_rx\t= sa1100_stop_rx,\n\t.enable_ms\t= sa1100_enable_ms,\n\t.break_ctl\t= sa1100_break_ctl,\n\t.startup\t= sa1100_startup,\n\t.shutdown\t= sa1100_shutdown,\n\t.set_termios\t= sa1100_set_termios,\n\t.type\t\t= sa1100_type,\n\t.release_port\t= sa1100_release_port,\n\t.request_port\t= sa1100_request_port,\n\t.config_port\t= sa1100_config_port,\n\t.verify_port\t= sa1100_verify_port,\n};\n\nstatic struct sa1100_port sa1100_ports[NR_PORTS];\n\n \nstatic void __init sa1100_init_ports(void)\n{\n\tstatic int first = 1;\n\tint i;\n\n\tif (!first)\n\t\treturn;\n\tfirst = 0;\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tsa1100_ports[i].port.uartclk   = 3686400;\n\t\tsa1100_ports[i].port.ops       = &sa1100_pops;\n\t\tsa1100_ports[i].port.fifosize  = 8;\n\t\tsa1100_ports[i].port.line      = i;\n\t\tsa1100_ports[i].port.iotype    = UPIO_MEM;\n\t\ttimer_setup(&sa1100_ports[i].timer, sa1100_timeout, 0);\n\t}\n\n\t \n\tPPDR |= PPC_TXD1 | PPC_TXD3;\n\tPPSR |= PPC_TXD1 | PPC_TXD3;\n}\n\nvoid sa1100_register_uart_fns(struct sa1100_port_fns *fns)\n{\n\tif (fns->get_mctrl)\n\t\tsa1100_pops.get_mctrl = fns->get_mctrl;\n\tif (fns->set_mctrl)\n\t\tsa1100_pops.set_mctrl = fns->set_mctrl;\n\n\tsa1100_pops.pm       = fns->pm;\n\t \n}\n\nvoid __init sa1100_register_uart(int idx, int port)\n{\n\tif (idx >= NR_PORTS) {\n\t\tprintk(KERN_ERR \"%s: bad index number %d\\n\", __func__, idx);\n\t\treturn;\n\t}\n\n\tswitch (port) {\n\tcase 1:\n\t\tsa1100_ports[idx].port.membase = (void __iomem *)&Ser1UTCR0;\n\t\tsa1100_ports[idx].port.mapbase = _Ser1UTCR0;\n\t\tsa1100_ports[idx].port.irq     = IRQ_Ser1UART;\n\t\tsa1100_ports[idx].port.flags   = UPF_BOOT_AUTOCONF;\n\t\tbreak;\n\n\tcase 2:\n\t\tsa1100_ports[idx].port.membase = (void __iomem *)&Ser2UTCR0;\n\t\tsa1100_ports[idx].port.mapbase = _Ser2UTCR0;\n\t\tsa1100_ports[idx].port.irq     = IRQ_Ser2ICP;\n\t\tsa1100_ports[idx].port.flags   = UPF_BOOT_AUTOCONF;\n\t\tbreak;\n\n\tcase 3:\n\t\tsa1100_ports[idx].port.membase = (void __iomem *)&Ser3UTCR0;\n\t\tsa1100_ports[idx].port.mapbase = _Ser3UTCR0;\n\t\tsa1100_ports[idx].port.irq     = IRQ_Ser3UART;\n\t\tsa1100_ports[idx].port.flags   = UPF_BOOT_AUTOCONF;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: bad port number %d\\n\", __func__, port);\n\t}\n}\n\n\n#ifdef CONFIG_SERIAL_SA1100_CONSOLE\nstatic void sa1100_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct sa1100_port *sport =\n\t\tcontainer_of(port, struct sa1100_port, port);\n\n\twhile (!(UART_GET_UTSR1(sport) & UTSR1_TNF))\n\t\tbarrier();\n\tUART_PUT_CHAR(sport, ch);\n}\n\n \nstatic void\nsa1100_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct sa1100_port *sport = &sa1100_ports[co->index];\n\tunsigned int old_utcr3, status;\n\n\t \n\told_utcr3 = UART_GET_UTCR3(sport);\n\tUART_PUT_UTCR3(sport, (old_utcr3 & ~(UTCR3_RIE | UTCR3_TIE)) |\n\t\t\t\tUTCR3_TXE);\n\n\tuart_console_write(&sport->port, s, count, sa1100_console_putchar);\n\n\t \n\tdo {\n\t\tstatus = UART_GET_UTSR1(sport);\n\t} while (status & UTSR1_TBY);\n\tUART_PUT_UTCR3(sport, old_utcr3);\n}\n\n \nstatic void __init\nsa1100_console_get_options(struct sa1100_port *sport, int *baud,\n\t\t\t   int *parity, int *bits)\n{\n\tunsigned int utcr3;\n\n\tutcr3 = UART_GET_UTCR3(sport) & (UTCR3_RXE | UTCR3_TXE);\n\tif (utcr3 == (UTCR3_RXE | UTCR3_TXE)) {\n\t\t \n\t\tunsigned int utcr0, quot;\n\n\t\tutcr0 = UART_GET_UTCR0(sport);\n\n\t\t*parity = 'n';\n\t\tif (utcr0 & UTCR0_PE) {\n\t\t\tif (utcr0 & UTCR0_OES)\n\t\t\t\t*parity = 'e';\n\t\t\telse\n\t\t\t\t*parity = 'o';\n\t\t}\n\n\t\tif (utcr0 & UTCR0_DSS)\n\t\t\t*bits = 8;\n\t\telse\n\t\t\t*bits = 7;\n\n\t\tquot = UART_GET_UTCR2(sport) | UART_GET_UTCR1(sport) << 8;\n\t\tquot &= 0xfff;\n\t\t*baud = sport->port.uartclk / (16 * (quot + 1));\n\t}\n}\n\nstatic int __init\nsa1100_console_setup(struct console *co, char *options)\n{\n\tstruct sa1100_port *sport;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\t \n\tif (co->index == -1 || co->index >= NR_PORTS)\n\t\tco->index = 0;\n\tsport = &sa1100_ports[co->index];\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse\n\t\tsa1100_console_get_options(sport, &baud, &parity, &bits);\n\n\treturn uart_set_options(&sport->port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver sa1100_reg;\nstatic struct console sa1100_console = {\n\t.name\t\t= \"ttySA\",\n\t.write\t\t= sa1100_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= sa1100_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &sa1100_reg,\n};\n\nstatic int __init sa1100_rs_console_init(void)\n{\n\tsa1100_init_ports();\n\tregister_console(&sa1100_console);\n\treturn 0;\n}\nconsole_initcall(sa1100_rs_console_init);\n\n#define SA1100_CONSOLE\t&sa1100_console\n#else\n#define SA1100_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver sa1100_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"ttySA\",\n\t.dev_name\t\t= \"ttySA\",\n\t.major\t\t\t= SERIAL_SA1100_MAJOR,\n\t.minor\t\t\t= MINOR_START,\n\t.nr\t\t\t= NR_PORTS,\n\t.cons\t\t\t= SA1100_CONSOLE,\n};\n\nstatic int sa1100_serial_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct sa1100_port *sport = platform_get_drvdata(dev);\n\n\tif (sport)\n\t\tuart_suspend_port(&sa1100_reg, &sport->port);\n\n\treturn 0;\n}\n\nstatic int sa1100_serial_resume(struct platform_device *dev)\n{\n\tstruct sa1100_port *sport = platform_get_drvdata(dev);\n\n\tif (sport)\n\t\tuart_resume_port(&sa1100_reg, &sport->port);\n\n\treturn 0;\n}\n\nstatic int sa1100_serial_add_one_port(struct sa1100_port *sport, struct platform_device *dev)\n{\n\tsport->port.dev = &dev->dev;\n\tsport->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_SA1100_CONSOLE);\n\n\t\n\t\n\t\n\tsport->gpios = mctrl_gpio_init_noauto(sport->port.dev, 0);\n\tif (IS_ERR(sport->gpios)) {\n\t\tint err = PTR_ERR(sport->gpios);\n\n\t\tdev_err(sport->port.dev, \"failed to get mctrl gpios: %d\\n\",\n\t\t\terr);\n\n\t\tif (err == -EPROBE_DEFER)\n\t\t\treturn err;\n\n\t\tsport->gpios = NULL;\n\t}\n\n\tplatform_set_drvdata(dev, sport);\n\n\treturn uart_add_one_port(&sa1100_reg, &sport->port);\n}\n\nstatic int sa1100_serial_probe(struct platform_device *dev)\n{\n\tstruct resource *res;\n\tint i;\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < NR_PORTS; i++)\n\t\tif (sa1100_ports[i].port.mapbase == res->start)\n\t\t\tbreak;\n\tif (i == NR_PORTS)\n\t\treturn -ENODEV;\n\n\tsa1100_serial_add_one_port(&sa1100_ports[i], dev);\n\n\treturn 0;\n}\n\nstatic int sa1100_serial_remove(struct platform_device *pdev)\n{\n\tstruct sa1100_port *sport = platform_get_drvdata(pdev);\n\n\tif (sport)\n\t\tuart_remove_one_port(&sa1100_reg, &sport->port);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sa11x0_serial_driver = {\n\t.probe\t\t= sa1100_serial_probe,\n\t.remove\t\t= sa1100_serial_remove,\n\t.suspend\t= sa1100_serial_suspend,\n\t.resume\t\t= sa1100_serial_resume,\n\t.driver\t\t= {\n\t\t.name\t= \"sa11x0-uart\",\n\t},\n};\n\nstatic int __init sa1100_serial_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO \"Serial: SA11x0 driver\\n\");\n\n\tsa1100_init_ports();\n\n\tret = uart_register_driver(&sa1100_reg);\n\tif (ret == 0) {\n\t\tret = platform_driver_register(&sa11x0_serial_driver);\n\t\tif (ret)\n\t\t\tuart_unregister_driver(&sa1100_reg);\n\t}\n\treturn ret;\n}\n\nstatic void __exit sa1100_serial_exit(void)\n{\n\tplatform_driver_unregister(&sa11x0_serial_driver);\n\tuart_unregister_driver(&sa1100_reg);\n}\n\nmodule_init(sa1100_serial_init);\nmodule_exit(sa1100_serial_exit);\n\nMODULE_AUTHOR(\"Deep Blue Solutions Ltd\");\nMODULE_DESCRIPTION(\"SA1100 generic serial port driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CHARDEV_MAJOR(SERIAL_SA1100_MAJOR);\nMODULE_ALIAS(\"platform:sa11x0-uart\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}