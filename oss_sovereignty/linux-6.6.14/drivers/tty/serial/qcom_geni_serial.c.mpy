{
  "module_name": "qcom_geni_serial.c",
  "hash_id": "1020f85e6d396230622791169bf8ce443ff6415cd468526ae98a5bc07a6057fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/qcom_geni_serial.c",
  "human_readable_source": "\n\n\n \n#define __DISABLE_TRACE_MMIO__\n\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_opp.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/soc/qcom/geni-se.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <dt-bindings/interconnect/qcom,icc.h>\n\n \n#define SE_UART_LOOPBACK_CFG\t\t0x22c\n#define SE_UART_IO_MACRO_CTRL\t\t0x240\n#define SE_UART_TX_TRANS_CFG\t\t0x25c\n#define SE_UART_TX_WORD_LEN\t\t0x268\n#define SE_UART_TX_STOP_BIT_LEN\t\t0x26c\n#define SE_UART_TX_TRANS_LEN\t\t0x270\n#define SE_UART_RX_TRANS_CFG\t\t0x280\n#define SE_UART_RX_WORD_LEN\t\t0x28c\n#define SE_UART_RX_STALE_CNT\t\t0x294\n#define SE_UART_TX_PARITY_CFG\t\t0x2a4\n#define SE_UART_RX_PARITY_CFG\t\t0x2a8\n#define SE_UART_MANUAL_RFR\t\t0x2ac\n\n \n#define UART_TX_PAR_EN\t\t\tBIT(0)\n#define UART_CTS_MASK\t\t\tBIT(1)\n\n \n#define TX_STOP_BIT_LEN_1\t\t0\n#define TX_STOP_BIT_LEN_2\t\t2\n\n \n#define UART_RX_PAR_EN\t\t\tBIT(3)\n\n \n#define RX_WORD_LEN_MASK\t\tGENMASK(9, 0)\n\n \n#define RX_STALE_CNT\t\t\tGENMASK(23, 0)\n\n \n#define PAR_CALC_EN\t\t\tBIT(0)\n#define PAR_EVEN\t\t\t0x00\n#define PAR_ODD\t\t\t\t0x01\n#define PAR_SPACE\t\t\t0x10\n\n \n#define UART_MANUAL_RFR_EN\t\tBIT(31)\n#define UART_RFR_NOT_READY\t\tBIT(1)\n#define UART_RFR_READY\t\t\tBIT(0)\n\n \n#define UART_START_TX\t\t\t0x1\n \n#define UART_START_READ\t\t\t0x1\n#define UART_PARAM\t\t\t0x1\n#define UART_PARAM_RFR_OPEN\t\tBIT(7)\n\n#define UART_OVERSAMPLING\t\t32\n#define STALE_TIMEOUT\t\t\t16\n#define DEFAULT_BITS_PER_CHAR\t\t10\n#define GENI_UART_CONS_PORTS\t\t1\n#define GENI_UART_PORTS\t\t\t3\n#define DEF_FIFO_DEPTH_WORDS\t\t16\n#define DEF_TX_WM\t\t\t2\n#define DEF_FIFO_WIDTH_BITS\t\t32\n#define UART_RX_WM\t\t\t2\n\n \n#define RX_TX_SORTED\t\t\tBIT(0)\n#define CTS_RTS_SORTED\t\t\tBIT(1)\n#define RX_TX_CTS_RTS_SORTED\t\t(RX_TX_SORTED | CTS_RTS_SORTED)\n\n \n#define DEFAULT_IO_MACRO_IO0_IO1_MASK\tGENMASK(3, 0)\n#define IO_MACRO_IO0_SEL\t\t0x3\n#define DEFAULT_IO_MACRO_IO2_IO3_MASK\tGENMASK(15, 4)\n#define IO_MACRO_IO2_IO3_SWAP\t\t0x4640\n\n \n#define BYTES_PER_FIFO_WORD\t\t4U\n\n#define DMA_RX_BUF_SIZE\t\t2048\n\nstruct qcom_geni_device_data {\n\tbool console;\n\tenum geni_se_xfer_mode mode;\n};\n\nstruct qcom_geni_private_data {\n\t \n\tstruct uart_driver *drv;\n\n\tu32 poll_cached_bytes;\n\tunsigned int poll_cached_bytes_cnt;\n\n\tu32 write_cached_bytes;\n\tunsigned int write_cached_bytes_cnt;\n};\n\nstruct qcom_geni_serial_port {\n\tstruct uart_port uport;\n\tstruct geni_se se;\n\tconst char *name;\n\tu32 tx_fifo_depth;\n\tu32 tx_fifo_width;\n\tu32 rx_fifo_depth;\n\tdma_addr_t tx_dma_addr;\n\tdma_addr_t rx_dma_addr;\n\tbool setup;\n\tunsigned int baud;\n\tunsigned long clk_rate;\n\tvoid *rx_buf;\n\tu32 loopback;\n\tbool brk;\n\n\tunsigned int tx_remaining;\n\tint wakeup_irq;\n\tbool rx_tx_swap;\n\tbool cts_rts_swap;\n\n\tstruct qcom_geni_private_data private_data;\n\tconst struct qcom_geni_device_data *dev_data;\n};\n\nstatic const struct uart_ops qcom_geni_console_pops;\nstatic const struct uart_ops qcom_geni_uart_pops;\nstatic struct uart_driver qcom_geni_console_driver;\nstatic struct uart_driver qcom_geni_uart_driver;\n\nstatic inline struct qcom_geni_serial_port *to_dev_port(struct uart_port *uport)\n{\n\treturn container_of(uport, struct qcom_geni_serial_port, uport);\n}\n\nstatic struct qcom_geni_serial_port qcom_geni_uart_ports[GENI_UART_PORTS] = {\n\t[0] = {\n\t\t.uport = {\n\t\t\t.iotype = UPIO_MEM,\n\t\t\t.ops = &qcom_geni_uart_pops,\n\t\t\t.flags = UPF_BOOT_AUTOCONF,\n\t\t\t.line = 0,\n\t\t},\n\t},\n\t[1] = {\n\t\t.uport = {\n\t\t\t.iotype = UPIO_MEM,\n\t\t\t.ops = &qcom_geni_uart_pops,\n\t\t\t.flags = UPF_BOOT_AUTOCONF,\n\t\t\t.line = 1,\n\t\t},\n\t},\n\t[2] = {\n\t\t.uport = {\n\t\t\t.iotype = UPIO_MEM,\n\t\t\t.ops = &qcom_geni_uart_pops,\n\t\t\t.flags = UPF_BOOT_AUTOCONF,\n\t\t\t.line = 2,\n\t\t},\n\t},\n};\n\nstatic struct qcom_geni_serial_port qcom_geni_console_port = {\n\t.uport = {\n\t\t.iotype = UPIO_MEM,\n\t\t.ops = &qcom_geni_console_pops,\n\t\t.flags = UPF_BOOT_AUTOCONF,\n\t\t.line = 0,\n\t},\n};\n\nstatic int qcom_geni_serial_request_port(struct uart_port *uport)\n{\n\tstruct platform_device *pdev = to_platform_device(uport->dev);\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\n\tuport->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(uport->membase))\n\t\treturn PTR_ERR(uport->membase);\n\tport->se.base = uport->membase;\n\treturn 0;\n}\n\nstatic void qcom_geni_serial_config_port(struct uart_port *uport, int cfg_flags)\n{\n\tif (cfg_flags & UART_CONFIG_TYPE) {\n\t\tuport->type = PORT_MSM;\n\t\tqcom_geni_serial_request_port(uport);\n\t}\n}\n\nstatic unsigned int qcom_geni_serial_get_mctrl(struct uart_port *uport)\n{\n\tunsigned int mctrl = TIOCM_DSR | TIOCM_CAR;\n\tu32 geni_ios;\n\n\tif (uart_console(uport)) {\n\t\tmctrl |= TIOCM_CTS;\n\t} else {\n\t\tgeni_ios = readl(uport->membase + SE_GENI_IOS);\n\t\tif (!(geni_ios & IO2_DATA_IN))\n\t\t\tmctrl |= TIOCM_CTS;\n\t}\n\n\treturn mctrl;\n}\n\nstatic void qcom_geni_serial_set_mctrl(struct uart_port *uport,\n\t\t\t\t\t\t\tunsigned int mctrl)\n{\n\tu32 uart_manual_rfr = 0;\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\n\tif (uart_console(uport))\n\t\treturn;\n\n\tif (mctrl & TIOCM_LOOP)\n\t\tport->loopback = RX_TX_CTS_RTS_SORTED;\n\n\tif (!(mctrl & TIOCM_RTS) && !uport->suspended)\n\t\tuart_manual_rfr = UART_MANUAL_RFR_EN | UART_RFR_NOT_READY;\n\twritel(uart_manual_rfr, uport->membase + SE_UART_MANUAL_RFR);\n}\n\nstatic const char *qcom_geni_serial_get_type(struct uart_port *uport)\n{\n\treturn \"MSM\";\n}\n\nstatic struct qcom_geni_serial_port *get_port_from_line(int line, bool console)\n{\n\tstruct qcom_geni_serial_port *port;\n\tint nr_ports = console ? GENI_UART_CONS_PORTS : GENI_UART_PORTS;\n\n\tif (line < 0 || line >= nr_ports)\n\t\treturn ERR_PTR(-ENXIO);\n\n\tport = console ? &qcom_geni_console_port : &qcom_geni_uart_ports[line];\n\treturn port;\n}\n\nstatic bool qcom_geni_serial_main_active(struct uart_port *uport)\n{\n\treturn readl(uport->membase + SE_GENI_STATUS) & M_GENI_CMD_ACTIVE;\n}\n\nstatic bool qcom_geni_serial_secondary_active(struct uart_port *uport)\n{\n\treturn readl(uport->membase + SE_GENI_STATUS) & S_GENI_CMD_ACTIVE;\n}\n\nstatic bool qcom_geni_serial_poll_bit(struct uart_port *uport,\n\t\t\t\tint offset, int field, bool set)\n{\n\tu32 reg;\n\tstruct qcom_geni_serial_port *port;\n\tunsigned int baud;\n\tunsigned int fifo_bits;\n\tunsigned long timeout_us = 20000;\n\tstruct qcom_geni_private_data *private_data = uport->private_data;\n\n\tif (private_data->drv) {\n\t\tport = to_dev_port(uport);\n\t\tbaud = port->baud;\n\t\tif (!baud)\n\t\t\tbaud = 115200;\n\t\tfifo_bits = port->tx_fifo_depth * port->tx_fifo_width;\n\t\t \n\t\ttimeout_us = ((fifo_bits * USEC_PER_SEC) / baud) + 500;\n\t}\n\n\t \n\ttimeout_us = DIV_ROUND_UP(timeout_us, 10) * 10;\n\twhile (timeout_us) {\n\t\treg = readl(uport->membase + offset);\n\t\tif ((bool)(reg & field) == set)\n\t\t\treturn true;\n\t\tudelay(10);\n\t\ttimeout_us -= 10;\n\t}\n\treturn false;\n}\n\nstatic void qcom_geni_serial_setup_tx(struct uart_port *uport, u32 xmit_size)\n{\n\tu32 m_cmd;\n\n\twritel(xmit_size, uport->membase + SE_UART_TX_TRANS_LEN);\n\tm_cmd = UART_START_TX << M_OPCODE_SHFT;\n\twritel(m_cmd, uport->membase + SE_GENI_M_CMD0);\n}\n\nstatic void qcom_geni_serial_poll_tx_done(struct uart_port *uport)\n{\n\tint done;\n\tu32 irq_clear = M_CMD_DONE_EN;\n\n\tdone = qcom_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,\n\t\t\t\t\t\tM_CMD_DONE_EN, true);\n\tif (!done) {\n\t\twritel(M_GENI_CMD_ABORT, uport->membase +\n\t\t\t\t\t\tSE_GENI_M_CMD_CTRL_REG);\n\t\tirq_clear |= M_CMD_ABORT_EN;\n\t\tqcom_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,\n\t\t\t\t\t\t\tM_CMD_ABORT_EN, true);\n\t}\n\twritel(irq_clear, uport->membase + SE_GENI_M_IRQ_CLEAR);\n}\n\nstatic void qcom_geni_serial_abort_rx(struct uart_port *uport)\n{\n\tu32 irq_clear = S_CMD_DONE_EN | S_CMD_ABORT_EN;\n\n\twritel(S_GENI_CMD_ABORT, uport->membase + SE_GENI_S_CMD_CTRL_REG);\n\tqcom_geni_serial_poll_bit(uport, SE_GENI_S_CMD_CTRL_REG,\n\t\t\t\t\tS_GENI_CMD_ABORT, false);\n\twritel(irq_clear, uport->membase + SE_GENI_S_IRQ_CLEAR);\n\twritel(FORCE_DEFAULT, uport->membase + GENI_FORCE_DEFAULT_REG);\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int qcom_geni_serial_get_char(struct uart_port *uport)\n{\n\tstruct qcom_geni_private_data *private_data = uport->private_data;\n\tu32 status;\n\tu32 word_cnt;\n\tint ret;\n\n\tif (!private_data->poll_cached_bytes_cnt) {\n\t\tstatus = readl(uport->membase + SE_GENI_M_IRQ_STATUS);\n\t\twritel(status, uport->membase + SE_GENI_M_IRQ_CLEAR);\n\n\t\tstatus = readl(uport->membase + SE_GENI_S_IRQ_STATUS);\n\t\twritel(status, uport->membase + SE_GENI_S_IRQ_CLEAR);\n\n\t\tstatus = readl(uport->membase + SE_GENI_RX_FIFO_STATUS);\n\t\tword_cnt = status & RX_FIFO_WC_MSK;\n\t\tif (!word_cnt)\n\t\t\treturn NO_POLL_CHAR;\n\n\t\tif (word_cnt == 1 && (status & RX_LAST))\n\t\t\t \n\t\t\tprivate_data->poll_cached_bytes_cnt =\n\t\t\t\t(status & RX_LAST_BYTE_VALID_MSK) >>\n\t\t\t\tRX_LAST_BYTE_VALID_SHFT;\n\n\t\tif (private_data->poll_cached_bytes_cnt == 0)\n\t\t\tprivate_data->poll_cached_bytes_cnt = BYTES_PER_FIFO_WORD;\n\n\t\tprivate_data->poll_cached_bytes =\n\t\t\treadl(uport->membase + SE_GENI_RX_FIFOn);\n\t}\n\n\tprivate_data->poll_cached_bytes_cnt--;\n\tret = private_data->poll_cached_bytes & 0xff;\n\tprivate_data->poll_cached_bytes >>= 8;\n\n\treturn ret;\n}\n\nstatic void qcom_geni_serial_poll_put_char(struct uart_port *uport,\n\t\t\t\t\t\t\tunsigned char c)\n{\n\twritel(DEF_TX_WM, uport->membase + SE_GENI_TX_WATERMARK_REG);\n\tqcom_geni_serial_setup_tx(uport, 1);\n\tWARN_ON(!qcom_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,\n\t\t\t\t\t\tM_TX_FIFO_WATERMARK_EN, true));\n\twritel(c, uport->membase + SE_GENI_TX_FIFOn);\n\twritel(M_TX_FIFO_WATERMARK_EN, uport->membase + SE_GENI_M_IRQ_CLEAR);\n\tqcom_geni_serial_poll_tx_done(uport);\n}\n#endif\n\n#ifdef CONFIG_SERIAL_QCOM_GENI_CONSOLE\nstatic void qcom_geni_serial_wr_char(struct uart_port *uport, unsigned char ch)\n{\n\tstruct qcom_geni_private_data *private_data = uport->private_data;\n\n\tprivate_data->write_cached_bytes =\n\t\t(private_data->write_cached_bytes >> 8) | (ch << 24);\n\tprivate_data->write_cached_bytes_cnt++;\n\n\tif (private_data->write_cached_bytes_cnt == BYTES_PER_FIFO_WORD) {\n\t\twritel(private_data->write_cached_bytes,\n\t\t       uport->membase + SE_GENI_TX_FIFOn);\n\t\tprivate_data->write_cached_bytes_cnt = 0;\n\t}\n}\n\nstatic void\n__qcom_geni_serial_console_write(struct uart_port *uport, const char *s,\n\t\t\t\t unsigned int count)\n{\n\tstruct qcom_geni_private_data *private_data = uport->private_data;\n\n\tint i;\n\tu32 bytes_to_send = count;\n\n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tif (s[i] == '\\n')\n\t\t\tbytes_to_send++;\n\t}\n\n\twritel(DEF_TX_WM, uport->membase + SE_GENI_TX_WATERMARK_REG);\n\tqcom_geni_serial_setup_tx(uport, bytes_to_send);\n\tfor (i = 0; i < count; ) {\n\t\tsize_t chars_to_write = 0;\n\t\tsize_t avail = DEF_FIFO_DEPTH_WORDS - DEF_TX_WM;\n\n\t\t \n\t\tif (!qcom_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,\n\t\t\t\t\t\tM_TX_FIFO_WATERMARK_EN, true))\n\t\t\tbreak;\n\t\tchars_to_write = min_t(size_t, count - i, avail / 2);\n\t\tuart_console_write(uport, s + i, chars_to_write,\n\t\t\t\t\t\tqcom_geni_serial_wr_char);\n\t\twritel(M_TX_FIFO_WATERMARK_EN, uport->membase +\n\t\t\t\t\t\t\tSE_GENI_M_IRQ_CLEAR);\n\t\ti += chars_to_write;\n\t}\n\n\tif (private_data->write_cached_bytes_cnt) {\n\t\tprivate_data->write_cached_bytes >>= BITS_PER_BYTE *\n\t\t\t(BYTES_PER_FIFO_WORD - private_data->write_cached_bytes_cnt);\n\t\twritel(private_data->write_cached_bytes,\n\t\t       uport->membase + SE_GENI_TX_FIFOn);\n\t\tprivate_data->write_cached_bytes_cnt = 0;\n\t}\n\n\tqcom_geni_serial_poll_tx_done(uport);\n}\n\nstatic void qcom_geni_serial_console_write(struct console *co, const char *s,\n\t\t\t      unsigned int count)\n{\n\tstruct uart_port *uport;\n\tstruct qcom_geni_serial_port *port;\n\tbool locked = true;\n\tunsigned long flags;\n\tu32 geni_status;\n\tu32 irq_en;\n\n\tWARN_ON(co->index < 0 || co->index >= GENI_UART_CONS_PORTS);\n\n\tport = get_port_from_line(co->index, true);\n\tif (IS_ERR(port))\n\t\treturn;\n\n\tuport = &port->uport;\n\tif (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&uport->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&uport->lock, flags);\n\n\tgeni_status = readl(uport->membase + SE_GENI_STATUS);\n\n\t \n\tif (!locked) {\n\t\tgeni_se_cancel_m_cmd(&port->se);\n\t\tif (!qcom_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,\n\t\t\t\t\t\tM_CMD_CANCEL_EN, true)) {\n\t\t\tgeni_se_abort_m_cmd(&port->se);\n\t\t\tqcom_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,\n\t\t\t\t\t\t\tM_CMD_ABORT_EN, true);\n\t\t\twritel(M_CMD_ABORT_EN, uport->membase +\n\t\t\t\t\t\t\tSE_GENI_M_IRQ_CLEAR);\n\t\t}\n\t\twritel(M_CMD_CANCEL_EN, uport->membase + SE_GENI_M_IRQ_CLEAR);\n\t} else if ((geni_status & M_GENI_CMD_ACTIVE) && !port->tx_remaining) {\n\t\t \n\t\tqcom_geni_serial_poll_tx_done(uport);\n\n\t\tif (!uart_circ_empty(&uport->state->xmit)) {\n\t\t\tirq_en = readl(uport->membase + SE_GENI_M_IRQ_EN);\n\t\t\twritel(irq_en | M_TX_FIFO_WATERMARK_EN,\n\t\t\t\t\tuport->membase + SE_GENI_M_IRQ_EN);\n\t\t}\n\t}\n\n\t__qcom_geni_serial_console_write(uport, s, count);\n\n\tif (port->tx_remaining)\n\t\tqcom_geni_serial_setup_tx(uport, port->tx_remaining);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&uport->lock, flags);\n}\n\nstatic void handle_rx_console(struct uart_port *uport, u32 bytes, bool drop)\n{\n\tu32 i;\n\tunsigned char buf[sizeof(u32)];\n\tstruct tty_port *tport;\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\n\ttport = &uport->state->port;\n\tfor (i = 0; i < bytes; ) {\n\t\tint c;\n\t\tint chunk = min_t(int, bytes - i, BYTES_PER_FIFO_WORD);\n\n\t\tioread32_rep(uport->membase + SE_GENI_RX_FIFOn, buf, 1);\n\t\ti += chunk;\n\t\tif (drop)\n\t\t\tcontinue;\n\n\t\tfor (c = 0; c < chunk; c++) {\n\t\t\tint sysrq;\n\n\t\t\tuport->icount.rx++;\n\t\t\tif (port->brk && buf[c] == 0) {\n\t\t\t\tport->brk = false;\n\t\t\t\tif (uart_handle_break(uport))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsysrq = uart_prepare_sysrq_char(uport, buf[c]);\n\n\t\t\tif (!sysrq)\n\t\t\t\ttty_insert_flip_char(tport, buf[c], TTY_NORMAL);\n\t\t}\n\t}\n\tif (!drop)\n\t\ttty_flip_buffer_push(tport);\n}\n#else\nstatic void handle_rx_console(struct uart_port *uport, u32 bytes, bool drop)\n{\n\n}\n#endif  \n\nstatic void handle_rx_uart(struct uart_port *uport, u32 bytes, bool drop)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\tstruct tty_port *tport = &uport->state->port;\n\tint ret;\n\n\tret = tty_insert_flip_string(tport, port->rx_buf, bytes);\n\tif (ret != bytes) {\n\t\tdev_err(uport->dev, \"%s:Unable to push data ret %d_bytes %d\\n\",\n\t\t\t\t__func__, ret, bytes);\n\t\tWARN_ON_ONCE(1);\n\t}\n\tuport->icount.rx += ret;\n\ttty_flip_buffer_push(tport);\n}\n\nstatic unsigned int qcom_geni_serial_tx_empty(struct uart_port *uport)\n{\n\treturn !readl(uport->membase + SE_GENI_TX_FIFO_STATUS);\n}\n\nstatic void qcom_geni_serial_stop_tx_dma(struct uart_port *uport)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\tbool done;\n\n\tif (!qcom_geni_serial_main_active(uport))\n\t\treturn;\n\n\tif (port->tx_dma_addr) {\n\t\tgeni_se_tx_dma_unprep(&port->se, port->tx_dma_addr,\n\t\t\t\t      port->tx_remaining);\n\t\tport->tx_dma_addr = 0;\n\t\tport->tx_remaining = 0;\n\t}\n\n\tgeni_se_cancel_m_cmd(&port->se);\n\n\tdone = qcom_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,\n\t\t\t\t\t M_CMD_CANCEL_EN, true);\n\tif (!done) {\n\t\tgeni_se_abort_m_cmd(&port->se);\n\t\tdone = qcom_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,\n\t\t\t\t\t\t M_CMD_ABORT_EN, true);\n\t\tif (!done)\n\t\t\tdev_err_ratelimited(uport->dev, \"M_CMD_ABORT_EN not set\");\n\t\twritel(M_CMD_ABORT_EN, uport->membase + SE_GENI_M_IRQ_CLEAR);\n\t}\n\n\twritel(M_CMD_CANCEL_EN, uport->membase + SE_GENI_M_IRQ_CLEAR);\n}\n\nstatic void qcom_geni_serial_start_tx_dma(struct uart_port *uport)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\tstruct circ_buf *xmit = &uport->state->xmit;\n\tunsigned int xmit_size;\n\tint ret;\n\n\tif (port->tx_dma_addr)\n\t\treturn;\n\n\tif (uart_circ_empty(xmit))\n\t\treturn;\n\n\txmit_size = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\n\tqcom_geni_serial_setup_tx(uport, xmit_size);\n\n\tret = geni_se_tx_dma_prep(&port->se, &xmit->buf[xmit->tail],\n\t\t\t\t  xmit_size, &port->tx_dma_addr);\n\tif (ret) {\n\t\tdev_err(uport->dev, \"unable to start TX SE DMA: %d\\n\", ret);\n\t\tqcom_geni_serial_stop_tx_dma(uport);\n\t\treturn;\n\t}\n\n\tport->tx_remaining = xmit_size;\n}\n\nstatic void qcom_geni_serial_start_tx_fifo(struct uart_port *uport)\n{\n\tu32 irq_en;\n\n\tif (qcom_geni_serial_main_active(uport) ||\n\t    !qcom_geni_serial_tx_empty(uport))\n\t\treturn;\n\n\tirq_en = readl(uport->membase +\tSE_GENI_M_IRQ_EN);\n\tirq_en |= M_TX_FIFO_WATERMARK_EN | M_CMD_DONE_EN;\n\n\twritel(DEF_TX_WM, uport->membase + SE_GENI_TX_WATERMARK_REG);\n\twritel(irq_en, uport->membase +\tSE_GENI_M_IRQ_EN);\n}\n\nstatic void qcom_geni_serial_stop_tx_fifo(struct uart_port *uport)\n{\n\tu32 irq_en;\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\n\tirq_en = readl(uport->membase + SE_GENI_M_IRQ_EN);\n\tirq_en &= ~(M_CMD_DONE_EN | M_TX_FIFO_WATERMARK_EN);\n\twritel(0, uport->membase + SE_GENI_TX_WATERMARK_REG);\n\twritel(irq_en, uport->membase + SE_GENI_M_IRQ_EN);\n\t \n\tif (!qcom_geni_serial_main_active(uport))\n\t\treturn;\n\n\tgeni_se_cancel_m_cmd(&port->se);\n\tif (!qcom_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,\n\t\t\t\t\t\tM_CMD_CANCEL_EN, true)) {\n\t\tgeni_se_abort_m_cmd(&port->se);\n\t\tqcom_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,\n\t\t\t\t\t\tM_CMD_ABORT_EN, true);\n\t\twritel(M_CMD_ABORT_EN, uport->membase + SE_GENI_M_IRQ_CLEAR);\n\t}\n\twritel(M_CMD_CANCEL_EN, uport->membase + SE_GENI_M_IRQ_CLEAR);\n}\n\nstatic void qcom_geni_serial_handle_rx_fifo(struct uart_port *uport, bool drop)\n{\n\tu32 status;\n\tu32 word_cnt;\n\tu32 last_word_byte_cnt;\n\tu32 last_word_partial;\n\tu32 total_bytes;\n\n\tstatus = readl(uport->membase +\tSE_GENI_RX_FIFO_STATUS);\n\tword_cnt = status & RX_FIFO_WC_MSK;\n\tlast_word_partial = status & RX_LAST;\n\tlast_word_byte_cnt = (status & RX_LAST_BYTE_VALID_MSK) >>\n\t\t\t\t\t\tRX_LAST_BYTE_VALID_SHFT;\n\n\tif (!word_cnt)\n\t\treturn;\n\ttotal_bytes = BYTES_PER_FIFO_WORD * (word_cnt - 1);\n\tif (last_word_partial && last_word_byte_cnt)\n\t\ttotal_bytes += last_word_byte_cnt;\n\telse\n\t\ttotal_bytes += BYTES_PER_FIFO_WORD;\n\thandle_rx_console(uport, total_bytes, drop);\n}\n\nstatic void qcom_geni_serial_stop_rx_fifo(struct uart_port *uport)\n{\n\tu32 irq_en;\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\tu32 s_irq_status;\n\n\tirq_en = readl(uport->membase + SE_GENI_S_IRQ_EN);\n\tirq_en &= ~(S_RX_FIFO_WATERMARK_EN | S_RX_FIFO_LAST_EN);\n\twritel(irq_en, uport->membase + SE_GENI_S_IRQ_EN);\n\n\tirq_en = readl(uport->membase + SE_GENI_M_IRQ_EN);\n\tirq_en &= ~(M_RX_FIFO_WATERMARK_EN | M_RX_FIFO_LAST_EN);\n\twritel(irq_en, uport->membase + SE_GENI_M_IRQ_EN);\n\n\tif (!qcom_geni_serial_secondary_active(uport))\n\t\treturn;\n\n\tgeni_se_cancel_s_cmd(&port->se);\n\tqcom_geni_serial_poll_bit(uport, SE_GENI_S_IRQ_STATUS,\n\t\t\t\t\tS_CMD_CANCEL_EN, true);\n\t \n\ts_irq_status = readl(uport->membase + SE_GENI_S_IRQ_STATUS);\n\t \n\tif (s_irq_status & S_RX_FIFO_LAST_EN)\n\t\tqcom_geni_serial_handle_rx_fifo(uport, true);\n\twritel(s_irq_status, uport->membase + SE_GENI_S_IRQ_CLEAR);\n\n\tif (qcom_geni_serial_secondary_active(uport))\n\t\tqcom_geni_serial_abort_rx(uport);\n}\n\nstatic void qcom_geni_serial_start_rx_fifo(struct uart_port *uport)\n{\n\tu32 irq_en;\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\n\tif (qcom_geni_serial_secondary_active(uport))\n\t\tqcom_geni_serial_stop_rx_fifo(uport);\n\n\tgeni_se_setup_s_cmd(&port->se, UART_START_READ, 0);\n\n\tirq_en = readl(uport->membase + SE_GENI_S_IRQ_EN);\n\tirq_en |= S_RX_FIFO_WATERMARK_EN | S_RX_FIFO_LAST_EN;\n\twritel(irq_en, uport->membase + SE_GENI_S_IRQ_EN);\n\n\tirq_en = readl(uport->membase + SE_GENI_M_IRQ_EN);\n\tirq_en |= M_RX_FIFO_WATERMARK_EN | M_RX_FIFO_LAST_EN;\n\twritel(irq_en, uport->membase + SE_GENI_M_IRQ_EN);\n}\n\nstatic void qcom_geni_serial_stop_rx_dma(struct uart_port *uport)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\n\tif (!qcom_geni_serial_secondary_active(uport))\n\t\treturn;\n\n\tgeni_se_cancel_s_cmd(&port->se);\n\tqcom_geni_serial_poll_bit(uport, SE_GENI_S_IRQ_STATUS,\n\t\t\t\t  S_CMD_CANCEL_EN, true);\n\n\tif (qcom_geni_serial_secondary_active(uport))\n\t\tqcom_geni_serial_abort_rx(uport);\n\n\tif (port->rx_dma_addr) {\n\t\tgeni_se_rx_dma_unprep(&port->se, port->rx_dma_addr,\n\t\t\t\t      DMA_RX_BUF_SIZE);\n\t\tport->rx_dma_addr = 0;\n\t}\n}\n\nstatic void qcom_geni_serial_start_rx_dma(struct uart_port *uport)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\tint ret;\n\n\tif (qcom_geni_serial_secondary_active(uport))\n\t\tqcom_geni_serial_stop_rx_dma(uport);\n\n\tgeni_se_setup_s_cmd(&port->se, UART_START_READ, UART_PARAM_RFR_OPEN);\n\n\tret = geni_se_rx_dma_prep(&port->se, port->rx_buf,\n\t\t\t\t  DMA_RX_BUF_SIZE,\n\t\t\t\t  &port->rx_dma_addr);\n\tif (ret) {\n\t\tdev_err(uport->dev, \"unable to start RX SE DMA: %d\\n\", ret);\n\t\tqcom_geni_serial_stop_rx_dma(uport);\n\t}\n}\n\nstatic void qcom_geni_serial_handle_rx_dma(struct uart_port *uport, bool drop)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\tu32 rx_in;\n\tint ret;\n\n\tif (!qcom_geni_serial_secondary_active(uport))\n\t\treturn;\n\n\tif (!port->rx_dma_addr)\n\t\treturn;\n\n\tgeni_se_rx_dma_unprep(&port->se, port->rx_dma_addr, DMA_RX_BUF_SIZE);\n\tport->rx_dma_addr = 0;\n\n\trx_in = readl(uport->membase + SE_DMA_RX_LEN_IN);\n\tif (!rx_in) {\n\t\tdev_warn(uport->dev, \"serial engine reports 0 RX bytes in!\\n\");\n\t\treturn;\n\t}\n\n\tif (!drop)\n\t\thandle_rx_uart(uport, rx_in, drop);\n\n\tret = geni_se_rx_dma_prep(&port->se, port->rx_buf,\n\t\t\t\t  DMA_RX_BUF_SIZE,\n\t\t\t\t  &port->rx_dma_addr);\n\tif (ret) {\n\t\tdev_err(uport->dev, \"unable to start RX SE DMA: %d\\n\", ret);\n\t\tqcom_geni_serial_stop_rx_dma(uport);\n\t}\n}\n\nstatic void qcom_geni_serial_start_rx(struct uart_port *uport)\n{\n\tuport->ops->start_rx(uport);\n}\n\nstatic void qcom_geni_serial_stop_rx(struct uart_port *uport)\n{\n\tuport->ops->stop_rx(uport);\n}\n\nstatic void qcom_geni_serial_stop_tx(struct uart_port *uport)\n{\n\tuport->ops->stop_tx(uport);\n}\n\nstatic void qcom_geni_serial_send_chunk_fifo(struct uart_port *uport,\n\t\t\t\t\t     unsigned int remaining)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\tstruct circ_buf *xmit = &uport->state->xmit;\n\tunsigned int tx_bytes;\n\tu8 buf[BYTES_PER_FIFO_WORD];\n\n\twhile (remaining) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\ttx_bytes = min(remaining, BYTES_PER_FIFO_WORD);\n\n\t\tmemcpy(buf, &xmit->buf[xmit->tail], tx_bytes);\n\t\tuart_xmit_advance(uport, tx_bytes);\n\n\t\tiowrite32_rep(uport->membase + SE_GENI_TX_FIFOn, buf, 1);\n\n\t\tremaining -= tx_bytes;\n\t\tport->tx_remaining -= tx_bytes;\n\t}\n}\n\nstatic void qcom_geni_serial_handle_tx_fifo(struct uart_port *uport,\n\t\t\t\t\t    bool done, bool active)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\tstruct circ_buf *xmit = &uport->state->xmit;\n\tsize_t avail;\n\tsize_t pending;\n\tu32 status;\n\tu32 irq_en;\n\tunsigned int chunk;\n\n\tstatus = readl(uport->membase + SE_GENI_TX_FIFO_STATUS);\n\n\t \n\tif (active)\n\t\tpending = port->tx_remaining;\n\telse\n\t\tpending = uart_circ_chars_pending(xmit);\n\n\t \n\tif (!pending && !status && done) {\n\t\tqcom_geni_serial_stop_tx_fifo(uport);\n\t\tgoto out_write_wakeup;\n\t}\n\n\tavail = port->tx_fifo_depth - (status & TX_FIFO_WC);\n\tavail *= BYTES_PER_FIFO_WORD;\n\n\tchunk = min(avail, pending);\n\tif (!chunk)\n\t\tgoto out_write_wakeup;\n\n\tif (!port->tx_remaining) {\n\t\tqcom_geni_serial_setup_tx(uport, pending);\n\t\tport->tx_remaining = pending;\n\n\t\tirq_en = readl(uport->membase + SE_GENI_M_IRQ_EN);\n\t\tif (!(irq_en & M_TX_FIFO_WATERMARK_EN))\n\t\t\twritel(irq_en | M_TX_FIFO_WATERMARK_EN,\n\t\t\t\t\tuport->membase + SE_GENI_M_IRQ_EN);\n\t}\n\n\tqcom_geni_serial_send_chunk_fifo(uport, chunk);\n\n\t \n\twritel(M_TX_FIFO_WATERMARK_EN,\n\t\t\tuport->membase + SE_GENI_M_IRQ_CLEAR);\n\nout_write_wakeup:\n\tif (!port->tx_remaining) {\n\t\tirq_en = readl(uport->membase + SE_GENI_M_IRQ_EN);\n\t\tif (irq_en & M_TX_FIFO_WATERMARK_EN)\n\t\t\twritel(irq_en & ~M_TX_FIFO_WATERMARK_EN,\n\t\t\t\t\tuport->membase + SE_GENI_M_IRQ_EN);\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(uport);\n}\n\nstatic void qcom_geni_serial_handle_tx_dma(struct uart_port *uport)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\tstruct circ_buf *xmit = &uport->state->xmit;\n\n\tuart_xmit_advance(uport, port->tx_remaining);\n\tgeni_se_tx_dma_unprep(&port->se, port->tx_dma_addr, port->tx_remaining);\n\tport->tx_dma_addr = 0;\n\tport->tx_remaining = 0;\n\n\tif (!uart_circ_empty(xmit))\n\t\tqcom_geni_serial_start_tx_dma(uport);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(uport);\n}\n\nstatic irqreturn_t qcom_geni_serial_isr(int isr, void *dev)\n{\n\tu32 m_irq_en;\n\tu32 m_irq_status;\n\tu32 s_irq_status;\n\tu32 geni_status;\n\tu32 dma;\n\tu32 dma_tx_status;\n\tu32 dma_rx_status;\n\tstruct uart_port *uport = dev;\n\tbool drop_rx = false;\n\tstruct tty_port *tport = &uport->state->port;\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\n\tif (uport->suspended)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&uport->lock);\n\n\tm_irq_status = readl(uport->membase + SE_GENI_M_IRQ_STATUS);\n\ts_irq_status = readl(uport->membase + SE_GENI_S_IRQ_STATUS);\n\tdma_tx_status = readl(uport->membase + SE_DMA_TX_IRQ_STAT);\n\tdma_rx_status = readl(uport->membase + SE_DMA_RX_IRQ_STAT);\n\tgeni_status = readl(uport->membase + SE_GENI_STATUS);\n\tdma = readl(uport->membase + SE_GENI_DMA_MODE_EN);\n\tm_irq_en = readl(uport->membase + SE_GENI_M_IRQ_EN);\n\twritel(m_irq_status, uport->membase + SE_GENI_M_IRQ_CLEAR);\n\twritel(s_irq_status, uport->membase + SE_GENI_S_IRQ_CLEAR);\n\twritel(dma_tx_status, uport->membase + SE_DMA_TX_IRQ_CLR);\n\twritel(dma_rx_status, uport->membase + SE_DMA_RX_IRQ_CLR);\n\n\tif (WARN_ON(m_irq_status & M_ILLEGAL_CMD_EN))\n\t\tgoto out_unlock;\n\n\tif (s_irq_status & S_RX_FIFO_WR_ERR_EN) {\n\t\tuport->icount.overrun++;\n\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\t}\n\n\tif (s_irq_status & (S_GP_IRQ_0_EN | S_GP_IRQ_1_EN)) {\n\t\tif (s_irq_status & S_GP_IRQ_0_EN)\n\t\t\tuport->icount.parity++;\n\t\tdrop_rx = true;\n\t} else if (s_irq_status & (S_GP_IRQ_2_EN | S_GP_IRQ_3_EN)) {\n\t\tuport->icount.brk++;\n\t\tport->brk = true;\n\t}\n\n\tif (dma) {\n\t\tif (dma_tx_status & TX_DMA_DONE)\n\t\t\tqcom_geni_serial_handle_tx_dma(uport);\n\n\t\tif (dma_rx_status) {\n\t\t\tif (dma_rx_status & RX_RESET_DONE)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tif (dma_rx_status & RX_DMA_PARITY_ERR) {\n\t\t\t\tuport->icount.parity++;\n\t\t\t\tdrop_rx = true;\n\t\t\t}\n\n\t\t\tif (dma_rx_status & RX_DMA_BREAK)\n\t\t\t\tuport->icount.brk++;\n\n\t\t\tif (dma_rx_status & (RX_DMA_DONE | RX_EOT))\n\t\t\t\tqcom_geni_serial_handle_rx_dma(uport, drop_rx);\n\t\t}\n\t} else {\n\t\tif (m_irq_status & m_irq_en &\n\t\t    (M_TX_FIFO_WATERMARK_EN | M_CMD_DONE_EN))\n\t\t\tqcom_geni_serial_handle_tx_fifo(uport,\n\t\t\t\t\tm_irq_status & M_CMD_DONE_EN,\n\t\t\t\t\tgeni_status & M_GENI_CMD_ACTIVE);\n\n\t\tif (s_irq_status & (S_RX_FIFO_WATERMARK_EN | S_RX_FIFO_LAST_EN))\n\t\t\tqcom_geni_serial_handle_rx_fifo(uport, drop_rx);\n\t}\n\nout_unlock:\n\tuart_unlock_and_check_sysrq(uport);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int setup_fifos(struct qcom_geni_serial_port *port)\n{\n\tstruct uart_port *uport;\n\tu32 old_rx_fifo_depth = port->rx_fifo_depth;\n\n\tuport = &port->uport;\n\tport->tx_fifo_depth = geni_se_get_tx_fifo_depth(&port->se);\n\tport->tx_fifo_width = geni_se_get_tx_fifo_width(&port->se);\n\tport->rx_fifo_depth = geni_se_get_rx_fifo_depth(&port->se);\n\tuport->fifosize =\n\t\t(port->tx_fifo_depth * port->tx_fifo_width) / BITS_PER_BYTE;\n\n\tif (port->rx_buf && (old_rx_fifo_depth != port->rx_fifo_depth) && port->rx_fifo_depth) {\n\t\t \n\t\tport->rx_buf = devm_krealloc(uport->dev, port->rx_buf,\n\t\t\t\t\t     port->rx_fifo_depth * sizeof(u32),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!port->rx_buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void qcom_geni_serial_shutdown(struct uart_port *uport)\n{\n\tdisable_irq(uport->irq);\n\n\tif (uart_console(uport))\n\t\treturn;\n\n\tqcom_geni_serial_stop_tx(uport);\n\tqcom_geni_serial_stop_rx(uport);\n}\n\nstatic int qcom_geni_serial_port_setup(struct uart_port *uport)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\tu32 rxstale = DEFAULT_BITS_PER_CHAR * STALE_TIMEOUT;\n\tu32 proto;\n\tu32 pin_swap;\n\tint ret;\n\n\tproto = geni_se_read_proto(&port->se);\n\tif (proto != GENI_SE_UART) {\n\t\tdev_err(uport->dev, \"Invalid FW loaded, proto: %d\\n\", proto);\n\t\treturn -ENXIO;\n\t}\n\n\tqcom_geni_serial_stop_rx(uport);\n\n\tret = setup_fifos(port);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(rxstale, uport->membase + SE_UART_RX_STALE_CNT);\n\n\tpin_swap = readl(uport->membase + SE_UART_IO_MACRO_CTRL);\n\tif (port->rx_tx_swap) {\n\t\tpin_swap &= ~DEFAULT_IO_MACRO_IO2_IO3_MASK;\n\t\tpin_swap |= IO_MACRO_IO2_IO3_SWAP;\n\t}\n\tif (port->cts_rts_swap) {\n\t\tpin_swap &= ~DEFAULT_IO_MACRO_IO0_IO1_MASK;\n\t\tpin_swap |= IO_MACRO_IO0_SEL;\n\t}\n\t \n\tif (port->rx_tx_swap || port->cts_rts_swap)\n\t\twritel(pin_swap, uport->membase + SE_UART_IO_MACRO_CTRL);\n\n\t \n\tif (uart_console(uport))\n\t\tqcom_geni_serial_poll_tx_done(uport);\n\tgeni_se_config_packing(&port->se, BITS_PER_BYTE, BYTES_PER_FIFO_WORD,\n\t\t\t       false, true, true);\n\tgeni_se_init(&port->se, UART_RX_WM, port->rx_fifo_depth - 2);\n\tgeni_se_select_mode(&port->se, port->dev_data->mode);\n\tqcom_geni_serial_start_rx(uport);\n\tport->setup = true;\n\n\treturn 0;\n}\n\nstatic int qcom_geni_serial_startup(struct uart_port *uport)\n{\n\tint ret;\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\n\tif (!port->setup) {\n\t\tret = qcom_geni_serial_port_setup(uport);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tenable_irq(uport->irq);\n\n\treturn 0;\n}\n\nstatic unsigned long find_clk_rate_in_tol(struct clk *clk, unsigned int desired_clk,\n\t\t\tunsigned int *clk_div, unsigned int percent_tol)\n{\n\tunsigned long freq;\n\tunsigned long div, maxdiv;\n\tu64 mult;\n\tunsigned long offset, abs_tol, achieved;\n\n\tabs_tol = div_u64((u64)desired_clk * percent_tol, 100);\n\tmaxdiv = CLK_DIV_MSK >> CLK_DIV_SHFT;\n\tdiv = 1;\n\twhile (div <= maxdiv) {\n\t\tmult = (u64)div * desired_clk;\n\t\tif (mult != (unsigned long)mult)\n\t\t\tbreak;\n\n\t\toffset = div * abs_tol;\n\t\tfreq = clk_round_rate(clk, mult - offset);\n\n\t\t \n\t\tif (freq < mult - offset)\n\t\t\tbreak;\n\n\t\t \n\t\tdiv = DIV_ROUND_CLOSEST(freq, desired_clk);\n\t\tachieved = DIV_ROUND_CLOSEST(freq, div);\n\t\tif (achieved <= desired_clk + abs_tol &&\n\t\t    achieved >= desired_clk - abs_tol) {\n\t\t\t*clk_div = div;\n\t\t\treturn freq;\n\t\t}\n\n\t\tdiv = DIV_ROUND_UP(freq, desired_clk);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long get_clk_div_rate(struct clk *clk, unsigned int baud,\n\t\t\tunsigned int sampling_rate, unsigned int *clk_div)\n{\n\tunsigned long ser_clk;\n\tunsigned long desired_clk;\n\n\tdesired_clk = baud * sampling_rate;\n\tif (!desired_clk)\n\t\treturn 0;\n\n\t \n\tser_clk = find_clk_rate_in_tol(clk, desired_clk, clk_div, 2);\n\tif (!ser_clk)\n\t\tser_clk = find_clk_rate_in_tol(clk, desired_clk, clk_div, 5);\n\n\treturn ser_clk;\n}\n\nstatic void qcom_geni_serial_set_termios(struct uart_port *uport,\n\t\t\t\t\t struct ktermios *termios,\n\t\t\t\t\t const struct ktermios *old)\n{\n\tunsigned int baud;\n\tu32 bits_per_char;\n\tu32 tx_trans_cfg;\n\tu32 tx_parity_cfg;\n\tu32 rx_trans_cfg;\n\tu32 rx_parity_cfg;\n\tu32 stop_bit_len;\n\tunsigned int clk_div;\n\tu32 ser_clk_cfg;\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\tunsigned long clk_rate;\n\tu32 ver, sampling_rate;\n\tunsigned int avg_bw_core;\n\n\tqcom_geni_serial_stop_rx(uport);\n\t \n\tbaud = uart_get_baud_rate(uport, termios, old, 300, 4000000);\n\tport->baud = baud;\n\n\tsampling_rate = UART_OVERSAMPLING;\n\t \n\tver = geni_se_get_qup_hw_version(&port->se);\n\tif (ver >= QUP_SE_VERSION_2_5)\n\t\tsampling_rate /= 2;\n\n\tclk_rate = get_clk_div_rate(port->se.clk, baud,\n\t\tsampling_rate, &clk_div);\n\tif (!clk_rate) {\n\t\tdev_err(port->se.dev,\n\t\t\t\"Couldn't find suitable clock rate for %u\\n\",\n\t\t\tbaud * sampling_rate);\n\t\tgoto out_restart_rx;\n\t}\n\n\tdev_dbg(port->se.dev, \"desired_rate = %u, clk_rate = %lu, clk_div = %u\\n\",\n\t\t\tbaud * sampling_rate, clk_rate, clk_div);\n\n\tuport->uartclk = clk_rate;\n\tport->clk_rate = clk_rate;\n\tdev_pm_opp_set_rate(uport->dev, clk_rate);\n\tser_clk_cfg = SER_CLK_EN;\n\tser_clk_cfg |= clk_div << CLK_DIV_SHFT;\n\n\t \n\tavg_bw_core = (baud > 115200) ? Bps_to_icc(CORE_2X_50_MHZ)\n\t\t\t\t\t\t: GENI_DEFAULT_BW;\n\tport->se.icc_paths[GENI_TO_CORE].avg_bw = avg_bw_core;\n\tport->se.icc_paths[CPU_TO_GENI].avg_bw = Bps_to_icc(baud);\n\tgeni_icc_set_bw(&port->se);\n\n\t \n\ttx_trans_cfg = readl(uport->membase + SE_UART_TX_TRANS_CFG);\n\ttx_parity_cfg = readl(uport->membase + SE_UART_TX_PARITY_CFG);\n\trx_trans_cfg = readl(uport->membase + SE_UART_RX_TRANS_CFG);\n\trx_parity_cfg = readl(uport->membase + SE_UART_RX_PARITY_CFG);\n\tif (termios->c_cflag & PARENB) {\n\t\ttx_trans_cfg |= UART_TX_PAR_EN;\n\t\trx_trans_cfg |= UART_RX_PAR_EN;\n\t\ttx_parity_cfg |= PAR_CALC_EN;\n\t\trx_parity_cfg |= PAR_CALC_EN;\n\t\tif (termios->c_cflag & PARODD) {\n\t\t\ttx_parity_cfg |= PAR_ODD;\n\t\t\trx_parity_cfg |= PAR_ODD;\n\t\t} else if (termios->c_cflag & CMSPAR) {\n\t\t\ttx_parity_cfg |= PAR_SPACE;\n\t\t\trx_parity_cfg |= PAR_SPACE;\n\t\t} else {\n\t\t\ttx_parity_cfg |= PAR_EVEN;\n\t\t\trx_parity_cfg |= PAR_EVEN;\n\t\t}\n\t} else {\n\t\ttx_trans_cfg &= ~UART_TX_PAR_EN;\n\t\trx_trans_cfg &= ~UART_RX_PAR_EN;\n\t\ttx_parity_cfg &= ~PAR_CALC_EN;\n\t\trx_parity_cfg &= ~PAR_CALC_EN;\n\t}\n\n\t \n\tbits_per_char = tty_get_char_size(termios->c_cflag);\n\n\t \n\tif (termios->c_cflag & CSTOPB)\n\t\tstop_bit_len = TX_STOP_BIT_LEN_2;\n\telse\n\t\tstop_bit_len = TX_STOP_BIT_LEN_1;\n\n\t \n\tif (termios->c_cflag & CRTSCTS)\n\t\ttx_trans_cfg &= ~UART_CTS_MASK;\n\telse\n\t\ttx_trans_cfg |= UART_CTS_MASK;\n\n\tif (baud)\n\t\tuart_update_timeout(uport, termios->c_cflag, baud);\n\n\tif (!uart_console(uport))\n\t\twritel(port->loopback,\n\t\t\t\tuport->membase + SE_UART_LOOPBACK_CFG);\n\twritel(tx_trans_cfg, uport->membase + SE_UART_TX_TRANS_CFG);\n\twritel(tx_parity_cfg, uport->membase + SE_UART_TX_PARITY_CFG);\n\twritel(rx_trans_cfg, uport->membase + SE_UART_RX_TRANS_CFG);\n\twritel(rx_parity_cfg, uport->membase + SE_UART_RX_PARITY_CFG);\n\twritel(bits_per_char, uport->membase + SE_UART_TX_WORD_LEN);\n\twritel(bits_per_char, uport->membase + SE_UART_RX_WORD_LEN);\n\twritel(stop_bit_len, uport->membase + SE_UART_TX_STOP_BIT_LEN);\n\twritel(ser_clk_cfg, uport->membase + GENI_SER_M_CLK_CFG);\n\twritel(ser_clk_cfg, uport->membase + GENI_SER_S_CLK_CFG);\nout_restart_rx:\n\tqcom_geni_serial_start_rx(uport);\n}\n\n#ifdef CONFIG_SERIAL_QCOM_GENI_CONSOLE\nstatic int qcom_geni_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *uport;\n\tstruct qcom_geni_serial_port *port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret;\n\n\tif (co->index >= GENI_UART_CONS_PORTS  || co->index < 0)\n\t\treturn -ENXIO;\n\n\tport = get_port_from_line(co->index, true);\n\tif (IS_ERR(port)) {\n\t\tpr_err(\"Invalid line %d\\n\", co->index);\n\t\treturn PTR_ERR(port);\n\t}\n\n\tuport = &port->uport;\n\n\tif (unlikely(!uport->membase))\n\t\treturn -ENXIO;\n\n\tif (!port->setup) {\n\t\tret = qcom_geni_serial_port_setup(uport);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(uport, co, baud, parity, bits, flow);\n}\n\nstatic void qcom_geni_serial_earlycon_write(struct console *con,\n\t\t\t\t\tconst char *s, unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\t__qcom_geni_serial_console_write(&dev->port, s, n);\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int qcom_geni_serial_earlycon_read(struct console *con,\n\t\t\t\t\t  char *s, unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\tstruct uart_port *uport = &dev->port;\n\tint num_read = 0;\n\tint ch;\n\n\twhile (num_read < n) {\n\t\tch = qcom_geni_serial_get_char(uport);\n\t\tif (ch == NO_POLL_CHAR)\n\t\t\tbreak;\n\t\ts[num_read++] = ch;\n\t}\n\n\treturn num_read;\n}\n\nstatic void __init qcom_geni_serial_enable_early_read(struct geni_se *se,\n\t\t\t\t\t\t      struct console *con)\n{\n\tgeni_se_setup_s_cmd(se, UART_START_READ, 0);\n\tcon->read = qcom_geni_serial_earlycon_read;\n}\n#else\nstatic inline void qcom_geni_serial_enable_early_read(struct geni_se *se,\n\t\t\t\t\t\t      struct console *con) { }\n#endif\n\nstatic struct qcom_geni_private_data earlycon_private_data;\n\nstatic int __init qcom_geni_serial_earlycon_setup(struct earlycon_device *dev,\n\t\t\t\t\t\t\t\tconst char *opt)\n{\n\tstruct uart_port *uport = &dev->port;\n\tu32 tx_trans_cfg;\n\tu32 tx_parity_cfg = 0;\t \n\tu32 rx_trans_cfg = 0;\n\tu32 rx_parity_cfg = 0;\t \n\tu32 stop_bit_len = 0;\t \n\tu32 bits_per_char;\n\tstruct geni_se se;\n\n\tif (!uport->membase)\n\t\treturn -EINVAL;\n\n\tuport->private_data = &earlycon_private_data;\n\n\tmemset(&se, 0, sizeof(se));\n\tse.base = uport->membase;\n\tif (geni_se_read_proto(&se) != GENI_SE_UART)\n\t\treturn -ENXIO;\n\t \n\ttx_trans_cfg = UART_CTS_MASK;\n\tbits_per_char = BITS_PER_BYTE;\n\n\t \n\tqcom_geni_serial_poll_tx_done(uport);\n\tqcom_geni_serial_abort_rx(uport);\n\tgeni_se_config_packing(&se, BITS_PER_BYTE, BYTES_PER_FIFO_WORD,\n\t\t\t       false, true, true);\n\tgeni_se_init(&se, DEF_FIFO_DEPTH_WORDS / 2, DEF_FIFO_DEPTH_WORDS - 2);\n\tgeni_se_select_mode(&se, GENI_SE_FIFO);\n\n\twritel(tx_trans_cfg, uport->membase + SE_UART_TX_TRANS_CFG);\n\twritel(tx_parity_cfg, uport->membase + SE_UART_TX_PARITY_CFG);\n\twritel(rx_trans_cfg, uport->membase + SE_UART_RX_TRANS_CFG);\n\twritel(rx_parity_cfg, uport->membase + SE_UART_RX_PARITY_CFG);\n\twritel(bits_per_char, uport->membase + SE_UART_TX_WORD_LEN);\n\twritel(bits_per_char, uport->membase + SE_UART_RX_WORD_LEN);\n\twritel(stop_bit_len, uport->membase + SE_UART_TX_STOP_BIT_LEN);\n\n\tdev->con->write = qcom_geni_serial_earlycon_write;\n\tdev->con->setup = NULL;\n\tqcom_geni_serial_enable_early_read(&se, dev->con);\n\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(qcom_geni, \"qcom,geni-debug-uart\",\n\t\t\t\tqcom_geni_serial_earlycon_setup);\n\nstatic int __init console_register(struct uart_driver *drv)\n{\n\treturn uart_register_driver(drv);\n}\n\nstatic void console_unregister(struct uart_driver *drv)\n{\n\tuart_unregister_driver(drv);\n}\n\nstatic struct console cons_ops = {\n\t.name = \"ttyMSM\",\n\t.write = qcom_geni_serial_console_write,\n\t.device = uart_console_device,\n\t.setup = qcom_geni_console_setup,\n\t.flags = CON_PRINTBUFFER,\n\t.index = -1,\n\t.data = &qcom_geni_console_driver,\n};\n\nstatic struct uart_driver qcom_geni_console_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = \"qcom_geni_console\",\n\t.dev_name = \"ttyMSM\",\n\t.nr =  GENI_UART_CONS_PORTS,\n\t.cons = &cons_ops,\n};\n#else\nstatic int console_register(struct uart_driver *drv)\n{\n\treturn 0;\n}\n\nstatic void console_unregister(struct uart_driver *drv)\n{\n}\n#endif  \n\nstatic struct uart_driver qcom_geni_uart_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = \"qcom_geni_uart\",\n\t.dev_name = \"ttyHS\",\n\t.nr =  GENI_UART_PORTS,\n};\n\nstatic void qcom_geni_serial_pm(struct uart_port *uport,\n\t\tunsigned int new_state, unsigned int old_state)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport);\n\n\t \n\tif (old_state == UART_PM_STATE_UNDEFINED)\n\t\told_state = UART_PM_STATE_OFF;\n\n\tif (new_state == UART_PM_STATE_ON && old_state == UART_PM_STATE_OFF) {\n\t\tgeni_icc_enable(&port->se);\n\t\tif (port->clk_rate)\n\t\t\tdev_pm_opp_set_rate(uport->dev, port->clk_rate);\n\t\tgeni_se_resources_on(&port->se);\n\t} else if (new_state == UART_PM_STATE_OFF &&\n\t\t\told_state == UART_PM_STATE_ON) {\n\t\tgeni_se_resources_off(&port->se);\n\t\tdev_pm_opp_set_rate(uport->dev, 0);\n\t\tgeni_icc_disable(&port->se);\n\t}\n}\n\nstatic const struct uart_ops qcom_geni_console_pops = {\n\t.tx_empty = qcom_geni_serial_tx_empty,\n\t.stop_tx = qcom_geni_serial_stop_tx_fifo,\n\t.start_tx = qcom_geni_serial_start_tx_fifo,\n\t.stop_rx = qcom_geni_serial_stop_rx_fifo,\n\t.start_rx = qcom_geni_serial_start_rx_fifo,\n\t.set_termios = qcom_geni_serial_set_termios,\n\t.startup = qcom_geni_serial_startup,\n\t.request_port = qcom_geni_serial_request_port,\n\t.config_port = qcom_geni_serial_config_port,\n\t.shutdown = qcom_geni_serial_shutdown,\n\t.type = qcom_geni_serial_get_type,\n\t.set_mctrl = qcom_geni_serial_set_mctrl,\n\t.get_mctrl = qcom_geni_serial_get_mctrl,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= qcom_geni_serial_get_char,\n\t.poll_put_char\t= qcom_geni_serial_poll_put_char,\n\t.poll_init = qcom_geni_serial_port_setup,\n#endif\n\t.pm = qcom_geni_serial_pm,\n};\n\nstatic const struct uart_ops qcom_geni_uart_pops = {\n\t.tx_empty = qcom_geni_serial_tx_empty,\n\t.stop_tx = qcom_geni_serial_stop_tx_dma,\n\t.start_tx = qcom_geni_serial_start_tx_dma,\n\t.start_rx = qcom_geni_serial_start_rx_dma,\n\t.stop_rx = qcom_geni_serial_stop_rx_dma,\n\t.set_termios = qcom_geni_serial_set_termios,\n\t.startup = qcom_geni_serial_startup,\n\t.request_port = qcom_geni_serial_request_port,\n\t.config_port = qcom_geni_serial_config_port,\n\t.shutdown = qcom_geni_serial_shutdown,\n\t.type = qcom_geni_serial_get_type,\n\t.set_mctrl = qcom_geni_serial_set_mctrl,\n\t.get_mctrl = qcom_geni_serial_get_mctrl,\n\t.pm = qcom_geni_serial_pm,\n};\n\nstatic int qcom_geni_serial_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tint line;\n\tstruct qcom_geni_serial_port *port;\n\tstruct uart_port *uport;\n\tstruct resource *res;\n\tint irq;\n\tstruct uart_driver *drv;\n\tconst struct qcom_geni_device_data *data;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tif (data->console) {\n\t\tdrv = &qcom_geni_console_driver;\n\t\tline = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\t} else {\n\t\tdrv = &qcom_geni_uart_driver;\n\t\tline = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\t\tif (line == -ENODEV)  \n\t\t\tline = of_alias_get_id(pdev->dev.of_node, \"hsuart\");\n\t}\n\n\tport = get_port_from_line(line, data->console);\n\tif (IS_ERR(port)) {\n\t\tdev_err(&pdev->dev, \"Invalid line %d\\n\", line);\n\t\treturn PTR_ERR(port);\n\t}\n\n\tuport = &port->uport;\n\t \n\tif (uport->private_data)\n\t\treturn -ENODEV;\n\n\tuport->dev = &pdev->dev;\n\tport->dev_data = data;\n\tport->se.dev = &pdev->dev;\n\tport->se.wrapper = dev_get_drvdata(pdev->dev.parent);\n\tport->se.clk = devm_clk_get(&pdev->dev, \"se\");\n\tif (IS_ERR(port->se.clk)) {\n\t\tret = PTR_ERR(port->se.clk);\n\t\tdev_err(&pdev->dev, \"Err getting SE Core clk %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tuport->mapbase = res->start;\n\n\tport->tx_fifo_depth = DEF_FIFO_DEPTH_WORDS;\n\tport->rx_fifo_depth = DEF_FIFO_DEPTH_WORDS;\n\tport->tx_fifo_width = DEF_FIFO_WIDTH_BITS;\n\n\tif (!data->console) {\n\t\tport->rx_buf = devm_kzalloc(uport->dev,\n\t\t\t\t\t    DMA_RX_BUF_SIZE, GFP_KERNEL);\n\t\tif (!port->rx_buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = geni_icc_get(&port->se, NULL);\n\tif (ret)\n\t\treturn ret;\n\tport->se.icc_paths[GENI_TO_CORE].avg_bw = GENI_DEFAULT_BW;\n\tport->se.icc_paths[CPU_TO_GENI].avg_bw = GENI_DEFAULT_BW;\n\n\t \n\tret = geni_icc_set_bw(&port->se);\n\tif (ret)\n\t\treturn ret;\n\n\tport->name = devm_kasprintf(uport->dev, GFP_KERNEL,\n\t\t\t\"qcom_geni_serial_%s%d\",\n\t\t\tuart_console(uport) ? \"console\" : \"uart\", uport->line);\n\tif (!port->name)\n\t\treturn -ENOMEM;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tuport->irq = irq;\n\tuport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_QCOM_GENI_CONSOLE);\n\n\tif (!data->console)\n\t\tport->wakeup_irq = platform_get_irq_optional(pdev, 1);\n\n\tif (of_property_read_bool(pdev->dev.of_node, \"rx-tx-swap\"))\n\t\tport->rx_tx_swap = true;\n\n\tif (of_property_read_bool(pdev->dev.of_node, \"cts-rts-swap\"))\n\t\tport->cts_rts_swap = true;\n\n\tret = devm_pm_opp_set_clkname(&pdev->dev, \"se\");\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = devm_pm_opp_of_add_table(&pdev->dev);\n\tif (ret && ret != -ENODEV) {\n\t\tdev_err(&pdev->dev, \"invalid OPP table in device tree\\n\");\n\t\treturn ret;\n\t}\n\n\tport->private_data.drv = drv;\n\tuport->private_data = &port->private_data;\n\tplatform_set_drvdata(pdev, port);\n\n\tirq_set_status_flags(uport->irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(uport->dev, uport->irq, qcom_geni_serial_isr,\n\t\t\tIRQF_TRIGGER_HIGH, port->name, uport);\n\tif (ret) {\n\t\tdev_err(uport->dev, \"Failed to get IRQ ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = uart_add_one_port(drv, uport);\n\tif (ret)\n\t\treturn ret;\n\n\tif (port->wakeup_irq > 0) {\n\t\tdevice_init_wakeup(&pdev->dev, true);\n\t\tret = dev_pm_set_dedicated_wake_irq(&pdev->dev,\n\t\t\t\t\t\tport->wakeup_irq);\n\t\tif (ret) {\n\t\t\tdevice_init_wakeup(&pdev->dev, false);\n\t\t\tuart_remove_one_port(drv, uport);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int qcom_geni_serial_remove(struct platform_device *pdev)\n{\n\tstruct qcom_geni_serial_port *port = platform_get_drvdata(pdev);\n\tstruct uart_driver *drv = port->private_data.drv;\n\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\tdevice_init_wakeup(&pdev->dev, false);\n\tuart_remove_one_port(drv, &port->uport);\n\n\treturn 0;\n}\n\nstatic int qcom_geni_serial_sys_suspend(struct device *dev)\n{\n\tstruct qcom_geni_serial_port *port = dev_get_drvdata(dev);\n\tstruct uart_port *uport = &port->uport;\n\tstruct qcom_geni_private_data *private_data = uport->private_data;\n\n\t \n\tif (uart_console(uport)) {\n\t\tgeni_icc_set_tag(&port->se, QCOM_ICC_TAG_ACTIVE_ONLY);\n\t\tgeni_icc_set_bw(&port->se);\n\t}\n\treturn uart_suspend_port(private_data->drv, uport);\n}\n\nstatic int qcom_geni_serial_sys_resume(struct device *dev)\n{\n\tint ret;\n\tstruct qcom_geni_serial_port *port = dev_get_drvdata(dev);\n\tstruct uart_port *uport = &port->uport;\n\tstruct qcom_geni_private_data *private_data = uport->private_data;\n\n\tret = uart_resume_port(private_data->drv, uport);\n\tif (uart_console(uport)) {\n\t\tgeni_icc_set_tag(&port->se, QCOM_ICC_TAG_ALWAYS);\n\t\tgeni_icc_set_bw(&port->se);\n\t}\n\treturn ret;\n}\n\nstatic int qcom_geni_serial_sys_hib_resume(struct device *dev)\n{\n\tint ret = 0;\n\tstruct uart_port *uport;\n\tstruct qcom_geni_private_data *private_data;\n\tstruct qcom_geni_serial_port *port = dev_get_drvdata(dev);\n\n\tuport = &port->uport;\n\tprivate_data = uport->private_data;\n\n\tif (uart_console(uport)) {\n\t\tgeni_icc_set_tag(&port->se, QCOM_ICC_TAG_ALWAYS);\n\t\tgeni_icc_set_bw(&port->se);\n\t\tret = uart_resume_port(private_data->drv, uport);\n\t\t \n\t\tqcom_geni_serial_port_setup(uport);\n\t} else {\n\t\t \n\t\tport->setup = false;\n\t}\n\treturn ret;\n}\n\nstatic const struct qcom_geni_device_data qcom_geni_console_data = {\n\t.console = true,\n\t.mode = GENI_SE_FIFO,\n};\n\nstatic const struct qcom_geni_device_data qcom_geni_uart_data = {\n\t.console = false,\n\t.mode = GENI_SE_DMA,\n};\n\nstatic const struct dev_pm_ops qcom_geni_serial_pm_ops = {\n\t.suspend = pm_sleep_ptr(qcom_geni_serial_sys_suspend),\n\t.resume = pm_sleep_ptr(qcom_geni_serial_sys_resume),\n\t.freeze = pm_sleep_ptr(qcom_geni_serial_sys_suspend),\n\t.poweroff = pm_sleep_ptr(qcom_geni_serial_sys_suspend),\n\t.restore = pm_sleep_ptr(qcom_geni_serial_sys_hib_resume),\n\t.thaw = pm_sleep_ptr(qcom_geni_serial_sys_hib_resume),\n};\n\nstatic const struct of_device_id qcom_geni_serial_match_table[] = {\n\t{\n\t\t.compatible = \"qcom,geni-debug-uart\",\n\t\t.data = &qcom_geni_console_data,\n\t},\n\t{\n\t\t.compatible = \"qcom,geni-uart\",\n\t\t.data = &qcom_geni_uart_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_geni_serial_match_table);\n\nstatic struct platform_driver qcom_geni_serial_platform_driver = {\n\t.remove = qcom_geni_serial_remove,\n\t.probe = qcom_geni_serial_probe,\n\t.driver = {\n\t\t.name = \"qcom_geni_serial\",\n\t\t.of_match_table = qcom_geni_serial_match_table,\n\t\t.pm = &qcom_geni_serial_pm_ops,\n\t},\n};\n\nstatic int __init qcom_geni_serial_init(void)\n{\n\tint ret;\n\n\tret = console_register(&qcom_geni_console_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uart_register_driver(&qcom_geni_uart_driver);\n\tif (ret) {\n\t\tconsole_unregister(&qcom_geni_console_driver);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&qcom_geni_serial_platform_driver);\n\tif (ret) {\n\t\tconsole_unregister(&qcom_geni_console_driver);\n\t\tuart_unregister_driver(&qcom_geni_uart_driver);\n\t}\n\treturn ret;\n}\nmodule_init(qcom_geni_serial_init);\n\nstatic void __exit qcom_geni_serial_exit(void)\n{\n\tplatform_driver_unregister(&qcom_geni_serial_platform_driver);\n\tconsole_unregister(&qcom_geni_console_driver);\n\tuart_unregister_driver(&qcom_geni_uart_driver);\n}\nmodule_exit(qcom_geni_serial_exit);\n\nMODULE_DESCRIPTION(\"Serial driver for GENI based QUP cores\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}