{
  "module_name": "imx.c",
  "hash_id": "3932a6433156191b0d9c2e2a30567e7fa32e5041aa5095e7ac970294b1332a69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/imx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/platform_device.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/ktime.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/rational.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n\n#include <asm/irq.h>\n#include <linux/dma/imx-dma.h>\n\n#include \"serial_mctrl_gpio.h\"\n\n \n#define URXD0 0x0   \n#define URTX0 0x40  \n#define UCR1  0x80  \n#define UCR2  0x84  \n#define UCR3  0x88  \n#define UCR4  0x8c  \n#define UFCR  0x90  \n#define USR1  0x94  \n#define USR2  0x98  \n#define UESC  0x9c  \n#define UTIM  0xa0  \n#define UBIR  0xa4  \n#define UBMR  0xa8  \n#define UBRC  0xac  \n#define IMX21_ONEMS 0xb0  \n#define IMX1_UTS 0xd0  \n#define IMX21_UTS 0xb4  \n\n \n#define URXD_DUMMY_READ (1<<16)\n#define URXD_CHARRDY\t(1<<15)\n#define URXD_ERR\t(1<<14)\n#define URXD_OVRRUN\t(1<<13)\n#define URXD_FRMERR\t(1<<12)\n#define URXD_BRK\t(1<<11)\n#define URXD_PRERR\t(1<<10)\n#define URXD_RX_DATA\t(0xFF<<0)\n#define UCR1_ADEN\t(1<<15)  \n#define UCR1_ADBR\t(1<<14)  \n#define UCR1_TRDYEN\t(1<<13)  \n#define UCR1_IDEN\t(1<<12)  \n#define UCR1_ICD_REG(x) (((x) & 3) << 10)  \n#define UCR1_RRDYEN\t(1<<9)\t \n#define UCR1_RXDMAEN\t(1<<8)\t \n#define UCR1_IREN\t(1<<7)\t \n#define UCR1_TXMPTYEN\t(1<<6)\t \n#define UCR1_RTSDEN\t(1<<5)\t \n#define UCR1_SNDBRK\t(1<<4)\t \n#define UCR1_TXDMAEN\t(1<<3)\t \n#define IMX1_UCR1_UARTCLKEN (1<<2)  \n#define UCR1_ATDMAEN    (1<<2)   \n#define UCR1_DOZE\t(1<<1)\t \n#define UCR1_UARTEN\t(1<<0)\t \n#define UCR2_ESCI\t(1<<15)\t \n#define UCR2_IRTS\t(1<<14)\t \n#define UCR2_CTSC\t(1<<13)\t \n#define UCR2_CTS\t(1<<12)\t \n#define UCR2_ESCEN\t(1<<11)\t \n#define UCR2_PREN\t(1<<8)\t \n#define UCR2_PROE\t(1<<7)\t \n#define UCR2_STPB\t(1<<6)\t \n#define UCR2_WS\t\t(1<<5)\t \n#define UCR2_RTSEN\t(1<<4)\t \n#define UCR2_ATEN\t(1<<3)\t \n#define UCR2_TXEN\t(1<<2)\t \n#define UCR2_RXEN\t(1<<1)\t \n#define UCR2_SRST\t(1<<0)\t \n#define UCR3_DTREN\t(1<<13)  \n#define UCR3_PARERREN\t(1<<12)  \n#define UCR3_FRAERREN\t(1<<11)  \n#define UCR3_DSR\t(1<<10)  \n#define UCR3_DCD\t(1<<9)\t \n#define UCR3_RI\t\t(1<<8)\t \n#define UCR3_ADNIMP\t(1<<7)\t \n#define UCR3_RXDSEN\t(1<<6)\t \n#define UCR3_AIRINTEN\t(1<<5)\t \n#define UCR3_AWAKEN\t(1<<4)\t \n#define UCR3_DTRDEN\t(1<<3)\t \n#define IMX21_UCR3_RXDMUXSEL\t(1<<2)\t \n#define UCR3_INVT\t(1<<1)\t \n#define UCR3_BPEN\t(1<<0)\t \n#define UCR4_CTSTL_SHF\t10\t \n#define UCR4_CTSTL_MASK\t0x3F\t \n#define UCR4_INVR\t(1<<9)\t \n#define UCR4_ENIRI\t(1<<8)\t \n#define UCR4_WKEN\t(1<<7)\t \n#define UCR4_REF16\t(1<<6)\t \n#define UCR4_IDDMAEN    (1<<6)   \n#define UCR4_IRSC\t(1<<5)\t \n#define UCR4_TCEN\t(1<<3)\t \n#define UCR4_BKEN\t(1<<2)\t \n#define UCR4_OREN\t(1<<1)\t \n#define UCR4_DREN\t(1<<0)\t \n#define UFCR_RXTL_SHF\t0\t \n#define UFCR_DCEDTE\t(1<<6)\t \n#define UFCR_RFDIV\t(7<<7)\t \n#define UFCR_RFDIV_REG(x)\t(((x) < 7 ? 6 - (x) : 6) << 7)\n#define UFCR_TXTL_SHF\t10\t \n#define USR1_PARITYERR\t(1<<15)  \n#define USR1_RTSS\t(1<<14)  \n#define USR1_TRDY\t(1<<13)  \n#define USR1_RTSD\t(1<<12)  \n#define USR1_ESCF\t(1<<11)  \n#define USR1_FRAMERR\t(1<<10)  \n#define USR1_RRDY\t(1<<9)\t  \n#define USR1_AGTIM\t(1<<8)\t  \n#define USR1_DTRD\t(1<<7)\t  \n#define USR1_RXDS\t (1<<6)\t  \n#define USR1_AIRINT\t (1<<5)\t  \n#define USR1_AWAKE\t (1<<4)\t  \n#define USR2_ADET\t (1<<15)  \n#define USR2_TXFE\t (1<<14)  \n#define USR2_DTRF\t (1<<13)  \n#define USR2_IDLE\t (1<<12)  \n#define USR2_RIDELT\t (1<<10)  \n#define USR2_RIIN\t (1<<9)\t  \n#define USR2_IRINT\t (1<<8)\t  \n#define USR2_WAKE\t (1<<7)\t  \n#define USR2_DCDIN\t (1<<5)\t  \n#define USR2_RTSF\t (1<<4)\t  \n#define USR2_TXDC\t (1<<3)\t  \n#define USR2_BRCD\t (1<<2)\t  \n#define USR2_ORE\t(1<<1)\t  \n#define USR2_RDR\t(1<<0)\t  \n#define UTS_FRCPERR\t(1<<13)  \n#define UTS_LOOP\t(1<<12)\t  \n#define UTS_TXEMPTY\t (1<<6)\t  \n#define UTS_RXEMPTY\t (1<<5)\t  \n#define UTS_TXFULL\t (1<<4)\t  \n#define UTS_RXFULL\t (1<<3)\t  \n#define UTS_SOFTRST\t (1<<0)\t  \n\n \n#define SERIAL_IMX_MAJOR\t207\n#define MINOR_START\t\t16\n#define DEV_NAME\t\t\"ttymxc\"\n\n \n#define MCTRL_TIMEOUT\t(250*HZ/1000)\n\n#define DRIVER_NAME \"IMX-uart\"\n\n#define UART_NR 8\n\n \nenum imx_uart_type {\n\tIMX1_UART,\n\tIMX21_UART,\n\tIMX53_UART,\n\tIMX6Q_UART,\n};\n\n \nstruct imx_uart_data {\n\tunsigned uts_reg;\n\tenum imx_uart_type devtype;\n};\n\nenum imx_tx_state {\n\tOFF,\n\tWAIT_AFTER_RTS,\n\tSEND,\n\tWAIT_AFTER_SEND,\n};\n\nstruct imx_port {\n\tstruct uart_port\tport;\n\tstruct timer_list\ttimer;\n\tunsigned int\t\told_status;\n\tunsigned int\t\thave_rtscts:1;\n\tunsigned int\t\thave_rtsgpio:1;\n\tunsigned int\t\tdte_mode:1;\n\tunsigned int\t\tinverted_tx:1;\n\tunsigned int\t\tinverted_rx:1;\n\tstruct clk\t\t*clk_ipg;\n\tstruct clk\t\t*clk_per;\n\tconst struct imx_uart_data *devdata;\n\n\tstruct mctrl_gpios *gpios;\n\n\t \n\tint idle_counter;\n\n\t \n\tunsigned int\t\tdma_is_enabled:1;\n\tunsigned int\t\tdma_is_rxing:1;\n\tunsigned int\t\tdma_is_txing:1;\n\tstruct dma_chan\t\t*dma_chan_rx, *dma_chan_tx;\n\tstruct scatterlist\trx_sgl, tx_sgl[2];\n\tvoid\t\t\t*rx_buf;\n\tstruct circ_buf\t\trx_ring;\n\tunsigned int\t\trx_buf_size;\n\tunsigned int\t\trx_period_length;\n\tunsigned int\t\trx_periods;\n\tdma_cookie_t\t\trx_cookie;\n\tunsigned int\t\ttx_bytes;\n\tunsigned int\t\tdma_tx_nents;\n\tunsigned int            saved_reg[10];\n\tbool\t\t\tcontext_saved;\n\n\tenum imx_tx_state\ttx_state;\n\tstruct hrtimer\t\ttrigger_start_tx;\n\tstruct hrtimer\t\ttrigger_stop_tx;\n};\n\nstruct imx_port_ucrs {\n\tunsigned int\tucr1;\n\tunsigned int\tucr2;\n\tunsigned int\tucr3;\n};\n\nstatic struct imx_uart_data imx_uart_devdata[] = {\n\t[IMX1_UART] = {\n\t\t.uts_reg = IMX1_UTS,\n\t\t.devtype = IMX1_UART,\n\t},\n\t[IMX21_UART] = {\n\t\t.uts_reg = IMX21_UTS,\n\t\t.devtype = IMX21_UART,\n\t},\n\t[IMX53_UART] = {\n\t\t.uts_reg = IMX21_UTS,\n\t\t.devtype = IMX53_UART,\n\t},\n\t[IMX6Q_UART] = {\n\t\t.uts_reg = IMX21_UTS,\n\t\t.devtype = IMX6Q_UART,\n\t},\n};\n\nstatic const struct of_device_id imx_uart_dt_ids[] = {\n\t{ .compatible = \"fsl,imx6q-uart\", .data = &imx_uart_devdata[IMX6Q_UART], },\n\t{ .compatible = \"fsl,imx53-uart\", .data = &imx_uart_devdata[IMX53_UART], },\n\t{ .compatible = \"fsl,imx1-uart\", .data = &imx_uart_devdata[IMX1_UART], },\n\t{ .compatible = \"fsl,imx21-uart\", .data = &imx_uart_devdata[IMX21_UART], },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_uart_dt_ids);\n\nstatic inline void imx_uart_writel(struct imx_port *sport, u32 val, u32 offset)\n{\n\twritel(val, sport->port.membase + offset);\n}\n\nstatic inline u32 imx_uart_readl(struct imx_port *sport, u32 offset)\n{\n\treturn readl(sport->port.membase + offset);\n}\n\nstatic inline unsigned imx_uart_uts_reg(struct imx_port *sport)\n{\n\treturn sport->devdata->uts_reg;\n}\n\nstatic inline int imx_uart_is_imx1(struct imx_port *sport)\n{\n\treturn sport->devdata->devtype == IMX1_UART;\n}\n\n \n#if IS_ENABLED(CONFIG_SERIAL_IMX_CONSOLE)\nstatic void imx_uart_ucrs_save(struct imx_port *sport,\n\t\t\t       struct imx_port_ucrs *ucr)\n{\n\t \n\tucr->ucr1 = imx_uart_readl(sport, UCR1);\n\tucr->ucr2 = imx_uart_readl(sport, UCR2);\n\tucr->ucr3 = imx_uart_readl(sport, UCR3);\n}\n\nstatic void imx_uart_ucrs_restore(struct imx_port *sport,\n\t\t\t\t  struct imx_port_ucrs *ucr)\n{\n\t \n\timx_uart_writel(sport, ucr->ucr1, UCR1);\n\timx_uart_writel(sport, ucr->ucr2, UCR2);\n\timx_uart_writel(sport, ucr->ucr3, UCR3);\n}\n#endif\n\n \nstatic void imx_uart_rts_active(struct imx_port *sport, u32 *ucr2)\n{\n\t*ucr2 &= ~(UCR2_CTSC | UCR2_CTS);\n\n\tmctrl_gpio_set(sport->gpios, sport->port.mctrl | TIOCM_RTS);\n}\n\n \nstatic void imx_uart_rts_inactive(struct imx_port *sport, u32 *ucr2)\n{\n\t*ucr2 &= ~UCR2_CTSC;\n\t*ucr2 |= UCR2_CTS;\n\n\tmctrl_gpio_set(sport->gpios, sport->port.mctrl & ~TIOCM_RTS);\n}\n\nstatic void start_hrtimer_ms(struct hrtimer *hrt, unsigned long msec)\n{\n       hrtimer_start(hrt, ms_to_ktime(msec), HRTIMER_MODE_REL);\n}\n\n \nstatic void imx_uart_soft_reset(struct imx_port *sport)\n{\n\tint i = 10;\n\tu32 ucr2, ubir, ubmr, uts;\n\n\t \n\tubir = imx_uart_readl(sport, UBIR);\n\tubmr = imx_uart_readl(sport, UBMR);\n\tuts = imx_uart_readl(sport, IMX21_UTS);\n\n\tucr2 = imx_uart_readl(sport, UCR2);\n\timx_uart_writel(sport, ucr2 & ~UCR2_SRST, UCR2);\n\n\twhile (!(imx_uart_readl(sport, UCR2) & UCR2_SRST) && (--i > 0))\n\t\tudelay(1);\n\n\t \n\timx_uart_writel(sport, ubir, UBIR);\n\timx_uart_writel(sport, ubmr, UBMR);\n\timx_uart_writel(sport, uts, IMX21_UTS);\n\n\tsport->idle_counter = 0;\n}\n\nstatic void imx_uart_disable_loopback_rs485(struct imx_port *sport)\n{\n\tunsigned int uts;\n\n\t \n\tuts = imx_uart_readl(sport, imx_uart_uts_reg(sport));\n\tuts &= ~UTS_LOOP;\n\timx_uart_writel(sport, uts, imx_uart_uts_reg(sport));\n}\n\n \nstatic void imx_uart_start_rx(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tunsigned int ucr1, ucr2;\n\n\tucr1 = imx_uart_readl(sport, UCR1);\n\tucr2 = imx_uart_readl(sport, UCR2);\n\n\tucr2 |= UCR2_RXEN;\n\n\tif (sport->dma_is_enabled) {\n\t\tucr1 |= UCR1_RXDMAEN | UCR1_ATDMAEN;\n\t} else {\n\t\tucr1 |= UCR1_RRDYEN;\n\t\tucr2 |= UCR2_ATEN;\n\t}\n\n\t \n\timx_uart_writel(sport, ucr2, UCR2);\n\timx_uart_writel(sport, ucr1, UCR1);\n\timx_uart_disable_loopback_rs485(sport);\n}\n\n \nstatic void imx_uart_stop_tx(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tu32 ucr1, ucr4, usr2;\n\n\tif (sport->tx_state == OFF)\n\t\treturn;\n\n\t \n\tif (sport->dma_is_txing)\n\t\treturn;\n\n\tucr1 = imx_uart_readl(sport, UCR1);\n\timx_uart_writel(sport, ucr1 & ~UCR1_TRDYEN, UCR1);\n\n\tucr4 = imx_uart_readl(sport, UCR4);\n\tusr2 = imx_uart_readl(sport, USR2);\n\tif ((!(usr2 & USR2_TXDC)) && (ucr4 & UCR4_TCEN)) {\n\t\t \n\t\treturn;\n\t}\n\n\tucr4 &= ~UCR4_TCEN;\n\timx_uart_writel(sport, ucr4, UCR4);\n\n\t \n\tif (port->rs485.flags & SER_RS485_ENABLED) {\n\t\tif (sport->tx_state == SEND) {\n\t\t\tsport->tx_state = WAIT_AFTER_SEND;\n\n\t\t\tif (port->rs485.delay_rts_after_send > 0) {\n\t\t\t\tstart_hrtimer_ms(&sport->trigger_stop_tx,\n\t\t\t\t\t port->rs485.delay_rts_after_send);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t}\n\n\t\tif (sport->tx_state == WAIT_AFTER_RTS ||\n\t\t    sport->tx_state == WAIT_AFTER_SEND) {\n\t\t\tu32 ucr2;\n\n\t\t\thrtimer_try_to_cancel(&sport->trigger_start_tx);\n\n\t\t\tucr2 = imx_uart_readl(sport, UCR2);\n\t\t\tif (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)\n\t\t\t\timx_uart_rts_active(sport, &ucr2);\n\t\t\telse\n\t\t\t\timx_uart_rts_inactive(sport, &ucr2);\n\t\t\timx_uart_writel(sport, ucr2, UCR2);\n\n\t\t\tif (!port->rs485_rx_during_tx_gpio)\n\t\t\t\timx_uart_start_rx(port);\n\n\t\t\tsport->tx_state = OFF;\n\t\t}\n\t} else {\n\t\tsport->tx_state = OFF;\n\t}\n}\n\n \nstatic void imx_uart_stop_rx(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tu32 ucr1, ucr2, ucr4, uts;\n\n\tucr1 = imx_uart_readl(sport, UCR1);\n\tucr2 = imx_uart_readl(sport, UCR2);\n\tucr4 = imx_uart_readl(sport, UCR4);\n\n\tif (sport->dma_is_enabled) {\n\t\tucr1 &= ~(UCR1_RXDMAEN | UCR1_ATDMAEN);\n\t} else {\n\t\tucr1 &= ~UCR1_RRDYEN;\n\t\tucr2 &= ~UCR2_ATEN;\n\t\tucr4 &= ~UCR4_OREN;\n\t}\n\timx_uart_writel(sport, ucr1, UCR1);\n\timx_uart_writel(sport, ucr4, UCR4);\n\n\t \n\tif (port->rs485.flags & SER_RS485_ENABLED &&\n\t    port->rs485.flags & SER_RS485_RTS_ON_SEND &&\n\t    sport->have_rtscts && !sport->have_rtsgpio) {\n\t\tuts = imx_uart_readl(sport, imx_uart_uts_reg(sport));\n\t\tuts |= UTS_LOOP;\n\t\timx_uart_writel(sport, uts, imx_uart_uts_reg(sport));\n\t\tucr2 |= UCR2_RXEN;\n\t} else {\n\t\tucr2 &= ~UCR2_RXEN;\n\t}\n\n\timx_uart_writel(sport, ucr2, UCR2);\n}\n\n \nstatic void imx_uart_enable_ms(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\n\tmod_timer(&sport->timer, jiffies);\n\n\tmctrl_gpio_enable_ms(sport->gpios);\n}\n\nstatic void imx_uart_dma_tx(struct imx_port *sport);\n\n \nstatic inline void imx_uart_transmit_buffer(struct imx_port *sport)\n{\n\tstruct circ_buf *xmit = &sport->port.state->xmit;\n\n\tif (sport->port.x_char) {\n\t\t \n\t\timx_uart_writel(sport, sport->port.x_char, URTX0);\n\t\tsport->port.icount.tx++;\n\t\tsport->port.x_char = 0;\n\t\treturn;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port)) {\n\t\timx_uart_stop_tx(&sport->port);\n\t\treturn;\n\t}\n\n\tif (sport->dma_is_enabled) {\n\t\tu32 ucr1;\n\t\t \n\t\tucr1 = imx_uart_readl(sport, UCR1);\n\t\tucr1 &= ~UCR1_TRDYEN;\n\t\tif (sport->dma_is_txing) {\n\t\t\tucr1 |= UCR1_TXDMAEN;\n\t\t\timx_uart_writel(sport, ucr1, UCR1);\n\t\t} else {\n\t\t\timx_uart_writel(sport, ucr1, UCR1);\n\t\t\timx_uart_dma_tx(sport);\n\t\t}\n\n\t\treturn;\n\t}\n\n\twhile (!uart_circ_empty(xmit) &&\n\t       !(imx_uart_readl(sport, imx_uart_uts_reg(sport)) & UTS_TXFULL)) {\n\t\t \n\t\timx_uart_writel(sport, xmit->buf[xmit->tail], URTX0);\n\t\tuart_xmit_advance(&sport->port, 1);\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&sport->port);\n\n\tif (uart_circ_empty(xmit))\n\t\timx_uart_stop_tx(&sport->port);\n}\n\nstatic void imx_uart_dma_tx_callback(void *data)\n{\n\tstruct imx_port *sport = data;\n\tstruct scatterlist *sgl = &sport->tx_sgl[0];\n\tstruct circ_buf *xmit = &sport->port.state->xmit;\n\tunsigned long flags;\n\tu32 ucr1;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\tdma_unmap_sg(sport->port.dev, sgl, sport->dma_tx_nents, DMA_TO_DEVICE);\n\n\tucr1 = imx_uart_readl(sport, UCR1);\n\tucr1 &= ~UCR1_TXDMAEN;\n\timx_uart_writel(sport, ucr1, UCR1);\n\n\tuart_xmit_advance(&sport->port, sport->tx_bytes);\n\n\tdev_dbg(sport->port.dev, \"we finish the TX DMA.\\n\");\n\n\tsport->dma_is_txing = 0;\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&sport->port);\n\n\tif (!uart_circ_empty(xmit) && !uart_tx_stopped(&sport->port))\n\t\timx_uart_dma_tx(sport);\n\telse if (sport->port.rs485.flags & SER_RS485_ENABLED) {\n\t\tu32 ucr4 = imx_uart_readl(sport, UCR4);\n\t\tucr4 |= UCR4_TCEN;\n\t\timx_uart_writel(sport, ucr4, UCR4);\n\t}\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\n \nstatic void imx_uart_dma_tx(struct imx_port *sport)\n{\n\tstruct circ_buf *xmit = &sport->port.state->xmit;\n\tstruct scatterlist *sgl = sport->tx_sgl;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct dma_chan\t*chan = sport->dma_chan_tx;\n\tstruct device *dev = sport->port.dev;\n\tu32 ucr1, ucr4;\n\tint ret;\n\n\tif (sport->dma_is_txing)\n\t\treturn;\n\n\tucr4 = imx_uart_readl(sport, UCR4);\n\tucr4 &= ~UCR4_TCEN;\n\timx_uart_writel(sport, ucr4, UCR4);\n\n\tsport->tx_bytes = uart_circ_chars_pending(xmit);\n\n\tif (xmit->tail < xmit->head || xmit->head == 0) {\n\t\tsport->dma_tx_nents = 1;\n\t\tsg_init_one(sgl, xmit->buf + xmit->tail, sport->tx_bytes);\n\t} else {\n\t\tsport->dma_tx_nents = 2;\n\t\tsg_init_table(sgl, 2);\n\t\tsg_set_buf(sgl, xmit->buf + xmit->tail,\n\t\t\t\tUART_XMIT_SIZE - xmit->tail);\n\t\tsg_set_buf(sgl + 1, xmit->buf, xmit->head);\n\t}\n\n\tret = dma_map_sg(dev, sgl, sport->dma_tx_nents, DMA_TO_DEVICE);\n\tif (ret == 0) {\n\t\tdev_err(dev, \"DMA mapping error for TX.\\n\");\n\t\treturn;\n\t}\n\tdesc = dmaengine_prep_slave_sg(chan, sgl, ret,\n\t\t\t\t\tDMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);\n\tif (!desc) {\n\t\tdma_unmap_sg(dev, sgl, sport->dma_tx_nents,\n\t\t\t     DMA_TO_DEVICE);\n\t\tdev_err(dev, \"We cannot prepare for the TX slave dma!\\n\");\n\t\treturn;\n\t}\n\tdesc->callback = imx_uart_dma_tx_callback;\n\tdesc->callback_param = sport;\n\n\tdev_dbg(dev, \"TX: prepare to send %lu bytes by DMA.\\n\",\n\t\t\tuart_circ_chars_pending(xmit));\n\n\tucr1 = imx_uart_readl(sport, UCR1);\n\tucr1 |= UCR1_TXDMAEN;\n\timx_uart_writel(sport, ucr1, UCR1);\n\n\t \n\tsport->dma_is_txing = 1;\n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(chan);\n\treturn;\n}\n\n \nstatic void imx_uart_start_tx(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tu32 ucr1;\n\n\tif (!sport->port.x_char && uart_circ_empty(&port->state->xmit))\n\t\treturn;\n\n\t \n\n\tif (port->rs485.flags & SER_RS485_ENABLED) {\n\t\tif (sport->tx_state == OFF) {\n\t\t\tu32 ucr2 = imx_uart_readl(sport, UCR2);\n\t\t\tif (port->rs485.flags & SER_RS485_RTS_ON_SEND)\n\t\t\t\timx_uart_rts_active(sport, &ucr2);\n\t\t\telse\n\t\t\t\timx_uart_rts_inactive(sport, &ucr2);\n\t\t\timx_uart_writel(sport, ucr2, UCR2);\n\n\t\t\tif (!(port->rs485.flags & SER_RS485_RX_DURING_TX) &&\n\t\t\t    !port->rs485_rx_during_tx_gpio)\n\t\t\t\timx_uart_stop_rx(port);\n\n\t\t\tsport->tx_state = WAIT_AFTER_RTS;\n\n\t\t\tif (port->rs485.delay_rts_before_send > 0) {\n\t\t\t\tstart_hrtimer_ms(&sport->trigger_start_tx,\n\t\t\t\t\t port->rs485.delay_rts_before_send);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t}\n\n\t\tif (sport->tx_state == WAIT_AFTER_SEND\n\t\t    || sport->tx_state == WAIT_AFTER_RTS) {\n\n\t\t\thrtimer_try_to_cancel(&sport->trigger_stop_tx);\n\n\t\t\t \n\t\t\tif (!sport->dma_is_enabled) {\n\t\t\t\tu32 ucr4 = imx_uart_readl(sport, UCR4);\n\t\t\t\tucr4 |= UCR4_TCEN;\n\t\t\t\timx_uart_writel(sport, ucr4, UCR4);\n\t\t\t}\n\n\t\t\tsport->tx_state = SEND;\n\t\t}\n\t} else {\n\t\tsport->tx_state = SEND;\n\t}\n\n\tif (!sport->dma_is_enabled) {\n\t\tucr1 = imx_uart_readl(sport, UCR1);\n\t\timx_uart_writel(sport, ucr1 | UCR1_TRDYEN, UCR1);\n\t}\n\n\tif (sport->dma_is_enabled) {\n\t\tif (sport->port.x_char) {\n\t\t\t \n\t\t\tucr1 = imx_uart_readl(sport, UCR1);\n\t\t\tucr1 &= ~UCR1_TXDMAEN;\n\t\t\tucr1 |= UCR1_TRDYEN;\n\t\t\timx_uart_writel(sport, ucr1, UCR1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!uart_circ_empty(&port->state->xmit) &&\n\t\t    !uart_tx_stopped(port))\n\t\t\timx_uart_dma_tx(sport);\n\t\treturn;\n\t}\n}\n\nstatic irqreturn_t __imx_uart_rtsint(int irq, void *dev_id)\n{\n\tstruct imx_port *sport = dev_id;\n\tu32 usr1;\n\n\timx_uart_writel(sport, USR1_RTSD, USR1);\n\tusr1 = imx_uart_readl(sport, USR1) & USR1_RTSS;\n\tuart_handle_cts_change(&sport->port, usr1);\n\twake_up_interruptible(&sport->port.state->port.delta_msr_wait);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t imx_uart_rtsint(int irq, void *dev_id)\n{\n\tstruct imx_port *sport = dev_id;\n\tirqreturn_t ret;\n\n\tspin_lock(&sport->port.lock);\n\n\tret = __imx_uart_rtsint(irq, dev_id);\n\n\tspin_unlock(&sport->port.lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t imx_uart_txint(int irq, void *dev_id)\n{\n\tstruct imx_port *sport = dev_id;\n\n\tspin_lock(&sport->port.lock);\n\timx_uart_transmit_buffer(sport);\n\tspin_unlock(&sport->port.lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void imx_uart_check_flood(struct imx_port *sport, u32 usr2)\n{\n\t \n\n\tif (usr2 & USR2_WAKE) {\n\t\timx_uart_writel(sport, USR2_WAKE, USR2);\n\t\tsport->idle_counter = 0;\n\t} else if (++sport->idle_counter > 3) {\n\t\tdev_warn(sport->port.dev, \"RX flood detected: soft reset.\");\n\t\timx_uart_soft_reset(sport);  \n\t}\n}\n\nstatic irqreturn_t __imx_uart_rxint(int irq, void *dev_id)\n{\n\tstruct imx_port *sport = dev_id;\n\tstruct tty_port *port = &sport->port.state->port;\n\tu32 usr2, rx;\n\n\t \n\tusr2 = imx_uart_readl(sport, USR2);\n\tif (usr2 & USR2_RDR)\n\t\timx_uart_check_flood(sport, usr2);\n\n\twhile ((rx = imx_uart_readl(sport, URXD0)) & URXD_CHARRDY) {\n\t\tunsigned int flg = TTY_NORMAL;\n\t\tsport->port.icount.rx++;\n\n\t\tif (unlikely(rx & URXD_ERR)) {\n\t\t\tif (rx & URXD_BRK) {\n\t\t\t\tsport->port.icount.brk++;\n\t\t\t\tif (uart_handle_break(&sport->port))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (rx & URXD_PRERR)\n\t\t\t\tsport->port.icount.parity++;\n\t\t\telse if (rx & URXD_FRMERR)\n\t\t\t\tsport->port.icount.frame++;\n\t\t\tif (rx & URXD_OVRRUN)\n\t\t\t\tsport->port.icount.overrun++;\n\n\t\t\tif (rx & sport->port.ignore_status_mask)\n\t\t\t\tcontinue;\n\n\t\t\trx &= (sport->port.read_status_mask | 0xFF);\n\n\t\t\tif (rx & URXD_BRK)\n\t\t\t\tflg = TTY_BREAK;\n\t\t\telse if (rx & URXD_PRERR)\n\t\t\t\tflg = TTY_PARITY;\n\t\t\telse if (rx & URXD_FRMERR)\n\t\t\t\tflg = TTY_FRAME;\n\t\t\tif (rx & URXD_OVRRUN)\n\t\t\t\tflg = TTY_OVERRUN;\n\n\t\t\tsport->port.sysrq = 0;\n\t\t} else if (uart_handle_sysrq_char(&sport->port, (unsigned char)rx)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sport->port.ignore_status_mask & URXD_DUMMY_READ)\n\t\t\tcontinue;\n\n\t\tif (tty_insert_flip_char(port, rx, flg) == 0)\n\t\t\tsport->port.icount.buf_overrun++;\n\t}\n\n\ttty_flip_buffer_push(port);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t imx_uart_rxint(int irq, void *dev_id)\n{\n\tstruct imx_port *sport = dev_id;\n\tirqreturn_t ret;\n\n\tspin_lock(&sport->port.lock);\n\n\tret = __imx_uart_rxint(irq, dev_id);\n\n\tspin_unlock(&sport->port.lock);\n\n\treturn ret;\n}\n\nstatic void imx_uart_clear_rx_errors(struct imx_port *sport);\n\n \nstatic unsigned int imx_uart_get_hwmctrl(struct imx_port *sport)\n{\n\tunsigned int tmp = TIOCM_DSR;\n\tunsigned usr1 = imx_uart_readl(sport, USR1);\n\tunsigned usr2 = imx_uart_readl(sport, USR2);\n\n\tif (usr1 & USR1_RTSS)\n\t\ttmp |= TIOCM_CTS;\n\n\t \n\tif (!(usr2 & USR2_DCDIN))\n\t\ttmp |= TIOCM_CAR;\n\n\tif (sport->dte_mode)\n\t\tif (!(imx_uart_readl(sport, USR2) & USR2_RIIN))\n\t\t\ttmp |= TIOCM_RI;\n\n\treturn tmp;\n}\n\n \nstatic void imx_uart_mctrl_check(struct imx_port *sport)\n{\n\tunsigned int status, changed;\n\n\tstatus = imx_uart_get_hwmctrl(sport);\n\tchanged = status ^ sport->old_status;\n\n\tif (changed == 0)\n\t\treturn;\n\n\tsport->old_status = status;\n\n\tif (changed & TIOCM_RI && status & TIOCM_RI)\n\t\tsport->port.icount.rng++;\n\tif (changed & TIOCM_DSR)\n\t\tsport->port.icount.dsr++;\n\tif (changed & TIOCM_CAR)\n\t\tuart_handle_dcd_change(&sport->port, status & TIOCM_CAR);\n\tif (changed & TIOCM_CTS)\n\t\tuart_handle_cts_change(&sport->port, status & TIOCM_CTS);\n\n\twake_up_interruptible(&sport->port.state->port.delta_msr_wait);\n}\n\nstatic irqreturn_t imx_uart_int(int irq, void *dev_id)\n{\n\tstruct imx_port *sport = dev_id;\n\tunsigned int usr1, usr2, ucr1, ucr2, ucr3, ucr4;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tspin_lock(&sport->port.lock);\n\n\tusr1 = imx_uart_readl(sport, USR1);\n\tusr2 = imx_uart_readl(sport, USR2);\n\tucr1 = imx_uart_readl(sport, UCR1);\n\tucr2 = imx_uart_readl(sport, UCR2);\n\tucr3 = imx_uart_readl(sport, UCR3);\n\tucr4 = imx_uart_readl(sport, UCR4);\n\n\t \n\tif ((ucr1 & UCR1_RRDYEN) == 0)\n\t\tusr1 &= ~USR1_RRDY;\n\tif ((ucr2 & UCR2_ATEN) == 0)\n\t\tusr1 &= ~USR1_AGTIM;\n\tif ((ucr1 & UCR1_TRDYEN) == 0)\n\t\tusr1 &= ~USR1_TRDY;\n\tif ((ucr4 & UCR4_TCEN) == 0)\n\t\tusr2 &= ~USR2_TXDC;\n\tif ((ucr3 & UCR3_DTRDEN) == 0)\n\t\tusr1 &= ~USR1_DTRD;\n\tif ((ucr1 & UCR1_RTSDEN) == 0)\n\t\tusr1 &= ~USR1_RTSD;\n\tif ((ucr3 & UCR3_AWAKEN) == 0)\n\t\tusr1 &= ~USR1_AWAKE;\n\tif ((ucr4 & UCR4_OREN) == 0)\n\t\tusr2 &= ~USR2_ORE;\n\n\tif (usr1 & (USR1_RRDY | USR1_AGTIM)) {\n\t\timx_uart_writel(sport, USR1_AGTIM, USR1);\n\n\t\t__imx_uart_rxint(irq, dev_id);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif ((usr1 & USR1_TRDY) || (usr2 & USR2_TXDC)) {\n\t\timx_uart_transmit_buffer(sport);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (usr1 & USR1_DTRD) {\n\t\timx_uart_writel(sport, USR1_DTRD, USR1);\n\n\t\timx_uart_mctrl_check(sport);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (usr1 & USR1_RTSD) {\n\t\t__imx_uart_rtsint(irq, dev_id);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (usr1 & USR1_AWAKE) {\n\t\timx_uart_writel(sport, USR1_AWAKE, USR1);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (usr2 & USR2_ORE) {\n\t\tsport->port.icount.overrun++;\n\t\timx_uart_writel(sport, USR2_ORE, USR2);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tspin_unlock(&sport->port.lock);\n\n\treturn ret;\n}\n\n \nstatic unsigned int imx_uart_tx_empty(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tunsigned int ret;\n\n\tret = (imx_uart_readl(sport, USR2) & USR2_TXDC) ?  TIOCSER_TEMT : 0;\n\n\t \n\tif (sport->dma_is_txing)\n\t\tret = 0;\n\n\treturn ret;\n}\n\n \nstatic unsigned int imx_uart_get_mctrl(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tunsigned int ret = imx_uart_get_hwmctrl(sport);\n\n\tmctrl_gpio_get(sport->gpios, &ret);\n\n\treturn ret;\n}\n\n \nstatic void imx_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tu32 ucr3, uts;\n\n\tif (!(port->rs485.flags & SER_RS485_ENABLED)) {\n\t\tu32 ucr2;\n\n\t\t \n\t\tucr2 = imx_uart_readl(sport, UCR2);\n\t\tucr2 &= ~(UCR2_CTS | UCR2_CTSC);\n\t\tif (mctrl & TIOCM_RTS) {\n\t\t\tucr2 |= UCR2_CTS;\n\t\t\t \n\t\t\tif (!(ucr2 & UCR2_IRTS))\n\t\t\t\tucr2 |= UCR2_CTSC;\n\t\t}\n\t\timx_uart_writel(sport, ucr2, UCR2);\n\t}\n\n\tucr3 = imx_uart_readl(sport, UCR3) & ~UCR3_DSR;\n\tif (!(mctrl & TIOCM_DTR))\n\t\tucr3 |= UCR3_DSR;\n\timx_uart_writel(sport, ucr3, UCR3);\n\n\tuts = imx_uart_readl(sport, imx_uart_uts_reg(sport)) & ~UTS_LOOP;\n\tif (mctrl & TIOCM_LOOP)\n\t\tuts |= UTS_LOOP;\n\timx_uart_writel(sport, uts, imx_uart_uts_reg(sport));\n\n\tmctrl_gpio_set(sport->gpios, mctrl);\n}\n\n \nstatic void imx_uart_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tunsigned long flags;\n\tu32 ucr1;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\tucr1 = imx_uart_readl(sport, UCR1) & ~UCR1_SNDBRK;\n\n\tif (break_state != 0)\n\t\tucr1 |= UCR1_SNDBRK;\n\n\timx_uart_writel(sport, ucr1, UCR1);\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\n \nstatic void imx_uart_timeout(struct timer_list *t)\n{\n\tstruct imx_port *sport = from_timer(sport, t, timer);\n\tunsigned long flags;\n\n\tif (sport->port.state) {\n\t\tspin_lock_irqsave(&sport->port.lock, flags);\n\t\timx_uart_mctrl_check(sport);\n\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\t\tmod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);\n\t}\n}\n\n \nstatic void imx_uart_dma_rx_callback(void *data)\n{\n\tstruct imx_port *sport = data;\n\tstruct dma_chan\t*chan = sport->dma_chan_rx;\n\tstruct scatterlist *sgl = &sport->rx_sgl;\n\tstruct tty_port *port = &sport->port.state->port;\n\tstruct dma_tx_state state;\n\tstruct circ_buf *rx_ring = &sport->rx_ring;\n\tenum dma_status status;\n\tunsigned int w_bytes = 0;\n\tunsigned int r_bytes;\n\tunsigned int bd_size;\n\n\tstatus = dmaengine_tx_status(chan, sport->rx_cookie, &state);\n\n\tif (status == DMA_ERROR) {\n\t\tspin_lock(&sport->port.lock);\n\t\timx_uart_clear_rx_errors(sport);\n\t\tspin_unlock(&sport->port.lock);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\trx_ring->head = sg_dma_len(sgl) - state.residue;\n\n\t \n\tbd_size = sg_dma_len(sgl) / sport->rx_periods;\n\trx_ring->tail = ((rx_ring->head-1) / bd_size) * bd_size;\n\n\tif (rx_ring->head <= sg_dma_len(sgl) &&\n\t    rx_ring->head > rx_ring->tail) {\n\n\t\t \n\t\tr_bytes = rx_ring->head - rx_ring->tail;\n\n\t\t \n\t\tspin_lock(&sport->port.lock);\n\t\timx_uart_check_flood(sport, imx_uart_readl(sport, USR2));\n\t\tspin_unlock(&sport->port.lock);\n\n\t\tif (!(sport->port.ignore_status_mask & URXD_DUMMY_READ)) {\n\n\t\t\t \n\t\t\tdma_sync_sg_for_cpu(sport->port.dev, sgl, 1,\n\t\t\t\t\t    DMA_FROM_DEVICE);\n\n\t\t\tw_bytes = tty_insert_flip_string(port,\n\t\t\t\t\t\t\t sport->rx_buf + rx_ring->tail, r_bytes);\n\n\t\t\t \n\t\t\tdma_sync_sg_for_device(sport->port.dev, sgl, 1,\n\t\t\t\t\t       DMA_FROM_DEVICE);\n\n\t\t\tif (w_bytes != r_bytes)\n\t\t\t\tsport->port.icount.buf_overrun++;\n\n\t\t\tsport->port.icount.rx += w_bytes;\n\t\t}\n\t} else\t{\n\t\tWARN_ON(rx_ring->head > sg_dma_len(sgl));\n\t\tWARN_ON(rx_ring->head <= rx_ring->tail);\n\t}\n\n\tif (w_bytes) {\n\t\ttty_flip_buffer_push(port);\n\t\tdev_dbg(sport->port.dev, \"We get %d bytes.\\n\", w_bytes);\n\t}\n}\n\nstatic int imx_uart_start_rx_dma(struct imx_port *sport)\n{\n\tstruct scatterlist *sgl = &sport->rx_sgl;\n\tstruct dma_chan\t*chan = sport->dma_chan_rx;\n\tstruct device *dev = sport->port.dev;\n\tstruct dma_async_tx_descriptor *desc;\n\tint ret;\n\n\tsport->rx_ring.head = 0;\n\tsport->rx_ring.tail = 0;\n\n\tsg_init_one(sgl, sport->rx_buf, sport->rx_buf_size);\n\tret = dma_map_sg(dev, sgl, 1, DMA_FROM_DEVICE);\n\tif (ret == 0) {\n\t\tdev_err(dev, \"DMA mapping error for RX.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdesc = dmaengine_prep_dma_cyclic(chan, sg_dma_address(sgl),\n\t\tsg_dma_len(sgl), sg_dma_len(sgl) / sport->rx_periods,\n\t\tDMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);\n\n\tif (!desc) {\n\t\tdma_unmap_sg(dev, sgl, 1, DMA_FROM_DEVICE);\n\t\tdev_err(dev, \"We cannot prepare for the RX slave dma!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdesc->callback = imx_uart_dma_rx_callback;\n\tdesc->callback_param = sport;\n\n\tdev_dbg(dev, \"RX: prepare for the DMA.\\n\");\n\tsport->dma_is_rxing = 1;\n\tsport->rx_cookie = dmaengine_submit(desc);\n\tdma_async_issue_pending(chan);\n\treturn 0;\n}\n\nstatic void imx_uart_clear_rx_errors(struct imx_port *sport)\n{\n\tstruct tty_port *port = &sport->port.state->port;\n\tu32 usr1, usr2;\n\n\tusr1 = imx_uart_readl(sport, USR1);\n\tusr2 = imx_uart_readl(sport, USR2);\n\n\tif (usr2 & USR2_BRCD) {\n\t\tsport->port.icount.brk++;\n\t\timx_uart_writel(sport, USR2_BRCD, USR2);\n\t\tuart_handle_break(&sport->port);\n\t\tif (tty_insert_flip_char(port, 0, TTY_BREAK) == 0)\n\t\t\tsport->port.icount.buf_overrun++;\n\t\ttty_flip_buffer_push(port);\n\t} else {\n\t\tif (usr1 & USR1_FRAMERR) {\n\t\t\tsport->port.icount.frame++;\n\t\t\timx_uart_writel(sport, USR1_FRAMERR, USR1);\n\t\t} else if (usr1 & USR1_PARITYERR) {\n\t\t\tsport->port.icount.parity++;\n\t\t\timx_uart_writel(sport, USR1_PARITYERR, USR1);\n\t\t}\n\t}\n\n\tif (usr2 & USR2_ORE) {\n\t\tsport->port.icount.overrun++;\n\t\timx_uart_writel(sport, USR2_ORE, USR2);\n\t}\n\n\tsport->idle_counter = 0;\n\n}\n\n#define TXTL_DEFAULT 2  \n#define RXTL_DEFAULT 8  \n#define TXTL_DMA 8  \n#define RXTL_DMA 9  \n\nstatic void imx_uart_setup_ufcr(struct imx_port *sport,\n\t\t\t\tunsigned char txwl, unsigned char rxwl)\n{\n\tunsigned int val;\n\n\t \n\tval = imx_uart_readl(sport, UFCR) & (UFCR_RFDIV | UFCR_DCEDTE);\n\tval |= txwl << UFCR_TXTL_SHF | rxwl;\n\timx_uart_writel(sport, val, UFCR);\n}\n\nstatic void imx_uart_dma_exit(struct imx_port *sport)\n{\n\tif (sport->dma_chan_rx) {\n\t\tdmaengine_terminate_sync(sport->dma_chan_rx);\n\t\tdma_release_channel(sport->dma_chan_rx);\n\t\tsport->dma_chan_rx = NULL;\n\t\tsport->rx_cookie = -EINVAL;\n\t\tkfree(sport->rx_buf);\n\t\tsport->rx_buf = NULL;\n\t}\n\n\tif (sport->dma_chan_tx) {\n\t\tdmaengine_terminate_sync(sport->dma_chan_tx);\n\t\tdma_release_channel(sport->dma_chan_tx);\n\t\tsport->dma_chan_tx = NULL;\n\t}\n}\n\nstatic int imx_uart_dma_init(struct imx_port *sport)\n{\n\tstruct dma_slave_config slave_config = {};\n\tstruct device *dev = sport->port.dev;\n\tint ret;\n\n\t \n\tsport->dma_chan_rx = dma_request_slave_channel(dev, \"rx\");\n\tif (!sport->dma_chan_rx) {\n\t\tdev_dbg(dev, \"cannot get the DMA channel.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tslave_config.direction = DMA_DEV_TO_MEM;\n\tslave_config.src_addr = sport->port.mapbase + URXD0;\n\tslave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t \n\tslave_config.src_maxburst = RXTL_DMA - 1;\n\tret = dmaengine_slave_config(sport->dma_chan_rx, &slave_config);\n\tif (ret) {\n\t\tdev_err(dev, \"error in RX dma configuration.\\n\");\n\t\tgoto err;\n\t}\n\n\tsport->rx_buf_size = sport->rx_period_length * sport->rx_periods;\n\tsport->rx_buf = kzalloc(sport->rx_buf_size, GFP_KERNEL);\n\tif (!sport->rx_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tsport->rx_ring.buf = sport->rx_buf;\n\n\t \n\tsport->dma_chan_tx = dma_request_slave_channel(dev, \"tx\");\n\tif (!sport->dma_chan_tx) {\n\t\tdev_err(dev, \"cannot get the TX DMA channel!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tslave_config.direction = DMA_MEM_TO_DEV;\n\tslave_config.dst_addr = sport->port.mapbase + URTX0;\n\tslave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tslave_config.dst_maxburst = TXTL_DMA;\n\tret = dmaengine_slave_config(sport->dma_chan_tx, &slave_config);\n\tif (ret) {\n\t\tdev_err(dev, \"error in TX dma configuration.\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\timx_uart_dma_exit(sport);\n\treturn ret;\n}\n\nstatic void imx_uart_enable_dma(struct imx_port *sport)\n{\n\tu32 ucr1;\n\n\timx_uart_setup_ufcr(sport, TXTL_DMA, RXTL_DMA);\n\n\t \n\tucr1 = imx_uart_readl(sport, UCR1);\n\tucr1 |= UCR1_RXDMAEN | UCR1_TXDMAEN | UCR1_ATDMAEN;\n\timx_uart_writel(sport, ucr1, UCR1);\n\n\tsport->dma_is_enabled = 1;\n}\n\nstatic void imx_uart_disable_dma(struct imx_port *sport)\n{\n\tu32 ucr1;\n\n\t \n\tucr1 = imx_uart_readl(sport, UCR1);\n\tucr1 &= ~(UCR1_RXDMAEN | UCR1_TXDMAEN | UCR1_ATDMAEN);\n\timx_uart_writel(sport, ucr1, UCR1);\n\n\timx_uart_setup_ufcr(sport, TXTL_DEFAULT, RXTL_DEFAULT);\n\n\tsport->dma_is_enabled = 0;\n}\n\n \n#define CTSTL 16\n\nstatic int imx_uart_startup(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tint retval;\n\tunsigned long flags;\n\tint dma_is_inited = 0;\n\tu32 ucr1, ucr2, ucr3, ucr4;\n\n\tretval = clk_prepare_enable(sport->clk_per);\n\tif (retval)\n\t\treturn retval;\n\tretval = clk_prepare_enable(sport->clk_ipg);\n\tif (retval) {\n\t\tclk_disable_unprepare(sport->clk_per);\n\t\treturn retval;\n\t}\n\n\timx_uart_setup_ufcr(sport, TXTL_DEFAULT, RXTL_DEFAULT);\n\n\t \n\tucr4 = imx_uart_readl(sport, UCR4);\n\n\t \n\tucr4 &= ~(UCR4_CTSTL_MASK << UCR4_CTSTL_SHF);\n\tucr4 |= CTSTL << UCR4_CTSTL_SHF;\n\n\timx_uart_writel(sport, ucr4 & ~UCR4_DREN, UCR4);\n\n\t \n\tif (!uart_console(port) && imx_uart_dma_init(sport) == 0)\n\t\tdma_is_inited = 1;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\t \n\timx_uart_soft_reset(sport);\n\n\t \n\timx_uart_writel(sport, USR1_RTSD | USR1_DTRD, USR1);\n\timx_uart_writel(sport, USR2_ORE, USR2);\n\n\tucr1 = imx_uart_readl(sport, UCR1) & ~UCR1_RRDYEN;\n\tucr1 |= UCR1_UARTEN;\n\tif (sport->have_rtscts)\n\t\tucr1 |= UCR1_RTSDEN;\n\n\timx_uart_writel(sport, ucr1, UCR1);\n\n\tucr4 = imx_uart_readl(sport, UCR4) & ~(UCR4_OREN | UCR4_INVR);\n\tif (!dma_is_inited)\n\t\tucr4 |= UCR4_OREN;\n\tif (sport->inverted_rx)\n\t\tucr4 |= UCR4_INVR;\n\timx_uart_writel(sport, ucr4, UCR4);\n\n\tucr3 = imx_uart_readl(sport, UCR3) & ~UCR3_INVT;\n\t \n\tif (sport->inverted_tx)\n\t\tucr3 |= UCR3_INVT;\n\n\tif (!imx_uart_is_imx1(sport)) {\n\t\tucr3 |= UCR3_DTRDEN | UCR3_RI | UCR3_DCD;\n\n\t\tif (sport->dte_mode)\n\t\t\t \n\t\t\tucr3 &= ~(UCR3_RI | UCR3_DCD);\n\t}\n\timx_uart_writel(sport, ucr3, UCR3);\n\n\tucr2 = imx_uart_readl(sport, UCR2) & ~UCR2_ATEN;\n\tucr2 |= (UCR2_RXEN | UCR2_TXEN);\n\tif (!sport->have_rtscts)\n\t\tucr2 |= UCR2_IRTS;\n\t \n\tif (!imx_uart_is_imx1(sport))\n\t\tucr2 &= ~UCR2_RTSEN;\n\timx_uart_writel(sport, ucr2, UCR2);\n\n\t \n\timx_uart_enable_ms(&sport->port);\n\n\tif (dma_is_inited) {\n\t\timx_uart_enable_dma(sport);\n\t\timx_uart_start_rx_dma(sport);\n\t} else {\n\t\tucr1 = imx_uart_readl(sport, UCR1);\n\t\tucr1 |= UCR1_RRDYEN;\n\t\timx_uart_writel(sport, ucr1, UCR1);\n\n\t\tucr2 = imx_uart_readl(sport, UCR2);\n\t\tucr2 |= UCR2_ATEN;\n\t\timx_uart_writel(sport, ucr2, UCR2);\n\t}\n\n\timx_uart_disable_loopback_rs485(sport);\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\treturn 0;\n}\n\nstatic void imx_uart_shutdown(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tunsigned long flags;\n\tu32 ucr1, ucr2, ucr4, uts;\n\n\tif (sport->dma_is_enabled) {\n\t\tdmaengine_terminate_sync(sport->dma_chan_tx);\n\t\tif (sport->dma_is_txing) {\n\t\t\tdma_unmap_sg(sport->port.dev, &sport->tx_sgl[0],\n\t\t\t\t     sport->dma_tx_nents, DMA_TO_DEVICE);\n\t\t\tsport->dma_is_txing = 0;\n\t\t}\n\t\tdmaengine_terminate_sync(sport->dma_chan_rx);\n\t\tif (sport->dma_is_rxing) {\n\t\t\tdma_unmap_sg(sport->port.dev, &sport->rx_sgl,\n\t\t\t\t     1, DMA_FROM_DEVICE);\n\t\t\tsport->dma_is_rxing = 0;\n\t\t}\n\n\t\tspin_lock_irqsave(&sport->port.lock, flags);\n\t\timx_uart_stop_tx(port);\n\t\timx_uart_stop_rx(port);\n\t\timx_uart_disable_dma(sport);\n\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\t\timx_uart_dma_exit(sport);\n\t}\n\n\tmctrl_gpio_disable_ms(sport->gpios);\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\tucr2 = imx_uart_readl(sport, UCR2);\n\tucr2 &= ~(UCR2_TXEN | UCR2_ATEN);\n\timx_uart_writel(sport, ucr2, UCR2);\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\t \n\tdel_timer_sync(&sport->timer);\n\n\t \n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\tucr1 = imx_uart_readl(sport, UCR1);\n\tucr1 &= ~(UCR1_TRDYEN | UCR1_RRDYEN | UCR1_RTSDEN | UCR1_RXDMAEN |\n\t\t  UCR1_ATDMAEN | UCR1_SNDBRK);\n\t \n\tif (port->rs485.flags & SER_RS485_ENABLED &&\n\t    port->rs485.flags & SER_RS485_RTS_ON_SEND &&\n\t    sport->have_rtscts && !sport->have_rtsgpio) {\n\t\tuts = imx_uart_readl(sport, imx_uart_uts_reg(sport));\n\t\tuts |= UTS_LOOP;\n\t\timx_uart_writel(sport, uts, imx_uart_uts_reg(sport));\n\t\tucr1 |= UCR1_UARTEN;\n\t} else {\n\t\tucr1 &= ~UCR1_UARTEN;\n\t}\n\timx_uart_writel(sport, ucr1, UCR1);\n\n\tucr4 = imx_uart_readl(sport, UCR4);\n\tucr4 &= ~UCR4_TCEN;\n\timx_uart_writel(sport, ucr4, UCR4);\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\tclk_disable_unprepare(sport->clk_per);\n\tclk_disable_unprepare(sport->clk_ipg);\n}\n\n \nstatic void imx_uart_flush_buffer(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tstruct scatterlist *sgl = &sport->tx_sgl[0];\n\n\tif (!sport->dma_chan_tx)\n\t\treturn;\n\n\tsport->tx_bytes = 0;\n\tdmaengine_terminate_all(sport->dma_chan_tx);\n\tif (sport->dma_is_txing) {\n\t\tu32 ucr1;\n\n\t\tdma_unmap_sg(sport->port.dev, sgl, sport->dma_tx_nents,\n\t\t\t     DMA_TO_DEVICE);\n\t\tucr1 = imx_uart_readl(sport, UCR1);\n\t\tucr1 &= ~UCR1_TXDMAEN;\n\t\timx_uart_writel(sport, ucr1, UCR1);\n\t\tsport->dma_is_txing = 0;\n\t}\n\n\timx_uart_soft_reset(sport);\n\n}\n\nstatic void\nimx_uart_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t     const struct ktermios *old)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tunsigned long flags;\n\tu32 ucr2, old_ucr2, ufcr;\n\tunsigned int baud, quot;\n\tunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\n\tunsigned long div;\n\tunsigned long num, denom, old_ubir, old_ubmr;\n\tuint64_t tdiv64;\n\n\t \n\twhile ((termios->c_cflag & CSIZE) != CS7 &&\n\t       (termios->c_cflag & CSIZE) != CS8) {\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= old_csize;\n\t\told_csize = CS8;\n\t}\n\n\tdel_timer_sync(&sport->timer);\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 50, port->uartclk / 16);\n\tquot = uart_get_divisor(port, baud);\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\t \n\told_ucr2 = imx_uart_readl(sport, UCR2);\n\tucr2 = old_ucr2 & (UCR2_TXEN | UCR2_RXEN | UCR2_ATEN | UCR2_CTS);\n\n\tucr2 |= UCR2_SRST | UCR2_IRTS;\n\tif ((termios->c_cflag & CSIZE) == CS8)\n\t\tucr2 |= UCR2_WS;\n\n\tif (!sport->have_rtscts)\n\t\ttermios->c_cflag &= ~CRTSCTS;\n\n\tif (port->rs485.flags & SER_RS485_ENABLED) {\n\t\t \n\t\tif (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)\n\t\t\timx_uart_rts_active(sport, &ucr2);\n\t\telse\n\t\t\timx_uart_rts_inactive(sport, &ucr2);\n\n\t} else if (termios->c_cflag & CRTSCTS) {\n\t\t \n\t\tif (ucr2 & UCR2_CTS)\n\t\t\tucr2 |= UCR2_CTSC;\n\t}\n\n\tif (termios->c_cflag & CRTSCTS)\n\t\tucr2 &= ~UCR2_IRTS;\n\tif (termios->c_cflag & CSTOPB)\n\t\tucr2 |= UCR2_STPB;\n\tif (termios->c_cflag & PARENB) {\n\t\tucr2 |= UCR2_PREN;\n\t\tif (termios->c_cflag & PARODD)\n\t\t\tucr2 |= UCR2_PROE;\n\t}\n\n\tsport->port.read_status_mask = 0;\n\tif (termios->c_iflag & INPCK)\n\t\tsport->port.read_status_mask |= (URXD_FRMERR | URXD_PRERR);\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tsport->port.read_status_mask |= URXD_BRK;\n\n\t \n\tsport->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tsport->port.ignore_status_mask |= URXD_PRERR | URXD_FRMERR;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tsport->port.ignore_status_mask |= URXD_BRK;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tsport->port.ignore_status_mask |= URXD_OVRRUN;\n\t}\n\n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tsport->port.ignore_status_mask |= URXD_DUMMY_READ;\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tdiv = sport->port.uartclk / (baud * 16);\n\tif (baud == 38400 && quot != div)\n\t\tbaud = sport->port.uartclk / (quot * 16);\n\n\tdiv = sport->port.uartclk / (baud * 16);\n\tif (div > 7)\n\t\tdiv = 7;\n\tif (!div)\n\t\tdiv = 1;\n\n\trational_best_approximation(16 * div * baud, sport->port.uartclk,\n\t\t1 << 16, 1 << 16, &num, &denom);\n\n\ttdiv64 = sport->port.uartclk;\n\ttdiv64 *= num;\n\tdo_div(tdiv64, denom * 16 * div);\n\ttty_termios_encode_baud_rate(termios,\n\t\t\t\t(speed_t)tdiv64, (speed_t)tdiv64);\n\n\tnum -= 1;\n\tdenom -= 1;\n\n\tufcr = imx_uart_readl(sport, UFCR);\n\tufcr = (ufcr & (~UFCR_RFDIV)) | UFCR_RFDIV_REG(div);\n\timx_uart_writel(sport, ufcr, UFCR);\n\n\t \n\told_ubir = imx_uart_readl(sport, UBIR);\n\told_ubmr = imx_uart_readl(sport, UBMR);\n\tif (old_ubir != num || old_ubmr != denom) {\n\t\timx_uart_writel(sport, num, UBIR);\n\t\timx_uart_writel(sport, denom, UBMR);\n\t}\n\n\tif (!imx_uart_is_imx1(sport))\n\t\timx_uart_writel(sport, sport->port.uartclk / div / 1000,\n\t\t\t\tIMX21_ONEMS);\n\n\timx_uart_writel(sport, ucr2, UCR2);\n\n\tif (UART_ENABLE_MS(&sport->port, termios->c_cflag))\n\t\timx_uart_enable_ms(&sport->port);\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\nstatic const char *imx_uart_type(struct uart_port *port)\n{\n\treturn port->type == PORT_IMX ? \"IMX\" : NULL;\n}\n\n \nstatic void imx_uart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_IMX;\n}\n\n \nstatic int\nimx_uart_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tint ret = 0;\n\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_IMX)\n\t\tret = -EINVAL;\n\tif (port->irq != ser->irq)\n\t\tret = -EINVAL;\n\tif (ser->io_type != UPIO_MEM)\n\t\tret = -EINVAL;\n\tif (port->uartclk / 16 != ser->baud_base)\n\t\tret = -EINVAL;\n\tif (port->mapbase != (unsigned long)ser->iomem_base)\n\t\tret = -EINVAL;\n\tif (port->iobase != ser->port)\n\t\tret = -EINVAL;\n\tif (ser->hub6 != 0)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\n#if defined(CONFIG_CONSOLE_POLL)\n\nstatic int imx_uart_poll_init(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tunsigned long flags;\n\tu32 ucr1, ucr2;\n\tint retval;\n\n\tretval = clk_prepare_enable(sport->clk_ipg);\n\tif (retval)\n\t\treturn retval;\n\tretval = clk_prepare_enable(sport->clk_per);\n\tif (retval)\n\t\tclk_disable_unprepare(sport->clk_ipg);\n\n\timx_uart_setup_ufcr(sport, TXTL_DEFAULT, RXTL_DEFAULT);\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\t \n\tucr1 = imx_uart_readl(sport, UCR1);\n\tucr2 = imx_uart_readl(sport, UCR2);\n\n\tif (imx_uart_is_imx1(sport))\n\t\tucr1 |= IMX1_UCR1_UARTCLKEN;\n\n\tucr1 |= UCR1_UARTEN;\n\tucr1 &= ~(UCR1_TRDYEN | UCR1_RTSDEN | UCR1_RRDYEN);\n\n\tucr2 |= UCR2_RXEN | UCR2_TXEN;\n\tucr2 &= ~UCR2_ATEN;\n\n\timx_uart_writel(sport, ucr1, UCR1);\n\timx_uart_writel(sport, ucr2, UCR2);\n\n\t \n\timx_uart_writel(sport, ucr1 | UCR1_RRDYEN, UCR1);\n\timx_uart_writel(sport, ucr2 | UCR2_ATEN, UCR2);\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\treturn 0;\n}\n\nstatic int imx_uart_poll_get_char(struct uart_port *port)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tif (!(imx_uart_readl(sport, USR2) & USR2_RDR))\n\t\treturn NO_POLL_CHAR;\n\n\treturn imx_uart_readl(sport, URXD0) & URXD_RX_DATA;\n}\n\nstatic void imx_uart_poll_put_char(struct uart_port *port, unsigned char c)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tunsigned int status;\n\n\t \n\tdo {\n\t\tstatus = imx_uart_readl(sport, USR1);\n\t} while (~status & USR1_TRDY);\n\n\t \n\timx_uart_writel(sport, c, URTX0);\n\n\t \n\tdo {\n\t\tstatus = imx_uart_readl(sport, USR2);\n\t} while (~status & USR2_TXDC);\n}\n#endif\n\n \nstatic int imx_uart_rs485_config(struct uart_port *port, struct ktermios *termios,\n\t\t\t\t struct serial_rs485 *rs485conf)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\tu32 ucr2;\n\n\tif (rs485conf->flags & SER_RS485_ENABLED) {\n\t\t \n\t\tif (sport->have_rtscts &&  !sport->have_rtsgpio &&\n\t\t    !(rs485conf->flags & SER_RS485_RTS_ON_SEND))\n\t\t\trs485conf->flags |= SER_RS485_RX_DURING_TX;\n\n\t\t \n\t\tucr2 = imx_uart_readl(sport, UCR2);\n\t\tif (rs485conf->flags & SER_RS485_RTS_AFTER_SEND)\n\t\t\timx_uart_rts_active(sport, &ucr2);\n\t\telse\n\t\t\timx_uart_rts_inactive(sport, &ucr2);\n\t\timx_uart_writel(sport, ucr2, UCR2);\n\t}\n\n\t \n\tif (!(rs485conf->flags & SER_RS485_ENABLED) ||\n\t    rs485conf->flags & SER_RS485_RX_DURING_TX)\n\t\timx_uart_start_rx(port);\n\n\tif (port->rs485_rx_during_tx_gpio)\n\t\tgpiod_set_value_cansleep(port->rs485_rx_during_tx_gpio,\n\t\t\t\t\t !!(rs485conf->flags & SER_RS485_RX_DURING_TX));\n\n\treturn 0;\n}\n\nstatic const struct uart_ops imx_uart_pops = {\n\t.tx_empty\t= imx_uart_tx_empty,\n\t.set_mctrl\t= imx_uart_set_mctrl,\n\t.get_mctrl\t= imx_uart_get_mctrl,\n\t.stop_tx\t= imx_uart_stop_tx,\n\t.start_tx\t= imx_uart_start_tx,\n\t.stop_rx\t= imx_uart_stop_rx,\n\t.enable_ms\t= imx_uart_enable_ms,\n\t.break_ctl\t= imx_uart_break_ctl,\n\t.startup\t= imx_uart_startup,\n\t.shutdown\t= imx_uart_shutdown,\n\t.flush_buffer\t= imx_uart_flush_buffer,\n\t.set_termios\t= imx_uart_set_termios,\n\t.type\t\t= imx_uart_type,\n\t.config_port\t= imx_uart_config_port,\n\t.verify_port\t= imx_uart_verify_port,\n#if defined(CONFIG_CONSOLE_POLL)\n\t.poll_init      = imx_uart_poll_init,\n\t.poll_get_char  = imx_uart_poll_get_char,\n\t.poll_put_char  = imx_uart_poll_put_char,\n#endif\n};\n\nstatic struct imx_port *imx_uart_ports[UART_NR];\n\n#if IS_ENABLED(CONFIG_SERIAL_IMX_CONSOLE)\nstatic void imx_uart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct imx_port *sport = (struct imx_port *)port;\n\n\twhile (imx_uart_readl(sport, imx_uart_uts_reg(sport)) & UTS_TXFULL)\n\t\tbarrier();\n\n\timx_uart_writel(sport, ch, URTX0);\n}\n\n \nstatic void\nimx_uart_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct imx_port *sport = imx_uart_ports[co->index];\n\tstruct imx_port_ucrs old_ucr;\n\tunsigned long flags;\n\tunsigned int ucr1;\n\tint locked = 1;\n\n\tif (sport->port.sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&sport->port.lock, flags);\n\telse\n\t\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\t \n\timx_uart_ucrs_save(sport, &old_ucr);\n\tucr1 = old_ucr.ucr1;\n\n\tif (imx_uart_is_imx1(sport))\n\t\tucr1 |= IMX1_UCR1_UARTCLKEN;\n\tucr1 |= UCR1_UARTEN;\n\tucr1 &= ~(UCR1_TRDYEN | UCR1_RRDYEN | UCR1_RTSDEN);\n\n\timx_uart_writel(sport, ucr1, UCR1);\n\n\timx_uart_writel(sport, old_ucr.ucr2 | UCR2_TXEN, UCR2);\n\n\tuart_console_write(&sport->port, s, count, imx_uart_console_putchar);\n\n\t \n\twhile (!(imx_uart_readl(sport, USR2) & USR2_TXDC));\n\n\timx_uart_ucrs_restore(sport, &old_ucr);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\n \nstatic void\nimx_uart_console_get_options(struct imx_port *sport, int *baud,\n\t\t\t     int *parity, int *bits)\n{\n\n\tif (imx_uart_readl(sport, UCR1) & UCR1_UARTEN) {\n\t\t \n\t\tunsigned int ucr2, ubir, ubmr, uartclk;\n\t\tunsigned int baud_raw;\n\t\tunsigned int ucfr_rfdiv;\n\n\t\tucr2 = imx_uart_readl(sport, UCR2);\n\n\t\t*parity = 'n';\n\t\tif (ucr2 & UCR2_PREN) {\n\t\t\tif (ucr2 & UCR2_PROE)\n\t\t\t\t*parity = 'o';\n\t\t\telse\n\t\t\t\t*parity = 'e';\n\t\t}\n\n\t\tif (ucr2 & UCR2_WS)\n\t\t\t*bits = 8;\n\t\telse\n\t\t\t*bits = 7;\n\n\t\tubir = imx_uart_readl(sport, UBIR) & 0xffff;\n\t\tubmr = imx_uart_readl(sport, UBMR) & 0xffff;\n\n\t\tucfr_rfdiv = (imx_uart_readl(sport, UFCR) & UFCR_RFDIV) >> 7;\n\t\tif (ucfr_rfdiv == 6)\n\t\t\tucfr_rfdiv = 7;\n\t\telse\n\t\t\tucfr_rfdiv = 6 - ucfr_rfdiv;\n\n\t\tuartclk = clk_get_rate(sport->clk_per);\n\t\tuartclk /= ucfr_rfdiv;\n\n\t\t{\t \n\t\t\tunsigned int mul = ubir + 1;\n\t\t\tunsigned int div = 16 * (ubmr + 1);\n\t\t\tunsigned int rem = uartclk % div;\n\n\t\t\tbaud_raw = (uartclk / div) * mul;\n\t\t\tbaud_raw += (rem * mul + div / 2) / div;\n\t\t\t*baud = (baud_raw + 50) / 100 * 100;\n\t\t}\n\n\t\tif (*baud != baud_raw)\n\t\t\tdev_info(sport->port.dev, \"Console IMX rounded baud rate from %d to %d\\n\",\n\t\t\t\tbaud_raw, *baud);\n\t}\n}\n\nstatic int\nimx_uart_console_setup(struct console *co, char *options)\n{\n\tstruct imx_port *sport;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint retval;\n\n\t \n\tif (co->index == -1 || co->index >= ARRAY_SIZE(imx_uart_ports))\n\t\tco->index = 0;\n\tsport = imx_uart_ports[co->index];\n\tif (sport == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tretval = clk_prepare_enable(sport->clk_ipg);\n\tif (retval)\n\t\tgoto error_console;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse\n\t\timx_uart_console_get_options(sport, &baud, &parity, &bits);\n\n\timx_uart_setup_ufcr(sport, TXTL_DEFAULT, RXTL_DEFAULT);\n\n\tretval = uart_set_options(&sport->port, co, baud, parity, bits, flow);\n\n\tif (retval) {\n\t\tclk_disable_unprepare(sport->clk_ipg);\n\t\tgoto error_console;\n\t}\n\n\tretval = clk_prepare_enable(sport->clk_per);\n\tif (retval)\n\t\tclk_disable_unprepare(sport->clk_ipg);\n\nerror_console:\n\treturn retval;\n}\n\nstatic int\nimx_uart_console_exit(struct console *co)\n{\n\tstruct imx_port *sport = imx_uart_ports[co->index];\n\n\tclk_disable_unprepare(sport->clk_per);\n\tclk_disable_unprepare(sport->clk_ipg);\n\n\treturn 0;\n}\n\nstatic struct uart_driver imx_uart_uart_driver;\nstatic struct console imx_uart_console = {\n\t.name\t\t= DEV_NAME,\n\t.write\t\t= imx_uart_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= imx_uart_console_setup,\n\t.exit\t\t= imx_uart_console_exit,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &imx_uart_uart_driver,\n};\n\n#define IMX_CONSOLE\t&imx_uart_console\n\n#else\n#define IMX_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver imx_uart_uart_driver = {\n\t.owner          = THIS_MODULE,\n\t.driver_name    = DRIVER_NAME,\n\t.dev_name       = DEV_NAME,\n\t.major          = SERIAL_IMX_MAJOR,\n\t.minor          = MINOR_START,\n\t.nr             = ARRAY_SIZE(imx_uart_ports),\n\t.cons           = IMX_CONSOLE,\n};\n\nstatic enum hrtimer_restart imx_trigger_start_tx(struct hrtimer *t)\n{\n\tstruct imx_port *sport = container_of(t, struct imx_port, trigger_start_tx);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\tif (sport->tx_state == WAIT_AFTER_RTS)\n\t\timx_uart_start_tx(&sport->port);\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic enum hrtimer_restart imx_trigger_stop_tx(struct hrtimer *t)\n{\n\tstruct imx_port *sport = container_of(t, struct imx_port, trigger_stop_tx);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\tif (sport->tx_state == WAIT_AFTER_SEND)\n\t\timx_uart_stop_tx(&sport->port);\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic const struct serial_rs485 imx_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | SER_RS485_RTS_AFTER_SEND |\n\t\t SER_RS485_RX_DURING_TX,\n\t.delay_rts_before_send = 1,\n\t.delay_rts_after_send = 1,\n};\n\n \n#define RX_DMA_PERIODS\t\t16\n#define RX_DMA_PERIOD_LEN\t(PAGE_SIZE / 4)\n\nstatic int imx_uart_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct imx_port *sport;\n\tvoid __iomem *base;\n\tu32 dma_buf_conf[2];\n\tint ret = 0;\n\tu32 ucr1, ucr2, uts;\n\tstruct resource *res;\n\tint txirq, rxirq, rtsirq;\n\n\tsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n\tif (!sport)\n\t\treturn -ENOMEM;\n\n\tsport->devdata = of_device_get_match_data(&pdev->dev);\n\n\tret = of_alias_get_id(np, \"serial\");\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias id, errno %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsport->port.line = ret;\n\n\tsport->have_rtscts = of_property_read_bool(np, \"uart-has-rtscts\") ||\n\t\tof_property_read_bool(np, \"fsl,uart-has-rtscts\");  \n\n\tsport->dte_mode = of_property_read_bool(np, \"fsl,dte-mode\");\n\n\tsport->have_rtsgpio = of_property_present(np, \"rts-gpios\");\n\n\tsport->inverted_tx = of_property_read_bool(np, \"fsl,inverted-tx\");\n\n\tsport->inverted_rx = of_property_read_bool(np, \"fsl,inverted-rx\");\n\n\tif (!of_property_read_u32_array(np, \"fsl,dma-info\", dma_buf_conf, 2)) {\n\t\tsport->rx_period_length = dma_buf_conf[0];\n\t\tsport->rx_periods = dma_buf_conf[1];\n\t} else {\n\t\tsport->rx_period_length = RX_DMA_PERIOD_LEN;\n\t\tsport->rx_periods = RX_DMA_PERIODS;\n\t}\n\n\tif (sport->port.line >= ARRAY_SIZE(imx_uart_ports)) {\n\t\tdev_err(&pdev->dev, \"serial%d out of range\\n\",\n\t\t\tsport->port.line);\n\t\treturn -EINVAL;\n\t}\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\trxirq = platform_get_irq(pdev, 0);\n\tif (rxirq < 0)\n\t\treturn rxirq;\n\ttxirq = platform_get_irq_optional(pdev, 1);\n\trtsirq = platform_get_irq_optional(pdev, 2);\n\n\tsport->port.dev = &pdev->dev;\n\tsport->port.mapbase = res->start;\n\tsport->port.membase = base;\n\tsport->port.type = PORT_IMX;\n\tsport->port.iotype = UPIO_MEM;\n\tsport->port.irq = rxirq;\n\tsport->port.fifosize = 32;\n\tsport->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_IMX_CONSOLE);\n\tsport->port.ops = &imx_uart_pops;\n\tsport->port.rs485_config = imx_uart_rs485_config;\n\t \n\tif (sport->have_rtscts || sport->have_rtsgpio)\n\t\tsport->port.rs485_supported = imx_rs485_supported;\n\tsport->port.flags = UPF_BOOT_AUTOCONF;\n\ttimer_setup(&sport->timer, imx_uart_timeout, 0);\n\n\tsport->gpios = mctrl_gpio_init(&sport->port, 0);\n\tif (IS_ERR(sport->gpios))\n\t\treturn PTR_ERR(sport->gpios);\n\n\tsport->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(sport->clk_ipg)) {\n\t\tret = PTR_ERR(sport->clk_ipg);\n\t\tdev_err(&pdev->dev, \"failed to get ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsport->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(sport->clk_per)) {\n\t\tret = PTR_ERR(sport->clk_per);\n\t\tdev_err(&pdev->dev, \"failed to get per clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsport->port.uartclk = clk_get_rate(sport->clk_per);\n\n\t \n\tret = clk_prepare_enable(sport->clk_ipg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = uart_get_rs485_mode(&sport->port);\n\tif (ret)\n\t\tgoto err_clk;\n\n\t \n\tif (sport->port.rs485.flags & SER_RS485_ENABLED &&\n\t    sport->have_rtscts && !sport->have_rtsgpio &&\n\t    (!(sport->port.rs485.flags & SER_RS485_RTS_ON_SEND) &&\n\t     !(sport->port.rs485.flags & SER_RS485_RX_DURING_TX)))\n\t\tdev_err(&pdev->dev,\n\t\t\t\"low-active RTS not possible when receiver is off, enabling receiver\\n\");\n\n\t \n\tucr1 = imx_uart_readl(sport, UCR1);\n\tucr1 &= ~(UCR1_ADEN | UCR1_TRDYEN | UCR1_IDEN | UCR1_RRDYEN | UCR1_RTSDEN);\n\timx_uart_writel(sport, ucr1, UCR1);\n\n\t \n\tucr2 = imx_uart_readl(sport, UCR2);\n\tucr2 &= ~UCR2_ATEN;\n\timx_uart_writel(sport, ucr2, UCR2);\n\n\t \n\tif (sport->port.rs485.flags & SER_RS485_ENABLED &&\n\t    sport->have_rtscts && !sport->have_rtsgpio) {\n\t\tuts = imx_uart_readl(sport, imx_uart_uts_reg(sport));\n\t\tuts |= UTS_LOOP;\n\t\timx_uart_writel(sport, uts, imx_uart_uts_reg(sport));\n\n\t\tucr1 = imx_uart_readl(sport, UCR1);\n\t\tucr1 |= UCR1_UARTEN;\n\t\timx_uart_writel(sport, ucr1, UCR1);\n\n\t\tucr2 = imx_uart_readl(sport, UCR2);\n\t\tucr2 |= UCR2_RXEN;\n\t\timx_uart_writel(sport, ucr2, UCR2);\n\t}\n\n\tif (!imx_uart_is_imx1(sport) && sport->dte_mode) {\n\t\t \n\t\tu32 ufcr = imx_uart_readl(sport, UFCR);\n\t\tif (!(ufcr & UFCR_DCEDTE))\n\t\t\timx_uart_writel(sport, ufcr | UFCR_DCEDTE, UFCR);\n\n\t\t \n\t\timx_uart_writel(sport,\n\t\t\t\tIMX21_UCR3_RXDMUXSEL | UCR3_ADNIMP | UCR3_DSR,\n\t\t\t\tUCR3);\n\n\t} else {\n\t\tu32 ucr3 = UCR3_DSR;\n\t\tu32 ufcr = imx_uart_readl(sport, UFCR);\n\t\tif (ufcr & UFCR_DCEDTE)\n\t\t\timx_uart_writel(sport, ufcr & ~UFCR_DCEDTE, UFCR);\n\n\t\tif (!imx_uart_is_imx1(sport))\n\t\t\tucr3 |= IMX21_UCR3_RXDMUXSEL | UCR3_ADNIMP;\n\t\timx_uart_writel(sport, ucr3, UCR3);\n\t}\n\n\thrtimer_init(&sport->trigger_start_tx, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thrtimer_init(&sport->trigger_stop_tx, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsport->trigger_start_tx.function = imx_trigger_start_tx;\n\tsport->trigger_stop_tx.function = imx_trigger_stop_tx;\n\n\t \n\tif (txirq > 0) {\n\t\tret = devm_request_irq(&pdev->dev, rxirq, imx_uart_rxint, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to request rx irq: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_clk;\n\t\t}\n\n\t\tret = devm_request_irq(&pdev->dev, txirq, imx_uart_txint, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to request tx irq: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_clk;\n\t\t}\n\n\t\tret = devm_request_irq(&pdev->dev, rtsirq, imx_uart_rtsint, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to request rts irq: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_clk;\n\t\t}\n\t} else {\n\t\tret = devm_request_irq(&pdev->dev, rxirq, imx_uart_int, 0,\n\t\t\t\t       dev_name(&pdev->dev), sport);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to request irq: %d\\n\", ret);\n\t\t\tgoto err_clk;\n\t\t}\n\t}\n\n\timx_uart_ports[sport->port.line] = sport;\n\n\tplatform_set_drvdata(pdev, sport);\n\n\tret = uart_add_one_port(&imx_uart_uart_driver, &sport->port);\n\nerr_clk:\n\tclk_disable_unprepare(sport->clk_ipg);\n\n\treturn ret;\n}\n\nstatic int imx_uart_remove(struct platform_device *pdev)\n{\n\tstruct imx_port *sport = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&imx_uart_uart_driver, &sport->port);\n\n\treturn 0;\n}\n\nstatic void imx_uart_restore_context(struct imx_port *sport)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\tif (!sport->context_saved) {\n\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\t\treturn;\n\t}\n\n\timx_uart_writel(sport, sport->saved_reg[4], UFCR);\n\timx_uart_writel(sport, sport->saved_reg[5], UESC);\n\timx_uart_writel(sport, sport->saved_reg[6], UTIM);\n\timx_uart_writel(sport, sport->saved_reg[7], UBIR);\n\timx_uart_writel(sport, sport->saved_reg[8], UBMR);\n\timx_uart_writel(sport, sport->saved_reg[9], IMX21_UTS);\n\timx_uart_writel(sport, sport->saved_reg[0], UCR1);\n\timx_uart_writel(sport, sport->saved_reg[1] | UCR2_SRST, UCR2);\n\timx_uart_writel(sport, sport->saved_reg[2], UCR3);\n\timx_uart_writel(sport, sport->saved_reg[3], UCR4);\n\tsport->context_saved = false;\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\nstatic void imx_uart_save_context(struct imx_port *sport)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&sport->port.lock, flags);\n\tsport->saved_reg[0] = imx_uart_readl(sport, UCR1);\n\tsport->saved_reg[1] = imx_uart_readl(sport, UCR2);\n\tsport->saved_reg[2] = imx_uart_readl(sport, UCR3);\n\tsport->saved_reg[3] = imx_uart_readl(sport, UCR4);\n\tsport->saved_reg[4] = imx_uart_readl(sport, UFCR);\n\tsport->saved_reg[5] = imx_uart_readl(sport, UESC);\n\tsport->saved_reg[6] = imx_uart_readl(sport, UTIM);\n\tsport->saved_reg[7] = imx_uart_readl(sport, UBIR);\n\tsport->saved_reg[8] = imx_uart_readl(sport, UBMR);\n\tsport->saved_reg[9] = imx_uart_readl(sport, IMX21_UTS);\n\tsport->context_saved = true;\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\nstatic void imx_uart_enable_wakeup(struct imx_port *sport, bool on)\n{\n\tu32 ucr3;\n\n\tucr3 = imx_uart_readl(sport, UCR3);\n\tif (on) {\n\t\timx_uart_writel(sport, USR1_AWAKE, USR1);\n\t\tucr3 |= UCR3_AWAKEN;\n\t} else {\n\t\tucr3 &= ~UCR3_AWAKEN;\n\t}\n\timx_uart_writel(sport, ucr3, UCR3);\n\n\tif (sport->have_rtscts) {\n\t\tu32 ucr1 = imx_uart_readl(sport, UCR1);\n\t\tif (on) {\n\t\t\timx_uart_writel(sport, USR1_RTSD, USR1);\n\t\t\tucr1 |= UCR1_RTSDEN;\n\t\t} else {\n\t\t\tucr1 &= ~UCR1_RTSDEN;\n\t\t}\n\t\timx_uart_writel(sport, ucr1, UCR1);\n\t}\n}\n\nstatic int imx_uart_suspend_noirq(struct device *dev)\n{\n\tstruct imx_port *sport = dev_get_drvdata(dev);\n\n\timx_uart_save_context(sport);\n\n\tclk_disable(sport->clk_ipg);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int imx_uart_resume_noirq(struct device *dev)\n{\n\tstruct imx_port *sport = dev_get_drvdata(dev);\n\tint ret;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tret = clk_enable(sport->clk_ipg);\n\tif (ret)\n\t\treturn ret;\n\n\timx_uart_restore_context(sport);\n\n\treturn 0;\n}\n\nstatic int imx_uart_suspend(struct device *dev)\n{\n\tstruct imx_port *sport = dev_get_drvdata(dev);\n\tint ret;\n\n\tuart_suspend_port(&imx_uart_uart_driver, &sport->port);\n\tdisable_irq(sport->port.irq);\n\n\tret = clk_prepare_enable(sport->clk_ipg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\timx_uart_enable_wakeup(sport, true);\n\n\treturn 0;\n}\n\nstatic int imx_uart_resume(struct device *dev)\n{\n\tstruct imx_port *sport = dev_get_drvdata(dev);\n\n\t \n\timx_uart_enable_wakeup(sport, false);\n\n\tuart_resume_port(&imx_uart_uart_driver, &sport->port);\n\tenable_irq(sport->port.irq);\n\n\tclk_disable_unprepare(sport->clk_ipg);\n\n\treturn 0;\n}\n\nstatic int imx_uart_freeze(struct device *dev)\n{\n\tstruct imx_port *sport = dev_get_drvdata(dev);\n\n\tuart_suspend_port(&imx_uart_uart_driver, &sport->port);\n\n\treturn clk_prepare_enable(sport->clk_ipg);\n}\n\nstatic int imx_uart_thaw(struct device *dev)\n{\n\tstruct imx_port *sport = dev_get_drvdata(dev);\n\n\tuart_resume_port(&imx_uart_uart_driver, &sport->port);\n\n\tclk_disable_unprepare(sport->clk_ipg);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops imx_uart_pm_ops = {\n\t.suspend_noirq = imx_uart_suspend_noirq,\n\t.resume_noirq = imx_uart_resume_noirq,\n\t.freeze_noirq = imx_uart_suspend_noirq,\n\t.thaw_noirq = imx_uart_resume_noirq,\n\t.restore_noirq = imx_uart_resume_noirq,\n\t.suspend = imx_uart_suspend,\n\t.resume = imx_uart_resume,\n\t.freeze = imx_uart_freeze,\n\t.thaw = imx_uart_thaw,\n\t.restore = imx_uart_thaw,\n};\n\nstatic struct platform_driver imx_uart_platform_driver = {\n\t.probe = imx_uart_probe,\n\t.remove = imx_uart_remove,\n\n\t.driver = {\n\t\t.name = \"imx-uart\",\n\t\t.of_match_table = imx_uart_dt_ids,\n\t\t.pm = &imx_uart_pm_ops,\n\t},\n};\n\nstatic int __init imx_uart_init(void)\n{\n\tint ret = uart_register_driver(&imx_uart_uart_driver);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&imx_uart_platform_driver);\n\tif (ret != 0)\n\t\tuart_unregister_driver(&imx_uart_uart_driver);\n\n\treturn ret;\n}\n\nstatic void __exit imx_uart_exit(void)\n{\n\tplatform_driver_unregister(&imx_uart_platform_driver);\n\tuart_unregister_driver(&imx_uart_uart_driver);\n}\n\nmodule_init(imx_uart_init);\nmodule_exit(imx_uart_exit);\n\nMODULE_AUTHOR(\"Sascha Hauer\");\nMODULE_DESCRIPTION(\"IMX generic serial port driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:imx-uart\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}