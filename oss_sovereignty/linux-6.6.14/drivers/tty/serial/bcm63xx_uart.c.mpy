{
  "module_name": "bcm63xx_uart.c",
  "hash_id": "1b0e9db2feb1bfb4de3b76f7c65ea60eb0853f7d5e8cbc839029cb00897d9e4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/bcm63xx_uart.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/clk.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/sysrq.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/serial_bcm63xx.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#define BCM63XX_NR_UARTS\t2\n\nstatic struct uart_port ports[BCM63XX_NR_UARTS];\n\n \n#define UART_RX_INT_MASK\t(UART_IR_MASK(UART_IR_RXOVER) |\t\t\\\n\t\t\t\tUART_IR_MASK(UART_IR_RXTHRESH) |\t\\\n\t\t\t\tUART_IR_MASK(UART_IR_RXTIMEOUT))\n\n#define UART_RX_INT_STAT\t(UART_IR_STAT(UART_IR_RXOVER) |\t\t\\\n\t\t\t\tUART_IR_STAT(UART_IR_RXTHRESH) |\t\\\n\t\t\t\tUART_IR_STAT(UART_IR_RXTIMEOUT))\n\n \n#define UART_TX_INT_MASK\t(UART_IR_MASK(UART_IR_TXEMPTY) |\t\\\n\t\t\t\tUART_IR_MASK(UART_IR_TXTRESH))\n\n#define UART_TX_INT_STAT\t(UART_IR_STAT(UART_IR_TXEMPTY) |\t\\\n\t\t\t\tUART_IR_STAT(UART_IR_TXTRESH))\n\n \n#define UART_EXTINP_INT_MASK\t(UART_EXTINP_IRMASK(UART_EXTINP_IR_CTS) | \\\n\t\t\t\t UART_EXTINP_IRMASK(UART_EXTINP_IR_DCD))\n\n \nstatic inline unsigned int bcm_uart_readl(struct uart_port *port,\n\t\t\t\t\t unsigned int offset)\n{\n\treturn __raw_readl(port->membase + offset);\n}\n\nstatic inline void bcm_uart_writel(struct uart_port *port,\n\t\t\t\t  unsigned int value, unsigned int offset)\n{\n\t__raw_writel(value, port->membase + offset);\n}\n\n \nstatic unsigned int bcm_uart_tx_empty(struct uart_port *port)\n{\n\tunsigned int val;\n\n\tval = bcm_uart_readl(port, UART_IR_REG);\n\treturn (val & UART_IR_STAT(UART_IR_TXEMPTY)) ? 1 : 0;\n}\n\n \nstatic void bcm_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tunsigned int val;\n\n\tval = bcm_uart_readl(port, UART_MCTL_REG);\n\tval &= ~(UART_MCTL_DTR_MASK | UART_MCTL_RTS_MASK);\n\t \n\tif (!(mctrl & TIOCM_DTR))\n\t\tval |= UART_MCTL_DTR_MASK;\n\tif (!(mctrl & TIOCM_RTS))\n\t\tval |= UART_MCTL_RTS_MASK;\n\tbcm_uart_writel(port, val, UART_MCTL_REG);\n\n\tval = bcm_uart_readl(port, UART_CTL_REG);\n\tif (mctrl & TIOCM_LOOP)\n\t\tval |= UART_CTL_LOOPBACK_MASK;\n\telse\n\t\tval &= ~UART_CTL_LOOPBACK_MASK;\n\tbcm_uart_writel(port, val, UART_CTL_REG);\n}\n\n \nstatic unsigned int bcm_uart_get_mctrl(struct uart_port *port)\n{\n\tunsigned int val, mctrl;\n\n\tmctrl = 0;\n\tval = bcm_uart_readl(port, UART_EXTINP_REG);\n\tif (val & UART_EXTINP_RI_MASK)\n\t\tmctrl |= TIOCM_RI;\n\tif (val & UART_EXTINP_CTS_MASK)\n\t\tmctrl |= TIOCM_CTS;\n\tif (val & UART_EXTINP_DCD_MASK)\n\t\tmctrl |= TIOCM_CD;\n\tif (val & UART_EXTINP_DSR_MASK)\n\t\tmctrl |= TIOCM_DSR;\n\treturn mctrl;\n}\n\n \nstatic void bcm_uart_stop_tx(struct uart_port *port)\n{\n\tunsigned int val;\n\n\tval = bcm_uart_readl(port, UART_CTL_REG);\n\tval &= ~(UART_CTL_TXEN_MASK);\n\tbcm_uart_writel(port, val, UART_CTL_REG);\n\n\tval = bcm_uart_readl(port, UART_IR_REG);\n\tval &= ~UART_TX_INT_MASK;\n\tbcm_uart_writel(port, val, UART_IR_REG);\n}\n\n \nstatic void bcm_uart_start_tx(struct uart_port *port)\n{\n\tunsigned int val;\n\n\tval = bcm_uart_readl(port, UART_IR_REG);\n\tval |= UART_TX_INT_MASK;\n\tbcm_uart_writel(port, val, UART_IR_REG);\n\n\tval = bcm_uart_readl(port, UART_CTL_REG);\n\tval |= UART_CTL_TXEN_MASK;\n\tbcm_uart_writel(port, val, UART_CTL_REG);\n}\n\n \nstatic void bcm_uart_stop_rx(struct uart_port *port)\n{\n\tunsigned int val;\n\n\tval = bcm_uart_readl(port, UART_IR_REG);\n\tval &= ~UART_RX_INT_MASK;\n\tbcm_uart_writel(port, val, UART_IR_REG);\n}\n\n \nstatic void bcm_uart_enable_ms(struct uart_port *port)\n{\n\tunsigned int val;\n\n\tval = bcm_uart_readl(port, UART_IR_REG);\n\tval |= UART_IR_MASK(UART_IR_EXTIP);\n\tbcm_uart_writel(port, val, UART_IR_REG);\n}\n\n \nstatic void bcm_uart_break_ctl(struct uart_port *port, int ctl)\n{\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tval = bcm_uart_readl(port, UART_CTL_REG);\n\tif (ctl)\n\t\tval |= UART_CTL_XMITBRK_MASK;\n\telse\n\t\tval &= ~UART_CTL_XMITBRK_MASK;\n\tbcm_uart_writel(port, val, UART_CTL_REG);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic const char *bcm_uart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_BCM63XX) ? \"bcm63xx_uart\" : NULL;\n}\n\n \nstatic void bcm_uart_do_rx(struct uart_port *port)\n{\n\tstruct tty_port *tty_port = &port->state->port;\n\tunsigned int max_count;\n\n\t \n\tmax_count = 32;\n\tdo {\n\t\tunsigned int iestat, c, cstat;\n\t\tchar flag;\n\n\t\t \n\t\tiestat = bcm_uart_readl(port, UART_IR_REG);\n\n\t\tif (unlikely(iestat & UART_IR_STAT(UART_IR_RXOVER))) {\n\t\t\tunsigned int val;\n\n\t\t\t \n\t\t\tval = bcm_uart_readl(port, UART_CTL_REG);\n\t\t\tval |= UART_CTL_RSTRXFIFO_MASK;\n\t\t\tbcm_uart_writel(port, val, UART_CTL_REG);\n\n\t\t\tport->icount.overrun++;\n\t\t\ttty_insert_flip_char(tty_port, 0, TTY_OVERRUN);\n\t\t}\n\n\t\tif (!(iestat & UART_IR_STAT(UART_IR_RXNOTEMPTY)))\n\t\t\tbreak;\n\n\t\tcstat = c = bcm_uart_readl(port, UART_FIFO_REG);\n\t\tport->icount.rx++;\n\t\tflag = TTY_NORMAL;\n\t\tc &= 0xff;\n\n\t\tif (unlikely((cstat & UART_FIFO_ANYERR_MASK))) {\n\t\t\t \n\t\t\tif (cstat & UART_FIFO_BRKDET_MASK) {\n\t\t\t\tport->icount.brk++;\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cstat & UART_FIFO_PARERR_MASK)\n\t\t\t\tport->icount.parity++;\n\t\t\tif (cstat & UART_FIFO_FRAMEERR_MASK)\n\t\t\t\tport->icount.frame++;\n\n\t\t\t \n\t\t\tcstat &= port->read_status_mask;\n\t\t\tif (cstat & UART_FIFO_BRKDET_MASK)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\tif (cstat & UART_FIFO_FRAMEERR_MASK)\n\t\t\t\tflag = TTY_FRAME;\n\t\t\tif (cstat & UART_FIFO_PARERR_MASK)\n\t\t\t\tflag = TTY_PARITY;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, c))\n\t\t\tcontinue;\n\n\n\t\tif ((cstat & port->ignore_status_mask) == 0)\n\t\t\ttty_insert_flip_char(tty_port, c, flag);\n\n\t} while (--max_count);\n\n\ttty_flip_buffer_push(tty_port);\n}\n\n \nstatic void bcm_uart_do_tx(struct uart_port *port)\n{\n\tunsigned int val;\n\tbool pending;\n\tu8 ch;\n\n\tval = bcm_uart_readl(port, UART_MCTL_REG);\n\tval = (val & UART_MCTL_TXFIFOFILL_MASK) >> UART_MCTL_TXFIFOFILL_SHIFT;\n\n\tpending = uart_port_tx_limited(port, ch, port->fifosize - val,\n\t\ttrue,\n\t\tbcm_uart_writel(port, ch, UART_FIFO_REG),\n\t\t({}));\n\tif (pending)\n\t\treturn;\n\n\t \n\tval = bcm_uart_readl(port, UART_IR_REG);\n\tval &= ~UART_TX_INT_MASK;\n\tbcm_uart_writel(port, val, UART_IR_REG);\n}\n\n \nstatic irqreturn_t bcm_uart_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_port *port;\n\tunsigned int irqstat;\n\n\tport = dev_id;\n\tspin_lock(&port->lock);\n\n\tirqstat = bcm_uart_readl(port, UART_IR_REG);\n\tif (irqstat & UART_RX_INT_STAT)\n\t\tbcm_uart_do_rx(port);\n\n\tif (irqstat & UART_TX_INT_STAT)\n\t\tbcm_uart_do_tx(port);\n\n\tif (irqstat & UART_IR_MASK(UART_IR_EXTIP)) {\n\t\tunsigned int estat;\n\n\t\testat = bcm_uart_readl(port, UART_EXTINP_REG);\n\t\tif (estat & UART_EXTINP_IRSTAT(UART_EXTINP_IR_CTS))\n\t\t\tuart_handle_cts_change(port,\n\t\t\t\t\t       estat & UART_EXTINP_CTS_MASK);\n\t\tif (estat & UART_EXTINP_IRSTAT(UART_EXTINP_IR_DCD))\n\t\t\tuart_handle_dcd_change(port,\n\t\t\t\t\t       estat & UART_EXTINP_DCD_MASK);\n\t}\n\n\tspin_unlock(&port->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void bcm_uart_enable(struct uart_port *port)\n{\n\tunsigned int val;\n\n\tval = bcm_uart_readl(port, UART_CTL_REG);\n\tval |= (UART_CTL_BRGEN_MASK | UART_CTL_TXEN_MASK | UART_CTL_RXEN_MASK);\n\tbcm_uart_writel(port, val, UART_CTL_REG);\n}\n\n \nstatic void bcm_uart_disable(struct uart_port *port)\n{\n\tunsigned int val;\n\n\tval = bcm_uart_readl(port, UART_CTL_REG);\n\tval &= ~(UART_CTL_BRGEN_MASK | UART_CTL_TXEN_MASK |\n\t\t UART_CTL_RXEN_MASK);\n\tbcm_uart_writel(port, val, UART_CTL_REG);\n}\n\n \nstatic void bcm_uart_flush(struct uart_port *port)\n{\n\tunsigned int val;\n\n\t \n\tval = bcm_uart_readl(port, UART_CTL_REG);\n\tval |= UART_CTL_RSTRXFIFO_MASK | UART_CTL_RSTTXFIFO_MASK;\n\tbcm_uart_writel(port, val, UART_CTL_REG);\n\n\t \n\t(void)bcm_uart_readl(port, UART_FIFO_REG);\n}\n\n \nstatic int bcm_uart_startup(struct uart_port *port)\n{\n\tunsigned int val;\n\tint ret;\n\n\t \n\tbcm_uart_disable(port);\n\tbcm_uart_writel(port, 0, UART_IR_REG);\n\tbcm_uart_flush(port);\n\n\t \n\t(void)bcm_uart_readl(port, UART_EXTINP_REG);\n\n\t \n\tval = bcm_uart_readl(port, UART_MCTL_REG);\n\tval &= ~(UART_MCTL_RXFIFOTHRESH_MASK | UART_MCTL_TXFIFOTHRESH_MASK);\n\tval |= (port->fifosize / 2) << UART_MCTL_RXFIFOTHRESH_SHIFT;\n\tval |= (port->fifosize / 2) << UART_MCTL_TXFIFOTHRESH_SHIFT;\n\tbcm_uart_writel(port, val, UART_MCTL_REG);\n\n\t \n\tval = bcm_uart_readl(port, UART_CTL_REG);\n\tval &= ~UART_CTL_RXTMOUTCNT_MASK;\n\tval |= 1 << UART_CTL_RXTMOUTCNT_SHIFT;\n\tbcm_uart_writel(port, val, UART_CTL_REG);\n\n\t \n\tval = UART_EXTINP_INT_MASK;\n\tval |= UART_EXTINP_DCD_NOSENSE_MASK;\n\tval |= UART_EXTINP_CTS_NOSENSE_MASK;\n\tbcm_uart_writel(port, val, UART_EXTINP_REG);\n\n\t \n\tret = request_irq(port->irq, bcm_uart_interrupt, 0,\n\t\t\t  dev_name(port->dev), port);\n\tif (ret)\n\t\treturn ret;\n\tbcm_uart_writel(port, UART_RX_INT_MASK, UART_IR_REG);\n\tbcm_uart_enable(port);\n\treturn 0;\n}\n\n \nstatic void bcm_uart_shutdown(struct uart_port *port)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tbcm_uart_writel(port, 0, UART_IR_REG);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tbcm_uart_disable(port);\n\tbcm_uart_flush(port);\n\tfree_irq(port->irq, port);\n}\n\n \nstatic void bcm_uart_set_termios(struct uart_port *port, struct ktermios *new,\n\t\t\t\t const struct ktermios *old)\n{\n\tunsigned int ctl, baud, quot, ier;\n\tunsigned long flags;\n\tint tries;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tfor (tries = 3; !bcm_uart_tx_empty(port) && tries; tries--)\n\t\tmdelay(10);\n\n\t \n\tbcm_uart_disable(port);\n\tbcm_uart_flush(port);\n\n\t \n\tctl = bcm_uart_readl(port, UART_CTL_REG);\n\tctl &= ~UART_CTL_BITSPERSYM_MASK;\n\n\tswitch (new->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tctl |= (0 << UART_CTL_BITSPERSYM_SHIFT);\n\t\tbreak;\n\tcase CS6:\n\t\tctl |= (1 << UART_CTL_BITSPERSYM_SHIFT);\n\t\tbreak;\n\tcase CS7:\n\t\tctl |= (2 << UART_CTL_BITSPERSYM_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tctl |= (3 << UART_CTL_BITSPERSYM_SHIFT);\n\t\tbreak;\n\t}\n\n\tctl &= ~UART_CTL_STOPBITS_MASK;\n\tif (new->c_cflag & CSTOPB)\n\t\tctl |= UART_CTL_STOPBITS_2;\n\telse\n\t\tctl |= UART_CTL_STOPBITS_1;\n\n\tctl &= ~(UART_CTL_RXPAREN_MASK | UART_CTL_TXPAREN_MASK);\n\tif (new->c_cflag & PARENB)\n\t\tctl |= (UART_CTL_RXPAREN_MASK | UART_CTL_TXPAREN_MASK);\n\tctl &= ~(UART_CTL_RXPAREVEN_MASK | UART_CTL_TXPAREVEN_MASK);\n\tif (new->c_cflag & PARODD)\n\t\tctl |= (UART_CTL_RXPAREVEN_MASK | UART_CTL_TXPAREVEN_MASK);\n\tbcm_uart_writel(port, ctl, UART_CTL_REG);\n\n\t \n\tbaud = uart_get_baud_rate(port, new, old, 0, port->uartclk / 16);\n\tquot = uart_get_divisor(port, baud) - 1;\n\tbcm_uart_writel(port, quot, UART_BAUD_REG);\n\n\t \n\tier = bcm_uart_readl(port, UART_IR_REG);\n\n\tier &= ~UART_IR_MASK(UART_IR_EXTIP);\n\tif (UART_ENABLE_MS(port, new->c_cflag))\n\t\tier |= UART_IR_MASK(UART_IR_EXTIP);\n\n\tbcm_uart_writel(port, ier, UART_IR_REG);\n\n\t \n\tport->read_status_mask = UART_FIFO_VALID_MASK;\n\tif (new->c_iflag & INPCK) {\n\t\tport->read_status_mask |= UART_FIFO_FRAMEERR_MASK;\n\t\tport->read_status_mask |= UART_FIFO_PARERR_MASK;\n\t}\n\tif (new->c_iflag & (IGNBRK | BRKINT))\n\t\tport->read_status_mask |= UART_FIFO_BRKDET_MASK;\n\n\tport->ignore_status_mask = 0;\n\tif (new->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= UART_FIFO_PARERR_MASK;\n\tif (new->c_iflag & IGNBRK)\n\t\tport->ignore_status_mask |= UART_FIFO_BRKDET_MASK;\n\tif (!(new->c_cflag & CREAD))\n\t\tport->ignore_status_mask |= UART_FIFO_VALID_MASK;\n\n\tuart_update_timeout(port, new->c_cflag, baud);\n\tbcm_uart_enable(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic int bcm_uart_request_port(struct uart_port *port)\n{\n\t \n\treturn 0;\n}\n\n \nstatic void bcm_uart_release_port(struct uart_port *port)\n{\n\t \n}\n\n \nstatic void bcm_uart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tif (bcm_uart_request_port(port))\n\t\t\treturn;\n\t\tport->type = PORT_BCM63XX;\n\t}\n}\n\n \nstatic int bcm_uart_verify_port(struct uart_port *port,\n\t\t\t\tstruct serial_struct *serinfo)\n{\n\tif (port->type != PORT_BCM63XX)\n\t\treturn -EINVAL;\n\tif (port->irq != serinfo->irq)\n\t\treturn -EINVAL;\n\tif (port->iotype != serinfo->io_type)\n\t\treturn -EINVAL;\n\tif (port->mapbase != (unsigned long)serinfo->iomem_base)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n \nstatic bool bcm_uart_tx_full(struct uart_port *port)\n{\n\tunsigned int val;\n\n\tval = bcm_uart_readl(port, UART_MCTL_REG);\n\tval = (val & UART_MCTL_TXFIFOFILL_MASK) >> UART_MCTL_TXFIFOFILL_SHIFT;\n\treturn !(port->fifosize - val);\n}\n\nstatic int bcm_uart_poll_get_char(struct uart_port *port)\n{\n\tunsigned int iestat;\n\n\tiestat = bcm_uart_readl(port, UART_IR_REG);\n\tif (!(iestat & UART_IR_STAT(UART_IR_RXNOTEMPTY)))\n\t\treturn NO_POLL_CHAR;\n\n\treturn bcm_uart_readl(port, UART_FIFO_REG);\n}\n\nstatic void bcm_uart_poll_put_char(struct uart_port *port, unsigned char c)\n{\n\twhile (bcm_uart_tx_full(port)) {\n\t\tcpu_relax();\n\t}\n\n\tbcm_uart_writel(port, c, UART_FIFO_REG);\n}\n#endif\n\n \nstatic const struct uart_ops bcm_uart_ops = {\n\t.tx_empty\t= bcm_uart_tx_empty,\n\t.get_mctrl\t= bcm_uart_get_mctrl,\n\t.set_mctrl\t= bcm_uart_set_mctrl,\n\t.start_tx\t= bcm_uart_start_tx,\n\t.stop_tx\t= bcm_uart_stop_tx,\n\t.stop_rx\t= bcm_uart_stop_rx,\n\t.enable_ms\t= bcm_uart_enable_ms,\n\t.break_ctl\t= bcm_uart_break_ctl,\n\t.startup\t= bcm_uart_startup,\n\t.shutdown\t= bcm_uart_shutdown,\n\t.set_termios\t= bcm_uart_set_termios,\n\t.type\t\t= bcm_uart_type,\n\t.release_port\t= bcm_uart_release_port,\n\t.request_port\t= bcm_uart_request_port,\n\t.config_port\t= bcm_uart_config_port,\n\t.verify_port\t= bcm_uart_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char  = bcm_uart_poll_get_char,\n\t.poll_put_char  = bcm_uart_poll_put_char,\n#endif\n};\n\n\n\n#ifdef CONFIG_SERIAL_BCM63XX_CONSOLE\nstatic void wait_for_xmitr(struct uart_port *port)\n{\n\tunsigned int tmout;\n\n\t \n\ttmout = 10000;\n\twhile (--tmout) {\n\t\tunsigned int val;\n\n\t\tval = bcm_uart_readl(port, UART_IR_REG);\n\t\tif (val & UART_IR_STAT(UART_IR_TXEMPTY))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\t \n\tif (port->flags & UPF_CONS_FLOW) {\n\t\ttmout = 1000000;\n\t\twhile (--tmout) {\n\t\t\tunsigned int val;\n\n\t\t\tval = bcm_uart_readl(port, UART_EXTINP_REG);\n\t\t\tif (val & UART_EXTINP_CTS_MASK)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t}\n}\n\n \nstatic void bcm_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\twait_for_xmitr(port);\n\tbcm_uart_writel(port, ch, UART_FIFO_REG);\n}\n\n \nstatic void bcm_console_write(struct console *co, const char *s,\n\t\t\t      unsigned int count)\n{\n\tstruct uart_port *port;\n\tunsigned long flags;\n\tint locked;\n\n\tport = &ports[co->index];\n\n\tlocal_irq_save(flags);\n\tif (port->sysrq) {\n\t\t \n\t\tlocked = 0;\n\t} else if (oops_in_progress) {\n\t\tlocked = spin_trylock(&port->lock);\n\t} else {\n\t\tspin_lock(&port->lock);\n\t\tlocked = 1;\n\t}\n\n\t \n\tuart_console_write(port, s, count, bcm_console_putchar);\n\n\t \n\twait_for_xmitr(port);\n\n\tif (locked)\n\t\tspin_unlock(&port->lock);\n\tlocal_irq_restore(flags);\n}\n\n \nstatic int bcm_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index < 0 || co->index >= BCM63XX_NR_UARTS)\n\t\treturn -EINVAL;\n\tport = &ports[co->index];\n\tif (!port->membase)\n\t\treturn -ENODEV;\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver bcm_uart_driver;\n\nstatic struct console bcm63xx_console = {\n\t.name\t\t= \"ttyS\",\n\t.write\t\t= bcm_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= bcm_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &bcm_uart_driver,\n};\n\nstatic int __init bcm63xx_console_init(void)\n{\n\tregister_console(&bcm63xx_console);\n\treturn 0;\n}\n\nconsole_initcall(bcm63xx_console_init);\n\nstatic void bcm_early_write(struct console *con, const char *s, unsigned n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, bcm_console_putchar);\n\twait_for_xmitr(&dev->port);\n}\n\nstatic int __init bcm_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t  const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = bcm_early_write;\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(bcm63xx_uart, \"brcm,bcm6345-uart\", bcm_early_console_setup);\n\n#define BCM63XX_CONSOLE\t(&bcm63xx_console)\n#else\n#define BCM63XX_CONSOLE\tNULL\n#endif  \n\nstatic struct uart_driver bcm_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"bcm63xx_uart\",\n\t.dev_name\t= \"ttyS\",\n\t.major\t\t= TTY_MAJOR,\n\t.minor\t\t= 64,\n\t.nr\t\t= BCM63XX_NR_UARTS,\n\t.cons\t\t= BCM63XX_CONSOLE,\n};\n\n \nstatic int bcm_uart_probe(struct platform_device *pdev)\n{\n\tstruct resource *res_mem;\n\tstruct uart_port *port;\n\tstruct clk *clk;\n\tint ret;\n\n\tif (pdev->dev.of_node) {\n\t\tpdev->id = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\n\t\tif (pdev->id < 0)\n\t\t\tpdev->id = of_alias_get_id(pdev->dev.of_node, \"uart\");\n\t}\n\n\tif (pdev->id < 0 || pdev->id >= BCM63XX_NR_UARTS)\n\t\treturn -EINVAL;\n\n\tport = &ports[pdev->id];\n\tif (port->membase)\n\t\treturn -EBUSY;\n\tmemset(port, 0, sizeof(*port));\n\n\tport->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &res_mem);\n\tif (IS_ERR(port->membase))\n\t\treturn PTR_ERR(port->membase);\n\tport->mapbase = res_mem->start;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tport->irq = ret;\n\n\tclk = clk_get(&pdev->dev, \"refclk\");\n\tif (IS_ERR(clk) && pdev->dev.of_node)\n\t\tclk = of_clk_get(pdev->dev.of_node, 0);\n\n\tif (IS_ERR(clk))\n\t\treturn -ENODEV;\n\n\tport->iotype = UPIO_MEM;\n\tport->ops = &bcm_uart_ops;\n\tport->flags = UPF_BOOT_AUTOCONF;\n\tport->dev = &pdev->dev;\n\tport->fifosize = 16;\n\tport->uartclk = clk_get_rate(clk) / 2;\n\tport->line = pdev->id;\n\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_BCM63XX_CONSOLE);\n\tclk_put(clk);\n\n\tret = uart_add_one_port(&bcm_uart_driver, port);\n\tif (ret) {\n\t\tports[pdev->id].membase = NULL;\n\t\treturn ret;\n\t}\n\tplatform_set_drvdata(pdev, port);\n\treturn 0;\n}\n\nstatic int bcm_uart_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port;\n\n\tport = platform_get_drvdata(pdev);\n\tuart_remove_one_port(&bcm_uart_driver, port);\n\t \n\tports[pdev->id].membase = NULL;\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm63xx_of_match[] = {\n\t{ .compatible = \"brcm,bcm6345-uart\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, bcm63xx_of_match);\n\n \nstatic struct platform_driver bcm_uart_platform_driver = {\n\t.probe\t= bcm_uart_probe,\n\t.remove\t= bcm_uart_remove,\n\t.driver\t= {\n\t\t.name  = \"bcm63xx_uart\",\n\t\t.of_match_table = bcm63xx_of_match,\n\t},\n};\n\nstatic int __init bcm_uart_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&bcm_uart_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&bcm_uart_platform_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&bcm_uart_driver);\n\n\treturn ret;\n}\n\nstatic void __exit bcm_uart_exit(void)\n{\n\tplatform_driver_unregister(&bcm_uart_platform_driver);\n\tuart_unregister_driver(&bcm_uart_driver);\n}\n\nmodule_init(bcm_uart_init);\nmodule_exit(bcm_uart_exit);\n\nMODULE_AUTHOR(\"Maxime Bizon <mbizon@freebox.fr>\");\nMODULE_DESCRIPTION(\"Broadcom 63xx integrated uart driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}