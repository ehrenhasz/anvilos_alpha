{
  "module_name": "fsl_lpuart.c",
  "hash_id": "42a1c39afccac17a213d8f298d32abf1e060d4b2c7eec9d92ea2e40c03aa0005",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/fsl_lpuart.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/dmapool.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/tty_flip.h>\n\n \n#define UARTBDH\t\t\t0x00\n#define UARTBDL\t\t\t0x01\n#define UARTCR1\t\t\t0x02\n#define UARTCR2\t\t\t0x03\n#define UARTSR1\t\t\t0x04\n#define UARTCR3\t\t\t0x06\n#define UARTDR\t\t\t0x07\n#define UARTCR4\t\t\t0x0a\n#define UARTCR5\t\t\t0x0b\n#define UARTMODEM\t\t0x0d\n#define UARTPFIFO\t\t0x10\n#define UARTCFIFO\t\t0x11\n#define UARTSFIFO\t\t0x12\n#define UARTTWFIFO\t\t0x13\n#define UARTTCFIFO\t\t0x14\n#define UARTRWFIFO\t\t0x15\n\n#define UARTBDH_LBKDIE\t\t0x80\n#define UARTBDH_RXEDGIE\t\t0x40\n#define UARTBDH_SBR_MASK\t0x1f\n\n#define UARTCR1_LOOPS\t\t0x80\n#define UARTCR1_RSRC\t\t0x20\n#define UARTCR1_M\t\t0x10\n#define UARTCR1_WAKE\t\t0x08\n#define UARTCR1_ILT\t\t0x04\n#define UARTCR1_PE\t\t0x02\n#define UARTCR1_PT\t\t0x01\n\n#define UARTCR2_TIE\t\t0x80\n#define UARTCR2_TCIE\t\t0x40\n#define UARTCR2_RIE\t\t0x20\n#define UARTCR2_ILIE\t\t0x10\n#define UARTCR2_TE\t\t0x08\n#define UARTCR2_RE\t\t0x04\n#define UARTCR2_RWU\t\t0x02\n#define UARTCR2_SBK\t\t0x01\n\n#define UARTSR1_TDRE\t\t0x80\n#define UARTSR1_TC\t\t0x40\n#define UARTSR1_RDRF\t\t0x20\n#define UARTSR1_IDLE\t\t0x10\n#define UARTSR1_OR\t\t0x08\n#define UARTSR1_NF\t\t0x04\n#define UARTSR1_FE\t\t0x02\n#define UARTSR1_PE\t\t0x01\n\n#define UARTCR3_R8\t\t0x80\n#define UARTCR3_T8\t\t0x40\n#define UARTCR3_TXDIR\t\t0x20\n#define UARTCR3_TXINV\t\t0x10\n#define UARTCR3_ORIE\t\t0x08\n#define UARTCR3_NEIE\t\t0x04\n#define UARTCR3_FEIE\t\t0x02\n#define UARTCR3_PEIE\t\t0x01\n\n#define UARTCR4_MAEN1\t\t0x80\n#define UARTCR4_MAEN2\t\t0x40\n#define UARTCR4_M10\t\t0x20\n#define UARTCR4_BRFA_MASK\t0x1f\n#define UARTCR4_BRFA_OFF\t0\n\n#define UARTCR5_TDMAS\t\t0x80\n#define UARTCR5_RDMAS\t\t0x20\n\n#define UARTMODEM_RXRTSE\t0x08\n#define UARTMODEM_TXRTSPOL\t0x04\n#define UARTMODEM_TXRTSE\t0x02\n#define UARTMODEM_TXCTSE\t0x01\n\n#define UARTPFIFO_TXFE\t\t0x80\n#define UARTPFIFO_FIFOSIZE_MASK\t0x7\n#define UARTPFIFO_TXSIZE_OFF\t4\n#define UARTPFIFO_RXFE\t\t0x08\n#define UARTPFIFO_RXSIZE_OFF\t0\n\n#define UARTCFIFO_TXFLUSH\t0x80\n#define UARTCFIFO_RXFLUSH\t0x40\n#define UARTCFIFO_RXOFE\t\t0x04\n#define UARTCFIFO_TXOFE\t\t0x02\n#define UARTCFIFO_RXUFE\t\t0x01\n\n#define UARTSFIFO_TXEMPT\t0x80\n#define UARTSFIFO_RXEMPT\t0x40\n#define UARTSFIFO_RXOF\t\t0x04\n#define UARTSFIFO_TXOF\t\t0x02\n#define UARTSFIFO_RXUF\t\t0x01\n\n \n#define UART_GLOBAL\t\t0x8\n\n \n#define UARTBAUD\t\t0x00\n#define UARTSTAT\t\t0x04\n#define UARTCTRL\t\t0x08\n#define UARTDATA\t\t0x0C\n#define UARTMATCH\t\t0x10\n#define UARTMODIR\t\t0x14\n#define UARTFIFO\t\t0x18\n#define UARTWATER\t\t0x1c\n\n#define UARTBAUD_MAEN1\t\t0x80000000\n#define UARTBAUD_MAEN2\t\t0x40000000\n#define UARTBAUD_M10\t\t0x20000000\n#define UARTBAUD_TDMAE\t\t0x00800000\n#define UARTBAUD_RDMAE\t\t0x00200000\n#define UARTBAUD_MATCFG\t\t0x00400000\n#define UARTBAUD_BOTHEDGE\t0x00020000\n#define UARTBAUD_RESYNCDIS\t0x00010000\n#define UARTBAUD_LBKDIE\t\t0x00008000\n#define UARTBAUD_RXEDGIE\t0x00004000\n#define UARTBAUD_SBNS\t\t0x00002000\n#define UARTBAUD_SBR\t\t0x00000000\n#define UARTBAUD_SBR_MASK\t0x1fff\n#define UARTBAUD_OSR_MASK       0x1f\n#define UARTBAUD_OSR_SHIFT      24\n\n#define UARTSTAT_LBKDIF\t\t0x80000000\n#define UARTSTAT_RXEDGIF\t0x40000000\n#define UARTSTAT_MSBF\t\t0x20000000\n#define UARTSTAT_RXINV\t\t0x10000000\n#define UARTSTAT_RWUID\t\t0x08000000\n#define UARTSTAT_BRK13\t\t0x04000000\n#define UARTSTAT_LBKDE\t\t0x02000000\n#define UARTSTAT_RAF\t\t0x01000000\n#define UARTSTAT_TDRE\t\t0x00800000\n#define UARTSTAT_TC\t\t0x00400000\n#define UARTSTAT_RDRF\t\t0x00200000\n#define UARTSTAT_IDLE\t\t0x00100000\n#define UARTSTAT_OR\t\t0x00080000\n#define UARTSTAT_NF\t\t0x00040000\n#define UARTSTAT_FE\t\t0x00020000\n#define UARTSTAT_PE\t\t0x00010000\n#define UARTSTAT_MA1F\t\t0x00008000\n#define UARTSTAT_M21F\t\t0x00004000\n\n#define UARTCTRL_R8T9\t\t0x80000000\n#define UARTCTRL_R9T8\t\t0x40000000\n#define UARTCTRL_TXDIR\t\t0x20000000\n#define UARTCTRL_TXINV\t\t0x10000000\n#define UARTCTRL_ORIE\t\t0x08000000\n#define UARTCTRL_NEIE\t\t0x04000000\n#define UARTCTRL_FEIE\t\t0x02000000\n#define UARTCTRL_PEIE\t\t0x01000000\n#define UARTCTRL_TIE\t\t0x00800000\n#define UARTCTRL_TCIE\t\t0x00400000\n#define UARTCTRL_RIE\t\t0x00200000\n#define UARTCTRL_ILIE\t\t0x00100000\n#define UARTCTRL_TE\t\t0x00080000\n#define UARTCTRL_RE\t\t0x00040000\n#define UARTCTRL_RWU\t\t0x00020000\n#define UARTCTRL_SBK\t\t0x00010000\n#define UARTCTRL_MA1IE\t\t0x00008000\n#define UARTCTRL_MA2IE\t\t0x00004000\n#define UARTCTRL_IDLECFG\tGENMASK(10, 8)\n#define UARTCTRL_LOOPS\t\t0x00000080\n#define UARTCTRL_DOZEEN\t\t0x00000040\n#define UARTCTRL_RSRC\t\t0x00000020\n#define UARTCTRL_M\t\t0x00000010\n#define UARTCTRL_WAKE\t\t0x00000008\n#define UARTCTRL_ILT\t\t0x00000004\n#define UARTCTRL_PE\t\t0x00000002\n#define UARTCTRL_PT\t\t0x00000001\n\n#define UARTDATA_NOISY\t\t0x00008000\n#define UARTDATA_PARITYE\t0x00004000\n#define UARTDATA_FRETSC\t\t0x00002000\n#define UARTDATA_RXEMPT\t\t0x00001000\n#define UARTDATA_IDLINE\t\t0x00000800\n#define UARTDATA_MASK\t\t0x3ff\n\n#define UARTMODIR_IREN\t\t0x00020000\n#define UARTMODIR_RTSWATER\tGENMASK(10, 8)\n#define UARTMODIR_TXCTSSRC\t0x00000020\n#define UARTMODIR_TXCTSC\t0x00000010\n#define UARTMODIR_RXRTSE\t0x00000008\n#define UARTMODIR_TXRTSPOL\t0x00000004\n#define UARTMODIR_TXRTSE\t0x00000002\n#define UARTMODIR_TXCTSE\t0x00000001\n\n#define UARTFIFO_TXEMPT\t\t0x00800000\n#define UARTFIFO_RXEMPT\t\t0x00400000\n#define UARTFIFO_TXOF\t\t0x00020000\n#define UARTFIFO_RXUF\t\t0x00010000\n#define UARTFIFO_TXFLUSH\t0x00008000\n#define UARTFIFO_RXFLUSH\t0x00004000\n#define UARTFIFO_RXIDEN\tGENMASK(12, 10)\n#define UARTFIFO_TXOFE\t\t0x00000200\n#define UARTFIFO_RXUFE\t\t0x00000100\n#define UARTFIFO_TXFE\t\t0x00000080\n#define UARTFIFO_FIFOSIZE_MASK\t0x7\n#define UARTFIFO_TXSIZE_OFF\t4\n#define UARTFIFO_RXFE\t\t0x00000008\n#define UARTFIFO_RXSIZE_OFF\t0\n#define UARTFIFO_DEPTH(x)\t(0x1 << ((x) ? ((x) + 1) : 0))\n\n#define UARTWATER_COUNT_MASK\t0xff\n#define UARTWATER_TXCNT_OFF\t8\n#define UARTWATER_RXCNT_OFF\t24\n#define UARTWATER_WATER_MASK\t0xff\n#define UARTWATER_TXWATER_OFF\t0\n#define UARTWATER_RXWATER_OFF\t16\n\n#define UART_GLOBAL_RST\t0x2\n#define GLOBAL_RST_MIN_US\t20\n#define GLOBAL_RST_MAX_US\t40\n\n \n#define DMA_RX_TIMEOUT\t\t(10)\n#define DMA_RX_IDLE_CHARS\t8\n#define UART_AUTOSUSPEND_TIMEOUT\t3000\n\n#define DRIVER_NAME\t\"fsl-lpuart\"\n#define DEV_NAME\t\"ttyLP\"\n#define UART_NR\t\t8\n\n \n#define IMX_REG_OFF\t0x10\n\nenum lpuart_type {\n\tVF610_LPUART,\n\tLS1021A_LPUART,\n\tLS1028A_LPUART,\n\tIMX7ULP_LPUART,\n\tIMX8ULP_LPUART,\n\tIMX8QXP_LPUART,\n\tIMXRT1050_LPUART,\n};\n\nstruct lpuart_port {\n\tstruct uart_port\tport;\n\tenum lpuart_type\tdevtype;\n\tstruct clk\t\t*ipg_clk;\n\tstruct clk\t\t*baud_clk;\n\tunsigned int\t\ttxfifo_size;\n\tunsigned int\t\trxfifo_size;\n\n\tu8\t\t\trx_watermark;\n\tbool\t\t\tlpuart_dma_tx_use;\n\tbool\t\t\tlpuart_dma_rx_use;\n\tstruct dma_chan\t\t*dma_tx_chan;\n\tstruct dma_chan\t\t*dma_rx_chan;\n\tstruct dma_async_tx_descriptor  *dma_tx_desc;\n\tstruct dma_async_tx_descriptor  *dma_rx_desc;\n\tdma_cookie_t\t\tdma_tx_cookie;\n\tdma_cookie_t\t\tdma_rx_cookie;\n\tunsigned int\t\tdma_tx_bytes;\n\tunsigned int\t\tdma_rx_bytes;\n\tbool\t\t\tdma_tx_in_progress;\n\tunsigned int\t\tdma_rx_timeout;\n\tstruct timer_list\tlpuart_timer;\n\tstruct scatterlist\trx_sgl, tx_sgl[2];\n\tstruct circ_buf\t\trx_ring;\n\tint\t\t\trx_dma_rng_buf_len;\n\tint                     last_residue;\n\tunsigned int\t\tdma_tx_nents;\n\twait_queue_head_t\tdma_wait;\n\tbool\t\t\tis_cs7;  \n\t\t\t\t\t \n\tbool\t\t\tdma_idle_int;\n};\n\nstruct lpuart_soc_data {\n\tenum lpuart_type devtype;\n\tchar iotype;\n\tu8 reg_off;\n\tu8 rx_watermark;\n};\n\nstatic const struct lpuart_soc_data vf_data = {\n\t.devtype = VF610_LPUART,\n\t.iotype = UPIO_MEM,\n\t.rx_watermark = 1,\n};\n\nstatic const struct lpuart_soc_data ls1021a_data = {\n\t.devtype = LS1021A_LPUART,\n\t.iotype = UPIO_MEM32BE,\n\t.rx_watermark = 1,\n};\n\nstatic const struct lpuart_soc_data ls1028a_data = {\n\t.devtype = LS1028A_LPUART,\n\t.iotype = UPIO_MEM32,\n\t.rx_watermark = 0,\n};\n\nstatic struct lpuart_soc_data imx7ulp_data = {\n\t.devtype = IMX7ULP_LPUART,\n\t.iotype = UPIO_MEM32,\n\t.reg_off = IMX_REG_OFF,\n\t.rx_watermark = 1,\n};\n\nstatic struct lpuart_soc_data imx8ulp_data = {\n\t.devtype = IMX8ULP_LPUART,\n\t.iotype = UPIO_MEM32,\n\t.reg_off = IMX_REG_OFF,\n\t.rx_watermark = 3,\n};\n\nstatic struct lpuart_soc_data imx8qxp_data = {\n\t.devtype = IMX8QXP_LPUART,\n\t.iotype = UPIO_MEM32,\n\t.reg_off = IMX_REG_OFF,\n\t.rx_watermark = 7,  \n};\nstatic struct lpuart_soc_data imxrt1050_data = {\n\t.devtype = IMXRT1050_LPUART,\n\t.iotype = UPIO_MEM32,\n\t.reg_off = IMX_REG_OFF,\n\t.rx_watermark = 1,\n};\n\nstatic const struct of_device_id lpuart_dt_ids[] = {\n\t{ .compatible = \"fsl,vf610-lpuart\",\t.data = &vf_data, },\n\t{ .compatible = \"fsl,ls1021a-lpuart\",\t.data = &ls1021a_data, },\n\t{ .compatible = \"fsl,ls1028a-lpuart\",\t.data = &ls1028a_data, },\n\t{ .compatible = \"fsl,imx7ulp-lpuart\",\t.data = &imx7ulp_data, },\n\t{ .compatible = \"fsl,imx8ulp-lpuart\",\t.data = &imx8ulp_data, },\n\t{ .compatible = \"fsl,imx8qxp-lpuart\",\t.data = &imx8qxp_data, },\n\t{ .compatible = \"fsl,imxrt1050-lpuart\",\t.data = &imxrt1050_data},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, lpuart_dt_ids);\n\n \nstatic void lpuart_dma_tx_complete(void *arg);\n\nstatic inline bool is_layerscape_lpuart(struct lpuart_port *sport)\n{\n\treturn (sport->devtype == LS1021A_LPUART ||\n\t\tsport->devtype == LS1028A_LPUART);\n}\n\nstatic inline bool is_imx7ulp_lpuart(struct lpuart_port *sport)\n{\n\treturn sport->devtype == IMX7ULP_LPUART;\n}\n\nstatic inline bool is_imx8ulp_lpuart(struct lpuart_port *sport)\n{\n\treturn sport->devtype == IMX8ULP_LPUART;\n}\n\nstatic inline bool is_imx8qxp_lpuart(struct lpuart_port *sport)\n{\n\treturn sport->devtype == IMX8QXP_LPUART;\n}\n\nstatic inline u32 lpuart32_read(struct uart_port *port, u32 off)\n{\n\tswitch (port->iotype) {\n\tcase UPIO_MEM32:\n\t\treturn readl(port->membase + off);\n\tcase UPIO_MEM32BE:\n\t\treturn ioread32be(port->membase + off);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline void lpuart32_write(struct uart_port *port, u32 val,\n\t\t\t\t  u32 off)\n{\n\tswitch (port->iotype) {\n\tcase UPIO_MEM32:\n\t\twritel(val, port->membase + off);\n\t\tbreak;\n\tcase UPIO_MEM32BE:\n\t\tiowrite32be(val, port->membase + off);\n\t\tbreak;\n\t}\n}\n\nstatic int __lpuart_enable_clks(struct lpuart_port *sport, bool is_en)\n{\n\tint ret = 0;\n\n\tif (is_en) {\n\t\tret = clk_prepare_enable(sport->ipg_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_prepare_enable(sport->baud_clk);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(sport->ipg_clk);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tclk_disable_unprepare(sport->baud_clk);\n\t\tclk_disable_unprepare(sport->ipg_clk);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int lpuart_get_baud_clk_rate(struct lpuart_port *sport)\n{\n\tif (is_imx8qxp_lpuart(sport))\n\t\treturn clk_get_rate(sport->baud_clk);\n\n\treturn clk_get_rate(sport->ipg_clk);\n}\n\n#define lpuart_enable_clks(x)\t__lpuart_enable_clks(x, true)\n#define lpuart_disable_clks(x)\t__lpuart_enable_clks(x, false)\n\nstatic void lpuart_stop_tx(struct uart_port *port)\n{\n\tunsigned char temp;\n\n\ttemp = readb(port->membase + UARTCR2);\n\ttemp &= ~(UARTCR2_TIE | UARTCR2_TCIE);\n\twriteb(temp, port->membase + UARTCR2);\n}\n\nstatic void lpuart32_stop_tx(struct uart_port *port)\n{\n\tunsigned long temp;\n\n\ttemp = lpuart32_read(port, UARTCTRL);\n\ttemp &= ~(UARTCTRL_TIE | UARTCTRL_TCIE);\n\tlpuart32_write(port, temp, UARTCTRL);\n}\n\nstatic void lpuart_stop_rx(struct uart_port *port)\n{\n\tunsigned char temp;\n\n\ttemp = readb(port->membase + UARTCR2);\n\twriteb(temp & ~UARTCR2_RE, port->membase + UARTCR2);\n}\n\nstatic void lpuart32_stop_rx(struct uart_port *port)\n{\n\tunsigned long temp;\n\n\ttemp = lpuart32_read(port, UARTCTRL);\n\tlpuart32_write(port, temp & ~UARTCTRL_RE, UARTCTRL);\n}\n\nstatic void lpuart_dma_tx(struct lpuart_port *sport)\n{\n\tstruct circ_buf *xmit = &sport->port.state->xmit;\n\tstruct scatterlist *sgl = sport->tx_sgl;\n\tstruct device *dev = sport->port.dev;\n\tstruct dma_chan *chan = sport->dma_tx_chan;\n\tint ret;\n\n\tif (sport->dma_tx_in_progress)\n\t\treturn;\n\n\tsport->dma_tx_bytes = uart_circ_chars_pending(xmit);\n\n\tif (xmit->tail < xmit->head || xmit->head == 0) {\n\t\tsport->dma_tx_nents = 1;\n\t\tsg_init_one(sgl, xmit->buf + xmit->tail, sport->dma_tx_bytes);\n\t} else {\n\t\tsport->dma_tx_nents = 2;\n\t\tsg_init_table(sgl, 2);\n\t\tsg_set_buf(sgl, xmit->buf + xmit->tail,\n\t\t\t\tUART_XMIT_SIZE - xmit->tail);\n\t\tsg_set_buf(sgl + 1, xmit->buf, xmit->head);\n\t}\n\n\tret = dma_map_sg(chan->device->dev, sgl, sport->dma_tx_nents,\n\t\t\t DMA_TO_DEVICE);\n\tif (!ret) {\n\t\tdev_err(dev, \"DMA mapping error for TX.\\n\");\n\t\treturn;\n\t}\n\n\tsport->dma_tx_desc = dmaengine_prep_slave_sg(chan, sgl,\n\t\t\t\t\tret, DMA_MEM_TO_DEV,\n\t\t\t\t\tDMA_PREP_INTERRUPT);\n\tif (!sport->dma_tx_desc) {\n\t\tdma_unmap_sg(chan->device->dev, sgl, sport->dma_tx_nents,\n\t\t\t      DMA_TO_DEVICE);\n\t\tdev_err(dev, \"Cannot prepare TX slave DMA!\\n\");\n\t\treturn;\n\t}\n\n\tsport->dma_tx_desc->callback = lpuart_dma_tx_complete;\n\tsport->dma_tx_desc->callback_param = sport;\n\tsport->dma_tx_in_progress = true;\n\tsport->dma_tx_cookie = dmaengine_submit(sport->dma_tx_desc);\n\tdma_async_issue_pending(chan);\n}\n\nstatic bool lpuart_stopped_or_empty(struct uart_port *port)\n{\n\treturn uart_circ_empty(&port->state->xmit) || uart_tx_stopped(port);\n}\n\nstatic void lpuart_dma_tx_complete(void *arg)\n{\n\tstruct lpuart_port *sport = arg;\n\tstruct scatterlist *sgl = &sport->tx_sgl[0];\n\tstruct circ_buf *xmit = &sport->port.state->xmit;\n\tstruct dma_chan *chan = sport->dma_tx_chan;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\tif (!sport->dma_tx_in_progress) {\n\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\t\treturn;\n\t}\n\n\tdma_unmap_sg(chan->device->dev, sgl, sport->dma_tx_nents,\n\t\t     DMA_TO_DEVICE);\n\n\tuart_xmit_advance(&sport->port, sport->dma_tx_bytes);\n\tsport->dma_tx_in_progress = false;\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&sport->port);\n\n\tif (waitqueue_active(&sport->dma_wait)) {\n\t\twake_up(&sport->dma_wait);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\tif (!lpuart_stopped_or_empty(&sport->port))\n\t\tlpuart_dma_tx(sport);\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\nstatic dma_addr_t lpuart_dma_datareg_addr(struct lpuart_port *sport)\n{\n\tswitch (sport->port.iotype) {\n\tcase UPIO_MEM32:\n\t\treturn sport->port.mapbase + UARTDATA;\n\tcase UPIO_MEM32BE:\n\t\treturn sport->port.mapbase + UARTDATA + sizeof(u32) - 1;\n\t}\n\treturn sport->port.mapbase + UARTDR;\n}\n\nstatic int lpuart_dma_tx_request(struct uart_port *port)\n{\n\tstruct lpuart_port *sport = container_of(port,\n\t\t\t\t\tstruct lpuart_port, port);\n\tstruct dma_slave_config dma_tx_sconfig = {};\n\tint ret;\n\n\tdma_tx_sconfig.dst_addr = lpuart_dma_datareg_addr(sport);\n\tdma_tx_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma_tx_sconfig.dst_maxburst = 1;\n\tdma_tx_sconfig.direction = DMA_MEM_TO_DEV;\n\tret = dmaengine_slave_config(sport->dma_tx_chan, &dma_tx_sconfig);\n\n\tif (ret) {\n\t\tdev_err(sport->port.dev,\n\t\t\t\t\"DMA slave config failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool lpuart_is_32(struct lpuart_port *sport)\n{\n\treturn sport->port.iotype == UPIO_MEM32 ||\n\t       sport->port.iotype ==  UPIO_MEM32BE;\n}\n\nstatic void lpuart_flush_buffer(struct uart_port *port)\n{\n\tstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\n\tstruct dma_chan *chan = sport->dma_tx_chan;\n\tu32 val;\n\n\tif (sport->lpuart_dma_tx_use) {\n\t\tif (sport->dma_tx_in_progress) {\n\t\t\tdma_unmap_sg(chan->device->dev, &sport->tx_sgl[0],\n\t\t\t\tsport->dma_tx_nents, DMA_TO_DEVICE);\n\t\t\tsport->dma_tx_in_progress = false;\n\t\t}\n\t\tdmaengine_terminate_async(chan);\n\t}\n\n\tif (lpuart_is_32(sport)) {\n\t\tval = lpuart32_read(&sport->port, UARTFIFO);\n\t\tval |= UARTFIFO_TXFLUSH | UARTFIFO_RXFLUSH;\n\t\tlpuart32_write(&sport->port, val, UARTFIFO);\n\t} else {\n\t\tval = readb(sport->port.membase + UARTCFIFO);\n\t\tval |= UARTCFIFO_TXFLUSH | UARTCFIFO_RXFLUSH;\n\t\twriteb(val, sport->port.membase + UARTCFIFO);\n\t}\n}\n\nstatic void lpuart_wait_bit_set(struct uart_port *port, unsigned int offset,\n\t\t\t\tu8 bit)\n{\n\twhile (!(readb(port->membase + offset) & bit))\n\t\tcpu_relax();\n}\n\nstatic void lpuart32_wait_bit_set(struct uart_port *port, unsigned int offset,\n\t\t\t\t  u32 bit)\n{\n\twhile (!(lpuart32_read(port, offset) & bit))\n\t\tcpu_relax();\n}\n\n#if defined(CONFIG_CONSOLE_POLL)\n\nstatic int lpuart_poll_init(struct uart_port *port)\n{\n\tstruct lpuart_port *sport = container_of(port,\n\t\t\t\t\tstruct lpuart_port, port);\n\tunsigned long flags;\n\tunsigned char temp;\n\n\tsport->port.fifosize = 0;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\t \n\twriteb(0, sport->port.membase + UARTCR2);\n\n\ttemp = readb(sport->port.membase + UARTPFIFO);\n\t \n\twriteb(temp | UARTPFIFO_RXFE | UARTPFIFO_TXFE,\n\t\t\tsport->port.membase + UARTPFIFO);\n\n\t \n\twriteb(UARTCFIFO_TXFLUSH | UARTCFIFO_RXFLUSH,\n\t\t\tsport->port.membase + UARTCFIFO);\n\n\t \n\tif (readb(sport->port.membase + UARTSR1) & UARTSR1_RDRF) {\n\t\treadb(sport->port.membase + UARTDR);\n\t\twriteb(UARTSFIFO_RXUF, sport->port.membase + UARTSFIFO);\n\t}\n\n\twriteb(0, sport->port.membase + UARTTWFIFO);\n\twriteb(1, sport->port.membase + UARTRWFIFO);\n\n\t \n\twriteb(UARTCR2_RE | UARTCR2_TE, sport->port.membase + UARTCR2);\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\treturn 0;\n}\n\nstatic void lpuart_poll_put_char(struct uart_port *port, unsigned char c)\n{\n\t \n\tlpuart_wait_bit_set(port, UARTSR1, UARTSR1_TDRE);\n\twriteb(c, port->membase + UARTDR);\n}\n\nstatic int lpuart_poll_get_char(struct uart_port *port)\n{\n\tif (!(readb(port->membase + UARTSR1) & UARTSR1_RDRF))\n\t\treturn NO_POLL_CHAR;\n\n\treturn readb(port->membase + UARTDR);\n}\n\nstatic int lpuart32_poll_init(struct uart_port *port)\n{\n\tunsigned long flags;\n\tstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\n\tu32 temp;\n\n\tsport->port.fifosize = 0;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\t \n\tlpuart32_write(&sport->port, 0, UARTCTRL);\n\n\ttemp = lpuart32_read(&sport->port, UARTFIFO);\n\n\t \n\tlpuart32_write(&sport->port, temp | UARTFIFO_RXFE | UARTFIFO_TXFE, UARTFIFO);\n\n\t \n\tlpuart32_write(&sport->port, UARTFIFO_TXFLUSH | UARTFIFO_RXFLUSH, UARTFIFO);\n\n\t \n\tif (lpuart32_read(&sport->port, UARTSTAT) & UARTSTAT_RDRF) {\n\t\tlpuart32_read(&sport->port, UARTDATA);\n\t\tlpuart32_write(&sport->port, UARTFIFO_RXUF, UARTFIFO);\n\t}\n\n\t \n\tlpuart32_write(&sport->port, UARTCTRL_RE | UARTCTRL_TE, UARTCTRL);\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\treturn 0;\n}\n\nstatic void lpuart32_poll_put_char(struct uart_port *port, unsigned char c)\n{\n\tlpuart32_wait_bit_set(port, UARTSTAT, UARTSTAT_TDRE);\n\tlpuart32_write(port, c, UARTDATA);\n}\n\nstatic int lpuart32_poll_get_char(struct uart_port *port)\n{\n\tif (!(lpuart32_read(port, UARTWATER) >> UARTWATER_RXCNT_OFF))\n\t\treturn NO_POLL_CHAR;\n\n\treturn lpuart32_read(port, UARTDATA);\n}\n#endif\n\nstatic inline void lpuart_transmit_buffer(struct lpuart_port *sport)\n{\n\tstruct uart_port *port = &sport->port;\n\tu8 ch;\n\n\tuart_port_tx(port, ch,\n\t\treadb(port->membase + UARTTCFIFO) < sport->txfifo_size,\n\t\twriteb(ch, port->membase + UARTDR));\n}\n\nstatic inline void lpuart32_transmit_buffer(struct lpuart_port *sport)\n{\n\tstruct circ_buf *xmit = &sport->port.state->xmit;\n\tunsigned long txcnt;\n\n\tif (sport->port.x_char) {\n\t\tlpuart32_write(&sport->port, sport->port.x_char, UARTDATA);\n\t\tsport->port.icount.tx++;\n\t\tsport->port.x_char = 0;\n\t\treturn;\n\t}\n\n\tif (lpuart_stopped_or_empty(&sport->port)) {\n\t\tlpuart32_stop_tx(&sport->port);\n\t\treturn;\n\t}\n\n\ttxcnt = lpuart32_read(&sport->port, UARTWATER);\n\ttxcnt = txcnt >> UARTWATER_TXCNT_OFF;\n\ttxcnt &= UARTWATER_COUNT_MASK;\n\twhile (!uart_circ_empty(xmit) && (txcnt < sport->txfifo_size)) {\n\t\tlpuart32_write(&sport->port, xmit->buf[xmit->tail], UARTDATA);\n\t\tuart_xmit_advance(&sport->port, 1);\n\t\ttxcnt = lpuart32_read(&sport->port, UARTWATER);\n\t\ttxcnt = txcnt >> UARTWATER_TXCNT_OFF;\n\t\ttxcnt &= UARTWATER_COUNT_MASK;\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&sport->port);\n\n\tif (uart_circ_empty(xmit))\n\t\tlpuart32_stop_tx(&sport->port);\n}\n\nstatic void lpuart_start_tx(struct uart_port *port)\n{\n\tstruct lpuart_port *sport = container_of(port,\n\t\t\tstruct lpuart_port, port);\n\tunsigned char temp;\n\n\ttemp = readb(port->membase + UARTCR2);\n\twriteb(temp | UARTCR2_TIE, port->membase + UARTCR2);\n\n\tif (sport->lpuart_dma_tx_use) {\n\t\tif (!lpuart_stopped_or_empty(port))\n\t\t\tlpuart_dma_tx(sport);\n\t} else {\n\t\tif (readb(port->membase + UARTSR1) & UARTSR1_TDRE)\n\t\t\tlpuart_transmit_buffer(sport);\n\t}\n}\n\nstatic void lpuart32_start_tx(struct uart_port *port)\n{\n\tstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\n\tunsigned long temp;\n\n\tif (sport->lpuart_dma_tx_use) {\n\t\tif (!lpuart_stopped_or_empty(port))\n\t\t\tlpuart_dma_tx(sport);\n\t} else {\n\t\ttemp = lpuart32_read(port, UARTCTRL);\n\t\tlpuart32_write(port, temp | UARTCTRL_TIE, UARTCTRL);\n\n\t\tif (lpuart32_read(port, UARTSTAT) & UARTSTAT_TDRE)\n\t\t\tlpuart32_transmit_buffer(sport);\n\t}\n}\n\nstatic void\nlpuart_uart_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)\n{\n\tswitch (state) {\n\tcase UART_PM_STATE_OFF:\n\t\tpm_runtime_mark_last_busy(port->dev);\n\t\tpm_runtime_put_autosuspend(port->dev);\n\t\tbreak;\n\tdefault:\n\t\tpm_runtime_get_sync(port->dev);\n\t\tbreak;\n\t}\n}\n\n \nstatic unsigned int lpuart_tx_empty(struct uart_port *port)\n{\n\tstruct lpuart_port *sport = container_of(port,\n\t\t\tstruct lpuart_port, port);\n\tunsigned char sr1 = readb(port->membase + UARTSR1);\n\tunsigned char sfifo = readb(port->membase + UARTSFIFO);\n\n\tif (sport->dma_tx_in_progress)\n\t\treturn 0;\n\n\tif (sr1 & UARTSR1_TC && sfifo & UARTSFIFO_TXEMPT)\n\t\treturn TIOCSER_TEMT;\n\n\treturn 0;\n}\n\nstatic unsigned int lpuart32_tx_empty(struct uart_port *port)\n{\n\tstruct lpuart_port *sport = container_of(port,\n\t\t\tstruct lpuart_port, port);\n\tunsigned long stat = lpuart32_read(port, UARTSTAT);\n\tunsigned long sfifo = lpuart32_read(port, UARTFIFO);\n\tunsigned long ctrl = lpuart32_read(port, UARTCTRL);\n\n\tif (sport->dma_tx_in_progress)\n\t\treturn 0;\n\n\t \n\tif ((stat & UARTSTAT_TC && sfifo & UARTFIFO_TXEMPT) || ctrl & UARTCTRL_SBK)\n\t\treturn TIOCSER_TEMT;\n\n\treturn 0;\n}\n\nstatic void lpuart_txint(struct lpuart_port *sport)\n{\n\tspin_lock(&sport->port.lock);\n\tlpuart_transmit_buffer(sport);\n\tspin_unlock(&sport->port.lock);\n}\n\nstatic void lpuart_rxint(struct lpuart_port *sport)\n{\n\tunsigned int flg, ignored = 0, overrun = 0;\n\tstruct tty_port *port = &sport->port.state->port;\n\tunsigned char rx, sr;\n\n\tspin_lock(&sport->port.lock);\n\n\twhile (!(readb(sport->port.membase + UARTSFIFO) & UARTSFIFO_RXEMPT)) {\n\t\tflg = TTY_NORMAL;\n\t\tsport->port.icount.rx++;\n\t\t \n\t\tsr = readb(sport->port.membase + UARTSR1);\n\t\trx = readb(sport->port.membase + UARTDR);\n\n\t\tif (uart_prepare_sysrq_char(&sport->port, rx))\n\t\t\tcontinue;\n\n\t\tif (sr & (UARTSR1_PE | UARTSR1_OR | UARTSR1_FE)) {\n\t\t\tif (sr & UARTSR1_PE)\n\t\t\t\tsport->port.icount.parity++;\n\t\t\telse if (sr & UARTSR1_FE)\n\t\t\t\tsport->port.icount.frame++;\n\n\t\t\tif (sr & UARTSR1_OR)\n\t\t\t\toverrun++;\n\n\t\t\tif (sr & sport->port.ignore_status_mask) {\n\t\t\t\tif (++ignored > 100)\n\t\t\t\t\tgoto out;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsr &= sport->port.read_status_mask;\n\n\t\t\tif (sr & UARTSR1_PE)\n\t\t\t\tflg = TTY_PARITY;\n\t\t\telse if (sr & UARTSR1_FE)\n\t\t\t\tflg = TTY_FRAME;\n\n\t\t\tif (sr & UARTSR1_OR)\n\t\t\t\tflg = TTY_OVERRUN;\n\n\t\t\tsport->port.sysrq = 0;\n\t\t}\n\n\t\tif (tty_insert_flip_char(port, rx, flg) == 0)\n\t\t\tsport->port.icount.buf_overrun++;\n\t}\n\nout:\n\tif (overrun) {\n\t\tsport->port.icount.overrun += overrun;\n\n\t\t \n\t\twriteb(UARTCFIFO_RXFLUSH, sport->port.membase + UARTCFIFO);\n\t\twriteb(UARTSFIFO_RXOF, sport->port.membase + UARTSFIFO);\n\t}\n\n\tuart_unlock_and_check_sysrq(&sport->port);\n\n\ttty_flip_buffer_push(port);\n}\n\nstatic void lpuart32_txint(struct lpuart_port *sport)\n{\n\tspin_lock(&sport->port.lock);\n\tlpuart32_transmit_buffer(sport);\n\tspin_unlock(&sport->port.lock);\n}\n\nstatic void lpuart32_rxint(struct lpuart_port *sport)\n{\n\tunsigned int flg, ignored = 0;\n\tstruct tty_port *port = &sport->port.state->port;\n\tunsigned long rx, sr;\n\tbool is_break;\n\n\tspin_lock(&sport->port.lock);\n\n\twhile (!(lpuart32_read(&sport->port, UARTFIFO) & UARTFIFO_RXEMPT)) {\n\t\tflg = TTY_NORMAL;\n\t\tsport->port.icount.rx++;\n\t\t \n\t\tsr = lpuart32_read(&sport->port, UARTSTAT);\n\t\trx = lpuart32_read(&sport->port, UARTDATA);\n\t\trx &= UARTDATA_MASK;\n\n\t\t \n\t\tis_break = (sr & UARTSTAT_FE) && !rx;\n\n\t\tif (is_break && uart_handle_break(&sport->port))\n\t\t\tcontinue;\n\n\t\tif (uart_prepare_sysrq_char(&sport->port, rx))\n\t\t\tcontinue;\n\n\t\tif (sr & (UARTSTAT_PE | UARTSTAT_OR | UARTSTAT_FE)) {\n\t\t\tif (sr & UARTSTAT_PE) {\n\t\t\t\tsport->port.icount.parity++;\n\t\t\t} else if (sr & UARTSTAT_FE) {\n\t\t\t\tif (is_break)\n\t\t\t\t\tsport->port.icount.brk++;\n\t\t\t\telse\n\t\t\t\t\tsport->port.icount.frame++;\n\t\t\t}\n\n\t\t\tif (sr & UARTSTAT_OR)\n\t\t\t\tsport->port.icount.overrun++;\n\n\t\t\tif (sr & sport->port.ignore_status_mask) {\n\t\t\t\tif (++ignored > 100)\n\t\t\t\t\tgoto out;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsr &= sport->port.read_status_mask;\n\n\t\t\tif (sr & UARTSTAT_PE) {\n\t\t\t\tflg = TTY_PARITY;\n\t\t\t} else if (sr & UARTSTAT_FE) {\n\t\t\t\tif (is_break)\n\t\t\t\t\tflg = TTY_BREAK;\n\t\t\t\telse\n\t\t\t\t\tflg = TTY_FRAME;\n\t\t\t}\n\n\t\t\tif (sr & UARTSTAT_OR)\n\t\t\t\tflg = TTY_OVERRUN;\n\t\t}\n\n\t\tif (sport->is_cs7)\n\t\t\trx &= 0x7F;\n\n\t\tif (tty_insert_flip_char(port, rx, flg) == 0)\n\t\t\tsport->port.icount.buf_overrun++;\n\t}\n\nout:\n\tuart_unlock_and_check_sysrq(&sport->port);\n\n\ttty_flip_buffer_push(port);\n}\n\nstatic irqreturn_t lpuart_int(int irq, void *dev_id)\n{\n\tstruct lpuart_port *sport = dev_id;\n\tunsigned char sts;\n\n\tsts = readb(sport->port.membase + UARTSR1);\n\n\t \n\tif (sts & UARTSR1_FE && sport->lpuart_dma_rx_use) {\n\t\treadb(sport->port.membase + UARTDR);\n\t\tuart_handle_break(&sport->port);\n\t\t \n\t\twriteb(UARTCFIFO_RXFLUSH, sport->port.membase + UARTCFIFO);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (sts & UARTSR1_RDRF && !sport->lpuart_dma_rx_use)\n\t\tlpuart_rxint(sport);\n\n\tif (sts & UARTSR1_TDRE && !sport->lpuart_dma_tx_use)\n\t\tlpuart_txint(sport);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline void lpuart_handle_sysrq_chars(struct uart_port *port,\n\t\t\t\t\t     unsigned char *p, int count)\n{\n\twhile (count--) {\n\t\tif (*p && uart_handle_sysrq_char(port, *p))\n\t\t\treturn;\n\t\tp++;\n\t}\n}\n\nstatic void lpuart_handle_sysrq(struct lpuart_port *sport)\n{\n\tstruct circ_buf *ring = &sport->rx_ring;\n\tint count;\n\n\tif (ring->head < ring->tail) {\n\t\tcount = sport->rx_sgl.length - ring->tail;\n\t\tlpuart_handle_sysrq_chars(&sport->port,\n\t\t\t\t\t  ring->buf + ring->tail, count);\n\t\tring->tail = 0;\n\t}\n\n\tif (ring->head > ring->tail) {\n\t\tcount = ring->head - ring->tail;\n\t\tlpuart_handle_sysrq_chars(&sport->port,\n\t\t\t\t\t  ring->buf + ring->tail, count);\n\t\tring->tail = ring->head;\n\t}\n}\n\nstatic int lpuart_tty_insert_flip_string(struct tty_port *port,\n\tunsigned char *chars, size_t size, bool is_cs7)\n{\n\tint i;\n\n\tif (is_cs7)\n\t\tfor (i = 0; i < size; i++)\n\t\t\tchars[i] &= 0x7F;\n\treturn tty_insert_flip_string(port, chars, size);\n}\n\nstatic void lpuart_copy_rx_to_tty(struct lpuart_port *sport)\n{\n\tstruct tty_port *port = &sport->port.state->port;\n\tstruct dma_tx_state state;\n\tenum dma_status dmastat;\n\tstruct dma_chan *chan = sport->dma_rx_chan;\n\tstruct circ_buf *ring = &sport->rx_ring;\n\tunsigned long flags;\n\tint count, copied;\n\n\tif (lpuart_is_32(sport)) {\n\t\tunsigned long sr = lpuart32_read(&sport->port, UARTSTAT);\n\n\t\tif (sr & (UARTSTAT_PE | UARTSTAT_FE)) {\n\t\t\t \n\t\t\tlpuart32_write(&sport->port, sr, UARTSTAT);\n\n\t\t\tif (sr & UARTSTAT_PE)\n\t\t\t\tsport->port.icount.parity++;\n\t\t\telse if (sr & UARTSTAT_FE)\n\t\t\t\tsport->port.icount.frame++;\n\t\t}\n\t} else {\n\t\tunsigned char sr = readb(sport->port.membase + UARTSR1);\n\n\t\tif (sr & (UARTSR1_PE | UARTSR1_FE)) {\n\t\t\tunsigned char cr2;\n\n\t\t\t \n\t\t\tcr2 = readb(sport->port.membase + UARTCR2);\n\t\t\tcr2 &= ~UARTCR2_RE;\n\t\t\twriteb(cr2, sport->port.membase + UARTCR2);\n\n\t\t\t \n\t\t\treadb(sport->port.membase + UARTDR);\n\n\t\t\tif (sr & UARTSR1_PE)\n\t\t\t\tsport->port.icount.parity++;\n\t\t\telse if (sr & UARTSR1_FE)\n\t\t\t\tsport->port.icount.frame++;\n\t\t\t \n\t\t\tif (readb(sport->port.membase + UARTSFIFO) &\n\t\t\t    UARTSFIFO_RXUF) {\n\t\t\t\twriteb(UARTSFIFO_RXUF,\n\t\t\t\t       sport->port.membase + UARTSFIFO);\n\t\t\t\twriteb(UARTCFIFO_RXFLUSH,\n\t\t\t\t       sport->port.membase + UARTCFIFO);\n\t\t\t}\n\n\t\t\tcr2 |= UARTCR2_RE;\n\t\t\twriteb(cr2, sport->port.membase + UARTCR2);\n\t\t}\n\t}\n\n\tasync_tx_ack(sport->dma_rx_desc);\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\tdmastat = dmaengine_tx_status(chan, sport->dma_rx_cookie, &state);\n\tif (dmastat == DMA_ERROR) {\n\t\tdev_err(sport->port.dev, \"Rx DMA transfer failed!\\n\");\n\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tdma_sync_sg_for_cpu(chan->device->dev, &sport->rx_sgl, 1,\n\t\t\t    DMA_FROM_DEVICE);\n\n\t \n\tring->head = sport->rx_sgl.length - state.residue;\n\tBUG_ON(ring->head > sport->rx_sgl.length);\n\n\t \n\tif (sport->port.sysrq) {\n\t\tlpuart_handle_sysrq(sport);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (ring->head < ring->tail) {\n\t\tcount = sport->rx_sgl.length - ring->tail;\n\n\t\tcopied = lpuart_tty_insert_flip_string(port, ring->buf + ring->tail,\n\t\t\t\t\tcount, sport->is_cs7);\n\t\tif (copied != count)\n\t\t\tsport->port.icount.buf_overrun++;\n\t\tring->tail = 0;\n\t\tsport->port.icount.rx += copied;\n\t}\n\n\t \n\tif (ring->tail < ring->head) {\n\t\tcount = ring->head - ring->tail;\n\t\tcopied = lpuart_tty_insert_flip_string(port, ring->buf + ring->tail,\n\t\t\t\t\tcount, sport->is_cs7);\n\t\tif (copied != count)\n\t\t\tsport->port.icount.buf_overrun++;\n\t\t \n\t\tif (ring->head >= sport->rx_sgl.length)\n\t\t\tring->head = 0;\n\t\tring->tail = ring->head;\n\t\tsport->port.icount.rx += copied;\n\t}\n\n\tsport->last_residue = state.residue;\n\nexit:\n\tdma_sync_sg_for_device(chan->device->dev, &sport->rx_sgl, 1,\n\t\t\t       DMA_FROM_DEVICE);\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\ttty_flip_buffer_push(port);\n\tif (!sport->dma_idle_int)\n\t\tmod_timer(&sport->lpuart_timer, jiffies + sport->dma_rx_timeout);\n}\n\nstatic void lpuart_dma_rx_complete(void *arg)\n{\n\tstruct lpuart_port *sport = arg;\n\n\tlpuart_copy_rx_to_tty(sport);\n}\n\nstatic void lpuart32_dma_idleint(struct lpuart_port *sport)\n{\n\tenum dma_status dmastat;\n\tstruct dma_chan *chan = sport->dma_rx_chan;\n\tstruct circ_buf *ring = &sport->rx_ring;\n\tstruct dma_tx_state state;\n\tint count = 0;\n\n\tdmastat = dmaengine_tx_status(chan, sport->dma_rx_cookie, &state);\n\tif (dmastat == DMA_ERROR) {\n\t\tdev_err(sport->port.dev, \"Rx DMA transfer failed!\\n\");\n\t\treturn;\n\t}\n\n\tring->head = sport->rx_sgl.length - state.residue;\n\tcount = CIRC_CNT(ring->head, ring->tail, sport->rx_sgl.length);\n\n\t \n\tif (count)\n\t\tlpuart_copy_rx_to_tty(sport);\n}\n\nstatic irqreturn_t lpuart32_int(int irq, void *dev_id)\n{\n\tstruct lpuart_port *sport = dev_id;\n\tunsigned long sts, rxcount;\n\n\tsts = lpuart32_read(&sport->port, UARTSTAT);\n\trxcount = lpuart32_read(&sport->port, UARTWATER);\n\trxcount = rxcount >> UARTWATER_RXCNT_OFF;\n\n\tif ((sts & UARTSTAT_RDRF || rxcount > 0) && !sport->lpuart_dma_rx_use)\n\t\tlpuart32_rxint(sport);\n\n\tif ((sts & UARTSTAT_TDRE) && !sport->lpuart_dma_tx_use)\n\t\tlpuart32_txint(sport);\n\n\tif ((sts & UARTSTAT_IDLE) && sport->lpuart_dma_rx_use && sport->dma_idle_int)\n\t\tlpuart32_dma_idleint(sport);\n\n\tlpuart32_write(&sport->port, sts, UARTSTAT);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void lpuart_timer_func(struct timer_list *t)\n{\n\tstruct lpuart_port *sport = from_timer(sport, t, lpuart_timer);\n\tenum dma_status dmastat;\n\tstruct dma_chan *chan = sport->dma_rx_chan;\n\tstruct circ_buf *ring = &sport->rx_ring;\n\tstruct dma_tx_state state;\n\tunsigned long flags;\n\tint count;\n\n\tdmastat = dmaengine_tx_status(chan, sport->dma_rx_cookie, &state);\n\tif (dmastat == DMA_ERROR) {\n\t\tdev_err(sport->port.dev, \"Rx DMA transfer failed!\\n\");\n\t\treturn;\n\t}\n\n\tring->head = sport->rx_sgl.length - state.residue;\n\tcount = CIRC_CNT(ring->head, ring->tail, sport->rx_sgl.length);\n\n\t \n\tif ((count != 0) && (sport->last_residue == state.residue))\n\t\tlpuart_copy_rx_to_tty(sport);\n\telse\n\t\tmod_timer(&sport->lpuart_timer,\n\t\t\t  jiffies + sport->dma_rx_timeout);\n\n\tif (spin_trylock_irqsave(&sport->port.lock, flags)) {\n\t\tsport->last_residue = state.residue;\n\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\t}\n}\n\nstatic inline int lpuart_start_rx_dma(struct lpuart_port *sport)\n{\n\tstruct dma_slave_config dma_rx_sconfig = {};\n\tstruct circ_buf *ring = &sport->rx_ring;\n\tint ret, nent;\n\tstruct tty_port *port = &sport->port.state->port;\n\tstruct tty_struct *tty = port->tty;\n\tstruct ktermios *termios = &tty->termios;\n\tstruct dma_chan *chan = sport->dma_rx_chan;\n\tunsigned int bits = tty_get_frame_size(termios->c_cflag);\n\tunsigned int baud = tty_get_baud_rate(tty);\n\n\t \n\tsport->rx_dma_rng_buf_len = (DMA_RX_TIMEOUT * baud /  bits / 1000) * 2;\n\tsport->rx_dma_rng_buf_len = (1 << fls(sport->rx_dma_rng_buf_len));\n\tsport->rx_dma_rng_buf_len = max_t(int,\n\t\t\t\t\t  sport->rxfifo_size * 2,\n\t\t\t\t\t  sport->rx_dma_rng_buf_len);\n\t \n\tif (sport->rx_dma_rng_buf_len < 16)\n\t\tsport->rx_dma_rng_buf_len = 16;\n\n\tsport->last_residue = 0;\n\tsport->dma_rx_timeout = max(nsecs_to_jiffies(\n\t\tsport->port.frame_time * DMA_RX_IDLE_CHARS), 1UL);\n\n\tring->buf = kzalloc(sport->rx_dma_rng_buf_len, GFP_ATOMIC);\n\tif (!ring->buf)\n\t\treturn -ENOMEM;\n\n\tsg_init_one(&sport->rx_sgl, ring->buf, sport->rx_dma_rng_buf_len);\n\tnent = dma_map_sg(chan->device->dev, &sport->rx_sgl, 1,\n\t\t\t  DMA_FROM_DEVICE);\n\n\tif (!nent) {\n\t\tdev_err(sport->port.dev, \"DMA Rx mapping error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdma_rx_sconfig.src_addr = lpuart_dma_datareg_addr(sport);\n\tdma_rx_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma_rx_sconfig.src_maxburst = 1;\n\tdma_rx_sconfig.direction = DMA_DEV_TO_MEM;\n\tret = dmaengine_slave_config(chan, &dma_rx_sconfig);\n\n\tif (ret < 0) {\n\t\tdev_err(sport->port.dev,\n\t\t\t\t\"DMA Rx slave config failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsport->dma_rx_desc = dmaengine_prep_dma_cyclic(chan,\n\t\t\t\t sg_dma_address(&sport->rx_sgl),\n\t\t\t\t sport->rx_sgl.length,\n\t\t\t\t sport->rx_sgl.length / 2,\n\t\t\t\t DMA_DEV_TO_MEM,\n\t\t\t\t DMA_PREP_INTERRUPT);\n\tif (!sport->dma_rx_desc) {\n\t\tdev_err(sport->port.dev, \"Cannot prepare cyclic DMA\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tsport->dma_rx_desc->callback = lpuart_dma_rx_complete;\n\tsport->dma_rx_desc->callback_param = sport;\n\tsport->dma_rx_cookie = dmaengine_submit(sport->dma_rx_desc);\n\tdma_async_issue_pending(chan);\n\n\tif (lpuart_is_32(sport)) {\n\t\tunsigned long temp = lpuart32_read(&sport->port, UARTBAUD);\n\n\t\tlpuart32_write(&sport->port, temp | UARTBAUD_RDMAE, UARTBAUD);\n\n\t\tif (sport->dma_idle_int) {\n\t\t\tunsigned long ctrl = lpuart32_read(&sport->port, UARTCTRL);\n\n\t\t\tlpuart32_write(&sport->port, ctrl | UARTCTRL_ILIE, UARTCTRL);\n\t\t}\n\t} else {\n\t\twriteb(readb(sport->port.membase + UARTCR5) | UARTCR5_RDMAS,\n\t\t       sport->port.membase + UARTCR5);\n\t}\n\n\treturn 0;\n}\n\nstatic void lpuart_dma_rx_free(struct uart_port *port)\n{\n\tstruct lpuart_port *sport = container_of(port,\n\t\t\t\t\tstruct lpuart_port, port);\n\tstruct dma_chan *chan = sport->dma_rx_chan;\n\n\tdmaengine_terminate_sync(chan);\n\tif (!sport->dma_idle_int)\n\t\tdel_timer_sync(&sport->lpuart_timer);\n\n\tdma_unmap_sg(chan->device->dev, &sport->rx_sgl, 1, DMA_FROM_DEVICE);\n\tkfree(sport->rx_ring.buf);\n\tsport->rx_ring.tail = 0;\n\tsport->rx_ring.head = 0;\n\tsport->dma_rx_desc = NULL;\n\tsport->dma_rx_cookie = -EINVAL;\n}\n\nstatic int lpuart_config_rs485(struct uart_port *port, struct ktermios *termios,\n\t\t\tstruct serial_rs485 *rs485)\n{\n\tstruct lpuart_port *sport = container_of(port,\n\t\t\tstruct lpuart_port, port);\n\n\tu8 modem = readb(sport->port.membase + UARTMODEM) &\n\t\t~(UARTMODEM_TXRTSPOL | UARTMODEM_TXRTSE);\n\twriteb(modem, sport->port.membase + UARTMODEM);\n\n\tif (rs485->flags & SER_RS485_ENABLED) {\n\t\t \n\t\tmodem |= UARTMODEM_TXRTSE;\n\n\t\t \n\t\tif (rs485->flags & SER_RS485_RTS_ON_SEND)\n\t\t\tmodem |= UARTMODEM_TXRTSPOL;\n\t\telse if (rs485->flags & SER_RS485_RTS_AFTER_SEND)\n\t\t\tmodem &= ~UARTMODEM_TXRTSPOL;\n\t}\n\n\twriteb(modem, sport->port.membase + UARTMODEM);\n\treturn 0;\n}\n\nstatic int lpuart32_config_rs485(struct uart_port *port, struct ktermios *termios,\n\t\t\tstruct serial_rs485 *rs485)\n{\n\tstruct lpuart_port *sport = container_of(port,\n\t\t\tstruct lpuart_port, port);\n\n\tunsigned long modem = lpuart32_read(&sport->port, UARTMODIR)\n\t\t\t\t& ~(UARTMODIR_TXRTSPOL | UARTMODIR_TXRTSE);\n\tlpuart32_write(&sport->port, modem, UARTMODIR);\n\n\tif (rs485->flags & SER_RS485_ENABLED) {\n\t\t \n\t\tmodem |= UARTMODIR_TXRTSE;\n\n\t\t \n\t\tif (rs485->flags & SER_RS485_RTS_ON_SEND)\n\t\t\tmodem |= UARTMODIR_TXRTSPOL;\n\t\telse if (rs485->flags & SER_RS485_RTS_AFTER_SEND)\n\t\t\tmodem &= ~UARTMODIR_TXRTSPOL;\n\t}\n\n\tlpuart32_write(&sport->port, modem, UARTMODIR);\n\treturn 0;\n}\n\nstatic unsigned int lpuart_get_mctrl(struct uart_port *port)\n{\n\tunsigned int mctrl = 0;\n\tu8 reg;\n\n\treg = readb(port->membase + UARTCR1);\n\tif (reg & UARTCR1_LOOPS)\n\t\tmctrl |= TIOCM_LOOP;\n\n\treturn mctrl;\n}\n\nstatic unsigned int lpuart32_get_mctrl(struct uart_port *port)\n{\n\tunsigned int mctrl = TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n\tu32 reg;\n\n\treg = lpuart32_read(port, UARTCTRL);\n\tif (reg & UARTCTRL_LOOPS)\n\t\tmctrl |= TIOCM_LOOP;\n\n\treturn mctrl;\n}\n\nstatic void lpuart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tu8 reg;\n\n\treg = readb(port->membase + UARTCR1);\n\n\t \n\treg &= ~(UARTCR1_LOOPS | UARTCR1_RSRC);\n\tif (mctrl & TIOCM_LOOP)\n\t\treg |= UARTCR1_LOOPS;\n\n\twriteb(reg, port->membase + UARTCR1);\n}\n\nstatic void lpuart32_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tu32 reg;\n\n\treg = lpuart32_read(port, UARTCTRL);\n\n\t \n\treg &= ~(UARTCTRL_LOOPS | UARTCTRL_RSRC);\n\tif (mctrl & TIOCM_LOOP)\n\t\treg |= UARTCTRL_LOOPS;\n\n\tlpuart32_write(port, reg, UARTCTRL);\n}\n\nstatic void lpuart_break_ctl(struct uart_port *port, int break_state)\n{\n\tunsigned char temp;\n\n\ttemp = readb(port->membase + UARTCR2) & ~UARTCR2_SBK;\n\n\tif (break_state != 0)\n\t\ttemp |= UARTCR2_SBK;\n\n\twriteb(temp, port->membase + UARTCR2);\n}\n\nstatic void lpuart32_break_ctl(struct uart_port *port, int break_state)\n{\n\tunsigned long temp;\n\n\ttemp = lpuart32_read(port, UARTCTRL);\n\n\t \n\tif (break_state != 0) {\n\t\t \n\t\ttemp &= ~UARTCTRL_TE;\n\t\tlpuart32_write(port, temp, UARTCTRL);\n\t\ttemp |= UARTCTRL_TXINV;\n\t\tlpuart32_write(port, temp, UARTCTRL);\n\t} else {\n\t\t \n\t\ttemp &= ~UARTCTRL_TXINV;\n\t\tlpuart32_write(port, temp, UARTCTRL);\n\t\ttemp |= UARTCTRL_TE;\n\t\tlpuart32_write(port, temp, UARTCTRL);\n\t}\n}\n\nstatic void lpuart_setup_watermark(struct lpuart_port *sport)\n{\n\tunsigned char val, cr2;\n\tunsigned char cr2_saved;\n\n\tcr2 = readb(sport->port.membase + UARTCR2);\n\tcr2_saved = cr2;\n\tcr2 &= ~(UARTCR2_TIE | UARTCR2_TCIE | UARTCR2_TE |\n\t\t\tUARTCR2_RIE | UARTCR2_RE);\n\twriteb(cr2, sport->port.membase + UARTCR2);\n\n\tval = readb(sport->port.membase + UARTPFIFO);\n\twriteb(val | UARTPFIFO_TXFE | UARTPFIFO_RXFE,\n\t\t\tsport->port.membase + UARTPFIFO);\n\n\t \n\twriteb(UARTCFIFO_TXFLUSH | UARTCFIFO_RXFLUSH,\n\t\t\tsport->port.membase + UARTCFIFO);\n\n\t \n\tif (readb(sport->port.membase + UARTSR1) & UARTSR1_RDRF) {\n\t\treadb(sport->port.membase + UARTDR);\n\t\twriteb(UARTSFIFO_RXUF, sport->port.membase + UARTSFIFO);\n\t}\n\n\tif (uart_console(&sport->port))\n\t\tsport->rx_watermark = 1;\n\twriteb(0, sport->port.membase + UARTTWFIFO);\n\twriteb(sport->rx_watermark, sport->port.membase + UARTRWFIFO);\n\n\t \n\twriteb(cr2_saved, sport->port.membase + UARTCR2);\n}\n\nstatic void lpuart_setup_watermark_enable(struct lpuart_port *sport)\n{\n\tunsigned char cr2;\n\n\tlpuart_setup_watermark(sport);\n\n\tcr2 = readb(sport->port.membase + UARTCR2);\n\tcr2 |= UARTCR2_RIE | UARTCR2_RE | UARTCR2_TE;\n\twriteb(cr2, sport->port.membase + UARTCR2);\n}\n\nstatic void lpuart32_setup_watermark(struct lpuart_port *sport)\n{\n\tunsigned long val, ctrl;\n\tunsigned long ctrl_saved;\n\n\tctrl = lpuart32_read(&sport->port, UARTCTRL);\n\tctrl_saved = ctrl;\n\tctrl &= ~(UARTCTRL_TIE | UARTCTRL_TCIE | UARTCTRL_TE |\n\t\t\tUARTCTRL_RIE | UARTCTRL_RE | UARTCTRL_ILIE);\n\tlpuart32_write(&sport->port, ctrl, UARTCTRL);\n\n\t \n\tval = lpuart32_read(&sport->port, UARTFIFO);\n\tval |= UARTFIFO_TXFE | UARTFIFO_RXFE;\n\tval |= UARTFIFO_TXFLUSH | UARTFIFO_RXFLUSH;\n\tval |= FIELD_PREP(UARTFIFO_RXIDEN, 0x3);\n\tlpuart32_write(&sport->port, val, UARTFIFO);\n\n\t \n\tif (uart_console(&sport->port))\n\t\tsport->rx_watermark = 1;\n\tval = (sport->rx_watermark << UARTWATER_RXWATER_OFF) |\n\t      (0x0 << UARTWATER_TXWATER_OFF);\n\tlpuart32_write(&sport->port, val, UARTWATER);\n\n\t \n\tif (!uart_console(&sport->port)) {\n\t\tval = lpuart32_read(&sport->port, UARTMODIR);\n\t\tval |= FIELD_PREP(UARTMODIR_RTSWATER, sport->rxfifo_size >> 1);\n\t\tlpuart32_write(&sport->port, val, UARTMODIR);\n\t}\n\n\t \n\tlpuart32_write(&sport->port, ctrl_saved, UARTCTRL);\n}\n\nstatic void lpuart32_setup_watermark_enable(struct lpuart_port *sport)\n{\n\tu32 temp;\n\n\tlpuart32_setup_watermark(sport);\n\n\ttemp = lpuart32_read(&sport->port, UARTCTRL);\n\ttemp |= UARTCTRL_RE | UARTCTRL_TE;\n\ttemp |= FIELD_PREP(UARTCTRL_IDLECFG, 0x7);\n\tlpuart32_write(&sport->port, temp, UARTCTRL);\n}\n\nstatic void rx_dma_timer_init(struct lpuart_port *sport)\n{\n\tif (sport->dma_idle_int)\n\t\treturn;\n\n\ttimer_setup(&sport->lpuart_timer, lpuart_timer_func, 0);\n\tsport->lpuart_timer.expires = jiffies + sport->dma_rx_timeout;\n\tadd_timer(&sport->lpuart_timer);\n}\n\nstatic void lpuart_request_dma(struct lpuart_port *sport)\n{\n\tsport->dma_tx_chan = dma_request_chan(sport->port.dev, \"tx\");\n\tif (IS_ERR(sport->dma_tx_chan)) {\n\t\tdev_dbg_once(sport->port.dev,\n\t\t\t     \"DMA tx channel request failed, operating without tx DMA (%ld)\\n\",\n\t\t\t     PTR_ERR(sport->dma_tx_chan));\n\t\tsport->dma_tx_chan = NULL;\n\t}\n\n\tsport->dma_rx_chan = dma_request_chan(sport->port.dev, \"rx\");\n\tif (IS_ERR(sport->dma_rx_chan)) {\n\t\tdev_dbg_once(sport->port.dev,\n\t\t\t     \"DMA rx channel request failed, operating without rx DMA (%ld)\\n\",\n\t\t\t     PTR_ERR(sport->dma_rx_chan));\n\t\tsport->dma_rx_chan = NULL;\n\t}\n}\n\nstatic void lpuart_tx_dma_startup(struct lpuart_port *sport)\n{\n\tu32 uartbaud;\n\tint ret;\n\n\tif (uart_console(&sport->port))\n\t\tgoto err;\n\n\tif (!sport->dma_tx_chan)\n\t\tgoto err;\n\n\tret = lpuart_dma_tx_request(&sport->port);\n\tif (ret)\n\t\tgoto err;\n\n\tinit_waitqueue_head(&sport->dma_wait);\n\tsport->lpuart_dma_tx_use = true;\n\tif (lpuart_is_32(sport)) {\n\t\tuartbaud = lpuart32_read(&sport->port, UARTBAUD);\n\t\tlpuart32_write(&sport->port,\n\t\t\t       uartbaud | UARTBAUD_TDMAE, UARTBAUD);\n\t} else {\n\t\twriteb(readb(sport->port.membase + UARTCR5) |\n\t\t       UARTCR5_TDMAS, sport->port.membase + UARTCR5);\n\t}\n\n\treturn;\n\nerr:\n\tsport->lpuart_dma_tx_use = false;\n}\n\nstatic void lpuart_rx_dma_startup(struct lpuart_port *sport)\n{\n\tint ret;\n\tunsigned char cr3;\n\n\tif (uart_console(&sport->port))\n\t\tgoto err;\n\n\tif (!sport->dma_rx_chan)\n\t\tgoto err;\n\n\t \n\tsport->dma_rx_timeout = msecs_to_jiffies(DMA_RX_TIMEOUT);\n\n\tret = lpuart_start_rx_dma(sport);\n\tif (ret)\n\t\tgoto err;\n\n\tif (!sport->dma_rx_timeout)\n\t\tsport->dma_rx_timeout = 1;\n\n\tsport->lpuart_dma_rx_use = true;\n\trx_dma_timer_init(sport);\n\n\tif (sport->port.has_sysrq && !lpuart_is_32(sport)) {\n\t\tcr3 = readb(sport->port.membase + UARTCR3);\n\t\tcr3 |= UARTCR3_FEIE;\n\t\twriteb(cr3, sport->port.membase + UARTCR3);\n\t}\n\n\treturn;\n\nerr:\n\tsport->lpuart_dma_rx_use = false;\n}\n\nstatic void lpuart_hw_setup(struct lpuart_port *sport)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\tlpuart_setup_watermark_enable(sport);\n\n\tlpuart_rx_dma_startup(sport);\n\tlpuart_tx_dma_startup(sport);\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\nstatic int lpuart_startup(struct uart_port *port)\n{\n\tstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\n\tunsigned char temp;\n\n\t \n\ttemp = readb(sport->port.membase + UARTPFIFO);\n\n\tsport->txfifo_size = UARTFIFO_DEPTH((temp >> UARTPFIFO_TXSIZE_OFF) &\n\t\t\t\t\t    UARTPFIFO_FIFOSIZE_MASK);\n\tsport->port.fifosize = sport->txfifo_size;\n\n\tsport->rxfifo_size = UARTFIFO_DEPTH((temp >> UARTPFIFO_RXSIZE_OFF) &\n\t\t\t\t\t    UARTPFIFO_FIFOSIZE_MASK);\n\n\tlpuart_request_dma(sport);\n\tlpuart_hw_setup(sport);\n\n\treturn 0;\n}\n\nstatic void lpuart32_hw_disable(struct lpuart_port *sport)\n{\n\tunsigned long temp;\n\n\ttemp = lpuart32_read(&sport->port, UARTCTRL);\n\ttemp &= ~(UARTCTRL_RIE | UARTCTRL_ILIE | UARTCTRL_RE |\n\t\t  UARTCTRL_TIE | UARTCTRL_TE);\n\tlpuart32_write(&sport->port, temp, UARTCTRL);\n}\n\nstatic void lpuart32_configure(struct lpuart_port *sport)\n{\n\tunsigned long temp;\n\n\ttemp = lpuart32_read(&sport->port, UARTCTRL);\n\tif (!sport->lpuart_dma_rx_use)\n\t\ttemp |= UARTCTRL_RIE | UARTCTRL_ILIE;\n\tif (!sport->lpuart_dma_tx_use)\n\t\ttemp |= UARTCTRL_TIE;\n\tlpuart32_write(&sport->port, temp, UARTCTRL);\n}\n\nstatic void lpuart32_hw_setup(struct lpuart_port *sport)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\tlpuart32_hw_disable(sport);\n\n\tlpuart_rx_dma_startup(sport);\n\tlpuart_tx_dma_startup(sport);\n\n\tlpuart32_setup_watermark_enable(sport);\n\tlpuart32_configure(sport);\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\nstatic int lpuart32_startup(struct uart_port *port)\n{\n\tstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\n\tunsigned long temp;\n\n\t \n\ttemp = lpuart32_read(&sport->port, UARTFIFO);\n\n\tsport->txfifo_size = UARTFIFO_DEPTH((temp >> UARTFIFO_TXSIZE_OFF) &\n\t\t\t\t\t    UARTFIFO_FIFOSIZE_MASK);\n\tsport->port.fifosize = sport->txfifo_size;\n\n\tsport->rxfifo_size = UARTFIFO_DEPTH((temp >> UARTFIFO_RXSIZE_OFF) &\n\t\t\t\t\t    UARTFIFO_FIFOSIZE_MASK);\n\n\t \n\tif (is_layerscape_lpuart(sport)) {\n\t\tsport->rxfifo_size = 16;\n\t\tsport->txfifo_size = 16;\n\t\tsport->port.fifosize = sport->txfifo_size;\n\t}\n\n\tlpuart_request_dma(sport);\n\tlpuart32_hw_setup(sport);\n\n\treturn 0;\n}\n\nstatic void lpuart_dma_shutdown(struct lpuart_port *sport)\n{\n\tif (sport->lpuart_dma_rx_use) {\n\t\tlpuart_dma_rx_free(&sport->port);\n\t\tsport->lpuart_dma_rx_use = false;\n\t}\n\n\tif (sport->lpuart_dma_tx_use) {\n\t\tif (wait_event_interruptible_timeout(sport->dma_wait,\n\t\t\t!sport->dma_tx_in_progress, msecs_to_jiffies(300)) <= 0) {\n\t\t\tsport->dma_tx_in_progress = false;\n\t\t\tdmaengine_terminate_sync(sport->dma_tx_chan);\n\t\t}\n\t\tsport->lpuart_dma_tx_use = false;\n\t}\n\n\tif (sport->dma_tx_chan)\n\t\tdma_release_channel(sport->dma_tx_chan);\n\tif (sport->dma_rx_chan)\n\t\tdma_release_channel(sport->dma_rx_chan);\n}\n\nstatic void lpuart_shutdown(struct uart_port *port)\n{\n\tstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\n\tunsigned char temp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\ttemp = readb(port->membase + UARTCR2);\n\ttemp &= ~(UARTCR2_TE | UARTCR2_RE |\n\t\t\tUARTCR2_TIE | UARTCR2_TCIE | UARTCR2_RIE);\n\twriteb(temp, port->membase + UARTCR2);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tlpuart_dma_shutdown(sport);\n}\n\nstatic void lpuart32_shutdown(struct uart_port *port)\n{\n\tstruct lpuart_port *sport =\n\t\tcontainer_of(port, struct lpuart_port, port);\n\tunsigned long temp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\ttemp = lpuart32_read(&sport->port, UARTSTAT);\n\tlpuart32_write(&sport->port, temp, UARTSTAT);\n\n\t \n\ttemp = lpuart32_read(port, UARTBAUD);\n\ttemp &= ~(UARTBAUD_TDMAE | UARTBAUD_RDMAE);\n\tlpuart32_write(port, temp, UARTBAUD);\n\n\t \n\ttemp = lpuart32_read(port, UARTCTRL);\n\ttemp &= ~(UARTCTRL_TE | UARTCTRL_RE | UARTCTRL_ILIE |\n\t\t\tUARTCTRL_TIE | UARTCTRL_TCIE | UARTCTRL_RIE | UARTCTRL_SBK);\n\tlpuart32_write(port, temp, UARTCTRL);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tlpuart_dma_shutdown(sport);\n}\n\nstatic void\nlpuart_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t   const struct ktermios *old)\n{\n\tstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\n\tunsigned long flags;\n\tunsigned char cr1, old_cr1, old_cr2, cr3, cr4, bdh, modem;\n\tunsigned int  baud;\n\tunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\n\tunsigned int sbr, brfa;\n\n\tcr1 = old_cr1 = readb(sport->port.membase + UARTCR1);\n\told_cr2 = readb(sport->port.membase + UARTCR2);\n\tcr3 = readb(sport->port.membase + UARTCR3);\n\tcr4 = readb(sport->port.membase + UARTCR4);\n\tbdh = readb(sport->port.membase + UARTBDH);\n\tmodem = readb(sport->port.membase + UARTMODEM);\n\t \n\twhile ((termios->c_cflag & CSIZE) != CS8 &&\n\t\t(termios->c_cflag & CSIZE) != CS7) {\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= old_csize;\n\t\told_csize = CS8;\n\t}\n\n\tif ((termios->c_cflag & CSIZE) == CS8 ||\n\t\t(termios->c_cflag & CSIZE) == CS7)\n\t\tcr1 = old_cr1 & ~UARTCR1_M;\n\n\tif (termios->c_cflag & CMSPAR) {\n\t\tif ((termios->c_cflag & CSIZE) != CS8) {\n\t\t\ttermios->c_cflag &= ~CSIZE;\n\t\t\ttermios->c_cflag |= CS8;\n\t\t}\n\t\tcr1 |= UARTCR1_M;\n\t}\n\n\t \n\tif (sport->port.rs485.flags & SER_RS485_ENABLED)\n\t\ttermios->c_cflag &= ~CRTSCTS;\n\n\tif (termios->c_cflag & CRTSCTS)\n\t\tmodem |= UARTMODEM_RXRTSE | UARTMODEM_TXCTSE;\n\telse\n\t\tmodem &= ~(UARTMODEM_RXRTSE | UARTMODEM_TXCTSE);\n\n\ttermios->c_cflag &= ~CSTOPB;\n\n\t \n\tif ((termios->c_cflag & CSIZE) == CS7)\n\t\ttermios->c_cflag |= PARENB;\n\n\tif (termios->c_cflag & PARENB) {\n\t\tif (termios->c_cflag & CMSPAR) {\n\t\t\tcr1 &= ~UARTCR1_PE;\n\t\t\tif (termios->c_cflag & PARODD)\n\t\t\t\tcr3 |= UARTCR3_T8;\n\t\t\telse\n\t\t\t\tcr3 &= ~UARTCR3_T8;\n\t\t} else {\n\t\t\tcr1 |= UARTCR1_PE;\n\t\t\tif ((termios->c_cflag & CSIZE) == CS8)\n\t\t\t\tcr1 |= UARTCR1_M;\n\t\t\tif (termios->c_cflag & PARODD)\n\t\t\t\tcr1 |= UARTCR1_PT;\n\t\t\telse\n\t\t\t\tcr1 &= ~UARTCR1_PT;\n\t\t}\n\t} else {\n\t\tcr1 &= ~UARTCR1_PE;\n\t}\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 50, port->uartclk / 16);\n\n\t \n\tif (old && sport->lpuart_dma_rx_use)\n\t\tlpuart_dma_rx_free(&sport->port);\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\tsport->port.read_status_mask = 0;\n\tif (termios->c_iflag & INPCK)\n\t\tsport->port.read_status_mask |= UARTSR1_FE | UARTSR1_PE;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tsport->port.read_status_mask |= UARTSR1_FE;\n\n\t \n\tsport->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tsport->port.ignore_status_mask |= UARTSR1_PE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tsport->port.ignore_status_mask |= UARTSR1_FE;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tsport->port.ignore_status_mask |= UARTSR1_OR;\n\t}\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tlpuart_wait_bit_set(&sport->port, UARTSR1, UARTSR1_TC);\n\n\t \n\twriteb(old_cr2 & ~(UARTCR2_TE | UARTCR2_RE),\n\t\t\tsport->port.membase + UARTCR2);\n\n\tsbr = sport->port.uartclk / (16 * baud);\n\tbrfa = ((sport->port.uartclk - (16 * sbr * baud)) * 2) / baud;\n\tbdh &= ~UARTBDH_SBR_MASK;\n\tbdh |= (sbr >> 8) & 0x1F;\n\tcr4 &= ~UARTCR4_BRFA_MASK;\n\tbrfa &= UARTCR4_BRFA_MASK;\n\twriteb(cr4 | brfa, sport->port.membase + UARTCR4);\n\twriteb(bdh, sport->port.membase + UARTBDH);\n\twriteb(sbr & 0xFF, sport->port.membase + UARTBDL);\n\twriteb(cr3, sport->port.membase + UARTCR3);\n\twriteb(cr1, sport->port.membase + UARTCR1);\n\twriteb(modem, sport->port.membase + UARTMODEM);\n\n\t \n\twriteb(old_cr2, sport->port.membase + UARTCR2);\n\n\tif (old && sport->lpuart_dma_rx_use) {\n\t\tif (!lpuart_start_rx_dma(sport))\n\t\t\trx_dma_timer_init(sport);\n\t\telse\n\t\t\tsport->lpuart_dma_rx_use = false;\n\t}\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\nstatic void __lpuart32_serial_setbrg(struct uart_port *port,\n\t\t\t\t     unsigned int baudrate, bool use_rx_dma,\n\t\t\t\t     bool use_tx_dma)\n{\n\tu32 sbr, osr, baud_diff, tmp_osr, tmp_sbr, tmp_diff, tmp;\n\tu32 clk = port->uartclk;\n\n\t \n\tbaud_diff = baudrate;\n\tosr = 0;\n\tsbr = 0;\n\n\tfor (tmp_osr = 4; tmp_osr <= 32; tmp_osr++) {\n\t\t \n\t\ttmp_sbr = (clk / (baudrate * tmp_osr));\n\t\tif (tmp_sbr == 0)\n\t\t\ttmp_sbr = 1;\n\n\t\t \n\t\ttmp_diff = clk / (tmp_osr * tmp_sbr) - baudrate;\n\n\t\t \n\t\ttmp = clk / (tmp_osr * (tmp_sbr + 1));\n\t\tif (tmp_diff > (baudrate - tmp)) {\n\t\t\ttmp_diff = baudrate - tmp;\n\t\t\ttmp_sbr++;\n\t\t}\n\n\t\tif (tmp_sbr > UARTBAUD_SBR_MASK)\n\t\t\tcontinue;\n\n\t\tif (tmp_diff <= baud_diff) {\n\t\t\tbaud_diff = tmp_diff;\n\t\t\tosr = tmp_osr;\n\t\t\tsbr = tmp_sbr;\n\n\t\t\tif (!baud_diff)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (baud_diff > ((baudrate / 100) * 3))\n\t\tdev_warn(port->dev,\n\t\t\t \"unacceptable baud rate difference of more than 3%%\\n\");\n\n\ttmp = lpuart32_read(port, UARTBAUD);\n\n\tif ((osr > 3) && (osr < 8))\n\t\ttmp |= UARTBAUD_BOTHEDGE;\n\n\ttmp &= ~(UARTBAUD_OSR_MASK << UARTBAUD_OSR_SHIFT);\n\ttmp |= ((osr-1) & UARTBAUD_OSR_MASK) << UARTBAUD_OSR_SHIFT;\n\n\ttmp &= ~UARTBAUD_SBR_MASK;\n\ttmp |= sbr & UARTBAUD_SBR_MASK;\n\n\tif (!use_rx_dma)\n\t\ttmp &= ~UARTBAUD_RDMAE;\n\tif (!use_tx_dma)\n\t\ttmp &= ~UARTBAUD_TDMAE;\n\n\tlpuart32_write(port, tmp, UARTBAUD);\n}\n\nstatic void lpuart32_serial_setbrg(struct lpuart_port *sport,\n\t\t\t\t   unsigned int baudrate)\n{\n\t__lpuart32_serial_setbrg(&sport->port, baudrate,\n\t\t\t\t sport->lpuart_dma_rx_use,\n\t\t\t\t sport->lpuart_dma_tx_use);\n}\n\n\nstatic void\nlpuart32_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t     const struct ktermios *old)\n{\n\tstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\n\tunsigned long flags;\n\tunsigned long ctrl, old_ctrl, bd, modem;\n\tunsigned int  baud;\n\tunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\n\n\tctrl = old_ctrl = lpuart32_read(&sport->port, UARTCTRL);\n\tbd = lpuart32_read(&sport->port, UARTBAUD);\n\tmodem = lpuart32_read(&sport->port, UARTMODIR);\n\tsport->is_cs7 = false;\n\t \n\twhile ((termios->c_cflag & CSIZE) != CS8 &&\n\t\t(termios->c_cflag & CSIZE) != CS7) {\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= old_csize;\n\t\told_csize = CS8;\n\t}\n\n\tif ((termios->c_cflag & CSIZE) == CS8 ||\n\t\t(termios->c_cflag & CSIZE) == CS7)\n\t\tctrl = old_ctrl & ~UARTCTRL_M;\n\n\tif (termios->c_cflag & CMSPAR) {\n\t\tif ((termios->c_cflag & CSIZE) != CS8) {\n\t\t\ttermios->c_cflag &= ~CSIZE;\n\t\t\ttermios->c_cflag |= CS8;\n\t\t}\n\t\tctrl |= UARTCTRL_M;\n\t}\n\n\t \n\tif (sport->port.rs485.flags & SER_RS485_ENABLED)\n\t\ttermios->c_cflag &= ~CRTSCTS;\n\n\tif (termios->c_cflag & CRTSCTS)\n\t\tmodem |= UARTMODIR_RXRTSE | UARTMODIR_TXCTSE;\n\telse\n\t\tmodem &= ~(UARTMODIR_RXRTSE | UARTMODIR_TXCTSE);\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tbd |= UARTBAUD_SBNS;\n\telse\n\t\tbd &= ~UARTBAUD_SBNS;\n\n\t \n\tif ((termios->c_cflag & CSIZE) == CS7)\n\t\ttermios->c_cflag |= PARENB;\n\n\tif ((termios->c_cflag & PARENB)) {\n\t\tif (termios->c_cflag & CMSPAR) {\n\t\t\tctrl &= ~UARTCTRL_PE;\n\t\t\tctrl |= UARTCTRL_M;\n\t\t} else {\n\t\t\tctrl |= UARTCTRL_PE;\n\t\t\tif ((termios->c_cflag & CSIZE) == CS8)\n\t\t\t\tctrl |= UARTCTRL_M;\n\t\t\tif (termios->c_cflag & PARODD)\n\t\t\t\tctrl |= UARTCTRL_PT;\n\t\t\telse\n\t\t\t\tctrl &= ~UARTCTRL_PT;\n\t\t}\n\t} else {\n\t\tctrl &= ~UARTCTRL_PE;\n\t}\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 50, port->uartclk / 4);\n\n\t \n\tif (old && sport->lpuart_dma_rx_use)\n\t\tlpuart_dma_rx_free(&sport->port);\n\n\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\tsport->port.read_status_mask = 0;\n\tif (termios->c_iflag & INPCK)\n\t\tsport->port.read_status_mask |= UARTSTAT_FE | UARTSTAT_PE;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tsport->port.read_status_mask |= UARTSTAT_FE;\n\n\t \n\tsport->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tsport->port.ignore_status_mask |= UARTSTAT_PE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tsport->port.ignore_status_mask |= UARTSTAT_FE;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tsport->port.ignore_status_mask |= UARTSTAT_OR;\n\t}\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tif (!(old_ctrl & UARTCTRL_SBK)) {\n\t\tlpuart32_write(&sport->port, 0, UARTMODIR);\n\t\tlpuart32_wait_bit_set(&sport->port, UARTSTAT, UARTSTAT_TC);\n\t}\n\n\t \n\tlpuart32_write(&sport->port, old_ctrl & ~(UARTCTRL_TE | UARTCTRL_RE),\n\t\t       UARTCTRL);\n\n\tlpuart32_write(&sport->port, bd, UARTBAUD);\n\tlpuart32_serial_setbrg(sport, baud);\n\tlpuart32_write(&sport->port, modem, UARTMODIR);\n\tlpuart32_write(&sport->port, ctrl, UARTCTRL);\n\t \n\n\tif ((ctrl & (UARTCTRL_PE | UARTCTRL_M)) == UARTCTRL_PE)\n\t\tsport->is_cs7 = true;\n\n\tif (old && sport->lpuart_dma_rx_use) {\n\t\tif (!lpuart_start_rx_dma(sport))\n\t\t\trx_dma_timer_init(sport);\n\t\telse\n\t\t\tsport->lpuart_dma_rx_use = false;\n\t}\n\n\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\nstatic const char *lpuart_type(struct uart_port *port)\n{\n\treturn \"FSL_LPUART\";\n}\n\nstatic void lpuart_release_port(struct uart_port *port)\n{\n\t \n}\n\nstatic int lpuart_request_port(struct uart_port *port)\n{\n\treturn  0;\n}\n\n \nstatic void lpuart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_LPUART;\n}\n\nstatic int lpuart_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tint ret = 0;\n\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_LPUART)\n\t\tret = -EINVAL;\n\tif (port->irq != ser->irq)\n\t\tret = -EINVAL;\n\tif (ser->io_type != UPIO_MEM)\n\t\tret = -EINVAL;\n\tif (port->uartclk / 16 != ser->baud_base)\n\t\tret = -EINVAL;\n\tif (port->iobase != ser->port)\n\t\tret = -EINVAL;\n\tif (ser->hub6 != 0)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\nstatic const struct uart_ops lpuart_pops = {\n\t.tx_empty\t= lpuart_tx_empty,\n\t.set_mctrl\t= lpuart_set_mctrl,\n\t.get_mctrl\t= lpuart_get_mctrl,\n\t.stop_tx\t= lpuart_stop_tx,\n\t.start_tx\t= lpuart_start_tx,\n\t.stop_rx\t= lpuart_stop_rx,\n\t.break_ctl\t= lpuart_break_ctl,\n\t.startup\t= lpuart_startup,\n\t.shutdown\t= lpuart_shutdown,\n\t.set_termios\t= lpuart_set_termios,\n\t.pm\t\t= lpuart_uart_pm,\n\t.type\t\t= lpuart_type,\n\t.request_port\t= lpuart_request_port,\n\t.release_port\t= lpuart_release_port,\n\t.config_port\t= lpuart_config_port,\n\t.verify_port\t= lpuart_verify_port,\n\t.flush_buffer\t= lpuart_flush_buffer,\n#if defined(CONFIG_CONSOLE_POLL)\n\t.poll_init\t= lpuart_poll_init,\n\t.poll_get_char\t= lpuart_poll_get_char,\n\t.poll_put_char\t= lpuart_poll_put_char,\n#endif\n};\n\nstatic const struct uart_ops lpuart32_pops = {\n\t.tx_empty\t= lpuart32_tx_empty,\n\t.set_mctrl\t= lpuart32_set_mctrl,\n\t.get_mctrl\t= lpuart32_get_mctrl,\n\t.stop_tx\t= lpuart32_stop_tx,\n\t.start_tx\t= lpuart32_start_tx,\n\t.stop_rx\t= lpuart32_stop_rx,\n\t.break_ctl\t= lpuart32_break_ctl,\n\t.startup\t= lpuart32_startup,\n\t.shutdown\t= lpuart32_shutdown,\n\t.set_termios\t= lpuart32_set_termios,\n\t.pm\t\t= lpuart_uart_pm,\n\t.type\t\t= lpuart_type,\n\t.request_port\t= lpuart_request_port,\n\t.release_port\t= lpuart_release_port,\n\t.config_port\t= lpuart_config_port,\n\t.verify_port\t= lpuart_verify_port,\n\t.flush_buffer\t= lpuart_flush_buffer,\n#if defined(CONFIG_CONSOLE_POLL)\n\t.poll_init\t= lpuart32_poll_init,\n\t.poll_get_char\t= lpuart32_poll_get_char,\n\t.poll_put_char\t= lpuart32_poll_put_char,\n#endif\n};\n\nstatic struct lpuart_port *lpuart_ports[UART_NR];\n\n#ifdef CONFIG_SERIAL_FSL_LPUART_CONSOLE\nstatic void lpuart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tlpuart_wait_bit_set(port, UARTSR1, UARTSR1_TDRE);\n\twriteb(ch, port->membase + UARTDR);\n}\n\nstatic void lpuart32_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tlpuart32_wait_bit_set(port, UARTSTAT, UARTSTAT_TDRE);\n\tlpuart32_write(port, ch, UARTDATA);\n}\n\nstatic void\nlpuart_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct lpuart_port *sport = lpuart_ports[co->index];\n\tunsigned char  old_cr2, cr2;\n\tunsigned long flags;\n\tint locked = 1;\n\n\tif (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&sport->port.lock, flags);\n\telse\n\t\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\t \n\tcr2 = old_cr2 = readb(sport->port.membase + UARTCR2);\n\tcr2 |= UARTCR2_TE | UARTCR2_RE;\n\tcr2 &= ~(UARTCR2_TIE | UARTCR2_TCIE | UARTCR2_RIE);\n\twriteb(cr2, sport->port.membase + UARTCR2);\n\n\tuart_console_write(&sport->port, s, count, lpuart_console_putchar);\n\n\t \n\tlpuart_wait_bit_set(&sport->port, UARTSR1, UARTSR1_TC);\n\n\twriteb(old_cr2, sport->port.membase + UARTCR2);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\nstatic void\nlpuart32_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct lpuart_port *sport = lpuart_ports[co->index];\n\tunsigned long  old_cr, cr;\n\tunsigned long flags;\n\tint locked = 1;\n\n\tif (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&sport->port.lock, flags);\n\telse\n\t\tspin_lock_irqsave(&sport->port.lock, flags);\n\n\t \n\tcr = old_cr = lpuart32_read(&sport->port, UARTCTRL);\n\tcr |= UARTCTRL_TE | UARTCTRL_RE;\n\tcr &= ~(UARTCTRL_TIE | UARTCTRL_TCIE | UARTCTRL_RIE);\n\tlpuart32_write(&sport->port, cr, UARTCTRL);\n\n\tuart_console_write(&sport->port, s, count, lpuart32_console_putchar);\n\n\t \n\tlpuart32_wait_bit_set(&sport->port, UARTSTAT, UARTSTAT_TC);\n\n\tlpuart32_write(&sport->port, old_cr, UARTCTRL);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n}\n\n \nstatic void __init\nlpuart_console_get_options(struct lpuart_port *sport, int *baud,\n\t\t\t   int *parity, int *bits)\n{\n\tunsigned char cr, bdh, bdl, brfa;\n\tunsigned int sbr, uartclk, baud_raw;\n\n\tcr = readb(sport->port.membase + UARTCR2);\n\tcr &= UARTCR2_TE | UARTCR2_RE;\n\tif (!cr)\n\t\treturn;\n\n\t \n\n\tcr = readb(sport->port.membase + UARTCR1);\n\n\t*parity = 'n';\n\tif (cr & UARTCR1_PE) {\n\t\tif (cr & UARTCR1_PT)\n\t\t\t*parity = 'o';\n\t\telse\n\t\t\t*parity = 'e';\n\t}\n\n\tif (cr & UARTCR1_M)\n\t\t*bits = 9;\n\telse\n\t\t*bits = 8;\n\n\tbdh = readb(sport->port.membase + UARTBDH);\n\tbdh &= UARTBDH_SBR_MASK;\n\tbdl = readb(sport->port.membase + UARTBDL);\n\tsbr = bdh;\n\tsbr <<= 8;\n\tsbr |= bdl;\n\tbrfa = readb(sport->port.membase + UARTCR4);\n\tbrfa &= UARTCR4_BRFA_MASK;\n\n\tuartclk = lpuart_get_baud_clk_rate(sport);\n\t \n\tbaud_raw = uartclk / (16 * (sbr + brfa / 32));\n\n\tif (*baud != baud_raw)\n\t\tdev_info(sport->port.dev, \"Serial: Console lpuart rounded baud rate\"\n\t\t\t\t\"from %d to %d\\n\", baud_raw, *baud);\n}\n\nstatic void __init\nlpuart32_console_get_options(struct lpuart_port *sport, int *baud,\n\t\t\t   int *parity, int *bits)\n{\n\tunsigned long cr, bd;\n\tunsigned int sbr, uartclk, baud_raw;\n\n\tcr = lpuart32_read(&sport->port, UARTCTRL);\n\tcr &= UARTCTRL_TE | UARTCTRL_RE;\n\tif (!cr)\n\t\treturn;\n\n\t \n\n\tcr = lpuart32_read(&sport->port, UARTCTRL);\n\n\t*parity = 'n';\n\tif (cr & UARTCTRL_PE) {\n\t\tif (cr & UARTCTRL_PT)\n\t\t\t*parity = 'o';\n\t\telse\n\t\t\t*parity = 'e';\n\t}\n\n\tif (cr & UARTCTRL_M)\n\t\t*bits = 9;\n\telse\n\t\t*bits = 8;\n\n\tbd = lpuart32_read(&sport->port, UARTBAUD);\n\tbd &= UARTBAUD_SBR_MASK;\n\tif (!bd)\n\t\treturn;\n\n\tsbr = bd;\n\tuartclk = lpuart_get_baud_clk_rate(sport);\n\t \n\tbaud_raw = uartclk / (16 * sbr);\n\n\tif (*baud != baud_raw)\n\t\tdev_info(sport->port.dev, \"Serial: Console lpuart rounded baud rate\"\n\t\t\t\t\"from %d to %d\\n\", baud_raw, *baud);\n}\n\nstatic int __init lpuart_console_setup(struct console *co, char *options)\n{\n\tstruct lpuart_port *sport;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\t \n\tif (co->index == -1 || co->index >= ARRAY_SIZE(lpuart_ports))\n\t\tco->index = 0;\n\n\tsport = lpuart_ports[co->index];\n\tif (sport == NULL)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse\n\t\tif (lpuart_is_32(sport))\n\t\t\tlpuart32_console_get_options(sport, &baud, &parity, &bits);\n\t\telse\n\t\t\tlpuart_console_get_options(sport, &baud, &parity, &bits);\n\n\tif (lpuart_is_32(sport))\n\t\tlpuart32_setup_watermark(sport);\n\telse\n\t\tlpuart_setup_watermark(sport);\n\n\treturn uart_set_options(&sport->port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver lpuart_reg;\nstatic struct console lpuart_console = {\n\t.name\t\t= DEV_NAME,\n\t.write\t\t= lpuart_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= lpuart_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &lpuart_reg,\n};\n\nstatic struct console lpuart32_console = {\n\t.name\t\t= DEV_NAME,\n\t.write\t\t= lpuart32_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= lpuart_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &lpuart_reg,\n};\n\nstatic void lpuart_early_write(struct console *con, const char *s, unsigned n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, lpuart_console_putchar);\n}\n\nstatic void lpuart32_early_write(struct console *con, const char *s, unsigned n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, lpuart32_console_putchar);\n}\n\nstatic int __init lpuart_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t  const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = lpuart_early_write;\n\treturn 0;\n}\n\nstatic int __init lpuart32_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t  const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tif (device->port.iotype != UPIO_MEM32)\n\t\tdevice->port.iotype = UPIO_MEM32BE;\n\n\tdevice->con->write = lpuart32_early_write;\n\treturn 0;\n}\n\nstatic int __init ls1028a_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t      const char *opt)\n{\n\tu32 cr;\n\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->port.iotype = UPIO_MEM32;\n\tdevice->con->write = lpuart32_early_write;\n\n\t \n\tif (device->port.uartclk && device->baud)\n\t\t__lpuart32_serial_setbrg(&device->port, device->baud,\n\t\t\t\t\t false, false);\n\n\t \n\tcr = lpuart32_read(&device->port, UARTCTRL);\n\tcr |= UARTCTRL_TE;\n\tlpuart32_write(&device->port, cr, UARTCTRL);\n\n\treturn 0;\n}\n\nstatic int __init lpuart32_imx_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t\t   const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->port.iotype = UPIO_MEM32;\n\tdevice->port.membase += IMX_REG_OFF;\n\tdevice->con->write = lpuart32_early_write;\n\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(lpuart, \"fsl,vf610-lpuart\", lpuart_early_console_setup);\nOF_EARLYCON_DECLARE(lpuart32, \"fsl,ls1021a-lpuart\", lpuart32_early_console_setup);\nOF_EARLYCON_DECLARE(lpuart32, \"fsl,ls1028a-lpuart\", ls1028a_early_console_setup);\nOF_EARLYCON_DECLARE(lpuart32, \"fsl,imx7ulp-lpuart\", lpuart32_imx_early_console_setup);\nOF_EARLYCON_DECLARE(lpuart32, \"fsl,imx8ulp-lpuart\", lpuart32_imx_early_console_setup);\nOF_EARLYCON_DECLARE(lpuart32, \"fsl,imx8qxp-lpuart\", lpuart32_imx_early_console_setup);\nOF_EARLYCON_DECLARE(lpuart32, \"fsl,imxrt1050-lpuart\", lpuart32_imx_early_console_setup);\nEARLYCON_DECLARE(lpuart, lpuart_early_console_setup);\nEARLYCON_DECLARE(lpuart32, lpuart32_early_console_setup);\n\n#define LPUART_CONSOLE\t(&lpuart_console)\n#define LPUART32_CONSOLE\t(&lpuart32_console)\n#else\n#define LPUART_CONSOLE\tNULL\n#define LPUART32_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver lpuart_reg = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= DRIVER_NAME,\n\t.dev_name\t= DEV_NAME,\n\t.nr\t\t= ARRAY_SIZE(lpuart_ports),\n\t.cons\t\t= LPUART_CONSOLE,\n};\n\nstatic const struct serial_rs485 lpuart_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | SER_RS485_RTS_AFTER_SEND,\n\t \n};\n\nstatic int lpuart_global_reset(struct lpuart_port *sport)\n{\n\tstruct uart_port *port = &sport->port;\n\tvoid __iomem *global_addr;\n\tunsigned long ctrl, bd;\n\tunsigned int val = 0;\n\tint ret;\n\n\tret = clk_prepare_enable(sport->ipg_clk);\n\tif (ret) {\n\t\tdev_err(sport->port.dev, \"failed to enable uart ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (is_imx7ulp_lpuart(sport) || is_imx8ulp_lpuart(sport) || is_imx8qxp_lpuart(sport)) {\n\t\t \n\t\tctrl = lpuart32_read(port, UARTCTRL);\n\t\tif (ctrl & UARTCTRL_TE) {\n\t\t\tbd = lpuart32_read(&sport->port, UARTBAUD);\n\t\t\tif (read_poll_timeout(lpuart32_tx_empty, val, val, 1, 100000, false,\n\t\t\t\t\t      port)) {\n\t\t\t\tdev_warn(sport->port.dev,\n\t\t\t\t\t \"timeout waiting for transmit engine to complete\\n\");\n\t\t\t\tclk_disable_unprepare(sport->ipg_clk);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tglobal_addr = port->membase + UART_GLOBAL - IMX_REG_OFF;\n\t\twritel(UART_GLOBAL_RST, global_addr);\n\t\tusleep_range(GLOBAL_RST_MIN_US, GLOBAL_RST_MAX_US);\n\t\twritel(0, global_addr);\n\t\tusleep_range(GLOBAL_RST_MIN_US, GLOBAL_RST_MAX_US);\n\n\t\t \n\t\tif (ctrl & UARTCTRL_TE) {\n\t\t\tlpuart32_write(port, bd, UARTBAUD);\n\t\t\tlpuart32_write(port, ctrl, UARTCTRL);\n\t\t}\n\t}\n\n\tclk_disable_unprepare(sport->ipg_clk);\n\treturn 0;\n}\n\nstatic int lpuart_probe(struct platform_device *pdev)\n{\n\tconst struct lpuart_soc_data *sdata = of_device_get_match_data(&pdev->dev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct lpuart_port *sport;\n\tstruct resource *res;\n\tirq_handler_t handler;\n\tint ret;\n\n\tsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n\tif (!sport)\n\t\treturn -ENOMEM;\n\n\tsport->port.membase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(sport->port.membase))\n\t\treturn PTR_ERR(sport->port.membase);\n\n\tsport->port.membase += sdata->reg_off;\n\tsport->port.mapbase = res->start + sdata->reg_off;\n\tsport->port.dev = &pdev->dev;\n\tsport->port.type = PORT_LPUART;\n\tsport->devtype = sdata->devtype;\n\tsport->rx_watermark = sdata->rx_watermark;\n\tsport->dma_idle_int = is_imx7ulp_lpuart(sport) || is_imx8ulp_lpuart(sport) ||\n\t\t\t      is_imx8qxp_lpuart(sport);\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tsport->port.irq = ret;\n\tsport->port.iotype = sdata->iotype;\n\tif (lpuart_is_32(sport))\n\t\tsport->port.ops = &lpuart32_pops;\n\telse\n\t\tsport->port.ops = &lpuart_pops;\n\tsport->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_FSL_LPUART_CONSOLE);\n\tsport->port.flags = UPF_BOOT_AUTOCONF;\n\n\tif (lpuart_is_32(sport))\n\t\tsport->port.rs485_config = lpuart32_config_rs485;\n\telse\n\t\tsport->port.rs485_config = lpuart_config_rs485;\n\tsport->port.rs485_supported = lpuart_rs485_supported;\n\n\tsport->ipg_clk = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(sport->ipg_clk)) {\n\t\tret = PTR_ERR(sport->ipg_clk);\n\t\tdev_err(&pdev->dev, \"failed to get uart ipg clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsport->baud_clk = NULL;\n\tif (is_imx8qxp_lpuart(sport)) {\n\t\tsport->baud_clk = devm_clk_get(&pdev->dev, \"baud\");\n\t\tif (IS_ERR(sport->baud_clk)) {\n\t\t\tret = PTR_ERR(sport->baud_clk);\n\t\t\tdev_err(&pdev->dev, \"failed to get uart baud clk: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = of_alias_get_id(np, \"serial\");\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias id, errno %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (ret >= ARRAY_SIZE(lpuart_ports)) {\n\t\tdev_err(&pdev->dev, \"serial%d out of range\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\tsport->port.line = ret;\n\n\tret = lpuart_enable_clks(sport);\n\tif (ret)\n\t\treturn ret;\n\tsport->port.uartclk = lpuart_get_baud_clk_rate(sport);\n\n\tlpuart_ports[sport->port.line] = sport;\n\n\tplatform_set_drvdata(pdev, &sport->port);\n\n\tif (lpuart_is_32(sport)) {\n\t\tlpuart_reg.cons = LPUART32_CONSOLE;\n\t\thandler = lpuart32_int;\n\t} else {\n\t\tlpuart_reg.cons = LPUART_CONSOLE;\n\t\thandler = lpuart_int;\n\t}\n\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, UART_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = lpuart_global_reset(sport);\n\tif (ret)\n\t\tgoto failed_reset;\n\n\tret = uart_get_rs485_mode(&sport->port);\n\tif (ret)\n\t\tgoto failed_get_rs485;\n\n\tret = uart_add_one_port(&lpuart_reg, &sport->port);\n\tif (ret)\n\t\tgoto failed_attach_port;\n\n\tret = devm_request_irq(&pdev->dev, sport->port.irq, handler, 0,\n\t\t\t\tDRIVER_NAME, sport);\n\tif (ret)\n\t\tgoto failed_irq_request;\n\n\treturn 0;\n\nfailed_irq_request:\n\tuart_remove_one_port(&lpuart_reg, &sport->port);\nfailed_attach_port:\nfailed_get_rs485:\nfailed_reset:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tlpuart_disable_clks(sport);\n\treturn ret;\n}\n\nstatic int lpuart_remove(struct platform_device *pdev)\n{\n\tstruct lpuart_port *sport = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&lpuart_reg, &sport->port);\n\n\tlpuart_disable_clks(sport);\n\n\tif (sport->dma_tx_chan)\n\t\tdma_release_channel(sport->dma_tx_chan);\n\n\tif (sport->dma_rx_chan)\n\t\tdma_release_channel(sport->dma_rx_chan);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\treturn 0;\n}\n\nstatic int lpuart_runtime_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct lpuart_port *sport = platform_get_drvdata(pdev);\n\n\tlpuart_disable_clks(sport);\n\n\treturn 0;\n};\n\nstatic int lpuart_runtime_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct lpuart_port *sport = platform_get_drvdata(pdev);\n\n\treturn lpuart_enable_clks(sport);\n};\n\nstatic void serial_lpuart_enable_wakeup(struct lpuart_port *sport, bool on)\n{\n\tunsigned int val, baud;\n\n\tif (lpuart_is_32(sport)) {\n\t\tval = lpuart32_read(&sport->port, UARTCTRL);\n\t\tbaud = lpuart32_read(&sport->port, UARTBAUD);\n\t\tif (on) {\n\t\t\t \n\t\t\tlpuart32_write(&sport->port, 0, UARTWATER);\n\t\t\tval |= UARTCTRL_RIE;\n\t\t\t \n\t\t\tlpuart32_write(&sport->port, UARTSTAT_RXEDGIF, UARTSTAT);\n\t\t\tbaud |= UARTBAUD_RXEDGIE;\n\t\t} else {\n\t\t\tval &= ~UARTCTRL_RIE;\n\t\t\tbaud &= ~UARTBAUD_RXEDGIE;\n\t\t}\n\t\tlpuart32_write(&sport->port, val, UARTCTRL);\n\t\tlpuart32_write(&sport->port, baud, UARTBAUD);\n\t} else {\n\t\tval = readb(sport->port.membase + UARTCR2);\n\t\tif (on)\n\t\t\tval |= UARTCR2_RIE;\n\t\telse\n\t\t\tval &= ~UARTCR2_RIE;\n\t\twriteb(val, sport->port.membase + UARTCR2);\n\t}\n}\n\nstatic bool lpuart_uport_is_active(struct lpuart_port *sport)\n{\n\tstruct tty_port *port = &sport->port.state->port;\n\tstruct tty_struct *tty;\n\tstruct device *tty_dev;\n\tint may_wake = 0;\n\n\ttty = tty_port_tty_get(port);\n\tif (tty) {\n\t\ttty_dev = tty->dev;\n\t\tmay_wake = tty_dev && device_may_wakeup(tty_dev);\n\t\ttty_kref_put(tty);\n\t}\n\n\tif ((tty_port_initialized(port) && may_wake) ||\n\t    (!console_suspend_enabled && uart_console(&sport->port)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int lpuart_suspend_noirq(struct device *dev)\n{\n\tstruct lpuart_port *sport = dev_get_drvdata(dev);\n\tbool irq_wake = irqd_is_wakeup_set(irq_get_irq_data(sport->port.irq));\n\n\tif (lpuart_uport_is_active(sport))\n\t\tserial_lpuart_enable_wakeup(sport, !!irq_wake);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int lpuart_resume_noirq(struct device *dev)\n{\n\tstruct lpuart_port *sport = dev_get_drvdata(dev);\n\tunsigned int val;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tif (lpuart_uport_is_active(sport)) {\n\t\tserial_lpuart_enable_wakeup(sport, false);\n\n\t\t \n\t\tif (lpuart_is_32(sport)) {\n\t\t\tval = lpuart32_read(&sport->port, UARTSTAT);\n\t\t\tlpuart32_write(&sport->port, val, UARTSTAT);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lpuart_suspend(struct device *dev)\n{\n\tstruct lpuart_port *sport = dev_get_drvdata(dev);\n\tunsigned long temp, flags;\n\n\tuart_suspend_port(&lpuart_reg, &sport->port);\n\n\tif (lpuart_uport_is_active(sport)) {\n\t\tspin_lock_irqsave(&sport->port.lock, flags);\n\t\tif (lpuart_is_32(sport)) {\n\t\t\t \n\t\t\ttemp = lpuart32_read(&sport->port, UARTCTRL);\n\t\t\ttemp &= ~(UARTCTRL_TE | UARTCTRL_TIE | UARTCTRL_TCIE);\n\t\t\tlpuart32_write(&sport->port, temp, UARTCTRL);\n\t\t} else {\n\t\t\t \n\t\t\ttemp = readb(sport->port.membase + UARTCR2);\n\t\t\ttemp &= ~(UARTCR2_TE | UARTCR2_TIE | UARTCR2_TCIE);\n\t\t\twriteb(temp, sport->port.membase + UARTCR2);\n\t\t}\n\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\n\t\tif (sport->lpuart_dma_rx_use) {\n\t\t\t \n\t\t\tlpuart_dma_rx_free(&sport->port);\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&sport->port.lock, flags);\n\t\t\tif (lpuart_is_32(sport)) {\n\t\t\t\ttemp = lpuart32_read(&sport->port, UARTBAUD);\n\t\t\t\tlpuart32_write(&sport->port, temp & ~UARTBAUD_RDMAE,\n\t\t\t\t\t       UARTBAUD);\n\t\t\t} else {\n\t\t\t\twriteb(readb(sport->port.membase + UARTCR5) &\n\t\t\t\t       ~UARTCR5_RDMAS, sport->port.membase + UARTCR5);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\t\t}\n\n\t\tif (sport->lpuart_dma_tx_use) {\n\t\t\tspin_lock_irqsave(&sport->port.lock, flags);\n\t\t\tif (lpuart_is_32(sport)) {\n\t\t\t\ttemp = lpuart32_read(&sport->port, UARTBAUD);\n\t\t\t\ttemp &= ~UARTBAUD_TDMAE;\n\t\t\t\tlpuart32_write(&sport->port, temp, UARTBAUD);\n\t\t\t} else {\n\t\t\t\ttemp = readb(sport->port.membase + UARTCR5);\n\t\t\t\ttemp &= ~UARTCR5_TDMAS;\n\t\t\t\twriteb(temp, sport->port.membase + UARTCR5);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&sport->port.lock, flags);\n\t\t\tsport->dma_tx_in_progress = false;\n\t\t\tdmaengine_terminate_sync(sport->dma_tx_chan);\n\t\t}\n\t} else if (pm_runtime_active(sport->port.dev)) {\n\t\tlpuart_disable_clks(sport);\n\t\tpm_runtime_disable(sport->port.dev);\n\t\tpm_runtime_set_suspended(sport->port.dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void lpuart_console_fixup(struct lpuart_port *sport)\n{\n\tstruct tty_port *port = &sport->port.state->port;\n\tstruct uart_port *uport = &sport->port;\n\tstruct ktermios termios;\n\n\t \n\tif (is_imx7ulp_lpuart(sport) && lpuart_uport_is_active(sport) &&\n\t    console_suspend_enabled && uart_console(&sport->port)) {\n\n\t\tmutex_lock(&port->mutex);\n\t\tmemset(&termios, 0, sizeof(struct ktermios));\n\t\ttermios.c_cflag = uport->cons->cflag;\n\t\tif (port->tty && termios.c_cflag == 0)\n\t\t\ttermios = port->tty->termios;\n\t\tuport->ops->set_termios(uport, &termios, NULL);\n\t\tmutex_unlock(&port->mutex);\n\t}\n}\n\nstatic int lpuart_resume(struct device *dev)\n{\n\tstruct lpuart_port *sport = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (lpuart_uport_is_active(sport)) {\n\t\tif (lpuart_is_32(sport))\n\t\t\tlpuart32_hw_setup(sport);\n\t\telse\n\t\t\tlpuart_hw_setup(sport);\n\t} else if (pm_runtime_active(sport->port.dev)) {\n\t\tret = lpuart_enable_clks(sport);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpm_runtime_set_active(sport->port.dev);\n\t\tpm_runtime_enable(sport->port.dev);\n\t}\n\n\tlpuart_console_fixup(sport);\n\tuart_resume_port(&lpuart_reg, &sport->port);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops lpuart_pm_ops = {\n\tRUNTIME_PM_OPS(lpuart_runtime_suspend,\n\t\t\t   lpuart_runtime_resume, NULL)\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(lpuart_suspend_noirq,\n\t\t\t\t      lpuart_resume_noirq)\n\tSYSTEM_SLEEP_PM_OPS(lpuart_suspend, lpuart_resume)\n};\n\nstatic struct platform_driver lpuart_driver = {\n\t.probe\t\t= lpuart_probe,\n\t.remove\t\t= lpuart_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"fsl-lpuart\",\n\t\t.of_match_table = lpuart_dt_ids,\n\t\t.pm\t= pm_ptr(&lpuart_pm_ops),\n\t},\n};\n\nstatic int __init lpuart_serial_init(void)\n{\n\tint ret = uart_register_driver(&lpuart_reg);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&lpuart_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&lpuart_reg);\n\n\treturn ret;\n}\n\nstatic void __exit lpuart_serial_exit(void)\n{\n\tplatform_driver_unregister(&lpuart_driver);\n\tuart_unregister_driver(&lpuart_reg);\n}\n\nmodule_init(lpuart_serial_init);\nmodule_exit(lpuart_serial_exit);\n\nMODULE_DESCRIPTION(\"Freescale lpuart serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}