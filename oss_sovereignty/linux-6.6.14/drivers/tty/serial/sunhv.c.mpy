{
  "module_name": "sunhv.c",
  "hash_id": "d0bfcf9e5a6250c53f1ec5c5a34d7f690f7b7cf20b6af78db0cacf828d4b93f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sunhv.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/major.h>\n#include <linux/circ_buf.h>\n#include <linux/serial.h>\n#include <linux/sysrq.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <asm/hypervisor.h>\n#include <asm/spitfire.h>\n#include <asm/irq.h>\n#include <asm/setup.h>\n\n#include <linux/serial_core.h>\n#include <linux/sunserialcore.h>\n\n#define CON_BREAK\t((long)-1)\n#define CON_HUP\t\t((long)-2)\n\n#define IGNORE_BREAK\t0x1\n#define IGNORE_ALL\t0x2\n\nstatic char *con_write_page;\nstatic char *con_read_page;\n\nstatic int hung_up = 0;\n\nstatic void transmit_chars_putchar(struct uart_port *port, struct circ_buf *xmit)\n{\n\twhile (!uart_circ_empty(xmit)) {\n\t\tlong status = sun4v_con_putchar(xmit->buf[xmit->tail]);\n\n\t\tif (status != HV_EOK)\n\t\t\tbreak;\n\n\t\tuart_xmit_advance(port, 1);\n\t}\n}\n\nstatic void transmit_chars_write(struct uart_port *port, struct circ_buf *xmit)\n{\n\twhile (!uart_circ_empty(xmit)) {\n\t\tunsigned long ra = __pa(xmit->buf + xmit->tail);\n\t\tunsigned long len, status, sent;\n\n\t\tlen = CIRC_CNT_TO_END(xmit->head, xmit->tail,\n\t\t\t\t      UART_XMIT_SIZE);\n\t\tstatus = sun4v_con_write(ra, len, &sent);\n\t\tif (status != HV_EOK)\n\t\t\tbreak;\n\t\tuart_xmit_advance(port, sent);\n\t}\n}\n\nstatic int receive_chars_getchar(struct uart_port *port)\n{\n\tint saw_console_brk = 0;\n\tint limit = 10000;\n\n\twhile (limit-- > 0) {\n\t\tlong status;\n\t\tlong c = sun4v_con_getchar(&status);\n\n\t\tif (status == HV_EWOULDBLOCK)\n\t\t\tbreak;\n\n\t\tif (c == CON_BREAK) {\n\t\t\tif (uart_handle_break(port))\n\t\t\t\tcontinue;\n\t\t\tsaw_console_brk = 1;\n\t\t\tc = 0;\n\t\t}\n\n\t\tif (c == CON_HUP) {\n\t\t\thung_up = 1;\n\t\t\tuart_handle_dcd_change(port, false);\n\t\t} else if (hung_up) {\n\t\t\thung_up = 0;\n\t\t\tuart_handle_dcd_change(port, true);\n\t\t}\n\n\t\tif (port->state == NULL) {\n\t\t\tuart_handle_sysrq_char(port, c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tport->icount.rx++;\n\n\t\tif (uart_handle_sysrq_char(port, c))\n\t\t\tcontinue;\n\n\t\ttty_insert_flip_char(&port->state->port, c, TTY_NORMAL);\n\t}\n\n\treturn saw_console_brk;\n}\n\nstatic int receive_chars_read(struct uart_port *port)\n{\n\tstatic int saw_console_brk;\n\tint limit = 10000;\n\n\twhile (limit-- > 0) {\n\t\tunsigned long ra = __pa(con_read_page);\n\t\tunsigned long bytes_read, i;\n\t\tlong stat = sun4v_con_read(ra, PAGE_SIZE, &bytes_read);\n\n\t\tif (stat != HV_EOK) {\n\t\t\tbytes_read = 0;\n\n\t\t\tif (stat == CON_BREAK) {\n\t\t\t\tif (saw_console_brk)\n\t\t\t\t\tsun_do_break();\n\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tcontinue;\n\t\t\t\tsaw_console_brk = 1;\n\t\t\t\t*con_read_page = 0;\n\t\t\t\tbytes_read = 1;\n\t\t\t} else if (stat == CON_HUP) {\n\t\t\t\thung_up = 1;\n\t\t\t\tuart_handle_dcd_change(port, false);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (hung_up) {\n\t\t\thung_up = 0;\n\t\t\tuart_handle_dcd_change(port, true);\n\t\t}\n\n\t\tif (port->sysrq != 0 &&  *con_read_page) {\n\t\t\tfor (i = 0; i < bytes_read; i++)\n\t\t\t\tuart_handle_sysrq_char(port, con_read_page[i]);\n\t\t\tsaw_console_brk = 0;\n\t\t}\n\n\t\tif (port->state == NULL)\n\t\t\tcontinue;\n\n\t\tport->icount.rx += bytes_read;\n\n\t\ttty_insert_flip_string(&port->state->port, con_read_page,\n\t\t\t\tbytes_read);\n\t}\n\n\treturn saw_console_brk;\n}\n\nstruct sunhv_ops {\n\tvoid (*transmit_chars)(struct uart_port *port, struct circ_buf *xmit);\n\tint (*receive_chars)(struct uart_port *port);\n};\n\nstatic const struct sunhv_ops bychar_ops = {\n\t.transmit_chars = transmit_chars_putchar,\n\t.receive_chars = receive_chars_getchar,\n};\n\nstatic const struct sunhv_ops bywrite_ops = {\n\t.transmit_chars = transmit_chars_write,\n\t.receive_chars = receive_chars_read,\n};\n\nstatic const struct sunhv_ops *sunhv_ops = &bychar_ops;\n\nstatic struct tty_port *receive_chars(struct uart_port *port)\n{\n\tstruct tty_port *tport = NULL;\n\n\tif (port->state != NULL)\t\t \n\t\ttport = &port->state->port;\n\n\tif (sunhv_ops->receive_chars(port))\n\t\tsun_do_break();\n\n\treturn tport;\n}\n\nstatic void transmit_chars(struct uart_port *port)\n{\n\tstruct circ_buf *xmit;\n\n\tif (!port->state)\n\t\treturn;\n\n\txmit = &port->state->xmit;\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port))\n\t\treturn;\n\n\tsunhv_ops->transmit_chars(port, xmit);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n}\n\nstatic irqreturn_t sunhv_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tstruct tty_port *tport;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\ttport = receive_chars(port);\n\ttransmit_chars(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (tport)\n\t\ttty_flip_buffer_push(tport);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic unsigned int sunhv_tx_empty(struct uart_port *port)\n{\n\t \n\treturn TIOCSER_TEMT;\n}\n\n \nstatic void sunhv_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\treturn;\n}\n\n \nstatic unsigned int sunhv_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_DSR | TIOCM_CAR | TIOCM_CTS;\n}\n\n \nstatic void sunhv_stop_tx(struct uart_port *port)\n{\n\treturn;\n}\n\n \nstatic void sunhv_start_tx(struct uart_port *port)\n{\n\ttransmit_chars(port);\n}\n\n \nstatic void sunhv_send_xchar(struct uart_port *port, char ch)\n{\n\tunsigned long flags;\n\tint limit = 10000;\n\n\tif (ch == __DISABLED_CHAR)\n\t\treturn;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\twhile (limit-- > 0) {\n\t\tlong status = sun4v_con_putchar(ch);\n\t\tif (status == HV_EOK)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic void sunhv_stop_rx(struct uart_port *port)\n{\n}\n\n \nstatic void sunhv_break_ctl(struct uart_port *port, int break_state)\n{\n\tif (break_state) {\n\t\tunsigned long flags;\n\t\tint limit = 10000;\n\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\t\twhile (limit-- > 0) {\n\t\t\tlong status = sun4v_con_putchar(CON_BREAK);\n\t\t\tif (status == HV_EOK)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t}\n}\n\n \nstatic int sunhv_startup(struct uart_port *port)\n{\n\treturn 0;\n}\n\n \nstatic void sunhv_shutdown(struct uart_port *port)\n{\n}\n\n \nstatic void sunhv_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t\t      const struct ktermios *old)\n{\n\tunsigned int baud = uart_get_baud_rate(port, termios, old, 0, 4000000);\n\tunsigned int quot = uart_get_divisor(port, baud);\n\tunsigned int iflag, cflag;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tiflag = termios->c_iflag;\n\tcflag = termios->c_cflag;\n\n\tport->ignore_status_mask = 0;\n\tif (iflag & IGNBRK)\n\t\tport->ignore_status_mask |= IGNORE_BREAK;\n\tif ((cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= IGNORE_ALL;\n\n\t \n\tuart_update_timeout(port, cflag,\n\t\t\t    (port->uartclk / (16 * quot)));\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *sunhv_type(struct uart_port *port)\n{\n\treturn \"SUN4V HCONS\";\n}\n\nstatic void sunhv_release_port(struct uart_port *port)\n{\n}\n\nstatic int sunhv_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void sunhv_config_port(struct uart_port *port, int flags)\n{\n}\n\nstatic int sunhv_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct uart_ops sunhv_pops = {\n\t.tx_empty\t= sunhv_tx_empty,\n\t.set_mctrl\t= sunhv_set_mctrl,\n\t.get_mctrl\t= sunhv_get_mctrl,\n\t.stop_tx\t= sunhv_stop_tx,\n\t.start_tx\t= sunhv_start_tx,\n\t.send_xchar\t= sunhv_send_xchar,\n\t.stop_rx\t= sunhv_stop_rx,\n\t.break_ctl\t= sunhv_break_ctl,\n\t.startup\t= sunhv_startup,\n\t.shutdown\t= sunhv_shutdown,\n\t.set_termios\t= sunhv_set_termios,\n\t.type\t\t= sunhv_type,\n\t.release_port\t= sunhv_release_port,\n\t.request_port\t= sunhv_request_port,\n\t.config_port\t= sunhv_config_port,\n\t.verify_port\t= sunhv_verify_port,\n};\n\nstatic struct uart_driver sunhv_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"sunhv\",\n\t.dev_name\t\t= \"ttyHV\",\n\t.major\t\t\t= TTY_MAJOR,\n};\n\nstatic struct uart_port *sunhv_port;\n\nvoid sunhv_migrate_hvcons_irq(int cpu)\n{\n\t \n\tirq_force_affinity(sunhv_port->irq, cpumask_of(cpu));\n}\n\n \nstatic int fill_con_write_page(const char *s, unsigned int n,\n\t\t\t       unsigned long *page_bytes)\n{\n\tconst char *orig_s = s;\n\tchar *p = con_write_page;\n\tint left = PAGE_SIZE;\n\n\twhile (n--) {\n\t\tif (*s == '\\n') {\n\t\t\tif (left < 2)\n\t\t\t\tbreak;\n\t\t\t*p++ = '\\r';\n\t\t\tleft--;\n\t\t} else if (left < 1)\n\t\t\tbreak;\n\t\t*p++ = *s++;\n\t\tleft--;\n\t}\n\t*page_bytes = p - con_write_page;\n\treturn s - orig_s;\n}\n\nstatic void sunhv_console_write_paged(struct console *con, const char *s, unsigned n)\n{\n\tstruct uart_port *port = sunhv_port;\n\tunsigned long flags;\n\tint locked = 1;\n\n\tif (port->sysrq || oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&port->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\twhile (n > 0) {\n\t\tunsigned long ra = __pa(con_write_page);\n\t\tunsigned long page_bytes;\n\t\tunsigned int cpy = fill_con_write_page(s, n,\n\t\t\t\t\t\t       &page_bytes);\n\n\t\tn -= cpy;\n\t\ts += cpy;\n\t\twhile (page_bytes > 0) {\n\t\t\tunsigned long written;\n\t\t\tint limit = 1000000;\n\n\t\t\twhile (limit--) {\n\t\t\t\tunsigned long stat;\n\n\t\t\t\tstat = sun4v_con_write(ra, page_bytes,\n\t\t\t\t\t\t       &written);\n\t\t\t\tif (stat == HV_EOK)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t\tif (limit < 0)\n\t\t\t\tbreak;\n\t\t\tpage_bytes -= written;\n\t\t\tra += written;\n\t\t}\n\t}\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic inline void sunhv_console_putchar(struct uart_port *port, char c)\n{\n\tint limit = 1000000;\n\n\twhile (limit-- > 0) {\n\t\tlong status = sun4v_con_putchar(c);\n\t\tif (status == HV_EOK)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void sunhv_console_write_bychar(struct console *con, const char *s, unsigned n)\n{\n\tstruct uart_port *port = sunhv_port;\n\tunsigned long flags;\n\tint i, locked = 1;\n\n\tif (port->sysrq || oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&port->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (*s == '\\n')\n\t\t\tsunhv_console_putchar(port, '\\r');\n\t\tsunhv_console_putchar(port, *s++);\n\t}\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic struct console sunhv_console = {\n\t.name\t=\t\"ttyHV\",\n\t.write\t=\tsunhv_console_write_bychar,\n\t.device\t=\tuart_console_device,\n\t.flags\t=\tCON_PRINTBUFFER,\n\t.index\t=\t-1,\n\t.data\t=\t&sunhv_reg,\n};\n\nstatic int hv_probe(struct platform_device *op)\n{\n\tstruct uart_port *port;\n\tunsigned long minor;\n\tint err;\n\n\tif (op->archdata.irqs[0] == 0xffffffff)\n\t\treturn -ENODEV;\n\n\tport = kzalloc(sizeof(struct uart_port), GFP_KERNEL);\n\tif (unlikely(!port))\n\t\treturn -ENOMEM;\n\n\tminor = 1;\n\tif (sun4v_hvapi_register(HV_GRP_CORE, 1, &minor) == 0 &&\n\t    minor >= 1) {\n\t\terr = -ENOMEM;\n\t\tcon_write_page = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\t\tif (!con_write_page)\n\t\t\tgoto out_free_port;\n\n\t\tcon_read_page = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\t\tif (!con_read_page)\n\t\t\tgoto out_free_con_write_page;\n\n\t\tsunhv_console.write = sunhv_console_write_paged;\n\t\tsunhv_ops = &bywrite_ops;\n\t}\n\n\tsunhv_port = port;\n\n\tport->has_sysrq = 1;\n\tport->line = 0;\n\tport->ops = &sunhv_pops;\n\tport->type = PORT_SUNHV;\n\tport->uartclk = ( 29491200 / 16 );  \n\n\tport->membase = (unsigned char __iomem *) __pa(port);\n\n\tport->irq = op->archdata.irqs[0];\n\n\tport->dev = &op->dev;\n\n\terr = sunserial_register_minors(&sunhv_reg, 1);\n\tif (err)\n\t\tgoto out_free_con_read_page;\n\n\tsunserial_console_match(&sunhv_console, op->dev.of_node,\n\t\t\t\t&sunhv_reg, port->line, false);\n\n\terr = uart_add_one_port(&sunhv_reg, port);\n\tif (err)\n\t\tgoto out_unregister_driver;\n\n\terr = request_irq(port->irq, sunhv_interrupt, 0, \"hvcons\", port);\n\tif (err)\n\t\tgoto out_remove_port;\n\n\tplatform_set_drvdata(op, port);\n\n\treturn 0;\n\nout_remove_port:\n\tuart_remove_one_port(&sunhv_reg, port);\n\nout_unregister_driver:\n\tsunserial_unregister_minors(&sunhv_reg, 1);\n\nout_free_con_read_page:\n\tkfree(con_read_page);\n\nout_free_con_write_page:\n\tkfree(con_write_page);\n\nout_free_port:\n\tkfree(port);\n\tsunhv_port = NULL;\n\treturn err;\n}\n\nstatic int hv_remove(struct platform_device *dev)\n{\n\tstruct uart_port *port = platform_get_drvdata(dev);\n\n\tfree_irq(port->irq, port);\n\n\tuart_remove_one_port(&sunhv_reg, port);\n\n\tsunserial_unregister_minors(&sunhv_reg, 1);\n\tkfree(con_read_page);\n\tkfree(con_write_page);\n\tkfree(port);\n\tsunhv_port = NULL;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id hv_match[] = {\n\t{\n\t\t.name = \"console\",\n\t\t.compatible = \"qcn\",\n\t},\n\t{\n\t\t.name = \"console\",\n\t\t.compatible = \"SUNW,sun4v-console\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver hv_driver = {\n\t.driver = {\n\t\t.name = \"hv\",\n\t\t.of_match_table = hv_match,\n\t},\n\t.probe\t\t= hv_probe,\n\t.remove\t\t= hv_remove,\n};\n\nstatic int __init sunhv_init(void)\n{\n\tif (tlb_type != hypervisor)\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&hv_driver);\n}\ndevice_initcall(sunhv_init);\n\n#if 0  \nMODULE_AUTHOR(\"David S. Miller\");\nMODULE_DESCRIPTION(\"SUN4V Hypervisor console driver\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}