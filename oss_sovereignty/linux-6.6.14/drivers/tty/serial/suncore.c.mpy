{
  "module_name": "suncore.c",
  "hash_id": "05230725589853059f719c5a91092cc196effabf9f7717a70c474e063b646dce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/suncore.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/console.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/serial_core.h>\n#include <linux/sunserialcore.h>\n#include <linux/init.h>\n\n#include <asm/prom.h>\n\n\nstatic int sunserial_current_minor = 64;\n\nint sunserial_register_minors(struct uart_driver *drv, int count)\n{\n\tint err = 0;\n\n\tdrv->minor = sunserial_current_minor;\n\tdrv->nr += count;\n\t \n\tif (drv->nr == count)\n\t\terr = uart_register_driver(drv);\n\tif (err == 0) {\n\t\tsunserial_current_minor += count;\n\t\tdrv->tty_driver->name_base = drv->minor - 64;\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(sunserial_register_minors);\n\nvoid sunserial_unregister_minors(struct uart_driver *drv, int count)\n{\n\tdrv->nr -= count;\n\tsunserial_current_minor -= count;\n\n\tif (drv->nr == 0)\n\t\tuart_unregister_driver(drv);\n}\nEXPORT_SYMBOL(sunserial_unregister_minors);\n\nint sunserial_console_match(struct console *con, struct device_node *dp,\n\t\t\t    struct uart_driver *drv, int line, bool ignore_line)\n{\n\tif (!con)\n\t\treturn 0;\n\n\tdrv->cons = con;\n\n\tif (of_console_device != dp)\n\t\treturn 0;\n\n\tif (!ignore_line) {\n\t\tint off = 0;\n\n\t\tif (of_console_options &&\n\t\t    *of_console_options == 'b')\n\t\t\toff = 1;\n\n\t\tif ((line & 1) != off)\n\t\t\treturn 0;\n\t}\n\n\tif (!console_set_on_cmdline) {\n\t\tcon->index = line;\n\t\tadd_preferred_console(con->name, line, NULL);\n\t}\n\treturn 1;\n}\nEXPORT_SYMBOL(sunserial_console_match);\n\nvoid sunserial_console_termios(struct console *con, struct device_node *uart_dp)\n{\n\tconst char *mode, *s;\n\tchar mode_prop[] = \"ttyX-mode\";\n\tint baud, bits, stop, cflag;\n\tchar parity;\n\n\tif (of_node_name_eq(uart_dp, \"rsc\") ||\n\t    of_node_name_eq(uart_dp, \"rsc-console\") ||\n\t    of_node_name_eq(uart_dp, \"rsc-control\")) {\n\t\tmode = of_get_property(uart_dp,\n\t\t\t\t       \"ssp-console-modes\", NULL);\n\t\tif (!mode)\n\t\t\tmode = \"115200,8,n,1,-\";\n\t} else if (of_node_name_eq(uart_dp, \"lom-console\")) {\n\t\tmode = \"9600,8,n,1,-\";\n\t} else {\n\t\tstruct device_node *dp;\n\t\tchar c;\n\n\t\tc = 'a';\n\t\tif (of_console_options)\n\t\t\tc = *of_console_options;\n\n\t\tmode_prop[3] = c;\n\n\t\tdp = of_find_node_by_path(\"/options\");\n\t\tmode = of_get_property(dp, mode_prop, NULL);\n\t\tif (!mode)\n\t\t\tmode = \"9600,8,n,1,-\";\n\t\tof_node_put(dp);\n\t}\n\n\tcflag = CREAD | HUPCL | CLOCAL;\n\n\ts = mode;\n\tbaud = simple_strtoul(s, NULL, 0);\n\ts = strchr(s, ',');\n\tbits = simple_strtoul(++s, NULL, 0);\n\ts = strchr(s, ',');\n\tparity = *(++s);\n\ts = strchr(s, ',');\n\tstop = simple_strtoul(++s, NULL, 0);\n\ts = strchr(s, ',');\n\t \n\n\tswitch (baud) {\n\t\tcase 150: cflag |= B150; break;\n\t\tcase 300: cflag |= B300; break;\n\t\tcase 600: cflag |= B600; break;\n\t\tcase 1200: cflag |= B1200; break;\n\t\tcase 2400: cflag |= B2400; break;\n\t\tcase 4800: cflag |= B4800; break;\n\t\tcase 9600: cflag |= B9600; break;\n\t\tcase 19200: cflag |= B19200; break;\n\t\tcase 38400: cflag |= B38400; break;\n\t\tcase 57600: cflag |= B57600; break;\n\t\tcase 115200: cflag |= B115200; break;\n\t\tcase 230400: cflag |= B230400; break;\n\t\tcase 460800: cflag |= B460800; break;\n\t\tdefault: baud = 9600; cflag |= B9600; break;\n\t}\n\n\tswitch (bits) {\n\t\tcase 5: cflag |= CS5; break;\n\t\tcase 6: cflag |= CS6; break;\n\t\tcase 7: cflag |= CS7; break;\n\t\tcase 8: cflag |= CS8; break;\n\t\tdefault: cflag |= CS8; break;\n\t}\n\n\tswitch (parity) {\n\t\tcase 'o': cflag |= (PARENB | PARODD); break;\n\t\tcase 'e': cflag |= PARENB; break;\n\t\tcase 'n': default: break;\n\t}\n\n\tswitch (stop) {\n\t\tcase 2: cflag |= CSTOPB; break;\n\t\tcase 1: default: break;\n\t}\n\n\tcon->cflag = cflag;\n}\n\n \nstatic struct mouse_baud_cflag {\n\tint baud;\n\tunsigned int cflag;\n} mouse_baud_table[] = {\n\t{ 1200, B1200 },\n\t{ 2400, B2400 },\n\t{ 4800, B4800 },\n\t{ 9600, B9600 },\n\t{ -1, ~0 },\n\t{ -1, ~0 },\n};\n\nunsigned int suncore_mouse_baud_cflag_next(unsigned int cflag, int *new_baud)\n{\n\tint i;\n\n\tfor (i = 0; mouse_baud_table[i].baud != -1; i++)\n\t\tif (mouse_baud_table[i].cflag == (cflag & CBAUD))\n\t\t\tbreak;\n\n\ti += 1;\n\tif (mouse_baud_table[i].baud == -1)\n\t\ti = 0;\n\n\t*new_baud = mouse_baud_table[i].baud;\n\treturn mouse_baud_table[i].cflag;\n}\n\nEXPORT_SYMBOL(suncore_mouse_baud_cflag_next);\n\n \nint suncore_mouse_baud_detection(unsigned char ch, int is_break)\n{\n\tstatic int mouse_got_break = 0;\n\tstatic int ctr = 0;\n\n\tif (is_break) {\n\t\t \n\t\tif (mouse_got_break && ctr < 8)\n\t\t\treturn 1;\n\n\t\t \n\t\tctr = 0;\n\t\tmouse_got_break = 1;\n\t\treturn 2;\n\t}\n\tif (mouse_got_break) {\n\t\tctr++;\n\t\tif (ch == 0x87) {\n\t\t\t \n\t\t\tmouse_got_break = 0;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL(suncore_mouse_baud_detection);\n\nstatic int __init suncore_init(void)\n{\n\treturn 0;\n}\ndevice_initcall(suncore_init);\n\n#if 0  \nMODULE_AUTHOR(\"Eddie C. Dost, David S. Miller\");\nMODULE_DESCRIPTION(\"Sun serial common layer\");\nMODULE_LICENSE(\"GPL\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}