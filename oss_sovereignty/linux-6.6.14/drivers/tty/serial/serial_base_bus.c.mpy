{
  "module_name": "serial_base_bus.c",
  "hash_id": "26552c4e9e05259753b8c41fc37b533a3b206f31b21e1a482fa2f6ddae8c45a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/serial_base_bus.c",
  "human_readable_source": "\n \n\n#include <linux/container_of.h>\n#include <linux/device.h>\n#include <linux/idr.h>\n#include <linux/module.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"serial_base.h\"\n\nstatic bool serial_base_initialized;\n\nstatic const struct device_type serial_ctrl_type = {\n\t.name = \"ctrl\",\n};\n\nstatic const struct device_type serial_port_type = {\n\t.name = \"port\",\n};\n\nstatic int serial_base_match(struct device *dev, struct device_driver *drv)\n{\n\tif (dev->type == &serial_ctrl_type &&\n\t    str_has_prefix(drv->name, serial_ctrl_type.name))\n\t\treturn 1;\n\n\tif (dev->type == &serial_port_type &&\n\t    str_has_prefix(drv->name, serial_port_type.name))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct bus_type serial_base_bus_type = {\n\t.name = \"serial-base\",\n\t.match = serial_base_match,\n};\n\nint serial_base_driver_register(struct device_driver *driver)\n{\n\tdriver->bus = &serial_base_bus_type;\n\n\treturn driver_register(driver);\n}\n\nvoid serial_base_driver_unregister(struct device_driver *driver)\n{\n\tdriver_unregister(driver);\n}\n\nstatic int serial_base_device_init(struct uart_port *port,\n\t\t\t\t   struct device *dev,\n\t\t\t\t   struct device *parent_dev,\n\t\t\t\t   const struct device_type *type,\n\t\t\t\t   void (*release)(struct device *dev),\n\t\t\t\t   unsigned int ctrl_id,\n\t\t\t\t   unsigned int port_id)\n{\n\tdevice_initialize(dev);\n\tdev->type = type;\n\tdev->parent = parent_dev;\n\tdev->bus = &serial_base_bus_type;\n\tdev->release = release;\n\n\tif (!serial_base_initialized) {\n\t\tdev_dbg(port->dev, \"uart_add_one_port() called before arch_initcall()?\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tif (type == &serial_ctrl_type)\n\t\treturn dev_set_name(dev, \"%s:%d\", dev_name(port->dev), ctrl_id);\n\n\tif (type == &serial_port_type)\n\t\treturn dev_set_name(dev, \"%s:%d.%d\", dev_name(port->dev),\n\t\t\t\t    ctrl_id, port_id);\n\n\treturn -EINVAL;\n}\n\nstatic void serial_base_ctrl_release(struct device *dev)\n{\n\tstruct serial_ctrl_device *ctrl_dev = to_serial_base_ctrl_device(dev);\n\n\tkfree(ctrl_dev);\n}\n\nvoid serial_base_ctrl_device_remove(struct serial_ctrl_device *ctrl_dev)\n{\n\tif (!ctrl_dev)\n\t\treturn;\n\n\tdevice_del(&ctrl_dev->dev);\n\tput_device(&ctrl_dev->dev);\n}\n\nstruct serial_ctrl_device *serial_base_ctrl_add(struct uart_port *port,\n\t\t\t\t\t\tstruct device *parent)\n{\n\tstruct serial_ctrl_device *ctrl_dev;\n\tint err;\n\n\tctrl_dev = kzalloc(sizeof(*ctrl_dev), GFP_KERNEL);\n\tif (!ctrl_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tida_init(&ctrl_dev->port_ida);\n\n\terr = serial_base_device_init(port, &ctrl_dev->dev,\n\t\t\t\t      parent, &serial_ctrl_type,\n\t\t\t\t      serial_base_ctrl_release,\n\t\t\t\t      port->ctrl_id, 0);\n\tif (err)\n\t\tgoto err_put_device;\n\n\terr = device_add(&ctrl_dev->dev);\n\tif (err)\n\t\tgoto err_put_device;\n\n\treturn ctrl_dev;\n\nerr_put_device:\n\tput_device(&ctrl_dev->dev);\n\n\treturn ERR_PTR(err);\n}\n\nstatic void serial_base_port_release(struct device *dev)\n{\n\tstruct serial_port_device *port_dev = to_serial_base_port_device(dev);\n\n\tkfree(port_dev);\n}\n\nstruct serial_port_device *serial_base_port_add(struct uart_port *port,\n\t\t\t\t\t\tstruct serial_ctrl_device *ctrl_dev)\n{\n\tstruct serial_port_device *port_dev;\n\tint min = 0, max = -1;\t \n\tint err;\n\n\tport_dev = kzalloc(sizeof(*port_dev), GFP_KERNEL);\n\tif (!port_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (port->port_id) {\n\t\tmin = port->port_id;\n\t\tmax = port->port_id;\n\t}\n\n\terr = ida_alloc_range(&ctrl_dev->port_ida, min, max, GFP_KERNEL);\n\tif (err < 0) {\n\t\tkfree(port_dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tport->port_id = err;\n\n\terr = serial_base_device_init(port, &port_dev->dev,\n\t\t\t\t      &ctrl_dev->dev, &serial_port_type,\n\t\t\t\t      serial_base_port_release,\n\t\t\t\t      port->ctrl_id, port->port_id);\n\tif (err)\n\t\tgoto err_put_device;\n\n\tport_dev->port = port;\n\n\terr = device_add(&port_dev->dev);\n\tif (err)\n\t\tgoto err_put_device;\n\n\treturn port_dev;\n\nerr_put_device:\n\tput_device(&port_dev->dev);\n\tida_free(&ctrl_dev->port_ida, port->port_id);\n\n\treturn ERR_PTR(err);\n}\n\nvoid serial_base_port_device_remove(struct serial_port_device *port_dev)\n{\n\tstruct serial_ctrl_device *ctrl_dev;\n\tstruct device *parent;\n\n\tif (!port_dev)\n\t\treturn;\n\n\tparent = port_dev->dev.parent;\n\tctrl_dev = to_serial_base_ctrl_device(parent);\n\n\tdevice_del(&port_dev->dev);\n\tida_free(&ctrl_dev->port_ida, port_dev->port->port_id);\n\tput_device(&port_dev->dev);\n}\n\nstatic int serial_base_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&serial_base_bus_type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = serial_base_ctrl_init();\n\tif (ret)\n\t\tgoto err_bus_unregister;\n\n\tret = serial_base_port_init();\n\tif (ret)\n\t\tgoto err_ctrl_exit;\n\n\tserial_base_initialized = true;\n\n\treturn 0;\n\nerr_ctrl_exit:\n\tserial_base_ctrl_exit();\n\nerr_bus_unregister:\n\tbus_unregister(&serial_base_bus_type);\n\n\treturn ret;\n}\narch_initcall(serial_base_init);\n\nstatic void serial_base_exit(void)\n{\n\tserial_base_port_exit();\n\tserial_base_ctrl_exit();\n\tbus_unregister(&serial_base_bus_type);\n}\nmodule_exit(serial_base_exit);\n\nMODULE_AUTHOR(\"Tony Lindgren <tony@atomide.com>\");\nMODULE_DESCRIPTION(\"Serial core bus\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}