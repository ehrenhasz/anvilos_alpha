{
  "module_name": "liteuart.c",
  "hash_id": "661a37b89736574dd1739337e5e9f3b5183914c7980dcdd00e362d5510194218",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/liteuart.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/console.h>\n#include <linux/interrupt.h>\n#include <linux/litex.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/tty_flip.h>\n#include <linux/xarray.h>\n\n \n#define OFF_RXTX\t0x00\n#define OFF_TXFULL\t0x04\n#define OFF_RXEMPTY\t0x08\n#define OFF_EV_STATUS\t0x0c\n#define OFF_EV_PENDING\t0x10\n#define OFF_EV_ENABLE\t0x14\n\n \n#define EV_TX\t\tBIT(0)\n#define EV_RX\t\tBIT(1)\n\nstruct liteuart_port {\n\tstruct uart_port port;\n\tstruct timer_list timer;\n\tu8 irq_reg;\n};\n\n#define to_liteuart_port(port)\tcontainer_of(port, struct liteuart_port, port)\n\nstatic DEFINE_XARRAY_FLAGS(liteuart_array, XA_FLAGS_ALLOC);\n\n#ifdef CONFIG_SERIAL_LITEUART_CONSOLE\nstatic struct console liteuart_console;\n#endif\n\nstatic struct uart_driver liteuart_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = KBUILD_MODNAME,\n\t.dev_name = \"ttyLXU\",\n\t.major = 0,\n\t.minor = 0,\n\t.nr = CONFIG_SERIAL_LITEUART_MAX_PORTS,\n#ifdef CONFIG_SERIAL_LITEUART_CONSOLE\n\t.cons = &liteuart_console,\n#endif\n};\n\nstatic void liteuart_update_irq_reg(struct uart_port *port, bool set, u8 mask)\n{\n\tstruct liteuart_port *uart = to_liteuart_port(port);\n\n\tif (set)\n\t\tuart->irq_reg |= mask;\n\telse\n\t\tuart->irq_reg &= ~mask;\n\n\tif (port->irq)\n\t\tlitex_write8(port->membase + OFF_EV_ENABLE, uart->irq_reg);\n}\n\nstatic void liteuart_stop_tx(struct uart_port *port)\n{\n\tliteuart_update_irq_reg(port, false, EV_TX);\n}\n\nstatic void liteuart_start_tx(struct uart_port *port)\n{\n\tliteuart_update_irq_reg(port, true, EV_TX);\n}\n\nstatic void liteuart_stop_rx(struct uart_port *port)\n{\n\tstruct liteuart_port *uart = to_liteuart_port(port);\n\n\t \n\tdel_timer(&uart->timer);\n}\n\nstatic void liteuart_rx_chars(struct uart_port *port)\n{\n\tunsigned char __iomem *membase = port->membase;\n\tu8 ch;\n\n\twhile (!litex_read8(membase + OFF_RXEMPTY)) {\n\t\tch = litex_read8(membase + OFF_RXTX);\n\t\tport->icount.rx++;\n\n\t\t \n\t\tlitex_write8(membase + OFF_EV_PENDING, EV_RX);\n\n\t\t \n\t\tif (!(uart_handle_sysrq_char(port, ch)))\n\t\t\tuart_insert_char(port, 1, 0, ch, TTY_NORMAL);\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic void liteuart_tx_chars(struct uart_port *port)\n{\n\tu8 ch;\n\n\tuart_port_tx(port, ch,\n\t\t!litex_read8(port->membase + OFF_TXFULL),\n\t\tlitex_write8(port->membase + OFF_RXTX, ch));\n}\n\nstatic irqreturn_t liteuart_interrupt(int irq, void *data)\n{\n\tstruct liteuart_port *uart = data;\n\tstruct uart_port *port = &uart->port;\n\tunsigned long flags;\n\tu8 isr;\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tisr = litex_read8(port->membase + OFF_EV_PENDING) & uart->irq_reg;\n\tif (isr & EV_RX)\n\t\tliteuart_rx_chars(port);\n\tif (isr & EV_TX)\n\t\tliteuart_tx_chars(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn IRQ_RETVAL(isr);\n}\n\nstatic void liteuart_timer(struct timer_list *t)\n{\n\tstruct liteuart_port *uart = from_timer(uart, t, timer);\n\tstruct uart_port *port = &uart->port;\n\n\tliteuart_interrupt(0, port);\n\tmod_timer(&uart->timer, jiffies + uart_poll_timeout(port));\n}\n\nstatic unsigned int liteuart_tx_empty(struct uart_port *port)\n{\n\t \n\tif (!litex_read8(port->membase + OFF_TXFULL))\n\t\treturn TIOCSER_TEMT;\n\n\treturn 0;\n}\n\nstatic void liteuart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\t \n}\n\nstatic unsigned int liteuart_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\n}\n\nstatic int liteuart_startup(struct uart_port *port)\n{\n\tstruct liteuart_port *uart = to_liteuart_port(port);\n\tunsigned long flags;\n\tint ret;\n\n\tif (port->irq) {\n\t\tret = request_irq(port->irq, liteuart_interrupt, 0,\n\t\t\t\t  KBUILD_MODNAME, uart);\n\t\tif (ret) {\n\t\t\tdev_warn(port->dev,\n\t\t\t\t\"line %d irq %d failed: switch to polling\\n\",\n\t\t\t\tport->line, port->irq);\n\t\t\tport->irq = 0;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\t \n\tliteuart_update_irq_reg(port, true, EV_RX);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (!port->irq) {\n\t\ttimer_setup(&uart->timer, liteuart_timer, 0);\n\t\tmod_timer(&uart->timer, jiffies + uart_poll_timeout(port));\n\t}\n\n\treturn 0;\n}\n\nstatic void liteuart_shutdown(struct uart_port *port)\n{\n\tstruct liteuart_port *uart = to_liteuart_port(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tliteuart_update_irq_reg(port, false, EV_RX | EV_TX);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (port->irq)\n\t\tfree_irq(port->irq, port);\n\telse\n\t\tdel_timer_sync(&uart->timer);\n}\n\nstatic void liteuart_set_termios(struct uart_port *port, struct ktermios *new,\n\t\t\t\t const struct ktermios *old)\n{\n\tunsigned int baud;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tbaud = uart_get_baud_rate(port, new, old, 0, 460800);\n\tuart_update_timeout(port, new->c_cflag, baud);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *liteuart_type(struct uart_port *port)\n{\n\treturn \"liteuart\";\n}\n\nstatic void liteuart_config_port(struct uart_port *port, int flags)\n{\n\t \n\tport->type = 1;\n}\n\nstatic int liteuart_verify_port(struct uart_port *port,\n\t\t\t\tstruct serial_struct *ser)\n{\n\tif (port->type != PORT_UNKNOWN && ser->type != 1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct uart_ops liteuart_ops = {\n\t.tx_empty\t= liteuart_tx_empty,\n\t.set_mctrl\t= liteuart_set_mctrl,\n\t.get_mctrl\t= liteuart_get_mctrl,\n\t.stop_tx\t= liteuart_stop_tx,\n\t.start_tx\t= liteuart_start_tx,\n\t.stop_rx\t= liteuart_stop_rx,\n\t.startup\t= liteuart_startup,\n\t.shutdown\t= liteuart_shutdown,\n\t.set_termios\t= liteuart_set_termios,\n\t.type\t\t= liteuart_type,\n\t.config_port\t= liteuart_config_port,\n\t.verify_port\t= liteuart_verify_port,\n};\n\nstatic int liteuart_probe(struct platform_device *pdev)\n{\n\tstruct liteuart_port *uart;\n\tstruct uart_port *port;\n\tstruct xa_limit limit;\n\tint dev_id, ret;\n\n\tuart = devm_kzalloc(&pdev->dev, sizeof(struct liteuart_port), GFP_KERNEL);\n\tif (!uart)\n\t\treturn -ENOMEM;\n\n\tport = &uart->port;\n\n\t \n\tport->membase = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(port->membase))\n\t\treturn PTR_ERR(port->membase);\n\n\tret = platform_get_irq_optional(pdev, 0);\n\tif (ret < 0 && ret != -ENXIO)\n\t\treturn ret;\n\tif (ret > 0)\n\t\tport->irq = ret;\n\n\t \n\tdev_id = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\tif (dev_id < 0)\n\t\tlimit = XA_LIMIT(0, CONFIG_SERIAL_LITEUART_MAX_PORTS);\n\telse\n\t\tlimit = XA_LIMIT(dev_id, dev_id);\n\n\tret = xa_alloc(&liteuart_array, &dev_id, uart, limit, GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tport->dev = &pdev->dev;\n\tport->iotype = UPIO_MEM;\n\tport->flags = UPF_BOOT_AUTOCONF;\n\tport->ops = &liteuart_ops;\n\tport->fifosize = 16;\n\tport->type = PORT_UNKNOWN;\n\tport->line = dev_id;\n\tspin_lock_init(&port->lock);\n\n\tplatform_set_drvdata(pdev, port);\n\n\tret = uart_add_one_port(&liteuart_driver, &uart->port);\n\tif (ret)\n\t\tgoto err_erase_id;\n\n\treturn 0;\n\nerr_erase_id:\n\txa_erase(&liteuart_array, dev_id);\n\n\treturn ret;\n}\n\nstatic int liteuart_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = platform_get_drvdata(pdev);\n\tunsigned int line = port->line;\n\n\tuart_remove_one_port(&liteuart_driver, port);\n\txa_erase(&liteuart_array, line);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id liteuart_of_match[] = {\n\t{ .compatible = \"litex,liteuart\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, liteuart_of_match);\n\nstatic struct platform_driver liteuart_platform_driver = {\n\t.probe = liteuart_probe,\n\t.remove = liteuart_remove,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = liteuart_of_match,\n\t},\n};\n\n#ifdef CONFIG_SERIAL_LITEUART_CONSOLE\n\nstatic void liteuart_putchar(struct uart_port *port, unsigned char ch)\n{\n\twhile (litex_read8(port->membase + OFF_TXFULL))\n\t\tcpu_relax();\n\n\tlitex_write8(port->membase + OFF_RXTX, ch);\n}\n\nstatic void liteuart_console_write(struct console *co, const char *s,\n\tunsigned int count)\n{\n\tstruct liteuart_port *uart;\n\tstruct uart_port *port;\n\tunsigned long flags;\n\n\tuart = (struct liteuart_port *)xa_load(&liteuart_array, co->index);\n\tport = &uart->port;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tuart_console_write(port, s, count, liteuart_putchar);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int liteuart_console_setup(struct console *co, char *options)\n{\n\tstruct liteuart_port *uart;\n\tstruct uart_port *port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tuart = (struct liteuart_port *)xa_load(&liteuart_array, co->index);\n\tif (!uart)\n\t\treturn -ENODEV;\n\n\tport = &uart->port;\n\tif (!port->membase)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct console liteuart_console = {\n\t.name = KBUILD_MODNAME,\n\t.write = liteuart_console_write,\n\t.device = uart_console_device,\n\t.setup = liteuart_console_setup,\n\t.flags = CON_PRINTBUFFER,\n\t.index = -1,\n\t.data = &liteuart_driver,\n};\n\nstatic int __init liteuart_console_init(void)\n{\n\tregister_console(&liteuart_console);\n\n\treturn 0;\n}\nconsole_initcall(liteuart_console_init);\n\nstatic void early_liteuart_write(struct console *console, const char *s,\n\t\t\t\t    unsigned int count)\n{\n\tstruct earlycon_device *device = console->data;\n\tstruct uart_port *port = &device->port;\n\n\tuart_console_write(port, s, count, liteuart_putchar);\n}\n\nstatic int __init early_liteuart_setup(struct earlycon_device *device,\n\t\t\t\t       const char *options)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = early_liteuart_write;\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(liteuart, \"litex,liteuart\", early_liteuart_setup);\n#endif  \n\nstatic int __init liteuart_init(void)\n{\n\tint res;\n\n\tres = uart_register_driver(&liteuart_driver);\n\tif (res)\n\t\treturn res;\n\n\tres = platform_driver_register(&liteuart_platform_driver);\n\tif (res)\n\t\tuart_unregister_driver(&liteuart_driver);\n\n\treturn res;\n}\n\nstatic void __exit liteuart_exit(void)\n{\n\tplatform_driver_unregister(&liteuart_platform_driver);\n\tuart_unregister_driver(&liteuart_driver);\n}\n\nmodule_init(liteuart_init);\nmodule_exit(liteuart_exit);\n\nMODULE_AUTHOR(\"Antmicro <www.antmicro.com>\");\nMODULE_DESCRIPTION(\"LiteUART serial driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:liteuart\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}