{
  "module_name": "milbeaut_usio.c",
  "hash_id": "259d6dc9f7187ac5642df9bf955cbecb2d6429643a2829ebe491bf42fac44edf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/milbeaut_usio.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/serial_core.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#define USIO_NAME\t\t\"mlb-usio-uart\"\n#define USIO_UART_DEV_NAME\t\"ttyUSI\"\n\nstatic struct uart_port mlb_usio_ports[CONFIG_SERIAL_MILBEAUT_USIO_PORTS];\n\n#define RX\t0\n#define TX\t1\nstatic int mlb_usio_irq[CONFIG_SERIAL_MILBEAUT_USIO_PORTS][2];\n\n#define MLB_USIO_REG_SMR\t\t0\n#define MLB_USIO_REG_SCR\t\t1\n#define MLB_USIO_REG_ESCR\t\t2\n#define MLB_USIO_REG_SSR\t\t3\n#define MLB_USIO_REG_DR\t\t\t4\n#define MLB_USIO_REG_BGR\t\t6\n#define MLB_USIO_REG_FCR\t\t12\n#define MLB_USIO_REG_FBYTE\t\t14\n\n#define MLB_USIO_SMR_SOE\t\tBIT(0)\n#define MLB_USIO_SMR_SBL\t\tBIT(3)\n#define MLB_USIO_SCR_TXE\t\tBIT(0)\n#define MLB_USIO_SCR_RXE\t\tBIT(1)\n#define MLB_USIO_SCR_TBIE\t\tBIT(2)\n#define MLB_USIO_SCR_TIE\t\tBIT(3)\n#define MLB_USIO_SCR_RIE\t\tBIT(4)\n#define MLB_USIO_SCR_UPCL\t\tBIT(7)\n#define MLB_USIO_ESCR_L_8BIT\t\t0\n#define MLB_USIO_ESCR_L_5BIT\t\t1\n#define MLB_USIO_ESCR_L_6BIT\t\t2\n#define MLB_USIO_ESCR_L_7BIT\t\t3\n#define MLB_USIO_ESCR_P\t\t\tBIT(3)\n#define MLB_USIO_ESCR_PEN\t\tBIT(4)\n#define MLB_USIO_ESCR_FLWEN\t\tBIT(7)\n#define MLB_USIO_SSR_TBI\t\tBIT(0)\n#define MLB_USIO_SSR_TDRE\t\tBIT(1)\n#define MLB_USIO_SSR_RDRF\t\tBIT(2)\n#define MLB_USIO_SSR_ORE\t\tBIT(3)\n#define MLB_USIO_SSR_FRE\t\tBIT(4)\n#define MLB_USIO_SSR_PE\t\t\tBIT(5)\n#define MLB_USIO_SSR_REC\t\tBIT(7)\n#define MLB_USIO_SSR_BRK\t\tBIT(8)\n#define MLB_USIO_FCR_FE1\t\tBIT(0)\n#define MLB_USIO_FCR_FE2\t\tBIT(1)\n#define MLB_USIO_FCR_FCL1\t\tBIT(2)\n#define MLB_USIO_FCR_FCL2\t\tBIT(3)\n#define MLB_USIO_FCR_FSET\t\tBIT(4)\n#define MLB_USIO_FCR_FTIE\t\tBIT(9)\n#define MLB_USIO_FCR_FDRQ\t\tBIT(10)\n#define MLB_USIO_FCR_FRIIE\t\tBIT(11)\n\nstatic void mlb_usio_stop_tx(struct uart_port *port)\n{\n\twritew(readw(port->membase + MLB_USIO_REG_FCR) & ~MLB_USIO_FCR_FTIE,\n\t       port->membase + MLB_USIO_REG_FCR);\n\twriteb(readb(port->membase + MLB_USIO_REG_SCR) & ~MLB_USIO_SCR_TBIE,\n\t       port->membase + MLB_USIO_REG_SCR);\n}\n\nstatic void mlb_usio_tx_chars(struct uart_port *port)\n{\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tint count;\n\n\twritew(readw(port->membase + MLB_USIO_REG_FCR) & ~MLB_USIO_FCR_FTIE,\n\t       port->membase + MLB_USIO_REG_FCR);\n\twriteb(readb(port->membase + MLB_USIO_REG_SCR) &\n\t       ~(MLB_USIO_SCR_TIE | MLB_USIO_SCR_TBIE),\n\t       port->membase + MLB_USIO_REG_SCR);\n\n\tif (port->x_char) {\n\t\twritew(port->x_char, port->membase + MLB_USIO_REG_DR);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn;\n\t}\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\tmlb_usio_stop_tx(port);\n\t\treturn;\n\t}\n\n\tcount = port->fifosize -\n\t\t(readw(port->membase + MLB_USIO_REG_FBYTE) & 0xff);\n\n\tdo {\n\t\twritew(xmit->buf[xmit->tail], port->membase + MLB_USIO_REG_DR);\n\n\t\tuart_xmit_advance(port, 1);\n\t\tif (uart_circ_empty(xmit))\n\t\t\tbreak;\n\n\t} while (--count > 0);\n\n\twritew(readw(port->membase + MLB_USIO_REG_FCR) & ~MLB_USIO_FCR_FDRQ,\n\t       port->membase + MLB_USIO_REG_FCR);\n\n\twriteb(readb(port->membase + MLB_USIO_REG_SCR) | MLB_USIO_SCR_TBIE,\n\t       port->membase + MLB_USIO_REG_SCR);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (uart_circ_empty(xmit))\n\t\tmlb_usio_stop_tx(port);\n}\n\nstatic void mlb_usio_start_tx(struct uart_port *port)\n{\n\tu16 fcr = readw(port->membase + MLB_USIO_REG_FCR);\n\n\twritew(fcr | MLB_USIO_FCR_FTIE, port->membase + MLB_USIO_REG_FCR);\n\tif (!(fcr & MLB_USIO_FCR_FDRQ))\n\t\treturn;\n\n\twriteb(readb(port->membase + MLB_USIO_REG_SCR) | MLB_USIO_SCR_TBIE,\n\t       port->membase + MLB_USIO_REG_SCR);\n\n\tif (readb(port->membase + MLB_USIO_REG_SSR) & MLB_USIO_SSR_TBI)\n\t\tmlb_usio_tx_chars(port);\n}\n\nstatic void mlb_usio_stop_rx(struct uart_port *port)\n{\n\twriteb(readb(port->membase + MLB_USIO_REG_SCR) & ~MLB_USIO_SCR_RIE,\n\t       port->membase + MLB_USIO_REG_SCR);\n}\n\nstatic void mlb_usio_enable_ms(struct uart_port *port)\n{\n\twriteb(readb(port->membase + MLB_USIO_REG_SCR) |\n\t       MLB_USIO_SCR_RIE | MLB_USIO_SCR_RXE,\n\t       port->membase + MLB_USIO_REG_SCR);\n}\n\nstatic void mlb_usio_rx_chars(struct uart_port *port)\n{\n\tstruct tty_port *ttyport = &port->state->port;\n\tu8 flag = 0, ch = 0;\n\tu8 status;\n\tint max_count = 2;\n\n\twhile (max_count--) {\n\t\tstatus = readb(port->membase + MLB_USIO_REG_SSR);\n\n\t\tif (!(status & MLB_USIO_SSR_RDRF))\n\t\t\tbreak;\n\n\t\tif (!(status & (MLB_USIO_SSR_ORE | MLB_USIO_SSR_FRE |\n\t\t\t\tMLB_USIO_SSR_PE))) {\n\t\t\tch = readw(port->membase + MLB_USIO_REG_DR);\n\t\t\tflag = TTY_NORMAL;\n\t\t\tport->icount.rx++;\n\t\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\t\tcontinue;\n\t\t\tuart_insert_char(port, status, MLB_USIO_SSR_ORE,\n\t\t\t\t\t ch, flag);\n\t\t\tcontinue;\n\t\t}\n\t\tif (status & MLB_USIO_SSR_PE)\n\t\t\tport->icount.parity++;\n\t\tif (status & MLB_USIO_SSR_ORE)\n\t\t\tport->icount.overrun++;\n\t\tstatus &= port->read_status_mask;\n\t\tif (status & MLB_USIO_SSR_BRK) {\n\t\t\tflag = TTY_BREAK;\n\t\t\tch = 0;\n\t\t} else\n\t\t\tif (status & MLB_USIO_SSR_PE) {\n\t\t\t\tflag = TTY_PARITY;\n\t\t\t\tch = 0;\n\t\t\t} else\n\t\t\t\tif (status & MLB_USIO_SSR_FRE) {\n\t\t\t\t\tflag = TTY_FRAME;\n\t\t\t\t\tch = 0;\n\t\t\t\t}\n\t\tif (flag)\n\t\t\tuart_insert_char(port, status, MLB_USIO_SSR_ORE,\n\t\t\t\t\t ch, flag);\n\n\t\twriteb(readb(port->membase + MLB_USIO_REG_SSR) |\n\t\t\t\tMLB_USIO_SSR_REC,\n\t\t\t\tport->membase + MLB_USIO_REG_SSR);\n\n\t\tmax_count = readw(port->membase + MLB_USIO_REG_FBYTE) >> 8;\n\t\twritew(readw(port->membase + MLB_USIO_REG_FCR) |\n\t\t       MLB_USIO_FCR_FE2 | MLB_USIO_FCR_FRIIE,\n\t\tport->membase + MLB_USIO_REG_FCR);\n\t}\n\n\ttty_flip_buffer_push(ttyport);\n}\n\nstatic irqreturn_t mlb_usio_rx_irq(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\n\tspin_lock(&port->lock);\n\tmlb_usio_rx_chars(port);\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mlb_usio_tx_irq(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\n\tspin_lock(&port->lock);\n\tif (readb(port->membase + MLB_USIO_REG_SSR) & MLB_USIO_SSR_TBI)\n\t\tmlb_usio_tx_chars(port);\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int mlb_usio_tx_empty(struct uart_port *port)\n{\n\treturn (readb(port->membase + MLB_USIO_REG_SSR) & MLB_USIO_SSR_TBI) ?\n\t\tTIOCSER_TEMT : 0;\n}\n\nstatic void mlb_usio_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n}\n\nstatic unsigned int mlb_usio_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n\n}\n\nstatic void mlb_usio_break_ctl(struct uart_port *port, int break_state)\n{\n}\n\nstatic int mlb_usio_startup(struct uart_port *port)\n{\n\tconst char *portname = to_platform_device(port->dev)->name;\n\tunsigned long flags;\n\tint ret, index = port->line;\n\tunsigned char  escr;\n\n\tret = request_irq(mlb_usio_irq[index][RX], mlb_usio_rx_irq,\n\t\t\t\t0, portname, port);\n\tif (ret)\n\t\treturn ret;\n\tret = request_irq(mlb_usio_irq[index][TX], mlb_usio_tx_irq,\n\t\t\t\t0, portname, port);\n\tif (ret) {\n\t\tfree_irq(mlb_usio_irq[index][RX], port);\n\t\treturn ret;\n\t}\n\n\tescr = readb(port->membase + MLB_USIO_REG_ESCR);\n\tif (of_property_read_bool(port->dev->of_node, \"auto-flow-control\"))\n\t\tescr |= MLB_USIO_ESCR_FLWEN;\n\tspin_lock_irqsave(&port->lock, flags);\n\twriteb(0, port->membase + MLB_USIO_REG_SCR);\n\twriteb(escr, port->membase + MLB_USIO_REG_ESCR);\n\twriteb(MLB_USIO_SCR_UPCL, port->membase + MLB_USIO_REG_SCR);\n\twriteb(MLB_USIO_SSR_REC, port->membase + MLB_USIO_REG_SSR);\n\twritew(0, port->membase + MLB_USIO_REG_FCR);\n\twritew(MLB_USIO_FCR_FCL1 | MLB_USIO_FCR_FCL2,\n\t       port->membase + MLB_USIO_REG_FCR);\n\twritew(MLB_USIO_FCR_FE1 | MLB_USIO_FCR_FE2 | MLB_USIO_FCR_FRIIE,\n\t       port->membase + MLB_USIO_REG_FCR);\n\twritew(0, port->membase + MLB_USIO_REG_FBYTE);\n\twritew(BIT(12), port->membase + MLB_USIO_REG_FBYTE);\n\n\twriteb(MLB_USIO_SCR_TXE  | MLB_USIO_SCR_RIE | MLB_USIO_SCR_TBIE |\n\t       MLB_USIO_SCR_RXE, port->membase + MLB_USIO_REG_SCR);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn 0;\n}\n\nstatic void mlb_usio_shutdown(struct uart_port *port)\n{\n\tint index = port->line;\n\n\tfree_irq(mlb_usio_irq[index][RX], port);\n\tfree_irq(mlb_usio_irq[index][TX], port);\n}\n\nstatic void mlb_usio_set_termios(struct uart_port *port,\n\t\t\t\t struct ktermios *termios,\n\t\t\t\t const struct ktermios *old)\n{\n\tunsigned int escr, smr = MLB_USIO_SMR_SOE;\n\tunsigned long flags, baud, quot;\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tescr = MLB_USIO_ESCR_L_5BIT;\n\t\tbreak;\n\tcase CS6:\n\t\tescr = MLB_USIO_ESCR_L_6BIT;\n\t\tbreak;\n\tcase CS7:\n\t\tescr = MLB_USIO_ESCR_L_7BIT;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tescr = MLB_USIO_ESCR_L_8BIT;\n\t\tbreak;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tsmr |= MLB_USIO_SMR_SBL;\n\n\tif (termios->c_cflag & PARENB) {\n\t\tescr |= MLB_USIO_ESCR_PEN;\n\t\tif (termios->c_cflag & PARODD)\n\t\t\tescr |= MLB_USIO_ESCR_P;\n\t}\n\t \n\tif (of_property_read_bool(port->dev->of_node, \"auto-flow-control\") ||\n\t\t\t(termios->c_cflag & CRTSCTS))\n\t\tescr |= MLB_USIO_ESCR_FLWEN;\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk);\n\tif (baud > 1)\n\t\tquot = port->uartclk / baud - 1;\n\telse\n\t\tquot = 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\tport->read_status_mask = MLB_USIO_SSR_ORE | MLB_USIO_SSR_RDRF |\n\t\t\t\t MLB_USIO_SSR_TDRE;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= MLB_USIO_SSR_FRE | MLB_USIO_SSR_PE;\n\n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= MLB_USIO_SSR_FRE | MLB_USIO_SSR_PE;\n\tif ((termios->c_iflag & IGNBRK) && (termios->c_iflag & IGNPAR))\n\t\tport->ignore_status_mask |= MLB_USIO_SSR_ORE;\n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= MLB_USIO_SSR_RDRF;\n\n\twriteb(0, port->membase + MLB_USIO_REG_SCR);\n\twriteb(MLB_USIO_SCR_UPCL, port->membase + MLB_USIO_REG_SCR);\n\twriteb(MLB_USIO_SSR_REC, port->membase + MLB_USIO_REG_SSR);\n\twritew(0, port->membase + MLB_USIO_REG_FCR);\n\twriteb(smr, port->membase + MLB_USIO_REG_SMR);\n\twriteb(escr, port->membase + MLB_USIO_REG_ESCR);\n\twritew(quot, port->membase + MLB_USIO_REG_BGR);\n\twritew(0, port->membase + MLB_USIO_REG_FCR);\n\twritew(MLB_USIO_FCR_FCL1 | MLB_USIO_FCR_FCL2 | MLB_USIO_FCR_FE1 |\n\t       MLB_USIO_FCR_FE2 | MLB_USIO_FCR_FRIIE,\n\t       port->membase + MLB_USIO_REG_FCR);\n\twritew(0, port->membase + MLB_USIO_REG_FBYTE);\n\twritew(BIT(12), port->membase + MLB_USIO_REG_FBYTE);\n\twriteb(MLB_USIO_SCR_RIE | MLB_USIO_SCR_RXE | MLB_USIO_SCR_TBIE |\n\t       MLB_USIO_SCR_TXE, port->membase + MLB_USIO_REG_SCR);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *mlb_usio_type(struct uart_port *port)\n{\n\treturn ((port->type == PORT_MLB_USIO) ? USIO_NAME : NULL);\n}\n\nstatic void mlb_usio_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_MLB_USIO;\n}\n\nstatic const struct uart_ops mlb_usio_ops = {\n\t.tx_empty\t= mlb_usio_tx_empty,\n\t.set_mctrl\t= mlb_usio_set_mctrl,\n\t.get_mctrl\t= mlb_usio_get_mctrl,\n\t.stop_tx\t= mlb_usio_stop_tx,\n\t.start_tx\t= mlb_usio_start_tx,\n\t.stop_rx\t= mlb_usio_stop_rx,\n\t.enable_ms\t= mlb_usio_enable_ms,\n\t.break_ctl\t= mlb_usio_break_ctl,\n\t.startup\t= mlb_usio_startup,\n\t.shutdown\t= mlb_usio_shutdown,\n\t.set_termios\t= mlb_usio_set_termios,\n\t.type\t\t= mlb_usio_type,\n\t.config_port\t= mlb_usio_config_port,\n};\n\n#ifdef CONFIG_SERIAL_MILBEAUT_USIO_CONSOLE\n\nstatic void mlb_usio_console_putchar(struct uart_port *port, unsigned char c)\n{\n\twhile (!(readb(port->membase + MLB_USIO_REG_SSR) & MLB_USIO_SSR_TDRE))\n\t\tcpu_relax();\n\n\twritew(c, port->membase + MLB_USIO_REG_DR);\n}\n\nstatic void mlb_usio_console_write(struct console *co, const char *s,\n\t\t\t       unsigned int count)\n{\n\tstruct uart_port *port = &mlb_usio_ports[co->index];\n\n\tuart_console_write(port, s, count, mlb_usio_console_putchar);\n}\n\nstatic int __init mlb_usio_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint baud = 115200;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint bits = 8;\n\n\tif (co->index >= CONFIG_SERIAL_MILBEAUT_USIO_PORTS)\n\t\treturn -ENODEV;\n\n\tport = &mlb_usio_ports[co->index];\n\tif (!port->membase)\n\t\treturn -ENODEV;\n\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\tif (of_property_read_bool(port->dev->of_node, \"auto-flow-control\"))\n\t\tflow = 'r';\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\n\nstatic struct uart_driver mlb_usio_uart_driver;\nstatic struct console mlb_usio_console = {\n\t.name   = USIO_UART_DEV_NAME,\n\t.write  = mlb_usio_console_write,\n\t.device = uart_console_device,\n\t.setup  = mlb_usio_console_setup,\n\t.flags  = CON_PRINTBUFFER,\n\t.index  = -1,\n\t.data   = &mlb_usio_uart_driver,\n};\n\nstatic int __init mlb_usio_console_init(void)\n{\n\tregister_console(&mlb_usio_console);\n\treturn 0;\n}\nconsole_initcall(mlb_usio_console_init);\n\n\nstatic void mlb_usio_early_console_write(struct console *co, const char *s,\n\t\t\t\t\tu_int count)\n{\n\tstruct earlycon_device *dev = co->data;\n\n\tuart_console_write(&dev->port, s, count, mlb_usio_console_putchar);\n}\n\nstatic int __init mlb_usio_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t\tconst char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\tdevice->con->write = mlb_usio_early_console_write;\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(mlb_usio, \"socionext,milbeaut-usio-uart\",\n\t\t\tmlb_usio_early_console_setup);\n\n#define USIO_CONSOLE\t(&mlb_usio_console)\n#else\n#define USIO_CONSOLE\tNULL\n#endif\n\nstatic struct  uart_driver mlb_usio_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= USIO_NAME,\n\t.dev_name\t= USIO_UART_DEV_NAME,\n\t.cons           = USIO_CONSOLE,\n\t.nr\t\t= CONFIG_SERIAL_MILBEAUT_USIO_PORTS,\n};\n\nstatic int mlb_usio_probe(struct platform_device *pdev)\n{\n\tstruct clk *clk = devm_clk_get(&pdev->dev, NULL);\n\tstruct uart_port *port;\n\tstruct resource *res;\n\tint index = 0;\n\tint ret;\n\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"Missing clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Clock enable failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tof_property_read_u32(pdev->dev.of_node, \"index\", &index);\n\tport = &mlb_usio_ports[index];\n\n\tport->private_data = (void *)clk;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"Missing regs\\n\");\n\t\tret = -ENODEV;\n\t\tgoto failed;\n\t}\n\tport->membase = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\tresource_size(res));\n\n\tret = platform_get_irq_byname(pdev, \"rx\");\n\tmlb_usio_irq[index][RX] = ret;\n\n\tret = platform_get_irq_byname(pdev, \"tx\");\n\tmlb_usio_irq[index][TX] = ret;\n\n\tport->irq = mlb_usio_irq[index][RX];\n\tport->uartclk = clk_get_rate(clk);\n\tport->fifosize = 128;\n\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_MILBEAUT_USIO_CONSOLE);\n\tport->iotype = UPIO_MEM32;\n\tport->flags = UPF_BOOT_AUTOCONF | UPF_SPD_VHI;\n\tport->line = index;\n\tport->ops = &mlb_usio_ops;\n\tport->dev = &pdev->dev;\n\n\tret = uart_add_one_port(&mlb_usio_uart_driver, port);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Adding port failed: %d\\n\", ret);\n\t\tgoto failed;\n\t}\n\treturn 0;\n\nfailed:\n\tclk_disable_unprepare(clk);\n\n\treturn ret;\n}\n\nstatic int mlb_usio_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = &mlb_usio_ports[pdev->id];\n\tstruct clk *clk = port->private_data;\n\n\tuart_remove_one_port(&mlb_usio_uart_driver, port);\n\tclk_disable_unprepare(clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mlb_usio_dt_ids[] = {\n\t{ .compatible = \"socionext,milbeaut-usio-uart\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mlb_usio_dt_ids);\n\nstatic struct platform_driver mlb_usio_driver = {\n\t.probe          = mlb_usio_probe,\n\t.remove         = mlb_usio_remove,\n\t.driver         = {\n\t\t.name   = USIO_NAME,\n\t\t.of_match_table = mlb_usio_dt_ids,\n\t},\n};\n\nstatic int __init mlb_usio_init(void)\n{\n\tint ret = uart_register_driver(&mlb_usio_uart_driver);\n\n\tif (ret) {\n\t\tpr_err(\"%s: uart registration failed: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\tret = platform_driver_register(&mlb_usio_driver);\n\tif (ret) {\n\t\tuart_unregister_driver(&mlb_usio_uart_driver);\n\t\tpr_err(\"%s: drv registration failed: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit mlb_usio_exit(void)\n{\n\tplatform_driver_unregister(&mlb_usio_driver);\n\tuart_unregister_driver(&mlb_usio_uart_driver);\n}\n\nmodule_init(mlb_usio_init);\nmodule_exit(mlb_usio_exit);\n\nMODULE_AUTHOR(\"SOCIONEXT\");\nMODULE_DESCRIPTION(\"MILBEAUT_USIO/UART Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}