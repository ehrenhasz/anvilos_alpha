{
  "module_name": "amba-pl010.c",
  "hash_id": "a546109f3184d2f25619fda7d13c2d5d8517aab5f8276656fb003133f8ab201d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/amba-pl010.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/device.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/amba/bus.h>\n#include <linux/amba/serial.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#define UART_NR\t\t8\n\n#define SERIAL_AMBA_MAJOR\t204\n#define SERIAL_AMBA_MINOR\t16\n#define SERIAL_AMBA_NR\t\tUART_NR\n\n#define AMBA_ISR_PASS_LIMIT\t256\n\n#define UART_RX_DATA(s)\t\t(((s) & UART01x_FR_RXFE) == 0)\n#define UART_TX_READY(s)\t(((s) & UART01x_FR_TXFF) == 0)\n\n#define UART_DUMMY_RSR_RX\t256\n#define UART_PORT_SIZE\t\t64\n\n \nstruct uart_amba_port {\n\tstruct uart_port\tport;\n\tstruct clk\t\t*clk;\n\tstruct amba_device\t*dev;\n\tstruct amba_pl010_data\t*data;\n\tunsigned int\t\told_status;\n};\n\nstatic void pl010_stop_tx(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t\tcontainer_of(port, struct uart_amba_port, port);\n\tunsigned int cr;\n\n\tcr = readb(uap->port.membase + UART010_CR);\n\tcr &= ~UART010_CR_TIE;\n\twritel(cr, uap->port.membase + UART010_CR);\n}\n\nstatic void pl010_start_tx(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t\tcontainer_of(port, struct uart_amba_port, port);\n\tunsigned int cr;\n\n\tcr = readb(uap->port.membase + UART010_CR);\n\tcr |= UART010_CR_TIE;\n\twritel(cr, uap->port.membase + UART010_CR);\n}\n\nstatic void pl010_stop_rx(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t\tcontainer_of(port, struct uart_amba_port, port);\n\tunsigned int cr;\n\n\tcr = readb(uap->port.membase + UART010_CR);\n\tcr &= ~(UART010_CR_RIE | UART010_CR_RTIE);\n\twritel(cr, uap->port.membase + UART010_CR);\n}\n\nstatic void pl010_disable_ms(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap = (struct uart_amba_port *)port;\n\tunsigned int cr;\n\n\tcr = readb(uap->port.membase + UART010_CR);\n\tcr &= ~UART010_CR_MSIE;\n\twritel(cr, uap->port.membase + UART010_CR);\n}\n\nstatic void pl010_enable_ms(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t\tcontainer_of(port, struct uart_amba_port, port);\n\tunsigned int cr;\n\n\tcr = readb(uap->port.membase + UART010_CR);\n\tcr |= UART010_CR_MSIE;\n\twritel(cr, uap->port.membase + UART010_CR);\n}\n\nstatic void pl010_rx_chars(struct uart_port *port)\n{\n\tunsigned int status, rsr, max_count = 256;\n\tu8 ch, flag;\n\n\tstatus = readb(port->membase + UART01x_FR);\n\twhile (UART_RX_DATA(status) && max_count--) {\n\t\tch = readb(port->membase + UART01x_DR);\n\t\tflag = TTY_NORMAL;\n\n\t\tport->icount.rx++;\n\n\t\t \n\t\trsr = readb(port->membase + UART01x_RSR) | UART_DUMMY_RSR_RX;\n\t\tif (unlikely(rsr & UART01x_RSR_ANY)) {\n\t\t\twritel(0, port->membase + UART01x_ECR);\n\n\t\t\tif (rsr & UART01x_RSR_BE) {\n\t\t\t\trsr &= ~(UART01x_RSR_FE | UART01x_RSR_PE);\n\t\t\t\tport->icount.brk++;\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tgoto ignore_char;\n\t\t\t} else if (rsr & UART01x_RSR_PE)\n\t\t\t\tport->icount.parity++;\n\t\t\telse if (rsr & UART01x_RSR_FE)\n\t\t\t\tport->icount.frame++;\n\t\t\tif (rsr & UART01x_RSR_OE)\n\t\t\t\tport->icount.overrun++;\n\n\t\t\trsr &= port->read_status_mask;\n\n\t\t\tif (rsr & UART01x_RSR_BE)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (rsr & UART01x_RSR_PE)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (rsr & UART01x_RSR_FE)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tgoto ignore_char;\n\n\t\tuart_insert_char(port, rsr, UART01x_RSR_OE, ch, flag);\n\n\tignore_char:\n\t\tstatus = readb(port->membase + UART01x_FR);\n\t}\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic void pl010_tx_chars(struct uart_port *port)\n{\n\tu8 ch;\n\n\tuart_port_tx_limited(port, ch, port->fifosize >> 1,\n\t\ttrue,\n\t\twritel(ch, port->membase + UART01x_DR),\n\t\t({}));\n}\n\nstatic void pl010_modem_status(struct uart_amba_port *uap)\n{\n\tstruct uart_port *port = &uap->port;\n\tunsigned int status, delta;\n\n\twritel(0, port->membase + UART010_ICR);\n\n\tstatus = readb(port->membase + UART01x_FR) & UART01x_FR_MODEM_ANY;\n\n\tdelta = status ^ uap->old_status;\n\tuap->old_status = status;\n\n\tif (!delta)\n\t\treturn;\n\n\tif (delta & UART01x_FR_DCD)\n\t\tuart_handle_dcd_change(port, status & UART01x_FR_DCD);\n\n\tif (delta & UART01x_FR_DSR)\n\t\tport->icount.dsr++;\n\n\tif (delta & UART01x_FR_CTS)\n\t\tuart_handle_cts_change(port, status & UART01x_FR_CTS);\n\n\twake_up_interruptible(&port->state->port.delta_msr_wait);\n}\n\nstatic irqreturn_t pl010_int(int irq, void *dev_id)\n{\n\tstruct uart_amba_port *uap = dev_id;\n\tstruct uart_port *port = &uap->port;\n\tunsigned int status, pass_counter = AMBA_ISR_PASS_LIMIT;\n\tint handled = 0;\n\n\tspin_lock(&port->lock);\n\n\tstatus = readb(port->membase + UART010_IIR);\n\tif (status) {\n\t\tdo {\n\t\t\tif (status & (UART010_IIR_RTIS | UART010_IIR_RIS))\n\t\t\t\tpl010_rx_chars(port);\n\t\t\tif (status & UART010_IIR_MIS)\n\t\t\t\tpl010_modem_status(uap);\n\t\t\tif (status & UART010_IIR_TIS)\n\t\t\t\tpl010_tx_chars(port);\n\n\t\t\tif (pass_counter-- == 0)\n\t\t\t\tbreak;\n\n\t\t\tstatus = readb(port->membase + UART010_IIR);\n\t\t} while (status & (UART010_IIR_RTIS | UART010_IIR_RIS |\n\t\t\t\t   UART010_IIR_TIS));\n\t\thandled = 1;\n\t}\n\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic unsigned int pl010_tx_empty(struct uart_port *port)\n{\n\tunsigned int status = readb(port->membase + UART01x_FR);\n\n\treturn status & UART01x_FR_BUSY ? 0 : TIOCSER_TEMT;\n}\n\nstatic unsigned int pl010_get_mctrl(struct uart_port *port)\n{\n\tunsigned int result = 0;\n\tunsigned int status;\n\n\tstatus = readb(port->membase + UART01x_FR);\n\tif (status & UART01x_FR_DCD)\n\t\tresult |= TIOCM_CAR;\n\tif (status & UART01x_FR_DSR)\n\t\tresult |= TIOCM_DSR;\n\tif (status & UART01x_FR_CTS)\n\t\tresult |= TIOCM_CTS;\n\n\treturn result;\n}\n\nstatic void pl010_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_amba_port *uap =\n\t\tcontainer_of(port, struct uart_amba_port, port);\n\n\tif (uap->data)\n\t\tuap->data->set_mctrl(uap->dev, port->membase, mctrl);\n}\n\nstatic void pl010_break_ctl(struct uart_port *port, int break_state)\n{\n\tunsigned long flags;\n\tunsigned int lcr_h;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tlcr_h = readb(port->membase + UART010_LCRH);\n\tif (break_state == -1)\n\t\tlcr_h |= UART01x_LCRH_BRK;\n\telse\n\t\tlcr_h &= ~UART01x_LCRH_BRK;\n\twritel(lcr_h, port->membase + UART010_LCRH);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int pl010_startup(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t\tcontainer_of(port, struct uart_amba_port, port);\n\tint retval;\n\n\t \n\tretval = clk_prepare_enable(uap->clk);\n\tif (retval)\n\t\tgoto out;\n\n\tport->uartclk = clk_get_rate(uap->clk);\n\n\t \n\tretval = request_irq(port->irq, pl010_int, 0, \"uart-pl010\", uap);\n\tif (retval)\n\t\tgoto clk_dis;\n\n\t \n\tuap->old_status = readb(port->membase + UART01x_FR) & UART01x_FR_MODEM_ANY;\n\n\t \n\twritel(UART01x_CR_UARTEN | UART010_CR_RIE | UART010_CR_RTIE,\n\t       port->membase + UART010_CR);\n\n\treturn 0;\n\n clk_dis:\n\tclk_disable_unprepare(uap->clk);\n out:\n\treturn retval;\n}\n\nstatic void pl010_shutdown(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t\tcontainer_of(port, struct uart_amba_port, port);\n\n\t \n\tfree_irq(port->irq, uap);\n\n\t \n\twritel(0, port->membase + UART010_CR);\n\n\t \n\twritel(readb(port->membase + UART010_LCRH) &\n\t\t~(UART01x_LCRH_BRK | UART01x_LCRH_FEN),\n\t       port->membase + UART010_LCRH);\n\n\t \n\tclk_disable_unprepare(uap->clk);\n}\n\nstatic void\npl010_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t  const struct ktermios *old)\n{\n\tunsigned int lcr_h, old_cr;\n\tunsigned long flags;\n\tunsigned int baud, quot;\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\n\tquot = uart_get_divisor(port, baud);\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tlcr_h = UART01x_LCRH_WLEN_5;\n\t\tbreak;\n\tcase CS6:\n\t\tlcr_h = UART01x_LCRH_WLEN_6;\n\t\tbreak;\n\tcase CS7:\n\t\tlcr_h = UART01x_LCRH_WLEN_7;\n\t\tbreak;\n\tdefault:  \n\t\tlcr_h = UART01x_LCRH_WLEN_8;\n\t\tbreak;\n\t}\n\tif (termios->c_cflag & CSTOPB)\n\t\tlcr_h |= UART01x_LCRH_STP2;\n\tif (termios->c_cflag & PARENB) {\n\t\tlcr_h |= UART01x_LCRH_PEN;\n\t\tif (!(termios->c_cflag & PARODD))\n\t\t\tlcr_h |= UART01x_LCRH_EPS;\n\t}\n\tif (port->fifosize > 1)\n\t\tlcr_h |= UART01x_LCRH_FEN;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tport->read_status_mask = UART01x_RSR_OE;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= UART01x_RSR_FE | UART01x_RSR_PE;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tport->read_status_mask |= UART01x_RSR_BE;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= UART01x_RSR_FE | UART01x_RSR_PE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= UART01x_RSR_BE;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= UART01x_RSR_OE;\n\t}\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= UART_DUMMY_RSR_RX;\n\n\told_cr = readb(port->membase + UART010_CR) & ~UART010_CR_MSIE;\n\n\tif (UART_ENABLE_MS(port, termios->c_cflag))\n\t\told_cr |= UART010_CR_MSIE;\n\n\t \n\tquot -= 1;\n\twritel((quot & 0xf00) >> 8, port->membase + UART010_LCRM);\n\twritel(quot & 0xff, port->membase + UART010_LCRL);\n\n\t \n\twritel(lcr_h, port->membase + UART010_LCRH);\n\twritel(old_cr, port->membase + UART010_CR);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void pl010_set_ldisc(struct uart_port *port, struct ktermios *termios)\n{\n\tif (termios->c_line == N_PPS) {\n\t\tport->flags |= UPF_HARDPPS_CD;\n\t\tspin_lock_irq(&port->lock);\n\t\tpl010_enable_ms(port);\n\t\tspin_unlock_irq(&port->lock);\n\t} else {\n\t\tport->flags &= ~UPF_HARDPPS_CD;\n\t\tif (!UART_ENABLE_MS(port, termios->c_cflag)) {\n\t\t\tspin_lock_irq(&port->lock);\n\t\t\tpl010_disable_ms(port);\n\t\t\tspin_unlock_irq(&port->lock);\n\t\t}\n\t}\n}\n\nstatic const char *pl010_type(struct uart_port *port)\n{\n\treturn port->type == PORT_AMBA ? \"AMBA\" : NULL;\n}\n\n \nstatic void pl010_release_port(struct uart_port *port)\n{\n\trelease_mem_region(port->mapbase, UART_PORT_SIZE);\n}\n\n \nstatic int pl010_request_port(struct uart_port *port)\n{\n\treturn request_mem_region(port->mapbase, UART_PORT_SIZE, \"uart-pl010\")\n\t\t\t!= NULL ? 0 : -EBUSY;\n}\n\n \nstatic void pl010_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_AMBA;\n\t\tpl010_request_port(port);\n\t}\n}\n\n \nstatic int pl010_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tint ret = 0;\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_AMBA)\n\t\tret = -EINVAL;\n\tif (ser->irq < 0 || ser->irq >= nr_irqs)\n\t\tret = -EINVAL;\n\tif (ser->baud_base < 9600)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\nstatic const struct uart_ops amba_pl010_pops = {\n\t.tx_empty\t= pl010_tx_empty,\n\t.set_mctrl\t= pl010_set_mctrl,\n\t.get_mctrl\t= pl010_get_mctrl,\n\t.stop_tx\t= pl010_stop_tx,\n\t.start_tx\t= pl010_start_tx,\n\t.stop_rx\t= pl010_stop_rx,\n\t.enable_ms\t= pl010_enable_ms,\n\t.break_ctl\t= pl010_break_ctl,\n\t.startup\t= pl010_startup,\n\t.shutdown\t= pl010_shutdown,\n\t.set_termios\t= pl010_set_termios,\n\t.set_ldisc\t= pl010_set_ldisc,\n\t.type\t\t= pl010_type,\n\t.release_port\t= pl010_release_port,\n\t.request_port\t= pl010_request_port,\n\t.config_port\t= pl010_config_port,\n\t.verify_port\t= pl010_verify_port,\n};\n\nstatic struct uart_amba_port *amba_ports[UART_NR];\n\n#ifdef CONFIG_SERIAL_AMBA_PL010_CONSOLE\n\nstatic void pl010_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tunsigned int status;\n\n\tdo {\n\t\tstatus = readb(port->membase + UART01x_FR);\n\t\tbarrier();\n\t} while (!UART_TX_READY(status));\n\twritel(ch, port->membase + UART01x_DR);\n}\n\nstatic void\npl010_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct uart_amba_port *uap = amba_ports[co->index];\n\tstruct uart_port *port = &uap->port;\n\tunsigned int status, old_cr;\n\n\tclk_enable(uap->clk);\n\n\t \n\told_cr = readb(port->membase + UART010_CR);\n\twritel(UART01x_CR_UARTEN, port->membase + UART010_CR);\n\n\tuart_console_write(port, s, count, pl010_console_putchar);\n\n\t \n\tdo {\n\t\tstatus = readb(port->membase + UART01x_FR);\n\t\tbarrier();\n\t} while (status & UART01x_FR_BUSY);\n\twritel(old_cr, port->membase + UART010_CR);\n\n\tclk_disable(uap->clk);\n}\n\nstatic void __init\npl010_console_get_options(struct uart_amba_port *uap, int *baud,\n\t\t\t     int *parity, int *bits)\n{\n\tif (readb(uap->port.membase + UART010_CR) & UART01x_CR_UARTEN) {\n\t\tunsigned int lcr_h, quot;\n\t\tlcr_h = readb(uap->port.membase + UART010_LCRH);\n\n\t\t*parity = 'n';\n\t\tif (lcr_h & UART01x_LCRH_PEN) {\n\t\t\tif (lcr_h & UART01x_LCRH_EPS)\n\t\t\t\t*parity = 'e';\n\t\t\telse\n\t\t\t\t*parity = 'o';\n\t\t}\n\n\t\tif ((lcr_h & 0x60) == UART01x_LCRH_WLEN_7)\n\t\t\t*bits = 7;\n\t\telse\n\t\t\t*bits = 8;\n\n\t\tquot = readb(uap->port.membase + UART010_LCRL) |\n\t\t       readb(uap->port.membase + UART010_LCRM) << 8;\n\t\t*baud = uap->port.uartclk / (16 * (quot + 1));\n\t}\n}\n\nstatic int __init pl010_console_setup(struct console *co, char *options)\n{\n\tstruct uart_amba_port *uap;\n\tint baud = 38400;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret;\n\n\t \n\tif (co->index >= UART_NR)\n\t\tco->index = 0;\n\tuap = amba_ports[co->index];\n\tif (!uap)\n\t\treturn -ENODEV;\n\n\tret = clk_prepare(uap->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tuap->port.uartclk = clk_get_rate(uap->clk);\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse\n\t\tpl010_console_get_options(uap, &baud, &parity, &bits);\n\n\treturn uart_set_options(&uap->port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver amba_reg;\nstatic struct console amba_console = {\n\t.name\t\t= \"ttyAM\",\n\t.write\t\t= pl010_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= pl010_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &amba_reg,\n};\n\n#define AMBA_CONSOLE\t&amba_console\n#else\n#define AMBA_CONSOLE\tNULL\n#endif\n\nstatic DEFINE_MUTEX(amba_reg_lock);\nstatic struct uart_driver amba_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"ttyAM\",\n\t.dev_name\t\t= \"ttyAM\",\n\t.major\t\t\t= SERIAL_AMBA_MAJOR,\n\t.minor\t\t\t= SERIAL_AMBA_MINOR,\n\t.nr\t\t\t= UART_NR,\n\t.cons\t\t\t= AMBA_CONSOLE,\n};\n\nstatic int pl010_probe(struct amba_device *dev, const struct amba_id *id)\n{\n\tstruct uart_amba_port *uap;\n\tvoid __iomem *base;\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(amba_ports); i++)\n\t\tif (amba_ports[i] == NULL)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(amba_ports))\n\t\treturn -EBUSY;\n\n\tuap = devm_kzalloc(&dev->dev, sizeof(struct uart_amba_port),\n\t\t\t   GFP_KERNEL);\n\tif (!uap)\n\t\treturn -ENOMEM;\n\n\tbase = devm_ioremap(&dev->dev, dev->res.start,\n\t\t\t    resource_size(&dev->res));\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tuap->clk = devm_clk_get(&dev->dev, NULL);\n\tif (IS_ERR(uap->clk))\n\t\treturn PTR_ERR(uap->clk);\n\n\tuap->port.dev = &dev->dev;\n\tuap->port.mapbase = dev->res.start;\n\tuap->port.membase = base;\n\tuap->port.iotype = UPIO_MEM;\n\tuap->port.irq = dev->irq[0];\n\tuap->port.fifosize = 16;\n\tuap->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_AMBA_PL010_CONSOLE);\n\tuap->port.ops = &amba_pl010_pops;\n\tuap->port.flags = UPF_BOOT_AUTOCONF;\n\tuap->port.line = i;\n\tuap->dev = dev;\n\tuap->data = dev_get_platdata(&dev->dev);\n\n\tamba_ports[i] = uap;\n\n\tamba_set_drvdata(dev, uap);\n\n\tmutex_lock(&amba_reg_lock);\n\tif (!amba_reg.state) {\n\t\tret = uart_register_driver(&amba_reg);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&amba_reg_lock);\n\t\t\tdev_err(uap->port.dev,\n\t\t\t\t\"Failed to register AMBA-PL010 driver\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmutex_unlock(&amba_reg_lock);\n\n\tret = uart_add_one_port(&amba_reg, &uap->port);\n\tif (ret)\n\t\tamba_ports[i] = NULL;\n\n\treturn ret;\n}\n\nstatic void pl010_remove(struct amba_device *dev)\n{\n\tstruct uart_amba_port *uap = amba_get_drvdata(dev);\n\tint i;\n\tbool busy = false;\n\n\tuart_remove_one_port(&amba_reg, &uap->port);\n\n\tfor (i = 0; i < ARRAY_SIZE(amba_ports); i++)\n\t\tif (amba_ports[i] == uap)\n\t\t\tamba_ports[i] = NULL;\n\t\telse if (amba_ports[i])\n\t\t\tbusy = true;\n\n\tif (!busy)\n\t\tuart_unregister_driver(&amba_reg);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pl010_suspend(struct device *dev)\n{\n\tstruct uart_amba_port *uap = dev_get_drvdata(dev);\n\n\tif (uap)\n\t\tuart_suspend_port(&amba_reg, &uap->port);\n\n\treturn 0;\n}\n\nstatic int pl010_resume(struct device *dev)\n{\n\tstruct uart_amba_port *uap = dev_get_drvdata(dev);\n\n\tif (uap)\n\t\tuart_resume_port(&amba_reg, &uap->port);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(pl010_dev_pm_ops, pl010_suspend, pl010_resume);\n\nstatic const struct amba_id pl010_ids[] = {\n\t{\n\t\t.id\t= 0x00041010,\n\t\t.mask\t= 0x000fffff,\n\t},\n\t{ 0, 0 },\n};\n\nMODULE_DEVICE_TABLE(amba, pl010_ids);\n\nstatic struct amba_driver pl010_driver = {\n\t.drv = {\n\t\t.name\t= \"uart-pl010\",\n\t\t.pm\t= &pl010_dev_pm_ops,\n\t},\n\t.id_table\t= pl010_ids,\n\t.probe\t\t= pl010_probe,\n\t.remove\t\t= pl010_remove,\n};\n\nstatic int __init pl010_init(void)\n{\n\tprintk(KERN_INFO \"Serial: AMBA driver\\n\");\n\n\treturn  amba_driver_register(&pl010_driver);\n}\n\nstatic void __exit pl010_exit(void)\n{\n\tamba_driver_unregister(&pl010_driver);\n}\n\nmodule_init(pl010_init);\nmodule_exit(pl010_exit);\n\nMODULE_AUTHOR(\"ARM Ltd/Deep Blue Solutions Ltd\");\nMODULE_DESCRIPTION(\"ARM AMBA serial port driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}