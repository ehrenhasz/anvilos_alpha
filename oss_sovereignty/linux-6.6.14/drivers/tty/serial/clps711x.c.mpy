{
  "module_name": "clps711x.c",
  "hash_id": "8f7bfc302f966030802caf333363afbce4bfd6a3fcceda6862e4a762c7368db2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/clps711x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/ioport.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/clps711x.h>\n\n#include \"serial_mctrl_gpio.h\"\n\n#define UART_CLPS711X_DEVNAME\t\"ttyCL\"\n#define UART_CLPS711X_NR\t2\n#define UART_CLPS711X_MAJOR\t204\n#define UART_CLPS711X_MINOR\t40\n\n#define UARTDR_OFFSET\t\t(0x00)\n#define UBRLCR_OFFSET\t\t(0x40)\n\n#define UARTDR_FRMERR\t\t(1 << 8)\n#define UARTDR_PARERR\t\t(1 << 9)\n#define UARTDR_OVERR\t\t(1 << 10)\n\n#define UBRLCR_BAUD_MASK\t((1 << 12) - 1)\n#define UBRLCR_BREAK\t\t(1 << 12)\n#define UBRLCR_PRTEN\t\t(1 << 13)\n#define UBRLCR_EVENPRT\t\t(1 << 14)\n#define UBRLCR_XSTOP\t\t(1 << 15)\n#define UBRLCR_FIFOEN\t\t(1 << 16)\n#define UBRLCR_WRDLEN5\t\t(0 << 17)\n#define UBRLCR_WRDLEN6\t\t(1 << 17)\n#define UBRLCR_WRDLEN7\t\t(2 << 17)\n#define UBRLCR_WRDLEN8\t\t(3 << 17)\n#define UBRLCR_WRDLEN_MASK\t(3 << 17)\n\nstruct clps711x_port {\n\tstruct uart_port\tport;\n\tunsigned int\t\ttx_enabled;\n\tint\t\t\trx_irq;\n\tstruct regmap\t\t*syscon;\n\tstruct mctrl_gpios\t*gpios;\n};\n\nstatic struct uart_driver clps711x_uart = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= UART_CLPS711X_DEVNAME,\n\t.dev_name\t= UART_CLPS711X_DEVNAME,\n\t.major\t\t= UART_CLPS711X_MAJOR,\n\t.minor\t\t= UART_CLPS711X_MINOR,\n\t.nr\t\t= UART_CLPS711X_NR,\n};\n\nstatic void uart_clps711x_stop_tx(struct uart_port *port)\n{\n\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\n\tif (s->tx_enabled) {\n\t\tdisable_irq(port->irq);\n\t\ts->tx_enabled = 0;\n\t}\n}\n\nstatic void uart_clps711x_start_tx(struct uart_port *port)\n{\n\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\n\tif (!s->tx_enabled) {\n\t\ts->tx_enabled = 1;\n\t\tenable_irq(port->irq);\n\t}\n}\n\nstatic irqreturn_t uart_clps711x_int_rx(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\tunsigned int status;\n\tu16 ch;\n\tu8 flg;\n\n\tfor (;;) {\n\t\tu32 sysflg = 0;\n\n\t\tregmap_read(s->syscon, SYSFLG_OFFSET, &sysflg);\n\t\tif (sysflg & SYSFLG_URXFE)\n\t\t\tbreak;\n\n\t\tch = readw(port->membase + UARTDR_OFFSET);\n\t\tstatus = ch & (UARTDR_FRMERR | UARTDR_PARERR | UARTDR_OVERR);\n\t\tch &= 0xff;\n\n\t\tport->icount.rx++;\n\t\tflg = TTY_NORMAL;\n\n\t\tif (unlikely(status)) {\n\t\t\tif (status & UARTDR_PARERR)\n\t\t\t\tport->icount.parity++;\n\t\t\telse if (status & UARTDR_FRMERR)\n\t\t\t\tport->icount.frame++;\n\t\t\telse if (status & UARTDR_OVERR)\n\t\t\t\tport->icount.overrun++;\n\n\t\t\tstatus &= port->read_status_mask;\n\n\t\t\tif (status & UARTDR_PARERR)\n\t\t\t\tflg = TTY_PARITY;\n\t\t\telse if (status & UARTDR_FRMERR)\n\t\t\t\tflg = TTY_FRAME;\n\t\t\telse if (status & UARTDR_OVERR)\n\t\t\t\tflg = TTY_OVERRUN;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tcontinue;\n\n\t\tif (status & port->ignore_status_mask)\n\t\t\tcontinue;\n\n\t\tuart_insert_char(port, status, UARTDR_OVERR, ch, flg);\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t uart_clps711x_int_tx(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\tif (port->x_char) {\n\t\twritew(port->x_char, port->membase + UARTDR_OFFSET);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\tif (s->tx_enabled) {\n\t\t\tdisable_irq_nosync(port->irq);\n\t\t\ts->tx_enabled = 0;\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\twhile (!uart_circ_empty(xmit)) {\n\t\tu32 sysflg = 0;\n\n\t\twritew(xmit->buf[xmit->tail], port->membase + UARTDR_OFFSET);\n\t\tuart_xmit_advance(port, 1);\n\n\t\tregmap_read(s->syscon, SYSFLG_OFFSET, &sysflg);\n\t\tif (sysflg & SYSFLG_UTXFF)\n\t\t\tbreak;\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int uart_clps711x_tx_empty(struct uart_port *port)\n{\n\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\tu32 sysflg = 0;\n\n\tregmap_read(s->syscon, SYSFLG_OFFSET, &sysflg);\n\n\treturn (sysflg & SYSFLG_UBUSY) ? 0 : TIOCSER_TEMT;\n}\n\nstatic unsigned int uart_clps711x_get_mctrl(struct uart_port *port)\n{\n\tunsigned int result = TIOCM_DSR | TIOCM_CTS | TIOCM_CAR;\n\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\n\treturn mctrl_gpio_get(s->gpios, &result);\n}\n\nstatic void uart_clps711x_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\n\tmctrl_gpio_set(s->gpios, mctrl);\n}\n\nstatic void uart_clps711x_break_ctl(struct uart_port *port, int break_state)\n{\n\tunsigned int ubrlcr;\n\n\tubrlcr = readl(port->membase + UBRLCR_OFFSET);\n\tif (break_state)\n\t\tubrlcr |= UBRLCR_BREAK;\n\telse\n\t\tubrlcr &= ~UBRLCR_BREAK;\n\twritel(ubrlcr, port->membase + UBRLCR_OFFSET);\n}\n\nstatic void uart_clps711x_set_ldisc(struct uart_port *port,\n\t\t\t\t    struct ktermios *termios)\n{\n\tif (!port->line) {\n\t\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\n\t\tregmap_update_bits(s->syscon, SYSCON_OFFSET, SYSCON1_SIREN,\n\t\t\t\t   (termios->c_line == N_IRDA) ? SYSCON1_SIREN : 0);\n\t}\n}\n\nstatic int uart_clps711x_startup(struct uart_port *port)\n{\n\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\n\t \n\twritel(readl(port->membase + UBRLCR_OFFSET) & ~UBRLCR_BREAK,\n\t       port->membase + UBRLCR_OFFSET);\n\n\t \n\treturn regmap_update_bits(s->syscon, SYSCON_OFFSET,\n\t\t\t\t  SYSCON_UARTEN, SYSCON_UARTEN);\n}\n\nstatic void uart_clps711x_shutdown(struct uart_port *port)\n{\n\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\n\t \n\tregmap_update_bits(s->syscon, SYSCON_OFFSET, SYSCON_UARTEN, 0);\n}\n\nstatic void uart_clps711x_set_termios(struct uart_port *port,\n\t\t\t\t      struct ktermios *termios,\n\t\t\t\t      const struct ktermios *old)\n{\n\tu32 ubrlcr;\n\tunsigned int baud, quot;\n\n\t \n\ttermios->c_cflag &= ~CMSPAR;\n\ttermios->c_iflag &= ~(BRKINT | IGNBRK);\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, port->uartclk / 4096,\n\t\t\t\t\t\t      port->uartclk / 16);\n\tquot = uart_get_divisor(port, baud);\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tubrlcr = UBRLCR_WRDLEN5;\n\t\tbreak;\n\tcase CS6:\n\t\tubrlcr = UBRLCR_WRDLEN6;\n\t\tbreak;\n\tcase CS7:\n\t\tubrlcr = UBRLCR_WRDLEN7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tubrlcr = UBRLCR_WRDLEN8;\n\t\tbreak;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tubrlcr |= UBRLCR_XSTOP;\n\n\tif (termios->c_cflag & PARENB) {\n\t\tubrlcr |= UBRLCR_PRTEN;\n\t\tif (!(termios->c_cflag & PARODD))\n\t\t\tubrlcr |= UBRLCR_EVENPRT;\n\t}\n\n\t \n\tubrlcr |= UBRLCR_FIFOEN;\n\n\t \n\tport->read_status_mask = UARTDR_OVERR;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= UARTDR_PARERR | UARTDR_FRMERR;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (!(termios->c_cflag & CREAD))\n\t\tport->ignore_status_mask |= UARTDR_OVERR | UARTDR_PARERR |\n\t\t\t\t\t    UARTDR_FRMERR;\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\twritel(ubrlcr | (quot - 1), port->membase + UBRLCR_OFFSET);\n}\n\nstatic const char *uart_clps711x_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_CLPS711X) ? \"CLPS711X\" : NULL;\n}\n\nstatic void uart_clps711x_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_CLPS711X;\n}\n\nstatic void uart_clps711x_nop_void(struct uart_port *port)\n{\n}\n\nstatic int uart_clps711x_nop_int(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic const struct uart_ops uart_clps711x_ops = {\n\t.tx_empty\t= uart_clps711x_tx_empty,\n\t.set_mctrl\t= uart_clps711x_set_mctrl,\n\t.get_mctrl\t= uart_clps711x_get_mctrl,\n\t.stop_tx\t= uart_clps711x_stop_tx,\n\t.start_tx\t= uart_clps711x_start_tx,\n\t.stop_rx\t= uart_clps711x_nop_void,\n\t.break_ctl\t= uart_clps711x_break_ctl,\n\t.set_ldisc\t= uart_clps711x_set_ldisc,\n\t.startup\t= uart_clps711x_startup,\n\t.shutdown\t= uart_clps711x_shutdown,\n\t.set_termios\t= uart_clps711x_set_termios,\n\t.type\t\t= uart_clps711x_type,\n\t.config_port\t= uart_clps711x_config_port,\n\t.release_port\t= uart_clps711x_nop_void,\n\t.request_port\t= uart_clps711x_nop_int,\n};\n\n#ifdef CONFIG_SERIAL_CLPS711X_CONSOLE\nstatic void uart_clps711x_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\tu32 sysflg = 0;\n\n\t \n\tdo {\n\t\tregmap_read(s->syscon, SYSFLG_OFFSET, &sysflg);\n\t} while (sysflg & SYSFLG_UTXFF);\n\n\twritew(ch, port->membase + UARTDR_OFFSET);\n}\n\nstatic void uart_clps711x_console_write(struct console *co, const char *c,\n\t\t\t\t\tunsigned n)\n{\n\tstruct uart_port *port = clps711x_uart.state[co->index].uart_port;\n\tstruct clps711x_port *s = dev_get_drvdata(port->dev);\n\tu32 sysflg = 0;\n\n\tuart_console_write(port, c, n, uart_clps711x_console_putchar);\n\n\t \n\tdo {\n\t\tregmap_read(s->syscon, SYSFLG_OFFSET, &sysflg);\n\t} while (sysflg & SYSFLG_UBUSY);\n}\n\nstatic int uart_clps711x_console_setup(struct console *co, char *options)\n{\n\tint baud = 38400, bits = 8, parity = 'n', flow = 'n';\n\tint ret, index = co->index;\n\tstruct clps711x_port *s;\n\tstruct uart_port *port;\n\tunsigned int quot;\n\tu32 ubrlcr;\n\n\tif (index < 0 || index >= UART_CLPS711X_NR)\n\t\treturn -EINVAL;\n\n\tport = clps711x_uart.state[index].uart_port;\n\tif (!port)\n\t\treturn -ENODEV;\n\n\ts = dev_get_drvdata(port->dev);\n\n\tif (!options) {\n\t\tu32 syscon = 0;\n\n\t\tregmap_read(s->syscon, SYSCON_OFFSET, &syscon);\n\t\tif (syscon & SYSCON_UARTEN) {\n\t\t\tubrlcr = readl(port->membase + UBRLCR_OFFSET);\n\n\t\t\tif (ubrlcr & UBRLCR_PRTEN) {\n\t\t\t\tif (ubrlcr & UBRLCR_EVENPRT)\n\t\t\t\t\tparity = 'e';\n\t\t\t\telse\n\t\t\t\t\tparity = 'o';\n\t\t\t}\n\n\t\t\tif ((ubrlcr & UBRLCR_WRDLEN_MASK) == UBRLCR_WRDLEN7)\n\t\t\t\tbits = 7;\n\n\t\t\tquot = ubrlcr & UBRLCR_BAUD_MASK;\n\t\t\tbaud = port->uartclk / (16 * (quot + 1));\n\t\t}\n\t} else\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\tret = uart_set_options(port, co, baud, parity, bits, flow);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(s->syscon, SYSCON_OFFSET,\n\t\t\t\t  SYSCON_UARTEN, SYSCON_UARTEN);\n}\n\nstatic struct console clps711x_console = {\n\t.name\t= UART_CLPS711X_DEVNAME,\n\t.device\t= uart_console_device,\n\t.write\t= uart_clps711x_console_write,\n\t.setup\t= uart_clps711x_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,\n};\n#endif\n\nstatic int uart_clps711x_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct clps711x_port *s;\n\tstruct resource *res;\n\tstruct clk *uart_clk;\n\tint irq, ret;\n\n\ts = devm_kzalloc(&pdev->dev, sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tuart_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(uart_clk))\n\t\treturn PTR_ERR(uart_clk);\n\n\ts->port.membase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(s->port.membase))\n\t\treturn PTR_ERR(s->port.membase);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\ts->port.irq = irq;\n\n\ts->rx_irq = platform_get_irq(pdev, 1);\n\tif (s->rx_irq < 0)\n\t\treturn s->rx_irq;\n\n\ts->syscon = syscon_regmap_lookup_by_phandle(np, \"syscon\");\n\tif (IS_ERR(s->syscon))\n\t\treturn PTR_ERR(s->syscon);\n\n\ts->port.line\t\t= of_alias_get_id(np, \"serial\");\n\ts->port.dev\t\t= &pdev->dev;\n\ts->port.iotype\t\t= UPIO_MEM32;\n\ts->port.mapbase\t\t= res->start;\n\ts->port.type\t\t= PORT_CLPS711X;\n\ts->port.fifosize\t= 16;\n\ts->port.has_sysrq\t= IS_ENABLED(CONFIG_SERIAL_CLPS711X_CONSOLE);\n\ts->port.flags\t\t= UPF_SKIP_TEST | UPF_FIXED_TYPE;\n\ts->port.uartclk\t\t= clk_get_rate(uart_clk);\n\ts->port.ops\t\t= &uart_clps711x_ops;\n\n\tplatform_set_drvdata(pdev, s);\n\n\ts->gpios = mctrl_gpio_init_noauto(&pdev->dev, 0);\n\tif (IS_ERR(s->gpios))\n\t    return PTR_ERR(s->gpios);\n\n\tret = uart_add_one_port(&clps711x_uart, &s->port);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!uart_console(&s->port))\n\t\tregmap_update_bits(s->syscon, SYSCON_OFFSET, SYSCON_UARTEN, 0);\n\n\ts->tx_enabled = 1;\n\n\tret = devm_request_irq(&pdev->dev, s->port.irq, uart_clps711x_int_tx, 0,\n\t\t\t       dev_name(&pdev->dev), &s->port);\n\tif (ret) {\n\t\tuart_remove_one_port(&clps711x_uart, &s->port);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, s->rx_irq, uart_clps711x_int_rx, 0,\n\t\t\t       dev_name(&pdev->dev), &s->port);\n\tif (ret)\n\t\tuart_remove_one_port(&clps711x_uart, &s->port);\n\n\treturn ret;\n}\n\nstatic int uart_clps711x_remove(struct platform_device *pdev)\n{\n\tstruct clps711x_port *s = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&clps711x_uart, &s->port);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused clps711x_uart_dt_ids[] = {\n\t{ .compatible = \"cirrus,ep7209-uart\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, clps711x_uart_dt_ids);\n\nstatic struct platform_driver clps711x_uart_platform = {\n\t.driver = {\n\t\t.name\t\t= \"clps711x-uart\",\n\t\t.of_match_table\t= of_match_ptr(clps711x_uart_dt_ids),\n\t},\n\t.probe\t= uart_clps711x_probe,\n\t.remove\t= uart_clps711x_remove,\n};\n\nstatic int __init uart_clps711x_init(void)\n{\n\tint ret;\n\n#ifdef CONFIG_SERIAL_CLPS711X_CONSOLE\n\tclps711x_uart.cons = &clps711x_console;\n\tclps711x_console.data = &clps711x_uart;\n#endif\n\n\tret = uart_register_driver(&clps711x_uart);\n\tif (ret)\n\t\treturn ret;\n\n\treturn platform_driver_register(&clps711x_uart_platform);\n}\nmodule_init(uart_clps711x_init);\n\nstatic void __exit uart_clps711x_exit(void)\n{\n\tplatform_driver_unregister(&clps711x_uart_platform);\n\tuart_unregister_driver(&clps711x_uart);\n}\nmodule_exit(uart_clps711x_exit);\n\nMODULE_AUTHOR(\"Deep Blue Solutions Ltd\");\nMODULE_DESCRIPTION(\"CLPS711X serial driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}