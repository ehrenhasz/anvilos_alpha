{
  "module_name": "arc_uart.c",
  "hash_id": "226ab1ef99ae69bad6ef35f6408c9e54cd8cc1f01a91fd1c79c0db54b7b9dab6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/arc_uart.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/serial.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/platform_device.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/io.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n\n \n#define ARC_UART_TX_FIFO_SIZE  1\n\n \n#define R_ID0\t0\n#define R_ID1\t4\n#define R_ID2\t8\n#define R_ID3\t12\n#define R_DATA\t16\n#define R_STS\t20\n#define R_BAUDL\t24\n#define R_BAUDH\t28\n\n \n#define RXIENB  0x04\t \n#define TXIENB  0x40\t \n\n#define RXEMPTY 0x20\t \n#define TXEMPTY 0x80\t \n\n#define RXFULL  0x08\t \n#define RXFULL1 0x10\t \n\n#define RXFERR  0x01\t \n#define RXOERR  0x02\t \n\n \n#define RBASE(port, reg)      (port->membase + reg)\n#define UART_REG_SET(u, r, v) writeb((v), RBASE(u, r))\n#define UART_REG_GET(u, r)    readb(RBASE(u, r))\n\n#define UART_REG_OR(u, r, v)  UART_REG_SET(u, r, UART_REG_GET(u, r) | (v))\n#define UART_REG_CLR(u, r, v) UART_REG_SET(u, r, UART_REG_GET(u, r) & ~(v))\n\n \n#define UART_SET_DATA(uart, val)   UART_REG_SET(uart, R_DATA, val)\n#define UART_GET_DATA(uart)        UART_REG_GET(uart, R_DATA)\n\n#define UART_SET_BAUDH(uart, val)  UART_REG_SET(uart, R_BAUDH, val)\n#define UART_SET_BAUDL(uart, val)  UART_REG_SET(uart, R_BAUDL, val)\n\n#define UART_CLR_STATUS(uart, val) UART_REG_CLR(uart, R_STS, val)\n#define UART_GET_STATUS(uart)      UART_REG_GET(uart, R_STS)\n\n#define UART_ALL_IRQ_DISABLE(uart) UART_REG_CLR(uart, R_STS, RXIENB|TXIENB)\n#define UART_RX_IRQ_DISABLE(uart)  UART_REG_CLR(uart, R_STS, RXIENB)\n#define UART_TX_IRQ_DISABLE(uart)  UART_REG_CLR(uart, R_STS, TXIENB)\n\n#define UART_ALL_IRQ_ENABLE(uart)  UART_REG_OR(uart, R_STS, RXIENB|TXIENB)\n#define UART_RX_IRQ_ENABLE(uart)   UART_REG_OR(uart, R_STS, RXIENB)\n#define UART_TX_IRQ_ENABLE(uart)   UART_REG_OR(uart, R_STS, TXIENB)\n\n#define ARC_SERIAL_DEV_NAME\t\"ttyARC\"\n\nstruct arc_uart_port {\n\tstruct uart_port port;\n\tunsigned long baud;\n};\n\n#define to_arc_port(uport)  container_of(uport, struct arc_uart_port, port)\n\nstatic struct arc_uart_port arc_uart_ports[CONFIG_SERIAL_ARC_NR_PORTS];\n\n#ifdef CONFIG_SERIAL_ARC_CONSOLE\nstatic struct console arc_console;\n#endif\n\n#define DRIVER_NAME\t\"arc-uart\"\n\nstatic struct uart_driver arc_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= DRIVER_NAME,\n\t.dev_name\t= ARC_SERIAL_DEV_NAME,\n\t.major\t\t= 0,\n\t.minor\t\t= 0,\n\t.nr\t\t= CONFIG_SERIAL_ARC_NR_PORTS,\n#ifdef CONFIG_SERIAL_ARC_CONSOLE\n\t.cons\t\t= &arc_console,\n#endif\n};\n\nstatic void arc_serial_stop_rx(struct uart_port *port)\n{\n\tUART_RX_IRQ_DISABLE(port);\n}\n\nstatic void arc_serial_stop_tx(struct uart_port *port)\n{\n\twhile (!(UART_GET_STATUS(port) & TXEMPTY))\n\t\tcpu_relax();\n\n\tUART_TX_IRQ_DISABLE(port);\n}\n\n \nstatic unsigned int arc_serial_tx_empty(struct uart_port *port)\n{\n\tunsigned int stat;\n\n\tstat = UART_GET_STATUS(port);\n\tif (stat & TXEMPTY)\n\t\treturn TIOCSER_TEMT;\n\n\treturn 0;\n}\n\n \nstatic void arc_serial_tx_chars(struct uart_port *port)\n{\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tint sent = 0;\n\tunsigned char ch;\n\n\tif (unlikely(port->x_char)) {\n\t\tUART_SET_DATA(port, port->x_char);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\tsent = 1;\n\t} else if (!uart_circ_empty(xmit)) {\n\t\tch = xmit->buf[xmit->tail];\n\t\tuart_xmit_advance(port, 1);\n\t\twhile (!(UART_GET_STATUS(port) & TXEMPTY))\n\t\t\tcpu_relax();\n\t\tUART_SET_DATA(port, ch);\n\t\tsent = 1;\n\t}\n\n\t \n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (sent)\n\t\tUART_TX_IRQ_ENABLE(port);\n}\n\n \nstatic void arc_serial_start_tx(struct uart_port *port)\n{\n\tarc_serial_tx_chars(port);\n}\n\nstatic void arc_serial_rx_chars(struct uart_port *port, unsigned int status)\n{\n\t \n\tdo {\n\t\tu8 ch, flg = TTY_NORMAL;\n\n\t\t \n\t\tif (status & RXOERR) {\n\t\t\tport->icount.overrun++;\n\t\t\tflg = TTY_OVERRUN;\n\t\t\tUART_CLR_STATUS(port, RXOERR);\n\t\t}\n\n\t\tif (status & RXFERR) {\n\t\t\tport->icount.frame++;\n\t\t\tflg = TTY_FRAME;\n\t\t\tUART_CLR_STATUS(port, RXFERR);\n\t\t}\n\n\t\tif (status & RXEMPTY)\n\t\t\tcontinue;\n\n\t\tch = UART_GET_DATA(port);\n\t\tport->icount.rx++;\n\n\t\tif (!(uart_handle_sysrq_char(port, ch)))\n\t\t\tuart_insert_char(port, status, RXOERR, ch, flg);\n\n\t\ttty_flip_buffer_push(&port->state->port);\n\t} while (!((status = UART_GET_STATUS(port)) & RXEMPTY));\n}\n\n \n\nstatic irqreturn_t arc_serial_isr(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tunsigned int status;\n\n\tstatus = UART_GET_STATUS(port);\n\n\t \n\tif (status & RXIENB) {\n\n\t\t \n\t\tspin_lock(&port->lock);\n\t\tarc_serial_rx_chars(port, status);\n\t\tspin_unlock(&port->lock);\n\t}\n\n\tif ((status & TXIENB) && (status & TXEMPTY)) {\n\n\t\t \n\t\tUART_TX_IRQ_DISABLE(port);\n\n\t\tspin_lock(&port->lock);\n\n\t\tif (!uart_tx_stopped(port))\n\t\t\tarc_serial_tx_chars(port);\n\n\t\tspin_unlock(&port->lock);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int arc_serial_get_mctrl(struct uart_port *port)\n{\n\t \n\treturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\n}\n\nstatic void arc_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\t \n}\n\nstatic void arc_serial_break_ctl(struct uart_port *port, int break_state)\n{\n\t \n}\n\nstatic int arc_serial_startup(struct uart_port *port)\n{\n\t \n\tUART_ALL_IRQ_DISABLE(port);\n\n\tif (request_irq(port->irq, arc_serial_isr, 0, \"arc uart rx-tx\", port)) {\n\t\tdev_warn(port->dev, \"Unable to attach ARC UART intr\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tUART_RX_IRQ_ENABLE(port);  \n\n\treturn 0;\n}\n\n \nstatic void arc_serial_shutdown(struct uart_port *port)\n{\n\tfree_irq(port->irq, port);\n}\n\nstatic void\narc_serial_set_termios(struct uart_port *port, struct ktermios *new,\n\t\t       const struct ktermios *old)\n{\n\tstruct arc_uart_port *uart = to_arc_port(port);\n\tunsigned int baud, uartl, uarth, hw_val;\n\tunsigned long flags;\n\n\t \n\tbaud = uart_get_baud_rate(port, new, old, 0, 460800);\n\n\thw_val = port->uartclk / (uart->baud * 4) - 1;\n\tuartl = hw_val & 0xFF;\n\tuarth = (hw_val >> 8) & 0xFF;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tUART_ALL_IRQ_DISABLE(port);\n\n\tUART_SET_BAUDL(port, uartl);\n\tUART_SET_BAUDH(port, uarth);\n\n\tUART_RX_IRQ_ENABLE(port);\n\n\t \n\tnew->c_cflag &= ~(CMSPAR|CRTSCTS|CSIZE);\n\tnew->c_cflag |= CS8;\n\n\tif (old)\n\t\ttty_termios_copy_hw(new, old);\n\n\t \n\tif (tty_termios_baud_rate(new))\n\t\ttty_termios_encode_baud_rate(new, baud, baud);\n\n\tuart_update_timeout(port, new->c_cflag, baud);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *arc_serial_type(struct uart_port *port)\n{\n\treturn port->type == PORT_ARC ? DRIVER_NAME : NULL;\n}\n\nstatic void arc_serial_release_port(struct uart_port *port)\n{\n}\n\nstatic int arc_serial_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\n \nstatic int\narc_serial_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tif (port->type != PORT_UNKNOWN && ser->type != PORT_ARC)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic void arc_serial_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_ARC;\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n\nstatic void arc_serial_poll_putchar(struct uart_port *port, unsigned char chr)\n{\n\twhile (!(UART_GET_STATUS(port) & TXEMPTY))\n\t\tcpu_relax();\n\n\tUART_SET_DATA(port, chr);\n}\n\nstatic int arc_serial_poll_getchar(struct uart_port *port)\n{\n\tunsigned char chr;\n\n\twhile (!(UART_GET_STATUS(port) & RXEMPTY))\n\t\tcpu_relax();\n\n\tchr = UART_GET_DATA(port);\n\treturn chr;\n}\n#endif\n\nstatic const struct uart_ops arc_serial_pops = {\n\t.tx_empty\t= arc_serial_tx_empty,\n\t.set_mctrl\t= arc_serial_set_mctrl,\n\t.get_mctrl\t= arc_serial_get_mctrl,\n\t.stop_tx\t= arc_serial_stop_tx,\n\t.start_tx\t= arc_serial_start_tx,\n\t.stop_rx\t= arc_serial_stop_rx,\n\t.break_ctl\t= arc_serial_break_ctl,\n\t.startup\t= arc_serial_startup,\n\t.shutdown\t= arc_serial_shutdown,\n\t.set_termios\t= arc_serial_set_termios,\n\t.type\t\t= arc_serial_type,\n\t.release_port\t= arc_serial_release_port,\n\t.request_port\t= arc_serial_request_port,\n\t.config_port\t= arc_serial_config_port,\n\t.verify_port\t= arc_serial_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_put_char = arc_serial_poll_putchar,\n\t.poll_get_char = arc_serial_poll_getchar,\n#endif\n};\n\n#ifdef CONFIG_SERIAL_ARC_CONSOLE\n\nstatic int arc_serial_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index < 0 || co->index >= CONFIG_SERIAL_ARC_NR_PORTS)\n\t\treturn -ENODEV;\n\n\t \n\tport = &arc_uart_ports[co->index].port;\n\tif (!port->membase)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\t \n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic void arc_serial_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\twhile (!(UART_GET_STATUS(port) & TXEMPTY))\n\t\tcpu_relax();\n\n\tUART_SET_DATA(port, (unsigned char)ch);\n}\n\n \nstatic void arc_serial_console_write(struct console *co, const char *s,\n\t\t\t\t     unsigned int count)\n{\n\tstruct uart_port *port = &arc_uart_ports[co->index].port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tuart_console_write(port, s, count, arc_serial_console_putchar);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic struct console arc_console = {\n\t.name\t= ARC_SERIAL_DEV_NAME,\n\t.write\t= arc_serial_console_write,\n\t.device\t= uart_console_device,\n\t.setup\t= arc_serial_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,\n\t.data\t= &arc_uart_driver\n};\n\nstatic void arc_early_serial_write(struct console *con, const char *s,\n\t\t\t\t   unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, arc_serial_console_putchar);\n}\n\nstatic int __init arc_early_console_setup(struct earlycon_device *dev,\n\t\t\t\t\t  const char *opt)\n{\n\tstruct uart_port *port = &dev->port;\n\tunsigned int l, h, hw_val;\n\n\tif (!dev->port.membase)\n\t\treturn -ENODEV;\n\n\thw_val = port->uartclk / (dev->baud * 4) - 1;\n\tl = hw_val & 0xFF;\n\th = (hw_val >> 8) & 0xFF;\n\n\tUART_SET_BAUDL(port, l);\n\tUART_SET_BAUDH(port, h);\n\n\tdev->con->write = arc_early_serial_write;\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(arc_uart, \"snps,arc-uart\", arc_early_console_setup);\n\n#endif\t \n\nstatic int arc_serial_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct arc_uart_port *uart;\n\tstruct uart_port *port;\n\tint dev_id;\n\tu32 val;\n\n\t \n\tif (!np)\n\t\treturn -ENODEV;\n\n\tdev_id = of_alias_get_id(np, \"serial\");\n\tif (dev_id < 0)\n\t\tdev_id = 0;\n\n\tif (dev_id >= ARRAY_SIZE(arc_uart_ports)) {\n\t\tdev_err(&pdev->dev, \"serial%d out of range\\n\", dev_id);\n\t\treturn -EINVAL;\n\t}\n\n\tuart = &arc_uart_ports[dev_id];\n\tport = &uart->port;\n\n\tif (of_property_read_u32(np, \"clock-frequency\", &val)) {\n\t\tdev_err(&pdev->dev, \"clock-frequency property NOTset\\n\");\n\t\treturn -EINVAL;\n\t}\n\tport->uartclk = val;\n\n\tif (of_property_read_u32(np, \"current-speed\", &val)) {\n\t\tdev_err(&pdev->dev, \"current-speed property NOT set\\n\");\n\t\treturn -EINVAL;\n\t}\n\tuart->baud = val;\n\n\tport->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(port->membase)) {\n\t\t \n\t\treturn PTR_ERR(port->membase);\n\t}\n\n\tport->irq = irq_of_parse_and_map(np, 0);\n\n\tport->dev = &pdev->dev;\n\tport->iotype = UPIO_MEM;\n\tport->flags = UPF_BOOT_AUTOCONF;\n\tport->line = dev_id;\n\tport->ops = &arc_serial_pops;\n\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_ARC_CONSOLE);\n\n\tport->fifosize = ARC_UART_TX_FIFO_SIZE;\n\n\t \n\tport->ignore_status_mask = 0;\n\n\treturn uart_add_one_port(&arc_uart_driver, &arc_uart_ports[dev_id].port);\n}\n\nstatic const struct of_device_id arc_uart_dt_ids[] = {\n\t{ .compatible = \"snps,arc-uart\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, arc_uart_dt_ids);\n\nstatic struct platform_driver arc_platform_driver = {\n\t.probe = arc_serial_probe,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table  = arc_uart_dt_ids,\n\t },\n};\n\nstatic int __init arc_serial_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&arc_uart_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&arc_platform_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&arc_uart_driver);\n\n\treturn ret;\n}\n\nstatic void __exit arc_serial_exit(void)\n{\n\tplatform_driver_unregister(&arc_platform_driver);\n\tuart_unregister_driver(&arc_uart_driver);\n}\n\nmodule_init(arc_serial_init);\nmodule_exit(arc_serial_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_AUTHOR(\"Vineet Gupta\");\nMODULE_DESCRIPTION(\"ARC(Synopsys) On-Chip(fpga) serial driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}