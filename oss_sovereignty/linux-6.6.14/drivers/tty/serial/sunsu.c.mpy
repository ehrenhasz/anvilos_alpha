{
  "module_name": "sunsu.c",
  "hash_id": "681221d86b331737d6d10f82ad0e486a5148174a23a224a0be6429216cfcb4b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sunsu.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/circ_buf.h>\n#include <linux/serial.h>\n#include <linux/sysrq.h>\n#include <linux/console.h>\n#include <linux/slab.h>\n#ifdef CONFIG_SERIO\n#include <linux/serio.h>\n#endif\n#include <linux/serial_reg.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <asm/setup.h>\n\n#include <linux/serial_core.h>\n#include <linux/sunserialcore.h>\n\n \n#define SU_BASE_BAUD\t(1846200 / 16)\n\nenum su_type { SU_PORT_NONE, SU_PORT_MS, SU_PORT_KBD, SU_PORT_PORT };\nstatic char *su_typev[] = { \"su(???)\", \"su(mouse)\", \"su(kbd)\", \"su(serial)\" };\n\nstruct serial_uart_config {\n\tchar\t*name;\n\tint\tdfl_xmit_fifo_size;\n\tint\tflags;\n};\n\n \nstatic const struct serial_uart_config uart_config[] = {\n\t{ \"unknown\",\t1,\t0 },\n\t{ \"8250\",\t1,\t0 },\n\t{ \"16450\",\t1,\t0 },\n\t{ \"16550\",\t1,\t0 },\n\t{ \"16550A\",\t16,\tUART_CLEAR_FIFO | UART_USE_FIFO },\n\t{ \"Cirrus\",\t1, \t0 },\n\t{ \"ST16650\",\t1,\tUART_CLEAR_FIFO | UART_STARTECH },\n\t{ \"ST16650V2\",\t32,\tUART_CLEAR_FIFO | UART_USE_FIFO | UART_STARTECH },\n\t{ \"TI16750\",\t64,\tUART_CLEAR_FIFO | UART_USE_FIFO },\n\t{ \"Startech\",\t1,\t0 },\n\t{ \"16C950/954\",\t128,\tUART_CLEAR_FIFO | UART_USE_FIFO },\n\t{ \"ST16654\",\t64,\tUART_CLEAR_FIFO | UART_USE_FIFO | UART_STARTECH },\n\t{ \"XR16850\",\t128,\tUART_CLEAR_FIFO | UART_USE_FIFO | UART_STARTECH },\n\t{ \"RSA\",\t2048,\tUART_CLEAR_FIFO | UART_USE_FIFO }\n};\n\nstruct uart_sunsu_port {\n\tstruct uart_port\tport;\n\tunsigned char\t\tacr;\n\tunsigned char\t\tier;\n\tunsigned short\t\trev;\n\tunsigned char\t\tlcr;\n\tunsigned int\t\tlsr_break_flag;\n\tunsigned int\t\tcflag;\n\n\t \n\tenum su_type\t\tsu_type;\n\tunsigned int\t\ttype_probed;\t \n\tunsigned long\t\treg_size;\n\n#ifdef CONFIG_SERIO\n\tstruct serio\t\tserio;\n\tint\t\t\tserio_open;\n#endif\n};\n\nstatic unsigned int serial_in(struct uart_sunsu_port *up, int offset)\n{\n\toffset <<= up->port.regshift;\n\n\tswitch (up->port.iotype) {\n\tcase UPIO_HUB6:\n\t\toutb(up->port.hub6 - 1 + offset, up->port.iobase);\n\t\treturn inb(up->port.iobase + 1);\n\n\tcase UPIO_MEM:\n\t\treturn readb(up->port.membase + offset);\n\n\tdefault:\n\t\treturn inb(up->port.iobase + offset);\n\t}\n}\n\nstatic void serial_out(struct uart_sunsu_port *up, int offset, int value)\n{\n#ifndef CONFIG_SPARC64\n\t \n\tif (offset == UART_MCR)\n\t\tvalue |= UART_MCR_OUT2;\n#endif\n\toffset <<= up->port.regshift;\n\n\tswitch (up->port.iotype) {\n\tcase UPIO_HUB6:\n\t\toutb(up->port.hub6 - 1 + offset, up->port.iobase);\n\t\toutb(value, up->port.iobase + 1);\n\t\tbreak;\n\n\tcase UPIO_MEM:\n\t\twriteb(value, up->port.membase + offset);\n\t\tbreak;\n\n\tdefault:\n\t\toutb(value, up->port.iobase + offset);\n\t}\n}\n\n \n#define serial_inp(up, offset)\t\tserial_in(up, offset)\n#define serial_outp(up, offset, value)\tserial_out(up, offset, value)\n\n\n \nstatic void serial_icr_write(struct uart_sunsu_port *up, int offset, int value)\n{\n\tserial_out(up, UART_SCR, offset);\n\tserial_out(up, UART_ICR, value);\n}\n\n#if 0  \nstatic unsigned int serial_icr_read(struct uart_sunsu_port *up, int offset)\n{\n\tunsigned int value;\n\n\tserial_icr_write(up, UART_ACR, up->acr | UART_ACR_ICRRD);\n\tserial_out(up, UART_SCR, offset);\n\tvalue = serial_in(up, UART_ICR);\n\tserial_icr_write(up, UART_ACR, up->acr);\n\n\treturn value;\n}\n#endif\n\n#ifdef CONFIG_SERIAL_8250_RSA\n \nstatic int __enable_rsa(struct uart_sunsu_port *up)\n{\n\tunsigned char mode;\n\tint result;\n\n\tmode = serial_inp(up, UART_RSA_MSR);\n\tresult = mode & UART_RSA_MSR_FIFO;\n\n\tif (!result) {\n\t\tserial_outp(up, UART_RSA_MSR, mode | UART_RSA_MSR_FIFO);\n\t\tmode = serial_inp(up, UART_RSA_MSR);\n\t\tresult = mode & UART_RSA_MSR_FIFO;\n\t}\n\n\tif (result)\n\t\tup->port.uartclk = SERIAL_RSA_BAUD_BASE * 16;\n\n\treturn result;\n}\n\nstatic void enable_rsa(struct uart_sunsu_port *up)\n{\n\tif (up->port.type == PORT_RSA) {\n\t\tif (up->port.uartclk != SERIAL_RSA_BAUD_BASE * 16) {\n\t\t\tspin_lock_irq(&up->port.lock);\n\t\t\t__enable_rsa(up);\n\t\t\tspin_unlock_irq(&up->port.lock);\n\t\t}\n\t\tif (up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16)\n\t\t\tserial_outp(up, UART_RSA_FRR, 0);\n\t}\n}\n\n \nstatic void disable_rsa(struct uart_sunsu_port *up)\n{\n\tunsigned char mode;\n\tint result;\n\n\tif (up->port.type == PORT_RSA &&\n\t    up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16) {\n\t\tspin_lock_irq(&up->port.lock);\n\n\t\tmode = serial_inp(up, UART_RSA_MSR);\n\t\tresult = !(mode & UART_RSA_MSR_FIFO);\n\n\t\tif (!result) {\n\t\t\tserial_outp(up, UART_RSA_MSR, mode & ~UART_RSA_MSR_FIFO);\n\t\t\tmode = serial_inp(up, UART_RSA_MSR);\n\t\t\tresult = !(mode & UART_RSA_MSR_FIFO);\n\t\t}\n\n\t\tif (result)\n\t\t\tup->port.uartclk = SERIAL_RSA_BAUD_BASE_LO * 16;\n\t\tspin_unlock_irq(&up->port.lock);\n\t}\n}\n#endif  \n\nstatic inline void __stop_tx(struct uart_sunsu_port *p)\n{\n\tif (p->ier & UART_IER_THRI) {\n\t\tp->ier &= ~UART_IER_THRI;\n\t\tserial_out(p, UART_IER, p->ier);\n\t}\n}\n\nstatic void sunsu_stop_tx(struct uart_port *port)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\n\t__stop_tx(up);\n\n\t \n\tif (up->port.type == PORT_16C950) {\n\t\tup->acr |= UART_ACR_TXDIS;\n\t\tserial_icr_write(up, UART_ACR, up->acr);\n\t}\n}\n\nstatic void sunsu_start_tx(struct uart_port *port)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\n\tif (!(up->ier & UART_IER_THRI)) {\n\t\tup->ier |= UART_IER_THRI;\n\t\tserial_out(up, UART_IER, up->ier);\n\t}\n\n\t \n\tif (up->port.type == PORT_16C950 && up->acr & UART_ACR_TXDIS) {\n\t\tup->acr &= ~UART_ACR_TXDIS;\n\t\tserial_icr_write(up, UART_ACR, up->acr);\n\t}\n}\n\nstatic void sunsu_stop_rx(struct uart_port *port)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\n\tup->ier &= ~UART_IER_RLSI;\n\tup->port.read_status_mask &= ~UART_LSR_DR;\n\tserial_out(up, UART_IER, up->ier);\n}\n\nstatic void sunsu_enable_ms(struct uart_port *port)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tup->ier |= UART_IER_MSI;\n\tserial_out(up, UART_IER, up->ier);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic void\nreceive_chars(struct uart_sunsu_port *up, unsigned char *status)\n{\n\tstruct tty_port *port = &up->port.state->port;\n\tunsigned char ch, flag;\n\tint max_count = 256;\n\tint saw_console_brk = 0;\n\n\tdo {\n\t\tch = serial_inp(up, UART_RX);\n\t\tflag = TTY_NORMAL;\n\t\tup->port.icount.rx++;\n\n\t\tif (unlikely(*status & (UART_LSR_BI | UART_LSR_PE |\n\t\t\t\t       UART_LSR_FE | UART_LSR_OE))) {\n\t\t\t \n\t\t\tif (*status & UART_LSR_BI) {\n\t\t\t\t*status &= ~(UART_LSR_FE | UART_LSR_PE);\n\t\t\t\tup->port.icount.brk++;\n\t\t\t\tif (up->port.cons != NULL &&\n\t\t\t\t    up->port.line == up->port.cons->index)\n\t\t\t\t\tsaw_console_brk = 1;\n\t\t\t\t \n\t\t\t\tif (uart_handle_break(&up->port))\n\t\t\t\t\tgoto ignore_char;\n\t\t\t} else if (*status & UART_LSR_PE)\n\t\t\t\tup->port.icount.parity++;\n\t\t\telse if (*status & UART_LSR_FE)\n\t\t\t\tup->port.icount.frame++;\n\t\t\tif (*status & UART_LSR_OE)\n\t\t\t\tup->port.icount.overrun++;\n\n\t\t\t \n\t\t\t*status &= up->port.read_status_mask;\n\n\t\t\tif (up->port.cons != NULL &&\n\t\t\t    up->port.line == up->port.cons->index) {\n\t\t\t\t \n\t\t\t\t*status |= up->lsr_break_flag;\n\t\t\t\tup->lsr_break_flag = 0;\n\t\t\t}\n\n\t\t\tif (*status & UART_LSR_BI) {\n\t\t\t\tflag = TTY_BREAK;\n\t\t\t} else if (*status & UART_LSR_PE)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (*status & UART_LSR_FE)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\t\tif (uart_handle_sysrq_char(&up->port, ch))\n\t\t\tgoto ignore_char;\n\t\tif ((*status & up->port.ignore_status_mask) == 0)\n\t\t\ttty_insert_flip_char(port, ch, flag);\n\t\tif (*status & UART_LSR_OE)\n\t\t\t \n\t\t\t tty_insert_flip_char(port, 0, TTY_OVERRUN);\n\tignore_char:\n\t\t*status = serial_inp(up, UART_LSR);\n\t} while ((*status & UART_LSR_DR) && (max_count-- > 0));\n\n\tif (saw_console_brk)\n\t\tsun_do_break();\n}\n\nstatic void transmit_chars(struct uart_sunsu_port *up)\n{\n\tstruct circ_buf *xmit = &up->port.state->xmit;\n\tint count;\n\n\tif (up->port.x_char) {\n\t\tserial_outp(up, UART_TX, up->port.x_char);\n\t\tup->port.icount.tx++;\n\t\tup->port.x_char = 0;\n\t\treturn;\n\t}\n\tif (uart_tx_stopped(&up->port)) {\n\t\tsunsu_stop_tx(&up->port);\n\t\treturn;\n\t}\n\tif (uart_circ_empty(xmit)) {\n\t\t__stop_tx(up);\n\t\treturn;\n\t}\n\n\tcount = up->port.fifosize;\n\tdo {\n\t\tserial_out(up, UART_TX, xmit->buf[xmit->tail]);\n\t\tuart_xmit_advance(&up->port, 1);\n\t\tif (uart_circ_empty(xmit))\n\t\t\tbreak;\n\t} while (--count > 0);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&up->port);\n\n\tif (uart_circ_empty(xmit))\n\t\t__stop_tx(up);\n}\n\nstatic void check_modem_status(struct uart_sunsu_port *up)\n{\n\tint status;\n\n\tstatus = serial_in(up, UART_MSR);\n\n\tif ((status & UART_MSR_ANY_DELTA) == 0)\n\t\treturn;\n\n\tif (status & UART_MSR_TERI)\n\t\tup->port.icount.rng++;\n\tif (status & UART_MSR_DDSR)\n\t\tup->port.icount.dsr++;\n\tif (status & UART_MSR_DDCD)\n\t\tuart_handle_dcd_change(&up->port, status & UART_MSR_DCD);\n\tif (status & UART_MSR_DCTS)\n\t\tuart_handle_cts_change(&up->port, status & UART_MSR_CTS);\n\n\twake_up_interruptible(&up->port.state->port.delta_msr_wait);\n}\n\nstatic irqreturn_t sunsu_serial_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_sunsu_port *up = dev_id;\n\tunsigned long flags;\n\tunsigned char status;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tdo {\n\t\tstatus = serial_inp(up, UART_LSR);\n\t\tif (status & UART_LSR_DR)\n\t\t\treceive_chars(up, &status);\n\t\tcheck_modem_status(up);\n\t\tif (status & UART_LSR_THRE)\n\t\t\ttransmit_chars(up);\n\n\t\ttty_flip_buffer_push(&up->port.state->port);\n\n\t} while (!(serial_in(up, UART_IIR) & UART_IIR_NO_INT));\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void\nsunsu_change_speed(struct uart_port *port, unsigned int cflag,\n\t\t   unsigned int iflag, unsigned int quot);\n\nstatic void sunsu_change_mouse_baud(struct uart_sunsu_port *up)\n{\n\tunsigned int cur_cflag = up->cflag;\n\tint quot, new_baud;\n\n\tup->cflag &= ~CBAUD;\n\tup->cflag |= suncore_mouse_baud_cflag_next(cur_cflag, &new_baud);\n\n\tquot = up->port.uartclk / (16 * new_baud);\n\n\tsunsu_change_speed(&up->port, up->cflag, 0, quot);\n}\n\nstatic void receive_kbd_ms_chars(struct uart_sunsu_port *up, int is_break)\n{\n\tdo {\n\t\tunsigned char ch = serial_inp(up, UART_RX);\n\n\t\t \n\t\tif (up->su_type == SU_PORT_KBD) {\n#ifdef CONFIG_SERIO\n\t\t\tserio_interrupt(&up->serio, ch, 0);\n#endif\n\t\t} else if (up->su_type == SU_PORT_MS) {\n\t\t\tint ret = suncore_mouse_baud_detection(ch, is_break);\n\n\t\t\tswitch (ret) {\n\t\t\tcase 2:\n\t\t\t\tsunsu_change_mouse_baud(up);\n\t\t\t\tfallthrough;\n\t\t\tcase 1:\n\t\t\t\tbreak;\n\n\t\t\tcase 0:\n#ifdef CONFIG_SERIO\n\t\t\t\tserio_interrupt(&up->serio, ch, 0);\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (serial_in(up, UART_LSR) & UART_LSR_DR);\n}\n\nstatic irqreturn_t sunsu_kbd_ms_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_sunsu_port *up = dev_id;\n\n\tif (!(serial_in(up, UART_IIR) & UART_IIR_NO_INT)) {\n\t\tunsigned char status = serial_inp(up, UART_LSR);\n\n\t\tif ((status & UART_LSR_DR) || (status & UART_LSR_BI))\n\t\t\treceive_kbd_ms_chars(up, (status & UART_LSR_BI) != 0);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int sunsu_tx_empty(struct uart_port *port)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\tunsigned long flags;\n\tunsigned int ret;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\treturn ret;\n}\n\nstatic unsigned int sunsu_get_mctrl(struct uart_port *port)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\tunsigned char status;\n\tunsigned int ret;\n\n\tstatus = serial_in(up, UART_MSR);\n\n\tret = 0;\n\tif (status & UART_MSR_DCD)\n\t\tret |= TIOCM_CAR;\n\tif (status & UART_MSR_RI)\n\t\tret |= TIOCM_RNG;\n\tif (status & UART_MSR_DSR)\n\t\tret |= TIOCM_DSR;\n\tif (status & UART_MSR_CTS)\n\t\tret |= TIOCM_CTS;\n\treturn ret;\n}\n\nstatic void sunsu_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\tunsigned char mcr = 0;\n\n\tif (mctrl & TIOCM_RTS)\n\t\tmcr |= UART_MCR_RTS;\n\tif (mctrl & TIOCM_DTR)\n\t\tmcr |= UART_MCR_DTR;\n\tif (mctrl & TIOCM_OUT1)\n\t\tmcr |= UART_MCR_OUT1;\n\tif (mctrl & TIOCM_OUT2)\n\t\tmcr |= UART_MCR_OUT2;\n\tif (mctrl & TIOCM_LOOP)\n\t\tmcr |= UART_MCR_LOOP;\n\n\tserial_out(up, UART_MCR, mcr);\n}\n\nstatic void sunsu_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tif (break_state == -1)\n\t\tup->lcr |= UART_LCR_SBC;\n\telse\n\t\tup->lcr &= ~UART_LCR_SBC;\n\tserial_out(up, UART_LCR, up->lcr);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic int sunsu_startup(struct uart_port *port)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\tunsigned long flags;\n\tint retval;\n\n\tif (up->port.type == PORT_16C950) {\n\t\t \n\t\tup->acr = 0;\n\t\tserial_outp(up, UART_LCR, 0xBF);\n\t\tserial_outp(up, UART_EFR, UART_EFR_ECB);\n\t\tserial_outp(up, UART_IER, 0);\n\t\tserial_outp(up, UART_LCR, 0);\n\t\tserial_icr_write(up, UART_CSR, 0);  \n\t\tserial_outp(up, UART_LCR, 0xBF);\n\t\tserial_outp(up, UART_EFR, UART_EFR_ECB);\n\t\tserial_outp(up, UART_LCR, 0);\n\t}\n\n#ifdef CONFIG_SERIAL_8250_RSA\n\t \n\tenable_rsa(up);\n#endif\n\n\t \n\tif (uart_config[up->port.type].flags & UART_CLEAR_FIFO) {\n\t\tserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t\tserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t\t\tUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\t\tserial_outp(up, UART_FCR, 0);\n\t}\n\n\t \n\t(void) serial_inp(up, UART_LSR);\n\t(void) serial_inp(up, UART_RX);\n\t(void) serial_inp(up, UART_IIR);\n\t(void) serial_inp(up, UART_MSR);\n\n\t \n\tif (!(up->port.flags & UPF_BUGGY_UART) &&\n\t    (serial_inp(up, UART_LSR) == 0xff)) {\n\t\tprintk(\"ttyS%d: LSR safety check engaged!\\n\", up->port.line);\n\t\treturn -ENODEV;\n\t}\n\n\tif (up->su_type != SU_PORT_PORT) {\n\t\tretval = request_irq(up->port.irq, sunsu_kbd_ms_interrupt,\n\t\t\t\t     IRQF_SHARED, su_typev[up->su_type], up);\n\t} else {\n\t\tretval = request_irq(up->port.irq, sunsu_serial_interrupt,\n\t\t\t\t     IRQF_SHARED, su_typev[up->su_type], up);\n\t}\n\tif (retval) {\n\t\tprintk(\"su: Cannot register IRQ %d\\n\", up->port.irq);\n\t\treturn retval;\n\t}\n\n\t \n\tserial_outp(up, UART_LCR, UART_LCR_WLEN8);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tup->port.mctrl |= TIOCM_OUT2;\n\n\tsunsu_set_mctrl(&up->port, up->port.mctrl);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\t \n\tup->ier = UART_IER_RLSI | UART_IER_RDI;\n\tserial_outp(up, UART_IER, up->ier);\n\n\tif (up->port.flags & UPF_FOURPORT) {\n\t\tunsigned int icp;\n\t\t \n\t\ticp = (up->port.iobase & 0xfe0) | 0x01f;\n\t\toutb_p(0x80, icp);\n\t\t(void) inb_p(icp);\n\t}\n\n\t \n\t(void) serial_inp(up, UART_LSR);\n\t(void) serial_inp(up, UART_RX);\n\t(void) serial_inp(up, UART_IIR);\n\t(void) serial_inp(up, UART_MSR);\n\n\treturn 0;\n}\n\nstatic void sunsu_shutdown(struct uart_port *port)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\tunsigned long flags;\n\n\t \n\tup->ier = 0;\n\tserial_outp(up, UART_IER, 0);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tif (up->port.flags & UPF_FOURPORT) {\n\t\t \n\t\tinb((up->port.iobase & 0xfe0) | 0x1f);\n\t\tup->port.mctrl |= TIOCM_OUT1;\n\t} else\n\t\tup->port.mctrl &= ~TIOCM_OUT2;\n\n\tsunsu_set_mctrl(&up->port, up->port.mctrl);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\t \n\tserial_out(up, UART_LCR, serial_inp(up, UART_LCR) & ~UART_LCR_SBC);\n\tserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t\t\t  UART_FCR_CLEAR_RCVR |\n\t\t\t\t  UART_FCR_CLEAR_XMIT);\n\tserial_outp(up, UART_FCR, 0);\n\n#ifdef CONFIG_SERIAL_8250_RSA\n\t \n\tdisable_rsa(up);\n#endif\n\n\t \n\t(void) serial_in(up, UART_RX);\n\n\tfree_irq(up->port.irq, up);\n}\n\nstatic void\nsunsu_change_speed(struct uart_port *port, unsigned int cflag,\n\t\t   unsigned int iflag, unsigned int quot)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\tunsigned char cval, fcr = 0;\n\tunsigned long flags;\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\tcval = 0x00;\n\t\tbreak;\n\tcase CS6:\n\t\tcval = 0x01;\n\t\tbreak;\n\tcase CS7:\n\t\tcval = 0x02;\n\t\tbreak;\n\tdefault:\n\tcase CS8:\n\t\tcval = 0x03;\n\t\tbreak;\n\t}\n\n\tif (cflag & CSTOPB)\n\t\tcval |= 0x04;\n\tif (cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\tif (cflag & CMSPAR)\n\t\tcval |= UART_LCR_SPAR;\n\n\t \n\tif ((quot & 0xff) == 0 && up->port.type == PORT_16C950 &&\n\t    up->rev == 0x5201)\n\t\tquot ++;\n\n\tif (uart_config[up->port.type].flags & UART_USE_FIFO) {\n\t\tif ((up->port.uartclk / quot) < (2400 * 16))\n\t\t\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1;\n#ifdef CONFIG_SERIAL_8250_RSA\n\t\telse if (up->port.type == PORT_RSA)\n\t\t\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_14;\n#endif\n\t\telse\n\t\t\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_8;\n\t}\n\tif (up->port.type == PORT_16750)\n\t\tfcr |= UART_FCR7_64BYTE;\n\n\t \n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t \n\tuart_update_timeout(port, cflag, (port->uartclk / (16 * quot)));\n\n\tup->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\n\tif (iflag & INPCK)\n\t\tup->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tup->port.read_status_mask |= UART_LSR_BI;\n\n\t \n\tup->port.ignore_status_mask = 0;\n\tif (iflag & IGNPAR)\n\t\tup->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\n\tif (iflag & IGNBRK) {\n\t\tup->port.ignore_status_mask |= UART_LSR_BI;\n\t\t \n\t\tif (iflag & IGNPAR)\n\t\t\tup->port.ignore_status_mask |= UART_LSR_OE;\n\t}\n\n\t \n\tif ((cflag & CREAD) == 0)\n\t\tup->port.ignore_status_mask |= UART_LSR_DR;\n\n\t \n\tup->ier &= ~UART_IER_MSI;\n\tif (UART_ENABLE_MS(&up->port, cflag))\n\t\tup->ier |= UART_IER_MSI;\n\n\tserial_out(up, UART_IER, up->ier);\n\n\tif (uart_config[up->port.type].flags & UART_STARTECH) {\n\t\tserial_outp(up, UART_LCR, 0xBF);\n\t\tserial_outp(up, UART_EFR, cflag & CRTSCTS ? UART_EFR_CTS :0);\n\t}\n\tserial_outp(up, UART_LCR, cval | UART_LCR_DLAB); \n\tserial_outp(up, UART_DLL, quot & 0xff);\t\t \n\tserial_outp(up, UART_DLM, quot >> 8);\t\t \n\tif (up->port.type == PORT_16750)\n\t\tserial_outp(up, UART_FCR, fcr);\t\t \n\tserial_outp(up, UART_LCR, cval);\t\t \n\tup->lcr = cval;\t\t\t\t\t \n\tif (up->port.type != PORT_16750) {\n\t\tif (fcr & UART_FCR_ENABLE_FIFO) {\n\t\t\t \n\t\t\tserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t\t}\n\t\tserial_outp(up, UART_FCR, fcr);\t\t \n\t}\n\n\tup->cflag = cflag;\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic void\nsunsu_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t  const struct ktermios *old)\n{\n\tunsigned int baud, quot;\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16); \n\tquot = uart_get_divisor(port, baud);\n\n\tsunsu_change_speed(port, termios->c_cflag, termios->c_iflag, quot);\n}\n\nstatic void sunsu_release_port(struct uart_port *port)\n{\n}\n\nstatic int sunsu_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void sunsu_config_port(struct uart_port *port, int flags)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\n\tif (flags & UART_CONFIG_TYPE) {\n\t\t \n\t\tport->type = up->type_probed;\t \n\t}\n}\n\nstatic int\nsunsu_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\treturn -EINVAL;\n}\n\nstatic const char *\nsunsu_type(struct uart_port *port)\n{\n\tint type = port->type;\n\n\tif (type >= ARRAY_SIZE(uart_config))\n\t\ttype = 0;\n\treturn uart_config[type].name;\n}\n\nstatic const struct uart_ops sunsu_pops = {\n\t.tx_empty\t= sunsu_tx_empty,\n\t.set_mctrl\t= sunsu_set_mctrl,\n\t.get_mctrl\t= sunsu_get_mctrl,\n\t.stop_tx\t= sunsu_stop_tx,\n\t.start_tx\t= sunsu_start_tx,\n\t.stop_rx\t= sunsu_stop_rx,\n\t.enable_ms\t= sunsu_enable_ms,\n\t.break_ctl\t= sunsu_break_ctl,\n\t.startup\t= sunsu_startup,\n\t.shutdown\t= sunsu_shutdown,\n\t.set_termios\t= sunsu_set_termios,\n\t.type\t\t= sunsu_type,\n\t.release_port\t= sunsu_release_port,\n\t.request_port\t= sunsu_request_port,\n\t.config_port\t= sunsu_config_port,\n\t.verify_port\t= sunsu_verify_port,\n};\n\n#define UART_NR\t4\n\nstatic struct uart_sunsu_port sunsu_ports[UART_NR];\nstatic int nr_inst;  \n\n#ifdef CONFIG_SERIO\n\nstatic DEFINE_SPINLOCK(sunsu_serio_lock);\n\nstatic int sunsu_serio_write(struct serio *serio, unsigned char ch)\n{\n\tstruct uart_sunsu_port *up = serio->port_data;\n\tunsigned long flags;\n\tint lsr;\n\n\tspin_lock_irqsave(&sunsu_serio_lock, flags);\n\n\tdo {\n\t\tlsr = serial_in(up, UART_LSR);\n\t} while (!(lsr & UART_LSR_THRE));\n\n\t \n\tserial_out(up, UART_TX, ch);\n\n\tspin_unlock_irqrestore(&sunsu_serio_lock, flags);\n\n\treturn 0;\n}\n\nstatic int sunsu_serio_open(struct serio *serio)\n{\n\tstruct uart_sunsu_port *up = serio->port_data;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&sunsu_serio_lock, flags);\n\tif (!up->serio_open) {\n\t\tup->serio_open = 1;\n\t\tret = 0;\n\t} else\n\t\tret = -EBUSY;\n\tspin_unlock_irqrestore(&sunsu_serio_lock, flags);\n\n\treturn ret;\n}\n\nstatic void sunsu_serio_close(struct serio *serio)\n{\n\tstruct uart_sunsu_port *up = serio->port_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sunsu_serio_lock, flags);\n\tup->serio_open = 0;\n\tspin_unlock_irqrestore(&sunsu_serio_lock, flags);\n}\n\n#endif  \n\nstatic void sunsu_autoconfig(struct uart_sunsu_port *up)\n{\n\tunsigned char status1, status2, scratch, scratch2, scratch3;\n\tunsigned char save_lcr, save_mcr;\n\tunsigned long flags;\n\n\tif (up->su_type == SU_PORT_NONE)\n\t\treturn;\n\n\tup->type_probed = PORT_UNKNOWN;\n\tup->port.iotype = UPIO_MEM;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tif (!(up->port.flags & UPF_BUGGY_UART)) {\n\t\t \n\t\tscratch = serial_inp(up, UART_IER);\n\t\tserial_outp(up, UART_IER, 0);\n#ifdef __i386__\n\t\toutb(0xff, 0x080);\n#endif\n\t\tscratch2 = serial_inp(up, UART_IER);\n\t\tserial_outp(up, UART_IER, 0x0f);\n#ifdef __i386__\n\t\toutb(0, 0x080);\n#endif\n\t\tscratch3 = serial_inp(up, UART_IER);\n\t\tserial_outp(up, UART_IER, scratch);\n\t\tif (scratch2 != 0 || scratch3 != 0x0F)\n\t\t\tgoto out;\t \n\t}\n\n\tsave_mcr = serial_in(up, UART_MCR);\n\tsave_lcr = serial_in(up, UART_LCR);\n\n\t \n\tif (!(up->port.flags & UPF_SKIP_TEST)) {\n\t\tserial_outp(up, UART_MCR, UART_MCR_LOOP | 0x0A);\n\t\tstatus1 = serial_inp(up, UART_MSR) & 0xF0;\n\t\tserial_outp(up, UART_MCR, save_mcr);\n\t\tif (status1 != 0x90)\n\t\t\tgoto out;\t \n\t}\n\tserial_outp(up, UART_LCR, 0xBF);\t \n\tserial_outp(up, UART_EFR, 0);\t\t \n\tserial_outp(up, UART_LCR, 0);\n\tserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);\n\tscratch = serial_in(up, UART_IIR) >> 6;\n\tswitch (scratch) {\n\t\tcase 0:\n\t\t\tup->port.type = PORT_16450;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tup->port.type = PORT_UNKNOWN;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tup->port.type = PORT_16550;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tup->port.type = PORT_16550A;\n\t\t\tbreak;\n\t}\n\tif (up->port.type == PORT_16550A) {\n\t\t \n\t\tserial_outp(up, UART_LCR, UART_LCR_DLAB);\n\t\tif (serial_in(up, UART_EFR) == 0) {\n\t\t\tup->port.type = PORT_16650;\n\t\t} else {\n\t\t\tserial_outp(up, UART_LCR, 0xBF);\n\t\t\tif (serial_in(up, UART_EFR) == 0)\n\t\t\t\tup->port.type = PORT_16650V2;\n\t\t}\n\t}\n\tif (up->port.type == PORT_16550A) {\n\t\t \n\t\tserial_outp(up, UART_LCR, save_lcr | UART_LCR_DLAB);\n\t\tserial_outp(up, UART_FCR,\n\t\t\t    UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);\n\t\tscratch = serial_in(up, UART_IIR) >> 5;\n\t\tif (scratch == 7) {\n\t\t\t \n \t\t\tserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t\t\tserial_outp(up, UART_LCR, 0);\n\t\t\tserial_outp(up, UART_FCR,\n\t\t\t\t    UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);\n\t\t\tscratch = serial_in(up, UART_IIR) >> 5;\n\t\t\tif (scratch == 6)\n\t\t\t\tup->port.type = PORT_16750;\n\t\t}\n\t\tserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t}\n\tserial_outp(up, UART_LCR, save_lcr);\n\tif (up->port.type == PORT_16450) {\n\t\tscratch = serial_in(up, UART_SCR);\n\t\tserial_outp(up, UART_SCR, 0xa5);\n\t\tstatus1 = serial_in(up, UART_SCR);\n\t\tserial_outp(up, UART_SCR, 0x5a);\n\t\tstatus2 = serial_in(up, UART_SCR);\n\t\tserial_outp(up, UART_SCR, scratch);\n\n\t\tif ((status1 != 0xa5) || (status2 != 0x5a))\n\t\t\tup->port.type = PORT_8250;\n\t}\n\n\tup->port.fifosize = uart_config[up->port.type].dfl_xmit_fifo_size;\n\n\tif (up->port.type == PORT_UNKNOWN)\n\t\tgoto out;\n\tup->type_probed = up->port.type;\t \n\n\t \n#ifdef CONFIG_SERIAL_8250_RSA\n\tif (up->port.type == PORT_RSA)\n\t\tserial_outp(up, UART_RSA_FRR, 0);\n#endif\n\tserial_outp(up, UART_MCR, save_mcr);\n\tserial_outp(up, UART_FCR, (UART_FCR_ENABLE_FIFO |\n\t\t\t\t     UART_FCR_CLEAR_RCVR |\n\t\t\t\t     UART_FCR_CLEAR_XMIT));\n\tserial_outp(up, UART_FCR, 0);\n\t(void)serial_in(up, UART_RX);\n\tserial_outp(up, UART_IER, 0);\n\nout:\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic struct uart_driver sunsu_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"sunsu\",\n\t.dev_name\t\t= \"ttyS\",\n\t.major\t\t\t= TTY_MAJOR,\n};\n\nstatic int sunsu_kbd_ms_init(struct uart_sunsu_port *up)\n{\n\tint quot, baud;\n#ifdef CONFIG_SERIO\n\tstruct serio *serio;\n#endif\n\n\tif (up->su_type == SU_PORT_KBD) {\n\t\tup->cflag = B1200 | CS8 | CLOCAL | CREAD;\n\t\tbaud = 1200;\n\t} else {\n\t\tup->cflag = B4800 | CS8 | CLOCAL | CREAD;\n\t\tbaud = 4800;\n\t}\n\tquot = up->port.uartclk / (16 * baud);\n\n\tsunsu_autoconfig(up);\n\tif (up->port.type == PORT_UNKNOWN)\n\t\treturn -ENODEV;\n\n\tprintk(\"%pOF: %s port at %llx, irq %u\\n\",\n\t       up->port.dev->of_node,\n\t       (up->su_type == SU_PORT_KBD) ? \"Keyboard\" : \"Mouse\",\n\t       (unsigned long long) up->port.mapbase,\n\t       up->port.irq);\n\n#ifdef CONFIG_SERIO\n\tserio = &up->serio;\n\tserio->port_data = up;\n\n\tserio->id.type = SERIO_RS232;\n\tif (up->su_type == SU_PORT_KBD) {\n\t\tserio->id.proto = SERIO_SUNKBD;\n\t\tstrscpy(serio->name, \"sukbd\", sizeof(serio->name));\n\t} else {\n\t\tserio->id.proto = SERIO_SUN;\n\t\tserio->id.extra = 1;\n\t\tstrscpy(serio->name, \"sums\", sizeof(serio->name));\n\t}\n\tstrscpy(serio->phys,\n\t\t(!(up->port.line & 1) ? \"su/serio0\" : \"su/serio1\"),\n\t\tsizeof(serio->phys));\n\n\tserio->write = sunsu_serio_write;\n\tserio->open = sunsu_serio_open;\n\tserio->close = sunsu_serio_close;\n\tserio->dev.parent = up->port.dev;\n\n\tserio_register_port(serio);\n#endif\n\n\tsunsu_change_speed(&up->port, up->cflag, 0, quot);\n\n\tsunsu_startup(&up->port);\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_SERIAL_SUNSU_CONSOLE\n\n \nstatic void wait_for_xmitr(struct uart_sunsu_port *up)\n{\n\tunsigned int status, tmout = 10000;\n\n\t \n\tdo {\n\t\tstatus = serial_in(up, UART_LSR);\n\n\t\tif (status & UART_LSR_BI)\n\t\t\tup->lsr_break_flag = UART_LSR_BI;\n\n\t\tif (--tmout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (!uart_lsr_tx_empty(status));\n\n\t \n\tif (up->port.flags & UPF_CONS_FLOW) {\n\t\ttmout = 1000000;\n\t\twhile (--tmout &&\n\t\t       ((serial_in(up, UART_MSR) & UART_MSR_CTS) == 0))\n\t\t\tudelay(1);\n\t}\n}\n\nstatic void sunsu_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct uart_sunsu_port *up =\n\t\tcontainer_of(port, struct uart_sunsu_port, port);\n\n\twait_for_xmitr(up);\n\tserial_out(up, UART_TX, ch);\n}\n\n \nstatic void sunsu_console_write(struct console *co, const char *s,\n\t\t\t\tunsigned int count)\n{\n\tstruct uart_sunsu_port *up = &sunsu_ports[co->index];\n\tunsigned long flags;\n\tunsigned int ier;\n\tint locked = 1;\n\n\tif (up->port.sysrq || oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&up->port.lock, flags);\n\telse\n\t\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t \n\tier = serial_in(up, UART_IER);\n\tserial_out(up, UART_IER, 0);\n\n\tuart_console_write(&up->port, s, count, sunsu_console_putchar);\n\n\t \n\twait_for_xmitr(up);\n\tserial_out(up, UART_IER, ier);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\n \nstatic int __init sunsu_console_setup(struct console *co, char *options)\n{\n\tstatic struct ktermios dummy;\n\tstruct ktermios termios;\n\tstruct uart_port *port;\n\n\tprintk(\"Console: ttyS%d (SU)\\n\",\n\t       (sunsu_reg.minor - 64) + co->index);\n\n\tif (co->index > nr_inst)\n\t\treturn -ENODEV;\n\tport = &sunsu_ports[co->index].port;\n\n\t \n\tspin_lock_init(&port->lock);\n\n\t \n\tsunserial_console_termios(co, port->dev->of_node);\n\n\tmemset(&termios, 0, sizeof(struct ktermios));\n\ttermios.c_cflag = co->cflag;\n\tport->mctrl |= TIOCM_DTR;\n\tport->ops->set_termios(port, &termios, &dummy);\n\n\treturn 0;\n}\n\nstatic struct console sunsu_console = {\n\t.name\t=\t\"ttyS\",\n\t.write\t=\tsunsu_console_write,\n\t.device\t=\tuart_console_device,\n\t.setup\t=\tsunsu_console_setup,\n\t.flags\t=\tCON_PRINTBUFFER,\n\t.index\t=\t-1,\n\t.data\t=\t&sunsu_reg,\n};\n\n \n\nstatic inline struct console *SUNSU_CONSOLE(void)\n{\n\treturn &sunsu_console;\n}\n#else\n#define SUNSU_CONSOLE()\t\t\t(NULL)\n#define sunsu_serial_console_init()\tdo { } while (0)\n#endif\n\nstatic enum su_type su_get_type(struct device_node *dp)\n{\n\tstruct device_node *ap = of_find_node_by_path(\"/aliases\");\n\tenum su_type rc = SU_PORT_PORT;\n\n\tif (ap) {\n\t\tconst char *keyb = of_get_property(ap, \"keyboard\", NULL);\n\t\tconst char *ms = of_get_property(ap, \"mouse\", NULL);\n\t\tstruct device_node *match;\n\n\t\tif (keyb) {\n\t\t\tmatch = of_find_node_by_path(keyb);\n\n\t\t\t \n\t\t\tof_node_put(match);\n\n\t\t\tif (dp == match) {\n\t\t\t\trc = SU_PORT_KBD;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (ms) {\n\t\t\tmatch = of_find_node_by_path(ms);\n\n\t\t\tof_node_put(match);\n\n\t\t\tif (dp == match) {\n\t\t\t\trc = SU_PORT_MS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tof_node_put(ap);\n\treturn rc;\n}\n\nstatic int su_probe(struct platform_device *op)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct uart_sunsu_port *up;\n\tstruct resource *rp;\n\tenum su_type type;\n\tbool ignore_line;\n\tint err;\n\n\ttype = su_get_type(dp);\n\tif (type == SU_PORT_PORT) {\n\t\tif (nr_inst >= UART_NR)\n\t\t\treturn -EINVAL;\n\t\tup = &sunsu_ports[nr_inst];\n\t} else {\n\t\tup = kzalloc(sizeof(*up), GFP_KERNEL);\n\t\tif (!up)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tup->port.line = nr_inst;\n\n\tspin_lock_init(&up->port.lock);\n\n\tup->su_type = type;\n\n\trp = &op->resource[0];\n\tup->port.mapbase = rp->start;\n\tup->reg_size = resource_size(rp);\n\tup->port.membase = of_ioremap(rp, 0, up->reg_size, \"su\");\n\tif (!up->port.membase) {\n\t\tif (type != SU_PORT_PORT)\n\t\t\tkfree(up);\n\t\treturn -ENOMEM;\n\t}\n\n\tup->port.irq = op->archdata.irqs[0];\n\n\tup->port.dev = &op->dev;\n\n\tup->port.type = PORT_UNKNOWN;\n\tup->port.uartclk = (SU_BASE_BAUD * 16);\n\tup->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_SUNSU_CONSOLE);\n\n\terr = 0;\n\tif (up->su_type == SU_PORT_KBD || up->su_type == SU_PORT_MS) {\n\t\terr = sunsu_kbd_ms_init(up);\n\t\tif (err) {\n\t\t\tof_iounmap(&op->resource[0],\n\t\t\t\t   up->port.membase, up->reg_size);\n\t\t\tkfree(up);\n\t\t\treturn err;\n\t\t}\n\t\tplatform_set_drvdata(op, up);\n\n\t\tnr_inst++;\n\n\t\treturn 0;\n\t}\n\n\tup->port.flags |= UPF_BOOT_AUTOCONF;\n\n\tsunsu_autoconfig(up);\n\n\terr = -ENODEV;\n\tif (up->port.type == PORT_UNKNOWN)\n\t\tgoto out_unmap;\n\n\tup->port.ops = &sunsu_pops;\n\n\tignore_line = false;\n\tif (of_node_name_eq(dp, \"rsc-console\") ||\n\t    of_node_name_eq(dp, \"lom-console\"))\n\t\tignore_line = true;\n\n\tsunserial_console_match(SUNSU_CONSOLE(), dp,\n\t\t\t\t&sunsu_reg, up->port.line,\n\t\t\t\tignore_line);\n\terr = uart_add_one_port(&sunsu_reg, &up->port);\n\tif (err)\n\t\tgoto out_unmap;\n\n\tplatform_set_drvdata(op, up);\n\n\tnr_inst++;\n\n\treturn 0;\n\nout_unmap:\n\tof_iounmap(&op->resource[0], up->port.membase, up->reg_size);\n\tkfree(up);\n\treturn err;\n}\n\nstatic int su_remove(struct platform_device *op)\n{\n\tstruct uart_sunsu_port *up = platform_get_drvdata(op);\n\tbool kbdms = false;\n\n\tif (up->su_type == SU_PORT_MS ||\n\t    up->su_type == SU_PORT_KBD)\n\t\tkbdms = true;\n\n\tif (kbdms) {\n#ifdef CONFIG_SERIO\n\t\tserio_unregister_port(&up->serio);\n#endif\n\t} else if (up->port.type != PORT_UNKNOWN)\n\t\tuart_remove_one_port(&sunsu_reg, &up->port);\n\n\tif (up->port.membase)\n\t\tof_iounmap(&op->resource[0], up->port.membase, up->reg_size);\n\n\tif (kbdms)\n\t\tkfree(up);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id su_match[] = {\n\t{\n\t\t.name = \"su\",\n\t},\n\t{\n\t\t.name = \"su_pnp\",\n\t},\n\t{\n\t\t.name = \"serial\",\n\t\t.compatible = \"su\",\n\t},\n\t{\n\t\t.type = \"serial\",\n\t\t.compatible = \"su\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, su_match);\n\nstatic struct platform_driver su_driver = {\n\t.driver = {\n\t\t.name = \"su\",\n\t\t.of_match_table = su_match,\n\t},\n\t.probe\t\t= su_probe,\n\t.remove\t\t= su_remove,\n};\n\nstatic int __init sunsu_init(void)\n{\n\tstruct device_node *dp;\n\tint err;\n\tint num_uart = 0;\n\n\tfor_each_node_by_name(dp, \"su\") {\n\t\tif (su_get_type(dp) == SU_PORT_PORT)\n\t\t\tnum_uart++;\n\t}\n\tfor_each_node_by_name(dp, \"su_pnp\") {\n\t\tif (su_get_type(dp) == SU_PORT_PORT)\n\t\t\tnum_uart++;\n\t}\n\tfor_each_node_by_name(dp, \"serial\") {\n\t\tif (of_device_is_compatible(dp, \"su\")) {\n\t\t\tif (su_get_type(dp) == SU_PORT_PORT)\n\t\t\t\tnum_uart++;\n\t\t}\n\t}\n\tfor_each_node_by_type(dp, \"serial\") {\n\t\tif (of_device_is_compatible(dp, \"su\")) {\n\t\t\tif (su_get_type(dp) == SU_PORT_PORT)\n\t\t\t\tnum_uart++;\n\t\t}\n\t}\n\n\tif (num_uart) {\n\t\terr = sunserial_register_minors(&sunsu_reg, num_uart);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = platform_driver_register(&su_driver);\n\tif (err && num_uart)\n\t\tsunserial_unregister_minors(&sunsu_reg, num_uart);\n\n\treturn err;\n}\n\nstatic void __exit sunsu_exit(void)\n{\n\tplatform_driver_unregister(&su_driver);\n\tif (sunsu_reg.nr)\n\t\tsunserial_unregister_minors(&sunsu_reg, sunsu_reg.nr);\n}\n\nmodule_init(sunsu_init);\nmodule_exit(sunsu_exit);\n\nMODULE_AUTHOR(\"Eddie C. Dost, Peter Zaitcev, and David S. Miller\");\nMODULE_DESCRIPTION(\"Sun SU serial port driver\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}