{
  "module_name": "max310x.c",
  "hash_id": "71900f49c15733698a9f5998b56826c22adc51bdcdc6ec2e6d4f3775aa169915",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/max310x.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/spi/spi.h>\n#include <linux/uaccess.h>\n\n#define MAX310X_NAME\t\t\t\"max310x\"\n#define MAX310X_MAJOR\t\t\t204\n#define MAX310X_MINOR\t\t\t209\n#define MAX310X_UART_NRMAX\t\t16\n\n \n#define MAX310X_RHR_REG\t\t\t(0x00)  \n#define MAX310X_THR_REG\t\t\t(0x00)  \n#define MAX310X_IRQEN_REG\t\t(0x01)  \n#define MAX310X_IRQSTS_REG\t\t(0x02)  \n#define MAX310X_LSR_IRQEN_REG\t\t(0x03)  \n#define MAX310X_LSR_IRQSTS_REG\t\t(0x04)  \n#define MAX310X_REG_05\t\t\t(0x05)\n#define MAX310X_SPCHR_IRQEN_REG\t\tMAX310X_REG_05  \n#define MAX310X_SPCHR_IRQSTS_REG\t(0x06)  \n#define MAX310X_STS_IRQEN_REG\t\t(0x07)  \n#define MAX310X_STS_IRQSTS_REG\t\t(0x08)  \n#define MAX310X_MODE1_REG\t\t(0x09)  \n#define MAX310X_MODE2_REG\t\t(0x0a)  \n#define MAX310X_LCR_REG\t\t\t(0x0b)  \n#define MAX310X_RXTO_REG\t\t(0x0c)  \n#define MAX310X_HDPIXDELAY_REG\t\t(0x0d)  \n#define MAX310X_IRDA_REG\t\t(0x0e)  \n#define MAX310X_FLOWLVL_REG\t\t(0x0f)  \n#define MAX310X_FIFOTRIGLVL_REG\t\t(0x10)  \n#define MAX310X_TXFIFOLVL_REG\t\t(0x11)  \n#define MAX310X_RXFIFOLVL_REG\t\t(0x12)  \n#define MAX310X_FLOWCTRL_REG\t\t(0x13)  \n#define MAX310X_XON1_REG\t\t(0x14)  \n#define MAX310X_XON2_REG\t\t(0x15)  \n#define MAX310X_XOFF1_REG\t\t(0x16)  \n#define MAX310X_XOFF2_REG\t\t(0x17)  \n#define MAX310X_GPIOCFG_REG\t\t(0x18)  \n#define MAX310X_GPIODATA_REG\t\t(0x19)  \n#define MAX310X_PLLCFG_REG\t\t(0x1a)  \n#define MAX310X_BRGCFG_REG\t\t(0x1b)  \n#define MAX310X_BRGDIVLSB_REG\t\t(0x1c)  \n#define MAX310X_BRGDIVMSB_REG\t\t(0x1d)  \n#define MAX310X_CLKSRC_REG\t\t(0x1e)  \n#define MAX310X_REG_1F\t\t\t(0x1f)\n\n#define MAX310X_REVID_REG\t\tMAX310X_REG_1F  \n\n#define MAX310X_GLOBALIRQ_REG\t\tMAX310X_REG_1F  \n#define MAX310X_GLOBALCMD_REG\t\tMAX310X_REG_1F  \n\n \n#define MAX310X_SPI_REVID_EXTREG\tMAX310X_REG_05  \n#define MAX310X_I2C_REVID_EXTREG\t(0x25)  \n\n \n#define MAX310X_IRQ_LSR_BIT\t\t(1 << 0)  \n#define MAX310X_IRQ_SPCHR_BIT\t\t(1 << 1)  \n#define MAX310X_IRQ_STS_BIT\t\t(1 << 2)  \n#define MAX310X_IRQ_RXFIFO_BIT\t\t(1 << 3)  \n#define MAX310X_IRQ_TXFIFO_BIT\t\t(1 << 4)  \n#define MAX310X_IRQ_TXEMPTY_BIT\t\t(1 << 5)  \n#define MAX310X_IRQ_RXEMPTY_BIT\t\t(1 << 6)  \n#define MAX310X_IRQ_CTS_BIT\t\t(1 << 7)  \n\n \n#define MAX310X_LSR_RXTO_BIT\t\t(1 << 0)  \n#define MAX310X_LSR_RXOVR_BIT\t\t(1 << 1)  \n#define MAX310X_LSR_RXPAR_BIT\t\t(1 << 2)  \n#define MAX310X_LSR_FRERR_BIT\t\t(1 << 3)  \n#define MAX310X_LSR_RXBRK_BIT\t\t(1 << 4)  \n#define MAX310X_LSR_RXNOISE_BIT\t\t(1 << 5)  \n#define MAX310X_LSR_CTS_BIT\t\t(1 << 7)  \n\n \n#define MAX310X_SPCHR_XON1_BIT\t\t(1 << 0)  \n#define MAX310X_SPCHR_XON2_BIT\t\t(1 << 1)  \n#define MAX310X_SPCHR_XOFF1_BIT\t\t(1 << 2)  \n#define MAX310X_SPCHR_XOFF2_BIT\t\t(1 << 3)  \n#define MAX310X_SPCHR_BREAK_BIT\t\t(1 << 4)  \n#define MAX310X_SPCHR_MULTIDROP_BIT\t(1 << 5)  \n\n \n#define MAX310X_STS_GPIO0_BIT\t\t(1 << 0)  \n#define MAX310X_STS_GPIO1_BIT\t\t(1 << 1)  \n#define MAX310X_STS_GPIO2_BIT\t\t(1 << 2)  \n#define MAX310X_STS_GPIO3_BIT\t\t(1 << 3)  \n#define MAX310X_STS_CLKREADY_BIT\t(1 << 5)  \n#define MAX310X_STS_SLEEP_BIT\t\t(1 << 6)  \n\n \n#define MAX310X_MODE1_RXDIS_BIT\t\t(1 << 0)  \n#define MAX310X_MODE1_TXDIS_BIT\t\t(1 << 1)  \n#define MAX310X_MODE1_TXHIZ_BIT\t\t(1 << 2)  \n#define MAX310X_MODE1_RTSHIZ_BIT\t(1 << 3)  \n#define MAX310X_MODE1_TRNSCVCTRL_BIT\t(1 << 4)  \n#define MAX310X_MODE1_FORCESLEEP_BIT\t(1 << 5)  \n#define MAX310X_MODE1_AUTOSLEEP_BIT\t(1 << 6)  \n#define MAX310X_MODE1_IRQSEL_BIT\t(1 << 7)  \n\n \n#define MAX310X_MODE2_RST_BIT\t\t(1 << 0)  \n#define MAX310X_MODE2_FIFORST_BIT\t(1 << 1)  \n#define MAX310X_MODE2_RXTRIGINV_BIT\t(1 << 2)  \n#define MAX310X_MODE2_RXEMPTINV_BIT\t(1 << 3)  \n#define MAX310X_MODE2_SPCHR_BIT\t\t(1 << 4)  \n#define MAX310X_MODE2_LOOPBACK_BIT\t(1 << 5)  \n#define MAX310X_MODE2_MULTIDROP_BIT\t(1 << 6)  \n#define MAX310X_MODE2_ECHOSUPR_BIT\t(1 << 7)  \n\n \n#define MAX310X_LCR_LENGTH0_BIT\t\t(1 << 0)  \n#define MAX310X_LCR_LENGTH1_BIT\t\t(1 << 1)  \n#define MAX310X_LCR_STOPLEN_BIT\t\t(1 << 2)  \n#define MAX310X_LCR_PARITY_BIT\t\t(1 << 3)  \n#define MAX310X_LCR_EVENPARITY_BIT\t(1 << 4)  \n#define MAX310X_LCR_FORCEPARITY_BIT\t(1 << 5)  \n#define MAX310X_LCR_TXBREAK_BIT\t\t(1 << 6)  \n#define MAX310X_LCR_RTS_BIT\t\t(1 << 7)  \n\n \n#define MAX310X_IRDA_IRDAEN_BIT\t\t(1 << 0)  \n#define MAX310X_IRDA_SIR_BIT\t\t(1 << 1)  \n\n \n#define MAX310X_FLOWLVL_HALT_MASK\t(0x000f)  \n#define MAX310X_FLOWLVL_RES_MASK\t(0x00f0)  \n#define MAX310X_FLOWLVL_HALT(words)\t((words / 8) & 0x0f)\n#define MAX310X_FLOWLVL_RES(words)\t(((words / 8) & 0x0f) << 4)\n\n \n#define MAX310X_FIFOTRIGLVL_TX_MASK\t(0x0f)  \n#define MAX310X_FIFOTRIGLVL_RX_MASK\t(0xf0)  \n#define MAX310X_FIFOTRIGLVL_TX(words)\t((words / 8) & 0x0f)\n#define MAX310X_FIFOTRIGLVL_RX(words)\t(((words / 8) & 0x0f) << 4)\n\n \n#define MAX310X_FLOWCTRL_AUTORTS_BIT\t(1 << 0)  \n#define MAX310X_FLOWCTRL_AUTOCTS_BIT\t(1 << 1)  \n#define MAX310X_FLOWCTRL_GPIADDR_BIT\t(1 << 2)  \n#define MAX310X_FLOWCTRL_SWFLOWEN_BIT\t(1 << 3)  \n#define MAX310X_FLOWCTRL_SWFLOW0_BIT\t(1 << 4)  \n#define MAX310X_FLOWCTRL_SWFLOW1_BIT\t(1 << 5)  \n#define MAX310X_FLOWCTRL_SWFLOW2_BIT\t(1 << 6)  \n#define MAX310X_FLOWCTRL_SWFLOW3_BIT\t(1 << 7)  \n\n \n#define MAX310X_PLLCFG_PREDIV_MASK\t(0x3f)  \n#define MAX310X_PLLCFG_PLLFACTOR_MASK\t(0xc0)  \n\n \n#define MAX310X_BRGCFG_2XMODE_BIT\t(1 << 4)  \n#define MAX310X_BRGCFG_4XMODE_BIT\t(1 << 5)  \n\n \n#define MAX310X_CLKSRC_CRYST_BIT\t(1 << 1)  \n#define MAX310X_CLKSRC_PLL_BIT\t\t(1 << 2)  \n#define MAX310X_CLKSRC_PLLBYP_BIT\t(1 << 3)  \n#define MAX310X_CLKSRC_EXTCLK_BIT\t(1 << 4)  \n#define MAX310X_CLKSRC_CLK2RTS_BIT\t(1 << 7)  \n\n \n#define MAX310X_EXTREG_ENBL\t\t(0xce)\n#define MAX310X_EXTREG_DSBL\t\t(0xcd)\n\n \n#define MAX310X_FIFO_SIZE\t\t(128)\n#define MAX310x_REV_MASK\t\t(0xf8)\n#define MAX310X_WRITE_BIT\t\t0x80\n\n \n#define MAX3107_REV_ID\t\t\t(0xa0)\n\n \n#define MAX3109_REV_ID\t\t\t(0xc0)\n\n \n#define MAX14830_BRGCFG_CLKDIS_BIT\t(1 << 6)  \n#define MAX14830_REV_ID\t\t\t(0xb0)\n\nstruct max310x_if_cfg {\n\tint (*extended_reg_enable)(struct device *dev, bool enable);\n\n\tunsigned int rev_id_reg;\n};\n\nstruct max310x_devtype {\n\tstruct {\n\t\tunsigned short min;\n\t\tunsigned short max;\n\t} slave_addr;\n\tchar\tname[9];\n\tint\tnr;\n\tu8\tmode1;\n\tint\t(*detect)(struct device *);\n\tvoid\t(*power)(struct uart_port *, int);\n};\n\nstruct max310x_one {\n\tstruct uart_port\tport;\n\tstruct work_struct\ttx_work;\n\tstruct work_struct\tmd_work;\n\tstruct work_struct\trs_work;\n\tstruct regmap\t\t*regmap;\n\n\tu8 rx_buf[MAX310X_FIFO_SIZE];\n};\n#define to_max310x_port(_port) \\\n\tcontainer_of(_port, struct max310x_one, port)\n\nstruct max310x_port {\n\tconst struct max310x_devtype *devtype;\n\tconst struct max310x_if_cfg *if_cfg;\n\tstruct regmap\t\t*regmap;\n\tstruct clk\t\t*clk;\n#ifdef CONFIG_GPIOLIB\n\tstruct gpio_chip\tgpio;\n#endif\n\tstruct max310x_one\tp[];\n};\n\nstatic struct uart_driver max310x_uart = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= MAX310X_NAME,\n\t.dev_name\t= \"ttyMAX\",\n\t.major\t\t= MAX310X_MAJOR,\n\t.minor\t\t= MAX310X_MINOR,\n\t.nr\t\t= MAX310X_UART_NRMAX,\n};\n\nstatic DECLARE_BITMAP(max310x_lines, MAX310X_UART_NRMAX);\n\nstatic u8 max310x_port_read(struct uart_port *port, u8 reg)\n{\n\tstruct max310x_one *one = to_max310x_port(port);\n\tunsigned int val = 0;\n\n\tregmap_read(one->regmap, reg, &val);\n\n\treturn val;\n}\n\nstatic void max310x_port_write(struct uart_port *port, u8 reg, u8 val)\n{\n\tstruct max310x_one *one = to_max310x_port(port);\n\n\tregmap_write(one->regmap, reg, val);\n}\n\nstatic void max310x_port_update(struct uart_port *port, u8 reg, u8 mask, u8 val)\n{\n\tstruct max310x_one *one = to_max310x_port(port);\n\n\tregmap_update_bits(one->regmap, reg, mask, val);\n}\n\nstatic int max3107_detect(struct device *dev)\n{\n\tstruct max310x_port *s = dev_get_drvdata(dev);\n\tunsigned int val = 0;\n\tint ret;\n\n\tret = regmap_read(s->regmap, MAX310X_REVID_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (((val & MAX310x_REV_MASK) != MAX3107_REV_ID)) {\n\t\tdev_err(dev,\n\t\t\t\"%s ID 0x%02x does not match\\n\", s->devtype->name, val);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int max3108_detect(struct device *dev)\n{\n\tstruct max310x_port *s = dev_get_drvdata(dev);\n\tunsigned int val = 0;\n\tint ret;\n\n\t \n\tret = regmap_read(s->regmap, MAX310X_CLKSRC_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != (MAX310X_CLKSRC_EXTCLK_BIT | MAX310X_CLKSRC_PLLBYP_BIT)) {\n\t\tdev_err(dev, \"%s not present\\n\", s->devtype->name);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int max3109_detect(struct device *dev)\n{\n\tstruct max310x_port *s = dev_get_drvdata(dev);\n\tunsigned int val = 0;\n\tint ret;\n\n\tret = s->if_cfg->extended_reg_enable(dev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_read(s->regmap, s->if_cfg->rev_id_reg, &val);\n\ts->if_cfg->extended_reg_enable(dev, false);\n\tif (((val & MAX310x_REV_MASK) != MAX3109_REV_ID)) {\n\t\tdev_err(dev,\n\t\t\t\"%s ID 0x%02x does not match\\n\", s->devtype->name, val);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void max310x_power(struct uart_port *port, int on)\n{\n\tmax310x_port_update(port, MAX310X_MODE1_REG,\n\t\t\t    MAX310X_MODE1_FORCESLEEP_BIT,\n\t\t\t    on ? 0 : MAX310X_MODE1_FORCESLEEP_BIT);\n\tif (on)\n\t\tmsleep(50);\n}\n\nstatic int max14830_detect(struct device *dev)\n{\n\tstruct max310x_port *s = dev_get_drvdata(dev);\n\tunsigned int val = 0;\n\tint ret;\n\n\tret = s->if_cfg->extended_reg_enable(dev, true);\n\tif (ret)\n\t\treturn ret;\n\t\n\tregmap_read(s->regmap, s->if_cfg->rev_id_reg, &val);\n\ts->if_cfg->extended_reg_enable(dev, false);\n\tif (((val & MAX310x_REV_MASK) != MAX14830_REV_ID)) {\n\t\tdev_err(dev,\n\t\t\t\"%s ID 0x%02x does not match\\n\", s->devtype->name, val);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void max14830_power(struct uart_port *port, int on)\n{\n\tmax310x_port_update(port, MAX310X_BRGCFG_REG,\n\t\t\t    MAX14830_BRGCFG_CLKDIS_BIT,\n\t\t\t    on ? 0 : MAX14830_BRGCFG_CLKDIS_BIT);\n\tif (on)\n\t\tmsleep(50);\n}\n\nstatic const struct max310x_devtype max3107_devtype = {\n\t.name\t= \"MAX3107\",\n\t.nr\t= 1,\n\t.mode1\t= MAX310X_MODE1_AUTOSLEEP_BIT | MAX310X_MODE1_IRQSEL_BIT,\n\t.detect\t= max3107_detect,\n\t.power\t= max310x_power,\n\t.slave_addr\t= {\n\t\t.min = 0x2c,\n\t\t.max = 0x2f,\n\t},\n};\n\nstatic const struct max310x_devtype max3108_devtype = {\n\t.name\t= \"MAX3108\",\n\t.nr\t= 1,\n\t.mode1\t= MAX310X_MODE1_AUTOSLEEP_BIT,\n\t.detect\t= max3108_detect,\n\t.power\t= max310x_power,\n\t.slave_addr\t= {\n\t\t.min = 0x60,\n\t\t.max = 0x6f,\n\t},\n};\n\nstatic const struct max310x_devtype max3109_devtype = {\n\t.name\t= \"MAX3109\",\n\t.nr\t= 2,\n\t.mode1\t= MAX310X_MODE1_AUTOSLEEP_BIT,\n\t.detect\t= max3109_detect,\n\t.power\t= max310x_power,\n\t.slave_addr\t= {\n\t\t.min = 0x60,\n\t\t.max = 0x6f,\n\t},\n};\n\nstatic const struct max310x_devtype max14830_devtype = {\n\t.name\t= \"MAX14830\",\n\t.nr\t= 4,\n\t.mode1\t= MAX310X_MODE1_IRQSEL_BIT,\n\t.detect\t= max14830_detect,\n\t.power\t= max14830_power,\n\t.slave_addr\t= {\n\t\t.min = 0x60,\n\t\t.max = 0x6f,\n\t},\n};\n\nstatic bool max310x_reg_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX310X_IRQSTS_REG:\n\tcase MAX310X_LSR_IRQSTS_REG:\n\tcase MAX310X_SPCHR_IRQSTS_REG:\n\tcase MAX310X_STS_IRQSTS_REG:\n\tcase MAX310X_TXFIFOLVL_REG:\n\tcase MAX310X_RXFIFOLVL_REG:\n\t\treturn false;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic bool max310x_reg_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX310X_RHR_REG:\n\tcase MAX310X_IRQSTS_REG:\n\tcase MAX310X_LSR_IRQSTS_REG:\n\tcase MAX310X_SPCHR_IRQSTS_REG:\n\tcase MAX310X_STS_IRQSTS_REG:\n\tcase MAX310X_TXFIFOLVL_REG:\n\tcase MAX310X_RXFIFOLVL_REG:\n\tcase MAX310X_GPIODATA_REG:\n\tcase MAX310X_BRGDIVLSB_REG:\n\tcase MAX310X_REG_05:\n\tcase MAX310X_REG_1F:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool max310x_reg_precious(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX310X_RHR_REG:\n\tcase MAX310X_IRQSTS_REG:\n\tcase MAX310X_SPCHR_IRQSTS_REG:\n\tcase MAX310X_STS_IRQSTS_REG:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool max310x_reg_noinc(struct device *dev, unsigned int reg)\n{\n\treturn reg == MAX310X_RHR_REG;\n}\n\nstatic int max310x_set_baud(struct uart_port *port, int baud)\n{\n\tunsigned int mode = 0, div = 0, frac = 0, c = 0, F = 0;\n\n\t \n\tdiv = port->uartclk / baud;\n\tif (div < 8) {\n\t\t \n\t\tc = 4;\n\t\tmode = MAX310X_BRGCFG_4XMODE_BIT;\n\t} else if (div < 16) {\n\t\t \n\t\tc = 8;\n\t\tmode = MAX310X_BRGCFG_2XMODE_BIT;\n\t} else {\n\t\tc = 16;\n\t}\n\n\t \n\tdiv /= c;\n\tF = c*baud;\n\n\t \n\tif (div > 0)\n\t\tfrac = (16*(port->uartclk % F)) / F;\n\telse\n\t\tdiv = 1;\n\n\tmax310x_port_write(port, MAX310X_BRGDIVMSB_REG, div >> 8);\n\tmax310x_port_write(port, MAX310X_BRGDIVLSB_REG, div);\n\tmax310x_port_write(port, MAX310X_BRGCFG_REG, frac | mode);\n\n\t \n\treturn (16*port->uartclk) / (c*(16*div + frac));\n}\n\nstatic int max310x_update_best_err(unsigned long f, long *besterr)\n{\n\t \n\tlong err = f % (460800 * 16);\n\n\tif ((*besterr < 0) || (*besterr > err)) {\n\t\t*besterr = err;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic u32 max310x_set_ref_clk(struct device *dev, struct max310x_port *s,\n\t\t\t       unsigned long freq, bool xtal)\n{\n\tunsigned int div, clksrc, pllcfg = 0;\n\tlong besterr = -1;\n\tunsigned long fdiv, fmul, bestfreq = freq;\n\n\t \n\tmax310x_update_best_err(freq, &besterr);\n\n\t \n\tfor (div = 1; (div <= 63) && besterr; div++) {\n\t\tfdiv = DIV_ROUND_CLOSEST(freq, div);\n\n\t\t \n\t\tfmul = fdiv * 6;\n\t\tif ((fdiv >= 500000) && (fdiv <= 800000))\n\t\t\tif (!max310x_update_best_err(fmul, &besterr)) {\n\t\t\t\tpllcfg = (0 << 6) | div;\n\t\t\t\tbestfreq = fmul;\n\t\t\t}\n\t\t \n\t\tfmul = fdiv * 48;\n\t\tif ((fdiv >= 850000) && (fdiv <= 1200000))\n\t\t\tif (!max310x_update_best_err(fmul, &besterr)) {\n\t\t\t\tpllcfg = (1 << 6) | div;\n\t\t\t\tbestfreq = fmul;\n\t\t\t}\n\t\t \n\t\tfmul = fdiv * 96;\n\t\tif ((fdiv >= 425000) && (fdiv <= 1000000))\n\t\t\tif (!max310x_update_best_err(fmul, &besterr)) {\n\t\t\t\tpllcfg = (2 << 6) | div;\n\t\t\t\tbestfreq = fmul;\n\t\t\t}\n\t\t \n\t\tfmul = fdiv * 144;\n\t\tif ((fdiv >= 390000) && (fdiv <= 667000))\n\t\t\tif (!max310x_update_best_err(fmul, &besterr)) {\n\t\t\t\tpllcfg = (3 << 6) | div;\n\t\t\t\tbestfreq = fmul;\n\t\t\t}\n\t}\n\n\t \n\tclksrc = MAX310X_CLKSRC_EXTCLK_BIT | (xtal ? MAX310X_CLKSRC_CRYST_BIT : 0);\n\n\t \n\tif (pllcfg) {\n\t\tclksrc |= MAX310X_CLKSRC_PLL_BIT;\n\t\tregmap_write(s->regmap, MAX310X_PLLCFG_REG, pllcfg);\n\t} else\n\t\tclksrc |= MAX310X_CLKSRC_PLLBYP_BIT;\n\n\tregmap_write(s->regmap, MAX310X_CLKSRC_REG, clksrc);\n\n\t \n\tif (xtal) {\n\t\tunsigned int val;\n\t\tmsleep(10);\n\t\tregmap_read(s->regmap, MAX310X_STS_IRQSTS_REG, &val);\n\t\tif (!(val & MAX310X_STS_CLKREADY_BIT)) {\n\t\t\tdev_warn(dev, \"clock is not stable yet\\n\");\n\t\t}\n\t}\n\n\treturn bestfreq;\n}\n\nstatic void max310x_batch_write(struct uart_port *port, u8 *txbuf, unsigned int len)\n{\n\tstruct max310x_one *one = to_max310x_port(port);\n\n\tregmap_noinc_write(one->regmap, MAX310X_THR_REG, txbuf, len);\n}\n\nstatic void max310x_batch_read(struct uart_port *port, u8 *rxbuf, unsigned int len)\n{\n\tstruct max310x_one *one = to_max310x_port(port);\n\n\tregmap_noinc_read(one->regmap, MAX310X_RHR_REG, rxbuf, len);\n}\n\nstatic void max310x_handle_rx(struct uart_port *port, unsigned int rxlen)\n{\n\tstruct max310x_one *one = to_max310x_port(port);\n\tunsigned int sts, i;\n\tu8 ch, flag;\n\n\tif (port->read_status_mask == MAX310X_LSR_RXOVR_BIT) {\n\t\t \n\n\t\tsts = max310x_port_read(port, MAX310X_LSR_IRQSTS_REG);\n\t\tmax310x_batch_read(port, one->rx_buf, rxlen);\n\n\t\tport->icount.rx += rxlen;\n\t\tflag = TTY_NORMAL;\n\t\tsts &= port->read_status_mask;\n\n\t\tif (sts & MAX310X_LSR_RXOVR_BIT) {\n\t\t\tdev_warn_ratelimited(port->dev, \"Hardware RX FIFO overrun\\n\");\n\t\t\tport->icount.overrun++;\n\t\t}\n\n\t\tfor (i = 0; i < (rxlen - 1); ++i)\n\t\t\tuart_insert_char(port, sts, 0, one->rx_buf[i], flag);\n\n\t\t \n\t\tuart_insert_char(port, sts, MAX310X_LSR_RXOVR_BIT,\n\t\t\t\t one->rx_buf[rxlen-1], flag);\n\n\t} else {\n\t\tif (unlikely(rxlen >= port->fifosize)) {\n\t\t\tdev_warn_ratelimited(port->dev, \"Possible RX FIFO overrun\\n\");\n\t\t\tport->icount.buf_overrun++;\n\t\t\t \n\t\t\trxlen = port->fifosize;\n\t\t}\n\n\t\twhile (rxlen--) {\n\t\t\tch = max310x_port_read(port, MAX310X_RHR_REG);\n\t\t\tsts = max310x_port_read(port, MAX310X_LSR_IRQSTS_REG);\n\n\t\t\tsts &= MAX310X_LSR_RXPAR_BIT | MAX310X_LSR_FRERR_BIT |\n\t\t\t       MAX310X_LSR_RXOVR_BIT | MAX310X_LSR_RXBRK_BIT;\n\n\t\t\tport->icount.rx++;\n\t\t\tflag = TTY_NORMAL;\n\n\t\t\tif (unlikely(sts)) {\n\t\t\t\tif (sts & MAX310X_LSR_RXBRK_BIT) {\n\t\t\t\t\tport->icount.brk++;\n\t\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (sts & MAX310X_LSR_RXPAR_BIT)\n\t\t\t\t\tport->icount.parity++;\n\t\t\t\telse if (sts & MAX310X_LSR_FRERR_BIT)\n\t\t\t\t\tport->icount.frame++;\n\t\t\t\telse if (sts & MAX310X_LSR_RXOVR_BIT)\n\t\t\t\t\tport->icount.overrun++;\n\n\t\t\t\tsts &= port->read_status_mask;\n\t\t\t\tif (sts & MAX310X_LSR_RXBRK_BIT)\n\t\t\t\t\tflag = TTY_BREAK;\n\t\t\t\telse if (sts & MAX310X_LSR_RXPAR_BIT)\n\t\t\t\t\tflag = TTY_PARITY;\n\t\t\t\telse if (sts & MAX310X_LSR_FRERR_BIT)\n\t\t\t\t\tflag = TTY_FRAME;\n\t\t\t\telse if (sts & MAX310X_LSR_RXOVR_BIT)\n\t\t\t\t\tflag = TTY_OVERRUN;\n\t\t\t}\n\n\t\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\t\tcontinue;\n\n\t\t\tif (sts & port->ignore_status_mask)\n\t\t\t\tcontinue;\n\n\t\t\tuart_insert_char(port, sts, MAX310X_LSR_RXOVR_BIT, ch, flag);\n\t\t}\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic void max310x_handle_tx(struct uart_port *port)\n{\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned int txlen, to_send, until_end;\n\n\tif (unlikely(port->x_char)) {\n\t\tmax310x_port_write(port, MAX310X_THR_REG, port->x_char);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port))\n\t\treturn;\n\n\t \n\tto_send = uart_circ_chars_pending(xmit);\n\tuntil_end = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\tif (likely(to_send)) {\n\t\t \n\t\ttxlen = max310x_port_read(port, MAX310X_TXFIFOLVL_REG);\n\t\ttxlen = port->fifosize - txlen;\n\t\tto_send = (to_send > txlen) ? txlen : to_send;\n\n\t\tif (until_end < to_send) {\n\t\t\t \n\t\t\tmax310x_batch_write(port, xmit->buf + xmit->tail, until_end);\n\t\t\tmax310x_batch_write(port, xmit->buf, to_send - until_end);\n\t\t} else {\n\t\t\tmax310x_batch_write(port, xmit->buf + xmit->tail, to_send);\n\t\t}\n\t\tuart_xmit_advance(port, to_send);\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n}\n\nstatic void max310x_start_tx(struct uart_port *port)\n{\n\tstruct max310x_one *one = to_max310x_port(port);\n\n\tschedule_work(&one->tx_work);\n}\n\nstatic irqreturn_t max310x_port_irq(struct max310x_port *s, int portno)\n{\n\tstruct uart_port *port = &s->p[portno].port;\n\tirqreturn_t res = IRQ_NONE;\n\n\tdo {\n\t\tunsigned int ists, lsr, rxlen;\n\n\t\t \n\t\tists = max310x_port_read(port, MAX310X_IRQSTS_REG);\n\t\trxlen = max310x_port_read(port, MAX310X_RXFIFOLVL_REG);\n\t\tif (!ists && !rxlen)\n\t\t\tbreak;\n\n\t\tres = IRQ_HANDLED;\n\n\t\tif (ists & MAX310X_IRQ_CTS_BIT) {\n\t\t\tlsr = max310x_port_read(port, MAX310X_LSR_IRQSTS_REG);\n\t\t\tuart_handle_cts_change(port, lsr & MAX310X_LSR_CTS_BIT);\n\t\t}\n\t\tif (rxlen)\n\t\t\tmax310x_handle_rx(port, rxlen);\n\t\tif (ists & MAX310X_IRQ_TXEMPTY_BIT)\n\t\t\tmax310x_start_tx(port);\n\t} while (1);\n\treturn res;\n}\n\nstatic irqreturn_t max310x_ist(int irq, void *dev_id)\n{\n\tstruct max310x_port *s = (struct max310x_port *)dev_id;\n\tbool handled = false;\n\n\tif (s->devtype->nr > 1) {\n\t\tdo {\n\t\t\tunsigned int val = ~0;\n\n\t\t\tWARN_ON_ONCE(regmap_read(s->regmap,\n\t\t\t\t\t\t MAX310X_GLOBALIRQ_REG, &val));\n\t\t\tval = ((1 << s->devtype->nr) - 1) & ~val;\n\t\t\tif (!val)\n\t\t\t\tbreak;\n\t\t\tif (max310x_port_irq(s, fls(val) - 1) == IRQ_HANDLED)\n\t\t\t\thandled = true;\n\t\t} while (1);\n\t} else {\n\t\tif (max310x_port_irq(s, 0) == IRQ_HANDLED)\n\t\t\thandled = true;\n\t}\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void max310x_tx_proc(struct work_struct *ws)\n{\n\tstruct max310x_one *one = container_of(ws, struct max310x_one, tx_work);\n\n\tmax310x_handle_tx(&one->port);\n}\n\nstatic unsigned int max310x_tx_empty(struct uart_port *port)\n{\n\tu8 lvl = max310x_port_read(port, MAX310X_TXFIFOLVL_REG);\n\n\treturn lvl ? 0 : TIOCSER_TEMT;\n}\n\nstatic unsigned int max310x_get_mctrl(struct uart_port *port)\n{\n\t \n\treturn TIOCM_DSR | TIOCM_CAR;\n}\n\nstatic void max310x_md_proc(struct work_struct *ws)\n{\n\tstruct max310x_one *one = container_of(ws, struct max310x_one, md_work);\n\n\tmax310x_port_update(&one->port, MAX310X_MODE2_REG,\n\t\t\t    MAX310X_MODE2_LOOPBACK_BIT,\n\t\t\t    (one->port.mctrl & TIOCM_LOOP) ?\n\t\t\t    MAX310X_MODE2_LOOPBACK_BIT : 0);\n}\n\nstatic void max310x_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct max310x_one *one = to_max310x_port(port);\n\n\tschedule_work(&one->md_work);\n}\n\nstatic void max310x_break_ctl(struct uart_port *port, int break_state)\n{\n\tmax310x_port_update(port, MAX310X_LCR_REG,\n\t\t\t    MAX310X_LCR_TXBREAK_BIT,\n\t\t\t    break_state ? MAX310X_LCR_TXBREAK_BIT : 0);\n}\n\nstatic void max310x_set_termios(struct uart_port *port,\n\t\t\t\tstruct ktermios *termios,\n\t\t\t\tconst struct ktermios *old)\n{\n\tunsigned int lcr = 0, flow = 0;\n\tint baud;\n\n\t \n\ttermios->c_cflag &= ~CMSPAR;\n\n\t \n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tbreak;\n\tcase CS6:\n\t\tlcr = MAX310X_LCR_LENGTH0_BIT;\n\t\tbreak;\n\tcase CS7:\n\t\tlcr = MAX310X_LCR_LENGTH1_BIT;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tlcr = MAX310X_LCR_LENGTH1_BIT | MAX310X_LCR_LENGTH0_BIT;\n\t\tbreak;\n\t}\n\n\t \n\tif (termios->c_cflag & PARENB) {\n\t\tlcr |= MAX310X_LCR_PARITY_BIT;\n\t\tif (!(termios->c_cflag & PARODD))\n\t\t\tlcr |= MAX310X_LCR_EVENPARITY_BIT;\n\t}\n\n\t \n\tif (termios->c_cflag & CSTOPB)\n\t\tlcr |= MAX310X_LCR_STOPLEN_BIT;  \n\n\t \n\tmax310x_port_write(port, MAX310X_LCR_REG, lcr);\n\n\t \n\tport->read_status_mask = MAX310X_LSR_RXOVR_BIT;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= MAX310X_LSR_RXPAR_BIT |\n\t\t\t\t\t  MAX310X_LSR_FRERR_BIT;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tport->read_status_mask |= MAX310X_LSR_RXBRK_BIT;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNBRK)\n\t\tport->ignore_status_mask |= MAX310X_LSR_RXBRK_BIT;\n\tif (!(termios->c_cflag & CREAD))\n\t\tport->ignore_status_mask |= MAX310X_LSR_RXPAR_BIT |\n\t\t\t\t\t    MAX310X_LSR_RXOVR_BIT |\n\t\t\t\t\t    MAX310X_LSR_FRERR_BIT |\n\t\t\t\t\t    MAX310X_LSR_RXBRK_BIT;\n\n\t \n\tmax310x_port_write(port, MAX310X_XON1_REG, termios->c_cc[VSTART]);\n\tmax310x_port_write(port, MAX310X_XOFF1_REG, termios->c_cc[VSTOP]);\n\n\t \n\tif (termios->c_cflag & CRTSCTS || termios->c_iflag & IXOFF) {\n\t\tmax310x_port_update(port, MAX310X_MODE1_REG,\n\t\t\t\t    MAX310X_MODE1_TXDIS_BIT,\n\t\t\t\t    MAX310X_MODE1_TXDIS_BIT);\n\t}\n\n\tport->status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS | UPSTAT_AUTOXOFF);\n\n\tif (termios->c_cflag & CRTSCTS) {\n\t\t \n\t\tport->status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;\n\t\tflow |= MAX310X_FLOWCTRL_AUTOCTS_BIT |\n\t\t\tMAX310X_FLOWCTRL_AUTORTS_BIT;\n\t}\n\tif (termios->c_iflag & IXON)\n\t\tflow |= MAX310X_FLOWCTRL_SWFLOW3_BIT |\n\t\t\tMAX310X_FLOWCTRL_SWFLOWEN_BIT;\n\tif (termios->c_iflag & IXOFF) {\n\t\tport->status |= UPSTAT_AUTOXOFF;\n\t\tflow |= MAX310X_FLOWCTRL_SWFLOW1_BIT |\n\t\t\tMAX310X_FLOWCTRL_SWFLOWEN_BIT;\n\t}\n\tmax310x_port_write(port, MAX310X_FLOWCTRL_REG, flow);\n\n\t \n\tif (!(termios->c_cflag & CRTSCTS) && !(termios->c_iflag & IXOFF)) {\n\t\tmax310x_port_update(port, MAX310X_MODE1_REG,\n\t\t\t\t    MAX310X_MODE1_TXDIS_BIT,\n\t\t\t\t    0);\n\t}\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old,\n\t\t\t\t  port->uartclk / 16 / 0xffff,\n\t\t\t\t  port->uartclk / 4);\n\n\t \n\tbaud = max310x_set_baud(port, baud);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n}\n\nstatic void max310x_rs_proc(struct work_struct *ws)\n{\n\tstruct max310x_one *one = container_of(ws, struct max310x_one, rs_work);\n\tunsigned int delay, mode1 = 0, mode2 = 0;\n\n\tdelay = (one->port.rs485.delay_rts_before_send << 4) |\n\t\tone->port.rs485.delay_rts_after_send;\n\tmax310x_port_write(&one->port, MAX310X_HDPIXDELAY_REG, delay);\n\n\tif (one->port.rs485.flags & SER_RS485_ENABLED) {\n\t\tmode1 = MAX310X_MODE1_TRNSCVCTRL_BIT;\n\n\t\tif (!(one->port.rs485.flags & SER_RS485_RX_DURING_TX))\n\t\t\tmode2 = MAX310X_MODE2_ECHOSUPR_BIT;\n\t}\n\n\tmax310x_port_update(&one->port, MAX310X_MODE1_REG,\n\t\t\tMAX310X_MODE1_TRNSCVCTRL_BIT, mode1);\n\tmax310x_port_update(&one->port, MAX310X_MODE2_REG,\n\t\t\tMAX310X_MODE2_ECHOSUPR_BIT, mode2);\n}\n\nstatic int max310x_rs485_config(struct uart_port *port, struct ktermios *termios,\n\t\t\t\tstruct serial_rs485 *rs485)\n{\n\tstruct max310x_one *one = to_max310x_port(port);\n\n\tif ((rs485->delay_rts_before_send > 0x0f) ||\n\t    (rs485->delay_rts_after_send > 0x0f))\n\t\treturn -ERANGE;\n\n\tport->rs485 = *rs485;\n\n\tschedule_work(&one->rs_work);\n\n\treturn 0;\n}\n\nstatic int max310x_startup(struct uart_port *port)\n{\n\tstruct max310x_port *s = dev_get_drvdata(port->dev);\n\tunsigned int val;\n\n\ts->devtype->power(port, 1);\n\n\t \n\tmax310x_port_update(port, MAX310X_MODE1_REG,\n\t\t\t    MAX310X_MODE1_TRNSCVCTRL_BIT, 0);\n\n\t \n\tval = MAX310X_MODE2_RXEMPTINV_BIT | MAX310X_MODE2_FIFORST_BIT;\n\tmax310x_port_write(port, MAX310X_MODE2_REG, val);\n\tmax310x_port_update(port, MAX310X_MODE2_REG,\n\t\t\t    MAX310X_MODE2_FIFORST_BIT, 0);\n\n\t \n\tval = (clamp(port->rs485.delay_rts_before_send, 0U, 15U) << 4) |\n\t\tclamp(port->rs485.delay_rts_after_send, 0U, 15U);\n\tmax310x_port_write(port, MAX310X_HDPIXDELAY_REG, val);\n\n\tif (port->rs485.flags & SER_RS485_ENABLED) {\n\t\tmax310x_port_update(port, MAX310X_MODE1_REG,\n\t\t\t\t    MAX310X_MODE1_TRNSCVCTRL_BIT,\n\t\t\t\t    MAX310X_MODE1_TRNSCVCTRL_BIT);\n\n\t\tif (!(port->rs485.flags & SER_RS485_RX_DURING_TX))\n\t\t\tmax310x_port_update(port, MAX310X_MODE2_REG,\n\t\t\t\t\t    MAX310X_MODE2_ECHOSUPR_BIT,\n\t\t\t\t\t    MAX310X_MODE2_ECHOSUPR_BIT);\n\t}\n\n\t \n\t \n\tmax310x_port_write(port, MAX310X_FLOWLVL_REG,\n\t\t\t   MAX310X_FLOWLVL_RES(48) | MAX310X_FLOWLVL_HALT(96));\n\n\t \n\tmax310x_port_read(port, MAX310X_IRQSTS_REG);\n\n\t \n\tval = MAX310X_IRQ_RXEMPTY_BIT | MAX310X_IRQ_TXEMPTY_BIT;\n\tmax310x_port_write(port, MAX310X_IRQEN_REG, val | MAX310X_IRQ_CTS_BIT);\n\n\treturn 0;\n}\n\nstatic void max310x_shutdown(struct uart_port *port)\n{\n\tstruct max310x_port *s = dev_get_drvdata(port->dev);\n\n\t \n\tmax310x_port_write(port, MAX310X_IRQEN_REG, 0);\n\n\ts->devtype->power(port, 0);\n}\n\nstatic const char *max310x_type(struct uart_port *port)\n{\n\tstruct max310x_port *s = dev_get_drvdata(port->dev);\n\n\treturn (port->type == PORT_MAX310X) ? s->devtype->name : NULL;\n}\n\nstatic int max310x_request_port(struct uart_port *port)\n{\n\t \n\treturn 0;\n}\n\nstatic void max310x_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_MAX310X;\n}\n\nstatic int max310x_verify_port(struct uart_port *port, struct serial_struct *s)\n{\n\tif ((s->type != PORT_UNKNOWN) && (s->type != PORT_MAX310X))\n\t\treturn -EINVAL;\n\tif (s->irq != port->irq)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void max310x_null_void(struct uart_port *port)\n{\n\t \n}\n\nstatic const struct uart_ops max310x_ops = {\n\t.tx_empty\t= max310x_tx_empty,\n\t.set_mctrl\t= max310x_set_mctrl,\n\t.get_mctrl\t= max310x_get_mctrl,\n\t.stop_tx\t= max310x_null_void,\n\t.start_tx\t= max310x_start_tx,\n\t.stop_rx\t= max310x_null_void,\n\t.break_ctl\t= max310x_break_ctl,\n\t.startup\t= max310x_startup,\n\t.shutdown\t= max310x_shutdown,\n\t.set_termios\t= max310x_set_termios,\n\t.type\t\t= max310x_type,\n\t.request_port\t= max310x_request_port,\n\t.release_port\t= max310x_null_void,\n\t.config_port\t= max310x_config_port,\n\t.verify_port\t= max310x_verify_port,\n};\n\nstatic int __maybe_unused max310x_suspend(struct device *dev)\n{\n\tstruct max310x_port *s = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < s->devtype->nr; i++) {\n\t\tuart_suspend_port(&max310x_uart, &s->p[i].port);\n\t\ts->devtype->power(&s->p[i].port, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused max310x_resume(struct device *dev)\n{\n\tstruct max310x_port *s = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < s->devtype->nr; i++) {\n\t\ts->devtype->power(&s->p[i].port, 1);\n\t\tuart_resume_port(&max310x_uart, &s->p[i].port);\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(max310x_pm_ops, max310x_suspend, max310x_resume);\n\n#ifdef CONFIG_GPIOLIB\nstatic int max310x_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tunsigned int val;\n\tstruct max310x_port *s = gpiochip_get_data(chip);\n\tstruct uart_port *port = &s->p[offset / 4].port;\n\n\tval = max310x_port_read(port, MAX310X_GPIODATA_REG);\n\n\treturn !!((val >> 4) & (1 << (offset % 4)));\n}\n\nstatic void max310x_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct max310x_port *s = gpiochip_get_data(chip);\n\tstruct uart_port *port = &s->p[offset / 4].port;\n\n\tmax310x_port_update(port, MAX310X_GPIODATA_REG, 1 << (offset % 4),\n\t\t\t    value ? 1 << (offset % 4) : 0);\n}\n\nstatic int max310x_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct max310x_port *s = gpiochip_get_data(chip);\n\tstruct uart_port *port = &s->p[offset / 4].port;\n\n\tmax310x_port_update(port, MAX310X_GPIOCFG_REG, 1 << (offset % 4), 0);\n\n\treturn 0;\n}\n\nstatic int max310x_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t unsigned offset, int value)\n{\n\tstruct max310x_port *s = gpiochip_get_data(chip);\n\tstruct uart_port *port = &s->p[offset / 4].port;\n\n\tmax310x_port_update(port, MAX310X_GPIODATA_REG, 1 << (offset % 4),\n\t\t\t    value ? 1 << (offset % 4) : 0);\n\tmax310x_port_update(port, MAX310X_GPIOCFG_REG, 1 << (offset % 4),\n\t\t\t    1 << (offset % 4));\n\n\treturn 0;\n}\n\nstatic int max310x_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t   unsigned long config)\n{\n\tstruct max310x_port *s = gpiochip_get_data(chip);\n\tstruct uart_port *port = &s->p[offset / 4].port;\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tmax310x_port_update(port, MAX310X_GPIOCFG_REG,\n\t\t\t\t1 << ((offset % 4) + 4),\n\t\t\t\t1 << ((offset % 4) + 4));\n\t\treturn 0;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tmax310x_port_update(port, MAX310X_GPIOCFG_REG,\n\t\t\t\t1 << ((offset % 4) + 4), 0);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n#endif\n\nstatic const struct serial_rs485 max310x_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | SER_RS485_RX_DURING_TX,\n\t.delay_rts_before_send = 1,\n\t.delay_rts_after_send = 1,\n};\n\nstatic int max310x_probe(struct device *dev, const struct max310x_devtype *devtype,\n\t\t\t const struct max310x_if_cfg *if_cfg,\n\t\t\t struct regmap *regmaps[], int irq)\n{\n\tint i, ret, fmin, fmax, freq;\n\tstruct max310x_port *s;\n\tu32 uartclk = 0;\n\tbool xtal;\n\n\tfor (i = 0; i < devtype->nr; i++)\n\t\tif (IS_ERR(regmaps[i]))\n\t\t\treturn PTR_ERR(regmaps[i]);\n\n\t \n\ts = devm_kzalloc(dev, struct_size(s, p, devtype->nr), GFP_KERNEL);\n\tif (!s) {\n\t\tdev_err(dev, \"Error allocating port structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdevice_property_read_u32(dev, \"clock-frequency\", &uartclk);\n\n\txtal = device_property_match_string(dev, \"clock-names\", \"osc\") < 0;\n\tif (xtal)\n\t\ts->clk = devm_clk_get_optional(dev, \"xtal\");\n\telse\n\t\ts->clk = devm_clk_get_optional(dev, \"osc\");\n\tif (IS_ERR(s->clk))\n\t\treturn PTR_ERR(s->clk);\n\n\tret = clk_prepare_enable(s->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tfreq = clk_get_rate(s->clk);\n\tif (freq == 0)\n\t\tfreq = uartclk;\n\tif (freq == 0) {\n\t\tdev_err(dev, \"Cannot get clock rate\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_clk;\n\t}\n\n\tif (xtal) {\n\t\tfmin = 1000000;\n\t\tfmax = 4000000;\n\t} else {\n\t\tfmin = 500000;\n\t\tfmax = 35000000;\n\t}\n\n\t \n\tif (freq < fmin || freq > fmax) {\n\t\tret = -ERANGE;\n\t\tgoto out_clk;\n\t}\n\n\ts->regmap = regmaps[0];\n\ts->devtype = devtype;\n\ts->if_cfg = if_cfg;\n\tdev_set_drvdata(dev, s);\n\n\t \n\tret = devtype->detect(dev);\n\tif (ret)\n\t\tgoto out_clk;\n\n\tfor (i = 0; i < devtype->nr; i++) {\n\t\t \n\t\tregmap_write(regmaps[i], MAX310X_MODE2_REG,\n\t\t\t     MAX310X_MODE2_RST_BIT);\n\t\t \n\t\tregmap_write(regmaps[i], MAX310X_MODE2_REG, 0);\n\n\t\t \n\t\tdo {\n\t\t\tregmap_read(regmaps[i], MAX310X_BRGDIVLSB_REG, &ret);\n\t\t} while (ret != 0x01);\n\n\t\tregmap_write(regmaps[i], MAX310X_MODE1_REG, devtype->mode1);\n\t}\n\n\tuartclk = max310x_set_ref_clk(dev, s, freq, xtal);\n\tdev_dbg(dev, \"Reference clock set to %i Hz\\n\", uartclk);\n\n\tfor (i = 0; i < devtype->nr; i++) {\n\t\tunsigned int line;\n\n\t\tline = find_first_zero_bit(max310x_lines, MAX310X_UART_NRMAX);\n\t\tif (line == MAX310X_UART_NRMAX) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_uart;\n\t\t}\n\n\t\t \n\t\ts->p[i].port.line\t= line;\n\t\ts->p[i].port.dev\t= dev;\n\t\ts->p[i].port.irq\t= irq;\n\t\ts->p[i].port.type\t= PORT_MAX310X;\n\t\ts->p[i].port.fifosize\t= MAX310X_FIFO_SIZE;\n\t\ts->p[i].port.flags\t= UPF_FIXED_TYPE | UPF_LOW_LATENCY;\n\t\ts->p[i].port.iotype\t= UPIO_PORT;\n\t\ts->p[i].port.iobase\t= i;\n\t\t \n\t\ts->p[i].port.membase\t= (void __iomem *)~0;\n\t\ts->p[i].port.uartclk\t= uartclk;\n\t\ts->p[i].port.rs485_config = max310x_rs485_config;\n\t\ts->p[i].port.rs485_supported = max310x_rs485_supported;\n\t\ts->p[i].port.ops\t= &max310x_ops;\n\t\ts->p[i].regmap\t\t= regmaps[i];\n\n\t\t \n\t\tmax310x_port_write(&s->p[i].port, MAX310X_IRQEN_REG, 0);\n\t\t \n\t\tmax310x_port_read(&s->p[i].port, MAX310X_IRQSTS_REG);\n\t\t \n\t\tINIT_WORK(&s->p[i].tx_work, max310x_tx_proc);\n\t\t \n\t\tINIT_WORK(&s->p[i].md_work, max310x_md_proc);\n\t\t \n\t\tINIT_WORK(&s->p[i].rs_work, max310x_rs_proc);\n\n\t\t \n\t\tret = uart_add_one_port(&max310x_uart, &s->p[i].port);\n\t\tif (ret) {\n\t\t\ts->p[i].port.dev = NULL;\n\t\t\tgoto out_uart;\n\t\t}\n\t\tset_bit(line, max310x_lines);\n\n\t\t \n\t\tdevtype->power(&s->p[i].port, 0);\n\t}\n\n#ifdef CONFIG_GPIOLIB\n\t \n\ts->gpio.owner\t\t= THIS_MODULE;\n\ts->gpio.parent\t\t= dev;\n\ts->gpio.label\t\t= devtype->name;\n\ts->gpio.direction_input\t= max310x_gpio_direction_input;\n\ts->gpio.get\t\t= max310x_gpio_get;\n\ts->gpio.direction_output= max310x_gpio_direction_output;\n\ts->gpio.set\t\t= max310x_gpio_set;\n\ts->gpio.set_config\t= max310x_gpio_set_config;\n\ts->gpio.base\t\t= -1;\n\ts->gpio.ngpio\t\t= devtype->nr * 4;\n\ts->gpio.can_sleep\t= 1;\n\tret = devm_gpiochip_add_data(dev, &s->gpio, s);\n\tif (ret)\n\t\tgoto out_uart;\n#endif\n\n\t \n\tret = devm_request_threaded_irq(dev, irq, NULL, max310x_ist,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED, dev_name(dev), s);\n\tif (!ret)\n\t\treturn 0;\n\n\tdev_err(dev, \"Unable to reguest IRQ %i\\n\", irq);\n\nout_uart:\n\tfor (i = 0; i < devtype->nr; i++) {\n\t\tif (s->p[i].port.dev) {\n\t\t\tuart_remove_one_port(&max310x_uart, &s->p[i].port);\n\t\t\tclear_bit(s->p[i].port.line, max310x_lines);\n\t\t}\n\t}\n\nout_clk:\n\tclk_disable_unprepare(s->clk);\n\n\treturn ret;\n}\n\nstatic void max310x_remove(struct device *dev)\n{\n\tstruct max310x_port *s = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < s->devtype->nr; i++) {\n\t\tcancel_work_sync(&s->p[i].tx_work);\n\t\tcancel_work_sync(&s->p[i].md_work);\n\t\tcancel_work_sync(&s->p[i].rs_work);\n\t\tuart_remove_one_port(&max310x_uart, &s->p[i].port);\n\t\tclear_bit(s->p[i].port.line, max310x_lines);\n\t\ts->devtype->power(&s->p[i].port, 0);\n\t}\n\n\tclk_disable_unprepare(s->clk);\n}\n\nstatic const struct of_device_id __maybe_unused max310x_dt_ids[] = {\n\t{ .compatible = \"maxim,max3107\",\t.data = &max3107_devtype, },\n\t{ .compatible = \"maxim,max3108\",\t.data = &max3108_devtype, },\n\t{ .compatible = \"maxim,max3109\",\t.data = &max3109_devtype, },\n\t{ .compatible = \"maxim,max14830\",\t.data = &max14830_devtype },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max310x_dt_ids);\n\nstatic struct regmap_config regcfg = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.write_flag_mask = MAX310X_WRITE_BIT,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = MAX310X_REG_1F,\n\t.writeable_reg = max310x_reg_writeable,\n\t.volatile_reg = max310x_reg_volatile,\n\t.precious_reg = max310x_reg_precious,\n\t.writeable_noinc_reg = max310x_reg_noinc,\n\t.readable_noinc_reg = max310x_reg_noinc,\n\t.max_raw_read = MAX310X_FIFO_SIZE,\n\t.max_raw_write = MAX310X_FIFO_SIZE,\n};\n\n#ifdef CONFIG_SPI_MASTER\nstatic int max310x_spi_extended_reg_enable(struct device *dev, bool enable)\n{\n\tstruct max310x_port *s = dev_get_drvdata(dev);\n\n\treturn regmap_write(s->regmap, MAX310X_GLOBALCMD_REG,\n\t\t\t    enable ? MAX310X_EXTREG_ENBL : MAX310X_EXTREG_DSBL);\n}\n\nstatic const struct max310x_if_cfg __maybe_unused max310x_spi_if_cfg = {\n\t.extended_reg_enable = max310x_spi_extended_reg_enable,\n\t.rev_id_reg = MAX310X_SPI_REVID_EXTREG,\n};\n\nstatic int max310x_spi_probe(struct spi_device *spi)\n{\n\tconst struct max310x_devtype *devtype;\n\tstruct regmap *regmaps[4];\n\tunsigned int i;\n\tint ret;\n\n\t \n\tspi->bits_per_word\t= 8;\n\tspi->mode\t\t= spi->mode ? : SPI_MODE_0;\n\tspi->max_speed_hz\t= spi->max_speed_hz ? : 26000000;\n\tret = spi_setup(spi);\n\tif (ret)\n\t\treturn ret;\n\n\tdevtype = device_get_match_data(&spi->dev);\n\tif (!devtype)\n\t\tdevtype = (struct max310x_devtype *)spi_get_device_id(spi)->driver_data;\n\n\tfor (i = 0; i < devtype->nr; i++) {\n\t\tu8 port_mask = i * 0x20;\n\t\tregcfg.read_flag_mask = port_mask;\n\t\tregcfg.write_flag_mask = port_mask | MAX310X_WRITE_BIT;\n\t\tregmaps[i] = devm_regmap_init_spi(spi, &regcfg);\n\t}\n\n\treturn max310x_probe(&spi->dev, devtype, &max310x_spi_if_cfg, regmaps, spi->irq);\n}\n\nstatic void max310x_spi_remove(struct spi_device *spi)\n{\n\tmax310x_remove(&spi->dev);\n}\n\nstatic const struct spi_device_id max310x_id_table[] = {\n\t{ \"max3107\",\t(kernel_ulong_t)&max3107_devtype, },\n\t{ \"max3108\",\t(kernel_ulong_t)&max3108_devtype, },\n\t{ \"max3109\",\t(kernel_ulong_t)&max3109_devtype, },\n\t{ \"max14830\",\t(kernel_ulong_t)&max14830_devtype, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, max310x_id_table);\n\nstatic struct spi_driver max310x_spi_driver = {\n\t.driver = {\n\t\t.name\t\t= MAX310X_NAME,\n\t\t.of_match_table\t= max310x_dt_ids,\n\t\t.pm\t\t= &max310x_pm_ops,\n\t},\n\t.probe\t\t= max310x_spi_probe,\n\t.remove\t\t= max310x_spi_remove,\n\t.id_table\t= max310x_id_table,\n};\n#endif\n\n#ifdef CONFIG_I2C\nstatic int max310x_i2c_extended_reg_enable(struct device *dev, bool enable)\n{\n\treturn 0;\n}\n\nstatic struct regmap_config regcfg_i2c = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.writeable_reg = max310x_reg_writeable,\n\t.volatile_reg = max310x_reg_volatile,\n\t.precious_reg = max310x_reg_precious,\n\t.max_register = MAX310X_I2C_REVID_EXTREG,\n\t.writeable_noinc_reg = max310x_reg_noinc,\n\t.readable_noinc_reg = max310x_reg_noinc,\n\t.max_raw_read = MAX310X_FIFO_SIZE,\n\t.max_raw_write = MAX310X_FIFO_SIZE,\n};\n\nstatic const struct max310x_if_cfg max310x_i2c_if_cfg = {\n\t.extended_reg_enable = max310x_i2c_extended_reg_enable,\n\t.rev_id_reg = MAX310X_I2C_REVID_EXTREG,\n};\n\nstatic unsigned short max310x_i2c_slave_addr(unsigned short addr,\n\t\t\t\t\t     unsigned int nr)\n{\n\t \n\n\taddr -= nr * 0x10;\n\n\tif (nr >= 2)\n\t\taddr -= 0x20;\n\n\treturn addr;\n}\n\nstatic int max310x_i2c_probe(struct i2c_client *client)\n{\n\tconst struct max310x_devtype *devtype =\n\t\t\tdevice_get_match_data(&client->dev);\n\tstruct i2c_client *port_client;\n\tstruct regmap *regmaps[4];\n\tunsigned int i;\n\tu8 port_addr;\n\n\tif (client->addr < devtype->slave_addr.min ||\n\t\tclient->addr > devtype->slave_addr.max)\n\t\treturn dev_err_probe(&client->dev, -EINVAL,\n\t\t\t\t     \"Slave addr 0x%x outside of range [0x%x, 0x%x]\\n\",\n\t\t\t\t     client->addr, devtype->slave_addr.min,\n\t\t\t\t     devtype->slave_addr.max);\n\n\tregmaps[0] = devm_regmap_init_i2c(client, &regcfg_i2c);\n\n\tfor (i = 1; i < devtype->nr; i++) {\n\t\tport_addr = max310x_i2c_slave_addr(client->addr, i);\n\t\tport_client = devm_i2c_new_dummy_device(&client->dev,\n\t\t\t\t\t\t\tclient->adapter,\n\t\t\t\t\t\t\tport_addr);\n\n\t\tregmaps[i] = devm_regmap_init_i2c(port_client, &regcfg_i2c);\n\t}\n\n\treturn max310x_probe(&client->dev, devtype, &max310x_i2c_if_cfg,\n\t\t\t     regmaps, client->irq);\n}\n\nstatic void max310x_i2c_remove(struct i2c_client *client)\n{\n\tmax310x_remove(&client->dev);\n}\n\nstatic struct i2c_driver max310x_i2c_driver = {\n\t.driver = {\n\t\t.name\t\t= MAX310X_NAME,\n\t\t.of_match_table\t= max310x_dt_ids,\n\t\t.pm\t\t= &max310x_pm_ops,\n\t},\n\t.probe\t\t= max310x_i2c_probe,\n\t.remove\t\t= max310x_i2c_remove,\n};\n#endif\n\nstatic int __init max310x_uart_init(void)\n{\n\tint ret;\n\n\tbitmap_zero(max310x_lines, MAX310X_UART_NRMAX);\n\n\tret = uart_register_driver(&max310x_uart);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_SPI_MASTER\n\tret = spi_register_driver(&max310x_spi_driver);\n\tif (ret)\n\t\tgoto err_spi_register;\n#endif\n\n#ifdef CONFIG_I2C\n\tret = i2c_add_driver(&max310x_i2c_driver);\n\tif (ret)\n\t\tgoto err_i2c_register;\n#endif\n\n\treturn 0;\n\n#ifdef CONFIG_I2C\nerr_i2c_register:\n\tspi_unregister_driver(&max310x_spi_driver);\n#endif\n\nerr_spi_register:\n\tuart_unregister_driver(&max310x_uart);\n\n\treturn ret;\n}\nmodule_init(max310x_uart_init);\n\nstatic void __exit max310x_uart_exit(void)\n{\n#ifdef CONFIG_I2C\n\ti2c_del_driver(&max310x_i2c_driver);\n#endif\n\n#ifdef CONFIG_SPI_MASTER\n\tspi_unregister_driver(&max310x_spi_driver);\n#endif\n\n\tuart_unregister_driver(&max310x_uart);\n}\nmodule_exit(max310x_uart_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alexander Shiyan <shc_work@mail.ru>\");\nMODULE_DESCRIPTION(\"MAX310X serial driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}