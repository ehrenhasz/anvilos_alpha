{
  "module_name": "max3100.c",
  "hash_id": "da9beef2da59498e2dcbcfe6e242874976ca75732f1fb56d7b42189b350e4ace",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/max3100.c",
  "human_readable_source": "\n \n\n#define MAX3100_MAJOR 204\n#define MAX3100_MINOR 209\n \n#define MAX_MAX3100 4\n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/spi/spi.h>\n#include <linux/freezer.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#include <linux/serial_max3100.h>\n\n#define MAX3100_C    (1<<14)\n#define MAX3100_D    (0<<14)\n#define MAX3100_W    (1<<15)\n#define MAX3100_RX   (0<<15)\n\n#define MAX3100_WC   (MAX3100_W  | MAX3100_C)\n#define MAX3100_RC   (MAX3100_RX | MAX3100_C)\n#define MAX3100_WD   (MAX3100_W  | MAX3100_D)\n#define MAX3100_RD   (MAX3100_RX | MAX3100_D)\n#define MAX3100_CMD  (3 << 14)\n\n#define MAX3100_T    (1<<14)\n#define MAX3100_R    (1<<15)\n\n#define MAX3100_FEN  (1<<13)\n#define MAX3100_SHDN (1<<12)\n#define MAX3100_TM   (1<<11)\n#define MAX3100_RM   (1<<10)\n#define MAX3100_PM   (1<<9)\n#define MAX3100_RAM  (1<<8)\n#define MAX3100_IR   (1<<7)\n#define MAX3100_ST   (1<<6)\n#define MAX3100_PE   (1<<5)\n#define MAX3100_L    (1<<4)\n#define MAX3100_BAUD (0xf)\n\n#define MAX3100_TE   (1<<10)\n#define MAX3100_RAFE (1<<10)\n#define MAX3100_RTS  (1<<9)\n#define MAX3100_CTS  (1<<9)\n#define MAX3100_PT   (1<<8)\n#define MAX3100_DATA (0xff)\n\n#define MAX3100_RT   (MAX3100_R | MAX3100_T)\n#define MAX3100_RTC  (MAX3100_RT | MAX3100_CTS | MAX3100_RAFE)\n\n \n#define MAX3100_STATUS_PE 1\n#define MAX3100_STATUS_FE 2\n#define MAX3100_STATUS_OE 4\n\nstruct max3100_port {\n\tstruct uart_port port;\n\tstruct spi_device *spi;\n\n\tint cts;\t         \n\tint tx_empty;\t\t \n\n\tspinlock_t conf_lock;\t \n\tint conf_commit;\t \n\tint conf;\t\t \n\tint rts_commit;\t         \n\tint rts;\t\t \n\tint baud;\t\t \n\n\tint parity;\t\t \n#define MAX3100_PARITY_ON 1\n#define MAX3100_PARITY_ODD 2\n#define MAX3100_7BIT 4\n\tint rx_enabled;\t         \n\n\tint irq;\t\t \n\n\tint minor;\t\t \n\tint crystal;\t\t \n\tint loopback;\t\t \n\n\t \n\tstruct workqueue_struct *workqueue;\n\tstruct work_struct work;\n\t \n\tint  force_end_work;\n\t \n\tint suspending;\n\n\t \n\tvoid (*max3100_hw_suspend) (int suspend);\n\n\t \n\tint poll_time;\n\t \n\tstruct timer_list\ttimer;\n};\n\nstatic struct max3100_port *max3100s[MAX_MAX3100];  \nstatic DEFINE_MUTEX(max3100s_lock);\t\t    \n\nstatic int max3100_do_parity(struct max3100_port *s, u16 c)\n{\n\tint parity;\n\n\tif (s->parity & MAX3100_PARITY_ODD)\n\t\tparity = 1;\n\telse\n\t\tparity = 0;\n\n\tif (s->parity & MAX3100_7BIT)\n\t\tc &= 0x7f;\n\telse\n\t\tc &= 0xff;\n\n\tparity = parity ^ (hweight8(c) & 1);\n\treturn parity;\n}\n\nstatic int max3100_check_parity(struct max3100_port *s, u16 c)\n{\n\treturn max3100_do_parity(s, c) == ((c >> 8) & 1);\n}\n\nstatic void max3100_calc_parity(struct max3100_port *s, u16 *c)\n{\n\tif (s->parity & MAX3100_7BIT)\n\t\t*c &= 0x7f;\n\telse\n\t\t*c &= 0xff;\n\n\tif (s->parity & MAX3100_PARITY_ON)\n\t\t*c |= max3100_do_parity(s, *c) << 8;\n}\n\nstatic void max3100_work(struct work_struct *w);\n\nstatic void max3100_dowork(struct max3100_port *s)\n{\n\tif (!s->force_end_work && !freezing(current) && !s->suspending)\n\t\tqueue_work(s->workqueue, &s->work);\n}\n\nstatic void max3100_timeout(struct timer_list *t)\n{\n\tstruct max3100_port *s = from_timer(s, t, timer);\n\n\tif (s->port.state) {\n\t\tmax3100_dowork(s);\n\t\tmod_timer(&s->timer, jiffies + s->poll_time);\n\t}\n}\n\nstatic int max3100_sr(struct max3100_port *s, u16 tx, u16 *rx)\n{\n\tstruct spi_message message;\n\tu16 etx, erx;\n\tint status;\n\tstruct spi_transfer tran = {\n\t\t.tx_buf = &etx,\n\t\t.rx_buf = &erx,\n\t\t.len = 2,\n\t};\n\n\tetx = cpu_to_be16(tx);\n\tspi_message_init(&message);\n\tspi_message_add_tail(&tran, &message);\n\tstatus = spi_sync(s->spi, &message);\n\tif (status) {\n\t\tdev_warn(&s->spi->dev, \"error while calling spi_sync\\n\");\n\t\treturn -EIO;\n\t}\n\t*rx = be16_to_cpu(erx);\n\ts->tx_empty = (*rx & MAX3100_T) > 0;\n\tdev_dbg(&s->spi->dev, \"%04x - %04x\\n\", tx, *rx);\n\treturn 0;\n}\n\nstatic int max3100_handlerx(struct max3100_port *s, u16 rx)\n{\n\tunsigned int status = 0;\n\tint ret = 0, cts;\n\tu8 ch, flg;\n\n\tif (rx & MAX3100_R && s->rx_enabled) {\n\t\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\t\tch = rx & (s->parity & MAX3100_7BIT ? 0x7f : 0xff);\n\t\tif (rx & MAX3100_RAFE) {\n\t\t\ts->port.icount.frame++;\n\t\t\tflg = TTY_FRAME;\n\t\t\tstatus |= MAX3100_STATUS_FE;\n\t\t} else {\n\t\t\tif (s->parity & MAX3100_PARITY_ON) {\n\t\t\t\tif (max3100_check_parity(s, rx)) {\n\t\t\t\t\ts->port.icount.rx++;\n\t\t\t\t\tflg = TTY_NORMAL;\n\t\t\t\t} else {\n\t\t\t\t\ts->port.icount.parity++;\n\t\t\t\t\tflg = TTY_PARITY;\n\t\t\t\t\tstatus |= MAX3100_STATUS_PE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts->port.icount.rx++;\n\t\t\t\tflg = TTY_NORMAL;\n\t\t\t}\n\t\t}\n\t\tuart_insert_char(&s->port, status, MAX3100_STATUS_OE, ch, flg);\n\t\tret = 1;\n\t}\n\n\tcts = (rx & MAX3100_CTS) > 0;\n\tif (s->cts != cts) {\n\t\ts->cts = cts;\n\t\tuart_handle_cts_change(&s->port, cts);\n\t}\n\n\treturn ret;\n}\n\nstatic void max3100_work(struct work_struct *w)\n{\n\tstruct max3100_port *s = container_of(w, struct max3100_port, work);\n\tint rxchars;\n\tu16 tx, rx;\n\tint conf, cconf, crts;\n\tstruct circ_buf *xmit = &s->port.state->xmit;\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\trxchars = 0;\n\tdo {\n\t\tspin_lock(&s->conf_lock);\n\t\tconf = s->conf;\n\t\tcconf = s->conf_commit;\n\t\ts->conf_commit = 0;\n\t\tcrts = s->rts_commit;\n\t\ts->rts_commit = 0;\n\t\tspin_unlock(&s->conf_lock);\n\t\tif (cconf)\n\t\t\tmax3100_sr(s, MAX3100_WC | conf, &rx);\n\t\tif (crts) {\n\t\t\tmax3100_sr(s, MAX3100_WD | MAX3100_TE |\n\t\t\t\t   (s->rts ? MAX3100_RTS : 0), &rx);\n\t\t\trxchars += max3100_handlerx(s, rx);\n\t\t}\n\n\t\tmax3100_sr(s, MAX3100_RD, &rx);\n\t\trxchars += max3100_handlerx(s, rx);\n\n\t\tif (rx & MAX3100_T) {\n\t\t\ttx = 0xffff;\n\t\t\tif (s->port.x_char) {\n\t\t\t\ttx = s->port.x_char;\n\t\t\t\ts->port.icount.tx++;\n\t\t\t\ts->port.x_char = 0;\n\t\t\t} else if (!uart_circ_empty(xmit) &&\n\t\t\t\t   !uart_tx_stopped(&s->port)) {\n\t\t\t\ttx = xmit->buf[xmit->tail];\n\t\t\t\tuart_xmit_advance(&s->port, 1);\n\t\t\t}\n\t\t\tif (tx != 0xffff) {\n\t\t\t\tmax3100_calc_parity(s, &tx);\n\t\t\t\ttx |= MAX3100_WD | (s->rts ? MAX3100_RTS : 0);\n\t\t\t\tmax3100_sr(s, tx, &rx);\n\t\t\t\trxchars += max3100_handlerx(s, rx);\n\t\t\t}\n\t\t}\n\n\t\tif (rxchars > 16) {\n\t\t\ttty_flip_buffer_push(&s->port.state->port);\n\t\t\trxchars = 0;\n\t\t}\n\t\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\t\tuart_write_wakeup(&s->port);\n\n\t} while (!s->force_end_work &&\n\t\t !freezing(current) &&\n\t\t ((rx & MAX3100_R) ||\n\t\t  (!uart_circ_empty(xmit) &&\n\t\t   !uart_tx_stopped(&s->port))));\n\n\tif (rxchars > 0)\n\t\ttty_flip_buffer_push(&s->port.state->port);\n}\n\nstatic irqreturn_t max3100_irq(int irqno, void *dev_id)\n{\n\tstruct max3100_port *s = dev_id;\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\tmax3100_dowork(s);\n\treturn IRQ_HANDLED;\n}\n\nstatic void max3100_enable_ms(struct uart_port *port)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tif (s->poll_time > 0)\n\t\tmod_timer(&s->timer, jiffies);\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n}\n\nstatic void max3100_start_tx(struct uart_port *port)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\tmax3100_dowork(s);\n}\n\nstatic void max3100_stop_rx(struct uart_port *port)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\ts->rx_enabled = 0;\n\tspin_lock(&s->conf_lock);\n\ts->conf &= ~MAX3100_RM;\n\ts->conf_commit = 1;\n\tspin_unlock(&s->conf_lock);\n\tmax3100_dowork(s);\n}\n\nstatic unsigned int max3100_tx_empty(struct uart_port *port)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\t \n\tmax3100_dowork(s);\n\treturn s->tx_empty;\n}\n\nstatic unsigned int max3100_get_mctrl(struct uart_port *port)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\t \n\tmax3100_dowork(s);\n\t \n\treturn (s->cts ? TIOCM_CTS : 0) | TIOCM_DSR | TIOCM_CAR;\n}\n\nstatic void max3100_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\tint rts;\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\trts = (mctrl & TIOCM_RTS) > 0;\n\n\tspin_lock(&s->conf_lock);\n\tif (s->rts != rts) {\n\t\ts->rts = rts;\n\t\ts->rts_commit = 1;\n\t\tmax3100_dowork(s);\n\t}\n\tspin_unlock(&s->conf_lock);\n}\n\nstatic void\nmax3100_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t    const struct ktermios *old)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\tint baud = 0;\n\tunsigned cflag;\n\tu32 param_new, param_mask, parity = 0;\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\tcflag = termios->c_cflag;\n\tparam_mask = 0;\n\n\tbaud = tty_termios_baud_rate(termios);\n\tparam_new = s->conf & MAX3100_BAUD;\n\tswitch (baud) {\n\tcase 300:\n\t\tif (s->crystal)\n\t\t\tbaud = s->baud;\n\t\telse\n\t\t\tparam_new = 15;\n\t\tbreak;\n\tcase 600:\n\t\tparam_new = 14 + s->crystal;\n\t\tbreak;\n\tcase 1200:\n\t\tparam_new = 13 + s->crystal;\n\t\tbreak;\n\tcase 2400:\n\t\tparam_new = 12 + s->crystal;\n\t\tbreak;\n\tcase 4800:\n\t\tparam_new = 11 + s->crystal;\n\t\tbreak;\n\tcase 9600:\n\t\tparam_new = 10 + s->crystal;\n\t\tbreak;\n\tcase 19200:\n\t\tparam_new = 9 + s->crystal;\n\t\tbreak;\n\tcase 38400:\n\t\tparam_new = 8 + s->crystal;\n\t\tbreak;\n\tcase 57600:\n\t\tparam_new = 1 + s->crystal;\n\t\tbreak;\n\tcase 115200:\n\t\tparam_new = 0 + s->crystal;\n\t\tbreak;\n\tcase 230400:\n\t\tif (s->crystal)\n\t\t\tparam_new = 0;\n\t\telse\n\t\t\tbaud = s->baud;\n\t\tbreak;\n\tdefault:\n\t\tbaud = s->baud;\n\t}\n\ttty_termios_encode_baud_rate(termios, baud, baud);\n\ts->baud = baud;\n\tparam_mask |= MAX3100_BAUD;\n\n\tif ((cflag & CSIZE) == CS8) {\n\t\tparam_new &= ~MAX3100_L;\n\t\tparity &= ~MAX3100_7BIT;\n\t} else {\n\t\tparam_new |= MAX3100_L;\n\t\tparity |= MAX3100_7BIT;\n\t\tcflag = (cflag & ~CSIZE) | CS7;\n\t}\n\tparam_mask |= MAX3100_L;\n\n\tif (cflag & CSTOPB)\n\t\tparam_new |= MAX3100_ST;\n\telse\n\t\tparam_new &= ~MAX3100_ST;\n\tparam_mask |= MAX3100_ST;\n\n\tif (cflag & PARENB) {\n\t\tparam_new |= MAX3100_PE;\n\t\tparity |= MAX3100_PARITY_ON;\n\t} else {\n\t\tparam_new &= ~MAX3100_PE;\n\t\tparity &= ~MAX3100_PARITY_ON;\n\t}\n\tparam_mask |= MAX3100_PE;\n\n\tif (cflag & PARODD)\n\t\tparity |= MAX3100_PARITY_ODD;\n\telse\n\t\tparity &= ~MAX3100_PARITY_ODD;\n\n\t \n\tcflag &= ~CMSPAR;\n\ttermios->c_cflag = cflag;\n\n\ts->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\ts->port.ignore_status_mask |=\n\t\t\tMAX3100_STATUS_PE | MAX3100_STATUS_FE |\n\t\t\tMAX3100_STATUS_OE;\n\n\tif (s->poll_time > 0)\n\t\tdel_timer_sync(&s->timer);\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tspin_lock(&s->conf_lock);\n\ts->conf = (s->conf & ~param_mask) | (param_new & param_mask);\n\ts->conf_commit = 1;\n\ts->parity = parity;\n\tspin_unlock(&s->conf_lock);\n\tmax3100_dowork(s);\n\n\tif (UART_ENABLE_MS(&s->port, termios->c_cflag))\n\t\tmax3100_enable_ms(&s->port);\n}\n\nstatic void max3100_shutdown(struct uart_port *port)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\tif (s->suspending)\n\t\treturn;\n\n\ts->force_end_work = 1;\n\n\tif (s->poll_time > 0)\n\t\tdel_timer_sync(&s->timer);\n\n\tif (s->workqueue) {\n\t\tdestroy_workqueue(s->workqueue);\n\t\ts->workqueue = NULL;\n\t}\n\tif (s->irq)\n\t\tfree_irq(s->irq, s);\n\n\t \n\tif (s->max3100_hw_suspend)\n\t\ts->max3100_hw_suspend(1);\n\telse  {\n\t\tu16 tx, rx;\n\n\t\ttx = MAX3100_WC | MAX3100_SHDN;\n\t\tmax3100_sr(s, tx, &rx);\n\t}\n}\n\nstatic int max3100_startup(struct uart_port *port)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\tchar b[12];\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\ts->conf = MAX3100_RM;\n\ts->baud = s->crystal ? 230400 : 115200;\n\ts->rx_enabled = 1;\n\n\tif (s->suspending)\n\t\treturn 0;\n\n\ts->force_end_work = 0;\n\ts->parity = 0;\n\ts->rts = 0;\n\n\tsprintf(b, \"max3100-%d\", s->minor);\n\ts->workqueue = create_freezable_workqueue(b);\n\tif (!s->workqueue) {\n\t\tdev_warn(&s->spi->dev, \"cannot create workqueue\\n\");\n\t\treturn -EBUSY;\n\t}\n\tINIT_WORK(&s->work, max3100_work);\n\n\tif (request_irq(s->irq, max3100_irq,\n\t\t\tIRQF_TRIGGER_FALLING, \"max3100\", s) < 0) {\n\t\tdev_warn(&s->spi->dev, \"cannot allocate irq %d\\n\", s->irq);\n\t\ts->irq = 0;\n\t\tdestroy_workqueue(s->workqueue);\n\t\ts->workqueue = NULL;\n\t\treturn -EBUSY;\n\t}\n\n\tif (s->loopback) {\n\t\tu16 tx, rx;\n\t\ttx = 0x4001;\n\t\tmax3100_sr(s, tx, &rx);\n\t}\n\n\tif (s->max3100_hw_suspend)\n\t\ts->max3100_hw_suspend(0);\n\ts->conf_commit = 1;\n\tmax3100_dowork(s);\n\t \n\tmsleep(50);\n\n\tmax3100_enable_ms(&s->port);\n\n\treturn 0;\n}\n\nstatic const char *max3100_type(struct uart_port *port)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\treturn s->port.type == PORT_MAX3100 ? \"MAX3100\" : NULL;\n}\n\nstatic void max3100_release_port(struct uart_port *port)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n}\n\nstatic void max3100_config_port(struct uart_port *port, int flags)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\tif (flags & UART_CONFIG_TYPE)\n\t\ts->port.type = PORT_MAX3100;\n}\n\nstatic int max3100_verify_port(struct uart_port *port,\n\t\t\t       struct serial_struct *ser)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\tint ret = -EINVAL;\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\tif (ser->type == PORT_UNKNOWN || ser->type == PORT_MAX3100)\n\t\tret = 0;\n\treturn ret;\n}\n\nstatic void max3100_stop_tx(struct uart_port *port)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n}\n\nstatic int max3100_request_port(struct uart_port *port)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\treturn 0;\n}\n\nstatic void max3100_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct max3100_port *s = container_of(port,\n\t\t\t\t\t      struct max3100_port,\n\t\t\t\t\t      port);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n}\n\nstatic const struct uart_ops max3100_ops = {\n\t.tx_empty\t= max3100_tx_empty,\n\t.set_mctrl\t= max3100_set_mctrl,\n\t.get_mctrl\t= max3100_get_mctrl,\n\t.stop_tx        = max3100_stop_tx,\n\t.start_tx\t= max3100_start_tx,\n\t.stop_rx\t= max3100_stop_rx,\n\t.enable_ms      = max3100_enable_ms,\n\t.break_ctl      = max3100_break_ctl,\n\t.startup\t= max3100_startup,\n\t.shutdown\t= max3100_shutdown,\n\t.set_termios\t= max3100_set_termios,\n\t.type\t\t= max3100_type,\n\t.release_port   = max3100_release_port,\n\t.request_port   = max3100_request_port,\n\t.config_port\t= max3100_config_port,\n\t.verify_port\t= max3100_verify_port,\n};\n\nstatic struct uart_driver max3100_uart_driver = {\n\t.owner          = THIS_MODULE,\n\t.driver_name    = \"ttyMAX\",\n\t.dev_name       = \"ttyMAX\",\n\t.major          = MAX3100_MAJOR,\n\t.minor          = MAX3100_MINOR,\n\t.nr             = MAX_MAX3100,\n};\nstatic int uart_driver_registered;\n\nstatic int max3100_probe(struct spi_device *spi)\n{\n\tint i, retval;\n\tstruct plat_max3100 *pdata;\n\tu16 tx, rx;\n\n\tmutex_lock(&max3100s_lock);\n\n\tif (!uart_driver_registered) {\n\t\tuart_driver_registered = 1;\n\t\tretval = uart_register_driver(&max3100_uart_driver);\n\t\tif (retval) {\n\t\t\tprintk(KERN_ERR \"Couldn't register max3100 uart driver\\n\");\n\t\t\tmutex_unlock(&max3100s_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_MAX3100; i++)\n\t\tif (!max3100s[i])\n\t\t\tbreak;\n\tif (i == MAX_MAX3100) {\n\t\tdev_warn(&spi->dev, \"too many MAX3100 chips\\n\");\n\t\tmutex_unlock(&max3100s_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tmax3100s[i] = kzalloc(sizeof(struct max3100_port), GFP_KERNEL);\n\tif (!max3100s[i]) {\n\t\tdev_warn(&spi->dev,\n\t\t\t \"kmalloc for max3100 structure %d failed!\\n\", i);\n\t\tmutex_unlock(&max3100s_lock);\n\t\treturn -ENOMEM;\n\t}\n\tmax3100s[i]->spi = spi;\n\tmax3100s[i]->irq = spi->irq;\n\tspin_lock_init(&max3100s[i]->conf_lock);\n\tspi_set_drvdata(spi, max3100s[i]);\n\tpdata = dev_get_platdata(&spi->dev);\n\tmax3100s[i]->crystal = pdata->crystal;\n\tmax3100s[i]->loopback = pdata->loopback;\n\tmax3100s[i]->poll_time = msecs_to_jiffies(pdata->poll_time);\n\tif (pdata->poll_time > 0 && max3100s[i]->poll_time == 0)\n\t\tmax3100s[i]->poll_time = 1;\n\tmax3100s[i]->max3100_hw_suspend = pdata->max3100_hw_suspend;\n\tmax3100s[i]->minor = i;\n\ttimer_setup(&max3100s[i]->timer, max3100_timeout, 0);\n\n\tdev_dbg(&spi->dev, \"%s: adding port %d\\n\", __func__, i);\n\tmax3100s[i]->port.irq = max3100s[i]->irq;\n\tmax3100s[i]->port.uartclk = max3100s[i]->crystal ? 3686400 : 1843200;\n\tmax3100s[i]->port.fifosize = 16;\n\tmax3100s[i]->port.ops = &max3100_ops;\n\tmax3100s[i]->port.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;\n\tmax3100s[i]->port.line = i;\n\tmax3100s[i]->port.type = PORT_MAX3100;\n\tmax3100s[i]->port.dev = &spi->dev;\n\tretval = uart_add_one_port(&max3100_uart_driver, &max3100s[i]->port);\n\tif (retval < 0)\n\t\tdev_warn(&spi->dev,\n\t\t\t \"uart_add_one_port failed for line %d with error %d\\n\",\n\t\t\t i, retval);\n\n\t \n\tif (max3100s[i]->max3100_hw_suspend)\n\t\tmax3100s[i]->max3100_hw_suspend(1);\n\telse {\n\t\ttx = MAX3100_WC | MAX3100_SHDN;\n\t\tmax3100_sr(max3100s[i], tx, &rx);\n\t}\n\tmutex_unlock(&max3100s_lock);\n\treturn 0;\n}\n\nstatic void max3100_remove(struct spi_device *spi)\n{\n\tstruct max3100_port *s = spi_get_drvdata(spi);\n\tint i;\n\n\tmutex_lock(&max3100s_lock);\n\n\t \n\tfor (i = 0; i < MAX_MAX3100; i++)\n\t\tif (max3100s[i] == s) {\n\t\t\tdev_dbg(&spi->dev, \"%s: removing port %d\\n\", __func__, i);\n\t\t\tuart_remove_one_port(&max3100_uart_driver, &max3100s[i]->port);\n\t\t\tkfree(max3100s[i]);\n\t\t\tmax3100s[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\n\tWARN_ON(i == MAX_MAX3100);\n\t\n\t \n\tfor (i = 0; i < MAX_MAX3100; i++)\n\t\tif (max3100s[i]) {\n\t\t\tmutex_unlock(&max3100s_lock);\n\t\t\treturn;\n\t\t}\n\tpr_debug(\"removing max3100 driver\\n\");\n\tuart_unregister_driver(&max3100_uart_driver);\n\n\tmutex_unlock(&max3100s_lock);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int max3100_suspend(struct device *dev)\n{\n\tstruct max3100_port *s = dev_get_drvdata(dev);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\tdisable_irq(s->irq);\n\n\ts->suspending = 1;\n\tuart_suspend_port(&max3100_uart_driver, &s->port);\n\n\tif (s->max3100_hw_suspend)\n\t\ts->max3100_hw_suspend(1);\n\telse {\n\t\t \n\t\tu16 tx, rx;\n\n\t\ttx = MAX3100_WC | MAX3100_SHDN;\n\t\tmax3100_sr(s, tx, &rx);\n\t}\n\treturn 0;\n}\n\nstatic int max3100_resume(struct device *dev)\n{\n\tstruct max3100_port *s = dev_get_drvdata(dev);\n\n\tdev_dbg(&s->spi->dev, \"%s\\n\", __func__);\n\n\tif (s->max3100_hw_suspend)\n\t\ts->max3100_hw_suspend(0);\n\tuart_resume_port(&max3100_uart_driver, &s->port);\n\ts->suspending = 0;\n\n\tenable_irq(s->irq);\n\n\ts->conf_commit = 1;\n\tif (s->workqueue)\n\t\tmax3100_dowork(s);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(max3100_pm_ops, max3100_suspend, max3100_resume);\n#define MAX3100_PM_OPS (&max3100_pm_ops)\n\n#else\n#define MAX3100_PM_OPS NULL\n#endif\n\nstatic struct spi_driver max3100_driver = {\n\t.driver = {\n\t\t.name\t\t= \"max3100\",\n\t\t.pm\t\t= MAX3100_PM_OPS,\n\t},\n\t.probe\t\t= max3100_probe,\n\t.remove\t\t= max3100_remove,\n};\n\nmodule_spi_driver(max3100_driver);\n\nMODULE_DESCRIPTION(\"MAX3100 driver\");\nMODULE_AUTHOR(\"Christian Pellegrin <chripell@evolware.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:max3100\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}