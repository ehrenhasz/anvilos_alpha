{
  "module_name": "sunzilog.c",
  "hash_id": "b5d03c77a497b6661230322a259608524ecf1be2a074b7ab2e4dfd0cf2dc2941",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sunzilog.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/circ_buf.h>\n#include <linux/serial.h>\n#include <linux/sysrq.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#ifdef CONFIG_SERIO\n#include <linux/serio.h>\n#endif\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <asm/setup.h>\n\n#include <linux/serial_core.h>\n#include <linux/sunserialcore.h>\n\n#include \"sunzilog.h\"\n\n \n#ifndef CONFIG_SPARC64\n#define ZSDELAY()\t\tudelay(5)\n#define ZSDELAY_LONG()\t\tudelay(20)\n#define ZS_WSYNC(channel)\tdo { } while (0)\n#else\n#define ZSDELAY()\n#define ZSDELAY_LONG()\n#define ZS_WSYNC(__channel) \\\n\treadb(&((__channel)->control))\n#endif\n\n#define ZS_CLOCK\t\t4915200  \n#define ZS_CLOCK_DIVISOR\t16       \n\n \nstruct uart_sunzilog_port {\n\tstruct uart_port\t\tport;\n\n\t \n\tstruct uart_sunzilog_port\t*next;\n\n\t \n\tunsigned char\t\t\tcurregs[NUM_ZSREGS];\n\n\tunsigned int\t\t\tflags;\n#define SUNZILOG_FLAG_CONS_KEYB\t\t0x00000001\n#define SUNZILOG_FLAG_CONS_MOUSE\t0x00000002\n#define SUNZILOG_FLAG_IS_CONS\t\t0x00000004\n#define SUNZILOG_FLAG_IS_KGDB\t\t0x00000008\n#define SUNZILOG_FLAG_MODEM_STATUS\t0x00000010\n#define SUNZILOG_FLAG_IS_CHANNEL_A\t0x00000020\n#define SUNZILOG_FLAG_REGS_HELD\t\t0x00000040\n#define SUNZILOG_FLAG_TX_STOPPED\t0x00000080\n#define SUNZILOG_FLAG_TX_ACTIVE\t\t0x00000100\n#define SUNZILOG_FLAG_ESCC\t\t0x00000200\n#define SUNZILOG_FLAG_ISR_HANDLER\t0x00000400\n\n\tunsigned int cflag;\n\n\tunsigned char\t\t\tparity_mask;\n\tunsigned char\t\t\tprev_status;\n\n#ifdef CONFIG_SERIO\n\tstruct serio\t\t\tserio;\n\tint\t\t\t\tserio_open;\n#endif\n};\n\nstatic void sunzilog_putchar(struct uart_port *port, unsigned char ch);\n\n#define ZILOG_CHANNEL_FROM_PORT(PORT)\t((struct zilog_channel __iomem *)((PORT)->membase))\n#define UART_ZILOG(PORT)\t\t((struct uart_sunzilog_port *)(PORT))\n\n#define ZS_IS_KEYB(UP)\t((UP)->flags & SUNZILOG_FLAG_CONS_KEYB)\n#define ZS_IS_MOUSE(UP)\t((UP)->flags & SUNZILOG_FLAG_CONS_MOUSE)\n#define ZS_IS_CONS(UP)\t((UP)->flags & SUNZILOG_FLAG_IS_CONS)\n#define ZS_IS_KGDB(UP)\t((UP)->flags & SUNZILOG_FLAG_IS_KGDB)\n#define ZS_WANTS_MODEM_STATUS(UP)\t((UP)->flags & SUNZILOG_FLAG_MODEM_STATUS)\n#define ZS_IS_CHANNEL_A(UP)\t((UP)->flags & SUNZILOG_FLAG_IS_CHANNEL_A)\n#define ZS_REGS_HELD(UP)\t((UP)->flags & SUNZILOG_FLAG_REGS_HELD)\n#define ZS_TX_STOPPED(UP)\t((UP)->flags & SUNZILOG_FLAG_TX_STOPPED)\n#define ZS_TX_ACTIVE(UP)\t((UP)->flags & SUNZILOG_FLAG_TX_ACTIVE)\n\n \nstatic unsigned char read_zsreg(struct zilog_channel __iomem *channel,\n\t\t\t\tunsigned char reg)\n{\n\tunsigned char retval;\n\n\twriteb(reg, &channel->control);\n\tZSDELAY();\n\tretval = readb(&channel->control);\n\tZSDELAY();\n\n\treturn retval;\n}\n\nstatic void write_zsreg(struct zilog_channel __iomem *channel,\n\t\t\tunsigned char reg, unsigned char value)\n{\n\twriteb(reg, &channel->control);\n\tZSDELAY();\n\twriteb(value, &channel->control);\n\tZSDELAY();\n}\n\nstatic void sunzilog_clear_fifo(struct zilog_channel __iomem *channel)\n{\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tunsigned char regval;\n\n\t\tregval = readb(&channel->control);\n\t\tZSDELAY();\n\t\tif (regval & Rx_CH_AV)\n\t\t\tbreak;\n\n\t\tregval = read_zsreg(channel, R1);\n\t\treadb(&channel->data);\n\t\tZSDELAY();\n\n\t\tif (regval & (PAR_ERR | Rx_OVR | CRC_ERR)) {\n\t\t\twriteb(ERR_RES, &channel->control);\n\t\t\tZSDELAY();\n\t\t\tZS_WSYNC(channel);\n\t\t}\n\t}\n}\n\n \nstatic int __load_zsregs(struct zilog_channel __iomem *channel, unsigned char *regs)\n{\n\tint i;\n\tint escc;\n\tunsigned char r15;\n\n\t \n\tfor (i = 0; i < 1000; i++) {\n\t\tunsigned char stat = read_zsreg(channel, R1);\n\t\tif (stat & ALL_SNT)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\n\twriteb(ERR_RES, &channel->control);\n\tZSDELAY();\n\tZS_WSYNC(channel);\n\n\tsunzilog_clear_fifo(channel);\n\n\t \n\twrite_zsreg(channel, R1,\n\t\t    regs[R1] & ~(RxINT_MASK | TxINT_ENAB | EXT_INT_ENAB));\n\n\t \n\twrite_zsreg(channel, R4, regs[R4]);\n\n\t \n\twrite_zsreg(channel, R10, regs[R10]);\n\n\t \n\twrite_zsreg(channel, R3, regs[R3] & ~RxENAB);\n\twrite_zsreg(channel, R5, regs[R5] & ~TxENAB);\n\n\t \n\twrite_zsreg(channel, R6, regs[R6]);\n\twrite_zsreg(channel, R7, regs[R7]);\n\n\t \n\n\t \n\twrite_zsreg(channel, R14, regs[R14] & ~BRENAB);\n\n\t \n\twrite_zsreg(channel, R11, regs[R11]);\n\n\t \n\twrite_zsreg(channel, R12, regs[R12]);\n\twrite_zsreg(channel, R13, regs[R13]);\n\t\n\t \n\twrite_zsreg(channel, R14, regs[R14]);\n\n\t \n\twrite_zsreg(channel, R15, (regs[R15] | WR7pEN) & ~FIFOEN);\n\n\t \n\tr15 = read_zsreg(channel, R15);\n\tif (r15 & 0x01)\t{\n\t\twrite_zsreg(channel, R7,  regs[R7p]);\n\n\t\t \n\t\twrite_zsreg(channel, R15, regs[R15] & ~WR7pEN);\n\t\tescc = 1;\n\t} else {\n\t\t  \n\t\tregs[R15] &= ~FIFOEN;\n\t\tescc = 0;\n\t}\n\n\t \n\twrite_zsreg(channel, R0, RES_EXT_INT);  \n\twrite_zsreg(channel, R0, RES_EXT_INT);  \n\n\t \n\twrite_zsreg(channel, R3, regs[R3]);\n\twrite_zsreg(channel, R5, regs[R5]);\n\n\t \n\twrite_zsreg(channel, R1, regs[R1]);\n\n\treturn escc;\n}\n\n \nstatic void sunzilog_maybe_update_regs(struct uart_sunzilog_port *up,\n\t\t\t\t       struct zilog_channel __iomem *channel)\n{\n\tif (!ZS_REGS_HELD(up)) {\n\t\tif (ZS_TX_ACTIVE(up)) {\n\t\t\tup->flags |= SUNZILOG_FLAG_REGS_HELD;\n\t\t} else {\n\t\t\t__load_zsregs(channel, up->curregs);\n\t\t}\n\t}\n}\n\nstatic void sunzilog_change_mouse_baud(struct uart_sunzilog_port *up)\n{\n\tunsigned int cur_cflag = up->cflag;\n\tint brg, new_baud;\n\n\tup->cflag &= ~CBAUD;\n\tup->cflag |= suncore_mouse_baud_cflag_next(cur_cflag, &new_baud);\n\n\tbrg = BPS_TO_BRG(new_baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\n\tup->curregs[R12] = (brg & 0xff);\n\tup->curregs[R13] = (brg >> 8) & 0xff;\n\tsunzilog_maybe_update_regs(up, ZILOG_CHANNEL_FROM_PORT(&up->port));\n}\n\nstatic void sunzilog_kbdms_receive_chars(struct uart_sunzilog_port *up,\n\t\t\t\t\t unsigned char ch, int is_break)\n{\n\tif (ZS_IS_KEYB(up)) {\n\t\t \n#ifdef CONFIG_SERIO\n\t\tif (up->serio_open)\n\t\t\tserio_interrupt(&up->serio, ch, 0);\n#endif\n\t} else if (ZS_IS_MOUSE(up)) {\n\t\tint ret = suncore_mouse_baud_detection(ch, is_break);\n\n\t\tswitch (ret) {\n\t\tcase 2:\n\t\t\tsunzilog_change_mouse_baud(up);\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\tbreak;\n\n\t\tcase 0:\n#ifdef CONFIG_SERIO\n\t\t\tif (up->serio_open)\n\t\t\t\tserio_interrupt(&up->serio, ch, 0);\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct tty_port *\nsunzilog_receive_chars(struct uart_sunzilog_port *up,\n\t\t       struct zilog_channel __iomem *channel)\n{\n\tstruct tty_port *port = NULL;\n\tunsigned char ch, r1, flag;\n\n\tif (up->port.state != NULL)\t\t \n\t\tport = &up->port.state->port;\n\n\tfor (;;) {\n\n\t\tr1 = read_zsreg(channel, R1);\n\t\tif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR)) {\n\t\t\twriteb(ERR_RES, &channel->control);\n\t\t\tZSDELAY();\n\t\t\tZS_WSYNC(channel);\n\t\t}\n\n\t\tch = readb(&channel->control);\n\t\tZSDELAY();\n\n\t\t \n\t\tif (ch & BRK_ABRT)\n\t\t\tr1 |= BRK_ABRT;\n\n\t\tif (!(ch & Rx_CH_AV))\n\t\t\tbreak;\n\n\t\tch = readb(&channel->data);\n\t\tZSDELAY();\n\n\t\tch &= up->parity_mask;\n\n\t\tif (unlikely(ZS_IS_KEYB(up)) || unlikely(ZS_IS_MOUSE(up))) {\n\t\t\tsunzilog_kbdms_receive_chars(up, ch, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tflag = TTY_NORMAL;\n\t\tup->port.icount.rx++;\n\t\tif (r1 & (BRK_ABRT | PAR_ERR | Rx_OVR | CRC_ERR)) {\n\t\t\tif (r1 & BRK_ABRT) {\n\t\t\t\tr1 &= ~(PAR_ERR | CRC_ERR);\n\t\t\t\tup->port.icount.brk++;\n\t\t\t\tif (uart_handle_break(&up->port))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (r1 & PAR_ERR)\n\t\t\t\tup->port.icount.parity++;\n\t\t\telse if (r1 & CRC_ERR)\n\t\t\t\tup->port.icount.frame++;\n\t\t\tif (r1 & Rx_OVR)\n\t\t\t\tup->port.icount.overrun++;\n\t\t\tr1 &= up->port.read_status_mask;\n\t\t\tif (r1 & BRK_ABRT)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (r1 & PAR_ERR)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (r1 & CRC_ERR)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\t\tif (uart_handle_sysrq_char(&up->port, ch) || !port)\n\t\t\tcontinue;\n\n\t\tif (up->port.ignore_status_mask == 0xff ||\n\t\t    (r1 & up->port.ignore_status_mask) == 0) {\n\t\t    \ttty_insert_flip_char(port, ch, flag);\n\t\t}\n\t\tif (r1 & Rx_OVR)\n\t\t\ttty_insert_flip_char(port, 0, TTY_OVERRUN);\n\t}\n\n\treturn port;\n}\n\nstatic void sunzilog_status_handle(struct uart_sunzilog_port *up,\n\t\t\t\t   struct zilog_channel __iomem *channel)\n{\n\tunsigned char status;\n\n\tstatus = readb(&channel->control);\n\tZSDELAY();\n\n\twriteb(RES_EXT_INT, &channel->control);\n\tZSDELAY();\n\tZS_WSYNC(channel);\n\n\tif (status & BRK_ABRT) {\n\t\tif (ZS_IS_MOUSE(up))\n\t\t\tsunzilog_kbdms_receive_chars(up, 0, 1);\n\t\tif (ZS_IS_CONS(up)) {\n\t\t\t \n\t\t\twhile (1) {\n\t\t\t\tstatus = readb(&channel->control);\n\t\t\t\tZSDELAY();\n\t\t\t\tif (!(status & BRK_ABRT))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsun_do_break();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ZS_WANTS_MODEM_STATUS(up)) {\n\t\tif (status & SYNC)\n\t\t\tup->port.icount.dsr++;\n\n\t\t \n\t\tif ((status ^ up->prev_status) ^ DCD)\n\t\t\tuart_handle_dcd_change(&up->port,\n\t\t\t\t\t       (status & DCD));\n\t\tif ((status ^ up->prev_status) ^ CTS)\n\t\t\tuart_handle_cts_change(&up->port,\n\t\t\t\t\t       (status & CTS));\n\n\t\twake_up_interruptible(&up->port.state->port.delta_msr_wait);\n\t}\n\n\tup->prev_status = status;\n}\n\nstatic void sunzilog_transmit_chars(struct uart_sunzilog_port *up,\n\t\t\t\t    struct zilog_channel __iomem *channel)\n{\n\tstruct circ_buf *xmit;\n\n\tif (ZS_IS_CONS(up)) {\n\t\tunsigned char status = readb(&channel->control);\n\t\tZSDELAY();\n\n\t\t \n\t\tif (!(status & Tx_BUF_EMP))\n\t\t\treturn;\n\t}\n\n\tup->flags &= ~SUNZILOG_FLAG_TX_ACTIVE;\n\n\tif (ZS_REGS_HELD(up)) {\n\t\t__load_zsregs(channel, up->curregs);\n\t\tup->flags &= ~SUNZILOG_FLAG_REGS_HELD;\n\t}\n\n\tif (ZS_TX_STOPPED(up)) {\n\t\tup->flags &= ~SUNZILOG_FLAG_TX_STOPPED;\n\t\tgoto ack_tx_int;\n\t}\n\n\tif (up->port.x_char) {\n\t\tup->flags |= SUNZILOG_FLAG_TX_ACTIVE;\n\t\twriteb(up->port.x_char, &channel->data);\n\t\tZSDELAY();\n\t\tZS_WSYNC(channel);\n\n\t\tup->port.icount.tx++;\n\t\tup->port.x_char = 0;\n\t\treturn;\n\t}\n\n\tif (up->port.state == NULL)\n\t\tgoto ack_tx_int;\n\txmit = &up->port.state->xmit;\n\tif (uart_circ_empty(xmit))\n\t\tgoto ack_tx_int;\n\n\tif (uart_tx_stopped(&up->port))\n\t\tgoto ack_tx_int;\n\n\tup->flags |= SUNZILOG_FLAG_TX_ACTIVE;\n\twriteb(xmit->buf[xmit->tail], &channel->data);\n\tZSDELAY();\n\tZS_WSYNC(channel);\n\n\tuart_xmit_advance(&up->port, 1);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&up->port);\n\n\treturn;\n\nack_tx_int:\n\twriteb(RES_Tx_P, &channel->control);\n\tZSDELAY();\n\tZS_WSYNC(channel);\n}\n\nstatic irqreturn_t sunzilog_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_sunzilog_port *up = dev_id;\n\n\twhile (up) {\n\t\tstruct zilog_channel __iomem *channel\n\t\t\t= ZILOG_CHANNEL_FROM_PORT(&up->port);\n\t\tstruct tty_port *port;\n\t\tunsigned char r3;\n\n\t\tspin_lock(&up->port.lock);\n\t\tr3 = read_zsreg(channel, R3);\n\n\t\t \n\t\tport = NULL;\n\t\tif (r3 & (CHAEXT | CHATxIP | CHARxIP)) {\n\t\t\twriteb(RES_H_IUS, &channel->control);\n\t\t\tZSDELAY();\n\t\t\tZS_WSYNC(channel);\n\n\t\t\tif (r3 & CHARxIP)\n\t\t\t\tport = sunzilog_receive_chars(up, channel);\n\t\t\tif (r3 & CHAEXT)\n\t\t\t\tsunzilog_status_handle(up, channel);\n\t\t\tif (r3 & CHATxIP)\n\t\t\t\tsunzilog_transmit_chars(up, channel);\n\t\t}\n\t\tspin_unlock(&up->port.lock);\n\n\t\tif (port)\n\t\t\ttty_flip_buffer_push(port);\n\n\t\t \n\t\tup = up->next;\n\t\tchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\n\n\t\tspin_lock(&up->port.lock);\n\t\tport = NULL;\n\t\tif (r3 & (CHBEXT | CHBTxIP | CHBRxIP)) {\n\t\t\twriteb(RES_H_IUS, &channel->control);\n\t\t\tZSDELAY();\n\t\t\tZS_WSYNC(channel);\n\n\t\t\tif (r3 & CHBRxIP)\n\t\t\t\tport = sunzilog_receive_chars(up, channel);\n\t\t\tif (r3 & CHBEXT)\n\t\t\t\tsunzilog_status_handle(up, channel);\n\t\t\tif (r3 & CHBTxIP)\n\t\t\t\tsunzilog_transmit_chars(up, channel);\n\t\t}\n\t\tspin_unlock(&up->port.lock);\n\n\t\tif (port)\n\t\t\ttty_flip_buffer_push(port);\n\n\t\tup = up->next;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic __inline__ unsigned char sunzilog_read_channel_status(struct uart_port *port)\n{\n\tstruct zilog_channel __iomem *channel;\n\tunsigned char status;\n\n\tchannel = ZILOG_CHANNEL_FROM_PORT(port);\n\tstatus = readb(&channel->control);\n\tZSDELAY();\n\n\treturn status;\n}\n\n \nstatic unsigned int sunzilog_tx_empty(struct uart_port *port)\n{\n\tunsigned long flags;\n\tunsigned char status;\n\tunsigned int ret;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tstatus = sunzilog_read_channel_status(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (status & Tx_BUF_EMP)\n\t\tret = TIOCSER_TEMT;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\n \nstatic unsigned int sunzilog_get_mctrl(struct uart_port *port)\n{\n\tunsigned char status;\n\tunsigned int ret;\n\n\tstatus = sunzilog_read_channel_status(port);\n\n\tret = 0;\n\tif (status & DCD)\n\t\tret |= TIOCM_CAR;\n\tif (status & SYNC)\n\t\tret |= TIOCM_DSR;\n\tif (status & CTS)\n\t\tret |= TIOCM_CTS;\n\n\treturn ret;\n}\n\n \nstatic void sunzilog_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_sunzilog_port *up =\n\t\tcontainer_of(port, struct uart_sunzilog_port, port);\n\tstruct zilog_channel __iomem *channel = ZILOG_CHANNEL_FROM_PORT(port);\n\tunsigned char set_bits, clear_bits;\n\n\tset_bits = clear_bits = 0;\n\n\tif (mctrl & TIOCM_RTS)\n\t\tset_bits |= RTS;\n\telse\n\t\tclear_bits |= RTS;\n\tif (mctrl & TIOCM_DTR)\n\t\tset_bits |= DTR;\n\telse\n\t\tclear_bits |= DTR;\n\n\t  \n\tup->curregs[R5] |= set_bits;\n\tup->curregs[R5] &= ~clear_bits;\n\twrite_zsreg(channel, R5, up->curregs[R5]);\n}\n\n \nstatic void sunzilog_stop_tx(struct uart_port *port)\n{\n\tstruct uart_sunzilog_port *up =\n\t\tcontainer_of(port, struct uart_sunzilog_port, port);\n\n\tup->flags |= SUNZILOG_FLAG_TX_STOPPED;\n}\n\n \nstatic void sunzilog_start_tx(struct uart_port *port)\n{\n\tstruct uart_sunzilog_port *up =\n\t\tcontainer_of(port, struct uart_sunzilog_port, port);\n\tstruct zilog_channel __iomem *channel = ZILOG_CHANNEL_FROM_PORT(port);\n\tunsigned char status;\n\n\tup->flags |= SUNZILOG_FLAG_TX_ACTIVE;\n\tup->flags &= ~SUNZILOG_FLAG_TX_STOPPED;\n\n\tstatus = readb(&channel->control);\n\tZSDELAY();\n\n\t \n\tif (!(status & Tx_BUF_EMP))\n\t\treturn;\n\n\t \n\tif (port->x_char) {\n\t\twriteb(port->x_char, &channel->data);\n\t\tZSDELAY();\n\t\tZS_WSYNC(channel);\n\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t} else {\n\t\tstruct circ_buf *xmit = &port->state->xmit;\n\n\t\tif (uart_circ_empty(xmit))\n\t\t\treturn;\n\t\twriteb(xmit->buf[xmit->tail], &channel->data);\n\t\tZSDELAY();\n\t\tZS_WSYNC(channel);\n\n\t\tuart_xmit_advance(port, 1);\n\n\t\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\t\tuart_write_wakeup(&up->port);\n\t}\n}\n\n \nstatic void sunzilog_stop_rx(struct uart_port *port)\n{\n\tstruct uart_sunzilog_port *up = UART_ZILOG(port);\n\tstruct zilog_channel __iomem *channel;\n\n\tif (ZS_IS_CONS(up))\n\t\treturn;\n\n\tchannel = ZILOG_CHANNEL_FROM_PORT(port);\n\n\t \n\tup->curregs[R1] &= ~RxINT_MASK;\n\tsunzilog_maybe_update_regs(up, channel);\n}\n\n \nstatic void sunzilog_enable_ms(struct uart_port *port)\n{\n\tstruct uart_sunzilog_port *up =\n\t\tcontainer_of(port, struct uart_sunzilog_port, port);\n\tstruct zilog_channel __iomem *channel = ZILOG_CHANNEL_FROM_PORT(port);\n\tunsigned char new_reg;\n\n\tnew_reg = up->curregs[R15] | (DCDIE | SYNCIE | CTSIE);\n\tif (new_reg != up->curregs[R15]) {\n\t\tup->curregs[R15] = new_reg;\n\n\t\t  \n\t\twrite_zsreg(channel, R15, up->curregs[R15] & ~WR7pEN);\n\t}\n}\n\n \nstatic void sunzilog_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_sunzilog_port *up =\n\t\tcontainer_of(port, struct uart_sunzilog_port, port);\n\tstruct zilog_channel __iomem *channel = ZILOG_CHANNEL_FROM_PORT(port);\n\tunsigned char set_bits, clear_bits, new_reg;\n\tunsigned long flags;\n\n\tset_bits = clear_bits = 0;\n\n\tif (break_state)\n\t\tset_bits |= SND_BRK;\n\telse\n\t\tclear_bits |= SND_BRK;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tnew_reg = (up->curregs[R5] | set_bits) & ~clear_bits;\n\tif (new_reg != up->curregs[R5]) {\n\t\tup->curregs[R5] = new_reg;\n\n\t\t  \n\t\twrite_zsreg(channel, R5, up->curregs[R5]);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void __sunzilog_startup(struct uart_sunzilog_port *up)\n{\n\tstruct zilog_channel __iomem *channel;\n\n\tchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\n\tup->prev_status = readb(&channel->control);\n\n\t \n\tup->curregs[R3] |= RxENAB;\n\tup->curregs[R5] |= TxENAB;\n\n\tup->curregs[R1] |= EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB;\n\tsunzilog_maybe_update_regs(up, channel);\n}\n\nstatic int sunzilog_startup(struct uart_port *port)\n{\n\tstruct uart_sunzilog_port *up = UART_ZILOG(port);\n\tunsigned long flags;\n\n\tif (ZS_IS_CONS(up))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\t__sunzilog_startup(up);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\treturn 0;\n}\n\n \nstatic void sunzilog_shutdown(struct uart_port *port)\n{\n\tstruct uart_sunzilog_port *up = UART_ZILOG(port);\n\tstruct zilog_channel __iomem *channel;\n\tunsigned long flags;\n\n\tif (ZS_IS_CONS(up))\n\t\treturn;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tchannel = ZILOG_CHANNEL_FROM_PORT(port);\n\n\t \n\tup->curregs[R3] &= ~RxENAB;\n\tup->curregs[R5] &= ~TxENAB;\n\n\t \n\tup->curregs[R1] &= ~(EXT_INT_ENAB | TxINT_ENAB | RxINT_MASK);\n\tup->curregs[R5] &= ~SND_BRK;\n\tsunzilog_maybe_update_regs(up, channel);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic void\nsunzilog_convert_to_zs(struct uart_sunzilog_port *up, unsigned int cflag,\n\t\t       unsigned int iflag, int brg)\n{\n\n\tup->curregs[R10] = NRZ;\n\tup->curregs[R11] = TCBR | RCBR;\n\n\t \n\tup->curregs[R4] &= ~XCLK_MASK;\n\tup->curregs[R4] |= X16CLK;\n\tup->curregs[R12] = brg & 0xff;\n\tup->curregs[R13] = (brg >> 8) & 0xff;\n\tup->curregs[R14] = BRSRC | BRENAB;\n\n\t \n\tup->curregs[R3] &= ~RxN_MASK;\n\tup->curregs[R5] &= ~TxN_MASK;\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\tup->curregs[R3] |= Rx5;\n\t\tup->curregs[R5] |= Tx5;\n\t\tup->parity_mask = 0x1f;\n\t\tbreak;\n\tcase CS6:\n\t\tup->curregs[R3] |= Rx6;\n\t\tup->curregs[R5] |= Tx6;\n\t\tup->parity_mask = 0x3f;\n\t\tbreak;\n\tcase CS7:\n\t\tup->curregs[R3] |= Rx7;\n\t\tup->curregs[R5] |= Tx7;\n\t\tup->parity_mask = 0x7f;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tup->curregs[R3] |= Rx8;\n\t\tup->curregs[R5] |= Tx8;\n\t\tup->parity_mask = 0xff;\n\t\tbreak;\n\t}\n\tup->curregs[R4] &= ~0x0c;\n\tif (cflag & CSTOPB)\n\t\tup->curregs[R4] |= SB2;\n\telse\n\t\tup->curregs[R4] |= SB1;\n\tif (cflag & PARENB)\n\t\tup->curregs[R4] |= PAR_ENAB;\n\telse\n\t\tup->curregs[R4] &= ~PAR_ENAB;\n\tif (!(cflag & PARODD))\n\t\tup->curregs[R4] |= PAR_EVEN;\n\telse\n\t\tup->curregs[R4] &= ~PAR_EVEN;\n\n\tup->port.read_status_mask = Rx_OVR;\n\tif (iflag & INPCK)\n\t\tup->port.read_status_mask |= CRC_ERR | PAR_ERR;\n\tif (iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tup->port.read_status_mask |= BRK_ABRT;\n\n\tup->port.ignore_status_mask = 0;\n\tif (iflag & IGNPAR)\n\t\tup->port.ignore_status_mask |= CRC_ERR | PAR_ERR;\n\tif (iflag & IGNBRK) {\n\t\tup->port.ignore_status_mask |= BRK_ABRT;\n\t\tif (iflag & IGNPAR)\n\t\t\tup->port.ignore_status_mask |= Rx_OVR;\n\t}\n\n\tif ((cflag & CREAD) == 0)\n\t\tup->port.ignore_status_mask = 0xff;\n}\n\n \nstatic void\nsunzilog_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t     const struct ktermios *old)\n{\n\tstruct uart_sunzilog_port *up =\n\t\tcontainer_of(port, struct uart_sunzilog_port, port);\n\tunsigned long flags;\n\tint baud, brg;\n\n\tbaud = uart_get_baud_rate(port, termios, old, 1200, 76800);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tbrg = BPS_TO_BRG(baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\n\n\tsunzilog_convert_to_zs(up, termios->c_cflag, termios->c_iflag, brg);\n\n\tif (UART_ENABLE_MS(&up->port, termios->c_cflag))\n\t\tup->flags |= SUNZILOG_FLAG_MODEM_STATUS;\n\telse\n\t\tup->flags &= ~SUNZILOG_FLAG_MODEM_STATUS;\n\n\tup->cflag = termios->c_cflag;\n\n\tsunzilog_maybe_update_regs(up, ZILOG_CHANNEL_FROM_PORT(port));\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic const char *sunzilog_type(struct uart_port *port)\n{\n\tstruct uart_sunzilog_port *up = UART_ZILOG(port);\n\n\treturn (up->flags & SUNZILOG_FLAG_ESCC) ? \"zs (ESCC)\" : \"zs\";\n}\n\n \nstatic void sunzilog_release_port(struct uart_port *port)\n{\n}\n\nstatic int sunzilog_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\n \nstatic void sunzilog_config_port(struct uart_port *port, int flags)\n{\n}\n\n \nstatic int sunzilog_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int sunzilog_get_poll_char(struct uart_port *port)\n{\n\tunsigned char ch, r1;\n\tstruct uart_sunzilog_port *up =\n\t\tcontainer_of(port, struct uart_sunzilog_port, port);\n\tstruct zilog_channel __iomem *channel\n\t\t= ZILOG_CHANNEL_FROM_PORT(&up->port);\n\n\n\tr1 = read_zsreg(channel, R1);\n\tif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR)) {\n\t\twriteb(ERR_RES, &channel->control);\n\t\tZSDELAY();\n\t\tZS_WSYNC(channel);\n\t}\n\n\tch = readb(&channel->control);\n\tZSDELAY();\n\n\t \n\tif (ch & BRK_ABRT)\n\t\tr1 |= BRK_ABRT;\n\n\tif (!(ch & Rx_CH_AV))\n\t\treturn NO_POLL_CHAR;\n\n\tch = readb(&channel->data);\n\tZSDELAY();\n\n\tch &= up->parity_mask;\n\treturn ch;\n}\n\nstatic void sunzilog_put_poll_char(struct uart_port *port,\n\t\t\tunsigned char ch)\n{\n\tstruct uart_sunzilog_port *up =\n\t\tcontainer_of(port, struct uart_sunzilog_port, port);\n\n\tsunzilog_putchar(&up->port, ch);\n}\n#endif  \n\nstatic const struct uart_ops sunzilog_pops = {\n\t.tx_empty\t=\tsunzilog_tx_empty,\n\t.set_mctrl\t=\tsunzilog_set_mctrl,\n\t.get_mctrl\t=\tsunzilog_get_mctrl,\n\t.stop_tx\t=\tsunzilog_stop_tx,\n\t.start_tx\t=\tsunzilog_start_tx,\n\t.stop_rx\t=\tsunzilog_stop_rx,\n\t.enable_ms\t=\tsunzilog_enable_ms,\n\t.break_ctl\t=\tsunzilog_break_ctl,\n\t.startup\t=\tsunzilog_startup,\n\t.shutdown\t=\tsunzilog_shutdown,\n\t.set_termios\t=\tsunzilog_set_termios,\n\t.type\t\t=\tsunzilog_type,\n\t.release_port\t=\tsunzilog_release_port,\n\t.request_port\t=\tsunzilog_request_port,\n\t.config_port\t=\tsunzilog_config_port,\n\t.verify_port\t=\tsunzilog_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t=\tsunzilog_get_poll_char,\n\t.poll_put_char\t=\tsunzilog_put_poll_char,\n#endif\n};\n\nstatic int uart_chip_count;\nstatic struct uart_sunzilog_port *sunzilog_port_table;\nstatic struct zilog_layout __iomem **sunzilog_chip_regs;\n\nstatic struct uart_sunzilog_port *sunzilog_irq_chain;\n\nstatic struct uart_driver sunzilog_reg = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.driver_name\t=\t\"sunzilog\",\n\t.dev_name\t=\t\"ttyS\",\n\t.major\t\t=\tTTY_MAJOR,\n};\n\nstatic int __init sunzilog_alloc_tables(int num_sunzilog)\n{\n\tstruct uart_sunzilog_port *up;\n\tunsigned long size;\n\tint num_channels = num_sunzilog * 2;\n\tint i;\n\n\tsize = num_channels * sizeof(struct uart_sunzilog_port);\n\tsunzilog_port_table = kzalloc(size, GFP_KERNEL);\n\tif (!sunzilog_port_table)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tup = &sunzilog_port_table[i];\n\n\t\tspin_lock_init(&up->port.lock);\n\n\t\tif (i == 0)\n\t\t\tsunzilog_irq_chain = up;\n\n\t\tif (i < num_channels - 1)\n\t\t\tup->next = up + 1;\n\t\telse\n\t\t\tup->next = NULL;\n\t}\n\n\tsize = num_sunzilog * sizeof(struct zilog_layout __iomem *);\n\tsunzilog_chip_regs = kzalloc(size, GFP_KERNEL);\n\tif (!sunzilog_chip_regs) {\n\t\tkfree(sunzilog_port_table);\n\t\tsunzilog_irq_chain = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void sunzilog_free_tables(void)\n{\n\tkfree(sunzilog_port_table);\n\tsunzilog_irq_chain = NULL;\n\tkfree(sunzilog_chip_regs);\n}\n\n#define ZS_PUT_CHAR_MAX_DELAY\t2000\t \n\nstatic void __maybe_unused sunzilog_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct zilog_channel __iomem *channel = ZILOG_CHANNEL_FROM_PORT(port);\n\tint loops = ZS_PUT_CHAR_MAX_DELAY;\n\n\t \n\tdo {\n\t\tunsigned char val = readb(&channel->control);\n\t\tif (val & Tx_BUF_EMP) {\n\t\t\tZSDELAY();\n\t\t\tbreak;\n\t\t}\n\t\tudelay(5);\n\t} while (--loops);\n\n\twriteb(ch, &channel->data);\n\tZSDELAY();\n\tZS_WSYNC(channel);\n}\n\n#ifdef CONFIG_SERIO\n\nstatic DEFINE_SPINLOCK(sunzilog_serio_lock);\n\nstatic int sunzilog_serio_write(struct serio *serio, unsigned char ch)\n{\n\tstruct uart_sunzilog_port *up = serio->port_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sunzilog_serio_lock, flags);\n\n\tsunzilog_putchar(&up->port, ch);\n\n\tspin_unlock_irqrestore(&sunzilog_serio_lock, flags);\n\n\treturn 0;\n}\n\nstatic int sunzilog_serio_open(struct serio *serio)\n{\n\tstruct uart_sunzilog_port *up = serio->port_data;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&sunzilog_serio_lock, flags);\n\tif (!up->serio_open) {\n\t\tup->serio_open = 1;\n\t\tret = 0;\n\t} else\n\t\tret = -EBUSY;\n\tspin_unlock_irqrestore(&sunzilog_serio_lock, flags);\n\n\treturn ret;\n}\n\nstatic void sunzilog_serio_close(struct serio *serio)\n{\n\tstruct uart_sunzilog_port *up = serio->port_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sunzilog_serio_lock, flags);\n\tup->serio_open = 0;\n\tspin_unlock_irqrestore(&sunzilog_serio_lock, flags);\n}\n\n#endif  \n\n#ifdef CONFIG_SERIAL_SUNZILOG_CONSOLE\nstatic void\nsunzilog_console_write(struct console *con, const char *s, unsigned int count)\n{\n\tstruct uart_sunzilog_port *up = &sunzilog_port_table[con->index];\n\tunsigned long flags;\n\tint locked = 1;\n\n\tif (up->port.sysrq || oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&up->port.lock, flags);\n\telse\n\t\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tuart_console_write(&up->port, s, count, sunzilog_putchar);\n\tudelay(2);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic int __init sunzilog_console_setup(struct console *con, char *options)\n{\n\tstruct uart_sunzilog_port *up = &sunzilog_port_table[con->index];\n\tunsigned long flags;\n\tint baud, brg;\n\n\tif (up->port.type != PORT_SUNZILOG)\n\t\treturn -EINVAL;\n\n\tprintk(KERN_INFO \"Console: ttyS%d (SunZilog zs%d)\\n\",\n\t       (sunzilog_reg.minor - 64) + con->index, con->index);\n\n\t \n\tsunserial_console_termios(con, up->port.dev->of_node);\n\n\t \n\tswitch (con->cflag & CBAUD) {\n\tcase B150: baud = 150; break;\n\tcase B300: baud = 300; break;\n\tcase B600: baud = 600; break;\n\tcase B1200: baud = 1200; break;\n\tcase B2400: baud = 2400; break;\n\tcase B4800: baud = 4800; break;\n\tdefault: case B9600: baud = 9600; break;\n\tcase B19200: baud = 19200; break;\n\tcase B38400: baud = 38400; break;\n\t}\n\n\tbrg = BPS_TO_BRG(baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tup->curregs[R15] |= BRKIE;\n\tsunzilog_convert_to_zs(up, con->cflag, 0, brg);\n\n\tsunzilog_set_mctrl(&up->port, TIOCM_DTR | TIOCM_RTS);\n\t__sunzilog_startup(up);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\treturn 0;\n}\n\nstatic struct console sunzilog_console_ops = {\n\t.name\t=\t\"ttyS\",\n\t.write\t=\tsunzilog_console_write,\n\t.device\t=\tuart_console_device,\n\t.setup\t=\tsunzilog_console_setup,\n\t.flags\t=\tCON_PRINTBUFFER,\n\t.index\t=\t-1,\n\t.data   =\t&sunzilog_reg,\n};\n\nstatic inline struct console *SUNZILOG_CONSOLE(void)\n{\n\treturn &sunzilog_console_ops;\n}\n\n#else\n#define SUNZILOG_CONSOLE()\t(NULL)\n#endif\n\nstatic void sunzilog_init_kbdms(struct uart_sunzilog_port *up)\n{\n\tint baud, brg;\n\n\tif (up->flags & SUNZILOG_FLAG_CONS_KEYB) {\n\t\tup->cflag = B1200 | CS8 | CLOCAL | CREAD;\n\t\tbaud = 1200;\n\t} else {\n\t\tup->cflag = B4800 | CS8 | CLOCAL | CREAD;\n\t\tbaud = 4800;\n\t}\n\n\tup->curregs[R15] |= BRKIE;\n\tbrg = BPS_TO_BRG(baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\n\tsunzilog_convert_to_zs(up, up->cflag, 0, brg);\n\tsunzilog_set_mctrl(&up->port, TIOCM_DTR | TIOCM_RTS);\n\t__sunzilog_startup(up);\n}\n\n#ifdef CONFIG_SERIO\nstatic void sunzilog_register_serio(struct uart_sunzilog_port *up)\n{\n\tstruct serio *serio = &up->serio;\n\n\tserio->port_data = up;\n\n\tserio->id.type = SERIO_RS232;\n\tif (up->flags & SUNZILOG_FLAG_CONS_KEYB) {\n\t\tserio->id.proto = SERIO_SUNKBD;\n\t\tstrscpy(serio->name, \"zskbd\", sizeof(serio->name));\n\t} else {\n\t\tserio->id.proto = SERIO_SUN;\n\t\tserio->id.extra = 1;\n\t\tstrscpy(serio->name, \"zsms\", sizeof(serio->name));\n\t}\n\tstrscpy(serio->phys,\n\t\t((up->flags & SUNZILOG_FLAG_CONS_KEYB) ?\n\t\t \"zs/serio0\" : \"zs/serio1\"),\n\t\tsizeof(serio->phys));\n\n\tserio->write = sunzilog_serio_write;\n\tserio->open = sunzilog_serio_open;\n\tserio->close = sunzilog_serio_close;\n\tserio->dev.parent = up->port.dev;\n\n\tserio_register_port(serio);\n}\n#endif\n\nstatic void sunzilog_init_hw(struct uart_sunzilog_port *up)\n{\n\tstruct zilog_channel __iomem *channel;\n\tunsigned long flags;\n\tint baud, brg;\n\n\tchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tif (ZS_IS_CHANNEL_A(up)) {\n\t\twrite_zsreg(channel, R9, FHWRES);\n\t\tZSDELAY_LONG();\n\t\t(void) read_zsreg(channel, R0);\n\t}\n\n\tif (up->flags & (SUNZILOG_FLAG_CONS_KEYB |\n\t\t\t SUNZILOG_FLAG_CONS_MOUSE)) {\n\t\tup->curregs[R1] = EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB;\n\t\tup->curregs[R4] = PAR_EVEN | X16CLK | SB1;\n\t\tup->curregs[R3] = RxENAB | Rx8;\n\t\tup->curregs[R5] = TxENAB | Tx8;\n\t\tup->curregs[R6] = 0x00;  \n\t\tup->curregs[R7] = 0x7E;  \n\t\tup->curregs[R9] = NV;\n\t\tup->curregs[R7p] = 0x00;\n\t\tsunzilog_init_kbdms(up);\n\t\t \n\t\tif (up->flags & SUNZILOG_FLAG_ISR_HANDLER)\n\t\t\tup->curregs[R9] |= MIE;\n\t\twrite_zsreg(channel, R9, up->curregs[R9]);\n\t} else {\n\t\t \n\t\tup->parity_mask = 0xff;\n\t\tup->curregs[R1] = EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB;\n\t\tup->curregs[R4] = PAR_EVEN | X16CLK | SB1;\n\t\tup->curregs[R3] = RxENAB | Rx8;\n\t\tup->curregs[R5] = TxENAB | Tx8;\n\t\tup->curregs[R6] = 0x00;  \n\t\tup->curregs[R7] = 0x7E;  \n\t\tup->curregs[R9] = NV;\n\t\tup->curregs[R10] = NRZ;\n\t\tup->curregs[R11] = TCBR | RCBR;\n\t\tbaud = 9600;\n\t\tbrg = BPS_TO_BRG(baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\n\t\tup->curregs[R12] = (brg & 0xff);\n\t\tup->curregs[R13] = (brg >> 8) & 0xff;\n\t\tup->curregs[R14] = BRSRC | BRENAB;\n\t\tup->curregs[R15] = FIFOEN;  \n\t\tup->curregs[R7p] = TxFIFO_LVL | RxFIFO_LVL;\n\t\tif (__load_zsregs(channel, up->curregs)) {\n\t\t\tup->flags |= SUNZILOG_FLAG_ESCC;\n\t\t}\n\t\t \n\t\tif (up->flags & SUNZILOG_FLAG_ISR_HANDLER)\n\t\t\tup->curregs[R9] |= MIE;\n\t\twrite_zsreg(channel, R9, up->curregs[R9]);\n\t}\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n#ifdef CONFIG_SERIO\n\tif (up->flags & (SUNZILOG_FLAG_CONS_KEYB |\n\t\t\t SUNZILOG_FLAG_CONS_MOUSE))\n\t\tsunzilog_register_serio(up);\n#endif\n}\n\nstatic int zilog_irq;\n\nstatic int zs_probe(struct platform_device *op)\n{\n\tstatic int kbm_inst, uart_inst;\n\tint inst;\n\tstruct uart_sunzilog_port *up;\n\tstruct zilog_layout __iomem *rp;\n\tint keyboard_mouse = 0;\n\tint err;\n\n\tif (of_property_present(op->dev.of_node, \"keyboard\"))\n\t\tkeyboard_mouse = 1;\n\n\t \n\tif (keyboard_mouse)\n\t\tinst = uart_chip_count + kbm_inst;\n\telse\n\t\tinst = uart_inst;\n\n\tsunzilog_chip_regs[inst] = of_ioremap(&op->resource[0], 0,\n\t\t\t\t\t      sizeof(struct zilog_layout),\n\t\t\t\t\t      \"zs\");\n\tif (!sunzilog_chip_regs[inst])\n\t\treturn -ENOMEM;\n\n\trp = sunzilog_chip_regs[inst];\n\n\tif (!zilog_irq)\n\t\tzilog_irq = op->archdata.irqs[0];\n\n\tup = &sunzilog_port_table[inst * 2];\n\n\t \n\tup[0].port.mapbase = op->resource[0].start + 0x00;\n\tup[0].port.membase = (void __iomem *) &rp->channelA;\n\tup[0].port.iotype = UPIO_MEM;\n\tup[0].port.irq = op->archdata.irqs[0];\n\tup[0].port.uartclk = ZS_CLOCK;\n\tup[0].port.fifosize = 1;\n\tup[0].port.ops = &sunzilog_pops;\n\tup[0].port.type = PORT_SUNZILOG;\n\tup[0].port.flags = 0;\n\tup[0].port.line = (inst * 2) + 0;\n\tup[0].port.dev = &op->dev;\n\tup[0].flags |= SUNZILOG_FLAG_IS_CHANNEL_A;\n\tup[0].port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_SUNZILOG_CONSOLE);\n\tif (keyboard_mouse)\n\t\tup[0].flags |= SUNZILOG_FLAG_CONS_KEYB;\n\tsunzilog_init_hw(&up[0]);\n\n\t \n\tup[1].port.mapbase = op->resource[0].start + 0x04;\n\tup[1].port.membase = (void __iomem *) &rp->channelB;\n\tup[1].port.iotype = UPIO_MEM;\n\tup[1].port.irq = op->archdata.irqs[0];\n\tup[1].port.uartclk = ZS_CLOCK;\n\tup[1].port.fifosize = 1;\n\tup[1].port.ops = &sunzilog_pops;\n\tup[1].port.type = PORT_SUNZILOG;\n\tup[1].port.flags = 0;\n\tup[1].port.line = (inst * 2) + 1;\n\tup[1].port.dev = &op->dev;\n\tup[1].flags |= 0;\n\tup[1].port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_SUNZILOG_CONSOLE);\n\tif (keyboard_mouse)\n\t\tup[1].flags |= SUNZILOG_FLAG_CONS_MOUSE;\n\tsunzilog_init_hw(&up[1]);\n\n\tif (!keyboard_mouse) {\n\t\tif (sunserial_console_match(SUNZILOG_CONSOLE(), op->dev.of_node,\n\t\t\t\t\t    &sunzilog_reg, up[0].port.line,\n\t\t\t\t\t    false))\n\t\t\tup->flags |= SUNZILOG_FLAG_IS_CONS;\n\t\terr = uart_add_one_port(&sunzilog_reg, &up[0].port);\n\t\tif (err) {\n\t\t\tof_iounmap(&op->resource[0],\n\t\t\t\t   rp, sizeof(struct zilog_layout));\n\t\t\treturn err;\n\t\t}\n\t\tif (sunserial_console_match(SUNZILOG_CONSOLE(), op->dev.of_node,\n\t\t\t\t\t    &sunzilog_reg, up[1].port.line,\n\t\t\t\t\t    false))\n\t\t\tup->flags |= SUNZILOG_FLAG_IS_CONS;\n\t\terr = uart_add_one_port(&sunzilog_reg, &up[1].port);\n\t\tif (err) {\n\t\t\tuart_remove_one_port(&sunzilog_reg, &up[0].port);\n\t\t\tof_iounmap(&op->resource[0],\n\t\t\t\t   rp, sizeof(struct zilog_layout));\n\t\t\treturn err;\n\t\t}\n\t\tuart_inst++;\n\t} else {\n\t\tprintk(KERN_INFO \"%s: Keyboard at MMIO 0x%llx (irq = %d) \"\n\t\t       \"is a %s\\n\",\n\t\t       dev_name(&op->dev),\n\t\t       (unsigned long long) up[0].port.mapbase,\n\t\t       op->archdata.irqs[0], sunzilog_type(&up[0].port));\n\t\tprintk(KERN_INFO \"%s: Mouse at MMIO 0x%llx (irq = %d) \"\n\t\t       \"is a %s\\n\",\n\t\t       dev_name(&op->dev),\n\t\t       (unsigned long long) up[1].port.mapbase,\n\t\t       op->archdata.irqs[0], sunzilog_type(&up[1].port));\n\t\tkbm_inst++;\n\t}\n\n\tplatform_set_drvdata(op, &up[0]);\n\n\treturn 0;\n}\n\nstatic void zs_remove_one(struct uart_sunzilog_port *up)\n{\n\tif (ZS_IS_KEYB(up) || ZS_IS_MOUSE(up)) {\n#ifdef CONFIG_SERIO\n\t\tserio_unregister_port(&up->serio);\n#endif\n\t} else\n\t\tuart_remove_one_port(&sunzilog_reg, &up->port);\n}\n\nstatic int zs_remove(struct platform_device *op)\n{\n\tstruct uart_sunzilog_port *up = platform_get_drvdata(op);\n\tstruct zilog_layout __iomem *regs;\n\n\tzs_remove_one(&up[0]);\n\tzs_remove_one(&up[1]);\n\n\tregs = sunzilog_chip_regs[up[0].port.line / 2];\n\tof_iounmap(&op->resource[0], regs, sizeof(struct zilog_layout));\n\n\treturn 0;\n}\n\nstatic const struct of_device_id zs_match[] = {\n\t{\n\t\t.name = \"zs\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, zs_match);\n\nstatic struct platform_driver zs_driver = {\n\t.driver = {\n\t\t.name = \"zs\",\n\t\t.of_match_table = zs_match,\n\t},\n\t.probe\t\t= zs_probe,\n\t.remove\t\t= zs_remove,\n};\n\nstatic int __init sunzilog_init(void)\n{\n\tstruct device_node *dp;\n\tint err;\n\tint num_keybms = 0;\n\tint num_sunzilog = 0;\n\n\tfor_each_node_by_name(dp, \"zs\") {\n\t\tnum_sunzilog++;\n\t\tif (of_property_present(dp, \"keyboard\"))\n\t\t\tnum_keybms++;\n\t}\n\n\tif (num_sunzilog) {\n\t\terr = sunzilog_alloc_tables(num_sunzilog);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tuart_chip_count = num_sunzilog - num_keybms;\n\n\t\terr = sunserial_register_minors(&sunzilog_reg,\n\t\t\t\t\t\tuart_chip_count * 2);\n\t\tif (err)\n\t\t\tgoto out_free_tables;\n\t}\n\n\terr = platform_driver_register(&zs_driver);\n\tif (err)\n\t\tgoto out_unregister_uart;\n\n\tif (zilog_irq) {\n\t\tstruct uart_sunzilog_port *up = sunzilog_irq_chain;\n\t\terr = request_irq(zilog_irq, sunzilog_interrupt, IRQF_SHARED,\n\t\t\t\t  \"zs\", sunzilog_irq_chain);\n\t\tif (err)\n\t\t\tgoto out_unregister_driver;\n\n\t\t \n\t\twhile (up) {\n\t\t\tstruct zilog_channel __iomem *channel;\n\n\t\t\t \n\t\t\tchannel          = ZILOG_CHANNEL_FROM_PORT(&up->port);\n\t\t\tup->flags       |= SUNZILOG_FLAG_ISR_HANDLER;\n\t\t\tup->curregs[R9] |= MIE;\n\t\t\twrite_zsreg(channel, R9, up->curregs[R9]);\n\t\t\tup = up->next;\n\t\t}\n\t}\n\nout:\n\treturn err;\n\nout_unregister_driver:\n\tplatform_driver_unregister(&zs_driver);\n\nout_unregister_uart:\n\tif (num_sunzilog) {\n\t\tsunserial_unregister_minors(&sunzilog_reg, num_sunzilog);\n\t\tsunzilog_reg.cons = NULL;\n\t}\n\nout_free_tables:\n\tsunzilog_free_tables();\n\tgoto out;\n}\n\nstatic void __exit sunzilog_exit(void)\n{\n\tplatform_driver_unregister(&zs_driver);\n\n\tif (zilog_irq) {\n\t\tstruct uart_sunzilog_port *up = sunzilog_irq_chain;\n\n\t\t \n\t\twhile (up) {\n\t\t\tstruct zilog_channel __iomem *channel;\n\n\t\t\t \n\t\t\tchannel          = ZILOG_CHANNEL_FROM_PORT(&up->port);\n\t\t\tup->flags       &= ~SUNZILOG_FLAG_ISR_HANDLER;\n\t\t\tup->curregs[R9] &= ~MIE;\n\t\t\twrite_zsreg(channel, R9, up->curregs[R9]);\n\t\t\tup = up->next;\n\t\t}\n\n\t\tfree_irq(zilog_irq, sunzilog_irq_chain);\n\t\tzilog_irq = 0;\n\t}\n\n\tif (sunzilog_reg.nr) {\n\t\tsunserial_unregister_minors(&sunzilog_reg, sunzilog_reg.nr);\n\t\tsunzilog_free_tables();\n\t}\n}\n\nmodule_init(sunzilog_init);\nmodule_exit(sunzilog_exit);\n\nMODULE_AUTHOR(\"David S. Miller\");\nMODULE_DESCRIPTION(\"Sun Zilog serial port driver\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}