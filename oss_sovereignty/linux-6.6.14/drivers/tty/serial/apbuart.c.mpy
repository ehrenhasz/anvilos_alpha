{
  "module_name": "apbuart.c",
  "hash_id": "8ae8db26fb57960cc411a6fe4dd2269d489ca9af73e9838c8345ea1741298a9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/apbuart.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/serial.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/kthread.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/serial_core.h>\n#include <asm/irq.h>\n\n#include \"apbuart.h\"\n\n#define SERIAL_APBUART_MAJOR\tTTY_MAJOR\n#define SERIAL_APBUART_MINOR\t64\n#define UART_DUMMY_RSR_RX\t0x8000\t \n\nstatic void apbuart_tx_chars(struct uart_port *port);\n\nstatic void apbuart_stop_tx(struct uart_port *port)\n{\n\tunsigned int cr;\n\n\tcr = UART_GET_CTRL(port);\n\tcr &= ~UART_CTRL_TI;\n\tUART_PUT_CTRL(port, cr);\n}\n\nstatic void apbuart_start_tx(struct uart_port *port)\n{\n\tunsigned int cr;\n\n\tcr = UART_GET_CTRL(port);\n\tcr |= UART_CTRL_TI;\n\tUART_PUT_CTRL(port, cr);\n\n\tif (UART_GET_STATUS(port) & UART_STATUS_THE)\n\t\tapbuart_tx_chars(port);\n}\n\nstatic void apbuart_stop_rx(struct uart_port *port)\n{\n\tunsigned int cr;\n\n\tcr = UART_GET_CTRL(port);\n\tcr &= ~(UART_CTRL_RI);\n\tUART_PUT_CTRL(port, cr);\n}\n\nstatic void apbuart_rx_chars(struct uart_port *port)\n{\n\tunsigned int status, rsr;\n\tunsigned int max_chars = port->fifosize;\n\tu8 ch, flag;\n\n\tstatus = UART_GET_STATUS(port);\n\n\twhile (UART_RX_DATA(status) && (max_chars--)) {\n\n\t\tch = UART_GET_CHAR(port);\n\t\tflag = TTY_NORMAL;\n\n\t\tport->icount.rx++;\n\n\t\trsr = UART_GET_STATUS(port) | UART_DUMMY_RSR_RX;\n\t\tUART_PUT_STATUS(port, 0);\n\t\tif (rsr & UART_STATUS_ERR) {\n\n\t\t\tif (rsr & UART_STATUS_BR) {\n\t\t\t\trsr &= ~(UART_STATUS_FE | UART_STATUS_PE);\n\t\t\t\tport->icount.brk++;\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tgoto ignore_char;\n\t\t\t} else if (rsr & UART_STATUS_PE) {\n\t\t\t\tport->icount.parity++;\n\t\t\t} else if (rsr & UART_STATUS_FE) {\n\t\t\t\tport->icount.frame++;\n\t\t\t}\n\t\t\tif (rsr & UART_STATUS_OE)\n\t\t\t\tport->icount.overrun++;\n\n\t\t\trsr &= port->read_status_mask;\n\n\t\t\tif (rsr & UART_STATUS_PE)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (rsr & UART_STATUS_FE)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tgoto ignore_char;\n\n\t\tuart_insert_char(port, rsr, UART_STATUS_OE, ch, flag);\n\n\n\t      ignore_char:\n\t\tstatus = UART_GET_STATUS(port);\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic void apbuart_tx_chars(struct uart_port *port)\n{\n\tu8 ch;\n\n\tuart_port_tx_limited(port, ch, port->fifosize,\n\t\ttrue,\n\t\tUART_PUT_CHAR(port, ch),\n\t\t({}));\n}\n\nstatic irqreturn_t apbuart_int(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tunsigned int status;\n\n\tspin_lock(&port->lock);\n\n\tstatus = UART_GET_STATUS(port);\n\tif (status & UART_STATUS_DR)\n\t\tapbuart_rx_chars(port);\n\tif (status & UART_STATUS_THE)\n\t\tapbuart_tx_chars(port);\n\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int apbuart_tx_empty(struct uart_port *port)\n{\n\tunsigned int status = UART_GET_STATUS(port);\n\treturn status & UART_STATUS_THE ? TIOCSER_TEMT : 0;\n}\n\nstatic unsigned int apbuart_get_mctrl(struct uart_port *port)\n{\n\t \n\treturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n}\n\nstatic void apbuart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\t \n}\n\nstatic void apbuart_break_ctl(struct uart_port *port, int break_state)\n{\n\t \n}\n\nstatic int apbuart_startup(struct uart_port *port)\n{\n\tint retval;\n\tunsigned int cr;\n\n\t \n\tretval = request_irq(port->irq, apbuart_int, 0, \"apbuart\", port);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tcr = UART_GET_CTRL(port);\n\tUART_PUT_CTRL(port,\n\t\t      cr | UART_CTRL_RE | UART_CTRL_TE |\n\t\t      UART_CTRL_RI | UART_CTRL_TI);\n\n\treturn 0;\n}\n\nstatic void apbuart_shutdown(struct uart_port *port)\n{\n\tunsigned int cr;\n\n\t \n\tcr = UART_GET_CTRL(port);\n\tUART_PUT_CTRL(port,\n\t\t      cr & ~(UART_CTRL_RE | UART_CTRL_TE |\n\t\t\t     UART_CTRL_RI | UART_CTRL_TI));\n\n\t \n\tfree_irq(port->irq, port);\n}\n\nstatic void apbuart_set_termios(struct uart_port *port,\n\t\t\t\tstruct ktermios *termios, const struct ktermios *old)\n{\n\tunsigned int cr;\n\tunsigned long flags;\n\tunsigned int baud, quot;\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\n\tif (baud == 0)\n\t\tpanic(\"invalid baudrate %i\\n\", port->uartclk / 16);\n\n\t \n\tquot = (uart_get_divisor(port, baud)) * 2;\n\tcr = UART_GET_CTRL(port);\n\tcr &= ~(UART_CTRL_PE | UART_CTRL_PS);\n\n\tif (termios->c_cflag & PARENB) {\n\t\tcr |= UART_CTRL_PE;\n\t\tif ((termios->c_cflag & PARODD))\n\t\t\tcr |= UART_CTRL_PS;\n\t}\n\n\t \n\tif (termios->c_cflag & CRTSCTS)\n\t\tcr |= UART_CTRL_FL;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tport->read_status_mask = UART_STATUS_OE;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= UART_STATUS_FE | UART_STATUS_PE;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= UART_STATUS_FE | UART_STATUS_PE;\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= UART_DUMMY_RSR_RX;\n\n\t \n\tquot -= 1;\n\tUART_PUT_SCAL(port, quot);\n\tUART_PUT_CTRL(port, cr);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *apbuart_type(struct uart_port *port)\n{\n\treturn port->type == PORT_APBUART ? \"GRLIB/APBUART\" : NULL;\n}\n\nstatic void apbuart_release_port(struct uart_port *port)\n{\n\trelease_mem_region(port->mapbase, 0x100);\n}\n\nstatic int apbuart_request_port(struct uart_port *port)\n{\n\treturn request_mem_region(port->mapbase, 0x100, \"grlib-apbuart\")\n\t    != NULL ? 0 : -EBUSY;\n\treturn 0;\n}\n\n \nstatic void apbuart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_APBUART;\n\t\tapbuart_request_port(port);\n\t}\n}\n\n \nstatic int apbuart_verify_port(struct uart_port *port,\n\t\t\t       struct serial_struct *ser)\n{\n\tint ret = 0;\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_APBUART)\n\t\tret = -EINVAL;\n\tif (ser->irq < 0 || ser->irq >= NR_IRQS)\n\t\tret = -EINVAL;\n\tif (ser->baud_base < 9600)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\nstatic const struct uart_ops grlib_apbuart_ops = {\n\t.tx_empty = apbuart_tx_empty,\n\t.set_mctrl = apbuart_set_mctrl,\n\t.get_mctrl = apbuart_get_mctrl,\n\t.stop_tx = apbuart_stop_tx,\n\t.start_tx = apbuart_start_tx,\n\t.stop_rx = apbuart_stop_rx,\n\t.break_ctl = apbuart_break_ctl,\n\t.startup = apbuart_startup,\n\t.shutdown = apbuart_shutdown,\n\t.set_termios = apbuart_set_termios,\n\t.type = apbuart_type,\n\t.release_port = apbuart_release_port,\n\t.request_port = apbuart_request_port,\n\t.config_port = apbuart_config_port,\n\t.verify_port = apbuart_verify_port,\n};\n\nstatic struct uart_port grlib_apbuart_ports[UART_NR];\nstatic struct device_node *grlib_apbuart_nodes[UART_NR];\n\nstatic int apbuart_scan_fifo_size(struct uart_port *port, int portnumber)\n{\n\tint ctrl, loop = 0;\n\tint status;\n\tint fifosize;\n\tunsigned long flags;\n\n\tctrl = UART_GET_CTRL(port);\n\n\t \n\n\tlocal_irq_save(flags);\n\n\tUART_PUT_CTRL(port, ctrl | UART_CTRL_TE);\n\n\twhile (!UART_TX_READY(UART_GET_STATUS(port)))\n\t\tloop++;\n\n\t \n\n\tUART_PUT_CTRL(port, ctrl & ~(UART_CTRL_TE));\n\n\tfifosize = 1;\n\tUART_PUT_CHAR(port, 0);\n\n\t \n\n\tstatus = UART_GET_STATUS(port);\n\twhile (((status >> 20) & 0x3F) == fifosize) {\n\t\tfifosize++;\n\t\tUART_PUT_CHAR(port, 0);\n\t\tstatus = UART_GET_STATUS(port);\n\t}\n\n\tfifosize--;\n\n\tUART_PUT_CTRL(port, ctrl);\n\tlocal_irq_restore(flags);\n\n\tif (fifosize == 0)\n\t\tfifosize = 1;\n\n\treturn fifosize;\n}\n\nstatic void apbuart_flush_fifo(struct uart_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < port->fifosize; i++)\n\t\tUART_GET_CHAR(port);\n}\n\n\n \n \n \n\n#ifdef CONFIG_SERIAL_GRLIB_GAISLER_APBUART_CONSOLE\n\nstatic void apbuart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tunsigned int status;\n\tdo {\n\t\tstatus = UART_GET_STATUS(port);\n\t} while (!UART_TX_READY(status));\n\tUART_PUT_CHAR(port, ch);\n}\n\nstatic void\napbuart_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct uart_port *port = &grlib_apbuart_ports[co->index];\n\tunsigned int status, old_cr, new_cr;\n\n\t \n\told_cr = UART_GET_CTRL(port);\n\tnew_cr = old_cr & ~(UART_CTRL_RI | UART_CTRL_TI);\n\tUART_PUT_CTRL(port, new_cr);\n\n\tuart_console_write(port, s, count, apbuart_console_putchar);\n\n\t \n\tdo {\n\t\tstatus = UART_GET_STATUS(port);\n\t} while (!UART_TX_READY(status));\n\tUART_PUT_CTRL(port, old_cr);\n}\n\nstatic void __init\napbuart_console_get_options(struct uart_port *port, int *baud,\n\t\t\t    int *parity, int *bits)\n{\n\tif (UART_GET_CTRL(port) & (UART_CTRL_RE | UART_CTRL_TE)) {\n\n\t\tunsigned int quot, status;\n\t\tstatus = UART_GET_STATUS(port);\n\n\t\t*parity = 'n';\n\t\tif (status & UART_CTRL_PE) {\n\t\t\tif ((status & UART_CTRL_PS) == 0)\n\t\t\t\t*parity = 'e';\n\t\t\telse\n\t\t\t\t*parity = 'o';\n\t\t}\n\n\t\t*bits = 8;\n\t\tquot = UART_GET_SCAL(port) / 8;\n\t\t*baud = port->uartclk / (16 * (quot + 1));\n\t}\n}\n\nstatic int __init apbuart_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint baud = 38400;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tpr_debug(\"apbuart_console_setup co=%p, co->index=%i, options=%s\\n\",\n\t\t co, co->index, options);\n\n\t \n\tif (co->index >= grlib_apbuart_port_nr)\n\t\tco->index = 0;\n\n\tport = &grlib_apbuart_ports[co->index];\n\n\tspin_lock_init(&port->lock);\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse\n\t\tapbuart_console_get_options(port, &baud, &parity, &bits);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver grlib_apbuart_driver;\n\nstatic struct console grlib_apbuart_console = {\n\t.name = \"ttyS\",\n\t.write = apbuart_console_write,\n\t.device = uart_console_device,\n\t.setup = apbuart_console_setup,\n\t.flags = CON_PRINTBUFFER,\n\t.index = -1,\n\t.data = &grlib_apbuart_driver,\n};\n\n\nstatic int grlib_apbuart_configure(void);\n\nstatic int __init apbuart_console_init(void)\n{\n\tif (grlib_apbuart_configure())\n\t\treturn -ENODEV;\n\tregister_console(&grlib_apbuart_console);\n\treturn 0;\n}\n\nconsole_initcall(apbuart_console_init);\n\n#define APBUART_CONSOLE\t(&grlib_apbuart_console)\n#else\n#define APBUART_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver grlib_apbuart_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = \"serial\",\n\t.dev_name = \"ttyS\",\n\t.major = SERIAL_APBUART_MAJOR,\n\t.minor = SERIAL_APBUART_MINOR,\n\t.nr = UART_NR,\n\t.cons = APBUART_CONSOLE,\n};\n\n\n \n \n \n\nstatic int apbuart_probe(struct platform_device *op)\n{\n\tint i;\n\tstruct uart_port *port = NULL;\n\n\tfor (i = 0; i < grlib_apbuart_port_nr; i++) {\n\t\tif (op->dev.of_node == grlib_apbuart_nodes[i])\n\t\t\tbreak;\n\t}\n\n\tport = &grlib_apbuart_ports[i];\n\tport->dev = &op->dev;\n\tport->irq = op->archdata.irqs[0];\n\n\tuart_add_one_port(&grlib_apbuart_driver, (struct uart_port *) port);\n\n\tapbuart_flush_fifo((struct uart_port *) port);\n\n\tprintk(KERN_INFO \"grlib-apbuart at 0x%llx, irq %d\\n\",\n\t       (unsigned long long) port->mapbase, port->irq);\n\treturn 0;\n}\n\nstatic const struct of_device_id apbuart_match[] = {\n\t{\n\t .name = \"GAISLER_APBUART\",\n\t },\n\t{\n\t .name = \"01_00c\",\n\t },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, apbuart_match);\n\nstatic struct platform_driver grlib_apbuart_of_driver = {\n\t.probe = apbuart_probe,\n\t.driver = {\n\t\t.name = \"grlib-apbuart\",\n\t\t.of_match_table = apbuart_match,\n\t},\n};\n\n\nstatic int __init grlib_apbuart_configure(void)\n{\n\tstruct device_node *np;\n\tint line = 0;\n\n\tfor_each_matching_node(np, apbuart_match) {\n\t\tconst int *ampopts;\n\t\tconst u32 *freq_hz;\n\t\tconst struct amba_prom_registers *regs;\n\t\tstruct uart_port *port;\n\t\tunsigned long addr;\n\n\t\tampopts = of_get_property(np, \"ampopts\", NULL);\n\t\tif (ampopts && (*ampopts == 0))\n\t\t\tcontinue;  \n\t\tregs = of_get_property(np, \"reg\", NULL);\n\t\t \n\t\tfreq_hz = of_get_property(np, \"freq\", NULL);\n\n\t\tif (!regs || !freq_hz || (*freq_hz == 0))\n\t\t\tcontinue;\n\n\t\tgrlib_apbuart_nodes[line] = np;\n\n\t\taddr = regs->phys_addr;\n\n\t\tport = &grlib_apbuart_ports[line];\n\n\t\tport->mapbase = addr;\n\t\tport->membase = ioremap(addr, sizeof(struct grlib_apbuart_regs_map));\n\t\tport->irq = 0;\n\t\tport->iotype = UPIO_MEM;\n\t\tport->ops = &grlib_apbuart_ops;\n\t\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_GRLIB_GAISLER_APBUART_CONSOLE);\n\t\tport->flags = UPF_BOOT_AUTOCONF;\n\t\tport->line = line;\n\t\tport->uartclk = *freq_hz;\n\t\tport->fifosize = apbuart_scan_fifo_size((struct uart_port *) port, line);\n\t\tline++;\n\n\t\t \n\t\tif (line == UART_NR)\n\t\t\tbreak;\n\t}\n\n\tgrlib_apbuart_driver.nr = grlib_apbuart_port_nr = line;\n\treturn line ? 0 : -ENODEV;\n}\n\nstatic int __init grlib_apbuart_init(void)\n{\n\tint ret;\n\n\t \n\tret = grlib_apbuart_configure();\n\tif (ret)\n\t\treturn ret;\n\n\tprintk(KERN_INFO \"Serial: GRLIB APBUART driver\\n\");\n\n\tret = uart_register_driver(&grlib_apbuart_driver);\n\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: uart_register_driver failed (%i)\\n\",\n\t\t       __FILE__, ret);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&grlib_apbuart_of_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: platform_driver_register failed (%i)\\n\",\n\t\t       __FILE__, ret);\n\t\tuart_unregister_driver(&grlib_apbuart_driver);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit grlib_apbuart_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < grlib_apbuart_port_nr; i++)\n\t\tuart_remove_one_port(&grlib_apbuart_driver,\n\t\t\t\t     &grlib_apbuart_ports[i]);\n\n\tuart_unregister_driver(&grlib_apbuart_driver);\n\tplatform_driver_unregister(&grlib_apbuart_of_driver);\n}\n\nmodule_init(grlib_apbuart_init);\nmodule_exit(grlib_apbuart_exit);\n\nMODULE_AUTHOR(\"Aeroflex Gaisler AB\");\nMODULE_DESCRIPTION(\"GRLIB APBUART serial driver\");\nMODULE_VERSION(\"2.1\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}