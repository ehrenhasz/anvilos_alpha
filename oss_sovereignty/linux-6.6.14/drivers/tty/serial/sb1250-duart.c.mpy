{
  "module_name": "sb1250-duart.c",
  "hash_id": "22146b127e2c979b6b96e6430f09a678123ecb4d218879bb84992c93f88d8793",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sb1250-duart.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/major.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/spinlock.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/types.h>\n\n#include <linux/refcount.h>\n#include <linux/io.h>\n\n#include <asm/sibyte/sb1250.h>\n#include <asm/sibyte/sb1250_uart.h>\n#include <asm/sibyte/swarm.h>\n\n\n#if defined(CONFIG_SIBYTE_BCM1x80)\n#include <asm/sibyte/bcm1480_regs.h>\n#include <asm/sibyte/bcm1480_int.h>\n\n#define SBD_CHANREGS(line)\tA_BCM1480_DUART_CHANREG((line), 0)\n#define SBD_CTRLREGS(line)\tA_BCM1480_DUART_CTRLREG((line), 0)\n#define SBD_INT(line)\t\t(K_BCM1480_INT_UART_0 + (line))\n\n#define DUART_CHANREG_SPACING\tBCM1480_DUART_CHANREG_SPACING\n\n#define R_DUART_IMRREG(line)\tR_BCM1480_DUART_IMRREG(line)\n#define R_DUART_INCHREG(line)\tR_BCM1480_DUART_INCHREG(line)\n#define R_DUART_ISRREG(line)\tR_BCM1480_DUART_ISRREG(line)\n\n#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)\n#include <asm/sibyte/sb1250_regs.h>\n#include <asm/sibyte/sb1250_int.h>\n\n#define SBD_CHANREGS(line)\tA_DUART_CHANREG((line), 0)\n#define SBD_CTRLREGS(line)\tA_DUART_CTRLREG(0)\n#define SBD_INT(line)\t\t(K_INT_UART_0 + (line))\n\n#else\n#error invalid SB1250 UART configuration\n\n#endif\n\n\nMODULE_AUTHOR(\"Maciej W. Rozycki <macro@linux-mips.org>\");\nMODULE_DESCRIPTION(\"BCM1xxx on-chip DUART serial driver\");\nMODULE_LICENSE(\"GPL\");\n\n\n#define DUART_MAX_CHIP 2\n#define DUART_MAX_SIDE 2\n\n \nstruct sbd_port {\n\tstruct sbd_duart\t*duart;\n\tstruct uart_port\tport;\n\tunsigned char __iomem\t*memctrl;\n\tint\t\t\ttx_stopped;\n\tint\t\t\tinitialised;\n};\n\n \nstruct sbd_duart {\n\tstruct sbd_port\t\tsport[2];\n\tunsigned long\t\tmapctrl;\n\trefcount_t\t\tmap_guard;\n};\n\n#define to_sport(uport) container_of(uport, struct sbd_port, port)\n\nstatic struct sbd_duart sbd_duarts[DUART_MAX_CHIP];\n\n\n \nstatic u64 __read_sbdchn(struct sbd_port *sport, int reg)\n{\n\tvoid __iomem *csr = sport->port.membase + reg;\n\n\treturn __raw_readq(csr);\n}\n\nstatic u64 __read_sbdshr(struct sbd_port *sport, int reg)\n{\n\tvoid __iomem *csr = sport->memctrl + reg;\n\n\treturn __raw_readq(csr);\n}\n\nstatic void __write_sbdchn(struct sbd_port *sport, int reg, u64 value)\n{\n\tvoid __iomem *csr = sport->port.membase + reg;\n\n\t__raw_writeq(value, csr);\n}\n\nstatic void __write_sbdshr(struct sbd_port *sport, int reg, u64 value)\n{\n\tvoid __iomem *csr = sport->memctrl + reg;\n\n\t__raw_writeq(value, csr);\n}\n\n \nstatic void __war_sbd1956(struct sbd_port *sport)\n{\n\t__read_sbdchn(sport, R_DUART_MODE_REG_1);\n\t__read_sbdchn(sport, R_DUART_MODE_REG_2);\n}\n\nstatic unsigned char read_sbdchn(struct sbd_port *sport, int reg)\n{\n\tunsigned char retval;\n\n\tretval = __read_sbdchn(sport, reg);\n\tif (IS_ENABLED(CONFIG_SB1_PASS_2_WORKAROUNDS))\n\t\t__war_sbd1956(sport);\n\treturn retval;\n}\n\nstatic unsigned char read_sbdshr(struct sbd_port *sport, int reg)\n{\n\tunsigned char retval;\n\n\tretval = __read_sbdshr(sport, reg);\n\tif (IS_ENABLED(CONFIG_SB1_PASS_2_WORKAROUNDS))\n\t\t__war_sbd1956(sport);\n\treturn retval;\n}\n\nstatic void write_sbdchn(struct sbd_port *sport, int reg, unsigned int value)\n{\n\t__write_sbdchn(sport, reg, value);\n\tif (IS_ENABLED(CONFIG_SB1_PASS_2_WORKAROUNDS))\n\t\t__war_sbd1956(sport);\n}\n\nstatic void write_sbdshr(struct sbd_port *sport, int reg, unsigned int value)\n{\n\t__write_sbdshr(sport, reg, value);\n\tif (IS_ENABLED(CONFIG_SB1_PASS_2_WORKAROUNDS))\n\t\t__war_sbd1956(sport);\n}\n\n\nstatic int sbd_receive_ready(struct sbd_port *sport)\n{\n\treturn read_sbdchn(sport, R_DUART_STATUS) & M_DUART_RX_RDY;\n}\n\nstatic int sbd_receive_drain(struct sbd_port *sport)\n{\n\tint loops = 10000;\n\n\twhile (sbd_receive_ready(sport) && --loops)\n\t\tread_sbdchn(sport, R_DUART_RX_HOLD);\n\treturn loops;\n}\n\nstatic int __maybe_unused sbd_transmit_ready(struct sbd_port *sport)\n{\n\treturn read_sbdchn(sport, R_DUART_STATUS) & M_DUART_TX_RDY;\n}\n\nstatic int __maybe_unused sbd_transmit_drain(struct sbd_port *sport)\n{\n\tint loops = 10000;\n\n\twhile (!sbd_transmit_ready(sport) && --loops)\n\t\tudelay(2);\n\treturn loops;\n}\n\nstatic int sbd_transmit_empty(struct sbd_port *sport)\n{\n\treturn read_sbdchn(sport, R_DUART_STATUS) & M_DUART_TX_EMT;\n}\n\nstatic int sbd_line_drain(struct sbd_port *sport)\n{\n\tint loops = 10000;\n\n\twhile (!sbd_transmit_empty(sport) && --loops)\n\t\tudelay(2);\n\treturn loops;\n}\n\n\nstatic unsigned int sbd_tx_empty(struct uart_port *uport)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\n\treturn sbd_transmit_empty(sport) ? TIOCSER_TEMT : 0;\n}\n\nstatic unsigned int sbd_get_mctrl(struct uart_port *uport)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\tunsigned int mctrl, status;\n\n\tstatus = read_sbdshr(sport, R_DUART_IN_PORT);\n\tstatus >>= (uport->line) % 2;\n\tmctrl = (!(status & M_DUART_IN_PIN0_VAL) ? TIOCM_CTS : 0) |\n\t\t(!(status & M_DUART_IN_PIN4_VAL) ? TIOCM_CAR : 0) |\n\t\t(!(status & M_DUART_RIN0_PIN) ? TIOCM_RNG : 0) |\n\t\t(!(status & M_DUART_IN_PIN2_VAL) ? TIOCM_DSR : 0);\n\treturn mctrl;\n}\n\nstatic void sbd_set_mctrl(struct uart_port *uport, unsigned int mctrl)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\tunsigned int clr = 0, set = 0, mode2;\n\n\tif (mctrl & TIOCM_DTR)\n\t\tset |= M_DUART_SET_OPR2;\n\telse\n\t\tclr |= M_DUART_CLR_OPR2;\n\tif (mctrl & TIOCM_RTS)\n\t\tset |= M_DUART_SET_OPR0;\n\telse\n\t\tclr |= M_DUART_CLR_OPR0;\n\tclr <<= (uport->line) % 2;\n\tset <<= (uport->line) % 2;\n\n\tmode2 = read_sbdchn(sport, R_DUART_MODE_REG_2);\n\tmode2 &= ~M_DUART_CHAN_MODE;\n\tif (mctrl & TIOCM_LOOP)\n\t\tmode2 |= V_DUART_CHAN_MODE_LCL_LOOP;\n\telse\n\t\tmode2 |= V_DUART_CHAN_MODE_NORMAL;\n\n\twrite_sbdshr(sport, R_DUART_CLEAR_OPR, clr);\n\twrite_sbdshr(sport, R_DUART_SET_OPR, set);\n\twrite_sbdchn(sport, R_DUART_MODE_REG_2, mode2);\n}\n\nstatic void sbd_stop_tx(struct uart_port *uport)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\n\twrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_DIS);\n\tsport->tx_stopped = 1;\n};\n\nstatic void sbd_start_tx(struct uart_port *uport)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\tunsigned int mask;\n\n\t \n\tmask = read_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2));\n\tmask |= M_DUART_IMR_TX;\n\twrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2), mask);\n\n\t \n\twrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_EN);\n\tsport->tx_stopped = 0;\n};\n\nstatic void sbd_stop_rx(struct uart_port *uport)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\n\twrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2), 0);\n};\n\nstatic void sbd_enable_ms(struct uart_port *uport)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\n\twrite_sbdchn(sport, R_DUART_AUXCTL_X,\n\t\t     M_DUART_CIN_CHNG_ENA | M_DUART_CTS_CHNG_ENA);\n}\n\nstatic void sbd_break_ctl(struct uart_port *uport, int break_state)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\n\tif (break_state == -1)\n\t\twrite_sbdchn(sport, R_DUART_CMD, V_DUART_MISC_CMD_START_BREAK);\n\telse\n\t\twrite_sbdchn(sport, R_DUART_CMD, V_DUART_MISC_CMD_STOP_BREAK);\n}\n\n\nstatic void sbd_receive_chars(struct sbd_port *sport)\n{\n\tstruct uart_port *uport = &sport->port;\n\tstruct uart_icount *icount;\n\tunsigned int status;\n\tint count;\n\tu8 ch, flag;\n\n\tfor (count = 16; count; count--) {\n\t\tstatus = read_sbdchn(sport, R_DUART_STATUS);\n\t\tif (!(status & M_DUART_RX_RDY))\n\t\t\tbreak;\n\n\t\tch = read_sbdchn(sport, R_DUART_RX_HOLD);\n\n\t\tflag = TTY_NORMAL;\n\n\t\ticount = &uport->icount;\n\t\ticount->rx++;\n\n\t\tif (unlikely(status &\n\t\t\t     (M_DUART_RCVD_BRK | M_DUART_FRM_ERR |\n\t\t\t      M_DUART_PARITY_ERR | M_DUART_OVRUN_ERR))) {\n\t\t\tif (status & M_DUART_RCVD_BRK) {\n\t\t\t\ticount->brk++;\n\t\t\t\tif (uart_handle_break(uport))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (status & M_DUART_FRM_ERR)\n\t\t\t\ticount->frame++;\n\t\t\telse if (status & M_DUART_PARITY_ERR)\n\t\t\t\ticount->parity++;\n\t\t\tif (status & M_DUART_OVRUN_ERR)\n\t\t\t\ticount->overrun++;\n\n\t\t\tstatus &= uport->read_status_mask;\n\t\t\tif (status & M_DUART_RCVD_BRK)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (status & M_DUART_FRM_ERR)\n\t\t\t\tflag = TTY_FRAME;\n\t\t\telse if (status & M_DUART_PARITY_ERR)\n\t\t\t\tflag = TTY_PARITY;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(uport, ch))\n\t\t\tcontinue;\n\n\t\tuart_insert_char(uport, status, M_DUART_OVRUN_ERR, ch, flag);\n\t}\n\n\ttty_flip_buffer_push(&uport->state->port);\n}\n\nstatic void sbd_transmit_chars(struct sbd_port *sport)\n{\n\tstruct uart_port *uport = &sport->port;\n\tstruct circ_buf *xmit = &sport->port.state->xmit;\n\tunsigned int mask;\n\tint stop_tx;\n\n\t \n\tif (sport->port.x_char) {\n\t\twrite_sbdchn(sport, R_DUART_TX_HOLD, sport->port.x_char);\n\t\tsport->port.icount.tx++;\n\t\tsport->port.x_char = 0;\n\t\treturn;\n\t}\n\n\t \n\tstop_tx = (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port));\n\n\t \n\tif (!stop_tx) {\n\t\twrite_sbdchn(sport, R_DUART_TX_HOLD, xmit->buf[xmit->tail]);\n\t\tuart_xmit_advance(&sport->port, 1);\n\n\t\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\t\tuart_write_wakeup(&sport->port);\n\t}\n\n\t \n\tif (stop_tx || uart_circ_empty(xmit)) {\n\t\t \n\t\tmask = read_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2));\n\t\tmask &= ~M_DUART_IMR_TX;\n\t\twrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2), mask);\n\t}\n}\n\nstatic void sbd_status_handle(struct sbd_port *sport)\n{\n\tstruct uart_port *uport = &sport->port;\n\tunsigned int delta;\n\n\tdelta = read_sbdshr(sport, R_DUART_INCHREG((uport->line) % 2));\n\tdelta >>= (uport->line) % 2;\n\n\tif (delta & (M_DUART_IN_PIN0_VAL << S_DUART_IN_PIN_CHNG))\n\t\tuart_handle_cts_change(uport, !(delta & M_DUART_IN_PIN0_VAL));\n\n\tif (delta & (M_DUART_IN_PIN2_VAL << S_DUART_IN_PIN_CHNG))\n\t\tuport->icount.dsr++;\n\n\tif (delta & ((M_DUART_IN_PIN2_VAL | M_DUART_IN_PIN0_VAL) <<\n\t\t     S_DUART_IN_PIN_CHNG))\n\t\twake_up_interruptible(&uport->state->port.delta_msr_wait);\n}\n\nstatic irqreturn_t sbd_interrupt(int irq, void *dev_id)\n{\n\tstruct sbd_port *sport = dev_id;\n\tstruct uart_port *uport = &sport->port;\n\tirqreturn_t status = IRQ_NONE;\n\tunsigned int intstat;\n\tint count;\n\n\tfor (count = 16; count; count--) {\n\t\tintstat = read_sbdshr(sport,\n\t\t\t\t      R_DUART_ISRREG((uport->line) % 2));\n\t\tintstat &= read_sbdshr(sport,\n\t\t\t\t       R_DUART_IMRREG((uport->line) % 2));\n\t\tintstat &= M_DUART_ISR_ALL;\n\t\tif (!intstat)\n\t\t\tbreak;\n\n\t\tif (intstat & M_DUART_ISR_RX)\n\t\t\tsbd_receive_chars(sport);\n\t\tif (intstat & M_DUART_ISR_IN)\n\t\t\tsbd_status_handle(sport);\n\t\tif (intstat & M_DUART_ISR_TX)\n\t\t\tsbd_transmit_chars(sport);\n\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\treturn status;\n}\n\n\nstatic int sbd_startup(struct uart_port *uport)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\tunsigned int mode1;\n\tint ret;\n\n\tret = request_irq(sport->port.irq, sbd_interrupt,\n\t\t\t  IRQF_SHARED, \"sb1250-duart\", sport);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsbd_receive_drain(sport);\n\n\t \n\twrite_sbdchn(sport, R_DUART_CMD, V_DUART_MISC_CMD_RESET_BREAK_INT);\n\tread_sbdshr(sport, R_DUART_INCHREG((uport->line) % 2));\n\n\t \n\tmode1 = read_sbdchn(sport, R_DUART_MODE_REG_1);\n\tmode1 &= ~(M_DUART_RX_IRQ_SEL_RXFULL | M_DUART_TX_IRQ_SEL_TXEMPT);\n\twrite_sbdchn(sport, R_DUART_MODE_REG_1, mode1);\n\n\t \n\twrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_DIS | M_DUART_RX_EN);\n\tsport->tx_stopped = 1;\n\n\t \n\twrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2),\n\t\t     M_DUART_IMR_IN | M_DUART_IMR_RX);\n\n\treturn 0;\n}\n\nstatic void sbd_shutdown(struct uart_port *uport)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\n\twrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_DIS | M_DUART_RX_DIS);\n\tsport->tx_stopped = 1;\n\tfree_irq(sport->port.irq, sport);\n}\n\n\nstatic void sbd_init_port(struct sbd_port *sport)\n{\n\tstruct uart_port *uport = &sport->port;\n\n\tif (sport->initialised)\n\t\treturn;\n\n\t \n\twrite_sbdchn(sport, R_DUART_CMD, V_DUART_MISC_CMD_RESET_TX);\n\twrite_sbdchn(sport, R_DUART_CMD, V_DUART_MISC_CMD_RESET_RX);\n\twrite_sbdchn(sport, R_DUART_MODE_REG_1, V_DUART_BITS_PER_CHAR_8);\n\twrite_sbdchn(sport, R_DUART_MODE_REG_2, 0);\n\twrite_sbdchn(sport, R_DUART_FULL_CTL,\n\t\t     V_DUART_INT_TIME(0) | V_DUART_SIG_FULL(15));\n\twrite_sbdchn(sport, R_DUART_OPCR_X, 0);\n\twrite_sbdchn(sport, R_DUART_AUXCTL_X, 0);\n\twrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2), 0);\n\n\tsport->initialised = 1;\n}\n\nstatic void sbd_set_termios(struct uart_port *uport, struct ktermios *termios,\n\t\t\t    const struct ktermios *old_termios)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\tunsigned int mode1 = 0, mode2 = 0, aux = 0;\n\tunsigned int mode1mask = 0, mode2mask = 0, auxmask = 0;\n\tunsigned int oldmode1, oldmode2, oldaux;\n\tunsigned int baud, brg;\n\tunsigned int command;\n\n\tmode1mask |= ~(M_DUART_PARITY_MODE | M_DUART_PARITY_TYPE_ODD |\n\t\t       M_DUART_BITS_PER_CHAR);\n\tmode2mask |= ~M_DUART_STOP_BIT_LEN_2;\n\tauxmask |= ~M_DUART_CTS_CHNG_ENA;\n\n\t \n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\tcase CS6:\n\t\t \n\t\tmode1mask |= M_DUART_PARITY_MODE;\n\t\tbreak;\n\tcase CS7:\n\t\tmode1 |= V_DUART_BITS_PER_CHAR_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tmode1 |= V_DUART_BITS_PER_CHAR_8;\n\t\tbreak;\n\t}\n\n\t \n\tif (termios->c_cflag & CSTOPB)\n\t\tmode2 |= M_DUART_STOP_BIT_LEN_2;\n\telse\n\t\tmode2 |= M_DUART_STOP_BIT_LEN_1;\n\tif (termios->c_cflag & PARENB)\n\t\tmode1 |= V_DUART_PARITY_MODE_ADD;\n\telse\n\t\tmode1 |= V_DUART_PARITY_MODE_NONE;\n\tif (termios->c_cflag & PARODD)\n\t\tmode1 |= M_DUART_PARITY_TYPE_ODD;\n\telse\n\t\tmode1 |= M_DUART_PARITY_TYPE_EVEN;\n\n\tbaud = uart_get_baud_rate(uport, termios, old_termios, 1200, 5000000);\n\tbrg = V_DUART_BAUD_RATE(baud);\n\t \n\tif (brg > M_DUART_CLK_COUNTER)\n\t\tbrg = M_DUART_CLK_COUNTER;\n\n\tuart_update_timeout(uport, termios->c_cflag, baud);\n\n\tuport->read_status_mask = M_DUART_OVRUN_ERR;\n\tif (termios->c_iflag & INPCK)\n\t\tuport->read_status_mask |= M_DUART_FRM_ERR |\n\t\t\t\t\t   M_DUART_PARITY_ERR;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tuport->read_status_mask |= M_DUART_RCVD_BRK;\n\n\tuport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tuport->ignore_status_mask |= M_DUART_FRM_ERR |\n\t\t\t\t\t     M_DUART_PARITY_ERR;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tuport->ignore_status_mask |= M_DUART_RCVD_BRK;\n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tuport->ignore_status_mask |= M_DUART_OVRUN_ERR;\n\t}\n\n\tif (termios->c_cflag & CREAD)\n\t\tcommand = M_DUART_RX_EN;\n\telse\n\t\tcommand = M_DUART_RX_DIS;\n\n\tif (termios->c_cflag & CRTSCTS)\n\t\taux |= M_DUART_CTS_CHNG_ENA;\n\telse\n\t\taux &= ~M_DUART_CTS_CHNG_ENA;\n\n\tspin_lock(&uport->lock);\n\n\tif (sport->tx_stopped)\n\t\tcommand |= M_DUART_TX_DIS;\n\telse\n\t\tcommand |= M_DUART_TX_EN;\n\n\toldmode1 = read_sbdchn(sport, R_DUART_MODE_REG_1) & mode1mask;\n\toldmode2 = read_sbdchn(sport, R_DUART_MODE_REG_2) & mode2mask;\n\toldaux = read_sbdchn(sport, R_DUART_AUXCTL_X) & auxmask;\n\n\tif (!sport->tx_stopped)\n\t\tsbd_line_drain(sport);\n\twrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_DIS | M_DUART_RX_DIS);\n\n\twrite_sbdchn(sport, R_DUART_MODE_REG_1, mode1 | oldmode1);\n\twrite_sbdchn(sport, R_DUART_MODE_REG_2, mode2 | oldmode2);\n\twrite_sbdchn(sport, R_DUART_CLK_SEL, brg);\n\twrite_sbdchn(sport, R_DUART_AUXCTL_X, aux | oldaux);\n\n\twrite_sbdchn(sport, R_DUART_CMD, command);\n\n\tspin_unlock(&uport->lock);\n}\n\n\nstatic const char *sbd_type(struct uart_port *uport)\n{\n\treturn \"SB1250 DUART\";\n}\n\nstatic void sbd_release_port(struct uart_port *uport)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\tstruct sbd_duart *duart = sport->duart;\n\n\tiounmap(sport->memctrl);\n\tsport->memctrl = NULL;\n\tiounmap(uport->membase);\n\tuport->membase = NULL;\n\n\tif(refcount_dec_and_test(&duart->map_guard))\n\t\trelease_mem_region(duart->mapctrl, DUART_CHANREG_SPACING);\n\trelease_mem_region(uport->mapbase, DUART_CHANREG_SPACING);\n}\n\nstatic int sbd_map_port(struct uart_port *uport)\n{\n\tconst char *err = KERN_ERR \"sbd: Cannot map MMIO\\n\";\n\tstruct sbd_port *sport = to_sport(uport);\n\tstruct sbd_duart *duart = sport->duart;\n\n\tif (!uport->membase)\n\t\tuport->membase = ioremap(uport->mapbase,\n\t\t\t\t\t\t DUART_CHANREG_SPACING);\n\tif (!uport->membase) {\n\t\tprintk(err);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!sport->memctrl)\n\t\tsport->memctrl = ioremap(duart->mapctrl,\n\t\t\t\t\t\t DUART_CHANREG_SPACING);\n\tif (!sport->memctrl) {\n\t\tprintk(err);\n\t\tiounmap(uport->membase);\n\t\tuport->membase = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int sbd_request_port(struct uart_port *uport)\n{\n\tconst char *err = KERN_ERR \"sbd: Unable to reserve MMIO resource\\n\";\n\tstruct sbd_duart *duart = to_sport(uport)->duart;\n\tint ret = 0;\n\n\tif (!request_mem_region(uport->mapbase, DUART_CHANREG_SPACING,\n\t\t\t\t\"sb1250-duart\")) {\n\t\tprintk(err);\n\t\treturn -EBUSY;\n\t}\n\trefcount_inc(&duart->map_guard);\n\tif (refcount_read(&duart->map_guard) == 1) {\n\t\tif (!request_mem_region(duart->mapctrl, DUART_CHANREG_SPACING,\n\t\t\t\t\t\"sb1250-duart\")) {\n\t\t\trefcount_dec(&duart->map_guard);\n\t\t\tprintk(err);\n\t\t\tret = -EBUSY;\n\t\t}\n\t}\n\tif (!ret) {\n\t\tret = sbd_map_port(uport);\n\t\tif (ret) {\n\t\t\tif (refcount_dec_and_test(&duart->map_guard))\n\t\t\t\trelease_mem_region(duart->mapctrl,\n\t\t\t\t\t\t   DUART_CHANREG_SPACING);\n\t\t}\n\t}\n\tif (ret) {\n\t\trelease_mem_region(uport->mapbase, DUART_CHANREG_SPACING);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void sbd_config_port(struct uart_port *uport, int flags)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tif (sbd_request_port(uport))\n\t\t\treturn;\n\n\t\tuport->type = PORT_SB1250_DUART;\n\n\t\tsbd_init_port(sport);\n\t}\n}\n\nstatic int sbd_verify_port(struct uart_port *uport, struct serial_struct *ser)\n{\n\tint ret = 0;\n\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_SB1250_DUART)\n\t\tret = -EINVAL;\n\tif (ser->irq != uport->irq)\n\t\tret = -EINVAL;\n\tif (ser->baud_base != uport->uartclk / 16)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\n\nstatic const struct uart_ops sbd_ops = {\n\t.tx_empty\t= sbd_tx_empty,\n\t.set_mctrl\t= sbd_set_mctrl,\n\t.get_mctrl\t= sbd_get_mctrl,\n\t.stop_tx\t= sbd_stop_tx,\n\t.start_tx\t= sbd_start_tx,\n\t.stop_rx\t= sbd_stop_rx,\n\t.enable_ms\t= sbd_enable_ms,\n\t.break_ctl\t= sbd_break_ctl,\n\t.startup\t= sbd_startup,\n\t.shutdown\t= sbd_shutdown,\n\t.set_termios\t= sbd_set_termios,\n\t.type\t\t= sbd_type,\n\t.release_port\t= sbd_release_port,\n\t.request_port\t= sbd_request_port,\n\t.config_port\t= sbd_config_port,\n\t.verify_port\t= sbd_verify_port,\n};\n\n \nstatic void __init sbd_probe_duarts(void)\n{\n\tstatic int probed;\n\tint chip, side;\n\tint max_lines, line;\n\n\tif (probed)\n\t\treturn;\n\n\t \n\tswitch (soc_type) {\n\tcase K_SYS_SOC_TYPE_BCM1x55:\n\tcase K_SYS_SOC_TYPE_BCM1x80:\n\t\tmax_lines = 4;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tmax_lines = 2;\n\t\tbreak;\n\t}\n\n\tprobed = 1;\n\n\tfor (chip = 0, line = 0; chip < DUART_MAX_CHIP && line < max_lines;\n\t     chip++) {\n\t\tsbd_duarts[chip].mapctrl = SBD_CTRLREGS(line);\n\n\t\tfor (side = 0; side < DUART_MAX_SIDE && line < max_lines;\n\t\t     side++, line++) {\n\t\t\tstruct sbd_port *sport = &sbd_duarts[chip].sport[side];\n\t\t\tstruct uart_port *uport = &sport->port;\n\n\t\t\tsport->duart\t= &sbd_duarts[chip];\n\n\t\t\tuport->irq\t= SBD_INT(line);\n\t\t\tuport->uartclk\t= 100000000 / 20 * 16;\n\t\t\tuport->fifosize\t= 16;\n\t\t\tuport->iotype\t= UPIO_MEM;\n\t\t\tuport->flags\t= UPF_BOOT_AUTOCONF;\n\t\t\tuport->ops\t= &sbd_ops;\n\t\t\tuport->line\t= line;\n\t\t\tuport->mapbase\t= SBD_CHANREGS(line);\n\t\t\tuport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_SB1250_DUART_CONSOLE);\n\t\t}\n\t}\n}\n\n\n#ifdef CONFIG_SERIAL_SB1250_DUART_CONSOLE\n \nstatic void sbd_console_putchar(struct uart_port *uport, unsigned char ch)\n{\n\tstruct sbd_port *sport = to_sport(uport);\n\n\tsbd_transmit_drain(sport);\n\twrite_sbdchn(sport, R_DUART_TX_HOLD, ch);\n}\n\nstatic void sbd_console_write(struct console *co, const char *s,\n\t\t\t      unsigned int count)\n{\n\tint chip = co->index / DUART_MAX_SIDE;\n\tint side = co->index % DUART_MAX_SIDE;\n\tstruct sbd_port *sport = &sbd_duarts[chip].sport[side];\n\tstruct uart_port *uport = &sport->port;\n\tunsigned long flags;\n\tunsigned int mask;\n\n\t \n\tspin_lock_irqsave(&uport->lock, flags);\n\tmask = read_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2));\n\twrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2),\n\t\t     mask & ~M_DUART_IMR_TX);\n\twrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_EN);\n\tspin_unlock_irqrestore(&uport->lock, flags);\n\n\tuart_console_write(&sport->port, s, count, sbd_console_putchar);\n\n\t \n\tspin_lock_irqsave(&uport->lock, flags);\n\tsbd_line_drain(sport);\n\tif (sport->tx_stopped)\n\t\twrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_DIS);\n\twrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2), mask);\n\tspin_unlock_irqrestore(&uport->lock, flags);\n}\n\nstatic int __init sbd_console_setup(struct console *co, char *options)\n{\n\tint chip = co->index / DUART_MAX_SIDE;\n\tint side = co->index % DUART_MAX_SIDE;\n\tstruct sbd_port *sport = &sbd_duarts[chip].sport[side];\n\tstruct uart_port *uport = &sport->port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret;\n\n\tif (!sport->duart)\n\t\treturn -ENXIO;\n\n\tret = sbd_map_port(uport);\n\tif (ret)\n\t\treturn ret;\n\n\tsbd_init_port(sport);\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\treturn uart_set_options(uport, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver sbd_reg;\nstatic struct console sbd_console = {\n\t.name\t= \"duart\",\n\t.write\t= sbd_console_write,\n\t.device\t= uart_console_device,\n\t.setup\t= sbd_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,\n\t.data\t= &sbd_reg\n};\n\nstatic int __init sbd_serial_console_init(void)\n{\n\tsbd_probe_duarts();\n\tregister_console(&sbd_console);\n\n\treturn 0;\n}\n\nconsole_initcall(sbd_serial_console_init);\n\n#define SERIAL_SB1250_DUART_CONSOLE\t&sbd_console\n#else\n#define SERIAL_SB1250_DUART_CONSOLE\tNULL\n#endif  \n\n\nstatic struct uart_driver sbd_reg = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"sb1250_duart\",\n\t.dev_name\t= \"duart\",\n\t.major\t\t= TTY_MAJOR,\n\t.minor\t\t= SB1250_DUART_MINOR_BASE,\n\t.nr\t\t= DUART_MAX_CHIP * DUART_MAX_SIDE,\n\t.cons\t\t= SERIAL_SB1250_DUART_CONSOLE,\n};\n\n \nstatic int __init sbd_init(void)\n{\n\tint i, ret;\n\n\tsbd_probe_duarts();\n\n\tret = uart_register_driver(&sbd_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < DUART_MAX_CHIP * DUART_MAX_SIDE; i++) {\n\t\tstruct sbd_duart *duart = &sbd_duarts[i / DUART_MAX_SIDE];\n\t\tstruct sbd_port *sport = &duart->sport[i % DUART_MAX_SIDE];\n\t\tstruct uart_port *uport = &sport->port;\n\n\t\tif (sport->duart)\n\t\t\tuart_add_one_port(&sbd_reg, uport);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __exit sbd_exit(void)\n{\n\tint i;\n\n\tfor (i = DUART_MAX_CHIP * DUART_MAX_SIDE - 1; i >= 0; i--) {\n\t\tstruct sbd_duart *duart = &sbd_duarts[i / DUART_MAX_SIDE];\n\t\tstruct sbd_port *sport = &duart->sport[i % DUART_MAX_SIDE];\n\t\tstruct uart_port *uport = &sport->port;\n\n\t\tif (sport->duart)\n\t\t\tuart_remove_one_port(&sbd_reg, uport);\n\t}\n\n\tuart_unregister_driver(&sbd_reg);\n}\n\nmodule_init(sbd_init);\nmodule_exit(sbd_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}