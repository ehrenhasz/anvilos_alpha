{
  "module_name": "men_z135_uart.c",
  "hash_id": "1ba582c038dabdfe08918bae9daf0e4d1e1b7ac8fc776ac55d03dd984db12ad2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/men_z135_uart.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \":\" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/tty_flip.h>\n#include <linux/bitops.h>\n#include <linux/mcb.h>\n\n#define MEN_Z135_MAX_PORTS\t\t12\n#define MEN_Z135_BASECLK\t\t29491200\n#define MEN_Z135_FIFO_SIZE\t\t1024\n#define MEN_Z135_FIFO_WATERMARK\t\t1020\n\n#define MEN_Z135_STAT_REG\t\t0x0\n#define MEN_Z135_RX_RAM\t\t\t0x4\n#define MEN_Z135_TX_RAM\t\t\t0x400\n#define MEN_Z135_RX_CTRL\t\t0x800\n#define MEN_Z135_TX_CTRL\t\t0x804\n#define MEN_Z135_CONF_REG\t\t0x808\n#define MEN_Z135_UART_FREQ\t\t0x80c\n#define MEN_Z135_BAUD_REG\t\t0x810\n#define MEN_Z135_TIMEOUT\t\t0x814\n\n#define IRQ_ID(x) ((x) & 0x1f)\n\n#define MEN_Z135_IER_RXCIEN BIT(0)\t\t \n#define MEN_Z135_IER_TXCIEN BIT(1)\t\t \n#define MEN_Z135_IER_RLSIEN BIT(2)\t\t \n#define MEN_Z135_IER_MSIEN  BIT(3)\t\t \n#define MEN_Z135_ALL_IRQS (MEN_Z135_IER_RXCIEN\t\t\\\n\t\t\t\t| MEN_Z135_IER_RLSIEN\t\\\n\t\t\t\t| MEN_Z135_IER_MSIEN\t\\\n\t\t\t\t| MEN_Z135_IER_TXCIEN)\n\n#define MEN_Z135_MCR_DTR\tBIT(24)\n#define MEN_Z135_MCR_RTS\tBIT(25)\n#define MEN_Z135_MCR_OUT1\tBIT(26)\n#define MEN_Z135_MCR_OUT2\tBIT(27)\n#define MEN_Z135_MCR_LOOP\tBIT(28)\n#define MEN_Z135_MCR_RCFC\tBIT(29)\n\n#define MEN_Z135_MSR_DCTS\tBIT(0)\n#define MEN_Z135_MSR_DDSR\tBIT(1)\n#define MEN_Z135_MSR_DRI\tBIT(2)\n#define MEN_Z135_MSR_DDCD\tBIT(3)\n#define MEN_Z135_MSR_CTS\tBIT(4)\n#define MEN_Z135_MSR_DSR\tBIT(5)\n#define MEN_Z135_MSR_RI\t\tBIT(6)\n#define MEN_Z135_MSR_DCD\tBIT(7)\n\n#define MEN_Z135_LCR_SHIFT 8\t \n\n#define MEN_Z135_WL5 0\t\t \n#define MEN_Z135_WL6 1\t\t \n#define MEN_Z135_WL7 2\t\t \n#define MEN_Z135_WL8 3\t\t \n\n#define MEN_Z135_STB_SHIFT 2\t \n#define MEN_Z135_NSTB1 0\n#define MEN_Z135_NSTB2 1\n\n#define MEN_Z135_PEN_SHIFT 3\t \n#define MEN_Z135_PAR_DIS 0\n#define MEN_Z135_PAR_ENA 1\n\n#define MEN_Z135_PTY_SHIFT 4\t \n#define MEN_Z135_PTY_ODD 0\n#define MEN_Z135_PTY_EVN 1\n\n#define MEN_Z135_LSR_DR BIT(0)\n#define MEN_Z135_LSR_OE BIT(1)\n#define MEN_Z135_LSR_PE BIT(2)\n#define MEN_Z135_LSR_FE BIT(3)\n#define MEN_Z135_LSR_BI BIT(4)\n#define MEN_Z135_LSR_THEP BIT(5)\n#define MEN_Z135_LSR_TEXP BIT(6)\n#define MEN_Z135_LSR_RXFIFOERR BIT(7)\n\n#define MEN_Z135_IRQ_ID_RLS BIT(0)\n#define MEN_Z135_IRQ_ID_RDA BIT(1)\n#define MEN_Z135_IRQ_ID_CTI BIT(2)\n#define MEN_Z135_IRQ_ID_TSA BIT(3)\n#define MEN_Z135_IRQ_ID_MST BIT(4)\n\n#define LCR(x) (((x) >> MEN_Z135_LCR_SHIFT) & 0xff)\n\n#define BYTES_TO_ALIGN(x) ((x) & 0x3)\n\nstatic int line;\n\nstatic int txlvl = 5;\nmodule_param(txlvl, int, S_IRUGO);\nMODULE_PARM_DESC(txlvl, \"TX IRQ trigger level 0-7, default 5 (128 byte)\");\n\nstatic int rxlvl = 6;\nmodule_param(rxlvl, int, S_IRUGO);\nMODULE_PARM_DESC(rxlvl, \"RX IRQ trigger level 0-7, default 6 (256 byte)\");\n\nstatic int align;\nmodule_param(align, int, S_IRUGO);\nMODULE_PARM_DESC(align, \"Keep hardware FIFO write pointer aligned, default 0\");\n\nstatic uint rx_timeout;\nmodule_param(rx_timeout, uint, S_IRUGO);\nMODULE_PARM_DESC(rx_timeout, \"RX timeout. \"\n\t\t\"Timeout in seconds = (timeout_reg * baud_reg * 4) / freq_reg\");\n\nstruct men_z135_port {\n\tstruct uart_port port;\n\tstruct mcb_device *mdev;\n\tstruct resource *mem;\n\tunsigned char *rxbuf;\n\tu32 stat_reg;\n\tspinlock_t lock;\n\tbool automode;\n};\n#define to_men_z135(port) container_of((port), struct men_z135_port, port)\n\n \nstatic inline void men_z135_reg_set(struct men_z135_port *uart,\n\t\t\t\tu32 addr, u32 val)\n{\n\tstruct uart_port *port = &uart->port;\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&uart->lock, flags);\n\n\treg = ioread32(port->membase + addr);\n\treg |= val;\n\tiowrite32(reg, port->membase + addr);\n\n\tspin_unlock_irqrestore(&uart->lock, flags);\n}\n\n \nstatic void men_z135_reg_clr(struct men_z135_port *uart,\n\t\t\t\tu32 addr, u32 val)\n{\n\tstruct uart_port *port = &uart->port;\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&uart->lock, flags);\n\n\treg = ioread32(port->membase + addr);\n\treg &= ~val;\n\tiowrite32(reg, port->membase + addr);\n\n\tspin_unlock_irqrestore(&uart->lock, flags);\n}\n\n \nstatic void men_z135_handle_modem_status(struct men_z135_port *uart)\n{\n\tu8 msr;\n\n\tmsr = (uart->stat_reg >> 8) & 0xff;\n\n\tif (msr & MEN_Z135_MSR_DDCD)\n\t\tuart_handle_dcd_change(&uart->port,\n\t\t\t\tmsr & MEN_Z135_MSR_DCD);\n\tif (msr & MEN_Z135_MSR_DCTS)\n\t\tuart_handle_cts_change(&uart->port,\n\t\t\t\tmsr & MEN_Z135_MSR_CTS);\n}\n\nstatic void men_z135_handle_lsr(struct men_z135_port *uart)\n{\n\tstruct uart_port *port = &uart->port;\n\tu8 lsr;\n\n\tlsr = (uart->stat_reg >> 16) & 0xff;\n\n\tif (lsr & MEN_Z135_LSR_OE)\n\t\tport->icount.overrun++;\n\tif (lsr & MEN_Z135_LSR_PE)\n\t\tport->icount.parity++;\n\tif (lsr & MEN_Z135_LSR_FE)\n\t\tport->icount.frame++;\n\tif (lsr & MEN_Z135_LSR_BI) {\n\t\tport->icount.brk++;\n\t\tuart_handle_break(port);\n\t}\n}\n\n \nstatic u16 get_rx_fifo_content(struct men_z135_port *uart)\n{\n\tstruct uart_port *port = &uart->port;\n\tu32 stat_reg;\n\tu16 rxc;\n\tu8 rxc_lo;\n\tu8 rxc_hi;\n\n\tstat_reg = ioread32(port->membase + MEN_Z135_STAT_REG);\n\trxc_lo = stat_reg >> 24;\n\trxc_hi = (stat_reg & 0xC0) >> 6;\n\n\trxc = rxc_lo | (rxc_hi << 8);\n\n\treturn rxc;\n}\n\n \nstatic void men_z135_handle_rx(struct men_z135_port *uart)\n{\n\tstruct uart_port *port = &uart->port;\n\tstruct tty_port *tport = &port->state->port;\n\tint copied;\n\tu16 size;\n\tint room;\n\n\tsize = get_rx_fifo_content(uart);\n\n\tif (size == 0)\n\t\treturn;\n\n\t \n\tif (size > MEN_Z135_FIFO_WATERMARK)\n\t\tsize = MEN_Z135_FIFO_WATERMARK;\n\n\troom = tty_buffer_request_room(tport, size);\n\tif (room != size)\n\t\tdev_warn(&uart->mdev->dev,\n\t\t\t\"Not enough room in flip buffer, truncating to %d\\n\",\n\t\t\troom);\n\n\tif (room == 0)\n\t\treturn;\n\n\tmemcpy_fromio(uart->rxbuf, port->membase + MEN_Z135_RX_RAM, room);\n\t \n\tmb();\n\tiowrite32(room, port->membase +  MEN_Z135_RX_CTRL);\n\n\tcopied = tty_insert_flip_string(tport, uart->rxbuf, room);\n\tif (copied != room)\n\t\tdev_warn(&uart->mdev->dev,\n\t\t\t\"Only copied %d instead of %d bytes\\n\",\n\t\t\tcopied, room);\n\n\tport->icount.rx += copied;\n\n\ttty_flip_buffer_push(tport);\n\n}\n\n \nstatic void men_z135_handle_tx(struct men_z135_port *uart)\n{\n\tstruct uart_port *port = &uart->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tu32 txc;\n\tu32 wptr;\n\tint qlen;\n\tint n;\n\tint txfree;\n\tint head;\n\tint tail;\n\tint s;\n\n\tif (uart_circ_empty(xmit))\n\t\tgoto out;\n\n\tif (uart_tx_stopped(port))\n\t\tgoto out;\n\n\tif (port->x_char)\n\t\tgoto out;\n\n\t \n\tqlen = uart_circ_chars_pending(xmit);\n\tif (qlen <= 0)\n\t\tgoto out;\n\n\twptr = ioread32(port->membase + MEN_Z135_TX_CTRL);\n\ttxc = (wptr >> 16) & 0x3ff;\n\twptr &= 0x3ff;\n\n\tif (txc > MEN_Z135_FIFO_WATERMARK)\n\t\ttxc = MEN_Z135_FIFO_WATERMARK;\n\n\ttxfree = MEN_Z135_FIFO_WATERMARK - txc;\n\tif (txfree <= 0) {\n\t\tdev_err(&uart->mdev->dev,\n\t\t\t\"Not enough room in TX FIFO have %d, need %d\\n\",\n\t\t\ttxfree, qlen);\n\t\tgoto irq_en;\n\t}\n\n\t \n\tif (align && qlen >= 3 && BYTES_TO_ALIGN(wptr))\n\t\tn = 4 - BYTES_TO_ALIGN(wptr);\n\telse if (qlen > txfree)\n\t\tn = txfree;\n\telse\n\t\tn = qlen;\n\n\tif (n <= 0)\n\t\tgoto irq_en;\n\n\thead = xmit->head & (UART_XMIT_SIZE - 1);\n\ttail = xmit->tail & (UART_XMIT_SIZE - 1);\n\n\ts = ((head >= tail) ? head : UART_XMIT_SIZE) - tail;\n\tn = min(n, s);\n\n\tmemcpy_toio(port->membase + MEN_Z135_TX_RAM, &xmit->buf[xmit->tail], n);\n\tiowrite32(n & 0x3ff, port->membase + MEN_Z135_TX_CTRL);\n\tuart_xmit_advance(port, n);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\nirq_en:\n\tif (!uart_circ_empty(xmit))\n\t\tmen_z135_reg_set(uart, MEN_Z135_CONF_REG, MEN_Z135_IER_TXCIEN);\n\telse\n\t\tmen_z135_reg_clr(uart, MEN_Z135_CONF_REG, MEN_Z135_IER_TXCIEN);\n\nout:\n\treturn;\n\n}\n\n \nstatic irqreturn_t men_z135_intr(int irq, void *data)\n{\n\tstruct men_z135_port *uart = (struct men_z135_port *)data;\n\tstruct uart_port *port = &uart->port;\n\tbool handled = false;\n\tint irq_id;\n\n\tuart->stat_reg = ioread32(port->membase + MEN_Z135_STAT_REG);\n\tirq_id = IRQ_ID(uart->stat_reg);\n\n\tif (!irq_id)\n\t\tgoto out;\n\n\tspin_lock(&port->lock);\n\t \n\tiowrite8(irq_id, port->membase + MEN_Z135_STAT_REG);\n\n\tif (irq_id & MEN_Z135_IRQ_ID_RLS) {\n\t\tmen_z135_handle_lsr(uart);\n\t\thandled = true;\n\t}\n\n\tif (irq_id & (MEN_Z135_IRQ_ID_RDA | MEN_Z135_IRQ_ID_CTI)) {\n\t\tif (irq_id & MEN_Z135_IRQ_ID_CTI)\n\t\t\tdev_dbg(&uart->mdev->dev, \"Character Timeout Indication\\n\");\n\t\tmen_z135_handle_rx(uart);\n\t\thandled = true;\n\t}\n\n\tif (irq_id & MEN_Z135_IRQ_ID_TSA) {\n\t\tmen_z135_handle_tx(uart);\n\t\thandled = true;\n\t}\n\n\tif (irq_id & MEN_Z135_IRQ_ID_MST) {\n\t\tmen_z135_handle_modem_status(uart);\n\t\thandled = true;\n\t}\n\n\tspin_unlock(&port->lock);\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\n \nstatic int men_z135_request_irq(struct men_z135_port *uart)\n{\n\tstruct device *dev = &uart->mdev->dev;\n\tstruct uart_port *port = &uart->port;\n\tint err = 0;\n\n\terr = request_irq(port->irq, men_z135_intr, IRQF_SHARED,\n\t\t\t\"men_z135_intr\", uart);\n\tif (err)\n\t\tdev_err(dev, \"Error %d getting interrupt\\n\", err);\n\n\treturn err;\n}\n\n \nstatic unsigned int men_z135_tx_empty(struct uart_port *port)\n{\n\tu32 wptr;\n\tu16 txc;\n\n\twptr = ioread32(port->membase + MEN_Z135_TX_CTRL);\n\ttxc = (wptr >> 16) & 0x3ff;\n\n\tif (txc == 0)\n\t\treturn TIOCSER_TEMT;\n\telse\n\t\treturn 0;\n}\n\n \nstatic void men_z135_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tu32 old;\n\tu32 conf_reg;\n\n\tconf_reg = old = ioread32(port->membase + MEN_Z135_CONF_REG);\n\tif (mctrl & TIOCM_RTS)\n\t\tconf_reg |= MEN_Z135_MCR_RTS;\n\telse\n\t\tconf_reg &= ~MEN_Z135_MCR_RTS;\n\n\tif (mctrl & TIOCM_DTR)\n\t\tconf_reg |= MEN_Z135_MCR_DTR;\n\telse\n\t\tconf_reg &= ~MEN_Z135_MCR_DTR;\n\n\tif (mctrl & TIOCM_OUT1)\n\t\tconf_reg |= MEN_Z135_MCR_OUT1;\n\telse\n\t\tconf_reg &= ~MEN_Z135_MCR_OUT1;\n\n\tif (mctrl & TIOCM_OUT2)\n\t\tconf_reg |= MEN_Z135_MCR_OUT2;\n\telse\n\t\tconf_reg &= ~MEN_Z135_MCR_OUT2;\n\n\tif (mctrl & TIOCM_LOOP)\n\t\tconf_reg |= MEN_Z135_MCR_LOOP;\n\telse\n\t\tconf_reg &= ~MEN_Z135_MCR_LOOP;\n\n\tif (conf_reg != old)\n\t\tiowrite32(conf_reg, port->membase + MEN_Z135_CONF_REG);\n}\n\n \nstatic unsigned int men_z135_get_mctrl(struct uart_port *port)\n{\n\tunsigned int mctrl = 0;\n\tu8 msr;\n\n\tmsr = ioread8(port->membase + MEN_Z135_STAT_REG + 1);\n\n\tif (msr & MEN_Z135_MSR_CTS)\n\t\tmctrl |= TIOCM_CTS;\n\tif (msr & MEN_Z135_MSR_DSR)\n\t\tmctrl |= TIOCM_DSR;\n\tif (msr & MEN_Z135_MSR_RI)\n\t\tmctrl |= TIOCM_RI;\n\tif (msr & MEN_Z135_MSR_DCD)\n\t\tmctrl |= TIOCM_CAR;\n\n\treturn mctrl;\n}\n\n \nstatic void men_z135_stop_tx(struct uart_port *port)\n{\n\tstruct men_z135_port *uart = to_men_z135(port);\n\n\tmen_z135_reg_clr(uart, MEN_Z135_CONF_REG, MEN_Z135_IER_TXCIEN);\n}\n\n \nstatic void men_z135_disable_ms(struct uart_port *port)\n{\n\tstruct men_z135_port *uart = to_men_z135(port);\n\n\tmen_z135_reg_clr(uart, MEN_Z135_CONF_REG, MEN_Z135_IER_MSIEN);\n}\n\n \nstatic void men_z135_start_tx(struct uart_port *port)\n{\n\tstruct men_z135_port *uart = to_men_z135(port);\n\n\tif (uart->automode)\n\t\tmen_z135_disable_ms(port);\n\n\tmen_z135_handle_tx(uart);\n}\n\n \nstatic void men_z135_stop_rx(struct uart_port *port)\n{\n\tstruct men_z135_port *uart = to_men_z135(port);\n\n\tmen_z135_reg_clr(uart, MEN_Z135_CONF_REG, MEN_Z135_IER_RXCIEN);\n}\n\n \nstatic void men_z135_enable_ms(struct uart_port *port)\n{\n\tstruct men_z135_port *uart = to_men_z135(port);\n\n\tmen_z135_reg_set(uart, MEN_Z135_CONF_REG, MEN_Z135_IER_MSIEN);\n}\n\nstatic int men_z135_startup(struct uart_port *port)\n{\n\tstruct men_z135_port *uart = to_men_z135(port);\n\tint err;\n\tu32 conf_reg = 0;\n\n\terr = men_z135_request_irq(uart);\n\tif (err)\n\t\treturn -ENODEV;\n\n\tconf_reg = ioread32(port->membase + MEN_Z135_CONF_REG);\n\n\t \n\tconf_reg |= MEN_Z135_ALL_IRQS & ~MEN_Z135_IER_TXCIEN;\n\tconf_reg &= ~(0xff << 16);\n\tconf_reg |= (txlvl << 16);\n\tconf_reg |= (rxlvl << 20);\n\n\tiowrite32(conf_reg, port->membase + MEN_Z135_CONF_REG);\n\n\tif (rx_timeout)\n\t\tiowrite32(rx_timeout, port->membase + MEN_Z135_TIMEOUT);\n\n\treturn 0;\n}\n\nstatic void men_z135_shutdown(struct uart_port *port)\n{\n\tstruct men_z135_port *uart = to_men_z135(port);\n\tu32 conf_reg = 0;\n\n\tconf_reg |= MEN_Z135_ALL_IRQS;\n\n\tmen_z135_reg_clr(uart, MEN_Z135_CONF_REG, conf_reg);\n\n\tfree_irq(uart->port.irq, uart);\n}\n\nstatic void men_z135_set_termios(struct uart_port *port,\n\t\t\t\t struct ktermios *termios,\n\t\t\t\t const struct ktermios *old)\n{\n\tstruct men_z135_port *uart = to_men_z135(port);\n\tunsigned int baud;\n\tu32 conf_reg;\n\tu32 bd_reg;\n\tu32 uart_freq;\n\tu8 lcr;\n\n\tconf_reg = ioread32(port->membase + MEN_Z135_CONF_REG);\n\tlcr = LCR(conf_reg);\n\n\t \n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tlcr |= MEN_Z135_WL5;\n\t\tbreak;\n\tcase CS6:\n\t\tlcr |= MEN_Z135_WL6;\n\t\tbreak;\n\tcase CS7:\n\t\tlcr |= MEN_Z135_WL7;\n\t\tbreak;\n\tcase CS8:\n\t\tlcr |= MEN_Z135_WL8;\n\t\tbreak;\n\t}\n\n\t \n\tif (termios->c_cflag & CSTOPB)\n\t\tlcr |= MEN_Z135_NSTB2 << MEN_Z135_STB_SHIFT;\n\n\t \n\tif (termios->c_cflag & PARENB) {\n\t\tlcr |= MEN_Z135_PAR_ENA << MEN_Z135_PEN_SHIFT;\n\n\t\tif (termios->c_cflag & PARODD)\n\t\t\tlcr |= MEN_Z135_PTY_ODD << MEN_Z135_PTY_SHIFT;\n\t\telse\n\t\t\tlcr |= MEN_Z135_PTY_EVN << MEN_Z135_PTY_SHIFT;\n\t} else\n\t\tlcr |= MEN_Z135_PAR_DIS << MEN_Z135_PEN_SHIFT;\n\n\tconf_reg |= MEN_Z135_IER_MSIEN;\n\tif (termios->c_cflag & CRTSCTS) {\n\t\tconf_reg |= MEN_Z135_MCR_RCFC;\n\t\tuart->automode = true;\n\t\ttermios->c_cflag &= ~CLOCAL;\n\t} else {\n\t\tconf_reg &= ~MEN_Z135_MCR_RCFC;\n\t\tuart->automode = false;\n\t}\n\n\ttermios->c_cflag &= ~CMSPAR;  \n\n\tconf_reg |= lcr << MEN_Z135_LCR_SHIFT;\n\tiowrite32(conf_reg, port->membase + MEN_Z135_CONF_REG);\n\n\tuart_freq = ioread32(port->membase + MEN_Z135_UART_FREQ);\n\tif (uart_freq == 0)\n\t\tuart_freq = MEN_Z135_BASECLK;\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, uart_freq / 16);\n\n\tspin_lock_irq(&port->lock);\n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\n\tbd_reg = uart_freq / (4 * baud);\n\tiowrite32(bd_reg, port->membase + MEN_Z135_BAUD_REG);\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\tspin_unlock_irq(&port->lock);\n}\n\nstatic const char *men_z135_type(struct uart_port *port)\n{\n\treturn KBUILD_MODNAME;\n}\n\nstatic void men_z135_release_port(struct uart_port *port)\n{\n\tstruct men_z135_port *uart = to_men_z135(port);\n\n\tiounmap(port->membase);\n\tport->membase = NULL;\n\n\tmcb_release_mem(uart->mem);\n}\n\nstatic int men_z135_request_port(struct uart_port *port)\n{\n\tstruct men_z135_port *uart = to_men_z135(port);\n\tstruct mcb_device *mdev = uart->mdev;\n\tstruct resource *mem;\n\n\tmem = mcb_request_mem(uart->mdev, dev_name(&mdev->dev));\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\tport->mapbase = mem->start;\n\tuart->mem = mem;\n\n\tport->membase = ioremap(mem->start, resource_size(mem));\n\tif (port->membase == NULL) {\n\t\tmcb_release_mem(mem);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void men_z135_config_port(struct uart_port *port, int type)\n{\n\tport->type = PORT_MEN_Z135;\n\tmen_z135_request_port(port);\n}\n\nstatic int men_z135_verify_port(struct uart_port *port,\n\t\t\t\tstruct serial_struct *serinfo)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct uart_ops men_z135_ops = {\n\t.tx_empty = men_z135_tx_empty,\n\t.set_mctrl = men_z135_set_mctrl,\n\t.get_mctrl = men_z135_get_mctrl,\n\t.stop_tx = men_z135_stop_tx,\n\t.start_tx = men_z135_start_tx,\n\t.stop_rx = men_z135_stop_rx,\n\t.enable_ms = men_z135_enable_ms,\n\t.startup = men_z135_startup,\n\t.shutdown = men_z135_shutdown,\n\t.set_termios = men_z135_set_termios,\n\t.type = men_z135_type,\n\t.release_port = men_z135_release_port,\n\t.request_port = men_z135_request_port,\n\t.config_port = men_z135_config_port,\n\t.verify_port = men_z135_verify_port,\n};\n\nstatic struct uart_driver men_z135_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = KBUILD_MODNAME,\n\t.dev_name = \"ttyHSU\",\n\t.major = 0,\n\t.minor = 0,\n\t.nr = MEN_Z135_MAX_PORTS,\n};\n\n \nstatic int men_z135_probe(struct mcb_device *mdev,\n\t\t\tconst struct mcb_device_id *id)\n{\n\tstruct men_z135_port *uart;\n\tstruct resource *mem;\n\tstruct device *dev;\n\tint err;\n\n\tdev = &mdev->dev;\n\n\tuart = devm_kzalloc(dev, sizeof(struct men_z135_port), GFP_KERNEL);\n\tif (!uart)\n\t\treturn -ENOMEM;\n\n\tuart->rxbuf = (unsigned char *)__get_free_page(GFP_KERNEL);\n\tif (!uart->rxbuf)\n\t\treturn -ENOMEM;\n\n\tmem = &mdev->mem;\n\n\tmcb_set_drvdata(mdev, uart);\n\n\tuart->port.uartclk = MEN_Z135_BASECLK * 16;\n\tuart->port.fifosize = MEN_Z135_FIFO_SIZE;\n\tuart->port.iotype = UPIO_MEM;\n\tuart->port.ops = &men_z135_ops;\n\tuart->port.irq = mcb_get_irq(mdev);\n\tuart->port.flags = UPF_BOOT_AUTOCONF | UPF_IOREMAP;\n\tuart->port.line = line++;\n\tuart->port.dev = dev;\n\tuart->port.type = PORT_MEN_Z135;\n\tuart->port.mapbase = mem->start;\n\tuart->port.membase = NULL;\n\tuart->mdev = mdev;\n\n\tspin_lock_init(&uart->lock);\n\n\terr = uart_add_one_port(&men_z135_driver, &uart->port);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tfree_page((unsigned long) uart->rxbuf);\n\tdev_err(dev, \"Failed to add UART: %d\\n\", err);\n\n\treturn err;\n}\n\n \nstatic void men_z135_remove(struct mcb_device *mdev)\n{\n\tstruct men_z135_port *uart = mcb_get_drvdata(mdev);\n\n\tline--;\n\tuart_remove_one_port(&men_z135_driver, &uart->port);\n\tfree_page((unsigned long) uart->rxbuf);\n}\n\nstatic const struct mcb_device_id men_z135_ids[] = {\n\t{ .device = 0x87 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(mcb, men_z135_ids);\n\nstatic struct mcb_driver mcb_driver = {\n\t.driver = {\n\t\t.name = \"z135-uart\",\n\t\t.owner = THIS_MODULE,\n\t},\n\t.probe = men_z135_probe,\n\t.remove = men_z135_remove,\n\t.id_table = men_z135_ids,\n};\n\n \nstatic int __init men_z135_init(void)\n{\n\tint err;\n\n\terr = uart_register_driver(&men_z135_driver);\n\tif (err) {\n\t\tpr_err(\"Failed to register UART: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = mcb_register_driver(&mcb_driver);\n\tif  (err) {\n\t\tpr_err(\"Failed to register MCB driver: %d\\n\", err);\n\t\tuart_unregister_driver(&men_z135_driver);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nmodule_init(men_z135_init);\n\n \nstatic void __exit men_z135_exit(void)\n{\n\tmcb_unregister_driver(&mcb_driver);\n\tuart_unregister_driver(&men_z135_driver);\n}\nmodule_exit(men_z135_exit);\n\nMODULE_AUTHOR(\"Johannes Thumshirn <johannes.thumshirn@men.de>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MEN 16z135 High Speed UART\");\nMODULE_ALIAS(\"mcb:16z135\");\nMODULE_IMPORT_NS(MCB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}