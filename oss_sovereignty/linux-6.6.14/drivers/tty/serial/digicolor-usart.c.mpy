{
  "module_name": "digicolor-usart.c",
  "hash_id": "4d84f0ca3102c25b78167f0ccc129d689d4706138fd425611c887c1a25f477a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/digicolor-usart.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n\n#define UA_ENABLE\t\t\t0x00\n#define UA_ENABLE_ENABLE\t\tBIT(0)\n\n#define UA_CONTROL\t\t\t0x01\n#define UA_CONTROL_RX_ENABLE\t\tBIT(0)\n#define UA_CONTROL_TX_ENABLE\t\tBIT(1)\n#define UA_CONTROL_SOFT_RESET\t\tBIT(2)\n\n#define UA_STATUS\t\t\t0x02\n#define UA_STATUS_PARITY_ERR\t\tBIT(0)\n#define UA_STATUS_FRAME_ERR\t\tBIT(1)\n#define UA_STATUS_OVERRUN_ERR\t\tBIT(2)\n#define UA_STATUS_TX_READY\t\tBIT(6)\n\n#define UA_CONFIG\t\t\t0x03\n#define UA_CONFIG_CHAR_LEN\t\tBIT(0)\n#define UA_CONFIG_STOP_BITS\t\tBIT(1)\n#define UA_CONFIG_PARITY\t\tBIT(2)\n#define UA_CONFIG_ODD_PARITY\t\tBIT(4)\n\n#define UA_EMI_REC\t\t\t0x04\n\n#define UA_HBAUD_LO\t\t\t0x08\n#define UA_HBAUD_HI\t\t\t0x09\n\n#define UA_STATUS_FIFO\t\t\t0x0a\n#define UA_STATUS_FIFO_RX_EMPTY\t\tBIT(2)\n#define UA_STATUS_FIFO_RX_INT_ALMOST\tBIT(3)\n#define UA_STATUS_FIFO_TX_FULL\t\tBIT(4)\n#define UA_STATUS_FIFO_TX_INT_ALMOST\tBIT(7)\n\n#define UA_CONFIG_FIFO\t\t\t0x0b\n#define UA_CONFIG_FIFO_RX_THRESH\t7\n#define UA_CONFIG_FIFO_RX_FIFO_MODE\tBIT(3)\n#define UA_CONFIG_FIFO_TX_FIFO_MODE\tBIT(7)\n\n#define UA_INTFLAG_CLEAR\t\t0x1c\n#define UA_INTFLAG_SET\t\t\t0x1d\n#define UA_INT_ENABLE\t\t\t0x1e\n#define UA_INT_STATUS\t\t\t0x1f\n\n#define UA_INT_TX\t\t\tBIT(0)\n#define UA_INT_RX\t\t\tBIT(1)\n\n#define DIGICOLOR_USART_NR\t\t3\n\n \n\nstruct digicolor_port {\n\tstruct uart_port port;\n\tstruct delayed_work rx_poll_work;\n};\n\nstatic struct uart_port *digicolor_ports[DIGICOLOR_USART_NR];\n\nstatic bool digicolor_uart_tx_full(struct uart_port *port)\n{\n\treturn !!(readb_relaxed(port->membase + UA_STATUS_FIFO) &\n\t\t  UA_STATUS_FIFO_TX_FULL);\n}\n\nstatic bool digicolor_uart_rx_empty(struct uart_port *port)\n{\n\treturn !!(readb_relaxed(port->membase + UA_STATUS_FIFO) &\n\t\t  UA_STATUS_FIFO_RX_EMPTY);\n}\n\nstatic void digicolor_uart_stop_tx(struct uart_port *port)\n{\n\tu8 int_enable = readb_relaxed(port->membase + UA_INT_ENABLE);\n\n\tint_enable &= ~UA_INT_TX;\n\twriteb_relaxed(int_enable, port->membase + UA_INT_ENABLE);\n}\n\nstatic void digicolor_uart_start_tx(struct uart_port *port)\n{\n\tu8 int_enable = readb_relaxed(port->membase + UA_INT_ENABLE);\n\n\tint_enable |= UA_INT_TX;\n\twriteb_relaxed(int_enable, port->membase + UA_INT_ENABLE);\n}\n\nstatic void digicolor_uart_stop_rx(struct uart_port *port)\n{\n\tu8 int_enable = readb_relaxed(port->membase + UA_INT_ENABLE);\n\n\tint_enable &= ~UA_INT_RX;\n\twriteb_relaxed(int_enable, port->membase + UA_INT_ENABLE);\n}\n\nstatic void digicolor_rx_poll(struct work_struct *work)\n{\n\tstruct digicolor_port *dp =\n\t\tcontainer_of(to_delayed_work(work),\n\t\t\t     struct digicolor_port, rx_poll_work);\n\n\tif (!digicolor_uart_rx_empty(&dp->port))\n\t\t \n\t\twriteb_relaxed(UA_INT_RX, dp->port.membase + UA_INTFLAG_SET);\n\n\tschedule_delayed_work(&dp->rx_poll_work, msecs_to_jiffies(100));\n}\n\nstatic void digicolor_uart_rx(struct uart_port *port)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\twhile (1) {\n\t\tu8 status, ch, ch_flag;\n\n\t\tif (digicolor_uart_rx_empty(port))\n\t\t\tbreak;\n\n\t\tch = readb_relaxed(port->membase + UA_EMI_REC);\n\t\tstatus = readb_relaxed(port->membase + UA_STATUS);\n\n\t\tport->icount.rx++;\n\t\tch_flag = TTY_NORMAL;\n\n\t\tif (status) {\n\t\t\tif (status & UA_STATUS_PARITY_ERR)\n\t\t\t\tport->icount.parity++;\n\t\t\telse if (status & UA_STATUS_FRAME_ERR)\n\t\t\t\tport->icount.frame++;\n\t\t\telse if (status & UA_STATUS_OVERRUN_ERR)\n\t\t\t\tport->icount.overrun++;\n\n\t\t\tstatus &= port->read_status_mask;\n\n\t\t\tif (status & UA_STATUS_PARITY_ERR)\n\t\t\t\tch_flag = TTY_PARITY;\n\t\t\telse if (status & UA_STATUS_FRAME_ERR)\n\t\t\t\tch_flag = TTY_FRAME;\n\t\t\telse if (status & UA_STATUS_OVERRUN_ERR)\n\t\t\t\tch_flag = TTY_OVERRUN;\n\t\t}\n\n\t\tif (status & port->ignore_status_mask)\n\t\t\tcontinue;\n\n\t\tuart_insert_char(port, status, UA_STATUS_OVERRUN_ERR, ch,\n\t\t\t\t ch_flag);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic void digicolor_uart_tx(struct uart_port *port)\n{\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned long flags;\n\n\tif (digicolor_uart_tx_full(port))\n\t\treturn;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (port->x_char) {\n\t\twriteb_relaxed(port->x_char, port->membase + UA_EMI_REC);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\tgoto out;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\tdigicolor_uart_stop_tx(port);\n\t\tgoto out;\n\t}\n\n\twhile (!uart_circ_empty(xmit)) {\n\t\twriteb(xmit->buf[xmit->tail], port->membase + UA_EMI_REC);\n\t\tuart_xmit_advance(port, 1);\n\n\t\tif (digicolor_uart_tx_full(port))\n\t\t\tbreak;\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\nout:\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic irqreturn_t digicolor_uart_int(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tu8 int_status = readb_relaxed(port->membase + UA_INT_STATUS);\n\n\twriteb_relaxed(UA_INT_RX | UA_INT_TX,\n\t\t       port->membase + UA_INTFLAG_CLEAR);\n\n\tif (int_status & UA_INT_RX)\n\t\tdigicolor_uart_rx(port);\n\tif (int_status & UA_INT_TX)\n\t\tdigicolor_uart_tx(port);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int digicolor_uart_tx_empty(struct uart_port *port)\n{\n\tu8 status = readb_relaxed(port->membase + UA_STATUS);\n\n\treturn (status & UA_STATUS_TX_READY) ? TIOCSER_TEMT : 0;\n}\n\nstatic unsigned int digicolor_uart_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CTS;\n}\n\nstatic void digicolor_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n}\n\nstatic void digicolor_uart_break_ctl(struct uart_port *port, int state)\n{\n}\n\nstatic int digicolor_uart_startup(struct uart_port *port)\n{\n\tstruct digicolor_port *dp =\n\t\tcontainer_of(port, struct digicolor_port, port);\n\n\twriteb_relaxed(UA_ENABLE_ENABLE, port->membase + UA_ENABLE);\n\twriteb_relaxed(UA_CONTROL_SOFT_RESET, port->membase + UA_CONTROL);\n\twriteb_relaxed(0, port->membase + UA_CONTROL);\n\n\twriteb_relaxed(UA_CONFIG_FIFO_RX_FIFO_MODE\n\t\t       | UA_CONFIG_FIFO_TX_FIFO_MODE | UA_CONFIG_FIFO_RX_THRESH,\n\t\t       port->membase + UA_CONFIG_FIFO);\n\twriteb_relaxed(UA_STATUS_FIFO_RX_INT_ALMOST,\n\t\t       port->membase + UA_STATUS_FIFO);\n\twriteb_relaxed(UA_CONTROL_RX_ENABLE | UA_CONTROL_TX_ENABLE,\n\t\t       port->membase + UA_CONTROL);\n\twriteb_relaxed(UA_INT_TX | UA_INT_RX,\n\t\t       port->membase + UA_INT_ENABLE);\n\n\tschedule_delayed_work(&dp->rx_poll_work, msecs_to_jiffies(100));\n\n\treturn 0;\n}\n\nstatic void digicolor_uart_shutdown(struct uart_port *port)\n{\n\tstruct digicolor_port *dp =\n\t\tcontainer_of(port, struct digicolor_port, port);\n\n\twriteb_relaxed(0, port->membase + UA_ENABLE);\n\tcancel_delayed_work_sync(&dp->rx_poll_work);\n}\n\nstatic void digicolor_uart_set_termios(struct uart_port *port,\n\t\t\t\t       struct ktermios *termios,\n\t\t\t\t       const struct ktermios *old)\n{\n\tunsigned int baud, divisor;\n\tu8 config = 0;\n\tunsigned long flags;\n\n\t \n\ttermios->c_cflag &= ~CMSPAR;\n\ttermios->c_iflag &= ~(BRKINT | IGNBRK);\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old,\n\t\t\t\t  port->uartclk / (0x10000*16),\n\t\t\t\t  port->uartclk / 256);\n\tdivisor = uart_get_divisor(port, baud) - 1;\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS7:\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tconfig |= UA_CONFIG_CHAR_LEN;\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= CS8;\n\t\tbreak;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tconfig |= UA_CONFIG_STOP_BITS;\n\n\tif (termios->c_cflag & PARENB) {\n\t\tconfig |= UA_CONFIG_PARITY;\n\t\tif (termios->c_cflag & PARODD)\n\t\t\tconfig |= UA_CONFIG_ODD_PARITY;\n\t}\n\n\t \n\tport->read_status_mask = UA_STATUS_OVERRUN_ERR;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= UA_STATUS_PARITY_ERR\n\t\t\t| UA_STATUS_FRAME_ERR;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (!(termios->c_cflag & CREAD))\n\t\tport->ignore_status_mask |= UA_STATUS_OVERRUN_ERR\n\t\t\t| UA_STATUS_PARITY_ERR | UA_STATUS_FRAME_ERR;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\twriteb_relaxed(config, port->membase + UA_CONFIG);\n\twriteb_relaxed(divisor & 0xff, port->membase + UA_HBAUD_LO);\n\twriteb_relaxed(divisor >> 8, port->membase + UA_HBAUD_HI);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *digicolor_uart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_DIGICOLOR) ? \"DIGICOLOR USART\" : NULL;\n}\n\nstatic void digicolor_uart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_DIGICOLOR;\n}\n\nstatic void digicolor_uart_release_port(struct uart_port *port)\n{\n}\n\nstatic int digicolor_uart_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic const struct uart_ops digicolor_uart_ops = {\n\t.tx_empty\t= digicolor_uart_tx_empty,\n\t.set_mctrl\t= digicolor_uart_set_mctrl,\n\t.get_mctrl\t= digicolor_uart_get_mctrl,\n\t.stop_tx\t= digicolor_uart_stop_tx,\n\t.start_tx\t= digicolor_uart_start_tx,\n\t.stop_rx\t= digicolor_uart_stop_rx,\n\t.break_ctl\t= digicolor_uart_break_ctl,\n\t.startup\t= digicolor_uart_startup,\n\t.shutdown\t= digicolor_uart_shutdown,\n\t.set_termios\t= digicolor_uart_set_termios,\n\t.type\t\t= digicolor_uart_type,\n\t.config_port\t= digicolor_uart_config_port,\n\t.release_port\t= digicolor_uart_release_port,\n\t.request_port\t= digicolor_uart_request_port,\n};\n\nstatic void digicolor_uart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\twhile (digicolor_uart_tx_full(port))\n\t\tcpu_relax();\n\n\twriteb_relaxed(ch, port->membase + UA_EMI_REC);\n}\n\nstatic void digicolor_uart_console_write(struct console *co, const char *c,\n\t\t\t\t\t unsigned n)\n{\n\tstruct uart_port *port = digicolor_ports[co->index];\n\tu8 status;\n\tunsigned long flags;\n\tint locked = 1;\n\n\tif (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&port->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\tuart_console_write(port, c, n, digicolor_uart_console_putchar);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\tdo {\n\t\tstatus = readb_relaxed(port->membase + UA_STATUS);\n\t} while ((status & UA_STATUS_TX_READY) == 0);\n}\n\nstatic int digicolor_uart_console_setup(struct console *co, char *options)\n{\n\tint baud = 115200, bits = 8, parity = 'n', flow = 'n';\n\tstruct uart_port *port;\n\n\tif (co->index < 0 || co->index >= DIGICOLOR_USART_NR)\n\t\treturn -EINVAL;\n\n\tport = digicolor_ports[co->index];\n\tif (!port)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct console digicolor_console = {\n\t.name\t= \"ttyS\",\n\t.device\t= uart_console_device,\n\t.write\t= digicolor_uart_console_write,\n\t.setup\t= digicolor_uart_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,\n};\n\nstatic struct uart_driver digicolor_uart = {\n\t.driver_name\t= \"digicolor-usart\",\n\t.dev_name\t= \"ttyS\",\n\t.nr\t\t= DIGICOLOR_USART_NR,\n};\n\nstatic int digicolor_uart_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint irq, ret, index;\n\tstruct digicolor_port *dp;\n\tstruct resource *res;\n\tstruct clk *uart_clk;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"Missing device tree node\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tindex = of_alias_get_id(np, \"serial\");\n\tif (index < 0 || index >= DIGICOLOR_USART_NR)\n\t\treturn -EINVAL;\n\n\tdp = devm_kzalloc(&pdev->dev, sizeof(*dp), GFP_KERNEL);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tuart_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(uart_clk))\n\t\treturn PTR_ERR(uart_clk);\n\n\tdp->port.membase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(dp->port.membase))\n\t\treturn PTR_ERR(dp->port.membase);\n\tdp->port.mapbase = res->start;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tdp->port.irq = irq;\n\n\tdp->port.iotype = UPIO_MEM;\n\tdp->port.uartclk = clk_get_rate(uart_clk);\n\tdp->port.fifosize = 16;\n\tdp->port.dev = &pdev->dev;\n\tdp->port.ops = &digicolor_uart_ops;\n\tdp->port.line = index;\n\tdp->port.type = PORT_DIGICOLOR;\n\tspin_lock_init(&dp->port.lock);\n\n\tdigicolor_ports[index] = &dp->port;\n\tplatform_set_drvdata(pdev, &dp->port);\n\n\tINIT_DELAYED_WORK(&dp->rx_poll_work, digicolor_rx_poll);\n\n\tret = devm_request_irq(&pdev->dev, dp->port.irq, digicolor_uart_int, 0,\n\t\t\t       dev_name(&pdev->dev), &dp->port);\n\tif (ret)\n\t\treturn ret;\n\n\treturn uart_add_one_port(&digicolor_uart, &dp->port);\n}\n\nstatic int digicolor_uart_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&digicolor_uart, port);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id digicolor_uart_dt_ids[] = {\n\t{ .compatible = \"cnxt,cx92755-usart\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, digicolor_uart_dt_ids);\n\nstatic struct platform_driver digicolor_uart_platform = {\n\t.driver = {\n\t\t.name\t\t= \"digicolor-usart\",\n\t\t.of_match_table\t= of_match_ptr(digicolor_uart_dt_ids),\n\t},\n\t.probe\t= digicolor_uart_probe,\n\t.remove\t= digicolor_uart_remove,\n};\n\nstatic int __init digicolor_uart_init(void)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_SERIAL_CONEXANT_DIGICOLOR_CONSOLE)) {\n\t\tdigicolor_uart.cons = &digicolor_console;\n\t\tdigicolor_console.data = &digicolor_uart;\n\t}\n\n\tret = uart_register_driver(&digicolor_uart);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&digicolor_uart_platform);\n\tif (ret)\n\t\tuart_unregister_driver(&digicolor_uart);\n\n\treturn ret;\n}\nmodule_init(digicolor_uart_init);\n\nstatic void __exit digicolor_uart_exit(void)\n{\n\tplatform_driver_unregister(&digicolor_uart_platform);\n\tuart_unregister_driver(&digicolor_uart);\n}\nmodule_exit(digicolor_uart_exit);\n\nMODULE_AUTHOR(\"Baruch Siach <baruch@tkos.co.il>\");\nMODULE_DESCRIPTION(\"Conexant Digicolor USART serial driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}