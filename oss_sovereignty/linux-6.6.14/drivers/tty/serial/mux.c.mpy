{
  "module_name": "mux.c",
  "hash_id": "b0103a1ef48325a9da667705dbe6c9af9366af6a53bb42f17792bdc8cfff9076",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/mux.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/serial.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/console.h>\n#include <linux/delay.h>  \n#include <linux/device.h>\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <asm/parisc-device.h>\n\n#include <linux/sysrq.h>\n#include <linux/serial_core.h>\n\n#define MUX_OFFSET 0x800\n#define MUX_LINE_OFFSET 0x80\n\n#define MUX_FIFO_SIZE 255\n#define MUX_POLL_DELAY (30 * HZ / 1000)\n\n#define IO_DATA_REG_OFFSET 0x3c\n#define IO_DCOUNT_REG_OFFSET 0x40\n\n#define MUX_EOFIFO(status) ((status & 0xF000) == 0xF000)\n#define MUX_STATUS(status) ((status & 0xF000) == 0x8000)\n#define MUX_BREAK(status) ((status & 0xF000) == 0x2000)\n\n#define MUX_NR 256\nstatic unsigned int port_cnt __read_mostly;\nstruct mux_port {\n\tstruct uart_port port;\n\tint enabled;\n};\nstatic struct mux_port mux_ports[MUX_NR];\n\nstatic struct uart_driver mux_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = \"ttyB\",\n\t.dev_name = \"ttyB\",\n\t.major = MUX_MAJOR,\n\t.minor = 0,\n\t.nr = MUX_NR,\n};\n\nstatic struct timer_list mux_timer;\n\n#define UART_PUT_CHAR(p, c) __raw_writel((c), (p)->membase + IO_DATA_REG_OFFSET)\n#define UART_GET_FIFO_CNT(p) __raw_readl((p)->membase + IO_DCOUNT_REG_OFFSET)\n\n \nstatic int __init get_mux_port_count(struct parisc_device *dev)\n{\n\tint status;\n\tu8 iodc_data[32];\n\tunsigned long bytecnt;\n\n\t \n\tif(dev->id.hversion == 0x15)\n\t\treturn 1;\n\n\tstatus = pdc_iodc_read(&bytecnt, dev->hpa.start, 0, iodc_data, 32);\n\tBUG_ON(status != PDC_OK);\n\n\t \n\treturn ((((iodc_data)[4] & 0xf0) >> 4) * 8) + 8;\n}\n\n \nstatic unsigned int mux_tx_empty(struct uart_port *port)\n{\n\treturn UART_GET_FIFO_CNT(port) ? 0 : TIOCSER_TEMT;\n} \n\n \nstatic void mux_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n}\n\n \nstatic unsigned int mux_get_mctrl(struct uart_port *port)\n{ \n\treturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n}\n\n \nstatic void mux_stop_tx(struct uart_port *port)\n{\n}\n\n \nstatic void mux_start_tx(struct uart_port *port)\n{\n}\n\n \nstatic void mux_stop_rx(struct uart_port *port)\n{\n}\n\n \nstatic void mux_break_ctl(struct uart_port *port, int break_state)\n{\n}\n\nstatic void mux_tx_done(struct uart_port *port)\n{\n\t \n\twhile (UART_GET_FIFO_CNT(port))\n\t\tudelay(1);\n}\n\n \nstatic void mux_write(struct uart_port *port)\n{\n\tu8 ch;\n\n\tuart_port_tx_limited(port, ch,\n\t\tport->fifosize - UART_GET_FIFO_CNT(port),\n\t\ttrue,\n\t\tUART_PUT_CHAR(port, ch),\n\t\tmux_tx_done(port));\n}\n\n \nstatic void mux_read(struct uart_port *port)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tint data;\n\t__u32 start_count = port->icount.rx;\n\n\twhile(1) {\n\t\tdata = __raw_readl(port->membase + IO_DATA_REG_OFFSET);\n\n\t\tif (MUX_STATUS(data))\n\t\t\tcontinue;\n\n\t\tif (MUX_EOFIFO(data))\n\t\t\tbreak;\n\n\t\tport->icount.rx++;\n\n\t\tif (MUX_BREAK(data)) {\n\t\t\tport->icount.brk++;\n\t\t\tif(uart_handle_break(port))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, data & 0xffu))\n\t\t\tcontinue;\n\n\t\ttty_insert_flip_char(tport, data & 0xFF, TTY_NORMAL);\n\t}\n\t\n\tif (start_count != port->icount.rx)\n\t\ttty_flip_buffer_push(tport);\n}\n\n \nstatic int mux_startup(struct uart_port *port)\n{\n\tmux_ports[port->line].enabled = 1;\n\treturn 0;\n}\n\n \nstatic void mux_shutdown(struct uart_port *port)\n{\n\tmux_ports[port->line].enabled = 0;\n}\n\n \nstatic void\nmux_set_termios(struct uart_port *port, struct ktermios *termios,\n\t        const struct ktermios *old)\n{\n}\n\n \nstatic const char *mux_type(struct uart_port *port)\n{\n\treturn \"Mux\";\n}\n\n \nstatic void mux_release_port(struct uart_port *port)\n{\n}\n\n \nstatic int mux_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\n \nstatic void mux_config_port(struct uart_port *port, int type)\n{\n\tport->type = PORT_MUX;\n}\n\n \nstatic int mux_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tif(port->membase == NULL)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic void mux_poll(struct timer_list *unused)\n{  \n\tint i;\n\n\tfor(i = 0; i < port_cnt; ++i) {\n\t\tif(!mux_ports[i].enabled)\n\t\t\tcontinue;\n\n\t\tmux_read(&mux_ports[i].port);\n\t\tmux_write(&mux_ports[i].port);\n\t}\n\n\tmod_timer(&mux_timer, jiffies + MUX_POLL_DELAY);\n}\n\n\n#ifdef CONFIG_SERIAL_MUX_CONSOLE\nstatic void mux_console_write(struct console *co, const char *s, unsigned count)\n{\n\t \n\twhile(UART_GET_FIFO_CNT(&mux_ports[0].port))\n\t\tudelay(1);\n\n\twhile(count--) {\n\t\tif(*s == '\\n') {\n\t\t\tUART_PUT_CHAR(&mux_ports[0].port, '\\r');\n\t\t}\n\t\tUART_PUT_CHAR(&mux_ports[0].port, *s++);\n\t}\n\n}\n\nstatic int mux_console_setup(struct console *co, char *options)\n{\n        return 0;\n}\n\nstatic struct console mux_console = {\n\t.name =\t\t\"ttyB\",\n\t.write =\tmux_console_write,\n\t.device =\tuart_console_device,\n\t.setup =\tmux_console_setup,\n\t.flags =\tCON_ENABLED | CON_PRINTBUFFER,\n\t.index =\t0,\n\t.data =\t\t&mux_driver,\n};\n\n#define MUX_CONSOLE\t&mux_console\n#else\n#define MUX_CONSOLE\tNULL\n#endif\n\nstatic const struct uart_ops mux_pops = {\n\t.tx_empty =\t\tmux_tx_empty,\n\t.set_mctrl =\t\tmux_set_mctrl,\n\t.get_mctrl =\t\tmux_get_mctrl,\n\t.stop_tx =\t\tmux_stop_tx,\n\t.start_tx =\t\tmux_start_tx,\n\t.stop_rx =\t\tmux_stop_rx,\n\t.break_ctl =\t\tmux_break_ctl,\n\t.startup =\t\tmux_startup,\n\t.shutdown =\t\tmux_shutdown,\n\t.set_termios =\t\tmux_set_termios,\n\t.type =\t\t\tmux_type,\n\t.release_port =\t\tmux_release_port,\n\t.request_port =\t\tmux_request_port,\n\t.config_port =\t\tmux_config_port,\n\t.verify_port =\t\tmux_verify_port,\n};\n\n \nstatic int __init mux_probe(struct parisc_device *dev)\n{\n\tint i, status;\n\n\tint port_count = get_mux_port_count(dev);\n\tprintk(KERN_INFO \"Serial mux driver (%d ports) Revision: 0.6\\n\", port_count);\n\n\tdev_set_drvdata(&dev->dev, (void *)(long)port_count);\n\trequest_mem_region(dev->hpa.start + MUX_OFFSET,\n                           port_count * MUX_LINE_OFFSET, \"Mux\");\n\n\tif(!port_cnt) {\n\t\tmux_driver.cons = MUX_CONSOLE;\n\n\t\tstatus = uart_register_driver(&mux_driver);\n\t\tif(status) {\n\t\t\tprintk(KERN_ERR \"Serial mux: Unable to register driver.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor(i = 0; i < port_count; ++i, ++port_cnt) {\n\t\tstruct uart_port *port = &mux_ports[port_cnt].port;\n\t\tport->iobase\t= 0;\n\t\tport->mapbase\t= dev->hpa.start + MUX_OFFSET +\n\t\t\t\t\t\t(i * MUX_LINE_OFFSET);\n\t\tport->membase\t= ioremap(port->mapbase, MUX_LINE_OFFSET);\n\t\tport->iotype\t= UPIO_MEM;\n\t\tport->type\t= PORT_MUX;\n\t\tport->irq\t= 0;\n\t\tport->uartclk\t= 0;\n\t\tport->fifosize\t= MUX_FIFO_SIZE;\n\t\tport->ops\t= &mux_pops;\n\t\tport->flags\t= UPF_BOOT_AUTOCONF;\n\t\tport->line\t= port_cnt;\n\t\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_MUX_CONSOLE);\n\n\t\tspin_lock_init(&port->lock);\n\n\t\tstatus = uart_add_one_port(&mux_driver, port);\n\t\tBUG_ON(status);\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit mux_remove(struct parisc_device *dev)\n{\n\tint i, j;\n\tint port_count = (long)dev_get_drvdata(&dev->dev);\n\n\t \n\tfor(i = 0; i < port_cnt; ++i) {\n\t\tif(mux_ports[i].port.mapbase == dev->hpa.start + MUX_OFFSET)\n\t\t\tbreak;\n\t}\n\tBUG_ON(i + port_count > port_cnt);\n\n\t \n\tfor(j = 0; j < port_count; ++j, ++i) {\n\t\tstruct uart_port *port = &mux_ports[i].port;\n\n\t\tuart_remove_one_port(&mux_driver, port);\n\t\tif(port->membase)\n\t\t\tiounmap(port->membase);\n\t}\n\n\trelease_mem_region(dev->hpa.start + MUX_OFFSET, port_count * MUX_LINE_OFFSET);\n}\n\n \nstatic const struct parisc_device_id builtin_mux_tbl[] __initconst = {\n\t{ HPHW_A_DIRECT, HVERSION_REV_ANY_ID, 0x15, 0x0000D },  \n\t{ HPHW_A_DIRECT, HVERSION_REV_ANY_ID, 0x44, 0x0000D },  \n\t{ 0, }\n};\n\nstatic const struct parisc_device_id mux_tbl[] __initconst = {\n\t{ HPHW_A_DIRECT, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0000D },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(parisc, builtin_mux_tbl);\nMODULE_DEVICE_TABLE(parisc, mux_tbl);\n\nstatic struct parisc_driver builtin_serial_mux_driver __refdata = {\n\t.name =\t\t\"builtin_serial_mux\",\n\t.id_table =\tbuiltin_mux_tbl,\n\t.probe =\tmux_probe,\n\t.remove =       __exit_p(mux_remove),\n};\n\nstatic struct parisc_driver serial_mux_driver __refdata = {\n\t.name =\t\t\"serial_mux\",\n\t.id_table =\tmux_tbl,\n\t.probe =\tmux_probe,\n\t.remove =       __exit_p(mux_remove),\n};\n\n \nstatic int __init mux_init(void)\n{\n\tregister_parisc_driver(&builtin_serial_mux_driver);\n\tregister_parisc_driver(&serial_mux_driver);\n\n\tif(port_cnt > 0) {\n\t\t \n\t\ttimer_setup(&mux_timer, mux_poll, 0);\n\t\tmod_timer(&mux_timer, jiffies + MUX_POLL_DELAY);\n\n#ifdef CONFIG_SERIAL_MUX_CONSOLE\n\t        register_console(&mux_console);\n#endif\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __exit mux_exit(void)\n{\n\t \n\tif(port_cnt > 0) {\n\t\tdel_timer_sync(&mux_timer);\n#ifdef CONFIG_SERIAL_MUX_CONSOLE\n\t\tunregister_console(&mux_console);\n#endif\n\t}\n\n\tunregister_parisc_driver(&builtin_serial_mux_driver);\n\tunregister_parisc_driver(&serial_mux_driver);\n\tuart_unregister_driver(&mux_driver);\n}\n\nmodule_init(mux_init);\nmodule_exit(mux_exit);\n\nMODULE_AUTHOR(\"Ryan Bradetich\");\nMODULE_DESCRIPTION(\"Serial MUX driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CHARDEV_MAJOR(MUX_MAJOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}