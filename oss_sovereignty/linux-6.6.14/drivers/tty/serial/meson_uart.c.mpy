{
  "module_name": "meson_uart.c",
  "hash_id": "2d890552af39367917ec4a4ac59873a723f7019720f5ff9019bc95f2d1a8a674",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/meson_uart.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n \n#define AML_UART_WFIFO\t\t\t0x00\n#define AML_UART_RFIFO\t\t\t0x04\n#define AML_UART_CONTROL\t\t0x08\n#define AML_UART_STATUS\t\t\t0x0c\n#define AML_UART_MISC\t\t\t0x10\n#define AML_UART_REG5\t\t\t0x14\n\n \n#define AML_UART_TX_EN\t\t\tBIT(12)\n#define AML_UART_RX_EN\t\t\tBIT(13)\n#define AML_UART_TWO_WIRE_EN\t\tBIT(15)\n#define AML_UART_STOP_BIT_LEN_MASK\t(0x03 << 16)\n#define AML_UART_STOP_BIT_1SB\t\t(0x00 << 16)\n#define AML_UART_STOP_BIT_2SB\t\t(0x01 << 16)\n#define AML_UART_PARITY_TYPE\t\tBIT(18)\n#define AML_UART_PARITY_EN\t\tBIT(19)\n#define AML_UART_TX_RST\t\t\tBIT(22)\n#define AML_UART_RX_RST\t\t\tBIT(23)\n#define AML_UART_CLEAR_ERR\t\tBIT(24)\n#define AML_UART_RX_INT_EN\t\tBIT(27)\n#define AML_UART_TX_INT_EN\t\tBIT(28)\n#define AML_UART_DATA_LEN_MASK\t\t(0x03 << 20)\n#define AML_UART_DATA_LEN_8BIT\t\t(0x00 << 20)\n#define AML_UART_DATA_LEN_7BIT\t\t(0x01 << 20)\n#define AML_UART_DATA_LEN_6BIT\t\t(0x02 << 20)\n#define AML_UART_DATA_LEN_5BIT\t\t(0x03 << 20)\n\n \n#define AML_UART_PARITY_ERR\t\tBIT(16)\n#define AML_UART_FRAME_ERR\t\tBIT(17)\n#define AML_UART_TX_FIFO_WERR\t\tBIT(18)\n#define AML_UART_RX_EMPTY\t\tBIT(20)\n#define AML_UART_TX_FULL\t\tBIT(21)\n#define AML_UART_TX_EMPTY\t\tBIT(22)\n#define AML_UART_XMIT_BUSY\t\tBIT(25)\n#define AML_UART_ERR\t\t\t(AML_UART_PARITY_ERR | \\\n\t\t\t\t\t AML_UART_FRAME_ERR  | \\\n\t\t\t\t\t AML_UART_TX_FIFO_WERR)\n\n \n#define AML_UART_XMIT_IRQ(c)\t\t(((c) & 0xff) << 8)\n#define AML_UART_RECV_IRQ(c)\t\t((c) & 0xff)\n\n \n#define AML_UART_BAUD_MASK\t\t0x7fffff\n#define AML_UART_BAUD_USE\t\tBIT(23)\n#define AML_UART_BAUD_XTAL\t\tBIT(24)\n#define AML_UART_BAUD_XTAL_DIV2\t\tBIT(27)\n\n#define AML_UART_PORT_NUM\t\t12\n#define AML_UART_PORT_OFFSET\t\t6\n\n#define AML_UART_POLL_USEC\t\t5\n#define AML_UART_TIMEOUT_USEC\t\t10000\n\nstatic struct uart_driver meson_uart_driver_ttyAML;\nstatic struct uart_driver meson_uart_driver_ttyS;\n\nstatic struct uart_port *meson_ports[AML_UART_PORT_NUM];\n\nstruct meson_uart_data {\n\tstruct uart_driver *uart_driver;\n\tbool has_xtal_div2;\n};\n\nstatic void meson_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n}\n\nstatic unsigned int meson_uart_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CTS;\n}\n\nstatic unsigned int meson_uart_tx_empty(struct uart_port *port)\n{\n\tu32 val;\n\n\tval = readl(port->membase + AML_UART_STATUS);\n\tval &= (AML_UART_TX_EMPTY | AML_UART_XMIT_BUSY);\n\treturn (val == AML_UART_TX_EMPTY) ? TIOCSER_TEMT : 0;\n}\n\nstatic void meson_uart_stop_tx(struct uart_port *port)\n{\n\tu32 val;\n\n\tval = readl(port->membase + AML_UART_CONTROL);\n\tval &= ~AML_UART_TX_INT_EN;\n\twritel(val, port->membase + AML_UART_CONTROL);\n}\n\nstatic void meson_uart_stop_rx(struct uart_port *port)\n{\n\tu32 val;\n\n\tval = readl(port->membase + AML_UART_CONTROL);\n\tval &= ~AML_UART_RX_EN;\n\twritel(val, port->membase + AML_UART_CONTROL);\n}\n\nstatic void meson_uart_shutdown(struct uart_port *port)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tfree_irq(port->irq, port);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tval = readl(port->membase + AML_UART_CONTROL);\n\tval &= ~AML_UART_RX_EN;\n\tval &= ~(AML_UART_RX_INT_EN | AML_UART_TX_INT_EN);\n\twritel(val, port->membase + AML_UART_CONTROL);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void meson_uart_start_tx(struct uart_port *port)\n{\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned int ch;\n\tu32 val;\n\n\tif (uart_tx_stopped(port)) {\n\t\tmeson_uart_stop_tx(port);\n\t\treturn;\n\t}\n\n\twhile (!(readl(port->membase + AML_UART_STATUS) & AML_UART_TX_FULL)) {\n\t\tif (port->x_char) {\n\t\t\twritel(port->x_char, port->membase + AML_UART_WFIFO);\n\t\t\tport->icount.tx++;\n\t\t\tport->x_char = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (uart_circ_empty(xmit))\n\t\t\tbreak;\n\n\t\tch = xmit->buf[xmit->tail];\n\t\twritel(ch, port->membase + AML_UART_WFIFO);\n\t\tuart_xmit_advance(port, 1);\n\t}\n\n\tif (!uart_circ_empty(xmit)) {\n\t\tval = readl(port->membase + AML_UART_CONTROL);\n\t\tval |= AML_UART_TX_INT_EN;\n\t\twritel(val, port->membase + AML_UART_CONTROL);\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n}\n\nstatic void meson_receive_chars(struct uart_port *port)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tchar flag;\n\tu32 ostatus, status, ch, mode;\n\n\tdo {\n\t\tflag = TTY_NORMAL;\n\t\tport->icount.rx++;\n\t\tostatus = status = readl(port->membase + AML_UART_STATUS);\n\n\t\tif (status & AML_UART_ERR) {\n\t\t\tif (status & AML_UART_TX_FIFO_WERR)\n\t\t\t\tport->icount.overrun++;\n\t\t\telse if (status & AML_UART_FRAME_ERR)\n\t\t\t\tport->icount.frame++;\n\t\t\telse if (status & AML_UART_PARITY_ERR)\n\t\t\t\tport->icount.frame++;\n\n\t\t\tmode = readl(port->membase + AML_UART_CONTROL);\n\t\t\tmode |= AML_UART_CLEAR_ERR;\n\t\t\twritel(mode, port->membase + AML_UART_CONTROL);\n\n\t\t\t \n\t\t\tmode &= ~AML_UART_CLEAR_ERR;\n\t\t\twritel(mode, port->membase + AML_UART_CONTROL);\n\n\t\t\tstatus &= port->read_status_mask;\n\t\t\tif (status & AML_UART_FRAME_ERR)\n\t\t\t\tflag = TTY_FRAME;\n\t\t\telse if (status & AML_UART_PARITY_ERR)\n\t\t\t\tflag = TTY_PARITY;\n\t\t}\n\n\t\tch = readl(port->membase + AML_UART_RFIFO);\n\t\tch &= 0xff;\n\n\t\tif ((ostatus & AML_UART_FRAME_ERR) && (ch == 0)) {\n\t\t\tport->icount.brk++;\n\t\t\tflag = TTY_BREAK;\n\t\t\tif (uart_handle_break(port))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tcontinue;\n\n\t\tif ((status & port->ignore_status_mask) == 0)\n\t\t\ttty_insert_flip_char(tport, ch, flag);\n\n\t\tif (status & AML_UART_TX_FIFO_WERR)\n\t\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\n\t} while (!(readl(port->membase + AML_UART_STATUS) & AML_UART_RX_EMPTY));\n\n\ttty_flip_buffer_push(tport);\n}\n\nstatic irqreturn_t meson_uart_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_port *port = (struct uart_port *)dev_id;\n\n\tspin_lock(&port->lock);\n\n\tif (!(readl(port->membase + AML_UART_STATUS) & AML_UART_RX_EMPTY))\n\t\tmeson_receive_chars(port);\n\n\tif (!(readl(port->membase + AML_UART_STATUS) & AML_UART_TX_FULL)) {\n\t\tif (readl(port->membase + AML_UART_CONTROL) & AML_UART_TX_INT_EN)\n\t\t\tmeson_uart_start_tx(port);\n\t}\n\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const char *meson_uart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_MESON) ? \"meson_uart\" : NULL;\n}\n\n \nstatic void meson_uart_reset(struct uart_port *port)\n{\n\tu32 val;\n\n\tval = readl(port->membase + AML_UART_CONTROL);\n\tval |= (AML_UART_RX_RST | AML_UART_TX_RST | AML_UART_CLEAR_ERR);\n\twritel(val, port->membase + AML_UART_CONTROL);\n\n\tval &= ~(AML_UART_RX_RST | AML_UART_TX_RST | AML_UART_CLEAR_ERR);\n\twritel(val, port->membase + AML_UART_CONTROL);\n}\n\nstatic int meson_uart_startup(struct uart_port *port)\n{\n\tunsigned long flags;\n\tu32 val;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tval = readl(port->membase + AML_UART_CONTROL);\n\tval |= AML_UART_CLEAR_ERR;\n\twritel(val, port->membase + AML_UART_CONTROL);\n\tval &= ~AML_UART_CLEAR_ERR;\n\twritel(val, port->membase + AML_UART_CONTROL);\n\n\tval |= (AML_UART_RX_EN | AML_UART_TX_EN);\n\twritel(val, port->membase + AML_UART_CONTROL);\n\n\tval |= (AML_UART_RX_INT_EN | AML_UART_TX_INT_EN);\n\twritel(val, port->membase + AML_UART_CONTROL);\n\n\tval = (AML_UART_RECV_IRQ(1) | AML_UART_XMIT_IRQ(port->fifosize / 2));\n\twritel(val, port->membase + AML_UART_MISC);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tret = request_irq(port->irq, meson_uart_interrupt, 0,\n\t\t\t  port->name, port);\n\n\treturn ret;\n}\n\nstatic void meson_uart_change_speed(struct uart_port *port, unsigned long baud)\n{\n\tconst struct meson_uart_data *private_data = port->private_data;\n\tu32 val = 0;\n\n\twhile (!meson_uart_tx_empty(port))\n\t\tcpu_relax();\n\n\tif (port->uartclk == 24000000) {\n\t\tunsigned int xtal_div = 3;\n\n\t\tif (private_data && private_data->has_xtal_div2) {\n\t\t\txtal_div = 2;\n\t\t\tval |= AML_UART_BAUD_XTAL_DIV2;\n\t\t}\n\t\tval |= DIV_ROUND_CLOSEST(port->uartclk / xtal_div, baud) - 1;\n\t\tval |= AML_UART_BAUD_XTAL;\n\t} else {\n\t\tval =  DIV_ROUND_CLOSEST(port->uartclk / 4, baud) - 1;\n\t}\n\tval |= AML_UART_BAUD_USE;\n\twritel(val, port->membase + AML_UART_REG5);\n}\n\nstatic void meson_uart_set_termios(struct uart_port *port,\n\t\t\t\t   struct ktermios *termios,\n\t\t\t\t   const struct ktermios *old)\n{\n\tunsigned int cflags, iflags, baud;\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tcflags = termios->c_cflag;\n\tiflags = termios->c_iflag;\n\n\tval = readl(port->membase + AML_UART_CONTROL);\n\n\tval &= ~AML_UART_DATA_LEN_MASK;\n\tswitch (cflags & CSIZE) {\n\tcase CS8:\n\t\tval |= AML_UART_DATA_LEN_8BIT;\n\t\tbreak;\n\tcase CS7:\n\t\tval |= AML_UART_DATA_LEN_7BIT;\n\t\tbreak;\n\tcase CS6:\n\t\tval |= AML_UART_DATA_LEN_6BIT;\n\t\tbreak;\n\tcase CS5:\n\t\tval |= AML_UART_DATA_LEN_5BIT;\n\t\tbreak;\n\t}\n\n\tif (cflags & PARENB)\n\t\tval |= AML_UART_PARITY_EN;\n\telse\n\t\tval &= ~AML_UART_PARITY_EN;\n\n\tif (cflags & PARODD)\n\t\tval |= AML_UART_PARITY_TYPE;\n\telse\n\t\tval &= ~AML_UART_PARITY_TYPE;\n\n\tval &= ~AML_UART_STOP_BIT_LEN_MASK;\n\tif (cflags & CSTOPB)\n\t\tval |= AML_UART_STOP_BIT_2SB;\n\telse\n\t\tval |= AML_UART_STOP_BIT_1SB;\n\n\tif (cflags & CRTSCTS) {\n\t\tif (port->flags & UPF_HARD_FLOW)\n\t\t\tval &= ~AML_UART_TWO_WIRE_EN;\n\t\telse\n\t\t\ttermios->c_cflag &= ~CRTSCTS;\n\t} else {\n\t\tval |= AML_UART_TWO_WIRE_EN;\n\t}\n\n\twritel(val, port->membase + AML_UART_CONTROL);\n\n\tbaud = uart_get_baud_rate(port, termios, old, 50, 4000000);\n\tmeson_uart_change_speed(port, baud);\n\n\tport->read_status_mask = AML_UART_TX_FIFO_WERR;\n\tif (iflags & INPCK)\n\t\tport->read_status_mask |= AML_UART_PARITY_ERR |\n\t\t\t\t\t  AML_UART_FRAME_ERR;\n\n\tport->ignore_status_mask = 0;\n\tif (iflags & IGNPAR)\n\t\tport->ignore_status_mask |= AML_UART_PARITY_ERR |\n\t\t\t\t\t    AML_UART_FRAME_ERR;\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int meson_uart_verify_port(struct uart_port *port,\n\t\t\t\t  struct serial_struct *ser)\n{\n\tint ret = 0;\n\n\tif (port->type != PORT_MESON)\n\t\tret = -EINVAL;\n\tif (port->irq != ser->irq)\n\t\tret = -EINVAL;\n\tif (ser->baud_base < 9600)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\nstatic void meson_uart_release_port(struct uart_port *port)\n{\n\tdevm_iounmap(port->dev, port->membase);\n\tport->membase = NULL;\n\tdevm_release_mem_region(port->dev, port->mapbase, port->mapsize);\n}\n\nstatic int meson_uart_request_port(struct uart_port *port)\n{\n\tif (!devm_request_mem_region(port->dev, port->mapbase, port->mapsize,\n\t\t\t\t     dev_name(port->dev))) {\n\t\tdev_err(port->dev, \"Memory region busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tport->membase = devm_ioremap(port->dev, port->mapbase,\n\t\t\t\t\t     port->mapsize);\n\tif (!port->membase)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void meson_uart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_MESON;\n\t\tmeson_uart_request_port(port);\n\t}\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n \n\nstatic int meson_uart_poll_get_char(struct uart_port *port)\n{\n\tu32 c;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (readl(port->membase + AML_UART_STATUS) & AML_UART_RX_EMPTY)\n\t\tc = NO_POLL_CHAR;\n\telse\n\t\tc = readl(port->membase + AML_UART_RFIFO);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn c;\n}\n\nstatic void meson_uart_poll_put_char(struct uart_port *port, unsigned char c)\n{\n\tunsigned long flags;\n\tu32 reg;\n\tint ret;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tret = readl_poll_timeout_atomic(port->membase + AML_UART_STATUS, reg,\n\t\t\t\t\treg & AML_UART_TX_EMPTY,\n\t\t\t\t\tAML_UART_POLL_USEC,\n\t\t\t\t\tAML_UART_TIMEOUT_USEC);\n\tif (ret == -ETIMEDOUT) {\n\t\tdev_err(port->dev, \"Timeout waiting for UART TX EMPTY\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\twritel(c, port->membase + AML_UART_WFIFO);\n\n\t \n\tret = readl_poll_timeout_atomic(port->membase + AML_UART_STATUS, reg,\n\t\t\t\t\treg & AML_UART_TX_EMPTY,\n\t\t\t\t\tAML_UART_POLL_USEC,\n\t\t\t\t\tAML_UART_TIMEOUT_USEC);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(port->dev, \"Timeout waiting for UART TX EMPTY\\n\");\n\nout:\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n#endif  \n\nstatic const struct uart_ops meson_uart_ops = {\n\t.set_mctrl      = meson_uart_set_mctrl,\n\t.get_mctrl      = meson_uart_get_mctrl,\n\t.tx_empty\t= meson_uart_tx_empty,\n\t.start_tx\t= meson_uart_start_tx,\n\t.stop_tx\t= meson_uart_stop_tx,\n\t.stop_rx\t= meson_uart_stop_rx,\n\t.startup\t= meson_uart_startup,\n\t.shutdown\t= meson_uart_shutdown,\n\t.set_termios\t= meson_uart_set_termios,\n\t.type\t\t= meson_uart_type,\n\t.config_port\t= meson_uart_config_port,\n\t.request_port\t= meson_uart_request_port,\n\t.release_port\t= meson_uart_release_port,\n\t.verify_port\t= meson_uart_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= meson_uart_poll_get_char,\n\t.poll_put_char\t= meson_uart_poll_put_char,\n#endif\n};\n\n#ifdef CONFIG_SERIAL_MESON_CONSOLE\nstatic void meson_uart_enable_tx_engine(struct uart_port *port)\n{\n\tu32 val;\n\n\tval = readl(port->membase + AML_UART_CONTROL);\n\tval |= AML_UART_TX_EN;\n\twritel(val, port->membase + AML_UART_CONTROL);\n}\n\nstatic void meson_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tif (!port->membase)\n\t\treturn;\n\n\twhile (readl(port->membase + AML_UART_STATUS) & AML_UART_TX_FULL)\n\t\tcpu_relax();\n\twritel(ch, port->membase + AML_UART_WFIFO);\n}\n\nstatic void meson_serial_port_write(struct uart_port *port, const char *s,\n\t\t\t\t    u_int count)\n{\n\tunsigned long flags;\n\tint locked;\n\tu32 val, tmp;\n\n\tlocal_irq_save(flags);\n\tif (port->sysrq) {\n\t\tlocked = 0;\n\t} else if (oops_in_progress) {\n\t\tlocked = spin_trylock(&port->lock);\n\t} else {\n\t\tspin_lock(&port->lock);\n\t\tlocked = 1;\n\t}\n\n\tval = readl(port->membase + AML_UART_CONTROL);\n\ttmp = val & ~(AML_UART_TX_INT_EN | AML_UART_RX_INT_EN);\n\twritel(tmp, port->membase + AML_UART_CONTROL);\n\n\tuart_console_write(port, s, count, meson_console_putchar);\n\twritel(val, port->membase + AML_UART_CONTROL);\n\n\tif (locked)\n\t\tspin_unlock(&port->lock);\n\tlocal_irq_restore(flags);\n}\n\nstatic void meson_serial_console_write(struct console *co, const char *s,\n\t\t\t\t       u_int count)\n{\n\tstruct uart_port *port;\n\n\tport = meson_ports[co->index];\n\tif (!port)\n\t\treturn;\n\n\tmeson_serial_port_write(port, s, count);\n}\n\nstatic int meson_serial_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index < 0 || co->index >= AML_UART_PORT_NUM)\n\t\treturn -EINVAL;\n\n\tport = meson_ports[co->index];\n\tif (!port || !port->membase)\n\t\treturn -ENODEV;\n\n\tmeson_uart_enable_tx_engine(port);\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\n#define MESON_SERIAL_CONSOLE(_devname)\t\t\t\t\t\\\n\tstatic struct console meson_serial_console_##_devname = {\t\\\n\t\t.name\t\t= __stringify(_devname),\t\t\\\n\t\t.write\t\t= meson_serial_console_write,\t\t\\\n\t\t.device\t\t= uart_console_device,\t\t\t\\\n\t\t.setup\t\t= meson_serial_console_setup,\t\t\\\n\t\t.flags\t\t= CON_PRINTBUFFER,\t\t\t\\\n\t\t.index\t\t= -1,\t\t\t\t\t\\\n\t\t.data\t\t= &meson_uart_driver_##_devname,\t\\\n\t}\n\nMESON_SERIAL_CONSOLE(ttyAML);\nMESON_SERIAL_CONSOLE(ttyS);\n\nstatic void meson_serial_early_console_write(struct console *co,\n\t\t\t\t\t     const char *s,\n\t\t\t\t\t     u_int count)\n{\n\tstruct earlycon_device *dev = co->data;\n\n\tmeson_serial_port_write(&dev->port, s, count);\n}\n\nstatic int __init\nmeson_serial_early_console_setup(struct earlycon_device *device, const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tmeson_uart_enable_tx_engine(&device->port);\n\tdevice->con->write = meson_serial_early_console_write;\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(meson, \"amlogic,meson-ao-uart\",\n\t\t    meson_serial_early_console_setup);\n\n#define MESON_SERIAL_CONSOLE_PTR(_devname) (&meson_serial_console_##_devname)\n#else\n#define MESON_SERIAL_CONSOLE_PTR(_devname) (NULL)\n#endif\n\n#define MESON_UART_DRIVER(_devname)\t\t\t\t\t\\\n\tstatic struct uart_driver meson_uart_driver_##_devname = {\t\\\n\t\t.owner\t\t= THIS_MODULE,\t\t\t\t\\\n\t\t.driver_name\t= \"meson_uart\",\t\t\t\t\\\n\t\t.dev_name\t= __stringify(_devname),\t\t\\\n\t\t.nr\t\t= AML_UART_PORT_NUM,\t\t\t\\\n\t\t.cons\t\t= MESON_SERIAL_CONSOLE_PTR(_devname),\t\\\n\t}\n\nMESON_UART_DRIVER(ttyAML);\nMESON_UART_DRIVER(ttyS);\n\nstatic int meson_uart_probe_clocks(struct platform_device *pdev,\n\t\t\t\t   struct uart_port *port)\n{\n\tstruct clk *clk_xtal = NULL;\n\tstruct clk *clk_pclk = NULL;\n\tstruct clk *clk_baud = NULL;\n\n\tclk_pclk = devm_clk_get_enabled(&pdev->dev, \"pclk\");\n\tif (IS_ERR(clk_pclk))\n\t\treturn PTR_ERR(clk_pclk);\n\n\tclk_xtal = devm_clk_get_enabled(&pdev->dev, \"xtal\");\n\tif (IS_ERR(clk_xtal))\n\t\treturn PTR_ERR(clk_xtal);\n\n\tclk_baud = devm_clk_get_enabled(&pdev->dev, \"baud\");\n\tif (IS_ERR(clk_baud))\n\t\treturn PTR_ERR(clk_baud);\n\n\tport->uartclk = clk_get_rate(clk_baud);\n\n\treturn 0;\n}\n\nstatic struct uart_driver *meson_uart_current(const struct meson_uart_data *pd)\n{\n\treturn (pd && pd->uart_driver) ?\n\t\tpd->uart_driver : &meson_uart_driver_ttyAML;\n}\n\nstatic int meson_uart_probe(struct platform_device *pdev)\n{\n\tconst struct meson_uart_data *priv_data;\n\tstruct uart_driver *uart_driver;\n\tstruct resource *res_mem;\n\tstruct uart_port *port;\n\tu32 fifosize = 64;  \n\tint ret = 0;\n\tint irq;\n\tbool has_rtscts;\n\n\tif (pdev->dev.of_node)\n\t\tpdev->id = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\n\tif (pdev->id < 0) {\n\t\tint id;\n\n\t\tfor (id = AML_UART_PORT_OFFSET; id < AML_UART_PORT_NUM; id++) {\n\t\t\tif (!meson_ports[id]) {\n\t\t\t\tpdev->id = id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pdev->id < 0 || pdev->id >= AML_UART_PORT_NUM)\n\t\treturn -EINVAL;\n\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res_mem)\n\t\treturn -ENODEV;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tof_property_read_u32(pdev->dev.of_node, \"fifo-size\", &fifosize);\n\thas_rtscts = of_property_read_bool(pdev->dev.of_node, \"uart-has-rtscts\");\n\n\tif (meson_ports[pdev->id]) {\n\t\treturn dev_err_probe(&pdev->dev, -EBUSY,\n\t\t\t\t     \"port %d already allocated\\n\", pdev->id);\n\t}\n\n\tport = devm_kzalloc(&pdev->dev, sizeof(struct uart_port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tret = meson_uart_probe_clocks(pdev, port);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv_data = device_get_match_data(&pdev->dev);\n\n\tuart_driver = meson_uart_current(priv_data);\n\n\tif (!uart_driver->state) {\n\t\tret = uart_register_driver(uart_driver);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t\t     \"can't register uart driver\\n\");\n\t}\n\n\tport->iotype = UPIO_MEM;\n\tport->mapbase = res_mem->start;\n\tport->mapsize = resource_size(res_mem);\n\tport->irq = irq;\n\tport->flags = UPF_BOOT_AUTOCONF | UPF_LOW_LATENCY;\n\tif (has_rtscts)\n\t\tport->flags |= UPF_HARD_FLOW;\n\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_MESON_CONSOLE);\n\tport->dev = &pdev->dev;\n\tport->line = pdev->id;\n\tport->type = PORT_MESON;\n\tport->x_char = 0;\n\tport->ops = &meson_uart_ops;\n\tport->fifosize = fifosize;\n\tport->private_data = (void *)priv_data;\n\n\tmeson_ports[pdev->id] = port;\n\tplatform_set_drvdata(pdev, port);\n\n\t \n\tif (meson_uart_request_port(port) >= 0) {\n\t\tmeson_uart_reset(port);\n\t\tmeson_uart_release_port(port);\n\t}\n\n\tret = uart_add_one_port(uart_driver, port);\n\tif (ret)\n\t\tmeson_ports[pdev->id] = NULL;\n\n\treturn ret;\n}\n\nstatic int meson_uart_remove(struct platform_device *pdev)\n{\n\tstruct uart_driver *uart_driver;\n\tstruct uart_port *port;\n\n\tport = platform_get_drvdata(pdev);\n\tuart_driver = meson_uart_current(port->private_data);\n\tuart_remove_one_port(uart_driver, port);\n\tmeson_ports[pdev->id] = NULL;\n\n\tfor (int id = 0; id < AML_UART_PORT_NUM; id++)\n\t\tif (meson_ports[id])\n\t\t\treturn 0;\n\n\t \n\tuart_unregister_driver(uart_driver);\n\n\treturn 0;\n}\n\nstatic struct meson_uart_data meson_g12a_uart_data = {\n\t.has_xtal_div2 = true,\n};\n\nstatic struct meson_uart_data meson_a1_uart_data = {\n\t.uart_driver = &meson_uart_driver_ttyS,\n\t.has_xtal_div2 = false,\n};\n\nstatic struct meson_uart_data meson_s4_uart_data = {\n\t.uart_driver = &meson_uart_driver_ttyS,\n\t.has_xtal_div2 = true,\n};\n\nstatic const struct of_device_id meson_uart_dt_match[] = {\n\t{ .compatible = \"amlogic,meson6-uart\" },\n\t{ .compatible = \"amlogic,meson8-uart\" },\n\t{ .compatible = \"amlogic,meson8b-uart\" },\n\t{ .compatible = \"amlogic,meson-gx-uart\" },\n\t{\n\t\t.compatible = \"amlogic,meson-g12a-uart\",\n\t\t.data = (void *)&meson_g12a_uart_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-s4-uart\",\n\t\t.data = (void *)&meson_s4_uart_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-a1-uart\",\n\t\t.data = (void *)&meson_a1_uart_data,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, meson_uart_dt_match);\n\nstatic  struct platform_driver meson_uart_platform_driver = {\n\t.probe\t\t= meson_uart_probe,\n\t.remove\t\t= meson_uart_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"meson_uart\",\n\t\t.of_match_table\t= meson_uart_dt_match,\n\t},\n};\n\nmodule_platform_driver(meson_uart_platform_driver);\n\nMODULE_AUTHOR(\"Carlo Caione <carlo@caione.org>\");\nMODULE_DESCRIPTION(\"Amlogic Meson serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}