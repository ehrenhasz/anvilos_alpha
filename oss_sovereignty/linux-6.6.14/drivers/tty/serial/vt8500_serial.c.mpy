{
  "module_name": "vt8500_serial.c",
  "hash_id": "e6c5de59e6d1a355e622f757acd99f2f6512d363bd600d31a635e97da4b40445",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/vt8500_serial.c",
  "human_readable_source": "\n \n\n#include <linux/hrtimer.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/platform_device.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/err.h>\n\n \n\n#define VT8500_URTDR\t\t0x0000\t \n#define VT8500_URRDR\t\t0x0004\t \n#define VT8500_URDIV\t\t0x0008\t \n#define VT8500_URLCR\t\t0x000C\t \n#define VT8500_URICR\t\t0x0010\t \n#define VT8500_URIER\t\t0x0014\t \n#define VT8500_URISR\t\t0x0018\t \n#define VT8500_URUSR\t\t0x001c\t \n#define VT8500_URFCR\t\t0x0020\t \n#define VT8500_URFIDX\t\t0x0024\t \n#define VT8500_URBKR\t\t0x0028\t \n#define VT8500_URTOD\t\t0x002c\t \n#define VT8500_TXFIFO\t\t0x1000\t \n#define VT8500_RXFIFO\t\t0x1020\t \n\n \n\n#define TXDE\t(1 << 0)\t \n#define RXDF\t(1 << 1)\t \n#define TXFAE\t(1 << 2)\t \n#define TXFE\t(1 << 3)\t \n#define RXFAF\t(1 << 4)\t \n#define RXFF\t(1 << 5)\t \n#define TXUDR\t(1 << 6)\t \n#define RXOVER\t(1 << 7)\t \n#define PER\t(1 << 8)\t \n#define FER\t(1 << 9)\t \n#define TCTS\t(1 << 10)\t \n#define RXTOUT\t(1 << 11)\t \n#define BKDONE\t(1 << 12)\t \n#define ERR\t(1 << 13)\t \n\n#define RX_FIFO_INTS\t(RXFAF | RXFF | RXOVER | PER | FER | RXTOUT)\n#define TX_FIFO_INTS\t(TXFAE | TXFE | TXUDR)\n\n \n\n#define VT8500_TXEN\t(1 << 0)\t \n#define VT8500_RXEN\t(1 << 1)\t \n#define VT8500_CS8\t(1 << 2)\t \n#define VT8500_CSTOPB\t(1 << 3)\t \n#define VT8500_PARENB\t(1 << 4)\t \n#define VT8500_PARODD\t(1 << 5)\t \n#define VT8500_RTS\t(1 << 6)\t \n#define VT8500_LOOPBK\t(1 << 7)\t \n#define VT8500_DMA\t(1 << 8)\t \n#define VT8500_BREAK\t(1 << 9)\t \n#define VT8500_PSLVERR\t(1 << 10)\t \n#define VT8500_SWRTSCTS\t(1 << 11)\t \n\n \n\n#define VT8500_HAS_SWRTSCTS_SWITCH\t(1 << 1)\n\n#define VT8500_RECOMMENDED_CLK\t\t12000000\n#define VT8500_OVERSAMPLING_DIVISOR\t13\n#define VT8500_MAX_PORTS\t6\n\nstruct vt8500_port {\n\tstruct uart_port\tuart;\n\tchar\t\t\tname[16];\n\tstruct clk\t\t*clk;\n\tunsigned int\t\tclk_predivisor;\n\tunsigned int\t\tier;\n\tunsigned int\t\tvt8500_uart_flags;\n};\n\n \nstatic DECLARE_BITMAP(vt8500_ports_in_use, VT8500_MAX_PORTS);\n\nstatic inline void vt8500_write(struct uart_port *port, unsigned int val,\n\t\t\t     unsigned int off)\n{\n\twritel(val, port->membase + off);\n}\n\nstatic inline unsigned int vt8500_read(struct uart_port *port, unsigned int off)\n{\n\treturn readl(port->membase + off);\n}\n\nstatic void vt8500_stop_tx(struct uart_port *port)\n{\n\tstruct vt8500_port *vt8500_port = container_of(port,\n\t\t\t\t\t\t       struct vt8500_port,\n\t\t\t\t\t\t       uart);\n\n\tvt8500_port->ier &= ~TX_FIFO_INTS;\n\tvt8500_write(port, vt8500_port->ier, VT8500_URIER);\n}\n\nstatic void vt8500_stop_rx(struct uart_port *port)\n{\n\tstruct vt8500_port *vt8500_port = container_of(port,\n\t\t\t\t\t\t       struct vt8500_port,\n\t\t\t\t\t\t       uart);\n\n\tvt8500_port->ier &= ~RX_FIFO_INTS;\n\tvt8500_write(port, vt8500_port->ier, VT8500_URIER);\n}\n\nstatic void vt8500_enable_ms(struct uart_port *port)\n{\n\tstruct vt8500_port *vt8500_port = container_of(port,\n\t\t\t\t\t\t       struct vt8500_port,\n\t\t\t\t\t\t       uart);\n\n\tvt8500_port->ier |= TCTS;\n\tvt8500_write(port, vt8500_port->ier, VT8500_URIER);\n}\n\nstatic void handle_rx(struct uart_port *port)\n{\n\tstruct tty_port *tport = &port->state->port;\n\n\t \n\tif ((vt8500_read(port, VT8500_URISR) & RXOVER)) {\n\t\tport->icount.overrun++;\n\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\t}\n\n\t \n\twhile (vt8500_read(port, VT8500_URFIDX) & 0x1f00) {\n\t\tunsigned int c;\n\t\tchar flag = TTY_NORMAL;\n\n\t\tc = readw(port->membase + VT8500_RXFIFO) & 0x3ff;\n\n\t\t \n\t\tc &= ~port->read_status_mask;\n\n\t\tif (c & FER) {\n\t\t\tport->icount.frame++;\n\t\t\tflag = TTY_FRAME;\n\t\t} else if (c & PER) {\n\t\t\tport->icount.parity++;\n\t\t\tflag = TTY_PARITY;\n\t\t}\n\t\tport->icount.rx++;\n\n\t\tif (!uart_handle_sysrq_char(port, c))\n\t\t\ttty_insert_flip_char(tport, c, flag);\n\t}\n\n\ttty_flip_buffer_push(tport);\n}\n\nstatic unsigned int vt8500_tx_empty(struct uart_port *port)\n{\n\tunsigned int idx = vt8500_read(port, VT8500_URFIDX) & 0x1f;\n\n\treturn idx < 16 ? TIOCSER_TEMT : 0;\n}\n\nstatic void handle_tx(struct uart_port *port)\n{\n\tu8 ch;\n\n\tuart_port_tx(port, ch,\n\t\tvt8500_tx_empty(port),\n\t\twriteb(ch, port->membase + VT8500_TXFIFO));\n}\n\nstatic void vt8500_start_tx(struct uart_port *port)\n{\n\tstruct vt8500_port *vt8500_port = container_of(port,\n\t\t\t\t\t\t       struct vt8500_port,\n\t\t\t\t\t\t       uart);\n\n\tvt8500_port->ier &= ~TX_FIFO_INTS;\n\tvt8500_write(port, vt8500_port->ier, VT8500_URIER);\n\thandle_tx(port);\n\tvt8500_port->ier |= TX_FIFO_INTS;\n\tvt8500_write(port, vt8500_port->ier, VT8500_URIER);\n}\n\nstatic void handle_delta_cts(struct uart_port *port)\n{\n\tport->icount.cts++;\n\twake_up_interruptible(&port->state->port.delta_msr_wait);\n}\n\nstatic irqreturn_t vt8500_irq(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tunsigned long isr;\n\n\tspin_lock(&port->lock);\n\tisr = vt8500_read(port, VT8500_URISR);\n\n\t \n\tvt8500_write(port, isr, VT8500_URISR);\n\n\tif (isr & RX_FIFO_INTS)\n\t\thandle_rx(port);\n\tif (isr & TX_FIFO_INTS)\n\t\thandle_tx(port);\n\tif (isr & TCTS)\n\t\thandle_delta_cts(port);\n\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int vt8500_get_mctrl(struct uart_port *port)\n{\n\tunsigned int usr;\n\n\tusr = vt8500_read(port, VT8500_URUSR);\n\tif (usr & (1 << 4))\n\t\treturn TIOCM_CTS;\n\telse\n\t\treturn 0;\n}\n\nstatic void vt8500_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tunsigned int lcr = vt8500_read(port, VT8500_URLCR);\n\n\tif (mctrl & TIOCM_RTS)\n\t\tlcr |= VT8500_RTS;\n\telse\n\t\tlcr &= ~VT8500_RTS;\n\n\tvt8500_write(port, lcr, VT8500_URLCR);\n}\n\nstatic void vt8500_break_ctl(struct uart_port *port, int break_ctl)\n{\n\tif (break_ctl)\n\t\tvt8500_write(port,\n\t\t\t     vt8500_read(port, VT8500_URLCR) | VT8500_BREAK,\n\t\t\t     VT8500_URLCR);\n}\n\nstatic int vt8500_set_baud_rate(struct uart_port *port, unsigned int baud)\n{\n\tstruct vt8500_port *vt8500_port =\n\t\t\tcontainer_of(port, struct vt8500_port, uart);\n\tunsigned long div;\n\tunsigned int loops = 1000;\n\n\tdiv = ((vt8500_port->clk_predivisor - 1) & 0xf) << 16;\n\tdiv |= (uart_get_divisor(port, baud) - 1) & 0x3ff;\n\n\t \n\tbaud = port->uartclk / 16 / ((div & 0x3ff) + 1);\n\n\twhile ((vt8500_read(port, VT8500_URUSR) & (1 << 5)) && --loops)\n\t\tcpu_relax();\n\n\tvt8500_write(port, div, VT8500_URDIV);\n\n\t \n\tvt8500_write(port, mult_frac(baud, 4096, 1000000), VT8500_URBKR);\n\n\treturn baud;\n}\n\nstatic int vt8500_startup(struct uart_port *port)\n{\n\tstruct vt8500_port *vt8500_port =\n\t\t\tcontainer_of(port, struct vt8500_port, uart);\n\tint ret;\n\n\tsnprintf(vt8500_port->name, sizeof(vt8500_port->name),\n\t\t \"vt8500_serial%d\", port->line);\n\n\tret = request_irq(port->irq, vt8500_irq, IRQF_TRIGGER_HIGH,\n\t\t\t  vt8500_port->name, port);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tvt8500_write(port, 0x03, VT8500_URLCR);\t \n\n\treturn 0;\n}\n\nstatic void vt8500_shutdown(struct uart_port *port)\n{\n\tstruct vt8500_port *vt8500_port =\n\t\t\tcontainer_of(port, struct vt8500_port, uart);\n\n\tvt8500_port->ier = 0;\n\n\t \n\tvt8500_write(&vt8500_port->uart, 0, VT8500_URIER);\n\tvt8500_write(&vt8500_port->uart, 0x880, VT8500_URFCR);\n\tfree_irq(port->irq, port);\n}\n\nstatic void vt8500_set_termios(struct uart_port *port,\n\t\t\t       struct ktermios *termios,\n\t\t\t       const struct ktermios *old)\n{\n\tstruct vt8500_port *vt8500_port =\n\t\t\tcontainer_of(port, struct vt8500_port, uart);\n\tunsigned long flags;\n\tunsigned int baud, lcr;\n\tunsigned int loops = 1000;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 900, 921600);\n\tbaud = vt8500_set_baud_rate(port, baud);\n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\n\t \n\tlcr = vt8500_read(&vt8500_port->uart, VT8500_URLCR);\n\tlcr &= ~(VT8500_PARENB | VT8500_PARODD);\n\tif (termios->c_cflag & PARENB) {\n\t\tlcr |= VT8500_PARENB;\n\t\ttermios->c_cflag &= ~CMSPAR;\n\t\tif (termios->c_cflag & PARODD)\n\t\t\tlcr |= VT8500_PARODD;\n\t}\n\n\t \n\tlcr &= ~VT8500_CS8;\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS7:\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tlcr |= VT8500_CS8;\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= CS8;\n\t\tbreak;\n\t}\n\n\t \n\tlcr &= ~VT8500_CSTOPB;\n\tif (termios->c_cflag & CSTOPB)\n\t\tlcr |= VT8500_CSTOPB;\n\n\tlcr &= ~VT8500_SWRTSCTS;\n\tif (vt8500_port->vt8500_uart_flags & VT8500_HAS_SWRTSCTS_SWITCH)\n\t\tlcr |= VT8500_SWRTSCTS;\n\n\t \n\tvt8500_write(&vt8500_port->uart, lcr, VT8500_URLCR);\n\n\t \n\tport->read_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->read_status_mask = FER | PER;\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tvt8500_write(&vt8500_port->uart, 0x88c, VT8500_URFCR);\n\twhile ((vt8500_read(&vt8500_port->uart, VT8500_URFCR) & 0xc)\n\t\t\t\t\t\t\t&& --loops)\n\t\tcpu_relax();\n\n\t \n\tvt8500_port->ier = RX_FIFO_INTS | TX_FIFO_INTS;\n\n\t \n\tif (UART_ENABLE_MS(&vt8500_port->uart, termios->c_cflag))\n\t\tvt8500_port->ier |= TCTS;\n\n\tvt8500_write(&vt8500_port->uart, 0x881, VT8500_URFCR);\n\tvt8500_write(&vt8500_port->uart, vt8500_port->ier, VT8500_URIER);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *vt8500_type(struct uart_port *port)\n{\n\tstruct vt8500_port *vt8500_port =\n\t\t\tcontainer_of(port, struct vt8500_port, uart);\n\treturn vt8500_port->name;\n}\n\nstatic void vt8500_release_port(struct uart_port *port)\n{\n}\n\nstatic int vt8500_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void vt8500_config_port(struct uart_port *port, int flags)\n{\n\tport->type = PORT_VT8500;\n}\n\nstatic int vt8500_verify_port(struct uart_port *port,\n\t\t\t      struct serial_struct *ser)\n{\n\tif (unlikely(ser->type != PORT_UNKNOWN && ser->type != PORT_VT8500))\n\t\treturn -EINVAL;\n\tif (unlikely(port->irq != ser->irq))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct vt8500_port *vt8500_uart_ports[VT8500_MAX_PORTS];\nstatic struct uart_driver vt8500_uart_driver;\n\n#ifdef CONFIG_SERIAL_VT8500_CONSOLE\n\nstatic void wait_for_xmitr(struct uart_port *port)\n{\n\tunsigned int status, tmout = 10000;\n\n\t \n\tdo {\n\t\tstatus = vt8500_read(port, VT8500_URFIDX);\n\n\t\tif (--tmout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (status & 0x10);\n}\n\nstatic void vt8500_console_putchar(struct uart_port *port, unsigned char c)\n{\n\twait_for_xmitr(port);\n\twriteb(c, port->membase + VT8500_TXFIFO);\n}\n\nstatic void vt8500_console_write(struct console *co, const char *s,\n\t\t\t      unsigned int count)\n{\n\tstruct vt8500_port *vt8500_port = vt8500_uart_ports[co->index];\n\tunsigned long ier;\n\n\tBUG_ON(co->index < 0 || co->index >= vt8500_uart_driver.nr);\n\n\tier = vt8500_read(&vt8500_port->uart, VT8500_URIER);\n\tvt8500_write(&vt8500_port->uart, VT8500_URIER, 0);\n\n\tuart_console_write(&vt8500_port->uart, s, count,\n\t\t\t   vt8500_console_putchar);\n\n\t \n\twait_for_xmitr(&vt8500_port->uart);\n\tvt8500_write(&vt8500_port->uart, VT8500_URIER, ier);\n}\n\nstatic int __init vt8500_console_setup(struct console *co, char *options)\n{\n\tstruct vt8500_port *vt8500_port;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (unlikely(co->index >= vt8500_uart_driver.nr || co->index < 0))\n\t\treturn -ENXIO;\n\n\tvt8500_port = vt8500_uart_ports[co->index];\n\n\tif (!vt8500_port)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&vt8500_port->uart,\n\t\t\t\t co, baud, parity, bits, flow);\n}\n\nstatic struct console vt8500_console = {\n\t.name = \"ttyWMT\",\n\t.write = vt8500_console_write,\n\t.device = uart_console_device,\n\t.setup = vt8500_console_setup,\n\t.flags = CON_PRINTBUFFER,\n\t.index = -1,\n\t.data = &vt8500_uart_driver,\n};\n\n#define VT8500_CONSOLE\t(&vt8500_console)\n\n#else\n#define VT8500_CONSOLE\tNULL\n#endif\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int vt8500_get_poll_char(struct uart_port *port)\n{\n\tunsigned int status = vt8500_read(port, VT8500_URFIDX);\n\n\tif (!(status & 0x1f00))\n\t\treturn NO_POLL_CHAR;\n\n\treturn vt8500_read(port, VT8500_RXFIFO) & 0xff;\n}\n\nstatic void vt8500_put_poll_char(struct uart_port *port, unsigned char c)\n{\n\tunsigned int status, tmout = 10000;\n\n\tdo {\n\t\tstatus = vt8500_read(port, VT8500_URFIDX);\n\n\t\tif (--tmout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (status & 0x10);\n\n\tvt8500_write(port, c, VT8500_TXFIFO);\n}\n#endif\n\nstatic const struct uart_ops vt8500_uart_pops = {\n\t.tx_empty\t= vt8500_tx_empty,\n\t.set_mctrl\t= vt8500_set_mctrl,\n\t.get_mctrl\t= vt8500_get_mctrl,\n\t.stop_tx\t= vt8500_stop_tx,\n\t.start_tx\t= vt8500_start_tx,\n\t.stop_rx\t= vt8500_stop_rx,\n\t.enable_ms\t= vt8500_enable_ms,\n\t.break_ctl\t= vt8500_break_ctl,\n\t.startup\t= vt8500_startup,\n\t.shutdown\t= vt8500_shutdown,\n\t.set_termios\t= vt8500_set_termios,\n\t.type\t\t= vt8500_type,\n\t.release_port\t= vt8500_release_port,\n\t.request_port\t= vt8500_request_port,\n\t.config_port\t= vt8500_config_port,\n\t.verify_port\t= vt8500_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= vt8500_get_poll_char,\n\t.poll_put_char\t= vt8500_put_poll_char,\n#endif\n};\n\nstatic struct uart_driver vt8500_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"vt8500_serial\",\n\t.dev_name\t= \"ttyWMT\",\n\t.nr\t\t= 6,\n\t.cons\t\t= VT8500_CONSOLE,\n};\n\nstatic unsigned int vt8500_flags;  \nstatic unsigned int wm8880_flags = VT8500_HAS_SWRTSCTS_SWITCH;\n\nstatic const struct of_device_id wmt_dt_ids[] = {\n\t{ .compatible = \"via,vt8500-uart\", .data = &vt8500_flags},\n\t{ .compatible = \"wm,wm8880-uart\", .data = &wm8880_flags},\n\t{}\n};\n\nstatic int vt8500_serial_probe(struct platform_device *pdev)\n{\n\tstruct vt8500_port *vt8500_port;\n\tstruct resource *mmres;\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst unsigned int *flags;\n\tint ret;\n\tint port;\n\tint irq;\n\n\tflags = of_device_get_match_data(&pdev->dev);\n\tif (!flags)\n\t\treturn -EINVAL;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tif (np) {\n\t\tport = of_alias_get_id(np, \"serial\");\n\t\tif (port >= VT8500_MAX_PORTS)\n\t\t\tport = -1;\n\t} else {\n\t\tport = -1;\n\t}\n\n\tif (port < 0) {\n\t\t \n\t\tport = find_first_zero_bit(vt8500_ports_in_use,\n\t\t\t\t\t   VT8500_MAX_PORTS);\n\t}\n\n\tif (port >= VT8500_MAX_PORTS)\n\t\treturn -ENODEV;\n\n\t \n\tif (test_and_set_bit(port, vt8500_ports_in_use)) {\n\t\t \n\t\treturn -EBUSY;\n\t}\n\n\tvt8500_port = devm_kzalloc(&pdev->dev, sizeof(struct vt8500_port),\n\t\t\t\t   GFP_KERNEL);\n\tif (!vt8500_port)\n\t\treturn -ENOMEM;\n\n\tvt8500_port->uart.membase = devm_platform_get_and_ioremap_resource(pdev, 0, &mmres);\n\tif (IS_ERR(vt8500_port->uart.membase))\n\t\treturn PTR_ERR(vt8500_port->uart.membase);\n\n\tvt8500_port->clk = of_clk_get(pdev->dev.of_node, 0);\n\tif (IS_ERR(vt8500_port->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\treturn  -EINVAL;\n\t}\n\n\tret = clk_prepare_enable(vt8500_port->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tvt8500_port->vt8500_uart_flags = *flags;\n\tvt8500_port->clk_predivisor = DIV_ROUND_CLOSEST(\n\t\t\t\t\tclk_get_rate(vt8500_port->clk),\n\t\t\t\t\tVT8500_RECOMMENDED_CLK\n\t\t\t\t      );\n\tvt8500_port->uart.type = PORT_VT8500;\n\tvt8500_port->uart.iotype = UPIO_MEM;\n\tvt8500_port->uart.mapbase = mmres->start;\n\tvt8500_port->uart.irq = irq;\n\tvt8500_port->uart.fifosize = 16;\n\tvt8500_port->uart.ops = &vt8500_uart_pops;\n\tvt8500_port->uart.line = port;\n\tvt8500_port->uart.dev = &pdev->dev;\n\tvt8500_port->uart.flags = UPF_IOREMAP | UPF_BOOT_AUTOCONF;\n\tvt8500_port->uart.has_sysrq = IS_ENABLED(CONFIG_SERIAL_VT8500_CONSOLE);\n\n\t \n\tvt8500_port->uart.uartclk = 16 * clk_get_rate(vt8500_port->clk) /\n\t\t\t\t\tvt8500_port->clk_predivisor /\n\t\t\t\t\tVT8500_OVERSAMPLING_DIVISOR;\n\n\tsnprintf(vt8500_port->name, sizeof(vt8500_port->name),\n\t\t \"VT8500 UART%d\", pdev->id);\n\n\tvt8500_uart_ports[port] = vt8500_port;\n\n\tuart_add_one_port(&vt8500_uart_driver, &vt8500_port->uart);\n\n\tplatform_set_drvdata(pdev, vt8500_port);\n\n\treturn 0;\n}\n\nstatic struct platform_driver vt8500_platform_driver = {\n\t.probe  = vt8500_serial_probe,\n\t.driver = {\n\t\t.name = \"vt8500_serial\",\n\t\t.of_match_table = wmt_dt_ids,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nstatic int __init vt8500_serial_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&vt8500_uart_driver);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = platform_driver_register(&vt8500_platform_driver);\n\n\tif (unlikely(ret))\n\t\tuart_unregister_driver(&vt8500_uart_driver);\n\n\treturn ret;\n}\ndevice_initcall(vt8500_serial_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}