{
  "module_name": "sifive.c",
  "hash_id": "344b168558aa0d4b0ad874005506cc5109549b00c90c15d8cd447fda6b4b6557",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sifive.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/serial_core.h>\n#include <linux/serial_reg.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n \n\n \n#define SIFIVE_SERIAL_TXDATA_OFFS\t\t0x0\n#define SIFIVE_SERIAL_TXDATA_FULL_SHIFT\t\t31\n#define SIFIVE_SERIAL_TXDATA_FULL_MASK\t\t(1 << SIFIVE_SERIAL_TXDATA_FULL_SHIFT)\n#define SIFIVE_SERIAL_TXDATA_DATA_SHIFT\t\t0\n#define SIFIVE_SERIAL_TXDATA_DATA_MASK\t\t(0xff << SIFIVE_SERIAL_TXDATA_DATA_SHIFT)\n\n \n#define SIFIVE_SERIAL_RXDATA_OFFS\t\t0x4\n#define SIFIVE_SERIAL_RXDATA_EMPTY_SHIFT\t31\n#define SIFIVE_SERIAL_RXDATA_EMPTY_MASK\t\t(1 << SIFIVE_SERIAL_RXDATA_EMPTY_SHIFT)\n#define SIFIVE_SERIAL_RXDATA_DATA_SHIFT\t\t0\n#define SIFIVE_SERIAL_RXDATA_DATA_MASK\t\t(0xff << SIFIVE_SERIAL_RXDATA_DATA_SHIFT)\n\n \n#define SIFIVE_SERIAL_TXCTRL_OFFS\t\t0x8\n#define SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT\t16\n#define SIFIVE_SERIAL_TXCTRL_TXCNT_MASK\t\t(0x7 << SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT)\n#define SIFIVE_SERIAL_TXCTRL_NSTOP_SHIFT\t1\n#define SIFIVE_SERIAL_TXCTRL_NSTOP_MASK\t\t(1 << SIFIVE_SERIAL_TXCTRL_NSTOP_SHIFT)\n#define SIFIVE_SERIAL_TXCTRL_TXEN_SHIFT\t\t0\n#define SIFIVE_SERIAL_TXCTRL_TXEN_MASK\t\t(1 << SIFIVE_SERIAL_TXCTRL_TXEN_SHIFT)\n\n \n#define SIFIVE_SERIAL_RXCTRL_OFFS\t\t0xC\n#define SIFIVE_SERIAL_RXCTRL_RXCNT_SHIFT\t16\n#define SIFIVE_SERIAL_RXCTRL_RXCNT_MASK\t\t(0x7 << SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT)\n#define SIFIVE_SERIAL_RXCTRL_RXEN_SHIFT\t\t0\n#define SIFIVE_SERIAL_RXCTRL_RXEN_MASK\t\t(1 << SIFIVE_SERIAL_RXCTRL_RXEN_SHIFT)\n\n \n#define SIFIVE_SERIAL_IE_OFFS\t\t\t0x10\n#define SIFIVE_SERIAL_IE_RXWM_SHIFT\t\t1\n#define SIFIVE_SERIAL_IE_RXWM_MASK\t\t(1 << SIFIVE_SERIAL_IE_RXWM_SHIFT)\n#define SIFIVE_SERIAL_IE_TXWM_SHIFT\t\t0\n#define SIFIVE_SERIAL_IE_TXWM_MASK\t\t(1 << SIFIVE_SERIAL_IE_TXWM_SHIFT)\n\n \n#define SIFIVE_SERIAL_IP_OFFS\t\t\t0x14\n#define SIFIVE_SERIAL_IP_RXWM_SHIFT\t\t1\n#define SIFIVE_SERIAL_IP_RXWM_MASK\t\t(1 << SIFIVE_SERIAL_IP_RXWM_SHIFT)\n#define SIFIVE_SERIAL_IP_TXWM_SHIFT\t\t0\n#define SIFIVE_SERIAL_IP_TXWM_MASK\t\t(1 << SIFIVE_SERIAL_IP_TXWM_SHIFT)\n\n \n#define SIFIVE_SERIAL_DIV_OFFS\t\t\t0x18\n#define SIFIVE_SERIAL_DIV_DIV_SHIFT\t\t0\n#define SIFIVE_SERIAL_DIV_DIV_MASK\t\t(0xffff << SIFIVE_SERIAL_IP_DIV_SHIFT)\n\n \n\n \n#define SIFIVE_SERIAL_MAX_PORTS\t\t\t8\n\n \n#define SIFIVE_DEFAULT_BAUD_RATE\t\t115200\n\n \n#define SIFIVE_SERIAL_NAME\t\t\t\"sifive-serial\"\n\n \n#define SIFIVE_TTY_PREFIX\t\t\t\"ttySIF\"\n\n \n#define SIFIVE_TX_FIFO_DEPTH\t\t\t8\n\n \n#define SIFIVE_RX_FIFO_DEPTH\t\t\t8\n\n#if (SIFIVE_TX_FIFO_DEPTH != SIFIVE_RX_FIFO_DEPTH)\n#error Driver does not support configurations with different TX, RX FIFO sizes\n#endif\n\n \n\n \nstruct sifive_serial_port {\n\tstruct uart_port\tport;\n\tstruct device\t\t*dev;\n\tunsigned char\t\tier;\n\tunsigned long\t\tbaud_rate;\n\tstruct clk\t\t*clk;\n\tstruct notifier_block\tclk_notifier;\n};\n\n \n\n#define port_to_sifive_serial_port(p) (container_of((p), \\\n\t\t\t\t\t\t    struct sifive_serial_port, \\\n\t\t\t\t\t\t    port))\n\n#define notifier_to_sifive_serial_port(nb) (container_of((nb), \\\n\t\t\t\t\t\t\t struct sifive_serial_port, \\\n\t\t\t\t\t\t\t clk_notifier))\n\n \nstatic void sifive_serial_stop_tx(struct uart_port *port);\n\n \n\n \nstatic void __ssp_early_writel(u32 v, u16 offs, struct uart_port *port)\n{\n\twritel_relaxed(v, port->membase + offs);\n}\n\n \nstatic u32 __ssp_early_readl(struct uart_port *port, u16 offs)\n{\n\treturn readl_relaxed(port->membase + offs);\n}\n\n \nstatic void __ssp_writel(u32 v, u16 offs, struct sifive_serial_port *ssp)\n{\n\t__ssp_early_writel(v, offs, &ssp->port);\n}\n\n \nstatic u32 __ssp_readl(struct sifive_serial_port *ssp, u16 offs)\n{\n\treturn __ssp_early_readl(&ssp->port, offs);\n}\n\n \nstatic int sifive_serial_is_txfifo_full(struct sifive_serial_port *ssp)\n{\n\treturn __ssp_readl(ssp, SIFIVE_SERIAL_TXDATA_OFFS) &\n\t\tSIFIVE_SERIAL_TXDATA_FULL_MASK;\n}\n\n \nstatic void __ssp_transmit_char(struct sifive_serial_port *ssp, int ch)\n{\n\t__ssp_writel(ch, SIFIVE_SERIAL_TXDATA_OFFS, ssp);\n}\n\n \nstatic void __ssp_transmit_chars(struct sifive_serial_port *ssp)\n{\n\tu8 ch;\n\n\tuart_port_tx_limited(&ssp->port, ch, SIFIVE_TX_FIFO_DEPTH,\n\t\ttrue,\n\t\t__ssp_transmit_char(ssp, ch),\n\t\t({}));\n}\n\n \nstatic void __ssp_enable_txwm(struct sifive_serial_port *ssp)\n{\n\tif (ssp->ier & SIFIVE_SERIAL_IE_TXWM_MASK)\n\t\treturn;\n\n\tssp->ier |= SIFIVE_SERIAL_IE_TXWM_MASK;\n\t__ssp_writel(ssp->ier, SIFIVE_SERIAL_IE_OFFS, ssp);\n}\n\n \nstatic void __ssp_enable_rxwm(struct sifive_serial_port *ssp)\n{\n\tif (ssp->ier & SIFIVE_SERIAL_IE_RXWM_MASK)\n\t\treturn;\n\n\tssp->ier |= SIFIVE_SERIAL_IE_RXWM_MASK;\n\t__ssp_writel(ssp->ier, SIFIVE_SERIAL_IE_OFFS, ssp);\n}\n\n \nstatic void __ssp_disable_txwm(struct sifive_serial_port *ssp)\n{\n\tif (!(ssp->ier & SIFIVE_SERIAL_IE_TXWM_MASK))\n\t\treturn;\n\n\tssp->ier &= ~SIFIVE_SERIAL_IE_TXWM_MASK;\n\t__ssp_writel(ssp->ier, SIFIVE_SERIAL_IE_OFFS, ssp);\n}\n\n \nstatic void __ssp_disable_rxwm(struct sifive_serial_port *ssp)\n{\n\tif (!(ssp->ier & SIFIVE_SERIAL_IE_RXWM_MASK))\n\t\treturn;\n\n\tssp->ier &= ~SIFIVE_SERIAL_IE_RXWM_MASK;\n\t__ssp_writel(ssp->ier, SIFIVE_SERIAL_IE_OFFS, ssp);\n}\n\n \nstatic char __ssp_receive_char(struct sifive_serial_port *ssp, char *is_empty)\n{\n\tu32 v;\n\tu8 ch;\n\n\tv = __ssp_readl(ssp, SIFIVE_SERIAL_RXDATA_OFFS);\n\n\tif (!is_empty)\n\t\tWARN_ON(1);\n\telse\n\t\t*is_empty = (v & SIFIVE_SERIAL_RXDATA_EMPTY_MASK) >>\n\t\t\tSIFIVE_SERIAL_RXDATA_EMPTY_SHIFT;\n\n\tch = (v & SIFIVE_SERIAL_RXDATA_DATA_MASK) >>\n\t\tSIFIVE_SERIAL_RXDATA_DATA_SHIFT;\n\n\treturn ch;\n}\n\n \nstatic void __ssp_receive_chars(struct sifive_serial_port *ssp)\n{\n\tchar is_empty;\n\tint c;\n\tu8 ch;\n\n\tfor (c = SIFIVE_RX_FIFO_DEPTH; c > 0; --c) {\n\t\tch = __ssp_receive_char(ssp, &is_empty);\n\t\tif (is_empty)\n\t\t\tbreak;\n\n\t\tssp->port.icount.rx++;\n\t\tuart_insert_char(&ssp->port, 0, 0, ch, TTY_NORMAL);\n\t}\n\n\ttty_flip_buffer_push(&ssp->port.state->port);\n}\n\n \nstatic void __ssp_update_div(struct sifive_serial_port *ssp)\n{\n\tu16 div;\n\n\tdiv = DIV_ROUND_UP(ssp->port.uartclk, ssp->baud_rate) - 1;\n\n\t__ssp_writel(div, SIFIVE_SERIAL_DIV_OFFS, ssp);\n}\n\n \nstatic void __ssp_update_baud_rate(struct sifive_serial_port *ssp,\n\t\t\t\t   unsigned int rate)\n{\n\tif (ssp->baud_rate == rate)\n\t\treturn;\n\n\tssp->baud_rate = rate;\n\t__ssp_update_div(ssp);\n}\n\n \nstatic void __ssp_set_stop_bits(struct sifive_serial_port *ssp, char nstop)\n{\n\tu32 v;\n\n\tif (nstop < 1 || nstop > 2) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tv = __ssp_readl(ssp, SIFIVE_SERIAL_TXCTRL_OFFS);\n\tv &= ~SIFIVE_SERIAL_TXCTRL_NSTOP_MASK;\n\tv |= (nstop - 1) << SIFIVE_SERIAL_TXCTRL_NSTOP_SHIFT;\n\t__ssp_writel(v, SIFIVE_SERIAL_TXCTRL_OFFS, ssp);\n}\n\n \nstatic void __maybe_unused __ssp_wait_for_xmitr(struct sifive_serial_port *ssp)\n{\n\twhile (sifive_serial_is_txfifo_full(ssp))\n\t\tudelay(1);  \n}\n\n \n\nstatic void sifive_serial_stop_tx(struct uart_port *port)\n{\n\tstruct sifive_serial_port *ssp = port_to_sifive_serial_port(port);\n\n\t__ssp_disable_txwm(ssp);\n}\n\nstatic void sifive_serial_stop_rx(struct uart_port *port)\n{\n\tstruct sifive_serial_port *ssp = port_to_sifive_serial_port(port);\n\n\t__ssp_disable_rxwm(ssp);\n}\n\nstatic void sifive_serial_start_tx(struct uart_port *port)\n{\n\tstruct sifive_serial_port *ssp = port_to_sifive_serial_port(port);\n\n\t__ssp_enable_txwm(ssp);\n}\n\nstatic irqreturn_t sifive_serial_irq(int irq, void *dev_id)\n{\n\tstruct sifive_serial_port *ssp = dev_id;\n\tu32 ip;\n\n\tspin_lock(&ssp->port.lock);\n\n\tip = __ssp_readl(ssp, SIFIVE_SERIAL_IP_OFFS);\n\tif (!ip) {\n\t\tspin_unlock(&ssp->port.lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (ip & SIFIVE_SERIAL_IP_RXWM_MASK)\n\t\t__ssp_receive_chars(ssp);\n\tif (ip & SIFIVE_SERIAL_IP_TXWM_MASK)\n\t\t__ssp_transmit_chars(ssp);\n\n\tspin_unlock(&ssp->port.lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int sifive_serial_tx_empty(struct uart_port *port)\n{\n\treturn TIOCSER_TEMT;\n}\n\nstatic unsigned int sifive_serial_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CAR | TIOCM_CTS | TIOCM_DSR;\n}\n\nstatic void sifive_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\t \n}\n\nstatic void sifive_serial_break_ctl(struct uart_port *port, int break_state)\n{\n\t \n}\n\nstatic int sifive_serial_startup(struct uart_port *port)\n{\n\tstruct sifive_serial_port *ssp = port_to_sifive_serial_port(port);\n\n\t__ssp_enable_rxwm(ssp);\n\n\treturn 0;\n}\n\nstatic void sifive_serial_shutdown(struct uart_port *port)\n{\n\tstruct sifive_serial_port *ssp = port_to_sifive_serial_port(port);\n\n\t__ssp_disable_rxwm(ssp);\n\t__ssp_disable_txwm(ssp);\n}\n\n \nstatic int sifive_serial_clk_notifier(struct notifier_block *nb,\n\t\t\t\t      unsigned long event, void *data)\n{\n\tstruct clk_notifier_data *cnd = data;\n\tstruct sifive_serial_port *ssp = notifier_to_sifive_serial_port(nb);\n\n\tif (event == PRE_RATE_CHANGE) {\n\t\t \n\t\t__ssp_wait_for_xmitr(ssp);\n\t\t \n\t\tudelay(DIV_ROUND_UP(12 * 1000 * 1000, ssp->baud_rate));\n\t}\n\n\tif (event == POST_RATE_CHANGE && ssp->port.uartclk != cnd->new_rate) {\n\t\tssp->port.uartclk = cnd->new_rate;\n\t\t__ssp_update_div(ssp);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic void sifive_serial_set_termios(struct uart_port *port,\n\t\t\t\t      struct ktermios *termios,\n\t\t\t\t      const struct ktermios *old)\n{\n\tstruct sifive_serial_port *ssp = port_to_sifive_serial_port(port);\n\tunsigned long flags;\n\tu32 v, old_v;\n\tint rate;\n\tchar nstop;\n\n\tif ((termios->c_cflag & CSIZE) != CS8) {\n\t\tdev_err_once(ssp->port.dev, \"only 8-bit words supported\\n\");\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= CS8;\n\t}\n\tif (termios->c_iflag & (INPCK | PARMRK))\n\t\tdev_err_once(ssp->port.dev, \"parity checking not supported\\n\");\n\tif (termios->c_iflag & BRKINT)\n\t\tdev_err_once(ssp->port.dev, \"BREAK detection not supported\\n\");\n\ttermios->c_iflag &= ~(INPCK|PARMRK|BRKINT);\n\n\t \n\tnstop = (termios->c_cflag & CSTOPB) ? 2 : 1;\n\t__ssp_set_stop_bits(ssp, nstop);\n\n\t \n\trate = uart_get_baud_rate(port, termios, old, 0,\n\t\t\t\t  ssp->port.uartclk / 16);\n\t__ssp_update_baud_rate(ssp, rate);\n\n\tspin_lock_irqsave(&ssp->port.lock, flags);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, rate);\n\n\tssp->port.read_status_mask = 0;\n\n\t \n\tv = __ssp_readl(ssp, SIFIVE_SERIAL_RXCTRL_OFFS);\n\told_v = v;\n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tv &= SIFIVE_SERIAL_RXCTRL_RXEN_MASK;\n\telse\n\t\tv |= SIFIVE_SERIAL_RXCTRL_RXEN_MASK;\n\tif (v != old_v)\n\t\t__ssp_writel(v, SIFIVE_SERIAL_RXCTRL_OFFS, ssp);\n\n\tspin_unlock_irqrestore(&ssp->port.lock, flags);\n}\n\nstatic void sifive_serial_release_port(struct uart_port *port)\n{\n}\n\nstatic int sifive_serial_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void sifive_serial_config_port(struct uart_port *port, int flags)\n{\n\tstruct sifive_serial_port *ssp = port_to_sifive_serial_port(port);\n\n\tssp->port.type = PORT_SIFIVE_V0;\n}\n\nstatic int sifive_serial_verify_port(struct uart_port *port,\n\t\t\t\t     struct serial_struct *ser)\n{\n\treturn -EINVAL;\n}\n\nstatic const char *sifive_serial_type(struct uart_port *port)\n{\n\treturn port->type == PORT_SIFIVE_V0 ? \"SiFive UART v0\" : NULL;\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int sifive_serial_poll_get_char(struct uart_port *port)\n{\n\tstruct sifive_serial_port *ssp = port_to_sifive_serial_port(port);\n\tchar is_empty, ch;\n\n\tch = __ssp_receive_char(ssp, &is_empty);\n\tif (is_empty)\n\t\treturn NO_POLL_CHAR;\n\n\treturn ch;\n}\n\nstatic void sifive_serial_poll_put_char(struct uart_port *port,\n\t\t\t\t\tunsigned char c)\n{\n\tstruct sifive_serial_port *ssp = port_to_sifive_serial_port(port);\n\n\t__ssp_wait_for_xmitr(ssp);\n\t__ssp_transmit_char(ssp, c);\n}\n#endif  \n\n \n\n#ifdef CONFIG_SERIAL_EARLYCON\nstatic void early_sifive_serial_putc(struct uart_port *port, unsigned char c)\n{\n\twhile (__ssp_early_readl(port, SIFIVE_SERIAL_TXDATA_OFFS) &\n\t       SIFIVE_SERIAL_TXDATA_FULL_MASK)\n\t\tcpu_relax();\n\n\t__ssp_early_writel(c, SIFIVE_SERIAL_TXDATA_OFFS, port);\n}\n\nstatic void early_sifive_serial_write(struct console *con, const char *s,\n\t\t\t\t      unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\tstruct uart_port *port = &dev->port;\n\n\tuart_console_write(port, s, n, early_sifive_serial_putc);\n}\n\nstatic int __init early_sifive_serial_setup(struct earlycon_device *dev,\n\t\t\t\t\t    const char *options)\n{\n\tstruct uart_port *port = &dev->port;\n\n\tif (!port->membase)\n\t\treturn -ENODEV;\n\n\tdev->con->write = early_sifive_serial_write;\n\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(sifive, \"sifive,uart0\", early_sifive_serial_setup);\nOF_EARLYCON_DECLARE(sifive, \"sifive,fu540-c000-uart0\",\n\t\t    early_sifive_serial_setup);\n#endif  \n\n \n\n#ifdef CONFIG_SERIAL_SIFIVE_CONSOLE\n\nstatic struct sifive_serial_port *sifive_serial_console_ports[SIFIVE_SERIAL_MAX_PORTS];\n\nstatic void sifive_serial_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct sifive_serial_port *ssp = port_to_sifive_serial_port(port);\n\n\t__ssp_wait_for_xmitr(ssp);\n\t__ssp_transmit_char(ssp, ch);\n}\n\nstatic void sifive_serial_console_write(struct console *co, const char *s,\n\t\t\t\t\tunsigned int count)\n{\n\tstruct sifive_serial_port *ssp = sifive_serial_console_ports[co->index];\n\tunsigned long flags;\n\tunsigned int ier;\n\tint locked = 1;\n\n\tif (!ssp)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tif (ssp->port.sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock(&ssp->port.lock);\n\telse\n\t\tspin_lock(&ssp->port.lock);\n\n\tier = __ssp_readl(ssp, SIFIVE_SERIAL_IE_OFFS);\n\t__ssp_writel(0, SIFIVE_SERIAL_IE_OFFS, ssp);\n\n\tuart_console_write(&ssp->port, s, count, sifive_serial_console_putchar);\n\n\t__ssp_writel(ier, SIFIVE_SERIAL_IE_OFFS, ssp);\n\n\tif (locked)\n\t\tspin_unlock(&ssp->port.lock);\n\tlocal_irq_restore(flags);\n}\n\nstatic int sifive_serial_console_setup(struct console *co, char *options)\n{\n\tstruct sifive_serial_port *ssp;\n\tint baud = SIFIVE_DEFAULT_BAUD_RATE;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index < 0 || co->index >= SIFIVE_SERIAL_MAX_PORTS)\n\t\treturn -ENODEV;\n\n\tssp = sifive_serial_console_ports[co->index];\n\tif (!ssp)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&ssp->port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver sifive_serial_uart_driver;\n\nstatic struct console sifive_serial_console = {\n\t.name\t\t= SIFIVE_TTY_PREFIX,\n\t.write\t\t= sifive_serial_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= sifive_serial_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &sifive_serial_uart_driver,\n};\n\nstatic int __init sifive_console_init(void)\n{\n\tregister_console(&sifive_serial_console);\n\treturn 0;\n}\n\nconsole_initcall(sifive_console_init);\n\nstatic void __ssp_add_console_port(struct sifive_serial_port *ssp)\n{\n\tsifive_serial_console_ports[ssp->port.line] = ssp;\n}\n\nstatic void __ssp_remove_console_port(struct sifive_serial_port *ssp)\n{\n\tsifive_serial_console_ports[ssp->port.line] = NULL;\n}\n\n#define SIFIVE_SERIAL_CONSOLE\t(&sifive_serial_console)\n\n#else\n\n#define SIFIVE_SERIAL_CONSOLE\tNULL\n\nstatic void __ssp_add_console_port(struct sifive_serial_port *ssp)\n{}\nstatic void __ssp_remove_console_port(struct sifive_serial_port *ssp)\n{}\n\n#endif\n\nstatic const struct uart_ops sifive_serial_uops = {\n\t.tx_empty\t= sifive_serial_tx_empty,\n\t.set_mctrl\t= sifive_serial_set_mctrl,\n\t.get_mctrl\t= sifive_serial_get_mctrl,\n\t.stop_tx\t= sifive_serial_stop_tx,\n\t.start_tx\t= sifive_serial_start_tx,\n\t.stop_rx\t= sifive_serial_stop_rx,\n\t.break_ctl\t= sifive_serial_break_ctl,\n\t.startup\t= sifive_serial_startup,\n\t.shutdown\t= sifive_serial_shutdown,\n\t.set_termios\t= sifive_serial_set_termios,\n\t.type\t\t= sifive_serial_type,\n\t.release_port\t= sifive_serial_release_port,\n\t.request_port\t= sifive_serial_request_port,\n\t.config_port\t= sifive_serial_config_port,\n\t.verify_port\t= sifive_serial_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= sifive_serial_poll_get_char,\n\t.poll_put_char\t= sifive_serial_poll_put_char,\n#endif\n};\n\nstatic struct uart_driver sifive_serial_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= SIFIVE_SERIAL_NAME,\n\t.dev_name\t= SIFIVE_TTY_PREFIX,\n\t.nr\t\t= SIFIVE_SERIAL_MAX_PORTS,\n\t.cons\t\t= SIFIVE_SERIAL_CONSOLE,\n};\n\nstatic int sifive_serial_probe(struct platform_device *pdev)\n{\n\tstruct sifive_serial_port *ssp;\n\tstruct resource *mem;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tint irq, id, r;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EPROBE_DEFER;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tclk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"unable to find controller clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tid = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\tif (id < 0) {\n\t\tdev_err(&pdev->dev, \"missing aliases entry\\n\");\n\t\treturn id;\n\t}\n\n#ifdef CONFIG_SERIAL_SIFIVE_CONSOLE\n\tif (id > SIFIVE_SERIAL_MAX_PORTS) {\n\t\tdev_err(&pdev->dev, \"too many UARTs (%d)\\n\", id);\n\t\treturn -EINVAL;\n\t}\n#endif\n\n\tssp = devm_kzalloc(&pdev->dev, sizeof(*ssp), GFP_KERNEL);\n\tif (!ssp)\n\t\treturn -ENOMEM;\n\n\tssp->port.dev = &pdev->dev;\n\tssp->port.type = PORT_SIFIVE_V0;\n\tssp->port.iotype = UPIO_MEM;\n\tssp->port.irq = irq;\n\tssp->port.fifosize = SIFIVE_TX_FIFO_DEPTH;\n\tssp->port.ops = &sifive_serial_uops;\n\tssp->port.line = id;\n\tssp->port.mapbase = mem->start;\n\tssp->port.membase = base;\n\tssp->dev = &pdev->dev;\n\tssp->clk = clk;\n\tssp->clk_notifier.notifier_call = sifive_serial_clk_notifier;\n\n\tr = clk_notifier_register(ssp->clk, &ssp->clk_notifier);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"could not register clock notifier: %d\\n\",\n\t\t\tr);\n\t\tgoto probe_out1;\n\t}\n\n\t \n\tssp->port.uartclk = clk_get_rate(ssp->clk);\n\tssp->baud_rate = SIFIVE_DEFAULT_BAUD_RATE;\n\t__ssp_update_div(ssp);\n\n\tplatform_set_drvdata(pdev, ssp);\n\n\t \n\t__ssp_writel((1 << SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT) |\n\t\t     SIFIVE_SERIAL_TXCTRL_TXEN_MASK,\n\t\t     SIFIVE_SERIAL_TXCTRL_OFFS, ssp);\n\n\t \n\t__ssp_writel((0 << SIFIVE_SERIAL_RXCTRL_RXCNT_SHIFT) |\n\t\t     SIFIVE_SERIAL_RXCTRL_RXEN_MASK,\n\t\t     SIFIVE_SERIAL_RXCTRL_OFFS, ssp);\n\n\tr = request_irq(ssp->port.irq, sifive_serial_irq, ssp->port.irqflags,\n\t\t\tdev_name(&pdev->dev), ssp);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"could not attach interrupt: %d\\n\", r);\n\t\tgoto probe_out2;\n\t}\n\n\t__ssp_add_console_port(ssp);\n\n\tr = uart_add_one_port(&sifive_serial_uart_driver, &ssp->port);\n\tif (r != 0) {\n\t\tdev_err(&pdev->dev, \"could not add uart: %d\\n\", r);\n\t\tgoto probe_out3;\n\t}\n\n\treturn 0;\n\nprobe_out3:\n\t__ssp_remove_console_port(ssp);\n\tfree_irq(ssp->port.irq, ssp);\nprobe_out2:\n\tclk_notifier_unregister(ssp->clk, &ssp->clk_notifier);\nprobe_out1:\n\treturn r;\n}\n\nstatic int sifive_serial_remove(struct platform_device *dev)\n{\n\tstruct sifive_serial_port *ssp = platform_get_drvdata(dev);\n\n\t__ssp_remove_console_port(ssp);\n\tuart_remove_one_port(&sifive_serial_uart_driver, &ssp->port);\n\tfree_irq(ssp->port.irq, ssp);\n\tclk_notifier_unregister(ssp->clk, &ssp->clk_notifier);\n\n\treturn 0;\n}\n\nstatic int sifive_serial_suspend(struct device *dev)\n{\n\tstruct sifive_serial_port *ssp = dev_get_drvdata(dev);\n\n\treturn uart_suspend_port(&sifive_serial_uart_driver, &ssp->port);\n}\n\nstatic int sifive_serial_resume(struct device *dev)\n{\n\tstruct sifive_serial_port *ssp = dev_get_drvdata(dev);\n\n\treturn uart_resume_port(&sifive_serial_uart_driver, &ssp->port);\n}\n\nDEFINE_SIMPLE_DEV_PM_OPS(sifive_uart_pm_ops, sifive_serial_suspend,\n\t\t\t sifive_serial_resume);\n\nstatic const struct of_device_id sifive_serial_of_match[] = {\n\t{ .compatible = \"sifive,fu540-c000-uart0\" },\n\t{ .compatible = \"sifive,uart0\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sifive_serial_of_match);\n\nstatic struct platform_driver sifive_serial_platform_driver = {\n\t.probe\t\t= sifive_serial_probe,\n\t.remove\t\t= sifive_serial_remove,\n\t.driver\t\t= {\n\t\t.name\t= SIFIVE_SERIAL_NAME,\n\t\t.pm = pm_sleep_ptr(&sifive_uart_pm_ops),\n\t\t.of_match_table = sifive_serial_of_match,\n\t},\n};\n\nstatic int __init sifive_serial_init(void)\n{\n\tint r;\n\n\tr = uart_register_driver(&sifive_serial_uart_driver);\n\tif (r)\n\t\tgoto init_out1;\n\n\tr = platform_driver_register(&sifive_serial_platform_driver);\n\tif (r)\n\t\tgoto init_out2;\n\n\treturn 0;\n\ninit_out2:\n\tuart_unregister_driver(&sifive_serial_uart_driver);\ninit_out1:\n\treturn r;\n}\n\nstatic void __exit sifive_serial_exit(void)\n{\n\tplatform_driver_unregister(&sifive_serial_platform_driver);\n\tuart_unregister_driver(&sifive_serial_uart_driver);\n}\n\nmodule_init(sifive_serial_init);\nmodule_exit(sifive_serial_exit);\n\nMODULE_DESCRIPTION(\"SiFive UART serial driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Paul Walmsley <paul@pwsan.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}