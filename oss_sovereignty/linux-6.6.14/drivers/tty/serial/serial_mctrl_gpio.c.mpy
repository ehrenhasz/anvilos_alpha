{
  "module_name": "serial_mctrl_gpio.c",
  "hash_id": "7d0d3ac5d5aee6cf1a9a8feeeceb3d976c2ff36df0e074247edd3ab6e8ebe3f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/serial_mctrl_gpio.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/irq.h>\n#include <linux/gpio/consumer.h>\n#include <linux/termios.h>\n#include <linux/serial_core.h>\n#include <linux/module.h>\n#include <linux/property.h>\n\n#include \"serial_mctrl_gpio.h\"\n\nstruct mctrl_gpios {\n\tstruct uart_port *port;\n\tstruct gpio_desc *gpio[UART_GPIO_MAX];\n\tint irq[UART_GPIO_MAX];\n\tunsigned int mctrl_prev;\n\tbool mctrl_on;\n};\n\nstatic const struct {\n\tconst char *name;\n\tunsigned int mctrl;\n\tenum gpiod_flags flags;\n} mctrl_gpios_desc[UART_GPIO_MAX] = {\n\t{ \"cts\", TIOCM_CTS, GPIOD_IN, },\n\t{ \"dsr\", TIOCM_DSR, GPIOD_IN, },\n\t{ \"dcd\", TIOCM_CD,  GPIOD_IN, },\n\t{ \"rng\", TIOCM_RNG, GPIOD_IN, },\n\t{ \"rts\", TIOCM_RTS, GPIOD_OUT_LOW, },\n\t{ \"dtr\", TIOCM_DTR, GPIOD_OUT_LOW, },\n};\n\nstatic bool mctrl_gpio_flags_is_dir_out(unsigned int idx)\n{\n\treturn mctrl_gpios_desc[idx].flags & GPIOD_FLAGS_BIT_DIR_OUT;\n}\n\n \nvoid mctrl_gpio_set(struct mctrl_gpios *gpios, unsigned int mctrl)\n{\n\tenum mctrl_gpio_idx i;\n\tstruct gpio_desc *desc_array[UART_GPIO_MAX];\n\tDECLARE_BITMAP(values, UART_GPIO_MAX);\n\tunsigned int count = 0;\n\n\tif (gpios == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < UART_GPIO_MAX; i++)\n\t\tif (gpios->gpio[i] && mctrl_gpio_flags_is_dir_out(i)) {\n\t\t\tdesc_array[count] = gpios->gpio[i];\n\t\t\t__assign_bit(count, values,\n\t\t\t\t     mctrl & mctrl_gpios_desc[i].mctrl);\n\t\t\tcount++;\n\t\t}\n\tgpiod_set_array_value(count, desc_array, NULL, values);\n}\nEXPORT_SYMBOL_GPL(mctrl_gpio_set);\n\n \nstruct gpio_desc *mctrl_gpio_to_gpiod(struct mctrl_gpios *gpios,\n\t\t\t\t      enum mctrl_gpio_idx gidx)\n{\n\tif (gpios == NULL)\n\t\treturn NULL;\n\n\treturn gpios->gpio[gidx];\n}\nEXPORT_SYMBOL_GPL(mctrl_gpio_to_gpiod);\n\n \nunsigned int mctrl_gpio_get(struct mctrl_gpios *gpios, unsigned int *mctrl)\n{\n\tenum mctrl_gpio_idx i;\n\n\tif (gpios == NULL)\n\t\treturn *mctrl;\n\n\tfor (i = 0; i < UART_GPIO_MAX; i++) {\n\t\tif (gpios->gpio[i] && !mctrl_gpio_flags_is_dir_out(i)) {\n\t\t\tif (gpiod_get_value(gpios->gpio[i]))\n\t\t\t\t*mctrl |= mctrl_gpios_desc[i].mctrl;\n\t\t\telse\n\t\t\t\t*mctrl &= ~mctrl_gpios_desc[i].mctrl;\n\t\t}\n\t}\n\n\treturn *mctrl;\n}\nEXPORT_SYMBOL_GPL(mctrl_gpio_get);\n\nunsigned int\nmctrl_gpio_get_outputs(struct mctrl_gpios *gpios, unsigned int *mctrl)\n{\n\tenum mctrl_gpio_idx i;\n\n\tif (gpios == NULL)\n\t\treturn *mctrl;\n\n\tfor (i = 0; i < UART_GPIO_MAX; i++) {\n\t\tif (gpios->gpio[i] && mctrl_gpio_flags_is_dir_out(i)) {\n\t\t\tif (gpiod_get_value(gpios->gpio[i]))\n\t\t\t\t*mctrl |= mctrl_gpios_desc[i].mctrl;\n\t\t\telse\n\t\t\t\t*mctrl &= ~mctrl_gpios_desc[i].mctrl;\n\t\t}\n\t}\n\n\treturn *mctrl;\n}\nEXPORT_SYMBOL_GPL(mctrl_gpio_get_outputs);\n\nstruct mctrl_gpios *mctrl_gpio_init_noauto(struct device *dev, unsigned int idx)\n{\n\tstruct mctrl_gpios *gpios;\n\tenum mctrl_gpio_idx i;\n\n\tgpios = devm_kzalloc(dev, sizeof(*gpios), GFP_KERNEL);\n\tif (!gpios)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < UART_GPIO_MAX; i++) {\n\t\tchar *gpio_str;\n\t\tbool present;\n\n\t\t \n\t\tgpio_str = kasprintf(GFP_KERNEL, \"%s-gpios\",\n\t\t\t\t     mctrl_gpios_desc[i].name);\n\t\tif (!gpio_str)\n\t\t\tcontinue;\n\n\t\tpresent = device_property_present(dev, gpio_str);\n\t\tkfree(gpio_str);\n\t\tif (!present)\n\t\t\tcontinue;\n\n\t\tgpios->gpio[i] =\n\t\t\tdevm_gpiod_get_index_optional(dev,\n\t\t\t\t\t\t      mctrl_gpios_desc[i].name,\n\t\t\t\t\t\t      idx,\n\t\t\t\t\t\t      mctrl_gpios_desc[i].flags);\n\n\t\tif (IS_ERR(gpios->gpio[i]))\n\t\t\treturn ERR_CAST(gpios->gpio[i]);\n\t}\n\n\treturn gpios;\n}\nEXPORT_SYMBOL_GPL(mctrl_gpio_init_noauto);\n\n#define MCTRL_ANY_DELTA (TIOCM_RI | TIOCM_DSR | TIOCM_CD | TIOCM_CTS)\nstatic irqreturn_t mctrl_gpio_irq_handle(int irq, void *context)\n{\n\tstruct mctrl_gpios *gpios = context;\n\tstruct uart_port *port = gpios->port;\n\tu32 mctrl = gpios->mctrl_prev;\n\tu32 mctrl_diff;\n\tunsigned long flags;\n\n\tmctrl_gpio_get(gpios, &mctrl);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tmctrl_diff = mctrl ^ gpios->mctrl_prev;\n\tgpios->mctrl_prev = mctrl;\n\n\tif (mctrl_diff & MCTRL_ANY_DELTA && port->state != NULL) {\n\t\tif ((mctrl_diff & mctrl) & TIOCM_RI)\n\t\t\tport->icount.rng++;\n\n\t\tif ((mctrl_diff & mctrl) & TIOCM_DSR)\n\t\t\tport->icount.dsr++;\n\n\t\tif (mctrl_diff & TIOCM_CD)\n\t\t\tuart_handle_dcd_change(port, mctrl & TIOCM_CD);\n\n\t\tif (mctrl_diff & TIOCM_CTS)\n\t\t\tuart_handle_cts_change(port, mctrl & TIOCM_CTS);\n\n\t\twake_up_interruptible(&port->state->port.delta_msr_wait);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstruct mctrl_gpios *mctrl_gpio_init(struct uart_port *port, unsigned int idx)\n{\n\tstruct mctrl_gpios *gpios;\n\tenum mctrl_gpio_idx i;\n\n\tgpios = mctrl_gpio_init_noauto(port->dev, idx);\n\tif (IS_ERR(gpios))\n\t\treturn gpios;\n\n\tgpios->port = port;\n\n\tfor (i = 0; i < UART_GPIO_MAX; ++i) {\n\t\tint ret;\n\n\t\tif (!gpios->gpio[i] || mctrl_gpio_flags_is_dir_out(i))\n\t\t\tcontinue;\n\n\t\tret = gpiod_to_irq(gpios->gpio[i]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(port->dev,\n\t\t\t\t\"failed to find corresponding irq for %s (idx=%d, err=%d)\\n\",\n\t\t\t\tmctrl_gpios_desc[i].name, idx, ret);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t\tgpios->irq[i] = ret;\n\n\t\t \n\t\tirq_set_status_flags(gpios->irq[i], IRQ_NOAUTOEN);\n\n\t\tret = devm_request_irq(port->dev, gpios->irq[i],\n\t\t\t\t       mctrl_gpio_irq_handle,\n\t\t\t\t       IRQ_TYPE_EDGE_BOTH, dev_name(port->dev),\n\t\t\t\t       gpios);\n\t\tif (ret) {\n\t\t\t \n\t\t\tdev_err(port->dev,\n\t\t\t\t\"failed to request irq for %s (idx=%d, err=%d)\\n\",\n\t\t\t\tmctrl_gpios_desc[i].name, idx, ret);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn gpios;\n}\nEXPORT_SYMBOL_GPL(mctrl_gpio_init);\n\n \nvoid mctrl_gpio_free(struct device *dev, struct mctrl_gpios *gpios)\n{\n\tenum mctrl_gpio_idx i;\n\n\tif (gpios == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < UART_GPIO_MAX; i++) {\n\t\tif (gpios->irq[i])\n\t\t\tdevm_free_irq(gpios->port->dev, gpios->irq[i], gpios);\n\n\t\tif (gpios->gpio[i])\n\t\t\tdevm_gpiod_put(dev, gpios->gpio[i]);\n\t}\n\tdevm_kfree(dev, gpios);\n}\nEXPORT_SYMBOL_GPL(mctrl_gpio_free);\n\n \nvoid mctrl_gpio_enable_ms(struct mctrl_gpios *gpios)\n{\n\tenum mctrl_gpio_idx i;\n\n\tif (gpios == NULL)\n\t\treturn;\n\n\t \n\tif (gpios->mctrl_on)\n\t\treturn;\n\n\tgpios->mctrl_on = true;\n\n\t \n\tmctrl_gpio_get(gpios, &gpios->mctrl_prev);\n\n\tfor (i = 0; i < UART_GPIO_MAX; ++i) {\n\t\tif (!gpios->irq[i])\n\t\t\tcontinue;\n\n\t\tenable_irq(gpios->irq[i]);\n\t}\n}\nEXPORT_SYMBOL_GPL(mctrl_gpio_enable_ms);\n\n \nvoid mctrl_gpio_disable_ms(struct mctrl_gpios *gpios)\n{\n\tenum mctrl_gpio_idx i;\n\n\tif (gpios == NULL)\n\t\treturn;\n\n\tif (!gpios->mctrl_on)\n\t\treturn;\n\n\tgpios->mctrl_on = false;\n\n\tfor (i = 0; i < UART_GPIO_MAX; ++i) {\n\t\tif (!gpios->irq[i])\n\t\t\tcontinue;\n\n\t\tdisable_irq(gpios->irq[i]);\n\t}\n}\nEXPORT_SYMBOL_GPL(mctrl_gpio_disable_ms);\n\nvoid mctrl_gpio_enable_irq_wake(struct mctrl_gpios *gpios)\n{\n\tenum mctrl_gpio_idx i;\n\n\tif (!gpios)\n\t\treturn;\n\n\tif (!gpios->mctrl_on)\n\t\treturn;\n\n\tfor (i = 0; i < UART_GPIO_MAX; ++i) {\n\t\tif (!gpios->irq[i])\n\t\t\tcontinue;\n\n\t\tenable_irq_wake(gpios->irq[i]);\n\t}\n}\nEXPORT_SYMBOL_GPL(mctrl_gpio_enable_irq_wake);\n\nvoid mctrl_gpio_disable_irq_wake(struct mctrl_gpios *gpios)\n{\n\tenum mctrl_gpio_idx i;\n\n\tif (!gpios)\n\t\treturn;\n\n\tif (!gpios->mctrl_on)\n\t\treturn;\n\n\tfor (i = 0; i < UART_GPIO_MAX; ++i) {\n\t\tif (!gpios->irq[i])\n\t\t\tcontinue;\n\n\t\tdisable_irq_wake(gpios->irq[i]);\n\t}\n}\nEXPORT_SYMBOL_GPL(mctrl_gpio_disable_irq_wake);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}