{
  "module_name": "jsm_driver.c",
  "hash_id": "b9afe9dabe123dc69bb503dbcc79900cc310a94e014e5dfcf1319b9b80361a99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/jsm/jsm_driver.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include \"jsm.h\"\n\nMODULE_AUTHOR(\"Digi International, https://www.digi.com\");\nMODULE_DESCRIPTION(\"Driver for the Digi International Neo and Classic PCI based product line\");\nMODULE_LICENSE(\"GPL\");\n\n#define JSM_DRIVER_NAME \"jsm\"\n#define NR_PORTS\t32\n#define JSM_MINOR_START\t0\n\nstruct uart_driver jsm_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= JSM_DRIVER_NAME,\n\t.dev_name\t= \"ttyn\",\n\t.major\t\t= 0,\n\t.minor\t\t= JSM_MINOR_START,\n\t.nr\t\t= NR_PORTS,\n};\n\nstatic pci_ers_result_t jsm_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\tpci_channel_state_t state);\nstatic pci_ers_result_t jsm_io_slot_reset(struct pci_dev *pdev);\nstatic void jsm_io_resume(struct pci_dev *pdev);\n\nstatic const struct pci_error_handlers jsm_err_handler = {\n\t.error_detected = jsm_io_error_detected,\n\t.slot_reset = jsm_io_slot_reset,\n\t.resume = jsm_io_resume,\n};\n\nint jsm_debug;\nmodule_param(jsm_debug, int, 0);\nMODULE_PARM_DESC(jsm_debug, \"Driver debugging level\");\n\nstatic int jsm_probe_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint rc = 0;\n\tstruct jsm_board *brd;\n\tstatic int adapter_count;\n\n\trc = pci_enable_device(pdev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Device enable FAILED\\n\");\n\t\tgoto out;\n\t}\n\n\trc = pci_request_regions(pdev, JSM_DRIVER_NAME);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"pci_request_region FAILED\\n\");\n\t\tgoto out_disable_device;\n\t}\n\n\tbrd = kzalloc(sizeof(*brd), GFP_KERNEL);\n\tif (!brd) {\n\t\trc = -ENOMEM;\n\t\tgoto out_release_regions;\n\t}\n\n\t \n\tbrd->boardnum = adapter_count++;\n\tbrd->pci_dev = pdev;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_NEO_2DB9:\n\tcase PCI_DEVICE_ID_NEO_2DB9PRI:\n\tcase PCI_DEVICE_ID_NEO_2RJ45:\n\tcase PCI_DEVICE_ID_NEO_2RJ45PRI:\n\tcase PCI_DEVICE_ID_NEO_2_422_485:\n\t\tbrd->maxports = 2;\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_CLASSIC_4:\n\tcase PCI_DEVICE_ID_CLASSIC_4_422:\n\tcase PCI_DEVICE_ID_NEO_4:\n\tcase PCIE_DEVICE_ID_NEO_4:\n\tcase PCIE_DEVICE_ID_NEO_4RJ45:\n\tcase PCIE_DEVICE_ID_NEO_4_IBM:\n\t\tbrd->maxports = 4;\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_CLASSIC_8:\n\tcase PCI_DEVICE_ID_CLASSIC_8_422:\n\tcase PCI_DEVICE_ID_DIGI_NEO_8:\n\tcase PCIE_DEVICE_ID_NEO_8:\n\tcase PCIE_DEVICE_ID_NEO_8RJ45:\n\t\tbrd->maxports = 8;\n\t\tbreak;\n\n\tdefault:\n\t\tbrd->maxports = 1;\n\t\tbreak;\n\t}\n\n\tspin_lock_init(&brd->bd_intr_lock);\n\n\t \n\tbrd->rev = pdev->revision;\n\n\tbrd->irq = pdev->irq;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_CLASSIC_4:\n\tcase PCI_DEVICE_ID_CLASSIC_4_422:\n\tcase PCI_DEVICE_ID_CLASSIC_8:\n\tcase PCI_DEVICE_ID_CLASSIC_8_422:\n\n\t\tjsm_dbg(INIT, &brd->pci_dev,\n\t\t\t\"jsm_found_board - Classic adapter\\n\");\n\n\t\t \n\n\t\t \n\t\tbrd->membase = pci_resource_start(pdev, 4);\n\t\tbrd->membase_end = pci_resource_end(pdev, 4);\n\n\t\tif (brd->membase & 0x1)\n\t\t\tbrd->membase &= ~0x3;\n\t\telse\n\t\t\tbrd->membase &= ~0xF;\n\n\t\tbrd->iobase = pci_resource_start(pdev, 1);\n\t\tbrd->iobase_end = pci_resource_end(pdev, 1);\n\t\tbrd->iobase = ((unsigned int)(brd->iobase)) & 0xFFFE;\n\n\t\t \n\t\tbrd->bd_ops = &jsm_cls_ops;\n\n\t\tbrd->bd_uart_offset = 0x8;\n\t\tbrd->bd_dividend = 921600;\n\n\t\tbrd->re_map_membase = ioremap(brd->membase,\n\t\t\t\t\t\tpci_resource_len(pdev, 4));\n\t\tif (!brd->re_map_membase) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Card has no PCI Memory resources, failing board.\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_kfree_brd;\n\t\t}\n\n\t\t \n\t\toutb(0x43, brd->iobase + 0x4c);\n\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_NEO_2DB9:\n\tcase PCI_DEVICE_ID_NEO_2DB9PRI:\n\tcase PCI_DEVICE_ID_NEO_2RJ45:\n\tcase PCI_DEVICE_ID_NEO_2RJ45PRI:\n\tcase PCI_DEVICE_ID_NEO_2_422_485:\n\tcase PCI_DEVICE_ID_NEO_4:\n\tcase PCIE_DEVICE_ID_NEO_4:\n\tcase PCIE_DEVICE_ID_NEO_4RJ45:\n\tcase PCIE_DEVICE_ID_NEO_4_IBM:\n\tcase PCI_DEVICE_ID_DIGI_NEO_8:\n\tcase PCIE_DEVICE_ID_NEO_8:\n\tcase PCIE_DEVICE_ID_NEO_8RJ45:\n\n\t\tjsm_dbg(INIT, &brd->pci_dev, \"jsm_found_board - NEO adapter\\n\");\n\n\t\t \n\t\tbrd->membase\t= pci_resource_start(pdev, 0);\n\t\tbrd->membase_end = pci_resource_end(pdev, 0);\n\n\t\tif (brd->membase & 1)\n\t\t\tbrd->membase &= ~0x3;\n\t\telse\n\t\t\tbrd->membase &= ~0xF;\n\n\t\t \n\t\tbrd->bd_ops = &jsm_neo_ops;\n\n\t\tbrd->bd_uart_offset = 0x200;\n\t\tbrd->bd_dividend = 921600;\n\n\t\tbrd->re_map_membase = ioremap(brd->membase,\n\t\t\t\t\t\tpci_resource_len(pdev, 0));\n\t\tif (!brd->re_map_membase) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Card has no PCI Memory resources, failing board.\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_kfree_brd;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\trc = -ENXIO;\n\t\tgoto out_kfree_brd;\n\t}\n\n\trc = request_irq(brd->irq, brd->bd_ops->intr, IRQF_SHARED, \"JSM\", brd);\n\tif (rc) {\n\t\tdev_warn(&pdev->dev, \"Failed to hook IRQ %d\\n\", brd->irq);\n\t\tgoto out_iounmap;\n\t}\n\n\trc = jsm_tty_init(brd);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"Can't init tty devices (%d)\\n\", rc);\n\t\trc = -ENXIO;\n\t\tgoto out_free_irq;\n\t}\n\n\trc = jsm_uart_port_init(brd);\n\tif (rc < 0) {\n\t\t \n\t\tdev_err(&pdev->dev, \"Can't init uart port (%d)\\n\", rc);\n\t\trc = -ENXIO;\n\t\tgoto out_free_irq;\n\t}\n\n\t \n\tdev_info(&pdev->dev, \"board %d: Digi Classic/Neo (rev %d), irq %d\\n\",\n\t\t\tadapter_count, brd->rev, brd->irq);\n\n\tpci_set_drvdata(pdev, brd);\n\tpci_save_state(pdev);\n\n\treturn 0;\n out_free_irq:\n\tjsm_remove_uart_port(brd);\n\tfree_irq(brd->irq, brd);\n out_iounmap:\n\tiounmap(brd->re_map_membase);\n out_kfree_brd:\n\tkfree(brd);\n out_release_regions:\n\tpci_release_regions(pdev);\n out_disable_device:\n\tpci_disable_device(pdev);\n out:\n\treturn rc;\n}\n\nstatic void jsm_remove_one(struct pci_dev *pdev)\n{\n\tstruct jsm_board *brd = pci_get_drvdata(pdev);\n\tint i = 0;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_CLASSIC_4:\n\tcase PCI_DEVICE_ID_CLASSIC_4_422:\n\tcase PCI_DEVICE_ID_CLASSIC_8:\n\tcase PCI_DEVICE_ID_CLASSIC_8_422:\n\t\t \n\t\toutb(0x0, brd->iobase + 0x4c);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tjsm_remove_uart_port(brd);\n\n\tfree_irq(brd->irq, brd);\n\tiounmap(brd->re_map_membase);\n\n\t \n\tfor (i = 0; i < brd->maxports; i++) {\n\t\tif (brd->channels[i]) {\n\t\t\tkfree(brd->channels[i]->ch_rqueue);\n\t\t\tkfree(brd->channels[i]->ch_equeue);\n\t\t\tkfree(brd->channels[i]);\n\t\t}\n\t}\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tkfree(brd);\n}\n\nstatic const struct pci_device_id jsm_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_NEO_2DB9), 0, 0, 0 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_NEO_2DB9PRI), 0, 0, 1 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_NEO_2RJ45), 0, 0, 2 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_NEO_2RJ45PRI), 0, 0, 3 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCIE_DEVICE_ID_NEO_4_IBM), 0, 0, 4 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_NEO_8), 0, 0, 5 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_NEO_4), 0, 0, 6 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_NEO_1_422), 0, 0, 7 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_NEO_1_422_485), 0, 0, 8 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_NEO_2_422_485), 0, 0, 9 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCIE_DEVICE_ID_NEO_8), 0, 0, 10 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCIE_DEVICE_ID_NEO_4), 0, 0, 11 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCIE_DEVICE_ID_NEO_4RJ45), 0, 0, 12 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCIE_DEVICE_ID_NEO_8RJ45), 0, 0, 13 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_CLASSIC_4), 0, 0, 14 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_CLASSIC_4_422), 0, 0, 15 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_CLASSIC_8), 0, 0, 16 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_CLASSIC_8_422), 0, 0, 17 },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, jsm_pci_tbl);\n\nstatic struct pci_driver jsm_driver = {\n\t.name\t\t= JSM_DRIVER_NAME,\n\t.id_table\t= jsm_pci_tbl,\n\t.probe\t\t= jsm_probe_one,\n\t.remove\t\t= jsm_remove_one,\n\t.err_handler    = &jsm_err_handler,\n};\n\nstatic pci_ers_result_t jsm_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\tpci_channel_state_t state)\n{\n\tstruct jsm_board *brd = pci_get_drvdata(pdev);\n\n\tjsm_remove_uart_port(brd);\n\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t jsm_io_slot_reset(struct pci_dev *pdev)\n{\n\tint rc;\n\n\trc = pci_enable_device(pdev);\n\n\tif (rc)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tpci_set_master(pdev);\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic void jsm_io_resume(struct pci_dev *pdev)\n{\n\tstruct jsm_board *brd = pci_get_drvdata(pdev);\n\n\tpci_restore_state(pdev);\n\tpci_save_state(pdev);\n\n\tjsm_uart_port_init(brd);\n}\n\nstatic int __init jsm_init_module(void)\n{\n\tint rc;\n\n\trc = uart_register_driver(&jsm_uart_driver);\n\tif (!rc) {\n\t\trc = pci_register_driver(&jsm_driver);\n\t\tif (rc)\n\t\t\tuart_unregister_driver(&jsm_uart_driver);\n\t}\n\treturn rc;\n}\n\nstatic void __exit jsm_exit_module(void)\n{\n\tpci_unregister_driver(&jsm_driver);\n\tuart_unregister_driver(&jsm_uart_driver);\n}\n\nmodule_init(jsm_init_module);\nmodule_exit(jsm_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}