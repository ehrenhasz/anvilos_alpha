{
  "module_name": "jsm_tty.c",
  "hash_id": "5410ed47f9eadef2eb9c04c82321ff80e8e82151ed7b12685455fd4a1dc964dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/jsm/jsm_tty.c",
  "human_readable_source": "\n \n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_reg.h>\n#include <linux/delay.h>\t \n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include \"jsm.h\"\n\nstatic DECLARE_BITMAP(linemap, MAXLINES);\n\nstatic void jsm_carrier(struct jsm_channel *ch);\n\nstatic inline int jsm_get_mstat(struct jsm_channel *ch)\n{\n\tunsigned char mstat;\n\tint result;\n\n\tjsm_dbg(IOCTL, &ch->ch_bd->pci_dev, \"start\\n\");\n\n\tmstat = (ch->ch_mostat | ch->ch_mistat);\n\n\tresult = 0;\n\n\tif (mstat & UART_MCR_DTR)\n\t\tresult |= TIOCM_DTR;\n\tif (mstat & UART_MCR_RTS)\n\t\tresult |= TIOCM_RTS;\n\tif (mstat & UART_MSR_CTS)\n\t\tresult |= TIOCM_CTS;\n\tif (mstat & UART_MSR_DSR)\n\t\tresult |= TIOCM_DSR;\n\tif (mstat & UART_MSR_RI)\n\t\tresult |= TIOCM_RI;\n\tif (mstat & UART_MSR_DCD)\n\t\tresult |= TIOCM_CD;\n\n\tjsm_dbg(IOCTL, &ch->ch_bd->pci_dev, \"finish\\n\");\n\treturn result;\n}\n\nstatic unsigned int jsm_tty_tx_empty(struct uart_port *port)\n{\n\treturn TIOCSER_TEMT;\n}\n\n \nstatic unsigned int jsm_tty_get_mctrl(struct uart_port *port)\n{\n\tint result;\n\tstruct jsm_channel *channel =\n\t\tcontainer_of(port, struct jsm_channel, uart_port);\n\n\tjsm_dbg(IOCTL, &channel->ch_bd->pci_dev, \"start\\n\");\n\n\tresult = jsm_get_mstat(channel);\n\n\tif (result < 0)\n\t\treturn -ENXIO;\n\n\tjsm_dbg(IOCTL, &channel->ch_bd->pci_dev, \"finish\\n\");\n\n\treturn result;\n}\n\n \nstatic void jsm_tty_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct jsm_channel *channel =\n\t\tcontainer_of(port, struct jsm_channel, uart_port);\n\n\tjsm_dbg(IOCTL, &channel->ch_bd->pci_dev, \"start\\n\");\n\n\tif (mctrl & TIOCM_RTS)\n\t\tchannel->ch_mostat |= UART_MCR_RTS;\n\telse\n\t\tchannel->ch_mostat &= ~UART_MCR_RTS;\n\n\tif (mctrl & TIOCM_DTR)\n\t\tchannel->ch_mostat |= UART_MCR_DTR;\n\telse\n\t\tchannel->ch_mostat &= ~UART_MCR_DTR;\n\n\tchannel->ch_bd->bd_ops->assert_modem_signals(channel);\n\n\tjsm_dbg(IOCTL, &channel->ch_bd->pci_dev, \"finish\\n\");\n\tudelay(10);\n}\n\n \nstatic void jsm_tty_write(struct uart_port *port)\n{\n\tstruct jsm_channel *channel;\n\n\tchannel = container_of(port, struct jsm_channel, uart_port);\n\tchannel->ch_bd->bd_ops->copy_data_from_queue_to_uart(channel);\n}\n\nstatic void jsm_tty_start_tx(struct uart_port *port)\n{\n\tstruct jsm_channel *channel =\n\t\tcontainer_of(port, struct jsm_channel, uart_port);\n\n\tjsm_dbg(IOCTL, &channel->ch_bd->pci_dev, \"start\\n\");\n\n\tchannel->ch_flags &= ~(CH_STOP);\n\tjsm_tty_write(port);\n\n\tjsm_dbg(IOCTL, &channel->ch_bd->pci_dev, \"finish\\n\");\n}\n\nstatic void jsm_tty_stop_tx(struct uart_port *port)\n{\n\tstruct jsm_channel *channel =\n\t\tcontainer_of(port, struct jsm_channel, uart_port);\n\n\tjsm_dbg(IOCTL, &channel->ch_bd->pci_dev, \"start\\n\");\n\n\tchannel->ch_flags |= (CH_STOP);\n\n\tjsm_dbg(IOCTL, &channel->ch_bd->pci_dev, \"finish\\n\");\n}\n\nstatic void jsm_tty_send_xchar(struct uart_port *port, char ch)\n{\n\tunsigned long lock_flags;\n\tstruct jsm_channel *channel =\n\t\tcontainer_of(port, struct jsm_channel, uart_port);\n\tstruct ktermios *termios;\n\n\tspin_lock_irqsave(&port->lock, lock_flags);\n\ttermios = &port->state->port.tty->termios;\n\tif (ch == termios->c_cc[VSTART])\n\t\tchannel->ch_bd->bd_ops->send_start_character(channel);\n\n\tif (ch == termios->c_cc[VSTOP])\n\t\tchannel->ch_bd->bd_ops->send_stop_character(channel);\n\tspin_unlock_irqrestore(&port->lock, lock_flags);\n}\n\nstatic void jsm_tty_stop_rx(struct uart_port *port)\n{\n\tstruct jsm_channel *channel =\n\t\tcontainer_of(port, struct jsm_channel, uart_port);\n\n\tchannel->ch_bd->bd_ops->disable_receiver(channel);\n}\n\nstatic void jsm_tty_break(struct uart_port *port, int break_state)\n{\n\tunsigned long lock_flags;\n\tstruct jsm_channel *channel =\n\t\tcontainer_of(port, struct jsm_channel, uart_port);\n\n\tspin_lock_irqsave(&port->lock, lock_flags);\n\tif (break_state == -1)\n\t\tchannel->ch_bd->bd_ops->send_break(channel);\n\telse\n\t\tchannel->ch_bd->bd_ops->clear_break(channel);\n\n\tspin_unlock_irqrestore(&port->lock, lock_flags);\n}\n\nstatic int jsm_tty_open(struct uart_port *port)\n{\n\tunsigned long lock_flags;\n\tstruct jsm_board *brd;\n\tstruct jsm_channel *channel =\n\t\tcontainer_of(port, struct jsm_channel, uart_port);\n\tstruct ktermios *termios;\n\n\t \n\tbrd = channel->ch_bd;\n\n\t \n\tchannel->ch_flags |= (CH_OPENING);\n\n\t \n\n\tif (!channel->ch_rqueue) {\n\t\tchannel->ch_rqueue = kzalloc(RQUEUESIZE, GFP_KERNEL);\n\t\tif (!channel->ch_rqueue) {\n\t\t\tjsm_dbg(INIT, &channel->ch_bd->pci_dev,\n\t\t\t\t\"unable to allocate read queue buf\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tif (!channel->ch_equeue) {\n\t\tchannel->ch_equeue = kzalloc(EQUEUESIZE, GFP_KERNEL);\n\t\tif (!channel->ch_equeue) {\n\t\t\tjsm_dbg(INIT, &channel->ch_bd->pci_dev,\n\t\t\t\t\"unable to allocate error queue buf\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tchannel->ch_flags &= ~(CH_OPENING);\n\t \n\tjsm_dbg(OPEN, &channel->ch_bd->pci_dev,\n\t\t\"jsm_open: initializing channel in open...\\n\");\n\n\t \n\tchannel->ch_r_head = channel->ch_r_tail = 0;\n\tchannel->ch_e_head = channel->ch_e_tail = 0;\n\n\tbrd->bd_ops->flush_uart_write(channel);\n\tbrd->bd_ops->flush_uart_read(channel);\n\n\tchannel->ch_flags = 0;\n\tchannel->ch_cached_lsr = 0;\n\tchannel->ch_stops_sent = 0;\n\n\tspin_lock_irqsave(&port->lock, lock_flags);\n\ttermios = &port->state->port.tty->termios;\n\tchannel->ch_c_cflag\t= termios->c_cflag;\n\tchannel->ch_c_iflag\t= termios->c_iflag;\n\tchannel->ch_c_oflag\t= termios->c_oflag;\n\tchannel->ch_c_lflag\t= termios->c_lflag;\n\tchannel->ch_startc\t= termios->c_cc[VSTART];\n\tchannel->ch_stopc\t= termios->c_cc[VSTOP];\n\n\t \n\tbrd->bd_ops->uart_init(channel);\n\n\t \n\tbrd->bd_ops->param(channel);\n\n\tjsm_carrier(channel);\n\n\tchannel->ch_open_count++;\n\tspin_unlock_irqrestore(&port->lock, lock_flags);\n\n\tjsm_dbg(OPEN, &channel->ch_bd->pci_dev, \"finish\\n\");\n\treturn 0;\n}\n\nstatic void jsm_tty_close(struct uart_port *port)\n{\n\tstruct jsm_board *bd;\n\tstruct jsm_channel *channel =\n\t\tcontainer_of(port, struct jsm_channel, uart_port);\n\n\tjsm_dbg(CLOSE, &channel->ch_bd->pci_dev, \"start\\n\");\n\n\tbd = channel->ch_bd;\n\n\tchannel->ch_flags &= ~(CH_STOPI);\n\n\tchannel->ch_open_count--;\n\n\t \n\tif (channel->ch_c_cflag & HUPCL) {\n\t\tjsm_dbg(CLOSE, &channel->ch_bd->pci_dev,\n\t\t\t\"Close. HUPCL set, dropping DTR/RTS\\n\");\n\n\t\t \n\t\tchannel->ch_mostat &= ~(UART_MCR_DTR | UART_MCR_RTS);\n\t\tbd->bd_ops->assert_modem_signals(channel);\n\t}\n\n\t \n\tchannel->ch_bd->bd_ops->uart_off(channel);\n\n\tjsm_dbg(CLOSE, &channel->ch_bd->pci_dev, \"finish\\n\");\n}\n\nstatic void jsm_tty_set_termios(struct uart_port *port,\n\t\t\t\tstruct ktermios *termios,\n\t\t\t\tconst struct ktermios *old_termios)\n{\n\tunsigned long lock_flags;\n\tstruct jsm_channel *channel =\n\t\tcontainer_of(port, struct jsm_channel, uart_port);\n\n\tspin_lock_irqsave(&port->lock, lock_flags);\n\tchannel->ch_c_cflag\t= termios->c_cflag;\n\tchannel->ch_c_iflag\t= termios->c_iflag;\n\tchannel->ch_c_oflag\t= termios->c_oflag;\n\tchannel->ch_c_lflag\t= termios->c_lflag;\n\tchannel->ch_startc\t= termios->c_cc[VSTART];\n\tchannel->ch_stopc\t= termios->c_cc[VSTOP];\n\n\tchannel->ch_bd->bd_ops->param(channel);\n\tjsm_carrier(channel);\n\tspin_unlock_irqrestore(&port->lock, lock_flags);\n}\n\nstatic const char *jsm_tty_type(struct uart_port *port)\n{\n\treturn \"jsm\";\n}\n\nstatic void jsm_tty_release_port(struct uart_port *port)\n{\n}\n\nstatic int jsm_tty_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void jsm_config_port(struct uart_port *port, int flags)\n{\n\tport->type = PORT_JSM;\n}\n\nstatic const struct uart_ops jsm_ops = {\n\t.tx_empty\t= jsm_tty_tx_empty,\n\t.set_mctrl\t= jsm_tty_set_mctrl,\n\t.get_mctrl\t= jsm_tty_get_mctrl,\n\t.stop_tx\t= jsm_tty_stop_tx,\n\t.start_tx\t= jsm_tty_start_tx,\n\t.send_xchar\t= jsm_tty_send_xchar,\n\t.stop_rx\t= jsm_tty_stop_rx,\n\t.break_ctl\t= jsm_tty_break,\n\t.startup\t= jsm_tty_open,\n\t.shutdown\t= jsm_tty_close,\n\t.set_termios\t= jsm_tty_set_termios,\n\t.type\t\t= jsm_tty_type,\n\t.release_port\t= jsm_tty_release_port,\n\t.request_port\t= jsm_tty_request_port,\n\t.config_port\t= jsm_config_port,\n};\n\n \nint jsm_tty_init(struct jsm_board *brd)\n{\n\tint i;\n\tvoid __iomem *vaddr;\n\tstruct jsm_channel *ch;\n\n\tif (!brd)\n\t\treturn -ENXIO;\n\n\tjsm_dbg(INIT, &brd->pci_dev, \"start\\n\");\n\n\t \n\n\tbrd->nasync = brd->maxports;\n\n\t \n\tfor (i = 0; i < brd->nasync; i++) {\n\t\tif (!brd->channels[i]) {\n\n\t\t\t \n\t\t\tbrd->channels[i] = kzalloc(sizeof(struct jsm_channel), GFP_KERNEL);\n\t\t\tif (!brd->channels[i]) {\n\t\t\t\tjsm_dbg(CORE, &brd->pci_dev,\n\t\t\t\t\t\"%s:%d Unable to allocate memory for channel struct\\n\",\n\t\t\t\t\t__FILE__, __LINE__);\n\t\t\t}\n\t\t}\n\t}\n\n\tch = brd->channels[0];\n\tvaddr = brd->re_map_membase;\n\n\t \n\tfor (i = 0; i < brd->nasync; i++, ch = brd->channels[i]) {\n\n\t\tif (!brd->channels[i])\n\t\t\tcontinue;\n\n\t\tspin_lock_init(&ch->ch_lock);\n\n\t\tif (brd->bd_uart_offset == 0x200)\n\t\t\tch->ch_neo_uart =  vaddr + (brd->bd_uart_offset * i);\n\t\telse\n\t\t\tch->ch_cls_uart =  vaddr + (brd->bd_uart_offset * i);\n\n\t\tch->ch_bd = brd;\n\t\tch->ch_portnum = i;\n\n\t\t \n\t\tch->ch_close_delay = 250;\n\n\t\tinit_waitqueue_head(&ch->ch_flags_wait);\n\t}\n\n\tjsm_dbg(INIT, &brd->pci_dev, \"finish\\n\");\n\treturn 0;\n}\n\nint jsm_uart_port_init(struct jsm_board *brd)\n{\n\tint i, rc;\n\tunsigned int line;\n\n\tif (!brd)\n\t\treturn -ENXIO;\n\n\tjsm_dbg(INIT, &brd->pci_dev, \"start\\n\");\n\n\t \n\n\tbrd->nasync = brd->maxports;\n\n\t \n\tfor (i = 0; i < brd->nasync; i++) {\n\n\t\tif (!brd->channels[i])\n\t\t\tcontinue;\n\n\t\tbrd->channels[i]->uart_port.irq = brd->irq;\n\t\tbrd->channels[i]->uart_port.uartclk = 14745600;\n\t\tbrd->channels[i]->uart_port.type = PORT_JSM;\n\t\tbrd->channels[i]->uart_port.iotype = UPIO_MEM;\n\t\tbrd->channels[i]->uart_port.membase = brd->re_map_membase;\n\t\tbrd->channels[i]->uart_port.fifosize = 16;\n\t\tbrd->channels[i]->uart_port.ops = &jsm_ops;\n\t\tline = find_first_zero_bit(linemap, MAXLINES);\n\t\tif (line >= MAXLINES) {\n\t\t\tprintk(KERN_INFO \"jsm: linemap is full, added device failed\\n\");\n\t\t\tcontinue;\n\t\t} else\n\t\t\tset_bit(line, linemap);\n\t\tbrd->channels[i]->uart_port.line = line;\n\t\trc = uart_add_one_port(&jsm_uart_driver, &brd->channels[i]->uart_port);\n\t\tif (rc) {\n\t\t\tprintk(KERN_INFO \"jsm: Port %d failed. Aborting...\\n\", i);\n\t\t\treturn rc;\n\t\t} else\n\t\t\tprintk(KERN_INFO \"jsm: Port %d added\\n\", i);\n\t}\n\n\tjsm_dbg(INIT, &brd->pci_dev, \"finish\\n\");\n\treturn 0;\n}\n\nint jsm_remove_uart_port(struct jsm_board *brd)\n{\n\tint i;\n\tstruct jsm_channel *ch;\n\n\tif (!brd)\n\t\treturn -ENXIO;\n\n\tjsm_dbg(INIT, &brd->pci_dev, \"start\\n\");\n\n\t \n\n\tbrd->nasync = brd->maxports;\n\n\t \n\tfor (i = 0; i < brd->nasync; i++) {\n\n\t\tif (!brd->channels[i])\n\t\t\tcontinue;\n\n\t\tch = brd->channels[i];\n\n\t\tclear_bit(ch->uart_port.line, linemap);\n\t\tuart_remove_one_port(&jsm_uart_driver, &brd->channels[i]->uart_port);\n\t}\n\n\tjsm_dbg(INIT, &brd->pci_dev, \"finish\\n\");\n\treturn 0;\n}\n\nvoid jsm_input(struct jsm_channel *ch)\n{\n\tstruct jsm_board *bd;\n\tstruct tty_struct *tp;\n\tstruct tty_port *port;\n\tu32 rmask;\n\tu16 head;\n\tu16 tail;\n\tint data_len;\n\tunsigned long lock_flags;\n\tint len = 0;\n\tint s = 0;\n\tint i = 0;\n\n\tjsm_dbg(READ, &ch->ch_bd->pci_dev, \"start\\n\");\n\n\tport = &ch->uart_port.state->port;\n\ttp = port->tty;\n\n\tbd = ch->ch_bd;\n\tif (!bd)\n\t\treturn;\n\n\tspin_lock_irqsave(&ch->ch_lock, lock_flags);\n\n\t \n\n\trmask = RQUEUEMASK;\n\n\thead = ch->ch_r_head & rmask;\n\ttail = ch->ch_r_tail & rmask;\n\n\tdata_len = (head - tail) & rmask;\n\tif (data_len == 0) {\n\t\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n\t\treturn;\n\t}\n\n\tjsm_dbg(READ, &ch->ch_bd->pci_dev, \"start\\n\");\n\n\t \n\tif (!tp || !C_CREAD(tp)) {\n\n\t\tjsm_dbg(READ, &ch->ch_bd->pci_dev,\n\t\t\t\"input. dropping %d bytes on port %d...\\n\",\n\t\t\tdata_len, ch->ch_portnum);\n\t\tch->ch_r_head = tail;\n\n\t\t \n\t\tjsm_check_queue_flow_control(ch);\n\n\t\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n\t\treturn;\n\t}\n\n\t \n\tif (ch->ch_flags & CH_STOPI) {\n\t\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n\t\tjsm_dbg(READ, &ch->ch_bd->pci_dev,\n\t\t\t\"Port %d throttled, not reading any data. head: %x tail: %x\\n\",\n\t\t\tch->ch_portnum, head, tail);\n\t\treturn;\n\t}\n\n\tjsm_dbg(READ, &ch->ch_bd->pci_dev, \"start 2\\n\");\n\n\tlen = tty_buffer_request_room(port, data_len);\n\n\t \n\twhile (len) {\n\t\ts = ((head >= tail) ? head : RQUEUESIZE) - tail;\n\t\ts = min(s, len);\n\n\t\tif (s <= 0)\n\t\t\tbreak;\n\n\t\t\t \n\n\t\tif (I_PARMRK(tp) || I_BRKINT(tp) || I_INPCK(tp)) {\n\t\t\tfor (i = 0; i < s; i++) {\n\t\t\t\tu8 chr   = ch->ch_rqueue[tail + i];\n\t\t\t\tu8 error = ch->ch_equeue[tail + i];\n\t\t\t\tchar flag = TTY_NORMAL;\n\n\t\t\t\t \n\t\t\t\tif (error & UART_LSR_BI)\n\t\t\t\t\tflag = TTY_BREAK;\n\t\t\t\telse if (error & UART_LSR_PE)\n\t\t\t\t\tflag = TTY_PARITY;\n\t\t\t\telse if (error & UART_LSR_FE)\n\t\t\t\t\tflag = TTY_FRAME;\n\n\t\t\t\ttty_insert_flip_char(port, chr, flag);\n\t\t\t}\n\t\t} else {\n\t\t\ttty_insert_flip_string(port, ch->ch_rqueue + tail, s);\n\t\t}\n\t\ttail += s;\n\t\tlen -= s;\n\t\t \n\t\ttail &= rmask;\n\t}\n\n\tch->ch_r_tail = tail & rmask;\n\tch->ch_e_tail = tail & rmask;\n\tjsm_check_queue_flow_control(ch);\n\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n\n\t \n\ttty_flip_buffer_push(port);\n\n\tjsm_dbg(IOCTL, &ch->ch_bd->pci_dev, \"finish\\n\");\n}\n\nstatic void jsm_carrier(struct jsm_channel *ch)\n{\n\tstruct jsm_board *bd;\n\n\tint virt_carrier = 0;\n\tint phys_carrier = 0;\n\n\tjsm_dbg(CARR, &ch->ch_bd->pci_dev, \"start\\n\");\n\n\tbd = ch->ch_bd;\n\tif (!bd)\n\t\treturn;\n\n\tif (ch->ch_mistat & UART_MSR_DCD) {\n\t\tjsm_dbg(CARR, &ch->ch_bd->pci_dev, \"mistat: %x D_CD: %x\\n\",\n\t\t\tch->ch_mistat, ch->ch_mistat & UART_MSR_DCD);\n\t\tphys_carrier = 1;\n\t}\n\n\tif (ch->ch_c_cflag & CLOCAL)\n\t\tvirt_carrier = 1;\n\n\tjsm_dbg(CARR, &ch->ch_bd->pci_dev, \"DCD: physical: %d virt: %d\\n\",\n\t\tphys_carrier, virt_carrier);\n\n\t \n\tif (((ch->ch_flags & CH_FCAR) == 0) && (virt_carrier == 1)) {\n\n\t\t \n\n\t\tjsm_dbg(CARR, &ch->ch_bd->pci_dev, \"carrier: virt DCD rose\\n\");\n\n\t\tif (waitqueue_active(&(ch->ch_flags_wait)))\n\t\t\twake_up_interruptible(&ch->ch_flags_wait);\n\t}\n\n\t \n\tif (((ch->ch_flags & CH_CD) == 0) && (phys_carrier == 1)) {\n\n\t\t \n\n\t\tjsm_dbg(CARR, &ch->ch_bd->pci_dev,\n\t\t\t\"carrier: physical DCD rose\\n\");\n\n\t\tif (waitqueue_active(&(ch->ch_flags_wait)))\n\t\t\twake_up_interruptible(&ch->ch_flags_wait);\n\t}\n\n\t \n\tif ((virt_carrier == 0) && ((ch->ch_flags & CH_CD) != 0)\n\t\t\t&& (phys_carrier == 0)) {\n\t\t \n\t\tif (waitqueue_active(&(ch->ch_flags_wait)))\n\t\t\twake_up_interruptible(&ch->ch_flags_wait);\n\t}\n\n\t \n\tif (virt_carrier == 1)\n\t\tch->ch_flags |= CH_FCAR;\n\telse\n\t\tch->ch_flags &= ~CH_FCAR;\n\n\tif (phys_carrier == 1)\n\t\tch->ch_flags |= CH_CD;\n\telse\n\t\tch->ch_flags &= ~CH_CD;\n}\n\n\nvoid jsm_check_queue_flow_control(struct jsm_channel *ch)\n{\n\tstruct board_ops *bd_ops = ch->ch_bd->bd_ops;\n\tint qleft;\n\n\t \n\tqleft = ch->ch_r_tail - ch->ch_r_head - 1;\n\tif (qleft < 0)\n\t\tqleft += RQUEUEMASK + 1;\n\n\t \n\tif (qleft < 256) {\n\t\t \n\t\tif (ch->ch_c_cflag & CRTSCTS) {\n\t\t\tif (!(ch->ch_flags & CH_RECEIVER_OFF)) {\n\t\t\t\tbd_ops->disable_receiver(ch);\n\t\t\t\tch->ch_flags |= (CH_RECEIVER_OFF);\n\t\t\t\tjsm_dbg(READ, &ch->ch_bd->pci_dev,\n\t\t\t\t\t\"Internal queue hit hilevel mark (%d)! Turning off interrupts\\n\",\n\t\t\t\t\tqleft);\n\t\t\t}\n\t\t}\n\t\t \n\t\telse if (ch->ch_c_iflag & IXOFF) {\n\t\t\tif (ch->ch_stops_sent <= MAX_STOPS_SENT) {\n\t\t\t\tbd_ops->send_stop_character(ch);\n\t\t\t\tch->ch_stops_sent++;\n\t\t\t\tjsm_dbg(READ, &ch->ch_bd->pci_dev,\n\t\t\t\t\t\"Sending stop char! Times sent: %x\\n\",\n\t\t\t\t\tch->ch_stops_sent);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (qleft > (RQUEUESIZE / 2)) {\n\t\t \n\t\tif (ch->ch_c_cflag & CRTSCTS) {\n\t\t\tif (ch->ch_flags & CH_RECEIVER_OFF) {\n\t\t\t\tbd_ops->enable_receiver(ch);\n\t\t\t\tch->ch_flags &= ~(CH_RECEIVER_OFF);\n\t\t\t\tjsm_dbg(READ, &ch->ch_bd->pci_dev,\n\t\t\t\t\t\"Internal queue hit lowlevel mark (%d)! Turning on interrupts\\n\",\n\t\t\t\t\tqleft);\n\t\t\t}\n\t\t}\n\t\t \n\t\telse if (ch->ch_c_iflag & IXOFF && ch->ch_stops_sent) {\n\t\t\tch->ch_stops_sent = 0;\n\t\t\tbd_ops->send_start_character(ch);\n\t\t\tjsm_dbg(READ, &ch->ch_bd->pci_dev,\n\t\t\t\t\"Sending start char!\\n\");\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}