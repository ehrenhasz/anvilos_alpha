{
  "module_name": "jsm_neo.c",
  "hash_id": "1779d8072680c9a87d80d4c5c42450ae054ddd0235cb0f997ce55b47c4e564fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/jsm/jsm_neo.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\t \n#include <linux/serial_reg.h>\t \n#include <linux/tty.h>\n#include <linux/pci.h>\n#include <asm/io.h>\n\n#include \"jsm.h\"\t\t \n\nstatic u32 jsm_offset_table[8] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };\n\n \nstatic inline void neo_pci_posting_flush(struct jsm_board *bd)\n{\n      readb(bd->re_map_membase + 0x8D);\n}\n\nstatic void neo_set_cts_flow_control(struct jsm_channel *ch)\n{\n\tu8 ier, efr;\n\tier = readb(&ch->ch_neo_uart->ier);\n\tefr = readb(&ch->ch_neo_uart->efr);\n\n\tjsm_dbg(PARAM, &ch->ch_bd->pci_dev, \"Setting CTSFLOW\\n\");\n\n\t \n\tier |= (UART_17158_IER_CTSDSR);\n\tefr |= (UART_17158_EFR_ECB | UART_17158_EFR_CTSDSR);\n\n\t \n\tefr &= ~(UART_17158_EFR_IXON);\n\n\t \n\twriteb(0, &ch->ch_neo_uart->efr);\n\n\t \n\twriteb(efr, &ch->ch_neo_uart->efr);\n\n\t \n\twriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_4DELAY), &ch->ch_neo_uart->fctr);\n\n\t \n\twriteb(8, &ch->ch_neo_uart->tfifo);\n\tch->ch_t_tlevel = 8;\n\n\twriteb(ier, &ch->ch_neo_uart->ier);\n}\n\nstatic void neo_set_rts_flow_control(struct jsm_channel *ch)\n{\n\tu8 ier, efr;\n\tier = readb(&ch->ch_neo_uart->ier);\n\tefr = readb(&ch->ch_neo_uart->efr);\n\n\tjsm_dbg(PARAM, &ch->ch_bd->pci_dev, \"Setting RTSFLOW\\n\");\n\n\t \n\tier |= (UART_17158_IER_RTSDTR);\n\tefr |= (UART_17158_EFR_ECB | UART_17158_EFR_RTSDTR);\n\n\t \n\tier &= ~(UART_17158_IER_XOFF);\n\tefr &= ~(UART_17158_EFR_IXOFF);\n\n\t \n\twriteb(0, &ch->ch_neo_uart->efr);\n\n\t \n\twriteb(efr, &ch->ch_neo_uart->efr);\n\n\twriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_4DELAY), &ch->ch_neo_uart->fctr);\n\tch->ch_r_watermark = 4;\n\n\twriteb(56, &ch->ch_neo_uart->rfifo);\n\tch->ch_r_tlevel = 56;\n\n\twriteb(ier, &ch->ch_neo_uart->ier);\n\n\t \n\tch->ch_mostat |= (UART_MCR_RTS);\n}\n\n\nstatic void neo_set_ixon_flow_control(struct jsm_channel *ch)\n{\n\tu8 ier, efr;\n\tier = readb(&ch->ch_neo_uart->ier);\n\tefr = readb(&ch->ch_neo_uart->efr);\n\n\tjsm_dbg(PARAM, &ch->ch_bd->pci_dev, \"Setting IXON FLOW\\n\");\n\n\t \n\tier &= ~(UART_17158_IER_CTSDSR);\n\tefr &= ~(UART_17158_EFR_CTSDSR);\n\n\t \n\tefr |= (UART_17158_EFR_ECB | UART_17158_EFR_IXON);\n\n\t \n\twriteb(0, &ch->ch_neo_uart->efr);\n\n\t \n\twriteb(efr, &ch->ch_neo_uart->efr);\n\n\twriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_8DELAY), &ch->ch_neo_uart->fctr);\n\tch->ch_r_watermark = 4;\n\n\twriteb(32, &ch->ch_neo_uart->rfifo);\n\tch->ch_r_tlevel = 32;\n\n\t \n\twriteb(ch->ch_startc, &ch->ch_neo_uart->xonchar1);\n\twriteb(0, &ch->ch_neo_uart->xonchar2);\n\n\twriteb(ch->ch_stopc, &ch->ch_neo_uart->xoffchar1);\n\twriteb(0, &ch->ch_neo_uart->xoffchar2);\n\n\twriteb(ier, &ch->ch_neo_uart->ier);\n}\n\nstatic void neo_set_ixoff_flow_control(struct jsm_channel *ch)\n{\n\tu8 ier, efr;\n\tier = readb(&ch->ch_neo_uart->ier);\n\tefr = readb(&ch->ch_neo_uart->efr);\n\n\tjsm_dbg(PARAM, &ch->ch_bd->pci_dev, \"Setting IXOFF FLOW\\n\");\n\n\t \n\tier &= ~(UART_17158_IER_RTSDTR);\n\tefr &= ~(UART_17158_EFR_RTSDTR);\n\n\t \n\tier |= (UART_17158_IER_XOFF);\n\tefr |= (UART_17158_EFR_ECB | UART_17158_EFR_IXOFF);\n\n\t \n\twriteb(0, &ch->ch_neo_uart->efr);\n\n\t \n\twriteb(efr, &ch->ch_neo_uart->efr);\n\n\t \n\twriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_8DELAY), &ch->ch_neo_uart->fctr);\n\n\twriteb(8, &ch->ch_neo_uart->tfifo);\n\tch->ch_t_tlevel = 8;\n\n\t \n\twriteb(ch->ch_startc, &ch->ch_neo_uart->xonchar1);\n\twriteb(0, &ch->ch_neo_uart->xonchar2);\n\n\twriteb(ch->ch_stopc, &ch->ch_neo_uart->xoffchar1);\n\twriteb(0, &ch->ch_neo_uart->xoffchar2);\n\n\twriteb(ier, &ch->ch_neo_uart->ier);\n}\n\nstatic void neo_set_no_input_flow_control(struct jsm_channel *ch)\n{\n\tu8 ier, efr;\n\tier = readb(&ch->ch_neo_uart->ier);\n\tefr = readb(&ch->ch_neo_uart->efr);\n\n\tjsm_dbg(PARAM, &ch->ch_bd->pci_dev, \"Unsetting Input FLOW\\n\");\n\n\t \n\tier &= ~(UART_17158_IER_RTSDTR);\n\tefr &= ~(UART_17158_EFR_RTSDTR);\n\n\t \n\tier &= ~(UART_17158_IER_XOFF);\n\tif (ch->ch_c_iflag & IXON)\n\t\tefr &= ~(UART_17158_EFR_IXOFF);\n\telse\n\t\tefr &= ~(UART_17158_EFR_ECB | UART_17158_EFR_IXOFF);\n\n\t \n\twriteb(0, &ch->ch_neo_uart->efr);\n\n\t \n\twriteb(efr, &ch->ch_neo_uart->efr);\n\n\t \n\twriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_8DELAY), &ch->ch_neo_uart->fctr);\n\n\tch->ch_r_watermark = 0;\n\n\twriteb(16, &ch->ch_neo_uart->tfifo);\n\tch->ch_t_tlevel = 16;\n\n\twriteb(16, &ch->ch_neo_uart->rfifo);\n\tch->ch_r_tlevel = 16;\n\n\twriteb(ier, &ch->ch_neo_uart->ier);\n}\n\nstatic void neo_set_no_output_flow_control(struct jsm_channel *ch)\n{\n\tu8 ier, efr;\n\tier = readb(&ch->ch_neo_uart->ier);\n\tefr = readb(&ch->ch_neo_uart->efr);\n\n\tjsm_dbg(PARAM, &ch->ch_bd->pci_dev, \"Unsetting Output FLOW\\n\");\n\n\t \n\tier &= ~(UART_17158_IER_CTSDSR);\n\tefr &= ~(UART_17158_EFR_CTSDSR);\n\n\t \n\tif (ch->ch_c_iflag & IXOFF)\n\t\tefr &= ~(UART_17158_EFR_IXON);\n\telse\n\t\tefr &= ~(UART_17158_EFR_ECB | UART_17158_EFR_IXON);\n\n\t \n\twriteb(0, &ch->ch_neo_uart->efr);\n\n\t \n\twriteb(efr, &ch->ch_neo_uart->efr);\n\n\t \n\twriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_8DELAY), &ch->ch_neo_uart->fctr);\n\n\tch->ch_r_watermark = 0;\n\n\twriteb(16, &ch->ch_neo_uart->tfifo);\n\tch->ch_t_tlevel = 16;\n\n\twriteb(16, &ch->ch_neo_uart->rfifo);\n\tch->ch_r_tlevel = 16;\n\n\twriteb(ier, &ch->ch_neo_uart->ier);\n}\n\nstatic inline void neo_set_new_start_stop_chars(struct jsm_channel *ch)\n{\n\n\t \n\tif (ch->ch_c_cflag & CRTSCTS)\n\t\treturn;\n\n\tjsm_dbg(PARAM, &ch->ch_bd->pci_dev, \"start\\n\");\n\n\t \n\twriteb(ch->ch_startc, &ch->ch_neo_uart->xonchar1);\n\twriteb(0, &ch->ch_neo_uart->xonchar2);\n\n\twriteb(ch->ch_stopc, &ch->ch_neo_uart->xoffchar1);\n\twriteb(0, &ch->ch_neo_uart->xoffchar2);\n}\n\nstatic void neo_copy_data_from_uart_to_queue(struct jsm_channel *ch)\n{\n\tint qleft = 0;\n\tu8 linestatus = 0;\n\tu8 error_mask = 0;\n\tint n = 0;\n\tint total = 0;\n\tu16 head;\n\tu16 tail;\n\n\t \n\thead = ch->ch_r_head & RQUEUEMASK;\n\ttail = ch->ch_r_tail & RQUEUEMASK;\n\n\t \n\tlinestatus = ch->ch_cached_lsr;\n\tch->ch_cached_lsr = 0;\n\n\t \n\tqleft = tail - head - 1;\n\tif (qleft < 0)\n\t\tqleft += RQUEUEMASK + 1;\n\n\t \n\tif (!(ch->ch_flags & CH_FIFO_ENABLED))\n\t\ttotal = 0;\n\telse {\n\t\ttotal = readb(&ch->ch_neo_uart->rfifo);\n\n\t\t \n\t\ttotal -= 3;\n\t}\n\n\t \n\ttotal = min(total, qleft);\n\n\twhile (total > 0) {\n\t\t \n\t\tlinestatus = readb(&ch->ch_neo_uart->lsr);\n\n\t\t \n\t\tif (linestatus & UART_17158_RX_FIFO_DATA_ERROR)\n\t\t\tbreak;\n\n\t\t \n\t\tn = min(((u32) total), (RQUEUESIZE - (u32) head));\n\n\t\t \n\t\tn = min((u32) n, (u32) 12);\n\n\t\t \n\t\tif (linestatus & (UART_LSR_THRE | UART_17158_TX_AND_FIFO_CLR))\n\t\t\tch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\n\n\t\tlinestatus = 0;\n\n\t\t \n\t\tmemcpy_fromio(ch->ch_rqueue + head, &ch->ch_neo_uart->txrxburst, n);\n\t\t \n\t\tmemset(ch->ch_equeue + head, 0, n);\n\n\t\t \n\t\thead = (head + n) & RQUEUEMASK;\n\t\ttotal -= n;\n\t\tqleft -= n;\n\t\tch->ch_rxcount += n;\n\t}\n\n\t \n\tif (ch->ch_c_iflag & IGNBRK)\n\t\terror_mask |= UART_LSR_BI;\n\n\t \n\twhile (1) {\n\n\t\t \n\t\tlinestatus |= readb(&ch->ch_neo_uart->lsr);\n\n\t\t \n\t\tif (!(linestatus & UART_LSR_DR)) {\n\t\t\tch->ch_cached_lsr = linestatus;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tlinestatus &= ~UART_LSR_DR;\n\n\t\t \n\t\tif (linestatus & (UART_LSR_THRE | UART_17158_TX_AND_FIFO_CLR)) {\n\t\t\tlinestatus &= ~(UART_LSR_THRE | UART_17158_TX_AND_FIFO_CLR);\n\t\t\tch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\n\t\t}\n\n\t\t \n\t\tif (linestatus & error_mask) {\n\t\t\tu8 discard;\n\t\t\tlinestatus = 0;\n\t\t\tmemcpy_fromio(&discard, &ch->ch_neo_uart->txrxburst, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\twhile (qleft < 1) {\n\t\t\tjsm_dbg(READ, &ch->ch_bd->pci_dev,\n\t\t\t\t\"Queue full, dropping DATA:%x LSR:%x\\n\",\n\t\t\t\tch->ch_rqueue[tail], ch->ch_equeue[tail]);\n\n\t\t\tch->ch_r_tail = tail = (tail + 1) & RQUEUEMASK;\n\t\t\tch->ch_err_overrun++;\n\t\t\tqleft++;\n\t\t}\n\n\t\tmemcpy_fromio(ch->ch_rqueue + head, &ch->ch_neo_uart->txrxburst, 1);\n\t\tch->ch_equeue[head] = (u8) linestatus;\n\n\t\tjsm_dbg(READ, &ch->ch_bd->pci_dev, \"DATA/LSR pair: %x %x\\n\",\n\t\t\tch->ch_rqueue[head], ch->ch_equeue[head]);\n\n\t\t \n\t\tlinestatus = 0;\n\n\t\t \n\t\thead = (head + 1) & RQUEUEMASK;\n\n\t\tqleft--;\n\t\tch->ch_rxcount++;\n\t}\n\n\t \n\tch->ch_r_head = head & RQUEUEMASK;\n\tch->ch_e_head = head & EQUEUEMASK;\n\tjsm_input(ch);\n}\n\nstatic void neo_copy_data_from_queue_to_uart(struct jsm_channel *ch)\n{\n\tu16 head;\n\tu16 tail;\n\tint n;\n\tint s;\n\tint qlen;\n\tu32 len_written = 0;\n\tstruct circ_buf *circ;\n\n\tif (!ch)\n\t\treturn;\n\n\tcirc = &ch->uart_port.state->xmit;\n\n\t \n\tif (uart_circ_empty(circ))\n\t\treturn;\n\n\t \n\tif ((ch->ch_flags & CH_STOP) || (ch->ch_flags & CH_BREAK_SENDING))\n\t\treturn;\n\t \n\tif (!(ch->ch_flags & CH_FIFO_ENABLED)) {\n\t\tu8 lsrbits = readb(&ch->ch_neo_uart->lsr);\n\n\t\tch->ch_cached_lsr |= lsrbits;\n\t\tif (ch->ch_cached_lsr & UART_LSR_THRE) {\n\t\t\tch->ch_cached_lsr &= ~(UART_LSR_THRE);\n\n\t\t\twriteb(circ->buf[circ->tail], &ch->ch_neo_uart->txrx);\n\t\t\tjsm_dbg(WRITE, &ch->ch_bd->pci_dev,\n\t\t\t\t\"Tx data: %x\\n\", circ->buf[circ->tail]);\n\t\t\tcirc->tail = (circ->tail + 1) & (UART_XMIT_SIZE - 1);\n\t\t\tch->ch_txcount++;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (!(ch->ch_flags & (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM)))\n\t\treturn;\n\n\tn = UART_17158_TX_FIFOSIZE - ch->ch_t_tlevel;\n\n\t \n\thead = circ->head & (UART_XMIT_SIZE - 1);\n\ttail = circ->tail & (UART_XMIT_SIZE - 1);\n\tqlen = uart_circ_chars_pending(circ);\n\n\t \n\tn = min(n, qlen);\n\n\twhile (n > 0) {\n\n\t\ts = ((head >= tail) ? head : UART_XMIT_SIZE) - tail;\n\t\ts = min(s, n);\n\n\t\tif (s <= 0)\n\t\t\tbreak;\n\n\t\tmemcpy_toio(&ch->ch_neo_uart->txrxburst, circ->buf + tail, s);\n\t\t \n\t\ttail = (tail + s) & (UART_XMIT_SIZE - 1);\n\t\tn -= s;\n\t\tch->ch_txcount += s;\n\t\tlen_written += s;\n\t}\n\n\t \n\tcirc->tail = tail & (UART_XMIT_SIZE - 1);\n\n\tif (len_written >= ch->ch_t_tlevel)\n\t\tch->ch_flags &= ~(CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\n\n\tif (uart_circ_empty(circ))\n\t\tuart_write_wakeup(&ch->uart_port);\n}\n\nstatic void neo_parse_modem(struct jsm_channel *ch, u8 signals)\n{\n\tu8 msignals = signals;\n\n\tjsm_dbg(MSIGS, &ch->ch_bd->pci_dev,\n\t\t\"neo_parse_modem: port: %d msignals: %x\\n\",\n\t\tch->ch_portnum, msignals);\n\n\t \n\t \n\tmsignals &= 0xf8;\n\n\tif (msignals & UART_MSR_DDCD)\n\t\tuart_handle_dcd_change(&ch->uart_port, msignals & UART_MSR_DCD);\n\tif (msignals & UART_MSR_DDSR)\n\t\tuart_handle_cts_change(&ch->uart_port, msignals & UART_MSR_CTS);\n\tif (msignals & UART_MSR_DCD)\n\t\tch->ch_mistat |= UART_MSR_DCD;\n\telse\n\t\tch->ch_mistat &= ~UART_MSR_DCD;\n\n\tif (msignals & UART_MSR_DSR)\n\t\tch->ch_mistat |= UART_MSR_DSR;\n\telse\n\t\tch->ch_mistat &= ~UART_MSR_DSR;\n\n\tif (msignals & UART_MSR_RI)\n\t\tch->ch_mistat |= UART_MSR_RI;\n\telse\n\t\tch->ch_mistat &= ~UART_MSR_RI;\n\n\tif (msignals & UART_MSR_CTS)\n\t\tch->ch_mistat |= UART_MSR_CTS;\n\telse\n\t\tch->ch_mistat &= ~UART_MSR_CTS;\n\n\tjsm_dbg(MSIGS, &ch->ch_bd->pci_dev,\n\t\t\"Port: %d DTR: %d RTS: %d CTS: %d DSR: %d \" \"RI: %d CD: %d\\n\",\n\t\tch->ch_portnum,\n\t\t!!((ch->ch_mistat | ch->ch_mostat) & UART_MCR_DTR),\n\t\t!!((ch->ch_mistat | ch->ch_mostat) & UART_MCR_RTS),\n\t\t!!((ch->ch_mistat | ch->ch_mostat) & UART_MSR_CTS),\n\t\t!!((ch->ch_mistat | ch->ch_mostat) & UART_MSR_DSR),\n\t\t!!((ch->ch_mistat | ch->ch_mostat) & UART_MSR_RI),\n\t\t!!((ch->ch_mistat | ch->ch_mostat) & UART_MSR_DCD));\n}\n\n \nstatic void neo_assert_modem_signals(struct jsm_channel *ch)\n{\n\tif (!ch)\n\t\treturn;\n\n\twriteb(ch->ch_mostat, &ch->ch_neo_uart->mcr);\n\n\t \n\tneo_pci_posting_flush(ch->ch_bd);\n}\n\n \nstatic void neo_flush_uart_write(struct jsm_channel *ch)\n{\n\tu8 tmp = 0;\n\tint i = 0;\n\n\tif (!ch)\n\t\treturn;\n\n\twriteb((UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_XMIT), &ch->ch_neo_uart->isr_fcr);\n\n\tfor (i = 0; i < 10; i++) {\n\n\t\t \n\t\ttmp = readb(&ch->ch_neo_uart->isr_fcr);\n\t\tif (tmp & UART_FCR_CLEAR_XMIT) {\n\t\t\tjsm_dbg(IOCTL, &ch->ch_bd->pci_dev,\n\t\t\t\t\"Still flushing TX UART... i: %d\\n\", i);\n\t\t\tudelay(10);\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\n}\n\n\n \nstatic void neo_flush_uart_read(struct jsm_channel *ch)\n{\n\tu8 tmp = 0;\n\tint i = 0;\n\n\tif (!ch)\n\t\treturn;\n\n\twriteb((UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR), &ch->ch_neo_uart->isr_fcr);\n\n\tfor (i = 0; i < 10; i++) {\n\n\t\t \n\t\ttmp = readb(&ch->ch_neo_uart->isr_fcr);\n\t\tif (tmp & 2) {\n\t\t\tjsm_dbg(IOCTL, &ch->ch_bd->pci_dev,\n\t\t\t\t\"Still flushing RX UART... i: %d\\n\", i);\n\t\t\tudelay(10);\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void neo_clear_break(struct jsm_channel *ch)\n{\n\tunsigned long lock_flags;\n\n\tspin_lock_irqsave(&ch->ch_lock, lock_flags);\n\n\t \n\tif (ch->ch_flags & CH_BREAK_SENDING) {\n\t\tu8 temp = readb(&ch->ch_neo_uart->lcr);\n\t\twriteb((temp & ~UART_LCR_SBC), &ch->ch_neo_uart->lcr);\n\n\t\tch->ch_flags &= ~(CH_BREAK_SENDING);\n\t\tjsm_dbg(IOCTL, &ch->ch_bd->pci_dev,\n\t\t\t\"clear break Finishing UART_LCR_SBC! finished: %lx\\n\",\n\t\t\tjiffies);\n\n\t\t \n\t\tneo_pci_posting_flush(ch->ch_bd);\n\t}\n\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n}\n\n \nstatic void neo_parse_isr(struct jsm_board *brd, u32 port)\n{\n\tstruct jsm_channel *ch;\n\tu8 isr;\n\tu8 cause;\n\tunsigned long lock_flags;\n\n\tif (!brd)\n\t\treturn;\n\n\tif (port >= brd->maxports)\n\t\treturn;\n\n\tch = brd->channels[port];\n\tif (!ch)\n\t\treturn;\n\n\t \n\twhile (1) {\n\n\t\tisr = readb(&ch->ch_neo_uart->isr_fcr);\n\n\t\t \n\t\tif (isr & UART_IIR_NO_INT)\n\t\t\tbreak;\n\n\t\t \n\t\tisr &= ~(UART_17158_IIR_FIFO_ENABLED);\n\n\t\tjsm_dbg(INTR, &ch->ch_bd->pci_dev, \"%s:%d isr: %x\\n\",\n\t\t\t__FILE__, __LINE__, isr);\n\n\t\tif (isr & (UART_17158_IIR_RDI_TIMEOUT | UART_IIR_RDI)) {\n\t\t\t \n\t\t\tneo_copy_data_from_uart_to_queue(ch);\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&ch->ch_lock, lock_flags);\n\t\t\tjsm_check_queue_flow_control(ch);\n\t\t\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n\t\t}\n\n\t\tif (isr & UART_IIR_THRI) {\n\t\t\t \n\t\t\tspin_lock_irqsave(&ch->ch_lock, lock_flags);\n\t\t\tch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\n\t\t\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n\t\t\tneo_copy_data_from_queue_to_uart(ch);\n\t\t}\n\n\t\tif (isr & UART_17158_IIR_XONXOFF) {\n\t\t\tcause = readb(&ch->ch_neo_uart->xoffchar1);\n\n\t\t\tjsm_dbg(INTR, &ch->ch_bd->pci_dev,\n\t\t\t\t\"Port %d. Got ISR_XONXOFF: cause:%x\\n\",\n\t\t\t\tport, cause);\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&ch->ch_lock, lock_flags);\n\t\t\tif (cause == UART_17158_XON_DETECT) {\n\t\t\t\t \n\t\t\t\tif (brd->channels[port]->ch_flags & CH_STOP) {\n\t\t\t\t\tch->ch_flags &= ~(CH_STOP);\n\t\t\t\t}\n\t\t\t\tjsm_dbg(INTR, &ch->ch_bd->pci_dev,\n\t\t\t\t\t\"Port %d. XON detected in incoming data\\n\",\n\t\t\t\t\tport);\n\t\t\t}\n\t\t\telse if (cause == UART_17158_XOFF_DETECT) {\n\t\t\t\tif (!(brd->channels[port]->ch_flags & CH_STOP)) {\n\t\t\t\t\tch->ch_flags |= CH_STOP;\n\t\t\t\t\tjsm_dbg(INTR, &ch->ch_bd->pci_dev,\n\t\t\t\t\t\t\"Setting CH_STOP\\n\");\n\t\t\t\t}\n\t\t\t\tjsm_dbg(INTR, &ch->ch_bd->pci_dev,\n\t\t\t\t\t\"Port: %d. XOFF detected in incoming data\\n\",\n\t\t\t\t\tport);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n\t\t}\n\n\t\tif (isr & UART_17158_IIR_HWFLOW_STATE_CHANGE) {\n\t\t\t \n\t\t\tcause = readb(&ch->ch_neo_uart->mcr);\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&ch->ch_lock, lock_flags);\n\t\t\tif ((cause & 0x4) == 0) {\n\t\t\t\tif (cause & UART_MCR_RTS)\n\t\t\t\t\tch->ch_mostat |= UART_MCR_RTS;\n\t\t\t\telse\n\t\t\t\t\tch->ch_mostat &= ~(UART_MCR_RTS);\n\t\t\t} else {\n\t\t\t\tif (cause & UART_MCR_DTR)\n\t\t\t\t\tch->ch_mostat |= UART_MCR_DTR;\n\t\t\t\telse\n\t\t\t\t\tch->ch_mostat &= ~(UART_MCR_DTR);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n\t\t}\n\n\t\t \n\t\tjsm_dbg(INTR, &ch->ch_bd->pci_dev,\n\t\t\t\"MOD_STAT: sending to parse_modem_sigs\\n\");\n\t\tspin_lock_irqsave(&ch->uart_port.lock, lock_flags);\n\t\tneo_parse_modem(ch, readb(&ch->ch_neo_uart->msr));\n\t\tspin_unlock_irqrestore(&ch->uart_port.lock, lock_flags);\n\t}\n}\n\nstatic inline void neo_parse_lsr(struct jsm_board *brd, u32 port)\n{\n\tstruct jsm_channel *ch;\n\tint linestatus;\n\tunsigned long lock_flags;\n\n\tif (!brd)\n\t\treturn;\n\n\tif (port >= brd->maxports)\n\t\treturn;\n\n\tch = brd->channels[port];\n\tif (!ch)\n\t\treturn;\n\n\tlinestatus = readb(&ch->ch_neo_uart->lsr);\n\n\tjsm_dbg(INTR, &ch->ch_bd->pci_dev, \"%s:%d port: %d linestatus: %x\\n\",\n\t\t__FILE__, __LINE__, port, linestatus);\n\n\tch->ch_cached_lsr |= linestatus;\n\n\tif (ch->ch_cached_lsr & UART_LSR_DR) {\n\t\t \n\t\tneo_copy_data_from_uart_to_queue(ch);\n\t\tspin_lock_irqsave(&ch->ch_lock, lock_flags);\n\t\tjsm_check_queue_flow_control(ch);\n\t\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n\t}\n\n\t \n\tif (linestatus & UART_17158_RX_FIFO_DATA_ERROR)\n\t\tjsm_dbg(INTR, &ch->ch_bd->pci_dev,\n\t\t\t\"%s:%d Port: %d Got an RX error, need to parse LSR\\n\",\n\t\t\t__FILE__, __LINE__, port);\n\n\t \n\n\tif (linestatus & UART_LSR_PE) {\n\t\tch->ch_err_parity++;\n\t\tjsm_dbg(INTR, &ch->ch_bd->pci_dev, \"%s:%d Port: %d. PAR ERR!\\n\",\n\t\t\t__FILE__, __LINE__, port);\n\t}\n\n\tif (linestatus & UART_LSR_FE) {\n\t\tch->ch_err_frame++;\n\t\tjsm_dbg(INTR, &ch->ch_bd->pci_dev, \"%s:%d Port: %d. FRM ERR!\\n\",\n\t\t\t__FILE__, __LINE__, port);\n\t}\n\n\tif (linestatus & UART_LSR_BI) {\n\t\tch->ch_err_break++;\n\t\tjsm_dbg(INTR, &ch->ch_bd->pci_dev,\n\t\t\t\"%s:%d Port: %d. BRK INTR!\\n\",\n\t\t\t__FILE__, __LINE__, port);\n\t}\n\n\tif (linestatus & UART_LSR_OE) {\n\t\t \n\t\tch->ch_err_overrun++;\n\t\tjsm_dbg(INTR, &ch->ch_bd->pci_dev,\n\t\t\t\"%s:%d Port: %d. Rx Overrun!\\n\",\n\t\t\t__FILE__, __LINE__, port);\n\t}\n\n\tif (linestatus & UART_LSR_THRE) {\n\t\tspin_lock_irqsave(&ch->ch_lock, lock_flags);\n\t\tch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\n\t\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n\n\t\t \n\t\tneo_copy_data_from_queue_to_uart(ch);\n\t}\n\telse if (linestatus & UART_17158_TX_AND_FIFO_CLR) {\n\t\tspin_lock_irqsave(&ch->ch_lock, lock_flags);\n\t\tch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\n\t\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\n\n\t\t \n\t\tneo_copy_data_from_queue_to_uart(ch);\n\t}\n}\n\n \nstatic void neo_param(struct jsm_channel *ch)\n{\n\tu8 lcr = 0;\n\tu8 uart_lcr, ier;\n\tu32 baud;\n\tint quot;\n\tstruct jsm_board *bd;\n\n\tbd = ch->ch_bd;\n\tif (!bd)\n\t\treturn;\n\n\t \n\tif ((ch->ch_c_cflag & CBAUD) == B0) {\n\t\tch->ch_r_head = ch->ch_r_tail = 0;\n\t\tch->ch_e_head = ch->ch_e_tail = 0;\n\n\t\tneo_flush_uart_write(ch);\n\t\tneo_flush_uart_read(ch);\n\n\t\tch->ch_flags |= (CH_BAUD0);\n\t\tch->ch_mostat &= ~(UART_MCR_RTS | UART_MCR_DTR);\n\t\tneo_assert_modem_signals(ch);\n\t\treturn;\n\n\t} else {\n\t\tint i;\n\t\tunsigned int cflag;\n\t\tstatic struct {\n\t\t\tunsigned int rate;\n\t\t\tunsigned int cflag;\n\t\t} baud_rates[] = {\n\t\t\t{ 921600, B921600 },\n\t\t\t{ 460800, B460800 },\n\t\t\t{ 230400, B230400 },\n\t\t\t{ 115200, B115200 },\n\t\t\t{  57600, B57600  },\n\t\t\t{  38400, B38400  },\n\t\t\t{  19200, B19200  },\n\t\t\t{   9600, B9600   },\n\t\t\t{   4800, B4800   },\n\t\t\t{   2400, B2400   },\n\t\t\t{   1200, B1200   },\n\t\t\t{    600, B600    },\n\t\t\t{    300, B300    },\n\t\t\t{    200, B200    },\n\t\t\t{    150, B150    },\n\t\t\t{    134, B134    },\n\t\t\t{    110, B110    },\n\t\t\t{     75, B75     },\n\t\t\t{     50, B50     },\n\t\t};\n\n\t\tcflag = C_BAUD(ch->uart_port.state->port.tty);\n\t\tbaud = 9600;\n\t\tfor (i = 0; i < ARRAY_SIZE(baud_rates); i++) {\n\t\t\tif (baud_rates[i].cflag == cflag) {\n\t\t\t\tbaud = baud_rates[i].rate;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ch->ch_flags & CH_BAUD0)\n\t\t\tch->ch_flags &= ~(CH_BAUD0);\n\t}\n\n\tif (ch->ch_c_cflag & PARENB)\n\t\tlcr |= UART_LCR_PARITY;\n\n\tif (!(ch->ch_c_cflag & PARODD))\n\t\tlcr |= UART_LCR_EPAR;\n\n\tif (ch->ch_c_cflag & CMSPAR)\n\t\tlcr |= UART_LCR_SPAR;\n\n\tif (ch->ch_c_cflag & CSTOPB)\n\t\tlcr |= UART_LCR_STOP;\n\n\tlcr |= UART_LCR_WLEN(tty_get_char_size(ch->ch_c_cflag));\n\n\tier = readb(&ch->ch_neo_uart->ier);\n\tuart_lcr = readb(&ch->ch_neo_uart->lcr);\n\n\tquot = ch->ch_bd->bd_dividend / baud;\n\n\tif (quot != 0) {\n\t\twriteb(UART_LCR_DLAB, &ch->ch_neo_uart->lcr);\n\t\twriteb((quot & 0xff), &ch->ch_neo_uart->txrx);\n\t\twriteb((quot >> 8), &ch->ch_neo_uart->ier);\n\t\twriteb(lcr, &ch->ch_neo_uart->lcr);\n\t}\n\n\tif (uart_lcr != lcr)\n\t\twriteb(lcr, &ch->ch_neo_uart->lcr);\n\n\tif (ch->ch_c_cflag & CREAD)\n\t\tier |= (UART_IER_RDI | UART_IER_RLSI);\n\n\tier |= (UART_IER_THRI | UART_IER_MSI);\n\n\twriteb(ier, &ch->ch_neo_uart->ier);\n\n\t \n\tneo_set_new_start_stop_chars(ch);\n\n\tif (ch->ch_c_cflag & CRTSCTS)\n\t\tneo_set_cts_flow_control(ch);\n\telse if (ch->ch_c_iflag & IXON) {\n\t\t \n\t\tif ((ch->ch_startc == __DISABLED_CHAR) || (ch->ch_stopc == __DISABLED_CHAR))\n\t\t\tneo_set_no_output_flow_control(ch);\n\t\telse\n\t\t\tneo_set_ixon_flow_control(ch);\n\t}\n\telse\n\t\tneo_set_no_output_flow_control(ch);\n\n\tif (ch->ch_c_cflag & CRTSCTS)\n\t\tneo_set_rts_flow_control(ch);\n\telse if (ch->ch_c_iflag & IXOFF) {\n\t\t \n\t\tif ((ch->ch_startc == __DISABLED_CHAR) || (ch->ch_stopc == __DISABLED_CHAR))\n\t\t\tneo_set_no_input_flow_control(ch);\n\t\telse\n\t\t\tneo_set_ixoff_flow_control(ch);\n\t}\n\telse\n\t\tneo_set_no_input_flow_control(ch);\n\t \n\tif (baud < 9600) {\n\t\twriteb(1, &ch->ch_neo_uart->rfifo);\n\t\tch->ch_r_tlevel = 1;\n\t}\n\n\tneo_assert_modem_signals(ch);\n\n\t \n\tneo_parse_modem(ch, readb(&ch->ch_neo_uart->msr));\n\treturn;\n}\n\n \nstatic irqreturn_t neo_intr(int irq, void *voidbrd)\n{\n\tstruct jsm_board *brd = voidbrd;\n\tstruct jsm_channel *ch;\n\tint port = 0;\n\tint type = 0;\n\tint current_port;\n\tu32 tmp;\n\tu32 uart_poll;\n\tunsigned long lock_flags;\n\tunsigned long lock_flags2;\n\tint outofloop_count = 0;\n\n\t \n\tspin_lock_irqsave(&brd->bd_intr_lock, lock_flags);\n\n\t \n\tuart_poll = readl(brd->re_map_membase + UART_17158_POLL_ADDR_OFFSET);\n\n\tjsm_dbg(INTR, &brd->pci_dev, \"%s:%d uart_poll: %x\\n\",\n\t\t__FILE__, __LINE__, uart_poll);\n\n\tif (!uart_poll) {\n\t\tjsm_dbg(INTR, &brd->pci_dev,\n\t\t\t\"Kernel interrupted to me, but no pending interrupts...\\n\");\n\t\tspin_unlock_irqrestore(&brd->bd_intr_lock, lock_flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\n\tcurrent_port = 0;\n\n\t \n\twhile (((uart_poll & 0xff) != 0) && (outofloop_count < 0xff)){\n\n\t\ttmp = uart_poll;\n\t\toutofloop_count++;\n\n\t\t \n\t\tif ((tmp & jsm_offset_table[current_port]) != 0) {\n\t\t\tport = current_port;\n\t\t\ttype = tmp >> (8 + (port * 3));\n\t\t\ttype &= 0x7;\n\t\t} else {\n\t\t\tcurrent_port++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tjsm_dbg(INTR, &brd->pci_dev, \"%s:%d port: %x type: %x\\n\",\n\t\t\t__FILE__, __LINE__, port, type);\n\n\t\t \n\t\tuart_poll &= ~(jsm_offset_table[port]);\n\n\t\tif (!type) {\n\t\t\t \n\t\t\tjsm_dbg(INTR, &brd->pci_dev,\n\t\t\t\t\"Interrupt with no type! port: %d\\n\", port);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tswitch (type) {\n\n\t\tcase UART_17158_RXRDY_TIMEOUT:\n\t\t\t \n\n\t\t\t \n\t\t\tif (port >= brd->nasync)\n\t\t\t\tcontinue;\n\n\t\t\tch = brd->channels[port];\n\t\t\tif (!ch)\n\t\t\t\tcontinue;\n\n\t\t\tneo_copy_data_from_uart_to_queue(ch);\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&ch->ch_lock, lock_flags2);\n\t\t\tjsm_check_queue_flow_control(ch);\n\t\t\tspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\n\n\t\t\tcontinue;\n\n\t\tcase UART_17158_RX_LINE_STATUS:\n\t\t\t \n\t\t\tneo_parse_lsr(brd, port);\n\t\t\tcontinue;\n\n\t\tcase UART_17158_TXRDY:\n\t\t\t \n\n\t\t\t \n\t\t\tneo_parse_isr(brd, port);\n\t\t\tcontinue;\n\n\t\tcase UART_17158_MSR:\n\t\t\t \n\t\t\tneo_parse_isr(brd, port);\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\t \n\t\t\tjsm_dbg(INTR, &brd->pci_dev,\n\t\t\t\t\"%s:%d Unknown Interrupt type: %x\\n\",\n\t\t\t\t__FILE__, __LINE__, type);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&brd->bd_intr_lock, lock_flags);\n\n\tjsm_dbg(INTR, &brd->pci_dev, \"finish\\n\");\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void neo_disable_receiver(struct jsm_channel *ch)\n{\n\tu8 tmp = readb(&ch->ch_neo_uart->ier);\n\ttmp &= ~(UART_IER_RDI);\n\twriteb(tmp, &ch->ch_neo_uart->ier);\n\n\t \n\tneo_pci_posting_flush(ch->ch_bd);\n}\n\n\n \nstatic void neo_enable_receiver(struct jsm_channel *ch)\n{\n\tu8 tmp = readb(&ch->ch_neo_uart->ier);\n\ttmp |= (UART_IER_RDI);\n\twriteb(tmp, &ch->ch_neo_uart->ier);\n\n\t \n\tneo_pci_posting_flush(ch->ch_bd);\n}\n\nstatic void neo_send_start_character(struct jsm_channel *ch)\n{\n\tif (!ch)\n\t\treturn;\n\n\tif (ch->ch_startc != __DISABLED_CHAR) {\n\t\tch->ch_xon_sends++;\n\t\twriteb(ch->ch_startc, &ch->ch_neo_uart->txrx);\n\n\t\t \n\t\tneo_pci_posting_flush(ch->ch_bd);\n\t}\n}\n\nstatic void neo_send_stop_character(struct jsm_channel *ch)\n{\n\tif (!ch)\n\t\treturn;\n\n\tif (ch->ch_stopc != __DISABLED_CHAR) {\n\t\tch->ch_xoff_sends++;\n\t\twriteb(ch->ch_stopc, &ch->ch_neo_uart->txrx);\n\n\t\t \n\t\tneo_pci_posting_flush(ch->ch_bd);\n\t}\n}\n\n \nstatic void neo_uart_init(struct jsm_channel *ch)\n{\n\twriteb(0, &ch->ch_neo_uart->ier);\n\twriteb(0, &ch->ch_neo_uart->efr);\n\twriteb(UART_EFR_ECB, &ch->ch_neo_uart->efr);\n\n\t \n\treadb(&ch->ch_neo_uart->txrx);\n\twriteb((UART_FCR_ENABLE_FIFO|UART_FCR_CLEAR_RCVR|UART_FCR_CLEAR_XMIT), &ch->ch_neo_uart->isr_fcr);\n\treadb(&ch->ch_neo_uart->lsr);\n\treadb(&ch->ch_neo_uart->msr);\n\n\tch->ch_flags |= CH_FIFO_ENABLED;\n\n\t \n\twriteb(ch->ch_mostat, &ch->ch_neo_uart->mcr);\n}\n\n \nstatic void neo_uart_off(struct jsm_channel *ch)\n{\n\t \n\twriteb(0, &ch->ch_neo_uart->efr);\n\n\t \n\twriteb(0, &ch->ch_neo_uart->ier);\n}\n\nstatic u32 neo_get_uart_bytes_left(struct jsm_channel *ch)\n{\n\tu8 left = 0;\n\tu8 lsr = readb(&ch->ch_neo_uart->lsr);\n\n\t \n\tch->ch_cached_lsr |= lsr;\n\n\t \n\tif (!(lsr & UART_LSR_TEMT))\n\t\tleft = 1;\n\telse {\n\t\tch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\n\t\tleft = 0;\n\t}\n\n\treturn left;\n}\n\n \nstatic void neo_send_break(struct jsm_channel *ch)\n{\n\t \n\n\t \n\tif (!(ch->ch_flags & CH_BREAK_SENDING)) {\n\t\tu8 temp = readb(&ch->ch_neo_uart->lcr);\n\t\twriteb((temp | UART_LCR_SBC), &ch->ch_neo_uart->lcr);\n\t\tch->ch_flags |= (CH_BREAK_SENDING);\n\n\t\t \n\t\tneo_pci_posting_flush(ch->ch_bd);\n\t}\n}\n\n \nstatic void neo_send_immediate_char(struct jsm_channel *ch, unsigned char c)\n{\n\tif (!ch)\n\t\treturn;\n\n\twriteb(c, &ch->ch_neo_uart->txrx);\n\n\t \n\tneo_pci_posting_flush(ch->ch_bd);\n}\n\nstruct board_ops jsm_neo_ops = {\n\t.intr\t\t\t\t= neo_intr,\n\t.uart_init\t\t\t= neo_uart_init,\n\t.uart_off\t\t\t= neo_uart_off,\n\t.param\t\t\t\t= neo_param,\n\t.assert_modem_signals\t\t= neo_assert_modem_signals,\n\t.flush_uart_write\t\t= neo_flush_uart_write,\n\t.flush_uart_read\t\t= neo_flush_uart_read,\n\t.disable_receiver\t\t= neo_disable_receiver,\n\t.enable_receiver\t\t= neo_enable_receiver,\n\t.send_break\t\t\t= neo_send_break,\n\t.clear_break\t\t\t= neo_clear_break,\n\t.send_start_character\t\t= neo_send_start_character,\n\t.send_stop_character\t\t= neo_send_stop_character,\n\t.copy_data_from_queue_to_uart\t= neo_copy_data_from_queue_to_uart,\n\t.get_uart_bytes_left\t\t= neo_get_uart_bytes_left,\n\t.send_immediate_char\t\t= neo_send_immediate_char\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}