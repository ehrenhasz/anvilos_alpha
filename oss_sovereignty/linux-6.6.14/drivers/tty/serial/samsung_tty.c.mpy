{
  "module_name": "samsung_tty.c",
  "hash_id": "c1d59b5583e06e14d9ad38db6d4f6b52a6926599f680f98a36599a528e392f5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/samsung_tty.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/console.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/serial_s3c.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/cpufreq.h>\n#include <linux/of.h>\n#include <asm/irq.h>\n\n \n\n#define S3C24XX_SERIAL_NAME\t\"ttySAC\"\n#define S3C24XX_SERIAL_MAJOR\t204\n#define S3C24XX_SERIAL_MINOR\t64\n\n#ifdef CONFIG_ARM64\n#define UART_NR\t\t\t12\n#else\n#define UART_NR\t\t\tCONFIG_SERIAL_SAMSUNG_UARTS\n#endif\n\n#define S3C24XX_TX_PIO\t\t\t1\n#define S3C24XX_TX_DMA\t\t\t2\n#define S3C24XX_RX_PIO\t\t\t1\n#define S3C24XX_RX_DMA\t\t\t2\n\n \n#define RXSTAT_DUMMY_READ (0x10000000)\n\nenum s3c24xx_port_type {\n\tTYPE_S3C24XX,\n\tTYPE_S3C6400,\n\tTYPE_APPLE_S5L,\n};\n\nstruct s3c24xx_uart_info {\n\tconst char\t\t*name;\n\tenum s3c24xx_port_type\ttype;\n\tunsigned int\t\tport_type;\n\tunsigned int\t\tfifosize;\n\tunsigned long\t\trx_fifomask;\n\tunsigned long\t\trx_fifoshift;\n\tunsigned long\t\trx_fifofull;\n\tunsigned long\t\ttx_fifomask;\n\tunsigned long\t\ttx_fifoshift;\n\tunsigned long\t\ttx_fifofull;\n\tunsigned int\t\tdef_clk_sel;\n\tunsigned long\t\tnum_clks;\n\tunsigned long\t\tclksel_mask;\n\tunsigned long\t\tclksel_shift;\n\tunsigned long\t\tucon_mask;\n\n\t \n\n\tunsigned int\t\thas_divslot:1;\n};\n\nstruct s3c24xx_serial_drv_data {\n\tconst struct s3c24xx_uart_info\tinfo;\n\tconst struct s3c2410_uartcfg\tdef_cfg;\n\tconst unsigned int\t\tfifosize[UART_NR];\n};\n\nstruct s3c24xx_uart_dma {\n\tunsigned int\t\t\trx_chan_id;\n\tunsigned int\t\t\ttx_chan_id;\n\n\tstruct dma_slave_config\t\trx_conf;\n\tstruct dma_slave_config\t\ttx_conf;\n\n\tstruct dma_chan\t\t\t*rx_chan;\n\tstruct dma_chan\t\t\t*tx_chan;\n\n\tdma_addr_t\t\t\trx_addr;\n\tdma_addr_t\t\t\ttx_addr;\n\n\tdma_cookie_t\t\t\trx_cookie;\n\tdma_cookie_t\t\t\ttx_cookie;\n\n\tchar\t\t\t\t*rx_buf;\n\n\tdma_addr_t\t\t\ttx_transfer_addr;\n\n\tsize_t\t\t\t\trx_size;\n\tsize_t\t\t\t\ttx_size;\n\n\tstruct dma_async_tx_descriptor\t*tx_desc;\n\tstruct dma_async_tx_descriptor\t*rx_desc;\n\n\tint\t\t\t\ttx_bytes_requested;\n\tint\t\t\t\trx_bytes_requested;\n};\n\nstruct s3c24xx_uart_port {\n\tunsigned char\t\t\trx_claimed;\n\tunsigned char\t\t\ttx_claimed;\n\tunsigned char\t\t\trx_enabled;\n\tunsigned char\t\t\ttx_enabled;\n\tunsigned int\t\t\tpm_level;\n\tunsigned long\t\t\tbaudclk_rate;\n\tunsigned int\t\t\tmin_dma_size;\n\n\tunsigned int\t\t\trx_irq;\n\tunsigned int\t\t\ttx_irq;\n\n\tunsigned int\t\t\ttx_in_progress;\n\tunsigned int\t\t\ttx_mode;\n\tunsigned int\t\t\trx_mode;\n\n\tconst struct s3c24xx_uart_info\t*info;\n\tstruct clk\t\t\t*clk;\n\tstruct clk\t\t\t*baudclk;\n\tstruct uart_port\t\tport;\n\tconst struct s3c24xx_serial_drv_data\t*drv_data;\n\n\t \n\tconst struct s3c2410_uartcfg\t*cfg;\n\n\tstruct s3c24xx_uart_dma\t\t*dma;\n};\n\nstatic void s3c24xx_serial_tx_chars(struct s3c24xx_uart_port *ourport);\n\n \n\n#define s3c24xx_dev_to_port(__dev) dev_get_drvdata(__dev)\n\n \n\n#define portaddr(port, reg) ((port)->membase + (reg))\n#define portaddrl(port, reg) \\\n\t((unsigned long *)(unsigned long)((port)->membase + (reg)))\n\nstatic u32 rd_reg(const struct uart_port *port, u32 reg)\n{\n\tswitch (port->iotype) {\n\tcase UPIO_MEM:\n\t\treturn readb_relaxed(portaddr(port, reg));\n\tcase UPIO_MEM32:\n\t\treturn readl_relaxed(portaddr(port, reg));\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n#define rd_regl(port, reg) (readl_relaxed(portaddr(port, reg)))\n\nstatic void wr_reg(const struct uart_port *port, u32 reg, u32 val)\n{\n\tswitch (port->iotype) {\n\tcase UPIO_MEM:\n\t\twriteb_relaxed(val, portaddr(port, reg));\n\t\tbreak;\n\tcase UPIO_MEM32:\n\t\twritel_relaxed(val, portaddr(port, reg));\n\t\tbreak;\n\t}\n}\n\n#define wr_regl(port, reg, val) writel_relaxed(val, portaddr(port, reg))\n\n \n\nstatic inline void s3c24xx_set_bit(const struct uart_port *port, int idx,\n\t\t\t\t   unsigned int reg)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tlocal_irq_save(flags);\n\tval = rd_regl(port, reg);\n\tval |= (1 << idx);\n\twr_regl(port, reg, val);\n\tlocal_irq_restore(flags);\n}\n\nstatic inline void s3c24xx_clear_bit(const struct uart_port *port, int idx,\n\t\t\t\t     unsigned int reg)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tlocal_irq_save(flags);\n\tval = rd_regl(port, reg);\n\tval &= ~(1 << idx);\n\twr_regl(port, reg, val);\n\tlocal_irq_restore(flags);\n}\n\nstatic inline struct s3c24xx_uart_port *to_ourport(struct uart_port *port)\n{\n\treturn container_of(port, struct s3c24xx_uart_port, port);\n}\n\n \n\nstatic inline const char *s3c24xx_serial_portname(const struct uart_port *port)\n{\n\treturn to_platform_device(port->dev)->name;\n}\n\nstatic int s3c24xx_serial_txempty_nofifo(const struct uart_port *port)\n{\n\treturn rd_regl(port, S3C2410_UTRSTAT) & S3C2410_UTRSTAT_TXE;\n}\n\nstatic void s3c24xx_serial_rx_enable(struct uart_port *port)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\tunsigned long flags;\n\tunsigned int ucon, ufcon;\n\tint count = 10000;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\twhile (--count && !s3c24xx_serial_txempty_nofifo(port))\n\t\tudelay(100);\n\n\tufcon = rd_regl(port, S3C2410_UFCON);\n\tufcon |= S3C2410_UFCON_RESETRX;\n\twr_regl(port, S3C2410_UFCON, ufcon);\n\n\tucon = rd_regl(port, S3C2410_UCON);\n\tucon |= S3C2410_UCON_RXIRQMODE;\n\twr_regl(port, S3C2410_UCON, ucon);\n\n\tourport->rx_enabled = 1;\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void s3c24xx_serial_rx_disable(struct uart_port *port)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\tunsigned long flags;\n\tunsigned int ucon;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tucon = rd_regl(port, S3C2410_UCON);\n\tucon &= ~S3C2410_UCON_RXIRQMODE;\n\twr_regl(port, S3C2410_UCON, ucon);\n\n\tourport->rx_enabled = 0;\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void s3c24xx_serial_stop_tx(struct uart_port *port)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\tstruct s3c24xx_uart_dma *dma = ourport->dma;\n\tstruct dma_tx_state state;\n\tint count;\n\n\tif (!ourport->tx_enabled)\n\t\treturn;\n\n\tswitch (ourport->info->type) {\n\tcase TYPE_S3C6400:\n\t\ts3c24xx_set_bit(port, S3C64XX_UINTM_TXD, S3C64XX_UINTM);\n\t\tbreak;\n\tcase TYPE_APPLE_S5L:\n\t\ts3c24xx_clear_bit(port, APPLE_S5L_UCON_TXTHRESH_ENA, S3C2410_UCON);\n\t\tbreak;\n\tdefault:\n\t\tdisable_irq_nosync(ourport->tx_irq);\n\t\tbreak;\n\t}\n\n\tif (dma && dma->tx_chan && ourport->tx_in_progress == S3C24XX_TX_DMA) {\n\t\tdmaengine_pause(dma->tx_chan);\n\t\tdmaengine_tx_status(dma->tx_chan, dma->tx_cookie, &state);\n\t\tdmaengine_terminate_all(dma->tx_chan);\n\t\tdma_sync_single_for_cpu(dma->tx_chan->device->dev,\n\t\t\t\t\tdma->tx_transfer_addr, dma->tx_size,\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\tasync_tx_ack(dma->tx_desc);\n\t\tcount = dma->tx_bytes_requested - state.residue;\n\t\tuart_xmit_advance(port, count);\n\t}\n\n\tourport->tx_enabled = 0;\n\tourport->tx_in_progress = 0;\n\n\tif (port->flags & UPF_CONS_FLOW)\n\t\ts3c24xx_serial_rx_enable(port);\n\n\tourport->tx_mode = 0;\n}\n\nstatic void s3c24xx_serial_start_next_tx(struct s3c24xx_uart_port *ourport);\n\nstatic void s3c24xx_serial_tx_dma_complete(void *args)\n{\n\tstruct s3c24xx_uart_port *ourport = args;\n\tstruct uart_port *port = &ourport->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tstruct s3c24xx_uart_dma *dma = ourport->dma;\n\tstruct dma_tx_state state;\n\tunsigned long flags;\n\tint count;\n\n\tdmaengine_tx_status(dma->tx_chan, dma->tx_cookie, &state);\n\tcount = dma->tx_bytes_requested - state.residue;\n\tasync_tx_ack(dma->tx_desc);\n\n\tdma_sync_single_for_cpu(dma->tx_chan->device->dev,\n\t\t\t\tdma->tx_transfer_addr, dma->tx_size,\n\t\t\t\tDMA_TO_DEVICE);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tuart_xmit_advance(port, count);\n\tourport->tx_in_progress = 0;\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\ts3c24xx_serial_start_next_tx(ourport);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void enable_tx_dma(struct s3c24xx_uart_port *ourport)\n{\n\tconst struct uart_port *port = &ourport->port;\n\tu32 ucon;\n\n\t \n\tswitch (ourport->info->type) {\n\tcase TYPE_S3C6400:\n\t\ts3c24xx_set_bit(port, S3C64XX_UINTM_TXD, S3C64XX_UINTM);\n\t\tbreak;\n\tcase TYPE_APPLE_S5L:\n\t\tWARN_ON(1); \n\t\tbreak;\n\tdefault:\n\t\tdisable_irq_nosync(ourport->tx_irq);\n\t\tbreak;\n\t}\n\n\t \n\tucon = rd_regl(port, S3C2410_UCON);\n\tucon &= ~(S3C64XX_UCON_TXBURST_MASK | S3C64XX_UCON_TXMODE_MASK);\n\tucon |= S3C64XX_UCON_TXBURST_1;\n\tucon |= S3C64XX_UCON_TXMODE_DMA;\n\twr_regl(port,  S3C2410_UCON, ucon);\n\n\tourport->tx_mode = S3C24XX_TX_DMA;\n}\n\nstatic void enable_tx_pio(struct s3c24xx_uart_port *ourport)\n{\n\tconst struct uart_port *port = &ourport->port;\n\tu32 ucon, ufcon;\n\n\t \n\tourport->tx_in_progress = S3C24XX_TX_PIO;\n\tufcon = rd_regl(port, S3C2410_UFCON);\n\twr_regl(port,  S3C2410_UFCON, ufcon);\n\n\t \n\tucon = rd_regl(port, S3C2410_UCON);\n\tucon &= ~(S3C64XX_UCON_TXMODE_MASK);\n\tucon |= S3C64XX_UCON_TXMODE_CPU;\n\twr_regl(port,  S3C2410_UCON, ucon);\n\n\t \n\tswitch (ourport->info->type) {\n\tcase TYPE_S3C6400:\n\t\ts3c24xx_clear_bit(port, S3C64XX_UINTM_TXD,\n\t\t\t\t  S3C64XX_UINTM);\n\t\tbreak;\n\tcase TYPE_APPLE_S5L:\n\t\tucon |= APPLE_S5L_UCON_TXTHRESH_ENA_MSK;\n\t\twr_regl(port, S3C2410_UCON, ucon);\n\t\tbreak;\n\tdefault:\n\t\tenable_irq(ourport->tx_irq);\n\t\tbreak;\n\t}\n\n\tourport->tx_mode = S3C24XX_TX_PIO;\n\n\t \n\tif (ourport->info->type == TYPE_APPLE_S5L)\n\t\ts3c24xx_serial_tx_chars(ourport);\n}\n\nstatic void s3c24xx_serial_start_tx_pio(struct s3c24xx_uart_port *ourport)\n{\n\tif (ourport->tx_mode != S3C24XX_TX_PIO)\n\t\tenable_tx_pio(ourport);\n}\n\nstatic int s3c24xx_serial_start_tx_dma(struct s3c24xx_uart_port *ourport,\n\t\t\t\t      unsigned int count)\n{\n\tstruct uart_port *port = &ourport->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tstruct s3c24xx_uart_dma *dma = ourport->dma;\n\n\tif (ourport->tx_mode != S3C24XX_TX_DMA)\n\t\tenable_tx_dma(ourport);\n\n\tdma->tx_size = count & ~(dma_get_cache_alignment() - 1);\n\tdma->tx_transfer_addr = dma->tx_addr + xmit->tail;\n\n\tdma_sync_single_for_device(dma->tx_chan->device->dev,\n\t\t\t\t   dma->tx_transfer_addr, dma->tx_size,\n\t\t\t\t   DMA_TO_DEVICE);\n\n\tdma->tx_desc = dmaengine_prep_slave_single(dma->tx_chan,\n\t\t\t\tdma->tx_transfer_addr, dma->tx_size,\n\t\t\t\tDMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);\n\tif (!dma->tx_desc) {\n\t\tdev_err(ourport->port.dev, \"Unable to get desc for Tx\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdma->tx_desc->callback = s3c24xx_serial_tx_dma_complete;\n\tdma->tx_desc->callback_param = ourport;\n\tdma->tx_bytes_requested = dma->tx_size;\n\n\tourport->tx_in_progress = S3C24XX_TX_DMA;\n\tdma->tx_cookie = dmaengine_submit(dma->tx_desc);\n\tdma_async_issue_pending(dma->tx_chan);\n\treturn 0;\n}\n\nstatic void s3c24xx_serial_start_next_tx(struct s3c24xx_uart_port *ourport)\n{\n\tstruct uart_port *port = &ourport->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned long count;\n\n\t \n\tcount = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\n\tif (!count) {\n\t\ts3c24xx_serial_stop_tx(port);\n\t\treturn;\n\t}\n\n\tif (!ourport->dma || !ourport->dma->tx_chan ||\n\t    count < ourport->min_dma_size ||\n\t    xmit->tail & (dma_get_cache_alignment() - 1))\n\t\ts3c24xx_serial_start_tx_pio(ourport);\n\telse\n\t\ts3c24xx_serial_start_tx_dma(ourport, count);\n}\n\nstatic void s3c24xx_serial_start_tx(struct uart_port *port)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\tif (!ourport->tx_enabled) {\n\t\tif (port->flags & UPF_CONS_FLOW)\n\t\t\ts3c24xx_serial_rx_disable(port);\n\n\t\tourport->tx_enabled = 1;\n\t\tif (!ourport->dma || !ourport->dma->tx_chan)\n\t\t\ts3c24xx_serial_start_tx_pio(ourport);\n\t}\n\n\tif (ourport->dma && ourport->dma->tx_chan) {\n\t\tif (!uart_circ_empty(xmit) && !ourport->tx_in_progress)\n\t\t\ts3c24xx_serial_start_next_tx(ourport);\n\t}\n}\n\nstatic void s3c24xx_uart_copy_rx_to_tty(struct s3c24xx_uart_port *ourport,\n\t\tstruct tty_port *tty, int count)\n{\n\tstruct s3c24xx_uart_dma *dma = ourport->dma;\n\tint copied;\n\n\tif (!count)\n\t\treturn;\n\n\tdma_sync_single_for_cpu(dma->rx_chan->device->dev, dma->rx_addr,\n\t\t\t\tdma->rx_size, DMA_FROM_DEVICE);\n\n\tourport->port.icount.rx += count;\n\tif (!tty) {\n\t\tdev_err(ourport->port.dev, \"No tty port\\n\");\n\t\treturn;\n\t}\n\tcopied = tty_insert_flip_string(tty,\n\t\t\t((unsigned char *)(ourport->dma->rx_buf)), count);\n\tif (copied != count) {\n\t\tWARN_ON(1);\n\t\tdev_err(ourport->port.dev, \"RxData copy to tty layer failed\\n\");\n\t}\n}\n\nstatic void s3c24xx_serial_stop_rx(struct uart_port *port)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\tstruct s3c24xx_uart_dma *dma = ourport->dma;\n\tstruct tty_port *t = &port->state->port;\n\tstruct dma_tx_state state;\n\tenum dma_status dma_status;\n\tunsigned int received;\n\n\tif (ourport->rx_enabled) {\n\t\tdev_dbg(port->dev, \"stopping rx\\n\");\n\t\tswitch (ourport->info->type) {\n\t\tcase TYPE_S3C6400:\n\t\t\ts3c24xx_set_bit(port, S3C64XX_UINTM_RXD,\n\t\t\t\t\tS3C64XX_UINTM);\n\t\t\tbreak;\n\t\tcase TYPE_APPLE_S5L:\n\t\t\ts3c24xx_clear_bit(port, APPLE_S5L_UCON_RXTHRESH_ENA, S3C2410_UCON);\n\t\t\ts3c24xx_clear_bit(port, APPLE_S5L_UCON_RXTO_ENA, S3C2410_UCON);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdisable_irq_nosync(ourport->rx_irq);\n\t\t\tbreak;\n\t\t}\n\t\tourport->rx_enabled = 0;\n\t}\n\tif (dma && dma->rx_chan) {\n\t\tdmaengine_pause(dma->tx_chan);\n\t\tdma_status = dmaengine_tx_status(dma->rx_chan,\n\t\t\t\tdma->rx_cookie, &state);\n\t\tif (dma_status == DMA_IN_PROGRESS ||\n\t\t\tdma_status == DMA_PAUSED) {\n\t\t\treceived = dma->rx_bytes_requested - state.residue;\n\t\t\tdmaengine_terminate_all(dma->rx_chan);\n\t\t\ts3c24xx_uart_copy_rx_to_tty(ourport, t, received);\n\t\t}\n\t}\n}\n\nstatic inline const struct s3c24xx_uart_info\n\t*s3c24xx_port_to_info(struct uart_port *port)\n{\n\treturn to_ourport(port)->info;\n}\n\nstatic inline const struct s3c2410_uartcfg\n\t*s3c24xx_port_to_cfg(const struct uart_port *port)\n{\n\tconst struct s3c24xx_uart_port *ourport;\n\n\tif (port->dev == NULL)\n\t\treturn NULL;\n\n\tourport = container_of(port, struct s3c24xx_uart_port, port);\n\treturn ourport->cfg;\n}\n\nstatic int s3c24xx_serial_rx_fifocnt(const struct s3c24xx_uart_port *ourport,\n\t\t\t\t     unsigned long ufstat)\n{\n\tconst struct s3c24xx_uart_info *info = ourport->info;\n\n\tif (ufstat & info->rx_fifofull)\n\t\treturn ourport->port.fifosize;\n\n\treturn (ufstat & info->rx_fifomask) >> info->rx_fifoshift;\n}\n\nstatic void s3c64xx_start_rx_dma(struct s3c24xx_uart_port *ourport);\nstatic void s3c24xx_serial_rx_dma_complete(void *args)\n{\n\tstruct s3c24xx_uart_port *ourport = args;\n\tstruct uart_port *port = &ourport->port;\n\n\tstruct s3c24xx_uart_dma *dma = ourport->dma;\n\tstruct tty_port *t = &port->state->port;\n\tstruct tty_struct *tty = tty_port_tty_get(&ourport->port.state->port);\n\n\tstruct dma_tx_state state;\n\tunsigned long flags;\n\tint received;\n\n\tdmaengine_tx_status(dma->rx_chan,  dma->rx_cookie, &state);\n\treceived  = dma->rx_bytes_requested - state.residue;\n\tasync_tx_ack(dma->rx_desc);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (received)\n\t\ts3c24xx_uart_copy_rx_to_tty(ourport, t, received);\n\n\tif (tty) {\n\t\ttty_flip_buffer_push(t);\n\t\ttty_kref_put(tty);\n\t}\n\n\ts3c64xx_start_rx_dma(ourport);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void s3c64xx_start_rx_dma(struct s3c24xx_uart_port *ourport)\n{\n\tstruct s3c24xx_uart_dma *dma = ourport->dma;\n\n\tdma_sync_single_for_device(dma->rx_chan->device->dev, dma->rx_addr,\n\t\t\t\t   dma->rx_size, DMA_FROM_DEVICE);\n\n\tdma->rx_desc = dmaengine_prep_slave_single(dma->rx_chan,\n\t\t\t\tdma->rx_addr, dma->rx_size, DMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT);\n\tif (!dma->rx_desc) {\n\t\tdev_err(ourport->port.dev, \"Unable to get desc for Rx\\n\");\n\t\treturn;\n\t}\n\n\tdma->rx_desc->callback = s3c24xx_serial_rx_dma_complete;\n\tdma->rx_desc->callback_param = ourport;\n\tdma->rx_bytes_requested = dma->rx_size;\n\n\tdma->rx_cookie = dmaengine_submit(dma->rx_desc);\n\tdma_async_issue_pending(dma->rx_chan);\n}\n\n \n#define S3C2410_UERSTAT_PARITY (0x1000)\n\nstatic void enable_rx_dma(struct s3c24xx_uart_port *ourport)\n{\n\tstruct uart_port *port = &ourport->port;\n\tunsigned int ucon;\n\n\t \n\tucon = rd_regl(port, S3C2410_UCON);\n\tucon &= ~(S3C64XX_UCON_RXBURST_MASK |\n\t\t\tS3C64XX_UCON_TIMEOUT_MASK |\n\t\t\tS3C64XX_UCON_EMPTYINT_EN |\n\t\t\tS3C64XX_UCON_DMASUS_EN |\n\t\t\tS3C64XX_UCON_TIMEOUT_EN |\n\t\t\tS3C64XX_UCON_RXMODE_MASK);\n\tucon |= S3C64XX_UCON_RXBURST_1 |\n\t\t\t0xf << S3C64XX_UCON_TIMEOUT_SHIFT |\n\t\t\tS3C64XX_UCON_EMPTYINT_EN |\n\t\t\tS3C64XX_UCON_TIMEOUT_EN |\n\t\t\tS3C64XX_UCON_RXMODE_DMA;\n\twr_regl(port, S3C2410_UCON, ucon);\n\n\tourport->rx_mode = S3C24XX_RX_DMA;\n}\n\nstatic void enable_rx_pio(struct s3c24xx_uart_port *ourport)\n{\n\tstruct uart_port *port = &ourport->port;\n\tunsigned int ucon;\n\n\t \n\tucon = rd_regl(port, S3C2410_UCON);\n\tucon &= ~S3C64XX_UCON_RXMODE_MASK;\n\tucon |= S3C64XX_UCON_RXMODE_CPU;\n\n\t \n\tif (ourport->info->type != TYPE_APPLE_S5L) {\n\t\tucon &= ~(S3C64XX_UCON_TIMEOUT_MASK |\n\t\t\t\tS3C64XX_UCON_EMPTYINT_EN |\n\t\t\t\tS3C64XX_UCON_DMASUS_EN |\n\t\t\t\tS3C64XX_UCON_TIMEOUT_EN);\n\t\tucon |= 0xf << S3C64XX_UCON_TIMEOUT_SHIFT |\n\t\t\t\tS3C64XX_UCON_TIMEOUT_EN;\n\t}\n\twr_regl(port, S3C2410_UCON, ucon);\n\n\tourport->rx_mode = S3C24XX_RX_PIO;\n}\n\nstatic void s3c24xx_serial_rx_drain_fifo(struct s3c24xx_uart_port *ourport);\n\nstatic irqreturn_t s3c24xx_serial_rx_chars_dma(void *dev_id)\n{\n\tunsigned int utrstat, received;\n\tstruct s3c24xx_uart_port *ourport = dev_id;\n\tstruct uart_port *port = &ourport->port;\n\tstruct s3c24xx_uart_dma *dma = ourport->dma;\n\tstruct tty_struct *tty = tty_port_tty_get(&ourport->port.state->port);\n\tstruct tty_port *t = &port->state->port;\n\tstruct dma_tx_state state;\n\n\tutrstat = rd_regl(port, S3C2410_UTRSTAT);\n\trd_regl(port, S3C2410_UFSTAT);\n\n\tspin_lock(&port->lock);\n\n\tif (!(utrstat & S3C2410_UTRSTAT_TIMEOUT)) {\n\t\ts3c64xx_start_rx_dma(ourport);\n\t\tif (ourport->rx_mode == S3C24XX_RX_PIO)\n\t\t\tenable_rx_dma(ourport);\n\t\tgoto finish;\n\t}\n\n\tif (ourport->rx_mode == S3C24XX_RX_DMA) {\n\t\tdmaengine_pause(dma->rx_chan);\n\t\tdmaengine_tx_status(dma->rx_chan, dma->rx_cookie, &state);\n\t\tdmaengine_terminate_all(dma->rx_chan);\n\t\treceived = dma->rx_bytes_requested - state.residue;\n\t\ts3c24xx_uart_copy_rx_to_tty(ourport, t, received);\n\n\t\tenable_rx_pio(ourport);\n\t}\n\n\ts3c24xx_serial_rx_drain_fifo(ourport);\n\n\tif (tty) {\n\t\ttty_flip_buffer_push(t);\n\t\ttty_kref_put(tty);\n\t}\n\n\twr_regl(port, S3C2410_UTRSTAT, S3C2410_UTRSTAT_TIMEOUT);\n\nfinish:\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void s3c24xx_serial_rx_drain_fifo(struct s3c24xx_uart_port *ourport)\n{\n\tstruct uart_port *port = &ourport->port;\n\tunsigned int ufcon, ufstat, uerstat;\n\tunsigned int fifocnt = 0;\n\tint max_count = port->fifosize;\n\tu8 ch, flag;\n\n\twhile (max_count-- > 0) {\n\t\t \n\t\tif (fifocnt == 0) {\n\t\t\tufstat = rd_regl(port, S3C2410_UFSTAT);\n\t\t\tfifocnt = s3c24xx_serial_rx_fifocnt(ourport, ufstat);\n\t\t\tif (fifocnt == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tfifocnt--;\n\n\t\tuerstat = rd_regl(port, S3C2410_UERSTAT);\n\t\tch = rd_reg(port, S3C2410_URXH);\n\n\t\tif (port->flags & UPF_CONS_FLOW) {\n\t\t\tint txe = s3c24xx_serial_txempty_nofifo(port);\n\n\t\t\tif (ourport->rx_enabled) {\n\t\t\t\tif (!txe) {\n\t\t\t\t\tourport->rx_enabled = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (txe) {\n\t\t\t\t\tufcon = rd_regl(port, S3C2410_UFCON);\n\t\t\t\t\tufcon |= S3C2410_UFCON_RESETRX;\n\t\t\t\t\twr_regl(port, S3C2410_UFCON, ufcon);\n\t\t\t\t\tourport->rx_enabled = 1;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tflag = TTY_NORMAL;\n\t\tport->icount.rx++;\n\n\t\tif (unlikely(uerstat & S3C2410_UERSTAT_ANY)) {\n\t\t\tdev_dbg(port->dev,\n\t\t\t\t\"rxerr: port ch=0x%02x, rxs=0x%08x\\n\",\n\t\t\t\tch, uerstat);\n\n\t\t\t \n\t\t\tif (uerstat & S3C2410_UERSTAT_BREAK) {\n\t\t\t\tdev_dbg(port->dev, \"break!\\n\");\n\t\t\t\tport->icount.brk++;\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tcontinue;  \n\t\t\t}\n\n\t\t\tif (uerstat & S3C2410_UERSTAT_FRAME)\n\t\t\t\tport->icount.frame++;\n\t\t\tif (uerstat & S3C2410_UERSTAT_OVERRUN)\n\t\t\t\tport->icount.overrun++;\n\n\t\t\tuerstat &= port->read_status_mask;\n\n\t\t\tif (uerstat & S3C2410_UERSTAT_BREAK)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (uerstat & S3C2410_UERSTAT_PARITY)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (uerstat & (S3C2410_UERSTAT_FRAME |\n\t\t\t\t\t    S3C2410_UERSTAT_OVERRUN))\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tcontinue;  \n\n\t\tuart_insert_char(port, uerstat, S3C2410_UERSTAT_OVERRUN,\n\t\t\t\t ch, flag);\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic irqreturn_t s3c24xx_serial_rx_chars_pio(void *dev_id)\n{\n\tstruct s3c24xx_uart_port *ourport = dev_id;\n\tstruct uart_port *port = &ourport->port;\n\n\tspin_lock(&port->lock);\n\ts3c24xx_serial_rx_drain_fifo(ourport);\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t s3c24xx_serial_rx_irq(int irq, void *dev_id)\n{\n\tstruct s3c24xx_uart_port *ourport = dev_id;\n\n\tif (ourport->dma && ourport->dma->rx_chan)\n\t\treturn s3c24xx_serial_rx_chars_dma(dev_id);\n\treturn s3c24xx_serial_rx_chars_pio(dev_id);\n}\n\nstatic void s3c24xx_serial_tx_chars(struct s3c24xx_uart_port *ourport)\n{\n\tstruct uart_port *port = &ourport->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tint count, dma_count = 0;\n\n\tcount = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\n\tif (ourport->dma && ourport->dma->tx_chan &&\n\t    count >= ourport->min_dma_size) {\n\t\tint align = dma_get_cache_alignment() -\n\t\t\t(xmit->tail & (dma_get_cache_alignment() - 1));\n\t\tif (count - align >= ourport->min_dma_size) {\n\t\t\tdma_count = count - align;\n\t\t\tcount = align;\n\t\t}\n\t}\n\n\tif (port->x_char) {\n\t\twr_reg(port, S3C2410_UTXH, port->x_char);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn;\n\t}\n\n\t \n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\ts3c24xx_serial_stop_tx(port);\n\t\treturn;\n\t}\n\n\t \n\n\tif (count > port->fifosize) {\n\t\tcount = port->fifosize;\n\t\tdma_count = 0;\n\t}\n\n\twhile (!uart_circ_empty(xmit) && count > 0) {\n\t\tif (rd_regl(port, S3C2410_UFSTAT) & ourport->info->tx_fifofull)\n\t\t\tbreak;\n\n\t\twr_reg(port, S3C2410_UTXH, xmit->buf[xmit->tail]);\n\t\tuart_xmit_advance(port, 1);\n\t\tcount--;\n\t}\n\n\tif (!count && dma_count) {\n\t\ts3c24xx_serial_start_tx_dma(ourport, dma_count);\n\t\treturn;\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (uart_circ_empty(xmit))\n\t\ts3c24xx_serial_stop_tx(port);\n}\n\nstatic irqreturn_t s3c24xx_serial_tx_irq(int irq, void *id)\n{\n\tstruct s3c24xx_uart_port *ourport = id;\n\tstruct uart_port *port = &ourport->port;\n\n\tspin_lock(&port->lock);\n\n\ts3c24xx_serial_tx_chars(ourport);\n\n\tspin_unlock(&port->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t s3c64xx_serial_handle_irq(int irq, void *id)\n{\n\tconst struct s3c24xx_uart_port *ourport = id;\n\tconst struct uart_port *port = &ourport->port;\n\tunsigned int pend = rd_regl(port, S3C64XX_UINTP);\n\tirqreturn_t ret = IRQ_HANDLED;\n\n\tif (pend & S3C64XX_UINTM_RXD_MSK) {\n\t\tret = s3c24xx_serial_rx_irq(irq, id);\n\t\twr_regl(port, S3C64XX_UINTP, S3C64XX_UINTM_RXD_MSK);\n\t}\n\tif (pend & S3C64XX_UINTM_TXD_MSK) {\n\t\tret = s3c24xx_serial_tx_irq(irq, id);\n\t\twr_regl(port, S3C64XX_UINTP, S3C64XX_UINTM_TXD_MSK);\n\t}\n\treturn ret;\n}\n\n \nstatic irqreturn_t apple_serial_handle_irq(int irq, void *id)\n{\n\tconst struct s3c24xx_uart_port *ourport = id;\n\tconst struct uart_port *port = &ourport->port;\n\tunsigned int pend = rd_regl(port, S3C2410_UTRSTAT);\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (pend & (APPLE_S5L_UTRSTAT_RXTHRESH | APPLE_S5L_UTRSTAT_RXTO)) {\n\t\twr_regl(port, S3C2410_UTRSTAT,\n\t\t\tAPPLE_S5L_UTRSTAT_RXTHRESH | APPLE_S5L_UTRSTAT_RXTO);\n\t\tret = s3c24xx_serial_rx_irq(irq, id);\n\t}\n\tif (pend & APPLE_S5L_UTRSTAT_TXTHRESH) {\n\t\twr_regl(port, S3C2410_UTRSTAT, APPLE_S5L_UTRSTAT_TXTHRESH);\n\t\tret = s3c24xx_serial_tx_irq(irq, id);\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned int s3c24xx_serial_tx_empty(struct uart_port *port)\n{\n\tconst struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);\n\tunsigned long ufstat = rd_regl(port, S3C2410_UFSTAT);\n\tunsigned long ufcon = rd_regl(port, S3C2410_UFCON);\n\n\tif (ufcon & S3C2410_UFCON_FIFOMODE) {\n\t\tif ((ufstat & info->tx_fifomask) != 0 ||\n\t\t    (ufstat & info->tx_fifofull))\n\t\t\treturn 0;\n\n\t\treturn 1;\n\t}\n\n\treturn s3c24xx_serial_txempty_nofifo(port);\n}\n\n \nstatic unsigned int s3c24xx_serial_get_mctrl(struct uart_port *port)\n{\n\tunsigned int umstat = rd_reg(port, S3C2410_UMSTAT);\n\n\tif (umstat & S3C2410_UMSTAT_CTS)\n\t\treturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n\telse\n\t\treturn TIOCM_CAR | TIOCM_DSR;\n}\n\nstatic void s3c24xx_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tunsigned int umcon = rd_regl(port, S3C2410_UMCON);\n\tunsigned int ucon = rd_regl(port, S3C2410_UCON);\n\n\tif (mctrl & TIOCM_RTS)\n\t\tumcon |= S3C2410_UMCOM_RTS_LOW;\n\telse\n\t\tumcon &= ~S3C2410_UMCOM_RTS_LOW;\n\n\twr_regl(port, S3C2410_UMCON, umcon);\n\n\tif (mctrl & TIOCM_LOOP)\n\t\tucon |= S3C2410_UCON_LOOPBACK;\n\telse\n\t\tucon &= ~S3C2410_UCON_LOOPBACK;\n\n\twr_regl(port, S3C2410_UCON, ucon);\n}\n\nstatic void s3c24xx_serial_break_ctl(struct uart_port *port, int break_state)\n{\n\tunsigned long flags;\n\tunsigned int ucon;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tucon = rd_regl(port, S3C2410_UCON);\n\n\tif (break_state)\n\t\tucon |= S3C2410_UCON_SBREAK;\n\telse\n\t\tucon &= ~S3C2410_UCON_SBREAK;\n\n\twr_regl(port, S3C2410_UCON, ucon);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int s3c24xx_serial_request_dma(struct s3c24xx_uart_port *p)\n{\n\tstruct s3c24xx_uart_dma\t*dma = p->dma;\n\tstruct dma_slave_caps dma_caps;\n\tconst char *reason = NULL;\n\tint ret;\n\n\t \n\tdma->rx_conf.direction\t\t= DMA_DEV_TO_MEM;\n\tdma->rx_conf.src_addr_width\t= DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma->rx_conf.src_addr\t\t= p->port.mapbase + S3C2410_URXH;\n\tdma->rx_conf.src_maxburst\t= 1;\n\n\tdma->tx_conf.direction\t\t= DMA_MEM_TO_DEV;\n\tdma->tx_conf.dst_addr_width\t= DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma->tx_conf.dst_addr\t\t= p->port.mapbase + S3C2410_UTXH;\n\tdma->tx_conf.dst_maxburst\t= 1;\n\n\tdma->rx_chan = dma_request_chan(p->port.dev, \"rx\");\n\n\tif (IS_ERR(dma->rx_chan)) {\n\t\treason = \"DMA RX channel request failed\";\n\t\tret = PTR_ERR(dma->rx_chan);\n\t\tgoto err_warn;\n\t}\n\n\tret = dma_get_slave_caps(dma->rx_chan, &dma_caps);\n\tif (ret < 0 ||\n\t    dma_caps.residue_granularity < DMA_RESIDUE_GRANULARITY_BURST) {\n\t\treason = \"insufficient DMA RX engine capabilities\";\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_release_rx;\n\t}\n\n\tdmaengine_slave_config(dma->rx_chan, &dma->rx_conf);\n\n\tdma->tx_chan = dma_request_chan(p->port.dev, \"tx\");\n\tif (IS_ERR(dma->tx_chan)) {\n\t\treason = \"DMA TX channel request failed\";\n\t\tret = PTR_ERR(dma->tx_chan);\n\t\tgoto err_release_rx;\n\t}\n\n\tret = dma_get_slave_caps(dma->tx_chan, &dma_caps);\n\tif (ret < 0 ||\n\t    dma_caps.residue_granularity < DMA_RESIDUE_GRANULARITY_BURST) {\n\t\treason = \"insufficient DMA TX engine capabilities\";\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_release_tx;\n\t}\n\n\tdmaengine_slave_config(dma->tx_chan, &dma->tx_conf);\n\n\t \n\tdma->rx_size = PAGE_SIZE;\n\n\tdma->rx_buf = kmalloc(dma->rx_size, GFP_KERNEL);\n\tif (!dma->rx_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_release_tx;\n\t}\n\n\tdma->rx_addr = dma_map_single(dma->rx_chan->device->dev, dma->rx_buf,\n\t\t\t\t      dma->rx_size, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dma->rx_chan->device->dev, dma->rx_addr)) {\n\t\treason = \"DMA mapping error for RX buffer\";\n\t\tret = -EIO;\n\t\tgoto err_free_rx;\n\t}\n\n\t \n\tdma->tx_addr = dma_map_single(dma->tx_chan->device->dev,\n\t\t\t\t      p->port.state->xmit.buf, UART_XMIT_SIZE,\n\t\t\t\t      DMA_TO_DEVICE);\n\tif (dma_mapping_error(dma->tx_chan->device->dev, dma->tx_addr)) {\n\t\treason = \"DMA mapping error for TX buffer\";\n\t\tret = -EIO;\n\t\tgoto err_unmap_rx;\n\t}\n\n\treturn 0;\n\nerr_unmap_rx:\n\tdma_unmap_single(dma->rx_chan->device->dev, dma->rx_addr,\n\t\t\t dma->rx_size, DMA_FROM_DEVICE);\nerr_free_rx:\n\tkfree(dma->rx_buf);\nerr_release_tx:\n\tdma_release_channel(dma->tx_chan);\nerr_release_rx:\n\tdma_release_channel(dma->rx_chan);\nerr_warn:\n\tif (reason)\n\t\tdev_warn(p->port.dev, \"%s, DMA will not be used\\n\", reason);\n\treturn ret;\n}\n\nstatic void s3c24xx_serial_release_dma(struct s3c24xx_uart_port *p)\n{\n\tstruct s3c24xx_uart_dma\t*dma = p->dma;\n\n\tif (dma->rx_chan) {\n\t\tdmaengine_terminate_all(dma->rx_chan);\n\t\tdma_unmap_single(dma->rx_chan->device->dev, dma->rx_addr,\n\t\t\t\t dma->rx_size, DMA_FROM_DEVICE);\n\t\tkfree(dma->rx_buf);\n\t\tdma_release_channel(dma->rx_chan);\n\t\tdma->rx_chan = NULL;\n\t}\n\n\tif (dma->tx_chan) {\n\t\tdmaengine_terminate_all(dma->tx_chan);\n\t\tdma_unmap_single(dma->tx_chan->device->dev, dma->tx_addr,\n\t\t\t\t UART_XMIT_SIZE, DMA_TO_DEVICE);\n\t\tdma_release_channel(dma->tx_chan);\n\t\tdma->tx_chan = NULL;\n\t}\n}\n\nstatic void s3c24xx_serial_shutdown(struct uart_port *port)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\n\tif (ourport->tx_claimed) {\n\t\tfree_irq(ourport->tx_irq, ourport);\n\t\tourport->tx_enabled = 0;\n\t\tourport->tx_claimed = 0;\n\t\tourport->tx_mode = 0;\n\t}\n\n\tif (ourport->rx_claimed) {\n\t\tfree_irq(ourport->rx_irq, ourport);\n\t\tourport->rx_claimed = 0;\n\t\tourport->rx_enabled = 0;\n\t}\n\n\tif (ourport->dma)\n\t\ts3c24xx_serial_release_dma(ourport);\n\n\tourport->tx_in_progress = 0;\n}\n\nstatic void s3c64xx_serial_shutdown(struct uart_port *port)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\n\tourport->tx_enabled = 0;\n\tourport->tx_mode = 0;\n\tourport->rx_enabled = 0;\n\n\tfree_irq(port->irq, ourport);\n\n\twr_regl(port, S3C64XX_UINTP, 0xf);\n\twr_regl(port, S3C64XX_UINTM, 0xf);\n\n\tif (ourport->dma)\n\t\ts3c24xx_serial_release_dma(ourport);\n\n\tourport->tx_in_progress = 0;\n}\n\nstatic void apple_s5l_serial_shutdown(struct uart_port *port)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\n\tunsigned int ucon;\n\n\tucon = rd_regl(port, S3C2410_UCON);\n\tucon &= ~(APPLE_S5L_UCON_TXTHRESH_ENA_MSK |\n\t\t  APPLE_S5L_UCON_RXTHRESH_ENA_MSK |\n\t\t  APPLE_S5L_UCON_RXTO_ENA_MSK);\n\twr_regl(port, S3C2410_UCON, ucon);\n\n\twr_regl(port, S3C2410_UTRSTAT, APPLE_S5L_UTRSTAT_ALL_FLAGS);\n\n\tfree_irq(port->irq, ourport);\n\n\tourport->tx_enabled = 0;\n\tourport->tx_mode = 0;\n\tourport->rx_enabled = 0;\n\n\tif (ourport->dma)\n\t\ts3c24xx_serial_release_dma(ourport);\n\n\tourport->tx_in_progress = 0;\n}\n\nstatic int s3c24xx_serial_startup(struct uart_port *port)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\tint ret;\n\n\tourport->rx_enabled = 1;\n\n\tret = request_irq(ourport->rx_irq, s3c24xx_serial_rx_irq, 0,\n\t\t\t  s3c24xx_serial_portname(port), ourport);\n\n\tif (ret != 0) {\n\t\tdev_err(port->dev, \"cannot get irq %d\\n\", ourport->rx_irq);\n\t\treturn ret;\n\t}\n\n\tourport->rx_claimed = 1;\n\n\tdev_dbg(port->dev, \"requesting tx irq...\\n\");\n\n\tourport->tx_enabled = 1;\n\n\tret = request_irq(ourport->tx_irq, s3c24xx_serial_tx_irq, 0,\n\t\t\t  s3c24xx_serial_portname(port), ourport);\n\n\tif (ret) {\n\t\tdev_err(port->dev, \"cannot get irq %d\\n\", ourport->tx_irq);\n\t\tgoto err;\n\t}\n\n\tourport->tx_claimed = 1;\n\n\t \n\n\treturn ret;\n\nerr:\n\ts3c24xx_serial_shutdown(port);\n\treturn ret;\n}\n\nstatic int s3c64xx_serial_startup(struct uart_port *port)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\tunsigned long flags;\n\tunsigned int ufcon;\n\tint ret;\n\n\twr_regl(port, S3C64XX_UINTM, 0xf);\n\tif (ourport->dma) {\n\t\tret = s3c24xx_serial_request_dma(ourport);\n\t\tif (ret < 0) {\n\t\t\tdevm_kfree(port->dev, ourport->dma);\n\t\t\tourport->dma = NULL;\n\t\t}\n\t}\n\n\tret = request_irq(port->irq, s3c64xx_serial_handle_irq, IRQF_SHARED,\n\t\t\t  s3c24xx_serial_portname(port), ourport);\n\tif (ret) {\n\t\tdev_err(port->dev, \"cannot get irq %d\\n\", port->irq);\n\t\treturn ret;\n\t}\n\n\t \n\tourport->rx_enabled = 1;\n\tourport->tx_enabled = 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tufcon = rd_regl(port, S3C2410_UFCON);\n\tufcon |= S3C2410_UFCON_RESETRX | S5PV210_UFCON_RXTRIG8;\n\tif (!uart_console(port))\n\t\tufcon |= S3C2410_UFCON_RESETTX;\n\twr_regl(port, S3C2410_UFCON, ufcon);\n\n\tenable_rx_pio(ourport);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\ts3c24xx_clear_bit(port, S3C64XX_UINTM_RXD, S3C64XX_UINTM);\n\n\treturn ret;\n}\n\nstatic int apple_s5l_serial_startup(struct uart_port *port)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\tunsigned long flags;\n\tunsigned int ufcon;\n\tint ret;\n\n\twr_regl(port, S3C2410_UTRSTAT, APPLE_S5L_UTRSTAT_ALL_FLAGS);\n\n\tret = request_irq(port->irq, apple_serial_handle_irq, 0,\n\t\t\t  s3c24xx_serial_portname(port), ourport);\n\tif (ret) {\n\t\tdev_err(port->dev, \"cannot get irq %d\\n\", port->irq);\n\t\treturn ret;\n\t}\n\n\t \n\tourport->rx_enabled = 1;\n\tourport->tx_enabled = 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tufcon = rd_regl(port, S3C2410_UFCON);\n\tufcon |= S3C2410_UFCON_RESETRX | S5PV210_UFCON_RXTRIG8;\n\tif (!uart_console(port))\n\t\tufcon |= S3C2410_UFCON_RESETTX;\n\twr_regl(port, S3C2410_UFCON, ufcon);\n\n\tenable_rx_pio(ourport);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\ts3c24xx_set_bit(port, APPLE_S5L_UCON_RXTHRESH_ENA, S3C2410_UCON);\n\ts3c24xx_set_bit(port, APPLE_S5L_UCON_RXTO_ENA, S3C2410_UCON);\n\n\treturn ret;\n}\n\n \n\nstatic void s3c24xx_serial_pm(struct uart_port *port, unsigned int level,\n\t\t\t      unsigned int old)\n{\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\tint timeout = 10000;\n\n\tourport->pm_level = level;\n\n\tswitch (level) {\n\tcase 3:\n\t\twhile (--timeout && !s3c24xx_serial_txempty_nofifo(port))\n\t\t\tudelay(100);\n\n\t\tif (!IS_ERR(ourport->baudclk))\n\t\t\tclk_disable_unprepare(ourport->baudclk);\n\n\t\tclk_disable_unprepare(ourport->clk);\n\t\tbreak;\n\n\tcase 0:\n\t\tclk_prepare_enable(ourport->clk);\n\n\t\tif (!IS_ERR(ourport->baudclk))\n\t\t\tclk_prepare_enable(ourport->baudclk);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(port->dev, \"s3c24xx_serial: unknown pm %d\\n\", level);\n\t}\n}\n\n \n\n#define MAX_CLK_NAME_LENGTH 15\n\nstatic inline int s3c24xx_serial_getsource(struct uart_port *port)\n{\n\tconst struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);\n\tunsigned int ucon;\n\n\tif (info->num_clks == 1)\n\t\treturn 0;\n\n\tucon = rd_regl(port, S3C2410_UCON);\n\tucon &= info->clksel_mask;\n\treturn ucon >> info->clksel_shift;\n}\n\nstatic void s3c24xx_serial_setsource(struct uart_port *port,\n\t\t\tunsigned int clk_sel)\n{\n\tconst struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);\n\tunsigned int ucon;\n\n\tif (info->num_clks == 1)\n\t\treturn;\n\n\tucon = rd_regl(port, S3C2410_UCON);\n\tif ((ucon & info->clksel_mask) >> info->clksel_shift == clk_sel)\n\t\treturn;\n\n\tucon &= ~info->clksel_mask;\n\tucon |= clk_sel << info->clksel_shift;\n\twr_regl(port, S3C2410_UCON, ucon);\n}\n\nstatic unsigned int s3c24xx_serial_getclk(struct s3c24xx_uart_port *ourport,\n\t\t\tunsigned int req_baud, struct clk **best_clk,\n\t\t\tunsigned int *clk_num)\n{\n\tconst struct s3c24xx_uart_info *info = ourport->info;\n\tstruct clk *clk;\n\tunsigned long rate;\n\tunsigned int cnt, baud, quot, best_quot = 0;\n\tchar clkname[MAX_CLK_NAME_LENGTH];\n\tint calc_deviation, deviation = (1 << 30) - 1;\n\n\tfor (cnt = 0; cnt < info->num_clks; cnt++) {\n\t\t \n\t\tif (ourport->cfg->clk_sel &&\n\t\t\t!(ourport->cfg->clk_sel & (1 << cnt)))\n\t\t\tcontinue;\n\n\t\tsprintf(clkname, \"clk_uart_baud%d\", cnt);\n\t\tclk = clk_get(ourport->port.dev, clkname);\n\t\tif (IS_ERR(clk))\n\t\t\tcontinue;\n\n\t\trate = clk_get_rate(clk);\n\t\tif (!rate) {\n\t\t\tdev_err(ourport->port.dev,\n\t\t\t\t\"Failed to get clock rate for %s.\\n\", clkname);\n\t\t\tclk_put(clk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ourport->info->has_divslot) {\n\t\t\tunsigned long div = rate / req_baud;\n\n\t\t\t \n\n\t\t\tquot = div / 16;\n\t\t\tbaud = rate / div;\n\t\t} else {\n\t\t\tquot = (rate + (8 * req_baud)) / (16 * req_baud);\n\t\t\tbaud = rate / (quot * 16);\n\t\t}\n\t\tquot--;\n\n\t\tcalc_deviation = abs(req_baud - baud);\n\n\t\tif (calc_deviation < deviation) {\n\t\t\t \n\t\t\tif (!IS_ERR(*best_clk))\n\t\t\t\tclk_put(*best_clk);\n\t\t\t*best_clk = clk;\n\t\t\tbest_quot = quot;\n\t\t\t*clk_num = cnt;\n\t\t\tdeviation = calc_deviation;\n\t\t} else {\n\t\t\tclk_put(clk);\n\t\t}\n\t}\n\n\treturn best_quot;\n}\n\n \nstatic const u16 udivslot_table[16] = {\n\t[0] = 0x0000,\n\t[1] = 0x0080,\n\t[2] = 0x0808,\n\t[3] = 0x0888,\n\t[4] = 0x2222,\n\t[5] = 0x4924,\n\t[6] = 0x4A52,\n\t[7] = 0x54AA,\n\t[8] = 0x5555,\n\t[9] = 0xD555,\n\t[10] = 0xD5D5,\n\t[11] = 0xDDD5,\n\t[12] = 0xDDDD,\n\t[13] = 0xDFDD,\n\t[14] = 0xDFDF,\n\t[15] = 0xFFDF,\n};\n\nstatic void s3c24xx_serial_set_termios(struct uart_port *port,\n\t\t\t\t       struct ktermios *termios,\n\t\t\t\t       const struct ktermios *old)\n{\n\tconst struct s3c2410_uartcfg *cfg = s3c24xx_port_to_cfg(port);\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\tstruct clk *clk = ERR_PTR(-EINVAL);\n\tunsigned long flags;\n\tunsigned int baud, quot, clk_sel = 0;\n\tunsigned int ulcon;\n\tunsigned int umcon;\n\tunsigned int udivslot = 0;\n\n\t \n\ttermios->c_cflag &= ~(HUPCL | CMSPAR);\n\ttermios->c_cflag |= CLOCAL;\n\n\t \n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, 3000000);\n\tquot = s3c24xx_serial_getclk(ourport, baud, &clk, &clk_sel);\n\tif (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST)\n\t\tquot = port->custom_divisor;\n\tif (IS_ERR(clk))\n\t\treturn;\n\n\t \n\n\tif (ourport->baudclk != clk) {\n\t\tclk_prepare_enable(clk);\n\n\t\ts3c24xx_serial_setsource(port, clk_sel);\n\n\t\tif (!IS_ERR(ourport->baudclk)) {\n\t\t\tclk_disable_unprepare(ourport->baudclk);\n\t\t\tourport->baudclk = ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tourport->baudclk = clk;\n\t\tourport->baudclk_rate = clk ? clk_get_rate(clk) : 0;\n\t}\n\n\tif (ourport->info->has_divslot) {\n\t\tunsigned int div = ourport->baudclk_rate / baud;\n\n\t\tif (cfg->has_fracval) {\n\t\t\tudivslot = (div & 15);\n\t\t\tdev_dbg(port->dev, \"fracval = %04x\\n\", udivslot);\n\t\t} else {\n\t\t\tudivslot = udivslot_table[div & 15];\n\t\t\tdev_dbg(port->dev, \"udivslot = %04x (div %d)\\n\",\n\t\t\t\tudivslot, div & 15);\n\t\t}\n\t}\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tdev_dbg(port->dev, \"config: 5bits/char\\n\");\n\t\tulcon = S3C2410_LCON_CS5;\n\t\tbreak;\n\tcase CS6:\n\t\tdev_dbg(port->dev, \"config: 6bits/char\\n\");\n\t\tulcon = S3C2410_LCON_CS6;\n\t\tbreak;\n\tcase CS7:\n\t\tdev_dbg(port->dev, \"config: 7bits/char\\n\");\n\t\tulcon = S3C2410_LCON_CS7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tdev_dbg(port->dev, \"config: 8bits/char\\n\");\n\t\tulcon = S3C2410_LCON_CS8;\n\t\tbreak;\n\t}\n\n\t \n\tulcon |= (cfg->ulcon & S3C2410_LCON_IRM);\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tulcon |= S3C2410_LCON_STOPB;\n\n\tif (termios->c_cflag & PARENB) {\n\t\tif (termios->c_cflag & PARODD)\n\t\t\tulcon |= S3C2410_LCON_PODD;\n\t\telse\n\t\t\tulcon |= S3C2410_LCON_PEVEN;\n\t} else {\n\t\tulcon |= S3C2410_LCON_PNONE;\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tdev_dbg(port->dev,\n\t\t\"setting ulcon to %08x, brddiv to %d, udivslot %08x\\n\",\n\t\tulcon, quot, udivslot);\n\n\twr_regl(port, S3C2410_ULCON, ulcon);\n\twr_regl(port, S3C2410_UBRDIV, quot);\n\n\tport->status &= ~UPSTAT_AUTOCTS;\n\n\tumcon = rd_regl(port, S3C2410_UMCON);\n\tif (termios->c_cflag & CRTSCTS) {\n\t\tumcon |= S3C2410_UMCOM_AFC;\n\t\t \n\t\tumcon &= ~S3C2412_UMCON_AFC_8;\n\t\tport->status = UPSTAT_AUTOCTS;\n\t} else {\n\t\tumcon &= ~S3C2410_UMCOM_AFC;\n\t}\n\twr_regl(port, S3C2410_UMCON, umcon);\n\n\tif (ourport->info->has_divslot)\n\t\twr_regl(port, S3C2443_DIVSLOT, udivslot);\n\n\tdev_dbg(port->dev,\n\t\t\"uart: ulcon = 0x%08x, ucon = 0x%08x, ufcon = 0x%08x\\n\",\n\t\trd_regl(port, S3C2410_ULCON),\n\t\trd_regl(port, S3C2410_UCON),\n\t\trd_regl(port, S3C2410_UFCON));\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tport->read_status_mask = S3C2410_UERSTAT_OVERRUN;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= S3C2410_UERSTAT_FRAME |\n\t\t\tS3C2410_UERSTAT_PARITY;\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= S3C2410_UERSTAT_OVERRUN;\n\tif (termios->c_iflag & IGNBRK && termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= S3C2410_UERSTAT_FRAME;\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= RXSTAT_DUMMY_READ;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *s3c24xx_serial_type(struct uart_port *port)\n{\n\tconst struct s3c24xx_uart_port *ourport = to_ourport(port);\n\n\tswitch (ourport->info->type) {\n\tcase TYPE_S3C24XX:\n\t\treturn \"S3C24XX\";\n\tcase TYPE_S3C6400:\n\t\treturn \"S3C6400/10\";\n\tcase TYPE_APPLE_S5L:\n\t\treturn \"APPLE S5L\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic void s3c24xx_serial_config_port(struct uart_port *port, int flags)\n{\n\tconst struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);\n\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = info->port_type;\n}\n\n \nstatic int\ns3c24xx_serial_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tconst struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);\n\n\tif (ser->type != PORT_UNKNOWN && ser->type != info->port_type)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SERIAL_SAMSUNG_CONSOLE\n\nstatic struct console s3c24xx_serial_console;\n\nstatic void __init s3c24xx_serial_register_console(void)\n{\n\tregister_console(&s3c24xx_serial_console);\n}\n\nstatic void s3c24xx_serial_unregister_console(void)\n{\n\tif (console_is_registered(&s3c24xx_serial_console))\n\t\tunregister_console(&s3c24xx_serial_console);\n}\n\n#define S3C24XX_SERIAL_CONSOLE &s3c24xx_serial_console\n#else\nstatic inline void s3c24xx_serial_register_console(void) { }\nstatic inline void s3c24xx_serial_unregister_console(void) { }\n#define S3C24XX_SERIAL_CONSOLE NULL\n#endif\n\n#if defined(CONFIG_SERIAL_SAMSUNG_CONSOLE) && defined(CONFIG_CONSOLE_POLL)\nstatic int s3c24xx_serial_get_poll_char(struct uart_port *port);\nstatic void s3c24xx_serial_put_poll_char(struct uart_port *port,\n\t\t\t unsigned char c);\n#endif\n\nstatic const struct uart_ops s3c24xx_serial_ops = {\n\t.pm\t\t= s3c24xx_serial_pm,\n\t.tx_empty\t= s3c24xx_serial_tx_empty,\n\t.get_mctrl\t= s3c24xx_serial_get_mctrl,\n\t.set_mctrl\t= s3c24xx_serial_set_mctrl,\n\t.stop_tx\t= s3c24xx_serial_stop_tx,\n\t.start_tx\t= s3c24xx_serial_start_tx,\n\t.stop_rx\t= s3c24xx_serial_stop_rx,\n\t.break_ctl\t= s3c24xx_serial_break_ctl,\n\t.startup\t= s3c24xx_serial_startup,\n\t.shutdown\t= s3c24xx_serial_shutdown,\n\t.set_termios\t= s3c24xx_serial_set_termios,\n\t.type\t\t= s3c24xx_serial_type,\n\t.config_port\t= s3c24xx_serial_config_port,\n\t.verify_port\t= s3c24xx_serial_verify_port,\n#if defined(CONFIG_SERIAL_SAMSUNG_CONSOLE) && defined(CONFIG_CONSOLE_POLL)\n\t.poll_get_char = s3c24xx_serial_get_poll_char,\n\t.poll_put_char = s3c24xx_serial_put_poll_char,\n#endif\n};\n\nstatic const struct uart_ops s3c64xx_serial_ops = {\n\t.pm\t\t= s3c24xx_serial_pm,\n\t.tx_empty\t= s3c24xx_serial_tx_empty,\n\t.get_mctrl\t= s3c24xx_serial_get_mctrl,\n\t.set_mctrl\t= s3c24xx_serial_set_mctrl,\n\t.stop_tx\t= s3c24xx_serial_stop_tx,\n\t.start_tx\t= s3c24xx_serial_start_tx,\n\t.stop_rx\t= s3c24xx_serial_stop_rx,\n\t.break_ctl\t= s3c24xx_serial_break_ctl,\n\t.startup\t= s3c64xx_serial_startup,\n\t.shutdown\t= s3c64xx_serial_shutdown,\n\t.set_termios\t= s3c24xx_serial_set_termios,\n\t.type\t\t= s3c24xx_serial_type,\n\t.config_port\t= s3c24xx_serial_config_port,\n\t.verify_port\t= s3c24xx_serial_verify_port,\n#if defined(CONFIG_SERIAL_SAMSUNG_CONSOLE) && defined(CONFIG_CONSOLE_POLL)\n\t.poll_get_char = s3c24xx_serial_get_poll_char,\n\t.poll_put_char = s3c24xx_serial_put_poll_char,\n#endif\n};\n\nstatic const struct uart_ops apple_s5l_serial_ops = {\n\t.pm\t\t= s3c24xx_serial_pm,\n\t.tx_empty\t= s3c24xx_serial_tx_empty,\n\t.get_mctrl\t= s3c24xx_serial_get_mctrl,\n\t.set_mctrl\t= s3c24xx_serial_set_mctrl,\n\t.stop_tx\t= s3c24xx_serial_stop_tx,\n\t.start_tx\t= s3c24xx_serial_start_tx,\n\t.stop_rx\t= s3c24xx_serial_stop_rx,\n\t.break_ctl\t= s3c24xx_serial_break_ctl,\n\t.startup\t= apple_s5l_serial_startup,\n\t.shutdown\t= apple_s5l_serial_shutdown,\n\t.set_termios\t= s3c24xx_serial_set_termios,\n\t.type\t\t= s3c24xx_serial_type,\n\t.config_port\t= s3c24xx_serial_config_port,\n\t.verify_port\t= s3c24xx_serial_verify_port,\n#if defined(CONFIG_SERIAL_SAMSUNG_CONSOLE) && defined(CONFIG_CONSOLE_POLL)\n\t.poll_get_char = s3c24xx_serial_get_poll_char,\n\t.poll_put_char = s3c24xx_serial_put_poll_char,\n#endif\n};\n\nstatic struct uart_driver s3c24xx_uart_drv = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"s3c2410_serial\",\n\t.nr\t\t= UART_NR,\n\t.cons\t\t= S3C24XX_SERIAL_CONSOLE,\n\t.dev_name\t= S3C24XX_SERIAL_NAME,\n\t.major\t\t= S3C24XX_SERIAL_MAJOR,\n\t.minor\t\t= S3C24XX_SERIAL_MINOR,\n};\n\nstatic struct s3c24xx_uart_port s3c24xx_serial_ports[UART_NR];\n\nstatic void s3c24xx_serial_init_port_default(int index) {\n\tstruct uart_port *port = &s3c24xx_serial_ports[index].port;\n\n\tspin_lock_init(&port->lock);\n\n\tport->iotype = UPIO_MEM;\n\tport->uartclk = 0;\n\tport->fifosize = 16;\n\tport->ops = &s3c24xx_serial_ops;\n\tport->flags = UPF_BOOT_AUTOCONF;\n\tport->line = index;\n}\n\n \n\nstatic void s3c24xx_serial_resetport(struct uart_port *port,\n\t\t\t\t     const struct s3c2410_uartcfg *cfg)\n{\n\tconst struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);\n\tunsigned long ucon = rd_regl(port, S3C2410_UCON);\n\n\tucon &= (info->clksel_mask | info->ucon_mask);\n\twr_regl(port, S3C2410_UCON, ucon | cfg->ucon);\n\n\t \n\twr_regl(port, S3C2410_UFCON, cfg->ufcon | S3C2410_UFCON_RESETBOTH);\n\twr_regl(port, S3C2410_UFCON, cfg->ufcon);\n\n\t \n\tudelay(1);\n}\n\nstatic int s3c24xx_serial_enable_baudclk(struct s3c24xx_uart_port *ourport)\n{\n\tstruct device *dev = ourport->port.dev;\n\tconst struct s3c24xx_uart_info *info = ourport->info;\n\tchar clk_name[MAX_CLK_NAME_LENGTH];\n\tunsigned int clk_sel;\n\tstruct clk *clk;\n\tint clk_num;\n\tint ret;\n\n\tclk_sel = ourport->cfg->clk_sel ? : info->def_clk_sel;\n\tfor (clk_num = 0; clk_num < info->num_clks; clk_num++) {\n\t\tif (!(clk_sel & (1 << clk_num)))\n\t\t\tcontinue;\n\n\t\tsprintf(clk_name, \"clk_uart_baud%d\", clk_num);\n\t\tclk = clk_get(dev, clk_name);\n\t\tif (IS_ERR(clk))\n\t\t\tcontinue;\n\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret) {\n\t\t\tclk_put(clk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tourport->baudclk = clk;\n\t\tourport->baudclk_rate = clk_get_rate(clk);\n\t\ts3c24xx_serial_setsource(&ourport->port, clk_num);\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \n\nstatic int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,\n\t\t\t\t    struct platform_device *platdev)\n{\n\tstruct uart_port *port = &ourport->port;\n\tconst struct s3c2410_uartcfg *cfg = ourport->cfg;\n\tstruct resource *res;\n\tint ret;\n\n\tif (platdev == NULL)\n\t\treturn -ENODEV;\n\n\tif (port->mapbase != 0)\n\t\treturn -EINVAL;\n\n\t \n\tport->dev\t= &platdev->dev;\n\n\tport->uartclk = 1;\n\n\tif (cfg->uart_flags & UPF_CONS_FLOW) {\n\t\tdev_dbg(port->dev, \"enabling flow control\\n\");\n\t\tport->flags |= UPF_CONS_FLOW;\n\t}\n\n\t \n\n\tres = platform_get_resource(platdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(port->dev, \"failed to find memory resource for uart\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(port->dev, \"resource %pR)\\n\", res);\n\n\tport->membase = devm_ioremap_resource(port->dev, res);\n\tif (IS_ERR(port->membase)) {\n\t\tdev_err(port->dev, \"failed to remap controller address\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tport->mapbase = res->start;\n\tret = platform_get_irq(platdev, 0);\n\tif (ret < 0) {\n\t\tport->irq = 0;\n\t} else {\n\t\tport->irq = ret;\n\t\tourport->rx_irq = ret;\n\t\tourport->tx_irq = ret + 1;\n\t}\n\n\tswitch (ourport->info->type) {\n\tcase TYPE_S3C24XX:\n\t\tret = platform_get_irq(platdev, 1);\n\t\tif (ret > 0)\n\t\t\tourport->tx_irq = ret;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (platdev->dev.of_node && of_find_property(platdev->dev.of_node,\n\t\t\t\t\t\t     \"dmas\", NULL)) {\n\t\tourport->dma = devm_kzalloc(port->dev,\n\t\t\t\t\t    sizeof(*ourport->dma),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!ourport->dma) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tourport->clk\t= clk_get(&platdev->dev, \"uart\");\n\tif (IS_ERR(ourport->clk)) {\n\t\tpr_err(\"%s: Controller clock not found\\n\",\n\t\t\t\tdev_name(&platdev->dev));\n\t\tret = PTR_ERR(ourport->clk);\n\t\tgoto err;\n\t}\n\n\tret = clk_prepare_enable(ourport->clk);\n\tif (ret) {\n\t\tpr_err(\"uart: clock failed to prepare+enable: %d\\n\", ret);\n\t\tclk_put(ourport->clk);\n\t\tgoto err;\n\t}\n\n\tret = s3c24xx_serial_enable_baudclk(ourport);\n\tif (ret)\n\t\tpr_warn(\"uart: failed to enable baudclk\\n\");\n\n\t \n\tswitch (ourport->info->type) {\n\tcase TYPE_S3C6400:\n\t\twr_regl(port, S3C64XX_UINTM, 0xf);\n\t\twr_regl(port, S3C64XX_UINTP, 0xf);\n\t\twr_regl(port, S3C64XX_UINTSP, 0xf);\n\t\tbreak;\n\tcase TYPE_APPLE_S5L: {\n\t\tunsigned int ucon;\n\n\t\tucon = rd_regl(port, S3C2410_UCON);\n\t\tucon &= ~(APPLE_S5L_UCON_TXTHRESH_ENA_MSK |\n\t\t\tAPPLE_S5L_UCON_RXTHRESH_ENA_MSK |\n\t\t\tAPPLE_S5L_UCON_RXTO_ENA_MSK);\n\t\twr_regl(port, S3C2410_UCON, ucon);\n\n\t\twr_regl(port, S3C2410_UTRSTAT, APPLE_S5L_UTRSTAT_ALL_FLAGS);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_dbg(port->dev, \"port: map=%pa, mem=%p, irq=%d (%d,%d), clock=%u\\n\",\n\t\t&port->mapbase, port->membase, port->irq,\n\t\tourport->rx_irq, ourport->tx_irq, port->uartclk);\n\n\t \n\ts3c24xx_serial_resetport(port, cfg);\n\n\treturn 0;\n\nerr:\n\tport->mapbase = 0;\n\treturn ret;\n}\n\n \n\nstatic int probe_index;\n\nstatic inline const struct s3c24xx_serial_drv_data *\ns3c24xx_get_driver_data(struct platform_device *pdev)\n{\n\tif (dev_of_node(&pdev->dev))\n\t\treturn of_device_get_match_data(&pdev->dev);\n\n\treturn (struct s3c24xx_serial_drv_data *)\n\t\t\tplatform_get_device_id(pdev)->driver_data;\n}\n\nstatic int s3c24xx_serial_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct s3c24xx_uart_port *ourport;\n\tint index = probe_index;\n\tint ret, prop = 0;\n\n\tif (np) {\n\t\tret = of_alias_get_id(np, \"serial\");\n\t\tif (ret >= 0)\n\t\t\tindex = ret;\n\t}\n\n\tif (index >= ARRAY_SIZE(s3c24xx_serial_ports)) {\n\t\tdev_err(&pdev->dev, \"serial%d out of range\\n\", index);\n\t\treturn -EINVAL;\n\t}\n\tourport = &s3c24xx_serial_ports[index];\n\n\ts3c24xx_serial_init_port_default(index);\n\n\tourport->drv_data = s3c24xx_get_driver_data(pdev);\n\tif (!ourport->drv_data) {\n\t\tdev_err(&pdev->dev, \"could not find driver data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tourport->baudclk = ERR_PTR(-EINVAL);\n\tourport->info = &ourport->drv_data->info;\n\tourport->cfg = (dev_get_platdata(&pdev->dev)) ?\n\t\t\tdev_get_platdata(&pdev->dev) :\n\t\t\t&ourport->drv_data->def_cfg;\n\n\tswitch (ourport->info->type) {\n\tcase TYPE_S3C24XX:\n\t\tourport->port.ops = &s3c24xx_serial_ops;\n\t\tbreak;\n\tcase TYPE_S3C6400:\n\t\tourport->port.ops = &s3c64xx_serial_ops;\n\t\tbreak;\n\tcase TYPE_APPLE_S5L:\n\t\tourport->port.ops = &apple_s5l_serial_ops;\n\t\tbreak;\n\t}\n\n\tif (np) {\n\t\tof_property_read_u32(np,\n\t\t\t\"samsung,uart-fifosize\", &ourport->port.fifosize);\n\n\t\tif (of_property_read_u32(np, \"reg-io-width\", &prop) == 0) {\n\t\t\tswitch (prop) {\n\t\t\tcase 1:\n\t\t\t\tourport->port.iotype = UPIO_MEM;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tourport->port.iotype = UPIO_MEM32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_warn(&pdev->dev, \"unsupported reg-io-width (%d)\\n\",\n\t\t\t\t\t\tprop);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ourport->drv_data->fifosize[index])\n\t\tourport->port.fifosize = ourport->drv_data->fifosize[index];\n\telse if (ourport->info->fifosize)\n\t\tourport->port.fifosize = ourport->info->fifosize;\n\tourport->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_SAMSUNG_CONSOLE);\n\n\t \n\tourport->min_dma_size = max_t(int, ourport->port.fifosize,\n\t\t\t\t    dma_get_cache_alignment());\n\n\tdev_dbg(&pdev->dev, \"%s: initialising port %p...\\n\", __func__, ourport);\n\n\tret = s3c24xx_serial_init_port(ourport, pdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!s3c24xx_uart_drv.state) {\n\t\tret = uart_register_driver(&s3c24xx_uart_drv);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to register Samsung UART driver\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_dbg(&pdev->dev, \"%s: adding port\\n\", __func__);\n\tuart_add_one_port(&s3c24xx_uart_drv, &ourport->port);\n\tplatform_set_drvdata(pdev, &ourport->port);\n\n\t \n\tclk_disable_unprepare(ourport->clk);\n\tif (!IS_ERR(ourport->baudclk))\n\t\tclk_disable_unprepare(ourport->baudclk);\n\n\tprobe_index++;\n\n\treturn 0;\n}\n\nstatic int s3c24xx_serial_remove(struct platform_device *dev)\n{\n\tstruct uart_port *port = s3c24xx_dev_to_port(&dev->dev);\n\n\tif (port) {\n\t\tuart_remove_one_port(&s3c24xx_uart_drv, port);\n\t}\n\n\tuart_unregister_driver(&s3c24xx_uart_drv);\n\n\treturn 0;\n}\n\n \n#ifdef CONFIG_PM_SLEEP\nstatic int s3c24xx_serial_suspend(struct device *dev)\n{\n\tstruct uart_port *port = s3c24xx_dev_to_port(dev);\n\n\tif (port)\n\t\tuart_suspend_port(&s3c24xx_uart_drv, port);\n\n\treturn 0;\n}\n\nstatic int s3c24xx_serial_resume(struct device *dev)\n{\n\tstruct uart_port *port = s3c24xx_dev_to_port(dev);\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\n\tif (port) {\n\t\tclk_prepare_enable(ourport->clk);\n\t\tif (!IS_ERR(ourport->baudclk))\n\t\t\tclk_prepare_enable(ourport->baudclk);\n\t\ts3c24xx_serial_resetport(port, s3c24xx_port_to_cfg(port));\n\t\tif (!IS_ERR(ourport->baudclk))\n\t\t\tclk_disable_unprepare(ourport->baudclk);\n\t\tclk_disable_unprepare(ourport->clk);\n\n\t\tuart_resume_port(&s3c24xx_uart_drv, port);\n\t}\n\n\treturn 0;\n}\n\nstatic int s3c24xx_serial_resume_noirq(struct device *dev)\n{\n\tstruct uart_port *port = s3c24xx_dev_to_port(dev);\n\tstruct s3c24xx_uart_port *ourport = to_ourport(port);\n\n\tif (port) {\n\t\t \n\t\tswitch (ourport->info->type) {\n\t\tcase TYPE_S3C6400: {\n\t\t\tunsigned int uintm = 0xf;\n\n\t\t\tif (ourport->tx_enabled)\n\t\t\t\tuintm &= ~S3C64XX_UINTM_TXD_MSK;\n\t\t\tif (ourport->rx_enabled)\n\t\t\t\tuintm &= ~S3C64XX_UINTM_RXD_MSK;\n\t\t\tclk_prepare_enable(ourport->clk);\n\t\t\tif (!IS_ERR(ourport->baudclk))\n\t\t\t\tclk_prepare_enable(ourport->baudclk);\n\t\t\twr_regl(port, S3C64XX_UINTM, uintm);\n\t\t\tif (!IS_ERR(ourport->baudclk))\n\t\t\t\tclk_disable_unprepare(ourport->baudclk);\n\t\t\tclk_disable_unprepare(ourport->clk);\n\t\t\tbreak;\n\t\t}\n\t\tcase TYPE_APPLE_S5L: {\n\t\t\tunsigned int ucon;\n\t\t\tint ret;\n\n\t\t\tret = clk_prepare_enable(ourport->clk);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"clk_enable clk failed: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif (!IS_ERR(ourport->baudclk)) {\n\t\t\t\tret = clk_prepare_enable(ourport->baudclk);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(dev, \"clk_enable baudclk failed: %d\\n\", ret);\n\t\t\t\t\tclk_disable_unprepare(ourport->clk);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tucon = rd_regl(port, S3C2410_UCON);\n\n\t\t\tucon &= ~(APPLE_S5L_UCON_TXTHRESH_ENA_MSK |\n\t\t\t\t  APPLE_S5L_UCON_RXTHRESH_ENA_MSK |\n\t\t\t\t  APPLE_S5L_UCON_RXTO_ENA_MSK);\n\n\t\t\tif (ourport->tx_enabled)\n\t\t\t\tucon |= APPLE_S5L_UCON_TXTHRESH_ENA_MSK;\n\t\t\tif (ourport->rx_enabled)\n\t\t\t\tucon |= APPLE_S5L_UCON_RXTHRESH_ENA_MSK |\n\t\t\t\t\tAPPLE_S5L_UCON_RXTO_ENA_MSK;\n\n\t\t\twr_regl(port, S3C2410_UCON, ucon);\n\n\t\t\tif (!IS_ERR(ourport->baudclk))\n\t\t\t\tclk_disable_unprepare(ourport->baudclk);\n\t\t\tclk_disable_unprepare(ourport->clk);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops s3c24xx_serial_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(s3c24xx_serial_suspend, s3c24xx_serial_resume)\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(NULL, s3c24xx_serial_resume_noirq)\n};\n#define SERIAL_SAMSUNG_PM_OPS\t(&s3c24xx_serial_pm_ops)\n\n#else  \n\n#define SERIAL_SAMSUNG_PM_OPS\tNULL\n#endif  \n\n \n\n#ifdef CONFIG_SERIAL_SAMSUNG_CONSOLE\n\nstatic struct uart_port *cons_uart;\n\nstatic int\ns3c24xx_serial_console_txrdy(struct uart_port *port, unsigned int ufcon)\n{\n\tconst struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);\n\tunsigned long ufstat, utrstat;\n\n\tif (ufcon & S3C2410_UFCON_FIFOMODE) {\n\t\t \n\n\t\tufstat = rd_regl(port, S3C2410_UFSTAT);\n\t\treturn (ufstat & info->tx_fifofull) ? 0 : 1;\n\t}\n\n\t \n\n\tutrstat = rd_regl(port, S3C2410_UTRSTAT);\n\treturn (utrstat & S3C2410_UTRSTAT_TXE) ? 1 : 0;\n}\n\nstatic bool\ns3c24xx_port_configured(unsigned int ucon)\n{\n\t \n\treturn (ucon & 0xf) != 0;\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n \n\nstatic int s3c24xx_serial_get_poll_char(struct uart_port *port)\n{\n\tconst struct s3c24xx_uart_port *ourport = to_ourport(port);\n\tunsigned int ufstat;\n\n\tufstat = rd_regl(port, S3C2410_UFSTAT);\n\tif (s3c24xx_serial_rx_fifocnt(ourport, ufstat) == 0)\n\t\treturn NO_POLL_CHAR;\n\n\treturn rd_reg(port, S3C2410_URXH);\n}\n\nstatic void s3c24xx_serial_put_poll_char(struct uart_port *port,\n\t\tunsigned char c)\n{\n\tunsigned int ufcon = rd_regl(port, S3C2410_UFCON);\n\tunsigned int ucon = rd_regl(port, S3C2410_UCON);\n\n\t \n\tif (!s3c24xx_port_configured(ucon))\n\t\treturn;\n\n\twhile (!s3c24xx_serial_console_txrdy(port, ufcon))\n\t\tcpu_relax();\n\twr_reg(port, S3C2410_UTXH, c);\n}\n\n#endif  \n\nstatic void\ns3c24xx_serial_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tunsigned int ufcon = rd_regl(port, S3C2410_UFCON);\n\n\twhile (!s3c24xx_serial_console_txrdy(port, ufcon))\n\t\tcpu_relax();\n\twr_reg(port, S3C2410_UTXH, ch);\n}\n\nstatic void\ns3c24xx_serial_console_write(struct console *co, const char *s,\n\t\t\t     unsigned int count)\n{\n\tunsigned int ucon = rd_regl(cons_uart, S3C2410_UCON);\n\tunsigned long flags;\n\tbool locked = true;\n\n\t \n\tif (!s3c24xx_port_configured(ucon))\n\t\treturn;\n\n\tif (cons_uart->sysrq)\n\t\tlocked = false;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&cons_uart->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&cons_uart->lock, flags);\n\n\tuart_console_write(cons_uart, s, count, s3c24xx_serial_console_putchar);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&cons_uart->lock, flags);\n}\n\n \nstatic void\ns3c24xx_serial_get_options(struct uart_port *port, int *baud,\n\t\t\t   int *parity, int *bits)\n{\n\tstruct clk *clk;\n\tunsigned int ulcon;\n\tunsigned int ucon;\n\tunsigned int ubrdiv;\n\tunsigned long rate;\n\tunsigned int clk_sel;\n\tchar clk_name[MAX_CLK_NAME_LENGTH];\n\n\tulcon  = rd_regl(port, S3C2410_ULCON);\n\tucon   = rd_regl(port, S3C2410_UCON);\n\tubrdiv = rd_regl(port, S3C2410_UBRDIV);\n\n\tif (s3c24xx_port_configured(ucon)) {\n\t\tswitch (ulcon & S3C2410_LCON_CSMASK) {\n\t\tcase S3C2410_LCON_CS5:\n\t\t\t*bits = 5;\n\t\t\tbreak;\n\t\tcase S3C2410_LCON_CS6:\n\t\t\t*bits = 6;\n\t\t\tbreak;\n\t\tcase S3C2410_LCON_CS7:\n\t\t\t*bits = 7;\n\t\t\tbreak;\n\t\tcase S3C2410_LCON_CS8:\n\t\tdefault:\n\t\t\t*bits = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ulcon & S3C2410_LCON_PMASK) {\n\t\tcase S3C2410_LCON_PEVEN:\n\t\t\t*parity = 'e';\n\t\t\tbreak;\n\n\t\tcase S3C2410_LCON_PODD:\n\t\t\t*parity = 'o';\n\t\t\tbreak;\n\n\t\tcase S3C2410_LCON_PNONE:\n\t\tdefault:\n\t\t\t*parity = 'n';\n\t\t}\n\n\t\t \n\n\t\tclk_sel = s3c24xx_serial_getsource(port);\n\t\tsprintf(clk_name, \"clk_uart_baud%d\", clk_sel);\n\n\t\tclk = clk_get(port->dev, clk_name);\n\t\tif (!IS_ERR(clk))\n\t\t\trate = clk_get_rate(clk);\n\t\telse\n\t\t\trate = 1;\n\n\t\t*baud = rate / (16 * (ubrdiv + 1));\n\t\tdev_dbg(port->dev, \"calculated baud %d\\n\", *baud);\n\t}\n}\n\n \nstatic int\ns3c24xx_serial_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\t \n\n\tif (co->index == -1 || co->index >= UART_NR)\n\t\tco->index = 0;\n\n\tport = &s3c24xx_serial_ports[co->index].port;\n\n\t \n\n\tif (port->mapbase == 0x0)\n\t\treturn -ENODEV;\n\n\tcons_uart = port;\n\n\t \n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse\n\t\ts3c24xx_serial_get_options(port, &baud, &parity, &bits);\n\n\tdev_dbg(port->dev, \"baud %d\\n\", baud);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct console s3c24xx_serial_console = {\n\t.name\t\t= S3C24XX_SERIAL_NAME,\n\t.device\t\t= uart_console_device,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.write\t\t= s3c24xx_serial_console_write,\n\t.setup\t\t= s3c24xx_serial_console_setup,\n\t.data\t\t= &s3c24xx_uart_drv,\n};\n#endif  \n\n#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)\nstatic const struct s3c24xx_serial_drv_data s3c6400_serial_drv_data = {\n\t.info = {\n\t\t.name\t\t= \"Samsung S3C6400 UART\",\n\t\t.type\t\t= TYPE_S3C6400,\n\t\t.port_type\t= PORT_S3C6400,\n\t\t.fifosize\t= 64,\n\t\t.has_divslot\t= 1,\n\t\t.rx_fifomask\t= S3C2440_UFSTAT_RXMASK,\n\t\t.rx_fifoshift\t= S3C2440_UFSTAT_RXSHIFT,\n\t\t.rx_fifofull\t= S3C2440_UFSTAT_RXFULL,\n\t\t.tx_fifofull\t= S3C2440_UFSTAT_TXFULL,\n\t\t.tx_fifomask\t= S3C2440_UFSTAT_TXMASK,\n\t\t.tx_fifoshift\t= S3C2440_UFSTAT_TXSHIFT,\n\t\t.def_clk_sel\t= S3C2410_UCON_CLKSEL2,\n\t\t.num_clks\t= 4,\n\t\t.clksel_mask\t= S3C6400_UCON_CLKMASK,\n\t\t.clksel_shift\t= S3C6400_UCON_CLKSHIFT,\n\t},\n\t.def_cfg = {\n\t\t.ucon\t\t= S3C2410_UCON_DEFAULT,\n\t\t.ufcon\t\t= S3C2410_UFCON_DEFAULT,\n\t},\n};\n#define S3C6400_SERIAL_DRV_DATA (&s3c6400_serial_drv_data)\n#else\n#define S3C6400_SERIAL_DRV_DATA NULL\n#endif\n\n#ifdef CONFIG_CPU_S5PV210\nstatic const struct s3c24xx_serial_drv_data s5pv210_serial_drv_data = {\n\t.info = {\n\t\t.name\t\t= \"Samsung S5PV210 UART\",\n\t\t.type\t\t= TYPE_S3C6400,\n\t\t.port_type\t= PORT_S3C6400,\n\t\t.has_divslot\t= 1,\n\t\t.rx_fifomask\t= S5PV210_UFSTAT_RXMASK,\n\t\t.rx_fifoshift\t= S5PV210_UFSTAT_RXSHIFT,\n\t\t.rx_fifofull\t= S5PV210_UFSTAT_RXFULL,\n\t\t.tx_fifofull\t= S5PV210_UFSTAT_TXFULL,\n\t\t.tx_fifomask\t= S5PV210_UFSTAT_TXMASK,\n\t\t.tx_fifoshift\t= S5PV210_UFSTAT_TXSHIFT,\n\t\t.def_clk_sel\t= S3C2410_UCON_CLKSEL0,\n\t\t.num_clks\t= 2,\n\t\t.clksel_mask\t= S5PV210_UCON_CLKMASK,\n\t\t.clksel_shift\t= S5PV210_UCON_CLKSHIFT,\n\t},\n\t.def_cfg = {\n\t\t.ucon\t\t= S5PV210_UCON_DEFAULT,\n\t\t.ufcon\t\t= S5PV210_UFCON_DEFAULT,\n\t},\n\t.fifosize = { 256, 64, 16, 16 },\n};\n#define S5PV210_SERIAL_DRV_DATA (&s5pv210_serial_drv_data)\n#else\n#define S5PV210_SERIAL_DRV_DATA\tNULL\n#endif\n\n#if defined(CONFIG_ARCH_EXYNOS)\n#define EXYNOS_COMMON_SERIAL_DRV_DATA()\t\t\t\t\\\n\t.info = {\t\t\t\t\t\t\\\n\t\t.name\t\t= \"Samsung Exynos UART\",\t\\\n\t\t.type\t\t= TYPE_S3C6400,\t\t\t\\\n\t\t.port_type\t= PORT_S3C6400,\t\t\t\\\n\t\t.has_divslot\t= 1,\t\t\t\t\\\n\t\t.rx_fifomask\t= S5PV210_UFSTAT_RXMASK,\t\\\n\t\t.rx_fifoshift\t= S5PV210_UFSTAT_RXSHIFT,\t\\\n\t\t.rx_fifofull\t= S5PV210_UFSTAT_RXFULL,\t\\\n\t\t.tx_fifofull\t= S5PV210_UFSTAT_TXFULL,\t\\\n\t\t.tx_fifomask\t= S5PV210_UFSTAT_TXMASK,\t\\\n\t\t.tx_fifoshift\t= S5PV210_UFSTAT_TXSHIFT,\t\\\n\t\t.def_clk_sel\t= S3C2410_UCON_CLKSEL0,\t\t\\\n\t\t.num_clks\t= 1,\t\t\t\t\\\n\t\t.clksel_mask\t= 0,\t\t\t\t\\\n\t\t.clksel_shift\t= 0,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.def_cfg = {\t\t\t\t\t\t\\\n\t\t.ucon\t\t= S5PV210_UCON_DEFAULT,\t\t\\\n\t\t.ufcon\t\t= S5PV210_UFCON_DEFAULT,\t\\\n\t\t.has_fracval\t= 1,\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\nstatic const struct s3c24xx_serial_drv_data exynos4210_serial_drv_data = {\n\tEXYNOS_COMMON_SERIAL_DRV_DATA(),\n\t.fifosize = { 256, 64, 16, 16 },\n};\n\nstatic const struct s3c24xx_serial_drv_data exynos5433_serial_drv_data = {\n\tEXYNOS_COMMON_SERIAL_DRV_DATA(),\n\t.fifosize = { 64, 256, 16, 256 },\n};\n\nstatic const struct s3c24xx_serial_drv_data exynos850_serial_drv_data = {\n\tEXYNOS_COMMON_SERIAL_DRV_DATA(),\n\t.fifosize = { 256, 64, 64, 64 },\n};\n\n#define EXYNOS4210_SERIAL_DRV_DATA (&exynos4210_serial_drv_data)\n#define EXYNOS5433_SERIAL_DRV_DATA (&exynos5433_serial_drv_data)\n#define EXYNOS850_SERIAL_DRV_DATA (&exynos850_serial_drv_data)\n\n#else\n#define EXYNOS4210_SERIAL_DRV_DATA NULL\n#define EXYNOS5433_SERIAL_DRV_DATA NULL\n#define EXYNOS850_SERIAL_DRV_DATA NULL\n#endif\n\n#ifdef CONFIG_ARCH_APPLE\nstatic const struct s3c24xx_serial_drv_data s5l_serial_drv_data = {\n\t.info = {\n\t\t.name\t\t= \"Apple S5L UART\",\n\t\t.type\t\t= TYPE_APPLE_S5L,\n\t\t.port_type\t= PORT_8250,\n\t\t.fifosize\t= 16,\n\t\t.rx_fifomask\t= S3C2410_UFSTAT_RXMASK,\n\t\t.rx_fifoshift\t= S3C2410_UFSTAT_RXSHIFT,\n\t\t.rx_fifofull\t= S3C2410_UFSTAT_RXFULL,\n\t\t.tx_fifofull\t= S3C2410_UFSTAT_TXFULL,\n\t\t.tx_fifomask\t= S3C2410_UFSTAT_TXMASK,\n\t\t.tx_fifoshift\t= S3C2410_UFSTAT_TXSHIFT,\n\t\t.def_clk_sel\t= S3C2410_UCON_CLKSEL0,\n\t\t.num_clks\t= 1,\n\t\t.clksel_mask\t= 0,\n\t\t.clksel_shift\t= 0,\n\t\t.ucon_mask\t= APPLE_S5L_UCON_MASK,\n\t},\n\t.def_cfg = {\n\t\t.ucon\t\t= APPLE_S5L_UCON_DEFAULT,\n\t\t.ufcon\t\t= S3C2410_UFCON_DEFAULT,\n\t},\n};\n#define S5L_SERIAL_DRV_DATA (&s5l_serial_drv_data)\n#else\n#define S5L_SERIAL_DRV_DATA NULL\n#endif\n\n#if defined(CONFIG_ARCH_ARTPEC)\nstatic const struct s3c24xx_serial_drv_data artpec8_serial_drv_data = {\n\t.info = {\n\t\t.name\t\t= \"Axis ARTPEC-8 UART\",\n\t\t.type\t\t= TYPE_S3C6400,\n\t\t.port_type\t= PORT_S3C6400,\n\t\t.fifosize\t= 64,\n\t\t.has_divslot\t= 1,\n\t\t.rx_fifomask\t= S5PV210_UFSTAT_RXMASK,\n\t\t.rx_fifoshift\t= S5PV210_UFSTAT_RXSHIFT,\n\t\t.rx_fifofull\t= S5PV210_UFSTAT_RXFULL,\n\t\t.tx_fifofull\t= S5PV210_UFSTAT_TXFULL,\n\t\t.tx_fifomask\t= S5PV210_UFSTAT_TXMASK,\n\t\t.tx_fifoshift\t= S5PV210_UFSTAT_TXSHIFT,\n\t\t.def_clk_sel\t= S3C2410_UCON_CLKSEL0,\n\t\t.num_clks\t= 1,\n\t\t.clksel_mask\t= 0,\n\t\t.clksel_shift\t= 0,\n\t},\n\t.def_cfg = {\n\t\t.ucon\t\t= S5PV210_UCON_DEFAULT,\n\t\t.ufcon\t\t= S5PV210_UFCON_DEFAULT,\n\t\t.has_fracval\t= 1,\n\t}\n};\n#define ARTPEC8_SERIAL_DRV_DATA (&artpec8_serial_drv_data)\n#else\n#define ARTPEC8_SERIAL_DRV_DATA (NULL)\n#endif\n\nstatic const struct platform_device_id s3c24xx_serial_driver_ids[] = {\n\t{\n\t\t.name\t\t= \"s3c6400-uart\",\n\t\t.driver_data\t= (kernel_ulong_t)S3C6400_SERIAL_DRV_DATA,\n\t}, {\n\t\t.name\t\t= \"s5pv210-uart\",\n\t\t.driver_data\t= (kernel_ulong_t)S5PV210_SERIAL_DRV_DATA,\n\t}, {\n\t\t.name\t\t= \"exynos4210-uart\",\n\t\t.driver_data\t= (kernel_ulong_t)EXYNOS4210_SERIAL_DRV_DATA,\n\t}, {\n\t\t.name\t\t= \"exynos5433-uart\",\n\t\t.driver_data\t= (kernel_ulong_t)EXYNOS5433_SERIAL_DRV_DATA,\n\t}, {\n\t\t.name\t\t= \"s5l-uart\",\n\t\t.driver_data\t= (kernel_ulong_t)S5L_SERIAL_DRV_DATA,\n\t}, {\n\t\t.name\t\t= \"exynos850-uart\",\n\t\t.driver_data\t= (kernel_ulong_t)EXYNOS850_SERIAL_DRV_DATA,\n\t}, {\n\t\t.name\t\t= \"artpec8-uart\",\n\t\t.driver_data\t= (kernel_ulong_t)ARTPEC8_SERIAL_DRV_DATA,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, s3c24xx_serial_driver_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id s3c24xx_uart_dt_match[] = {\n\t{ .compatible = \"samsung,s3c6400-uart\",\n\t\t.data = S3C6400_SERIAL_DRV_DATA },\n\t{ .compatible = \"samsung,s5pv210-uart\",\n\t\t.data = S5PV210_SERIAL_DRV_DATA },\n\t{ .compatible = \"samsung,exynos4210-uart\",\n\t\t.data = EXYNOS4210_SERIAL_DRV_DATA },\n\t{ .compatible = \"samsung,exynos5433-uart\",\n\t\t.data = EXYNOS5433_SERIAL_DRV_DATA },\n\t{ .compatible = \"apple,s5l-uart\",\n\t\t.data = S5L_SERIAL_DRV_DATA },\n\t{ .compatible = \"samsung,exynos850-uart\",\n\t\t.data = EXYNOS850_SERIAL_DRV_DATA },\n\t{ .compatible = \"axis,artpec8-uart\",\n\t\t.data = ARTPEC8_SERIAL_DRV_DATA },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, s3c24xx_uart_dt_match);\n#endif\n\nstatic struct platform_driver samsung_serial_driver = {\n\t.probe\t\t= s3c24xx_serial_probe,\n\t.remove\t\t= s3c24xx_serial_remove,\n\t.id_table\t= s3c24xx_serial_driver_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"samsung-uart\",\n\t\t.pm\t= SERIAL_SAMSUNG_PM_OPS,\n\t\t.of_match_table\t= of_match_ptr(s3c24xx_uart_dt_match),\n\t},\n};\n\nstatic int __init samsung_serial_init(void)\n{\n\tint ret;\n\n\ts3c24xx_serial_register_console();\n\n\tret = platform_driver_register(&samsung_serial_driver);\n\tif (ret) {\n\t\ts3c24xx_serial_unregister_console();\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit samsung_serial_exit(void)\n{\n\tplatform_driver_unregister(&samsung_serial_driver);\n\ts3c24xx_serial_unregister_console();\n}\n\nmodule_init(samsung_serial_init);\nmodule_exit(samsung_serial_exit);\n\n#ifdef CONFIG_SERIAL_SAMSUNG_CONSOLE\n \n\nstatic void wr_reg_barrier(const struct uart_port *port, u32 reg, u32 val)\n{\n\tswitch (port->iotype) {\n\tcase UPIO_MEM:\n\t\twriteb(val, portaddr(port, reg));\n\t\tbreak;\n\tcase UPIO_MEM32:\n\t\twritel(val, portaddr(port, reg));\n\t\tbreak;\n\t}\n}\n\nstruct samsung_early_console_data {\n\tu32 txfull_mask;\n\tu32 rxfifo_mask;\n};\n\nstatic void samsung_early_busyuart(const struct uart_port *port)\n{\n\twhile (!(readl(port->membase + S3C2410_UTRSTAT) & S3C2410_UTRSTAT_TXFE))\n\t\t;\n}\n\nstatic void samsung_early_busyuart_fifo(const struct uart_port *port)\n{\n\tconst struct samsung_early_console_data *data = port->private_data;\n\n\twhile (readl(port->membase + S3C2410_UFSTAT) & data->txfull_mask)\n\t\t;\n}\n\nstatic void samsung_early_putc(struct uart_port *port, unsigned char c)\n{\n\tif (readl(port->membase + S3C2410_UFCON) & S3C2410_UFCON_FIFOMODE)\n\t\tsamsung_early_busyuart_fifo(port);\n\telse\n\t\tsamsung_early_busyuart(port);\n\n\twr_reg_barrier(port, S3C2410_UTXH, c);\n}\n\nstatic void samsung_early_write(struct console *con, const char *s,\n\t\t\t\tunsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, samsung_early_putc);\n}\n\nstatic int samsung_early_read(struct console *con, char *s, unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\tconst struct samsung_early_console_data *data = dev->port.private_data;\n\tint ch, ufstat, num_read = 0;\n\n\twhile (num_read < n) {\n\t\tufstat = rd_regl(&dev->port, S3C2410_UFSTAT);\n\t\tif (!(ufstat & data->rxfifo_mask))\n\t\t\tbreak;\n\t\tch = rd_reg(&dev->port, S3C2410_URXH);\n\t\tif (ch == NO_POLL_CHAR)\n\t\t\tbreak;\n\n\t\ts[num_read++] = ch;\n\t}\n\n\treturn num_read;\n}\n\nstatic int __init samsung_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t      const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = samsung_early_write;\n\tdevice->con->read = samsung_early_read;\n\treturn 0;\n}\n\n \nstatic struct samsung_early_console_data s3c2410_early_console_data = {\n\t.txfull_mask = S3C2410_UFSTAT_TXFULL,\n\t.rxfifo_mask = S3C2410_UFSTAT_RXFULL | S3C2410_UFSTAT_RXMASK,\n};\n\nstatic int __init s3c2410_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t      const char *opt)\n{\n\tdevice->port.private_data = &s3c2410_early_console_data;\n\treturn samsung_early_console_setup(device, opt);\n}\n\nOF_EARLYCON_DECLARE(s3c2410, \"samsung,s3c2410-uart\",\n\t\t\ts3c2410_early_console_setup);\n\n \nstatic struct samsung_early_console_data s3c2440_early_console_data = {\n\t.txfull_mask = S3C2440_UFSTAT_TXFULL,\n\t.rxfifo_mask = S3C2440_UFSTAT_RXFULL | S3C2440_UFSTAT_RXMASK,\n};\n\nstatic int __init s3c2440_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t      const char *opt)\n{\n\tdevice->port.private_data = &s3c2440_early_console_data;\n\treturn samsung_early_console_setup(device, opt);\n}\n\nOF_EARLYCON_DECLARE(s3c2412, \"samsung,s3c2412-uart\",\n\t\t\ts3c2440_early_console_setup);\nOF_EARLYCON_DECLARE(s3c2440, \"samsung,s3c2440-uart\",\n\t\t\ts3c2440_early_console_setup);\nOF_EARLYCON_DECLARE(s3c6400, \"samsung,s3c6400-uart\",\n\t\t\ts3c2440_early_console_setup);\n\n \nstatic struct samsung_early_console_data s5pv210_early_console_data = {\n\t.txfull_mask = S5PV210_UFSTAT_TXFULL,\n\t.rxfifo_mask = S5PV210_UFSTAT_RXFULL | S5PV210_UFSTAT_RXMASK,\n};\n\nstatic int __init s5pv210_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t      const char *opt)\n{\n\tdevice->port.private_data = &s5pv210_early_console_data;\n\treturn samsung_early_console_setup(device, opt);\n}\n\nOF_EARLYCON_DECLARE(s5pv210, \"samsung,s5pv210-uart\",\n\t\t\ts5pv210_early_console_setup);\nOF_EARLYCON_DECLARE(exynos4210, \"samsung,exynos4210-uart\",\n\t\t\ts5pv210_early_console_setup);\nOF_EARLYCON_DECLARE(artpec8, \"axis,artpec8-uart\",\n\t\t\ts5pv210_early_console_setup);\n\n \nstatic int __init apple_s5l_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t\tconst char *opt)\n{\n\t \n\tdevice->port.private_data = &s3c2410_early_console_data;\n\n#ifdef CONFIG_ARM64\n\t \n\t__set_fixmap(FIX_EARLYCON_MEM_BASE, device->port.mapbase,\n\t\t     __pgprot(PROT_DEVICE_nGnRnE));\n#endif\n\treturn samsung_early_console_setup(device, opt);\n}\n\nOF_EARLYCON_DECLARE(s5l, \"apple,s5l-uart\", apple_s5l_early_console_setup);\n#endif\n\nMODULE_ALIAS(\"platform:samsung-uart\");\nMODULE_DESCRIPTION(\"Samsung SoC Serial port driver\");\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}