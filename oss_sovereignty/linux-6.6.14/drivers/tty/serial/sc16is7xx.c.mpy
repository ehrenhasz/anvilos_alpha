{
  "module_name": "sc16is7xx.c",
  "hash_id": "0f03db8caf906cc32386a857102bcd9920a090539a1217e1e617af3157b951ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sc16is7xx.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/spi/spi.h>\n#include <linux/uaccess.h>\n#include <linux/units.h>\n#include <uapi/linux/sched/types.h>\n\n#define SC16IS7XX_NAME\t\t\t\"sc16is7xx\"\n#define SC16IS7XX_MAX_DEVS\t\t8\n\n \n#define SC16IS7XX_RHR_REG\t\t(0x00)  \n#define SC16IS7XX_THR_REG\t\t(0x00)  \n#define SC16IS7XX_IER_REG\t\t(0x01)  \n#define SC16IS7XX_IIR_REG\t\t(0x02)  \n#define SC16IS7XX_FCR_REG\t\t(0x02)  \n#define SC16IS7XX_LCR_REG\t\t(0x03)  \n#define SC16IS7XX_MCR_REG\t\t(0x04)  \n#define SC16IS7XX_LSR_REG\t\t(0x05)  \n#define SC16IS7XX_MSR_REG\t\t(0x06)  \n#define SC16IS7XX_SPR_REG\t\t(0x07)  \n#define SC16IS7XX_TXLVL_REG\t\t(0x08)  \n#define SC16IS7XX_RXLVL_REG\t\t(0x09)  \n#define SC16IS7XX_IODIR_REG\t\t(0x0a)  \n#define SC16IS7XX_IOSTATE_REG\t\t(0x0b)  \n#define SC16IS7XX_IOINTENA_REG\t\t(0x0c)  \n#define SC16IS7XX_IOCONTROL_REG\t\t(0x0e)  \n#define SC16IS7XX_EFCR_REG\t\t(0x0f)  \n\n \n#define SC16IS7XX_TCR_REG\t\t(0x06)  \n#define SC16IS7XX_TLR_REG\t\t(0x07)  \n\n \n#define SC16IS7XX_DLL_REG\t\t(0x00)  \n#define SC16IS7XX_DLH_REG\t\t(0x01)  \n\n \n#define SC16IS7XX_EFR_REG\t\t(0x02)  \n#define SC16IS7XX_XON1_REG\t\t(0x04)  \n#define SC16IS7XX_XON2_REG\t\t(0x05)  \n#define SC16IS7XX_XOFF1_REG\t\t(0x06)  \n#define SC16IS7XX_XOFF2_REG\t\t(0x07)  \n\n \n#define SC16IS7XX_IER_RDI_BIT\t\t(1 << 0)  \n#define SC16IS7XX_IER_THRI_BIT\t\t(1 << 1)  \n#define SC16IS7XX_IER_RLSI_BIT\t\t(1 << 2)  \n#define SC16IS7XX_IER_MSI_BIT\t\t(1 << 3)  \n\n \n#define SC16IS7XX_IER_SLEEP_BIT\t\t(1 << 4)  \n#define SC16IS7XX_IER_XOFFI_BIT\t\t(1 << 5)  \n#define SC16IS7XX_IER_RTSI_BIT\t\t(1 << 6)  \n#define SC16IS7XX_IER_CTSI_BIT\t\t(1 << 7)  \n\n \n#define SC16IS7XX_FCR_FIFO_BIT\t\t(1 << 0)  \n#define SC16IS7XX_FCR_RXRESET_BIT\t(1 << 1)  \n#define SC16IS7XX_FCR_TXRESET_BIT\t(1 << 2)  \n#define SC16IS7XX_FCR_RXLVLL_BIT\t(1 << 6)  \n#define SC16IS7XX_FCR_RXLVLH_BIT\t(1 << 7)  \n\n \n#define SC16IS7XX_FCR_TXLVLL_BIT\t(1 << 4)  \n#define SC16IS7XX_FCR_TXLVLH_BIT\t(1 << 5)  \n\n \n#define SC16IS7XX_IIR_NO_INT_BIT\t(1 << 0)  \n#define SC16IS7XX_IIR_ID_MASK\t\t0x3e      \n#define SC16IS7XX_IIR_THRI_SRC\t\t0x02      \n#define SC16IS7XX_IIR_RDI_SRC\t\t0x04      \n#define SC16IS7XX_IIR_RLSE_SRC\t\t0x06      \n#define SC16IS7XX_IIR_RTOI_SRC\t\t0x0c      \n#define SC16IS7XX_IIR_MSI_SRC\t\t0x00      \n#define SC16IS7XX_IIR_INPIN_SRC\t\t0x30      \n#define SC16IS7XX_IIR_XOFFI_SRC\t\t0x10      \n#define SC16IS7XX_IIR_CTSRTS_SRC\t0x20      \n \n#define SC16IS7XX_LCR_LENGTH0_BIT\t(1 << 0)  \n#define SC16IS7XX_LCR_LENGTH1_BIT\t(1 << 1)  \n#define SC16IS7XX_LCR_STOPLEN_BIT\t(1 << 2)  \n#define SC16IS7XX_LCR_PARITY_BIT\t(1 << 3)  \n#define SC16IS7XX_LCR_EVENPARITY_BIT\t(1 << 4)  \n#define SC16IS7XX_LCR_FORCEPARITY_BIT\t(1 << 5)  \n#define SC16IS7XX_LCR_TXBREAK_BIT\t(1 << 6)  \n#define SC16IS7XX_LCR_DLAB_BIT\t\t(1 << 7)  \n#define SC16IS7XX_LCR_WORD_LEN_5\t(0x00)\n#define SC16IS7XX_LCR_WORD_LEN_6\t(0x01)\n#define SC16IS7XX_LCR_WORD_LEN_7\t(0x02)\n#define SC16IS7XX_LCR_WORD_LEN_8\t(0x03)\n#define SC16IS7XX_LCR_CONF_MODE_A\tSC16IS7XX_LCR_DLAB_BIT  \n#define SC16IS7XX_LCR_CONF_MODE_B\t0xBF                    \n\n \n#define SC16IS7XX_MCR_DTR_BIT\t\t(1 << 0)  \n#define SC16IS7XX_MCR_RTS_BIT\t\t(1 << 1)  \n#define SC16IS7XX_MCR_TCRTLR_BIT\t(1 << 2)  \n#define SC16IS7XX_MCR_LOOP_BIT\t\t(1 << 4)  \n#define SC16IS7XX_MCR_XONANY_BIT\t(1 << 5)  \n#define SC16IS7XX_MCR_IRDA_BIT\t\t(1 << 6)  \n#define SC16IS7XX_MCR_CLKSEL_BIT\t(1 << 7)  \n\n \n#define SC16IS7XX_LSR_DR_BIT\t\t(1 << 0)  \n#define SC16IS7XX_LSR_OE_BIT\t\t(1 << 1)  \n#define SC16IS7XX_LSR_PE_BIT\t\t(1 << 2)  \n#define SC16IS7XX_LSR_FE_BIT\t\t(1 << 3)  \n#define SC16IS7XX_LSR_BI_BIT\t\t(1 << 4)  \n#define SC16IS7XX_LSR_BRK_ERROR_MASK\t0x1E      \n#define SC16IS7XX_LSR_THRE_BIT\t\t(1 << 5)  \n#define SC16IS7XX_LSR_TEMT_BIT\t\t(1 << 6)  \n#define SC16IS7XX_LSR_FIFOE_BIT\t\t(1 << 7)  \n\n \n#define SC16IS7XX_MSR_DCTS_BIT\t\t(1 << 0)  \n#define SC16IS7XX_MSR_DDSR_BIT\t\t(1 << 1)  \n#define SC16IS7XX_MSR_DRI_BIT\t\t(1 << 2)  \n#define SC16IS7XX_MSR_DCD_BIT\t\t(1 << 3)  \n#define SC16IS7XX_MSR_CTS_BIT\t\t(1 << 4)  \n#define SC16IS7XX_MSR_DSR_BIT\t\t(1 << 5)  \n#define SC16IS7XX_MSR_RI_BIT\t\t(1 << 6)  \n#define SC16IS7XX_MSR_CD_BIT\t\t(1 << 7)  \n#define SC16IS7XX_MSR_DELTA_MASK\t0x0F      \n\n \n#define SC16IS7XX_TCR_RX_HALT(words)\t((((words) / 4) & 0x0f) << 0)\n#define SC16IS7XX_TCR_RX_RESUME(words)\t((((words) / 4) & 0x0f) << 4)\n\n \n#define SC16IS7XX_TLR_TX_TRIGGER(words)\t((((words) / 4) & 0x0f) << 0)\n#define SC16IS7XX_TLR_RX_TRIGGER(words)\t((((words) / 4) & 0x0f) << 4)\n\n \n#define SC16IS7XX_IOCONTROL_LATCH_BIT\t(1 << 0)  \n#define SC16IS7XX_IOCONTROL_MODEM_A_BIT\t(1 << 1)  \n#define SC16IS7XX_IOCONTROL_MODEM_B_BIT\t(1 << 2)  \n#define SC16IS7XX_IOCONTROL_SRESET_BIT\t(1 << 3)  \n\n \n#define SC16IS7XX_EFCR_9BIT_MODE_BIT\t(1 << 0)  \n#define SC16IS7XX_EFCR_RXDISABLE_BIT\t(1 << 1)  \n#define SC16IS7XX_EFCR_TXDISABLE_BIT\t(1 << 2)  \n#define SC16IS7XX_EFCR_AUTO_RS485_BIT\t(1 << 4)  \n#define SC16IS7XX_EFCR_RTS_INVERT_BIT\t(1 << 5)  \n#define SC16IS7XX_EFCR_IRDA_MODE_BIT\t(1 << 7)  \n\n \n#define SC16IS7XX_EFR_AUTORTS_BIT\t(1 << 6)  \n#define SC16IS7XX_EFR_AUTOCTS_BIT\t(1 << 7)  \n#define SC16IS7XX_EFR_XOFF2_DETECT_BIT\t(1 << 5)  \n#define SC16IS7XX_EFR_ENABLE_BIT\t(1 << 4)  \n#define SC16IS7XX_EFR_SWFLOW3_BIT\t(1 << 3)  \n#define SC16IS7XX_EFR_SWFLOW2_BIT\t(1 << 2)  \n#define SC16IS7XX_EFR_SWFLOW1_BIT\t(1 << 1)  \n#define SC16IS7XX_EFR_SWFLOW0_BIT\t(1 << 0)  \n#define SC16IS7XX_EFR_FLOWCTRL_BITS\t(SC16IS7XX_EFR_AUTORTS_BIT | \\\n\t\t\t\t\tSC16IS7XX_EFR_AUTOCTS_BIT | \\\n\t\t\t\t\tSC16IS7XX_EFR_XOFF2_DETECT_BIT | \\\n\t\t\t\t\tSC16IS7XX_EFR_SWFLOW3_BIT | \\\n\t\t\t\t\tSC16IS7XX_EFR_SWFLOW2_BIT | \\\n\t\t\t\t\tSC16IS7XX_EFR_SWFLOW1_BIT | \\\n\t\t\t\t\tSC16IS7XX_EFR_SWFLOW0_BIT)\n\n\n \n#define SC16IS7XX_FIFO_SIZE\t\t(64)\n#define SC16IS7XX_REG_SHIFT\t\t2\n#define SC16IS7XX_GPIOS_PER_BANK\t4\n\nstruct sc16is7xx_devtype {\n\tchar\tname[10];\n\tint\tnr_gpio;\n\tint\tnr_uart;\n};\n\n#define SC16IS7XX_RECONF_MD\t\t(1 << 0)\n#define SC16IS7XX_RECONF_IER\t\t(1 << 1)\n#define SC16IS7XX_RECONF_RS485\t\t(1 << 2)\n\nstruct sc16is7xx_one_config {\n\tunsigned int\t\t\tflags;\n\tu8\t\t\t\tier_mask;\n\tu8\t\t\t\tier_val;\n};\n\nstruct sc16is7xx_one {\n\tstruct uart_port\t\tport;\n\tu8\t\t\t\tline;\n\tstruct kthread_work\t\ttx_work;\n\tstruct kthread_work\t\treg_work;\n\tstruct kthread_delayed_work\tms_work;\n\tstruct sc16is7xx_one_config\tconfig;\n\tbool\t\t\t\tirda_mode;\n\tunsigned int\t\t\told_mctrl;\n};\n\nstruct sc16is7xx_port {\n\tconst struct sc16is7xx_devtype\t*devtype;\n\tstruct regmap\t\t\t*regmap;\n\tstruct clk\t\t\t*clk;\n#ifdef CONFIG_GPIOLIB\n\tstruct gpio_chip\t\tgpio;\n\tunsigned long\t\t\tgpio_valid_mask;\n#endif\n\tu8\t\t\t\tmctrl_mask;\n\tunsigned char\t\t\tbuf[SC16IS7XX_FIFO_SIZE];\n\tstruct kthread_worker\t\tkworker;\n\tstruct task_struct\t\t*kworker_task;\n\tstruct mutex\t\t\tefr_lock;\n\tstruct sc16is7xx_one\t\tp[];\n};\n\nstatic unsigned long sc16is7xx_lines;\n\nstatic struct uart_driver sc16is7xx_uart = {\n\t.owner\t\t= THIS_MODULE,\n\t.dev_name\t= \"ttySC\",\n\t.nr\t\t= SC16IS7XX_MAX_DEVS,\n};\n\nstatic void sc16is7xx_ier_set(struct uart_port *port, u8 bit);\nstatic void sc16is7xx_stop_tx(struct uart_port *port);\n\n#define to_sc16is7xx_port(p,e)\t((container_of((p), struct sc16is7xx_port, e)))\n#define to_sc16is7xx_one(p,e)\t((container_of((p), struct sc16is7xx_one, e)))\n\nstatic int sc16is7xx_line(struct uart_port *port)\n{\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\n\treturn one->line;\n}\n\nstatic u8 sc16is7xx_port_read(struct uart_port *port, u8 reg)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tunsigned int val = 0;\n\tconst u8 line = sc16is7xx_line(port);\n\n\tregmap_read(s->regmap, (reg << SC16IS7XX_REG_SHIFT) | line, &val);\n\n\treturn val;\n}\n\nstatic void sc16is7xx_port_write(struct uart_port *port, u8 reg, u8 val)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tconst u8 line = sc16is7xx_line(port);\n\n\tregmap_write(s->regmap, (reg << SC16IS7XX_REG_SHIFT) | line, val);\n}\n\nstatic void sc16is7xx_fifo_read(struct uart_port *port, unsigned int rxlen)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tconst u8 line = sc16is7xx_line(port);\n\tu8 addr = (SC16IS7XX_RHR_REG << SC16IS7XX_REG_SHIFT) | line;\n\n\tregcache_cache_bypass(s->regmap, true);\n\tregmap_raw_read(s->regmap, addr, s->buf, rxlen);\n\tregcache_cache_bypass(s->regmap, false);\n}\n\nstatic void sc16is7xx_fifo_write(struct uart_port *port, u8 to_send)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tconst u8 line = sc16is7xx_line(port);\n\tu8 addr = (SC16IS7XX_THR_REG << SC16IS7XX_REG_SHIFT) | line;\n\n\t \n\tif (unlikely(!to_send))\n\t\treturn;\n\n\tregcache_cache_bypass(s->regmap, true);\n\tregmap_raw_write(s->regmap, addr, s->buf, to_send);\n\tregcache_cache_bypass(s->regmap, false);\n}\n\nstatic void sc16is7xx_port_update(struct uart_port *port, u8 reg,\n\t\t\t\t  u8 mask, u8 val)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tconst u8 line = sc16is7xx_line(port);\n\n\tregmap_update_bits(s->regmap, (reg << SC16IS7XX_REG_SHIFT) | line,\n\t\t\t   mask, val);\n}\n\nstatic int sc16is7xx_alloc_line(void)\n{\n\tint i;\n\n\tBUILD_BUG_ON(SC16IS7XX_MAX_DEVS > BITS_PER_LONG);\n\n\tfor (i = 0; i < SC16IS7XX_MAX_DEVS; i++)\n\t\tif (!test_and_set_bit(i, &sc16is7xx_lines))\n\t\t\tbreak;\n\n\treturn i;\n}\n\nstatic void sc16is7xx_power(struct uart_port *port, int on)\n{\n\tsc16is7xx_port_update(port, SC16IS7XX_IER_REG,\n\t\t\t      SC16IS7XX_IER_SLEEP_BIT,\n\t\t\t      on ? 0 : SC16IS7XX_IER_SLEEP_BIT);\n}\n\nstatic const struct sc16is7xx_devtype sc16is74x_devtype = {\n\t.name\t\t= \"SC16IS74X\",\n\t.nr_gpio\t= 0,\n\t.nr_uart\t= 1,\n};\n\nstatic const struct sc16is7xx_devtype sc16is750_devtype = {\n\t.name\t\t= \"SC16IS750\",\n\t.nr_gpio\t= 8,\n\t.nr_uart\t= 1,\n};\n\nstatic const struct sc16is7xx_devtype sc16is752_devtype = {\n\t.name\t\t= \"SC16IS752\",\n\t.nr_gpio\t= 8,\n\t.nr_uart\t= 2,\n};\n\nstatic const struct sc16is7xx_devtype sc16is760_devtype = {\n\t.name\t\t= \"SC16IS760\",\n\t.nr_gpio\t= 8,\n\t.nr_uart\t= 1,\n};\n\nstatic const struct sc16is7xx_devtype sc16is762_devtype = {\n\t.name\t\t= \"SC16IS762\",\n\t.nr_gpio\t= 8,\n\t.nr_uart\t= 2,\n};\n\nstatic bool sc16is7xx_regmap_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg >> SC16IS7XX_REG_SHIFT) {\n\tcase SC16IS7XX_RHR_REG:\n\tcase SC16IS7XX_IIR_REG:\n\tcase SC16IS7XX_LSR_REG:\n\tcase SC16IS7XX_MSR_REG:\n\tcase SC16IS7XX_TXLVL_REG:\n\tcase SC16IS7XX_RXLVL_REG:\n\tcase SC16IS7XX_IOSTATE_REG:\n\tcase SC16IS7XX_IOCONTROL_REG:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool sc16is7xx_regmap_precious(struct device *dev, unsigned int reg)\n{\n\tswitch (reg >> SC16IS7XX_REG_SHIFT) {\n\tcase SC16IS7XX_RHR_REG:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic int sc16is7xx_set_baud(struct uart_port *port, int baud)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tu8 lcr;\n\tu8 prescaler = 0;\n\tunsigned long clk = port->uartclk, div = clk / 16 / baud;\n\n\tif (div > 0xffff) {\n\t\tprescaler = SC16IS7XX_MCR_CLKSEL_BIT;\n\t\tdiv /= 4;\n\t}\n\n\t \n\tmutex_lock(&s->efr_lock);\n\n\tlcr = sc16is7xx_port_read(port, SC16IS7XX_LCR_REG);\n\n\t \n\tsc16is7xx_port_write(port, SC16IS7XX_LCR_REG,\n\t\t\t     SC16IS7XX_LCR_CONF_MODE_B);\n\n\t \n\tregcache_cache_bypass(s->regmap, true);\n\tsc16is7xx_port_update(port, SC16IS7XX_EFR_REG,\n\t\t\t      SC16IS7XX_EFR_ENABLE_BIT,\n\t\t\t      SC16IS7XX_EFR_ENABLE_BIT);\n\n\tregcache_cache_bypass(s->regmap, false);\n\n\t \n\tsc16is7xx_port_write(port, SC16IS7XX_LCR_REG, lcr);\n\n\tmutex_unlock(&s->efr_lock);\n\n\tsc16is7xx_port_update(port, SC16IS7XX_MCR_REG,\n\t\t\t      SC16IS7XX_MCR_CLKSEL_BIT,\n\t\t\t      prescaler);\n\n\t \n\tsc16is7xx_port_write(port, SC16IS7XX_LCR_REG,\n\t\t\t     SC16IS7XX_LCR_CONF_MODE_A);\n\n\t \n\tregcache_cache_bypass(s->regmap, true);\n\tsc16is7xx_port_write(port, SC16IS7XX_DLH_REG, div / 256);\n\tsc16is7xx_port_write(port, SC16IS7XX_DLL_REG, div % 256);\n\tregcache_cache_bypass(s->regmap, false);\n\n\t \n\tsc16is7xx_port_write(port, SC16IS7XX_LCR_REG, lcr);\n\n\treturn DIV_ROUND_CLOSEST(clk / 16, div);\n}\n\nstatic void sc16is7xx_handle_rx(struct uart_port *port, unsigned int rxlen,\n\t\t\t\tunsigned int iir)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tunsigned int lsr = 0, bytes_read, i;\n\tbool read_lsr = (iir == SC16IS7XX_IIR_RLSE_SRC) ? true : false;\n\tu8 ch, flag;\n\n\tif (unlikely(rxlen >= sizeof(s->buf))) {\n\t\tdev_warn_ratelimited(port->dev,\n\t\t\t\t     \"ttySC%i: Possible RX FIFO overrun: %d\\n\",\n\t\t\t\t     port->line, rxlen);\n\t\tport->icount.buf_overrun++;\n\t\t \n\t\trxlen = sizeof(s->buf);\n\t}\n\n\twhile (rxlen) {\n\t\t \n\t\tif (read_lsr) {\n\t\t\tlsr = sc16is7xx_port_read(port, SC16IS7XX_LSR_REG);\n\t\t\tif (!(lsr & SC16IS7XX_LSR_FIFOE_BIT))\n\t\t\t\tread_lsr = false;  \n\t\t} else\n\t\t\tlsr = 0;\n\n\t\tif (read_lsr) {\n\t\t\ts->buf[0] = sc16is7xx_port_read(port, SC16IS7XX_RHR_REG);\n\t\t\tbytes_read = 1;\n\t\t} else {\n\t\t\tsc16is7xx_fifo_read(port, rxlen);\n\t\t\tbytes_read = rxlen;\n\t\t}\n\n\t\tlsr &= SC16IS7XX_LSR_BRK_ERROR_MASK;\n\n\t\tport->icount.rx++;\n\t\tflag = TTY_NORMAL;\n\n\t\tif (unlikely(lsr)) {\n\t\t\tif (lsr & SC16IS7XX_LSR_BI_BIT) {\n\t\t\t\tport->icount.brk++;\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (lsr & SC16IS7XX_LSR_PE_BIT)\n\t\t\t\tport->icount.parity++;\n\t\t\telse if (lsr & SC16IS7XX_LSR_FE_BIT)\n\t\t\t\tport->icount.frame++;\n\t\t\telse if (lsr & SC16IS7XX_LSR_OE_BIT)\n\t\t\t\tport->icount.overrun++;\n\n\t\t\tlsr &= port->read_status_mask;\n\t\t\tif (lsr & SC16IS7XX_LSR_BI_BIT)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (lsr & SC16IS7XX_LSR_PE_BIT)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (lsr & SC16IS7XX_LSR_FE_BIT)\n\t\t\t\tflag = TTY_FRAME;\n\t\t\telse if (lsr & SC16IS7XX_LSR_OE_BIT)\n\t\t\t\tflag = TTY_OVERRUN;\n\t\t}\n\n\t\tfor (i = 0; i < bytes_read; ++i) {\n\t\t\tch = s->buf[i];\n\t\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\t\tcontinue;\n\n\t\t\tif (lsr & port->ignore_status_mask)\n\t\t\t\tcontinue;\n\n\t\t\tuart_insert_char(port, lsr, SC16IS7XX_LSR_OE_BIT, ch,\n\t\t\t\t\t flag);\n\t\t}\n\t\trxlen -= bytes_read;\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic void sc16is7xx_handle_tx(struct uart_port *port)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned int txlen, to_send, i;\n\tunsigned long flags;\n\n\tif (unlikely(port->x_char)) {\n\t\tsc16is7xx_port_write(port, SC16IS7XX_THR_REG, port->x_char);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tsc16is7xx_stop_tx(port);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tto_send = uart_circ_chars_pending(xmit);\n\tif (likely(to_send)) {\n\t\t \n\t\ttxlen = sc16is7xx_port_read(port, SC16IS7XX_TXLVL_REG);\n\t\tif (txlen > SC16IS7XX_FIFO_SIZE) {\n\t\t\tdev_err_ratelimited(port->dev,\n\t\t\t\t\"chip reports %d free bytes in TX fifo, but it only has %d\",\n\t\t\t\ttxlen, SC16IS7XX_FIFO_SIZE);\n\t\t\ttxlen = 0;\n\t\t}\n\t\tto_send = (to_send > txlen) ? txlen : to_send;\n\n\t\t \n\t\tfor (i = 0; i < to_send; ++i) {\n\t\t\ts->buf[i] = xmit->buf[xmit->tail];\n\t\t\tuart_xmit_advance(port, 1);\n\t\t}\n\n\t\tsc16is7xx_fifo_write(port, to_send);\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (uart_circ_empty(xmit))\n\t\tsc16is7xx_stop_tx(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic unsigned int sc16is7xx_get_hwmctrl(struct uart_port *port)\n{\n\tu8 msr = sc16is7xx_port_read(port, SC16IS7XX_MSR_REG);\n\tunsigned int mctrl = 0;\n\n\tmctrl |= (msr & SC16IS7XX_MSR_CTS_BIT) ? TIOCM_CTS : 0;\n\tmctrl |= (msr & SC16IS7XX_MSR_DSR_BIT) ? TIOCM_DSR : 0;\n\tmctrl |= (msr & SC16IS7XX_MSR_CD_BIT)  ? TIOCM_CAR : 0;\n\tmctrl |= (msr & SC16IS7XX_MSR_RI_BIT)  ? TIOCM_RNG : 0;\n\treturn mctrl;\n}\n\nstatic void sc16is7xx_update_mlines(struct sc16is7xx_one *one)\n{\n\tstruct uart_port *port = &one->port;\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tunsigned long flags;\n\tunsigned int status, changed;\n\n\tlockdep_assert_held_once(&s->efr_lock);\n\n\tstatus = sc16is7xx_get_hwmctrl(port);\n\tchanged = status ^ one->old_mctrl;\n\n\tif (changed == 0)\n\t\treturn;\n\n\tone->old_mctrl = status;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif ((changed & TIOCM_RNG) && (status & TIOCM_RNG))\n\t\tport->icount.rng++;\n\tif (changed & TIOCM_DSR)\n\t\tport->icount.dsr++;\n\tif (changed & TIOCM_CAR)\n\t\tuart_handle_dcd_change(port, status & TIOCM_CAR);\n\tif (changed & TIOCM_CTS)\n\t\tuart_handle_cts_change(port, status & TIOCM_CTS);\n\n\twake_up_interruptible(&port->state->port.delta_msr_wait);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic bool sc16is7xx_port_irq(struct sc16is7xx_port *s, int portno)\n{\n\tstruct uart_port *port = &s->p[portno].port;\n\n\tdo {\n\t\tunsigned int iir, rxlen;\n\t\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\n\t\tiir = sc16is7xx_port_read(port, SC16IS7XX_IIR_REG);\n\t\tif (iir & SC16IS7XX_IIR_NO_INT_BIT)\n\t\t\treturn false;\n\n\t\tiir &= SC16IS7XX_IIR_ID_MASK;\n\n\t\tswitch (iir) {\n\t\tcase SC16IS7XX_IIR_RDI_SRC:\n\t\tcase SC16IS7XX_IIR_RLSE_SRC:\n\t\tcase SC16IS7XX_IIR_RTOI_SRC:\n\t\tcase SC16IS7XX_IIR_XOFFI_SRC:\n\t\t\trxlen = sc16is7xx_port_read(port, SC16IS7XX_RXLVL_REG);\n\n\t\t\t \n\t\t\tif (iir == SC16IS7XX_IIR_RTOI_SRC && !rxlen)\n\t\t\t\trxlen = 1;\n\n\t\t\tif (rxlen)\n\t\t\t\tsc16is7xx_handle_rx(port, rxlen, iir);\n\t\t\tbreak;\n\t\t \n\t\tcase SC16IS7XX_IIR_CTSRTS_SRC:\n\t\tcase SC16IS7XX_IIR_MSI_SRC:\n\t\t\tsc16is7xx_update_mlines(one);\n\t\t\tbreak;\n\t\tcase SC16IS7XX_IIR_THRI_SRC:\n\t\t\tsc16is7xx_handle_tx(port);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err_ratelimited(port->dev,\n\t\t\t\t\t    \"ttySC%i: Unexpected interrupt: %x\",\n\t\t\t\t\t    port->line, iir);\n\t\t\tbreak;\n\t\t}\n\t} while (0);\n\treturn true;\n}\n\nstatic irqreturn_t sc16is7xx_irq(int irq, void *dev_id)\n{\n\tstruct sc16is7xx_port *s = (struct sc16is7xx_port *)dev_id;\n\n\tmutex_lock(&s->efr_lock);\n\n\twhile (1) {\n\t\tbool keep_polling = false;\n\t\tint i;\n\n\t\tfor (i = 0; i < s->devtype->nr_uart; ++i)\n\t\t\tkeep_polling |= sc16is7xx_port_irq(s, i);\n\t\tif (!keep_polling)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&s->efr_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sc16is7xx_tx_proc(struct kthread_work *ws)\n{\n\tstruct uart_port *port = &(to_sc16is7xx_one(ws, tx_work)->port);\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tunsigned long flags;\n\n\tif ((port->rs485.flags & SER_RS485_ENABLED) &&\n\t    (port->rs485.delay_rts_before_send > 0))\n\t\tmsleep(port->rs485.delay_rts_before_send);\n\n\tmutex_lock(&s->efr_lock);\n\tsc16is7xx_handle_tx(port);\n\tmutex_unlock(&s->efr_lock);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tsc16is7xx_ier_set(port, SC16IS7XX_IER_THRI_BIT);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void sc16is7xx_reconf_rs485(struct uart_port *port)\n{\n\tconst u32 mask = SC16IS7XX_EFCR_AUTO_RS485_BIT |\n\t\t\t SC16IS7XX_EFCR_RTS_INVERT_BIT;\n\tu32 efcr = 0;\n\tstruct serial_rs485 *rs485 = &port->rs485;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&port->lock, irqflags);\n\tif (rs485->flags & SER_RS485_ENABLED) {\n\t\tefcr |=\tSC16IS7XX_EFCR_AUTO_RS485_BIT;\n\n\t\tif (rs485->flags & SER_RS485_RTS_AFTER_SEND)\n\t\t\tefcr |= SC16IS7XX_EFCR_RTS_INVERT_BIT;\n\t}\n\tspin_unlock_irqrestore(&port->lock, irqflags);\n\n\tsc16is7xx_port_update(port, SC16IS7XX_EFCR_REG, mask, efcr);\n}\n\nstatic void sc16is7xx_reg_proc(struct kthread_work *ws)\n{\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(ws, reg_work);\n\tstruct sc16is7xx_one_config config;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&one->port.lock, irqflags);\n\tconfig = one->config;\n\tmemset(&one->config, 0, sizeof(one->config));\n\tspin_unlock_irqrestore(&one->port.lock, irqflags);\n\n\tif (config.flags & SC16IS7XX_RECONF_MD) {\n\t\tu8 mcr = 0;\n\n\t\t \n\t\tif (one->port.mctrl & TIOCM_RTS)\n\t\t\tmcr |= SC16IS7XX_MCR_RTS_BIT;\n\n\t\tif (one->port.mctrl & TIOCM_DTR)\n\t\t\tmcr |= SC16IS7XX_MCR_DTR_BIT;\n\n\t\tif (one->port.mctrl & TIOCM_LOOP)\n\t\t\tmcr |= SC16IS7XX_MCR_LOOP_BIT;\n\t\tsc16is7xx_port_update(&one->port, SC16IS7XX_MCR_REG,\n\t\t\t\t      SC16IS7XX_MCR_RTS_BIT |\n\t\t\t\t      SC16IS7XX_MCR_DTR_BIT |\n\t\t\t\t      SC16IS7XX_MCR_LOOP_BIT,\n\t\t\t\t      mcr);\n\t}\n\n\tif (config.flags & SC16IS7XX_RECONF_IER)\n\t\tsc16is7xx_port_update(&one->port, SC16IS7XX_IER_REG,\n\t\t\t\t      config.ier_mask, config.ier_val);\n\n\tif (config.flags & SC16IS7XX_RECONF_RS485)\n\t\tsc16is7xx_reconf_rs485(&one->port);\n}\n\nstatic void sc16is7xx_ier_clear(struct uart_port *port, u8 bit)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\n\tlockdep_assert_held_once(&port->lock);\n\n\tone->config.flags |= SC16IS7XX_RECONF_IER;\n\tone->config.ier_mask |= bit;\n\tone->config.ier_val &= ~bit;\n\tkthread_queue_work(&s->kworker, &one->reg_work);\n}\n\nstatic void sc16is7xx_ier_set(struct uart_port *port, u8 bit)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\n\tlockdep_assert_held_once(&port->lock);\n\n\tone->config.flags |= SC16IS7XX_RECONF_IER;\n\tone->config.ier_mask |= bit;\n\tone->config.ier_val |= bit;\n\tkthread_queue_work(&s->kworker, &one->reg_work);\n}\n\nstatic void sc16is7xx_stop_tx(struct uart_port *port)\n{\n\tsc16is7xx_ier_clear(port, SC16IS7XX_IER_THRI_BIT);\n}\n\nstatic void sc16is7xx_stop_rx(struct uart_port *port)\n{\n\tsc16is7xx_ier_clear(port, SC16IS7XX_IER_RDI_BIT);\n}\n\nstatic void sc16is7xx_ms_proc(struct kthread_work *ws)\n{\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(ws, ms_work.work);\n\tstruct sc16is7xx_port *s = dev_get_drvdata(one->port.dev);\n\n\tif (one->port.state) {\n\t\tmutex_lock(&s->efr_lock);\n\t\tsc16is7xx_update_mlines(one);\n\t\tmutex_unlock(&s->efr_lock);\n\n\t\tkthread_queue_delayed_work(&s->kworker, &one->ms_work, HZ);\n\t}\n}\n\nstatic void sc16is7xx_enable_ms(struct uart_port *port)\n{\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\n\tlockdep_assert_held_once(&port->lock);\n\n\tkthread_queue_delayed_work(&s->kworker, &one->ms_work, 0);\n}\n\nstatic void sc16is7xx_start_tx(struct uart_port *port)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\n\tkthread_queue_work(&s->kworker, &one->tx_work);\n}\n\nstatic void sc16is7xx_throttle(struct uart_port *port)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tsc16is7xx_ier_clear(port, SC16IS7XX_IER_RDI_BIT);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void sc16is7xx_unthrottle(struct uart_port *port)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tsc16is7xx_ier_set(port, SC16IS7XX_IER_RDI_BIT);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic unsigned int sc16is7xx_tx_empty(struct uart_port *port)\n{\n\tunsigned int lsr;\n\n\tlsr = sc16is7xx_port_read(port, SC16IS7XX_LSR_REG);\n\n\treturn (lsr & SC16IS7XX_LSR_TEMT_BIT) ? TIOCSER_TEMT : 0;\n}\n\nstatic unsigned int sc16is7xx_get_mctrl(struct uart_port *port)\n{\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\n\t \n\treturn one->old_mctrl;\n}\n\nstatic void sc16is7xx_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\n\tone->config.flags |= SC16IS7XX_RECONF_MD;\n\tkthread_queue_work(&s->kworker, &one->reg_work);\n}\n\nstatic void sc16is7xx_break_ctl(struct uart_port *port, int break_state)\n{\n\tsc16is7xx_port_update(port, SC16IS7XX_LCR_REG,\n\t\t\t      SC16IS7XX_LCR_TXBREAK_BIT,\n\t\t\t      break_state ? SC16IS7XX_LCR_TXBREAK_BIT : 0);\n}\n\nstatic void sc16is7xx_set_termios(struct uart_port *port,\n\t\t\t\t  struct ktermios *termios,\n\t\t\t\t  const struct ktermios *old)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\tunsigned int lcr, flow = 0;\n\tint baud;\n\tunsigned long flags;\n\n\tkthread_cancel_delayed_work_sync(&one->ms_work);\n\n\t \n\ttermios->c_cflag &= ~CMSPAR;\n\n\t \n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tlcr = SC16IS7XX_LCR_WORD_LEN_5;\n\t\tbreak;\n\tcase CS6:\n\t\tlcr = SC16IS7XX_LCR_WORD_LEN_6;\n\t\tbreak;\n\tcase CS7:\n\t\tlcr = SC16IS7XX_LCR_WORD_LEN_7;\n\t\tbreak;\n\tcase CS8:\n\t\tlcr = SC16IS7XX_LCR_WORD_LEN_8;\n\t\tbreak;\n\tdefault:\n\t\tlcr = SC16IS7XX_LCR_WORD_LEN_8;\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= CS8;\n\t\tbreak;\n\t}\n\n\t \n\tif (termios->c_cflag & PARENB) {\n\t\tlcr |= SC16IS7XX_LCR_PARITY_BIT;\n\t\tif (!(termios->c_cflag & PARODD))\n\t\t\tlcr |= SC16IS7XX_LCR_EVENPARITY_BIT;\n\t}\n\n\t \n\tif (termios->c_cflag & CSTOPB)\n\t\tlcr |= SC16IS7XX_LCR_STOPLEN_BIT;  \n\n\t \n\tport->read_status_mask = SC16IS7XX_LSR_OE_BIT;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= SC16IS7XX_LSR_PE_BIT |\n\t\t\t\t\t  SC16IS7XX_LSR_FE_BIT;\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tport->read_status_mask |= SC16IS7XX_LSR_BI_BIT;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNBRK)\n\t\tport->ignore_status_mask |= SC16IS7XX_LSR_BI_BIT;\n\tif (!(termios->c_cflag & CREAD))\n\t\tport->ignore_status_mask |= SC16IS7XX_LSR_BRK_ERROR_MASK;\n\n\t \n\tmutex_lock(&s->efr_lock);\n\n\tsc16is7xx_port_write(port, SC16IS7XX_LCR_REG,\n\t\t\t     SC16IS7XX_LCR_CONF_MODE_B);\n\n\t \n\tregcache_cache_bypass(s->regmap, true);\n\tsc16is7xx_port_write(port, SC16IS7XX_XON1_REG, termios->c_cc[VSTART]);\n\tsc16is7xx_port_write(port, SC16IS7XX_XOFF1_REG, termios->c_cc[VSTOP]);\n\n\tport->status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS);\n\tif (termios->c_cflag & CRTSCTS) {\n\t\tflow |= SC16IS7XX_EFR_AUTOCTS_BIT |\n\t\t\tSC16IS7XX_EFR_AUTORTS_BIT;\n\t\tport->status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;\n\t}\n\tif (termios->c_iflag & IXON)\n\t\tflow |= SC16IS7XX_EFR_SWFLOW3_BIT;\n\tif (termios->c_iflag & IXOFF)\n\t\tflow |= SC16IS7XX_EFR_SWFLOW1_BIT;\n\n\tsc16is7xx_port_update(port,\n\t\t\t      SC16IS7XX_EFR_REG,\n\t\t\t      SC16IS7XX_EFR_FLOWCTRL_BITS,\n\t\t\t      flow);\n\tregcache_cache_bypass(s->regmap, false);\n\n\t \n\tsc16is7xx_port_write(port, SC16IS7XX_LCR_REG, lcr);\n\n\tmutex_unlock(&s->efr_lock);\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old,\n\t\t\t\t  port->uartclk / 16 / 4 / 0xffff,\n\t\t\t\t  port->uartclk / 16);\n\n\t \n\tbaud = sc16is7xx_set_baud(port, baud);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tif (UART_ENABLE_MS(port, termios->c_cflag))\n\t\tsc16is7xx_enable_ms(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int sc16is7xx_config_rs485(struct uart_port *port, struct ktermios *termios,\n\t\t\t\t  struct serial_rs485 *rs485)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\n\tif (rs485->flags & SER_RS485_ENABLED) {\n\t\t \n\t\tif (rs485->delay_rts_after_send)\n\t\t\treturn -EINVAL;\n\t}\n\n\tone->config.flags |= SC16IS7XX_RECONF_RS485;\n\tkthread_queue_work(&s->kworker, &one->reg_work);\n\n\treturn 0;\n}\n\nstatic int sc16is7xx_startup(struct uart_port *port)\n{\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tunsigned int val;\n\tunsigned long flags;\n\n\tsc16is7xx_power(port, 1);\n\n\t \n\tval = SC16IS7XX_FCR_RXRESET_BIT | SC16IS7XX_FCR_TXRESET_BIT;\n\tsc16is7xx_port_write(port, SC16IS7XX_FCR_REG, val);\n\tudelay(5);\n\tsc16is7xx_port_write(port, SC16IS7XX_FCR_REG,\n\t\t\t     SC16IS7XX_FCR_FIFO_BIT);\n\n\t \n\tsc16is7xx_port_write(port, SC16IS7XX_LCR_REG,\n\t\t\t     SC16IS7XX_LCR_CONF_MODE_B);\n\n\tregcache_cache_bypass(s->regmap, true);\n\n\t \n\tsc16is7xx_port_update(port, SC16IS7XX_EFR_REG,\n\t\t\t      SC16IS7XX_EFR_ENABLE_BIT,\n\t\t\t      SC16IS7XX_EFR_ENABLE_BIT);\n\n\t \n\tsc16is7xx_port_update(port, SC16IS7XX_MCR_REG,\n\t\t\t      SC16IS7XX_MCR_TCRTLR_BIT,\n\t\t\t      SC16IS7XX_MCR_TCRTLR_BIT);\n\n\t \n\t \n\tsc16is7xx_port_write(port, SC16IS7XX_TCR_REG,\n\t\t\t     SC16IS7XX_TCR_RX_RESUME(24) |\n\t\t\t     SC16IS7XX_TCR_RX_HALT(48));\n\n\tregcache_cache_bypass(s->regmap, false);\n\n\t \n\tsc16is7xx_port_write(port, SC16IS7XX_LCR_REG, SC16IS7XX_LCR_WORD_LEN_8);\n\n\t \n\t \n\tsc16is7xx_port_update(port, SC16IS7XX_MCR_REG,\n\t\t\t      SC16IS7XX_MCR_IRDA_BIT,\n\t\t\t      one->irda_mode ?\n\t\t\t\tSC16IS7XX_MCR_IRDA_BIT : 0);\n\n\t \n\tsc16is7xx_port_update(port, SC16IS7XX_EFCR_REG,\n\t\t\t      SC16IS7XX_EFCR_RXDISABLE_BIT |\n\t\t\t      SC16IS7XX_EFCR_TXDISABLE_BIT,\n\t\t\t      0);\n\n\t \n\tval = SC16IS7XX_IER_RDI_BIT | SC16IS7XX_IER_CTSI_BIT |\n\t      SC16IS7XX_IER_MSI_BIT;\n\tsc16is7xx_port_write(port, SC16IS7XX_IER_REG, val);\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tsc16is7xx_enable_ms(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn 0;\n}\n\nstatic void sc16is7xx_shutdown(struct uart_port *port)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\tstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\n\n\tkthread_cancel_delayed_work_sync(&one->ms_work);\n\n\t \n\tsc16is7xx_port_write(port, SC16IS7XX_IER_REG, 0);\n\t \n\tsc16is7xx_port_update(port, SC16IS7XX_EFCR_REG,\n\t\t\t      SC16IS7XX_EFCR_RXDISABLE_BIT |\n\t\t\t      SC16IS7XX_EFCR_TXDISABLE_BIT,\n\t\t\t      SC16IS7XX_EFCR_RXDISABLE_BIT |\n\t\t\t      SC16IS7XX_EFCR_TXDISABLE_BIT);\n\n\tsc16is7xx_power(port, 0);\n\n\tkthread_flush_worker(&s->kworker);\n}\n\nstatic const char *sc16is7xx_type(struct uart_port *port)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\n\n\treturn (port->type == PORT_SC16IS7XX) ? s->devtype->name : NULL;\n}\n\nstatic int sc16is7xx_request_port(struct uart_port *port)\n{\n\t \n\treturn 0;\n}\n\nstatic void sc16is7xx_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_SC16IS7XX;\n}\n\nstatic int sc16is7xx_verify_port(struct uart_port *port,\n\t\t\t\t struct serial_struct *s)\n{\n\tif ((s->type != PORT_UNKNOWN) && (s->type != PORT_SC16IS7XX))\n\t\treturn -EINVAL;\n\tif (s->irq != port->irq)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void sc16is7xx_pm(struct uart_port *port, unsigned int state,\n\t\t\t unsigned int oldstate)\n{\n\tsc16is7xx_power(port, (state == UART_PM_STATE_ON) ? 1 : 0);\n}\n\nstatic void sc16is7xx_null_void(struct uart_port *port)\n{\n\t \n}\n\nstatic const struct uart_ops sc16is7xx_ops = {\n\t.tx_empty\t= sc16is7xx_tx_empty,\n\t.set_mctrl\t= sc16is7xx_set_mctrl,\n\t.get_mctrl\t= sc16is7xx_get_mctrl,\n\t.stop_tx\t= sc16is7xx_stop_tx,\n\t.start_tx\t= sc16is7xx_start_tx,\n\t.throttle\t= sc16is7xx_throttle,\n\t.unthrottle\t= sc16is7xx_unthrottle,\n\t.stop_rx\t= sc16is7xx_stop_rx,\n\t.enable_ms\t= sc16is7xx_enable_ms,\n\t.break_ctl\t= sc16is7xx_break_ctl,\n\t.startup\t= sc16is7xx_startup,\n\t.shutdown\t= sc16is7xx_shutdown,\n\t.set_termios\t= sc16is7xx_set_termios,\n\t.type\t\t= sc16is7xx_type,\n\t.request_port\t= sc16is7xx_request_port,\n\t.release_port\t= sc16is7xx_null_void,\n\t.config_port\t= sc16is7xx_config_port,\n\t.verify_port\t= sc16is7xx_verify_port,\n\t.pm\t\t= sc16is7xx_pm,\n};\n\n#ifdef CONFIG_GPIOLIB\nstatic int sc16is7xx_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tunsigned int val;\n\tstruct sc16is7xx_port *s = gpiochip_get_data(chip);\n\tstruct uart_port *port = &s->p[0].port;\n\n\tval = sc16is7xx_port_read(port, SC16IS7XX_IOSTATE_REG);\n\n\treturn !!(val & BIT(offset));\n}\n\nstatic void sc16is7xx_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\n{\n\tstruct sc16is7xx_port *s = gpiochip_get_data(chip);\n\tstruct uart_port *port = &s->p[0].port;\n\n\tsc16is7xx_port_update(port, SC16IS7XX_IOSTATE_REG, BIT(offset),\n\t\t\t      val ? BIT(offset) : 0);\n}\n\nstatic int sc16is7xx_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\t  unsigned offset)\n{\n\tstruct sc16is7xx_port *s = gpiochip_get_data(chip);\n\tstruct uart_port *port = &s->p[0].port;\n\n\tsc16is7xx_port_update(port, SC16IS7XX_IODIR_REG, BIT(offset), 0);\n\n\treturn 0;\n}\n\nstatic int sc16is7xx_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t   unsigned offset, int val)\n{\n\tstruct sc16is7xx_port *s = gpiochip_get_data(chip);\n\tstruct uart_port *port = &s->p[0].port;\n\tu8 state = sc16is7xx_port_read(port, SC16IS7XX_IOSTATE_REG);\n\n\tif (val)\n\t\tstate |= BIT(offset);\n\telse\n\t\tstate &= ~BIT(offset);\n\n\t \n\tsc16is7xx_port_update(port, SC16IS7XX_IODIR_REG, BIT(offset),\n\t\t\t      BIT(offset));\n\tsc16is7xx_port_write(port, SC16IS7XX_IOSTATE_REG, state);\n\n\treturn 0;\n}\n\nstatic int sc16is7xx_gpio_init_valid_mask(struct gpio_chip *chip,\n\t\t\t\t\t  unsigned long *valid_mask,\n\t\t\t\t\t  unsigned int ngpios)\n{\n\tstruct sc16is7xx_port *s = gpiochip_get_data(chip);\n\n\t*valid_mask = s->gpio_valid_mask;\n\n\treturn 0;\n}\n\nstatic int sc16is7xx_setup_gpio_chip(struct sc16is7xx_port *s)\n{\n\tstruct device *dev = s->p[0].port.dev;\n\n\tif (!s->devtype->nr_gpio)\n\t\treturn 0;\n\n\tswitch (s->mctrl_mask) {\n\tcase 0:\n\t\ts->gpio_valid_mask = GENMASK(7, 0);\n\t\tbreak;\n\tcase SC16IS7XX_IOCONTROL_MODEM_A_BIT:\n\t\ts->gpio_valid_mask = GENMASK(3, 0);\n\t\tbreak;\n\tcase SC16IS7XX_IOCONTROL_MODEM_B_BIT:\n\t\ts->gpio_valid_mask = GENMASK(7, 4);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (s->gpio_valid_mask == 0)\n\t\treturn 0;\n\n\ts->gpio.owner\t\t = THIS_MODULE;\n\ts->gpio.parent\t\t = dev;\n\ts->gpio.label\t\t = dev_name(dev);\n\ts->gpio.init_valid_mask\t = sc16is7xx_gpio_init_valid_mask;\n\ts->gpio.direction_input\t = sc16is7xx_gpio_direction_input;\n\ts->gpio.get\t\t = sc16is7xx_gpio_get;\n\ts->gpio.direction_output = sc16is7xx_gpio_direction_output;\n\ts->gpio.set\t\t = sc16is7xx_gpio_set;\n\ts->gpio.base\t\t = -1;\n\ts->gpio.ngpio\t\t = s->devtype->nr_gpio;\n\ts->gpio.can_sleep\t = 1;\n\n\treturn gpiochip_add_data(&s->gpio, s);\n}\n#endif\n\n \nstatic int sc16is7xx_setup_mctrl_ports(struct sc16is7xx_port *s)\n{\n\tint i;\n\tint ret;\n\tint count;\n\tu32 mctrl_port[2];\n\tstruct device *dev = s->p[0].port.dev;\n\n\tcount = device_property_count_u32(dev, \"nxp,modem-control-line-ports\");\n\tif (count < 0 || count > ARRAY_SIZE(mctrl_port))\n\t\treturn 0;\n\n\tret = device_property_read_u32_array(dev, \"nxp,modem-control-line-ports\",\n\t\t\t\t\t     mctrl_port, count);\n\tif (ret)\n\t\treturn ret;\n\n\ts->mctrl_mask = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tif (mctrl_port[i] == 0)\n\t\t\ts->mctrl_mask |= SC16IS7XX_IOCONTROL_MODEM_A_BIT;\n\t\telse if (mctrl_port[i] == 1)\n\t\t\ts->mctrl_mask |= SC16IS7XX_IOCONTROL_MODEM_B_BIT;\n\t}\n\n\tif (s->mctrl_mask)\n\t\tregmap_update_bits(\n\t\t\ts->regmap,\n\t\t\tSC16IS7XX_IOCONTROL_REG << SC16IS7XX_REG_SHIFT,\n\t\t\tSC16IS7XX_IOCONTROL_MODEM_A_BIT |\n\t\t\tSC16IS7XX_IOCONTROL_MODEM_B_BIT, s->mctrl_mask);\n\n\treturn 0;\n}\n\nstatic const struct serial_rs485 sc16is7xx_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_AFTER_SEND,\n\t.delay_rts_before_send = 1,\n\t.delay_rts_after_send = 1,\t \n};\n\nstatic int sc16is7xx_probe(struct device *dev,\n\t\t\t   const struct sc16is7xx_devtype *devtype,\n\t\t\t   struct regmap *regmap, int irq)\n{\n\tunsigned long freq = 0, *pfreq = dev_get_platdata(dev);\n\tunsigned int val;\n\tu32 uartclk = 0;\n\tint i, ret;\n\tstruct sc16is7xx_port *s;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\t \n\tret = regmap_read(regmap,\n\t\t\t  SC16IS7XX_LSR_REG << SC16IS7XX_REG_SHIFT, &val);\n\tif (ret < 0)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\ts = devm_kzalloc(dev, struct_size(s, p, devtype->nr_uart), GFP_KERNEL);\n\tif (!s) {\n\t\tdev_err(dev, \"Error allocating port structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdevice_property_read_u32(dev, \"clock-frequency\", &uartclk);\n\n\ts->clk = devm_clk_get_optional(dev, NULL);\n\tif (IS_ERR(s->clk))\n\t\treturn PTR_ERR(s->clk);\n\n\tret = clk_prepare_enable(s->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tfreq = clk_get_rate(s->clk);\n\tif (freq == 0) {\n\t\tif (uartclk)\n\t\t\tfreq = uartclk;\n\t\tif (pfreq)\n\t\t\tfreq = *pfreq;\n\t\tif (freq)\n\t\t\tdev_dbg(dev, \"Clock frequency: %luHz\\n\", freq);\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\ts->regmap = regmap;\n\ts->devtype = devtype;\n\tdev_set_drvdata(dev, s);\n\tmutex_init(&s->efr_lock);\n\n\tkthread_init_worker(&s->kworker);\n\ts->kworker_task = kthread_run(kthread_worker_fn, &s->kworker,\n\t\t\t\t      \"sc16is7xx\");\n\tif (IS_ERR(s->kworker_task)) {\n\t\tret = PTR_ERR(s->kworker_task);\n\t\tgoto out_clk;\n\t}\n\tsched_set_fifo(s->kworker_task);\n\n\t \n\tregmap_write(s->regmap, SC16IS7XX_IOCONTROL_REG << SC16IS7XX_REG_SHIFT,\n\t\t\tSC16IS7XX_IOCONTROL_SRESET_BIT);\n\n\tfor (i = 0; i < devtype->nr_uart; ++i) {\n\t\ts->p[i].line\t\t= i;\n\t\t \n\t\ts->p[i].port.dev\t= dev;\n\t\ts->p[i].port.irq\t= irq;\n\t\ts->p[i].port.type\t= PORT_SC16IS7XX;\n\t\ts->p[i].port.fifosize\t= SC16IS7XX_FIFO_SIZE;\n\t\ts->p[i].port.flags\t= UPF_FIXED_TYPE | UPF_LOW_LATENCY;\n\t\ts->p[i].port.iobase\t= i;\n\t\t \n\t\ts->p[i].port.membase\t= (void __iomem *)~0;\n\t\ts->p[i].port.iotype\t= UPIO_PORT;\n\t\ts->p[i].port.uartclk\t= freq;\n\t\ts->p[i].port.rs485_config = sc16is7xx_config_rs485;\n\t\ts->p[i].port.rs485_supported = sc16is7xx_rs485_supported;\n\t\ts->p[i].port.ops\t= &sc16is7xx_ops;\n\t\ts->p[i].old_mctrl\t= 0;\n\t\ts->p[i].port.line\t= sc16is7xx_alloc_line();\n\n\t\tif (s->p[i].port.line >= SC16IS7XX_MAX_DEVS) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_ports;\n\t\t}\n\n\t\tret = uart_get_rs485_mode(&s->p[i].port);\n\t\tif (ret)\n\t\t\tgoto out_ports;\n\n\t\t \n\t\tsc16is7xx_port_write(&s->p[i].port, SC16IS7XX_IER_REG, 0);\n\t\t \n\t\tsc16is7xx_port_write(&s->p[i].port, SC16IS7XX_EFCR_REG,\n\t\t\t\t     SC16IS7XX_EFCR_RXDISABLE_BIT |\n\t\t\t\t     SC16IS7XX_EFCR_TXDISABLE_BIT);\n\n\t\t \n\t\tkthread_init_work(&s->p[i].tx_work, sc16is7xx_tx_proc);\n\t\tkthread_init_work(&s->p[i].reg_work, sc16is7xx_reg_proc);\n\t\tkthread_init_delayed_work(&s->p[i].ms_work, sc16is7xx_ms_proc);\n\t\t \n\t\tuart_add_one_port(&sc16is7xx_uart, &s->p[i].port);\n\n\t\t \n\t\tsc16is7xx_port_write(&s->p[i].port, SC16IS7XX_LCR_REG,\n\t\t\t\t     SC16IS7XX_LCR_CONF_MODE_B);\n\n\t\tregcache_cache_bypass(s->regmap, true);\n\n\t\t \n\t\tsc16is7xx_port_write(&s->p[i].port, SC16IS7XX_EFR_REG,\n\t\t\t\t     SC16IS7XX_EFR_ENABLE_BIT);\n\n\t\tregcache_cache_bypass(s->regmap, false);\n\n\t\t \n\t\tsc16is7xx_port_write(&s->p[i].port, SC16IS7XX_LCR_REG, 0x00);\n\n\t\t \n\t\tsc16is7xx_power(&s->p[i].port, 0);\n\t}\n\n\tif (dev->of_node) {\n\t\tstruct property *prop;\n\t\tconst __be32 *p;\n\t\tu32 u;\n\n\t\tof_property_for_each_u32(dev->of_node, \"irda-mode-ports\",\n\t\t\t\t\t prop, p, u)\n\t\t\tif (u < devtype->nr_uart)\n\t\t\t\ts->p[u].irda_mode = true;\n\t}\n\n\tret = sc16is7xx_setup_mctrl_ports(s);\n\tif (ret)\n\t\tgoto out_ports;\n\n#ifdef CONFIG_GPIOLIB\n\tret = sc16is7xx_setup_gpio_chip(s);\n\tif (ret)\n\t\tgoto out_ports;\n#endif\n\n\t \n\tret = devm_request_threaded_irq(dev, irq, NULL, sc16is7xx_irq,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_SHARED |\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), s);\n\tif (!ret)\n\t\treturn 0;\n\n\tret = devm_request_threaded_irq(dev, irq, NULL, sc16is7xx_irq,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), s);\n\tif (!ret)\n\t\treturn 0;\n\n#ifdef CONFIG_GPIOLIB\n\tif (s->gpio_valid_mask)\n\t\tgpiochip_remove(&s->gpio);\n#endif\n\nout_ports:\n\tfor (i--; i >= 0; i--) {\n\t\tuart_remove_one_port(&sc16is7xx_uart, &s->p[i].port);\n\t\tclear_bit(s->p[i].port.line, &sc16is7xx_lines);\n\t}\n\n\tkthread_stop(s->kworker_task);\n\nout_clk:\n\tclk_disable_unprepare(s->clk);\n\n\treturn ret;\n}\n\nstatic void sc16is7xx_remove(struct device *dev)\n{\n\tstruct sc16is7xx_port *s = dev_get_drvdata(dev);\n\tint i;\n\n#ifdef CONFIG_GPIOLIB\n\tif (s->gpio_valid_mask)\n\t\tgpiochip_remove(&s->gpio);\n#endif\n\n\tfor (i = 0; i < s->devtype->nr_uart; i++) {\n\t\tkthread_cancel_delayed_work_sync(&s->p[i].ms_work);\n\t\tuart_remove_one_port(&sc16is7xx_uart, &s->p[i].port);\n\t\tclear_bit(s->p[i].port.line, &sc16is7xx_lines);\n\t\tsc16is7xx_power(&s->p[i].port, 0);\n\t}\n\n\tkthread_flush_worker(&s->kworker);\n\tkthread_stop(s->kworker_task);\n\n\tclk_disable_unprepare(s->clk);\n}\n\nstatic const struct of_device_id __maybe_unused sc16is7xx_dt_ids[] = {\n\t{ .compatible = \"nxp,sc16is740\",\t.data = &sc16is74x_devtype, },\n\t{ .compatible = \"nxp,sc16is741\",\t.data = &sc16is74x_devtype, },\n\t{ .compatible = \"nxp,sc16is750\",\t.data = &sc16is750_devtype, },\n\t{ .compatible = \"nxp,sc16is752\",\t.data = &sc16is752_devtype, },\n\t{ .compatible = \"nxp,sc16is760\",\t.data = &sc16is760_devtype, },\n\t{ .compatible = \"nxp,sc16is762\",\t.data = &sc16is762_devtype, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sc16is7xx_dt_ids);\n\nstatic struct regmap_config regcfg = {\n\t.reg_bits = 7,\n\t.pad_bits = 1,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = sc16is7xx_regmap_volatile,\n\t.precious_reg = sc16is7xx_regmap_precious,\n};\n\n#ifdef CONFIG_SERIAL_SC16IS7XX_SPI\nstatic int sc16is7xx_spi_probe(struct spi_device *spi)\n{\n\tconst struct sc16is7xx_devtype *devtype;\n\tstruct regmap *regmap;\n\tint ret;\n\n\t \n\tspi->bits_per_word\t= 8;\n\t \n\tif ((spi->mode & SPI_MODE_X_MASK) != SPI_MODE_0)\n\t\treturn dev_err_probe(&spi->dev, -EINVAL, \"Unsupported SPI mode\\n\");\n\n\tspi->mode\t\t= spi->mode ? : SPI_MODE_0;\n\tspi->max_speed_hz\t= spi->max_speed_hz ? : 4 * HZ_PER_MHZ;\n\tret = spi_setup(spi);\n\tif (ret)\n\t\treturn ret;\n\n\tif (spi->dev.of_node) {\n\t\tdevtype = device_get_match_data(&spi->dev);\n\t\tif (!devtype)\n\t\t\treturn -ENODEV;\n\t} else {\n\t\tconst struct spi_device_id *id_entry = spi_get_device_id(spi);\n\n\t\tdevtype = (struct sc16is7xx_devtype *)id_entry->driver_data;\n\t}\n\n\tregcfg.max_register = (0xf << SC16IS7XX_REG_SHIFT) |\n\t\t\t      (devtype->nr_uart - 1);\n\tregmap = devm_regmap_init_spi(spi, &regcfg);\n\n\treturn sc16is7xx_probe(&spi->dev, devtype, regmap, spi->irq);\n}\n\nstatic void sc16is7xx_spi_remove(struct spi_device *spi)\n{\n\tsc16is7xx_remove(&spi->dev);\n}\n\nstatic const struct spi_device_id sc16is7xx_spi_id_table[] = {\n\t{ \"sc16is74x\",\t(kernel_ulong_t)&sc16is74x_devtype, },\n\t{ \"sc16is740\",\t(kernel_ulong_t)&sc16is74x_devtype, },\n\t{ \"sc16is741\",\t(kernel_ulong_t)&sc16is74x_devtype, },\n\t{ \"sc16is750\",\t(kernel_ulong_t)&sc16is750_devtype, },\n\t{ \"sc16is752\",\t(kernel_ulong_t)&sc16is752_devtype, },\n\t{ \"sc16is760\",\t(kernel_ulong_t)&sc16is760_devtype, },\n\t{ \"sc16is762\",\t(kernel_ulong_t)&sc16is762_devtype, },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(spi, sc16is7xx_spi_id_table);\n\nstatic struct spi_driver sc16is7xx_spi_uart_driver = {\n\t.driver = {\n\t\t.name\t\t= SC16IS7XX_NAME,\n\t\t.of_match_table\t= sc16is7xx_dt_ids,\n\t},\n\t.probe\t\t= sc16is7xx_spi_probe,\n\t.remove\t\t= sc16is7xx_spi_remove,\n\t.id_table\t= sc16is7xx_spi_id_table,\n};\n\nMODULE_ALIAS(\"spi:sc16is7xx\");\n#endif\n\n#ifdef CONFIG_SERIAL_SC16IS7XX_I2C\nstatic int sc16is7xx_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tconst struct sc16is7xx_devtype *devtype;\n\tstruct regmap *regmap;\n\n\tif (i2c->dev.of_node) {\n\t\tdevtype = device_get_match_data(&i2c->dev);\n\t\tif (!devtype)\n\t\t\treturn -ENODEV;\n\t} else {\n\t\tdevtype = (struct sc16is7xx_devtype *)id->driver_data;\n\t}\n\n\tregcfg.max_register = (0xf << SC16IS7XX_REG_SHIFT) |\n\t\t\t      (devtype->nr_uart - 1);\n\tregmap = devm_regmap_init_i2c(i2c, &regcfg);\n\n\treturn sc16is7xx_probe(&i2c->dev, devtype, regmap, i2c->irq);\n}\n\nstatic void sc16is7xx_i2c_remove(struct i2c_client *client)\n{\n\tsc16is7xx_remove(&client->dev);\n}\n\nstatic const struct i2c_device_id sc16is7xx_i2c_id_table[] = {\n\t{ \"sc16is74x\",\t(kernel_ulong_t)&sc16is74x_devtype, },\n\t{ \"sc16is740\",\t(kernel_ulong_t)&sc16is74x_devtype, },\n\t{ \"sc16is741\",\t(kernel_ulong_t)&sc16is74x_devtype, },\n\t{ \"sc16is750\",\t(kernel_ulong_t)&sc16is750_devtype, },\n\t{ \"sc16is752\",\t(kernel_ulong_t)&sc16is752_devtype, },\n\t{ \"sc16is760\",\t(kernel_ulong_t)&sc16is760_devtype, },\n\t{ \"sc16is762\",\t(kernel_ulong_t)&sc16is762_devtype, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sc16is7xx_i2c_id_table);\n\nstatic struct i2c_driver sc16is7xx_i2c_uart_driver = {\n\t.driver = {\n\t\t.name\t\t= SC16IS7XX_NAME,\n\t\t.of_match_table\t= sc16is7xx_dt_ids,\n\t},\n\t.probe\t\t= sc16is7xx_i2c_probe,\n\t.remove\t\t= sc16is7xx_i2c_remove,\n\t.id_table\t= sc16is7xx_i2c_id_table,\n};\n\n#endif\n\nstatic int __init sc16is7xx_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&sc16is7xx_uart);\n\tif (ret) {\n\t\tpr_err(\"Registering UART driver failed\\n\");\n\t\treturn ret;\n\t}\n\n#ifdef CONFIG_SERIAL_SC16IS7XX_I2C\n\tret = i2c_add_driver(&sc16is7xx_i2c_uart_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to init sc16is7xx i2c --> %d\\n\", ret);\n\t\tgoto err_i2c;\n\t}\n#endif\n\n#ifdef CONFIG_SERIAL_SC16IS7XX_SPI\n\tret = spi_register_driver(&sc16is7xx_spi_uart_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to init sc16is7xx spi --> %d\\n\", ret);\n\t\tgoto err_spi;\n\t}\n#endif\n\treturn ret;\n\n#ifdef CONFIG_SERIAL_SC16IS7XX_SPI\nerr_spi:\n#endif\n#ifdef CONFIG_SERIAL_SC16IS7XX_I2C\n\ti2c_del_driver(&sc16is7xx_i2c_uart_driver);\nerr_i2c:\n#endif\n\tuart_unregister_driver(&sc16is7xx_uart);\n\treturn ret;\n}\nmodule_init(sc16is7xx_init);\n\nstatic void __exit sc16is7xx_exit(void)\n{\n#ifdef CONFIG_SERIAL_SC16IS7XX_I2C\n\ti2c_del_driver(&sc16is7xx_i2c_uart_driver);\n#endif\n\n#ifdef CONFIG_SERIAL_SC16IS7XX_SPI\n\tspi_unregister_driver(&sc16is7xx_spi_uart_driver);\n#endif\n\tuart_unregister_driver(&sc16is7xx_uart);\n}\nmodule_exit(sc16is7xx_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jon Ringle <jringle@gridpoint.com>\");\nMODULE_DESCRIPTION(\"SC16IS7XX serial driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}