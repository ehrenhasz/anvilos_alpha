{
  "module_name": "mxs-auart.c",
  "hash_id": "34a40522b8da39823f5aecd2ee6b0adb8aea5468301424a44a3d35d69bb86006",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/mxs-auart.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/platform_device.h>\n#include <linux/device.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/err.h>\n#include <linux/irq.h>\n#include \"serial_mctrl_gpio.h\"\n\n#define MXS_AUART_PORTS 5\n#define MXS_AUART_FIFO_SIZE\t\t16\n\n#define SET_REG\t\t\t\t0x4\n#define CLR_REG\t\t\t\t0x8\n#define TOG_REG\t\t\t\t0xc\n\n#define AUART_CTRL0\t\t\t0x00000000\n#define AUART_CTRL1\t\t\t0x00000010\n#define AUART_CTRL2\t\t\t0x00000020\n#define AUART_LINECTRL\t\t\t0x00000030\n#define AUART_LINECTRL2\t\t\t0x00000040\n#define AUART_INTR\t\t\t0x00000050\n#define AUART_DATA\t\t\t0x00000060\n#define AUART_STAT\t\t\t0x00000070\n#define AUART_DEBUG\t\t\t0x00000080\n#define AUART_VERSION\t\t\t0x00000090\n#define AUART_AUTOBAUD\t\t\t0x000000a0\n\n#define AUART_CTRL0_SFTRST\t\t\t(1 << 31)\n#define AUART_CTRL0_CLKGATE\t\t\t(1 << 30)\n#define AUART_CTRL0_RXTO_ENABLE\t\t\t(1 << 27)\n#define AUART_CTRL0_RXTIMEOUT(v)\t\t(((v) & 0x7ff) << 16)\n#define AUART_CTRL0_XFER_COUNT(v)\t\t((v) & 0xffff)\n\n#define AUART_CTRL1_XFER_COUNT(v)\t\t((v) & 0xffff)\n\n#define AUART_CTRL2_DMAONERR\t\t\t(1 << 26)\n#define AUART_CTRL2_TXDMAE\t\t\t(1 << 25)\n#define AUART_CTRL2_RXDMAE\t\t\t(1 << 24)\n\n#define AUART_CTRL2_CTSEN\t\t\t(1 << 15)\n#define AUART_CTRL2_RTSEN\t\t\t(1 << 14)\n#define AUART_CTRL2_RTS\t\t\t\t(1 << 11)\n#define AUART_CTRL2_RXE\t\t\t\t(1 << 9)\n#define AUART_CTRL2_TXE\t\t\t\t(1 << 8)\n#define AUART_CTRL2_UARTEN\t\t\t(1 << 0)\n\n#define AUART_LINECTRL_BAUD_DIV_MAX\t\t0x003fffc0\n#define AUART_LINECTRL_BAUD_DIV_MIN\t\t0x000000ec\n#define AUART_LINECTRL_BAUD_DIVINT_SHIFT\t16\n#define AUART_LINECTRL_BAUD_DIVINT_MASK\t\t0xffff0000\n#define AUART_LINECTRL_BAUD_DIVINT(v)\t\t(((v) & 0xffff) << 16)\n#define AUART_LINECTRL_BAUD_DIVFRAC_SHIFT\t8\n#define AUART_LINECTRL_BAUD_DIVFRAC_MASK\t0x00003f00\n#define AUART_LINECTRL_BAUD_DIVFRAC(v)\t\t(((v) & 0x3f) << 8)\n#define AUART_LINECTRL_SPS\t\t\t(1 << 7)\n#define AUART_LINECTRL_WLEN_MASK\t\t0x00000060\n#define AUART_LINECTRL_WLEN(v)\t\t\t((((v) - 5) & 0x3) << 5)\n#define AUART_LINECTRL_FEN\t\t\t(1 << 4)\n#define AUART_LINECTRL_STP2\t\t\t(1 << 3)\n#define AUART_LINECTRL_EPS\t\t\t(1 << 2)\n#define AUART_LINECTRL_PEN\t\t\t(1 << 1)\n#define AUART_LINECTRL_BRK\t\t\t(1 << 0)\n\n#define AUART_INTR_RTIEN\t\t\t(1 << 22)\n#define AUART_INTR_TXIEN\t\t\t(1 << 21)\n#define AUART_INTR_RXIEN\t\t\t(1 << 20)\n#define AUART_INTR_CTSMIEN\t\t\t(1 << 17)\n#define AUART_INTR_RTIS\t\t\t\t(1 << 6)\n#define AUART_INTR_TXIS\t\t\t\t(1 << 5)\n#define AUART_INTR_RXIS\t\t\t\t(1 << 4)\n#define AUART_INTR_CTSMIS\t\t\t(1 << 1)\n\n#define AUART_STAT_BUSY\t\t\t\t(1 << 29)\n#define AUART_STAT_CTS\t\t\t\t(1 << 28)\n#define AUART_STAT_TXFE\t\t\t\t(1 << 27)\n#define AUART_STAT_TXFF\t\t\t\t(1 << 25)\n#define AUART_STAT_RXFE\t\t\t\t(1 << 24)\n#define AUART_STAT_OERR\t\t\t\t(1 << 19)\n#define AUART_STAT_BERR\t\t\t\t(1 << 18)\n#define AUART_STAT_PERR\t\t\t\t(1 << 17)\n#define AUART_STAT_FERR\t\t\t\t(1 << 16)\n#define AUART_STAT_RXCOUNT_MASK\t\t\t0xffff\n\n \n#define ASM9260_HW_CTRL0\t\t\t0x0000\n \n#define ASM9260_BM_CTRL0_RXDMA_RUN\t\tBIT(28)\n \n#define ASM9260_BM_CTRL0_RXTO_SOURCE_STATUS\tBIT(25)\n \n#define ASM9260_BM_CTRL0_RXTO_ENABLE\t\tBIT(24)\n \n#define ASM9260_BM_CTRL0_RXTO_MASK\t\t(0xff << 16)\n \n#define ASM9260_BM_CTRL0_DEFAULT_RXTIMEOUT\t(20 << 16)\n\n \n#define ASM9260_HW_CTRL1\t\t\t0x0010\n \n#define ASM9260_BM_CTRL1_TXDMA_RUN\t\tBIT(28)\n\n#define ASM9260_HW_CTRL2\t\t\t0x0020\n \n#define ASM9260_BM_CTRL2_RXIFLSEL\t\t(7 << 20)\n#define ASM9260_BM_CTRL2_DEFAULT_RXIFLSEL\t(3 << 20)\n \n#define ASM9260_BM_CTRL2_TXIFLSEL\t\t(7 << 16)\n#define ASM9260_BM_CTRL2_DEFAULT_TXIFLSEL\t(2 << 16)\n \n#define ASM9260_BM_CTRL2_DTR\t\t\tBIT(10)\n \n#define ASM9260_BM_CTRL2_LBE\t\t\tBIT(7)\n#define ASM9260_BM_CTRL2_PORT_ENABLE\t\tBIT(0)\n\n#define ASM9260_HW_LINECTRL\t\t\t0x0030\n \n#define ASM9260_BM_LCTRL_SPS\t\t\tBIT(7)\n \n#define ASM9260_BM_LCTRL_WLEN\t\t\t(3 << 5)\n#define ASM9260_BM_LCTRL_CHRL_5\t\t\t(0 << 5)\n#define ASM9260_BM_LCTRL_CHRL_6\t\t\t(1 << 5)\n#define ASM9260_BM_LCTRL_CHRL_7\t\t\t(2 << 5)\n#define ASM9260_BM_LCTRL_CHRL_8\t\t\t(3 << 5)\n\n \n#define ASM9260_HW_INTR\t\t\t\t0x0040\n \n#define ASM9260_BM_INTR_TFEIEN\t\t\tBIT(27)\n \n#define ASM9260_BM_INTR_OEIEN\t\t\tBIT(26)\n \n#define ASM9260_BM_INTR_BEIEN\t\t\tBIT(25)\n \n#define ASM9260_BM_INTR_PEIEN\t\t\tBIT(24)\n \n#define ASM9260_BM_INTR_FEIEN\t\t\tBIT(23)\n\n \n#define ASM9260_BM_INTR_DSRMIEN\t\t\tBIT(19)\n \n#define ASM9260_BM_INTR_DCDMIEN\t\t\tBIT(18)\n \n#define ASM9260_BM_INTR_RIMIEN\t\t\tBIT(16)\n \n#define ASM9260_BM_INTR_ABTO\t\t\tBIT(13)\n#define ASM9260_BM_INTR_ABEO\t\t\tBIT(12)\n \n#define ASM9260_BM_INTR_TFEIS\t\t\tBIT(11)\n \n#define ASM9260_BM_INTR_OEIS\t\t\tBIT(10)\n \n#define ASM9260_BM_INTR_BEIS\t\t\tBIT(9)\n \n#define ASM9260_BM_INTR_PEIS\t\t\tBIT(8)\n \n#define ASM9260_BM_INTR_FEIS\t\t\tBIT(7)\n#define ASM9260_BM_INTR_DSRMIS\t\t\tBIT(3)\n#define ASM9260_BM_INTR_DCDMIS\t\t\tBIT(2)\n#define ASM9260_BM_INTR_RIMIS\t\t\tBIT(0)\n\n \n#define ASM9260_HW_DATA\t\t\t\t0x0050\n\n#define ASM9260_HW_STAT\t\t\t\t0x0060\n \n#define ASM9260_BM_STAT_PRESENT\t\t\tBIT(31)\n \n#define ASM9260_BM_STAT_HISPEED\t\t\tBIT(30)\n \n#define ASM9260_BM_STAT_RXFULL\t\t\tBIT(26)\n\n \n#define ASM9260_HW_DEBUG\t\t\t0x0070\n \n#define ASM9260_BM_DEBUG_TXDMARUN\t\tBIT(5)\n#define ASM9260_BM_DEBUG_RXDMARUN\t\tBIT(4)\n \n#define ASM9260_BM_DEBUG_TXCMDEND\t\tBIT(3)\n#define ASM9260_BM_DEBUG_RXCMDEND\t\tBIT(2)\n \n#define ASM9260_BM_DEBUG_TXDMARQ\t\tBIT(1)\n#define ASM9260_BM_DEBUG_RXDMARQ\t\tBIT(0)\n\n#define ASM9260_HW_ILPR\t\t\t\t0x0080\n\n#define ASM9260_HW_RS485CTRL\t\t\t0x0090\n \n#define ASM9260_BM_RS485CTRL_ONIV\t\tBIT(5)\n \n#define ASM9260_BM_RS485CTRL_DIR_CTRL\t\tBIT(4)\n \n#define ASM9260_BM_RS485CTRL_PINSEL\t\tBIT(3)\n \n#define ASM9260_BM_RS485CTRL_AADEN\t\tBIT(2)\n \n#define ASM9260_BM_RS485CTRL_RXDIS\t\tBIT(1)\n \n#define ASM9260_BM_RS485CTRL_RS485EN\t\tBIT(0)\n\n#define ASM9260_HW_RS485ADRMATCH\t\t0x00a0\n \n#define ASM9260_BM_RS485ADRMATCH_MASK\t\t(0xff << 0)\n\n#define ASM9260_HW_RS485DLY\t\t\t0x00b0\n \n#define ASM9260_BM_RS485DLY_MASK\t\t(0xff << 0)\n\n#define ASM9260_HW_AUTOBAUD\t\t\t0x00c0\n \n#define ASM9260_BM_AUTOBAUD_TO_INT_CLR\t\tBIT(9)\n \n#define ASM9260_BM_AUTOBAUD_EO_INT_CLR\t\tBIT(8)\n \n#define ASM9260_BM_AUTOBAUD_AUTORESTART\t\tBIT(2)\n \n#define ASM9260_BM_AUTOBAUD_MODE\t\tBIT(1)\n \n#define ASM9260_BM_AUTOBAUD_START\t\tBIT(0)\n\n#define ASM9260_HW_CTRL3\t\t\t0x00d0\n#define ASM9260_BM_CTRL3_OUTCLK_DIV_MASK\t(0xffff << 16)\n \n#define ASM9260_BM_CTRL3_MASTERMODE\t\tBIT(6)\n \n#define ASM9260_BM_CTRL3_SYNCMODE\t\tBIT(4)\n \n#define ASM9260_BM_CTRL3_MSBF\t\t\tBIT(2)\n \n#define ASM9260_BM_CTRL3_BAUD8\t\t\tBIT(1)\n \n#define ASM9260_BM_CTRL3_9BIT\t\t\tBIT(0)\n\n#define ASM9260_HW_ISO7816_CTRL\t\t\t0x00e0\n \n#define ASM9260_BM_ISO7816CTRL_HS\t\tBIT(12)\n \n#define ASM9260_BM_ISO7816CTRL_DS_NACK\t\tBIT(8)\n#define ASM9260_BM_ISO7816CTRL_MAX_ITER_MASK\t(0xff << 4)\n \n#define ASM9260_BM_ISO7816CTRL_INACK\t\tBIT(3)\n#define ASM9260_BM_ISO7816CTRL_NEG_DATA\t\tBIT(2)\n \n#define ASM9260_BM_ISO7816CTRL_ENABLE\t\tBIT(0)\n\n#define ASM9260_HW_ISO7816_ERRCNT\t\t0x00f0\n \n#define ASM9260_BM_ISO7816_NB_ERRORS_MASK\t(0xff << 0)\n\n#define ASM9260_HW_ISO7816_STATUS\t\t0x0100\n \n#define ASM9260_BM_ISO7816_STAT_ITERATION\tBIT(0)\n\n \n\nstatic struct uart_driver auart_driver;\n\nenum mxs_auart_type {\n\tIMX23_AUART,\n\tIMX28_AUART,\n\tASM9260_AUART,\n};\n\nstruct vendor_data {\n\tconst u16\t*reg_offset;\n};\n\nenum {\n\tREG_CTRL0,\n\tREG_CTRL1,\n\tREG_CTRL2,\n\tREG_LINECTRL,\n\tREG_LINECTRL2,\n\tREG_INTR,\n\tREG_DATA,\n\tREG_STAT,\n\tREG_DEBUG,\n\tREG_VERSION,\n\tREG_AUTOBAUD,\n\n\t \n\tREG_ARRAY_SIZE,\n};\n\nstatic const u16 mxs_asm9260_offsets[REG_ARRAY_SIZE] = {\n\t[REG_CTRL0] = ASM9260_HW_CTRL0,\n\t[REG_CTRL1] = ASM9260_HW_CTRL1,\n\t[REG_CTRL2] = ASM9260_HW_CTRL2,\n\t[REG_LINECTRL] = ASM9260_HW_LINECTRL,\n\t[REG_INTR] = ASM9260_HW_INTR,\n\t[REG_DATA] = ASM9260_HW_DATA,\n\t[REG_STAT] = ASM9260_HW_STAT,\n\t[REG_DEBUG] = ASM9260_HW_DEBUG,\n\t[REG_AUTOBAUD] = ASM9260_HW_AUTOBAUD,\n};\n\nstatic const u16 mxs_stmp37xx_offsets[REG_ARRAY_SIZE] = {\n\t[REG_CTRL0] = AUART_CTRL0,\n\t[REG_CTRL1] = AUART_CTRL1,\n\t[REG_CTRL2] = AUART_CTRL2,\n\t[REG_LINECTRL] = AUART_LINECTRL,\n\t[REG_LINECTRL2] = AUART_LINECTRL2,\n\t[REG_INTR] = AUART_INTR,\n\t[REG_DATA] = AUART_DATA,\n\t[REG_STAT] = AUART_STAT,\n\t[REG_DEBUG] = AUART_DEBUG,\n\t[REG_VERSION] = AUART_VERSION,\n\t[REG_AUTOBAUD] = AUART_AUTOBAUD,\n};\n\nstatic const struct vendor_data vendor_alphascale_asm9260 = {\n\t.reg_offset = mxs_asm9260_offsets,\n};\n\nstatic const struct vendor_data vendor_freescale_stmp37xx = {\n\t.reg_offset = mxs_stmp37xx_offsets,\n};\n\nstruct mxs_auart_port {\n\tstruct uart_port port;\n\n#define MXS_AUART_DMA_ENABLED\t0x2\n#define MXS_AUART_DMA_TX_SYNC\t2   \n#define MXS_AUART_DMA_RX_READY\t3   \n#define MXS_AUART_RTSCTS\t4   \n\tunsigned long flags;\n\tunsigned int mctrl_prev;\n\tenum mxs_auart_type devtype;\n\tconst struct vendor_data *vendor;\n\n\tstruct clk *clk;\n\tstruct clk *clk_ahb;\n\tstruct device *dev;\n\n\t \n\tstruct scatterlist tx_sgl;\n\tstruct dma_chan\t*tx_dma_chan;\n\tvoid *tx_dma_buf;\n\n\tstruct scatterlist rx_sgl;\n\tstruct dma_chan\t*rx_dma_chan;\n\tvoid *rx_dma_buf;\n\n\tstruct mctrl_gpios\t*gpios;\n\tint\t\t\tgpio_irq[UART_GPIO_MAX];\n\tbool\t\t\tms_irq_enabled;\n};\n\nstatic const struct of_device_id mxs_auart_dt_ids[] = {\n\t{\n\t\t.compatible = \"fsl,imx28-auart\",\n\t\t.data = (const void *)IMX28_AUART\n\t}, {\n\t\t.compatible = \"fsl,imx23-auart\",\n\t\t.data = (const void *)IMX23_AUART\n\t}, {\n\t\t.compatible = \"alphascale,asm9260-auart\",\n\t\t.data = (const void *)ASM9260_AUART\n\t}, {   }\n};\nMODULE_DEVICE_TABLE(of, mxs_auart_dt_ids);\n\nstatic inline int is_imx28_auart(struct mxs_auart_port *s)\n{\n\treturn s->devtype == IMX28_AUART;\n}\n\nstatic inline int is_asm9260_auart(struct mxs_auart_port *s)\n{\n\treturn s->devtype == ASM9260_AUART;\n}\n\nstatic inline bool auart_dma_enabled(struct mxs_auart_port *s)\n{\n\treturn s->flags & MXS_AUART_DMA_ENABLED;\n}\n\nstatic unsigned int mxs_reg_to_offset(const struct mxs_auart_port *uap,\n\t\t\t\t      unsigned int reg)\n{\n\treturn uap->vendor->reg_offset[reg];\n}\n\nstatic unsigned int mxs_read(const struct mxs_auart_port *uap,\n\t\t\t     unsigned int reg)\n{\n\tvoid __iomem *addr = uap->port.membase + mxs_reg_to_offset(uap, reg);\n\n\treturn readl_relaxed(addr);\n}\n\nstatic void mxs_write(unsigned int val, struct mxs_auart_port *uap,\n\t\t      unsigned int reg)\n{\n\tvoid __iomem *addr = uap->port.membase + mxs_reg_to_offset(uap, reg);\n\n\twritel_relaxed(val, addr);\n}\n\nstatic void mxs_set(unsigned int val, struct mxs_auart_port *uap,\n\t\t    unsigned int reg)\n{\n\tvoid __iomem *addr = uap->port.membase + mxs_reg_to_offset(uap, reg);\n\n\twritel_relaxed(val, addr + SET_REG);\n}\n\nstatic void mxs_clr(unsigned int val, struct mxs_auart_port *uap,\n\t\t    unsigned int reg)\n{\n\tvoid __iomem *addr = uap->port.membase + mxs_reg_to_offset(uap, reg);\n\n\twritel_relaxed(val, addr + CLR_REG);\n}\n\nstatic void mxs_auart_stop_tx(struct uart_port *u);\n\n#define to_auart_port(u) container_of(u, struct mxs_auart_port, port)\n\nstatic void mxs_auart_tx_chars(struct mxs_auart_port *s);\n\nstatic void dma_tx_callback(void *param)\n{\n\tstruct mxs_auart_port *s = param;\n\tstruct circ_buf *xmit = &s->port.state->xmit;\n\n\tdma_unmap_sg(s->dev, &s->tx_sgl, 1, DMA_TO_DEVICE);\n\n\t \n\tclear_bit(MXS_AUART_DMA_TX_SYNC, &s->flags);\n\tsmp_mb__after_atomic();\n\n\t \n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&s->port);\n\n\tmxs_auart_tx_chars(s);\n}\n\nstatic int mxs_auart_dma_tx(struct mxs_auart_port *s, int size)\n{\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct scatterlist *sgl = &s->tx_sgl;\n\tstruct dma_chan *channel = s->tx_dma_chan;\n\tu32 pio;\n\n\t \n\tpio = AUART_CTRL1_XFER_COUNT(size);\n\tdesc = dmaengine_prep_slave_sg(channel, (struct scatterlist *)&pio,\n\t\t\t\t\t1, DMA_TRANS_NONE, 0);\n\tif (!desc) {\n\t\tdev_err(s->dev, \"step 1 error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsg_init_one(sgl, s->tx_dma_buf, size);\n\tdma_map_sg(s->dev, sgl, 1, DMA_TO_DEVICE);\n\tdesc = dmaengine_prep_slave_sg(channel, sgl,\n\t\t\t1, DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdev_err(s->dev, \"step 2 error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdesc->callback = dma_tx_callback;\n\tdesc->callback_param = s;\n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(channel);\n\treturn 0;\n}\n\nstatic void mxs_auart_tx_chars(struct mxs_auart_port *s)\n{\n\tstruct circ_buf *xmit = &s->port.state->xmit;\n\tbool pending;\n\tu8 ch;\n\n\tif (auart_dma_enabled(s)) {\n\t\tu32 i = 0;\n\t\tint size;\n\t\tvoid *buffer = s->tx_dma_buf;\n\n\t\tif (test_and_set_bit(MXS_AUART_DMA_TX_SYNC, &s->flags))\n\t\t\treturn;\n\n\t\twhile (!uart_circ_empty(xmit) && !uart_tx_stopped(&s->port)) {\n\t\t\tsize = min_t(u32, UART_XMIT_SIZE - i,\n\t\t\t\t     CIRC_CNT_TO_END(xmit->head,\n\t\t\t\t\t\t     xmit->tail,\n\t\t\t\t\t\t     UART_XMIT_SIZE));\n\t\t\tmemcpy(buffer + i, xmit->buf + xmit->tail, size);\n\t\t\txmit->tail = (xmit->tail + size) & (UART_XMIT_SIZE - 1);\n\n\t\t\ti += size;\n\t\t\tif (i >= UART_XMIT_SIZE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (uart_tx_stopped(&s->port))\n\t\t\tmxs_auart_stop_tx(&s->port);\n\n\t\tif (i) {\n\t\t\tmxs_auart_dma_tx(s, i);\n\t\t} else {\n\t\t\tclear_bit(MXS_AUART_DMA_TX_SYNC, &s->flags);\n\t\t\tsmp_mb__after_atomic();\n\t\t}\n\t\treturn;\n\t}\n\n\tpending = uart_port_tx(&s->port, ch,\n\t\t!(mxs_read(s, REG_STAT) & AUART_STAT_TXFF),\n\t\tmxs_write(ch, s, REG_DATA));\n\tif (pending)\n\t\tmxs_set(AUART_INTR_TXIEN, s, REG_INTR);\n\telse\n\t\tmxs_clr(AUART_INTR_TXIEN, s, REG_INTR);\n}\n\nstatic void mxs_auart_rx_char(struct mxs_auart_port *s)\n{\n\tu32 stat;\n\tu8 c, flag;\n\n\tc = mxs_read(s, REG_DATA);\n\tstat = mxs_read(s, REG_STAT);\n\n\tflag = TTY_NORMAL;\n\ts->port.icount.rx++;\n\n\tif (stat & AUART_STAT_BERR) {\n\t\ts->port.icount.brk++;\n\t\tif (uart_handle_break(&s->port))\n\t\t\tgoto out;\n\t} else if (stat & AUART_STAT_PERR) {\n\t\ts->port.icount.parity++;\n\t} else if (stat & AUART_STAT_FERR) {\n\t\ts->port.icount.frame++;\n\t}\n\n\t \n\tstat &= s->port.read_status_mask;\n\n\tif (stat & AUART_STAT_BERR) {\n\t\tflag = TTY_BREAK;\n\t} else if (stat & AUART_STAT_PERR)\n\t\tflag = TTY_PARITY;\n\telse if (stat & AUART_STAT_FERR)\n\t\tflag = TTY_FRAME;\n\n\tif (stat & AUART_STAT_OERR)\n\t\ts->port.icount.overrun++;\n\n\tif (uart_handle_sysrq_char(&s->port, c))\n\t\tgoto out;\n\n\tuart_insert_char(&s->port, stat, AUART_STAT_OERR, c, flag);\nout:\n\tmxs_write(stat, s, REG_STAT);\n}\n\nstatic void mxs_auart_rx_chars(struct mxs_auart_port *s)\n{\n\tu32 stat = 0;\n\n\tfor (;;) {\n\t\tstat = mxs_read(s, REG_STAT);\n\t\tif (stat & AUART_STAT_RXFE)\n\t\t\tbreak;\n\t\tmxs_auart_rx_char(s);\n\t}\n\n\tmxs_write(stat, s, REG_STAT);\n\ttty_flip_buffer_push(&s->port.state->port);\n}\n\nstatic int mxs_auart_request_port(struct uart_port *u)\n{\n\treturn 0;\n}\n\nstatic int mxs_auart_verify_port(struct uart_port *u,\n\t\t\t\t    struct serial_struct *ser)\n{\n\tif (u->type != PORT_UNKNOWN && u->type != PORT_IMX)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void mxs_auart_config_port(struct uart_port *u, int flags)\n{\n}\n\nstatic const char *mxs_auart_type(struct uart_port *u)\n{\n\tstruct mxs_auart_port *s = to_auart_port(u);\n\n\treturn dev_name(s->dev);\n}\n\nstatic void mxs_auart_release_port(struct uart_port *u)\n{\n}\n\nstatic void mxs_auart_set_mctrl(struct uart_port *u, unsigned mctrl)\n{\n\tstruct mxs_auart_port *s = to_auart_port(u);\n\n\tu32 ctrl = mxs_read(s, REG_CTRL2);\n\n\tctrl &= ~(AUART_CTRL2_RTSEN | AUART_CTRL2_RTS);\n\tif (mctrl & TIOCM_RTS) {\n\t\tif (uart_cts_enabled(u))\n\t\t\tctrl |= AUART_CTRL2_RTSEN;\n\t\telse\n\t\t\tctrl |= AUART_CTRL2_RTS;\n\t}\n\n\tmxs_write(ctrl, s, REG_CTRL2);\n\n\tmctrl_gpio_set(s->gpios, mctrl);\n}\n\n#define MCTRL_ANY_DELTA        (TIOCM_RI | TIOCM_DSR | TIOCM_CD | TIOCM_CTS)\nstatic u32 mxs_auart_modem_status(struct mxs_auart_port *s, u32 mctrl)\n{\n\tu32 mctrl_diff;\n\n\tmctrl_diff = mctrl ^ s->mctrl_prev;\n\ts->mctrl_prev = mctrl;\n\tif (mctrl_diff & MCTRL_ANY_DELTA && s->ms_irq_enabled &&\n\t\t\t\t\t\ts->port.state != NULL) {\n\t\tif (mctrl_diff & TIOCM_RI)\n\t\t\ts->port.icount.rng++;\n\t\tif (mctrl_diff & TIOCM_DSR)\n\t\t\ts->port.icount.dsr++;\n\t\tif (mctrl_diff & TIOCM_CD)\n\t\t\tuart_handle_dcd_change(&s->port, mctrl & TIOCM_CD);\n\t\tif (mctrl_diff & TIOCM_CTS)\n\t\t\tuart_handle_cts_change(&s->port, mctrl & TIOCM_CTS);\n\n\t\twake_up_interruptible(&s->port.state->port.delta_msr_wait);\n\t}\n\treturn mctrl;\n}\n\nstatic u32 mxs_auart_get_mctrl(struct uart_port *u)\n{\n\tstruct mxs_auart_port *s = to_auart_port(u);\n\tu32 stat = mxs_read(s, REG_STAT);\n\tu32 mctrl = 0;\n\n\tif (stat & AUART_STAT_CTS)\n\t\tmctrl |= TIOCM_CTS;\n\n\treturn mctrl_gpio_get(s->gpios, &mctrl);\n}\n\n \nstatic void mxs_auart_enable_ms(struct uart_port *port)\n{\n\tstruct mxs_auart_port *s = to_auart_port(port);\n\n\t \n\tif (s->ms_irq_enabled)\n\t\treturn;\n\n\ts->ms_irq_enabled = true;\n\n\tif (s->gpio_irq[UART_GPIO_CTS] >= 0)\n\t\tenable_irq(s->gpio_irq[UART_GPIO_CTS]);\n\t \n\n\tif (s->gpio_irq[UART_GPIO_DSR] >= 0)\n\t\tenable_irq(s->gpio_irq[UART_GPIO_DSR]);\n\n\tif (s->gpio_irq[UART_GPIO_RI] >= 0)\n\t\tenable_irq(s->gpio_irq[UART_GPIO_RI]);\n\n\tif (s->gpio_irq[UART_GPIO_DCD] >= 0)\n\t\tenable_irq(s->gpio_irq[UART_GPIO_DCD]);\n}\n\n \nstatic void mxs_auart_disable_ms(struct uart_port *port)\n{\n\tstruct mxs_auart_port *s = to_auart_port(port);\n\n\t \n\tif (!s->ms_irq_enabled)\n\t\treturn;\n\n\ts->ms_irq_enabled = false;\n\n\tif (s->gpio_irq[UART_GPIO_CTS] >= 0)\n\t\tdisable_irq(s->gpio_irq[UART_GPIO_CTS]);\n\t \n\n\tif (s->gpio_irq[UART_GPIO_DSR] >= 0)\n\t\tdisable_irq(s->gpio_irq[UART_GPIO_DSR]);\n\n\tif (s->gpio_irq[UART_GPIO_RI] >= 0)\n\t\tdisable_irq(s->gpio_irq[UART_GPIO_RI]);\n\n\tif (s->gpio_irq[UART_GPIO_DCD] >= 0)\n\t\tdisable_irq(s->gpio_irq[UART_GPIO_DCD]);\n}\n\nstatic int mxs_auart_dma_prep_rx(struct mxs_auart_port *s);\nstatic void dma_rx_callback(void *arg)\n{\n\tstruct mxs_auart_port *s = (struct mxs_auart_port *) arg;\n\tstruct tty_port *port = &s->port.state->port;\n\tint count;\n\tu32 stat;\n\n\tdma_unmap_sg(s->dev, &s->rx_sgl, 1, DMA_FROM_DEVICE);\n\n\tstat = mxs_read(s, REG_STAT);\n\tstat &= ~(AUART_STAT_OERR | AUART_STAT_BERR |\n\t\t\tAUART_STAT_PERR | AUART_STAT_FERR);\n\n\tcount = stat & AUART_STAT_RXCOUNT_MASK;\n\ttty_insert_flip_string(port, s->rx_dma_buf, count);\n\n\tmxs_write(stat, s, REG_STAT);\n\ttty_flip_buffer_push(port);\n\n\t \n\tmxs_auart_dma_prep_rx(s);\n}\n\nstatic int mxs_auart_dma_prep_rx(struct mxs_auart_port *s)\n{\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct scatterlist *sgl = &s->rx_sgl;\n\tstruct dma_chan *channel = s->rx_dma_chan;\n\tu32 pio[1];\n\n\t \n\tpio[0] = AUART_CTRL0_RXTO_ENABLE\n\t\t| AUART_CTRL0_RXTIMEOUT(0x80)\n\t\t| AUART_CTRL0_XFER_COUNT(UART_XMIT_SIZE);\n\tdesc = dmaengine_prep_slave_sg(channel, (struct scatterlist *)pio,\n\t\t\t\t\t1, DMA_TRANS_NONE, 0);\n\tif (!desc) {\n\t\tdev_err(s->dev, \"step 1 error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsg_init_one(sgl, s->rx_dma_buf, UART_XMIT_SIZE);\n\tdma_map_sg(s->dev, sgl, 1, DMA_FROM_DEVICE);\n\tdesc = dmaengine_prep_slave_sg(channel, sgl, 1, DMA_DEV_TO_MEM,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdev_err(s->dev, \"step 2 error\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tdesc->callback = dma_rx_callback;\n\tdesc->callback_param = s;\n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(channel);\n\treturn 0;\n}\n\nstatic void mxs_auart_dma_exit_channel(struct mxs_auart_port *s)\n{\n\tif (s->tx_dma_chan) {\n\t\tdma_release_channel(s->tx_dma_chan);\n\t\ts->tx_dma_chan = NULL;\n\t}\n\tif (s->rx_dma_chan) {\n\t\tdma_release_channel(s->rx_dma_chan);\n\t\ts->rx_dma_chan = NULL;\n\t}\n\n\tkfree(s->tx_dma_buf);\n\tkfree(s->rx_dma_buf);\n\ts->tx_dma_buf = NULL;\n\ts->rx_dma_buf = NULL;\n}\n\nstatic void mxs_auart_dma_exit(struct mxs_auart_port *s)\n{\n\n\tmxs_clr(AUART_CTRL2_TXDMAE | AUART_CTRL2_RXDMAE | AUART_CTRL2_DMAONERR,\n\t\ts, REG_CTRL2);\n\n\tmxs_auart_dma_exit_channel(s);\n\ts->flags &= ~MXS_AUART_DMA_ENABLED;\n\tclear_bit(MXS_AUART_DMA_TX_SYNC, &s->flags);\n\tclear_bit(MXS_AUART_DMA_RX_READY, &s->flags);\n}\n\nstatic int mxs_auart_dma_init(struct mxs_auart_port *s)\n{\n\tif (auart_dma_enabled(s))\n\t\treturn 0;\n\n\t \n\ts->rx_dma_chan = dma_request_slave_channel(s->dev, \"rx\");\n\tif (!s->rx_dma_chan)\n\t\tgoto err_out;\n\ts->rx_dma_buf = kzalloc(UART_XMIT_SIZE, GFP_KERNEL | GFP_DMA);\n\tif (!s->rx_dma_buf)\n\t\tgoto err_out;\n\n\t \n\ts->tx_dma_chan = dma_request_slave_channel(s->dev, \"tx\");\n\tif (!s->tx_dma_chan)\n\t\tgoto err_out;\n\ts->tx_dma_buf = kzalloc(UART_XMIT_SIZE, GFP_KERNEL | GFP_DMA);\n\tif (!s->tx_dma_buf)\n\t\tgoto err_out;\n\n\t \n\ts->flags |= MXS_AUART_DMA_ENABLED;\n\tdev_dbg(s->dev, \"enabled the DMA support.\");\n\n\t \n\ts->port.fifosize = UART_XMIT_SIZE;\n\n\treturn 0;\n\nerr_out:\n\tmxs_auart_dma_exit_channel(s);\n\treturn -EINVAL;\n\n}\n\n#define RTS_AT_AUART()\t!mctrl_gpio_to_gpiod(s->gpios, UART_GPIO_RTS)\n#define CTS_AT_AUART()\t!mctrl_gpio_to_gpiod(s->gpios, UART_GPIO_CTS)\nstatic void mxs_auart_settermios(struct uart_port *u,\n\t\t\t\t struct ktermios *termios,\n\t\t\t\t const struct ktermios *old)\n{\n\tstruct mxs_auart_port *s = to_auart_port(u);\n\tu32 ctrl, ctrl2, div;\n\tunsigned int cflag, baud, baud_min, baud_max;\n\n\tcflag = termios->c_cflag;\n\n\tctrl = AUART_LINECTRL_FEN;\n\tctrl2 = mxs_read(s, REG_CTRL2);\n\n\tctrl |= AUART_LINECTRL_WLEN(tty_get_char_size(cflag));\n\n\t \n\tif (cflag & PARENB) {\n\t\tctrl |= AUART_LINECTRL_PEN;\n\t\tif ((cflag & PARODD) == 0)\n\t\t\tctrl |= AUART_LINECTRL_EPS;\n\t\tif (cflag & CMSPAR)\n\t\t\tctrl |= AUART_LINECTRL_SPS;\n\t}\n\n\tu->read_status_mask = AUART_STAT_OERR;\n\n\tif (termios->c_iflag & INPCK)\n\t\tu->read_status_mask |= AUART_STAT_PERR;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tu->read_status_mask |= AUART_STAT_BERR;\n\n\t \n\tu->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tu->ignore_status_mask |= AUART_STAT_PERR;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tu->ignore_status_mask |= AUART_STAT_BERR;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tu->ignore_status_mask |= AUART_STAT_OERR;\n\t}\n\n\t \n\tif (cflag & CREAD)\n\t\tctrl2 |= AUART_CTRL2_RXE;\n\telse\n\t\tctrl2 &= ~AUART_CTRL2_RXE;\n\n\t \n\tif (cflag & CSTOPB)\n\t\tctrl |= AUART_LINECTRL_STP2;\n\n\t \n\tctrl2 &= ~(AUART_CTRL2_CTSEN | AUART_CTRL2_RTSEN);\n\tif (cflag & CRTSCTS) {\n\t\t \n\t\tif (is_imx28_auart(s)\n\t\t\t\t&& test_bit(MXS_AUART_RTSCTS, &s->flags)) {\n\t\t\tif (!mxs_auart_dma_init(s))\n\t\t\t\t \n\t\t\t\tctrl2 |= AUART_CTRL2_TXDMAE | AUART_CTRL2_RXDMAE\n\t\t\t\t       | AUART_CTRL2_DMAONERR;\n\t\t}\n\t\t \n\t\tctrl2 |= AUART_CTRL2_RTSEN;\n\t\tif (CTS_AT_AUART())\n\t\t\tctrl2 |= AUART_CTRL2_CTSEN;\n\t}\n\n\t \n\tif (is_asm9260_auart(s)) {\n\t\tbaud = uart_get_baud_rate(u, termios, old,\n\t\t\t\t\t  u->uartclk * 4 / 0x3FFFFF,\n\t\t\t\t\t  u->uartclk / 16);\n\t\tdiv = u->uartclk * 4 / baud;\n\t} else {\n\t\tbaud_min = DIV_ROUND_UP(u->uartclk * 32,\n\t\t\t\t\tAUART_LINECTRL_BAUD_DIV_MAX);\n\t\tbaud_max = u->uartclk * 32 / AUART_LINECTRL_BAUD_DIV_MIN;\n\t\tbaud = uart_get_baud_rate(u, termios, old, baud_min, baud_max);\n\t\tdiv = DIV_ROUND_CLOSEST(u->uartclk * 32, baud);\n\t}\n\n\tctrl |= AUART_LINECTRL_BAUD_DIVFRAC(div & 0x3F);\n\tctrl |= AUART_LINECTRL_BAUD_DIVINT(div >> 6);\n\tmxs_write(ctrl, s, REG_LINECTRL);\n\n\tmxs_write(ctrl2, s, REG_CTRL2);\n\n\tuart_update_timeout(u, termios->c_cflag, baud);\n\n\t \n\tif (auart_dma_enabled(s) &&\n\t\t!test_and_set_bit(MXS_AUART_DMA_RX_READY, &s->flags)) {\n\t\tif (!mxs_auart_dma_prep_rx(s)) {\n\t\t\t \n\t\t\tmxs_clr(AUART_INTR_RXIEN | AUART_INTR_RTIEN,\n\t\t\t\ts, REG_INTR);\n\t\t} else {\n\t\t\tmxs_auart_dma_exit(s);\n\t\t\tdev_err(s->dev, \"We can not start up the DMA.\\n\");\n\t\t}\n\t}\n\n\t \n\tif (UART_ENABLE_MS(u, termios->c_cflag))\n\t\tmxs_auart_enable_ms(u);\n\telse\n\t\tmxs_auart_disable_ms(u);\n}\n\nstatic void mxs_auart_set_ldisc(struct uart_port *port,\n\t\t\t\tstruct ktermios *termios)\n{\n\tif (termios->c_line == N_PPS) {\n\t\tport->flags |= UPF_HARDPPS_CD;\n\t\tmxs_auart_enable_ms(port);\n\t} else {\n\t\tport->flags &= ~UPF_HARDPPS_CD;\n\t}\n}\n\nstatic irqreturn_t mxs_auart_irq_handle(int irq, void *context)\n{\n\tu32 istat;\n\tstruct mxs_auart_port *s = context;\n\tu32 mctrl_temp = s->mctrl_prev;\n\tu32 stat = mxs_read(s, REG_STAT);\n\n\tistat = mxs_read(s, REG_INTR);\n\n\t \n\tmxs_clr(istat & (AUART_INTR_RTIS | AUART_INTR_TXIS | AUART_INTR_RXIS\n\t\t| AUART_INTR_CTSMIS), s, REG_INTR);\n\n\t \n\tif (irq == s->gpio_irq[UART_GPIO_CTS] ||\n\t    irq == s->gpio_irq[UART_GPIO_DCD] ||\n\t    irq == s->gpio_irq[UART_GPIO_DSR] ||\n\t    irq == s->gpio_irq[UART_GPIO_RI])\n\t\tmxs_auart_modem_status(s,\n\t\t\t\tmctrl_gpio_get(s->gpios, &mctrl_temp));\n\n\tif (istat & AUART_INTR_CTSMIS) {\n\t\tif (CTS_AT_AUART() && s->ms_irq_enabled)\n\t\t\tuart_handle_cts_change(&s->port,\n\t\t\t\t\tstat & AUART_STAT_CTS);\n\t\tmxs_clr(AUART_INTR_CTSMIS, s, REG_INTR);\n\t\tistat &= ~AUART_INTR_CTSMIS;\n\t}\n\n\tif (istat & (AUART_INTR_RTIS | AUART_INTR_RXIS)) {\n\t\tif (!auart_dma_enabled(s))\n\t\t\tmxs_auart_rx_chars(s);\n\t\tistat &= ~(AUART_INTR_RTIS | AUART_INTR_RXIS);\n\t}\n\n\tif (istat & AUART_INTR_TXIS) {\n\t\tmxs_auart_tx_chars(s);\n\t\tistat &= ~AUART_INTR_TXIS;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mxs_auart_reset_deassert(struct mxs_auart_port *s)\n{\n\tint i;\n\tunsigned int reg;\n\n\tmxs_clr(AUART_CTRL0_SFTRST, s, REG_CTRL0);\n\n\tfor (i = 0; i < 10000; i++) {\n\t\treg = mxs_read(s, REG_CTRL0);\n\t\tif (!(reg & AUART_CTRL0_SFTRST))\n\t\t\tbreak;\n\t\tudelay(3);\n\t}\n\tmxs_clr(AUART_CTRL0_CLKGATE, s, REG_CTRL0);\n}\n\nstatic void mxs_auart_reset_assert(struct mxs_auart_port *s)\n{\n\tint i;\n\tu32 reg;\n\n\treg = mxs_read(s, REG_CTRL0);\n\t \n\tif (reg & AUART_CTRL0_SFTRST)\n\t\treturn;\n\n\tmxs_clr(AUART_CTRL0_CLKGATE, s, REG_CTRL0);\n\tmxs_set(AUART_CTRL0_SFTRST, s, REG_CTRL0);\n\n\tfor (i = 0; i < 1000; i++) {\n\t\treg = mxs_read(s, REG_CTRL0);\n\t\t \n\t\tif (reg & AUART_CTRL0_CLKGATE)\n\t\t\treturn;\n\t\tudelay(10);\n\t}\n\n\tdev_err(s->dev, \"Failed to reset the unit.\");\n}\n\nstatic int mxs_auart_startup(struct uart_port *u)\n{\n\tint ret;\n\tstruct mxs_auart_port *s = to_auart_port(u);\n\n\tret = clk_prepare_enable(s->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (uart_console(u)) {\n\t\tmxs_clr(AUART_CTRL0_CLKGATE, s, REG_CTRL0);\n\t} else {\n\t\t \n\t\tmxs_auart_reset_assert(s);\n\t\tmxs_auart_reset_deassert(s);\n\t}\n\n\tmxs_set(AUART_CTRL2_UARTEN, s, REG_CTRL2);\n\n\tmxs_write(AUART_INTR_RXIEN | AUART_INTR_RTIEN | AUART_INTR_CTSMIEN,\n\t\t  s, REG_INTR);\n\n\t \n\tu->fifosize = MXS_AUART_FIFO_SIZE;\n\n\t \n\tmxs_set(AUART_LINECTRL_FEN, s, REG_LINECTRL);\n\n\t \n\tmctrl_gpio_get(s->gpios, &s->mctrl_prev);\n\n\ts->ms_irq_enabled = false;\n\treturn 0;\n}\n\nstatic void mxs_auart_shutdown(struct uart_port *u)\n{\n\tstruct mxs_auart_port *s = to_auart_port(u);\n\n\tmxs_auart_disable_ms(u);\n\n\tif (auart_dma_enabled(s))\n\t\tmxs_auart_dma_exit(s);\n\n\tif (uart_console(u)) {\n\t\tmxs_clr(AUART_CTRL2_UARTEN, s, REG_CTRL2);\n\n\t\tmxs_clr(AUART_INTR_RXIEN | AUART_INTR_RTIEN |\n\t\t\tAUART_INTR_CTSMIEN, s, REG_INTR);\n\t\tmxs_set(AUART_CTRL0_CLKGATE, s, REG_CTRL0);\n\t} else {\n\t\tmxs_auart_reset_assert(s);\n\t}\n\n\tclk_disable_unprepare(s->clk);\n}\n\nstatic unsigned int mxs_auart_tx_empty(struct uart_port *u)\n{\n\tstruct mxs_auart_port *s = to_auart_port(u);\n\n\tif ((mxs_read(s, REG_STAT) &\n\t\t (AUART_STAT_TXFE | AUART_STAT_BUSY)) == AUART_STAT_TXFE)\n\t\treturn TIOCSER_TEMT;\n\n\treturn 0;\n}\n\nstatic void mxs_auart_start_tx(struct uart_port *u)\n{\n\tstruct mxs_auart_port *s = to_auart_port(u);\n\n\t \n\tmxs_set(AUART_CTRL2_TXE, s, REG_CTRL2);\n\n\tmxs_auart_tx_chars(s);\n}\n\nstatic void mxs_auart_stop_tx(struct uart_port *u)\n{\n\tstruct mxs_auart_port *s = to_auart_port(u);\n\n\tmxs_clr(AUART_CTRL2_TXE, s, REG_CTRL2);\n}\n\nstatic void mxs_auart_stop_rx(struct uart_port *u)\n{\n\tstruct mxs_auart_port *s = to_auart_port(u);\n\n\tmxs_clr(AUART_CTRL2_RXE, s, REG_CTRL2);\n}\n\nstatic void mxs_auart_break_ctl(struct uart_port *u, int ctl)\n{\n\tstruct mxs_auart_port *s = to_auart_port(u);\n\n\tif (ctl)\n\t\tmxs_set(AUART_LINECTRL_BRK, s, REG_LINECTRL);\n\telse\n\t\tmxs_clr(AUART_LINECTRL_BRK, s, REG_LINECTRL);\n}\n\nstatic const struct uart_ops mxs_auart_ops = {\n\t.tx_empty       = mxs_auart_tx_empty,\n\t.start_tx       = mxs_auart_start_tx,\n\t.stop_tx\t= mxs_auart_stop_tx,\n\t.stop_rx\t= mxs_auart_stop_rx,\n\t.enable_ms      = mxs_auart_enable_ms,\n\t.break_ctl      = mxs_auart_break_ctl,\n\t.set_mctrl\t= mxs_auart_set_mctrl,\n\t.get_mctrl      = mxs_auart_get_mctrl,\n\t.startup\t= mxs_auart_startup,\n\t.shutdown       = mxs_auart_shutdown,\n\t.set_termios    = mxs_auart_settermios,\n\t.set_ldisc      = mxs_auart_set_ldisc,\n\t.type\t   \t= mxs_auart_type,\n\t.release_port   = mxs_auart_release_port,\n\t.request_port   = mxs_auart_request_port,\n\t.config_port    = mxs_auart_config_port,\n\t.verify_port    = mxs_auart_verify_port,\n};\n\nstatic struct mxs_auart_port *auart_port[MXS_AUART_PORTS];\n\n#ifdef CONFIG_SERIAL_MXS_AUART_CONSOLE\nstatic void mxs_auart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct mxs_auart_port *s = to_auart_port(port);\n\tunsigned int to = 1000;\n\n\twhile (mxs_read(s, REG_STAT) & AUART_STAT_TXFF) {\n\t\tif (!to--)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tmxs_write(ch, s, REG_DATA);\n}\n\nstatic void\nauart_console_write(struct console *co, const char *str, unsigned int count)\n{\n\tstruct mxs_auart_port *s;\n\tstruct uart_port *port;\n\tunsigned int old_ctrl0, old_ctrl2;\n\tunsigned int to = 20000;\n\n\tif (co->index >= MXS_AUART_PORTS || co->index < 0)\n\t\treturn;\n\n\ts = auart_port[co->index];\n\tport = &s->port;\n\n\tclk_enable(s->clk);\n\n\t \n\told_ctrl2 = mxs_read(s, REG_CTRL2);\n\told_ctrl0 = mxs_read(s, REG_CTRL0);\n\n\tmxs_clr(AUART_CTRL0_CLKGATE, s, REG_CTRL0);\n\tmxs_set(AUART_CTRL2_UARTEN | AUART_CTRL2_TXE, s, REG_CTRL2);\n\n\tuart_console_write(port, str, count, mxs_auart_console_putchar);\n\n\t \n\twhile (mxs_read(s, REG_STAT) & AUART_STAT_BUSY) {\n\t\tudelay(1);\n\t\tif (!to--)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!(mxs_read(s, REG_STAT) & AUART_STAT_BUSY)) {\n\t\tmxs_write(old_ctrl0, s, REG_CTRL0);\n\t\tmxs_write(old_ctrl2, s, REG_CTRL2);\n\t}\n\n\tclk_disable(s->clk);\n}\n\nstatic void __init\nauart_console_get_options(struct mxs_auart_port *s, int *baud,\n\t\t\t  int *parity, int *bits)\n{\n\tstruct uart_port *port = &s->port;\n\tunsigned int lcr_h, quot;\n\n\tif (!(mxs_read(s, REG_CTRL2) & AUART_CTRL2_UARTEN))\n\t\treturn;\n\n\tlcr_h = mxs_read(s, REG_LINECTRL);\n\n\t*parity = 'n';\n\tif (lcr_h & AUART_LINECTRL_PEN) {\n\t\tif (lcr_h & AUART_LINECTRL_EPS)\n\t\t\t*parity = 'e';\n\t\telse\n\t\t\t*parity = 'o';\n\t}\n\n\tif ((lcr_h & AUART_LINECTRL_WLEN_MASK) == AUART_LINECTRL_WLEN(7))\n\t\t*bits = 7;\n\telse\n\t\t*bits = 8;\n\n\tquot = ((mxs_read(s, REG_LINECTRL) & AUART_LINECTRL_BAUD_DIVINT_MASK))\n\t\t>> (AUART_LINECTRL_BAUD_DIVINT_SHIFT - 6);\n\tquot |= ((mxs_read(s, REG_LINECTRL) & AUART_LINECTRL_BAUD_DIVFRAC_MASK))\n\t\t>> AUART_LINECTRL_BAUD_DIVFRAC_SHIFT;\n\tif (quot == 0)\n\t\tquot = 1;\n\n\t*baud = (port->uartclk << 2) / quot;\n}\n\nstatic int __init\nauart_console_setup(struct console *co, char *options)\n{\n\tstruct mxs_auart_port *s;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret;\n\n\t \n\tif (co->index == -1 || co->index >= ARRAY_SIZE(auart_port))\n\t\tco->index = 0;\n\ts = auart_port[co->index];\n\tif (!s)\n\t\treturn -ENODEV;\n\n\tret = clk_prepare_enable(s->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse\n\t\tauart_console_get_options(s, &baud, &parity, &bits);\n\n\tret = uart_set_options(&s->port, co, baud, parity, bits, flow);\n\n\tclk_disable_unprepare(s->clk);\n\n\treturn ret;\n}\n\nstatic struct console auart_console = {\n\t.name\t\t= \"ttyAPP\",\n\t.write\t\t= auart_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= auart_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &auart_driver,\n};\n#endif\n\nstatic struct uart_driver auart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"ttyAPP\",\n\t.dev_name\t= \"ttyAPP\",\n\t.major\t\t= 0,\n\t.minor\t\t= 0,\n\t.nr\t\t= MXS_AUART_PORTS,\n#ifdef CONFIG_SERIAL_MXS_AUART_CONSOLE\n\t.cons =\t\t&auart_console,\n#endif\n};\n\nstatic void mxs_init_regs(struct mxs_auart_port *s)\n{\n\tif (is_asm9260_auart(s))\n\t\ts->vendor = &vendor_alphascale_asm9260;\n\telse\n\t\ts->vendor = &vendor_freescale_stmp37xx;\n}\n\nstatic int mxs_get_clks(struct mxs_auart_port *s,\n\t\t\tstruct platform_device *pdev)\n{\n\tint err;\n\n\tif (!is_asm9260_auart(s)) {\n\t\ts->clk = devm_clk_get(&pdev->dev, NULL);\n\t\treturn PTR_ERR_OR_ZERO(s->clk);\n\t}\n\n\ts->clk = devm_clk_get(s->dev, \"mod\");\n\tif (IS_ERR(s->clk)) {\n\t\tdev_err(s->dev, \"Failed to get \\\"mod\\\" clk\\n\");\n\t\treturn PTR_ERR(s->clk);\n\t}\n\n\ts->clk_ahb = devm_clk_get(s->dev, \"ahb\");\n\tif (IS_ERR(s->clk_ahb)) {\n\t\tdev_err(s->dev, \"Failed to get \\\"ahb\\\" clk\\n\");\n\t\treturn PTR_ERR(s->clk_ahb);\n\t}\n\n\terr = clk_prepare_enable(s->clk_ahb);\n\tif (err) {\n\t\tdev_err(s->dev, \"Failed to enable ahb_clk!\\n\");\n\t\treturn err;\n\t}\n\n\terr = clk_set_rate(s->clk, clk_get_rate(s->clk_ahb));\n\tif (err) {\n\t\tdev_err(s->dev, \"Failed to set rate!\\n\");\n\t\tgoto disable_clk_ahb;\n\t}\n\n\terr = clk_prepare_enable(s->clk);\n\tif (err) {\n\t\tdev_err(s->dev, \"Failed to enable clk!\\n\");\n\t\tgoto disable_clk_ahb;\n\t}\n\n\treturn 0;\n\ndisable_clk_ahb:\n\tclk_disable_unprepare(s->clk_ahb);\n\treturn err;\n}\n\nstatic int mxs_auart_init_gpios(struct mxs_auart_port *s, struct device *dev)\n{\n\tenum mctrl_gpio_idx i;\n\tstruct gpio_desc *gpiod;\n\n\ts->gpios = mctrl_gpio_init_noauto(dev, 0);\n\tif (IS_ERR(s->gpios))\n\t\treturn PTR_ERR(s->gpios);\n\n\t \n\tif (!RTS_AT_AUART() || !CTS_AT_AUART()) {\n\t\tif (test_bit(MXS_AUART_RTSCTS, &s->flags))\n\t\t\tdev_warn(dev,\n\t\t\t\t \"DMA and flow control via gpio may cause some problems. DMA disabled!\\n\");\n\t\tclear_bit(MXS_AUART_RTSCTS, &s->flags);\n\t}\n\n\tfor (i = 0; i < UART_GPIO_MAX; i++) {\n\t\tgpiod = mctrl_gpio_to_gpiod(s->gpios, i);\n\t\tif (gpiod && (gpiod_get_direction(gpiod) == 1))\n\t\t\ts->gpio_irq[i] = gpiod_to_irq(gpiod);\n\t\telse\n\t\t\ts->gpio_irq[i] = -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void mxs_auart_free_gpio_irq(struct mxs_auart_port *s)\n{\n\tenum mctrl_gpio_idx i;\n\n\tfor (i = 0; i < UART_GPIO_MAX; i++)\n\t\tif (s->gpio_irq[i] >= 0)\n\t\t\tfree_irq(s->gpio_irq[i], s);\n}\n\nstatic int mxs_auart_request_gpio_irq(struct mxs_auart_port *s)\n{\n\tint *irq = s->gpio_irq;\n\tenum mctrl_gpio_idx i;\n\tint err = 0;\n\n\tfor (i = 0; (i < UART_GPIO_MAX) && !err; i++) {\n\t\tif (irq[i] < 0)\n\t\t\tcontinue;\n\n\t\tirq_set_status_flags(irq[i], IRQ_NOAUTOEN);\n\t\terr = request_irq(irq[i], mxs_auart_irq_handle,\n\t\t\t\tIRQ_TYPE_EDGE_BOTH, dev_name(s->dev), s);\n\t\tif (err)\n\t\t\tdev_err(s->dev, \"%s - Can't get %d irq\\n\",\n\t\t\t\t__func__, irq[i]);\n\t}\n\n\t \n\twhile (err && (i-- > 0))\n\t\tif (irq[i] >= 0)\n\t\t\tfree_irq(irq[i], s);\n\n\treturn err;\n}\n\nstatic int mxs_auart_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mxs_auart_port *s;\n\tu32 version;\n\tint ret, irq;\n\tstruct resource *r;\n\n\ts = devm_kzalloc(&pdev->dev, sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ts->port.dev = &pdev->dev;\n\ts->dev = &pdev->dev;\n\n\tret = of_alias_get_id(np, \"serial\");\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias id: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\ts->port.line = ret;\n\n\tif (of_property_read_bool(np, \"uart-has-rtscts\") ||\n\t    of_property_read_bool(np, \"fsl,uart-has-rtscts\")  )\n\t\tset_bit(MXS_AUART_RTSCTS, &s->flags);\n\n\tif (s->port.line >= ARRAY_SIZE(auart_port)) {\n\t\tdev_err(&pdev->dev, \"serial%d out of range\\n\", s->port.line);\n\t\treturn -EINVAL;\n\t}\n\n\ts->devtype = (enum mxs_auart_type)of_device_get_match_data(&pdev->dev);\n\n\tret = mxs_get_clks(s, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tret = -ENXIO;\n\t\tgoto out_disable_clks;\n\t}\n\n\ts->port.mapbase = r->start;\n\ts->port.membase = ioremap(r->start, resource_size(r));\n\tif (!s->port.membase) {\n\t\tret = -ENOMEM;\n\t\tgoto out_disable_clks;\n\t}\n\ts->port.ops = &mxs_auart_ops;\n\ts->port.iotype = UPIO_MEM;\n\ts->port.fifosize = MXS_AUART_FIFO_SIZE;\n\ts->port.uartclk = clk_get_rate(s->clk);\n\ts->port.type = PORT_IMX;\n\ts->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_MXS_AUART_CONSOLE);\n\n\tmxs_init_regs(s);\n\n\ts->mctrl_prev = 0;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_iounmap;\n\t}\n\n\ts->port.irq = irq;\n\tret = devm_request_irq(&pdev->dev, irq, mxs_auart_irq_handle, 0,\n\t\t\t       dev_name(&pdev->dev), s);\n\tif (ret)\n\t\tgoto out_iounmap;\n\n\tplatform_set_drvdata(pdev, s);\n\n\tret = mxs_auart_init_gpios(s, &pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize GPIOs.\\n\");\n\t\tgoto out_iounmap;\n\t}\n\n\t \n\tret = mxs_auart_request_gpio_irq(s);\n\tif (ret)\n\t\tgoto out_iounmap;\n\n\tauart_port[s->port.line] = s;\n\n\tmxs_auart_reset_deassert(s);\n\n\tret = uart_add_one_port(&auart_driver, &s->port);\n\tif (ret)\n\t\tgoto out_free_qpio_irq;\n\n\t \n\tif (is_asm9260_auart(s)) {\n\t\tdev_info(&pdev->dev, \"Found APPUART ASM9260\\n\");\n\t} else {\n\t\tversion = mxs_read(s, REG_VERSION);\n\t\tdev_info(&pdev->dev, \"Found APPUART %d.%d.%d\\n\",\n\t\t\t (version >> 24) & 0xff,\n\t\t\t (version >> 16) & 0xff, version & 0xffff);\n\t}\n\n\treturn 0;\n\nout_free_qpio_irq:\n\tmxs_auart_free_gpio_irq(s);\n\tauart_port[pdev->id] = NULL;\n\nout_iounmap:\n\tiounmap(s->port.membase);\n\nout_disable_clks:\n\tif (is_asm9260_auart(s)) {\n\t\tclk_disable_unprepare(s->clk);\n\t\tclk_disable_unprepare(s->clk_ahb);\n\t}\n\treturn ret;\n}\n\nstatic int mxs_auart_remove(struct platform_device *pdev)\n{\n\tstruct mxs_auart_port *s = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&auart_driver, &s->port);\n\tauart_port[pdev->id] = NULL;\n\tmxs_auart_free_gpio_irq(s);\n\tiounmap(s->port.membase);\n\tif (is_asm9260_auart(s)) {\n\t\tclk_disable_unprepare(s->clk);\n\t\tclk_disable_unprepare(s->clk_ahb);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver mxs_auart_driver = {\n\t.probe = mxs_auart_probe,\n\t.remove = mxs_auart_remove,\n\t.driver = {\n\t\t.name = \"mxs-auart\",\n\t\t.of_match_table = mxs_auart_dt_ids,\n\t},\n};\n\nstatic int __init mxs_auart_init(void)\n{\n\tint r;\n\n\tr = uart_register_driver(&auart_driver);\n\tif (r)\n\t\tgoto out;\n\n\tr = platform_driver_register(&mxs_auart_driver);\n\tif (r)\n\t\tgoto out_err;\n\n\treturn 0;\nout_err:\n\tuart_unregister_driver(&auart_driver);\nout:\n\treturn r;\n}\n\nstatic void __exit mxs_auart_exit(void)\n{\n\tplatform_driver_unregister(&mxs_auart_driver);\n\tuart_unregister_driver(&auart_driver);\n}\n\nmodule_init(mxs_auart_init);\nmodule_exit(mxs_auart_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Freescale MXS application uart driver\");\nMODULE_ALIAS(\"platform:mxs-auart\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}