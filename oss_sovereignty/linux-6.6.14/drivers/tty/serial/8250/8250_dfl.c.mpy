{
  "module_name": "8250_dfl.c",
  "hash_id": "42db8b7f98320c975ab7098ce4a042fc70558a3748045121b5a29f870c828929",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_dfl.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/dfl.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/types.h>\n\n#include <linux/serial.h>\n#include <linux/serial_8250.h>\n\n#define DFHv1_PARAM_ID_CLK_FRQ    0x2\n#define DFHv1_PARAM_ID_FIFO_LEN   0x3\n\n#define DFHv1_PARAM_ID_REG_LAYOUT\t0x4\n#define DFHv1_PARAM_REG_LAYOUT_WIDTH\tGENMASK_ULL(63, 32)\n#define DFHv1_PARAM_REG_LAYOUT_SHIFT\tGENMASK_ULL(31, 0)\n\nstruct dfl_uart {\n\tint line;\n};\n\nstatic int dfh_get_u64_param_val(struct dfl_device *dfl_dev, int param_id, u64 *pval)\n{\n\tsize_t psize;\n\tu64 *p;\n\n\tp = dfh_find_param(dfl_dev, param_id, &psize);\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tif (psize != sizeof(*pval))\n\t\treturn -EINVAL;\n\n\t*pval = *p;\n\n\treturn 0;\n}\n\nstatic int dfl_uart_get_params(struct dfl_device *dfl_dev, struct uart_8250_port *uart)\n{\n\tstruct device *dev = &dfl_dev->dev;\n\tu64 fifo_len, clk_freq, reg_layout;\n\tu32 reg_width;\n\tint ret;\n\n\tret = dfh_get_u64_param_val(dfl_dev, DFHv1_PARAM_ID_CLK_FRQ, &clk_freq);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"missing CLK_FRQ param\\n\");\n\n\tuart->port.uartclk = clk_freq;\n\n\tret = dfh_get_u64_param_val(dfl_dev, DFHv1_PARAM_ID_FIFO_LEN, &fifo_len);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"missing FIFO_LEN param\\n\");\n\n\tswitch (fifo_len) {\n\tcase 32:\n\t\tuart->port.type = PORT_ALTR_16550_F32;\n\t\tbreak;\n\n\tcase 64:\n\t\tuart->port.type = PORT_ALTR_16550_F64;\n\t\tbreak;\n\n\tcase 128:\n\t\tuart->port.type = PORT_ALTR_16550_F128;\n\t\tbreak;\n\n\tdefault:\n\t\treturn dev_err_probe(dev, -EINVAL, \"unsupported FIFO_LEN %llu\\n\", fifo_len);\n\t}\n\n\tret = dfh_get_u64_param_val(dfl_dev, DFHv1_PARAM_ID_REG_LAYOUT, &reg_layout);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"missing REG_LAYOUT param\\n\");\n\n\tuart->port.regshift = FIELD_GET(DFHv1_PARAM_REG_LAYOUT_SHIFT, reg_layout);\n\treg_width = FIELD_GET(DFHv1_PARAM_REG_LAYOUT_WIDTH, reg_layout);\n\tswitch (reg_width) {\n\tcase 4:\n\t\tuart->port.iotype = UPIO_MEM32;\n\t\tbreak;\n\n\tcase 2:\n\t\tuart->port.iotype = UPIO_MEM16;\n\t\tbreak;\n\n\tdefault:\n\t\treturn dev_err_probe(dev, -EINVAL, \"unsupported reg-width %u\\n\", reg_width);\n\n\t}\n\n\treturn 0;\n}\n\nstatic int dfl_uart_probe(struct dfl_device *dfl_dev)\n{\n\tstruct device *dev = &dfl_dev->dev;\n\tstruct uart_8250_port uart = { };\n\tstruct dfl_uart *dfluart;\n\tint ret;\n\n\tuart.port.flags = UPF_IOREMAP;\n\tuart.port.mapbase = dfl_dev->mmio_res.start;\n\tuart.port.mapsize = resource_size(&dfl_dev->mmio_res);\n\n\tret = dfl_uart_get_params(dfl_dev, &uart);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"failed uart feature walk\\n\");\n\n\tif (dfl_dev->num_irqs == 1)\n\t\tuart.port.irq = dfl_dev->irqs[0];\n\n\tdfluart = devm_kzalloc(dev, sizeof(*dfluart), GFP_KERNEL);\n\tif (!dfluart)\n\t\treturn -ENOMEM;\n\n\tdfluart->line = serial8250_register_8250_port(&uart);\n\tif (dfluart->line < 0)\n\t\treturn dev_err_probe(dev, dfluart->line, \"unable to register 8250 port.\\n\");\n\n\tdev_set_drvdata(dev, dfluart);\n\n\treturn 0;\n}\n\nstatic void dfl_uart_remove(struct dfl_device *dfl_dev)\n{\n\tstruct dfl_uart *dfluart = dev_get_drvdata(&dfl_dev->dev);\n\n\tserial8250_unregister_port(dfluart->line);\n}\n\n#define FME_FEATURE_ID_UART 0x24\n\nstatic const struct dfl_device_id dfl_uart_ids[] = {\n\t{ FME_ID, FME_FEATURE_ID_UART },\n\t{ }\n};\nMODULE_DEVICE_TABLE(dfl, dfl_uart_ids);\n\nstatic struct dfl_driver dfl_uart_driver = {\n\t.drv = {\n\t\t.name = \"dfl-uart\",\n\t},\n\t.id_table = dfl_uart_ids,\n\t.probe = dfl_uart_probe,\n\t.remove = dfl_uart_remove,\n};\nmodule_dfl_driver(dfl_uart_driver);\n\nMODULE_DESCRIPTION(\"DFL Intel UART driver\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}