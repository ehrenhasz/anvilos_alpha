{
  "module_name": "8250_pxa.c",
  "hash_id": "c512027965d560226976c44e62df5193f47d7266684fd6d8b8fcf280ca172827",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_pxa.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/serial_8250.h>\n#include <linux/serial_core.h>\n#include <linux/serial_reg.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n\n#include \"8250.h\"\n\nstruct pxa8250_data {\n\tint\t\t\tline;\n\tstruct clk\t\t*clk;\n};\n\nstatic int __maybe_unused serial_pxa_suspend(struct device *dev)\n{\n\tstruct pxa8250_data *data = dev_get_drvdata(dev);\n\n\tserial8250_suspend_port(data->line);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused serial_pxa_resume(struct device *dev)\n{\n\tstruct pxa8250_data *data = dev_get_drvdata(dev);\n\n\tserial8250_resume_port(data->line);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops serial_pxa_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(serial_pxa_suspend, serial_pxa_resume)\n};\n\nstatic const struct of_device_id serial_pxa_dt_ids[] = {\n\t{ .compatible = \"mrvl,pxa-uart\", },\n\t{ .compatible = \"mrvl,mmp-uart\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, serial_pxa_dt_ids);\n\n \nstatic void serial_pxa_dl_write(struct uart_8250_port *up, u32 value)\n{\n\tunsigned int dll;\n\n\tserial_out(up, UART_DLL, value & 0xff);\n\t \n\tdll = serial_in(up, UART_DLL);\n\tWARN_ON(dll != (value & 0xff));\n\n\tserial_out(up, UART_DLM, value >> 8 & 0xff);\n}\n\n\nstatic void serial_pxa_pm(struct uart_port *port, unsigned int state,\n\t      unsigned int oldstate)\n{\n\tstruct pxa8250_data *data = port->private_data;\n\n\tif (!state)\n\t\tclk_prepare_enable(data->clk);\n\telse\n\t\tclk_disable_unprepare(data->clk);\n}\n\nstatic int serial_pxa_probe(struct platform_device *pdev)\n{\n\tstruct uart_8250_port uart = {};\n\tstruct pxa8250_data *data;\n\tstruct resource *mmres;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tmmres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!mmres)\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(data->clk))\n\t\treturn PTR_ERR(data->clk);\n\n\tret = clk_prepare(data->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\tif (ret >= 0)\n\t\tuart.port.line = ret;\n\n\tuart.port.type = PORT_XSCALE;\n\tuart.port.iotype = UPIO_MEM32;\n\tuart.port.mapbase = mmres->start;\n\tuart.port.regshift = 2;\n\tuart.port.irq = irq;\n\tuart.port.fifosize = 64;\n\tuart.port.flags = UPF_IOREMAP | UPF_SKIP_TEST | UPF_FIXED_TYPE;\n\tuart.port.dev = &pdev->dev;\n\tuart.port.uartclk = clk_get_rate(data->clk);\n\tuart.port.pm = serial_pxa_pm;\n\tuart.port.private_data = data;\n\tuart.dl_write = serial_pxa_dl_write;\n\n\tret = serial8250_register_8250_port(&uart);\n\tif (ret < 0)\n\t\tgoto err_clk;\n\n\tdata->line = ret;\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n\n err_clk:\n\tclk_unprepare(data->clk);\n\treturn ret;\n}\n\nstatic int serial_pxa_remove(struct platform_device *pdev)\n{\n\tstruct pxa8250_data *data = platform_get_drvdata(pdev);\n\n\tserial8250_unregister_port(data->line);\n\n\tclk_unprepare(data->clk);\n\n\treturn 0;\n}\n\nstatic struct platform_driver serial_pxa_driver = {\n\t.probe          = serial_pxa_probe,\n\t.remove         = serial_pxa_remove,\n\n\t.driver\t\t= {\n\t\t.name\t= \"pxa2xx-uart\",\n\t\t.pm\t= &serial_pxa_pm_ops,\n\t\t.of_match_table = serial_pxa_dt_ids,\n\t},\n};\n\nmodule_platform_driver(serial_pxa_driver);\n\n#ifdef CONFIG_SERIAL_8250_CONSOLE\nstatic int __init early_serial_pxa_setup(struct earlycon_device *device,\n\t\t\t\t  const char *options)\n{\n\tstruct uart_port *port = &device->port;\n\n\tif (!(device->port.membase || device->port.iobase))\n\t\treturn -ENODEV;\n\n\tport->regshift = 2;\n\treturn early_serial8250_setup(device, NULL);\n}\nOF_EARLYCON_DECLARE(early_pxa, \"mrvl,pxa-uart\", early_serial_pxa_setup);\nOF_EARLYCON_DECLARE(mmp, \"mrvl,mmp-uart\", early_serial_pxa_setup);\n#endif\n\nMODULE_AUTHOR(\"Sergei Ianovich\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pxa2xx-uart\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}