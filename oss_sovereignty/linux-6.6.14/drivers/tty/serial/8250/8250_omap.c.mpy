{
  "module_name": "8250_omap.c",
  "hash_id": "2fcc224e7afcdfc3760e2643dba964829c211ea728454767222095c803a57ce0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_omap.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/serial_8250.h>\n#include <linux/serial_reg.h>\n#include <linux/tty_flip.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_irq.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/console.h>\n#include <linux/pm_qos.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/dma-mapping.h>\n#include <linux/sys_soc.h>\n\n#include \"8250.h\"\n\n#define DEFAULT_CLK_SPEED\t48000000\n#define OMAP_UART_REGSHIFT\t2\n\n#define UART_ERRATA_i202_MDR1_ACCESS\t(1 << 0)\n#define OMAP_UART_WER_HAS_TX_WAKEUP\t(1 << 1)\n#define OMAP_DMA_TX_KICK\t\t(1 << 2)\n \n#define UART_ERRATA_CLOCK_DISABLE\t(1 << 3)\n#define\tUART_HAS_EFR2\t\t\tBIT(4)\n#define UART_HAS_RHR_IT_DIS\t\tBIT(5)\n#define UART_RX_TIMEOUT_QUIRK\t\tBIT(6)\n#define UART_HAS_NATIVE_RS485\t\tBIT(7)\n\n#define OMAP_UART_FCR_RX_TRIG\t\t6\n#define OMAP_UART_FCR_TX_TRIG\t\t4\n\n \n#define OMAP_UART_SCR_RX_TRIG_GRANU1_MASK\t(1 << 7)\n#define OMAP_UART_SCR_TX_TRIG_GRANU1_MASK\t(1 << 6)\n#define OMAP_UART_SCR_TX_EMPTY\t\t\t(1 << 3)\n#define OMAP_UART_SCR_DMAMODE_MASK\t\t(3 << 1)\n#define OMAP_UART_SCR_DMAMODE_1\t\t\t(1 << 1)\n#define OMAP_UART_SCR_DMAMODE_CTL\t\t(1 << 0)\n\n \n#define OMAP_UART_MVR_SCHEME_SHIFT\t30\n#define OMAP_UART_LEGACY_MVR_MAJ_MASK\t0xf0\n#define OMAP_UART_LEGACY_MVR_MAJ_SHIFT\t4\n#define OMAP_UART_LEGACY_MVR_MIN_MASK\t0x0f\n#define OMAP_UART_MVR_MAJ_MASK\t\t0x700\n#define OMAP_UART_MVR_MAJ_SHIFT\t\t8\n#define OMAP_UART_MVR_MIN_MASK\t\t0x3f\n\n \n#define OMAP_UART_SYSC_SOFTRESET\t(1 << 1)\n\n \n#define OMAP_UART_SYSS_RESETDONE\t(1 << 0)\n\n#define UART_TI752_TLR_TX\t0\n#define UART_TI752_TLR_RX\t4\n\n#define TRIGGER_TLR_MASK(x)\t((x & 0x3c) >> 2)\n#define TRIGGER_FCR_MASK(x)\t(x & 3)\n\n \n#define OMAP_UART_SW_TX\t\t0x08\n \n#define OMAP_UART_SW_RX\t\t0x02\n\n#define OMAP_UART_WER_MOD_WKUP\t0x7f\n#define OMAP_UART_TX_WAKEUP_EN\t(1 << 7)\n\n#define TX_TRIGGER\t1\n#define RX_TRIGGER\t48\n\n#define OMAP_UART_TCR_RESTORE(x)\t((x / 4) << 4)\n#define OMAP_UART_TCR_HALT(x)\t\t((x / 4) << 0)\n\n#define UART_BUILD_REVISION(x, y)\t(((x) << 8) | (y))\n\n#define OMAP_UART_REV_46 0x0406\n#define OMAP_UART_REV_52 0x0502\n#define OMAP_UART_REV_63 0x0603\n\n \n#define UART_OMAP_IER2\t\t\t0x1B\n#define UART_OMAP_IER2_RHR_IT_DIS\tBIT(2)\n\n \n#define UART_OMAP_MDR3\t\t\t0x20\n#define UART_OMAP_MDR3_DIR_POL\t\tBIT(3)\n#define UART_OMAP_MDR3_DIR_EN\t\tBIT(4)\n\n \n#define UART_OMAP_EFR2\t\t\t0x23\n#define UART_OMAP_EFR2_TIMEOUT_BEHAVE\tBIT(6)\n\n \n#define UART_OMAP_RX_LVL\t\t0x19\n\nstruct omap8250_priv {\n\tvoid __iomem *membase;\n\tint line;\n\tu8 habit;\n\tu8 mdr1;\n\tu8 mdr3;\n\tu8 efr;\n\tu8 scr;\n\tu8 wer;\n\tu8 xon;\n\tu8 xoff;\n\tu8 delayed_restore;\n\tu16 quot;\n\n\tu8 tx_trigger;\n\tu8 rx_trigger;\n\tbool is_suspending;\n\tint wakeirq;\n\tint wakeups_enabled;\n\tu32 latency;\n\tu32 calc_latency;\n\tstruct pm_qos_request pm_qos_request;\n\tstruct work_struct qos_work;\n\tstruct uart_8250_dma omap8250_dma;\n\tspinlock_t rx_dma_lock;\n\tbool rx_dma_broken;\n\tbool throttled;\n};\n\nstruct omap8250_dma_params {\n\tu32 rx_size;\n\tu8 rx_trigger;\n\tu8 tx_trigger;\n};\n\nstruct omap8250_platdata {\n\tstruct omap8250_dma_params *dma_params;\n\tu8 habit;\n};\n\n#ifdef CONFIG_SERIAL_8250_DMA\nstatic void omap_8250_rx_dma_flush(struct uart_8250_port *p);\n#else\nstatic inline void omap_8250_rx_dma_flush(struct uart_8250_port *p) { }\n#endif\n\nstatic u32 uart_read(struct omap8250_priv *priv, u32 reg)\n{\n\treturn readl(priv->membase + (reg << OMAP_UART_REGSHIFT));\n}\n\n \nstatic void __omap8250_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct omap8250_priv *priv = up->port.private_data;\n\tu8 lcr;\n\n\tserial8250_do_set_mctrl(port, mctrl);\n\n\tif (!mctrl_gpio_to_gpiod(up->gpios, UART_GPIO_RTS)) {\n\t\t \n\t\tlcr = serial_in(up, UART_LCR);\n\t\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\t\tif ((mctrl & TIOCM_RTS) && (port->status & UPSTAT_AUTORTS))\n\t\t\tpriv->efr |= UART_EFR_RTS;\n\t\telse\n\t\t\tpriv->efr &= ~UART_EFR_RTS;\n\t\tserial_out(up, UART_EFR, priv->efr);\n\t\tserial_out(up, UART_LCR, lcr);\n\t}\n}\n\nstatic void omap8250_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tint err;\n\n\terr = pm_runtime_resume_and_get(port->dev);\n\tif (err)\n\t\treturn;\n\n\t__omap8250_set_mctrl(port, mctrl);\n\n\tpm_runtime_mark_last_busy(port->dev);\n\tpm_runtime_put_autosuspend(port->dev);\n}\n\n \nstatic void omap_8250_mdr1_errataset(struct uart_8250_port *up,\n\t\t\t\t     struct omap8250_priv *priv)\n{\n\tserial_out(up, UART_OMAP_MDR1, priv->mdr1);\n\tudelay(2);\n\tserial_out(up, UART_FCR, up->fcr | UART_FCR_CLEAR_XMIT |\n\t\t\tUART_FCR_CLEAR_RCVR);\n}\n\nstatic void omap_8250_get_divisor(struct uart_port *port, unsigned int baud,\n\t\t\t\t  struct omap8250_priv *priv)\n{\n\tunsigned int uartclk = port->uartclk;\n\tunsigned int div_13, div_16;\n\tunsigned int abs_d13, abs_d16;\n\n\t \n\tif (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST) {\n\t\tpriv->quot = port->custom_divisor & UART_DIV_MAX;\n\t\t \n\t\tif (port->custom_divisor & (1 << 16))\n\t\t\tpriv->mdr1 = UART_OMAP_MDR1_13X_MODE;\n\t\telse\n\t\t\tpriv->mdr1 = UART_OMAP_MDR1_16X_MODE;\n\t\treturn;\n\t}\n\tdiv_13 = DIV_ROUND_CLOSEST(uartclk, 13 * baud);\n\tdiv_16 = DIV_ROUND_CLOSEST(uartclk, 16 * baud);\n\n\tif (!div_13)\n\t\tdiv_13 = 1;\n\tif (!div_16)\n\t\tdiv_16 = 1;\n\n\tabs_d13 = abs(baud - uartclk / 13 / div_13);\n\tabs_d16 = abs(baud - uartclk / 16 / div_16);\n\n\tif (abs_d13 >= abs_d16) {\n\t\tpriv->mdr1 = UART_OMAP_MDR1_16X_MODE;\n\t\tpriv->quot = div_16;\n\t} else {\n\t\tpriv->mdr1 = UART_OMAP_MDR1_13X_MODE;\n\t\tpriv->quot = div_13;\n\t}\n}\n\nstatic void omap8250_update_scr(struct uart_8250_port *up,\n\t\t\t\tstruct omap8250_priv *priv)\n{\n\tu8 old_scr;\n\n\told_scr = serial_in(up, UART_OMAP_SCR);\n\tif (old_scr == priv->scr)\n\t\treturn;\n\n\t \n\tif (priv->scr & OMAP_UART_SCR_DMAMODE_MASK)\n\t\tserial_out(up, UART_OMAP_SCR,\n\t\t\t   priv->scr & ~OMAP_UART_SCR_DMAMODE_MASK);\n\tserial_out(up, UART_OMAP_SCR, priv->scr);\n}\n\nstatic void omap8250_update_mdr1(struct uart_8250_port *up,\n\t\t\t\t struct omap8250_priv *priv)\n{\n\tif (priv->habit & UART_ERRATA_i202_MDR1_ACCESS)\n\t\tomap_8250_mdr1_errataset(up, priv);\n\telse\n\t\tserial_out(up, UART_OMAP_MDR1, priv->mdr1);\n}\n\nstatic void omap8250_restore_regs(struct uart_8250_port *up)\n{\n\tstruct omap8250_priv *priv = up->port.private_data;\n\tstruct uart_8250_dma\t*dma = up->dma;\n\tu8 mcr = serial8250_in_MCR(up);\n\n\t \n\tlockdep_assert_held_once(&up->port.lock);\n\n\tif (dma && dma->tx_running) {\n\t\t \n\t\tpriv->delayed_restore = 1;\n\t\treturn;\n\t}\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_out(up, UART_EFR, UART_EFR_ECB);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\n\tserial8250_out_MCR(up, mcr | UART_MCR_TCRTLR);\n\tserial_out(up, UART_FCR, up->fcr);\n\n\tomap8250_update_scr(up, priv);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\n\tserial_out(up, UART_TI752_TCR, OMAP_UART_TCR_RESTORE(16) |\n\t\t\tOMAP_UART_TCR_HALT(52));\n\tserial_out(up, UART_TI752_TLR,\n\t\t   TRIGGER_TLR_MASK(priv->tx_trigger) << UART_TI752_TLR_TX |\n\t\t   TRIGGER_TLR_MASK(priv->rx_trigger) << UART_TI752_TLR_RX);\n\n\tserial_out(up, UART_LCR, 0);\n\n\t \n\tserial8250_out_MCR(up, mcr);\n\n\tserial_out(up, UART_IER, up->ier);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_dl_write(up, priv->quot);\n\n\tserial_out(up, UART_EFR, priv->efr);\n\n\t \n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_out(up, UART_XON1, priv->xon);\n\tserial_out(up, UART_XOFF1, priv->xoff);\n\n\tserial_out(up, UART_LCR, up->lcr);\n\n\tomap8250_update_mdr1(up, priv);\n\n\t__omap8250_set_mctrl(&up->port, up->port.mctrl);\n\n\tserial_out(up, UART_OMAP_MDR3, priv->mdr3);\n\n\tif (up->port.rs485.flags & SER_RS485_ENABLED &&\n\t    up->port.rs485_config == serial8250_em485_config)\n\t\tserial8250_em485_stop_tx(up);\n}\n\n \nstatic void omap_8250_set_termios(struct uart_port *port,\n\t\t\t\t  struct ktermios *termios,\n\t\t\t\t  const struct ktermios *old)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct omap8250_priv *priv = up->port.private_data;\n\tunsigned char cval = 0;\n\tunsigned int baud;\n\n\tcval = UART_LCR_WLEN(tty_get_char_size(termios->c_cflag));\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tcval |= UART_LCR_STOP;\n\tif (termios->c_cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(termios->c_cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\tif (termios->c_cflag & CMSPAR)\n\t\tcval |= UART_LCR_SPAR;\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old,\n\t\t\t\t  port->uartclk / 16 / UART_DIV_MAX,\n\t\t\t\t  port->uartclk / 13);\n\tomap_8250_get_divisor(port, baud, priv);\n\n\t \n\tpm_runtime_get_sync(port->dev);\n\tspin_lock_irq(&port->lock);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tup->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\n\tif (termios->c_iflag & INPCK)\n\t\tup->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (termios->c_iflag & (IGNBRK | PARMRK))\n\t\tup->port.read_status_mask |= UART_LSR_BI;\n\n\t \n\tup->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tup->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tup->port.ignore_status_mask |= UART_LSR_BI;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tup->port.ignore_status_mask |= UART_LSR_OE;\n\t}\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tup->port.ignore_status_mask |= UART_LSR_DR;\n\n\t \n\tup->ier &= ~UART_IER_MSI;\n\tif (UART_ENABLE_MS(&up->port, termios->c_cflag))\n\t\tup->ier |= UART_IER_MSI;\n\n\tup->lcr = cval;\n\t \n\n\t \n\tup->fcr = UART_FCR_ENABLE_FIFO;\n\tup->fcr |= TRIGGER_FCR_MASK(priv->tx_trigger) << OMAP_UART_FCR_TX_TRIG;\n\tup->fcr |= TRIGGER_FCR_MASK(priv->rx_trigger) << OMAP_UART_FCR_RX_TRIG;\n\n\tpriv->scr = OMAP_UART_SCR_RX_TRIG_GRANU1_MASK | OMAP_UART_SCR_TX_EMPTY |\n\t\tOMAP_UART_SCR_TX_TRIG_GRANU1_MASK;\n\n\tif (up->dma)\n\t\tpriv->scr |= OMAP_UART_SCR_DMAMODE_1 |\n\t\t\tOMAP_UART_SCR_DMAMODE_CTL;\n\n\tpriv->xon = termios->c_cc[VSTART];\n\tpriv->xoff = termios->c_cc[VSTOP];\n\n\tpriv->efr = 0;\n\tup->port.status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS | UPSTAT_AUTOXOFF);\n\n\tif (termios->c_cflag & CRTSCTS && up->port.flags & UPF_HARD_FLOW &&\n\t    !mctrl_gpio_to_gpiod(up->gpios, UART_GPIO_RTS) &&\n\t    !mctrl_gpio_to_gpiod(up->gpios, UART_GPIO_CTS)) {\n\t\t \n\t\tup->port.status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;\n\t\tpriv->efr |= UART_EFR_CTS;\n\t} else\tif (up->port.flags & UPF_SOFT_FLOW) {\n\t\t \n\n\t\t \n\t\tif (termios->c_iflag & IXOFF) {\n\t\t\tup->port.status |= UPSTAT_AUTOXOFF;\n\t\t\tpriv->efr |= OMAP_UART_SW_TX;\n\t\t}\n\t}\n\tomap8250_restore_regs(up);\n\n\tspin_unlock_irq(&up->port.lock);\n\tpm_runtime_mark_last_busy(port->dev);\n\tpm_runtime_put_autosuspend(port->dev);\n\n\t \n\tpriv->calc_latency = USEC_PER_SEC * 64 * 8 / baud;\n\tpriv->latency = priv->calc_latency;\n\n\tschedule_work(&priv->qos_work);\n\n\t \n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n}\n\n \nstatic void omap_8250_pm(struct uart_port *port, unsigned int state,\n\t\t\t unsigned int oldstate)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tu8 efr;\n\n\tpm_runtime_get_sync(port->dev);\n\n\t \n\tspin_lock_irq(&port->lock);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tefr = serial_in(up, UART_EFR);\n\tserial_out(up, UART_EFR, efr | UART_EFR_ECB);\n\tserial_out(up, UART_LCR, 0);\n\n\tserial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_out(up, UART_EFR, efr);\n\tserial_out(up, UART_LCR, 0);\n\n\tspin_unlock_irq(&port->lock);\n\n\tpm_runtime_mark_last_busy(port->dev);\n\tpm_runtime_put_autosuspend(port->dev);\n}\n\nstatic void omap_serial_fill_features_erratas(struct uart_8250_port *up,\n\t\t\t\t\t      struct omap8250_priv *priv)\n{\n\tstatic const struct soc_device_attribute k3_soc_devices[] = {\n\t\t{ .family = \"AM65X\",  },\n\t\t{ .family = \"J721E\", .revision = \"SR1.0\" },\n\t\t{   }\n\t};\n\tu32 mvr, scheme;\n\tu16 revision, major, minor;\n\n\tmvr = uart_read(priv, UART_OMAP_MVER);\n\n\t \n\tscheme = mvr >> OMAP_UART_MVR_SCHEME_SHIFT;\n\n\tswitch (scheme) {\n\tcase 0:  \n\t\t \n\t\tmajor = (mvr & OMAP_UART_LEGACY_MVR_MAJ_MASK) >>\n\t\t\tOMAP_UART_LEGACY_MVR_MAJ_SHIFT;\n\t\tminor = (mvr & OMAP_UART_LEGACY_MVR_MIN_MASK);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\t \n\t\tmajor = (mvr & OMAP_UART_MVR_MAJ_MASK) >>\n\t\t\tOMAP_UART_MVR_MAJ_SHIFT;\n\t\tminor = (mvr & OMAP_UART_MVR_MIN_MASK);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(up->port.dev,\n\t\t\t \"Unknown revision, defaulting to highest\\n\");\n\t\t \n\t\tmajor = 0xff;\n\t\tminor = 0xff;\n\t}\n\t \n\trevision = UART_BUILD_REVISION(major, minor);\n\n\tswitch (revision) {\n\tcase OMAP_UART_REV_46:\n\t\tpriv->habit |= UART_ERRATA_i202_MDR1_ACCESS;\n\t\tbreak;\n\tcase OMAP_UART_REV_52:\n\t\tpriv->habit |= UART_ERRATA_i202_MDR1_ACCESS |\n\t\t\t\tOMAP_UART_WER_HAS_TX_WAKEUP;\n\t\tbreak;\n\tcase OMAP_UART_REV_63:\n\t\tpriv->habit |= UART_ERRATA_i202_MDR1_ACCESS |\n\t\t\tOMAP_UART_WER_HAS_TX_WAKEUP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (soc_device_match(k3_soc_devices))\n\t\tpriv->habit &= ~UART_HAS_RHR_IT_DIS;\n}\n\nstatic void omap8250_uart_qos_work(struct work_struct *work)\n{\n\tstruct omap8250_priv *priv;\n\n\tpriv = container_of(work, struct omap8250_priv, qos_work);\n\tcpu_latency_qos_update_request(&priv->pm_qos_request, priv->latency);\n}\n\n#ifdef CONFIG_SERIAL_8250_DMA\nstatic int omap_8250_dma_handle_irq(struct uart_port *port);\n#endif\n\nstatic irqreturn_t omap8250_irq(int irq, void *dev_id)\n{\n\tstruct omap8250_priv *priv = dev_id;\n\tstruct uart_8250_port *up = serial8250_get_port(priv->line);\n\tstruct uart_port *port = &up->port;\n\tunsigned int iir, lsr;\n\tint ret;\n\n#ifdef CONFIG_SERIAL_8250_DMA\n\tif (up->dma) {\n\t\tret = omap_8250_dma_handle_irq(port);\n\t\treturn IRQ_RETVAL(ret);\n\t}\n#endif\n\n\tserial8250_rpm_get(up);\n\tlsr = serial_port_in(port, UART_LSR);\n\tiir = serial_port_in(port, UART_IIR);\n\tret = serial8250_handle_irq(port, iir);\n\n\t \n\tif (priv->habit & UART_RX_TIMEOUT_QUIRK &&\n\t    (iir & UART_IIR_RX_TIMEOUT) == UART_IIR_RX_TIMEOUT &&\n\t    serial_port_in(port, UART_OMAP_RX_LVL) == 0) {\n\t\tserial_port_in(port, UART_RX);\n\t}\n\n\t \n\tif ((lsr & UART_LSR_OE) && up->overrun_backoff_time_ms > 0) {\n\t\tunsigned long delay;\n\n\t\t \n\t\tspin_lock(&port->lock);\n\t\tup->ier = port->serial_in(port, UART_IER);\n\t\tif (up->ier & (UART_IER_RLSI | UART_IER_RDI)) {\n\t\t\tport->ops->stop_rx(port);\n\t\t} else {\n\t\t\t \n\t\t\tcancel_delayed_work(&up->overrun_backoff);\n\t\t}\n\t\tspin_unlock(&port->lock);\n\n\t\tdelay = msecs_to_jiffies(up->overrun_backoff_time_ms);\n\t\tschedule_delayed_work(&up->overrun_backoff, delay);\n\t}\n\n\tserial8250_rpm_put(up);\n\n\treturn IRQ_RETVAL(ret);\n}\n\nstatic int omap_8250_startup(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct omap8250_priv *priv = port->private_data;\n\tstruct uart_8250_dma *dma = &priv->omap8250_dma;\n\tint ret;\n\n\tif (priv->wakeirq) {\n\t\tret = dev_pm_set_dedicated_wake_irq(port->dev, priv->wakeirq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpm_runtime_get_sync(port->dev);\n\n\tserial_out(up, UART_FCR, UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\n\tserial_out(up, UART_LCR, UART_LCR_WLEN8);\n\n\tup->lsr_saved_flags = 0;\n\tup->msr_saved_flags = 0;\n\n\t \n\tif (dma->fn && !uart_console(port)) {\n\t\tup->dma = &priv->omap8250_dma;\n\t\tret = serial8250_request_dma(up);\n\t\tif (ret) {\n\t\t\tdev_warn_ratelimited(port->dev,\n\t\t\t\t\t     \"failed to request DMA\\n\");\n\t\t\tup->dma = NULL;\n\t\t}\n\t} else {\n\t\tup->dma = NULL;\n\t}\n\n\t \n\tspin_lock_irq(&port->lock);\n\tup->ier = UART_IER_RLSI | UART_IER_RDI;\n\tserial_out(up, UART_IER, up->ier);\n\tspin_unlock_irq(&port->lock);\n\n#ifdef CONFIG_PM\n\tup->capabilities |= UART_CAP_RPM;\n#endif\n\n\t \n\tpriv->wer = OMAP_UART_WER_MOD_WKUP;\n\tif (priv->habit & OMAP_UART_WER_HAS_TX_WAKEUP)\n\t\tpriv->wer |= OMAP_UART_TX_WAKEUP_EN;\n\tserial_out(up, UART_OMAP_WER, priv->wer);\n\n\tif (up->dma && !(priv->habit & UART_HAS_EFR2)) {\n\t\tspin_lock_irq(&port->lock);\n\t\tup->dma->rx_dma(up);\n\t\tspin_unlock_irq(&port->lock);\n\t}\n\n\tenable_irq(up->port.irq);\n\n\tpm_runtime_mark_last_busy(port->dev);\n\tpm_runtime_put_autosuspend(port->dev);\n\treturn 0;\n}\n\nstatic void omap_8250_shutdown(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct omap8250_priv *priv = port->private_data;\n\n\tflush_work(&priv->qos_work);\n\tif (up->dma)\n\t\tomap_8250_rx_dma_flush(up);\n\n\tpm_runtime_get_sync(port->dev);\n\n\tserial_out(up, UART_OMAP_WER, 0);\n\tif (priv->habit & UART_HAS_EFR2)\n\t\tserial_out(up, UART_OMAP_EFR2, 0x0);\n\n\t \n\tspin_lock_irq(&port->lock);\n\tup->ier = 0;\n\tserial_out(up, UART_IER, 0);\n\tspin_unlock_irq(&port->lock);\n\tdisable_irq_nosync(up->port.irq);\n\tdev_pm_clear_wake_irq(port->dev);\n\n\tserial8250_release_dma(up);\n\tup->dma = NULL;\n\n\t \n\tif (up->lcr & UART_LCR_SBC)\n\t\tserial_out(up, UART_LCR, up->lcr & ~UART_LCR_SBC);\n\tserial_out(up, UART_FCR, UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\n\tpm_runtime_mark_last_busy(port->dev);\n\tpm_runtime_put_autosuspend(port->dev);\n}\n\nstatic void omap_8250_throttle(struct uart_port *port)\n{\n\tstruct omap8250_priv *priv = port->private_data;\n\tunsigned long flags;\n\n\tpm_runtime_get_sync(port->dev);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tport->ops->stop_rx(port);\n\tpriv->throttled = true;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tpm_runtime_mark_last_busy(port->dev);\n\tpm_runtime_put_autosuspend(port->dev);\n}\n\nstatic void omap_8250_unthrottle(struct uart_port *port)\n{\n\tstruct omap8250_priv *priv = port->private_data;\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned long flags;\n\n\tpm_runtime_get_sync(port->dev);\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tpriv->throttled = false;\n\tif (up->dma)\n\t\tup->dma->rx_dma(up);\n\tup->ier |= UART_IER_RLSI | UART_IER_RDI;\n\tport->read_status_mask |= UART_LSR_DR;\n\tserial_out(up, UART_IER, up->ier);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tpm_runtime_mark_last_busy(port->dev);\n\tpm_runtime_put_autosuspend(port->dev);\n}\n\nstatic int omap8250_rs485_config(struct uart_port *port,\n\t\t\t\t struct ktermios *termios,\n\t\t\t\t struct serial_rs485 *rs485)\n{\n\tstruct omap8250_priv *priv = port->private_data;\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tu32 fixed_delay_rts_before_send = 0;\n\tu32 fixed_delay_rts_after_send = 0;\n\tunsigned int baud;\n\n\t \n\tif (priv->quot) {\n\t\tif (priv->mdr1 == UART_OMAP_MDR1_16X_MODE)\n\t\t\tbaud = port->uartclk / (16 * priv->quot);\n\t\telse\n\t\t\tbaud = port->uartclk / (13 * priv->quot);\n\n\t\tfixed_delay_rts_after_send  = 3 * MSEC_PER_SEC / baud;\n\t\tfixed_delay_rts_before_send = 1 * MSEC_PER_SEC / baud;\n\t}\n\n\t \n\tif (!(priv->habit & UART_HAS_NATIVE_RS485) ||\n\t    mctrl_gpio_to_gpiod(up->gpios, UART_GPIO_RTS) ||\n\t    rs485->delay_rts_after_send  > fixed_delay_rts_after_send ||\n\t    rs485->delay_rts_before_send > fixed_delay_rts_before_send) {\n\t\tpriv->mdr3 &= ~UART_OMAP_MDR3_DIR_EN;\n\t\tserial_out(up, UART_OMAP_MDR3, priv->mdr3);\n\n\t\tport->rs485_config = serial8250_em485_config;\n\t\treturn serial8250_em485_config(port, termios, rs485);\n\t}\n\n\trs485->delay_rts_after_send  = fixed_delay_rts_after_send;\n\trs485->delay_rts_before_send = fixed_delay_rts_before_send;\n\n\tif (rs485->flags & SER_RS485_ENABLED)\n\t\tpriv->mdr3 |= UART_OMAP_MDR3_DIR_EN;\n\telse\n\t\tpriv->mdr3 &= ~UART_OMAP_MDR3_DIR_EN;\n\n\t \n\tif (rs485->flags & SER_RS485_RTS_ON_SEND)\n\t\tpriv->mdr3 &= ~UART_OMAP_MDR3_DIR_POL;\n\telse\n\t\tpriv->mdr3 |= UART_OMAP_MDR3_DIR_POL;\n\n\tserial_out(up, UART_OMAP_MDR3, priv->mdr3);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SERIAL_8250_DMA\nstatic int omap_8250_rx_dma(struct uart_8250_port *p);\n\n \nstatic void __dma_rx_do_complete(struct uart_8250_port *p)\n{\n\tstruct uart_8250_dma    *dma = p->dma;\n\tstruct tty_port         *tty_port = &p->port.state->port;\n\tstruct omap8250_priv\t*priv = p->port.private_data;\n\tstruct dma_chan\t\t*rxchan = dma->rxchan;\n\tdma_cookie_t\t\tcookie;\n\tstruct dma_tx_state     state;\n\tint                     count;\n\tint\t\t\tret;\n\tu32\t\t\treg;\n\n\tif (!dma->rx_running)\n\t\tgoto out;\n\n\tcookie = dma->rx_cookie;\n\tdma->rx_running = 0;\n\n\t \n\tif (priv->habit & UART_HAS_RHR_IT_DIS) {\n\t\treg = serial_in(p, UART_OMAP_IER2);\n\t\treg &= ~UART_OMAP_IER2_RHR_IT_DIS;\n\t\tserial_out(p, UART_OMAP_IER2, reg);\n\t}\n\n\tdmaengine_tx_status(rxchan, cookie, &state);\n\n\tcount = dma->rx_size - state.residue + state.in_flight_bytes;\n\tif (count < dma->rx_size) {\n\t\tdmaengine_terminate_async(rxchan);\n\n\t\t \n\t\tif (state.in_flight_bytes) {\n\t\t\tint poll_count = 25;\n\n\t\t\twhile (dmaengine_tx_status(rxchan, cookie, NULL) &&\n\t\t\t       poll_count--)\n\t\t\t\tcpu_relax();\n\n\t\t\tif (poll_count == -1)\n\t\t\t\tdev_err(p->port.dev, \"teardown incomplete\\n\");\n\t\t}\n\t}\n\tif (!count)\n\t\tgoto out;\n\tret = tty_insert_flip_string(tty_port, dma->rx_buf, count);\n\n\tp->port.icount.rx += ret;\n\tp->port.icount.buf_overrun += count - ret;\nout:\n\n\ttty_flip_buffer_push(tty_port);\n}\n\nstatic void __dma_rx_complete(void *param)\n{\n\tstruct uart_8250_port *p = param;\n\tstruct omap8250_priv *priv = p->port.private_data;\n\tstruct uart_8250_dma *dma = p->dma;\n\tstruct dma_tx_state     state;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&p->port.lock, flags);\n\n\t \n\tif (dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state) !=\n\t\t\tDMA_COMPLETE) {\n\t\tspin_unlock_irqrestore(&p->port.lock, flags);\n\t\treturn;\n\t}\n\t__dma_rx_do_complete(p);\n\tif (!priv->throttled) {\n\t\tp->ier |= UART_IER_RLSI | UART_IER_RDI;\n\t\tserial_out(p, UART_IER, p->ier);\n\t\tif (!(priv->habit & UART_HAS_EFR2))\n\t\t\tomap_8250_rx_dma(p);\n\t}\n\n\tspin_unlock_irqrestore(&p->port.lock, flags);\n}\n\nstatic void omap_8250_rx_dma_flush(struct uart_8250_port *p)\n{\n\tstruct omap8250_priv\t*priv = p->port.private_data;\n\tstruct uart_8250_dma\t*dma = p->dma;\n\tstruct dma_tx_state     state;\n\tunsigned long\t\tflags;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->rx_dma_lock, flags);\n\n\tif (!dma->rx_running) {\n\t\tspin_unlock_irqrestore(&priv->rx_dma_lock, flags);\n\t\treturn;\n\t}\n\n\tret = dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);\n\tif (ret == DMA_IN_PROGRESS) {\n\t\tret = dmaengine_pause(dma->rxchan);\n\t\tif (WARN_ON_ONCE(ret))\n\t\t\tpriv->rx_dma_broken = true;\n\t}\n\t__dma_rx_do_complete(p);\n\tspin_unlock_irqrestore(&priv->rx_dma_lock, flags);\n}\n\nstatic int omap_8250_rx_dma(struct uart_8250_port *p)\n{\n\tstruct omap8250_priv\t\t*priv = p->port.private_data;\n\tstruct uart_8250_dma            *dma = p->dma;\n\tint\t\t\t\terr = 0;\n\tstruct dma_async_tx_descriptor  *desc;\n\tunsigned long\t\t\tflags;\n\tu32\t\t\t\treg;\n\n\t \n\tlockdep_assert_held_once(&p->port.lock);\n\n\tif (priv->rx_dma_broken)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&priv->rx_dma_lock, flags);\n\n\tif (dma->rx_running) {\n\t\tenum dma_status state;\n\n\t\tstate = dmaengine_tx_status(dma->rxchan, dma->rx_cookie, NULL);\n\t\tif (state == DMA_COMPLETE) {\n\t\t\t \n\t\t\tp->ier &= ~(UART_IER_RLSI | UART_IER_RDI);\n\t\t\tserial_out(p, UART_IER, p->ier);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdesc = dmaengine_prep_slave_single(dma->rxchan, dma->rx_addr,\n\t\t\t\t\t   dma->rx_size, DMA_DEV_TO_MEM,\n\t\t\t\t\t   DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tdma->rx_running = 1;\n\tdesc->callback = __dma_rx_complete;\n\tdesc->callback_param = p;\n\n\tdma->rx_cookie = dmaengine_submit(desc);\n\n\t \n\tif (priv->habit & UART_HAS_RHR_IT_DIS) {\n\t\treg = serial_in(p, UART_OMAP_IER2);\n\t\treg |= UART_OMAP_IER2_RHR_IT_DIS;\n\t\tserial_out(p, UART_OMAP_IER2, reg);\n\t}\n\n\tdma_async_issue_pending(dma->rxchan);\nout:\n\tspin_unlock_irqrestore(&priv->rx_dma_lock, flags);\n\treturn err;\n}\n\nstatic int omap_8250_tx_dma(struct uart_8250_port *p);\n\nstatic void omap_8250_dma_tx_complete(void *param)\n{\n\tstruct uart_8250_port\t*p = param;\n\tstruct uart_8250_dma\t*dma = p->dma;\n\tstruct circ_buf\t\t*xmit = &p->port.state->xmit;\n\tunsigned long\t\tflags;\n\tbool\t\t\ten_thri = false;\n\tstruct omap8250_priv\t*priv = p->port.private_data;\n\n\tdma_sync_single_for_cpu(dma->txchan->device->dev, dma->tx_addr,\n\t\t\t\tUART_XMIT_SIZE, DMA_TO_DEVICE);\n\n\tspin_lock_irqsave(&p->port.lock, flags);\n\n\tdma->tx_running = 0;\n\n\tuart_xmit_advance(&p->port, dma->tx_size);\n\n\tif (priv->delayed_restore) {\n\t\tpriv->delayed_restore = 0;\n\t\tomap8250_restore_regs(p);\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&p->port);\n\n\tif (!uart_circ_empty(xmit) && !uart_tx_stopped(&p->port)) {\n\t\tint ret;\n\n\t\tret = omap_8250_tx_dma(p);\n\t\tif (ret)\n\t\t\ten_thri = true;\n\t} else if (p->capabilities & UART_CAP_RPM) {\n\t\ten_thri = true;\n\t}\n\n\tif (en_thri) {\n\t\tdma->tx_err = 1;\n\t\tserial8250_set_THRI(p);\n\t}\n\n\tspin_unlock_irqrestore(&p->port.lock, flags);\n}\n\nstatic int omap_8250_tx_dma(struct uart_8250_port *p)\n{\n\tstruct uart_8250_dma\t\t*dma = p->dma;\n\tstruct omap8250_priv\t\t*priv = p->port.private_data;\n\tstruct circ_buf\t\t\t*xmit = &p->port.state->xmit;\n\tstruct dma_async_tx_descriptor\t*desc;\n\tunsigned int\tskip_byte = 0;\n\tint ret;\n\n\tif (dma->tx_running)\n\t\treturn 0;\n\tif (uart_tx_stopped(&p->port) || uart_circ_empty(xmit)) {\n\n\t\t \n\t\tif (dma->tx_err || p->capabilities & UART_CAP_RPM) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\t\tserial8250_clear_THRI(p);\n\t\treturn 0;\n\t}\n\n\tdma->tx_size = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\tif (priv->habit & OMAP_DMA_TX_KICK) {\n\t\tu8 tx_lvl;\n\n\t\t \n\t\ttx_lvl = serial_in(p, UART_OMAP_TX_LVL);\n\t\tif (tx_lvl == p->tx_loadsz) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\t\tif (dma->tx_size < 4) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tskip_byte = 1;\n\t}\n\n\tdesc = dmaengine_prep_slave_single(dma->txchan,\n\t\t\tdma->tx_addr + xmit->tail + skip_byte,\n\t\t\tdma->tx_size - skip_byte, DMA_MEM_TO_DEV,\n\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tdma->tx_running = 1;\n\n\tdesc->callback = omap_8250_dma_tx_complete;\n\tdesc->callback_param = p;\n\n\tdma->tx_cookie = dmaengine_submit(desc);\n\n\tdma_sync_single_for_device(dma->txchan->device->dev, dma->tx_addr,\n\t\t\t\t   UART_XMIT_SIZE, DMA_TO_DEVICE);\n\n\tdma_async_issue_pending(dma->txchan);\n\tif (dma->tx_err)\n\t\tdma->tx_err = 0;\n\n\tserial8250_clear_THRI(p);\n\tif (skip_byte)\n\t\tserial_out(p, UART_TX, xmit->buf[xmit->tail]);\n\treturn 0;\nerr:\n\tdma->tx_err = 1;\n\treturn ret;\n}\n\nstatic bool handle_rx_dma(struct uart_8250_port *up, unsigned int iir)\n{\n\tswitch (iir & 0x3f) {\n\tcase UART_IIR_RLSI:\n\tcase UART_IIR_RX_TIMEOUT:\n\tcase UART_IIR_RDI:\n\t\tomap_8250_rx_dma_flush(up);\n\t\treturn true;\n\t}\n\treturn omap_8250_rx_dma(up);\n}\n\nstatic u16 omap_8250_handle_rx_dma(struct uart_8250_port *up, u8 iir, u16 status)\n{\n\tif ((status & (UART_LSR_DR | UART_LSR_BI)) &&\n\t    (iir & UART_IIR_RDI)) {\n\t\tif (handle_rx_dma(up, iir)) {\n\t\t\tstatus = serial8250_rx_chars(up, status);\n\t\t\tomap_8250_rx_dma(up);\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic void am654_8250_handle_rx_dma(struct uart_8250_port *up, u8 iir,\n\t\t\t\t     u16 status)\n{\n\t \n\tlockdep_assert_held_once(&up->port.lock);\n\n\t \n\tif ((status & (UART_LSR_DR | UART_LSR_BI)) &&\n\t    (up->ier & UART_IER_RDI)) {\n\t\tomap_8250_rx_dma(up);\n\t\tserial_out(up, UART_OMAP_EFR2, UART_OMAP_EFR2_TIMEOUT_BEHAVE);\n\t} else if ((iir & 0x3f) == UART_IIR_RX_TIMEOUT) {\n\t\t \n\t\tup->ier &= ~(UART_IER_RLSI | UART_IER_RDI);\n\t\tserial_out(up, UART_IER, up->ier);\n\t\tomap_8250_rx_dma_flush(up);\n\t\tserial_in(up, UART_IIR);\n\t\tserial_out(up, UART_OMAP_EFR2, 0x0);\n\t\tup->ier |= UART_IER_RLSI | UART_IER_RDI;\n\t\tserial_out(up, UART_IER, up->ier);\n\t}\n}\n\n \nstatic int omap_8250_dma_handle_irq(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct omap8250_priv *priv = up->port.private_data;\n\tu16 status;\n\tu8 iir;\n\n\tserial8250_rpm_get(up);\n\n\tiir = serial_port_in(port, UART_IIR);\n\tif (iir & UART_IIR_NO_INT) {\n\t\tserial8250_rpm_put(up);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_lock(&port->lock);\n\n\tstatus = serial_port_in(port, UART_LSR);\n\n\tif ((iir & 0x3f) != UART_IIR_THRI) {\n\t\tif (priv->habit & UART_HAS_EFR2)\n\t\t\tam654_8250_handle_rx_dma(up, iir, status);\n\t\telse\n\t\t\tstatus = omap_8250_handle_rx_dma(up, iir, status);\n\t}\n\n\tserial8250_modem_status(up);\n\tif (status & UART_LSR_THRE && up->dma->tx_err) {\n\t\tif (uart_tx_stopped(&up->port) ||\n\t\t    uart_circ_empty(&up->port.state->xmit)) {\n\t\t\tup->dma->tx_err = 0;\n\t\t\tserial8250_tx_chars(up);\n\t\t} else  {\n\t\t\t \n\t\t\tif (omap_8250_tx_dma(up))\n\t\t\t\tserial8250_tx_chars(up);\n\t\t}\n\t}\n\n\tuart_unlock_and_check_sysrq(port);\n\n\tserial8250_rpm_put(up);\n\treturn 1;\n}\n\nstatic bool the_no_dma_filter_fn(struct dma_chan *chan, void *param)\n{\n\treturn false;\n}\n\n#else\n\nstatic inline int omap_8250_rx_dma(struct uart_8250_port *p)\n{\n\treturn -EINVAL;\n}\n#endif\n\nstatic int omap8250_no_handle_irq(struct uart_port *port)\n{\n\t \n\tWARN_ONCE(1, \"Unexpected irq handling before port startup\\n\");\n\treturn 0;\n}\n\nstatic struct omap8250_dma_params am654_dma = {\n\t.rx_size = SZ_2K,\n\t.rx_trigger = 1,\n\t.tx_trigger = TX_TRIGGER,\n};\n\nstatic struct omap8250_dma_params am33xx_dma = {\n\t.rx_size = RX_TRIGGER,\n\t.rx_trigger = RX_TRIGGER,\n\t.tx_trigger = TX_TRIGGER,\n};\n\nstatic struct omap8250_platdata am654_platdata = {\n\t.dma_params\t= &am654_dma,\n\t.habit\t\t= UART_HAS_EFR2 | UART_HAS_RHR_IT_DIS |\n\t\t\t  UART_RX_TIMEOUT_QUIRK | UART_HAS_NATIVE_RS485,\n};\n\nstatic struct omap8250_platdata am33xx_platdata = {\n\t.dma_params\t= &am33xx_dma,\n\t.habit\t\t= OMAP_DMA_TX_KICK | UART_ERRATA_CLOCK_DISABLE,\n};\n\nstatic struct omap8250_platdata omap4_platdata = {\n\t.dma_params\t= &am33xx_dma,\n\t.habit\t\t= UART_ERRATA_CLOCK_DISABLE,\n};\n\nstatic const struct of_device_id omap8250_dt_ids[] = {\n\t{ .compatible = \"ti,am654-uart\", .data = &am654_platdata, },\n\t{ .compatible = \"ti,omap2-uart\" },\n\t{ .compatible = \"ti,omap3-uart\" },\n\t{ .compatible = \"ti,omap4-uart\", .data = &omap4_platdata, },\n\t{ .compatible = \"ti,am3352-uart\", .data = &am33xx_platdata, },\n\t{ .compatible = \"ti,am4372-uart\", .data = &am33xx_platdata, },\n\t{ .compatible = \"ti,dra742-uart\", .data = &omap4_platdata, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap8250_dt_ids);\n\nstatic int omap8250_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct omap8250_priv *priv;\n\tconst struct omap8250_platdata *pdata;\n\tstruct uart_8250_port up;\n\tstruct resource *regs;\n\tvoid __iomem *membase;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs) {\n\t\tdev_err(&pdev->dev, \"missing registers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmembase = devm_ioremap(&pdev->dev, regs->start,\n\t\t\t\t       resource_size(regs));\n\tif (!membase)\n\t\treturn -ENODEV;\n\n\tmemset(&up, 0, sizeof(up));\n\tup.port.dev = &pdev->dev;\n\tup.port.mapbase = regs->start;\n\tup.port.membase = membase;\n\tup.port.irq = irq;\n\t \n\tup.port.type = PORT_8250;\n\tup.port.iotype = UPIO_MEM;\n\tup.port.flags = UPF_FIXED_PORT | UPF_FIXED_TYPE | UPF_SOFT_FLOW |\n\t\tUPF_HARD_FLOW;\n\tup.port.private_data = priv;\n\n\tup.port.regshift = OMAP_UART_REGSHIFT;\n\tup.port.fifosize = 64;\n\tup.tx_loadsz = 64;\n\tup.capabilities = UART_CAP_FIFO;\n#ifdef CONFIG_PM\n\t \n\tup.capabilities |= UART_CAP_RPM;\n#endif\n\tup.port.set_termios = omap_8250_set_termios;\n\tup.port.set_mctrl = omap8250_set_mctrl;\n\tup.port.pm = omap_8250_pm;\n\tup.port.startup = omap_8250_startup;\n\tup.port.shutdown = omap_8250_shutdown;\n\tup.port.throttle = omap_8250_throttle;\n\tup.port.unthrottle = omap_8250_unthrottle;\n\tup.port.rs485_config = omap8250_rs485_config;\n\t \n\tup.port.rs485_supported = serial8250_em485_supported;\n\tup.rs485_start_tx = serial8250_em485_start_tx;\n\tup.rs485_stop_tx = serial8250_em485_stop_tx;\n\tup.port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);\n\n\tret = of_alias_get_id(np, \"serial\");\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias\\n\");\n\t\treturn ret;\n\t}\n\tup.port.line = ret;\n\n\tif (of_property_read_u32(np, \"clock-frequency\", &up.port.uartclk)) {\n\t\tstruct clk *clk;\n\n\t\tclk = devm_clk_get(&pdev->dev, NULL);\n\t\tif (IS_ERR(clk)) {\n\t\t\tif (PTR_ERR(clk) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t} else {\n\t\t\tup.port.uartclk = clk_get_rate(clk);\n\t\t}\n\t}\n\n\tif (of_property_read_u32(np, \"overrun-throttle-ms\",\n\t\t\t\t &up.overrun_backoff_time_ms) != 0)\n\t\tup.overrun_backoff_time_ms = 0;\n\n\tpdata = of_device_get_match_data(&pdev->dev);\n\tif (pdata)\n\t\tpriv->habit |= pdata->habit;\n\n\tif (!up.port.uartclk) {\n\t\tup.port.uartclk = DEFAULT_CLK_SPEED;\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"No clock speed specified: using default: %d\\n\",\n\t\t\t DEFAULT_CLK_SPEED);\n\t}\n\n\tpriv->membase = membase;\n\tpriv->line = -ENODEV;\n\tpriv->latency = PM_QOS_CPU_LATENCY_DEFAULT_VALUE;\n\tpriv->calc_latency = PM_QOS_CPU_LATENCY_DEFAULT_VALUE;\n\tcpu_latency_qos_add_request(&priv->pm_qos_request, priv->latency);\n\tINIT_WORK(&priv->qos_work, omap8250_uart_qos_work);\n\n\tspin_lock_init(&priv->rx_dma_lock);\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\n\t \n\tif (!of_get_available_child_count(pdev->dev.of_node))\n\t\tpm_runtime_set_autosuspend_delay(&pdev->dev, -1);\n\n\tpm_runtime_irq_safe(&pdev->dev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tomap_serial_fill_features_erratas(&up, priv);\n\tup.port.handle_irq = omap8250_no_handle_irq;\n\tpriv->rx_trigger = RX_TRIGGER;\n\tpriv->tx_trigger = TX_TRIGGER;\n#ifdef CONFIG_SERIAL_8250_DMA\n\t \n\tret = of_property_count_strings(np, \"dma-names\");\n\tif (ret == 2) {\n\t\tstruct omap8250_dma_params *dma_params = NULL;\n\t\tstruct uart_8250_dma *dma = &priv->omap8250_dma;\n\n\t\tdma->fn = the_no_dma_filter_fn;\n\t\tdma->tx_dma = omap_8250_tx_dma;\n\t\tdma->rx_dma = omap_8250_rx_dma;\n\t\tif (pdata)\n\t\t\tdma_params = pdata->dma_params;\n\n\t\tif (dma_params) {\n\t\t\tdma->rx_size = dma_params->rx_size;\n\t\t\tdma->rxconf.src_maxburst = dma_params->rx_trigger;\n\t\t\tdma->txconf.dst_maxburst = dma_params->tx_trigger;\n\t\t\tpriv->rx_trigger = dma_params->rx_trigger;\n\t\t\tpriv->tx_trigger = dma_params->tx_trigger;\n\t\t} else {\n\t\t\tdma->rx_size = RX_TRIGGER;\n\t\t\tdma->rxconf.src_maxburst = RX_TRIGGER;\n\t\t\tdma->txconf.dst_maxburst = TX_TRIGGER;\n\t\t}\n\t}\n#endif\n\n\tirq_set_status_flags(irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(&pdev->dev, irq, omap8250_irq, 0,\n\t\t\t       dev_name(&pdev->dev), priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->wakeirq = irq_of_parse_and_map(np, 1);\n\n\tret = serial8250_register_8250_port(&up);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"unable to register 8250 port\\n\");\n\t\tgoto err;\n\t}\n\tpriv->line = ret;\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\treturn 0;\nerr:\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_sync(&pdev->dev);\n\tflush_work(&priv->qos_work);\n\tpm_runtime_disable(&pdev->dev);\n\tcpu_latency_qos_remove_request(&priv->pm_qos_request);\n\treturn ret;\n}\n\nstatic int omap8250_remove(struct platform_device *pdev)\n{\n\tstruct omap8250_priv *priv = platform_get_drvdata(pdev);\n\tstruct uart_8250_port *up;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(&pdev->dev);\n\tif (err)\n\t\tdev_err(&pdev->dev, \"Failed to resume hardware\\n\");\n\n\tup = serial8250_get_port(priv->line);\n\tomap_8250_shutdown(&up->port);\n\tserial8250_unregister_port(priv->line);\n\tpriv->line = -ENODEV;\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_sync(&pdev->dev);\n\tflush_work(&priv->qos_work);\n\tpm_runtime_disable(&pdev->dev);\n\tcpu_latency_qos_remove_request(&priv->pm_qos_request);\n\tdevice_init_wakeup(&pdev->dev, false);\n\treturn 0;\n}\n\nstatic int omap8250_prepare(struct device *dev)\n{\n\tstruct omap8250_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn 0;\n\tpriv->is_suspending = true;\n\treturn 0;\n}\n\nstatic void omap8250_complete(struct device *dev)\n{\n\tstruct omap8250_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn;\n\tpriv->is_suspending = false;\n}\n\nstatic int omap8250_suspend(struct device *dev)\n{\n\tstruct omap8250_priv *priv = dev_get_drvdata(dev);\n\tstruct uart_8250_port *up = serial8250_get_port(priv->line);\n\tint err = 0;\n\n\tserial8250_suspend_port(priv->line);\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err)\n\t\treturn err;\n\tif (!device_may_wakeup(dev))\n\t\tpriv->wer = 0;\n\tserial_out(up, UART_OMAP_WER, priv->wer);\n\tif (uart_console(&up->port) && console_suspend_enabled)\n\t\terr = pm_runtime_force_suspend(dev);\n\tflush_work(&priv->qos_work);\n\n\treturn err;\n}\n\nstatic int omap8250_resume(struct device *dev)\n{\n\tstruct omap8250_priv *priv = dev_get_drvdata(dev);\n\tstruct uart_8250_port *up = serial8250_get_port(priv->line);\n\tint err;\n\n\tif (uart_console(&up->port) && console_suspend_enabled) {\n\t\terr = pm_runtime_force_resume(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tserial8250_resume_port(priv->line);\n\t \n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic int omap8250_lost_context(struct uart_8250_port *up)\n{\n\tu32 val;\n\n\tval = serial_in(up, UART_OMAP_SCR);\n\t \n\tif (!val)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void uart_write(struct omap8250_priv *priv, u32 reg, u32 val)\n{\n\twritel(val, priv->membase + (reg << OMAP_UART_REGSHIFT));\n}\n\n \nstatic int omap8250_soft_reset(struct device *dev)\n{\n\tstruct omap8250_priv *priv = dev_get_drvdata(dev);\n\tint timeout = 100;\n\tint sysc;\n\tint syss;\n\n\t \n\tuart_write(priv, UART_OMAP_SCR, OMAP_UART_SCR_DMAMODE_1);\n\tuart_write(priv, UART_OMAP_SCR,\n\t\t   OMAP_UART_SCR_DMAMODE_1 | OMAP_UART_SCR_DMAMODE_CTL);\n\n\tsysc = uart_read(priv, UART_OMAP_SYSC);\n\n\t \n\tsysc |= OMAP_UART_SYSC_SOFTRESET;\n\tuart_write(priv, UART_OMAP_SYSC, sysc);\n\n\t \n\tdo {\n\t\tudelay(1);\n\t\tsyss = uart_read(priv, UART_OMAP_SYSS);\n\t} while (--timeout && !(syss & OMAP_UART_SYSS_RESETDONE));\n\n\tif (!timeout) {\n\t\tdev_err(dev, \"timed out waiting for reset done\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int omap8250_runtime_suspend(struct device *dev)\n{\n\tstruct omap8250_priv *priv = dev_get_drvdata(dev);\n\tstruct uart_8250_port *up = NULL;\n\n\tif (priv->line >= 0)\n\t\tup = serial8250_get_port(priv->line);\n\n\tif (priv->habit & UART_ERRATA_CLOCK_DISABLE) {\n\t\tint ret;\n\n\t\tret = omap8250_soft_reset(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (up) {\n\t\t\t \n\t\t\tomap8250_update_mdr1(up, priv);\n\t\t\t \n\t\t\tserial_out(up, UART_OMAP_WER, priv->wer);\n\t\t}\n\t}\n\n\tif (up && up->dma && up->dma->rxchan)\n\t\tomap_8250_rx_dma_flush(up);\n\n\tpriv->latency = PM_QOS_CPU_LATENCY_DEFAULT_VALUE;\n\tschedule_work(&priv->qos_work);\n\n\treturn 0;\n}\n\nstatic int omap8250_runtime_resume(struct device *dev)\n{\n\tstruct omap8250_priv *priv = dev_get_drvdata(dev);\n\tstruct uart_8250_port *up = NULL;\n\n\tif (priv->line >= 0)\n\t\tup = serial8250_get_port(priv->line);\n\n\tif (up && omap8250_lost_context(up)) {\n\t\tspin_lock_irq(&up->port.lock);\n\t\tomap8250_restore_regs(up);\n\t\tspin_unlock_irq(&up->port.lock);\n\t}\n\n\tif (up && up->dma && up->dma->rxchan && !(priv->habit & UART_HAS_EFR2)) {\n\t\tspin_lock_irq(&up->port.lock);\n\t\tomap_8250_rx_dma(up);\n\t\tspin_unlock_irq(&up->port.lock);\n\t}\n\n\tpriv->latency = priv->calc_latency;\n\tschedule_work(&priv->qos_work);\n\treturn 0;\n}\n\n#ifdef CONFIG_SERIAL_8250_OMAP_TTYO_FIXUP\nstatic int __init omap8250_console_fixup(void)\n{\n\tchar *omap_str;\n\tchar *options;\n\tu8 idx;\n\n\tif (strstr(boot_command_line, \"console=ttyS\"))\n\t\t \n\t\treturn 0;\n\n\tomap_str = strstr(boot_command_line, \"console=ttyO\");\n\tif (!omap_str)\n\t\t \n\t\treturn 0;\n\n\tomap_str += 12;\n\tif ('0' <= *omap_str && *omap_str <= '9')\n\t\tidx = *omap_str - '0';\n\telse\n\t\treturn 0;\n\n\tomap_str++;\n\tif (omap_str[0] == ',') {\n\t\tomap_str++;\n\t\toptions = omap_str;\n\t} else {\n\t\toptions = NULL;\n\t}\n\n\tadd_preferred_console(\"ttyS\", idx, options);\n\tpr_err(\"WARNING: Your 'console=ttyO%d' has been replaced by 'ttyS%d'\\n\",\n\t       idx, idx);\n\tpr_err(\"This ensures that you still see kernel messages. Please\\n\");\n\tpr_err(\"update your kernel commandline.\\n\");\n\treturn 0;\n}\nconsole_initcall(omap8250_console_fixup);\n#endif\n\nstatic const struct dev_pm_ops omap8250_dev_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(omap8250_suspend, omap8250_resume)\n\tRUNTIME_PM_OPS(omap8250_runtime_suspend,\n\t\t\t   omap8250_runtime_resume, NULL)\n\t.prepare        = pm_sleep_ptr(omap8250_prepare),\n\t.complete       = pm_sleep_ptr(omap8250_complete),\n};\n\nstatic struct platform_driver omap8250_platform_driver = {\n\t.driver = {\n\t\t.name\t\t= \"omap8250\",\n\t\t.pm\t\t= pm_ptr(&omap8250_dev_pm_ops),\n\t\t.of_match_table = omap8250_dt_ids,\n\t},\n\t.probe\t\t\t= omap8250_probe,\n\t.remove\t\t\t= omap8250_remove,\n};\nmodule_platform_driver(omap8250_platform_driver);\n\nMODULE_AUTHOR(\"Sebastian Andrzej Siewior\");\nMODULE_DESCRIPTION(\"OMAP 8250 Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}