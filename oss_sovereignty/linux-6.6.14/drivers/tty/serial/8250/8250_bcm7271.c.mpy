{
  "module_name": "8250_bcm7271.c",
  "hash_id": "9e0640c8266cb36c3840a7430237dca8318590fd69bd96e0133997f1a23bf688",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_bcm7271.c",
  "human_readable_source": "\n \n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/dma-mapping.h>\n#include <linux/tty_flip.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n\n#include \"8250.h\"\n\n \n#define UDMA_ARB_RX\t\t0x00\n#define UDMA_ARB_TX\t\t0x04\n#define\t\tUDMA_ARB_REQ\t\t\t\t0x00000001\n#define\t\tUDMA_ARB_GRANT\t\t\t\t0x00000002\n\n#define UDMA_RX_REVISION\t0x00\n#define UDMA_RX_REVISION_REQUIRED\t\t\t0x00000101\n#define UDMA_RX_CTRL\t\t0x04\n#define\t\tUDMA_RX_CTRL_BUF_CLOSE_MODE\t\t0x00010000\n#define\t\tUDMA_RX_CTRL_MASK_WR_DONE\t\t0x00008000\n#define\t\tUDMA_RX_CTRL_ENDIAN_OVERRIDE\t\t0x00004000\n#define\t\tUDMA_RX_CTRL_ENDIAN\t\t\t0x00002000\n#define\t\tUDMA_RX_CTRL_OE_IS_ERR\t\t\t0x00001000\n#define\t\tUDMA_RX_CTRL_PE_IS_ERR\t\t\t0x00000800\n#define\t\tUDMA_RX_CTRL_FE_IS_ERR\t\t\t0x00000400\n#define\t\tUDMA_RX_CTRL_NUM_BUF_USED_MASK\t\t0x000003c0\n#define\t\tUDMA_RX_CTRL_NUM_BUF_USED_SHIFT\t6\n#define\t\tUDMA_RX_CTRL_BUF_CLOSE_CLK_SEL_SYS\t0x00000020\n#define\t\tUDMA_RX_CTRL_BUF_CLOSE_ENA\t\t0x00000010\n#define\t\tUDMA_RX_CTRL_TIMEOUT_CLK_SEL_SYS\t0x00000008\n#define\t\tUDMA_RX_CTRL_TIMEOUT_ENA\t\t0x00000004\n#define\t\tUDMA_RX_CTRL_ABORT\t\t\t0x00000002\n#define\t\tUDMA_RX_CTRL_ENA\t\t\t0x00000001\n#define UDMA_RX_STATUS\t\t0x08\n#define\t\tUDMA_RX_STATUS_ACTIVE_BUF_MASK\t\t0x0000000f\n#define UDMA_RX_TRANSFER_LEN\t0x0c\n#define UDMA_RX_TRANSFER_TOTAL\t0x10\n#define UDMA_RX_BUFFER_SIZE\t0x14\n#define UDMA_RX_SRC_ADDR\t0x18\n#define UDMA_RX_TIMEOUT\t\t0x1c\n#define UDMA_RX_BUFFER_CLOSE\t0x20\n#define UDMA_RX_BLOCKOUT_COUNTER 0x24\n#define UDMA_RX_BUF0_PTR_LO\t0x28\n#define UDMA_RX_BUF0_PTR_HI\t0x2c\n#define UDMA_RX_BUF0_STATUS\t0x30\n#define\t\tUDMA_RX_BUFX_STATUS_OVERRUN_ERR\t\t0x00000010\n#define\t\tUDMA_RX_BUFX_STATUS_FRAME_ERR\t\t0x00000008\n#define\t\tUDMA_RX_BUFX_STATUS_PARITY_ERR\t\t0x00000004\n#define\t\tUDMA_RX_BUFX_STATUS_CLOSE_EXPIRED\t0x00000002\n#define\t\tUDMA_RX_BUFX_STATUS_DATA_RDY\t\t0x00000001\n#define UDMA_RX_BUF0_DATA_LEN\t0x34\n#define UDMA_RX_BUF1_PTR_LO\t0x38\n#define UDMA_RX_BUF1_PTR_HI\t0x3c\n#define UDMA_RX_BUF1_STATUS\t0x40\n#define UDMA_RX_BUF1_DATA_LEN\t0x44\n\n#define UDMA_TX_REVISION\t0x00\n#define UDMA_TX_REVISION_REQUIRED\t\t\t0x00000101\n#define UDMA_TX_CTRL\t\t0x04\n#define\t\tUDMA_TX_CTRL_ENDIAN_OVERRIDE\t\t0x00000080\n#define\t\tUDMA_TX_CTRL_ENDIAN\t\t\t0x00000040\n#define\t\tUDMA_TX_CTRL_NUM_BUF_USED_MASK\t\t0x00000030\n#define\t\tUDMA_TX_CTRL_NUM_BUF_USED_1\t\t0x00000010\n#define\t\tUDMA_TX_CTRL_ABORT\t\t\t0x00000002\n#define\t\tUDMA_TX_CTRL_ENA\t\t\t0x00000001\n#define UDMA_TX_DST_ADDR\t0x08\n#define UDMA_TX_BLOCKOUT_COUNTER 0x10\n#define UDMA_TX_TRANSFER_LEN\t0x14\n#define UDMA_TX_TRANSFER_TOTAL\t0x18\n#define UDMA_TX_STATUS\t\t0x20\n#define UDMA_TX_BUF0_PTR_LO\t0x24\n#define UDMA_TX_BUF0_PTR_HI\t0x28\n#define UDMA_TX_BUF0_STATUS\t0x2c\n#define\t\tUDMA_TX_BUFX_LAST\t\t\t0x00000002\n#define\t\tUDMA_TX_BUFX_EMPTY\t\t\t0x00000001\n#define UDMA_TX_BUF0_DATA_LEN\t0x30\n#define UDMA_TX_BUF0_DATA_SENT\t0x34\n#define UDMA_TX_BUF1_PTR_LO\t0x38\n\n#define UDMA_INTR_STATUS\t0x00\n#define\t\tUDMA_INTR_ARB_TX_GRANT\t\t\t0x00040000\n#define\t\tUDMA_INTR_ARB_RX_GRANT\t\t\t0x00020000\n#define\t\tUDMA_INTR_TX_ALL_EMPTY\t\t\t0x00010000\n#define\t\tUDMA_INTR_TX_EMPTY_BUF1\t\t\t0x00008000\n#define\t\tUDMA_INTR_TX_EMPTY_BUF0\t\t\t0x00004000\n#define\t\tUDMA_INTR_TX_ABORT\t\t\t0x00002000\n#define\t\tUDMA_INTR_TX_DONE\t\t\t0x00001000\n#define\t\tUDMA_INTR_RX_ERROR\t\t\t0x00000800\n#define\t\tUDMA_INTR_RX_TIMEOUT\t\t\t0x00000400\n#define\t\tUDMA_INTR_RX_READY_BUF7\t\t\t0x00000200\n#define\t\tUDMA_INTR_RX_READY_BUF6\t\t\t0x00000100\n#define\t\tUDMA_INTR_RX_READY_BUF5\t\t\t0x00000080\n#define\t\tUDMA_INTR_RX_READY_BUF4\t\t\t0x00000040\n#define\t\tUDMA_INTR_RX_READY_BUF3\t\t\t0x00000020\n#define\t\tUDMA_INTR_RX_READY_BUF2\t\t\t0x00000010\n#define\t\tUDMA_INTR_RX_READY_BUF1\t\t\t0x00000008\n#define\t\tUDMA_INTR_RX_READY_BUF0\t\t\t0x00000004\n#define\t\tUDMA_INTR_RX_READY_MASK\t\t\t0x000003fc\n#define\t\tUDMA_INTR_RX_READY_SHIFT\t\t2\n#define\t\tUDMA_INTR_RX_ABORT\t\t\t0x00000002\n#define\t\tUDMA_INTR_RX_DONE\t\t\t0x00000001\n#define UDMA_INTR_SET\t\t0x04\n#define UDMA_INTR_CLEAR\t\t0x08\n#define UDMA_INTR_MASK_STATUS\t0x0c\n#define UDMA_INTR_MASK_SET\t0x10\n#define UDMA_INTR_MASK_CLEAR\t0x14\n\n\n#define UDMA_RX_INTERRUPTS ( \\\n\tUDMA_INTR_RX_ERROR | \\\n\tUDMA_INTR_RX_TIMEOUT | \\\n\tUDMA_INTR_RX_READY_BUF0 | \\\n\tUDMA_INTR_RX_READY_BUF1 | \\\n\tUDMA_INTR_RX_READY_BUF2 | \\\n\tUDMA_INTR_RX_READY_BUF3 | \\\n\tUDMA_INTR_RX_READY_BUF4 | \\\n\tUDMA_INTR_RX_READY_BUF5 | \\\n\tUDMA_INTR_RX_READY_BUF6 | \\\n\tUDMA_INTR_RX_READY_BUF7 | \\\n\tUDMA_INTR_RX_ABORT | \\\n\tUDMA_INTR_RX_DONE)\n\n#define UDMA_RX_ERR_INTERRUPTS ( \\\n\tUDMA_INTR_RX_ERROR | \\\n\tUDMA_INTR_RX_TIMEOUT | \\\n\tUDMA_INTR_RX_ABORT | \\\n\tUDMA_INTR_RX_DONE)\n\n#define UDMA_TX_INTERRUPTS ( \\\n\tUDMA_INTR_TX_ABORT | \\\n\tUDMA_INTR_TX_DONE)\n\n#define UDMA_IS_RX_INTERRUPT(status) ((status) & UDMA_RX_INTERRUPTS)\n#define UDMA_IS_TX_INTERRUPT(status) ((status) & UDMA_TX_INTERRUPTS)\n\n\n \n#define UDMA_RX_BUFS_COUNT\t8\n#define UDMA_RX_BUFS_REG_OFFSET (UDMA_RX_BUF1_PTR_LO - UDMA_RX_BUF0_PTR_LO)\n#define UDMA_RX_BUFx_PTR_LO(x)\t(UDMA_RX_BUF0_PTR_LO + \\\n\t\t\t\t ((x) * UDMA_RX_BUFS_REG_OFFSET))\n#define UDMA_RX_BUFx_PTR_HI(x)\t(UDMA_RX_BUF0_PTR_HI + \\\n\t\t\t\t ((x) * UDMA_RX_BUFS_REG_OFFSET))\n#define UDMA_RX_BUFx_STATUS(x)\t(UDMA_RX_BUF0_STATUS + \\\n\t\t\t\t ((x) * UDMA_RX_BUFS_REG_OFFSET))\n#define UDMA_RX_BUFx_DATA_LEN(x) (UDMA_RX_BUF0_DATA_LEN + \\\n\t\t\t\t  ((x) * UDMA_RX_BUFS_REG_OFFSET))\n\n \n#define UDMA_TX_BUFS_COUNT\t2\n#define UDMA_TX_BUFS_REG_OFFSET (UDMA_TX_BUF1_PTR_LO - UDMA_TX_BUF0_PTR_LO)\n#define UDMA_TX_BUFx_PTR_LO(x)\t(UDMA_TX_BUF0_PTR_LO + \\\n\t\t\t\t ((x) * UDMA_TX_BUFS_REG_OFFSET))\n#define UDMA_TX_BUFx_PTR_HI(x)\t(UDMA_TX_BUF0_PTR_HI + \\\n\t\t\t\t ((x) * UDMA_TX_BUFS_REG_OFFSET))\n#define UDMA_TX_BUFx_STATUS(x)\t(UDMA_TX_BUF0_STATUS + \\\n\t\t\t\t ((x) * UDMA_TX_BUFS_REG_OFFSET))\n#define UDMA_TX_BUFx_DATA_LEN(x) (UDMA_TX_BUF0_DATA_LEN + \\\n\t\t\t\t  ((x) * UDMA_TX_BUFS_REG_OFFSET))\n#define UDMA_TX_BUFx_DATA_SENT(x) (UDMA_TX_BUF0_DATA_SENT + \\\n\t\t\t\t   ((x) * UDMA_TX_BUFS_REG_OFFSET))\n#define REGS_8250 0\n#define REGS_DMA_RX 1\n#define REGS_DMA_TX 2\n#define REGS_DMA_ISR 3\n#define REGS_DMA_ARB 4\n#define REGS_MAX 5\n\n#define TX_BUF_SIZE 4096\n#define RX_BUF_SIZE 4096\n#define RX_BUFS_COUNT 2\n#define KHZ    1000\n#define MHZ(x) ((x) * KHZ * KHZ)\n\nstatic const u32 brcmstb_rate_table[] = {\n\tMHZ(81),\n\tMHZ(108),\n\tMHZ(64),\t\t \n\tMHZ(48),\n};\n\nstatic const u32 brcmstb_rate_table_7278[] = {\n\tMHZ(81),\n\tMHZ(108),\n\t0,\n\tMHZ(48),\n};\n\nstruct brcmuart_priv {\n\tint\t\tline;\n\tstruct clk\t*baud_mux_clk;\n\tunsigned long\tdefault_mux_rate;\n\tu32\t\treal_rates[ARRAY_SIZE(brcmstb_rate_table)];\n\tconst u32\t*rate_table;\n\tktime_t\t\tchar_wait;\n\tstruct uart_port *up;\n\tstruct hrtimer\thrt;\n\tbool\t\tshutdown;\n\tbool\t\tdma_enabled;\n\tstruct uart_8250_dma dma;\n\tvoid __iomem\t*regs[REGS_MAX];\n\tdma_addr_t\trx_addr;\n\tvoid\t\t*rx_bufs;\n\tsize_t\t\trx_size;\n\tint\t\trx_next_buf;\n\tdma_addr_t\ttx_addr;\n\tvoid\t\t*tx_buf;\n\tsize_t\t\ttx_size;\n\tbool\t\ttx_running;\n\tbool\t\trx_running;\n\tstruct dentry\t*debugfs_dir;\n\n\t \n\tu64\t\tdma_rx_partial_buf;\n\tu64\t\tdma_rx_full_buf;\n\tu32\t\trx_bad_timeout_late_char;\n\tu32\t\trx_bad_timeout_no_char;\n\tu32\t\trx_missing_close_timeout;\n\tu32\t\trx_err;\n\tu32\t\trx_timeout;\n\tu32\t\trx_abort;\n\tu32\t\tsaved_mctrl;\n};\n\nstatic struct dentry *brcmuart_debugfs_root;\n\n \nstatic u32 udma_readl(struct brcmuart_priv *priv,\n\t\tint reg_type, int offset)\n{\n\treturn readl(priv->regs[reg_type] + offset);\n}\n\nstatic void udma_writel(struct brcmuart_priv *priv,\n\t\t\tint reg_type, int offset, u32 value)\n{\n\twritel(value, priv->regs[reg_type] + offset);\n}\n\nstatic void udma_set(struct brcmuart_priv *priv,\n\t\tint reg_type, int offset, u32 bits)\n{\n\tvoid __iomem *reg = priv->regs[reg_type] + offset;\n\tu32 value;\n\n\tvalue = readl(reg);\n\tvalue |= bits;\n\twritel(value, reg);\n}\n\nstatic void udma_unset(struct brcmuart_priv *priv,\n\t\tint reg_type, int offset, u32 bits)\n{\n\tvoid __iomem *reg = priv->regs[reg_type] + offset;\n\tu32 value;\n\n\tvalue = readl(reg);\n\tvalue &= ~bits;\n\twritel(value, reg);\n}\n\n \nstatic int brcmuart_arbitration(struct brcmuart_priv *priv, bool acquire)\n{\n\tu32 rx_grant;\n\tu32 tx_grant;\n\tint waits;\n\tint ret = 0;\n\n\tif (acquire) {\n\t\tudma_set(priv, REGS_DMA_ARB, UDMA_ARB_RX, UDMA_ARB_REQ);\n\t\tudma_set(priv, REGS_DMA_ARB, UDMA_ARB_TX, UDMA_ARB_REQ);\n\n\t\twaits = 1;\n\t\twhile (1) {\n\t\t\trx_grant = udma_readl(priv, REGS_DMA_ARB, UDMA_ARB_RX);\n\t\t\ttx_grant = udma_readl(priv, REGS_DMA_ARB, UDMA_ARB_TX);\n\t\t\tif (rx_grant & tx_grant & UDMA_ARB_GRANT)\n\t\t\t\treturn 0;\n\t\t\tif (waits-- == 0)\n\t\t\t\tbreak;\n\t\t\tmsleep(1);\n\t\t}\n\t\tret = 1;\n\t}\n\n\tudma_unset(priv, REGS_DMA_ARB, UDMA_ARB_RX, UDMA_ARB_REQ);\n\tudma_unset(priv, REGS_DMA_ARB, UDMA_ARB_TX, UDMA_ARB_REQ);\n\treturn ret;\n}\n\nstatic void brcmuart_init_dma_hardware(struct brcmuart_priv *priv)\n{\n\tu32 daddr;\n\tu32 value;\n\tint x;\n\n\t \n\tudma_writel(priv, REGS_DMA_ISR, UDMA_INTR_MASK_SET, 0xffffffff);\n\n\tudma_writel(priv, REGS_DMA_RX, UDMA_RX_BUFFER_SIZE, RX_BUF_SIZE);\n\n\t \n\tudma_writel(priv, REGS_DMA_RX, UDMA_RX_BUFFER_CLOSE, 16*10*32);\n\tvalue = (RX_BUFS_COUNT << UDMA_RX_CTRL_NUM_BUF_USED_SHIFT)\n\t\t| UDMA_RX_CTRL_BUF_CLOSE_MODE\n\t\t| UDMA_RX_CTRL_BUF_CLOSE_ENA;\n\tudma_writel(priv, REGS_DMA_RX, UDMA_RX_CTRL, value);\n\n\tudma_writel(priv, REGS_DMA_RX, UDMA_RX_BLOCKOUT_COUNTER, 0);\n\tdaddr = priv->rx_addr;\n\tfor (x = 0; x < RX_BUFS_COUNT; x++) {\n\n\t\t \n\t\tudma_writel(priv, REGS_DMA_RX, UDMA_RX_TRANSFER_LEN, 0);\n\n\t\tudma_writel(priv, REGS_DMA_RX, UDMA_RX_BUFx_PTR_LO(x),\n\t\t\t    lower_32_bits(daddr));\n\t\tudma_writel(priv, REGS_DMA_RX, UDMA_RX_BUFx_PTR_HI(x),\n\t\t\t    upper_32_bits(daddr));\n\t\tdaddr += RX_BUF_SIZE;\n\t}\n\n\tdaddr = priv->tx_addr;\n\tudma_writel(priv, REGS_DMA_TX, UDMA_TX_BUFx_PTR_LO(0),\n\t\t    lower_32_bits(daddr));\n\tudma_writel(priv, REGS_DMA_TX, UDMA_TX_BUFx_PTR_HI(0),\n\t\t    upper_32_bits(daddr));\n\tudma_writel(priv, REGS_DMA_TX, UDMA_TX_CTRL,\n\t\t    UDMA_TX_CTRL_NUM_BUF_USED_1);\n\n\t \n\tudma_writel(priv, REGS_DMA_ISR, UDMA_INTR_CLEAR, 0xffffffff);\n\tudma_writel(priv, REGS_DMA_ISR, UDMA_INTR_MASK_CLEAR,\n\t\tUDMA_RX_INTERRUPTS | UDMA_TX_INTERRUPTS);\n\n}\n\nstatic void start_rx_dma(struct uart_8250_port *p)\n{\n\tstruct brcmuart_priv *priv = p->port.private_data;\n\tint x;\n\n\tudma_unset(priv, REGS_DMA_RX, UDMA_RX_CTRL, UDMA_RX_CTRL_ENA);\n\n\t \n\tfor (x = 0; x < RX_BUFS_COUNT; x++)\n\t\tudma_unset(priv, REGS_DMA_RX, UDMA_RX_BUFx_STATUS(x),\n\t\t\tUDMA_RX_BUFX_STATUS_DATA_RDY);\n\n\t \n\tudma_unset(priv, REGS_DMA_RX, UDMA_RX_STATUS,\n\t\t   UDMA_RX_STATUS_ACTIVE_BUF_MASK);\n\tpriv->rx_next_buf = 0;\n\n\tudma_set(priv, REGS_DMA_RX, UDMA_RX_CTRL, UDMA_RX_CTRL_ENA);\n\tpriv->rx_running = true;\n}\n\nstatic void stop_rx_dma(struct uart_8250_port *p)\n{\n\tstruct brcmuart_priv *priv = p->port.private_data;\n\n\t \n\tif (priv->rx_running)\n\t\tudma_set(priv, REGS_DMA_RX, UDMA_RX_CTRL, UDMA_RX_CTRL_ABORT);\n}\n\nstatic int stop_tx_dma(struct uart_8250_port *p)\n{\n\tstruct brcmuart_priv *priv = p->port.private_data;\n\tu32 value;\n\n\t \n\tvalue = udma_readl(priv, REGS_DMA_TX, UDMA_TX_CTRL);\n\tif (value & UDMA_TX_CTRL_ENA)\n\t\tudma_set(priv, REGS_DMA_TX, UDMA_TX_CTRL, UDMA_TX_CTRL_ABORT);\n\tpriv->tx_running = false;\n\treturn 0;\n}\n\n \nstatic int brcmuart_tx_dma(struct uart_8250_port *p)\n{\n\tstruct brcmuart_priv *priv = p->port.private_data;\n\tstruct circ_buf *xmit = &p->port.state->xmit;\n\tu32 tx_size;\n\n\tif (uart_tx_stopped(&p->port) || priv->tx_running ||\n\t\tuart_circ_empty(xmit)) {\n\t\treturn 0;\n\t}\n\ttx_size = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\n\tpriv->dma.tx_err = 0;\n\tmemcpy(priv->tx_buf, &xmit->buf[xmit->tail], tx_size);\n\tuart_xmit_advance(&p->port, tx_size);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&p->port);\n\n\tudma_writel(priv, REGS_DMA_TX, UDMA_TX_TRANSFER_LEN, tx_size);\n\tudma_writel(priv, REGS_DMA_TX, UDMA_TX_BUF0_DATA_LEN, tx_size);\n\tudma_unset(priv, REGS_DMA_TX, UDMA_TX_BUF0_STATUS, UDMA_TX_BUFX_EMPTY);\n\tudma_set(priv, REGS_DMA_TX, UDMA_TX_CTRL, UDMA_TX_CTRL_ENA);\n\tpriv->tx_running = true;\n\n\treturn 0;\n}\n\nstatic void brcmuart_rx_buf_done_isr(struct uart_port *up, int index)\n{\n\tstruct brcmuart_priv *priv = up->private_data;\n\tstruct tty_port *tty_port = &up->state->port;\n\tu32 status;\n\tu32 length;\n\tu32 copied;\n\n\t \n\tstatus = udma_readl(priv, REGS_DMA_RX, UDMA_RX_BUFx_STATUS(index));\n\tlength = udma_readl(priv, REGS_DMA_RX, UDMA_RX_BUFx_DATA_LEN(index));\n\n\tif ((status & UDMA_RX_BUFX_STATUS_DATA_RDY) == 0) {\n\t\tdev_err(up->dev, \"RX done interrupt but DATA_RDY not found\\n\");\n\t\treturn;\n\t}\n\tif (status & (UDMA_RX_BUFX_STATUS_OVERRUN_ERR |\n\t\t      UDMA_RX_BUFX_STATUS_FRAME_ERR |\n\t\t      UDMA_RX_BUFX_STATUS_PARITY_ERR)) {\n\t\tif (status & UDMA_RX_BUFX_STATUS_OVERRUN_ERR) {\n\t\t\tup->icount.overrun++;\n\t\t\tdev_warn(up->dev, \"RX OVERRUN Error\\n\");\n\t\t}\n\t\tif (status & UDMA_RX_BUFX_STATUS_FRAME_ERR) {\n\t\t\tup->icount.frame++;\n\t\t\tdev_warn(up->dev, \"RX FRAMING Error\\n\");\n\t\t}\n\t\tif (status & UDMA_RX_BUFX_STATUS_PARITY_ERR) {\n\t\t\tup->icount.parity++;\n\t\t\tdev_warn(up->dev, \"RX PARITY Error\\n\");\n\t\t}\n\t}\n\tcopied = (u32)tty_insert_flip_string(\n\t\ttty_port,\n\t\tpriv->rx_bufs + (index * RX_BUF_SIZE),\n\t\tlength);\n\tif (copied != length) {\n\t\tdev_warn(up->dev, \"Flip buffer overrun of %d bytes\\n\",\n\t\t\t length - copied);\n\t\tup->icount.overrun += length - copied;\n\t}\n\tup->icount.rx += length;\n\tif (status & UDMA_RX_BUFX_STATUS_CLOSE_EXPIRED)\n\t\tpriv->dma_rx_partial_buf++;\n\telse if (length != RX_BUF_SIZE)\n\t\t \n\t\tpriv->rx_missing_close_timeout++;\n\telse\n\t\tpriv->dma_rx_full_buf++;\n\n\ttty_flip_buffer_push(tty_port);\n}\n\nstatic void brcmuart_rx_isr(struct uart_port *up, u32 rx_isr)\n{\n\tstruct brcmuart_priv *priv = up->private_data;\n\tstruct device *dev = up->dev;\n\tu32 rx_done_isr;\n\tu32 check_isr;\n\n\trx_done_isr = (rx_isr & UDMA_INTR_RX_READY_MASK);\n\twhile (rx_done_isr) {\n\t\tcheck_isr = UDMA_INTR_RX_READY_BUF0 << priv->rx_next_buf;\n\t\tif (check_isr & rx_done_isr) {\n\t\t\tbrcmuart_rx_buf_done_isr(up, priv->rx_next_buf);\n\t\t} else {\n\t\t\tdev_err(dev,\n\t\t\t\t\"RX buffer ready out of sequence, restarting RX DMA\\n\");\n\t\t\tstart_rx_dma(up_to_u8250p(up));\n\t\t\tbreak;\n\t\t}\n\t\tif (rx_isr & UDMA_RX_ERR_INTERRUPTS) {\n\t\t\tif (rx_isr & UDMA_INTR_RX_ERROR)\n\t\t\t\tpriv->rx_err++;\n\t\t\tif (rx_isr & UDMA_INTR_RX_TIMEOUT) {\n\t\t\t\tpriv->rx_timeout++;\n\t\t\t\tdev_err(dev, \"RX TIMEOUT Error\\n\");\n\t\t\t}\n\t\t\tif (rx_isr & UDMA_INTR_RX_ABORT)\n\t\t\t\tpriv->rx_abort++;\n\t\t\tpriv->rx_running = false;\n\t\t}\n\t\t \n\t\tif (!(rx_isr & UDMA_INTR_RX_ABORT))\n\t\t\tudma_unset(priv, REGS_DMA_RX,\n\t\t\t\t   UDMA_RX_BUFx_STATUS(priv->rx_next_buf),\n\t\t\t\t   UDMA_RX_BUFX_STATUS_DATA_RDY);\n\t\trx_done_isr &= ~check_isr;\n\t\tpriv->rx_next_buf++;\n\t\tif (priv->rx_next_buf == RX_BUFS_COUNT)\n\t\t\tpriv->rx_next_buf = 0;\n\t}\n}\n\nstatic void brcmuart_tx_isr(struct uart_port *up, u32 isr)\n{\n\tstruct brcmuart_priv *priv = up->private_data;\n\tstruct device *dev = up->dev;\n\tstruct uart_8250_port *port_8250 = up_to_u8250p(up);\n\tstruct circ_buf\t*xmit = &port_8250->port.state->xmit;\n\n\tif (isr & UDMA_INTR_TX_ABORT) {\n\t\tif (priv->tx_running)\n\t\t\tdev_err(dev, \"Unexpected TX_ABORT interrupt\\n\");\n\t\treturn;\n\t}\n\tpriv->tx_running = false;\n\tif (!uart_circ_empty(xmit) && !uart_tx_stopped(up))\n\t\tbrcmuart_tx_dma(port_8250);\n}\n\nstatic irqreturn_t brcmuart_isr(int irq, void *dev_id)\n{\n\tstruct uart_port *up = dev_id;\n\tstruct device *dev = up->dev;\n\tstruct brcmuart_priv *priv = up->private_data;\n\tunsigned long flags;\n\tu32 interrupts;\n\tu32 rval;\n\tu32 tval;\n\n\tinterrupts = udma_readl(priv, REGS_DMA_ISR, UDMA_INTR_STATUS);\n\tif (interrupts == 0)\n\t\treturn IRQ_NONE;\n\n\tspin_lock_irqsave(&up->lock, flags);\n\n\t \n\tudma_writel(priv, REGS_DMA_ISR, UDMA_INTR_CLEAR, interrupts);\n\n\trval = UDMA_IS_RX_INTERRUPT(interrupts);\n\tif (rval)\n\t\tbrcmuart_rx_isr(up, rval);\n\ttval = UDMA_IS_TX_INTERRUPT(interrupts);\n\tif (tval)\n\t\tbrcmuart_tx_isr(up, tval);\n\tif ((rval | tval) == 0)\n\t\tdev_warn(dev, \"Spurious interrupt: 0x%x\\n\", interrupts);\n\n\tspin_unlock_irqrestore(&up->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int brcmuart_startup(struct uart_port *port)\n{\n\tint res;\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct brcmuart_priv *priv = up->port.private_data;\n\n\tpriv->shutdown = false;\n\n\t \n\tup->dma = NULL;\n\n\tres = serial8250_do_startup(port);\n\tif (!priv->dma_enabled)\n\t\treturn res;\n\t \n\tspin_lock_irq(&port->lock);\n\tup->ier &= ~UART_IER_RDI;\n\tserial_port_out(port, UART_IER, up->ier);\n\tspin_unlock_irq(&port->lock);\n\n\tpriv->tx_running = false;\n\tpriv->dma.rx_dma = NULL;\n\tpriv->dma.tx_dma = brcmuart_tx_dma;\n\tup->dma = &priv->dma;\n\n\tbrcmuart_init_dma_hardware(priv);\n\tstart_rx_dma(up);\n\treturn res;\n}\n\nstatic void brcmuart_shutdown(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct brcmuart_priv *priv = up->port.private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tpriv->shutdown = true;\n\tif (priv->dma_enabled) {\n\t\tstop_rx_dma(up);\n\t\tstop_tx_dma(up);\n\t\t \n\t\tudma_writel(priv, REGS_DMA_ISR, UDMA_INTR_MASK_SET,\n\t\t\tUDMA_RX_INTERRUPTS | UDMA_TX_INTERRUPTS);\n\t}\n\n\t \n\tup->dma = NULL;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tserial8250_do_shutdown(port);\n}\n\n \nstatic void init_real_clk_rates(struct device *dev, struct brcmuart_priv *priv)\n{\n\tint x;\n\tint rc;\n\n\tpriv->default_mux_rate = clk_get_rate(priv->baud_mux_clk);\n\tfor (x = 0; x < ARRAY_SIZE(priv->real_rates); x++) {\n\t\tif (priv->rate_table[x] == 0) {\n\t\t\tpriv->real_rates[x] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\trc = clk_set_rate(priv->baud_mux_clk, priv->rate_table[x]);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Error selecting BAUD MUX clock for %u\\n\",\n\t\t\t\tpriv->rate_table[x]);\n\t\t\tpriv->real_rates[x] = priv->rate_table[x];\n\t\t} else {\n\t\t\tpriv->real_rates[x] = clk_get_rate(priv->baud_mux_clk);\n\t\t}\n\t}\n\tclk_set_rate(priv->baud_mux_clk, priv->default_mux_rate);\n}\n\nstatic void set_clock_mux(struct uart_port *up, struct brcmuart_priv *priv,\n\t\t\tu32 baud)\n{\n\tu32 percent;\n\tu32 best_percent = UINT_MAX;\n\tu32 quot;\n\tu32 best_quot = 1;\n\tu32 rate;\n\tint best_index = -1;\n\tu64 hires_rate;\n\tu64 hires_baud;\n\tu64 hires_err;\n\tint rc;\n\tint i;\n\tint real_baud;\n\n\t \n\tif (priv->baud_mux_clk == NULL)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(priv->real_rates); i++) {\n\t\tif (priv->real_rates[i] == 0)\n\t\t\tcontinue;\n\t\trate = priv->real_rates[i] / 16;\n\t\tquot = DIV_ROUND_CLOSEST(rate, baud);\n\t\tif (!quot)\n\t\t\tcontinue;\n\n\t\t \n\t\thires_rate = (u64)rate * 10000;\n\t\thires_baud = (u64)baud * 10000;\n\n\t\thires_err = div_u64(hires_rate, (u64)quot);\n\n\t\t \n\t\tif (hires_err > hires_baud)\n\t\t\thires_err = (hires_err - hires_baud);\n\t\telse\n\t\t\thires_err = (hires_baud - hires_err);\n\n\t\tpercent = (unsigned long)DIV_ROUND_CLOSEST_ULL(hires_err, baud);\n\t\tdev_dbg(up->dev,\n\t\t\t\"Baud rate: %u, MUX Clk: %u, Error: %u.%u%%\\n\",\n\t\t\tbaud, priv->real_rates[i], percent / 100,\n\t\t\tpercent % 100);\n\t\tif (percent < best_percent) {\n\t\t\tbest_percent = percent;\n\t\t\tbest_index = i;\n\t\t\tbest_quot = quot;\n\t\t}\n\t}\n\tif (best_index == -1) {\n\t\tdev_err(up->dev, \"Error, %d BAUD rate is too fast.\\n\", baud);\n\t\treturn;\n\t}\n\trate = priv->real_rates[best_index];\n\trc = clk_set_rate(priv->baud_mux_clk, rate);\n\tif (rc)\n\t\tdev_err(up->dev, \"Error selecting BAUD MUX clock\\n\");\n\n\t \n\tif (best_percent > 300)\n\t\tdev_err(up->dev, \"Error, baud: %d has %u.%u%% error\\n\",\n\t\t\tbaud, percent / 100, percent % 100);\n\n\treal_baud = rate / 16 / best_quot;\n\tdev_dbg(up->dev, \"Selecting BAUD MUX rate: %u\\n\", rate);\n\tdev_dbg(up->dev, \"Requested baud: %u, Actual baud: %u\\n\",\n\t\tbaud, real_baud);\n\n\t \n\ti = NSEC_PER_SEC / real_baud / 10;\n\ti += (i / 2);\n\tpriv->char_wait = ns_to_ktime(i);\n\n\tup->uartclk = rate;\n}\n\nstatic void brcmstb_set_termios(struct uart_port *up,\n\t\t\t\tstruct ktermios *termios,\n\t\t\t\tconst struct ktermios *old)\n{\n\tstruct uart_8250_port *p8250 = up_to_u8250p(up);\n\tstruct brcmuart_priv *priv = up->private_data;\n\n\tif (priv->dma_enabled)\n\t\tstop_rx_dma(p8250);\n\tset_clock_mux(up, priv, tty_termios_baud_rate(termios));\n\tserial8250_do_set_termios(up, termios, old);\n\tif (p8250->mcr & UART_MCR_AFE)\n\t\tp8250->port.status |= UPSTAT_AUTOCTS;\n\tif (priv->dma_enabled)\n\t\tstart_rx_dma(p8250);\n}\n\nstatic int brcmuart_handle_irq(struct uart_port *p)\n{\n\tunsigned int iir = serial_port_in(p, UART_IIR);\n\tstruct brcmuart_priv *priv = p->private_data;\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\tunsigned int status;\n\tunsigned long flags;\n\tunsigned int ier;\n\tunsigned int mcr;\n\tint handled = 0;\n\n\t \n\tif (((iir & UART_IIR_ID) == UART_IIR_RX_TIMEOUT) && !(priv->shutdown)) {\n\t\tspin_lock_irqsave(&p->lock, flags);\n\t\tstatus = serial_port_in(p, UART_LSR);\n\t\tif ((status & UART_LSR_DR) == 0) {\n\n\t\t\tier = serial_port_in(p, UART_IER);\n\t\t\t \n\t\t\tif ((ier & UART_IER_RDI) && (up->mcr & UART_MCR_AFE)) {\n\t\t\t\tier &= ~(UART_IER_RLSI | UART_IER_RDI);\n\t\t\t\tserial_port_out(p, UART_IER, ier);\n\t\t\t\tmcr = serial_port_in(p, UART_MCR);\n\t\t\t\tmcr &= ~UART_MCR_RTS;\n\t\t\t\tserial_port_out(p, UART_MCR, mcr);\n\t\t\t\thrtimer_start(&priv->hrt, priv->char_wait,\n\t\t\t\t\t      HRTIMER_MODE_REL);\n\t\t\t} else {\n\t\t\t\tserial_port_in(p, UART_RX);\n\t\t\t}\n\n\t\t\thandled = 1;\n\t\t}\n\t\tspin_unlock_irqrestore(&p->lock, flags);\n\t\tif (handled)\n\t\t\treturn 1;\n\t}\n\treturn serial8250_handle_irq(p, iir);\n}\n\nstatic enum hrtimer_restart brcmuart_hrtimer_func(struct hrtimer *t)\n{\n\tstruct brcmuart_priv *priv = container_of(t, struct brcmuart_priv, hrt);\n\tstruct uart_port *p = priv->up;\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\tunsigned int status;\n\tunsigned long flags;\n\n\tif (priv->shutdown)\n\t\treturn HRTIMER_NORESTART;\n\n\tspin_lock_irqsave(&p->lock, flags);\n\tstatus = serial_port_in(p, UART_LSR);\n\n\t \n\tif ((status & UART_LSR_DR) == 0) {\n\t\tserial_port_in(p, UART_RX);\n\t\tpriv->rx_bad_timeout_no_char++;\n\t} else {\n\t\tpriv->rx_bad_timeout_late_char++;\n\t}\n\n\t \n\tif ((up->ier & (UART_IER_RLSI | UART_IER_RDI)) ==\n\t    (UART_IER_RLSI | UART_IER_RDI)) {\n\t\tstatus = serial_port_in(p, UART_IER);\n\t\tstatus |= (UART_IER_RLSI | UART_IER_RDI);\n\t\tserial_port_out(p, UART_IER, status);\n\t\tstatus = serial_port_in(p, UART_MCR);\n\t\tstatus |= UART_MCR_RTS;\n\t\tserial_port_out(p, UART_MCR, status);\n\t}\n\tspin_unlock_irqrestore(&p->lock, flags);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic const struct of_device_id brcmuart_dt_ids[] = {\n\t{\n\t\t.compatible = \"brcm,bcm7278-uart\",\n\t\t.data = brcmstb_rate_table_7278,\n\t},\n\t{\n\t\t.compatible = \"brcm,bcm7271-uart\",\n\t\t.data = brcmstb_rate_table,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, brcmuart_dt_ids);\n\nstatic void brcmuart_free_bufs(struct device *dev, struct brcmuart_priv *priv)\n{\n\tif (priv->rx_bufs)\n\t\tdma_free_coherent(dev, priv->rx_size, priv->rx_bufs,\n\t\t\t\t  priv->rx_addr);\n\tif (priv->tx_buf)\n\t\tdma_free_coherent(dev, priv->tx_size, priv->tx_buf,\n\t\t\t\t  priv->tx_addr);\n}\n\nstatic void brcmuart_throttle(struct uart_port *port)\n{\n\tstruct brcmuart_priv *priv = port->private_data;\n\n\tudma_writel(priv, REGS_DMA_ISR, UDMA_INTR_MASK_SET, UDMA_RX_INTERRUPTS);\n}\n\nstatic void brcmuart_unthrottle(struct uart_port *port)\n{\n\tstruct brcmuart_priv *priv = port->private_data;\n\n\tudma_writel(priv, REGS_DMA_ISR, UDMA_INTR_MASK_CLEAR,\n\t\t    UDMA_RX_INTERRUPTS);\n}\n\nstatic int debugfs_stats_show(struct seq_file *s, void *unused)\n{\n\tstruct brcmuart_priv *priv = s->private;\n\n\tseq_printf(s, \"rx_err:\\t\\t\\t\\t%u\\n\",\n\t\t   priv->rx_err);\n\tseq_printf(s, \"rx_timeout:\\t\\t\\t%u\\n\",\n\t\t   priv->rx_timeout);\n\tseq_printf(s, \"rx_abort:\\t\\t\\t%u\\n\",\n\t\t   priv->rx_abort);\n\tseq_printf(s, \"rx_bad_timeout_late_char:\\t%u\\n\",\n\t\t   priv->rx_bad_timeout_late_char);\n\tseq_printf(s, \"rx_bad_timeout_no_char:\\t\\t%u\\n\",\n\t\t   priv->rx_bad_timeout_no_char);\n\tseq_printf(s, \"rx_missing_close_timeout:\\t%u\\n\",\n\t\t   priv->rx_missing_close_timeout);\n\tif (priv->dma_enabled) {\n\t\tseq_printf(s, \"dma_rx_partial_buf:\\t\\t%llu\\n\",\n\t\t\t   priv->dma_rx_partial_buf);\n\t\tseq_printf(s, \"dma_rx_full_buf:\\t\\t%llu\\n\",\n\t\t\t   priv->dma_rx_full_buf);\n\t}\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_stats);\n\nstatic void brcmuart_init_debugfs(struct brcmuart_priv *priv,\n\t\t\t\t  const char *device)\n{\n\tpriv->debugfs_dir = debugfs_create_dir(device, brcmuart_debugfs_root);\n\tdebugfs_create_file(\"stats\", 0444, priv->debugfs_dir, priv,\n\t\t\t    &debugfs_stats_fops);\n}\n\n\nstatic int brcmuart_probe(struct platform_device *pdev)\n{\n\tstruct resource *regs;\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *of_id = NULL;\n\tstruct uart_8250_port *new_port;\n\tstruct device *dev = &pdev->dev;\n\tstruct brcmuart_priv *priv;\n\tstruct clk *baud_mux_clk;\n\tstruct uart_8250_port up;\n\tint irq;\n\tvoid __iomem *membase = NULL;\n\tresource_size_t mapbase = 0;\n\tu32 clk_rate = 0;\n\tint ret;\n\tint x;\n\tint dma_irq;\n\tstatic const char * const reg_names[REGS_MAX] = {\n\t\t\"uart\", \"dma_rx\", \"dma_tx\", \"dma_intr2\", \"dma_arb\"\n\t};\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tpriv = devm_kzalloc(dev, sizeof(struct brcmuart_priv),\n\t\t\tGFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_node(brcmuart_dt_ids, np);\n\tif (!of_id || !of_id->data)\n\t\tpriv->rate_table = brcmstb_rate_table;\n\telse\n\t\tpriv->rate_table = of_id->data;\n\n\tfor (x = 0; x < REGS_MAX; x++) {\n\t\tregs = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\treg_names[x]);\n\t\tif (!regs)\n\t\t\tbreak;\n\t\tpriv->regs[x] =\tdevm_ioremap(dev, regs->start,\n\t\t\t\t\t     resource_size(regs));\n\t\tif (!priv->regs[x])\n\t\t\treturn -ENOMEM;\n\t\tif (x == REGS_8250) {\n\t\t\tmapbase = regs->start;\n\t\t\tmembase = priv->regs[x];\n\t\t}\n\t}\n\n\t \n\tif (x != 1 && x != REGS_MAX) {\n\t\tdev_warn(dev, \"%s registers not specified\\n\", reg_names[x]);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (x > REGS_DMA_RX) {\n\t\tif (brcmuart_arbitration(priv, 1) == 0) {\n\t\t\tu32 txrev = 0;\n\t\t\tu32 rxrev = 0;\n\n\t\t\ttxrev = udma_readl(priv, REGS_DMA_RX, UDMA_RX_REVISION);\n\t\t\trxrev = udma_readl(priv, REGS_DMA_TX, UDMA_TX_REVISION);\n\t\t\tif ((txrev >= UDMA_TX_REVISION_REQUIRED) &&\n\t\t\t\t(rxrev >= UDMA_RX_REVISION_REQUIRED)) {\n\n\t\t\t\t \n\t\t\t\tpriv->dma_enabled = true;\n\t\t\t} else {\n\t\t\t\tbrcmuart_arbitration(priv, 0);\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Unsupported DMA Hardware Revision\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Timeout arbitrating for UART DMA hardware\\n\");\n\t\t}\n\t}\n\n\tof_property_read_u32(np, \"clock-frequency\", &clk_rate);\n\n\t \n\tbaud_mux_clk = devm_clk_get(dev, \"sw_baud\");\n\tif (IS_ERR(baud_mux_clk)) {\n\t\tif (PTR_ERR(baud_mux_clk) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto release_dma;\n\t\t}\n\t\tdev_dbg(dev, \"BAUD MUX clock not specified\\n\");\n\t} else {\n\t\tdev_dbg(dev, \"BAUD MUX clock found\\n\");\n\t\tret = clk_prepare_enable(baud_mux_clk);\n\t\tif (ret)\n\t\t\tgoto release_dma;\n\t\tpriv->baud_mux_clk = baud_mux_clk;\n\t\tinit_real_clk_rates(dev, priv);\n\t\tclk_rate = priv->default_mux_rate;\n\t}\n\n\tif (clk_rate == 0) {\n\t\tdev_err(dev, \"clock-frequency or clk not defined\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\tdev_dbg(dev, \"DMA is %senabled\\n\", priv->dma_enabled ? \"\" : \"not \");\n\n\tmemset(&up, 0, sizeof(up));\n\tup.port.type = PORT_BCM7271;\n\tup.port.uartclk = clk_rate;\n\tup.port.dev = dev;\n\tup.port.mapbase = mapbase;\n\tup.port.membase = membase;\n\tup.port.irq = irq;\n\tup.port.handle_irq = brcmuart_handle_irq;\n\tup.port.regshift = 2;\n\tup.port.iotype = of_device_is_big_endian(np) ?\n\t\tUPIO_MEM32BE : UPIO_MEM32;\n\tup.port.flags = UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF\n\t\t| UPF_FIXED_PORT | UPF_FIXED_TYPE;\n\tup.port.dev = dev;\n\tup.port.private_data = priv;\n\n\t \n\tret = of_alias_get_id(np, \"serial\");\n\tif (ret >= 0)\n\t\tup.port.line = ret;\n\n\t \n\thrtimer_init(&priv->hrt, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpriv->hrt.function = brcmuart_hrtimer_func;\n\n\tup.port.shutdown = brcmuart_shutdown;\n\tup.port.startup = brcmuart_startup;\n\tup.port.throttle = brcmuart_throttle;\n\tup.port.unthrottle = brcmuart_unthrottle;\n\tup.port.set_termios = brcmstb_set_termios;\n\n\tif (priv->dma_enabled) {\n\t\tpriv->rx_size = RX_BUF_SIZE * RX_BUFS_COUNT;\n\t\tpriv->rx_bufs = dma_alloc_coherent(dev,\n\t\t\t\t\t\t   priv->rx_size,\n\t\t\t\t\t\t   &priv->rx_addr, GFP_KERNEL);\n\t\tif (!priv->rx_bufs) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tpriv->tx_size = UART_XMIT_SIZE;\n\t\tpriv->tx_buf = dma_alloc_coherent(dev,\n\t\t\t\t\t\t  priv->tx_size,\n\t\t\t\t\t\t  &priv->tx_addr, GFP_KERNEL);\n\t\tif (!priv->tx_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = serial8250_register_8250_port(&up);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to register 8250 port\\n\");\n\t\tgoto err;\n\t}\n\tpriv->line = ret;\n\tnew_port = serial8250_get_port(ret);\n\tpriv->up = &new_port->port;\n\tif (priv->dma_enabled) {\n\t\tdma_irq = platform_get_irq_byname(pdev,  \"dma\");\n\t\tif (dma_irq < 0) {\n\t\t\tret = dma_irq;\n\t\t\tdev_err(dev, \"no IRQ resource info\\n\");\n\t\t\tgoto err1;\n\t\t}\n\t\tret = devm_request_irq(dev, dma_irq, brcmuart_isr,\n\t\t\t\tIRQF_SHARED, \"uart DMA irq\", &new_port->port);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"unable to register IRQ handler\\n\");\n\t\t\tgoto err1;\n\t\t}\n\t}\n\tplatform_set_drvdata(pdev, priv);\n\tbrcmuart_init_debugfs(priv, dev_name(&pdev->dev));\n\treturn 0;\n\nerr1:\n\tserial8250_unregister_port(priv->line);\nerr:\n\tbrcmuart_free_bufs(dev, priv);\nerr_clk_disable:\n\tclk_disable_unprepare(baud_mux_clk);\nrelease_dma:\n\tif (priv->dma_enabled)\n\t\tbrcmuart_arbitration(priv, 0);\n\treturn ret;\n}\n\nstatic int brcmuart_remove(struct platform_device *pdev)\n{\n\tstruct brcmuart_priv *priv = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(priv->debugfs_dir);\n\thrtimer_cancel(&priv->hrt);\n\tserial8250_unregister_port(priv->line);\n\tbrcmuart_free_bufs(&pdev->dev, priv);\n\tclk_disable_unprepare(priv->baud_mux_clk);\n\tif (priv->dma_enabled)\n\t\tbrcmuart_arbitration(priv, 0);\n\treturn 0;\n}\n\nstatic int __maybe_unused brcmuart_suspend(struct device *dev)\n{\n\tstruct brcmuart_priv *priv = dev_get_drvdata(dev);\n\tstruct uart_8250_port *up = serial8250_get_port(priv->line);\n\tstruct uart_port *port = &up->port;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tpriv->saved_mctrl = port->mctrl;\n\tport->mctrl &= ~TIOCM_RTS;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tserial8250_suspend_port(priv->line);\n\tclk_disable_unprepare(priv->baud_mux_clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused brcmuart_resume(struct device *dev)\n{\n\tstruct brcmuart_priv *priv = dev_get_drvdata(dev);\n\tstruct uart_8250_port *up = serial8250_get_port(priv->line);\n\tstruct uart_port *port = &up->port;\n\tunsigned long flags;\n\tint ret;\n\n\tret = clk_prepare_enable(priv->baud_mux_clk);\n\tif (ret)\n\t\tdev_err(dev, \"Error enabling BAUD MUX clock\\n\");\n\n\t \n\tret = clk_set_rate(priv->baud_mux_clk, priv->default_mux_rate);\n\tif (ret)\n\t\tdev_err(dev, \"Error restoring default BAUD MUX clock\\n\");\n\tif (priv->dma_enabled) {\n\t\tif (brcmuart_arbitration(priv, 1)) {\n\t\t\tdev_err(dev, \"Timeout arbitrating for DMA hardware on resume\\n\");\n\t\t\treturn(-EBUSY);\n\t\t}\n\t\tbrcmuart_init_dma_hardware(priv);\n\t\tstart_rx_dma(serial8250_get_port(priv->line));\n\t}\n\tserial8250_resume_port(priv->line);\n\n\tif (priv->saved_mctrl & TIOCM_RTS) {\n\t\t \n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->mctrl |= TIOCM_RTS;\n\t\tport->ops->set_mctrl(port, port->mctrl);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops brcmuart_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(brcmuart_suspend, brcmuart_resume)\n};\n\nstatic struct platform_driver brcmuart_platform_driver = {\n\t.driver = {\n\t\t.name\t= \"bcm7271-uart\",\n\t\t.pm\t\t= &brcmuart_dev_pm_ops,\n\t\t.of_match_table = brcmuart_dt_ids,\n\t},\n\t.probe\t\t= brcmuart_probe,\n\t.remove\t\t= brcmuart_remove,\n};\n\nstatic int __init brcmuart_init(void)\n{\n\tint ret;\n\n\tbrcmuart_debugfs_root = debugfs_create_dir(\n\t\tbrcmuart_platform_driver.driver.name, NULL);\n\tret = platform_driver_register(&brcmuart_platform_driver);\n\tif (ret) {\n\t\tdebugfs_remove_recursive(brcmuart_debugfs_root);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(brcmuart_init);\n\nstatic void __exit brcmuart_deinit(void)\n{\n\tplatform_driver_unregister(&brcmuart_platform_driver);\n\tdebugfs_remove_recursive(brcmuart_debugfs_root);\n}\nmodule_exit(brcmuart_deinit);\n\nMODULE_AUTHOR(\"Al Cooper\");\nMODULE_DESCRIPTION(\"Broadcom NS16550A compatible serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}