{
  "module_name": "8250_lpss.c",
  "hash_id": "c84589d7b91099afd83dfa4955c61c8db7ba791a16f838f8673d6703f44fd08b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_lpss.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/rational.h>\n\n#include <linux/dmaengine.h>\n#include <linux/dma/dw.h>\n\n#include \"8250_dwlib.h\"\n\n#define PCI_DEVICE_ID_INTEL_QRK_UARTx\t0x0936\n\n#define PCI_DEVICE_ID_INTEL_BYT_UART1\t0x0f0a\n#define PCI_DEVICE_ID_INTEL_BYT_UART2\t0x0f0c\n\n#define PCI_DEVICE_ID_INTEL_BSW_UART1\t0x228a\n#define PCI_DEVICE_ID_INTEL_BSW_UART2\t0x228c\n\n#define PCI_DEVICE_ID_INTEL_EHL_UART0\t0x4b96\n#define PCI_DEVICE_ID_INTEL_EHL_UART1\t0x4b97\n#define PCI_DEVICE_ID_INTEL_EHL_UART2\t0x4b98\n#define PCI_DEVICE_ID_INTEL_EHL_UART3\t0x4b99\n#define PCI_DEVICE_ID_INTEL_EHL_UART4\t0x4b9a\n#define PCI_DEVICE_ID_INTEL_EHL_UART5\t0x4b9b\n\n#define PCI_DEVICE_ID_INTEL_BDW_UART1\t0x9ce3\n#define PCI_DEVICE_ID_INTEL_BDW_UART2\t0x9ce4\n\n \n\n#define BYT_PRV_CLK\t\t\t0x800\n#define BYT_PRV_CLK_EN\t\t\tBIT(0)\n#define BYT_PRV_CLK_M_VAL_SHIFT\t\t1\n#define BYT_PRV_CLK_N_VAL_SHIFT\t\t16\n#define BYT_PRV_CLK_UPDATE\t\tBIT(31)\n\n#define BYT_TX_OVF_INT\t\t\t0x820\n#define BYT_TX_OVF_INT_MASK\t\tBIT(1)\n\nstruct lpss8250;\n\nstruct lpss8250_board {\n\tunsigned long freq;\n\tunsigned int base_baud;\n\tint (*setup)(struct lpss8250 *, struct uart_port *p);\n\tvoid (*exit)(struct lpss8250 *);\n};\n\nstruct lpss8250 {\n\tstruct dw8250_port_data data;\n\tstruct lpss8250_board *board;\n\n\t \n\tstruct dw_dma_chip dma_chip;\n\tstruct dw_dma_slave dma_param;\n\tu8 dma_maxburst;\n};\n\nstatic inline struct lpss8250 *to_lpss8250(struct dw8250_port_data *data)\n{\n\treturn container_of(data, struct lpss8250, data);\n}\n\nstatic void byt_set_termios(struct uart_port *p, struct ktermios *termios,\n\t\t\t    const struct ktermios *old)\n{\n\tunsigned int baud = tty_termios_baud_rate(termios);\n\tstruct lpss8250 *lpss = to_lpss8250(p->private_data);\n\tunsigned long fref = lpss->board->freq, fuart = baud * 16;\n\tunsigned long w = BIT(15) - 1;\n\tunsigned long m, n;\n\tu32 reg;\n\n\t \n\tfuart = fuart ? fuart : 9600 * 16;\n\n\t \n\tfuart *= rounddown_pow_of_two(fref / fuart);\n\n\t \n\trational_best_approximation(fuart, fref, w, w, &m, &n);\n\tp->uartclk = fuart;\n\n\t \n\treg = (m << BYT_PRV_CLK_M_VAL_SHIFT) | (n << BYT_PRV_CLK_N_VAL_SHIFT);\n\twritel(reg, p->membase + BYT_PRV_CLK);\n\treg |= BYT_PRV_CLK_EN | BYT_PRV_CLK_UPDATE;\n\twritel(reg, p->membase + BYT_PRV_CLK);\n\n\tdw8250_do_set_termios(p, termios, old);\n}\n\nstatic unsigned int byt_get_mctrl(struct uart_port *port)\n{\n\tunsigned int ret = serial8250_do_get_mctrl(port);\n\n\t \n\tret |= TIOCM_CAR | TIOCM_DSR;\n\n\treturn ret;\n}\n\nstatic int byt_serial_setup(struct lpss8250 *lpss, struct uart_port *port)\n{\n\tstruct dw_dma_slave *param = &lpss->dma_param;\n\tstruct pci_dev *pdev = to_pci_dev(port->dev);\n\tstruct pci_dev *dma_dev;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_BYT_UART1:\n\tcase PCI_DEVICE_ID_INTEL_BSW_UART1:\n\tcase PCI_DEVICE_ID_INTEL_BDW_UART1:\n\t\tparam->src_id = 3;\n\t\tparam->dst_id = 2;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_INTEL_BYT_UART2:\n\tcase PCI_DEVICE_ID_INTEL_BSW_UART2:\n\tcase PCI_DEVICE_ID_INTEL_BDW_UART2:\n\t\tparam->src_id = 5;\n\t\tparam->dst_id = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdma_dev = pci_get_slot(pdev->bus, PCI_DEVFN(PCI_SLOT(pdev->devfn), 0));\n\n\tparam->dma_dev = &dma_dev->dev;\n\tparam->m_master = 0;\n\tparam->p_master = 1;\n\n\tlpss->dma_maxburst = 16;\n\n\tport->set_termios = byt_set_termios;\n\tport->get_mctrl = byt_get_mctrl;\n\n\t \n\twritel(BYT_TX_OVF_INT_MASK, port->membase + BYT_TX_OVF_INT);\n\n\treturn 0;\n}\n\nstatic void byt_serial_exit(struct lpss8250 *lpss)\n{\n\tstruct dw_dma_slave *param = &lpss->dma_param;\n\n\t \n\tput_device(param->dma_dev);\n}\n\nstatic int ehl_serial_setup(struct lpss8250 *lpss, struct uart_port *port)\n{\n\tstruct uart_8250_dma *dma = &lpss->data.dma;\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\t \n\tup->dma = dma;\n\n\tlpss->dma_maxburst = 16;\n\n\tport->set_termios = dw8250_do_set_termios;\n\n\treturn 0;\n}\n\nstatic void ehl_serial_exit(struct lpss8250 *lpss)\n{\n\tstruct uart_8250_port *up = serial8250_get_port(lpss->data.line);\n\n\tup->dma = NULL;\n}\n\n#ifdef CONFIG_SERIAL_8250_DMA\nstatic const struct dw_dma_platform_data qrk_serial_dma_pdata = {\n\t.nr_channels = 2,\n\t.chan_allocation_order = CHAN_ALLOCATION_ASCENDING,\n\t.chan_priority = CHAN_PRIORITY_ASCENDING,\n\t.block_size = 4095,\n\t.nr_masters = 1,\n\t.data_width = {4},\n\t.multi_block = {0},\n};\n\nstatic void qrk_serial_setup_dma(struct lpss8250 *lpss, struct uart_port *port)\n{\n\tstruct uart_8250_dma *dma = &lpss->data.dma;\n\tstruct dw_dma_chip *chip = &lpss->dma_chip;\n\tstruct dw_dma_slave *param = &lpss->dma_param;\n\tstruct pci_dev *pdev = to_pci_dev(port->dev);\n\tint ret;\n\n\tchip->pdata = &qrk_serial_dma_pdata;\n\tchip->dev = &pdev->dev;\n\tchip->id = pdev->devfn;\n\tchip->irq = pci_irq_vector(pdev, 0);\n\tchip->regs = pci_ioremap_bar(pdev, 1);\n\tif (!chip->regs)\n\t\treturn;\n\n\t \n\tret = dw_dma_probe(chip);\n\tif (ret)\n\t\treturn;\n\n\tpci_try_set_mwi(pdev);\n\n\t \n\tdma->rx_dma_addr = 0xfffff000;\n\tdma->tx_dma_addr = 0xfffff000;\n\n\tparam->dma_dev = &pdev->dev;\n\tparam->src_id = 0;\n\tparam->dst_id = 1;\n\tparam->hs_polarity = true;\n\n\tlpss->dma_maxburst = 8;\n}\n\nstatic void qrk_serial_exit_dma(struct lpss8250 *lpss)\n{\n\tstruct dw_dma_chip *chip = &lpss->dma_chip;\n\tstruct dw_dma_slave *param = &lpss->dma_param;\n\n\tif (!param->dma_dev)\n\t\treturn;\n\n\tdw_dma_remove(chip);\n\n\tpci_iounmap(to_pci_dev(chip->dev), chip->regs);\n}\n#else\t \nstatic void qrk_serial_setup_dma(struct lpss8250 *lpss, struct uart_port *port) {}\nstatic void qrk_serial_exit_dma(struct lpss8250 *lpss) {}\n#endif\t \n\nstatic int qrk_serial_setup(struct lpss8250 *lpss, struct uart_port *port)\n{\n\tqrk_serial_setup_dma(lpss, port);\n\treturn 0;\n}\n\nstatic void qrk_serial_exit(struct lpss8250 *lpss)\n{\n\tqrk_serial_exit_dma(lpss);\n}\n\nstatic bool lpss8250_dma_filter(struct dma_chan *chan, void *param)\n{\n\tstruct dw_dma_slave *dws = param;\n\n\tif (dws->dma_dev != chan->device->dev)\n\t\treturn false;\n\n\tchan->private = dws;\n\treturn true;\n}\n\nstatic int lpss8250_dma_setup(struct lpss8250 *lpss, struct uart_8250_port *port)\n{\n\tstruct uart_8250_dma *dma = &lpss->data.dma;\n\tstruct dw_dma_slave *rx_param, *tx_param;\n\tstruct device *dev = port->port.dev;\n\n\tif (!lpss->dma_param.dma_dev) {\n\t\tdma = port->dma;\n\t\tif (dma)\n\t\t\tgoto out_configuration_only;\n\n\t\treturn 0;\n\t}\n\n\trx_param = devm_kzalloc(dev, sizeof(*rx_param), GFP_KERNEL);\n\tif (!rx_param)\n\t\treturn -ENOMEM;\n\n\ttx_param = devm_kzalloc(dev, sizeof(*tx_param), GFP_KERNEL);\n\tif (!tx_param)\n\t\treturn -ENOMEM;\n\n\t*rx_param = lpss->dma_param;\n\t*tx_param = lpss->dma_param;\n\n\tdma->fn = lpss8250_dma_filter;\n\tdma->rx_param = rx_param;\n\tdma->tx_param = tx_param;\n\n\tport->dma = dma;\n\nout_configuration_only:\n\tdma->rxconf.src_maxburst = lpss->dma_maxburst;\n\tdma->txconf.dst_maxburst = lpss->dma_maxburst;\n\n\treturn 0;\n}\n\nstatic int lpss8250_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct uart_8250_port uart;\n\tstruct lpss8250 *lpss;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\tlpss = devm_kzalloc(&pdev->dev, sizeof(*lpss), GFP_KERNEL);\n\tif (!lpss)\n\t\treturn -ENOMEM;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlpss->board = (struct lpss8250_board *)id->driver_data;\n\n\tmemset(&uart, 0, sizeof(struct uart_8250_port));\n\n\tuart.port.dev = &pdev->dev;\n\tuart.port.irq = pci_irq_vector(pdev, 0);\n\tuart.port.private_data = &lpss->data;\n\tuart.port.type = PORT_16550A;\n\tuart.port.iotype = UPIO_MEM32;\n\tuart.port.regshift = 2;\n\tuart.port.uartclk = lpss->board->base_baud * 16;\n\tuart.port.flags = UPF_SHARE_IRQ | UPF_FIXED_PORT | UPF_FIXED_TYPE;\n\tuart.capabilities = UART_CAP_FIFO | UART_CAP_AFE;\n\tuart.port.mapbase = pci_resource_start(pdev, 0);\n\tuart.port.membase = pcim_iomap(pdev, 0, 0);\n\tif (!uart.port.membase)\n\t\treturn -ENOMEM;\n\n\tret = lpss->board->setup(lpss, &uart.port);\n\tif (ret)\n\t\treturn ret;\n\n\tdw8250_setup_port(&uart.port);\n\n\tret = lpss8250_dma_setup(lpss, &uart);\n\tif (ret)\n\t\tgoto err_exit;\n\n\tret = serial8250_register_8250_port(&uart);\n\tif (ret < 0)\n\t\tgoto err_exit;\n\n\tlpss->data.line = ret;\n\n\tpci_set_drvdata(pdev, lpss);\n\treturn 0;\n\nerr_exit:\n\tlpss->board->exit(lpss);\n\tpci_free_irq_vectors(pdev);\n\treturn ret;\n}\n\nstatic void lpss8250_remove(struct pci_dev *pdev)\n{\n\tstruct lpss8250 *lpss = pci_get_drvdata(pdev);\n\n\tserial8250_unregister_port(lpss->data.line);\n\n\tlpss->board->exit(lpss);\n\tpci_free_irq_vectors(pdev);\n}\n\nstatic const struct lpss8250_board byt_board = {\n\t.freq = 100000000,\n\t.base_baud = 2764800,\n\t.setup = byt_serial_setup,\n\t.exit = byt_serial_exit,\n};\n\nstatic const struct lpss8250_board ehl_board = {\n\t.freq = 200000000,\n\t.base_baud = 12500000,\n\t.setup = ehl_serial_setup,\n\t.exit = ehl_serial_exit,\n};\n\nstatic const struct lpss8250_board qrk_board = {\n\t.freq = 44236800,\n\t.base_baud = 2764800,\n\t.setup = qrk_serial_setup,\n\t.exit = qrk_serial_exit,\n};\n\nstatic const struct pci_device_id pci_ids[] = {\n\t{ PCI_DEVICE_DATA(INTEL, QRK_UARTx, &qrk_board) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_UART0, &ehl_board) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_UART1, &ehl_board) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_UART2, &ehl_board) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_UART3, &ehl_board) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_UART4, &ehl_board) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_UART5, &ehl_board) },\n\t{ PCI_DEVICE_DATA(INTEL, BYT_UART1, &byt_board) },\n\t{ PCI_DEVICE_DATA(INTEL, BYT_UART2, &byt_board) },\n\t{ PCI_DEVICE_DATA(INTEL, BSW_UART1, &byt_board) },\n\t{ PCI_DEVICE_DATA(INTEL, BSW_UART2, &byt_board) },\n\t{ PCI_DEVICE_DATA(INTEL, BDW_UART1, &byt_board) },\n\t{ PCI_DEVICE_DATA(INTEL, BDW_UART2, &byt_board) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, pci_ids);\n\nstatic struct pci_driver lpss8250_pci_driver = {\n\t.name           = \"8250_lpss\",\n\t.id_table       = pci_ids,\n\t.probe          = lpss8250_probe,\n\t.remove         = lpss8250_remove,\n};\n\nmodule_pci_driver(lpss8250_pci_driver);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel LPSS UART driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}