{
  "module_name": "8250_aspeed_vuart.c",
  "hash_id": "403c071fbea738bc9a632c215479c454c0e2823e29489fc92f7e4fa14f0fa067",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_aspeed_vuart.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/clk.h>\n\n#include \"8250.h\"\n\n#define ASPEED_VUART_GCRA\t\t0x20\n#define ASPEED_VUART_GCRA_VUART_EN\t\tBIT(0)\n#define ASPEED_VUART_GCRA_HOST_SIRQ_POLARITY\tBIT(1)\n#define ASPEED_VUART_GCRA_DISABLE_HOST_TX_DISCARD BIT(5)\n#define ASPEED_VUART_GCRB\t\t0x24\n#define ASPEED_VUART_GCRB_HOST_SIRQ_MASK\tGENMASK(7, 4)\n#define ASPEED_VUART_GCRB_HOST_SIRQ_SHIFT\t4\n#define ASPEED_VUART_ADDRL\t\t0x28\n#define ASPEED_VUART_ADDRH\t\t0x2c\n\n#define ASPEED_VUART_DEFAULT_LPC_ADDR\t0x3f8\n#define ASPEED_VUART_DEFAULT_SIRQ\t4\n#define ASPEED_VUART_DEFAULT_SIRQ_POLARITY\tIRQ_TYPE_LEVEL_LOW\n\nstruct aspeed_vuart {\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*clk;\n\tint\t\t\tline;\n\tstruct timer_list\tunthrottle_timer;\n\tstruct uart_8250_port\t*port;\n};\n\n \nstatic const int unthrottle_timeout = HZ/10;\n\n \n\nstatic inline u8 aspeed_vuart_readb(struct aspeed_vuart *vuart, u8 reg)\n{\n\treturn readb(vuart->port->port.membase + reg);\n}\n\nstatic inline void aspeed_vuart_writeb(struct aspeed_vuart *vuart, u8 val, u8 reg)\n{\n\twriteb(val, vuart->port->port.membase + reg);\n}\n\nstatic ssize_t lpc_address_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct aspeed_vuart *vuart = dev_get_drvdata(dev);\n\tu16 addr;\n\n\taddr = (aspeed_vuart_readb(vuart, ASPEED_VUART_ADDRH) << 8) |\n\t\t(aspeed_vuart_readb(vuart, ASPEED_VUART_ADDRL));\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", addr);\n}\n\nstatic int aspeed_vuart_set_lpc_address(struct aspeed_vuart *vuart, u32 addr)\n{\n\tif (addr > U16_MAX)\n\t\treturn -EINVAL;\n\n\taspeed_vuart_writeb(vuart, addr >> 8, ASPEED_VUART_ADDRH);\n\taspeed_vuart_writeb(vuart, addr >> 0, ASPEED_VUART_ADDRL);\n\n\treturn 0;\n}\n\nstatic ssize_t lpc_address_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct aspeed_vuart *vuart = dev_get_drvdata(dev);\n\tu32 val;\n\tint err;\n\n\terr = kstrtou32(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\n\terr = aspeed_vuart_set_lpc_address(vuart, val);\n\treturn err ? : count;\n}\n\nstatic DEVICE_ATTR_RW(lpc_address);\n\nstatic ssize_t sirq_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct aspeed_vuart *vuart = dev_get_drvdata(dev);\n\tu8 reg;\n\n\treg = aspeed_vuart_readb(vuart, ASPEED_VUART_GCRB);\n\treg &= ASPEED_VUART_GCRB_HOST_SIRQ_MASK;\n\treg >>= ASPEED_VUART_GCRB_HOST_SIRQ_SHIFT;\n\n\treturn sysfs_emit(buf, \"%u\\n\", reg);\n}\n\nstatic int aspeed_vuart_set_sirq(struct aspeed_vuart *vuart, u32 sirq)\n{\n\tu8 reg;\n\n\tif (sirq > (ASPEED_VUART_GCRB_HOST_SIRQ_MASK >> ASPEED_VUART_GCRB_HOST_SIRQ_SHIFT))\n\t\treturn -EINVAL;\n\n\tsirq <<= ASPEED_VUART_GCRB_HOST_SIRQ_SHIFT;\n\tsirq &= ASPEED_VUART_GCRB_HOST_SIRQ_MASK;\n\n\treg = aspeed_vuart_readb(vuart, ASPEED_VUART_GCRB);\n\treg &= ~ASPEED_VUART_GCRB_HOST_SIRQ_MASK;\n\treg |= sirq;\n\taspeed_vuart_writeb(vuart, reg, ASPEED_VUART_GCRB);\n\n\treturn 0;\n}\n\nstatic ssize_t sirq_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct aspeed_vuart *vuart = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\n\terr = aspeed_vuart_set_sirq(vuart, val);\n\treturn err ? : count;\n}\n\nstatic DEVICE_ATTR_RW(sirq);\n\nstatic ssize_t sirq_polarity_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct aspeed_vuart *vuart = dev_get_drvdata(dev);\n\tu8 reg;\n\n\treg = aspeed_vuart_readb(vuart, ASPEED_VUART_GCRA);\n\treg &= ASPEED_VUART_GCRA_HOST_SIRQ_POLARITY;\n\n\treturn sysfs_emit(buf, \"%u\\n\", reg ? 1 : 0);\n}\n\nstatic void aspeed_vuart_set_sirq_polarity(struct aspeed_vuart *vuart,\n\t\t\t\t\t   bool polarity)\n{\n\tu8 reg = aspeed_vuart_readb(vuart, ASPEED_VUART_GCRA);\n\n\tif (polarity)\n\t\treg |= ASPEED_VUART_GCRA_HOST_SIRQ_POLARITY;\n\telse\n\t\treg &= ~ASPEED_VUART_GCRA_HOST_SIRQ_POLARITY;\n\n\taspeed_vuart_writeb(vuart, reg, ASPEED_VUART_GCRA);\n}\n\nstatic ssize_t sirq_polarity_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct aspeed_vuart *vuart = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\n\taspeed_vuart_set_sirq_polarity(vuart, val != 0);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(sirq_polarity);\n\nstatic struct attribute *aspeed_vuart_attrs[] = {\n\t&dev_attr_sirq.attr,\n\t&dev_attr_sirq_polarity.attr,\n\t&dev_attr_lpc_address.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group aspeed_vuart_attr_group = {\n\t.attrs = aspeed_vuart_attrs,\n};\n\nstatic void aspeed_vuart_set_enabled(struct aspeed_vuart *vuart, bool enabled)\n{\n\tu8 reg = aspeed_vuart_readb(vuart, ASPEED_VUART_GCRA);\n\n\tif (enabled)\n\t\treg |= ASPEED_VUART_GCRA_VUART_EN;\n\telse\n\t\treg &= ~ASPEED_VUART_GCRA_VUART_EN;\n\n\taspeed_vuart_writeb(vuart, reg, ASPEED_VUART_GCRA);\n}\n\nstatic void aspeed_vuart_set_host_tx_discard(struct aspeed_vuart *vuart,\n\t\t\t\t\t     bool discard)\n{\n\tu8 reg;\n\n\treg = aspeed_vuart_readb(vuart, ASPEED_VUART_GCRA);\n\n\t \n\tif (!discard)\n\t\treg |= ASPEED_VUART_GCRA_DISABLE_HOST_TX_DISCARD;\n\telse\n\t\treg &= ~ASPEED_VUART_GCRA_DISABLE_HOST_TX_DISCARD;\n\n\taspeed_vuart_writeb(vuart, reg, ASPEED_VUART_GCRA);\n}\n\nstatic int aspeed_vuart_startup(struct uart_port *uart_port)\n{\n\tstruct uart_8250_port *uart_8250_port = up_to_u8250p(uart_port);\n\tstruct aspeed_vuart *vuart = uart_8250_port->port.private_data;\n\tint rc;\n\n\trc = serial8250_do_startup(uart_port);\n\tif (rc)\n\t\treturn rc;\n\n\taspeed_vuart_set_host_tx_discard(vuart, false);\n\n\treturn 0;\n}\n\nstatic void aspeed_vuart_shutdown(struct uart_port *uart_port)\n{\n\tstruct uart_8250_port *uart_8250_port = up_to_u8250p(uart_port);\n\tstruct aspeed_vuart *vuart = uart_8250_port->port.private_data;\n\n\taspeed_vuart_set_host_tx_discard(vuart, true);\n\n\tserial8250_do_shutdown(uart_port);\n}\n\nstatic void __aspeed_vuart_set_throttle(struct uart_8250_port *up,\n\t\tbool throttle)\n{\n\tunsigned char irqs = UART_IER_RLSI | UART_IER_RDI;\n\n\t \n\tlockdep_assert_held_once(&up->port.lock);\n\n\tup->ier &= ~irqs;\n\tif (!throttle)\n\t\tup->ier |= irqs;\n\tserial_out(up, UART_IER, up->ier);\n}\nstatic void aspeed_vuart_set_throttle(struct uart_port *port, bool throttle)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\t__aspeed_vuart_set_throttle(up, throttle);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void aspeed_vuart_throttle(struct uart_port *port)\n{\n\taspeed_vuart_set_throttle(port, true);\n}\n\nstatic void aspeed_vuart_unthrottle(struct uart_port *port)\n{\n\taspeed_vuart_set_throttle(port, false);\n}\n\nstatic void aspeed_vuart_unthrottle_exp(struct timer_list *timer)\n{\n\tstruct aspeed_vuart *vuart = from_timer(vuart, timer, unthrottle_timer);\n\tstruct uart_8250_port *up = vuart->port;\n\n\tif (!tty_buffer_space_avail(&up->port.state->port)) {\n\t\tmod_timer(&vuart->unthrottle_timer,\n\t\t\t  jiffies + unthrottle_timeout);\n\t\treturn;\n\t}\n\n\taspeed_vuart_unthrottle(&up->port);\n}\n\n \nstatic int aspeed_vuart_handle_irq(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned int iir, lsr;\n\tunsigned long flags;\n\tunsigned int space, count;\n\n\tiir = serial_port_in(port, UART_IIR);\n\n\tif (iir & UART_IIR_NO_INT)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tlsr = serial_port_in(port, UART_LSR);\n\n\tif (lsr & (UART_LSR_DR | UART_LSR_BI)) {\n\t\tspace = tty_buffer_space_avail(&port->state->port);\n\n\t\tif (!space) {\n\t\t\t \n\t\t\tstruct aspeed_vuart *vuart = port->private_data;\n\t\t\t__aspeed_vuart_set_throttle(up, true);\n\n\t\t\tif (!timer_pending(&vuart->unthrottle_timer))\n\t\t\t\tmod_timer(&vuart->unthrottle_timer,\n\t\t\t\t\t  jiffies + unthrottle_timeout);\n\n\t\t} else {\n\t\t\tcount = min(space, 256U);\n\n\t\t\tdo {\n\t\t\t\tserial8250_read_char(up, lsr);\n\t\t\t\tlsr = serial_in(up, UART_LSR);\n\t\t\t\tif (--count == 0)\n\t\t\t\t\tbreak;\n\t\t\t} while (lsr & (UART_LSR_DR | UART_LSR_BI));\n\n\t\t\ttty_flip_buffer_push(&port->state->port);\n\t\t}\n\t}\n\n\tserial8250_modem_status(up);\n\tif (lsr & UART_LSR_THRE)\n\t\tserial8250_tx_chars(up);\n\n\tuart_unlock_and_check_sysrq_irqrestore(port, flags);\n\n\treturn 1;\n}\n\nstatic void aspeed_vuart_auto_configure_sirq_polarity(\n\tstruct aspeed_vuart *vuart, struct device_node *syscon_np,\n\tu32 reg_offset, u32 reg_mask)\n{\n\tstruct regmap *regmap;\n\tu32 value;\n\n\tregmap = syscon_node_to_regmap(syscon_np);\n\tif (IS_ERR(regmap)) {\n\t\tdev_warn(vuart->dev,\n\t\t\t \"could not get regmap for aspeed,sirq-polarity-sense\\n\");\n\t\treturn;\n\t}\n\tif (regmap_read(regmap, reg_offset, &value)) {\n\t\tdev_warn(vuart->dev, \"could not read hw strap table\\n\");\n\t\treturn;\n\t}\n\n\taspeed_vuart_set_sirq_polarity(vuart, (value & reg_mask) == 0);\n}\n\nstatic int aspeed_vuart_map_irq_polarity(u32 dt)\n{\n\tswitch (dt) {\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\treturn 0;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\treturn 1;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int aspeed_vuart_probe(struct platform_device *pdev)\n{\n\tstruct of_phandle_args sirq_polarity_sense_args;\n\tstruct uart_8250_port port;\n\tstruct aspeed_vuart *vuart;\n\tstruct device_node *np;\n\tstruct resource *res;\n\tu32 clk, prop, sirq[2];\n\tint rc, sirq_polarity;\n\n\tnp = pdev->dev.of_node;\n\n\tvuart = devm_kzalloc(&pdev->dev, sizeof(*vuart), GFP_KERNEL);\n\tif (!vuart)\n\t\treturn -ENOMEM;\n\n\tvuart->dev = &pdev->dev;\n\ttimer_setup(&vuart->unthrottle_timer, aspeed_vuart_unthrottle_exp, 0);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tmemset(&port, 0, sizeof(port));\n\tport.port.private_data = vuart;\n\tport.port.mapbase = res->start;\n\tport.port.mapsize = resource_size(res);\n\tport.port.startup = aspeed_vuart_startup;\n\tport.port.shutdown = aspeed_vuart_shutdown;\n\tport.port.throttle = aspeed_vuart_throttle;\n\tport.port.unthrottle = aspeed_vuart_unthrottle;\n\tport.port.status = UPSTAT_SYNC_FIFO;\n\tport.port.dev = &pdev->dev;\n\tport.port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);\n\tport.bugs |= UART_BUG_TXRACE;\n\n\trc = sysfs_create_group(&vuart->dev->kobj, &aspeed_vuart_attr_group);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (of_property_read_u32(np, \"clock-frequency\", &clk)) {\n\t\tvuart->clk = devm_clk_get(&pdev->dev, NULL);\n\t\tif (IS_ERR(vuart->clk)) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\"clk or clock-frequency not defined\\n\");\n\t\t\trc = PTR_ERR(vuart->clk);\n\t\t\tgoto err_sysfs_remove;\n\t\t}\n\n\t\trc = clk_prepare_enable(vuart->clk);\n\t\tif (rc < 0)\n\t\t\tgoto err_sysfs_remove;\n\n\t\tclk = clk_get_rate(vuart->clk);\n\t}\n\n\t \n\tif (of_property_read_u32(np, \"current-speed\", &prop) == 0)\n\t\tport.port.custom_divisor = clk / (16 * prop);\n\n\t \n\tif (of_property_read_u32(np, \"reg-offset\", &prop) == 0)\n\t\tport.port.mapbase += prop;\n\n\t \n\tif (of_property_read_u32(np, \"reg-shift\", &prop) == 0)\n\t\tport.port.regshift = prop;\n\n\t \n\tif (of_property_read_u32(np, \"fifo-size\", &prop) == 0)\n\t\tport.port.fifosize = prop;\n\n\t \n\trc = of_alias_get_id(np, \"serial\");\n\tif (rc >= 0)\n\t\tport.port.line = rc;\n\n\tport.port.irq = irq_of_parse_and_map(np, 0);\n\tport.port.handle_irq = aspeed_vuart_handle_irq;\n\tport.port.iotype = UPIO_MEM;\n\tport.port.type = PORT_ASPEED_VUART;\n\tport.port.uartclk = clk;\n\tport.port.flags = UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF | UPF_IOREMAP\n\t\t| UPF_FIXED_PORT | UPF_FIXED_TYPE | UPF_NO_THRE_TEST;\n\n\tif (of_property_read_bool(np, \"no-loopback-test\"))\n\t\tport.port.flags |= UPF_SKIP_TEST;\n\n\tif (port.port.fifosize)\n\t\tport.capabilities = UART_CAP_FIFO;\n\n\tif (of_property_read_bool(np, \"auto-flow-control\"))\n\t\tport.capabilities |= UART_CAP_AFE;\n\n\trc = serial8250_register_8250_port(&port);\n\tif (rc < 0)\n\t\tgoto err_clk_disable;\n\n\tvuart->line = rc;\n\tvuart->port = serial8250_get_port(vuart->line);\n\n\trc = of_parse_phandle_with_fixed_args(\n\t\tnp, \"aspeed,sirq-polarity-sense\", 2, 0,\n\t\t&sirq_polarity_sense_args);\n\tif (rc < 0) {\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"aspeed,sirq-polarity-sense property not found\\n\");\n\t} else {\n\t\taspeed_vuart_auto_configure_sirq_polarity(\n\t\t\tvuart, sirq_polarity_sense_args.np,\n\t\t\tsirq_polarity_sense_args.args[0],\n\t\t\tBIT(sirq_polarity_sense_args.args[1]));\n\t\tof_node_put(sirq_polarity_sense_args.np);\n\t}\n\n\trc = of_property_read_u32(np, \"aspeed,lpc-io-reg\", &prop);\n\tif (rc < 0)\n\t\tprop = ASPEED_VUART_DEFAULT_LPC_ADDR;\n\n\trc = aspeed_vuart_set_lpc_address(vuart, prop);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"invalid value in aspeed,lpc-io-reg property\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\trc = of_property_read_u32_array(np, \"aspeed,lpc-interrupts\", sirq, 2);\n\tif (rc < 0) {\n\t\tsirq[0] = ASPEED_VUART_DEFAULT_SIRQ;\n\t\tsirq[1] = ASPEED_VUART_DEFAULT_SIRQ_POLARITY;\n\t}\n\n\trc = aspeed_vuart_set_sirq(vuart, sirq[0]);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"invalid sirq number in aspeed,lpc-interrupts property\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\tsirq_polarity = aspeed_vuart_map_irq_polarity(sirq[1]);\n\tif (sirq_polarity < 0) {\n\t\tdev_err(&pdev->dev, \"invalid sirq polarity in aspeed,lpc-interrupts property\\n\");\n\t\trc = sirq_polarity;\n\t\tgoto err_clk_disable;\n\t}\n\n\taspeed_vuart_set_sirq_polarity(vuart, sirq_polarity);\n\n\taspeed_vuart_set_enabled(vuart, true);\n\taspeed_vuart_set_host_tx_discard(vuart, true);\n\tplatform_set_drvdata(pdev, vuart);\n\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(vuart->clk);\n\tirq_dispose_mapping(port.port.irq);\nerr_sysfs_remove:\n\tsysfs_remove_group(&vuart->dev->kobj, &aspeed_vuart_attr_group);\n\treturn rc;\n}\n\nstatic int aspeed_vuart_remove(struct platform_device *pdev)\n{\n\tstruct aspeed_vuart *vuart = platform_get_drvdata(pdev);\n\n\tdel_timer_sync(&vuart->unthrottle_timer);\n\taspeed_vuart_set_enabled(vuart, false);\n\tserial8250_unregister_port(vuart->line);\n\tsysfs_remove_group(&vuart->dev->kobj, &aspeed_vuart_attr_group);\n\tclk_disable_unprepare(vuart->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id aspeed_vuart_table[] = {\n\t{ .compatible = \"aspeed,ast2400-vuart\" },\n\t{ .compatible = \"aspeed,ast2500-vuart\" },\n\t{ },\n};\n\nstatic struct platform_driver aspeed_vuart_driver = {\n\t.driver = {\n\t\t.name = \"aspeed-vuart\",\n\t\t.of_match_table = aspeed_vuart_table,\n\t},\n\t.probe = aspeed_vuart_probe,\n\t.remove = aspeed_vuart_remove,\n};\n\nmodule_platform_driver(aspeed_vuart_driver);\n\nMODULE_AUTHOR(\"Jeremy Kerr <jk@ozlabs.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Driver for Aspeed VUART device\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}