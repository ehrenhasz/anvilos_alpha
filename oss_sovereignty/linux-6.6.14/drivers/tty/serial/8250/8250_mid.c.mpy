{
  "module_name": "8250_mid.c",
  "hash_id": "6b5938d815a79e86894ceaa8b2d6700e56db0fd6d01699270a43c0175566aec0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_mid.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/rational.h>\n\n#include <linux/dma/hsu.h>\n#include <linux/8250_pci.h>\n\n#include \"8250.h\"\n\n#define PCI_DEVICE_ID_INTEL_PNW_UART1\t0x081b\n#define PCI_DEVICE_ID_INTEL_PNW_UART2\t0x081c\n#define PCI_DEVICE_ID_INTEL_PNW_UART3\t0x081d\n#define PCI_DEVICE_ID_INTEL_TNG_UART\t0x1191\n#define PCI_DEVICE_ID_INTEL_CDF_UART\t0x18d8\n#define PCI_DEVICE_ID_INTEL_DNV_UART\t0x19d8\n\n \n#define INTEL_MID_UART_FISR\t\t0x08\n#define INTEL_MID_UART_PS\t\t0x30\n#define INTEL_MID_UART_MUL\t\t0x34\n#define INTEL_MID_UART_DIV\t\t0x38\n\nstruct mid8250;\n\nstruct mid8250_board {\n\tunsigned int flags;\n\tunsigned long freq;\n\tunsigned int base_baud;\n\tint (*setup)(struct mid8250 *, struct uart_port *p);\n\tvoid (*exit)(struct mid8250 *);\n};\n\nstruct mid8250 {\n\tint line;\n\tint dma_index;\n\tstruct pci_dev *dma_dev;\n\tstruct uart_8250_dma dma;\n\tstruct mid8250_board *board;\n\tstruct hsu_dma_chip dma_chip;\n};\n\n \n\nstatic int pnw_setup(struct mid8250 *mid, struct uart_port *p)\n{\n\tstruct pci_dev *pdev = to_pci_dev(p->dev);\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_PNW_UART1:\n\t\tmid->dma_index = 0;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_INTEL_PNW_UART2:\n\t\tmid->dma_index = 1;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_INTEL_PNW_UART3:\n\t\tmid->dma_index = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmid->dma_dev = pci_get_slot(pdev->bus,\n\t\t\t\t    PCI_DEVFN(PCI_SLOT(pdev->devfn), 3));\n\treturn 0;\n}\n\nstatic void pnw_exit(struct mid8250 *mid)\n{\n\tpci_dev_put(mid->dma_dev);\n}\n\nstatic int tng_handle_irq(struct uart_port *p)\n{\n\tstruct mid8250 *mid = p->private_data;\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\tstruct hsu_dma_chip *chip;\n\tu32 status;\n\tint ret = 0;\n\tint err;\n\n\tchip = pci_get_drvdata(mid->dma_dev);\n\n\t \n\terr = hsu_dma_get_status(chip, mid->dma_index * 2 + 1, &status);\n\tif (err > 0) {\n\t\tserial8250_rx_dma_flush(up);\n\t\tret |= 1;\n\t} else if (err == 0)\n\t\tret |= hsu_dma_do_irq(chip, mid->dma_index * 2 + 1, status);\n\n\t \n\terr = hsu_dma_get_status(chip, mid->dma_index * 2, &status);\n\tif (err > 0)\n\t\tret |= 1;\n\telse if (err == 0)\n\t\tret |= hsu_dma_do_irq(chip, mid->dma_index * 2, status);\n\n\t \n\tret |= serial8250_handle_irq(p, serial_port_in(p, UART_IIR));\n\treturn IRQ_RETVAL(ret);\n}\n\nstatic int tng_setup(struct mid8250 *mid, struct uart_port *p)\n{\n\tstruct pci_dev *pdev = to_pci_dev(p->dev);\n\tint index = PCI_FUNC(pdev->devfn);\n\n\t \n\tif (index-- == 0)\n\t\treturn -ENODEV;\n\n\tmid->dma_index = index;\n\tmid->dma_dev = pci_get_slot(pdev->bus, PCI_DEVFN(5, 0));\n\n\tp->handle_irq = tng_handle_irq;\n\treturn 0;\n}\n\nstatic void tng_exit(struct mid8250 *mid)\n{\n\tpci_dev_put(mid->dma_dev);\n}\n\nstatic int dnv_handle_irq(struct uart_port *p)\n{\n\tstruct mid8250 *mid = p->private_data;\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\tunsigned int fisr = serial_port_in(p, INTEL_MID_UART_FISR);\n\tu32 status;\n\tint ret = 0;\n\tint err;\n\n\tif (fisr & BIT(2)) {\n\t\terr = hsu_dma_get_status(&mid->dma_chip, 1, &status);\n\t\tif (err > 0) {\n\t\t\tserial8250_rx_dma_flush(up);\n\t\t\tret |= 1;\n\t\t} else if (err == 0)\n\t\t\tret |= hsu_dma_do_irq(&mid->dma_chip, 1, status);\n\t}\n\tif (fisr & BIT(1)) {\n\t\terr = hsu_dma_get_status(&mid->dma_chip, 0, &status);\n\t\tif (err > 0)\n\t\t\tret |= 1;\n\t\telse if (err == 0)\n\t\t\tret |= hsu_dma_do_irq(&mid->dma_chip, 0, status);\n\t}\n\tif (fisr & BIT(0))\n\t\tret |= serial8250_handle_irq(p, serial_port_in(p, UART_IIR));\n\treturn IRQ_RETVAL(ret);\n}\n\n#define DNV_DMA_CHAN_OFFSET 0x80\n\nstatic int dnv_setup(struct mid8250 *mid, struct uart_port *p)\n{\n\tstruct hsu_dma_chip *chip = &mid->dma_chip;\n\tstruct pci_dev *pdev = to_pci_dev(p->dev);\n\tunsigned int bar = FL_GET_BASE(mid->board->flags);\n\tint ret;\n\n\tpci_set_master(pdev);\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tp->irq = pci_irq_vector(pdev, 0);\n\n\tchip->dev = &pdev->dev;\n\tchip->irq = pci_irq_vector(pdev, 0);\n\tchip->regs = p->membase;\n\tchip->length = pci_resource_len(pdev, bar);\n\tchip->offset = DNV_DMA_CHAN_OFFSET;\n\n\t \n\tret = hsu_dma_probe(chip);\n\tif (ret)\n\t\treturn 0;\n\n\tmid->dma_dev = pdev;\n\n\tp->handle_irq = dnv_handle_irq;\n\treturn 0;\n}\n\nstatic void dnv_exit(struct mid8250 *mid)\n{\n\tif (!mid->dma_dev)\n\t\treturn;\n\thsu_dma_remove(&mid->dma_chip);\n}\n\n \n\nstatic void mid8250_set_termios(struct uart_port *p, struct ktermios *termios,\n\t\t\t\tconst struct ktermios *old)\n{\n\tunsigned int baud = tty_termios_baud_rate(termios);\n\tstruct mid8250 *mid = p->private_data;\n\tunsigned short ps = 16;\n\tunsigned long fuart = baud * ps;\n\tunsigned long w = BIT(24) - 1;\n\tunsigned long mul, div;\n\n\t \n\tfuart = fuart ? fuart : 9600 * 16;\n\n\tif (mid->board->freq < fuart) {\n\t\t \n\t\tif (mid->board->freq > baud)\n\t\t\tps = mid->board->freq / baud;\t \n\t\telse\n\t\t\tps = 1;\t\t\t\t \n\t\tfuart = baud * ps;\n\t} else {\n\t\t \n\t\tfuart *= rounddown_pow_of_two(mid->board->freq / fuart);\n\t}\n\n\trational_best_approximation(fuart, mid->board->freq, w, w, &mul, &div);\n\tp->uartclk = fuart * 16 / ps;\t\t \n\n\twritel(ps, p->membase + INTEL_MID_UART_PS);\t\t \n\twritel(mul, p->membase + INTEL_MID_UART_MUL);\t\t \n\twritel(div, p->membase + INTEL_MID_UART_DIV);\n\n\tserial8250_do_set_termios(p, termios, old);\n}\n\nstatic bool mid8250_dma_filter(struct dma_chan *chan, void *param)\n{\n\tstruct hsu_dma_slave *s = param;\n\n\tif (s->dma_dev != chan->device->dev || s->chan_id != chan->chan_id)\n\t\treturn false;\n\n\tchan->private = s;\n\treturn true;\n}\n\nstatic int mid8250_dma_setup(struct mid8250 *mid, struct uart_8250_port *port)\n{\n\tstruct uart_8250_dma *dma = &mid->dma;\n\tstruct device *dev = port->port.dev;\n\tstruct hsu_dma_slave *rx_param;\n\tstruct hsu_dma_slave *tx_param;\n\n\tif (!mid->dma_dev)\n\t\treturn 0;\n\n\trx_param = devm_kzalloc(dev, sizeof(*rx_param), GFP_KERNEL);\n\tif (!rx_param)\n\t\treturn -ENOMEM;\n\n\ttx_param = devm_kzalloc(dev, sizeof(*tx_param), GFP_KERNEL);\n\tif (!tx_param)\n\t\treturn -ENOMEM;\n\n\trx_param->chan_id = mid->dma_index * 2 + 1;\n\ttx_param->chan_id = mid->dma_index * 2;\n\n\tdma->rxconf.src_maxburst = 64;\n\tdma->txconf.dst_maxburst = 64;\n\n\trx_param->dma_dev = &mid->dma_dev->dev;\n\ttx_param->dma_dev = &mid->dma_dev->dev;\n\n\tdma->fn = mid8250_dma_filter;\n\tdma->rx_param = rx_param;\n\tdma->tx_param = tx_param;\n\n\tport->dma = dma;\n\treturn 0;\n}\n\nstatic int mid8250_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct uart_8250_port uart;\n\tstruct mid8250 *mid;\n\tunsigned int bar;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tmid = devm_kzalloc(&pdev->dev, sizeof(*mid), GFP_KERNEL);\n\tif (!mid)\n\t\treturn -ENOMEM;\n\n\tmid->board = (struct mid8250_board *)id->driver_data;\n\tbar = FL_GET_BASE(mid->board->flags);\n\n\tmemset(&uart, 0, sizeof(struct uart_8250_port));\n\n\tuart.port.dev = &pdev->dev;\n\tuart.port.irq = pdev->irq;\n\tuart.port.private_data = mid;\n\tuart.port.type = PORT_16750;\n\tuart.port.iotype = UPIO_MEM;\n\tuart.port.uartclk = mid->board->base_baud * 16;\n\tuart.port.flags = UPF_SHARE_IRQ | UPF_FIXED_PORT | UPF_FIXED_TYPE;\n\tuart.port.set_termios = mid8250_set_termios;\n\n\tuart.port.mapbase = pci_resource_start(pdev, bar);\n\tuart.port.membase = pcim_iomap(pdev, bar, 0);\n\tif (!uart.port.membase)\n\t\treturn -ENOMEM;\n\n\tret = mid->board->setup(mid, &uart.port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mid8250_dma_setup(mid, &uart);\n\tif (ret)\n\t\tgoto err;\n\n\tret = serial8250_register_8250_port(&uart);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmid->line = ret;\n\n\tpci_set_drvdata(pdev, mid);\n\treturn 0;\n\nerr:\n\tmid->board->exit(mid);\n\treturn ret;\n}\n\nstatic void mid8250_remove(struct pci_dev *pdev)\n{\n\tstruct mid8250 *mid = pci_get_drvdata(pdev);\n\n\tserial8250_unregister_port(mid->line);\n\n\tmid->board->exit(mid);\n}\n\nstatic const struct mid8250_board pnw_board = {\n\t.flags = FL_BASE0,\n\t.freq = 50000000,\n\t.base_baud = 115200,\n\t.setup = pnw_setup,\n\t.exit = pnw_exit,\n};\n\nstatic const struct mid8250_board tng_board = {\n\t.flags = FL_BASE0,\n\t.freq = 38400000,\n\t.base_baud = 1843200,\n\t.setup = tng_setup,\n\t.exit = tng_exit,\n};\n\nstatic const struct mid8250_board dnv_board = {\n\t.flags = FL_BASE1,\n\t.freq = 133333333,\n\t.base_baud = 115200,\n\t.setup = dnv_setup,\n\t.exit = dnv_exit,\n};\n\nstatic const struct pci_device_id pci_ids[] = {\n\t{ PCI_DEVICE_DATA(INTEL, PNW_UART1, &pnw_board) },\n\t{ PCI_DEVICE_DATA(INTEL, PNW_UART2, &pnw_board) },\n\t{ PCI_DEVICE_DATA(INTEL, PNW_UART3, &pnw_board) },\n\t{ PCI_DEVICE_DATA(INTEL, TNG_UART, &tng_board) },\n\t{ PCI_DEVICE_DATA(INTEL, CDF_UART, &dnv_board) },\n\t{ PCI_DEVICE_DATA(INTEL, DNV_UART, &dnv_board) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, pci_ids);\n\nstatic struct pci_driver mid8250_pci_driver = {\n\t.name           = \"8250_mid\",\n\t.id_table       = pci_ids,\n\t.probe          = mid8250_probe,\n\t.remove         = mid8250_remove,\n};\n\nmodule_pci_driver(mid8250_pci_driver);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel MID UART driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}