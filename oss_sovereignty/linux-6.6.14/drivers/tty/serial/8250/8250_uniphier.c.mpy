{
  "module_name": "8250_uniphier.c",
  "hash_id": "e4fdcc2b97c7f73d53736047f4815d92a01bd75e494074a8ec8fdb7b661b564d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_uniphier.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include \"8250.h\"\n\n \n\n#define UNIPHIER_UART_REGSHIFT\t\t2\n\n \n#define UNIPHIER_UART_CHAR_FCR\t\t(3 << (UNIPHIER_UART_REGSHIFT))\n \n#define UNIPHIER_UART_LCR_MCR\t\t(4 << (UNIPHIER_UART_REGSHIFT))\n \n#define UNIPHIER_UART_DLR\t\t(9 << (UNIPHIER_UART_REGSHIFT))\n\nstruct uniphier8250_priv {\n\tint line;\n\tstruct clk *clk;\n\tspinlock_t atomic_write_lock;\n};\n\n#ifdef CONFIG_SERIAL_8250_CONSOLE\nstatic int __init uniphier_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t       const char *options)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\t \n\tdevice->port.iotype = UPIO_MEM32;\n\tdevice->port.regshift = UNIPHIER_UART_REGSHIFT;\n\n\t \n\tdevice->baud = 0;\n\n\treturn early_serial8250_setup(device, options);\n}\nOF_EARLYCON_DECLARE(uniphier, \"socionext,uniphier-uart\",\n\t\t    uniphier_early_console_setup);\n#endif\n\n \nstatic unsigned int uniphier_serial_in(struct uart_port *p, int offset)\n{\n\tunsigned int valshift = 0;\n\n\tswitch (offset) {\n\tcase UART_SCR:\n\t\t \n\t\tvalshift = 8;\n\t\toffset = UNIPHIER_UART_CHAR_FCR;\n\t\tbreak;\n\tcase UART_LCR:\n\t\tvalshift = 8;\n\t\tfallthrough;\n\tcase UART_MCR:\n\t\toffset = UNIPHIER_UART_LCR_MCR;\n\t\tbreak;\n\tdefault:\n\t\toffset <<= UNIPHIER_UART_REGSHIFT;\n\t\tbreak;\n\t}\n\n\t \n\treturn (readl(p->membase + offset) >> valshift) & 0xff;\n}\n\nstatic void uniphier_serial_out(struct uart_port *p, int offset, int value)\n{\n\tunsigned int valshift = 0;\n\tbool normal = false;\n\n\tswitch (offset) {\n\tcase UART_SCR:\n\t\t \n\t\tvalshift = 8;\n\t\tfallthrough;\n\tcase UART_FCR:\n\t\toffset = UNIPHIER_UART_CHAR_FCR;\n\t\tbreak;\n\tcase UART_LCR:\n\t\tvalshift = 8;\n\t\t \n\t\tvalue &= ~UART_LCR_DLAB;\n\t\tfallthrough;\n\tcase UART_MCR:\n\t\toffset = UNIPHIER_UART_LCR_MCR;\n\t\tbreak;\n\tdefault:\n\t\toffset <<= UNIPHIER_UART_REGSHIFT;\n\t\tnormal = true;\n\t\tbreak;\n\t}\n\n\tif (normal) {\n\t\twritel(value, p->membase + offset);\n\t} else {\n\t\t \n\t\tstruct uniphier8250_priv *priv = p->private_data;\n\t\tunsigned long flags;\n\t\tu32 tmp;\n\n\t\tspin_lock_irqsave(&priv->atomic_write_lock, flags);\n\t\ttmp = readl(p->membase + offset);\n\t\ttmp &= ~(0xff << valshift);\n\t\ttmp |= value << valshift;\n\t\twritel(tmp, p->membase + offset);\n\t\tspin_unlock_irqrestore(&priv->atomic_write_lock, flags);\n\t}\n}\n\n \nstatic u32 uniphier_serial_dl_read(struct uart_8250_port *up)\n{\n\treturn readl(up->port.membase + UNIPHIER_UART_DLR);\n}\n\nstatic void uniphier_serial_dl_write(struct uart_8250_port *up, u32 value)\n{\n\twritel(value, up->port.membase + UNIPHIER_UART_DLR);\n}\n\nstatic int uniphier_uart_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uart_8250_port up;\n\tstruct uniphier8250_priv *priv;\n\tstruct resource *regs;\n\tvoid __iomem *membase;\n\tint irq;\n\tint ret;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs) {\n\t\tdev_err(dev, \"failed to get memory resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmembase = devm_ioremap(dev, regs->start, resource_size(regs));\n\tif (!membase)\n\t\treturn -ENOMEM;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmemset(&up, 0, sizeof(up));\n\n\tret = of_alias_get_id(dev->of_node, \"serial\");\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get alias id\\n\");\n\t\treturn ret;\n\t}\n\tup.port.line = ret;\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tup.port.uartclk = clk_get_rate(priv->clk);\n\n\tspin_lock_init(&priv->atomic_write_lock);\n\n\tup.port.dev = dev;\n\tup.port.private_data = priv;\n\tup.port.mapbase = regs->start;\n\tup.port.mapsize = resource_size(regs);\n\tup.port.membase = membase;\n\tup.port.irq = irq;\n\n\tup.port.type = PORT_16550A;\n\tup.port.iotype = UPIO_MEM32;\n\tup.port.fifosize = 64;\n\tup.port.regshift = UNIPHIER_UART_REGSHIFT;\n\tup.port.flags = UPF_FIXED_PORT | UPF_FIXED_TYPE;\n\tup.capabilities = UART_CAP_FIFO;\n\n\tif (of_property_read_bool(dev->of_node, \"auto-flow-control\"))\n\t\tup.capabilities |= UART_CAP_AFE;\n\n\tup.port.serial_in = uniphier_serial_in;\n\tup.port.serial_out = uniphier_serial_out;\n\tup.dl_read = uniphier_serial_dl_read;\n\tup.dl_write = uniphier_serial_dl_write;\n\n\tret = serial8250_register_8250_port(&up);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register 8250 port\\n\");\n\t\tclk_disable_unprepare(priv->clk);\n\t\treturn ret;\n\t}\n\tpriv->line = ret;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n}\n\nstatic int uniphier_uart_remove(struct platform_device *pdev)\n{\n\tstruct uniphier8250_priv *priv = platform_get_drvdata(pdev);\n\n\tserial8250_unregister_port(priv->line);\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused uniphier_uart_suspend(struct device *dev)\n{\n\tstruct uniphier8250_priv *priv = dev_get_drvdata(dev);\n\tstruct uart_8250_port *up = serial8250_get_port(priv->line);\n\n\tserial8250_suspend_port(priv->line);\n\n\tif (!uart_console(&up->port) || console_suspend_enabled)\n\t\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused uniphier_uart_resume(struct device *dev)\n{\n\tstruct uniphier8250_priv *priv = dev_get_drvdata(dev);\n\tstruct uart_8250_port *up = serial8250_get_port(priv->line);\n\tint ret;\n\n\tif (!uart_console(&up->port) || console_suspend_enabled) {\n\t\tret = clk_prepare_enable(priv->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tserial8250_resume_port(priv->line);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops uniphier_uart_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(uniphier_uart_suspend, uniphier_uart_resume)\n};\n\nstatic const struct of_device_id uniphier_uart_match[] = {\n\t{ .compatible = \"socionext,uniphier-uart\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_uart_match);\n\nstatic struct platform_driver uniphier_uart_platform_driver = {\n\t.probe\t\t= uniphier_uart_probe,\n\t.remove\t\t= uniphier_uart_remove,\n\t.driver = {\n\t\t.name\t= \"uniphier-uart\",\n\t\t.of_match_table = uniphier_uart_match,\n\t\t.pm = &uniphier_uart_pm_ops,\n\t},\n};\nmodule_platform_driver(uniphier_uart_platform_driver);\n\nMODULE_AUTHOR(\"Masahiro Yamada <yamada.masahiro@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier UART driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}