{
  "module_name": "8250_em.c",
  "hash_id": "fe2e9014f7f233095a07b209a3ef8bf595a026d60baf118de88d885d2037922b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_em.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/serial_8250.h>\n#include <linux/serial_reg.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n\n#include \"8250.h\"\n\n#define UART_DLL_EM 9\n#define UART_DLM_EM 10\n#define UART_HCR0_EM 11\n\n \n#define UART_FCR_EM 0x10003\n#define UART_FCR_EM_HW 3\n\n#define UART_HCR0_EM_SW_RESET\tBIT(7)  \n\nstruct serial8250_em_priv {\n\tint line;\n};\n\nstatic void serial8250_em_serial_out_helper(struct uart_port *p, int offset,\n\t\t\t\t\t    int value)\n{\n\tswitch (offset) {\n\tcase UART_TX:  \n\t\twriteb(value, p->membase);\n\t\tbreak;\n\tcase UART_LCR:  \n\tcase UART_MCR:  \n\tcase UART_SCR:  \n\t\twritel(value, p->membase + ((offset + 1) << 2));\n\t\tbreak;\n\tcase UART_FCR_EM:\n\t\twritel(value, p->membase + (UART_FCR_EM_HW << 2));\n\t\tbreak;\n\tcase UART_IER:  \n\t\tvalue &= 0x0f;  \n\t\tfallthrough;\n\tcase UART_DLL_EM:  \n\tcase UART_DLM_EM:  \n\tcase UART_HCR0_EM:  \n\t\twritel(value, p->membase + (offset << 2));\n\t\tbreak;\n\t}\n}\n\nstatic unsigned int serial8250_em_serial_in(struct uart_port *p, int offset)\n{\n\tswitch (offset) {\n\tcase UART_RX:  \n\t\treturn readb(p->membase);\n\tcase UART_LCR:  \n\tcase UART_MCR:  \n\tcase UART_LSR:  \n\tcase UART_MSR:  \n\tcase UART_SCR:  \n\t\treturn readl(p->membase + ((offset + 1) << 2));\n\tcase UART_FCR_EM:\n\t\treturn readl(p->membase + (UART_FCR_EM_HW << 2));\n\tcase UART_IER:  \n\tcase UART_IIR:  \n\tcase UART_DLL_EM:  \n\tcase UART_DLM_EM:  \n\tcase UART_HCR0_EM:  \n\t\treturn readl(p->membase + (offset << 2));\n\t}\n\treturn 0;\n}\n\nstatic void serial8250_em_reg_update(struct uart_port *p, int off, int value)\n{\n\tunsigned int ier, fcr, lcr, mcr, hcr0;\n\n\tier = serial8250_em_serial_in(p, UART_IER);\n\tfcr = serial8250_em_serial_in(p, UART_FCR_EM);\n\tlcr = serial8250_em_serial_in(p, UART_LCR);\n\tmcr = serial8250_em_serial_in(p, UART_MCR);\n\thcr0 = serial8250_em_serial_in(p, UART_HCR0_EM);\n\n\tserial8250_em_serial_out_helper(p, UART_FCR_EM, fcr |\n\t\t\t\t\t\t\tUART_FCR_CLEAR_RCVR |\n\t\t\t\t\t\t\tUART_FCR_CLEAR_XMIT);\n\tserial8250_em_serial_out_helper(p, UART_HCR0_EM, hcr0 |\n\t\t\t\t\t\t\t UART_HCR0_EM_SW_RESET);\n\tserial8250_em_serial_out_helper(p, UART_HCR0_EM, hcr0 &\n\t\t\t\t\t\t\t ~UART_HCR0_EM_SW_RESET);\n\n\tswitch (off) {\n\tcase UART_FCR_EM:\n\t\tfcr = value;\n\t\tbreak;\n\tcase UART_LCR:\n\t\tlcr = value;\n\t\tbreak;\n\tcase UART_MCR:\n\t\tmcr = value;\n\t\tbreak;\n\t}\n\n\tserial8250_em_serial_out_helper(p, UART_IER, ier);\n\tserial8250_em_serial_out_helper(p, UART_FCR_EM, fcr);\n\tserial8250_em_serial_out_helper(p, UART_MCR, mcr);\n\tserial8250_em_serial_out_helper(p, UART_LCR, lcr);\n\tserial8250_em_serial_out_helper(p, UART_HCR0_EM, hcr0);\n}\n\nstatic void serial8250_em_serial_out(struct uart_port *p, int offset, int value)\n{\n\tswitch (offset) {\n\tcase UART_TX:\n\tcase UART_SCR:\n\tcase UART_IER:\n\tcase UART_DLL_EM:\n\tcase UART_DLM_EM:\n\t\tserial8250_em_serial_out_helper(p, offset, value);\n\t\tbreak;\n\tcase UART_FCR:\n\t\tserial8250_em_reg_update(p, UART_FCR_EM, value);\n\t\tbreak;\n\tcase UART_LCR:\n\tcase UART_MCR:\n\t\tserial8250_em_reg_update(p, offset, value);\n\t\tbreak;\n\t}\n}\n\nstatic u32 serial8250_em_serial_dl_read(struct uart_8250_port *up)\n{\n\treturn serial_in(up, UART_DLL_EM) | serial_in(up, UART_DLM_EM) << 8;\n}\n\nstatic void serial8250_em_serial_dl_write(struct uart_8250_port *up, u32 value)\n{\n\tserial_out(up, UART_DLL_EM, value & 0xff);\n\tserial_out(up, UART_DLM_EM, value >> 8 & 0xff);\n}\n\nstatic int serial8250_em_probe(struct platform_device *pdev)\n{\n\tstruct serial8250_em_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct uart_8250_port up;\n\tstruct resource *regs;\n\tstruct clk *sclk;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs)\n\t\treturn dev_err_probe(dev, -EINVAL, \"missing registers\\n\");\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tsclk = devm_clk_get_enabled(dev, \"sclk\");\n\tif (IS_ERR(sclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(sclk), \"unable to get clock\\n\");\n\n\tmemset(&up, 0, sizeof(up));\n\tup.port.mapbase = regs->start;\n\tup.port.irq = irq;\n\tup.port.type = PORT_16750;\n\tup.port.flags = UPF_FIXED_PORT | UPF_IOREMAP | UPF_FIXED_TYPE;\n\tup.port.dev = dev;\n\tup.port.private_data = priv;\n\n\tup.port.uartclk = clk_get_rate(sclk);\n\n\tup.port.iotype = UPIO_MEM32;\n\tup.port.serial_in = serial8250_em_serial_in;\n\tup.port.serial_out = serial8250_em_serial_out;\n\tup.dl_read = serial8250_em_serial_dl_read;\n\tup.dl_write = serial8250_em_serial_dl_write;\n\n\tret = serial8250_register_8250_port(&up);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"unable to register 8250 port\\n\");\n\n\tpriv->line = ret;\n\tplatform_set_drvdata(pdev, priv);\n\treturn 0;\n}\n\nstatic int serial8250_em_remove(struct platform_device *pdev)\n{\n\tstruct serial8250_em_priv *priv = platform_get_drvdata(pdev);\n\n\tserial8250_unregister_port(priv->line);\n\treturn 0;\n}\n\nstatic const struct of_device_id serial8250_em_dt_ids[] = {\n\t{ .compatible = \"renesas,em-uart\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, serial8250_em_dt_ids);\n\nstatic struct platform_driver serial8250_em_platform_driver = {\n\t.driver = {\n\t\t.name\t\t= \"serial8250-em\",\n\t\t.of_match_table = serial8250_em_dt_ids,\n\t},\n\t.probe\t\t\t= serial8250_em_probe,\n\t.remove\t\t\t= serial8250_em_remove,\n};\n\nmodule_platform_driver(serial8250_em_platform_driver);\n\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_DESCRIPTION(\"Renesas Emma Mobile 8250 Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}