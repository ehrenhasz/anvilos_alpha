{
  "module_name": "8250_bcm2835aux.c",
  "hash_id": "ca6a56899bbfd83e80b132c07ef8392776757c02a4ae7109ae14d88e27963268",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_bcm2835aux.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#include \"8250.h\"\n\n#define BCM2835_AUX_UART_CNTL\t\t8\n#define BCM2835_AUX_UART_CNTL_RXEN\t0x01  \n#define BCM2835_AUX_UART_CNTL_TXEN\t0x02  \n#define BCM2835_AUX_UART_CNTL_AUTORTS\t0x04  \n#define BCM2835_AUX_UART_CNTL_AUTOCTS\t0x08  \n#define BCM2835_AUX_UART_CNTL_RTS3\t0x00  \n#define BCM2835_AUX_UART_CNTL_RTS2\t0x10  \n#define BCM2835_AUX_UART_CNTL_RTS1\t0x20  \n#define BCM2835_AUX_UART_CNTL_RTS4\t0x30  \n#define BCM2835_AUX_UART_CNTL_RTSINV\t0x40  \n#define BCM2835_AUX_UART_CNTL_CTSINV\t0x80  \n\n \nstruct bcm2835aux_data {\n\tstruct clk *clk;\n\tint line;\n\tu32 cntl;\n};\n\nstruct bcm2835_aux_serial_driver_data {\n\tresource_size_t offset;\n};\n\nstatic void bcm2835aux_rs485_start_tx(struct uart_8250_port *up)\n{\n\tif (!(up->port.rs485.flags & SER_RS485_RX_DURING_TX)) {\n\t\tstruct bcm2835aux_data *data = dev_get_drvdata(up->port.dev);\n\n\t\tdata->cntl &= ~BCM2835_AUX_UART_CNTL_RXEN;\n\t\tserial_out(up, BCM2835_AUX_UART_CNTL, data->cntl);\n\t}\n\n\t \n\tif (up->port.rs485.flags & SER_RS485_RTS_ON_SEND)\n\t\tserial8250_out_MCR(up, 0);\n\telse\n\t\tserial8250_out_MCR(up, UART_MCR_RTS);\n}\n\nstatic void bcm2835aux_rs485_stop_tx(struct uart_8250_port *up)\n{\n\tif (up->port.rs485.flags & SER_RS485_RTS_AFTER_SEND)\n\t\tserial8250_out_MCR(up, 0);\n\telse\n\t\tserial8250_out_MCR(up, UART_MCR_RTS);\n\n\tif (!(up->port.rs485.flags & SER_RS485_RX_DURING_TX)) {\n\t\tstruct bcm2835aux_data *data = dev_get_drvdata(up->port.dev);\n\n\t\tdata->cntl |= BCM2835_AUX_UART_CNTL_RXEN;\n\t\tserial_out(up, BCM2835_AUX_UART_CNTL, data->cntl);\n\t}\n}\n\nstatic int bcm2835aux_serial_probe(struct platform_device *pdev)\n{\n\tconst struct bcm2835_aux_serial_driver_data *bcm_data;\n\tstruct uart_8250_port up = { };\n\tstruct bcm2835aux_data *data;\n\tresource_size_t offset = 0;\n\tstruct resource *res;\n\tunsigned int uartclk;\n\tint ret;\n\n\t \n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tup.capabilities = UART_CAP_FIFO | UART_CAP_MINI;\n\tup.port.dev = &pdev->dev;\n\tup.port.regshift = 2;\n\tup.port.type = PORT_16550;\n\tup.port.iotype = UPIO_MEM;\n\tup.port.fifosize = 8;\n\tup.port.flags = UPF_SHARE_IRQ | UPF_FIXED_PORT | UPF_FIXED_TYPE |\n\t\t\tUPF_SKIP_TEST | UPF_IOREMAP;\n\tup.port.rs485_config = serial8250_em485_config;\n\tup.port.rs485_supported = serial8250_em485_supported;\n\tup.rs485_start_tx = bcm2835aux_rs485_start_tx;\n\tup.rs485_stop_tx = bcm2835aux_rs485_stop_tx;\n\n\t \n\tdata->cntl = BCM2835_AUX_UART_CNTL_RXEN | BCM2835_AUX_UART_CNTL_TXEN;\n\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tdata->clk = devm_clk_get_optional(&pdev->dev, NULL);\n\tif (IS_ERR(data->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->clk), \"could not get clk\\n\");\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tup.port.irq = ret;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"memory resource not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tbcm_data = device_get_match_data(&pdev->dev);\n\n\t \n\tif (bcm_data)\n\t\toffset = bcm_data->offset;\n\n\tup.port.mapbase = res->start + offset;\n\tup.port.mapsize = resource_size(res) - offset;\n\n\t \n\tret = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\tif (ret >= 0)\n\t\tup.port.line = ret;\n\n\t \n\tret = clk_prepare_enable(data->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to enable uart clock - %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tuartclk = clk_get_rate(data->clk);\n\tif (!uartclk) {\n\t\tret = device_property_read_u32(&pdev->dev, \"clock-frequency\", &uartclk);\n\t\tif (ret) {\n\t\t\tdev_err_probe(&pdev->dev, ret, \"could not get clk rate\\n\");\n\t\t\tgoto dis_clk;\n\t\t}\n\t}\n\n\t \n\tup.port.uartclk = uartclk * 2;\n\n\t \n\tret = serial8250_register_8250_port(&up);\n\tif (ret < 0) {\n\t\tdev_err_probe(&pdev->dev, ret, \"unable to register 8250 port\\n\");\n\t\tgoto dis_clk;\n\t}\n\tdata->line = ret;\n\n\treturn 0;\n\ndis_clk:\n\tclk_disable_unprepare(data->clk);\n\treturn ret;\n}\n\nstatic int bcm2835aux_serial_remove(struct platform_device *pdev)\n{\n\tstruct bcm2835aux_data *data = platform_get_drvdata(pdev);\n\n\tserial8250_unregister_port(data->line);\n\tclk_disable_unprepare(data->clk);\n\n\treturn 0;\n}\n\nstatic const struct bcm2835_aux_serial_driver_data bcm2835_acpi_data = {\n\t.offset = 0x40,\n};\n\nstatic const struct of_device_id bcm2835aux_serial_match[] = {\n\t{ .compatible = \"brcm,bcm2835-aux-uart\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bcm2835aux_serial_match);\n\nstatic const struct acpi_device_id bcm2835aux_serial_acpi_match[] = {\n\t{ \"BCM2836\", (kernel_ulong_t)&bcm2835_acpi_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, bcm2835aux_serial_acpi_match);\n\nstatic struct platform_driver bcm2835aux_serial_driver = {\n\t.driver = {\n\t\t.name = \"bcm2835-aux-uart\",\n\t\t.of_match_table = bcm2835aux_serial_match,\n\t\t.acpi_match_table = bcm2835aux_serial_acpi_match,\n\t},\n\t.probe  = bcm2835aux_serial_probe,\n\t.remove = bcm2835aux_serial_remove,\n};\nmodule_platform_driver(bcm2835aux_serial_driver);\n\n#ifdef CONFIG_SERIAL_8250_CONSOLE\n\nstatic int __init early_bcm2835aux_setup(struct earlycon_device *device,\n\t\t\t\t\tconst char *options)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->port.iotype = UPIO_MEM32;\n\tdevice->port.regshift = 2;\n\n\treturn early_serial8250_setup(device, NULL);\n}\n\nOF_EARLYCON_DECLARE(bcm2835aux, \"brcm,bcm2835-aux-uart\",\n\t\t    early_bcm2835aux_setup);\n#endif\n\nMODULE_DESCRIPTION(\"BCM2835 auxiliar UART driver\");\nMODULE_AUTHOR(\"Martin Sperl <kernel@martin.sperl.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}