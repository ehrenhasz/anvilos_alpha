{
  "module_name": "8250_acorn.c",
  "hash_id": "40ebff29f1d6da6d59dfd3b35f104b4e9bd1630e625b41016045a54d33aa4564",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_acorn.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/tty.h>\n#include <linux/serial_core.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/init.h>\n\n#include <asm/io.h>\n#include <asm/ecard.h>\n#include <asm/string.h>\n\n#include \"8250.h\"\n\n#define MAX_PORTS\t3\n\nstruct serial_card_type {\n\tunsigned int\tnum_ports;\n\tunsigned int\tuartclk;\n\tunsigned int\ttype;\n\tunsigned int\toffset[MAX_PORTS];\n};\n\nstruct serial_card_info {\n\tunsigned int\tnum_ports;\n\tint\t\tports[MAX_PORTS];\n\tvoid __iomem *vaddr;\n};\n\nstatic int\nserial_card_probe(struct expansion_card *ec, const struct ecard_id *id)\n{\n\tstruct serial_card_info *info;\n\tstruct serial_card_type *type = id->data;\n\tstruct uart_8250_port uart;\n\tunsigned long bus_addr;\n\tunsigned int i;\n\n\tinfo = kzalloc(sizeof(struct serial_card_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->num_ports = type->num_ports;\n\n\tbus_addr = ecard_resource_start(ec, type->type);\n\tinfo->vaddr = ecardm_iomap(ec, type->type, 0, 0);\n\tif (!info->vaddr) {\n\t\tkfree(info);\n\t\treturn -ENOMEM;\n\t}\n\n\tecard_set_drvdata(ec, info);\n\n\tmemset(&uart, 0, sizeof(struct uart_8250_port));\n\tuart.port.irq\t= ec->irq;\n\tuart.port.flags\t= UPF_BOOT_AUTOCONF | UPF_SHARE_IRQ;\n\tuart.port.uartclk\t= type->uartclk;\n\tuart.port.iotype\t= UPIO_MEM;\n\tuart.port.regshift\t= 2;\n\tuart.port.dev\t= &ec->dev;\n\n\tfor (i = 0; i < info->num_ports; i++) {\n\t\tuart.port.membase = info->vaddr + type->offset[i];\n\t\tuart.port.mapbase = bus_addr + type->offset[i];\n\n\t\tinfo->ports[i] = serial8250_register_8250_port(&uart);\n\t}\n\n\treturn 0;\n}\n\nstatic void serial_card_remove(struct expansion_card *ec)\n{\n\tstruct serial_card_info *info = ecard_get_drvdata(ec);\n\tint i;\n\n\tecard_set_drvdata(ec, NULL);\n\n\tfor (i = 0; i < info->num_ports; i++)\n\t\tif (info->ports[i] > 0)\n\t\t\tserial8250_unregister_port(info->ports[i]);\n\n\tkfree(info);\n}\n\nstatic struct serial_card_type atomwide_type = {\n\t.num_ports\t= 3,\n\t.uartclk\t= 7372800,\n\t.type\t\t= ECARD_RES_IOCSLOW,\n\t.offset\t\t= { 0x2800, 0x2400, 0x2000 },\n};\n\nstatic struct serial_card_type serport_type = {\n\t.num_ports\t= 2,\n\t.uartclk\t= 3686400,\n\t.type\t\t= ECARD_RES_IOCSLOW,\n\t.offset\t\t= { 0x2000, 0x2020 },\n};\n\nstatic const struct ecard_id serial_cids[] = {\n\t{ MANU_ATOMWIDE,\tPROD_ATOMWIDE_3PSERIAL,\t&atomwide_type\t},\n\t{ MANU_SERPORT,\t\tPROD_SERPORT_DSPORT,\t&serport_type\t},\n\t{ 0xffff, 0xffff }\n};\n\nstatic struct ecard_driver serial_card_driver = {\n\t.probe\t\t= serial_card_probe,\n\t.remove\t\t= serial_card_remove,\n\t.id_table\t= serial_cids,\n\t.drv = {\n\t\t.name\t= \"8250_acorn\",\n\t},\n};\n\nstatic int __init serial_card_init(void)\n{\n\treturn ecard_register_driver(&serial_card_driver);\n}\n\nstatic void __exit serial_card_exit(void)\n{\n\tecard_remove_driver(&serial_card_driver);\n}\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"Acorn 8250-compatible serial port expansion card driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(serial_card_init);\nmodule_exit(serial_card_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}