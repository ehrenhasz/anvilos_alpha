{
  "module_name": "8250_dma.c",
  "hash_id": "723ba1f24815008b2bbe3e56cdd316a49a0a3d6af2da87e042934b14494288ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_dma.c",
  "human_readable_source": "\n \n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_reg.h>\n#include <linux/dma-mapping.h>\n\n#include \"8250.h\"\n\nstatic void __dma_tx_complete(void *param)\n{\n\tstruct uart_8250_port\t*p = param;\n\tstruct uart_8250_dma\t*dma = p->dma;\n\tstruct circ_buf\t\t*xmit = &p->port.state->xmit;\n\tunsigned long\tflags;\n\tint\t\tret;\n\n\tdma_sync_single_for_cpu(dma->txchan->device->dev, dma->tx_addr,\n\t\t\t\tUART_XMIT_SIZE, DMA_TO_DEVICE);\n\n\tspin_lock_irqsave(&p->port.lock, flags);\n\n\tdma->tx_running = 0;\n\n\tuart_xmit_advance(&p->port, dma->tx_size);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&p->port);\n\n\tret = serial8250_tx_dma(p);\n\tif (ret || !dma->tx_running)\n\t\tserial8250_set_THRI(p);\n\n\tspin_unlock_irqrestore(&p->port.lock, flags);\n}\n\nstatic void __dma_rx_complete(struct uart_8250_port *p)\n{\n\tstruct uart_8250_dma\t*dma = p->dma;\n\tstruct tty_port\t\t*tty_port = &p->port.state->port;\n\tstruct dma_tx_state\tstate;\n\tenum dma_status\t\tdma_status;\n\tint\t\t\tcount;\n\n\t \n\tdma_status = dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);\n\tif (dma_status == DMA_IN_PROGRESS)\n\t\treturn;\n\n\tcount = dma->rx_size - state.residue;\n\n\ttty_insert_flip_string(tty_port, dma->rx_buf, count);\n\tp->port.icount.rx += count;\n\tdma->rx_running = 0;\n\n\ttty_flip_buffer_push(tty_port);\n}\n\nstatic void dma_rx_complete(void *param)\n{\n\tstruct uart_8250_port *p = param;\n\tstruct uart_8250_dma *dma = p->dma;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&p->port.lock, flags);\n\tif (dma->rx_running)\n\t\t__dma_rx_complete(p);\n\n\t \n\tif (!dma->rx_running && (serial_lsr_in(p) & UART_LSR_DR))\n\t\tp->dma->rx_dma(p);\n\tspin_unlock_irqrestore(&p->port.lock, flags);\n}\n\nint serial8250_tx_dma(struct uart_8250_port *p)\n{\n\tstruct uart_8250_dma\t\t*dma = p->dma;\n\tstruct circ_buf\t\t\t*xmit = &p->port.state->xmit;\n\tstruct dma_async_tx_descriptor\t*desc;\n\tstruct uart_port\t\t*up = &p->port;\n\tint ret;\n\n\tif (dma->tx_running) {\n\t\tif (up->x_char) {\n\t\t\tdmaengine_pause(dma->txchan);\n\t\t\tuart_xchar_out(up, UART_TX);\n\t\t\tdmaengine_resume(dma->txchan);\n\t\t}\n\t\treturn 0;\n\t} else if (up->x_char) {\n\t\tuart_xchar_out(up, UART_TX);\n\t}\n\n\tif (uart_tx_stopped(&p->port) || uart_circ_empty(xmit)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tdma->tx_size = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\n\tserial8250_do_prepare_tx_dma(p);\n\n\tdesc = dmaengine_prep_slave_single(dma->txchan,\n\t\t\t\t\t   dma->tx_addr + xmit->tail,\n\t\t\t\t\t   dma->tx_size, DMA_MEM_TO_DEV,\n\t\t\t\t\t   DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tdma->tx_running = 1;\n\tdesc->callback = __dma_tx_complete;\n\tdesc->callback_param = p;\n\n\tdma->tx_cookie = dmaengine_submit(desc);\n\n\tdma_sync_single_for_device(dma->txchan->device->dev, dma->tx_addr,\n\t\t\t\t   UART_XMIT_SIZE, DMA_TO_DEVICE);\n\n\tdma_async_issue_pending(dma->txchan);\n\tserial8250_clear_THRI(p);\n\tdma->tx_err = 0;\n\n\treturn 0;\nerr:\n\tdma->tx_err = 1;\n\treturn ret;\n}\n\nint serial8250_rx_dma(struct uart_8250_port *p)\n{\n\tstruct uart_8250_dma\t\t*dma = p->dma;\n\tstruct dma_async_tx_descriptor\t*desc;\n\n\tif (dma->rx_running)\n\t\treturn 0;\n\n\tserial8250_do_prepare_rx_dma(p);\n\n\tdesc = dmaengine_prep_slave_single(dma->rxchan, dma->rx_addr,\n\t\t\t\t\t   dma->rx_size, DMA_DEV_TO_MEM,\n\t\t\t\t\t   DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc)\n\t\treturn -EBUSY;\n\n\tdma->rx_running = 1;\n\tdesc->callback = dma_rx_complete;\n\tdesc->callback_param = p;\n\n\tdma->rx_cookie = dmaengine_submit(desc);\n\n\tdma_async_issue_pending(dma->rxchan);\n\n\treturn 0;\n}\n\nvoid serial8250_rx_dma_flush(struct uart_8250_port *p)\n{\n\tstruct uart_8250_dma *dma = p->dma;\n\n\tif (dma->rx_running) {\n\t\tdmaengine_pause(dma->rxchan);\n\t\t__dma_rx_complete(p);\n\t\tdmaengine_terminate_async(dma->rxchan);\n\t}\n}\nEXPORT_SYMBOL_GPL(serial8250_rx_dma_flush);\n\nint serial8250_request_dma(struct uart_8250_port *p)\n{\n\tstruct uart_8250_dma\t*dma = p->dma;\n\tphys_addr_t rx_dma_addr = dma->rx_dma_addr ?\n\t\t\t\t  dma->rx_dma_addr : p->port.mapbase;\n\tphys_addr_t tx_dma_addr = dma->tx_dma_addr ?\n\t\t\t\t  dma->tx_dma_addr : p->port.mapbase;\n\tdma_cap_mask_t\t\tmask;\n\tstruct dma_slave_caps\tcaps;\n\tint\t\t\tret;\n\n\t \n\tdma->rxconf.direction\t\t= DMA_DEV_TO_MEM;\n\tdma->rxconf.src_addr_width\t= DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma->rxconf.src_addr\t\t= rx_dma_addr + UART_RX;\n\n\tdma->txconf.direction\t\t= DMA_MEM_TO_DEV;\n\tdma->txconf.dst_addr_width\t= DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma->txconf.dst_addr\t\t= tx_dma_addr + UART_TX;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\t \n\tdma->rxchan = dma_request_slave_channel_compat(mask,\n\t\t\t\t\t\t       dma->fn, dma->rx_param,\n\t\t\t\t\t\t       p->port.dev, \"rx\");\n\tif (!dma->rxchan)\n\t\treturn -ENODEV;\n\n\t \n\tret = dma_get_slave_caps(dma->rxchan, &caps);\n\tif (ret)\n\t\tgoto release_rx;\n\tif (!caps.cmd_pause || !caps.cmd_terminate ||\n\t    caps.residue_granularity == DMA_RESIDUE_GRANULARITY_DESCRIPTOR) {\n\t\tret = -EINVAL;\n\t\tgoto release_rx;\n\t}\n\n\tdmaengine_slave_config(dma->rxchan, &dma->rxconf);\n\n\t \n\tdma->txchan = dma_request_slave_channel_compat(mask,\n\t\t\t\t\t\t       dma->fn, dma->tx_param,\n\t\t\t\t\t\t       p->port.dev, \"tx\");\n\tif (!dma->txchan) {\n\t\tret = -ENODEV;\n\t\tgoto release_rx;\n\t}\n\n\t \n\tret = dma_get_slave_caps(dma->txchan, &caps);\n\tif (ret)\n\t\tgoto err;\n\tif (!caps.cmd_terminate) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdmaengine_slave_config(dma->txchan, &dma->txconf);\n\n\t \n\tif (!dma->rx_size)\n\t\tdma->rx_size = PAGE_SIZE;\n\n\tdma->rx_buf = dma_alloc_coherent(dma->rxchan->device->dev, dma->rx_size,\n\t\t\t\t\t&dma->rx_addr, GFP_KERNEL);\n\tif (!dma->rx_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tdma->tx_addr = dma_map_single(dma->txchan->device->dev,\n\t\t\t\t\tp->port.state->xmit.buf,\n\t\t\t\t\tUART_XMIT_SIZE,\n\t\t\t\t\tDMA_TO_DEVICE);\n\tif (dma_mapping_error(dma->txchan->device->dev, dma->tx_addr)) {\n\t\tdma_free_coherent(dma->rxchan->device->dev, dma->rx_size,\n\t\t\t\t  dma->rx_buf, dma->rx_addr);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev_dbg_ratelimited(p->port.dev, \"got both dma channels\\n\");\n\n\treturn 0;\nerr:\n\tdma_release_channel(dma->txchan);\nrelease_rx:\n\tdma_release_channel(dma->rxchan);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(serial8250_request_dma);\n\nvoid serial8250_release_dma(struct uart_8250_port *p)\n{\n\tstruct uart_8250_dma *dma = p->dma;\n\n\tif (!dma)\n\t\treturn;\n\n\t \n\tdmaengine_terminate_sync(dma->rxchan);\n\tdma_free_coherent(dma->rxchan->device->dev, dma->rx_size, dma->rx_buf,\n\t\t\t  dma->rx_addr);\n\tdma_release_channel(dma->rxchan);\n\tdma->rxchan = NULL;\n\n\t \n\tdmaengine_terminate_sync(dma->txchan);\n\tdma_unmap_single(dma->txchan->device->dev, dma->tx_addr,\n\t\t\t UART_XMIT_SIZE, DMA_TO_DEVICE);\n\tdma_release_channel(dma->txchan);\n\tdma->txchan = NULL;\n\tdma->tx_running = 0;\n\n\tdev_dbg_ratelimited(p->port.dev, \"dma channels released\\n\");\n}\nEXPORT_SYMBOL_GPL(serial8250_release_dma);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}