{
  "module_name": "8250_pci1xxxx.c",
  "hash_id": "bc45c1f8381fdb8f90bbd51f6e409025208e6398b3b08e18321281e5280ba719",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_pci1xxxx.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/units.h>\n#include <linux/tty.h>\n\n#include <asm/byteorder.h>\n\n#include \"8250.h\"\n#include \"8250_pcilib.h\"\n\n#define PCI_DEVICE_ID_EFAR_PCI12000\t\t0xa002\n#define PCI_DEVICE_ID_EFAR_PCI11010\t\t0xa012\n#define PCI_DEVICE_ID_EFAR_PCI11101\t\t0xa022\n#define PCI_DEVICE_ID_EFAR_PCI11400\t\t0xa032\n#define PCI_DEVICE_ID_EFAR_PCI11414\t\t0xa042\n\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_4p\t0x0001\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_3p012\t0x0002\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_3p013\t0x0003\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_3p023\t0x0004\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_3p123\t0x0005\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p01\t0x0006\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p02\t0x0007\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p03\t0x0008\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p12\t0x0009\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p13\t0x000a\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p23\t0x000b\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_1p0\t0x000c\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_1p1\t0x000d\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_1p2\t0x000e\n#define PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_1p3\t0x000f\n\n#define PCI_SUBDEVICE_ID_EFAR_PCI12000\t\tPCI_DEVICE_ID_EFAR_PCI12000\n#define PCI_SUBDEVICE_ID_EFAR_PCI11010\t\tPCI_DEVICE_ID_EFAR_PCI11010\n#define PCI_SUBDEVICE_ID_EFAR_PCI11101\t\tPCI_DEVICE_ID_EFAR_PCI11101\n#define PCI_SUBDEVICE_ID_EFAR_PCI11400\t\tPCI_DEVICE_ID_EFAR_PCI11400\n#define PCI_SUBDEVICE_ID_EFAR_PCI11414\t\tPCI_DEVICE_ID_EFAR_PCI11414\n\n#define UART_ACTV_REG\t\t\t\t0x11\n#define UART_BLOCK_SET_ACTIVE\t\t\tBIT(0)\n\n#define UART_PCI_CTRL_REG\t\t\t0x80\n#define UART_PCI_CTRL_SET_MULTIPLE_MSI\t\tBIT(4)\n#define UART_PCI_CTRL_D3_CLK_ENABLE\t\tBIT(0)\n\n#define ADCL_CFG_REG\t\t\t\t0x40\n#define ADCL_CFG_POL_SEL\t\t\tBIT(2)\n#define ADCL_CFG_PIN_SEL\t\t\tBIT(1)\n#define ADCL_CFG_EN\t\t\t\tBIT(0)\n\n#define UART_BIT_SAMPLE_CNT\t\t\t16\n#define BAUD_CLOCK_DIV_INT_MSK\t\t\tGENMASK(31, 8)\n#define ADCL_CFG_RTS_DELAY_MASK\t\t\tGENMASK(11, 8)\n#define UART_CLOCK_DEFAULT\t\t\t(62500 * HZ_PER_KHZ)\n\n#define UART_WAKE_REG\t\t\t\t0x8C\n#define UART_WAKE_MASK_REG\t\t\t0x90\n#define UART_WAKE_N_PIN\t\t\t\tBIT(2)\n#define UART_WAKE_NCTS\t\t\t\tBIT(1)\n#define UART_WAKE_INT\t\t\t\tBIT(0)\n#define UART_WAKE_SRCS\t\\\n\t(UART_WAKE_N_PIN | UART_WAKE_NCTS | UART_WAKE_INT)\n\n#define UART_BAUD_CLK_DIVISOR_REG\t\t0x54\n\n#define UART_RESET_REG\t\t\t\t0x94\n#define UART_RESET_D3_RESET_DISABLE\t\tBIT(16)\n\n#define MAX_PORTS\t\t\t\t4\n#define PORT_OFFSET\t\t\t\t0x100\n\nstatic const int logical_to_physical_port_idx[][MAX_PORTS] = {\n\t{0,  1,  2,  3},  \n\t{0,  1,  2,  3},  \n\t{0,  1,  2, -1},  \n\t{0,  1,  3, -1},  \n\t{0,  2,  3, -1},  \n\t{1,  2,  3, -1},  \n\t{0,  1, -1, -1},  \n\t{0,  2, -1, -1},  \n\t{0,  3, -1, -1},  \n\t{1,  2, -1, -1},  \n\t{1,  3, -1, -1},  \n\t{2,  3, -1, -1},  \n\t{0, -1, -1, -1},  \n\t{1, -1, -1, -1},  \n\t{2, -1, -1, -1},  \n\t{3, -1, -1, -1},  \n};\n\nstruct pci1xxxx_8250 {\n\tunsigned int nr;\n\tvoid __iomem *membase;\n\tint line[];\n};\n\nstatic int pci1xxxx_get_num_ports(struct pci_dev *dev)\n{\n\tswitch (dev->subsystem_device) {\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_1p0:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_1p1:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_1p2:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_1p3:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI12000:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI11010:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI11101:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI11400:\n\tdefault:\n\t\treturn 1;\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p01:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p02:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p03:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p12:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p13:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_2p23:\n\t\treturn 2;\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_3p012:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_3p123:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_3p013:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_3p023:\n\t\treturn 3;\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_4p:\n\tcase PCI_SUBDEVICE_ID_EFAR_PCI11414:\n\t\treturn 4;\n\t}\n}\n\nstatic unsigned int pci1xxxx_get_divisor(struct uart_port *port,\n\t\t\t\t\t unsigned int baud, unsigned int *frac)\n{\n\tunsigned int quot;\n\n\t \n\tquot = NSEC_PER_SEC / (baud * UART_BIT_SAMPLE_CNT);\n\t*frac = (NSEC_PER_SEC - quot * baud * UART_BIT_SAMPLE_CNT) *\n\t\t  255 / UART_BIT_SAMPLE_CNT / baud;\n\n\treturn quot;\n}\n\nstatic void pci1xxxx_set_divisor(struct uart_port *port, unsigned int baud,\n\t\t\t\t unsigned int quot, unsigned int frac)\n{\n\twritel(FIELD_PREP(BAUD_CLOCK_DIV_INT_MSK, quot) | frac,\n\t       port->membase + UART_BAUD_CLK_DIVISOR_REG);\n}\n\nstatic int pci1xxxx_rs485_config(struct uart_port *port,\n\t\t\t\t struct ktermios *termios,\n\t\t\t\t struct serial_rs485 *rs485)\n{\n\tu32 delay_in_baud_periods;\n\tu32 baud_period_in_ns;\n\tu32 mode_cfg = 0;\n\tu32 clock_div;\n\n\t \n\tif (rs485->flags & SER_RS485_ENABLED) {\n\t\tmode_cfg = ADCL_CFG_EN | ADCL_CFG_PIN_SEL;\n\n\t\tif (!(rs485->flags & SER_RS485_RTS_ON_SEND))\n\t\t\tmode_cfg |= ADCL_CFG_POL_SEL;\n\n\t\tif (rs485->delay_rts_after_send) {\n\t\t\tclock_div = readl(port->membase + UART_BAUD_CLK_DIVISOR_REG);\n\t\t\tbaud_period_in_ns =\n\t\t\t\tFIELD_GET(BAUD_CLOCK_DIV_INT_MSK, clock_div) *\n\t\t\t\tUART_BIT_SAMPLE_CNT;\n\t\t\tdelay_in_baud_periods =\n\t\t\t\trs485->delay_rts_after_send * NSEC_PER_MSEC /\n\t\t\t\tbaud_period_in_ns;\n\t\t\tdelay_in_baud_periods =\n\t\t\t\tmin_t(u32, delay_in_baud_periods,\n\t\t\t\t      FIELD_MAX(ADCL_CFG_RTS_DELAY_MASK));\n\t\t\tmode_cfg |= FIELD_PREP(ADCL_CFG_RTS_DELAY_MASK,\n\t\t\t\t\t   delay_in_baud_periods);\n\t\t\trs485->delay_rts_after_send =\n\t\t\t\tbaud_period_in_ns * delay_in_baud_periods /\n\t\t\t\tNSEC_PER_MSEC;\n\t\t}\n\t}\n\twritel(mode_cfg, port->membase + ADCL_CFG_REG);\n\treturn 0;\n}\n\nstatic const struct serial_rs485 pci1xxxx_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND |\n\t\t SER_RS485_RTS_AFTER_SEND,\n\t.delay_rts_after_send = 1,\n\t \n};\n\nstatic bool pci1xxxx_port_suspend(int line)\n{\n\tstruct uart_8250_port *up = serial8250_get_port(line);\n\tstruct uart_port *port = &up->port;\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned long flags;\n\tbool ret = false;\n\tu8 wakeup_mask;\n\n\tmutex_lock(&tport->mutex);\n\tif (port->suspended == 0 && port->dev) {\n\t\twakeup_mask = readb(up->port.membase + UART_WAKE_MASK_REG);\n\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->mctrl &= ~TIOCM_OUT2;\n\t\tport->ops->set_mctrl(port, port->mctrl);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\tret = (wakeup_mask & UART_WAKE_SRCS) != UART_WAKE_SRCS;\n\t}\n\n\twriteb(UART_WAKE_SRCS, port->membase + UART_WAKE_REG);\n\tmutex_unlock(&tport->mutex);\n\n\treturn ret;\n}\n\nstatic void pci1xxxx_port_resume(int line)\n{\n\tstruct uart_8250_port *up = serial8250_get_port(line);\n\tstruct uart_port *port = &up->port;\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned long flags;\n\n\tmutex_lock(&tport->mutex);\n\twriteb(UART_BLOCK_SET_ACTIVE, port->membase + UART_ACTV_REG);\n\twriteb(UART_WAKE_SRCS, port->membase + UART_WAKE_REG);\n\n\tif (port->suspended == 0) {\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->mctrl |= TIOCM_OUT2;\n\t\tport->ops->set_mctrl(port, port->mctrl);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t}\n\tmutex_unlock(&tport->mutex);\n}\n\nstatic int pci1xxxx_suspend(struct device *dev)\n{\n\tstruct pci1xxxx_8250 *priv = dev_get_drvdata(dev);\n\tstruct pci_dev *pcidev = to_pci_dev(dev);\n\tbool wakeup = false;\n\tunsigned int data;\n\tvoid __iomem *p;\n\tint i;\n\n\tfor (i = 0; i < priv->nr; i++) {\n\t\tif (priv->line[i] >= 0) {\n\t\t\tserial8250_suspend_port(priv->line[i]);\n\t\t\twakeup |= pci1xxxx_port_suspend(priv->line[i]);\n\t\t}\n\t}\n\n\tp = pci_ioremap_bar(pcidev, 0);\n\tif (!p) {\n\t\tdev_err(dev, \"remapping of bar 0 memory failed\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = readl(p + UART_RESET_REG);\n\twritel(data | UART_RESET_D3_RESET_DISABLE, p + UART_RESET_REG);\n\n\tif (wakeup)\n\t\twriteb(UART_PCI_CTRL_D3_CLK_ENABLE, p + UART_PCI_CTRL_REG);\n\n\tiounmap(p);\n\tdevice_set_wakeup_enable(dev, true);\n\tpci_wake_from_d3(pcidev, true);\n\n\treturn 0;\n}\n\nstatic int pci1xxxx_resume(struct device *dev)\n{\n\tstruct pci1xxxx_8250 *priv = dev_get_drvdata(dev);\n\tstruct pci_dev *pcidev = to_pci_dev(dev);\n\tunsigned int data;\n\tvoid __iomem *p;\n\tint i;\n\n\tp = pci_ioremap_bar(pcidev, 0);\n\tif (!p) {\n\t\tdev_err(dev, \"remapping of bar 0 memory failed\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = readl(p + UART_RESET_REG);\n\twritel(data & ~UART_RESET_D3_RESET_DISABLE, p + UART_RESET_REG);\n\tiounmap(p);\n\n\tfor (i = 0; i < priv->nr; i++) {\n\t\tif (priv->line[i] >= 0) {\n\t\t\tpci1xxxx_port_resume(priv->line[i]);\n\t\t\tserial8250_resume_port(priv->line[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pci1xxxx_setup(struct pci_dev *pdev,\n\t\t\t  struct uart_8250_port *port, int port_idx)\n{\n\tint ret;\n\n\tport->port.flags |= UPF_FIXED_TYPE | UPF_SKIP_TEST;\n\tport->port.type = PORT_MCHP16550A;\n\tport->port.set_termios = serial8250_do_set_termios;\n\tport->port.get_divisor = pci1xxxx_get_divisor;\n\tport->port.set_divisor = pci1xxxx_set_divisor;\n\tport->port.rs485_config = pci1xxxx_rs485_config;\n\tport->port.rs485_supported = pci1xxxx_rs485_supported;\n\n\tret = serial8250_pci_setup_port(pdev, port, 0, PORT_OFFSET * port_idx, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twriteb(UART_BLOCK_SET_ACTIVE, port->port.membase + UART_ACTV_REG);\n\twriteb(UART_WAKE_SRCS, port->port.membase + UART_WAKE_REG);\n\twriteb(UART_WAKE_N_PIN, port->port.membase + UART_WAKE_MASK_REG);\n\n\treturn 0;\n}\n\nstatic unsigned int pci1xxxx_get_max_port(int subsys_dev)\n{\n\tunsigned int i = MAX_PORTS;\n\n\tif (subsys_dev < ARRAY_SIZE(logical_to_physical_port_idx))\n\t\twhile (i--) {\n\t\t\tif (logical_to_physical_port_idx[subsys_dev][i] != -1)\n\t\t\t\treturn logical_to_physical_port_idx[subsys_dev][i] + 1;\n\t\t}\n\n\tif (subsys_dev == PCI_SUBDEVICE_ID_EFAR_PCI11414)\n\t\treturn 4;\n\n\treturn 1;\n}\n\nstatic int pci1xxxx_logical_to_physical_port_translate(int subsys_dev, int port)\n{\n\tif (subsys_dev < ARRAY_SIZE(logical_to_physical_port_idx))\n\t\treturn logical_to_physical_port_idx[subsys_dev][port];\n\n\treturn logical_to_physical_port_idx[0][port];\n}\n\nstatic int pci1xxxx_serial_probe(struct pci_dev *pdev,\n\t\t\t\t const struct pci_device_id *id)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pci1xxxx_8250 *priv;\n\tstruct uart_8250_port uart;\n\tunsigned int max_vec_reqd;\n\tunsigned int nr_ports, i;\n\tint num_vectors;\n\tint subsys_dev;\n\tint port_idx;\n\tint rc;\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tnr_ports = pci1xxxx_get_num_ports(pdev);\n\n\tpriv = devm_kzalloc(dev, struct_size(priv, line, nr_ports), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->membase = pci_ioremap_bar(pdev, 0);\n\tif (!priv->membase)\n\t\treturn -ENOMEM;\n\n\tpci_set_master(pdev);\n\n\tpriv->nr = nr_ports;\n\n\tsubsys_dev = pdev->subsystem_device;\n\tmax_vec_reqd = pci1xxxx_get_max_port(subsys_dev);\n\n\tnum_vectors = pci_alloc_irq_vectors(pdev, 1, max_vec_reqd, PCI_IRQ_ALL_TYPES);\n\tif (num_vectors < 0) {\n\t\tpci_iounmap(pdev, priv->membase);\n\t\treturn num_vectors;\n\t}\n\n\tmemset(&uart, 0, sizeof(uart));\n\tuart.port.flags = UPF_SHARE_IRQ | UPF_FIXED_PORT;\n\tuart.port.uartclk = UART_CLOCK_DEFAULT;\n\tuart.port.dev = dev;\n\n\tif (num_vectors == max_vec_reqd)\n\t\twriteb(UART_PCI_CTRL_SET_MULTIPLE_MSI, priv->membase + UART_PCI_CTRL_REG);\n\n\tfor (i = 0; i < nr_ports; i++) {\n\t\tpriv->line[i] = -ENODEV;\n\n\t\tport_idx = pci1xxxx_logical_to_physical_port_translate(subsys_dev, i);\n\n\t\tif (num_vectors == max_vec_reqd)\n\t\t\tuart.port.irq = pci_irq_vector(pdev, port_idx);\n\t\telse\n\t\t\tuart.port.irq = pci_irq_vector(pdev, 0);\n\n\t\trc = pci1xxxx_setup(pdev, &uart, port_idx);\n\t\tif (rc) {\n\t\t\tdev_warn(dev, \"Failed to setup port %u\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpriv->line[i] = serial8250_register_8250_port(&uart);\n\t\tif (priv->line[i] < 0) {\n\t\t\tdev_warn(dev,\n\t\t\t\t\"Couldn't register serial port %lx, irq %d, type %d, error %d\\n\",\n\t\t\t\tuart.port.iobase, uart.port.irq, uart.port.iotype,\n\t\t\t\tpriv->line[i]);\n\t\t}\n\t}\n\n\tpci_set_drvdata(pdev, priv);\n\n\treturn 0;\n}\n\nstatic void pci1xxxx_serial_remove(struct pci_dev *dev)\n{\n\tstruct pci1xxxx_8250 *priv = pci_get_drvdata(dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < priv->nr; i++) {\n\t\tif (priv->line[i] >= 0)\n\t\t\tserial8250_unregister_port(priv->line[i]);\n\t}\n\n\tpci_free_irq_vectors(dev);\n\tpci_iounmap(dev, priv->membase);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pci1xxxx_pm_ops, pci1xxxx_suspend, pci1xxxx_resume);\n\nstatic const struct pci_device_id pci1xxxx_pci_tbl[] = {\n\t{ PCI_VDEVICE(EFAR, PCI_DEVICE_ID_EFAR_PCI11010) },\n\t{ PCI_VDEVICE(EFAR, PCI_DEVICE_ID_EFAR_PCI11101) },\n\t{ PCI_VDEVICE(EFAR, PCI_DEVICE_ID_EFAR_PCI11400) },\n\t{ PCI_VDEVICE(EFAR, PCI_DEVICE_ID_EFAR_PCI11414) },\n\t{ PCI_VDEVICE(EFAR, PCI_DEVICE_ID_EFAR_PCI12000) },\n\t{}\n};\nMODULE_DEVICE_TABLE(pci, pci1xxxx_pci_tbl);\n\nstatic struct pci_driver pci1xxxx_pci_driver = {\n\t.name = \"pci1xxxx serial\",\n\t.probe = pci1xxxx_serial_probe,\n\t.remove = pci1xxxx_serial_remove,\n\t.driver = {\n\t\t.pm     = pm_sleep_ptr(&pci1xxxx_pm_ops),\n\t},\n\t.id_table = pci1xxxx_pci_tbl,\n};\nmodule_pci_driver(pci1xxxx_pci_driver);\n\nstatic_assert((ARRAY_SIZE(logical_to_physical_port_idx) == PCI_SUBDEVICE_ID_EFAR_PCI1XXXX_1p3 + 1));\n\nMODULE_IMPORT_NS(SERIAL_8250_PCI);\nMODULE_DESCRIPTION(\"Microchip Technology Inc. PCIe to UART module\");\nMODULE_AUTHOR(\"Kumaravel Thiagarajan <kumaravel.thiagarajan@microchip.com>\");\nMODULE_AUTHOR(\"Tharun Kumar P <tharunkumar.pasumarthi@microchip.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}