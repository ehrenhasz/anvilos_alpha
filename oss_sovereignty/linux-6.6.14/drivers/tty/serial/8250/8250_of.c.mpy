{
  "module_name": "8250_of.c",
  "hash_id": "8db21fb88e692394b362e6f96cdc87f502e67d162da417a0261985210be8dbac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_of.c",
  "human_readable_source": "\n \n#include <linux/console.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/serial_core.h>\n#include <linux/serial_reg.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n\n#include \"8250.h\"\n\nstruct of_serial_info {\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\tint type;\n\tint line;\n};\n\n \nstatic int of_platform_serial_setup(struct platform_device *ofdev,\n\t\t\tint type, struct uart_8250_port *up,\n\t\t\tstruct of_serial_info *info)\n{\n\tstruct resource resource;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct uart_port *port = &up->port;\n\tu32 clk, spd, prop;\n\tint ret, irq;\n\n\tmemset(port, 0, sizeof *port);\n\n\tpm_runtime_enable(&ofdev->dev);\n\tpm_runtime_get_sync(&ofdev->dev);\n\n\tif (of_property_read_u32(np, \"clock-frequency\", &clk)) {\n\n\t\t \n\t\tinfo->clk = devm_clk_get(&ofdev->dev, NULL);\n\t\tif (IS_ERR(info->clk)) {\n\t\t\tret = PTR_ERR(info->clk);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_warn(&ofdev->dev,\n\t\t\t\t\t \"failed to get clock: %d\\n\", ret);\n\t\t\tgoto err_pmruntime;\n\t\t}\n\n\t\tret = clk_prepare_enable(info->clk);\n\t\tif (ret < 0)\n\t\t\tgoto err_pmruntime;\n\n\t\tclk = clk_get_rate(info->clk);\n\t}\n\t \n\tif (of_property_read_u32(np, \"current-speed\", &spd) == 0)\n\t\tport->custom_divisor = clk / (16 * spd);\n\n\tret = of_address_to_resource(np, 0, &resource);\n\tif (ret) {\n\t\tdev_warn(&ofdev->dev, \"invalid address\\n\");\n\t\tgoto err_unprepare;\n\t}\n\n\tport->flags = UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF | UPF_FIXED_PORT |\n\t\t\t\t  UPF_FIXED_TYPE;\n\tspin_lock_init(&port->lock);\n\n\tif (resource_type(&resource) == IORESOURCE_IO) {\n\t\tport->iotype = UPIO_PORT;\n\t\tport->iobase = resource.start;\n\t} else {\n\t\tport->mapbase = resource.start;\n\t\tport->mapsize = resource_size(&resource);\n\n\t\t \n\t\tif (of_property_read_u32(np, \"reg-offset\", &prop) == 0) {\n\t\t\tif (prop >= port->mapsize) {\n\t\t\t\tdev_warn(&ofdev->dev, \"reg-offset %u exceeds region size %pa\\n\",\n\t\t\t\t\t prop, &port->mapsize);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_unprepare;\n\t\t\t}\n\n\t\t\tport->mapbase += prop;\n\t\t\tport->mapsize -= prop;\n\t\t}\n\n\t\tport->iotype = UPIO_MEM;\n\t\tif (of_property_read_u32(np, \"reg-io-width\", &prop) == 0) {\n\t\t\tswitch (prop) {\n\t\t\tcase 1:\n\t\t\t\tport->iotype = UPIO_MEM;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tport->iotype = UPIO_MEM16;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tport->iotype = of_device_is_big_endian(np) ?\n\t\t\t\t\t       UPIO_MEM32BE : UPIO_MEM32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_warn(&ofdev->dev, \"unsupported reg-io-width (%d)\\n\",\n\t\t\t\t\t prop);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_unprepare;\n\t\t\t}\n\t\t}\n\t\tport->flags |= UPF_IOREMAP;\n\t}\n\n\t \n\tif (of_device_is_compatible(np, \"mrvl,mmp-uart\"))\n\t\tport->regshift = 2;\n\n\t \n\tif (of_property_read_u32(np, \"reg-shift\", &prop) == 0)\n\t\tport->regshift = prop;\n\n\t \n\tif (of_property_read_u32(np, \"fifo-size\", &prop) == 0)\n\t\tport->fifosize = prop;\n\n\t \n\tret = of_alias_get_id(np, \"serial\");\n\tif (ret >= 0)\n\t\tport->line = ret;\n\n\tirq = of_irq_get(np, 0);\n\tif (irq < 0) {\n\t\tif (irq == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto err_unprepare;\n\t\t}\n\t\t \n\t\tirq = 0;\n\t}\n\n\tport->irq = irq;\n\n\tinfo->rst = devm_reset_control_get_optional_shared(&ofdev->dev, NULL);\n\tif (IS_ERR(info->rst)) {\n\t\tret = PTR_ERR(info->rst);\n\t\tgoto err_unprepare;\n\t}\n\n\tret = reset_control_deassert(info->rst);\n\tif (ret)\n\t\tgoto err_unprepare;\n\n\tport->type = type;\n\tport->uartclk = clk;\n\n\tif (of_property_read_bool(np, \"no-loopback-test\"))\n\t\tport->flags |= UPF_SKIP_TEST;\n\n\tport->dev = &ofdev->dev;\n\tport->rs485_config = serial8250_em485_config;\n\tport->rs485_supported = serial8250_em485_supported;\n\tup->rs485_start_tx = serial8250_em485_start_tx;\n\tup->rs485_stop_tx = serial8250_em485_stop_tx;\n\n\tswitch (type) {\n\tcase PORT_RT2880:\n\t\tret = rt288x_setup(port);\n\t\tif (ret)\n\t\t\tgoto err_unprepare;\n\t\tbreak;\n\t}\n\n\tif (IS_REACHABLE(CONFIG_SERIAL_8250_FSL) &&\n\t    (of_device_is_compatible(np, \"fsl,ns16550\") ||\n\t     of_device_is_compatible(np, \"fsl,16550-FIFO64\"))) {\n\t\tport->handle_irq = fsl8250_handle_irq;\n\t\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);\n\t}\n\n\treturn 0;\nerr_unprepare:\n\tclk_disable_unprepare(info->clk);\nerr_pmruntime:\n\tpm_runtime_put_sync(&ofdev->dev);\n\tpm_runtime_disable(&ofdev->dev);\n\treturn ret;\n}\n\n \nstatic int of_platform_serial_probe(struct platform_device *ofdev)\n{\n\tstruct of_serial_info *info;\n\tstruct uart_8250_port port8250;\n\tunsigned int port_type;\n\tu32 tx_threshold;\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_SERIAL_8250_BCM7271) &&\n\t    of_device_is_compatible(ofdev->dev.of_node, \"brcm,bcm7271-uart\"))\n\t\treturn -ENODEV;\n\n\tport_type = (unsigned long)of_device_get_match_data(&ofdev->dev);\n\tif (port_type == PORT_UNKNOWN)\n\t\treturn -EINVAL;\n\n\tif (of_property_read_bool(ofdev->dev.of_node, \"used-by-rtas\"))\n\t\treturn -EBUSY;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(&port8250, 0, sizeof(port8250));\n\tret = of_platform_serial_setup(ofdev, port_type, &port8250, info);\n\tif (ret)\n\t\tgoto err_free;\n\n\tif (port8250.port.fifosize)\n\t\tport8250.capabilities = UART_CAP_FIFO;\n\n\t \n\tif ((of_property_read_u32(ofdev->dev.of_node, \"tx-threshold\",\n\t\t\t\t  &tx_threshold) == 0) &&\n\t    (tx_threshold < port8250.port.fifosize))\n\t\tport8250.tx_loadsz = port8250.port.fifosize - tx_threshold;\n\n\tif (of_property_read_bool(ofdev->dev.of_node, \"auto-flow-control\"))\n\t\tport8250.capabilities |= UART_CAP_AFE;\n\n\tif (of_property_read_u32(ofdev->dev.of_node,\n\t\t\t\"overrun-throttle-ms\",\n\t\t\t&port8250.overrun_backoff_time_ms) != 0)\n\t\tport8250.overrun_backoff_time_ms = 0;\n\n\tret = serial8250_register_8250_port(&port8250);\n\tif (ret < 0)\n\t\tgoto err_dispose;\n\n\tinfo->type = port_type;\n\tinfo->line = ret;\n\tplatform_set_drvdata(ofdev, info);\n\treturn 0;\nerr_dispose:\n\tirq_dispose_mapping(port8250.port.irq);\n\tpm_runtime_put_sync(&ofdev->dev);\n\tpm_runtime_disable(&ofdev->dev);\n\tclk_disable_unprepare(info->clk);\nerr_free:\n\tkfree(info);\n\treturn ret;\n}\n\n \nstatic int of_platform_serial_remove(struct platform_device *ofdev)\n{\n\tstruct of_serial_info *info = platform_get_drvdata(ofdev);\n\n\tserial8250_unregister_port(info->line);\n\n\treset_control_assert(info->rst);\n\tpm_runtime_put_sync(&ofdev->dev);\n\tpm_runtime_disable(&ofdev->dev);\n\tclk_disable_unprepare(info->clk);\n\tkfree(info);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int of_serial_suspend(struct device *dev)\n{\n\tstruct of_serial_info *info = dev_get_drvdata(dev);\n\tstruct uart_8250_port *port8250 = serial8250_get_port(info->line);\n\tstruct uart_port *port = &port8250->port;\n\n\tserial8250_suspend_port(info->line);\n\n\tif (!uart_console(port) || console_suspend_enabled) {\n\t\tpm_runtime_put_sync(dev);\n\t\tclk_disable_unprepare(info->clk);\n\t}\n\treturn 0;\n}\n\nstatic int of_serial_resume(struct device *dev)\n{\n\tstruct of_serial_info *info = dev_get_drvdata(dev);\n\tstruct uart_8250_port *port8250 = serial8250_get_port(info->line);\n\tstruct uart_port *port = &port8250->port;\n\n\tif (!uart_console(port) || console_suspend_enabled) {\n\t\tpm_runtime_get_sync(dev);\n\t\tclk_prepare_enable(info->clk);\n\t}\n\n\tserial8250_resume_port(info->line);\n\n\treturn 0;\n}\n#endif\nstatic SIMPLE_DEV_PM_OPS(of_serial_pm_ops, of_serial_suspend, of_serial_resume);\n\n \nstatic const struct of_device_id of_platform_serial_table[] = {\n\t{ .compatible = \"ns8250\",   .data = (void *)PORT_8250, },\n\t{ .compatible = \"ns16450\",  .data = (void *)PORT_16450, },\n\t{ .compatible = \"ns16550a\", .data = (void *)PORT_16550A, },\n\t{ .compatible = \"ns16550\",  .data = (void *)PORT_16550, },\n\t{ .compatible = \"ns16750\",  .data = (void *)PORT_16750, },\n\t{ .compatible = \"ns16850\",  .data = (void *)PORT_16850, },\n\t{ .compatible = \"nxp,lpc3220-uart\", .data = (void *)PORT_LPC3220, },\n\t{ .compatible = \"ralink,rt2880-uart\", .data = (void *)PORT_RT2880, },\n\t{ .compatible = \"intel,xscale-uart\", .data = (void *)PORT_XSCALE, },\n\t{ .compatible = \"altr,16550-FIFO32\",\n\t\t.data = (void *)PORT_ALTR_16550_F32, },\n\t{ .compatible = \"altr,16550-FIFO64\",\n\t\t.data = (void *)PORT_ALTR_16550_F64, },\n\t{ .compatible = \"altr,16550-FIFO128\",\n\t\t.data = (void *)PORT_ALTR_16550_F128, },\n\t{ .compatible = \"fsl,16550-FIFO64\",\n\t\t.data = (void *)PORT_16550A_FSL64, },\n\t{ .compatible = \"mediatek,mtk-btif\",\n\t\t.data = (void *)PORT_MTK_BTIF, },\n\t{ .compatible = \"mrvl,mmp-uart\",\n\t\t.data = (void *)PORT_XSCALE, },\n\t{ .compatible = \"ti,da830-uart\", .data = (void *)PORT_DA830, },\n\t{ .compatible = \"nuvoton,wpcm450-uart\", .data = (void *)PORT_NPCM, },\n\t{ .compatible = \"nuvoton,npcm750-uart\", .data = (void *)PORT_NPCM, },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, of_platform_serial_table);\n\nstatic struct platform_driver of_platform_serial_driver = {\n\t.driver = {\n\t\t.name = \"of_serial\",\n\t\t.of_match_table = of_platform_serial_table,\n\t\t.pm = &of_serial_pm_ops,\n\t},\n\t.probe = of_platform_serial_probe,\n\t.remove = of_platform_serial_remove,\n};\n\nmodule_platform_driver(of_platform_serial_driver);\n\nMODULE_AUTHOR(\"Arnd Bergmann <arnd@arndb.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Serial Port driver for Open Firmware platform devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}