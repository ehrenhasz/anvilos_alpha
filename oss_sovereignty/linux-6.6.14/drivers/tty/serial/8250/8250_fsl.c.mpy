{
  "module_name": "8250_fsl.c",
  "hash_id": "423aec8f64783f45e4af0b867572eb321b72e5d402a69dd434db87320aa54440",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_fsl.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/serial_reg.h>\n#include <linux/serial_8250.h>\n\n#include \"8250.h\"\n\nint fsl8250_handle_irq(struct uart_port *port)\n{\n\tunsigned long flags;\n\tu16 lsr, orig_lsr;\n\tunsigned int iir;\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tiir = port->serial_in(port, UART_IIR);\n\tif (iir & UART_IIR_NO_INT) {\n\t\tspin_unlock_irqrestore(&up->port.lock, flags);\n\t\treturn 0;\n\t}\n\n\t \n\tif (unlikely(up->lsr_saved_flags & UART_LSR_BI)) {\n\t\tup->lsr_saved_flags &= ~UART_LSR_BI;\n\t\tport->serial_in(port, UART_RX);\n\t\tspin_unlock_irqrestore(&up->port.lock, flags);\n\t\treturn 1;\n\t}\n\n\tlsr = orig_lsr = up->port.serial_in(&up->port, UART_LSR);\n\n\t \n\tif ((lsr & (UART_LSR_DR | UART_LSR_BI)) &&\n\t    (up->ier & (UART_IER_RLSI | UART_IER_RDI))) {\n\t\tlsr = serial8250_rx_chars(up, lsr);\n\t}\n\n\t \n\tif ((orig_lsr & UART_LSR_OE) && (up->overrun_backoff_time_ms > 0)) {\n\t\tunsigned long delay;\n\n\t\tup->ier = port->serial_in(port, UART_IER);\n\t\tif (up->ier & (UART_IER_RLSI | UART_IER_RDI)) {\n\t\t\tport->ops->stop_rx(port);\n\t\t} else {\n\t\t\t \n\t\t\tcancel_delayed_work(&up->overrun_backoff);\n\t\t}\n\n\t\tdelay = msecs_to_jiffies(up->overrun_backoff_time_ms);\n\t\tschedule_delayed_work(&up->overrun_backoff, delay);\n\t}\n\n\tserial8250_modem_status(up);\n\n\tif ((lsr & UART_LSR_THRE) && (up->ier & UART_IER_THRI))\n\t\tserial8250_tx_chars(up);\n\n\tup->lsr_saved_flags |= orig_lsr & UART_LSR_BI;\n\n\tuart_unlock_and_check_sysrq_irqrestore(&up->port, flags);\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(fsl8250_handle_irq);\n\n#ifdef CONFIG_ACPI\nstruct fsl8250_data {\n\tint\tline;\n};\n\nstatic int fsl8250_acpi_probe(struct platform_device *pdev)\n{\n\tstruct fsl8250_data *data;\n\tstruct uart_8250_port port8250;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *regs;\n\n\tint ret, irq;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs) {\n\t\tdev_err(dev, \"no registers defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tmemset(&port8250, 0, sizeof(port8250));\n\n\tret = device_property_read_u32(dev, \"clock-frequency\",\n\t\t\t\t\t&port8250.port.uartclk);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_init(&port8250.port.lock);\n\n\tport8250.port.mapbase           = regs->start;\n\tport8250.port.irq               = irq;\n\tport8250.port.handle_irq        = fsl8250_handle_irq;\n\tport8250.port.type              = PORT_16550A;\n\tport8250.port.flags             = UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF\n\t\t\t\t\t\t| UPF_FIXED_PORT | UPF_IOREMAP\n\t\t\t\t\t\t| UPF_FIXED_TYPE;\n\tport8250.port.dev               = dev;\n\tport8250.port.mapsize           = resource_size(regs);\n\tport8250.port.iotype            = UPIO_MEM;\n\tport8250.port.irqflags          = IRQF_SHARED;\n\n\tport8250.port.membase = devm_ioremap(dev,  port8250.port.mapbase,\n\t\t\t\t\t\t\tport8250.port.mapsize);\n\tif (!port8250.port.membase)\n\t\treturn -ENOMEM;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->line = serial8250_register_8250_port(&port8250);\n\tif (data->line < 0)\n\t\treturn data->line;\n\n\tplatform_set_drvdata(pdev, data);\n\treturn 0;\n}\n\nstatic int fsl8250_acpi_remove(struct platform_device *pdev)\n{\n\tstruct fsl8250_data *data = platform_get_drvdata(pdev);\n\n\tserial8250_unregister_port(data->line);\n\treturn 0;\n}\n\nstatic const struct acpi_device_id fsl_8250_acpi_id[] = {\n\t{ \"NXP0018\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, fsl_8250_acpi_id);\n\nstatic struct platform_driver fsl8250_platform_driver = {\n\t.driver = {\n\t\t.name\t\t\t= \"fsl-16550-uart\",\n\t\t.acpi_match_table\t= ACPI_PTR(fsl_8250_acpi_id),\n\t},\n\t.probe\t\t\t= fsl8250_acpi_probe,\n\t.remove\t\t\t= fsl8250_acpi_remove,\n};\n\nmodule_platform_driver(fsl8250_platform_driver);\n#endif\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Handling of Freescale specific 8250 variants\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}