{
  "module_name": "8250_mtk.c",
  "hash_id": "19c78df26760066546e756c0bc99267311a43641cee2980f0ec347780836112c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_mtk.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/serial_8250.h>\n#include <linux/serial_reg.h>\n#include <linux/console.h>\n#include <linux/dma-mapping.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#include \"8250.h\"\n\n#define MTK_UART_HIGHS\t\t0x09\t \n#define MTK_UART_SAMPLE_COUNT\t0x0a\t \n#define MTK_UART_SAMPLE_POINT\t0x0b\t \n#define MTK_UART_RATE_FIX\t0x0d\t \n#define MTK_UART_ESCAPE_DAT\t0x10\t \n#define MTK_UART_ESCAPE_EN\t0x11\t \n#define MTK_UART_DMA_EN\t\t0x13\t \n#define MTK_UART_RXTRI_AD\t0x14\t \n#define MTK_UART_FRACDIV_L\t0x15\t \n#define MTK_UART_FRACDIV_M\t0x16\t \n#define MTK_UART_DEBUG0\t0x18\n#define MTK_UART_IER_XOFFI\t0x20\t \n#define MTK_UART_IER_RTSI\t0x40\t \n#define MTK_UART_IER_CTSI\t0x80\t \n\n#define MTK_UART_EFR\t\t38\t \n#define MTK_UART_EFR_EN\t\t0x10\t \n#define MTK_UART_EFR_RTS\t0x40\t \n#define MTK_UART_EFR_CTS\t0x80\t \n#define MTK_UART_EFR_NO_SW_FC\t0x0\t \n#define MTK_UART_EFR_XON1_XOFF1\t0xa\t \n#define MTK_UART_EFR_XON2_XOFF2\t0x5\t \n#define MTK_UART_EFR_SW_FC_MASK\t0xf\t \n#define MTK_UART_EFR_HW_FC\t(MTK_UART_EFR_RTS | MTK_UART_EFR_CTS)\n#define MTK_UART_DMA_EN_TX\t0x2\n#define MTK_UART_DMA_EN_RX\t0x5\n\n#define MTK_UART_ESCAPE_CHAR\t0x77\t \n#define MTK_UART_RX_SIZE\t0x8000\n#define MTK_UART_TX_TRIGGER\t1\n#define MTK_UART_RX_TRIGGER\tMTK_UART_RX_SIZE\n\n#define MTK_UART_XON1\t\t40\t \n#define MTK_UART_XOFF1\t\t42\t \n\n#ifdef CONFIG_SERIAL_8250_DMA\nenum dma_rx_status {\n\tDMA_RX_START = 0,\n\tDMA_RX_RUNNING = 1,\n\tDMA_RX_SHUTDOWN = 2,\n};\n#endif\n\nstruct mtk8250_data {\n\tint\t\t\tline;\n\tunsigned int\t\trx_pos;\n\tunsigned int\t\tclk_count;\n\tstruct clk\t\t*uart_clk;\n\tstruct clk\t\t*bus_clk;\n\tstruct uart_8250_dma\t*dma;\n#ifdef CONFIG_SERIAL_8250_DMA\n\tenum dma_rx_status\trx_status;\n#endif\n\tint\t\t\trx_wakeup_irq;\n};\n\n \nenum {\n\tMTK_UART_FC_NONE,\n\tMTK_UART_FC_SW,\n\tMTK_UART_FC_HW,\n};\n\n#ifdef CONFIG_SERIAL_8250_DMA\nstatic void mtk8250_rx_dma(struct uart_8250_port *up);\n\nstatic void mtk8250_dma_rx_complete(void *param)\n{\n\tstruct uart_8250_port *up = param;\n\tstruct uart_8250_dma *dma = up->dma;\n\tstruct mtk8250_data *data = up->port.private_data;\n\tstruct tty_port *tty_port = &up->port.state->port;\n\tstruct dma_tx_state state;\n\tint copied, total, cnt;\n\tunsigned char *ptr;\n\tunsigned long flags;\n\n\tif (data->rx_status == DMA_RX_SHUTDOWN)\n\t\treturn;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tdmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);\n\ttotal = dma->rx_size - state.residue;\n\tcnt = total;\n\n\tif ((data->rx_pos + cnt) > dma->rx_size)\n\t\tcnt = dma->rx_size - data->rx_pos;\n\n\tptr = (unsigned char *)(data->rx_pos + dma->rx_buf);\n\tcopied = tty_insert_flip_string(tty_port, ptr, cnt);\n\tdata->rx_pos += cnt;\n\n\tif (total > cnt) {\n\t\tptr = (unsigned char *)(dma->rx_buf);\n\t\tcnt = total - cnt;\n\t\tcopied += tty_insert_flip_string(tty_port, ptr, cnt);\n\t\tdata->rx_pos = cnt;\n\t}\n\n\tup->port.icount.rx += copied;\n\n\ttty_flip_buffer_push(tty_port);\n\n\tmtk8250_rx_dma(up);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic void mtk8250_rx_dma(struct uart_8250_port *up)\n{\n\tstruct uart_8250_dma *dma = up->dma;\n\tstruct dma_async_tx_descriptor\t*desc;\n\n\tdesc = dmaengine_prep_slave_single(dma->rxchan, dma->rx_addr,\n\t\t\t\t\t   dma->rx_size, DMA_DEV_TO_MEM,\n\t\t\t\t\t   DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tpr_err(\"failed to prepare rx slave single\\n\");\n\t\treturn;\n\t}\n\n\tdesc->callback = mtk8250_dma_rx_complete;\n\tdesc->callback_param = up;\n\n\tdma->rx_cookie = dmaengine_submit(desc);\n\n\tdma_async_issue_pending(dma->rxchan);\n}\n\nstatic void mtk8250_dma_enable(struct uart_8250_port *up)\n{\n\tstruct uart_8250_dma *dma = up->dma;\n\tstruct mtk8250_data *data = up->port.private_data;\n\tint lcr = serial_in(up, UART_LCR);\n\n\tif (data->rx_status != DMA_RX_START)\n\t\treturn;\n\n\tdma->rxconf.src_port_window_size\t= dma->rx_size;\n\tdma->rxconf.src_addr\t\t\t\t= dma->rx_addr;\n\n\tdma->txconf.dst_port_window_size\t= UART_XMIT_SIZE;\n\tdma->txconf.dst_addr\t\t\t\t= dma->tx_addr;\n\n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR |\n\t\tUART_FCR_CLEAR_XMIT);\n\tserial_out(up, MTK_UART_DMA_EN,\n\t\t   MTK_UART_DMA_EN_RX | MTK_UART_DMA_EN_TX);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_out(up, MTK_UART_EFR, UART_EFR_ECB);\n\tserial_out(up, UART_LCR, lcr);\n\n\tif (dmaengine_slave_config(dma->rxchan, &dma->rxconf) != 0)\n\t\tpr_err(\"failed to configure rx dma channel\\n\");\n\tif (dmaengine_slave_config(dma->txchan, &dma->txconf) != 0)\n\t\tpr_err(\"failed to configure tx dma channel\\n\");\n\n\tdata->rx_status = DMA_RX_RUNNING;\n\tdata->rx_pos = 0;\n\tmtk8250_rx_dma(up);\n}\n#endif\n\nstatic int mtk8250_startup(struct uart_port *port)\n{\n#ifdef CONFIG_SERIAL_8250_DMA\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct mtk8250_data *data = port->private_data;\n\n\t \n\tif (uart_console(port))\n\t\tup->dma = NULL;\n\n\tif (up->dma) {\n\t\tdata->rx_status = DMA_RX_START;\n\t\tuart_circ_clear(&port->state->xmit);\n\t}\n#endif\n\tmemset(&port->icount, 0, sizeof(port->icount));\n\n\treturn serial8250_do_startup(port);\n}\n\nstatic void mtk8250_shutdown(struct uart_port *port)\n{\n#ifdef CONFIG_SERIAL_8250_DMA\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct mtk8250_data *data = port->private_data;\n\n\tif (up->dma)\n\t\tdata->rx_status = DMA_RX_SHUTDOWN;\n#endif\n\n\treturn serial8250_do_shutdown(port);\n}\n\nstatic void mtk8250_disable_intrs(struct uart_8250_port *up, int mask)\n{\n\t \n\tlockdep_assert_held_once(&up->port.lock);\n\n\tserial_out(up, UART_IER, serial_in(up, UART_IER) & (~mask));\n}\n\nstatic void mtk8250_enable_intrs(struct uart_8250_port *up, int mask)\n{\n\t \n\tlockdep_assert_held_once(&up->port.lock);\n\n\tserial_out(up, UART_IER, serial_in(up, UART_IER) | mask);\n}\n\nstatic void mtk8250_set_flow_ctrl(struct uart_8250_port *up, int mode)\n{\n\tstruct uart_port *port = &up->port;\n\tint lcr = serial_in(up, UART_LCR);\n\n\t \n\tlockdep_assert_held_once(&port->lock);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_out(up, MTK_UART_EFR, UART_EFR_ECB);\n\tserial_out(up, UART_LCR, lcr);\n\tlcr = serial_in(up, UART_LCR);\n\n\tswitch (mode) {\n\tcase MTK_UART_FC_NONE:\n\t\tserial_out(up, MTK_UART_ESCAPE_DAT, MTK_UART_ESCAPE_CHAR);\n\t\tserial_out(up, MTK_UART_ESCAPE_EN, 0x00);\n\t\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\t\tserial_out(up, MTK_UART_EFR, serial_in(up, MTK_UART_EFR) &\n\t\t\t(~(MTK_UART_EFR_HW_FC | MTK_UART_EFR_SW_FC_MASK)));\n\t\tserial_out(up, UART_LCR, lcr);\n\t\tmtk8250_disable_intrs(up, MTK_UART_IER_XOFFI |\n\t\t\tMTK_UART_IER_RTSI | MTK_UART_IER_CTSI);\n\t\tbreak;\n\n\tcase MTK_UART_FC_HW:\n\t\tserial_out(up, MTK_UART_ESCAPE_DAT, MTK_UART_ESCAPE_CHAR);\n\t\tserial_out(up, MTK_UART_ESCAPE_EN, 0x00);\n\t\tserial_out(up, UART_MCR, UART_MCR_RTS);\n\t\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\n\t\t \n\t\tserial_out(up, MTK_UART_EFR, MTK_UART_EFR_HW_FC |\n\t\t\t(serial_in(up, MTK_UART_EFR) &\n\t\t\t(~(MTK_UART_EFR_HW_FC | MTK_UART_EFR_SW_FC_MASK))));\n\n\t\tserial_out(up, UART_LCR, lcr);\n\t\tmtk8250_disable_intrs(up, MTK_UART_IER_XOFFI);\n\t\tmtk8250_enable_intrs(up, MTK_UART_IER_CTSI | MTK_UART_IER_RTSI);\n\t\tbreak;\n\n\tcase MTK_UART_FC_SW:\t \n\t\tserial_out(up, MTK_UART_ESCAPE_DAT, MTK_UART_ESCAPE_CHAR);\n\t\tserial_out(up, MTK_UART_ESCAPE_EN, 0x01);\n\t\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\n\t\t \n\t\tserial_out(up, MTK_UART_EFR, MTK_UART_EFR_XON1_XOFF1 |\n\t\t\t(serial_in(up, MTK_UART_EFR) &\n\t\t\t(~(MTK_UART_EFR_HW_FC | MTK_UART_EFR_SW_FC_MASK))));\n\n\t\tserial_out(up, MTK_UART_XON1, START_CHAR(port->state->port.tty));\n\t\tserial_out(up, MTK_UART_XOFF1, STOP_CHAR(port->state->port.tty));\n\t\tserial_out(up, UART_LCR, lcr);\n\t\tmtk8250_disable_intrs(up, MTK_UART_IER_CTSI|MTK_UART_IER_RTSI);\n\t\tmtk8250_enable_intrs(up, MTK_UART_IER_XOFFI);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmtk8250_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t    const struct ktermios *old)\n{\n\tstatic const unsigned short fraction_L_mapping[] = {\n\t\t0, 1, 0x5, 0x15, 0x55, 0x57, 0x57, 0x77, 0x7F, 0xFF, 0xFF\n\t};\n\tstatic const unsigned short fraction_M_mapping[] = {\n\t\t0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 3\n\t};\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned int baud, quot, fraction;\n\tunsigned long flags;\n\tint mode;\n\n#ifdef CONFIG_SERIAL_8250_DMA\n\tif (up->dma) {\n\t\tif (uart_console(port)) {\n\t\t\tdevm_kfree(up->port.dev, up->dma);\n\t\t\tup->dma = NULL;\n\t\t} else {\n\t\t\tmtk8250_dma_enable(up);\n\t\t}\n\t}\n#endif\n\n\t \n\tbaud = tty_termios_baud_rate(termios);\n\n\tserial8250_do_set_termios(port, termios, NULL);\n\n\ttty_termios_encode_baud_rate(termios, baud, baud);\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old,\n\t\t\t\t  port->uartclk / 16 / UART_DIV_MAX,\n\t\t\t\t  port->uartclk);\n\n\tif (baud < 115200) {\n\t\tserial_port_out(port, MTK_UART_HIGHS, 0x0);\n\t\tquot = uart_get_divisor(port, baud);\n\t} else {\n\t\tserial_port_out(port, MTK_UART_HIGHS, 0x3);\n\t\tquot = DIV_ROUND_UP(port->uartclk, 256 * baud);\n\t}\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tserial_port_out(port, UART_LCR, up->lcr | UART_LCR_DLAB);\n\tserial_dl_write(up, quot);\n\n\t \n\tserial_port_out(port, UART_LCR, up->lcr);\n\n\tif (baud >= 115200) {\n\t\tunsigned int tmp;\n\n\t\ttmp = (port->uartclk / (baud *  quot)) - 1;\n\t\tserial_port_out(port, MTK_UART_SAMPLE_COUNT, tmp);\n\t\tserial_port_out(port, MTK_UART_SAMPLE_POINT,\n\t\t\t\t\t(tmp >> 1) - 1);\n\n\t\t \n\t\tfraction = ((port->uartclk  * 100) / baud / quot) % 100;\n\t\tfraction = DIV_ROUND_CLOSEST(fraction, 10);\n\t\tserial_port_out(port, MTK_UART_FRACDIV_L,\n\t\t\t\t\t\tfraction_L_mapping[fraction]);\n\t\tserial_port_out(port, MTK_UART_FRACDIV_M,\n\t\t\t\t\t\tfraction_M_mapping[fraction]);\n\t} else {\n\t\tserial_port_out(port, MTK_UART_SAMPLE_COUNT, 0x00);\n\t\tserial_port_out(port, MTK_UART_SAMPLE_POINT, 0xff);\n\t\tserial_port_out(port, MTK_UART_FRACDIV_L, 0x00);\n\t\tserial_port_out(port, MTK_UART_FRACDIV_M, 0x00);\n\t}\n\n\tif ((termios->c_cflag & CRTSCTS) && (!(termios->c_iflag & CRTSCTS)))\n\t\tmode = MTK_UART_FC_HW;\n\telse if (termios->c_iflag & CRTSCTS)\n\t\tmode = MTK_UART_FC_SW;\n\telse\n\t\tmode = MTK_UART_FC_NONE;\n\n\tmtk8250_set_flow_ctrl(up, mode);\n\n\tif (uart_console(port))\n\t\tup->port.cons->cflag = termios->c_cflag;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\t \n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n}\n\nstatic int __maybe_unused mtk8250_runtime_suspend(struct device *dev)\n{\n\tstruct mtk8250_data *data = dev_get_drvdata(dev);\n\tstruct uart_8250_port *up = serial8250_get_port(data->line);\n\n\t \n\twhile\n\t\t(serial_in(up, MTK_UART_DEBUG0));\n\n\tclk_disable_unprepare(data->bus_clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mtk8250_runtime_resume(struct device *dev)\n{\n\tstruct mtk8250_data *data = dev_get_drvdata(dev);\n\n\tclk_prepare_enable(data->bus_clk);\n\n\treturn 0;\n}\n\nstatic void\nmtk8250_do_pm(struct uart_port *port, unsigned int state, unsigned int old)\n{\n\tif (!state)\n\t\tpm_runtime_get_sync(port->dev);\n\n\tserial8250_do_pm(port, state, old);\n\n\tif (state)\n\t\tpm_runtime_put_sync_suspend(port->dev);\n}\n\n#ifdef CONFIG_SERIAL_8250_DMA\nstatic bool mtk8250_dma_filter(struct dma_chan *chan, void *param)\n{\n\treturn false;\n}\n#endif\n\nstatic int mtk8250_probe_of(struct platform_device *pdev, struct uart_port *p,\n\t\t\t   struct mtk8250_data *data)\n{\n#ifdef CONFIG_SERIAL_8250_DMA\n\tint dmacnt;\n#endif\n\n\tdata->uart_clk = devm_clk_get(&pdev->dev, \"baud\");\n\tif (IS_ERR(data->uart_clk)) {\n\t\t \n\t\tdata->uart_clk = devm_clk_get(&pdev->dev, NULL);\n\t\tif (IS_ERR(data->uart_clk)) {\n\t\t\tdev_warn(&pdev->dev, \"Can't get uart clock\\n\");\n\t\t\treturn PTR_ERR(data->uart_clk);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdata->bus_clk = devm_clk_get_enabled(&pdev->dev, \"bus\");\n\tif (IS_ERR(data->bus_clk))\n\t\treturn PTR_ERR(data->bus_clk);\n\n\tdata->dma = NULL;\n#ifdef CONFIG_SERIAL_8250_DMA\n\tdmacnt = of_property_count_strings(pdev->dev.of_node, \"dma-names\");\n\tif (dmacnt == 2) {\n\t\tdata->dma = devm_kzalloc(&pdev->dev, sizeof(*data->dma),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!data->dma)\n\t\t\treturn -ENOMEM;\n\n\t\tdata->dma->fn = mtk8250_dma_filter;\n\t\tdata->dma->rx_size = MTK_UART_RX_SIZE;\n\t\tdata->dma->rxconf.src_maxburst = MTK_UART_RX_TRIGGER;\n\t\tdata->dma->txconf.dst_maxburst = MTK_UART_TX_TRIGGER;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int mtk8250_probe(struct platform_device *pdev)\n{\n\tstruct uart_8250_port uart = {};\n\tstruct mtk8250_data *data;\n\tstruct resource *regs;\n\tint irq, err;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs) {\n\t\tdev_err(&pdev->dev, \"no registers defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tuart.port.membase = devm_ioremap(&pdev->dev, regs->start,\n\t\t\t\t\t resource_size(regs));\n\tif (!uart.port.membase)\n\t\treturn -ENOMEM;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->clk_count = 0;\n\n\tif (pdev->dev.of_node) {\n\t\terr = mtk8250_probe_of(pdev, &uart.port, data);\n\t\tif (err)\n\t\t\treturn err;\n\t} else\n\t\treturn -ENODEV;\n\n\tspin_lock_init(&uart.port.lock);\n\tuart.port.mapbase = regs->start;\n\tuart.port.irq = irq;\n\tuart.port.pm = mtk8250_do_pm;\n\tuart.port.type = PORT_16550;\n\tuart.port.flags = UPF_BOOT_AUTOCONF | UPF_FIXED_PORT;\n\tuart.port.dev = &pdev->dev;\n\tuart.port.iotype = UPIO_MEM32;\n\tuart.port.regshift = 2;\n\tuart.port.private_data = data;\n\tuart.port.shutdown = mtk8250_shutdown;\n\tuart.port.startup = mtk8250_startup;\n\tuart.port.set_termios = mtk8250_set_termios;\n\tuart.port.uartclk = clk_get_rate(data->uart_clk);\n#ifdef CONFIG_SERIAL_8250_DMA\n\tif (data->dma)\n\t\tuart.dma = data->dma;\n#endif\n\n\t \n\twritel(0x0, uart.port.membase +\n\t\t\t(MTK_UART_RATE_FIX << uart.port.regshift));\n\n\tplatform_set_drvdata(pdev, data);\n\n\tdata->line = serial8250_register_8250_port(&uart);\n\tif (data->line < 0)\n\t\treturn data->line;\n\n\tdata->rx_wakeup_irq = platform_get_irq_optional(pdev, 1);\n\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int mtk8250_remove(struct platform_device *pdev)\n{\n\tstruct mtk8250_data *data = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tserial8250_unregister_port(data->line);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mtk8250_suspend(struct device *dev)\n{\n\tstruct mtk8250_data *data = dev_get_drvdata(dev);\n\tint irq = data->rx_wakeup_irq;\n\tint err;\n\n\tserial8250_suspend_port(data->line);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\tif (irq >= 0) {\n\t\terr = enable_irq_wake(irq);\n\t\tif (err) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to enable irq wake on IRQ %d: %d\\n\",\n\t\t\t\tirq, err);\n\t\t\tpinctrl_pm_select_default_state(dev);\n\t\t\tserial8250_resume_port(data->line);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mtk8250_resume(struct device *dev)\n{\n\tstruct mtk8250_data *data = dev_get_drvdata(dev);\n\tint irq = data->rx_wakeup_irq;\n\n\tif (irq >= 0)\n\t\tdisable_irq_wake(irq);\n\tpinctrl_pm_select_default_state(dev);\n\n\tserial8250_resume_port(data->line);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mtk8250_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(mtk8250_suspend, mtk8250_resume)\n\tSET_RUNTIME_PM_OPS(mtk8250_runtime_suspend, mtk8250_runtime_resume,\n\t\t\t\tNULL)\n};\n\nstatic const struct of_device_id mtk8250_of_match[] = {\n\t{ .compatible = \"mediatek,mt6577-uart\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mtk8250_of_match);\n\nstatic struct platform_driver mtk8250_platform_driver = {\n\t.driver = {\n\t\t.name\t\t= \"mt6577-uart\",\n\t\t.pm\t\t= &mtk8250_pm_ops,\n\t\t.of_match_table\t= mtk8250_of_match,\n\t},\n\t.probe\t\t\t= mtk8250_probe,\n\t.remove\t\t\t= mtk8250_remove,\n};\nmodule_platform_driver(mtk8250_platform_driver);\n\n#ifdef CONFIG_SERIAL_8250_CONSOLE\nstatic int __init early_mtk8250_setup(struct earlycon_device *device,\n\t\t\t\t\tconst char *options)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->port.iotype = UPIO_MEM32;\n\tdevice->port.regshift = 2;\n\n\treturn early_serial8250_setup(device, NULL);\n}\n\nOF_EARLYCON_DECLARE(mtk8250, \"mediatek,mt6577-uart\", early_mtk8250_setup);\n#endif\n\nMODULE_AUTHOR(\"Matthias Brugger\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Mediatek 8250 serial port driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}