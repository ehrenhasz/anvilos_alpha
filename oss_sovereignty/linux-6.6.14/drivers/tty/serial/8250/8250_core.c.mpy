{
  "module_name": "8250_core.c",
  "hash_id": "25631247b705b5cccf6c74384f51f0af80c0dca303dd818248ead49be4a4f0fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_core.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/tty.h>\n#include <linux/ratelimit.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/serial_8250.h>\n#include <linux/nmi.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#ifdef CONFIG_SPARC\n#include <linux/sunserialcore.h>\n#endif\n\n#include <asm/irq.h>\n\n#include \"8250.h\"\n\n \nstatic unsigned int share_irqs = SERIAL8250_SHARE_IRQS;\n\nstatic unsigned int nr_uarts = CONFIG_SERIAL_8250_RUNTIME_UARTS;\n\nstatic struct uart_driver serial8250_reg;\n\nstatic unsigned int skip_txen_test;  \n\n#define PASS_LIMIT\t512\n\n#include <asm/serial.h>\n \n#ifndef SERIAL_PORT_DFNS\n#define SERIAL_PORT_DFNS\n#endif\n\nstatic const struct old_serial_port old_serial_port[] = {\n\tSERIAL_PORT_DFNS  \n};\n\n#define UART_NR\tCONFIG_SERIAL_8250_NR_UARTS\n\n#ifdef CONFIG_SERIAL_8250_RSA\n\n#define PORT_RSA_MAX 4\nstatic unsigned long probe_rsa[PORT_RSA_MAX];\nstatic unsigned int probe_rsa_count;\n#endif  \n\nstruct irq_info {\n\tstruct\t\t\thlist_node node;\n\tint\t\t\tirq;\n\tspinlock_t\t\tlock;\t \n\tstruct list_head\t*head;\n};\n\n#define NR_IRQ_HASH\t\t32\t \nstatic struct hlist_head irq_lists[NR_IRQ_HASH];\nstatic DEFINE_MUTEX(hash_mutex);\t \n\n \nstatic irqreturn_t serial8250_interrupt(int irq, void *dev_id)\n{\n\tstruct irq_info *i = dev_id;\n\tstruct list_head *l, *end = NULL;\n\tint pass_counter = 0, handled = 0;\n\n\tpr_debug(\"%s(%d): start\\n\", __func__, irq);\n\n\tspin_lock(&i->lock);\n\n\tl = i->head;\n\tdo {\n\t\tstruct uart_8250_port *up;\n\t\tstruct uart_port *port;\n\n\t\tup = list_entry(l, struct uart_8250_port, list);\n\t\tport = &up->port;\n\n\t\tif (port->handle_irq(port)) {\n\t\t\thandled = 1;\n\t\t\tend = NULL;\n\t\t} else if (end == NULL)\n\t\t\tend = l;\n\n\t\tl = l->next;\n\n\t\tif (l == i->head && pass_counter++ > PASS_LIMIT)\n\t\t\tbreak;\n\t} while (l != end);\n\n\tspin_unlock(&i->lock);\n\n\tpr_debug(\"%s(%d): end\\n\", __func__, irq);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n \nstatic void serial_do_unlink(struct irq_info *i, struct uart_8250_port *up)\n{\n\tspin_lock_irq(&i->lock);\n\n\tif (!list_empty(i->head)) {\n\t\tif (i->head == &up->list)\n\t\t\ti->head = i->head->next;\n\t\tlist_del(&up->list);\n\t} else {\n\t\tBUG_ON(i->head != &up->list);\n\t\ti->head = NULL;\n\t}\n\tspin_unlock_irq(&i->lock);\n\t \n\tif (i->head == NULL) {\n\t\thlist_del(&i->node);\n\t\tkfree(i);\n\t}\n}\n\nstatic int serial_link_irq_chain(struct uart_8250_port *up)\n{\n\tstruct hlist_head *h;\n\tstruct irq_info *i;\n\tint ret;\n\n\tmutex_lock(&hash_mutex);\n\n\th = &irq_lists[up->port.irq % NR_IRQ_HASH];\n\n\thlist_for_each_entry(i, h, node)\n\t\tif (i->irq == up->port.irq)\n\t\t\tbreak;\n\n\tif (i == NULL) {\n\t\ti = kzalloc(sizeof(struct irq_info), GFP_KERNEL);\n\t\tif (i == NULL) {\n\t\t\tmutex_unlock(&hash_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tspin_lock_init(&i->lock);\n\t\ti->irq = up->port.irq;\n\t\thlist_add_head(&i->node, h);\n\t}\n\tmutex_unlock(&hash_mutex);\n\n\tspin_lock_irq(&i->lock);\n\n\tif (i->head) {\n\t\tlist_add(&up->list, i->head);\n\t\tspin_unlock_irq(&i->lock);\n\n\t\tret = 0;\n\t} else {\n\t\tINIT_LIST_HEAD(&up->list);\n\t\ti->head = &up->list;\n\t\tspin_unlock_irq(&i->lock);\n\t\tret = request_irq(up->port.irq, serial8250_interrupt,\n\t\t\t\t  up->port.irqflags, up->port.name, i);\n\t\tif (ret < 0)\n\t\t\tserial_do_unlink(i, up);\n\t}\n\n\treturn ret;\n}\n\nstatic void serial_unlink_irq_chain(struct uart_8250_port *up)\n{\n\tstruct irq_info *i;\n\tstruct hlist_head *h;\n\n\tmutex_lock(&hash_mutex);\n\n\th = &irq_lists[up->port.irq % NR_IRQ_HASH];\n\n\thlist_for_each_entry(i, h, node)\n\t\tif (i->irq == up->port.irq)\n\t\t\tbreak;\n\n\tBUG_ON(i == NULL);\n\tBUG_ON(i->head == NULL);\n\n\tif (list_empty(i->head))\n\t\tfree_irq(up->port.irq, i);\n\n\tserial_do_unlink(i, up);\n\tmutex_unlock(&hash_mutex);\n}\n\n \nstatic void serial8250_timeout(struct timer_list *t)\n{\n\tstruct uart_8250_port *up = from_timer(up, t, timer);\n\n\tup->port.handle_irq(&up->port);\n\tmod_timer(&up->timer, jiffies + uart_poll_timeout(&up->port));\n}\n\nstatic void serial8250_backup_timeout(struct timer_list *t)\n{\n\tstruct uart_8250_port *up = from_timer(up, t, timer);\n\tunsigned int iir, ier = 0, lsr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t \n\tif (up->port.irq) {\n\t\tier = serial_in(up, UART_IER);\n\t\tserial_out(up, UART_IER, 0);\n\t}\n\n\tiir = serial_in(up, UART_IIR);\n\n\t \n\tlsr = serial_lsr_in(up);\n\tif ((iir & UART_IIR_NO_INT) && (up->ier & UART_IER_THRI) &&\n\t    (!uart_circ_empty(&up->port.state->xmit) || up->port.x_char) &&\n\t    (lsr & UART_LSR_THRE)) {\n\t\tiir &= ~(UART_IIR_ID | UART_IIR_NO_INT);\n\t\tiir |= UART_IIR_THRI;\n\t}\n\n\tif (!(iir & UART_IIR_NO_INT))\n\t\tserial8250_tx_chars(up);\n\n\tif (up->port.irq)\n\t\tserial_out(up, UART_IER, ier);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\t \n\tmod_timer(&up->timer,\n\t\tjiffies + uart_poll_timeout(&up->port) + HZ / 5);\n}\n\nstatic void univ8250_setup_timer(struct uart_8250_port *up)\n{\n\tstruct uart_port *port = &up->port;\n\n\t \n\tif (up->bugs & UART_BUG_THRE) {\n\t\tpr_debug(\"%s - using backup timer\\n\", port->name);\n\n\t\tup->timer.function = serial8250_backup_timeout;\n\t\tmod_timer(&up->timer, jiffies +\n\t\t\t  uart_poll_timeout(port) + HZ / 5);\n\t}\n\n\t \n\tif (!port->irq)\n\t\tmod_timer(&up->timer, jiffies + uart_poll_timeout(port));\n}\n\nstatic int univ8250_setup_irq(struct uart_8250_port *up)\n{\n\tstruct uart_port *port = &up->port;\n\n\tif (port->irq)\n\t\treturn serial_link_irq_chain(up);\n\n\treturn 0;\n}\n\nstatic void univ8250_release_irq(struct uart_8250_port *up)\n{\n\tstruct uart_port *port = &up->port;\n\n\tdel_timer_sync(&up->timer);\n\tup->timer.function = serial8250_timeout;\n\tif (port->irq)\n\t\tserial_unlink_irq_chain(up);\n}\n\n#ifdef CONFIG_SERIAL_8250_RSA\nstatic int serial8250_request_rsa_resource(struct uart_8250_port *up)\n{\n\tunsigned long start = UART_RSA_BASE << up->port.regshift;\n\tunsigned int size = 8 << up->port.regshift;\n\tstruct uart_port *port = &up->port;\n\tint ret = -EINVAL;\n\n\tswitch (port->iotype) {\n\tcase UPIO_HUB6:\n\tcase UPIO_PORT:\n\t\tstart += port->iobase;\n\t\tif (request_region(start, size, \"serial-rsa\"))\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void serial8250_release_rsa_resource(struct uart_8250_port *up)\n{\n\tunsigned long offset = UART_RSA_BASE << up->port.regshift;\n\tunsigned int size = 8 << up->port.regshift;\n\tstruct uart_port *port = &up->port;\n\n\tswitch (port->iotype) {\n\tcase UPIO_HUB6:\n\tcase UPIO_PORT:\n\t\trelease_region(port->iobase + offset, size);\n\t\tbreak;\n\t}\n}\n#endif\n\nstatic const struct uart_ops *base_ops;\nstatic struct uart_ops univ8250_port_ops;\n\nstatic const struct uart_8250_ops univ8250_driver_ops = {\n\t.setup_irq\t= univ8250_setup_irq,\n\t.release_irq\t= univ8250_release_irq,\n\t.setup_timer\t= univ8250_setup_timer,\n};\n\nstatic struct uart_8250_port serial8250_ports[UART_NR];\n\n \nstruct uart_8250_port *serial8250_get_port(int line)\n{\n\treturn &serial8250_ports[line];\n}\nEXPORT_SYMBOL_GPL(serial8250_get_port);\n\nstatic void (*serial8250_isa_config)(int port, struct uart_port *up,\n\tu32 *capabilities);\n\nvoid serial8250_set_isa_configurator(\n\tvoid (*v)(int port, struct uart_port *up, u32 *capabilities))\n{\n\tserial8250_isa_config = v;\n}\nEXPORT_SYMBOL(serial8250_set_isa_configurator);\n\n#ifdef CONFIG_SERIAL_8250_RSA\n\nstatic void univ8250_config_port(struct uart_port *port, int flags)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\tup->probe &= ~UART_PROBE_RSA;\n\tif (port->type == PORT_RSA) {\n\t\tif (serial8250_request_rsa_resource(up) == 0)\n\t\t\tup->probe |= UART_PROBE_RSA;\n\t} else if (flags & UART_CONFIG_TYPE) {\n\t\tint i;\n\n\t\tfor (i = 0; i < probe_rsa_count; i++) {\n\t\t\tif (probe_rsa[i] == up->port.iobase) {\n\t\t\t\tif (serial8250_request_rsa_resource(up) == 0)\n\t\t\t\t\tup->probe |= UART_PROBE_RSA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbase_ops->config_port(port, flags);\n\n\tif (port->type != PORT_RSA && up->probe & UART_PROBE_RSA)\n\t\tserial8250_release_rsa_resource(up);\n}\n\nstatic int univ8250_request_port(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tint ret;\n\n\tret = base_ops->request_port(port);\n\tif (ret == 0 && port->type == PORT_RSA) {\n\t\tret = serial8250_request_rsa_resource(up);\n\t\tif (ret < 0)\n\t\t\tbase_ops->release_port(port);\n\t}\n\n\treturn ret;\n}\n\nstatic void univ8250_release_port(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\tif (port->type == PORT_RSA)\n\t\tserial8250_release_rsa_resource(up);\n\tbase_ops->release_port(port);\n}\n\nstatic void univ8250_rsa_support(struct uart_ops *ops)\n{\n\tops->config_port  = univ8250_config_port;\n\tops->request_port = univ8250_request_port;\n\tops->release_port = univ8250_release_port;\n}\n\n#else\n#define univ8250_rsa_support(x)\t\tdo { } while (0)\n#endif  \n\nstatic inline void serial8250_apply_quirks(struct uart_8250_port *up)\n{\n\tup->port.quirks |= skip_txen_test ? UPQ_NO_TXEN_TEST : 0;\n}\n\nstatic struct uart_8250_port *serial8250_setup_port(int index)\n{\n\tstruct uart_8250_port *up;\n\n\tif (index >= UART_NR)\n\t\treturn NULL;\n\n\tup = &serial8250_ports[index];\n\tup->port.line = index;\n\tup->port.port_id = index;\n\n\tserial8250_init_port(up);\n\tif (!base_ops)\n\t\tbase_ops = up->port.ops;\n\tup->port.ops = &univ8250_port_ops;\n\n\ttimer_setup(&up->timer, serial8250_timeout, 0);\n\n\tup->ops = &univ8250_driver_ops;\n\n\tif (IS_ENABLED(CONFIG_ALPHA_JENSEN) ||\n\t    (IS_ENABLED(CONFIG_ALPHA_GENERIC) && alpha_jensen()))\n\t\tup->port.set_mctrl = alpha_jensen_set_mctrl;\n\n\tserial8250_set_defaults(up);\n\n\treturn up;\n}\n\nstatic void __init serial8250_isa_init_ports(void)\n{\n\tstruct uart_8250_port *up;\n\tstatic int first = 1;\n\tint i, irqflag = 0;\n\n\tif (!first)\n\t\treturn;\n\tfirst = 0;\n\n\tif (nr_uarts > UART_NR)\n\t\tnr_uarts = UART_NR;\n\n\t \n\tfor (i = 0; i < nr_uarts; i++)\n\t\tserial8250_setup_port(i);\n\n\t \n\tuniv8250_port_ops = *base_ops;\n\tuniv8250_rsa_support(&univ8250_port_ops);\n\n\tif (share_irqs)\n\t\tirqflag = IRQF_SHARED;\n\n\tfor (i = 0, up = serial8250_ports;\n\t     i < ARRAY_SIZE(old_serial_port) && i < nr_uarts;\n\t     i++, up++) {\n\t\tstruct uart_port *port = &up->port;\n\n\t\tport->iobase   = old_serial_port[i].port;\n\t\tport->irq      = irq_canonicalize(old_serial_port[i].irq);\n\t\tport->irqflags = 0;\n\t\tport->uartclk  = old_serial_port[i].baud_base * 16;\n\t\tport->flags    = old_serial_port[i].flags;\n\t\tport->hub6     = 0;\n\t\tport->membase  = old_serial_port[i].iomem_base;\n\t\tport->iotype   = old_serial_port[i].io_type;\n\t\tport->regshift = old_serial_port[i].iomem_reg_shift;\n\n\t\tport->irqflags |= irqflag;\n\t\tif (serial8250_isa_config != NULL)\n\t\t\tserial8250_isa_config(i, &up->port, &up->capabilities);\n\t}\n}\n\nstatic void __init\nserial8250_register_ports(struct uart_driver *drv, struct device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_uarts; i++) {\n\t\tstruct uart_8250_port *up = &serial8250_ports[i];\n\n\t\tif (up->port.type == PORT_8250_CIR)\n\t\t\tcontinue;\n\n\t\tif (up->port.dev)\n\t\t\tcontinue;\n\n\t\tup->port.dev = dev;\n\n\t\tif (uart_console_registered(&up->port))\n\t\t\tpm_runtime_get_sync(up->port.dev);\n\n\t\tserial8250_apply_quirks(up);\n\t\tuart_add_one_port(drv, &up->port);\n\t}\n}\n\n#ifdef CONFIG_SERIAL_8250_CONSOLE\n\nstatic void univ8250_console_write(struct console *co, const char *s,\n\t\t\t\t   unsigned int count)\n{\n\tstruct uart_8250_port *up = &serial8250_ports[co->index];\n\n\tserial8250_console_write(up, s, count);\n}\n\nstatic int univ8250_console_setup(struct console *co, char *options)\n{\n\tstruct uart_8250_port *up;\n\tstruct uart_port *port;\n\tint retval, i;\n\n\t \n\tif (co->index >= UART_NR)\n\t\tco->index = 0;\n\n\t \n\tfor (i = nr_uarts; i <= co->index; i++) {\n\t\tup = serial8250_setup_port(i);\n\t\tif (!up)\n\t\t\treturn -ENODEV;\n\t\tnr_uarts++;\n\t}\n\n\tport = &serial8250_ports[co->index].port;\n\t \n\tport->cons = co;\n\n\tretval = serial8250_console_setup(port, options, false);\n\tif (retval != 0)\n\t\tport->cons = NULL;\n\treturn retval;\n}\n\nstatic int univ8250_console_exit(struct console *co)\n{\n\tstruct uart_port *port;\n\n\tport = &serial8250_ports[co->index].port;\n\treturn serial8250_console_exit(port);\n}\n\n \nstatic int univ8250_console_match(struct console *co, char *name, int idx,\n\t\t\t\t  char *options)\n{\n\tchar match[] = \"uart\";\t \n\tunsigned char iotype;\n\tresource_size_t addr;\n\tint i;\n\n\tif (strncmp(name, match, 4) != 0)\n\t\treturn -ENODEV;\n\n\tif (uart_parse_earlycon(options, &iotype, &addr, &options))\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = 0; i < nr_uarts; i++) {\n\t\tstruct uart_port *port = &serial8250_ports[i].port;\n\n\t\tif (port->iotype != iotype)\n\t\t\tcontinue;\n\t\tif ((iotype == UPIO_MEM || iotype == UPIO_MEM16 ||\n\t\t     iotype == UPIO_MEM32 || iotype == UPIO_MEM32BE)\n\t\t    && (port->mapbase != addr))\n\t\t\tcontinue;\n\t\tif (iotype == UPIO_PORT && port->iobase != addr)\n\t\t\tcontinue;\n\n\t\tco->index = i;\n\t\tport->cons = co;\n\t\treturn serial8250_console_setup(port, options, true);\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic struct console univ8250_console = {\n\t.name\t\t= \"ttyS\",\n\t.write\t\t= univ8250_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= univ8250_console_setup,\n\t.exit\t\t= univ8250_console_exit,\n\t.match\t\t= univ8250_console_match,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ANYTIME,\n\t.index\t\t= -1,\n\t.data\t\t= &serial8250_reg,\n};\n\nstatic int __init univ8250_console_init(void)\n{\n\tif (nr_uarts == 0)\n\t\treturn -ENODEV;\n\n\tserial8250_isa_init_ports();\n\tregister_console(&univ8250_console);\n\treturn 0;\n}\nconsole_initcall(univ8250_console_init);\n\n#define SERIAL8250_CONSOLE\t(&univ8250_console)\n#else\n#define SERIAL8250_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver serial8250_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"serial\",\n\t.dev_name\t\t= \"ttyS\",\n\t.major\t\t\t= TTY_MAJOR,\n\t.minor\t\t\t= 64,\n\t.cons\t\t\t= SERIAL8250_CONSOLE,\n};\n\n \nint __init early_serial_setup(struct uart_port *port)\n{\n\tstruct uart_port *p;\n\n\tif (port->line >= ARRAY_SIZE(serial8250_ports) || nr_uarts == 0)\n\t\treturn -ENODEV;\n\n\tserial8250_isa_init_ports();\n\tp = &serial8250_ports[port->line].port;\n\tp->iobase       = port->iobase;\n\tp->membase      = port->membase;\n\tp->irq          = port->irq;\n\tp->irqflags     = port->irqflags;\n\tp->uartclk      = port->uartclk;\n\tp->fifosize     = port->fifosize;\n\tp->regshift     = port->regshift;\n\tp->iotype       = port->iotype;\n\tp->flags        = port->flags;\n\tp->mapbase      = port->mapbase;\n\tp->mapsize      = port->mapsize;\n\tp->private_data = port->private_data;\n\tp->type\t\t= port->type;\n\tp->line\t\t= port->line;\n\n\tserial8250_set_defaults(up_to_u8250p(p));\n\n\tif (port->serial_in)\n\t\tp->serial_in = port->serial_in;\n\tif (port->serial_out)\n\t\tp->serial_out = port->serial_out;\n\tif (port->handle_irq)\n\t\tp->handle_irq = port->handle_irq;\n\n\treturn 0;\n}\n\n \nvoid serial8250_suspend_port(int line)\n{\n\tstruct uart_8250_port *up = &serial8250_ports[line];\n\tstruct uart_port *port = &up->port;\n\n\tif (!console_suspend_enabled && uart_console(port) &&\n\t    port->type != PORT_8250) {\n\t\tunsigned char canary = 0xa5;\n\n\t\tserial_out(up, UART_SCR, canary);\n\t\tif (serial_in(up, UART_SCR) == canary)\n\t\t\tup->canary = canary;\n\t}\n\n\tuart_suspend_port(&serial8250_reg, port);\n}\nEXPORT_SYMBOL(serial8250_suspend_port);\n\n \nvoid serial8250_resume_port(int line)\n{\n\tstruct uart_8250_port *up = &serial8250_ports[line];\n\tstruct uart_port *port = &up->port;\n\n\tup->canary = 0;\n\n\tif (up->capabilities & UART_NATSEMI) {\n\t\t \n\t\tserial_port_out(port, UART_LCR, 0xE0);\n\n\t\tns16550a_goto_highspeed(up);\n\n\t\tserial_port_out(port, UART_LCR, 0);\n\t\tport->uartclk = 921600*16;\n\t}\n\tuart_resume_port(&serial8250_reg, port);\n}\nEXPORT_SYMBOL(serial8250_resume_port);\n\n \nstatic int serial8250_probe(struct platform_device *dev)\n{\n\tstruct plat_serial8250_port *p = dev_get_platdata(&dev->dev);\n\tstruct uart_8250_port uart;\n\tint ret, i, irqflag = 0;\n\n\tmemset(&uart, 0, sizeof(uart));\n\n\tif (share_irqs)\n\t\tirqflag = IRQF_SHARED;\n\n\tfor (i = 0; p && p->flags != 0; p++, i++) {\n\t\tuart.port.iobase\t= p->iobase;\n\t\tuart.port.membase\t= p->membase;\n\t\tuart.port.irq\t\t= p->irq;\n\t\tuart.port.irqflags\t= p->irqflags;\n\t\tuart.port.uartclk\t= p->uartclk;\n\t\tuart.port.regshift\t= p->regshift;\n\t\tuart.port.iotype\t= p->iotype;\n\t\tuart.port.flags\t\t= p->flags;\n\t\tuart.port.mapbase\t= p->mapbase;\n\t\tuart.port.mapsize\t= p->mapsize;\n\t\tuart.port.hub6\t\t= p->hub6;\n\t\tuart.port.has_sysrq\t= p->has_sysrq;\n\t\tuart.port.private_data\t= p->private_data;\n\t\tuart.port.type\t\t= p->type;\n\t\tuart.bugs\t\t= p->bugs;\n\t\tuart.port.serial_in\t= p->serial_in;\n\t\tuart.port.serial_out\t= p->serial_out;\n\t\tuart.dl_read\t\t= p->dl_read;\n\t\tuart.dl_write\t\t= p->dl_write;\n\t\tuart.port.handle_irq\t= p->handle_irq;\n\t\tuart.port.handle_break\t= p->handle_break;\n\t\tuart.port.set_termios\t= p->set_termios;\n\t\tuart.port.set_ldisc\t= p->set_ldisc;\n\t\tuart.port.get_mctrl\t= p->get_mctrl;\n\t\tuart.port.pm\t\t= p->pm;\n\t\tuart.port.dev\t\t= &dev->dev;\n\t\tuart.port.irqflags\t|= irqflag;\n\t\tret = serial8250_register_8250_port(&uart);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->dev, \"unable to register port at index %d \"\n\t\t\t\t\"(IO%lx MEM%llx IRQ%d): %d\\n\", i,\n\t\t\t\tp->iobase, (unsigned long long)p->mapbase,\n\t\t\t\tp->irq, ret);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int serial8250_remove(struct platform_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_uarts; i++) {\n\t\tstruct uart_8250_port *up = &serial8250_ports[i];\n\n\t\tif (up->port.dev == &dev->dev)\n\t\t\tserial8250_unregister_port(i);\n\t}\n\treturn 0;\n}\n\nstatic int serial8250_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tint i;\n\n\tfor (i = 0; i < UART_NR; i++) {\n\t\tstruct uart_8250_port *up = &serial8250_ports[i];\n\n\t\tif (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)\n\t\t\tuart_suspend_port(&serial8250_reg, &up->port);\n\t}\n\n\treturn 0;\n}\n\nstatic int serial8250_resume(struct platform_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < UART_NR; i++) {\n\t\tstruct uart_8250_port *up = &serial8250_ports[i];\n\n\t\tif (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)\n\t\t\tserial8250_resume_port(i);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver serial8250_isa_driver = {\n\t.probe\t\t= serial8250_probe,\n\t.remove\t\t= serial8250_remove,\n\t.suspend\t= serial8250_suspend,\n\t.resume\t\t= serial8250_resume,\n\t.driver\t\t= {\n\t\t.name\t= \"serial8250\",\n\t},\n};\n\n \nstatic struct platform_device *serial8250_isa_devs;\n\n \nstatic DEFINE_MUTEX(serial_mutex);\n\nstatic struct uart_8250_port *serial8250_find_match_or_unused(const struct uart_port *port)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < nr_uarts; i++)\n\t\tif (uart_match_port(&serial8250_ports[i].port, port))\n\t\t\treturn &serial8250_ports[i];\n\n\t \n\ti = port->line;\n\tif (i < nr_uarts && serial8250_ports[i].port.type == PORT_UNKNOWN &&\n\t\t\tserial8250_ports[i].port.iobase == 0)\n\t\treturn &serial8250_ports[i];\n\t \n\tfor (i = 0; i < nr_uarts; i++)\n\t\tif (serial8250_ports[i].port.type == PORT_UNKNOWN &&\n\t\t    serial8250_ports[i].port.iobase == 0)\n\t\t\treturn &serial8250_ports[i];\n\n\t \n\tfor (i = 0; i < nr_uarts; i++)\n\t\tif (serial8250_ports[i].port.type == PORT_UNKNOWN)\n\t\t\treturn &serial8250_ports[i];\n\n\treturn NULL;\n}\n\nstatic void serial_8250_overrun_backoff_work(struct work_struct *work)\n{\n\tstruct uart_8250_port *up =\n\t    container_of(to_delayed_work(work), struct uart_8250_port,\n\t\t\t overrun_backoff);\n\tstruct uart_port *port = &up->port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tup->ier |= UART_IER_RLSI | UART_IER_RDI;\n\tup->port.read_status_mask |= UART_LSR_DR;\n\tserial_out(up, UART_IER, up->ier);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nint serial8250_register_8250_port(const struct uart_8250_port *up)\n{\n\tstruct uart_8250_port *uart;\n\tint ret = -ENOSPC;\n\n\tif (up->port.uartclk == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&serial_mutex);\n\n\tuart = serial8250_find_match_or_unused(&up->port);\n\tif (!uart) {\n\t\t \n\t\tuart = serial8250_setup_port(nr_uarts);\n\t\tif (!uart)\n\t\t\tgoto unlock;\n\t\tnr_uarts++;\n\t}\n\n\tif (uart->port.type != PORT_8250_CIR) {\n\t\tstruct mctrl_gpios *gpios;\n\n\t\tif (uart->port.dev)\n\t\t\tuart_remove_one_port(&serial8250_reg, &uart->port);\n\n\t\tuart->port.ctrl_id\t= up->port.ctrl_id;\n\t\tuart->port.port_id\t= up->port.port_id;\n\t\tuart->port.iobase       = up->port.iobase;\n\t\tuart->port.membase      = up->port.membase;\n\t\tuart->port.irq          = up->port.irq;\n\t\tuart->port.irqflags     = up->port.irqflags;\n\t\tuart->port.uartclk      = up->port.uartclk;\n\t\tuart->port.fifosize     = up->port.fifosize;\n\t\tuart->port.regshift     = up->port.regshift;\n\t\tuart->port.iotype       = up->port.iotype;\n\t\tuart->port.flags        = up->port.flags | UPF_BOOT_AUTOCONF;\n\t\tuart->bugs\t\t= up->bugs;\n\t\tuart->port.mapbase      = up->port.mapbase;\n\t\tuart->port.mapsize      = up->port.mapsize;\n\t\tuart->port.private_data = up->port.private_data;\n\t\tuart->tx_loadsz\t\t= up->tx_loadsz;\n\t\tuart->capabilities\t= up->capabilities;\n\t\tuart->port.throttle\t= up->port.throttle;\n\t\tuart->port.unthrottle\t= up->port.unthrottle;\n\t\tuart->port.rs485_config\t= up->port.rs485_config;\n\t\tuart->port.rs485_supported = up->port.rs485_supported;\n\t\tuart->port.rs485\t= up->port.rs485;\n\t\tuart->rs485_start_tx\t= up->rs485_start_tx;\n\t\tuart->rs485_stop_tx\t= up->rs485_stop_tx;\n\t\tuart->lsr_save_mask\t= up->lsr_save_mask;\n\t\tuart->dma\t\t= up->dma;\n\n\t\t \n\t\tif (uart->port.fifosize && !uart->tx_loadsz)\n\t\t\tuart->tx_loadsz = uart->port.fifosize;\n\n\t\tif (up->port.dev) {\n\t\t\tuart->port.dev = up->port.dev;\n\t\t\tret = uart_get_rs485_mode(&uart->port);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tif (up->port.flags & UPF_FIXED_TYPE)\n\t\t\tuart->port.type = up->port.type;\n\n\t\t \n\t\tif (!has_acpi_companion(uart->port.dev)) {\n\t\t\tgpios = mctrl_gpio_init(&uart->port, 0);\n\t\t\tif (IS_ERR(gpios)) {\n\t\t\t\tret = PTR_ERR(gpios);\n\t\t\t\tgoto err;\n\t\t\t} else {\n\t\t\t\tuart->gpios = gpios;\n\t\t\t}\n\t\t}\n\n\t\tserial8250_set_defaults(uart);\n\n\t\t \n\t\tif (up->port.serial_in)\n\t\t\tuart->port.serial_in = up->port.serial_in;\n\t\tif (up->port.serial_out)\n\t\t\tuart->port.serial_out = up->port.serial_out;\n\t\tif (up->port.handle_irq)\n\t\t\tuart->port.handle_irq = up->port.handle_irq;\n\t\t \n\t\tif (up->port.set_termios)\n\t\t\tuart->port.set_termios = up->port.set_termios;\n\t\tif (up->port.set_ldisc)\n\t\t\tuart->port.set_ldisc = up->port.set_ldisc;\n\t\tif (up->port.get_mctrl)\n\t\t\tuart->port.get_mctrl = up->port.get_mctrl;\n\t\tif (up->port.set_mctrl)\n\t\t\tuart->port.set_mctrl = up->port.set_mctrl;\n\t\tif (up->port.get_divisor)\n\t\t\tuart->port.get_divisor = up->port.get_divisor;\n\t\tif (up->port.set_divisor)\n\t\t\tuart->port.set_divisor = up->port.set_divisor;\n\t\tif (up->port.startup)\n\t\t\tuart->port.startup = up->port.startup;\n\t\tif (up->port.shutdown)\n\t\t\tuart->port.shutdown = up->port.shutdown;\n\t\tif (up->port.pm)\n\t\t\tuart->port.pm = up->port.pm;\n\t\tif (up->port.handle_break)\n\t\t\tuart->port.handle_break = up->port.handle_break;\n\t\tif (up->dl_read)\n\t\t\tuart->dl_read = up->dl_read;\n\t\tif (up->dl_write)\n\t\t\tuart->dl_write = up->dl_write;\n\n\t\tif (uart->port.type != PORT_8250_CIR) {\n\t\t\tif (serial8250_isa_config != NULL)\n\t\t\t\tserial8250_isa_config(0, &uart->port,\n\t\t\t\t\t\t&uart->capabilities);\n\n\t\t\tserial8250_apply_quirks(uart);\n\t\t\tret = uart_add_one_port(&serial8250_reg,\n\t\t\t\t\t\t&uart->port);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tret = uart->port.line;\n\t\t} else {\n\t\t\tdev_info(uart->port.dev,\n\t\t\t\t\"skipping CIR port at 0x%lx / 0x%llx, IRQ %d\\n\",\n\t\t\t\tuart->port.iobase,\n\t\t\t\t(unsigned long long)uart->port.mapbase,\n\t\t\t\tuart->port.irq);\n\n\t\t\tret = 0;\n\t\t}\n\n\t\tif (!uart->lsr_save_mask)\n\t\t\tuart->lsr_save_mask = LSR_SAVE_FLAGS;\t \n\n\t\t \n\t\tif (up->overrun_backoff_time_ms > 0) {\n\t\t\tuart->overrun_backoff_time_ms =\n\t\t\t\tup->overrun_backoff_time_ms;\n\t\t\tINIT_DELAYED_WORK(&uart->overrun_backoff,\n\t\t\t\t\tserial_8250_overrun_backoff_work);\n\t\t} else {\n\t\t\tuart->overrun_backoff_time_ms = 0;\n\t\t}\n\t}\n\nunlock:\n\tmutex_unlock(&serial_mutex);\n\n\treturn ret;\n\nerr:\n\tuart->port.dev = NULL;\n\tmutex_unlock(&serial_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(serial8250_register_8250_port);\n\n \nvoid serial8250_unregister_port(int line)\n{\n\tstruct uart_8250_port *uart = &serial8250_ports[line];\n\n\tmutex_lock(&serial_mutex);\n\n\tif (uart->em485) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&uart->port.lock, flags);\n\t\tserial8250_em485_destroy(uart);\n\t\tspin_unlock_irqrestore(&uart->port.lock, flags);\n\t}\n\n\tuart_remove_one_port(&serial8250_reg, &uart->port);\n\tif (serial8250_isa_devs) {\n\t\tuart->port.flags &= ~UPF_BOOT_AUTOCONF;\n\t\tuart->port.type = PORT_UNKNOWN;\n\t\tuart->port.dev = &serial8250_isa_devs->dev;\n\t\tuart->port.port_id = line;\n\t\tuart->capabilities = 0;\n\t\tserial8250_init_port(uart);\n\t\tserial8250_apply_quirks(uart);\n\t\tuart_add_one_port(&serial8250_reg, &uart->port);\n\t} else {\n\t\tuart->port.dev = NULL;\n\t}\n\tmutex_unlock(&serial_mutex);\n}\nEXPORT_SYMBOL(serial8250_unregister_port);\n\nstatic int __init serial8250_init(void)\n{\n\tint ret;\n\n\tif (nr_uarts == 0)\n\t\treturn -ENODEV;\n\n\tserial8250_isa_init_ports();\n\n\tpr_info(\"Serial: 8250/16550 driver, %d ports, IRQ sharing %s\\n\",\n\t\tnr_uarts, str_enabled_disabled(share_irqs));\n\n#ifdef CONFIG_SPARC\n\tret = sunserial_register_minors(&serial8250_reg, UART_NR);\n#else\n\tserial8250_reg.nr = UART_NR;\n\tret = uart_register_driver(&serial8250_reg);\n#endif\n\tif (ret)\n\t\tgoto out;\n\n\tret = serial8250_pnp_init();\n\tif (ret)\n\t\tgoto unreg_uart_drv;\n\n\tserial8250_isa_devs = platform_device_alloc(\"serial8250\",\n\t\t\t\t\t\t    PLAT8250_DEV_LEGACY);\n\tif (!serial8250_isa_devs) {\n\t\tret = -ENOMEM;\n\t\tgoto unreg_pnp;\n\t}\n\n\tret = platform_device_add(serial8250_isa_devs);\n\tif (ret)\n\t\tgoto put_dev;\n\n\tserial8250_register_ports(&serial8250_reg, &serial8250_isa_devs->dev);\n\n\tret = platform_driver_register(&serial8250_isa_driver);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tplatform_device_del(serial8250_isa_devs);\nput_dev:\n\tplatform_device_put(serial8250_isa_devs);\nunreg_pnp:\n\tserial8250_pnp_exit();\nunreg_uart_drv:\n#ifdef CONFIG_SPARC\n\tsunserial_unregister_minors(&serial8250_reg, UART_NR);\n#else\n\tuart_unregister_driver(&serial8250_reg);\n#endif\nout:\n\treturn ret;\n}\n\nstatic void __exit serial8250_exit(void)\n{\n\tstruct platform_device *isa_dev = serial8250_isa_devs;\n\n\t \n\tserial8250_isa_devs = NULL;\n\n\tplatform_driver_unregister(&serial8250_isa_driver);\n\tplatform_device_unregister(isa_dev);\n\n\tserial8250_pnp_exit();\n\n#ifdef CONFIG_SPARC\n\tsunserial_unregister_minors(&serial8250_reg, UART_NR);\n#else\n\tuart_unregister_driver(&serial8250_reg);\n#endif\n}\n\nmodule_init(serial8250_init);\nmodule_exit(serial8250_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Generic 8250/16x50 serial driver\");\n\nmodule_param_hw(share_irqs, uint, other, 0644);\nMODULE_PARM_DESC(share_irqs, \"Share IRQs with other non-8250/16x50 devices (unsafe)\");\n\nmodule_param(nr_uarts, uint, 0644);\nMODULE_PARM_DESC(nr_uarts, \"Maximum number of UARTs supported. (1-\" __MODULE_STRING(CONFIG_SERIAL_8250_NR_UARTS) \")\");\n\nmodule_param(skip_txen_test, uint, 0644);\nMODULE_PARM_DESC(skip_txen_test, \"Skip checking for the TXEN bug at init time\");\n\n#ifdef CONFIG_SERIAL_8250_RSA\nmodule_param_hw_array(probe_rsa, ulong, ioport, &probe_rsa_count, 0444);\nMODULE_PARM_DESC(probe_rsa, \"Probe I/O ports for RSA\");\n#endif\nMODULE_ALIAS_CHARDEV_MAJOR(TTY_MAJOR);\n\n#ifdef CONFIG_SERIAL_8250_DEPRECATED_OPTIONS\n#ifndef MODULE\n \nstatic void __used s8250_options(void)\n{\n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX \"8250_core.\"\n\n\tmodule_param_cb(share_irqs, &param_ops_uint, &share_irqs, 0644);\n\tmodule_param_cb(nr_uarts, &param_ops_uint, &nr_uarts, 0644);\n\tmodule_param_cb(skip_txen_test, &param_ops_uint, &skip_txen_test, 0644);\n#ifdef CONFIG_SERIAL_8250_RSA\n\t__module_param_call(MODULE_PARAM_PREFIX, probe_rsa,\n\t\t&param_array_ops, .arr = &__param_arr_probe_rsa,\n\t\t0444, -1, 0);\n#endif\n}\n#else\nMODULE_ALIAS(\"8250_core\");\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}