{
  "module_name": "8250.h",
  "hash_id": "ba599c9b2a6bb1a8aa0a7968fcb6b0e593aad423aef2aa3a2fa9da7b0c1527ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250.h",
  "human_readable_source": " \n \n\n#include <linux/bits.h>\n#include <linux/serial_8250.h>\n#include <linux/serial_reg.h>\n#include <linux/dmaengine.h>\n\n#include \"../serial_mctrl_gpio.h\"\n\nstruct uart_8250_dma {\n\tint (*tx_dma)(struct uart_8250_port *p);\n\tint (*rx_dma)(struct uart_8250_port *p);\n\tvoid (*prepare_tx_dma)(struct uart_8250_port *p);\n\tvoid (*prepare_rx_dma)(struct uart_8250_port *p);\n\n\t \n\tdma_filter_fn\t\tfn;\n\t \n\tvoid\t\t\t*rx_param;\n\tvoid\t\t\t*tx_param;\n\n\tstruct dma_slave_config\trxconf;\n\tstruct dma_slave_config\ttxconf;\n\n\tstruct dma_chan\t\t*rxchan;\n\tstruct dma_chan\t\t*txchan;\n\n\t \n\tphys_addr_t\t\trx_dma_addr;\n\tphys_addr_t\t\ttx_dma_addr;\n\n\t \n\tdma_addr_t\t\trx_addr;\n\tdma_addr_t\t\ttx_addr;\n\n\tdma_cookie_t\t\trx_cookie;\n\tdma_cookie_t\t\ttx_cookie;\n\n\tvoid\t\t\t*rx_buf;\n\n\tsize_t\t\t\trx_size;\n\tsize_t\t\t\ttx_size;\n\n\tunsigned char\t\ttx_running;\n\tunsigned char\t\ttx_err;\n\tunsigned char\t\trx_running;\n};\n\nstruct old_serial_port {\n\tunsigned int uart;\n\tunsigned int baud_base;\n\tunsigned int port;\n\tunsigned int irq;\n\tupf_t        flags;\n\tunsigned char io_type;\n\tunsigned char __iomem *iomem_base;\n\tunsigned short iomem_reg_shift;\n};\n\nstruct serial8250_config {\n\tconst char\t*name;\n\tunsigned short\tfifo_size;\n\tunsigned short\ttx_loadsz;\n\tunsigned char\tfcr;\n\tunsigned char\trxtrig_bytes[UART_FCR_R_TRIG_MAX_STATE];\n\tunsigned int\tflags;\n};\n\n#define UART_CAP_FIFO\tBIT(8)\t \n#define UART_CAP_EFR\tBIT(9)\t \n#define UART_CAP_SLEEP\tBIT(10)\t \n#define UART_CAP_AFE\tBIT(11)\t \n#define UART_CAP_UUE\tBIT(12)\t \n#define UART_CAP_RTOIE\tBIT(13)\t \n#define UART_CAP_HFIFO\tBIT(14)\t \n#define UART_CAP_RPM\tBIT(15)\t \n#define UART_CAP_IRDA\tBIT(16)\t \n#define UART_CAP_MINI\tBIT(17)\t \n#define UART_CAP_NOTEMT\tBIT(18)\t \n\n#define UART_BUG_QUOT\tBIT(0)\t \n#define UART_BUG_TXEN\tBIT(1)\t \n#define UART_BUG_NOMSR\tBIT(2)\t \n#define UART_BUG_THRE\tBIT(3)\t \n#define UART_BUG_TXRACE\tBIT(5)\t \n\n\n#ifdef CONFIG_SERIAL_8250_SHARE_IRQ\n#define SERIAL8250_SHARE_IRQS 1\n#else\n#define SERIAL8250_SHARE_IRQS 0\n#endif\n\n#define SERIAL8250_PORT_FLAGS(_base, _irq, _flags)\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.iobase\t\t= _base,\t\t\t\\\n\t\t.irq\t\t= _irq,\t\t\t\t\\\n\t\t.uartclk\t= 1843200,\t\t\t\\\n\t\t.iotype\t\t= UPIO_PORT,\t\t\t\\\n\t\t.flags\t\t= UPF_BOOT_AUTOCONF | (_flags),\t\\\n\t}\n\n#define SERIAL8250_PORT(_base, _irq) SERIAL8250_PORT_FLAGS(_base, _irq, 0)\n\n\nstatic inline int serial_in(struct uart_8250_port *up, int offset)\n{\n\treturn up->port.serial_in(&up->port, offset);\n}\n\nstatic inline void serial_out(struct uart_8250_port *up, int offset, int value)\n{\n\tup->port.serial_out(&up->port, offset, value);\n}\n\n \nstatic inline u16 serial_lsr_in(struct uart_8250_port *up)\n{\n\tu16 lsr = up->lsr_saved_flags;\n\n\tlsr |= serial_in(up, UART_LSR);\n\tup->lsr_saved_flags = lsr & up->lsr_save_mask;\n\n\treturn lsr;\n}\n\n \nstatic void serial_icr_write(struct uart_8250_port *up, int offset, int value)\n{\n\tserial_out(up, UART_SCR, offset);\n\tserial_out(up, UART_ICR, value);\n}\n\nstatic unsigned int __maybe_unused serial_icr_read(struct uart_8250_port *up,\n\t\t\t\t\t\t   int offset)\n{\n\tunsigned int value;\n\n\tserial_icr_write(up, UART_ACR, up->acr | UART_ACR_ICRRD);\n\tserial_out(up, UART_SCR, offset);\n\tvalue = serial_in(up, UART_ICR);\n\tserial_icr_write(up, UART_ACR, up->acr);\n\n\treturn value;\n}\n\nvoid serial8250_clear_and_reinit_fifos(struct uart_8250_port *p);\n\nstatic inline u32 serial_dl_read(struct uart_8250_port *up)\n{\n\treturn up->dl_read(up);\n}\n\nstatic inline void serial_dl_write(struct uart_8250_port *up, u32 value)\n{\n\tup->dl_write(up, value);\n}\n\nstatic inline bool serial8250_set_THRI(struct uart_8250_port *up)\n{\n\t \n\tlockdep_assert_held_once(&up->port.lock);\n\n\tif (up->ier & UART_IER_THRI)\n\t\treturn false;\n\tup->ier |= UART_IER_THRI;\n\tserial_out(up, UART_IER, up->ier);\n\treturn true;\n}\n\nstatic inline bool serial8250_clear_THRI(struct uart_8250_port *up)\n{\n\t \n\tlockdep_assert_held_once(&up->port.lock);\n\n\tif (!(up->ier & UART_IER_THRI))\n\t\treturn false;\n\tup->ier &= ~UART_IER_THRI;\n\tserial_out(up, UART_IER, up->ier);\n\treturn true;\n}\n\nstruct uart_8250_port *serial8250_get_port(int line);\n\nvoid serial8250_rpm_get(struct uart_8250_port *p);\nvoid serial8250_rpm_put(struct uart_8250_port *p);\n\nvoid serial8250_rpm_get_tx(struct uart_8250_port *p);\nvoid serial8250_rpm_put_tx(struct uart_8250_port *p);\n\nint serial8250_em485_config(struct uart_port *port, struct ktermios *termios,\n\t\t\t    struct serial_rs485 *rs485);\nvoid serial8250_em485_start_tx(struct uart_8250_port *p);\nvoid serial8250_em485_stop_tx(struct uart_8250_port *p);\nvoid serial8250_em485_destroy(struct uart_8250_port *p);\nextern struct serial_rs485 serial8250_em485_supported;\n\n \nstatic inline int serial8250_TIOCM_to_MCR(int tiocm)\n{\n\tint mcr = 0;\n\n\tif (tiocm & TIOCM_RTS)\n\t\tmcr |= UART_MCR_RTS;\n\tif (tiocm & TIOCM_DTR)\n\t\tmcr |= UART_MCR_DTR;\n\tif (tiocm & TIOCM_OUT1)\n\t\tmcr |= UART_MCR_OUT1;\n\tif (tiocm & TIOCM_OUT2)\n\t\tmcr |= UART_MCR_OUT2;\n\tif (tiocm & TIOCM_LOOP)\n\t\tmcr |= UART_MCR_LOOP;\n\n\treturn mcr;\n}\n\nstatic inline int serial8250_MCR_to_TIOCM(int mcr)\n{\n\tint tiocm = 0;\n\n\tif (mcr & UART_MCR_RTS)\n\t\ttiocm |= TIOCM_RTS;\n\tif (mcr & UART_MCR_DTR)\n\t\ttiocm |= TIOCM_DTR;\n\tif (mcr & UART_MCR_OUT1)\n\t\ttiocm |= TIOCM_OUT1;\n\tif (mcr & UART_MCR_OUT2)\n\t\ttiocm |= TIOCM_OUT2;\n\tif (mcr & UART_MCR_LOOP)\n\t\ttiocm |= TIOCM_LOOP;\n\n\treturn tiocm;\n}\n\n \nstatic inline int serial8250_MSR_to_TIOCM(int msr)\n{\n\tint tiocm = 0;\n\n\tif (msr & UART_MSR_DCD)\n\t\ttiocm |= TIOCM_CAR;\n\tif (msr & UART_MSR_RI)\n\t\ttiocm |= TIOCM_RNG;\n\tif (msr & UART_MSR_DSR)\n\t\ttiocm |= TIOCM_DSR;\n\tif (msr & UART_MSR_CTS)\n\t\ttiocm |= TIOCM_CTS;\n\n\treturn tiocm;\n}\n\nstatic inline void serial8250_out_MCR(struct uart_8250_port *up, int value)\n{\n\tserial_out(up, UART_MCR, value);\n\n\tif (up->gpios)\n\t\tmctrl_gpio_set(up->gpios, serial8250_MCR_to_TIOCM(value));\n}\n\nstatic inline int serial8250_in_MCR(struct uart_8250_port *up)\n{\n\tint mctrl;\n\n\tmctrl = serial_in(up, UART_MCR);\n\n\tif (up->gpios) {\n\t\tunsigned int mctrl_gpio = 0;\n\n\t\tmctrl_gpio = mctrl_gpio_get_outputs(up->gpios, &mctrl_gpio);\n\t\tmctrl |= serial8250_TIOCM_to_MCR(mctrl_gpio);\n\t}\n\n\treturn mctrl;\n}\n\nbool alpha_jensen(void);\nvoid alpha_jensen_set_mctrl(struct uart_port *port, unsigned int mctrl);\n\n#ifdef CONFIG_SERIAL_8250_PNP\nint serial8250_pnp_init(void);\nvoid serial8250_pnp_exit(void);\n#else\nstatic inline int serial8250_pnp_init(void) { return 0; }\nstatic inline void serial8250_pnp_exit(void) { }\n#endif\n\n#ifdef CONFIG_SERIAL_8250_FINTEK\nint fintek_8250_probe(struct uart_8250_port *uart);\n#else\nstatic inline int fintek_8250_probe(struct uart_8250_port *uart) { return 0; }\n#endif\n\n#ifdef CONFIG_ARCH_OMAP1\n#include <linux/soc/ti/omap1-soc.h>\nstatic inline int is_omap1_8250(struct uart_8250_port *pt)\n{\n\tint res;\n\n\tswitch (pt->port.mapbase) {\n\tcase OMAP1_UART1_BASE:\n\tcase OMAP1_UART2_BASE:\n\tcase OMAP1_UART3_BASE:\n\t\tres = 1;\n\t\tbreak;\n\tdefault:\n\t\tres = 0;\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n\nstatic inline int is_omap1510_8250(struct uart_8250_port *pt)\n{\n\tif (!cpu_is_omap1510())\n\t\treturn 0;\n\n\treturn is_omap1_8250(pt);\n}\n#else\nstatic inline int is_omap1_8250(struct uart_8250_port *pt)\n{\n\treturn 0;\n}\nstatic inline int is_omap1510_8250(struct uart_8250_port *pt)\n{\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_SERIAL_8250_DMA\nextern int serial8250_tx_dma(struct uart_8250_port *);\nextern int serial8250_rx_dma(struct uart_8250_port *);\nextern void serial8250_rx_dma_flush(struct uart_8250_port *);\nextern int serial8250_request_dma(struct uart_8250_port *);\nextern void serial8250_release_dma(struct uart_8250_port *);\n\nstatic inline void serial8250_do_prepare_tx_dma(struct uart_8250_port *p)\n{\n\tstruct uart_8250_dma *dma = p->dma;\n\n\tif (dma->prepare_tx_dma)\n\t\tdma->prepare_tx_dma(p);\n}\n\nstatic inline void serial8250_do_prepare_rx_dma(struct uart_8250_port *p)\n{\n\tstruct uart_8250_dma *dma = p->dma;\n\n\tif (dma->prepare_rx_dma)\n\t\tdma->prepare_rx_dma(p);\n}\n\nstatic inline bool serial8250_tx_dma_running(struct uart_8250_port *p)\n{\n\tstruct uart_8250_dma *dma = p->dma;\n\n\treturn dma && dma->tx_running;\n}\n#else\nstatic inline int serial8250_tx_dma(struct uart_8250_port *p)\n{\n\treturn -1;\n}\nstatic inline int serial8250_rx_dma(struct uart_8250_port *p)\n{\n\treturn -1;\n}\nstatic inline void serial8250_rx_dma_flush(struct uart_8250_port *p) { }\nstatic inline int serial8250_request_dma(struct uart_8250_port *p)\n{\n\treturn -1;\n}\nstatic inline void serial8250_release_dma(struct uart_8250_port *p) { }\n\nstatic inline bool serial8250_tx_dma_running(struct uart_8250_port *p)\n{\n\treturn false;\n}\n#endif\n\nstatic inline int ns16550a_goto_highspeed(struct uart_8250_port *up)\n{\n\tunsigned char status;\n\n\tstatus = serial_in(up, 0x04);  \n#define PRESL(x) ((x) & 0x30)\n\tif (PRESL(status) == 0x10) {\n\t\t \n\t\treturn 0;\n\t} else {\n\t\tstatus &= ~0xB0;  \n\t\tstatus |= 0x10;   \n\t\tserial_out(up, 0x04, status);\n\t}\n\treturn 1;\n}\n\nstatic inline int serial_index(struct uart_port *port)\n{\n\treturn port->minor - 64;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}