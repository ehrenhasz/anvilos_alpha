{
  "module_name": "8250_port.c",
  "hash_id": "d2b6f1fb0862b9b37d1613e2892815427ced2cff663dd29066e78f6a7dca2285",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_port.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/console.h>\n#include <linux/gpio/consumer.h>\n#include <linux/sysrq.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/tty.h>\n#include <linux/ratelimit.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/serial_8250.h>\n#include <linux/nmi.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/pm_runtime.h>\n#include <linux/ktime.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n\n#include \"8250.h\"\n\n \n#define UART_NPCM_TOR          7\n#define UART_NPCM_TOIE         BIT(7)   \n\n \n#if 0\n#define DEBUG_AUTOCONF(fmt...)\tprintk(fmt)\n#else\n#define DEBUG_AUTOCONF(fmt...)\tdo { } while (0)\n#endif\n\n \nstatic const struct serial8250_config uart_config[] = {\n\t[PORT_UNKNOWN] = {\n\t\t.name\t\t= \"unknown\",\n\t\t.fifo_size\t= 1,\n\t\t.tx_loadsz\t= 1,\n\t},\n\t[PORT_8250] = {\n\t\t.name\t\t= \"8250\",\n\t\t.fifo_size\t= 1,\n\t\t.tx_loadsz\t= 1,\n\t},\n\t[PORT_16450] = {\n\t\t.name\t\t= \"16450\",\n\t\t.fifo_size\t= 1,\n\t\t.tx_loadsz\t= 1,\n\t},\n\t[PORT_16550] = {\n\t\t.name\t\t= \"16550\",\n\t\t.fifo_size\t= 1,\n\t\t.tx_loadsz\t= 1,\n\t},\n\t[PORT_16550A] = {\n\t\t.name\t\t= \"16550A\",\n\t\t.fifo_size\t= 16,\n\t\t.tx_loadsz\t= 16,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.rxtrig_bytes\t= {1, 4, 8, 14},\n\t\t.flags\t\t= UART_CAP_FIFO,\n\t},\n\t[PORT_CIRRUS] = {\n\t\t.name\t\t= \"Cirrus\",\n\t\t.fifo_size\t= 1,\n\t\t.tx_loadsz\t= 1,\n\t},\n\t[PORT_16650] = {\n\t\t.name\t\t= \"ST16650\",\n\t\t.fifo_size\t= 1,\n\t\t.tx_loadsz\t= 1,\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,\n\t},\n\t[PORT_16650V2] = {\n\t\t.name\t\t= \"ST16650V2\",\n\t\t.fifo_size\t= 32,\n\t\t.tx_loadsz\t= 16,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01 |\n\t\t\t\t  UART_FCR_T_TRIG_00,\n\t\t.rxtrig_bytes\t= {8, 16, 24, 28},\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,\n\t},\n\t[PORT_16750] = {\n\t\t.name\t\t= \"TI16750\",\n\t\t.fifo_size\t= 64,\n\t\t.tx_loadsz\t= 64,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10 |\n\t\t\t\t  UART_FCR7_64BYTE,\n\t\t.rxtrig_bytes\t= {1, 16, 32, 56},\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_SLEEP | UART_CAP_AFE,\n\t},\n\t[PORT_STARTECH] = {\n\t\t.name\t\t= \"Startech\",\n\t\t.fifo_size\t= 1,\n\t\t.tx_loadsz\t= 1,\n\t},\n\t[PORT_16C950] = {\n\t\t.name\t\t= \"16C950/954\",\n\t\t.fifo_size\t= 128,\n\t\t.tx_loadsz\t= 128,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01,\n\t\t.rxtrig_bytes\t= {16, 32, 112, 120},\n\t\t \n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_SLEEP,\n\t},\n\t[PORT_16654] = {\n\t\t.name\t\t= \"ST16654\",\n\t\t.fifo_size\t= 64,\n\t\t.tx_loadsz\t= 32,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01 |\n\t\t\t\t  UART_FCR_T_TRIG_10,\n\t\t.rxtrig_bytes\t= {8, 16, 56, 60},\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,\n\t},\n\t[PORT_16850] = {\n\t\t.name\t\t= \"XR16850\",\n\t\t.fifo_size\t= 128,\n\t\t.tx_loadsz\t= 128,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,\n\t},\n\t[PORT_RSA] = {\n\t\t.name\t\t= \"RSA\",\n\t\t.fifo_size\t= 2048,\n\t\t.tx_loadsz\t= 2048,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_11,\n\t\t.flags\t\t= UART_CAP_FIFO,\n\t},\n\t[PORT_NS16550A] = {\n\t\t.name\t\t= \"NS16550A\",\n\t\t.fifo_size\t= 16,\n\t\t.tx_loadsz\t= 16,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.flags\t\t= UART_CAP_FIFO | UART_NATSEMI,\n\t},\n\t[PORT_XSCALE] = {\n\t\t.name\t\t= \"XScale\",\n\t\t.fifo_size\t= 32,\n\t\t.tx_loadsz\t= 32,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_UUE | UART_CAP_RTOIE,\n\t},\n\t[PORT_OCTEON] = {\n\t\t.name\t\t= \"OCTEON\",\n\t\t.fifo_size\t= 64,\n\t\t.tx_loadsz\t= 64,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.flags\t\t= UART_CAP_FIFO,\n\t},\n\t[PORT_AR7] = {\n\t\t.name\t\t= \"AR7\",\n\t\t.fifo_size\t= 16,\n\t\t.tx_loadsz\t= 16,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_00,\n\t\t.flags\t\t= UART_CAP_FIFO  ,\n\t},\n\t[PORT_U6_16550A] = {\n\t\t.name\t\t= \"U6_16550A\",\n\t\t.fifo_size\t= 64,\n\t\t.tx_loadsz\t= 64,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_AFE,\n\t},\n\t[PORT_TEGRA] = {\n\t\t.name\t\t= \"Tegra\",\n\t\t.fifo_size\t= 32,\n\t\t.tx_loadsz\t= 8,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01 |\n\t\t\t\t  UART_FCR_T_TRIG_01,\n\t\t.rxtrig_bytes\t= {1, 4, 8, 14},\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_RTOIE,\n\t},\n\t[PORT_XR17D15X] = {\n\t\t.name\t\t= \"XR17D15X\",\n\t\t.fifo_size\t= 64,\n\t\t.tx_loadsz\t= 64,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_AFE | UART_CAP_EFR |\n\t\t\t\t  UART_CAP_SLEEP,\n\t},\n\t[PORT_XR17V35X] = {\n\t\t.name\t\t= \"XR17V35X\",\n\t\t.fifo_size\t= 256,\n\t\t.tx_loadsz\t= 256,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_11 |\n\t\t\t\t  UART_FCR_T_TRIG_11,\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_AFE | UART_CAP_EFR |\n\t\t\t\t  UART_CAP_SLEEP,\n\t},\n\t[PORT_LPC3220] = {\n\t\t.name\t\t= \"LPC3220\",\n\t\t.fifo_size\t= 64,\n\t\t.tx_loadsz\t= 32,\n\t\t.fcr\t\t= UART_FCR_DMA_SELECT | UART_FCR_ENABLE_FIFO |\n\t\t\t\t  UART_FCR_R_TRIG_00 | UART_FCR_T_TRIG_00,\n\t\t.flags\t\t= UART_CAP_FIFO,\n\t},\n\t[PORT_BRCM_TRUMANAGE] = {\n\t\t.name\t\t= \"TruManage\",\n\t\t.fifo_size\t= 1,\n\t\t.tx_loadsz\t= 1024,\n\t\t.flags\t\t= UART_CAP_HFIFO,\n\t},\n\t[PORT_8250_CIR] = {\n\t\t.name\t\t= \"CIR port\"\n\t},\n\t[PORT_ALTR_16550_F32] = {\n\t\t.name\t\t= \"Altera 16550 FIFO32\",\n\t\t.fifo_size\t= 32,\n\t\t.tx_loadsz\t= 32,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.rxtrig_bytes\t= {1, 8, 16, 30},\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_AFE,\n\t},\n\t[PORT_ALTR_16550_F64] = {\n\t\t.name\t\t= \"Altera 16550 FIFO64\",\n\t\t.fifo_size\t= 64,\n\t\t.tx_loadsz\t= 64,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.rxtrig_bytes\t= {1, 16, 32, 62},\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_AFE,\n\t},\n\t[PORT_ALTR_16550_F128] = {\n\t\t.name\t\t= \"Altera 16550 FIFO128\",\n\t\t.fifo_size\t= 128,\n\t\t.tx_loadsz\t= 128,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.rxtrig_bytes\t= {1, 32, 64, 126},\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_AFE,\n\t},\n\t \n\t[PORT_16550A_FSL64] = {\n\t\t.name\t\t= \"16550A_FSL64\",\n\t\t.fifo_size\t= 64,\n\t\t.tx_loadsz\t= 63,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10 |\n\t\t\t\t  UART_FCR7_64BYTE,\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_NOTEMT,\n\t},\n\t[PORT_RT2880] = {\n\t\t.name\t\t= \"Palmchip BK-3103\",\n\t\t.fifo_size\t= 16,\n\t\t.tx_loadsz\t= 16,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.rxtrig_bytes\t= {1, 4, 8, 14},\n\t\t.flags\t\t= UART_CAP_FIFO,\n\t},\n\t[PORT_DA830] = {\n\t\t.name\t\t= \"TI DA8xx/66AK2x\",\n\t\t.fifo_size\t= 16,\n\t\t.tx_loadsz\t= 16,\n\t\t.fcr\t\t= UART_FCR_DMA_SELECT | UART_FCR_ENABLE_FIFO |\n\t\t\t\t  UART_FCR_R_TRIG_10,\n\t\t.rxtrig_bytes\t= {1, 4, 8, 14},\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_AFE,\n\t},\n\t[PORT_MTK_BTIF] = {\n\t\t.name\t\t= \"MediaTek BTIF\",\n\t\t.fifo_size\t= 16,\n\t\t.tx_loadsz\t= 16,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO |\n\t\t\t\t  UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT,\n\t\t.flags\t\t= UART_CAP_FIFO,\n\t},\n\t[PORT_NPCM] = {\n\t\t.name\t\t= \"Nuvoton 16550\",\n\t\t.fifo_size\t= 16,\n\t\t.tx_loadsz\t= 16,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10 |\n\t\t\t\t  UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT,\n\t\t.rxtrig_bytes\t= {1, 4, 8, 14},\n\t\t.flags\t\t= UART_CAP_FIFO,\n\t},\n\t[PORT_SUNIX] = {\n\t\t.name\t\t= \"Sunix\",\n\t\t.fifo_size\t= 128,\n\t\t.tx_loadsz\t= 128,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,\n\t\t.rxtrig_bytes\t= {1, 32, 64, 112},\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_SLEEP,\n\t},\n\t[PORT_ASPEED_VUART] = {\n\t\t.name\t\t= \"ASPEED VUART\",\n\t\t.fifo_size\t= 16,\n\t\t.tx_loadsz\t= 16,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_00,\n\t\t.rxtrig_bytes\t= {1, 4, 8, 14},\n\t\t.flags\t\t= UART_CAP_FIFO,\n\t},\n\t[PORT_MCHP16550A] = {\n\t\t.name           = \"MCHP16550A\",\n\t\t.fifo_size      = 256,\n\t\t.tx_loadsz      = 256,\n\t\t.fcr            = UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01,\n\t\t.rxtrig_bytes   = {2, 66, 130, 194},\n\t\t.flags          = UART_CAP_FIFO,\n\t},\n\t[PORT_BCM7271] = {\n\t\t.name\t\t= \"Broadcom BCM7271 UART\",\n\t\t.fifo_size\t= 32,\n\t\t.tx_loadsz\t= 32,\n\t\t.fcr\t\t= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01,\n\t\t.rxtrig_bytes\t= {1, 8, 16, 30},\n\t\t.flags\t\t= UART_CAP_FIFO | UART_CAP_AFE,\n\t},\n};\n\n \nstatic u32 default_serial_dl_read(struct uart_8250_port *up)\n{\n\t \n\tunsigned char dll = serial_in(up, UART_DLL);\n\tunsigned char dlm = serial_in(up, UART_DLM);\n\n\treturn dll | dlm << 8;\n}\n\n \nstatic void default_serial_dl_write(struct uart_8250_port *up, u32 value)\n{\n\tserial_out(up, UART_DLL, value & 0xff);\n\tserial_out(up, UART_DLM, value >> 8 & 0xff);\n}\n\nstatic unsigned int hub6_serial_in(struct uart_port *p, int offset)\n{\n\toffset = offset << p->regshift;\n\toutb(p->hub6 - 1 + offset, p->iobase);\n\treturn inb(p->iobase + 1);\n}\n\nstatic void hub6_serial_out(struct uart_port *p, int offset, int value)\n{\n\toffset = offset << p->regshift;\n\toutb(p->hub6 - 1 + offset, p->iobase);\n\toutb(value, p->iobase + 1);\n}\n\nstatic unsigned int mem_serial_in(struct uart_port *p, int offset)\n{\n\toffset = offset << p->regshift;\n\treturn readb(p->membase + offset);\n}\n\nstatic void mem_serial_out(struct uart_port *p, int offset, int value)\n{\n\toffset = offset << p->regshift;\n\twriteb(value, p->membase + offset);\n}\n\nstatic void mem16_serial_out(struct uart_port *p, int offset, int value)\n{\n\toffset = offset << p->regshift;\n\twritew(value, p->membase + offset);\n}\n\nstatic unsigned int mem16_serial_in(struct uart_port *p, int offset)\n{\n\toffset = offset << p->regshift;\n\treturn readw(p->membase + offset);\n}\n\nstatic void mem32_serial_out(struct uart_port *p, int offset, int value)\n{\n\toffset = offset << p->regshift;\n\twritel(value, p->membase + offset);\n}\n\nstatic unsigned int mem32_serial_in(struct uart_port *p, int offset)\n{\n\toffset = offset << p->regshift;\n\treturn readl(p->membase + offset);\n}\n\nstatic void mem32be_serial_out(struct uart_port *p, int offset, int value)\n{\n\toffset = offset << p->regshift;\n\tiowrite32be(value, p->membase + offset);\n}\n\nstatic unsigned int mem32be_serial_in(struct uart_port *p, int offset)\n{\n\toffset = offset << p->regshift;\n\treturn ioread32be(p->membase + offset);\n}\n\nstatic unsigned int io_serial_in(struct uart_port *p, int offset)\n{\n\toffset = offset << p->regshift;\n\treturn inb(p->iobase + offset);\n}\n\nstatic void io_serial_out(struct uart_port *p, int offset, int value)\n{\n\toffset = offset << p->regshift;\n\toutb(value, p->iobase + offset);\n}\n\nstatic int serial8250_default_handle_irq(struct uart_port *port);\n\nstatic void set_io_from_upio(struct uart_port *p)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\n\tup->dl_read = default_serial_dl_read;\n\tup->dl_write = default_serial_dl_write;\n\n\tswitch (p->iotype) {\n\tcase UPIO_HUB6:\n\t\tp->serial_in = hub6_serial_in;\n\t\tp->serial_out = hub6_serial_out;\n\t\tbreak;\n\n\tcase UPIO_MEM:\n\t\tp->serial_in = mem_serial_in;\n\t\tp->serial_out = mem_serial_out;\n\t\tbreak;\n\n\tcase UPIO_MEM16:\n\t\tp->serial_in = mem16_serial_in;\n\t\tp->serial_out = mem16_serial_out;\n\t\tbreak;\n\n\tcase UPIO_MEM32:\n\t\tp->serial_in = mem32_serial_in;\n\t\tp->serial_out = mem32_serial_out;\n\t\tbreak;\n\n\tcase UPIO_MEM32BE:\n\t\tp->serial_in = mem32be_serial_in;\n\t\tp->serial_out = mem32be_serial_out;\n\t\tbreak;\n\n\tdefault:\n\t\tp->serial_in = io_serial_in;\n\t\tp->serial_out = io_serial_out;\n\t\tbreak;\n\t}\n\t \n\tup->cur_iotype = p->iotype;\n\tp->handle_irq = serial8250_default_handle_irq;\n}\n\nstatic void\nserial_port_out_sync(struct uart_port *p, int offset, int value)\n{\n\tswitch (p->iotype) {\n\tcase UPIO_MEM:\n\tcase UPIO_MEM16:\n\tcase UPIO_MEM32:\n\tcase UPIO_MEM32BE:\n\tcase UPIO_AU:\n\t\tp->serial_out(p, offset, value);\n\t\tp->serial_in(p, UART_LCR);\t \n\t\tbreak;\n\tdefault:\n\t\tp->serial_out(p, offset, value);\n\t}\n}\n\n \nstatic void serial8250_clear_fifos(struct uart_8250_port *p)\n{\n\tif (p->capabilities & UART_CAP_FIFO) {\n\t\tserial_out(p, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t\tserial_out(p, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t\t       UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\t\tserial_out(p, UART_FCR, 0);\n\t}\n}\n\nstatic enum hrtimer_restart serial8250_em485_handle_start_tx(struct hrtimer *t);\nstatic enum hrtimer_restart serial8250_em485_handle_stop_tx(struct hrtimer *t);\n\nvoid serial8250_clear_and_reinit_fifos(struct uart_8250_port *p)\n{\n\tserial8250_clear_fifos(p);\n\tserial_out(p, UART_FCR, p->fcr);\n}\nEXPORT_SYMBOL_GPL(serial8250_clear_and_reinit_fifos);\n\nvoid serial8250_rpm_get(struct uart_8250_port *p)\n{\n\tif (!(p->capabilities & UART_CAP_RPM))\n\t\treturn;\n\tpm_runtime_get_sync(p->port.dev);\n}\nEXPORT_SYMBOL_GPL(serial8250_rpm_get);\n\nvoid serial8250_rpm_put(struct uart_8250_port *p)\n{\n\tif (!(p->capabilities & UART_CAP_RPM))\n\t\treturn;\n\tpm_runtime_mark_last_busy(p->port.dev);\n\tpm_runtime_put_autosuspend(p->port.dev);\n}\nEXPORT_SYMBOL_GPL(serial8250_rpm_put);\n\n \nstatic int serial8250_em485_init(struct uart_8250_port *p)\n{\n\t \n\tlockdep_assert_held_once(&p->port.lock);\n\n\tif (p->em485)\n\t\tgoto deassert_rts;\n\n\tp->em485 = kmalloc(sizeof(struct uart_8250_em485), GFP_ATOMIC);\n\tif (!p->em485)\n\t\treturn -ENOMEM;\n\n\thrtimer_init(&p->em485->stop_tx_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL);\n\thrtimer_init(&p->em485->start_tx_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL);\n\tp->em485->stop_tx_timer.function = &serial8250_em485_handle_stop_tx;\n\tp->em485->start_tx_timer.function = &serial8250_em485_handle_start_tx;\n\tp->em485->port = p;\n\tp->em485->active_timer = NULL;\n\tp->em485->tx_stopped = true;\n\ndeassert_rts:\n\tif (p->em485->tx_stopped)\n\t\tp->rs485_stop_tx(p);\n\n\treturn 0;\n}\n\n \nvoid serial8250_em485_destroy(struct uart_8250_port *p)\n{\n\tif (!p->em485)\n\t\treturn;\n\n\thrtimer_cancel(&p->em485->start_tx_timer);\n\thrtimer_cancel(&p->em485->stop_tx_timer);\n\n\tkfree(p->em485);\n\tp->em485 = NULL;\n}\nEXPORT_SYMBOL_GPL(serial8250_em485_destroy);\n\nstruct serial_rs485 serial8250_em485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | SER_RS485_RTS_AFTER_SEND |\n\t\t SER_RS485_TERMINATE_BUS | SER_RS485_RX_DURING_TX,\n\t.delay_rts_before_send = 1,\n\t.delay_rts_after_send = 1,\n};\nEXPORT_SYMBOL_GPL(serial8250_em485_supported);\n\n \nint serial8250_em485_config(struct uart_port *port, struct ktermios *termios,\n\t\t\t    struct serial_rs485 *rs485)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\t \n\tif (!!(rs485->flags & SER_RS485_RTS_ON_SEND) ==\n\t    !!(rs485->flags & SER_RS485_RTS_AFTER_SEND)) {\n\t\trs485->flags |= SER_RS485_RTS_ON_SEND;\n\t\trs485->flags &= ~SER_RS485_RTS_AFTER_SEND;\n\t}\n\n\t \n\tif (rs485->flags & SER_RS485_ENABLED)\n\t\treturn serial8250_em485_init(up);\n\n\tserial8250_em485_destroy(up);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(serial8250_em485_config);\n\n \nvoid serial8250_rpm_get_tx(struct uart_8250_port *p)\n{\n\tunsigned char rpm_active;\n\n\tif (!(p->capabilities & UART_CAP_RPM))\n\t\treturn;\n\n\trpm_active = xchg(&p->rpm_tx_active, 1);\n\tif (rpm_active)\n\t\treturn;\n\tpm_runtime_get_sync(p->port.dev);\n}\nEXPORT_SYMBOL_GPL(serial8250_rpm_get_tx);\n\nvoid serial8250_rpm_put_tx(struct uart_8250_port *p)\n{\n\tunsigned char rpm_active;\n\n\tif (!(p->capabilities & UART_CAP_RPM))\n\t\treturn;\n\n\trpm_active = xchg(&p->rpm_tx_active, 0);\n\tif (!rpm_active)\n\t\treturn;\n\tpm_runtime_mark_last_busy(p->port.dev);\n\tpm_runtime_put_autosuspend(p->port.dev);\n}\nEXPORT_SYMBOL_GPL(serial8250_rpm_put_tx);\n\n \nstatic void serial8250_set_sleep(struct uart_8250_port *p, int sleep)\n{\n\tunsigned char lcr = 0, efr = 0;\n\n\tserial8250_rpm_get(p);\n\n\tif (p->capabilities & UART_CAP_SLEEP) {\n\t\t \n\t\tspin_lock_irq(&p->port.lock);\n\t\tif (p->capabilities & UART_CAP_EFR) {\n\t\t\tlcr = serial_in(p, UART_LCR);\n\t\t\tefr = serial_in(p, UART_EFR);\n\t\t\tserial_out(p, UART_LCR, UART_LCR_CONF_MODE_B);\n\t\t\tserial_out(p, UART_EFR, UART_EFR_ECB);\n\t\t\tserial_out(p, UART_LCR, 0);\n\t\t}\n\t\tserial_out(p, UART_IER, sleep ? UART_IERX_SLEEP : 0);\n\t\tif (p->capabilities & UART_CAP_EFR) {\n\t\t\tserial_out(p, UART_LCR, UART_LCR_CONF_MODE_B);\n\t\t\tserial_out(p, UART_EFR, efr);\n\t\t\tserial_out(p, UART_LCR, lcr);\n\t\t}\n\t\tspin_unlock_irq(&p->port.lock);\n\t}\n\n\tserial8250_rpm_put(p);\n}\n\nstatic void serial8250_clear_IER(struct uart_8250_port *up)\n{\n\tif (up->capabilities & UART_CAP_UUE)\n\t\tserial_out(up, UART_IER, UART_IER_UUE);\n\telse\n\t\tserial_out(up, UART_IER, 0);\n}\n\n#ifdef CONFIG_SERIAL_8250_RSA\n \nstatic int __enable_rsa(struct uart_8250_port *up)\n{\n\tunsigned char mode;\n\tint result;\n\n\tmode = serial_in(up, UART_RSA_MSR);\n\tresult = mode & UART_RSA_MSR_FIFO;\n\n\tif (!result) {\n\t\tserial_out(up, UART_RSA_MSR, mode | UART_RSA_MSR_FIFO);\n\t\tmode = serial_in(up, UART_RSA_MSR);\n\t\tresult = mode & UART_RSA_MSR_FIFO;\n\t}\n\n\tif (result)\n\t\tup->port.uartclk = SERIAL_RSA_BAUD_BASE * 16;\n\n\treturn result;\n}\n\nstatic void enable_rsa(struct uart_8250_port *up)\n{\n\tif (up->port.type == PORT_RSA) {\n\t\tif (up->port.uartclk != SERIAL_RSA_BAUD_BASE * 16) {\n\t\t\tspin_lock_irq(&up->port.lock);\n\t\t\t__enable_rsa(up);\n\t\t\tspin_unlock_irq(&up->port.lock);\n\t\t}\n\t\tif (up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16)\n\t\t\tserial_out(up, UART_RSA_FRR, 0);\n\t}\n}\n\n \nstatic void disable_rsa(struct uart_8250_port *up)\n{\n\tunsigned char mode;\n\tint result;\n\n\tif (up->port.type == PORT_RSA &&\n\t    up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16) {\n\t\tspin_lock_irq(&up->port.lock);\n\n\t\tmode = serial_in(up, UART_RSA_MSR);\n\t\tresult = !(mode & UART_RSA_MSR_FIFO);\n\n\t\tif (!result) {\n\t\t\tserial_out(up, UART_RSA_MSR, mode & ~UART_RSA_MSR_FIFO);\n\t\t\tmode = serial_in(up, UART_RSA_MSR);\n\t\t\tresult = !(mode & UART_RSA_MSR_FIFO);\n\t\t}\n\n\t\tif (result)\n\t\t\tup->port.uartclk = SERIAL_RSA_BAUD_BASE_LO * 16;\n\t\tspin_unlock_irq(&up->port.lock);\n\t}\n}\n#endif  \n\n \nstatic int size_fifo(struct uart_8250_port *up)\n{\n\tunsigned char old_fcr, old_mcr, old_lcr;\n\tu32 old_dl;\n\tint count;\n\n\told_lcr = serial_in(up, UART_LCR);\n\tserial_out(up, UART_LCR, 0);\n\told_fcr = serial_in(up, UART_FCR);\n\told_mcr = serial8250_in_MCR(up);\n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t    UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\tserial8250_out_MCR(up, UART_MCR_LOOP);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\n\told_dl = serial_dl_read(up);\n\tserial_dl_write(up, 0x0001);\n\tserial_out(up, UART_LCR, UART_LCR_WLEN8);\n\tfor (count = 0; count < 256; count++)\n\t\tserial_out(up, UART_TX, count);\n\tmdelay(20); \n\tfor (count = 0; (serial_in(up, UART_LSR) & UART_LSR_DR) &&\n\t     (count < 256); count++)\n\t\tserial_in(up, UART_RX);\n\tserial_out(up, UART_FCR, old_fcr);\n\tserial8250_out_MCR(up, old_mcr);\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\n\tserial_dl_write(up, old_dl);\n\tserial_out(up, UART_LCR, old_lcr);\n\n\treturn count;\n}\n\n \nstatic unsigned int autoconfig_read_divisor_id(struct uart_8250_port *p)\n{\n\tunsigned char old_lcr;\n\tunsigned int id, old_dl;\n\n\told_lcr = serial_in(p, UART_LCR);\n\tserial_out(p, UART_LCR, UART_LCR_CONF_MODE_A);\n\told_dl = serial_dl_read(p);\n\tserial_dl_write(p, 0);\n\tid = serial_dl_read(p);\n\tserial_dl_write(p, old_dl);\n\n\tserial_out(p, UART_LCR, old_lcr);\n\n\treturn id;\n}\n\n \nstatic void autoconfig_has_efr(struct uart_8250_port *up)\n{\n\tunsigned int id1, id2, id3, rev;\n\n\t \n\tup->capabilities |= UART_CAP_EFR | UART_CAP_SLEEP;\n\n\t \n\n\t \n\tup->acr = 0;\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_out(up, UART_EFR, UART_EFR_ECB);\n\tserial_out(up, UART_LCR, 0x00);\n\tid1 = serial_icr_read(up, UART_ID1);\n\tid2 = serial_icr_read(up, UART_ID2);\n\tid3 = serial_icr_read(up, UART_ID3);\n\trev = serial_icr_read(up, UART_REV);\n\n\tDEBUG_AUTOCONF(\"950id=%02x:%02x:%02x:%02x \", id1, id2, id3, rev);\n\n\tif (id1 == 0x16 && id2 == 0xC9 &&\n\t    (id3 == 0x50 || id3 == 0x52 || id3 == 0x54)) {\n\t\tup->port.type = PORT_16C950;\n\n\t\t \n\t\tif (id3 == 0x52 && rev == 0x01)\n\t\t\tup->bugs |= UART_BUG_QUOT;\n\t\treturn;\n\t}\n\n\t \n\tid1 = autoconfig_read_divisor_id(up);\n\tDEBUG_AUTOCONF(\"850id=%04x \", id1);\n\n\tid2 = id1 >> 8;\n\tif (id2 == 0x10 || id2 == 0x12 || id2 == 0x14) {\n\t\tup->port.type = PORT_16850;\n\t\treturn;\n\t}\n\n\t \n\tif (size_fifo(up) == 64)\n\t\tup->port.type = PORT_16654;\n\telse\n\t\tup->port.type = PORT_16650V2;\n}\n\n \nstatic void autoconfig_8250(struct uart_8250_port *up)\n{\n\tunsigned char scratch, status1, status2;\n\n\tup->port.type = PORT_8250;\n\n\tscratch = serial_in(up, UART_SCR);\n\tserial_out(up, UART_SCR, 0xa5);\n\tstatus1 = serial_in(up, UART_SCR);\n\tserial_out(up, UART_SCR, 0x5a);\n\tstatus2 = serial_in(up, UART_SCR);\n\tserial_out(up, UART_SCR, scratch);\n\n\tif (status1 == 0xa5 && status2 == 0x5a)\n\t\tup->port.type = PORT_16450;\n}\n\nstatic int broken_efr(struct uart_8250_port *up)\n{\n\t \n\tif (autoconfig_read_divisor_id(up) == 0x0201 && size_fifo(up) == 16)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic void autoconfig_16550a(struct uart_8250_port *up)\n{\n\tunsigned char status1, status2;\n\tunsigned int iersave;\n\n\t \n\tlockdep_assert_held_once(&up->port.lock);\n\n\tup->port.type = PORT_16550A;\n\tup->capabilities |= UART_CAP_FIFO;\n\n\tif (!IS_ENABLED(CONFIG_SERIAL_8250_16550A_VARIANTS) &&\n\t    !(up->port.flags & UPF_FULL_PROBE))\n\t\treturn;\n\n\t \n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\n\tif (serial_in(up, UART_EFR) == 0) {\n\t\tserial_out(up, UART_EFR, 0xA8);\n\t\tif (serial_in(up, UART_EFR) != 0) {\n\t\t\tDEBUG_AUTOCONF(\"EFRv1 \");\n\t\t\tup->port.type = PORT_16650;\n\t\t\tup->capabilities |= UART_CAP_EFR | UART_CAP_SLEEP;\n\t\t} else {\n\t\t\tserial_out(up, UART_LCR, 0);\n\t\t\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t\t\t   UART_FCR7_64BYTE);\n\t\t\tstatus1 = serial_in(up, UART_IIR) & (UART_IIR_64BYTE_FIFO |\n\t\t\t\t\t\t\t     UART_IIR_FIFO_ENABLED);\n\t\t\tserial_out(up, UART_FCR, 0);\n\t\t\tserial_out(up, UART_LCR, 0);\n\n\t\t\tif (status1 == (UART_IIR_64BYTE_FIFO | UART_IIR_FIFO_ENABLED))\n\t\t\t\tup->port.type = PORT_16550A_FSL64;\n\t\t\telse\n\t\t\t\tDEBUG_AUTOCONF(\"Motorola 8xxx DUART \");\n\t\t}\n\t\tserial_out(up, UART_EFR, 0);\n\t\treturn;\n\t}\n\n\t \n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tif (serial_in(up, UART_EFR) == 0 && !broken_efr(up)) {\n\t\tDEBUG_AUTOCONF(\"EFRv2 \");\n\t\tautoconfig_has_efr(up);\n\t\treturn;\n\t}\n\n\t \n\tserial_out(up, UART_LCR, 0);\n\tstatus1 = serial8250_in_MCR(up);\n\tserial_out(up, UART_LCR, 0xE0);\n\tstatus2 = serial_in(up, 0x02);  \n\n\tif (!((status2 ^ status1) & UART_MCR_LOOP)) {\n\t\tserial_out(up, UART_LCR, 0);\n\t\tserial8250_out_MCR(up, status1 ^ UART_MCR_LOOP);\n\t\tserial_out(up, UART_LCR, 0xE0);\n\t\tstatus2 = serial_in(up, 0x02);  \n\t\tserial_out(up, UART_LCR, 0);\n\t\tserial8250_out_MCR(up, status1);\n\n\t\tif ((status2 ^ status1) & UART_MCR_LOOP) {\n\t\t\tunsigned short quot;\n\n\t\t\tserial_out(up, UART_LCR, 0xE0);\n\n\t\t\tquot = serial_dl_read(up);\n\t\t\tquot <<= 3;\n\n\t\t\tif (ns16550a_goto_highspeed(up))\n\t\t\t\tserial_dl_write(up, quot);\n\n\t\t\tserial_out(up, UART_LCR, 0);\n\n\t\t\tup->port.uartclk = 921600*16;\n\t\t\tup->port.type = PORT_NS16550A;\n\t\t\tup->capabilities |= UART_NATSEMI;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tserial_out(up, UART_LCR, 0);\n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);\n\tstatus1 = serial_in(up, UART_IIR) & (UART_IIR_64BYTE_FIFO | UART_IIR_FIFO_ENABLED);\n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\n\n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);\n\tstatus2 = serial_in(up, UART_IIR) & (UART_IIR_64BYTE_FIFO | UART_IIR_FIFO_ENABLED);\n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\n\n\tserial_out(up, UART_LCR, 0);\n\n\tDEBUG_AUTOCONF(\"iir1=%d iir2=%d \", status1, status2);\n\n\tif (status1 == UART_IIR_FIFO_ENABLED_16550A &&\n\t    status2 == (UART_IIR_64BYTE_FIFO | UART_IIR_FIFO_ENABLED_16550A)) {\n\t\tup->port.type = PORT_16750;\n\t\tup->capabilities |= UART_CAP_AFE | UART_CAP_SLEEP;\n\t\treturn;\n\t}\n\n\t \n\tiersave = serial_in(up, UART_IER);\n\tserial_out(up, UART_IER, iersave & ~UART_IER_UUE);\n\tif (!(serial_in(up, UART_IER) & UART_IER_UUE)) {\n\t\t \n\t\tserial_out(up, UART_IER, iersave | UART_IER_UUE);\n\t\tif (serial_in(up, UART_IER) & UART_IER_UUE) {\n\t\t\t \n\t\t\tDEBUG_AUTOCONF(\"Xscale \");\n\t\t\tup->port.type = PORT_XSCALE;\n\t\t\tup->capabilities |= UART_CAP_UUE | UART_CAP_RTOIE;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t \n\t\tDEBUG_AUTOCONF(\"Couldn't force IER_UUE to 0 \");\n\t}\n\tserial_out(up, UART_IER, iersave);\n\n\t \n\tif (up->port.type == PORT_16550A && size_fifo(up) == 64) {\n\t\tup->port.type = PORT_U6_16550A;\n\t\tup->capabilities |= UART_CAP_AFE;\n\t}\n}\n\n \nstatic void autoconfig(struct uart_8250_port *up)\n{\n\tunsigned char status1, scratch, scratch2, scratch3;\n\tunsigned char save_lcr, save_mcr;\n\tstruct uart_port *port = &up->port;\n\tunsigned long flags;\n\tunsigned int old_capabilities;\n\n\tif (!port->iobase && !port->mapbase && !port->membase)\n\t\treturn;\n\n\tDEBUG_AUTOCONF(\"%s: autoconf (0x%04lx, 0x%p): \",\n\t\t       port->name, port->iobase, port->membase);\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\n\tup->capabilities = 0;\n\tup->bugs = 0;\n\n\tif (!(port->flags & UPF_BUGGY_UART)) {\n\t\t \n\t\tscratch = serial_in(up, UART_IER);\n\t\tserial_out(up, UART_IER, 0);\n#ifdef __i386__\n\t\toutb(0xff, 0x080);\n#endif\n\t\t \n\t\tscratch2 = serial_in(up, UART_IER) & UART_IER_ALL_INTR;\n\t\tserial_out(up, UART_IER, UART_IER_ALL_INTR);\n#ifdef __i386__\n\t\toutb(0, 0x080);\n#endif\n\t\tscratch3 = serial_in(up, UART_IER) & UART_IER_ALL_INTR;\n\t\tserial_out(up, UART_IER, scratch);\n\t\tif (scratch2 != 0 || scratch3 != UART_IER_ALL_INTR) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\t\tDEBUG_AUTOCONF(\"IER test failed (%02x, %02x) \",\n\t\t\t\t       scratch2, scratch3);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsave_mcr = serial8250_in_MCR(up);\n\tsave_lcr = serial_in(up, UART_LCR);\n\n\t \n\tif (!(port->flags & UPF_SKIP_TEST)) {\n\t\tserial8250_out_MCR(up, UART_MCR_LOOP | UART_MCR_OUT2 | UART_MCR_RTS);\n\t\tstatus1 = serial_in(up, UART_MSR) & UART_MSR_STATUS_BITS;\n\t\tserial8250_out_MCR(up, save_mcr);\n\t\tif (status1 != (UART_MSR_DCD | UART_MSR_CTS)) {\n\t\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\t\tDEBUG_AUTOCONF(\"LOOP test failed (%02x) \",\n\t\t\t\t       status1);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\tserial_out(up, UART_EFR, 0);\n\tserial_out(up, UART_LCR, 0);\n\n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\n\n\tswitch (serial_in(up, UART_IIR) & UART_IIR_FIFO_ENABLED) {\n\tcase UART_IIR_FIFO_ENABLED_8250:\n\t\tautoconfig_8250(up);\n\t\tbreak;\n\tcase UART_IIR_FIFO_ENABLED_16550:\n\t\tport->type = PORT_16550;\n\t\tbreak;\n\tcase UART_IIR_FIFO_ENABLED_16550A:\n\t\tautoconfig_16550a(up);\n\t\tbreak;\n\tdefault:\n\t\tport->type = PORT_UNKNOWN;\n\t\tbreak;\n\t}\n\n#ifdef CONFIG_SERIAL_8250_RSA\n\t \n\tif (port->type == PORT_16550A && up->probe & UART_PROBE_RSA &&\n\t    __enable_rsa(up))\n\t\tport->type = PORT_RSA;\n#endif\n\n\tserial_out(up, UART_LCR, save_lcr);\n\n\tport->fifosize = uart_config[up->port.type].fifo_size;\n\told_capabilities = up->capabilities;\n\tup->capabilities = uart_config[port->type].flags;\n\tup->tx_loadsz = uart_config[port->type].tx_loadsz;\n\n\tif (port->type == PORT_UNKNOWN)\n\t\tgoto out_unlock;\n\n\t \n#ifdef CONFIG_SERIAL_8250_RSA\n\tif (port->type == PORT_RSA)\n\t\tserial_out(up, UART_RSA_FRR, 0);\n#endif\n\tserial8250_out_MCR(up, save_mcr);\n\tserial8250_clear_fifos(up);\n\tserial_in(up, UART_RX);\n\tserial8250_clear_IER(up);\n\nout_unlock:\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\tif (port->type == PORT_16550A && port->iotype == UPIO_PORT)\n\t\tfintek_8250_probe(up);\n\n\tif (up->capabilities != old_capabilities) {\n\t\tdev_warn(port->dev, \"detected caps %08x should be %08x\\n\",\n\t\t\t old_capabilities, up->capabilities);\n\t}\nout:\n\tDEBUG_AUTOCONF(\"iir=%d \", scratch);\n\tDEBUG_AUTOCONF(\"type=%s\\n\", uart_config[port->type].name);\n}\n\nstatic void autoconfig_irq(struct uart_8250_port *up)\n{\n\tstruct uart_port *port = &up->port;\n\tunsigned char save_mcr, save_ier;\n\tunsigned char save_ICP = 0;\n\tunsigned int ICP = 0;\n\tunsigned long irqs;\n\tint irq;\n\n\tif (port->flags & UPF_FOURPORT) {\n\t\tICP = (port->iobase & 0xfe0) | 0x1f;\n\t\tsave_ICP = inb_p(ICP);\n\t\toutb_p(0x80, ICP);\n\t\tinb_p(ICP);\n\t}\n\n\tif (uart_console(port))\n\t\tconsole_lock();\n\n\t \n\tprobe_irq_off(probe_irq_on());\n\tsave_mcr = serial8250_in_MCR(up);\n\t \n\tspin_lock_irq(&port->lock);\n\tsave_ier = serial_in(up, UART_IER);\n\tspin_unlock_irq(&port->lock);\n\tserial8250_out_MCR(up, UART_MCR_OUT1 | UART_MCR_OUT2);\n\n\tirqs = probe_irq_on();\n\tserial8250_out_MCR(up, 0);\n\tudelay(10);\n\tif (port->flags & UPF_FOURPORT) {\n\t\tserial8250_out_MCR(up, UART_MCR_DTR | UART_MCR_RTS);\n\t} else {\n\t\tserial8250_out_MCR(up,\n\t\t\tUART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);\n\t}\n\t \n\tspin_lock_irq(&port->lock);\n\tserial_out(up, UART_IER, UART_IER_ALL_INTR);\n\tspin_unlock_irq(&port->lock);\n\tserial_in(up, UART_LSR);\n\tserial_in(up, UART_RX);\n\tserial_in(up, UART_IIR);\n\tserial_in(up, UART_MSR);\n\tserial_out(up, UART_TX, 0xFF);\n\tudelay(20);\n\tirq = probe_irq_off(irqs);\n\n\tserial8250_out_MCR(up, save_mcr);\n\t \n\tspin_lock_irq(&port->lock);\n\tserial_out(up, UART_IER, save_ier);\n\tspin_unlock_irq(&port->lock);\n\n\tif (port->flags & UPF_FOURPORT)\n\t\toutb_p(save_ICP, ICP);\n\n\tif (uart_console(port))\n\t\tconsole_unlock();\n\n\tport->irq = (irq > 0) ? irq : 0;\n}\n\nstatic void serial8250_stop_rx(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\t \n\tlockdep_assert_held_once(&port->lock);\n\n\tserial8250_rpm_get(up);\n\n\tup->ier &= ~(UART_IER_RLSI | UART_IER_RDI);\n\tup->port.read_status_mask &= ~UART_LSR_DR;\n\tserial_port_out(port, UART_IER, up->ier);\n\n\tserial8250_rpm_put(up);\n}\n\n \nvoid serial8250_em485_stop_tx(struct uart_8250_port *p)\n{\n\tunsigned char mcr = serial8250_in_MCR(p);\n\n\t \n\tlockdep_assert_held_once(&p->port.lock);\n\n\tif (p->port.rs485.flags & SER_RS485_RTS_AFTER_SEND)\n\t\tmcr |= UART_MCR_RTS;\n\telse\n\t\tmcr &= ~UART_MCR_RTS;\n\tserial8250_out_MCR(p, mcr);\n\n\t \n\tif (!(p->port.rs485.flags & SER_RS485_RX_DURING_TX)) {\n\t\tserial8250_clear_and_reinit_fifos(p);\n\n\t\tp->ier |= UART_IER_RLSI | UART_IER_RDI;\n\t\tserial_port_out(&p->port, UART_IER, p->ier);\n\t}\n}\nEXPORT_SYMBOL_GPL(serial8250_em485_stop_tx);\n\nstatic enum hrtimer_restart serial8250_em485_handle_stop_tx(struct hrtimer *t)\n{\n\tstruct uart_8250_em485 *em485 = container_of(t, struct uart_8250_em485,\n\t\t\tstop_tx_timer);\n\tstruct uart_8250_port *p = em485->port;\n\tunsigned long flags;\n\n\tserial8250_rpm_get(p);\n\tspin_lock_irqsave(&p->port.lock, flags);\n\tif (em485->active_timer == &em485->stop_tx_timer) {\n\t\tp->rs485_stop_tx(p);\n\t\tem485->active_timer = NULL;\n\t\tem485->tx_stopped = true;\n\t}\n\tspin_unlock_irqrestore(&p->port.lock, flags);\n\tserial8250_rpm_put(p);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void start_hrtimer_ms(struct hrtimer *hrt, unsigned long msec)\n{\n\thrtimer_start(hrt, ms_to_ktime(msec), HRTIMER_MODE_REL);\n}\n\nstatic void __stop_tx_rs485(struct uart_8250_port *p, u64 stop_delay)\n{\n\tstruct uart_8250_em485 *em485 = p->em485;\n\n\t \n\tlockdep_assert_held_once(&p->port.lock);\n\n\tstop_delay += (u64)p->port.rs485.delay_rts_after_send * NSEC_PER_MSEC;\n\n\t \n\tif (stop_delay > 0) {\n\t\tem485->active_timer = &em485->stop_tx_timer;\n\t\thrtimer_start(&em485->stop_tx_timer, ns_to_ktime(stop_delay), HRTIMER_MODE_REL);\n\t} else {\n\t\tp->rs485_stop_tx(p);\n\t\tem485->active_timer = NULL;\n\t\tem485->tx_stopped = true;\n\t}\n}\n\nstatic inline void __stop_tx(struct uart_8250_port *p)\n{\n\tstruct uart_8250_em485 *em485 = p->em485;\n\n\tif (em485) {\n\t\tu16 lsr = serial_lsr_in(p);\n\t\tu64 stop_delay = 0;\n\n\t\tif (!(lsr & UART_LSR_THRE))\n\t\t\treturn;\n\t\t \n\t\tif (!(lsr & UART_LSR_TEMT)) {\n\t\t\tif (!(p->capabilities & UART_CAP_NOTEMT))\n\t\t\t\treturn;\n\t\t\t \n\t\t\tstop_delay = p->port.frame_time + DIV_ROUND_UP(p->port.frame_time, 7);\n\t\t}\n\n\t\t__stop_tx_rs485(p, stop_delay);\n\t}\n\n\tif (serial8250_clear_THRI(p))\n\t\tserial8250_rpm_put_tx(p);\n}\n\nstatic void serial8250_stop_tx(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\tserial8250_rpm_get(up);\n\t__stop_tx(up);\n\n\t \n\tif (port->type == PORT_16C950) {\n\t\tup->acr |= UART_ACR_TXDIS;\n\t\tserial_icr_write(up, UART_ACR, up->acr);\n\t}\n\tserial8250_rpm_put(up);\n}\n\nstatic inline void __start_tx(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\tif (up->dma && !up->dma->tx_dma(up))\n\t\treturn;\n\n\tif (serial8250_set_THRI(up)) {\n\t\tif (up->bugs & UART_BUG_TXEN) {\n\t\t\tu16 lsr = serial_lsr_in(up);\n\n\t\t\tif (lsr & UART_LSR_THRE)\n\t\t\t\tserial8250_tx_chars(up);\n\t\t}\n\t}\n\n\t \n\tif (port->type == PORT_16C950 && up->acr & UART_ACR_TXDIS) {\n\t\tup->acr &= ~UART_ACR_TXDIS;\n\t\tserial_icr_write(up, UART_ACR, up->acr);\n\t}\n}\n\n \nvoid serial8250_em485_start_tx(struct uart_8250_port *up)\n{\n\tunsigned char mcr = serial8250_in_MCR(up);\n\n\tif (!(up->port.rs485.flags & SER_RS485_RX_DURING_TX))\n\t\tserial8250_stop_rx(&up->port);\n\n\tif (up->port.rs485.flags & SER_RS485_RTS_ON_SEND)\n\t\tmcr |= UART_MCR_RTS;\n\telse\n\t\tmcr &= ~UART_MCR_RTS;\n\tserial8250_out_MCR(up, mcr);\n}\nEXPORT_SYMBOL_GPL(serial8250_em485_start_tx);\n\n \nstatic bool start_tx_rs485(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct uart_8250_em485 *em485 = up->em485;\n\n\t \n\tif (em485->active_timer == &em485->stop_tx_timer)\n\t\thrtimer_try_to_cancel(&em485->stop_tx_timer);\n\n\tem485->active_timer = NULL;\n\n\tif (em485->tx_stopped) {\n\t\tem485->tx_stopped = false;\n\n\t\tup->rs485_start_tx(up);\n\n\t\tif (up->port.rs485.delay_rts_before_send > 0) {\n\t\t\tem485->active_timer = &em485->start_tx_timer;\n\t\t\tstart_hrtimer_ms(&em485->start_tx_timer,\n\t\t\t\t\t up->port.rs485.delay_rts_before_send);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic enum hrtimer_restart serial8250_em485_handle_start_tx(struct hrtimer *t)\n{\n\tstruct uart_8250_em485 *em485 = container_of(t, struct uart_8250_em485,\n\t\t\tstart_tx_timer);\n\tstruct uart_8250_port *p = em485->port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&p->port.lock, flags);\n\tif (em485->active_timer == &em485->start_tx_timer) {\n\t\t__start_tx(&p->port);\n\t\tem485->active_timer = NULL;\n\t}\n\tspin_unlock_irqrestore(&p->port.lock, flags);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void serial8250_start_tx(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct uart_8250_em485 *em485 = up->em485;\n\n\t \n\tlockdep_assert_held_once(&port->lock);\n\n\tif (!port->x_char && uart_circ_empty(&port->state->xmit))\n\t\treturn;\n\n\tserial8250_rpm_get_tx(up);\n\n\tif (em485) {\n\t\tif ((em485->active_timer == &em485->start_tx_timer) ||\n\t\t    !start_tx_rs485(port))\n\t\t\treturn;\n\t}\n\t__start_tx(port);\n}\n\nstatic void serial8250_throttle(struct uart_port *port)\n{\n\tport->throttle(port);\n}\n\nstatic void serial8250_unthrottle(struct uart_port *port)\n{\n\tport->unthrottle(port);\n}\n\nstatic void serial8250_disable_ms(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\t \n\tlockdep_assert_held_once(&port->lock);\n\n\t \n\tif (up->bugs & UART_BUG_NOMSR)\n\t\treturn;\n\n\tmctrl_gpio_disable_ms(up->gpios);\n\n\tup->ier &= ~UART_IER_MSI;\n\tserial_port_out(port, UART_IER, up->ier);\n}\n\nstatic void serial8250_enable_ms(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\t \n\tlockdep_assert_held_once(&port->lock);\n\n\t \n\tif (up->bugs & UART_BUG_NOMSR)\n\t\treturn;\n\n\tmctrl_gpio_enable_ms(up->gpios);\n\n\tup->ier |= UART_IER_MSI;\n\n\tserial8250_rpm_get(up);\n\tserial_port_out(port, UART_IER, up->ier);\n\tserial8250_rpm_put(up);\n}\n\nvoid serial8250_read_char(struct uart_8250_port *up, u16 lsr)\n{\n\tstruct uart_port *port = &up->port;\n\tu8 ch, flag = TTY_NORMAL;\n\n\tif (likely(lsr & UART_LSR_DR))\n\t\tch = serial_in(up, UART_RX);\n\telse\n\t\t \n\t\tch = 0;\n\n\tport->icount.rx++;\n\n\tlsr |= up->lsr_saved_flags;\n\tup->lsr_saved_flags = 0;\n\n\tif (unlikely(lsr & UART_LSR_BRK_ERROR_BITS)) {\n\t\tif (lsr & UART_LSR_BI) {\n\t\t\tlsr &= ~(UART_LSR_FE | UART_LSR_PE);\n\t\t\tport->icount.brk++;\n\t\t\t \n\t\t\tif (uart_handle_break(port))\n\t\t\t\treturn;\n\t\t} else if (lsr & UART_LSR_PE)\n\t\t\tport->icount.parity++;\n\t\telse if (lsr & UART_LSR_FE)\n\t\t\tport->icount.frame++;\n\t\tif (lsr & UART_LSR_OE)\n\t\t\tport->icount.overrun++;\n\n\t\t \n\t\tlsr &= port->read_status_mask;\n\n\t\tif (lsr & UART_LSR_BI) {\n\t\t\tdev_dbg(port->dev, \"handling break\\n\");\n\t\t\tflag = TTY_BREAK;\n\t\t} else if (lsr & UART_LSR_PE)\n\t\t\tflag = TTY_PARITY;\n\t\telse if (lsr & UART_LSR_FE)\n\t\t\tflag = TTY_FRAME;\n\t}\n\tif (uart_prepare_sysrq_char(port, ch))\n\t\treturn;\n\n\tuart_insert_char(port, lsr, UART_LSR_OE, ch, flag);\n}\nEXPORT_SYMBOL_GPL(serial8250_read_char);\n\n \nu16 serial8250_rx_chars(struct uart_8250_port *up, u16 lsr)\n{\n\tstruct uart_port *port = &up->port;\n\tint max_count = 256;\n\n\tdo {\n\t\tserial8250_read_char(up, lsr);\n\t\tif (--max_count == 0)\n\t\t\tbreak;\n\t\tlsr = serial_in(up, UART_LSR);\n\t} while (lsr & (UART_LSR_DR | UART_LSR_BI));\n\n\ttty_flip_buffer_push(&port->state->port);\n\treturn lsr;\n}\nEXPORT_SYMBOL_GPL(serial8250_rx_chars);\n\nvoid serial8250_tx_chars(struct uart_8250_port *up)\n{\n\tstruct uart_port *port = &up->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tint count;\n\n\tif (port->x_char) {\n\t\tuart_xchar_out(port, UART_TX);\n\t\treturn;\n\t}\n\tif (uart_tx_stopped(port)) {\n\t\tserial8250_stop_tx(port);\n\t\treturn;\n\t}\n\tif (uart_circ_empty(xmit)) {\n\t\t__stop_tx(up);\n\t\treturn;\n\t}\n\n\tcount = up->tx_loadsz;\n\tdo {\n\t\tserial_out(up, UART_TX, xmit->buf[xmit->tail]);\n\t\tif (up->bugs & UART_BUG_TXRACE) {\n\t\t\t \n\t\t\tserial_in(up, UART_SCR);\n\t\t}\n\t\tuart_xmit_advance(port, 1);\n\t\tif (uart_circ_empty(xmit))\n\t\t\tbreak;\n\t\tif ((up->capabilities & UART_CAP_HFIFO) &&\n\t\t    !uart_lsr_tx_empty(serial_in(up, UART_LSR)))\n\t\t\tbreak;\n\t\t \n\t\tif ((up->capabilities & UART_CAP_MINI) &&\n\t\t    !(serial_in(up, UART_LSR) & UART_LSR_THRE))\n\t\t\tbreak;\n\t} while (--count > 0);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\t \n\tif (uart_circ_empty(xmit) && !(up->capabilities & UART_CAP_RPM))\n\t\t__stop_tx(up);\n}\nEXPORT_SYMBOL_GPL(serial8250_tx_chars);\n\n \nunsigned int serial8250_modem_status(struct uart_8250_port *up)\n{\n\tstruct uart_port *port = &up->port;\n\tunsigned int status = serial_in(up, UART_MSR);\n\n\tstatus |= up->msr_saved_flags;\n\tup->msr_saved_flags = 0;\n\tif (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&\n\t    port->state != NULL) {\n\t\tif (status & UART_MSR_TERI)\n\t\t\tport->icount.rng++;\n\t\tif (status & UART_MSR_DDSR)\n\t\t\tport->icount.dsr++;\n\t\tif (status & UART_MSR_DDCD)\n\t\t\tuart_handle_dcd_change(port, status & UART_MSR_DCD);\n\t\tif (status & UART_MSR_DCTS)\n\t\t\tuart_handle_cts_change(port, status & UART_MSR_CTS);\n\n\t\twake_up_interruptible(&port->state->port.delta_msr_wait);\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(serial8250_modem_status);\n\nstatic bool handle_rx_dma(struct uart_8250_port *up, unsigned int iir)\n{\n\tswitch (iir & 0x3f) {\n\tcase UART_IIR_THRI:\n\t\t \n\t\treturn false;\n\tcase UART_IIR_RDI:\n\t\tif (!up->dma->rx_running)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase UART_IIR_RLSI:\n\tcase UART_IIR_RX_TIMEOUT:\n\t\tserial8250_rx_dma_flush(up);\n\t\treturn true;\n\t}\n\treturn up->dma->rx_dma(up);\n}\n\n \nint serial8250_handle_irq(struct uart_port *port, unsigned int iir)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct tty_port *tport = &port->state->port;\n\tbool skip_rx = false;\n\tunsigned long flags;\n\tu16 status;\n\n\tif (iir & UART_IIR_NO_INT)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tstatus = serial_lsr_in(up);\n\n\t \n\tif (!(status & (UART_LSR_FIFOE | UART_LSR_BRK_ERROR_BITS)) &&\n\t    (port->status & (UPSTAT_AUTOCTS | UPSTAT_AUTORTS)) &&\n\t    !(port->read_status_mask & UART_LSR_DR))\n\t\tskip_rx = true;\n\n\tif (status & (UART_LSR_DR | UART_LSR_BI) && !skip_rx) {\n\t\tstruct irq_data *d;\n\n\t\td = irq_get_irq_data(port->irq);\n\t\tif (d && irqd_is_wakeup_set(d))\n\t\t\tpm_wakeup_event(tport->tty->dev, 0);\n\t\tif (!up->dma || handle_rx_dma(up, iir))\n\t\t\tstatus = serial8250_rx_chars(up, status);\n\t}\n\tserial8250_modem_status(up);\n\tif ((status & UART_LSR_THRE) && (up->ier & UART_IER_THRI)) {\n\t\tif (!up->dma || up->dma->tx_err)\n\t\t\tserial8250_tx_chars(up);\n\t\telse if (!up->dma->tx_running)\n\t\t\t__stop_tx(up);\n\t}\n\n\tuart_unlock_and_check_sysrq_irqrestore(port, flags);\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(serial8250_handle_irq);\n\nstatic int serial8250_default_handle_irq(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned int iir;\n\tint ret;\n\n\tserial8250_rpm_get(up);\n\n\tiir = serial_port_in(port, UART_IIR);\n\tret = serial8250_handle_irq(port, iir);\n\n\tserial8250_rpm_put(up);\n\treturn ret;\n}\n\n \nstatic int serial8250_tx_threshold_handle_irq(struct uart_port *port)\n{\n\tunsigned long flags;\n\tunsigned int iir = serial_port_in(port, UART_IIR);\n\n\t \n\tif ((iir & UART_IIR_ID) == UART_IIR_THRI) {\n\t\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tserial8250_tx_chars(up);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t}\n\n\tiir = serial_port_in(port, UART_IIR);\n\treturn serial8250_handle_irq(port, iir);\n}\n\nstatic unsigned int serial8250_tx_empty(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned int result = 0;\n\tunsigned long flags;\n\n\tserial8250_rpm_get(up);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (!serial8250_tx_dma_running(up) && uart_lsr_tx_empty(serial_lsr_in(up)))\n\t\tresult = TIOCSER_TEMT;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tserial8250_rpm_put(up);\n\n\treturn result;\n}\n\nunsigned int serial8250_do_get_mctrl(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned int status;\n\tunsigned int val;\n\n\tserial8250_rpm_get(up);\n\tstatus = serial8250_modem_status(up);\n\tserial8250_rpm_put(up);\n\n\tval = serial8250_MSR_to_TIOCM(status);\n\tif (up->gpios)\n\t\treturn mctrl_gpio_get(up->gpios, &val);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(serial8250_do_get_mctrl);\n\nstatic unsigned int serial8250_get_mctrl(struct uart_port *port)\n{\n\tif (port->get_mctrl)\n\t\treturn port->get_mctrl(port);\n\treturn serial8250_do_get_mctrl(port);\n}\n\nvoid serial8250_do_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned char mcr;\n\n\tmcr = serial8250_TIOCM_to_MCR(mctrl);\n\n\tmcr |= up->mcr;\n\n\tserial8250_out_MCR(up, mcr);\n}\nEXPORT_SYMBOL_GPL(serial8250_do_set_mctrl);\n\nstatic void serial8250_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tif (port->rs485.flags & SER_RS485_ENABLED)\n\t\treturn;\n\n\tif (port->set_mctrl)\n\t\tport->set_mctrl(port, mctrl);\n\telse\n\t\tserial8250_do_set_mctrl(port, mctrl);\n}\n\nstatic void serial8250_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned long flags;\n\n\tserial8250_rpm_get(up);\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (break_state == -1)\n\t\tup->lcr |= UART_LCR_SBC;\n\telse\n\t\tup->lcr &= ~UART_LCR_SBC;\n\tserial_port_out(port, UART_LCR, up->lcr);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tserial8250_rpm_put(up);\n}\n\nstatic void wait_for_lsr(struct uart_8250_port *up, int bits)\n{\n\tunsigned int status, tmout = 10000;\n\n\t \n\tfor (;;) {\n\t\tstatus = serial_lsr_in(up);\n\n\t\tif ((status & bits) == bits)\n\t\t\tbreak;\n\t\tif (--tmout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t\ttouch_nmi_watchdog();\n\t}\n}\n\n \nstatic void wait_for_xmitr(struct uart_8250_port *up, int bits)\n{\n\tunsigned int tmout;\n\n\twait_for_lsr(up, bits);\n\n\t \n\tif (up->port.flags & UPF_CONS_FLOW) {\n\t\tfor (tmout = 1000000; tmout; tmout--) {\n\t\t\tunsigned int msr = serial_in(up, UART_MSR);\n\t\t\tup->msr_saved_flags |= msr & MSR_SAVE_FLAGS;\n\t\t\tif (msr & UART_MSR_CTS)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n \n\nstatic int serial8250_get_poll_char(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tint status;\n\tu16 lsr;\n\n\tserial8250_rpm_get(up);\n\n\tlsr = serial_port_in(port, UART_LSR);\n\n\tif (!(lsr & UART_LSR_DR)) {\n\t\tstatus = NO_POLL_CHAR;\n\t\tgoto out;\n\t}\n\n\tstatus = serial_port_in(port, UART_RX);\nout:\n\tserial8250_rpm_put(up);\n\treturn status;\n}\n\n\nstatic void serial8250_put_poll_char(struct uart_port *port,\n\t\t\t unsigned char c)\n{\n\tunsigned int ier;\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\t \n\n\tserial8250_rpm_get(up);\n\t \n\tier = serial_port_in(port, UART_IER);\n\tserial8250_clear_IER(up);\n\n\twait_for_xmitr(up, UART_LSR_BOTH_EMPTY);\n\t \n\tserial_port_out(port, UART_TX, c);\n\n\t \n\twait_for_xmitr(up, UART_LSR_BOTH_EMPTY);\n\tserial_port_out(port, UART_IER, ier);\n\tserial8250_rpm_put(up);\n}\n\n#endif  \n\nint serial8250_do_startup(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned long flags;\n\tunsigned char iir;\n\tint retval;\n\tu16 lsr;\n\n\tif (!port->fifosize)\n\t\tport->fifosize = uart_config[port->type].fifo_size;\n\tif (!up->tx_loadsz)\n\t\tup->tx_loadsz = uart_config[port->type].tx_loadsz;\n\tif (!up->capabilities)\n\t\tup->capabilities = uart_config[port->type].flags;\n\tup->mcr = 0;\n\n\tif (port->iotype != up->cur_iotype)\n\t\tset_io_from_upio(port);\n\n\tserial8250_rpm_get(up);\n\tif (port->type == PORT_16C950) {\n\t\t \n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tup->acr = 0;\n\t\tserial_port_out(port, UART_LCR, UART_LCR_CONF_MODE_B);\n\t\tserial_port_out(port, UART_EFR, UART_EFR_ECB);\n\t\tserial_port_out(port, UART_IER, 0);\n\t\tserial_port_out(port, UART_LCR, 0);\n\t\tserial_icr_write(up, UART_CSR, 0);  \n\t\tserial_port_out(port, UART_LCR, UART_LCR_CONF_MODE_B);\n\t\tserial_port_out(port, UART_EFR, UART_EFR_ECB);\n\t\tserial_port_out(port, UART_LCR, 0);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t}\n\n\tif (port->type == PORT_DA830) {\n\t\t \n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tserial_port_out(port, UART_IER, 0);\n\t\tserial_port_out(port, UART_DA830_PWREMU_MGMT, 0);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tmdelay(10);\n\n\t\t \n\t\tserial_port_out(port, UART_DA830_PWREMU_MGMT,\n\t\t\t\tUART_DA830_PWREMU_MGMT_UTRST |\n\t\t\t\tUART_DA830_PWREMU_MGMT_URRST |\n\t\t\t\tUART_DA830_PWREMU_MGMT_FREE);\n\t}\n\n\tif (port->type == PORT_NPCM) {\n\t\t \n\t\tserial_port_out(port, UART_NPCM_TOR, UART_NPCM_TOIE | 0x20);\n\t}\n\n#ifdef CONFIG_SERIAL_8250_RSA\n\t \n\tenable_rsa(up);\n#endif\n\n\t \n\tserial8250_clear_fifos(up);\n\n\t \n\tserial_port_in(port, UART_LSR);\n\tserial_port_in(port, UART_RX);\n\tserial_port_in(port, UART_IIR);\n\tserial_port_in(port, UART_MSR);\n\n\t \n\tif (!(port->flags & UPF_BUGGY_UART) &&\n\t    (serial_port_in(port, UART_LSR) == 0xff)) {\n\t\tdev_info_ratelimited(port->dev, \"LSR safety check engaged!\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tif (port->type == PORT_16850) {\n\t\tunsigned char fctr;\n\n\t\tserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\n\n\t\tfctr = serial_in(up, UART_FCTR) & ~(UART_FCTR_RX|UART_FCTR_TX);\n\t\tserial_port_out(port, UART_FCTR,\n\t\t\t\tfctr | UART_FCTR_TRGD | UART_FCTR_RX);\n\t\tserial_port_out(port, UART_TRG, UART_TRG_96);\n\t\tserial_port_out(port, UART_FCTR,\n\t\t\t\tfctr | UART_FCTR_TRGD | UART_FCTR_TX);\n\t\tserial_port_out(port, UART_TRG, UART_TRG_96);\n\n\t\tserial_port_out(port, UART_LCR, 0);\n\t}\n\n\t \n\tif (((port->type == PORT_ALTR_16550_F32) ||\n\t     (port->type == PORT_ALTR_16550_F64) ||\n\t     (port->type == PORT_ALTR_16550_F128)) && (port->fifosize > 1)) {\n\t\t \n\t\tif ((up->tx_loadsz < 2) || (up->tx_loadsz > port->fifosize)) {\n\t\t\tdev_err(port->dev, \"TX FIFO Threshold errors, skipping\\n\");\n\t\t} else {\n\t\t\tserial_port_out(port, UART_ALTR_AFR,\n\t\t\t\t\tUART_ALTR_EN_TXFIFO_LW);\n\t\t\tserial_port_out(port, UART_ALTR_TX_LOW,\n\t\t\t\t\tport->fifosize - up->tx_loadsz);\n\t\t\tport->handle_irq = serial8250_tx_threshold_handle_irq;\n\t\t}\n\t}\n\n\t \n\tif (port->irq && (up->port.flags & UPF_SHARE_IRQ))\n\t\tup->port.irqflags |= IRQF_SHARED;\n\n\tretval = up->ops->setup_irq(up);\n\tif (retval)\n\t\tgoto out;\n\n\tif (port->irq && !(up->port.flags & UPF_NO_THRE_TEST)) {\n\t\tunsigned char iir1;\n\n\t\tif (port->irqflags & IRQF_SHARED)\n\t\t\tdisable_irq_nosync(port->irq);\n\n\t\t \n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\t\twait_for_xmitr(up, UART_LSR_THRE);\n\t\tserial_port_out_sync(port, UART_IER, UART_IER_THRI);\n\t\tudelay(1);  \n\t\tiir1 = serial_port_in(port, UART_IIR);\n\t\tserial_port_out(port, UART_IER, 0);\n\t\tserial_port_out_sync(port, UART_IER, UART_IER_THRI);\n\t\tudelay(1);  \n\t\tiir = serial_port_in(port, UART_IIR);\n\t\tserial_port_out(port, UART_IER, 0);\n\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\tif (port->irqflags & IRQF_SHARED)\n\t\t\tenable_irq(port->irq);\n\n\t\t \n\t\tif ((!(iir1 & UART_IIR_NO_INT) && (iir & UART_IIR_NO_INT)) ||\n\t\t    up->port.flags & UPF_BUG_THRE) {\n\t\t\tup->bugs |= UART_BUG_THRE;\n\t\t}\n\t}\n\n\tup->ops->setup_timer(up);\n\n\t \n\tserial_port_out(port, UART_LCR, UART_LCR_WLEN8);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (up->port.flags & UPF_FOURPORT) {\n\t\tif (!up->port.irq)\n\t\t\tup->port.mctrl |= TIOCM_OUT1;\n\t} else\n\t\t \n\t\tif (port->irq)\n\t\t\tup->port.mctrl |= TIOCM_OUT2;\n\n\tserial8250_set_mctrl(port, port->mctrl);\n\n\t \n\tif (up->port.quirks & UPQ_NO_TXEN_TEST)\n\t\tgoto dont_test_tx_en;\n\n\t \n\tserial_port_out(port, UART_IER, UART_IER_THRI);\n\tlsr = serial_port_in(port, UART_LSR);\n\tiir = serial_port_in(port, UART_IIR);\n\tserial_port_out(port, UART_IER, 0);\n\n\tif (lsr & UART_LSR_TEMT && iir & UART_IIR_NO_INT) {\n\t\tif (!(up->bugs & UART_BUG_TXEN)) {\n\t\t\tup->bugs |= UART_BUG_TXEN;\n\t\t\tdev_dbg(port->dev, \"enabling bad tx status workarounds\\n\");\n\t\t}\n\t} else {\n\t\tup->bugs &= ~UART_BUG_TXEN;\n\t}\n\ndont_test_tx_en:\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\tserial_port_in(port, UART_LSR);\n\tserial_port_in(port, UART_RX);\n\tserial_port_in(port, UART_IIR);\n\tserial_port_in(port, UART_MSR);\n\tup->lsr_saved_flags = 0;\n\tup->msr_saved_flags = 0;\n\n\t \n\tif (up->dma) {\n\t\tconst char *msg = NULL;\n\n\t\tif (uart_console(port))\n\t\t\tmsg = \"forbid DMA for kernel console\";\n\t\telse if (serial8250_request_dma(up))\n\t\t\tmsg = \"failed to request DMA\";\n\t\tif (msg) {\n\t\t\tdev_warn_ratelimited(port->dev, \"%s\\n\", msg);\n\t\t\tup->dma = NULL;\n\t\t}\n\t}\n\n\t \n\tup->ier = UART_IER_RLSI | UART_IER_RDI;\n\n\tif (port->flags & UPF_FOURPORT) {\n\t\tunsigned int icp;\n\t\t \n\t\ticp = (port->iobase & 0xfe0) | 0x01f;\n\t\toutb_p(0x80, icp);\n\t\tinb_p(icp);\n\t}\n\tretval = 0;\nout:\n\tserial8250_rpm_put(up);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(serial8250_do_startup);\n\nstatic int serial8250_startup(struct uart_port *port)\n{\n\tif (port->startup)\n\t\treturn port->startup(port);\n\treturn serial8250_do_startup(port);\n}\n\nvoid serial8250_do_shutdown(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned long flags;\n\n\tserial8250_rpm_get(up);\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tup->ier = 0;\n\tserial_port_out(port, UART_IER, 0);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tsynchronize_irq(port->irq);\n\n\tif (up->dma)\n\t\tserial8250_release_dma(up);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (port->flags & UPF_FOURPORT) {\n\t\t \n\t\tinb((port->iobase & 0xfe0) | 0x1f);\n\t\tport->mctrl |= TIOCM_OUT1;\n\t} else\n\t\tport->mctrl &= ~TIOCM_OUT2;\n\n\tserial8250_set_mctrl(port, port->mctrl);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\tserial_port_out(port, UART_LCR,\n\t\t\tserial_port_in(port, UART_LCR) & ~UART_LCR_SBC);\n\tserial8250_clear_fifos(up);\n\n#ifdef CONFIG_SERIAL_8250_RSA\n\t \n\tdisable_rsa(up);\n#endif\n\n\t \n\tserial_port_in(port, UART_RX);\n\tserial8250_rpm_put(up);\n\n\tup->ops->release_irq(up);\n}\nEXPORT_SYMBOL_GPL(serial8250_do_shutdown);\n\nstatic void serial8250_shutdown(struct uart_port *port)\n{\n\tif (port->shutdown)\n\t\tport->shutdown(port);\n\telse\n\t\tserial8250_do_shutdown(port);\n}\n\n \nstatic unsigned int npcm_get_divisor(struct uart_8250_port *up,\n\t\tunsigned int baud)\n{\n\tstruct uart_port *port = &up->port;\n\n\treturn DIV_ROUND_CLOSEST(port->uartclk, 16 * baud + 2) - 2;\n}\n\nstatic unsigned int serial8250_do_get_divisor(struct uart_port *port,\n\t\t\t\t\t      unsigned int baud,\n\t\t\t\t\t      unsigned int *frac)\n{\n\tupf_t magic_multiplier = port->flags & UPF_MAGIC_MULTIPLIER;\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned int quot;\n\n\t \n\tif (magic_multiplier && baud >= port->uartclk / 6)\n\t\tquot = 0x8001;\n\telse if (magic_multiplier && baud >= port->uartclk / 12)\n\t\tquot = 0x8002;\n\telse if (up->port.type == PORT_NPCM)\n\t\tquot = npcm_get_divisor(up, baud);\n\telse\n\t\tquot = uart_get_divisor(port, baud);\n\n\t \n\tif (up->bugs & UART_BUG_QUOT && (quot & 0xff) == 0)\n\t\tquot++;\n\n\treturn quot;\n}\n\nstatic unsigned int serial8250_get_divisor(struct uart_port *port,\n\t\t\t\t\t   unsigned int baud,\n\t\t\t\t\t   unsigned int *frac)\n{\n\tif (port->get_divisor)\n\t\treturn port->get_divisor(port, baud, frac);\n\n\treturn serial8250_do_get_divisor(port, baud, frac);\n}\n\nstatic unsigned char serial8250_compute_lcr(struct uart_8250_port *up,\n\t\t\t\t\t    tcflag_t c_cflag)\n{\n\tunsigned char cval;\n\n\tcval = UART_LCR_WLEN(tty_get_char_size(c_cflag));\n\n\tif (c_cflag & CSTOPB)\n\t\tcval |= UART_LCR_STOP;\n\tif (c_cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(c_cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\tif (c_cflag & CMSPAR)\n\t\tcval |= UART_LCR_SPAR;\n\n\treturn cval;\n}\n\nvoid serial8250_do_set_divisor(struct uart_port *port, unsigned int baud,\n\t\t\t       unsigned int quot, unsigned int quot_frac)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\t \n\tif (is_omap1510_8250(up)) {\n\t\tif (baud == 115200) {\n\t\t\tquot = 1;\n\t\t\tserial_port_out(port, UART_OMAP_OSC_12M_SEL, 1);\n\t\t} else\n\t\t\tserial_port_out(port, UART_OMAP_OSC_12M_SEL, 0);\n\t}\n\n\t \n\tif (up->capabilities & UART_NATSEMI)\n\t\tserial_port_out(port, UART_LCR, 0xe0);\n\telse\n\t\tserial_port_out(port, UART_LCR, up->lcr | UART_LCR_DLAB);\n\n\tserial_dl_write(up, quot);\n}\nEXPORT_SYMBOL_GPL(serial8250_do_set_divisor);\n\nstatic void serial8250_set_divisor(struct uart_port *port, unsigned int baud,\n\t\t\t\t   unsigned int quot, unsigned int quot_frac)\n{\n\tif (port->set_divisor)\n\t\tport->set_divisor(port, baud, quot, quot_frac);\n\telse\n\t\tserial8250_do_set_divisor(port, baud, quot, quot_frac);\n}\n\nstatic unsigned int serial8250_get_baud_rate(struct uart_port *port,\n\t\t\t\t\t     struct ktermios *termios,\n\t\t\t\t\t     const struct ktermios *old)\n{\n\tunsigned int tolerance = port->uartclk / 100;\n\tunsigned int min;\n\tunsigned int max;\n\n\t \n\tif (port->flags & UPF_MAGIC_MULTIPLIER) {\n\t\tmin = port->uartclk / 16 / UART_DIV_MAX >> 1;\n\t\tmax = (port->uartclk + tolerance) / 4;\n\t} else {\n\t\tmin = port->uartclk / 16 / UART_DIV_MAX;\n\t\tmax = (port->uartclk + tolerance) / 16;\n\t}\n\n\t \n\treturn uart_get_baud_rate(port, termios, old, min, max);\n}\n\n \nvoid serial8250_update_uartclk(struct uart_port *port, unsigned int uartclk)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned int baud, quot, frac = 0;\n\tstruct ktermios *termios;\n\tstruct tty_struct *tty;\n\tunsigned long flags;\n\n\ttty = tty_port_tty_get(tport);\n\tif (!tty) {\n\t\tmutex_lock(&tport->mutex);\n\t\tport->uartclk = uartclk;\n\t\tmutex_unlock(&tport->mutex);\n\t\treturn;\n\t}\n\n\tdown_write(&tty->termios_rwsem);\n\tmutex_lock(&tport->mutex);\n\n\tif (port->uartclk == uartclk)\n\t\tgoto out_unlock;\n\n\tport->uartclk = uartclk;\n\n\tif (!tty_port_initialized(tport))\n\t\tgoto out_unlock;\n\n\ttermios = &tty->termios;\n\n\tbaud = serial8250_get_baud_rate(port, termios, NULL);\n\tquot = serial8250_get_divisor(port, baud, &frac);\n\n\tserial8250_rpm_get(up);\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tserial8250_set_divisor(port, baud, quot, frac);\n\tserial_port_out(port, UART_LCR, up->lcr);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tserial8250_rpm_put(up);\n\nout_unlock:\n\tmutex_unlock(&tport->mutex);\n\tup_write(&tty->termios_rwsem);\n\ttty_kref_put(tty);\n}\nEXPORT_SYMBOL_GPL(serial8250_update_uartclk);\n\nvoid\nserial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t          const struct ktermios *old)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tunsigned char cval;\n\tunsigned long flags;\n\tunsigned int baud, quot, frac = 0;\n\n\tif (up->capabilities & UART_CAP_MINI) {\n\t\ttermios->c_cflag &= ~(CSTOPB | PARENB | PARODD | CMSPAR);\n\t\tif ((termios->c_cflag & CSIZE) == CS5 ||\n\t\t    (termios->c_cflag & CSIZE) == CS6)\n\t\t\ttermios->c_cflag = (termios->c_cflag & ~CSIZE) | CS7;\n\t}\n\tcval = serial8250_compute_lcr(up, termios->c_cflag);\n\n\tbaud = serial8250_get_baud_rate(port, termios, old);\n\tquot = serial8250_get_divisor(port, baud, &frac);\n\n\t \n\tserial8250_rpm_get(up);\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tup->lcr = cval;\t\t\t\t\t \n\n\tif (up->capabilities & UART_CAP_FIFO && port->fifosize > 1) {\n\t\tif (baud < 2400 && !up->dma) {\n\t\t\tup->fcr &= ~UART_FCR_TRIGGER_MASK;\n\t\t\tup->fcr |= UART_FCR_TRIGGER_1;\n\t\t}\n\t}\n\n\t \n\tif (up->capabilities & UART_CAP_AFE) {\n\t\tup->mcr &= ~UART_MCR_AFE;\n\t\tif (termios->c_cflag & CRTSCTS)\n\t\t\tup->mcr |= UART_MCR_AFE;\n\t}\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tport->read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tport->read_status_mask |= UART_LSR_BI;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= UART_LSR_BI;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= UART_LSR_OE;\n\t}\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= UART_LSR_DR;\n\n\t \n\tup->ier &= ~UART_IER_MSI;\n\tif (!(up->bugs & UART_BUG_NOMSR) &&\n\t\t\tUART_ENABLE_MS(&up->port, termios->c_cflag))\n\t\tup->ier |= UART_IER_MSI;\n\tif (up->capabilities & UART_CAP_UUE)\n\t\tup->ier |= UART_IER_UUE;\n\tif (up->capabilities & UART_CAP_RTOIE)\n\t\tup->ier |= UART_IER_RTOIE;\n\n\tserial_port_out(port, UART_IER, up->ier);\n\n\tif (up->capabilities & UART_CAP_EFR) {\n\t\tunsigned char efr = 0;\n\t\t \n\t\tif (termios->c_cflag & CRTSCTS)\n\t\t\tefr |= UART_EFR_CTS;\n\n\t\tserial_port_out(port, UART_LCR, UART_LCR_CONF_MODE_B);\n\t\tif (port->flags & UPF_EXAR_EFR)\n\t\t\tserial_port_out(port, UART_XR_EFR, efr);\n\t\telse\n\t\t\tserial_port_out(port, UART_EFR, efr);\n\t}\n\n\tserial8250_set_divisor(port, baud, quot, frac);\n\n\t \n\tif (port->type == PORT_16750)\n\t\tserial_port_out(port, UART_FCR, up->fcr);\n\n\tserial_port_out(port, UART_LCR, up->lcr);\t \n\tif (port->type != PORT_16750) {\n\t\t \n\t\tif (up->fcr & UART_FCR_ENABLE_FIFO)\n\t\t\tserial_port_out(port, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t\tserial_port_out(port, UART_FCR, up->fcr);\t \n\t}\n\tserial8250_set_mctrl(port, port->mctrl);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tserial8250_rpm_put(up);\n\n\t \n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n}\nEXPORT_SYMBOL(serial8250_do_set_termios);\n\nstatic void\nserial8250_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t       const struct ktermios *old)\n{\n\tif (port->set_termios)\n\t\tport->set_termios(port, termios, old);\n\telse\n\t\tserial8250_do_set_termios(port, termios, old);\n}\n\nvoid serial8250_do_set_ldisc(struct uart_port *port, struct ktermios *termios)\n{\n\tif (termios->c_line == N_PPS) {\n\t\tport->flags |= UPF_HARDPPS_CD;\n\t\tspin_lock_irq(&port->lock);\n\t\tserial8250_enable_ms(port);\n\t\tspin_unlock_irq(&port->lock);\n\t} else {\n\t\tport->flags &= ~UPF_HARDPPS_CD;\n\t\tif (!UART_ENABLE_MS(port, termios->c_cflag)) {\n\t\t\tspin_lock_irq(&port->lock);\n\t\t\tserial8250_disable_ms(port);\n\t\t\tspin_unlock_irq(&port->lock);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(serial8250_do_set_ldisc);\n\nstatic void\nserial8250_set_ldisc(struct uart_port *port, struct ktermios *termios)\n{\n\tif (port->set_ldisc)\n\t\tport->set_ldisc(port, termios);\n\telse\n\t\tserial8250_do_set_ldisc(port, termios);\n}\n\nvoid serial8250_do_pm(struct uart_port *port, unsigned int state,\n\t\t      unsigned int oldstate)\n{\n\tstruct uart_8250_port *p = up_to_u8250p(port);\n\n\tserial8250_set_sleep(p, state != 0);\n}\nEXPORT_SYMBOL(serial8250_do_pm);\n\nstatic void\nserial8250_pm(struct uart_port *port, unsigned int state,\n\t      unsigned int oldstate)\n{\n\tif (port->pm)\n\t\tport->pm(port, state, oldstate);\n\telse\n\t\tserial8250_do_pm(port, state, oldstate);\n}\n\nstatic unsigned int serial8250_port_size(struct uart_8250_port *pt)\n{\n\tif (pt->port.mapsize)\n\t\treturn pt->port.mapsize;\n\tif (is_omap1_8250(pt))\n\t\treturn 0x16 << pt->port.regshift;\n\n\treturn 8 << pt->port.regshift;\n}\n\n \nstatic int serial8250_request_std_resource(struct uart_8250_port *up)\n{\n\tunsigned int size = serial8250_port_size(up);\n\tstruct uart_port *port = &up->port;\n\tint ret = 0;\n\n\tswitch (port->iotype) {\n\tcase UPIO_AU:\n\tcase UPIO_TSI:\n\tcase UPIO_MEM32:\n\tcase UPIO_MEM32BE:\n\tcase UPIO_MEM16:\n\tcase UPIO_MEM:\n\t\tif (!port->mapbase) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!request_mem_region(port->mapbase, size, \"serial\")) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (port->flags & UPF_IOREMAP) {\n\t\t\tport->membase = ioremap(port->mapbase, size);\n\t\t\tif (!port->membase) {\n\t\t\t\trelease_mem_region(port->mapbase, size);\n\t\t\t\tret = -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase UPIO_HUB6:\n\tcase UPIO_PORT:\n\t\tif (!request_region(port->iobase, size, \"serial\"))\n\t\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void serial8250_release_std_resource(struct uart_8250_port *up)\n{\n\tunsigned int size = serial8250_port_size(up);\n\tstruct uart_port *port = &up->port;\n\n\tswitch (port->iotype) {\n\tcase UPIO_AU:\n\tcase UPIO_TSI:\n\tcase UPIO_MEM32:\n\tcase UPIO_MEM32BE:\n\tcase UPIO_MEM16:\n\tcase UPIO_MEM:\n\t\tif (!port->mapbase)\n\t\t\tbreak;\n\n\t\tif (port->flags & UPF_IOREMAP) {\n\t\t\tiounmap(port->membase);\n\t\t\tport->membase = NULL;\n\t\t}\n\n\t\trelease_mem_region(port->mapbase, size);\n\t\tbreak;\n\n\tcase UPIO_HUB6:\n\tcase UPIO_PORT:\n\t\trelease_region(port->iobase, size);\n\t\tbreak;\n\t}\n}\n\nstatic void serial8250_release_port(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\tserial8250_release_std_resource(up);\n}\n\nstatic int serial8250_request_port(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\treturn serial8250_request_std_resource(up);\n}\n\nstatic int fcr_get_rxtrig_bytes(struct uart_8250_port *up)\n{\n\tconst struct serial8250_config *conf_type = &uart_config[up->port.type];\n\tunsigned char bytes;\n\n\tbytes = conf_type->rxtrig_bytes[UART_FCR_R_TRIG_BITS(up->fcr)];\n\n\treturn bytes ? bytes : -EOPNOTSUPP;\n}\n\nstatic int bytes_to_fcr_rxtrig(struct uart_8250_port *up, unsigned char bytes)\n{\n\tconst struct serial8250_config *conf_type = &uart_config[up->port.type];\n\tint i;\n\n\tif (!conf_type->rxtrig_bytes[UART_FCR_R_TRIG_BITS(UART_FCR_R_TRIG_00)])\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 1; i < UART_FCR_R_TRIG_MAX_STATE; i++) {\n\t\tif (bytes < conf_type->rxtrig_bytes[i])\n\t\t\t \n\t\t\treturn (--i) << UART_FCR_R_TRIG_SHIFT;\n\t}\n\n\treturn UART_FCR_R_TRIG_11;\n}\n\nstatic int do_get_rxtrig(struct tty_port *port)\n{\n\tstruct uart_state *state = container_of(port, struct uart_state, port);\n\tstruct uart_port *uport = state->uart_port;\n\tstruct uart_8250_port *up = up_to_u8250p(uport);\n\n\tif (!(up->capabilities & UART_CAP_FIFO) || uport->fifosize <= 1)\n\t\treturn -EINVAL;\n\n\treturn fcr_get_rxtrig_bytes(up);\n}\n\nstatic int do_serial8250_get_rxtrig(struct tty_port *port)\n{\n\tint rxtrig_bytes;\n\n\tmutex_lock(&port->mutex);\n\trxtrig_bytes = do_get_rxtrig(port);\n\tmutex_unlock(&port->mutex);\n\n\treturn rxtrig_bytes;\n}\n\nstatic ssize_t rx_trig_bytes_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\tint rxtrig_bytes;\n\n\trxtrig_bytes = do_serial8250_get_rxtrig(port);\n\tif (rxtrig_bytes < 0)\n\t\treturn rxtrig_bytes;\n\n\treturn sysfs_emit(buf, \"%d\\n\", rxtrig_bytes);\n}\n\nstatic int do_set_rxtrig(struct tty_port *port, unsigned char bytes)\n{\n\tstruct uart_state *state = container_of(port, struct uart_state, port);\n\tstruct uart_port *uport = state->uart_port;\n\tstruct uart_8250_port *up = up_to_u8250p(uport);\n\tint rxtrig;\n\n\tif (!(up->capabilities & UART_CAP_FIFO) || uport->fifosize <= 1)\n\t\treturn -EINVAL;\n\n\trxtrig = bytes_to_fcr_rxtrig(up, bytes);\n\tif (rxtrig < 0)\n\t\treturn rxtrig;\n\n\tserial8250_clear_fifos(up);\n\tup->fcr &= ~UART_FCR_TRIGGER_MASK;\n\tup->fcr |= (unsigned char)rxtrig;\n\tserial_out(up, UART_FCR, up->fcr);\n\treturn 0;\n}\n\nstatic int do_serial8250_set_rxtrig(struct tty_port *port, unsigned char bytes)\n{\n\tint ret;\n\n\tmutex_lock(&port->mutex);\n\tret = do_set_rxtrig(port, bytes);\n\tmutex_unlock(&port->mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t rx_trig_bytes_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\tunsigned char bytes;\n\tint ret;\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tret = kstrtou8(buf, 10, &bytes);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = do_serial8250_set_rxtrig(port, bytes);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(rx_trig_bytes);\n\nstatic struct attribute *serial8250_dev_attrs[] = {\n\t&dev_attr_rx_trig_bytes.attr,\n\tNULL\n};\n\nstatic struct attribute_group serial8250_dev_attr_group = {\n\t.attrs = serial8250_dev_attrs,\n};\n\nstatic void register_dev_spec_attr_grp(struct uart_8250_port *up)\n{\n\tconst struct serial8250_config *conf_type = &uart_config[up->port.type];\n\n\tif (conf_type->rxtrig_bytes[0])\n\t\tup->port.attr_group = &serial8250_dev_attr_group;\n}\n\nstatic void serial8250_config_port(struct uart_port *port, int flags)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tint ret;\n\n\t \n\tret = serial8250_request_std_resource(up);\n\tif (ret < 0)\n\t\treturn;\n\n\tif (port->iotype != up->cur_iotype)\n\t\tset_io_from_upio(port);\n\n\tif (flags & UART_CONFIG_TYPE)\n\t\tautoconfig(up);\n\n\t \n\tif (port->type == PORT_TEGRA)\n\t\tup->bugs |= UART_BUG_NOMSR;\n\n\tif (port->type != PORT_UNKNOWN && flags & UART_CONFIG_IRQ)\n\t\tautoconfig_irq(up);\n\n\tif (port->type == PORT_UNKNOWN)\n\t\tserial8250_release_std_resource(up);\n\n\tregister_dev_spec_attr_grp(up);\n\tup->fcr = uart_config[up->port.type].fcr;\n}\n\nstatic int\nserial8250_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tif (ser->irq >= nr_irqs || ser->irq < 0 ||\n\t    ser->baud_base < 9600 || ser->type < PORT_UNKNOWN ||\n\t    ser->type >= ARRAY_SIZE(uart_config) || ser->type == PORT_CIRRUS ||\n\t    ser->type == PORT_STARTECH)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic const char *serial8250_type(struct uart_port *port)\n{\n\tint type = port->type;\n\n\tif (type >= ARRAY_SIZE(uart_config))\n\t\ttype = 0;\n\treturn uart_config[type].name;\n}\n\nstatic const struct uart_ops serial8250_pops = {\n\t.tx_empty\t= serial8250_tx_empty,\n\t.set_mctrl\t= serial8250_set_mctrl,\n\t.get_mctrl\t= serial8250_get_mctrl,\n\t.stop_tx\t= serial8250_stop_tx,\n\t.start_tx\t= serial8250_start_tx,\n\t.throttle\t= serial8250_throttle,\n\t.unthrottle\t= serial8250_unthrottle,\n\t.stop_rx\t= serial8250_stop_rx,\n\t.enable_ms\t= serial8250_enable_ms,\n\t.break_ctl\t= serial8250_break_ctl,\n\t.startup\t= serial8250_startup,\n\t.shutdown\t= serial8250_shutdown,\n\t.set_termios\t= serial8250_set_termios,\n\t.set_ldisc\t= serial8250_set_ldisc,\n\t.pm\t\t= serial8250_pm,\n\t.type\t\t= serial8250_type,\n\t.release_port\t= serial8250_release_port,\n\t.request_port\t= serial8250_request_port,\n\t.config_port\t= serial8250_config_port,\n\t.verify_port\t= serial8250_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char = serial8250_get_poll_char,\n\t.poll_put_char = serial8250_put_poll_char,\n#endif\n};\n\nvoid serial8250_init_port(struct uart_8250_port *up)\n{\n\tstruct uart_port *port = &up->port;\n\n\tspin_lock_init(&port->lock);\n\tport->ctrl_id = 0;\n\tport->pm = NULL;\n\tport->ops = &serial8250_pops;\n\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);\n\n\tup->cur_iotype = 0xFF;\n}\nEXPORT_SYMBOL_GPL(serial8250_init_port);\n\nvoid serial8250_set_defaults(struct uart_8250_port *up)\n{\n\tstruct uart_port *port = &up->port;\n\n\tif (up->port.flags & UPF_FIXED_TYPE) {\n\t\tunsigned int type = up->port.type;\n\n\t\tif (!up->port.fifosize)\n\t\t\tup->port.fifosize = uart_config[type].fifo_size;\n\t\tif (!up->tx_loadsz)\n\t\t\tup->tx_loadsz = uart_config[type].tx_loadsz;\n\t\tif (!up->capabilities)\n\t\t\tup->capabilities = uart_config[type].flags;\n\t}\n\n\tset_io_from_upio(port);\n\n\t \n\tif (up->dma) {\n\t\tif (!up->dma->tx_dma)\n\t\t\tup->dma->tx_dma = serial8250_tx_dma;\n\t\tif (!up->dma->rx_dma)\n\t\t\tup->dma->rx_dma = serial8250_rx_dma;\n\t}\n}\nEXPORT_SYMBOL_GPL(serial8250_set_defaults);\n\n#ifdef CONFIG_SERIAL_8250_CONSOLE\n\nstatic void serial8250_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\twait_for_xmitr(up, UART_LSR_THRE);\n\tserial_port_out(port, UART_TX, ch);\n}\n\n \nstatic void serial8250_console_restore(struct uart_8250_port *up)\n{\n\tstruct uart_port *port = &up->port;\n\tstruct ktermios termios;\n\tunsigned int baud, quot, frac = 0;\n\n\ttermios.c_cflag = port->cons->cflag;\n\ttermios.c_ispeed = port->cons->ispeed;\n\ttermios.c_ospeed = port->cons->ospeed;\n\tif (port->state->port.tty && termios.c_cflag == 0) {\n\t\ttermios.c_cflag = port->state->port.tty->termios.c_cflag;\n\t\ttermios.c_ispeed = port->state->port.tty->termios.c_ispeed;\n\t\ttermios.c_ospeed = port->state->port.tty->termios.c_ospeed;\n\t}\n\n\tbaud = serial8250_get_baud_rate(port, &termios, NULL);\n\tquot = serial8250_get_divisor(port, baud, &frac);\n\n\tserial8250_set_divisor(port, baud, quot, frac);\n\tserial_port_out(port, UART_LCR, up->lcr);\n\tserial8250_out_MCR(up, up->mcr | UART_MCR_DTR | UART_MCR_RTS);\n}\n\n \nstatic void serial8250_console_fifo_write(struct uart_8250_port *up,\n\t\t\t\t\t  const char *s, unsigned int count)\n{\n\tint i;\n\tconst char *end = s + count;\n\tunsigned int fifosize = up->tx_loadsz;\n\tbool cr_sent = false;\n\n\twhile (s != end) {\n\t\twait_for_lsr(up, UART_LSR_THRE);\n\n\t\tfor (i = 0; i < fifosize && s != end; ++i) {\n\t\t\tif (*s == '\\n' && !cr_sent) {\n\t\t\t\tserial_out(up, UART_TX, '\\r');\n\t\t\t\tcr_sent = true;\n\t\t\t} else {\n\t\t\t\tserial_out(up, UART_TX, *s++);\n\t\t\t\tcr_sent = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid serial8250_console_write(struct uart_8250_port *up, const char *s,\n\t\t\t      unsigned int count)\n{\n\tstruct uart_8250_em485 *em485 = up->em485;\n\tstruct uart_port *port = &up->port;\n\tunsigned long flags;\n\tunsigned int ier, use_fifo;\n\tint locked = 1;\n\n\ttouch_nmi_watchdog();\n\n\tif (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&port->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tier = serial_port_in(port, UART_IER);\n\tserial8250_clear_IER(up);\n\n\t \n\tif (up->canary && (up->canary != serial_port_in(port, UART_SCR))) {\n\t\tserial8250_console_restore(up);\n\t\tup->canary = 0;\n\t}\n\n\tif (em485) {\n\t\tif (em485->tx_stopped)\n\t\t\tup->rs485_start_tx(up);\n\t\tmdelay(port->rs485.delay_rts_before_send);\n\t}\n\n\tuse_fifo = (up->capabilities & UART_CAP_FIFO) &&\n\t\t \n\t\t!(up->capabilities & UART_CAP_MINI) &&\n\t\t \n\t\tup->tx_loadsz > 1 &&\n\t\t(up->fcr & UART_FCR_ENABLE_FIFO) &&\n\t\tport->state &&\n\t\ttest_bit(TTY_PORT_INITIALIZED, &port->state->port.iflags) &&\n\t\t \n\t\t!(up->port.flags & UPF_CONS_FLOW);\n\n\tif (likely(use_fifo))\n\t\tserial8250_console_fifo_write(up, s, count);\n\telse\n\t\tuart_console_write(port, s, count, serial8250_console_putchar);\n\n\t \n\twait_for_xmitr(up, UART_LSR_BOTH_EMPTY);\n\n\tif (em485) {\n\t\tmdelay(port->rs485.delay_rts_after_send);\n\t\tif (em485->tx_stopped)\n\t\t\tup->rs485_stop_tx(up);\n\t}\n\n\tserial_port_out(port, UART_IER, ier);\n\n\t \n\tif (up->msr_saved_flags)\n\t\tserial8250_modem_status(up);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic unsigned int probe_baud(struct uart_port *port)\n{\n\tunsigned char lcr, dll, dlm;\n\tunsigned int quot;\n\n\tlcr = serial_port_in(port, UART_LCR);\n\tserial_port_out(port, UART_LCR, lcr | UART_LCR_DLAB);\n\tdll = serial_port_in(port, UART_DLL);\n\tdlm = serial_port_in(port, UART_DLM);\n\tserial_port_out(port, UART_LCR, lcr);\n\n\tquot = (dlm << 8) | dll;\n\treturn (port->uartclk / 16) / quot;\n}\n\nint serial8250_console_setup(struct uart_port *port, char *options, bool probe)\n{\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret;\n\n\tif (!port->iobase && !port->membase)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse if (probe)\n\t\tbaud = probe_baud(port);\n\n\tret = uart_set_options(port, port->cons, baud, parity, bits, flow);\n\tif (ret)\n\t\treturn ret;\n\n\tif (port->dev)\n\t\tpm_runtime_get_sync(port->dev);\n\n\treturn 0;\n}\n\nint serial8250_console_exit(struct uart_port *port)\n{\n\tif (port->dev)\n\t\tpm_runtime_put_sync(port->dev);\n\n\treturn 0;\n}\n\n#endif  \n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}