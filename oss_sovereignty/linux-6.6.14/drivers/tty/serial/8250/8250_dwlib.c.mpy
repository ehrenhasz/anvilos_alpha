{
  "module_name": "8250_dwlib.c",
  "hash_id": "c72cae4880ef7497bd12a2b6bd281ee8cf51326bc2563aa0eb0535431f0ba880",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_dwlib.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/math.h>\n#include <linux/property.h>\n#include <linux/serial_8250.h>\n#include <linux/serial_core.h>\n\n#include \"8250_dwlib.h\"\n\n \n#define DW_UART_TCR\t0xac  \n#define DW_UART_DE_EN\t0xb0  \n#define DW_UART_RE_EN\t0xb4  \n#define DW_UART_DLF\t0xc0  \n#define DW_UART_RAR\t0xc4  \n#define DW_UART_TAR\t0xc8  \n#define DW_UART_LCR_EXT\t0xcc  \n#define DW_UART_CPR\t0xf4  \n#define DW_UART_UCV\t0xf8  \n\n \n#define DW_UART_ADDR_MASK\t\tGENMASK(7, 0)\n\n \n#define DW_UART_LSR_ADDR_RCVD\t\tBIT(8)\n\n \n#define DW_UART_TCR_RS485_EN\t\tBIT(0)\n#define DW_UART_TCR_RE_POL\t\tBIT(1)\n#define DW_UART_TCR_DE_POL\t\tBIT(2)\n#define DW_UART_TCR_XFER_MODE\t\tGENMASK(4, 3)\n#define DW_UART_TCR_XFER_MODE_DE_DURING_RE\tFIELD_PREP(DW_UART_TCR_XFER_MODE, 0)\n#define DW_UART_TCR_XFER_MODE_SW_DE_OR_RE\tFIELD_PREP(DW_UART_TCR_XFER_MODE, 1)\n#define DW_UART_TCR_XFER_MODE_DE_OR_RE\t\tFIELD_PREP(DW_UART_TCR_XFER_MODE, 2)\n\n \n#define DW_UART_LCR_EXT_DLS_E\t\tBIT(0)\n#define DW_UART_LCR_EXT_ADDR_MATCH\tBIT(1)\n#define DW_UART_LCR_EXT_SEND_ADDR\tBIT(2)\n#define DW_UART_LCR_EXT_TRANSMIT_MODE\tBIT(3)\n\n \n#define DW_UART_CPR_ABP_DATA_WIDTH\tGENMASK(1, 0)\n#define DW_UART_CPR_AFCE_MODE\t\tBIT(4)\n#define DW_UART_CPR_THRE_MODE\t\tBIT(5)\n#define DW_UART_CPR_SIR_MODE\t\tBIT(6)\n#define DW_UART_CPR_SIR_LP_MODE\t\tBIT(7)\n#define DW_UART_CPR_ADDITIONAL_FEATURES\tBIT(8)\n#define DW_UART_CPR_FIFO_ACCESS\t\tBIT(9)\n#define DW_UART_CPR_FIFO_STAT\t\tBIT(10)\n#define DW_UART_CPR_SHADOW\t\tBIT(11)\n#define DW_UART_CPR_ENCODED_PARMS\tBIT(12)\n#define DW_UART_CPR_DMA_EXTRA\t\tBIT(13)\n#define DW_UART_CPR_FIFO_MODE\t\tGENMASK(23, 16)\n\n \n#define DW_UART_CPR_FIFO_SIZE(a)\t(FIELD_GET(DW_UART_CPR_FIFO_MODE, (a)) * 16)\n\n \nstatic unsigned int dw8250_get_divisor(struct uart_port *p, unsigned int baud,\n\t\t\t\t       unsigned int *frac)\n{\n\tunsigned int quot, rem, base_baud = baud * 16;\n\tstruct dw8250_port_data *d = p->private_data;\n\n\tquot = p->uartclk / base_baud;\n\trem = p->uartclk % base_baud;\n\t*frac = DIV_ROUND_CLOSEST(rem << d->dlf_size, base_baud);\n\n\treturn quot;\n}\n\nstatic void dw8250_set_divisor(struct uart_port *p, unsigned int baud,\n\t\t\t       unsigned int quot, unsigned int quot_frac)\n{\n\tdw8250_writel_ext(p, DW_UART_DLF, quot_frac);\n\tserial8250_do_set_divisor(p, baud, quot, quot_frac);\n}\n\nvoid dw8250_do_set_termios(struct uart_port *p, struct ktermios *termios,\n\t\t\t   const struct ktermios *old)\n{\n\tp->status &= ~UPSTAT_AUTOCTS;\n\tif (termios->c_cflag & CRTSCTS)\n\t\tp->status |= UPSTAT_AUTOCTS;\n\n\tserial8250_do_set_termios(p, termios, old);\n\n\t \n\tp->ignore_status_mask |= DW_UART_LSR_ADDR_RCVD;\n\tp->read_status_mask |= DW_UART_LSR_ADDR_RCVD;\n}\nEXPORT_SYMBOL_GPL(dw8250_do_set_termios);\n\n \nstatic void dw8250_wait_re_deassert(struct uart_port *p)\n{\n\tndelay(p->frame_time);\n}\n\nstatic void dw8250_update_rar(struct uart_port *p, u32 addr)\n{\n\tu32 re_en = dw8250_readl_ext(p, DW_UART_RE_EN);\n\n\t \n\tif (re_en)\n\t\tdw8250_writel_ext(p, DW_UART_RE_EN, 0);\n\tdw8250_wait_re_deassert(p);\n\tdw8250_writel_ext(p, DW_UART_RAR, addr);\n\tif (re_en)\n\t\tdw8250_writel_ext(p, DW_UART_RE_EN, re_en);\n}\n\nstatic void dw8250_rs485_set_addr(struct uart_port *p, struct serial_rs485 *rs485,\n\t\t\t\t  struct ktermios *termios)\n{\n\tu32 lcr = dw8250_readl_ext(p, DW_UART_LCR_EXT);\n\n\tif (rs485->flags & SER_RS485_ADDRB) {\n\t\tlcr |= DW_UART_LCR_EXT_DLS_E;\n\t\tif (termios)\n\t\t\ttermios->c_cflag |= ADDRB;\n\n\t\tif (rs485->flags & SER_RS485_ADDR_RECV) {\n\t\t\tu32 delta = p->rs485.flags ^ rs485->flags;\n\n\t\t\t \n\t\t\tif (unlikely(&p->rs485 == rs485))\n\t\t\t\tdelta = rs485->flags;\n\n\t\t\tif ((delta & SER_RS485_ADDR_RECV) ||\n\t\t\t    (p->rs485.addr_recv != rs485->addr_recv))\n\t\t\t\tdw8250_update_rar(p, rs485->addr_recv);\n\t\t\tlcr |= DW_UART_LCR_EXT_ADDR_MATCH;\n\t\t} else {\n\t\t\tlcr &= ~DW_UART_LCR_EXT_ADDR_MATCH;\n\t\t}\n\t\tif (rs485->flags & SER_RS485_ADDR_DEST) {\n\t\t\t \n\t\t\tdw8250_writel_ext(p, DW_UART_TAR, rs485->addr_dest);\n\t\t\tlcr |= DW_UART_LCR_EXT_SEND_ADDR;\n\t\t}\n\t} else {\n\t\tlcr = 0;\n\t}\n\tdw8250_writel_ext(p, DW_UART_LCR_EXT, lcr);\n}\n\nstatic int dw8250_rs485_config(struct uart_port *p, struct ktermios *termios,\n\t\t\t       struct serial_rs485 *rs485)\n{\n\tu32 tcr;\n\n\ttcr = dw8250_readl_ext(p, DW_UART_TCR);\n\ttcr &= ~DW_UART_TCR_XFER_MODE;\n\n\tif (rs485->flags & SER_RS485_ENABLED) {\n\t\ttcr |= DW_UART_TCR_RS485_EN;\n\n\t\tif (rs485->flags & SER_RS485_RX_DURING_TX)\n\t\t\ttcr |= DW_UART_TCR_XFER_MODE_DE_DURING_RE;\n\t\telse\n\t\t\ttcr |= DW_UART_TCR_XFER_MODE_DE_OR_RE;\n\t\tdw8250_writel_ext(p, DW_UART_DE_EN, 1);\n\t\tdw8250_writel_ext(p, DW_UART_RE_EN, 1);\n\t} else {\n\t\tif (termios)\n\t\t\ttermios->c_cflag &= ~ADDRB;\n\n\t\ttcr &= ~DW_UART_TCR_RS485_EN;\n\t}\n\n\t \n\ttcr |= DW_UART_TCR_DE_POL;\n\ttcr &= ~DW_UART_TCR_RE_POL;\n\n\tif (!(rs485->flags & SER_RS485_RTS_ON_SEND))\n\t\ttcr &= ~DW_UART_TCR_DE_POL;\n\tif (device_property_read_bool(p->dev, \"rs485-rx-active-high\"))\n\t\ttcr |= DW_UART_TCR_RE_POL;\n\n\tdw8250_writel_ext(p, DW_UART_TCR, tcr);\n\n\t \n\tif (rs485->flags & SER_RS485_ENABLED)\n\t\tdw8250_rs485_set_addr(p, rs485, termios);\n\n\treturn 0;\n}\n\n \nstatic bool dw8250_detect_rs485_hw(struct uart_port *p)\n{\n\tu32 reg;\n\n\tdw8250_writel_ext(p, DW_UART_RE_EN, 1);\n\treg = dw8250_readl_ext(p, DW_UART_RE_EN);\n\tdw8250_writel_ext(p, DW_UART_RE_EN, 0);\n\treturn reg;\n}\n\nstatic const struct serial_rs485 dw8250_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RX_DURING_TX | SER_RS485_RTS_ON_SEND |\n\t\t SER_RS485_RTS_AFTER_SEND | SER_RS485_ADDRB | SER_RS485_ADDR_RECV |\n\t\t SER_RS485_ADDR_DEST,\n};\n\nvoid dw8250_setup_port(struct uart_port *p)\n{\n\tstruct dw8250_port_data *pd = p->private_data;\n\tstruct dw8250_data *data = to_dw8250_data(pd);\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\tu32 reg, old_dlf;\n\n\tpd->hw_rs485_support = dw8250_detect_rs485_hw(p);\n\tif (pd->hw_rs485_support) {\n\t\tp->rs485_config = dw8250_rs485_config;\n\t\tup->lsr_save_mask = LSR_SAVE_FLAGS | DW_UART_LSR_ADDR_RCVD;\n\t\tp->rs485_supported = dw8250_rs485_supported;\n\t} else {\n\t\tp->rs485_config = serial8250_em485_config;\n\t\tp->rs485_supported = serial8250_em485_supported;\n\t\tup->rs485_start_tx = serial8250_em485_start_tx;\n\t\tup->rs485_stop_tx = serial8250_em485_stop_tx;\n\t}\n\tup->capabilities |= UART_CAP_NOTEMT;\n\n\t \n\treg = dw8250_readl_ext(p, DW_UART_UCV);\n\tif (!reg)\n\t\treturn;\n\n\tdev_dbg(p->dev, \"Designware UART version %c.%c%c\\n\",\n\t\t(reg >> 24) & 0xff, (reg >> 16) & 0xff, (reg >> 8) & 0xff);\n\n\t \n\told_dlf = dw8250_readl_ext(p, DW_UART_DLF);\n\tdw8250_writel_ext(p, DW_UART_DLF, ~0U);\n\treg = dw8250_readl_ext(p, DW_UART_DLF);\n\tdw8250_writel_ext(p, DW_UART_DLF, old_dlf);\n\n\tif (reg) {\n\t\tpd->dlf_size = fls(reg);\n\t\tp->get_divisor = dw8250_get_divisor;\n\t\tp->set_divisor = dw8250_set_divisor;\n\t}\n\n\treg = dw8250_readl_ext(p, DW_UART_CPR);\n\tif (!reg) {\n\t\treg = data->pdata->cpr_val;\n\t\tdev_dbg(p->dev, \"CPR is not available, using 0x%08x instead\\n\", reg);\n\t}\n\tif (!reg)\n\t\treturn;\n\n\t \n\tif (reg & DW_UART_CPR_FIFO_MODE) {\n\t\tp->type = PORT_16550A;\n\t\tp->flags |= UPF_FIXED_TYPE;\n\t\tp->fifosize = DW_UART_CPR_FIFO_SIZE(reg);\n\t\tup->capabilities = UART_CAP_FIFO | UART_CAP_NOTEMT;\n\t}\n\n\tif (reg & DW_UART_CPR_AFCE_MODE)\n\t\tup->capabilities |= UART_CAP_AFE;\n\n\tif (reg & DW_UART_CPR_SIR_MODE)\n\t\tup->capabilities |= UART_CAP_IRDA;\n}\nEXPORT_SYMBOL_GPL(dw8250_setup_port);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}