{
  "module_name": "8250_early.c",
  "hash_id": "8a7623abb5fcdb29045ffeadc647a56524396e9b7dcc7b96beeb8eac60fcd13e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_early.c",
  "human_readable_source": "\n \n\n#include <linux/tty.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/of.h>\n#include <linux/serial_reg.h>\n#include <linux/serial.h>\n#include <linux/serial_8250.h>\n#include <asm/io.h>\n#include <asm/serial.h>\n\nstatic unsigned int serial8250_early_in(struct uart_port *port, int offset)\n{\n\toffset <<= port->regshift;\n\n\tswitch (port->iotype) {\n\tcase UPIO_MEM:\n\t\treturn readb(port->membase + offset);\n\tcase UPIO_MEM16:\n\t\treturn readw(port->membase + offset);\n\tcase UPIO_MEM32:\n\t\treturn readl(port->membase + offset);\n\tcase UPIO_MEM32BE:\n\t\treturn ioread32be(port->membase + offset);\n\tcase UPIO_PORT:\n\t\treturn inb(port->iobase + offset);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void serial8250_early_out(struct uart_port *port, int offset, int value)\n{\n\toffset <<= port->regshift;\n\n\tswitch (port->iotype) {\n\tcase UPIO_MEM:\n\t\twriteb(value, port->membase + offset);\n\t\tbreak;\n\tcase UPIO_MEM16:\n\t\twritew(value, port->membase + offset);\n\t\tbreak;\n\tcase UPIO_MEM32:\n\t\twritel(value, port->membase + offset);\n\t\tbreak;\n\tcase UPIO_MEM32BE:\n\t\tiowrite32be(value, port->membase + offset);\n\t\tbreak;\n\tcase UPIO_PORT:\n\t\toutb(value, port->iobase + offset);\n\t\tbreak;\n\t}\n}\n\nstatic void serial_putc(struct uart_port *port, unsigned char c)\n{\n\tunsigned int status;\n\n\tserial8250_early_out(port, UART_TX, c);\n\n\tfor (;;) {\n\t\tstatus = serial8250_early_in(port, UART_LSR);\n\t\tif (uart_lsr_tx_empty(status))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n}\n\nstatic void early_serial8250_write(struct console *console,\n\t\t\t\t\tconst char *s, unsigned int count)\n{\n\tstruct earlycon_device *device = console->data;\n\tstruct uart_port *port = &device->port;\n\n\tuart_console_write(port, s, count, serial_putc);\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int early_serial8250_read(struct console *console,\n\t\t\t\t char *s, unsigned int count)\n{\n\tstruct earlycon_device *device = console->data;\n\tstruct uart_port *port = &device->port;\n\tunsigned int status;\n\tint num_read = 0;\n\n\twhile (num_read < count) {\n\t\tstatus = serial8250_early_in(port, UART_LSR);\n\t\tif (!(status & UART_LSR_DR))\n\t\t\tbreak;\n\t\ts[num_read++] = serial8250_early_in(port, UART_RX);\n\t}\n\n\treturn num_read;\n}\n#else\n#define early_serial8250_read NULL\n#endif\n\nstatic void __init init_port(struct earlycon_device *device)\n{\n\tstruct uart_port *port = &device->port;\n\tunsigned int divisor;\n\tunsigned char c;\n\tunsigned int ier;\n\n\tserial8250_early_out(port, UART_LCR, UART_LCR_WLEN8);\t\t \n\tier = serial8250_early_in(port, UART_IER);\n\tserial8250_early_out(port, UART_IER, ier & UART_IER_UUE);  \n\tserial8250_early_out(port, UART_FCR, 0);\t \n\tserial8250_early_out(port, UART_MCR, UART_MCR_DTR | UART_MCR_RTS);\n\n\tif (port->uartclk) {\n\t\tdivisor = DIV_ROUND_CLOSEST(port->uartclk, 16 * device->baud);\n\t\tc = serial8250_early_in(port, UART_LCR);\n\t\tserial8250_early_out(port, UART_LCR, c | UART_LCR_DLAB);\n\t\tserial8250_early_out(port, UART_DLL, divisor & 0xff);\n\t\tserial8250_early_out(port, UART_DLM, (divisor >> 8) & 0xff);\n\t\tserial8250_early_out(port, UART_LCR, c & ~UART_LCR_DLAB);\n\t}\n}\n\nint __init early_serial8250_setup(struct earlycon_device *device,\n\t\t\t\t\t const char *options)\n{\n\tif (!(device->port.membase || device->port.iobase))\n\t\treturn -ENODEV;\n\n\tif (!device->baud) {\n\t\tstruct uart_port *port = &device->port;\n\t\tunsigned int ier;\n\n\t\t \n\t\tier = serial8250_early_in(port, UART_IER);\n\t\tserial8250_early_out(port, UART_IER, ier & UART_IER_UUE);\n\t} else\n\t\tinit_port(device);\n\n\tdevice->con->write = early_serial8250_write;\n\tdevice->con->read = early_serial8250_read;\n\treturn 0;\n}\nEARLYCON_DECLARE(uart8250, early_serial8250_setup);\nEARLYCON_DECLARE(uart, early_serial8250_setup);\nOF_EARLYCON_DECLARE(ns16550, \"ns16550\", early_serial8250_setup);\nOF_EARLYCON_DECLARE(ns16550a, \"ns16550a\", early_serial8250_setup);\nOF_EARLYCON_DECLARE(uart, \"nvidia,tegra20-uart\", early_serial8250_setup);\nOF_EARLYCON_DECLARE(uart, \"snps,dw-apb-uart\", early_serial8250_setup);\n\n#ifdef CONFIG_SERIAL_8250_OMAP\n\nstatic int __init early_omap8250_setup(struct earlycon_device *device,\n\t\t\t\t       const char *options)\n{\n\tstruct uart_port *port = &device->port;\n\n\tif (!(device->port.membase || device->port.iobase))\n\t\treturn -ENODEV;\n\n\tport->regshift = 2;\n\tdevice->con->write = early_serial8250_write;\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(omap8250, \"ti,omap2-uart\", early_omap8250_setup);\nOF_EARLYCON_DECLARE(omap8250, \"ti,omap3-uart\", early_omap8250_setup);\nOF_EARLYCON_DECLARE(omap8250, \"ti,omap4-uart\", early_omap8250_setup);\nOF_EARLYCON_DECLARE(omap8250, \"ti,am654-uart\", early_omap8250_setup);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}