{
  "module_name": "8250_exar.c",
  "hash_id": "606050ff3c286bd9f89fdf9ef5d91e567f11e6f2afa991792296806ce65faeca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_exar.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/property.h>\n#include <linux/serial_core.h>\n#include <linux/serial_reg.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/tty.h>\n#include <linux/8250_pci.h>\n#include <linux/delay.h>\n\n#include <asm/byteorder.h>\n\n#include \"8250.h\"\n\n#define PCI_DEVICE_ID_ACCESSIO_COM_2S\t\t0x1052\n#define PCI_DEVICE_ID_ACCESSIO_COM_4S\t\t0x105d\n#define PCI_DEVICE_ID_ACCESSIO_COM_8S\t\t0x106c\n#define PCI_DEVICE_ID_ACCESSIO_COM232_8\t\t0x10a8\n#define PCI_DEVICE_ID_ACCESSIO_COM_2SM\t\t0x10d2\n#define PCI_DEVICE_ID_ACCESSIO_COM_4SM\t\t0x10db\n#define PCI_DEVICE_ID_ACCESSIO_COM_8SM\t\t0x10ea\n\n#define PCI_DEVICE_ID_COMMTECH_4224PCI335\t0x0002\n#define PCI_DEVICE_ID_COMMTECH_4222PCI335\t0x0004\n#define PCI_DEVICE_ID_COMMTECH_2324PCI335\t0x000a\n#define PCI_DEVICE_ID_COMMTECH_2328PCI335\t0x000b\n#define PCI_DEVICE_ID_COMMTECH_4224PCIE\t\t0x0020\n#define PCI_DEVICE_ID_COMMTECH_4228PCIE\t\t0x0021\n#define PCI_DEVICE_ID_COMMTECH_4222PCIE\t\t0x0022\n\n#define PCI_DEVICE_ID_EXAR_XR17V4358\t\t0x4358\n#define PCI_DEVICE_ID_EXAR_XR17V8358\t\t0x8358\n\n#define PCI_SUBDEVICE_ID_USR_2980\t\t0x0128\n#define PCI_SUBDEVICE_ID_USR_2981\t\t0x0129\n\n#define PCI_DEVICE_ID_SEALEVEL_710xC\t\t0x1001\n#define PCI_DEVICE_ID_SEALEVEL_720xC\t\t0x1002\n#define PCI_DEVICE_ID_SEALEVEL_740xC\t\t0x1004\n#define PCI_DEVICE_ID_SEALEVEL_780xC\t\t0x1008\n#define PCI_DEVICE_ID_SEALEVEL_716xC\t\t0x1010\n\n#define UART_EXAR_INT0\t\t0x80\n#define UART_EXAR_8XMODE\t0x88\t \n#define UART_EXAR_SLEEP\t\t0x8b\t \n#define UART_EXAR_DVID\t\t0x8d\t \n\n#define UART_EXAR_FCTR\t\t0x08\t \n#define UART_FCTR_EXAR_IRDA\t0x10\t \n#define UART_FCTR_EXAR_485\t0x20\t \n#define UART_FCTR_EXAR_TRGA\t0x00\t \n#define UART_FCTR_EXAR_TRGB\t0x60\t \n#define UART_FCTR_EXAR_TRGC\t0x80\t \n#define UART_FCTR_EXAR_TRGD\t0xc0\t \n\n#define UART_EXAR_TXTRG\t\t0x0a\t \n#define UART_EXAR_RXTRG\t\t0x0b\t \n\n#define UART_EXAR_MPIOINT_7_0\t0x8f\t \n#define UART_EXAR_MPIOLVL_7_0\t0x90\t \n#define UART_EXAR_MPIO3T_7_0\t0x91\t \n#define UART_EXAR_MPIOINV_7_0\t0x92\t \n#define UART_EXAR_MPIOSEL_7_0\t0x93\t \n#define UART_EXAR_MPIOOD_7_0\t0x94\t \n#define UART_EXAR_MPIOINT_15_8\t0x95\t \n#define UART_EXAR_MPIOLVL_15_8\t0x96\t \n#define UART_EXAR_MPIO3T_15_8\t0x97\t \n#define UART_EXAR_MPIOINV_15_8\t0x98\t \n#define UART_EXAR_MPIOSEL_15_8\t0x99\t \n#define UART_EXAR_MPIOOD_15_8\t0x9a\t \n\n#define UART_EXAR_RS485_DLY(x)\t((x) << 4)\n\n \n\n \n#define IOT2040_UART_MODE_RS232\t\t0x01\n#define IOT2040_UART_MODE_RS485\t\t0x02\n#define IOT2040_UART_MODE_RS422\t\t0x03\n#define IOT2040_UART_TERMINATE_BUS\t0x04\n\n#define IOT2040_UART1_MASK\t\t0x0f\n#define IOT2040_UART2_SHIFT\t\t4\n\n#define IOT2040_UARTS_DEFAULT_MODE\t0x11\t \n#define IOT2040_UARTS_GPIO_LO_MODE\t0x88\t \n\n \n#define IOT2040_UARTS_ENABLE\t\t0x03\n#define IOT2040_UARTS_GPIO_HI_MODE\t0xF8\t \n\nstruct exar8250;\n\nstruct exar8250_platform {\n\tint (*rs485_config)(struct uart_port *port, struct ktermios *termios,\n\t\t\t    struct serial_rs485 *rs485);\n\tconst struct serial_rs485 *rs485_supported;\n\tint (*register_gpio)(struct pci_dev *, struct uart_8250_port *);\n\tvoid (*unregister_gpio)(struct uart_8250_port *);\n};\n\n \nstruct exar8250_board {\n\tunsigned int num_ports;\n\tunsigned int reg_shift;\n\tint\t(*setup)(struct exar8250 *, struct pci_dev *,\n\t\t\t struct uart_8250_port *, int);\n\tvoid\t(*exit)(struct pci_dev *pcidev);\n};\n\nstruct exar8250 {\n\tunsigned int\t\tnr;\n\tstruct exar8250_board\t*board;\n\tvoid __iomem\t\t*virt;\n\tint\t\t\tline[];\n};\n\nstatic void exar_pm(struct uart_port *port, unsigned int state, unsigned int old)\n{\n\t \n\tserial_port_out(port, UART_EXAR_SLEEP, state ? 0xff : 0);\n}\n\n \nstatic unsigned int xr17v35x_get_divisor(struct uart_port *p, unsigned int baud,\n\t\t\t\t\t unsigned int *frac)\n{\n\tunsigned int quot_16;\n\n\tquot_16 = DIV_ROUND_CLOSEST(p->uartclk, baud);\n\t*frac = quot_16 & 0x0f;\n\n\treturn quot_16 >> 4;\n}\n\nstatic void xr17v35x_set_divisor(struct uart_port *p, unsigned int baud,\n\t\t\t\t unsigned int quot, unsigned int quot_frac)\n{\n\tserial8250_do_set_divisor(p, baud, quot, quot_frac);\n\n\t \n\tquot_frac |= serial_port_in(p, 0x2) & 0xf0;\n\tserial_port_out(p, 0x2, quot_frac);\n}\n\nstatic int xr17v35x_startup(struct uart_port *port)\n{\n\t \n\tserial_port_out(port, UART_XR_EFR, UART_EFR_ECB);\n\n\t \n\tspin_lock_irq(&port->lock);\n\tserial_port_out(port, UART_IER, 0);\n\tspin_unlock_irq(&port->lock);\n\n\treturn serial8250_do_startup(port);\n}\n\nstatic void exar_shutdown(struct uart_port *port)\n{\n\tbool tx_complete = false;\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tint i = 0;\n\tu16 lsr;\n\n\tdo {\n\t\tlsr = serial_in(up, UART_LSR);\n\t\tif (lsr & (UART_LSR_TEMT | UART_LSR_THRE))\n\t\t\ttx_complete = true;\n\t\telse\n\t\t\ttx_complete = false;\n\t\tusleep_range(1000, 1100);\n\t} while (!uart_circ_empty(xmit) && !tx_complete && i++ < 1000);\n\n\tserial8250_do_shutdown(port);\n}\n\nstatic int default_setup(struct exar8250 *priv, struct pci_dev *pcidev,\n\t\t\t int idx, unsigned int offset,\n\t\t\t struct uart_8250_port *port)\n{\n\tconst struct exar8250_board *board = priv->board;\n\tunsigned int bar = 0;\n\tunsigned char status;\n\n\tport->port.iotype = UPIO_MEM;\n\tport->port.mapbase = pci_resource_start(pcidev, bar) + offset;\n\tport->port.membase = priv->virt + offset;\n\tport->port.regshift = board->reg_shift;\n\n\t \n\tstatus = readb(port->port.membase + UART_EXAR_DVID);\n\tif (status == 0x82 || status == 0x84 || status == 0x88) {\n\t\tport->port.type = PORT_XR17V35X;\n\n\t\tport->port.get_divisor = xr17v35x_get_divisor;\n\t\tport->port.set_divisor = xr17v35x_set_divisor;\n\n\t\tport->port.startup = xr17v35x_startup;\n\t} else {\n\t\tport->port.type = PORT_XR17D15X;\n\t}\n\n\tport->port.pm = exar_pm;\n\tport->port.shutdown = exar_shutdown;\n\n\treturn 0;\n}\n\nstatic int\npci_fastcom335_setup(struct exar8250 *priv, struct pci_dev *pcidev,\n\t\t     struct uart_8250_port *port, int idx)\n{\n\tunsigned int offset = idx * 0x200;\n\tunsigned int baud = 1843200;\n\tu8 __iomem *p;\n\tint err;\n\n\tport->port.uartclk = baud * 16;\n\n\terr = default_setup(priv, pcidev, idx, offset, port);\n\tif (err)\n\t\treturn err;\n\n\tp = port->port.membase;\n\n\twriteb(0x00, p + UART_EXAR_8XMODE);\n\twriteb(UART_FCTR_EXAR_TRGD, p + UART_EXAR_FCTR);\n\twriteb(32, p + UART_EXAR_TXTRG);\n\twriteb(32, p + UART_EXAR_RXTRG);\n\n\t \n\tif (idx == 0) {\n\t\tswitch (pcidev->device) {\n\t\tcase PCI_DEVICE_ID_COMMTECH_4222PCI335:\n\t\tcase PCI_DEVICE_ID_COMMTECH_4224PCI335:\n\t\t\twriteb(0x78, p + UART_EXAR_MPIOLVL_7_0);\n\t\t\twriteb(0x00, p + UART_EXAR_MPIOINV_7_0);\n\t\t\twriteb(0x00, p + UART_EXAR_MPIOSEL_7_0);\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_COMMTECH_2324PCI335:\n\t\tcase PCI_DEVICE_ID_COMMTECH_2328PCI335:\n\t\t\twriteb(0x00, p + UART_EXAR_MPIOLVL_7_0);\n\t\t\twriteb(0xc0, p + UART_EXAR_MPIOINV_7_0);\n\t\t\twriteb(0xc0, p + UART_EXAR_MPIOSEL_7_0);\n\t\t\tbreak;\n\t\t}\n\t\twriteb(0x00, p + UART_EXAR_MPIOINT_7_0);\n\t\twriteb(0x00, p + UART_EXAR_MPIO3T_7_0);\n\t\twriteb(0x00, p + UART_EXAR_MPIOOD_7_0);\n\t}\n\n\treturn 0;\n}\n\nstatic int\npci_connect_tech_setup(struct exar8250 *priv, struct pci_dev *pcidev,\n\t\t       struct uart_8250_port *port, int idx)\n{\n\tunsigned int offset = idx * 0x200;\n\tunsigned int baud = 1843200;\n\n\tport->port.uartclk = baud * 16;\n\treturn default_setup(priv, pcidev, idx, offset, port);\n}\n\nstatic int\npci_xr17c154_setup(struct exar8250 *priv, struct pci_dev *pcidev,\n\t\t   struct uart_8250_port *port, int idx)\n{\n\tunsigned int offset = idx * 0x200;\n\tunsigned int baud = 921600;\n\n\tport->port.uartclk = baud * 16;\n\treturn default_setup(priv, pcidev, idx, offset, port);\n}\n\nstatic void setup_gpio(struct pci_dev *pcidev, u8 __iomem *p)\n{\n\t \n\n\tu8 dir = 0x00;\n\n\tif  ((pcidev->vendor == PCI_VENDOR_ID_EXAR) &&\n\t\t(pcidev->subsystem_vendor != PCI_VENDOR_ID_SEALEVEL)) {\n\t\t\n\t\tdir = 0xff;\n\t} else {\n\t\t\n\t\tdir = 0x00;\n\t}\n\n\twriteb(0x00, p + UART_EXAR_MPIOINT_7_0);\n\twriteb(0x00, p + UART_EXAR_MPIOLVL_7_0);\n\twriteb(0x00, p + UART_EXAR_MPIO3T_7_0);\n\twriteb(0x00, p + UART_EXAR_MPIOINV_7_0);\n\twriteb(dir,  p + UART_EXAR_MPIOSEL_7_0);\n\twriteb(0x00, p + UART_EXAR_MPIOOD_7_0);\n\twriteb(0x00, p + UART_EXAR_MPIOINT_15_8);\n\twriteb(0x00, p + UART_EXAR_MPIOLVL_15_8);\n\twriteb(0x00, p + UART_EXAR_MPIO3T_15_8);\n\twriteb(0x00, p + UART_EXAR_MPIOINV_15_8);\n\twriteb(dir,  p + UART_EXAR_MPIOSEL_15_8);\n\twriteb(0x00, p + UART_EXAR_MPIOOD_15_8);\n}\n\nstatic struct platform_device *__xr17v35x_register_gpio(struct pci_dev *pcidev,\n\t\t\t\t\t\t\tconst struct software_node *node)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_alloc(\"gpio_exar\", PLATFORM_DEVID_AUTO);\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpdev->dev.parent = &pcidev->dev;\n\tACPI_COMPANION_SET(&pdev->dev, ACPI_COMPANION(&pcidev->dev));\n\n\tif (device_add_software_node(&pdev->dev, node) < 0 ||\n\t    platform_device_add(pdev) < 0) {\n\t\tplatform_device_put(pdev);\n\t\treturn NULL;\n\t}\n\n\treturn pdev;\n}\n\nstatic void __xr17v35x_unregister_gpio(struct platform_device *pdev)\n{\n\tdevice_remove_software_node(&pdev->dev);\n\tplatform_device_unregister(pdev);\n}\n\nstatic const struct property_entry exar_gpio_properties[] = {\n\tPROPERTY_ENTRY_U32(\"exar,first-pin\", 0),\n\tPROPERTY_ENTRY_U32(\"ngpios\", 16),\n\t{ }\n};\n\nstatic const struct software_node exar_gpio_node = {\n\t.properties = exar_gpio_properties,\n};\n\nstatic int xr17v35x_register_gpio(struct pci_dev *pcidev, struct uart_8250_port *port)\n{\n\tif (pcidev->vendor == PCI_VENDOR_ID_EXAR)\n\t\tport->port.private_data =\n\t\t\t__xr17v35x_register_gpio(pcidev, &exar_gpio_node);\n\n\treturn 0;\n}\n\nstatic void xr17v35x_unregister_gpio(struct uart_8250_port *port)\n{\n\tif (!port->port.private_data)\n\t\treturn;\n\n\t__xr17v35x_unregister_gpio(port->port.private_data);\n\tport->port.private_data = NULL;\n}\n\nstatic int generic_rs485_config(struct uart_port *port, struct ktermios *termios,\n\t\t\t\tstruct serial_rs485 *rs485)\n{\n\tbool is_rs485 = !!(rs485->flags & SER_RS485_ENABLED);\n\tu8 __iomem *p = port->membase;\n\tu8 value;\n\n\tvalue = readb(p + UART_EXAR_FCTR);\n\tif (is_rs485)\n\t\tvalue |= UART_FCTR_EXAR_485;\n\telse\n\t\tvalue &= ~UART_FCTR_EXAR_485;\n\n\twriteb(value, p + UART_EXAR_FCTR);\n\n\tif (is_rs485)\n\t\twriteb(UART_EXAR_RS485_DLY(4), p + UART_MSR);\n\n\treturn 0;\n}\n\nstatic const struct serial_rs485 generic_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND,\n};\n\nstatic const struct exar8250_platform exar8250_default_platform = {\n\t.register_gpio = xr17v35x_register_gpio,\n\t.unregister_gpio = xr17v35x_unregister_gpio,\n\t.rs485_config = generic_rs485_config,\n\t.rs485_supported = &generic_rs485_supported,\n};\n\nstatic int iot2040_rs485_config(struct uart_port *port, struct ktermios *termios,\n\t\t\t\tstruct serial_rs485 *rs485)\n{\n\tbool is_rs485 = !!(rs485->flags & SER_RS485_ENABLED);\n\tu8 __iomem *p = port->membase;\n\tu8 mask = IOT2040_UART1_MASK;\n\tu8 mode, value;\n\n\tif (is_rs485) {\n\t\tif (rs485->flags & SER_RS485_RX_DURING_TX)\n\t\t\tmode = IOT2040_UART_MODE_RS422;\n\t\telse\n\t\t\tmode = IOT2040_UART_MODE_RS485;\n\n\t\tif (rs485->flags & SER_RS485_TERMINATE_BUS)\n\t\t\tmode |= IOT2040_UART_TERMINATE_BUS;\n\t} else {\n\t\tmode = IOT2040_UART_MODE_RS232;\n\t}\n\n\tif (port->line == 3) {\n\t\tmask <<= IOT2040_UART2_SHIFT;\n\t\tmode <<= IOT2040_UART2_SHIFT;\n\t}\n\n\tvalue = readb(p + UART_EXAR_MPIOLVL_7_0);\n\tvalue &= ~mask;\n\tvalue |= mode;\n\twriteb(value, p + UART_EXAR_MPIOLVL_7_0);\n\n\treturn generic_rs485_config(port, termios, rs485);\n}\n\nstatic const struct serial_rs485 iot2040_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND |\n\t\t SER_RS485_RX_DURING_TX | SER_RS485_TERMINATE_BUS,\n};\n\nstatic const struct property_entry iot2040_gpio_properties[] = {\n\tPROPERTY_ENTRY_U32(\"exar,first-pin\", 10),\n\tPROPERTY_ENTRY_U32(\"ngpios\", 1),\n\t{ }\n};\n\nstatic const struct software_node iot2040_gpio_node = {\n\t.properties = iot2040_gpio_properties,\n};\n\nstatic int iot2040_register_gpio(struct pci_dev *pcidev,\n\t\t\t      struct uart_8250_port *port)\n{\n\tu8 __iomem *p = port->port.membase;\n\n\twriteb(IOT2040_UARTS_DEFAULT_MODE, p + UART_EXAR_MPIOLVL_7_0);\n\twriteb(IOT2040_UARTS_GPIO_LO_MODE, p + UART_EXAR_MPIOSEL_7_0);\n\twriteb(IOT2040_UARTS_ENABLE, p + UART_EXAR_MPIOLVL_15_8);\n\twriteb(IOT2040_UARTS_GPIO_HI_MODE, p + UART_EXAR_MPIOSEL_15_8);\n\n\tport->port.private_data =\n\t\t__xr17v35x_register_gpio(pcidev, &iot2040_gpio_node);\n\n\treturn 0;\n}\n\nstatic const struct exar8250_platform iot2040_platform = {\n\t.rs485_config = iot2040_rs485_config,\n\t.rs485_supported = &iot2040_rs485_supported,\n\t.register_gpio = iot2040_register_gpio,\n\t.unregister_gpio = xr17v35x_unregister_gpio,\n};\n\n \nstatic const struct dmi_system_id exar_platforms[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"SIMATIC IOT2000\"),\n\t\t},\n\t\t.driver_data = (void *)&iot2040_platform,\n\t},\n\t{}\n};\n\nstatic const struct exar8250_platform *exar_get_platform(void)\n{\n\tconst struct dmi_system_id *dmi_match;\n\n\tdmi_match = dmi_first_match(exar_platforms);\n\tif (dmi_match)\n\t\treturn dmi_match->driver_data;\n\n\treturn &exar8250_default_platform;\n}\n\nstatic int\npci_xr17v35x_setup(struct exar8250 *priv, struct pci_dev *pcidev,\n\t\t   struct uart_8250_port *port, int idx)\n{\n\tconst struct exar8250_platform *platform = exar_get_platform();\n\tunsigned int offset = idx * 0x400;\n\tunsigned int baud = 7812500;\n\tu8 __iomem *p;\n\tint ret;\n\n\tport->port.uartclk = baud * 16;\n\tport->port.rs485_config = platform->rs485_config;\n\tport->port.rs485_supported = *(platform->rs485_supported);\n\n\t \n\tif (idx >= 8)\n\t\tport->port.uartclk /= 2;\n\n\tret = default_setup(priv, pcidev, idx, offset, port);\n\tif (ret)\n\t\treturn ret;\n\n\tp = port->port.membase;\n\n\twriteb(0x00, p + UART_EXAR_8XMODE);\n\twriteb(UART_FCTR_EXAR_TRGD, p + UART_EXAR_FCTR);\n\twriteb(128, p + UART_EXAR_TXTRG);\n\twriteb(128, p + UART_EXAR_RXTRG);\n\n\tif (idx == 0) {\n\t\t \n\t\tsetup_gpio(pcidev, p);\n\n\t\tret = platform->register_gpio(pcidev, port);\n\t}\n\n\treturn ret;\n}\n\nstatic void pci_xr17v35x_exit(struct pci_dev *pcidev)\n{\n\tconst struct exar8250_platform *platform = exar_get_platform();\n\tstruct exar8250 *priv = pci_get_drvdata(pcidev);\n\tstruct uart_8250_port *port = serial8250_get_port(priv->line[0]);\n\n\tplatform->unregister_gpio(port);\n}\n\nstatic inline void exar_misc_clear(struct exar8250 *priv)\n{\n\t \n\treadb(priv->virt + UART_EXAR_INT0);\n\n\t \n\tif (priv->board->num_ports > 8)\n\t\treadb(priv->virt + 0x2000 + UART_EXAR_INT0);\n}\n\n \nstatic irqreturn_t exar_misc_handler(int irq, void *data)\n{\n\texar_misc_clear(data);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nexar_pci_probe(struct pci_dev *pcidev, const struct pci_device_id *ent)\n{\n\tunsigned int nr_ports, i, bar = 0, maxnr;\n\tstruct exar8250_board *board;\n\tstruct uart_8250_port uart;\n\tstruct exar8250 *priv;\n\tint rc;\n\n\tboard = (struct exar8250_board *)ent->driver_data;\n\tif (!board)\n\t\treturn -EINVAL;\n\n\trc = pcim_enable_device(pcidev);\n\tif (rc)\n\t\treturn rc;\n\n\tmaxnr = pci_resource_len(pcidev, bar) >> (board->reg_shift + 3);\n\n\tif (pcidev->vendor == PCI_VENDOR_ID_ACCESSIO)\n\t\tnr_ports = BIT(((pcidev->device & 0x38) >> 3) - 1);\n\telse if (board->num_ports)\n\t\tnr_ports = board->num_ports;\n\telse if (pcidev->vendor == PCI_VENDOR_ID_SEALEVEL)\n\t\tnr_ports = pcidev->device & 0xff;\n\telse\n\t\tnr_ports = pcidev->device & 0x0f;\n\n\tpriv = devm_kzalloc(&pcidev->dev, struct_size(priv, line, nr_ports), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->board = board;\n\tpriv->virt = pcim_iomap(pcidev, bar, 0);\n\tif (!priv->virt)\n\t\treturn -ENOMEM;\n\n\tpci_set_master(pcidev);\n\n\trc = pci_alloc_irq_vectors(pcidev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tmemset(&uart, 0, sizeof(uart));\n\tuart.port.flags = UPF_SHARE_IRQ | UPF_EXAR_EFR | UPF_FIXED_TYPE | UPF_FIXED_PORT;\n\tuart.port.irq = pci_irq_vector(pcidev, 0);\n\tuart.port.dev = &pcidev->dev;\n\n\trc = devm_request_irq(&pcidev->dev, uart.port.irq, exar_misc_handler,\n\t\t\t IRQF_SHARED, \"exar_uart\", priv);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\texar_misc_clear(priv);\n\n\tfor (i = 0; i < nr_ports && i < maxnr; i++) {\n\t\trc = board->setup(priv, pcidev, &uart, i);\n\t\tif (rc) {\n\t\t\tdev_err(&pcidev->dev, \"Failed to setup port %u\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(&pcidev->dev, \"Setup PCI port: port %lx, irq %d, type %d\\n\",\n\t\t\tuart.port.iobase, uart.port.irq, uart.port.iotype);\n\n\t\tpriv->line[i] = serial8250_register_8250_port(&uart);\n\t\tif (priv->line[i] < 0) {\n\t\t\tdev_err(&pcidev->dev,\n\t\t\t\t\"Couldn't register serial port %lx, irq %d, type %d, error %d\\n\",\n\t\t\t\tuart.port.iobase, uart.port.irq,\n\t\t\t\tuart.port.iotype, priv->line[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpriv->nr = i;\n\tpci_set_drvdata(pcidev, priv);\n\treturn 0;\n}\n\nstatic void exar_pci_remove(struct pci_dev *pcidev)\n{\n\tstruct exar8250 *priv = pci_get_drvdata(pcidev);\n\tunsigned int i;\n\n\tfor (i = 0; i < priv->nr; i++)\n\t\tserial8250_unregister_port(priv->line[i]);\n\n\tif (priv->board->exit)\n\t\tpriv->board->exit(pcidev);\n}\n\nstatic int __maybe_unused exar_suspend(struct device *dev)\n{\n\tstruct pci_dev *pcidev = to_pci_dev(dev);\n\tstruct exar8250 *priv = pci_get_drvdata(pcidev);\n\tunsigned int i;\n\n\tfor (i = 0; i < priv->nr; i++)\n\t\tif (priv->line[i] >= 0)\n\t\t\tserial8250_suspend_port(priv->line[i]);\n\n\t \n\tif (priv->board->exit)\n\t\tpriv->board->exit(pcidev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused exar_resume(struct device *dev)\n{\n\tstruct exar8250 *priv = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\texar_misc_clear(priv);\n\n\tfor (i = 0; i < priv->nr; i++)\n\t\tif (priv->line[i] >= 0)\n\t\t\tserial8250_resume_port(priv->line[i]);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(exar_pci_pm, exar_suspend, exar_resume);\n\nstatic const struct exar8250_board pbn_fastcom335_2 = {\n\t.num_ports\t= 2,\n\t.setup\t\t= pci_fastcom335_setup,\n};\n\nstatic const struct exar8250_board pbn_fastcom335_4 = {\n\t.num_ports\t= 4,\n\t.setup\t\t= pci_fastcom335_setup,\n};\n\nstatic const struct exar8250_board pbn_fastcom335_8 = {\n\t.num_ports\t= 8,\n\t.setup\t\t= pci_fastcom335_setup,\n};\n\nstatic const struct exar8250_board pbn_connect = {\n\t.setup\t\t= pci_connect_tech_setup,\n};\n\nstatic const struct exar8250_board pbn_exar_ibm_saturn = {\n\t.num_ports\t= 1,\n\t.setup\t\t= pci_xr17c154_setup,\n};\n\nstatic const struct exar8250_board pbn_exar_XR17C15x = {\n\t.setup\t\t= pci_xr17c154_setup,\n};\n\nstatic const struct exar8250_board pbn_exar_XR17V35x = {\n\t.setup\t\t= pci_xr17v35x_setup,\n\t.exit\t\t= pci_xr17v35x_exit,\n};\n\nstatic const struct exar8250_board pbn_fastcom35x_2 = {\n\t.num_ports\t= 2,\n\t.setup\t\t= pci_xr17v35x_setup,\n\t.exit\t\t= pci_xr17v35x_exit,\n};\n\nstatic const struct exar8250_board pbn_fastcom35x_4 = {\n\t.num_ports\t= 4,\n\t.setup\t\t= pci_xr17v35x_setup,\n\t.exit\t\t= pci_xr17v35x_exit,\n};\n\nstatic const struct exar8250_board pbn_fastcom35x_8 = {\n\t.num_ports\t= 8,\n\t.setup\t\t= pci_xr17v35x_setup,\n\t.exit\t\t= pci_xr17v35x_exit,\n};\n\nstatic const struct exar8250_board pbn_exar_XR17V4358 = {\n\t.num_ports\t= 12,\n\t.setup\t\t= pci_xr17v35x_setup,\n\t.exit\t\t= pci_xr17v35x_exit,\n};\n\nstatic const struct exar8250_board pbn_exar_XR17V8358 = {\n\t.num_ports\t= 16,\n\t.setup\t\t= pci_xr17v35x_setup,\n\t.exit\t\t= pci_xr17v35x_exit,\n};\n\n#define CONNECT_DEVICE(devid, sdevid, bd) {\t\t\t\t\\\n\tPCI_DEVICE_SUB(\t\t\t\t\t\t\t\\\n\t\tPCI_VENDOR_ID_EXAR,\t\t\t\t\t\\\n\t\tPCI_DEVICE_ID_EXAR_##devid,\t\t\t\t\\\n\t\tPCI_SUBVENDOR_ID_CONNECT_TECH,\t\t\t\t\\\n\t\tPCI_SUBDEVICE_ID_CONNECT_TECH_PCI_##sdevid), 0, 0,\t\\\n\t\t(kernel_ulong_t)&bd\t\t\t\t\t\\\n\t}\n\n#define EXAR_DEVICE(vend, devid, bd) { PCI_DEVICE_DATA(vend, devid, &bd) }\n\n#define IBM_DEVICE(devid, sdevid, bd) {\t\t\t\\\n\tPCI_DEVICE_SUB(\t\t\t\t\t\\\n\t\tPCI_VENDOR_ID_EXAR,\t\t\t\\\n\t\tPCI_DEVICE_ID_EXAR_##devid,\t\t\\\n\t\tPCI_VENDOR_ID_IBM,\t\t\t\\\n\t\tPCI_SUBDEVICE_ID_IBM_##sdevid), 0, 0,\t\\\n\t\t(kernel_ulong_t)&bd\t\t\t\\\n\t}\n\n#define USR_DEVICE(devid, sdevid, bd) {\t\t\t\\\n\tPCI_DEVICE_SUB(\t\t\t\t\t\\\n\t\tPCI_VENDOR_ID_USR,\t\t\t\\\n\t\tPCI_DEVICE_ID_EXAR_##devid,\t\t\\\n\t\tPCI_VENDOR_ID_EXAR,\t\t\t\\\n\t\tPCI_SUBDEVICE_ID_USR_##sdevid), 0, 0,\t\\\n\t\t(kernel_ulong_t)&bd\t\t\t\\\n\t}\n\nstatic const struct pci_device_id exar_pci_tbl[] = {\n\tEXAR_DEVICE(ACCESSIO, COM_2S, pbn_exar_XR17C15x),\n\tEXAR_DEVICE(ACCESSIO, COM_4S, pbn_exar_XR17C15x),\n\tEXAR_DEVICE(ACCESSIO, COM_8S, pbn_exar_XR17C15x),\n\tEXAR_DEVICE(ACCESSIO, COM232_8, pbn_exar_XR17C15x),\n\tEXAR_DEVICE(ACCESSIO, COM_2SM, pbn_exar_XR17C15x),\n\tEXAR_DEVICE(ACCESSIO, COM_4SM, pbn_exar_XR17C15x),\n\tEXAR_DEVICE(ACCESSIO, COM_8SM, pbn_exar_XR17C15x),\n\n\tCONNECT_DEVICE(XR17C152, UART_2_232, pbn_connect),\n\tCONNECT_DEVICE(XR17C154, UART_4_232, pbn_connect),\n\tCONNECT_DEVICE(XR17C158, UART_8_232, pbn_connect),\n\tCONNECT_DEVICE(XR17C152, UART_1_1, pbn_connect),\n\tCONNECT_DEVICE(XR17C154, UART_2_2, pbn_connect),\n\tCONNECT_DEVICE(XR17C158, UART_4_4, pbn_connect),\n\tCONNECT_DEVICE(XR17C152, UART_2, pbn_connect),\n\tCONNECT_DEVICE(XR17C154, UART_4, pbn_connect),\n\tCONNECT_DEVICE(XR17C158, UART_8, pbn_connect),\n\tCONNECT_DEVICE(XR17C152, UART_2_485, pbn_connect),\n\tCONNECT_DEVICE(XR17C154, UART_4_485, pbn_connect),\n\tCONNECT_DEVICE(XR17C158, UART_8_485, pbn_connect),\n\n\tIBM_DEVICE(XR17C152, SATURN_SERIAL_ONE_PORT, pbn_exar_ibm_saturn),\n\n\t \n\tUSR_DEVICE(XR17C152, 2980, pbn_exar_XR17C15x),\n\tUSR_DEVICE(XR17C152, 2981, pbn_exar_XR17C15x),\n\n\t \n\tEXAR_DEVICE(EXAR, XR17C152, pbn_exar_XR17C15x),\n\tEXAR_DEVICE(EXAR, XR17C154, pbn_exar_XR17C15x),\n\tEXAR_DEVICE(EXAR, XR17C158, pbn_exar_XR17C15x),\n\n\t \n\tEXAR_DEVICE(EXAR, XR17V352, pbn_exar_XR17V35x),\n\tEXAR_DEVICE(EXAR, XR17V354, pbn_exar_XR17V35x),\n\tEXAR_DEVICE(EXAR, XR17V358, pbn_exar_XR17V35x),\n\tEXAR_DEVICE(EXAR, XR17V4358, pbn_exar_XR17V4358),\n\tEXAR_DEVICE(EXAR, XR17V8358, pbn_exar_XR17V8358),\n\tEXAR_DEVICE(COMMTECH, 4222PCIE, pbn_fastcom35x_2),\n\tEXAR_DEVICE(COMMTECH, 4224PCIE, pbn_fastcom35x_4),\n\tEXAR_DEVICE(COMMTECH, 4228PCIE, pbn_fastcom35x_8),\n\n\tEXAR_DEVICE(COMMTECH, 4222PCI335, pbn_fastcom335_2),\n\tEXAR_DEVICE(COMMTECH, 4224PCI335, pbn_fastcom335_4),\n\tEXAR_DEVICE(COMMTECH, 2324PCI335, pbn_fastcom335_4),\n\tEXAR_DEVICE(COMMTECH, 2328PCI335, pbn_fastcom335_8),\n\n\tEXAR_DEVICE(SEALEVEL, 710xC, pbn_exar_XR17V35x),\n\tEXAR_DEVICE(SEALEVEL, 720xC, pbn_exar_XR17V35x),\n\tEXAR_DEVICE(SEALEVEL, 740xC, pbn_exar_XR17V35x),\n\tEXAR_DEVICE(SEALEVEL, 780xC, pbn_exar_XR17V35x),\n\tEXAR_DEVICE(SEALEVEL, 716xC, pbn_exar_XR17V35x),\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, exar_pci_tbl);\n\nstatic struct pci_driver exar_pci_driver = {\n\t.name\t\t= \"exar_serial\",\n\t.probe\t\t= exar_pci_probe,\n\t.remove\t\t= exar_pci_remove,\n\t.driver         = {\n\t\t.pm     = &exar_pci_pm,\n\t},\n\t.id_table\t= exar_pci_tbl,\n};\nmodule_pci_driver(exar_pci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Exar Serial Driver\");\nMODULE_AUTHOR(\"Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}