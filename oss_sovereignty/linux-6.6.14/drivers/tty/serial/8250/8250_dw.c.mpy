{
  "module_name": "8250_dw.c",
  "hash_id": "8d45eebb8ab00111076a2f335b1597fb4096eadc81f8ebaeda02b7060fae6f41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_dw.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include <asm/byteorder.h>\n\n#include <linux/serial_8250.h>\n#include <linux/serial_reg.h>\n\n#include \"8250_dwlib.h\"\n\n \n#define DW_UART_USR\t0x1f  \n#define DW_UART_DMASA\t0xa8  \n\n#define OCTEON_UART_USR\t0x27  \n\n#define RZN1_UART_TDMACR 0x10c  \n#define RZN1_UART_RDMACR 0x110  \n\n \n#define DW_UART_MCR_SIRE\t\tBIT(6)\n\n \n#define RZN1_UART_xDMACR_DMA_EN\t\tBIT(0)\n#define RZN1_UART_xDMACR_1_WORD_BURST\t(0 << 1)\n#define RZN1_UART_xDMACR_4_WORD_BURST\t(1 << 1)\n#define RZN1_UART_xDMACR_8_WORD_BURST\t(2 << 1)\n#define RZN1_UART_xDMACR_BLK_SZ(x)\t((x) << 3)\n\n \n#define DW_UART_QUIRK_OCTEON\t\tBIT(0)\n#define DW_UART_QUIRK_ARMADA_38X\tBIT(1)\n#define DW_UART_QUIRK_SKIP_SET_RATE\tBIT(2)\n#define DW_UART_QUIRK_IS_DMA_FC\t\tBIT(3)\n\nstatic inline struct dw8250_data *clk_to_dw8250_data(struct notifier_block *nb)\n{\n\treturn container_of(nb, struct dw8250_data, clk_notifier);\n}\n\nstatic inline struct dw8250_data *work_to_dw8250_data(struct work_struct *work)\n{\n\treturn container_of(work, struct dw8250_data, clk_work);\n}\n\nstatic inline int dw8250_modify_msr(struct uart_port *p, int offset, int value)\n{\n\tstruct dw8250_data *d = to_dw8250_data(p->private_data);\n\n\t \n\tif (offset == UART_MSR) {\n\t\tvalue |= d->msr_mask_on;\n\t\tvalue &= ~d->msr_mask_off;\n\t}\n\n\treturn value;\n}\n\nstatic void dw8250_force_idle(struct uart_port *p)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\tunsigned int lsr;\n\n\tserial8250_clear_and_reinit_fifos(up);\n\n\t \n\tif (up->fcr & UART_FCR_ENABLE_FIFO) {\n\t\tlsr = p->serial_in(p, UART_LSR);\n\t\tif (!(lsr & UART_LSR_DR))\n\t\t\treturn;\n\t}\n\n\t(void)p->serial_in(p, UART_RX);\n}\n\nstatic void dw8250_check_lcr(struct uart_port *p, int value)\n{\n\tvoid __iomem *offset = p->membase + (UART_LCR << p->regshift);\n\tint tries = 1000;\n\n\t \n\twhile (tries--) {\n\t\tunsigned int lcr = p->serial_in(p, UART_LCR);\n\n\t\tif ((value & ~UART_LCR_SPAR) == (lcr & ~UART_LCR_SPAR))\n\t\t\treturn;\n\n\t\tdw8250_force_idle(p);\n\n#ifdef CONFIG_64BIT\n\t\tif (p->type == PORT_OCTEON)\n\t\t\t__raw_writeq(value & 0xff, offset);\n\t\telse\n#endif\n\t\tif (p->iotype == UPIO_MEM32)\n\t\t\twritel(value, offset);\n\t\telse if (p->iotype == UPIO_MEM32BE)\n\t\t\tiowrite32be(value, offset);\n\t\telse\n\t\t\twriteb(value, offset);\n\t}\n\t \n}\n\n \nstatic void dw8250_tx_wait_empty(struct uart_port *p)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\tunsigned int tries = 20000;\n\tunsigned int delay_threshold = tries - 1000;\n\tunsigned int lsr;\n\n\twhile (tries--) {\n\t\tlsr = readb (p->membase + (UART_LSR << p->regshift));\n\t\tup->lsr_saved_flags |= lsr & up->lsr_save_mask;\n\n\t\tif (lsr & UART_LSR_TEMT)\n\t\t\tbreak;\n\n\t\t \n\t\tif (tries < delay_threshold)\n\t\t\tudelay (1);\n\t}\n}\n\nstatic void dw8250_serial_out(struct uart_port *p, int offset, int value)\n{\n\tstruct dw8250_data *d = to_dw8250_data(p->private_data);\n\n\twriteb(value, p->membase + (offset << p->regshift));\n\n\tif (offset == UART_LCR && !d->uart_16550_compatible)\n\t\tdw8250_check_lcr(p, value);\n}\n\nstatic void dw8250_serial_out38x(struct uart_port *p, int offset, int value)\n{\n\t \n\tif (offset == UART_LCR)\n\t\tdw8250_tx_wait_empty(p);\n\n\tdw8250_serial_out(p, offset, value);\n}\n\nstatic unsigned int dw8250_serial_in(struct uart_port *p, int offset)\n{\n\tunsigned int value = readb(p->membase + (offset << p->regshift));\n\n\treturn dw8250_modify_msr(p, offset, value);\n}\n\n#ifdef CONFIG_64BIT\nstatic unsigned int dw8250_serial_inq(struct uart_port *p, int offset)\n{\n\tunsigned int value;\n\n\tvalue = (u8)__raw_readq(p->membase + (offset << p->regshift));\n\n\treturn dw8250_modify_msr(p, offset, value);\n}\n\nstatic void dw8250_serial_outq(struct uart_port *p, int offset, int value)\n{\n\tstruct dw8250_data *d = to_dw8250_data(p->private_data);\n\n\tvalue &= 0xff;\n\t__raw_writeq(value, p->membase + (offset << p->regshift));\n\t \n\t__raw_readq(p->membase + (UART_LCR << p->regshift));\n\n\tif (offset == UART_LCR && !d->uart_16550_compatible)\n\t\tdw8250_check_lcr(p, value);\n}\n#endif  \n\nstatic void dw8250_serial_out32(struct uart_port *p, int offset, int value)\n{\n\tstruct dw8250_data *d = to_dw8250_data(p->private_data);\n\n\twritel(value, p->membase + (offset << p->regshift));\n\n\tif (offset == UART_LCR && !d->uart_16550_compatible)\n\t\tdw8250_check_lcr(p, value);\n}\n\nstatic unsigned int dw8250_serial_in32(struct uart_port *p, int offset)\n{\n\tunsigned int value = readl(p->membase + (offset << p->regshift));\n\n\treturn dw8250_modify_msr(p, offset, value);\n}\n\nstatic void dw8250_serial_out32be(struct uart_port *p, int offset, int value)\n{\n\tstruct dw8250_data *d = to_dw8250_data(p->private_data);\n\n\tiowrite32be(value, p->membase + (offset << p->regshift));\n\n\tif (offset == UART_LCR && !d->uart_16550_compatible)\n\t\tdw8250_check_lcr(p, value);\n}\n\nstatic unsigned int dw8250_serial_in32be(struct uart_port *p, int offset)\n{\n       unsigned int value = ioread32be(p->membase + (offset << p->regshift));\n\n       return dw8250_modify_msr(p, offset, value);\n}\n\n\nstatic int dw8250_handle_irq(struct uart_port *p)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\tstruct dw8250_data *d = to_dw8250_data(p->private_data);\n\tunsigned int iir = p->serial_in(p, UART_IIR);\n\tbool rx_timeout = (iir & 0x3f) == UART_IIR_RX_TIMEOUT;\n\tunsigned int quirks = d->pdata->quirks;\n\tunsigned int status;\n\tunsigned long flags;\n\n\t \n\tif (!up->dma && rx_timeout) {\n\t\tspin_lock_irqsave(&p->lock, flags);\n\t\tstatus = serial_lsr_in(up);\n\n\t\tif (!(status & (UART_LSR_DR | UART_LSR_BI)))\n\t\t\t(void) p->serial_in(p, UART_RX);\n\n\t\tspin_unlock_irqrestore(&p->lock, flags);\n\t}\n\n\t \n\tif (quirks & DW_UART_QUIRK_IS_DMA_FC && up->dma && up->dma->rx_running && rx_timeout) {\n\t\tspin_lock_irqsave(&p->lock, flags);\n\t\tstatus = serial_lsr_in(up);\n\t\tspin_unlock_irqrestore(&p->lock, flags);\n\n\t\tif (status & (UART_LSR_DR | UART_LSR_BI)) {\n\t\t\tdw8250_writel_ext(p, RZN1_UART_RDMACR, 0);\n\t\t\tdw8250_writel_ext(p, DW_UART_DMASA, 1);\n\t\t}\n\t}\n\n\tif (serial8250_handle_irq(p, iir))\n\t\treturn 1;\n\n\tif ((iir & UART_IIR_BUSY) == UART_IIR_BUSY) {\n\t\t \n\t\t(void)p->serial_in(p, d->pdata->usr_reg);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void dw8250_clk_work_cb(struct work_struct *work)\n{\n\tstruct dw8250_data *d = work_to_dw8250_data(work);\n\tstruct uart_8250_port *up;\n\tunsigned long rate;\n\n\trate = clk_get_rate(d->clk);\n\tif (rate <= 0)\n\t\treturn;\n\n\tup = serial8250_get_port(d->data.line);\n\n\tserial8250_update_uartclk(&up->port, rate);\n}\n\nstatic int dw8250_clk_notifier_cb(struct notifier_block *nb,\n\t\t\t\t  unsigned long event, void *data)\n{\n\tstruct dw8250_data *d = clk_to_dw8250_data(nb);\n\n\t \n\tif (event == POST_RATE_CHANGE) {\n\t\tqueue_work(system_unbound_wq, &d->clk_work);\n\t\treturn NOTIFY_OK;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void\ndw8250_do_pm(struct uart_port *port, unsigned int state, unsigned int old)\n{\n\tif (!state)\n\t\tpm_runtime_get_sync(port->dev);\n\n\tserial8250_do_pm(port, state, old);\n\n\tif (state)\n\t\tpm_runtime_put_sync_suspend(port->dev);\n}\n\nstatic void dw8250_set_termios(struct uart_port *p, struct ktermios *termios,\n\t\t\t       const struct ktermios *old)\n{\n\tunsigned long newrate = tty_termios_baud_rate(termios) * 16;\n\tstruct dw8250_data *d = to_dw8250_data(p->private_data);\n\tlong rate;\n\tint ret;\n\n\tclk_disable_unprepare(d->clk);\n\trate = clk_round_rate(d->clk, newrate);\n\tif (rate > 0) {\n\t\t \n\t\tret = clk_set_rate(d->clk, newrate);\n\t\tif (!ret)\n\t\t\tp->uartclk = rate;\n\t}\n\tclk_prepare_enable(d->clk);\n\n\tdw8250_do_set_termios(p, termios, old);\n}\n\nstatic void dw8250_set_ldisc(struct uart_port *p, struct ktermios *termios)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\tunsigned int mcr = p->serial_in(p, UART_MCR);\n\n\tif (up->capabilities & UART_CAP_IRDA) {\n\t\tif (termios->c_line == N_IRDA)\n\t\t\tmcr |= DW_UART_MCR_SIRE;\n\t\telse\n\t\t\tmcr &= ~DW_UART_MCR_SIRE;\n\n\t\tp->serial_out(p, UART_MCR, mcr);\n\t}\n\tserial8250_do_set_ldisc(p, termios);\n}\n\n \nstatic bool dw8250_fallback_dma_filter(struct dma_chan *chan, void *param)\n{\n\treturn false;\n}\n\nstatic bool dw8250_idma_filter(struct dma_chan *chan, void *param)\n{\n\treturn param == chan->device->dev;\n}\n\nstatic u32 dw8250_rzn1_get_dmacr_burst(int max_burst)\n{\n\tif (max_burst >= 8)\n\t\treturn RZN1_UART_xDMACR_8_WORD_BURST;\n\telse if (max_burst >= 4)\n\t\treturn RZN1_UART_xDMACR_4_WORD_BURST;\n\telse\n\t\treturn RZN1_UART_xDMACR_1_WORD_BURST;\n}\n\nstatic void dw8250_prepare_tx_dma(struct uart_8250_port *p)\n{\n\tstruct uart_port *up = &p->port;\n\tstruct uart_8250_dma *dma = p->dma;\n\tu32 val;\n\n\tdw8250_writel_ext(up, RZN1_UART_TDMACR, 0);\n\tval = dw8250_rzn1_get_dmacr_burst(dma->txconf.dst_maxburst) |\n\t      RZN1_UART_xDMACR_BLK_SZ(dma->tx_size) |\n\t      RZN1_UART_xDMACR_DMA_EN;\n\tdw8250_writel_ext(up, RZN1_UART_TDMACR, val);\n}\n\nstatic void dw8250_prepare_rx_dma(struct uart_8250_port *p)\n{\n\tstruct uart_port *up = &p->port;\n\tstruct uart_8250_dma *dma = p->dma;\n\tu32 val;\n\n\tdw8250_writel_ext(up, RZN1_UART_RDMACR, 0);\n\tval = dw8250_rzn1_get_dmacr_burst(dma->rxconf.src_maxburst) |\n\t      RZN1_UART_xDMACR_BLK_SZ(dma->rx_size) |\n\t      RZN1_UART_xDMACR_DMA_EN;\n\tdw8250_writel_ext(up, RZN1_UART_RDMACR, val);\n}\n\nstatic void dw8250_quirks(struct uart_port *p, struct dw8250_data *data)\n{\n\tstruct device_node *np = p->dev->of_node;\n\n\tif (np) {\n\t\tunsigned int quirks = data->pdata->quirks;\n\t\tint id;\n\n\t\t \n\t\tid = of_alias_get_id(np, \"serial\");\n\t\tif (id >= 0)\n\t\t\tp->line = id;\n#ifdef CONFIG_64BIT\n\t\tif (quirks & DW_UART_QUIRK_OCTEON) {\n\t\t\tp->serial_in = dw8250_serial_inq;\n\t\t\tp->serial_out = dw8250_serial_outq;\n\t\t\tp->flags = UPF_SKIP_TEST | UPF_SHARE_IRQ | UPF_FIXED_TYPE;\n\t\t\tp->type = PORT_OCTEON;\n\t\t\tdata->skip_autocfg = true;\n\t\t}\n#endif\n\n\t\tif (of_device_is_big_endian(np)) {\n\t\t\tp->iotype = UPIO_MEM32BE;\n\t\t\tp->serial_in = dw8250_serial_in32be;\n\t\t\tp->serial_out = dw8250_serial_out32be;\n\t\t}\n\n\t\tif (quirks & DW_UART_QUIRK_ARMADA_38X)\n\t\t\tp->serial_out = dw8250_serial_out38x;\n\t\tif (quirks & DW_UART_QUIRK_SKIP_SET_RATE)\n\t\t\tp->set_termios = dw8250_do_set_termios;\n\t\tif (quirks & DW_UART_QUIRK_IS_DMA_FC) {\n\t\t\tdata->data.dma.txconf.device_fc = 1;\n\t\t\tdata->data.dma.rxconf.device_fc = 1;\n\t\t\tdata->data.dma.prepare_tx_dma = dw8250_prepare_tx_dma;\n\t\t\tdata->data.dma.prepare_rx_dma = dw8250_prepare_rx_dma;\n\t\t}\n\n\t} else if (acpi_dev_present(\"APMC0D08\", NULL, -1)) {\n\t\tp->iotype = UPIO_MEM32;\n\t\tp->regshift = 2;\n\t\tp->serial_in = dw8250_serial_in32;\n\t\tdata->uart_16550_compatible = true;\n\t}\n\n\t \n\tif (platform_get_resource_byname(to_platform_device(p->dev),\n\t\t\t\t\t IORESOURCE_MEM, \"lpss_priv\")) {\n\t\tdata->data.dma.rx_param = p->dev->parent;\n\t\tdata->data.dma.tx_param = p->dev->parent;\n\t\tdata->data.dma.fn = dw8250_idma_filter;\n\t}\n}\n\nstatic void dw8250_clk_disable_unprepare(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic void dw8250_reset_control_assert(void *data)\n{\n\treset_control_assert(data);\n}\n\nstatic int dw8250_probe(struct platform_device *pdev)\n{\n\tstruct uart_8250_port uart = {}, *up = &uart;\n\tstruct uart_port *p = &up->port;\n\tstruct device *dev = &pdev->dev;\n\tstruct dw8250_data *data;\n\tstruct resource *regs;\n\tint irq;\n\tint err;\n\tu32 val;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs)\n\t\treturn dev_err_probe(dev, -EINVAL, \"no registers defined\\n\");\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\t \n\tif (irq == -ENXIO)\n\t\tirq = 0;\n\tif (irq < 0)\n\t\treturn irq;\n\n\tspin_lock_init(&p->lock);\n\tp->mapbase\t= regs->start;\n\tp->irq\t\t= irq;\n\tp->handle_irq\t= dw8250_handle_irq;\n\tp->pm\t\t= dw8250_do_pm;\n\tp->type\t\t= PORT_8250;\n\tp->flags\t= UPF_SHARE_IRQ | UPF_FIXED_PORT;\n\tp->dev\t\t= dev;\n\tp->iotype\t= UPIO_MEM;\n\tp->serial_in\t= dw8250_serial_in;\n\tp->serial_out\t= dw8250_serial_out;\n\tp->set_ldisc\t= dw8250_set_ldisc;\n\tp->set_termios\t= dw8250_set_termios;\n\n\tp->membase = devm_ioremap(dev, regs->start, resource_size(regs));\n\tif (!p->membase)\n\t\treturn -ENOMEM;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->data.dma.fn = dw8250_fallback_dma_filter;\n\tdata->pdata = device_get_match_data(p->dev);\n\tp->private_data = &data->data;\n\n\tdata->uart_16550_compatible = device_property_read_bool(dev,\n\t\t\t\t\t\t\"snps,uart-16550-compatible\");\n\n\terr = device_property_read_u32(dev, \"reg-shift\", &val);\n\tif (!err)\n\t\tp->regshift = val;\n\n\terr = device_property_read_u32(dev, \"reg-io-width\", &val);\n\tif (!err && val == 4) {\n\t\tp->iotype = UPIO_MEM32;\n\t\tp->serial_in = dw8250_serial_in32;\n\t\tp->serial_out = dw8250_serial_out32;\n\t}\n\n\tif (device_property_read_bool(dev, \"dcd-override\")) {\n\t\t \n\t\tdata->msr_mask_on |= UART_MSR_DCD;\n\t\tdata->msr_mask_off |= UART_MSR_DDCD;\n\t}\n\n\tif (device_property_read_bool(dev, \"dsr-override\")) {\n\t\t \n\t\tdata->msr_mask_on |= UART_MSR_DSR;\n\t\tdata->msr_mask_off |= UART_MSR_DDSR;\n\t}\n\n\tif (device_property_read_bool(dev, \"cts-override\")) {\n\t\t \n\t\tdata->msr_mask_on |= UART_MSR_CTS;\n\t\tdata->msr_mask_off |= UART_MSR_DCTS;\n\t}\n\n\tif (device_property_read_bool(dev, \"ri-override\")) {\n\t\t \n\t\tdata->msr_mask_off |= UART_MSR_RI;\n\t\tdata->msr_mask_off |= UART_MSR_TERI;\n\t}\n\n\t \n\tdevice_property_read_u32(dev, \"clock-frequency\", &p->uartclk);\n\n\t \n\tdata->clk = devm_clk_get_optional(dev, \"baudclk\");\n\tif (data->clk == NULL)\n\t\tdata->clk = devm_clk_get_optional(dev, NULL);\n\tif (IS_ERR(data->clk))\n\t\treturn PTR_ERR(data->clk);\n\n\tINIT_WORK(&data->clk_work, dw8250_clk_work_cb);\n\tdata->clk_notifier.notifier_call = dw8250_clk_notifier_cb;\n\n\terr = clk_prepare_enable(data->clk);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"could not enable optional baudclk\\n\");\n\n\terr = devm_add_action_or_reset(dev, dw8250_clk_disable_unprepare, data->clk);\n\tif (err)\n\t\treturn err;\n\n\tif (data->clk)\n\t\tp->uartclk = clk_get_rate(data->clk);\n\n\t \n\tif (!p->uartclk)\n\t\treturn dev_err_probe(dev, -EINVAL, \"clock rate not defined\\n\");\n\n\tdata->pclk = devm_clk_get_optional(dev, \"apb_pclk\");\n\tif (IS_ERR(data->pclk))\n\t\treturn PTR_ERR(data->pclk);\n\n\terr = clk_prepare_enable(data->pclk);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"could not enable apb_pclk\\n\");\n\n\terr = devm_add_action_or_reset(dev, dw8250_clk_disable_unprepare, data->pclk);\n\tif (err)\n\t\treturn err;\n\n\tdata->rst = devm_reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(data->rst))\n\t\treturn PTR_ERR(data->rst);\n\n\treset_control_deassert(data->rst);\n\n\terr = devm_add_action_or_reset(dev, dw8250_reset_control_assert, data->rst);\n\tif (err)\n\t\treturn err;\n\n\tdw8250_quirks(p, data);\n\n\t \n\tif (data->uart_16550_compatible)\n\t\tp->handle_irq = NULL;\n\n\tif (!data->skip_autocfg)\n\t\tdw8250_setup_port(p);\n\n\t \n\tif (p->fifosize) {\n\t\tdata->data.dma.rxconf.src_maxburst = p->fifosize / 4;\n\t\tdata->data.dma.txconf.dst_maxburst = p->fifosize / 4;\n\t\tup->dma = &data->data.dma;\n\t}\n\n\tdata->data.line = serial8250_register_8250_port(up);\n\tif (data->data.line < 0)\n\t\treturn data->data.line;\n\n\t \n\tif (data->clk) {\n\t\terr = clk_notifier_register(data->clk, &data->clk_notifier);\n\t\tif (err)\n\t\t\treturn dev_err_probe(dev, err, \"Failed to set the clock notifier\\n\");\n\t\tqueue_work(system_unbound_wq, &data->clk_work);\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic int dw8250_remove(struct platform_device *pdev)\n{\n\tstruct dw8250_data *data = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tpm_runtime_get_sync(dev);\n\n\tif (data->clk) {\n\t\tclk_notifier_unregister(data->clk, &data->clk_notifier);\n\n\t\tflush_work(&data->clk_work);\n\t}\n\n\tserial8250_unregister_port(data->data.line);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n\n\treturn 0;\n}\n\nstatic int dw8250_suspend(struct device *dev)\n{\n\tstruct dw8250_data *data = dev_get_drvdata(dev);\n\n\tserial8250_suspend_port(data->data.line);\n\n\treturn 0;\n}\n\nstatic int dw8250_resume(struct device *dev)\n{\n\tstruct dw8250_data *data = dev_get_drvdata(dev);\n\n\tserial8250_resume_port(data->data.line);\n\n\treturn 0;\n}\n\nstatic int dw8250_runtime_suspend(struct device *dev)\n{\n\tstruct dw8250_data *data = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(data->clk);\n\n\tclk_disable_unprepare(data->pclk);\n\n\treturn 0;\n}\n\nstatic int dw8250_runtime_resume(struct device *dev)\n{\n\tstruct dw8250_data *data = dev_get_drvdata(dev);\n\n\tclk_prepare_enable(data->pclk);\n\n\tclk_prepare_enable(data->clk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dw8250_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(dw8250_suspend, dw8250_resume)\n\tRUNTIME_PM_OPS(dw8250_runtime_suspend, dw8250_runtime_resume, NULL)\n};\n\nstatic const struct dw8250_platform_data dw8250_dw_apb = {\n\t.usr_reg = DW_UART_USR,\n};\n\nstatic const struct dw8250_platform_data dw8250_octeon_3860_data = {\n\t.usr_reg = OCTEON_UART_USR,\n\t.quirks = DW_UART_QUIRK_OCTEON,\n};\n\nstatic const struct dw8250_platform_data dw8250_armada_38x_data = {\n\t.usr_reg = DW_UART_USR,\n\t.quirks = DW_UART_QUIRK_ARMADA_38X,\n};\n\nstatic const struct dw8250_platform_data dw8250_renesas_rzn1_data = {\n\t.usr_reg = DW_UART_USR,\n\t.cpr_val = 0x00012f32,\n\t.quirks = DW_UART_QUIRK_IS_DMA_FC,\n};\n\nstatic const struct dw8250_platform_data dw8250_starfive_jh7100_data = {\n\t.usr_reg = DW_UART_USR,\n\t.quirks = DW_UART_QUIRK_SKIP_SET_RATE,\n};\n\nstatic const struct of_device_id dw8250_of_match[] = {\n\t{ .compatible = \"snps,dw-apb-uart\", .data = &dw8250_dw_apb },\n\t{ .compatible = \"cavium,octeon-3860-uart\", .data = &dw8250_octeon_3860_data },\n\t{ .compatible = \"marvell,armada-38x-uart\", .data = &dw8250_armada_38x_data },\n\t{ .compatible = \"renesas,rzn1-uart\", .data = &dw8250_renesas_rzn1_data },\n\t{ .compatible = \"starfive,jh7100-uart\", .data = &dw8250_starfive_jh7100_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dw8250_of_match);\n\nstatic const struct acpi_device_id dw8250_acpi_match[] = {\n\t{ \"80860F0A\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ \"8086228A\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ \"AMD0020\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ \"AMDI0020\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ \"AMDI0022\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ \"APMC0D08\", (kernel_ulong_t)&dw8250_dw_apb},\n\t{ \"BRCM2032\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ \"HISI0031\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ \"INT33C4\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ \"INT33C5\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ \"INT3434\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ \"INT3435\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ \"INTC10EE\", (kernel_ulong_t)&dw8250_dw_apb },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, dw8250_acpi_match);\n\nstatic struct platform_driver dw8250_platform_driver = {\n\t.driver = {\n\t\t.name\t\t= \"dw-apb-uart\",\n\t\t.pm\t\t= pm_ptr(&dw8250_pm_ops),\n\t\t.of_match_table\t= dw8250_of_match,\n\t\t.acpi_match_table = dw8250_acpi_match,\n\t},\n\t.probe\t\t\t= dw8250_probe,\n\t.remove\t\t\t= dw8250_remove,\n};\n\nmodule_platform_driver(dw8250_platform_driver);\n\nMODULE_AUTHOR(\"Jamie Iles\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Synopsys DesignWare 8250 serial port driver\");\nMODULE_ALIAS(\"platform:dw-apb-uart\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}