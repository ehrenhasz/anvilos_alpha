{
  "module_name": "8250_ingenic.c",
  "hash_id": "6abe2bdcb52591bdc879a5cc4780d84b7aa323e22cb69abbbd546d4f2f0c0864",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_ingenic.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/libfdt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_fdt.h>\n#include <linux/platform_device.h>\n#include <linux/serial_8250.h>\n#include <linux/serial_core.h>\n#include <linux/serial_reg.h>\n\n#include \"8250.h\"\n\n \nstruct ingenic_uart_config {\n\tint tx_loadsz;\n\tint fifosize;\n};\n\nstruct ingenic_uart_data {\n\tstruct clk\t*clk_module;\n\tstruct clk\t*clk_baud;\n\tint\t\tline;\n};\n\nstatic const struct of_device_id of_match[];\n\n#define UART_FCR_UME\tBIT(4)\n\n#define UART_MCR_MDCE\tBIT(7)\n#define UART_MCR_FCM\tBIT(6)\n\nstatic struct earlycon_device *early_device;\n\nstatic uint8_t early_in(struct uart_port *port, int offset)\n{\n\treturn readl(port->membase + (offset << 2));\n}\n\nstatic void early_out(struct uart_port *port, int offset, uint8_t value)\n{\n\twritel(value, port->membase + (offset << 2));\n}\n\nstatic void ingenic_early_console_putc(struct uart_port *port, unsigned char c)\n{\n\tu16 lsr;\n\n\tdo {\n\t\tlsr = early_in(port, UART_LSR);\n\t} while ((lsr & UART_LSR_TEMT) == 0);\n\n\tearly_out(port, UART_TX, c);\n}\n\nstatic void ingenic_early_console_write(struct console *console,\n\t\t\t\t\t      const char *s, unsigned int count)\n{\n\tuart_console_write(&early_device->port, s, count,\n\t\t\t   ingenic_early_console_putc);\n}\n\nstatic void __init ingenic_early_console_setup_clock(struct earlycon_device *dev)\n{\n\tvoid *fdt = initial_boot_params;\n\tconst __be32 *prop;\n\tint offset;\n\n\toffset = fdt_path_offset(fdt, \"/ext\");\n\tif (offset < 0)\n\t\treturn;\n\n\tprop = fdt_getprop(fdt, offset, \"clock-frequency\", NULL);\n\tif (!prop)\n\t\treturn;\n\n\tdev->port.uartclk = be32_to_cpup(prop);\n}\n\nstatic int __init ingenic_earlycon_setup_tail(struct earlycon_device *dev,\n\t\t\t\t\t      const char *opt)\n{\n\tstruct uart_port *port = &dev->port;\n\tunsigned int divisor;\n\tint baud = 115200;\n\n\tif (!dev->port.membase)\n\t\treturn -ENODEV;\n\n\tif (opt) {\n\t\tunsigned int parity, bits, flow;  \n\n\t\tuart_parse_options(opt, &baud, &parity, &bits, &flow);\n\t}\n\n\tif (dev->baud)\n\t\tbaud = dev->baud;\n\tdivisor = DIV_ROUND_CLOSEST(port->uartclk, 16 * baud);\n\n\tearly_out(port, UART_IER, 0);\n\tearly_out(port, UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN8);\n\tearly_out(port, UART_DLL, 0);\n\tearly_out(port, UART_DLM, 0);\n\tearly_out(port, UART_LCR, UART_LCR_WLEN8);\n\tearly_out(port, UART_FCR, UART_FCR_UME | UART_FCR_CLEAR_XMIT |\n\t\t\tUART_FCR_CLEAR_RCVR | UART_FCR_ENABLE_FIFO);\n\tearly_out(port, UART_MCR, UART_MCR_RTS | UART_MCR_DTR);\n\n\tearly_out(port, UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN8);\n\tearly_out(port, UART_DLL, divisor & 0xff);\n\tearly_out(port, UART_DLM, (divisor >> 8) & 0xff);\n\tearly_out(port, UART_LCR, UART_LCR_WLEN8);\n\n\tearly_device = dev;\n\tdev->con->write = ingenic_early_console_write;\n\n\treturn 0;\n}\n\nstatic int __init ingenic_early_console_setup(struct earlycon_device *dev,\n\t\t\t\t\t      const char *opt)\n{\n\tingenic_early_console_setup_clock(dev);\n\n\treturn ingenic_earlycon_setup_tail(dev, opt);\n}\n\nstatic int __init jz4750_early_console_setup(struct earlycon_device *dev,\n\t\t\t\t\t     const char *opt)\n{\n\t \n\tingenic_early_console_setup_clock(dev);\n\tif (dev->port.uartclk >= 16000000)\n\t\tdev->port.uartclk /= 2;\n\n\treturn ingenic_earlycon_setup_tail(dev, opt);\n}\n\nOF_EARLYCON_DECLARE(jz4740_uart, \"ingenic,jz4740-uart\",\n\t\t    ingenic_early_console_setup);\n\nOF_EARLYCON_DECLARE(jz4750_uart, \"ingenic,jz4750-uart\",\n\t\t    jz4750_early_console_setup);\n\nOF_EARLYCON_DECLARE(jz4770_uart, \"ingenic,jz4770-uart\",\n\t\t    ingenic_early_console_setup);\n\nOF_EARLYCON_DECLARE(jz4775_uart, \"ingenic,jz4775-uart\",\n\t\t    ingenic_early_console_setup);\n\nOF_EARLYCON_DECLARE(jz4780_uart, \"ingenic,jz4780-uart\",\n\t\t    ingenic_early_console_setup);\n\nOF_EARLYCON_DECLARE(x1000_uart, \"ingenic,x1000-uart\",\n\t\t    ingenic_early_console_setup);\n\nstatic void ingenic_uart_serial_out(struct uart_port *p, int offset, int value)\n{\n\tint ier;\n\n\tswitch (offset) {\n\tcase UART_FCR:\n\t\t \n\t\tvalue |= UART_FCR_UME;\n\t\tbreak;\n\n\tcase UART_IER:\n\t\t \n\t\tvalue |= (value & 0x4) << 2;\n\t\tbreak;\n\n\tcase UART_MCR:\n\t\t \n\t\tier = p->serial_in(p, UART_IER);\n\n\t\tif (ier & UART_IER_MSI)\n\t\t\tvalue |= UART_MCR_MDCE | UART_MCR_FCM;\n\t\telse\n\t\t\tvalue &= ~(UART_MCR_MDCE | UART_MCR_FCM);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\twriteb(value, p->membase + (offset << p->regshift));\n}\n\nstatic unsigned int ingenic_uart_serial_in(struct uart_port *p, int offset)\n{\n\tunsigned int value;\n\n\tvalue = readb(p->membase + (offset << p->regshift));\n\n\t \n\tswitch (offset) {\n\tcase UART_FCR:\n\t\tvalue &= ~UART_FCR_UME;\n\t\tbreak;\n\n\tcase UART_MCR:\n\t\tvalue &= ~(UART_MCR_MDCE | UART_MCR_FCM);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn value;\n}\n\nstatic int ingenic_uart_probe(struct platform_device *pdev)\n{\n\tstruct uart_8250_port uart = {};\n\tstruct ingenic_uart_data *data;\n\tconst struct ingenic_uart_config *cdata;\n\tstruct resource *regs;\n\tint irq, err, line;\n\n\tcdata = of_device_get_match_data(&pdev->dev);\n\tif (!cdata) {\n\t\tdev_err(&pdev->dev, \"Error: No device match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs) {\n\t\tdev_err(&pdev->dev, \"no registers defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&uart.port.lock);\n\tuart.port.type = PORT_16550A;\n\tuart.port.flags = UPF_SKIP_TEST | UPF_IOREMAP | UPF_FIXED_TYPE;\n\tuart.port.iotype = UPIO_MEM;\n\tuart.port.mapbase = regs->start;\n\tuart.port.regshift = 2;\n\tuart.port.serial_out = ingenic_uart_serial_out;\n\tuart.port.serial_in = ingenic_uart_serial_in;\n\tuart.port.irq = irq;\n\tuart.port.dev = &pdev->dev;\n\tuart.port.fifosize = cdata->fifosize;\n\tuart.tx_loadsz = cdata->tx_loadsz;\n\tuart.capabilities = UART_CAP_FIFO | UART_CAP_RTOIE;\n\n\t \n\tline = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\tif (line >= 0)\n\t\tuart.port.line = line;\n\n\tuart.port.membase = devm_ioremap(&pdev->dev, regs->start,\n\t\t\t\t\t resource_size(regs));\n\tif (!uart.port.membase)\n\t\treturn -ENOMEM;\n\n\tdata->clk_module = devm_clk_get(&pdev->dev, \"module\");\n\tif (IS_ERR(data->clk_module))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->clk_module),\n\t\t\t\t     \"unable to get module clock\\n\");\n\n\tdata->clk_baud = devm_clk_get(&pdev->dev, \"baud\");\n\tif (IS_ERR(data->clk_baud))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->clk_baud),\n\t\t\t\t     \"unable to get baud clock\\n\");\n\n\terr = clk_prepare_enable(data->clk_module);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"could not enable module clock: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = clk_prepare_enable(data->clk_baud);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"could not enable baud clock: %d\\n\", err);\n\t\tgoto out_disable_moduleclk;\n\t}\n\tuart.port.uartclk = clk_get_rate(data->clk_baud);\n\n\tdata->line = serial8250_register_8250_port(&uart);\n\tif (data->line < 0) {\n\t\terr = data->line;\n\t\tgoto out_disable_baudclk;\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\treturn 0;\n\nout_disable_baudclk:\n\tclk_disable_unprepare(data->clk_baud);\nout_disable_moduleclk:\n\tclk_disable_unprepare(data->clk_module);\nout:\n\treturn err;\n}\n\nstatic int ingenic_uart_remove(struct platform_device *pdev)\n{\n\tstruct ingenic_uart_data *data = platform_get_drvdata(pdev);\n\n\tserial8250_unregister_port(data->line);\n\tclk_disable_unprepare(data->clk_module);\n\tclk_disable_unprepare(data->clk_baud);\n\treturn 0;\n}\n\nstatic const struct ingenic_uart_config jz4740_uart_config = {\n\t.tx_loadsz = 8,\n\t.fifosize = 16,\n};\n\nstatic const struct ingenic_uart_config jz4760_uart_config = {\n\t.tx_loadsz = 16,\n\t.fifosize = 32,\n};\n\nstatic const struct ingenic_uart_config jz4780_uart_config = {\n\t.tx_loadsz = 32,\n\t.fifosize = 64,\n};\n\nstatic const struct ingenic_uart_config x1000_uart_config = {\n\t.tx_loadsz = 32,\n\t.fifosize = 64,\n};\n\nstatic const struct of_device_id of_match[] = {\n\t{ .compatible = \"ingenic,jz4740-uart\", .data = &jz4740_uart_config },\n\t{ .compatible = \"ingenic,jz4750-uart\", .data = &jz4760_uart_config },\n\t{ .compatible = \"ingenic,jz4760-uart\", .data = &jz4760_uart_config },\n\t{ .compatible = \"ingenic,jz4770-uart\", .data = &jz4760_uart_config },\n\t{ .compatible = \"ingenic,jz4775-uart\", .data = &jz4760_uart_config },\n\t{ .compatible = \"ingenic,jz4780-uart\", .data = &jz4780_uart_config },\n\t{ .compatible = \"ingenic,x1000-uart\", .data = &x1000_uart_config },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_match);\n\nstatic struct platform_driver ingenic_uart_platform_driver = {\n\t.driver = {\n\t\t.name\t\t= \"ingenic-uart\",\n\t\t.of_match_table\t= of_match,\n\t},\n\t.probe\t\t\t= ingenic_uart_probe,\n\t.remove\t\t\t= ingenic_uart_remove,\n};\n\nmodule_platform_driver(ingenic_uart_platform_driver);\n\nMODULE_AUTHOR(\"Paul Burton\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Ingenic SoC UART driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}