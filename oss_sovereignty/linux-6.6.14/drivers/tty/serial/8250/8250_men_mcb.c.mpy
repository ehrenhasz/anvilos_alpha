{
  "module_name": "8250_men_mcb.c",
  "hash_id": "6ab2d7ae117672a9b924667ade705380b801431cab64d3c584e08944e4577fba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_men_mcb.c",
  "human_readable_source": "\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/mcb.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n\n#define MEN_UART_ID_Z025 0x19\n#define MEN_UART_ID_Z057 0x39\n#define MEN_UART_ID_Z125 0x7d\n\n \n#define MEN_UART1_MASK\t0x01\n#define MEN_UART2_MASK\t0x02\n#define MEN_UART3_MASK\t0x04\n#define MEN_UART4_MASK\t0x08\n\n#define MEN_Z125_UARTS_AVAILABLE\t0x01\n\n#define MEN_Z025_MAX_UARTS\t\t4\n#define MEN_UART_MEM_SIZE\t\t0x10\n#define MEM_UART_REGISTER_SIZE\t\t0x01\n#define MEN_Z025_REGISTER_OFFSET\t0x40\n\n#define MEN_UART1_OFFSET\t0\n#define MEN_UART2_OFFSET\t(MEN_UART1_OFFSET + MEN_UART_MEM_SIZE)\n#define MEN_UART3_OFFSET\t(MEN_UART2_OFFSET + MEN_UART_MEM_SIZE)\n#define MEN_UART4_OFFSET\t(MEN_UART3_OFFSET + MEN_UART_MEM_SIZE)\n\n#define MEN_READ_REGISTER(addr)\treadb(addr)\n\n#define MAX_PORTS\t4\n\nstruct serial_8250_men_mcb_data {\n\tint num_ports;\n\tint line[MAX_PORTS];\n\tunsigned int offset[MAX_PORTS];\n};\n\n \nstatic u32 men_lookup_uartclk(struct mcb_device *mdev)\n{\n\t \n\tu32 clkval = 1041666;\n\n\tdev_info(&mdev->dev, \"%s on board %s\\n\",\n\t\tdev_name(&mdev->dev),\n\t\tmdev->bus->name);\n\tif  (strncmp(mdev->bus->name, \"F075\", 4) == 0)\n\t\tclkval = 1041666;\n\telse if (strncmp(mdev->bus->name, \"F216\", 4) == 0)\n\t\tclkval = 1843200;\n\telse if (strncmp(mdev->bus->name, \"F210\", 4) == 0)\n\t\tclkval = 115200;\n\telse if (strstr(mdev->bus->name, \"215\"))\n\t\tclkval = 1843200;\n\telse\n\t\tdev_info(&mdev->dev,\n\t\t\t \"board not detected, using default uartclk\\n\");\n\n\tclkval = clkval  << 4;\n\n\treturn clkval;\n}\n\nstatic int read_uarts_available_from_register(struct resource *mem_res,\n\t\t\t\t\t      u8 *uarts_available)\n{\n\tvoid __iomem *mem;\n\tint reg_value;\n\n\tif (!request_mem_region(mem_res->start + MEN_Z025_REGISTER_OFFSET,\n\t\t\t\tMEM_UART_REGISTER_SIZE,  KBUILD_MODNAME)) {\n\t\treturn -EBUSY;\n\t}\n\n\tmem = ioremap(mem_res->start + MEN_Z025_REGISTER_OFFSET,\n\t\t      MEM_UART_REGISTER_SIZE);\n\tif (!mem) {\n\t\trelease_mem_region(mem_res->start + MEN_Z025_REGISTER_OFFSET,\n\t\t\t\t   MEM_UART_REGISTER_SIZE);\n\t\treturn -ENOMEM;\n\t}\n\n\treg_value = MEN_READ_REGISTER(mem);\n\n\tiounmap(mem);\n\n\trelease_mem_region(mem_res->start + MEN_Z025_REGISTER_OFFSET,\n\t\t\t   MEM_UART_REGISTER_SIZE);\n\n\t*uarts_available = reg_value >> 4;\n\n\treturn 0;\n}\n\nstatic int read_serial_data(struct mcb_device *mdev,\n\t\t\t    struct resource *mem_res,\n\t\t\t    struct serial_8250_men_mcb_data *serial_data)\n{\n\tu8 uarts_available;\n\tint count = 0;\n\tint mask;\n\tint res;\n\tint i;\n\n\tres = read_uarts_available_from_register(mem_res, &uarts_available);\n\tif (res < 0)\n\t\treturn res;\n\n\tfor (i = 0; i < MAX_PORTS; i++) {\n\t\tmask = 0x1 << i;\n\t\tswitch (uarts_available & mask) {\n\t\tcase MEN_UART1_MASK:\n\t\t\tserial_data->offset[count] = MEN_UART1_OFFSET;\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase MEN_UART2_MASK:\n\t\t\tserial_data->offset[count] = MEN_UART2_OFFSET;\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase MEN_UART3_MASK:\n\t\t\tserial_data->offset[count] = MEN_UART3_OFFSET;\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase MEN_UART4_MASK:\n\t\t\tserial_data->offset[count] = MEN_UART4_OFFSET;\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (count <= 0 || count > MAX_PORTS) {\n\t\tdev_err(&mdev->dev, \"unexpected number of ports: %u\\n\",\n\t\t\tcount);\n\t\treturn -ENODEV;\n\t}\n\n\tserial_data->num_ports = count;\n\n\treturn 0;\n}\n\nstatic int init_serial_data(struct mcb_device *mdev,\n\t\t\t    struct resource *mem_res,\n\t\t\t    struct serial_8250_men_mcb_data *serial_data)\n{\n\tswitch (mdev->id) {\n\tcase MEN_UART_ID_Z125:\n\t\tserial_data->num_ports = 1;\n\t\tserial_data->offset[0] = 0;\n\t\treturn 0;\n\tcase MEN_UART_ID_Z025:\n\tcase MEN_UART_ID_Z057:\n\t\treturn read_serial_data(mdev, mem_res, serial_data);\n\tdefault:\n\t\tdev_err(&mdev->dev, \"no supported device!\\n\");\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic int serial_8250_men_mcb_probe(struct mcb_device *mdev,\n\t\t\t\t     const struct mcb_device_id *id)\n{\n\tstruct uart_8250_port uart;\n\tstruct serial_8250_men_mcb_data *data;\n\tstruct resource *mem;\n\tint i;\n\tint res;\n\n\tmem = mcb_get_resource(mdev, IORESOURCE_MEM);\n\tif (mem == NULL)\n\t\treturn -ENXIO;\n\n\tdata = devm_kzalloc(&mdev->dev,\n\t\t\t    sizeof(struct serial_8250_men_mcb_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tres = init_serial_data(mdev, mem, data);\n\tif (res < 0)\n\t\treturn res;\n\n\tdev_dbg(&mdev->dev, \"found a 16z%03u with %u ports\\n\",\n\t\tmdev->id, data->num_ports);\n\n\tmcb_set_drvdata(mdev, data);\n\n\tfor (i = 0; i < data->num_ports; i++) {\n\t\tmemset(&uart, 0, sizeof(struct uart_8250_port));\n\t\tspin_lock_init(&uart.port.lock);\n\n\t\tuart.port.flags = UPF_SKIP_TEST |\n\t\t\t\t  UPF_SHARE_IRQ |\n\t\t\t\t  UPF_BOOT_AUTOCONF |\n\t\t\t\t  UPF_IOREMAP;\n\t\tuart.port.iotype = UPIO_MEM;\n\t\tuart.port.uartclk = men_lookup_uartclk(mdev);\n\t\tuart.port.irq = mcb_get_irq(mdev);\n\t\tuart.port.mapbase = (unsigned long) mem->start\n\t\t\t\t\t    + data->offset[i];\n\n\t\t \n\t\tres = serial8250_register_8250_port(&uart);\n\t\tif (res < 0) {\n\t\t\tdev_err(&mdev->dev, \"unable to register UART port\\n\");\n\t\t\treturn res;\n\t\t}\n\n\t\tdata->line[i] = res;\n\t\tdev_info(&mdev->dev, \"found MCB UART: ttyS%d\\n\", data->line[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic void serial_8250_men_mcb_remove(struct mcb_device *mdev)\n{\n\tint i;\n\tstruct serial_8250_men_mcb_data *data = mcb_get_drvdata(mdev);\n\n\tif (!data)\n\t\treturn;\n\n\tfor (i = 0; i < data->num_ports; i++)\n\t\tserial8250_unregister_port(data->line[i]);\n}\n\nstatic const struct mcb_device_id serial_8250_men_mcb_ids[] = {\n\t{ .device = MEN_UART_ID_Z025 },\n\t{ .device = MEN_UART_ID_Z057 },\n\t{ .device = MEN_UART_ID_Z125 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(mcb, serial_8250_men_mcb_ids);\n\nstatic struct mcb_driver mcb_driver = {\n\t.driver = {\n\t\t.name = \"8250_men_mcb\",\n\t},\n\t.probe = serial_8250_men_mcb_probe,\n\t.remove = serial_8250_men_mcb_remove,\n\t.id_table = serial_8250_men_mcb_ids,\n};\nmodule_mcb_driver(mcb_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MEN 8250 UART driver\");\nMODULE_AUTHOR(\"Michael Moese <michael.moese@men.de\");\nMODULE_ALIAS(\"mcb:16z125\");\nMODULE_ALIAS(\"mcb:16z025\");\nMODULE_ALIAS(\"mcb:16z057\");\nMODULE_IMPORT_NS(MCB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}