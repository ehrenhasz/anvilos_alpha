{
  "module_name": "8250_tegra.c",
  "hash_id": "9b6386374a86ca19c887c5a24747c84a46d0d3f4795c963897f9fd3ba8e963da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_tegra.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include \"8250.h\"\n\nstruct tegra_uart {\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\tint line;\n};\n\nstatic void tegra_uart_handle_break(struct uart_port *p)\n{\n\tunsigned int status, tmout = 10000;\n\n\twhile (1) {\n\t\tstatus = p->serial_in(p, UART_LSR);\n\t\tif (!(status & (UART_LSR_FIFOE | UART_LSR_BRK_ERROR_BITS)))\n\t\t\tbreak;\n\n\t\tp->serial_in(p, UART_RX);\n\n\t\tif (--tmout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic int tegra_uart_probe(struct platform_device *pdev)\n{\n\tstruct uart_8250_port port8250;\n\tstruct tegra_uart *uart;\n\tstruct uart_port *port;\n\tstruct resource *res;\n\tint ret;\n\n\tuart = devm_kzalloc(&pdev->dev, sizeof(*uart), GFP_KERNEL);\n\tif (!uart)\n\t\treturn -ENOMEM;\n\n\tmemset(&port8250, 0, sizeof(port8250));\n\n\tport = &port8250.port;\n\tspin_lock_init(&port->lock);\n\n\tport->flags = UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF | UPF_FIXED_PORT |\n\t\t      UPF_FIXED_TYPE;\n\tport->iotype = UPIO_MEM32;\n\tport->regshift = 2;\n\tport->type = PORT_TEGRA;\n\tport->irqflags |= IRQF_SHARED;\n\tport->dev = &pdev->dev;\n\tport->handle_break = tegra_uart_handle_break;\n\n\tret = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\tif (ret >= 0)\n\t\tport->line = ret;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport->irq = ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tport->membase = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t     resource_size(res));\n\tif (!port->membase)\n\t\treturn -ENOMEM;\n\n\tport->mapbase = res->start;\n\tport->mapsize = resource_size(res);\n\n\tuart->rst = devm_reset_control_get_optional_shared(&pdev->dev, NULL);\n\tif (IS_ERR(uart->rst))\n\t\treturn PTR_ERR(uart->rst);\n\n\tif (device_property_read_u32(&pdev->dev, \"clock-frequency\",\n\t\t\t\t     &port->uartclk)) {\n\t\tuart->clk = devm_clk_get(&pdev->dev, NULL);\n\t\tif (IS_ERR(uart->clk)) {\n\t\t\tdev_err(&pdev->dev, \"failed to get clock!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tret = clk_prepare_enable(uart->clk);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tport->uartclk = clk_get_rate(uart->clk);\n\t}\n\n\tret = reset_control_deassert(uart->rst);\n\tif (ret)\n\t\tgoto err_clkdisable;\n\n\tret = serial8250_register_8250_port(&port8250);\n\tif (ret < 0)\n\t\tgoto err_ctrl_assert;\n\n\tplatform_set_drvdata(pdev, uart);\n\tuart->line = ret;\n\n\treturn 0;\n\nerr_ctrl_assert:\n\treset_control_assert(uart->rst);\nerr_clkdisable:\n\tclk_disable_unprepare(uart->clk);\n\n\treturn ret;\n}\n\nstatic int tegra_uart_remove(struct platform_device *pdev)\n{\n\tstruct tegra_uart *uart = platform_get_drvdata(pdev);\n\n\tserial8250_unregister_port(uart->line);\n\treset_control_assert(uart->rst);\n\tclk_disable_unprepare(uart->clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tegra_uart_suspend(struct device *dev)\n{\n\tstruct tegra_uart *uart = dev_get_drvdata(dev);\n\tstruct uart_8250_port *port8250 = serial8250_get_port(uart->line);\n\tstruct uart_port *port = &port8250->port;\n\n\tserial8250_suspend_port(uart->line);\n\n\tif (!uart_console(port) || console_suspend_enabled)\n\t\tclk_disable_unprepare(uart->clk);\n\n\treturn 0;\n}\n\nstatic int tegra_uart_resume(struct device *dev)\n{\n\tstruct tegra_uart *uart = dev_get_drvdata(dev);\n\tstruct uart_8250_port *port8250 = serial8250_get_port(uart->line);\n\tstruct uart_port *port = &port8250->port;\n\n\tif (!uart_console(port) || console_suspend_enabled)\n\t\tclk_prepare_enable(uart->clk);\n\n\tserial8250_resume_port(uart->line);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(tegra_uart_pm_ops, tegra_uart_suspend,\n\t\t\t tegra_uart_resume);\n\nstatic const struct of_device_id tegra_uart_of_match[] = {\n\t{ .compatible = \"nvidia,tegra20-uart\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_uart_of_match);\n\nstatic const struct acpi_device_id tegra_uart_acpi_match[] __maybe_unused = {\n\t{ \"NVDA0100\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, tegra_uart_acpi_match);\n\nstatic struct platform_driver tegra_uart_driver = {\n\t.driver = {\n\t\t.name = \"tegra-uart\",\n\t\t.pm = &tegra_uart_pm_ops,\n\t\t.of_match_table = tegra_uart_of_match,\n\t\t.acpi_match_table = ACPI_PTR(tegra_uart_acpi_match),\n\t},\n\t.probe = tegra_uart_probe,\n\t.remove = tegra_uart_remove,\n};\n\nmodule_platform_driver(tegra_uart_driver);\n\nMODULE_AUTHOR(\"Jeff Brasen <jbrasen@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra 8250 Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}