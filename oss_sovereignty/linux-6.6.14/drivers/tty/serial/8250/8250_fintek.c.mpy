{
  "module_name": "8250_fintek.c",
  "hash_id": "8b168f5c59563265dcbb2113e2a4c49e8ca7b55e4ce5fbda8e7f797a31cf7a78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_fintek.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pnp.h>\n#include <linux/kernel.h>\n#include <linux/serial_core.h>\n#include <linux/irq.h>\n#include  \"8250.h\"\n\n#define ADDR_PORT 0\n#define DATA_PORT 1\n#define EXIT_KEY 0xAA\n#define CHIP_ID1  0x20\n#define CHIP_ID2  0x21\n#define CHIP_ID_F81865 0x0407\n#define CHIP_ID_F81866 0x1010\n#define CHIP_ID_F81966 0x0215\n#define CHIP_ID_F81216AD 0x1602\n#define CHIP_ID_F81216H 0x0501\n#define CHIP_ID_F81216 0x0802\n#define VENDOR_ID1 0x23\n#define VENDOR_ID1_VAL 0x19\n#define VENDOR_ID2 0x24\n#define VENDOR_ID2_VAL 0x34\n#define IO_ADDR1 0x61\n#define IO_ADDR2 0x60\n#define LDN 0x7\n\n#define FINTEK_IRQ_MODE\t0x70\n#define IRQ_SHARE\tBIT(4)\n#define IRQ_MODE_MASK\t(BIT(6) | BIT(5))\n#define IRQ_LEVEL_LOW\t0\n#define IRQ_EDGE_HIGH\tBIT(5)\n\n \n#define RS485  0xF0\n#define RTS_INVERT BIT(5)\n#define RS485_URA BIT(4)\n#define RXW4C_IRA BIT(3)\n#define TXW4C_IRA BIT(2)\n\n#define FIFO_CTRL\t\t0xF6\n#define FIFO_MODE_MASK\t\t(BIT(1) | BIT(0))\n#define FIFO_MODE_128\t\t(BIT(1) | BIT(0))\n#define RXFTHR_MODE_MASK\t(BIT(5) | BIT(4))\n#define RXFTHR_MODE_4X\t\tBIT(5)\n\n#define F81216_LDN_LOW\t0x0\n#define F81216_LDN_HIGH\t0x4\n\n \n#define F81866_IRQ_MODE\t\t0xf0\n#define F81866_IRQ_SHARE\tBIT(0)\n#define F81866_IRQ_MODE0\tBIT(1)\n\n#define F81866_FIFO_CTRL\tFIFO_CTRL\n#define F81866_IRQ_MODE1\tBIT(3)\n\n#define F81866_LDN_LOW\t\t0x10\n#define F81866_LDN_HIGH\t\t0x16\n\n#define F81866_UART_CLK 0xF2\n#define F81866_UART_CLK_MASK (BIT(1) | BIT(0))\n#define F81866_UART_CLK_1_8432MHZ 0\n#define F81866_UART_CLK_14_769MHZ (BIT(1) | BIT(0))\n#define F81866_UART_CLK_18_432MHZ BIT(0)\n#define F81866_UART_CLK_24MHZ BIT(1)\n\nstruct fintek_8250 {\n\tu16 pid;\n\tu16 base_port;\n\tu8 index;\n\tu8 key;\n};\n\nstatic u8 sio_read_reg(struct fintek_8250 *pdata, u8 reg)\n{\n\toutb(reg, pdata->base_port + ADDR_PORT);\n\treturn inb(pdata->base_port + DATA_PORT);\n}\n\nstatic void sio_write_reg(struct fintek_8250 *pdata, u8 reg, u8 data)\n{\n\toutb(reg, pdata->base_port + ADDR_PORT);\n\toutb(data, pdata->base_port + DATA_PORT);\n}\n\nstatic void sio_write_mask_reg(struct fintek_8250 *pdata, u8 reg, u8 mask,\n\t\t\t       u8 data)\n{\n\tu8 tmp;\n\n\ttmp = (sio_read_reg(pdata, reg) & ~mask) | (mask & data);\n\tsio_write_reg(pdata, reg, tmp);\n}\n\nstatic int fintek_8250_enter_key(u16 base_port, u8 key)\n{\n\tif (!request_muxed_region(base_port, 2, \"8250_fintek\"))\n\t\treturn -EBUSY;\n\n\t \n\toutb(EXIT_KEY, base_port + ADDR_PORT);\n\n\toutb(key, base_port + ADDR_PORT);\n\toutb(key, base_port + ADDR_PORT);\n\treturn 0;\n}\n\nstatic void fintek_8250_exit_key(u16 base_port)\n{\n\n\toutb(EXIT_KEY, base_port + ADDR_PORT);\n\trelease_region(base_port + ADDR_PORT, 2);\n}\n\nstatic int fintek_8250_check_id(struct fintek_8250 *pdata)\n{\n\tu16 chip;\n\n\tif (sio_read_reg(pdata, VENDOR_ID1) != VENDOR_ID1_VAL)\n\t\treturn -ENODEV;\n\n\tif (sio_read_reg(pdata, VENDOR_ID2) != VENDOR_ID2_VAL)\n\t\treturn -ENODEV;\n\n\tchip = sio_read_reg(pdata, CHIP_ID1);\n\tchip |= sio_read_reg(pdata, CHIP_ID2) << 8;\n\n\tswitch (chip) {\n\tcase CHIP_ID_F81865:\n\tcase CHIP_ID_F81866:\n\tcase CHIP_ID_F81966:\n\tcase CHIP_ID_F81216AD:\n\tcase CHIP_ID_F81216H:\n\tcase CHIP_ID_F81216:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tpdata->pid = chip;\n\treturn 0;\n}\n\nstatic int fintek_8250_get_ldn_range(struct fintek_8250 *pdata, int *min,\n\t\t\t\t     int *max)\n{\n\tswitch (pdata->pid) {\n\tcase CHIP_ID_F81966:\n\tcase CHIP_ID_F81865:\n\tcase CHIP_ID_F81866:\n\t\t*min = F81866_LDN_LOW;\n\t\t*max = F81866_LDN_HIGH;\n\t\treturn 0;\n\n\tcase CHIP_ID_F81216AD:\n\tcase CHIP_ID_F81216H:\n\tcase CHIP_ID_F81216:\n\t\t*min = F81216_LDN_LOW;\n\t\t*max = F81216_LDN_HIGH;\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int fintek_8250_rs485_config(struct uart_port *port, struct ktermios *termios,\n\t\t\t      struct serial_rs485 *rs485)\n{\n\tuint8_t config = 0;\n\tstruct fintek_8250 *pdata = port->private_data;\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\n\tif (rs485->flags & SER_RS485_ENABLED) {\n\t\t \n\t\tif (!(rs485->flags & SER_RS485_RTS_ON_SEND) ==\n\t\t    !(rs485->flags & SER_RS485_RTS_AFTER_SEND))\n\t\t\treturn -EINVAL;\n\t\tconfig |= RS485_URA;\n\t}\n\n\tif (rs485->delay_rts_before_send) {\n\t\trs485->delay_rts_before_send = 1;\n\t\tconfig |= TXW4C_IRA;\n\t}\n\n\tif (rs485->delay_rts_after_send) {\n\t\trs485->delay_rts_after_send = 1;\n\t\tconfig |= RXW4C_IRA;\n\t}\n\n\tif (rs485->flags & SER_RS485_RTS_ON_SEND)\n\t\tconfig |= RTS_INVERT;\n\n\tif (fintek_8250_enter_key(pdata->base_port, pdata->key))\n\t\treturn -EBUSY;\n\n\tsio_write_reg(pdata, LDN, pdata->index);\n\tsio_write_reg(pdata, RS485, config);\n\tfintek_8250_exit_key(pdata->base_port);\n\n\treturn 0;\n}\n\nstatic void fintek_8250_set_irq_mode(struct fintek_8250 *pdata, bool is_level)\n{\n\tsio_write_reg(pdata, LDN, pdata->index);\n\n\tswitch (pdata->pid) {\n\tcase CHIP_ID_F81966:\n\tcase CHIP_ID_F81866:\n\t\tsio_write_mask_reg(pdata, F81866_FIFO_CTRL, F81866_IRQ_MODE1,\n\t\t\t\t   0);\n\t\tfallthrough;\n\tcase CHIP_ID_F81865:\n\t\tsio_write_mask_reg(pdata, F81866_IRQ_MODE, F81866_IRQ_SHARE,\n\t\t\t\t   F81866_IRQ_SHARE);\n\t\tsio_write_mask_reg(pdata, F81866_IRQ_MODE, F81866_IRQ_MODE0,\n\t\t\t\t   is_level ? 0 : F81866_IRQ_MODE0);\n\t\tbreak;\n\n\tcase CHIP_ID_F81216AD:\n\tcase CHIP_ID_F81216H:\n\tcase CHIP_ID_F81216:\n\t\tsio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_SHARE,\n\t\t\t\t   IRQ_SHARE);\n\t\tsio_write_mask_reg(pdata, FINTEK_IRQ_MODE, IRQ_MODE_MASK,\n\t\t\t\t   is_level ? IRQ_LEVEL_LOW : IRQ_EDGE_HIGH);\n\t\tbreak;\n\t}\n}\n\nstatic void fintek_8250_set_max_fifo(struct fintek_8250 *pdata)\n{\n\tswitch (pdata->pid) {\n\tcase CHIP_ID_F81216H:  \n\tcase CHIP_ID_F81966:\n\tcase CHIP_ID_F81866:\n\t\tsio_write_mask_reg(pdata, FIFO_CTRL,\n\t\t\t\t   FIFO_MODE_MASK | RXFTHR_MODE_MASK,\n\t\t\t\t   FIFO_MODE_128 | RXFTHR_MODE_4X);\n\t\tbreak;\n\n\tdefault:  \n\t\tbreak;\n\t}\n}\n\nstatic void fintek_8250_set_termios(struct uart_port *port,\n\t\t\t\t    struct ktermios *termios,\n\t\t\t\t    const struct ktermios *old)\n{\n\tstruct fintek_8250 *pdata = port->private_data;\n\tunsigned int baud = tty_termios_baud_rate(termios);\n\tint i;\n\tu8 reg;\n\tstatic u32 baudrate_table[] = {115200, 921600, 1152000, 1500000};\n\tstatic u8 clock_table[] = { F81866_UART_CLK_1_8432MHZ,\n\t\t\tF81866_UART_CLK_14_769MHZ, F81866_UART_CLK_18_432MHZ,\n\t\t\tF81866_UART_CLK_24MHZ };\n\n\t \n\tif (!baud)\n\t\tgoto exit;\n\n\tswitch (pdata->pid) {\n\tcase CHIP_ID_F81216H:\n\t\treg = RS485;\n\t\tbreak;\n\tcase CHIP_ID_F81966:\n\tcase CHIP_ID_F81866:\n\t\treg = F81866_UART_CLK;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_warn(port->dev,\n\t\t\t\"%s: pid: %x Not support. use default set_termios.\\n\",\n\t\t\t__func__, pdata->pid);\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(baudrate_table); ++i) {\n\t\tif (baud > baudrate_table[i] || baudrate_table[i] % baud != 0)\n\t\t\tcontinue;\n\n\t\tif (port->uartclk == baudrate_table[i] * 16)\n\t\t\tbreak;\n\n\t\tif (fintek_8250_enter_key(pdata->base_port, pdata->key))\n\t\t\tcontinue;\n\n\t\tport->uartclk = baudrate_table[i] * 16;\n\n\t\tsio_write_reg(pdata, LDN, pdata->index);\n\t\tsio_write_mask_reg(pdata, reg, F81866_UART_CLK_MASK,\n\t\t\t\tclock_table[i]);\n\n\t\tfintek_8250_exit_key(pdata->base_port);\n\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(baudrate_table)) {\n\t\tbaud = tty_termios_baud_rate(old);\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\t}\n\nexit:\n\tserial8250_do_set_termios(port, termios, old);\n}\n\nstatic void fintek_8250_set_termios_handler(struct uart_8250_port *uart)\n{\n\tstruct fintek_8250 *pdata = uart->port.private_data;\n\n\tswitch (pdata->pid) {\n\tcase CHIP_ID_F81216H:\n\tcase CHIP_ID_F81966:\n\tcase CHIP_ID_F81866:\n\t\tuart->port.set_termios = fintek_8250_set_termios;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int probe_setup_port(struct fintek_8250 *pdata,\n\t\t\t\t\tstruct uart_8250_port *uart)\n{\n\tstatic const u16 addr[] = {0x4e, 0x2e};\n\tstatic const u8 keys[] = {0x77, 0xa0, 0x87, 0x67};\n\tstruct irq_data *irq_data;\n\tbool level_mode = false;\n\tint i, j, k, min, max;\n\n\tfor (i = 0; i < ARRAY_SIZE(addr); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(keys); j++) {\n\t\t\tpdata->base_port = addr[i];\n\t\t\tpdata->key = keys[j];\n\n\t\t\tif (fintek_8250_enter_key(addr[i], keys[j]))\n\t\t\t\tcontinue;\n\t\t\tif (fintek_8250_check_id(pdata) ||\n\t\t\t    fintek_8250_get_ldn_range(pdata, &min, &max)) {\n\t\t\t\tfintek_8250_exit_key(addr[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (k = min; k < max; k++) {\n\t\t\t\tu16 aux;\n\n\t\t\t\tsio_write_reg(pdata, LDN, k);\n\t\t\t\taux = sio_read_reg(pdata, IO_ADDR1);\n\t\t\t\taux |= sio_read_reg(pdata, IO_ADDR2) << 8;\n\t\t\t\tif (aux != uart->port.iobase)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tpdata->index = k;\n\n\t\t\t\tirq_data = irq_get_irq_data(uart->port.irq);\n\t\t\t\tif (irq_data)\n\t\t\t\t\tlevel_mode =\n\t\t\t\t\t\tirqd_is_level_type(irq_data);\n\n\t\t\t\tfintek_8250_set_irq_mode(pdata, level_mode);\n\t\t\t\tfintek_8250_set_max_fifo(pdata);\n\n\t\t\t\tfintek_8250_exit_key(addr[i]);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfintek_8250_exit_key(addr[i]);\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic const struct serial_rs485 fintek_8250_rs485_supported_port0 = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | SER_RS485_RTS_AFTER_SEND,\n\t.delay_rts_before_send = 1,\n\t.delay_rts_after_send = 1,\n};\n\nstatic const struct serial_rs485 fintek_8250_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | SER_RS485_RTS_AFTER_SEND,\n};\n\nstatic void fintek_8250_set_rs485_handler(struct uart_8250_port *uart)\n{\n\tstruct fintek_8250 *pdata = uart->port.private_data;\n\n\tswitch (pdata->pid) {\n\tcase CHIP_ID_F81216AD:\n\tcase CHIP_ID_F81216H:\n\tcase CHIP_ID_F81966:\n\tcase CHIP_ID_F81866:\n\tcase CHIP_ID_F81865:\n\t\tuart->port.rs485_config = fintek_8250_rs485_config;\n\t\tif (!pdata->index)\n\t\t\tuart->port.rs485_supported = fintek_8250_rs485_supported_port0;\n\t\telse\n\t\t\tuart->port.rs485_supported = fintek_8250_rs485_supported;\n\t\tbreak;\n\n\tdefault:  \n\t\tbreak;\n\t}\n}\n\nint fintek_8250_probe(struct uart_8250_port *uart)\n{\n\tstruct fintek_8250 *pdata;\n\tstruct fintek_8250 probe_data;\n\n\tif (probe_setup_port(&probe_data, uart))\n\t\treturn -ENODEV;\n\n\tpdata = devm_kzalloc(uart->port.dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tmemcpy(pdata, &probe_data, sizeof(probe_data));\n\tuart->port.private_data = pdata;\n\tfintek_8250_set_rs485_handler(uart);\n\tfintek_8250_set_termios_handler(uart);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}