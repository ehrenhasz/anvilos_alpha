{
  "module_name": "8250_rt288x.c",
  "hash_id": "bd53f219eba320f110f48ac3eef908ac6a264fd7fad852b094fc483a99becd5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_rt288x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/serial.h>\n#include <linux/serial_8250.h>\n\n#include \"8250.h\"\n\n#define RT288X_DL\t0x28\n\n \nstatic const u8 au_io_in_map[7] = {\n\t[UART_RX]\t= 0,\n\t[UART_IER]\t= 2,\n\t[UART_IIR]\t= 3,\n\t[UART_LCR]\t= 5,\n\t[UART_MCR]\t= 6,\n\t[UART_LSR]\t= 7,\n\t[UART_MSR]\t= 8,\n};\n\nstatic const u8 au_io_out_map[5] = {\n\t[UART_TX]\t= 1,\n\t[UART_IER]\t= 2,\n\t[UART_FCR]\t= 4,\n\t[UART_LCR]\t= 5,\n\t[UART_MCR]\t= 6,\n};\n\nstatic unsigned int au_serial_in(struct uart_port *p, int offset)\n{\n\tif (offset >= ARRAY_SIZE(au_io_in_map))\n\t\treturn UINT_MAX;\n\toffset = au_io_in_map[offset];\n\n\treturn __raw_readl(p->membase + (offset << p->regshift));\n}\n\nstatic void au_serial_out(struct uart_port *p, int offset, int value)\n{\n\tif (offset >= ARRAY_SIZE(au_io_out_map))\n\t\treturn;\n\toffset = au_io_out_map[offset];\n\n\t__raw_writel(value, p->membase + (offset << p->regshift));\n}\n\n \nstatic u32 au_serial_dl_read(struct uart_8250_port *up)\n{\n\treturn __raw_readl(up->port.membase + RT288X_DL);\n}\n\nstatic void au_serial_dl_write(struct uart_8250_port *up, u32 value)\n{\n\t__raw_writel(value, up->port.membase + RT288X_DL);\n}\n\nint au_platform_setup(struct plat_serial8250_port *p)\n{\n\tp->iotype = UPIO_AU;\n\n\tp->serial_in = au_serial_in;\n\tp->serial_out = au_serial_out;\n\tp->dl_read = au_serial_dl_read;\n\tp->dl_write = au_serial_dl_write;\n\n\tp->mapsize = 0x1000;\n\n\tp->bugs |= UART_BUG_NOMSR;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(au_platform_setup);\n\nint rt288x_setup(struct uart_port *p)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(p);\n\n\tp->iotype = UPIO_AU;\n\n\tp->serial_in = au_serial_in;\n\tp->serial_out = au_serial_out;\n\tup->dl_read = au_serial_dl_read;\n\tup->dl_write = au_serial_dl_write;\n\n\tp->mapsize = 0x100;\n\n\tup->bugs |= UART_BUG_NOMSR;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt288x_setup);\n\n#ifdef CONFIG_SERIAL_8250_CONSOLE\nstatic void au_putc(struct uart_port *port, unsigned char c)\n{\n\tunsigned int status;\n\n\tau_serial_out(port, UART_TX, c);\n\n\tfor (;;) {\n\t\tstatus = au_serial_in(port, UART_LSR);\n\t\tif (uart_lsr_tx_empty(status))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n}\n\nstatic void au_early_serial8250_write(struct console *console,\n\t\t\t\t      const char *s, unsigned int count)\n{\n\tstruct earlycon_device *device = console->data;\n\tstruct uart_port *port = &device->port;\n\n\tuart_console_write(port, s, count, au_putc);\n}\n\nstatic int __init early_au_setup(struct earlycon_device *dev, const char *opt)\n{\n\trt288x_setup(&dev->port);\n\tdev->con->write = au_early_serial8250_write;\n\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(palmchip, \"ralink,rt2880-uart\", early_au_setup);\n#endif\n\nMODULE_DESCRIPTION(\"RT288x/Au1xxx UART driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}