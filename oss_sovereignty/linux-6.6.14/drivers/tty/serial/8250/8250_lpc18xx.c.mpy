{
  "module_name": "8250_lpc18xx.c",
  "hash_id": "6093154f89b8b6051840d4673f96d0e396c8f668926a965b75d6bc14f34824d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/8250/8250_lpc18xx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include \"8250.h\"\n\n \n#define LPC18XX_UART_RS485CTRL\t\t(0x04c / sizeof(u32))\n#define  LPC18XX_UART_RS485CTRL_NMMEN\tBIT(0)\n#define  LPC18XX_UART_RS485CTRL_DCTRL\tBIT(4)\n#define  LPC18XX_UART_RS485CTRL_OINV\tBIT(5)\n#define LPC18XX_UART_RS485DLY\t\t(0x054 / sizeof(u32))\n#define LPC18XX_UART_RS485DLY_MAX\t255\n\nstruct lpc18xx_uart_data {\n\tstruct uart_8250_dma dma;\n\tstruct clk *clk_uart;\n\tstruct clk *clk_reg;\n\tint line;\n};\n\nstatic int lpc18xx_rs485_config(struct uart_port *port, struct ktermios *termios,\n\t\t\t\tstruct serial_rs485 *rs485)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tu32 rs485_ctrl_reg = 0;\n\tu32 rs485_dly_reg = 0;\n\tunsigned baud_clk;\n\n\tif (rs485->flags & SER_RS485_ENABLED) {\n\t\trs485_ctrl_reg |= LPC18XX_UART_RS485CTRL_NMMEN |\n\t\t\t\t  LPC18XX_UART_RS485CTRL_DCTRL;\n\n\t\tif (rs485->flags & SER_RS485_RTS_ON_SEND)\n\t\t\trs485_ctrl_reg |= LPC18XX_UART_RS485CTRL_OINV;\n\t}\n\n\tif (rs485->delay_rts_after_send) {\n\t\tbaud_clk = port->uartclk / up->dl_read(up);\n\t\trs485_dly_reg = DIV_ROUND_UP(rs485->delay_rts_after_send\n\t\t\t\t\t\t* baud_clk, MSEC_PER_SEC);\n\n\t\tif (rs485_dly_reg > LPC18XX_UART_RS485DLY_MAX)\n\t\t\trs485_dly_reg = LPC18XX_UART_RS485DLY_MAX;\n\n\t\t \n\t\trs485->delay_rts_after_send = (rs485_dly_reg * MSEC_PER_SEC)\n\t\t\t\t\t\t/ baud_clk;\n\t}\n\n\tserial_out(up, LPC18XX_UART_RS485CTRL, rs485_ctrl_reg);\n\tserial_out(up, LPC18XX_UART_RS485DLY, rs485_dly_reg);\n\n\treturn 0;\n}\n\nstatic void lpc18xx_uart_serial_out(struct uart_port *p, int offset, int value)\n{\n\t \n\tif (offset == UART_FCR && (value & UART_FCR_ENABLE_FIFO))\n\t\tvalue |= UART_FCR_DMA_SELECT;\n\n\toffset = offset << p->regshift;\n\twritel(value, p->membase + offset);\n}\n\nstatic const struct serial_rs485 lpc18xx_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | SER_RS485_RTS_AFTER_SEND,\n\t.delay_rts_after_send = 1,\n\t \n};\n\nstatic int lpc18xx_serial_probe(struct platform_device *pdev)\n{\n\tstruct lpc18xx_uart_data *data;\n\tstruct uart_8250_port uart;\n\tstruct resource *res;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"memory resource not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&uart, 0, sizeof(uart));\n\n\tuart.port.membase = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t resource_size(res));\n\tif (!uart.port.membase)\n\t\treturn -ENOMEM;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->clk_uart = devm_clk_get(&pdev->dev, \"uartclk\");\n\tif (IS_ERR(data->clk_uart)) {\n\t\tdev_err(&pdev->dev, \"uart clock not found\\n\");\n\t\treturn PTR_ERR(data->clk_uart);\n\t}\n\n\tdata->clk_reg = devm_clk_get(&pdev->dev, \"reg\");\n\tif (IS_ERR(data->clk_reg)) {\n\t\tdev_err(&pdev->dev, \"reg clock not found\\n\");\n\t\treturn PTR_ERR(data->clk_reg);\n\t}\n\n\tret = clk_prepare_enable(data->clk_reg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to enable reg clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(data->clk_uart);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to enable uart clock\\n\");\n\t\tgoto dis_clk_reg;\n\t}\n\n\tret = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\tif (ret >= 0)\n\t\tuart.port.line = ret;\n\n\tdata->dma.rx_param = data;\n\tdata->dma.tx_param = data;\n\n\tspin_lock_init(&uart.port.lock);\n\tuart.port.dev = &pdev->dev;\n\tuart.port.irq = irq;\n\tuart.port.iotype = UPIO_MEM32;\n\tuart.port.mapbase = res->start;\n\tuart.port.regshift = 2;\n\tuart.port.type = PORT_16550A;\n\tuart.port.flags = UPF_FIXED_PORT | UPF_FIXED_TYPE | UPF_SKIP_TEST;\n\tuart.port.uartclk = clk_get_rate(data->clk_uart);\n\tuart.port.private_data = data;\n\tuart.port.rs485_config = lpc18xx_rs485_config;\n\tuart.port.rs485_supported = lpc18xx_rs485_supported;\n\tuart.port.serial_out = lpc18xx_uart_serial_out;\n\n\tuart.dma = &data->dma;\n\tuart.dma->rxconf.src_maxburst = 1;\n\tuart.dma->txconf.dst_maxburst = 1;\n\n\tret = serial8250_register_8250_port(&uart);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"unable to register 8250 port\\n\");\n\t\tgoto dis_uart_clk;\n\t}\n\n\tdata->line = ret;\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n\ndis_uart_clk:\n\tclk_disable_unprepare(data->clk_uart);\ndis_clk_reg:\n\tclk_disable_unprepare(data->clk_reg);\n\treturn ret;\n}\n\nstatic int lpc18xx_serial_remove(struct platform_device *pdev)\n{\n\tstruct lpc18xx_uart_data *data = platform_get_drvdata(pdev);\n\n\tserial8250_unregister_port(data->line);\n\tclk_disable_unprepare(data->clk_uart);\n\tclk_disable_unprepare(data->clk_reg);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id lpc18xx_serial_match[] = {\n\t{ .compatible = \"nxp,lpc1850-uart\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lpc18xx_serial_match);\n\nstatic struct platform_driver lpc18xx_serial_driver = {\n\t.probe  = lpc18xx_serial_probe,\n\t.remove = lpc18xx_serial_remove,\n\t.driver = {\n\t\t.name = \"lpc18xx-uart\",\n\t\t.of_match_table = lpc18xx_serial_match,\n\t},\n};\nmodule_platform_driver(lpc18xx_serial_driver);\n\nMODULE_AUTHOR(\"Joachim Eastwood <manabian@gmail.com>\");\nMODULE_DESCRIPTION(\"Serial port driver NXP LPC18xx/43xx devices\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}