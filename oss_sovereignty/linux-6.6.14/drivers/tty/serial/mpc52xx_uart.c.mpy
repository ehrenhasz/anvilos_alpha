{
  "module_name": "mpc52xx_uart.c",
  "hash_id": "c29348178d480bb0672a7cb58721dc5cc6100c9f114af469e7aa21427ff8ea27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/mpc52xx_uart.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/sysrq.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n\n#include <asm/mpc52xx.h>\n#include <asm/mpc52xx_psc.h>\n\n#include <linux/serial_core.h>\n\n\n \n#define SERIAL_PSC_MAJOR\t204\n#define SERIAL_PSC_MINOR\t148\n\n\n#define ISR_PASS_LIMIT 256\t \n\n\nstatic struct uart_port mpc52xx_uart_ports[MPC52xx_PSC_MAXNUM];\n\t \n\n \nstatic struct device_node *mpc52xx_uart_nodes[MPC52xx_PSC_MAXNUM];\n\nstatic void mpc52xx_uart_of_enumerate(void);\n\n\n#define PSC(port) ((struct mpc52xx_psc __iomem *)((port)->membase))\n\n\n \nstatic irqreturn_t mpc52xx_uart_int(int irq, void *dev_id);\nstatic irqreturn_t mpc5xxx_uart_process_int(struct uart_port *port);\n\n \n \n \n\nstruct psc_ops {\n\tvoid\t\t(*fifo_init)(struct uart_port *port);\n\tunsigned int\t(*raw_rx_rdy)(struct uart_port *port);\n\tunsigned int\t(*raw_tx_rdy)(struct uart_port *port);\n\tunsigned int\t(*rx_rdy)(struct uart_port *port);\n\tunsigned int\t(*tx_rdy)(struct uart_port *port);\n\tunsigned int\t(*tx_empty)(struct uart_port *port);\n\tvoid\t\t(*stop_rx)(struct uart_port *port);\n\tvoid\t\t(*start_tx)(struct uart_port *port);\n\tvoid\t\t(*stop_tx)(struct uart_port *port);\n\tvoid\t\t(*rx_clr_irq)(struct uart_port *port);\n\tvoid\t\t(*tx_clr_irq)(struct uart_port *port);\n\tvoid\t\t(*write_char)(struct uart_port *port, unsigned char c);\n\tunsigned char\t(*read_char)(struct uart_port *port);\n\tvoid\t\t(*cw_disable_ints)(struct uart_port *port);\n\tvoid\t\t(*cw_restore_ints)(struct uart_port *port);\n\tunsigned int\t(*set_baudrate)(struct uart_port *port,\n\t\t\t\t\tstruct ktermios *new,\n\t\t\t\t\tconst struct ktermios *old);\n\tint\t\t(*clock_alloc)(struct uart_port *port);\n\tvoid\t\t(*clock_relse)(struct uart_port *port);\n\tint\t\t(*clock)(struct uart_port *port, int enable);\n\tint\t\t(*fifoc_init)(void);\n\tvoid\t\t(*fifoc_uninit)(void);\n\tvoid\t\t(*get_irq)(struct uart_port *, struct device_node *);\n\tirqreturn_t\t(*handle_irq)(struct uart_port *port);\n\tu16\t\t(*get_status)(struct uart_port *port);\n\tu8\t\t(*get_ipcr)(struct uart_port *port);\n\tvoid\t\t(*command)(struct uart_port *port, u8 cmd);\n\tvoid\t\t(*set_mode)(struct uart_port *port, u8 mr1, u8 mr2);\n\tvoid\t\t(*set_rts)(struct uart_port *port, int state);\n\tvoid\t\t(*enable_ms)(struct uart_port *port);\n\tvoid\t\t(*set_sicr)(struct uart_port *port, u32 val);\n\tvoid\t\t(*set_imr)(struct uart_port *port, u16 val);\n\tu8\t\t(*get_mr1)(struct uart_port *port);\n};\n\n \nstatic inline void mpc52xx_set_divisor(struct mpc52xx_psc __iomem *psc,\n\t\t\t\t       u16 prescaler, unsigned int divisor)\n{\n\t \n\tout_be16(&psc->mpc52xx_psc_clock_select, prescaler);\n\tout_8(&psc->ctur, divisor >> 8);\n\tout_8(&psc->ctlr, divisor & 0xff);\n}\n\nstatic u16 mpc52xx_psc_get_status(struct uart_port *port)\n{\n\treturn in_be16(&PSC(port)->mpc52xx_psc_status);\n}\n\nstatic u8 mpc52xx_psc_get_ipcr(struct uart_port *port)\n{\n\treturn in_8(&PSC(port)->mpc52xx_psc_ipcr);\n}\n\nstatic void mpc52xx_psc_command(struct uart_port *port, u8 cmd)\n{\n\tout_8(&PSC(port)->command, cmd);\n}\n\nstatic void mpc52xx_psc_set_mode(struct uart_port *port, u8 mr1, u8 mr2)\n{\n\tout_8(&PSC(port)->command, MPC52xx_PSC_SEL_MODE_REG_1);\n\tout_8(&PSC(port)->mode, mr1);\n\tout_8(&PSC(port)->mode, mr2);\n}\n\nstatic void mpc52xx_psc_set_rts(struct uart_port *port, int state)\n{\n\tif (state)\n\t\tout_8(&PSC(port)->op1, MPC52xx_PSC_OP_RTS);\n\telse\n\t\tout_8(&PSC(port)->op0, MPC52xx_PSC_OP_RTS);\n}\n\nstatic void mpc52xx_psc_enable_ms(struct uart_port *port)\n{\n\tstruct mpc52xx_psc __iomem *psc = PSC(port);\n\n\t \n\tin_8(&psc->mpc52xx_psc_ipcr);\n\t \n\tout_8(&psc->mpc52xx_psc_acr, MPC52xx_PSC_IEC_CTS | MPC52xx_PSC_IEC_DCD);\n\n\tport->read_status_mask |= MPC52xx_PSC_IMR_IPC;\n\tout_be16(&psc->mpc52xx_psc_imr, port->read_status_mask);\n}\n\nstatic void mpc52xx_psc_set_sicr(struct uart_port *port, u32 val)\n{\n\tout_be32(&PSC(port)->sicr, val);\n}\n\nstatic void mpc52xx_psc_set_imr(struct uart_port *port, u16 val)\n{\n\tout_be16(&PSC(port)->mpc52xx_psc_imr, val);\n}\n\nstatic u8 mpc52xx_psc_get_mr1(struct uart_port *port)\n{\n\tout_8(&PSC(port)->command, MPC52xx_PSC_SEL_MODE_REG_1);\n\treturn in_8(&PSC(port)->mode);\n}\n\n#ifdef CONFIG_PPC_MPC52xx\n#define FIFO_52xx(port) ((struct mpc52xx_psc_fifo __iomem *)(PSC(port)+1))\nstatic void mpc52xx_psc_fifo_init(struct uart_port *port)\n{\n\tstruct mpc52xx_psc __iomem *psc = PSC(port);\n\tstruct mpc52xx_psc_fifo __iomem *fifo = FIFO_52xx(port);\n\n\tout_8(&fifo->rfcntl, 0x00);\n\tout_be16(&fifo->rfalarm, 0x1ff);\n\tout_8(&fifo->tfcntl, 0x07);\n\tout_be16(&fifo->tfalarm, 0x80);\n\n\tport->read_status_mask |= MPC52xx_PSC_IMR_RXRDY | MPC52xx_PSC_IMR_TXRDY;\n\tout_be16(&psc->mpc52xx_psc_imr, port->read_status_mask);\n}\n\nstatic unsigned int mpc52xx_psc_raw_rx_rdy(struct uart_port *port)\n{\n\treturn in_be16(&PSC(port)->mpc52xx_psc_status)\n\t    & MPC52xx_PSC_SR_RXRDY;\n}\n\nstatic unsigned int mpc52xx_psc_raw_tx_rdy(struct uart_port *port)\n{\n\treturn in_be16(&PSC(port)->mpc52xx_psc_status)\n\t    & MPC52xx_PSC_SR_TXRDY;\n}\n\n\nstatic unsigned int mpc52xx_psc_rx_rdy(struct uart_port *port)\n{\n\treturn in_be16(&PSC(port)->mpc52xx_psc_isr)\n\t    & port->read_status_mask\n\t    & MPC52xx_PSC_IMR_RXRDY;\n}\n\nstatic unsigned int mpc52xx_psc_tx_rdy(struct uart_port *port)\n{\n\treturn in_be16(&PSC(port)->mpc52xx_psc_isr)\n\t    & port->read_status_mask\n\t    & MPC52xx_PSC_IMR_TXRDY;\n}\n\nstatic unsigned int mpc52xx_psc_tx_empty(struct uart_port *port)\n{\n\tu16 sts = in_be16(&PSC(port)->mpc52xx_psc_status);\n\n\treturn (sts & MPC52xx_PSC_SR_TXEMP) ? TIOCSER_TEMT : 0;\n}\n\nstatic void mpc52xx_psc_start_tx(struct uart_port *port)\n{\n\tport->read_status_mask |= MPC52xx_PSC_IMR_TXRDY;\n\tout_be16(&PSC(port)->mpc52xx_psc_imr, port->read_status_mask);\n}\n\nstatic void mpc52xx_psc_stop_tx(struct uart_port *port)\n{\n\tport->read_status_mask &= ~MPC52xx_PSC_IMR_TXRDY;\n\tout_be16(&PSC(port)->mpc52xx_psc_imr, port->read_status_mask);\n}\n\nstatic void mpc52xx_psc_stop_rx(struct uart_port *port)\n{\n\tport->read_status_mask &= ~MPC52xx_PSC_IMR_RXRDY;\n\tout_be16(&PSC(port)->mpc52xx_psc_imr, port->read_status_mask);\n}\n\nstatic void mpc52xx_psc_rx_clr_irq(struct uart_port *port)\n{\n}\n\nstatic void mpc52xx_psc_tx_clr_irq(struct uart_port *port)\n{\n}\n\nstatic void mpc52xx_psc_write_char(struct uart_port *port, unsigned char c)\n{\n\tout_8(&PSC(port)->mpc52xx_psc_buffer_8, c);\n}\n\nstatic unsigned char mpc52xx_psc_read_char(struct uart_port *port)\n{\n\treturn in_8(&PSC(port)->mpc52xx_psc_buffer_8);\n}\n\nstatic void mpc52xx_psc_cw_disable_ints(struct uart_port *port)\n{\n\tout_be16(&PSC(port)->mpc52xx_psc_imr, 0);\n}\n\nstatic void mpc52xx_psc_cw_restore_ints(struct uart_port *port)\n{\n\tout_be16(&PSC(port)->mpc52xx_psc_imr, port->read_status_mask);\n}\n\nstatic unsigned int mpc5200_psc_set_baudrate(struct uart_port *port,\n\t\t\t\t\t     struct ktermios *new,\n\t\t\t\t\t     const struct ktermios *old)\n{\n\tunsigned int baud;\n\tunsigned int divisor;\n\n\t \n\tbaud = uart_get_baud_rate(port, new, old,\n\t\t\t\t  port->uartclk / (32 * 0xffff) + 1,\n\t\t\t\t  port->uartclk / 32);\n\tdivisor = (port->uartclk + 16 * baud) / (32 * baud);\n\n\t \n\tmpc52xx_set_divisor(PSC(port), 0xdd00, divisor);\n\treturn baud;\n}\n\nstatic unsigned int mpc5200b_psc_set_baudrate(struct uart_port *port,\n\t\t\t\t\t      struct ktermios *new,\n\t\t\t\t\t      const struct ktermios *old)\n{\n\tunsigned int baud;\n\tunsigned int divisor;\n\tu16 prescaler;\n\n\t \n\tbaud = uart_get_baud_rate(port, new, old,\n\t\t\t\t  port->uartclk / (32 * 0xffff) + 1,\n\t\t\t\t  port->uartclk / 4);\n\tdivisor = (port->uartclk + 2 * baud) / (4 * baud);\n\n\t \n\tif (divisor > 0xffff || baud <= 115200) {\n\t\tdivisor = (divisor + 4) / 8;\n\t\tprescaler = 0xdd00;  \n\t} else\n\t\tprescaler = 0xff00;  \n\tmpc52xx_set_divisor(PSC(port), prescaler, divisor);\n\treturn baud;\n}\n\nstatic void mpc52xx_psc_get_irq(struct uart_port *port, struct device_node *np)\n{\n\tport->irqflags = 0;\n\tport->irq = irq_of_parse_and_map(np, 0);\n}\n\n \nstatic irqreturn_t mpc52xx_psc_handle_irq(struct uart_port *port)\n{\n\treturn mpc5xxx_uart_process_int(port);\n}\n\nstatic const struct psc_ops mpc52xx_psc_ops = {\n\t.fifo_init = mpc52xx_psc_fifo_init,\n\t.raw_rx_rdy = mpc52xx_psc_raw_rx_rdy,\n\t.raw_tx_rdy = mpc52xx_psc_raw_tx_rdy,\n\t.rx_rdy = mpc52xx_psc_rx_rdy,\n\t.tx_rdy = mpc52xx_psc_tx_rdy,\n\t.tx_empty = mpc52xx_psc_tx_empty,\n\t.stop_rx = mpc52xx_psc_stop_rx,\n\t.start_tx = mpc52xx_psc_start_tx,\n\t.stop_tx = mpc52xx_psc_stop_tx,\n\t.rx_clr_irq = mpc52xx_psc_rx_clr_irq,\n\t.tx_clr_irq = mpc52xx_psc_tx_clr_irq,\n\t.write_char = mpc52xx_psc_write_char,\n\t.read_char = mpc52xx_psc_read_char,\n\t.cw_disable_ints = mpc52xx_psc_cw_disable_ints,\n\t.cw_restore_ints = mpc52xx_psc_cw_restore_ints,\n\t.set_baudrate = mpc5200_psc_set_baudrate,\n\t.get_irq = mpc52xx_psc_get_irq,\n\t.handle_irq = mpc52xx_psc_handle_irq,\n\t.get_status = mpc52xx_psc_get_status,\n\t.get_ipcr = mpc52xx_psc_get_ipcr,\n\t.command = mpc52xx_psc_command,\n\t.set_mode = mpc52xx_psc_set_mode,\n\t.set_rts = mpc52xx_psc_set_rts,\n\t.enable_ms = mpc52xx_psc_enable_ms,\n\t.set_sicr = mpc52xx_psc_set_sicr,\n\t.set_imr = mpc52xx_psc_set_imr,\n\t.get_mr1 = mpc52xx_psc_get_mr1,\n};\n\nstatic const struct psc_ops mpc5200b_psc_ops = {\n\t.fifo_init = mpc52xx_psc_fifo_init,\n\t.raw_rx_rdy = mpc52xx_psc_raw_rx_rdy,\n\t.raw_tx_rdy = mpc52xx_psc_raw_tx_rdy,\n\t.rx_rdy = mpc52xx_psc_rx_rdy,\n\t.tx_rdy = mpc52xx_psc_tx_rdy,\n\t.tx_empty = mpc52xx_psc_tx_empty,\n\t.stop_rx = mpc52xx_psc_stop_rx,\n\t.start_tx = mpc52xx_psc_start_tx,\n\t.stop_tx = mpc52xx_psc_stop_tx,\n\t.rx_clr_irq = mpc52xx_psc_rx_clr_irq,\n\t.tx_clr_irq = mpc52xx_psc_tx_clr_irq,\n\t.write_char = mpc52xx_psc_write_char,\n\t.read_char = mpc52xx_psc_read_char,\n\t.cw_disable_ints = mpc52xx_psc_cw_disable_ints,\n\t.cw_restore_ints = mpc52xx_psc_cw_restore_ints,\n\t.set_baudrate = mpc5200b_psc_set_baudrate,\n\t.get_irq = mpc52xx_psc_get_irq,\n\t.handle_irq = mpc52xx_psc_handle_irq,\n\t.get_status = mpc52xx_psc_get_status,\n\t.get_ipcr = mpc52xx_psc_get_ipcr,\n\t.command = mpc52xx_psc_command,\n\t.set_mode = mpc52xx_psc_set_mode,\n\t.set_rts = mpc52xx_psc_set_rts,\n\t.enable_ms = mpc52xx_psc_enable_ms,\n\t.set_sicr = mpc52xx_psc_set_sicr,\n\t.set_imr = mpc52xx_psc_set_imr,\n\t.get_mr1 = mpc52xx_psc_get_mr1,\n};\n\n#endif  \n\n#ifdef CONFIG_PPC_MPC512x\n#define FIFO_512x(port) ((struct mpc512x_psc_fifo __iomem *)(PSC(port)+1))\n\n \nstruct psc_fifoc {\n\tu32 fifoc_cmd;\n\tu32 fifoc_int;\n\tu32 fifoc_dma;\n\tu32 fifoc_axe;\n\tu32 fifoc_debug;\n};\n\nstatic struct psc_fifoc __iomem *psc_fifoc;\nstatic unsigned int psc_fifoc_irq;\nstatic struct clk *psc_fifoc_clk;\n\nstatic void mpc512x_psc_fifo_init(struct uart_port *port)\n{\n\t \n\tout_be16(&PSC(port)->mpc52xx_psc_clock_select, 0xdd00);\n\n\tout_be32(&FIFO_512x(port)->txcmd, MPC512x_PSC_FIFO_RESET_SLICE);\n\tout_be32(&FIFO_512x(port)->txcmd, MPC512x_PSC_FIFO_ENABLE_SLICE);\n\tout_be32(&FIFO_512x(port)->txalarm, 1);\n\tout_be32(&FIFO_512x(port)->tximr, 0);\n\n\tout_be32(&FIFO_512x(port)->rxcmd, MPC512x_PSC_FIFO_RESET_SLICE);\n\tout_be32(&FIFO_512x(port)->rxcmd, MPC512x_PSC_FIFO_ENABLE_SLICE);\n\tout_be32(&FIFO_512x(port)->rxalarm, 1);\n\tout_be32(&FIFO_512x(port)->rximr, 0);\n\n\tout_be32(&FIFO_512x(port)->tximr, MPC512x_PSC_FIFO_ALARM);\n\tout_be32(&FIFO_512x(port)->rximr, MPC512x_PSC_FIFO_ALARM);\n}\n\nstatic unsigned int mpc512x_psc_raw_rx_rdy(struct uart_port *port)\n{\n\treturn !(in_be32(&FIFO_512x(port)->rxsr) & MPC512x_PSC_FIFO_EMPTY);\n}\n\nstatic unsigned int mpc512x_psc_raw_tx_rdy(struct uart_port *port)\n{\n\treturn !(in_be32(&FIFO_512x(port)->txsr) & MPC512x_PSC_FIFO_FULL);\n}\n\nstatic unsigned int mpc512x_psc_rx_rdy(struct uart_port *port)\n{\n\treturn in_be32(&FIFO_512x(port)->rxsr)\n\t    & in_be32(&FIFO_512x(port)->rximr)\n\t    & MPC512x_PSC_FIFO_ALARM;\n}\n\nstatic unsigned int mpc512x_psc_tx_rdy(struct uart_port *port)\n{\n\treturn in_be32(&FIFO_512x(port)->txsr)\n\t    & in_be32(&FIFO_512x(port)->tximr)\n\t    & MPC512x_PSC_FIFO_ALARM;\n}\n\nstatic unsigned int mpc512x_psc_tx_empty(struct uart_port *port)\n{\n\treturn in_be32(&FIFO_512x(port)->txsr)\n\t    & MPC512x_PSC_FIFO_EMPTY;\n}\n\nstatic void mpc512x_psc_stop_rx(struct uart_port *port)\n{\n\tunsigned long rx_fifo_imr;\n\n\trx_fifo_imr = in_be32(&FIFO_512x(port)->rximr);\n\trx_fifo_imr &= ~MPC512x_PSC_FIFO_ALARM;\n\tout_be32(&FIFO_512x(port)->rximr, rx_fifo_imr);\n}\n\nstatic void mpc512x_psc_start_tx(struct uart_port *port)\n{\n\tunsigned long tx_fifo_imr;\n\n\ttx_fifo_imr = in_be32(&FIFO_512x(port)->tximr);\n\ttx_fifo_imr |= MPC512x_PSC_FIFO_ALARM;\n\tout_be32(&FIFO_512x(port)->tximr, tx_fifo_imr);\n}\n\nstatic void mpc512x_psc_stop_tx(struct uart_port *port)\n{\n\tunsigned long tx_fifo_imr;\n\n\ttx_fifo_imr = in_be32(&FIFO_512x(port)->tximr);\n\ttx_fifo_imr &= ~MPC512x_PSC_FIFO_ALARM;\n\tout_be32(&FIFO_512x(port)->tximr, tx_fifo_imr);\n}\n\nstatic void mpc512x_psc_rx_clr_irq(struct uart_port *port)\n{\n\tout_be32(&FIFO_512x(port)->rxisr, in_be32(&FIFO_512x(port)->rxisr));\n}\n\nstatic void mpc512x_psc_tx_clr_irq(struct uart_port *port)\n{\n\tout_be32(&FIFO_512x(port)->txisr, in_be32(&FIFO_512x(port)->txisr));\n}\n\nstatic void mpc512x_psc_write_char(struct uart_port *port, unsigned char c)\n{\n\tout_8(&FIFO_512x(port)->txdata_8, c);\n}\n\nstatic unsigned char mpc512x_psc_read_char(struct uart_port *port)\n{\n\treturn in_8(&FIFO_512x(port)->rxdata_8);\n}\n\nstatic void mpc512x_psc_cw_disable_ints(struct uart_port *port)\n{\n\tport->read_status_mask =\n\t\tin_be32(&FIFO_512x(port)->tximr) << 16 |\n\t\tin_be32(&FIFO_512x(port)->rximr);\n\tout_be32(&FIFO_512x(port)->tximr, 0);\n\tout_be32(&FIFO_512x(port)->rximr, 0);\n}\n\nstatic void mpc512x_psc_cw_restore_ints(struct uart_port *port)\n{\n\tout_be32(&FIFO_512x(port)->tximr,\n\t\t(port->read_status_mask >> 16) & 0x7f);\n\tout_be32(&FIFO_512x(port)->rximr, port->read_status_mask & 0x7f);\n}\n\nstatic unsigned int mpc512x_psc_set_baudrate(struct uart_port *port,\n\t\t\t\t\t     struct ktermios *new,\n\t\t\t\t\t     const struct ktermios *old)\n{\n\tunsigned int baud;\n\tunsigned int divisor;\n\n\t \n\n\t \n\tbaud = uart_get_baud_rate(port, new, old,\n\t\t\t\t  port->uartclk / (16 * 0xffff) + 1,\n\t\t\t\t  port->uartclk / 16);\n\tdivisor = (port->uartclk + 8 * baud) / (16 * baud);\n\n\t \n\tmpc52xx_set_divisor(PSC(port), 0xdd00, divisor);\n\treturn baud;\n}\n\n \nstatic int __init mpc512x_psc_fifoc_init(void)\n{\n\tint err;\n\tstruct device_node *np;\n\tstruct clk *clk;\n\n\t \n\terr = -ENODEV;\n\n\tnp = of_find_compatible_node(NULL, NULL,\n\t\t\t\t     \"fsl,mpc5121-psc-fifo\");\n\tif (!np) {\n\t\tpr_err(\"%s: Can't find FIFOC node\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\n\tclk = of_clk_get(np, 0);\n\tif (IS_ERR(clk)) {\n\t\t \n\t\tclk = clk_get_sys(np->name, \"ipg\");\n\t}\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: Can't lookup FIFO clock\\n\", __func__);\n\t\terr = PTR_ERR(clk);\n\t\tgoto out_ofnode_put;\n\t}\n\tif (clk_prepare_enable(clk)) {\n\t\tpr_err(\"%s: Can't enable FIFO clock\\n\", __func__);\n\t\tclk_put(clk);\n\t\tgoto out_ofnode_put;\n\t}\n\tpsc_fifoc_clk = clk;\n\n\tpsc_fifoc = of_iomap(np, 0);\n\tif (!psc_fifoc) {\n\t\tpr_err(\"%s: Can't map FIFOC\\n\", __func__);\n\t\tgoto out_clk_disable;\n\t}\n\n\tpsc_fifoc_irq = irq_of_parse_and_map(np, 0);\n\tif (psc_fifoc_irq == 0) {\n\t\tpr_err(\"%s: Can't get FIFOC irq\\n\", __func__);\n\t\tgoto out_unmap;\n\t}\n\n\tof_node_put(np);\n\treturn 0;\n\nout_unmap:\n\tiounmap(psc_fifoc);\nout_clk_disable:\n\tclk_disable_unprepare(psc_fifoc_clk);\n\tclk_put(psc_fifoc_clk);\nout_ofnode_put:\n\tof_node_put(np);\nout_err:\n\treturn err;\n}\n\nstatic void __exit mpc512x_psc_fifoc_uninit(void)\n{\n\tiounmap(psc_fifoc);\n\n\t \n\tif (psc_fifoc_clk) {\n\t\tclk_disable_unprepare(psc_fifoc_clk);\n\t\tclk_put(psc_fifoc_clk);\n\t\tpsc_fifoc_clk = NULL;\n\t}\n}\n\n \nstatic irqreturn_t mpc512x_psc_handle_irq(struct uart_port *port)\n{\n\tunsigned long fifoc_int;\n\tint psc_num;\n\n\t \n\tfifoc_int = in_be32(&psc_fifoc->fifoc_int);\n\n\t \n\tpsc_num = (port->mapbase & 0xf00) >> 8;\n\tif (test_bit(psc_num, &fifoc_int) ||\n\t    test_bit(psc_num + 16, &fifoc_int))\n\t\treturn mpc5xxx_uart_process_int(port);\n\n\treturn IRQ_NONE;\n}\n\nstatic struct clk *psc_mclk_clk[MPC52xx_PSC_MAXNUM];\nstatic struct clk *psc_ipg_clk[MPC52xx_PSC_MAXNUM];\n\n \nstatic int mpc512x_psc_alloc_clock(struct uart_port *port)\n{\n\tint psc_num;\n\tstruct clk *clk;\n\tint err;\n\n\tpsc_num = (port->mapbase & 0xf00) >> 8;\n\n\tclk = devm_clk_get(port->dev, \"mclk\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(port->dev, \"Failed to get MCLK!\\n\");\n\t\terr = PTR_ERR(clk);\n\t\tgoto out_err;\n\t}\n\terr = clk_prepare_enable(clk);\n\tif (err) {\n\t\tdev_err(port->dev, \"Failed to enable MCLK!\\n\");\n\t\tgoto out_err;\n\t}\n\tpsc_mclk_clk[psc_num] = clk;\n\n\tclk = devm_clk_get(port->dev, \"ipg\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(port->dev, \"Failed to get IPG clock!\\n\");\n\t\terr = PTR_ERR(clk);\n\t\tgoto out_err;\n\t}\n\terr = clk_prepare_enable(clk);\n\tif (err) {\n\t\tdev_err(port->dev, \"Failed to enable IPG clock!\\n\");\n\t\tgoto out_err;\n\t}\n\tpsc_ipg_clk[psc_num] = clk;\n\n\treturn 0;\n\nout_err:\n\tif (psc_mclk_clk[psc_num]) {\n\t\tclk_disable_unprepare(psc_mclk_clk[psc_num]);\n\t\tpsc_mclk_clk[psc_num] = NULL;\n\t}\n\tif (psc_ipg_clk[psc_num]) {\n\t\tclk_disable_unprepare(psc_ipg_clk[psc_num]);\n\t\tpsc_ipg_clk[psc_num] = NULL;\n\t}\n\treturn err;\n}\n\n \nstatic void mpc512x_psc_relse_clock(struct uart_port *port)\n{\n\tint psc_num;\n\tstruct clk *clk;\n\n\tpsc_num = (port->mapbase & 0xf00) >> 8;\n\tclk = psc_mclk_clk[psc_num];\n\tif (clk) {\n\t\tclk_disable_unprepare(clk);\n\t\tpsc_mclk_clk[psc_num] = NULL;\n\t}\n\tif (psc_ipg_clk[psc_num]) {\n\t\tclk_disable_unprepare(psc_ipg_clk[psc_num]);\n\t\tpsc_ipg_clk[psc_num] = NULL;\n\t}\n}\n\n \nstatic int mpc512x_psc_endis_clock(struct uart_port *port, int enable)\n{\n\tint psc_num;\n\tstruct clk *psc_clk;\n\tint ret;\n\n\tif (uart_console(port))\n\t\treturn 0;\n\n\tpsc_num = (port->mapbase & 0xf00) >> 8;\n\tpsc_clk = psc_mclk_clk[psc_num];\n\tif (!psc_clk) {\n\t\tdev_err(port->dev, \"Failed to get PSC clock entry!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(port->dev, \"mclk %sable\\n\", enable ? \"en\" : \"dis\");\n\tif (enable) {\n\t\tret = clk_enable(psc_clk);\n\t\tif (ret)\n\t\t\tdev_err(port->dev, \"Failed to enable MCLK!\\n\");\n\t\treturn ret;\n\t} else {\n\t\tclk_disable(psc_clk);\n\t\treturn 0;\n\t}\n}\n\nstatic void mpc512x_psc_get_irq(struct uart_port *port, struct device_node *np)\n{\n\tport->irqflags = IRQF_SHARED;\n\tport->irq = psc_fifoc_irq;\n}\n\n#define PSC_5125(port) ((struct mpc5125_psc __iomem *)((port)->membase))\n#define FIFO_5125(port) ((struct mpc512x_psc_fifo __iomem *)(PSC_5125(port)+1))\n\nstatic void mpc5125_psc_fifo_init(struct uart_port *port)\n{\n\t \n\tout_8(&PSC_5125(port)->mpc52xx_psc_clock_select, 0xdd);\n\n\tout_be32(&FIFO_5125(port)->txcmd, MPC512x_PSC_FIFO_RESET_SLICE);\n\tout_be32(&FIFO_5125(port)->txcmd, MPC512x_PSC_FIFO_ENABLE_SLICE);\n\tout_be32(&FIFO_5125(port)->txalarm, 1);\n\tout_be32(&FIFO_5125(port)->tximr, 0);\n\n\tout_be32(&FIFO_5125(port)->rxcmd, MPC512x_PSC_FIFO_RESET_SLICE);\n\tout_be32(&FIFO_5125(port)->rxcmd, MPC512x_PSC_FIFO_ENABLE_SLICE);\n\tout_be32(&FIFO_5125(port)->rxalarm, 1);\n\tout_be32(&FIFO_5125(port)->rximr, 0);\n\n\tout_be32(&FIFO_5125(port)->tximr, MPC512x_PSC_FIFO_ALARM);\n\tout_be32(&FIFO_5125(port)->rximr, MPC512x_PSC_FIFO_ALARM);\n}\n\nstatic unsigned int mpc5125_psc_raw_rx_rdy(struct uart_port *port)\n{\n\treturn !(in_be32(&FIFO_5125(port)->rxsr) & MPC512x_PSC_FIFO_EMPTY);\n}\n\nstatic unsigned int mpc5125_psc_raw_tx_rdy(struct uart_port *port)\n{\n\treturn !(in_be32(&FIFO_5125(port)->txsr) & MPC512x_PSC_FIFO_FULL);\n}\n\nstatic unsigned int mpc5125_psc_rx_rdy(struct uart_port *port)\n{\n\treturn in_be32(&FIFO_5125(port)->rxsr) &\n\t       in_be32(&FIFO_5125(port)->rximr) & MPC512x_PSC_FIFO_ALARM;\n}\n\nstatic unsigned int mpc5125_psc_tx_rdy(struct uart_port *port)\n{\n\treturn in_be32(&FIFO_5125(port)->txsr) &\n\t       in_be32(&FIFO_5125(port)->tximr) & MPC512x_PSC_FIFO_ALARM;\n}\n\nstatic unsigned int mpc5125_psc_tx_empty(struct uart_port *port)\n{\n\treturn in_be32(&FIFO_5125(port)->txsr) & MPC512x_PSC_FIFO_EMPTY;\n}\n\nstatic void mpc5125_psc_stop_rx(struct uart_port *port)\n{\n\tunsigned long rx_fifo_imr;\n\n\trx_fifo_imr = in_be32(&FIFO_5125(port)->rximr);\n\trx_fifo_imr &= ~MPC512x_PSC_FIFO_ALARM;\n\tout_be32(&FIFO_5125(port)->rximr, rx_fifo_imr);\n}\n\nstatic void mpc5125_psc_start_tx(struct uart_port *port)\n{\n\tunsigned long tx_fifo_imr;\n\n\ttx_fifo_imr = in_be32(&FIFO_5125(port)->tximr);\n\ttx_fifo_imr |= MPC512x_PSC_FIFO_ALARM;\n\tout_be32(&FIFO_5125(port)->tximr, tx_fifo_imr);\n}\n\nstatic void mpc5125_psc_stop_tx(struct uart_port *port)\n{\n\tunsigned long tx_fifo_imr;\n\n\ttx_fifo_imr = in_be32(&FIFO_5125(port)->tximr);\n\ttx_fifo_imr &= ~MPC512x_PSC_FIFO_ALARM;\n\tout_be32(&FIFO_5125(port)->tximr, tx_fifo_imr);\n}\n\nstatic void mpc5125_psc_rx_clr_irq(struct uart_port *port)\n{\n\tout_be32(&FIFO_5125(port)->rxisr, in_be32(&FIFO_5125(port)->rxisr));\n}\n\nstatic void mpc5125_psc_tx_clr_irq(struct uart_port *port)\n{\n\tout_be32(&FIFO_5125(port)->txisr, in_be32(&FIFO_5125(port)->txisr));\n}\n\nstatic void mpc5125_psc_write_char(struct uart_port *port, unsigned char c)\n{\n\tout_8(&FIFO_5125(port)->txdata_8, c);\n}\n\nstatic unsigned char mpc5125_psc_read_char(struct uart_port *port)\n{\n\treturn in_8(&FIFO_5125(port)->rxdata_8);\n}\n\nstatic void mpc5125_psc_cw_disable_ints(struct uart_port *port)\n{\n\tport->read_status_mask =\n\t\tin_be32(&FIFO_5125(port)->tximr) << 16 |\n\t\tin_be32(&FIFO_5125(port)->rximr);\n\tout_be32(&FIFO_5125(port)->tximr, 0);\n\tout_be32(&FIFO_5125(port)->rximr, 0);\n}\n\nstatic void mpc5125_psc_cw_restore_ints(struct uart_port *port)\n{\n\tout_be32(&FIFO_5125(port)->tximr,\n\t\t(port->read_status_mask >> 16) & 0x7f);\n\tout_be32(&FIFO_5125(port)->rximr, port->read_status_mask & 0x7f);\n}\n\nstatic inline void mpc5125_set_divisor(struct mpc5125_psc __iomem *psc,\n\t\tu8 prescaler, unsigned int divisor)\n{\n\t \n\tout_8(&psc->mpc52xx_psc_clock_select, prescaler);\n\tout_8(&psc->ctur, divisor >> 8);\n\tout_8(&psc->ctlr, divisor & 0xff);\n}\n\nstatic unsigned int mpc5125_psc_set_baudrate(struct uart_port *port,\n\t\t\t\t\t     struct ktermios *new,\n\t\t\t\t\t     const struct ktermios *old)\n{\n\tunsigned int baud;\n\tunsigned int divisor;\n\n\t \n\n\t \n\tbaud = uart_get_baud_rate(port, new, old,\n\t\t\t\t  port->uartclk / (16 * 0xffff) + 1,\n\t\t\t\t  port->uartclk / 16);\n\tdivisor = (port->uartclk + 8 * baud) / (16 * baud);\n\n\t \n\tmpc5125_set_divisor(PSC_5125(port), 0xdd, divisor);\n\treturn baud;\n}\n\n \nstatic u16 mpc5125_psc_get_status(struct uart_port *port)\n{\n\treturn in_be16(&PSC_5125(port)->mpc52xx_psc_status);\n}\n\nstatic u8 mpc5125_psc_get_ipcr(struct uart_port *port)\n{\n\treturn in_8(&PSC_5125(port)->mpc52xx_psc_ipcr);\n}\n\nstatic void mpc5125_psc_command(struct uart_port *port, u8 cmd)\n{\n\tout_8(&PSC_5125(port)->command, cmd);\n}\n\nstatic void mpc5125_psc_set_mode(struct uart_port *port, u8 mr1, u8 mr2)\n{\n\tout_8(&PSC_5125(port)->mr1, mr1);\n\tout_8(&PSC_5125(port)->mr2, mr2);\n}\n\nstatic void mpc5125_psc_set_rts(struct uart_port *port, int state)\n{\n\tif (state & TIOCM_RTS)\n\t\tout_8(&PSC_5125(port)->op1, MPC52xx_PSC_OP_RTS);\n\telse\n\t\tout_8(&PSC_5125(port)->op0, MPC52xx_PSC_OP_RTS);\n}\n\nstatic void mpc5125_psc_enable_ms(struct uart_port *port)\n{\n\tstruct mpc5125_psc __iomem *psc = PSC_5125(port);\n\n\t \n\tin_8(&psc->mpc52xx_psc_ipcr);\n\t \n\tout_8(&psc->mpc52xx_psc_acr, MPC52xx_PSC_IEC_CTS | MPC52xx_PSC_IEC_DCD);\n\n\tport->read_status_mask |= MPC52xx_PSC_IMR_IPC;\n\tout_be16(&psc->mpc52xx_psc_imr, port->read_status_mask);\n}\n\nstatic void mpc5125_psc_set_sicr(struct uart_port *port, u32 val)\n{\n\tout_be32(&PSC_5125(port)->sicr, val);\n}\n\nstatic void mpc5125_psc_set_imr(struct uart_port *port, u16 val)\n{\n\tout_be16(&PSC_5125(port)->mpc52xx_psc_imr, val);\n}\n\nstatic u8 mpc5125_psc_get_mr1(struct uart_port *port)\n{\n\treturn in_8(&PSC_5125(port)->mr1);\n}\n\nstatic const struct psc_ops mpc5125_psc_ops = {\n\t.fifo_init = mpc5125_psc_fifo_init,\n\t.raw_rx_rdy = mpc5125_psc_raw_rx_rdy,\n\t.raw_tx_rdy = mpc5125_psc_raw_tx_rdy,\n\t.rx_rdy = mpc5125_psc_rx_rdy,\n\t.tx_rdy = mpc5125_psc_tx_rdy,\n\t.tx_empty = mpc5125_psc_tx_empty,\n\t.stop_rx = mpc5125_psc_stop_rx,\n\t.start_tx = mpc5125_psc_start_tx,\n\t.stop_tx = mpc5125_psc_stop_tx,\n\t.rx_clr_irq = mpc5125_psc_rx_clr_irq,\n\t.tx_clr_irq = mpc5125_psc_tx_clr_irq,\n\t.write_char = mpc5125_psc_write_char,\n\t.read_char = mpc5125_psc_read_char,\n\t.cw_disable_ints = mpc5125_psc_cw_disable_ints,\n\t.cw_restore_ints = mpc5125_psc_cw_restore_ints,\n\t.set_baudrate = mpc5125_psc_set_baudrate,\n\t.clock_alloc = mpc512x_psc_alloc_clock,\n\t.clock_relse = mpc512x_psc_relse_clock,\n\t.clock = mpc512x_psc_endis_clock,\n\t.fifoc_init = mpc512x_psc_fifoc_init,\n\t.fifoc_uninit = mpc512x_psc_fifoc_uninit,\n\t.get_irq = mpc512x_psc_get_irq,\n\t.handle_irq = mpc512x_psc_handle_irq,\n\t.get_status = mpc5125_psc_get_status,\n\t.get_ipcr = mpc5125_psc_get_ipcr,\n\t.command = mpc5125_psc_command,\n\t.set_mode = mpc5125_psc_set_mode,\n\t.set_rts = mpc5125_psc_set_rts,\n\t.enable_ms = mpc5125_psc_enable_ms,\n\t.set_sicr = mpc5125_psc_set_sicr,\n\t.set_imr = mpc5125_psc_set_imr,\n\t.get_mr1 = mpc5125_psc_get_mr1,\n};\n\nstatic const struct psc_ops mpc512x_psc_ops = {\n\t.fifo_init = mpc512x_psc_fifo_init,\n\t.raw_rx_rdy = mpc512x_psc_raw_rx_rdy,\n\t.raw_tx_rdy = mpc512x_psc_raw_tx_rdy,\n\t.rx_rdy = mpc512x_psc_rx_rdy,\n\t.tx_rdy = mpc512x_psc_tx_rdy,\n\t.tx_empty = mpc512x_psc_tx_empty,\n\t.stop_rx = mpc512x_psc_stop_rx,\n\t.start_tx = mpc512x_psc_start_tx,\n\t.stop_tx = mpc512x_psc_stop_tx,\n\t.rx_clr_irq = mpc512x_psc_rx_clr_irq,\n\t.tx_clr_irq = mpc512x_psc_tx_clr_irq,\n\t.write_char = mpc512x_psc_write_char,\n\t.read_char = mpc512x_psc_read_char,\n\t.cw_disable_ints = mpc512x_psc_cw_disable_ints,\n\t.cw_restore_ints = mpc512x_psc_cw_restore_ints,\n\t.set_baudrate = mpc512x_psc_set_baudrate,\n\t.clock_alloc = mpc512x_psc_alloc_clock,\n\t.clock_relse = mpc512x_psc_relse_clock,\n\t.clock = mpc512x_psc_endis_clock,\n\t.fifoc_init = mpc512x_psc_fifoc_init,\n\t.fifoc_uninit = mpc512x_psc_fifoc_uninit,\n\t.get_irq = mpc512x_psc_get_irq,\n\t.handle_irq = mpc512x_psc_handle_irq,\n\t.get_status = mpc52xx_psc_get_status,\n\t.get_ipcr = mpc52xx_psc_get_ipcr,\n\t.command = mpc52xx_psc_command,\n\t.set_mode = mpc52xx_psc_set_mode,\n\t.set_rts = mpc52xx_psc_set_rts,\n\t.enable_ms = mpc52xx_psc_enable_ms,\n\t.set_sicr = mpc52xx_psc_set_sicr,\n\t.set_imr = mpc52xx_psc_set_imr,\n\t.get_mr1 = mpc52xx_psc_get_mr1,\n};\n#endif  \n\n\nstatic const struct psc_ops *psc_ops;\n\n \n \n \n\nstatic unsigned int\nmpc52xx_uart_tx_empty(struct uart_port *port)\n{\n\treturn psc_ops->tx_empty(port) ? TIOCSER_TEMT : 0;\n}\n\nstatic void\nmpc52xx_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tpsc_ops->set_rts(port, mctrl & TIOCM_RTS);\n}\n\nstatic unsigned int\nmpc52xx_uart_get_mctrl(struct uart_port *port)\n{\n\tunsigned int ret = TIOCM_DSR;\n\tu8 status = psc_ops->get_ipcr(port);\n\n\tif (!(status & MPC52xx_PSC_CTS))\n\t\tret |= TIOCM_CTS;\n\tif (!(status & MPC52xx_PSC_DCD))\n\t\tret |= TIOCM_CAR;\n\n\treturn ret;\n}\n\nstatic void\nmpc52xx_uart_stop_tx(struct uart_port *port)\n{\n\t \n\tpsc_ops->stop_tx(port);\n}\n\nstatic void\nmpc52xx_uart_start_tx(struct uart_port *port)\n{\n\t \n\tpsc_ops->start_tx(port);\n}\n\nstatic void\nmpc52xx_uart_stop_rx(struct uart_port *port)\n{\n\t \n\tpsc_ops->stop_rx(port);\n}\n\nstatic void\nmpc52xx_uart_enable_ms(struct uart_port *port)\n{\n\tpsc_ops->enable_ms(port);\n}\n\nstatic void\nmpc52xx_uart_break_ctl(struct uart_port *port, int ctl)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (ctl == -1)\n\t\tpsc_ops->command(port, MPC52xx_PSC_START_BRK);\n\telse\n\t\tpsc_ops->command(port, MPC52xx_PSC_STOP_BRK);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int\nmpc52xx_uart_startup(struct uart_port *port)\n{\n\tint ret;\n\n\tif (psc_ops->clock) {\n\t\tret = psc_ops->clock(port, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = request_irq(port->irq, mpc52xx_uart_int,\n\t\t\t  port->irqflags, \"mpc52xx_psc_uart\", port);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpsc_ops->command(port, MPC52xx_PSC_RST_RX);\n\tpsc_ops->command(port, MPC52xx_PSC_RST_TX);\n\n\t \n\tmsleep(1);\n\n\tpsc_ops->set_sicr(port, 0);\t \n\n\tpsc_ops->fifo_init(port);\n\n\tpsc_ops->command(port, MPC52xx_PSC_TX_ENABLE);\n\tpsc_ops->command(port, MPC52xx_PSC_RX_ENABLE);\n\n\treturn 0;\n}\n\nstatic void\nmpc52xx_uart_shutdown(struct uart_port *port)\n{\n\t \n\tpsc_ops->command(port, MPC52xx_PSC_RST_RX);\n\tif (!uart_console(port))\n\t\tpsc_ops->command(port, MPC52xx_PSC_RST_TX);\n\n\tport->read_status_mask = 0;\n\tpsc_ops->set_imr(port, port->read_status_mask);\n\n\tif (psc_ops->clock)\n\t\tpsc_ops->clock(port, 0);\n\n\t \n\tpsc_ops->cw_disable_ints(port);\n\n\t \n\tfree_irq(port->irq, port);\n}\n\nstatic void\nmpc52xx_uart_set_termios(struct uart_port *port, struct ktermios *new,\n\t\t\t const struct ktermios *old)\n{\n\tunsigned long flags;\n\tunsigned char mr1, mr2;\n\tunsigned int j;\n\tunsigned int baud;\n\n\t \n\tmr1 = 0;\n\n\tswitch (new->c_cflag & CSIZE) {\n\tcase CS5:\tmr1 |= MPC52xx_PSC_MODE_5_BITS;\n\t\tbreak;\n\tcase CS6:\tmr1 |= MPC52xx_PSC_MODE_6_BITS;\n\t\tbreak;\n\tcase CS7:\tmr1 |= MPC52xx_PSC_MODE_7_BITS;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\tmr1 |= MPC52xx_PSC_MODE_8_BITS;\n\t}\n\n\tif (new->c_cflag & PARENB) {\n\t\tif (new->c_cflag & CMSPAR)\n\t\t\tmr1 |= MPC52xx_PSC_MODE_PARFORCE;\n\n\t\t \n\t\tmr1 |= (new->c_cflag & PARODD) ?\n\t\t\tMPC52xx_PSC_MODE_PARODD : MPC52xx_PSC_MODE_PAREVEN;\n\t} else {\n\t\tmr1 |= MPC52xx_PSC_MODE_PARNONE;\n\t}\n\n\tmr2 = 0;\n\n\tif (new->c_cflag & CSTOPB)\n\t\tmr2 |= MPC52xx_PSC_MODE_TWO_STOP;\n\telse\n\t\tmr2 |= ((new->c_cflag & CSIZE) == CS5) ?\n\t\t\tMPC52xx_PSC_MODE_ONE_STOP_5_BITS :\n\t\t\tMPC52xx_PSC_MODE_ONE_STOP;\n\n\tif (new->c_cflag & CRTSCTS) {\n\t\tmr1 |= MPC52xx_PSC_MODE_RXRTS;\n\t\tmr2 |= MPC52xx_PSC_MODE_TXCTS;\n\t}\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\t \n\tj = 5000000;\t \n\t \n\t \n\twhile (!mpc52xx_uart_tx_empty(port) && --j)\n\t\tudelay(1);\n\n\tif (!j)\n\t\tprintk(KERN_ERR \"mpc52xx_uart.c: \"\n\t\t\t\"Unable to flush RX & TX fifos in-time in set_termios.\"\n\t\t\t\"Some chars may have been lost.\\n\");\n\n\t \n\tpsc_ops->command(port, MPC52xx_PSC_RST_RX);\n\tpsc_ops->command(port, MPC52xx_PSC_RST_TX);\n\n\t \n\tpsc_ops->set_mode(port, mr1, mr2);\n\tbaud = psc_ops->set_baudrate(port, new, old);\n\n\t \n\tuart_update_timeout(port, new->c_cflag, baud);\n\n\tif (UART_ENABLE_MS(port, new->c_cflag))\n\t\tmpc52xx_uart_enable_ms(port);\n\n\t \n\tpsc_ops->command(port, MPC52xx_PSC_TX_ENABLE);\n\tpsc_ops->command(port, MPC52xx_PSC_RX_ENABLE);\n\n\t \n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *\nmpc52xx_uart_type(struct uart_port *port)\n{\n\t \n\treturn port->type == PORT_MPC52xx ? \"MPC5xxx PSC\" : NULL;\n}\n\nstatic void\nmpc52xx_uart_release_port(struct uart_port *port)\n{\n\tif (psc_ops->clock_relse)\n\t\tpsc_ops->clock_relse(port);\n\n\t \n\tif (port->flags & UPF_IOREMAP) {\n\t\tiounmap(port->membase);\n\t\tport->membase = NULL;\n\t}\n\n\trelease_mem_region(port->mapbase, sizeof(struct mpc52xx_psc));\n}\n\nstatic int\nmpc52xx_uart_request_port(struct uart_port *port)\n{\n\tint err;\n\n\tif (port->flags & UPF_IOREMAP)  \n\t\tport->membase = ioremap(port->mapbase,\n\t\t\t\t\tsizeof(struct mpc52xx_psc));\n\n\tif (!port->membase)\n\t\treturn -EINVAL;\n\n\terr = request_mem_region(port->mapbase, sizeof(struct mpc52xx_psc),\n\t\t\t\"mpc52xx_psc_uart\") != NULL ? 0 : -EBUSY;\n\n\tif (err)\n\t\tgoto out_membase;\n\n\tif (psc_ops->clock_alloc) {\n\t\terr = psc_ops->clock_alloc(port);\n\t\tif (err)\n\t\t\tgoto out_mapregion;\n\t}\n\n\treturn 0;\n\nout_mapregion:\n\trelease_mem_region(port->mapbase, sizeof(struct mpc52xx_psc));\nout_membase:\n\tif (port->flags & UPF_IOREMAP) {\n\t\tiounmap(port->membase);\n\t\tport->membase = NULL;\n\t}\n\treturn err;\n}\n\nstatic void\nmpc52xx_uart_config_port(struct uart_port *port, int flags)\n{\n\tif ((flags & UART_CONFIG_TYPE)\n\t\t&& (mpc52xx_uart_request_port(port) == 0))\n\t\tport->type = PORT_MPC52xx;\n}\n\nstatic int\nmpc52xx_uart_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_MPC52xx)\n\t\treturn -EINVAL;\n\n\tif ((ser->irq != port->irq) ||\n\t    (ser->io_type != UPIO_MEM) ||\n\t    (ser->baud_base != port->uartclk)  ||\n\t    (ser->iomem_base != (void *)port->mapbase) ||\n\t    (ser->hub6 != 0))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n\nstatic const struct uart_ops mpc52xx_uart_ops = {\n\t.tx_empty\t= mpc52xx_uart_tx_empty,\n\t.set_mctrl\t= mpc52xx_uart_set_mctrl,\n\t.get_mctrl\t= mpc52xx_uart_get_mctrl,\n\t.stop_tx\t= mpc52xx_uart_stop_tx,\n\t.start_tx\t= mpc52xx_uart_start_tx,\n\t.stop_rx\t= mpc52xx_uart_stop_rx,\n\t.enable_ms\t= mpc52xx_uart_enable_ms,\n\t.break_ctl\t= mpc52xx_uart_break_ctl,\n\t.startup\t= mpc52xx_uart_startup,\n\t.shutdown\t= mpc52xx_uart_shutdown,\n\t.set_termios\t= mpc52xx_uart_set_termios,\n \n\t.type\t\t= mpc52xx_uart_type,\n\t.release_port\t= mpc52xx_uart_release_port,\n\t.request_port\t= mpc52xx_uart_request_port,\n\t.config_port\t= mpc52xx_uart_config_port,\n\t.verify_port\t= mpc52xx_uart_verify_port\n};\n\n\n \n \n \n\nstatic inline bool\nmpc52xx_uart_int_rx_chars(struct uart_port *port)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned char ch, flag;\n\tunsigned short status;\n\n\t \n\twhile (psc_ops->raw_rx_rdy(port)) {\n\t\t \n\t\tch = psc_ops->read_char(port);\n\n\t\t \n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tcontinue;\n\n\t\t \n\n\t\tflag = TTY_NORMAL;\n\t\tport->icount.rx++;\n\n\t\tstatus = psc_ops->get_status(port);\n\n\t\tif (status & (MPC52xx_PSC_SR_PE |\n\t\t\t      MPC52xx_PSC_SR_FE |\n\t\t\t      MPC52xx_PSC_SR_RB)) {\n\n\t\t\tif (status & MPC52xx_PSC_SR_RB) {\n\t\t\t\tflag = TTY_BREAK;\n\t\t\t\tuart_handle_break(port);\n\t\t\t\tport->icount.brk++;\n\t\t\t} else if (status & MPC52xx_PSC_SR_PE) {\n\t\t\t\tflag = TTY_PARITY;\n\t\t\t\tport->icount.parity++;\n\t\t\t}\n\t\t\telse if (status & MPC52xx_PSC_SR_FE) {\n\t\t\t\tflag = TTY_FRAME;\n\t\t\t\tport->icount.frame++;\n\t\t\t}\n\n\t\t\t \n\t\t\tpsc_ops->command(port, MPC52xx_PSC_RST_ERR_STAT);\n\n\t\t}\n\t\ttty_insert_flip_char(tport, ch, flag);\n\t\tif (status & MPC52xx_PSC_SR_OE) {\n\t\t\t \n\t\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\t\t\tport->icount.overrun++;\n\t\t}\n\t}\n\n\ttty_flip_buffer_push(tport);\n\n\treturn psc_ops->raw_rx_rdy(port);\n}\n\nstatic inline bool\nmpc52xx_uart_int_tx_chars(struct uart_port *port)\n{\n\tu8 ch;\n\n\treturn uart_port_tx(port, ch,\n\t\tpsc_ops->raw_tx_rdy(port),\n\t\tpsc_ops->write_char(port, ch));\n}\n\nstatic irqreturn_t\nmpc5xxx_uart_process_int(struct uart_port *port)\n{\n\tunsigned long pass = ISR_PASS_LIMIT;\n\tbool keepgoing;\n\tu8 status;\n\n\t \n\tdo {\n\t\t \n\t\tkeepgoing = false;\n\n\t\tpsc_ops->rx_clr_irq(port);\n\t\tif (psc_ops->rx_rdy(port))\n\t\t\tkeepgoing |= mpc52xx_uart_int_rx_chars(port);\n\n\t\tpsc_ops->tx_clr_irq(port);\n\t\tif (psc_ops->tx_rdy(port))\n\t\t\tkeepgoing |= mpc52xx_uart_int_tx_chars(port);\n\n\t\tstatus = psc_ops->get_ipcr(port);\n\t\tif (status & MPC52xx_PSC_D_DCD)\n\t\t\tuart_handle_dcd_change(port, !(status & MPC52xx_PSC_DCD));\n\n\t\tif (status & MPC52xx_PSC_D_CTS)\n\t\t\tuart_handle_cts_change(port, !(status & MPC52xx_PSC_CTS));\n\n\t\t \n\t\tif (!(--pass))\n\t\t\tkeepgoing = false;\n\n\t} while (keepgoing);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\nmpc52xx_uart_int(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tirqreturn_t ret;\n\n\tspin_lock(&port->lock);\n\n\tret = psc_ops->handle_irq(port);\n\n\tspin_unlock(&port->lock);\n\n\treturn ret;\n}\n\n \n \n \n\n#ifdef CONFIG_SERIAL_MPC52xx_CONSOLE\n\nstatic void __init\nmpc52xx_console_get_options(struct uart_port *port,\n\t\t\t    int *baud, int *parity, int *bits, int *flow)\n{\n\tunsigned char mr1;\n\n\tpr_debug(\"mpc52xx_console_get_options(port=%p)\\n\", port);\n\n\t \n\tmr1 = psc_ops->get_mr1(port);\n\n\t \n\t*baud = CONFIG_SERIAL_MPC52xx_CONSOLE_BAUD;\n\n\t \n\tswitch (mr1 & MPC52xx_PSC_MODE_BITS_MASK) {\n\tcase MPC52xx_PSC_MODE_5_BITS:\n\t\t*bits = 5;\n\t\tbreak;\n\tcase MPC52xx_PSC_MODE_6_BITS:\n\t\t*bits = 6;\n\t\tbreak;\n\tcase MPC52xx_PSC_MODE_7_BITS:\n\t\t*bits = 7;\n\t\tbreak;\n\tcase MPC52xx_PSC_MODE_8_BITS:\n\tdefault:\n\t\t*bits = 8;\n\t}\n\n\tif (mr1 & MPC52xx_PSC_MODE_PARNONE)\n\t\t*parity = 'n';\n\telse\n\t\t*parity = mr1 & MPC52xx_PSC_MODE_PARODD ? 'o' : 'e';\n}\n\nstatic void\nmpc52xx_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct uart_port *port = &mpc52xx_uart_ports[co->index];\n\tunsigned int i, j;\n\n\t \n\tpsc_ops->cw_disable_ints(port);\n\n\t \n\tj = 5000000;\t \n\twhile (!mpc52xx_uart_tx_empty(port) && --j)\n\t\tudelay(1);\n\n\t \n\tfor (i = 0; i < count; i++, s++) {\n\t\t \n\t\tif (*s == '\\n')\n\t\t\tpsc_ops->write_char(port, '\\r');\n\n\t\t \n\t\tpsc_ops->write_char(port, *s);\n\n\t\t \n\t\tj = 20000;\t \n\t\twhile (!mpc52xx_uart_tx_empty(port) && --j)\n\t\t\tudelay(1);\n\t}\n\n\t \n\tpsc_ops->cw_restore_ints(port);\n}\n\n\nstatic int __init\nmpc52xx_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port = &mpc52xx_uart_ports[co->index];\n\tstruct device_node *np = mpc52xx_uart_nodes[co->index];\n\tunsigned int uartclk;\n\tstruct resource res;\n\tint ret;\n\n\tint baud = CONFIG_SERIAL_MPC52xx_CONSOLE_BAUD;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tpr_debug(\"mpc52xx_console_setup co=%p, co->index=%i, options=%s\\n\",\n\t\t co, co->index, options);\n\n\tif ((co->index < 0) || (co->index >= MPC52xx_PSC_MAXNUM)) {\n\t\tpr_debug(\"PSC%x out of range\\n\", co->index);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!np) {\n\t\tpr_debug(\"PSC%x not found in device tree\\n\", co->index);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"Console on ttyPSC%x is %pOF\\n\",\n\t\t co->index, mpc52xx_uart_nodes[co->index]);\n\n\t \n\tret = of_address_to_resource(np, 0, &res);\n\tif (ret) {\n\t\tpr_debug(\"Could not get resources for PSC%x\\n\", co->index);\n\t\treturn ret;\n\t}\n\n\tuartclk = mpc5xxx_fwnode_get_bus_frequency(of_fwnode_handle(np));\n\tif (uartclk == 0) {\n\t\tpr_debug(\"Could not find uart clock frequency!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspin_lock_init(&port->lock);\n\tport->uartclk = uartclk;\n\tport->ops\t= &mpc52xx_uart_ops;\n\tport->mapbase = res.start;\n\tport->membase = ioremap(res.start, sizeof(struct mpc52xx_psc));\n\tport->irq = irq_of_parse_and_map(np, 0);\n\n\tif (port->membase == NULL)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"mpc52xx-psc uart at %p, mapped to %p, irq=%x, freq=%i\\n\",\n\t\t (void *)port->mapbase, port->membase,\n\t\t port->irq, port->uartclk);\n\n\t \n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse\n\t\tmpc52xx_console_get_options(port, &baud, &parity, &bits, &flow);\n\n\tpr_debug(\"Setting console parameters: %i %i%c1 flow=%c\\n\",\n\t\t baud, bits, parity, flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\n\nstatic struct uart_driver mpc52xx_uart_driver;\n\nstatic struct console mpc52xx_console = {\n\t.name\t= \"ttyPSC\",\n\t.write\t= mpc52xx_console_write,\n\t.device\t= uart_console_device,\n\t.setup\t= mpc52xx_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,\t \n\t.data\t= &mpc52xx_uart_driver,\n};\n\n\nstatic int __init\nmpc52xx_console_init(void)\n{\n\tmpc52xx_uart_of_enumerate();\n\tregister_console(&mpc52xx_console);\n\treturn 0;\n}\n\nconsole_initcall(mpc52xx_console_init);\n\n#define MPC52xx_PSC_CONSOLE &mpc52xx_console\n#else\n#define MPC52xx_PSC_CONSOLE NULL\n#endif\n\n\n \n \n \n\nstatic struct uart_driver mpc52xx_uart_driver = {\n\t.driver_name\t= \"mpc52xx_psc_uart\",\n\t.dev_name\t= \"ttyPSC\",\n\t.major\t\t= SERIAL_PSC_MAJOR,\n\t.minor\t\t= SERIAL_PSC_MINOR,\n\t.nr\t\t= MPC52xx_PSC_MAXNUM,\n\t.cons\t\t= MPC52xx_PSC_CONSOLE,\n};\n\n \n \n \n\nstatic const struct of_device_id mpc52xx_uart_of_match[] = {\n#ifdef CONFIG_PPC_MPC52xx\n\t{ .compatible = \"fsl,mpc5200b-psc-uart\", .data = &mpc5200b_psc_ops, },\n\t{ .compatible = \"fsl,mpc5200-psc-uart\", .data = &mpc52xx_psc_ops, },\n\t \n\t{ .compatible = \"mpc5200-psc-uart\", .data = &mpc52xx_psc_ops, },\n\t \n\t{ .compatible = \"mpc5200-serial\", .data = &mpc52xx_psc_ops, },\n#endif\n#ifdef CONFIG_PPC_MPC512x\n\t{ .compatible = \"fsl,mpc5121-psc-uart\", .data = &mpc512x_psc_ops, },\n\t{ .compatible = \"fsl,mpc5125-psc-uart\", .data = &mpc5125_psc_ops, },\n#endif\n\t{},\n};\n\nstatic int mpc52xx_uart_of_probe(struct platform_device *op)\n{\n\tint idx = -1;\n\tunsigned int uartclk;\n\tstruct uart_port *port = NULL;\n\tstruct resource res;\n\tint ret;\n\n\t \n\tfor (idx = 0; idx < MPC52xx_PSC_MAXNUM; idx++)\n\t\tif (mpc52xx_uart_nodes[idx] == op->dev.of_node)\n\t\t\tbreak;\n\tif (idx >= MPC52xx_PSC_MAXNUM)\n\t\treturn -EINVAL;\n\tpr_debug(\"Found %pOF assigned to ttyPSC%x\\n\",\n\t\t mpc52xx_uart_nodes[idx], idx);\n\n\t \n\tuartclk = mpc5xxx_get_bus_frequency(&op->dev);\n\tif (uartclk == 0) {\n\t\tdev_dbg(&op->dev, \"Could not find uart clock frequency!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tport = &mpc52xx_uart_ports[idx];\n\n\tspin_lock_init(&port->lock);\n\tport->uartclk = uartclk;\n\tport->fifosize\t= 512;\n\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_MPC52xx_CONSOLE);\n\tport->iotype\t= UPIO_MEM;\n\tport->flags\t= UPF_BOOT_AUTOCONF |\n\t\t\t  (uart_console(port) ? 0 : UPF_IOREMAP);\n\tport->line\t= idx;\n\tport->ops\t= &mpc52xx_uart_ops;\n\tport->dev\t= &op->dev;\n\n\t \n\tret = of_address_to_resource(op->dev.of_node, 0, &res);\n\tif (ret)\n\t\treturn ret;\n\n\tport->mapbase = res.start;\n\tif (!port->mapbase) {\n\t\tdev_dbg(&op->dev, \"Could not allocate resources for PSC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpsc_ops->get_irq(port, op->dev.of_node);\n\tif (port->irq == 0) {\n\t\tdev_dbg(&op->dev, \"Could not get irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&op->dev, \"mpc52xx-psc uart at %p, irq=%x, freq=%i\\n\",\n\t\t(void *)port->mapbase, port->irq, port->uartclk);\n\n\t \n\tret = uart_add_one_port(&mpc52xx_uart_driver, port);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(op, (void *)port);\n\treturn 0;\n}\n\nstatic int\nmpc52xx_uart_of_remove(struct platform_device *op)\n{\n\tstruct uart_port *port = platform_get_drvdata(op);\n\n\tif (port)\n\t\tuart_remove_one_port(&mpc52xx_uart_driver, port);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int\nmpc52xx_uart_of_suspend(struct platform_device *op, pm_message_t state)\n{\n\tstruct uart_port *port = platform_get_drvdata(op);\n\n\tif (port)\n\t\tuart_suspend_port(&mpc52xx_uart_driver, port);\n\n\treturn 0;\n}\n\nstatic int\nmpc52xx_uart_of_resume(struct platform_device *op)\n{\n\tstruct uart_port *port = platform_get_drvdata(op);\n\n\tif (port)\n\t\tuart_resume_port(&mpc52xx_uart_driver, port);\n\n\treturn 0;\n}\n#endif\n\nstatic void\nmpc52xx_uart_of_assign(struct device_node *np)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < MPC52xx_PSC_MAXNUM; i++) {\n\t\tif (mpc52xx_uart_nodes[i] == NULL) {\n\t\t\tof_node_get(np);\n\t\t\tmpc52xx_uart_nodes[i] = np;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\nmpc52xx_uart_of_enumerate(void)\n{\n\tstatic int enum_done;\n\tstruct device_node *np;\n\tconst struct  of_device_id *match;\n\tint i;\n\n\tif (enum_done)\n\t\treturn;\n\n\t \n\tfor_each_matching_node(np, mpc52xx_uart_of_match) {\n\t\tmatch = of_match_node(mpc52xx_uart_of_match, np);\n\t\tpsc_ops = match->data;\n\t\tmpc52xx_uart_of_assign(np);\n\t}\n\n\tenum_done = 1;\n\n\tfor (i = 0; i < MPC52xx_PSC_MAXNUM; i++) {\n\t\tif (mpc52xx_uart_nodes[i])\n\t\t\tpr_debug(\"%pOF assigned to ttyPSC%x\\n\",\n\t\t\t\t mpc52xx_uart_nodes[i], i);\n\t}\n}\n\nMODULE_DEVICE_TABLE(of, mpc52xx_uart_of_match);\n\nstatic struct platform_driver mpc52xx_uart_of_driver = {\n\t.probe\t\t= mpc52xx_uart_of_probe,\n\t.remove\t\t= mpc52xx_uart_of_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= mpc52xx_uart_of_suspend,\n\t.resume\t\t= mpc52xx_uart_of_resume,\n#endif\n\t.driver = {\n\t\t.name = \"mpc52xx-psc-uart\",\n\t\t.of_match_table = mpc52xx_uart_of_match,\n\t},\n};\n\n\n \n \n \n\nstatic int __init\nmpc52xx_uart_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO \"Serial: MPC52xx PSC UART driver\\n\");\n\n\tret = uart_register_driver(&mpc52xx_uart_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: uart_register_driver failed (%i)\\n\",\n\t\t       __FILE__, ret);\n\t\treturn ret;\n\t}\n\n\tmpc52xx_uart_of_enumerate();\n\n\t \n\tif (psc_ops && psc_ops->fifoc_init) {\n\t\tret = psc_ops->fifoc_init();\n\t\tif (ret)\n\t\t\tgoto err_init;\n\t}\n\n\tret = platform_driver_register(&mpc52xx_uart_of_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: platform_driver_register failed (%i)\\n\",\n\t\t       __FILE__, ret);\n\t\tgoto err_reg;\n\t}\n\n\treturn 0;\nerr_reg:\n\tif (psc_ops && psc_ops->fifoc_uninit)\n\t\tpsc_ops->fifoc_uninit();\nerr_init:\n\tuart_unregister_driver(&mpc52xx_uart_driver);\n\treturn ret;\n}\n\nstatic void __exit\nmpc52xx_uart_exit(void)\n{\n\tif (psc_ops->fifoc_uninit)\n\t\tpsc_ops->fifoc_uninit();\n\n\tplatform_driver_unregister(&mpc52xx_uart_of_driver);\n\tuart_unregister_driver(&mpc52xx_uart_driver);\n}\n\n\nmodule_init(mpc52xx_uart_init);\nmodule_exit(mpc52xx_uart_exit);\n\nMODULE_AUTHOR(\"Sylvain Munaut <tnt@246tNt.com>\");\nMODULE_DESCRIPTION(\"Freescale MPC52xx PSC UART\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}