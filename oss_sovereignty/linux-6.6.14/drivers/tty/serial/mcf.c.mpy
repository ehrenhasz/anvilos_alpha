{
  "module_name": "mcf.c",
  "hash_id": "685e9912f5635bb22a6d301290334ad35dc28f1126905a6d5fa4c8e5b97b53be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/mcf.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/platform_device.h>\n#include <asm/coldfire.h>\n#include <asm/mcfsim.h>\n#include <asm/mcfuart.h>\n#include <asm/nettel.h>\n\n \n\n \n#if !defined(mcf_getppdcd)\n#define\tmcf_getppdcd(p)\t\t(1)\n#endif\n#if !defined(mcf_getppdtr)\n#define\tmcf_getppdtr(p)\t\t(1)\n#endif\n#if !defined(mcf_setppdtr)\n#define\tmcf_setppdtr(p, v)\tdo { } while (0)\n#endif\n\n \n\n \nstruct mcf_uart {\n\tstruct uart_port\tport;\n\tunsigned int\t\tsigs;\t\t \n\tunsigned char\t\timr;\t\t \n};\n\n \n\nstatic unsigned int mcf_tx_empty(struct uart_port *port)\n{\n\treturn (readb(port->membase + MCFUART_USR) & MCFUART_USR_TXEMPTY) ?\n\t\tTIOCSER_TEMT : 0;\n}\n\n \n\nstatic unsigned int mcf_get_mctrl(struct uart_port *port)\n{\n\tstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\n\tunsigned int sigs;\n\n\tsigs = (readb(port->membase + MCFUART_UIPR) & MCFUART_UIPR_CTS) ?\n\t\t0 : TIOCM_CTS;\n\tsigs |= (pp->sigs & TIOCM_RTS);\n\tsigs |= (mcf_getppdcd(port->line) ? TIOCM_CD : 0);\n\tsigs |= (mcf_getppdtr(port->line) ? TIOCM_DTR : 0);\n\n\treturn sigs;\n}\n\n \n\nstatic void mcf_set_mctrl(struct uart_port *port, unsigned int sigs)\n{\n\tstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\n\n\tpp->sigs = sigs;\n\tmcf_setppdtr(port->line, (sigs & TIOCM_DTR));\n\tif (sigs & TIOCM_RTS)\n\t\twriteb(MCFUART_UOP_RTS, port->membase + MCFUART_UOP1);\n\telse\n\t\twriteb(MCFUART_UOP_RTS, port->membase + MCFUART_UOP0);\n}\n\n \n\nstatic void mcf_start_tx(struct uart_port *port)\n{\n\tstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\n\n\tif (port->rs485.flags & SER_RS485_ENABLED) {\n\t\t \n\t\twriteb(MCFUART_UCR_TXENABLE, port->membase + MCFUART_UCR);\n\t\t \n\t\twriteb(MCFUART_UOP_RTS, port->membase + MCFUART_UOP1);\n\t}\n\tpp->imr |= MCFUART_UIR_TXREADY;\n\twriteb(pp->imr, port->membase + MCFUART_UIMR);\n}\n\n \n\nstatic void mcf_stop_tx(struct uart_port *port)\n{\n\tstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\n\n\tpp->imr &= ~MCFUART_UIR_TXREADY;\n\twriteb(pp->imr, port->membase + MCFUART_UIMR);\n}\n\n \n\nstatic void mcf_stop_rx(struct uart_port *port)\n{\n\tstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\n\n\tpp->imr &= ~MCFUART_UIR_RXREADY;\n\twriteb(pp->imr, port->membase + MCFUART_UIMR);\n}\n\n \n\nstatic void mcf_break_ctl(struct uart_port *port, int break_state)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (break_state == -1)\n\t\twriteb(MCFUART_UCR_CMDBREAKSTART, port->membase + MCFUART_UCR);\n\telse\n\t\twriteb(MCFUART_UCR_CMDBREAKSTOP, port->membase + MCFUART_UCR);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \n\nstatic int mcf_startup(struct uart_port *port)\n{\n\tstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\twriteb(MCFUART_UCR_CMDRESETRX, port->membase + MCFUART_UCR);\n\twriteb(MCFUART_UCR_CMDRESETTX, port->membase + MCFUART_UCR);\n\n\t \n\twriteb(MCFUART_UCR_RXENABLE | MCFUART_UCR_TXENABLE,\n\t\tport->membase + MCFUART_UCR);\n\n\t \n\tpp->imr = MCFUART_UIR_RXREADY;\n\twriteb(pp->imr, port->membase + MCFUART_UIMR);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn 0;\n}\n\n \n\nstatic void mcf_shutdown(struct uart_port *port)\n{\n\tstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tpp->imr = 0;\n\twriteb(pp->imr, port->membase + MCFUART_UIMR);\n\n\t \n\twriteb(MCFUART_UCR_CMDRESETRX, port->membase + MCFUART_UCR);\n\twriteb(MCFUART_UCR_CMDRESETTX, port->membase + MCFUART_UCR);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \n\nstatic void mcf_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t\t    const struct ktermios *old)\n{\n\tunsigned long flags;\n\tunsigned int baud, baudclk;\n#if defined(CONFIG_M5272)\n\tunsigned int baudfr;\n#endif\n\tunsigned char mr1, mr2;\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, 230400);\n#if defined(CONFIG_M5272)\n\tbaudclk = (MCF_BUSCLK / baud) / 32;\n\tbaudfr = (((MCF_BUSCLK / baud) + 1) / 2) % 16;\n#else\n\tbaudclk = ((MCF_BUSCLK / baud) + 16) / 32;\n#endif\n\n\tmr1 = MCFUART_MR1_RXIRQRDY | MCFUART_MR1_RXERRCHAR;\n\tmr2 = 0;\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5: mr1 |= MCFUART_MR1_CS5; break;\n\tcase CS6: mr1 |= MCFUART_MR1_CS6; break;\n\tcase CS7: mr1 |= MCFUART_MR1_CS7; break;\n\tcase CS8:\n\tdefault:  mr1 |= MCFUART_MR1_CS8; break;\n\t}\n\n\tif (termios->c_cflag & PARENB) {\n\t\tif (termios->c_cflag & CMSPAR) {\n\t\t\tif (termios->c_cflag & PARODD)\n\t\t\t\tmr1 |= MCFUART_MR1_PARITYMARK;\n\t\t\telse\n\t\t\t\tmr1 |= MCFUART_MR1_PARITYSPACE;\n\t\t} else {\n\t\t\tif (termios->c_cflag & PARODD)\n\t\t\t\tmr1 |= MCFUART_MR1_PARITYODD;\n\t\t\telse\n\t\t\t\tmr1 |= MCFUART_MR1_PARITYEVEN;\n\t\t}\n\t} else {\n\t\tmr1 |= MCFUART_MR1_PARITYNONE;\n\t}\n\n\t \n\n\tif (termios->c_cflag & CSTOPB)\n\t\tmr2 |= MCFUART_MR2_STOP2;\n\telse\n\t\tmr2 |= MCFUART_MR2_STOP1;\n\n\tif (termios->c_cflag & CRTSCTS) {\n\t\tmr1 |= MCFUART_MR1_RXRTS;\n\t\tmr2 |= MCFUART_MR2_TXCTS;\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (port->rs485.flags & SER_RS485_ENABLED) {\n\t\tdev_dbg(port->dev, \"Setting UART to RS485\\n\");\n\t\tmr2 |= MCFUART_MR2_TXRTS;\n\t}\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\twriteb(MCFUART_UCR_CMDRESETRX, port->membase + MCFUART_UCR);\n\twriteb(MCFUART_UCR_CMDRESETTX, port->membase + MCFUART_UCR);\n\twriteb(MCFUART_UCR_CMDRESETMRPTR, port->membase + MCFUART_UCR);\n\twriteb(mr1, port->membase + MCFUART_UMR);\n\twriteb(mr2, port->membase + MCFUART_UMR);\n\twriteb((baudclk & 0xff00) >> 8, port->membase + MCFUART_UBG1);\n\twriteb((baudclk & 0xff), port->membase + MCFUART_UBG2);\n#if defined(CONFIG_M5272)\n\twriteb((baudfr & 0x0f), port->membase + MCFUART_UFPD);\n#endif\n\twriteb(MCFUART_UCSR_RXCLKTIMER | MCFUART_UCSR_TXCLKTIMER,\n\t\tport->membase + MCFUART_UCSR);\n\twriteb(MCFUART_UCR_RXENABLE | MCFUART_UCR_TXENABLE,\n\t\tport->membase + MCFUART_UCR);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \n\nstatic void mcf_rx_chars(struct mcf_uart *pp)\n{\n\tstruct uart_port *port = &pp->port;\n\tu8 status, ch, flag;\n\n\twhile ((status = readb(port->membase + MCFUART_USR)) & MCFUART_USR_RXREADY) {\n\t\tch = readb(port->membase + MCFUART_URB);\n\t\tflag = TTY_NORMAL;\n\t\tport->icount.rx++;\n\n\t\tif (status & MCFUART_USR_RXERR) {\n\t\t\twriteb(MCFUART_UCR_CMDRESETERR,\n\t\t\t\tport->membase + MCFUART_UCR);\n\n\t\t\tif (status & MCFUART_USR_RXBREAK) {\n\t\t\t\tport->icount.brk++;\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (status & MCFUART_USR_RXPARITY) {\n\t\t\t\tport->icount.parity++;\n\t\t\t} else if (status & MCFUART_USR_RXOVERRUN) {\n\t\t\t\tport->icount.overrun++;\n\t\t\t} else if (status & MCFUART_USR_RXFRAMING) {\n\t\t\t\tport->icount.frame++;\n\t\t\t}\n\n\t\t\tstatus &= port->read_status_mask;\n\n\t\t\tif (status & MCFUART_USR_RXBREAK)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (status & MCFUART_USR_RXPARITY)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (status & MCFUART_USR_RXFRAMING)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tcontinue;\n\t\tuart_insert_char(port, status, MCFUART_USR_RXOVERRUN, ch, flag);\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\n \n\nstatic void mcf_tx_chars(struct mcf_uart *pp)\n{\n\tstruct uart_port *port = &pp->port;\n\tbool pending;\n\tu8 ch;\n\n\tpending = uart_port_tx(port, ch,\n\t\treadb(port->membase + MCFUART_USR) & MCFUART_USR_TXREADY,\n\t\twriteb(ch, port->membase + MCFUART_UTB));\n\n\t \n\tif (!pending && (port->rs485.flags & SER_RS485_ENABLED))\n\t\twriteb(MCFUART_UCR_TXDISABLE, port->membase + MCFUART_UCR);\n}\n\n \n\nstatic irqreturn_t mcf_interrupt(int irq, void *data)\n{\n\tstruct uart_port *port = data;\n\tstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\n\tunsigned int isr;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tisr = readb(port->membase + MCFUART_UISR) & pp->imr;\n\n\tspin_lock(&port->lock);\n\tif (isr & MCFUART_UIR_RXREADY) {\n\t\tmcf_rx_chars(pp);\n\t\tret = IRQ_HANDLED;\n\t}\n\tif (isr & MCFUART_UIR_TXREADY) {\n\t\tmcf_tx_chars(pp);\n\t\tret = IRQ_HANDLED;\n\t}\n\tspin_unlock(&port->lock);\n\n\treturn ret;\n}\n\n \n\nstatic void mcf_config_port(struct uart_port *port, int flags)\n{\n\tport->type = PORT_MCF;\n\tport->fifosize = MCFUART_TXFIFOSIZE;\n\n\t \n\twriteb(0, port->membase + MCFUART_UIMR);\n\n\tif (request_irq(port->irq, mcf_interrupt, 0, \"UART\", port))\n\t\tprintk(KERN_ERR \"MCF: unable to attach ColdFire UART %d \"\n\t\t\t\"interrupt vector=%d\\n\", port->line, port->irq);\n}\n\n \n\nstatic const char *mcf_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_MCF) ? \"ColdFire UART\" : NULL;\n}\n\n \n\nstatic int mcf_request_port(struct uart_port *port)\n{\n\t \n\treturn 0;\n}\n\n \n\nstatic void mcf_release_port(struct uart_port *port)\n{\n\t \n}\n\n \n\nstatic int mcf_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tif ((ser->type != PORT_UNKNOWN) && (ser->type != PORT_MCF))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \n\n \nstatic int mcf_config_rs485(struct uart_port *port, struct ktermios *termios,\n\t\t\t    struct serial_rs485 *rs485)\n{\n\tunsigned char mr1, mr2;\n\n\t \n\tmr1 = readb(port->membase + MCFUART_UMR);\n\tmr2 = readb(port->membase + MCFUART_UMR);\n\tif (rs485->flags & SER_RS485_ENABLED) {\n\t\tdev_dbg(port->dev, \"Setting UART to RS485\\n\");\n\t\t \n\t\tmr2 |= MCFUART_MR2_TXRTS;\n\t} else {\n\t\tdev_dbg(port->dev, \"Setting UART to RS232\\n\");\n\t\tmr2 &= ~MCFUART_MR2_TXRTS;\n\t}\n\twriteb(mr1, port->membase + MCFUART_UMR);\n\twriteb(mr2, port->membase + MCFUART_UMR);\n\n\treturn 0;\n}\n\nstatic const struct serial_rs485 mcf_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_AFTER_SEND,\n};\n\n \n\n \nstatic const struct uart_ops mcf_uart_ops = {\n\t.tx_empty\t= mcf_tx_empty,\n\t.get_mctrl\t= mcf_get_mctrl,\n\t.set_mctrl\t= mcf_set_mctrl,\n\t.start_tx\t= mcf_start_tx,\n\t.stop_tx\t= mcf_stop_tx,\n\t.stop_rx\t= mcf_stop_rx,\n\t.break_ctl\t= mcf_break_ctl,\n\t.startup\t= mcf_startup,\n\t.shutdown\t= mcf_shutdown,\n\t.set_termios\t= mcf_set_termios,\n\t.type\t\t= mcf_type,\n\t.request_port\t= mcf_request_port,\n\t.release_port\t= mcf_release_port,\n\t.config_port\t= mcf_config_port,\n\t.verify_port\t= mcf_verify_port,\n};\n\nstatic struct mcf_uart mcf_ports[4];\n\n#define\tMCF_MAXPORTS\tARRAY_SIZE(mcf_ports)\n\n \n#if defined(CONFIG_SERIAL_MCF_CONSOLE)\n \n\nint __init early_mcf_setup(struct mcf_platform_uart *platp)\n{\n\tstruct uart_port *port;\n\tint i;\n\n\tfor (i = 0; ((i < MCF_MAXPORTS) && (platp[i].mapbase)); i++) {\n\t\tport = &mcf_ports[i].port;\n\n\t\tport->line = i;\n\t\tport->type = PORT_MCF;\n\t\tport->mapbase = platp[i].mapbase;\n\t\tport->membase = (platp[i].membase) ? platp[i].membase :\n\t\t\t(unsigned char __iomem *) port->mapbase;\n\t\tport->iotype = SERIAL_IO_MEM;\n\t\tport->irq = platp[i].irq;\n\t\tport->uartclk = MCF_BUSCLK;\n\t\tport->flags = UPF_BOOT_AUTOCONF;\n\t\tport->rs485_config = mcf_config_rs485;\n\t\tport->rs485_supported = mcf_rs485_supported;\n\t\tport->ops = &mcf_uart_ops;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void mcf_console_putc(struct console *co, const char c)\n{\n\tstruct uart_port *port = &(mcf_ports + co->index)->port;\n\tint i;\n\n\tfor (i = 0; (i < 0x10000); i++) {\n\t\tif (readb(port->membase + MCFUART_USR) & MCFUART_USR_TXREADY)\n\t\t\tbreak;\n\t}\n\twriteb(c, port->membase + MCFUART_UTB);\n\tfor (i = 0; (i < 0x10000); i++) {\n\t\tif (readb(port->membase + MCFUART_USR) & MCFUART_USR_TXREADY)\n\t\t\tbreak;\n\t}\n}\n\n \n\nstatic void mcf_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tfor (; (count); count--, s++) {\n\t\tmcf_console_putc(co, *s);\n\t\tif (*s == '\\n')\n\t\t\tmcf_console_putc(co, '\\r');\n\t}\n}\n\n \n\nstatic int __init mcf_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint baud = CONFIG_SERIAL_MCF_BAUDRATE;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif ((co->index < 0) || (co->index >= MCF_MAXPORTS))\n\t\tco->index = 0;\n\tport = &mcf_ports[co->index].port;\n\tif (port->membase == 0)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\n \n\nstatic struct uart_driver mcf_driver;\n\nstatic struct console mcf_console = {\n\t.name\t\t= \"ttyS\",\n\t.write\t\t= mcf_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= mcf_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &mcf_driver,\n};\n\nstatic int __init mcf_console_init(void)\n{\n\tregister_console(&mcf_console);\n\treturn 0;\n}\n\nconsole_initcall(mcf_console_init);\n\n#define\tMCF_CONSOLE\t&mcf_console\n\n \n#else\n \n\n#define\tMCF_CONSOLE\tNULL\n\n \n#endif  \n \n\n \nstatic struct uart_driver mcf_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"mcf\",\n\t.dev_name\t= \"ttyS\",\n\t.major\t\t= TTY_MAJOR,\n\t.minor\t\t= 64,\n\t.nr\t\t= MCF_MAXPORTS,\n\t.cons\t\t= MCF_CONSOLE,\n};\n\n \n\nstatic int mcf_probe(struct platform_device *pdev)\n{\n\tstruct mcf_platform_uart *platp = dev_get_platdata(&pdev->dev);\n\tstruct uart_port *port;\n\tint i;\n\n\tfor (i = 0; ((i < MCF_MAXPORTS) && (platp[i].mapbase)); i++) {\n\t\tport = &mcf_ports[i].port;\n\n\t\tport->line = i;\n\t\tport->type = PORT_MCF;\n\t\tport->mapbase = platp[i].mapbase;\n\t\tport->membase = (platp[i].membase) ? platp[i].membase :\n\t\t\t(unsigned char __iomem *) platp[i].mapbase;\n\t\tport->dev = &pdev->dev;\n\t\tport->iotype = SERIAL_IO_MEM;\n\t\tport->irq = platp[i].irq;\n\t\tport->uartclk = MCF_BUSCLK;\n\t\tport->ops = &mcf_uart_ops;\n\t\tport->flags = UPF_BOOT_AUTOCONF;\n\t\tport->rs485_config = mcf_config_rs485;\n\t\tport->rs485_supported = mcf_rs485_supported;\n\t\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_MCF_CONSOLE);\n\n\t\tuart_add_one_port(&mcf_driver, port);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int mcf_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port;\n\tint i;\n\n\tfor (i = 0; (i < MCF_MAXPORTS); i++) {\n\t\tport = &mcf_ports[i].port;\n\t\tif (port)\n\t\t\tuart_remove_one_port(&mcf_driver, port);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic struct platform_driver mcf_platform_driver = {\n\t.probe\t\t= mcf_probe,\n\t.remove\t\t= mcf_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"mcfuart\",\n\t},\n};\n\n \n\nstatic int __init mcf_init(void)\n{\n\tint rc;\n\n\tprintk(\"ColdFire internal UART serial driver\\n\");\n\n\trc = uart_register_driver(&mcf_driver);\n\tif (rc)\n\t\treturn rc;\n\trc = platform_driver_register(&mcf_platform_driver);\n\tif (rc) {\n\t\tuart_unregister_driver(&mcf_driver);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\n \n\nstatic void __exit mcf_exit(void)\n{\n\tplatform_driver_unregister(&mcf_platform_driver);\n\tuart_unregister_driver(&mcf_driver);\n}\n\n \n\nmodule_init(mcf_init);\nmodule_exit(mcf_exit);\n\nMODULE_AUTHOR(\"Greg Ungerer <gerg@uclinux.org>\");\nMODULE_DESCRIPTION(\"Freescale ColdFire UART driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mcfuart\");\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}