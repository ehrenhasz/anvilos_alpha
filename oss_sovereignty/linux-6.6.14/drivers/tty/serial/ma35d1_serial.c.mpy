{
  "module_name": "ma35d1_serial.c",
  "hash_id": "dee9d570b010e9c27e63918d10e4c84697ca8768f62735d10a124836498ede9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/ma35d1_serial.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/iopoll.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/tty_flip.h>\n#include <linux/units.h>\n\n#define MA35_UART_NR\t\t17\n\n#define MA35_RBR_REG\t\t0x00\n#define MA35_THR_REG\t\t0x00\n#define MA35_IER_REG\t\t0x04\n#define MA35_FCR_REG\t\t0x08\n#define MA35_LCR_REG\t\t0x0C\n#define MA35_MCR_REG\t\t0x10\n#define MA35_MSR_REG\t\t0x14\n#define MA35_FSR_REG\t\t0x18\n#define MA35_ISR_REG\t\t0x1C\n#define MA35_TOR_REG\t\t0x20\n#define MA35_BAUD_REG\t\t0x24\n#define MA35_ALTCTL_REG\t\t0x2C\n#define MA35_FUN_SEL_REG\t0x30\n#define MA35_WKCTL_REG\t\t0x40\n#define MA35_WKSTS_REG\t\t0x44\n\n \n#define MA35_IER_RDA_IEN\tBIT(0)   \n#define MA35_IER_THRE_IEN\tBIT(1)   \n#define MA35_IER_RLS_IEN\tBIT(2)   \n#define MA35_IER_RTO_IEN\tBIT(4)   \n#define MA35_IER_BUFERR_IEN\tBIT(5)   \n#define MA35_IER_TIME_OUT_EN\tBIT(11)  \n#define MA35_IER_AUTO_RTS\tBIT(12)  \n#define MA35_IER_AUTO_CTS\tBIT(13)  \n\n \n#define MA35_FCR_RFR\t\tBIT(1)   \n#define MA35_FCR_TFR\t\tBIT(2)   \n#define MA35_FCR_RFITL_MASK\tGENMASK(7, 4)  \n#define MA35_FCR_RFITL_1BYTE\tFIELD_PREP(MA35_FCR_RFITL_MASK, 0)\n#define MA35_FCR_RFITL_4BYTES\tFIELD_PREP(MA35_FCR_RFITL_MASK, 1)\n#define MA35_FCR_RFITL_8BYTES\tFIELD_PREP(MA35_FCR_RFITL_MASK, 2)\n#define MA35_FCR_RFITL_14BYTES\tFIELD_PREP(MA35_FCR_RFITL_MASK, 3)\n#define MA35_FCR_RFITL_30BYTES\tFIELD_PREP(MA35_FCR_RFITL_MASK, 4)\n#define MA35_FCR_RTSTL_MASK\tGENMASK(19, 16)  \n#define MA35_FCR_RTSTL_1BYTE\tFIELD_PREP(MA35_FCR_RTSTL_MASK, 0)\n#define MA35_FCR_RTSTL_4BYTES\tFIELD_PREP(MA35_FCR_RTSTL_MASK, 1)\n#define MA35_FCR_RTSTL_8BYTES\tFIELD_PREP(MA35_FCR_RTSTL_MASK, 2)\n#define MA35_FCR_RTSTL_14BYTES\tFIELD_PREP(MA35_FCR_RTSTL_MASK, 3)\n#define MA35_FCR_RTSTLL_30BYTES\tFIELD_PREP(MA35_FCR_RTSTL_MASK, 4)\n\n \n#define\tMA35_LCR_NSB\t\tBIT(2)   \n#define MA35_LCR_PBE\t\tBIT(3)   \n#define MA35_LCR_EPE\t\tBIT(4)   \n#define MA35_LCR_SPE\t\tBIT(5)   \n#define MA35_LCR_BREAK\t\tBIT(6)   \n#define MA35_LCR_WLS_MASK\tGENMASK(1, 0)  \n#define MA35_LCR_WLS_5BITS\tFIELD_PREP(MA35_LCR_WLS_MASK, 0)\n#define MA35_LCR_WLS_6BITS\tFIELD_PREP(MA35_LCR_WLS_MASK, 1)\n#define MA35_LCR_WLS_7BITS\tFIELD_PREP(MA35_LCR_WLS_MASK, 2)\n#define MA35_LCR_WLS_8BITS\tFIELD_PREP(MA35_LCR_WLS_MASK, 3)\n\n \n#define MA35_MCR_RTS_CTRL\tBIT(1)   \n#define MA35_MCR_RTSACTLV\tBIT(9)   \n#define MA35_MCR_RTSSTS\t\tBIT(13)  \n\n \n#define MA35_MSR_CTSDETF\tBIT(0)   \n#define MA35_MSR_CTSSTS\t\tBIT(4)   \n#define MA35_MSR_CTSACTLV\tBIT(8)   \n\n \n#define MA35_FSR_RX_OVER_IF\tBIT(0)   \n#define MA35_FSR_PEF\t\tBIT(4)   \n#define MA35_FSR_FEF\t\tBIT(5)   \n#define MA35_FSR_BIF\t\tBIT(6)   \n#define MA35_FSR_RX_EMPTY\tBIT(14)  \n#define MA35_FSR_RX_FULL\tBIT(15)  \n#define MA35_FSR_TX_EMPTY\tBIT(22)  \n#define MA35_FSR_TX_FULL\tBIT(23)  \n#define MA35_FSR_TX_OVER_IF\tBIT(24)  \n#define MA35_FSR_TE_FLAG\tBIT(28)  \n#define MA35_FSR_RXPTR_MSK\tGENMASK(13, 8)  \n#define MA35_FSR_TXPTR_MSK\tGENMASK(21, 16)  \n\n \n#define MA35_ISR_RDA_IF\t\tBIT(0)   \n#define MA35_ISR_THRE_IF\tBIT(1)   \n#define MA35_ISR_RLSIF\t\tBIT(2)   \n#define MA35_ISR_MODEMIF\tBIT(3)   \n#define MA35_ISR_RXTO_IF\tBIT(4)   \n#define MA35_ISR_BUFEIF\t\tBIT(5)   \n#define MA35_ISR_WK_IF\t\tBIT(6)   \n#define MA35_ISR_RDAINT\t\tBIT(8)   \n#define MA35_ISR_THRE_INT\tBIT(9)   \n#define MA35_ISR_ALL\t\t0xFFFFFFFF\n\n \n#define\tMA35_BAUD_MODE_MASK\tGENMASK(29, 28)\n#define MA35_BAUD_MODE0\t\tFIELD_PREP(MA35_BAUD_MODE_MASK, 0)\n#define MA35_BAUD_MODE1\t\tFIELD_PREP(MA35_BAUD_MODE_MASK, 2)\n#define MA35_BAUD_MODE2\t\tFIELD_PREP(MA35_BAUD_MODE_MASK, 3)\n#define\tMA35_BAUD_MASK\t\tGENMASK(15, 0)\n\n \n#define MA35_ALTCTL_RS485AUD\tBIT(10)  \n\n \n#define MA35_FUN_SEL_MASK\tGENMASK(2, 0)\n#define MA35_FUN_SEL_UART\tFIELD_PREP(MA35_FUN_SEL_MASK, 0)\n#define MA35_FUN_SEL_RS485\tFIELD_PREP(MA35_FUN_SEL_MASK, 3)\n\n \n#define MA35_BAUD_DIV_MAX\t0xFFFF\n#define MA35_BAUD_DIV_MIN\t11\n\n \n#define MA35_UART_FIFO_DEPTH\t32\n \n#define MA35_UART_CONSOLE_CLK\t(24 * HZ_PER_MHZ)\n \n#define MA35_UART_REG_SIZE\t0x100\n \n#define MA35_UART_RX_TOUT\t0x40\n\n#define MA35_IER_CONFIG\t\t(MA35_IER_RTO_IEN | MA35_IER_RDA_IEN | \\\n\t\t\t\t MA35_IER_TIME_OUT_EN | MA35_IER_BUFERR_IEN)\n\n#define MA35_ISR_IF_CHECK\t(MA35_ISR_RDA_IF | MA35_ISR_RXTO_IF | \\\n\t\t\t\t MA35_ISR_THRE_INT | MA35_ISR_BUFEIF)\n\n#define MA35_FSR_TX_BOTH_EMPTY\t(MA35_FSR_TE_FLAG | MA35_FSR_TX_EMPTY)\n\nstatic struct uart_driver ma35d1serial_reg;\n\nstruct uart_ma35d1_port {\n\tstruct uart_port port;\n\tstruct clk *clk;\n\tu16 capabilities;  \n\tu8 ier;\n\tu8 lcr;\n\tu8 mcr;\n\tu32 baud_rate;\n\tu32 console_baud_rate;\n\tu32 console_line;\n\tu32 console_int;\n};\n\nstatic struct uart_ma35d1_port ma35d1serial_ports[MA35_UART_NR];\n\nstatic struct uart_ma35d1_port *to_ma35d1_uart_port(struct uart_port *uart)\n{\n\treturn container_of(uart, struct uart_ma35d1_port, port);\n}\n\nstatic u32 serial_in(struct uart_ma35d1_port *p, u32 offset)\n{\n\treturn readl_relaxed(p->port.membase + offset);\n}\n\nstatic void serial_out(struct uart_ma35d1_port *p, u32 offset, u32 value)\n{\n\twritel_relaxed(value, p->port.membase + offset);\n}\n\nstatic void __stop_tx(struct uart_ma35d1_port *p)\n{\n\tu32 ier;\n\n\tier = serial_in(p, MA35_IER_REG);\n\tif (ier & MA35_IER_THRE_IEN)\n\t\tserial_out(p, MA35_IER_REG, ier & ~MA35_IER_THRE_IEN);\n}\n\nstatic void ma35d1serial_stop_tx(struct uart_port *port)\n{\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\n\t__stop_tx(up);\n}\n\nstatic void transmit_chars(struct uart_ma35d1_port *up)\n{\n\tu32 count;\n\tu8 ch;\n\n\tif (uart_tx_stopped(&up->port)) {\n\t\tma35d1serial_stop_tx(&up->port);\n\t\treturn;\n\t}\n\tcount = MA35_UART_FIFO_DEPTH - FIELD_GET(MA35_FSR_TXPTR_MSK,\n\t\t\t\t\t\t serial_in(up, MA35_FSR_REG));\n\tuart_port_tx_limited(&up->port, ch, count,\n\t\t\t     !(serial_in(up, MA35_FSR_REG) & MA35_FSR_TX_FULL),\n\t\t\t     serial_out(up, MA35_THR_REG, ch),\n\t\t\t     ({}));\n}\n\nstatic void ma35d1serial_start_tx(struct uart_port *port)\n{\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\tu32 ier;\n\n\tier = serial_in(up, MA35_IER_REG);\n\tserial_out(up, MA35_IER_REG, ier & ~MA35_IER_THRE_IEN);\n\ttransmit_chars(up);\n\tserial_out(up, MA35_IER_REG, ier | MA35_IER_THRE_IEN);\n}\n\nstatic void ma35d1serial_stop_rx(struct uart_port *port)\n{\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\tu32 ier;\n\n\tier = serial_in(up, MA35_IER_REG);\n\tier &= ~MA35_IER_RDA_IEN;\n\tserial_out(up, MA35_IER_REG, ier);\n}\n\nstatic void receive_chars(struct uart_ma35d1_port *up)\n{\n\tint max_count = 256;\n\tu8 ch, flag;\n\tu32 fsr;\n\n\tfsr = serial_in(up, MA35_FSR_REG);\n\tdo {\n\t\tflag = TTY_NORMAL;\n\t\tup->port.icount.rx++;\n\n\t\tif (unlikely(fsr & (MA35_FSR_BIF | MA35_FSR_FEF |\n\t\t\t\t    MA35_FSR_PEF | MA35_FSR_RX_OVER_IF))) {\n\t\t\tif (fsr & MA35_FSR_BIF) {\n\t\t\t\tup->port.icount.brk++;\n\t\t\t\tif (uart_handle_break(&up->port))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fsr & MA35_FSR_FEF)\n\t\t\t\tup->port.icount.frame++;\n\t\t\tif (fsr & MA35_FSR_PEF)\n\t\t\t\tup->port.icount.parity++;\n\t\t\tif (fsr & MA35_FSR_RX_OVER_IF)\n\t\t\t\tup->port.icount.overrun++;\n\n\t\t\tserial_out(up, MA35_FSR_REG,\n\t\t\t\t   fsr & (MA35_FSR_BIF | MA35_FSR_FEF |\n\t\t\t\t\t  MA35_FSR_PEF | MA35_FSR_RX_OVER_IF));\n\t\t\tif (fsr & MA35_FSR_BIF)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (fsr & MA35_FSR_PEF)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (fsr & MA35_FSR_FEF)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tch = serial_in(up, MA35_RBR_REG);\n\t\tif (uart_handle_sysrq_char(&up->port, ch))\n\t\t\tcontinue;\n\n\t\tspin_lock(&up->port.lock);\n\t\tuart_insert_char(&up->port, fsr, MA35_FSR_RX_OVER_IF, ch, flag);\n\t\tspin_unlock(&up->port.lock);\n\n\t\tfsr = serial_in(up, MA35_FSR_REG);\n\t} while (!(fsr & MA35_FSR_RX_EMPTY) && (max_count-- > 0));\n\n\tspin_lock(&up->port.lock);\n\ttty_flip_buffer_push(&up->port.state->port);\n\tspin_unlock(&up->port.lock);\n}\n\nstatic irqreturn_t ma35d1serial_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\tu32 isr, fsr;\n\n\tisr = serial_in(up, MA35_ISR_REG);\n\tfsr = serial_in(up, MA35_FSR_REG);\n\n\tif (!(isr & MA35_ISR_IF_CHECK))\n\t\treturn IRQ_NONE;\n\n\tif (isr & (MA35_ISR_RDA_IF | MA35_ISR_RXTO_IF))\n\t\treceive_chars(up);\n\tif (isr & MA35_ISR_THRE_INT)\n\t\ttransmit_chars(up);\n\tif (fsr & MA35_FSR_TX_OVER_IF)\n\t\tserial_out(up, MA35_FSR_REG, MA35_FSR_TX_OVER_IF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 ma35d1serial_tx_empty(struct uart_port *port)\n{\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\tu32 fsr;\n\n\tfsr = serial_in(up, MA35_FSR_REG);\n\tif ((fsr & MA35_FSR_TX_BOTH_EMPTY) == MA35_FSR_TX_BOTH_EMPTY)\n\t\treturn TIOCSER_TEMT;\n\telse\n\t\treturn 0;\n}\n\nstatic u32 ma35d1serial_get_mctrl(struct uart_port *port)\n{\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\tu32 status;\n\tu32 ret = 0;\n\n\tstatus = serial_in(up, MA35_MSR_REG);\n\tif (!(status & MA35_MSR_CTSSTS))\n\t\tret |= TIOCM_CTS;\n\treturn ret;\n}\n\nstatic void ma35d1serial_set_mctrl(struct uart_port *port, u32 mctrl)\n{\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\tu32 mcr, msr, ier;\n\n\tmcr = serial_in(up, MA35_MCR_REG);\n\tmcr &= ~MA35_MCR_RTS_CTRL;\n\n\tif (mctrl & TIOCM_RTS)\n\t\tmcr |= MA35_MCR_RTSACTLV;\n\telse\n\t\tmcr &= ~MA35_MCR_RTSACTLV;\n\n\tif (up->mcr & UART_MCR_AFE) {\n\t\tier = serial_in(up, MA35_IER_REG);\n\t\tier |= MA35_IER_AUTO_RTS | MA35_IER_AUTO_CTS;\n\t\tserial_out(up, MA35_IER_REG, ier);\n\t\tup->port.flags |= UPF_HARD_FLOW;\n\t} else {\n\t\tier = serial_in(up, MA35_IER_REG);\n\t\tier &= ~(MA35_IER_AUTO_RTS | MA35_IER_AUTO_CTS);\n\t\tserial_out(up, MA35_IER_REG, ier);\n\t\tup->port.flags &= ~UPF_HARD_FLOW;\n\t}\n\n\tmsr = serial_in(up, MA35_MSR_REG);\n\tmsr |= MA35_MSR_CTSACTLV;\n\tserial_out(up, MA35_MSR_REG, msr);\n\tserial_out(up, MA35_MCR_REG, mcr);\n}\n\nstatic void ma35d1serial_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\tunsigned long flags;\n\tu32 lcr;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tlcr = serial_in(up, MA35_LCR_REG);\n\tif (break_state != 0)\n\t\tlcr |= MA35_LCR_BREAK;\n\telse\n\t\tlcr &= ~MA35_LCR_BREAK;\n\tserial_out(up, MA35_LCR_REG, lcr);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic int ma35d1serial_startup(struct uart_port *port)\n{\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\tu32 fcr;\n\tint retval;\n\n\t \n\tserial_out(up, MA35_FCR_REG, MA35_FCR_TFR | MA35_FCR_RFR);\n\n\t \n\tserial_out(up, MA35_ISR_REG, MA35_ISR_ALL);\n\n\tretval = request_irq(port->irq, ma35d1serial_interrupt, 0,\n\t\t\t     dev_name(port->dev), port);\n\tif (retval) {\n\t\tdev_err(up->port.dev, \"request irq failed.\\n\");\n\t\treturn retval;\n\t}\n\n\tfcr = serial_in(up, MA35_FCR_REG);\n\tfcr |= MA35_FCR_RFITL_4BYTES | MA35_FCR_RTSTL_8BYTES;\n\tserial_out(up, MA35_FCR_REG, fcr);\n\tserial_out(up, MA35_LCR_REG, MA35_LCR_WLS_8BITS);\n\tserial_out(up, MA35_TOR_REG, MA35_UART_RX_TOUT);\n\tserial_out(up, MA35_IER_REG, MA35_IER_CONFIG);\n\treturn 0;\n}\n\nstatic void ma35d1serial_shutdown(struct uart_port *port)\n{\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\n\tserial_out(up, MA35_IER_REG, 0);\n\tfree_irq(port->irq, port);\n}\n\nstatic void ma35d1serial_set_termios(struct uart_port *port,\n\t\t\t\t     struct ktermios *termios,\n\t\t\t\t     const struct ktermios *old)\n{\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\tunsigned long flags;\n\tu32 baud, quot;\n\tu32 lcr = 0;\n\n\tlcr = UART_LCR_WLEN(tty_get_char_size(termios->c_cflag));\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tlcr |= MA35_LCR_NSB;\n\tif (termios->c_cflag & PARENB)\n\t\tlcr |= MA35_LCR_PBE;\n\tif (!(termios->c_cflag & PARODD))\n\t\tlcr |= MA35_LCR_EPE;\n\tif (termios->c_cflag & CMSPAR)\n\t\tlcr |= MA35_LCR_SPE;\n\n\tbaud = uart_get_baud_rate(port, termios, old,\n\t\t\t\t  port->uartclk / MA35_BAUD_DIV_MAX,\n\t\t\t\t  port->uartclk / MA35_BAUD_DIV_MIN);\n\n\t \n\tquot = (port->uartclk / baud) - 2;\n\n\t \n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tup->port.read_status_mask = MA35_FSR_RX_OVER_IF;\n\tif (termios->c_iflag & INPCK)\n\t\tup->port.read_status_mask |= MA35_FSR_FEF | MA35_FSR_PEF;\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tup->port.read_status_mask |= MA35_FSR_BIF;\n\n\t \n\tup->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tup->port.ignore_status_mask |= MA35_FSR_FEF | MA35_FSR_PEF;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tup->port.ignore_status_mask |= MA35_FSR_BIF;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tup->port.ignore_status_mask |= MA35_FSR_RX_OVER_IF;\n\t}\n\tif (termios->c_cflag & CRTSCTS)\n\t\tup->mcr |= UART_MCR_AFE;\n\telse\n\t\tup->mcr &= ~UART_MCR_AFE;\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tma35d1serial_set_mctrl(&up->port, up->port.mctrl);\n\n\tserial_out(up, MA35_BAUD_REG, MA35_BAUD_MODE2 | FIELD_PREP(MA35_BAUD_MASK, quot));\n\n\tserial_out(up, MA35_LCR_REG, lcr);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic const char *ma35d1serial_type(struct uart_port *port)\n{\n\treturn \"ma35d1-uart\";\n}\n\nstatic void ma35d1serial_config_port(struct uart_port *port, int flags)\n{\n\t \n\tport->type = 1;\n}\n\nstatic int ma35d1serial_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tif (port->type != PORT_UNKNOWN && ser->type != 1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct uart_ops ma35d1serial_ops = {\n\t.tx_empty     = ma35d1serial_tx_empty,\n\t.set_mctrl    = ma35d1serial_set_mctrl,\n\t.get_mctrl    = ma35d1serial_get_mctrl,\n\t.stop_tx      = ma35d1serial_stop_tx,\n\t.start_tx     = ma35d1serial_start_tx,\n\t.stop_rx      = ma35d1serial_stop_rx,\n\t.break_ctl    = ma35d1serial_break_ctl,\n\t.startup      = ma35d1serial_startup,\n\t.shutdown     = ma35d1serial_shutdown,\n\t.set_termios  = ma35d1serial_set_termios,\n\t.type         = ma35d1serial_type,\n\t.config_port  = ma35d1serial_config_port,\n\t.verify_port  = ma35d1serial_verify_port,\n};\n\nstatic const struct of_device_id ma35d1_serial_of_match[] = {\n\t{ .compatible = \"nuvoton,ma35d1-uart\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ma35d1_serial_of_match);\n\n#ifdef CONFIG_SERIAL_NUVOTON_MA35D1_CONSOLE\n\nstatic struct device_node *ma35d1serial_uart_nodes[MA35_UART_NR];\n\nstatic void wait_for_xmitr(struct uart_ma35d1_port *up)\n{\n\tunsigned int reg = 0;\n\n\tread_poll_timeout_atomic(serial_in, reg, reg & MA35_FSR_TX_EMPTY,\n\t\t\t\t 1, 10000, false,\n\t\t\t\t up, MA35_FSR_REG);\n}\n\nstatic void ma35d1serial_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\n\twait_for_xmitr(up);\n\tserial_out(up, MA35_THR_REG, ch);\n}\n\n \nstatic void ma35d1serial_console_write(struct console *co, const char *s, u32 count)\n{\n\tstruct uart_ma35d1_port *up;\n\tunsigned long flags;\n\tint locked = 1;\n\tu32 ier;\n\n\tif ((co->index < 0) || (co->index >= MA35_UART_NR)) {\n\t\tpr_warn(\"Failed to write on ononsole port %x, out of range\\n\",\n\t\t\tco->index);\n\t\treturn;\n\t}\n\n\tup = &ma35d1serial_ports[co->index];\n\n\tif (up->port.sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&up->port.lock, flags);\n\telse\n\t\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t \n\tier = serial_in(up, MA35_IER_REG);\n\tserial_out(up, MA35_IER_REG, 0);\n\n\tuart_console_write(&up->port, s, count, ma35d1serial_console_putchar);\n\n\twait_for_xmitr(up);\n\tserial_out(up, MA35_IER_REG, ier);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic int __init ma35d1serial_console_setup(struct console *co, char *options)\n{\n\tstruct device_node *np;\n\tstruct uart_ma35d1_port *p;\n\tu32 val32[4];\n\tstruct uart_port *port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif ((co->index < 0) || (co->index >= MA35_UART_NR)) {\n\t\tpr_debug(\"Console Port%x out of range\\n\", co->index);\n\t\treturn -EINVAL;\n\t}\n\n\tnp = ma35d1serial_uart_nodes[co->index];\n\tp = &ma35d1serial_ports[co->index];\n\tif (!np || !p)\n\t\treturn -ENODEV;\n\n\tif (of_property_read_u32_array(np, \"reg\", val32, ARRAY_SIZE(val32)) != 0)\n\t\treturn -EINVAL;\n\n\tp->port.iobase = val32[1];\n\tp->port.membase = ioremap(p->port.iobase, MA35_UART_REG_SIZE);\n\tif (!p->port.membase)\n\t\treturn -ENOMEM;\n\n\tp->port.ops = &ma35d1serial_ops;\n\tp->port.line = 0;\n\tp->port.uartclk = MA35_UART_CONSOLE_CLK;\n\n\tport = &ma35d1serial_ports[co->index].port;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct console ma35d1serial_console = {\n\t.name    = \"ttyNVT\",\n\t.write   = ma35d1serial_console_write,\n\t.device  = uart_console_device,\n\t.setup   = ma35d1serial_console_setup,\n\t.flags   = CON_PRINTBUFFER | CON_ENABLED,\n\t.index   = -1,\n\t.data    = &ma35d1serial_reg,\n};\n\nstatic void ma35d1serial_console_init_port(void)\n{\n\tu32 i = 0;\n\tstruct device_node *np;\n\n\tfor_each_matching_node(np, ma35d1_serial_of_match) {\n\t\tif (ma35d1serial_uart_nodes[i] == NULL) {\n\t\t\tof_node_get(np);\n\t\t\tma35d1serial_uart_nodes[i] = np;\n\t\t\ti++;\n\t\t\tif (i == MA35_UART_NR)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int __init ma35d1serial_console_init(void)\n{\n\tma35d1serial_console_init_port();\n\tregister_console(&ma35d1serial_console);\n\treturn 0;\n}\nconsole_initcall(ma35d1serial_console_init);\n\n#define MA35D1SERIAL_CONSOLE    (&ma35d1serial_console)\n#else\n#define MA35D1SERIAL_CONSOLE    NULL\n#endif\n\nstatic struct uart_driver ma35d1serial_reg = {\n\t.owner        = THIS_MODULE,\n\t.driver_name  = \"serial\",\n\t.dev_name     = \"ttyNVT\",\n\t.major        = TTY_MAJOR,\n\t.minor        = 64,\n\t.cons         = MA35D1SERIAL_CONSOLE,\n\t.nr           = MA35_UART_NR,\n};\n\n \nstatic int ma35d1serial_probe(struct platform_device *pdev)\n{\n\tstruct resource *res_mem;\n\tstruct uart_ma35d1_port *up;\n\tint ret = 0;\n\n\tif (pdev->dev.of_node) {\n\t\tret = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to get alias/pdev id, errno %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tup = &ma35d1serial_ports[ret];\n\tup->port.line = ret;\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res_mem)\n\t\treturn -ENODEV;\n\n\tup->port.iobase = res_mem->start;\n\tup->port.membase = ioremap(up->port.iobase, MA35_UART_REG_SIZE);\n\tup->port.ops = &ma35d1serial_ops;\n\n\tspin_lock_init(&up->port.lock);\n\n\tup->clk = of_clk_get(pdev->dev.of_node, 0);\n\tif (IS_ERR(up->clk)) {\n\t\tret = PTR_ERR(up->clk);\n\t\tdev_err(&pdev->dev, \"failed to get core clk: %d\\n\", ret);\n\t\tgoto err_iounmap;\n\t}\n\n\tret = clk_prepare_enable(up->clk);\n\tif (ret)\n\t\tgoto err_iounmap;\n\n\tif (up->port.line != 0)\n\t\tup->port.uartclk = clk_get_rate(up->clk);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_clk_disable;\n\n\tup->port.irq = ret;\n\tup->port.dev = &pdev->dev;\n\tup->port.flags = UPF_BOOT_AUTOCONF;\n\n\tplatform_set_drvdata(pdev, up);\n\n\tret = uart_add_one_port(&ma35d1serial_reg, &up->port);\n\tif (ret < 0)\n\t\tgoto err_free_irq;\n\n\treturn 0;\n\nerr_free_irq:\n\tfree_irq(up->port.irq, &up->port);\n\nerr_clk_disable:\n\tclk_disable_unprepare(up->clk);\n\nerr_iounmap:\n\tiounmap(up->port.membase);\n\treturn ret;\n}\n\n \nstatic int ma35d1serial_remove(struct platform_device *dev)\n{\n\tstruct uart_port *port = platform_get_drvdata(dev);\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\n\tuart_remove_one_port(&ma35d1serial_reg, port);\n\tclk_disable_unprepare(up->clk);\n\treturn 0;\n}\n\nstatic int ma35d1serial_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct uart_port *port = platform_get_drvdata(dev);\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\n\tuart_suspend_port(&ma35d1serial_reg, &up->port);\n\tif (up->port.line == 0) {\n\t\tup->console_baud_rate = serial_in(up, MA35_BAUD_REG);\n\t\tup->console_line = serial_in(up, MA35_LCR_REG);\n\t\tup->console_int = serial_in(up, MA35_IER_REG);\n\t}\n\treturn 0;\n}\n\nstatic int ma35d1serial_resume(struct platform_device *dev)\n{\n\tstruct uart_port *port = platform_get_drvdata(dev);\n\tstruct uart_ma35d1_port *up = to_ma35d1_uart_port(port);\n\n\tif (up->port.line == 0) {\n\t\tserial_out(up, MA35_BAUD_REG, up->console_baud_rate);\n\t\tserial_out(up, MA35_LCR_REG, up->console_line);\n\t\tserial_out(up, MA35_IER_REG, up->console_int);\n\t}\n\tuart_resume_port(&ma35d1serial_reg, &up->port);\n\treturn 0;\n}\n\nstatic struct platform_driver ma35d1serial_driver = {\n\t.probe      = ma35d1serial_probe,\n\t.remove     = ma35d1serial_remove,\n\t.suspend    = ma35d1serial_suspend,\n\t.resume     = ma35d1serial_resume,\n\t.driver     = {\n\t\t.name   = \"ma35d1-uart\",\n\t\t.of_match_table = of_match_ptr(ma35d1_serial_of_match),\n\t},\n};\n\nstatic int __init ma35d1serial_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&ma35d1serial_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&ma35d1serial_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&ma35d1serial_reg);\n\n\treturn ret;\n}\n\nstatic void __exit ma35d1serial_exit(void)\n{\n\tplatform_driver_unregister(&ma35d1serial_driver);\n\tuart_unregister_driver(&ma35d1serial_reg);\n}\n\nmodule_init(ma35d1serial_init);\nmodule_exit(ma35d1serial_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MA35D1 serial driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}