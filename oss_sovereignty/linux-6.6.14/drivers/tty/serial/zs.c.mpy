{
  "module_name": "zs.c",
  "hash_id": "af85cba9be72e4a3d9fb9ab15c2562f4d8f55956772c341f56760d1d2cded092",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/zs.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/irqflags.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/major.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/spinlock.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/types.h>\n\n#include <linux/atomic.h>\n\n#include <asm/dec/interrupts.h>\n#include <asm/dec/ioasic_addrs.h>\n#include <asm/dec/system.h>\n\n#include \"zs.h\"\n\n\nMODULE_AUTHOR(\"Maciej W. Rozycki <macro@linux-mips.org>\");\nMODULE_DESCRIPTION(\"DECstation Z85C30 serial driver\");\nMODULE_LICENSE(\"GPL\");\n\n\nstatic char zs_name[] __initdata = \"DECstation Z85C30 serial driver version \";\nstatic char zs_version[] __initdata = \"0.10\";\n\n \n#define ZS_NUM_SCCS\t2\t\t \n#define ZS_NUM_CHAN\t2\t\t \n#define ZS_CHAN_A\t0\t\t \n#define ZS_CHAN_B\t1\t\t \n#define ZS_CHAN_IO_SIZE 8\t\t \n#define ZS_CHAN_IO_STRIDE 4\t\t \n#define ZS_CHAN_IO_OFFSET 1\t\t \n#define ZS_CLOCK        7372800 \t \n\n#define to_zport(uport) container_of(uport, struct zs_port, port)\n\nstruct zs_parms {\n\tresource_size_t scc[ZS_NUM_SCCS];\n\tint irq[ZS_NUM_SCCS];\n};\n\nstatic struct zs_scc zs_sccs[ZS_NUM_SCCS];\n\nstatic u8 zs_init_regs[ZS_NUM_REGS] __initdata = {\n\t0,\t\t\t\t \n\tPAR_SPEC,\t\t\t \n\t0,\t\t\t\t \n\t0,\t\t\t\t \n\tX16CLK | SB1,\t\t\t \n\t0,\t\t\t\t \n\t0, 0, 0,\t\t\t \n\tMIE | DLC | NV,\t\t\t \n\tNRZ,\t\t\t\t \n\tTCBR | RCBR,\t\t\t \n\t0, 0,\t\t\t\t \n\tBRSRC | BRENABL,\t\t \n\t0,\t\t\t\t \n};\n\n \n#undef ZS_DEBUG_REGS\n\n\n \nstatic void recovery_delay(void)\n{\n\tudelay(2);\n}\n\nstatic u8 read_zsreg(struct zs_port *zport, int reg)\n{\n\tvoid __iomem *control = zport->port.membase + ZS_CHAN_IO_OFFSET;\n\tu8 retval;\n\n\tif (reg != 0) {\n\t\twriteb(reg & 0xf, control);\n\t\tfast_iob();\n\t\trecovery_delay();\n\t}\n\tretval = readb(control);\n\trecovery_delay();\n\treturn retval;\n}\n\nstatic void write_zsreg(struct zs_port *zport, int reg, u8 value)\n{\n\tvoid __iomem *control = zport->port.membase + ZS_CHAN_IO_OFFSET;\n\n\tif (reg != 0) {\n\t\twriteb(reg & 0xf, control);\n\t\tfast_iob(); recovery_delay();\n\t}\n\twriteb(value, control);\n\tfast_iob();\n\trecovery_delay();\n\treturn;\n}\n\nstatic u8 read_zsdata(struct zs_port *zport)\n{\n\tvoid __iomem *data = zport->port.membase +\n\t\t\t     ZS_CHAN_IO_STRIDE + ZS_CHAN_IO_OFFSET;\n\tu8 retval;\n\n\tretval = readb(data);\n\trecovery_delay();\n\treturn retval;\n}\n\nstatic void write_zsdata(struct zs_port *zport, u8 value)\n{\n\tvoid __iomem *data = zport->port.membase +\n\t\t\t     ZS_CHAN_IO_STRIDE + ZS_CHAN_IO_OFFSET;\n\n\twriteb(value, data);\n\tfast_iob();\n\trecovery_delay();\n\treturn;\n}\n\n#ifdef ZS_DEBUG_REGS\nvoid zs_dump(void)\n{\n\tstruct zs_port *zport;\n\tint i, j;\n\n\tfor (i = 0; i < ZS_NUM_SCCS * ZS_NUM_CHAN; i++) {\n\t\tzport = &zs_sccs[i / ZS_NUM_CHAN].zport[i % ZS_NUM_CHAN];\n\n\t\tif (!zport->scc)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tprintk(\"W%-2d = 0x%02x\\t\", j, zport->regs[j]);\n\t\tprintk(\"\\n\");\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tprintk(\"R%-2d = 0x%02x\\t\", j, read_zsreg(zport, j));\n\t\tprintk(\"\\n\\n\");\n\t}\n}\n#endif\n\n\nstatic void zs_spin_lock_cond_irq(spinlock_t *lock, int irq)\n{\n\tif (irq)\n\t\tspin_lock_irq(lock);\n\telse\n\t\tspin_lock(lock);\n}\n\nstatic void zs_spin_unlock_cond_irq(spinlock_t *lock, int irq)\n{\n\tif (irq)\n\t\tspin_unlock_irq(lock);\n\telse\n\t\tspin_unlock(lock);\n}\n\nstatic int zs_receive_drain(struct zs_port *zport)\n{\n\tint loops = 10000;\n\n\twhile ((read_zsreg(zport, R0) & Rx_CH_AV) && --loops)\n\t\tread_zsdata(zport);\n\treturn loops;\n}\n\nstatic int zs_transmit_drain(struct zs_port *zport, int irq)\n{\n\tstruct zs_scc *scc = zport->scc;\n\tint loops = 10000;\n\n\twhile (!(read_zsreg(zport, R0) & Tx_BUF_EMP) && --loops) {\n\t\tzs_spin_unlock_cond_irq(&scc->zlock, irq);\n\t\tudelay(2);\n\t\tzs_spin_lock_cond_irq(&scc->zlock, irq);\n\t}\n\treturn loops;\n}\n\nstatic int zs_line_drain(struct zs_port *zport, int irq)\n{\n\tstruct zs_scc *scc = zport->scc;\n\tint loops = 10000;\n\n\twhile (!(read_zsreg(zport, R1) & ALL_SNT) && --loops) {\n\t\tzs_spin_unlock_cond_irq(&scc->zlock, irq);\n\t\tudelay(2);\n\t\tzs_spin_lock_cond_irq(&scc->zlock, irq);\n\t}\n\treturn loops;\n}\n\n\nstatic void load_zsregs(struct zs_port *zport, u8 *regs, int irq)\n{\n\t \n\tzs_line_drain(zport, irq);\n\t \n\twrite_zsreg(zport, R3, regs[3] & ~RxENABLE);\n\twrite_zsreg(zport, R5, regs[5] & ~TxENAB);\n\twrite_zsreg(zport, R4, regs[4]);\n\twrite_zsreg(zport, R9, regs[9]);\n\twrite_zsreg(zport, R1, regs[1]);\n\twrite_zsreg(zport, R2, regs[2]);\n\twrite_zsreg(zport, R10, regs[10]);\n\twrite_zsreg(zport, R14, regs[14] & ~BRENABL);\n\twrite_zsreg(zport, R11, regs[11]);\n\twrite_zsreg(zport, R12, regs[12]);\n\twrite_zsreg(zport, R13, regs[13]);\n\twrite_zsreg(zport, R14, regs[14]);\n\twrite_zsreg(zport, R15, regs[15]);\n\tif (regs[3] & RxENABLE)\n\t\twrite_zsreg(zport, R3, regs[3]);\n\tif (regs[5] & TxENAB)\n\t\twrite_zsreg(zport, R5, regs[5]);\n\treturn;\n}\n\n\n \n\n \nstatic unsigned int zs_tx_empty(struct uart_port *uport)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\tunsigned long flags;\n\tu8 status;\n\n\tspin_lock_irqsave(&scc->zlock, flags);\n\tstatus = read_zsreg(zport, R1);\n\tspin_unlock_irqrestore(&scc->zlock, flags);\n\n\treturn status & ALL_SNT ? TIOCSER_TEMT : 0;\n}\n\nstatic unsigned int zs_raw_get_ab_mctrl(struct zs_port *zport_a,\n\t\t\t\t\tstruct zs_port *zport_b)\n{\n\tu8 status_a, status_b;\n\tunsigned int mctrl;\n\n\tstatus_a = read_zsreg(zport_a, R0);\n\tstatus_b = read_zsreg(zport_b, R0);\n\n\tmctrl = ((status_b & CTS) ? TIOCM_CTS : 0) |\n\t\t((status_b & DCD) ? TIOCM_CAR : 0) |\n\t\t((status_a & DCD) ? TIOCM_RNG : 0) |\n\t\t((status_a & SYNC_HUNT) ? TIOCM_DSR : 0);\n\n\treturn mctrl;\n}\n\nstatic unsigned int zs_raw_get_mctrl(struct zs_port *zport)\n{\n\tstruct zs_port *zport_a = &zport->scc->zport[ZS_CHAN_A];\n\n\treturn zport != zport_a ? zs_raw_get_ab_mctrl(zport_a, zport) : 0;\n}\n\nstatic unsigned int zs_raw_xor_mctrl(struct zs_port *zport)\n{\n\tstruct zs_port *zport_a = &zport->scc->zport[ZS_CHAN_A];\n\tunsigned int mmask, mctrl, delta;\n\tu8 mask_a, mask_b;\n\n\tif (zport == zport_a)\n\t\treturn 0;\n\n\tmask_a = zport_a->regs[15];\n\tmask_b = zport->regs[15];\n\n\tmmask = ((mask_b & CTSIE) ? TIOCM_CTS : 0) |\n\t\t((mask_b & DCDIE) ? TIOCM_CAR : 0) |\n\t\t((mask_a & DCDIE) ? TIOCM_RNG : 0) |\n\t\t((mask_a & SYNCIE) ? TIOCM_DSR : 0);\n\n\tmctrl = zport->mctrl;\n\tif (mmask) {\n\t\tmctrl &= ~mmask;\n\t\tmctrl |= zs_raw_get_ab_mctrl(zport_a, zport) & mmask;\n\t}\n\n\tdelta = mctrl ^ zport->mctrl;\n\tif (delta)\n\t\tzport->mctrl = mctrl;\n\n\treturn delta;\n}\n\nstatic unsigned int zs_get_mctrl(struct uart_port *uport)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\tunsigned int mctrl;\n\n\tspin_lock(&scc->zlock);\n\tmctrl = zs_raw_get_mctrl(zport);\n\tspin_unlock(&scc->zlock);\n\n\treturn mctrl;\n}\n\nstatic void zs_set_mctrl(struct uart_port *uport, unsigned int mctrl)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\tstruct zs_port *zport_a = &scc->zport[ZS_CHAN_A];\n\tu8 oldloop, newloop;\n\n\tspin_lock(&scc->zlock);\n\tif (zport != zport_a) {\n\t\tif (mctrl & TIOCM_DTR)\n\t\t\tzport_a->regs[5] |= DTR;\n\t\telse\n\t\t\tzport_a->regs[5] &= ~DTR;\n\t\tif (mctrl & TIOCM_RTS)\n\t\t\tzport_a->regs[5] |= RTS;\n\t\telse\n\t\t\tzport_a->regs[5] &= ~RTS;\n\t\twrite_zsreg(zport_a, R5, zport_a->regs[5]);\n\t}\n\n\t \n\toldloop = zport->regs[14];\n\tnewloop = oldloop;\n\tif (mctrl & TIOCM_LOOP)\n\t\tnewloop |= LOOPBAK;\n\telse\n\t\tnewloop &= ~LOOPBAK;\n\tif (newloop != oldloop) {\n\t\tzport->regs[14] = newloop;\n\t\twrite_zsreg(zport, R14, zport->regs[14]);\n\t}\n\tspin_unlock(&scc->zlock);\n}\n\nstatic void zs_raw_stop_tx(struct zs_port *zport)\n{\n\twrite_zsreg(zport, R0, RES_Tx_P);\n\tzport->tx_stopped = 1;\n}\n\nstatic void zs_stop_tx(struct uart_port *uport)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\n\tspin_lock(&scc->zlock);\n\tzs_raw_stop_tx(zport);\n\tspin_unlock(&scc->zlock);\n}\n\nstatic void zs_raw_transmit_chars(struct zs_port *);\n\nstatic void zs_start_tx(struct uart_port *uport)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\n\tspin_lock(&scc->zlock);\n\tif (zport->tx_stopped) {\n\t\tzs_transmit_drain(zport, 0);\n\t\tzport->tx_stopped = 0;\n\t\tzs_raw_transmit_chars(zport);\n\t}\n\tspin_unlock(&scc->zlock);\n}\n\nstatic void zs_stop_rx(struct uart_port *uport)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\tstruct zs_port *zport_a = &scc->zport[ZS_CHAN_A];\n\n\tspin_lock(&scc->zlock);\n\tzport->regs[15] &= ~BRKIE;\n\tzport->regs[1] &= ~(RxINT_MASK | TxINT_ENAB);\n\tzport->regs[1] |= RxINT_DISAB;\n\n\tif (zport != zport_a) {\n\t\t \n\t\tzport_a->regs[15] &= ~(DCDIE | SYNCIE);\n\t\twrite_zsreg(zport_a, R15, zport_a->regs[15]);\n\t\tif (!(zport_a->regs[15] & BRKIE)) {\n\t\t\tzport_a->regs[1] &= ~EXT_INT_ENAB;\n\t\t\twrite_zsreg(zport_a, R1, zport_a->regs[1]);\n\t\t}\n\n\t\t \n\t\tzport->regs[15] &= ~(DCDIE | CTSIE);\n\t\tzport->regs[1] &= ~EXT_INT_ENAB;\n\t} else {\n\t\t \n\t\tif (!(zport->regs[15] & (DCDIE | SYNCIE)))\n\t\t\tzport->regs[1] &= ~EXT_INT_ENAB;\n\t}\n\n\twrite_zsreg(zport, R15, zport->regs[15]);\n\twrite_zsreg(zport, R1, zport->regs[1]);\n\tspin_unlock(&scc->zlock);\n}\n\nstatic void zs_enable_ms(struct uart_port *uport)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\tstruct zs_port *zport_a = &scc->zport[ZS_CHAN_A];\n\n\tif (zport == zport_a)\n\t\treturn;\n\n\tspin_lock(&scc->zlock);\n\n\t \n\tif (!(zport_a->regs[1] & EXT_INT_ENAB))\n\t\twrite_zsreg(zport_a, R0, RES_EXT_INT);\n\n\t \n\tzport_a->regs[1] |= EXT_INT_ENAB;\n\tzport_a->regs[15] |= DCDIE | SYNCIE;\n\n\t \n\tzport->regs[15] |= DCDIE | CTSIE;\n\n\tzs_raw_xor_mctrl(zport);\n\n\twrite_zsreg(zport_a, R1, zport_a->regs[1]);\n\twrite_zsreg(zport_a, R15, zport_a->regs[15]);\n\twrite_zsreg(zport, R15, zport->regs[15]);\n\tspin_unlock(&scc->zlock);\n}\n\nstatic void zs_break_ctl(struct uart_port *uport, int break_state)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&scc->zlock, flags);\n\tif (break_state == -1)\n\t\tzport->regs[5] |= SND_BRK;\n\telse\n\t\tzport->regs[5] &= ~SND_BRK;\n\twrite_zsreg(zport, R5, zport->regs[5]);\n\tspin_unlock_irqrestore(&scc->zlock, flags);\n}\n\n\n \n#define Rx_BRK 0x0100\t\t\t \n#define Rx_SYS 0x0200\t\t\t \n\nstatic void zs_receive_chars(struct zs_port *zport)\n{\n\tstruct uart_port *uport = &zport->port;\n\tstruct zs_scc *scc = zport->scc;\n\tstruct uart_icount *icount;\n\tunsigned int avail, status;\n\tint count;\n\tu8 ch, flag;\n\n\tfor (count = 16; count; count--) {\n\t\tspin_lock(&scc->zlock);\n\t\tavail = read_zsreg(zport, R0) & Rx_CH_AV;\n\t\tspin_unlock(&scc->zlock);\n\t\tif (!avail)\n\t\t\tbreak;\n\n\t\tspin_lock(&scc->zlock);\n\t\tstatus = read_zsreg(zport, R1) & (Rx_OVR | FRM_ERR | PAR_ERR);\n\t\tch = read_zsdata(zport);\n\t\tspin_unlock(&scc->zlock);\n\n\t\tflag = TTY_NORMAL;\n\n\t\ticount = &uport->icount;\n\t\ticount->rx++;\n\n\t\t \n\t\tif (!ch)\n\t\t\tstatus |= zport->tty_break;\n\t\tif (unlikely(status &\n\t\t\t     (Rx_OVR | FRM_ERR | PAR_ERR | Rx_SYS | Rx_BRK))) {\n\t\t\tzport->tty_break = 0;\n\n\t\t\t \n\t\t\tif (status & (Rx_OVR | FRM_ERR | PAR_ERR)) {\n\t\t\t\tspin_lock(&scc->zlock);\n\t\t\t\twrite_zsreg(zport, R0, ERR_RES);\n\t\t\t\tspin_unlock(&scc->zlock);\n\t\t\t}\n\n\t\t\tif (status & (Rx_SYS | Rx_BRK)) {\n\t\t\t\ticount->brk++;\n\t\t\t\t \n\t\t\t\tif (status & Rx_SYS)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (status & FRM_ERR)\n\t\t\t\ticount->frame++;\n\t\t\telse if (status & PAR_ERR)\n\t\t\t\ticount->parity++;\n\t\t\tif (status & Rx_OVR)\n\t\t\t\ticount->overrun++;\n\n\t\t\tstatus &= uport->read_status_mask;\n\t\t\tif (status & Rx_BRK)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (status & FRM_ERR)\n\t\t\t\tflag = TTY_FRAME;\n\t\t\telse if (status & PAR_ERR)\n\t\t\t\tflag = TTY_PARITY;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(uport, ch))\n\t\t\tcontinue;\n\n\t\tuart_insert_char(uport, status, Rx_OVR, ch, flag);\n\t}\n\n\ttty_flip_buffer_push(&uport->state->port);\n}\n\nstatic void zs_raw_transmit_chars(struct zs_port *zport)\n{\n\tstruct circ_buf *xmit = &zport->port.state->xmit;\n\n\t \n\tif (zport->port.x_char) {\n\t\twrite_zsdata(zport, zport->port.x_char);\n\t\tzport->port.icount.tx++;\n\t\tzport->port.x_char = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (uart_circ_empty(xmit) || uart_tx_stopped(&zport->port)) {\n\t\tzs_raw_stop_tx(zport);\n\t\treturn;\n\t}\n\n\t \n\twrite_zsdata(zport, xmit->buf[xmit->tail]);\n\tuart_xmit_advance(&zport->port, 1);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&zport->port);\n\n\t \n\tif (uart_circ_empty(xmit))\n\t\tzs_raw_stop_tx(zport);\n}\n\nstatic void zs_transmit_chars(struct zs_port *zport)\n{\n\tstruct zs_scc *scc = zport->scc;\n\n\tspin_lock(&scc->zlock);\n\tzs_raw_transmit_chars(zport);\n\tspin_unlock(&scc->zlock);\n}\n\nstatic void zs_status_handle(struct zs_port *zport, struct zs_port *zport_a)\n{\n\tstruct uart_port *uport = &zport->port;\n\tstruct zs_scc *scc = zport->scc;\n\tunsigned int delta;\n\tu8 status, brk;\n\n\tspin_lock(&scc->zlock);\n\n\t \n\tstatus = read_zsreg(zport, R0);\n\n\tif (zport->regs[15] & BRKIE) {\n\t\tbrk = status & BRK_ABRT;\n\t\tif (brk && !zport->brk) {\n\t\t\tspin_unlock(&scc->zlock);\n\t\t\tif (uart_handle_break(uport))\n\t\t\t\tzport->tty_break = Rx_SYS;\n\t\t\telse\n\t\t\t\tzport->tty_break = Rx_BRK;\n\t\t\tspin_lock(&scc->zlock);\n\t\t}\n\t\tzport->brk = brk;\n\t}\n\n\tif (zport != zport_a) {\n\t\tdelta = zs_raw_xor_mctrl(zport);\n\t\tspin_unlock(&scc->zlock);\n\n\t\tif (delta & TIOCM_CTS)\n\t\t\tuart_handle_cts_change(uport,\n\t\t\t\t\t       zport->mctrl & TIOCM_CTS);\n\t\tif (delta & TIOCM_CAR)\n\t\t\tuart_handle_dcd_change(uport,\n\t\t\t\t\t       zport->mctrl & TIOCM_CAR);\n\t\tif (delta & TIOCM_RNG)\n\t\t\tuport->icount.dsr++;\n\t\tif (delta & TIOCM_DSR)\n\t\t\tuport->icount.rng++;\n\n\t\tif (delta)\n\t\t\twake_up_interruptible(&uport->state->port.delta_msr_wait);\n\n\t\tspin_lock(&scc->zlock);\n\t}\n\n\t \n\twrite_zsreg(zport, R0, RES_EXT_INT);\n\n\tspin_unlock(&scc->zlock);\n}\n\n \nstatic irqreturn_t zs_interrupt(int irq, void *dev_id)\n{\n\tstruct zs_scc *scc = dev_id;\n\tstruct zs_port *zport_a = &scc->zport[ZS_CHAN_A];\n\tstruct zs_port *zport_b = &scc->zport[ZS_CHAN_B];\n\tirqreturn_t status = IRQ_NONE;\n\tu8 zs_intreg;\n\tint count;\n\n\t \n\tfor (count = 16; count; count--) {\n\t\tspin_lock(&scc->zlock);\n\t\tzs_intreg = read_zsreg(zport_a, R3);\n\t\tspin_unlock(&scc->zlock);\n\t\tif (!zs_intreg)\n\t\t\tbreak;\n\n\t\t \n\t\tif (zs_intreg & CHBRxIP)\n\t\t\tzs_receive_chars(zport_b);\n\t\tif (zs_intreg & CHARxIP)\n\t\t\tzs_receive_chars(zport_a);\n\t\tif (zs_intreg & CHBEXT)\n\t\t\tzs_status_handle(zport_b, zport_a);\n\t\tif (zs_intreg & CHAEXT)\n\t\t\tzs_status_handle(zport_a, zport_a);\n\t\tif (zs_intreg & CHBTxIP)\n\t\t\tzs_transmit_chars(zport_b);\n\t\tif (zs_intreg & CHATxIP)\n\t\t\tzs_transmit_chars(zport_a);\n\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\treturn status;\n}\n\n\n \nstatic int zs_startup(struct uart_port *uport)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\tunsigned long flags;\n\tint irq_guard;\n\tint ret;\n\n\tirq_guard = atomic_add_return(1, &scc->irq_guard);\n\tif (irq_guard == 1) {\n\t\tret = request_irq(zport->port.irq, zs_interrupt,\n\t\t\t\t  IRQF_SHARED, \"scc\", scc);\n\t\tif (ret) {\n\t\t\tatomic_add(-1, &scc->irq_guard);\n\t\t\tprintk(KERN_ERR \"zs: can't get irq %d\\n\",\n\t\t\t       zport->port.irq);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&scc->zlock, flags);\n\n\t \n\tzs_receive_drain(zport);\n\n\t \n\twrite_zsreg(zport, R0, ERR_RES);\n\twrite_zsreg(zport, R0, RES_Tx_P);\n\t \n\tif (!(zport->regs[1] & EXT_INT_ENAB))\n\t\twrite_zsreg(zport, R0, RES_EXT_INT);\n\n\t \n\tzport->regs[1] &= ~RxINT_MASK;\n\tzport->regs[1] |= RxINT_ALL | TxINT_ENAB | EXT_INT_ENAB;\n\tzport->regs[3] |= RxENABLE;\n\tzport->regs[15] |= BRKIE;\n\twrite_zsreg(zport, R1, zport->regs[1]);\n\twrite_zsreg(zport, R3, zport->regs[3]);\n\twrite_zsreg(zport, R5, zport->regs[5]);\n\twrite_zsreg(zport, R15, zport->regs[15]);\n\n\t \n\tzport->mctrl = zs_raw_get_mctrl(zport);\n\tzport->brk = read_zsreg(zport, R0) & BRK_ABRT;\n\n\tzport->tx_stopped = 1;\n\n\tspin_unlock_irqrestore(&scc->zlock, flags);\n\n\treturn 0;\n}\n\nstatic void zs_shutdown(struct uart_port *uport)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\tunsigned long flags;\n\tint irq_guard;\n\n\tspin_lock_irqsave(&scc->zlock, flags);\n\n\tzport->regs[3] &= ~RxENABLE;\n\twrite_zsreg(zport, R5, zport->regs[5]);\n\twrite_zsreg(zport, R3, zport->regs[3]);\n\n\tspin_unlock_irqrestore(&scc->zlock, flags);\n\n\tirq_guard = atomic_add_return(-1, &scc->irq_guard);\n\tif (!irq_guard)\n\t\tfree_irq(zport->port.irq, scc);\n}\n\n\nstatic void zs_reset(struct zs_port *zport)\n{\n\tstruct zs_scc *scc = zport->scc;\n\tint irq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&scc->zlock, flags);\n\tirq = !irqs_disabled_flags(flags);\n\tif (!scc->initialised) {\n\t\t \n\t\tread_zsreg(zport, R0);\n\t\t \n\t\tzs_line_drain(zport, irq);\n\t\twrite_zsreg(zport, R9, FHWRES);\n\t\tudelay(10);\n\t\twrite_zsreg(zport, R9, 0);\n\t\tscc->initialised = 1;\n\t}\n\tload_zsregs(zport, zport->regs, irq);\n\tspin_unlock_irqrestore(&scc->zlock, flags);\n}\n\nstatic void zs_set_termios(struct uart_port *uport, struct ktermios *termios,\n\t\t\t   const struct ktermios *old_termios)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\tstruct zs_port *zport_a = &scc->zport[ZS_CHAN_A];\n\tint irq;\n\tunsigned int baud, brg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&scc->zlock, flags);\n\tirq = !irqs_disabled_flags(flags);\n\n\t \n\tzport->regs[3] &= ~RxNBITS_MASK;\n\tzport->regs[5] &= ~TxNBITS_MASK;\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tzport->regs[3] |= Rx5;\n\t\tzport->regs[5] |= Tx5;\n\t\tbreak;\n\tcase CS6:\n\t\tzport->regs[3] |= Rx6;\n\t\tzport->regs[5] |= Tx6;\n\t\tbreak;\n\tcase CS7:\n\t\tzport->regs[3] |= Rx7;\n\t\tzport->regs[5] |= Tx7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tzport->regs[3] |= Rx8;\n\t\tzport->regs[5] |= Tx8;\n\t\tbreak;\n\t}\n\n\t \n\tzport->regs[4] &= ~(XCLK_MASK | SB_MASK | PAR_ENA | PAR_EVEN);\n\tif (termios->c_cflag & CSTOPB)\n\t\tzport->regs[4] |= SB2;\n\telse\n\t\tzport->regs[4] |= SB1;\n\tif (termios->c_cflag & PARENB)\n\t\tzport->regs[4] |= PAR_ENA;\n\tif (!(termios->c_cflag & PARODD))\n\t\tzport->regs[4] |= PAR_EVEN;\n\tswitch (zport->clk_mode) {\n\tcase 64:\n\t\tzport->regs[4] |= X64CLK;\n\t\tbreak;\n\tcase 32:\n\t\tzport->regs[4] |= X32CLK;\n\t\tbreak;\n\tcase 16:\n\t\tzport->regs[4] |= X16CLK;\n\t\tbreak;\n\tcase 1:\n\t\tzport->regs[4] |= X1CLK;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tbaud = uart_get_baud_rate(uport, termios, old_termios, 0,\n\t\t\t\t  uport->uartclk / zport->clk_mode / 4);\n\n\tbrg = ZS_BPS_TO_BRG(baud, uport->uartclk / zport->clk_mode);\n\tzport->regs[12] = brg & 0xff;\n\tzport->regs[13] = (brg >> 8) & 0xff;\n\n\tuart_update_timeout(uport, termios->c_cflag, baud);\n\n\tuport->read_status_mask = Rx_OVR;\n\tif (termios->c_iflag & INPCK)\n\t\tuport->read_status_mask |= FRM_ERR | PAR_ERR;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tuport->read_status_mask |= Rx_BRK;\n\n\tuport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tuport->ignore_status_mask |= FRM_ERR | PAR_ERR;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tuport->ignore_status_mask |= Rx_BRK;\n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tuport->ignore_status_mask |= Rx_OVR;\n\t}\n\n\tif (termios->c_cflag & CREAD)\n\t\tzport->regs[3] |= RxENABLE;\n\telse\n\t\tzport->regs[3] &= ~RxENABLE;\n\n\tif (zport != zport_a) {\n\t\tif (!(termios->c_cflag & CLOCAL)) {\n\t\t\tzport->regs[15] |= DCDIE;\n\t\t} else\n\t\t\tzport->regs[15] &= ~DCDIE;\n\t\tif (termios->c_cflag & CRTSCTS) {\n\t\t\tzport->regs[15] |= CTSIE;\n\t\t} else\n\t\t\tzport->regs[15] &= ~CTSIE;\n\t\tzs_raw_xor_mctrl(zport);\n\t}\n\n\t \n\tload_zsregs(zport, zport->regs, irq);\n\n\tspin_unlock_irqrestore(&scc->zlock, flags);\n}\n\n \nstatic void zs_pm(struct uart_port *uport, unsigned int state,\n\t\t  unsigned int oldstate)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\n\tif (state < 3)\n\t\tzport->regs[5] |= TxENAB;\n\telse\n\t\tzport->regs[5] &= ~TxENAB;\n\twrite_zsreg(zport, R5, zport->regs[5]);\n}\n\n\nstatic const char *zs_type(struct uart_port *uport)\n{\n\treturn \"Z85C30 SCC\";\n}\n\nstatic void zs_release_port(struct uart_port *uport)\n{\n\tiounmap(uport->membase);\n\tuport->membase = NULL;\n\trelease_mem_region(uport->mapbase, ZS_CHAN_IO_SIZE);\n}\n\nstatic int zs_map_port(struct uart_port *uport)\n{\n\tif (!uport->membase)\n\t\tuport->membase = ioremap(uport->mapbase,\n\t\t\t\t\t\t ZS_CHAN_IO_SIZE);\n\tif (!uport->membase) {\n\t\tprintk(KERN_ERR \"zs: Cannot map MMIO\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int zs_request_port(struct uart_port *uport)\n{\n\tint ret;\n\n\tif (!request_mem_region(uport->mapbase, ZS_CHAN_IO_SIZE, \"scc\")) {\n\t\tprintk(KERN_ERR \"zs: Unable to reserve MMIO resource\\n\");\n\t\treturn -EBUSY;\n\t}\n\tret = zs_map_port(uport);\n\tif (ret) {\n\t\trelease_mem_region(uport->mapbase, ZS_CHAN_IO_SIZE);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void zs_config_port(struct uart_port *uport, int flags)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tif (zs_request_port(uport))\n\t\t\treturn;\n\n\t\tuport->type = PORT_ZS;\n\n\t\tzs_reset(zport);\n\t}\n}\n\nstatic int zs_verify_port(struct uart_port *uport, struct serial_struct *ser)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tint ret = 0;\n\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_ZS)\n\t\tret = -EINVAL;\n\tif (ser->irq != uport->irq)\n\t\tret = -EINVAL;\n\tif (ser->baud_base != uport->uartclk / zport->clk_mode / 4)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\n\nstatic const struct uart_ops zs_ops = {\n\t.tx_empty\t= zs_tx_empty,\n\t.set_mctrl\t= zs_set_mctrl,\n\t.get_mctrl\t= zs_get_mctrl,\n\t.stop_tx\t= zs_stop_tx,\n\t.start_tx\t= zs_start_tx,\n\t.stop_rx\t= zs_stop_rx,\n\t.enable_ms\t= zs_enable_ms,\n\t.break_ctl\t= zs_break_ctl,\n\t.startup\t= zs_startup,\n\t.shutdown\t= zs_shutdown,\n\t.set_termios\t= zs_set_termios,\n\t.pm\t\t= zs_pm,\n\t.type\t\t= zs_type,\n\t.release_port\t= zs_release_port,\n\t.request_port\t= zs_request_port,\n\t.config_port\t= zs_config_port,\n\t.verify_port\t= zs_verify_port,\n};\n\n \nstatic int __init zs_probe_sccs(void)\n{\n\tstatic int probed;\n\tstruct zs_parms zs_parms;\n\tint chip, side, irq;\n\tint n_chips = 0;\n\tint i;\n\n\tif (probed)\n\t\treturn 0;\n\n\tirq = dec_interrupt[DEC_IRQ_SCC0];\n\tif (irq >= 0) {\n\t\tzs_parms.scc[n_chips] = IOASIC_SCC0;\n\t\tzs_parms.irq[n_chips] = dec_interrupt[DEC_IRQ_SCC0];\n\t\tn_chips++;\n\t}\n\tirq = dec_interrupt[DEC_IRQ_SCC1];\n\tif (irq >= 0) {\n\t\tzs_parms.scc[n_chips] = IOASIC_SCC1;\n\t\tzs_parms.irq[n_chips] = dec_interrupt[DEC_IRQ_SCC1];\n\t\tn_chips++;\n\t}\n\tif (!n_chips)\n\t\treturn -ENXIO;\n\n\tprobed = 1;\n\n\tfor (chip = 0; chip < n_chips; chip++) {\n\t\tspin_lock_init(&zs_sccs[chip].zlock);\n\t\tfor (side = 0; side < ZS_NUM_CHAN; side++) {\n\t\t\tstruct zs_port *zport = &zs_sccs[chip].zport[side];\n\t\t\tstruct uart_port *uport = &zport->port;\n\n\t\t\tzport->scc\t= &zs_sccs[chip];\n\t\t\tzport->clk_mode\t= 16;\n\n\t\t\tuport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_ZS_CONSOLE);\n\t\t\tuport->irq\t= zs_parms.irq[chip];\n\t\t\tuport->uartclk\t= ZS_CLOCK;\n\t\t\tuport->fifosize\t= 1;\n\t\t\tuport->iotype\t= UPIO_MEM;\n\t\t\tuport->flags\t= UPF_BOOT_AUTOCONF;\n\t\t\tuport->ops\t= &zs_ops;\n\t\t\tuport->line\t= chip * ZS_NUM_CHAN + side;\n\t\t\tuport->mapbase\t= dec_kn_slot_base +\n\t\t\t\t\t  zs_parms.scc[chip] +\n\t\t\t\t\t  (side ^ ZS_CHAN_B) * ZS_CHAN_IO_SIZE;\n\n\t\t\tfor (i = 0; i < ZS_NUM_REGS; i++)\n\t\t\t\tzport->regs[i] = zs_init_regs[i];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n#ifdef CONFIG_SERIAL_ZS_CONSOLE\nstatic void zs_console_putchar(struct uart_port *uport, unsigned char ch)\n{\n\tstruct zs_port *zport = to_zport(uport);\n\tstruct zs_scc *scc = zport->scc;\n\tint irq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&scc->zlock, flags);\n\tirq = !irqs_disabled_flags(flags);\n\tif (zs_transmit_drain(zport, irq))\n\t\twrite_zsdata(zport, ch);\n\tspin_unlock_irqrestore(&scc->zlock, flags);\n}\n\n \nstatic void zs_console_write(struct console *co, const char *s,\n\t\t\t     unsigned int count)\n{\n\tint chip = co->index / ZS_NUM_CHAN, side = co->index % ZS_NUM_CHAN;\n\tstruct zs_port *zport = &zs_sccs[chip].zport[side];\n\tstruct zs_scc *scc = zport->scc;\n\tunsigned long flags;\n\tu8 txint, txenb;\n\tint irq;\n\n\t \n\tspin_lock_irqsave(&scc->zlock, flags);\n\ttxint = zport->regs[1];\n\ttxenb = zport->regs[5];\n\tif (txint & TxINT_ENAB) {\n\t\tzport->regs[1] = txint & ~TxINT_ENAB;\n\t\twrite_zsreg(zport, R1, zport->regs[1]);\n\t}\n\tif (!(txenb & TxENAB)) {\n\t\tzport->regs[5] = txenb | TxENAB;\n\t\twrite_zsreg(zport, R5, zport->regs[5]);\n\t}\n\tspin_unlock_irqrestore(&scc->zlock, flags);\n\n\tuart_console_write(&zport->port, s, count, zs_console_putchar);\n\n\t \n\tspin_lock_irqsave(&scc->zlock, flags);\n\tirq = !irqs_disabled_flags(flags);\n\tzs_line_drain(zport, irq);\n\tif (!(txenb & TxENAB)) {\n\t\tzport->regs[5] &= ~TxENAB;\n\t\twrite_zsreg(zport, R5, zport->regs[5]);\n\t}\n\tif (txint & TxINT_ENAB) {\n\t\tzport->regs[1] |= TxINT_ENAB;\n\t\twrite_zsreg(zport, R1, zport->regs[1]);\n\n\t\t \n\t\tif (!zport->tx_stopped)\n\t\t\tzs_raw_transmit_chars(zport);\n\t}\n\tspin_unlock_irqrestore(&scc->zlock, flags);\n}\n\n \nstatic int __init zs_console_setup(struct console *co, char *options)\n{\n\tint chip = co->index / ZS_NUM_CHAN, side = co->index % ZS_NUM_CHAN;\n\tstruct zs_port *zport = &zs_sccs[chip].zport[side];\n\tstruct uart_port *uport = &zport->port;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret;\n\n\tret = zs_map_port(uport);\n\tif (ret)\n\t\treturn ret;\n\n\tzs_reset(zport);\n\tzs_pm(uport, 0, -1);\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\treturn uart_set_options(uport, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver zs_reg;\nstatic struct console zs_console = {\n\t.name\t= \"ttyS\",\n\t.write\t= zs_console_write,\n\t.device\t= uart_console_device,\n\t.setup\t= zs_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,\n\t.data\t= &zs_reg,\n};\n\n \nstatic int __init zs_serial_console_init(void)\n{\n\tint ret;\n\n\tret = zs_probe_sccs();\n\tif (ret)\n\t\treturn ret;\n\tregister_console(&zs_console);\n\n\treturn 0;\n}\n\nconsole_initcall(zs_serial_console_init);\n\n#define SERIAL_ZS_CONSOLE\t&zs_console\n#else\n#define SERIAL_ZS_CONSOLE\tNULL\n#endif  \n\nstatic struct uart_driver zs_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"serial\",\n\t.dev_name\t\t= \"ttyS\",\n\t.major\t\t\t= TTY_MAJOR,\n\t.minor\t\t\t= 64,\n\t.nr\t\t\t= ZS_NUM_SCCS * ZS_NUM_CHAN,\n\t.cons\t\t\t= SERIAL_ZS_CONSOLE,\n};\n\n \nstatic int __init zs_init(void)\n{\n\tint i, ret;\n\n\tpr_info(\"%s%s\\n\", zs_name, zs_version);\n\n\t \n\tret = zs_probe_sccs();\n\tif (ret)\n\t\treturn ret;\n\n\tret = uart_register_driver(&zs_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ZS_NUM_SCCS * ZS_NUM_CHAN; i++) {\n\t\tstruct zs_scc *scc = &zs_sccs[i / ZS_NUM_CHAN];\n\t\tstruct zs_port *zport = &scc->zport[i % ZS_NUM_CHAN];\n\t\tstruct uart_port *uport = &zport->port;\n\n\t\tif (zport->scc)\n\t\t\tuart_add_one_port(&zs_reg, uport);\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit zs_exit(void)\n{\n\tint i;\n\n\tfor (i = ZS_NUM_SCCS * ZS_NUM_CHAN - 1; i >= 0; i--) {\n\t\tstruct zs_scc *scc = &zs_sccs[i / ZS_NUM_CHAN];\n\t\tstruct zs_port *zport = &scc->zport[i % ZS_NUM_CHAN];\n\t\tstruct uart_port *uport = &zport->port;\n\n\t\tif (zport->scc)\n\t\t\tuart_remove_one_port(&zs_reg, uport);\n\t}\n\n\tuart_unregister_driver(&zs_reg);\n}\n\nmodule_init(zs_init);\nmodule_exit(zs_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}