{
  "module_name": "pxa.c",
  "hash_id": "9ef0239e57582d2413e1a43efe934247edf7ab57472bd22eb2b4ae8f2dc3cd61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/pxa.c",
  "human_readable_source": "\n \n\n\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/circ_buf.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#define PXA_NAME_LEN\t\t8\n\nstruct uart_pxa_port {\n\tstruct uart_port        port;\n\tunsigned char           ier;\n\tunsigned char           lcr;\n\tunsigned char           mcr;\n\tunsigned int            lsr_break_flag;\n\tstruct clk\t\t*clk;\n\tchar\t\t\tname[PXA_NAME_LEN];\n};\n\nstatic inline unsigned int serial_in(struct uart_pxa_port *up, int offset)\n{\n\toffset <<= 2;\n\treturn readl(up->port.membase + offset);\n}\n\nstatic inline void serial_out(struct uart_pxa_port *up, int offset, int value)\n{\n\toffset <<= 2;\n\twritel(value, up->port.membase + offset);\n}\n\nstatic void serial_pxa_enable_ms(struct uart_port *port)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\n\tup->ier |= UART_IER_MSI;\n\tserial_out(up, UART_IER, up->ier);\n}\n\nstatic void serial_pxa_stop_tx(struct uart_port *port)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\n\tif (up->ier & UART_IER_THRI) {\n\t\tup->ier &= ~UART_IER_THRI;\n\t\tserial_out(up, UART_IER, up->ier);\n\t}\n}\n\nstatic void serial_pxa_stop_rx(struct uart_port *port)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\n\tup->ier &= ~UART_IER_RLSI;\n\tup->port.read_status_mask &= ~UART_LSR_DR;\n\tserial_out(up, UART_IER, up->ier);\n}\n\nstatic inline void receive_chars(struct uart_pxa_port *up, int *status)\n{\n\tu8 ch, flag;\n\tint max_count = 256;\n\n\tdo {\n\t\t \n\t\tup->ier &= ~UART_IER_RTOIE;\n\t\tserial_out(up, UART_IER, up->ier);\n\n\t\tch = serial_in(up, UART_RX);\n\t\tflag = TTY_NORMAL;\n\t\tup->port.icount.rx++;\n\n\t\tif (unlikely(*status & (UART_LSR_BI | UART_LSR_PE |\n\t\t\t\t       UART_LSR_FE | UART_LSR_OE))) {\n\t\t\t \n\t\t\tif (*status & UART_LSR_BI) {\n\t\t\t\t*status &= ~(UART_LSR_FE | UART_LSR_PE);\n\t\t\t\tup->port.icount.brk++;\n\t\t\t\t \n\t\t\t\tif (uart_handle_break(&up->port))\n\t\t\t\t\tgoto ignore_char;\n\t\t\t} else if (*status & UART_LSR_PE)\n\t\t\t\tup->port.icount.parity++;\n\t\t\telse if (*status & UART_LSR_FE)\n\t\t\t\tup->port.icount.frame++;\n\t\t\tif (*status & UART_LSR_OE)\n\t\t\t\tup->port.icount.overrun++;\n\n\t\t\t \n\t\t\t*status &= up->port.read_status_mask;\n\n#ifdef CONFIG_SERIAL_PXA_CONSOLE\n\t\t\tif (up->port.line == up->port.cons->index) {\n\t\t\t\t \n\t\t\t\t*status |= up->lsr_break_flag;\n\t\t\t\tup->lsr_break_flag = 0;\n\t\t\t}\n#endif\n\t\t\tif (*status & UART_LSR_BI) {\n\t\t\t\tflag = TTY_BREAK;\n\t\t\t} else if (*status & UART_LSR_PE)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (*status & UART_LSR_FE)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(&up->port, ch))\n\t\t\tgoto ignore_char;\n\n\t\tuart_insert_char(&up->port, *status, UART_LSR_OE, ch, flag);\n\n\tignore_char:\n\t\t*status = serial_in(up, UART_LSR);\n\t} while ((*status & UART_LSR_DR) && (max_count-- > 0));\n\ttty_flip_buffer_push(&up->port.state->port);\n\n\t \n\tup->ier |= UART_IER_RTOIE;\n\tserial_out(up, UART_IER, up->ier);\n}\n\nstatic void transmit_chars(struct uart_pxa_port *up)\n{\n\tu8 ch;\n\n\tuart_port_tx_limited(&up->port, ch, up->port.fifosize / 2,\n\t\ttrue,\n\t\tserial_out(up, UART_TX, ch),\n\t\t({}));\n}\n\nstatic void serial_pxa_start_tx(struct uart_port *port)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\n\tif (!(up->ier & UART_IER_THRI)) {\n\t\tup->ier |= UART_IER_THRI;\n\t\tserial_out(up, UART_IER, up->ier);\n\t}\n}\n\n \nstatic inline void check_modem_status(struct uart_pxa_port *up)\n{\n\tint status;\n\n\tstatus = serial_in(up, UART_MSR);\n\n\tif ((status & UART_MSR_ANY_DELTA) == 0)\n\t\treturn;\n\n\tif (status & UART_MSR_TERI)\n\t\tup->port.icount.rng++;\n\tif (status & UART_MSR_DDSR)\n\t\tup->port.icount.dsr++;\n\tif (status & UART_MSR_DDCD)\n\t\tuart_handle_dcd_change(&up->port, status & UART_MSR_DCD);\n\tif (status & UART_MSR_DCTS)\n\t\tuart_handle_cts_change(&up->port, status & UART_MSR_CTS);\n\n\twake_up_interruptible(&up->port.state->port.delta_msr_wait);\n}\n\n \nstatic inline irqreturn_t serial_pxa_irq(int irq, void *dev_id)\n{\n\tstruct uart_pxa_port *up = dev_id;\n\tunsigned int iir, lsr;\n\n\tiir = serial_in(up, UART_IIR);\n\tif (iir & UART_IIR_NO_INT)\n\t\treturn IRQ_NONE;\n\tspin_lock(&up->port.lock);\n\tlsr = serial_in(up, UART_LSR);\n\tif (lsr & UART_LSR_DR)\n\t\treceive_chars(up, &lsr);\n\tcheck_modem_status(up);\n\tif (lsr & UART_LSR_THRE)\n\t\ttransmit_chars(up);\n\tspin_unlock(&up->port.lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int serial_pxa_tx_empty(struct uart_port *port)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\tunsigned long flags;\n\tunsigned int ret;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\treturn ret;\n}\n\nstatic unsigned int serial_pxa_get_mctrl(struct uart_port *port)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\tunsigned char status;\n\tunsigned int ret;\n\n\tstatus = serial_in(up, UART_MSR);\n\n\tret = 0;\n\tif (status & UART_MSR_DCD)\n\t\tret |= TIOCM_CAR;\n\tif (status & UART_MSR_RI)\n\t\tret |= TIOCM_RNG;\n\tif (status & UART_MSR_DSR)\n\t\tret |= TIOCM_DSR;\n\tif (status & UART_MSR_CTS)\n\t\tret |= TIOCM_CTS;\n\treturn ret;\n}\n\nstatic void serial_pxa_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\tunsigned char mcr = 0;\n\n\tif (mctrl & TIOCM_RTS)\n\t\tmcr |= UART_MCR_RTS;\n\tif (mctrl & TIOCM_DTR)\n\t\tmcr |= UART_MCR_DTR;\n\tif (mctrl & TIOCM_OUT1)\n\t\tmcr |= UART_MCR_OUT1;\n\tif (mctrl & TIOCM_OUT2)\n\t\tmcr |= UART_MCR_OUT2;\n\tif (mctrl & TIOCM_LOOP)\n\t\tmcr |= UART_MCR_LOOP;\n\n\tmcr |= up->mcr;\n\n\tserial_out(up, UART_MCR, mcr);\n}\n\nstatic void serial_pxa_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tif (break_state == -1)\n\t\tup->lcr |= UART_LCR_SBC;\n\telse\n\t\tup->lcr &= ~UART_LCR_SBC;\n\tserial_out(up, UART_LCR, up->lcr);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic int serial_pxa_startup(struct uart_port *port)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\tunsigned long flags;\n\tint retval;\n\n\tif (port->line == 3)  \n\t\tup->mcr |= UART_MCR_AFE;\n\telse\n\t\tup->mcr = 0;\n\n\tup->port.uartclk = clk_get_rate(up->clk);\n\n\t \n\tretval = request_irq(up->port.irq, serial_pxa_irq, 0, up->name, up);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t\tUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\tserial_out(up, UART_FCR, 0);\n\n\t \n\t(void) serial_in(up, UART_LSR);\n\t(void) serial_in(up, UART_RX);\n\t(void) serial_in(up, UART_IIR);\n\t(void) serial_in(up, UART_MSR);\n\n\t \n\tserial_out(up, UART_LCR, UART_LCR_WLEN8);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tup->port.mctrl |= TIOCM_OUT2;\n\tserial_pxa_set_mctrl(&up->port, up->port.mctrl);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\t \n\tup->ier = UART_IER_RLSI | UART_IER_RDI | UART_IER_RTOIE | UART_IER_UUE;\n\tserial_out(up, UART_IER, up->ier);\n\n\t \n\t(void) serial_in(up, UART_LSR);\n\t(void) serial_in(up, UART_RX);\n\t(void) serial_in(up, UART_IIR);\n\t(void) serial_in(up, UART_MSR);\n\n\treturn 0;\n}\n\nstatic void serial_pxa_shutdown(struct uart_port *port)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\tunsigned long flags;\n\n\tfree_irq(up->port.irq, up);\n\n\t \n\tup->ier = 0;\n\tserial_out(up, UART_IER, 0);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tup->port.mctrl &= ~TIOCM_OUT2;\n\tserial_pxa_set_mctrl(&up->port, up->port.mctrl);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\t \n\tserial_out(up, UART_LCR, serial_in(up, UART_LCR) & ~UART_LCR_SBC);\n\tserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t\t\t  UART_FCR_CLEAR_RCVR |\n\t\t\t\t  UART_FCR_CLEAR_XMIT);\n\tserial_out(up, UART_FCR, 0);\n}\n\nstatic void\nserial_pxa_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t       const struct ktermios *old)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\tunsigned char cval, fcr = 0;\n\tunsigned long flags;\n\tunsigned int baud, quot;\n\tunsigned int dll;\n\n\tcval = UART_LCR_WLEN(tty_get_char_size(termios->c_cflag));\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tcval |= UART_LCR_STOP;\n\tif (termios->c_cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(termios->c_cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\n\tquot = uart_get_divisor(port, baud);\n\n\tif ((up->port.uartclk / quot) < (2400 * 16))\n\t\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR1;\n\telse if ((up->port.uartclk / quot) < (230400 * 16))\n\t\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR8;\n\telse\n\t\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR32;\n\n\t \n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t \n\tup->ier |= UART_IER_UUE;\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tup->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\n\tif (termios->c_iflag & INPCK)\n\t\tup->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tup->port.read_status_mask |= UART_LSR_BI;\n\n\t \n\tup->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tup->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tup->port.ignore_status_mask |= UART_LSR_BI;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tup->port.ignore_status_mask |= UART_LSR_OE;\n\t}\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tup->port.ignore_status_mask |= UART_LSR_DR;\n\n\t \n\tup->ier &= ~UART_IER_MSI;\n\tif (UART_ENABLE_MS(&up->port, termios->c_cflag))\n\t\tup->ier |= UART_IER_MSI;\n\n\tserial_out(up, UART_IER, up->ier);\n\n\tif (termios->c_cflag & CRTSCTS)\n\t\tup->mcr |= UART_MCR_AFE;\n\telse\n\t\tup->mcr &= ~UART_MCR_AFE;\n\n\tserial_out(up, UART_LCR, cval | UART_LCR_DLAB);\t \n\tserial_out(up, UART_DLL, quot & 0xff);\t\t \n\n\t \n\tdll = serial_in(up, UART_DLL);\n\tWARN_ON(dll != (quot & 0xff));\n\n\tserial_out(up, UART_DLM, quot >> 8);\t\t \n\tserial_out(up, UART_LCR, cval);\t\t\t \n\tup->lcr = cval;\t\t\t\t\t \n\tserial_pxa_set_mctrl(&up->port, up->port.mctrl);\n\tserial_out(up, UART_FCR, fcr);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic void\nserial_pxa_pm(struct uart_port *port, unsigned int state,\n\t      unsigned int oldstate)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\n\tif (!state)\n\t\tclk_prepare_enable(up->clk);\n\telse\n\t\tclk_disable_unprepare(up->clk);\n}\n\nstatic void serial_pxa_release_port(struct uart_port *port)\n{\n}\n\nstatic int serial_pxa_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void serial_pxa_config_port(struct uart_port *port, int flags)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\tup->port.type = PORT_PXA;\n}\n\nstatic int\nserial_pxa_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic const char *\nserial_pxa_type(struct uart_port *port)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\treturn up->name;\n}\n\nstatic struct uart_pxa_port *serial_pxa_ports[4];\nstatic struct uart_driver serial_pxa_reg;\n\n#ifdef CONFIG_SERIAL_PXA_CONSOLE\n\n \nstatic void wait_for_xmitr(struct uart_pxa_port *up)\n{\n\tunsigned int status, tmout = 10000;\n\n\t \n\tdo {\n\t\tstatus = serial_in(up, UART_LSR);\n\n\t\tif (status & UART_LSR_BI)\n\t\t\tup->lsr_break_flag = UART_LSR_BI;\n\n\t\tif (--tmout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (!uart_lsr_tx_empty(status));\n\n\t \n\tif (up->port.flags & UPF_CONS_FLOW) {\n\t\ttmout = 1000000;\n\t\twhile (--tmout &&\n\t\t       ((serial_in(up, UART_MSR) & UART_MSR_CTS) == 0))\n\t\t\tudelay(1);\n\t}\n}\n\nstatic void serial_pxa_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\n\twait_for_xmitr(up);\n\tserial_out(up, UART_TX, ch);\n}\n\n \nstatic void\nserial_pxa_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct uart_pxa_port *up = serial_pxa_ports[co->index];\n\tunsigned int ier;\n\tunsigned long flags;\n\tint locked = 1;\n\n\tclk_enable(up->clk);\n\tlocal_irq_save(flags);\n\tif (up->port.sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock(&up->port.lock);\n\telse\n\t\tspin_lock(&up->port.lock);\n\n\t \n\tier = serial_in(up, UART_IER);\n\tserial_out(up, UART_IER, UART_IER_UUE);\n\n\tuart_console_write(&up->port, s, count, serial_pxa_console_putchar);\n\n\t \n\twait_for_xmitr(up);\n\tserial_out(up, UART_IER, ier);\n\n\tif (locked)\n\t\tspin_unlock(&up->port.lock);\n\tlocal_irq_restore(flags);\n\tclk_disable(up->clk);\n\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n \n\nstatic int serial_pxa_get_poll_char(struct uart_port *port)\n{\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\tunsigned char lsr = serial_in(up, UART_LSR);\n\n\twhile (!(lsr & UART_LSR_DR))\n\t\tlsr = serial_in(up, UART_LSR);\n\n\treturn serial_in(up, UART_RX);\n}\n\n\nstatic void serial_pxa_put_poll_char(struct uart_port *port,\n\t\t\t unsigned char c)\n{\n\tunsigned int ier;\n\tstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\n\n\t \n\tier = serial_in(up, UART_IER);\n\tserial_out(up, UART_IER, UART_IER_UUE);\n\n\twait_for_xmitr(up);\n\t \n\tserial_out(up, UART_TX, c);\n\n\t \n\twait_for_xmitr(up);\n\tserial_out(up, UART_IER, ier);\n}\n\n#endif  \n\nstatic int __init\nserial_pxa_console_setup(struct console *co, char *options)\n{\n\tstruct uart_pxa_port *up;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index == -1 || co->index >= serial_pxa_reg.nr)\n\t\tco->index = 0;\n\tup = serial_pxa_ports[co->index];\n\tif (!up)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&up->port, co, baud, parity, bits, flow);\n}\n\nstatic struct console serial_pxa_console = {\n\t.name\t\t= \"ttyS\",\n\t.write\t\t= serial_pxa_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= serial_pxa_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &serial_pxa_reg,\n};\n\n#define PXA_CONSOLE\t&serial_pxa_console\n#else\n#define PXA_CONSOLE\tNULL\n#endif\n\nstatic const struct uart_ops serial_pxa_pops = {\n\t.tx_empty\t= serial_pxa_tx_empty,\n\t.set_mctrl\t= serial_pxa_set_mctrl,\n\t.get_mctrl\t= serial_pxa_get_mctrl,\n\t.stop_tx\t= serial_pxa_stop_tx,\n\t.start_tx\t= serial_pxa_start_tx,\n\t.stop_rx\t= serial_pxa_stop_rx,\n\t.enable_ms\t= serial_pxa_enable_ms,\n\t.break_ctl\t= serial_pxa_break_ctl,\n\t.startup\t= serial_pxa_startup,\n\t.shutdown\t= serial_pxa_shutdown,\n\t.set_termios\t= serial_pxa_set_termios,\n\t.pm\t\t= serial_pxa_pm,\n\t.type\t\t= serial_pxa_type,\n\t.release_port\t= serial_pxa_release_port,\n\t.request_port\t= serial_pxa_request_port,\n\t.config_port\t= serial_pxa_config_port,\n\t.verify_port\t= serial_pxa_verify_port,\n#if defined(CONFIG_CONSOLE_POLL) && defined(CONFIG_SERIAL_PXA_CONSOLE)\n\t.poll_get_char = serial_pxa_get_poll_char,\n\t.poll_put_char = serial_pxa_put_poll_char,\n#endif\n};\n\nstatic struct uart_driver serial_pxa_reg = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"PXA serial\",\n\t.dev_name\t= \"ttyS\",\n\t.major\t\t= TTY_MAJOR,\n\t.minor\t\t= 64,\n\t.nr\t\t= 4,\n\t.cons\t\t= PXA_CONSOLE,\n};\n\n#ifdef CONFIG_PM\nstatic int serial_pxa_suspend(struct device *dev)\n{\n        struct uart_pxa_port *sport = dev_get_drvdata(dev);\n\n        if (sport)\n                uart_suspend_port(&serial_pxa_reg, &sport->port);\n\n        return 0;\n}\n\nstatic int serial_pxa_resume(struct device *dev)\n{\n        struct uart_pxa_port *sport = dev_get_drvdata(dev);\n\n        if (sport)\n                uart_resume_port(&serial_pxa_reg, &sport->port);\n\n        return 0;\n}\n\nstatic const struct dev_pm_ops serial_pxa_pm_ops = {\n\t.suspend\t= serial_pxa_suspend,\n\t.resume\t\t= serial_pxa_resume,\n};\n#endif\n\nstatic const struct of_device_id serial_pxa_dt_ids[] = {\n\t{ .compatible = \"mrvl,pxa-uart\", },\n\t{ .compatible = \"mrvl,mmp-uart\", },\n\t{}\n};\n\nstatic int serial_pxa_probe_dt(struct platform_device *pdev,\n\t\t\t       struct uart_pxa_port *sport)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret;\n\n\tif (!np)\n\t\treturn 1;\n\n\tret = of_alias_get_id(np, \"serial\");\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias id, errno %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsport->port.line = ret;\n\treturn 0;\n}\n\nstatic int serial_pxa_probe(struct platform_device *dev)\n{\n\tstruct uart_pxa_port *sport;\n\tstruct resource *mmres;\n\tint ret;\n\tint irq;\n\n\tmmres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!mmres)\n\t\treturn -ENODEV;\n\n\tirq = platform_get_irq(dev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tsport = kzalloc(sizeof(struct uart_pxa_port), GFP_KERNEL);\n\tif (!sport)\n\t\treturn -ENOMEM;\n\n\tsport->clk = clk_get(&dev->dev, NULL);\n\tif (IS_ERR(sport->clk)) {\n\t\tret = PTR_ERR(sport->clk);\n\t\tgoto err_free;\n\t}\n\n\tret = clk_prepare(sport->clk);\n\tif (ret) {\n\t\tclk_put(sport->clk);\n\t\tgoto err_free;\n\t}\n\n\tsport->port.type = PORT_PXA;\n\tsport->port.iotype = UPIO_MEM;\n\tsport->port.mapbase = mmres->start;\n\tsport->port.irq = irq;\n\tsport->port.fifosize = 64;\n\tsport->port.ops = &serial_pxa_pops;\n\tsport->port.dev = &dev->dev;\n\tsport->port.flags = UPF_IOREMAP | UPF_BOOT_AUTOCONF;\n\tsport->port.uartclk = clk_get_rate(sport->clk);\n\tsport->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_PXA_CONSOLE);\n\n\tret = serial_pxa_probe_dt(dev, sport);\n\tif (ret > 0)\n\t\tsport->port.line = dev->id;\n\telse if (ret < 0)\n\t\tgoto err_clk;\n\tif (sport->port.line >= ARRAY_SIZE(serial_pxa_ports)) {\n\t\tdev_err(&dev->dev, \"serial%d out of range\\n\", sport->port.line);\n\t\tret = -EINVAL;\n\t\tgoto err_clk;\n\t}\n\tsnprintf(sport->name, PXA_NAME_LEN - 1, \"UART%d\", sport->port.line + 1);\n\n\tsport->port.membase = ioremap(mmres->start, resource_size(mmres));\n\tif (!sport->port.membase) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk;\n\t}\n\n\tserial_pxa_ports[sport->port.line] = sport;\n\n\tuart_add_one_port(&serial_pxa_reg, &sport->port);\n\tplatform_set_drvdata(dev, sport);\n\n\treturn 0;\n\n err_clk:\n\tclk_unprepare(sport->clk);\n\tclk_put(sport->clk);\n err_free:\n\tkfree(sport);\n\treturn ret;\n}\n\nstatic struct platform_driver serial_pxa_driver = {\n        .probe          = serial_pxa_probe,\n\n\t.driver\t\t= {\n\t        .name\t= \"pxa2xx-uart\",\n#ifdef CONFIG_PM\n\t\t.pm\t= &serial_pxa_pm_ops,\n#endif\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = serial_pxa_dt_ids,\n\t},\n};\n\n\n \nstatic int __init serial_pxa_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&serial_pxa_reg);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = platform_driver_register(&serial_pxa_driver);\n\tif (ret != 0)\n\t\tuart_unregister_driver(&serial_pxa_reg);\n\n\treturn ret;\n}\ndevice_initcall(serial_pxa_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}