{
  "module_name": "21285.c",
  "hash_id": "8008ee1d2f8b582d6886c8a29880f63b3df9f7b14af667b28be45070fc7ef942",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/21285.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/tty.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/device.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/io.h>\n\n#include <asm/irq.h>\n#include <asm/mach-types.h>\n#include <asm/system_info.h>\n#include <asm/hardware/dec21285.h>\n#include <mach/hardware.h>\n\n#define BAUD_BASE\t\t(mem_fclk_21285/64)\n\n#define SERIAL_21285_NAME\t\"ttyFB\"\n#define SERIAL_21285_MAJOR\t204\n#define SERIAL_21285_MINOR\t4\n\n#define RXSTAT_DUMMY_READ\t0x80000000\n#define RXSTAT_FRAME\t\t(1 << 0)\n#define RXSTAT_PARITY\t\t(1 << 1)\n#define RXSTAT_OVERRUN\t\t(1 << 2)\n#define RXSTAT_ANYERR\t\t(RXSTAT_FRAME|RXSTAT_PARITY|RXSTAT_OVERRUN)\n\n#define H_UBRLCR_BREAK\t\t(1 << 0)\n#define H_UBRLCR_PARENB\t\t(1 << 1)\n#define H_UBRLCR_PAREVN\t\t(1 << 2)\n#define H_UBRLCR_STOPB\t\t(1 << 3)\n#define H_UBRLCR_FIFO\t\t(1 << 4)\n\nstatic const char serial21285_name[] = \"Footbridge UART\";\n\n \n#define tx_enabled_bit\t0\n#define rx_enabled_bit\t1\n\nstatic bool is_enabled(struct uart_port *port, int bit)\n{\n\tunsigned long *private_data = (unsigned long *)&port->private_data;\n\n\tif (test_bit(bit, private_data))\n\t\treturn true;\n\treturn false;\n}\n\nstatic void enable(struct uart_port *port, int bit)\n{\n\tunsigned long *private_data = (unsigned long *)&port->private_data;\n\n\tset_bit(bit, private_data);\n}\n\nstatic void disable(struct uart_port *port, int bit)\n{\n\tunsigned long *private_data = (unsigned long *)&port->private_data;\n\n\tclear_bit(bit, private_data);\n}\n\n#define is_tx_enabled(port)\tis_enabled(port, tx_enabled_bit)\n#define tx_enable(port)\t\tenable(port, tx_enabled_bit)\n#define tx_disable(port)\tdisable(port, tx_enabled_bit)\n\n#define is_rx_enabled(port)\tis_enabled(port, rx_enabled_bit)\n#define rx_enable(port)\t\tenable(port, rx_enabled_bit)\n#define rx_disable(port)\tdisable(port, rx_enabled_bit)\n\n \n\nstatic void serial21285_stop_tx(struct uart_port *port)\n{\n\tif (is_tx_enabled(port)) {\n\t\tdisable_irq_nosync(IRQ_CONTX);\n\t\ttx_disable(port);\n\t}\n}\n\nstatic void serial21285_start_tx(struct uart_port *port)\n{\n\tif (!is_tx_enabled(port)) {\n\t\tenable_irq(IRQ_CONTX);\n\t\ttx_enable(port);\n\t}\n}\n\nstatic void serial21285_stop_rx(struct uart_port *port)\n{\n\tif (is_rx_enabled(port)) {\n\t\tdisable_irq_nosync(IRQ_CONRX);\n\t\trx_disable(port);\n\t}\n}\n\nstatic irqreturn_t serial21285_rx_chars(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tunsigned int status, rxs, max_count = 256;\n\tu8 ch, flag;\n\n\tstatus = *CSR_UARTFLG;\n\twhile (!(status & 0x10) && max_count--) {\n\t\tch = *CSR_UARTDR;\n\t\tflag = TTY_NORMAL;\n\t\tport->icount.rx++;\n\n\t\trxs = *CSR_RXSTAT | RXSTAT_DUMMY_READ;\n\t\tif (unlikely(rxs & RXSTAT_ANYERR)) {\n\t\t\tif (rxs & RXSTAT_PARITY)\n\t\t\t\tport->icount.parity++;\n\t\t\telse if (rxs & RXSTAT_FRAME)\n\t\t\t\tport->icount.frame++;\n\t\t\tif (rxs & RXSTAT_OVERRUN)\n\t\t\t\tport->icount.overrun++;\n\n\t\t\trxs &= port->read_status_mask;\n\n\t\t\tif (rxs & RXSTAT_PARITY)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (rxs & RXSTAT_FRAME)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tuart_insert_char(port, rxs, RXSTAT_OVERRUN, ch, flag);\n\n\t\tstatus = *CSR_UARTFLG;\n\t}\n\ttty_flip_buffer_push(&port->state->port);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t serial21285_tx_chars(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tu8 ch;\n\n\tuart_port_tx_limited(port, ch, 256,\n\t\t!(*CSR_UARTFLG & 0x20),\n\t\t*CSR_UARTDR = ch,\n\t\t({}));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int serial21285_tx_empty(struct uart_port *port)\n{\n\treturn (*CSR_UARTFLG & 8) ? 0 : TIOCSER_TEMT;\n}\n\n \nstatic unsigned int serial21285_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n}\n\nstatic void serial21285_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n}\n\nstatic void serial21285_break_ctl(struct uart_port *port, int break_state)\n{\n\tunsigned long flags;\n\tunsigned int h_lcr;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\th_lcr = *CSR_H_UBRLCR;\n\tif (break_state)\n\t\th_lcr |= H_UBRLCR_BREAK;\n\telse\n\t\th_lcr &= ~H_UBRLCR_BREAK;\n\t*CSR_H_UBRLCR = h_lcr;\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int serial21285_startup(struct uart_port *port)\n{\n\tint ret;\n\n\ttx_enable(port);\n\trx_enable(port);\n\n\tret = request_irq(IRQ_CONRX, serial21285_rx_chars, 0,\n\t\t\t  serial21285_name, port);\n\tif (ret == 0) {\n\t\tret = request_irq(IRQ_CONTX, serial21285_tx_chars, 0,\n\t\t\t\t  serial21285_name, port);\n\t\tif (ret)\n\t\t\tfree_irq(IRQ_CONRX, port);\n\t}\n\n\treturn ret;\n}\n\nstatic void serial21285_shutdown(struct uart_port *port)\n{\n\tfree_irq(IRQ_CONTX, port);\n\tfree_irq(IRQ_CONRX, port);\n}\n\nstatic void\nserial21285_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t\tconst struct ktermios *old)\n{\n\tunsigned long flags;\n\tunsigned int baud, quot, h_lcr, b;\n\n\t \n\ttermios->c_cflag &= ~(HUPCL | CRTSCTS | CMSPAR);\n\ttermios->c_cflag |= CLOCAL;\n\n\t \n\ttermios->c_iflag &= ~(IGNBRK | BRKINT);\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16); \n\tquot = uart_get_divisor(port, baud);\n\tb = port->uartclk / (16 * quot);\n\ttty_termios_encode_baud_rate(termios, b, b);\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\th_lcr = 0x00;\n\t\tbreak;\n\tcase CS6:\n\t\th_lcr = 0x20;\n\t\tbreak;\n\tcase CS7:\n\t\th_lcr = 0x40;\n\t\tbreak;\n\tdefault:  \n\t\th_lcr = 0x60;\n\t\tbreak;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\th_lcr |= H_UBRLCR_STOPB;\n\tif (termios->c_cflag & PARENB) {\n\t\th_lcr |= H_UBRLCR_PARENB;\n\t\tif (!(termios->c_cflag & PARODD))\n\t\t\th_lcr |= H_UBRLCR_PAREVN;\n\t}\n\n\tif (port->fifosize)\n\t\th_lcr |= H_UBRLCR_FIFO;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tport->read_status_mask = RXSTAT_OVERRUN;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= RXSTAT_FRAME | RXSTAT_PARITY;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= RXSTAT_FRAME | RXSTAT_PARITY;\n\tif (termios->c_iflag & IGNBRK && termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= RXSTAT_OVERRUN;\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= RXSTAT_DUMMY_READ;\n\n\tquot -= 1;\n\n\t*CSR_UARTCON = 0;\n\t*CSR_L_UBRLCR = quot & 0xff;\n\t*CSR_M_UBRLCR = (quot >> 8) & 0x0f;\n\t*CSR_H_UBRLCR = h_lcr;\n\t*CSR_UARTCON = 1;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *serial21285_type(struct uart_port *port)\n{\n\treturn port->type == PORT_21285 ? \"DC21285\" : NULL;\n}\n\nstatic void serial21285_release_port(struct uart_port *port)\n{\n\trelease_mem_region(port->mapbase, 32);\n}\n\nstatic int serial21285_request_port(struct uart_port *port)\n{\n\treturn request_mem_region(port->mapbase, 32, serial21285_name)\n\t\t\t != NULL ? 0 : -EBUSY;\n}\n\nstatic void serial21285_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE && serial21285_request_port(port) == 0)\n\t\tport->type = PORT_21285;\n}\n\n \nstatic int serial21285_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tint ret = 0;\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_21285)\n\t\tret = -EINVAL;\n\tif (ser->irq <= 0)\n\t\tret = -EINVAL;\n\tif (ser->baud_base != port->uartclk / 16)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\nstatic const struct uart_ops serial21285_ops = {\n\t.tx_empty\t= serial21285_tx_empty,\n\t.get_mctrl\t= serial21285_get_mctrl,\n\t.set_mctrl\t= serial21285_set_mctrl,\n\t.stop_tx\t= serial21285_stop_tx,\n\t.start_tx\t= serial21285_start_tx,\n\t.stop_rx\t= serial21285_stop_rx,\n\t.break_ctl\t= serial21285_break_ctl,\n\t.startup\t= serial21285_startup,\n\t.shutdown\t= serial21285_shutdown,\n\t.set_termios\t= serial21285_set_termios,\n\t.type\t\t= serial21285_type,\n\t.release_port\t= serial21285_release_port,\n\t.request_port\t= serial21285_request_port,\n\t.config_port\t= serial21285_config_port,\n\t.verify_port\t= serial21285_verify_port,\n};\n\nstatic struct uart_port serial21285_port = {\n\t.mapbase\t= 0x42000160,\n\t.iotype\t\t= UPIO_MEM,\n\t.irq\t\t= 0,\n\t.fifosize\t= 16,\n\t.ops\t\t= &serial21285_ops,\n\t.flags\t\t= UPF_BOOT_AUTOCONF,\n};\n\nstatic void serial21285_setup_ports(void)\n{\n\tserial21285_port.uartclk = mem_fclk_21285 / 4;\n}\n\n#ifdef CONFIG_SERIAL_21285_CONSOLE\nstatic void serial21285_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\twhile (*CSR_UARTFLG & 0x20)\n\t\tbarrier();\n\t*CSR_UARTDR = ch;\n}\n\nstatic void\nserial21285_console_write(struct console *co, const char *s,\n\t\t\t  unsigned int count)\n{\n\tuart_console_write(&serial21285_port, s, count, serial21285_console_putchar);\n}\n\nstatic void __init\nserial21285_get_options(struct uart_port *port, int *baud,\n\t\t\tint *parity, int *bits)\n{\n\tif (*CSR_UARTCON == 1) {\n\t\tunsigned int tmp;\n\n\t\ttmp = *CSR_H_UBRLCR;\n\t\tswitch (tmp & 0x60) {\n\t\tcase 0x00:\n\t\t\t*bits = 5;\n\t\t\tbreak;\n\t\tcase 0x20:\n\t\t\t*bits = 6;\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\t\t*bits = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 0x60:\n\t\t\t*bits = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tmp & H_UBRLCR_PARENB) {\n\t\t\t*parity = 'o';\n\t\t\tif (tmp & H_UBRLCR_PAREVN)\n\t\t\t\t*parity = 'e';\n\t\t}\n\n\t\ttmp = *CSR_L_UBRLCR | (*CSR_M_UBRLCR << 8);\n\n\t\t*baud = port->uartclk / (16 * (tmp + 1));\n\t}\n}\n\nstatic int __init serial21285_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port = &serial21285_port;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\t \n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse\n\t\tserial21285_get_options(port, &baud, &parity, &bits);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver serial21285_reg;\n\nstatic struct console serial21285_console =\n{\n\t.name\t\t= SERIAL_21285_NAME,\n\t.write\t\t= serial21285_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= serial21285_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &serial21285_reg,\n};\n\nstatic int __init rs285_console_init(void)\n{\n\tserial21285_setup_ports();\n\tregister_console(&serial21285_console);\n\treturn 0;\n}\nconsole_initcall(rs285_console_init);\n\n#define SERIAL_21285_CONSOLE\t&serial21285_console\n#else\n#define SERIAL_21285_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver serial21285_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"ttyFB\",\n\t.dev_name\t\t= \"ttyFB\",\n\t.major\t\t\t= SERIAL_21285_MAJOR,\n\t.minor\t\t\t= SERIAL_21285_MINOR,\n\t.nr\t\t\t= 1,\n\t.cons\t\t\t= SERIAL_21285_CONSOLE,\n};\n\nstatic int __init serial21285_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO \"Serial: 21285 driver\\n\");\n\n\tserial21285_setup_ports();\n\n\tret = uart_register_driver(&serial21285_reg);\n\tif (ret == 0)\n\t\tuart_add_one_port(&serial21285_reg, &serial21285_port);\n\n\treturn ret;\n}\n\nstatic void __exit serial21285_exit(void)\n{\n\tuart_remove_one_port(&serial21285_reg, &serial21285_port);\n\tuart_unregister_driver(&serial21285_reg);\n}\n\nmodule_init(serial21285_init);\nmodule_exit(serial21285_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Intel Footbridge (21285) serial driver\");\nMODULE_ALIAS_CHARDEV(SERIAL_21285_MAJOR, SERIAL_21285_MINOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}