{
  "module_name": "ip22zilog.c",
  "hash_id": "ad6bd98954d8e386920cbb21077e4572a9238873f0999c9043a1312bf8f080f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/ip22zilog.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/circ_buf.h>\n#include <linux/serial.h>\n#include <linux/sysrq.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <asm/sgialib.h>\n#include <asm/sgi/ioc.h>\n#include <asm/sgi/hpc3.h>\n#include <asm/sgi/ip22.h>\n\n#include <linux/serial_core.h>\n\n#include \"ip22zilog.h\"\n\n \n#define ZSDELAY()\t\tudelay(5)\n#define ZSDELAY_LONG()\t\tudelay(20)\n#define ZS_WSYNC(channel)\tdo { } while (0)\n\n#define NUM_IP22ZILOG\t\t1\n#define NUM_CHANNELS\t\t(NUM_IP22ZILOG * 2)\n\n#define ZS_CLOCK\t\t3672000\t \n#define ZS_CLOCK_DIVISOR\t16       \n\n \nstruct uart_ip22zilog_port {\n\tstruct uart_port\t\tport;\n\n\t \n\tstruct uart_ip22zilog_port\t*next;\n\n\t \n\tunsigned char\t\t\tcurregs[NUM_ZSREGS];\n\n\tunsigned int\t\t\tflags;\n#define IP22ZILOG_FLAG_IS_CONS\t\t0x00000004\n#define IP22ZILOG_FLAG_IS_KGDB\t\t0x00000008\n#define IP22ZILOG_FLAG_MODEM_STATUS\t0x00000010\n#define IP22ZILOG_FLAG_IS_CHANNEL_A\t0x00000020\n#define IP22ZILOG_FLAG_REGS_HELD\t0x00000040\n#define IP22ZILOG_FLAG_TX_STOPPED\t0x00000080\n#define IP22ZILOG_FLAG_TX_ACTIVE\t0x00000100\n#define IP22ZILOG_FLAG_RESET_DONE\t0x00000200\n\n\tunsigned int\t\t\ttty_break;\n\n\tunsigned char\t\t\tparity_mask;\n\tunsigned char\t\t\tprev_status;\n};\n\n#define ZILOG_CHANNEL_FROM_PORT(PORT)\t((struct zilog_channel *)((PORT)->membase))\n#define UART_ZILOG(PORT)\t\t((struct uart_ip22zilog_port *)(PORT))\n#define IP22ZILOG_GET_CURR_REG(PORT, REGNUM)\t\t\\\n\t(UART_ZILOG(PORT)->curregs[REGNUM])\n#define IP22ZILOG_SET_CURR_REG(PORT, REGNUM, REGVAL)\t\\\n\t((UART_ZILOG(PORT)->curregs[REGNUM]) = (REGVAL))\n#define ZS_IS_CONS(UP)\t((UP)->flags & IP22ZILOG_FLAG_IS_CONS)\n#define ZS_IS_KGDB(UP)\t((UP)->flags & IP22ZILOG_FLAG_IS_KGDB)\n#define ZS_WANTS_MODEM_STATUS(UP)\t((UP)->flags & IP22ZILOG_FLAG_MODEM_STATUS)\n#define ZS_IS_CHANNEL_A(UP)\t((UP)->flags & IP22ZILOG_FLAG_IS_CHANNEL_A)\n#define ZS_REGS_HELD(UP)\t((UP)->flags & IP22ZILOG_FLAG_REGS_HELD)\n#define ZS_TX_STOPPED(UP)\t((UP)->flags & IP22ZILOG_FLAG_TX_STOPPED)\n#define ZS_TX_ACTIVE(UP)\t((UP)->flags & IP22ZILOG_FLAG_TX_ACTIVE)\n\n \nstatic unsigned char read_zsreg(struct zilog_channel *channel,\n\t\t\t\tunsigned char reg)\n{\n\tunsigned char retval;\n\n\twriteb(reg, &channel->control);\n\tZSDELAY();\n\tretval = readb(&channel->control);\n\tZSDELAY();\n\n\treturn retval;\n}\n\nstatic void write_zsreg(struct zilog_channel *channel,\n\t\t\tunsigned char reg, unsigned char value)\n{\n\twriteb(reg, &channel->control);\n\tZSDELAY();\n\twriteb(value, &channel->control);\n\tZSDELAY();\n}\n\nstatic void ip22zilog_clear_fifo(struct zilog_channel *channel)\n{\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tunsigned char regval;\n\n\t\tregval = readb(&channel->control);\n\t\tZSDELAY();\n\t\tif (regval & Rx_CH_AV)\n\t\t\tbreak;\n\n\t\tregval = read_zsreg(channel, R1);\n\t\treadb(&channel->data);\n\t\tZSDELAY();\n\n\t\tif (regval & (PAR_ERR | Rx_OVR | CRC_ERR)) {\n\t\t\twriteb(ERR_RES, &channel->control);\n\t\t\tZSDELAY();\n\t\t\tZS_WSYNC(channel);\n\t\t}\n\t}\n}\n\n \nstatic void __load_zsregs(struct zilog_channel *channel, unsigned char *regs)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 1000; i++) {\n\t\tunsigned char stat = read_zsreg(channel, R1);\n\t\tif (stat & ALL_SNT)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\n\twriteb(ERR_RES, &channel->control);\n\tZSDELAY();\n\tZS_WSYNC(channel);\n\n\tip22zilog_clear_fifo(channel);\n\n\t \n\twrite_zsreg(channel, R1,\n\t\t    regs[R1] & ~(RxINT_MASK | TxINT_ENAB | EXT_INT_ENAB));\n\n\t \n\twrite_zsreg(channel, R4, regs[R4]);\n\n\t \n\twrite_zsreg(channel, R10, regs[R10]);\n\n\t \n\twrite_zsreg(channel, R3, regs[R3] & ~RxENAB);\n\twrite_zsreg(channel, R5, regs[R5] & ~TxENAB);\n\n\t \n\twrite_zsreg(channel, R6, regs[R6]);\n\twrite_zsreg(channel, R7, regs[R7]);\n\n\t \n\n\t \n\twrite_zsreg(channel, R14, regs[R14] & ~BRENAB);\n\n\t \n\twrite_zsreg(channel, R11, regs[R11]);\n\n\t \n\twrite_zsreg(channel, R12, regs[R12]);\n\twrite_zsreg(channel, R13, regs[R13]);\n\n\t \n\twrite_zsreg(channel, R14, regs[R14]);\n\n\t \n\twrite_zsreg(channel, R15, regs[R15]);\n\n\t \n\twrite_zsreg(channel, R0, RES_EXT_INT);\n\twrite_zsreg(channel, R0, RES_EXT_INT);\n\n\t \n\twrite_zsreg(channel, R3, regs[R3]);\n\twrite_zsreg(channel, R5, regs[R5]);\n\n\t \n\twrite_zsreg(channel, R1, regs[R1]);\n}\n\n \nstatic void ip22zilog_maybe_update_regs(struct uart_ip22zilog_port *up,\n\t\t\t\t       struct zilog_channel *channel)\n{\n\tif (!ZS_REGS_HELD(up)) {\n\t\tif (ZS_TX_ACTIVE(up)) {\n\t\t\tup->flags |= IP22ZILOG_FLAG_REGS_HELD;\n\t\t} else {\n\t\t\t__load_zsregs(channel, up->curregs);\n\t\t}\n\t}\n}\n\n#define Rx_BRK 0x0100                    \n#define Rx_SYS 0x0200                    \n\nstatic bool ip22zilog_receive_chars(struct uart_ip22zilog_port *up,\n\t\t\t\t\t\t  struct zilog_channel *channel)\n{\n\tunsigned int r1;\n\tu8 ch, flag;\n\tbool push = up->port.state != NULL;\n\n\tfor (;;) {\n\t\tch = readb(&channel->control);\n\t\tZSDELAY();\n\t\tif (!(ch & Rx_CH_AV))\n\t\t\tbreak;\n\n\t\tr1 = read_zsreg(channel, R1);\n\t\tif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR)) {\n\t\t\twriteb(ERR_RES, &channel->control);\n\t\t\tZSDELAY();\n\t\t\tZS_WSYNC(channel);\n\t\t}\n\n\t\tch = readb(&channel->data);\n\t\tZSDELAY();\n\n\t\tch &= up->parity_mask;\n\n\t\t \n\t\tif (!ch)\n\t\t\tr1 |= up->tty_break;\n\n\t\t \n\t\tflag = TTY_NORMAL;\n\t\tup->port.icount.rx++;\n\t\tif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR | Rx_SYS | Rx_BRK)) {\n\t\t\tup->tty_break = 0;\n\n\t\t\tif (r1 & (Rx_SYS | Rx_BRK)) {\n\t\t\t\tup->port.icount.brk++;\n\t\t\t\tif (r1 & Rx_SYS)\n\t\t\t\t\tcontinue;\n\t\t\t\tr1 &= ~(PAR_ERR | CRC_ERR);\n\t\t\t}\n\t\t\telse if (r1 & PAR_ERR)\n\t\t\t\tup->port.icount.parity++;\n\t\t\telse if (r1 & CRC_ERR)\n\t\t\t\tup->port.icount.frame++;\n\t\t\tif (r1 & Rx_OVR)\n\t\t\t\tup->port.icount.overrun++;\n\t\t\tr1 &= up->port.read_status_mask;\n\t\t\tif (r1 & Rx_BRK)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (r1 & PAR_ERR)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (r1 & CRC_ERR)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(&up->port, ch))\n\t\t\tcontinue;\n\n\t\tif (push)\n\t\t\tuart_insert_char(&up->port, r1, Rx_OVR, ch, flag);\n\t}\n\treturn push;\n}\n\nstatic void ip22zilog_status_handle(struct uart_ip22zilog_port *up,\n\t\t\t\t   struct zilog_channel *channel)\n{\n\tunsigned char status;\n\n\tstatus = readb(&channel->control);\n\tZSDELAY();\n\n\twriteb(RES_EXT_INT, &channel->control);\n\tZSDELAY();\n\tZS_WSYNC(channel);\n\n\tif (up->curregs[R15] & BRKIE) {\n\t\tif ((status & BRK_ABRT) && !(up->prev_status & BRK_ABRT)) {\n\t\t\tif (uart_handle_break(&up->port))\n\t\t\t\tup->tty_break = Rx_SYS;\n\t\t\telse\n\t\t\t\tup->tty_break = Rx_BRK;\n\t\t}\n\t}\n\n\tif (ZS_WANTS_MODEM_STATUS(up)) {\n\t\tif (status & SYNC)\n\t\t\tup->port.icount.dsr++;\n\n\t\t \n\t\tif ((status ^ up->prev_status) ^ DCD)\n\t\t\tuart_handle_dcd_change(&up->port,\n\t\t\t\t\t       (status & DCD));\n\t\tif ((status ^ up->prev_status) ^ CTS)\n\t\t\tuart_handle_cts_change(&up->port,\n\t\t\t\t\t       (status & CTS));\n\n\t\twake_up_interruptible(&up->port.state->port.delta_msr_wait);\n\t}\n\n\tup->prev_status = status;\n}\n\nstatic void ip22zilog_transmit_chars(struct uart_ip22zilog_port *up,\n\t\t\t\t    struct zilog_channel *channel)\n{\n\tstruct circ_buf *xmit;\n\n\tif (ZS_IS_CONS(up)) {\n\t\tunsigned char status = readb(&channel->control);\n\t\tZSDELAY();\n\n\t\t \n\t\tif (!(status & Tx_BUF_EMP))\n\t\t\treturn;\n\t}\n\n\tup->flags &= ~IP22ZILOG_FLAG_TX_ACTIVE;\n\n\tif (ZS_REGS_HELD(up)) {\n\t\t__load_zsregs(channel, up->curregs);\n\t\tup->flags &= ~IP22ZILOG_FLAG_REGS_HELD;\n\t}\n\n\tif (ZS_TX_STOPPED(up)) {\n\t\tup->flags &= ~IP22ZILOG_FLAG_TX_STOPPED;\n\t\tgoto ack_tx_int;\n\t}\n\n\tif (up->port.x_char) {\n\t\tup->flags |= IP22ZILOG_FLAG_TX_ACTIVE;\n\t\twriteb(up->port.x_char, &channel->data);\n\t\tZSDELAY();\n\t\tZS_WSYNC(channel);\n\n\t\tup->port.icount.tx++;\n\t\tup->port.x_char = 0;\n\t\treturn;\n\t}\n\n\tif (up->port.state == NULL)\n\t\tgoto ack_tx_int;\n\txmit = &up->port.state->xmit;\n\tif (uart_circ_empty(xmit))\n\t\tgoto ack_tx_int;\n\tif (uart_tx_stopped(&up->port))\n\t\tgoto ack_tx_int;\n\n\tup->flags |= IP22ZILOG_FLAG_TX_ACTIVE;\n\twriteb(xmit->buf[xmit->tail], &channel->data);\n\tZSDELAY();\n\tZS_WSYNC(channel);\n\n\tuart_xmit_advance(&up->port, 1);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&up->port);\n\n\treturn;\n\nack_tx_int:\n\twriteb(RES_Tx_P, &channel->control);\n\tZSDELAY();\n\tZS_WSYNC(channel);\n}\n\nstatic irqreturn_t ip22zilog_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_ip22zilog_port *up = dev_id;\n\n\twhile (up) {\n\t\tstruct zilog_channel *channel\n\t\t\t= ZILOG_CHANNEL_FROM_PORT(&up->port);\n\t\tunsigned char r3;\n\t\tbool push = false;\n\n\t\tspin_lock(&up->port.lock);\n\t\tr3 = read_zsreg(channel, R3);\n\n\t\t \n\t\tif (r3 & (CHAEXT | CHATxIP | CHARxIP)) {\n\t\t\twriteb(RES_H_IUS, &channel->control);\n\t\t\tZSDELAY();\n\t\t\tZS_WSYNC(channel);\n\n\t\t\tif (r3 & CHARxIP)\n\t\t\t\tpush = ip22zilog_receive_chars(up, channel);\n\t\t\tif (r3 & CHAEXT)\n\t\t\t\tip22zilog_status_handle(up, channel);\n\t\t\tif (r3 & CHATxIP)\n\t\t\t\tip22zilog_transmit_chars(up, channel);\n\t\t}\n\t\tspin_unlock(&up->port.lock);\n\n\t\tif (push)\n\t\t\ttty_flip_buffer_push(&up->port.state->port);\n\n\t\t \n\t\tup = up->next;\n\t\tchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\n\t\tpush = false;\n\n\t\tspin_lock(&up->port.lock);\n\t\tif (r3 & (CHBEXT | CHBTxIP | CHBRxIP)) {\n\t\t\twriteb(RES_H_IUS, &channel->control);\n\t\t\tZSDELAY();\n\t\t\tZS_WSYNC(channel);\n\n\t\t\tif (r3 & CHBRxIP)\n\t\t\t\tpush = ip22zilog_receive_chars(up, channel);\n\t\t\tif (r3 & CHBEXT)\n\t\t\t\tip22zilog_status_handle(up, channel);\n\t\t\tif (r3 & CHBTxIP)\n\t\t\t\tip22zilog_transmit_chars(up, channel);\n\t\t}\n\t\tspin_unlock(&up->port.lock);\n\n\t\tif (push)\n\t\t\ttty_flip_buffer_push(&up->port.state->port);\n\n\t\tup = up->next;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic __inline__ unsigned char ip22zilog_read_channel_status(struct uart_port *port)\n{\n\tstruct zilog_channel *channel;\n\tunsigned char status;\n\n\tchannel = ZILOG_CHANNEL_FROM_PORT(port);\n\tstatus = readb(&channel->control);\n\tZSDELAY();\n\n\treturn status;\n}\n\n \nstatic unsigned int ip22zilog_tx_empty(struct uart_port *port)\n{\n\tunsigned long flags;\n\tunsigned char status;\n\tunsigned int ret;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tstatus = ip22zilog_read_channel_status(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (status & Tx_BUF_EMP)\n\t\tret = TIOCSER_TEMT;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\n \nstatic unsigned int ip22zilog_get_mctrl(struct uart_port *port)\n{\n\tunsigned char status;\n\tunsigned int ret;\n\n\tstatus = ip22zilog_read_channel_status(port);\n\n\tret = 0;\n\tif (status & DCD)\n\t\tret |= TIOCM_CAR;\n\tif (status & SYNC)\n\t\tret |= TIOCM_DSR;\n\tif (status & CTS)\n\t\tret |= TIOCM_CTS;\n\n\treturn ret;\n}\n\n \nstatic void ip22zilog_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_ip22zilog_port *up =\n\t\tcontainer_of(port, struct uart_ip22zilog_port, port);\n\tstruct zilog_channel *channel = ZILOG_CHANNEL_FROM_PORT(port);\n\tunsigned char set_bits, clear_bits;\n\n\tset_bits = clear_bits = 0;\n\n\tif (mctrl & TIOCM_RTS)\n\t\tset_bits |= RTS;\n\telse\n\t\tclear_bits |= RTS;\n\tif (mctrl & TIOCM_DTR)\n\t\tset_bits |= DTR;\n\telse\n\t\tclear_bits |= DTR;\n\n\t \n\tup->curregs[R5] |= set_bits;\n\tup->curregs[R5] &= ~clear_bits;\n\twrite_zsreg(channel, R5, up->curregs[R5]);\n}\n\n \nstatic void ip22zilog_stop_tx(struct uart_port *port)\n{\n\tstruct uart_ip22zilog_port *up =\n\t\tcontainer_of(port, struct uart_ip22zilog_port, port);\n\n\tup->flags |= IP22ZILOG_FLAG_TX_STOPPED;\n}\n\n \nstatic void ip22zilog_start_tx(struct uart_port *port)\n{\n\tstruct uart_ip22zilog_port *up =\n\t\tcontainer_of(port, struct uart_ip22zilog_port, port);\n\tstruct zilog_channel *channel = ZILOG_CHANNEL_FROM_PORT(port);\n\tunsigned char status;\n\n\tup->flags |= IP22ZILOG_FLAG_TX_ACTIVE;\n\tup->flags &= ~IP22ZILOG_FLAG_TX_STOPPED;\n\n\tstatus = readb(&channel->control);\n\tZSDELAY();\n\n\t \n\tif (!(status & Tx_BUF_EMP))\n\t\treturn;\n\n\t \n\tif (port->x_char) {\n\t\twriteb(port->x_char, &channel->data);\n\t\tZSDELAY();\n\t\tZS_WSYNC(channel);\n\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t} else {\n\t\tstruct circ_buf *xmit = &port->state->xmit;\n\n\t\tif (uart_circ_empty(xmit))\n\t\t\treturn;\n\t\twriteb(xmit->buf[xmit->tail], &channel->data);\n\t\tZSDELAY();\n\t\tZS_WSYNC(channel);\n\n\t\tuart_xmit_advance(port, 1);\n\n\t\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\t\tuart_write_wakeup(&up->port);\n\t}\n}\n\n \nstatic void ip22zilog_stop_rx(struct uart_port *port)\n{\n\tstruct uart_ip22zilog_port *up = UART_ZILOG(port);\n\tstruct zilog_channel *channel;\n\n\tif (ZS_IS_CONS(up))\n\t\treturn;\n\n\tchannel = ZILOG_CHANNEL_FROM_PORT(port);\n\n\t \n\tup->curregs[R1] &= ~RxINT_MASK;\n\tip22zilog_maybe_update_regs(up, channel);\n}\n\n \nstatic void ip22zilog_enable_ms(struct uart_port *port)\n{\n\tstruct uart_ip22zilog_port *up =\n\t\tcontainer_of(port, struct uart_ip22zilog_port, port);\n\tstruct zilog_channel *channel = ZILOG_CHANNEL_FROM_PORT(port);\n\tunsigned char new_reg;\n\n\tnew_reg = up->curregs[R15] | (DCDIE | SYNCIE | CTSIE);\n\tif (new_reg != up->curregs[R15]) {\n\t\tup->curregs[R15] = new_reg;\n\n\t\t \n\t\twrite_zsreg(channel, R15, up->curregs[R15]);\n\t}\n}\n\n \nstatic void ip22zilog_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_ip22zilog_port *up =\n\t\tcontainer_of(port, struct uart_ip22zilog_port, port);\n\tstruct zilog_channel *channel = ZILOG_CHANNEL_FROM_PORT(port);\n\tunsigned char set_bits, clear_bits, new_reg;\n\tunsigned long flags;\n\n\tset_bits = clear_bits = 0;\n\n\tif (break_state)\n\t\tset_bits |= SND_BRK;\n\telse\n\t\tclear_bits |= SND_BRK;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tnew_reg = (up->curregs[R5] | set_bits) & ~clear_bits;\n\tif (new_reg != up->curregs[R5]) {\n\t\tup->curregs[R5] = new_reg;\n\n\t\t \n\t\twrite_zsreg(channel, R5, up->curregs[R5]);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void __ip22zilog_reset(struct uart_ip22zilog_port *up)\n{\n\tstruct zilog_channel *channel;\n\tint i;\n\n\tif (up->flags & IP22ZILOG_FLAG_RESET_DONE)\n\t\treturn;\n\n\t \n\tchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\n\tfor (i = 0; i < 1000; i++) {\n\t\tunsigned char stat = read_zsreg(channel, R1);\n\t\tif (stat & ALL_SNT)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\n\tif (!ZS_IS_CHANNEL_A(up)) {\n\t\tup++;\n\t\tchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\n\t}\n\twrite_zsreg(channel, R9, FHWRES);\n\tZSDELAY_LONG();\n\t(void) read_zsreg(channel, R0);\n\n\tup->flags |= IP22ZILOG_FLAG_RESET_DONE;\n\tup->next->flags |= IP22ZILOG_FLAG_RESET_DONE;\n}\n\nstatic void __ip22zilog_startup(struct uart_ip22zilog_port *up)\n{\n\tstruct zilog_channel *channel;\n\n\tchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\n\n\t__ip22zilog_reset(up);\n\n\t__load_zsregs(channel, up->curregs);\n\t \n\twrite_zsreg(channel, R9, up->curregs[R9]);\n\tup->prev_status = readb(&channel->control);\n\n\t \n\tup->curregs[R3] |= RxENAB;\n\tup->curregs[R5] |= TxENAB;\n\n\tup->curregs[R1] |= EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB;\n\tip22zilog_maybe_update_regs(up, channel);\n}\n\nstatic int ip22zilog_startup(struct uart_port *port)\n{\n\tstruct uart_ip22zilog_port *up = UART_ZILOG(port);\n\tunsigned long flags;\n\n\tif (ZS_IS_CONS(up))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\t__ip22zilog_startup(up);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\treturn 0;\n}\n\n \nstatic void ip22zilog_shutdown(struct uart_port *port)\n{\n\tstruct uart_ip22zilog_port *up = UART_ZILOG(port);\n\tstruct zilog_channel *channel;\n\tunsigned long flags;\n\n\tif (ZS_IS_CONS(up))\n\t\treturn;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tchannel = ZILOG_CHANNEL_FROM_PORT(port);\n\n\t \n\tup->curregs[R3] &= ~RxENAB;\n\tup->curregs[R5] &= ~TxENAB;\n\n\t \n\tup->curregs[R1] &= ~(EXT_INT_ENAB | TxINT_ENAB | RxINT_MASK);\n\tup->curregs[R5] &= ~SND_BRK;\n\tip22zilog_maybe_update_regs(up, channel);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic void\nip22zilog_convert_to_zs(struct uart_ip22zilog_port *up, unsigned int cflag,\n\t\t       unsigned int iflag, int brg)\n{\n\n\tup->curregs[R10] = NRZ;\n\tup->curregs[R11] = TCBR | RCBR;\n\n\t \n\tup->curregs[R4] &= ~XCLK_MASK;\n\tup->curregs[R4] |= X16CLK;\n\tup->curregs[R12] = brg & 0xff;\n\tup->curregs[R13] = (brg >> 8) & 0xff;\n\tup->curregs[R14] = BRENAB;\n\n\t \n\tup->curregs[3] &= ~RxN_MASK;\n\tup->curregs[5] &= ~TxN_MASK;\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\tup->curregs[3] |= Rx5;\n\t\tup->curregs[5] |= Tx5;\n\t\tup->parity_mask = 0x1f;\n\t\tbreak;\n\tcase CS6:\n\t\tup->curregs[3] |= Rx6;\n\t\tup->curregs[5] |= Tx6;\n\t\tup->parity_mask = 0x3f;\n\t\tbreak;\n\tcase CS7:\n\t\tup->curregs[3] |= Rx7;\n\t\tup->curregs[5] |= Tx7;\n\t\tup->parity_mask = 0x7f;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tup->curregs[3] |= Rx8;\n\t\tup->curregs[5] |= Tx8;\n\t\tup->parity_mask = 0xff;\n\t\tbreak;\n\t}\n\tup->curregs[4] &= ~0x0c;\n\tif (cflag & CSTOPB)\n\t\tup->curregs[4] |= SB2;\n\telse\n\t\tup->curregs[4] |= SB1;\n\tif (cflag & PARENB)\n\t\tup->curregs[4] |= PAR_ENAB;\n\telse\n\t\tup->curregs[4] &= ~PAR_ENAB;\n\tif (!(cflag & PARODD))\n\t\tup->curregs[4] |= PAR_EVEN;\n\telse\n\t\tup->curregs[4] &= ~PAR_EVEN;\n\n\tup->port.read_status_mask = Rx_OVR;\n\tif (iflag & INPCK)\n\t\tup->port.read_status_mask |= CRC_ERR | PAR_ERR;\n\tif (iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tup->port.read_status_mask |= BRK_ABRT;\n\n\tup->port.ignore_status_mask = 0;\n\tif (iflag & IGNPAR)\n\t\tup->port.ignore_status_mask |= CRC_ERR | PAR_ERR;\n\tif (iflag & IGNBRK) {\n\t\tup->port.ignore_status_mask |= BRK_ABRT;\n\t\tif (iflag & IGNPAR)\n\t\t\tup->port.ignore_status_mask |= Rx_OVR;\n\t}\n\n\tif ((cflag & CREAD) == 0)\n\t\tup->port.ignore_status_mask = 0xff;\n}\n\n \nstatic void\nip22zilog_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t      const struct ktermios *old)\n{\n\tstruct uart_ip22zilog_port *up =\n\t\tcontainer_of(port, struct uart_ip22zilog_port, port);\n\tunsigned long flags;\n\tint baud, brg;\n\n\tbaud = uart_get_baud_rate(port, termios, old, 1200, 76800);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tbrg = BPS_TO_BRG(baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\n\n\tip22zilog_convert_to_zs(up, termios->c_cflag, termios->c_iflag, brg);\n\n\tif (UART_ENABLE_MS(&up->port, termios->c_cflag))\n\t\tup->flags |= IP22ZILOG_FLAG_MODEM_STATUS;\n\telse\n\t\tup->flags &= ~IP22ZILOG_FLAG_MODEM_STATUS;\n\n\tip22zilog_maybe_update_regs(up, ZILOG_CHANNEL_FROM_PORT(port));\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic const char *ip22zilog_type(struct uart_port *port)\n{\n\treturn \"IP22-Zilog\";\n}\n\n \nstatic void ip22zilog_release_port(struct uart_port *port)\n{\n}\n\nstatic int ip22zilog_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\n \nstatic void ip22zilog_config_port(struct uart_port *port, int flags)\n{\n}\n\n \nstatic int ip22zilog_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct uart_ops ip22zilog_pops = {\n\t.tx_empty\t=\tip22zilog_tx_empty,\n\t.set_mctrl\t=\tip22zilog_set_mctrl,\n\t.get_mctrl\t=\tip22zilog_get_mctrl,\n\t.stop_tx\t=\tip22zilog_stop_tx,\n\t.start_tx\t=\tip22zilog_start_tx,\n\t.stop_rx\t=\tip22zilog_stop_rx,\n\t.enable_ms\t=\tip22zilog_enable_ms,\n\t.break_ctl\t=\tip22zilog_break_ctl,\n\t.startup\t=\tip22zilog_startup,\n\t.shutdown\t=\tip22zilog_shutdown,\n\t.set_termios\t=\tip22zilog_set_termios,\n\t.type\t\t=\tip22zilog_type,\n\t.release_port\t=\tip22zilog_release_port,\n\t.request_port\t=\tip22zilog_request_port,\n\t.config_port\t=\tip22zilog_config_port,\n\t.verify_port\t=\tip22zilog_verify_port,\n};\n\nstatic struct uart_ip22zilog_port *ip22zilog_port_table;\nstatic struct zilog_layout **ip22zilog_chip_regs;\n\nstatic struct uart_ip22zilog_port *ip22zilog_irq_chain;\nstatic int zilog_irq = -1;\n\nstatic void * __init alloc_one_table(unsigned long size)\n{\n\treturn kzalloc(size, GFP_KERNEL);\n}\n\nstatic void __init ip22zilog_alloc_tables(void)\n{\n\tip22zilog_port_table = (struct uart_ip22zilog_port *)\n\t\talloc_one_table(NUM_CHANNELS * sizeof(struct uart_ip22zilog_port));\n\tip22zilog_chip_regs = (struct zilog_layout **)\n\t\talloc_one_table(NUM_IP22ZILOG * sizeof(struct zilog_layout *));\n\n\tif (ip22zilog_port_table == NULL || ip22zilog_chip_regs == NULL) {\n\t\tpanic(\"IP22-Zilog: Cannot allocate IP22-Zilog tables.\");\n\t}\n}\n\n \nstatic struct zilog_layout * __init get_zs(int chip)\n{\n\tunsigned long base;\n\n\tif (chip < 0 || chip >= NUM_IP22ZILOG) {\n\t\tpanic(\"IP22-Zilog: Illegal chip number %d in get_zs.\", chip);\n\t}\n\n\t \n\tbase = (unsigned long) &sgioc->uart;\n\n\tzilog_irq = SGI_SERIAL_IRQ;\n\trequest_mem_region(base, 8, \"IP22-Zilog\");\n\n\treturn (struct zilog_layout *) base;\n}\n\n#define ZS_PUT_CHAR_MAX_DELAY\t2000\t \n\n#ifdef CONFIG_SERIAL_IP22_ZILOG_CONSOLE\nstatic void ip22zilog_put_char(struct uart_port *port, unsigned char ch)\n{\n\tstruct zilog_channel *channel = ZILOG_CHANNEL_FROM_PORT(port);\n\tint loops = ZS_PUT_CHAR_MAX_DELAY;\n\n\t \n\tdo {\n\t\tunsigned char val = readb(&channel->control);\n\t\tif (val & Tx_BUF_EMP) {\n\t\t\tZSDELAY();\n\t\t\tbreak;\n\t\t}\n\t\tudelay(5);\n\t} while (--loops);\n\n\twriteb(ch, &channel->data);\n\tZSDELAY();\n\tZS_WSYNC(channel);\n}\n\nstatic void\nip22zilog_console_write(struct console *con, const char *s, unsigned int count)\n{\n\tstruct uart_ip22zilog_port *up = &ip22zilog_port_table[con->index];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tuart_console_write(&up->port, s, count, ip22zilog_put_char);\n\tudelay(2);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\nstatic int __init ip22zilog_console_setup(struct console *con, char *options)\n{\n\tstruct uart_ip22zilog_port *up = &ip22zilog_port_table[con->index];\n\tunsigned long flags;\n\tint baud = 9600, bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tup->flags |= IP22ZILOG_FLAG_IS_CONS;\n\n\tprintk(KERN_INFO \"Console: ttyS%d (IP22-Zilog)\\n\", con->index);\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\tup->curregs[R15] |= BRKIE;\n\n\t__ip22zilog_startup(up);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\treturn uart_set_options(&up->port, con, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver ip22zilog_reg;\n\nstatic struct console ip22zilog_console = {\n\t.name\t=\t\"ttyS\",\n\t.write\t=\tip22zilog_console_write,\n\t.device\t=\tuart_console_device,\n\t.setup\t=\tip22zilog_console_setup,\n\t.flags\t=\tCON_PRINTBUFFER,\n\t.index\t=\t-1,\n\t.data\t=\t&ip22zilog_reg,\n};\n#endif  \n\nstatic struct uart_driver ip22zilog_reg = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"serial\",\n\t.dev_name\t= \"ttyS\",\n\t.major\t\t= TTY_MAJOR,\n\t.minor\t\t= 64,\n\t.nr\t\t= NUM_CHANNELS,\n#ifdef CONFIG_SERIAL_IP22_ZILOG_CONSOLE\n\t.cons\t\t= &ip22zilog_console,\n#endif\n};\n\nstatic void __init ip22zilog_prepare(void)\n{\n\tunsigned char sysrq_on = IS_ENABLED(CONFIG_SERIAL_IP22_ZILOG_CONSOLE);\n\tstruct uart_ip22zilog_port *up;\n\tstruct zilog_layout *rp;\n\tint channel, chip;\n\n\t \n\tfor (channel = 0; channel < NUM_CHANNELS; channel++)\n\t\tspin_lock_init(&ip22zilog_port_table[channel].port.lock);\n\n\tip22zilog_irq_chain = &ip22zilog_port_table[NUM_CHANNELS - 1];\n        up = &ip22zilog_port_table[0];\n\tfor (channel = NUM_CHANNELS - 1 ; channel > 0; channel--)\n\t\tup[channel].next = &up[channel - 1];\n\tup[channel].next = NULL;\n\n\tfor (chip = 0; chip < NUM_IP22ZILOG; chip++) {\n\t\tif (!ip22zilog_chip_regs[chip]) {\n\t\t\tip22zilog_chip_regs[chip] = rp = get_zs(chip);\n\n\t\t\tup[(chip * 2) + 0].port.membase = (char *) &rp->channelB;\n\t\t\tup[(chip * 2) + 1].port.membase = (char *) &rp->channelA;\n\n\t\t\t \n\t\t\tup[(chip * 2) + 0].port.mapbase =\n\t\t\t\t(unsigned long) ioremap((unsigned long) &rp->channelB, 8);\n\t\t\tup[(chip * 2) + 1].port.mapbase =\n\t\t\t\t(unsigned long) ioremap((unsigned long) &rp->channelA, 8);\n\t\t}\n\n\t\t \n\t\tup[(chip * 2) + 0].port.iotype = UPIO_MEM;\n\t\tup[(chip * 2) + 0].port.irq = zilog_irq;\n\t\tup[(chip * 2) + 0].port.uartclk = ZS_CLOCK;\n\t\tup[(chip * 2) + 0].port.fifosize = 1;\n\t\tup[(chip * 2) + 0].port.has_sysrq = sysrq_on;\n\t\tup[(chip * 2) + 0].port.ops = &ip22zilog_pops;\n\t\tup[(chip * 2) + 0].port.type = PORT_IP22ZILOG;\n\t\tup[(chip * 2) + 0].port.flags = 0;\n\t\tup[(chip * 2) + 0].port.line = (chip * 2) + 0;\n\t\tup[(chip * 2) + 0].flags = 0;\n\n\t\t \n\t\tup[(chip * 2) + 1].port.iotype = UPIO_MEM;\n\t\tup[(chip * 2) + 1].port.irq = zilog_irq;\n\t\tup[(chip * 2) + 1].port.uartclk = ZS_CLOCK;\n\t\tup[(chip * 2) + 1].port.fifosize = 1;\n\t\tup[(chip * 2) + 1].port.has_sysrq = sysrq_on;\n\t\tup[(chip * 2) + 1].port.ops = &ip22zilog_pops;\n\t\tup[(chip * 2) + 1].port.type = PORT_IP22ZILOG;\n\t\tup[(chip * 2) + 1].port.line = (chip * 2) + 1;\n\t\tup[(chip * 2) + 1].flags |= IP22ZILOG_FLAG_IS_CHANNEL_A;\n\t}\n\n\tfor (channel = 0; channel < NUM_CHANNELS; channel++) {\n\t\tstruct uart_ip22zilog_port *up = &ip22zilog_port_table[channel];\n\t\tint brg;\n\n\t\t \n\t\tup->parity_mask = 0xff;\n\t\tup->curregs[R1] = EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB;\n\t\tup->curregs[R4] = PAR_EVEN | X16CLK | SB1;\n\t\tup->curregs[R3] = RxENAB | Rx8;\n\t\tup->curregs[R5] = TxENAB | Tx8;\n\t\tup->curregs[R9] = NV | MIE;\n\t\tup->curregs[R10] = NRZ;\n\t\tup->curregs[R11] = TCBR | RCBR;\n\t\tbrg = BPS_TO_BRG(9600, ZS_CLOCK / ZS_CLOCK_DIVISOR);\n\t\tup->curregs[R12] = (brg & 0xff);\n\t\tup->curregs[R13] = (brg >> 8) & 0xff;\n\t\tup->curregs[R14] = BRENAB;\n\t}\n}\n\nstatic int __init ip22zilog_ports_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO \"Serial: IP22 Zilog driver (%d chips).\\n\", NUM_IP22ZILOG);\n\n\tip22zilog_prepare();\n\n\tif (request_irq(zilog_irq, ip22zilog_interrupt, 0,\n\t\t\t\"IP22-Zilog\", ip22zilog_irq_chain)) {\n\t\tpanic(\"IP22-Zilog: Unable to register zs interrupt handler.\\n\");\n\t}\n\n\tret = uart_register_driver(&ip22zilog_reg);\n\tif (ret == 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < NUM_CHANNELS; i++) {\n\t\t\tstruct uart_ip22zilog_port *up = &ip22zilog_port_table[i];\n\n\t\t\tuart_add_one_port(&ip22zilog_reg, &up->port);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int __init ip22zilog_init(void)\n{\n\t \n\tip22zilog_alloc_tables();\n\tip22zilog_ports_init();\n\n\treturn 0;\n}\n\nstatic void __exit ip22zilog_exit(void)\n{\n\tint i;\n\tstruct uart_ip22zilog_port *up;\n\n\tfor (i = 0; i < NUM_CHANNELS; i++) {\n\t\tup = &ip22zilog_port_table[i];\n\n\t\tuart_remove_one_port(&ip22zilog_reg, &up->port);\n\t}\n\n\t \n\tup = &ip22zilog_port_table[0];\n\tfor (i = 0; i < NUM_IP22ZILOG; i++) {\n\t\tif (up[(i * 2) + 0].port.mapbase) {\n\t\t   iounmap((void*)up[(i * 2) + 0].port.mapbase);\n\t\t   up[(i * 2) + 0].port.mapbase = 0;\n\t\t}\n\t\tif (up[(i * 2) + 1].port.mapbase) {\n\t\t\tiounmap((void*)up[(i * 2) + 1].port.mapbase);\n\t\t\tup[(i * 2) + 1].port.mapbase = 0;\n\t\t}\n\t}\n\n\tuart_unregister_driver(&ip22zilog_reg);\n}\n\nmodule_init(ip22zilog_init);\nmodule_exit(ip22zilog_exit);\n\n \nMODULE_AUTHOR(\"Ralf Baechle <ralf@linux-mips.org>\");\nMODULE_DESCRIPTION(\"SGI Zilog serial port driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}