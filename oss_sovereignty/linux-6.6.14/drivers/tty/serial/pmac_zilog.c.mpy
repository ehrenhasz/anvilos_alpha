{
  "module_name": "pmac_zilog.c",
  "hash_id": "35dba85d0b6577badbe1695ed332d6d526eef499538d369bb18802c15bae6c72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/pmac_zilog.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n#undef USE_CTRL_O_SYSRQ\n\n#include <linux/module.h>\n#include <linux/tty.h>\n\n#include <linux/tty_flip.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/adb.h>\n#include <linux/pmu.h>\n#include <linux/bitops.h>\n#include <linux/sysrq.h>\n#include <linux/mutex.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <asm/sections.h>\n#include <linux/io.h>\n#include <asm/irq.h>\n\n#ifdef CONFIG_PPC_PMAC\n#include <asm/machdep.h>\n#include <asm/pmac_feature.h>\n#include <asm/macio.h>\n#else\n#include <linux/platform_device.h>\n#define of_machine_is_compatible(x) (0)\n#endif\n\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n\n#include \"pmac_zilog.h\"\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"Driver for the Mac and PowerMac serial ports.\");\nMODULE_LICENSE(\"GPL\");\n\n#ifdef CONFIG_SERIAL_PMACZILOG_TTYS\n#define PMACZILOG_MAJOR\t\tTTY_MAJOR\n#define PMACZILOG_MINOR\t\t64\n#define PMACZILOG_NAME\t\t\"ttyS\"\n#else\n#define PMACZILOG_MAJOR\t\t204\n#define PMACZILOG_MINOR\t\t192\n#define PMACZILOG_NAME\t\t\"ttyPZ\"\n#endif\n\n#define pmz_debug(fmt, arg...)\tpr_debug(\"ttyPZ%d: \" fmt, uap->port.line, ## arg)\n#define pmz_error(fmt, arg...)\tpr_err(\"ttyPZ%d: \" fmt, uap->port.line, ## arg)\n#define pmz_info(fmt, arg...)\tpr_info(\"ttyPZ%d: \" fmt, uap->port.line, ## arg)\n\n \nstatic struct uart_pmac_port\tpmz_ports[MAX_ZS_PORTS];\nstatic int\t\t\tpmz_ports_count;\n\nstatic struct uart_driver pmz_uart_reg = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.driver_name\t=\tPMACZILOG_NAME,\n\t.dev_name\t=\tPMACZILOG_NAME,\n\t.major\t\t=\tPMACZILOG_MAJOR,\n\t.minor\t\t=\tPMACZILOG_MINOR,\n};\n\n\n \nstatic void pmz_load_zsregs(struct uart_pmac_port *uap, u8 *regs)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 1000; i++) {\n\t\tunsigned char stat = read_zsreg(uap, R1);\n\t\tif (stat & ALL_SNT)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\n\tZS_CLEARERR(uap);\n\tzssync(uap);\n\tZS_CLEARFIFO(uap);\n\tzssync(uap);\n\tZS_CLEARERR(uap);\n\n\t \n\twrite_zsreg(uap, R1,\n\t\t    regs[R1] & ~(RxINT_MASK | TxINT_ENAB | EXT_INT_ENAB));\n\n\t \n\twrite_zsreg(uap, R4, regs[R4]);\n\n\t \n\twrite_zsreg(uap, R10, regs[R10]);\n\n\t \n\twrite_zsreg(uap, R3, regs[R3] & ~RxENABLE);\n\twrite_zsreg(uap, R5, regs[R5] & ~TxENABLE);\n\n\t \n\twrite_zsreg(uap, R15, regs[R15] | EN85C30);\n\twrite_zsreg(uap, R7, regs[R7P]);\n\n\t \n\twrite_zsreg(uap, R15, regs[R15] & ~EN85C30);\n\n\t \n\twrite_zsreg(uap, R6, regs[R6]);\n\twrite_zsreg(uap, R7, regs[R7]);\n\n\t \n\twrite_zsreg(uap, R14, regs[R14] & ~BRENAB);\n\n\t \n\twrite_zsreg(uap, R11, regs[R11]);\n\n\t \n\twrite_zsreg(uap, R12, regs[R12]);\n\twrite_zsreg(uap, R13, regs[R13]);\n\t\n\t \n\twrite_zsreg(uap, R14, regs[R14]);\n\n\t \n\twrite_zsreg(uap, R0, RES_EXT_INT);\n\twrite_zsreg(uap, R0, RES_EXT_INT);\n\n\t \n\twrite_zsreg(uap, R3, regs[R3]);\n\twrite_zsreg(uap, R5, regs[R5]);\n\n\t \n\twrite_zsreg(uap, R1, regs[R1]);\n\n\t \n\twrite_zsreg(uap, R9, regs[R9]);\n}\n\n \nstatic void pmz_maybe_update_regs(struct uart_pmac_port *uap)\n{\n\tif (!ZS_REGS_HELD(uap)) {\n\t\tif (ZS_TX_ACTIVE(uap)) {\n\t\t\tuap->flags |= PMACZILOG_FLAG_REGS_HELD;\n\t\t} else {\n\t\t\tpmz_debug(\"pmz: maybe_update_regs: updating\\n\");\n\t\t\tpmz_load_zsregs(uap, uap->curregs);\n\t\t}\n\t}\n}\n\nstatic void pmz_interrupt_control(struct uart_pmac_port *uap, int enable)\n{\n\tif (enable) {\n\t\tuap->curregs[1] |= INT_ALL_Rx | TxINT_ENAB;\n\t\tif (!ZS_IS_EXTCLK(uap))\n\t\t\tuap->curregs[1] |= EXT_INT_ENAB;\n\t} else {\n\t\tuap->curregs[1] &= ~(EXT_INT_ENAB | TxINT_ENAB | RxINT_MASK);\n\t}\n\twrite_zsreg(uap, R1, uap->curregs[1]);\n}\n\nstatic bool pmz_receive_chars(struct uart_pmac_port *uap)\n\t__must_hold(&uap->port.lock)\n{\n\tstruct tty_port *port;\n\tunsigned char ch, r1, drop, flag;\n\tint loops = 0;\n\n\t \n\tif (uap->port.state == NULL) {\n\t\tWARN_ON(1);\n\t\t(void)read_zsdata(uap);\n\t\treturn false;\n\t}\n\tport = &uap->port.state->port;\n\n\twhile (1) {\n\t\tdrop = 0;\n\n\t\tr1 = read_zsreg(uap, R1);\n\t\tch = read_zsdata(uap);\n\n\t\tif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR)) {\n\t\t\twrite_zsreg(uap, R0, ERR_RES);\n\t\t\tzssync(uap);\n\t\t}\n\n\t\tch &= uap->parity_mask;\n\t\tif (ch == 0 && uap->flags & PMACZILOG_FLAG_BREAK) {\n\t\t\tuap->flags &= ~PMACZILOG_FLAG_BREAK;\n\t\t}\n\n#if defined(CONFIG_MAGIC_SYSRQ) && defined(CONFIG_SERIAL_CORE_CONSOLE)\n#ifdef USE_CTRL_O_SYSRQ\n\t\t \n\t\tif (ch == '\\x0f') {\n\t\t\tuap->port.sysrq = jiffies + HZ*5;\n\t\t\tgoto next_char;\n\t\t}\n#endif  \n\t\tif (uap->port.sysrq) {\n\t\t\tint swallow;\n\t\t\tspin_unlock(&uap->port.lock);\n\t\t\tswallow = uart_handle_sysrq_char(&uap->port, ch);\n\t\t\tspin_lock(&uap->port.lock);\n\t\t\tif (swallow)\n\t\t\t\tgoto next_char;\n\t\t}\n#endif  \n\n\t\t \n\t\tif (drop)\n\t\t\tgoto next_char;\n\n\t\tflag = TTY_NORMAL;\n\t\tuap->port.icount.rx++;\n\n\t\tif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR | BRK_ABRT)) {\n\t\t\tif (r1 & BRK_ABRT) {\n\t\t\t\tpmz_debug(\"pmz: got break !\\n\");\n\t\t\t\tr1 &= ~(PAR_ERR | CRC_ERR);\n\t\t\t\tuap->port.icount.brk++;\n\t\t\t\tif (uart_handle_break(&uap->port))\n\t\t\t\t\tgoto next_char;\n\t\t\t}\n\t\t\telse if (r1 & PAR_ERR)\n\t\t\t\tuap->port.icount.parity++;\n\t\t\telse if (r1 & CRC_ERR)\n\t\t\t\tuap->port.icount.frame++;\n\t\t\tif (r1 & Rx_OVR)\n\t\t\t\tuap->port.icount.overrun++;\n\t\t\tr1 &= uap->port.read_status_mask;\n\t\t\tif (r1 & BRK_ABRT)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (r1 & PAR_ERR)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (r1 & CRC_ERR)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif (uap->port.ignore_status_mask == 0xff ||\n\t\t    (r1 & uap->port.ignore_status_mask) == 0) {\n\t\t\ttty_insert_flip_char(port, ch, flag);\n\t\t}\n\t\tif (r1 & Rx_OVR)\n\t\t\ttty_insert_flip_char(port, 0, TTY_OVERRUN);\n\tnext_char:\n\t\t \n\t\tif ((++loops) > 1000)\n\t\t\tgoto flood;\n\t\tch = read_zsreg(uap, R0);\n\t\tif (!(ch & Rx_CH_AV))\n\t\t\tbreak;\n\t}\n\n\treturn true;\n flood:\n\tpmz_interrupt_control(uap, 0);\n\tpmz_error(\"pmz: rx irq flood !\\n\");\n\treturn true;\n}\n\nstatic void pmz_status_handle(struct uart_pmac_port *uap)\n{\n\tunsigned char status;\n\n\tstatus = read_zsreg(uap, R0);\n\twrite_zsreg(uap, R0, RES_EXT_INT);\n\tzssync(uap);\n\n\tif (ZS_IS_OPEN(uap) && ZS_WANTS_MODEM_STATUS(uap)) {\n\t\tif (status & SYNC_HUNT)\n\t\t\tuap->port.icount.dsr++;\n\n\t\t \n\t\tif ((status ^ uap->prev_status) & DCD)\n\t\t\tuart_handle_dcd_change(&uap->port,\n\t\t\t\t\t       (status & DCD));\n\t\tif ((status ^ uap->prev_status) & CTS)\n\t\t\tuart_handle_cts_change(&uap->port,\n\t\t\t\t\t       !(status & CTS));\n\n\t\twake_up_interruptible(&uap->port.state->port.delta_msr_wait);\n\t}\n\n\tif (status & BRK_ABRT)\n\t\tuap->flags |= PMACZILOG_FLAG_BREAK;\n\n\tuap->prev_status = status;\n}\n\nstatic void pmz_transmit_chars(struct uart_pmac_port *uap)\n{\n\tstruct circ_buf *xmit;\n\n\tif (ZS_IS_CONS(uap)) {\n\t\tunsigned char status = read_zsreg(uap, R0);\n\n\t\t \n\t\tif (!(status & Tx_BUF_EMP))\n\t\t\treturn;\n\t}\n\n\tuap->flags &= ~PMACZILOG_FLAG_TX_ACTIVE;\n\n\tif (ZS_REGS_HELD(uap)) {\n\t\tpmz_load_zsregs(uap, uap->curregs);\n\t\tuap->flags &= ~PMACZILOG_FLAG_REGS_HELD;\n\t}\n\n\tif (ZS_TX_STOPPED(uap)) {\n\t\tuap->flags &= ~PMACZILOG_FLAG_TX_STOPPED;\n\t\tgoto ack_tx_int;\n\t}\n\n\t \n\tif (!ZS_IS_OPEN(uap))\n\t\tgoto ack_tx_int;\n\n\tif (uap->port.x_char) {\n\t\tuap->flags |= PMACZILOG_FLAG_TX_ACTIVE;\n\t\twrite_zsdata(uap, uap->port.x_char);\n\t\tzssync(uap);\n\t\tuap->port.icount.tx++;\n\t\tuap->port.x_char = 0;\n\t\treturn;\n\t}\n\n\tif (uap->port.state == NULL)\n\t\tgoto ack_tx_int;\n\txmit = &uap->port.state->xmit;\n\tif (uart_circ_empty(xmit)) {\n\t\tuart_write_wakeup(&uap->port);\n\t\tgoto ack_tx_int;\n\t}\n\tif (uart_tx_stopped(&uap->port))\n\t\tgoto ack_tx_int;\n\n\tuap->flags |= PMACZILOG_FLAG_TX_ACTIVE;\n\twrite_zsdata(uap, xmit->buf[xmit->tail]);\n\tzssync(uap);\n\n\tuart_xmit_advance(&uap->port, 1);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&uap->port);\n\n\treturn;\n\nack_tx_int:\n\twrite_zsreg(uap, R0, RES_Tx_P);\n\tzssync(uap);\n}\n\n \nstatic irqreturn_t pmz_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_pmac_port *uap = dev_id;\n\tstruct uart_pmac_port *uap_a;\n\tstruct uart_pmac_port *uap_b;\n\tint rc = IRQ_NONE;\n\tbool push;\n\tu8 r3;\n\n\tuap_a = pmz_get_port_A(uap);\n\tuap_b = uap_a->mate;\n\n\tspin_lock(&uap_a->port.lock);\n\tr3 = read_zsreg(uap_a, R3);\n\n\t \n\tpush = false;\n\tif (r3 & (CHAEXT | CHATxIP | CHARxIP)) {\n\t\tif (!ZS_IS_OPEN(uap_a)) {\n\t\t\tpmz_debug(\"ChanA interrupt while not open !\\n\");\n\t\t\tgoto skip_a;\n\t\t}\n\t\twrite_zsreg(uap_a, R0, RES_H_IUS);\n\t\tzssync(uap_a);\t\t\n\t\tif (r3 & CHAEXT)\n\t\t\tpmz_status_handle(uap_a);\n\t\tif (r3 & CHARxIP)\n\t\t\tpush = pmz_receive_chars(uap_a);\n\t\tif (r3 & CHATxIP)\n\t\t\tpmz_transmit_chars(uap_a);\n\t\trc = IRQ_HANDLED;\n\t}\n skip_a:\n\tspin_unlock(&uap_a->port.lock);\n\tif (push)\n\t\ttty_flip_buffer_push(&uap->port.state->port);\n\n\tif (!uap_b)\n\t\tgoto out;\n\n\tspin_lock(&uap_b->port.lock);\n\tpush = false;\n\tif (r3 & (CHBEXT | CHBTxIP | CHBRxIP)) {\n\t\tif (!ZS_IS_OPEN(uap_b)) {\n\t\t\tpmz_debug(\"ChanB interrupt while not open !\\n\");\n\t\t\tgoto skip_b;\n\t\t}\n\t\twrite_zsreg(uap_b, R0, RES_H_IUS);\n\t\tzssync(uap_b);\n\t\tif (r3 & CHBEXT)\n\t\t\tpmz_status_handle(uap_b);\n\t\tif (r3 & CHBRxIP)\n\t\t\tpush = pmz_receive_chars(uap_b);\n\t\tif (r3 & CHBTxIP)\n\t\t\tpmz_transmit_chars(uap_b);\n\t\trc = IRQ_HANDLED;\n\t}\n skip_b:\n\tspin_unlock(&uap_b->port.lock);\n\tif (push)\n\t\ttty_flip_buffer_push(&uap->port.state->port);\n\n out:\n\treturn rc;\n}\n\n \nstatic inline u8 pmz_peek_status(struct uart_pmac_port *uap)\n{\n\tunsigned long flags;\n\tu8 status;\n\t\n\tspin_lock_irqsave(&uap->port.lock, flags);\n\tstatus = read_zsreg(uap, R0);\n\tspin_unlock_irqrestore(&uap->port.lock, flags);\n\n\treturn status;\n}\n\n \nstatic unsigned int pmz_tx_empty(struct uart_port *port)\n{\n\tunsigned char status;\n\n\tstatus = pmz_peek_status(to_pmz(port));\n\tif (status & Tx_BUF_EMP)\n\t\treturn TIOCSER_TEMT;\n\treturn 0;\n}\n\n \nstatic void pmz_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_pmac_port *uap = to_pmz(port);\n\tunsigned char set_bits, clear_bits;\n\n         \n\tif (ZS_IS_IRDA(uap))\n\t\treturn;\n\t \n\tif (!(ZS_IS_OPEN(uap) || ZS_IS_CONS(uap)))\n\t\treturn;\n\n\tset_bits = clear_bits = 0;\n\n\tif (ZS_IS_INTMODEM(uap)) {\n\t\tif (mctrl & TIOCM_RTS)\n\t\t\tset_bits |= RTS;\n\t\telse\n\t\t\tclear_bits |= RTS;\n\t}\n\tif (mctrl & TIOCM_DTR)\n\t\tset_bits |= DTR;\n\telse\n\t\tclear_bits |= DTR;\n\n\t  \n\tuap->curregs[R5] |= set_bits;\n\tuap->curregs[R5] &= ~clear_bits;\n\n\twrite_zsreg(uap, R5, uap->curregs[R5]);\n\tpmz_debug(\"pmz_set_mctrl: set bits: %x, clear bits: %x -> %x\\n\",\n\t\t  set_bits, clear_bits, uap->curregs[R5]);\n\tzssync(uap);\n}\n\n \nstatic unsigned int pmz_get_mctrl(struct uart_port *port)\n{\n\tstruct uart_pmac_port *uap = to_pmz(port);\n\tunsigned char status;\n\tunsigned int ret;\n\n\tstatus = read_zsreg(uap, R0);\n\n\tret = 0;\n\tif (status & DCD)\n\t\tret |= TIOCM_CAR;\n\tif (status & SYNC_HUNT)\n\t\tret |= TIOCM_DSR;\n\tif (!(status & CTS))\n\t\tret |= TIOCM_CTS;\n\n\treturn ret;\n}\n\n \nstatic void pmz_stop_tx(struct uart_port *port)\n{\n\tto_pmz(port)->flags |= PMACZILOG_FLAG_TX_STOPPED;\n}\n\n \nstatic void pmz_start_tx(struct uart_port *port)\n{\n\tstruct uart_pmac_port *uap = to_pmz(port);\n\tunsigned char status;\n\n\tuap->flags |= PMACZILOG_FLAG_TX_ACTIVE;\n\tuap->flags &= ~PMACZILOG_FLAG_TX_STOPPED;\n\n\tstatus = read_zsreg(uap, R0);\n\n\t \n\tif (!(status & Tx_BUF_EMP))\n\t\treturn;\n\n\t \n\tif (port->x_char) {\n\t\twrite_zsdata(uap, port->x_char);\n\t\tzssync(uap);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t} else {\n\t\tstruct circ_buf *xmit = &port->state->xmit;\n\n\t\tif (uart_circ_empty(xmit))\n\t\t\treturn;\n\t\twrite_zsdata(uap, xmit->buf[xmit->tail]);\n\t\tzssync(uap);\n\t\tuart_xmit_advance(port, 1);\n\n\t\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\t\tuart_write_wakeup(&uap->port);\n\t}\n}\n\n \nstatic void pmz_stop_rx(struct uart_port *port)\n{\n\tstruct uart_pmac_port *uap = to_pmz(port);\n\n\t \n\tuap->curregs[R1] &= ~RxINT_MASK;\n\tpmz_maybe_update_regs(uap);\n}\n\n \nstatic void pmz_enable_ms(struct uart_port *port)\n{\n\tstruct uart_pmac_port *uap = to_pmz(port);\n\tunsigned char new_reg;\n\n\tif (ZS_IS_IRDA(uap))\n\t\treturn;\n\tnew_reg = uap->curregs[R15] | (DCDIE | SYNCIE | CTSIE);\n\tif (new_reg != uap->curregs[R15]) {\n\t\tuap->curregs[R15] = new_reg;\n\n\t\t \n\t\twrite_zsreg(uap, R15, uap->curregs[R15]);\n\t}\n}\n\n \nstatic void pmz_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_pmac_port *uap = to_pmz(port);\n\tunsigned char set_bits, clear_bits, new_reg;\n\tunsigned long flags;\n\n\tset_bits = clear_bits = 0;\n\n\tif (break_state)\n\t\tset_bits |= SND_BRK;\n\telse\n\t\tclear_bits |= SND_BRK;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tnew_reg = (uap->curregs[R5] | set_bits) & ~clear_bits;\n\tif (new_reg != uap->curregs[R5]) {\n\t\tuap->curregs[R5] = new_reg;\n\t\twrite_zsreg(uap, R5, uap->curregs[R5]);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n#ifdef CONFIG_PPC_PMAC\n\n \nstatic int pmz_set_scc_power(struct uart_pmac_port *uap, int state)\n{\n\tint delay = 0;\n\tint rc;\n\n\tif (state) {\n\t\trc = pmac_call_feature(\n\t\t\tPMAC_FTR_SCC_ENABLE, uap->node, uap->port_type, 1);\n\t\tpmz_debug(\"port power on result: %d\\n\", rc);\n\t\tif (ZS_IS_INTMODEM(uap)) {\n\t\t\trc = pmac_call_feature(\n\t\t\t\tPMAC_FTR_MODEM_ENABLE, uap->node, 0, 1);\n\t\t\tdelay = 2500;\t \n\t\t\tpmz_debug(\"modem power result: %d\\n\", rc);\n\t\t}\n\t} else {\n\t\t \n\t\tif (ZS_IS_INTMODEM(uap)) {\n\t\t\trc = pmac_call_feature(\n\t\t\t\tPMAC_FTR_MODEM_ENABLE, uap->node, 0, 0);\n\t\t\tpmz_debug(\"port power off result: %d\\n\", rc);\n\t\t}\n\t\tpmac_call_feature(PMAC_FTR_SCC_ENABLE, uap->node, uap->port_type, 0);\n\t}\n\treturn delay;\n}\n\n#else\n\nstatic int pmz_set_scc_power(struct uart_pmac_port *uap, int state)\n{\n\treturn 0;\n}\n\n#endif  \n\n \nstatic void pmz_fix_zero_bug_scc(struct uart_pmac_port *uap)\n{\n\twrite_zsreg(uap, 9, ZS_IS_CHANNEL_A(uap) ? CHRA : CHRB);\n\tzssync(uap);\n\tudelay(10);\n\twrite_zsreg(uap, 9, (ZS_IS_CHANNEL_A(uap) ? CHRA : CHRB) | NV);\n\tzssync(uap);\n\n\twrite_zsreg(uap, 4, X1CLK | MONSYNC);\n\twrite_zsreg(uap, 3, Rx8);\n\twrite_zsreg(uap, 5, Tx8 | RTS);\n\twrite_zsreg(uap, 9, NV);\t \n\twrite_zsreg(uap, 11, RCBR | TCBR);\n\twrite_zsreg(uap, 12, 0);\n\twrite_zsreg(uap, 13, 0);\n\twrite_zsreg(uap, 14, (LOOPBAK | BRSRC));\n\twrite_zsreg(uap, 14, (LOOPBAK | BRSRC | BRENAB));\n\twrite_zsreg(uap, 3, Rx8 | RxENABLE);\n\twrite_zsreg(uap, 0, RES_EXT_INT);\n\twrite_zsreg(uap, 0, RES_EXT_INT);\n\twrite_zsreg(uap, 0, RES_EXT_INT);\t \n\n\t \n\twrite_zsreg(uap, 9, NV);\n\twrite_zsreg(uap, 4, X16CLK | SB_MASK);\n\twrite_zsreg(uap, 3, Rx8);\n\n\twhile (read_zsreg(uap, 0) & Rx_CH_AV) {\n\t\t(void)read_zsreg(uap, 8);\n\t\twrite_zsreg(uap, 0, RES_EXT_INT);\n\t\twrite_zsreg(uap, 0, ERR_RES);\n\t}\n}\n\n \nstatic int __pmz_startup(struct uart_pmac_port *uap)\n{\n\tint pwr_delay = 0;\n\n\tmemset(&uap->curregs, 0, sizeof(uap->curregs));\n\n\t \n\tpwr_delay = pmz_set_scc_power(uap, 1);\n\n\t \n\tpmz_fix_zero_bug_scc(uap);\n\n\t \n\tuap->curregs[R9] = 0;\n\twrite_zsreg(uap, 9, ZS_IS_CHANNEL_A(uap) ? CHRA : CHRB);\n\tzssync(uap);\n\tudelay(10);\n\twrite_zsreg(uap, 9, 0);\n\tzssync(uap);\n\n\t \n\twrite_zsreg(uap, R1, 0);\n\twrite_zsreg(uap, R0, ERR_RES);\n\twrite_zsreg(uap, R0, ERR_RES);\n\twrite_zsreg(uap, R0, RES_H_IUS);\n\twrite_zsreg(uap, R0, RES_H_IUS);\n\n\t \n\tuap->curregs[R4] = X16CLK | SB1;\n\tuap->curregs[R3] = Rx8;\n\tuap->curregs[R5] = Tx8 | RTS;\n\tif (!ZS_IS_IRDA(uap))\n\t\tuap->curregs[R5] |= DTR;\n\tuap->curregs[R12] = 0;\n\tuap->curregs[R13] = 0;\n\tuap->curregs[R14] = BRENAB;\n\n\t \n\tuap->curregs[R15] = BRKIE;\n\n\t \n\tuap->curregs[R9] |= NV | MIE;\n\n\tpmz_load_zsregs(uap, uap->curregs);\n\n\t \n\twrite_zsreg(uap, R3, uap->curregs[R3] |= RxENABLE);\n\twrite_zsreg(uap, R5, uap->curregs[R5] |= TxENABLE);\n\n\t \n\tuap->prev_status = read_zsreg(uap, R0);\n\n\treturn pwr_delay;\n}\n\nstatic void pmz_irda_reset(struct uart_pmac_port *uap)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&uap->port.lock, flags);\n\tuap->curregs[R5] |= DTR;\n\twrite_zsreg(uap, R5, uap->curregs[R5]);\n\tzssync(uap);\n\tspin_unlock_irqrestore(&uap->port.lock, flags);\n\tmsleep(110);\n\n\tspin_lock_irqsave(&uap->port.lock, flags);\n\tuap->curregs[R5] &= ~DTR;\n\twrite_zsreg(uap, R5, uap->curregs[R5]);\n\tzssync(uap);\n\tspin_unlock_irqrestore(&uap->port.lock, flags);\n\tmsleep(10);\n}\n\n \nstatic int pmz_startup(struct uart_port *port)\n{\n\tstruct uart_pmac_port *uap = to_pmz(port);\n\tunsigned long flags;\n\tint pwr_delay = 0;\n\n\tuap->flags |= PMACZILOG_FLAG_IS_OPEN;\n\n\t \n\tif (!ZS_IS_CONS(uap)) {\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tpwr_delay = __pmz_startup(uap);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t}\t\n\tsprintf(uap->irq_name, PMACZILOG_NAME\"%d\", uap->port.line);\n\tif (request_irq(uap->port.irq, pmz_interrupt, IRQF_SHARED,\n\t\t\tuap->irq_name, uap)) {\n\t\tpmz_error(\"Unable to register zs interrupt handler.\\n\");\n\t\tpmz_set_scc_power(uap, 0);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tif (pwr_delay != 0) {\n\t\tpmz_debug(\"pmz: delaying %d ms\\n\", pwr_delay);\n\t\tmsleep(pwr_delay);\n\t}\n\n\t \n\tif (ZS_IS_IRDA(uap))\n\t\tpmz_irda_reset(uap);\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tpmz_interrupt_control(uap, 1);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn 0;\n}\n\nstatic void pmz_shutdown(struct uart_port *port)\n{\n\tstruct uart_pmac_port *uap = to_pmz(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tpmz_interrupt_control(uap, 0);\n\n\tif (!ZS_IS_CONS(uap)) {\n\t\t \n\t\tuap->curregs[R3] &= ~RxENABLE;\n\t\tuap->curregs[R5] &= ~TxENABLE;\n\n\t\t \n\t\tuap->curregs[R5] &= ~SND_BRK;\n\t\tpmz_maybe_update_regs(uap);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\tfree_irq(uap->port.irq, uap);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tuap->flags &= ~PMACZILOG_FLAG_IS_OPEN;\n\n\tif (!ZS_IS_CONS(uap))\n\t\tpmz_set_scc_power(uap, 0);\t \n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic void pmz_convert_to_zs(struct uart_pmac_port *uap, unsigned int cflag,\n\t\t\t      unsigned int iflag, unsigned long baud)\n{\n\tint brg;\n\n\t \n\tif (baud >= 115200 && ZS_IS_IRDA(uap)) {\n\t\tuap->curregs[R4] = X1CLK;\n\t\tuap->curregs[R11] = RCTRxCP | TCTRxCP;\n\t\tuap->curregs[R14] = 0;  \n\t\tuap->curregs[R12] = 0;\n\t\tuap->curregs[R13] = 0;\n\t\tuap->flags |= PMACZILOG_FLAG_IS_EXTCLK;\n\t} else {\n\t\tswitch (baud) {\n\t\tcase ZS_CLOCK/16:\t \n\t\t\tuap->curregs[R4] = X16CLK;\n\t\t\tuap->curregs[R11] = 0;\n\t\t\tuap->curregs[R14] = 0;\n\t\t\tbreak;\n\t\tcase ZS_CLOCK/32:\t \n\t\t\tuap->curregs[R4] = X32CLK;\n\t\t\tuap->curregs[R11] = 0;\n\t\t\tuap->curregs[R14] = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tuap->curregs[R4] = X16CLK;\n\t\t\tuap->curregs[R11] = TCBR | RCBR;\n\t\t\tbrg = BPS_TO_BRG(baud, ZS_CLOCK / 16);\n\t\t\tuap->curregs[R12] = (brg & 255);\n\t\t\tuap->curregs[R13] = ((brg >> 8) & 255);\n\t\t\tuap->curregs[R14] = BRENAB;\n\t\t}\n\t\tuap->flags &= ~PMACZILOG_FLAG_IS_EXTCLK;\n\t}\n\n\t \n\tuap->curregs[3] &= ~RxN_MASK;\n\tuap->curregs[5] &= ~TxN_MASK;\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\tuap->curregs[3] |= Rx5;\n\t\tuap->curregs[5] |= Tx5;\n\t\tuap->parity_mask = 0x1f;\n\t\tbreak;\n\tcase CS6:\n\t\tuap->curregs[3] |= Rx6;\n\t\tuap->curregs[5] |= Tx6;\n\t\tuap->parity_mask = 0x3f;\n\t\tbreak;\n\tcase CS7:\n\t\tuap->curregs[3] |= Rx7;\n\t\tuap->curregs[5] |= Tx7;\n\t\tuap->parity_mask = 0x7f;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tuap->curregs[3] |= Rx8;\n\t\tuap->curregs[5] |= Tx8;\n\t\tuap->parity_mask = 0xff;\n\t\tbreak;\n\t}\n\tuap->curregs[4] &= ~(SB_MASK);\n\tif (cflag & CSTOPB)\n\t\tuap->curregs[4] |= SB2;\n\telse\n\t\tuap->curregs[4] |= SB1;\n\tif (cflag & PARENB)\n\t\tuap->curregs[4] |= PAR_ENAB;\n\telse\n\t\tuap->curregs[4] &= ~PAR_ENAB;\n\tif (!(cflag & PARODD))\n\t\tuap->curregs[4] |= PAR_EVEN;\n\telse\n\t\tuap->curregs[4] &= ~PAR_EVEN;\n\n\tuap->port.read_status_mask = Rx_OVR;\n\tif (iflag & INPCK)\n\t\tuap->port.read_status_mask |= CRC_ERR | PAR_ERR;\n\tif (iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tuap->port.read_status_mask |= BRK_ABRT;\n\n\tuap->port.ignore_status_mask = 0;\n\tif (iflag & IGNPAR)\n\t\tuap->port.ignore_status_mask |= CRC_ERR | PAR_ERR;\n\tif (iflag & IGNBRK) {\n\t\tuap->port.ignore_status_mask |= BRK_ABRT;\n\t\tif (iflag & IGNPAR)\n\t\t\tuap->port.ignore_status_mask |= Rx_OVR;\n\t}\n\n\tif ((cflag & CREAD) == 0)\n\t\tuap->port.ignore_status_mask = 0xff;\n}\n\n\n \nstatic void pmz_irda_setup(struct uart_pmac_port *uap, unsigned long *baud)\n{\n\tu8 cmdbyte;\n\tint t, version;\n\n\tswitch (*baud) {\n\t \n\tcase 2400:\n\t\tcmdbyte = 0x53;\n\t\tbreak;\n\tcase 4800:\n\t\tcmdbyte = 0x52;\n\t\tbreak;\n\tcase 9600:\n\t\tcmdbyte = 0x51;\n\t\tbreak;\n\tcase 19200:\n\t\tcmdbyte = 0x50;\n\t\tbreak;\n\tcase 38400:\n\t\tcmdbyte = 0x4f;\n\t\tbreak;\n\tcase 57600:\n\t\tcmdbyte = 0x4e;\n\t\tbreak;\n\tcase 115200:\n\t\tcmdbyte = 0x4d;\n\t\tbreak;\n\t \n\tcase 1152000:\n\t\tcmdbyte = 0;\n\t\tbreak;\n\tcase 4000000:\n\t\tcmdbyte = 0;\n\t\tbreak;\n\tdefault:  \n\t\tcmdbyte = 0x51;\n\t\t*baud = 9600;\n\t\tbreak;\n\t}\n\n\t \n\tt = 10000;\n\twhile ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0\n\t       || (read_zsreg(uap, R1) & ALL_SNT) == 0) {\n\t\tif (--t <= 0) {\n\t\t\tpmz_error(\"transmitter didn't drain\\n\");\n\t\t\treturn;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\t \n\tt = 100;\n\t(void)read_zsdata(uap);\n\t(void)read_zsdata(uap);\n\t(void)read_zsdata(uap);\n\tmdelay(10);\n\twhile (read_zsreg(uap, R0) & Rx_CH_AV) {\n\t\tread_zsdata(uap);\n\t\tmdelay(10);\n\t\tif (--t <= 0) {\n\t\t\tpmz_error(\"receiver didn't drain\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tuap->curregs[R5] |= DTR;\n\twrite_zsreg(uap, R5, uap->curregs[R5]);\n\tzssync(uap);\n\tmdelay(1);\n\n\t \n\tpmz_convert_to_zs(uap, CS8, 0, 19200);\t\t\n\tpmz_load_zsregs(uap, uap->curregs);\n\tmdelay(1);\n\n\t \n\twrite_zsdata(uap, 1);\n\tt = 5000;\n\twhile ((read_zsreg(uap, R0) & Rx_CH_AV) == 0) {\n\t\tif (--t <= 0) {\n\t\t\tpmz_error(\"irda_setup timed out on get_version byte\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tudelay(10);\n\t}\n\tversion = read_zsdata(uap);\n\n\tif (version < 4) {\n\t\tpmz_info(\"IrDA: dongle version %d not supported\\n\", version);\n\t\tgoto out;\n\t}\n\n\t \n\twrite_zsdata(uap, cmdbyte);\n\tt = 5000;\n\twhile ((read_zsreg(uap, R0) & Rx_CH_AV) == 0) {\n\t\tif (--t <= 0) {\n\t\t\tpmz_error(\"irda_setup timed out on speed mode byte\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tudelay(10);\n\t}\n\tt = read_zsdata(uap);\n\tif (t != cmdbyte)\n\t\tpmz_error(\"irda_setup speed mode byte = %x (%x)\\n\", t, cmdbyte);\n\n\tpmz_info(\"IrDA setup for %ld bps, dongle version: %d\\n\",\n\t\t *baud, version);\n\n\t(void)read_zsdata(uap);\n\t(void)read_zsdata(uap);\n\t(void)read_zsdata(uap);\n\n out:\n\t \n\tuap->curregs[R5] &= ~DTR;\n\twrite_zsreg(uap, R5, uap->curregs[R5]);\n\tzssync(uap);\n\n\t(void)read_zsdata(uap);\n\t(void)read_zsdata(uap);\n\t(void)read_zsdata(uap);\n}\n\n\nstatic void __pmz_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t\t      const struct ktermios *old)\n{\n\tstruct uart_pmac_port *uap = to_pmz(port);\n\tunsigned long baud;\n\n\t \n\tif (ZS_IS_IRDA(uap)) {\n\t\t \n\t\tbaud = uart_get_baud_rate(port, termios, old, 1200, 4000000);\n\t\tpmz_debug(\"pmz: switch IRDA to %ld bauds\\n\", baud);\n\t\t \n\t\tpmz_irda_setup(uap, &baud);\n\t\t \n\t\tpmz_convert_to_zs(uap, termios->c_cflag, termios->c_iflag, baud);\n\t\tpmz_load_zsregs(uap, uap->curregs);\n\t\tzssync(uap);\n\t} else {\n\t\tbaud = uart_get_baud_rate(port, termios, old, 1200, 230400);\n\t\tpmz_convert_to_zs(uap, termios->c_cflag, termios->c_iflag, baud);\n\t\t \n\t\tif (UART_ENABLE_MS(&uap->port, termios->c_cflag)) {\n\t\t\tuap->curregs[R15] |= DCDIE | SYNCIE | CTSIE;\n\t\t\tuap->flags |= PMACZILOG_FLAG_MODEM_STATUS;\n\t\t} else {\n\t\t\tuap->curregs[R15] &= ~(DCDIE | SYNCIE | CTSIE);\n\t\t\tuap->flags &= ~PMACZILOG_FLAG_MODEM_STATUS;\n\t\t}\n\n\t\t \n\t\tpmz_maybe_update_regs(uap);\n\t}\n\tuart_update_timeout(port, termios->c_cflag, baud);\n}\n\n \nstatic void pmz_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t\t    const struct ktermios *old)\n{\n\tstruct uart_pmac_port *uap = to_pmz(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\t\n\n\t \n\tpmz_interrupt_control(uap, 0);\n\n\t \n\t__pmz_set_termios(port, termios, old);\n\n\t \n\tif (ZS_IS_OPEN(uap))\n\t\tpmz_interrupt_control(uap, 1);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *pmz_type(struct uart_port *port)\n{\n\tstruct uart_pmac_port *uap = to_pmz(port);\n\n\tif (ZS_IS_IRDA(uap))\n\t\treturn \"Z85c30 ESCC - Infrared port\";\n\telse if (ZS_IS_INTMODEM(uap))\n\t\treturn \"Z85c30 ESCC - Internal modem\";\n\treturn \"Z85c30 ESCC - Serial port\";\n}\n\n \nstatic void pmz_release_port(struct uart_port *port)\n{\n}\n\nstatic int pmz_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\n \nstatic void pmz_config_port(struct uart_port *port, int flags)\n{\n}\n\n \nstatic int pmz_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n\nstatic int pmz_poll_get_char(struct uart_port *port)\n{\n\tstruct uart_pmac_port *uap =\n\t\tcontainer_of(port, struct uart_pmac_port, port);\n\tint tries = 2;\n\n\twhile (tries) {\n\t\tif ((read_zsreg(uap, R0) & Rx_CH_AV) != 0)\n\t\t\treturn read_zsdata(uap);\n\t\tif (tries--)\n\t\t\tudelay(5);\n\t}\n\n\treturn NO_POLL_CHAR;\n}\n\nstatic void pmz_poll_put_char(struct uart_port *port, unsigned char c)\n{\n\tstruct uart_pmac_port *uap =\n\t\tcontainer_of(port, struct uart_pmac_port, port);\n\n\t \n\twhile ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0)\n\t\tudelay(5);\n\twrite_zsdata(uap, c);\n}\n\n#endif  \n\nstatic const struct uart_ops pmz_pops = {\n\t.tx_empty\t=\tpmz_tx_empty,\n\t.set_mctrl\t=\tpmz_set_mctrl,\n\t.get_mctrl\t=\tpmz_get_mctrl,\n\t.stop_tx\t=\tpmz_stop_tx,\n\t.start_tx\t=\tpmz_start_tx,\n\t.stop_rx\t=\tpmz_stop_rx,\n\t.enable_ms\t=\tpmz_enable_ms,\n\t.break_ctl\t=\tpmz_break_ctl,\n\t.startup\t=\tpmz_startup,\n\t.shutdown\t=\tpmz_shutdown,\n\t.set_termios\t=\tpmz_set_termios,\n\t.type\t\t=\tpmz_type,\n\t.release_port\t=\tpmz_release_port,\n\t.request_port\t=\tpmz_request_port,\n\t.config_port\t=\tpmz_config_port,\n\t.verify_port\t=\tpmz_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t=\tpmz_poll_get_char,\n\t.poll_put_char\t=\tpmz_poll_put_char,\n#endif\n};\n\n#ifdef CONFIG_PPC_PMAC\n\n \nstatic int __init pmz_init_port(struct uart_pmac_port *uap)\n{\n\tstruct device_node *np = uap->node;\n\tconst char *conn;\n\tconst struct slot_names_prop {\n\t\tint\tcount;\n\t\tchar\tname[1];\n\t} *slots;\n\tint len;\n\tstruct resource r_ports;\n\n\t \n\tif (of_address_to_resource(np, 0, &r_ports))\n\t\treturn -ENODEV;\n\tuap->port.mapbase = r_ports.start;\n\tuap->port.membase = ioremap(uap->port.mapbase, 0x1000);\n\n\tuap->control_reg = uap->port.membase;\n\tuap->data_reg = uap->control_reg + 0x10;\n\n\t \n\tif (of_device_is_compatible(np, \"cobalt\"))\n\t\tuap->flags |= PMACZILOG_FLAG_IS_INTMODEM;\n\tconn = of_get_property(np, \"AAPL,connector\", &len);\n\tif (conn && (strcmp(conn, \"infrared\") == 0))\n\t\tuap->flags |= PMACZILOG_FLAG_IS_IRDA;\n\tuap->port_type = PMAC_SCC_ASYNC;\n\t \n\tslots = of_get_property(np, \"slot-names\", &len);\n\tif (slots && slots->count > 0) {\n\t\tif (strcmp(slots->name, \"IrDA\") == 0)\n\t\t\tuap->flags |= PMACZILOG_FLAG_IS_IRDA;\n\t\telse if (strcmp(slots->name, \"Modem\") == 0)\n\t\t\tuap->flags |= PMACZILOG_FLAG_IS_INTMODEM;\n\t}\n\tif (ZS_IS_IRDA(uap))\n\t\tuap->port_type = PMAC_SCC_IRDA;\n\tif (ZS_IS_INTMODEM(uap)) {\n\t\tstruct device_node* i2c_modem =\n\t\t\tof_find_node_by_name(NULL, \"i2c-modem\");\n\t\tif (i2c_modem) {\n\t\t\tconst char* mid =\n\t\t\t\tof_get_property(i2c_modem, \"modem-id\", NULL);\n\t\t\tif (mid) switch(*mid) {\n\t\t\tcase 0x04 :\n\t\t\tcase 0x05 :\n\t\t\tcase 0x07 :\n\t\t\tcase 0x08 :\n\t\t\tcase 0x0b :\n\t\t\tcase 0x0c :\n\t\t\t\tuap->port_type = PMAC_SCC_I2S1;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"pmac_zilog: i2c-modem detected, id: %d\\n\",\n\t\t\t\tmid ? (*mid) : 0);\n\t\t\tof_node_put(i2c_modem);\n\t\t} else {\n\t\t\tprintk(KERN_INFO \"pmac_zilog: serial modem detected\\n\");\n\t\t}\n\t}\n\n\t \n\tuap->port.iotype = UPIO_MEM;\n\tuap->port.irq = irq_of_parse_and_map(np, 0);\n\tuap->port.uartclk = ZS_CLOCK;\n\tuap->port.fifosize = 1;\n\tuap->port.ops = &pmz_pops;\n\tuap->port.type = PORT_PMAC_ZILOG;\n\tuap->port.flags = 0;\n\n\t \n\tif (uap->port.irq == 0 &&\n\t    np->parent && np->parent->parent &&\n\t    of_device_is_compatible(np->parent->parent, \"gatwick\")) {\n\t\t \n\t\tuap->port.irq = irq_create_mapping(NULL, 64 + 15);\n\t}\n\n\t \n\tpmz_convert_to_zs(uap, CS8, 0, 9600);\n\n\treturn 0;\n}\n\n \nstatic void pmz_dispose_port(struct uart_pmac_port *uap)\n{\n\tstruct device_node *np;\n\n\tnp = uap->node;\n\tiounmap(uap->control_reg);\n\tuap->node = NULL;\n\tof_node_put(np);\n\tmemset(uap, 0, sizeof(struct uart_pmac_port));\n}\n\n \nstatic int pmz_attach(struct macio_dev *mdev, const struct of_device_id *match)\n{\n\tstruct uart_pmac_port *uap;\n\tint i;\n\t\n\t \n\tfor (i = 0; i < MAX_ZS_PORTS; i++)\n\t\tif (pmz_ports[i].node == mdev->ofdev.dev.of_node)\n\t\t\tbreak;\n\tif (i >= MAX_ZS_PORTS)\n\t\treturn -ENODEV;\n\n\n\tuap = &pmz_ports[i];\n\tuap->dev = mdev;\n\tuap->port.dev = &mdev->ofdev.dev;\n\tdev_set_drvdata(&mdev->ofdev.dev, uap);\n\n\t \n\tif (macio_request_resources(uap->dev, \"pmac_zilog\"))\n\t\tprintk(KERN_WARNING \"%pOFn: Failed to request resource\"\n\t\t       \", port still active\\n\",\n\t\t       uap->node);\n\telse\n\t\tuap->flags |= PMACZILOG_FLAG_RSRC_REQUESTED;\n\n\treturn uart_add_one_port(&pmz_uart_reg, &uap->port);\n}\n\n \nstatic int pmz_detach(struct macio_dev *mdev)\n{\n\tstruct uart_pmac_port\t*uap = dev_get_drvdata(&mdev->ofdev.dev);\n\t\n\tif (!uap)\n\t\treturn -ENODEV;\n\n\tuart_remove_one_port(&pmz_uart_reg, &uap->port);\n\n\tif (uap->flags & PMACZILOG_FLAG_RSRC_REQUESTED) {\n\t\tmacio_release_resources(uap->dev);\n\t\tuap->flags &= ~PMACZILOG_FLAG_RSRC_REQUESTED;\n\t}\n\tdev_set_drvdata(&mdev->ofdev.dev, NULL);\n\tuap->dev = NULL;\n\tuap->port.dev = NULL;\n\t\n\treturn 0;\n}\n\n\nstatic int pmz_suspend(struct macio_dev *mdev, pm_message_t pm_state)\n{\n\tstruct uart_pmac_port *uap = dev_get_drvdata(&mdev->ofdev.dev);\n\n\tif (uap == NULL) {\n\t\tprintk(\"HRM... pmz_suspend with NULL uap\\n\");\n\t\treturn 0;\n\t}\n\n\tuart_suspend_port(&pmz_uart_reg, &uap->port);\n\n\treturn 0;\n}\n\n\nstatic int pmz_resume(struct macio_dev *mdev)\n{\n\tstruct uart_pmac_port *uap = dev_get_drvdata(&mdev->ofdev.dev);\n\n\tif (uap == NULL)\n\t\treturn 0;\n\n\tuart_resume_port(&pmz_uart_reg, &uap->port);\n\n\treturn 0;\n}\n\n \nstatic int __init pmz_probe(void)\n{\n\tstruct device_node\t*node_p, *node_a, *node_b, *np;\n\tint\t\t\tcount = 0;\n\tint\t\t\trc;\n\n\t \n\tfor_each_node_by_name(node_p, \"escc\") {\n\t\t \n\t\tnode_a = node_b = NULL;\n\t\tfor_each_child_of_node(node_p, np) {\n\t\t\tif (of_node_name_prefix(np, \"ch-a\"))\n\t\t\t\tnode_a = of_node_get(np);\n\t\t\telse if (of_node_name_prefix(np, \"ch-b\"))\n\t\t\t\tnode_b = of_node_get(np);\n\t\t}\n\t\tif (!node_a && !node_b) {\n\t\t\tof_node_put(node_a);\n\t\t\tof_node_put(node_b);\n\t\t\tprintk(KERN_ERR \"pmac_zilog: missing node %c for escc %pOF\\n\",\n\t\t\t\t(!node_a) ? 'a' : 'b', node_p);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (node_b != NULL) {\n\t\t\tpmz_ports[count].mate\t\t= &pmz_ports[count+1];\n\t\t\tpmz_ports[count+1].mate\t\t= &pmz_ports[count];\n\t\t}\n\t\tpmz_ports[count].flags\t\t= PMACZILOG_FLAG_IS_CHANNEL_A;\n\t\tpmz_ports[count].node\t\t= node_a;\n\t\tpmz_ports[count+1].node\t\t= node_b;\n\t\tpmz_ports[count].port.line\t= count;\n\t\tpmz_ports[count+1].port.line\t= count+1;\n\n\t\t \n\t\trc = pmz_init_port(&pmz_ports[count]);\n\t\tif (rc == 0 && node_b != NULL)\n\t\t\trc = pmz_init_port(&pmz_ports[count+1]);\n\t\tif (rc != 0) {\n\t\t\tof_node_put(node_a);\n\t\t\tof_node_put(node_b);\n\t\t\tmemset(&pmz_ports[count], 0, sizeof(struct uart_pmac_port));\n\t\t\tmemset(&pmz_ports[count+1], 0, sizeof(struct uart_pmac_port));\n\t\t\tcontinue;\n\t\t}\n\t\tcount += 2;\n\t}\n\tpmz_ports_count = count;\n\n\treturn 0;\n}\n\n#else\n\n \nextern struct platform_device scc_a_pdev, scc_b_pdev;\n\nstatic int __init pmz_init_port(struct uart_pmac_port *uap)\n{\n\tstruct resource *r_ports;\n\tint irq;\n\n\tr_ports = platform_get_resource(uap->pdev, IORESOURCE_MEM, 0);\n\tif (!r_ports)\n\t\treturn -ENODEV;\n\n\tirq = platform_get_irq(uap->pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tuap->port.mapbase  = r_ports->start;\n\tuap->port.membase  = (unsigned char __iomem *) r_ports->start;\n\tuap->port.iotype   = UPIO_MEM;\n\tuap->port.irq      = irq;\n\tuap->port.uartclk  = ZS_CLOCK;\n\tuap->port.fifosize = 1;\n\tuap->port.ops      = &pmz_pops;\n\tuap->port.type     = PORT_PMAC_ZILOG;\n\tuap->port.flags    = 0;\n\n\tuap->control_reg   = uap->port.membase;\n\tuap->data_reg      = uap->control_reg + 4;\n\tuap->port_type     = 0;\n\tuap->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_PMACZILOG_CONSOLE);\n\n\tpmz_convert_to_zs(uap, CS8, 0, 9600);\n\n\treturn 0;\n}\n\nstatic int __init pmz_probe(void)\n{\n\tint err;\n\n\tpmz_ports_count = 0;\n\n\tpmz_ports[0].port.line = 0;\n\tpmz_ports[0].flags     = PMACZILOG_FLAG_IS_CHANNEL_A;\n\tpmz_ports[0].pdev      = &scc_a_pdev;\n\terr = pmz_init_port(&pmz_ports[0]);\n\tif (err)\n\t\treturn err;\n\tpmz_ports_count++;\n\n\tpmz_ports[0].mate      = &pmz_ports[1];\n\tpmz_ports[1].mate      = &pmz_ports[0];\n\tpmz_ports[1].port.line = 1;\n\tpmz_ports[1].flags     = 0;\n\tpmz_ports[1].pdev      = &scc_b_pdev;\n\terr = pmz_init_port(&pmz_ports[1]);\n\tif (err)\n\t\treturn err;\n\tpmz_ports_count++;\n\n\treturn 0;\n}\n\nstatic void pmz_dispose_port(struct uart_pmac_port *uap)\n{\n\tmemset(uap, 0, sizeof(struct uart_pmac_port));\n}\n\nstatic int __init pmz_attach(struct platform_device *pdev)\n{\n\tstruct uart_pmac_port *uap;\n\tint i;\n\n\t \n\tfor (i = 0; i < pmz_ports_count; i++)\n\t\tif (pmz_ports[i].pdev == pdev)\n\t\t\tbreak;\n\tif (i >= pmz_ports_count)\n\t\treturn -ENODEV;\n\n\tuap = &pmz_ports[i];\n\tuap->port.dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, uap);\n\n\treturn uart_add_one_port(&pmz_uart_reg, &uap->port);\n}\n\nstatic int __exit pmz_detach(struct platform_device *pdev)\n{\n\tstruct uart_pmac_port *uap = platform_get_drvdata(pdev);\n\n\tif (!uap)\n\t\treturn -ENODEV;\n\n\tuart_remove_one_port(&pmz_uart_reg, &uap->port);\n\n\tuap->port.dev = NULL;\n\n\treturn 0;\n}\n\n#endif  \n\n#ifdef CONFIG_SERIAL_PMACZILOG_CONSOLE\n\nstatic void pmz_console_write(struct console *con, const char *s, unsigned int count);\nstatic int __init pmz_console_setup(struct console *co, char *options);\n\nstatic struct console pmz_console = {\n\t.name\t=\tPMACZILOG_NAME,\n\t.write\t=\tpmz_console_write,\n\t.device\t=\tuart_console_device,\n\t.setup\t=\tpmz_console_setup,\n\t.flags\t=\tCON_PRINTBUFFER,\n\t.index\t=\t-1,\n\t.data   =\t&pmz_uart_reg,\n};\n\n#define PMACZILOG_CONSOLE\t&pmz_console\n#else  \n#define PMACZILOG_CONSOLE\t(NULL)\n#endif  \n\n \nstatic int __init pmz_register(void)\n{\n\tpmz_uart_reg.nr = pmz_ports_count;\n\tpmz_uart_reg.cons = PMACZILOG_CONSOLE;\n\n\t \n\treturn uart_register_driver(&pmz_uart_reg);\n}\n\n#ifdef CONFIG_PPC_PMAC\n\nstatic const struct of_device_id pmz_match[] =\n{\n\t{\n\t.name\t\t= \"ch-a\",\n\t},\n\t{\n\t.name\t\t= \"ch-b\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE (of, pmz_match);\n\nstatic struct macio_driver pmz_driver = {\n\t.driver = {\n\t\t.name \t\t= \"pmac_zilog\",\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.of_match_table\t= pmz_match,\n\t},\n\t.probe\t\t= pmz_attach,\n\t.remove\t\t= pmz_detach,\n\t.suspend\t= pmz_suspend,\n\t.resume\t\t= pmz_resume,\n};\n\n#else\n\nstatic struct platform_driver pmz_driver = {\n\t.remove\t\t= __exit_p(pmz_detach),\n\t.driver\t\t= {\n\t\t.name\t\t= \"scc\",\n\t},\n};\n\n#endif  \n\nstatic int __init init_pmz(void)\n{\n\tint rc, i;\n\n\t \n\tif (pmz_ports_count == 0)\n\t\tpmz_probe();\n\n\t \n\tif (pmz_ports_count == 0)\n\t\treturn -ENODEV;\n\n\t \n\trc = pmz_register();\n\tif (rc) {\n\t\tprintk(KERN_ERR \n\t\t\t\"pmac_zilog: Error registering serial device, disabling pmac_zilog.\\n\"\n\t\t \t\"pmac_zilog: Did another serial driver already claim the minors?\\n\"); \n\t\t \n\t\tfor (i=0; i < pmz_ports_count; i++)\n\t\t\tpmz_dispose_port(&pmz_ports[i]);\n\t\treturn rc;\n\t}\n\n\t \n#ifdef CONFIG_PPC_PMAC\n\treturn macio_register_driver(&pmz_driver);\n#else\n\treturn platform_driver_probe(&pmz_driver, pmz_attach);\n#endif\n}\n\nstatic void __exit exit_pmz(void)\n{\n\tint i;\n\n#ifdef CONFIG_PPC_PMAC\n\t \n\tmacio_unregister_driver(&pmz_driver);\n#else\n\tplatform_driver_unregister(&pmz_driver);\n#endif\n\n\tfor (i = 0; i < pmz_ports_count; i++) {\n\t\tstruct uart_pmac_port *uport = &pmz_ports[i];\n#ifdef CONFIG_PPC_PMAC\n\t\tif (uport->node != NULL)\n\t\t\tpmz_dispose_port(uport);\n#else\n\t\tif (uport->pdev != NULL)\n\t\t\tpmz_dispose_port(uport);\n#endif\n\t}\n\t \n\tuart_unregister_driver(&pmz_uart_reg);\n}\n\n#ifdef CONFIG_SERIAL_PMACZILOG_CONSOLE\n\nstatic void pmz_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct uart_pmac_port *uap =\n\t\tcontainer_of(port, struct uart_pmac_port, port);\n\n\t \n\twhile ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0)\n\t\tudelay(5);\n\twrite_zsdata(uap, ch);\n}\n\n \nstatic void pmz_console_write(struct console *con, const char *s, unsigned int count)\n{\n\tstruct uart_pmac_port *uap = &pmz_ports[con->index];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&uap->port.lock, flags);\n\n\t \n\twrite_zsreg(uap, R1, uap->curregs[1] & ~TxINT_ENAB);\n\twrite_zsreg(uap, R5, uap->curregs[5] | TxENABLE | RTS | DTR);\n\n\tuart_console_write(&uap->port, s, count, pmz_console_putchar);\n\n\t \n\twrite_zsreg(uap, R1, uap->curregs[1]);\n\t \n\n\tspin_unlock_irqrestore(&uap->port.lock, flags);\n}\n\n \nstatic int __init pmz_console_setup(struct console *co, char *options)\n{\n\tstruct uart_pmac_port *uap;\n\tstruct uart_port *port;\n\tint baud = 38400;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tunsigned long pwr_delay;\n\n\t \n\tif (of_machine_is_compatible(\"RackMac1,1\")\n\t    || of_machine_is_compatible(\"RackMac1,2\")\n\t    || of_machine_is_compatible(\"MacRISC4\"))\n\t\tbaud = 57600;\n\n\t \n\tif (co->index >= pmz_ports_count)\n\t\tco->index = 0;\n\tuap = &pmz_ports[co->index];\n#ifdef CONFIG_PPC_PMAC\n\tif (uap->node == NULL)\n\t\treturn -ENODEV;\n#else\n\tif (uap->pdev == NULL)\n\t\treturn -ENODEV;\n#endif\n\tport = &uap->port;\n\n\t \n\tuap->flags |= PMACZILOG_FLAG_IS_CONS;\n\n\t \n\tspin_lock_init(&port->lock);\n\n\t \n\tpwr_delay = __pmz_startup(uap);\n\tif (pwr_delay)\n\t\tmdelay(pwr_delay);\n\t\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic int __init pmz_console_init(void)\n{\n\t \n\tpmz_probe();\n\n\tif (pmz_ports_count == 0)\n\t\treturn -ENODEV;\n\n\t \n\t \n\tregister_console(&pmz_console);\n\n\treturn 0;\n\n}\nconsole_initcall(pmz_console_init);\n#endif  \n\nmodule_init(init_pmz);\nmodule_exit(exit_pmz);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}