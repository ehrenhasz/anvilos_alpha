{
  "module_name": "msm_serial.c",
  "hash_id": "7e14275dac062391496611055435e0bd9da3533fdcc843a81c20f7608002974d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/msm_serial.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/dma/qcom_adm.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/wait.h>\n\n#define MSM_UART_MR1\t\t\t0x0000\n\n#define MSM_UART_MR1_AUTO_RFR_LEVEL0\t0x3F\n#define MSM_UART_MR1_AUTO_RFR_LEVEL1\t0x3FF00\n#define MSM_UART_DM_MR1_AUTO_RFR_LEVEL1\t0xFFFFFF00\n#define MSM_UART_MR1_RX_RDY_CTL\t\tBIT(7)\n#define MSM_UART_MR1_CTS_CTL\t\tBIT(6)\n\n#define MSM_UART_MR2\t\t\t0x0004\n#define MSM_UART_MR2_ERROR_MODE\t\tBIT(6)\n#define MSM_UART_MR2_BITS_PER_CHAR\t0x30\n#define MSM_UART_MR2_BITS_PER_CHAR_5\t(0x0 << 4)\n#define MSM_UART_MR2_BITS_PER_CHAR_6\t(0x1 << 4)\n#define MSM_UART_MR2_BITS_PER_CHAR_7\t(0x2 << 4)\n#define MSM_UART_MR2_BITS_PER_CHAR_8\t(0x3 << 4)\n#define MSM_UART_MR2_STOP_BIT_LEN_ONE\t(0x1 << 2)\n#define MSM_UART_MR2_STOP_BIT_LEN_TWO\t(0x3 << 2)\n#define MSM_UART_MR2_PARITY_MODE_NONE\t0x0\n#define MSM_UART_MR2_PARITY_MODE_ODD\t0x1\n#define MSM_UART_MR2_PARITY_MODE_EVEN\t0x2\n#define MSM_UART_MR2_PARITY_MODE_SPACE\t0x3\n#define MSM_UART_MR2_PARITY_MODE\t0x3\n\n#define MSM_UART_CSR\t\t\t0x0008\n\n#define MSM_UART_TF\t\t\t0x000C\n#define UARTDM_TF\t\t\t0x0070\n\n#define MSM_UART_CR\t\t\t\t0x0010\n#define MSM_UART_CR_CMD_NULL\t\t\t(0 << 4)\n#define MSM_UART_CR_CMD_RESET_RX\t\t(1 << 4)\n#define MSM_UART_CR_CMD_RESET_TX\t\t(2 << 4)\n#define MSM_UART_CR_CMD_RESET_ERR\t\t(3 << 4)\n#define MSM_UART_CR_CMD_RESET_BREAK_INT\t\t(4 << 4)\n#define MSM_UART_CR_CMD_START_BREAK\t\t(5 << 4)\n#define MSM_UART_CR_CMD_STOP_BREAK\t\t(6 << 4)\n#define MSM_UART_CR_CMD_RESET_CTS\t\t(7 << 4)\n#define MSM_UART_CR_CMD_RESET_STALE_INT\t\t(8 << 4)\n#define MSM_UART_CR_CMD_PACKET_MODE\t\t(9 << 4)\n#define MSM_UART_CR_CMD_MODE_RESET\t\t(12 << 4)\n#define MSM_UART_CR_CMD_SET_RFR\t\t\t(13 << 4)\n#define MSM_UART_CR_CMD_RESET_RFR\t\t(14 << 4)\n#define MSM_UART_CR_CMD_PROTECTION_EN\t\t(16 << 4)\n#define MSM_UART_CR_CMD_STALE_EVENT_DISABLE\t(6 << 8)\n#define MSM_UART_CR_CMD_STALE_EVENT_ENABLE\t(80 << 4)\n#define MSM_UART_CR_CMD_FORCE_STALE\t\t(4 << 8)\n#define MSM_UART_CR_CMD_RESET_TX_READY\t\t(3 << 8)\n#define MSM_UART_CR_TX_DISABLE\t\t\tBIT(3)\n#define MSM_UART_CR_TX_ENABLE\t\t\tBIT(2)\n#define MSM_UART_CR_RX_DISABLE\t\t\tBIT(1)\n#define MSM_UART_CR_RX_ENABLE\t\t\tBIT(0)\n#define MSM_UART_CR_CMD_RESET_RXBREAK_START\t((1 << 11) | (2 << 4))\n\n#define MSM_UART_IMR\t\t\t0x0014\n#define MSM_UART_IMR_TXLEV\t\tBIT(0)\n#define MSM_UART_IMR_RXSTALE\t\tBIT(3)\n#define MSM_UART_IMR_RXLEV\t\tBIT(4)\n#define MSM_UART_IMR_DELTA_CTS\t\tBIT(5)\n#define MSM_UART_IMR_CURRENT_CTS\tBIT(6)\n#define MSM_UART_IMR_RXBREAK_START\tBIT(10)\n\n#define MSM_UART_IPR_RXSTALE_LAST\t\t0x20\n#define MSM_UART_IPR_STALE_LSB\t\t\t0x1F\n#define MSM_UART_IPR_STALE_TIMEOUT_MSB\t\t0x3FF80\n#define MSM_UART_DM_IPR_STALE_TIMEOUT_MSB\t0xFFFFFF80\n\n#define MSM_UART_IPR\t\t\t0x0018\n#define MSM_UART_TFWR\t\t\t0x001C\n#define MSM_UART_RFWR\t\t\t0x0020\n#define MSM_UART_HCR\t\t\t0x0024\n\n#define MSM_UART_MREG\t\t\t0x0028\n#define MSM_UART_NREG\t\t\t0x002C\n#define MSM_UART_DREG\t\t\t0x0030\n#define MSM_UART_MNDREG\t\t\t0x0034\n#define MSM_UART_IRDA\t\t\t0x0038\n#define MSM_UART_MISR_MODE\t\t0x0040\n#define MSM_UART_MISR_RESET\t\t0x0044\n#define MSM_UART_MISR_EXPORT\t\t0x0048\n#define MSM_UART_MISR_VAL\t\t0x004C\n#define MSM_UART_TEST_CTRL\t\t0x0050\n\n#define MSM_UART_SR\t\t\t0x0008\n#define MSM_UART_SR_HUNT_CHAR\t\tBIT(7)\n#define MSM_UART_SR_RX_BREAK\t\tBIT(6)\n#define MSM_UART_SR_PAR_FRAME_ERR\tBIT(5)\n#define MSM_UART_SR_OVERRUN\t\tBIT(4)\n#define MSM_UART_SR_TX_EMPTY\t\tBIT(3)\n#define MSM_UART_SR_TX_READY\t\tBIT(2)\n#define MSM_UART_SR_RX_FULL\t\tBIT(1)\n#define MSM_UART_SR_RX_READY\t\tBIT(0)\n\n#define MSM_UART_RF\t\t\t0x000C\n#define UARTDM_RF\t\t\t0x0070\n#define MSM_UART_MISR\t\t\t0x0010\n#define MSM_UART_ISR\t\t\t0x0014\n#define MSM_UART_ISR_TX_READY\t\tBIT(7)\n\n#define UARTDM_RXFS\t\t\t0x50\n#define UARTDM_RXFS_BUF_SHIFT\t\t0x7\n#define UARTDM_RXFS_BUF_MASK\t\t0x7\n\n#define UARTDM_DMEN\t\t\t0x3C\n#define UARTDM_DMEN_RX_SC_ENABLE\tBIT(5)\n#define UARTDM_DMEN_TX_SC_ENABLE\tBIT(4)\n\n#define UARTDM_DMEN_TX_BAM_ENABLE\tBIT(2)\t \n#define UARTDM_DMEN_TX_DM_ENABLE\tBIT(0)\t \n\n#define UARTDM_DMEN_RX_BAM_ENABLE\tBIT(3)\t \n#define UARTDM_DMEN_RX_DM_ENABLE\tBIT(1)\t \n\n#define UARTDM_DMRX\t\t\t0x34\n#define UARTDM_NCF_TX\t\t\t0x40\n#define UARTDM_RX_TOTAL_SNAP\t\t0x38\n\n#define UARTDM_BURST_SIZE\t\t16    \n#define UARTDM_TX_AIGN(x)\t\t((x) & ~0x3)  \n#define UARTDM_TX_MAX\t\t\t256    \n#define UARTDM_RX_SIZE\t\t\t(UART_XMIT_SIZE / 4)\n\nenum {\n\tUARTDM_1P1 = 1,\n\tUARTDM_1P2,\n\tUARTDM_1P3,\n\tUARTDM_1P4,\n};\n\nstruct msm_dma {\n\tstruct dma_chan\t\t*chan;\n\tenum dma_data_direction dir;\n\tdma_addr_t\t\tphys;\n\tunsigned char\t\t*virt;\n\tdma_cookie_t\t\tcookie;\n\tu32\t\t\tenable_bit;\n\tunsigned int\t\tcount;\n\tstruct dma_async_tx_descriptor\t*desc;\n};\n\nstruct msm_port {\n\tstruct uart_port\tuart;\n\tchar\t\t\tname[16];\n\tstruct clk\t\t*clk;\n\tstruct clk\t\t*pclk;\n\tunsigned int\t\timr;\n\tint\t\t\tis_uartdm;\n\tunsigned int\t\told_snap_state;\n\tbool\t\t\tbreak_detected;\n\tstruct msm_dma\t\ttx_dma;\n\tstruct msm_dma\t\trx_dma;\n};\n\nstatic inline struct msm_port *to_msm_port(struct uart_port *up)\n{\n\treturn container_of(up, struct msm_port, uart);\n}\n\nstatic\nvoid msm_write(struct uart_port *port, unsigned int val, unsigned int off)\n{\n\twritel_relaxed(val, port->membase + off);\n}\n\nstatic\nunsigned int msm_read(struct uart_port *port, unsigned int off)\n{\n\treturn readl_relaxed(port->membase + off);\n}\n\n \nstatic void msm_serial_set_mnd_regs_tcxo(struct uart_port *port)\n{\n\tmsm_write(port, 0x06, MSM_UART_MREG);\n\tmsm_write(port, 0xF1, MSM_UART_NREG);\n\tmsm_write(port, 0x0F, MSM_UART_DREG);\n\tmsm_write(port, 0x1A, MSM_UART_MNDREG);\n\tport->uartclk = 1843200;\n}\n\n \nstatic void msm_serial_set_mnd_regs_tcxoby4(struct uart_port *port)\n{\n\tmsm_write(port, 0x18, MSM_UART_MREG);\n\tmsm_write(port, 0xF6, MSM_UART_NREG);\n\tmsm_write(port, 0x0F, MSM_UART_DREG);\n\tmsm_write(port, 0x0A, MSM_UART_MNDREG);\n\tport->uartclk = 1843200;\n}\n\nstatic void msm_serial_set_mnd_regs(struct uart_port *port)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\n\t \n\tif (msm_port->is_uartdm)\n\t\treturn;\n\n\tif (port->uartclk == 19200000)\n\t\tmsm_serial_set_mnd_regs_tcxo(port);\n\telse if (port->uartclk == 4800000)\n\t\tmsm_serial_set_mnd_regs_tcxoby4(port);\n}\n\nstatic void msm_handle_tx(struct uart_port *port);\nstatic void msm_start_rx_dma(struct msm_port *msm_port);\n\nstatic void msm_stop_dma(struct uart_port *port, struct msm_dma *dma)\n{\n\tstruct device *dev = port->dev;\n\tunsigned int mapped;\n\tu32 val;\n\n\tmapped = dma->count;\n\tdma->count = 0;\n\n\tdmaengine_terminate_all(dma->chan);\n\n\t \n\tval = msm_read(port, UARTDM_DMEN);\n\tval &= ~dma->enable_bit;\n\tmsm_write(port, val, UARTDM_DMEN);\n\n\tif (mapped)\n\t\tdma_unmap_single(dev, dma->phys, mapped, dma->dir);\n}\n\nstatic void msm_release_dma(struct msm_port *msm_port)\n{\n\tstruct msm_dma *dma;\n\n\tdma = &msm_port->tx_dma;\n\tif (dma->chan) {\n\t\tmsm_stop_dma(&msm_port->uart, dma);\n\t\tdma_release_channel(dma->chan);\n\t}\n\n\tmemset(dma, 0, sizeof(*dma));\n\n\tdma = &msm_port->rx_dma;\n\tif (dma->chan) {\n\t\tmsm_stop_dma(&msm_port->uart, dma);\n\t\tdma_release_channel(dma->chan);\n\t\tkfree(dma->virt);\n\t}\n\n\tmemset(dma, 0, sizeof(*dma));\n}\n\nstatic void msm_request_tx_dma(struct msm_port *msm_port, resource_size_t base)\n{\n\tstruct device *dev = msm_port->uart.dev;\n\tstruct dma_slave_config conf;\n\tstruct qcom_adm_peripheral_config periph_conf = {};\n\tstruct msm_dma *dma;\n\tu32 crci = 0;\n\tint ret;\n\n\tdma = &msm_port->tx_dma;\n\n\t \n\tdma->chan = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(dma->chan))\n\t\tgoto no_tx;\n\n\tof_property_read_u32(dev->of_node, \"qcom,tx-crci\", &crci);\n\n\tmemset(&conf, 0, sizeof(conf));\n\tconf.direction = DMA_MEM_TO_DEV;\n\tconf.device_fc = true;\n\tconf.dst_addr = base + UARTDM_TF;\n\tconf.dst_maxburst = UARTDM_BURST_SIZE;\n\tif (crci) {\n\t\tconf.peripheral_config = &periph_conf;\n\t\tconf.peripheral_size = sizeof(periph_conf);\n\t\tperiph_conf.crci = crci;\n\t}\n\n\tret = dmaengine_slave_config(dma->chan, &conf);\n\tif (ret)\n\t\tgoto rel_tx;\n\n\tdma->dir = DMA_TO_DEVICE;\n\n\tif (msm_port->is_uartdm < UARTDM_1P4)\n\t\tdma->enable_bit = UARTDM_DMEN_TX_DM_ENABLE;\n\telse\n\t\tdma->enable_bit = UARTDM_DMEN_TX_BAM_ENABLE;\n\n\treturn;\n\nrel_tx:\n\tdma_release_channel(dma->chan);\nno_tx:\n\tmemset(dma, 0, sizeof(*dma));\n}\n\nstatic void msm_request_rx_dma(struct msm_port *msm_port, resource_size_t base)\n{\n\tstruct device *dev = msm_port->uart.dev;\n\tstruct dma_slave_config conf;\n\tstruct qcom_adm_peripheral_config periph_conf = {};\n\tstruct msm_dma *dma;\n\tu32 crci = 0;\n\tint ret;\n\n\tdma = &msm_port->rx_dma;\n\n\t \n\tdma->chan = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(dma->chan))\n\t\tgoto no_rx;\n\n\tof_property_read_u32(dev->of_node, \"qcom,rx-crci\", &crci);\n\n\tdma->virt = kzalloc(UARTDM_RX_SIZE, GFP_KERNEL);\n\tif (!dma->virt)\n\t\tgoto rel_rx;\n\n\tmemset(&conf, 0, sizeof(conf));\n\tconf.direction = DMA_DEV_TO_MEM;\n\tconf.device_fc = true;\n\tconf.src_addr = base + UARTDM_RF;\n\tconf.src_maxburst = UARTDM_BURST_SIZE;\n\tif (crci) {\n\t\tconf.peripheral_config = &periph_conf;\n\t\tconf.peripheral_size = sizeof(periph_conf);\n\t\tperiph_conf.crci = crci;\n\t}\n\n\tret = dmaengine_slave_config(dma->chan, &conf);\n\tif (ret)\n\t\tgoto err;\n\n\tdma->dir = DMA_FROM_DEVICE;\n\n\tif (msm_port->is_uartdm < UARTDM_1P4)\n\t\tdma->enable_bit = UARTDM_DMEN_RX_DM_ENABLE;\n\telse\n\t\tdma->enable_bit = UARTDM_DMEN_RX_BAM_ENABLE;\n\n\treturn;\nerr:\n\tkfree(dma->virt);\nrel_rx:\n\tdma_release_channel(dma->chan);\nno_rx:\n\tmemset(dma, 0, sizeof(*dma));\n}\n\nstatic inline void msm_wait_for_xmitr(struct uart_port *port)\n{\n\tunsigned int timeout = 500000;\n\n\twhile (!(msm_read(port, MSM_UART_SR) & MSM_UART_SR_TX_EMPTY)) {\n\t\tif (msm_read(port, MSM_UART_ISR) & MSM_UART_ISR_TX_READY)\n\t\t\tbreak;\n\t\tudelay(1);\n\t\tif (!timeout--)\n\t\t\tbreak;\n\t}\n\tmsm_write(port, MSM_UART_CR_CMD_RESET_TX_READY, MSM_UART_CR);\n}\n\nstatic void msm_stop_tx(struct uart_port *port)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\n\tmsm_port->imr &= ~MSM_UART_IMR_TXLEV;\n\tmsm_write(port, msm_port->imr, MSM_UART_IMR);\n}\n\nstatic void msm_start_tx(struct uart_port *port)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\tstruct msm_dma *dma = &msm_port->tx_dma;\n\n\t \n\tif (dma->count)\n\t\treturn;\n\n\tmsm_port->imr |= MSM_UART_IMR_TXLEV;\n\tmsm_write(port, msm_port->imr, MSM_UART_IMR);\n}\n\nstatic void msm_reset_dm_count(struct uart_port *port, int count)\n{\n\tmsm_wait_for_xmitr(port);\n\tmsm_write(port, count, UARTDM_NCF_TX);\n\tmsm_read(port, UARTDM_NCF_TX);\n}\n\nstatic void msm_complete_tx_dma(void *args)\n{\n\tstruct msm_port *msm_port = args;\n\tstruct uart_port *port = &msm_port->uart;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tstruct msm_dma *dma = &msm_port->tx_dma;\n\tstruct dma_tx_state state;\n\tunsigned long flags;\n\tunsigned int count;\n\tu32 val;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tif (!dma->count)\n\t\tgoto done;\n\n\tdmaengine_tx_status(dma->chan, dma->cookie, &state);\n\n\tdma_unmap_single(port->dev, dma->phys, dma->count, dma->dir);\n\n\tval = msm_read(port, UARTDM_DMEN);\n\tval &= ~dma->enable_bit;\n\tmsm_write(port, val, UARTDM_DMEN);\n\n\tif (msm_port->is_uartdm > UARTDM_1P3) {\n\t\tmsm_write(port, MSM_UART_CR_CMD_RESET_TX, MSM_UART_CR);\n\t\tmsm_write(port, MSM_UART_CR_TX_ENABLE, MSM_UART_CR);\n\t}\n\n\tcount = dma->count - state.residue;\n\tuart_xmit_advance(port, count);\n\tdma->count = 0;\n\n\t \n\tmsm_port->imr |= MSM_UART_IMR_TXLEV;\n\tmsm_write(port, msm_port->imr, MSM_UART_IMR);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tmsm_handle_tx(port);\ndone:\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int msm_handle_tx_dma(struct msm_port *msm_port, unsigned int count)\n{\n\tstruct circ_buf *xmit = &msm_port->uart.state->xmit;\n\tstruct uart_port *port = &msm_port->uart;\n\tstruct msm_dma *dma = &msm_port->tx_dma;\n\tvoid *cpu_addr;\n\tint ret;\n\tu32 val;\n\n\tcpu_addr = &xmit->buf[xmit->tail];\n\n\tdma->phys = dma_map_single(port->dev, cpu_addr, count, dma->dir);\n\tret = dma_mapping_error(port->dev, dma->phys);\n\tif (ret)\n\t\treturn ret;\n\n\tdma->desc = dmaengine_prep_slave_single(dma->chan, dma->phys,\n\t\t\t\t\t\tcount, DMA_MEM_TO_DEV,\n\t\t\t\t\t\tDMA_PREP_INTERRUPT |\n\t\t\t\t\t\tDMA_PREP_FENCE);\n\tif (!dma->desc) {\n\t\tret = -EIO;\n\t\tgoto unmap;\n\t}\n\n\tdma->desc->callback = msm_complete_tx_dma;\n\tdma->desc->callback_param = msm_port;\n\n\tdma->cookie = dmaengine_submit(dma->desc);\n\tret = dma_submit_error(dma->cookie);\n\tif (ret)\n\t\tgoto unmap;\n\n\t \n\tmsm_port->imr &= ~MSM_UART_IMR_TXLEV;\n\tmsm_write(port, msm_port->imr, MSM_UART_IMR);\n\n\tdma->count = count;\n\n\tval = msm_read(port, UARTDM_DMEN);\n\tval |= dma->enable_bit;\n\n\tif (msm_port->is_uartdm < UARTDM_1P4)\n\t\tmsm_write(port, val, UARTDM_DMEN);\n\n\tmsm_reset_dm_count(port, count);\n\n\tif (msm_port->is_uartdm > UARTDM_1P3)\n\t\tmsm_write(port, val, UARTDM_DMEN);\n\n\tdma_async_issue_pending(dma->chan);\n\treturn 0;\nunmap:\n\tdma_unmap_single(port->dev, dma->phys, count, dma->dir);\n\treturn ret;\n}\n\nstatic void msm_complete_rx_dma(void *args)\n{\n\tstruct msm_port *msm_port = args;\n\tstruct uart_port *port = &msm_port->uart;\n\tstruct tty_port *tport = &port->state->port;\n\tstruct msm_dma *dma = &msm_port->rx_dma;\n\tint count = 0, i, sysrq;\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tif (!dma->count)\n\t\tgoto done;\n\n\tval = msm_read(port, UARTDM_DMEN);\n\tval &= ~dma->enable_bit;\n\tmsm_write(port, val, UARTDM_DMEN);\n\n\tif (msm_read(port, MSM_UART_SR) & MSM_UART_SR_OVERRUN) {\n\t\tport->icount.overrun++;\n\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\t\tmsm_write(port, MSM_UART_CR_CMD_RESET_ERR, MSM_UART_CR);\n\t}\n\n\tcount = msm_read(port, UARTDM_RX_TOTAL_SNAP);\n\n\tport->icount.rx += count;\n\n\tdma->count = 0;\n\n\tdma_unmap_single(port->dev, dma->phys, UARTDM_RX_SIZE, dma->dir);\n\n\tfor (i = 0; i < count; i++) {\n\t\tchar flag = TTY_NORMAL;\n\n\t\tif (msm_port->break_detected && dma->virt[i] == 0) {\n\t\t\tport->icount.brk++;\n\t\t\tflag = TTY_BREAK;\n\t\t\tmsm_port->break_detected = false;\n\t\t\tif (uart_handle_break(port))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(port->read_status_mask & MSM_UART_SR_RX_BREAK))\n\t\t\tflag = TTY_NORMAL;\n\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tsysrq = uart_handle_sysrq_char(port, dma->virt[i]);\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tif (!sysrq)\n\t\t\ttty_insert_flip_char(tport, dma->virt[i], flag);\n\t}\n\n\tmsm_start_rx_dma(msm_port);\ndone:\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (count)\n\t\ttty_flip_buffer_push(tport);\n}\n\nstatic void msm_start_rx_dma(struct msm_port *msm_port)\n{\n\tstruct msm_dma *dma = &msm_port->rx_dma;\n\tstruct uart_port *uart = &msm_port->uart;\n\tu32 val;\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_CONSOLE_POLL))\n\t\treturn;\n\n\tif (!dma->chan)\n\t\treturn;\n\n\tdma->phys = dma_map_single(uart->dev, dma->virt,\n\t\t\t\t   UARTDM_RX_SIZE, dma->dir);\n\tret = dma_mapping_error(uart->dev, dma->phys);\n\tif (ret)\n\t\tgoto sw_mode;\n\n\tdma->desc = dmaengine_prep_slave_single(dma->chan, dma->phys,\n\t\t\t\t\t\tUARTDM_RX_SIZE, DMA_DEV_TO_MEM,\n\t\t\t\t\t\tDMA_PREP_INTERRUPT);\n\tif (!dma->desc)\n\t\tgoto unmap;\n\n\tdma->desc->callback = msm_complete_rx_dma;\n\tdma->desc->callback_param = msm_port;\n\n\tdma->cookie = dmaengine_submit(dma->desc);\n\tret = dma_submit_error(dma->cookie);\n\tif (ret)\n\t\tgoto unmap;\n\t \n\tmsm_port->imr &= ~(MSM_UART_IMR_RXLEV | MSM_UART_IMR_RXSTALE);\n\n\t \n\tif (msm_port->is_uartdm < UARTDM_1P4)\n\t\tmsm_port->imr |= MSM_UART_IMR_RXSTALE;\n\n\tmsm_write(uart, msm_port->imr, MSM_UART_IMR);\n\n\tdma->count = UARTDM_RX_SIZE;\n\n\tdma_async_issue_pending(dma->chan);\n\n\tmsm_write(uart, MSM_UART_CR_CMD_RESET_STALE_INT, MSM_UART_CR);\n\tmsm_write(uart, MSM_UART_CR_CMD_STALE_EVENT_ENABLE, MSM_UART_CR);\n\n\tval = msm_read(uart, UARTDM_DMEN);\n\tval |= dma->enable_bit;\n\n\tif (msm_port->is_uartdm < UARTDM_1P4)\n\t\tmsm_write(uart, val, UARTDM_DMEN);\n\n\tmsm_write(uart, UARTDM_RX_SIZE, UARTDM_DMRX);\n\n\tif (msm_port->is_uartdm > UARTDM_1P3)\n\t\tmsm_write(uart, val, UARTDM_DMEN);\n\n\treturn;\nunmap:\n\tdma_unmap_single(uart->dev, dma->phys, UARTDM_RX_SIZE, dma->dir);\n\nsw_mode:\n\t \n\tmsm_write(uart, MSM_UART_CR_CMD_RESET_RX, MSM_UART_CR);\n\tmsm_write(uart, MSM_UART_CR_RX_ENABLE, MSM_UART_CR);\n\n\tmsm_write(uart, MSM_UART_CR_CMD_RESET_STALE_INT, MSM_UART_CR);\n\tmsm_write(uart, 0xFFFFFF, UARTDM_DMRX);\n\tmsm_write(uart, MSM_UART_CR_CMD_STALE_EVENT_ENABLE, MSM_UART_CR);\n\n\t \n\tmsm_port->imr |= MSM_UART_IMR_RXLEV | MSM_UART_IMR_RXSTALE;\n\tmsm_write(uart, msm_port->imr, MSM_UART_IMR);\n}\n\nstatic void msm_stop_rx(struct uart_port *port)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\tstruct msm_dma *dma = &msm_port->rx_dma;\n\n\tmsm_port->imr &= ~(MSM_UART_IMR_RXLEV | MSM_UART_IMR_RXSTALE);\n\tmsm_write(port, msm_port->imr, MSM_UART_IMR);\n\n\tif (dma->chan)\n\t\tmsm_stop_dma(port, dma);\n}\n\nstatic void msm_enable_ms(struct uart_port *port)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\n\tmsm_port->imr |= MSM_UART_IMR_DELTA_CTS;\n\tmsm_write(port, msm_port->imr, MSM_UART_IMR);\n}\n\nstatic void msm_handle_rx_dm(struct uart_port *port, unsigned int misr)\n\t__must_hold(&port->lock)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned int sr;\n\tint count = 0;\n\tstruct msm_port *msm_port = to_msm_port(port);\n\n\tif ((msm_read(port, MSM_UART_SR) & MSM_UART_SR_OVERRUN)) {\n\t\tport->icount.overrun++;\n\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\t\tmsm_write(port, MSM_UART_CR_CMD_RESET_ERR, MSM_UART_CR);\n\t}\n\n\tif (misr & MSM_UART_IMR_RXSTALE) {\n\t\tcount = msm_read(port, UARTDM_RX_TOTAL_SNAP) -\n\t\t\tmsm_port->old_snap_state;\n\t\tmsm_port->old_snap_state = 0;\n\t} else {\n\t\tcount = 4 * (msm_read(port, MSM_UART_RFWR));\n\t\tmsm_port->old_snap_state += count;\n\t}\n\n\t \n\n\tport->icount.rx += count;\n\n\twhile (count > 0) {\n\t\tunsigned char buf[4];\n\t\tint sysrq, r_count, i;\n\n\t\tsr = msm_read(port, MSM_UART_SR);\n\t\tif ((sr & MSM_UART_SR_RX_READY) == 0) {\n\t\t\tmsm_port->old_snap_state -= count;\n\t\t\tbreak;\n\t\t}\n\n\t\tioread32_rep(port->membase + UARTDM_RF, buf, 1);\n\t\tr_count = min_t(int, count, sizeof(buf));\n\n\t\tfor (i = 0; i < r_count; i++) {\n\t\t\tchar flag = TTY_NORMAL;\n\n\t\t\tif (msm_port->break_detected && buf[i] == 0) {\n\t\t\t\tport->icount.brk++;\n\t\t\t\tflag = TTY_BREAK;\n\t\t\t\tmsm_port->break_detected = false;\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(port->read_status_mask & MSM_UART_SR_RX_BREAK))\n\t\t\t\tflag = TTY_NORMAL;\n\n\t\t\tspin_unlock(&port->lock);\n\t\t\tsysrq = uart_handle_sysrq_char(port, buf[i]);\n\t\t\tspin_lock(&port->lock);\n\t\t\tif (!sysrq)\n\t\t\t\ttty_insert_flip_char(tport, buf[i], flag);\n\t\t}\n\t\tcount -= r_count;\n\t}\n\n\ttty_flip_buffer_push(tport);\n\n\tif (misr & (MSM_UART_IMR_RXSTALE))\n\t\tmsm_write(port, MSM_UART_CR_CMD_RESET_STALE_INT, MSM_UART_CR);\n\tmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\n\tmsm_write(port, MSM_UART_CR_CMD_STALE_EVENT_ENABLE, MSM_UART_CR);\n\n\t \n\tmsm_start_rx_dma(msm_port);\n}\n\nstatic void msm_handle_rx(struct uart_port *port)\n\t__must_hold(&port->lock)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned int sr;\n\n\t \n\tif ((msm_read(port, MSM_UART_SR) & MSM_UART_SR_OVERRUN)) {\n\t\tport->icount.overrun++;\n\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\t\tmsm_write(port, MSM_UART_CR_CMD_RESET_ERR, MSM_UART_CR);\n\t}\n\n\t \n\twhile ((sr = msm_read(port, MSM_UART_SR)) & MSM_UART_SR_RX_READY) {\n\t\tunsigned int c;\n\t\tchar flag = TTY_NORMAL;\n\t\tint sysrq;\n\n\t\tc = msm_read(port, MSM_UART_RF);\n\n\t\tif (sr & MSM_UART_SR_RX_BREAK) {\n\t\t\tport->icount.brk++;\n\t\t\tif (uart_handle_break(port))\n\t\t\t\tcontinue;\n\t\t} else if (sr & MSM_UART_SR_PAR_FRAME_ERR) {\n\t\t\tport->icount.frame++;\n\t\t} else {\n\t\t\tport->icount.rx++;\n\t\t}\n\n\t\t \n\t\tsr &= port->read_status_mask;\n\n\t\tif (sr & MSM_UART_SR_RX_BREAK)\n\t\t\tflag = TTY_BREAK;\n\t\telse if (sr & MSM_UART_SR_PAR_FRAME_ERR)\n\t\t\tflag = TTY_FRAME;\n\n\t\tspin_unlock(&port->lock);\n\t\tsysrq = uart_handle_sysrq_char(port, c);\n\t\tspin_lock(&port->lock);\n\t\tif (!sysrq)\n\t\t\ttty_insert_flip_char(tport, c, flag);\n\t}\n\n\ttty_flip_buffer_push(tport);\n}\n\nstatic void msm_handle_tx_pio(struct uart_port *port, unsigned int tx_count)\n{\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tstruct msm_port *msm_port = to_msm_port(port);\n\tunsigned int num_chars;\n\tunsigned int tf_pointer = 0;\n\tvoid __iomem *tf;\n\n\tif (msm_port->is_uartdm)\n\t\ttf = port->membase + UARTDM_TF;\n\telse\n\t\ttf = port->membase + MSM_UART_TF;\n\n\tif (tx_count && msm_port->is_uartdm)\n\t\tmsm_reset_dm_count(port, tx_count);\n\n\twhile (tf_pointer < tx_count) {\n\t\tint i;\n\t\tchar buf[4] = { 0 };\n\n\t\tif (!(msm_read(port, MSM_UART_SR) & MSM_UART_SR_TX_READY))\n\t\t\tbreak;\n\n\t\tif (msm_port->is_uartdm)\n\t\t\tnum_chars = min(tx_count - tf_pointer,\n\t\t\t\t\t(unsigned int)sizeof(buf));\n\t\telse\n\t\t\tnum_chars = 1;\n\n\t\tfor (i = 0; i < num_chars; i++)\n\t\t\tbuf[i] = xmit->buf[xmit->tail + i];\n\n\t\tiowrite32_rep(tf, buf, 1);\n\t\tuart_xmit_advance(port, num_chars);\n\t\ttf_pointer += num_chars;\n\t}\n\n\t \n\tif (uart_circ_empty(xmit))\n\t\tmsm_stop_tx(port);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n}\n\nstatic void msm_handle_tx(struct uart_port *port)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\tstruct circ_buf *xmit = &msm_port->uart.state->xmit;\n\tstruct msm_dma *dma = &msm_port->tx_dma;\n\tunsigned int pio_count, dma_count, dma_min;\n\tchar buf[4] = { 0 };\n\tvoid __iomem *tf;\n\tint err = 0;\n\n\tif (port->x_char) {\n\t\tif (msm_port->is_uartdm)\n\t\t\ttf = port->membase + UARTDM_TF;\n\t\telse\n\t\t\ttf = port->membase + MSM_UART_TF;\n\n\t\tbuf[0] = port->x_char;\n\n\t\tif (msm_port->is_uartdm)\n\t\t\tmsm_reset_dm_count(port, 1);\n\n\t\tiowrite32_rep(tf, buf, 1);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\tmsm_stop_tx(port);\n\t\treturn;\n\t}\n\n\tpio_count = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\tdma_count = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\n\tdma_min = 1;\t \n\tif (msm_port->is_uartdm > UARTDM_1P3) {\n\t\tdma_count = UARTDM_TX_AIGN(dma_count);\n\t\tdma_min = UARTDM_BURST_SIZE;\n\t} else {\n\t\tif (dma_count > UARTDM_TX_MAX)\n\t\t\tdma_count = UARTDM_TX_MAX;\n\t}\n\n\tif (pio_count > port->fifosize)\n\t\tpio_count = port->fifosize;\n\n\tif (!dma->chan || dma_count < dma_min)\n\t\tmsm_handle_tx_pio(port, pio_count);\n\telse\n\t\terr = msm_handle_tx_dma(msm_port, dma_count);\n\n\tif (err)\t \n\t\tmsm_handle_tx_pio(port, pio_count);\n}\n\nstatic void msm_handle_delta_cts(struct uart_port *port)\n{\n\tmsm_write(port, MSM_UART_CR_CMD_RESET_CTS, MSM_UART_CR);\n\tport->icount.cts++;\n\twake_up_interruptible(&port->state->port.delta_msr_wait);\n}\n\nstatic irqreturn_t msm_uart_irq(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tstruct msm_port *msm_port = to_msm_port(port);\n\tstruct msm_dma *dma = &msm_port->rx_dma;\n\tunsigned long flags;\n\tunsigned int misr;\n\tu32 val;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tmisr = msm_read(port, MSM_UART_MISR);\n\tmsm_write(port, 0, MSM_UART_IMR);  \n\n\tif (misr & MSM_UART_IMR_RXBREAK_START) {\n\t\tmsm_port->break_detected = true;\n\t\tmsm_write(port, MSM_UART_CR_CMD_RESET_RXBREAK_START, MSM_UART_CR);\n\t}\n\n\tif (misr & (MSM_UART_IMR_RXLEV | MSM_UART_IMR_RXSTALE)) {\n\t\tif (dma->count) {\n\t\t\tval = MSM_UART_CR_CMD_STALE_EVENT_DISABLE;\n\t\t\tmsm_write(port, val, MSM_UART_CR);\n\t\t\tval = MSM_UART_CR_CMD_RESET_STALE_INT;\n\t\t\tmsm_write(port, val, MSM_UART_CR);\n\t\t\t \n\t\t\tdmaengine_terminate_all(dma->chan);\n\t\t} else if (msm_port->is_uartdm) {\n\t\t\tmsm_handle_rx_dm(port, misr);\n\t\t} else {\n\t\t\tmsm_handle_rx(port);\n\t\t}\n\t}\n\tif (misr & MSM_UART_IMR_TXLEV)\n\t\tmsm_handle_tx(port);\n\tif (misr & MSM_UART_IMR_DELTA_CTS)\n\t\tmsm_handle_delta_cts(port);\n\n\tmsm_write(port, msm_port->imr, MSM_UART_IMR);  \n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int msm_tx_empty(struct uart_port *port)\n{\n\treturn (msm_read(port, MSM_UART_SR) & MSM_UART_SR_TX_EMPTY) ? TIOCSER_TEMT : 0;\n}\n\nstatic unsigned int msm_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CAR | TIOCM_CTS | TIOCM_DSR | TIOCM_RTS;\n}\n\nstatic void msm_reset(struct uart_port *port)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\tunsigned int mr;\n\n\t \n\tmsm_write(port, MSM_UART_CR_CMD_RESET_RX, MSM_UART_CR);\n\tmsm_write(port, MSM_UART_CR_CMD_RESET_TX, MSM_UART_CR);\n\tmsm_write(port, MSM_UART_CR_CMD_RESET_ERR, MSM_UART_CR);\n\tmsm_write(port, MSM_UART_CR_CMD_RESET_BREAK_INT, MSM_UART_CR);\n\tmsm_write(port, MSM_UART_CR_CMD_RESET_CTS, MSM_UART_CR);\n\tmsm_write(port, MSM_UART_CR_CMD_RESET_RFR, MSM_UART_CR);\n\tmr = msm_read(port, MSM_UART_MR1);\n\tmr &= ~MSM_UART_MR1_RX_RDY_CTL;\n\tmsm_write(port, mr, MSM_UART_MR1);\n\n\t \n\tif (msm_port->is_uartdm)\n\t\tmsm_write(port, 0, UARTDM_DMEN);\n}\n\nstatic void msm_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tunsigned int mr;\n\n\tmr = msm_read(port, MSM_UART_MR1);\n\n\tif (!(mctrl & TIOCM_RTS)) {\n\t\tmr &= ~MSM_UART_MR1_RX_RDY_CTL;\n\t\tmsm_write(port, mr, MSM_UART_MR1);\n\t\tmsm_write(port, MSM_UART_CR_CMD_RESET_RFR, MSM_UART_CR);\n\t} else {\n\t\tmr |= MSM_UART_MR1_RX_RDY_CTL;\n\t\tmsm_write(port, mr, MSM_UART_MR1);\n\t}\n}\n\nstatic void msm_break_ctl(struct uart_port *port, int break_ctl)\n{\n\tif (break_ctl)\n\t\tmsm_write(port, MSM_UART_CR_CMD_START_BREAK, MSM_UART_CR);\n\telse\n\t\tmsm_write(port, MSM_UART_CR_CMD_STOP_BREAK, MSM_UART_CR);\n}\n\nstruct msm_baud_map {\n\tu16\tdivisor;\n\tu8\tcode;\n\tu8\trxstale;\n};\n\nstatic const struct msm_baud_map *\nmsm_find_best_baud(struct uart_port *port, unsigned int baud,\n\t\t   unsigned long *rate)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\tunsigned int divisor, result;\n\tunsigned long target, old, best_rate = 0, diff, best_diff = ULONG_MAX;\n\tconst struct msm_baud_map *entry, *end, *best;\n\tstatic const struct msm_baud_map table[] = {\n\t\t{    1, 0xff, 31 },\n\t\t{    2, 0xee, 16 },\n\t\t{    3, 0xdd,  8 },\n\t\t{    4, 0xcc,  6 },\n\t\t{    6, 0xbb,  6 },\n\t\t{    8, 0xaa,  6 },\n\t\t{   12, 0x99,  6 },\n\t\t{   16, 0x88,  1 },\n\t\t{   24, 0x77,  1 },\n\t\t{   32, 0x66,  1 },\n\t\t{   48, 0x55,  1 },\n\t\t{   96, 0x44,  1 },\n\t\t{  192, 0x33,  1 },\n\t\t{  384, 0x22,  1 },\n\t\t{  768, 0x11,  1 },\n\t\t{ 1536, 0x00,  1 },\n\t};\n\n\tbest = table;  \n\ttarget = clk_round_rate(msm_port->clk, 16 * baud);\n\tdivisor = DIV_ROUND_CLOSEST(target, 16 * baud);\n\n\tend = table + ARRAY_SIZE(table);\n\tentry = table;\n\twhile (entry < end) {\n\t\tif (entry->divisor <= divisor) {\n\t\t\tresult = target / entry->divisor / 16;\n\t\t\tdiff = abs(result - baud);\n\n\t\t\t \n\t\t\tif (diff < best_diff) {\n\t\t\t\tbest_diff = diff;\n\t\t\t\tbest = entry;\n\t\t\t\tbest_rate = target;\n\t\t\t}\n\n\t\t\tif (result == baud)\n\t\t\t\tbreak;\n\t\t} else if (entry->divisor > divisor) {\n\t\t\told = target;\n\t\t\ttarget = clk_round_rate(msm_port->clk, old + 1);\n\t\t\t \n\t\t\tif (target == old)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tentry = table;\n\t\t\tdivisor = DIV_ROUND_CLOSEST(target, 16 * baud);\n\t\t\tcontinue;\n\t\t}\n\t\tentry++;\n\t}\n\n\t*rate = best_rate;\n\treturn best;\n}\n\nstatic int msm_set_baud_rate(struct uart_port *port, unsigned int baud,\n\t\t\t     unsigned long *saved_flags)\n\t__must_hold(&port->lock)\n{\n\tunsigned int rxstale, watermark, mask;\n\tstruct msm_port *msm_port = to_msm_port(port);\n\tconst struct msm_baud_map *entry;\n\tunsigned long flags, rate;\n\n\tflags = *saved_flags;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tentry = msm_find_best_baud(port, baud, &rate);\n\tclk_set_rate(msm_port->clk, rate);\n\tbaud = rate / 16 / entry->divisor;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\t*saved_flags = flags;\n\tport->uartclk = rate;\n\n\tmsm_write(port, entry->code, MSM_UART_CSR);\n\n\t \n\trxstale = entry->rxstale;\n\twatermark = MSM_UART_IPR_STALE_LSB & rxstale;\n\tif (msm_port->is_uartdm) {\n\t\tmask = MSM_UART_DM_IPR_STALE_TIMEOUT_MSB;\n\t} else {\n\t\twatermark |= MSM_UART_IPR_RXSTALE_LAST;\n\t\tmask = MSM_UART_IPR_STALE_TIMEOUT_MSB;\n\t}\n\n\twatermark |= mask & (rxstale << 2);\n\n\tmsm_write(port, watermark, MSM_UART_IPR);\n\n\t \n\twatermark = (port->fifosize * 3) / 4;\n\tmsm_write(port, watermark, MSM_UART_RFWR);\n\n\t \n\tmsm_write(port, 10, MSM_UART_TFWR);\n\n\tmsm_write(port, MSM_UART_CR_CMD_PROTECTION_EN, MSM_UART_CR);\n\tmsm_reset(port);\n\n\t \n\tmsm_write(port, MSM_UART_CR_TX_ENABLE | MSM_UART_CR_RX_ENABLE, MSM_UART_CR);\n\n\t \n\tmsm_port->imr = MSM_UART_IMR_RXLEV | MSM_UART_IMR_RXSTALE |\n\t\t\tMSM_UART_IMR_CURRENT_CTS | MSM_UART_IMR_RXBREAK_START;\n\n\tmsm_write(port, msm_port->imr, MSM_UART_IMR);\n\n\tif (msm_port->is_uartdm) {\n\t\tmsm_write(port, MSM_UART_CR_CMD_RESET_STALE_INT, MSM_UART_CR);\n\t\tmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\n\t\tmsm_write(port, MSM_UART_CR_CMD_STALE_EVENT_ENABLE, MSM_UART_CR);\n\t}\n\n\treturn baud;\n}\n\nstatic void msm_init_clock(struct uart_port *port)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\n\tclk_prepare_enable(msm_port->clk);\n\tclk_prepare_enable(msm_port->pclk);\n\tmsm_serial_set_mnd_regs(port);\n}\n\nstatic int msm_startup(struct uart_port *port)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\tunsigned int data, rfr_level, mask;\n\tint ret;\n\n\tsnprintf(msm_port->name, sizeof(msm_port->name),\n\t\t \"msm_serial%d\", port->line);\n\n\tmsm_init_clock(port);\n\n\tif (likely(port->fifosize > 12))\n\t\trfr_level = port->fifosize - 12;\n\telse\n\t\trfr_level = port->fifosize;\n\n\t \n\tdata = msm_read(port, MSM_UART_MR1);\n\n\tif (msm_port->is_uartdm)\n\t\tmask = MSM_UART_DM_MR1_AUTO_RFR_LEVEL1;\n\telse\n\t\tmask = MSM_UART_MR1_AUTO_RFR_LEVEL1;\n\n\tdata &= ~mask;\n\tdata &= ~MSM_UART_MR1_AUTO_RFR_LEVEL0;\n\tdata |= mask & (rfr_level << 2);\n\tdata |= MSM_UART_MR1_AUTO_RFR_LEVEL0 & rfr_level;\n\tmsm_write(port, data, MSM_UART_MR1);\n\n\tif (msm_port->is_uartdm) {\n\t\tmsm_request_tx_dma(msm_port, msm_port->uart.mapbase);\n\t\tmsm_request_rx_dma(msm_port, msm_port->uart.mapbase);\n\t}\n\n\tret = request_irq(port->irq, msm_uart_irq, IRQF_TRIGGER_HIGH,\n\t\t\t  msm_port->name, port);\n\tif (unlikely(ret))\n\t\tgoto err_irq;\n\n\treturn 0;\n\nerr_irq:\n\tif (msm_port->is_uartdm)\n\t\tmsm_release_dma(msm_port);\n\n\tclk_disable_unprepare(msm_port->pclk);\n\tclk_disable_unprepare(msm_port->clk);\n\n\treturn ret;\n}\n\nstatic void msm_shutdown(struct uart_port *port)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\n\tmsm_port->imr = 0;\n\tmsm_write(port, 0, MSM_UART_IMR);  \n\n\tif (msm_port->is_uartdm)\n\t\tmsm_release_dma(msm_port);\n\n\tclk_disable_unprepare(msm_port->clk);\n\n\tfree_irq(port->irq, port);\n}\n\nstatic void msm_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t\t    const struct ktermios *old)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\tstruct msm_dma *dma = &msm_port->rx_dma;\n\tunsigned long flags;\n\tunsigned int baud, mr;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (dma->chan)  \n\t\tmsm_stop_dma(port, dma);\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 300, 4000000);\n\tbaud = msm_set_baud_rate(port, baud, &flags);\n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\n\t \n\tmr = msm_read(port, MSM_UART_MR2);\n\tmr &= ~MSM_UART_MR2_PARITY_MODE;\n\tif (termios->c_cflag & PARENB) {\n\t\tif (termios->c_cflag & PARODD)\n\t\t\tmr |= MSM_UART_MR2_PARITY_MODE_ODD;\n\t\telse if (termios->c_cflag & CMSPAR)\n\t\t\tmr |= MSM_UART_MR2_PARITY_MODE_SPACE;\n\t\telse\n\t\t\tmr |= MSM_UART_MR2_PARITY_MODE_EVEN;\n\t}\n\n\t \n\tmr &= ~MSM_UART_MR2_BITS_PER_CHAR;\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tmr |= MSM_UART_MR2_BITS_PER_CHAR_5;\n\t\tbreak;\n\tcase CS6:\n\t\tmr |= MSM_UART_MR2_BITS_PER_CHAR_6;\n\t\tbreak;\n\tcase CS7:\n\t\tmr |= MSM_UART_MR2_BITS_PER_CHAR_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tmr |= MSM_UART_MR2_BITS_PER_CHAR_8;\n\t\tbreak;\n\t}\n\n\t \n\tmr &= ~(MSM_UART_MR2_STOP_BIT_LEN_ONE | MSM_UART_MR2_STOP_BIT_LEN_TWO);\n\tif (termios->c_cflag & CSTOPB)\n\t\tmr |= MSM_UART_MR2_STOP_BIT_LEN_TWO;\n\telse\n\t\tmr |= MSM_UART_MR2_STOP_BIT_LEN_ONE;\n\n\t \n\tmsm_write(port, mr, MSM_UART_MR2);\n\n\t \n\tmr = msm_read(port, MSM_UART_MR1);\n\tmr &= ~(MSM_UART_MR1_CTS_CTL | MSM_UART_MR1_RX_RDY_CTL);\n\tif (termios->c_cflag & CRTSCTS) {\n\t\tmr |= MSM_UART_MR1_CTS_CTL;\n\t\tmr |= MSM_UART_MR1_RX_RDY_CTL;\n\t}\n\tmsm_write(port, mr, MSM_UART_MR1);\n\n\t \n\tport->read_status_mask = 0;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= MSM_UART_SR_PAR_FRAME_ERR;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tport->read_status_mask |= MSM_UART_SR_RX_BREAK;\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tmsm_start_rx_dma(msm_port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *msm_type(struct uart_port *port)\n{\n\treturn \"MSM\";\n}\n\nstatic void msm_release_port(struct uart_port *port)\n{\n\tstruct platform_device *pdev = to_platform_device(port->dev);\n\tstruct resource *uart_resource;\n\tresource_size_t size;\n\n\tuart_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (unlikely(!uart_resource))\n\t\treturn;\n\tsize = resource_size(uart_resource);\n\n\trelease_mem_region(port->mapbase, size);\n\tiounmap(port->membase);\n\tport->membase = NULL;\n}\n\nstatic int msm_request_port(struct uart_port *port)\n{\n\tstruct platform_device *pdev = to_platform_device(port->dev);\n\tstruct resource *uart_resource;\n\tresource_size_t size;\n\tint ret;\n\n\tuart_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (unlikely(!uart_resource))\n\t\treturn -ENXIO;\n\n\tsize = resource_size(uart_resource);\n\n\tif (!request_mem_region(port->mapbase, size, \"msm_serial\"))\n\t\treturn -EBUSY;\n\n\tport->membase = ioremap(port->mapbase, size);\n\tif (!port->membase) {\n\t\tret = -EBUSY;\n\t\tgoto fail_release_port;\n\t}\n\n\treturn 0;\n\nfail_release_port:\n\trelease_mem_region(port->mapbase, size);\n\treturn ret;\n}\n\nstatic void msm_config_port(struct uart_port *port, int flags)\n{\n\tint ret;\n\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_MSM;\n\t\tret = msm_request_port(port);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n}\n\nstatic int msm_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tif (unlikely(ser->type != PORT_UNKNOWN && ser->type != PORT_MSM))\n\t\treturn -EINVAL;\n\tif (unlikely(port->irq != ser->irq))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void msm_power(struct uart_port *port, unsigned int state,\n\t\t      unsigned int oldstate)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\n\tswitch (state) {\n\tcase 0:\n\t\tclk_prepare_enable(msm_port->clk);\n\t\tclk_prepare_enable(msm_port->pclk);\n\t\tbreak;\n\tcase 3:\n\t\tclk_disable_unprepare(msm_port->clk);\n\t\tclk_disable_unprepare(msm_port->pclk);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"msm_serial: Unknown PM state %d\\n\", state);\n\t}\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int msm_poll_get_char_single(struct uart_port *port)\n{\n\tstruct msm_port *msm_port = to_msm_port(port);\n\tunsigned int rf_reg = msm_port->is_uartdm ? UARTDM_RF : MSM_UART_RF;\n\n\tif (!(msm_read(port, MSM_UART_SR) & MSM_UART_SR_RX_READY))\n\t\treturn NO_POLL_CHAR;\n\n\treturn msm_read(port, rf_reg) & 0xff;\n}\n\nstatic int msm_poll_get_char_dm(struct uart_port *port)\n{\n\tint c;\n\tstatic u32 slop;\n\tstatic int count;\n\tunsigned char *sp = (unsigned char *)&slop;\n\n\t \n\tif (count) {\n\t\tc = sp[sizeof(slop) - count];\n\t\tcount--;\n\t \n\t} else if (!(msm_read(port, MSM_UART_SR) & MSM_UART_SR_RX_READY)) {\n\t\t \n\t\tcount = msm_read(port, UARTDM_RXFS);\n\t\tcount = (count >> UARTDM_RXFS_BUF_SHIFT) & UARTDM_RXFS_BUF_MASK;\n\t\tif (count) {\n\t\t\tmsm_write(port, MSM_UART_CR_CMD_FORCE_STALE, MSM_UART_CR);\n\t\t\tslop = msm_read(port, UARTDM_RF);\n\t\t\tc = sp[0];\n\t\t\tcount--;\n\t\t\tmsm_write(port, MSM_UART_CR_CMD_RESET_STALE_INT, MSM_UART_CR);\n\t\t\tmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\n\t\t\tmsm_write(port, MSM_UART_CR_CMD_STALE_EVENT_ENABLE, MSM_UART_CR);\n\t\t} else {\n\t\t\tc = NO_POLL_CHAR;\n\t\t}\n\t \n\t} else {\n\t\tslop = msm_read(port, UARTDM_RF);\n\t\tc = sp[0];\n\t\tcount = sizeof(slop) - 1;\n\t}\n\n\treturn c;\n}\n\nstatic int msm_poll_get_char(struct uart_port *port)\n{\n\tu32 imr;\n\tint c;\n\tstruct msm_port *msm_port = to_msm_port(port);\n\n\t \n\timr = msm_read(port, MSM_UART_IMR);\n\tmsm_write(port, 0, MSM_UART_IMR);\n\n\tif (msm_port->is_uartdm)\n\t\tc = msm_poll_get_char_dm(port);\n\telse\n\t\tc = msm_poll_get_char_single(port);\n\n\t \n\tmsm_write(port, imr, MSM_UART_IMR);\n\n\treturn c;\n}\n\nstatic void msm_poll_put_char(struct uart_port *port, unsigned char c)\n{\n\tu32 imr;\n\tstruct msm_port *msm_port = to_msm_port(port);\n\n\t \n\timr = msm_read(port, MSM_UART_IMR);\n\tmsm_write(port, 0, MSM_UART_IMR);\n\n\tif (msm_port->is_uartdm)\n\t\tmsm_reset_dm_count(port, 1);\n\n\t \n\twhile (!(msm_read(port, MSM_UART_SR) & MSM_UART_SR_TX_READY))\n\t\tcpu_relax();\n\n\t \n\tmsm_write(port, c, msm_port->is_uartdm ? UARTDM_TF : MSM_UART_TF);\n\n\t \n\twhile (!(msm_read(port, MSM_UART_SR) & MSM_UART_SR_TX_READY))\n\t\tcpu_relax();\n\n\t \n\tmsm_write(port, imr, MSM_UART_IMR);\n}\n#endif\n\nstatic const struct uart_ops msm_uart_pops = {\n\t.tx_empty = msm_tx_empty,\n\t.set_mctrl = msm_set_mctrl,\n\t.get_mctrl = msm_get_mctrl,\n\t.stop_tx = msm_stop_tx,\n\t.start_tx = msm_start_tx,\n\t.stop_rx = msm_stop_rx,\n\t.enable_ms = msm_enable_ms,\n\t.break_ctl = msm_break_ctl,\n\t.startup = msm_startup,\n\t.shutdown = msm_shutdown,\n\t.set_termios = msm_set_termios,\n\t.type = msm_type,\n\t.release_port = msm_release_port,\n\t.request_port = msm_request_port,\n\t.config_port = msm_config_port,\n\t.verify_port = msm_verify_port,\n\t.pm = msm_power,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= msm_poll_get_char,\n\t.poll_put_char\t= msm_poll_put_char,\n#endif\n};\n\nstatic struct msm_port msm_uart_ports[] = {\n\t{\n\t\t.uart = {\n\t\t\t.iotype = UPIO_MEM,\n\t\t\t.ops = &msm_uart_pops,\n\t\t\t.flags = UPF_BOOT_AUTOCONF,\n\t\t\t.fifosize = 64,\n\t\t\t.line = 0,\n\t\t},\n\t},\n\t{\n\t\t.uart = {\n\t\t\t.iotype = UPIO_MEM,\n\t\t\t.ops = &msm_uart_pops,\n\t\t\t.flags = UPF_BOOT_AUTOCONF,\n\t\t\t.fifosize = 64,\n\t\t\t.line = 1,\n\t\t},\n\t},\n\t{\n\t\t.uart = {\n\t\t\t.iotype = UPIO_MEM,\n\t\t\t.ops = &msm_uart_pops,\n\t\t\t.flags = UPF_BOOT_AUTOCONF,\n\t\t\t.fifosize = 64,\n\t\t\t.line = 2,\n\t\t},\n\t},\n};\n\n#define MSM_UART_NR\tARRAY_SIZE(msm_uart_ports)\n\nstatic inline struct uart_port *msm_get_port_from_line(unsigned int line)\n{\n\treturn &msm_uart_ports[line].uart;\n}\n\n#ifdef CONFIG_SERIAL_MSM_CONSOLE\nstatic void __msm_console_write(struct uart_port *port, const char *s,\n\t\t\t\tunsigned int count, bool is_uartdm)\n{\n\tunsigned long flags;\n\tint i;\n\tint num_newlines = 0;\n\tbool replaced = false;\n\tvoid __iomem *tf;\n\tint locked = 1;\n\n\tif (is_uartdm)\n\t\ttf = port->membase + UARTDM_TF;\n\telse\n\t\ttf = port->membase + MSM_UART_TF;\n\n\t \n\tfor (i = 0; i < count; i++)\n\t\tif (s[i] == '\\n')\n\t\t\tnum_newlines++;\n\tcount += num_newlines;\n\n\tlocal_irq_save(flags);\n\n\tif (port->sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock(&port->lock);\n\telse\n\t\tspin_lock(&port->lock);\n\n\tif (is_uartdm)\n\t\tmsm_reset_dm_count(port, count);\n\n\ti = 0;\n\twhile (i < count) {\n\t\tint j;\n\t\tunsigned int num_chars;\n\t\tchar buf[4] = { 0 };\n\n\t\tif (is_uartdm)\n\t\t\tnum_chars = min(count - i, (unsigned int)sizeof(buf));\n\t\telse\n\t\t\tnum_chars = 1;\n\n\t\tfor (j = 0; j < num_chars; j++) {\n\t\t\tchar c = *s;\n\n\t\t\tif (c == '\\n' && !replaced) {\n\t\t\t\tbuf[j] = '\\r';\n\t\t\t\tj++;\n\t\t\t\treplaced = true;\n\t\t\t}\n\t\t\tif (j < num_chars) {\n\t\t\t\tbuf[j] = c;\n\t\t\t\ts++;\n\t\t\t\treplaced = false;\n\t\t\t}\n\t\t}\n\n\t\twhile (!(msm_read(port, MSM_UART_SR) & MSM_UART_SR_TX_READY))\n\t\t\tcpu_relax();\n\n\t\tiowrite32_rep(tf, buf, 1);\n\t\ti += num_chars;\n\t}\n\n\tif (locked)\n\t\tspin_unlock(&port->lock);\n\n\tlocal_irq_restore(flags);\n}\n\nstatic void msm_console_write(struct console *co, const char *s,\n\t\t\t      unsigned int count)\n{\n\tstruct uart_port *port;\n\tstruct msm_port *msm_port;\n\n\tBUG_ON(co->index < 0 || co->index >= MSM_UART_NR);\n\n\tport = msm_get_port_from_line(co->index);\n\tmsm_port = to_msm_port(port);\n\n\t__msm_console_write(port, s, count, msm_port->is_uartdm);\n}\n\nstatic int msm_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (unlikely(co->index >= MSM_UART_NR || co->index < 0))\n\t\treturn -ENXIO;\n\n\tport = msm_get_port_from_line(co->index);\n\n\tif (unlikely(!port->membase))\n\t\treturn -ENXIO;\n\n\tmsm_init_clock(port);\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\tpr_info(\"msm_serial: console setup on port #%d\\n\", port->line);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic void\nmsm_serial_early_write(struct console *con, const char *s, unsigned n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\t__msm_console_write(&dev->port, s, n, false);\n}\n\nstatic int __init\nmsm_serial_early_console_setup(struct earlycon_device *device, const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = msm_serial_early_write;\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(msm_serial, \"qcom,msm-uart\",\n\t\t    msm_serial_early_console_setup);\n\nstatic void\nmsm_serial_early_write_dm(struct console *con, const char *s, unsigned n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\t__msm_console_write(&dev->port, s, n, true);\n}\n\nstatic int __init\nmsm_serial_early_console_setup_dm(struct earlycon_device *device,\n\t\t\t\t  const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = msm_serial_early_write_dm;\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(msm_serial_dm, \"qcom,msm-uartdm\",\n\t\t    msm_serial_early_console_setup_dm);\n\nstatic struct uart_driver msm_uart_driver;\n\nstatic struct console msm_console = {\n\t.name = \"ttyMSM\",\n\t.write = msm_console_write,\n\t.device = uart_console_device,\n\t.setup = msm_console_setup,\n\t.flags = CON_PRINTBUFFER,\n\t.index = -1,\n\t.data = &msm_uart_driver,\n};\n\n#define MSM_CONSOLE\t(&msm_console)\n\n#else\n#define MSM_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver msm_uart_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = \"msm_serial\",\n\t.dev_name = \"ttyMSM\",\n\t.nr = MSM_UART_NR,\n\t.cons = MSM_CONSOLE,\n};\n\nstatic atomic_t msm_uart_next_id = ATOMIC_INIT(0);\n\nstatic const struct of_device_id msm_uartdm_table[] = {\n\t{ .compatible = \"qcom,msm-uartdm-v1.1\", .data = (void *)UARTDM_1P1 },\n\t{ .compatible = \"qcom,msm-uartdm-v1.2\", .data = (void *)UARTDM_1P2 },\n\t{ .compatible = \"qcom,msm-uartdm-v1.3\", .data = (void *)UARTDM_1P3 },\n\t{ .compatible = \"qcom,msm-uartdm-v1.4\", .data = (void *)UARTDM_1P4 },\n\t{ }\n};\n\nstatic int msm_serial_probe(struct platform_device *pdev)\n{\n\tstruct msm_port *msm_port;\n\tstruct resource *resource;\n\tstruct uart_port *port;\n\tconst struct of_device_id *id;\n\tint irq, line;\n\n\tif (pdev->dev.of_node)\n\t\tline = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\telse\n\t\tline = pdev->id;\n\n\tif (line < 0)\n\t\tline = atomic_inc_return(&msm_uart_next_id) - 1;\n\n\tif (unlikely(line < 0 || line >= MSM_UART_NR))\n\t\treturn -ENXIO;\n\n\tdev_info(&pdev->dev, \"msm_serial: detected port #%d\\n\", line);\n\n\tport = msm_get_port_from_line(line);\n\tport->dev = &pdev->dev;\n\tmsm_port = to_msm_port(port);\n\n\tid = of_match_device(msm_uartdm_table, &pdev->dev);\n\tif (id)\n\t\tmsm_port->is_uartdm = (unsigned long)id->data;\n\telse\n\t\tmsm_port->is_uartdm = 0;\n\n\tmsm_port->clk = devm_clk_get(&pdev->dev, \"core\");\n\tif (IS_ERR(msm_port->clk))\n\t\treturn PTR_ERR(msm_port->clk);\n\n\tif (msm_port->is_uartdm) {\n\t\tmsm_port->pclk = devm_clk_get(&pdev->dev, \"iface\");\n\t\tif (IS_ERR(msm_port->pclk))\n\t\t\treturn PTR_ERR(msm_port->pclk);\n\t}\n\n\tport->uartclk = clk_get_rate(msm_port->clk);\n\tdev_info(&pdev->dev, \"uartclk = %d\\n\", port->uartclk);\n\n\tresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (unlikely(!resource))\n\t\treturn -ENXIO;\n\tport->mapbase = resource->start;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (unlikely(irq < 0))\n\t\treturn -ENXIO;\n\tport->irq = irq;\n\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_MSM_CONSOLE);\n\n\tplatform_set_drvdata(pdev, port);\n\n\treturn uart_add_one_port(&msm_uart_driver, port);\n}\n\nstatic int msm_serial_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&msm_uart_driver, port);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id msm_match_table[] = {\n\t{ .compatible = \"qcom,msm-uart\" },\n\t{ .compatible = \"qcom,msm-uartdm\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, msm_match_table);\n\nstatic int __maybe_unused msm_serial_suspend(struct device *dev)\n{\n\tstruct msm_port *port = dev_get_drvdata(dev);\n\n\tuart_suspend_port(&msm_uart_driver, &port->uart);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused msm_serial_resume(struct device *dev)\n{\n\tstruct msm_port *port = dev_get_drvdata(dev);\n\n\tuart_resume_port(&msm_uart_driver, &port->uart);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops msm_serial_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(msm_serial_suspend, msm_serial_resume)\n};\n\nstatic struct platform_driver msm_platform_driver = {\n\t.remove = msm_serial_remove,\n\t.probe = msm_serial_probe,\n\t.driver = {\n\t\t.name = \"msm_serial\",\n\t\t.pm = &msm_serial_dev_pm_ops,\n\t\t.of_match_table = msm_match_table,\n\t},\n};\n\nstatic int __init msm_serial_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&msm_uart_driver);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = platform_driver_register(&msm_platform_driver);\n\tif (unlikely(ret))\n\t\tuart_unregister_driver(&msm_uart_driver);\n\n\tpr_info(\"msm_serial: driver initialized\\n\");\n\n\treturn ret;\n}\n\nstatic void __exit msm_serial_exit(void)\n{\n\tplatform_driver_unregister(&msm_platform_driver);\n\tuart_unregister_driver(&msm_uart_driver);\n}\n\nmodule_init(msm_serial_init);\nmodule_exit(msm_serial_exit);\n\nMODULE_AUTHOR(\"Robert Love <rlove@google.com>\");\nMODULE_DESCRIPTION(\"Driver for msm7x serial device\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}