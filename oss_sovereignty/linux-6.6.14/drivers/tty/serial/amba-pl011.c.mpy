{
  "module_name": "amba-pl011.c",
  "hash_id": "14a73bf1b803ffb4b0a8a46feff81a650e729ebc973704051bc42d022b780292",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/amba-pl011.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/platform_device.h>\n#include <linux/sysrq.h>\n#include <linux/device.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/amba/bus.h>\n#include <linux/amba/serial.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/sizes.h>\n#include <linux/io.h>\n#include <linux/acpi.h>\n\n#define UART_NR\t\t\t14\n\n#define SERIAL_AMBA_MAJOR\t204\n#define SERIAL_AMBA_MINOR\t64\n#define SERIAL_AMBA_NR\t\tUART_NR\n\n#define AMBA_ISR_PASS_LIMIT\t256\n\n#define UART_DR_ERROR\t\t(UART011_DR_OE|UART011_DR_BE|UART011_DR_PE|UART011_DR_FE)\n#define UART_DUMMY_DR_RX\t(1 << 16)\n\nenum {\n\tREG_DR,\n\tREG_ST_DMAWM,\n\tREG_ST_TIMEOUT,\n\tREG_FR,\n\tREG_LCRH_RX,\n\tREG_LCRH_TX,\n\tREG_IBRD,\n\tREG_FBRD,\n\tREG_CR,\n\tREG_IFLS,\n\tREG_IMSC,\n\tREG_RIS,\n\tREG_MIS,\n\tREG_ICR,\n\tREG_DMACR,\n\tREG_ST_XFCR,\n\tREG_ST_XON1,\n\tREG_ST_XON2,\n\tREG_ST_XOFF1,\n\tREG_ST_XOFF2,\n\tREG_ST_ITCR,\n\tREG_ST_ITIP,\n\tREG_ST_ABCR,\n\tREG_ST_ABIMSC,\n\n\t \n\tREG_ARRAY_SIZE,\n};\n\nstatic u16 pl011_std_offsets[REG_ARRAY_SIZE] = {\n\t[REG_DR] = UART01x_DR,\n\t[REG_FR] = UART01x_FR,\n\t[REG_LCRH_RX] = UART011_LCRH,\n\t[REG_LCRH_TX] = UART011_LCRH,\n\t[REG_IBRD] = UART011_IBRD,\n\t[REG_FBRD] = UART011_FBRD,\n\t[REG_CR] = UART011_CR,\n\t[REG_IFLS] = UART011_IFLS,\n\t[REG_IMSC] = UART011_IMSC,\n\t[REG_RIS] = UART011_RIS,\n\t[REG_MIS] = UART011_MIS,\n\t[REG_ICR] = UART011_ICR,\n\t[REG_DMACR] = UART011_DMACR,\n};\n\n \nstruct vendor_data {\n\tconst u16\t\t*reg_offset;\n\tunsigned int\t\tifls;\n\tunsigned int\t\tfr_busy;\n\tunsigned int\t\tfr_dsr;\n\tunsigned int\t\tfr_cts;\n\tunsigned int\t\tfr_ri;\n\tunsigned int\t\tinv_fr;\n\tbool\t\t\taccess_32b;\n\tbool\t\t\toversampling;\n\tbool\t\t\tdma_threshold;\n\tbool\t\t\tcts_event_workaround;\n\tbool\t\t\talways_enabled;\n\tbool\t\t\tfixed_options;\n\n\tunsigned int (*get_fifosize)(struct amba_device *dev);\n};\n\nstatic unsigned int get_fifosize_arm(struct amba_device *dev)\n{\n\treturn amba_rev(dev) < 3 ? 16 : 32;\n}\n\nstatic struct vendor_data vendor_arm = {\n\t.reg_offset\t\t= pl011_std_offsets,\n\t.ifls\t\t\t= UART011_IFLS_RX4_8|UART011_IFLS_TX4_8,\n\t.fr_busy\t\t= UART01x_FR_BUSY,\n\t.fr_dsr\t\t\t= UART01x_FR_DSR,\n\t.fr_cts\t\t\t= UART01x_FR_CTS,\n\t.fr_ri\t\t\t= UART011_FR_RI,\n\t.oversampling\t\t= false,\n\t.dma_threshold\t\t= false,\n\t.cts_event_workaround\t= false,\n\t.always_enabled\t\t= false,\n\t.fixed_options\t\t= false,\n\t.get_fifosize\t\t= get_fifosize_arm,\n};\n\nstatic const struct vendor_data vendor_sbsa = {\n\t.reg_offset\t\t= pl011_std_offsets,\n\t.fr_busy\t\t= UART01x_FR_BUSY,\n\t.fr_dsr\t\t\t= UART01x_FR_DSR,\n\t.fr_cts\t\t\t= UART01x_FR_CTS,\n\t.fr_ri\t\t\t= UART011_FR_RI,\n\t.access_32b\t\t= true,\n\t.oversampling\t\t= false,\n\t.dma_threshold\t\t= false,\n\t.cts_event_workaround\t= false,\n\t.always_enabled\t\t= true,\n\t.fixed_options\t\t= true,\n};\n\n#ifdef CONFIG_ACPI_SPCR_TABLE\nstatic const struct vendor_data vendor_qdt_qdf2400_e44 = {\n\t.reg_offset\t\t= pl011_std_offsets,\n\t.fr_busy\t\t= UART011_FR_TXFE,\n\t.fr_dsr\t\t\t= UART01x_FR_DSR,\n\t.fr_cts\t\t\t= UART01x_FR_CTS,\n\t.fr_ri\t\t\t= UART011_FR_RI,\n\t.inv_fr\t\t\t= UART011_FR_TXFE,\n\t.access_32b\t\t= true,\n\t.oversampling\t\t= false,\n\t.dma_threshold\t\t= false,\n\t.cts_event_workaround\t= false,\n\t.always_enabled\t\t= true,\n\t.fixed_options\t\t= true,\n};\n#endif\n\nstatic u16 pl011_st_offsets[REG_ARRAY_SIZE] = {\n\t[REG_DR] = UART01x_DR,\n\t[REG_ST_DMAWM] = ST_UART011_DMAWM,\n\t[REG_ST_TIMEOUT] = ST_UART011_TIMEOUT,\n\t[REG_FR] = UART01x_FR,\n\t[REG_LCRH_RX] = ST_UART011_LCRH_RX,\n\t[REG_LCRH_TX] = ST_UART011_LCRH_TX,\n\t[REG_IBRD] = UART011_IBRD,\n\t[REG_FBRD] = UART011_FBRD,\n\t[REG_CR] = UART011_CR,\n\t[REG_IFLS] = UART011_IFLS,\n\t[REG_IMSC] = UART011_IMSC,\n\t[REG_RIS] = UART011_RIS,\n\t[REG_MIS] = UART011_MIS,\n\t[REG_ICR] = UART011_ICR,\n\t[REG_DMACR] = UART011_DMACR,\n\t[REG_ST_XFCR] = ST_UART011_XFCR,\n\t[REG_ST_XON1] = ST_UART011_XON1,\n\t[REG_ST_XON2] = ST_UART011_XON2,\n\t[REG_ST_XOFF1] = ST_UART011_XOFF1,\n\t[REG_ST_XOFF2] = ST_UART011_XOFF2,\n\t[REG_ST_ITCR] = ST_UART011_ITCR,\n\t[REG_ST_ITIP] = ST_UART011_ITIP,\n\t[REG_ST_ABCR] = ST_UART011_ABCR,\n\t[REG_ST_ABIMSC] = ST_UART011_ABIMSC,\n};\n\nstatic unsigned int get_fifosize_st(struct amba_device *dev)\n{\n\treturn 64;\n}\n\nstatic struct vendor_data vendor_st = {\n\t.reg_offset\t\t= pl011_st_offsets,\n\t.ifls\t\t\t= UART011_IFLS_RX_HALF|UART011_IFLS_TX_HALF,\n\t.fr_busy\t\t= UART01x_FR_BUSY,\n\t.fr_dsr\t\t\t= UART01x_FR_DSR,\n\t.fr_cts\t\t\t= UART01x_FR_CTS,\n\t.fr_ri\t\t\t= UART011_FR_RI,\n\t.oversampling\t\t= true,\n\t.dma_threshold\t\t= true,\n\t.cts_event_workaround\t= true,\n\t.always_enabled\t\t= false,\n\t.fixed_options\t\t= false,\n\t.get_fifosize\t\t= get_fifosize_st,\n};\n\n \n\nstruct pl011_dmabuf {\n\tdma_addr_t\t\tdma;\n\tsize_t\t\t\tlen;\n\tchar\t\t\t*buf;\n};\n\nstruct pl011_dmarx_data {\n\tstruct dma_chan\t\t*chan;\n\tstruct completion\tcomplete;\n\tbool\t\t\tuse_buf_b;\n\tstruct pl011_dmabuf\tdbuf_a;\n\tstruct pl011_dmabuf\tdbuf_b;\n\tdma_cookie_t\t\tcookie;\n\tbool\t\t\trunning;\n\tstruct timer_list\ttimer;\n\tunsigned int last_residue;\n\tunsigned long last_jiffies;\n\tbool auto_poll_rate;\n\tunsigned int poll_rate;\n\tunsigned int poll_timeout;\n};\n\nstruct pl011_dmatx_data {\n\tstruct dma_chan\t\t*chan;\n\tdma_addr_t\t\tdma;\n\tsize_t\t\t\tlen;\n\tchar\t\t\t*buf;\n\tbool\t\t\tqueued;\n};\n\n \nstruct uart_amba_port {\n\tstruct uart_port\tport;\n\tconst u16\t\t*reg_offset;\n\tstruct clk\t\t*clk;\n\tconst struct vendor_data *vendor;\n\tunsigned int\t\tdmacr;\t\t \n\tunsigned int\t\tim;\t\t \n\tunsigned int\t\told_status;\n\tunsigned int\t\tfifosize;\t \n\tunsigned int\t\tfixed_baud;\t \n\tchar\t\t\ttype[12];\n\tbool\t\t\trs485_tx_started;\n\tunsigned int\t\trs485_tx_drain_interval;  \n#ifdef CONFIG_DMA_ENGINE\n\t \n\tbool\t\t\tusing_tx_dma;\n\tbool\t\t\tusing_rx_dma;\n\tstruct pl011_dmarx_data dmarx;\n\tstruct pl011_dmatx_data\tdmatx;\n\tbool\t\t\tdma_probed;\n#endif\n};\n\nstatic unsigned int pl011_tx_empty(struct uart_port *port);\n\nstatic unsigned int pl011_reg_to_offset(const struct uart_amba_port *uap,\n\tunsigned int reg)\n{\n\treturn uap->reg_offset[reg];\n}\n\nstatic unsigned int pl011_read(const struct uart_amba_port *uap,\n\tunsigned int reg)\n{\n\tvoid __iomem *addr = uap->port.membase + pl011_reg_to_offset(uap, reg);\n\n\treturn (uap->port.iotype == UPIO_MEM32) ?\n\t\treadl_relaxed(addr) : readw_relaxed(addr);\n}\n\nstatic void pl011_write(unsigned int val, const struct uart_amba_port *uap,\n\tunsigned int reg)\n{\n\tvoid __iomem *addr = uap->port.membase + pl011_reg_to_offset(uap, reg);\n\n\tif (uap->port.iotype == UPIO_MEM32)\n\t\twritel_relaxed(val, addr);\n\telse\n\t\twritew_relaxed(val, addr);\n}\n\n \nstatic int pl011_fifo_to_tty(struct uart_amba_port *uap)\n{\n\tunsigned int ch, fifotaken;\n\tint sysrq;\n\tu16 status;\n\tu8 flag;\n\n\tfor (fifotaken = 0; fifotaken != 256; fifotaken++) {\n\t\tstatus = pl011_read(uap, REG_FR);\n\t\tif (status & UART01x_FR_RXFE)\n\t\t\tbreak;\n\n\t\t \n\t\tch = pl011_read(uap, REG_DR) | UART_DUMMY_DR_RX;\n\t\tflag = TTY_NORMAL;\n\t\tuap->port.icount.rx++;\n\n\t\tif (unlikely(ch & UART_DR_ERROR)) {\n\t\t\tif (ch & UART011_DR_BE) {\n\t\t\t\tch &= ~(UART011_DR_FE | UART011_DR_PE);\n\t\t\t\tuap->port.icount.brk++;\n\t\t\t\tif (uart_handle_break(&uap->port))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (ch & UART011_DR_PE)\n\t\t\t\tuap->port.icount.parity++;\n\t\t\telse if (ch & UART011_DR_FE)\n\t\t\t\tuap->port.icount.frame++;\n\t\t\tif (ch & UART011_DR_OE)\n\t\t\t\tuap->port.icount.overrun++;\n\n\t\t\tch &= uap->port.read_status_mask;\n\n\t\t\tif (ch & UART011_DR_BE)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (ch & UART011_DR_PE)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (ch & UART011_DR_FE)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tspin_unlock(&uap->port.lock);\n\t\tsysrq = uart_handle_sysrq_char(&uap->port, ch & 255);\n\t\tspin_lock(&uap->port.lock);\n\n\t\tif (!sysrq)\n\t\t\tuart_insert_char(&uap->port, ch, UART011_DR_OE, ch, flag);\n\t}\n\n\treturn fifotaken;\n}\n\n\n \n#ifdef CONFIG_DMA_ENGINE\n\n#define PL011_DMA_BUFFER_SIZE PAGE_SIZE\n\nstatic int pl011_dmabuf_init(struct dma_chan *chan, struct pl011_dmabuf *db,\n\tenum dma_data_direction dir)\n{\n\tdb->buf = dma_alloc_coherent(chan->device->dev, PL011_DMA_BUFFER_SIZE,\n\t\t\t\t     &db->dma, GFP_KERNEL);\n\tif (!db->buf)\n\t\treturn -ENOMEM;\n\tdb->len = PL011_DMA_BUFFER_SIZE;\n\n\treturn 0;\n}\n\nstatic void pl011_dmabuf_free(struct dma_chan *chan, struct pl011_dmabuf *db,\n\tenum dma_data_direction dir)\n{\n\tif (db->buf) {\n\t\tdma_free_coherent(chan->device->dev,\n\t\t\t\t  PL011_DMA_BUFFER_SIZE, db->buf, db->dma);\n\t}\n}\n\nstatic void pl011_dma_probe(struct uart_amba_port *uap)\n{\n\t \n\tstruct amba_pl011_data *plat = dev_get_platdata(uap->port.dev);\n\tstruct device *dev = uap->port.dev;\n\tstruct dma_slave_config tx_conf = {\n\t\t.dst_addr = uap->port.mapbase +\n\t\t\t\t pl011_reg_to_offset(uap, REG_DR),\n\t\t.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,\n\t\t.direction = DMA_MEM_TO_DEV,\n\t\t.dst_maxburst = uap->fifosize >> 1,\n\t\t.device_fc = false,\n\t};\n\tstruct dma_chan *chan;\n\tdma_cap_mask_t mask;\n\n\tuap->dma_probed = true;\n\tchan = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(chan)) {\n\t\tif (PTR_ERR(chan) == -EPROBE_DEFER) {\n\t\t\tuap->dma_probed = false;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (!plat || !plat->dma_filter) {\n\t\t\tdev_info(uap->port.dev, \"no DMA platform data\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tdma_cap_zero(mask);\n\t\tdma_cap_set(DMA_SLAVE, mask);\n\n\t\tchan = dma_request_channel(mask, plat->dma_filter,\n\t\t\t\t\t\tplat->dma_tx_param);\n\t\tif (!chan) {\n\t\t\tdev_err(uap->port.dev, \"no TX DMA channel!\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdmaengine_slave_config(chan, &tx_conf);\n\tuap->dmatx.chan = chan;\n\n\tdev_info(uap->port.dev, \"DMA channel TX %s\\n\",\n\t\t dma_chan_name(uap->dmatx.chan));\n\n\t \n\tchan = dma_request_slave_channel(dev, \"rx\");\n\n\tif (!chan && plat && plat->dma_rx_param) {\n\t\tchan = dma_request_channel(mask, plat->dma_filter, plat->dma_rx_param);\n\n\t\tif (!chan) {\n\t\t\tdev_err(uap->port.dev, \"no RX DMA channel!\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (chan) {\n\t\tstruct dma_slave_config rx_conf = {\n\t\t\t.src_addr = uap->port.mapbase +\n\t\t\t\tpl011_reg_to_offset(uap, REG_DR),\n\t\t\t.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,\n\t\t\t.direction = DMA_DEV_TO_MEM,\n\t\t\t.src_maxburst = uap->fifosize >> 2,\n\t\t\t.device_fc = false,\n\t\t};\n\t\tstruct dma_slave_caps caps;\n\n\t\t \n\t\tif (0 == dma_get_slave_caps(chan, &caps)) {\n\t\t\tif (caps.residue_granularity ==\n\t\t\t\t\tDMA_RESIDUE_GRANULARITY_DESCRIPTOR) {\n\t\t\t\tdma_release_channel(chan);\n\t\t\t\tdev_info(uap->port.dev,\n\t\t\t\t\t\"RX DMA disabled - no residue processing\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdmaengine_slave_config(chan, &rx_conf);\n\t\tuap->dmarx.chan = chan;\n\n\t\tuap->dmarx.auto_poll_rate = false;\n\t\tif (plat && plat->dma_rx_poll_enable) {\n\t\t\t \n\t\t\tif (plat->dma_rx_poll_rate) {\n\t\t\t\tuap->dmarx.auto_poll_rate = false;\n\t\t\t\tuap->dmarx.poll_rate = plat->dma_rx_poll_rate;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tuap->dmarx.auto_poll_rate = true;\n\t\t\t\tuap->dmarx.poll_rate =  100;\n\t\t\t}\n\t\t\t \n\t\t\tif (plat->dma_rx_poll_timeout)\n\t\t\t\tuap->dmarx.poll_timeout =\n\t\t\t\t\tplat->dma_rx_poll_timeout;\n\t\t\telse\n\t\t\t\tuap->dmarx.poll_timeout = 3000;\n\t\t} else if (!plat && dev->of_node) {\n\t\t\tuap->dmarx.auto_poll_rate = of_property_read_bool(\n\t\t\t\t\t\tdev->of_node, \"auto-poll\");\n\t\t\tif (uap->dmarx.auto_poll_rate) {\n\t\t\t\tu32 x;\n\n\t\t\t\tif (0 == of_property_read_u32(dev->of_node,\n\t\t\t\t\t\t\"poll-rate-ms\", &x))\n\t\t\t\t\tuap->dmarx.poll_rate = x;\n\t\t\t\telse\n\t\t\t\t\tuap->dmarx.poll_rate = 100;\n\t\t\t\tif (0 == of_property_read_u32(dev->of_node,\n\t\t\t\t\t\t\"poll-timeout-ms\", &x))\n\t\t\t\t\tuap->dmarx.poll_timeout = x;\n\t\t\t\telse\n\t\t\t\t\tuap->dmarx.poll_timeout = 3000;\n\t\t\t}\n\t\t}\n\t\tdev_info(uap->port.dev, \"DMA channel RX %s\\n\",\n\t\t\t dma_chan_name(uap->dmarx.chan));\n\t}\n}\n\nstatic void pl011_dma_remove(struct uart_amba_port *uap)\n{\n\tif (uap->dmatx.chan)\n\t\tdma_release_channel(uap->dmatx.chan);\n\tif (uap->dmarx.chan)\n\t\tdma_release_channel(uap->dmarx.chan);\n}\n\n \nstatic int pl011_dma_tx_refill(struct uart_amba_port *uap);\nstatic void pl011_start_tx_pio(struct uart_amba_port *uap);\n\n \nstatic void pl011_dma_tx_callback(void *data)\n{\n\tstruct uart_amba_port *uap = data;\n\tstruct pl011_dmatx_data *dmatx = &uap->dmatx;\n\tunsigned long flags;\n\tu16 dmacr;\n\n\tspin_lock_irqsave(&uap->port.lock, flags);\n\tif (uap->dmatx.queued)\n\t\tdma_unmap_single(dmatx->chan->device->dev, dmatx->dma,\n\t\t\t\tdmatx->len, DMA_TO_DEVICE);\n\n\tdmacr = uap->dmacr;\n\tuap->dmacr = dmacr & ~UART011_TXDMAE;\n\tpl011_write(uap->dmacr, uap, REG_DMACR);\n\n\t \n\tif (!(dmacr & UART011_TXDMAE) || uart_tx_stopped(&uap->port) ||\n\t    uart_circ_empty(&uap->port.state->xmit)) {\n\t\tuap->dmatx.queued = false;\n\t\tspin_unlock_irqrestore(&uap->port.lock, flags);\n\t\treturn;\n\t}\n\n\tif (pl011_dma_tx_refill(uap) <= 0)\n\t\t \n\t\tpl011_start_tx_pio(uap);\n\n\tspin_unlock_irqrestore(&uap->port.lock, flags);\n}\n\n \nstatic int pl011_dma_tx_refill(struct uart_amba_port *uap)\n{\n\tstruct pl011_dmatx_data *dmatx = &uap->dmatx;\n\tstruct dma_chan *chan = dmatx->chan;\n\tstruct dma_device *dma_dev = chan->device;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct circ_buf *xmit = &uap->port.state->xmit;\n\tunsigned int count;\n\n\t \n\tcount = uart_circ_chars_pending(xmit);\n\tif (count < (uap->fifosize >> 1)) {\n\t\tuap->dmatx.queued = false;\n\t\treturn 0;\n\t}\n\n\t \n\tcount -= 1;\n\n\t \n\tif (count > PL011_DMA_BUFFER_SIZE)\n\t\tcount = PL011_DMA_BUFFER_SIZE;\n\n\tif (xmit->tail < xmit->head)\n\t\tmemcpy(&dmatx->buf[0], &xmit->buf[xmit->tail], count);\n\telse {\n\t\tsize_t first = UART_XMIT_SIZE - xmit->tail;\n\t\tsize_t second;\n\n\t\tif (first > count)\n\t\t\tfirst = count;\n\t\tsecond = count - first;\n\n\t\tmemcpy(&dmatx->buf[0], &xmit->buf[xmit->tail], first);\n\t\tif (second)\n\t\t\tmemcpy(&dmatx->buf[first], &xmit->buf[0], second);\n\t}\n\n\tdmatx->len = count;\n\tdmatx->dma = dma_map_single(dma_dev->dev, dmatx->buf, count,\n\t\t\t\t    DMA_TO_DEVICE);\n\tif (dmatx->dma == DMA_MAPPING_ERROR) {\n\t\tuap->dmatx.queued = false;\n\t\tdev_dbg(uap->port.dev, \"unable to map TX DMA\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdesc = dmaengine_prep_slave_single(chan, dmatx->dma, dmatx->len, DMA_MEM_TO_DEV,\n\t\t\t\t\t     DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdma_unmap_single(dma_dev->dev, dmatx->dma, dmatx->len, DMA_TO_DEVICE);\n\t\tuap->dmatx.queued = false;\n\t\t \n\t\tdev_dbg(uap->port.dev, \"TX DMA busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tdesc->callback = pl011_dma_tx_callback;\n\tdesc->callback_param = uap;\n\n\t \n\tdmaengine_submit(desc);\n\n\t \n\tdma_dev->device_issue_pending(chan);\n\n\tuap->dmacr |= UART011_TXDMAE;\n\tpl011_write(uap->dmacr, uap, REG_DMACR);\n\tuap->dmatx.queued = true;\n\n\t \n\tuart_xmit_advance(&uap->port, count);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&uap->port);\n\n\treturn 1;\n}\n\n \nstatic bool pl011_dma_tx_irq(struct uart_amba_port *uap)\n{\n\tif (!uap->using_tx_dma)\n\t\treturn false;\n\n\t \n\tif (uap->dmatx.queued) {\n\t\tuap->dmacr |= UART011_TXDMAE;\n\t\tpl011_write(uap->dmacr, uap, REG_DMACR);\n\t\tuap->im &= ~UART011_TXIM;\n\t\tpl011_write(uap->im, uap, REG_IMSC);\n\t\treturn true;\n\t}\n\n\t \n\tif (pl011_dma_tx_refill(uap) > 0) {\n\t\tuap->im &= ~UART011_TXIM;\n\t\tpl011_write(uap->im, uap, REG_IMSC);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic inline void pl011_dma_tx_stop(struct uart_amba_port *uap)\n{\n\tif (uap->dmatx.queued) {\n\t\tuap->dmacr &= ~UART011_TXDMAE;\n\t\tpl011_write(uap->dmacr, uap, REG_DMACR);\n\t}\n}\n\n \nstatic inline bool pl011_dma_tx_start(struct uart_amba_port *uap)\n{\n\tu16 dmacr;\n\n\tif (!uap->using_tx_dma)\n\t\treturn false;\n\n\tif (!uap->port.x_char) {\n\t\t \n\t\tbool ret = true;\n\n\t\tif (!uap->dmatx.queued) {\n\t\t\tif (pl011_dma_tx_refill(uap) > 0) {\n\t\t\t\tuap->im &= ~UART011_TXIM;\n\t\t\t\tpl011_write(uap->im, uap, REG_IMSC);\n\t\t\t} else\n\t\t\t\tret = false;\n\t\t} else if (!(uap->dmacr & UART011_TXDMAE)) {\n\t\t\tuap->dmacr |= UART011_TXDMAE;\n\t\t\tpl011_write(uap->dmacr, uap, REG_DMACR);\n\t\t}\n\t\treturn ret;\n\t}\n\n\t \n\tdmacr = uap->dmacr;\n\tuap->dmacr &= ~UART011_TXDMAE;\n\tpl011_write(uap->dmacr, uap, REG_DMACR);\n\n\tif (pl011_read(uap, REG_FR) & UART01x_FR_TXFF) {\n\t\t \n\t\treturn false;\n\t}\n\n\tpl011_write(uap->port.x_char, uap, REG_DR);\n\tuap->port.icount.tx++;\n\tuap->port.x_char = 0;\n\n\t \n\tuap->dmacr = dmacr;\n\tpl011_write(dmacr, uap, REG_DMACR);\n\n\treturn true;\n}\n\n \nstatic void pl011_dma_flush_buffer(struct uart_port *port)\n__releases(&uap->port.lock)\n__acquires(&uap->port.lock)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\n\tif (!uap->using_tx_dma)\n\t\treturn;\n\n\tdmaengine_terminate_async(uap->dmatx.chan);\n\n\tif (uap->dmatx.queued) {\n\t\tdma_unmap_single(uap->dmatx.chan->device->dev, uap->dmatx.dma,\n\t\t\t\t uap->dmatx.len, DMA_TO_DEVICE);\n\t\tuap->dmatx.queued = false;\n\t\tuap->dmacr &= ~UART011_TXDMAE;\n\t\tpl011_write(uap->dmacr, uap, REG_DMACR);\n\t}\n}\n\nstatic void pl011_dma_rx_callback(void *data);\n\nstatic int pl011_dma_rx_trigger_dma(struct uart_amba_port *uap)\n{\n\tstruct dma_chan *rxchan = uap->dmarx.chan;\n\tstruct pl011_dmarx_data *dmarx = &uap->dmarx;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct pl011_dmabuf *dbuf;\n\n\tif (!rxchan)\n\t\treturn -EIO;\n\n\t \n\tdbuf = uap->dmarx.use_buf_b ?\n\t\t&uap->dmarx.dbuf_b : &uap->dmarx.dbuf_a;\n\tdesc = dmaengine_prep_slave_single(rxchan, dbuf->dma, dbuf->len,\n\t\t\t\t\tDMA_DEV_TO_MEM,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t \n\tif (!desc) {\n\t\tuap->dmarx.running = false;\n\t\tdmaengine_terminate_all(rxchan);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tdesc->callback = pl011_dma_rx_callback;\n\tdesc->callback_param = uap;\n\tdmarx->cookie = dmaengine_submit(desc);\n\tdma_async_issue_pending(rxchan);\n\n\tuap->dmacr |= UART011_RXDMAE;\n\tpl011_write(uap->dmacr, uap, REG_DMACR);\n\tuap->dmarx.running = true;\n\n\tuap->im &= ~UART011_RXIM;\n\tpl011_write(uap->im, uap, REG_IMSC);\n\n\treturn 0;\n}\n\n \nstatic void pl011_dma_rx_chars(struct uart_amba_port *uap,\n\t\t\t       u32 pending, bool use_buf_b,\n\t\t\t       bool readfifo)\n{\n\tstruct tty_port *port = &uap->port.state->port;\n\tstruct pl011_dmabuf *dbuf = use_buf_b ?\n\t\t&uap->dmarx.dbuf_b : &uap->dmarx.dbuf_a;\n\tint dma_count = 0;\n\tu32 fifotaken = 0;  \n\n\tstruct pl011_dmarx_data *dmarx = &uap->dmarx;\n\tint dmataken = 0;\n\n\tif (uap->dmarx.poll_rate) {\n\t\t \n\t\tdmataken = dbuf->len - dmarx->last_residue;\n\t\t \n\t\tif (pending >= dmataken)\n\t\t\tpending -= dmataken;\n\t}\n\n\t \n\tif (pending) {\n\n\t\t \n\t\tdma_count = tty_insert_flip_string(port, dbuf->buf + dmataken,\n\t\t\t\tpending);\n\n\t\tuap->port.icount.rx += dma_count;\n\t\tif (dma_count < pending)\n\t\t\tdev_warn(uap->port.dev,\n\t\t\t\t \"couldn't insert all characters (TTY is full?)\\n\");\n\t}\n\n\t \n\tif (uap->dmarx.poll_rate)\n\t\tdmarx->last_residue = dbuf->len;\n\n\t \n\tif (dma_count == pending && readfifo) {\n\t\t \n\t\tpl011_write(UART011_OEIS | UART011_BEIS | UART011_PEIS |\n\t\t\t    UART011_FEIS, uap, REG_ICR);\n\n\t\t \n\t\tfifotaken = pl011_fifo_to_tty(uap);\n\t}\n\n\tdev_vdbg(uap->port.dev,\n\t\t \"Took %d chars from DMA buffer and %d chars from the FIFO\\n\",\n\t\t dma_count, fifotaken);\n\ttty_flip_buffer_push(port);\n}\n\nstatic void pl011_dma_rx_irq(struct uart_amba_port *uap)\n{\n\tstruct pl011_dmarx_data *dmarx = &uap->dmarx;\n\tstruct dma_chan *rxchan = dmarx->chan;\n\tstruct pl011_dmabuf *dbuf = dmarx->use_buf_b ?\n\t\t&dmarx->dbuf_b : &dmarx->dbuf_a;\n\tsize_t pending;\n\tstruct dma_tx_state state;\n\tenum dma_status dmastat;\n\n\t \n\tif (dmaengine_pause(rxchan))\n\t\tdev_err(uap->port.dev, \"unable to pause DMA transfer\\n\");\n\tdmastat = rxchan->device->device_tx_status(rxchan,\n\t\t\t\t\t\t   dmarx->cookie, &state);\n\tif (dmastat != DMA_PAUSED)\n\t\tdev_err(uap->port.dev, \"unable to pause DMA transfer\\n\");\n\n\t \n\tuap->dmacr &= ~UART011_RXDMAE;\n\tpl011_write(uap->dmacr, uap, REG_DMACR);\n\tuap->dmarx.running = false;\n\n\tpending = dbuf->len - state.residue;\n\tBUG_ON(pending > PL011_DMA_BUFFER_SIZE);\n\t \n\tdmaengine_terminate_all(rxchan);\n\n\t \n\tpl011_dma_rx_chars(uap, pending, dmarx->use_buf_b, true);\n\n\t \n\tdmarx->use_buf_b = !dmarx->use_buf_b;\n\tif (pl011_dma_rx_trigger_dma(uap)) {\n\t\tdev_dbg(uap->port.dev, \"could not retrigger RX DMA job \"\n\t\t\t\"fall back to interrupt mode\\n\");\n\t\tuap->im |= UART011_RXIM;\n\t\tpl011_write(uap->im, uap, REG_IMSC);\n\t}\n}\n\nstatic void pl011_dma_rx_callback(void *data)\n{\n\tstruct uart_amba_port *uap = data;\n\tstruct pl011_dmarx_data *dmarx = &uap->dmarx;\n\tstruct dma_chan *rxchan = dmarx->chan;\n\tbool lastbuf = dmarx->use_buf_b;\n\tstruct pl011_dmabuf *dbuf = dmarx->use_buf_b ?\n\t\t&dmarx->dbuf_b : &dmarx->dbuf_a;\n\tsize_t pending;\n\tstruct dma_tx_state state;\n\tint ret;\n\n\t \n\tspin_lock_irq(&uap->port.lock);\n\t \n\trxchan->device->device_tx_status(rxchan, dmarx->cookie, &state);\n\tpending = dbuf->len - state.residue;\n\tBUG_ON(pending > PL011_DMA_BUFFER_SIZE);\n\t \n\tdmaengine_terminate_all(rxchan);\n\n\tuap->dmarx.running = false;\n\tdmarx->use_buf_b = !lastbuf;\n\tret = pl011_dma_rx_trigger_dma(uap);\n\n\tpl011_dma_rx_chars(uap, pending, lastbuf, false);\n\tspin_unlock_irq(&uap->port.lock);\n\t \n\tif (ret) {\n\t\tdev_dbg(uap->port.dev, \"could not retrigger RX DMA job \"\n\t\t\t\"fall back to interrupt mode\\n\");\n\t\tuap->im |= UART011_RXIM;\n\t\tpl011_write(uap->im, uap, REG_IMSC);\n\t}\n}\n\n \nstatic inline void pl011_dma_rx_stop(struct uart_amba_port *uap)\n{\n\tif (!uap->using_rx_dma)\n\t\treturn;\n\n\t \n\tuap->dmacr &= ~UART011_RXDMAE;\n\tpl011_write(uap->dmacr, uap, REG_DMACR);\n}\n\n \nstatic void pl011_dma_rx_poll(struct timer_list *t)\n{\n\tstruct uart_amba_port *uap = from_timer(uap, t, dmarx.timer);\n\tstruct tty_port *port = &uap->port.state->port;\n\tstruct pl011_dmarx_data *dmarx = &uap->dmarx;\n\tstruct dma_chan *rxchan = uap->dmarx.chan;\n\tunsigned long flags;\n\tunsigned int dmataken = 0;\n\tunsigned int size = 0;\n\tstruct pl011_dmabuf *dbuf;\n\tint dma_count;\n\tstruct dma_tx_state state;\n\n\tdbuf = dmarx->use_buf_b ? &uap->dmarx.dbuf_b : &uap->dmarx.dbuf_a;\n\trxchan->device->device_tx_status(rxchan, dmarx->cookie, &state);\n\tif (likely(state.residue < dmarx->last_residue)) {\n\t\tdmataken = dbuf->len - dmarx->last_residue;\n\t\tsize = dmarx->last_residue - state.residue;\n\t\tdma_count = tty_insert_flip_string(port, dbuf->buf + dmataken,\n\t\t\t\tsize);\n\t\tif (dma_count == size)\n\t\t\tdmarx->last_residue =  state.residue;\n\t\tdmarx->last_jiffies = jiffies;\n\t}\n\ttty_flip_buffer_push(port);\n\n\t \n\tif (jiffies_to_msecs(jiffies - dmarx->last_jiffies)\n\t\t\t> uap->dmarx.poll_timeout) {\n\n\t\tspin_lock_irqsave(&uap->port.lock, flags);\n\t\tpl011_dma_rx_stop(uap);\n\t\tuap->im |= UART011_RXIM;\n\t\tpl011_write(uap->im, uap, REG_IMSC);\n\t\tspin_unlock_irqrestore(&uap->port.lock, flags);\n\n\t\tuap->dmarx.running = false;\n\t\tdmaengine_terminate_all(rxchan);\n\t\tdel_timer(&uap->dmarx.timer);\n\t} else {\n\t\tmod_timer(&uap->dmarx.timer,\n\t\t\tjiffies + msecs_to_jiffies(uap->dmarx.poll_rate));\n\t}\n}\n\nstatic void pl011_dma_startup(struct uart_amba_port *uap)\n{\n\tint ret;\n\n\tif (!uap->dma_probed)\n\t\tpl011_dma_probe(uap);\n\n\tif (!uap->dmatx.chan)\n\t\treturn;\n\n\tuap->dmatx.buf = kmalloc(PL011_DMA_BUFFER_SIZE, GFP_KERNEL | __GFP_DMA);\n\tif (!uap->dmatx.buf) {\n\t\tdev_err(uap->port.dev, \"no memory for DMA TX buffer\\n\");\n\t\tuap->port.fifosize = uap->fifosize;\n\t\treturn;\n\t}\n\n\tuap->dmatx.len = PL011_DMA_BUFFER_SIZE;\n\n\t \n\tuap->port.fifosize = PL011_DMA_BUFFER_SIZE;\n\tuap->using_tx_dma = true;\n\n\tif (!uap->dmarx.chan)\n\t\tgoto skip_rx;\n\n\t \n\tret = pl011_dmabuf_init(uap->dmarx.chan, &uap->dmarx.dbuf_a,\n\t\t\t       DMA_FROM_DEVICE);\n\tif (ret) {\n\t\tdev_err(uap->port.dev, \"failed to init DMA %s: %d\\n\",\n\t\t\t\"RX buffer A\", ret);\n\t\tgoto skip_rx;\n\t}\n\n\tret = pl011_dmabuf_init(uap->dmarx.chan, &uap->dmarx.dbuf_b,\n\t\t\t       DMA_FROM_DEVICE);\n\tif (ret) {\n\t\tdev_err(uap->port.dev, \"failed to init DMA %s: %d\\n\",\n\t\t\t\"RX buffer B\", ret);\n\t\tpl011_dmabuf_free(uap->dmarx.chan, &uap->dmarx.dbuf_a,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tgoto skip_rx;\n\t}\n\n\tuap->using_rx_dma = true;\n\nskip_rx:\n\t \n\tuap->dmacr |= UART011_DMAONERR;\n\tpl011_write(uap->dmacr, uap, REG_DMACR);\n\n\t \n\tif (uap->vendor->dma_threshold)\n\t\tpl011_write(ST_UART011_DMAWM_RX_16 | ST_UART011_DMAWM_TX_16,\n\t\t\t    uap, REG_ST_DMAWM);\n\n\tif (uap->using_rx_dma) {\n\t\tif (pl011_dma_rx_trigger_dma(uap))\n\t\t\tdev_dbg(uap->port.dev, \"could not trigger initial \"\n\t\t\t\t\"RX DMA job, fall back to interrupt mode\\n\");\n\t\tif (uap->dmarx.poll_rate) {\n\t\t\ttimer_setup(&uap->dmarx.timer, pl011_dma_rx_poll, 0);\n\t\t\tmod_timer(&uap->dmarx.timer,\n\t\t\t\tjiffies +\n\t\t\t\tmsecs_to_jiffies(uap->dmarx.poll_rate));\n\t\t\tuap->dmarx.last_residue = PL011_DMA_BUFFER_SIZE;\n\t\t\tuap->dmarx.last_jiffies = jiffies;\n\t\t}\n\t}\n}\n\nstatic void pl011_dma_shutdown(struct uart_amba_port *uap)\n{\n\tif (!(uap->using_tx_dma || uap->using_rx_dma))\n\t\treturn;\n\n\t \n\twhile (pl011_read(uap, REG_FR) & uap->vendor->fr_busy)\n\t\tcpu_relax();\n\n\tspin_lock_irq(&uap->port.lock);\n\tuap->dmacr &= ~(UART011_DMAONERR | UART011_RXDMAE | UART011_TXDMAE);\n\tpl011_write(uap->dmacr, uap, REG_DMACR);\n\tspin_unlock_irq(&uap->port.lock);\n\n\tif (uap->using_tx_dma) {\n\t\t \n\t\tdmaengine_terminate_all(uap->dmatx.chan);\n\t\tif (uap->dmatx.queued) {\n\t\t\tdma_unmap_single(uap->dmatx.chan->device->dev,\n\t\t\t\t\t uap->dmatx.dma, uap->dmatx.len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tuap->dmatx.queued = false;\n\t\t}\n\n\t\tkfree(uap->dmatx.buf);\n\t\tuap->using_tx_dma = false;\n\t}\n\n\tif (uap->using_rx_dma) {\n\t\tdmaengine_terminate_all(uap->dmarx.chan);\n\t\t \n\t\tpl011_dmabuf_free(uap->dmarx.chan, &uap->dmarx.dbuf_a, DMA_FROM_DEVICE);\n\t\tpl011_dmabuf_free(uap->dmarx.chan, &uap->dmarx.dbuf_b, DMA_FROM_DEVICE);\n\t\tif (uap->dmarx.poll_rate)\n\t\t\tdel_timer_sync(&uap->dmarx.timer);\n\t\tuap->using_rx_dma = false;\n\t}\n}\n\nstatic inline bool pl011_dma_rx_available(struct uart_amba_port *uap)\n{\n\treturn uap->using_rx_dma;\n}\n\nstatic inline bool pl011_dma_rx_running(struct uart_amba_port *uap)\n{\n\treturn uap->using_rx_dma && uap->dmarx.running;\n}\n\n#else\n \nstatic inline void pl011_dma_remove(struct uart_amba_port *uap)\n{\n}\n\nstatic inline void pl011_dma_startup(struct uart_amba_port *uap)\n{\n}\n\nstatic inline void pl011_dma_shutdown(struct uart_amba_port *uap)\n{\n}\n\nstatic inline bool pl011_dma_tx_irq(struct uart_amba_port *uap)\n{\n\treturn false;\n}\n\nstatic inline void pl011_dma_tx_stop(struct uart_amba_port *uap)\n{\n}\n\nstatic inline bool pl011_dma_tx_start(struct uart_amba_port *uap)\n{\n\treturn false;\n}\n\nstatic inline void pl011_dma_rx_irq(struct uart_amba_port *uap)\n{\n}\n\nstatic inline void pl011_dma_rx_stop(struct uart_amba_port *uap)\n{\n}\n\nstatic inline int pl011_dma_rx_trigger_dma(struct uart_amba_port *uap)\n{\n\treturn -EIO;\n}\n\nstatic inline bool pl011_dma_rx_available(struct uart_amba_port *uap)\n{\n\treturn false;\n}\n\nstatic inline bool pl011_dma_rx_running(struct uart_amba_port *uap)\n{\n\treturn false;\n}\n\n#define pl011_dma_flush_buffer\tNULL\n#endif\n\nstatic void pl011_rs485_tx_stop(struct uart_amba_port *uap)\n{\n\t \n\tconst int MAX_TX_DRAIN_ITERS = uap->port.fifosize * 2;\n\tstruct uart_port *port = &uap->port;\n\tint i = 0;\n\tu32 cr;\n\n\t \n\twhile (!pl011_tx_empty(port)) {\n\t\tif (i > MAX_TX_DRAIN_ITERS) {\n\t\t\tdev_warn(port->dev,\n\t\t\t\t \"timeout while draining hardware tx queue\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(uap->rs485_tx_drain_interval);\n\t\ti++;\n\t}\n\n\tif (port->rs485.delay_rts_after_send)\n\t\tmdelay(port->rs485.delay_rts_after_send);\n\n\tcr = pl011_read(uap, REG_CR);\n\n\tif (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)\n\t\tcr &= ~UART011_CR_RTS;\n\telse\n\t\tcr |= UART011_CR_RTS;\n\n\t \n\tcr &= ~UART011_CR_TXE;\n\tcr |= UART011_CR_RXE;\n\tpl011_write(cr, uap, REG_CR);\n\n\tuap->rs485_tx_started = false;\n}\n\nstatic void pl011_stop_tx(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\n\tuap->im &= ~UART011_TXIM;\n\tpl011_write(uap->im, uap, REG_IMSC);\n\tpl011_dma_tx_stop(uap);\n\n\tif ((port->rs485.flags & SER_RS485_ENABLED) && uap->rs485_tx_started)\n\t\tpl011_rs485_tx_stop(uap);\n}\n\nstatic bool pl011_tx_chars(struct uart_amba_port *uap, bool from_irq);\n\n \nstatic void pl011_start_tx_pio(struct uart_amba_port *uap)\n{\n\tif (pl011_tx_chars(uap, false)) {\n\t\tuap->im |= UART011_TXIM;\n\t\tpl011_write(uap->im, uap, REG_IMSC);\n\t}\n}\n\nstatic void pl011_start_tx(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\n\tif (!pl011_dma_tx_start(uap))\n\t\tpl011_start_tx_pio(uap);\n}\n\nstatic void pl011_stop_rx(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\n\tuap->im &= ~(UART011_RXIM|UART011_RTIM|UART011_FEIM|\n\t\t     UART011_PEIM|UART011_BEIM|UART011_OEIM);\n\tpl011_write(uap->im, uap, REG_IMSC);\n\n\tpl011_dma_rx_stop(uap);\n}\n\nstatic void pl011_throttle_rx(struct uart_port *port)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tpl011_stop_rx(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void pl011_enable_ms(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\n\tuap->im |= UART011_RIMIM|UART011_CTSMIM|UART011_DCDMIM|UART011_DSRMIM;\n\tpl011_write(uap->im, uap, REG_IMSC);\n}\n\nstatic void pl011_rx_chars(struct uart_amba_port *uap)\n__releases(&uap->port.lock)\n__acquires(&uap->port.lock)\n{\n\tpl011_fifo_to_tty(uap);\n\n\tspin_unlock(&uap->port.lock);\n\ttty_flip_buffer_push(&uap->port.state->port);\n\t \n\tif (pl011_dma_rx_available(uap)) {\n\t\tif (pl011_dma_rx_trigger_dma(uap)) {\n\t\t\tdev_dbg(uap->port.dev, \"could not trigger RX DMA job \"\n\t\t\t\t\"fall back to interrupt mode again\\n\");\n\t\t\tuap->im |= UART011_RXIM;\n\t\t\tpl011_write(uap->im, uap, REG_IMSC);\n\t\t} else {\n#ifdef CONFIG_DMA_ENGINE\n\t\t\t \n\t\t\tif (uap->dmarx.poll_rate) {\n\t\t\t\tuap->dmarx.last_jiffies = jiffies;\n\t\t\t\tuap->dmarx.last_residue\t= PL011_DMA_BUFFER_SIZE;\n\t\t\t\tmod_timer(&uap->dmarx.timer,\n\t\t\t\t\tjiffies +\n\t\t\t\t\tmsecs_to_jiffies(uap->dmarx.poll_rate));\n\t\t\t}\n#endif\n\t\t}\n\t}\n\tspin_lock(&uap->port.lock);\n}\n\nstatic bool pl011_tx_char(struct uart_amba_port *uap, unsigned char c,\n\t\t\t  bool from_irq)\n{\n\tif (unlikely(!from_irq) &&\n\t    pl011_read(uap, REG_FR) & UART01x_FR_TXFF)\n\t\treturn false;  \n\n\tpl011_write(c, uap, REG_DR);\n\tuap->port.icount.tx++;\n\n\treturn true;\n}\n\nstatic void pl011_rs485_tx_start(struct uart_amba_port *uap)\n{\n\tstruct uart_port *port = &uap->port;\n\tu32 cr;\n\n\t \n\tcr = pl011_read(uap, REG_CR);\n\tcr |= UART011_CR_TXE;\n\n\t \n\tif (!(port->rs485.flags & SER_RS485_RX_DURING_TX))\n\t\tcr &= ~UART011_CR_RXE;\n\n\tif (port->rs485.flags & SER_RS485_RTS_ON_SEND)\n\t\tcr &= ~UART011_CR_RTS;\n\telse\n\t\tcr |= UART011_CR_RTS;\n\n\tpl011_write(cr, uap, REG_CR);\n\n\tif (port->rs485.delay_rts_before_send)\n\t\tmdelay(port->rs485.delay_rts_before_send);\n\n\tuap->rs485_tx_started = true;\n}\n\n \nstatic bool pl011_tx_chars(struct uart_amba_port *uap, bool from_irq)\n{\n\tstruct circ_buf *xmit = &uap->port.state->xmit;\n\tint count = uap->fifosize >> 1;\n\n\tif ((uap->port.rs485.flags & SER_RS485_ENABLED) &&\n\t    !uap->rs485_tx_started)\n\t\tpl011_rs485_tx_start(uap);\n\n\tif (uap->port.x_char) {\n\t\tif (!pl011_tx_char(uap, uap->port.x_char, from_irq))\n\t\t\treturn true;\n\t\tuap->port.x_char = 0;\n\t\t--count;\n\t}\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(&uap->port)) {\n\t\tpl011_stop_tx(&uap->port);\n\t\treturn false;\n\t}\n\n\t \n\tif (pl011_dma_tx_irq(uap))\n\t\treturn true;\n\n\tdo {\n\t\tif (likely(from_irq) && count-- == 0)\n\t\t\tbreak;\n\n\t\tif (!pl011_tx_char(uap, xmit->buf[xmit->tail], from_irq))\n\t\t\tbreak;\n\n\t\txmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\n\t} while (!uart_circ_empty(xmit));\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&uap->port);\n\n\tif (uart_circ_empty(xmit)) {\n\t\tpl011_stop_tx(&uap->port);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void pl011_modem_status(struct uart_amba_port *uap)\n{\n\tunsigned int status, delta;\n\n\tstatus = pl011_read(uap, REG_FR) & UART01x_FR_MODEM_ANY;\n\n\tdelta = status ^ uap->old_status;\n\tuap->old_status = status;\n\n\tif (!delta)\n\t\treturn;\n\n\tif (delta & UART01x_FR_DCD)\n\t\tuart_handle_dcd_change(&uap->port, status & UART01x_FR_DCD);\n\n\tif (delta & uap->vendor->fr_dsr)\n\t\tuap->port.icount.dsr++;\n\n\tif (delta & uap->vendor->fr_cts)\n\t\tuart_handle_cts_change(&uap->port,\n\t\t\t\t       status & uap->vendor->fr_cts);\n\n\twake_up_interruptible(&uap->port.state->port.delta_msr_wait);\n}\n\nstatic void check_apply_cts_event_workaround(struct uart_amba_port *uap)\n{\n\tif (!uap->vendor->cts_event_workaround)\n\t\treturn;\n\n\t \n\tpl011_write(0x00, uap, REG_ICR);\n\n\t \n\tpl011_read(uap, REG_ICR);\n\tpl011_read(uap, REG_ICR);\n}\n\nstatic irqreturn_t pl011_int(int irq, void *dev_id)\n{\n\tstruct uart_amba_port *uap = dev_id;\n\tunsigned long flags;\n\tunsigned int status, pass_counter = AMBA_ISR_PASS_LIMIT;\n\tint handled = 0;\n\n\tspin_lock_irqsave(&uap->port.lock, flags);\n\tstatus = pl011_read(uap, REG_RIS) & uap->im;\n\tif (status) {\n\t\tdo {\n\t\t\tcheck_apply_cts_event_workaround(uap);\n\n\t\t\tpl011_write(status & ~(UART011_TXIS|UART011_RTIS|\n\t\t\t\t\t       UART011_RXIS),\n\t\t\t\t    uap, REG_ICR);\n\n\t\t\tif (status & (UART011_RTIS|UART011_RXIS)) {\n\t\t\t\tif (pl011_dma_rx_running(uap))\n\t\t\t\t\tpl011_dma_rx_irq(uap);\n\t\t\t\telse\n\t\t\t\t\tpl011_rx_chars(uap);\n\t\t\t}\n\t\t\tif (status & (UART011_DSRMIS|UART011_DCDMIS|\n\t\t\t\t      UART011_CTSMIS|UART011_RIMIS))\n\t\t\t\tpl011_modem_status(uap);\n\t\t\tif (status & UART011_TXIS)\n\t\t\t\tpl011_tx_chars(uap, true);\n\n\t\t\tif (pass_counter-- == 0)\n\t\t\t\tbreak;\n\n\t\t\tstatus = pl011_read(uap, REG_RIS) & uap->im;\n\t\t} while (status != 0);\n\t\thandled = 1;\n\t}\n\n\tspin_unlock_irqrestore(&uap->port.lock, flags);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic unsigned int pl011_tx_empty(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\n\t \n\tunsigned int status = pl011_read(uap, REG_FR) ^ uap->vendor->inv_fr;\n\n\treturn status & (uap->vendor->fr_busy | UART01x_FR_TXFF) ?\n\t\t\t\t\t\t\t0 : TIOCSER_TEMT;\n}\n\nstatic unsigned int pl011_get_mctrl(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\tunsigned int result = 0;\n\tunsigned int status = pl011_read(uap, REG_FR);\n\n#define TIOCMBIT(uartbit, tiocmbit)\t\\\n\tif (status & uartbit)\t\t\\\n\t\tresult |= tiocmbit\n\n\tTIOCMBIT(UART01x_FR_DCD, TIOCM_CAR);\n\tTIOCMBIT(uap->vendor->fr_dsr, TIOCM_DSR);\n\tTIOCMBIT(uap->vendor->fr_cts, TIOCM_CTS);\n\tTIOCMBIT(uap->vendor->fr_ri, TIOCM_RNG);\n#undef TIOCMBIT\n\treturn result;\n}\n\nstatic void pl011_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\tunsigned int cr;\n\n\tcr = pl011_read(uap, REG_CR);\n\n#define\tTIOCMBIT(tiocmbit, uartbit)\t\t\\\n\tif (mctrl & tiocmbit)\t\t\\\n\t\tcr |= uartbit;\t\t\\\n\telse\t\t\t\t\\\n\t\tcr &= ~uartbit\n\n\tTIOCMBIT(TIOCM_RTS, UART011_CR_RTS);\n\tTIOCMBIT(TIOCM_DTR, UART011_CR_DTR);\n\tTIOCMBIT(TIOCM_OUT1, UART011_CR_OUT1);\n\tTIOCMBIT(TIOCM_OUT2, UART011_CR_OUT2);\n\tTIOCMBIT(TIOCM_LOOP, UART011_CR_LBE);\n\n\tif (port->status & UPSTAT_AUTORTS) {\n\t\t \n\t\tTIOCMBIT(TIOCM_RTS, UART011_CR_RTSEN);\n\t}\n#undef TIOCMBIT\n\n\tpl011_write(cr, uap, REG_CR);\n}\n\nstatic void pl011_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\tunsigned long flags;\n\tunsigned int lcr_h;\n\n\tspin_lock_irqsave(&uap->port.lock, flags);\n\tlcr_h = pl011_read(uap, REG_LCRH_TX);\n\tif (break_state == -1)\n\t\tlcr_h |= UART01x_LCRH_BRK;\n\telse\n\t\tlcr_h &= ~UART01x_LCRH_BRK;\n\tpl011_write(lcr_h, uap, REG_LCRH_TX);\n\tspin_unlock_irqrestore(&uap->port.lock, flags);\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n\nstatic void pl011_quiesce_irqs(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\n\tpl011_write(pl011_read(uap, REG_MIS), uap, REG_ICR);\n\t \n\tpl011_write(pl011_read(uap, REG_IMSC) & ~UART011_TXIM, uap,\n\t\t    REG_IMSC);\n}\n\nstatic int pl011_get_poll_char(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\tunsigned int status;\n\n\t \n\tpl011_quiesce_irqs(port);\n\n\tstatus = pl011_read(uap, REG_FR);\n\tif (status & UART01x_FR_RXFE)\n\t\treturn NO_POLL_CHAR;\n\n\treturn pl011_read(uap, REG_DR);\n}\n\nstatic void pl011_put_poll_char(struct uart_port *port,\n\t\t\t unsigned char ch)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\n\twhile (pl011_read(uap, REG_FR) & UART01x_FR_TXFF)\n\t\tcpu_relax();\n\n\tpl011_write(ch, uap, REG_DR);\n}\n\n#endif  \n\nstatic int pl011_hwinit(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\tint retval;\n\n\t \n\tpinctrl_pm_select_default_state(port->dev);\n\n\t \n\tretval = clk_prepare_enable(uap->clk);\n\tif (retval)\n\t\treturn retval;\n\n\tuap->port.uartclk = clk_get_rate(uap->clk);\n\n\t \n\tpl011_write(UART011_OEIS | UART011_BEIS | UART011_PEIS |\n\t\t    UART011_FEIS | UART011_RTIS | UART011_RXIS,\n\t\t    uap, REG_ICR);\n\n\t \n\tuap->im = pl011_read(uap, REG_IMSC);\n\tpl011_write(UART011_RTIM | UART011_RXIM, uap, REG_IMSC);\n\n\tif (dev_get_platdata(uap->port.dev)) {\n\t\tstruct amba_pl011_data *plat;\n\n\t\tplat = dev_get_platdata(uap->port.dev);\n\t\tif (plat->init)\n\t\t\tplat->init();\n\t}\n\treturn 0;\n}\n\nstatic bool pl011_split_lcrh(const struct uart_amba_port *uap)\n{\n\treturn pl011_reg_to_offset(uap, REG_LCRH_RX) !=\n\t       pl011_reg_to_offset(uap, REG_LCRH_TX);\n}\n\nstatic void pl011_write_lcr_h(struct uart_amba_port *uap, unsigned int lcr_h)\n{\n\tpl011_write(lcr_h, uap, REG_LCRH_RX);\n\tif (pl011_split_lcrh(uap)) {\n\t\tint i;\n\t\t \n\t\tfor (i = 0; i < 10; ++i)\n\t\t\tpl011_write(0xff, uap, REG_MIS);\n\t\tpl011_write(lcr_h, uap, REG_LCRH_TX);\n\t}\n}\n\nstatic int pl011_allocate_irq(struct uart_amba_port *uap)\n{\n\tpl011_write(uap->im, uap, REG_IMSC);\n\n\treturn request_irq(uap->port.irq, pl011_int, IRQF_SHARED, \"uart-pl011\", uap);\n}\n\n \nstatic void pl011_enable_interrupts(struct uart_amba_port *uap)\n{\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&uap->port.lock, flags);\n\n\t \n\tpl011_write(UART011_RTIS | UART011_RXIS, uap, REG_ICR);\n\n\t \n\tfor (i = 0; i < uap->fifosize * 2; ++i) {\n\t\tif (pl011_read(uap, REG_FR) & UART01x_FR_RXFE)\n\t\t\tbreak;\n\n\t\tpl011_read(uap, REG_DR);\n\t}\n\n\tuap->im = UART011_RTIM;\n\tif (!pl011_dma_rx_running(uap))\n\t\tuap->im |= UART011_RXIM;\n\tpl011_write(uap->im, uap, REG_IMSC);\n\tspin_unlock_irqrestore(&uap->port.lock, flags);\n}\n\nstatic void pl011_unthrottle_rx(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap = container_of(port, struct uart_amba_port, port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&uap->port.lock, flags);\n\n\tuap->im = UART011_RTIM;\n\tif (!pl011_dma_rx_running(uap))\n\t\tuap->im |= UART011_RXIM;\n\n\tpl011_write(uap->im, uap, REG_IMSC);\n\n\tspin_unlock_irqrestore(&uap->port.lock, flags);\n}\n\nstatic int pl011_startup(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\tunsigned int cr;\n\tint retval;\n\n\tretval = pl011_hwinit(port);\n\tif (retval)\n\t\tgoto clk_dis;\n\n\tretval = pl011_allocate_irq(uap);\n\tif (retval)\n\t\tgoto clk_dis;\n\n\tpl011_write(uap->vendor->ifls, uap, REG_IFLS);\n\n\tspin_lock_irq(&uap->port.lock);\n\n\tcr = pl011_read(uap, REG_CR);\n\tcr &= UART011_CR_RTS | UART011_CR_DTR;\n\tcr |= UART01x_CR_UARTEN | UART011_CR_RXE;\n\n\tif (!(port->rs485.flags & SER_RS485_ENABLED))\n\t\tcr |= UART011_CR_TXE;\n\n\tpl011_write(cr, uap, REG_CR);\n\n\tspin_unlock_irq(&uap->port.lock);\n\n\t \n\tuap->old_status = pl011_read(uap, REG_FR) & UART01x_FR_MODEM_ANY;\n\n\t \n\tpl011_dma_startup(uap);\n\n\tpl011_enable_interrupts(uap);\n\n\treturn 0;\n\n clk_dis:\n\tclk_disable_unprepare(uap->clk);\n\treturn retval;\n}\n\nstatic int sbsa_uart_startup(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t\tcontainer_of(port, struct uart_amba_port, port);\n\tint retval;\n\n\tretval = pl011_hwinit(port);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = pl011_allocate_irq(uap);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tuap->old_status = 0;\n\n\tpl011_enable_interrupts(uap);\n\n\treturn 0;\n}\n\nstatic void pl011_shutdown_channel(struct uart_amba_port *uap,\n\t\t\t\t\tunsigned int lcrh)\n{\n      unsigned long val;\n\n      val = pl011_read(uap, lcrh);\n      val &= ~(UART01x_LCRH_BRK | UART01x_LCRH_FEN);\n      pl011_write(val, uap, lcrh);\n}\n\n \nstatic void pl011_disable_uart(struct uart_amba_port *uap)\n{\n\tunsigned int cr;\n\n\tuap->port.status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS);\n\tspin_lock_irq(&uap->port.lock);\n\tcr = pl011_read(uap, REG_CR);\n\tcr &= UART011_CR_RTS | UART011_CR_DTR;\n\tcr |= UART01x_CR_UARTEN | UART011_CR_TXE;\n\tpl011_write(cr, uap, REG_CR);\n\tspin_unlock_irq(&uap->port.lock);\n\n\t \n\tpl011_shutdown_channel(uap, REG_LCRH_RX);\n\tif (pl011_split_lcrh(uap))\n\t\tpl011_shutdown_channel(uap, REG_LCRH_TX);\n}\n\nstatic void pl011_disable_interrupts(struct uart_amba_port *uap)\n{\n\tspin_lock_irq(&uap->port.lock);\n\n\t \n\tuap->im = 0;\n\tpl011_write(uap->im, uap, REG_IMSC);\n\tpl011_write(0xffff, uap, REG_ICR);\n\n\tspin_unlock_irq(&uap->port.lock);\n}\n\nstatic void pl011_shutdown(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t\tcontainer_of(port, struct uart_amba_port, port);\n\n\tpl011_disable_interrupts(uap);\n\n\tpl011_dma_shutdown(uap);\n\n\tif ((port->rs485.flags & SER_RS485_ENABLED) && uap->rs485_tx_started)\n\t\tpl011_rs485_tx_stop(uap);\n\n\tfree_irq(uap->port.irq, uap);\n\n\tpl011_disable_uart(uap);\n\n\t \n\tclk_disable_unprepare(uap->clk);\n\t \n\tpinctrl_pm_select_sleep_state(port->dev);\n\n\tif (dev_get_platdata(uap->port.dev)) {\n\t\tstruct amba_pl011_data *plat;\n\n\t\tplat = dev_get_platdata(uap->port.dev);\n\t\tif (plat->exit)\n\t\t\tplat->exit();\n\t}\n\n\tif (uap->port.ops->flush_buffer)\n\t\tuap->port.ops->flush_buffer(port);\n}\n\nstatic void sbsa_uart_shutdown(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t\tcontainer_of(port, struct uart_amba_port, port);\n\n\tpl011_disable_interrupts(uap);\n\n\tfree_irq(uap->port.irq, uap);\n\n\tif (uap->port.ops->flush_buffer)\n\t\tuap->port.ops->flush_buffer(port);\n}\n\nstatic void\npl011_setup_status_masks(struct uart_port *port, struct ktermios *termios)\n{\n\tport->read_status_mask = UART011_DR_OE | 255;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= UART011_DR_FE | UART011_DR_PE;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tport->read_status_mask |= UART011_DR_BE;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= UART011_DR_FE | UART011_DR_PE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= UART011_DR_BE;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= UART011_DR_OE;\n\t}\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= UART_DUMMY_DR_RX;\n}\n\nstatic void\npl011_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t  const struct ktermios *old)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\tunsigned int lcr_h, old_cr;\n\tunsigned long flags;\n\tunsigned int baud, quot, clkdiv;\n\tunsigned int bits;\n\n\tif (uap->vendor->oversampling)\n\t\tclkdiv = 8;\n\telse\n\t\tclkdiv = 16;\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 0,\n\t\t\t\t  port->uartclk / clkdiv);\n#ifdef CONFIG_DMA_ENGINE\n\t \n\tif (uap->dmarx.auto_poll_rate)\n\t\tuap->dmarx.poll_rate = DIV_ROUND_UP(10000000, baud);\n#endif\n\n\tif (baud > port->uartclk/16)\n\t\tquot = DIV_ROUND_CLOSEST(port->uartclk * 8, baud);\n\telse\n\t\tquot = DIV_ROUND_CLOSEST(port->uartclk * 4, baud);\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tlcr_h = UART01x_LCRH_WLEN_5;\n\t\tbreak;\n\tcase CS6:\n\t\tlcr_h = UART01x_LCRH_WLEN_6;\n\t\tbreak;\n\tcase CS7:\n\t\tlcr_h = UART01x_LCRH_WLEN_7;\n\t\tbreak;\n\tdefault: \n\t\tlcr_h = UART01x_LCRH_WLEN_8;\n\t\tbreak;\n\t}\n\tif (termios->c_cflag & CSTOPB)\n\t\tlcr_h |= UART01x_LCRH_STP2;\n\tif (termios->c_cflag & PARENB) {\n\t\tlcr_h |= UART01x_LCRH_PEN;\n\t\tif (!(termios->c_cflag & PARODD))\n\t\t\tlcr_h |= UART01x_LCRH_EPS;\n\t\tif (termios->c_cflag & CMSPAR)\n\t\t\tlcr_h |= UART011_LCRH_SPS;\n\t}\n\tif (uap->fifosize > 1)\n\t\tlcr_h |= UART01x_LCRH_FEN;\n\n\tbits = tty_get_frame_size(termios->c_cflag);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tuap->rs485_tx_drain_interval = DIV_ROUND_UP(bits * 1000 * 1000, baud);\n\n\tpl011_setup_status_masks(port, termios);\n\n\tif (UART_ENABLE_MS(port, termios->c_cflag))\n\t\tpl011_enable_ms(port);\n\n\tif (port->rs485.flags & SER_RS485_ENABLED)\n\t\ttermios->c_cflag &= ~CRTSCTS;\n\n\told_cr = pl011_read(uap, REG_CR);\n\n\tif (termios->c_cflag & CRTSCTS) {\n\t\tif (old_cr & UART011_CR_RTS)\n\t\t\told_cr |= UART011_CR_RTSEN;\n\n\t\told_cr |= UART011_CR_CTSEN;\n\t\tport->status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;\n\t} else {\n\t\told_cr &= ~(UART011_CR_CTSEN | UART011_CR_RTSEN);\n\t\tport->status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS);\n\t}\n\n\tif (uap->vendor->oversampling) {\n\t\tif (baud > port->uartclk / 16)\n\t\t\told_cr |= ST_UART011_CR_OVSFACT;\n\t\telse\n\t\t\told_cr &= ~ST_UART011_CR_OVSFACT;\n\t}\n\n\t \n\tif (uap->vendor->oversampling) {\n\t\tif ((baud >= 3000000) && (baud < 3250000) && (quot > 1))\n\t\t\tquot -= 1;\n\t\telse if ((baud > 3250000) && (quot > 2))\n\t\t\tquot -= 2;\n\t}\n\t \n\tpl011_write(quot & 0x3f, uap, REG_FBRD);\n\tpl011_write(quot >> 6, uap, REG_IBRD);\n\n\t \n\tpl011_write_lcr_h(uap, lcr_h);\n\n\t \n\told_cr |= UART011_CR_RXE;\n\tpl011_write(old_cr, uap, REG_CR);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void\nsbsa_uart_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t      const struct ktermios *old)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\tunsigned long flags;\n\n\ttty_termios_encode_baud_rate(termios, uap->fixed_baud, uap->fixed_baud);\n\n\t \n\ttermios->c_cflag &= ~(CSIZE | CSTOPB | PARENB | PARODD);\n\ttermios->c_cflag &= ~(CMSPAR | CRTSCTS);\n\ttermios->c_cflag |= CS8 | CLOCAL;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tuart_update_timeout(port, CS8, uap->fixed_baud);\n\tpl011_setup_status_masks(port, termios);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *pl011_type(struct uart_port *port)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\treturn uap->port.type == PORT_AMBA ? uap->type : NULL;\n}\n\n \nstatic void pl011_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_AMBA;\n}\n\n \nstatic int pl011_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tint ret = 0;\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_AMBA)\n\t\tret = -EINVAL;\n\tif (ser->irq < 0 || ser->irq >= nr_irqs)\n\t\tret = -EINVAL;\n\tif (ser->baud_base < 9600)\n\t\tret = -EINVAL;\n\tif (port->mapbase != (unsigned long) ser->iomem_base)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\nstatic int pl011_rs485_config(struct uart_port *port, struct ktermios *termios,\n\t\t\t      struct serial_rs485 *rs485)\n{\n\tstruct uart_amba_port *uap =\n\t\tcontainer_of(port, struct uart_amba_port, port);\n\n\tif (port->rs485.flags & SER_RS485_ENABLED)\n\t\tpl011_rs485_tx_stop(uap);\n\n\t \n\tif (rs485->flags & SER_RS485_ENABLED) {\n\t\tu32 cr = pl011_read(uap, REG_CR);\n\n\t\tcr &= ~UART011_CR_RTSEN;\n\t\tpl011_write(cr, uap, REG_CR);\n\t\tport->status &= ~UPSTAT_AUTORTS;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct uart_ops amba_pl011_pops = {\n\t.tx_empty\t= pl011_tx_empty,\n\t.set_mctrl\t= pl011_set_mctrl,\n\t.get_mctrl\t= pl011_get_mctrl,\n\t.stop_tx\t= pl011_stop_tx,\n\t.start_tx\t= pl011_start_tx,\n\t.stop_rx\t= pl011_stop_rx,\n\t.throttle\t= pl011_throttle_rx,\n\t.unthrottle\t= pl011_unthrottle_rx,\n\t.enable_ms\t= pl011_enable_ms,\n\t.break_ctl\t= pl011_break_ctl,\n\t.startup\t= pl011_startup,\n\t.shutdown\t= pl011_shutdown,\n\t.flush_buffer\t= pl011_dma_flush_buffer,\n\t.set_termios\t= pl011_set_termios,\n\t.type\t\t= pl011_type,\n\t.config_port\t= pl011_config_port,\n\t.verify_port\t= pl011_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_init     = pl011_hwinit,\n\t.poll_get_char = pl011_get_poll_char,\n\t.poll_put_char = pl011_put_poll_char,\n#endif\n};\n\nstatic void sbsa_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n}\n\nstatic unsigned int sbsa_uart_get_mctrl(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic const struct uart_ops sbsa_uart_pops = {\n\t.tx_empty\t= pl011_tx_empty,\n\t.set_mctrl\t= sbsa_uart_set_mctrl,\n\t.get_mctrl\t= sbsa_uart_get_mctrl,\n\t.stop_tx\t= pl011_stop_tx,\n\t.start_tx\t= pl011_start_tx,\n\t.stop_rx\t= pl011_stop_rx,\n\t.startup\t= sbsa_uart_startup,\n\t.shutdown\t= sbsa_uart_shutdown,\n\t.set_termios\t= sbsa_uart_set_termios,\n\t.type\t\t= pl011_type,\n\t.config_port\t= pl011_config_port,\n\t.verify_port\t= pl011_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_init     = pl011_hwinit,\n\t.poll_get_char = pl011_get_poll_char,\n\t.poll_put_char = pl011_put_poll_char,\n#endif\n};\n\nstatic struct uart_amba_port *amba_ports[UART_NR];\n\n#ifdef CONFIG_SERIAL_AMBA_PL011_CONSOLE\n\nstatic void pl011_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct uart_amba_port *uap =\n\t    container_of(port, struct uart_amba_port, port);\n\n\twhile (pl011_read(uap, REG_FR) & UART01x_FR_TXFF)\n\t\tcpu_relax();\n\tpl011_write(ch, uap, REG_DR);\n}\n\nstatic void\npl011_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct uart_amba_port *uap = amba_ports[co->index];\n\tunsigned int old_cr = 0, new_cr;\n\tunsigned long flags;\n\tint locked = 1;\n\n\tclk_enable(uap->clk);\n\n\tlocal_irq_save(flags);\n\tif (uap->port.sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock(&uap->port.lock);\n\telse\n\t\tspin_lock(&uap->port.lock);\n\n\t \n\tif (!uap->vendor->always_enabled) {\n\t\told_cr = pl011_read(uap, REG_CR);\n\t\tnew_cr = old_cr & ~UART011_CR_CTSEN;\n\t\tnew_cr |= UART01x_CR_UARTEN | UART011_CR_TXE;\n\t\tpl011_write(new_cr, uap, REG_CR);\n\t}\n\n\tuart_console_write(&uap->port, s, count, pl011_console_putchar);\n\n\t \n\twhile ((pl011_read(uap, REG_FR) ^ uap->vendor->inv_fr)\n\t\t\t\t\t\t& uap->vendor->fr_busy)\n\t\tcpu_relax();\n\tif (!uap->vendor->always_enabled)\n\t\tpl011_write(old_cr, uap, REG_CR);\n\n\tif (locked)\n\t\tspin_unlock(&uap->port.lock);\n\tlocal_irq_restore(flags);\n\n\tclk_disable(uap->clk);\n}\n\nstatic void pl011_console_get_options(struct uart_amba_port *uap, int *baud,\n\t\t\t\t      int *parity, int *bits)\n{\n\tif (pl011_read(uap, REG_CR) & UART01x_CR_UARTEN) {\n\t\tunsigned int lcr_h, ibrd, fbrd;\n\n\t\tlcr_h = pl011_read(uap, REG_LCRH_TX);\n\n\t\t*parity = 'n';\n\t\tif (lcr_h & UART01x_LCRH_PEN) {\n\t\t\tif (lcr_h & UART01x_LCRH_EPS)\n\t\t\t\t*parity = 'e';\n\t\t\telse\n\t\t\t\t*parity = 'o';\n\t\t}\n\n\t\tif ((lcr_h & 0x60) == UART01x_LCRH_WLEN_7)\n\t\t\t*bits = 7;\n\t\telse\n\t\t\t*bits = 8;\n\n\t\tibrd = pl011_read(uap, REG_IBRD);\n\t\tfbrd = pl011_read(uap, REG_FBRD);\n\n\t\t*baud = uap->port.uartclk * 4 / (64 * ibrd + fbrd);\n\n\t\tif (uap->vendor->oversampling) {\n\t\t\tif (pl011_read(uap, REG_CR)\n\t\t\t\t  & ST_UART011_CR_OVSFACT)\n\t\t\t\t*baud *= 2;\n\t\t}\n\t}\n}\n\nstatic int pl011_console_setup(struct console *co, char *options)\n{\n\tstruct uart_amba_port *uap;\n\tint baud = 38400;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret;\n\n\t \n\tif (co->index >= UART_NR)\n\t\tco->index = 0;\n\tuap = amba_ports[co->index];\n\tif (!uap)\n\t\treturn -ENODEV;\n\n\t \n\tpinctrl_pm_select_default_state(uap->port.dev);\n\n\tret = clk_prepare(uap->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dev_get_platdata(uap->port.dev)) {\n\t\tstruct amba_pl011_data *plat;\n\n\t\tplat = dev_get_platdata(uap->port.dev);\n\t\tif (plat->init)\n\t\t\tplat->init();\n\t}\n\n\tuap->port.uartclk = clk_get_rate(uap->clk);\n\n\tif (uap->vendor->fixed_options) {\n\t\tbaud = uap->fixed_baud;\n\t} else {\n\t\tif (options)\n\t\t\tuart_parse_options(options,\n\t\t\t\t\t   &baud, &parity, &bits, &flow);\n\t\telse\n\t\t\tpl011_console_get_options(uap, &baud, &parity, &bits);\n\t}\n\n\treturn uart_set_options(&uap->port, co, baud, parity, bits, flow);\n}\n\n \nstatic int pl011_console_match(struct console *co, char *name, int idx,\n\t\t\t       char *options)\n{\n\tunsigned char iotype;\n\tresource_size_t addr;\n\tint i;\n\n\t \n\tif ((strcmp(name, \"qdf2400_e44\") != 0) && (strcmp(name, \"pl011\") != 0))\n\t\treturn -ENODEV;\n\n\tif (uart_parse_earlycon(options, &iotype, &addr, &options))\n\t\treturn -ENODEV;\n\n\tif (iotype != UPIO_MEM && iotype != UPIO_MEM32)\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(amba_ports); i++) {\n\t\tstruct uart_port *port;\n\n\t\tif (!amba_ports[i])\n\t\t\tcontinue;\n\n\t\tport = &amba_ports[i]->port;\n\n\t\tif (port->mapbase != addr)\n\t\t\tcontinue;\n\n\t\tco->index = i;\n\t\tport->cons = co;\n\t\treturn pl011_console_setup(co, options);\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic struct uart_driver amba_reg;\nstatic struct console amba_console = {\n\t.name\t\t= \"ttyAMA\",\n\t.write\t\t= pl011_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= pl011_console_setup,\n\t.match\t\t= pl011_console_match,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ANYTIME,\n\t.index\t\t= -1,\n\t.data\t\t= &amba_reg,\n};\n\n#define AMBA_CONSOLE\t(&amba_console)\n\nstatic void qdf2400_e44_putc(struct uart_port *port, unsigned char c)\n{\n\twhile (readl(port->membase + UART01x_FR) & UART01x_FR_TXFF)\n\t\tcpu_relax();\n\twritel(c, port->membase + UART01x_DR);\n\twhile (!(readl(port->membase + UART01x_FR) & UART011_FR_TXFE))\n\t\tcpu_relax();\n}\n\nstatic void qdf2400_e44_early_write(struct console *con, const char *s, unsigned n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, qdf2400_e44_putc);\n}\n\nstatic void pl011_putc(struct uart_port *port, unsigned char c)\n{\n\twhile (readl(port->membase + UART01x_FR) & UART01x_FR_TXFF)\n\t\tcpu_relax();\n\tif (port->iotype == UPIO_MEM32)\n\t\twritel(c, port->membase + UART01x_DR);\n\telse\n\t\twriteb(c, port->membase + UART01x_DR);\n\twhile (readl(port->membase + UART01x_FR) & UART01x_FR_BUSY)\n\t\tcpu_relax();\n}\n\nstatic void pl011_early_write(struct console *con, const char *s, unsigned n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, pl011_putc);\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int pl011_getc(struct uart_port *port)\n{\n\tif (readl(port->membase + UART01x_FR) & UART01x_FR_RXFE)\n\t\treturn NO_POLL_CHAR;\n\n\tif (port->iotype == UPIO_MEM32)\n\t\treturn readl(port->membase + UART01x_DR);\n\telse\n\t\treturn readb(port->membase + UART01x_DR);\n}\n\nstatic int pl011_early_read(struct console *con, char *s, unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\tint ch, num_read = 0;\n\n\twhile (num_read < n) {\n\t\tch = pl011_getc(&dev->port);\n\t\tif (ch == NO_POLL_CHAR)\n\t\t\tbreak;\n\n\t\ts[num_read++] = ch;\n\t}\n\n\treturn num_read;\n}\n#else\n#define pl011_early_read NULL\n#endif\n\n \nstatic int __init pl011_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t    const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = pl011_early_write;\n\tdevice->con->read = pl011_early_read;\n\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(pl011, \"arm,pl011\", pl011_early_console_setup);\nOF_EARLYCON_DECLARE(pl011, \"arm,sbsa-uart\", pl011_early_console_setup);\n\n \nstatic int __init\nqdf2400_e44_early_console_setup(struct earlycon_device *device,\n\t\t\t\tconst char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = qdf2400_e44_early_write;\n\treturn 0;\n}\nEARLYCON_DECLARE(qdf2400_e44, qdf2400_e44_early_console_setup);\n\n#else\n#define AMBA_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver amba_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"ttyAMA\",\n\t.dev_name\t\t= \"ttyAMA\",\n\t.major\t\t\t= SERIAL_AMBA_MAJOR,\n\t.minor\t\t\t= SERIAL_AMBA_MINOR,\n\t.nr\t\t\t= UART_NR,\n\t.cons\t\t\t= AMBA_CONSOLE,\n};\n\nstatic int pl011_probe_dt_alias(int index, struct device *dev)\n{\n\tstruct device_node *np;\n\tstatic bool seen_dev_with_alias = false;\n\tstatic bool seen_dev_without_alias = false;\n\tint ret = index;\n\n\tif (!IS_ENABLED(CONFIG_OF))\n\t\treturn ret;\n\n\tnp = dev->of_node;\n\tif (!np)\n\t\treturn ret;\n\n\tret = of_alias_get_id(np, \"serial\");\n\tif (ret < 0) {\n\t\tseen_dev_without_alias = true;\n\t\tret = index;\n\t} else {\n\t\tseen_dev_with_alias = true;\n\t\tif (ret >= ARRAY_SIZE(amba_ports) || amba_ports[ret] != NULL) {\n\t\t\tdev_warn(dev, \"requested serial port %d  not available.\\n\", ret);\n\t\t\tret = index;\n\t\t}\n\t}\n\n\tif (seen_dev_with_alias && seen_dev_without_alias)\n\t\tdev_warn(dev, \"aliased and non-aliased serial devices found in device tree. Serial port enumeration may be unpredictable.\\n\");\n\n\treturn ret;\n}\n\n \nstatic void pl011_unregister_port(struct uart_amba_port *uap)\n{\n\tint i;\n\tbool busy = false;\n\n\tfor (i = 0; i < ARRAY_SIZE(amba_ports); i++) {\n\t\tif (amba_ports[i] == uap)\n\t\t\tamba_ports[i] = NULL;\n\t\telse if (amba_ports[i])\n\t\t\tbusy = true;\n\t}\n\tpl011_dma_remove(uap);\n\tif (!busy)\n\t\tuart_unregister_driver(&amba_reg);\n}\n\nstatic int pl011_find_free_port(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(amba_ports); i++)\n\t\tif (amba_ports[i] == NULL)\n\t\t\treturn i;\n\n\treturn -EBUSY;\n}\n\nstatic int pl011_get_rs485_mode(struct uart_amba_port *uap)\n{\n\tstruct uart_port *port = &uap->port;\n\tint ret;\n\n\tret = uart_get_rs485_mode(port);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int pl011_setup_port(struct device *dev, struct uart_amba_port *uap,\n\t\t\t    struct resource *mmiobase, int index)\n{\n\tvoid __iomem *base;\n\tint ret;\n\n\tbase = devm_ioremap_resource(dev, mmiobase);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tindex = pl011_probe_dt_alias(index, dev);\n\n\tuap->port.dev = dev;\n\tuap->port.mapbase = mmiobase->start;\n\tuap->port.membase = base;\n\tuap->port.fifosize = uap->fifosize;\n\tuap->port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_AMBA_PL011_CONSOLE);\n\tuap->port.flags = UPF_BOOT_AUTOCONF;\n\tuap->port.line = index;\n\n\tret = pl011_get_rs485_mode(uap);\n\tif (ret)\n\t\treturn ret;\n\n\tamba_ports[index] = uap;\n\n\treturn 0;\n}\n\nstatic int pl011_register_port(struct uart_amba_port *uap)\n{\n\tint ret, i;\n\n\t \n\tpl011_write(0, uap, REG_IMSC);\n\tpl011_write(0xffff, uap, REG_ICR);\n\n\tif (!amba_reg.state) {\n\t\tret = uart_register_driver(&amba_reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(uap->port.dev,\n\t\t\t\t\"Failed to register AMBA-PL011 driver\\n\");\n\t\t\tfor (i = 0; i < ARRAY_SIZE(amba_ports); i++)\n\t\t\t\tif (amba_ports[i] == uap)\n\t\t\t\t\tamba_ports[i] = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = uart_add_one_port(&amba_reg, &uap->port);\n\tif (ret)\n\t\tpl011_unregister_port(uap);\n\n\treturn ret;\n}\n\nstatic const struct serial_rs485 pl011_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | SER_RS485_RTS_AFTER_SEND |\n\t\t SER_RS485_RX_DURING_TX,\n\t.delay_rts_before_send = 1,\n\t.delay_rts_after_send = 1,\n};\n\nstatic int pl011_probe(struct amba_device *dev, const struct amba_id *id)\n{\n\tstruct uart_amba_port *uap;\n\tstruct vendor_data *vendor = id->data;\n\tint portnr, ret;\n\tu32 val;\n\n\tportnr = pl011_find_free_port();\n\tif (portnr < 0)\n\t\treturn portnr;\n\n\tuap = devm_kzalloc(&dev->dev, sizeof(struct uart_amba_port),\n\t\t\t   GFP_KERNEL);\n\tif (!uap)\n\t\treturn -ENOMEM;\n\n\tuap->clk = devm_clk_get(&dev->dev, NULL);\n\tif (IS_ERR(uap->clk))\n\t\treturn PTR_ERR(uap->clk);\n\n\tuap->reg_offset = vendor->reg_offset;\n\tuap->vendor = vendor;\n\tuap->fifosize = vendor->get_fifosize(dev);\n\tuap->port.iotype = vendor->access_32b ? UPIO_MEM32 : UPIO_MEM;\n\tuap->port.irq = dev->irq[0];\n\tuap->port.ops = &amba_pl011_pops;\n\tuap->port.rs485_config = pl011_rs485_config;\n\tuap->port.rs485_supported = pl011_rs485_supported;\n\tsnprintf(uap->type, sizeof(uap->type), \"PL011 rev%u\", amba_rev(dev));\n\n\tif (device_property_read_u32(&dev->dev, \"reg-io-width\", &val) == 0) {\n\t\tswitch (val) {\n\t\tcase 1:\n\t\t\tuap->port.iotype = UPIO_MEM;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tuap->port.iotype = UPIO_MEM32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&dev->dev, \"unsupported reg-io-width (%d)\\n\",\n\t\t\t\t val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = pl011_setup_port(&dev->dev, uap, &dev->res, portnr);\n\tif (ret)\n\t\treturn ret;\n\n\tamba_set_drvdata(dev, uap);\n\n\treturn pl011_register_port(uap);\n}\n\nstatic void pl011_remove(struct amba_device *dev)\n{\n\tstruct uart_amba_port *uap = amba_get_drvdata(dev);\n\n\tuart_remove_one_port(&amba_reg, &uap->port);\n\tpl011_unregister_port(uap);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pl011_suspend(struct device *dev)\n{\n\tstruct uart_amba_port *uap = dev_get_drvdata(dev);\n\n\tif (!uap)\n\t\treturn -EINVAL;\n\n\treturn uart_suspend_port(&amba_reg, &uap->port);\n}\n\nstatic int pl011_resume(struct device *dev)\n{\n\tstruct uart_amba_port *uap = dev_get_drvdata(dev);\n\n\tif (!uap)\n\t\treturn -EINVAL;\n\n\treturn uart_resume_port(&amba_reg, &uap->port);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(pl011_dev_pm_ops, pl011_suspend, pl011_resume);\n\nstatic int sbsa_uart_probe(struct platform_device *pdev)\n{\n\tstruct uart_amba_port *uap;\n\tstruct resource *r;\n\tint portnr, ret;\n\tint baudrate;\n\n\t \n\tif (pdev->dev.of_node) {\n\t\tstruct device_node *np = pdev->dev.of_node;\n\n\t\tret = of_property_read_u32(np, \"current-speed\", &baudrate);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tbaudrate = 115200;\n\t}\n\n\tportnr = pl011_find_free_port();\n\tif (portnr < 0)\n\t\treturn portnr;\n\n\tuap = devm_kzalloc(&pdev->dev, sizeof(struct uart_amba_port),\n\t\t\t   GFP_KERNEL);\n\tif (!uap)\n\t\treturn -ENOMEM;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tuap->port.irq\t= ret;\n\n#ifdef CONFIG_ACPI_SPCR_TABLE\n\tif (qdf2400_e44_present) {\n\t\tdev_info(&pdev->dev, \"working around QDF2400 SoC erratum 44\\n\");\n\t\tuap->vendor = &vendor_qdt_qdf2400_e44;\n\t} else\n#endif\n\t\tuap->vendor = &vendor_sbsa;\n\n\tuap->reg_offset\t= uap->vendor->reg_offset;\n\tuap->fifosize\t= 32;\n\tuap->port.iotype = uap->vendor->access_32b ? UPIO_MEM32 : UPIO_MEM;\n\tuap->port.ops\t= &sbsa_uart_pops;\n\tuap->fixed_baud = baudrate;\n\n\tsnprintf(uap->type, sizeof(uap->type), \"SBSA\");\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tret = pl011_setup_port(&pdev->dev, uap, r, portnr);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, uap);\n\n\treturn pl011_register_port(uap);\n}\n\nstatic int sbsa_uart_remove(struct platform_device *pdev)\n{\n\tstruct uart_amba_port *uap = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&amba_reg, &uap->port);\n\tpl011_unregister_port(uap);\n\treturn 0;\n}\n\nstatic const struct of_device_id sbsa_uart_of_match[] = {\n\t{ .compatible = \"arm,sbsa-uart\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sbsa_uart_of_match);\n\nstatic const struct acpi_device_id __maybe_unused sbsa_uart_acpi_match[] = {\n\t{ \"ARMH0011\", 0 },\n\t{ \"ARMHB000\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, sbsa_uart_acpi_match);\n\nstatic struct platform_driver arm_sbsa_uart_platform_driver = {\n\t.probe\t\t= sbsa_uart_probe,\n\t.remove\t\t= sbsa_uart_remove,\n\t.driver\t= {\n\t\t.name\t= \"sbsa-uart\",\n\t\t.pm\t= &pl011_dev_pm_ops,\n\t\t.of_match_table = of_match_ptr(sbsa_uart_of_match),\n\t\t.acpi_match_table = ACPI_PTR(sbsa_uart_acpi_match),\n\t\t.suppress_bind_attrs = IS_BUILTIN(CONFIG_SERIAL_AMBA_PL011),\n\t},\n};\n\nstatic const struct amba_id pl011_ids[] = {\n\t{\n\t\t.id\t= 0x00041011,\n\t\t.mask\t= 0x000fffff,\n\t\t.data\t= &vendor_arm,\n\t},\n\t{\n\t\t.id\t= 0x00380802,\n\t\t.mask\t= 0x00ffffff,\n\t\t.data\t= &vendor_st,\n\t},\n\t{ 0, 0 },\n};\n\nMODULE_DEVICE_TABLE(amba, pl011_ids);\n\nstatic struct amba_driver pl011_driver = {\n\t.drv = {\n\t\t.name\t= \"uart-pl011\",\n\t\t.pm\t= &pl011_dev_pm_ops,\n\t\t.suppress_bind_attrs = IS_BUILTIN(CONFIG_SERIAL_AMBA_PL011),\n\t},\n\t.id_table\t= pl011_ids,\n\t.probe\t\t= pl011_probe,\n\t.remove\t\t= pl011_remove,\n};\n\nstatic int __init pl011_init(void)\n{\n\tprintk(KERN_INFO \"Serial: AMBA PL011 UART driver\\n\");\n\n\tif (platform_driver_register(&arm_sbsa_uart_platform_driver))\n\t\tpr_warn(\"could not register SBSA UART platform driver\\n\");\n\treturn amba_driver_register(&pl011_driver);\n}\n\nstatic void __exit pl011_exit(void)\n{\n\tplatform_driver_unregister(&arm_sbsa_uart_platform_driver);\n\tamba_driver_unregister(&pl011_driver);\n}\n\n \narch_initcall(pl011_init);\nmodule_exit(pl011_exit);\n\nMODULE_AUTHOR(\"ARM Ltd/Deep Blue Solutions Ltd\");\nMODULE_DESCRIPTION(\"ARM AMBA serial port driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}