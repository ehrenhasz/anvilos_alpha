{
  "module_name": "xilinx_uartps.c",
  "hash_id": "544e94d1ee763fe057c4160d149f6afafe58ab02a42b4e9794ed872364c1e606",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/xilinx_uartps.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/serial.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/clk.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/iopoll.h>\n\n#define CDNS_UART_TTY_NAME\t\"ttyPS\"\n#define CDNS_UART_NAME\t\t\"xuartps\"\n#define CDNS_UART_MAJOR\t\t0\t \n#define CDNS_UART_MINOR\t\t0\t \n#define CDNS_UART_NR_PORTS\t16\n#define CDNS_UART_FIFO_SIZE\t64\t \n#define CDNS_UART_REGISTER_SPACE\t0x1000\n#define TX_TIMEOUT\t\t500000\n\n \nstatic int rx_trigger_level = 56;\nmodule_param(rx_trigger_level, uint, 0444);\nMODULE_PARM_DESC(rx_trigger_level, \"Rx trigger level, 1-63 bytes\");\n\n \nstatic int rx_timeout = 10;\nmodule_param(rx_timeout, uint, 0444);\nMODULE_PARM_DESC(rx_timeout, \"Rx timeout, 1-255\");\n\n \n#define CDNS_UART_CR\t\t0x00   \n#define CDNS_UART_MR\t\t0x04   \n#define CDNS_UART_IER\t\t0x08   \n#define CDNS_UART_IDR\t\t0x0C   \n#define CDNS_UART_IMR\t\t0x10   \n#define CDNS_UART_ISR\t\t0x14   \n#define CDNS_UART_BAUDGEN\t0x18   \n#define CDNS_UART_RXTOUT\t0x1C   \n#define CDNS_UART_RXWM\t\t0x20   \n#define CDNS_UART_MODEMCR\t0x24   \n#define CDNS_UART_MODEMSR\t0x28   \n#define CDNS_UART_SR\t\t0x2C   \n#define CDNS_UART_FIFO\t\t0x30   \n#define CDNS_UART_BAUDDIV\t0x34   \n#define CDNS_UART_FLOWDEL\t0x38   \n#define CDNS_UART_IRRX_PWIDTH\t0x3C   \n#define CDNS_UART_IRTX_PWIDTH\t0x40   \n#define CDNS_UART_TXWM\t\t0x44   \n#define CDNS_UART_RXBS\t\t0x48   \n\n \n#define CDNS_UART_CR_STOPBRK\t0x00000100   \n#define CDNS_UART_CR_STARTBRK\t0x00000080   \n#define CDNS_UART_CR_TX_DIS\t0x00000020   \n#define CDNS_UART_CR_TX_EN\t0x00000010   \n#define CDNS_UART_CR_RX_DIS\t0x00000008   \n#define CDNS_UART_CR_RX_EN\t0x00000004   \n#define CDNS_UART_CR_TXRST\t0x00000002   \n#define CDNS_UART_CR_RXRST\t0x00000001   \n#define CDNS_UART_CR_RST_TO\t0x00000040   \n#define CDNS_UART_RXBS_PARITY    0x00000001  \n#define CDNS_UART_RXBS_FRAMING   0x00000002  \n#define CDNS_UART_RXBS_BRK       0x00000004  \n\n \n#define CDNS_UART_MR_CLKSEL\t\t0x00000001   \n#define CDNS_UART_MR_CHMODE_L_LOOP\t0x00000200   \n#define CDNS_UART_MR_CHMODE_NORM\t0x00000000   \n#define CDNS_UART_MR_CHMODE_MASK\t0x00000300   \n\n#define CDNS_UART_MR_STOPMODE_2_BIT\t0x00000080   \n#define CDNS_UART_MR_STOPMODE_1_BIT\t0x00000000   \n\n#define CDNS_UART_MR_PARITY_NONE\t0x00000020   \n#define CDNS_UART_MR_PARITY_MARK\t0x00000018   \n#define CDNS_UART_MR_PARITY_SPACE\t0x00000010   \n#define CDNS_UART_MR_PARITY_ODD\t\t0x00000008   \n#define CDNS_UART_MR_PARITY_EVEN\t0x00000000   \n\n#define CDNS_UART_MR_CHARLEN_6_BIT\t0x00000006   \n#define CDNS_UART_MR_CHARLEN_7_BIT\t0x00000004   \n#define CDNS_UART_MR_CHARLEN_8_BIT\t0x00000000   \n\n \n#define CDNS_UART_IXR_TOUT\t0x00000100  \n#define CDNS_UART_IXR_PARITY\t0x00000080  \n#define CDNS_UART_IXR_FRAMING\t0x00000040  \n#define CDNS_UART_IXR_OVERRUN\t0x00000020  \n#define CDNS_UART_IXR_TXFULL\t0x00000010  \n#define CDNS_UART_IXR_TXEMPTY\t0x00000008  \n#define CDNS_UART_ISR_RXEMPTY\t0x00000002  \n#define CDNS_UART_IXR_RXTRIG\t0x00000001  \n#define CDNS_UART_IXR_RXFULL\t0x00000004  \n#define CDNS_UART_IXR_RXEMPTY\t0x00000002  \n#define CDNS_UART_IXR_RXMASK\t0x000021e7  \n\n\t \n\n#define CDNS_UART_RX_IRQS\t(CDNS_UART_IXR_FRAMING | \\\n\t\t\t\t CDNS_UART_IXR_OVERRUN | \\\n\t\t\t\t CDNS_UART_IXR_RXTRIG |\t \\\n\t\t\t\t CDNS_UART_IXR_TOUT)\n\n \n#define CDNS_UART_IXR_BRK\t0x00002000\n\n#define CDNS_UART_RXBS_SUPPORT BIT(1)\n \n#define CDNS_UART_MODEMCR_FCM\t0x00000020  \n#define CDNS_UART_MODEMCR_RTS\t0x00000002  \n#define CDNS_UART_MODEMCR_DTR\t0x00000001  \n\n \n#define CDNS_UART_MODEMSR_DCD\tBIT(7)  \n#define CDNS_UART_MODEMSR_RI\tBIT(6)  \n#define CDNS_UART_MODEMSR_DSR\tBIT(5)  \n#define CDNS_UART_MODEMSR_CTS\tBIT(4)  \n\n \n#define CDNS_UART_SR_RXEMPTY\t0x00000002  \n#define CDNS_UART_SR_TXEMPTY\t0x00000008  \n#define CDNS_UART_SR_TXFULL\t0x00000010  \n#define CDNS_UART_SR_RXTRIG\t0x00000001  \n#define CDNS_UART_SR_TACTIVE\t0x00000800  \n\n \n#define CDNS_UART_BDIV_MIN\t4\n#define CDNS_UART_BDIV_MAX\t255\n#define CDNS_UART_CD_MAX\t65535\n#define UART_AUTOSUSPEND_TIMEOUT\t3000\n\n \nstruct cdns_uart {\n\tstruct uart_port\t*port;\n\tstruct clk\t\t*uartclk;\n\tstruct clk\t\t*pclk;\n\tstruct uart_driver\t*cdns_uart_driver;\n\tunsigned int\t\tbaud;\n\tstruct notifier_block\tclk_rate_change_nb;\n\tu32\t\t\tquirks;\n\tbool cts_override;\n};\nstruct cdns_platform_data {\n\tu32 quirks;\n};\n#define to_cdns_uart(_nb) container_of(_nb, struct cdns_uart, \\\n\t\tclk_rate_change_nb)\n\n \nstatic void cdns_uart_handle_rx(void *dev_id, unsigned int isrstatus)\n{\n\tstruct uart_port *port = (struct uart_port *)dev_id;\n\tstruct cdns_uart *cdns_uart = port->private_data;\n\tunsigned int data;\n\tunsigned int rxbs_status = 0;\n\tunsigned int status_mask;\n\tunsigned int framerrprocessed = 0;\n\tchar status = TTY_NORMAL;\n\tbool is_rxbs_support;\n\n\tis_rxbs_support = cdns_uart->quirks & CDNS_UART_RXBS_SUPPORT;\n\n\twhile ((readl(port->membase + CDNS_UART_SR) &\n\t\tCDNS_UART_SR_RXEMPTY) != CDNS_UART_SR_RXEMPTY) {\n\t\tif (is_rxbs_support)\n\t\t\trxbs_status = readl(port->membase + CDNS_UART_RXBS);\n\t\tdata = readl(port->membase + CDNS_UART_FIFO);\n\t\tport->icount.rx++;\n\t\t \n\t\tif (!is_rxbs_support && (isrstatus & CDNS_UART_IXR_FRAMING)) {\n\t\t\tif (!data) {\n\t\t\t\tport->read_status_mask |= CDNS_UART_IXR_BRK;\n\t\t\t\tframerrprocessed = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (is_rxbs_support && (rxbs_status & CDNS_UART_RXBS_BRK)) {\n\t\t\tport->icount.brk++;\n\t\t\tstatus = TTY_BREAK;\n\t\t\tif (uart_handle_break(port))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tisrstatus &= port->read_status_mask;\n\t\tisrstatus &= ~port->ignore_status_mask;\n\t\tstatus_mask = port->read_status_mask;\n\t\tstatus_mask &= ~port->ignore_status_mask;\n\n\t\tif (data &&\n\t\t    (port->read_status_mask & CDNS_UART_IXR_BRK)) {\n\t\t\tport->read_status_mask &= ~CDNS_UART_IXR_BRK;\n\t\t\tport->icount.brk++;\n\t\t\tif (uart_handle_break(port))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, data))\n\t\t\tcontinue;\n\n\t\tif (is_rxbs_support) {\n\t\t\tif ((rxbs_status & CDNS_UART_RXBS_PARITY)\n\t\t\t    && (status_mask & CDNS_UART_IXR_PARITY)) {\n\t\t\t\tport->icount.parity++;\n\t\t\t\tstatus = TTY_PARITY;\n\t\t\t}\n\t\t\tif ((rxbs_status & CDNS_UART_RXBS_FRAMING)\n\t\t\t    && (status_mask & CDNS_UART_IXR_PARITY)) {\n\t\t\t\tport->icount.frame++;\n\t\t\t\tstatus = TTY_FRAME;\n\t\t\t}\n\t\t} else {\n\t\t\tif (isrstatus & CDNS_UART_IXR_PARITY) {\n\t\t\t\tport->icount.parity++;\n\t\t\t\tstatus = TTY_PARITY;\n\t\t\t}\n\t\t\tif ((isrstatus & CDNS_UART_IXR_FRAMING) &&\n\t\t\t    !framerrprocessed) {\n\t\t\t\tport->icount.frame++;\n\t\t\t\tstatus = TTY_FRAME;\n\t\t\t}\n\t\t}\n\t\tif (isrstatus & CDNS_UART_IXR_OVERRUN) {\n\t\t\tport->icount.overrun++;\n\t\t\ttty_insert_flip_char(&port->state->port, 0,\n\t\t\t\t\t     TTY_OVERRUN);\n\t\t}\n\t\ttty_insert_flip_char(&port->state->port, data, status);\n\t\tisrstatus = 0;\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\n \nstatic void cdns_uart_handle_tx(void *dev_id)\n{\n\tstruct uart_port *port = (struct uart_port *)dev_id;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned int numbytes;\n\n\tif (uart_circ_empty(xmit)) {\n\t\twritel(CDNS_UART_IXR_TXEMPTY, port->membase + CDNS_UART_IDR);\n\t\treturn;\n\t}\n\n\tnumbytes = port->fifosize;\n\twhile (numbytes && !uart_circ_empty(xmit) &&\n\t       !(readl(port->membase + CDNS_UART_SR) & CDNS_UART_SR_TXFULL)) {\n\n\t\twritel(xmit->buf[xmit->tail], port->membase + CDNS_UART_FIFO);\n\t\tuart_xmit_advance(port, 1);\n\t\tnumbytes--;\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n}\n\n \nstatic irqreturn_t cdns_uart_isr(int irq, void *dev_id)\n{\n\tstruct uart_port *port = (struct uart_port *)dev_id;\n\tunsigned int isrstatus;\n\n\tspin_lock(&port->lock);\n\n\t \n\tisrstatus = readl(port->membase + CDNS_UART_ISR);\n\twritel(isrstatus, port->membase + CDNS_UART_ISR);\n\n\tif (isrstatus & CDNS_UART_IXR_TXEMPTY) {\n\t\tcdns_uart_handle_tx(dev_id);\n\t\tisrstatus &= ~CDNS_UART_IXR_TXEMPTY;\n\t}\n\n\tisrstatus &= port->read_status_mask;\n\tisrstatus &= ~port->ignore_status_mask;\n\t \n\tif (isrstatus & CDNS_UART_IXR_RXMASK &&\n\t    !(readl(port->membase + CDNS_UART_CR) & CDNS_UART_CR_RX_DIS))\n\t\tcdns_uart_handle_rx(dev_id, isrstatus);\n\n\tspin_unlock(&port->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic unsigned int cdns_uart_calc_baud_divs(unsigned int clk,\n\t\tunsigned int baud, u32 *rbdiv, u32 *rcd, int *div8)\n{\n\tu32 cd, bdiv;\n\tunsigned int calc_baud;\n\tunsigned int bestbaud = 0;\n\tunsigned int bauderror;\n\tunsigned int besterror = ~0;\n\n\tif (baud < clk / ((CDNS_UART_BDIV_MAX + 1) * CDNS_UART_CD_MAX)) {\n\t\t*div8 = 1;\n\t\tclk /= 8;\n\t} else {\n\t\t*div8 = 0;\n\t}\n\n\tfor (bdiv = CDNS_UART_BDIV_MIN; bdiv <= CDNS_UART_BDIV_MAX; bdiv++) {\n\t\tcd = DIV_ROUND_CLOSEST(clk, baud * (bdiv + 1));\n\t\tif (cd < 1 || cd > CDNS_UART_CD_MAX)\n\t\t\tcontinue;\n\n\t\tcalc_baud = clk / (cd * (bdiv + 1));\n\n\t\tif (baud > calc_baud)\n\t\t\tbauderror = baud - calc_baud;\n\t\telse\n\t\t\tbauderror = calc_baud - baud;\n\n\t\tif (besterror > bauderror) {\n\t\t\t*rbdiv = bdiv;\n\t\t\t*rcd = cd;\n\t\t\tbestbaud = calc_baud;\n\t\t\tbesterror = bauderror;\n\t\t}\n\t}\n\t \n\tif (((besterror * 100) / baud) < 3)\n\t\tbestbaud = baud;\n\n\treturn bestbaud;\n}\n\n \nstatic unsigned int cdns_uart_set_baud_rate(struct uart_port *port,\n\t\tunsigned int baud)\n{\n\tunsigned int calc_baud;\n\tu32 cd = 0, bdiv = 0;\n\tu32 mreg;\n\tint div8;\n\tstruct cdns_uart *cdns_uart = port->private_data;\n\n\tcalc_baud = cdns_uart_calc_baud_divs(port->uartclk, baud, &bdiv, &cd,\n\t\t\t&div8);\n\n\t \n\tmreg = readl(port->membase + CDNS_UART_MR);\n\tif (div8)\n\t\tmreg |= CDNS_UART_MR_CLKSEL;\n\telse\n\t\tmreg &= ~CDNS_UART_MR_CLKSEL;\n\twritel(mreg, port->membase + CDNS_UART_MR);\n\twritel(cd, port->membase + CDNS_UART_BAUDGEN);\n\twritel(bdiv, port->membase + CDNS_UART_BAUDDIV);\n\tcdns_uart->baud = baud;\n\n\treturn calc_baud;\n}\n\n#ifdef CONFIG_COMMON_CLK\n \nstatic int cdns_uart_clk_notifier_cb(struct notifier_block *nb,\n\t\tunsigned long event, void *data)\n{\n\tu32 ctrl_reg;\n\tstruct uart_port *port;\n\tint locked = 0;\n\tstruct clk_notifier_data *ndata = data;\n\tstruct cdns_uart *cdns_uart = to_cdns_uart(nb);\n\tunsigned long flags;\n\n\tport = cdns_uart->port;\n\tif (port->suspended)\n\t\treturn NOTIFY_OK;\n\n\tswitch (event) {\n\tcase PRE_RATE_CHANGE:\n\t{\n\t\tu32 bdiv, cd;\n\t\tint div8;\n\n\t\t \n\t\tif (!cdns_uart_calc_baud_divs(ndata->new_rate, cdns_uart->baud,\n\t\t\t\t\t&bdiv, &cd, &div8)) {\n\t\t\tdev_warn(port->dev, \"clock rate change rejected\\n\");\n\t\t\treturn NOTIFY_BAD;\n\t\t}\n\n\t\tspin_lock_irqsave(&cdns_uart->port->lock, flags);\n\n\t\t \n\t\tctrl_reg = readl(port->membase + CDNS_UART_CR);\n\t\tctrl_reg |= CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS;\n\t\twritel(ctrl_reg, port->membase + CDNS_UART_CR);\n\n\t\tspin_unlock_irqrestore(&cdns_uart->port->lock, flags);\n\n\t\treturn NOTIFY_OK;\n\t}\n\tcase POST_RATE_CHANGE:\n\t\t \n\n\t\tspin_lock_irqsave(&cdns_uart->port->lock, flags);\n\n\t\tlocked = 1;\n\t\tport->uartclk = ndata->new_rate;\n\n\t\tcdns_uart->baud = cdns_uart_set_baud_rate(cdns_uart->port,\n\t\t\t\tcdns_uart->baud);\n\t\tfallthrough;\n\tcase ABORT_RATE_CHANGE:\n\t\tif (!locked)\n\t\t\tspin_lock_irqsave(&cdns_uart->port->lock, flags);\n\n\t\t \n\t\tctrl_reg = readl(port->membase + CDNS_UART_CR);\n\t\tctrl_reg |= CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST;\n\t\twritel(ctrl_reg, port->membase + CDNS_UART_CR);\n\n\t\twhile (readl(port->membase + CDNS_UART_CR) &\n\t\t\t\t(CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST))\n\t\t\tcpu_relax();\n\n\t\t \n\t\twritel(rx_timeout, port->membase + CDNS_UART_RXTOUT);\n\t\tctrl_reg = readl(port->membase + CDNS_UART_CR);\n\t\tctrl_reg &= ~(CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS);\n\t\tctrl_reg |= CDNS_UART_CR_TX_EN | CDNS_UART_CR_RX_EN;\n\t\twritel(ctrl_reg, port->membase + CDNS_UART_CR);\n\n\t\tspin_unlock_irqrestore(&cdns_uart->port->lock, flags);\n\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n#endif\n\n \nstatic void cdns_uart_start_tx(struct uart_port *port)\n{\n\tunsigned int status;\n\n\tif (uart_tx_stopped(port))\n\t\treturn;\n\n\t \n\tstatus = readl(port->membase + CDNS_UART_CR);\n\tstatus &= ~CDNS_UART_CR_TX_DIS;\n\tstatus |= CDNS_UART_CR_TX_EN;\n\twritel(status, port->membase + CDNS_UART_CR);\n\n\tif (uart_circ_empty(&port->state->xmit))\n\t\treturn;\n\n\twritel(CDNS_UART_IXR_TXEMPTY, port->membase + CDNS_UART_ISR);\n\n\tcdns_uart_handle_tx(port);\n\n\t \n\twritel(CDNS_UART_IXR_TXEMPTY, port->membase + CDNS_UART_IER);\n}\n\n \nstatic void cdns_uart_stop_tx(struct uart_port *port)\n{\n\tunsigned int regval;\n\n\tregval = readl(port->membase + CDNS_UART_CR);\n\tregval |= CDNS_UART_CR_TX_DIS;\n\t \n\twritel(regval, port->membase + CDNS_UART_CR);\n}\n\n \nstatic void cdns_uart_stop_rx(struct uart_port *port)\n{\n\tunsigned int regval;\n\n\t \n\twritel(CDNS_UART_RX_IRQS, port->membase + CDNS_UART_IDR);\n\n\t \n\tregval = readl(port->membase + CDNS_UART_CR);\n\tregval |= CDNS_UART_CR_RX_DIS;\n\twritel(regval, port->membase + CDNS_UART_CR);\n}\n\n \nstatic unsigned int cdns_uart_tx_empty(struct uart_port *port)\n{\n\tunsigned int status;\n\n\tstatus = readl(port->membase + CDNS_UART_SR) &\n\t\t       (CDNS_UART_SR_TXEMPTY | CDNS_UART_SR_TACTIVE);\n\treturn (status == CDNS_UART_SR_TXEMPTY) ? TIOCSER_TEMT : 0;\n}\n\n \nstatic void cdns_uart_break_ctl(struct uart_port *port, int ctl)\n{\n\tunsigned int status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tstatus = readl(port->membase + CDNS_UART_CR);\n\n\tif (ctl == -1)\n\t\twritel(CDNS_UART_CR_STARTBRK | status,\n\t\t\t\tport->membase + CDNS_UART_CR);\n\telse {\n\t\tif ((status & CDNS_UART_CR_STOPBRK) == 0)\n\t\t\twritel(CDNS_UART_CR_STOPBRK | status,\n\t\t\t\t\tport->membase + CDNS_UART_CR);\n\t}\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic void cdns_uart_set_termios(struct uart_port *port,\n\t\t\t\t  struct ktermios *termios,\n\t\t\t\t  const struct ktermios *old)\n{\n\tu32 cval = 0;\n\tunsigned int baud, minbaud, maxbaud;\n\tunsigned long flags;\n\tunsigned int ctrl_reg, mode_reg;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tctrl_reg = readl(port->membase + CDNS_UART_CR);\n\tctrl_reg |= CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS;\n\twritel(ctrl_reg, port->membase + CDNS_UART_CR);\n\n\t \n\tminbaud = port->uartclk /\n\t\t\t((CDNS_UART_BDIV_MAX + 1) * CDNS_UART_CD_MAX * 8);\n\tmaxbaud = port->uartclk / (CDNS_UART_BDIV_MIN + 1);\n\tbaud = uart_get_baud_rate(port, termios, old, minbaud, maxbaud);\n\tbaud = cdns_uart_set_baud_rate(port, baud);\n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tctrl_reg = readl(port->membase + CDNS_UART_CR);\n\tctrl_reg |= CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST;\n\twritel(ctrl_reg, port->membase + CDNS_UART_CR);\n\n\twhile (readl(port->membase + CDNS_UART_CR) &\n\t\t(CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST))\n\t\tcpu_relax();\n\n\t \n\tctrl_reg = readl(port->membase + CDNS_UART_CR);\n\tctrl_reg &= ~(CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS);\n\tctrl_reg |= CDNS_UART_CR_TX_EN | CDNS_UART_CR_RX_EN;\n\twritel(ctrl_reg, port->membase + CDNS_UART_CR);\n\n\twritel(rx_timeout, port->membase + CDNS_UART_RXTOUT);\n\n\tport->read_status_mask = CDNS_UART_IXR_TXEMPTY | CDNS_UART_IXR_RXTRIG |\n\t\t\tCDNS_UART_IXR_OVERRUN | CDNS_UART_IXR_TOUT;\n\tport->ignore_status_mask = 0;\n\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= CDNS_UART_IXR_PARITY |\n\t\tCDNS_UART_IXR_FRAMING;\n\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= CDNS_UART_IXR_PARITY |\n\t\t\tCDNS_UART_IXR_FRAMING | CDNS_UART_IXR_OVERRUN;\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= CDNS_UART_IXR_RXTRIG |\n\t\t\tCDNS_UART_IXR_TOUT | CDNS_UART_IXR_PARITY |\n\t\t\tCDNS_UART_IXR_FRAMING | CDNS_UART_IXR_OVERRUN;\n\n\tmode_reg = readl(port->membase + CDNS_UART_MR);\n\n\t \n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS6:\n\t\tcval |= CDNS_UART_MR_CHARLEN_6_BIT;\n\t\tbreak;\n\tcase CS7:\n\t\tcval |= CDNS_UART_MR_CHARLEN_7_BIT;\n\t\tbreak;\n\tdefault:\n\tcase CS8:\n\t\tcval |= CDNS_UART_MR_CHARLEN_8_BIT;\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= CS8;\n\t\tbreak;\n\t}\n\n\t \n\tif (termios->c_cflag & CSTOPB)\n\t\tcval |= CDNS_UART_MR_STOPMODE_2_BIT;  \n\telse\n\t\tcval |= CDNS_UART_MR_STOPMODE_1_BIT;  \n\n\tif (termios->c_cflag & PARENB) {\n\t\t \n\t\tif (termios->c_cflag & CMSPAR) {\n\t\t\tif (termios->c_cflag & PARODD)\n\t\t\t\tcval |= CDNS_UART_MR_PARITY_MARK;\n\t\t\telse\n\t\t\t\tcval |= CDNS_UART_MR_PARITY_SPACE;\n\t\t} else {\n\t\t\tif (termios->c_cflag & PARODD)\n\t\t\t\tcval |= CDNS_UART_MR_PARITY_ODD;\n\t\t\telse\n\t\t\t\tcval |= CDNS_UART_MR_PARITY_EVEN;\n\t\t}\n\t} else {\n\t\tcval |= CDNS_UART_MR_PARITY_NONE;\n\t}\n\tcval |= mode_reg & 1;\n\twritel(cval, port->membase + CDNS_UART_MR);\n\n\tcval = readl(port->membase + CDNS_UART_MODEMCR);\n\tif (termios->c_cflag & CRTSCTS)\n\t\tcval |= CDNS_UART_MODEMCR_FCM;\n\telse\n\t\tcval &= ~CDNS_UART_MODEMCR_FCM;\n\twritel(cval, port->membase + CDNS_UART_MODEMCR);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic int cdns_uart_startup(struct uart_port *port)\n{\n\tstruct cdns_uart *cdns_uart = port->private_data;\n\tbool is_brk_support;\n\tint ret;\n\tunsigned long flags;\n\tunsigned int status = 0;\n\n\tis_brk_support = cdns_uart->quirks & CDNS_UART_RXBS_SUPPORT;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\twritel(CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS,\n\t\t\tport->membase + CDNS_UART_CR);\n\n\t \n\twritel(CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST,\n\t\t\tport->membase + CDNS_UART_CR);\n\n\twhile (readl(port->membase + CDNS_UART_CR) &\n\t\t(CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST))\n\t\tcpu_relax();\n\n\t \n\tstatus = readl(port->membase + CDNS_UART_CR);\n\tstatus &= ~CDNS_UART_CR_RX_DIS;\n\tstatus |= CDNS_UART_CR_RX_EN;\n\twritel(status, port->membase + CDNS_UART_CR);\n\n\t \n\twritel(CDNS_UART_MR_CHMODE_NORM | CDNS_UART_MR_STOPMODE_1_BIT\n\t\t| CDNS_UART_MR_PARITY_NONE | CDNS_UART_MR_CHARLEN_8_BIT,\n\t\tport->membase + CDNS_UART_MR);\n\n\t \n\twritel(rx_trigger_level, port->membase + CDNS_UART_RXWM);\n\n\t \n\twritel(rx_timeout, port->membase + CDNS_UART_RXTOUT);\n\n\t \n\twritel(readl(port->membase + CDNS_UART_ISR),\n\t\t\tport->membase + CDNS_UART_ISR);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tret = request_irq(port->irq, cdns_uart_isr, 0, CDNS_UART_NAME, port);\n\tif (ret) {\n\t\tdev_err(port->dev, \"request_irq '%d' failed with %d\\n\",\n\t\t\tport->irq, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (is_brk_support)\n\t\twritel(CDNS_UART_RX_IRQS | CDNS_UART_IXR_BRK,\n\t\t\t\t\tport->membase + CDNS_UART_IER);\n\telse\n\t\twritel(CDNS_UART_RX_IRQS, port->membase + CDNS_UART_IER);\n\n\treturn 0;\n}\n\n \nstatic void cdns_uart_shutdown(struct uart_port *port)\n{\n\tint status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tstatus = readl(port->membase + CDNS_UART_IMR);\n\twritel(status, port->membase + CDNS_UART_IDR);\n\twritel(0xffffffff, port->membase + CDNS_UART_ISR);\n\n\t \n\twritel(CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS,\n\t\t\tport->membase + CDNS_UART_CR);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tfree_irq(port->irq, port);\n}\n\n \nstatic const char *cdns_uart_type(struct uart_port *port)\n{\n\treturn port->type == PORT_XUARTPS ? CDNS_UART_NAME : NULL;\n}\n\n \nstatic int cdns_uart_verify_port(struct uart_port *port,\n\t\t\t\t\tstruct serial_struct *ser)\n{\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_XUARTPS)\n\t\treturn -EINVAL;\n\tif (port->irq != ser->irq)\n\t\treturn -EINVAL;\n\tif (ser->io_type != UPIO_MEM)\n\t\treturn -EINVAL;\n\tif (port->iobase != ser->port)\n\t\treturn -EINVAL;\n\tif (ser->hub6 != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int cdns_uart_request_port(struct uart_port *port)\n{\n\tif (!request_mem_region(port->mapbase, CDNS_UART_REGISTER_SPACE,\n\t\t\t\t\t CDNS_UART_NAME)) {\n\t\treturn -ENOMEM;\n\t}\n\n\tport->membase = ioremap(port->mapbase, CDNS_UART_REGISTER_SPACE);\n\tif (!port->membase) {\n\t\tdev_err(port->dev, \"Unable to map registers\\n\");\n\t\trelease_mem_region(port->mapbase, CDNS_UART_REGISTER_SPACE);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nstatic void cdns_uart_release_port(struct uart_port *port)\n{\n\trelease_mem_region(port->mapbase, CDNS_UART_REGISTER_SPACE);\n\tiounmap(port->membase);\n\tport->membase = NULL;\n}\n\n \nstatic void cdns_uart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE && cdns_uart_request_port(port) == 0)\n\t\tport->type = PORT_XUARTPS;\n}\n\n \nstatic unsigned int cdns_uart_get_mctrl(struct uart_port *port)\n{\n\tu32 val;\n\tunsigned int mctrl = 0;\n\tstruct cdns_uart *cdns_uart_data = port->private_data;\n\n\tif (cdns_uart_data->cts_override)\n\t\treturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\n\n\tval = readl(port->membase + CDNS_UART_MODEMSR);\n\tif (val & CDNS_UART_MODEMSR_CTS)\n\t\tmctrl |= TIOCM_CTS;\n\tif (val & CDNS_UART_MODEMSR_DSR)\n\t\tmctrl |= TIOCM_DSR;\n\tif (val & CDNS_UART_MODEMSR_RI)\n\t\tmctrl |= TIOCM_RNG;\n\tif (val & CDNS_UART_MODEMSR_DCD)\n\t\tmctrl |= TIOCM_CAR;\n\n\treturn mctrl;\n}\n\nstatic void cdns_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tu32 val;\n\tu32 mode_reg;\n\tstruct cdns_uart *cdns_uart_data = port->private_data;\n\n\tif (cdns_uart_data->cts_override)\n\t\treturn;\n\n\tval = readl(port->membase + CDNS_UART_MODEMCR);\n\tmode_reg = readl(port->membase + CDNS_UART_MR);\n\n\tval &= ~(CDNS_UART_MODEMCR_RTS | CDNS_UART_MODEMCR_DTR);\n\tmode_reg &= ~CDNS_UART_MR_CHMODE_MASK;\n\n\tif (mctrl & TIOCM_RTS)\n\t\tval |= CDNS_UART_MODEMCR_RTS;\n\tif (mctrl & TIOCM_DTR)\n\t\tval |= CDNS_UART_MODEMCR_DTR;\n\tif (mctrl & TIOCM_LOOP)\n\t\tmode_reg |= CDNS_UART_MR_CHMODE_L_LOOP;\n\telse\n\t\tmode_reg |= CDNS_UART_MR_CHMODE_NORM;\n\n\twritel(val, port->membase + CDNS_UART_MODEMCR);\n\twritel(mode_reg, port->membase + CDNS_UART_MR);\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int cdns_uart_poll_get_char(struct uart_port *port)\n{\n\tint c;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tif (readl(port->membase + CDNS_UART_SR) & CDNS_UART_SR_RXEMPTY)\n\t\tc = NO_POLL_CHAR;\n\telse  \n\t\tc = (unsigned char) readl(port->membase + CDNS_UART_FIFO);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn c;\n}\n\nstatic void cdns_uart_poll_put_char(struct uart_port *port, unsigned char c)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\twhile (!(readl(port->membase + CDNS_UART_SR) & CDNS_UART_SR_TXEMPTY))\n\t\tcpu_relax();\n\n\t \n\twritel(c, port->membase + CDNS_UART_FIFO);\n\n\t \n\twhile (!(readl(port->membase + CDNS_UART_SR) & CDNS_UART_SR_TXEMPTY))\n\t\tcpu_relax();\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n#endif\n\nstatic void cdns_uart_pm(struct uart_port *port, unsigned int state,\n\t\t   unsigned int oldstate)\n{\n\tswitch (state) {\n\tcase UART_PM_STATE_OFF:\n\t\tpm_runtime_mark_last_busy(port->dev);\n\t\tpm_runtime_put_autosuspend(port->dev);\n\t\tbreak;\n\tdefault:\n\t\tpm_runtime_get_sync(port->dev);\n\t\tbreak;\n\t}\n}\n\nstatic const struct uart_ops cdns_uart_ops = {\n\t.set_mctrl\t= cdns_uart_set_mctrl,\n\t.get_mctrl\t= cdns_uart_get_mctrl,\n\t.start_tx\t= cdns_uart_start_tx,\n\t.stop_tx\t= cdns_uart_stop_tx,\n\t.stop_rx\t= cdns_uart_stop_rx,\n\t.tx_empty\t= cdns_uart_tx_empty,\n\t.break_ctl\t= cdns_uart_break_ctl,\n\t.set_termios\t= cdns_uart_set_termios,\n\t.startup\t= cdns_uart_startup,\n\t.shutdown\t= cdns_uart_shutdown,\n\t.pm\t\t= cdns_uart_pm,\n\t.type\t\t= cdns_uart_type,\n\t.verify_port\t= cdns_uart_verify_port,\n\t.request_port\t= cdns_uart_request_port,\n\t.release_port\t= cdns_uart_release_port,\n\t.config_port\t= cdns_uart_config_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= cdns_uart_poll_get_char,\n\t.poll_put_char\t= cdns_uart_poll_put_char,\n#endif\n};\n\nstatic struct uart_driver cdns_uart_uart_driver;\n\n#ifdef CONFIG_SERIAL_XILINX_PS_UART_CONSOLE\n \nstatic void cdns_uart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tunsigned int ctrl_reg;\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\twhile (1) {\n\t\tctrl_reg = readl(port->membase + CDNS_UART_CR);\n\t\tif (!(ctrl_reg & CDNS_UART_CR_TX_DIS))\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_warn(port->dev,\n\t\t\t\t \"timeout waiting for Enable\\n\");\n\t\t\treturn;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\twhile (1) {\n\t\tctrl_reg = readl(port->membase + CDNS_UART_SR);\n\n\t\tif (!(ctrl_reg & CDNS_UART_SR_TXFULL))\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_warn(port->dev,\n\t\t\t\t \"timeout waiting for TX fifo\\n\");\n\t\t\treturn;\n\t\t}\n\t\tcpu_relax();\n\t}\n\twritel(ch, port->membase + CDNS_UART_FIFO);\n}\n\nstatic void cdns_early_write(struct console *con, const char *s,\n\t\t\t\t    unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, cdns_uart_console_putchar);\n}\n\nstatic int __init cdns_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t   const char *opt)\n{\n\tstruct uart_port *port = &device->port;\n\n\tif (!port->membase)\n\t\treturn -ENODEV;\n\n\t \n\twritel(CDNS_UART_CR_TX_EN|CDNS_UART_CR_TXRST|CDNS_UART_CR_RXRST,\n\t       port->membase + CDNS_UART_CR);\n\n\t \n\tif (port->uartclk && device->baud) {\n\t\tu32 cd = 0, bdiv = 0;\n\t\tu32 mr;\n\t\tint div8;\n\n\t\tcdns_uart_calc_baud_divs(port->uartclk, device->baud,\n\t\t\t\t\t &bdiv, &cd, &div8);\n\t\tmr = CDNS_UART_MR_PARITY_NONE;\n\t\tif (div8)\n\t\t\tmr |= CDNS_UART_MR_CLKSEL;\n\n\t\twritel(mr,   port->membase + CDNS_UART_MR);\n\t\twritel(cd,   port->membase + CDNS_UART_BAUDGEN);\n\t\twritel(bdiv, port->membase + CDNS_UART_BAUDDIV);\n\t}\n\n\tdevice->con->write = cdns_early_write;\n\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(cdns, \"xlnx,xuartps\", cdns_early_console_setup);\nOF_EARLYCON_DECLARE(cdns, \"cdns,uart-r1p8\", cdns_early_console_setup);\nOF_EARLYCON_DECLARE(cdns, \"cdns,uart-r1p12\", cdns_early_console_setup);\nOF_EARLYCON_DECLARE(cdns, \"xlnx,zynqmp-uart\", cdns_early_console_setup);\n\n\n \nstatic struct uart_port *console_port;\n\n \nstatic void cdns_uart_console_write(struct console *co, const char *s,\n\t\t\t\tunsigned int count)\n{\n\tstruct uart_port *port = console_port;\n\tunsigned long flags;\n\tunsigned int imr, ctrl;\n\tint locked = 1;\n\n\tif (port->sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&port->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\timr = readl(port->membase + CDNS_UART_IMR);\n\twritel(imr, port->membase + CDNS_UART_IDR);\n\n\t \n\tctrl = readl(port->membase + CDNS_UART_CR);\n\tctrl &= ~CDNS_UART_CR_TX_DIS;\n\tctrl |= CDNS_UART_CR_TX_EN;\n\twritel(ctrl, port->membase + CDNS_UART_CR);\n\n\tuart_console_write(port, s, count, cdns_uart_console_putchar);\n\twhile (cdns_uart_tx_empty(port) != TIOCSER_TEMT)\n\t\tcpu_relax();\n\n\t \n\twritel(imr, port->membase + CDNS_UART_IER);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic int cdns_uart_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port = console_port;\n\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tunsigned long time_out;\n\n\tif (!port->membase) {\n\t\tpr_debug(\"console on \" CDNS_UART_TTY_NAME \"%i not present\\n\",\n\t\t\t co->index);\n\t\treturn -ENODEV;\n\t}\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\t \n\ttime_out = jiffies + usecs_to_jiffies(TX_TIMEOUT);\n\n\twhile (time_before(jiffies, time_out) &&\n\t       cdns_uart_tx_empty(port) != TIOCSER_TEMT)\n\t\tcpu_relax();\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct console cdns_uart_console = {\n\t.name\t= CDNS_UART_TTY_NAME,\n\t.write\t= cdns_uart_console_write,\n\t.device\t= uart_console_device,\n\t.setup\t= cdns_uart_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,  \n\t.data\t= &cdns_uart_uart_driver,\n};\n#endif  \n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int cdns_uart_suspend(struct device *device)\n{\n\tstruct uart_port *port = dev_get_drvdata(device);\n\tstruct cdns_uart *cdns_uart = port->private_data;\n\tint may_wake;\n\n\tmay_wake = device_may_wakeup(device);\n\n\tif (console_suspend_enabled && uart_console(port) && may_wake) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\t \n\t\twhile (!(readl(port->membase + CDNS_UART_SR) &\n\t\t\t\t\tCDNS_UART_SR_RXEMPTY))\n\t\t\treadl(port->membase + CDNS_UART_FIFO);\n\t\t \n\t\twritel(1, port->membase + CDNS_UART_RXWM);\n\t\t \n\t\twritel(CDNS_UART_IXR_TOUT, port->membase + CDNS_UART_IDR);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t}\n\n\t \n\treturn uart_suspend_port(cdns_uart->cdns_uart_driver, port);\n}\n\n \nstatic int cdns_uart_resume(struct device *device)\n{\n\tstruct uart_port *port = dev_get_drvdata(device);\n\tstruct cdns_uart *cdns_uart = port->private_data;\n\tunsigned long flags;\n\tu32 ctrl_reg;\n\tint may_wake;\n\tint ret;\n\n\tmay_wake = device_may_wakeup(device);\n\n\tif (console_suspend_enabled && uart_console(port) && !may_wake) {\n\t\tret = clk_enable(cdns_uart->pclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_enable(cdns_uart->uartclk);\n\t\tif (ret) {\n\t\t\tclk_disable(cdns_uart->pclk);\n\t\t\treturn ret;\n\t\t}\n\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\t\t \n\t\tctrl_reg = readl(port->membase + CDNS_UART_CR);\n\t\tctrl_reg |= CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST;\n\t\twritel(ctrl_reg, port->membase + CDNS_UART_CR);\n\t\twhile (readl(port->membase + CDNS_UART_CR) &\n\t\t\t\t(CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST))\n\t\t\tcpu_relax();\n\n\t\t \n\t\twritel(rx_timeout, port->membase + CDNS_UART_RXTOUT);\n\t\t \n\t\tctrl_reg = readl(port->membase + CDNS_UART_CR);\n\t\tctrl_reg &= ~(CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS);\n\t\tctrl_reg |= CDNS_UART_CR_TX_EN | CDNS_UART_CR_RX_EN;\n\t\twritel(ctrl_reg, port->membase + CDNS_UART_CR);\n\n\t\tclk_disable(cdns_uart->uartclk);\n\t\tclk_disable(cdns_uart->pclk);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t} else {\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\t \n\t\twritel(rx_trigger_level, port->membase + CDNS_UART_RXWM);\n\t\t \n\t\twritel(CDNS_UART_IXR_TOUT, port->membase + CDNS_UART_IER);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t}\n\n\treturn uart_resume_port(cdns_uart->cdns_uart_driver, port);\n}\n#endif  \nstatic int __maybe_unused cdns_runtime_suspend(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct cdns_uart *cdns_uart = port->private_data;\n\n\tclk_disable(cdns_uart->uartclk);\n\tclk_disable(cdns_uart->pclk);\n\treturn 0;\n};\n\nstatic int __maybe_unused cdns_runtime_resume(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct cdns_uart *cdns_uart = port->private_data;\n\tint ret;\n\n\tret = clk_enable(cdns_uart->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_enable(cdns_uart->uartclk);\n\tif (ret) {\n\t\tclk_disable(cdns_uart->pclk);\n\t\treturn ret;\n\t}\n\treturn 0;\n};\n\nstatic const struct dev_pm_ops cdns_uart_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(cdns_uart_suspend, cdns_uart_resume)\n\tSET_RUNTIME_PM_OPS(cdns_runtime_suspend,\n\t\t\t   cdns_runtime_resume, NULL)\n};\n\nstatic const struct cdns_platform_data zynqmp_uart_def = {\n\t\t\t\t.quirks = CDNS_UART_RXBS_SUPPORT, };\n\n \nstatic const struct of_device_id cdns_uart_of_match[] = {\n\t{ .compatible = \"xlnx,xuartps\", },\n\t{ .compatible = \"cdns,uart-r1p8\", },\n\t{ .compatible = \"cdns,uart-r1p12\", .data = &zynqmp_uart_def },\n\t{ .compatible = \"xlnx,zynqmp-uart\", .data = &zynqmp_uart_def },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, cdns_uart_of_match);\n\n \nstatic int instances;\n\n \nstatic int cdns_uart_probe(struct platform_device *pdev)\n{\n\tint rc, id, irq;\n\tstruct uart_port *port;\n\tstruct resource *res;\n\tstruct cdns_uart *cdns_uart_data;\n\tconst struct of_device_id *match;\n\n\tcdns_uart_data = devm_kzalloc(&pdev->dev, sizeof(*cdns_uart_data),\n\t\t\tGFP_KERNEL);\n\tif (!cdns_uart_data)\n\t\treturn -ENOMEM;\n\tport = devm_kzalloc(&pdev->dev, sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\t \n\tid = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\tif (id < 0)\n\t\tid = 0;\n\n\tif (id >= CDNS_UART_NR_PORTS) {\n\t\tdev_err(&pdev->dev, \"Cannot get uart_port structure\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!cdns_uart_uart_driver.state) {\n\t\tcdns_uart_uart_driver.owner = THIS_MODULE;\n\t\tcdns_uart_uart_driver.driver_name = CDNS_UART_NAME;\n\t\tcdns_uart_uart_driver.dev_name = CDNS_UART_TTY_NAME;\n\t\tcdns_uart_uart_driver.major = CDNS_UART_MAJOR;\n\t\tcdns_uart_uart_driver.minor = CDNS_UART_MINOR;\n\t\tcdns_uart_uart_driver.nr = CDNS_UART_NR_PORTS;\n#ifdef CONFIG_SERIAL_XILINX_PS_UART_CONSOLE\n\t\tcdns_uart_uart_driver.cons = &cdns_uart_console;\n#endif\n\n\t\trc = uart_register_driver(&cdns_uart_uart_driver);\n\t\tif (rc < 0) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register driver\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tcdns_uart_data->cdns_uart_driver = &cdns_uart_uart_driver;\n\n\tmatch = of_match_node(cdns_uart_of_match, pdev->dev.of_node);\n\tif (match && match->data) {\n\t\tconst struct cdns_platform_data *data = match->data;\n\n\t\tcdns_uart_data->quirks = data->quirks;\n\t}\n\n\tcdns_uart_data->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (PTR_ERR(cdns_uart_data->pclk) == -EPROBE_DEFER) {\n\t\trc = PTR_ERR(cdns_uart_data->pclk);\n\t\tgoto err_out_unregister_driver;\n\t}\n\n\tif (IS_ERR(cdns_uart_data->pclk)) {\n\t\tcdns_uart_data->pclk = devm_clk_get(&pdev->dev, \"aper_clk\");\n\t\tif (IS_ERR(cdns_uart_data->pclk)) {\n\t\t\trc = PTR_ERR(cdns_uart_data->pclk);\n\t\t\tgoto err_out_unregister_driver;\n\t\t}\n\t\tdev_err(&pdev->dev, \"clock name 'aper_clk' is deprecated.\\n\");\n\t}\n\n\tcdns_uart_data->uartclk = devm_clk_get(&pdev->dev, \"uart_clk\");\n\tif (PTR_ERR(cdns_uart_data->uartclk) == -EPROBE_DEFER) {\n\t\trc = PTR_ERR(cdns_uart_data->uartclk);\n\t\tgoto err_out_unregister_driver;\n\t}\n\n\tif (IS_ERR(cdns_uart_data->uartclk)) {\n\t\tcdns_uart_data->uartclk = devm_clk_get(&pdev->dev, \"ref_clk\");\n\t\tif (IS_ERR(cdns_uart_data->uartclk)) {\n\t\t\trc = PTR_ERR(cdns_uart_data->uartclk);\n\t\t\tgoto err_out_unregister_driver;\n\t\t}\n\t\tdev_err(&pdev->dev, \"clock name 'ref_clk' is deprecated.\\n\");\n\t}\n\n\trc = clk_prepare_enable(cdns_uart_data->pclk);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Unable to enable pclk clock.\\n\");\n\t\tgoto err_out_unregister_driver;\n\t}\n\trc = clk_prepare_enable(cdns_uart_data->uartclk);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Unable to enable device clock.\\n\");\n\t\tgoto err_out_clk_dis_pclk;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\trc = -ENODEV;\n\t\tgoto err_out_clk_disable;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\trc = irq;\n\t\tgoto err_out_clk_disable;\n\t}\n\n#ifdef CONFIG_COMMON_CLK\n\tcdns_uart_data->clk_rate_change_nb.notifier_call =\n\t\t\tcdns_uart_clk_notifier_cb;\n\tif (clk_notifier_register(cdns_uart_data->uartclk,\n\t\t\t\t&cdns_uart_data->clk_rate_change_nb))\n\t\tdev_warn(&pdev->dev, \"Unable to register clock notifier.\\n\");\n#endif\n\n\t \n\tspin_lock_init(&port->lock);\n\tport->type\t= PORT_UNKNOWN;\n\tport->iotype\t= UPIO_MEM32;\n\tport->flags\t= UPF_BOOT_AUTOCONF;\n\tport->ops\t= &cdns_uart_ops;\n\tport->fifosize\t= CDNS_UART_FIFO_SIZE;\n\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_XILINX_PS_UART_CONSOLE);\n\tport->line\t= id;\n\n\t \n\tport->mapbase = res->start;\n\tport->irq = irq;\n\tport->dev = &pdev->dev;\n\tport->uartclk = clk_get_rate(cdns_uart_data->uartclk);\n\tport->private_data = cdns_uart_data;\n\tport->read_status_mask = CDNS_UART_IXR_TXEMPTY | CDNS_UART_IXR_RXTRIG |\n\t\t\tCDNS_UART_IXR_OVERRUN | CDNS_UART_IXR_TOUT;\n\tcdns_uart_data->port = port;\n\tplatform_set_drvdata(pdev, port);\n\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, UART_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tdevice_init_wakeup(port->dev, true);\n\n#ifdef CONFIG_SERIAL_XILINX_PS_UART_CONSOLE\n\t \n\tif (!console_port) {\n\t\tcdns_uart_console.index = id;\n\t\tconsole_port = port;\n\t}\n#endif\n\n\trc = uart_add_one_port(&cdns_uart_uart_driver, port);\n\tif (rc) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"uart_add_one_port() failed; err=%i\\n\", rc);\n\t\tgoto err_out_pm_disable;\n\t}\n\n#ifdef CONFIG_SERIAL_XILINX_PS_UART_CONSOLE\n\t \n\tif (console_port == port &&\n\t    !console_is_registered(cdns_uart_uart_driver.cons)) {\n\t\tconsole_port = NULL;\n\t\tcdns_uart_console.index = -1;\n\t}\n#endif\n\n\tcdns_uart_data->cts_override = of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t\t\t     \"cts-override\");\n\n\tinstances++;\n\n\treturn 0;\n\nerr_out_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n#ifdef CONFIG_COMMON_CLK\n\tclk_notifier_unregister(cdns_uart_data->uartclk,\n\t\t\t&cdns_uart_data->clk_rate_change_nb);\n#endif\nerr_out_clk_disable:\n\tclk_disable_unprepare(cdns_uart_data->uartclk);\nerr_out_clk_dis_pclk:\n\tclk_disable_unprepare(cdns_uart_data->pclk);\nerr_out_unregister_driver:\n\tif (!instances)\n\t\tuart_unregister_driver(cdns_uart_data->cdns_uart_driver);\n\treturn rc;\n}\n\n \nstatic int cdns_uart_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = platform_get_drvdata(pdev);\n\tstruct cdns_uart *cdns_uart_data = port->private_data;\n\n\t \n#ifdef CONFIG_COMMON_CLK\n\tclk_notifier_unregister(cdns_uart_data->uartclk,\n\t\t\t&cdns_uart_data->clk_rate_change_nb);\n#endif\n\tuart_remove_one_port(cdns_uart_data->cdns_uart_driver, port);\n\tport->mapbase = 0;\n\tclk_disable_unprepare(cdns_uart_data->uartclk);\n\tclk_disable_unprepare(cdns_uart_data->pclk);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tdevice_init_wakeup(&pdev->dev, false);\n\n#ifdef CONFIG_SERIAL_XILINX_PS_UART_CONSOLE\n\tif (console_port == port)\n\t\tconsole_port = NULL;\n#endif\n\n\tif (!--instances)\n\t\tuart_unregister_driver(cdns_uart_data->cdns_uart_driver);\n\treturn 0;\n}\n\nstatic struct platform_driver cdns_uart_platform_driver = {\n\t.probe   = cdns_uart_probe,\n\t.remove  = cdns_uart_remove,\n\t.driver  = {\n\t\t.name = CDNS_UART_NAME,\n\t\t.of_match_table = cdns_uart_of_match,\n\t\t.pm = &cdns_uart_dev_pm_ops,\n\t\t.suppress_bind_attrs = IS_BUILTIN(CONFIG_SERIAL_XILINX_PS_UART),\n\t\t},\n};\n\nstatic int __init cdns_uart_init(void)\n{\n\t \n\treturn platform_driver_register(&cdns_uart_platform_driver);\n}\n\nstatic void __exit cdns_uart_exit(void)\n{\n\t \n\tplatform_driver_unregister(&cdns_uart_platform_driver);\n}\n\narch_initcall(cdns_uart_init);\nmodule_exit(cdns_uart_exit);\n\nMODULE_DESCRIPTION(\"Driver for Cadence UART\");\nMODULE_AUTHOR(\"Xilinx Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}