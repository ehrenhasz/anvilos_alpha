{
  "module_name": "pic32_uart.c",
  "hash_id": "201b319a9342d1a8a9a2b1422554f601cde1b849dffcdd6e0a811e4b71a89295",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/pic32_uart.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_gpio.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/console.h>\n#include <linux/clk.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/delay.h>\n\n#include <asm/mach-pic32/pic32.h>\n\n \n#define PIC32_DEV_NAME\t\t\"pic32-uart\"\n#define PIC32_MAX_UARTS\t\t6\n#define PIC32_SDEV_NAME\t\t\"ttyPIC\"\n\n#define PIC32_UART_DFLT_BRATE\t\t9600\n#define PIC32_UART_TX_FIFO_DEPTH\t8\n#define PIC32_UART_RX_FIFO_DEPTH\t8\n\n#define PIC32_UART_MODE\t\t0x00\n#define PIC32_UART_STA\t\t0x10\n#define PIC32_UART_TX\t\t0x20\n#define PIC32_UART_RX\t\t0x30\n#define PIC32_UART_BRG\t\t0x40\n\n \nstruct pic32_sport {\n\tstruct uart_port port;\n\tint idx;\n\n\tint irq_fault;\n\tconst char *irq_fault_name;\n\tint irq_rx;\n\tconst char *irq_rx_name;\n\tint irq_tx;\n\tconst char *irq_tx_name;\n\tbool enable_tx_irq;\n\n\tstruct gpio_desc *cts_gpiod;\n\n\tstruct clk *clk;\n\n\tstruct device *dev;\n};\n\nstatic inline struct pic32_sport *to_pic32_sport(struct uart_port *port)\n{\n\treturn container_of(port, struct pic32_sport, port);\n}\n\nstatic inline void pic32_uart_writel(struct pic32_sport *sport,\n\t\t\t\t\tu32 reg, u32 val)\n{\n\t__raw_writel(val, sport->port.membase + reg);\n}\n\nstatic inline u32 pic32_uart_readl(struct pic32_sport *sport, u32 reg)\n{\n\treturn\t__raw_readl(sport->port.membase + reg);\n}\n\n \n#define PIC32_UART_MODE_ON        BIT(15)\n#define PIC32_UART_MODE_FRZ       BIT(14)\n#define PIC32_UART_MODE_SIDL      BIT(13)\n#define PIC32_UART_MODE_IREN      BIT(12)\n#define PIC32_UART_MODE_RTSMD     BIT(11)\n#define PIC32_UART_MODE_RESV1     BIT(10)\n#define PIC32_UART_MODE_UEN1      BIT(9)\n#define PIC32_UART_MODE_UEN0      BIT(8)\n#define PIC32_UART_MODE_WAKE      BIT(7)\n#define PIC32_UART_MODE_LPBK      BIT(6)\n#define PIC32_UART_MODE_ABAUD     BIT(5)\n#define PIC32_UART_MODE_RXINV     BIT(4)\n#define PIC32_UART_MODE_BRGH      BIT(3)\n#define PIC32_UART_MODE_PDSEL1    BIT(2)\n#define PIC32_UART_MODE_PDSEL0    BIT(1)\n#define PIC32_UART_MODE_STSEL     BIT(0)\n\n \n#define PIC32_UART_STA_UTXISEL1   BIT(15)\n#define PIC32_UART_STA_UTXISEL0   BIT(14)\n#define PIC32_UART_STA_UTXINV     BIT(13)\n#define PIC32_UART_STA_URXEN      BIT(12)\n#define PIC32_UART_STA_UTXBRK     BIT(11)\n#define PIC32_UART_STA_UTXEN      BIT(10)\n#define PIC32_UART_STA_UTXBF      BIT(9)\n#define PIC32_UART_STA_TRMT       BIT(8)\n#define PIC32_UART_STA_URXISEL1   BIT(7)\n#define PIC32_UART_STA_URXISEL0   BIT(6)\n#define PIC32_UART_STA_ADDEN      BIT(5)\n#define PIC32_UART_STA_RIDLE      BIT(4)\n#define PIC32_UART_STA_PERR       BIT(3)\n#define PIC32_UART_STA_FERR       BIT(2)\n#define PIC32_UART_STA_OERR       BIT(1)\n#define PIC32_UART_STA_URXDA      BIT(0)\n\n \nstatic struct pic32_sport *pic32_sports[PIC32_MAX_UARTS];\n\nstatic inline void pic32_wait_deplete_txbuf(struct pic32_sport *sport)\n{\n\t \n\twhile (!(pic32_uart_readl(sport, PIC32_UART_STA) & PIC32_UART_STA_TRMT))\n\t\tudelay(1);\n}\n\n \nstatic unsigned int pic32_uart_tx_empty(struct uart_port *port)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\tu32 val = pic32_uart_readl(sport, PIC32_UART_STA);\n\n\treturn (val & PIC32_UART_STA_TRMT) ? 1 : 0;\n}\n\n \nstatic void pic32_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\n\t \n\tif (mctrl & TIOCM_LOOP)\n\t\tpic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_LPBK);\n\telse\n\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_LPBK);\n}\n\n \nstatic unsigned int pic32_uart_get_mctrl(struct uart_port *port)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\tunsigned int mctrl = 0;\n\n\t \n\tif (!sport->cts_gpiod)\n\t\tmctrl |= TIOCM_CTS;\n\telse if (gpiod_get_value(sport->cts_gpiod))\n\t\tmctrl |= TIOCM_CTS;\n\n\t \n\tmctrl |= TIOCM_CD;\n\tmctrl |= TIOCM_DSR;\n\n\treturn mctrl;\n}\n\n \nstatic inline void pic32_uart_irqtxen(struct pic32_sport *sport, u8 en)\n{\n\tif (en && !sport->enable_tx_irq) {\n\t\tenable_irq(sport->irq_tx);\n\t\tsport->enable_tx_irq = true;\n\t} else if (!en && sport->enable_tx_irq) {\n\t\t \n\t\tdisable_irq_nosync(sport->irq_tx);\n\t\tsport->enable_tx_irq = false;\n\t}\n}\n\n \nstatic void pic32_uart_stop_tx(struct uart_port *port)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\n\tif (!(pic32_uart_readl(sport, PIC32_UART_MODE) & PIC32_UART_MODE_ON))\n\t\treturn;\n\n\tif (!(pic32_uart_readl(sport, PIC32_UART_STA) & PIC32_UART_STA_UTXEN))\n\t\treturn;\n\n\t \n\tpic32_wait_deplete_txbuf(sport);\n\n\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\n\t\t\t\tPIC32_UART_STA_UTXEN);\n\tpic32_uart_irqtxen(sport, 0);\n}\n\n \nstatic void pic32_uart_start_tx(struct uart_port *port)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\n\tpic32_uart_irqtxen(sport, 1);\n\tpic32_uart_writel(sport, PIC32_SET(PIC32_UART_STA),\n\t\t\t\tPIC32_UART_STA_UTXEN);\n}\n\n \nstatic void pic32_uart_stop_rx(struct uart_port *port)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\n\t \n\tdisable_irq(sport->irq_rx);\n\n\t \n\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\n\t\t\t\tPIC32_UART_STA_URXEN);\n}\n\n \nstatic void pic32_uart_break_ctl(struct uart_port *port, int ctl)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (ctl)\n\t\tpic32_uart_writel(sport, PIC32_SET(PIC32_UART_STA),\n\t\t\t\t\tPIC32_UART_STA_UTXBRK);\n\telse\n\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\n\t\t\t\t\tPIC32_UART_STA_UTXBRK);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic const char *pic32_uart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_PIC32) ? PIC32_DEV_NAME : NULL;\n}\n\n \nstatic void pic32_uart_do_rx(struct uart_port *port)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\tstruct tty_port *tty;\n\tunsigned int max_count;\n\n\t \n\tmax_count = PIC32_UART_RX_FIFO_DEPTH;\n\n\tspin_lock(&port->lock);\n\n\ttty = &port->state->port;\n\n\tdo {\n\t\tu32 sta_reg, c;\n\t\tchar flag;\n\n\t\t \n\t\tsta_reg = pic32_uart_readl(sport, PIC32_UART_STA);\n\t\tif (unlikely(sta_reg & PIC32_UART_STA_OERR)) {\n\n\t\t\t \n\t\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\n\t\t\t\t\t\tPIC32_UART_STA_OERR);\n\n\t\t\tport->icount.overrun++;\n\t\t\ttty_insert_flip_char(tty, 0, TTY_OVERRUN);\n\t\t}\n\n\t\t \n\t\tif (!(sta_reg & PIC32_UART_STA_URXDA))\n\t\t\tbreak;\n\n\t\t \n\t\tc = pic32_uart_readl(sport, PIC32_UART_RX);\n\n\t\tport->icount.rx++;\n\t\tflag = TTY_NORMAL;\n\t\tc &= 0xff;\n\n\t\tif (unlikely((sta_reg & PIC32_UART_STA_PERR) ||\n\t\t\t     (sta_reg & PIC32_UART_STA_FERR))) {\n\n\t\t\t \n\t\t\tif (sta_reg & PIC32_UART_STA_PERR)\n\t\t\t\tport->icount.parity++;\n\t\t\tif (sta_reg & PIC32_UART_STA_FERR)\n\t\t\t\tport->icount.frame++;\n\n\t\t\t \n\t\t\tsta_reg &= port->read_status_mask;\n\n\t\t\tif (sta_reg & PIC32_UART_STA_FERR)\n\t\t\t\tflag = TTY_FRAME;\n\t\t\tif (sta_reg & PIC32_UART_STA_PERR)\n\t\t\t\tflag = TTY_PARITY;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, c))\n\t\t\tcontinue;\n\n\t\tif ((sta_reg & port->ignore_status_mask) == 0)\n\t\t\ttty_insert_flip_char(tty, c, flag);\n\n\t} while (--max_count);\n\n\tspin_unlock(&port->lock);\n\n\ttty_flip_buffer_push(tty);\n}\n\n \nstatic void pic32_uart_do_tx(struct uart_port *port)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned int max_count = PIC32_UART_TX_FIFO_DEPTH;\n\n\tif (port->x_char) {\n\t\tpic32_uart_writel(sport, PIC32_UART_TX, port->x_char);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn;\n\t}\n\n\tif (uart_tx_stopped(port)) {\n\t\tpic32_uart_stop_tx(port);\n\t\treturn;\n\t}\n\n\tif (uart_circ_empty(xmit))\n\t\tgoto txq_empty;\n\n\t \n\twhile (!(PIC32_UART_STA_UTXBF &\n\t\tpic32_uart_readl(sport, PIC32_UART_STA))) {\n\t\tunsigned int c = xmit->buf[xmit->tail];\n\n\t\tpic32_uart_writel(sport, PIC32_UART_TX, c);\n\n\t\tuart_xmit_advance(port, 1);\n\t\tif (uart_circ_empty(xmit))\n\t\t\tbreak;\n\t\tif (--max_count == 0)\n\t\t\tbreak;\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (uart_circ_empty(xmit))\n\t\tgoto txq_empty;\n\n\treturn;\n\ntxq_empty:\n\tpic32_uart_irqtxen(sport, 0);\n}\n\n \nstatic irqreturn_t pic32_uart_rx_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\n\tpic32_uart_do_rx(port);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t pic32_uart_tx_interrupt(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tpic32_uart_do_tx(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t pic32_uart_fault_interrupt(int irq, void *dev_id)\n{\n\t \n\treturn IRQ_HANDLED;\n}\n\n \nstatic void pic32_uart_en_and_unmask(struct uart_port *port)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\n\tpic32_uart_writel(sport, PIC32_SET(PIC32_UART_STA),\n\t\t\t\tPIC32_UART_STA_UTXEN | PIC32_UART_STA_URXEN);\n\tpic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\n\t\t\t\tPIC32_UART_MODE_ON);\n}\n\n \nstatic void pic32_uart_dsbl_and_mask(struct uart_port *port)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\n\t \n\tpic32_wait_deplete_txbuf(sport);\n\n\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\n\t\t\t\tPIC32_UART_STA_UTXEN | PIC32_UART_STA_URXEN);\n\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\n\t\t\t\tPIC32_UART_MODE_ON);\n}\n\n \nstatic int pic32_uart_startup(struct uart_port *port)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\tu32 dflt_baud = (port->uartclk / PIC32_UART_DFLT_BRATE / 16) - 1;\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\n\tret = clk_prepare_enable(sport->clk);\n\tif (ret) {\n\t\tlocal_irq_restore(flags);\n\t\tgoto out_done;\n\t}\n\n\t \n\tpic32_uart_writel(sport, PIC32_UART_MODE, 0);\n\tpic32_uart_writel(sport, PIC32_UART_STA, 0);\n\n\t \n\tpic32_uart_dsbl_and_mask(port);\n\n\t \n\tpic32_uart_writel(sport, PIC32_UART_BRG, dflt_baud);\n\n\tlocal_irq_restore(flags);\n\n\t \n\tsport->enable_tx_irq = false;\n\n\tsport->irq_fault_name = kasprintf(GFP_KERNEL, \"%s%d-fault\",\n\t\t\t\t\t  pic32_uart_type(port),\n\t\t\t\t\t  sport->idx);\n\tif (!sport->irq_fault_name) {\n\t\tdev_err(port->dev, \"%s: kasprintf err!\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto out_disable_clk;\n\t}\n\tirq_set_status_flags(sport->irq_fault, IRQ_NOAUTOEN);\n\tret = request_irq(sport->irq_fault, pic32_uart_fault_interrupt,\n\t\t\t  IRQF_NO_THREAD, sport->irq_fault_name, port);\n\tif (ret) {\n\t\tdev_err(port->dev, \"%s: request irq(%d) err! ret:%d name:%s\\n\",\n\t\t\t__func__, sport->irq_fault, ret,\n\t\t\tpic32_uart_type(port));\n\t\tgoto out_f;\n\t}\n\n\tsport->irq_rx_name = kasprintf(GFP_KERNEL, \"%s%d-rx\",\n\t\t\t\t       pic32_uart_type(port),\n\t\t\t\t       sport->idx);\n\tif (!sport->irq_rx_name) {\n\t\tdev_err(port->dev, \"%s: kasprintf err!\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto out_f;\n\t}\n\tirq_set_status_flags(sport->irq_rx, IRQ_NOAUTOEN);\n\tret = request_irq(sport->irq_rx, pic32_uart_rx_interrupt,\n\t\t\t  IRQF_NO_THREAD, sport->irq_rx_name, port);\n\tif (ret) {\n\t\tdev_err(port->dev, \"%s: request irq(%d) err! ret:%d name:%s\\n\",\n\t\t\t__func__, sport->irq_rx, ret,\n\t\t\tpic32_uart_type(port));\n\t\tgoto out_r;\n\t}\n\n\tsport->irq_tx_name = kasprintf(GFP_KERNEL, \"%s%d-tx\",\n\t\t\t\t       pic32_uart_type(port),\n\t\t\t\t       sport->idx);\n\tif (!sport->irq_tx_name) {\n\t\tdev_err(port->dev, \"%s: kasprintf err!\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto out_r;\n\t}\n\tirq_set_status_flags(sport->irq_tx, IRQ_NOAUTOEN);\n\tret = request_irq(sport->irq_tx, pic32_uart_tx_interrupt,\n\t\t\t  IRQF_NO_THREAD, sport->irq_tx_name, port);\n\tif (ret) {\n\t\tdev_err(port->dev, \"%s: request irq(%d) err! ret:%d name:%s\\n\",\n\t\t\t__func__, sport->irq_tx, ret,\n\t\t\tpic32_uart_type(port));\n\t\tgoto out_t;\n\t}\n\n\tlocal_irq_save(flags);\n\n\t \n\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\n\t\t\tPIC32_UART_STA_URXISEL1 | PIC32_UART_STA_URXISEL0);\n\n\t \n\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\n\t\t\tPIC32_UART_STA_UTXISEL1);\n\n\t \n\tpic32_uart_en_and_unmask(port);\n\n\tlocal_irq_restore(flags);\n\n\tenable_irq(sport->irq_rx);\n\n\treturn 0;\n\nout_t:\n\tfree_irq(sport->irq_tx, port);\n\tkfree(sport->irq_tx_name);\nout_r:\n\tfree_irq(sport->irq_rx, port);\n\tkfree(sport->irq_rx_name);\nout_f:\n\tfree_irq(sport->irq_fault, port);\n\tkfree(sport->irq_fault_name);\nout_disable_clk:\n\tclk_disable_unprepare(sport->clk);\nout_done:\n\treturn ret;\n}\n\n \nstatic void pic32_uart_shutdown(struct uart_port *port)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tpic32_uart_dsbl_and_mask(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tclk_disable_unprepare(sport->clk);\n\n\t \n\tfree_irq(sport->irq_fault, port);\n\tkfree(sport->irq_fault_name);\n\tfree_irq(sport->irq_tx, port);\n\tkfree(sport->irq_tx_name);\n\tfree_irq(sport->irq_rx, port);\n\tkfree(sport->irq_rx_name);\n}\n\n \nstatic void pic32_uart_set_termios(struct uart_port *port,\n\t\t\t\t   struct ktermios *new,\n\t\t\t\t   const struct ktermios *old)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\tunsigned int baud;\n\tunsigned int quot;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tpic32_uart_dsbl_and_mask(port);\n\n\t \n\tif (new->c_cflag & CSTOPB)\n\t\tpic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_STSEL);\n\telse\n\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_STSEL);\n\n\t \n\tif (new->c_cflag & PARENB) {\n\t\tif (new->c_cflag & PARODD) {\n\t\t\tpic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_PDSEL1);\n\t\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_PDSEL0);\n\t\t} else {\n\t\t\tpic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_PDSEL0);\n\t\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_PDSEL1);\n\t\t}\n\t} else {\n\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_PDSEL1 |\n\t\t\t\t\tPIC32_UART_MODE_PDSEL0);\n\t}\n\t \n\tif ((new->c_cflag & CRTSCTS) && sport->cts_gpiod) {\n\t\t \n\t\tpic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_UEN1);\n\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_UEN0);\n\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_RTSMD);\n\t} else {\n\t\t \n\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_UEN1);\n\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_UEN0);\n\t\tpic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\n\t\t\t\t\tPIC32_UART_MODE_RTSMD);\n\t}\n\n\t \n\tnew->c_cflag |= CS8;\n\n\t \n\tnew->c_cflag &= ~CMSPAR;\n\n\t \n\tbaud = uart_get_baud_rate(port, new, old, 0, port->uartclk / 16);\n\tquot = uart_get_divisor(port, baud) - 1;\n\tpic32_uart_writel(sport, PIC32_UART_BRG, quot);\n\tuart_update_timeout(port, new->c_cflag, baud);\n\n\tif (tty_termios_baud_rate(new))\n\t\ttty_termios_encode_baud_rate(new, baud, baud);\n\n\t \n\tpic32_uart_en_and_unmask(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic int pic32_uart_request_port(struct uart_port *port)\n{\n\tstruct platform_device *pdev = to_platform_device(port->dev);\n\tstruct resource *res_mem;\n\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (unlikely(!res_mem))\n\t\treturn -EINVAL;\n\n\tif (!request_mem_region(port->mapbase, resource_size(res_mem),\n\t\t\t\t\"pic32_uart_mem\"))\n\t\treturn -EBUSY;\n\n\tport->membase = devm_ioremap(port->dev, port->mapbase,\n\t\t\t\t\t\tresource_size(res_mem));\n\tif (!port->membase) {\n\t\tdev_err(port->dev, \"Unable to map registers\\n\");\n\t\trelease_mem_region(port->mapbase, resource_size(res_mem));\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void pic32_uart_release_port(struct uart_port *port)\n{\n\tstruct platform_device *pdev = to_platform_device(port->dev);\n\tstruct resource *res_mem;\n\tunsigned int res_size;\n\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (unlikely(!res_mem))\n\t\treturn;\n\tres_size = resource_size(res_mem);\n\n\trelease_mem_region(port->mapbase, res_size);\n}\n\n \nstatic void pic32_uart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tif (pic32_uart_request_port(port))\n\t\t\treturn;\n\t\tport->type = PORT_PIC32;\n\t}\n}\n\n \nstatic int pic32_uart_verify_port(struct uart_port *port,\n\t\t\t\t  struct serial_struct *serinfo)\n{\n\tif (port->type != PORT_PIC32)\n\t\treturn -EINVAL;\n\tif (port->irq != serinfo->irq)\n\t\treturn -EINVAL;\n\tif (port->iotype != serinfo->io_type)\n\t\treturn -EINVAL;\n\tif (port->mapbase != (unsigned long)serinfo->iomem_base)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic const struct uart_ops pic32_uart_ops = {\n\t.tx_empty\t= pic32_uart_tx_empty,\n\t.get_mctrl\t= pic32_uart_get_mctrl,\n\t.set_mctrl\t= pic32_uart_set_mctrl,\n\t.start_tx\t= pic32_uart_start_tx,\n\t.stop_tx\t= pic32_uart_stop_tx,\n\t.stop_rx\t= pic32_uart_stop_rx,\n\t.break_ctl\t= pic32_uart_break_ctl,\n\t.startup\t= pic32_uart_startup,\n\t.shutdown\t= pic32_uart_shutdown,\n\t.set_termios\t= pic32_uart_set_termios,\n\t.type\t\t= pic32_uart_type,\n\t.release_port\t= pic32_uart_release_port,\n\t.request_port\t= pic32_uart_request_port,\n\t.config_port\t= pic32_uart_config_port,\n\t.verify_port\t= pic32_uart_verify_port,\n};\n\n#ifdef CONFIG_SERIAL_PIC32_CONSOLE\n \nstatic void pic32_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\n\tif (!(pic32_uart_readl(sport, PIC32_UART_MODE) & PIC32_UART_MODE_ON))\n\t\treturn;\n\n\tif (!(pic32_uart_readl(sport, PIC32_UART_STA) & PIC32_UART_STA_UTXEN))\n\t\treturn;\n\n\t \n\tpic32_wait_deplete_txbuf(sport);\n\n\tpic32_uart_writel(sport, PIC32_UART_TX, ch & 0xff);\n}\n\n \nstatic void pic32_console_write(struct console *co, const char *s,\n\t\t\t\tunsigned int count)\n{\n\tstruct pic32_sport *sport = pic32_sports[co->index];\n\n\t \n\tuart_console_write(&sport->port, s, count, pic32_console_putchar);\n}\n\n \nstatic int pic32_console_setup(struct console *co, char *options)\n{\n\tstruct pic32_sport *sport;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret = 0;\n\n\tif (unlikely(co->index < 0 || co->index >= PIC32_MAX_UARTS))\n\t\treturn -ENODEV;\n\n\tsport = pic32_sports[co->index];\n\tif (!sport)\n\t\treturn -ENODEV;\n\n\tret = clk_prepare_enable(sport->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&sport->port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver pic32_uart_driver;\nstatic struct console pic32_console = {\n\t.name\t\t= PIC32_SDEV_NAME,\n\t.write\t\t= pic32_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= pic32_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &pic32_uart_driver,\n};\n#define PIC32_SCONSOLE (&pic32_console)\n\nstatic int __init pic32_console_init(void)\n{\n\tregister_console(&pic32_console);\n\treturn 0;\n}\nconsole_initcall(pic32_console_init);\n\n \nstatic int __init pic32_late_console_init(void)\n{\n\tif (!console_is_registered(&pic32_console))\n\t\tregister_console(&pic32_console);\n\n\treturn 0;\n}\n\ncore_initcall(pic32_late_console_init);\n\n#else\n#define PIC32_SCONSOLE NULL\n#endif\n\nstatic struct uart_driver pic32_uart_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= PIC32_DEV_NAME,\n\t.dev_name\t\t= PIC32_SDEV_NAME,\n\t.nr\t\t\t= PIC32_MAX_UARTS,\n\t.cons\t\t\t= PIC32_SCONSOLE,\n};\n\nstatic int pic32_uart_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct pic32_sport *sport;\n\tint uart_idx = 0;\n\tstruct resource *res_mem;\n\tstruct uart_port *port;\n\tint ret;\n\n\tuart_idx = of_alias_get_id(np, \"serial\");\n\tif (uart_idx < 0 || uart_idx >= PIC32_MAX_UARTS)\n\t\treturn -EINVAL;\n\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res_mem)\n\t\treturn -EINVAL;\n\n\tsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n\tif (!sport)\n\t\treturn -ENOMEM;\n\n\tsport->idx\t\t= uart_idx;\n\tsport->irq_fault\t= irq_of_parse_and_map(np, 0);\n\tsport->irq_rx\t\t= irq_of_parse_and_map(np, 1);\n\tsport->irq_tx\t\t= irq_of_parse_and_map(np, 2);\n\tsport->clk\t\t= devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(sport->clk))\n\t\treturn PTR_ERR(sport->clk);\n\tsport->dev\t\t= &pdev->dev;\n\n\t \n\tsport->cts_gpiod = devm_gpiod_get_optional(dev, \"cts\", GPIOD_IN);\n\tif (IS_ERR(sport->cts_gpiod))\n\t\treturn dev_err_probe(dev, PTR_ERR(sport->cts_gpiod), \"error requesting CTS GPIO\\n\");\n\tgpiod_set_consumer_name(sport->cts_gpiod, \"CTS\");\n\n\tpic32_sports[uart_idx] = sport;\n\tport = &sport->port;\n\tport->iotype\t= UPIO_MEM;\n\tport->mapbase\t= res_mem->start;\n\tport->ops\t= &pic32_uart_ops;\n\tport->flags\t= UPF_BOOT_AUTOCONF;\n\tport->dev\t= &pdev->dev;\n\tport->fifosize\t= PIC32_UART_TX_FIFO_DEPTH;\n\tport->uartclk\t= clk_get_rate(sport->clk);\n\tport->line\t= uart_idx;\n\n\tret = uart_add_one_port(&pic32_uart_driver, port);\n\tif (ret) {\n\t\tport->membase = NULL;\n\t\tdev_err(port->dev, \"%s: uart add port error!\\n\", __func__);\n\t\tgoto err;\n\t}\n\n#ifdef CONFIG_SERIAL_PIC32_CONSOLE\n\tif (uart_console_registered(port)) {\n\t\t \n\t\tclk_disable_unprepare(sport->clk);\n\t}\n#endif\n\n\tplatform_set_drvdata(pdev, port);\n\n\tdev_info(&pdev->dev, \"%s: uart(%d) driver initialized.\\n\",\n\t\t __func__, uart_idx);\n\n\treturn 0;\nerr:\n\t \n\treturn ret;\n}\n\nstatic int pic32_uart_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = platform_get_drvdata(pdev);\n\tstruct pic32_sport *sport = to_pic32_sport(port);\n\n\tuart_remove_one_port(&pic32_uart_driver, port);\n\tclk_disable_unprepare(sport->clk);\n\tplatform_set_drvdata(pdev, NULL);\n\tpic32_sports[sport->idx] = NULL;\n\n\t \n\treturn 0;\n}\n\nstatic const struct of_device_id pic32_serial_dt_ids[] = {\n\t{ .compatible = \"microchip,pic32mzda-uart\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pic32_serial_dt_ids);\n\nstatic struct platform_driver pic32_uart_platform_driver = {\n\t.probe\t\t= pic32_uart_probe,\n\t.remove\t\t= pic32_uart_remove,\n\t.driver\t\t= {\n\t\t.name\t= PIC32_DEV_NAME,\n\t\t.of_match_table\t= of_match_ptr(pic32_serial_dt_ids),\n\t\t.suppress_bind_attrs = IS_BUILTIN(CONFIG_SERIAL_PIC32),\n\t},\n};\n\nstatic int __init pic32_uart_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&pic32_uart_driver);\n\tif (ret) {\n\t\tpr_err(\"failed to register %s:%d\\n\",\n\t\t       pic32_uart_driver.driver_name, ret);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&pic32_uart_platform_driver);\n\tif (ret) {\n\t\tpr_err(\"fail to register pic32 uart\\n\");\n\t\tuart_unregister_driver(&pic32_uart_driver);\n\t}\n\n\treturn ret;\n}\narch_initcall(pic32_uart_init);\n\nstatic void __exit pic32_uart_exit(void)\n{\n#ifdef CONFIG_SERIAL_PIC32_CONSOLE\n\tunregister_console(&pic32_console);\n#endif\n\tplatform_driver_unregister(&pic32_uart_platform_driver);\n\tuart_unregister_driver(&pic32_uart_driver);\n}\nmodule_exit(pic32_uart_exit);\n\nMODULE_AUTHOR(\"Sorin-Andrei Pistirica <andrei.pistirica@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip PIC32 integrated serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}