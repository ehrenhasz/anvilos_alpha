{
  "module_name": "sh-sci.c",
  "hash_id": "6894879db18a03b29abc2e4940a1cc871d338f22af24d0614cb7b1b45c97e5d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sh-sci.c",
  "human_readable_source": "\n \n#undef DEBUG\n\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/ctype.h>\n#include <linux/cpufreq.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ktime.h>\n#include <linux/major.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/scatterlist.h>\n#include <linux/serial.h>\n#include <linux/serial_sci.h>\n#include <linux/sh_dma.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/sysrq.h>\n#include <linux/timer.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#ifdef CONFIG_SUPERH\n#include <asm/sh_bios.h>\n#include <asm/platform_early.h>\n#endif\n\n#include \"serial_mctrl_gpio.h\"\n#include \"sh-sci.h\"\n\n \nenum {\n\tSCIx_ERI_IRQ,\n\tSCIx_RXI_IRQ,\n\tSCIx_TXI_IRQ,\n\tSCIx_BRI_IRQ,\n\tSCIx_DRI_IRQ,\n\tSCIx_TEI_IRQ,\n\tSCIx_NR_IRQS,\n\n\tSCIx_MUX_IRQ = SCIx_NR_IRQS,\t \n};\n\n#define SCIx_IRQ_IS_MUXED(port)\t\t\t\\\n\t((port)->irqs[SCIx_ERI_IRQ] ==\t\\\n\t (port)->irqs[SCIx_RXI_IRQ]) ||\t\\\n\t((port)->irqs[SCIx_ERI_IRQ] &&\t\\\n\t ((port)->irqs[SCIx_RXI_IRQ] < 0))\n\nenum SCI_CLKS {\n\tSCI_FCK,\t\t \n\tSCI_SCK,\t\t \n\tSCI_BRG_INT,\t\t \n\tSCI_SCIF_CLK,\t\t \n\tSCI_NUM_CLKS\n};\n\n \n#define SCI_SR(x)\t\tBIT((x) - 1)\n#define SCI_SR_RANGE(x, y)\tGENMASK((y) - 1, (x) - 1)\n\n#define SCI_SR_SCIFAB\t\tSCI_SR(5) | SCI_SR(7) | SCI_SR(11) | \\\n\t\t\t\tSCI_SR(13) | SCI_SR(16) | SCI_SR(17) | \\\n\t\t\t\tSCI_SR(19) | SCI_SR(27)\n\n#define min_sr(_port)\t\tffs((_port)->sampling_rate_mask)\n#define max_sr(_port)\t\tfls((_port)->sampling_rate_mask)\n\n \n#define for_each_sr(_sr, _port)\t\t\t\t\t\t\\\n\tfor ((_sr) = max_sr(_port); (_sr) >= min_sr(_port); (_sr)--)\t\\\n\t\tif ((_port)->sampling_rate_mask & SCI_SR((_sr)))\n\nstruct plat_sci_reg {\n\tu8 offset, size;\n};\n\nstruct sci_port_params {\n\tconst struct plat_sci_reg regs[SCIx_NR_REGS];\n\tunsigned int fifosize;\n\tunsigned int overrun_reg;\n\tunsigned int overrun_mask;\n\tunsigned int sampling_rate_mask;\n\tunsigned int error_mask;\n\tunsigned int error_clear;\n};\n\nstruct sci_port {\n\tstruct uart_port\tport;\n\n\t \n\tconst struct sci_port_params *params;\n\tconst struct plat_sci_port *cfg;\n\tunsigned int\t\tsampling_rate_mask;\n\tresource_size_t\t\treg_size;\n\tstruct mctrl_gpios\t*gpios;\n\n\t \n\tstruct clk\t\t*clks[SCI_NUM_CLKS];\n\tunsigned long\t\tclk_rates[SCI_NUM_CLKS];\n\n\tint\t\t\tirqs[SCIx_NR_IRQS];\n\tchar\t\t\t*irqstr[SCIx_NR_IRQS];\n\n\tstruct dma_chan\t\t\t*chan_tx;\n\tstruct dma_chan\t\t\t*chan_rx;\n\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\n\tstruct dma_chan\t\t\t*chan_tx_saved;\n\tstruct dma_chan\t\t\t*chan_rx_saved;\n\tdma_cookie_t\t\t\tcookie_tx;\n\tdma_cookie_t\t\t\tcookie_rx[2];\n\tdma_cookie_t\t\t\tactive_rx;\n\tdma_addr_t\t\t\ttx_dma_addr;\n\tunsigned int\t\t\ttx_dma_len;\n\tstruct scatterlist\t\tsg_rx[2];\n\tvoid\t\t\t\t*rx_buf[2];\n\tsize_t\t\t\t\tbuf_len_rx;\n\tstruct work_struct\t\twork_tx;\n\tstruct hrtimer\t\t\trx_timer;\n\tunsigned int\t\t\trx_timeout;\t \n#endif\n\tunsigned int\t\t\trx_frame;\n\tint\t\t\t\trx_trigger;\n\tstruct timer_list\t\trx_fifo_timer;\n\tint\t\t\t\trx_fifo_timeout;\n\tu16\t\t\t\thscif_tot;\n\n\tbool has_rtscts;\n\tbool autorts;\n};\n\n#define SCI_NPORTS CONFIG_SERIAL_SH_SCI_NR_UARTS\n\nstatic struct sci_port sci_ports[SCI_NPORTS];\nstatic unsigned long sci_ports_in_use;\nstatic struct uart_driver sci_uart_driver;\n\nstatic inline struct sci_port *\nto_sci_port(struct uart_port *uart)\n{\n\treturn container_of(uart, struct sci_port, port);\n}\n\nstatic const struct sci_port_params sci_port_params[SCIx_NR_REGTYPES] = {\n\t \n\t[SCIx_SCI_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00,  8 },\n\t\t\t[SCBRR]\t\t= { 0x01,  8 },\n\t\t\t[SCSCR]\t\t= { 0x02,  8 },\n\t\t\t[SCxTDR]\t= { 0x03,  8 },\n\t\t\t[SCxSR]\t\t= { 0x04,  8 },\n\t\t\t[SCxRDR]\t= { 0x05,  8 },\n\t\t},\n\t\t.fifosize = 1,\n\t\t.overrun_reg = SCxSR,\n\t\t.overrun_mask = SCI_ORER,\n\t\t.sampling_rate_mask = SCI_SR(32),\n\t\t.error_mask = SCI_DEFAULT_ERROR_MASK | SCI_ORER,\n\t\t.error_clear = SCI_ERROR_CLEAR & ~SCI_ORER,\n\t},\n\n\t \n\t[SCIx_IRDA_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00,  8 },\n\t\t\t[SCBRR]\t\t= { 0x02,  8 },\n\t\t\t[SCSCR]\t\t= { 0x04,  8 },\n\t\t\t[SCxTDR]\t= { 0x06,  8 },\n\t\t\t[SCxSR]\t\t= { 0x08, 16 },\n\t\t\t[SCxRDR]\t= { 0x0a,  8 },\n\t\t\t[SCFCR]\t\t= { 0x0c,  8 },\n\t\t\t[SCFDR]\t\t= { 0x0e, 16 },\n\t\t},\n\t\t.fifosize = 1,\n\t\t.overrun_reg = SCxSR,\n\t\t.overrun_mask = SCI_ORER,\n\t\t.sampling_rate_mask = SCI_SR(32),\n\t\t.error_mask = SCI_DEFAULT_ERROR_MASK | SCI_ORER,\n\t\t.error_clear = SCI_ERROR_CLEAR & ~SCI_ORER,\n\t},\n\n\t \n\t[SCIx_SCIFA_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00, 16 },\n\t\t\t[SCBRR]\t\t= { 0x04,  8 },\n\t\t\t[SCSCR]\t\t= { 0x08, 16 },\n\t\t\t[SCxTDR]\t= { 0x20,  8 },\n\t\t\t[SCxSR]\t\t= { 0x14, 16 },\n\t\t\t[SCxRDR]\t= { 0x24,  8 },\n\t\t\t[SCFCR]\t\t= { 0x18, 16 },\n\t\t\t[SCFDR]\t\t= { 0x1c, 16 },\n\t\t\t[SCPCR]\t\t= { 0x30, 16 },\n\t\t\t[SCPDR]\t\t= { 0x34, 16 },\n\t\t},\n\t\t.fifosize = 64,\n\t\t.overrun_reg = SCxSR,\n\t\t.overrun_mask = SCIFA_ORER,\n\t\t.sampling_rate_mask = SCI_SR_SCIFAB,\n\t\t.error_mask = SCIF_DEFAULT_ERROR_MASK | SCIFA_ORER,\n\t\t.error_clear = SCIF_ERROR_CLEAR & ~SCIFA_ORER,\n\t},\n\n\t \n\t[SCIx_SCIFB_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00, 16 },\n\t\t\t[SCBRR]\t\t= { 0x04,  8 },\n\t\t\t[SCSCR]\t\t= { 0x08, 16 },\n\t\t\t[SCxTDR]\t= { 0x40,  8 },\n\t\t\t[SCxSR]\t\t= { 0x14, 16 },\n\t\t\t[SCxRDR]\t= { 0x60,  8 },\n\t\t\t[SCFCR]\t\t= { 0x18, 16 },\n\t\t\t[SCTFDR]\t= { 0x38, 16 },\n\t\t\t[SCRFDR]\t= { 0x3c, 16 },\n\t\t\t[SCPCR]\t\t= { 0x30, 16 },\n\t\t\t[SCPDR]\t\t= { 0x34, 16 },\n\t\t},\n\t\t.fifosize = 256,\n\t\t.overrun_reg = SCxSR,\n\t\t.overrun_mask = SCIFA_ORER,\n\t\t.sampling_rate_mask = SCI_SR_SCIFAB,\n\t\t.error_mask = SCIF_DEFAULT_ERROR_MASK | SCIFA_ORER,\n\t\t.error_clear = SCIF_ERROR_CLEAR & ~SCIFA_ORER,\n\t},\n\n\t \n\t[SCIx_SH2_SCIF_FIFODATA_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00, 16 },\n\t\t\t[SCBRR]\t\t= { 0x04,  8 },\n\t\t\t[SCSCR]\t\t= { 0x08, 16 },\n\t\t\t[SCxTDR]\t= { 0x0c,  8 },\n\t\t\t[SCxSR]\t\t= { 0x10, 16 },\n\t\t\t[SCxRDR]\t= { 0x14,  8 },\n\t\t\t[SCFCR]\t\t= { 0x18, 16 },\n\t\t\t[SCFDR]\t\t= { 0x1c, 16 },\n\t\t\t[SCSPTR]\t= { 0x20, 16 },\n\t\t\t[SCLSR]\t\t= { 0x24, 16 },\n\t\t},\n\t\t.fifosize = 16,\n\t\t.overrun_reg = SCLSR,\n\t\t.overrun_mask = SCLSR_ORER,\n\t\t.sampling_rate_mask = SCI_SR(32),\n\t\t.error_mask = SCIF_DEFAULT_ERROR_MASK,\n\t\t.error_clear = SCIF_ERROR_CLEAR,\n\t},\n\n\t \n\t[SCIx_RZ_SCIFA_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00, 16 },\n\t\t\t[SCBRR]\t\t= { 0x02,  8 },\n\t\t\t[SCSCR]\t\t= { 0x04, 16 },\n\t\t\t[SCxTDR]\t= { 0x06,  8 },\n\t\t\t[SCxSR]\t\t= { 0x08, 16 },\n\t\t\t[SCxRDR]\t= { 0x0A,  8 },\n\t\t\t[SCFCR]\t\t= { 0x0C, 16 },\n\t\t\t[SCFDR]\t\t= { 0x0E, 16 },\n\t\t\t[SCSPTR]\t= { 0x10, 16 },\n\t\t\t[SCLSR]\t\t= { 0x12, 16 },\n\t\t\t[SEMR]\t\t= { 0x14, 8 },\n\t\t},\n\t\t.fifosize = 16,\n\t\t.overrun_reg = SCLSR,\n\t\t.overrun_mask = SCLSR_ORER,\n\t\t.sampling_rate_mask = SCI_SR(32),\n\t\t.error_mask = SCIF_DEFAULT_ERROR_MASK,\n\t\t.error_clear = SCIF_ERROR_CLEAR,\n\t},\n\n\t \n\t[SCIx_SH3_SCIF_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00,  8 },\n\t\t\t[SCBRR]\t\t= { 0x02,  8 },\n\t\t\t[SCSCR]\t\t= { 0x04,  8 },\n\t\t\t[SCxTDR]\t= { 0x06,  8 },\n\t\t\t[SCxSR]\t\t= { 0x08, 16 },\n\t\t\t[SCxRDR]\t= { 0x0a,  8 },\n\t\t\t[SCFCR]\t\t= { 0x0c,  8 },\n\t\t\t[SCFDR]\t\t= { 0x0e, 16 },\n\t\t},\n\t\t.fifosize = 16,\n\t\t.overrun_reg = SCLSR,\n\t\t.overrun_mask = SCLSR_ORER,\n\t\t.sampling_rate_mask = SCI_SR(32),\n\t\t.error_mask = SCIF_DEFAULT_ERROR_MASK,\n\t\t.error_clear = SCIF_ERROR_CLEAR,\n\t},\n\n\t \n\t[SCIx_SH4_SCIF_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00, 16 },\n\t\t\t[SCBRR]\t\t= { 0x04,  8 },\n\t\t\t[SCSCR]\t\t= { 0x08, 16 },\n\t\t\t[SCxTDR]\t= { 0x0c,  8 },\n\t\t\t[SCxSR]\t\t= { 0x10, 16 },\n\t\t\t[SCxRDR]\t= { 0x14,  8 },\n\t\t\t[SCFCR]\t\t= { 0x18, 16 },\n\t\t\t[SCFDR]\t\t= { 0x1c, 16 },\n\t\t\t[SCSPTR]\t= { 0x20, 16 },\n\t\t\t[SCLSR]\t\t= { 0x24, 16 },\n\t\t},\n\t\t.fifosize = 16,\n\t\t.overrun_reg = SCLSR,\n\t\t.overrun_mask = SCLSR_ORER,\n\t\t.sampling_rate_mask = SCI_SR(32),\n\t\t.error_mask = SCIF_DEFAULT_ERROR_MASK,\n\t\t.error_clear = SCIF_ERROR_CLEAR,\n\t},\n\n\t \n\t[SCIx_SH4_SCIF_BRG_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00, 16 },\n\t\t\t[SCBRR]\t\t= { 0x04,  8 },\n\t\t\t[SCSCR]\t\t= { 0x08, 16 },\n\t\t\t[SCxTDR]\t= { 0x0c,  8 },\n\t\t\t[SCxSR]\t\t= { 0x10, 16 },\n\t\t\t[SCxRDR]\t= { 0x14,  8 },\n\t\t\t[SCFCR]\t\t= { 0x18, 16 },\n\t\t\t[SCFDR]\t\t= { 0x1c, 16 },\n\t\t\t[SCSPTR]\t= { 0x20, 16 },\n\t\t\t[SCLSR]\t\t= { 0x24, 16 },\n\t\t\t[SCDL]\t\t= { 0x30, 16 },\n\t\t\t[SCCKS]\t\t= { 0x34, 16 },\n\t\t},\n\t\t.fifosize = 16,\n\t\t.overrun_reg = SCLSR,\n\t\t.overrun_mask = SCLSR_ORER,\n\t\t.sampling_rate_mask = SCI_SR(32),\n\t\t.error_mask = SCIF_DEFAULT_ERROR_MASK,\n\t\t.error_clear = SCIF_ERROR_CLEAR,\n\t},\n\n\t \n\t[SCIx_HSCIF_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00, 16 },\n\t\t\t[SCBRR]\t\t= { 0x04,  8 },\n\t\t\t[SCSCR]\t\t= { 0x08, 16 },\n\t\t\t[SCxTDR]\t= { 0x0c,  8 },\n\t\t\t[SCxSR]\t\t= { 0x10, 16 },\n\t\t\t[SCxRDR]\t= { 0x14,  8 },\n\t\t\t[SCFCR]\t\t= { 0x18, 16 },\n\t\t\t[SCFDR]\t\t= { 0x1c, 16 },\n\t\t\t[SCSPTR]\t= { 0x20, 16 },\n\t\t\t[SCLSR]\t\t= { 0x24, 16 },\n\t\t\t[HSSRR]\t\t= { 0x40, 16 },\n\t\t\t[SCDL]\t\t= { 0x30, 16 },\n\t\t\t[SCCKS]\t\t= { 0x34, 16 },\n\t\t\t[HSRTRGR]\t= { 0x54, 16 },\n\t\t\t[HSTTRGR]\t= { 0x58, 16 },\n\t\t},\n\t\t.fifosize = 128,\n\t\t.overrun_reg = SCLSR,\n\t\t.overrun_mask = SCLSR_ORER,\n\t\t.sampling_rate_mask = SCI_SR_RANGE(8, 32),\n\t\t.error_mask = SCIF_DEFAULT_ERROR_MASK,\n\t\t.error_clear = SCIF_ERROR_CLEAR,\n\t},\n\n\t \n\t[SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00, 16 },\n\t\t\t[SCBRR]\t\t= { 0x04,  8 },\n\t\t\t[SCSCR]\t\t= { 0x08, 16 },\n\t\t\t[SCxTDR]\t= { 0x0c,  8 },\n\t\t\t[SCxSR]\t\t= { 0x10, 16 },\n\t\t\t[SCxRDR]\t= { 0x14,  8 },\n\t\t\t[SCFCR]\t\t= { 0x18, 16 },\n\t\t\t[SCFDR]\t\t= { 0x1c, 16 },\n\t\t\t[SCLSR]\t\t= { 0x24, 16 },\n\t\t},\n\t\t.fifosize = 16,\n\t\t.overrun_reg = SCLSR,\n\t\t.overrun_mask = SCLSR_ORER,\n\t\t.sampling_rate_mask = SCI_SR(32),\n\t\t.error_mask = SCIF_DEFAULT_ERROR_MASK,\n\t\t.error_clear = SCIF_ERROR_CLEAR,\n\t},\n\n\t \n\t[SCIx_SH4_SCIF_FIFODATA_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00, 16 },\n\t\t\t[SCBRR]\t\t= { 0x04,  8 },\n\t\t\t[SCSCR]\t\t= { 0x08, 16 },\n\t\t\t[SCxTDR]\t= { 0x0c,  8 },\n\t\t\t[SCxSR]\t\t= { 0x10, 16 },\n\t\t\t[SCxRDR]\t= { 0x14,  8 },\n\t\t\t[SCFCR]\t\t= { 0x18, 16 },\n\t\t\t[SCFDR]\t\t= { 0x1c, 16 },\n\t\t\t[SCTFDR]\t= { 0x1c, 16 },\t \n\t\t\t[SCRFDR]\t= { 0x20, 16 },\n\t\t\t[SCSPTR]\t= { 0x24, 16 },\n\t\t\t[SCLSR]\t\t= { 0x28, 16 },\n\t\t},\n\t\t.fifosize = 16,\n\t\t.overrun_reg = SCLSR,\n\t\t.overrun_mask = SCLSR_ORER,\n\t\t.sampling_rate_mask = SCI_SR(32),\n\t\t.error_mask = SCIF_DEFAULT_ERROR_MASK,\n\t\t.error_clear = SCIF_ERROR_CLEAR,\n\t},\n\n\t \n\t[SCIx_SH7705_SCIF_REGTYPE] = {\n\t\t.regs = {\n\t\t\t[SCSMR]\t\t= { 0x00, 16 },\n\t\t\t[SCBRR]\t\t= { 0x04,  8 },\n\t\t\t[SCSCR]\t\t= { 0x08, 16 },\n\t\t\t[SCxTDR]\t= { 0x20,  8 },\n\t\t\t[SCxSR]\t\t= { 0x14, 16 },\n\t\t\t[SCxRDR]\t= { 0x24,  8 },\n\t\t\t[SCFCR]\t\t= { 0x18, 16 },\n\t\t\t[SCFDR]\t\t= { 0x1c, 16 },\n\t\t},\n\t\t.fifosize = 64,\n\t\t.overrun_reg = SCxSR,\n\t\t.overrun_mask = SCIFA_ORER,\n\t\t.sampling_rate_mask = SCI_SR(16),\n\t\t.error_mask = SCIF_DEFAULT_ERROR_MASK | SCIFA_ORER,\n\t\t.error_clear = SCIF_ERROR_CLEAR & ~SCIFA_ORER,\n\t},\n};\n\n#define sci_getreg(up, offset)\t\t(&to_sci_port(up)->params->regs[offset])\n\n \nstatic unsigned int sci_serial_in(struct uart_port *p, int offset)\n{\n\tconst struct plat_sci_reg *reg = sci_getreg(p, offset);\n\n\tif (reg->size == 8)\n\t\treturn ioread8(p->membase + (reg->offset << p->regshift));\n\telse if (reg->size == 16)\n\t\treturn ioread16(p->membase + (reg->offset << p->regshift));\n\telse\n\t\tWARN(1, \"Invalid register access\\n\");\n\n\treturn 0;\n}\n\nstatic void sci_serial_out(struct uart_port *p, int offset, int value)\n{\n\tconst struct plat_sci_reg *reg = sci_getreg(p, offset);\n\n\tif (reg->size == 8)\n\t\tiowrite8(value, p->membase + (reg->offset << p->regshift));\n\telse if (reg->size == 16)\n\t\tiowrite16(value, p->membase + (reg->offset << p->regshift));\n\telse\n\t\tWARN(1, \"Invalid register access\\n\");\n}\n\nstatic void sci_port_enable(struct sci_port *sci_port)\n{\n\tunsigned int i;\n\n\tif (!sci_port->port.dev)\n\t\treturn;\n\n\tpm_runtime_get_sync(sci_port->port.dev);\n\n\tfor (i = 0; i < SCI_NUM_CLKS; i++) {\n\t\tclk_prepare_enable(sci_port->clks[i]);\n\t\tsci_port->clk_rates[i] = clk_get_rate(sci_port->clks[i]);\n\t}\n\tsci_port->port.uartclk = sci_port->clk_rates[SCI_FCK];\n}\n\nstatic void sci_port_disable(struct sci_port *sci_port)\n{\n\tunsigned int i;\n\n\tif (!sci_port->port.dev)\n\t\treturn;\n\n\tfor (i = SCI_NUM_CLKS; i-- > 0; )\n\t\tclk_disable_unprepare(sci_port->clks[i]);\n\n\tpm_runtime_put_sync(sci_port->port.dev);\n}\n\nstatic inline unsigned long port_rx_irq_mask(struct uart_port *port)\n{\n\t \n\treturn SCSCR_RIE | (to_sci_port(port)->cfg->scscr & SCSCR_REIE);\n}\n\nstatic void sci_start_tx(struct uart_port *port)\n{\n\tstruct sci_port *s = to_sci_port(port);\n\tunsigned short ctrl;\n\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\n\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\n\t\tu16 new, scr = serial_port_in(port, SCSCR);\n\t\tif (s->chan_tx)\n\t\t\tnew = scr | SCSCR_TDRQE;\n\t\telse\n\t\t\tnew = scr & ~SCSCR_TDRQE;\n\t\tif (new != scr)\n\t\t\tserial_port_out(port, SCSCR, new);\n\t}\n\n\tif (s->chan_tx && !uart_circ_empty(&s->port.state->xmit) &&\n\t    dma_submit_error(s->cookie_tx)) {\n\t\tif (s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE)\n\t\t\t \n\t\t\tdisable_irq_nosync(s->irqs[SCIx_TXI_IRQ]);\n\n\t\ts->cookie_tx = 0;\n\t\tschedule_work(&s->work_tx);\n\t}\n#endif\n\n\tif (!s->chan_tx || s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE ||\n\t    port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\n\t\t \n\t\tctrl = serial_port_in(port, SCSCR);\n\n\t\t \n\t\tif (port->type == PORT_SCI)\n\t\t\tctrl |= SCSCR_TE;\n\n\t\tserial_port_out(port, SCSCR, ctrl | SCSCR_TIE);\n\t}\n}\n\nstatic void sci_stop_tx(struct uart_port *port)\n{\n\tunsigned short ctrl;\n\n\t \n\tctrl = serial_port_in(port, SCSCR);\n\n\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\n\t\tctrl &= ~SCSCR_TDRQE;\n\n\tctrl &= ~SCSCR_TIE;\n\n\tserial_port_out(port, SCSCR, ctrl);\n\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\n\tif (to_sci_port(port)->chan_tx &&\n\t    !dma_submit_error(to_sci_port(port)->cookie_tx)) {\n\t\tdmaengine_terminate_async(to_sci_port(port)->chan_tx);\n\t\tto_sci_port(port)->cookie_tx = -EINVAL;\n\t}\n#endif\n}\n\nstatic void sci_start_rx(struct uart_port *port)\n{\n\tunsigned short ctrl;\n\n\tctrl = serial_port_in(port, SCSCR) | port_rx_irq_mask(port);\n\n\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\n\t\tctrl &= ~SCSCR_RDRQE;\n\n\tserial_port_out(port, SCSCR, ctrl);\n}\n\nstatic void sci_stop_rx(struct uart_port *port)\n{\n\tunsigned short ctrl;\n\n\tctrl = serial_port_in(port, SCSCR);\n\n\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\n\t\tctrl &= ~SCSCR_RDRQE;\n\n\tctrl &= ~port_rx_irq_mask(port);\n\n\tserial_port_out(port, SCSCR, ctrl);\n}\n\nstatic void sci_clear_SCxSR(struct uart_port *port, unsigned int mask)\n{\n\tif (port->type == PORT_SCI) {\n\t\t \n\t\tserial_port_out(port, SCxSR, mask);\n\t} else if (to_sci_port(port)->params->overrun_mask == SCIFA_ORER) {\n\t\t \n\t\t \n\t\tserial_port_out(port, SCxSR,\n\t\t\t\tserial_port_in(port, SCxSR) & mask);\n\t} else {\n\t\t \n\t\tserial_port_out(port, SCxSR, mask & ~(SCIF_FERC | SCIF_PERC));\n\t}\n}\n\n#if defined(CONFIG_CONSOLE_POLL) || defined(CONFIG_SERIAL_SH_SCI_CONSOLE) || \\\n    defined(CONFIG_SERIAL_SH_SCI_EARLYCON)\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int sci_poll_get_char(struct uart_port *port)\n{\n\tunsigned short status;\n\tint c;\n\n\tdo {\n\t\tstatus = serial_port_in(port, SCxSR);\n\t\tif (status & SCxSR_ERRORS(port)) {\n\t\t\tsci_clear_SCxSR(port, SCxSR_ERROR_CLEAR(port));\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (1);\n\n\tif (!(status & SCxSR_RDxF(port)))\n\t\treturn NO_POLL_CHAR;\n\n\tc = serial_port_in(port, SCxRDR);\n\n\t \n\tserial_port_in(port, SCxSR);\n\tsci_clear_SCxSR(port, SCxSR_RDxF_CLEAR(port));\n\n\treturn c;\n}\n#endif\n\nstatic void sci_poll_put_char(struct uart_port *port, unsigned char c)\n{\n\tunsigned short status;\n\n\tdo {\n\t\tstatus = serial_port_in(port, SCxSR);\n\t} while (!(status & SCxSR_TDxE(port)));\n\n\tserial_port_out(port, SCxTDR, c);\n\tsci_clear_SCxSR(port, SCxSR_TDxE_CLEAR(port) & ~SCxSR_TEND(port));\n}\n#endif  \n\nstatic void sci_init_pins(struct uart_port *port, unsigned int cflag)\n{\n\tstruct sci_port *s = to_sci_port(port);\n\n\t \n\tif (s->cfg->ops && s->cfg->ops->init_pins) {\n\t\ts->cfg->ops->init_pins(port, cflag);\n\t\treturn;\n\t}\n\n\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\n\t\tu16 data = serial_port_in(port, SCPDR);\n\t\tu16 ctrl = serial_port_in(port, SCPCR);\n\n\t\t \n\t\tctrl &= ~(SCPCR_RXDC | SCPCR_TXDC);\n\t\tif (to_sci_port(port)->has_rtscts) {\n\t\t\t \n\t\t\tif (!(port->mctrl & TIOCM_RTS)) {\n\t\t\t\tctrl |= SCPCR_RTSC;\n\t\t\t\tdata |= SCPDR_RTSD;\n\t\t\t} else if (!s->autorts) {\n\t\t\t\tctrl |= SCPCR_RTSC;\n\t\t\t\tdata &= ~SCPDR_RTSD;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tctrl &= ~SCPCR_RTSC;\n\t\t\t}\n\t\t\t \n\t\t\tctrl &= ~SCPCR_CTSC;\n\t\t}\n\t\tserial_port_out(port, SCPDR, data);\n\t\tserial_port_out(port, SCPCR, ctrl);\n\t} else if (sci_getreg(port, SCSPTR)->size) {\n\t\tu16 status = serial_port_in(port, SCSPTR);\n\n\t\t \n\t\tstatus |= SCSPTR_RTSIO;\n\t\tif (!(port->mctrl & TIOCM_RTS))\n\t\t\tstatus |= SCSPTR_RTSDT;\n\t\telse if (!s->autorts)\n\t\t\tstatus &= ~SCSPTR_RTSDT;\n\t\t \n\t\tstatus &= ~(SCSPTR_CTSIO | SCSPTR_SCKIO);\n\t\tserial_port_out(port, SCSPTR, status);\n\t}\n}\n\nstatic int sci_txfill(struct uart_port *port)\n{\n\tstruct sci_port *s = to_sci_port(port);\n\tunsigned int fifo_mask = (s->params->fifosize << 1) - 1;\n\tconst struct plat_sci_reg *reg;\n\n\treg = sci_getreg(port, SCTFDR);\n\tif (reg->size)\n\t\treturn serial_port_in(port, SCTFDR) & fifo_mask;\n\n\treg = sci_getreg(port, SCFDR);\n\tif (reg->size)\n\t\treturn serial_port_in(port, SCFDR) >> 8;\n\n\treturn !(serial_port_in(port, SCxSR) & SCI_TDRE);\n}\n\nstatic int sci_txroom(struct uart_port *port)\n{\n\treturn port->fifosize - sci_txfill(port);\n}\n\nstatic int sci_rxfill(struct uart_port *port)\n{\n\tstruct sci_port *s = to_sci_port(port);\n\tunsigned int fifo_mask = (s->params->fifosize << 1) - 1;\n\tconst struct plat_sci_reg *reg;\n\n\treg = sci_getreg(port, SCRFDR);\n\tif (reg->size)\n\t\treturn serial_port_in(port, SCRFDR) & fifo_mask;\n\n\treg = sci_getreg(port, SCFDR);\n\tif (reg->size)\n\t\treturn serial_port_in(port, SCFDR) & fifo_mask;\n\n\treturn (serial_port_in(port, SCxSR) & SCxSR_RDxF(port)) != 0;\n}\n\n \n\nstatic void sci_transmit_chars(struct uart_port *port)\n{\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned int stopped = uart_tx_stopped(port);\n\tunsigned short status;\n\tunsigned short ctrl;\n\tint count;\n\n\tstatus = serial_port_in(port, SCxSR);\n\tif (!(status & SCxSR_TDxE(port))) {\n\t\tctrl = serial_port_in(port, SCSCR);\n\t\tif (uart_circ_empty(xmit))\n\t\t\tctrl &= ~SCSCR_TIE;\n\t\telse\n\t\t\tctrl |= SCSCR_TIE;\n\t\tserial_port_out(port, SCSCR, ctrl);\n\t\treturn;\n\t}\n\n\tcount = sci_txroom(port);\n\n\tdo {\n\t\tunsigned char c;\n\n\t\tif (port->x_char) {\n\t\t\tc = port->x_char;\n\t\t\tport->x_char = 0;\n\t\t} else if (!uart_circ_empty(xmit) && !stopped) {\n\t\t\tc = xmit->buf[xmit->tail];\n\t\t\txmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\n\t\t} else if (port->type == PORT_SCI && uart_circ_empty(xmit)) {\n\t\t\tctrl = serial_port_in(port, SCSCR);\n\t\t\tctrl &= ~SCSCR_TE;\n\t\t\tserial_port_out(port, SCSCR, ctrl);\n\t\t\treturn;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\tserial_port_out(port, SCxTDR, c);\n\n\t\tport->icount.tx++;\n\t} while (--count > 0);\n\n\tsci_clear_SCxSR(port, SCxSR_TDxE_CLEAR(port));\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\tif (uart_circ_empty(xmit)) {\n\t\tif (port->type == PORT_SCI) {\n\t\t\tctrl = serial_port_in(port, SCSCR);\n\t\t\tctrl &= ~SCSCR_TIE;\n\t\t\tctrl |= SCSCR_TEIE;\n\t\t\tserial_port_out(port, SCSCR, ctrl);\n\t\t}\n\n\t\tsci_stop_tx(port);\n\t}\n}\n\nstatic void sci_receive_chars(struct uart_port *port)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tint i, count, copied = 0;\n\tunsigned short status;\n\tunsigned char flag;\n\n\tstatus = serial_port_in(port, SCxSR);\n\tif (!(status & SCxSR_RDxF(port)))\n\t\treturn;\n\n\twhile (1) {\n\t\t \n\t\tcount = tty_buffer_request_room(tport, sci_rxfill(port));\n\n\t\t \n\t\tif (count == 0)\n\t\t\tbreak;\n\n\t\tif (port->type == PORT_SCI) {\n\t\t\tchar c = serial_port_in(port, SCxRDR);\n\t\t\tif (uart_handle_sysrq_char(port, c))\n\t\t\t\tcount = 0;\n\t\t\telse\n\t\t\t\ttty_insert_flip_char(tport, c, TTY_NORMAL);\n\t\t} else {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tchar c;\n\n\t\t\t\tif (port->type == PORT_SCIF ||\n\t\t\t\t    port->type == PORT_HSCIF) {\n\t\t\t\t\tstatus = serial_port_in(port, SCxSR);\n\t\t\t\t\tc = serial_port_in(port, SCxRDR);\n\t\t\t\t} else {\n\t\t\t\t\tc = serial_port_in(port, SCxRDR);\n\t\t\t\t\tstatus = serial_port_in(port, SCxSR);\n\t\t\t\t}\n\t\t\t\tif (uart_handle_sysrq_char(port, c)) {\n\t\t\t\t\tcount--; i--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (status & SCxSR_FER(port)) {\n\t\t\t\t\tflag = TTY_FRAME;\n\t\t\t\t\tport->icount.frame++;\n\t\t\t\t} else if (status & SCxSR_PER(port)) {\n\t\t\t\t\tflag = TTY_PARITY;\n\t\t\t\t\tport->icount.parity++;\n\t\t\t\t} else\n\t\t\t\t\tflag = TTY_NORMAL;\n\n\t\t\t\ttty_insert_flip_char(tport, c, flag);\n\t\t\t}\n\t\t}\n\n\t\tserial_port_in(port, SCxSR);  \n\t\tsci_clear_SCxSR(port, SCxSR_RDxF_CLEAR(port));\n\n\t\tcopied += count;\n\t\tport->icount.rx += count;\n\t}\n\n\tif (copied) {\n\t\t \n\t\ttty_flip_buffer_push(tport);\n\t} else {\n\t\t \n\t\tserial_port_in(port, SCxRDR);\n\t\tserial_port_in(port, SCxSR);  \n\t\tsci_clear_SCxSR(port, SCxSR_RDxF_CLEAR(port));\n\t}\n}\n\nstatic int sci_handle_errors(struct uart_port *port)\n{\n\tint copied = 0;\n\tunsigned short status = serial_port_in(port, SCxSR);\n\tstruct tty_port *tport = &port->state->port;\n\tstruct sci_port *s = to_sci_port(port);\n\n\t \n\tif (status & s->params->overrun_mask) {\n\t\tport->icount.overrun++;\n\n\t\t \n\t\tif (tty_insert_flip_char(tport, 0, TTY_OVERRUN))\n\t\t\tcopied++;\n\t}\n\n\tif (status & SCxSR_FER(port)) {\n\t\t \n\t\tport->icount.frame++;\n\n\t\tif (tty_insert_flip_char(tport, 0, TTY_FRAME))\n\t\t\tcopied++;\n\t}\n\n\tif (status & SCxSR_PER(port)) {\n\t\t \n\t\tport->icount.parity++;\n\n\t\tif (tty_insert_flip_char(tport, 0, TTY_PARITY))\n\t\t\tcopied++;\n\t}\n\n\tif (copied)\n\t\ttty_flip_buffer_push(tport);\n\n\treturn copied;\n}\n\nstatic int sci_handle_fifo_overrun(struct uart_port *port)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tstruct sci_port *s = to_sci_port(port);\n\tconst struct plat_sci_reg *reg;\n\tint copied = 0;\n\tu16 status;\n\n\treg = sci_getreg(port, s->params->overrun_reg);\n\tif (!reg->size)\n\t\treturn 0;\n\n\tstatus = serial_port_in(port, s->params->overrun_reg);\n\tif (status & s->params->overrun_mask) {\n\t\tstatus &= ~s->params->overrun_mask;\n\t\tserial_port_out(port, s->params->overrun_reg, status);\n\n\t\tport->icount.overrun++;\n\n\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\t\ttty_flip_buffer_push(tport);\n\t\tcopied++;\n\t}\n\n\treturn copied;\n}\n\nstatic int sci_handle_breaks(struct uart_port *port)\n{\n\tint copied = 0;\n\tunsigned short status = serial_port_in(port, SCxSR);\n\tstruct tty_port *tport = &port->state->port;\n\n\tif (uart_handle_break(port))\n\t\treturn 0;\n\n\tif (status & SCxSR_BRK(port)) {\n\t\tport->icount.brk++;\n\n\t\t \n\t\tif (tty_insert_flip_char(tport, 0, TTY_BREAK))\n\t\t\tcopied++;\n\t}\n\n\tif (copied)\n\t\ttty_flip_buffer_push(tport);\n\n\tcopied += sci_handle_fifo_overrun(port);\n\n\treturn copied;\n}\n\nstatic int scif_set_rtrg(struct uart_port *port, int rx_trig)\n{\n\tunsigned int bits;\n\n\tif (rx_trig >= port->fifosize)\n\t\trx_trig = port->fifosize - 1;\n\tif (rx_trig < 1)\n\t\trx_trig = 1;\n\n\t \n\tif (sci_getreg(port, HSRTRGR)->size) {\n\t\tserial_port_out(port, HSRTRGR, rx_trig);\n\t\treturn rx_trig;\n\t}\n\n\tswitch (port->type) {\n\tcase PORT_SCIF:\n\t\tif (rx_trig < 4) {\n\t\t\tbits = 0;\n\t\t\trx_trig = 1;\n\t\t} else if (rx_trig < 8) {\n\t\t\tbits = SCFCR_RTRG0;\n\t\t\trx_trig = 4;\n\t\t} else if (rx_trig < 14) {\n\t\t\tbits = SCFCR_RTRG1;\n\t\t\trx_trig = 8;\n\t\t} else {\n\t\t\tbits = SCFCR_RTRG0 | SCFCR_RTRG1;\n\t\t\trx_trig = 14;\n\t\t}\n\t\tbreak;\n\tcase PORT_SCIFA:\n\tcase PORT_SCIFB:\n\t\tif (rx_trig < 16) {\n\t\t\tbits = 0;\n\t\t\trx_trig = 1;\n\t\t} else if (rx_trig < 32) {\n\t\t\tbits = SCFCR_RTRG0;\n\t\t\trx_trig = 16;\n\t\t} else if (rx_trig < 48) {\n\t\t\tbits = SCFCR_RTRG1;\n\t\t\trx_trig = 32;\n\t\t} else {\n\t\t\tbits = SCFCR_RTRG0 | SCFCR_RTRG1;\n\t\t\trx_trig = 48;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unknown FIFO configuration\");\n\t\treturn 1;\n\t}\n\n\tserial_port_out(port, SCFCR,\n\t\t(serial_port_in(port, SCFCR) &\n\t\t~(SCFCR_RTRG1 | SCFCR_RTRG0)) | bits);\n\n\treturn rx_trig;\n}\n\nstatic int scif_rtrg_enabled(struct uart_port *port)\n{\n\tif (sci_getreg(port, HSRTRGR)->size)\n\t\treturn serial_port_in(port, HSRTRGR) != 0;\n\telse\n\t\treturn (serial_port_in(port, SCFCR) &\n\t\t\t(SCFCR_RTRG0 | SCFCR_RTRG1)) != 0;\n}\n\nstatic void rx_fifo_timer_fn(struct timer_list *t)\n{\n\tstruct sci_port *s = from_timer(s, t, rx_fifo_timer);\n\tstruct uart_port *port = &s->port;\n\n\tdev_dbg(port->dev, \"Rx timed out\\n\");\n\tscif_set_rtrg(port, 1);\n}\n\nstatic ssize_t rx_fifo_trigger_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct sci_port *sci = to_sci_port(port);\n\n\treturn sprintf(buf, \"%d\\n\", sci->rx_trigger);\n}\n\nstatic ssize_t rx_fifo_trigger_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct sci_port *sci = to_sci_port(port);\n\tint ret;\n\tlong r;\n\n\tret = kstrtol(buf, 0, &r);\n\tif (ret)\n\t\treturn ret;\n\n\tsci->rx_trigger = scif_set_rtrg(port, r);\n\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\n\t\tscif_set_rtrg(port, 1);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(rx_fifo_trigger);\n\nstatic ssize_t rx_fifo_timeout_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct sci_port *sci = to_sci_port(port);\n\tint v;\n\n\tif (port->type == PORT_HSCIF)\n\t\tv = sci->hscif_tot >> HSSCR_TOT_SHIFT;\n\telse\n\t\tv = sci->rx_fifo_timeout;\n\n\treturn sprintf(buf, \"%d\\n\", v);\n}\n\nstatic ssize_t rx_fifo_timeout_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct sci_port *sci = to_sci_port(port);\n\tint ret;\n\tlong r;\n\n\tret = kstrtol(buf, 0, &r);\n\tif (ret)\n\t\treturn ret;\n\n\tif (port->type == PORT_HSCIF) {\n\t\tif (r < 0 || r > 3)\n\t\t\treturn -EINVAL;\n\t\tsci->hscif_tot = r << HSSCR_TOT_SHIFT;\n\t} else {\n\t\tsci->rx_fifo_timeout = r;\n\t\tscif_set_rtrg(port, 1);\n\t\tif (r > 0)\n\t\t\ttimer_setup(&sci->rx_fifo_timer, rx_fifo_timer_fn, 0);\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(rx_fifo_timeout);\n\n\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\nstatic void sci_dma_tx_complete(void *arg)\n{\n\tstruct sci_port *s = arg;\n\tstruct uart_port *port = &s->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned long flags;\n\n\tdev_dbg(port->dev, \"%s(%d)\\n\", __func__, port->line);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tuart_xmit_advance(port, s->tx_dma_len);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (!uart_circ_empty(xmit)) {\n\t\ts->cookie_tx = 0;\n\t\tschedule_work(&s->work_tx);\n\t} else {\n\t\ts->cookie_tx = -EINVAL;\n\t\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB ||\n\t\t    s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE) {\n\t\t\tu16 ctrl = serial_port_in(port, SCSCR);\n\t\t\tserial_port_out(port, SCSCR, ctrl & ~SCSCR_TIE);\n\t\t\tif (s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE) {\n\t\t\t\t \n\t\t\t\tdmaengine_pause(s->chan_tx_saved);\n\t\t\t\tenable_irq(s->irqs[SCIx_TXI_IRQ]);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic int sci_dma_rx_push(struct sci_port *s, void *buf, size_t count)\n{\n\tstruct uart_port *port = &s->port;\n\tstruct tty_port *tport = &port->state->port;\n\tint copied;\n\n\tcopied = tty_insert_flip_string(tport, buf, count);\n\tif (copied < count)\n\t\tport->icount.buf_overrun++;\n\n\tport->icount.rx += copied;\n\n\treturn copied;\n}\n\nstatic int sci_dma_rx_find_active(struct sci_port *s)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->cookie_rx); i++)\n\t\tif (s->active_rx == s->cookie_rx[i])\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic void sci_dma_rx_chan_invalidate(struct sci_port *s)\n{\n\tunsigned int i;\n\n\ts->chan_rx = NULL;\n\tfor (i = 0; i < ARRAY_SIZE(s->cookie_rx); i++)\n\t\ts->cookie_rx[i] = -EINVAL;\n\ts->active_rx = 0;\n}\n\nstatic void sci_dma_rx_release(struct sci_port *s)\n{\n\tstruct dma_chan *chan = s->chan_rx_saved;\n\n\ts->chan_rx_saved = NULL;\n\tsci_dma_rx_chan_invalidate(s);\n\tdmaengine_terminate_sync(chan);\n\tdma_free_coherent(chan->device->dev, s->buf_len_rx * 2, s->rx_buf[0],\n\t\t\t  sg_dma_address(&s->sg_rx[0]));\n\tdma_release_channel(chan);\n}\n\nstatic void start_hrtimer_us(struct hrtimer *hrt, unsigned long usec)\n{\n\tlong sec = usec / 1000000;\n\tlong nsec = (usec % 1000000) * 1000;\n\tktime_t t = ktime_set(sec, nsec);\n\n\thrtimer_start(hrt, t, HRTIMER_MODE_REL);\n}\n\nstatic void sci_dma_rx_reenable_irq(struct sci_port *s)\n{\n\tstruct uart_port *port = &s->port;\n\tu16 scr;\n\n\t \n\tscr = serial_port_in(port, SCSCR);\n\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB ||\n\t    s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE) {\n\t\tenable_irq(s->irqs[SCIx_RXI_IRQ]);\n\t\tif (s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE)\n\t\t\tscif_set_rtrg(port, s->rx_trigger);\n\t\telse\n\t\t\tscr &= ~SCSCR_RDRQE;\n\t}\n\tserial_port_out(port, SCSCR, scr | SCSCR_RIE);\n}\n\nstatic void sci_dma_rx_complete(void *arg)\n{\n\tstruct sci_port *s = arg;\n\tstruct dma_chan *chan = s->chan_rx;\n\tstruct uart_port *port = &s->port;\n\tstruct dma_async_tx_descriptor *desc;\n\tunsigned long flags;\n\tint active, count = 0;\n\n\tdev_dbg(port->dev, \"%s(%d) active cookie %d\\n\", __func__, port->line,\n\t\ts->active_rx);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tactive = sci_dma_rx_find_active(s);\n\tif (active >= 0)\n\t\tcount = sci_dma_rx_push(s, s->rx_buf[active], s->buf_len_rx);\n\n\tstart_hrtimer_us(&s->rx_timer, s->rx_timeout);\n\n\tif (count)\n\t\ttty_flip_buffer_push(&port->state->port);\n\n\tdesc = dmaengine_prep_slave_sg(s->chan_rx, &s->sg_rx[active], 1,\n\t\t\t\t       DMA_DEV_TO_MEM,\n\t\t\t\t       DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc)\n\t\tgoto fail;\n\n\tdesc->callback = sci_dma_rx_complete;\n\tdesc->callback_param = s;\n\ts->cookie_rx[active] = dmaengine_submit(desc);\n\tif (dma_submit_error(s->cookie_rx[active]))\n\t\tgoto fail;\n\n\ts->active_rx = s->cookie_rx[!active];\n\n\tdma_async_issue_pending(chan);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tdev_dbg(port->dev, \"%s: cookie %d #%d, new active cookie %d\\n\",\n\t\t__func__, s->cookie_rx[active], active, s->active_rx);\n\treturn;\n\nfail:\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tdev_warn(port->dev, \"Failed submitting Rx DMA descriptor\\n\");\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tdmaengine_terminate_async(chan);\n\tsci_dma_rx_chan_invalidate(s);\n\tsci_dma_rx_reenable_irq(s);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void sci_dma_tx_release(struct sci_port *s)\n{\n\tstruct dma_chan *chan = s->chan_tx_saved;\n\n\tcancel_work_sync(&s->work_tx);\n\ts->chan_tx_saved = s->chan_tx = NULL;\n\ts->cookie_tx = -EINVAL;\n\tdmaengine_terminate_sync(chan);\n\tdma_unmap_single(chan->device->dev, s->tx_dma_addr, UART_XMIT_SIZE,\n\t\t\t DMA_TO_DEVICE);\n\tdma_release_channel(chan);\n}\n\nstatic int sci_dma_rx_submit(struct sci_port *s, bool port_lock_held)\n{\n\tstruct dma_chan *chan = s->chan_rx;\n\tstruct uart_port *port = &s->port;\n\tunsigned long flags;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct scatterlist *sg = &s->sg_rx[i];\n\t\tstruct dma_async_tx_descriptor *desc;\n\n\t\tdesc = dmaengine_prep_slave_sg(chan,\n\t\t\tsg, 1, DMA_DEV_TO_MEM,\n\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!desc)\n\t\t\tgoto fail;\n\n\t\tdesc->callback = sci_dma_rx_complete;\n\t\tdesc->callback_param = s;\n\t\ts->cookie_rx[i] = dmaengine_submit(desc);\n\t\tif (dma_submit_error(s->cookie_rx[i]))\n\t\t\tgoto fail;\n\n\t}\n\n\ts->active_rx = s->cookie_rx[0];\n\n\tdma_async_issue_pending(chan);\n\treturn 0;\n\nfail:\n\t \n\tif (!port_lock_held)\n\t\tspin_lock_irqsave(&port->lock, flags);\n\tif (i)\n\t\tdmaengine_terminate_async(chan);\n\tsci_dma_rx_chan_invalidate(s);\n\tsci_start_rx(port);\n\tif (!port_lock_held)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\treturn -EAGAIN;\n}\n\nstatic void sci_dma_tx_work_fn(struct work_struct *work)\n{\n\tstruct sci_port *s = container_of(work, struct sci_port, work_tx);\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct dma_chan *chan = s->chan_tx;\n\tstruct uart_port *port = &s->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned long flags;\n\tdma_addr_t buf;\n\tint head, tail;\n\n\t \n\tspin_lock_irq(&port->lock);\n\thead = xmit->head;\n\ttail = xmit->tail;\n\tbuf = s->tx_dma_addr + tail;\n\ts->tx_dma_len = CIRC_CNT_TO_END(head, tail, UART_XMIT_SIZE);\n\tif (!s->tx_dma_len) {\n\t\t \n\t\tspin_unlock_irq(&port->lock);\n\t\treturn;\n\t}\n\n\tdesc = dmaengine_prep_slave_single(chan, buf, s->tx_dma_len,\n\t\t\t\t\t   DMA_MEM_TO_DEV,\n\t\t\t\t\t   DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tspin_unlock_irq(&port->lock);\n\t\tdev_warn(port->dev, \"Failed preparing Tx DMA descriptor\\n\");\n\t\tgoto switch_to_pio;\n\t}\n\n\tdma_sync_single_for_device(chan->device->dev, buf, s->tx_dma_len,\n\t\t\t\t   DMA_TO_DEVICE);\n\n\tdesc->callback = sci_dma_tx_complete;\n\tdesc->callback_param = s;\n\ts->cookie_tx = dmaengine_submit(desc);\n\tif (dma_submit_error(s->cookie_tx)) {\n\t\tspin_unlock_irq(&port->lock);\n\t\tdev_warn(port->dev, \"Failed submitting Tx DMA descriptor\\n\");\n\t\tgoto switch_to_pio;\n\t}\n\n\tspin_unlock_irq(&port->lock);\n\tdev_dbg(port->dev, \"%s: %p: %d...%d, cookie %d\\n\",\n\t\t__func__, xmit->buf, tail, head, s->cookie_tx);\n\n\tdma_async_issue_pending(chan);\n\treturn;\n\nswitch_to_pio:\n\tspin_lock_irqsave(&port->lock, flags);\n\ts->chan_tx = NULL;\n\tsci_start_tx(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\treturn;\n}\n\nstatic enum hrtimer_restart sci_dma_rx_timer_fn(struct hrtimer *t)\n{\n\tstruct sci_port *s = container_of(t, struct sci_port, rx_timer);\n\tstruct dma_chan *chan = s->chan_rx;\n\tstruct uart_port *port = &s->port;\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\tunsigned long flags;\n\tunsigned int read;\n\tint active, count;\n\n\tdev_dbg(port->dev, \"DMA Rx timed out\\n\");\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tactive = sci_dma_rx_find_active(s);\n\tif (active < 0) {\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\treturn HRTIMER_NORESTART;\n\t}\n\n\tstatus = dmaengine_tx_status(s->chan_rx, s->active_rx, &state);\n\tif (status == DMA_COMPLETE) {\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tdev_dbg(port->dev, \"Cookie %d #%d has already completed\\n\",\n\t\t\ts->active_rx, active);\n\n\t\t \n\t\treturn HRTIMER_NORESTART;\n\t}\n\n\tdmaengine_pause(chan);\n\n\t \n\tstatus = dmaengine_tx_status(s->chan_rx, s->active_rx, &state);\n\tif (status == DMA_COMPLETE) {\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tdev_dbg(port->dev, \"Transaction complete after DMA engine was stopped\");\n\t\treturn HRTIMER_NORESTART;\n\t}\n\n\t \n\tdmaengine_terminate_async(s->chan_rx);\n\tread = sg_dma_len(&s->sg_rx[active]) - state.residue;\n\n\tif (read) {\n\t\tcount = sci_dma_rx_push(s, s->rx_buf[active], read);\n\t\tif (count)\n\t\t\ttty_flip_buffer_push(&port->state->port);\n\t}\n\n\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB ||\n\t    s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE)\n\t\tsci_dma_rx_submit(s, true);\n\n\tsci_dma_rx_reenable_irq(s);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic struct dma_chan *sci_request_dma_chan(struct uart_port *port,\n\t\t\t\t\t     enum dma_transfer_direction dir)\n{\n\tstruct dma_chan *chan;\n\tstruct dma_slave_config cfg;\n\tint ret;\n\n\tchan = dma_request_slave_channel(port->dev,\n\t\t\t\t\t dir == DMA_MEM_TO_DEV ? \"tx\" : \"rx\");\n\tif (!chan) {\n\t\tdev_dbg(port->dev, \"dma_request_slave_channel failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.direction = dir;\n\tcfg.dst_addr = port->mapbase +\n\t\t(sci_getreg(port, SCxTDR)->offset << port->regshift);\n\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tcfg.src_addr = port->mapbase +\n\t\t(sci_getreg(port, SCxRDR)->offset << port->regshift);\n\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\n\tret = dmaengine_slave_config(chan, &cfg);\n\tif (ret) {\n\t\tdev_warn(port->dev, \"dmaengine_slave_config failed %d\\n\", ret);\n\t\tdma_release_channel(chan);\n\t\treturn NULL;\n\t}\n\n\treturn chan;\n}\n\nstatic void sci_request_dma(struct uart_port *port)\n{\n\tstruct sci_port *s = to_sci_port(port);\n\tstruct dma_chan *chan;\n\n\tdev_dbg(port->dev, \"%s: port %d\\n\", __func__, port->line);\n\n\t \n\tif (uart_console(port))\n\t\treturn;\n\n\tif (!port->dev->of_node)\n\t\treturn;\n\n\ts->cookie_tx = -EINVAL;\n\n\t \n\tif (!of_property_present(port->dev->of_node, \"dmas\"))\n\t\treturn;\n\n\tchan = sci_request_dma_chan(port, DMA_MEM_TO_DEV);\n\tdev_dbg(port->dev, \"%s: TX: got channel %p\\n\", __func__, chan);\n\tif (chan) {\n\t\t \n\t\ts->tx_dma_addr = dma_map_single(chan->device->dev,\n\t\t\t\t\t\tport->state->xmit.buf,\n\t\t\t\t\t\tUART_XMIT_SIZE,\n\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\tif (dma_mapping_error(chan->device->dev, s->tx_dma_addr)) {\n\t\t\tdev_warn(port->dev, \"Failed mapping Tx DMA descriptor\\n\");\n\t\t\tdma_release_channel(chan);\n\t\t} else {\n\t\t\tdev_dbg(port->dev, \"%s: mapped %lu@%p to %pad\\n\",\n\t\t\t\t__func__, UART_XMIT_SIZE,\n\t\t\t\tport->state->xmit.buf, &s->tx_dma_addr);\n\n\t\t\tINIT_WORK(&s->work_tx, sci_dma_tx_work_fn);\n\t\t\ts->chan_tx_saved = s->chan_tx = chan;\n\t\t}\n\t}\n\n\tchan = sci_request_dma_chan(port, DMA_DEV_TO_MEM);\n\tdev_dbg(port->dev, \"%s: RX: got channel %p\\n\", __func__, chan);\n\tif (chan) {\n\t\tunsigned int i;\n\t\tdma_addr_t dma;\n\t\tvoid *buf;\n\n\t\ts->buf_len_rx = 2 * max_t(size_t, 16, port->fifosize);\n\t\tbuf = dma_alloc_coherent(chan->device->dev, s->buf_len_rx * 2,\n\t\t\t\t\t &dma, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tdev_warn(port->dev,\n\t\t\t\t \"Failed to allocate Rx dma buffer, using PIO\\n\");\n\t\t\tdma_release_channel(chan);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tstruct scatterlist *sg = &s->sg_rx[i];\n\n\t\t\tsg_init_table(sg, 1);\n\t\t\ts->rx_buf[i] = buf;\n\t\t\tsg_dma_address(sg) = dma;\n\t\t\tsg_dma_len(sg) = s->buf_len_rx;\n\n\t\t\tbuf += s->buf_len_rx;\n\t\t\tdma += s->buf_len_rx;\n\t\t}\n\n\t\thrtimer_init(&s->rx_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\t\ts->rx_timer.function = sci_dma_rx_timer_fn;\n\n\t\ts->chan_rx_saved = s->chan_rx = chan;\n\n\t\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB ||\n\t\t    s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE)\n\t\t\tsci_dma_rx_submit(s, false);\n\t}\n}\n\nstatic void sci_free_dma(struct uart_port *port)\n{\n\tstruct sci_port *s = to_sci_port(port);\n\n\tif (s->chan_tx_saved)\n\t\tsci_dma_tx_release(s);\n\tif (s->chan_rx_saved)\n\t\tsci_dma_rx_release(s);\n}\n\nstatic void sci_flush_buffer(struct uart_port *port)\n{\n\tstruct sci_port *s = to_sci_port(port);\n\n\t \n\ts->tx_dma_len = 0;\n\tif (s->chan_tx) {\n\t\tdmaengine_terminate_async(s->chan_tx);\n\t\ts->cookie_tx = -EINVAL;\n\t}\n}\n#else  \nstatic inline void sci_request_dma(struct uart_port *port)\n{\n}\n\nstatic inline void sci_free_dma(struct uart_port *port)\n{\n}\n\n#define sci_flush_buffer\tNULL\n#endif  \n\nstatic irqreturn_t sci_rx_interrupt(int irq, void *ptr)\n{\n\tstruct uart_port *port = ptr;\n\tstruct sci_port *s = to_sci_port(port);\n\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\n\tif (s->chan_rx) {\n\t\tu16 scr = serial_port_in(port, SCSCR);\n\t\tu16 ssr = serial_port_in(port, SCxSR);\n\n\t\t \n\t\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB ||\n\t\t    s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE) {\n\t\t\tdisable_irq_nosync(s->irqs[SCIx_RXI_IRQ]);\n\t\t\tif (s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE) {\n\t\t\t\tscif_set_rtrg(port, 1);\n\t\t\t\tscr |= SCSCR_RIE;\n\t\t\t} else {\n\t\t\t\tscr |= SCSCR_RDRQE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sci_dma_rx_submit(s, false) < 0)\n\t\t\t\tgoto handle_pio;\n\n\t\t\tscr &= ~SCSCR_RIE;\n\t\t}\n\t\tserial_port_out(port, SCSCR, scr);\n\t\t \n\t\tserial_port_out(port, SCxSR,\n\t\t\t\tssr & ~(SCIF_DR | SCxSR_RDxF(port)));\n\t\tdev_dbg(port->dev, \"Rx IRQ %lu: setup t-out in %u us\\n\",\n\t\t\tjiffies, s->rx_timeout);\n\t\tstart_hrtimer_us(&s->rx_timer, s->rx_timeout);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\nhandle_pio:\n#endif\n\n\tif (s->rx_trigger > 1 && s->rx_fifo_timeout > 0) {\n\t\tif (!scif_rtrg_enabled(port))\n\t\t\tscif_set_rtrg(port, s->rx_trigger);\n\n\t\tmod_timer(&s->rx_fifo_timer, jiffies + DIV_ROUND_UP(\n\t\t\t  s->rx_frame * HZ * s->rx_fifo_timeout, 1000000));\n\t}\n\n\t \n\tsci_receive_chars(port);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sci_tx_interrupt(int irq, void *ptr)\n{\n\tstruct uart_port *port = ptr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tsci_transmit_chars(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sci_tx_end_interrupt(int irq, void *ptr)\n{\n\tstruct uart_port *port = ptr;\n\tunsigned long flags;\n\tunsigned short ctrl;\n\n\tif (port->type != PORT_SCI)\n\t\treturn sci_tx_interrupt(irq, ptr);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tctrl = serial_port_in(port, SCSCR);\n\tctrl &= ~(SCSCR_TE | SCSCR_TEIE);\n\tserial_port_out(port, SCSCR, ctrl);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sci_br_interrupt(int irq, void *ptr)\n{\n\tstruct uart_port *port = ptr;\n\n\t \n\tsci_handle_breaks(port);\n\n\t \n\tserial_port_in(port, SCxRDR);\n\n\tsci_clear_SCxSR(port, SCxSR_BREAK_CLEAR(port));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sci_er_interrupt(int irq, void *ptr)\n{\n\tstruct uart_port *port = ptr;\n\tstruct sci_port *s = to_sci_port(port);\n\n\tif (s->irqs[SCIx_ERI_IRQ] == s->irqs[SCIx_BRI_IRQ]) {\n\t\t \n\t\tunsigned short ssr_status = serial_port_in(port, SCxSR);\n\n\t\t \n\t\tif (ssr_status & SCxSR_BRK(port))\n\t\t\tsci_br_interrupt(irq, ptr);\n\n\t\t \n\t\tif (!(ssr_status & SCxSR_ERRORS(port)))\n\t\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (port->type == PORT_SCI) {\n\t\tif (sci_handle_errors(port)) {\n\t\t\t \n\t\t\tserial_port_in(port, SCxSR);\n\t\t\tsci_clear_SCxSR(port, SCxSR_RDxF_CLEAR(port));\n\t\t}\n\t} else {\n\t\tsci_handle_fifo_overrun(port);\n\t\tif (!s->chan_rx)\n\t\t\tsci_receive_chars(port);\n\t}\n\n\tsci_clear_SCxSR(port, SCxSR_ERROR_CLEAR(port));\n\n\t \n\tif (!s->chan_tx)\n\t\tsci_tx_interrupt(irq, ptr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sci_mpxed_interrupt(int irq, void *ptr)\n{\n\tunsigned short ssr_status, scr_status, err_enabled, orer_status = 0;\n\tstruct uart_port *port = ptr;\n\tstruct sci_port *s = to_sci_port(port);\n\tirqreturn_t ret = IRQ_NONE;\n\n\tssr_status = serial_port_in(port, SCxSR);\n\tscr_status = serial_port_in(port, SCSCR);\n\tif (s->params->overrun_reg == SCxSR)\n\t\torer_status = ssr_status;\n\telse if (sci_getreg(port, s->params->overrun_reg)->size)\n\t\torer_status = serial_port_in(port, s->params->overrun_reg);\n\n\terr_enabled = scr_status & port_rx_irq_mask(port);\n\n\t \n\tif ((ssr_status & SCxSR_TDxE(port)) && (scr_status & SCSCR_TIE) &&\n\t    !s->chan_tx)\n\t\tret = sci_tx_interrupt(irq, ptr);\n\n\t \n\tif (((ssr_status & SCxSR_RDxF(port)) || s->chan_rx) &&\n\t    (scr_status & SCSCR_RIE))\n\t\tret = sci_rx_interrupt(irq, ptr);\n\n\t \n\tif ((ssr_status & SCxSR_ERRORS(port)) && err_enabled)\n\t\tret = sci_er_interrupt(irq, ptr);\n\n\t \n\tif (s->irqs[SCIx_ERI_IRQ] != s->irqs[SCIx_BRI_IRQ] &&\n\t    (ssr_status & SCxSR_BRK(port)) && err_enabled)\n\t\tret = sci_br_interrupt(irq, ptr);\n\n\t \n\tif (orer_status & s->params->overrun_mask) {\n\t\tsci_handle_fifo_overrun(port);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct sci_irq_desc {\n\tconst char\t*desc;\n\tirq_handler_t\thandler;\n} sci_irq_desc[] = {\n\t \n\t[SCIx_ERI_IRQ] = {\n\t\t.desc = \"rx err\",\n\t\t.handler = sci_er_interrupt,\n\t},\n\n\t[SCIx_RXI_IRQ] = {\n\t\t.desc = \"rx full\",\n\t\t.handler = sci_rx_interrupt,\n\t},\n\n\t[SCIx_TXI_IRQ] = {\n\t\t.desc = \"tx empty\",\n\t\t.handler = sci_tx_interrupt,\n\t},\n\n\t[SCIx_BRI_IRQ] = {\n\t\t.desc = \"break\",\n\t\t.handler = sci_br_interrupt,\n\t},\n\n\t[SCIx_DRI_IRQ] = {\n\t\t.desc = \"rx ready\",\n\t\t.handler = sci_rx_interrupt,\n\t},\n\n\t[SCIx_TEI_IRQ] = {\n\t\t.desc = \"tx end\",\n\t\t.handler = sci_tx_end_interrupt,\n\t},\n\n\t \n\t[SCIx_MUX_IRQ] = {\n\t\t.desc = \"mux\",\n\t\t.handler = sci_mpxed_interrupt,\n\t},\n};\n\nstatic int sci_request_irq(struct sci_port *port)\n{\n\tstruct uart_port *up = &port->port;\n\tint i, j, w, ret = 0;\n\n\tfor (i = j = 0; i < SCIx_NR_IRQS; i++, j++) {\n\t\tconst struct sci_irq_desc *desc;\n\t\tint irq;\n\n\t\t \n\t\tfor (w = 0; w < i; w++)\n\t\t\tif (port->irqs[w] == port->irqs[i])\n\t\t\t\tw = i + 1;\n\t\tif (w > i)\n\t\t\tcontinue;\n\n\t\tif (SCIx_IRQ_IS_MUXED(port)) {\n\t\t\ti = SCIx_MUX_IRQ;\n\t\t\tirq = up->irq;\n\t\t} else {\n\t\t\tirq = port->irqs[i];\n\n\t\t\t \n\t\t\tif (unlikely(irq < 0))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tdesc = sci_irq_desc + i;\n\t\tport->irqstr[j] = kasprintf(GFP_KERNEL, \"%s:%s\",\n\t\t\t\t\t    dev_name(up->dev), desc->desc);\n\t\tif (!port->irqstr[j]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_nomem;\n\t\t}\n\n\t\tret = request_irq(irq, desc->handler, up->irqflags,\n\t\t\t\t  port->irqstr[j], port);\n\t\tif (unlikely(ret)) {\n\t\t\tdev_err(up->dev, \"Can't allocate %s IRQ\\n\", desc->desc);\n\t\t\tgoto out_noirq;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_noirq:\n\twhile (--i >= 0)\n\t\tfree_irq(port->irqs[i], port);\n\nout_nomem:\n\twhile (--j >= 0)\n\t\tkfree(port->irqstr[j]);\n\n\treturn ret;\n}\n\nstatic void sci_free_irq(struct sci_port *port)\n{\n\tint i, j;\n\n\t \n\tfor (i = 0; i < SCIx_NR_IRQS; i++) {\n\t\tint irq = port->irqs[i];\n\n\t\t \n\t\tif (unlikely(irq < 0))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (j = 0; j < i; j++)\n\t\t\tif (port->irqs[j] == irq)\n\t\t\t\tj = i + 1;\n\t\tif (j > i)\n\t\t\tcontinue;\n\n\t\tfree_irq(port->irqs[i], port);\n\t\tkfree(port->irqstr[i]);\n\n\t\tif (SCIx_IRQ_IS_MUXED(port)) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic unsigned int sci_tx_empty(struct uart_port *port)\n{\n\tunsigned short status = serial_port_in(port, SCxSR);\n\tunsigned short in_tx_fifo = sci_txfill(port);\n\n\treturn (status & SCxSR_TEND(port)) && !in_tx_fifo ? TIOCSER_TEMT : 0;\n}\n\nstatic void sci_set_rts(struct uart_port *port, bool state)\n{\n\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\n\t\tu16 data = serial_port_in(port, SCPDR);\n\n\t\t \n\t\tif (state)\n\t\t\tdata &= ~SCPDR_RTSD;\n\t\telse\n\t\t\tdata |= SCPDR_RTSD;\n\t\tserial_port_out(port, SCPDR, data);\n\n\t\t \n\t\tserial_port_out(port, SCPCR,\n\t\t\t\tserial_port_in(port, SCPCR) | SCPCR_RTSC);\n\t} else if (sci_getreg(port, SCSPTR)->size) {\n\t\tu16 ctrl = serial_port_in(port, SCSPTR);\n\n\t\t \n\t\tif (state)\n\t\t\tctrl &= ~SCSPTR_RTSDT;\n\t\telse\n\t\t\tctrl |= SCSPTR_RTSDT;\n\t\tserial_port_out(port, SCSPTR, ctrl);\n\t}\n}\n\nstatic bool sci_get_cts(struct uart_port *port)\n{\n\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\n\t\t \n\t\treturn !(serial_port_in(port, SCPDR) & SCPDR_CTSD);\n\t} else if (sci_getreg(port, SCSPTR)->size) {\n\t\t \n\t\treturn !(serial_port_in(port, SCSPTR) & SCSPTR_CTSDT);\n\t}\n\n\treturn true;\n}\n\n \nstatic void sci_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct sci_port *s = to_sci_port(port);\n\n\tif (mctrl & TIOCM_LOOP) {\n\t\tconst struct plat_sci_reg *reg;\n\n\t\t \n\t\treg = sci_getreg(port, SCFCR);\n\t\tif (reg->size)\n\t\t\tserial_port_out(port, SCFCR,\n\t\t\t\t\tserial_port_in(port, SCFCR) |\n\t\t\t\t\tSCFCR_LOOP);\n\t}\n\n\tmctrl_gpio_set(s->gpios, mctrl);\n\n\tif (!s->has_rtscts)\n\t\treturn;\n\n\tif (!(mctrl & TIOCM_RTS)) {\n\t\t \n\t\tserial_port_out(port, SCFCR,\n\t\t\t\tserial_port_in(port, SCFCR) & ~SCFCR_MCE);\n\n\t\t \n\t\tsci_set_rts(port, 0);\n\t} else if (s->autorts) {\n\t\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\n\t\t\t \n\t\t\tserial_port_out(port, SCPCR,\n\t\t\t\tserial_port_in(port, SCPCR) & ~SCPCR_RTSC);\n\t\t}\n\n\t\t \n\t\tserial_port_out(port, SCFCR,\n\t\t\t\tserial_port_in(port, SCFCR) | SCFCR_MCE);\n\t} else {\n\t\t \n\t\tsci_set_rts(port, 1);\n\t}\n}\n\nstatic unsigned int sci_get_mctrl(struct uart_port *port)\n{\n\tstruct sci_port *s = to_sci_port(port);\n\tstruct mctrl_gpios *gpios = s->gpios;\n\tunsigned int mctrl = 0;\n\n\tmctrl_gpio_get(gpios, &mctrl);\n\n\t \n\tif (s->autorts) {\n\t\tif (sci_get_cts(port))\n\t\t\tmctrl |= TIOCM_CTS;\n\t} else if (!mctrl_gpio_to_gpiod(gpios, UART_GPIO_CTS)) {\n\t\tmctrl |= TIOCM_CTS;\n\t}\n\tif (!mctrl_gpio_to_gpiod(gpios, UART_GPIO_DSR))\n\t\tmctrl |= TIOCM_DSR;\n\tif (!mctrl_gpio_to_gpiod(gpios, UART_GPIO_DCD))\n\t\tmctrl |= TIOCM_CAR;\n\n\treturn mctrl;\n}\n\nstatic void sci_enable_ms(struct uart_port *port)\n{\n\tmctrl_gpio_enable_ms(to_sci_port(port)->gpios);\n}\n\nstatic void sci_break_ctl(struct uart_port *port, int break_state)\n{\n\tunsigned short scscr, scsptr;\n\tunsigned long flags;\n\n\t \n\tif (!sci_getreg(port, SCSPTR)->size) {\n\t\t \n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tscsptr = serial_port_in(port, SCSPTR);\n\tscscr = serial_port_in(port, SCSCR);\n\n\tif (break_state == -1) {\n\t\tscsptr = (scsptr | SCSPTR_SPB2IO) & ~SCSPTR_SPB2DT;\n\t\tscscr &= ~SCSCR_TE;\n\t} else {\n\t\tscsptr = (scsptr | SCSPTR_SPB2DT) & ~SCSPTR_SPB2IO;\n\t\tscscr |= SCSCR_TE;\n\t}\n\n\tserial_port_out(port, SCSPTR, scsptr);\n\tserial_port_out(port, SCSCR, scscr);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int sci_startup(struct uart_port *port)\n{\n\tstruct sci_port *s = to_sci_port(port);\n\tint ret;\n\n\tdev_dbg(port->dev, \"%s(%d)\\n\", __func__, port->line);\n\n\tsci_request_dma(port);\n\n\tret = sci_request_irq(s);\n\tif (unlikely(ret < 0)) {\n\t\tsci_free_dma(port);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void sci_shutdown(struct uart_port *port)\n{\n\tstruct sci_port *s = to_sci_port(port);\n\tunsigned long flags;\n\tu16 scr;\n\n\tdev_dbg(port->dev, \"%s(%d)\\n\", __func__, port->line);\n\n\ts->autorts = false;\n\tmctrl_gpio_disable_ms(to_sci_port(port)->gpios);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tsci_stop_rx(port);\n\tsci_stop_tx(port);\n\t \n\tscr = serial_port_in(port, SCSCR);\n\tserial_port_out(port, SCSCR, scr &\n\t\t\t(SCSCR_CKE1 | SCSCR_CKE0 | s->hscif_tot));\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\n\tif (s->chan_rx_saved) {\n\t\tdev_dbg(port->dev, \"%s(%d) deleting rx_timer\\n\", __func__,\n\t\t\tport->line);\n\t\thrtimer_cancel(&s->rx_timer);\n\t}\n#endif\n\n\tif (s->rx_trigger > 1 && s->rx_fifo_timeout > 0)\n\t\tdel_timer_sync(&s->rx_fifo_timer);\n\tsci_free_irq(s);\n\tsci_free_dma(port);\n}\n\nstatic int sci_sck_calc(struct sci_port *s, unsigned int bps,\n\t\t\tunsigned int *srr)\n{\n\tunsigned long freq = s->clk_rates[SCI_SCK];\n\tint err, min_err = INT_MAX;\n\tunsigned int sr;\n\n\tif (s->port.type != PORT_HSCIF)\n\t\tfreq *= 2;\n\n\tfor_each_sr(sr, s) {\n\t\terr = DIV_ROUND_CLOSEST(freq, sr) - bps;\n\t\tif (abs(err) >= abs(min_err))\n\t\t\tcontinue;\n\n\t\tmin_err = err;\n\t\t*srr = sr - 1;\n\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\tdev_dbg(s->port.dev, \"SCK: %u%+d bps using SR %u\\n\", bps, min_err,\n\t\t*srr + 1);\n\treturn min_err;\n}\n\nstatic int sci_brg_calc(struct sci_port *s, unsigned int bps,\n\t\t\tunsigned long freq, unsigned int *dlr,\n\t\t\tunsigned int *srr)\n{\n\tint err, min_err = INT_MAX;\n\tunsigned int sr, dl;\n\n\tif (s->port.type != PORT_HSCIF)\n\t\tfreq *= 2;\n\n\tfor_each_sr(sr, s) {\n\t\tdl = DIV_ROUND_CLOSEST(freq, sr * bps);\n\t\tdl = clamp(dl, 1U, 65535U);\n\n\t\terr = DIV_ROUND_CLOSEST(freq, sr * dl) - bps;\n\t\tif (abs(err) >= abs(min_err))\n\t\t\tcontinue;\n\n\t\tmin_err = err;\n\t\t*dlr = dl;\n\t\t*srr = sr - 1;\n\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\tdev_dbg(s->port.dev, \"BRG: %u%+d bps using DL %u SR %u\\n\", bps,\n\t\tmin_err, *dlr, *srr + 1);\n\treturn min_err;\n}\n\n \nstatic int sci_scbrr_calc(struct sci_port *s, unsigned int bps,\n\t\t\t  unsigned int *brr, unsigned int *srr,\n\t\t\t  unsigned int *cks)\n{\n\tunsigned long freq = s->clk_rates[SCI_FCK];\n\tunsigned int sr, br, prediv, scrate, c;\n\tint err, min_err = INT_MAX;\n\n\tif (s->port.type != PORT_HSCIF)\n\t\tfreq *= 2;\n\n\t \n\tfor_each_sr(sr, s) {\n\t\tfor (c = 0; c <= 3; c++) {\n\t\t\t \n\t\t\tprediv = sr << (2 * c + 1);\n\n\t\t\t \n\t\t\tif (bps > UINT_MAX / prediv)\n\t\t\t\tbreak;\n\n\t\t\tscrate = prediv * bps;\n\t\t\tbr = DIV_ROUND_CLOSEST(freq, scrate);\n\t\t\tbr = clamp(br, 1U, 256U);\n\n\t\t\terr = DIV_ROUND_CLOSEST(freq, br * prediv) - bps;\n\t\t\tif (abs(err) >= abs(min_err))\n\t\t\t\tcontinue;\n\n\t\t\tmin_err = err;\n\t\t\t*brr = br - 1;\n\t\t\t*srr = sr - 1;\n\t\t\t*cks = c;\n\n\t\t\tif (!err)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\nfound:\n\tdev_dbg(s->port.dev, \"BRR: %u%+d bps using N %u SR %u cks %u\\n\", bps,\n\t\tmin_err, *brr, *srr + 1, *cks);\n\treturn min_err;\n}\n\nstatic void sci_reset(struct uart_port *port)\n{\n\tconst struct plat_sci_reg *reg;\n\tunsigned int status;\n\tstruct sci_port *s = to_sci_port(port);\n\n\tserial_port_out(port, SCSCR, s->hscif_tot);\t \n\n\treg = sci_getreg(port, SCFCR);\n\tif (reg->size)\n\t\tserial_port_out(port, SCFCR, SCFCR_RFRST | SCFCR_TFRST);\n\n\tsci_clear_SCxSR(port,\n\t\t\tSCxSR_RDxF_CLEAR(port) & SCxSR_ERROR_CLEAR(port) &\n\t\t\tSCxSR_BREAK_CLEAR(port));\n\tif (sci_getreg(port, SCLSR)->size) {\n\t\tstatus = serial_port_in(port, SCLSR);\n\t\tstatus &= ~(SCLSR_TO | SCLSR_ORER);\n\t\tserial_port_out(port, SCLSR, status);\n\t}\n\n\tif (s->rx_trigger > 1) {\n\t\tif (s->rx_fifo_timeout) {\n\t\t\tscif_set_rtrg(port, 1);\n\t\t\ttimer_setup(&s->rx_fifo_timer, rx_fifo_timer_fn, 0);\n\t\t} else {\n\t\t\tif (port->type == PORT_SCIFA ||\n\t\t\t    port->type == PORT_SCIFB)\n\t\t\t\tscif_set_rtrg(port, 1);\n\t\t\telse\n\t\t\t\tscif_set_rtrg(port, s->rx_trigger);\n\t\t}\n\t}\n}\n\nstatic void sci_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t            const struct ktermios *old)\n{\n\tunsigned int baud, smr_val = SCSMR_ASYNC, scr_val = 0, i, bits;\n\tunsigned int brr = 255, cks = 0, srr = 15, dl = 0, sccks = 0;\n\tunsigned int brr1 = 255, cks1 = 0, srr1 = 15, dl1 = 0;\n\tstruct sci_port *s = to_sci_port(port);\n\tconst struct plat_sci_reg *reg;\n\tint min_err = INT_MAX, err;\n\tunsigned long max_freq = 0;\n\tint best_clk = -1;\n\tunsigned long flags;\n\n\tif ((termios->c_cflag & CSIZE) == CS7) {\n\t\tsmr_val |= SCSMR_CHR;\n\t} else {\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= CS8;\n\t}\n\tif (termios->c_cflag & PARENB)\n\t\tsmr_val |= SCSMR_PE;\n\tif (termios->c_cflag & PARODD)\n\t\tsmr_val |= SCSMR_PE | SCSMR_ODD;\n\tif (termios->c_cflag & CSTOPB)\n\t\tsmr_val |= SCSMR_STOP;\n\n\t \n\tif (!port->uartclk) {\n\t\tbaud = uart_get_baud_rate(port, termios, old, 0, 115200);\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < SCI_NUM_CLKS; i++)\n\t\tmax_freq = max(max_freq, s->clk_rates[i]);\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, max_freq / min_sr(s));\n\tif (!baud)\n\t\tgoto done;\n\n\t \n\n\t \n\tif (s->clk_rates[SCI_SCK] && port->type != PORT_SCIFA &&\n\t    port->type != PORT_SCIFB) {\n\t\terr = sci_sck_calc(s, baud, &srr1);\n\t\tif (abs(err) < abs(min_err)) {\n\t\t\tbest_clk = SCI_SCK;\n\t\t\tscr_val = SCSCR_CKE1;\n\t\t\tsccks = SCCKS_CKS;\n\t\t\tmin_err = err;\n\t\t\tsrr = srr1;\n\t\t\tif (!err)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (s->clk_rates[SCI_SCIF_CLK] && sci_getreg(port, SCDL)->size) {\n\t\terr = sci_brg_calc(s, baud, s->clk_rates[SCI_SCIF_CLK], &dl1,\n\t\t\t\t   &srr1);\n\t\tif (abs(err) < abs(min_err)) {\n\t\t\tbest_clk = SCI_SCIF_CLK;\n\t\t\tscr_val = SCSCR_CKE1;\n\t\t\tsccks = 0;\n\t\t\tmin_err = err;\n\t\t\tdl = dl1;\n\t\t\tsrr = srr1;\n\t\t\tif (!err)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (s->clk_rates[SCI_BRG_INT] && sci_getreg(port, SCDL)->size) {\n\t\terr = sci_brg_calc(s, baud, s->clk_rates[SCI_BRG_INT], &dl1,\n\t\t\t\t   &srr1);\n\t\tif (abs(err) < abs(min_err)) {\n\t\t\tbest_clk = SCI_BRG_INT;\n\t\t\tscr_val = SCSCR_CKE1;\n\t\t\tsccks = SCCKS_XIN;\n\t\t\tmin_err = err;\n\t\t\tdl = dl1;\n\t\t\tsrr = srr1;\n\t\t\tif (!min_err)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\terr = sci_scbrr_calc(s, baud, &brr1, &srr1, &cks1);\n\tif (abs(err) < abs(min_err)) {\n\t\tbest_clk = SCI_FCK;\n\t\tscr_val = 0;\n\t\tmin_err = err;\n\t\tbrr = brr1;\n\t\tsrr = srr1;\n\t\tcks = cks1;\n\t}\n\ndone:\n\tif (best_clk >= 0)\n\t\tdev_dbg(port->dev, \"Using clk %pC for %u%+d bps\\n\",\n\t\t\ts->clks[best_clk], baud, min_err);\n\n\tsci_port_enable(s);\n\n\t \n\tif (best_clk >= 0 && sci_getreg(port, SCCKS)->size) {\n\t\tserial_port_out(port, SCDL, dl);\n\t\tserial_port_out(port, SCCKS, sccks);\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tsci_reset(port);\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\t \n\tbits = tty_get_frame_size(termios->c_cflag);\n\n\tif (sci_getreg(port, SEMR)->size)\n\t\tserial_port_out(port, SEMR, 0);\n\n\tif (best_clk >= 0) {\n\t\tif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\n\t\t\tswitch (srr + 1) {\n\t\t\tcase 5:  smr_val |= SCSMR_SRC_5;  break;\n\t\t\tcase 7:  smr_val |= SCSMR_SRC_7;  break;\n\t\t\tcase 11: smr_val |= SCSMR_SRC_11; break;\n\t\t\tcase 13: smr_val |= SCSMR_SRC_13; break;\n\t\t\tcase 16: smr_val |= SCSMR_SRC_16; break;\n\t\t\tcase 17: smr_val |= SCSMR_SRC_17; break;\n\t\t\tcase 19: smr_val |= SCSMR_SRC_19; break;\n\t\t\tcase 27: smr_val |= SCSMR_SRC_27; break;\n\t\t\t}\n\t\tsmr_val |= cks;\n\t\tserial_port_out(port, SCSCR, scr_val | s->hscif_tot);\n\t\tserial_port_out(port, SCSMR, smr_val);\n\t\tserial_port_out(port, SCBRR, brr);\n\t\tif (sci_getreg(port, HSSRR)->size) {\n\t\t\tunsigned int hssrr = srr | HSCIF_SRE;\n\t\t\t \n\t\t\tint last_stop = bits * 2 - 1;\n\t\t\tint deviation = DIV_ROUND_CLOSEST(min_err * last_stop *\n\t\t\t\t\t\t\t  (int)(srr + 1),\n\t\t\t\t\t\t\t  2 * (int)baud);\n\n\t\t\tif (abs(deviation) >= 2) {\n\t\t\t\t \n\t\t\t\tint shift = clamp(deviation / 2, -8, 7);\n\n\t\t\t\thssrr |= (shift << HSCIF_SRHP_SHIFT) &\n\t\t\t\t\t HSCIF_SRHP_MASK;\n\t\t\t\thssrr |= HSCIF_SRDE;\n\t\t\t}\n\t\t\tserial_port_out(port, HSSRR, hssrr);\n\t\t}\n\n\t\t \n\t\tudelay((1000000 + (baud - 1)) / baud);\n\t} else {\n\t\t \n\t\tscr_val = s->cfg->scscr & (SCSCR_CKE1 | SCSCR_CKE0);\n\t\tsmr_val |= serial_port_in(port, SCSMR) &\n\t\t\t   (SCSMR_CKEDG | SCSMR_SRC_MASK | SCSMR_CKS);\n\t\tserial_port_out(port, SCSCR, scr_val | s->hscif_tot);\n\t\tserial_port_out(port, SCSMR, smr_val);\n\t}\n\n\tsci_init_pins(port, termios->c_cflag);\n\n\tport->status &= ~UPSTAT_AUTOCTS;\n\ts->autorts = false;\n\treg = sci_getreg(port, SCFCR);\n\tif (reg->size) {\n\t\tunsigned short ctrl = serial_port_in(port, SCFCR);\n\n\t\tif ((port->flags & UPF_HARD_FLOW) &&\n\t\t    (termios->c_cflag & CRTSCTS)) {\n\t\t\t \n\t\t\tport->status |= UPSTAT_AUTOCTS;\n\t\t\t \n\t\t\ts->autorts = true;\n\t\t}\n\n\t\t \n\t\tctrl &= ~(SCFCR_RFRST | SCFCR_TFRST);\n\n\t\tserial_port_out(port, SCFCR, ctrl);\n\t}\n\tif (port->flags & UPF_HARD_FLOW) {\n\t\t \n\t\tsci_set_mctrl(port, port->mctrl);\n\t}\n\n\t \n\tif (port->type != PORT_SCI)\n\t\tscr_val |= SCSCR_TE;\n\tscr_val |= SCSCR_RE | (s->cfg->scscr & ~(SCSCR_CKE1 | SCSCR_CKE0));\n\tserial_port_out(port, SCSCR, scr_val | s->hscif_tot);\n\tif ((srr + 1 == 5) &&\n\t    (port->type == PORT_SCIFA || port->type == PORT_SCIFB)) {\n\t\t \n\t\tudelay(DIV_ROUND_UP(10 * 1000000, baud));\n\t}\n\n\t \n\ts->rx_frame = (10000 * bits) / (baud / 100);\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\n\ts->rx_timeout = s->buf_len_rx * 2 * s->rx_frame;\n#endif\n\n\tif ((termios->c_cflag & CREAD) != 0)\n\t\tsci_start_rx(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tsci_port_disable(s);\n\n\tif (UART_ENABLE_MS(port, termios->c_cflag))\n\t\tsci_enable_ms(port);\n}\n\nstatic void sci_pm(struct uart_port *port, unsigned int state,\n\t\t   unsigned int oldstate)\n{\n\tstruct sci_port *sci_port = to_sci_port(port);\n\n\tswitch (state) {\n\tcase UART_PM_STATE_OFF:\n\t\tsci_port_disable(sci_port);\n\t\tbreak;\n\tdefault:\n\t\tsci_port_enable(sci_port);\n\t\tbreak;\n\t}\n}\n\nstatic const char *sci_type(struct uart_port *port)\n{\n\tswitch (port->type) {\n\tcase PORT_IRDA:\n\t\treturn \"irda\";\n\tcase PORT_SCI:\n\t\treturn \"sci\";\n\tcase PORT_SCIF:\n\t\treturn \"scif\";\n\tcase PORT_SCIFA:\n\t\treturn \"scifa\";\n\tcase PORT_SCIFB:\n\t\treturn \"scifb\";\n\tcase PORT_HSCIF:\n\t\treturn \"hscif\";\n\t}\n\n\treturn NULL;\n}\n\nstatic int sci_remap_port(struct uart_port *port)\n{\n\tstruct sci_port *sport = to_sci_port(port);\n\n\t \n\tif (port->membase)\n\t\treturn 0;\n\n\tif (port->dev->of_node || (port->flags & UPF_IOREMAP)) {\n\t\tport->membase = ioremap(port->mapbase, sport->reg_size);\n\t\tif (unlikely(!port->membase)) {\n\t\t\tdev_err(port->dev, \"can't remap port#%d\\n\", port->line);\n\t\t\treturn -ENXIO;\n\t\t}\n\t} else {\n\t\t \n\t\tport->membase = (void __iomem *)(uintptr_t)port->mapbase;\n\t}\n\n\treturn 0;\n}\n\nstatic void sci_release_port(struct uart_port *port)\n{\n\tstruct sci_port *sport = to_sci_port(port);\n\n\tif (port->dev->of_node || (port->flags & UPF_IOREMAP)) {\n\t\tiounmap(port->membase);\n\t\tport->membase = NULL;\n\t}\n\n\trelease_mem_region(port->mapbase, sport->reg_size);\n}\n\nstatic int sci_request_port(struct uart_port *port)\n{\n\tstruct resource *res;\n\tstruct sci_port *sport = to_sci_port(port);\n\tint ret;\n\n\tres = request_mem_region(port->mapbase, sport->reg_size,\n\t\t\t\t dev_name(port->dev));\n\tif (unlikely(res == NULL)) {\n\t\tdev_err(port->dev, \"request_mem_region failed.\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = sci_remap_port(port);\n\tif (unlikely(ret != 0)) {\n\t\trelease_resource(res);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void sci_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tstruct sci_port *sport = to_sci_port(port);\n\n\t\tport->type = sport->cfg->type;\n\t\tsci_request_port(port);\n\t}\n}\n\nstatic int sci_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tif (ser->baud_base < 2400)\n\t\t \n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct uart_ops sci_uart_ops = {\n\t.tx_empty\t= sci_tx_empty,\n\t.set_mctrl\t= sci_set_mctrl,\n\t.get_mctrl\t= sci_get_mctrl,\n\t.start_tx\t= sci_start_tx,\n\t.stop_tx\t= sci_stop_tx,\n\t.stop_rx\t= sci_stop_rx,\n\t.enable_ms\t= sci_enable_ms,\n\t.break_ctl\t= sci_break_ctl,\n\t.startup\t= sci_startup,\n\t.shutdown\t= sci_shutdown,\n\t.flush_buffer\t= sci_flush_buffer,\n\t.set_termios\t= sci_set_termios,\n\t.pm\t\t= sci_pm,\n\t.type\t\t= sci_type,\n\t.release_port\t= sci_release_port,\n\t.request_port\t= sci_request_port,\n\t.config_port\t= sci_config_port,\n\t.verify_port\t= sci_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= sci_poll_get_char,\n\t.poll_put_char\t= sci_poll_put_char,\n#endif\n};\n\nstatic int sci_init_clocks(struct sci_port *sci_port, struct device *dev)\n{\n\tconst char *clk_names[] = {\n\t\t[SCI_FCK] = \"fck\",\n\t\t[SCI_SCK] = \"sck\",\n\t\t[SCI_BRG_INT] = \"brg_int\",\n\t\t[SCI_SCIF_CLK] = \"scif_clk\",\n\t};\n\tstruct clk *clk;\n\tunsigned int i;\n\n\tif (sci_port->cfg->type == PORT_HSCIF)\n\t\tclk_names[SCI_SCK] = \"hsck\";\n\n\tfor (i = 0; i < SCI_NUM_CLKS; i++) {\n\t\tclk = devm_clk_get_optional(dev, clk_names[i]);\n\t\tif (IS_ERR(clk))\n\t\t\treturn PTR_ERR(clk);\n\n\t\tif (!clk && i == SCI_FCK) {\n\t\t\t \n\t\t\tclk = devm_clk_get(dev, \"peripheral_clk\");\n\t\t\tif (IS_ERR(clk))\n\t\t\t\treturn dev_err_probe(dev, PTR_ERR(clk),\n\t\t\t\t\t\t     \"failed to get %s\\n\",\n\t\t\t\t\t\t     clk_names[i]);\n\t\t}\n\n\t\tif (!clk)\n\t\t\tdev_dbg(dev, \"failed to get %s\\n\", clk_names[i]);\n\t\telse\n\t\t\tdev_dbg(dev, \"clk %s is %pC rate %lu\\n\", clk_names[i],\n\t\t\t\tclk, clk_get_rate(clk));\n\t\tsci_port->clks[i] = clk;\n\t}\n\treturn 0;\n}\n\nstatic const struct sci_port_params *\nsci_probe_regmap(const struct plat_sci_port *cfg)\n{\n\tunsigned int regtype;\n\n\tif (cfg->regtype != SCIx_PROBE_REGTYPE)\n\t\treturn &sci_port_params[cfg->regtype];\n\n\tswitch (cfg->type) {\n\tcase PORT_SCI:\n\t\tregtype = SCIx_SCI_REGTYPE;\n\t\tbreak;\n\tcase PORT_IRDA:\n\t\tregtype = SCIx_IRDA_REGTYPE;\n\t\tbreak;\n\tcase PORT_SCIFA:\n\t\tregtype = SCIx_SCIFA_REGTYPE;\n\t\tbreak;\n\tcase PORT_SCIFB:\n\t\tregtype = SCIx_SCIFB_REGTYPE;\n\t\tbreak;\n\tcase PORT_SCIF:\n\t\t \n\t\tregtype = SCIx_SH4_SCIF_REGTYPE;\n\t\tbreak;\n\tcase PORT_HSCIF:\n\t\tregtype = SCIx_HSCIF_REGTYPE;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Can't probe register map for given port\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn &sci_port_params[regtype];\n}\n\nstatic int sci_init_single(struct platform_device *dev,\n\t\t\t   struct sci_port *sci_port, unsigned int index,\n\t\t\t   const struct plat_sci_port *p, bool early)\n{\n\tstruct uart_port *port = &sci_port->port;\n\tconst struct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\tsci_port->cfg\t= p;\n\n\tport->ops\t= &sci_uart_ops;\n\tport->iotype\t= UPIO_MEM;\n\tport->line\t= index;\n\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_SH_SCI_CONSOLE);\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (res == NULL)\n\t\treturn -ENOMEM;\n\n\tport->mapbase = res->start;\n\tsci_port->reg_size = resource_size(res);\n\n\tfor (i = 0; i < ARRAY_SIZE(sci_port->irqs); ++i) {\n\t\tif (i)\n\t\t\tsci_port->irqs[i] = platform_get_irq_optional(dev, i);\n\t\telse\n\t\t\tsci_port->irqs[i] = platform_get_irq(dev, i);\n\t}\n\n\t \n\tif (p->type == PORT_SCI)\n\t\tswap(sci_port->irqs[SCIx_BRI_IRQ], sci_port->irqs[SCIx_TEI_IRQ]);\n\n\t \n\tif (sci_port->irqs[0] < 0)\n\t\treturn -ENXIO;\n\n\tif (sci_port->irqs[1] < 0)\n\t\tfor (i = 1; i < ARRAY_SIZE(sci_port->irqs); i++)\n\t\t\tsci_port->irqs[i] = sci_port->irqs[0];\n\n\tsci_port->params = sci_probe_regmap(p);\n\tif (unlikely(sci_port->params == NULL))\n\t\treturn -EINVAL;\n\n\tswitch (p->type) {\n\tcase PORT_SCIFB:\n\t\tsci_port->rx_trigger = 48;\n\t\tbreak;\n\tcase PORT_HSCIF:\n\t\tsci_port->rx_trigger = 64;\n\t\tbreak;\n\tcase PORT_SCIFA:\n\t\tsci_port->rx_trigger = 32;\n\t\tbreak;\n\tcase PORT_SCIF:\n\t\tif (p->regtype == SCIx_SH7705_SCIF_REGTYPE)\n\t\t\t \n\t\t\tsci_port->rx_trigger = 1;\n\t\telse\n\t\t\tsci_port->rx_trigger = 8;\n\t\tbreak;\n\tdefault:\n\t\tsci_port->rx_trigger = 1;\n\t\tbreak;\n\t}\n\n\tsci_port->rx_fifo_timeout = 0;\n\tsci_port->hscif_tot = 0;\n\n\t \n\tsci_port->sampling_rate_mask = p->sampling_rate\n\t\t\t\t     ? SCI_SR(p->sampling_rate)\n\t\t\t\t     : sci_port->params->sampling_rate_mask;\n\n\tif (!early) {\n\t\tret = sci_init_clocks(sci_port, &dev->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tport->dev = &dev->dev;\n\n\t\tpm_runtime_enable(&dev->dev);\n\t}\n\n\tport->type\t\t= p->type;\n\tport->flags\t\t= UPF_FIXED_PORT | UPF_BOOT_AUTOCONF | p->flags;\n\tport->fifosize\t\t= sci_port->params->fifosize;\n\n\tif (port->type == PORT_SCI && !dev->dev.of_node) {\n\t\tif (sci_port->reg_size >= 0x20)\n\t\t\tport->regshift = 2;\n\t\telse\n\t\t\tport->regshift = 1;\n\t}\n\n\t \n\tport->irq\t\t= sci_port->irqs[SCIx_RXI_IRQ];\n\tport->irqflags\t\t= 0;\n\n\tport->serial_in\t\t= sci_serial_in;\n\tport->serial_out\t= sci_serial_out;\n\n\treturn 0;\n}\n\nstatic void sci_cleanup_single(struct sci_port *port)\n{\n\tpm_runtime_disable(port->port.dev);\n}\n\n#if defined(CONFIG_SERIAL_SH_SCI_CONSOLE) || \\\n    defined(CONFIG_SERIAL_SH_SCI_EARLYCON)\nstatic void serial_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tsci_poll_put_char(port, ch);\n}\n\n \nstatic void serial_console_write(struct console *co, const char *s,\n\t\t\t\t unsigned count)\n{\n\tstruct sci_port *sci_port = &sci_ports[co->index];\n\tstruct uart_port *port = &sci_port->port;\n\tunsigned short bits, ctrl, ctrl_temp;\n\tunsigned long flags;\n\tint locked = 1;\n\n\tif (port->sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&port->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tctrl = serial_port_in(port, SCSCR);\n\tctrl_temp = SCSCR_RE | SCSCR_TE |\n\t\t    (sci_port->cfg->scscr & ~(SCSCR_CKE1 | SCSCR_CKE0)) |\n\t\t    (ctrl & (SCSCR_CKE1 | SCSCR_CKE0));\n\tserial_port_out(port, SCSCR, ctrl_temp | sci_port->hscif_tot);\n\n\tuart_console_write(port, s, count, serial_console_putchar);\n\n\t \n\tbits = SCxSR_TDxE(port) | SCxSR_TEND(port);\n\twhile ((serial_port_in(port, SCxSR) & bits) != bits)\n\t\tcpu_relax();\n\n\t \n\tserial_port_out(port, SCSCR, ctrl);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int serial_console_setup(struct console *co, char *options)\n{\n\tstruct sci_port *sci_port;\n\tstruct uart_port *port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret;\n\n\t \n\tif (co->index < 0 || co->index >= SCI_NPORTS)\n\t\treturn -ENODEV;\n\n\tsci_port = &sci_ports[co->index];\n\tport = &sci_port->port;\n\n\t \n\tif (!port->ops)\n\t\treturn -ENODEV;\n\n\tret = sci_remap_port(port);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct console serial_console = {\n\t.name\t\t= \"ttySC\",\n\t.device\t\t= uart_console_device,\n\t.write\t\t= serial_console_write,\n\t.setup\t\t= serial_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &sci_uart_driver,\n};\n\n#ifdef CONFIG_SUPERH\nstatic char early_serial_buf[32];\n\nstatic int early_serial_console_setup(struct console *co, char *options)\n{\n\t \n\tWARN_ON(options);\n\n\treturn serial_console_setup(co, early_serial_buf);\n}\n\nstatic struct console early_serial_console = {\n\t.name           = \"early_ttySC\",\n\t.write          = serial_console_write,\n\t.setup\t\t= early_serial_console_setup,\n\t.flags          = CON_PRINTBUFFER,\n\t.index\t\t= -1,\n};\n\nstatic int sci_probe_earlyprintk(struct platform_device *pdev)\n{\n\tconst struct plat_sci_port *cfg = dev_get_platdata(&pdev->dev);\n\n\tif (early_serial_console.data)\n\t\treturn -EEXIST;\n\n\tearly_serial_console.index = pdev->id;\n\n\tsci_init_single(pdev, &sci_ports[pdev->id], pdev->id, cfg, true);\n\n\tif (!strstr(early_serial_buf, \"keep\"))\n\t\tearly_serial_console.flags |= CON_BOOT;\n\n\tregister_console(&early_serial_console);\n\treturn 0;\n}\n#endif\n\n#define SCI_CONSOLE\t(&serial_console)\n\n#else\nstatic inline int sci_probe_earlyprintk(struct platform_device *pdev)\n{\n\treturn -EINVAL;\n}\n\n#define SCI_CONSOLE\tNULL\n\n#endif  \n\nstatic const char banner[] __initconst = \"SuperH (H)SCI(F) driver initialized\";\n\nstatic DEFINE_MUTEX(sci_uart_registration_lock);\nstatic struct uart_driver sci_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"sci\",\n\t.dev_name\t= \"ttySC\",\n\t.major\t\t= SCI_MAJOR,\n\t.minor\t\t= SCI_MINOR_START,\n\t.nr\t\t= SCI_NPORTS,\n\t.cons\t\t= SCI_CONSOLE,\n};\n\nstatic int sci_remove(struct platform_device *dev)\n{\n\tstruct sci_port *port = platform_get_drvdata(dev);\n\tunsigned int type = port->port.type;\t \n\n\tsci_ports_in_use &= ~BIT(port->port.line);\n\tuart_remove_one_port(&sci_uart_driver, &port->port);\n\n\tsci_cleanup_single(port);\n\n\tif (port->port.fifosize > 1)\n\t\tdevice_remove_file(&dev->dev, &dev_attr_rx_fifo_trigger);\n\tif (type == PORT_SCIFA || type == PORT_SCIFB || type == PORT_HSCIF)\n\t\tdevice_remove_file(&dev->dev, &dev_attr_rx_fifo_timeout);\n\n\treturn 0;\n}\n\n\n#define SCI_OF_DATA(type, regtype)\t(void *)((type) << 16 | (regtype))\n#define SCI_OF_TYPE(data)\t\t((unsigned long)(data) >> 16)\n#define SCI_OF_REGTYPE(data)\t\t((unsigned long)(data) & 0xffff)\n\nstatic const struct of_device_id of_sci_match[] __maybe_unused = {\n\t \n\t{\n\t\t.compatible = \"renesas,scif-r7s72100\",\n\t\t.data = SCI_OF_DATA(PORT_SCIF, SCIx_SH2_SCIF_FIFODATA_REGTYPE),\n\t},\n\t{\n\t\t.compatible = \"renesas,scif-r7s9210\",\n\t\t.data = SCI_OF_DATA(PORT_SCIF, SCIx_RZ_SCIFA_REGTYPE),\n\t},\n\t{\n\t\t.compatible = \"renesas,scif-r9a07g044\",\n\t\t.data = SCI_OF_DATA(PORT_SCIF, SCIx_RZ_SCIFA_REGTYPE),\n\t},\n\t \n\t{\n\t\t.compatible = \"renesas,rcar-gen1-scif\",\n\t\t.data = SCI_OF_DATA(PORT_SCIF, SCIx_SH4_SCIF_BRG_REGTYPE),\n\t}, {\n\t\t.compatible = \"renesas,rcar-gen2-scif\",\n\t\t.data = SCI_OF_DATA(PORT_SCIF, SCIx_SH4_SCIF_BRG_REGTYPE),\n\t}, {\n\t\t.compatible = \"renesas,rcar-gen3-scif\",\n\t\t.data = SCI_OF_DATA(PORT_SCIF, SCIx_SH4_SCIF_BRG_REGTYPE),\n\t}, {\n\t\t.compatible = \"renesas,rcar-gen4-scif\",\n\t\t.data = SCI_OF_DATA(PORT_SCIF, SCIx_SH4_SCIF_BRG_REGTYPE),\n\t},\n\t \n\t{\n\t\t.compatible = \"renesas,scif\",\n\t\t.data = SCI_OF_DATA(PORT_SCIF, SCIx_SH4_SCIF_REGTYPE),\n\t}, {\n\t\t.compatible = \"renesas,scifa\",\n\t\t.data = SCI_OF_DATA(PORT_SCIFA, SCIx_SCIFA_REGTYPE),\n\t}, {\n\t\t.compatible = \"renesas,scifb\",\n\t\t.data = SCI_OF_DATA(PORT_SCIFB, SCIx_SCIFB_REGTYPE),\n\t}, {\n\t\t.compatible = \"renesas,hscif\",\n\t\t.data = SCI_OF_DATA(PORT_HSCIF, SCIx_HSCIF_REGTYPE),\n\t}, {\n\t\t.compatible = \"renesas,sci\",\n\t\t.data = SCI_OF_DATA(PORT_SCI, SCIx_SCI_REGTYPE),\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, of_sci_match);\n\nstatic void sci_reset_control_assert(void *data)\n{\n\treset_control_assert(data);\n}\n\nstatic struct plat_sci_port *sci_parse_dt(struct platform_device *pdev,\n\t\t\t\t\t  unsigned int *dev_id)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct reset_control *rstc;\n\tstruct plat_sci_port *p;\n\tstruct sci_port *sp;\n\tconst void *data;\n\tint id, ret;\n\n\tif (!IS_ENABLED(CONFIG_OF) || !np)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\n\trstc = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(rstc))\n\t\treturn ERR_PTR(dev_err_probe(&pdev->dev, PTR_ERR(rstc),\n\t\t\t\t\t     \"failed to get reset ctrl\\n\"));\n\n\tret = reset_control_deassert(rstc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to deassert reset %d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = devm_add_action_or_reset(&pdev->dev, sci_reset_control_assert, rstc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register assert devm action, %d\\n\",\n\t\t\tret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tp = devm_kzalloc(&pdev->dev, sizeof(struct plat_sci_port), GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tid = of_alias_get_id(np, \"serial\");\n\tif (id < 0 && ~sci_ports_in_use)\n\t\tid = ffz(sci_ports_in_use);\n\tif (id < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias id (%d)\\n\", id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (id >= ARRAY_SIZE(sci_ports)) {\n\t\tdev_err(&pdev->dev, \"serial%d out of range\\n\", id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsp = &sci_ports[id];\n\t*dev_id = id;\n\n\tp->type = SCI_OF_TYPE(data);\n\tp->regtype = SCI_OF_REGTYPE(data);\n\n\tsp->has_rtscts = of_property_read_bool(np, \"uart-has-rtscts\");\n\n\treturn p;\n}\n\nstatic int sci_probe_single(struct platform_device *dev,\n\t\t\t\t      unsigned int index,\n\t\t\t\t      struct plat_sci_port *p,\n\t\t\t\t      struct sci_port *sciport)\n{\n\tint ret;\n\n\t \n\tif (unlikely(index >= SCI_NPORTS)) {\n\t\tdev_notice(&dev->dev, \"Attempting to register port %d when only %d are available\\n\",\n\t\t\t   index+1, SCI_NPORTS);\n\t\tdev_notice(&dev->dev, \"Consider bumping CONFIG_SERIAL_SH_SCI_NR_UARTS!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tBUILD_BUG_ON(SCI_NPORTS > sizeof(sci_ports_in_use) * 8);\n\tif (sci_ports_in_use & BIT(index))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&sci_uart_registration_lock);\n\tif (!sci_uart_driver.state) {\n\t\tret = uart_register_driver(&sci_uart_driver);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&sci_uart_registration_lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmutex_unlock(&sci_uart_registration_lock);\n\n\tret = sci_init_single(dev, sciport, index, p, false);\n\tif (ret)\n\t\treturn ret;\n\n\tsciport->gpios = mctrl_gpio_init(&sciport->port, 0);\n\tif (IS_ERR(sciport->gpios))\n\t\treturn PTR_ERR(sciport->gpios);\n\n\tif (sciport->has_rtscts) {\n\t\tif (mctrl_gpio_to_gpiod(sciport->gpios, UART_GPIO_CTS) ||\n\t\t    mctrl_gpio_to_gpiod(sciport->gpios, UART_GPIO_RTS)) {\n\t\t\tdev_err(&dev->dev, \"Conflicting RTS/CTS config\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsciport->port.flags |= UPF_HARD_FLOW;\n\t}\n\n\tret = uart_add_one_port(&sci_uart_driver, &sciport->port);\n\tif (ret) {\n\t\tsci_cleanup_single(sciport);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sci_probe(struct platform_device *dev)\n{\n\tstruct plat_sci_port *p;\n\tstruct sci_port *sp;\n\tunsigned int dev_id;\n\tint ret;\n\n\t \n#ifdef CONFIG_SUPERH\n\tif (is_sh_early_platform_device(dev))\n\t\treturn sci_probe_earlyprintk(dev);\n#endif\n\n\tif (dev->dev.of_node) {\n\t\tp = sci_parse_dt(dev, &dev_id);\n\t\tif (IS_ERR(p))\n\t\t\treturn PTR_ERR(p);\n\t} else {\n\t\tp = dev->dev.platform_data;\n\t\tif (p == NULL) {\n\t\t\tdev_err(&dev->dev, \"no platform data supplied\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_id = dev->id;\n\t}\n\n\tsp = &sci_ports[dev_id];\n\tplatform_set_drvdata(dev, sp);\n\n\tret = sci_probe_single(dev, dev_id, p, sp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sp->port.fifosize > 1) {\n\t\tret = device_create_file(&dev->dev, &dev_attr_rx_fifo_trigger);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (sp->port.type == PORT_SCIFA || sp->port.type == PORT_SCIFB ||\n\t    sp->port.type == PORT_HSCIF) {\n\t\tret = device_create_file(&dev->dev, &dev_attr_rx_fifo_timeout);\n\t\tif (ret) {\n\t\t\tif (sp->port.fifosize > 1) {\n\t\t\t\tdevice_remove_file(&dev->dev,\n\t\t\t\t\t\t   &dev_attr_rx_fifo_trigger);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n#ifdef CONFIG_SH_STANDARD_BIOS\n\tsh_bios_gdb_detach();\n#endif\n\n\tsci_ports_in_use |= BIT(dev_id);\n\treturn 0;\n}\n\nstatic __maybe_unused int sci_suspend(struct device *dev)\n{\n\tstruct sci_port *sport = dev_get_drvdata(dev);\n\n\tif (sport)\n\t\tuart_suspend_port(&sci_uart_driver, &sport->port);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int sci_resume(struct device *dev)\n{\n\tstruct sci_port *sport = dev_get_drvdata(dev);\n\n\tif (sport)\n\t\tuart_resume_port(&sci_uart_driver, &sport->port);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(sci_dev_pm_ops, sci_suspend, sci_resume);\n\nstatic struct platform_driver sci_driver = {\n\t.probe\t\t= sci_probe,\n\t.remove\t\t= sci_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"sh-sci\",\n\t\t.pm\t= &sci_dev_pm_ops,\n\t\t.of_match_table = of_match_ptr(of_sci_match),\n\t},\n};\n\nstatic int __init sci_init(void)\n{\n\tpr_info(\"%s\\n\", banner);\n\n\treturn platform_driver_register(&sci_driver);\n}\n\nstatic void __exit sci_exit(void)\n{\n\tplatform_driver_unregister(&sci_driver);\n\n\tif (sci_uart_driver.state)\n\t\tuart_unregister_driver(&sci_uart_driver);\n}\n\n#if defined(CONFIG_SUPERH) && defined(CONFIG_SERIAL_SH_SCI_CONSOLE)\nsh_early_platform_init_buffer(\"earlyprintk\", &sci_driver,\n\t\t\t   early_serial_buf, ARRAY_SIZE(early_serial_buf));\n#endif\n#ifdef CONFIG_SERIAL_SH_SCI_EARLYCON\nstatic struct plat_sci_port port_cfg __initdata;\n\nstatic int __init early_console_setup(struct earlycon_device *device,\n\t\t\t\t      int type)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->port.serial_in = sci_serial_in;\n\tdevice->port.serial_out\t= sci_serial_out;\n\tdevice->port.type = type;\n\tmemcpy(&sci_ports[0].port, &device->port, sizeof(struct uart_port));\n\tport_cfg.type = type;\n\tsci_ports[0].cfg = &port_cfg;\n\tsci_ports[0].params = sci_probe_regmap(&port_cfg);\n\tport_cfg.scscr = sci_serial_in(&sci_ports[0].port, SCSCR);\n\tsci_serial_out(&sci_ports[0].port, SCSCR,\n\t\t       SCSCR_RE | SCSCR_TE | port_cfg.scscr);\n\n\tdevice->con->write = serial_console_write;\n\treturn 0;\n}\nstatic int __init sci_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t  const char *opt)\n{\n\treturn early_console_setup(device, PORT_SCI);\n}\nstatic int __init scif_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t  const char *opt)\n{\n\treturn early_console_setup(device, PORT_SCIF);\n}\nstatic int __init rzscifa_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t  const char *opt)\n{\n\tport_cfg.regtype = SCIx_RZ_SCIFA_REGTYPE;\n\treturn early_console_setup(device, PORT_SCIF);\n}\n\nstatic int __init scifa_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t  const char *opt)\n{\n\treturn early_console_setup(device, PORT_SCIFA);\n}\nstatic int __init scifb_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t  const char *opt)\n{\n\treturn early_console_setup(device, PORT_SCIFB);\n}\nstatic int __init hscif_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t  const char *opt)\n{\n\treturn early_console_setup(device, PORT_HSCIF);\n}\n\nOF_EARLYCON_DECLARE(sci, \"renesas,sci\", sci_early_console_setup);\nOF_EARLYCON_DECLARE(scif, \"renesas,scif\", scif_early_console_setup);\nOF_EARLYCON_DECLARE(scif, \"renesas,scif-r7s9210\", rzscifa_early_console_setup);\nOF_EARLYCON_DECLARE(scif, \"renesas,scif-r9a07g044\", rzscifa_early_console_setup);\nOF_EARLYCON_DECLARE(scifa, \"renesas,scifa\", scifa_early_console_setup);\nOF_EARLYCON_DECLARE(scifb, \"renesas,scifb\", scifb_early_console_setup);\nOF_EARLYCON_DECLARE(hscif, \"renesas,hscif\", hscif_early_console_setup);\n#endif  \n\nmodule_init(sci_init);\nmodule_exit(sci_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:sh-sci\");\nMODULE_AUTHOR(\"Paul Mundt\");\nMODULE_DESCRIPTION(\"SuperH (H)SCI(F) serial driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}