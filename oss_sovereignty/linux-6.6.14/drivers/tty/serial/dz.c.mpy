{
  "module_name": "dz.c",
  "hash_id": "41a3e4cfc7f2b9c3702cbbcec2fb639b99d8fdc2201e1023aaaf0b182686d006",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/dz.c",
  "human_readable_source": "\n \n\n#undef DEBUG_DZ\n\n#include <linux/bitops.h>\n#include <linux/compiler.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/module.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#include <linux/atomic.h>\n#include <linux/io.h>\n#include <asm/bootinfo.h>\n\n#include <asm/dec/interrupts.h>\n#include <asm/dec/kn01.h>\n#include <asm/dec/kn02.h>\n#include <asm/dec/machtype.h>\n#include <asm/dec/prom.h>\n#include <asm/dec/system.h>\n\n#include \"dz.h\"\n\n\nMODULE_DESCRIPTION(\"DECstation DZ serial driver\");\nMODULE_LICENSE(\"GPL\");\n\n\nstatic char dz_name[] __initdata = \"DECstation DZ serial driver version \";\nstatic char dz_version[] __initdata = \"1.04\";\n\nstruct dz_port {\n\tstruct dz_mux\t\t*mux;\n\tstruct uart_port\tport;\n\tunsigned int\t\tcflag;\n};\n\nstruct dz_mux {\n\tstruct dz_port\t\tdport[DZ_NB_PORT];\n\tatomic_t\t\tmap_guard;\n\tatomic_t\t\tirq_guard;\n\tint\t\t\tinitialised;\n};\n\nstatic struct dz_mux dz_mux;\n\nstatic inline struct dz_port *to_dport(struct uart_port *uport)\n{\n\treturn container_of(uport, struct dz_port, port);\n}\n\n \n\nstatic u16 dz_in(struct dz_port *dport, unsigned offset)\n{\n\tvoid __iomem *addr = dport->port.membase + offset;\n\n\treturn readw(addr);\n}\n\nstatic void dz_out(struct dz_port *dport, unsigned offset, u16 value)\n{\n\tvoid __iomem *addr = dport->port.membase + offset;\n\n\twritew(value, addr);\n}\n\n \n\nstatic void dz_stop_tx(struct uart_port *uport)\n{\n\tstruct dz_port *dport = to_dport(uport);\n\tu16 tmp, mask = 1 << dport->port.line;\n\n\ttmp = dz_in(dport, DZ_TCR);\t \n\ttmp &= ~mask;\t\t\t \n\tdz_out(dport, DZ_TCR, tmp);\n}\n\nstatic void dz_start_tx(struct uart_port *uport)\n{\n\tstruct dz_port *dport = to_dport(uport);\n\tu16 tmp, mask = 1 << dport->port.line;\n\n\ttmp = dz_in(dport, DZ_TCR);\t \n\ttmp |= mask;\t\t\t \n\tdz_out(dport, DZ_TCR, tmp);\n}\n\nstatic void dz_stop_rx(struct uart_port *uport)\n{\n\tstruct dz_port *dport = to_dport(uport);\n\n\tdport->cflag &= ~DZ_RXENAB;\n\tdz_out(dport, DZ_LPR, dport->cflag);\n}\n\n \n\n \nstatic inline void dz_receive_chars(struct dz_mux *mux)\n{\n\tstruct uart_port *uport;\n\tstruct dz_port *dport = &mux->dport[0];\n\tstruct uart_icount *icount;\n\tint lines_rx[DZ_NB_PORT] = { [0 ... DZ_NB_PORT - 1] = 0 };\n\tu16 status;\n\tu8 ch, flag;\n\tint i;\n\n\twhile ((status = dz_in(dport, DZ_RBUF)) & DZ_DVAL) {\n\t\tdport = &mux->dport[LINE(status)];\n\t\tuport = &dport->port;\n\n\t\tch = UCHAR(status);\t\t \n\t\tflag = TTY_NORMAL;\n\n\t\ticount = &uport->icount;\n\t\ticount->rx++;\n\n\t\tif (unlikely(status & (DZ_OERR | DZ_FERR | DZ_PERR))) {\n\n\t\t\t \n\t\t\tif (!ch) {\n\t\t\t\tstatus |= (status & DZ_FERR) >>\n\t\t\t\t\t  (ffs(DZ_FERR) - ffs(DZ_BREAK));\n\t\t\t\tstatus &= ~DZ_FERR;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (status & DZ_BREAK) {\n\t\t\t\ticount->brk++;\n\t\t\t\tif (uart_handle_break(uport))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (status & DZ_FERR)\n\t\t\t\ticount->frame++;\n\t\t\telse if (status & DZ_PERR)\n\t\t\t\ticount->parity++;\n\t\t\tif (status & DZ_OERR)\n\t\t\t\ticount->overrun++;\n\n\t\t\tstatus &= uport->read_status_mask;\n\t\t\tif (status & DZ_BREAK)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (status & DZ_FERR)\n\t\t\t\tflag = TTY_FRAME;\n\t\t\telse if (status & DZ_PERR)\n\t\t\t\tflag = TTY_PARITY;\n\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(uport, ch))\n\t\t\tcontinue;\n\n\t\tuart_insert_char(uport, status, DZ_OERR, ch, flag);\n\t\tlines_rx[LINE(status)] = 1;\n\t}\n\tfor (i = 0; i < DZ_NB_PORT; i++)\n\t\tif (lines_rx[i])\n\t\t\ttty_flip_buffer_push(&mux->dport[i].port.state->port);\n}\n\n \nstatic inline void dz_transmit_chars(struct dz_mux *mux)\n{\n\tstruct dz_port *dport = &mux->dport[0];\n\tstruct circ_buf *xmit;\n\tunsigned char tmp;\n\tu16 status;\n\n\tstatus = dz_in(dport, DZ_CSR);\n\tdport = &mux->dport[LINE(status)];\n\txmit = &dport->port.state->xmit;\n\n\tif (dport->port.x_char) {\t\t \n\t\tdz_out(dport, DZ_TDR, dport->port.x_char);\n\t\tdport->port.icount.tx++;\n\t\tdport->port.x_char = 0;\n\t\treturn;\n\t}\n\t \n\tif (uart_circ_empty(xmit) || uart_tx_stopped(&dport->port)) {\n\t\tspin_lock(&dport->port.lock);\n\t\tdz_stop_tx(&dport->port);\n\t\tspin_unlock(&dport->port.lock);\n\t\treturn;\n\t}\n\n\t \n\ttmp = xmit->buf[xmit->tail];\n\tdz_out(dport, DZ_TDR, tmp);\n\tuart_xmit_advance(&dport->port, 1);\n\n\tif (uart_circ_chars_pending(xmit) < DZ_WAKEUP_CHARS)\n\t\tuart_write_wakeup(&dport->port);\n\n\t \n\tif (uart_circ_empty(xmit)) {\n\t\tspin_lock(&dport->port.lock);\n\t\tdz_stop_tx(&dport->port);\n\t\tspin_unlock(&dport->port.lock);\n\t}\n}\n\n \nstatic inline void check_modem_status(struct dz_port *dport)\n{\n\t \n\tu16 status;\n\n\t \n\tif (dport->port.line != DZ_MODEM)\n\t\treturn;\n\n\tstatus = dz_in(dport, DZ_MSR);\n\n\t \n\tif (status)\n\t\tdport->port.icount.dsr++;\n}\n\n \nstatic irqreturn_t dz_interrupt(int irq, void *dev_id)\n{\n\tstruct dz_mux *mux = dev_id;\n\tstruct dz_port *dport = &mux->dport[0];\n\tu16 status;\n\n\t \n\tstatus = dz_in(dport, DZ_CSR);\n\n\tif ((status & (DZ_RDONE | DZ_RIE)) == (DZ_RDONE | DZ_RIE))\n\t\tdz_receive_chars(mux);\n\n\tif ((status & (DZ_TRDY | DZ_TIE)) == (DZ_TRDY | DZ_TIE))\n\t\tdz_transmit_chars(mux);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic unsigned int dz_get_mctrl(struct uart_port *uport)\n{\n\t \n\tstruct dz_port *dport = to_dport(uport);\n\tunsigned int mctrl = TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n\n\tif (dport->port.line == DZ_MODEM) {\n\t\tif (dz_in(dport, DZ_MSR) & DZ_MODEM_DSR)\n\t\t\tmctrl &= ~TIOCM_DSR;\n\t}\n\n\treturn mctrl;\n}\n\nstatic void dz_set_mctrl(struct uart_port *uport, unsigned int mctrl)\n{\n\t \n\tstruct dz_port *dport = to_dport(uport);\n\tu16 tmp;\n\n\tif (dport->port.line == DZ_MODEM) {\n\t\ttmp = dz_in(dport, DZ_TCR);\n\t\tif (mctrl & TIOCM_DTR)\n\t\t\ttmp &= ~DZ_MODEM_DTR;\n\t\telse\n\t\t\ttmp |= DZ_MODEM_DTR;\n\t\tdz_out(dport, DZ_TCR, tmp);\n\t}\n}\n\n \nstatic int dz_startup(struct uart_port *uport)\n{\n\tstruct dz_port *dport = to_dport(uport);\n\tstruct dz_mux *mux = dport->mux;\n\tunsigned long flags;\n\tint irq_guard;\n\tint ret;\n\tu16 tmp;\n\n\tirq_guard = atomic_add_return(1, &mux->irq_guard);\n\tif (irq_guard != 1)\n\t\treturn 0;\n\n\tret = request_irq(dport->port.irq, dz_interrupt,\n\t\t\t  IRQF_SHARED, \"dz\", mux);\n\tif (ret) {\n\t\tatomic_add(-1, &mux->irq_guard);\n\t\tprintk(KERN_ERR \"dz: Cannot get IRQ %d!\\n\", dport->port.irq);\n\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&dport->port.lock, flags);\n\n\t \n\ttmp = dz_in(dport, DZ_CSR);\n\ttmp |= DZ_RIE | DZ_TIE;\n\tdz_out(dport, DZ_CSR, tmp);\n\n\tspin_unlock_irqrestore(&dport->port.lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void dz_shutdown(struct uart_port *uport)\n{\n\tstruct dz_port *dport = to_dport(uport);\n\tstruct dz_mux *mux = dport->mux;\n\tunsigned long flags;\n\tint irq_guard;\n\tu16 tmp;\n\n\tspin_lock_irqsave(&dport->port.lock, flags);\n\tdz_stop_tx(&dport->port);\n\tspin_unlock_irqrestore(&dport->port.lock, flags);\n\n\tirq_guard = atomic_add_return(-1, &mux->irq_guard);\n\tif (!irq_guard) {\n\t\t \n\t\ttmp = dz_in(dport, DZ_CSR);\n\t\ttmp &= ~(DZ_RIE | DZ_TIE);\n\t\tdz_out(dport, DZ_CSR, tmp);\n\n\t\tfree_irq(dport->port.irq, mux);\n\t}\n}\n\n \nstatic unsigned int dz_tx_empty(struct uart_port *uport)\n{\n\tstruct dz_port *dport = to_dport(uport);\n\tunsigned short tmp, mask = 1 << dport->port.line;\n\n\ttmp = dz_in(dport, DZ_TCR);\n\ttmp &= mask;\n\n\treturn tmp ? 0 : TIOCSER_TEMT;\n}\n\nstatic void dz_break_ctl(struct uart_port *uport, int break_state)\n{\n\t \n\tstruct dz_port *dport = to_dport(uport);\n\tunsigned long flags;\n\tunsigned short tmp, mask = 1 << dport->port.line;\n\n\tspin_lock_irqsave(&uport->lock, flags);\n\ttmp = dz_in(dport, DZ_TCR);\n\tif (break_state)\n\t\ttmp |= mask;\n\telse\n\t\ttmp &= ~mask;\n\tdz_out(dport, DZ_TCR, tmp);\n\tspin_unlock_irqrestore(&uport->lock, flags);\n}\n\nstatic int dz_encode_baud_rate(unsigned int baud)\n{\n\tswitch (baud) {\n\tcase 50:\n\t\treturn DZ_B50;\n\tcase 75:\n\t\treturn DZ_B75;\n\tcase 110:\n\t\treturn DZ_B110;\n\tcase 134:\n\t\treturn DZ_B134;\n\tcase 150:\n\t\treturn DZ_B150;\n\tcase 300:\n\t\treturn DZ_B300;\n\tcase 600:\n\t\treturn DZ_B600;\n\tcase 1200:\n\t\treturn DZ_B1200;\n\tcase 1800:\n\t\treturn DZ_B1800;\n\tcase 2000:\n\t\treturn DZ_B2000;\n\tcase 2400:\n\t\treturn DZ_B2400;\n\tcase 3600:\n\t\treturn DZ_B3600;\n\tcase 4800:\n\t\treturn DZ_B4800;\n\tcase 7200:\n\t\treturn DZ_B7200;\n\tcase 9600:\n\t\treturn DZ_B9600;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n\nstatic void dz_reset(struct dz_port *dport)\n{\n\tstruct dz_mux *mux = dport->mux;\n\n\tif (mux->initialised)\n\t\treturn;\n\n\tdz_out(dport, DZ_CSR, DZ_CLR);\n\twhile (dz_in(dport, DZ_CSR) & DZ_CLR);\n\tiob();\n\n\t \n\tdz_out(dport, DZ_CSR, DZ_MSE);\n\n\tmux->initialised = 1;\n}\n\nstatic void dz_set_termios(struct uart_port *uport, struct ktermios *termios,\n\t\t\t   const struct ktermios *old_termios)\n{\n\tstruct dz_port *dport = to_dport(uport);\n\tunsigned long flags;\n\tunsigned int cflag, baud;\n\tint bflag;\n\n\tcflag = dport->port.line;\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tcflag |= DZ_CS5;\n\t\tbreak;\n\tcase CS6:\n\t\tcflag |= DZ_CS6;\n\t\tbreak;\n\tcase CS7:\n\t\tcflag |= DZ_CS7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tcflag |= DZ_CS8;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tcflag |= DZ_CSTOPB;\n\tif (termios->c_cflag & PARENB)\n\t\tcflag |= DZ_PARENB;\n\tif (termios->c_cflag & PARODD)\n\t\tcflag |= DZ_PARODD;\n\n\tbaud = uart_get_baud_rate(uport, termios, old_termios, 50, 9600);\n\tbflag = dz_encode_baud_rate(baud);\n\tif (bflag < 0)\t{\n\t\tif (old_termios) {\n\t\t\t \n\t\t\tbaud = tty_termios_baud_rate(old_termios);\n\t\t\tbflag = dz_encode_baud_rate(baud);\n\t\t}\n\t\tif (bflag < 0)\t{\t\t \n\t\t\tbaud = 9600;\n\t\t\tbflag = DZ_B9600;\n\t\t}\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\t}\n\tcflag |= bflag;\n\n\tif (termios->c_cflag & CREAD)\n\t\tcflag |= DZ_RXENAB;\n\n\tspin_lock_irqsave(&dport->port.lock, flags);\n\n\tuart_update_timeout(uport, termios->c_cflag, baud);\n\n\tdz_out(dport, DZ_LPR, cflag);\n\tdport->cflag = cflag;\n\n\t \n\tdport->port.read_status_mask = DZ_OERR;\n\tif (termios->c_iflag & INPCK)\n\t\tdport->port.read_status_mask |= DZ_FERR | DZ_PERR;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tdport->port.read_status_mask |= DZ_BREAK;\n\n\t \n\tuport->ignore_status_mask = 0;\n\tif ((termios->c_iflag & (IGNPAR | IGNBRK)) == (IGNPAR | IGNBRK))\n\t\tdport->port.ignore_status_mask |= DZ_OERR;\n\tif (termios->c_iflag & IGNPAR)\n\t\tdport->port.ignore_status_mask |= DZ_FERR | DZ_PERR;\n\tif (termios->c_iflag & IGNBRK)\n\t\tdport->port.ignore_status_mask |= DZ_BREAK;\n\n\tspin_unlock_irqrestore(&dport->port.lock, flags);\n}\n\n \nstatic void dz_pm(struct uart_port *uport, unsigned int state,\n\t\t  unsigned int oldstate)\n{\n\tstruct dz_port *dport = to_dport(uport);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dport->port.lock, flags);\n\tif (state < 3)\n\t\tdz_start_tx(&dport->port);\n\telse\n\t\tdz_stop_tx(&dport->port);\n\tspin_unlock_irqrestore(&dport->port.lock, flags);\n}\n\n\nstatic const char *dz_type(struct uart_port *uport)\n{\n\treturn \"DZ\";\n}\n\nstatic void dz_release_port(struct uart_port *uport)\n{\n\tstruct dz_mux *mux = to_dport(uport)->mux;\n\tint map_guard;\n\n\tiounmap(uport->membase);\n\tuport->membase = NULL;\n\n\tmap_guard = atomic_add_return(-1, &mux->map_guard);\n\tif (!map_guard)\n\t\trelease_mem_region(uport->mapbase, dec_kn_slot_size);\n}\n\nstatic int dz_map_port(struct uart_port *uport)\n{\n\tif (!uport->membase)\n\t\tuport->membase = ioremap(uport->mapbase,\n\t\t\t\t\t\t dec_kn_slot_size);\n\tif (!uport->membase) {\n\t\tprintk(KERN_ERR \"dz: Cannot map MMIO\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int dz_request_port(struct uart_port *uport)\n{\n\tstruct dz_mux *mux = to_dport(uport)->mux;\n\tint map_guard;\n\tint ret;\n\n\tmap_guard = atomic_add_return(1, &mux->map_guard);\n\tif (map_guard == 1) {\n\t\tif (!request_mem_region(uport->mapbase, dec_kn_slot_size,\n\t\t\t\t\t\"dz\")) {\n\t\t\tatomic_add(-1, &mux->map_guard);\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"dz: Unable to reserve MMIO resource\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tret = dz_map_port(uport);\n\tif (ret) {\n\t\tmap_guard = atomic_add_return(-1, &mux->map_guard);\n\t\tif (!map_guard)\n\t\t\trelease_mem_region(uport->mapbase, dec_kn_slot_size);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void dz_config_port(struct uart_port *uport, int flags)\n{\n\tstruct dz_port *dport = to_dport(uport);\n\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tif (dz_request_port(uport))\n\t\t\treturn;\n\n\t\tuport->type = PORT_DZ;\n\n\t\tdz_reset(dport);\n\t}\n}\n\n \nstatic int dz_verify_port(struct uart_port *uport, struct serial_struct *ser)\n{\n\tint ret = 0;\n\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_DZ)\n\t\tret = -EINVAL;\n\tif (ser->irq != uport->irq)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\nstatic const struct uart_ops dz_ops = {\n\t.tx_empty\t= dz_tx_empty,\n\t.get_mctrl\t= dz_get_mctrl,\n\t.set_mctrl\t= dz_set_mctrl,\n\t.stop_tx\t= dz_stop_tx,\n\t.start_tx\t= dz_start_tx,\n\t.stop_rx\t= dz_stop_rx,\n\t.break_ctl\t= dz_break_ctl,\n\t.startup\t= dz_startup,\n\t.shutdown\t= dz_shutdown,\n\t.set_termios\t= dz_set_termios,\n\t.pm\t\t= dz_pm,\n\t.type\t\t= dz_type,\n\t.release_port\t= dz_release_port,\n\t.request_port\t= dz_request_port,\n\t.config_port\t= dz_config_port,\n\t.verify_port\t= dz_verify_port,\n};\n\nstatic void __init dz_init_ports(void)\n{\n\tstatic int first = 1;\n\tunsigned long base;\n\tint line;\n\n\tif (!first)\n\t\treturn;\n\tfirst = 0;\n\n\tif (mips_machtype == MACH_DS23100 || mips_machtype == MACH_DS5100)\n\t\tbase = dec_kn_slot_base + KN01_DZ11;\n\telse\n\t\tbase = dec_kn_slot_base + KN02_DZ11;\n\n\tfor (line = 0; line < DZ_NB_PORT; line++) {\n\t\tstruct dz_port *dport = &dz_mux.dport[line];\n\t\tstruct uart_port *uport = &dport->port;\n\n\t\tdport->mux\t= &dz_mux;\n\n\t\tuport->irq\t= dec_interrupt[DEC_IRQ_DZ11];\n\t\tuport->fifosize\t= 1;\n\t\tuport->iotype\t= UPIO_MEM;\n\t\tuport->flags\t= UPF_BOOT_AUTOCONF;\n\t\tuport->ops\t= &dz_ops;\n\t\tuport->line\t= line;\n\t\tuport->mapbase\t= base;\n\t\tuport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_DZ_CONSOLE);\n\t}\n}\n\n#ifdef CONFIG_SERIAL_DZ_CONSOLE\n \nstatic void dz_console_putchar(struct uart_port *uport, unsigned char ch)\n{\n\tstruct dz_port *dport = to_dport(uport);\n\tunsigned long flags;\n\tunsigned short csr, tcr, trdy, mask;\n\tint loops = 10000;\n\n\tspin_lock_irqsave(&dport->port.lock, flags);\n\tcsr = dz_in(dport, DZ_CSR);\n\tdz_out(dport, DZ_CSR, csr & ~DZ_TIE);\n\ttcr = dz_in(dport, DZ_TCR);\n\ttcr |= 1 << dport->port.line;\n\tmask = tcr;\n\tdz_out(dport, DZ_TCR, mask);\n\tiob();\n\tspin_unlock_irqrestore(&dport->port.lock, flags);\n\n\tdo {\n\t\ttrdy = dz_in(dport, DZ_CSR);\n\t\tif (!(trdy & DZ_TRDY))\n\t\t\tcontinue;\n\t\ttrdy = (trdy & DZ_TLINE) >> 8;\n\t\tif (trdy == dport->port.line)\n\t\t\tbreak;\n\t\tmask &= ~(1 << trdy);\n\t\tdz_out(dport, DZ_TCR, mask);\n\t\tiob();\n\t\tudelay(2);\n\t} while (--loops);\n\n\tif (loops)\t\t\t\t \n\t\tdz_out(dport, DZ_TDR, ch);\n\n\tdz_out(dport, DZ_TCR, tcr);\n\tdz_out(dport, DZ_CSR, csr);\n}\n\n \nstatic void dz_console_print(struct console *co,\n\t\t\t     const char *str,\n\t\t\t     unsigned int count)\n{\n\tstruct dz_port *dport = &dz_mux.dport[co->index];\n#ifdef DEBUG_DZ\n\tprom_printf((char *) str);\n#endif\n\tuart_console_write(&dport->port, str, count, dz_console_putchar);\n}\n\nstatic int __init dz_console_setup(struct console *co, char *options)\n{\n\tstruct dz_port *dport = &dz_mux.dport[co->index];\n\tstruct uart_port *uport = &dport->port;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret;\n\n\tret = dz_map_port(uport);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_init(&dport->port.lock);\t \n\n\tdz_reset(dport);\n\tdz_pm(uport, 0, -1);\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&dport->port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver dz_reg;\nstatic struct console dz_console = {\n\t.name\t= \"ttyS\",\n\t.write\t= dz_console_print,\n\t.device\t= uart_console_device,\n\t.setup\t= dz_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,\n\t.data\t= &dz_reg,\n};\n\nstatic int __init dz_serial_console_init(void)\n{\n\tif (!IOASIC) {\n\t\tdz_init_ports();\n\t\tregister_console(&dz_console);\n\t\treturn 0;\n\t} else\n\t\treturn -ENXIO;\n}\n\nconsole_initcall(dz_serial_console_init);\n\n#define SERIAL_DZ_CONSOLE\t&dz_console\n#else\n#define SERIAL_DZ_CONSOLE\tNULL\n#endif  \n\nstatic struct uart_driver dz_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"serial\",\n\t.dev_name\t\t= \"ttyS\",\n\t.major\t\t\t= TTY_MAJOR,\n\t.minor\t\t\t= 64,\n\t.nr\t\t\t= DZ_NB_PORT,\n\t.cons\t\t\t= SERIAL_DZ_CONSOLE,\n};\n\nstatic int __init dz_init(void)\n{\n\tint ret, i;\n\n\tif (IOASIC)\n\t\treturn -ENXIO;\n\n\tprintk(\"%s%s\\n\", dz_name, dz_version);\n\n\tdz_init_ports();\n\n\tret = uart_register_driver(&dz_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < DZ_NB_PORT; i++)\n\t\tuart_add_one_port(&dz_reg, &dz_mux.dport[i].port);\n\n\treturn 0;\n}\n\nmodule_init(dz_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}