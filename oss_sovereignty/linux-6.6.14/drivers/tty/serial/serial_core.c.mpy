{
  "module_name": "serial_core.c",
  "hash_id": "e37b7f33fae89dac776e189e9de9c34ef22c0481ef61707318c2d34723faee18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/serial_core.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/device.h>\n#include <linux/serial.h>  \n#include <linux/serial_core.h>\n#include <linux/sysrq.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/math64.h>\n#include <linux/security.h>\n\n#include <linux/irq.h>\n#include <linux/uaccess.h>\n\n#include \"serial_base.h\"\n\n \nstatic DEFINE_MUTEX(port_mutex);\n\n \nstatic struct lock_class_key port_lock_key;\n\n#define HIGH_BITS_OFFSET\t((sizeof(long)-sizeof(int))*8)\n\n \n#define RS485_MAX_RTS_DELAY\t100  \n\nstatic void uart_change_pm(struct uart_state *state,\n\t\t\t   enum uart_pm_state pm_state);\n\nstatic void uart_port_shutdown(struct tty_port *port);\n\nstatic int uart_dcd_enabled(struct uart_port *uport)\n{\n\treturn !!(uport->status & UPSTAT_DCD_ENABLE);\n}\n\nstatic inline struct uart_port *uart_port_ref(struct uart_state *state)\n{\n\tif (atomic_add_unless(&state->refcount, 1, 0))\n\t\treturn state->uart_port;\n\treturn NULL;\n}\n\nstatic inline void uart_port_deref(struct uart_port *uport)\n{\n\tif (atomic_dec_and_test(&uport->state->refcount))\n\t\twake_up(&uport->state->remove_wait);\n}\n\n#define uart_port_lock(state, flags)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tstruct uart_port *__uport = uart_port_ref(state);\t\\\n\t\tif (__uport)\t\t\t\t\t\t\\\n\t\t\tspin_lock_irqsave(&__uport->lock, flags);\t\\\n\t\t__uport;\t\t\t\t\t\t\\\n\t})\n\n#define uart_port_unlock(uport, flags)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tstruct uart_port *__uport = uport;\t\t\t\\\n\t\tif (__uport) {\t\t\t\t\t\t\\\n\t\t\tspin_unlock_irqrestore(&__uport->lock, flags);\t\\\n\t\t\tuart_port_deref(__uport);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t})\n\nstatic inline struct uart_port *uart_port_check(struct uart_state *state)\n{\n\tlockdep_assert_held(&state->port.mutex);\n\treturn state->uart_port;\n}\n\n \nvoid uart_write_wakeup(struct uart_port *port)\n{\n\tstruct uart_state *state = port->state;\n\t \n\tBUG_ON(!state);\n\ttty_port_tty_wakeup(&state->port);\n}\nEXPORT_SYMBOL(uart_write_wakeup);\n\nstatic void uart_stop(struct tty_struct *tty)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_port *port;\n\tunsigned long flags;\n\n\tport = uart_port_lock(state, flags);\n\tif (port)\n\t\tport->ops->stop_tx(port);\n\tuart_port_unlock(port, flags);\n}\n\nstatic void __uart_start(struct uart_state *state)\n{\n\tstruct uart_port *port = state->uart_port;\n\tstruct serial_port_device *port_dev;\n\tint err;\n\n\tif (!port || port->flags & UPF_DEAD || uart_tx_stopped(port))\n\t\treturn;\n\n\tport_dev = port->port_dev;\n\n\t \n\terr = pm_runtime_get(&port_dev->dev);\n\tif (err < 0 && err != -EINPROGRESS) {\n\t\tpm_runtime_put_noidle(&port_dev->dev);\n\t\treturn;\n\t}\n\n\t \n\tif (!pm_runtime_enabled(port->dev) || pm_runtime_active(port->dev))\n\t\tport->ops->start_tx(port);\n\tpm_runtime_mark_last_busy(&port_dev->dev);\n\tpm_runtime_put_autosuspend(&port_dev->dev);\n}\n\nstatic void uart_start(struct tty_struct *tty)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_port *port;\n\tunsigned long flags;\n\n\tport = uart_port_lock(state, flags);\n\t__uart_start(state);\n\tuart_port_unlock(port, flags);\n}\n\nstatic void\nuart_update_mctrl(struct uart_port *port, unsigned int set, unsigned int clear)\n{\n\tunsigned long flags;\n\tunsigned int old;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\told = port->mctrl;\n\tport->mctrl = (old & ~clear) | set;\n\tif (old != port->mctrl && !(port->rs485.flags & SER_RS485_ENABLED))\n\t\tport->ops->set_mctrl(port, port->mctrl);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n#define uart_set_mctrl(port, set)\tuart_update_mctrl(port, set, 0)\n#define uart_clear_mctrl(port, clear)\tuart_update_mctrl(port, 0, clear)\n\nstatic void uart_port_dtr_rts(struct uart_port *uport, bool active)\n{\n\tif (active)\n\t\tuart_set_mctrl(uport, TIOCM_DTR | TIOCM_RTS);\n\telse\n\t\tuart_clear_mctrl(uport, TIOCM_DTR | TIOCM_RTS);\n}\n\n \nstatic void uart_change_line_settings(struct tty_struct *tty, struct uart_state *state,\n\t\t\t\t      const struct ktermios *old_termios)\n{\n\tstruct uart_port *uport = uart_port_check(state);\n\tstruct ktermios *termios;\n\tbool old_hw_stopped;\n\n\t \n\tif (!tty || uport->type == PORT_UNKNOWN)\n\t\treturn;\n\n\ttermios = &tty->termios;\n\tuport->ops->set_termios(uport, termios, old_termios);\n\n\t \n\tspin_lock_irq(&uport->lock);\n\tif (termios->c_cflag & CRTSCTS)\n\t\tuport->status |= UPSTAT_CTS_ENABLE;\n\telse\n\t\tuport->status &= ~UPSTAT_CTS_ENABLE;\n\n\tif (termios->c_cflag & CLOCAL)\n\t\tuport->status &= ~UPSTAT_DCD_ENABLE;\n\telse\n\t\tuport->status |= UPSTAT_DCD_ENABLE;\n\n\t \n\told_hw_stopped = uport->hw_stopped;\n\tuport->hw_stopped = uart_softcts_mode(uport) &&\n\t\t\t    !(uport->ops->get_mctrl(uport) & TIOCM_CTS);\n\tif (uport->hw_stopped != old_hw_stopped) {\n\t\tif (!old_hw_stopped)\n\t\t\tuport->ops->stop_tx(uport);\n\t\telse\n\t\t\t__uart_start(state);\n\t}\n\tspin_unlock_irq(&uport->lock);\n}\n\n \nstatic int uart_port_startup(struct tty_struct *tty, struct uart_state *state,\n\t\t\t     bool init_hw)\n{\n\tstruct uart_port *uport = uart_port_check(state);\n\tunsigned long flags;\n\tunsigned long page;\n\tint retval = 0;\n\n\tif (uport->type == PORT_UNKNOWN)\n\t\treturn 1;\n\n\t \n\tuart_change_pm(state, UART_PM_STATE_ON);\n\n\t \n\tpage = get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tuart_port_lock(state, flags);\n\tif (!state->xmit.buf) {\n\t\tstate->xmit.buf = (unsigned char *) page;\n\t\tuart_circ_clear(&state->xmit);\n\t\tuart_port_unlock(uport, flags);\n\t} else {\n\t\tuart_port_unlock(uport, flags);\n\t\t \n\t\tfree_page(page);\n\t}\n\n\tretval = uport->ops->startup(uport);\n\tif (retval == 0) {\n\t\tif (uart_console(uport) && uport->cons->cflag) {\n\t\t\ttty->termios.c_cflag = uport->cons->cflag;\n\t\t\ttty->termios.c_ispeed = uport->cons->ispeed;\n\t\t\ttty->termios.c_ospeed = uport->cons->ospeed;\n\t\t\tuport->cons->cflag = 0;\n\t\t\tuport->cons->ispeed = 0;\n\t\t\tuport->cons->ospeed = 0;\n\t\t}\n\t\t \n\t\tuart_change_line_settings(tty, state, NULL);\n\n\t\t \n\t\tif (init_hw && C_BAUD(tty))\n\t\t\tuart_port_dtr_rts(uport, true);\n\t}\n\n\t \n\tif (retval && capable(CAP_SYS_ADMIN))\n\t\treturn 1;\n\n\treturn retval;\n}\n\nstatic int uart_startup(struct tty_struct *tty, struct uart_state *state,\n\t\t\tbool init_hw)\n{\n\tstruct tty_port *port = &state->port;\n\tint retval;\n\n\tif (tty_port_initialized(port))\n\t\treturn 0;\n\n\tretval = uart_port_startup(tty, state, init_hw);\n\tif (retval)\n\t\tset_bit(TTY_IO_ERROR, &tty->flags);\n\n\treturn retval;\n}\n\n \nstatic void uart_shutdown(struct tty_struct *tty, struct uart_state *state)\n{\n\tstruct uart_port *uport = uart_port_check(state);\n\tstruct tty_port *port = &state->port;\n\tunsigned long flags;\n\tchar *xmit_buf = NULL;\n\n\t \n\tif (tty)\n\t\tset_bit(TTY_IO_ERROR, &tty->flags);\n\n\tif (tty_port_initialized(port)) {\n\t\ttty_port_set_initialized(port, false);\n\n\t\t \n\t\tif (uport && uart_console(uport) && tty) {\n\t\t\tuport->cons->cflag = tty->termios.c_cflag;\n\t\t\tuport->cons->ispeed = tty->termios.c_ispeed;\n\t\t\tuport->cons->ospeed = tty->termios.c_ospeed;\n\t\t}\n\n\t\tif (!tty || C_HUPCL(tty))\n\t\t\tuart_port_dtr_rts(uport, false);\n\n\t\tuart_port_shutdown(port);\n\t}\n\n\t \n\ttty_port_set_suspended(port, false);\n\n\t \n\tuart_port_lock(state, flags);\n\txmit_buf = state->xmit.buf;\n\tstate->xmit.buf = NULL;\n\tuart_port_unlock(uport, flags);\n\n\tfree_page((unsigned long)xmit_buf);\n}\n\n \nvoid\nuart_update_timeout(struct uart_port *port, unsigned int cflag,\n\t\t    unsigned int baud)\n{\n\tunsigned int size = tty_get_frame_size(cflag);\n\tu64 frame_time;\n\n\tframe_time = (u64)size * NSEC_PER_SEC;\n\tport->frame_time = DIV64_U64_ROUND_UP(frame_time, baud);\n}\nEXPORT_SYMBOL(uart_update_timeout);\n\n \nunsigned int\nuart_get_baud_rate(struct uart_port *port, struct ktermios *termios,\n\t\t   const struct ktermios *old, unsigned int min, unsigned int max)\n{\n\tunsigned int try;\n\tunsigned int baud;\n\tunsigned int altbaud;\n\tint hung_up = 0;\n\tupf_t flags = port->flags & UPF_SPD_MASK;\n\n\tswitch (flags) {\n\tcase UPF_SPD_HI:\n\t\taltbaud = 57600;\n\t\tbreak;\n\tcase UPF_SPD_VHI:\n\t\taltbaud = 115200;\n\t\tbreak;\n\tcase UPF_SPD_SHI:\n\t\taltbaud = 230400;\n\t\tbreak;\n\tcase UPF_SPD_WARP:\n\t\taltbaud = 460800;\n\t\tbreak;\n\tdefault:\n\t\taltbaud = 38400;\n\t\tbreak;\n\t}\n\n\tfor (try = 0; try < 2; try++) {\n\t\tbaud = tty_termios_baud_rate(termios);\n\n\t\t \n\t\tif (try == 0 && baud == 38400)\n\t\t\tbaud = altbaud;\n\n\t\t \n\t\tif (baud == 0) {\n\t\t\thung_up = 1;\n\t\t\tbaud = 9600;\n\t\t}\n\n\t\tif (baud >= min && baud <= max)\n\t\t\treturn baud;\n\n\t\t \n\t\ttermios->c_cflag &= ~CBAUD;\n\t\tif (old) {\n\t\t\tbaud = tty_termios_baud_rate(old);\n\t\t\tif (!hung_up)\n\t\t\t\ttty_termios_encode_baud_rate(termios,\n\t\t\t\t\t\t\t\tbaud, baud);\n\t\t\told = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!hung_up) {\n\t\t\tif (baud <= min)\n\t\t\t\ttty_termios_encode_baud_rate(termios,\n\t\t\t\t\t\t\tmin + 1, min + 1);\n\t\t\telse\n\t\t\t\ttty_termios_encode_baud_rate(termios,\n\t\t\t\t\t\t\tmax - 1, max - 1);\n\t\t}\n\t}\n\t \n\tWARN_ON(1);\n\treturn 0;\n}\nEXPORT_SYMBOL(uart_get_baud_rate);\n\n \nunsigned int\nuart_get_divisor(struct uart_port *port, unsigned int baud)\n{\n\tunsigned int quot;\n\n\t \n\tif (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST)\n\t\tquot = port->custom_divisor;\n\telse\n\t\tquot = DIV_ROUND_CLOSEST(port->uartclk, 16 * baud);\n\n\treturn quot;\n}\nEXPORT_SYMBOL(uart_get_divisor);\n\nstatic int uart_put_char(struct tty_struct *tty, u8 c)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_port *port;\n\tstruct circ_buf *circ;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tcirc = &state->xmit;\n\tport = uart_port_lock(state, flags);\n\tif (!circ->buf) {\n\t\tuart_port_unlock(port, flags);\n\t\treturn 0;\n\t}\n\n\tif (port && uart_circ_chars_free(circ) != 0) {\n\t\tcirc->buf[circ->head] = c;\n\t\tcirc->head = (circ->head + 1) & (UART_XMIT_SIZE - 1);\n\t\tret = 1;\n\t}\n\tuart_port_unlock(port, flags);\n\treturn ret;\n}\n\nstatic void uart_flush_chars(struct tty_struct *tty)\n{\n\tuart_start(tty);\n}\n\nstatic ssize_t uart_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_port *port;\n\tstruct circ_buf *circ;\n\tunsigned long flags;\n\tint c, ret = 0;\n\n\t \n\tif (WARN_ON(!state))\n\t\treturn -EL3HLT;\n\n\tport = uart_port_lock(state, flags);\n\tcirc = &state->xmit;\n\tif (!circ->buf) {\n\t\tuart_port_unlock(port, flags);\n\t\treturn 0;\n\t}\n\n\twhile (port) {\n\t\tc = CIRC_SPACE_TO_END(circ->head, circ->tail, UART_XMIT_SIZE);\n\t\tif (count < c)\n\t\t\tc = count;\n\t\tif (c <= 0)\n\t\t\tbreak;\n\t\tmemcpy(circ->buf + circ->head, buf, c);\n\t\tcirc->head = (circ->head + c) & (UART_XMIT_SIZE - 1);\n\t\tbuf += c;\n\t\tcount -= c;\n\t\tret += c;\n\t}\n\n\t__uart_start(state);\n\tuart_port_unlock(port, flags);\n\treturn ret;\n}\n\nstatic unsigned int uart_write_room(struct tty_struct *tty)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_port *port;\n\tunsigned long flags;\n\tunsigned int ret;\n\n\tport = uart_port_lock(state, flags);\n\tret = uart_circ_chars_free(&state->xmit);\n\tuart_port_unlock(port, flags);\n\treturn ret;\n}\n\nstatic unsigned int uart_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_port *port;\n\tunsigned long flags;\n\tunsigned int ret;\n\n\tport = uart_port_lock(state, flags);\n\tret = uart_circ_chars_pending(&state->xmit);\n\tuart_port_unlock(port, flags);\n\treturn ret;\n}\n\nstatic void uart_flush_buffer(struct tty_struct *tty)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_port *port;\n\tunsigned long flags;\n\n\t \n\tif (WARN_ON(!state))\n\t\treturn;\n\n\tpr_debug(\"uart_flush_buffer(%d) called\\n\", tty->index);\n\n\tport = uart_port_lock(state, flags);\n\tif (!port)\n\t\treturn;\n\tuart_circ_clear(&state->xmit);\n\tif (port->ops->flush_buffer)\n\t\tport->ops->flush_buffer(port);\n\tuart_port_unlock(port, flags);\n\ttty_port_tty_wakeup(&state->port);\n}\n\n \nvoid uart_xchar_out(struct uart_port *uport, int offset)\n{\n\tserial_port_out(uport, offset, uport->x_char);\n\tuport->icount.tx++;\n\tuport->x_char = 0;\n}\nEXPORT_SYMBOL_GPL(uart_xchar_out);\n\n \nstatic void uart_send_xchar(struct tty_struct *tty, char ch)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_port *port;\n\tunsigned long flags;\n\n\tport = uart_port_ref(state);\n\tif (!port)\n\t\treturn;\n\n\tif (port->ops->send_xchar)\n\t\tport->ops->send_xchar(port, ch);\n\telse {\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->x_char = ch;\n\t\tif (ch)\n\t\t\tport->ops->start_tx(port);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t}\n\tuart_port_deref(port);\n}\n\nstatic void uart_throttle(struct tty_struct *tty)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tupstat_t mask = UPSTAT_SYNC_FIFO;\n\tstruct uart_port *port;\n\n\tport = uart_port_ref(state);\n\tif (!port)\n\t\treturn;\n\n\tif (I_IXOFF(tty))\n\t\tmask |= UPSTAT_AUTOXOFF;\n\tif (C_CRTSCTS(tty))\n\t\tmask |= UPSTAT_AUTORTS;\n\n\tif (port->status & mask) {\n\t\tport->ops->throttle(port);\n\t\tmask &= ~port->status;\n\t}\n\n\tif (mask & UPSTAT_AUTORTS)\n\t\tuart_clear_mctrl(port, TIOCM_RTS);\n\n\tif (mask & UPSTAT_AUTOXOFF)\n\t\tuart_send_xchar(tty, STOP_CHAR(tty));\n\n\tuart_port_deref(port);\n}\n\nstatic void uart_unthrottle(struct tty_struct *tty)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tupstat_t mask = UPSTAT_SYNC_FIFO;\n\tstruct uart_port *port;\n\n\tport = uart_port_ref(state);\n\tif (!port)\n\t\treturn;\n\n\tif (I_IXOFF(tty))\n\t\tmask |= UPSTAT_AUTOXOFF;\n\tif (C_CRTSCTS(tty))\n\t\tmask |= UPSTAT_AUTORTS;\n\n\tif (port->status & mask) {\n\t\tport->ops->unthrottle(port);\n\t\tmask &= ~port->status;\n\t}\n\n\tif (mask & UPSTAT_AUTORTS)\n\t\tuart_set_mctrl(port, TIOCM_RTS);\n\n\tif (mask & UPSTAT_AUTOXOFF)\n\t\tuart_send_xchar(tty, START_CHAR(tty));\n\n\tuart_port_deref(port);\n}\n\nstatic int uart_get_info(struct tty_port *port, struct serial_struct *retinfo)\n{\n\tstruct uart_state *state = container_of(port, struct uart_state, port);\n\tstruct uart_port *uport;\n\tint ret = -ENODEV;\n\n\t \n\tmutex_lock(&port->mutex);\n\tuport = uart_port_check(state);\n\tif (!uport)\n\t\tgoto out;\n\n\tretinfo->type\t    = uport->type;\n\tretinfo->line\t    = uport->line;\n\tretinfo->port\t    = uport->iobase;\n\tif (HIGH_BITS_OFFSET)\n\t\tretinfo->port_high = (long) uport->iobase >> HIGH_BITS_OFFSET;\n\tretinfo->irq\t\t    = uport->irq;\n\tretinfo->flags\t    = (__force int)uport->flags;\n\tretinfo->xmit_fifo_size  = uport->fifosize;\n\tretinfo->baud_base\t    = uport->uartclk / 16;\n\tretinfo->close_delay\t    = jiffies_to_msecs(port->close_delay) / 10;\n\tretinfo->closing_wait    = port->closing_wait == ASYNC_CLOSING_WAIT_NONE ?\n\t\t\t\tASYNC_CLOSING_WAIT_NONE :\n\t\t\t\tjiffies_to_msecs(port->closing_wait) / 10;\n\tretinfo->custom_divisor  = uport->custom_divisor;\n\tretinfo->hub6\t    = uport->hub6;\n\tretinfo->io_type         = uport->iotype;\n\tretinfo->iomem_reg_shift = uport->regshift;\n\tretinfo->iomem_base      = (void *)(unsigned long)uport->mapbase;\n\n\tret = 0;\nout:\n\tmutex_unlock(&port->mutex);\n\treturn ret;\n}\n\nstatic int uart_get_info_user(struct tty_struct *tty,\n\t\t\t struct serial_struct *ss)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct tty_port *port = &state->port;\n\n\treturn uart_get_info(port, ss) < 0 ? -EIO : 0;\n}\n\nstatic int uart_set_info(struct tty_struct *tty, struct tty_port *port,\n\t\t\t struct uart_state *state,\n\t\t\t struct serial_struct *new_info)\n{\n\tstruct uart_port *uport = uart_port_check(state);\n\tunsigned long new_port;\n\tunsigned int change_irq, change_port, closing_wait;\n\tunsigned int old_custom_divisor, close_delay;\n\tupf_t old_flags, new_flags;\n\tint retval = 0;\n\n\tif (!uport)\n\t\treturn -EIO;\n\n\tnew_port = new_info->port;\n\tif (HIGH_BITS_OFFSET)\n\t\tnew_port += (unsigned long) new_info->port_high << HIGH_BITS_OFFSET;\n\n\tnew_info->irq = irq_canonicalize(new_info->irq);\n\tclose_delay = msecs_to_jiffies(new_info->close_delay * 10);\n\tclosing_wait = new_info->closing_wait == ASYNC_CLOSING_WAIT_NONE ?\n\t\t\tASYNC_CLOSING_WAIT_NONE :\n\t\t\tmsecs_to_jiffies(new_info->closing_wait * 10);\n\n\n\tchange_irq  = !(uport->flags & UPF_FIXED_PORT)\n\t\t&& new_info->irq != uport->irq;\n\n\t \n\tchange_port = !(uport->flags & UPF_FIXED_PORT)\n\t\t&& (new_port != uport->iobase ||\n\t\t    (unsigned long)new_info->iomem_base != uport->mapbase ||\n\t\t    new_info->hub6 != uport->hub6 ||\n\t\t    new_info->io_type != uport->iotype ||\n\t\t    new_info->iomem_reg_shift != uport->regshift ||\n\t\t    new_info->type != uport->type);\n\n\told_flags = uport->flags;\n\tnew_flags = (__force upf_t)new_info->flags;\n\told_custom_divisor = uport->custom_divisor;\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tretval = -EPERM;\n\t\tif (change_irq || change_port ||\n\t\t    (new_info->baud_base != uport->uartclk / 16) ||\n\t\t    (close_delay != port->close_delay) ||\n\t\t    (closing_wait != port->closing_wait) ||\n\t\t    (new_info->xmit_fifo_size &&\n\t\t     new_info->xmit_fifo_size != uport->fifosize) ||\n\t\t    (((new_flags ^ old_flags) & ~UPF_USR_MASK) != 0))\n\t\t\tgoto exit;\n\t\tuport->flags = ((uport->flags & ~UPF_USR_MASK) |\n\t\t\t       (new_flags & UPF_USR_MASK));\n\t\tuport->custom_divisor = new_info->custom_divisor;\n\t\tgoto check_and_exit;\n\t}\n\n\tif (change_irq || change_port) {\n\t\tretval = security_locked_down(LOCKDOWN_TIOCSSERIAL);\n\t\tif (retval)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tif (uport->ops->verify_port)\n\t\tretval = uport->ops->verify_port(uport, new_info);\n\n\tif ((new_info->irq >= nr_irqs) || (new_info->irq < 0) ||\n\t    (new_info->baud_base < 9600))\n\t\tretval = -EINVAL;\n\n\tif (retval)\n\t\tgoto exit;\n\n\tif (change_port || change_irq) {\n\t\tretval = -EBUSY;\n\n\t\t \n\t\tif (tty_port_users(port) > 1)\n\t\t\tgoto exit;\n\n\t\t \n\t\tuart_shutdown(tty, state);\n\t}\n\n\tif (change_port) {\n\t\tunsigned long old_iobase, old_mapbase;\n\t\tunsigned int old_type, old_iotype, old_hub6, old_shift;\n\n\t\told_iobase = uport->iobase;\n\t\told_mapbase = uport->mapbase;\n\t\told_type = uport->type;\n\t\told_hub6 = uport->hub6;\n\t\told_iotype = uport->iotype;\n\t\told_shift = uport->regshift;\n\n\t\t \n\t\tif (old_type != PORT_UNKNOWN && uport->ops->release_port)\n\t\t\tuport->ops->release_port(uport);\n\n\t\tuport->iobase = new_port;\n\t\tuport->type = new_info->type;\n\t\tuport->hub6 = new_info->hub6;\n\t\tuport->iotype = new_info->io_type;\n\t\tuport->regshift = new_info->iomem_reg_shift;\n\t\tuport->mapbase = (unsigned long)new_info->iomem_base;\n\n\t\t \n\t\tif (uport->type != PORT_UNKNOWN && uport->ops->request_port) {\n\t\t\tretval = uport->ops->request_port(uport);\n\t\t} else {\n\t\t\t \n\t\t\tretval = 0;\n\t\t}\n\n\t\t \n\t\tif (retval) {\n\t\t\tuport->iobase = old_iobase;\n\t\t\tuport->type = old_type;\n\t\t\tuport->hub6 = old_hub6;\n\t\t\tuport->iotype = old_iotype;\n\t\t\tuport->regshift = old_shift;\n\t\t\tuport->mapbase = old_mapbase;\n\n\t\t\tif (old_type != PORT_UNKNOWN) {\n\t\t\t\tretval = uport->ops->request_port(uport);\n\t\t\t\t \n\t\t\t\tif (retval)\n\t\t\t\t\tuport->type = PORT_UNKNOWN;\n\n\t\t\t\t \n\t\t\t\tretval = -EBUSY;\n\t\t\t}\n\n\t\t\t \n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (change_irq)\n\t\tuport->irq      = new_info->irq;\n\tif (!(uport->flags & UPF_FIXED_PORT))\n\t\tuport->uartclk  = new_info->baud_base * 16;\n\tuport->flags            = (uport->flags & ~UPF_CHANGE_MASK) |\n\t\t\t\t (new_flags & UPF_CHANGE_MASK);\n\tuport->custom_divisor   = new_info->custom_divisor;\n\tport->close_delay     = close_delay;\n\tport->closing_wait    = closing_wait;\n\tif (new_info->xmit_fifo_size)\n\t\tuport->fifosize = new_info->xmit_fifo_size;\n\n check_and_exit:\n\tretval = 0;\n\tif (uport->type == PORT_UNKNOWN)\n\t\tgoto exit;\n\tif (tty_port_initialized(port)) {\n\t\tif (((old_flags ^ uport->flags) & UPF_SPD_MASK) ||\n\t\t    old_custom_divisor != uport->custom_divisor) {\n\t\t\t \n\t\t\tif (uport->flags & UPF_SPD_MASK) {\n\t\t\t\tdev_notice_ratelimited(uport->dev,\n\t\t\t\t       \"%s sets custom speed on %s. This is deprecated.\\n\",\n\t\t\t\t      current->comm,\n\t\t\t\t      tty_name(port->tty));\n\t\t\t}\n\t\t\tuart_change_line_settings(tty, state, NULL);\n\t\t}\n\t} else {\n\t\tretval = uart_startup(tty, state, true);\n\t\tif (retval == 0)\n\t\t\ttty_port_set_initialized(port, true);\n\t\tif (retval > 0)\n\t\t\tretval = 0;\n\t}\n exit:\n\treturn retval;\n}\n\nstatic int uart_set_info_user(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct tty_port *port = &state->port;\n\tint retval;\n\n\tdown_write(&tty->termios_rwsem);\n\t \n\tmutex_lock(&port->mutex);\n\tretval = uart_set_info(tty, port, state, ss);\n\tmutex_unlock(&port->mutex);\n\tup_write(&tty->termios_rwsem);\n\treturn retval;\n}\n\n \nstatic int uart_get_lsr_info(struct tty_struct *tty,\n\t\t\tstruct uart_state *state, unsigned int __user *value)\n{\n\tstruct uart_port *uport = uart_port_check(state);\n\tunsigned int result;\n\n\tresult = uport->ops->tx_empty(uport);\n\n\t \n\tif (uport->x_char ||\n\t    ((uart_circ_chars_pending(&state->xmit) > 0) &&\n\t     !uart_tx_stopped(uport)))\n\t\tresult &= ~TIOCSER_TEMT;\n\n\treturn put_user(result, value);\n}\n\nstatic int uart_tiocmget(struct tty_struct *tty)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct tty_port *port = &state->port;\n\tstruct uart_port *uport;\n\tint result = -EIO;\n\n\tmutex_lock(&port->mutex);\n\tuport = uart_port_check(state);\n\tif (!uport)\n\t\tgoto out;\n\n\tif (!tty_io_error(tty)) {\n\t\tresult = uport->mctrl;\n\t\tspin_lock_irq(&uport->lock);\n\t\tresult |= uport->ops->get_mctrl(uport);\n\t\tspin_unlock_irq(&uport->lock);\n\t}\nout:\n\tmutex_unlock(&port->mutex);\n\treturn result;\n}\n\nstatic int\nuart_tiocmset(struct tty_struct *tty, unsigned int set, unsigned int clear)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct tty_port *port = &state->port;\n\tstruct uart_port *uport;\n\tint ret = -EIO;\n\n\tmutex_lock(&port->mutex);\n\tuport = uart_port_check(state);\n\tif (!uport)\n\t\tgoto out;\n\n\tif (!tty_io_error(tty)) {\n\t\tuart_update_mctrl(uport, set, clear);\n\t\tret = 0;\n\t}\nout:\n\tmutex_unlock(&port->mutex);\n\treturn ret;\n}\n\nstatic int uart_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct tty_port *port = &state->port;\n\tstruct uart_port *uport;\n\tint ret = -EIO;\n\n\tmutex_lock(&port->mutex);\n\tuport = uart_port_check(state);\n\tif (!uport)\n\t\tgoto out;\n\n\tif (uport->type != PORT_UNKNOWN && uport->ops->break_ctl)\n\t\tuport->ops->break_ctl(uport, break_state);\n\tret = 0;\nout:\n\tmutex_unlock(&port->mutex);\n\treturn ret;\n}\n\nstatic int uart_do_autoconfig(struct tty_struct *tty, struct uart_state *state)\n{\n\tstruct tty_port *port = &state->port;\n\tstruct uart_port *uport;\n\tint flags, ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif (mutex_lock_interruptible(&port->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tuport = uart_port_check(state);\n\tif (!uport) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = -EBUSY;\n\tif (tty_port_users(port) == 1) {\n\t\tuart_shutdown(tty, state);\n\n\t\t \n\t\tif (uport->type != PORT_UNKNOWN && uport->ops->release_port)\n\t\t\tuport->ops->release_port(uport);\n\n\t\tflags = UART_CONFIG_TYPE;\n\t\tif (uport->flags & UPF_AUTO_IRQ)\n\t\t\tflags |= UART_CONFIG_IRQ;\n\n\t\t \n\t\tuport->ops->config_port(uport, flags);\n\n\t\tret = uart_startup(tty, state, true);\n\t\tif (ret == 0)\n\t\t\ttty_port_set_initialized(port, true);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t}\nout:\n\tmutex_unlock(&port->mutex);\n\treturn ret;\n}\n\nstatic void uart_enable_ms(struct uart_port *uport)\n{\n\t \n\tif (uport->ops->enable_ms)\n\t\tuport->ops->enable_ms(uport);\n}\n\n \nstatic int uart_wait_modem_status(struct uart_state *state, unsigned long arg)\n{\n\tstruct uart_port *uport;\n\tstruct tty_port *port = &state->port;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct uart_icount cprev, cnow;\n\tint ret;\n\n\t \n\tuport = uart_port_ref(state);\n\tif (!uport)\n\t\treturn -EIO;\n\tspin_lock_irq(&uport->lock);\n\tmemcpy(&cprev, &uport->icount, sizeof(struct uart_icount));\n\tuart_enable_ms(uport);\n\tspin_unlock_irq(&uport->lock);\n\n\tadd_wait_queue(&port->delta_msr_wait, &wait);\n\tfor (;;) {\n\t\tspin_lock_irq(&uport->lock);\n\t\tmemcpy(&cnow, &uport->icount, sizeof(struct uart_icount));\n\t\tspin_unlock_irq(&uport->lock);\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\n\t\t    ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\n\t\t    ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||\n\t\t    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule();\n\n\t\t \n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcprev = cnow;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&port->delta_msr_wait, &wait);\n\tuart_port_deref(uport);\n\n\treturn ret;\n}\n\n \nstatic int uart_get_icount(struct tty_struct *tty,\n\t\t\t  struct serial_icounter_struct *icount)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_icount cnow;\n\tstruct uart_port *uport;\n\n\tuport = uart_port_ref(state);\n\tif (!uport)\n\t\treturn -EIO;\n\tspin_lock_irq(&uport->lock);\n\tmemcpy(&cnow, &uport->icount, sizeof(struct uart_icount));\n\tspin_unlock_irq(&uport->lock);\n\tuart_port_deref(uport);\n\n\ticount->cts         = cnow.cts;\n\ticount->dsr         = cnow.dsr;\n\ticount->rng         = cnow.rng;\n\ticount->dcd         = cnow.dcd;\n\ticount->rx          = cnow.rx;\n\ticount->tx          = cnow.tx;\n\ticount->frame       = cnow.frame;\n\ticount->overrun     = cnow.overrun;\n\ticount->parity      = cnow.parity;\n\ticount->brk         = cnow.brk;\n\ticount->buf_overrun = cnow.buf_overrun;\n\n\treturn 0;\n}\n\n#define SER_RS485_LEGACY_FLAGS\t(SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | \\\n\t\t\t\t SER_RS485_RTS_AFTER_SEND | SER_RS485_RX_DURING_TX | \\\n\t\t\t\t SER_RS485_TERMINATE_BUS)\n\nstatic int uart_check_rs485_flags(struct uart_port *port, struct serial_rs485 *rs485)\n{\n\tu32 flags = rs485->flags;\n\n\t \n\tflags &= ~SER_RS485_LEGACY_FLAGS;\n\n\t \n\tif (flags & ~port->rs485_supported.flags)\n\t\treturn -EINVAL;\n\n\t \n\tif (!(rs485->flags & SER_RS485_ADDRB) &&\n\t    (rs485->flags & (SER_RS485_ADDR_RECV|SER_RS485_ADDR_DEST)))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(rs485->flags & SER_RS485_ADDR_RECV) && rs485->addr_recv)\n\t\treturn -EINVAL;\n\tif (!(rs485->flags & SER_RS485_ADDR_DEST) && rs485->addr_dest)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void uart_sanitize_serial_rs485_delays(struct uart_port *port,\n\t\t\t\t\t      struct serial_rs485 *rs485)\n{\n\tif (!port->rs485_supported.delay_rts_before_send) {\n\t\tif (rs485->delay_rts_before_send) {\n\t\t\tdev_warn_ratelimited(port->dev,\n\t\t\t\t\"%s (%d): RTS delay before sending not supported\\n\",\n\t\t\t\tport->name, port->line);\n\t\t}\n\t\trs485->delay_rts_before_send = 0;\n\t} else if (rs485->delay_rts_before_send > RS485_MAX_RTS_DELAY) {\n\t\trs485->delay_rts_before_send = RS485_MAX_RTS_DELAY;\n\t\tdev_warn_ratelimited(port->dev,\n\t\t\t\"%s (%d): RTS delay before sending clamped to %u ms\\n\",\n\t\t\tport->name, port->line, rs485->delay_rts_before_send);\n\t}\n\n\tif (!port->rs485_supported.delay_rts_after_send) {\n\t\tif (rs485->delay_rts_after_send) {\n\t\t\tdev_warn_ratelimited(port->dev,\n\t\t\t\t\"%s (%d): RTS delay after sending not supported\\n\",\n\t\t\t\tport->name, port->line);\n\t\t}\n\t\trs485->delay_rts_after_send = 0;\n\t} else if (rs485->delay_rts_after_send > RS485_MAX_RTS_DELAY) {\n\t\trs485->delay_rts_after_send = RS485_MAX_RTS_DELAY;\n\t\tdev_warn_ratelimited(port->dev,\n\t\t\t\"%s (%d): RTS delay after sending clamped to %u ms\\n\",\n\t\t\tport->name, port->line, rs485->delay_rts_after_send);\n\t}\n}\n\nstatic void uart_sanitize_serial_rs485(struct uart_port *port, struct serial_rs485 *rs485)\n{\n\tu32 supported_flags = port->rs485_supported.flags;\n\n\tif (!(rs485->flags & SER_RS485_ENABLED)) {\n\t\tmemset(rs485, 0, sizeof(*rs485));\n\t\treturn;\n\t}\n\n\trs485->flags &= supported_flags;\n\n\t \n\tif (!(rs485->flags & SER_RS485_RTS_ON_SEND) ==\n\t    !(rs485->flags & SER_RS485_RTS_AFTER_SEND)) {\n\t\tif (supported_flags & SER_RS485_RTS_ON_SEND) {\n\t\t\trs485->flags |= SER_RS485_RTS_ON_SEND;\n\t\t\trs485->flags &= ~SER_RS485_RTS_AFTER_SEND;\n\n\t\t\tdev_warn_ratelimited(port->dev,\n\t\t\t\t\"%s (%d): invalid RTS setting, using RTS_ON_SEND instead\\n\",\n\t\t\t\tport->name, port->line);\n\t\t} else {\n\t\t\trs485->flags |= SER_RS485_RTS_AFTER_SEND;\n\t\t\trs485->flags &= ~SER_RS485_RTS_ON_SEND;\n\n\t\t\tdev_warn_ratelimited(port->dev,\n\t\t\t\t\"%s (%d): invalid RTS setting, using RTS_AFTER_SEND instead\\n\",\n\t\t\t\tport->name, port->line);\n\t\t}\n\t}\n\n\tuart_sanitize_serial_rs485_delays(port, rs485);\n\n\t \n\tmemset(rs485->padding0, 0, sizeof(rs485->padding0));\n\tmemset(rs485->padding1, 0, sizeof(rs485->padding1));\n}\n\nstatic void uart_set_rs485_termination(struct uart_port *port,\n\t\t\t\t       const struct serial_rs485 *rs485)\n{\n\tif (!(rs485->flags & SER_RS485_ENABLED))\n\t\treturn;\n\n\tgpiod_set_value_cansleep(port->rs485_term_gpio,\n\t\t\t\t !!(rs485->flags & SER_RS485_TERMINATE_BUS));\n}\n\nstatic int uart_rs485_config(struct uart_port *port)\n{\n\tstruct serial_rs485 *rs485 = &port->rs485;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!(rs485->flags & SER_RS485_ENABLED))\n\t\treturn 0;\n\n\tuart_sanitize_serial_rs485(port, rs485);\n\tuart_set_rs485_termination(port, rs485);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tret = port->rs485_config(port, NULL, rs485);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tif (ret)\n\t\tmemset(rs485, 0, sizeof(*rs485));\n\n\treturn ret;\n}\n\nstatic int uart_get_rs485_config(struct uart_port *port,\n\t\t\t struct serial_rs485 __user *rs485)\n{\n\tunsigned long flags;\n\tstruct serial_rs485 aux;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\taux = port->rs485;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (copy_to_user(rs485, &aux, sizeof(aux)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int uart_set_rs485_config(struct tty_struct *tty, struct uart_port *port,\n\t\t\t struct serial_rs485 __user *rs485_user)\n{\n\tstruct serial_rs485 rs485;\n\tint ret;\n\tunsigned long flags;\n\n\tif (!(port->rs485_supported.flags & SER_RS485_ENABLED))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&rs485, rs485_user, sizeof(*rs485_user)))\n\t\treturn -EFAULT;\n\n\tret = uart_check_rs485_flags(port, &rs485);\n\tif (ret)\n\t\treturn ret;\n\tuart_sanitize_serial_rs485(port, &rs485);\n\tuart_set_rs485_termination(port, &rs485);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tret = port->rs485_config(port, &tty->termios, &rs485);\n\tif (!ret) {\n\t\tport->rs485 = rs485;\n\n\t\t \n\t\tif (!(rs485.flags & SER_RS485_ENABLED))\n\t\t\tport->ops->set_mctrl(port, port->mctrl);\n\t}\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(rs485_user, &port->rs485, sizeof(port->rs485)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int uart_get_iso7816_config(struct uart_port *port,\n\t\t\t\t   struct serial_iso7816 __user *iso7816)\n{\n\tunsigned long flags;\n\tstruct serial_iso7816 aux;\n\n\tif (!port->iso7816_config)\n\t\treturn -ENOTTY;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\taux = port->iso7816;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (copy_to_user(iso7816, &aux, sizeof(aux)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int uart_set_iso7816_config(struct uart_port *port,\n\t\t\t\t   struct serial_iso7816 __user *iso7816_user)\n{\n\tstruct serial_iso7816 iso7816;\n\tint i, ret;\n\tunsigned long flags;\n\n\tif (!port->iso7816_config)\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&iso7816, iso7816_user, sizeof(*iso7816_user)))\n\t\treturn -EFAULT;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(iso7816.reserved); i++)\n\t\tif (iso7816.reserved[i])\n\t\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tret = port->iso7816_config(port, &iso7816);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(iso7816_user, &port->iso7816, sizeof(port->iso7816)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int\nuart_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct tty_port *port = &state->port;\n\tstruct uart_port *uport;\n\tvoid __user *uarg = (void __user *)arg;\n\tint ret = -ENOIOCTLCMD;\n\n\n\t \n\tswitch (cmd) {\n\tcase TIOCSERCONFIG:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tret = uart_do_autoconfig(tty, state);\n\t\tup_write(&tty->termios_rwsem);\n\t\tbreak;\n\t}\n\n\tif (ret != -ENOIOCTLCMD)\n\t\tgoto out;\n\n\tif (tty_io_error(tty)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (cmd) {\n\tcase TIOCMIWAIT:\n\t\tret = uart_wait_modem_status(state, arg);\n\t\tbreak;\n\t}\n\n\tif (ret != -ENOIOCTLCMD)\n\t\tgoto out;\n\n\t \n\tif (cmd == TIOCSRS485)\n\t\tdown_write(&tty->termios_rwsem);\n\n\tmutex_lock(&port->mutex);\n\tuport = uart_port_check(state);\n\n\tif (!uport || tty_io_error(tty)) {\n\t\tret = -EIO;\n\t\tgoto out_up;\n\t}\n\n\t \n\n\tswitch (cmd) {\n\tcase TIOCSERGETLSR:  \n\t\tret = uart_get_lsr_info(tty, state, uarg);\n\t\tbreak;\n\n\tcase TIOCGRS485:\n\t\tret = uart_get_rs485_config(uport, uarg);\n\t\tbreak;\n\n\tcase TIOCSRS485:\n\t\tret = uart_set_rs485_config(tty, uport, uarg);\n\t\tbreak;\n\n\tcase TIOCSISO7816:\n\t\tret = uart_set_iso7816_config(state->uart_port, uarg);\n\t\tbreak;\n\n\tcase TIOCGISO7816:\n\t\tret = uart_get_iso7816_config(state->uart_port, uarg);\n\t\tbreak;\n\tdefault:\n\t\tif (uport->ops->ioctl)\n\t\t\tret = uport->ops->ioctl(uport, cmd, arg);\n\t\tbreak;\n\t}\nout_up:\n\tmutex_unlock(&port->mutex);\n\tif (cmd == TIOCSRS485)\n\t\tup_write(&tty->termios_rwsem);\nout:\n\treturn ret;\n}\n\nstatic void uart_set_ldisc(struct tty_struct *tty)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_port *uport;\n\tstruct tty_port *port = &state->port;\n\n\tif (!tty_port_initialized(port))\n\t\treturn;\n\n\tmutex_lock(&state->port.mutex);\n\tuport = uart_port_check(state);\n\tif (uport && uport->ops->set_ldisc)\n\t\tuport->ops->set_ldisc(uport, &tty->termios);\n\tmutex_unlock(&state->port.mutex);\n}\n\nstatic void uart_set_termios(struct tty_struct *tty,\n\t\t\t     const struct ktermios *old_termios)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_port *uport;\n\tunsigned int cflag = tty->termios.c_cflag;\n\tunsigned int iflag_mask = IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK;\n\tbool sw_changed = false;\n\n\tmutex_lock(&state->port.mutex);\n\tuport = uart_port_check(state);\n\tif (!uport)\n\t\tgoto out;\n\n\t \n\tif (uport->flags & UPF_SOFT_FLOW) {\n\t\tiflag_mask |= IXANY|IXON|IXOFF;\n\t\tsw_changed =\n\t\t   tty->termios.c_cc[VSTART] != old_termios->c_cc[VSTART] ||\n\t\t   tty->termios.c_cc[VSTOP] != old_termios->c_cc[VSTOP];\n\t}\n\n\t \n\tif ((cflag ^ old_termios->c_cflag) == 0 &&\n\t    tty->termios.c_ospeed == old_termios->c_ospeed &&\n\t    tty->termios.c_ispeed == old_termios->c_ispeed &&\n\t    ((tty->termios.c_iflag ^ old_termios->c_iflag) & iflag_mask) == 0 &&\n\t    !sw_changed) {\n\t\tgoto out;\n\t}\n\n\tuart_change_line_settings(tty, state, old_termios);\n\t \n\tcflag = tty->termios.c_cflag;\n\n\t \n\tif (((old_termios->c_cflag & CBAUD) != B0) && ((cflag & CBAUD) == B0))\n\t\tuart_clear_mctrl(uport, TIOCM_RTS | TIOCM_DTR);\n\t \n\telse if (((old_termios->c_cflag & CBAUD) == B0) && ((cflag & CBAUD) != B0)) {\n\t\tunsigned int mask = TIOCM_DTR;\n\n\t\tif (!(cflag & CRTSCTS) || !tty_throttled(tty))\n\t\t\tmask |= TIOCM_RTS;\n\t\tuart_set_mctrl(uport, mask);\n\t}\nout:\n\tmutex_unlock(&state->port.mutex);\n}\n\n \nstatic void uart_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct uart_state *state = tty->driver_data;\n\n\tif (!state) {\n\t\tstruct uart_driver *drv = tty->driver->driver_state;\n\t\tstruct tty_port *port;\n\n\t\tstate = drv->state + tty->index;\n\t\tport = &state->port;\n\t\tspin_lock_irq(&port->lock);\n\t\t--port->count;\n\t\tspin_unlock_irq(&port->lock);\n\t\treturn;\n\t}\n\n\tpr_debug(\"uart_close(%d) called\\n\", tty->index);\n\n\ttty_port_close(tty->port, tty, filp);\n}\n\nstatic void uart_tty_port_shutdown(struct tty_port *port)\n{\n\tstruct uart_state *state = container_of(port, struct uart_state, port);\n\tstruct uart_port *uport = uart_port_check(state);\n\tchar *buf;\n\n\t \n\tif (WARN(!uport, \"detached port still initialized!\\n\"))\n\t\treturn;\n\n\tspin_lock_irq(&uport->lock);\n\tuport->ops->stop_rx(uport);\n\tspin_unlock_irq(&uport->lock);\n\n\tuart_port_shutdown(port);\n\n\t \n\ttty_port_set_suspended(port, false);\n\n\t \n\tspin_lock_irq(&uport->lock);\n\tbuf = state->xmit.buf;\n\tstate->xmit.buf = NULL;\n\tspin_unlock_irq(&uport->lock);\n\n\tfree_page((unsigned long)buf);\n\n\tuart_change_pm(state, UART_PM_STATE_OFF);\n}\n\nstatic void uart_wait_until_sent(struct tty_struct *tty, int timeout)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct uart_port *port;\n\tunsigned long char_time, expire, fifo_timeout;\n\n\tport = uart_port_ref(state);\n\tif (!port)\n\t\treturn;\n\n\tif (port->type == PORT_UNKNOWN || port->fifosize == 0) {\n\t\tuart_port_deref(port);\n\t\treturn;\n\t}\n\n\t \n\tchar_time = max(nsecs_to_jiffies(port->frame_time / 5), 1UL);\n\n\tif (timeout && timeout < char_time)\n\t\tchar_time = timeout;\n\n\tif (!uart_cts_enabled(port)) {\n\t\t \n\t\tfifo_timeout = uart_fifo_timeout(port);\n\t\tif (timeout == 0 || timeout > 2 * fifo_timeout)\n\t\t\ttimeout = 2 * fifo_timeout;\n\t}\n\n\texpire = jiffies + timeout;\n\n\tpr_debug(\"uart_wait_until_sent(%d), jiffies=%lu, expire=%lu...\\n\",\n\t\tport->line, jiffies, expire);\n\n\t \n\twhile (!port->ops->tx_empty(port)) {\n\t\tmsleep_interruptible(jiffies_to_msecs(char_time));\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tif (timeout && time_after(jiffies, expire))\n\t\t\tbreak;\n\t}\n\tuart_port_deref(port);\n}\n\n \nstatic void uart_hangup(struct tty_struct *tty)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tstruct tty_port *port = &state->port;\n\tstruct uart_port *uport;\n\tunsigned long flags;\n\n\tpr_debug(\"uart_hangup(%d)\\n\", tty->index);\n\n\tmutex_lock(&port->mutex);\n\tuport = uart_port_check(state);\n\tWARN(!uport, \"hangup of detached port!\\n\");\n\n\tif (tty_port_active(port)) {\n\t\tuart_flush_buffer(tty);\n\t\tuart_shutdown(tty, state);\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->count = 0;\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\ttty_port_set_active(port, false);\n\t\ttty_port_tty_set(port, NULL);\n\t\tif (uport && !uart_console(uport))\n\t\t\tuart_change_pm(state, UART_PM_STATE_OFF);\n\t\twake_up_interruptible(&port->open_wait);\n\t\twake_up_interruptible(&port->delta_msr_wait);\n\t}\n\tmutex_unlock(&port->mutex);\n}\n\n \nstatic void uart_port_shutdown(struct tty_port *port)\n{\n\tstruct uart_state *state = container_of(port, struct uart_state, port);\n\tstruct uart_port *uport = uart_port_check(state);\n\n\t \n\twake_up_interruptible(&port->delta_msr_wait);\n\n\tif (uport) {\n\t\t \n\t\tuport->ops->shutdown(uport);\n\n\t\t \n\t\tsynchronize_irq(uport->irq);\n\t}\n}\n\nstatic bool uart_carrier_raised(struct tty_port *port)\n{\n\tstruct uart_state *state = container_of(port, struct uart_state, port);\n\tstruct uart_port *uport;\n\tint mctrl;\n\n\tuport = uart_port_ref(state);\n\t \n\tif (WARN_ON(!uport))\n\t\treturn true;\n\tspin_lock_irq(&uport->lock);\n\tuart_enable_ms(uport);\n\tmctrl = uport->ops->get_mctrl(uport);\n\tspin_unlock_irq(&uport->lock);\n\tuart_port_deref(uport);\n\n\treturn mctrl & TIOCM_CAR;\n}\n\nstatic void uart_dtr_rts(struct tty_port *port, bool active)\n{\n\tstruct uart_state *state = container_of(port, struct uart_state, port);\n\tstruct uart_port *uport;\n\n\tuport = uart_port_ref(state);\n\tif (!uport)\n\t\treturn;\n\tuart_port_dtr_rts(uport, active);\n\tuart_port_deref(uport);\n}\n\nstatic int uart_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct uart_driver *drv = driver->driver_state;\n\tstruct uart_state *state = drv->state + tty->index;\n\n\ttty->driver_data = state;\n\n\treturn tty_standard_install(driver, tty);\n}\n\n \nstatic int uart_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct uart_state *state = tty->driver_data;\n\tint retval;\n\n\tretval = tty_port_open(&state->port, tty, filp);\n\tif (retval > 0)\n\t\tretval = 0;\n\n\treturn retval;\n}\n\nstatic int uart_port_activate(struct tty_port *port, struct tty_struct *tty)\n{\n\tstruct uart_state *state = container_of(port, struct uart_state, port);\n\tstruct uart_port *uport;\n\tint ret;\n\n\tuport = uart_port_check(state);\n\tif (!uport || uport->flags & UPF_DEAD)\n\t\treturn -ENXIO;\n\n\t \n\tret = uart_startup(tty, state, false);\n\tif (ret > 0)\n\t\ttty_port_set_active(port, true);\n\n\treturn ret;\n}\n\nstatic const char *uart_type(struct uart_port *port)\n{\n\tconst char *str = NULL;\n\n\tif (port->ops->type)\n\t\tstr = port->ops->type(port);\n\n\tif (!str)\n\t\tstr = \"unknown\";\n\n\treturn str;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void uart_line_info(struct seq_file *m, struct uart_driver *drv, int i)\n{\n\tstruct uart_state *state = drv->state + i;\n\tstruct tty_port *port = &state->port;\n\tenum uart_pm_state pm_state;\n\tstruct uart_port *uport;\n\tchar stat_buf[32];\n\tunsigned int status;\n\tint mmio;\n\n\tmutex_lock(&port->mutex);\n\tuport = uart_port_check(state);\n\tif (!uport)\n\t\tgoto out;\n\n\tmmio = uport->iotype >= UPIO_MEM;\n\tseq_printf(m, \"%d: uart:%s %s%08llX irq:%d\",\n\t\t\tuport->line, uart_type(uport),\n\t\t\tmmio ? \"mmio:0x\" : \"port:\",\n\t\t\tmmio ? (unsigned long long)uport->mapbase\n\t\t\t     : (unsigned long long)uport->iobase,\n\t\t\tuport->irq);\n\n\tif (uport->type == PORT_UNKNOWN) {\n\t\tseq_putc(m, '\\n');\n\t\tgoto out;\n\t}\n\n\tif (capable(CAP_SYS_ADMIN)) {\n\t\tpm_state = state->pm_state;\n\t\tif (pm_state != UART_PM_STATE_ON)\n\t\t\tuart_change_pm(state, UART_PM_STATE_ON);\n\t\tspin_lock_irq(&uport->lock);\n\t\tstatus = uport->ops->get_mctrl(uport);\n\t\tspin_unlock_irq(&uport->lock);\n\t\tif (pm_state != UART_PM_STATE_ON)\n\t\t\tuart_change_pm(state, pm_state);\n\n\t\tseq_printf(m, \" tx:%d rx:%d\",\n\t\t\t\tuport->icount.tx, uport->icount.rx);\n\t\tif (uport->icount.frame)\n\t\t\tseq_printf(m, \" fe:%d\",\tuport->icount.frame);\n\t\tif (uport->icount.parity)\n\t\t\tseq_printf(m, \" pe:%d\",\tuport->icount.parity);\n\t\tif (uport->icount.brk)\n\t\t\tseq_printf(m, \" brk:%d\", uport->icount.brk);\n\t\tif (uport->icount.overrun)\n\t\t\tseq_printf(m, \" oe:%d\", uport->icount.overrun);\n\t\tif (uport->icount.buf_overrun)\n\t\t\tseq_printf(m, \" bo:%d\", uport->icount.buf_overrun);\n\n#define INFOBIT(bit, str) \\\n\tif (uport->mctrl & (bit)) \\\n\t\tstrncat(stat_buf, (str), sizeof(stat_buf) - \\\n\t\t\tstrlen(stat_buf) - 2)\n#define STATBIT(bit, str) \\\n\tif (status & (bit)) \\\n\t\tstrncat(stat_buf, (str), sizeof(stat_buf) - \\\n\t\t       strlen(stat_buf) - 2)\n\n\t\tstat_buf[0] = '\\0';\n\t\tstat_buf[1] = '\\0';\n\t\tINFOBIT(TIOCM_RTS, \"|RTS\");\n\t\tSTATBIT(TIOCM_CTS, \"|CTS\");\n\t\tINFOBIT(TIOCM_DTR, \"|DTR\");\n\t\tSTATBIT(TIOCM_DSR, \"|DSR\");\n\t\tSTATBIT(TIOCM_CAR, \"|CD\");\n\t\tSTATBIT(TIOCM_RNG, \"|RI\");\n\t\tif (stat_buf[0])\n\t\t\tstat_buf[0] = ' ';\n\n\t\tseq_puts(m, stat_buf);\n\t}\n\tseq_putc(m, '\\n');\n#undef STATBIT\n#undef INFOBIT\nout:\n\tmutex_unlock(&port->mutex);\n}\n\nstatic int uart_proc_show(struct seq_file *m, void *v)\n{\n\tstruct tty_driver *ttydrv = m->private;\n\tstruct uart_driver *drv = ttydrv->driver_state;\n\tint i;\n\n\tseq_printf(m, \"serinfo:1.0 driver%s%s revision:%s\\n\", \"\", \"\", \"\");\n\tfor (i = 0; i < drv->nr; i++)\n\t\tuart_line_info(m, drv, i);\n\treturn 0;\n}\n#endif\n\nstatic void uart_port_spin_lock_init(struct uart_port *port)\n{\n\tspin_lock_init(&port->lock);\n\tlockdep_set_class(&port->lock, &port_lock_key);\n}\n\n#if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(CONFIG_CONSOLE_POLL)\n \nvoid uart_console_write(struct uart_port *port, const char *s,\n\t\t\tunsigned int count,\n\t\t\tvoid (*putchar)(struct uart_port *, unsigned char))\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++, s++) {\n\t\tif (*s == '\\n')\n\t\t\tputchar(port, '\\r');\n\t\tputchar(port, *s);\n\t}\n}\nEXPORT_SYMBOL_GPL(uart_console_write);\n\n \nstruct uart_port * __init\nuart_get_console(struct uart_port *ports, int nr, struct console *co)\n{\n\tint idx = co->index;\n\n\tif (idx < 0 || idx >= nr || (ports[idx].iobase == 0 &&\n\t\t\t\t     ports[idx].membase == NULL))\n\t\tfor (idx = 0; idx < nr; idx++)\n\t\t\tif (ports[idx].iobase != 0 ||\n\t\t\t    ports[idx].membase != NULL)\n\t\t\t\tbreak;\n\n\tco->index = idx;\n\n\treturn ports + idx;\n}\n\n \nint uart_parse_earlycon(char *p, unsigned char *iotype, resource_size_t *addr,\n\t\t\tchar **options)\n{\n\tif (strncmp(p, \"mmio,\", 5) == 0) {\n\t\t*iotype = UPIO_MEM;\n\t\tp += 5;\n\t} else if (strncmp(p, \"mmio16,\", 7) == 0) {\n\t\t*iotype = UPIO_MEM16;\n\t\tp += 7;\n\t} else if (strncmp(p, \"mmio32,\", 7) == 0) {\n\t\t*iotype = UPIO_MEM32;\n\t\tp += 7;\n\t} else if (strncmp(p, \"mmio32be,\", 9) == 0) {\n\t\t*iotype = UPIO_MEM32BE;\n\t\tp += 9;\n\t} else if (strncmp(p, \"mmio32native,\", 13) == 0) {\n\t\t*iotype = IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) ?\n\t\t\tUPIO_MEM32BE : UPIO_MEM32;\n\t\tp += 13;\n\t} else if (strncmp(p, \"io,\", 3) == 0) {\n\t\t*iotype = UPIO_PORT;\n\t\tp += 3;\n\t} else if (strncmp(p, \"0x\", 2) == 0) {\n\t\t*iotype = UPIO_MEM;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t*addr = simple_strtoull(p, NULL, 0);\n\tp = strchr(p, ',');\n\tif (p)\n\t\tp++;\n\n\t*options = p;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(uart_parse_earlycon);\n\n \nvoid\nuart_parse_options(const char *options, int *baud, int *parity,\n\t\t   int *bits, int *flow)\n{\n\tconst char *s = options;\n\n\t*baud = simple_strtoul(s, NULL, 10);\n\twhile (*s >= '0' && *s <= '9')\n\t\ts++;\n\tif (*s)\n\t\t*parity = *s++;\n\tif (*s)\n\t\t*bits = *s++ - '0';\n\tif (*s)\n\t\t*flow = *s;\n}\nEXPORT_SYMBOL_GPL(uart_parse_options);\n\n \nint\nuart_set_options(struct uart_port *port, struct console *co,\n\t\t int baud, int parity, int bits, int flow)\n{\n\tstruct ktermios termios;\n\tstatic struct ktermios dummy;\n\n\t \n\tif (!uart_console_registered_locked(port) && !port->console_reinit)\n\t\tuart_port_spin_lock_init(port);\n\n\tmemset(&termios, 0, sizeof(struct ktermios));\n\n\ttermios.c_cflag |= CREAD | HUPCL | CLOCAL;\n\ttty_termios_encode_baud_rate(&termios, baud, baud);\n\n\tif (bits == 7)\n\t\ttermios.c_cflag |= CS7;\n\telse\n\t\ttermios.c_cflag |= CS8;\n\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\ttermios.c_cflag |= PARODD;\n\t\tfallthrough;\n\tcase 'e': case 'E':\n\t\ttermios.c_cflag |= PARENB;\n\t\tbreak;\n\t}\n\n\tif (flow == 'r')\n\t\ttermios.c_cflag |= CRTSCTS;\n\n\t \n\tport->mctrl |= TIOCM_DTR;\n\n\tport->ops->set_termios(port, &termios, &dummy);\n\t \n\tif (co) {\n\t\tco->cflag = termios.c_cflag;\n\t\tco->ispeed = termios.c_ispeed;\n\t\tco->ospeed = termios.c_ospeed;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(uart_set_options);\n#endif  \n\n \nstatic void uart_change_pm(struct uart_state *state,\n\t\t\t   enum uart_pm_state pm_state)\n{\n\tstruct uart_port *port = uart_port_check(state);\n\n\tif (state->pm_state != pm_state) {\n\t\tif (port && port->ops->pm)\n\t\t\tport->ops->pm(port, pm_state, state->pm_state);\n\t\tstate->pm_state = pm_state;\n\t}\n}\n\nstruct uart_match {\n\tstruct uart_port *port;\n\tstruct uart_driver *driver;\n};\n\nstatic int serial_match_port(struct device *dev, void *data)\n{\n\tstruct uart_match *match = data;\n\tstruct tty_driver *tty_drv = match->driver->tty_driver;\n\tdev_t devt = MKDEV(tty_drv->major, tty_drv->minor_start) +\n\t\tmatch->port->line;\n\n\treturn dev->devt == devt;  \n}\n\nint uart_suspend_port(struct uart_driver *drv, struct uart_port *uport)\n{\n\tstruct uart_state *state = drv->state + uport->line;\n\tstruct tty_port *port = &state->port;\n\tstruct device *tty_dev;\n\tstruct uart_match match = {uport, drv};\n\n\tmutex_lock(&port->mutex);\n\n\ttty_dev = device_find_child(uport->dev, &match, serial_match_port);\n\tif (tty_dev && device_may_wakeup(tty_dev)) {\n\t\tenable_irq_wake(uport->irq);\n\t\tput_device(tty_dev);\n\t\tmutex_unlock(&port->mutex);\n\t\treturn 0;\n\t}\n\tput_device(tty_dev);\n\n\t \n\tif (!console_suspend_enabled && uart_console(uport)) {\n\t\tif (uport->ops->start_rx) {\n\t\t\tspin_lock_irq(&uport->lock);\n\t\t\tuport->ops->stop_rx(uport);\n\t\t\tspin_unlock_irq(&uport->lock);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tuport->suspended = 1;\n\n\tif (tty_port_initialized(port)) {\n\t\tconst struct uart_ops *ops = uport->ops;\n\t\tint tries;\n\t\tunsigned int mctrl;\n\n\t\ttty_port_set_suspended(port, true);\n\t\ttty_port_set_initialized(port, false);\n\n\t\tspin_lock_irq(&uport->lock);\n\t\tops->stop_tx(uport);\n\t\tif (!(uport->rs485.flags & SER_RS485_ENABLED))\n\t\t\tops->set_mctrl(uport, 0);\n\t\t \n\t\tmctrl = uport->mctrl;\n\t\tuport->mctrl = 0;\n\t\tops->stop_rx(uport);\n\t\tspin_unlock_irq(&uport->lock);\n\n\t\t \n\t\tfor (tries = 3; !ops->tx_empty(uport) && tries; tries--)\n\t\t\tmsleep(10);\n\t\tif (!tries)\n\t\t\tdev_err(uport->dev, \"%s: Unable to drain transmitter\\n\",\n\t\t\t\tuport->name);\n\n\t\tops->shutdown(uport);\n\t\tuport->mctrl = mctrl;\n\t}\n\n\t \n\tif (uart_console(uport))\n\t\tconsole_stop(uport->cons);\n\n\tuart_change_pm(state, UART_PM_STATE_OFF);\nunlock:\n\tmutex_unlock(&port->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(uart_suspend_port);\n\nint uart_resume_port(struct uart_driver *drv, struct uart_port *uport)\n{\n\tstruct uart_state *state = drv->state + uport->line;\n\tstruct tty_port *port = &state->port;\n\tstruct device *tty_dev;\n\tstruct uart_match match = {uport, drv};\n\tstruct ktermios termios;\n\n\tmutex_lock(&port->mutex);\n\n\ttty_dev = device_find_child(uport->dev, &match, serial_match_port);\n\tif (!uport->suspended && device_may_wakeup(tty_dev)) {\n\t\tif (irqd_is_wakeup_set(irq_get_irq_data((uport->irq))))\n\t\t\tdisable_irq_wake(uport->irq);\n\t\tput_device(tty_dev);\n\t\tmutex_unlock(&port->mutex);\n\t\treturn 0;\n\t}\n\tput_device(tty_dev);\n\tuport->suspended = 0;\n\n\t \n\tif (uart_console(uport)) {\n\t\t \n\t\tmemset(&termios, 0, sizeof(struct ktermios));\n\t\ttermios.c_cflag = uport->cons->cflag;\n\t\ttermios.c_ispeed = uport->cons->ispeed;\n\t\ttermios.c_ospeed = uport->cons->ospeed;\n\n\t\t \n\t\tif (port->tty && termios.c_cflag == 0)\n\t\t\ttermios = port->tty->termios;\n\n\t\tif (console_suspend_enabled)\n\t\t\tuart_change_pm(state, UART_PM_STATE_ON);\n\t\tuport->ops->set_termios(uport, &termios, NULL);\n\t\tif (!console_suspend_enabled && uport->ops->start_rx) {\n\t\t\tspin_lock_irq(&uport->lock);\n\t\t\tuport->ops->start_rx(uport);\n\t\t\tspin_unlock_irq(&uport->lock);\n\t\t}\n\t\tif (console_suspend_enabled)\n\t\t\tconsole_start(uport->cons);\n\t}\n\n\tif (tty_port_suspended(port)) {\n\t\tconst struct uart_ops *ops = uport->ops;\n\t\tint ret;\n\n\t\tuart_change_pm(state, UART_PM_STATE_ON);\n\t\tspin_lock_irq(&uport->lock);\n\t\tif (!(uport->rs485.flags & SER_RS485_ENABLED))\n\t\t\tops->set_mctrl(uport, 0);\n\t\tspin_unlock_irq(&uport->lock);\n\t\tif (console_suspend_enabled || !uart_console(uport)) {\n\t\t\t \n\t\t\tstruct tty_struct *tty = port->tty;\n\n\t\t\tret = ops->startup(uport);\n\t\t\tif (ret == 0) {\n\t\t\t\tif (tty)\n\t\t\t\t\tuart_change_line_settings(tty, state, NULL);\n\t\t\t\tuart_rs485_config(uport);\n\t\t\t\tspin_lock_irq(&uport->lock);\n\t\t\t\tif (!(uport->rs485.flags & SER_RS485_ENABLED))\n\t\t\t\t\tops->set_mctrl(uport, uport->mctrl);\n\t\t\t\tops->start_tx(uport);\n\t\t\t\tspin_unlock_irq(&uport->lock);\n\t\t\t\ttty_port_set_initialized(port, true);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tuart_shutdown(tty, state);\n\t\t\t}\n\t\t}\n\n\t\ttty_port_set_suspended(port, false);\n\t}\n\n\tmutex_unlock(&port->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(uart_resume_port);\n\nstatic inline void\nuart_report_port(struct uart_driver *drv, struct uart_port *port)\n{\n\tchar address[64];\n\n\tswitch (port->iotype) {\n\tcase UPIO_PORT:\n\t\tsnprintf(address, sizeof(address), \"I/O 0x%lx\", port->iobase);\n\t\tbreak;\n\tcase UPIO_HUB6:\n\t\tsnprintf(address, sizeof(address),\n\t\t\t \"I/O 0x%lx offset 0x%x\", port->iobase, port->hub6);\n\t\tbreak;\n\tcase UPIO_MEM:\n\tcase UPIO_MEM16:\n\tcase UPIO_MEM32:\n\tcase UPIO_MEM32BE:\n\tcase UPIO_AU:\n\tcase UPIO_TSI:\n\t\tsnprintf(address, sizeof(address),\n\t\t\t \"MMIO 0x%llx\", (unsigned long long)port->mapbase);\n\t\tbreak;\n\tdefault:\n\t\tstrscpy(address, \"*unknown*\", sizeof(address));\n\t\tbreak;\n\t}\n\n\tpr_info(\"%s%s%s at %s (irq = %d, base_baud = %d) is a %s\\n\",\n\t       port->dev ? dev_name(port->dev) : \"\",\n\t       port->dev ? \": \" : \"\",\n\t       port->name,\n\t       address, port->irq, port->uartclk / 16, uart_type(port));\n\n\t \n\tif (port->flags & UPF_MAGIC_MULTIPLIER)\n\t\tpr_info(\"%s%s%s extra baud rates supported: %d, %d\",\n\t\t\tport->dev ? dev_name(port->dev) : \"\",\n\t\t\tport->dev ? \": \" : \"\",\n\t\t\tport->name,\n\t\t\tport->uartclk / 8, port->uartclk / 4);\n}\n\nstatic void\nuart_configure_port(struct uart_driver *drv, struct uart_state *state,\n\t\t    struct uart_port *port)\n{\n\tunsigned int flags;\n\n\t \n\tif (!port->iobase && !port->mapbase && !port->membase)\n\t\treturn;\n\n\t \n\tflags = 0;\n\tif (port->flags & UPF_AUTO_IRQ)\n\t\tflags |= UART_CONFIG_IRQ;\n\tif (port->flags & UPF_BOOT_AUTOCONF) {\n\t\tif (!(port->flags & UPF_FIXED_TYPE)) {\n\t\t\tport->type = PORT_UNKNOWN;\n\t\t\tflags |= UART_CONFIG_TYPE;\n\t\t}\n\t\tport->ops->config_port(port, flags);\n\t}\n\n\tif (port->type != PORT_UNKNOWN) {\n\t\tunsigned long flags;\n\n\t\tuart_report_port(drv, port);\n\n\t\t \n\t\tuart_change_pm(state, UART_PM_STATE_ON);\n\n\t\t \n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->mctrl &= TIOCM_DTR;\n\t\tif (!(port->rs485.flags & SER_RS485_ENABLED))\n\t\t\tport->ops->set_mctrl(port, port->mctrl);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\tuart_rs485_config(port);\n\n\t\t \n\t\tif (port->cons && !console_is_registered(port->cons))\n\t\t\tregister_console(port->cons);\n\n\t\t \n\t\tif (!uart_console(port))\n\t\t\tuart_change_pm(state, UART_PM_STATE_OFF);\n\t}\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n\nstatic int uart_poll_init(struct tty_driver *driver, int line, char *options)\n{\n\tstruct uart_driver *drv = driver->driver_state;\n\tstruct uart_state *state = drv->state + line;\n\tenum uart_pm_state pm_state;\n\tstruct tty_port *tport;\n\tstruct uart_port *port;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret = 0;\n\n\ttport = &state->port;\n\tmutex_lock(&tport->mutex);\n\n\tport = uart_port_check(state);\n\tif (!port || !(port->ops->poll_get_char && port->ops->poll_put_char)) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tpm_state = state->pm_state;\n\tuart_change_pm(state, UART_PM_STATE_ON);\n\n\tif (port->ops->poll_init) {\n\t\t \n\t\tif (!tty_port_initialized(tport))\n\t\t\tret = port->ops->poll_init(port);\n\t}\n\n\tif (!ret && options) {\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\t\tconsole_list_lock();\n\t\tret = uart_set_options(port, NULL, baud, parity, bits, flow);\n\t\tconsole_list_unlock();\n\t}\nout:\n\tif (ret)\n\t\tuart_change_pm(state, pm_state);\n\tmutex_unlock(&tport->mutex);\n\treturn ret;\n}\n\nstatic int uart_poll_get_char(struct tty_driver *driver, int line)\n{\n\tstruct uart_driver *drv = driver->driver_state;\n\tstruct uart_state *state = drv->state + line;\n\tstruct uart_port *port;\n\tint ret = -1;\n\n\tport = uart_port_ref(state);\n\tif (port) {\n\t\tret = port->ops->poll_get_char(port);\n\t\tuart_port_deref(port);\n\t}\n\n\treturn ret;\n}\n\nstatic void uart_poll_put_char(struct tty_driver *driver, int line, char ch)\n{\n\tstruct uart_driver *drv = driver->driver_state;\n\tstruct uart_state *state = drv->state + line;\n\tstruct uart_port *port;\n\n\tport = uart_port_ref(state);\n\tif (!port)\n\t\treturn;\n\n\tif (ch == '\\n')\n\t\tport->ops->poll_put_char(port, '\\r');\n\tport->ops->poll_put_char(port, ch);\n\tuart_port_deref(port);\n}\n#endif\n\nstatic const struct tty_operations uart_ops = {\n\t.install\t= uart_install,\n\t.open\t\t= uart_open,\n\t.close\t\t= uart_close,\n\t.write\t\t= uart_write,\n\t.put_char\t= uart_put_char,\n\t.flush_chars\t= uart_flush_chars,\n\t.write_room\t= uart_write_room,\n\t.chars_in_buffer= uart_chars_in_buffer,\n\t.flush_buffer\t= uart_flush_buffer,\n\t.ioctl\t\t= uart_ioctl,\n\t.throttle\t= uart_throttle,\n\t.unthrottle\t= uart_unthrottle,\n\t.send_xchar\t= uart_send_xchar,\n\t.set_termios\t= uart_set_termios,\n\t.set_ldisc\t= uart_set_ldisc,\n\t.stop\t\t= uart_stop,\n\t.start\t\t= uart_start,\n\t.hangup\t\t= uart_hangup,\n\t.break_ctl\t= uart_break_ctl,\n\t.wait_until_sent= uart_wait_until_sent,\n#ifdef CONFIG_PROC_FS\n\t.proc_show\t= uart_proc_show,\n#endif\n\t.tiocmget\t= uart_tiocmget,\n\t.tiocmset\t= uart_tiocmset,\n\t.set_serial\t= uart_set_info_user,\n\t.get_serial\t= uart_get_info_user,\n\t.get_icount\t= uart_get_icount,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_init\t= uart_poll_init,\n\t.poll_get_char\t= uart_poll_get_char,\n\t.poll_put_char\t= uart_poll_put_char,\n#endif\n};\n\nstatic const struct tty_port_operations uart_port_ops = {\n\t.carrier_raised = uart_carrier_raised,\n\t.dtr_rts\t= uart_dtr_rts,\n\t.activate\t= uart_port_activate,\n\t.shutdown\t= uart_tty_port_shutdown,\n};\n\n \nint uart_register_driver(struct uart_driver *drv)\n{\n\tstruct tty_driver *normal;\n\tint i, retval = -ENOMEM;\n\n\tBUG_ON(drv->state);\n\n\t \n\tdrv->state = kcalloc(drv->nr, sizeof(struct uart_state), GFP_KERNEL);\n\tif (!drv->state)\n\t\tgoto out;\n\n\tnormal = tty_alloc_driver(drv->nr, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(normal)) {\n\t\tretval = PTR_ERR(normal);\n\t\tgoto out_kfree;\n\t}\n\n\tdrv->tty_driver = normal;\n\n\tnormal->driver_name\t= drv->driver_name;\n\tnormal->name\t\t= drv->dev_name;\n\tnormal->major\t\t= drv->major;\n\tnormal->minor_start\t= drv->minor;\n\tnormal->type\t\t= TTY_DRIVER_TYPE_SERIAL;\n\tnormal->subtype\t\t= SERIAL_TYPE_NORMAL;\n\tnormal->init_termios\t= tty_std_termios;\n\tnormal->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;\n\tnormal->init_termios.c_ispeed = normal->init_termios.c_ospeed = 9600;\n\tnormal->driver_state    = drv;\n\ttty_set_operations(normal, &uart_ops);\n\n\t \n\tfor (i = 0; i < drv->nr; i++) {\n\t\tstruct uart_state *state = drv->state + i;\n\t\tstruct tty_port *port = &state->port;\n\n\t\ttty_port_init(port);\n\t\tport->ops = &uart_port_ops;\n\t}\n\n\tretval = tty_register_driver(normal);\n\tif (retval >= 0)\n\t\treturn retval;\n\n\tfor (i = 0; i < drv->nr; i++)\n\t\ttty_port_destroy(&drv->state[i].port);\n\ttty_driver_kref_put(normal);\nout_kfree:\n\tkfree(drv->state);\nout:\n\treturn retval;\n}\nEXPORT_SYMBOL(uart_register_driver);\n\n \nvoid uart_unregister_driver(struct uart_driver *drv)\n{\n\tstruct tty_driver *p = drv->tty_driver;\n\tunsigned int i;\n\n\ttty_unregister_driver(p);\n\ttty_driver_kref_put(p);\n\tfor (i = 0; i < drv->nr; i++)\n\t\ttty_port_destroy(&drv->state[i].port);\n\tkfree(drv->state);\n\tdrv->state = NULL;\n\tdrv->tty_driver = NULL;\n}\nEXPORT_SYMBOL(uart_unregister_driver);\n\nstruct tty_driver *uart_console_device(struct console *co, int *index)\n{\n\tstruct uart_driver *p = co->data;\n\t*index = co->index;\n\treturn p->tty_driver;\n}\nEXPORT_SYMBOL_GPL(uart_console_device);\n\nstatic ssize_t uartclk_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"%d\\n\", tmp.baud_base * 16);\n}\n\nstatic ssize_t type_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"%d\\n\", tmp.type);\n}\n\nstatic ssize_t line_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"%d\\n\", tmp.line);\n}\n\nstatic ssize_t port_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\tunsigned long ioaddr;\n\n\tuart_get_info(port, &tmp);\n\tioaddr = tmp.port;\n\tif (HIGH_BITS_OFFSET)\n\t\tioaddr |= (unsigned long)tmp.port_high << HIGH_BITS_OFFSET;\n\treturn sprintf(buf, \"0x%lX\\n\", ioaddr);\n}\n\nstatic ssize_t irq_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"%d\\n\", tmp.irq);\n}\n\nstatic ssize_t flags_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"0x%X\\n\", tmp.flags);\n}\n\nstatic ssize_t xmit_fifo_size_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"%d\\n\", tmp.xmit_fifo_size);\n}\n\nstatic ssize_t close_delay_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"%d\\n\", tmp.close_delay);\n}\n\nstatic ssize_t closing_wait_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"%d\\n\", tmp.closing_wait);\n}\n\nstatic ssize_t custom_divisor_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"%d\\n\", tmp.custom_divisor);\n}\n\nstatic ssize_t io_type_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"%d\\n\", tmp.io_type);\n}\n\nstatic ssize_t iomem_base_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"0x%lX\\n\", (unsigned long)tmp.iomem_base);\n}\n\nstatic ssize_t iomem_reg_shift_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct serial_struct tmp;\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\n\tuart_get_info(port, &tmp);\n\treturn sprintf(buf, \"%d\\n\", tmp.iomem_reg_shift);\n}\n\nstatic ssize_t console_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\tstruct uart_state *state = container_of(port, struct uart_state, port);\n\tstruct uart_port *uport;\n\tbool console = false;\n\n\tmutex_lock(&port->mutex);\n\tuport = uart_port_check(state);\n\tif (uport)\n\t\tconsole = uart_console_registered(uport);\n\tmutex_unlock(&port->mutex);\n\n\treturn sprintf(buf, \"%c\\n\", console ? 'Y' : 'N');\n}\n\nstatic ssize_t console_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct tty_port *port = dev_get_drvdata(dev);\n\tstruct uart_state *state = container_of(port, struct uart_state, port);\n\tstruct uart_port *uport;\n\tbool oldconsole, newconsole;\n\tint ret;\n\n\tret = kstrtobool(buf, &newconsole);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&port->mutex);\n\tuport = uart_port_check(state);\n\tif (uport) {\n\t\toldconsole = uart_console_registered(uport);\n\t\tif (oldconsole && !newconsole) {\n\t\t\tret = unregister_console(uport->cons);\n\t\t} else if (!oldconsole && newconsole) {\n\t\t\tif (uart_console(uport)) {\n\t\t\t\tuport->console_reinit = 1;\n\t\t\t\tregister_console(uport->cons);\n\t\t\t} else {\n\t\t\t\tret = -ENOENT;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = -ENXIO;\n\t}\n\tmutex_unlock(&port->mutex);\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic DEVICE_ATTR_RO(uartclk);\nstatic DEVICE_ATTR_RO(type);\nstatic DEVICE_ATTR_RO(line);\nstatic DEVICE_ATTR_RO(port);\nstatic DEVICE_ATTR_RO(irq);\nstatic DEVICE_ATTR_RO(flags);\nstatic DEVICE_ATTR_RO(xmit_fifo_size);\nstatic DEVICE_ATTR_RO(close_delay);\nstatic DEVICE_ATTR_RO(closing_wait);\nstatic DEVICE_ATTR_RO(custom_divisor);\nstatic DEVICE_ATTR_RO(io_type);\nstatic DEVICE_ATTR_RO(iomem_base);\nstatic DEVICE_ATTR_RO(iomem_reg_shift);\nstatic DEVICE_ATTR_RW(console);\n\nstatic struct attribute *tty_dev_attrs[] = {\n\t&dev_attr_uartclk.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_line.attr,\n\t&dev_attr_port.attr,\n\t&dev_attr_irq.attr,\n\t&dev_attr_flags.attr,\n\t&dev_attr_xmit_fifo_size.attr,\n\t&dev_attr_close_delay.attr,\n\t&dev_attr_closing_wait.attr,\n\t&dev_attr_custom_divisor.attr,\n\t&dev_attr_io_type.attr,\n\t&dev_attr_iomem_base.attr,\n\t&dev_attr_iomem_reg_shift.attr,\n\t&dev_attr_console.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tty_dev_attr_group = {\n\t.attrs = tty_dev_attrs,\n};\n\n \nstatic int serial_core_add_one_port(struct uart_driver *drv, struct uart_port *uport)\n{\n\tstruct uart_state *state;\n\tstruct tty_port *port;\n\tint ret = 0;\n\tstruct device *tty_dev;\n\tint num_groups;\n\n\tif (uport->line >= drv->nr)\n\t\treturn -EINVAL;\n\n\tstate = drv->state + uport->line;\n\tport = &state->port;\n\n\tmutex_lock(&port->mutex);\n\tif (state->uart_port) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tatomic_set(&state->refcount, 1);\n\tinit_waitqueue_head(&state->remove_wait);\n\tstate->uart_port = uport;\n\tuport->state = state;\n\n\tstate->pm_state = UART_PM_STATE_UNDEFINED;\n\tuport->cons = drv->cons;\n\tuport->minor = drv->tty_driver->minor_start + uport->line;\n\tuport->name = kasprintf(GFP_KERNEL, \"%s%d\", drv->dev_name,\n\t\t\t\tdrv->tty_driver->name_base + uport->line);\n\tif (!uport->name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!uart_console_registered(uport))\n\t\tuart_port_spin_lock_init(uport);\n\n\tif (uport->cons && uport->dev)\n\t\tof_console_check(uport->dev->of_node, uport->cons->name, uport->line);\n\n\ttty_port_link_device(port, drv->tty_driver, uport->line);\n\tuart_configure_port(drv, state, uport);\n\n\tport->console = uart_console(uport);\n\n\tnum_groups = 2;\n\tif (uport->attr_group)\n\t\tnum_groups++;\n\n\tuport->tty_groups = kcalloc(num_groups, sizeof(*uport->tty_groups),\n\t\t\t\t    GFP_KERNEL);\n\tif (!uport->tty_groups) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tuport->tty_groups[0] = &tty_dev_attr_group;\n\tif (uport->attr_group)\n\t\tuport->tty_groups[1] = uport->attr_group;\n\n\t \n\ttty_dev = tty_port_register_device_attr_serdev(port, drv->tty_driver,\n\t\t\tuport->line, uport->dev, port, uport->tty_groups);\n\tif (!IS_ERR(tty_dev)) {\n\t\tdevice_set_wakeup_capable(tty_dev, 1);\n\t} else {\n\t\tdev_err(uport->dev, \"Cannot register tty device on line %d\\n\",\n\t\t       uport->line);\n\t}\n\n out:\n\tmutex_unlock(&port->mutex);\n\n\treturn ret;\n}\n\n \nstatic void serial_core_remove_one_port(struct uart_driver *drv,\n\t\t\t\t\tstruct uart_port *uport)\n{\n\tstruct uart_state *state = drv->state + uport->line;\n\tstruct tty_port *port = &state->port;\n\tstruct uart_port *uart_port;\n\tstruct tty_struct *tty;\n\n\tmutex_lock(&port->mutex);\n\tuart_port = uart_port_check(state);\n\tif (uart_port != uport)\n\t\tdev_alert(uport->dev, \"Removing wrong port: %p != %p\\n\",\n\t\t\t  uart_port, uport);\n\n\tif (!uart_port) {\n\t\tmutex_unlock(&port->mutex);\n\t\treturn;\n\t}\n\tmutex_unlock(&port->mutex);\n\n\t \n\ttty_port_unregister_device(port, drv->tty_driver, uport->line);\n\n\ttty = tty_port_tty_get(port);\n\tif (tty) {\n\t\ttty_vhangup(port->tty);\n\t\ttty_kref_put(tty);\n\t}\n\n\t \n\tif (uart_console(uport))\n\t\tunregister_console(uport->cons);\n\n\t \n\tif (uport->type != PORT_UNKNOWN && uport->ops->release_port)\n\t\tuport->ops->release_port(uport);\n\tkfree(uport->tty_groups);\n\tkfree(uport->name);\n\n\t \n\tuport->type = PORT_UNKNOWN;\n\tuport->port_dev = NULL;\n\n\tmutex_lock(&port->mutex);\n\tWARN_ON(atomic_dec_return(&state->refcount) < 0);\n\twait_event(state->remove_wait, !atomic_read(&state->refcount));\n\tstate->uart_port = NULL;\n\tmutex_unlock(&port->mutex);\n}\n\n \nbool uart_match_port(const struct uart_port *port1,\n\t\tconst struct uart_port *port2)\n{\n\tif (port1->iotype != port2->iotype)\n\t\treturn false;\n\n\tswitch (port1->iotype) {\n\tcase UPIO_PORT:\n\t\treturn port1->iobase == port2->iobase;\n\tcase UPIO_HUB6:\n\t\treturn port1->iobase == port2->iobase &&\n\t\t       port1->hub6   == port2->hub6;\n\tcase UPIO_MEM:\n\tcase UPIO_MEM16:\n\tcase UPIO_MEM32:\n\tcase UPIO_MEM32BE:\n\tcase UPIO_AU:\n\tcase UPIO_TSI:\n\t\treturn port1->mapbase == port2->mapbase;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(uart_match_port);\n\nstatic struct serial_ctrl_device *\nserial_core_get_ctrl_dev(struct serial_port_device *port_dev)\n{\n\tstruct device *dev = &port_dev->dev;\n\n\treturn to_serial_base_ctrl_device(dev->parent);\n}\n\n \nstatic struct serial_ctrl_device *serial_core_ctrl_find(struct uart_driver *drv,\n\t\t\t\t\t\t\tstruct device *phys_dev,\n\t\t\t\t\t\t\tint ctrl_id)\n{\n\tstruct uart_state *state;\n\tint i;\n\n\tlockdep_assert_held(&port_mutex);\n\n\tfor (i = 0; i < drv->nr; i++) {\n\t\tstate = drv->state + i;\n\t\tif (!state->uart_port || !state->uart_port->port_dev)\n\t\t\tcontinue;\n\n\t\tif (state->uart_port->dev == phys_dev &&\n\t\t    state->uart_port->ctrl_id == ctrl_id)\n\t\t\treturn serial_core_get_ctrl_dev(state->uart_port->port_dev);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct serial_ctrl_device *serial_core_ctrl_device_add(struct uart_port *port)\n{\n\treturn serial_base_ctrl_add(port, port->dev);\n}\n\nstatic int serial_core_port_device_add(struct serial_ctrl_device *ctrl_dev,\n\t\t\t\t       struct uart_port *port)\n{\n\tstruct serial_port_device *port_dev;\n\n\tport_dev = serial_base_port_add(port, ctrl_dev);\n\tif (IS_ERR(port_dev))\n\t\treturn PTR_ERR(port_dev);\n\n\tport->port_dev = port_dev;\n\n\treturn 0;\n}\n\n \nint serial_core_register_port(struct uart_driver *drv, struct uart_port *port)\n{\n\tstruct serial_ctrl_device *ctrl_dev, *new_ctrl_dev = NULL;\n\tint ret;\n\n\tmutex_lock(&port_mutex);\n\n\t \n\tport->flags |= UPF_DEAD;\n\n\t \n\tctrl_dev = serial_core_ctrl_find(drv, port->dev, port->ctrl_id);\n\tif (!ctrl_dev) {\n\t\tnew_ctrl_dev = serial_core_ctrl_device_add(port);\n\t\tif (IS_ERR(new_ctrl_dev)) {\n\t\t\tret = PTR_ERR(new_ctrl_dev);\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tctrl_dev = new_ctrl_dev;\n\t}\n\n\t \n\tret = serial_core_port_device_add(ctrl_dev, port);\n\tif (ret)\n\t\tgoto err_unregister_ctrl_dev;\n\n\tret = serial_core_add_one_port(drv, port);\n\tif (ret)\n\t\tgoto err_unregister_port_dev;\n\n\tport->flags &= ~UPF_DEAD;\n\n\tmutex_unlock(&port_mutex);\n\n\treturn 0;\n\nerr_unregister_port_dev:\n\tserial_base_port_device_remove(port->port_dev);\n\nerr_unregister_ctrl_dev:\n\tserial_base_ctrl_device_remove(new_ctrl_dev);\n\nerr_unlock:\n\tmutex_unlock(&port_mutex);\n\n\treturn ret;\n}\n\n \nvoid serial_core_unregister_port(struct uart_driver *drv, struct uart_port *port)\n{\n\tstruct device *phys_dev = port->dev;\n\tstruct serial_port_device *port_dev = port->port_dev;\n\tstruct serial_ctrl_device *ctrl_dev = serial_core_get_ctrl_dev(port_dev);\n\tint ctrl_id = port->ctrl_id;\n\n\tmutex_lock(&port_mutex);\n\n\tport->flags |= UPF_DEAD;\n\n\tserial_core_remove_one_port(drv, port);\n\n\t \n\tserial_base_port_device_remove(port_dev);\n\n\t \n\tif (!serial_core_ctrl_find(drv, phys_dev, ctrl_id))\n\t\tserial_base_ctrl_device_remove(ctrl_dev);\n\n\tmutex_unlock(&port_mutex);\n}\n\n \nvoid uart_handle_dcd_change(struct uart_port *uport, bool active)\n{\n\tstruct tty_port *port = &uport->state->port;\n\tstruct tty_struct *tty = port->tty;\n\tstruct tty_ldisc *ld;\n\n\tlockdep_assert_held_once(&uport->lock);\n\n\tif (tty) {\n\t\tld = tty_ldisc_ref(tty);\n\t\tif (ld) {\n\t\t\tif (ld->ops->dcd_change)\n\t\t\t\tld->ops->dcd_change(tty, active);\n\t\t\ttty_ldisc_deref(ld);\n\t\t}\n\t}\n\n\tuport->icount.dcd++;\n\n\tif (uart_dcd_enabled(uport)) {\n\t\tif (active)\n\t\t\twake_up_interruptible(&port->open_wait);\n\t\telse if (tty)\n\t\t\ttty_hangup(tty);\n\t}\n}\nEXPORT_SYMBOL_GPL(uart_handle_dcd_change);\n\n \nvoid uart_handle_cts_change(struct uart_port *uport, bool active)\n{\n\tlockdep_assert_held_once(&uport->lock);\n\n\tuport->icount.cts++;\n\n\tif (uart_softcts_mode(uport)) {\n\t\tif (uport->hw_stopped) {\n\t\t\tif (active) {\n\t\t\t\tuport->hw_stopped = false;\n\t\t\t\tuport->ops->start_tx(uport);\n\t\t\t\tuart_write_wakeup(uport);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!active) {\n\t\t\t\tuport->hw_stopped = true;\n\t\t\t\tuport->ops->stop_tx(uport);\n\t\t\t}\n\t\t}\n\n\t}\n}\nEXPORT_SYMBOL_GPL(uart_handle_cts_change);\n\n \nvoid uart_insert_char(struct uart_port *port, unsigned int status,\n\t\t      unsigned int overrun, u8 ch, u8 flag)\n{\n\tstruct tty_port *tport = &port->state->port;\n\n\tif ((status & port->ignore_status_mask & ~overrun) == 0)\n\t\tif (tty_insert_flip_char(tport, ch, flag) == 0)\n\t\t\t++port->icount.buf_overrun;\n\n\t \n\tif (status & ~port->ignore_status_mask & overrun)\n\t\tif (tty_insert_flip_char(tport, 0, TTY_OVERRUN) == 0)\n\t\t\t++port->icount.buf_overrun;\n}\nEXPORT_SYMBOL_GPL(uart_insert_char);\n\n#ifdef CONFIG_MAGIC_SYSRQ_SERIAL\nstatic const u8 sysrq_toggle_seq[] = CONFIG_MAGIC_SYSRQ_SERIAL_SEQUENCE;\n\nstatic void uart_sysrq_on(struct work_struct *w)\n{\n\tint sysrq_toggle_seq_len = strlen(sysrq_toggle_seq);\n\n\tsysrq_toggle_support(1);\n\tpr_info(\"SysRq is enabled by magic sequence '%*pE' on serial\\n\",\n\t\tsysrq_toggle_seq_len, sysrq_toggle_seq);\n}\nstatic DECLARE_WORK(sysrq_enable_work, uart_sysrq_on);\n\n \nbool uart_try_toggle_sysrq(struct uart_port *port, u8 ch)\n{\n\tint sysrq_toggle_seq_len = strlen(sysrq_toggle_seq);\n\n\tif (!sysrq_toggle_seq_len)\n\t\treturn false;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(sysrq_toggle_seq) >= U8_MAX);\n\tif (sysrq_toggle_seq[port->sysrq_seq] != ch) {\n\t\tport->sysrq_seq = 0;\n\t\treturn false;\n\t}\n\n\tif (++port->sysrq_seq < sysrq_toggle_seq_len) {\n\t\tport->sysrq = jiffies + SYSRQ_TIMEOUT;\n\t\treturn true;\n\t}\n\n\tschedule_work(&sysrq_enable_work);\n\n\tport->sysrq = 0;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(uart_try_toggle_sysrq);\n#endif\n\n \nint uart_get_rs485_mode(struct uart_port *port)\n{\n\tstruct serial_rs485 *rs485conf = &port->rs485;\n\tstruct device *dev = port->dev;\n\tu32 rs485_delay[2];\n\tint ret;\n\tint rx_during_tx_gpio_flag;\n\n\tif (!(port->rs485_supported.flags & SER_RS485_ENABLED))\n\t\treturn 0;\n\n\tret = device_property_read_u32_array(dev, \"rs485-rts-delay\",\n\t\t\t\t\t     rs485_delay, 2);\n\tif (!ret) {\n\t\trs485conf->delay_rts_before_send = rs485_delay[0];\n\t\trs485conf->delay_rts_after_send = rs485_delay[1];\n\t} else {\n\t\trs485conf->delay_rts_before_send = 0;\n\t\trs485conf->delay_rts_after_send = 0;\n\t}\n\n\tuart_sanitize_serial_rs485_delays(port, rs485conf);\n\n\t \n\trs485conf->flags &= ~(SER_RS485_RX_DURING_TX | SER_RS485_ENABLED |\n\t\t\t      SER_RS485_TERMINATE_BUS |\n\t\t\t      SER_RS485_RTS_AFTER_SEND);\n\trs485conf->flags |= SER_RS485_RTS_ON_SEND;\n\n\tif (device_property_read_bool(dev, \"rs485-rx-during-tx\"))\n\t\trs485conf->flags |= SER_RS485_RX_DURING_TX;\n\n\tif (device_property_read_bool(dev, \"linux,rs485-enabled-at-boot-time\"))\n\t\trs485conf->flags |= SER_RS485_ENABLED;\n\n\tif (device_property_read_bool(dev, \"rs485-rts-active-low\")) {\n\t\trs485conf->flags &= ~SER_RS485_RTS_ON_SEND;\n\t\trs485conf->flags |= SER_RS485_RTS_AFTER_SEND;\n\t}\n\n\t \n\tport->rs485_term_gpio = devm_gpiod_get_optional(dev, \"rs485-term\",\n\t\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(port->rs485_term_gpio)) {\n\t\tret = PTR_ERR(port->rs485_term_gpio);\n\t\tport->rs485_term_gpio = NULL;\n\t\treturn dev_err_probe(dev, ret, \"Cannot get rs485-term-gpios\\n\");\n\t}\n\tif (port->rs485_term_gpio)\n\t\tport->rs485_supported.flags |= SER_RS485_TERMINATE_BUS;\n\n\trx_during_tx_gpio_flag = (rs485conf->flags & SER_RS485_RX_DURING_TX) ?\n\t\t\t\t GPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\tport->rs485_rx_during_tx_gpio = devm_gpiod_get_optional(dev,\n\t\t\t\t\t\t\t\t\"rs485-rx-during-tx\",\n\t\t\t\t\t\t\t\trx_during_tx_gpio_flag);\n\tif (IS_ERR(port->rs485_rx_during_tx_gpio)) {\n\t\tret = PTR_ERR(port->rs485_rx_during_tx_gpio);\n\t\tport->rs485_rx_during_tx_gpio = NULL;\n\t\treturn dev_err_probe(dev, ret, \"Cannot get rs485-rx-during-tx-gpios\\n\");\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(uart_get_rs485_mode);\n\n \nstatic_assert(offsetof(struct serial_rs485, padding) ==\n              (offsetof(struct serial_rs485, delay_rts_after_send) + sizeof(__u32)));\nstatic_assert(offsetof(struct serial_rs485, padding1) ==\n\t      offsetof(struct serial_rs485, padding[1]));\nstatic_assert((offsetof(struct serial_rs485, padding[4]) + sizeof(__u32)) ==\n\t      sizeof(struct serial_rs485));\n\nMODULE_DESCRIPTION(\"Serial driver core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}