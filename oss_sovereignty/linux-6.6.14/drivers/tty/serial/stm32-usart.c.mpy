{
  "module_name": "stm32-usart.c",
  "hash_id": "0d57554428e106c8ce2a31bac2ad802c10a05b26baa15386f52ee845561f06c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/stm32-usart.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/dma-direction.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/spinlock.h>\n#include <linux/sysrq.h>\n#include <linux/tty_flip.h>\n#include <linux/tty.h>\n\n#include \"serial_mctrl_gpio.h\"\n#include \"stm32-usart.h\"\n\n\n \nstatic struct stm32_usart_info __maybe_unused stm32f4_info = {\n\t.ofs = {\n\t\t.isr\t= 0x00,\n\t\t.rdr\t= 0x04,\n\t\t.tdr\t= 0x04,\n\t\t.brr\t= 0x08,\n\t\t.cr1\t= 0x0c,\n\t\t.cr2\t= 0x10,\n\t\t.cr3\t= 0x14,\n\t\t.gtpr\t= 0x18,\n\t\t.rtor\t= UNDEF_REG,\n\t\t.rqr\t= UNDEF_REG,\n\t\t.icr\t= UNDEF_REG,\n\t},\n\t.cfg = {\n\t\t.uart_enable_bit = 13,\n\t\t.has_7bits_data = false,\n\t\t.fifosize = 1,\n\t}\n};\n\nstatic struct stm32_usart_info __maybe_unused stm32f7_info = {\n\t.ofs = {\n\t\t.cr1\t= 0x00,\n\t\t.cr2\t= 0x04,\n\t\t.cr3\t= 0x08,\n\t\t.brr\t= 0x0c,\n\t\t.gtpr\t= 0x10,\n\t\t.rtor\t= 0x14,\n\t\t.rqr\t= 0x18,\n\t\t.isr\t= 0x1c,\n\t\t.icr\t= 0x20,\n\t\t.rdr\t= 0x24,\n\t\t.tdr\t= 0x28,\n\t},\n\t.cfg = {\n\t\t.uart_enable_bit = 0,\n\t\t.has_7bits_data = true,\n\t\t.has_swap = true,\n\t\t.fifosize = 1,\n\t}\n};\n\nstatic struct stm32_usart_info __maybe_unused stm32h7_info = {\n\t.ofs = {\n\t\t.cr1\t= 0x00,\n\t\t.cr2\t= 0x04,\n\t\t.cr3\t= 0x08,\n\t\t.brr\t= 0x0c,\n\t\t.gtpr\t= 0x10,\n\t\t.rtor\t= 0x14,\n\t\t.rqr\t= 0x18,\n\t\t.isr\t= 0x1c,\n\t\t.icr\t= 0x20,\n\t\t.rdr\t= 0x24,\n\t\t.tdr\t= 0x28,\n\t},\n\t.cfg = {\n\t\t.uart_enable_bit = 0,\n\t\t.has_7bits_data = true,\n\t\t.has_swap = true,\n\t\t.has_wakeup = true,\n\t\t.has_fifo = true,\n\t\t.fifosize = 16,\n\t}\n};\n\nstatic void stm32_usart_stop_tx(struct uart_port *port);\nstatic void stm32_usart_transmit_chars(struct uart_port *port);\nstatic void __maybe_unused stm32_usart_console_putchar(struct uart_port *port, unsigned char ch);\n\nstatic inline struct stm32_port *to_stm32_port(struct uart_port *port)\n{\n\treturn container_of(port, struct stm32_port, port);\n}\n\nstatic void stm32_usart_set_bits(struct uart_port *port, u32 reg, u32 bits)\n{\n\tu32 val;\n\n\tval = readl_relaxed(port->membase + reg);\n\tval |= bits;\n\twritel_relaxed(val, port->membase + reg);\n}\n\nstatic void stm32_usart_clr_bits(struct uart_port *port, u32 reg, u32 bits)\n{\n\tu32 val;\n\n\tval = readl_relaxed(port->membase + reg);\n\tval &= ~bits;\n\twritel_relaxed(val, port->membase + reg);\n}\n\nstatic unsigned int stm32_usart_tx_empty(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\n\tif (readl_relaxed(port->membase + ofs->isr) & USART_SR_TC)\n\t\treturn TIOCSER_TEMT;\n\n\treturn 0;\n}\n\nstatic void stm32_usart_rs485_rts_enable(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tstruct serial_rs485 *rs485conf = &port->rs485;\n\n\tif (stm32_port->hw_flow_control ||\n\t    !(rs485conf->flags & SER_RS485_ENABLED))\n\t\treturn;\n\n\tif (rs485conf->flags & SER_RS485_RTS_ON_SEND) {\n\t\tmctrl_gpio_set(stm32_port->gpios,\n\t\t\t       stm32_port->port.mctrl | TIOCM_RTS);\n\t} else {\n\t\tmctrl_gpio_set(stm32_port->gpios,\n\t\t\t       stm32_port->port.mctrl & ~TIOCM_RTS);\n\t}\n}\n\nstatic void stm32_usart_rs485_rts_disable(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tstruct serial_rs485 *rs485conf = &port->rs485;\n\n\tif (stm32_port->hw_flow_control ||\n\t    !(rs485conf->flags & SER_RS485_ENABLED))\n\t\treturn;\n\n\tif (rs485conf->flags & SER_RS485_RTS_ON_SEND) {\n\t\tmctrl_gpio_set(stm32_port->gpios,\n\t\t\t       stm32_port->port.mctrl & ~TIOCM_RTS);\n\t} else {\n\t\tmctrl_gpio_set(stm32_port->gpios,\n\t\t\t       stm32_port->port.mctrl | TIOCM_RTS);\n\t}\n}\n\nstatic void stm32_usart_config_reg_rs485(u32 *cr1, u32 *cr3, u32 delay_ADE,\n\t\t\t\t\t u32 delay_DDE, u32 baud)\n{\n\tu32 rs485_deat_dedt;\n\tu32 rs485_deat_dedt_max = (USART_CR1_DEAT_MASK >> USART_CR1_DEAT_SHIFT);\n\tbool over8;\n\n\t*cr3 |= USART_CR3_DEM;\n\tover8 = *cr1 & USART_CR1_OVER8;\n\n\t*cr1 &= ~(USART_CR1_DEDT_MASK | USART_CR1_DEAT_MASK);\n\n\tif (over8)\n\t\trs485_deat_dedt = delay_ADE * baud * 8;\n\telse\n\t\trs485_deat_dedt = delay_ADE * baud * 16;\n\n\trs485_deat_dedt = DIV_ROUND_CLOSEST(rs485_deat_dedt, 1000);\n\trs485_deat_dedt = rs485_deat_dedt > rs485_deat_dedt_max ?\n\t\t\t  rs485_deat_dedt_max : rs485_deat_dedt;\n\trs485_deat_dedt = (rs485_deat_dedt << USART_CR1_DEAT_SHIFT) &\n\t\t\t   USART_CR1_DEAT_MASK;\n\t*cr1 |= rs485_deat_dedt;\n\n\tif (over8)\n\t\trs485_deat_dedt = delay_DDE * baud * 8;\n\telse\n\t\trs485_deat_dedt = delay_DDE * baud * 16;\n\n\trs485_deat_dedt = DIV_ROUND_CLOSEST(rs485_deat_dedt, 1000);\n\trs485_deat_dedt = rs485_deat_dedt > rs485_deat_dedt_max ?\n\t\t\t  rs485_deat_dedt_max : rs485_deat_dedt;\n\trs485_deat_dedt = (rs485_deat_dedt << USART_CR1_DEDT_SHIFT) &\n\t\t\t   USART_CR1_DEDT_MASK;\n\t*cr1 |= rs485_deat_dedt;\n}\n\nstatic int stm32_usart_config_rs485(struct uart_port *port, struct ktermios *termios,\n\t\t\t\t    struct serial_rs485 *rs485conf)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tconst struct stm32_usart_config *cfg = &stm32_port->info->cfg;\n\tu32 usartdiv, baud, cr1, cr3;\n\tbool over8;\n\n\tstm32_usart_clr_bits(port, ofs->cr1, BIT(cfg->uart_enable_bit));\n\n\tif (port->rs485_rx_during_tx_gpio)\n\t\tgpiod_set_value_cansleep(port->rs485_rx_during_tx_gpio,\n\t\t\t\t\t !!(rs485conf->flags & SER_RS485_RX_DURING_TX));\n\telse\n\t\trs485conf->flags |= SER_RS485_RX_DURING_TX;\n\n\tif (rs485conf->flags & SER_RS485_ENABLED) {\n\t\tcr1 = readl_relaxed(port->membase + ofs->cr1);\n\t\tcr3 = readl_relaxed(port->membase + ofs->cr3);\n\t\tusartdiv = readl_relaxed(port->membase + ofs->brr);\n\t\tusartdiv = usartdiv & GENMASK(15, 0);\n\t\tover8 = cr1 & USART_CR1_OVER8;\n\n\t\tif (over8)\n\t\t\tusartdiv = usartdiv | (usartdiv & GENMASK(4, 0))\n\t\t\t\t   << USART_BRR_04_R_SHIFT;\n\n\t\tbaud = DIV_ROUND_CLOSEST(port->uartclk, usartdiv);\n\t\tstm32_usart_config_reg_rs485(&cr1, &cr3,\n\t\t\t\t\t     rs485conf->delay_rts_before_send,\n\t\t\t\t\t     rs485conf->delay_rts_after_send,\n\t\t\t\t\t     baud);\n\n\t\tif (rs485conf->flags & SER_RS485_RTS_ON_SEND)\n\t\t\tcr3 &= ~USART_CR3_DEP;\n\t\telse\n\t\t\tcr3 |= USART_CR3_DEP;\n\n\t\twritel_relaxed(cr3, port->membase + ofs->cr3);\n\t\twritel_relaxed(cr1, port->membase + ofs->cr1);\n\t} else {\n\t\tstm32_usart_clr_bits(port, ofs->cr3,\n\t\t\t\t     USART_CR3_DEM | USART_CR3_DEP);\n\t\tstm32_usart_clr_bits(port, ofs->cr1,\n\t\t\t\t     USART_CR1_DEDT_MASK | USART_CR1_DEAT_MASK);\n\t}\n\n\tstm32_usart_set_bits(port, ofs->cr1, BIT(cfg->uart_enable_bit));\n\n\t \n\tif (stm32_usart_tx_empty(port))\n\t\tstm32_usart_rs485_rts_disable(port);\n\telse\n\t\tstm32_usart_rs485_rts_enable(port);\n\n\treturn 0;\n}\n\nstatic int stm32_usart_init_rs485(struct uart_port *port,\n\t\t\t\t  struct platform_device *pdev)\n{\n\tstruct serial_rs485 *rs485conf = &port->rs485;\n\n\trs485conf->flags = 0;\n\trs485conf->delay_rts_before_send = 0;\n\trs485conf->delay_rts_after_send = 0;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\treturn uart_get_rs485_mode(port);\n}\n\nstatic bool stm32_usart_rx_dma_started(struct stm32_port *stm32_port)\n{\n\treturn stm32_port->rx_ch ? stm32_port->rx_dma_busy : false;\n}\n\nstatic void stm32_usart_rx_dma_terminate(struct stm32_port *stm32_port)\n{\n\tdmaengine_terminate_async(stm32_port->rx_ch);\n\tstm32_port->rx_dma_busy = false;\n}\n\nstatic int stm32_usart_dma_pause_resume(struct stm32_port *stm32_port,\n\t\t\t\t\tstruct dma_chan *chan,\n\t\t\t\t\tenum dma_status expected_status,\n\t\t\t\t\tint dmaengine_pause_or_resume(struct dma_chan *),\n\t\t\t\t\tbool stm32_usart_xx_dma_started(struct stm32_port *),\n\t\t\t\t\tvoid stm32_usart_xx_dma_terminate(struct stm32_port *))\n{\n\tstruct uart_port *port = &stm32_port->port;\n\tenum dma_status dma_status;\n\tint ret;\n\n\tif (!stm32_usart_xx_dma_started(stm32_port))\n\t\treturn -EPERM;\n\n\tdma_status = dmaengine_tx_status(chan, chan->cookie, NULL);\n\tif (dma_status != expected_status)\n\t\treturn -EAGAIN;\n\n\tret = dmaengine_pause_or_resume(chan);\n\tif (ret) {\n\t\tdev_err(port->dev, \"DMA failed with error code: %d\\n\", ret);\n\t\tstm32_usart_xx_dma_terminate(stm32_port);\n\t}\n\treturn ret;\n}\n\nstatic int stm32_usart_rx_dma_pause(struct stm32_port *stm32_port)\n{\n\treturn stm32_usart_dma_pause_resume(stm32_port, stm32_port->rx_ch,\n\t\t\t\t\t    DMA_IN_PROGRESS, dmaengine_pause,\n\t\t\t\t\t    stm32_usart_rx_dma_started,\n\t\t\t\t\t    stm32_usart_rx_dma_terminate);\n}\n\nstatic int stm32_usart_rx_dma_resume(struct stm32_port *stm32_port)\n{\n\treturn stm32_usart_dma_pause_resume(stm32_port, stm32_port->rx_ch,\n\t\t\t\t\t    DMA_PAUSED, dmaengine_resume,\n\t\t\t\t\t    stm32_usart_rx_dma_started,\n\t\t\t\t\t    stm32_usart_rx_dma_terminate);\n}\n\n \nstatic bool stm32_usart_pending_rx_pio(struct uart_port *port, u32 *sr)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\n\t*sr = readl_relaxed(port->membase + ofs->isr);\n\t \n\tif (*sr & USART_SR_RXNE) {\n\t\t \n\t\tif (!stm32_usart_rx_dma_started(stm32_port))\n\t\t\treturn true;\n\n\t\t \n\t\tif (*sr & USART_SR_ERR_MASK)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u8 stm32_usart_get_char_pio(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tunsigned long c;\n\n\tc = readl_relaxed(port->membase + ofs->rdr);\n\t \n\tc &= stm32_port->rdr_mask;\n\n\treturn c;\n}\n\nstatic unsigned int stm32_usart_receive_chars_pio(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tunsigned int size = 0;\n\tu32 sr;\n\tu8 c, flag;\n\n\twhile (stm32_usart_pending_rx_pio(port, &sr)) {\n\t\tsr |= USART_SR_DUMMY_RX;\n\t\tflag = TTY_NORMAL;\n\n\t\t \n\t\tif ((sr & USART_SR_ERR_MASK) && ofs->icr != UNDEF_REG)\n\t\t\twritel_relaxed(sr & USART_SR_ERR_MASK,\n\t\t\t\t       port->membase + ofs->icr);\n\n\t\tc = stm32_usart_get_char_pio(port);\n\t\tport->icount.rx++;\n\t\tsize++;\n\t\tif (sr & USART_SR_ERR_MASK) {\n\t\t\tif (sr & USART_SR_ORE) {\n\t\t\t\tport->icount.overrun++;\n\t\t\t} else if (sr & USART_SR_PE) {\n\t\t\t\tport->icount.parity++;\n\t\t\t} else if (sr & USART_SR_FE) {\n\t\t\t\t \n\t\t\t\tif (!c) {\n\t\t\t\t\tport->icount.brk++;\n\t\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tport->icount.frame++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsr &= port->read_status_mask;\n\n\t\t\tif (sr & USART_SR_PE) {\n\t\t\t\tflag = TTY_PARITY;\n\t\t\t} else if (sr & USART_SR_FE) {\n\t\t\t\tif (!c)\n\t\t\t\t\tflag = TTY_BREAK;\n\t\t\t\telse\n\t\t\t\t\tflag = TTY_FRAME;\n\t\t\t}\n\t\t}\n\n\t\tif (uart_prepare_sysrq_char(port, c))\n\t\t\tcontinue;\n\t\tuart_insert_char(port, sr, USART_SR_ORE, c, flag);\n\t}\n\n\treturn size;\n}\n\nstatic void stm32_usart_push_buffer_dma(struct uart_port *port, unsigned int dma_size)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tstruct tty_port *ttyport = &stm32_port->port.state->port;\n\tunsigned char *dma_start;\n\tint dma_count, i;\n\n\tdma_start = stm32_port->rx_buf + (RX_BUF_L - stm32_port->last_res);\n\n\t \n\tif (!(stm32_port->rdr_mask == (BIT(8) - 1)))\n\t\tfor (i = 0; i < dma_size; i++)\n\t\t\t*(dma_start + i) &= stm32_port->rdr_mask;\n\n\tdma_count = tty_insert_flip_string(ttyport, dma_start, dma_size);\n\tport->icount.rx += dma_count;\n\tif (dma_count != dma_size)\n\t\tport->icount.buf_overrun++;\n\tstm32_port->last_res -= dma_count;\n\tif (stm32_port->last_res == 0)\n\t\tstm32_port->last_res = RX_BUF_L;\n}\n\nstatic unsigned int stm32_usart_receive_chars_dma(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tunsigned int dma_size, size = 0;\n\n\t \n\tif (stm32_port->rx_dma_state.residue > stm32_port->last_res) {\n\t\t \n\t\tdma_size = stm32_port->last_res;\n\t\tstm32_usart_push_buffer_dma(port, dma_size);\n\t\tsize = dma_size;\n\t}\n\n\tdma_size = stm32_port->last_res - stm32_port->rx_dma_state.residue;\n\tstm32_usart_push_buffer_dma(port, dma_size);\n\tsize += dma_size;\n\n\treturn size;\n}\n\nstatic unsigned int stm32_usart_receive_chars(struct uart_port *port, bool force_dma_flush)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tenum dma_status rx_dma_status;\n\tu32 sr;\n\tunsigned int size = 0;\n\n\tif (stm32_usart_rx_dma_started(stm32_port) || force_dma_flush) {\n\t\trx_dma_status = dmaengine_tx_status(stm32_port->rx_ch,\n\t\t\t\t\t\t    stm32_port->rx_ch->cookie,\n\t\t\t\t\t\t    &stm32_port->rx_dma_state);\n\t\tif (rx_dma_status == DMA_IN_PROGRESS ||\n\t\t    rx_dma_status == DMA_PAUSED) {\n\t\t\t \n\t\t\tsize = stm32_usart_receive_chars_dma(port);\n\t\t\tsr = readl_relaxed(port->membase + ofs->isr);\n\t\t\tif (sr & USART_SR_ERR_MASK) {\n\t\t\t\t \n\t\t\t\tstm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAR);\n\n\t\t\t\t \n\t\t\t\tsize += stm32_usart_receive_chars_pio(port);\n\n\t\t\t\t \n\t\t\t\tstm32_usart_set_bits(port, ofs->cr3, USART_CR3_DMAR);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tstm32_usart_rx_dma_terminate(stm32_port);\n\t\t\t \n\t\t\tdev_dbg(port->dev, \"DMA error, fallback to irq mode\\n\");\n\t\t\tsize = stm32_usart_receive_chars_pio(port);\n\t\t}\n\t} else {\n\t\tsize = stm32_usart_receive_chars_pio(port);\n\t}\n\n\treturn size;\n}\n\nstatic void stm32_usart_rx_dma_complete(void *arg)\n{\n\tstruct uart_port *port = arg;\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned int size;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tsize = stm32_usart_receive_chars(port, false);\n\tuart_unlock_and_check_sysrq_irqrestore(port, flags);\n\tif (size)\n\t\ttty_flip_buffer_push(tport);\n}\n\nstatic int stm32_usart_rx_dma_start_or_resume(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tstruct dma_async_tx_descriptor *desc;\n\tenum dma_status rx_dma_status;\n\tint ret;\n\n\tif (stm32_port->throttled)\n\t\treturn 0;\n\n\tif (stm32_port->rx_dma_busy) {\n\t\trx_dma_status = dmaengine_tx_status(stm32_port->rx_ch,\n\t\t\t\t\t\t    stm32_port->rx_ch->cookie,\n\t\t\t\t\t\t    NULL);\n\t\tif (rx_dma_status == DMA_IN_PROGRESS)\n\t\t\treturn 0;\n\n\t\tif (rx_dma_status == DMA_PAUSED && !stm32_usart_rx_dma_resume(stm32_port))\n\t\t\treturn 0;\n\n\t\tdev_err(port->dev, \"DMA failed : status error.\\n\");\n\t\tstm32_usart_rx_dma_terminate(stm32_port);\n\t}\n\n\tstm32_port->rx_dma_busy = true;\n\n\tstm32_port->last_res = RX_BUF_L;\n\t \n\tdesc = dmaengine_prep_dma_cyclic(stm32_port->rx_ch,\n\t\t\t\t\t stm32_port->rx_dma_buf,\n\t\t\t\t\t RX_BUF_L, RX_BUF_P,\n\t\t\t\t\t DMA_DEV_TO_MEM,\n\t\t\t\t\t DMA_PREP_INTERRUPT);\n\tif (!desc) {\n\t\tdev_err(port->dev, \"rx dma prep cyclic failed\\n\");\n\t\tstm32_port->rx_dma_busy = false;\n\t\treturn -ENODEV;\n\t}\n\n\tdesc->callback = stm32_usart_rx_dma_complete;\n\tdesc->callback_param = port;\n\n\t \n\tret = dma_submit_error(dmaengine_submit(desc));\n\tif (ret) {\n\t\tdmaengine_terminate_sync(stm32_port->rx_ch);\n\t\tstm32_port->rx_dma_busy = false;\n\t\treturn ret;\n\t}\n\n\t \n\tdma_async_issue_pending(stm32_port->rx_ch);\n\n\treturn 0;\n}\n\nstatic void stm32_usart_tx_dma_terminate(struct stm32_port *stm32_port)\n{\n\tdmaengine_terminate_async(stm32_port->tx_ch);\n\tstm32_port->tx_dma_busy = false;\n}\n\nstatic bool stm32_usart_tx_dma_started(struct stm32_port *stm32_port)\n{\n\t \n\treturn stm32_port->tx_dma_busy;\n}\n\nstatic int stm32_usart_tx_dma_pause(struct stm32_port *stm32_port)\n{\n\treturn stm32_usart_dma_pause_resume(stm32_port, stm32_port->tx_ch,\n\t\t\t\t\t    DMA_IN_PROGRESS, dmaengine_pause,\n\t\t\t\t\t    stm32_usart_tx_dma_started,\n\t\t\t\t\t    stm32_usart_tx_dma_terminate);\n}\n\nstatic int stm32_usart_tx_dma_resume(struct stm32_port *stm32_port)\n{\n\treturn stm32_usart_dma_pause_resume(stm32_port, stm32_port->tx_ch,\n\t\t\t\t\t    DMA_PAUSED, dmaengine_resume,\n\t\t\t\t\t    stm32_usart_tx_dma_started,\n\t\t\t\t\t    stm32_usart_tx_dma_terminate);\n}\n\nstatic void stm32_usart_tx_dma_complete(void *arg)\n{\n\tstruct uart_port *port = arg;\n\tstruct stm32_port *stm32port = to_stm32_port(port);\n\tunsigned long flags;\n\n\tstm32_usart_tx_dma_terminate(stm32port);\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tstm32_usart_transmit_chars(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void stm32_usart_tx_interrupt_enable(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\n\t \n\tif (stm32_port->fifoen && stm32_port->txftcfg >= 0)\n\t\tstm32_usart_set_bits(port, ofs->cr3, USART_CR3_TXFTIE);\n\telse\n\t\tstm32_usart_set_bits(port, ofs->cr1, USART_CR1_TXEIE);\n}\n\nstatic void stm32_usart_tc_interrupt_enable(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\n\tstm32_usart_set_bits(port, ofs->cr1, USART_CR1_TCIE);\n}\n\nstatic void stm32_usart_tx_interrupt_disable(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\n\tif (stm32_port->fifoen && stm32_port->txftcfg >= 0)\n\t\tstm32_usart_clr_bits(port, ofs->cr3, USART_CR3_TXFTIE);\n\telse\n\t\tstm32_usart_clr_bits(port, ofs->cr1, USART_CR1_TXEIE);\n}\n\nstatic void stm32_usart_tc_interrupt_disable(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\n\tstm32_usart_clr_bits(port, ofs->cr1, USART_CR1_TCIE);\n}\n\nstatic void stm32_usart_transmit_chars_pio(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\twhile (!uart_circ_empty(xmit)) {\n\t\t \n\t\tif (!(readl_relaxed(port->membase + ofs->isr) & USART_SR_TXE))\n\t\t\tbreak;\n\t\twritel_relaxed(xmit->buf[xmit->tail], port->membase + ofs->tdr);\n\t\tuart_xmit_advance(port, 1);\n\t}\n\n\t \n\tif (uart_circ_empty(xmit))\n\t\tstm32_usart_tx_interrupt_disable(port);\n\telse\n\t\tstm32_usart_tx_interrupt_enable(port);\n}\n\nstatic void stm32_usart_transmit_chars_dma(struct uart_port *port)\n{\n\tstruct stm32_port *stm32port = to_stm32_port(port);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tstruct dma_async_tx_descriptor *desc = NULL;\n\tunsigned int count;\n\tint ret;\n\n\tif (stm32_usart_tx_dma_started(stm32port)) {\n\t\tret = stm32_usart_tx_dma_resume(stm32port);\n\t\tif (ret < 0 && ret != -EAGAIN)\n\t\t\tgoto fallback_err;\n\t\treturn;\n\t}\n\n\tcount = uart_circ_chars_pending(xmit);\n\n\tif (count > TX_BUF_L)\n\t\tcount = TX_BUF_L;\n\n\tif (xmit->tail < xmit->head) {\n\t\tmemcpy(&stm32port->tx_buf[0], &xmit->buf[xmit->tail], count);\n\t} else {\n\t\tsize_t one = UART_XMIT_SIZE - xmit->tail;\n\t\tsize_t two;\n\n\t\tif (one > count)\n\t\t\tone = count;\n\t\ttwo = count - one;\n\n\t\tmemcpy(&stm32port->tx_buf[0], &xmit->buf[xmit->tail], one);\n\t\tif (two)\n\t\t\tmemcpy(&stm32port->tx_buf[one], &xmit->buf[0], two);\n\t}\n\n\tdesc = dmaengine_prep_slave_single(stm32port->tx_ch,\n\t\t\t\t\t   stm32port->tx_dma_buf,\n\t\t\t\t\t   count,\n\t\t\t\t\t   DMA_MEM_TO_DEV,\n\t\t\t\t\t   DMA_PREP_INTERRUPT);\n\n\tif (!desc)\n\t\tgoto fallback_err;\n\n\t \n\tstm32port->tx_dma_busy = true;\n\n\tdesc->callback = stm32_usart_tx_dma_complete;\n\tdesc->callback_param = port;\n\n\t \n\t \n\tret = dma_submit_error(dmaengine_submit(desc));\n\tif (ret) {\n\t\tdev_err(port->dev, \"DMA failed with error code: %d\\n\", ret);\n\t\tstm32_usart_tx_dma_terminate(stm32port);\n\t\tgoto fallback_err;\n\t}\n\n\t \n\tdma_async_issue_pending(stm32port->tx_ch);\n\n\tuart_xmit_advance(port, count);\n\n\treturn;\n\nfallback_err:\n\tstm32_usart_transmit_chars_pio(port);\n}\n\nstatic void stm32_usart_transmit_chars(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tu32 isr;\n\tint ret;\n\n\tif (!stm32_port->hw_flow_control &&\n\t    port->rs485.flags & SER_RS485_ENABLED &&\n\t    (port->x_char ||\n\t     !(uart_circ_empty(xmit) || uart_tx_stopped(port)))) {\n\t\tstm32_usart_tc_interrupt_disable(port);\n\t\tstm32_usart_rs485_rts_enable(port);\n\t}\n\n\tif (port->x_char) {\n\t\t \n\t\tstm32_usart_tx_dma_pause(stm32_port);\n\n\t\t \n\t\tret =\n\t\treadl_relaxed_poll_timeout_atomic(port->membase + ofs->isr,\n\t\t\t\t\t\t  isr,\n\t\t\t\t\t\t  (isr & USART_SR_TXE),\n\t\t\t\t\t\t  10, 1000);\n\t\tif (ret)\n\t\t\tdev_warn(port->dev, \"1 character may be erased\\n\");\n\n\t\twritel_relaxed(port->x_char, port->membase + ofs->tdr);\n\t\tport->x_char = 0;\n\t\tport->icount.tx++;\n\n\t\t \n\t\tstm32_usart_tx_dma_resume(stm32_port);\n\t\treturn;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\tstm32_usart_tx_interrupt_disable(port);\n\t\treturn;\n\t}\n\n\tif (ofs->icr == UNDEF_REG)\n\t\tstm32_usart_clr_bits(port, ofs->isr, USART_SR_TC);\n\telse\n\t\twritel_relaxed(USART_ICR_TCCF, port->membase + ofs->icr);\n\n\tif (stm32_port->tx_ch)\n\t\tstm32_usart_transmit_chars_dma(port);\n\telse\n\t\tstm32_usart_transmit_chars_pio(port);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (uart_circ_empty(xmit)) {\n\t\tstm32_usart_tx_interrupt_disable(port);\n\t\tif (!stm32_port->hw_flow_control &&\n\t\t    port->rs485.flags & SER_RS485_ENABLED) {\n\t\t\tstm32_usart_tc_interrupt_enable(port);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t stm32_usart_interrupt(int irq, void *ptr)\n{\n\tstruct uart_port *port = ptr;\n\tstruct tty_port *tport = &port->state->port;\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tu32 sr;\n\tunsigned int size;\n\n\tsr = readl_relaxed(port->membase + ofs->isr);\n\n\tif (!stm32_port->hw_flow_control &&\n\t    port->rs485.flags & SER_RS485_ENABLED &&\n\t    (sr & USART_SR_TC)) {\n\t\tstm32_usart_tc_interrupt_disable(port);\n\t\tstm32_usart_rs485_rts_disable(port);\n\t}\n\n\tif ((sr & USART_SR_RTOF) && ofs->icr != UNDEF_REG)\n\t\twritel_relaxed(USART_ICR_RTOCF,\n\t\t\t       port->membase + ofs->icr);\n\n\tif ((sr & USART_SR_WUF) && ofs->icr != UNDEF_REG) {\n\t\t \n\t\twritel_relaxed(USART_ICR_WUCF,\n\t\t\t       port->membase + ofs->icr);\n\t\tstm32_usart_clr_bits(port, ofs->cr3, USART_CR3_WUFIE);\n\t\tif (irqd_is_wakeup_set(irq_get_irq_data(port->irq)))\n\t\t\tpm_wakeup_event(tport->tty->dev, 0);\n\t}\n\n\t \n\tif (!stm32_port->throttled) {\n\t\tif (((sr & USART_SR_RXNE) && !stm32_usart_rx_dma_started(stm32_port)) ||\n\t\t    ((sr & USART_SR_ERR_MASK) && stm32_usart_rx_dma_started(stm32_port))) {\n\t\t\tspin_lock(&port->lock);\n\t\t\tsize = stm32_usart_receive_chars(port, false);\n\t\t\tuart_unlock_and_check_sysrq(port);\n\t\t\tif (size)\n\t\t\t\ttty_flip_buffer_push(tport);\n\t\t}\n\t}\n\n\tif ((sr & USART_SR_TXE) && !(stm32_port->tx_ch)) {\n\t\tspin_lock(&port->lock);\n\t\tstm32_usart_transmit_chars(port);\n\t\tspin_unlock(&port->lock);\n\t}\n\n\t \n\tif (stm32_usart_rx_dma_started(stm32_port) && !stm32_port->throttled) {\n\t\tspin_lock(&port->lock);\n\t\tsize = stm32_usart_receive_chars(port, false);\n\t\tuart_unlock_and_check_sysrq(port);\n\t\tif (size)\n\t\t\ttty_flip_buffer_push(tport);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void stm32_usart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\n\tif ((mctrl & TIOCM_RTS) && (port->status & UPSTAT_AUTORTS))\n\t\tstm32_usart_set_bits(port, ofs->cr3, USART_CR3_RTSE);\n\telse\n\t\tstm32_usart_clr_bits(port, ofs->cr3, USART_CR3_RTSE);\n\n\tmctrl_gpio_set(stm32_port->gpios, mctrl);\n}\n\nstatic unsigned int stm32_usart_get_mctrl(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tunsigned int ret;\n\n\t \n\tret = TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n\n\treturn mctrl_gpio_get(stm32_port->gpios, &ret);\n}\n\nstatic void stm32_usart_enable_ms(struct uart_port *port)\n{\n\tmctrl_gpio_enable_ms(to_stm32_port(port)->gpios);\n}\n\nstatic void stm32_usart_disable_ms(struct uart_port *port)\n{\n\tmctrl_gpio_disable_ms(to_stm32_port(port)->gpios);\n}\n\n \nstatic void stm32_usart_stop_tx(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\n\tstm32_usart_tx_interrupt_disable(port);\n\n\t \n\tstm32_usart_tx_dma_pause(stm32_port);\n\n\tstm32_usart_rs485_rts_disable(port);\n}\n\n \nstatic void stm32_usart_start_tx(struct uart_port *port)\n{\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\tif (uart_circ_empty(xmit) && !port->x_char) {\n\t\tstm32_usart_rs485_rts_disable(port);\n\t\treturn;\n\t}\n\n\tstm32_usart_rs485_rts_enable(port);\n\n\tstm32_usart_transmit_chars(port);\n}\n\n \nstatic void stm32_usart_flush_buffer(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\n\tif (stm32_port->tx_ch)\n\t\tstm32_usart_tx_dma_terminate(stm32_port);\n}\n\n \nstatic void stm32_usart_throttle(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tstm32_usart_rx_dma_pause(stm32_port);\n\n\tstm32_usart_clr_bits(port, ofs->cr1, stm32_port->cr1_irq);\n\tif (stm32_port->cr3_irq)\n\t\tstm32_usart_clr_bits(port, ofs->cr3, stm32_port->cr3_irq);\n\n\tstm32_port->throttled = true;\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic void stm32_usart_unthrottle(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tstm32_usart_set_bits(port, ofs->cr1, stm32_port->cr1_irq);\n\tif (stm32_port->cr3_irq)\n\t\tstm32_usart_set_bits(port, ofs->cr3, stm32_port->cr3_irq);\n\n\tstm32_port->throttled = false;\n\n\t \n\tif (stm32_port->rx_ch)\n\t\tstm32_usart_rx_dma_start_or_resume(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \nstatic void stm32_usart_stop_rx(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\n\t \n\tstm32_usart_rx_dma_pause(stm32_port);\n\n\tstm32_usart_clr_bits(port, ofs->cr1, stm32_port->cr1_irq);\n\tif (stm32_port->cr3_irq)\n\t\tstm32_usart_clr_bits(port, ofs->cr3, stm32_port->cr3_irq);\n}\n\n \nstatic void stm32_usart_break_ctl(struct uart_port *port, int break_state)\n{\n}\n\nstatic int stm32_usart_startup(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tconst struct stm32_usart_config *cfg = &stm32_port->info->cfg;\n\tconst char *name = to_platform_device(port->dev)->name;\n\tu32 val;\n\tint ret;\n\n\tret = request_irq(port->irq, stm32_usart_interrupt,\n\t\t\t  IRQF_NO_SUSPEND, name, port);\n\tif (ret)\n\t\treturn ret;\n\n\tif (stm32_port->swap) {\n\t\tval = readl_relaxed(port->membase + ofs->cr2);\n\t\tval |= USART_CR2_SWAP;\n\t\twritel_relaxed(val, port->membase + ofs->cr2);\n\t}\n\n\t \n\tif (ofs->rqr != UNDEF_REG)\n\t\twritel_relaxed(USART_RQR_RXFRQ, port->membase + ofs->rqr);\n\n\tif (stm32_port->rx_ch) {\n\t\tret = stm32_usart_rx_dma_start_or_resume(port);\n\t\tif (ret) {\n\t\t\tfree_irq(port->irq, port);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tval = stm32_port->cr1_irq | USART_CR1_RE | BIT(cfg->uart_enable_bit);\n\tstm32_usart_set_bits(port, ofs->cr1, val);\n\n\treturn 0;\n}\n\nstatic void stm32_usart_shutdown(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tconst struct stm32_usart_config *cfg = &stm32_port->info->cfg;\n\tu32 val, isr;\n\tint ret;\n\n\tif (stm32_usart_tx_dma_started(stm32_port))\n\t\tstm32_usart_tx_dma_terminate(stm32_port);\n\n\tif (stm32_port->tx_ch)\n\t\tstm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);\n\n\t \n\tstm32_usart_disable_ms(port);\n\n\tval = USART_CR1_TXEIE | USART_CR1_TE;\n\tval |= stm32_port->cr1_irq | USART_CR1_RE;\n\tval |= BIT(cfg->uart_enable_bit);\n\tif (stm32_port->fifoen)\n\t\tval |= USART_CR1_FIFOEN;\n\n\tret = readl_relaxed_poll_timeout(port->membase + ofs->isr,\n\t\t\t\t\t isr, (isr & USART_SR_TC),\n\t\t\t\t\t 10, 100000);\n\n\t \n\tif (ret)\n\t\tdev_err(port->dev, \"Transmission is not complete\\n\");\n\n\t \n\tif (stm32_port->rx_ch) {\n\t\tstm32_usart_rx_dma_terminate(stm32_port);\n\t\tdmaengine_synchronize(stm32_port->rx_ch);\n\t}\n\n\t \n\tif (ofs->rqr != UNDEF_REG)\n\t\twritel_relaxed(USART_RQR_TXFRQ | USART_RQR_RXFRQ,\n\t\t\t       port->membase + ofs->rqr);\n\n\tstm32_usart_clr_bits(port, ofs->cr1, val);\n\n\tfree_irq(port->irq, port);\n}\n\nstatic void stm32_usart_set_termios(struct uart_port *port,\n\t\t\t\t    struct ktermios *termios,\n\t\t\t\t    const struct ktermios *old)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tconst struct stm32_usart_config *cfg = &stm32_port->info->cfg;\n\tstruct serial_rs485 *rs485conf = &port->rs485;\n\tunsigned int baud, bits;\n\tu32 usartdiv, mantissa, fraction, oversampling;\n\ttcflag_t cflag = termios->c_cflag;\n\tu32 cr1, cr2, cr3, isr;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!stm32_port->hw_flow_control)\n\t\tcflag &= ~CRTSCTS;\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 8);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tret = readl_relaxed_poll_timeout_atomic(port->membase + ofs->isr,\n\t\t\t\t\t\tisr,\n\t\t\t\t\t\t(isr & USART_SR_TC),\n\t\t\t\t\t\t10, 100000);\n\n\t \n\tif (ret)\n\t\tdev_err(port->dev, \"Transmission is not complete\\n\");\n\n\t \n\twritel_relaxed(0, port->membase + ofs->cr1);\n\n\t \n\tif (ofs->rqr != UNDEF_REG)\n\t\twritel_relaxed(USART_RQR_TXFRQ | USART_RQR_RXFRQ,\n\t\t\t       port->membase + ofs->rqr);\n\n\tcr1 = USART_CR1_TE | USART_CR1_RE;\n\tif (stm32_port->fifoen)\n\t\tcr1 |= USART_CR1_FIFOEN;\n\tcr2 = stm32_port->swap ? USART_CR2_SWAP : 0;\n\n\t \n\tcr3 = readl_relaxed(port->membase + ofs->cr3);\n\tcr3 &= USART_CR3_TXFTIE | USART_CR3_RXFTIE;\n\tif (stm32_port->fifoen) {\n\t\tif (stm32_port->txftcfg >= 0)\n\t\t\tcr3 |= stm32_port->txftcfg << USART_CR3_TXFTCFG_SHIFT;\n\t\tif (stm32_port->rxftcfg >= 0)\n\t\t\tcr3 |= stm32_port->rxftcfg << USART_CR3_RXFTCFG_SHIFT;\n\t}\n\n\tif (cflag & CSTOPB)\n\t\tcr2 |= USART_CR2_STOP_2B;\n\n\tbits = tty_get_char_size(cflag);\n\tstm32_port->rdr_mask = (BIT(bits) - 1);\n\n\tif (cflag & PARENB) {\n\t\tbits++;\n\t\tcr1 |= USART_CR1_PCE;\n\t}\n\n\t \n\tif (bits == 9) {\n\t\tcr1 |= USART_CR1_M0;\n\t} else if ((bits == 7) && cfg->has_7bits_data) {\n\t\tcr1 |= USART_CR1_M1;\n\t} else if (bits != 8) {\n\t\tdev_dbg(port->dev, \"Unsupported data bits config: %u bits\\n\"\n\t\t\t, bits);\n\t\tcflag &= ~CSIZE;\n\t\tcflag |= CS8;\n\t\ttermios->c_cflag = cflag;\n\t\tbits = 8;\n\t\tif (cflag & PARENB) {\n\t\t\tbits++;\n\t\t\tcr1 |= USART_CR1_M0;\n\t\t}\n\t}\n\n\tif (ofs->rtor != UNDEF_REG && (stm32_port->rx_ch ||\n\t\t\t\t       (stm32_port->fifoen &&\n\t\t\t\t\tstm32_port->rxftcfg >= 0))) {\n\t\tif (cflag & CSTOPB)\n\t\t\tbits = bits + 3;  \n\t\telse\n\t\t\tbits = bits + 2;  \n\n\t\t \n\t\tstm32_port->cr1_irq = USART_CR1_RTOIE;\n\t\twritel_relaxed(bits, port->membase + ofs->rtor);\n\t\tcr2 |= USART_CR2_RTOEN;\n\t\t \n\t\tstm32_port->cr3_irq =  USART_CR3_RXFTIE;\n\t}\n\n\tcr1 |= stm32_port->cr1_irq;\n\tcr3 |= stm32_port->cr3_irq;\n\n\tif (cflag & PARODD)\n\t\tcr1 |= USART_CR1_PS;\n\n\tport->status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS);\n\tif (cflag & CRTSCTS) {\n\t\tport->status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;\n\t\tcr3 |= USART_CR3_CTSE | USART_CR3_RTSE;\n\t}\n\n\tusartdiv = DIV_ROUND_CLOSEST(port->uartclk, baud);\n\n\t \n\tif (usartdiv < 16) {\n\t\toversampling = 8;\n\t\tcr1 |= USART_CR1_OVER8;\n\t\tstm32_usart_set_bits(port, ofs->cr1, USART_CR1_OVER8);\n\t} else {\n\t\toversampling = 16;\n\t\tcr1 &= ~USART_CR1_OVER8;\n\t\tstm32_usart_clr_bits(port, ofs->cr1, USART_CR1_OVER8);\n\t}\n\n\tmantissa = (usartdiv / oversampling) << USART_BRR_DIV_M_SHIFT;\n\tfraction = usartdiv % oversampling;\n\twritel_relaxed(mantissa | fraction, port->membase + ofs->brr);\n\n\tuart_update_timeout(port, cflag, baud);\n\n\tport->read_status_mask = USART_SR_ORE;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= USART_SR_PE | USART_SR_FE;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tport->read_status_mask |= USART_SR_FE;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask = USART_SR_PE | USART_SR_FE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= USART_SR_FE;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= USART_SR_ORE;\n\t}\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= USART_SR_DUMMY_RX;\n\n\tif (stm32_port->rx_ch) {\n\t\t \n\t\tcr1 |= USART_CR1_PEIE;\n\t\tcr3 |= USART_CR3_EIE;\n\t\tcr3 |= USART_CR3_DMAR;\n\t\tcr3 |= USART_CR3_DDRE;\n\t}\n\n\tif (stm32_port->tx_ch)\n\t\tcr3 |= USART_CR3_DMAT;\n\n\tif (rs485conf->flags & SER_RS485_ENABLED) {\n\t\tstm32_usart_config_reg_rs485(&cr1, &cr3,\n\t\t\t\t\t     rs485conf->delay_rts_before_send,\n\t\t\t\t\t     rs485conf->delay_rts_after_send,\n\t\t\t\t\t     baud);\n\t\tif (rs485conf->flags & SER_RS485_RTS_ON_SEND) {\n\t\t\tcr3 &= ~USART_CR3_DEP;\n\t\t\trs485conf->flags &= ~SER_RS485_RTS_AFTER_SEND;\n\t\t} else {\n\t\t\tcr3 |= USART_CR3_DEP;\n\t\t\trs485conf->flags |= SER_RS485_RTS_AFTER_SEND;\n\t\t}\n\n\t} else {\n\t\tcr3 &= ~(USART_CR3_DEM | USART_CR3_DEP);\n\t\tcr1 &= ~(USART_CR1_DEDT_MASK | USART_CR1_DEAT_MASK);\n\t}\n\n\t \n\tif (stm32_port->wakeup_src) {\n\t\tcr3 &= ~USART_CR3_WUS_MASK;\n\t\tcr3 |= USART_CR3_WUS_START_BIT;\n\t}\n\n\twritel_relaxed(cr3, port->membase + ofs->cr3);\n\twritel_relaxed(cr2, port->membase + ofs->cr2);\n\twritel_relaxed(cr1, port->membase + ofs->cr1);\n\n\tstm32_usart_set_bits(port, ofs->cr1, BIT(cfg->uart_enable_bit));\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\tif (UART_ENABLE_MS(port, termios->c_cflag))\n\t\tstm32_usart_enable_ms(port);\n\telse\n\t\tstm32_usart_disable_ms(port);\n}\n\nstatic const char *stm32_usart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_STM32) ? DRIVER_NAME : NULL;\n}\n\nstatic void stm32_usart_release_port(struct uart_port *port)\n{\n}\n\nstatic int stm32_usart_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void stm32_usart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_STM32;\n}\n\nstatic int\nstm32_usart_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic void stm32_usart_pm(struct uart_port *port, unsigned int state,\n\t\t\t   unsigned int oldstate)\n{\n\tstruct stm32_port *stm32port = container_of(port,\n\t\t\tstruct stm32_port, port);\n\tconst struct stm32_usart_offsets *ofs = &stm32port->info->ofs;\n\tconst struct stm32_usart_config *cfg = &stm32port->info->cfg;\n\tunsigned long flags;\n\n\tswitch (state) {\n\tcase UART_PM_STATE_ON:\n\t\tpm_runtime_get_sync(port->dev);\n\t\tbreak;\n\tcase UART_PM_STATE_OFF:\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tstm32_usart_clr_bits(port, ofs->cr1, BIT(cfg->uart_enable_bit));\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tpm_runtime_put_sync(port->dev);\n\t\tbreak;\n\t}\n}\n\n#if defined(CONFIG_CONSOLE_POLL)\n\n  \nstatic int stm32_usart_poll_init(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\n\treturn clk_prepare_enable(stm32_port->clk);\n}\n\nstatic int stm32_usart_poll_get_char(struct uart_port *port)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\n\tif (!(readl_relaxed(port->membase + ofs->isr) & USART_SR_RXNE))\n\t\treturn NO_POLL_CHAR;\n\n\treturn readl_relaxed(port->membase + ofs->rdr) & stm32_port->rdr_mask;\n}\n\nstatic void stm32_usart_poll_put_char(struct uart_port *port, unsigned char ch)\n{\n\tstm32_usart_console_putchar(port, ch);\n}\n#endif  \n\nstatic const struct uart_ops stm32_uart_ops = {\n\t.tx_empty\t= stm32_usart_tx_empty,\n\t.set_mctrl\t= stm32_usart_set_mctrl,\n\t.get_mctrl\t= stm32_usart_get_mctrl,\n\t.stop_tx\t= stm32_usart_stop_tx,\n\t.start_tx\t= stm32_usart_start_tx,\n\t.throttle\t= stm32_usart_throttle,\n\t.unthrottle\t= stm32_usart_unthrottle,\n\t.stop_rx\t= stm32_usart_stop_rx,\n\t.enable_ms\t= stm32_usart_enable_ms,\n\t.break_ctl\t= stm32_usart_break_ctl,\n\t.startup\t= stm32_usart_startup,\n\t.shutdown\t= stm32_usart_shutdown,\n\t.flush_buffer\t= stm32_usart_flush_buffer,\n\t.set_termios\t= stm32_usart_set_termios,\n\t.pm\t\t= stm32_usart_pm,\n\t.type\t\t= stm32_usart_type,\n\t.release_port\t= stm32_usart_release_port,\n\t.request_port\t= stm32_usart_request_port,\n\t.config_port\t= stm32_usart_config_port,\n\t.verify_port\t= stm32_usart_verify_port,\n#if defined(CONFIG_CONSOLE_POLL)\n\t.poll_init      = stm32_usart_poll_init,\n\t.poll_get_char\t= stm32_usart_poll_get_char,\n\t.poll_put_char\t= stm32_usart_poll_put_char,\n#endif  \n};\n\n \nstatic const u32 stm32h7_usart_fifo_thresh_cfg[] = { 1, 2, 4, 8, 12, 14, 16 };\n\nstatic void stm32_usart_get_ftcfg(struct platform_device *pdev, const char *p,\n\t\t\t\t  int *ftcfg)\n{\n\tu32 bytes, i;\n\n\t \n\tif (of_property_read_u32(pdev->dev.of_node, p, &bytes))\n\t\tbytes = 8;\n\n\tfor (i = 0; i < ARRAY_SIZE(stm32h7_usart_fifo_thresh_cfg); i++)\n\t\tif (stm32h7_usart_fifo_thresh_cfg[i] >= bytes)\n\t\t\tbreak;\n\tif (i >= ARRAY_SIZE(stm32h7_usart_fifo_thresh_cfg))\n\t\ti = ARRAY_SIZE(stm32h7_usart_fifo_thresh_cfg) - 1;\n\n\tdev_dbg(&pdev->dev, \"%s set to %d bytes\\n\", p,\n\t\tstm32h7_usart_fifo_thresh_cfg[i]);\n\n\t \n\tif (i)\n\t\t*ftcfg = i - 1;\n\telse\n\t\t*ftcfg = -EINVAL;\n}\n\nstatic void stm32_usart_deinit_port(struct stm32_port *stm32port)\n{\n\tclk_disable_unprepare(stm32port->clk);\n}\n\nstatic const struct serial_rs485 stm32_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | SER_RS485_RTS_AFTER_SEND |\n\t\t SER_RS485_RX_DURING_TX,\n\t.delay_rts_before_send = 1,\n\t.delay_rts_after_send = 1,\n};\n\nstatic int stm32_usart_init_port(struct stm32_port *stm32port,\n\t\t\t\t struct platform_device *pdev)\n{\n\tstruct uart_port *port = &stm32port->port;\n\tstruct resource *res;\n\tint ret, irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tport->iotype\t= UPIO_MEM;\n\tport->flags\t= UPF_BOOT_AUTOCONF;\n\tport->ops\t= &stm32_uart_ops;\n\tport->dev\t= &pdev->dev;\n\tport->fifosize\t= stm32port->info->cfg.fifosize;\n\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_STM32_CONSOLE);\n\tport->irq = irq;\n\tport->rs485_config = stm32_usart_config_rs485;\n\tport->rs485_supported = stm32_rs485_supported;\n\n\tret = stm32_usart_init_rs485(port, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tstm32port->wakeup_src = stm32port->info->cfg.has_wakeup &&\n\t\tof_property_read_bool(pdev->dev.of_node, \"wakeup-source\");\n\n\tstm32port->swap = stm32port->info->cfg.has_swap &&\n\t\tof_property_read_bool(pdev->dev.of_node, \"rx-tx-swap\");\n\n\tstm32port->fifoen = stm32port->info->cfg.has_fifo;\n\tif (stm32port->fifoen) {\n\t\tstm32_usart_get_ftcfg(pdev, \"rx-threshold\",\n\t\t\t\t      &stm32port->rxftcfg);\n\t\tstm32_usart_get_ftcfg(pdev, \"tx-threshold\",\n\t\t\t\t      &stm32port->txftcfg);\n\t}\n\n\tport->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(port->membase))\n\t\treturn PTR_ERR(port->membase);\n\tport->mapbase = res->start;\n\n\tspin_lock_init(&port->lock);\n\n\tstm32port->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(stm32port->clk))\n\t\treturn PTR_ERR(stm32port->clk);\n\n\t \n\tret = clk_prepare_enable(stm32port->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tstm32port->port.uartclk = clk_get_rate(stm32port->clk);\n\tif (!stm32port->port.uartclk) {\n\t\tret = -EINVAL;\n\t\tgoto err_clk;\n\t}\n\n\tstm32port->gpios = mctrl_gpio_init(&stm32port->port, 0);\n\tif (IS_ERR(stm32port->gpios)) {\n\t\tret = PTR_ERR(stm32port->gpios);\n\t\tgoto err_clk;\n\t}\n\n\t \n\tif (stm32port->hw_flow_control) {\n\t\tif (mctrl_gpio_to_gpiod(stm32port->gpios, UART_GPIO_CTS) ||\n\t\t    mctrl_gpio_to_gpiod(stm32port->gpios, UART_GPIO_RTS)) {\n\t\t\tdev_err(&pdev->dev, \"Conflicting RTS/CTS config\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_clk;\n\t\t}\n\t}\n\n\treturn ret;\n\nerr_clk:\n\tclk_disable_unprepare(stm32port->clk);\n\n\treturn ret;\n}\n\nstatic struct stm32_port *stm32_usart_of_get_port(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint id;\n\n\tif (!np)\n\t\treturn NULL;\n\n\tid = of_alias_get_id(np, \"serial\");\n\tif (id < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias id, errno %d\\n\", id);\n\t\treturn NULL;\n\t}\n\n\tif (WARN_ON(id >= STM32_MAX_PORTS))\n\t\treturn NULL;\n\n\tstm32_ports[id].hw_flow_control =\n\t\tof_property_read_bool (np, \"st,hw-flow-ctrl\")   ||\n\t\tof_property_read_bool (np, \"uart-has-rtscts\");\n\tstm32_ports[id].port.line = id;\n\tstm32_ports[id].cr1_irq = USART_CR1_RXNEIE;\n\tstm32_ports[id].cr3_irq = 0;\n\tstm32_ports[id].last_res = RX_BUF_L;\n\treturn &stm32_ports[id];\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id stm32_match[] = {\n\t{ .compatible = \"st,stm32-uart\", .data = &stm32f4_info},\n\t{ .compatible = \"st,stm32f7-uart\", .data = &stm32f7_info},\n\t{ .compatible = \"st,stm32h7-uart\", .data = &stm32h7_info},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, stm32_match);\n#endif\n\nstatic void stm32_usart_of_dma_rx_remove(struct stm32_port *stm32port,\n\t\t\t\t\t struct platform_device *pdev)\n{\n\tif (stm32port->rx_buf)\n\t\tdma_free_coherent(&pdev->dev, RX_BUF_L, stm32port->rx_buf,\n\t\t\t\t  stm32port->rx_dma_buf);\n}\n\nstatic int stm32_usart_of_dma_rx_probe(struct stm32_port *stm32port,\n\t\t\t\t       struct platform_device *pdev)\n{\n\tconst struct stm32_usart_offsets *ofs = &stm32port->info->ofs;\n\tstruct uart_port *port = &stm32port->port;\n\tstruct device *dev = &pdev->dev;\n\tstruct dma_slave_config config;\n\tint ret;\n\n\tstm32port->rx_buf = dma_alloc_coherent(dev, RX_BUF_L,\n\t\t\t\t\t       &stm32port->rx_dma_buf,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!stm32port->rx_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tmemset(&config, 0, sizeof(config));\n\tconfig.src_addr = port->mapbase + ofs->rdr;\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\n\tret = dmaengine_slave_config(stm32port->rx_ch, &config);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"rx dma channel config failed\\n\");\n\t\tstm32_usart_of_dma_rx_remove(stm32port, pdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_usart_of_dma_tx_remove(struct stm32_port *stm32port,\n\t\t\t\t\t struct platform_device *pdev)\n{\n\tif (stm32port->tx_buf)\n\t\tdma_free_coherent(&pdev->dev, TX_BUF_L, stm32port->tx_buf,\n\t\t\t\t  stm32port->tx_dma_buf);\n}\n\nstatic int stm32_usart_of_dma_tx_probe(struct stm32_port *stm32port,\n\t\t\t\t       struct platform_device *pdev)\n{\n\tconst struct stm32_usart_offsets *ofs = &stm32port->info->ofs;\n\tstruct uart_port *port = &stm32port->port;\n\tstruct device *dev = &pdev->dev;\n\tstruct dma_slave_config config;\n\tint ret;\n\n\tstm32port->tx_buf = dma_alloc_coherent(dev, TX_BUF_L,\n\t\t\t\t\t       &stm32port->tx_dma_buf,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!stm32port->tx_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tmemset(&config, 0, sizeof(config));\n\tconfig.dst_addr = port->mapbase + ofs->tdr;\n\tconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\n\tret = dmaengine_slave_config(stm32port->tx_ch, &config);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"tx dma channel config failed\\n\");\n\t\tstm32_usart_of_dma_tx_remove(stm32port, pdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_usart_serial_probe(struct platform_device *pdev)\n{\n\tstruct stm32_port *stm32port;\n\tint ret;\n\n\tstm32port = stm32_usart_of_get_port(pdev);\n\tif (!stm32port)\n\t\treturn -ENODEV;\n\n\tstm32port->info = of_device_get_match_data(&pdev->dev);\n\tif (!stm32port->info)\n\t\treturn -EINVAL;\n\n\tstm32port->rx_ch = dma_request_chan(&pdev->dev, \"rx\");\n\tif (PTR_ERR(stm32port->rx_ch) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tif (IS_ERR(stm32port->rx_ch))\n\t\tstm32port->rx_ch = NULL;\n\n\tstm32port->tx_ch = dma_request_chan(&pdev->dev, \"tx\");\n\tif (PTR_ERR(stm32port->tx_ch) == -EPROBE_DEFER) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_dma_rx;\n\t}\n\t \n\tif (IS_ERR(stm32port->tx_ch))\n\t\tstm32port->tx_ch = NULL;\n\n\tret = stm32_usart_init_port(stm32port, pdev);\n\tif (ret)\n\t\tgoto err_dma_tx;\n\n\tif (stm32port->wakeup_src) {\n\t\tdevice_set_wakeup_capable(&pdev->dev, true);\n\t\tret = dev_pm_set_wake_irq(&pdev->dev, stm32port->port.irq);\n\t\tif (ret)\n\t\t\tgoto err_deinit_port;\n\t}\n\n\tif (stm32port->rx_ch && stm32_usart_of_dma_rx_probe(stm32port, pdev)) {\n\t\t \n\t\tdma_release_channel(stm32port->rx_ch);\n\t\tstm32port->rx_ch = NULL;\n\t}\n\n\tif (stm32port->tx_ch && stm32_usart_of_dma_tx_probe(stm32port, pdev)) {\n\t\t \n\t\tdma_release_channel(stm32port->tx_ch);\n\t\tstm32port->tx_ch = NULL;\n\t}\n\n\tif (!stm32port->rx_ch)\n\t\tdev_info(&pdev->dev, \"interrupt mode for rx (no dma)\\n\");\n\tif (!stm32port->tx_ch)\n\t\tdev_info(&pdev->dev, \"interrupt mode for tx (no dma)\\n\");\n\n\tplatform_set_drvdata(pdev, &stm32port->port);\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = uart_add_one_port(&stm32_usart_driver, &stm32port->port);\n\tif (ret)\n\t\tgoto err_port;\n\n\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn 0;\n\nerr_port:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\tif (stm32port->tx_ch)\n\t\tstm32_usart_of_dma_tx_remove(stm32port, pdev);\n\tif (stm32port->rx_ch)\n\t\tstm32_usart_of_dma_rx_remove(stm32port, pdev);\n\n\tif (stm32port->wakeup_src)\n\t\tdev_pm_clear_wake_irq(&pdev->dev);\n\nerr_deinit_port:\n\tif (stm32port->wakeup_src)\n\t\tdevice_set_wakeup_capable(&pdev->dev, false);\n\n\tstm32_usart_deinit_port(stm32port);\n\nerr_dma_tx:\n\tif (stm32port->tx_ch)\n\t\tdma_release_channel(stm32port->tx_ch);\n\nerr_dma_rx:\n\tif (stm32port->rx_ch)\n\t\tdma_release_channel(stm32port->rx_ch);\n\n\treturn ret;\n}\n\nstatic int stm32_usart_serial_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = platform_get_drvdata(pdev);\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tu32 cr3;\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tuart_remove_one_port(&stm32_usart_driver, port);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\tstm32_usart_clr_bits(port, ofs->cr1, USART_CR1_PEIE);\n\n\tif (stm32_port->tx_ch) {\n\t\tstm32_usart_of_dma_tx_remove(stm32_port, pdev);\n\t\tdma_release_channel(stm32_port->tx_ch);\n\t}\n\n\tif (stm32_port->rx_ch) {\n\t\tstm32_usart_of_dma_rx_remove(stm32_port, pdev);\n\t\tdma_release_channel(stm32_port->rx_ch);\n\t}\n\n\tcr3 = readl_relaxed(port->membase + ofs->cr3);\n\tcr3 &= ~USART_CR3_EIE;\n\tcr3 &= ~USART_CR3_DMAR;\n\tcr3 &= ~USART_CR3_DMAT;\n\tcr3 &= ~USART_CR3_DDRE;\n\twritel_relaxed(cr3, port->membase + ofs->cr3);\n\n\tif (stm32_port->wakeup_src) {\n\t\tdev_pm_clear_wake_irq(&pdev->dev);\n\t\tdevice_init_wakeup(&pdev->dev, false);\n\t}\n\n\tstm32_usart_deinit_port(stm32_port);\n\n\treturn 0;\n}\n\nstatic void __maybe_unused stm32_usart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tu32 isr;\n\tint ret;\n\n\tret = readl_relaxed_poll_timeout_atomic(port->membase + ofs->isr, isr,\n\t\t\t\t\t\t(isr & USART_SR_TXE), 100,\n\t\t\t\t\t\tSTM32_USART_TIMEOUT_USEC);\n\tif (ret != 0) {\n\t\tdev_err(port->dev, \"Error while sending data in UART TX : %d\\n\", ret);\n\t\treturn;\n\t}\n\twritel_relaxed(ch, port->membase + ofs->tdr);\n}\n\n#ifdef CONFIG_SERIAL_STM32_CONSOLE\nstatic void stm32_usart_console_write(struct console *co, const char *s,\n\t\t\t\t      unsigned int cnt)\n{\n\tstruct uart_port *port = &stm32_ports[co->index].port;\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tconst struct stm32_usart_config *cfg = &stm32_port->info->cfg;\n\tunsigned long flags;\n\tu32 old_cr1, new_cr1;\n\tint locked = 1;\n\n\tif (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&port->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\told_cr1 = readl_relaxed(port->membase + ofs->cr1);\n\tnew_cr1 = old_cr1 & ~USART_CR1_IE_MASK;\n\tnew_cr1 |=  USART_CR1_TE | BIT(cfg->uart_enable_bit);\n\twritel_relaxed(new_cr1, port->membase + ofs->cr1);\n\n\tuart_console_write(port, s, cnt, stm32_usart_console_putchar);\n\n\t \n\twritel_relaxed(old_cr1, port->membase + ofs->cr1);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int stm32_usart_console_setup(struct console *co, char *options)\n{\n\tstruct stm32_port *stm32port;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index >= STM32_MAX_PORTS)\n\t\treturn -ENODEV;\n\n\tstm32port = &stm32_ports[co->index];\n\n\t \n\tif (stm32port->port.mapbase == 0 || !stm32port->port.membase)\n\t\treturn -ENXIO;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&stm32port->port, co, baud, parity, bits, flow);\n}\n\nstatic struct console stm32_console = {\n\t.name\t\t= STM32_SERIAL_NAME,\n\t.device\t\t= uart_console_device,\n\t.write\t\t= stm32_usart_console_write,\n\t.setup\t\t= stm32_usart_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &stm32_usart_driver,\n};\n\n#define STM32_SERIAL_CONSOLE (&stm32_console)\n\n#else\n#define STM32_SERIAL_CONSOLE NULL\n#endif  \n\n#ifdef CONFIG_SERIAL_EARLYCON\nstatic void early_stm32_usart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct stm32_usart_info *info = port->private_data;\n\n\twhile (!(readl_relaxed(port->membase + info->ofs.isr) & USART_SR_TXE))\n\t\tcpu_relax();\n\n\twritel_relaxed(ch, port->membase + info->ofs.tdr);\n}\n\nstatic void early_stm32_serial_write(struct console *console, const char *s, unsigned int count)\n{\n\tstruct earlycon_device *device = console->data;\n\tstruct uart_port *port = &device->port;\n\n\tuart_console_write(port, s, count, early_stm32_usart_console_putchar);\n}\n\nstatic int __init early_stm32_h7_serial_setup(struct earlycon_device *device, const char *options)\n{\n\tif (!(device->port.membase || device->port.iobase))\n\t\treturn -ENODEV;\n\tdevice->port.private_data = &stm32h7_info;\n\tdevice->con->write = early_stm32_serial_write;\n\treturn 0;\n}\n\nstatic int __init early_stm32_f7_serial_setup(struct earlycon_device *device, const char *options)\n{\n\tif (!(device->port.membase || device->port.iobase))\n\t\treturn -ENODEV;\n\tdevice->port.private_data = &stm32f7_info;\n\tdevice->con->write = early_stm32_serial_write;\n\treturn 0;\n}\n\nstatic int __init early_stm32_f4_serial_setup(struct earlycon_device *device, const char *options)\n{\n\tif (!(device->port.membase || device->port.iobase))\n\t\treturn -ENODEV;\n\tdevice->port.private_data = &stm32f4_info;\n\tdevice->con->write = early_stm32_serial_write;\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(stm32, \"st,stm32h7-uart\", early_stm32_h7_serial_setup);\nOF_EARLYCON_DECLARE(stm32, \"st,stm32f7-uart\", early_stm32_f7_serial_setup);\nOF_EARLYCON_DECLARE(stm32, \"st,stm32-uart\", early_stm32_f4_serial_setup);\n#endif  \n\nstatic struct uart_driver stm32_usart_driver = {\n\t.driver_name\t= DRIVER_NAME,\n\t.dev_name\t= STM32_SERIAL_NAME,\n\t.major\t\t= 0,\n\t.minor\t\t= 0,\n\t.nr\t\t= STM32_MAX_PORTS,\n\t.cons\t\t= STM32_SERIAL_CONSOLE,\n};\n\nstatic int __maybe_unused stm32_usart_serial_en_wakeup(struct uart_port *port,\n\t\t\t\t\t\t       bool enable)\n{\n\tstruct stm32_port *stm32_port = to_stm32_port(port);\n\tconst struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;\n\tstruct tty_port *tport = &port->state->port;\n\tint ret;\n\tunsigned int size = 0;\n\tunsigned long flags;\n\n\tif (!stm32_port->wakeup_src || !tty_port_initialized(tport))\n\t\treturn 0;\n\n\t \n\tif (enable) {\n\t\tstm32_usart_set_bits(port, ofs->cr1, USART_CR1_UESM);\n\t\tstm32_usart_set_bits(port, ofs->cr3, USART_CR3_WUFIE);\n\t\tmctrl_gpio_enable_irq_wake(stm32_port->gpios);\n\n\t\t \n\t\tif (stm32_port->rx_ch) {\n\t\t\tspin_lock_irqsave(&port->lock, flags);\n\t\t\t \n\t\t\tif (!stm32_usart_rx_dma_pause(stm32_port))\n\t\t\t\tsize += stm32_usart_receive_chars(port, true);\n\t\t\tstm32_usart_rx_dma_terminate(stm32_port);\n\t\t\tuart_unlock_and_check_sysrq_irqrestore(port, flags);\n\t\t\tif (size)\n\t\t\t\ttty_flip_buffer_push(tport);\n\t\t}\n\n\t\t \n\t\tstm32_usart_receive_chars(port, false);\n\t} else {\n\t\tif (stm32_port->rx_ch) {\n\t\t\tret = stm32_usart_rx_dma_start_or_resume(port);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tmctrl_gpio_disable_irq_wake(stm32_port->gpios);\n\t\tstm32_usart_clr_bits(port, ofs->cr1, USART_CR1_UESM);\n\t\tstm32_usart_clr_bits(port, ofs->cr3, USART_CR3_WUFIE);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_usart_serial_suspend(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tint ret;\n\n\tuart_suspend_port(&stm32_usart_driver, port);\n\n\tif (device_may_wakeup(dev) || device_wakeup_path(dev)) {\n\t\tret = stm32_usart_serial_en_wakeup(port, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (console_suspend_enabled || !uart_console(port)) {\n\t\tif (device_may_wakeup(dev) || device_wakeup_path(dev))\n\t\t\tpinctrl_pm_select_idle_state(dev);\n\t\telse\n\t\t\tpinctrl_pm_select_sleep_state(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_usart_serial_resume(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tint ret;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tif (device_may_wakeup(dev) || device_wakeup_path(dev)) {\n\t\tret = stm32_usart_serial_en_wakeup(port, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn uart_resume_port(&stm32_usart_driver, port);\n}\n\nstatic int __maybe_unused stm32_usart_runtime_suspend(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct stm32_port *stm32port = container_of(port,\n\t\t\tstruct stm32_port, port);\n\n\tclk_disable_unprepare(stm32port->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_usart_runtime_resume(struct device *dev)\n{\n\tstruct uart_port *port = dev_get_drvdata(dev);\n\tstruct stm32_port *stm32port = container_of(port,\n\t\t\tstruct stm32_port, port);\n\n\treturn clk_prepare_enable(stm32port->clk);\n}\n\nstatic const struct dev_pm_ops stm32_serial_pm_ops = {\n\tSET_RUNTIME_PM_OPS(stm32_usart_runtime_suspend,\n\t\t\t   stm32_usart_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(stm32_usart_serial_suspend,\n\t\t\t\tstm32_usart_serial_resume)\n};\n\nstatic struct platform_driver stm32_serial_driver = {\n\t.probe\t\t= stm32_usart_serial_probe,\n\t.remove\t\t= stm32_usart_serial_remove,\n\t.driver\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= &stm32_serial_pm_ops,\n\t\t.of_match_table = of_match_ptr(stm32_match),\n\t},\n};\n\nstatic int __init stm32_usart_init(void)\n{\n\tstatic char banner[] __initdata = \"STM32 USART driver initialized\";\n\tint ret;\n\n\tpr_info(\"%s\\n\", banner);\n\n\tret = uart_register_driver(&stm32_usart_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&stm32_serial_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&stm32_usart_driver);\n\n\treturn ret;\n}\n\nstatic void __exit stm32_usart_exit(void)\n{\n\tplatform_driver_unregister(&stm32_serial_driver);\n\tuart_unregister_driver(&stm32_usart_driver);\n}\n\nmodule_init(stm32_usart_init);\nmodule_exit(stm32_usart_exit);\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}