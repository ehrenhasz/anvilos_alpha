{
  "module_name": "sprd_serial.c",
  "hash_id": "fe837850216c002539aaa3ccd03b8bb25f73bec12d677976c3ed9432761af584",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/sprd_serial.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/dma/sprd-dma.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n \n#define UART_NR_MAX\t\t8\n#define SPRD_TTY_NAME\t\t\"ttyS\"\n#define SPRD_FIFO_SIZE\t\t128\n#define SPRD_DEF_RATE\t\t26000000\n#define SPRD_BAUD_IO_LIMIT\t3000000\n#define SPRD_TIMEOUT\t\t256000\n\n \n \n#define SPRD_TXD\t\t0x0000\n#define SPRD_RXD\t\t0x0004\n\n \n#define SPRD_LSR\t\t0x0008\n#define SPRD_LSR_OE\t\tBIT(4)\n#define SPRD_LSR_FE\t\tBIT(3)\n#define SPRD_LSR_PE\t\tBIT(2)\n#define SPRD_LSR_BI\t\tBIT(7)\n#define SPRD_LSR_TX_OVER\tBIT(15)\n\n \n#define SPRD_STS1\t\t0x000C\n#define SPRD_RX_FIFO_CNT_MASK\tGENMASK(7, 0)\n#define SPRD_TX_FIFO_CNT_MASK\tGENMASK(15, 8)\n\n \n#define SPRD_IEN\t\t0x0010\n#define SPRD_IEN_RX_FULL\tBIT(0)\n#define SPRD_IEN_TX_EMPTY\tBIT(1)\n#define SPRD_IEN_BREAK_DETECT\tBIT(7)\n#define SPRD_IEN_TIMEOUT\tBIT(13)\n\n \n#define SPRD_ICLR\t\t0x0014\n#define SPRD_ICLR_TIMEOUT\tBIT(13)\n\n \n#define SPRD_LCR\t\t0x0018\n#define SPRD_LCR_STOP_1BIT\t0x10\n#define SPRD_LCR_STOP_2BIT\t0x30\n#define SPRD_LCR_DATA_LEN\t(BIT(2) | BIT(3))\n#define SPRD_LCR_DATA_LEN5\t0x0\n#define SPRD_LCR_DATA_LEN6\t0x4\n#define SPRD_LCR_DATA_LEN7\t0x8\n#define SPRD_LCR_DATA_LEN8\t0xc\n#define SPRD_LCR_PARITY\t\t(BIT(0) | BIT(1))\n#define SPRD_LCR_PARITY_EN\t0x2\n#define SPRD_LCR_EVEN_PAR\t0x0\n#define SPRD_LCR_ODD_PAR\t0x1\n\n \n#define SPRD_CTL1\t\t0x001C\n#define SPRD_DMA_EN\t\tBIT(15)\n#define SPRD_LOOPBACK_EN\tBIT(14)\n#define RX_HW_FLOW_CTL_THLD\tBIT(6)\n#define RX_HW_FLOW_CTL_EN\tBIT(7)\n#define TX_HW_FLOW_CTL_EN\tBIT(8)\n#define RX_TOUT_THLD_DEF\t0x3E00\n#define RX_HFC_THLD_DEF\t\t0x40\n\n \n#define SPRD_CTL2\t\t0x0020\n#define THLD_TX_EMPTY\t\t0x40\n#define THLD_TX_EMPTY_SHIFT\t8\n#define THLD_RX_FULL\t\t0x40\n#define THLD_RX_FULL_MASK\tGENMASK(6, 0)\n\n \n#define SPRD_CLKD0\t\t0x0024\n#define SPRD_CLKD0_MASK\t\tGENMASK(15, 0)\n#define SPRD_CLKD1\t\t0x0028\n#define SPRD_CLKD1_MASK\t\tGENMASK(20, 16)\n#define SPRD_CLKD1_SHIFT\t16\n\n \n#define SPRD_IMSR\t\t0x002C\n#define SPRD_IMSR_RX_FIFO_FULL\tBIT(0)\n#define SPRD_IMSR_TX_FIFO_EMPTY\tBIT(1)\n#define SPRD_IMSR_BREAK_DETECT\tBIT(7)\n#define SPRD_IMSR_TIMEOUT\tBIT(13)\n#define SPRD_DEFAULT_SOURCE_CLK\t26000000\n\n#define SPRD_RX_DMA_STEP\t1\n#define SPRD_RX_FIFO_FULL\t1\n#define SPRD_TX_FIFO_FULL\t0x20\n#define SPRD_UART_RX_SIZE\t(UART_XMIT_SIZE / 4)\n\nstruct sprd_uart_dma {\n\tstruct dma_chan *chn;\n\tunsigned char *virt;\n\tdma_addr_t phys_addr;\n\tdma_cookie_t cookie;\n\tu32 trans_len;\n\tbool enable;\n};\n\nstruct sprd_uart_port {\n\tstruct uart_port port;\n\tchar name[16];\n\tstruct clk *clk;\n\tstruct sprd_uart_dma tx_dma;\n\tstruct sprd_uart_dma rx_dma;\n\tdma_addr_t pos;\n\tunsigned char *rx_buf_tail;\n};\n\nstatic struct sprd_uart_port *sprd_port[UART_NR_MAX];\nstatic int sprd_ports_num;\n\nstatic int sprd_start_dma_rx(struct uart_port *port);\nstatic int sprd_tx_dma_config(struct uart_port *port);\n\nstatic inline unsigned int serial_in(struct uart_port *port,\n\t\t\t\t     unsigned int offset)\n{\n\treturn readl_relaxed(port->membase + offset);\n}\n\nstatic inline void serial_out(struct uart_port *port, unsigned int offset,\n\t\t\t      int value)\n{\n\twritel_relaxed(value, port->membase + offset);\n}\n\nstatic unsigned int sprd_tx_empty(struct uart_port *port)\n{\n\tif (serial_in(port, SPRD_STS1) & SPRD_TX_FIFO_CNT_MASK)\n\t\treturn 0;\n\telse\n\t\treturn TIOCSER_TEMT;\n}\n\nstatic unsigned int sprd_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_DSR | TIOCM_CTS;\n}\n\nstatic void sprd_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tu32 val = serial_in(port, SPRD_CTL1);\n\n\tif (mctrl & TIOCM_LOOP)\n\t\tval |= SPRD_LOOPBACK_EN;\n\telse\n\t\tval &= ~SPRD_LOOPBACK_EN;\n\n\tserial_out(port, SPRD_CTL1, val);\n}\n\nstatic void sprd_stop_rx(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\tunsigned int ien, iclr;\n\n\tif (sp->rx_dma.enable)\n\t\tdmaengine_terminate_all(sp->rx_dma.chn);\n\n\ticlr = serial_in(port, SPRD_ICLR);\n\tien = serial_in(port, SPRD_IEN);\n\n\tien &= ~(SPRD_IEN_RX_FULL | SPRD_IEN_BREAK_DETECT);\n\ticlr |= SPRD_IEN_RX_FULL | SPRD_IEN_BREAK_DETECT;\n\n\tserial_out(port, SPRD_IEN, ien);\n\tserial_out(port, SPRD_ICLR, iclr);\n}\n\nstatic void sprd_uart_dma_enable(struct uart_port *port, bool enable)\n{\n\tu32 val = serial_in(port, SPRD_CTL1);\n\n\tif (enable)\n\t\tval |= SPRD_DMA_EN;\n\telse\n\t\tval &= ~SPRD_DMA_EN;\n\n\tserial_out(port, SPRD_CTL1, val);\n}\n\nstatic void sprd_stop_tx_dma(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\tstruct dma_tx_state state;\n\tu32 trans_len;\n\n\tdmaengine_pause(sp->tx_dma.chn);\n\n\tdmaengine_tx_status(sp->tx_dma.chn, sp->tx_dma.cookie, &state);\n\tif (state.residue) {\n\t\ttrans_len = state.residue - sp->tx_dma.phys_addr;\n\t\tuart_xmit_advance(port, trans_len);\n\t\tdma_unmap_single(port->dev, sp->tx_dma.phys_addr,\n\t\t\t\t sp->tx_dma.trans_len, DMA_TO_DEVICE);\n\t}\n\n\tdmaengine_terminate_all(sp->tx_dma.chn);\n\tsp->tx_dma.trans_len = 0;\n}\n\nstatic int sprd_tx_buf_remap(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\tsp->tx_dma.trans_len =\n\t\tCIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\n\tsp->tx_dma.phys_addr = dma_map_single(port->dev,\n\t\t\t\t\t      (void *)&(xmit->buf[xmit->tail]),\n\t\t\t\t\t      sp->tx_dma.trans_len,\n\t\t\t\t\t      DMA_TO_DEVICE);\n\treturn dma_mapping_error(port->dev, sp->tx_dma.phys_addr);\n}\n\nstatic void sprd_complete_tx_dma(void *data)\n{\n\tstruct uart_port *port = (struct uart_port *)data;\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tdma_unmap_single(port->dev, sp->tx_dma.phys_addr,\n\t\t\t sp->tx_dma.trans_len, DMA_TO_DEVICE);\n\n\tuart_xmit_advance(port, sp->tx_dma.trans_len);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (uart_circ_empty(xmit) || sprd_tx_buf_remap(port) ||\n\t    sprd_tx_dma_config(port))\n\t\tsp->tx_dma.trans_len = 0;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int sprd_uart_dma_submit(struct uart_port *port,\n\t\t\t\tstruct sprd_uart_dma *ud, u32 trans_len,\n\t\t\t\tenum dma_transfer_direction direction,\n\t\t\t\tdma_async_tx_callback callback)\n{\n\tstruct dma_async_tx_descriptor *dma_des;\n\tunsigned long flags;\n\n\tflags = SPRD_DMA_FLAGS(SPRD_DMA_CHN_MODE_NONE,\n\t\t\t       SPRD_DMA_NO_TRG,\n\t\t\t       SPRD_DMA_FRAG_REQ,\n\t\t\t       SPRD_DMA_TRANS_INT);\n\n\tdma_des = dmaengine_prep_slave_single(ud->chn, ud->phys_addr, trans_len,\n\t\t\t\t\t      direction, flags);\n\tif (!dma_des)\n\t\treturn -ENODEV;\n\n\tdma_des->callback = callback;\n\tdma_des->callback_param = port;\n\n\tud->cookie = dmaengine_submit(dma_des);\n\tif (dma_submit_error(ud->cookie))\n\t\treturn dma_submit_error(ud->cookie);\n\n\tdma_async_issue_pending(ud->chn);\n\n\treturn 0;\n}\n\nstatic int sprd_tx_dma_config(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\tu32 burst = sp->tx_dma.trans_len > SPRD_TX_FIFO_FULL ?\n\t\tSPRD_TX_FIFO_FULL : sp->tx_dma.trans_len;\n\tint ret;\n\tstruct dma_slave_config cfg = {\n\t\t.dst_addr = port->mapbase + SPRD_TXD,\n\t\t.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,\n\t\t.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,\n\t\t.src_maxburst = burst,\n\t};\n\n\tret = dmaengine_slave_config(sp->tx_dma.chn, &cfg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprd_uart_dma_submit(port, &sp->tx_dma, sp->tx_dma.trans_len,\n\t\t\t\t    DMA_MEM_TO_DEV, sprd_complete_tx_dma);\n}\n\nstatic void sprd_start_tx_dma(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\tif (port->x_char) {\n\t\tserial_out(port, SPRD_TXD, port->x_char);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\tsprd_stop_tx_dma(port);\n\t\treturn;\n\t}\n\n\tif (sp->tx_dma.trans_len)\n\t\treturn;\n\n\tif (sprd_tx_buf_remap(port) || sprd_tx_dma_config(port))\n\t\tsp->tx_dma.trans_len = 0;\n}\n\nstatic void sprd_rx_full_thld(struct uart_port *port, u32 thld)\n{\n\tu32 val = serial_in(port, SPRD_CTL2);\n\n\tval &= ~THLD_RX_FULL_MASK;\n\tval |= thld & THLD_RX_FULL_MASK;\n\tserial_out(port, SPRD_CTL2, val);\n}\n\nstatic int sprd_rx_alloc_buf(struct sprd_uart_port *sp)\n{\n\tsp->rx_dma.virt = dma_alloc_coherent(sp->port.dev, SPRD_UART_RX_SIZE,\n\t\t\t\t\t     &sp->rx_dma.phys_addr, GFP_KERNEL);\n\tif (!sp->rx_dma.virt)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void sprd_rx_free_buf(struct sprd_uart_port *sp)\n{\n\tif (sp->rx_dma.virt)\n\t\tdma_free_coherent(sp->port.dev, SPRD_UART_RX_SIZE,\n\t\t\t\t  sp->rx_dma.virt, sp->rx_dma.phys_addr);\n\tsp->rx_dma.virt = NULL;\n}\n\nstatic int sprd_rx_dma_config(struct uart_port *port, u32 burst)\n{\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\tstruct dma_slave_config cfg = {\n\t\t.src_addr = port->mapbase + SPRD_RXD,\n\t\t.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,\n\t\t.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,\n\t\t.src_maxburst = burst,\n\t};\n\n\treturn dmaengine_slave_config(sp->rx_dma.chn, &cfg);\n}\n\nstatic void sprd_uart_dma_rx(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\tstruct tty_port *tty = &port->state->port;\n\n\tport->icount.rx += sp->rx_dma.trans_len;\n\ttty_insert_flip_string(tty, sp->rx_buf_tail, sp->rx_dma.trans_len);\n\ttty_flip_buffer_push(tty);\n}\n\nstatic void sprd_uart_dma_irq(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\n\tstatus = dmaengine_tx_status(sp->rx_dma.chn,\n\t\t\t\t     sp->rx_dma.cookie, &state);\n\tif (status == DMA_ERROR)\n\t\tsprd_stop_rx(port);\n\n\tif (!state.residue && sp->pos == sp->rx_dma.phys_addr)\n\t\treturn;\n\n\tif (!state.residue) {\n\t\tsp->rx_dma.trans_len = SPRD_UART_RX_SIZE +\n\t\t\tsp->rx_dma.phys_addr - sp->pos;\n\t\tsp->pos = sp->rx_dma.phys_addr;\n\t} else {\n\t\tsp->rx_dma.trans_len = state.residue - sp->pos;\n\t\tsp->pos = state.residue;\n\t}\n\n\tsprd_uart_dma_rx(port);\n\tsp->rx_buf_tail += sp->rx_dma.trans_len;\n}\n\nstatic void sprd_complete_rx_dma(void *data)\n{\n\tstruct uart_port *port = (struct uart_port *)data;\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tstatus = dmaengine_tx_status(sp->rx_dma.chn,\n\t\t\t\t     sp->rx_dma.cookie, &state);\n\tif (status != DMA_COMPLETE) {\n\t\tsprd_stop_rx(port);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\treturn;\n\t}\n\n\tif (sp->pos != sp->rx_dma.phys_addr) {\n\t\tsp->rx_dma.trans_len =  SPRD_UART_RX_SIZE +\n\t\t\tsp->rx_dma.phys_addr - sp->pos;\n\t\tsprd_uart_dma_rx(port);\n\t\tsp->rx_buf_tail += sp->rx_dma.trans_len;\n\t}\n\n\tif (sprd_start_dma_rx(port))\n\t\tsprd_stop_rx(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int sprd_start_dma_rx(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\tint ret;\n\n\tif (!sp->rx_dma.enable)\n\t\treturn 0;\n\n\tsp->pos = sp->rx_dma.phys_addr;\n\tsp->rx_buf_tail = sp->rx_dma.virt;\n\tsprd_rx_full_thld(port, SPRD_RX_FIFO_FULL);\n\tret = sprd_rx_dma_config(port, SPRD_RX_DMA_STEP);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprd_uart_dma_submit(port, &sp->rx_dma, SPRD_UART_RX_SIZE,\n\t\t\t\t    DMA_DEV_TO_MEM, sprd_complete_rx_dma);\n}\n\nstatic void sprd_release_dma(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\n\tsprd_uart_dma_enable(port, false);\n\n\tif (sp->rx_dma.enable)\n\t\tdma_release_channel(sp->rx_dma.chn);\n\n\tif (sp->tx_dma.enable)\n\t\tdma_release_channel(sp->tx_dma.chn);\n\n\tsp->tx_dma.enable = false;\n\tsp->rx_dma.enable = false;\n}\n\nstatic void sprd_request_dma(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\n\tsp->tx_dma.enable = true;\n\tsp->rx_dma.enable = true;\n\n\tsp->tx_dma.chn = dma_request_chan(port->dev, \"tx\");\n\tif (IS_ERR(sp->tx_dma.chn)) {\n\t\tdev_err(port->dev, \"request TX DMA channel failed, ret = %ld\\n\",\n\t\t\tPTR_ERR(sp->tx_dma.chn));\n\t\tsp->tx_dma.enable = false;\n\t}\n\n\tsp->rx_dma.chn = dma_request_chan(port->dev, \"rx\");\n\tif (IS_ERR(sp->rx_dma.chn)) {\n\t\tdev_err(port->dev, \"request RX DMA channel failed, ret = %ld\\n\",\n\t\t\tPTR_ERR(sp->rx_dma.chn));\n\t\tsp->rx_dma.enable = false;\n\t}\n}\n\nstatic void sprd_stop_tx(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp = container_of(port, struct sprd_uart_port,\n\t\t\t\t\t\t port);\n\tunsigned int ien, iclr;\n\n\tif (sp->tx_dma.enable) {\n\t\tsprd_stop_tx_dma(port);\n\t\treturn;\n\t}\n\n\ticlr = serial_in(port, SPRD_ICLR);\n\tien = serial_in(port, SPRD_IEN);\n\n\ticlr |= SPRD_IEN_TX_EMPTY;\n\tien &= ~SPRD_IEN_TX_EMPTY;\n\n\tserial_out(port, SPRD_IEN, ien);\n\tserial_out(port, SPRD_ICLR, iclr);\n}\n\nstatic void sprd_start_tx(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp = container_of(port, struct sprd_uart_port,\n\t\t\t\t\t\t port);\n\tunsigned int ien;\n\n\tif (sp->tx_dma.enable) {\n\t\tsprd_start_tx_dma(port);\n\t\treturn;\n\t}\n\n\tien = serial_in(port, SPRD_IEN);\n\tif (!(ien & SPRD_IEN_TX_EMPTY)) {\n\t\tien |= SPRD_IEN_TX_EMPTY;\n\t\tserial_out(port, SPRD_IEN, ien);\n\t}\n}\n\n \nstatic void sprd_break_ctl(struct uart_port *port, int break_state)\n{\n\t \n}\n\nstatic int handle_lsr_errors(struct uart_port *port,\n\t\t\t     u8 *flag,\n\t\t\t     unsigned int *lsr)\n{\n\tint ret = 0;\n\n\t \n\tif (*lsr & SPRD_LSR_BI) {\n\t\t*lsr &= ~(SPRD_LSR_FE | SPRD_LSR_PE);\n\t\tport->icount.brk++;\n\t\tret = uart_handle_break(port);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (*lsr & SPRD_LSR_PE)\n\t\tport->icount.parity++;\n\telse if (*lsr & SPRD_LSR_FE)\n\t\tport->icount.frame++;\n\tif (*lsr & SPRD_LSR_OE)\n\t\tport->icount.overrun++;\n\n\t \n\t*lsr &= port->read_status_mask;\n\tif (*lsr & SPRD_LSR_BI)\n\t\t*flag = TTY_BREAK;\n\telse if (*lsr & SPRD_LSR_PE)\n\t\t*flag = TTY_PARITY;\n\telse if (*lsr & SPRD_LSR_FE)\n\t\t*flag = TTY_FRAME;\n\n\treturn ret;\n}\n\nstatic inline void sprd_rx(struct uart_port *port)\n{\n\tstruct sprd_uart_port *sp = container_of(port, struct sprd_uart_port,\n\t\t\t\t\t\t port);\n\tstruct tty_port *tty = &port->state->port;\n\tunsigned int lsr, max_count = SPRD_TIMEOUT;\n\tu8 ch, flag;\n\n\tif (sp->rx_dma.enable) {\n\t\tsprd_uart_dma_irq(port);\n\t\treturn;\n\t}\n\n\twhile ((serial_in(port, SPRD_STS1) & SPRD_RX_FIFO_CNT_MASK) &&\n\t       max_count--) {\n\t\tlsr = serial_in(port, SPRD_LSR);\n\t\tch = serial_in(port, SPRD_RXD);\n\t\tflag = TTY_NORMAL;\n\t\tport->icount.rx++;\n\n\t\tif (lsr & (SPRD_LSR_BI | SPRD_LSR_PE |\n\t\t\t   SPRD_LSR_FE | SPRD_LSR_OE))\n\t\t\tif (handle_lsr_errors(port, &flag, &lsr))\n\t\t\t\tcontinue;\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tcontinue;\n\n\t\tuart_insert_char(port, lsr, SPRD_LSR_OE, ch, flag);\n\t}\n\n\ttty_flip_buffer_push(tty);\n}\n\nstatic inline void sprd_tx(struct uart_port *port)\n{\n\tu8 ch;\n\n\tuart_port_tx_limited(port, ch, THLD_TX_EMPTY,\n\t\ttrue,\n\t\tserial_out(port, SPRD_TXD, ch),\n\t\t({}));\n}\n\n \nstatic irqreturn_t sprd_handle_irq(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tunsigned int ims;\n\n\tspin_lock(&port->lock);\n\n\tims = serial_in(port, SPRD_IMSR);\n\n\tif (!ims) {\n\t\tspin_unlock(&port->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (ims & SPRD_IMSR_TIMEOUT)\n\t\tserial_out(port, SPRD_ICLR, SPRD_ICLR_TIMEOUT);\n\n\tif (ims & SPRD_IMSR_BREAK_DETECT)\n\t\tserial_out(port, SPRD_ICLR, SPRD_IMSR_BREAK_DETECT);\n\n\tif (ims & (SPRD_IMSR_RX_FIFO_FULL | SPRD_IMSR_BREAK_DETECT |\n\t\t   SPRD_IMSR_TIMEOUT))\n\t\tsprd_rx(port);\n\n\tif (ims & SPRD_IMSR_TX_FIFO_EMPTY)\n\t\tsprd_tx(port);\n\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sprd_uart_dma_startup(struct uart_port *port,\n\t\t\t\t  struct sprd_uart_port *sp)\n{\n\tint ret;\n\n\tsprd_request_dma(port);\n\tif (!(sp->rx_dma.enable || sp->tx_dma.enable))\n\t\treturn;\n\n\tret = sprd_start_dma_rx(port);\n\tif (ret) {\n\t\tsp->rx_dma.enable = false;\n\t\tdma_release_channel(sp->rx_dma.chn);\n\t\tdev_warn(port->dev, \"fail to start RX dma mode\\n\");\n\t}\n\n\tsprd_uart_dma_enable(port, true);\n}\n\nstatic int sprd_startup(struct uart_port *port)\n{\n\tint ret = 0;\n\tunsigned int ien, fc;\n\tunsigned int timeout;\n\tstruct sprd_uart_port *sp;\n\tunsigned long flags;\n\n\tserial_out(port, SPRD_CTL2,\n\t\t   THLD_TX_EMPTY << THLD_TX_EMPTY_SHIFT | THLD_RX_FULL);\n\n\t \n\ttimeout = SPRD_TIMEOUT;\n\twhile (timeout-- && serial_in(port, SPRD_STS1) & SPRD_RX_FIFO_CNT_MASK)\n\t\tserial_in(port, SPRD_RXD);\n\n\t \n\ttimeout = SPRD_TIMEOUT;\n\twhile (timeout-- && serial_in(port, SPRD_STS1) & SPRD_TX_FIFO_CNT_MASK)\n\t\tcpu_relax();\n\n\t \n\tserial_out(port, SPRD_IEN, 0);\n\tserial_out(port, SPRD_ICLR, ~0);\n\n\t \n\tsp = container_of(port, struct sprd_uart_port, port);\n\tsnprintf(sp->name, sizeof(sp->name), \"sprd_serial%d\", port->line);\n\n\tsprd_uart_dma_startup(port, sp);\n\n\tret = devm_request_irq(port->dev, port->irq, sprd_handle_irq,\n\t\t\t       IRQF_SHARED, sp->name, port);\n\tif (ret) {\n\t\tdev_err(port->dev, \"fail to request serial irq %d, ret=%d\\n\",\n\t\t\tport->irq, ret);\n\t\treturn ret;\n\t}\n\tfc = serial_in(port, SPRD_CTL1);\n\tfc |= RX_TOUT_THLD_DEF | RX_HFC_THLD_DEF;\n\tserial_out(port, SPRD_CTL1, fc);\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tien = serial_in(port, SPRD_IEN);\n\tien |= SPRD_IEN_BREAK_DETECT | SPRD_IEN_TIMEOUT;\n\tif (!sp->rx_dma.enable)\n\t\tien |= SPRD_IEN_RX_FULL;\n\tserial_out(port, SPRD_IEN, ien);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn 0;\n}\n\nstatic void sprd_shutdown(struct uart_port *port)\n{\n\tsprd_release_dma(port);\n\tserial_out(port, SPRD_IEN, 0);\n\tserial_out(port, SPRD_ICLR, ~0);\n\tdevm_free_irq(port->dev, port->irq, port);\n}\n\nstatic void sprd_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t             const struct ktermios *old)\n{\n\tunsigned int baud, quot;\n\tunsigned int lcr = 0, fc;\n\tunsigned long flags;\n\n\t \n\tbaud = uart_get_baud_rate(port, termios, old, 0, SPRD_BAUD_IO_LIMIT);\n\n\tquot = port->uartclk / baud;\n\n\t \n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tlcr |= SPRD_LCR_DATA_LEN5;\n\t\tbreak;\n\tcase CS6:\n\t\tlcr |= SPRD_LCR_DATA_LEN6;\n\t\tbreak;\n\tcase CS7:\n\t\tlcr |= SPRD_LCR_DATA_LEN7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tlcr |= SPRD_LCR_DATA_LEN8;\n\t\tbreak;\n\t}\n\n\t \n\tlcr &= ~(SPRD_LCR_STOP_1BIT | SPRD_LCR_STOP_2BIT);\n\tif (termios->c_cflag & CSTOPB)\n\t\tlcr |= SPRD_LCR_STOP_2BIT;\n\telse\n\t\tlcr |= SPRD_LCR_STOP_1BIT;\n\n\t \n\tlcr &= ~SPRD_LCR_PARITY;\n\ttermios->c_cflag &= ~CMSPAR;\t \n\tif (termios->c_cflag & PARENB) {\n\t\tlcr |= SPRD_LCR_PARITY_EN;\n\t\tif (termios->c_cflag & PARODD)\n\t\t\tlcr |= SPRD_LCR_ODD_PAR;\n\t\telse\n\t\t\tlcr |= SPRD_LCR_EVEN_PAR;\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tport->read_status_mask = SPRD_LSR_OE;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= SPRD_LSR_FE | SPRD_LSR_PE;\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tport->read_status_mask |= SPRD_LSR_BI;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= SPRD_LSR_PE | SPRD_LSR_FE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= SPRD_LSR_BI;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= SPRD_LSR_OE;\n\t}\n\n\t \n\tfc = serial_in(port, SPRD_CTL1);\n\tfc &= ~(RX_HW_FLOW_CTL_THLD | RX_HW_FLOW_CTL_EN | TX_HW_FLOW_CTL_EN);\n\tif (termios->c_cflag & CRTSCTS) {\n\t\tfc |= RX_HW_FLOW_CTL_THLD;\n\t\tfc |= RX_HW_FLOW_CTL_EN;\n\t\tfc |= TX_HW_FLOW_CTL_EN;\n\t}\n\n\t \n\tserial_out(port, SPRD_CLKD0, quot & SPRD_CLKD0_MASK);\n\n\t \n\tserial_out(port, SPRD_CLKD1,\n\t\t   (quot & SPRD_CLKD1_MASK) >> SPRD_CLKD1_SHIFT);\n\tserial_out(port, SPRD_LCR, lcr);\n\tfc |= RX_TOUT_THLD_DEF | RX_HFC_THLD_DEF;\n\tserial_out(port, SPRD_CTL1, fc);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n}\n\nstatic const char *sprd_type(struct uart_port *port)\n{\n\treturn \"SPX\";\n}\n\nstatic void sprd_release_port(struct uart_port *port)\n{\n\t \n}\n\nstatic int sprd_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void sprd_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_SPRD;\n}\n\nstatic int sprd_verify_port(struct uart_port *port, struct serial_struct *ser)\n{\n\tif (ser->type != PORT_SPRD)\n\t\treturn -EINVAL;\n\tif (port->irq != ser->irq)\n\t\treturn -EINVAL;\n\tif (port->iotype != ser->io_type)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void sprd_pm(struct uart_port *port, unsigned int state,\n\t\tunsigned int oldstate)\n{\n\tstruct sprd_uart_port *sup =\n\t\tcontainer_of(port, struct sprd_uart_port, port);\n\n\tswitch (state) {\n\tcase UART_PM_STATE_ON:\n\t\tclk_prepare_enable(sup->clk);\n\t\tbreak;\n\tcase UART_PM_STATE_OFF:\n\t\tclk_disable_unprepare(sup->clk);\n\t\tbreak;\n\t}\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int sprd_poll_init(struct uart_port *port)\n{\n\tif (port->state->pm_state != UART_PM_STATE_ON) {\n\t\tsprd_pm(port, UART_PM_STATE_ON, 0);\n\t\tport->state->pm_state = UART_PM_STATE_ON;\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_poll_get_char(struct uart_port *port)\n{\n\twhile (!(serial_in(port, SPRD_STS1) & SPRD_RX_FIFO_CNT_MASK))\n\t\tcpu_relax();\n\n\treturn serial_in(port, SPRD_RXD);\n}\n\nstatic void sprd_poll_put_char(struct uart_port *port, unsigned char ch)\n{\n\twhile (serial_in(port, SPRD_STS1) & SPRD_TX_FIFO_CNT_MASK)\n\t\tcpu_relax();\n\n\tserial_out(port, SPRD_TXD, ch);\n}\n#endif\n\nstatic const struct uart_ops serial_sprd_ops = {\n\t.tx_empty = sprd_tx_empty,\n\t.get_mctrl = sprd_get_mctrl,\n\t.set_mctrl = sprd_set_mctrl,\n\t.stop_tx = sprd_stop_tx,\n\t.start_tx = sprd_start_tx,\n\t.stop_rx = sprd_stop_rx,\n\t.break_ctl = sprd_break_ctl,\n\t.startup = sprd_startup,\n\t.shutdown = sprd_shutdown,\n\t.set_termios = sprd_set_termios,\n\t.type = sprd_type,\n\t.release_port = sprd_release_port,\n\t.request_port = sprd_request_port,\n\t.config_port = sprd_config_port,\n\t.verify_port = sprd_verify_port,\n\t.pm = sprd_pm,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_init\t= sprd_poll_init,\n\t.poll_get_char\t= sprd_poll_get_char,\n\t.poll_put_char\t= sprd_poll_put_char,\n#endif\n};\n\n#ifdef CONFIG_SERIAL_SPRD_CONSOLE\nstatic void wait_for_xmitr(struct uart_port *port)\n{\n\tunsigned int status, tmout = 10000;\n\n\t \n\tdo {\n\t\tstatus = serial_in(port, SPRD_STS1);\n\t\tif (--tmout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (status & SPRD_TX_FIFO_CNT_MASK);\n}\n\nstatic void sprd_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\twait_for_xmitr(port);\n\tserial_out(port, SPRD_TXD, ch);\n}\n\nstatic void sprd_console_write(struct console *co, const char *s,\n\t\t\t       unsigned int count)\n{\n\tstruct uart_port *port = &sprd_port[co->index]->port;\n\tint locked = 1;\n\tunsigned long flags;\n\n\tif (port->sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&port->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\tuart_console_write(port, s, count, sprd_console_putchar);\n\n\t \n\twait_for_xmitr(port);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int sprd_console_setup(struct console *co, char *options)\n{\n\tstruct sprd_uart_port *sprd_uart_port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index >= UART_NR_MAX || co->index < 0)\n\t\tco->index = 0;\n\n\tsprd_uart_port = sprd_port[co->index];\n\tif (!sprd_uart_port || !sprd_uart_port->port.membase) {\n\t\tpr_info(\"serial port %d not yet initialized\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&sprd_uart_port->port, co, baud,\n\t\t\t\tparity, bits, flow);\n}\n\nstatic struct uart_driver sprd_uart_driver;\nstatic struct console sprd_console = {\n\t.name = SPRD_TTY_NAME,\n\t.write = sprd_console_write,\n\t.device = uart_console_device,\n\t.setup = sprd_console_setup,\n\t.flags = CON_PRINTBUFFER,\n\t.index = -1,\n\t.data = &sprd_uart_driver,\n};\n\nstatic int __init sprd_serial_console_init(void)\n{\n\tregister_console(&sprd_console);\n\treturn 0;\n}\nconsole_initcall(sprd_serial_console_init);\n\n#define SPRD_CONSOLE\t(&sprd_console)\n\n \nstatic void sprd_putc(struct uart_port *port, unsigned char c)\n{\n\tunsigned int timeout = SPRD_TIMEOUT;\n\n\twhile (timeout-- &&\n\t       !(readl(port->membase + SPRD_LSR) & SPRD_LSR_TX_OVER))\n\t\tcpu_relax();\n\n\twriteb(c, port->membase + SPRD_TXD);\n}\n\nstatic void sprd_early_write(struct console *con, const char *s, unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, sprd_putc);\n}\n\nstatic int __init sprd_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t   const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = sprd_early_write;\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(sprd_serial, \"sprd,sc9836-uart\",\n\t\t    sprd_early_console_setup);\n\n#else  \n#define SPRD_CONSOLE\t\tNULL\n#endif\n\nstatic struct uart_driver sprd_uart_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = \"sprd_serial\",\n\t.dev_name = SPRD_TTY_NAME,\n\t.major = 0,\n\t.minor = 0,\n\t.nr = UART_NR_MAX,\n\t.cons = SPRD_CONSOLE,\n};\n\nstatic int sprd_remove(struct platform_device *dev)\n{\n\tstruct sprd_uart_port *sup = platform_get_drvdata(dev);\n\n\tif (sup) {\n\t\tuart_remove_one_port(&sprd_uart_driver, &sup->port);\n\t\tsprd_port[sup->port.line] = NULL;\n\t\tsprd_rx_free_buf(sup);\n\t\tsprd_ports_num--;\n\t}\n\n\tif (!sprd_ports_num)\n\t\tuart_unregister_driver(&sprd_uart_driver);\n\n\treturn 0;\n}\n\nstatic bool sprd_uart_is_console(struct uart_port *uport)\n{\n\tstruct console *cons = sprd_uart_driver.cons;\n\n\tif ((cons && cons->index >= 0 && cons->index == uport->line) ||\n\t    of_console_check(uport->dev->of_node, SPRD_TTY_NAME, uport->line))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int sprd_clk_init(struct uart_port *uport)\n{\n\tstruct clk *clk_uart, *clk_parent;\n\tstruct sprd_uart_port *u = container_of(uport, struct sprd_uart_port, port);\n\n\tclk_uart = devm_clk_get(uport->dev, \"uart\");\n\tif (IS_ERR(clk_uart)) {\n\t\tdev_warn(uport->dev, \"uart%d can't get uart clock\\n\",\n\t\t\t uport->line);\n\t\tclk_uart = NULL;\n\t}\n\n\tclk_parent = devm_clk_get(uport->dev, \"source\");\n\tif (IS_ERR(clk_parent)) {\n\t\tdev_warn(uport->dev, \"uart%d can't get source clock\\n\",\n\t\t\t uport->line);\n\t\tclk_parent = NULL;\n\t}\n\n\tif (!clk_uart || clk_set_parent(clk_uart, clk_parent))\n\t\tuport->uartclk = SPRD_DEFAULT_SOURCE_CLK;\n\telse\n\t\tuport->uartclk = clk_get_rate(clk_uart);\n\n\tu->clk = devm_clk_get(uport->dev, \"enable\");\n\tif (IS_ERR(u->clk)) {\n\t\tif (PTR_ERR(u->clk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tdev_warn(uport->dev, \"uart%d can't get enable clock\\n\",\n\t\t\tuport->line);\n\n\t\t \n\t\tif (!sprd_uart_is_console(uport))\n\t\t\treturn PTR_ERR(u->clk);\n\n\t\tu->clk = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct uart_port *up;\n\tstruct sprd_uart_port *sport;\n\tint irq;\n\tint index;\n\tint ret;\n\n\tindex = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\tif (index < 0 || index >= UART_NR_MAX) {\n\t\tdev_err(&pdev->dev, \"got a wrong serial alias id %d\\n\", index);\n\t\treturn -EINVAL;\n\t}\n\n\tsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n\tif (!sport)\n\t\treturn -ENOMEM;\n\n\tup = &sport->port;\n\tup->dev = &pdev->dev;\n\tup->line = index;\n\tup->type = PORT_SPRD;\n\tup->iotype = UPIO_MEM;\n\tup->uartclk = SPRD_DEF_RATE;\n\tup->fifosize = SPRD_FIFO_SIZE;\n\tup->ops = &serial_sprd_ops;\n\tup->flags = UPF_BOOT_AUTOCONF;\n\tup->has_sysrq = IS_ENABLED(CONFIG_SERIAL_SPRD_CONSOLE);\n\n\tret = sprd_clk_init(up);\n\tif (ret)\n\t\treturn ret;\n\n\tup->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(up->membase))\n\t\treturn PTR_ERR(up->membase);\n\n\tup->mapbase = res->start;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tup->irq = irq;\n\n\t \n\tret = sprd_rx_alloc_buf(sport);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!sprd_ports_num) {\n\t\tret = uart_register_driver(&sprd_uart_driver);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to register SPRD-UART driver\\n\");\n\t\t\tgoto free_rx_buf;\n\t\t}\n\t}\n\n\tsprd_ports_num++;\n\tsprd_port[index] = sport;\n\n\tret = uart_add_one_port(&sprd_uart_driver, up);\n\tif (ret)\n\t\tgoto clean_port;\n\n\tplatform_set_drvdata(pdev, up);\n\n\treturn 0;\n\nclean_port:\n\tsprd_port[index] = NULL;\n\tif (--sprd_ports_num == 0)\n\t\tuart_unregister_driver(&sprd_uart_driver);\nfree_rx_buf:\n\tsprd_rx_free_buf(sport);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sprd_suspend(struct device *dev)\n{\n\tstruct sprd_uart_port *sup = dev_get_drvdata(dev);\n\n\tuart_suspend_port(&sprd_uart_driver, &sup->port);\n\n\treturn 0;\n}\n\nstatic int sprd_resume(struct device *dev)\n{\n\tstruct sprd_uart_port *sup = dev_get_drvdata(dev);\n\n\tuart_resume_port(&sprd_uart_driver, &sup->port);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(sprd_pm_ops, sprd_suspend, sprd_resume);\n\nstatic const struct of_device_id serial_ids[] = {\n\t{.compatible = \"sprd,sc9836-uart\",},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, serial_ids);\n\nstatic struct platform_driver sprd_platform_driver = {\n\t.probe\t\t= sprd_probe,\n\t.remove\t\t= sprd_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"sprd_serial\",\n\t\t.of_match_table = serial_ids,\n\t\t.pm\t= &sprd_pm_ops,\n\t},\n};\n\nmodule_platform_driver(sprd_platform_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Spreadtrum SoC serial driver series\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}