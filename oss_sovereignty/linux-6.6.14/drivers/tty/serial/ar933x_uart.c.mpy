{
  "module_name": "ar933x_uart.c",
  "hash_id": "62bdb83d1e5424da61c57f6d5bb0e4eae7e4bee3510952c50692b95406402b95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/ar933x_uart.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/clk.h>\n\n#include <asm/div64.h>\n\n#include <asm/mach-ath79/ar933x_uart.h>\n\n#include \"serial_mctrl_gpio.h\"\n\n#define DRIVER_NAME \"ar933x-uart\"\n\n#define AR933X_UART_MAX_SCALE\t0xff\n#define AR933X_UART_MAX_STEP\t0xffff\n\n#define AR933X_UART_MIN_BAUD\t300\n#define AR933X_UART_MAX_BAUD\t3000000\n\n#define AR933X_DUMMY_STATUS_RD\t0x01\n\nstatic struct uart_driver ar933x_uart_driver;\n\nstruct ar933x_uart_port {\n\tstruct uart_port\tport;\n\tunsigned int\t\tier;\t \n\tunsigned int\t\tmin_baud;\n\tunsigned int\t\tmax_baud;\n\tstruct clk\t\t*clk;\n\tstruct mctrl_gpios\t*gpios;\n\tstruct gpio_desc\t*rts_gpiod;\n};\n\nstatic inline unsigned int ar933x_uart_read(struct ar933x_uart_port *up,\n\t\t\t\t\t    int offset)\n{\n\treturn readl(up->port.membase + offset);\n}\n\nstatic inline void ar933x_uart_write(struct ar933x_uart_port *up,\n\t\t\t\t     int offset, unsigned int value)\n{\n\twritel(value, up->port.membase + offset);\n}\n\nstatic inline void ar933x_uart_rmw(struct ar933x_uart_port *up,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  unsigned int mask,\n\t\t\t\t  unsigned int val)\n{\n\tunsigned int t;\n\n\tt = ar933x_uart_read(up, offset);\n\tt &= ~mask;\n\tt |= val;\n\tar933x_uart_write(up, offset, t);\n}\n\nstatic inline void ar933x_uart_rmw_set(struct ar933x_uart_port *up,\n\t\t\t\t       unsigned int offset,\n\t\t\t\t       unsigned int val)\n{\n\tar933x_uart_rmw(up, offset, 0, val);\n}\n\nstatic inline void ar933x_uart_rmw_clear(struct ar933x_uart_port *up,\n\t\t\t\t\t unsigned int offset,\n\t\t\t\t\t unsigned int val)\n{\n\tar933x_uart_rmw(up, offset, val, 0);\n}\n\nstatic inline void ar933x_uart_start_tx_interrupt(struct ar933x_uart_port *up)\n{\n\tup->ier |= AR933X_UART_INT_TX_EMPTY;\n\tar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);\n}\n\nstatic inline void ar933x_uart_stop_tx_interrupt(struct ar933x_uart_port *up)\n{\n\tup->ier &= ~AR933X_UART_INT_TX_EMPTY;\n\tar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);\n}\n\nstatic inline void ar933x_uart_start_rx_interrupt(struct ar933x_uart_port *up)\n{\n\tup->ier |= AR933X_UART_INT_RX_VALID;\n\tar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);\n}\n\nstatic inline void ar933x_uart_stop_rx_interrupt(struct ar933x_uart_port *up)\n{\n\tup->ier &= ~AR933X_UART_INT_RX_VALID;\n\tar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);\n}\n\nstatic inline void ar933x_uart_putc(struct ar933x_uart_port *up, int ch)\n{\n\tunsigned int rdata;\n\n\trdata = ch & AR933X_UART_DATA_TX_RX_MASK;\n\trdata |= AR933X_UART_DATA_TX_CSR;\n\tar933x_uart_write(up, AR933X_UART_DATA_REG, rdata);\n}\n\nstatic unsigned int ar933x_uart_tx_empty(struct uart_port *port)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\tunsigned long flags;\n\tunsigned int rdata;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\trdata = ar933x_uart_read(up, AR933X_UART_DATA_REG);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\treturn (rdata & AR933X_UART_DATA_TX_CSR) ? 0 : TIOCSER_TEMT;\n}\n\nstatic unsigned int ar933x_uart_get_mctrl(struct uart_port *port)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\tint ret = TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\n\n\tmctrl_gpio_get(up->gpios, &ret);\n\n\treturn ret;\n}\n\nstatic void ar933x_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\n\tmctrl_gpio_set(up->gpios, mctrl);\n}\n\nstatic void ar933x_uart_start_tx(struct uart_port *port)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\n\tar933x_uart_start_tx_interrupt(up);\n}\n\nstatic void ar933x_uart_wait_tx_complete(struct ar933x_uart_port *up)\n{\n\tunsigned int status;\n\tunsigned int timeout = 60000;\n\n\t \n\tdo {\n\t\tstatus = ar933x_uart_read(up, AR933X_UART_CS_REG);\n\t\tif (--timeout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (status & AR933X_UART_CS_TX_BUSY);\n\n\tif (timeout == 0)\n\t\tdev_err(up->port.dev, \"waiting for TX timed out\\n\");\n}\n\nstatic void ar933x_uart_rx_flush(struct ar933x_uart_port *up)\n{\n\tunsigned int status;\n\n\t \n\tar933x_uart_write(up, AR933X_UART_INT_REG, AR933X_UART_INT_RX_VALID);\n\n\t \n\tdo {\n\t\tar933x_uart_write(up, AR933X_UART_DATA_REG, AR933X_UART_DATA_RX_CSR);\n\t\tstatus = ar933x_uart_read(up, AR933X_UART_DATA_REG);\n\t} while (status & AR933X_UART_DATA_RX_CSR);\n}\n\nstatic void ar933x_uart_stop_tx(struct uart_port *port)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\n\tar933x_uart_stop_tx_interrupt(up);\n}\n\nstatic void ar933x_uart_stop_rx(struct uart_port *port)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\n\tar933x_uart_stop_rx_interrupt(up);\n}\n\nstatic void ar933x_uart_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\tif (break_state == -1)\n\t\tar933x_uart_rmw_set(up, AR933X_UART_CS_REG,\n\t\t\t\t    AR933X_UART_CS_TX_BREAK);\n\telse\n\t\tar933x_uart_rmw_clear(up, AR933X_UART_CS_REG,\n\t\t\t\t      AR933X_UART_CS_TX_BREAK);\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n}\n\n \nstatic unsigned long ar933x_uart_get_baud(unsigned int clk,\n\t\t\t\t\t  unsigned int scale,\n\t\t\t\t\t  unsigned int step)\n{\n\tu64 t;\n\tu32 div;\n\n\tdiv = (2 << 16) * (scale + 1);\n\tt = clk;\n\tt *= step;\n\tt += (div / 2);\n\tdo_div(t, div);\n\n\treturn t;\n}\n\nstatic void ar933x_uart_get_scale_step(unsigned int clk,\n\t\t\t\t       unsigned int baud,\n\t\t\t\t       unsigned int *scale,\n\t\t\t\t       unsigned int *step)\n{\n\tunsigned int tscale;\n\tlong min_diff;\n\n\t*scale = 0;\n\t*step = 0;\n\n\tmin_diff = baud;\n\tfor (tscale = 0; tscale < AR933X_UART_MAX_SCALE; tscale++) {\n\t\tu64 tstep;\n\t\tint diff;\n\n\t\ttstep = baud * (tscale + 1);\n\t\ttstep *= (2 << 16);\n\t\tdo_div(tstep, clk);\n\n\t\tif (tstep > AR933X_UART_MAX_STEP)\n\t\t\tbreak;\n\n\t\tdiff = abs(ar933x_uart_get_baud(clk, tscale, tstep) - baud);\n\t\tif (diff < min_diff) {\n\t\t\tmin_diff = diff;\n\t\t\t*scale = tscale;\n\t\t\t*step = tstep;\n\t\t}\n\t}\n}\n\nstatic void ar933x_uart_set_termios(struct uart_port *port,\n\t\t\t\t    struct ktermios *new,\n\t\t\t\t    const struct ktermios *old)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\tunsigned int cs;\n\tunsigned long flags;\n\tunsigned int baud, scale, step;\n\n\t \n\tnew->c_cflag &= ~CSIZE;\n\tnew->c_cflag |= CS8;\n\n\t \n\tnew->c_cflag &= ~CSTOPB;\n\n\tcs = 0;\n\tif (new->c_cflag & PARENB) {\n\t\tif (!(new->c_cflag & PARODD))\n\t\t\tcs |= AR933X_UART_CS_PARITY_EVEN;\n\t\telse\n\t\t\tcs |= AR933X_UART_CS_PARITY_ODD;\n\t} else {\n\t\tcs |= AR933X_UART_CS_PARITY_NONE;\n\t}\n\n\t \n\tnew->c_cflag &= ~CMSPAR;\n\n\tbaud = uart_get_baud_rate(port, new, old, up->min_baud, up->max_baud);\n\tar933x_uart_get_scale_step(port->uartclk, baud, &scale, &step);\n\n\t \n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t \n\tar933x_uart_rmw_clear(up, AR933X_UART_CS_REG,\n\t\t      AR933X_UART_CS_IF_MODE_M << AR933X_UART_CS_IF_MODE_S);\n\n\t \n\tuart_update_timeout(port, new->c_cflag, baud);\n\n\tup->port.ignore_status_mask = 0;\n\n\t \n\tif ((new->c_cflag & CREAD) == 0)\n\t\tup->port.ignore_status_mask |= AR933X_DUMMY_STATUS_RD;\n\n\tar933x_uart_write(up, AR933X_UART_CLOCK_REG,\n\t\t\t  scale << AR933X_UART_CLOCK_SCALE_S | step);\n\n\t \n\tar933x_uart_rmw(up, AR933X_UART_CS_REG, AR933X_UART_CS_PARITY_M, cs);\n\n\t \n\tar933x_uart_rmw_set(up, AR933X_UART_CS_REG,\n\t\t\t    AR933X_UART_CS_HOST_INT_EN);\n\n\t \n\tar933x_uart_rmw_set(up, AR933X_UART_CS_REG,\n\t\tAR933X_UART_CS_TX_READY_ORIDE | AR933X_UART_CS_RX_READY_ORIDE);\n\n\t \n\tar933x_uart_rmw(up, AR933X_UART_CS_REG,\n\t\t\tAR933X_UART_CS_IF_MODE_M << AR933X_UART_CS_IF_MODE_S,\n\t\t\tAR933X_UART_CS_IF_MODE_DCE << AR933X_UART_CS_IF_MODE_S);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\tif (tty_termios_baud_rate(new))\n\t\ttty_termios_encode_baud_rate(new, baud, baud);\n}\n\nstatic void ar933x_uart_rx_chars(struct ar933x_uart_port *up)\n{\n\tstruct tty_port *port = &up->port.state->port;\n\tint max_count = 256;\n\n\tdo {\n\t\tunsigned int rdata;\n\t\tunsigned char ch;\n\n\t\trdata = ar933x_uart_read(up, AR933X_UART_DATA_REG);\n\t\tif ((rdata & AR933X_UART_DATA_RX_CSR) == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tar933x_uart_write(up, AR933X_UART_DATA_REG,\n\t\t\t\t  AR933X_UART_DATA_RX_CSR);\n\n\t\tup->port.icount.rx++;\n\t\tch = rdata & AR933X_UART_DATA_TX_RX_MASK;\n\n\t\tif (uart_handle_sysrq_char(&up->port, ch))\n\t\t\tcontinue;\n\n\t\tif ((up->port.ignore_status_mask & AR933X_DUMMY_STATUS_RD) == 0)\n\t\t\ttty_insert_flip_char(port, ch, TTY_NORMAL);\n\t} while (max_count-- > 0);\n\n\ttty_flip_buffer_push(port);\n}\n\nstatic void ar933x_uart_tx_chars(struct ar933x_uart_port *up)\n{\n\tstruct circ_buf *xmit = &up->port.state->xmit;\n\tstruct serial_rs485 *rs485conf = &up->port.rs485;\n\tint count;\n\tbool half_duplex_send = false;\n\n\tif (uart_tx_stopped(&up->port))\n\t\treturn;\n\n\tif ((rs485conf->flags & SER_RS485_ENABLED) &&\n\t    (up->port.x_char || !uart_circ_empty(xmit))) {\n\t\tar933x_uart_stop_rx_interrupt(up);\n\t\tgpiod_set_value(up->rts_gpiod, !!(rs485conf->flags & SER_RS485_RTS_ON_SEND));\n\t\thalf_duplex_send = true;\n\t}\n\n\tcount = up->port.fifosize;\n\tdo {\n\t\tunsigned int rdata;\n\n\t\trdata = ar933x_uart_read(up, AR933X_UART_DATA_REG);\n\t\tif ((rdata & AR933X_UART_DATA_TX_CSR) == 0)\n\t\t\tbreak;\n\n\t\tif (up->port.x_char) {\n\t\t\tar933x_uart_putc(up, up->port.x_char);\n\t\t\tup->port.icount.tx++;\n\t\t\tup->port.x_char = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (uart_circ_empty(xmit))\n\t\t\tbreak;\n\n\t\tar933x_uart_putc(up, xmit->buf[xmit->tail]);\n\n\t\tuart_xmit_advance(&up->port, 1);\n\t} while (--count > 0);\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&up->port);\n\n\tif (!uart_circ_empty(xmit)) {\n\t\tar933x_uart_start_tx_interrupt(up);\n\t} else if (half_duplex_send) {\n\t\tar933x_uart_wait_tx_complete(up);\n\t\tar933x_uart_rx_flush(up);\n\t\tar933x_uart_start_rx_interrupt(up);\n\t\tgpiod_set_value(up->rts_gpiod, !!(rs485conf->flags & SER_RS485_RTS_AFTER_SEND));\n\t}\n}\n\nstatic irqreturn_t ar933x_uart_interrupt(int irq, void *dev_id)\n{\n\tstruct ar933x_uart_port *up = dev_id;\n\tunsigned int status;\n\n\tstatus = ar933x_uart_read(up, AR933X_UART_CS_REG);\n\tif ((status & AR933X_UART_CS_HOST_INT) == 0)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&up->port.lock);\n\n\tstatus = ar933x_uart_read(up, AR933X_UART_INT_REG);\n\tstatus &= ar933x_uart_read(up, AR933X_UART_INT_EN_REG);\n\n\tif (status & AR933X_UART_INT_RX_VALID) {\n\t\tar933x_uart_write(up, AR933X_UART_INT_REG,\n\t\t\t\t  AR933X_UART_INT_RX_VALID);\n\t\tar933x_uart_rx_chars(up);\n\t}\n\n\tif (status & AR933X_UART_INT_TX_EMPTY) {\n\t\tar933x_uart_write(up, AR933X_UART_INT_REG,\n\t\t\t\t  AR933X_UART_INT_TX_EMPTY);\n\t\tar933x_uart_stop_tx_interrupt(up);\n\t\tar933x_uart_tx_chars(up);\n\t}\n\n\tspin_unlock(&up->port.lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ar933x_uart_startup(struct uart_port *port)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\tunsigned long flags;\n\tint ret;\n\n\tret = request_irq(up->port.irq, ar933x_uart_interrupt,\n\t\t\t  up->port.irqflags, dev_name(up->port.dev), up);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t \n\tar933x_uart_rmw_set(up, AR933X_UART_CS_REG,\n\t\t\t    AR933X_UART_CS_HOST_INT_EN);\n\n\t \n\tar933x_uart_rmw_set(up, AR933X_UART_CS_REG,\n\t\tAR933X_UART_CS_TX_READY_ORIDE | AR933X_UART_CS_RX_READY_ORIDE);\n\n\t \n\tar933x_uart_start_rx_interrupt(up);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\treturn 0;\n}\n\nstatic void ar933x_uart_shutdown(struct uart_port *port)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\n\t \n\tup->ier = 0;\n\tar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);\n\n\t \n\tar933x_uart_rmw_clear(up, AR933X_UART_CS_REG,\n\t\t\t      AR933X_UART_CS_TX_BREAK);\n\n\tfree_irq(up->port.irq, up);\n}\n\nstatic const char *ar933x_uart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_AR933X) ? \"AR933X UART\" : NULL;\n}\n\nstatic void ar933x_uart_release_port(struct uart_port *port)\n{\n\t \n}\n\nstatic int ar933x_uart_request_port(struct uart_port *port)\n{\n\t \n\treturn 0;\n}\n\nstatic void ar933x_uart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_AR933X;\n}\n\nstatic int ar933x_uart_verify_port(struct uart_port *port,\n\t\t\t\t   struct serial_struct *ser)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\n\tif (ser->type != PORT_UNKNOWN &&\n\t    ser->type != PORT_AR933X)\n\t\treturn -EINVAL;\n\n\tif (ser->irq < 0 || ser->irq >= NR_IRQS)\n\t\treturn -EINVAL;\n\n\tif (ser->baud_base < up->min_baud ||\n\t    ser->baud_base > up->max_baud)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct uart_ops ar933x_uart_ops = {\n\t.tx_empty\t= ar933x_uart_tx_empty,\n\t.set_mctrl\t= ar933x_uart_set_mctrl,\n\t.get_mctrl\t= ar933x_uart_get_mctrl,\n\t.stop_tx\t= ar933x_uart_stop_tx,\n\t.start_tx\t= ar933x_uart_start_tx,\n\t.stop_rx\t= ar933x_uart_stop_rx,\n\t.break_ctl\t= ar933x_uart_break_ctl,\n\t.startup\t= ar933x_uart_startup,\n\t.shutdown\t= ar933x_uart_shutdown,\n\t.set_termios\t= ar933x_uart_set_termios,\n\t.type\t\t= ar933x_uart_type,\n\t.release_port\t= ar933x_uart_release_port,\n\t.request_port\t= ar933x_uart_request_port,\n\t.config_port\t= ar933x_uart_config_port,\n\t.verify_port\t= ar933x_uart_verify_port,\n};\n\nstatic int ar933x_config_rs485(struct uart_port *port, struct ktermios *termios,\n\t\t\t\tstruct serial_rs485 *rs485conf)\n{\n\tstruct ar933x_uart_port *up =\n\t\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\n\tif (port->rs485.flags & SER_RS485_ENABLED)\n\t\tgpiod_set_value(up->rts_gpiod,\n\t\t\t!!(rs485conf->flags & SER_RS485_RTS_AFTER_SEND));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SERIAL_AR933X_CONSOLE\nstatic struct ar933x_uart_port *\nar933x_console_ports[CONFIG_SERIAL_AR933X_NR_UARTS];\n\nstatic void ar933x_uart_wait_xmitr(struct ar933x_uart_port *up)\n{\n\tunsigned int status;\n\tunsigned int timeout = 60000;\n\n\t \n\tdo {\n\t\tstatus = ar933x_uart_read(up, AR933X_UART_DATA_REG);\n\t\tif (--timeout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while ((status & AR933X_UART_DATA_TX_CSR) == 0);\n}\n\nstatic void ar933x_uart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tstruct ar933x_uart_port *up =\n\t\tcontainer_of(port, struct ar933x_uart_port, port);\n\n\tar933x_uart_wait_xmitr(up);\n\tar933x_uart_putc(up, ch);\n}\n\nstatic void ar933x_uart_console_write(struct console *co, const char *s,\n\t\t\t\t      unsigned int count)\n{\n\tstruct ar933x_uart_port *up = ar933x_console_ports[co->index];\n\tunsigned long flags;\n\tunsigned int int_en;\n\tint locked = 1;\n\n\tlocal_irq_save(flags);\n\n\tif (up->port.sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock(&up->port.lock);\n\telse\n\t\tspin_lock(&up->port.lock);\n\n\t \n\tint_en = ar933x_uart_read(up, AR933X_UART_INT_EN_REG);\n\tar933x_uart_write(up, AR933X_UART_INT_EN_REG, 0);\n\n\tuart_console_write(&up->port, s, count, ar933x_uart_console_putchar);\n\n\t \n\tar933x_uart_wait_xmitr(up);\n\tar933x_uart_write(up, AR933X_UART_INT_EN_REG, int_en);\n\n\tar933x_uart_write(up, AR933X_UART_INT_REG, AR933X_UART_INT_ALLINTS);\n\n\tif (locked)\n\t\tspin_unlock(&up->port.lock);\n\n\tlocal_irq_restore(flags);\n}\n\nstatic int ar933x_uart_console_setup(struct console *co, char *options)\n{\n\tstruct ar933x_uart_port *up;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index < 0 || co->index >= CONFIG_SERIAL_AR933X_NR_UARTS)\n\t\treturn -EINVAL;\n\n\tup = ar933x_console_ports[co->index];\n\tif (!up)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&up->port, co, baud, parity, bits, flow);\n}\n\nstatic struct console ar933x_uart_console = {\n\t.name\t\t= \"ttyATH\",\n\t.write\t\t= ar933x_uart_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= ar933x_uart_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &ar933x_uart_driver,\n};\n#endif  \n\nstatic struct uart_driver ar933x_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= DRIVER_NAME,\n\t.dev_name\t= \"ttyATH\",\n\t.nr\t\t= CONFIG_SERIAL_AR933X_NR_UARTS,\n\t.cons\t\t= NULL,  \n};\n\nstatic const struct serial_rs485 ar933x_no_rs485 = {};\nstatic const struct serial_rs485 ar933x_rs485_supported = {\n\t.flags = SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND | SER_RS485_RTS_AFTER_SEND,\n};\n\nstatic int ar933x_uart_probe(struct platform_device *pdev)\n{\n\tstruct ar933x_uart_port *up;\n\tstruct uart_port *port;\n\tstruct resource *mem_res;\n\tstruct device_node *np;\n\tunsigned int baud;\n\tint id;\n\tint ret;\n\tint irq;\n\n\tnp = pdev->dev.of_node;\n\tif (IS_ENABLED(CONFIG_OF) && np) {\n\t\tid = of_alias_get_id(np, \"serial\");\n\t\tif (id < 0) {\n\t\t\tdev_err(&pdev->dev, \"unable to get alias id, err=%d\\n\",\n\t\t\t\tid);\n\t\t\treturn id;\n\t\t}\n\t} else {\n\t\tid = pdev->id;\n\t\tif (id == -1)\n\t\t\tid = 0;\n\t}\n\n\tif (id >= CONFIG_SERIAL_AR933X_NR_UARTS)\n\t\treturn -EINVAL;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tup = devm_kzalloc(&pdev->dev, sizeof(struct ar933x_uart_port),\n\t\t\t  GFP_KERNEL);\n\tif (!up)\n\t\treturn -ENOMEM;\n\n\tup->clk = devm_clk_get(&pdev->dev, \"uart\");\n\tif (IS_ERR(up->clk)) {\n\t\tdev_err(&pdev->dev, \"unable to get UART clock\\n\");\n\t\treturn PTR_ERR(up->clk);\n\t}\n\n\tport = &up->port;\n\n\tport->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &mem_res);\n\tif (IS_ERR(port->membase))\n\t\treturn PTR_ERR(port->membase);\n\n\tret = clk_prepare_enable(up->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tport->uartclk = clk_get_rate(up->clk);\n\tif (!port->uartclk) {\n\t\tret = -EINVAL;\n\t\tgoto err_disable_clk;\n\t}\n\n\tport->mapbase = mem_res->start;\n\tport->line = id;\n\tport->irq = irq;\n\tport->dev = &pdev->dev;\n\tport->type = PORT_AR933X;\n\tport->iotype = UPIO_MEM32;\n\n\tport->regshift = 2;\n\tport->fifosize = AR933X_UART_FIFO_SIZE;\n\tport->ops = &ar933x_uart_ops;\n\tport->rs485_config = ar933x_config_rs485;\n\tport->rs485_supported = ar933x_rs485_supported;\n\n\tbaud = ar933x_uart_get_baud(port->uartclk, AR933X_UART_MAX_SCALE, 1);\n\tup->min_baud = max_t(unsigned int, baud, AR933X_UART_MIN_BAUD);\n\n\tbaud = ar933x_uart_get_baud(port->uartclk, 0, AR933X_UART_MAX_STEP);\n\tup->max_baud = min_t(unsigned int, baud, AR933X_UART_MAX_BAUD);\n\n\tret = uart_get_rs485_mode(port);\n\tif (ret)\n\t\tgoto err_disable_clk;\n\n\tup->gpios = mctrl_gpio_init(port, 0);\n\tif (IS_ERR(up->gpios) && PTR_ERR(up->gpios) != -ENOSYS) {\n\t\tret = PTR_ERR(up->gpios);\n\t\tgoto err_disable_clk;\n\t}\n\n\tup->rts_gpiod = mctrl_gpio_to_gpiod(up->gpios, UART_GPIO_RTS);\n\n\tif (!up->rts_gpiod) {\n\t\tport->rs485_supported = ar933x_no_rs485;\n\t\tif (port->rs485.flags & SER_RS485_ENABLED) {\n\t\t\tdev_err(&pdev->dev, \"lacking rts-gpio, disabling RS485\\n\");\n\t\t\tport->rs485.flags &= ~SER_RS485_ENABLED;\n\t\t}\n\t}\n\n#ifdef CONFIG_SERIAL_AR933X_CONSOLE\n\tar933x_console_ports[up->port.line] = up;\n#endif\n\n\tret = uart_add_one_port(&ar933x_uart_driver, &up->port);\n\tif (ret)\n\t\tgoto err_disable_clk;\n\n\tplatform_set_drvdata(pdev, up);\n\treturn 0;\n\nerr_disable_clk:\n\tclk_disable_unprepare(up->clk);\n\treturn ret;\n}\n\nstatic int ar933x_uart_remove(struct platform_device *pdev)\n{\n\tstruct ar933x_uart_port *up;\n\n\tup = platform_get_drvdata(pdev);\n\n\tif (up) {\n\t\tuart_remove_one_port(&ar933x_uart_driver, &up->port);\n\t\tclk_disable_unprepare(up->clk);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ar933x_uart_of_ids[] = {\n\t{ .compatible = \"qca,ar9330-uart\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ar933x_uart_of_ids);\n#endif\n\nstatic struct platform_driver ar933x_uart_platform_driver = {\n\t.probe\t\t= ar933x_uart_probe,\n\t.remove\t\t= ar933x_uart_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(ar933x_uart_of_ids),\n\t},\n};\n\nstatic int __init ar933x_uart_init(void)\n{\n\tint ret;\n\n#ifdef CONFIG_SERIAL_AR933X_CONSOLE\n\tar933x_uart_driver.cons = &ar933x_uart_console;\n#endif\n\n\tret = uart_register_driver(&ar933x_uart_driver);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = platform_driver_register(&ar933x_uart_platform_driver);\n\tif (ret)\n\t\tgoto err_unregister_uart_driver;\n\n\treturn 0;\n\nerr_unregister_uart_driver:\n\tuart_unregister_driver(&ar933x_uart_driver);\nerr_out:\n\treturn ret;\n}\n\nstatic void __exit ar933x_uart_exit(void)\n{\n\tplatform_driver_unregister(&ar933x_uart_platform_driver);\n\tuart_unregister_driver(&ar933x_uart_driver);\n}\n\nmodule_init(ar933x_uart_init);\nmodule_exit(ar933x_uart_exit);\n\nMODULE_DESCRIPTION(\"Atheros AR933X UART driver\");\nMODULE_AUTHOR(\"Gabor Juhos <juhosg@openwrt.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}