{
  "module_name": "mvebu-uart.c",
  "hash_id": "143e6664ff18c0e53eabfeb91aab9bbe1593ab7544d4510c6cdc8a2008e99390",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/mvebu-uart.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/math64.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n \n#define UART_STD_RBR\t\t0x00\n#define UART_EXT_RBR\t\t0x18\n\n#define UART_STD_TSH\t\t0x04\n#define UART_EXT_TSH\t\t0x1C\n\n#define UART_STD_CTRL1\t\t0x08\n#define UART_EXT_CTRL1\t\t0x04\n#define  CTRL_SOFT_RST\t\tBIT(31)\n#define  CTRL_TXFIFO_RST\tBIT(15)\n#define  CTRL_RXFIFO_RST\tBIT(14)\n#define  CTRL_SND_BRK_SEQ\tBIT(11)\n#define  CTRL_BRK_DET_INT\tBIT(3)\n#define  CTRL_FRM_ERR_INT\tBIT(2)\n#define  CTRL_PAR_ERR_INT\tBIT(1)\n#define  CTRL_OVR_ERR_INT\tBIT(0)\n#define  CTRL_BRK_INT\t\t(CTRL_BRK_DET_INT | CTRL_FRM_ERR_INT | \\\n\t\t\t\tCTRL_PAR_ERR_INT | CTRL_OVR_ERR_INT)\n\n#define UART_STD_CTRL2\t\tUART_STD_CTRL1\n#define UART_EXT_CTRL2\t\t0x20\n#define  CTRL_STD_TX_RDY_INT\tBIT(5)\n#define  CTRL_EXT_TX_RDY_INT\tBIT(6)\n#define  CTRL_STD_RX_RDY_INT\tBIT(4)\n#define  CTRL_EXT_RX_RDY_INT\tBIT(5)\n\n#define UART_STAT\t\t0x0C\n#define  STAT_TX_FIFO_EMP\tBIT(13)\n#define  STAT_TX_FIFO_FUL\tBIT(11)\n#define  STAT_TX_EMP\t\tBIT(6)\n#define  STAT_STD_TX_RDY\tBIT(5)\n#define  STAT_EXT_TX_RDY\tBIT(15)\n#define  STAT_STD_RX_RDY\tBIT(4)\n#define  STAT_EXT_RX_RDY\tBIT(14)\n#define  STAT_BRK_DET\t\tBIT(3)\n#define  STAT_FRM_ERR\t\tBIT(2)\n#define  STAT_PAR_ERR\t\tBIT(1)\n#define  STAT_OVR_ERR\t\tBIT(0)\n#define  STAT_BRK_ERR\t\t(STAT_BRK_DET | STAT_FRM_ERR \\\n\t\t\t\t | STAT_PAR_ERR | STAT_OVR_ERR)\n\n \n\n#define UART_BRDV\t\t0x10\n \n#define  UART2_CLK_DIS\t\tBIT(21)\n \n#define  UART1_CLK_DIS\t\tBIT(20)\n \n#define  CLK_NO_XTAL\t\tBIT(19)\n#define  CLK_TBG_DIV1_SHIFT\t15\n#define  CLK_TBG_DIV1_MASK\t0x7\n#define  CLK_TBG_DIV1_MAX\t6\n#define  CLK_TBG_DIV2_SHIFT\t12\n#define  CLK_TBG_DIV2_MASK\t0x7\n#define  CLK_TBG_DIV2_MAX\t6\n#define  CLK_TBG_SEL_SHIFT\t10\n#define  CLK_TBG_SEL_MASK\t0x3\n \n#define  BRDV_BAUD_MASK         0x3FF\n#define  BRDV_BAUD_MAX\t\tBRDV_BAUD_MASK\n\n#define UART_OSAMP\t\t0x14\n#define  OSAMP_DEFAULT_DIVISOR\t16\n#define  OSAMP_DIVISORS_MASK\t0x3F3F3F3F\n#define  OSAMP_MAX_DIVISOR\t63\n\n#define MVEBU_NR_UARTS\t\t2\n\n#define MVEBU_UART_TYPE\t\t\"mvebu-uart\"\n#define DRIVER_NAME\t\t\"mvebu_serial\"\n\nenum {\n\t \n\tUART_IRQ_SUM = 0,\n\t \n\tUART_RX_IRQ = 0,\n\tUART_TX_IRQ,\n\tUART_IRQ_COUNT\n};\n\n \nstruct uart_regs_layout {\n\tunsigned int rbr;\n\tunsigned int tsh;\n\tunsigned int ctrl;\n\tunsigned int intr;\n};\n\n \nstruct uart_flags {\n\tunsigned int ctrl_tx_rdy_int;\n\tunsigned int ctrl_rx_rdy_int;\n\tunsigned int stat_tx_rdy;\n\tunsigned int stat_rx_rdy;\n};\n\n \nstruct mvebu_uart_driver_data {\n\tbool is_ext;\n\tstruct uart_regs_layout regs;\n\tstruct uart_flags flags;\n};\n\n \nstruct mvebu_uart_pm_regs {\n\tunsigned int rbr;\n\tunsigned int tsh;\n\tunsigned int ctrl;\n\tunsigned int intr;\n\tunsigned int stat;\n\tunsigned int brdv;\n\tunsigned int osamp;\n};\n\n \nstruct mvebu_uart {\n\tstruct uart_port *port;\n\tstruct clk *clk;\n\tint irq[UART_IRQ_COUNT];\n\tstruct mvebu_uart_driver_data *data;\n#if defined(CONFIG_PM)\n\tstruct mvebu_uart_pm_regs pm_regs;\n#endif  \n};\n\nstatic struct mvebu_uart *to_mvuart(struct uart_port *port)\n{\n\treturn (struct mvebu_uart *)port->private_data;\n}\n\n#define IS_EXTENDED(port) (to_mvuart(port)->data->is_ext)\n\n#define UART_RBR(port) (to_mvuart(port)->data->regs.rbr)\n#define UART_TSH(port) (to_mvuart(port)->data->regs.tsh)\n#define UART_CTRL(port) (to_mvuart(port)->data->regs.ctrl)\n#define UART_INTR(port) (to_mvuart(port)->data->regs.intr)\n\n#define CTRL_TX_RDY_INT(port) (to_mvuart(port)->data->flags.ctrl_tx_rdy_int)\n#define CTRL_RX_RDY_INT(port) (to_mvuart(port)->data->flags.ctrl_rx_rdy_int)\n#define STAT_TX_RDY(port) (to_mvuart(port)->data->flags.stat_tx_rdy)\n#define STAT_RX_RDY(port) (to_mvuart(port)->data->flags.stat_rx_rdy)\n\nstatic struct uart_port mvebu_uart_ports[MVEBU_NR_UARTS];\n\nstatic DEFINE_SPINLOCK(mvebu_uart_lock);\n\n \nstatic unsigned int mvebu_uart_tx_empty(struct uart_port *port)\n{\n\tunsigned long flags;\n\tunsigned int st;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tst = readl(port->membase + UART_STAT);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn (st & STAT_TX_EMP) ? TIOCSER_TEMT : 0;\n}\n\nstatic unsigned int mvebu_uart_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\n}\n\nstatic void mvebu_uart_set_mctrl(struct uart_port *port,\n\t\t\t\t unsigned int mctrl)\n{\n \n}\n\nstatic void mvebu_uart_stop_tx(struct uart_port *port)\n{\n\tunsigned int ctl = readl(port->membase + UART_INTR(port));\n\n\tctl &= ~CTRL_TX_RDY_INT(port);\n\twritel(ctl, port->membase + UART_INTR(port));\n}\n\nstatic void mvebu_uart_start_tx(struct uart_port *port)\n{\n\tunsigned int ctl;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\tif (IS_EXTENDED(port) && !uart_circ_empty(xmit)) {\n\t\twritel(xmit->buf[xmit->tail], port->membase + UART_TSH(port));\n\t\tuart_xmit_advance(port, 1);\n\t}\n\n\tctl = readl(port->membase + UART_INTR(port));\n\tctl |= CTRL_TX_RDY_INT(port);\n\twritel(ctl, port->membase + UART_INTR(port));\n}\n\nstatic void mvebu_uart_stop_rx(struct uart_port *port)\n{\n\tunsigned int ctl;\n\n\tctl = readl(port->membase + UART_CTRL(port));\n\tctl &= ~CTRL_BRK_INT;\n\twritel(ctl, port->membase + UART_CTRL(port));\n\n\tctl = readl(port->membase + UART_INTR(port));\n\tctl &= ~CTRL_RX_RDY_INT(port);\n\twritel(ctl, port->membase + UART_INTR(port));\n}\n\nstatic void mvebu_uart_break_ctl(struct uart_port *port, int brk)\n{\n\tunsigned int ctl;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tctl = readl(port->membase + UART_CTRL(port));\n\tif (brk == -1)\n\t\tctl |= CTRL_SND_BRK_SEQ;\n\telse\n\t\tctl &= ~CTRL_SND_BRK_SEQ;\n\twritel(ctl, port->membase + UART_CTRL(port));\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void mvebu_uart_rx_chars(struct uart_port *port, unsigned int status)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned char ch = 0;\n\tchar flag = 0;\n\tint ret;\n\n\tdo {\n\t\tif (status & STAT_RX_RDY(port)) {\n\t\t\tch = readl(port->membase + UART_RBR(port));\n\t\t\tch &= 0xff;\n\t\t\tflag = TTY_NORMAL;\n\t\t\tport->icount.rx++;\n\n\t\t\tif (status & STAT_PAR_ERR)\n\t\t\t\tport->icount.parity++;\n\t\t}\n\n\t\t \n\t\tif (IS_EXTENDED(port) && (status & STAT_BRK_ERR)) {\n\t\t\tret = readl(port->membase + UART_STAT);\n\t\t\tret |= STAT_BRK_ERR;\n\t\t\twritel(ret, port->membase + UART_STAT);\n\t\t}\n\n\t\tif (status & STAT_BRK_DET) {\n\t\t\tport->icount.brk++;\n\t\t\tstatus &= ~(STAT_FRM_ERR | STAT_PAR_ERR);\n\t\t\tif (uart_handle_break(port))\n\t\t\t\tgoto ignore_char;\n\t\t}\n\n\t\tif (status & STAT_OVR_ERR)\n\t\t\tport->icount.overrun++;\n\n\t\tif (status & STAT_FRM_ERR)\n\t\t\tport->icount.frame++;\n\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tgoto ignore_char;\n\n\t\tif (status & port->ignore_status_mask & STAT_PAR_ERR)\n\t\t\tstatus &= ~STAT_RX_RDY(port);\n\n\t\tstatus &= port->read_status_mask;\n\n\t\tif (status & STAT_PAR_ERR)\n\t\t\tflag = TTY_PARITY;\n\n\t\tstatus &= ~port->ignore_status_mask;\n\n\t\tif (status & STAT_RX_RDY(port))\n\t\t\ttty_insert_flip_char(tport, ch, flag);\n\n\t\tif (status & STAT_BRK_DET)\n\t\t\ttty_insert_flip_char(tport, 0, TTY_BREAK);\n\n\t\tif (status & STAT_FRM_ERR)\n\t\t\ttty_insert_flip_char(tport, 0, TTY_FRAME);\n\n\t\tif (status & STAT_OVR_ERR)\n\t\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\nignore_char:\n\t\tstatus = readl(port->membase + UART_STAT);\n\t} while (status & (STAT_RX_RDY(port) | STAT_BRK_DET));\n\n\ttty_flip_buffer_push(tport);\n}\n\nstatic void mvebu_uart_tx_chars(struct uart_port *port, unsigned int status)\n{\n\tu8 ch;\n\n\tuart_port_tx_limited(port, ch, port->fifosize,\n\t\t!(readl(port->membase + UART_STAT) & STAT_TX_FIFO_FUL),\n\t\twritel(ch, port->membase + UART_TSH(port)),\n\t\t({}));\n}\n\nstatic irqreturn_t mvebu_uart_isr(int irq, void *dev_id)\n{\n\tstruct uart_port *port = (struct uart_port *)dev_id;\n\tunsigned int st = readl(port->membase + UART_STAT);\n\n\tif (st & (STAT_RX_RDY(port) | STAT_OVR_ERR | STAT_FRM_ERR |\n\t\t  STAT_BRK_DET))\n\t\tmvebu_uart_rx_chars(port, st);\n\n\tif (st & STAT_TX_RDY(port))\n\t\tmvebu_uart_tx_chars(port, st);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mvebu_uart_rx_isr(int irq, void *dev_id)\n{\n\tstruct uart_port *port = (struct uart_port *)dev_id;\n\tunsigned int st = readl(port->membase + UART_STAT);\n\n\tif (st & (STAT_RX_RDY(port) | STAT_OVR_ERR | STAT_FRM_ERR |\n\t\t\tSTAT_BRK_DET))\n\t\tmvebu_uart_rx_chars(port, st);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mvebu_uart_tx_isr(int irq, void *dev_id)\n{\n\tstruct uart_port *port = (struct uart_port *)dev_id;\n\tunsigned int st = readl(port->membase + UART_STAT);\n\n\tif (st & STAT_TX_RDY(port))\n\t\tmvebu_uart_tx_chars(port, st);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mvebu_uart_startup(struct uart_port *port)\n{\n\tstruct mvebu_uart *mvuart = to_mvuart(port);\n\tunsigned int ctl;\n\tint ret;\n\n\twritel(CTRL_TXFIFO_RST | CTRL_RXFIFO_RST,\n\t       port->membase + UART_CTRL(port));\n\tudelay(1);\n\n\t \n\tret = readl(port->membase + UART_STAT);\n\tret |= STAT_BRK_ERR;\n\twritel(ret, port->membase + UART_STAT);\n\n\twritel(CTRL_BRK_INT, port->membase + UART_CTRL(port));\n\n\tctl = readl(port->membase + UART_INTR(port));\n\tctl |= CTRL_RX_RDY_INT(port);\n\twritel(ctl, port->membase + UART_INTR(port));\n\n\tif (!mvuart->irq[UART_TX_IRQ]) {\n\t\t \n\t\tret = devm_request_irq(port->dev, mvuart->irq[UART_IRQ_SUM],\n\t\t\t\t       mvebu_uart_isr, port->irqflags,\n\t\t\t\t       dev_name(port->dev), port);\n\t\tif (ret) {\n\t\t\tdev_err(port->dev, \"unable to request IRQ %d\\n\",\n\t\t\t\tmvuart->irq[UART_IRQ_SUM]);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\tret = devm_request_irq(port->dev, mvuart->irq[UART_RX_IRQ],\n\t\t\t\t       mvebu_uart_rx_isr, port->irqflags,\n\t\t\t\t       dev_name(port->dev), port);\n\t\tif (ret) {\n\t\t\tdev_err(port->dev, \"unable to request IRQ %d\\n\",\n\t\t\t\tmvuart->irq[UART_RX_IRQ]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_request_irq(port->dev, mvuart->irq[UART_TX_IRQ],\n\t\t\t\t       mvebu_uart_tx_isr, port->irqflags,\n\t\t\t\t       dev_name(port->dev),\n\t\t\t\t       port);\n\t\tif (ret) {\n\t\t\tdev_err(port->dev, \"unable to request IRQ %d\\n\",\n\t\t\t\tmvuart->irq[UART_TX_IRQ]);\n\t\t\tdevm_free_irq(port->dev, mvuart->irq[UART_RX_IRQ],\n\t\t\t\t      port);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void mvebu_uart_shutdown(struct uart_port *port)\n{\n\tstruct mvebu_uart *mvuart = to_mvuart(port);\n\n\twritel(0, port->membase + UART_INTR(port));\n\n\tif (!mvuart->irq[UART_TX_IRQ]) {\n\t\tdevm_free_irq(port->dev, mvuart->irq[UART_IRQ_SUM], port);\n\t} else {\n\t\tdevm_free_irq(port->dev, mvuart->irq[UART_RX_IRQ], port);\n\t\tdevm_free_irq(port->dev, mvuart->irq[UART_TX_IRQ], port);\n\t}\n}\n\nstatic unsigned int mvebu_uart_baud_rate_set(struct uart_port *port, unsigned int baud)\n{\n\tunsigned int d_divisor, m_divisor;\n\tunsigned long flags;\n\tu32 brdv, osamp;\n\n\tif (!port->uartclk)\n\t\treturn 0;\n\n\t \n\n\tm_divisor = OSAMP_DEFAULT_DIVISOR;\n\td_divisor = DIV_ROUND_CLOSEST(port->uartclk, baud * m_divisor);\n\n\tif (d_divisor > BRDV_BAUD_MAX) {\n\t\t \n\t\tm_divisor = OSAMP_MAX_DIVISOR;\n\t\td_divisor = DIV_ROUND_CLOSEST(port->uartclk, baud * m_divisor);\n\t}\n\n\tif (d_divisor < 1)\n\t\td_divisor = 1;\n\telse if (d_divisor > BRDV_BAUD_MAX)\n\t\td_divisor = BRDV_BAUD_MAX;\n\n\tspin_lock_irqsave(&mvebu_uart_lock, flags);\n\tbrdv = readl(port->membase + UART_BRDV);\n\tbrdv &= ~BRDV_BAUD_MASK;\n\tbrdv |= d_divisor;\n\twritel(brdv, port->membase + UART_BRDV);\n\tspin_unlock_irqrestore(&mvebu_uart_lock, flags);\n\n\tosamp = readl(port->membase + UART_OSAMP);\n\tosamp &= ~OSAMP_DIVISORS_MASK;\n\tif (m_divisor != OSAMP_DEFAULT_DIVISOR)\n\t\tosamp |= (m_divisor << 0) | (m_divisor << 8) |\n\t\t\t(m_divisor << 16) | (m_divisor << 24);\n\twritel(osamp, port->membase + UART_OSAMP);\n\n\treturn DIV_ROUND_CLOSEST(port->uartclk, d_divisor * m_divisor);\n}\n\nstatic void mvebu_uart_set_termios(struct uart_port *port,\n\t\t\t\t   struct ktermios *termios,\n\t\t\t\t   const struct ktermios *old)\n{\n\tunsigned long flags;\n\tunsigned int baud, min_baud, max_baud;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tport->read_status_mask = STAT_RX_RDY(port) | STAT_OVR_ERR |\n\t\tSTAT_TX_RDY(port) | STAT_TX_FIFO_FUL;\n\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= STAT_FRM_ERR | STAT_PAR_ERR;\n\n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |=\n\t\t\tSTAT_FRM_ERR | STAT_PAR_ERR | STAT_OVR_ERR;\n\n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= STAT_RX_RDY(port) | STAT_BRK_ERR;\n\n\t \n\tmin_baud = DIV_ROUND_UP(port->uartclk, BRDV_BAUD_MAX *\n\t\t\t\tOSAMP_MAX_DIVISOR);\n\tmax_baud = port->uartclk / 80;\n\n\tbaud = uart_get_baud_rate(port, termios, old, min_baud, max_baud);\n\tbaud = mvebu_uart_baud_rate_set(port, baud);\n\n\t \n\tif (baud == 0 && old)\n\t\tbaud = tty_termios_baud_rate(old);\n\n\t \n\tif (old) {\n\t\ttermios->c_iflag &= INPCK | IGNPAR;\n\t\ttermios->c_iflag |= old->c_iflag & ~(INPCK | IGNPAR);\n\t\ttermios->c_cflag &= CREAD | CBAUD;\n\t\ttermios->c_cflag |= old->c_cflag & ~(CREAD | CBAUD);\n\t\ttermios->c_cflag |= CS8;\n\t}\n\n\tif (baud != 0) {\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\t\tuart_update_timeout(port, termios->c_cflag, baud);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *mvebu_uart_type(struct uart_port *port)\n{\n\treturn MVEBU_UART_TYPE;\n}\n\nstatic void mvebu_uart_release_port(struct uart_port *port)\n{\n\t \n}\n\nstatic int mvebu_uart_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int mvebu_uart_get_poll_char(struct uart_port *port)\n{\n\tunsigned int st = readl(port->membase + UART_STAT);\n\n\tif (!(st & STAT_RX_RDY(port)))\n\t\treturn NO_POLL_CHAR;\n\n\treturn readl(port->membase + UART_RBR(port));\n}\n\nstatic void mvebu_uart_put_poll_char(struct uart_port *port, unsigned char c)\n{\n\tunsigned int st;\n\n\tfor (;;) {\n\t\tst = readl(port->membase + UART_STAT);\n\n\t\tif (!(st & STAT_TX_FIFO_FUL))\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t}\n\n\twritel(c, port->membase + UART_TSH(port));\n}\n#endif\n\nstatic const struct uart_ops mvebu_uart_ops = {\n\t.tx_empty\t= mvebu_uart_tx_empty,\n\t.set_mctrl\t= mvebu_uart_set_mctrl,\n\t.get_mctrl\t= mvebu_uart_get_mctrl,\n\t.stop_tx\t= mvebu_uart_stop_tx,\n\t.start_tx\t= mvebu_uart_start_tx,\n\t.stop_rx\t= mvebu_uart_stop_rx,\n\t.break_ctl\t= mvebu_uart_break_ctl,\n\t.startup\t= mvebu_uart_startup,\n\t.shutdown\t= mvebu_uart_shutdown,\n\t.set_termios\t= mvebu_uart_set_termios,\n\t.type\t\t= mvebu_uart_type,\n\t.release_port\t= mvebu_uart_release_port,\n\t.request_port\t= mvebu_uart_request_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= mvebu_uart_get_poll_char,\n\t.poll_put_char\t= mvebu_uart_put_poll_char,\n#endif\n};\n\n \n\n#ifdef CONFIG_SERIAL_MVEBU_CONSOLE\n \nstatic void mvebu_uart_putc(struct uart_port *port, unsigned char c)\n{\n\tunsigned int st;\n\n\tfor (;;) {\n\t\tst = readl(port->membase + UART_STAT);\n\t\tif (!(st & STAT_TX_FIFO_FUL))\n\t\t\tbreak;\n\t}\n\n\t \n\twritel(c, port->membase + UART_STD_TSH);\n\n\tfor (;;) {\n\t\tst = readl(port->membase + UART_STAT);\n\t\tif (st & STAT_TX_FIFO_EMP)\n\t\t\tbreak;\n\t}\n}\n\nstatic void mvebu_uart_putc_early_write(struct console *con,\n\t\t\t\t\tconst char *s,\n\t\t\t\t\tunsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, mvebu_uart_putc);\n}\n\nstatic int __init\nmvebu_uart_early_console_setup(struct earlycon_device *device,\n\t\t\t       const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = mvebu_uart_putc_early_write;\n\n\treturn 0;\n}\n\nEARLYCON_DECLARE(ar3700_uart, mvebu_uart_early_console_setup);\nOF_EARLYCON_DECLARE(ar3700_uart, \"marvell,armada-3700-uart\",\n\t\t    mvebu_uart_early_console_setup);\n\nstatic void wait_for_xmitr(struct uart_port *port)\n{\n\tu32 val;\n\n\treadl_poll_timeout_atomic(port->membase + UART_STAT, val,\n\t\t\t\t  (val & STAT_TX_RDY(port)), 1, 10000);\n}\n\nstatic void wait_for_xmite(struct uart_port *port)\n{\n\tu32 val;\n\n\treadl_poll_timeout_atomic(port->membase + UART_STAT, val,\n\t\t\t\t  (val & STAT_TX_EMP), 1, 10000);\n}\n\nstatic void mvebu_uart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\twait_for_xmitr(port);\n\twritel(ch, port->membase + UART_TSH(port));\n}\n\nstatic void mvebu_uart_console_write(struct console *co, const char *s,\n\t\t\t\t     unsigned int count)\n{\n\tstruct uart_port *port = &mvebu_uart_ports[co->index];\n\tunsigned long flags;\n\tunsigned int ier, intr, ctl;\n\tint locked = 1;\n\n\tif (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&port->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&port->lock, flags);\n\n\tier = readl(port->membase + UART_CTRL(port)) & CTRL_BRK_INT;\n\tintr = readl(port->membase + UART_INTR(port)) &\n\t\t(CTRL_RX_RDY_INT(port) | CTRL_TX_RDY_INT(port));\n\twritel(0, port->membase + UART_CTRL(port));\n\twritel(0, port->membase + UART_INTR(port));\n\n\tuart_console_write(port, s, count, mvebu_uart_console_putchar);\n\n\twait_for_xmite(port);\n\n\tif (ier)\n\t\twritel(ier, port->membase + UART_CTRL(port));\n\n\tif (intr) {\n\t\tctl = intr | readl(port->membase + UART_INTR(port));\n\t\twritel(ctl, port->membase + UART_INTR(port));\n\t}\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic int mvebu_uart_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index < 0 || co->index >= MVEBU_NR_UARTS)\n\t\treturn -EINVAL;\n\n\tport = &mvebu_uart_ports[co->index];\n\n\tif (!port->mapbase || !port->membase) {\n\t\tpr_debug(\"console on ttyMV%i not present\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver mvebu_uart_driver;\n\nstatic struct console mvebu_uart_console = {\n\t.name\t= \"ttyMV\",\n\t.write\t= mvebu_uart_console_write,\n\t.device\t= uart_console_device,\n\t.setup\t= mvebu_uart_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,\n\t.data\t= &mvebu_uart_driver,\n};\n\nstatic int __init mvebu_uart_console_init(void)\n{\n\tregister_console(&mvebu_uart_console);\n\treturn 0;\n}\n\nconsole_initcall(mvebu_uart_console_init);\n\n\n#endif  \n\nstatic struct uart_driver mvebu_uart_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= DRIVER_NAME,\n\t.dev_name\t\t= \"ttyMV\",\n\t.nr\t\t\t= MVEBU_NR_UARTS,\n#ifdef CONFIG_SERIAL_MVEBU_CONSOLE\n\t.cons\t\t\t= &mvebu_uart_console,\n#endif\n};\n\n#if defined(CONFIG_PM)\nstatic int mvebu_uart_suspend(struct device *dev)\n{\n\tstruct mvebu_uart *mvuart = dev_get_drvdata(dev);\n\tstruct uart_port *port = mvuart->port;\n\tunsigned long flags;\n\n\tuart_suspend_port(&mvebu_uart_driver, port);\n\n\tmvuart->pm_regs.rbr = readl(port->membase + UART_RBR(port));\n\tmvuart->pm_regs.tsh = readl(port->membase + UART_TSH(port));\n\tmvuart->pm_regs.ctrl = readl(port->membase + UART_CTRL(port));\n\tmvuart->pm_regs.intr = readl(port->membase + UART_INTR(port));\n\tmvuart->pm_regs.stat = readl(port->membase + UART_STAT);\n\tspin_lock_irqsave(&mvebu_uart_lock, flags);\n\tmvuart->pm_regs.brdv = readl(port->membase + UART_BRDV);\n\tspin_unlock_irqrestore(&mvebu_uart_lock, flags);\n\tmvuart->pm_regs.osamp = readl(port->membase + UART_OSAMP);\n\n\tdevice_set_wakeup_enable(dev, true);\n\n\treturn 0;\n}\n\nstatic int mvebu_uart_resume(struct device *dev)\n{\n\tstruct mvebu_uart *mvuart = dev_get_drvdata(dev);\n\tstruct uart_port *port = mvuart->port;\n\tunsigned long flags;\n\n\twritel(mvuart->pm_regs.rbr, port->membase + UART_RBR(port));\n\twritel(mvuart->pm_regs.tsh, port->membase + UART_TSH(port));\n\twritel(mvuart->pm_regs.ctrl, port->membase + UART_CTRL(port));\n\twritel(mvuart->pm_regs.intr, port->membase + UART_INTR(port));\n\twritel(mvuart->pm_regs.stat, port->membase + UART_STAT);\n\tspin_lock_irqsave(&mvebu_uart_lock, flags);\n\twritel(mvuart->pm_regs.brdv, port->membase + UART_BRDV);\n\tspin_unlock_irqrestore(&mvebu_uart_lock, flags);\n\twritel(mvuart->pm_regs.osamp, port->membase + UART_OSAMP);\n\n\tuart_resume_port(&mvebu_uart_driver, port);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mvebu_uart_pm_ops = {\n\t.suspend        = mvebu_uart_suspend,\n\t.resume         = mvebu_uart_resume,\n};\n#endif  \n\nstatic const struct of_device_id mvebu_uart_of_match[];\n\n \nstatic int uart_num_counter;\n\nstatic int mvebu_uart_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match = of_match_device(mvebu_uart_of_match,\n\t\t\t\t\t\t\t   &pdev->dev);\n\tstruct uart_port *port;\n\tstruct mvebu_uart *mvuart;\n\tstruct resource *reg;\n\tint id, irq;\n\n\t \n\tid = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\tif (!pdev->dev.of_node || id < 0)\n\t\tpdev->id = uart_num_counter++;\n\telse\n\t\tpdev->id = id;\n\n\tif (pdev->id >= MVEBU_NR_UARTS) {\n\t\tdev_err(&pdev->dev, \"cannot have more than %d UART ports\\n\",\n\t\t\tMVEBU_NR_UARTS);\n\t\treturn -EINVAL;\n\t}\n\n\tport = &mvebu_uart_ports[pdev->id];\n\n\tspin_lock_init(&port->lock);\n\n\tport->dev        = &pdev->dev;\n\tport->type       = PORT_MVEBU;\n\tport->ops        = &mvebu_uart_ops;\n\tport->regshift   = 0;\n\n\tport->fifosize   = 32;\n\tport->iotype     = UPIO_MEM32;\n\tport->flags      = UPF_FIXED_PORT;\n\tport->line       = pdev->id;\n\n\t \n\tport->irq        = 0;\n\tport->irqflags   = 0;\n\n\tport->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &reg);\n\tif (IS_ERR(port->membase))\n\t\treturn PTR_ERR(port->membase);\n\tport->mapbase    = reg->start;\n\n\tmvuart = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_uart),\n\t\t\t      GFP_KERNEL);\n\tif (!mvuart)\n\t\treturn -ENOMEM;\n\n\t \n\tmvuart->data = (struct mvebu_uart_driver_data *)match->data;\n\tmvuart->port = port;\n\n\tport->private_data = mvuart;\n\tplatform_set_drvdata(pdev, mvuart);\n\n\t \n\tmvuart->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(mvuart->clk)) {\n\t\tif (PTR_ERR(mvuart->clk) == -EPROBE_DEFER)\n\t\t\treturn PTR_ERR(mvuart->clk);\n\n\t\tif (IS_EXTENDED(port)) {\n\t\t\tdev_err(&pdev->dev, \"unable to get UART clock\\n\");\n\t\t\treturn PTR_ERR(mvuart->clk);\n\t\t}\n\t} else {\n\t\tif (!clk_prepare_enable(mvuart->clk))\n\t\t\tport->uartclk = clk_get_rate(mvuart->clk);\n\t}\n\n\t \n\tif (platform_irq_count(pdev) == 1) {\n\t\t \n\t\tirq = platform_get_irq(pdev, 0);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tmvuart->irq[UART_IRQ_SUM] = irq;\n\t} else {\n\t\t \n\t\tirq = platform_get_irq_byname(pdev, \"uart-rx\");\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tmvuart->irq[UART_RX_IRQ] = irq;\n\n\t\tirq = platform_get_irq_byname(pdev, \"uart-tx\");\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tmvuart->irq[UART_TX_IRQ] = irq;\n\t}\n\n\t \n\twritel(CTRL_SOFT_RST, port->membase + UART_CTRL(port));\n\tudelay(1);\n\twritel(0, port->membase + UART_CTRL(port));\n\n\treturn uart_add_one_port(&mvebu_uart_driver, port);\n}\n\nstatic struct mvebu_uart_driver_data uart_std_driver_data = {\n\t.is_ext = false,\n\t.regs.rbr = UART_STD_RBR,\n\t.regs.tsh = UART_STD_TSH,\n\t.regs.ctrl = UART_STD_CTRL1,\n\t.regs.intr = UART_STD_CTRL2,\n\t.flags.ctrl_tx_rdy_int = CTRL_STD_TX_RDY_INT,\n\t.flags.ctrl_rx_rdy_int = CTRL_STD_RX_RDY_INT,\n\t.flags.stat_tx_rdy = STAT_STD_TX_RDY,\n\t.flags.stat_rx_rdy = STAT_STD_RX_RDY,\n};\n\nstatic struct mvebu_uart_driver_data uart_ext_driver_data = {\n\t.is_ext = true,\n\t.regs.rbr = UART_EXT_RBR,\n\t.regs.tsh = UART_EXT_TSH,\n\t.regs.ctrl = UART_EXT_CTRL1,\n\t.regs.intr = UART_EXT_CTRL2,\n\t.flags.ctrl_tx_rdy_int = CTRL_EXT_TX_RDY_INT,\n\t.flags.ctrl_rx_rdy_int = CTRL_EXT_RX_RDY_INT,\n\t.flags.stat_tx_rdy = STAT_EXT_TX_RDY,\n\t.flags.stat_rx_rdy = STAT_EXT_RX_RDY,\n};\n\n \nstatic const struct of_device_id mvebu_uart_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,armada-3700-uart\",\n\t\t.data = (void *)&uart_std_driver_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-3700-uart-ext\",\n\t\t.data = (void *)&uart_ext_driver_data,\n\t},\n\t{}\n};\n\nstatic struct platform_driver mvebu_uart_platform_driver = {\n\t.probe\t= mvebu_uart_probe,\n\t.driver\t= {\n\t\t.name  = \"mvebu-uart\",\n\t\t.of_match_table = of_match_ptr(mvebu_uart_of_match),\n\t\t.suppress_bind_attrs = true,\n#if defined(CONFIG_PM)\n\t\t.pm\t= &mvebu_uart_pm_ops,\n#endif  \n\t},\n};\n\n \n\nstruct mvebu_uart_clock {\n\tstruct clk_hw clk_hw;\n\tint clock_idx;\n\tu32 pm_context_reg1;\n\tu32 pm_context_reg2;\n};\n\nstruct mvebu_uart_clock_base {\n\tstruct mvebu_uart_clock clocks[2];\n\tunsigned int parent_rates[5];\n\tint parent_idx;\n\tunsigned int div;\n\tvoid __iomem *reg1;\n\tvoid __iomem *reg2;\n\tbool configured;\n};\n\n#define PARENT_CLOCK_XTAL 4\n\n#define to_uart_clock(hw) container_of(hw, struct mvebu_uart_clock, clk_hw)\n#define to_uart_clock_base(uart_clock) container_of(uart_clock, \\\n\tstruct mvebu_uart_clock_base, clocks[uart_clock->clock_idx])\n\nstatic int mvebu_uart_clock_prepare(struct clk_hw *hw)\n{\n\tstruct mvebu_uart_clock *uart_clock = to_uart_clock(hw);\n\tstruct mvebu_uart_clock_base *uart_clock_base =\n\t\t\t\t\t\tto_uart_clock_base(uart_clock);\n\tunsigned int prev_clock_idx, prev_clock_rate, prev_d1d2;\n\tunsigned int parent_clock_idx, parent_clock_rate;\n\tunsigned long flags;\n\tunsigned int d1, d2;\n\tu64 divisor;\n\tu32 val;\n\n\t \n\n\tspin_lock_irqsave(&mvebu_uart_lock, flags);\n\n\tif (uart_clock_base->configured) {\n\t\tspin_unlock_irqrestore(&mvebu_uart_lock, flags);\n\t\treturn 0;\n\t}\n\n\tparent_clock_idx = uart_clock_base->parent_idx;\n\tparent_clock_rate = uart_clock_base->parent_rates[parent_clock_idx];\n\n\tval = readl(uart_clock_base->reg1);\n\n\tif (uart_clock_base->div > CLK_TBG_DIV1_MAX) {\n\t\td1 = CLK_TBG_DIV1_MAX;\n\t\td2 = uart_clock_base->div / CLK_TBG_DIV1_MAX;\n\t} else {\n\t\td1 = uart_clock_base->div;\n\t\td2 = 1;\n\t}\n\n\tif (val & CLK_NO_XTAL) {\n\t\tprev_clock_idx = (val >> CLK_TBG_SEL_SHIFT) & CLK_TBG_SEL_MASK;\n\t\tprev_d1d2 = ((val >> CLK_TBG_DIV1_SHIFT) & CLK_TBG_DIV1_MASK) *\n\t\t\t    ((val >> CLK_TBG_DIV2_SHIFT) & CLK_TBG_DIV2_MASK);\n\t} else {\n\t\tprev_clock_idx = PARENT_CLOCK_XTAL;\n\t\tprev_d1d2 = 1;\n\t}\n\n\t \n\tprev_clock_rate = uart_clock_base->parent_rates[prev_clock_idx];\n\n\t \n\tif (prev_clock_rate) {\n\t\tdivisor = DIV_U64_ROUND_CLOSEST((u64)(val & BRDV_BAUD_MASK) *\n\t\t\t\t\t\tparent_clock_rate * prev_d1d2,\n\t\t\t\t\t\tprev_clock_rate * d1 * d2);\n\t\tif (divisor < 1)\n\t\t\tdivisor = 1;\n\t\telse if (divisor > BRDV_BAUD_MAX)\n\t\t\tdivisor = BRDV_BAUD_MAX;\n\t\tval = (val & ~BRDV_BAUD_MASK) | divisor;\n\t}\n\n\tif (parent_clock_idx != PARENT_CLOCK_XTAL) {\n\t\t \n\t\tval |= CLK_NO_XTAL;\n\t\tval &= ~(CLK_TBG_DIV1_MASK << CLK_TBG_DIV1_SHIFT);\n\t\tval |= d1 << CLK_TBG_DIV1_SHIFT;\n\t\tval &= ~(CLK_TBG_DIV2_MASK << CLK_TBG_DIV2_SHIFT);\n\t\tval |= d2 << CLK_TBG_DIV2_SHIFT;\n\t\tval &= ~(CLK_TBG_SEL_MASK << CLK_TBG_SEL_SHIFT);\n\t\tval |= parent_clock_idx << CLK_TBG_SEL_SHIFT;\n\t} else {\n\t\t \n\t\tval &= ~CLK_NO_XTAL;\n\t}\n\n\twritel(val, uart_clock_base->reg1);\n\n\t \n\tif (prev_clock_rate) {\n\t\tval = readl(uart_clock_base->reg2);\n\t\tdivisor = DIV_U64_ROUND_CLOSEST((u64)(val & BRDV_BAUD_MASK) *\n\t\t\t\t\t\tparent_clock_rate * prev_d1d2,\n\t\t\t\t\t\tprev_clock_rate * d1 * d2);\n\t\tif (divisor < 1)\n\t\t\tdivisor = 1;\n\t\telse if (divisor > BRDV_BAUD_MAX)\n\t\t\tdivisor = BRDV_BAUD_MAX;\n\t\tval = (val & ~BRDV_BAUD_MASK) | divisor;\n\t\twritel(val, uart_clock_base->reg2);\n\t}\n\n\tuart_clock_base->configured = true;\n\n\tspin_unlock_irqrestore(&mvebu_uart_lock, flags);\n\n\treturn 0;\n}\n\nstatic int mvebu_uart_clock_enable(struct clk_hw *hw)\n{\n\tstruct mvebu_uart_clock *uart_clock = to_uart_clock(hw);\n\tstruct mvebu_uart_clock_base *uart_clock_base =\n\t\t\t\t\t\tto_uart_clock_base(uart_clock);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&mvebu_uart_lock, flags);\n\n\tval = readl(uart_clock_base->reg1);\n\n\tif (uart_clock->clock_idx == 0)\n\t\tval &= ~UART1_CLK_DIS;\n\telse\n\t\tval &= ~UART2_CLK_DIS;\n\n\twritel(val, uart_clock_base->reg1);\n\n\tspin_unlock_irqrestore(&mvebu_uart_lock, flags);\n\n\treturn 0;\n}\n\nstatic void mvebu_uart_clock_disable(struct clk_hw *hw)\n{\n\tstruct mvebu_uart_clock *uart_clock = to_uart_clock(hw);\n\tstruct mvebu_uart_clock_base *uart_clock_base =\n\t\t\t\t\t\tto_uart_clock_base(uart_clock);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&mvebu_uart_lock, flags);\n\n\tval = readl(uart_clock_base->reg1);\n\n\tif (uart_clock->clock_idx == 0)\n\t\tval |= UART1_CLK_DIS;\n\telse\n\t\tval |= UART2_CLK_DIS;\n\n\twritel(val, uart_clock_base->reg1);\n\n\tspin_unlock_irqrestore(&mvebu_uart_lock, flags);\n}\n\nstatic int mvebu_uart_clock_is_enabled(struct clk_hw *hw)\n{\n\tstruct mvebu_uart_clock *uart_clock = to_uart_clock(hw);\n\tstruct mvebu_uart_clock_base *uart_clock_base =\n\t\t\t\t\t\tto_uart_clock_base(uart_clock);\n\tu32 val;\n\n\tval = readl(uart_clock_base->reg1);\n\n\tif (uart_clock->clock_idx == 0)\n\t\treturn !(val & UART1_CLK_DIS);\n\telse\n\t\treturn !(val & UART2_CLK_DIS);\n}\n\nstatic int mvebu_uart_clock_save_context(struct clk_hw *hw)\n{\n\tstruct mvebu_uart_clock *uart_clock = to_uart_clock(hw);\n\tstruct mvebu_uart_clock_base *uart_clock_base =\n\t\t\t\t\t\tto_uart_clock_base(uart_clock);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mvebu_uart_lock, flags);\n\tuart_clock->pm_context_reg1 = readl(uart_clock_base->reg1);\n\tuart_clock->pm_context_reg2 = readl(uart_clock_base->reg2);\n\tspin_unlock_irqrestore(&mvebu_uart_lock, flags);\n\n\treturn 0;\n}\n\nstatic void mvebu_uart_clock_restore_context(struct clk_hw *hw)\n{\n\tstruct mvebu_uart_clock *uart_clock = to_uart_clock(hw);\n\tstruct mvebu_uart_clock_base *uart_clock_base =\n\t\t\t\t\t\tto_uart_clock_base(uart_clock);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mvebu_uart_lock, flags);\n\twritel(uart_clock->pm_context_reg1, uart_clock_base->reg1);\n\twritel(uart_clock->pm_context_reg2, uart_clock_base->reg2);\n\tspin_unlock_irqrestore(&mvebu_uart_lock, flags);\n}\n\nstatic unsigned long mvebu_uart_clock_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct mvebu_uart_clock *uart_clock = to_uart_clock(hw);\n\tstruct mvebu_uart_clock_base *uart_clock_base =\n\t\t\t\t\t\tto_uart_clock_base(uart_clock);\n\n\treturn parent_rate / uart_clock_base->div;\n}\n\nstatic long mvebu_uart_clock_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long *parent_rate)\n{\n\tstruct mvebu_uart_clock *uart_clock = to_uart_clock(hw);\n\tstruct mvebu_uart_clock_base *uart_clock_base =\n\t\t\t\t\t\tto_uart_clock_base(uart_clock);\n\n\treturn *parent_rate / uart_clock_base->div;\n}\n\nstatic int mvebu_uart_clock_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\t \n\n\treturn 0;\n}\n\nstatic const struct clk_ops mvebu_uart_clock_ops = {\n\t.prepare = mvebu_uart_clock_prepare,\n\t.enable = mvebu_uart_clock_enable,\n\t.disable = mvebu_uart_clock_disable,\n\t.is_enabled = mvebu_uart_clock_is_enabled,\n\t.save_context = mvebu_uart_clock_save_context,\n\t.restore_context = mvebu_uart_clock_restore_context,\n\t.round_rate = mvebu_uart_clock_round_rate,\n\t.set_rate = mvebu_uart_clock_set_rate,\n\t.recalc_rate = mvebu_uart_clock_recalc_rate,\n};\n\nstatic int mvebu_uart_clock_register(struct device *dev,\n\t\t\t\t     struct mvebu_uart_clock *uart_clock,\n\t\t\t\t     const char *name,\n\t\t\t\t     const char *parent_name)\n{\n\tstruct clk_init_data init = { };\n\n\tuart_clock->clk_hw.init = &init;\n\n\tinit.name = name;\n\tinit.ops = &mvebu_uart_clock_ops;\n\tinit.flags = 0;\n\tinit.num_parents = 1;\n\tinit.parent_names = &parent_name;\n\n\treturn devm_clk_hw_register(dev, &uart_clock->clk_hw);\n}\n\nstatic int mvebu_uart_clock_probe(struct platform_device *pdev)\n{\n\tstatic const char *const uart_clk_names[] = { \"uart_1\", \"uart_2\" };\n\tstatic const char *const parent_clk_names[] = { \"TBG-A-P\", \"TBG-B-P\",\n\t\t\t\t\t\t\t\"TBG-A-S\", \"TBG-B-S\",\n\t\t\t\t\t\t\t\"xtal\" };\n\tstruct clk *parent_clks[ARRAY_SIZE(parent_clk_names)];\n\tstruct mvebu_uart_clock_base *uart_clock_base;\n\tstruct clk_hw_onecell_data *hw_clk_data;\n\tstruct device *dev = &pdev->dev;\n\tint i, parent_clk_idx, ret;\n\tunsigned long div, rate;\n\tstruct resource *res;\n\tunsigned int d1, d2;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(uart_clk_names) !=\n\t\t     ARRAY_SIZE(uart_clock_base->clocks));\n\tBUILD_BUG_ON(ARRAY_SIZE(parent_clk_names) !=\n\t\t     ARRAY_SIZE(uart_clock_base->parent_rates));\n\n\tuart_clock_base = devm_kzalloc(dev,\n\t\t\t\t       sizeof(*uart_clock_base),\n\t\t\t\t       GFP_KERNEL);\n\tif (!uart_clock_base)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"Couldn't get first register\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tuart_clock_base->reg1 = devm_ioremap(dev, res->start,\n\t\t\t\t\t     resource_size(res));\n\tif (!uart_clock_base->reg1)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res) {\n\t\tdev_err(dev, \"Couldn't get second register\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tuart_clock_base->reg2 = devm_ioremap(dev, res->start,\n\t\t\t\t\t     resource_size(res));\n\tif (!uart_clock_base->reg2)\n\t\treturn -ENOMEM;\n\n\thw_clk_data = devm_kzalloc(dev,\n\t\t\t\t   struct_size(hw_clk_data, hws,\n\t\t\t\t\t       ARRAY_SIZE(uart_clk_names)),\n\t\t\t\t   GFP_KERNEL);\n\tif (!hw_clk_data)\n\t\treturn -ENOMEM;\n\n\thw_clk_data->num = ARRAY_SIZE(uart_clk_names);\n\tfor (i = 0; i < ARRAY_SIZE(uart_clk_names); i++) {\n\t\thw_clk_data->hws[i] = &uart_clock_base->clocks[i].clk_hw;\n\t\tuart_clock_base->clocks[i].clock_idx = i;\n\t}\n\n\tparent_clk_idx = -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(parent_clk_names); i++) {\n\t\tparent_clks[i] = devm_clk_get(dev, parent_clk_names[i]);\n\t\tif (IS_ERR(parent_clks[i])) {\n\t\t\tif (PTR_ERR(parent_clks[i]) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\tdev_warn(dev, \"Couldn't get the parent clock %s: %ld\\n\",\n\t\t\t\t parent_clk_names[i], PTR_ERR(parent_clks[i]));\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = clk_prepare_enable(parent_clks[i]);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"Couldn't enable parent clock %s: %d\\n\",\n\t\t\t\t parent_clk_names[i], ret);\n\t\t\tcontinue;\n\t\t}\n\t\trate = clk_get_rate(parent_clks[i]);\n\t\tuart_clock_base->parent_rates[i] = rate;\n\n\t\tif (i != PARENT_CLOCK_XTAL) {\n\t\t\t \n\t\t\td1 = DIV_ROUND_UP(rate, 9600 * OSAMP_MAX_DIVISOR *\n\t\t\t\t\t  BRDV_BAUD_MAX);\n\t\t\tif (d1 < 1)\n\t\t\t\td1 = 1;\n\t\t\telse if (d1 > CLK_TBG_DIV1_MAX)\n\t\t\t\td1 = CLK_TBG_DIV1_MAX;\n\n\t\t\td2 = DIV_ROUND_UP(rate, 9600 * OSAMP_MAX_DIVISOR *\n\t\t\t\t\t  BRDV_BAUD_MAX * d1);\n\t\t\tif (d2 < 1)\n\t\t\t\td2 = 1;\n\t\t\telse if (d2 > CLK_TBG_DIV2_MAX)\n\t\t\t\td2 = CLK_TBG_DIV2_MAX;\n\t\t} else {\n\t\t\t \n\t\t\td1 = d2 = 1;\n\t\t}\n\n\t\t \n\t\tif (rate > 9600 * OSAMP_MAX_DIVISOR * BRDV_BAUD_MAX * d1 * d2)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (parent_clk_idx == -1 ||\n\t\t    (i != PARENT_CLOCK_XTAL && div > d1 * d2)) {\n\t\t\tparent_clk_idx = i;\n\t\t\tdiv = d1 * d2;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(parent_clk_names); i++) {\n\t\tif (i == parent_clk_idx || IS_ERR(parent_clks[i]))\n\t\t\tcontinue;\n\t\tclk_disable_unprepare(parent_clks[i]);\n\t\tdevm_clk_put(dev, parent_clks[i]);\n\t}\n\n\tif (parent_clk_idx == -1) {\n\t\tdev_err(dev, \"No usable parent clock\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tuart_clock_base->parent_idx = parent_clk_idx;\n\tuart_clock_base->div = div;\n\n\tdev_notice(dev, \"Using parent clock %s as base UART clock\\n\",\n\t\t   __clk_get_name(parent_clks[parent_clk_idx]));\n\n\tfor (i = 0; i < ARRAY_SIZE(uart_clk_names); i++) {\n\t\tret = mvebu_uart_clock_register(dev,\n\t\t\t\t&uart_clock_base->clocks[i],\n\t\t\t\tuart_clk_names[i],\n\t\t\t\t__clk_get_name(parent_clks[parent_clk_idx]));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Can't register UART clock %d: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get,\n\t\t\t\t\t   hw_clk_data);\n}\n\nstatic const struct of_device_id mvebu_uart_clock_of_match[] = {\n\t{ .compatible = \"marvell,armada-3700-uart-clock\", },\n\t{ }\n};\n\nstatic struct platform_driver mvebu_uart_clock_platform_driver = {\n\t.probe = mvebu_uart_clock_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"mvebu-uart-clock\",\n\t\t.of_match_table = mvebu_uart_clock_of_match,\n\t},\n};\n\nstatic int __init mvebu_uart_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&mvebu_uart_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&mvebu_uart_clock_platform_driver);\n\tif (ret) {\n\t\tuart_unregister_driver(&mvebu_uart_driver);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&mvebu_uart_platform_driver);\n\tif (ret) {\n\t\tplatform_driver_unregister(&mvebu_uart_clock_platform_driver);\n\t\tuart_unregister_driver(&mvebu_uart_driver);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\narch_initcall(mvebu_uart_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}