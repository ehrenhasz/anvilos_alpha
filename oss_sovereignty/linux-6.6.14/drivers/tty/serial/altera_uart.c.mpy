{
  "module_name": "altera_uart.c",
  "hash_id": "9568f615ea62a1c0b3a4b7db0a81cead41f302d211b2c991dc6453f76e12b95b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/altera_uart.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/altera_uart.h>\n\n#define DRV_NAME \"altera_uart\"\n#define SERIAL_ALTERA_MAJOR 204\n#define SERIAL_ALTERA_MINOR 213\n\n \n\n#define ALTERA_UART_SIZE\t\t32\n\n#define ALTERA_UART_RXDATA_REG\t\t0\n#define ALTERA_UART_TXDATA_REG\t\t4\n#define ALTERA_UART_STATUS_REG\t\t8\n#define ALTERA_UART_CONTROL_REG\t\t12\n#define ALTERA_UART_DIVISOR_REG\t\t16\n#define ALTERA_UART_EOP_REG\t\t20\n\n#define ALTERA_UART_STATUS_PE_MSK\t0x0001\t \n#define ALTERA_UART_STATUS_FE_MSK\t0x0002\t \n#define ALTERA_UART_STATUS_BRK_MSK\t0x0004\t \n#define ALTERA_UART_STATUS_ROE_MSK\t0x0008\t \n#define ALTERA_UART_STATUS_TOE_MSK\t0x0010\t \n#define ALTERA_UART_STATUS_TMT_MSK\t0x0020\t \n#define ALTERA_UART_STATUS_TRDY_MSK\t0x0040\t \n#define ALTERA_UART_STATUS_RRDY_MSK\t0x0080\t \n#define ALTERA_UART_STATUS_E_MSK\t0x0100\t \n#define ALTERA_UART_STATUS_DCTS_MSK\t0x0400\t \n#define ALTERA_UART_STATUS_CTS_MSK\t0x0800\t \n#define ALTERA_UART_STATUS_EOP_MSK\t0x1000\t \n\n\t\t\t\t\t\t \n#define ALTERA_UART_CONTROL_PE_MSK\t0x0001\t \n#define ALTERA_UART_CONTROL_FE_MSK\t0x0002\t \n#define ALTERA_UART_CONTROL_BRK_MSK\t0x0004\t \n#define ALTERA_UART_CONTROL_ROE_MSK\t0x0008\t \n#define ALTERA_UART_CONTROL_TOE_MSK\t0x0010\t \n#define ALTERA_UART_CONTROL_TMT_MSK\t0x0020\t \n#define ALTERA_UART_CONTROL_TRDY_MSK\t0x0040\t \n#define ALTERA_UART_CONTROL_RRDY_MSK\t0x0080\t \n#define ALTERA_UART_CONTROL_E_MSK\t0x0100\t \n\n#define ALTERA_UART_CONTROL_TRBK_MSK\t0x0200\t \n#define ALTERA_UART_CONTROL_DCTS_MSK\t0x0400\t \n#define ALTERA_UART_CONTROL_RTS_MSK\t0x0800\t \n#define ALTERA_UART_CONTROL_EOP_MSK\t0x1000\t \n\n \nstruct altera_uart {\n\tstruct uart_port port;\n\tstruct timer_list tmr;\n\tunsigned int sigs;\t \n\tunsigned short imr;\t \n};\n\nstatic u32 altera_uart_readl(struct uart_port *port, int reg)\n{\n\treturn readl(port->membase + (reg << port->regshift));\n}\n\nstatic void altera_uart_writel(struct uart_port *port, u32 dat, int reg)\n{\n\twritel(dat, port->membase + (reg << port->regshift));\n}\n\nstatic unsigned int altera_uart_tx_empty(struct uart_port *port)\n{\n\treturn (altera_uart_readl(port, ALTERA_UART_STATUS_REG) &\n\t\tALTERA_UART_STATUS_TMT_MSK) ? TIOCSER_TEMT : 0;\n}\n\nstatic unsigned int altera_uart_get_mctrl(struct uart_port *port)\n{\n\tstruct altera_uart *pp = container_of(port, struct altera_uart, port);\n\tunsigned int sigs;\n\n\tsigs = (altera_uart_readl(port, ALTERA_UART_STATUS_REG) &\n\t     ALTERA_UART_STATUS_CTS_MSK) ? TIOCM_CTS : 0;\n\tsigs |= (pp->sigs & TIOCM_RTS);\n\n\treturn sigs;\n}\n\nstatic void altera_uart_update_ctrl_reg(struct altera_uart *pp)\n{\n\tunsigned short imr = pp->imr;\n\n\t \n\tif (!pp->port.irq)\n\t\timr &= ALTERA_UART_CONTROL_TRBK_MSK | ALTERA_UART_CONTROL_RTS_MSK;\n\n\taltera_uart_writel(&pp->port, imr, ALTERA_UART_CONTROL_REG);\n}\n\nstatic void altera_uart_set_mctrl(struct uart_port *port, unsigned int sigs)\n{\n\tstruct altera_uart *pp = container_of(port, struct altera_uart, port);\n\n\tpp->sigs = sigs;\n\tif (sigs & TIOCM_RTS)\n\t\tpp->imr |= ALTERA_UART_CONTROL_RTS_MSK;\n\telse\n\t\tpp->imr &= ~ALTERA_UART_CONTROL_RTS_MSK;\n\taltera_uart_update_ctrl_reg(pp);\n}\n\nstatic void altera_uart_start_tx(struct uart_port *port)\n{\n\tstruct altera_uart *pp = container_of(port, struct altera_uart, port);\n\n\tpp->imr |= ALTERA_UART_CONTROL_TRDY_MSK;\n\taltera_uart_update_ctrl_reg(pp);\n}\n\nstatic void altera_uart_stop_tx(struct uart_port *port)\n{\n\tstruct altera_uart *pp = container_of(port, struct altera_uart, port);\n\n\tpp->imr &= ~ALTERA_UART_CONTROL_TRDY_MSK;\n\taltera_uart_update_ctrl_reg(pp);\n}\n\nstatic void altera_uart_stop_rx(struct uart_port *port)\n{\n\tstruct altera_uart *pp = container_of(port, struct altera_uart, port);\n\n\tpp->imr &= ~ALTERA_UART_CONTROL_RRDY_MSK;\n\taltera_uart_update_ctrl_reg(pp);\n}\n\nstatic void altera_uart_break_ctl(struct uart_port *port, int break_state)\n{\n\tstruct altera_uart *pp = container_of(port, struct altera_uart, port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (break_state == -1)\n\t\tpp->imr |= ALTERA_UART_CONTROL_TRBK_MSK;\n\telse\n\t\tpp->imr &= ~ALTERA_UART_CONTROL_TRBK_MSK;\n\taltera_uart_update_ctrl_reg(pp);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void altera_uart_set_termios(struct uart_port *port,\n\t\t\t\t    struct ktermios *termios,\n\t\t\t\t    const struct ktermios *old)\n{\n\tunsigned long flags;\n\tunsigned int baud, baudclk;\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, 4000000);\n\tbaudclk = port->uartclk / baud;\n\n\tif (old)\n\t\ttty_termios_copy_hw(termios, old);\n\ttty_termios_encode_baud_rate(termios, baud, baud);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\taltera_uart_writel(port, baudclk, ALTERA_UART_DIVISOR_REG);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n}\n\nstatic void altera_uart_rx_chars(struct uart_port *port)\n{\n\tunsigned short status;\n\tu8 ch, flag;\n\n\twhile ((status = altera_uart_readl(port, ALTERA_UART_STATUS_REG)) &\n\t       ALTERA_UART_STATUS_RRDY_MSK) {\n\t\tch = altera_uart_readl(port, ALTERA_UART_RXDATA_REG);\n\t\tflag = TTY_NORMAL;\n\t\tport->icount.rx++;\n\n\t\tif (status & ALTERA_UART_STATUS_E_MSK) {\n\t\t\taltera_uart_writel(port, status,\n\t\t\t\t\t   ALTERA_UART_STATUS_REG);\n\n\t\t\tif (status & ALTERA_UART_STATUS_BRK_MSK) {\n\t\t\t\tport->icount.brk++;\n\t\t\t\tif (uart_handle_break(port))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (status & ALTERA_UART_STATUS_PE_MSK) {\n\t\t\t\tport->icount.parity++;\n\t\t\t} else if (status & ALTERA_UART_STATUS_ROE_MSK) {\n\t\t\t\tport->icount.overrun++;\n\t\t\t} else if (status & ALTERA_UART_STATUS_FE_MSK) {\n\t\t\t\tport->icount.frame++;\n\t\t\t}\n\n\t\t\tstatus &= port->read_status_mask;\n\n\t\t\tif (status & ALTERA_UART_STATUS_BRK_MSK)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (status & ALTERA_UART_STATUS_PE_MSK)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (status & ALTERA_UART_STATUS_FE_MSK)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tcontinue;\n\t\tuart_insert_char(port, status, ALTERA_UART_STATUS_ROE_MSK, ch,\n\t\t\t\t flag);\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic void altera_uart_tx_chars(struct uart_port *port)\n{\n\tu8 ch;\n\n\tuart_port_tx(port, ch,\n\t\taltera_uart_readl(port, ALTERA_UART_STATUS_REG) &\n\t\t                ALTERA_UART_STATUS_TRDY_MSK,\n\t\taltera_uart_writel(port, ch, ALTERA_UART_TXDATA_REG));\n}\n\nstatic irqreturn_t altera_uart_interrupt(int irq, void *data)\n{\n\tstruct uart_port *port = data;\n\tstruct altera_uart *pp = container_of(port, struct altera_uart, port);\n\tunsigned long flags;\n\tunsigned int isr;\n\n\tisr = altera_uart_readl(port, ALTERA_UART_STATUS_REG) & pp->imr;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (isr & ALTERA_UART_STATUS_RRDY_MSK)\n\t\taltera_uart_rx_chars(port);\n\tif (isr & ALTERA_UART_STATUS_TRDY_MSK)\n\t\taltera_uart_tx_chars(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn IRQ_RETVAL(isr);\n}\n\nstatic void altera_uart_timer(struct timer_list *t)\n{\n\tstruct altera_uart *pp = from_timer(pp, t, tmr);\n\tstruct uart_port *port = &pp->port;\n\n\taltera_uart_interrupt(0, port);\n\tmod_timer(&pp->tmr, jiffies + uart_poll_timeout(port));\n}\n\nstatic void altera_uart_config_port(struct uart_port *port, int flags)\n{\n\tport->type = PORT_ALTERA_UART;\n\n\t \n\taltera_uart_writel(port, 0, ALTERA_UART_CONTROL_REG);\n\t \n\taltera_uart_writel(port, 0, ALTERA_UART_STATUS_REG);\n}\n\nstatic int altera_uart_startup(struct uart_port *port)\n{\n\tstruct altera_uart *pp = container_of(port, struct altera_uart, port);\n\tunsigned long flags;\n\n\tif (!port->irq) {\n\t\ttimer_setup(&pp->tmr, altera_uart_timer, 0);\n\t\tmod_timer(&pp->tmr, jiffies + uart_poll_timeout(port));\n\t} else {\n\t\tint ret;\n\n\t\tret = request_irq(port->irq, altera_uart_interrupt, 0,\n\t\t\t\tDRV_NAME, port);\n\t\tif (ret) {\n\t\t\tpr_err(DRV_NAME \": unable to attach Altera UART %d \"\n\t\t\t       \"interrupt vector=%d\\n\", port->line, port->irq);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tpp->imr = ALTERA_UART_CONTROL_RRDY_MSK;\n\taltera_uart_update_ctrl_reg(pp);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn 0;\n}\n\nstatic void altera_uart_shutdown(struct uart_port *port)\n{\n\tstruct altera_uart *pp = container_of(port, struct altera_uart, port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tpp->imr = 0;\n\taltera_uart_update_ctrl_reg(pp);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (port->irq)\n\t\tfree_irq(port->irq, port);\n\telse\n\t\tdel_timer_sync(&pp->tmr);\n}\n\nstatic const char *altera_uart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_ALTERA_UART) ? \"Altera UART\" : NULL;\n}\n\nstatic int altera_uart_request_port(struct uart_port *port)\n{\n\t \n\treturn 0;\n}\n\nstatic void altera_uart_release_port(struct uart_port *port)\n{\n\t \n}\n\nstatic int altera_uart_verify_port(struct uart_port *port,\n\t\t\t\t   struct serial_struct *ser)\n{\n\tif ((ser->type != PORT_UNKNOWN) && (ser->type != PORT_ALTERA_UART))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n#ifdef CONFIG_CONSOLE_POLL\nstatic int altera_uart_poll_get_char(struct uart_port *port)\n{\n\twhile (!(altera_uart_readl(port, ALTERA_UART_STATUS_REG) &\n\t\t ALTERA_UART_STATUS_RRDY_MSK))\n\t\tcpu_relax();\n\n\treturn altera_uart_readl(port, ALTERA_UART_RXDATA_REG);\n}\n\nstatic void altera_uart_poll_put_char(struct uart_port *port, unsigned char c)\n{\n\twhile (!(altera_uart_readl(port, ALTERA_UART_STATUS_REG) &\n\t\t ALTERA_UART_STATUS_TRDY_MSK))\n\t\tcpu_relax();\n\n\taltera_uart_writel(port, c, ALTERA_UART_TXDATA_REG);\n}\n#endif\n\n \nstatic const struct uart_ops altera_uart_ops = {\n\t.tx_empty\t= altera_uart_tx_empty,\n\t.get_mctrl\t= altera_uart_get_mctrl,\n\t.set_mctrl\t= altera_uart_set_mctrl,\n\t.start_tx\t= altera_uart_start_tx,\n\t.stop_tx\t= altera_uart_stop_tx,\n\t.stop_rx\t= altera_uart_stop_rx,\n\t.break_ctl\t= altera_uart_break_ctl,\n\t.startup\t= altera_uart_startup,\n\t.shutdown\t= altera_uart_shutdown,\n\t.set_termios\t= altera_uart_set_termios,\n\t.type\t\t= altera_uart_type,\n\t.request_port\t= altera_uart_request_port,\n\t.release_port\t= altera_uart_release_port,\n\t.config_port\t= altera_uart_config_port,\n\t.verify_port\t= altera_uart_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char\t= altera_uart_poll_get_char,\n\t.poll_put_char\t= altera_uart_poll_put_char,\n#endif\n};\n\nstatic struct altera_uart altera_uart_ports[CONFIG_SERIAL_ALTERA_UART_MAXPORTS];\n\n#if defined(CONFIG_SERIAL_ALTERA_UART_CONSOLE)\n\nstatic void altera_uart_console_putc(struct uart_port *port, unsigned char c)\n{\n\twhile (!(altera_uart_readl(port, ALTERA_UART_STATUS_REG) &\n\t\t ALTERA_UART_STATUS_TRDY_MSK))\n\t\tcpu_relax();\n\n\taltera_uart_writel(port, c, ALTERA_UART_TXDATA_REG);\n}\n\nstatic void altera_uart_console_write(struct console *co, const char *s,\n\t\t\t\t      unsigned int count)\n{\n\tstruct uart_port *port = &(altera_uart_ports + co->index)->port;\n\n\tuart_console_write(port, s, count, altera_uart_console_putc);\n}\n\nstatic int __init altera_uart_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint baud = CONFIG_SERIAL_ALTERA_UART_BAUDRATE;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index < 0 || co->index >= CONFIG_SERIAL_ALTERA_UART_MAXPORTS)\n\t\treturn -EINVAL;\n\tport = &altera_uart_ports[co->index].port;\n\tif (!port->membase)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver altera_uart_driver;\n\nstatic struct console altera_uart_console = {\n\t.name\t= \"ttyAL\",\n\t.write\t= altera_uart_console_write,\n\t.device\t= uart_console_device,\n\t.setup\t= altera_uart_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,\n\t.data\t= &altera_uart_driver,\n};\n\nstatic int __init altera_uart_console_init(void)\n{\n\tregister_console(&altera_uart_console);\n\treturn 0;\n}\n\nconsole_initcall(altera_uart_console_init);\n\n#define\tALTERA_UART_CONSOLE\t(&altera_uart_console)\n\nstatic void altera_uart_earlycon_write(struct console *co, const char *s,\n\t\t\t\t       unsigned int count)\n{\n\tstruct earlycon_device *dev = co->data;\n\n\tuart_console_write(&dev->port, s, count, altera_uart_console_putc);\n}\n\nstatic int __init altera_uart_earlycon_setup(struct earlycon_device *dev,\n\t\t\t\t\t     const char *options)\n{\n\tstruct uart_port *port = &dev->port;\n\n\tif (!port->membase)\n\t\treturn -ENODEV;\n\n\t \n\taltera_uart_writel(port, ALTERA_UART_CONTROL_RRDY_MSK,\n\t\t\t   ALTERA_UART_CONTROL_REG);\n\n\tif (dev->baud) {\n\t\tunsigned int baudclk = port->uartclk / dev->baud;\n\n\t\taltera_uart_writel(port, baudclk, ALTERA_UART_DIVISOR_REG);\n\t}\n\n\tdev->con->write = altera_uart_earlycon_write;\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(uart, \"altr,uart-1.0\", altera_uart_earlycon_setup);\n\n#else\n\n#define\tALTERA_UART_CONSOLE\tNULL\n\n#endif  \n\n \nstatic struct uart_driver altera_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= DRV_NAME,\n\t.dev_name\t= \"ttyAL\",\n\t.major\t\t= SERIAL_ALTERA_MAJOR,\n\t.minor\t\t= SERIAL_ALTERA_MINOR,\n\t.nr\t\t= CONFIG_SERIAL_ALTERA_UART_MAXPORTS,\n\t.cons\t\t= ALTERA_UART_CONSOLE,\n};\n\nstatic int altera_uart_probe(struct platform_device *pdev)\n{\n\tstruct altera_uart_platform_uart *platp = dev_get_platdata(&pdev->dev);\n\tstruct uart_port *port;\n\tstruct resource *res_mem;\n\tint i = pdev->id;\n\tint ret;\n\n\t \n\tif (i == -1) {\n\t\tfor (i = 0; i < CONFIG_SERIAL_ALTERA_UART_MAXPORTS; i++)\n\t\t\tif (altera_uart_ports[i].port.mapbase == 0)\n\t\t\t\tbreak;\n\t}\n\n\tif (i < 0 || i >= CONFIG_SERIAL_ALTERA_UART_MAXPORTS)\n\t\treturn -EINVAL;\n\n\tport = &altera_uart_ports[i].port;\n\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res_mem)\n\t\tport->mapbase = res_mem->start;\n\telse if (platp)\n\t\tport->mapbase = platp->mapbase;\n\telse\n\t\treturn -EINVAL;\n\n\tret = platform_get_irq_optional(pdev, 0);\n\tif (ret < 0 && ret != -ENXIO)\n\t\treturn ret;\n\tif (ret > 0)\n\t\tport->irq = ret;\n\telse if (platp)\n\t\tport->irq = platp->irq;\n\n\t \n\tif (platp)\n\t\tport->uartclk = platp->uartclk;\n\telse {\n\t\tret = of_property_read_u32(pdev->dev.of_node, \"clock-frequency\",\n\t\t\t\t\t   &port->uartclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tport->membase = ioremap(port->mapbase, ALTERA_UART_SIZE);\n\tif (!port->membase)\n\t\treturn -ENOMEM;\n\n\tif (platp)\n\t\tport->regshift = platp->bus_shift;\n\telse\n\t\tport->regshift = 0;\n\n\tport->line = i;\n\tport->type = PORT_ALTERA_UART;\n\tport->iotype = SERIAL_IO_MEM;\n\tport->ops = &altera_uart_ops;\n\tport->flags = UPF_BOOT_AUTOCONF;\n\tport->dev = &pdev->dev;\n\n\tplatform_set_drvdata(pdev, port);\n\n\tuart_add_one_port(&altera_uart_driver, port);\n\n\treturn 0;\n}\n\nstatic int altera_uart_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = platform_get_drvdata(pdev);\n\n\tif (port) {\n\t\tuart_remove_one_port(&altera_uart_driver, port);\n\t\tport->mapbase = 0;\n\t\tiounmap(port->membase);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id altera_uart_match[] = {\n\t{ .compatible = \"ALTR,uart-1.0\", },\n\t{ .compatible = \"altr,uart-1.0\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altera_uart_match);\n#endif  \n\nstatic struct platform_driver altera_uart_platform_driver = {\n\t.probe\t= altera_uart_probe,\n\t.remove\t= altera_uart_remove,\n\t.driver\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= of_match_ptr(altera_uart_match),\n\t},\n};\n\nstatic int __init altera_uart_init(void)\n{\n\tint rc;\n\n\trc = uart_register_driver(&altera_uart_driver);\n\tif (rc)\n\t\treturn rc;\n\trc = platform_driver_register(&altera_uart_platform_driver);\n\tif (rc)\n\t\tuart_unregister_driver(&altera_uart_driver);\n\treturn rc;\n}\n\nstatic void __exit altera_uart_exit(void)\n{\n\tplatform_driver_unregister(&altera_uart_platform_driver);\n\tuart_unregister_driver(&altera_uart_driver);\n}\n\nmodule_init(altera_uart_init);\nmodule_exit(altera_uart_exit);\n\nMODULE_DESCRIPTION(\"Altera UART driver\");\nMODULE_AUTHOR(\"Thomas Chou <thomas@wytron.com.tw>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_ALIAS_CHARDEV_MAJOR(SERIAL_ALTERA_MAJOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}