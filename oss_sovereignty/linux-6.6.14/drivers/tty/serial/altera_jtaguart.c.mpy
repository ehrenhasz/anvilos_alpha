{
  "module_name": "altera_jtaguart.c",
  "hash_id": "c032a4f9a045eadfec090841408cf180b97b4b053c1790d4e665dc40e1e75e36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/altera_jtaguart.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/of.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/altera_jtaguart.h>\n\n#define DRV_NAME \"altera_jtaguart\"\n\n \n\n#define ALTERA_JTAGUART_SIZE\t\t\t8\n\n#define ALTERA_JTAGUART_DATA_REG\t\t0\n\n#define ALTERA_JTAGUART_DATA_DATA_MSK\t\t0x000000FF\n#define ALTERA_JTAGUART_DATA_RVALID_MSK\t\t0x00008000\n#define ALTERA_JTAGUART_DATA_RAVAIL_MSK\t\t0xFFFF0000\n#define ALTERA_JTAGUART_DATA_RAVAIL_OFF\t\t16\n\n#define ALTERA_JTAGUART_CONTROL_REG\t\t4\n\n#define ALTERA_JTAGUART_CONTROL_RE_MSK\t\t0x00000001\n#define ALTERA_JTAGUART_CONTROL_WE_MSK\t\t0x00000002\n#define ALTERA_JTAGUART_CONTROL_RI_MSK\t\t0x00000100\n#define ALTERA_JTAGUART_CONTROL_RI_OFF\t\t8\n#define ALTERA_JTAGUART_CONTROL_WI_MSK\t\t0x00000200\n#define ALTERA_JTAGUART_CONTROL_AC_MSK\t\t0x00000400\n#define ALTERA_JTAGUART_CONTROL_WSPACE_MSK\t0xFFFF0000\n\nstatic unsigned int altera_jtaguart_tx_space(struct uart_port *port, u32 *ctlp)\n{\n\tu32 ctl = readl(port->membase + ALTERA_JTAGUART_CONTROL_REG);\n\n\tif (ctlp)\n\t\t*ctlp = ctl;\n\n\treturn FIELD_GET(ALTERA_JTAGUART_CONTROL_WSPACE_MSK, ctl);\n}\n\nstatic unsigned int altera_jtaguart_tx_empty(struct uart_port *port)\n{\n\treturn altera_jtaguart_tx_space(port, NULL) ? TIOCSER_TEMT : 0;\n}\n\nstatic unsigned int altera_jtaguart_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\n}\n\nstatic void altera_jtaguart_set_mctrl(struct uart_port *port, unsigned int sigs)\n{\n}\n\nstatic void altera_jtaguart_start_tx(struct uart_port *port)\n{\n\tport->read_status_mask |= ALTERA_JTAGUART_CONTROL_WE_MSK;\n\twritel(port->read_status_mask,\n\t\t\tport->membase + ALTERA_JTAGUART_CONTROL_REG);\n}\n\nstatic void altera_jtaguart_stop_tx(struct uart_port *port)\n{\n\tport->read_status_mask &= ~ALTERA_JTAGUART_CONTROL_WE_MSK;\n\twritel(port->read_status_mask,\n\t\t\tport->membase + ALTERA_JTAGUART_CONTROL_REG);\n}\n\nstatic void altera_jtaguart_stop_rx(struct uart_port *port)\n{\n\tport->read_status_mask &= ~ALTERA_JTAGUART_CONTROL_RE_MSK;\n\twritel(port->read_status_mask,\n\t\t\tport->membase + ALTERA_JTAGUART_CONTROL_REG);\n}\n\nstatic void altera_jtaguart_break_ctl(struct uart_port *port, int break_state)\n{\n}\n\nstatic void altera_jtaguart_set_termios(struct uart_port *port,\n\t\t\t\t        struct ktermios *termios,\n\t\t\t\t        const struct ktermios *old)\n{\n\t \n\tif (old)\n\t\ttty_termios_copy_hw(termios, old);\n}\n\nstatic void altera_jtaguart_rx_chars(struct uart_port *port)\n{\n\tu32 status;\n\tu8 ch;\n\n\twhile ((status = readl(port->membase + ALTERA_JTAGUART_DATA_REG)) &\n\t       ALTERA_JTAGUART_DATA_RVALID_MSK) {\n\t\tch = status & ALTERA_JTAGUART_DATA_DATA_MSK;\n\t\tport->icount.rx++;\n\n\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\tcontinue;\n\t\tuart_insert_char(port, 0, 0, ch, TTY_NORMAL);\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic void altera_jtaguart_tx_chars(struct uart_port *port)\n{\n\tunsigned int count;\n\tu8 ch;\n\n\tcount = altera_jtaguart_tx_space(port, NULL);\n\n\tuart_port_tx_limited(port, ch, count,\n\t\ttrue,\n\t\twritel(ch, port->membase + ALTERA_JTAGUART_DATA_REG),\n\t\t({}));\n}\n\nstatic irqreturn_t altera_jtaguart_interrupt(int irq, void *data)\n{\n\tstruct uart_port *port = data;\n\tunsigned int isr;\n\n\tisr = (readl(port->membase + ALTERA_JTAGUART_CONTROL_REG) >>\n\t       ALTERA_JTAGUART_CONTROL_RI_OFF) & port->read_status_mask;\n\n\tspin_lock(&port->lock);\n\n\tif (isr & ALTERA_JTAGUART_CONTROL_RE_MSK)\n\t\taltera_jtaguart_rx_chars(port);\n\tif (isr & ALTERA_JTAGUART_CONTROL_WE_MSK)\n\t\taltera_jtaguart_tx_chars(port);\n\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_RETVAL(isr);\n}\n\nstatic void altera_jtaguart_config_port(struct uart_port *port, int flags)\n{\n\tport->type = PORT_ALTERA_JTAGUART;\n\n\t \n\twritel(0, port->membase + ALTERA_JTAGUART_CONTROL_REG);\n}\n\nstatic int altera_jtaguart_startup(struct uart_port *port)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tret = request_irq(port->irq, altera_jtaguart_interrupt, 0,\n\t\t\tDRV_NAME, port);\n\tif (ret) {\n\t\tpr_err(DRV_NAME \": unable to attach Altera JTAG UART %d \"\n\t\t       \"interrupt vector=%d\\n\", port->line, port->irq);\n\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tport->read_status_mask = ALTERA_JTAGUART_CONTROL_RE_MSK;\n\twritel(port->read_status_mask,\n\t\t\tport->membase + ALTERA_JTAGUART_CONTROL_REG);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn 0;\n}\n\nstatic void altera_jtaguart_shutdown(struct uart_port *port)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tport->read_status_mask = 0;\n\twritel(port->read_status_mask,\n\t\t\tport->membase + ALTERA_JTAGUART_CONTROL_REG);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tfree_irq(port->irq, port);\n}\n\nstatic const char *altera_jtaguart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_ALTERA_JTAGUART) ? \"Altera JTAG UART\" : NULL;\n}\n\nstatic int altera_jtaguart_request_port(struct uart_port *port)\n{\n\t \n\treturn 0;\n}\n\nstatic void altera_jtaguart_release_port(struct uart_port *port)\n{\n\t \n}\n\nstatic int altera_jtaguart_verify_port(struct uart_port *port,\n\t\t\t\t       struct serial_struct *ser)\n{\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_ALTERA_JTAGUART)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic const struct uart_ops altera_jtaguart_ops = {\n\t.tx_empty\t= altera_jtaguart_tx_empty,\n\t.get_mctrl\t= altera_jtaguart_get_mctrl,\n\t.set_mctrl\t= altera_jtaguart_set_mctrl,\n\t.start_tx\t= altera_jtaguart_start_tx,\n\t.stop_tx\t= altera_jtaguart_stop_tx,\n\t.stop_rx\t= altera_jtaguart_stop_rx,\n\t.break_ctl\t= altera_jtaguart_break_ctl,\n\t.startup\t= altera_jtaguart_startup,\n\t.shutdown\t= altera_jtaguart_shutdown,\n\t.set_termios\t= altera_jtaguart_set_termios,\n\t.type\t\t= altera_jtaguart_type,\n\t.request_port\t= altera_jtaguart_request_port,\n\t.release_port\t= altera_jtaguart_release_port,\n\t.config_port\t= altera_jtaguart_config_port,\n\t.verify_port\t= altera_jtaguart_verify_port,\n};\n\n#define ALTERA_JTAGUART_MAXPORTS 1\nstatic struct uart_port altera_jtaguart_ports[ALTERA_JTAGUART_MAXPORTS];\n\n#if defined(CONFIG_SERIAL_ALTERA_JTAGUART_CONSOLE)\n\n#if defined(CONFIG_SERIAL_ALTERA_JTAGUART_CONSOLE_BYPASS)\nstatic void altera_jtaguart_console_putc(struct uart_port *port, unsigned char c)\n{\n\tunsigned long flags;\n\tu32 status;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\twhile (!altera_jtaguart_tx_space(port, &status)) {\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\tif ((status & ALTERA_JTAGUART_CONTROL_AC_MSK) == 0) {\n\t\t\treturn;\t \n\t\t}\n\n\t\tcpu_relax();\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t}\n\twritel(c, port->membase + ALTERA_JTAGUART_DATA_REG);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n#else\nstatic void altera_jtaguart_console_putc(struct uart_port *port, unsigned char c)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\twhile (!altera_jtaguart_tx_space(port, NULL)) {\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tcpu_relax();\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t}\n\twritel(c, port->membase + ALTERA_JTAGUART_DATA_REG);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n#endif\n\nstatic void altera_jtaguart_console_write(struct console *co, const char *s,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct uart_port *port = &altera_jtaguart_ports[co->index];\n\n\tuart_console_write(port, s, count, altera_jtaguart_console_putc);\n}\n\nstatic int __init altera_jtaguart_console_setup(struct console *co,\n\t\t\t\t\t\tchar *options)\n{\n\tstruct uart_port *port;\n\n\tif (co->index < 0 || co->index >= ALTERA_JTAGUART_MAXPORTS)\n\t\treturn -EINVAL;\n\tport = &altera_jtaguart_ports[co->index];\n\tif (port->membase == NULL)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic struct uart_driver altera_jtaguart_driver;\n\nstatic struct console altera_jtaguart_console = {\n\t.name\t= \"ttyJ\",\n\t.write\t= altera_jtaguart_console_write,\n\t.device\t= uart_console_device,\n\t.setup\t= altera_jtaguart_console_setup,\n\t.flags\t= CON_PRINTBUFFER,\n\t.index\t= -1,\n\t.data\t= &altera_jtaguart_driver,\n};\n\nstatic int __init altera_jtaguart_console_init(void)\n{\n\tregister_console(&altera_jtaguart_console);\n\treturn 0;\n}\n\nconsole_initcall(altera_jtaguart_console_init);\n\n#define\tALTERA_JTAGUART_CONSOLE\t(&altera_jtaguart_console)\n\nstatic void altera_jtaguart_earlycon_write(struct console *co, const char *s,\n\t\t\t\t\t   unsigned int count)\n{\n\tstruct earlycon_device *dev = co->data;\n\n\tuart_console_write(&dev->port, s, count, altera_jtaguart_console_putc);\n}\n\nstatic int __init altera_jtaguart_earlycon_setup(struct earlycon_device *dev,\n\t\t\t\t\t\t const char *options)\n{\n\tif (!dev->port.membase)\n\t\treturn -ENODEV;\n\n\tdev->con->write = altera_jtaguart_earlycon_write;\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(juart, \"altr,juart-1.0\", altera_jtaguart_earlycon_setup);\n\n#else\n\n#define\tALTERA_JTAGUART_CONSOLE\tNULL\n\n#endif  \n\nstatic struct uart_driver altera_jtaguart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"altera_jtaguart\",\n\t.dev_name\t= \"ttyJ\",\n\t.major\t\t= ALTERA_JTAGUART_MAJOR,\n\t.minor\t\t= ALTERA_JTAGUART_MINOR,\n\t.nr\t\t= ALTERA_JTAGUART_MAXPORTS,\n\t.cons\t\t= ALTERA_JTAGUART_CONSOLE,\n};\n\nstatic int altera_jtaguart_probe(struct platform_device *pdev)\n{\n\tstruct altera_jtaguart_platform_uart *platp =\n\t\t\tdev_get_platdata(&pdev->dev);\n\tstruct uart_port *port;\n\tstruct resource *res_mem;\n\tint i = pdev->id;\n\tint irq;\n\n\t \n\tif (i == -1)\n\t\ti = 0;\n\n\tif (i >= ALTERA_JTAGUART_MAXPORTS)\n\t\treturn -EINVAL;\n\n\tport = &altera_jtaguart_ports[i];\n\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res_mem)\n\t\tport->mapbase = res_mem->start;\n\telse if (platp)\n\t\tport->mapbase = platp->mapbase;\n\telse\n\t\treturn -ENODEV;\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq < 0 && irq != -ENXIO)\n\t\treturn irq;\n\tif (irq > 0)\n\t\tport->irq = irq;\n\telse if (platp)\n\t\tport->irq = platp->irq;\n\telse\n\t\treturn -ENODEV;\n\n\tport->membase = ioremap(port->mapbase, ALTERA_JTAGUART_SIZE);\n\tif (!port->membase)\n\t\treturn -ENOMEM;\n\n\tport->line = i;\n\tport->type = PORT_ALTERA_JTAGUART;\n\tport->iotype = SERIAL_IO_MEM;\n\tport->ops = &altera_jtaguart_ops;\n\tport->flags = UPF_BOOT_AUTOCONF;\n\tport->dev = &pdev->dev;\n\n\tuart_add_one_port(&altera_jtaguart_driver, port);\n\n\treturn 0;\n}\n\nstatic int altera_jtaguart_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port;\n\tint i = pdev->id;\n\n\tif (i == -1)\n\t\ti = 0;\n\n\tport = &altera_jtaguart_ports[i];\n\tuart_remove_one_port(&altera_jtaguart_driver, port);\n\tiounmap(port->membase);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id altera_jtaguart_match[] = {\n\t{ .compatible = \"ALTR,juart-1.0\", },\n\t{ .compatible = \"altr,juart-1.0\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altera_jtaguart_match);\n#endif  \n\nstatic struct platform_driver altera_jtaguart_platform_driver = {\n\t.probe\t= altera_jtaguart_probe,\n\t.remove\t= altera_jtaguart_remove,\n\t.driver\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= of_match_ptr(altera_jtaguart_match),\n\t},\n};\n\nstatic int __init altera_jtaguart_init(void)\n{\n\tint rc;\n\n\trc = uart_register_driver(&altera_jtaguart_driver);\n\tif (rc)\n\t\treturn rc;\n\trc = platform_driver_register(&altera_jtaguart_platform_driver);\n\tif (rc)\n\t\tuart_unregister_driver(&altera_jtaguart_driver);\n\treturn rc;\n}\n\nstatic void __exit altera_jtaguart_exit(void)\n{\n\tplatform_driver_unregister(&altera_jtaguart_platform_driver);\n\tuart_unregister_driver(&altera_jtaguart_driver);\n}\n\nmodule_init(altera_jtaguart_init);\nmodule_exit(altera_jtaguart_exit);\n\nMODULE_DESCRIPTION(\"Altera JTAG UART driver\");\nMODULE_AUTHOR(\"Thomas Chou <thomas@wytron.com.tw>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}