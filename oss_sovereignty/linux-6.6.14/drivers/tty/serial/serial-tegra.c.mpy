{
  "module_name": "serial-tegra.c",
  "hash_id": "195eb79d734f5e74e595b1ebaf188d2d688d0fcdd0f8a1716b74ad92ab65d171",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/serial-tegra.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pagemap.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/serial.h>\n#include <linux/serial_8250.h>\n#include <linux/serial_core.h>\n#include <linux/serial_reg.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/termios.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#define TEGRA_UART_TYPE\t\t\t\t\"TEGRA_UART\"\n#define TX_EMPTY_STATUS\t\t\t\t(UART_LSR_TEMT | UART_LSR_THRE)\n#define BYTES_TO_ALIGN(x)\t\t\t((unsigned long)(x) & 0x3)\n\n#define TEGRA_UART_RX_DMA_BUFFER_SIZE\t\t4096\n#define TEGRA_UART_LSR_TXFIFO_FULL\t\t0x100\n#define TEGRA_UART_IER_EORD\t\t\t0x20\n#define TEGRA_UART_MCR_RTS_EN\t\t\t0x40\n#define TEGRA_UART_MCR_CTS_EN\t\t\t0x20\n#define TEGRA_UART_LSR_ANY\t\t\t(UART_LSR_OE | UART_LSR_BI | \\\n\t\t\t\t\t\tUART_LSR_PE | UART_LSR_FE)\n#define TEGRA_UART_IRDA_CSR\t\t\t0x08\n#define TEGRA_UART_SIR_ENABLED\t\t\t0x80\n\n#define TEGRA_UART_TX_PIO\t\t\t1\n#define TEGRA_UART_TX_DMA\t\t\t2\n#define TEGRA_UART_MIN_DMA\t\t\t16\n#define TEGRA_UART_FIFO_SIZE\t\t\t32\n\n \n#define TEGRA_UART_TX_TRIG_16B\t\t\t0x00\n#define TEGRA_UART_TX_TRIG_8B\t\t\t0x10\n#define TEGRA_UART_TX_TRIG_4B\t\t\t0x20\n#define TEGRA_UART_TX_TRIG_1B\t\t\t0x30\n\n#define TEGRA_UART_MAXIMUM\t\t\t8\n\n \n#define TEGRA_UART_DEFAULT_BAUD\t\t\t115200\n#define TEGRA_UART_DEFAULT_LSR\t\t\tUART_LCR_WLEN8\n\n \n#define TEGRA_TX_PIO\t\t\t\t1\n#define TEGRA_TX_DMA\t\t\t\t2\n\n#define TEGRA_UART_FCR_IIR_FIFO_EN\t\t0x40\n\n \nstruct tegra_uart_chip_data {\n\tbool\ttx_fifo_full_status;\n\tbool\tallow_txfifo_reset_fifo_mode;\n\tbool\tsupport_clk_src_div;\n\tbool\tfifo_mode_enable_status;\n\tint\tuart_max_port;\n\tint\tmax_dma_burst_bytes;\n\tint\terror_tolerance_low_range;\n\tint\terror_tolerance_high_range;\n};\n\nstruct tegra_baud_tolerance {\n\tu32 lower_range_baud;\n\tu32 upper_range_baud;\n\ts32 tolerance;\n};\n\nstruct tegra_uart_port {\n\tstruct uart_port\t\t\tuport;\n\tconst struct tegra_uart_chip_data\t*cdata;\n\n\tstruct clk\t\t\t\t*uart_clk;\n\tstruct reset_control\t\t\t*rst;\n\tunsigned int\t\t\t\tcurrent_baud;\n\n\t \n\tunsigned long\t\t\t\tfcr_shadow;\n\tunsigned long\t\t\t\tmcr_shadow;\n\tunsigned long\t\t\t\tlcr_shadow;\n\tunsigned long\t\t\t\tier_shadow;\n\tbool\t\t\t\t\trts_active;\n\n\tint\t\t\t\t\ttx_in_progress;\n\tunsigned int\t\t\t\ttx_bytes;\n\n\tbool\t\t\t\t\tenable_modem_interrupt;\n\n\tbool\t\t\t\t\trx_timeout;\n\tint\t\t\t\t\trx_in_progress;\n\tint\t\t\t\t\tsymb_bit;\n\n\tstruct dma_chan\t\t\t\t*rx_dma_chan;\n\tstruct dma_chan\t\t\t\t*tx_dma_chan;\n\tdma_addr_t\t\t\t\trx_dma_buf_phys;\n\tdma_addr_t\t\t\t\ttx_dma_buf_phys;\n\tunsigned char\t\t\t\t*rx_dma_buf_virt;\n\tunsigned char\t\t\t\t*tx_dma_buf_virt;\n\tstruct dma_async_tx_descriptor\t\t*tx_dma_desc;\n\tstruct dma_async_tx_descriptor\t\t*rx_dma_desc;\n\tdma_cookie_t\t\t\t\ttx_cookie;\n\tdma_cookie_t\t\t\t\trx_cookie;\n\tunsigned int\t\t\t\ttx_bytes_requested;\n\tunsigned int\t\t\t\trx_bytes_requested;\n\tstruct tegra_baud_tolerance\t\t*baud_tolerance;\n\tint\t\t\t\t\tn_adjustable_baud_rates;\n\tint\t\t\t\t\trequired_rate;\n\tint\t\t\t\t\tconfigured_rate;\n\tbool\t\t\t\t\tuse_rx_pio;\n\tbool\t\t\t\t\tuse_tx_pio;\n\tbool\t\t\t\t\trx_dma_active;\n};\n\nstatic void tegra_uart_start_next_tx(struct tegra_uart_port *tup);\nstatic int tegra_uart_start_rx_dma(struct tegra_uart_port *tup);\nstatic void tegra_uart_dma_channel_free(struct tegra_uart_port *tup,\n\t\t\t\t\tbool dma_to_memory);\n\nstatic inline unsigned long tegra_uart_read(struct tegra_uart_port *tup,\n\t\tunsigned long reg)\n{\n\treturn readl(tup->uport.membase + (reg << tup->uport.regshift));\n}\n\nstatic inline void tegra_uart_write(struct tegra_uart_port *tup, unsigned val,\n\tunsigned long reg)\n{\n\twritel(val, tup->uport.membase + (reg << tup->uport.regshift));\n}\n\nstatic inline struct tegra_uart_port *to_tegra_uport(struct uart_port *u)\n{\n\treturn container_of(u, struct tegra_uart_port, uport);\n}\n\nstatic unsigned int tegra_uart_get_mctrl(struct uart_port *u)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\n\t \n\tif (tup->enable_modem_interrupt)\n\t\treturn TIOCM_RI | TIOCM_CD | TIOCM_DSR | TIOCM_CTS;\n\treturn TIOCM_CTS;\n}\n\nstatic void set_rts(struct tegra_uart_port *tup, bool active)\n{\n\tunsigned long mcr;\n\n\tmcr = tup->mcr_shadow;\n\tif (active)\n\t\tmcr |= TEGRA_UART_MCR_RTS_EN;\n\telse\n\t\tmcr &= ~TEGRA_UART_MCR_RTS_EN;\n\tif (mcr != tup->mcr_shadow) {\n\t\ttegra_uart_write(tup, mcr, UART_MCR);\n\t\ttup->mcr_shadow = mcr;\n\t}\n}\n\nstatic void set_dtr(struct tegra_uart_port *tup, bool active)\n{\n\tunsigned long mcr;\n\n\tmcr = tup->mcr_shadow;\n\tif (active)\n\t\tmcr |= UART_MCR_DTR;\n\telse\n\t\tmcr &= ~UART_MCR_DTR;\n\tif (mcr != tup->mcr_shadow) {\n\t\ttegra_uart_write(tup, mcr, UART_MCR);\n\t\ttup->mcr_shadow = mcr;\n\t}\n}\n\nstatic void set_loopbk(struct tegra_uart_port *tup, bool active)\n{\n\tunsigned long mcr = tup->mcr_shadow;\n\n\tif (active)\n\t\tmcr |= UART_MCR_LOOP;\n\telse\n\t\tmcr &= ~UART_MCR_LOOP;\n\n\tif (mcr != tup->mcr_shadow) {\n\t\ttegra_uart_write(tup, mcr, UART_MCR);\n\t\ttup->mcr_shadow = mcr;\n\t}\n}\n\nstatic void tegra_uart_set_mctrl(struct uart_port *u, unsigned int mctrl)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\tint enable;\n\n\ttup->rts_active = !!(mctrl & TIOCM_RTS);\n\tset_rts(tup, tup->rts_active);\n\n\tenable = !!(mctrl & TIOCM_DTR);\n\tset_dtr(tup, enable);\n\n\tenable = !!(mctrl & TIOCM_LOOP);\n\tset_loopbk(tup, enable);\n}\n\nstatic void tegra_uart_break_ctl(struct uart_port *u, int break_ctl)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\tunsigned long lcr;\n\n\tlcr = tup->lcr_shadow;\n\tif (break_ctl)\n\t\tlcr |= UART_LCR_SBC;\n\telse\n\t\tlcr &= ~UART_LCR_SBC;\n\ttegra_uart_write(tup, lcr, UART_LCR);\n\ttup->lcr_shadow = lcr;\n}\n\n \nstatic void tegra_uart_wait_cycle_time(struct tegra_uart_port *tup,\n\t\t\t\t       unsigned int cycles)\n{\n\tif (tup->current_baud)\n\t\tudelay(DIV_ROUND_UP(cycles * 1000000, tup->current_baud * 16));\n}\n\n \nstatic void tegra_uart_wait_sym_time(struct tegra_uart_port *tup,\n\t\tunsigned int syms)\n{\n\tif (tup->current_baud)\n\t\tudelay(DIV_ROUND_UP(syms * tup->symb_bit * 1000000,\n\t\t\ttup->current_baud));\n}\n\nstatic int tegra_uart_wait_fifo_mode_enabled(struct tegra_uart_port *tup)\n{\n\tunsigned long iir;\n\tunsigned int tmout = 100;\n\n\tdo {\n\t\tiir = tegra_uart_read(tup, UART_IIR);\n\t\tif (iir & TEGRA_UART_FCR_IIR_FIFO_EN)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t} while (--tmout);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void tegra_uart_fifo_reset(struct tegra_uart_port *tup, u8 fcr_bits)\n{\n\tunsigned long fcr = tup->fcr_shadow;\n\tunsigned int lsr, tmout = 10000;\n\n\tif (tup->rts_active)\n\t\tset_rts(tup, false);\n\n\tif (tup->cdata->allow_txfifo_reset_fifo_mode) {\n\t\tfcr |= fcr_bits & (UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\t\ttegra_uart_write(tup, fcr, UART_FCR);\n\t} else {\n\t\tfcr &= ~UART_FCR_ENABLE_FIFO;\n\t\ttegra_uart_write(tup, fcr, UART_FCR);\n\t\tudelay(60);\n\t\tfcr |= fcr_bits & (UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\t\ttegra_uart_write(tup, fcr, UART_FCR);\n\t\tfcr |= UART_FCR_ENABLE_FIFO;\n\t\ttegra_uart_write(tup, fcr, UART_FCR);\n\t\tif (tup->cdata->fifo_mode_enable_status)\n\t\t\ttegra_uart_wait_fifo_mode_enabled(tup);\n\t}\n\n\t \n\ttegra_uart_read(tup, UART_SCR);\n\n\t \n\ttegra_uart_wait_cycle_time(tup, 32);\n\n\tdo {\n\t\tlsr = tegra_uart_read(tup, UART_LSR);\n\t\tif ((lsr & UART_LSR_TEMT) && !(lsr & UART_LSR_DR))\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (--tmout);\n\n\tif (tup->rts_active)\n\t\tset_rts(tup, true);\n}\n\nstatic long tegra_get_tolerance_rate(struct tegra_uart_port *tup,\n\t\t\t\t     unsigned int baud, long rate)\n{\n\tint i;\n\n\tfor (i = 0; i < tup->n_adjustable_baud_rates; ++i) {\n\t\tif (baud >= tup->baud_tolerance[i].lower_range_baud &&\n\t\t    baud <= tup->baud_tolerance[i].upper_range_baud)\n\t\t\treturn (rate + (rate *\n\t\t\t\ttup->baud_tolerance[i].tolerance) / 10000);\n\t}\n\n\treturn rate;\n}\n\nstatic int tegra_check_rate_in_range(struct tegra_uart_port *tup)\n{\n\tlong diff;\n\n\tdiff = ((long)(tup->configured_rate - tup->required_rate) * 10000)\n\t\t/ tup->required_rate;\n\tif (diff < (tup->cdata->error_tolerance_low_range * 100) ||\n\t    diff > (tup->cdata->error_tolerance_high_range * 100)) {\n\t\tdev_err(tup->uport.dev,\n\t\t\t\"configured baud rate is out of range by %ld\", diff);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_set_baudrate(struct tegra_uart_port *tup, unsigned int baud)\n{\n\tunsigned long rate;\n\tunsigned int divisor;\n\tunsigned long lcr;\n\tunsigned long flags;\n\tint ret;\n\n\tif (tup->current_baud == baud)\n\t\treturn 0;\n\n\tif (tup->cdata->support_clk_src_div) {\n\t\trate = baud * 16;\n\t\ttup->required_rate = rate;\n\n\t\tif (tup->n_adjustable_baud_rates)\n\t\t\trate = tegra_get_tolerance_rate(tup, baud, rate);\n\n\t\tret = clk_set_rate(tup->uart_clk, rate);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tup->uport.dev,\n\t\t\t\t\"clk_set_rate() failed for rate %lu\\n\", rate);\n\t\t\treturn ret;\n\t\t}\n\t\ttup->configured_rate = clk_get_rate(tup->uart_clk);\n\t\tdivisor = 1;\n\t\tret = tegra_check_rate_in_range(tup);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\trate = clk_get_rate(tup->uart_clk);\n\t\tdivisor = DIV_ROUND_CLOSEST(rate, baud * 16);\n\t}\n\n\tspin_lock_irqsave(&tup->uport.lock, flags);\n\tlcr = tup->lcr_shadow;\n\tlcr |= UART_LCR_DLAB;\n\ttegra_uart_write(tup, lcr, UART_LCR);\n\n\ttegra_uart_write(tup, divisor & 0xFF, UART_TX);\n\ttegra_uart_write(tup, ((divisor >> 8) & 0xFF), UART_IER);\n\n\tlcr &= ~UART_LCR_DLAB;\n\ttegra_uart_write(tup, lcr, UART_LCR);\n\n\t \n\ttegra_uart_read(tup, UART_SCR);\n\tspin_unlock_irqrestore(&tup->uport.lock, flags);\n\n\ttup->current_baud = baud;\n\n\t \n\ttegra_uart_wait_sym_time(tup, 2);\n\treturn 0;\n}\n\nstatic u8 tegra_uart_decode_rx_error(struct tegra_uart_port *tup,\n\t\t\tunsigned long lsr)\n{\n\tu8 flag = TTY_NORMAL;\n\n\tif (unlikely(lsr & TEGRA_UART_LSR_ANY)) {\n\t\tif (lsr & UART_LSR_OE) {\n\t\t\t \n\t\t\tflag = TTY_OVERRUN;\n\t\t\ttup->uport.icount.overrun++;\n\t\t\tdev_dbg(tup->uport.dev, \"Got overrun errors\\n\");\n\t\t} else if (lsr & UART_LSR_PE) {\n\t\t\t \n\t\t\tflag = TTY_PARITY;\n\t\t\ttup->uport.icount.parity++;\n\t\t\tdev_dbg(tup->uport.dev, \"Got Parity errors\\n\");\n\t\t} else if (lsr & UART_LSR_FE) {\n\t\t\tflag = TTY_FRAME;\n\t\t\ttup->uport.icount.frame++;\n\t\t\tdev_dbg(tup->uport.dev, \"Got frame errors\\n\");\n\t\t} else if (lsr & UART_LSR_BI) {\n\t\t\t \n\t\t\tif (!(lsr & UART_LSR_DR) && (lsr & UART_LSR_FIFOE))\n\t\t\t\ttegra_uart_fifo_reset(tup, UART_FCR_CLEAR_RCVR);\n\t\t\tif (tup->uport.ignore_status_mask & UART_LSR_BI)\n\t\t\t\treturn TTY_BREAK;\n\t\t\tflag = TTY_BREAK;\n\t\t\ttup->uport.icount.brk++;\n\t\t\tdev_dbg(tup->uport.dev, \"Got Break\\n\");\n\t\t}\n\t\tuart_insert_char(&tup->uport, lsr, UART_LSR_OE, 0, flag);\n\t}\n\n\treturn flag;\n}\n\nstatic int tegra_uart_request_port(struct uart_port *u)\n{\n\treturn 0;\n}\n\nstatic void tegra_uart_release_port(struct uart_port *u)\n{\n\t \n}\n\nstatic void tegra_uart_fill_tx_fifo(struct tegra_uart_port *tup, int max_bytes)\n{\n\tstruct circ_buf *xmit = &tup->uport.state->xmit;\n\tint i;\n\n\tfor (i = 0; i < max_bytes; i++) {\n\t\tBUG_ON(uart_circ_empty(xmit));\n\t\tif (tup->cdata->tx_fifo_full_status) {\n\t\t\tunsigned long lsr = tegra_uart_read(tup, UART_LSR);\n\t\t\tif ((lsr & TEGRA_UART_LSR_TXFIFO_FULL))\n\t\t\t\tbreak;\n\t\t}\n\t\ttegra_uart_write(tup, xmit->buf[xmit->tail], UART_TX);\n\t\tuart_xmit_advance(&tup->uport, 1);\n\t}\n}\n\nstatic void tegra_uart_start_pio_tx(struct tegra_uart_port *tup,\n\t\tunsigned int bytes)\n{\n\tif (bytes > TEGRA_UART_MIN_DMA)\n\t\tbytes = TEGRA_UART_MIN_DMA;\n\n\ttup->tx_in_progress = TEGRA_UART_TX_PIO;\n\ttup->tx_bytes = bytes;\n\ttup->ier_shadow |= UART_IER_THRI;\n\ttegra_uart_write(tup, tup->ier_shadow, UART_IER);\n}\n\nstatic void tegra_uart_tx_dma_complete(void *args)\n{\n\tstruct tegra_uart_port *tup = args;\n\tstruct circ_buf *xmit = &tup->uport.state->xmit;\n\tstruct dma_tx_state state;\n\tunsigned long flags;\n\tunsigned int count;\n\n\tdmaengine_tx_status(tup->tx_dma_chan, tup->tx_cookie, &state);\n\tcount = tup->tx_bytes_requested - state.residue;\n\tasync_tx_ack(tup->tx_dma_desc);\n\tspin_lock_irqsave(&tup->uport.lock, flags);\n\tuart_xmit_advance(&tup->uport, count);\n\ttup->tx_in_progress = 0;\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&tup->uport);\n\ttegra_uart_start_next_tx(tup);\n\tspin_unlock_irqrestore(&tup->uport.lock, flags);\n}\n\nstatic int tegra_uart_start_tx_dma(struct tegra_uart_port *tup,\n\t\tunsigned long count)\n{\n\tstruct circ_buf *xmit = &tup->uport.state->xmit;\n\tdma_addr_t tx_phys_addr;\n\n\ttup->tx_bytes = count & ~(0xF);\n\ttx_phys_addr = tup->tx_dma_buf_phys + xmit->tail;\n\n\tdma_sync_single_for_device(tup->uport.dev, tx_phys_addr,\n\t\t\t\t   tup->tx_bytes, DMA_TO_DEVICE);\n\n\ttup->tx_dma_desc = dmaengine_prep_slave_single(tup->tx_dma_chan,\n\t\t\t\ttx_phys_addr, tup->tx_bytes, DMA_MEM_TO_DEV,\n\t\t\t\tDMA_PREP_INTERRUPT);\n\tif (!tup->tx_dma_desc) {\n\t\tdev_err(tup->uport.dev, \"Not able to get desc for Tx\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttup->tx_dma_desc->callback = tegra_uart_tx_dma_complete;\n\ttup->tx_dma_desc->callback_param = tup;\n\ttup->tx_in_progress = TEGRA_UART_TX_DMA;\n\ttup->tx_bytes_requested = tup->tx_bytes;\n\ttup->tx_cookie = dmaengine_submit(tup->tx_dma_desc);\n\tdma_async_issue_pending(tup->tx_dma_chan);\n\treturn 0;\n}\n\nstatic void tegra_uart_start_next_tx(struct tegra_uart_port *tup)\n{\n\tunsigned long tail;\n\tunsigned long count;\n\tstruct circ_buf *xmit = &tup->uport.state->xmit;\n\n\tif (!tup->current_baud)\n\t\treturn;\n\n\ttail = (unsigned long)&xmit->buf[xmit->tail];\n\tcount = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\n\tif (!count)\n\t\treturn;\n\n\tif (tup->use_tx_pio || count < TEGRA_UART_MIN_DMA)\n\t\ttegra_uart_start_pio_tx(tup, count);\n\telse if (BYTES_TO_ALIGN(tail) > 0)\n\t\ttegra_uart_start_pio_tx(tup, BYTES_TO_ALIGN(tail));\n\telse\n\t\ttegra_uart_start_tx_dma(tup, count);\n}\n\n \nstatic void tegra_uart_start_tx(struct uart_port *u)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\tstruct circ_buf *xmit = &u->state->xmit;\n\n\tif (!uart_circ_empty(xmit) && !tup->tx_in_progress)\n\t\ttegra_uart_start_next_tx(tup);\n}\n\nstatic unsigned int tegra_uart_tx_empty(struct uart_port *u)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\tunsigned int ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&u->lock, flags);\n\tif (!tup->tx_in_progress) {\n\t\tunsigned long lsr = tegra_uart_read(tup, UART_LSR);\n\t\tif ((lsr & TX_EMPTY_STATUS) == TX_EMPTY_STATUS)\n\t\t\tret = TIOCSER_TEMT;\n\t}\n\tspin_unlock_irqrestore(&u->lock, flags);\n\treturn ret;\n}\n\nstatic void tegra_uart_stop_tx(struct uart_port *u)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\tstruct dma_tx_state state;\n\tunsigned int count;\n\n\tif (tup->tx_in_progress != TEGRA_UART_TX_DMA)\n\t\treturn;\n\n\tdmaengine_pause(tup->tx_dma_chan);\n\tdmaengine_tx_status(tup->tx_dma_chan, tup->tx_cookie, &state);\n\tdmaengine_terminate_all(tup->tx_dma_chan);\n\tcount = tup->tx_bytes_requested - state.residue;\n\tasync_tx_ack(tup->tx_dma_desc);\n\tuart_xmit_advance(&tup->uport, count);\n\ttup->tx_in_progress = 0;\n}\n\nstatic void tegra_uart_handle_tx_pio(struct tegra_uart_port *tup)\n{\n\tstruct circ_buf *xmit = &tup->uport.state->xmit;\n\n\ttegra_uart_fill_tx_fifo(tup, tup->tx_bytes);\n\ttup->tx_in_progress = 0;\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(&tup->uport);\n\ttegra_uart_start_next_tx(tup);\n}\n\nstatic void tegra_uart_handle_rx_pio(struct tegra_uart_port *tup,\n\t\tstruct tty_port *port)\n{\n\tdo {\n\t\tunsigned long lsr = 0;\n\t\tu8 ch, flag = TTY_NORMAL;\n\n\t\tlsr = tegra_uart_read(tup, UART_LSR);\n\t\tif (!(lsr & UART_LSR_DR))\n\t\t\tbreak;\n\n\t\tflag = tegra_uart_decode_rx_error(tup, lsr);\n\t\tif (flag != TTY_NORMAL)\n\t\t\tcontinue;\n\n\t\tch = (unsigned char) tegra_uart_read(tup, UART_RX);\n\t\ttup->uport.icount.rx++;\n\n\t\tif (uart_handle_sysrq_char(&tup->uport, ch))\n\t\t\tcontinue;\n\n\t\tif (tup->uport.ignore_status_mask & UART_LSR_DR)\n\t\t\tcontinue;\n\n\t\ttty_insert_flip_char(port, ch, flag);\n\t} while (1);\n}\n\nstatic void tegra_uart_copy_rx_to_tty(struct tegra_uart_port *tup,\n\t\t\t\t      struct tty_port *port,\n\t\t\t\t      unsigned int count)\n{\n\tint copied;\n\n\t \n\tif (!count)\n\t\treturn;\n\n\ttup->uport.icount.rx += count;\n\n\tif (tup->uport.ignore_status_mask & UART_LSR_DR)\n\t\treturn;\n\n\tdma_sync_single_for_cpu(tup->uport.dev, tup->rx_dma_buf_phys,\n\t\t\t\tcount, DMA_FROM_DEVICE);\n\tcopied = tty_insert_flip_string(port,\n\t\t\t((unsigned char *)(tup->rx_dma_buf_virt)), count);\n\tif (copied != count) {\n\t\tWARN_ON(1);\n\t\tdev_err(tup->uport.dev, \"RxData copy to tty layer failed\\n\");\n\t}\n\tdma_sync_single_for_device(tup->uport.dev, tup->rx_dma_buf_phys,\n\t\t\t\t   count, DMA_TO_DEVICE);\n}\n\nstatic void do_handle_rx_pio(struct tegra_uart_port *tup)\n{\n\tstruct tty_struct *tty = tty_port_tty_get(&tup->uport.state->port);\n\tstruct tty_port *port = &tup->uport.state->port;\n\n\ttegra_uart_handle_rx_pio(tup, port);\n\tif (tty) {\n\t\ttty_flip_buffer_push(port);\n\t\ttty_kref_put(tty);\n\t}\n}\n\nstatic void tegra_uart_rx_buffer_push(struct tegra_uart_port *tup,\n\t\t\t\t      unsigned int residue)\n{\n\tstruct tty_port *port = &tup->uport.state->port;\n\tunsigned int count;\n\n\tasync_tx_ack(tup->rx_dma_desc);\n\tcount = tup->rx_bytes_requested - residue;\n\n\t \n\ttegra_uart_copy_rx_to_tty(tup, port, count);\n\n\tdo_handle_rx_pio(tup);\n}\n\nstatic void tegra_uart_rx_dma_complete(void *args)\n{\n\tstruct tegra_uart_port *tup = args;\n\tstruct uart_port *u = &tup->uport;\n\tunsigned long flags;\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\n\tspin_lock_irqsave(&u->lock, flags);\n\n\tstatus = dmaengine_tx_status(tup->rx_dma_chan, tup->rx_cookie, &state);\n\n\tif (status == DMA_IN_PROGRESS) {\n\t\tdev_dbg(tup->uport.dev, \"RX DMA is in progress\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tif (tup->rts_active)\n\t\tset_rts(tup, false);\n\n\ttup->rx_dma_active = false;\n\ttegra_uart_rx_buffer_push(tup, 0);\n\ttegra_uart_start_rx_dma(tup);\n\n\t \n\tif (tup->rts_active)\n\t\tset_rts(tup, true);\n\ndone:\n\tspin_unlock_irqrestore(&u->lock, flags);\n}\n\nstatic void tegra_uart_terminate_rx_dma(struct tegra_uart_port *tup)\n{\n\tstruct dma_tx_state state;\n\n\tif (!tup->rx_dma_active) {\n\t\tdo_handle_rx_pio(tup);\n\t\treturn;\n\t}\n\n\tdmaengine_pause(tup->rx_dma_chan);\n\tdmaengine_tx_status(tup->rx_dma_chan, tup->rx_cookie, &state);\n\tdmaengine_terminate_all(tup->rx_dma_chan);\n\n\ttegra_uart_rx_buffer_push(tup, state.residue);\n\ttup->rx_dma_active = false;\n}\n\nstatic void tegra_uart_handle_rx_dma(struct tegra_uart_port *tup)\n{\n\t \n\tif (tup->rts_active)\n\t\tset_rts(tup, false);\n\n\ttegra_uart_terminate_rx_dma(tup);\n\n\tif (tup->rts_active)\n\t\tset_rts(tup, true);\n}\n\nstatic int tegra_uart_start_rx_dma(struct tegra_uart_port *tup)\n{\n\tunsigned int count = TEGRA_UART_RX_DMA_BUFFER_SIZE;\n\n\tif (tup->rx_dma_active)\n\t\treturn 0;\n\n\ttup->rx_dma_desc = dmaengine_prep_slave_single(tup->rx_dma_chan,\n\t\t\t\ttup->rx_dma_buf_phys, count, DMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT);\n\tif (!tup->rx_dma_desc) {\n\t\tdev_err(tup->uport.dev, \"Not able to get desc for Rx\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttup->rx_dma_active = true;\n\ttup->rx_dma_desc->callback = tegra_uart_rx_dma_complete;\n\ttup->rx_dma_desc->callback_param = tup;\n\ttup->rx_bytes_requested = count;\n\ttup->rx_cookie = dmaengine_submit(tup->rx_dma_desc);\n\tdma_async_issue_pending(tup->rx_dma_chan);\n\treturn 0;\n}\n\nstatic void tegra_uart_handle_modem_signal_change(struct uart_port *u)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\tunsigned long msr;\n\n\tmsr = tegra_uart_read(tup, UART_MSR);\n\tif (!(msr & UART_MSR_ANY_DELTA))\n\t\treturn;\n\n\tif (msr & UART_MSR_TERI)\n\t\ttup->uport.icount.rng++;\n\tif (msr & UART_MSR_DDSR)\n\t\ttup->uport.icount.dsr++;\n\t \n\tif (msr & UART_MSR_DDCD)\n\t\tuart_handle_dcd_change(&tup->uport, msr & UART_MSR_DCD);\n\t \n\tif (msr & UART_MSR_DCTS)\n\t\tuart_handle_cts_change(&tup->uport, msr & UART_MSR_CTS);\n}\n\nstatic irqreturn_t tegra_uart_isr(int irq, void *data)\n{\n\tstruct tegra_uart_port *tup = data;\n\tstruct uart_port *u = &tup->uport;\n\tunsigned long iir;\n\tunsigned long ier;\n\tbool is_rx_start = false;\n\tbool is_rx_int = false;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&u->lock, flags);\n\twhile (1) {\n\t\tiir = tegra_uart_read(tup, UART_IIR);\n\t\tif (iir & UART_IIR_NO_INT) {\n\t\t\tif (!tup->use_rx_pio && is_rx_int) {\n\t\t\t\ttegra_uart_handle_rx_dma(tup);\n\t\t\t\tif (tup->rx_in_progress) {\n\t\t\t\t\tier = tup->ier_shadow;\n\t\t\t\t\tier |= (UART_IER_RLSI | UART_IER_RTOIE |\n\t\t\t\t\t\tTEGRA_UART_IER_EORD | UART_IER_RDI);\n\t\t\t\t\ttup->ier_shadow = ier;\n\t\t\t\t\ttegra_uart_write(tup, ier, UART_IER);\n\t\t\t\t}\n\t\t\t} else if (is_rx_start) {\n\t\t\t\ttegra_uart_start_rx_dma(tup);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&u->lock, flags);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tswitch ((iir >> 1) & 0x7) {\n\t\tcase 0:  \n\t\t\ttegra_uart_handle_modem_signal_change(u);\n\t\t\tbreak;\n\n\t\tcase 1:  \n\t\t\ttup->ier_shadow &= ~UART_IER_THRI;\n\t\t\ttegra_uart_write(tup, tup->ier_shadow, UART_IER);\n\t\t\ttegra_uart_handle_tx_pio(tup);\n\t\t\tbreak;\n\n\t\tcase 4:  \n\t\tcase 6:  \n\t\t\tif (!tup->use_rx_pio) {\n\t\t\t\tis_rx_int = tup->rx_in_progress;\n\t\t\t\t \n\t\t\t\tier = tup->ier_shadow;\n\t\t\t\tier &= ~(UART_IER_RDI | UART_IER_RLSI |\n\t\t\t\t\tUART_IER_RTOIE | TEGRA_UART_IER_EORD);\n\t\t\t\ttup->ier_shadow = ier;\n\t\t\t\ttegra_uart_write(tup, ier, UART_IER);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 2:  \n\t\t\tif (!tup->use_rx_pio) {\n\t\t\t\tis_rx_start = tup->rx_in_progress;\n\t\t\t\ttup->ier_shadow  &= ~UART_IER_RDI;\n\t\t\t\ttegra_uart_write(tup, tup->ier_shadow,\n\t\t\t\t\t\t UART_IER);\n\t\t\t} else {\n\t\t\t\tdo_handle_rx_pio(tup);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 3:  \n\t\t\ttegra_uart_decode_rx_error(tup,\n\t\t\t\t\ttegra_uart_read(tup, UART_LSR));\n\t\t\tbreak;\n\n\t\tcase 5:  \n\t\tcase 7:  \n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void tegra_uart_stop_rx(struct uart_port *u)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\tstruct tty_port *port = &tup->uport.state->port;\n\tunsigned long ier;\n\n\tif (tup->rts_active)\n\t\tset_rts(tup, false);\n\n\tif (!tup->rx_in_progress)\n\t\treturn;\n\n\ttegra_uart_wait_sym_time(tup, 1);  \n\n\tier = tup->ier_shadow;\n\tier &= ~(UART_IER_RDI | UART_IER_RLSI | UART_IER_RTOIE |\n\t\t\t\t\tTEGRA_UART_IER_EORD);\n\ttup->ier_shadow = ier;\n\ttegra_uart_write(tup, ier, UART_IER);\n\ttup->rx_in_progress = 0;\n\n\tif (!tup->use_rx_pio)\n\t\ttegra_uart_terminate_rx_dma(tup);\n\telse\n\t\ttegra_uart_handle_rx_pio(tup, port);\n}\n\nstatic void tegra_uart_hw_deinit(struct tegra_uart_port *tup)\n{\n\tunsigned long flags;\n\tunsigned long char_time = DIV_ROUND_UP(10000000, tup->current_baud);\n\tunsigned long fifo_empty_time = tup->uport.fifosize * char_time;\n\tunsigned long wait_time;\n\tunsigned long lsr;\n\tunsigned long msr;\n\tunsigned long mcr;\n\n\t \n\ttegra_uart_write(tup, 0, UART_IER);\n\n\tlsr = tegra_uart_read(tup, UART_LSR);\n\tif ((lsr & UART_LSR_TEMT) != UART_LSR_TEMT) {\n\t\tmsr = tegra_uart_read(tup, UART_MSR);\n\t\tmcr = tegra_uart_read(tup, UART_MCR);\n\t\tif ((mcr & TEGRA_UART_MCR_CTS_EN) && (msr & UART_MSR_CTS))\n\t\t\tdev_err(tup->uport.dev,\n\t\t\t\t\"Tx Fifo not empty, CTS disabled, waiting\\n\");\n\n\t\t \n\t\twhile ((lsr & UART_LSR_TEMT) != UART_LSR_TEMT) {\n\t\t\twait_time = min(fifo_empty_time, 100lu);\n\t\t\tudelay(wait_time);\n\t\t\tfifo_empty_time -= wait_time;\n\t\t\tif (!fifo_empty_time) {\n\t\t\t\tmsr = tegra_uart_read(tup, UART_MSR);\n\t\t\t\tmcr = tegra_uart_read(tup, UART_MCR);\n\t\t\t\tif ((mcr & TEGRA_UART_MCR_CTS_EN) &&\n\t\t\t\t\t(msr & UART_MSR_CTS))\n\t\t\t\t\tdev_err(tup->uport.dev,\n\t\t\t\t\t\t\"Slave not ready\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlsr = tegra_uart_read(tup, UART_LSR);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&tup->uport.lock, flags);\n\t \n\ttegra_uart_fifo_reset(tup, UART_FCR_CLEAR_XMIT | UART_FCR_CLEAR_RCVR);\n\ttup->current_baud = 0;\n\tspin_unlock_irqrestore(&tup->uport.lock, flags);\n\n\ttup->rx_in_progress = 0;\n\ttup->tx_in_progress = 0;\n\n\tif (!tup->use_rx_pio)\n\t\ttegra_uart_dma_channel_free(tup, true);\n\tif (!tup->use_tx_pio)\n\t\ttegra_uart_dma_channel_free(tup, false);\n\n\tclk_disable_unprepare(tup->uart_clk);\n}\n\nstatic int tegra_uart_hw_init(struct tegra_uart_port *tup)\n{\n\tint ret;\n\n\ttup->fcr_shadow = 0;\n\ttup->mcr_shadow = 0;\n\ttup->lcr_shadow = 0;\n\ttup->ier_shadow = 0;\n\ttup->current_baud = 0;\n\n\tret = clk_prepare_enable(tup->uart_clk);\n\tif (ret) {\n\t\tdev_err(tup->uport.dev, \"could not enable clk\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treset_control_assert(tup->rst);\n\tudelay(10);\n\treset_control_deassert(tup->rst);\n\n\ttup->rx_in_progress = 0;\n\ttup->tx_in_progress = 0;\n\n\t \n\ttup->fcr_shadow = UART_FCR_ENABLE_FIFO;\n\n\tif (tup->use_rx_pio) {\n\t\ttup->fcr_shadow |= UART_FCR_R_TRIG_11;\n\t} else {\n\t\tif (tup->cdata->max_dma_burst_bytes == 8)\n\t\t\ttup->fcr_shadow |= UART_FCR_R_TRIG_10;\n\t\telse\n\t\t\ttup->fcr_shadow |= UART_FCR_R_TRIG_01;\n\t}\n\n\ttup->fcr_shadow |= TEGRA_UART_TX_TRIG_16B;\n\ttegra_uart_write(tup, tup->fcr_shadow, UART_FCR);\n\n\t \n\ttegra_uart_read(tup, UART_SCR);\n\n\tif (tup->cdata->fifo_mode_enable_status) {\n\t\tret = tegra_uart_wait_fifo_mode_enabled(tup);\n\t\tif (ret < 0) {\n\t\t\tclk_disable_unprepare(tup->uart_clk);\n\t\t\tdev_err(tup->uport.dev,\n\t\t\t\t\"Failed to enable FIFO mode: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\ttegra_uart_wait_cycle_time(tup, 3);\n\t}\n\n\t \n\tret = tegra_set_baudrate(tup, TEGRA_UART_DEFAULT_BAUD);\n\tif (ret < 0) {\n\t\tclk_disable_unprepare(tup->uart_clk);\n\t\tdev_err(tup->uport.dev, \"Failed to set baud rate\\n\");\n\t\treturn ret;\n\t}\n\tif (!tup->use_rx_pio) {\n\t\ttup->lcr_shadow = TEGRA_UART_DEFAULT_LSR;\n\t\ttup->fcr_shadow |= UART_FCR_DMA_SELECT;\n\t\ttegra_uart_write(tup, tup->fcr_shadow, UART_FCR);\n\t} else {\n\t\ttegra_uart_write(tup, tup->fcr_shadow, UART_FCR);\n\t}\n\ttup->rx_in_progress = 1;\n\n\t \n\ttup->ier_shadow = UART_IER_RLSI | UART_IER_RTOIE | UART_IER_RDI;\n\n\t \n\tif (!tup->use_rx_pio)\n\t\ttup->ier_shadow |= TEGRA_UART_IER_EORD;\n\n\ttegra_uart_write(tup, tup->ier_shadow, UART_IER);\n\treturn 0;\n}\n\nstatic void tegra_uart_dma_channel_free(struct tegra_uart_port *tup,\n\t\tbool dma_to_memory)\n{\n\tif (dma_to_memory) {\n\t\tdmaengine_terminate_all(tup->rx_dma_chan);\n\t\tdma_release_channel(tup->rx_dma_chan);\n\t\tdma_free_coherent(tup->uport.dev, TEGRA_UART_RX_DMA_BUFFER_SIZE,\n\t\t\t\ttup->rx_dma_buf_virt, tup->rx_dma_buf_phys);\n\t\ttup->rx_dma_chan = NULL;\n\t\ttup->rx_dma_buf_phys = 0;\n\t\ttup->rx_dma_buf_virt = NULL;\n\t} else {\n\t\tdmaengine_terminate_all(tup->tx_dma_chan);\n\t\tdma_release_channel(tup->tx_dma_chan);\n\t\tdma_unmap_single(tup->uport.dev, tup->tx_dma_buf_phys,\n\t\t\tUART_XMIT_SIZE, DMA_TO_DEVICE);\n\t\ttup->tx_dma_chan = NULL;\n\t\ttup->tx_dma_buf_phys = 0;\n\t\ttup->tx_dma_buf_virt = NULL;\n\t}\n}\n\nstatic int tegra_uart_dma_channel_allocate(struct tegra_uart_port *tup,\n\t\t\tbool dma_to_memory)\n{\n\tstruct dma_chan *dma_chan;\n\tunsigned char *dma_buf;\n\tdma_addr_t dma_phys;\n\tint ret;\n\tstruct dma_slave_config dma_sconfig;\n\n\tdma_chan = dma_request_chan(tup->uport.dev, dma_to_memory ? \"rx\" : \"tx\");\n\tif (IS_ERR(dma_chan)) {\n\t\tret = PTR_ERR(dma_chan);\n\t\tdev_err(tup->uport.dev,\n\t\t\t\"DMA channel alloc failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (dma_to_memory) {\n\t\tdma_buf = dma_alloc_coherent(tup->uport.dev,\n\t\t\t\tTEGRA_UART_RX_DMA_BUFFER_SIZE,\n\t\t\t\t &dma_phys, GFP_KERNEL);\n\t\tif (!dma_buf) {\n\t\t\tdev_err(tup->uport.dev,\n\t\t\t\t\"Not able to allocate the dma buffer\\n\");\n\t\t\tdma_release_channel(dma_chan);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdma_sync_single_for_device(tup->uport.dev, dma_phys,\n\t\t\t\t\t   TEGRA_UART_RX_DMA_BUFFER_SIZE,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\tdma_sconfig.src_addr = tup->uport.mapbase;\n\t\tdma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tdma_sconfig.src_maxburst = tup->cdata->max_dma_burst_bytes;\n\t\ttup->rx_dma_chan = dma_chan;\n\t\ttup->rx_dma_buf_virt = dma_buf;\n\t\ttup->rx_dma_buf_phys = dma_phys;\n\t} else {\n\t\tdma_phys = dma_map_single(tup->uport.dev,\n\t\t\ttup->uport.state->xmit.buf, UART_XMIT_SIZE,\n\t\t\tDMA_TO_DEVICE);\n\t\tif (dma_mapping_error(tup->uport.dev, dma_phys)) {\n\t\t\tdev_err(tup->uport.dev, \"dma_map_single tx failed\\n\");\n\t\t\tdma_release_channel(dma_chan);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdma_buf = tup->uport.state->xmit.buf;\n\t\tdma_sconfig.dst_addr = tup->uport.mapbase;\n\t\tdma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tdma_sconfig.dst_maxburst = 16;\n\t\ttup->tx_dma_chan = dma_chan;\n\t\ttup->tx_dma_buf_virt = dma_buf;\n\t\ttup->tx_dma_buf_phys = dma_phys;\n\t}\n\n\tret = dmaengine_slave_config(dma_chan, &dma_sconfig);\n\tif (ret < 0) {\n\t\tdev_err(tup->uport.dev,\n\t\t\t\"Dma slave config failed, err = %d\\n\", ret);\n\t\ttegra_uart_dma_channel_free(tup, dma_to_memory);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_uart_startup(struct uart_port *u)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\tint ret;\n\n\tif (!tup->use_tx_pio) {\n\t\tret = tegra_uart_dma_channel_allocate(tup, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(u->dev, \"Tx Dma allocation failed, err = %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!tup->use_rx_pio) {\n\t\tret = tegra_uart_dma_channel_allocate(tup, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(u->dev, \"Rx Dma allocation failed, err = %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto fail_rx_dma;\n\t\t}\n\t}\n\n\tret = tegra_uart_hw_init(tup);\n\tif (ret < 0) {\n\t\tdev_err(u->dev, \"Uart HW init failed, err = %d\\n\", ret);\n\t\tgoto fail_hw_init;\n\t}\n\n\tret = request_irq(u->irq, tegra_uart_isr, 0,\n\t\t\t\tdev_name(u->dev), tup);\n\tif (ret < 0) {\n\t\tdev_err(u->dev, \"Failed to register ISR for IRQ %d\\n\", u->irq);\n\t\tgoto fail_request_irq;\n\t}\n\treturn 0;\n\nfail_request_irq:\n\t \n\tclk_disable_unprepare(tup->uart_clk);\nfail_hw_init:\n\tif (!tup->use_rx_pio)\n\t\ttegra_uart_dma_channel_free(tup, true);\nfail_rx_dma:\n\tif (!tup->use_tx_pio)\n\t\ttegra_uart_dma_channel_free(tup, false);\n\treturn ret;\n}\n\n \nstatic void tegra_uart_flush_buffer(struct uart_port *u)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\n\ttup->tx_bytes = 0;\n\tif (tup->tx_dma_chan)\n\t\tdmaengine_terminate_all(tup->tx_dma_chan);\n}\n\nstatic void tegra_uart_shutdown(struct uart_port *u)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\n\ttegra_uart_hw_deinit(tup);\n\tfree_irq(u->irq, tup);\n}\n\nstatic void tegra_uart_enable_ms(struct uart_port *u)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\n\tif (tup->enable_modem_interrupt) {\n\t\ttup->ier_shadow |= UART_IER_MSI;\n\t\ttegra_uart_write(tup, tup->ier_shadow, UART_IER);\n\t}\n}\n\nstatic void tegra_uart_set_termios(struct uart_port *u,\n\t\t\t\t   struct ktermios *termios,\n\t\t\t\t   const struct ktermios *oldtermios)\n{\n\tstruct tegra_uart_port *tup = to_tegra_uport(u);\n\tunsigned int baud;\n\tunsigned long flags;\n\tunsigned int lcr;\n\tunsigned char char_bits;\n\tstruct clk *parent_clk = clk_get_parent(tup->uart_clk);\n\tunsigned long parent_clk_rate = clk_get_rate(parent_clk);\n\tint max_divider = (tup->cdata->support_clk_src_div) ? 0x7FFF : 0xFFFF;\n\tint ret;\n\n\tmax_divider *= 16;\n\tspin_lock_irqsave(&u->lock, flags);\n\n\t \n\tif (tup->rts_active)\n\t\tset_rts(tup, false);\n\n\t \n\ttegra_uart_write(tup, tup->ier_shadow | UART_IER_RDI, UART_IER);\n\ttegra_uart_read(tup, UART_IER);\n\ttegra_uart_write(tup, 0, UART_IER);\n\ttegra_uart_read(tup, UART_IER);\n\n\t \n\tlcr = tup->lcr_shadow;\n\tlcr &= ~UART_LCR_PARITY;\n\n\t \n\ttermios->c_cflag &= ~CMSPAR;\n\n\tif ((termios->c_cflag & PARENB) == PARENB) {\n\t\tif (termios->c_cflag & PARODD) {\n\t\t\tlcr |= UART_LCR_PARITY;\n\t\t\tlcr &= ~UART_LCR_EPAR;\n\t\t\tlcr &= ~UART_LCR_SPAR;\n\t\t} else {\n\t\t\tlcr |= UART_LCR_PARITY;\n\t\t\tlcr |= UART_LCR_EPAR;\n\t\t\tlcr &= ~UART_LCR_SPAR;\n\t\t}\n\t}\n\n\tchar_bits = tty_get_char_size(termios->c_cflag);\n\tlcr &= ~UART_LCR_WLEN8;\n\tlcr |= UART_LCR_WLEN(char_bits);\n\n\t \n\tif (termios->c_cflag & CSTOPB)\n\t\tlcr |= UART_LCR_STOP;\n\telse\n\t\tlcr &= ~UART_LCR_STOP;\n\n\ttegra_uart_write(tup, lcr, UART_LCR);\n\ttup->lcr_shadow = lcr;\n\ttup->symb_bit = tty_get_frame_size(termios->c_cflag);\n\n\t \n\tbaud = uart_get_baud_rate(u, termios, oldtermios,\n\t\t\tparent_clk_rate/max_divider,\n\t\t\tparent_clk_rate/16);\n\tspin_unlock_irqrestore(&u->lock, flags);\n\tret = tegra_set_baudrate(tup, baud);\n\tif (ret < 0) {\n\t\tdev_err(tup->uport.dev, \"Failed to set baud rate\\n\");\n\t\treturn;\n\t}\n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\tspin_lock_irqsave(&u->lock, flags);\n\n\t \n\tif (termios->c_cflag & CRTSCTS)\t{\n\t\ttup->mcr_shadow |= TEGRA_UART_MCR_CTS_EN;\n\t\ttup->mcr_shadow &= ~TEGRA_UART_MCR_RTS_EN;\n\t\ttegra_uart_write(tup, tup->mcr_shadow, UART_MCR);\n\t\t \n\t\tif (tup->rts_active)\n\t\t\tset_rts(tup, true);\n\t} else {\n\t\ttup->mcr_shadow &= ~TEGRA_UART_MCR_CTS_EN;\n\t\ttup->mcr_shadow &= ~TEGRA_UART_MCR_RTS_EN;\n\t\ttegra_uart_write(tup, tup->mcr_shadow, UART_MCR);\n\t}\n\n\t \n\tuart_update_timeout(u, termios->c_cflag, baud);\n\n\t \n\ttegra_uart_read(tup, UART_IER);\n\n\t \n\ttegra_uart_write(tup, tup->ier_shadow, UART_IER);\n\ttegra_uart_read(tup, UART_IER);\n\n\ttup->uport.ignore_status_mask = 0;\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\ttup->uport.ignore_status_mask |= UART_LSR_DR;\n\tif (termios->c_iflag & IGNBRK)\n\t\ttup->uport.ignore_status_mask |= UART_LSR_BI;\n\n\tspin_unlock_irqrestore(&u->lock, flags);\n}\n\nstatic const char *tegra_uart_type(struct uart_port *u)\n{\n\treturn TEGRA_UART_TYPE;\n}\n\nstatic const struct uart_ops tegra_uart_ops = {\n\t.tx_empty\t= tegra_uart_tx_empty,\n\t.set_mctrl\t= tegra_uart_set_mctrl,\n\t.get_mctrl\t= tegra_uart_get_mctrl,\n\t.stop_tx\t= tegra_uart_stop_tx,\n\t.start_tx\t= tegra_uart_start_tx,\n\t.stop_rx\t= tegra_uart_stop_rx,\n\t.flush_buffer\t= tegra_uart_flush_buffer,\n\t.enable_ms\t= tegra_uart_enable_ms,\n\t.break_ctl\t= tegra_uart_break_ctl,\n\t.startup\t= tegra_uart_startup,\n\t.shutdown\t= tegra_uart_shutdown,\n\t.set_termios\t= tegra_uart_set_termios,\n\t.type\t\t= tegra_uart_type,\n\t.request_port\t= tegra_uart_request_port,\n\t.release_port\t= tegra_uart_release_port,\n};\n\nstatic struct uart_driver tegra_uart_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= \"tegra_hsuart\",\n\t.dev_name\t= \"ttyTHS\",\n\t.cons\t\t= NULL,\n\t.nr\t\t= TEGRA_UART_MAXIMUM,\n};\n\nstatic int tegra_uart_parse_dt(struct platform_device *pdev,\n\tstruct tegra_uart_port *tup)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint port;\n\tint ret;\n\tint index;\n\tu32 pval;\n\tint count;\n\tint n_entries;\n\n\tport = of_alias_get_id(np, \"serial\");\n\tif (port < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias id, errno %d\\n\", port);\n\t\treturn port;\n\t}\n\ttup->uport.line = port;\n\n\ttup->enable_modem_interrupt = of_property_read_bool(np,\n\t\t\t\t\t\"nvidia,enable-modem-interrupt\");\n\n\tindex = of_property_match_string(np, \"dma-names\", \"rx\");\n\tif (index < 0) {\n\t\ttup->use_rx_pio = true;\n\t\tdev_info(&pdev->dev, \"RX in PIO mode\\n\");\n\t}\n\tindex = of_property_match_string(np, \"dma-names\", \"tx\");\n\tif (index < 0) {\n\t\ttup->use_tx_pio = true;\n\t\tdev_info(&pdev->dev, \"TX in PIO mode\\n\");\n\t}\n\n\tn_entries = of_property_count_u32_elems(np, \"nvidia,adjust-baud-rates\");\n\tif (n_entries > 0) {\n\t\ttup->n_adjustable_baud_rates = n_entries / 3;\n\t\ttup->baud_tolerance =\n\t\tdevm_kzalloc(&pdev->dev, (tup->n_adjustable_baud_rates) *\n\t\t\t     sizeof(*tup->baud_tolerance), GFP_KERNEL);\n\t\tif (!tup->baud_tolerance)\n\t\t\treturn -ENOMEM;\n\t\tfor (count = 0, index = 0; count < n_entries; count += 3,\n\t\t     index++) {\n\t\t\tret =\n\t\t\tof_property_read_u32_index(np,\n\t\t\t\t\t\t   \"nvidia,adjust-baud-rates\",\n\t\t\t\t\t\t   count, &pval);\n\t\t\tif (!ret)\n\t\t\t\ttup->baud_tolerance[index].lower_range_baud =\n\t\t\t\tpval;\n\t\t\tret =\n\t\t\tof_property_read_u32_index(np,\n\t\t\t\t\t\t   \"nvidia,adjust-baud-rates\",\n\t\t\t\t\t\t   count + 1, &pval);\n\t\t\tif (!ret)\n\t\t\t\ttup->baud_tolerance[index].upper_range_baud =\n\t\t\t\tpval;\n\t\t\tret =\n\t\t\tof_property_read_u32_index(np,\n\t\t\t\t\t\t   \"nvidia,adjust-baud-rates\",\n\t\t\t\t\t\t   count + 2, &pval);\n\t\t\tif (!ret)\n\t\t\t\ttup->baud_tolerance[index].tolerance =\n\t\t\t\t(s32)pval;\n\t\t}\n\t} else {\n\t\ttup->n_adjustable_baud_rates = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic struct tegra_uart_chip_data tegra20_uart_chip_data = {\n\t.tx_fifo_full_status\t\t= false,\n\t.allow_txfifo_reset_fifo_mode\t= true,\n\t.support_clk_src_div\t\t= false,\n\t.fifo_mode_enable_status\t= false,\n\t.uart_max_port\t\t\t= 5,\n\t.max_dma_burst_bytes\t\t= 4,\n\t.error_tolerance_low_range\t= -4,\n\t.error_tolerance_high_range\t= 4,\n};\n\nstatic struct tegra_uart_chip_data tegra30_uart_chip_data = {\n\t.tx_fifo_full_status\t\t= true,\n\t.allow_txfifo_reset_fifo_mode\t= false,\n\t.support_clk_src_div\t\t= true,\n\t.fifo_mode_enable_status\t= false,\n\t.uart_max_port\t\t\t= 5,\n\t.max_dma_burst_bytes\t\t= 4,\n\t.error_tolerance_low_range\t= -4,\n\t.error_tolerance_high_range\t= 4,\n};\n\nstatic struct tegra_uart_chip_data tegra186_uart_chip_data = {\n\t.tx_fifo_full_status\t\t= true,\n\t.allow_txfifo_reset_fifo_mode\t= false,\n\t.support_clk_src_div\t\t= true,\n\t.fifo_mode_enable_status\t= true,\n\t.uart_max_port\t\t\t= 8,\n\t.max_dma_burst_bytes\t\t= 8,\n\t.error_tolerance_low_range\t= 0,\n\t.error_tolerance_high_range\t= 4,\n};\n\nstatic struct tegra_uart_chip_data tegra194_uart_chip_data = {\n\t.tx_fifo_full_status\t\t= true,\n\t.allow_txfifo_reset_fifo_mode\t= false,\n\t.support_clk_src_div\t\t= true,\n\t.fifo_mode_enable_status\t= true,\n\t.uart_max_port\t\t\t= 8,\n\t.max_dma_burst_bytes\t\t= 8,\n\t.error_tolerance_low_range\t= -2,\n\t.error_tolerance_high_range\t= 2,\n};\n\nstatic const struct of_device_id tegra_uart_of_match[] = {\n\t{\n\t\t.compatible\t= \"nvidia,tegra30-hsuart\",\n\t\t.data\t\t= &tegra30_uart_chip_data,\n\t}, {\n\t\t.compatible\t= \"nvidia,tegra20-hsuart\",\n\t\t.data\t\t= &tegra20_uart_chip_data,\n\t}, {\n\t\t.compatible     = \"nvidia,tegra186-hsuart\",\n\t\t.data\t\t= &tegra186_uart_chip_data,\n\t}, {\n\t\t.compatible     = \"nvidia,tegra194-hsuart\",\n\t\t.data\t\t= &tegra194_uart_chip_data,\n\t}, {\n\t},\n};\nMODULE_DEVICE_TABLE(of, tegra_uart_of_match);\n\nstatic int tegra_uart_probe(struct platform_device *pdev)\n{\n\tstruct tegra_uart_port *tup;\n\tstruct uart_port *u;\n\tstruct resource *resource;\n\tint ret;\n\tconst struct tegra_uart_chip_data *cdata;\n\n\tcdata = of_device_get_match_data(&pdev->dev);\n\tif (!cdata) {\n\t\tdev_err(&pdev->dev, \"Error: No device match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttup = devm_kzalloc(&pdev->dev, sizeof(*tup), GFP_KERNEL);\n\tif (!tup) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate memory for tup\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = tegra_uart_parse_dt(pdev, tup);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tu = &tup->uport;\n\tu->dev = &pdev->dev;\n\tu->ops = &tegra_uart_ops;\n\tu->type = PORT_TEGRA;\n\tu->fifosize = 32;\n\ttup->cdata = cdata;\n\n\tplatform_set_drvdata(pdev, tup);\n\n\tu->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &resource);\n\tif (IS_ERR(u->membase))\n\t\treturn PTR_ERR(u->membase);\n\tu->mapbase = resource->start;\n\n\ttup->uart_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(tup->uart_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(tup->uart_clk), \"Couldn't get the clock\");\n\n\ttup->rst = devm_reset_control_get_exclusive(&pdev->dev, \"serial\");\n\tif (IS_ERR(tup->rst)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get the reset\\n\");\n\t\treturn PTR_ERR(tup->rst);\n\t}\n\n\tu->iotype = UPIO_MEM32;\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tu->irq = ret;\n\tu->regshift = 2;\n\tret = uart_add_one_port(&tegra_uart_driver, u);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to add uart port, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic int tegra_uart_remove(struct platform_device *pdev)\n{\n\tstruct tegra_uart_port *tup = platform_get_drvdata(pdev);\n\tstruct uart_port *u = &tup->uport;\n\n\tuart_remove_one_port(&tegra_uart_driver, u);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tegra_uart_suspend(struct device *dev)\n{\n\tstruct tegra_uart_port *tup = dev_get_drvdata(dev);\n\tstruct uart_port *u = &tup->uport;\n\n\treturn uart_suspend_port(&tegra_uart_driver, u);\n}\n\nstatic int tegra_uart_resume(struct device *dev)\n{\n\tstruct tegra_uart_port *tup = dev_get_drvdata(dev);\n\tstruct uart_port *u = &tup->uport;\n\n\treturn uart_resume_port(&tegra_uart_driver, u);\n}\n#endif\n\nstatic const struct dev_pm_ops tegra_uart_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra_uart_suspend, tegra_uart_resume)\n};\n\nstatic struct platform_driver tegra_uart_platform_driver = {\n\t.probe\t\t= tegra_uart_probe,\n\t.remove\t\t= tegra_uart_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"serial-tegra\",\n\t\t.of_match_table = tegra_uart_of_match,\n\t\t.pm\t= &tegra_uart_pm_ops,\n\t},\n};\n\nstatic int __init tegra_uart_init(void)\n{\n\tint ret;\n\tstruct device_node *node;\n\tconst struct of_device_id *match = NULL;\n\tconst struct tegra_uart_chip_data *cdata = NULL;\n\n\tnode = of_find_matching_node(NULL, tegra_uart_of_match);\n\tif (node)\n\t\tmatch = of_match_node(tegra_uart_of_match, node);\n\tof_node_put(node);\n\tif (match)\n\t\tcdata = match->data;\n\tif (cdata)\n\t\ttegra_uart_driver.nr = cdata->uart_max_port;\n\n\tret = uart_register_driver(&tegra_uart_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"Could not register %s driver\\n\",\n\t\t       tegra_uart_driver.driver_name);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&tegra_uart_platform_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"Uart platform driver register failed, e = %d\\n\", ret);\n\t\tuart_unregister_driver(&tegra_uart_driver);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void __exit tegra_uart_exit(void)\n{\n\tpr_info(\"Unloading tegra uart driver\\n\");\n\tplatform_driver_unregister(&tegra_uart_platform_driver);\n\tuart_unregister_driver(&tegra_uart_driver);\n}\n\nmodule_init(tegra_uart_init);\nmodule_exit(tegra_uart_exit);\n\nMODULE_ALIAS(\"platform:serial-tegra\");\nMODULE_DESCRIPTION(\"High speed UART driver for tegra chipset\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}