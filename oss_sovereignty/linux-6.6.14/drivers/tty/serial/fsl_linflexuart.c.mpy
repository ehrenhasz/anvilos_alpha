{
  "module_name": "fsl_linflexuart.c",
  "hash_id": "fe3753195c735d39d770fa03a90ba09546e175fb25d597e60b8737c80066da7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/fsl_linflexuart.c",
  "human_readable_source": "\n \n\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/tty_flip.h>\n#include <linux/delay.h>\n\n \n\n#define LINCR1\t0x0000\t \n#define LINIER\t0x0004\t \n#define LINSR\t0x0008\t \n#define LINESR\t0x000C\t \n#define UARTCR\t0x0010\t \n#define UARTSR\t0x0014\t \n#define LINTCSR\t0x0018\t \n#define LINOCR\t0x001C\t \n#define LINTOCR\t0x0020\t \n#define LINFBRR\t0x0024\t \n#define LINIBRR\t0x0028\t \n#define LINCFR\t0x002C\t \n#define LINCR2\t0x0030\t \n#define BIDR\t0x0034\t \n#define BDRL\t0x0038\t \n#define BDRM\t0x003C\t \n#define IFER\t0x0040\t \n#define IFMI\t0x0044\t \n#define IFMR\t0x0048\t \n#define GCR\t0x004C\t \n#define UARTPTO\t0x0050\t \n#define UARTCTO\t0x0054\t \n\n \n\n#define LINFLEXD_LINCR1_INIT\t\tBIT(0)\n#define LINFLEXD_LINCR1_MME\t\tBIT(4)\n#define LINFLEXD_LINCR1_BF\t\tBIT(7)\n\n#define LINFLEXD_LINSR_LINS_INITMODE\tBIT(12)\n#define LINFLEXD_LINSR_LINS_MASK\t(0xF << 12)\n\n#define LINFLEXD_LINIER_SZIE\t\tBIT(15)\n#define LINFLEXD_LINIER_OCIE\t\tBIT(14)\n#define LINFLEXD_LINIER_BEIE\t\tBIT(13)\n#define LINFLEXD_LINIER_CEIE\t\tBIT(12)\n#define LINFLEXD_LINIER_HEIE\t\tBIT(11)\n#define LINFLEXD_LINIER_FEIE\t\tBIT(8)\n#define LINFLEXD_LINIER_BOIE\t\tBIT(7)\n#define LINFLEXD_LINIER_LSIE\t\tBIT(6)\n#define LINFLEXD_LINIER_WUIE\t\tBIT(5)\n#define LINFLEXD_LINIER_DBFIE\t\tBIT(4)\n#define LINFLEXD_LINIER_DBEIETOIE\tBIT(3)\n#define LINFLEXD_LINIER_DRIE\t\tBIT(2)\n#define LINFLEXD_LINIER_DTIE\t\tBIT(1)\n#define LINFLEXD_LINIER_HRIE\t\tBIT(0)\n\n#define LINFLEXD_UARTCR_OSR_MASK\t(0xF << 24)\n#define LINFLEXD_UARTCR_OSR(uartcr)\t(((uartcr) \\\n\t\t\t\t\t& LINFLEXD_UARTCR_OSR_MASK) >> 24)\n\n#define LINFLEXD_UARTCR_ROSE\t\tBIT(23)\n\n#define LINFLEXD_UARTCR_RFBM\t\tBIT(9)\n#define LINFLEXD_UARTCR_TFBM\t\tBIT(8)\n#define LINFLEXD_UARTCR_WL1\t\tBIT(7)\n#define LINFLEXD_UARTCR_PC1\t\tBIT(6)\n\n#define LINFLEXD_UARTCR_RXEN\t\tBIT(5)\n#define LINFLEXD_UARTCR_TXEN\t\tBIT(4)\n#define LINFLEXD_UARTCR_PC0\t\tBIT(3)\n\n#define LINFLEXD_UARTCR_PCE\t\tBIT(2)\n#define LINFLEXD_UARTCR_WL0\t\tBIT(1)\n#define LINFLEXD_UARTCR_UART\t\tBIT(0)\n\n#define LINFLEXD_UARTSR_SZF\t\tBIT(15)\n#define LINFLEXD_UARTSR_OCF\t\tBIT(14)\n#define LINFLEXD_UARTSR_PE3\t\tBIT(13)\n#define LINFLEXD_UARTSR_PE2\t\tBIT(12)\n#define LINFLEXD_UARTSR_PE1\t\tBIT(11)\n#define LINFLEXD_UARTSR_PE0\t\tBIT(10)\n#define LINFLEXD_UARTSR_RMB\t\tBIT(9)\n#define LINFLEXD_UARTSR_FEF\t\tBIT(8)\n#define LINFLEXD_UARTSR_BOF\t\tBIT(7)\n#define LINFLEXD_UARTSR_RPS\t\tBIT(6)\n#define LINFLEXD_UARTSR_WUF\t\tBIT(5)\n#define LINFLEXD_UARTSR_4\t\tBIT(4)\n\n#define LINFLEXD_UARTSR_TO\t\tBIT(3)\n\n#define LINFLEXD_UARTSR_DRFRFE\t\tBIT(2)\n#define LINFLEXD_UARTSR_DTFTFF\t\tBIT(1)\n#define LINFLEXD_UARTSR_NF\t\tBIT(0)\n#define LINFLEXD_UARTSR_PE\t\t(LINFLEXD_UARTSR_PE0 |\\\n\t\t\t\t\t LINFLEXD_UARTSR_PE1 |\\\n\t\t\t\t\t LINFLEXD_UARTSR_PE2 |\\\n\t\t\t\t\t LINFLEXD_UARTSR_PE3)\n\n#define LINFLEX_LDIV_MULTIPLIER\t\t(16)\n\n#define DRIVER_NAME\t\"fsl-linflexuart\"\n#define DEV_NAME\t\"ttyLF\"\n#define UART_NR\t\t4\n\n#define EARLYCON_BUFFER_INITIAL_CAP\t8\n\n#define PREINIT_DELAY\t\t\t2000  \n\nstatic const struct of_device_id linflex_dt_ids[] = {\n\t{\n\t\t.compatible = \"fsl,s32v234-linflexuart\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, linflex_dt_ids);\n\n#ifdef CONFIG_SERIAL_FSL_LINFLEXUART_CONSOLE\nstatic struct uart_port *earlycon_port;\nstatic bool linflex_earlycon_same_instance;\nstatic DEFINE_SPINLOCK(init_lock);\nstatic bool during_init;\n\nstatic struct {\n\tchar *content;\n\tunsigned int len, cap;\n} earlycon_buf;\n#endif\n\nstatic void linflex_stop_tx(struct uart_port *port)\n{\n\tunsigned long ier;\n\n\tier = readl(port->membase + LINIER);\n\tier &= ~(LINFLEXD_LINIER_DTIE);\n\twritel(ier, port->membase + LINIER);\n}\n\nstatic void linflex_stop_rx(struct uart_port *port)\n{\n\tunsigned long ier;\n\n\tier = readl(port->membase + LINIER);\n\twritel(ier & ~LINFLEXD_LINIER_DRIE, port->membase + LINIER);\n}\n\nstatic void linflex_put_char(struct uart_port *sport, unsigned char c)\n{\n\tunsigned long status;\n\n\twriteb(c, sport->membase + BDRL);\n\n\t \n\twhile (((status = readl(sport->membase + UARTSR)) &\n\t\t\t\tLINFLEXD_UARTSR_DTFTFF) !=\n\t\t\t\tLINFLEXD_UARTSR_DTFTFF)\n\t\t;\n\n\twritel(status | LINFLEXD_UARTSR_DTFTFF, sport->membase + UARTSR);\n}\n\nstatic inline void linflex_transmit_buffer(struct uart_port *sport)\n{\n\tstruct circ_buf *xmit = &sport->state->xmit;\n\n\twhile (!uart_circ_empty(xmit)) {\n\t\tlinflex_put_char(sport, xmit->buf[xmit->tail]);\n\t\tuart_xmit_advance(sport, 1);\n\t}\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(sport);\n\n\tif (uart_circ_empty(xmit))\n\t\tlinflex_stop_tx(sport);\n}\n\nstatic void linflex_start_tx(struct uart_port *port)\n{\n\tunsigned long ier;\n\n\tlinflex_transmit_buffer(port);\n\tier = readl(port->membase + LINIER);\n\twritel(ier | LINFLEXD_LINIER_DTIE, port->membase + LINIER);\n}\n\nstatic irqreturn_t linflex_txint(int irq, void *dev_id)\n{\n\tstruct uart_port *sport = dev_id;\n\tstruct circ_buf *xmit = &sport->state->xmit;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sport->lock, flags);\n\n\tif (sport->x_char) {\n\t\tlinflex_put_char(sport, sport->x_char);\n\t\tgoto out;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(sport)) {\n\t\tlinflex_stop_tx(sport);\n\t\tgoto out;\n\t}\n\n\tlinflex_transmit_buffer(sport);\nout:\n\tspin_unlock_irqrestore(&sport->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t linflex_rxint(int irq, void *dev_id)\n{\n\tstruct uart_port *sport = dev_id;\n\tunsigned int flg;\n\tstruct tty_port *port = &sport->state->port;\n\tunsigned long flags, status;\n\tunsigned char rx;\n\tbool brk;\n\n\tspin_lock_irqsave(&sport->lock, flags);\n\n\tstatus = readl(sport->membase + UARTSR);\n\twhile (status & LINFLEXD_UARTSR_RMB) {\n\t\trx = readb(sport->membase + BDRM);\n\t\tbrk = false;\n\t\tflg = TTY_NORMAL;\n\t\tsport->icount.rx++;\n\n\t\tif (status & (LINFLEXD_UARTSR_BOF | LINFLEXD_UARTSR_FEF |\n\t\t\t\tLINFLEXD_UARTSR_PE)) {\n\t\t\tif (status & LINFLEXD_UARTSR_BOF)\n\t\t\t\tsport->icount.overrun++;\n\t\t\tif (status & LINFLEXD_UARTSR_FEF) {\n\t\t\t\tif (!rx) {\n\t\t\t\t\tbrk = true;\n\t\t\t\t\tsport->icount.brk++;\n\t\t\t\t} else\n\t\t\t\t\tsport->icount.frame++;\n\t\t\t}\n\t\t\tif (status & LINFLEXD_UARTSR_PE)\n\t\t\t\tsport->icount.parity++;\n\t\t}\n\n\t\twritel(status, sport->membase + UARTSR);\n\t\tstatus = readl(sport->membase + UARTSR);\n\n\t\tif (brk) {\n\t\t\tuart_handle_break(sport);\n\t\t} else {\n\t\t\tif (uart_handle_sysrq_char(sport, (unsigned char)rx))\n\t\t\t\tcontinue;\n\t\t\ttty_insert_flip_char(port, rx, flg);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&sport->lock, flags);\n\n\ttty_flip_buffer_push(port);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t linflex_int(int irq, void *dev_id)\n{\n\tstruct uart_port *sport = dev_id;\n\tunsigned long status;\n\n\tstatus = readl(sport->membase + UARTSR);\n\n\tif (status & LINFLEXD_UARTSR_DRFRFE)\n\t\tlinflex_rxint(irq, dev_id);\n\tif (status & LINFLEXD_UARTSR_DTFTFF)\n\t\tlinflex_txint(irq, dev_id);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic unsigned int linflex_tx_empty(struct uart_port *port)\n{\n\tunsigned long status;\n\n\tstatus = readl(port->membase + UARTSR) & LINFLEXD_UARTSR_DTFTFF;\n\n\treturn status ? TIOCSER_TEMT : 0;\n}\n\nstatic unsigned int linflex_get_mctrl(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void linflex_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n}\n\nstatic void linflex_break_ctl(struct uart_port *port, int break_state)\n{\n}\n\nstatic void linflex_setup_watermark(struct uart_port *sport)\n{\n\tunsigned long cr, ier, cr1;\n\n\t \n\tier = readl(sport->membase + LINIER);\n\tier &= ~(LINFLEXD_LINIER_DRIE | LINFLEXD_LINIER_DTIE);\n\twritel(ier, sport->membase + LINIER);\n\n\tcr = readl(sport->membase + UARTCR);\n\tcr &= ~(LINFLEXD_UARTCR_RXEN | LINFLEXD_UARTCR_TXEN);\n\twritel(cr, sport->membase + UARTCR);\n\n\t \n\n\t \n\tcr1 = LINFLEXD_LINCR1_BF | LINFLEXD_LINCR1_MME\n\t      | LINFLEXD_LINCR1_INIT;\n\twritel(cr1, sport->membase + LINCR1);\n\n\t \n\twhile ((readl(sport->membase + LINSR)\n\t\t& LINFLEXD_LINSR_LINS_MASK)\n\t\t!= LINFLEXD_LINSR_LINS_INITMODE)\n\t\t;\n\n\t \n\n\t \n\twritel(LINFLEXD_UARTCR_UART, sport->membase + UARTCR);\n\n\tcr = (LINFLEXD_UARTCR_RXEN | LINFLEXD_UARTCR_TXEN |\n\t      LINFLEXD_UARTCR_WL0 | LINFLEXD_UARTCR_UART);\n\n\twritel(cr, sport->membase + UARTCR);\n\n\tcr1 &= ~(LINFLEXD_LINCR1_INIT);\n\n\twritel(cr1, sport->membase + LINCR1);\n\n\tier = readl(sport->membase + LINIER);\n\tier |= LINFLEXD_LINIER_DRIE;\n\tier |= LINFLEXD_LINIER_DTIE;\n\n\twritel(ier, sport->membase + LINIER);\n}\n\nstatic int linflex_startup(struct uart_port *port)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tlinflex_setup_watermark(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tret = devm_request_irq(port->dev, port->irq, linflex_int, 0,\n\t\t\t       DRIVER_NAME, port);\n\n\treturn ret;\n}\n\nstatic void linflex_shutdown(struct uart_port *port)\n{\n\tunsigned long ier;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\t \n\tier = readl(port->membase + LINIER);\n\tier &= ~(LINFLEXD_LINIER_DRIE | LINFLEXD_LINIER_DTIE);\n\twritel(ier, port->membase + LINIER);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tdevm_free_irq(port->dev, port->irq, port);\n}\n\nstatic void\nlinflex_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t    const struct ktermios *old)\n{\n\tunsigned long flags;\n\tunsigned long cr, old_cr, cr1;\n\tunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\n\n\tcr = readl(port->membase + UARTCR);\n\told_cr = cr;\n\n\t \n\tcr1 = readl(port->membase + LINCR1);\n\tcr1 |= LINFLEXD_LINCR1_INIT;\n\twritel(cr1, port->membase + LINCR1);\n\n\t \n\twhile ((readl(port->membase + LINSR)\n\t\t& LINFLEXD_LINSR_LINS_MASK)\n\t\t!= LINFLEXD_LINSR_LINS_INITMODE)\n\t\t;\n\n\t \n\t \n\n\twhile ((termios->c_cflag & CSIZE) != CS8 &&\n\t       (termios->c_cflag & CSIZE) != CS7) {\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\ttermios->c_cflag |= old_csize;\n\t\told_csize = CS8;\n\t}\n\n\tif ((termios->c_cflag & CSIZE) == CS7) {\n\t\t \n\t\tcr = old_cr & ~LINFLEXD_UARTCR_WL1 & ~LINFLEXD_UARTCR_WL0;\n\t}\n\n\tif ((termios->c_cflag & CSIZE) == CS8) {\n\t\t \n\t\tcr = (old_cr | LINFLEXD_UARTCR_WL0) & ~LINFLEXD_UARTCR_WL1;\n\t}\n\n\tif (termios->c_cflag & CMSPAR) {\n\t\tif ((termios->c_cflag & CSIZE) != CS8) {\n\t\t\ttermios->c_cflag &= ~CSIZE;\n\t\t\ttermios->c_cflag |= CS8;\n\t\t}\n\t\t \n\t\tcr |= LINFLEXD_UARTCR_WL0;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\ttermios->c_cflag &= ~CSTOPB;\n\n\t \n\tif ((termios->c_cflag & CSIZE) == CS7)\n\t\ttermios->c_cflag |= PARENB;\n\n\tif ((termios->c_cflag & PARENB)) {\n\t\tcr |= LINFLEXD_UARTCR_PCE;\n\t\tif (termios->c_cflag & PARODD)\n\t\t\tcr = (cr | LINFLEXD_UARTCR_PC0) &\n\t\t\t     (~LINFLEXD_UARTCR_PC1);\n\t\telse\n\t\t\tcr = cr & (~LINFLEXD_UARTCR_PC1 &\n\t\t\t\t   ~LINFLEXD_UARTCR_PC0);\n\t} else {\n\t\tcr &= ~LINFLEXD_UARTCR_PCE;\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tport->read_status_mask = 0;\n\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |=\t(LINFLEXD_UARTSR_FEF |\n\t\t\t\t\t\t LINFLEXD_UARTSR_PE0 |\n\t\t\t\t\t\t LINFLEXD_UARTSR_PE1 |\n\t\t\t\t\t\t LINFLEXD_UARTSR_PE2 |\n\t\t\t\t\t\t LINFLEXD_UARTSR_PE3);\n\tif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\n\t\tport->read_status_mask |= LINFLEXD_UARTSR_FEF;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= LINFLEXD_UARTSR_PE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= LINFLEXD_UARTSR_PE;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= LINFLEXD_UARTSR_BOF;\n\t}\n\n\twritel(cr, port->membase + UARTCR);\n\n\tcr1 &= ~(LINFLEXD_LINCR1_INIT);\n\n\twritel(cr1, port->membase + LINCR1);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic const char *linflex_type(struct uart_port *port)\n{\n\treturn \"FSL_LINFLEX\";\n}\n\nstatic void linflex_release_port(struct uart_port *port)\n{\n\t \n}\n\nstatic int linflex_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\n \nstatic void linflex_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE)\n\t\tport->type = PORT_LINFLEXUART;\n}\n\nstatic const struct uart_ops linflex_pops = {\n\t.tx_empty\t= linflex_tx_empty,\n\t.set_mctrl\t= linflex_set_mctrl,\n\t.get_mctrl\t= linflex_get_mctrl,\n\t.stop_tx\t= linflex_stop_tx,\n\t.start_tx\t= linflex_start_tx,\n\t.stop_rx\t= linflex_stop_rx,\n\t.break_ctl\t= linflex_break_ctl,\n\t.startup\t= linflex_startup,\n\t.shutdown\t= linflex_shutdown,\n\t.set_termios\t= linflex_set_termios,\n\t.type\t\t= linflex_type,\n\t.request_port\t= linflex_request_port,\n\t.release_port\t= linflex_release_port,\n\t.config_port\t= linflex_config_port,\n};\n\nstatic struct uart_port *linflex_ports[UART_NR];\n\n#ifdef CONFIG_SERIAL_FSL_LINFLEXUART_CONSOLE\nstatic void linflex_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tunsigned long cr;\n\n\tcr = readl(port->membase + UARTCR);\n\n\twriteb(ch, port->membase + BDRL);\n\n\tif (!(cr & LINFLEXD_UARTCR_TFBM))\n\t\twhile ((readl(port->membase + UARTSR) &\n\t\t\t\t\tLINFLEXD_UARTSR_DTFTFF)\n\t\t\t\t!= LINFLEXD_UARTSR_DTFTFF)\n\t\t\t;\n\telse\n\t\twhile (readl(port->membase + UARTSR) &\n\t\t\t\t\tLINFLEXD_UARTSR_DTFTFF)\n\t\t\t;\n\n\tif (!(cr & LINFLEXD_UARTCR_TFBM)) {\n\t\twritel((readl(port->membase + UARTSR) |\n\t\t\t\t\tLINFLEXD_UARTSR_DTFTFF),\n\t\t\t\t\tport->membase + UARTSR);\n\t}\n}\n\nstatic void linflex_earlycon_putchar(struct uart_port *port, unsigned char ch)\n{\n\tunsigned long flags;\n\tchar *ret;\n\n\tif (!linflex_earlycon_same_instance) {\n\t\tlinflex_console_putchar(port, ch);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&init_lock, flags);\n\tif (!during_init)\n\t\tgoto outside_init;\n\n\tif (earlycon_buf.len >= 1 << CONFIG_LOG_BUF_SHIFT)\n\t\tgoto init_release;\n\n\tif (!earlycon_buf.cap) {\n\t\tearlycon_buf.content = kmalloc(EARLYCON_BUFFER_INITIAL_CAP,\n\t\t\t\t\t       GFP_ATOMIC);\n\t\tearlycon_buf.cap = earlycon_buf.content ?\n\t\t\t\t   EARLYCON_BUFFER_INITIAL_CAP : 0;\n\t} else if (earlycon_buf.len == earlycon_buf.cap) {\n\t\tret = krealloc(earlycon_buf.content, earlycon_buf.cap << 1,\n\t\t\t       GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tearlycon_buf.content = ret;\n\t\t\tearlycon_buf.cap <<= 1;\n\t\t}\n\t}\n\n\tif (earlycon_buf.len < earlycon_buf.cap)\n\t\tearlycon_buf.content[earlycon_buf.len++] = ch;\n\n\tgoto init_release;\n\noutside_init:\n\tlinflex_console_putchar(port, ch);\ninit_release:\n\tspin_unlock_irqrestore(&init_lock, flags);\n}\n\nstatic void linflex_string_write(struct uart_port *sport, const char *s,\n\t\t\t\t unsigned int count)\n{\n\tunsigned long cr, ier = 0;\n\n\tier = readl(sport->membase + LINIER);\n\tlinflex_stop_tx(sport);\n\n\tcr = readl(sport->membase + UARTCR);\n\tcr |= (LINFLEXD_UARTCR_TXEN);\n\twritel(cr, sport->membase + UARTCR);\n\n\tuart_console_write(sport, s, count, linflex_console_putchar);\n\n\twritel(ier, sport->membase + LINIER);\n}\n\nstatic void\nlinflex_console_write(struct console *co, const char *s, unsigned int count)\n{\n\tstruct uart_port *sport = linflex_ports[co->index];\n\tunsigned long flags;\n\tint locked = 1;\n\n\tif (sport->sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock_irqsave(&sport->lock, flags);\n\telse\n\t\tspin_lock_irqsave(&sport->lock, flags);\n\n\tlinflex_string_write(sport, s, count);\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&sport->lock, flags);\n}\n\n \nstatic void __init\nlinflex_console_get_options(struct uart_port *sport, int *parity, int *bits)\n{\n\tunsigned long cr;\n\n\tcr = readl(sport->membase + UARTCR);\n\tcr &= LINFLEXD_UARTCR_RXEN | LINFLEXD_UARTCR_TXEN;\n\n\tif (!cr)\n\t\treturn;\n\n\t \n\n\t*parity = 'n';\n\tif (cr & LINFLEXD_UARTCR_PCE) {\n\t\tif (cr & LINFLEXD_UARTCR_PC0)\n\t\t\t*parity = 'o';\n\t\telse\n\t\t\t*parity = 'e';\n\t}\n\n\tif ((cr & LINFLEXD_UARTCR_WL0) && ((cr & LINFLEXD_UARTCR_WL1) == 0)) {\n\t\tif (cr & LINFLEXD_UARTCR_PCE)\n\t\t\t*bits = 9;\n\t\telse\n\t\t\t*bits = 8;\n\t}\n}\n\nstatic int __init linflex_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *sport;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\tint ret;\n\tint i;\n\tunsigned long flags;\n\t \n\tif (co->index == -1 || co->index >= ARRAY_SIZE(linflex_ports))\n\t\tco->index = 0;\n\n\tsport = linflex_ports[co->index];\n\tif (!sport)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\telse\n\t\tlinflex_console_get_options(sport, &parity, &bits);\n\n\tif (earlycon_port && sport->mapbase == earlycon_port->mapbase) {\n\t\tlinflex_earlycon_same_instance = true;\n\n\t\tspin_lock_irqsave(&init_lock, flags);\n\t\tduring_init = true;\n\t\tspin_unlock_irqrestore(&init_lock, flags);\n\n\t\t \n\t\tudelay(PREINIT_DELAY);\n\t}\n\n\tlinflex_setup_watermark(sport);\n\n\tret = uart_set_options(sport, co, baud, parity, bits, flow);\n\n\tif (!linflex_earlycon_same_instance)\n\t\tgoto done;\n\n\tspin_lock_irqsave(&init_lock, flags);\n\n\t \n\tif (earlycon_buf.len) {\n\t\tfor (i = 0; i < earlycon_buf.len; i++)\n\t\t\tlinflex_console_putchar(earlycon_port,\n\t\t\t\tearlycon_buf.content[i]);\n\n\t\tkfree(earlycon_buf.content);\n\t\tearlycon_buf.len = 0;\n\t}\n\n\tduring_init = false;\n\tspin_unlock_irqrestore(&init_lock, flags);\n\ndone:\n\treturn ret;\n}\n\nstatic struct uart_driver linflex_reg;\nstatic struct console linflex_console = {\n\t.name\t\t= DEV_NAME,\n\t.write\t\t= linflex_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= linflex_console_setup,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n\t.data\t\t= &linflex_reg,\n};\n\nstatic void linflex_earlycon_write(struct console *con, const char *s,\n\t\t\t\t   unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, linflex_earlycon_putchar);\n}\n\nstatic int __init linflex_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t      const char *options)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = linflex_earlycon_write;\n\tearlycon_port = &device->port;\n\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(linflex, \"fsl,s32v234-linflexuart\",\n\t\t    linflex_early_console_setup);\n\n#define LINFLEX_CONSOLE\t(&linflex_console)\n#else\n#define LINFLEX_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver linflex_reg = {\n\t.owner\t\t= THIS_MODULE,\n\t.driver_name\t= DRIVER_NAME,\n\t.dev_name\t= DEV_NAME,\n\t.nr\t\t= ARRAY_SIZE(linflex_ports),\n\t.cons\t\t= LINFLEX_CONSOLE,\n};\n\nstatic int linflex_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct uart_port *sport;\n\tstruct resource *res;\n\tint ret;\n\n\tsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\n\tif (!sport)\n\t\treturn -ENOMEM;\n\n\tret = of_alias_get_id(np, \"serial\");\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias id, errno %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (ret >= UART_NR) {\n\t\tdev_err(&pdev->dev, \"driver limited to %d serial ports\\n\",\n\t\t\tUART_NR);\n\t\treturn -ENOMEM;\n\t}\n\n\tsport->line = ret;\n\n\tsport->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(sport->membase))\n\t\treturn PTR_ERR(sport->membase);\n\tsport->mapbase = res->start;\n\n\tsport->dev = &pdev->dev;\n\tsport->type = PORT_LINFLEXUART;\n\tsport->iotype = UPIO_MEM;\n\tsport->irq = platform_get_irq(pdev, 0);\n\tsport->ops = &linflex_pops;\n\tsport->flags = UPF_BOOT_AUTOCONF;\n\tsport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_FSL_LINFLEXUART_CONSOLE);\n\n\tlinflex_ports[sport->line] = sport;\n\n\tplatform_set_drvdata(pdev, sport);\n\n\treturn uart_add_one_port(&linflex_reg, sport);\n}\n\nstatic int linflex_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *sport = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&linflex_reg, sport);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int linflex_suspend(struct device *dev)\n{\n\tstruct uart_port *sport = dev_get_drvdata(dev);\n\n\tuart_suspend_port(&linflex_reg, sport);\n\n\treturn 0;\n}\n\nstatic int linflex_resume(struct device *dev)\n{\n\tstruct uart_port *sport = dev_get_drvdata(dev);\n\n\tuart_resume_port(&linflex_reg, sport);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(linflex_pm_ops, linflex_suspend, linflex_resume);\n\nstatic struct platform_driver linflex_driver = {\n\t.probe\t\t= linflex_probe,\n\t.remove\t\t= linflex_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table\t= linflex_dt_ids,\n\t\t.pm\t= &linflex_pm_ops,\n\t},\n};\n\nstatic int __init linflex_serial_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&linflex_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&linflex_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&linflex_reg);\n\n\treturn ret;\n}\n\nstatic void __exit linflex_serial_exit(void)\n{\n\tplatform_driver_unregister(&linflex_driver);\n\tuart_unregister_driver(&linflex_reg);\n}\n\nmodule_init(linflex_serial_init);\nmodule_exit(linflex_serial_exit);\n\nMODULE_DESCRIPTION(\"Freescale LINFlexD serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}