{
  "module_name": "lantiq.c",
  "hash_id": "351debd58dd58322a56d1fb381c7cba1e8995f5551080578fdbf791cfae5f618",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/lantiq.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/lantiq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/slab.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#define PORT_LTQ_ASC\t\t111\n#define MAXPORTS\t\t2\n#define UART_DUMMY_UER_RX\t1\n#define DRVNAME\t\t\t\"lantiq,asc\"\n#ifdef __BIG_ENDIAN\n#define LTQ_ASC_TBUF\t\t(0x0020 + 3)\n#define LTQ_ASC_RBUF\t\t(0x0024 + 3)\n#else\n#define LTQ_ASC_TBUF\t\t0x0020\n#define LTQ_ASC_RBUF\t\t0x0024\n#endif\n#define LTQ_ASC_FSTAT\t\t0x0048\n#define LTQ_ASC_WHBSTATE\t0x0018\n#define LTQ_ASC_STATE\t\t0x0014\n#define LTQ_ASC_IRNCR\t\t0x00F8\n#define LTQ_ASC_CLC\t\t0x0000\n#define LTQ_ASC_ID\t\t0x0008\n#define LTQ_ASC_PISEL\t\t0x0004\n#define LTQ_ASC_TXFCON\t\t0x0044\n#define LTQ_ASC_RXFCON\t\t0x0040\n#define LTQ_ASC_CON\t\t0x0010\n#define LTQ_ASC_BG\t\t0x0050\n#define LTQ_ASC_IRNREN\t\t0x00F4\n\n#define ASC_IRNREN_TX\t\t0x1\n#define ASC_IRNREN_RX\t\t0x2\n#define ASC_IRNREN_ERR\t\t0x4\n#define ASC_IRNREN_TX_BUF\t0x8\n#define ASC_IRNCR_TIR\t\t0x1\n#define ASC_IRNCR_RIR\t\t0x2\n#define ASC_IRNCR_EIR\t\t0x4\n#define ASC_IRNCR_MASK\t\tGENMASK(2, 0)\n\n#define ASCOPT_CSIZE\t\t0x3\n#define TXFIFO_FL\t\t1\n#define RXFIFO_FL\t\t1\n#define ASCCLC_DISS\t\t0x2\n#define ASCCLC_RMCMASK\t\t0x0000FF00\n#define ASCCLC_RMCOFFSET\t8\n#define ASCCON_M_8ASYNC\t\t0x0\n#define ASCCON_M_7ASYNC\t\t0x2\n#define ASCCON_ODD\t\t0x00000020\n#define ASCCON_STP\t\t0x00000080\n#define ASCCON_BRS\t\t0x00000100\n#define ASCCON_FDE\t\t0x00000200\n#define ASCCON_R\t\t0x00008000\n#define ASCCON_FEN\t\t0x00020000\n#define ASCCON_ROEN\t\t0x00080000\n#define ASCCON_TOEN\t\t0x00100000\n#define ASCSTATE_PE\t\t0x00010000\n#define ASCSTATE_FE\t\t0x00020000\n#define ASCSTATE_ROE\t\t0x00080000\n#define ASCSTATE_ANY\t\t(ASCSTATE_ROE|ASCSTATE_PE|ASCSTATE_FE)\n#define ASCWHBSTATE_CLRREN\t0x00000001\n#define ASCWHBSTATE_SETREN\t0x00000002\n#define ASCWHBSTATE_CLRPE\t0x00000004\n#define ASCWHBSTATE_CLRFE\t0x00000008\n#define ASCWHBSTATE_CLRROE\t0x00000020\n#define ASCTXFCON_TXFEN\t\t0x0001\n#define ASCTXFCON_TXFFLU\t0x0002\n#define ASCTXFCON_TXFITLMASK\t0x3F00\n#define ASCTXFCON_TXFITLOFF\t8\n#define ASCRXFCON_RXFEN\t\t0x0001\n#define ASCRXFCON_RXFFLU\t0x0002\n#define ASCRXFCON_RXFITLMASK\t0x3F00\n#define ASCRXFCON_RXFITLOFF\t8\n#define ASCFSTAT_RXFFLMASK\t0x003F\n#define ASCFSTAT_TXFFLMASK\t0x3F00\n#define ASCFSTAT_TXFREEMASK\t0x3F000000\n\nstatic struct ltq_uart_port *lqasc_port[MAXPORTS];\nstatic struct uart_driver lqasc_reg;\n\nstruct ltq_soc_data {\n\tint\t(*fetch_irq)(struct device *dev, struct ltq_uart_port *ltq_port);\n\tint\t(*request_irq)(struct uart_port *port);\n\tvoid\t(*free_irq)(struct uart_port *port);\n};\n\nstruct ltq_uart_port {\n\tstruct uart_port\tport;\n\t \n\tstruct clk\t\t*freqclk;\n\t \n\tstruct clk\t\t*clk;\n\tunsigned int\t\ttx_irq;\n\tunsigned int\t\trx_irq;\n\tunsigned int\t\terr_irq;\n\tunsigned int\t\tcommon_irq;\n\tspinlock_t\t\tlock;  \n\n\tconst struct ltq_soc_data\t*soc;\n};\n\nstatic inline void asc_update_bits(u32 clear, u32 set, void __iomem *reg)\n{\n\tu32 tmp = __raw_readl(reg);\n\n\t__raw_writel((tmp & ~clear) | set, reg);\n}\n\nstatic inline struct\nltq_uart_port *to_ltq_uart_port(struct uart_port *port)\n{\n\treturn container_of(port, struct ltq_uart_port, port);\n}\n\nstatic void\nlqasc_stop_tx(struct uart_port *port)\n{\n\treturn;\n}\n\nstatic bool lqasc_tx_ready(struct uart_port *port)\n{\n\tu32 fstat = __raw_readl(port->membase + LTQ_ASC_FSTAT);\n\n\treturn FIELD_GET(ASCFSTAT_TXFREEMASK, fstat);\n}\n\nstatic void\nlqasc_start_tx(struct uart_port *port)\n{\n\tunsigned long flags;\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\tu8 ch;\n\n\tspin_lock_irqsave(&ltq_port->lock, flags);\n\tuart_port_tx(port, ch,\n\t\tlqasc_tx_ready(port),\n\t\twriteb(ch, port->membase + LTQ_ASC_TBUF));\n\tspin_unlock_irqrestore(&ltq_port->lock, flags);\n\treturn;\n}\n\nstatic void\nlqasc_stop_rx(struct uart_port *port)\n{\n\t__raw_writel(ASCWHBSTATE_CLRREN, port->membase + LTQ_ASC_WHBSTATE);\n}\n\nstatic int\nlqasc_rx_chars(struct uart_port *port)\n{\n\tstruct tty_port *tport = &port->state->port;\n\tunsigned int ch = 0, rsr = 0, fifocnt;\n\n\tfifocnt = __raw_readl(port->membase + LTQ_ASC_FSTAT) &\n\t\t  ASCFSTAT_RXFFLMASK;\n\twhile (fifocnt--) {\n\t\tu8 flag = TTY_NORMAL;\n\t\tch = readb(port->membase + LTQ_ASC_RBUF);\n\t\trsr = (__raw_readl(port->membase + LTQ_ASC_STATE)\n\t\t\t& ASCSTATE_ANY) | UART_DUMMY_UER_RX;\n\t\ttty_flip_buffer_push(tport);\n\t\tport->icount.rx++;\n\n\t\t \n\t\tif (rsr & ASCSTATE_ANY) {\n\t\t\tif (rsr & ASCSTATE_PE) {\n\t\t\t\tport->icount.parity++;\n\t\t\t\tasc_update_bits(0, ASCWHBSTATE_CLRPE,\n\t\t\t\t\tport->membase + LTQ_ASC_WHBSTATE);\n\t\t\t} else if (rsr & ASCSTATE_FE) {\n\t\t\t\tport->icount.frame++;\n\t\t\t\tasc_update_bits(0, ASCWHBSTATE_CLRFE,\n\t\t\t\t\tport->membase + LTQ_ASC_WHBSTATE);\n\t\t\t}\n\t\t\tif (rsr & ASCSTATE_ROE) {\n\t\t\t\tport->icount.overrun++;\n\t\t\t\tasc_update_bits(0, ASCWHBSTATE_CLRROE,\n\t\t\t\t\tport->membase + LTQ_ASC_WHBSTATE);\n\t\t\t}\n\n\t\t\trsr &= port->read_status_mask;\n\n\t\t\tif (rsr & ASCSTATE_PE)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (rsr & ASCSTATE_FE)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif ((rsr & port->ignore_status_mask) == 0)\n\t\t\ttty_insert_flip_char(tport, ch, flag);\n\n\t\tif (rsr & ASCSTATE_ROE)\n\t\t\t \n\t\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\t}\n\n\tif (ch != 0)\n\t\ttty_flip_buffer_push(tport);\n\n\treturn 0;\n}\n\nstatic irqreturn_t\nlqasc_tx_int(int irq, void *_port)\n{\n\tunsigned long flags;\n\tstruct uart_port *port = (struct uart_port *)_port;\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\n\tspin_lock_irqsave(&ltq_port->lock, flags);\n\t__raw_writel(ASC_IRNCR_TIR, port->membase + LTQ_ASC_IRNCR);\n\tspin_unlock_irqrestore(&ltq_port->lock, flags);\n\tlqasc_start_tx(port);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\nlqasc_err_int(int irq, void *_port)\n{\n\tunsigned long flags;\n\tstruct uart_port *port = (struct uart_port *)_port;\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\n\tspin_lock_irqsave(&ltq_port->lock, flags);\n\t__raw_writel(ASC_IRNCR_EIR, port->membase + LTQ_ASC_IRNCR);\n\t \n\tasc_update_bits(0, ASCWHBSTATE_CLRPE | ASCWHBSTATE_CLRFE |\n\t\tASCWHBSTATE_CLRROE, port->membase + LTQ_ASC_WHBSTATE);\n\tspin_unlock_irqrestore(&ltq_port->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\nlqasc_rx_int(int irq, void *_port)\n{\n\tunsigned long flags;\n\tstruct uart_port *port = (struct uart_port *)_port;\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\n\tspin_lock_irqsave(&ltq_port->lock, flags);\n\t__raw_writel(ASC_IRNCR_RIR, port->membase + LTQ_ASC_IRNCR);\n\tlqasc_rx_chars(port);\n\tspin_unlock_irqrestore(&ltq_port->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t lqasc_irq(int irq, void *p)\n{\n\tunsigned long flags;\n\tu32 stat;\n\tstruct uart_port *port = p;\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\n\tspin_lock_irqsave(&ltq_port->lock, flags);\n\tstat = readl(port->membase + LTQ_ASC_IRNCR);\n\tspin_unlock_irqrestore(&ltq_port->lock, flags);\n\tif (!(stat & ASC_IRNCR_MASK))\n\t\treturn IRQ_NONE;\n\n\tif (stat & ASC_IRNCR_TIR)\n\t\tlqasc_tx_int(irq, p);\n\n\tif (stat & ASC_IRNCR_RIR)\n\t\tlqasc_rx_int(irq, p);\n\n\tif (stat & ASC_IRNCR_EIR)\n\t\tlqasc_err_int(irq, p);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int\nlqasc_tx_empty(struct uart_port *port)\n{\n\tint status;\n\tstatus = __raw_readl(port->membase + LTQ_ASC_FSTAT) &\n\t\t ASCFSTAT_TXFFLMASK;\n\treturn status ? 0 : TIOCSER_TEMT;\n}\n\nstatic unsigned int\nlqasc_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CTS | TIOCM_CAR | TIOCM_DSR;\n}\n\nstatic void\nlqasc_set_mctrl(struct uart_port *port, u_int mctrl)\n{\n}\n\nstatic void\nlqasc_break_ctl(struct uart_port *port, int break_state)\n{\n}\n\nstatic int\nlqasc_startup(struct uart_port *port)\n{\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\tint retval;\n\tunsigned long flags;\n\n\tif (!IS_ERR(ltq_port->clk))\n\t\tclk_prepare_enable(ltq_port->clk);\n\tport->uartclk = clk_get_rate(ltq_port->freqclk);\n\n\tspin_lock_irqsave(&ltq_port->lock, flags);\n\tasc_update_bits(ASCCLC_DISS | ASCCLC_RMCMASK, (1 << ASCCLC_RMCOFFSET),\n\t\tport->membase + LTQ_ASC_CLC);\n\n\t__raw_writel(0, port->membase + LTQ_ASC_PISEL);\n\t__raw_writel(\n\t\t((TXFIFO_FL << ASCTXFCON_TXFITLOFF) & ASCTXFCON_TXFITLMASK) |\n\t\tASCTXFCON_TXFEN | ASCTXFCON_TXFFLU,\n\t\tport->membase + LTQ_ASC_TXFCON);\n\t__raw_writel(\n\t\t((RXFIFO_FL << ASCRXFCON_RXFITLOFF) & ASCRXFCON_RXFITLMASK)\n\t\t| ASCRXFCON_RXFEN | ASCRXFCON_RXFFLU,\n\t\tport->membase + LTQ_ASC_RXFCON);\n\t \n\twmb();\n\tasc_update_bits(0, ASCCON_M_8ASYNC | ASCCON_FEN | ASCCON_TOEN |\n\t\tASCCON_ROEN, port->membase + LTQ_ASC_CON);\n\n\tspin_unlock_irqrestore(&ltq_port->lock, flags);\n\n\tretval = ltq_port->soc->request_irq(port);\n\tif (retval)\n\t\treturn retval;\n\n\t__raw_writel(ASC_IRNREN_RX | ASC_IRNREN_ERR | ASC_IRNREN_TX,\n\t\tport->membase + LTQ_ASC_IRNREN);\n\treturn retval;\n}\n\nstatic void\nlqasc_shutdown(struct uart_port *port)\n{\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\tunsigned long flags;\n\n\tltq_port->soc->free_irq(port);\n\n\tspin_lock_irqsave(&ltq_port->lock, flags);\n\t__raw_writel(0, port->membase + LTQ_ASC_CON);\n\tasc_update_bits(ASCRXFCON_RXFEN, ASCRXFCON_RXFFLU,\n\t\tport->membase + LTQ_ASC_RXFCON);\n\tasc_update_bits(ASCTXFCON_TXFEN, ASCTXFCON_TXFFLU,\n\t\tport->membase + LTQ_ASC_TXFCON);\n\tspin_unlock_irqrestore(&ltq_port->lock, flags);\n\tif (!IS_ERR(ltq_port->clk))\n\t\tclk_disable_unprepare(ltq_port->clk);\n}\n\nstatic void\nlqasc_set_termios(struct uart_port *port, struct ktermios *new,\n\t\t  const struct ktermios *old)\n{\n\tunsigned int cflag;\n\tunsigned int iflag;\n\tunsigned int divisor;\n\tunsigned int baud;\n\tunsigned int con = 0;\n\tunsigned long flags;\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\n\tcflag = new->c_cflag;\n\tiflag = new->c_iflag;\n\n\tswitch (cflag & CSIZE) {\n\tcase CS7:\n\t\tcon = ASCCON_M_7ASYNC;\n\t\tbreak;\n\n\tcase CS5:\n\tcase CS6:\n\tdefault:\n\t\tnew->c_cflag &= ~ CSIZE;\n\t\tnew->c_cflag |= CS8;\n\t\tcon = ASCCON_M_8ASYNC;\n\t\tbreak;\n\t}\n\n\tcflag &= ~CMSPAR;  \n\n\tif (cflag & CSTOPB)\n\t\tcon |= ASCCON_STP;\n\n\tif (cflag & PARENB) {\n\t\tif (!(cflag & PARODD))\n\t\t\tcon &= ~ASCCON_ODD;\n\t\telse\n\t\t\tcon |= ASCCON_ODD;\n\t}\n\n\tport->read_status_mask = ASCSTATE_ROE;\n\tif (iflag & INPCK)\n\t\tport->read_status_mask |= ASCSTATE_FE | ASCSTATE_PE;\n\n\tport->ignore_status_mask = 0;\n\tif (iflag & IGNPAR)\n\t\tport->ignore_status_mask |= ASCSTATE_FE | ASCSTATE_PE;\n\n\tif (iflag & IGNBRK) {\n\t\t \n\t\tif (iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= ASCSTATE_ROE;\n\t}\n\n\tif ((cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= UART_DUMMY_UER_RX;\n\n\t \n\tcon |= ASCCON_FEN | ASCCON_TOEN | ASCCON_ROEN;\n\n\tspin_lock_irqsave(&ltq_port->lock, flags);\n\n\t \n\tasc_update_bits(0, con, port->membase + LTQ_ASC_CON);\n\n\t \n\tbaud = uart_get_baud_rate(port, new, old, 0, port->uartclk / 16);\n\tdivisor = uart_get_divisor(port, baud);\n\tdivisor = divisor / 2 - 1;\n\n\t \n\tasc_update_bits(ASCCON_R, 0, port->membase + LTQ_ASC_CON);\n\n\t \n\tasc_update_bits(ASCCON_FDE, 0, port->membase + LTQ_ASC_CON);\n\n\t \n\tasc_update_bits(ASCCON_BRS, 0, port->membase + LTQ_ASC_CON);\n\n\t \n\t__raw_writel(divisor, port->membase + LTQ_ASC_BG);\n\n\t \n\tasc_update_bits(0, ASCCON_R, port->membase + LTQ_ASC_CON);\n\n\t \n\t__raw_writel(ASCWHBSTATE_SETREN, port->membase + LTQ_ASC_WHBSTATE);\n\n\tspin_unlock_irqrestore(&ltq_port->lock, flags);\n\n\t \n\tif (tty_termios_baud_rate(new))\n\t\ttty_termios_encode_baud_rate(new, baud, baud);\n\n\tuart_update_timeout(port, cflag, baud);\n}\n\nstatic const char*\nlqasc_type(struct uart_port *port)\n{\n\tif (port->type == PORT_LTQ_ASC)\n\t\treturn DRVNAME;\n\telse\n\t\treturn NULL;\n}\n\nstatic void\nlqasc_release_port(struct uart_port *port)\n{\n\tstruct platform_device *pdev = to_platform_device(port->dev);\n\n\tif (port->flags & UPF_IOREMAP) {\n\t\tdevm_iounmap(&pdev->dev, port->membase);\n\t\tport->membase = NULL;\n\t}\n}\n\nstatic int\nlqasc_request_port(struct uart_port *port)\n{\n\tstruct platform_device *pdev = to_platform_device(port->dev);\n\tstruct resource *res;\n\tint size;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"cannot obtain I/O memory region\");\n\t\treturn -ENODEV;\n\t}\n\tsize = resource_size(res);\n\n\tres = devm_request_mem_region(&pdev->dev, res->start,\n\t\tsize, dev_name(&pdev->dev));\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"cannot request I/O memory region\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (port->flags & UPF_IOREMAP) {\n\t\tport->membase = devm_ioremap(&pdev->dev,\n\t\t\tport->mapbase, size);\n\t\tif (port->membase == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void\nlqasc_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_LTQ_ASC;\n\t\tlqasc_request_port(port);\n\t}\n}\n\nstatic int\nlqasc_verify_port(struct uart_port *port,\n\tstruct serial_struct *ser)\n{\n\tint ret = 0;\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_LTQ_ASC)\n\t\tret = -EINVAL;\n\tif (ser->irq < 0 || ser->irq >= NR_IRQS)\n\t\tret = -EINVAL;\n\tif (ser->baud_base < 9600)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\nstatic const struct uart_ops lqasc_pops = {\n\t.tx_empty =\tlqasc_tx_empty,\n\t.set_mctrl =\tlqasc_set_mctrl,\n\t.get_mctrl =\tlqasc_get_mctrl,\n\t.stop_tx =\tlqasc_stop_tx,\n\t.start_tx =\tlqasc_start_tx,\n\t.stop_rx =\tlqasc_stop_rx,\n\t.break_ctl =\tlqasc_break_ctl,\n\t.startup =\tlqasc_startup,\n\t.shutdown =\tlqasc_shutdown,\n\t.set_termios =\tlqasc_set_termios,\n\t.type =\t\tlqasc_type,\n\t.release_port =\tlqasc_release_port,\n\t.request_port =\tlqasc_request_port,\n\t.config_port =\tlqasc_config_port,\n\t.verify_port =\tlqasc_verify_port,\n};\n\n#ifdef CONFIG_SERIAL_LANTIQ_CONSOLE\nstatic void\nlqasc_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tif (!port->membase)\n\t\treturn;\n\n\twhile (!lqasc_tx_ready(port))\n\t\t;\n\n\twriteb(ch, port->membase + LTQ_ASC_TBUF);\n}\n\nstatic void lqasc_serial_port_write(struct uart_port *port, const char *s,\n\t\t\t\t    u_int count)\n{\n\tuart_console_write(port, s, count, lqasc_console_putchar);\n}\n\nstatic void\nlqasc_console_write(struct console *co, const char *s, u_int count)\n{\n\tstruct ltq_uart_port *ltq_port;\n\tunsigned long flags;\n\n\tif (co->index >= MAXPORTS)\n\t\treturn;\n\n\tltq_port = lqasc_port[co->index];\n\tif (!ltq_port)\n\t\treturn;\n\n\tspin_lock_irqsave(&ltq_port->lock, flags);\n\tlqasc_serial_port_write(&ltq_port->port, s, count);\n\tspin_unlock_irqrestore(&ltq_port->lock, flags);\n}\n\nstatic int __init\nlqasc_console_setup(struct console *co, char *options)\n{\n\tstruct ltq_uart_port *ltq_port;\n\tstruct uart_port *port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index >= MAXPORTS)\n\t\treturn -ENODEV;\n\n\tltq_port = lqasc_port[co->index];\n\tif (!ltq_port)\n\t\treturn -ENODEV;\n\n\tport = &ltq_port->port;\n\n\tif (!IS_ERR(ltq_port->clk))\n\t\tclk_prepare_enable(ltq_port->clk);\n\n\tport->uartclk = clk_get_rate(ltq_port->freqclk);\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\treturn uart_set_options(port, co, baud, parity, bits, flow);\n}\n\nstatic struct console lqasc_console = {\n\t.name =\t\t\"ttyLTQ\",\n\t.write =\tlqasc_console_write,\n\t.device =\tuart_console_device,\n\t.setup =\tlqasc_console_setup,\n\t.flags =\tCON_PRINTBUFFER,\n\t.index =\t-1,\n\t.data =\t\t&lqasc_reg,\n};\n\nstatic int __init\nlqasc_console_init(void)\n{\n\tregister_console(&lqasc_console);\n\treturn 0;\n}\nconsole_initcall(lqasc_console_init);\n\nstatic void lqasc_serial_early_console_write(struct console *co,\n\t\t\t\t\t     const char *s,\n\t\t\t\t\t     u_int count)\n{\n\tstruct earlycon_device *dev = co->data;\n\n\tlqasc_serial_port_write(&dev->port, s, count);\n}\n\nstatic int __init\nlqasc_serial_early_console_setup(struct earlycon_device *device,\n\t\t\t\t const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = lqasc_serial_early_console_write;\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(lantiq, \"lantiq,asc\", lqasc_serial_early_console_setup);\nOF_EARLYCON_DECLARE(lantiq, \"intel,lgm-asc\", lqasc_serial_early_console_setup);\n\n#define LANTIQ_SERIAL_CONSOLE\t(&lqasc_console)\n\n#else\n\n#define LANTIQ_SERIAL_CONSOLE\tNULL\n\n#endif  \n\nstatic struct uart_driver lqasc_reg = {\n\t.owner =\tTHIS_MODULE,\n\t.driver_name =\tDRVNAME,\n\t.dev_name =\t\"ttyLTQ\",\n\t.major =\t0,\n\t.minor =\t0,\n\t.nr =\t\tMAXPORTS,\n\t.cons =\t\tLANTIQ_SERIAL_CONSOLE,\n};\n\nstatic int fetch_irq_lantiq(struct device *dev, struct ltq_uart_port *ltq_port)\n{\n\tstruct uart_port *port = &ltq_port->port;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tltq_port->tx_irq = irq;\n\tirq = platform_get_irq(pdev, 1);\n\tif (irq < 0)\n\t\treturn irq;\n\tltq_port->rx_irq = irq;\n\tirq = platform_get_irq(pdev, 2);\n\tif (irq < 0)\n\t\treturn irq;\n\tltq_port->err_irq = irq;\n\n\tport->irq = ltq_port->tx_irq;\n\n\treturn 0;\n}\n\nstatic int request_irq_lantiq(struct uart_port *port)\n{\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\tint retval;\n\n\tretval = request_irq(ltq_port->tx_irq, lqasc_tx_int,\n\t\t\t     0, \"asc_tx\", port);\n\tif (retval) {\n\t\tdev_err(port->dev, \"failed to request asc_tx\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = request_irq(ltq_port->rx_irq, lqasc_rx_int,\n\t\t\t     0, \"asc_rx\", port);\n\tif (retval) {\n\t\tdev_err(port->dev, \"failed to request asc_rx\\n\");\n\t\tgoto err1;\n\t}\n\n\tretval = request_irq(ltq_port->err_irq, lqasc_err_int,\n\t\t\t     0, \"asc_err\", port);\n\tif (retval) {\n\t\tdev_err(port->dev, \"failed to request asc_err\\n\");\n\t\tgoto err2;\n\t}\n\treturn 0;\n\nerr2:\n\tfree_irq(ltq_port->rx_irq, port);\nerr1:\n\tfree_irq(ltq_port->tx_irq, port);\n\treturn retval;\n}\n\nstatic void free_irq_lantiq(struct uart_port *port)\n{\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\n\tfree_irq(ltq_port->tx_irq, port);\n\tfree_irq(ltq_port->rx_irq, port);\n\tfree_irq(ltq_port->err_irq, port);\n}\n\nstatic int fetch_irq_intel(struct device *dev, struct ltq_uart_port *ltq_port)\n{\n\tstruct uart_port *port = &ltq_port->port;\n\tint ret;\n\n\tret = platform_get_irq(to_platform_device(dev), 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to fetch IRQ for serial port\\n\");\n\t\treturn ret;\n\t}\n\tltq_port->common_irq = ret;\n\tport->irq = ret;\n\n\treturn 0;\n}\n\nstatic int request_irq_intel(struct uart_port *port)\n{\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\tint retval;\n\n\tretval = request_irq(ltq_port->common_irq, lqasc_irq, 0,\n\t\t\t     \"asc_irq\", port);\n\tif (retval)\n\t\tdev_err(port->dev, \"failed to request asc_irq\\n\");\n\n\treturn retval;\n}\n\nstatic void free_irq_intel(struct uart_port *port)\n{\n\tstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\n\n\tfree_irq(ltq_port->common_irq, port);\n}\n\nstatic int lqasc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct ltq_uart_port *ltq_port;\n\tstruct uart_port *port;\n\tstruct resource *mmres;\n\tint line;\n\tint ret;\n\n\tmmres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!mmres) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to get memory for serial port\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tltq_port = devm_kzalloc(&pdev->dev, sizeof(struct ltq_uart_port),\n\t\t\t\tGFP_KERNEL);\n\tif (!ltq_port)\n\t\treturn -ENOMEM;\n\n\tport = &ltq_port->port;\n\n\tltq_port->soc = of_device_get_match_data(&pdev->dev);\n\tret = ltq_port->soc->fetch_irq(&pdev->dev, ltq_port);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tline = of_alias_get_id(node, \"serial\");\n\tif (line < 0) {\n\t\tif (IS_ENABLED(CONFIG_LANTIQ)) {\n\t\t\tif (mmres->start == CPHYSADDR(LTQ_EARLY_ASC))\n\t\t\t\tline = 0;\n\t\t\telse\n\t\t\t\tline = 1;\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"failed to get alias id, errno %d\\n\",\n\t\t\t\tline);\n\t\t\treturn line;\n\t\t}\n\t}\n\n\tif (lqasc_port[line]) {\n\t\tdev_err(&pdev->dev, \"port %d already allocated\\n\", line);\n\t\treturn -EBUSY;\n\t}\n\n\tport->iotype\t= SERIAL_IO_MEM;\n\tport->flags\t= UPF_BOOT_AUTOCONF | UPF_IOREMAP;\n\tport->ops\t= &lqasc_pops;\n\tport->fifosize\t= 16;\n\tport->type\t= PORT_LTQ_ASC;\n\tport->line\t= line;\n\tport->dev\t= &pdev->dev;\n\t \n\tport->mapbase\t= mmres->start;\n\n\tif (IS_ENABLED(CONFIG_LANTIQ) && !IS_ENABLED(CONFIG_COMMON_CLK))\n\t\tltq_port->freqclk = clk_get_fpi();\n\telse\n\t\tltq_port->freqclk = devm_clk_get(&pdev->dev, \"freq\");\n\n\n\tif (IS_ERR(ltq_port->freqclk)) {\n\t\tpr_err(\"failed to get fpi clk\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_LANTIQ) && !IS_ENABLED(CONFIG_COMMON_CLK))\n\t\tltq_port->clk = clk_get(&pdev->dev, NULL);\n\telse\n\t\tltq_port->clk = devm_clk_get(&pdev->dev, \"asc\");\n\n\tspin_lock_init(&ltq_port->lock);\n\tlqasc_port[line] = ltq_port;\n\tplatform_set_drvdata(pdev, ltq_port);\n\n\tret = uart_add_one_port(&lqasc_reg, port);\n\n\treturn ret;\n}\n\nstatic int lqasc_remove(struct platform_device *pdev)\n{\n\tstruct uart_port *port = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&lqasc_reg, port);\n\n\treturn 0;\n}\n\nstatic const struct ltq_soc_data soc_data_lantiq = {\n\t.fetch_irq = fetch_irq_lantiq,\n\t.request_irq = request_irq_lantiq,\n\t.free_irq = free_irq_lantiq,\n};\n\nstatic const struct ltq_soc_data soc_data_intel = {\n\t.fetch_irq = fetch_irq_intel,\n\t.request_irq = request_irq_intel,\n\t.free_irq = free_irq_intel,\n};\n\nstatic const struct of_device_id ltq_asc_match[] = {\n\t{ .compatible = \"lantiq,asc\", .data = &soc_data_lantiq },\n\t{ .compatible = \"intel,lgm-asc\", .data = &soc_data_intel },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ltq_asc_match);\n\nstatic struct platform_driver lqasc_driver = {\n\t.probe\t\t= lqasc_probe,\n\t.remove\t\t= lqasc_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRVNAME,\n\t\t.of_match_table = ltq_asc_match,\n\t},\n};\n\nstatic int __init\ninit_lqasc(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&lqasc_reg);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = platform_driver_register(&lqasc_driver);\n\tif (ret != 0)\n\t\tuart_unregister_driver(&lqasc_reg);\n\n\treturn ret;\n}\n\nstatic void __exit exit_lqasc(void)\n{\n\tplatform_driver_unregister(&lqasc_driver);\n\tuart_unregister_driver(&lqasc_reg);\n}\n\nmodule_init(init_lqasc);\nmodule_exit(exit_lqasc);\n\nMODULE_DESCRIPTION(\"Serial driver for Lantiq & Intel gateway SoCs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}