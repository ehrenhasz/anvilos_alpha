{
  "module_name": "mps2-uart.c",
  "hash_id": "4b243b3ac7b10bf7e8d6378b4a578db0089e03e51e242521c1bb6343170c0edf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/mps2-uart.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/serial_core.h>\n#include <linux/tty_flip.h>\n#include <linux/types.h>\n#include <linux/idr.h>\n\n#define SERIAL_NAME\t\"ttyMPS\"\n#define DRIVER_NAME\t\"mps2-uart\"\n#define MAKE_NAME(x)\t(DRIVER_NAME # x)\n\n#define UARTn_DATA\t\t\t\t0x00\n\n#define UARTn_STATE\t\t\t\t0x04\n#define UARTn_STATE_TX_FULL\t\t\tBIT(0)\n#define UARTn_STATE_RX_FULL\t\t\tBIT(1)\n#define UARTn_STATE_TX_OVERRUN\t\t\tBIT(2)\n#define UARTn_STATE_RX_OVERRUN\t\t\tBIT(3)\n\n#define UARTn_CTRL\t\t\t\t0x08\n#define UARTn_CTRL_TX_ENABLE\t\t\tBIT(0)\n#define UARTn_CTRL_RX_ENABLE\t\t\tBIT(1)\n#define UARTn_CTRL_TX_INT_ENABLE\t\tBIT(2)\n#define UARTn_CTRL_RX_INT_ENABLE\t\tBIT(3)\n#define UARTn_CTRL_TX_OVERRUN_INT_ENABLE\tBIT(4)\n#define UARTn_CTRL_RX_OVERRUN_INT_ENABLE\tBIT(5)\n\n#define UARTn_INT\t\t\t\t0x0c\n#define UARTn_INT_TX\t\t\t\tBIT(0)\n#define UARTn_INT_RX\t\t\t\tBIT(1)\n#define UARTn_INT_TX_OVERRUN\t\t\tBIT(2)\n#define UARTn_INT_RX_OVERRUN\t\t\tBIT(3)\n\n#define UARTn_BAUDDIV\t\t\t\t0x10\n#define UARTn_BAUDDIV_MASK\t\t\tGENMASK(20, 0)\n\n \n#define UARTn_CTRL_TX_GRP\t(UARTn_CTRL_TX_ENABLE\t\t |\\\n\t\t\t\t UARTn_CTRL_TX_INT_ENABLE\t |\\\n\t\t\t\t UARTn_CTRL_TX_OVERRUN_INT_ENABLE)\n\n#define UARTn_CTRL_RX_GRP\t(UARTn_CTRL_RX_ENABLE\t\t |\\\n\t\t\t\t UARTn_CTRL_RX_INT_ENABLE\t |\\\n\t\t\t\t UARTn_CTRL_RX_OVERRUN_INT_ENABLE)\n\n#define MPS2_MAX_PORTS\t\t3\n\n#define UART_PORT_COMBINED_IRQ\tBIT(0)\n\nstruct mps2_uart_port {\n\tstruct uart_port port;\n\tstruct clk *clk;\n\tunsigned int tx_irq;\n\tunsigned int rx_irq;\n\tunsigned int flags;\n};\n\nstatic inline struct mps2_uart_port *to_mps2_port(struct uart_port *port)\n{\n\treturn container_of(port, struct mps2_uart_port, port);\n}\n\nstatic void mps2_uart_write8(struct uart_port *port, u8 val, unsigned int off)\n{\n\tstruct mps2_uart_port *mps_port = to_mps2_port(port);\n\n\twriteb(val, mps_port->port.membase + off);\n}\n\nstatic u8 mps2_uart_read8(struct uart_port *port, unsigned int off)\n{\n\tstruct mps2_uart_port *mps_port = to_mps2_port(port);\n\n\treturn readb(mps_port->port.membase + off);\n}\n\nstatic void mps2_uart_write32(struct uart_port *port, u32 val, unsigned int off)\n{\n\tstruct mps2_uart_port *mps_port = to_mps2_port(port);\n\n\twritel_relaxed(val, mps_port->port.membase + off);\n}\n\nstatic unsigned int mps2_uart_tx_empty(struct uart_port *port)\n{\n\tu8 status = mps2_uart_read8(port, UARTn_STATE);\n\n\treturn (status & UARTn_STATE_TX_FULL) ? 0 : TIOCSER_TEMT;\n}\n\nstatic void mps2_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n}\n\nstatic unsigned int mps2_uart_get_mctrl(struct uart_port *port)\n{\n\treturn TIOCM_CAR | TIOCM_CTS | TIOCM_DSR;\n}\n\nstatic void mps2_uart_stop_tx(struct uart_port *port)\n{\n\tu8 control = mps2_uart_read8(port, UARTn_CTRL);\n\n\tcontrol &= ~UARTn_CTRL_TX_INT_ENABLE;\n\n\tmps2_uart_write8(port, control, UARTn_CTRL);\n}\n\nstatic void mps2_uart_tx_chars(struct uart_port *port)\n{\n\tu8 ch;\n\n\tuart_port_tx(port, ch,\n\t\tmps2_uart_tx_empty(port),\n\t\tmps2_uart_write8(port, ch, UARTn_DATA));\n}\n\nstatic void mps2_uart_start_tx(struct uart_port *port)\n{\n\tu8 control = mps2_uart_read8(port, UARTn_CTRL);\n\n\tcontrol |= UARTn_CTRL_TX_INT_ENABLE;\n\n\tmps2_uart_write8(port, control, UARTn_CTRL);\n\n\t \n\n\tmps2_uart_tx_chars(port);\n}\n\nstatic void mps2_uart_stop_rx(struct uart_port *port)\n{\n\tu8 control = mps2_uart_read8(port, UARTn_CTRL);\n\n\tcontrol &= ~UARTn_CTRL_RX_GRP;\n\n\tmps2_uart_write8(port, control, UARTn_CTRL);\n}\n\nstatic void mps2_uart_break_ctl(struct uart_port *port, int ctl)\n{\n}\n\nstatic void mps2_uart_rx_chars(struct uart_port *port)\n{\n\tstruct tty_port *tport = &port->state->port;\n\n\twhile (mps2_uart_read8(port, UARTn_STATE) & UARTn_STATE_RX_FULL) {\n\t\tu8 rxdata = mps2_uart_read8(port, UARTn_DATA);\n\n\t\tport->icount.rx++;\n\t\ttty_insert_flip_char(&port->state->port, rxdata, TTY_NORMAL);\n\t}\n\n\ttty_flip_buffer_push(tport);\n}\n\nstatic irqreturn_t mps2_uart_rxirq(int irq, void *data)\n{\n\tstruct uart_port *port = data;\n\tu8 irqflag = mps2_uart_read8(port, UARTn_INT);\n\n\tif (unlikely(!(irqflag & UARTn_INT_RX)))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&port->lock);\n\n\tmps2_uart_write8(port, UARTn_INT_RX, UARTn_INT);\n\tmps2_uart_rx_chars(port);\n\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mps2_uart_txirq(int irq, void *data)\n{\n\tstruct uart_port *port = data;\n\tu8 irqflag = mps2_uart_read8(port, UARTn_INT);\n\n\tif (unlikely(!(irqflag & UARTn_INT_TX)))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&port->lock);\n\n\tmps2_uart_write8(port, UARTn_INT_TX, UARTn_INT);\n\tmps2_uart_tx_chars(port);\n\n\tspin_unlock(&port->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mps2_uart_oerrirq(int irq, void *data)\n{\n\tirqreturn_t handled = IRQ_NONE;\n\tstruct uart_port *port = data;\n\tu8 irqflag = mps2_uart_read8(port, UARTn_INT);\n\n\tspin_lock(&port->lock);\n\n\tif (irqflag & UARTn_INT_RX_OVERRUN) {\n\t\tstruct tty_port *tport = &port->state->port;\n\n\t\tmps2_uart_write8(port, UARTn_INT_RX_OVERRUN, UARTn_INT);\n\t\tport->icount.overrun++;\n\t\ttty_insert_flip_char(tport, 0, TTY_OVERRUN);\n\t\ttty_flip_buffer_push(tport);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\t \n\tif (irqflag & UARTn_INT_TX_OVERRUN) {\n\t\tmps2_uart_write8(port, UARTn_INT_TX_OVERRUN, UARTn_INT);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\tspin_unlock(&port->lock);\n\n\treturn handled;\n}\n\nstatic irqreturn_t mps2_uart_combinedirq(int irq, void *data)\n{\n\tif (mps2_uart_rxirq(irq, data) == IRQ_HANDLED)\n\t\treturn IRQ_HANDLED;\n\n\tif (mps2_uart_txirq(irq, data) == IRQ_HANDLED)\n\t\treturn IRQ_HANDLED;\n\n\tif (mps2_uart_oerrirq(irq, data) == IRQ_HANDLED)\n\t\treturn IRQ_HANDLED;\n\n\treturn IRQ_NONE;\n}\n\nstatic int mps2_uart_startup(struct uart_port *port)\n{\n\tstruct mps2_uart_port *mps_port = to_mps2_port(port);\n\tu8 control = mps2_uart_read8(port, UARTn_CTRL);\n\tint ret;\n\n\tcontrol &= ~(UARTn_CTRL_RX_GRP | UARTn_CTRL_TX_GRP);\n\n\tmps2_uart_write8(port, control, UARTn_CTRL);\n\n\tif (mps_port->flags & UART_PORT_COMBINED_IRQ) {\n\t\tret = request_irq(port->irq, mps2_uart_combinedirq, 0,\n\t\t\t\t  MAKE_NAME(-combined), mps_port);\n\n\t\tif (ret) {\n\t\t\tdev_err(port->dev, \"failed to register combinedirq (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = request_irq(port->irq, mps2_uart_oerrirq, IRQF_SHARED,\n\t\t\t\t  MAKE_NAME(-overrun), mps_port);\n\n\t\tif (ret) {\n\t\t\tdev_err(port->dev, \"failed to register oerrirq (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = request_irq(mps_port->rx_irq, mps2_uart_rxirq, 0,\n\t\t\t\t  MAKE_NAME(-rx), mps_port);\n\t\tif (ret) {\n\t\t\tdev_err(port->dev, \"failed to register rxirq (%d)\\n\", ret);\n\t\t\tgoto err_free_oerrirq;\n\t\t}\n\n\t\tret = request_irq(mps_port->tx_irq, mps2_uart_txirq, 0,\n\t\t\t\t  MAKE_NAME(-tx), mps_port);\n\t\tif (ret) {\n\t\t\tdev_err(port->dev, \"failed to register txirq (%d)\\n\", ret);\n\t\t\tgoto err_free_rxirq;\n\t\t}\n\n\t}\n\n\tcontrol |= UARTn_CTRL_RX_GRP | UARTn_CTRL_TX_GRP;\n\n\tmps2_uart_write8(port, control, UARTn_CTRL);\n\n\treturn 0;\n\nerr_free_rxirq:\n\tfree_irq(mps_port->rx_irq, mps_port);\nerr_free_oerrirq:\n\tfree_irq(port->irq, mps_port);\n\n\treturn ret;\n}\n\nstatic void mps2_uart_shutdown(struct uart_port *port)\n{\n\tstruct mps2_uart_port *mps_port = to_mps2_port(port);\n\tu8 control = mps2_uart_read8(port, UARTn_CTRL);\n\n\tcontrol &= ~(UARTn_CTRL_RX_GRP | UARTn_CTRL_TX_GRP);\n\n\tmps2_uart_write8(port, control, UARTn_CTRL);\n\n\tif (!(mps_port->flags & UART_PORT_COMBINED_IRQ)) {\n\t\tfree_irq(mps_port->rx_irq, mps_port);\n\t\tfree_irq(mps_port->tx_irq, mps_port);\n\t}\n\n\tfree_irq(port->irq, mps_port);\n}\n\nstatic void\nmps2_uart_set_termios(struct uart_port *port, struct ktermios *termios,\n\t\t      const struct ktermios *old)\n{\n\tunsigned long flags;\n\tunsigned int baud, bauddiv;\n\n\ttermios->c_cflag &= ~(CRTSCTS | CMSPAR);\n\ttermios->c_cflag &= ~CSIZE;\n\ttermios->c_cflag |= CS8;\n\ttermios->c_cflag &= ~PARENB;\n\ttermios->c_cflag &= ~CSTOPB;\n\n\tbaud = uart_get_baud_rate(port, termios, old,\n\t\t\tDIV_ROUND_CLOSEST(port->uartclk, UARTn_BAUDDIV_MASK),\n\t\t\tDIV_ROUND_CLOSEST(port->uartclk, 16));\n\n\tbauddiv = DIV_ROUND_CLOSEST(port->uartclk, baud);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\tmps2_uart_write32(port, bauddiv, UARTn_BAUDDIV);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n}\n\nstatic const char *mps2_uart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_MPS2UART) ? DRIVER_NAME : NULL;\n}\n\nstatic void mps2_uart_release_port(struct uart_port *port)\n{\n}\n\nstatic int mps2_uart_request_port(struct uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void mps2_uart_config_port(struct uart_port *port, int type)\n{\n\tif (type & UART_CONFIG_TYPE && !mps2_uart_request_port(port))\n\t\tport->type = PORT_MPS2UART;\n}\n\nstatic int mps2_uart_verify_port(struct uart_port *port, struct serial_struct *serinfo)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct uart_ops mps2_uart_pops = {\n\t.tx_empty = mps2_uart_tx_empty,\n\t.set_mctrl = mps2_uart_set_mctrl,\n\t.get_mctrl = mps2_uart_get_mctrl,\n\t.stop_tx = mps2_uart_stop_tx,\n\t.start_tx = mps2_uart_start_tx,\n\t.stop_rx = mps2_uart_stop_rx,\n\t.break_ctl = mps2_uart_break_ctl,\n\t.startup = mps2_uart_startup,\n\t.shutdown = mps2_uart_shutdown,\n\t.set_termios = mps2_uart_set_termios,\n\t.type = mps2_uart_type,\n\t.release_port = mps2_uart_release_port,\n\t.request_port = mps2_uart_request_port,\n\t.config_port = mps2_uart_config_port,\n\t.verify_port = mps2_uart_verify_port,\n};\n\nstatic DEFINE_IDR(ports_idr);\n\n#ifdef CONFIG_SERIAL_MPS2_UART_CONSOLE\nstatic void mps2_uart_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\twhile (mps2_uart_read8(port, UARTn_STATE) & UARTn_STATE_TX_FULL)\n\t\tcpu_relax();\n\n\tmps2_uart_write8(port, ch, UARTn_DATA);\n}\n\nstatic void mps2_uart_console_write(struct console *co, const char *s, unsigned int cnt)\n{\n\tstruct mps2_uart_port *mps_port = idr_find(&ports_idr, co->index);\n\tstruct uart_port *port = &mps_port->port;\n\n\tuart_console_write(port, s, cnt, mps2_uart_console_putchar);\n}\n\nstatic int mps2_uart_console_setup(struct console *co, char *options)\n{\n\tstruct mps2_uart_port *mps_port;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index < 0 || co->index >= MPS2_MAX_PORTS)\n\t\treturn -ENODEV;\n\n\tmps_port = idr_find(&ports_idr, co->index);\n\n\tif (!mps_port)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&mps_port->port, co, baud, parity, bits, flow);\n}\n\nstatic struct uart_driver mps2_uart_driver;\n\nstatic struct console mps2_uart_console = {\n\t.name = SERIAL_NAME,\n\t.device = uart_console_device,\n\t.write = mps2_uart_console_write,\n\t.setup = mps2_uart_console_setup,\n\t.flags = CON_PRINTBUFFER,\n\t.index = -1,\n\t.data = &mps2_uart_driver,\n};\n\n#define MPS2_SERIAL_CONSOLE (&mps2_uart_console)\n\nstatic void mps2_early_putchar(struct uart_port *port, unsigned char ch)\n{\n\twhile (readb(port->membase + UARTn_STATE) & UARTn_STATE_TX_FULL)\n\t\tcpu_relax();\n\n\twriteb((unsigned char)ch, port->membase + UARTn_DATA);\n}\n\nstatic void mps2_early_write(struct console *con, const char *s, unsigned int n)\n{\n\tstruct earlycon_device *dev = con->data;\n\n\tuart_console_write(&dev->port, s, n, mps2_early_putchar);\n}\n\nstatic int __init mps2_early_console_setup(struct earlycon_device *device,\n\t\t\t\t\t   const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = mps2_early_write;\n\n\treturn 0;\n}\n\nOF_EARLYCON_DECLARE(mps2, \"arm,mps2-uart\", mps2_early_console_setup);\n\n#else\n#define MPS2_SERIAL_CONSOLE NULL\n#endif\n\nstatic struct uart_driver mps2_uart_driver = {\n\t.driver_name = DRIVER_NAME,\n\t.dev_name = SERIAL_NAME,\n\t.nr = MPS2_MAX_PORTS,\n\t.cons = MPS2_SERIAL_CONSOLE,\n};\n\nstatic int mps2_of_get_port(struct platform_device *pdev,\n\t\t\t    struct mps2_uart_port *mps_port)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint id;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tid = of_alias_get_id(np, \"serial\");\n\n\tif (id < 0)\n\t\tid = idr_alloc_cyclic(&ports_idr, (void *)mps_port, 0, MPS2_MAX_PORTS, GFP_KERNEL);\n\telse\n\t\tid = idr_alloc(&ports_idr, (void *)mps_port, id, MPS2_MAX_PORTS, GFP_KERNEL);\n\n\tif (id < 0)\n\t\treturn id;\n\n\t \n\tif (platform_irq_count(pdev) == 1)\n\t\tmps_port->flags |= UART_PORT_COMBINED_IRQ;\n\n\tmps_port->port.line = id;\n\n\treturn 0;\n}\n\nstatic int mps2_init_port(struct platform_device *pdev,\n\t\t\t  struct mps2_uart_port *mps_port)\n{\n\tstruct resource *res;\n\tint ret;\n\n\tmps_port->port.membase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(mps_port->port.membase))\n\t\treturn PTR_ERR(mps_port->port.membase);\n\n\tmps_port->port.mapbase = res->start;\n\tmps_port->port.mapsize = resource_size(res);\n\tmps_port->port.iotype = UPIO_MEM;\n\tmps_port->port.flags = UPF_BOOT_AUTOCONF;\n\tmps_port->port.fifosize = 1;\n\tmps_port->port.ops = &mps2_uart_pops;\n\tmps_port->port.dev = &pdev->dev;\n\n\tmps_port->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(mps_port->clk))\n\t\treturn PTR_ERR(mps_port->clk);\n\n\tret = clk_prepare_enable(mps_port->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tmps_port->port.uartclk = clk_get_rate(mps_port->clk);\n\n\tclk_disable_unprepare(mps_port->clk);\n\n\n\tif (mps_port->flags & UART_PORT_COMBINED_IRQ) {\n\t\tmps_port->port.irq = platform_get_irq(pdev, 0);\n\t} else {\n\t\tmps_port->rx_irq = platform_get_irq(pdev, 0);\n\t\tmps_port->tx_irq = platform_get_irq(pdev, 1);\n\t\tmps_port->port.irq = platform_get_irq(pdev, 2);\n\t}\n\n\treturn ret;\n}\n\nstatic int mps2_serial_probe(struct platform_device *pdev)\n{\n\tstruct mps2_uart_port *mps_port;\n\tint ret;\n\n\tmps_port = devm_kzalloc(&pdev->dev, sizeof(struct mps2_uart_port), GFP_KERNEL);\n\n        if (!mps_port)\n                return -ENOMEM;\n\n\tret = mps2_of_get_port(pdev, mps_port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mps2_init_port(pdev, mps_port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uart_add_one_port(&mps2_uart_driver, &mps_port->port);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, mps_port);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mps2_match[] = {\n\t{ .compatible = \"arm,mps2-uart\", },\n\t{},\n};\n#endif\n\nstatic struct platform_driver mps2_serial_driver = {\n\t.probe = mps2_serial_probe,\n\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(mps2_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nstatic int __init mps2_uart_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&mps2_uart_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&mps2_serial_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&mps2_uart_driver);\n\n\treturn ret;\n}\narch_initcall(mps2_uart_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}