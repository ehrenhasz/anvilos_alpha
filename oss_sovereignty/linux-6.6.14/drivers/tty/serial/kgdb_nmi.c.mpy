{
  "module_name": "kgdb_nmi.c",
  "hash_id": "0c8ad7bfd78b1f6ee2cc25bb34fc1ed15fda596f71ed7271fa5b8d7dad6d7119",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/kgdb_nmi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/atomic.h>\n#include <linux/console.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/serial_core.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/tick.h>\n#include <linux/kfifo.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n\nstatic int kgdb_nmi_knock = 1;\nmodule_param_named(knock, kgdb_nmi_knock, int, 0600);\nMODULE_PARM_DESC(knock, \"if set to 1 (default), the special '$3#33' command \" \\\n\t\t\t\"must be used to enter the debugger; when set to 0, \" \\\n\t\t\t\"hitting return key is enough to enter the debugger; \" \\\n\t\t\t\"when set to -1, the debugger is entered immediately \" \\\n\t\t\t\"upon NMI\");\n\nstatic char *kgdb_nmi_magic = \"$3#33\";\nmodule_param_named(magic, kgdb_nmi_magic, charp, 0600);\nMODULE_PARM_DESC(magic, \"magic sequence to enter NMI debugger (default $3#33)\");\n\nstatic atomic_t kgdb_nmi_num_readers = ATOMIC_INIT(0);\n\nstatic int kgdb_nmi_console_setup(struct console *co, char *options)\n{\n\tarch_kgdb_ops.enable_nmi(1);\n\n\t \n\tdbg_io_ops->cons = co;\n\n\treturn 0;\n}\n\nstatic void kgdb_nmi_console_write(struct console *co, const char *s, uint c)\n{\n\tint i;\n\n\tfor (i = 0; i < c; i++)\n\t\tdbg_io_ops->write_char(s[i]);\n}\n\nstatic struct tty_driver *kgdb_nmi_tty_driver;\n\nstatic struct tty_driver *kgdb_nmi_console_device(struct console *co, int *idx)\n{\n\t*idx = co->index;\n\treturn kgdb_nmi_tty_driver;\n}\n\nstatic struct console kgdb_nmi_console = {\n\t.name\t= \"ttyNMI\",\n\t.setup  = kgdb_nmi_console_setup,\n\t.write\t= kgdb_nmi_console_write,\n\t.device\t= kgdb_nmi_console_device,\n\t.flags\t= CON_PRINTBUFFER | CON_ANYTIME,\n\t.index\t= -1,\n};\n\n \n#define KGDB_NMI_BAUD\t\t115200\n#define KGDB_NMI_FIFO_SIZE\troundup_pow_of_two(KGDB_NMI_BAUD / 8 / HZ)\n\nstruct kgdb_nmi_tty_priv {\n\tstruct tty_port port;\n\tstruct timer_list timer;\n\tSTRUCT_KFIFO(char, KGDB_NMI_FIFO_SIZE) fifo;\n};\n\nstatic struct tty_port *kgdb_nmi_port;\n\nstatic void kgdb_tty_recv(int ch)\n{\n\tstruct kgdb_nmi_tty_priv *priv;\n\tchar c = ch;\n\n\tif (!kgdb_nmi_port || ch < 0)\n\t\treturn;\n\t \n\tpriv = container_of(kgdb_nmi_port, struct kgdb_nmi_tty_priv, port);\n\tkfifo_in(&priv->fifo, &c, 1);\n}\n\nstatic int kgdb_nmi_poll_one_knock(void)\n{\n\tstatic int n;\n\tint c;\n\tconst char *magic = kgdb_nmi_magic;\n\tsize_t m = strlen(magic);\n\tbool printch = false;\n\n\tc = dbg_io_ops->read_char();\n\tif (c == NO_POLL_CHAR)\n\t\treturn c;\n\n\tif (!kgdb_nmi_knock && (c == '\\r' || c == '\\n')) {\n\t\treturn 1;\n\t} else if (c == magic[n]) {\n\t\tn = (n + 1) % m;\n\t\tif (!n)\n\t\t\treturn 1;\n\t\tprintch = true;\n\t} else {\n\t\tn = 0;\n\t}\n\n\tif (atomic_read(&kgdb_nmi_num_readers)) {\n\t\tkgdb_tty_recv(c);\n\t\treturn 0;\n\t}\n\n\tif (printch) {\n\t\tkdb_printf(\"%c\", c);\n\t\treturn 0;\n\t}\n\n\tkdb_printf(\"\\r%s %s to enter the debugger> %*s\",\n\t\t   kgdb_nmi_knock ? \"Type\" : \"Hit\",\n\t\t   kgdb_nmi_knock ? magic  : \"<return>\", (int)m, \"\");\n\twhile (m--)\n\t\tkdb_printf(\"\\b\");\n\treturn 0;\n}\n\n \nbool kgdb_nmi_poll_knock(void)\n{\n\tif (kgdb_nmi_knock < 0)\n\t\treturn true;\n\n\twhile (1) {\n\t\tint ret;\n\n\t\tret = kgdb_nmi_poll_one_knock();\n\t\tif (ret == NO_POLL_CHAR)\n\t\t\treturn false;\n\t\telse if (ret == 1)\n\t\t\tbreak;\n\t}\n\treturn true;\n}\n\n \nstatic void kgdb_nmi_tty_receiver(struct timer_list *t)\n{\n\tstruct kgdb_nmi_tty_priv *priv = from_timer(priv, t, timer);\n\tchar ch;\n\n\tpriv->timer.expires = jiffies + (HZ/100);\n\tadd_timer(&priv->timer);\n\n\tif (likely(!atomic_read(&kgdb_nmi_num_readers) ||\n\t\t   !kfifo_len(&priv->fifo)))\n\t\treturn;\n\n\twhile (kfifo_out(&priv->fifo, &ch, 1))\n\t\ttty_insert_flip_char(&priv->port, ch, TTY_NORMAL);\n\ttty_flip_buffer_push(&priv->port);\n}\n\nstatic int kgdb_nmi_tty_activate(struct tty_port *port, struct tty_struct *tty)\n{\n\tstruct kgdb_nmi_tty_priv *priv =\n\t    container_of(port, struct kgdb_nmi_tty_priv, port);\n\n\tkgdb_nmi_port = port;\n\tpriv->timer.expires = jiffies + (HZ/100);\n\tadd_timer(&priv->timer);\n\n\treturn 0;\n}\n\nstatic void kgdb_nmi_tty_shutdown(struct tty_port *port)\n{\n\tstruct kgdb_nmi_tty_priv *priv =\n\t    container_of(port, struct kgdb_nmi_tty_priv, port);\n\n\tdel_timer(&priv->timer);\n\tkgdb_nmi_port = NULL;\n}\n\nstatic const struct tty_port_operations kgdb_nmi_tty_port_ops = {\n\t.activate\t= kgdb_nmi_tty_activate,\n\t.shutdown\t= kgdb_nmi_tty_shutdown,\n};\n\nstatic int kgdb_nmi_tty_install(struct tty_driver *drv, struct tty_struct *tty)\n{\n\tstruct kgdb_nmi_tty_priv *priv;\n\tint ret;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_KFIFO(priv->fifo);\n\ttimer_setup(&priv->timer, kgdb_nmi_tty_receiver, 0);\n\ttty_port_init(&priv->port);\n\tpriv->port.ops = &kgdb_nmi_tty_port_ops;\n\ttty->driver_data = priv;\n\n\tret = tty_port_install(&priv->port, drv, tty);\n\tif (ret) {\n\t\tpr_err(\"%s: can't install tty port: %d\\n\", __func__, ret);\n\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\ttty_port_destroy(&priv->port);\n\tkfree(priv);\n\treturn ret;\n}\n\nstatic void kgdb_nmi_tty_cleanup(struct tty_struct *tty)\n{\n\tstruct kgdb_nmi_tty_priv *priv = tty->driver_data;\n\n\ttty->driver_data = NULL;\n\ttty_port_destroy(&priv->port);\n\tkfree(priv);\n}\n\nstatic int kgdb_nmi_tty_open(struct tty_struct *tty, struct file *file)\n{\n\tstruct kgdb_nmi_tty_priv *priv = tty->driver_data;\n\tunsigned int mode = file->f_flags & O_ACCMODE;\n\tint ret;\n\n\tret = tty_port_open(&priv->port, tty, file);\n\tif (!ret && (mode == O_RDONLY || mode == O_RDWR))\n\t\tatomic_inc(&kgdb_nmi_num_readers);\n\n\treturn ret;\n}\n\nstatic void kgdb_nmi_tty_close(struct tty_struct *tty, struct file *file)\n{\n\tstruct kgdb_nmi_tty_priv *priv = tty->driver_data;\n\tunsigned int mode = file->f_flags & O_ACCMODE;\n\n\tif (mode == O_RDONLY || mode == O_RDWR)\n\t\tatomic_dec(&kgdb_nmi_num_readers);\n\n\ttty_port_close(&priv->port, tty, file);\n}\n\nstatic void kgdb_nmi_tty_hangup(struct tty_struct *tty)\n{\n\tstruct kgdb_nmi_tty_priv *priv = tty->driver_data;\n\n\ttty_port_hangup(&priv->port);\n}\n\nstatic unsigned int kgdb_nmi_tty_write_room(struct tty_struct *tty)\n{\n\t \n\treturn 2048;\n}\n\nstatic ssize_t kgdb_nmi_tty_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t\t  size_t c)\n{\n\tint i;\n\n\tfor (i = 0; i < c; i++)\n\t\tdbg_io_ops->write_char(buf[i]);\n\treturn c;\n}\n\nstatic const struct tty_operations kgdb_nmi_tty_ops = {\n\t.open\t\t= kgdb_nmi_tty_open,\n\t.close\t\t= kgdb_nmi_tty_close,\n\t.install\t= kgdb_nmi_tty_install,\n\t.cleanup\t= kgdb_nmi_tty_cleanup,\n\t.hangup\t\t= kgdb_nmi_tty_hangup,\n\t.write_room\t= kgdb_nmi_tty_write_room,\n\t.write\t\t= kgdb_nmi_tty_write,\n};\n\nint kgdb_register_nmi_console(void)\n{\n\tint ret;\n\n\tif (!arch_kgdb_ops.enable_nmi)\n\t\treturn 0;\n\n\tkgdb_nmi_tty_driver = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW);\n\tif (IS_ERR(kgdb_nmi_tty_driver)) {\n\t\tpr_err(\"%s: cannot allocate tty\\n\", __func__);\n\t\treturn PTR_ERR(kgdb_nmi_tty_driver);\n\t}\n\tkgdb_nmi_tty_driver->driver_name\t= \"ttyNMI\";\n\tkgdb_nmi_tty_driver->name\t\t= \"ttyNMI\";\n\tkgdb_nmi_tty_driver->num\t\t= 1;\n\tkgdb_nmi_tty_driver->type\t\t= TTY_DRIVER_TYPE_SERIAL;\n\tkgdb_nmi_tty_driver->subtype\t\t= SERIAL_TYPE_NORMAL;\n\tkgdb_nmi_tty_driver->init_termios\t= tty_std_termios;\n\ttty_termios_encode_baud_rate(&kgdb_nmi_tty_driver->init_termios,\n\t\t\t\t     KGDB_NMI_BAUD, KGDB_NMI_BAUD);\n\ttty_set_operations(kgdb_nmi_tty_driver, &kgdb_nmi_tty_ops);\n\n\tret = tty_register_driver(kgdb_nmi_tty_driver);\n\tif (ret) {\n\t\tpr_err(\"%s: can't register tty driver: %d\\n\", __func__, ret);\n\t\tgoto err_drv_reg;\n\t}\n\n\tregister_console(&kgdb_nmi_console);\n\n\treturn 0;\nerr_drv_reg:\n\ttty_driver_kref_put(kgdb_nmi_tty_driver);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kgdb_register_nmi_console);\n\nint kgdb_unregister_nmi_console(void)\n{\n\tint ret;\n\n\tif (!arch_kgdb_ops.enable_nmi)\n\t\treturn 0;\n\tarch_kgdb_ops.enable_nmi(0);\n\n\tret = unregister_console(&kgdb_nmi_console);\n\tif (ret)\n\t\treturn ret;\n\n\ttty_unregister_driver(kgdb_nmi_tty_driver);\n\ttty_driver_kref_put(kgdb_nmi_tty_driver);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kgdb_unregister_nmi_console);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}