{
  "module_name": "owl-uart.c",
  "hash_id": "b430479cf1543d63305fe6acd53e4a90cdc4e76f6485d1d15d6c0e4f5725baab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serial/owl-uart.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#define OWL_UART_PORT_NUM 7\n#define OWL_UART_DEV_NAME \"ttyOWL\"\n\n#define OWL_UART_CTL\t0x000\n#define OWL_UART_RXDAT\t0x004\n#define OWL_UART_TXDAT\t0x008\n#define OWL_UART_STAT\t0x00c\n\n#define OWL_UART_CTL_DWLS_MASK\t\tGENMASK(1, 0)\n#define OWL_UART_CTL_DWLS_5BITS\t\t(0x0 << 0)\n#define OWL_UART_CTL_DWLS_6BITS\t\t(0x1 << 0)\n#define OWL_UART_CTL_DWLS_7BITS\t\t(0x2 << 0)\n#define OWL_UART_CTL_DWLS_8BITS\t\t(0x3 << 0)\n#define OWL_UART_CTL_STPS_2BITS\t\tBIT(2)\n#define OWL_UART_CTL_PRS_MASK\t\tGENMASK(6, 4)\n#define OWL_UART_CTL_PRS_NONE\t\t(0x0 << 4)\n#define OWL_UART_CTL_PRS_ODD\t\t(0x4 << 4)\n#define OWL_UART_CTL_PRS_MARK\t\t(0x5 << 4)\n#define OWL_UART_CTL_PRS_EVEN\t\t(0x6 << 4)\n#define OWL_UART_CTL_PRS_SPACE\t\t(0x7 << 4)\n#define OWL_UART_CTL_AFE\t\tBIT(12)\n#define OWL_UART_CTL_TRFS_TX\t\tBIT(14)\n#define OWL_UART_CTL_EN\t\t\tBIT(15)\n#define OWL_UART_CTL_RXDE\t\tBIT(16)\n#define OWL_UART_CTL_TXDE\t\tBIT(17)\n#define OWL_UART_CTL_RXIE\t\tBIT(18)\n#define OWL_UART_CTL_TXIE\t\tBIT(19)\n#define OWL_UART_CTL_LBEN\t\tBIT(20)\n\n#define OWL_UART_STAT_RIP\t\tBIT(0)\n#define OWL_UART_STAT_TIP\t\tBIT(1)\n#define OWL_UART_STAT_RXER\t\tBIT(2)\n#define OWL_UART_STAT_TFER\t\tBIT(3)\n#define OWL_UART_STAT_RXST\t\tBIT(4)\n#define OWL_UART_STAT_RFEM\t\tBIT(5)\n#define OWL_UART_STAT_TFFU\t\tBIT(6)\n#define OWL_UART_STAT_CTSS\t\tBIT(7)\n#define OWL_UART_STAT_RTSS\t\tBIT(8)\n#define OWL_UART_STAT_TFES\t\tBIT(10)\n#define OWL_UART_STAT_TRFL_MASK\t\tGENMASK(16, 11)\n#define OWL_UART_STAT_UTBB\t\tBIT(17)\n\n#define OWL_UART_POLL_USEC\t\t5\n#define OWL_UART_TIMEOUT_USEC\t\t10000\n\nstatic struct uart_driver owl_uart_driver;\n\nstruct owl_uart_info {\n\tunsigned int tx_fifosize;\n};\n\nstruct owl_uart_port {\n\tstruct uart_port port;\n\tstruct clk *clk;\n};\n\n#define to_owl_uart_port(prt) container_of(prt, struct owl_uart_port, prt)\n\nstatic struct owl_uart_port *owl_uart_ports[OWL_UART_PORT_NUM];\n\nstatic inline void owl_uart_write(struct uart_port *port, u32 val, unsigned int off)\n{\n\twritel(val, port->membase + off);\n}\n\nstatic inline u32 owl_uart_read(struct uart_port *port, unsigned int off)\n{\n\treturn readl(port->membase + off);\n}\n\nstatic void owl_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\n{\n\tu32 ctl;\n\n\tctl = owl_uart_read(port, OWL_UART_CTL);\n\n\tif (mctrl & TIOCM_LOOP)\n\t\tctl |= OWL_UART_CTL_LBEN;\n\telse\n\t\tctl &= ~OWL_UART_CTL_LBEN;\n\n\towl_uart_write(port, ctl, OWL_UART_CTL);\n}\n\nstatic unsigned int owl_uart_get_mctrl(struct uart_port *port)\n{\n\tunsigned int mctrl = TIOCM_CAR | TIOCM_DSR;\n\tu32 stat, ctl;\n\n\tctl = owl_uart_read(port, OWL_UART_CTL);\n\tstat = owl_uart_read(port, OWL_UART_STAT);\n\tif (stat & OWL_UART_STAT_RTSS)\n\t\tmctrl |= TIOCM_RTS;\n\tif ((stat & OWL_UART_STAT_CTSS) || !(ctl & OWL_UART_CTL_AFE))\n\t\tmctrl |= TIOCM_CTS;\n\treturn mctrl;\n}\n\nstatic unsigned int owl_uart_tx_empty(struct uart_port *port)\n{\n\tunsigned long flags;\n\tu32 val;\n\tunsigned int ret;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tval = owl_uart_read(port, OWL_UART_STAT);\n\tret = (val & OWL_UART_STAT_TFES) ? TIOCSER_TEMT : 0;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn ret;\n}\n\nstatic void owl_uart_stop_rx(struct uart_port *port)\n{\n\tu32 val;\n\n\tval = owl_uart_read(port, OWL_UART_CTL);\n\tval &= ~(OWL_UART_CTL_RXIE | OWL_UART_CTL_RXDE);\n\towl_uart_write(port, val, OWL_UART_CTL);\n\n\tval = owl_uart_read(port, OWL_UART_STAT);\n\tval |= OWL_UART_STAT_RIP;\n\towl_uart_write(port, val, OWL_UART_STAT);\n}\n\nstatic void owl_uart_stop_tx(struct uart_port *port)\n{\n\tu32 val;\n\n\tval = owl_uart_read(port, OWL_UART_CTL);\n\tval &= ~(OWL_UART_CTL_TXIE | OWL_UART_CTL_TXDE);\n\towl_uart_write(port, val, OWL_UART_CTL);\n\n\tval = owl_uart_read(port, OWL_UART_STAT);\n\tval |= OWL_UART_STAT_TIP;\n\towl_uart_write(port, val, OWL_UART_STAT);\n}\n\nstatic void owl_uart_start_tx(struct uart_port *port)\n{\n\tu32 val;\n\n\tif (uart_tx_stopped(port)) {\n\t\towl_uart_stop_tx(port);\n\t\treturn;\n\t}\n\n\tval = owl_uart_read(port, OWL_UART_STAT);\n\tval |= OWL_UART_STAT_TIP;\n\towl_uart_write(port, val, OWL_UART_STAT);\n\n\tval = owl_uart_read(port, OWL_UART_CTL);\n\tval |= OWL_UART_CTL_TXIE;\n\towl_uart_write(port, val, OWL_UART_CTL);\n}\n\nstatic void owl_uart_send_chars(struct uart_port *port)\n{\n\tu8 ch;\n\n\tuart_port_tx(port, ch,\n\t\t!(owl_uart_read(port, OWL_UART_STAT) & OWL_UART_STAT_TFFU),\n\t\towl_uart_write(port, ch, OWL_UART_TXDAT));\n}\n\nstatic void owl_uart_receive_chars(struct uart_port *port)\n{\n\tu32 stat, val;\n\n\tval = owl_uart_read(port, OWL_UART_CTL);\n\tval &= ~OWL_UART_CTL_TRFS_TX;\n\towl_uart_write(port, val, OWL_UART_CTL);\n\n\tstat = owl_uart_read(port, OWL_UART_STAT);\n\twhile (!(stat & OWL_UART_STAT_RFEM)) {\n\t\tchar flag = TTY_NORMAL;\n\n\t\tif (stat & OWL_UART_STAT_RXER)\n\t\t\tport->icount.overrun++;\n\n\t\tif (stat & OWL_UART_STAT_RXST) {\n\t\t\t \n\t\t\tport->icount.brk++;\n\t\t\tport->icount.frame++;\n\n\t\t\tstat &= port->read_status_mask;\n\t\t\tif (stat & OWL_UART_STAT_RXST)\n\t\t\t\tflag = TTY_PARITY;\n\t\t} else\n\t\t\tport->icount.rx++;\n\n\t\tval = owl_uart_read(port, OWL_UART_RXDAT);\n\t\tval &= 0xff;\n\n\t\tif ((stat & port->ignore_status_mask) == 0)\n\t\t\ttty_insert_flip_char(&port->state->port, val, flag);\n\n\t\tstat = owl_uart_read(port, OWL_UART_STAT);\n\t}\n\n\ttty_flip_buffer_push(&port->state->port);\n}\n\nstatic irqreturn_t owl_uart_irq(int irq, void *dev_id)\n{\n\tstruct uart_port *port = dev_id;\n\tunsigned long flags;\n\tu32 stat;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tstat = owl_uart_read(port, OWL_UART_STAT);\n\n\tif (stat & OWL_UART_STAT_RIP)\n\t\towl_uart_receive_chars(port);\n\n\tif (stat & OWL_UART_STAT_TIP)\n\t\towl_uart_send_chars(port);\n\n\tstat = owl_uart_read(port, OWL_UART_STAT);\n\tstat |= OWL_UART_STAT_RIP | OWL_UART_STAT_TIP;\n\towl_uart_write(port, stat, OWL_UART_STAT);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void owl_uart_shutdown(struct uart_port *port)\n{\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tval = owl_uart_read(port, OWL_UART_CTL);\n\tval &= ~(OWL_UART_CTL_TXIE | OWL_UART_CTL_RXIE\n\t\t| OWL_UART_CTL_TXDE | OWL_UART_CTL_RXDE | OWL_UART_CTL_EN);\n\towl_uart_write(port, val, OWL_UART_CTL);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tfree_irq(port->irq, port);\n}\n\nstatic int owl_uart_startup(struct uart_port *port)\n{\n\tu32 val;\n\tunsigned long flags;\n\tint ret;\n\n\tret = request_irq(port->irq, owl_uart_irq, IRQF_TRIGGER_HIGH,\n\t\t\t\"owl-uart\", port);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tval = owl_uart_read(port, OWL_UART_STAT);\n\tval |= OWL_UART_STAT_RIP | OWL_UART_STAT_TIP\n\t\t| OWL_UART_STAT_RXER | OWL_UART_STAT_TFER | OWL_UART_STAT_RXST;\n\towl_uart_write(port, val, OWL_UART_STAT);\n\n\tval = owl_uart_read(port, OWL_UART_CTL);\n\tval |= OWL_UART_CTL_RXIE | OWL_UART_CTL_TXIE;\n\tval |= OWL_UART_CTL_EN;\n\towl_uart_write(port, val, OWL_UART_CTL);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn 0;\n}\n\nstatic void owl_uart_change_baudrate(struct owl_uart_port *owl_port,\n\t\t\t\t     unsigned long baud)\n{\n\tclk_set_rate(owl_port->clk, baud * 8);\n}\n\nstatic void owl_uart_set_termios(struct uart_port *port,\n\t\t\t\t struct ktermios *termios,\n\t\t\t\t const struct ktermios *old)\n{\n\tstruct owl_uart_port *owl_port = to_owl_uart_port(port);\n\tunsigned int baud;\n\tu32 ctl;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tctl = owl_uart_read(port, OWL_UART_CTL);\n\n\tctl &= ~OWL_UART_CTL_DWLS_MASK;\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tctl |= OWL_UART_CTL_DWLS_5BITS;\n\t\tbreak;\n\tcase CS6:\n\t\tctl |= OWL_UART_CTL_DWLS_6BITS;\n\t\tbreak;\n\tcase CS7:\n\t\tctl |= OWL_UART_CTL_DWLS_7BITS;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tctl |= OWL_UART_CTL_DWLS_8BITS;\n\t\tbreak;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tctl |= OWL_UART_CTL_STPS_2BITS;\n\telse\n\t\tctl &= ~OWL_UART_CTL_STPS_2BITS;\n\n\tctl &= ~OWL_UART_CTL_PRS_MASK;\n\tif (termios->c_cflag & PARENB) {\n\t\tif (termios->c_cflag & CMSPAR) {\n\t\t\tif (termios->c_cflag & PARODD)\n\t\t\t\tctl |= OWL_UART_CTL_PRS_MARK;\n\t\t\telse\n\t\t\t\tctl |= OWL_UART_CTL_PRS_SPACE;\n\t\t} else if (termios->c_cflag & PARODD)\n\t\t\tctl |= OWL_UART_CTL_PRS_ODD;\n\t\telse\n\t\t\tctl |= OWL_UART_CTL_PRS_EVEN;\n\t} else\n\t\tctl |= OWL_UART_CTL_PRS_NONE;\n\n\tif (termios->c_cflag & CRTSCTS)\n\t\tctl |= OWL_UART_CTL_AFE;\n\telse\n\t\tctl &= ~OWL_UART_CTL_AFE;\n\n\towl_uart_write(port, ctl, OWL_UART_CTL);\n\n\tbaud = uart_get_baud_rate(port, termios, old, 9600, 3200000);\n\towl_uart_change_baudrate(owl_port, baud);\n\n\t \n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, baud, baud);\n\n\tport->read_status_mask |= OWL_UART_STAT_RXER;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= OWL_UART_STAT_RXST;\n\n\tuart_update_timeout(port, termios->c_cflag, baud);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void owl_uart_release_port(struct uart_port *port)\n{\n\tstruct platform_device *pdev = to_platform_device(port->dev);\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn;\n\n\tif (port->flags & UPF_IOREMAP) {\n\t\tdevm_release_mem_region(port->dev, port->mapbase,\n\t\t\tresource_size(res));\n\t\tdevm_iounmap(port->dev, port->membase);\n\t\tport->membase = NULL;\n\t}\n}\n\nstatic int owl_uart_request_port(struct uart_port *port)\n{\n\tstruct platform_device *pdev = to_platform_device(port->dev);\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENXIO;\n\n\tif (!devm_request_mem_region(port->dev, port->mapbase,\n\t\t\tresource_size(res), dev_name(port->dev)))\n\t\treturn -EBUSY;\n\n\tif (port->flags & UPF_IOREMAP) {\n\t\tport->membase = devm_ioremap(port->dev, port->mapbase,\n\t\t\t\tresource_size(res));\n\t\tif (!port->membase)\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic const char *owl_uart_type(struct uart_port *port)\n{\n\treturn (port->type == PORT_OWL) ? \"owl-uart\" : NULL;\n}\n\nstatic int owl_uart_verify_port(struct uart_port *port,\n\t\t\t\tstruct serial_struct *ser)\n{\n\tif (port->type != PORT_OWL)\n\t\treturn -EINVAL;\n\n\tif (port->irq != ser->irq)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void owl_uart_config_port(struct uart_port *port, int flags)\n{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_OWL;\n\t\towl_uart_request_port(port);\n\t}\n}\n\n#ifdef CONFIG_CONSOLE_POLL\n\nstatic int owl_uart_poll_get_char(struct uart_port *port)\n{\n\tif (owl_uart_read(port, OWL_UART_STAT) & OWL_UART_STAT_RFEM)\n\t\treturn NO_POLL_CHAR;\n\n\treturn owl_uart_read(port, OWL_UART_RXDAT);\n}\n\nstatic void owl_uart_poll_put_char(struct uart_port *port, unsigned char ch)\n{\n\tu32 reg;\n\tint ret;\n\n\t \n\tret = readl_poll_timeout_atomic(port->membase + OWL_UART_STAT, reg,\n\t\t\t\t\t!(reg & OWL_UART_STAT_TFFU),\n\t\t\t\t\tOWL_UART_POLL_USEC,\n\t\t\t\t\tOWL_UART_TIMEOUT_USEC);\n\tif (ret == -ETIMEDOUT) {\n\t\tdev_err(port->dev, \"Timeout waiting while UART TX FULL\\n\");\n\t\treturn;\n\t}\n\n\towl_uart_write(port, ch, OWL_UART_TXDAT);\n}\n\n#endif  \n\nstatic const struct uart_ops owl_uart_ops = {\n\t.set_mctrl = owl_uart_set_mctrl,\n\t.get_mctrl = owl_uart_get_mctrl,\n\t.tx_empty = owl_uart_tx_empty,\n\t.start_tx = owl_uart_start_tx,\n\t.stop_rx = owl_uart_stop_rx,\n\t.stop_tx = owl_uart_stop_tx,\n\t.startup = owl_uart_startup,\n\t.shutdown = owl_uart_shutdown,\n\t.set_termios = owl_uart_set_termios,\n\t.type = owl_uart_type,\n\t.config_port = owl_uart_config_port,\n\t.request_port = owl_uart_request_port,\n\t.release_port = owl_uart_release_port,\n\t.verify_port = owl_uart_verify_port,\n#ifdef CONFIG_CONSOLE_POLL\n\t.poll_get_char = owl_uart_poll_get_char,\n\t.poll_put_char = owl_uart_poll_put_char,\n#endif\n};\n\n#ifdef CONFIG_SERIAL_OWL_CONSOLE\n\nstatic void owl_console_putchar(struct uart_port *port, unsigned char ch)\n{\n\tif (!port->membase)\n\t\treturn;\n\n\twhile (owl_uart_read(port, OWL_UART_STAT) & OWL_UART_STAT_TFFU)\n\t\tcpu_relax();\n\n\towl_uart_write(port, ch, OWL_UART_TXDAT);\n}\n\nstatic void owl_uart_port_write(struct uart_port *port, const char *s,\n\t\t\t\tu_int count)\n{\n\tu32 old_ctl, val;\n\tunsigned long flags;\n\tint locked;\n\n\tlocal_irq_save(flags);\n\n\tif (port->sysrq)\n\t\tlocked = 0;\n\telse if (oops_in_progress)\n\t\tlocked = spin_trylock(&port->lock);\n\telse {\n\t\tspin_lock(&port->lock);\n\t\tlocked = 1;\n\t}\n\n\told_ctl = owl_uart_read(port, OWL_UART_CTL);\n\tval = old_ctl | OWL_UART_CTL_TRFS_TX;\n\t \n\tval &= ~(OWL_UART_CTL_RXIE | OWL_UART_CTL_TXIE);\n\towl_uart_write(port, val, OWL_UART_CTL);\n\n\tuart_console_write(port, s, count, owl_console_putchar);\n\n\t \n\twhile (owl_uart_read(port, OWL_UART_STAT) & OWL_UART_STAT_TRFL_MASK)\n\t\tcpu_relax();\n\n\t \n\tval = owl_uart_read(port, OWL_UART_STAT);\n\tval |= OWL_UART_STAT_TIP | OWL_UART_STAT_RIP;\n\towl_uart_write(port, val, OWL_UART_STAT);\n\n\towl_uart_write(port, old_ctl, OWL_UART_CTL);\n\n\tif (locked)\n\t\tspin_unlock(&port->lock);\n\n\tlocal_irq_restore(flags);\n}\n\nstatic void owl_uart_console_write(struct console *co, const char *s,\n\t\t\t\t   u_int count)\n{\n\tstruct owl_uart_port *owl_port;\n\n\towl_port = owl_uart_ports[co->index];\n\tif (!owl_port)\n\t\treturn;\n\n\towl_uart_port_write(&owl_port->port, s, count);\n}\n\nstatic int owl_uart_console_setup(struct console *co, char *options)\n{\n\tstruct owl_uart_port *owl_port;\n\tint baud = 115200;\n\tint bits = 8;\n\tint parity = 'n';\n\tint flow = 'n';\n\n\tif (co->index < 0 || co->index >= OWL_UART_PORT_NUM)\n\t\treturn -EINVAL;\n\n\towl_port = owl_uart_ports[co->index];\n\tif (!owl_port || !owl_port->port.membase)\n\t\treturn -ENODEV;\n\n\tif (options)\n\t\tuart_parse_options(options, &baud, &parity, &bits, &flow);\n\n\treturn uart_set_options(&owl_port->port, co, baud, parity, bits, flow);\n}\n\nstatic struct console owl_uart_console = {\n\t.name = OWL_UART_DEV_NAME,\n\t.write = owl_uart_console_write,\n\t.device = uart_console_device,\n\t.setup = owl_uart_console_setup,\n\t.flags = CON_PRINTBUFFER,\n\t.index = -1,\n\t.data = &owl_uart_driver,\n};\n\nstatic int __init owl_uart_console_init(void)\n{\n\tregister_console(&owl_uart_console);\n\n\treturn 0;\n}\nconsole_initcall(owl_uart_console_init);\n\nstatic void owl_uart_early_console_write(struct console *co,\n\t\t\t\t\t const char *s,\n\t\t\t\t\t u_int count)\n{\n\tstruct earlycon_device *dev = co->data;\n\n\towl_uart_port_write(&dev->port, s, count);\n}\n\nstatic int __init\nowl_uart_early_console_setup(struct earlycon_device *device, const char *opt)\n{\n\tif (!device->port.membase)\n\t\treturn -ENODEV;\n\n\tdevice->con->write = owl_uart_early_console_write;\n\n\treturn 0;\n}\nOF_EARLYCON_DECLARE(owl, \"actions,owl-uart\",\n\t\t    owl_uart_early_console_setup);\n\n#define OWL_UART_CONSOLE (&owl_uart_console)\n#else\n#define OWL_UART_CONSOLE NULL\n#endif\n\nstatic struct uart_driver owl_uart_driver = {\n\t.owner = THIS_MODULE,\n\t.driver_name = \"owl-uart\",\n\t.dev_name = OWL_UART_DEV_NAME,\n\t.nr = OWL_UART_PORT_NUM,\n\t.cons = OWL_UART_CONSOLE,\n};\n\nstatic const struct owl_uart_info owl_s500_info = {\n\t.tx_fifosize = 16,\n};\n\nstatic const struct owl_uart_info owl_s900_info = {\n\t.tx_fifosize = 32,\n};\n\nstatic const struct of_device_id owl_uart_dt_matches[] = {\n\t{ .compatible = \"actions,s500-uart\", .data = &owl_s500_info },\n\t{ .compatible = \"actions,s900-uart\", .data = &owl_s900_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, owl_uart_dt_matches);\n\nstatic int owl_uart_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tconst struct owl_uart_info *info = NULL;\n\tstruct resource *res_mem;\n\tstruct owl_uart_port *owl_port;\n\tint ret, irq;\n\n\tif (pdev->dev.of_node) {\n\t\tpdev->id = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\t\tmatch = of_match_node(owl_uart_dt_matches, pdev->dev.of_node);\n\t\tif (match)\n\t\t\tinfo = match->data;\n\t}\n\n\tif (pdev->id < 0 || pdev->id >= OWL_UART_PORT_NUM) {\n\t\tdev_err(&pdev->dev, \"id %d out of range\\n\", pdev->id);\n\t\treturn -EINVAL;\n\t}\n\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res_mem) {\n\t\tdev_err(&pdev->dev, \"could not get mem\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tif (owl_uart_ports[pdev->id]) {\n\t\tdev_err(&pdev->dev, \"port %d already allocated\\n\", pdev->id);\n\t\treturn -EBUSY;\n\t}\n\n\towl_port = devm_kzalloc(&pdev->dev, sizeof(*owl_port), GFP_KERNEL);\n\tif (!owl_port)\n\t\treturn -ENOMEM;\n\n\towl_port->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(owl_port->clk)) {\n\t\tdev_err(&pdev->dev, \"could not get clk\\n\");\n\t\treturn PTR_ERR(owl_port->clk);\n\t}\n\n\tret = clk_prepare_enable(owl_port->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not enable clk\\n\");\n\t\treturn ret;\n\t}\n\n\towl_port->port.dev = &pdev->dev;\n\towl_port->port.line = pdev->id;\n\towl_port->port.type = PORT_OWL;\n\towl_port->port.iotype = UPIO_MEM;\n\towl_port->port.mapbase = res_mem->start;\n\towl_port->port.irq = irq;\n\towl_port->port.uartclk = clk_get_rate(owl_port->clk);\n\tif (owl_port->port.uartclk == 0) {\n\t\tdev_err(&pdev->dev, \"clock rate is zero\\n\");\n\t\tclk_disable_unprepare(owl_port->clk);\n\t\treturn -EINVAL;\n\t}\n\towl_port->port.flags = UPF_BOOT_AUTOCONF | UPF_IOREMAP | UPF_LOW_LATENCY;\n\towl_port->port.x_char = 0;\n\towl_port->port.fifosize = (info) ? info->tx_fifosize : 16;\n\towl_port->port.ops = &owl_uart_ops;\n\n\towl_uart_ports[pdev->id] = owl_port;\n\tplatform_set_drvdata(pdev, owl_port);\n\n\tret = uart_add_one_port(&owl_uart_driver, &owl_port->port);\n\tif (ret)\n\t\towl_uart_ports[pdev->id] = NULL;\n\n\treturn ret;\n}\n\nstatic int owl_uart_remove(struct platform_device *pdev)\n{\n\tstruct owl_uart_port *owl_port = platform_get_drvdata(pdev);\n\n\tuart_remove_one_port(&owl_uart_driver, &owl_port->port);\n\towl_uart_ports[pdev->id] = NULL;\n\tclk_disable_unprepare(owl_port->clk);\n\n\treturn 0;\n}\n\nstatic struct platform_driver owl_uart_platform_driver = {\n\t.probe = owl_uart_probe,\n\t.remove = owl_uart_remove,\n\t.driver = {\n\t\t.name = \"owl-uart\",\n\t\t.of_match_table = owl_uart_dt_matches,\n\t},\n};\n\nstatic int __init owl_uart_init(void)\n{\n\tint ret;\n\n\tret = uart_register_driver(&owl_uart_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&owl_uart_platform_driver);\n\tif (ret)\n\t\tuart_unregister_driver(&owl_uart_driver);\n\n\treturn ret;\n}\n\nstatic void __exit owl_uart_exit(void)\n{\n\tplatform_driver_unregister(&owl_uart_platform_driver);\n\tuart_unregister_driver(&owl_uart_driver);\n}\n\nmodule_init(owl_uart_init);\nmodule_exit(owl_uart_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}