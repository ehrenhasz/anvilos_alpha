{
  "module_name": "nozomi.c",
  "hash_id": "7735cca3d2896027ed4ddfe75c6589882858c3407768baf5d032a8cddd2efd2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/nozomi.c",
  "human_readable_source": "\n \n\n \n#define DEBUG\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/ioport.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/sched.h>\n#include <linux/serial.h>\n#include <linux/interrupt.h>\n#include <linux/kmod.h>\n#include <linux/init.h>\n#include <linux/kfifo.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n\n#include <linux/delay.h>\n\n \n#define NOZOMI_DEBUG_LEVEL 0x00\nstatic int debug = NOZOMI_DEBUG_LEVEL;\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\n\n \n#define DBG_(lvl, fmt, args...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (lvl & debug)\t\t\t\t\\\n\t\tpr_debug(\"[%d] %s(): \" fmt \"\\n\",\t\\\n\t\t\t __LINE__, __func__,  ##args);\t\\\n} while (0)\n\n#define DBG1(args...) DBG_(0x01, ##args)\n#define DBG2(args...) DBG_(0x02, ##args)\n#define DBG3(args...) DBG_(0x04, ##args)\n#define DBG4(args...) DBG_(0x08, ##args)\n\n \n\n#define TMP_BUF_MAX 256\n\n#define DUMP(buf__, len__)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tchar tbuf[TMP_BUF_MAX] = {0};\t\t\t\t\\\n\t\tif (len__ > 1) {\t\t\t\t\t\\\n\t\t\tu32 data_len = min_t(u32, len__, TMP_BUF_MAX);\t\\\n\t\t\tstrscpy(tbuf, buf__, data_len);\t\t\t\\\n\t\t\tif (tbuf[data_len - 2] == '\\r')\t\t\t\\\n\t\t\t\ttbuf[data_len - 2] = 'r';\t\t\\\n\t\t\tDBG1(\"SENDING: '%s' (%d+n)\", tbuf, len__);\t\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\tDBG1(\"SENDING: '%s' (%d)\", tbuf, len__);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n \n#define NOZOMI_NAME\t\t\"nozomi\"\n#define NOZOMI_NAME_TTY\t\t\"nozomi_tty\"\n\n#define NTTY_TTY_MAXMINORS\t256\n#define NTTY_FIFO_BUFFER_SIZE\t8192\n\n \n#define FIFO_BUFFER_SIZE_UL\t8192\n\n \n#define SEND_BUF_MAX\t\t1024\n#define RECEIVE_BUF_MAX\t\t4\n\n\n#define R_IIR\t\t\t0x0000\t \n#define R_FCR\t\t\t0x0000\t \n#define R_IER\t\t\t0x0004\t \n\n#define NOZOMI_CONFIG_MAGIC\t0xEFEFFEFE\n#define TOGGLE_VALID\t\t0x0000\n\n \n#define MDM_DL1\t\t\t0x0001\n#define MDM_UL1\t\t\t0x0002\n#define MDM_DL2\t\t\t0x0004\n#define MDM_UL2\t\t\t0x0008\n#define DIAG_DL1\t\t0x0010\n#define DIAG_DL2\t\t0x0020\n#define DIAG_UL\t\t\t0x0040\n#define APP1_DL\t\t\t0x0080\n#define APP1_UL\t\t\t0x0100\n#define APP2_DL\t\t\t0x0200\n#define APP2_UL\t\t\t0x0400\n#define CTRL_DL\t\t\t0x0800\n#define CTRL_UL\t\t\t0x1000\n#define RESET\t\t\t0x8000\n\n#define MDM_DL\t\t\t(MDM_DL1  | MDM_DL2)\n#define MDM_UL\t\t\t(MDM_UL1  | MDM_UL2)\n#define DIAG_DL\t\t\t(DIAG_DL1 | DIAG_DL2)\n\n \n#define CTRL_DSR\t\t0x0001\n#define CTRL_DCD\t\t0x0002\n#define CTRL_RI\t\t\t0x0004\n#define CTRL_CTS\t\t0x0008\n\n#define CTRL_DTR\t\t0x0001\n#define CTRL_RTS\t\t0x0002\n\n#define MAX_PORT\t\t4\n#define NOZOMI_MAX_PORTS\t5\n#define NOZOMI_MAX_CARDS\t(NTTY_TTY_MAXMINORS / MAX_PORT)\n\n \n\n \nenum card_type {\n\tF32_2 = 2048,\t \n\tF32_8 = 8192,\t \n};\n\n \nenum card_state {\n\tNOZOMI_STATE_UNKNOWN\t= 0,\n\tNOZOMI_STATE_ENABLED\t= 1,\t \n\tNOZOMI_STATE_ALLOCATED\t= 2,\t \n\tNOZOMI_STATE_READY\t= 3,\t \n};\n\n \nenum channel_type {\n\tCH_A = 0,\n\tCH_B = 1,\n};\n\n \nenum ctrl_port_type {\n\tCTRL_CMD\t= 0,\n\tCTRL_MDM\t= 1,\n\tCTRL_DIAG\t= 2,\n\tCTRL_APP1\t= 3,\n\tCTRL_APP2\t= 4,\n\tCTRL_ERROR\t= -1,\n};\n\n \nenum port_type {\n\tPORT_MDM\t= 0,\n\tPORT_DIAG\t= 1,\n\tPORT_APP1\t= 2,\n\tPORT_APP2\t= 3,\n\tPORT_CTRL\t= 4,\n\tPORT_ERROR\t= -1,\n};\n\n#ifdef __BIG_ENDIAN\n \n\nstruct toggles {\n\tunsigned int enabled:5;\t \n\tunsigned int diag_dl:1;\n\tunsigned int mdm_dl:1;\n\tunsigned int mdm_ul:1;\n} __attribute__ ((packed));\n\n \n \nstruct config_table {\n\tu32 signature;\n\tu16 product_information;\n\tu16 version;\n\tu8 pad3[3];\n\tstruct toggles toggle;\n\tu8 pad1[4];\n\tu16 dl_mdm_len1;\t \n\tu16 dl_start;\n\n\tu16 dl_diag_len1;\n\tu16 dl_mdm_len2;\t \n\tu16 dl_app1_len;\n\n\tu16 dl_diag_len2;\n\tu16 dl_ctrl_len;\n\tu16 dl_app2_len;\n\tu8 pad2[16];\n\tu16 ul_mdm_len1;\n\tu16 ul_start;\n\tu16 ul_diag_len;\n\tu16 ul_mdm_len2;\n\tu16 ul_app1_len;\n\tu16 ul_app2_len;\n\tu16 ul_ctrl_len;\n} __attribute__ ((packed));\n\n \nstruct ctrl_dl {\n\tu8 port;\n\tunsigned int reserved:4;\n\tunsigned int CTS:1;\n\tunsigned int RI:1;\n\tunsigned int DCD:1;\n\tunsigned int DSR:1;\n} __attribute__ ((packed));\n\n \nstruct ctrl_ul {\n\tu8 port;\n\tunsigned int reserved:6;\n\tunsigned int RTS:1;\n\tunsigned int DTR:1;\n} __attribute__ ((packed));\n\n#else\n \n\n \nstruct toggles {\n\tunsigned int mdm_ul:1;\n\tunsigned int mdm_dl:1;\n\tunsigned int diag_dl:1;\n\tunsigned int enabled:5;\t \n} __attribute__ ((packed));\n\n \nstruct config_table {\n\tu32 signature;\n\tu16 version;\n\tu16 product_information;\n\tstruct toggles toggle;\n\tu8 pad1[7];\n\tu16 dl_start;\n\tu16 dl_mdm_len1;\t \n\tu16 dl_mdm_len2;\n\tu16 dl_diag_len1;\n\tu16 dl_diag_len2;\n\tu16 dl_app1_len;\n\tu16 dl_app2_len;\n\tu16 dl_ctrl_len;\n\tu8 pad2[16];\n\tu16 ul_start;\n\tu16 ul_mdm_len2;\n\tu16 ul_mdm_len1;\n\tu16 ul_diag_len;\n\tu16 ul_app1_len;\n\tu16 ul_app2_len;\n\tu16 ul_ctrl_len;\n} __attribute__ ((packed));\n\n \nstruct ctrl_dl {\n\tunsigned int DSR:1;\n\tunsigned int DCD:1;\n\tunsigned int RI:1;\n\tunsigned int CTS:1;\n\tunsigned int reserved:4;\n\tu8 port;\n} __attribute__ ((packed));\n\n \nstruct ctrl_ul {\n\tunsigned int DTR:1;\n\tunsigned int RTS:1;\n\tunsigned int reserved:6;\n\tu8 port;\n} __attribute__ ((packed));\n#endif\n\n \nstruct port {\n\tstruct tty_port port;\n\tu8 update_flow_control;\n\tstruct ctrl_ul ctrl_ul;\n\tstruct ctrl_dl ctrl_dl;\n\tstruct kfifo fifo_ul;\n\tvoid __iomem *dl_addr[2];\n\tu32 dl_size[2];\n\tu8 toggle_dl;\n\tvoid __iomem *ul_addr[2];\n\tu32 ul_size[2];\n\tu8 toggle_ul;\n\tu16 token_dl;\n\n\twait_queue_head_t tty_wait;\n\tstruct async_icount tty_icount;\n\n\tstruct nozomi *dc;\n};\n\n \nstruct nozomi {\n\tvoid __iomem *base_addr;\n\tunsigned long flip;\n\n\t \n\tvoid __iomem *reg_iir;\n\tvoid __iomem *reg_fcr;\n\tvoid __iomem *reg_ier;\n\n\tu16 last_ier;\n\tenum card_type card_type;\n\tstruct config_table config_table;\t \n\tstruct pci_dev *pdev;\n\tstruct port port[NOZOMI_MAX_PORTS];\n\tu8 *send_buf;\n\n\tspinlock_t spin_mutex;\t \n\n\tunsigned int index_start;\n\tenum card_state state;\n\tu32 open_ttys;\n};\n\n \nstatic const struct pci_device_id nozomi_pci_tbl[] = {\n\t{PCI_DEVICE(0x1931, 0x000c)},\t \n\t{},\n};\n\nMODULE_DEVICE_TABLE(pci, nozomi_pci_tbl);\n\nstatic struct nozomi *ndevs[NOZOMI_MAX_CARDS];\nstatic struct tty_driver *ntty_driver;\n\nstatic const struct tty_port_operations noz_tty_port_ops;\n\n \nstatic inline struct nozomi *get_dc_by_tty(const struct tty_struct *tty)\n{\n\treturn tty ? ndevs[tty->index / MAX_PORT] : NULL;\n}\n\nstatic inline struct port *get_port_by_tty(const struct tty_struct *tty)\n{\n\tstruct nozomi *ndev = get_dc_by_tty(tty);\n\treturn ndev ? &ndev->port[tty->index % MAX_PORT] : NULL;\n}\n\n \n\nstatic void read_mem32(u32 *buf, const void __iomem *mem_addr_start,\n\t\t\tu32 size_bytes)\n{\n\tu32 i = 0;\n\tconst u32 __iomem *ptr = mem_addr_start;\n\tu16 *buf16;\n\n\tif (unlikely(!ptr || !buf))\n\t\tgoto out;\n\n\t \n\tswitch (size_bytes) {\n\tcase 2:\t \n\t\tbuf16 = (u16 *) buf;\n\t\t*buf16 = __le16_to_cpu(readw(ptr));\n\t\tgoto out;\n\tcase 4:\t \n\t\t*(buf) = __le32_to_cpu(readl(ptr));\n\t\tgoto out;\n\t}\n\n\twhile (i < size_bytes) {\n\t\tif (size_bytes - i == 2) {\n\t\t\t \n\t\t\tbuf16 = (u16 *) buf;\n\t\t\t*(buf16) = __le16_to_cpu(readw(ptr));\n\t\t\ti += 2;\n\t\t} else {\n\t\t\t \n\t\t\t*(buf) = __le32_to_cpu(readl(ptr));\n\t\t\ti += 4;\n\t\t}\n\t\tbuf++;\n\t\tptr++;\n\t}\nout:\n\treturn;\n}\n\n \nstatic u32 write_mem32(void __iomem *mem_addr_start, const u32 *buf,\n\t\t\tu32 size_bytes)\n{\n\tu32 i = 0;\n\tu32 __iomem *ptr = mem_addr_start;\n\tconst u16 *buf16;\n\n\tif (unlikely(!ptr || !buf))\n\t\treturn 0;\n\n\t \n\tswitch (size_bytes) {\n\tcase 2:\t \n\t\tbuf16 = (const u16 *)buf;\n\t\twritew(__cpu_to_le16(*buf16), ptr);\n\t\treturn 2;\n\tcase 1:  \n\t\tfallthrough;\n\tcase 4:  \n\t\twritel(__cpu_to_le32(*buf), ptr);\n\t\treturn 4;\n\t}\n\n\twhile (i < size_bytes) {\n\t\tif (size_bytes - i == 2) {\n\t\t\t \n\t\t\tbuf16 = (const u16 *)buf;\n\t\t\twritew(__cpu_to_le16(*buf16), ptr);\n\t\t\ti += 2;\n\t\t} else {\n\t\t\t \n\t\t\twritel(__cpu_to_le32(*buf), ptr);\n\t\t\ti += 4;\n\t\t}\n\t\tbuf++;\n\t\tptr++;\n\t}\n\treturn i;\n}\n\n \nstatic void nozomi_setup_memory(struct nozomi *dc)\n{\n\tvoid __iomem *offset = dc->base_addr + dc->config_table.dl_start;\n\t \n\tconst u16 buff_offset = 4;\n\n\t \n\tdc->port[PORT_MDM].dl_addr[CH_A] = offset;\n\tdc->port[PORT_MDM].dl_addr[CH_B] =\n\t\t\t\t(offset += dc->config_table.dl_mdm_len1);\n\tdc->port[PORT_MDM].dl_size[CH_A] =\n\t\t\t\tdc->config_table.dl_mdm_len1 - buff_offset;\n\tdc->port[PORT_MDM].dl_size[CH_B] =\n\t\t\t\tdc->config_table.dl_mdm_len2 - buff_offset;\n\n\t \n\tdc->port[PORT_DIAG].dl_addr[CH_A] =\n\t\t\t\t(offset += dc->config_table.dl_mdm_len2);\n\tdc->port[PORT_DIAG].dl_size[CH_A] =\n\t\t\t\tdc->config_table.dl_diag_len1 - buff_offset;\n\tdc->port[PORT_DIAG].dl_addr[CH_B] =\n\t\t\t\t(offset += dc->config_table.dl_diag_len1);\n\tdc->port[PORT_DIAG].dl_size[CH_B] =\n\t\t\t\tdc->config_table.dl_diag_len2 - buff_offset;\n\n\t \n\tdc->port[PORT_APP1].dl_addr[CH_A] =\n\t\t\t\t(offset += dc->config_table.dl_diag_len2);\n\tdc->port[PORT_APP1].dl_size[CH_A] =\n\t\t\t\tdc->config_table.dl_app1_len - buff_offset;\n\n\t \n\tdc->port[PORT_APP2].dl_addr[CH_A] =\n\t\t\t\t(offset += dc->config_table.dl_app1_len);\n\tdc->port[PORT_APP2].dl_size[CH_A] =\n\t\t\t\tdc->config_table.dl_app2_len - buff_offset;\n\n\t \n\tdc->port[PORT_CTRL].dl_addr[CH_A] =\n\t\t\t\t(offset += dc->config_table.dl_app2_len);\n\tdc->port[PORT_CTRL].dl_size[CH_A] =\n\t\t\t\tdc->config_table.dl_ctrl_len - buff_offset;\n\n\toffset = dc->base_addr + dc->config_table.ul_start;\n\n\t \n\tdc->port[PORT_MDM].ul_addr[CH_A] = offset;\n\tdc->port[PORT_MDM].ul_size[CH_A] =\n\t\t\t\tdc->config_table.ul_mdm_len1 - buff_offset;\n\tdc->port[PORT_MDM].ul_addr[CH_B] =\n\t\t\t\t(offset += dc->config_table.ul_mdm_len1);\n\tdc->port[PORT_MDM].ul_size[CH_B] =\n\t\t\t\tdc->config_table.ul_mdm_len2 - buff_offset;\n\n\t \n\tdc->port[PORT_DIAG].ul_addr[CH_A] =\n\t\t\t\t(offset += dc->config_table.ul_mdm_len2);\n\tdc->port[PORT_DIAG].ul_size[CH_A] =\n\t\t\t\tdc->config_table.ul_diag_len - buff_offset;\n\n\t \n\tdc->port[PORT_APP1].ul_addr[CH_A] =\n\t\t\t\t(offset += dc->config_table.ul_diag_len);\n\tdc->port[PORT_APP1].ul_size[CH_A] =\n\t\t\t\tdc->config_table.ul_app1_len - buff_offset;\n\n\t \n\tdc->port[PORT_APP2].ul_addr[CH_A] =\n\t\t\t\t(offset += dc->config_table.ul_app1_len);\n\tdc->port[PORT_APP2].ul_size[CH_A] =\n\t\t\t\tdc->config_table.ul_app2_len - buff_offset;\n\n\t \n\tdc->port[PORT_CTRL].ul_addr[CH_A] =\n\t\t\t\t(offset += dc->config_table.ul_app2_len);\n\tdc->port[PORT_CTRL].ul_size[CH_A] =\n\t\t\t\tdc->config_table.ul_ctrl_len - buff_offset;\n}\n\n \n#ifdef DEBUG\nstatic void dump_table(const struct nozomi *dc)\n{\n\tDBG3(\"signature: 0x%08X\", dc->config_table.signature);\n\tDBG3(\"version: 0x%04X\", dc->config_table.version);\n\tDBG3(\"product_information: 0x%04X\", \\\n\t\t\t\tdc->config_table.product_information);\n\tDBG3(\"toggle enabled: %d\", dc->config_table.toggle.enabled);\n\tDBG3(\"toggle up_mdm: %d\", dc->config_table.toggle.mdm_ul);\n\tDBG3(\"toggle dl_mdm: %d\", dc->config_table.toggle.mdm_dl);\n\tDBG3(\"toggle dl_dbg: %d\", dc->config_table.toggle.diag_dl);\n\n\tDBG3(\"dl_start: 0x%04X\", dc->config_table.dl_start);\n\tDBG3(\"dl_mdm_len0: 0x%04X, %d\", dc->config_table.dl_mdm_len1,\n\t   dc->config_table.dl_mdm_len1);\n\tDBG3(\"dl_mdm_len1: 0x%04X, %d\", dc->config_table.dl_mdm_len2,\n\t   dc->config_table.dl_mdm_len2);\n\tDBG3(\"dl_diag_len0: 0x%04X, %d\", dc->config_table.dl_diag_len1,\n\t   dc->config_table.dl_diag_len1);\n\tDBG3(\"dl_diag_len1: 0x%04X, %d\", dc->config_table.dl_diag_len2,\n\t   dc->config_table.dl_diag_len2);\n\tDBG3(\"dl_app1_len: 0x%04X, %d\", dc->config_table.dl_app1_len,\n\t   dc->config_table.dl_app1_len);\n\tDBG3(\"dl_app2_len: 0x%04X, %d\", dc->config_table.dl_app2_len,\n\t   dc->config_table.dl_app2_len);\n\tDBG3(\"dl_ctrl_len: 0x%04X, %d\", dc->config_table.dl_ctrl_len,\n\t   dc->config_table.dl_ctrl_len);\n\tDBG3(\"ul_start: 0x%04X, %d\", dc->config_table.ul_start,\n\t   dc->config_table.ul_start);\n\tDBG3(\"ul_mdm_len[0]: 0x%04X, %d\", dc->config_table.ul_mdm_len1,\n\t   dc->config_table.ul_mdm_len1);\n\tDBG3(\"ul_mdm_len[1]: 0x%04X, %d\", dc->config_table.ul_mdm_len2,\n\t   dc->config_table.ul_mdm_len2);\n\tDBG3(\"ul_diag_len: 0x%04X, %d\", dc->config_table.ul_diag_len,\n\t   dc->config_table.ul_diag_len);\n\tDBG3(\"ul_app1_len: 0x%04X, %d\", dc->config_table.ul_app1_len,\n\t   dc->config_table.ul_app1_len);\n\tDBG3(\"ul_app2_len: 0x%04X, %d\", dc->config_table.ul_app2_len,\n\t   dc->config_table.ul_app2_len);\n\tDBG3(\"ul_ctrl_len: 0x%04X, %d\", dc->config_table.ul_ctrl_len,\n\t   dc->config_table.ul_ctrl_len);\n}\n#else\nstatic inline void dump_table(const struct nozomi *dc) { }\n#endif\n\n \nstatic int nozomi_read_config_table(struct nozomi *dc)\n{\n\tread_mem32((u32 *) &dc->config_table, dc->base_addr + 0,\n\t\t\t\t\t\tsizeof(struct config_table));\n\n\tif (dc->config_table.signature != NOZOMI_CONFIG_MAGIC) {\n\t\tdev_err(&dc->pdev->dev, \"ConfigTable Bad! 0x%08X != 0x%08X\\n\",\n\t\t\tdc->config_table.signature, NOZOMI_CONFIG_MAGIC);\n\t\treturn 0;\n\t}\n\n\tif ((dc->config_table.version == 0)\n\t    || (dc->config_table.toggle.enabled == TOGGLE_VALID)) {\n\t\tint i;\n\t\tDBG1(\"Second phase, configuring card\");\n\n\t\tnozomi_setup_memory(dc);\n\n\t\tdc->port[PORT_MDM].toggle_ul = dc->config_table.toggle.mdm_ul;\n\t\tdc->port[PORT_MDM].toggle_dl = dc->config_table.toggle.mdm_dl;\n\t\tdc->port[PORT_DIAG].toggle_dl = dc->config_table.toggle.diag_dl;\n\t\tDBG1(\"toggle ports: MDM UL:%d MDM DL:%d, DIAG DL:%d\",\n\t\t   dc->port[PORT_MDM].toggle_ul,\n\t\t   dc->port[PORT_MDM].toggle_dl, dc->port[PORT_DIAG].toggle_dl);\n\n\t\tdump_table(dc);\n\n\t\tfor (i = PORT_MDM; i < MAX_PORT; i++) {\n\t\t\tmemset(&dc->port[i].ctrl_dl, 0, sizeof(struct ctrl_dl));\n\t\t\tmemset(&dc->port[i].ctrl_ul, 0, sizeof(struct ctrl_ul));\n\t\t}\n\n\t\t \n\t\tdc->last_ier = dc->last_ier | CTRL_DL;\n\t\twritew(dc->last_ier, dc->reg_ier);\n\n\t\tdc->state = NOZOMI_STATE_ALLOCATED;\n\t\tdev_info(&dc->pdev->dev, \"Initialization OK!\\n\");\n\t\treturn 1;\n\t}\n\n\tif ((dc->config_table.version > 0)\n\t    && (dc->config_table.toggle.enabled != TOGGLE_VALID)) {\n\t\tu32 offset = 0;\n\t\tDBG1(\"First phase: pushing upload buffers, clearing download\");\n\n\t\tdev_info(&dc->pdev->dev, \"Version of card: %d\\n\",\n\t\t\t dc->config_table.version);\n\n\t\t \n\t\tnozomi_setup_memory(dc);\n\n\t\t \n\n\t\t \n\t\twrite_mem32(dc->port[PORT_MDM].ul_addr[CH_A],\n\t\t\t(u32 *) &offset, 4);\n\t\twrite_mem32(dc->port[PORT_MDM].ul_addr[CH_B],\n\t\t\t(u32 *) &offset, 4);\n\n\t\twritew(MDM_UL | DIAG_DL | MDM_DL, dc->reg_fcr);\n\n\t\tDBG1(\"First phase done\");\n\t}\n\n\treturn 1;\n}\n\n \nstatic void enable_transmit_ul(enum port_type port, struct nozomi *dc)\n{\n\tstatic const u16 mask[] = {MDM_UL, DIAG_UL, APP1_UL, APP2_UL, CTRL_UL};\n\n\tif (port < NOZOMI_MAX_PORTS) {\n\t\tdc->last_ier |= mask[port];\n\t\twritew(dc->last_ier, dc->reg_ier);\n\t} else {\n\t\tdev_err(&dc->pdev->dev, \"Called with wrong port?\\n\");\n\t}\n}\n\n \nstatic void disable_transmit_ul(enum port_type port, struct nozomi *dc)\n{\n\tstatic const u16 mask[] =\n\t\t{~MDM_UL, ~DIAG_UL, ~APP1_UL, ~APP2_UL, ~CTRL_UL};\n\n\tif (port < NOZOMI_MAX_PORTS) {\n\t\tdc->last_ier &= mask[port];\n\t\twritew(dc->last_ier, dc->reg_ier);\n\t} else {\n\t\tdev_err(&dc->pdev->dev, \"Called with wrong port?\\n\");\n\t}\n}\n\n \nstatic void enable_transmit_dl(enum port_type port, struct nozomi *dc)\n{\n\tstatic const u16 mask[] = {MDM_DL, DIAG_DL, APP1_DL, APP2_DL, CTRL_DL};\n\n\tif (port < NOZOMI_MAX_PORTS) {\n\t\tdc->last_ier |= mask[port];\n\t\twritew(dc->last_ier, dc->reg_ier);\n\t} else {\n\t\tdev_err(&dc->pdev->dev, \"Called with wrong port?\\n\");\n\t}\n}\n\n \nstatic void disable_transmit_dl(enum port_type port, struct nozomi *dc)\n{\n\tstatic const u16 mask[] =\n\t\t{~MDM_DL, ~DIAG_DL, ~APP1_DL, ~APP2_DL, ~CTRL_DL};\n\n\tif (port < NOZOMI_MAX_PORTS) {\n\t\tdc->last_ier &= mask[port];\n\t\twritew(dc->last_ier, dc->reg_ier);\n\t} else {\n\t\tdev_err(&dc->pdev->dev, \"Called with wrong port?\\n\");\n\t}\n}\n\n \nstatic int send_data(enum port_type index, struct nozomi *dc)\n{\n\tu32 size = 0;\n\tstruct port *port = &dc->port[index];\n\tconst u8 toggle = port->toggle_ul;\n\tvoid __iomem *addr = port->ul_addr[toggle];\n\tconst u32 ul_size = port->ul_size[toggle];\n\n\t \n\tsize = kfifo_out(&port->fifo_ul, dc->send_buf,\n\t\t\t   ul_size < SEND_BUF_MAX ? ul_size : SEND_BUF_MAX);\n\n\tif (size == 0) {\n\t\tDBG4(\"No more data to send, disable link:\");\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\twrite_mem32(addr, (u32 *) &size, 4);\n\twrite_mem32(addr + 4, (u32 *) dc->send_buf, size);\n\n\ttty_port_tty_wakeup(&port->port);\n\n\treturn 1;\n}\n\n \nstatic int receive_data(enum port_type index, struct nozomi *dc)\n{\n\tu8 buf[RECEIVE_BUF_MAX] = { 0 };\n\tint size;\n\tu32 offset = 4;\n\tstruct port *port = &dc->port[index];\n\tvoid __iomem *addr = port->dl_addr[port->toggle_dl];\n\tstruct tty_struct *tty = tty_port_tty_get(&port->port);\n\tint i, ret;\n\n\tsize = __le32_to_cpu(readl(addr));\n\n\tif (tty && tty_throttled(tty)) {\n\t\tDBG1(\"No room in tty, don't read data, don't ack interrupt, \"\n\t\t\t\"disable interrupt\");\n\n\t\t \n\t\tdisable_transmit_dl(index, dc);\n\t\tret = 0;\n\t\tgoto put;\n\t}\n\n\tif (unlikely(size == 0)) {\n\t\tdev_err(&dc->pdev->dev, \"size == 0?\\n\");\n\t\tret = 1;\n\t\tgoto put;\n\t}\n\n\twhile (size > 0) {\n\t\tread_mem32((u32 *) buf, addr + offset, RECEIVE_BUF_MAX);\n\n\t\tif (size == 1) {\n\t\t\ttty_insert_flip_char(&port->port, buf[0], TTY_NORMAL);\n\t\t\tsize = 0;\n\t\t} else if (size < RECEIVE_BUF_MAX) {\n\t\t\tsize -= tty_insert_flip_string(&port->port,\n\t\t\t\t\t(char *)buf, size);\n\t\t} else {\n\t\t\ti = tty_insert_flip_string(&port->port,\n\t\t\t\t\t(char *)buf, RECEIVE_BUF_MAX);\n\t\t\tsize -= i;\n\t\t\toffset += i;\n\t\t}\n\t}\n\n\tset_bit(index, &dc->flip);\n\tret = 1;\nput:\n\ttty_kref_put(tty);\n\treturn ret;\n}\n\n \n#ifdef DEBUG\nstatic char *interrupt2str(u16 interrupt)\n{\n\tstatic char buf[TMP_BUF_MAX];\n\tchar *p = buf;\n\n\tif (interrupt & MDM_DL1)\n\t\tp += scnprintf(p, TMP_BUF_MAX, \"MDM_DL1 \");\n\tif (interrupt & MDM_DL2)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"MDM_DL2 \");\n\tif (interrupt & MDM_UL1)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"MDM_UL1 \");\n\tif (interrupt & MDM_UL2)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"MDM_UL2 \");\n\tif (interrupt & DIAG_DL1)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"DIAG_DL1 \");\n\tif (interrupt & DIAG_DL2)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"DIAG_DL2 \");\n\n\tif (interrupt & DIAG_UL)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"DIAG_UL \");\n\n\tif (interrupt & APP1_DL)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"APP1_DL \");\n\tif (interrupt & APP2_DL)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"APP2_DL \");\n\n\tif (interrupt & APP1_UL)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"APP1_UL \");\n\tif (interrupt & APP2_UL)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"APP2_UL \");\n\n\tif (interrupt & CTRL_DL)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"CTRL_DL \");\n\tif (interrupt & CTRL_UL)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"CTRL_UL \");\n\n\tif (interrupt & RESET)\n\t\tp += scnprintf(p, TMP_BUF_MAX - (p - buf), \"RESET \");\n\n\treturn buf;\n}\n#endif\n\n \nstatic int receive_flow_control(struct nozomi *dc)\n{\n\tenum port_type port = PORT_MDM;\n\tstruct ctrl_dl ctrl_dl;\n\tstruct ctrl_dl old_ctrl;\n\tu16 enable_ier = 0;\n\n\tread_mem32((u32 *) &ctrl_dl, dc->port[PORT_CTRL].dl_addr[CH_A], 2);\n\n\tswitch (ctrl_dl.port) {\n\tcase CTRL_CMD:\n\t\tDBG1(\"The Base Band sends this value as a response to a \"\n\t\t\t\"request for IMSI detach sent over the control \"\n\t\t\t\"channel uplink (see section 7.6.1).\");\n\t\tbreak;\n\tcase CTRL_MDM:\n\t\tport = PORT_MDM;\n\t\tenable_ier = MDM_DL;\n\t\tbreak;\n\tcase CTRL_DIAG:\n\t\tport = PORT_DIAG;\n\t\tenable_ier = DIAG_DL;\n\t\tbreak;\n\tcase CTRL_APP1:\n\t\tport = PORT_APP1;\n\t\tenable_ier = APP1_DL;\n\t\tbreak;\n\tcase CTRL_APP2:\n\t\tport = PORT_APP2;\n\t\tenable_ier = APP2_DL;\n\t\tif (dc->state == NOZOMI_STATE_ALLOCATED) {\n\t\t\t \n\t\t\tdc->state = NOZOMI_STATE_READY;\n\t\t\tdev_info(&dc->pdev->dev, \"Device READY!\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dc->pdev->dev,\n\t\t\t\"ERROR: flow control received for non-existing port\\n\");\n\t\treturn 0;\n\t}\n\n\tDBG1(\"0x%04X->0x%04X\", *((u16 *)&dc->port[port].ctrl_dl),\n\t   *((u16 *)&ctrl_dl));\n\n\told_ctrl = dc->port[port].ctrl_dl;\n\tdc->port[port].ctrl_dl = ctrl_dl;\n\n\tif (old_ctrl.CTS == 1 && ctrl_dl.CTS == 0) {\n\t\tDBG1(\"Disable interrupt (0x%04X) on port: %d\",\n\t\t\tenable_ier, port);\n\t\tdisable_transmit_ul(port, dc);\n\n\t} else if (old_ctrl.CTS == 0 && ctrl_dl.CTS == 1) {\n\n\t\tif (kfifo_len(&dc->port[port].fifo_ul)) {\n\t\t\tDBG1(\"Enable interrupt (0x%04X) on port: %d\",\n\t\t\t\tenable_ier, port);\n\t\t\tDBG1(\"Data in buffer [%d], enable transmit! \",\n\t\t\t\tkfifo_len(&dc->port[port].fifo_ul));\n\t\t\tenable_transmit_ul(port, dc);\n\t\t} else {\n\t\t\tDBG1(\"No data in buffer...\");\n\t\t}\n\t}\n\n\tif (*(u16 *)&old_ctrl == *(u16 *)&ctrl_dl) {\n\t\tDBG1(\" No change in mctrl\");\n\t\treturn 1;\n\t}\n\t \n\tif (old_ctrl.CTS != ctrl_dl.CTS)\n\t\tdc->port[port].tty_icount.cts++;\n\tif (old_ctrl.DSR != ctrl_dl.DSR)\n\t\tdc->port[port].tty_icount.dsr++;\n\tif (old_ctrl.RI != ctrl_dl.RI)\n\t\tdc->port[port].tty_icount.rng++;\n\tif (old_ctrl.DCD != ctrl_dl.DCD)\n\t\tdc->port[port].tty_icount.dcd++;\n\n\twake_up_interruptible(&dc->port[port].tty_wait);\n\n\tDBG1(\"port: %d DCD(%d), CTS(%d), RI(%d), DSR(%d)\",\n\t   port,\n\t   dc->port[port].tty_icount.dcd, dc->port[port].tty_icount.cts,\n\t   dc->port[port].tty_icount.rng, dc->port[port].tty_icount.dsr);\n\n\treturn 1;\n}\n\nstatic enum ctrl_port_type port2ctrl(enum port_type port,\n\t\t\t\t\tconst struct nozomi *dc)\n{\n\tswitch (port) {\n\tcase PORT_MDM:\n\t\treturn CTRL_MDM;\n\tcase PORT_DIAG:\n\t\treturn CTRL_DIAG;\n\tcase PORT_APP1:\n\t\treturn CTRL_APP1;\n\tcase PORT_APP2:\n\t\treturn CTRL_APP2;\n\tdefault:\n\t\tdev_err(&dc->pdev->dev,\n\t\t\t\"ERROR: send flow control \" \\\n\t\t\t\"received for non-existing port\\n\");\n\t}\n\treturn CTRL_ERROR;\n}\n\n \nstatic int send_flow_control(struct nozomi *dc)\n{\n\tu32 i, more_flow_control_to_be_updated = 0;\n\tu16 *ctrl;\n\n\tfor (i = PORT_MDM; i < MAX_PORT; i++) {\n\t\tif (dc->port[i].update_flow_control) {\n\t\t\tif (more_flow_control_to_be_updated) {\n\t\t\t\t \n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tdc->port[i].ctrl_ul.port = port2ctrl(i, dc);\n\t\t\tctrl = (u16 *)&dc->port[i].ctrl_ul;\n\t\t\twrite_mem32(dc->port[PORT_CTRL].ul_addr[0], \\\n\t\t\t\t(u32 *) ctrl, 2);\n\t\t\tdc->port[i].update_flow_control = 0;\n\t\t\tmore_flow_control_to_be_updated = 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int handle_data_dl(struct nozomi *dc, enum port_type port, u8 *toggle,\n\t\t\tu16 read_iir, u16 mask1, u16 mask2)\n{\n\tif (*toggle == 0 && read_iir & mask1) {\n\t\tif (receive_data(port, dc)) {\n\t\t\twritew(mask1, dc->reg_fcr);\n\t\t\t*toggle = !(*toggle);\n\t\t}\n\n\t\tif (read_iir & mask2) {\n\t\t\tif (receive_data(port, dc)) {\n\t\t\t\twritew(mask2, dc->reg_fcr);\n\t\t\t\t*toggle = !(*toggle);\n\t\t\t}\n\t\t}\n\t} else if (*toggle == 1 && read_iir & mask2) {\n\t\tif (receive_data(port, dc)) {\n\t\t\twritew(mask2, dc->reg_fcr);\n\t\t\t*toggle = !(*toggle);\n\t\t}\n\n\t\tif (read_iir & mask1) {\n\t\t\tif (receive_data(port, dc)) {\n\t\t\t\twritew(mask1, dc->reg_fcr);\n\t\t\t\t*toggle = !(*toggle);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_err(&dc->pdev->dev, \"port out of sync!, toggle:%d\\n\",\n\t\t\t*toggle);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic int handle_data_ul(struct nozomi *dc, enum port_type port, u16 read_iir)\n{\n\tu8 *toggle = &(dc->port[port].toggle_ul);\n\n\tif (*toggle == 0 && read_iir & MDM_UL1) {\n\t\tdc->last_ier &= ~MDM_UL;\n\t\twritew(dc->last_ier, dc->reg_ier);\n\t\tif (send_data(port, dc)) {\n\t\t\twritew(MDM_UL1, dc->reg_fcr);\n\t\t\tdc->last_ier = dc->last_ier | MDM_UL;\n\t\t\twritew(dc->last_ier, dc->reg_ier);\n\t\t\t*toggle = !*toggle;\n\t\t}\n\n\t\tif (read_iir & MDM_UL2) {\n\t\t\tdc->last_ier &= ~MDM_UL;\n\t\t\twritew(dc->last_ier, dc->reg_ier);\n\t\t\tif (send_data(port, dc)) {\n\t\t\t\twritew(MDM_UL2, dc->reg_fcr);\n\t\t\t\tdc->last_ier = dc->last_ier | MDM_UL;\n\t\t\t\twritew(dc->last_ier, dc->reg_ier);\n\t\t\t\t*toggle = !*toggle;\n\t\t\t}\n\t\t}\n\n\t} else if (*toggle == 1 && read_iir & MDM_UL2) {\n\t\tdc->last_ier &= ~MDM_UL;\n\t\twritew(dc->last_ier, dc->reg_ier);\n\t\tif (send_data(port, dc)) {\n\t\t\twritew(MDM_UL2, dc->reg_fcr);\n\t\t\tdc->last_ier = dc->last_ier | MDM_UL;\n\t\t\twritew(dc->last_ier, dc->reg_ier);\n\t\t\t*toggle = !*toggle;\n\t\t}\n\n\t\tif (read_iir & MDM_UL1) {\n\t\t\tdc->last_ier &= ~MDM_UL;\n\t\t\twritew(dc->last_ier, dc->reg_ier);\n\t\t\tif (send_data(port, dc)) {\n\t\t\t\twritew(MDM_UL1, dc->reg_fcr);\n\t\t\t\tdc->last_ier = dc->last_ier | MDM_UL;\n\t\t\t\twritew(dc->last_ier, dc->reg_ier);\n\t\t\t\t*toggle = !*toggle;\n\t\t\t}\n\t\t}\n\t} else {\n\t\twritew(read_iir & MDM_UL, dc->reg_fcr);\n\t\tdev_err(&dc->pdev->dev, \"port out of sync!\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic irqreturn_t interrupt_handler(int irq, void *dev_id)\n{\n\tstruct nozomi *dc = dev_id;\n\tunsigned int a;\n\tu16 read_iir;\n\n\tif (!dc)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&dc->spin_mutex);\n\tread_iir = readw(dc->reg_iir);\n\n\t \n\tif (read_iir == (u16)-1)\n\t\tgoto none;\n\t \n\tread_iir &= dc->last_ier;\n\n\tif (read_iir == 0)\n\t\tgoto none;\n\n\n\tDBG4(\"%s irq:0x%04X, prev:0x%04X\", interrupt2str(read_iir), read_iir,\n\t\tdc->last_ier);\n\n\tif (read_iir & RESET) {\n\t\tif (unlikely(!nozomi_read_config_table(dc))) {\n\t\t\tdc->last_ier = 0x0;\n\t\t\twritew(dc->last_ier, dc->reg_ier);\n\t\t\tdev_err(&dc->pdev->dev, \"Could not read status from \"\n\t\t\t\t\"card, we should disable interface\\n\");\n\t\t} else {\n\t\t\twritew(RESET, dc->reg_fcr);\n\t\t}\n\t\t \n\t\tgoto exit_handler;\n\t}\n\tif (read_iir & CTRL_UL) {\n\t\tDBG1(\"CTRL_UL\");\n\t\tdc->last_ier &= ~CTRL_UL;\n\t\twritew(dc->last_ier, dc->reg_ier);\n\t\tif (send_flow_control(dc)) {\n\t\t\twritew(CTRL_UL, dc->reg_fcr);\n\t\t\tdc->last_ier = dc->last_ier | CTRL_UL;\n\t\t\twritew(dc->last_ier, dc->reg_ier);\n\t\t}\n\t}\n\tif (read_iir & CTRL_DL) {\n\t\treceive_flow_control(dc);\n\t\twritew(CTRL_DL, dc->reg_fcr);\n\t}\n\tif (read_iir & MDM_DL) {\n\t\tif (!handle_data_dl(dc, PORT_MDM,\n\t\t\t\t&(dc->port[PORT_MDM].toggle_dl), read_iir,\n\t\t\t\tMDM_DL1, MDM_DL2)) {\n\t\t\tdev_err(&dc->pdev->dev, \"MDM_DL out of sync!\\n\");\n\t\t\tgoto exit_handler;\n\t\t}\n\t}\n\tif (read_iir & MDM_UL) {\n\t\tif (!handle_data_ul(dc, PORT_MDM, read_iir)) {\n\t\t\tdev_err(&dc->pdev->dev, \"MDM_UL out of sync!\\n\");\n\t\t\tgoto exit_handler;\n\t\t}\n\t}\n\tif (read_iir & DIAG_DL) {\n\t\tif (!handle_data_dl(dc, PORT_DIAG,\n\t\t\t\t&(dc->port[PORT_DIAG].toggle_dl), read_iir,\n\t\t\t\tDIAG_DL1, DIAG_DL2)) {\n\t\t\tdev_err(&dc->pdev->dev, \"DIAG_DL out of sync!\\n\");\n\t\t\tgoto exit_handler;\n\t\t}\n\t}\n\tif (read_iir & DIAG_UL) {\n\t\tdc->last_ier &= ~DIAG_UL;\n\t\twritew(dc->last_ier, dc->reg_ier);\n\t\tif (send_data(PORT_DIAG, dc)) {\n\t\t\twritew(DIAG_UL, dc->reg_fcr);\n\t\t\tdc->last_ier = dc->last_ier | DIAG_UL;\n\t\t\twritew(dc->last_ier, dc->reg_ier);\n\t\t}\n\t}\n\tif (read_iir & APP1_DL) {\n\t\tif (receive_data(PORT_APP1, dc))\n\t\t\twritew(APP1_DL, dc->reg_fcr);\n\t}\n\tif (read_iir & APP1_UL) {\n\t\tdc->last_ier &= ~APP1_UL;\n\t\twritew(dc->last_ier, dc->reg_ier);\n\t\tif (send_data(PORT_APP1, dc)) {\n\t\t\twritew(APP1_UL, dc->reg_fcr);\n\t\t\tdc->last_ier = dc->last_ier | APP1_UL;\n\t\t\twritew(dc->last_ier, dc->reg_ier);\n\t\t}\n\t}\n\tif (read_iir & APP2_DL) {\n\t\tif (receive_data(PORT_APP2, dc))\n\t\t\twritew(APP2_DL, dc->reg_fcr);\n\t}\n\tif (read_iir & APP2_UL) {\n\t\tdc->last_ier &= ~APP2_UL;\n\t\twritew(dc->last_ier, dc->reg_ier);\n\t\tif (send_data(PORT_APP2, dc)) {\n\t\t\twritew(APP2_UL, dc->reg_fcr);\n\t\t\tdc->last_ier = dc->last_ier | APP2_UL;\n\t\t\twritew(dc->last_ier, dc->reg_ier);\n\t\t}\n\t}\n\nexit_handler:\n\tspin_unlock(&dc->spin_mutex);\n\n\tfor (a = 0; a < NOZOMI_MAX_PORTS; a++)\n\t\tif (test_and_clear_bit(a, &dc->flip))\n\t\t\ttty_flip_buffer_push(&dc->port[a].port);\n\n\treturn IRQ_HANDLED;\nnone:\n\tspin_unlock(&dc->spin_mutex);\n\treturn IRQ_NONE;\n}\n\nstatic void nozomi_get_card_type(struct nozomi *dc)\n{\n\tint i;\n\tu32 size = 0;\n\n\tfor (i = 0; i < 6; i++)\n\t\tsize += pci_resource_len(dc->pdev, i);\n\n\t \n\tdc->card_type = size == 2048 ? F32_2 : F32_8;\n\n\tdev_info(&dc->pdev->dev, \"Card type is: %d\\n\", dc->card_type);\n}\n\nstatic void nozomi_setup_private_data(struct nozomi *dc)\n{\n\tvoid __iomem *offset = dc->base_addr + dc->card_type / 2;\n\tunsigned int i;\n\n\tdc->reg_fcr = (void __iomem *)(offset + R_FCR);\n\tdc->reg_iir = (void __iomem *)(offset + R_IIR);\n\tdc->reg_ier = (void __iomem *)(offset + R_IER);\n\tdc->last_ier = 0;\n\tdc->flip = 0;\n\n\tdc->port[PORT_MDM].token_dl = MDM_DL;\n\tdc->port[PORT_DIAG].token_dl = DIAG_DL;\n\tdc->port[PORT_APP1].token_dl = APP1_DL;\n\tdc->port[PORT_APP2].token_dl = APP2_DL;\n\n\tfor (i = 0; i < MAX_PORT; i++)\n\t\tinit_waitqueue_head(&dc->port[i].tty_wait);\n}\n\nstatic ssize_t card_type_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tconst struct nozomi *dc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", dc->card_type);\n}\nstatic DEVICE_ATTR_RO(card_type);\n\nstatic ssize_t open_ttys_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tconst struct nozomi *dc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", dc->open_ttys);\n}\nstatic DEVICE_ATTR_RO(open_ttys);\n\nstatic void make_sysfs_files(struct nozomi *dc)\n{\n\tif (device_create_file(&dc->pdev->dev, &dev_attr_card_type))\n\t\tdev_err(&dc->pdev->dev,\n\t\t\t\"Could not create sysfs file for card_type\\n\");\n\tif (device_create_file(&dc->pdev->dev, &dev_attr_open_ttys))\n\t\tdev_err(&dc->pdev->dev,\n\t\t\t\"Could not create sysfs file for open_ttys\\n\");\n}\n\nstatic void remove_sysfs_files(struct nozomi *dc)\n{\n\tdevice_remove_file(&dc->pdev->dev, &dev_attr_card_type);\n\tdevice_remove_file(&dc->pdev->dev, &dev_attr_open_ttys);\n}\n\n \nstatic int nozomi_card_init(struct pci_dev *pdev,\n\t\t\t\t      const struct pci_device_id *ent)\n{\n\tint ret;\n\tstruct nozomi *dc = NULL;\n\tint ndev_idx;\n\tint i;\n\n\tfor (ndev_idx = 0; ndev_idx < ARRAY_SIZE(ndevs); ndev_idx++)\n\t\tif (!ndevs[ndev_idx])\n\t\t\tbreak;\n\n\tif (ndev_idx >= ARRAY_SIZE(ndevs)) {\n\t\tdev_err(&pdev->dev, \"no free tty range for this card left\\n\");\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tdc = kzalloc(sizeof(struct nozomi), GFP_KERNEL);\n\tif (unlikely(!dc)) {\n\t\tdev_err(&pdev->dev, \"Could not allocate memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tdc->pdev = pdev;\n\n\tret = pci_enable_device(dc->pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to enable PCI Device\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = pci_request_regions(dc->pdev, NOZOMI_NAME);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"I/O address 0x%04x already in use\\n\",\n\t\t\t(int)   0);\n\t\tgoto err_disable_device;\n\t}\n\n\t \n\tnozomi_get_card_type(dc);\n\n\tdc->base_addr = pci_iomap(dc->pdev, 0, dc->card_type);\n\tif (!dc->base_addr) {\n\t\tdev_err(&pdev->dev, \"Unable to map card MMIO\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_rel_regs;\n\t}\n\n\tdc->send_buf = kmalloc(SEND_BUF_MAX, GFP_KERNEL);\n\tif (!dc->send_buf) {\n\t\tdev_err(&pdev->dev, \"Could not allocate send buffer?\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_sbuf;\n\t}\n\n\tfor (i = PORT_MDM; i < MAX_PORT; i++) {\n\t\tif (kfifo_alloc(&dc->port[i].fifo_ul, FIFO_BUFFER_SIZE_UL,\n\t\t\t\t\tGFP_KERNEL)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Could not allocate kfifo buffer\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_kfifo;\n\t\t}\n\t}\n\n\tspin_lock_init(&dc->spin_mutex);\n\n\tnozomi_setup_private_data(dc);\n\n\t \n\tdc->last_ier = 0;\n\twritew(dc->last_ier, dc->reg_ier);\n\n\tret = request_irq(pdev->irq, &interrupt_handler, IRQF_SHARED,\n\t\t\tNOZOMI_NAME, dc);\n\tif (unlikely(ret)) {\n\t\tdev_err(&pdev->dev, \"can't request irq %d\\n\", pdev->irq);\n\t\tgoto err_free_all_kfifo;\n\t}\n\n\tDBG1(\"base_addr: %p\", dc->base_addr);\n\n\tmake_sysfs_files(dc);\n\n\tdc->index_start = ndev_idx * MAX_PORT;\n\tndevs[ndev_idx] = dc;\n\n\tpci_set_drvdata(pdev, dc);\n\n\t \n\tdc->last_ier = RESET;\n\tiowrite16(dc->last_ier, dc->reg_ier);\n\n\tdc->state = NOZOMI_STATE_ENABLED;\n\n\tfor (i = 0; i < MAX_PORT; i++) {\n\t\tstruct device *tty_dev;\n\t\tstruct port *port = &dc->port[i];\n\t\tport->dc = dc;\n\t\ttty_port_init(&port->port);\n\t\tport->port.ops = &noz_tty_port_ops;\n\t\ttty_dev = tty_port_register_device(&port->port, ntty_driver,\n\t\t\t\tdc->index_start + i, &pdev->dev);\n\n\t\tif (IS_ERR(tty_dev)) {\n\t\t\tret = PTR_ERR(tty_dev);\n\t\t\tdev_err(&pdev->dev, \"Could not allocate tty?\\n\");\n\t\t\ttty_port_destroy(&port->port);\n\t\t\tgoto err_free_tty;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free_tty:\n\tfor (i--; i >= 0; i--) {\n\t\ttty_unregister_device(ntty_driver, dc->index_start + i);\n\t\ttty_port_destroy(&dc->port[i].port);\n\t}\n\tfree_irq(pdev->irq, dc);\nerr_free_all_kfifo:\n\ti = MAX_PORT;\nerr_free_kfifo:\n\tfor (i--; i >= PORT_MDM; i--)\n\t\tkfifo_free(&dc->port[i].fifo_ul);\nerr_free_sbuf:\n\tkfree(dc->send_buf);\n\tiounmap(dc->base_addr);\nerr_rel_regs:\n\tpci_release_regions(pdev);\nerr_disable_device:\n\tpci_disable_device(pdev);\nerr_free:\n\tkfree(dc);\nerr:\n\treturn ret;\n}\n\nstatic void tty_exit(struct nozomi *dc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < MAX_PORT; ++i)\n\t\ttty_port_tty_hangup(&dc->port[i].port, false);\n\n\t \n\twhile (dc->open_ttys)\n\t\tmsleep(1);\n\tfor (i = 0; i < MAX_PORT; ++i) {\n\t\ttty_unregister_device(ntty_driver, dc->index_start + i);\n\t\ttty_port_destroy(&dc->port[i].port);\n\t}\n}\n\n \nstatic void nozomi_card_exit(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct ctrl_ul ctrl;\n\tstruct nozomi *dc = pci_get_drvdata(pdev);\n\n\t \n\tdc->last_ier = 0;\n\twritew(dc->last_ier, dc->reg_ier);\n\n\ttty_exit(dc);\n\n\t \n\t \n\tctrl.port = 0x00;\n\tctrl.reserved = 0;\n\tctrl.RTS = 0;\n\tctrl.DTR = 1;\n\tDBG1(\"sending flow control 0x%04X\", *((u16 *)&ctrl));\n\n\t \n\twrite_mem32(dc->port[PORT_CTRL].ul_addr[0], (u32 *)&ctrl, 2);\n\twritew(CTRL_UL, dc->reg_fcr);\t \n\n\tremove_sysfs_files(dc);\n\n\tfree_irq(pdev->irq, dc);\n\n\tfor (i = 0; i < MAX_PORT; i++)\n\t\tkfifo_free(&dc->port[i].fifo_ul);\n\n\tkfree(dc->send_buf);\n\n\tiounmap(dc->base_addr);\n\n\tpci_release_regions(pdev);\n\n\tpci_disable_device(pdev);\n\n\tndevs[dc->index_start / MAX_PORT] = NULL;\n\n\tkfree(dc);\n}\n\nstatic void set_rts(const struct tty_struct *tty, int rts)\n{\n\tstruct port *port = get_port_by_tty(tty);\n\n\tport->ctrl_ul.RTS = rts;\n\tport->update_flow_control = 1;\n\tenable_transmit_ul(PORT_CTRL, get_dc_by_tty(tty));\n}\n\nstatic void set_dtr(const struct tty_struct *tty, int dtr)\n{\n\tstruct port *port = get_port_by_tty(tty);\n\n\tDBG1(\"SETTING DTR index: %d, dtr: %d\", tty->index, dtr);\n\n\tport->ctrl_ul.DTR = dtr;\n\tport->update_flow_control = 1;\n\tenable_transmit_ul(PORT_CTRL, get_dc_by_tty(tty));\n}\n\n \n\nstatic int ntty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct port *port = get_port_by_tty(tty);\n\tstruct nozomi *dc = get_dc_by_tty(tty);\n\tint ret;\n\tif (!port || !dc || dc->state != NOZOMI_STATE_READY)\n\t\treturn -ENODEV;\n\tret = tty_standard_install(driver, tty);\n\tif (ret == 0)\n\t\ttty->driver_data = port;\n\treturn ret;\n}\n\nstatic void ntty_cleanup(struct tty_struct *tty)\n{\n\ttty->driver_data = NULL;\n}\n\nstatic int ntty_activate(struct tty_port *tport, struct tty_struct *tty)\n{\n\tstruct port *port = container_of(tport, struct port, port);\n\tstruct nozomi *dc = port->dc;\n\tunsigned long flags;\n\n\tDBG1(\"open: %d\", port->token_dl);\n\tspin_lock_irqsave(&dc->spin_mutex, flags);\n\tdc->last_ier = dc->last_ier | port->token_dl;\n\twritew(dc->last_ier, dc->reg_ier);\n\tdc->open_ttys++;\n\tspin_unlock_irqrestore(&dc->spin_mutex, flags);\n\tprintk(\"noz: activated %d: %p\\n\", tty->index, tport);\n\treturn 0;\n}\n\nstatic int ntty_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct port *port = tty->driver_data;\n\treturn tty_port_open(&port->port, tty, filp);\n}\n\nstatic void ntty_shutdown(struct tty_port *tport)\n{\n\tstruct port *port = container_of(tport, struct port, port);\n\tstruct nozomi *dc = port->dc;\n\tunsigned long flags;\n\n\tDBG1(\"close: %d\", port->token_dl);\n\tspin_lock_irqsave(&dc->spin_mutex, flags);\n\tdc->last_ier &= ~(port->token_dl);\n\twritew(dc->last_ier, dc->reg_ier);\n\tdc->open_ttys--;\n\tspin_unlock_irqrestore(&dc->spin_mutex, flags);\n\tprintk(\"noz: shutdown %p\\n\", tport);\n}\n\nstatic void ntty_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct port *port = tty->driver_data;\n\tif (port)\n\t\ttty_port_close(&port->port, tty, filp);\n}\n\nstatic void ntty_hangup(struct tty_struct *tty)\n{\n\tstruct port *port = tty->driver_data;\n\ttty_port_hangup(&port->port);\n}\n\n \nstatic ssize_t ntty_write(struct tty_struct *tty, const u8 *buffer,\n\t\t\t  size_t count)\n{\n\tint rval = -EINVAL;\n\tstruct nozomi *dc = get_dc_by_tty(tty);\n\tstruct port *port = tty->driver_data;\n\tunsigned long flags;\n\n\tif (!dc || !port)\n\t\treturn -ENODEV;\n\n\trval = kfifo_in(&port->fifo_ul, buffer, count);\n\n\tspin_lock_irqsave(&dc->spin_mutex, flags);\n\t \n\tif (port == &(dc->port[PORT_MDM])) {\n\t\tif (port->ctrl_dl.CTS) {\n\t\t\tDBG4(\"Enable interrupt\");\n\t\t\tenable_transmit_ul(tty->index % MAX_PORT, dc);\n\t\t} else {\n\t\t\tdev_err(&dc->pdev->dev,\n\t\t\t\t\"CTS not active on modem port?\\n\");\n\t\t}\n\t} else {\n\t\tenable_transmit_ul(tty->index % MAX_PORT, dc);\n\t}\n\tspin_unlock_irqrestore(&dc->spin_mutex, flags);\n\n\treturn rval;\n}\n\n \nstatic unsigned int ntty_write_room(struct tty_struct *tty)\n{\n\tstruct port *port = tty->driver_data;\n\tunsigned int room = 4096;\n\tconst struct nozomi *dc = get_dc_by_tty(tty);\n\n\tif (dc)\n\t\troom = kfifo_avail(&port->fifo_ul);\n\n\treturn room;\n}\n\n \nstatic int ntty_tiocmget(struct tty_struct *tty)\n{\n\tconst struct port *port = tty->driver_data;\n\tconst struct ctrl_dl *ctrl_dl = &port->ctrl_dl;\n\tconst struct ctrl_ul *ctrl_ul = &port->ctrl_ul;\n\n\t \n\treturn (ctrl_ul->RTS ? TIOCM_RTS : 0)\n\t\t| (ctrl_ul->DTR ? TIOCM_DTR : 0)\n\t\t| (ctrl_dl->DCD ? TIOCM_CAR : 0)\n\t\t| (ctrl_dl->RI  ? TIOCM_RNG : 0)\n\t\t| (ctrl_dl->DSR ? TIOCM_DSR : 0)\n\t\t| (ctrl_dl->CTS ? TIOCM_CTS : 0);\n}\n\n \nstatic int ntty_tiocmset(struct tty_struct *tty,\n\t\t\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct nozomi *dc = get_dc_by_tty(tty);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dc->spin_mutex, flags);\n\tif (set & TIOCM_RTS)\n\t\tset_rts(tty, 1);\n\telse if (clear & TIOCM_RTS)\n\t\tset_rts(tty, 0);\n\n\tif (set & TIOCM_DTR)\n\t\tset_dtr(tty, 1);\n\telse if (clear & TIOCM_DTR)\n\t\tset_dtr(tty, 0);\n\tspin_unlock_irqrestore(&dc->spin_mutex, flags);\n\n\treturn 0;\n}\n\nstatic int ntty_cflags_changed(struct port *port, unsigned long flags,\n\t\tstruct async_icount *cprev)\n{\n\tconst struct async_icount cnow = port->tty_icount;\n\tint ret;\n\n\tret = ((flags & TIOCM_RNG) && (cnow.rng != cprev->rng))\n\t\t|| ((flags & TIOCM_DSR) && (cnow.dsr != cprev->dsr))\n\t\t|| ((flags & TIOCM_CD)  && (cnow.dcd != cprev->dcd))\n\t\t|| ((flags & TIOCM_CTS) && (cnow.cts != cprev->cts));\n\n\t*cprev = cnow;\n\n\treturn ret;\n}\n\nstatic int ntty_tiocgicount(struct tty_struct *tty,\n\t\t\t\tstruct serial_icounter_struct *icount)\n{\n\tstruct port *port = tty->driver_data;\n\tconst struct async_icount cnow = port->tty_icount;\n\n\ticount->cts = cnow.cts;\n\ticount->dsr = cnow.dsr;\n\ticount->rng = cnow.rng;\n\ticount->dcd = cnow.dcd;\n\ticount->rx = cnow.rx;\n\ticount->tx = cnow.tx;\n\ticount->frame = cnow.frame;\n\ticount->overrun = cnow.overrun;\n\ticount->parity = cnow.parity;\n\ticount->brk = cnow.brk;\n\ticount->buf_overrun = cnow.buf_overrun;\n\treturn 0;\n}\n\nstatic int ntty_ioctl(struct tty_struct *tty,\n\t\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct port *port = tty->driver_data;\n\tint rval = -ENOIOCTLCMD;\n\n\tswitch (cmd) {\n\tcase TIOCMIWAIT: {\n\t\tstruct async_icount cprev = port->tty_icount;\n\n\t\trval = wait_event_interruptible(port->tty_wait,\n\t\t\t\tntty_cflags_changed(port, arg, &cprev));\n\t\tbreak;\n\t}\n\tdefault:\n\t\tDBG1(\"ERR: 0x%08X, %d\", cmd, cmd);\n\t\tbreak;\n\t}\n\n\treturn rval;\n}\n\n \nstatic void ntty_unthrottle(struct tty_struct *tty)\n{\n\tstruct nozomi *dc = get_dc_by_tty(tty);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dc->spin_mutex, flags);\n\tenable_transmit_dl(tty->index % MAX_PORT, dc);\n\tset_rts(tty, 1);\n\n\tspin_unlock_irqrestore(&dc->spin_mutex, flags);\n}\n\n \nstatic void ntty_throttle(struct tty_struct *tty)\n{\n\tstruct nozomi *dc = get_dc_by_tty(tty);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dc->spin_mutex, flags);\n\tset_rts(tty, 0);\n\tspin_unlock_irqrestore(&dc->spin_mutex, flags);\n}\n\n \nstatic unsigned int ntty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct port *port = tty->driver_data;\n\tstruct nozomi *dc = get_dc_by_tty(tty);\n\n\tif (unlikely(!dc || !port))\n\t\treturn 0;\n\n\treturn kfifo_len(&port->fifo_ul);\n}\n\nstatic const struct tty_port_operations noz_tty_port_ops = {\n\t.activate = ntty_activate,\n\t.shutdown = ntty_shutdown,\n};\n\nstatic const struct tty_operations tty_ops = {\n\t.ioctl = ntty_ioctl,\n\t.open = ntty_open,\n\t.close = ntty_close,\n\t.hangup = ntty_hangup,\n\t.write = ntty_write,\n\t.write_room = ntty_write_room,\n\t.unthrottle = ntty_unthrottle,\n\t.throttle = ntty_throttle,\n\t.chars_in_buffer = ntty_chars_in_buffer,\n\t.tiocmget = ntty_tiocmget,\n\t.tiocmset = ntty_tiocmset,\n\t.get_icount = ntty_tiocgicount,\n\t.install = ntty_install,\n\t.cleanup = ntty_cleanup,\n};\n\n \nstatic struct pci_driver nozomi_driver = {\n\t.name = NOZOMI_NAME,\n\t.id_table = nozomi_pci_tbl,\n\t.probe = nozomi_card_init,\n\t.remove = nozomi_card_exit,\n};\n\nstatic __init int nozomi_init(void)\n{\n\tint ret;\n\n\tntty_driver = tty_alloc_driver(NTTY_TTY_MAXMINORS, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(ntty_driver))\n\t\treturn PTR_ERR(ntty_driver);\n\n\tntty_driver->driver_name = NOZOMI_NAME_TTY;\n\tntty_driver->name = \"noz\";\n\tntty_driver->major = 0;\n\tntty_driver->type = TTY_DRIVER_TYPE_SERIAL;\n\tntty_driver->subtype = SERIAL_TYPE_NORMAL;\n\tntty_driver->init_termios = tty_std_termios;\n\tntty_driver->init_termios.c_cflag = B115200 | CS8 | CREAD | \\\n\t\t\t\t\t\tHUPCL | CLOCAL;\n\tntty_driver->init_termios.c_ispeed = 115200;\n\tntty_driver->init_termios.c_ospeed = 115200;\n\ttty_set_operations(ntty_driver, &tty_ops);\n\n\tret = tty_register_driver(ntty_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"Nozomi: failed to register ntty driver\\n\");\n\t\tgoto free_tty;\n\t}\n\n\tret = pci_register_driver(&nozomi_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"Nozomi: can't register pci driver\\n\");\n\t\tgoto unr_tty;\n\t}\n\n\treturn 0;\nunr_tty:\n\ttty_unregister_driver(ntty_driver);\nfree_tty:\n\ttty_driver_kref_put(ntty_driver);\n\treturn ret;\n}\n\nstatic __exit void nozomi_exit(void)\n{\n\tpci_unregister_driver(&nozomi_driver);\n\ttty_unregister_driver(ntty_driver);\n\ttty_driver_kref_put(ntty_driver);\n}\n\nmodule_init(nozomi_init);\nmodule_exit(nozomi_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Nozomi driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}