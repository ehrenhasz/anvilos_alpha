{
  "module_name": "mxser.c",
  "hash_id": "688ab4a38ebd287274c513e17cbb97158c2b4304b28149e5e53137437f328082",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/mxser.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/ratelimit.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n \n\n \n\n#define MOXA\t\t\t0x400\n#define MOXA_SET_OP_MODE\t(MOXA + 66)\n#define MOXA_GET_OP_MODE\t(MOXA + 67)\n\n#define RS232_MODE\t\t0\n#define RS485_2WIRE_MODE\t1\n#define RS422_MODE\t\t2\n#define RS485_4WIRE_MODE\t3\n#define OP_MODE_MASK\t\t3\n\n \n\n \n#define MOXA_MUST_ENTER_ENHANCED\t0xBF\n\n \n#define MOXA_MUST_GDL_REGISTER\t\t0x07\n#define MOXA_MUST_GDL_MASK\t\t0x7F\n#define MOXA_MUST_GDL_HAS_BAD_DATA\t0x80\n\n#define MOXA_MUST_LSR_RERR\t\t0x80\t \n \n \n#define MOXA_MUST_EFR_REGISTER\t\t0x02\n#define MOXA_MUST_EFR_EFRB_ENABLE\t0x10  \n \n#define MOXA_MUST_EFR_BANK0\t\t0x00\n#define MOXA_MUST_EFR_BANK1\t\t0x40\n#define MOXA_MUST_EFR_BANK2\t\t0x80\n#define MOXA_MUST_EFR_BANK3\t\t0xC0\n#define MOXA_MUST_EFR_BANK_MASK\t\t0xC0\n\n \n#define MOXA_MUST_XON1_REGISTER\t\t0x04\n\n \n#define MOXA_MUST_XON2_REGISTER\t\t0x05\n\n \n#define MOXA_MUST_XOFF1_REGISTER\t0x06\n\n \n#define MOXA_MUST_XOFF2_REGISTER\t0x07\n\n#define MOXA_MUST_RBRTL_REGISTER\t0x04\n#define MOXA_MUST_RBRTH_REGISTER\t0x05\n#define MOXA_MUST_RBRTI_REGISTER\t0x06\n#define MOXA_MUST_THRTL_REGISTER\t0x07\n#define MOXA_MUST_ENUM_REGISTER\t\t0x04\n#define MOXA_MUST_HWID_REGISTER\t\t0x05\n#define MOXA_MUST_ECR_REGISTER\t\t0x06\n#define MOXA_MUST_CSR_REGISTER\t\t0x07\n\n#define MOXA_MUST_FCR_GDA_MODE_ENABLE\t0x20  \n#define MOXA_MUST_FCR_GDA_ONLY_ENABLE\t0x10  \n\n#define MOXA_MUST_IER_ECTSI\t\t0x80  \n#define MOXA_MUST_IER_ERTSI\t\t0x40  \n#define MOXA_MUST_IER_XINT\t\t0x20  \n#define MOXA_MUST_IER_EGDAI\t\t0x10  \n\n#define MOXA_MUST_RECV_ISR\t\t(UART_IER_RDI | MOXA_MUST_IER_EGDAI)\n\n \n#define MOXA_MUST_IIR_GDA\t\t0x1C\n#define MOXA_MUST_IIR_RDA\t\t0x04\n#define MOXA_MUST_IIR_RTO\t\t0x0C\n#define MOXA_MUST_IIR_LSR\t\t0x06\n\n \n#define MOXA_MUST_IIR_XSC\t\t0x10\n\n \n#define MOXA_MUST_IIR_RTSCTS\t\t0x20\n#define MOXA_MUST_IIR_MASK\t\t0x3E\n\n#define MOXA_MUST_MCR_XON_FLAG\t\t0x40\n#define MOXA_MUST_MCR_XON_ANY\t\t0x80\n#define MOXA_MUST_MCR_TX_XON\t\t0x08\n\n#define MOXA_MUST_EFR_SF_MASK\t\t0x0F  \n#define MOXA_MUST_EFR_SF_TX1\t\t0x08  \n#define MOXA_MUST_EFR_SF_TX2\t\t0x04  \n#define MOXA_MUST_EFR_SF_TX12\t\t0x0C  \n#define MOXA_MUST_EFR_SF_TX_NO\t\t0x00  \n#define MOXA_MUST_EFR_SF_TX_MASK\t0x0C  \n#define MOXA_MUST_EFR_SF_RX_NO\t\t0x00  \n#define MOXA_MUST_EFR_SF_RX1\t\t0x02  \n#define MOXA_MUST_EFR_SF_RX2\t\t0x01  \n#define MOXA_MUST_EFR_SF_RX12\t\t0x03  \n#define MOXA_MUST_EFR_SF_RX_MASK\t0x03  \n\n#define\tMXSERMAJOR\t 174\n\n#define MXSER_BOARDS\t\t4\t \n#define MXSER_PORTS_PER_BOARD\t8\t \n#define MXSER_PORTS\t\t(MXSER_BOARDS * MXSER_PORTS_PER_BOARD)\n#define MXSER_ISR_PASS_LIMIT\t100\n\n#define WAKEUP_CHARS\t\t256\n\n#define MXSER_BAUD_BASE\t\t921600\n#define MXSER_CUSTOM_DIVISOR\t(MXSER_BAUD_BASE * 16)\n\n#define PCI_DEVICE_ID_MOXA_RC7000\t0x0001\n#define PCI_DEVICE_ID_MOXA_CP102\t0x1020\n#define PCI_DEVICE_ID_MOXA_CP102UL\t0x1021\n#define PCI_DEVICE_ID_MOXA_CP102U\t0x1022\n#define PCI_DEVICE_ID_MOXA_CP102UF\t0x1023\n#define PCI_DEVICE_ID_MOXA_C104\t\t0x1040\n#define PCI_DEVICE_ID_MOXA_CP104U\t0x1041\n#define PCI_DEVICE_ID_MOXA_CP104JU\t0x1042\n#define PCI_DEVICE_ID_MOXA_CP104EL\t0x1043\n#define PCI_DEVICE_ID_MOXA_POS104UL\t0x1044\n#define PCI_DEVICE_ID_MOXA_CB108\t0x1080\n#define PCI_DEVICE_ID_MOXA_CP112UL\t0x1120\n#define PCI_DEVICE_ID_MOXA_CT114\t0x1140\n#define PCI_DEVICE_ID_MOXA_CP114\t0x1141\n#define PCI_DEVICE_ID_MOXA_CB114\t0x1142\n#define PCI_DEVICE_ID_MOXA_CP114UL\t0x1143\n#define PCI_DEVICE_ID_MOXA_CP118U\t0x1180\n#define PCI_DEVICE_ID_MOXA_CP118EL\t0x1181\n#define PCI_DEVICE_ID_MOXA_CP132\t0x1320\n#define PCI_DEVICE_ID_MOXA_CP132U\t0x1321\n#define PCI_DEVICE_ID_MOXA_CP134U\t0x1340\n#define PCI_DEVICE_ID_MOXA_CB134I\t0x1341\n#define PCI_DEVICE_ID_MOXA_CP138U\t0x1380\n#define PCI_DEVICE_ID_MOXA_C168\t\t0x1680\n#define PCI_DEVICE_ID_MOXA_CP168U\t0x1681\n#define PCI_DEVICE_ID_MOXA_CP168EL\t0x1682\n\n#define MXSER_NPORTS(ddata)\t\t((ddata) & 0xffU)\n#define MXSER_HIGHBAUD\t\t\t0x0100\n\nenum mxser_must_hwid {\n\tMOXA_OTHER_UART\t\t= 0x00,\n\tMOXA_MUST_MU150_HWID\t= 0x01,\n\tMOXA_MUST_MU860_HWID\t= 0x02,\n};\n\nstatic const struct {\n\tu8 type;\n\tu8 fifo_size;\n\tu8 rx_high_water;\n\tu8 rx_low_water;\n\tspeed_t max_baud;\n} Gpci_uart_info[] = {\n\t{ MOXA_OTHER_UART,\t 16, 14,  1, 921600 },\n\t{ MOXA_MUST_MU150_HWID,\t 64, 48, 16, 230400 },\n\t{ MOXA_MUST_MU860_HWID, 128, 96, 32, 921600 }\n};\n#define UART_INFO_NUM\tARRAY_SIZE(Gpci_uart_info)\n\n\n \nstatic const struct pci_device_id mxser_pcibrds[] = {\n\t{ PCI_DEVICE_DATA(MOXA, C168,\t\t8) },\n\t{ PCI_DEVICE_DATA(MOXA, C104,\t\t4) },\n\t{ PCI_DEVICE_DATA(MOXA, CP132,\t\t2) },\n\t{ PCI_DEVICE_DATA(MOXA, CP114,\t\t4) },\n\t{ PCI_DEVICE_DATA(MOXA, CT114,\t\t4) },\n\t{ PCI_DEVICE_DATA(MOXA, CP102,\t\t2 | MXSER_HIGHBAUD) },\n\t{ PCI_DEVICE_DATA(MOXA, CP104U,\t\t4) },\n\t{ PCI_DEVICE_DATA(MOXA, CP168U,\t\t8) },\n\t{ PCI_DEVICE_DATA(MOXA, CP132U,\t\t2) },\n\t{ PCI_DEVICE_DATA(MOXA, CP134U,\t\t4) },\n\t{ PCI_DEVICE_DATA(MOXA, CP104JU,\t4) },\n\t{ PCI_DEVICE_DATA(MOXA, RC7000,\t\t8) },  \n\t{ PCI_DEVICE_DATA(MOXA, CP118U,\t\t8) },\n\t{ PCI_DEVICE_DATA(MOXA, CP102UL,\t2) },\n\t{ PCI_DEVICE_DATA(MOXA, CP102U,\t\t2) },\n\t{ PCI_DEVICE_DATA(MOXA, CP118EL,\t8) },\n\t{ PCI_DEVICE_DATA(MOXA, CP168EL,\t8) },\n\t{ PCI_DEVICE_DATA(MOXA, CP104EL,\t4) },\n\t{ PCI_DEVICE_DATA(MOXA, CB108,\t\t8) },\n\t{ PCI_DEVICE_DATA(MOXA, CB114,\t\t4) },\n\t{ PCI_DEVICE_DATA(MOXA, CB134I,\t\t4) },\n\t{ PCI_DEVICE_DATA(MOXA, CP138U,\t\t8) },\n\t{ PCI_DEVICE_DATA(MOXA, POS104UL,\t4) },\n\t{ PCI_DEVICE_DATA(MOXA, CP114UL,\t4) },\n\t{ PCI_DEVICE_DATA(MOXA, CP102UF,\t2) },\n\t{ PCI_DEVICE_DATA(MOXA, CP112UL,\t2) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, mxser_pcibrds);\n\nstatic int ttymajor = MXSERMAJOR;\n\n \n\nMODULE_AUTHOR(\"Casper Yang\");\nMODULE_DESCRIPTION(\"MOXA Smartio/Industio Family Multiport Board Device Driver\");\nmodule_param(ttymajor, int, 0);\nMODULE_LICENSE(\"GPL\");\n\nstruct mxser_board;\n\nstruct mxser_port {\n\tstruct tty_port port;\n\tstruct mxser_board *board;\n\n\tunsigned long ioaddr;\n\tunsigned long opmode_ioaddr;\n\n\tu8 rx_high_water;\n\tu8 rx_low_water;\n\tint type;\t\t \n\n\tunsigned char x_char;\t \n\tu8 IER;\t\t\t \n\tu8 MCR;\t\t\t \n\tu8 FCR;\t\t\t \n\n\tstruct async_icount icount;  \n\tunsigned int timeout;\n\n\tu8 read_status_mask;\n\tu8 ignore_status_mask;\n\tu8 xmit_fifo_size;\n\n\tspinlock_t slock;\n};\n\nstruct mxser_board {\n\tunsigned int idx;\n\tunsigned short nports;\n\tint irq;\n\tunsigned long vector;\n\n\tenum mxser_must_hwid must_hwid;\n\tspeed_t max_baud;\n\n\tstruct mxser_port ports[];\n};\n\nstatic DECLARE_BITMAP(mxser_boards, MXSER_BOARDS);\nstatic struct tty_driver *mxvar_sdriver;\n\nstatic u8 __mxser_must_set_EFR(unsigned long baseio, u8 clear, u8 set,\n\t\tbool restore_LCR)\n{\n\tu8 oldlcr, efr;\n\n\toldlcr = inb(baseio + UART_LCR);\n\toutb(MOXA_MUST_ENTER_ENHANCED, baseio + UART_LCR);\n\n\tefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\n\tefr &= ~clear;\n\tefr |= set;\n\n\toutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\n\n\tif (restore_LCR)\n\t\toutb(oldlcr, baseio + UART_LCR);\n\n\treturn oldlcr;\n}\n\nstatic u8 mxser_must_select_bank(unsigned long baseio, u8 bank)\n{\n\treturn __mxser_must_set_EFR(baseio, MOXA_MUST_EFR_BANK_MASK, bank,\n\t\t\tfalse);\n}\n\nstatic void mxser_set_must_xon1_value(unsigned long baseio, u8 value)\n{\n\tu8 oldlcr = mxser_must_select_bank(baseio, MOXA_MUST_EFR_BANK0);\n\toutb(value, baseio + MOXA_MUST_XON1_REGISTER);\n\toutb(oldlcr, baseio + UART_LCR);\n}\n\nstatic void mxser_set_must_xoff1_value(unsigned long baseio, u8 value)\n{\n\tu8 oldlcr = mxser_must_select_bank(baseio, MOXA_MUST_EFR_BANK0);\n\toutb(value, baseio + MOXA_MUST_XOFF1_REGISTER);\n\toutb(oldlcr, baseio + UART_LCR);\n}\n\nstatic void mxser_set_must_fifo_value(struct mxser_port *info)\n{\n\tu8 oldlcr = mxser_must_select_bank(info->ioaddr, MOXA_MUST_EFR_BANK1);\n\toutb(info->rx_high_water, info->ioaddr + MOXA_MUST_RBRTH_REGISTER);\n\toutb(info->rx_high_water, info->ioaddr + MOXA_MUST_RBRTI_REGISTER);\n\toutb(info->rx_low_water, info->ioaddr + MOXA_MUST_RBRTL_REGISTER);\n\toutb(oldlcr, info->ioaddr + UART_LCR);\n}\n\nstatic void mxser_set_must_enum_value(unsigned long baseio, u8 value)\n{\n\tu8 oldlcr = mxser_must_select_bank(baseio, MOXA_MUST_EFR_BANK2);\n\toutb(value, baseio + MOXA_MUST_ENUM_REGISTER);\n\toutb(oldlcr, baseio + UART_LCR);\n}\n\nstatic u8 mxser_get_must_hardware_id(unsigned long baseio)\n{\n\tu8 oldlcr = mxser_must_select_bank(baseio, MOXA_MUST_EFR_BANK2);\n\tu8 id = inb(baseio + MOXA_MUST_HWID_REGISTER);\n\toutb(oldlcr, baseio + UART_LCR);\n\n\treturn id;\n}\n\nstatic void mxser_must_set_EFR(unsigned long baseio, u8 clear, u8 set)\n{\n\t__mxser_must_set_EFR(baseio, clear, set, true);\n}\n\nstatic void mxser_must_set_enhance_mode(unsigned long baseio, bool enable)\n{\n\tmxser_must_set_EFR(baseio,\n\t\t\tenable ? 0 : MOXA_MUST_EFR_EFRB_ENABLE,\n\t\t\tenable ? MOXA_MUST_EFR_EFRB_ENABLE : 0);\n}\n\nstatic void mxser_must_no_sw_flow_control(unsigned long baseio)\n{\n\tmxser_must_set_EFR(baseio, MOXA_MUST_EFR_SF_MASK, 0);\n}\n\nstatic void mxser_must_set_tx_sw_flow_control(unsigned long baseio, bool enable)\n{\n\tmxser_must_set_EFR(baseio, MOXA_MUST_EFR_SF_TX_MASK,\n\t\t\tenable ? MOXA_MUST_EFR_SF_TX1 : 0);\n}\n\nstatic void mxser_must_set_rx_sw_flow_control(unsigned long baseio, bool enable)\n{\n\tmxser_must_set_EFR(baseio, MOXA_MUST_EFR_SF_RX_MASK,\n\t\t\tenable ? MOXA_MUST_EFR_SF_RX1 : 0);\n}\n\nstatic enum mxser_must_hwid mxser_must_get_hwid(unsigned long io)\n{\n\tu8 oldmcr, hwid;\n\tint i;\n\n\toutb(0, io + UART_LCR);\n\tmxser_must_set_enhance_mode(io, false);\n\toldmcr = inb(io + UART_MCR);\n\toutb(0, io + UART_MCR);\n\tmxser_set_must_xon1_value(io, 0x11);\n\tif (inb(io + UART_MCR) != 0) {\n\t\toutb(oldmcr, io + UART_MCR);\n\t\treturn MOXA_OTHER_UART;\n\t}\n\n\thwid = mxser_get_must_hardware_id(io);\n\tfor (i = 1; i < UART_INFO_NUM; i++)  \n\t\tif (hwid == Gpci_uart_info[i].type)\n\t\t\treturn hwid;\n\n\treturn MOXA_OTHER_UART;\n}\n\nstatic bool mxser_16550A_or_MUST(struct mxser_port *info)\n{\n\treturn info->type == PORT_16550A || info->board->must_hwid;\n}\n\nstatic void mxser_process_txrx_fifo(struct mxser_port *info)\n{\n\tunsigned int i;\n\n\tif (info->type == PORT_16450 || info->type == PORT_8250) {\n\t\tinfo->rx_high_water = 1;\n\t\tinfo->rx_low_water = 1;\n\t\tinfo->xmit_fifo_size = 1;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < UART_INFO_NUM; i++)\n\t\tif (info->board->must_hwid == Gpci_uart_info[i].type) {\n\t\t\tinfo->rx_low_water = Gpci_uart_info[i].rx_low_water;\n\t\t\tinfo->rx_high_water = Gpci_uart_info[i].rx_high_water;\n\t\t\tinfo->xmit_fifo_size = Gpci_uart_info[i].fifo_size;\n\t\t\tbreak;\n\t\t}\n}\n\nstatic void __mxser_start_tx(struct mxser_port *info)\n{\n\toutb(info->IER & ~UART_IER_THRI, info->ioaddr + UART_IER);\n\tinfo->IER |= UART_IER_THRI;\n\toutb(info->IER, info->ioaddr + UART_IER);\n}\n\nstatic void mxser_start_tx(struct mxser_port *info)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\t__mxser_start_tx(info);\n\tspin_unlock_irqrestore(&info->slock, flags);\n}\n\nstatic void __mxser_stop_tx(struct mxser_port *info)\n{\n\tinfo->IER &= ~UART_IER_THRI;\n\toutb(info->IER, info->ioaddr + UART_IER);\n}\n\nstatic bool mxser_carrier_raised(struct tty_port *port)\n{\n\tstruct mxser_port *mp = container_of(port, struct mxser_port, port);\n\n\treturn inb(mp->ioaddr + UART_MSR) & UART_MSR_DCD;\n}\n\nstatic void mxser_dtr_rts(struct tty_port *port, bool active)\n{\n\tstruct mxser_port *mp = container_of(port, struct mxser_port, port);\n\tunsigned long flags;\n\tu8 mcr;\n\n\tspin_lock_irqsave(&mp->slock, flags);\n\tmcr = inb(mp->ioaddr + UART_MCR);\n\tif (active)\n\t\tmcr |= UART_MCR_DTR | UART_MCR_RTS;\n\telse\n\t\tmcr &= ~(UART_MCR_DTR | UART_MCR_RTS);\n\toutb(mcr, mp->ioaddr + UART_MCR);\n\tspin_unlock_irqrestore(&mp->slock, flags);\n}\n\nstatic int mxser_set_baud(struct tty_struct *tty, speed_t newspd)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned int quot = 0, baud;\n\tunsigned char cval;\n\tu64 timeout;\n\n\tif (newspd > info->board->max_baud)\n\t\treturn -1;\n\n\tif (newspd == 134) {\n\t\tquot = 2 * MXSER_BAUD_BASE / 269;\n\t\ttty_encode_baud_rate(tty, 134, 134);\n\t} else if (newspd) {\n\t\tquot = MXSER_BAUD_BASE / newspd;\n\t\tif (quot == 0)\n\t\t\tquot = 1;\n\t\tbaud = MXSER_BAUD_BASE / quot;\n\t\ttty_encode_baud_rate(tty, baud, baud);\n\t} else {\n\t\tquot = 0;\n\t}\n\n\t \n\ttimeout = (u64)info->xmit_fifo_size * HZ * 10 * quot;\n\tdo_div(timeout, MXSER_BAUD_BASE);\n\tinfo->timeout = timeout + HZ / 50;  \n\n\tif (quot) {\n\t\tinfo->MCR |= UART_MCR_DTR;\n\t\toutb(info->MCR, info->ioaddr + UART_MCR);\n\t} else {\n\t\tinfo->MCR &= ~UART_MCR_DTR;\n\t\toutb(info->MCR, info->ioaddr + UART_MCR);\n\t\treturn 0;\n\t}\n\n\tcval = inb(info->ioaddr + UART_LCR);\n\n\toutb(cval | UART_LCR_DLAB, info->ioaddr + UART_LCR);\t \n\n\toutb(quot & 0xff, info->ioaddr + UART_DLL);\t \n\toutb(quot >> 8, info->ioaddr + UART_DLM);\t \n\toutb(cval, info->ioaddr + UART_LCR);\t \n\n\tif (C_BAUD(tty) == BOTHER) {\n\t\tquot = MXSER_BAUD_BASE % newspd;\n\t\tquot *= 8;\n\t\tif (quot % newspd > newspd / 2) {\n\t\t\tquot /= newspd;\n\t\t\tquot++;\n\t\t} else\n\t\t\tquot /= newspd;\n\n\t\tmxser_set_must_enum_value(info->ioaddr, quot);\n\t} else {\n\t\tmxser_set_must_enum_value(info->ioaddr, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic void mxser_handle_cts(struct tty_struct *tty, struct mxser_port *info,\n\t\tu8 msr)\n{\n\tbool cts = msr & UART_MSR_CTS;\n\n\tif (tty->hw_stopped) {\n\t\tif (cts) {\n\t\t\ttty->hw_stopped = false;\n\n\t\t\tif (!mxser_16550A_or_MUST(info))\n\t\t\t\t__mxser_start_tx(info);\n\t\t\ttty_wakeup(tty);\n\t\t}\n\t\treturn;\n\t} else if (cts)\n\t\treturn;\n\n\ttty->hw_stopped = true;\n\tif (!mxser_16550A_or_MUST(info))\n\t\t__mxser_stop_tx(info);\n}\n\n \nstatic void mxser_change_speed(struct tty_struct *tty,\n\t\t\t       const struct ktermios *old_termios)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned cflag, cval;\n\n\tcflag = tty->termios.c_cflag;\n\n\tif (mxser_set_baud(tty, tty_get_baud_rate(tty))) {\n\t\t \n\t\tif (old_termios) {\n\t\t\tspeed_t baud = tty_termios_baud_rate(old_termios);\n\t\t\ttty_encode_baud_rate(tty, baud, baud);\n\t\t}\n\t}\n\n\t \n\tcval = UART_LCR_WLEN(tty_get_char_size(tty->termios.c_cflag));\n\n\tif (cflag & CSTOPB)\n\t\tcval |= UART_LCR_STOP;\n\tif (cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\tif (cflag & CMSPAR)\n\t\tcval |= UART_LCR_SPAR;\n\n\tinfo->FCR = 0;\n\tif (info->board->must_hwid) {\n\t\tinfo->FCR |= UART_FCR_ENABLE_FIFO |\n\t\t\tMOXA_MUST_FCR_GDA_MODE_ENABLE;\n\t\tmxser_set_must_fifo_value(info);\n\t} else if (info->type != PORT_8250 && info->type != PORT_16450) {\n\t\tinfo->FCR |= UART_FCR_ENABLE_FIFO;\n\t\tswitch (info->rx_high_water) {\n\t\tcase 1:\n\t\t\tinfo->FCR |= UART_FCR_TRIGGER_1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tinfo->FCR |= UART_FCR_TRIGGER_4;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tinfo->FCR |= UART_FCR_TRIGGER_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo->FCR |= UART_FCR_TRIGGER_14;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tinfo->IER &= ~UART_IER_MSI;\n\tinfo->MCR &= ~UART_MCR_AFE;\n\ttty_port_set_cts_flow(&info->port, cflag & CRTSCTS);\n\tif (cflag & CRTSCTS) {\n\t\tinfo->IER |= UART_IER_MSI;\n\t\tif (mxser_16550A_or_MUST(info)) {\n\t\t\tinfo->MCR |= UART_MCR_AFE;\n\t\t} else {\n\t\t\tmxser_handle_cts(tty, info,\n\t\t\t\t\tinb(info->ioaddr + UART_MSR));\n\t\t}\n\t}\n\toutb(info->MCR, info->ioaddr + UART_MCR);\n\ttty_port_set_check_carrier(&info->port, ~cflag & CLOCAL);\n\tif (~cflag & CLOCAL)\n\t\tinfo->IER |= UART_IER_MSI;\n\toutb(info->IER, info->ioaddr + UART_IER);\n\n\t \n\tinfo->read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\n\tif (I_INPCK(tty))\n\t\tinfo->read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (I_BRKINT(tty) || I_PARMRK(tty))\n\t\tinfo->read_status_mask |= UART_LSR_BI;\n\n\tinfo->ignore_status_mask = 0;\n\n\tif (I_IGNBRK(tty)) {\n\t\tinfo->ignore_status_mask |= UART_LSR_BI;\n\t\tinfo->read_status_mask |= UART_LSR_BI;\n\t\t \n\t\tif (I_IGNPAR(tty)) {\n\t\t\tinfo->ignore_status_mask |=\n\t\t\t\t\t\tUART_LSR_OE |\n\t\t\t\t\t\tUART_LSR_PE |\n\t\t\t\t\t\tUART_LSR_FE;\n\t\t\tinfo->read_status_mask |=\n\t\t\t\t\t\tUART_LSR_OE |\n\t\t\t\t\t\tUART_LSR_PE |\n\t\t\t\t\t\tUART_LSR_FE;\n\t\t}\n\t}\n\tif (info->board->must_hwid) {\n\t\tmxser_set_must_xon1_value(info->ioaddr, START_CHAR(tty));\n\t\tmxser_set_must_xoff1_value(info->ioaddr, STOP_CHAR(tty));\n\t\tmxser_must_set_rx_sw_flow_control(info->ioaddr, I_IXON(tty));\n\t\tmxser_must_set_tx_sw_flow_control(info->ioaddr, I_IXOFF(tty));\n\t}\n\n\n\toutb(info->FCR, info->ioaddr + UART_FCR);\n\toutb(cval, info->ioaddr + UART_LCR);\n}\n\nstatic u8 mxser_check_modem_status(struct tty_struct *tty,\n\t\t\t\tstruct mxser_port *port)\n{\n\tu8 msr = inb(port->ioaddr + UART_MSR);\n\n\tif (!(msr & UART_MSR_ANY_DELTA))\n\t\treturn msr;\n\n\t \n\tif (msr & UART_MSR_TERI)\n\t\tport->icount.rng++;\n\tif (msr & UART_MSR_DDSR)\n\t\tport->icount.dsr++;\n\tif (msr & UART_MSR_DDCD)\n\t\tport->icount.dcd++;\n\tif (msr & UART_MSR_DCTS)\n\t\tport->icount.cts++;\n\twake_up_interruptible(&port->port.delta_msr_wait);\n\n\tif (tty_port_check_carrier(&port->port) && (msr & UART_MSR_DDCD)) {\n\t\tif (msr & UART_MSR_DCD)\n\t\t\twake_up_interruptible(&port->port.open_wait);\n\t}\n\n\tif (tty_port_cts_enabled(&port->port))\n\t\tmxser_handle_cts(tty, port, msr);\n\n\treturn msr;\n}\n\nstatic void mxser_disable_and_clear_FIFO(struct mxser_port *info)\n{\n\tu8 fcr = UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT;\n\n\tif (info->board->must_hwid)\n\t\tfcr |= MOXA_MUST_FCR_GDA_MODE_ENABLE;\n\n\toutb(fcr, info->ioaddr + UART_FCR);\n}\n\nstatic int mxser_activate(struct tty_port *port, struct tty_struct *tty)\n{\n\tstruct mxser_port *info = container_of(port, struct mxser_port, port);\n\tunsigned long flags;\n\tint ret;\n\n\tret = tty_port_alloc_xmit_buf(port);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\n\tif (!info->type) {\n\t\tset_bit(TTY_IO_ERROR, &tty->flags);\n\t\tspin_unlock_irqrestore(&info->slock, flags);\n\t\tret = 0;\n\t\tgoto err_free_xmit;\n\t}\n\n\t \n\tmxser_disable_and_clear_FIFO(info);\n\n\t \n\tif (inb(info->ioaddr + UART_LSR) == 0xff) {\n\t\tspin_unlock_irqrestore(&info->slock, flags);\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tset_bit(TTY_IO_ERROR, &tty->flags);\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = -ENODEV;\n\t\tgoto err_free_xmit;\n\t}\n\n\t \n\t(void) inb(info->ioaddr + UART_LSR);\n\t(void) inb(info->ioaddr + UART_RX);\n\t(void) inb(info->ioaddr + UART_IIR);\n\t(void) inb(info->ioaddr + UART_MSR);\n\n\t \n\toutb(UART_LCR_WLEN8, info->ioaddr + UART_LCR);\t \n\tinfo->MCR = UART_MCR_DTR | UART_MCR_RTS;\n\toutb(info->MCR, info->ioaddr + UART_MCR);\n\n\t \n\tinfo->IER = UART_IER_MSI | UART_IER_RLSI | UART_IER_RDI;\n\n\tif (info->board->must_hwid)\n\t\tinfo->IER |= MOXA_MUST_IER_EGDAI;\n\toutb(info->IER, info->ioaddr + UART_IER);\t \n\n\t \n\t(void) inb(info->ioaddr + UART_LSR);\n\t(void) inb(info->ioaddr + UART_RX);\n\t(void) inb(info->ioaddr + UART_IIR);\n\t(void) inb(info->ioaddr + UART_MSR);\n\n\tclear_bit(TTY_IO_ERROR, &tty->flags);\n\tkfifo_reset(&port->xmit_fifo);\n\n\t \n\tmxser_change_speed(tty, NULL);\n\tspin_unlock_irqrestore(&info->slock, flags);\n\n\treturn 0;\nerr_free_xmit:\n\ttty_port_free_xmit_buf(port);\n\treturn ret;\n}\n\n \nstatic void mxser_stop_rx(struct mxser_port *info)\n{\n\tinfo->IER &= ~UART_IER_RLSI;\n\tif (info->board->must_hwid)\n\t\tinfo->IER &= ~MOXA_MUST_RECV_ISR;\n\n\toutb(info->IER, info->ioaddr + UART_IER);\n}\n\n \nstatic void mxser_shutdown_port(struct tty_port *port)\n{\n\tstruct mxser_port *info = container_of(port, struct mxser_port, port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\n\tmxser_stop_rx(info);\n\n\t \n\twake_up_interruptible(&info->port.delta_msr_wait);\n\n\tinfo->IER = 0;\n\toutb(0x00, info->ioaddr + UART_IER);\n\n\t \n\tmxser_disable_and_clear_FIFO(info);\n\n\t \n\t(void) inb(info->ioaddr + UART_RX);\n\n\n\tif (info->board->must_hwid)\n\t\tmxser_must_no_sw_flow_control(info->ioaddr);\n\n\tspin_unlock_irqrestore(&info->slock, flags);\n\n\t \n\tsynchronize_irq(info->board->irq);\n\n\ttty_port_free_xmit_buf(port);\n}\n\n \nstatic int mxser_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct tty_port *tport = tty->port;\n\tstruct mxser_port *port = container_of(tport, struct mxser_port, port);\n\n\ttty->driver_data = port;\n\n\treturn tty_port_open(tport, tty, filp);\n}\n\nstatic void mxser_flush_buffer(struct tty_struct *tty)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\tkfifo_reset(&info->port.xmit_fifo);\n\n\toutb(info->FCR | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT,\n\t\tinfo->ioaddr + UART_FCR);\n\n\tspin_unlock_irqrestore(&info->slock, flags);\n\n\ttty_wakeup(tty);\n}\n\nstatic void mxser_close(struct tty_struct *tty, struct file *filp)\n{\n\ttty_port_close(tty->port, tty, filp);\n}\n\nstatic ssize_t mxser_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned long flags;\n\tint written;\n\tbool is_empty;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\twritten = kfifo_in(&info->port.xmit_fifo, buf, count);\n\tis_empty = kfifo_is_empty(&info->port.xmit_fifo);\n\tspin_unlock_irqrestore(&info->slock, flags);\n\n\tif (!is_empty && !tty->flow.stopped)\n\t\tif (!tty->hw_stopped || mxser_16550A_or_MUST(info))\n\t\t\tmxser_start_tx(info);\n\n\treturn written;\n}\n\nstatic int mxser_put_char(struct tty_struct *tty, u8 ch)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\tret = kfifo_put(&info->port.xmit_fifo, ch);\n\tspin_unlock_irqrestore(&info->slock, flags);\n\n\treturn ret;\n}\n\n\nstatic void mxser_flush_chars(struct tty_struct *tty)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\n\tif (kfifo_is_empty(&info->port.xmit_fifo) || tty->flow.stopped ||\n\t\t\t(tty->hw_stopped && !mxser_16550A_or_MUST(info)))\n\t\treturn;\n\n\tmxser_start_tx(info);\n}\n\nstatic unsigned int mxser_write_room(struct tty_struct *tty)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\n\treturn kfifo_avail(&info->port.xmit_fifo);\n}\n\nstatic unsigned int mxser_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\n\treturn kfifo_len(&info->port.xmit_fifo);\n}\n\n \nstatic int mxser_get_serial_info(struct tty_struct *tty,\n\t\tstruct serial_struct *ss)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tstruct tty_port *port = &info->port;\n\tunsigned int closing_wait, close_delay;\n\n\tmutex_lock(&port->mutex);\n\n\tclose_delay = jiffies_to_msecs(info->port.close_delay) / 10;\n\tclosing_wait = info->port.closing_wait;\n\tif (closing_wait != ASYNC_CLOSING_WAIT_NONE)\n\t\tclosing_wait = jiffies_to_msecs(closing_wait) / 10;\n\n\tss->type = info->type;\n\tss->line = tty->index;\n\tss->port = info->ioaddr;\n\tss->irq = info->board->irq;\n\tss->flags = info->port.flags;\n\tss->baud_base = MXSER_BAUD_BASE;\n\tss->close_delay = close_delay;\n\tss->closing_wait = closing_wait;\n\tss->custom_divisor = MXSER_CUSTOM_DIVISOR,\n\tmutex_unlock(&port->mutex);\n\treturn 0;\n}\n\nstatic int mxser_set_serial_info(struct tty_struct *tty,\n\t\tstruct serial_struct *ss)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tstruct tty_port *port = &info->port;\n\tspeed_t baud;\n\tunsigned long sl_flags;\n\tunsigned int old_speed, close_delay, closing_wait;\n\tint retval = 0;\n\n\tif (tty_io_error(tty))\n\t\treturn -EIO;\n\n\tmutex_lock(&port->mutex);\n\n\tif (ss->irq != info->board->irq ||\n\t\t\tss->port != info->ioaddr) {\n\t\tmutex_unlock(&port->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\told_speed = port->flags & ASYNC_SPD_MASK;\n\n\tclose_delay = msecs_to_jiffies(ss->close_delay * 10);\n\tclosing_wait = ss->closing_wait;\n\tif (closing_wait != ASYNC_CLOSING_WAIT_NONE)\n\t\tclosing_wait = msecs_to_jiffies(closing_wait * 10);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tif ((ss->baud_base != MXSER_BAUD_BASE) ||\n\t\t\t\t(close_delay != port->close_delay) ||\n\t\t\t\t(closing_wait != port->closing_wait) ||\n\t\t\t\t((ss->flags & ~ASYNC_USR_MASK) != (port->flags & ~ASYNC_USR_MASK))) {\n\t\t\tmutex_unlock(&port->mutex);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tport->flags = (port->flags & ~ASYNC_USR_MASK) |\n\t\t\t\t(ss->flags & ASYNC_USR_MASK);\n\t} else {\n\t\t \n\t\tport->flags = ((port->flags & ~ASYNC_FLAGS) |\n\t\t\t\t(ss->flags & ASYNC_FLAGS));\n\t\tport->close_delay = close_delay;\n\t\tport->closing_wait = closing_wait;\n\t\tif ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST &&\n\t\t\t\t(ss->baud_base != MXSER_BAUD_BASE ||\n\t\t\t\tss->custom_divisor !=\n\t\t\t\tMXSER_CUSTOM_DIVISOR)) {\n\t\t\tif (ss->custom_divisor == 0) {\n\t\t\t\tmutex_unlock(&port->mutex);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbaud = ss->baud_base / ss->custom_divisor;\n\t\t\ttty_encode_baud_rate(tty, baud, baud);\n\t\t}\n\n\t\tinfo->type = ss->type;\n\n\t\tmxser_process_txrx_fifo(info);\n\t}\n\n\tif (tty_port_initialized(port)) {\n\t\tif (old_speed != (port->flags & ASYNC_SPD_MASK)) {\n\t\t\tspin_lock_irqsave(&info->slock, sl_flags);\n\t\t\tmxser_change_speed(tty, NULL);\n\t\t\tspin_unlock_irqrestore(&info->slock, sl_flags);\n\t\t}\n\t} else {\n\t\tretval = mxser_activate(port, tty);\n\t\tif (retval == 0)\n\t\t\ttty_port_set_initialized(port, true);\n\t}\n\tmutex_unlock(&port->mutex);\n\treturn retval;\n}\n\n \nstatic int mxser_get_lsr_info(struct mxser_port *info,\n\t\tunsigned int __user *value)\n{\n\tunsigned char status;\n\tunsigned int result;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\tstatus = inb(info->ioaddr + UART_LSR);\n\tspin_unlock_irqrestore(&info->slock, flags);\n\tresult = ((status & UART_LSR_TEMT) ? TIOCSER_TEMT : 0);\n\treturn put_user(result, value);\n}\n\nstatic int mxser_tiocmget(struct tty_struct *tty)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned char control;\n\tunsigned long flags;\n\tu8 msr;\n\n\tif (tty_io_error(tty))\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\tcontrol = info->MCR;\n\tmsr = mxser_check_modem_status(tty, info);\n\tspin_unlock_irqrestore(&info->slock, flags);\n\n\treturn ((control & UART_MCR_RTS) ? TIOCM_RTS : 0) |\n\t\t    ((control & UART_MCR_DTR) ? TIOCM_DTR : 0) |\n\t\t    ((msr & UART_MSR_DCD) ? TIOCM_CAR : 0) |\n\t\t    ((msr & UART_MSR_RI) ? TIOCM_RNG : 0) |\n\t\t    ((msr & UART_MSR_DSR) ? TIOCM_DSR : 0) |\n\t\t    ((msr & UART_MSR_CTS) ? TIOCM_CTS : 0);\n}\n\nstatic int mxser_tiocmset(struct tty_struct *tty,\n\t\tunsigned int set, unsigned int clear)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (tty_io_error(tty))\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\n\tif (set & TIOCM_RTS)\n\t\tinfo->MCR |= UART_MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tinfo->MCR |= UART_MCR_DTR;\n\n\tif (clear & TIOCM_RTS)\n\t\tinfo->MCR &= ~UART_MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tinfo->MCR &= ~UART_MCR_DTR;\n\n\toutb(info->MCR, info->ioaddr + UART_MCR);\n\tspin_unlock_irqrestore(&info->slock, flags);\n\treturn 0;\n}\n\nstatic int mxser_cflags_changed(struct mxser_port *info, unsigned long arg,\n\t\tstruct async_icount *cprev)\n{\n\tstruct async_icount cnow;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\tcnow = info->icount;\t \n\tspin_unlock_irqrestore(&info->slock, flags);\n\n\tret =\t((arg & TIOCM_RNG) && (cnow.rng != cprev->rng)) ||\n\t\t((arg & TIOCM_DSR) && (cnow.dsr != cprev->dsr)) ||\n\t\t((arg & TIOCM_CD)  && (cnow.dcd != cprev->dcd)) ||\n\t\t((arg & TIOCM_CTS) && (cnow.cts != cprev->cts));\n\n\t*cprev = cnow;\n\n\treturn ret;\n}\n\n \nstatic int mxser_ioctl_op_mode(struct mxser_port *port, int index, bool set,\n\t\tint __user *u_opmode)\n{\n\tint opmode, p = index % 4;\n\tint shiftbit = p * 2;\n\tu8 val;\n\n\tif (port->board->must_hwid != MOXA_MUST_MU860_HWID)\n\t\treturn -EFAULT;\n\n\tif (set) {\n\t\tif (get_user(opmode, u_opmode))\n\t\t\treturn -EFAULT;\n\n\t\tif (opmode & ~OP_MODE_MASK)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irq(&port->slock);\n\t\tval = inb(port->opmode_ioaddr);\n\t\tval &= ~(OP_MODE_MASK << shiftbit);\n\t\tval |= (opmode << shiftbit);\n\t\toutb(val, port->opmode_ioaddr);\n\t\tspin_unlock_irq(&port->slock);\n\n\t\treturn 0;\n\t}\n\n\tspin_lock_irq(&port->slock);\n\topmode = inb(port->opmode_ioaddr) >> shiftbit;\n\tspin_unlock_irq(&port->slock);\n\n\treturn put_user(opmode & OP_MODE_MASK, u_opmode);\n}\n\nstatic int mxser_ioctl(struct tty_struct *tty,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tstruct async_icount cnow;\n\tunsigned long flags;\n\tvoid __user *argp = (void __user *)arg;\n\n\tif (cmd == MOXA_SET_OP_MODE || cmd == MOXA_GET_OP_MODE)\n\t\treturn mxser_ioctl_op_mode(info, tty->index,\n\t\t\t\tcmd == MOXA_SET_OP_MODE, argp);\n\n\tif (cmd != TIOCMIWAIT && tty_io_error(tty))\n\t\treturn -EIO;\n\n\tswitch (cmd) {\n\tcase TIOCSERGETLSR:\t \n\t\treturn  mxser_get_lsr_info(info, argp);\n\t\t \n\tcase TIOCMIWAIT:\n\t\tspin_lock_irqsave(&info->slock, flags);\n\t\tcnow = info->icount;\t \n\t\tspin_unlock_irqrestore(&info->slock, flags);\n\n\t\treturn wait_event_interruptible(info->port.delta_msr_wait,\n\t\t\t\tmxser_cflags_changed(info, arg, &cnow));\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn 0;\n}\n\n\t \n\nstatic int mxser_get_icount(struct tty_struct *tty,\n\t\tstruct serial_icounter_struct *icount)\n\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tstruct async_icount cnow;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\tcnow = info->icount;\n\tspin_unlock_irqrestore(&info->slock, flags);\n\n\ticount->frame = cnow.frame;\n\ticount->brk = cnow.brk;\n\ticount->overrun = cnow.overrun;\n\ticount->buf_overrun = cnow.buf_overrun;\n\ticount->parity = cnow.parity;\n\ticount->rx = cnow.rx;\n\ticount->tx = cnow.tx;\n\ticount->cts = cnow.cts;\n\ticount->dsr = cnow.dsr;\n\ticount->rng = cnow.rng;\n\ticount->dcd = cnow.dcd;\n\treturn 0;\n}\n\n \nstatic void mxser_throttle(struct tty_struct *tty)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\n\tif (I_IXOFF(tty)) {\n\t\tif (info->board->must_hwid) {\n\t\t\tinfo->IER &= ~MOXA_MUST_RECV_ISR;\n\t\t\toutb(info->IER, info->ioaddr + UART_IER);\n\t\t} else {\n\t\t\tinfo->x_char = STOP_CHAR(tty);\n\t\t\toutb(0, info->ioaddr + UART_IER);\n\t\t\tinfo->IER |= UART_IER_THRI;\n\t\t\toutb(info->IER, info->ioaddr + UART_IER);\n\t\t}\n\t}\n\n\tif (C_CRTSCTS(tty)) {\n\t\tinfo->MCR &= ~UART_MCR_RTS;\n\t\toutb(info->MCR, info->ioaddr + UART_MCR);\n\t}\n}\n\nstatic void mxser_unthrottle(struct tty_struct *tty)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\n\t \n\tif (I_IXOFF(tty)) {\n\t\tif (info->x_char)\n\t\t\tinfo->x_char = 0;\n\t\telse {\n\t\t\tif (info->board->must_hwid) {\n\t\t\t\tinfo->IER |= MOXA_MUST_RECV_ISR;\n\t\t\t\toutb(info->IER, info->ioaddr + UART_IER);\n\t\t\t} else {\n\t\t\t\tinfo->x_char = START_CHAR(tty);\n\t\t\t\toutb(0, info->ioaddr + UART_IER);\n\t\t\t\tinfo->IER |= UART_IER_THRI;\n\t\t\t\toutb(info->IER, info->ioaddr + UART_IER);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (C_CRTSCTS(tty)) {\n\t\tinfo->MCR |= UART_MCR_RTS;\n\t\toutb(info->MCR, info->ioaddr + UART_MCR);\n\t}\n}\n\n \nstatic void mxser_stop(struct tty_struct *tty)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\tif (info->IER & UART_IER_THRI)\n\t\t__mxser_stop_tx(info);\n\tspin_unlock_irqrestore(&info->slock, flags);\n}\n\nstatic void mxser_start(struct tty_struct *tty)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\tif (!kfifo_is_empty(&info->port.xmit_fifo))\n\t\t__mxser_start_tx(info);\n\tspin_unlock_irqrestore(&info->slock, flags);\n}\n\nstatic void mxser_set_termios(struct tty_struct *tty,\n\t\t\t      const struct ktermios *old_termios)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\tmxser_change_speed(tty, old_termios);\n\tspin_unlock_irqrestore(&info->slock, flags);\n\n\tif ((old_termios->c_cflag & CRTSCTS) && !C_CRTSCTS(tty)) {\n\t\ttty->hw_stopped = false;\n\t\tmxser_start(tty);\n\t}\n\n\t \n\tif ((old_termios->c_iflag & IXON) && !I_IXON(tty)) {\n\t\ttty->flow.stopped = 0;\n\n\t\tif (info->board->must_hwid) {\n\t\t\tspin_lock_irqsave(&info->slock, flags);\n\t\t\tmxser_must_set_rx_sw_flow_control(info->ioaddr, false);\n\t\t\tspin_unlock_irqrestore(&info->slock, flags);\n\t\t}\n\n\t\tmxser_start(tty);\n\t}\n}\n\nstatic bool mxser_tx_empty(struct mxser_port *info)\n{\n\tunsigned long flags;\n\tu8 lsr;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\tlsr = inb(info->ioaddr + UART_LSR);\n\tspin_unlock_irqrestore(&info->slock, flags);\n\n\treturn !(lsr & UART_LSR_TEMT);\n}\n\n \nstatic void mxser_wait_until_sent(struct tty_struct *tty, int timeout)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned long expire, char_time;\n\n\tif (info->type == PORT_UNKNOWN)\n\t\treturn;\n\n\tif (info->xmit_fifo_size == 0)\n\t\treturn;\t\t \n\n\t \n\tchar_time = (info->timeout - HZ / 50) / info->xmit_fifo_size;\n\tchar_time = char_time / 5;\n\tif (char_time == 0)\n\t\tchar_time = 1;\n\tif (timeout && timeout < char_time)\n\t\tchar_time = timeout;\n\n\tchar_time = jiffies_to_msecs(char_time);\n\n\t \n\tif (!timeout || timeout > 2 * info->timeout)\n\t\ttimeout = 2 * info->timeout;\n\n\texpire = jiffies + timeout;\n\n\twhile (mxser_tx_empty(info)) {\n\t\tmsleep_interruptible(char_time);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tif (time_after(jiffies, expire))\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void mxser_hangup(struct tty_struct *tty)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\n\tmxser_flush_buffer(tty);\n\ttty_port_hangup(&info->port);\n}\n\n \nstatic int mxser_rs_break(struct tty_struct *tty, int break_state)\n{\n\tstruct mxser_port *info = tty->driver_data;\n\tunsigned long flags;\n\tu8 lcr;\n\n\tspin_lock_irqsave(&info->slock, flags);\n\tlcr = inb(info->ioaddr + UART_LCR);\n\tif (break_state == -1)\n\t\tlcr |= UART_LCR_SBC;\n\telse\n\t\tlcr &= ~UART_LCR_SBC;\n\toutb(lcr, info->ioaddr + UART_LCR);\n\tspin_unlock_irqrestore(&info->slock, flags);\n\n\treturn 0;\n}\n\nstatic bool mxser_receive_chars_new(struct mxser_port *port, u8 status)\n{\n\tenum mxser_must_hwid hwid = port->board->must_hwid;\n\tu8 gdl;\n\n\tif (hwid == MOXA_OTHER_UART)\n\t\treturn false;\n\tif (status & (UART_LSR_BRK_ERROR_BITS | MOXA_MUST_LSR_RERR))\n\t\treturn false;\n\n\tgdl = inb(port->ioaddr + MOXA_MUST_GDL_REGISTER);\n\tif (hwid == MOXA_MUST_MU150_HWID)\n\t\tgdl &= MOXA_MUST_GDL_MASK;\n\n\twhile (gdl--) {\n\t\tu8 ch = inb(port->ioaddr + UART_RX);\n\t\tif (!tty_insert_flip_char(&port->port, ch, 0))\n\t\t\tport->icount.buf_overrun++;\n\t}\n\n\treturn true;\n}\n\nstatic u8 mxser_receive_chars_old(struct tty_struct *tty,\n\t\t                struct mxser_port *port, u8 status)\n{\n\tenum mxser_must_hwid hwid = port->board->must_hwid;\n\tint ignored = 0;\n\tint max = 256;\n\tu8 ch;\n\n\tdo {\n\t\tif (max-- < 0)\n\t\t\tbreak;\n\n\t\tch = inb(port->ioaddr + UART_RX);\n\t\tif (hwid && (status & UART_LSR_OE))\n\t\t\toutb(port->FCR | UART_FCR_CLEAR_RCVR,\n\t\t\t\t\tport->ioaddr + UART_FCR);\n\t\tstatus &= port->read_status_mask;\n\t\tif (status & port->ignore_status_mask) {\n\t\t\tif (++ignored > 100)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tchar flag = 0;\n\t\t\tif (status & UART_LSR_BRK_ERROR_BITS) {\n\t\t\t\tif (status & UART_LSR_BI) {\n\t\t\t\t\tflag = TTY_BREAK;\n\t\t\t\t\tport->icount.brk++;\n\n\t\t\t\t\tif (port->port.flags & ASYNC_SAK)\n\t\t\t\t\t\tdo_SAK(tty);\n\t\t\t\t} else if (status & UART_LSR_PE) {\n\t\t\t\t\tflag = TTY_PARITY;\n\t\t\t\t\tport->icount.parity++;\n\t\t\t\t} else if (status & UART_LSR_FE) {\n\t\t\t\t\tflag = TTY_FRAME;\n\t\t\t\t\tport->icount.frame++;\n\t\t\t\t} else if (status & UART_LSR_OE) {\n\t\t\t\t\tflag = TTY_OVERRUN;\n\t\t\t\t\tport->icount.overrun++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!tty_insert_flip_char(&port->port, ch, flag)) {\n\t\t\t\tport->icount.buf_overrun++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (hwid)\n\t\t\tbreak;\n\n\t\tstatus = inb(port->ioaddr + UART_LSR);\n\t} while (status & UART_LSR_DR);\n\n\treturn status;\n}\n\nstatic u8 mxser_receive_chars(struct tty_struct *tty,\n\t\tstruct mxser_port *port, u8 status)\n{\n\tif (!mxser_receive_chars_new(port, status))\n\t\tstatus = mxser_receive_chars_old(tty, port, status);\n\n\ttty_flip_buffer_push(&port->port);\n\n\treturn status;\n}\n\nstatic void mxser_transmit_chars(struct tty_struct *tty, struct mxser_port *port)\n{\n\tint count;\n\n\tif (port->x_char) {\n\t\toutb(port->x_char, port->ioaddr + UART_TX);\n\t\tport->x_char = 0;\n\t\tport->icount.tx++;\n\t\treturn;\n\t}\n\n\tif (kfifo_is_empty(&port->port.xmit_fifo) || tty->flow.stopped ||\n\t\t\t(tty->hw_stopped && !mxser_16550A_or_MUST(port))) {\n\t\t__mxser_stop_tx(port);\n\t\treturn;\n\t}\n\n\tcount = port->xmit_fifo_size;\n\tdo {\n\t\tunsigned char c;\n\n\t\tif (!kfifo_get(&port->port.xmit_fifo, &c))\n\t\t\tbreak;\n\n\t\toutb(c, port->ioaddr + UART_TX);\n\t\tport->icount.tx++;\n\t} while (--count > 0);\n\n\tif (kfifo_len(&port->port.xmit_fifo) < WAKEUP_CHARS)\n\t\ttty_wakeup(tty);\n\n\tif (kfifo_is_empty(&port->port.xmit_fifo))\n\t\t__mxser_stop_tx(port);\n}\n\nstatic bool mxser_port_isr(struct mxser_port *port)\n{\n\tstruct tty_struct *tty;\n\tu8 iir, status;\n\tbool error = false;\n\n\tiir = inb(port->ioaddr + UART_IIR);\n\tif (iir & UART_IIR_NO_INT)\n\t\treturn true;\n\n\tiir &= MOXA_MUST_IIR_MASK;\n\ttty = tty_port_tty_get(&port->port);\n\tif (!tty) {\n\t\tstatus = inb(port->ioaddr + UART_LSR);\n\t\toutb(port->FCR | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT,\n\t\t\t\tport->ioaddr + UART_FCR);\n\t\tinb(port->ioaddr + UART_MSR);\n\n\t\terror = true;\n\t\tgoto put_tty;\n\t}\n\n\tstatus = inb(port->ioaddr + UART_LSR);\n\n\tif (port->board->must_hwid) {\n\t\tif (iir == MOXA_MUST_IIR_GDA ||\n\t\t    iir == MOXA_MUST_IIR_RDA ||\n\t\t    iir == MOXA_MUST_IIR_RTO ||\n\t\t    iir == MOXA_MUST_IIR_LSR)\n\t\t\tstatus = mxser_receive_chars(tty, port, status);\n\t} else {\n\t\tstatus &= port->read_status_mask;\n\t\tif (status & UART_LSR_DR)\n\t\t\tstatus = mxser_receive_chars(tty, port, status);\n\t}\n\n\tmxser_check_modem_status(tty, port);\n\n\tif (port->board->must_hwid) {\n\t\tif (iir == 0x02 && (status & UART_LSR_THRE))\n\t\t\tmxser_transmit_chars(tty, port);\n\t} else {\n\t\tif (status & UART_LSR_THRE)\n\t\t\tmxser_transmit_chars(tty, port);\n\t}\n\nput_tty:\n\ttty_kref_put(tty);\n\n\treturn error;\n}\n\n \nstatic irqreturn_t mxser_interrupt(int irq, void *dev_id)\n{\n\tstruct mxser_board *brd = dev_id;\n\tstruct mxser_port *port;\n\tunsigned int int_cnt, pass_counter = 0;\n\tunsigned int i, max = brd->nports;\n\tint handled = IRQ_NONE;\n\tu8 irqbits, bits, mask = BIT(max) - 1;\n\n\twhile (pass_counter++ < MXSER_ISR_PASS_LIMIT) {\n\t\tirqbits = inb(brd->vector) & mask;\n\t\tif (irqbits == mask)\n\t\t\tbreak;\n\n\t\thandled = IRQ_HANDLED;\n\t\tfor (i = 0, bits = 1; i < max; i++, irqbits |= bits, bits <<= 1) {\n\t\t\tif (irqbits == mask)\n\t\t\t\tbreak;\n\t\t\tif (bits & irqbits)\n\t\t\t\tcontinue;\n\t\t\tport = &brd->ports[i];\n\n\t\t\tint_cnt = 0;\n\t\t\tspin_lock(&port->slock);\n\t\t\tdo {\n\t\t\t\tif (mxser_port_isr(port))\n\t\t\t\t\tbreak;\n\t\t\t} while (int_cnt++ < MXSER_ISR_PASS_LIMIT);\n\t\t\tspin_unlock(&port->slock);\n\t\t}\n\t}\n\n\treturn handled;\n}\n\nstatic const struct tty_operations mxser_ops = {\n\t.open = mxser_open,\n\t.close = mxser_close,\n\t.write = mxser_write,\n\t.put_char = mxser_put_char,\n\t.flush_chars = mxser_flush_chars,\n\t.write_room = mxser_write_room,\n\t.chars_in_buffer = mxser_chars_in_buffer,\n\t.flush_buffer = mxser_flush_buffer,\n\t.ioctl = mxser_ioctl,\n\t.throttle = mxser_throttle,\n\t.unthrottle = mxser_unthrottle,\n\t.set_termios = mxser_set_termios,\n\t.stop = mxser_stop,\n\t.start = mxser_start,\n\t.hangup = mxser_hangup,\n\t.break_ctl = mxser_rs_break,\n\t.wait_until_sent = mxser_wait_until_sent,\n\t.tiocmget = mxser_tiocmget,\n\t.tiocmset = mxser_tiocmset,\n\t.set_serial = mxser_set_serial_info,\n\t.get_serial = mxser_get_serial_info,\n\t.get_icount = mxser_get_icount,\n};\n\nstatic const struct tty_port_operations mxser_port_ops = {\n\t.carrier_raised = mxser_carrier_raised,\n\t.dtr_rts = mxser_dtr_rts,\n\t.activate = mxser_activate,\n\t.shutdown = mxser_shutdown_port,\n};\n\n \n\nstatic void mxser_initbrd(struct mxser_board *brd, bool high_baud)\n{\n\tstruct mxser_port *info;\n\tunsigned int i;\n\tbool is_mu860;\n\n\tbrd->must_hwid = mxser_must_get_hwid(brd->ports[0].ioaddr);\n\tis_mu860 = brd->must_hwid == MOXA_MUST_MU860_HWID;\n\n\tfor (i = 0; i < UART_INFO_NUM; i++) {\n\t\tif (Gpci_uart_info[i].type == brd->must_hwid) {\n\t\t\tbrd->max_baud = Gpci_uart_info[i].max_baud;\n\n\t\t\t \n\t\t\tif (high_baud)\n\t\t\t\tbrd->max_baud = 921600;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (is_mu860) {\n\t\t \n\t\toutb(0, brd->vector + 4);\n\t\toutb(0, brd->vector + 0x0c);\n\t}\n\n\tfor (i = 0; i < brd->nports; i++) {\n\t\tinfo = &brd->ports[i];\n\t\tif (is_mu860) {\n\t\t\tif (i < 4)\n\t\t\t\tinfo->opmode_ioaddr = brd->vector + 4;\n\t\t\telse\n\t\t\t\tinfo->opmode_ioaddr = brd->vector + 0x0c;\n\t\t}\n\t\ttty_port_init(&info->port);\n\t\tinfo->port.ops = &mxser_port_ops;\n\t\tinfo->board = brd;\n\n\t\t \n\t\tif (brd->must_hwid != MOXA_OTHER_UART)\n\t\t\tmxser_must_set_enhance_mode(info->ioaddr, true);\n\n\t\tinfo->type = PORT_16550A;\n\n\t\tmxser_process_txrx_fifo(info);\n\n\t\tinfo->port.close_delay = 5 * HZ / 10;\n\t\tinfo->port.closing_wait = 30 * HZ;\n\t\tspin_lock_init(&info->slock);\n\n\t\t \n\t\toutb(inb(info->ioaddr + UART_IER) & 0xf0,\n\t\t\tinfo->ioaddr + UART_IER);\n\t}\n}\n\nstatic int mxser_probe(struct pci_dev *pdev,\n\t\tconst struct pci_device_id *ent)\n{\n\tstruct mxser_board *brd;\n\tunsigned int i, base;\n\tunsigned long ioaddress;\n\tunsigned short nports = MXSER_NPORTS(ent->driver_data);\n\tstruct device *tty_dev;\n\tint retval = -EINVAL;\n\n\ti = find_first_zero_bit(mxser_boards, MXSER_BOARDS);\n\tif (i >= MXSER_BOARDS) {\n\t\tdev_err(&pdev->dev, \"too many boards found (maximum %d), board \"\n\t\t\t\t\"not configured\\n\", MXSER_BOARDS);\n\t\tgoto err;\n\t}\n\n\tbrd = devm_kzalloc(&pdev->dev, struct_size(brd, ports, nports),\n\t\t\tGFP_KERNEL);\n\tif (!brd)\n\t\tgoto err;\n\n\tbrd->idx = i;\n\t__set_bit(brd->idx, mxser_boards);\n\tbase = i * MXSER_PORTS_PER_BOARD;\n\n\tretval = pcim_enable_device(pdev);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"PCI enable failed\\n\");\n\t\tgoto err_zero;\n\t}\n\n\t \n\tioaddress = pci_resource_start(pdev, 2);\n\tretval = pci_request_region(pdev, 2, \"mxser(IO)\");\n\tif (retval)\n\t\tgoto err_zero;\n\n\tbrd->nports = nports;\n\tfor (i = 0; i < nports; i++)\n\t\tbrd->ports[i].ioaddr = ioaddress + 8 * i;\n\n\t \n\tioaddress = pci_resource_start(pdev, 3);\n\tretval = pci_request_region(pdev, 3, \"mxser(vector)\");\n\tif (retval)\n\t\tgoto err_zero;\n\tbrd->vector = ioaddress;\n\n\t \n\tbrd->irq = pdev->irq;\n\n\tmxser_initbrd(brd, ent->driver_data & MXSER_HIGHBAUD);\n\n\tretval = devm_request_irq(&pdev->dev, brd->irq, mxser_interrupt,\n\t\t\tIRQF_SHARED, \"mxser\", brd);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"request irq failed\");\n\t\tgoto err_relbrd;\n\t}\n\n\tfor (i = 0; i < nports; i++) {\n\t\ttty_dev = tty_port_register_device(&brd->ports[i].port,\n\t\t\t\tmxvar_sdriver, base + i, &pdev->dev);\n\t\tif (IS_ERR(tty_dev)) {\n\t\t\tretval = PTR_ERR(tty_dev);\n\t\t\tfor (; i > 0; i--)\n\t\t\t\ttty_unregister_device(mxvar_sdriver,\n\t\t\t\t\tbase + i - 1);\n\t\t\tgoto err_relbrd;\n\t\t}\n\t}\n\n\tpci_set_drvdata(pdev, brd);\n\n\treturn 0;\nerr_relbrd:\n\tfor (i = 0; i < nports; i++)\n\t\ttty_port_destroy(&brd->ports[i].port);\nerr_zero:\n\t__clear_bit(brd->idx, mxser_boards);\nerr:\n\treturn retval;\n}\n\nstatic void mxser_remove(struct pci_dev *pdev)\n{\n\tstruct mxser_board *brd = pci_get_drvdata(pdev);\n\tunsigned int i, base = brd->idx * MXSER_PORTS_PER_BOARD;\n\n\tfor (i = 0; i < brd->nports; i++) {\n\t\ttty_unregister_device(mxvar_sdriver, base + i);\n\t\ttty_port_destroy(&brd->ports[i].port);\n\t}\n\n\t__clear_bit(brd->idx, mxser_boards);\n}\n\nstatic struct pci_driver mxser_driver = {\n\t.name = \"mxser\",\n\t.id_table = mxser_pcibrds,\n\t.probe = mxser_probe,\n\t.remove = mxser_remove\n};\n\nstatic int __init mxser_module_init(void)\n{\n\tint retval;\n\n\tmxvar_sdriver = tty_alloc_driver(MXSER_PORTS, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(mxvar_sdriver))\n\t\treturn PTR_ERR(mxvar_sdriver);\n\n\t \n\tmxvar_sdriver->name = \"ttyMI\";\n\tmxvar_sdriver->major = ttymajor;\n\tmxvar_sdriver->minor_start = 0;\n\tmxvar_sdriver->type = TTY_DRIVER_TYPE_SERIAL;\n\tmxvar_sdriver->subtype = SERIAL_TYPE_NORMAL;\n\tmxvar_sdriver->init_termios = tty_std_termios;\n\tmxvar_sdriver->init_termios.c_cflag = B9600|CS8|CREAD|HUPCL|CLOCAL;\n\ttty_set_operations(mxvar_sdriver, &mxser_ops);\n\n\tretval = tty_register_driver(mxvar_sdriver);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"Couldn't install MOXA Smartio/Industio family \"\n\t\t\t\t\"tty driver !\\n\");\n\t\tgoto err_put;\n\t}\n\n\tretval = pci_register_driver(&mxser_driver);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"mxser: can't register pci driver\\n\");\n\t\tgoto err_unr;\n\t}\n\n\treturn 0;\nerr_unr:\n\ttty_unregister_driver(mxvar_sdriver);\nerr_put:\n\ttty_driver_kref_put(mxvar_sdriver);\n\treturn retval;\n}\n\nstatic void __exit mxser_module_exit(void)\n{\n\tpci_unregister_driver(&mxser_driver);\n\ttty_unregister_driver(mxvar_sdriver);\n\ttty_driver_kref_put(mxvar_sdriver);\n}\n\nmodule_init(mxser_module_init);\nmodule_exit(mxser_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}