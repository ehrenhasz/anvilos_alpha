{
  "module_name": "tty_jobctrl.c",
  "hash_id": "c13fedb5a6ebae9dba22309af9a88cd67d0fc04790d0c317ccbcd9a96773d14f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/tty_jobctrl.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/tty.h>\n#include <linux/fcntl.h>\n#include <linux/uaccess.h>\n#include \"tty.h\"\n\nstatic int is_ignored(int sig)\n{\n\treturn (sigismember(&current->blocked, sig) ||\n\t\tcurrent->sighand->action[sig-1].sa.sa_handler == SIG_IGN);\n}\n\n \nint __tty_check_change(struct tty_struct *tty, int sig)\n{\n\tunsigned long flags;\n\tstruct pid *pgrp, *tty_pgrp;\n\tint ret = 0;\n\n\tif (current->signal->tty != tty)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpgrp = task_pgrp(current);\n\n\tspin_lock_irqsave(&tty->ctrl.lock, flags);\n\ttty_pgrp = tty->ctrl.pgrp;\n\tspin_unlock_irqrestore(&tty->ctrl.lock, flags);\n\n\tif (tty_pgrp && pgrp != tty_pgrp) {\n\t\tif (is_ignored(sig)) {\n\t\t\tif (sig == SIGTTIN)\n\t\t\t\tret = -EIO;\n\t\t} else if (is_current_pgrp_orphaned())\n\t\t\tret = -EIO;\n\t\telse {\n\t\t\tkill_pgrp(pgrp, sig, 1);\n\t\t\tset_thread_flag(TIF_SIGPENDING);\n\t\t\tret = -ERESTARTSYS;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!tty_pgrp)\n\t\ttty_warn(tty, \"sig=%d, tty->pgrp == NULL!\\n\", sig);\n\n\treturn ret;\n}\n\nint tty_check_change(struct tty_struct *tty)\n{\n\treturn __tty_check_change(tty, SIGTTOU);\n}\nEXPORT_SYMBOL(tty_check_change);\n\nvoid proc_clear_tty(struct task_struct *p)\n{\n\tunsigned long flags;\n\tstruct tty_struct *tty;\n\n\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\ttty = p->signal->tty;\n\tp->signal->tty = NULL;\n\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\ttty_kref_put(tty);\n}\n\n \nstatic void __proc_set_tty(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tty->ctrl.lock, flags);\n\t \n\tput_pid(tty->ctrl.session);\n\tput_pid(tty->ctrl.pgrp);\n\ttty->ctrl.pgrp = get_pid(task_pgrp(current));\n\ttty->ctrl.session = get_pid(task_session(current));\n\tspin_unlock_irqrestore(&tty->ctrl.lock, flags);\n\tif (current->signal->tty) {\n\t\ttty_debug(tty, \"current tty %s not NULL!!\\n\",\n\t\t\t  current->signal->tty->name);\n\t\ttty_kref_put(current->signal->tty);\n\t}\n\tput_pid(current->signal->tty_old_pgrp);\n\tcurrent->signal->tty = tty_kref_get(tty);\n\tcurrent->signal->tty_old_pgrp = NULL;\n}\n\nstatic void proc_set_tty(struct tty_struct *tty)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\t__proc_set_tty(tty);\n\tspin_unlock_irq(&current->sighand->siglock);\n}\n\n \nvoid tty_open_proc_set_tty(struct file *filp, struct tty_struct *tty)\n{\n\tread_lock(&tasklist_lock);\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (current->signal->leader &&\n\t    !current->signal->tty &&\n\t    tty->ctrl.session == NULL) {\n\t\t \n\t\tif (filp->f_mode & FMODE_READ)\n\t\t\t__proc_set_tty(tty);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_unlock(&tasklist_lock);\n}\n\nstruct tty_struct *get_current_tty(void)\n{\n\tstruct tty_struct *tty;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\ttty = tty_kref_get(current->signal->tty);\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\treturn tty;\n}\nEXPORT_SYMBOL_GPL(get_current_tty);\n\n \nvoid session_clear_tty(struct pid *session)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\tproc_clear_tty(p);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n}\n\n \nint tty_signal_session_leader(struct tty_struct *tty, int exit_session)\n{\n\tstruct task_struct *p;\n\tint refs = 0;\n\tstruct pid *tty_pgrp = NULL;\n\n\tread_lock(&tasklist_lock);\n\tif (tty->ctrl.session) {\n\t\tdo_each_pid_task(tty->ctrl.session, PIDTYPE_SID, p) {\n\t\t\tspin_lock_irq(&p->sighand->siglock);\n\t\t\tif (p->signal->tty == tty) {\n\t\t\t\tp->signal->tty = NULL;\n\t\t\t\t \n\t\t\t\trefs++;\n\t\t\t}\n\t\t\tif (!p->signal->leader) {\n\t\t\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsend_signal_locked(SIGHUP, SEND_SIG_PRIV, p, PIDTYPE_TGID);\n\t\t\tsend_signal_locked(SIGCONT, SEND_SIG_PRIV, p, PIDTYPE_TGID);\n\t\t\tput_pid(p->signal->tty_old_pgrp);   \n\t\t\tspin_lock(&tty->ctrl.lock);\n\t\t\ttty_pgrp = get_pid(tty->ctrl.pgrp);\n\t\t\tif (tty->ctrl.pgrp)\n\t\t\t\tp->signal->tty_old_pgrp =\n\t\t\t\t\tget_pid(tty->ctrl.pgrp);\n\t\t\tspin_unlock(&tty->ctrl.lock);\n\t\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\t} while_each_pid_task(tty->ctrl.session, PIDTYPE_SID, p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tif (tty_pgrp) {\n\t\tif (exit_session)\n\t\t\tkill_pgrp(tty_pgrp, SIGHUP, exit_session);\n\t\tput_pid(tty_pgrp);\n\t}\n\n\treturn refs;\n}\n\n \nvoid disassociate_ctty(int on_exit)\n{\n\tstruct tty_struct *tty;\n\n\tif (!current->signal->leader)\n\t\treturn;\n\n\ttty = get_current_tty();\n\tif (tty) {\n\t\tif (on_exit && tty->driver->type != TTY_DRIVER_TYPE_PTY) {\n\t\t\ttty_vhangup_session(tty);\n\t\t} else {\n\t\t\tstruct pid *tty_pgrp = tty_get_pgrp(tty);\n\n\t\t\tif (tty_pgrp) {\n\t\t\t\tkill_pgrp(tty_pgrp, SIGHUP, on_exit);\n\t\t\t\tif (!on_exit)\n\t\t\t\t\tkill_pgrp(tty_pgrp, SIGCONT, on_exit);\n\t\t\t\tput_pid(tty_pgrp);\n\t\t\t}\n\t\t}\n\t\ttty_kref_put(tty);\n\n\t} else if (on_exit) {\n\t\tstruct pid *old_pgrp;\n\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\told_pgrp = current->signal->tty_old_pgrp;\n\t\tcurrent->signal->tty_old_pgrp = NULL;\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tif (old_pgrp) {\n\t\t\tkill_pgrp(old_pgrp, SIGHUP, on_exit);\n\t\t\tkill_pgrp(old_pgrp, SIGCONT, on_exit);\n\t\t\tput_pid(old_pgrp);\n\t\t}\n\t\treturn;\n\t}\n\n\ttty = get_current_tty();\n\tif (tty) {\n\t\tunsigned long flags;\n\n\t\ttty_lock(tty);\n\t\tspin_lock_irqsave(&tty->ctrl.lock, flags);\n\t\tput_pid(tty->ctrl.session);\n\t\tput_pid(tty->ctrl.pgrp);\n\t\ttty->ctrl.session = NULL;\n\t\ttty->ctrl.pgrp = NULL;\n\t\tspin_unlock_irqrestore(&tty->ctrl.lock, flags);\n\t\ttty_unlock(tty);\n\t\ttty_kref_put(tty);\n\t}\n\n\t \n\tspin_lock_irq(&current->sighand->siglock);\n\tput_pid(current->signal->tty_old_pgrp);\n\tcurrent->signal->tty_old_pgrp = NULL;\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t \n\tread_lock(&tasklist_lock);\n\tsession_clear_tty(task_session(current));\n\tread_unlock(&tasklist_lock);\n}\n\n \nvoid no_tty(void)\n{\n\t \n\tstruct task_struct *tsk = current;\n\n\tdisassociate_ctty(0);\n\tproc_clear_tty(tsk);\n}\n\n \nstatic int tiocsctty(struct tty_struct *tty, struct file *file, int arg)\n{\n\tint ret = 0;\n\n\ttty_lock(tty);\n\tread_lock(&tasklist_lock);\n\n\tif (current->signal->leader &&\n\t\t\ttask_session(current) == tty->ctrl.session)\n\t\tgoto unlock;\n\n\t \n\tif (!current->signal->leader || current->signal->tty) {\n\t\tret = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tif (tty->ctrl.session) {\n\t\t \n\t\tif (arg == 1 && capable(CAP_SYS_ADMIN)) {\n\t\t\t \n\t\t\tsession_clear_tty(tty->ctrl.session);\n\t\t} else {\n\t\t\tret = -EPERM;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t \n\tif ((file->f_mode & FMODE_READ) == 0 && !capable(CAP_SYS_ADMIN)) {\n\t\tret = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tproc_set_tty(tty);\nunlock:\n\tread_unlock(&tasklist_lock);\n\ttty_unlock(tty);\n\treturn ret;\n}\n\n \nstruct pid *tty_get_pgrp(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\tstruct pid *pgrp;\n\n\tspin_lock_irqsave(&tty->ctrl.lock, flags);\n\tpgrp = get_pid(tty->ctrl.pgrp);\n\tspin_unlock_irqrestore(&tty->ctrl.lock, flags);\n\n\treturn pgrp;\n}\nEXPORT_SYMBOL_GPL(tty_get_pgrp);\n\n \nstatic struct pid *session_of_pgrp(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\tstruct pid *sid = NULL;\n\n\tp = pid_task(pgrp, PIDTYPE_PGID);\n\tif (p == NULL)\n\t\tp = pid_task(pgrp, PIDTYPE_PID);\n\tif (p != NULL)\n\t\tsid = task_session(p);\n\n\treturn sid;\n}\n\n \nstatic int tiocgpgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\n{\n\tstruct pid *pid;\n\tint ret;\n\t \n\tif (tty == real_tty && current->signal->tty != real_tty)\n\t\treturn -ENOTTY;\n\tpid = tty_get_pgrp(real_tty);\n\tret =  put_user(pid_vnr(pid), p);\n\tput_pid(pid);\n\treturn ret;\n}\n\n \nstatic int tiocspgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\n{\n\tstruct pid *pgrp;\n\tpid_t pgrp_nr;\n\tint retval = tty_check_change(real_tty);\n\n\tif (retval == -EIO)\n\t\treturn -ENOTTY;\n\tif (retval)\n\t\treturn retval;\n\n\tif (get_user(pgrp_nr, p))\n\t\treturn -EFAULT;\n\tif (pgrp_nr < 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&real_tty->ctrl.lock);\n\tif (!current->signal->tty ||\n\t    (current->signal->tty != real_tty) ||\n\t    (real_tty->ctrl.session != task_session(current))) {\n\t\tretval = -ENOTTY;\n\t\tgoto out_unlock_ctrl;\n\t}\n\trcu_read_lock();\n\tpgrp = find_vpid(pgrp_nr);\n\tretval = -ESRCH;\n\tif (!pgrp)\n\t\tgoto out_unlock;\n\tretval = -EPERM;\n\tif (session_of_pgrp(pgrp) != task_session(current))\n\t\tgoto out_unlock;\n\tretval = 0;\n\tput_pid(real_tty->ctrl.pgrp);\n\treal_tty->ctrl.pgrp = get_pid(pgrp);\nout_unlock:\n\trcu_read_unlock();\nout_unlock_ctrl:\n\tspin_unlock_irq(&real_tty->ctrl.lock);\n\treturn retval;\n}\n\n \nstatic int tiocgsid(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\n{\n\tunsigned long flags;\n\tpid_t sid;\n\n\t \n\tif (tty == real_tty && current->signal->tty != real_tty)\n\t\treturn -ENOTTY;\n\n\tspin_lock_irqsave(&real_tty->ctrl.lock, flags);\n\tif (!real_tty->ctrl.session)\n\t\tgoto err;\n\tsid = pid_vnr(real_tty->ctrl.session);\n\tspin_unlock_irqrestore(&real_tty->ctrl.lock, flags);\n\n\treturn put_user(sid, p);\n\nerr:\n\tspin_unlock_irqrestore(&real_tty->ctrl.lock, flags);\n\treturn -ENOTTY;\n}\n\n \nlong tty_jobctrl_ioctl(struct tty_struct *tty, struct tty_struct *real_tty,\n\t\t       struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *p = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TIOCNOTTY:\n\t\tif (current->signal->tty != tty)\n\t\t\treturn -ENOTTY;\n\t\tno_tty();\n\t\treturn 0;\n\tcase TIOCSCTTY:\n\t\treturn tiocsctty(real_tty, file, arg);\n\tcase TIOCGPGRP:\n\t\treturn tiocgpgrp(tty, real_tty, p);\n\tcase TIOCSPGRP:\n\t\treturn tiocspgrp(tty, real_tty, p);\n\tcase TIOCGSID:\n\t\treturn tiocgsid(tty, real_tty, p);\n\t}\n\treturn -ENOIOCTLCMD;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}