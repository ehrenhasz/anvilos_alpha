{
  "module_name": "tty_ldisc.c",
  "hash_id": "8e54ab3e1129ab56789eb99102087645cbcd41146892c9ddc4b338a58cd58aa5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/tty_ldisc.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/wait.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/ratelimit.h>\n#include \"tty.h\"\n\n#undef LDISC_DEBUG_HANGUP\n\n#ifdef LDISC_DEBUG_HANGUP\n#define tty_ldisc_debug(tty, f, args...)\ttty_debug(tty, f, ##args)\n#else\n#define tty_ldisc_debug(tty, f, args...)\n#endif\n\n \nenum {\n\tLDISC_SEM_NORMAL,\n\tLDISC_SEM_OTHER,\n};\n\n\n \n\nstatic DEFINE_RAW_SPINLOCK(tty_ldiscs_lock);\n \nstatic struct tty_ldisc_ops *tty_ldiscs[NR_LDISCS];\n\n \nint tty_register_ldisc(struct tty_ldisc_ops *new_ldisc)\n{\n\tunsigned long flags;\n\n\tif (new_ldisc->num < N_TTY || new_ldisc->num >= NR_LDISCS)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\ttty_ldiscs[new_ldisc->num] = new_ldisc;\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tty_register_ldisc);\n\n \n\nvoid tty_unregister_ldisc(struct tty_ldisc_ops *ldisc)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\ttty_ldiscs[ldisc->num] = NULL;\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n}\nEXPORT_SYMBOL(tty_unregister_ldisc);\n\nstatic struct tty_ldisc_ops *get_ldops(int disc)\n{\n\tunsigned long flags;\n\tstruct tty_ldisc_ops *ldops, *ret;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\tret = ERR_PTR(-EINVAL);\n\tldops = tty_ldiscs[disc];\n\tif (ldops) {\n\t\tret = ERR_PTR(-EAGAIN);\n\t\tif (try_module_get(ldops->owner))\n\t\t\tret = ldops;\n\t}\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\treturn ret;\n}\n\nstatic void put_ldops(struct tty_ldisc_ops *ldops)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\tmodule_put(ldops->owner);\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n}\n\nint tty_ldisc_autoload = IS_BUILTIN(CONFIG_LDISC_AUTOLOAD);\n\n \nstatic struct tty_ldisc *tty_ldisc_get(struct tty_struct *tty, int disc)\n{\n\tstruct tty_ldisc *ld;\n\tstruct tty_ldisc_ops *ldops;\n\n\tif (disc < N_TTY || disc >= NR_LDISCS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tldops = get_ldops(disc);\n\tif (IS_ERR(ldops)) {\n\t\tif (!capable(CAP_SYS_MODULE) && !tty_ldisc_autoload)\n\t\t\treturn ERR_PTR(-EPERM);\n\t\trequest_module(\"tty-ldisc-%d\", disc);\n\t\tldops = get_ldops(disc);\n\t\tif (IS_ERR(ldops))\n\t\t\treturn ERR_CAST(ldops);\n\t}\n\n\t \n\tld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL | __GFP_NOFAIL);\n\tld->ops = ldops;\n\tld->tty = tty;\n\n\treturn ld;\n}\n\n \nstatic void tty_ldisc_put(struct tty_ldisc *ld)\n{\n\tif (WARN_ON_ONCE(!ld))\n\t\treturn;\n\n\tput_ldops(ld->ops);\n\tkfree(ld);\n}\n\nstatic void *tty_ldiscs_seq_start(struct seq_file *m, loff_t *pos)\n{\n\treturn (*pos < NR_LDISCS) ? pos : NULL;\n}\n\nstatic void *tty_ldiscs_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn (*pos < NR_LDISCS) ? pos : NULL;\n}\n\nstatic void tty_ldiscs_seq_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic int tty_ldiscs_seq_show(struct seq_file *m, void *v)\n{\n\tint i = *(loff_t *)v;\n\tstruct tty_ldisc_ops *ldops;\n\n\tldops = get_ldops(i);\n\tif (IS_ERR(ldops))\n\t\treturn 0;\n\tseq_printf(m, \"%-10s %2d\\n\", ldops->name ? ldops->name : \"???\", i);\n\tput_ldops(ldops);\n\treturn 0;\n}\n\nconst struct seq_operations tty_ldiscs_seq_ops = {\n\t.start\t= tty_ldiscs_seq_start,\n\t.next\t= tty_ldiscs_seq_next,\n\t.stop\t= tty_ldiscs_seq_stop,\n\t.show\t= tty_ldiscs_seq_show,\n};\n\n \nstruct tty_ldisc *tty_ldisc_ref_wait(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld;\n\n\tldsem_down_read(&tty->ldisc_sem, MAX_SCHEDULE_TIMEOUT);\n\tld = tty->ldisc;\n\tif (!ld)\n\t\tldsem_up_read(&tty->ldisc_sem);\n\treturn ld;\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_ref_wait);\n\n \nstruct tty_ldisc *tty_ldisc_ref(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld = NULL;\n\n\tif (ldsem_down_read_trylock(&tty->ldisc_sem)) {\n\t\tld = tty->ldisc;\n\t\tif (!ld)\n\t\t\tldsem_up_read(&tty->ldisc_sem);\n\t}\n\treturn ld;\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_ref);\n\n \nvoid tty_ldisc_deref(struct tty_ldisc *ld)\n{\n\tldsem_up_read(&ld->tty->ldisc_sem);\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_deref);\n\n\nstatic inline int\n__tty_ldisc_lock(struct tty_struct *tty, unsigned long timeout)\n{\n\treturn ldsem_down_write(&tty->ldisc_sem, timeout);\n}\n\nstatic inline int\n__tty_ldisc_lock_nested(struct tty_struct *tty, unsigned long timeout)\n{\n\treturn ldsem_down_write_nested(&tty->ldisc_sem,\n\t\t\t\t       LDISC_SEM_OTHER, timeout);\n}\n\nstatic inline void __tty_ldisc_unlock(struct tty_struct *tty)\n{\n\tldsem_up_write(&tty->ldisc_sem);\n}\n\nint tty_ldisc_lock(struct tty_struct *tty, unsigned long timeout)\n{\n\tint ret;\n\n\t \n\tset_bit(TTY_LDISC_CHANGING, &tty->flags);\n\twake_up_interruptible_all(&tty->read_wait);\n\twake_up_interruptible_all(&tty->write_wait);\n\n\tret = __tty_ldisc_lock(tty, timeout);\n\tif (!ret)\n\t\treturn -EBUSY;\n\tset_bit(TTY_LDISC_HALTED, &tty->flags);\n\treturn 0;\n}\n\nvoid tty_ldisc_unlock(struct tty_struct *tty)\n{\n\tclear_bit(TTY_LDISC_HALTED, &tty->flags);\n\t \n\tclear_bit(TTY_LDISC_CHANGING, &tty->flags);\n\t__tty_ldisc_unlock(tty);\n}\n\nstatic int\ntty_ldisc_lock_pair_timeout(struct tty_struct *tty, struct tty_struct *tty2,\n\t\t\t    unsigned long timeout)\n{\n\tint ret;\n\n\tif (tty < tty2) {\n\t\tret = __tty_ldisc_lock(tty, timeout);\n\t\tif (ret) {\n\t\t\tret = __tty_ldisc_lock_nested(tty2, timeout);\n\t\t\tif (!ret)\n\t\t\t\t__tty_ldisc_unlock(tty);\n\t\t}\n\t} else {\n\t\t \n\t\tWARN_ON_ONCE(tty == tty2);\n\t\tif (tty2 && tty != tty2) {\n\t\t\tret = __tty_ldisc_lock(tty2, timeout);\n\t\t\tif (ret) {\n\t\t\t\tret = __tty_ldisc_lock_nested(tty, timeout);\n\t\t\t\tif (!ret)\n\t\t\t\t\t__tty_ldisc_unlock(tty2);\n\t\t\t}\n\t\t} else\n\t\t\tret = __tty_ldisc_lock(tty, timeout);\n\t}\n\n\tif (!ret)\n\t\treturn -EBUSY;\n\n\tset_bit(TTY_LDISC_HALTED, &tty->flags);\n\tif (tty2)\n\t\tset_bit(TTY_LDISC_HALTED, &tty2->flags);\n\treturn 0;\n}\n\nstatic void tty_ldisc_lock_pair(struct tty_struct *tty, struct tty_struct *tty2)\n{\n\ttty_ldisc_lock_pair_timeout(tty, tty2, MAX_SCHEDULE_TIMEOUT);\n}\n\nstatic void tty_ldisc_unlock_pair(struct tty_struct *tty,\n\t\t\t\t  struct tty_struct *tty2)\n{\n\t__tty_ldisc_unlock(tty);\n\tif (tty2)\n\t\t__tty_ldisc_unlock(tty2);\n}\n\n \nvoid tty_ldisc_flush(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld = tty_ldisc_ref(tty);\n\n\ttty_buffer_flush(tty, ld);\n\tif (ld)\n\t\ttty_ldisc_deref(ld);\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_flush);\n\n \nstatic void tty_set_termios_ldisc(struct tty_struct *tty, int disc)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_line = disc;\n\tup_write(&tty->termios_rwsem);\n\n\ttty->disc_data = NULL;\n\ttty->receive_room = 0;\n}\n\n \nstatic int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)\n{\n\tWARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &tty->flags));\n\tif (ld->ops->open) {\n\t\tint ret;\n\t\t \n\t\tret = ld->ops->open(tty);\n\t\tif (ret)\n\t\t\tclear_bit(TTY_LDISC_OPEN, &tty->flags);\n\n\t\ttty_ldisc_debug(tty, \"%p: opened\\n\", ld);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic void tty_ldisc_close(struct tty_struct *tty, struct tty_ldisc *ld)\n{\n\tlockdep_assert_held_write(&tty->ldisc_sem);\n\tWARN_ON(!test_bit(TTY_LDISC_OPEN, &tty->flags));\n\tclear_bit(TTY_LDISC_OPEN, &tty->flags);\n\tif (ld->ops->close)\n\t\tld->ops->close(tty);\n\ttty_ldisc_debug(tty, \"%p: closed\\n\", ld);\n}\n\n \nstatic int tty_ldisc_failto(struct tty_struct *tty, int ld)\n{\n\tstruct tty_ldisc *disc = tty_ldisc_get(tty, ld);\n\tint r;\n\n\tlockdep_assert_held_write(&tty->ldisc_sem);\n\tif (IS_ERR(disc))\n\t\treturn PTR_ERR(disc);\n\ttty->ldisc = disc;\n\ttty_set_termios_ldisc(tty, ld);\n\tr = tty_ldisc_open(tty, disc);\n\tif (r < 0)\n\t\ttty_ldisc_put(disc);\n\treturn r;\n}\n\n \nstatic void tty_ldisc_restore(struct tty_struct *tty, struct tty_ldisc *old)\n{\n\t \n\tif (tty_ldisc_failto(tty, old->ops->num) < 0) {\n\t\tconst char *name = tty_name(tty);\n\n\t\tpr_warn(\"Falling back ldisc for %s.\\n\", name);\n\t\t \n\t\tif (tty_ldisc_failto(tty, N_TTY) < 0 &&\n\t\t    tty_ldisc_failto(tty, N_NULL) < 0)\n\t\t\tpanic(\"Couldn't open N_NULL ldisc for %s.\", name);\n\t}\n}\n\n \nint tty_set_ldisc(struct tty_struct *tty, int disc)\n{\n\tint retval;\n\tstruct tty_ldisc *old_ldisc, *new_ldisc;\n\n\tnew_ldisc = tty_ldisc_get(tty, disc);\n\tif (IS_ERR(new_ldisc))\n\t\treturn PTR_ERR(new_ldisc);\n\n\ttty_lock(tty);\n\tretval = tty_ldisc_lock(tty, 5 * HZ);\n\tif (retval)\n\t\tgoto err;\n\n\tif (!tty->ldisc) {\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tif (tty->ldisc->ops->num == disc)\n\t\tgoto out;\n\n\tif (test_bit(TTY_HUPPED, &tty->flags)) {\n\t\t \n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\told_ldisc = tty->ldisc;\n\n\t \n\ttty_ldisc_close(tty, old_ldisc);\n\n\t \n\ttty->ldisc = new_ldisc;\n\ttty_set_termios_ldisc(tty, disc);\n\n\tretval = tty_ldisc_open(tty, new_ldisc);\n\tif (retval < 0) {\n\t\t \n\t\ttty_ldisc_put(new_ldisc);\n\t\ttty_ldisc_restore(tty, old_ldisc);\n\t}\n\n\tif (tty->ldisc->ops->num != old_ldisc->ops->num && tty->ops->set_ldisc) {\n\t\tdown_read(&tty->termios_rwsem);\n\t\ttty->ops->set_ldisc(tty);\n\t\tup_read(&tty->termios_rwsem);\n\t}\n\n\t \n\tnew_ldisc = old_ldisc;\nout:\n\ttty_ldisc_unlock(tty);\n\n\t \n\ttty_buffer_restart_work(tty->port);\nerr:\n\ttty_ldisc_put(new_ldisc);\t \n\ttty_unlock(tty);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(tty_set_ldisc);\n\n \nstatic void tty_ldisc_kill(struct tty_struct *tty)\n{\n\tlockdep_assert_held_write(&tty->ldisc_sem);\n\tif (!tty->ldisc)\n\t\treturn;\n\t \n\ttty_ldisc_close(tty, tty->ldisc);\n\ttty_ldisc_put(tty->ldisc);\n\t \n\ttty->ldisc = NULL;\n}\n\n \nstatic void tty_reset_termios(struct tty_struct *tty)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios = tty->driver->init_termios;\n\ttty->termios.c_ispeed = tty_termios_input_baud_rate(&tty->termios);\n\ttty->termios.c_ospeed = tty_termios_baud_rate(&tty->termios);\n\tup_write(&tty->termios_rwsem);\n}\n\n\n \nint tty_ldisc_reinit(struct tty_struct *tty, int disc)\n{\n\tstruct tty_ldisc *ld;\n\tint retval;\n\n\tlockdep_assert_held_write(&tty->ldisc_sem);\n\tld = tty_ldisc_get(tty, disc);\n\tif (IS_ERR(ld)) {\n\t\tBUG_ON(disc == N_TTY);\n\t\treturn PTR_ERR(ld);\n\t}\n\n\tif (tty->ldisc) {\n\t\ttty_ldisc_close(tty, tty->ldisc);\n\t\ttty_ldisc_put(tty->ldisc);\n\t}\n\n\t \n\ttty->ldisc = ld;\n\ttty_set_termios_ldisc(tty, disc);\n\tretval = tty_ldisc_open(tty, tty->ldisc);\n\tif (retval) {\n\t\ttty_ldisc_put(tty->ldisc);\n\t\ttty->ldisc = NULL;\n\t}\n\treturn retval;\n}\n\n \nvoid tty_ldisc_hangup(struct tty_struct *tty, bool reinit)\n{\n\tstruct tty_ldisc *ld;\n\n\ttty_ldisc_debug(tty, \"%p: hangup\\n\", tty->ldisc);\n\n\tld = tty_ldisc_ref(tty);\n\tif (ld != NULL) {\n\t\tif (ld->ops->flush_buffer)\n\t\t\tld->ops->flush_buffer(tty);\n\t\ttty_driver_flush_buffer(tty);\n\t\tif ((test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) &&\n\t\t    ld->ops->write_wakeup)\n\t\t\tld->ops->write_wakeup(tty);\n\t\tif (ld->ops->hangup)\n\t\t\tld->ops->hangup(tty);\n\t\ttty_ldisc_deref(ld);\n\t}\n\n\twake_up_interruptible_poll(&tty->write_wait, EPOLLOUT);\n\twake_up_interruptible_poll(&tty->read_wait, EPOLLIN);\n\n\t \n\ttty_ldisc_lock(tty, MAX_SCHEDULE_TIMEOUT);\n\n\tif (tty->driver->flags & TTY_DRIVER_RESET_TERMIOS)\n\t\ttty_reset_termios(tty);\n\n\tif (tty->ldisc) {\n\t\tif (reinit) {\n\t\t\tif (tty_ldisc_reinit(tty, tty->termios.c_line) < 0 &&\n\t\t\t    tty_ldisc_reinit(tty, N_TTY) < 0)\n\t\t\t\tWARN_ON(tty_ldisc_reinit(tty, N_NULL) < 0);\n\t\t} else\n\t\t\ttty_ldisc_kill(tty);\n\t}\n\ttty_ldisc_unlock(tty);\n}\n\n \nint tty_ldisc_setup(struct tty_struct *tty, struct tty_struct *o_tty)\n{\n\tint retval = tty_ldisc_open(tty, tty->ldisc);\n\n\tif (retval)\n\t\treturn retval;\n\n\tif (o_tty) {\n\t\t \n\t\tretval = tty_ldisc_open(o_tty, o_tty->ldisc);\n\t\tif (retval) {\n\t\t\ttty_ldisc_close(tty, tty->ldisc);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nvoid tty_ldisc_release(struct tty_struct *tty)\n{\n\tstruct tty_struct *o_tty = tty->link;\n\n\t \n\n\ttty_ldisc_lock_pair(tty, o_tty);\n\ttty_ldisc_kill(tty);\n\tif (o_tty)\n\t\ttty_ldisc_kill(o_tty);\n\ttty_ldisc_unlock_pair(tty, o_tty);\n\n\t \n\n\ttty_ldisc_debug(tty, \"released\\n\");\n}\n\n \nint tty_ldisc_init(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld = tty_ldisc_get(tty, N_TTY);\n\n\tif (IS_ERR(ld))\n\t\treturn PTR_ERR(ld);\n\ttty->ldisc = ld;\n\treturn 0;\n}\n\n \nvoid tty_ldisc_deinit(struct tty_struct *tty)\n{\n\t \n\tif (tty->ldisc)\n\t\ttty_ldisc_put(tty->ldisc);\n\ttty->ldisc = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}