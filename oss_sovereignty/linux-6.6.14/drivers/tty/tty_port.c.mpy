{
  "module_name": "tty_port.c",
  "hash_id": "f17986eb4dfc1a3fbe9df815dc30ee25a34a6bef09dd819c62a8afbef11336d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/tty_port.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/wait.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/serdev.h>\n#include \"tty.h\"\n\nstatic size_t tty_port_default_receive_buf(struct tty_port *port, const u8 *p,\n\t\t\t\t\t   const u8 *f, size_t count)\n{\n\tstruct tty_struct *tty;\n\tstruct tty_ldisc *ld;\n\n\ttty = READ_ONCE(port->itty);\n\tif (!tty)\n\t\treturn 0;\n\n\tld = tty_ldisc_ref(tty);\n\tif (!ld)\n\t\treturn 0;\n\n\tcount = tty_ldisc_receive_buf(ld, p, f, count);\n\n\ttty_ldisc_deref(ld);\n\n\treturn count;\n}\n\nstatic void tty_port_default_lookahead_buf(struct tty_port *port, const u8 *p,\n\t\t\t\t\t   const u8 *f, size_t count)\n{\n\tstruct tty_struct *tty;\n\tstruct tty_ldisc *ld;\n\n\ttty = READ_ONCE(port->itty);\n\tif (!tty)\n\t\treturn;\n\n\tld = tty_ldisc_ref(tty);\n\tif (!ld)\n\t\treturn;\n\n\tif (ld->ops->lookahead_buf)\n\t\tld->ops->lookahead_buf(ld->tty, p, f, count);\n\n\ttty_ldisc_deref(ld);\n}\n\nstatic void tty_port_default_wakeup(struct tty_port *port)\n{\n\tstruct tty_struct *tty = tty_port_tty_get(port);\n\n\tif (tty) {\n\t\ttty_wakeup(tty);\n\t\ttty_kref_put(tty);\n\t}\n}\n\nconst struct tty_port_client_operations tty_port_default_client_ops = {\n\t.receive_buf = tty_port_default_receive_buf,\n\t.lookahead_buf = tty_port_default_lookahead_buf,\n\t.write_wakeup = tty_port_default_wakeup,\n};\nEXPORT_SYMBOL_GPL(tty_port_default_client_ops);\n\n \nvoid tty_port_init(struct tty_port *port)\n{\n\tmemset(port, 0, sizeof(*port));\n\ttty_buffer_init(port);\n\tinit_waitqueue_head(&port->open_wait);\n\tinit_waitqueue_head(&port->delta_msr_wait);\n\tmutex_init(&port->mutex);\n\tmutex_init(&port->buf_mutex);\n\tspin_lock_init(&port->lock);\n\tport->close_delay = (50 * HZ) / 100;\n\tport->closing_wait = (3000 * HZ) / 100;\n\tport->client_ops = &tty_port_default_client_ops;\n\tkref_init(&port->kref);\n}\nEXPORT_SYMBOL(tty_port_init);\n\n \nvoid tty_port_link_device(struct tty_port *port,\n\t\tstruct tty_driver *driver, unsigned index)\n{\n\tif (WARN_ON(index >= driver->num))\n\t\treturn;\n\tdriver->ports[index] = port;\n}\nEXPORT_SYMBOL_GPL(tty_port_link_device);\n\n \nstruct device *tty_port_register_device(struct tty_port *port,\n\t\tstruct tty_driver *driver, unsigned index,\n\t\tstruct device *device)\n{\n\treturn tty_port_register_device_attr(port, driver, index, device, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(tty_port_register_device);\n\n \nstruct device *tty_port_register_device_attr(struct tty_port *port,\n\t\tstruct tty_driver *driver, unsigned index,\n\t\tstruct device *device, void *drvdata,\n\t\tconst struct attribute_group **attr_grp)\n{\n\ttty_port_link_device(port, driver, index);\n\treturn tty_register_device_attr(driver, index, device, drvdata,\n\t\t\tattr_grp);\n}\nEXPORT_SYMBOL_GPL(tty_port_register_device_attr);\n\n \nstruct device *tty_port_register_device_attr_serdev(struct tty_port *port,\n\t\tstruct tty_driver *driver, unsigned index,\n\t\tstruct device *device, void *drvdata,\n\t\tconst struct attribute_group **attr_grp)\n{\n\tstruct device *dev;\n\n\ttty_port_link_device(port, driver, index);\n\n\tdev = serdev_tty_port_register(port, device, driver, index);\n\tif (PTR_ERR(dev) != -ENODEV) {\n\t\t \n\t\treturn dev;\n\t}\n\n\treturn tty_register_device_attr(driver, index, device, drvdata,\n\t\t\tattr_grp);\n}\nEXPORT_SYMBOL_GPL(tty_port_register_device_attr_serdev);\n\n \nstruct device *tty_port_register_device_serdev(struct tty_port *port,\n\t\tstruct tty_driver *driver, unsigned index,\n\t\tstruct device *device)\n{\n\treturn tty_port_register_device_attr_serdev(port, driver, index,\n\t\t\tdevice, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(tty_port_register_device_serdev);\n\n \nvoid tty_port_unregister_device(struct tty_port *port,\n\t\tstruct tty_driver *driver, unsigned index)\n{\n\tint ret;\n\n\tret = serdev_tty_port_unregister(port);\n\tif (ret == 0)\n\t\treturn;\n\n\ttty_unregister_device(driver, index);\n}\nEXPORT_SYMBOL_GPL(tty_port_unregister_device);\n\nint tty_port_alloc_xmit_buf(struct tty_port *port)\n{\n\t \n\tmutex_lock(&port->buf_mutex);\n\tif (port->xmit_buf == NULL) {\n\t\tport->xmit_buf = (unsigned char *)get_zeroed_page(GFP_KERNEL);\n\t\tif (port->xmit_buf)\n\t\t\tkfifo_init(&port->xmit_fifo, port->xmit_buf, PAGE_SIZE);\n\t}\n\tmutex_unlock(&port->buf_mutex);\n\tif (port->xmit_buf == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nEXPORT_SYMBOL(tty_port_alloc_xmit_buf);\n\nvoid tty_port_free_xmit_buf(struct tty_port *port)\n{\n\tmutex_lock(&port->buf_mutex);\n\tfree_page((unsigned long)port->xmit_buf);\n\tport->xmit_buf = NULL;\n\tINIT_KFIFO(port->xmit_fifo);\n\tmutex_unlock(&port->buf_mutex);\n}\nEXPORT_SYMBOL(tty_port_free_xmit_buf);\n\n \nvoid tty_port_destroy(struct tty_port *port)\n{\n\ttty_buffer_cancel_work(port);\n\ttty_buffer_free_all(port);\n}\nEXPORT_SYMBOL(tty_port_destroy);\n\nstatic void tty_port_destructor(struct kref *kref)\n{\n\tstruct tty_port *port = container_of(kref, struct tty_port, kref);\n\n\t \n\tif (WARN_ON(port->itty))\n\t\treturn;\n\tfree_page((unsigned long)port->xmit_buf);\n\ttty_port_destroy(port);\n\tif (port->ops && port->ops->destruct)\n\t\tport->ops->destruct(port);\n\telse\n\t\tkfree(port);\n}\n\n \nvoid tty_port_put(struct tty_port *port)\n{\n\tif (port)\n\t\tkref_put(&port->kref, tty_port_destructor);\n}\nEXPORT_SYMBOL(tty_port_put);\n\n \nstruct tty_struct *tty_port_tty_get(struct tty_port *port)\n{\n\tunsigned long flags;\n\tstruct tty_struct *tty;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\ttty = tty_kref_get(port->tty);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\treturn tty;\n}\nEXPORT_SYMBOL(tty_port_tty_get);\n\n \nvoid tty_port_tty_set(struct tty_port *port, struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\ttty_kref_put(port->tty);\n\tport->tty = tty_kref_get(tty);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\nEXPORT_SYMBOL(tty_port_tty_set);\n\n \nstatic void tty_port_shutdown(struct tty_port *port, struct tty_struct *tty)\n{\n\tmutex_lock(&port->mutex);\n\tif (port->console)\n\t\tgoto out;\n\n\tif (tty_port_initialized(port)) {\n\t\ttty_port_set_initialized(port, false);\n\t\t \n\t\tif (tty && C_HUPCL(tty))\n\t\t\ttty_port_lower_dtr_rts(port);\n\n\t\tif (port->ops->shutdown)\n\t\t\tport->ops->shutdown(port);\n\t}\nout:\n\tmutex_unlock(&port->mutex);\n}\n\n \nvoid tty_port_hangup(struct tty_port *port)\n{\n\tstruct tty_struct *tty;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tport->count = 0;\n\ttty = port->tty;\n\tif (tty)\n\t\tset_bit(TTY_IO_ERROR, &tty->flags);\n\tport->tty = NULL;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\ttty_port_set_active(port, false);\n\ttty_port_shutdown(port, tty);\n\ttty_kref_put(tty);\n\twake_up_interruptible(&port->open_wait);\n\twake_up_interruptible(&port->delta_msr_wait);\n}\nEXPORT_SYMBOL(tty_port_hangup);\n\n \nvoid tty_port_tty_hangup(struct tty_port *port, bool check_clocal)\n{\n\tstruct tty_struct *tty = tty_port_tty_get(port);\n\n\tif (tty && (!check_clocal || !C_CLOCAL(tty)))\n\t\ttty_hangup(tty);\n\ttty_kref_put(tty);\n}\nEXPORT_SYMBOL_GPL(tty_port_tty_hangup);\n\n \nvoid tty_port_tty_wakeup(struct tty_port *port)\n{\n\tport->client_ops->write_wakeup(port);\n}\nEXPORT_SYMBOL_GPL(tty_port_tty_wakeup);\n\n \nbool tty_port_carrier_raised(struct tty_port *port)\n{\n\tif (port->ops->carrier_raised == NULL)\n\t\treturn true;\n\treturn port->ops->carrier_raised(port);\n}\nEXPORT_SYMBOL(tty_port_carrier_raised);\n\n \nvoid tty_port_raise_dtr_rts(struct tty_port *port)\n{\n\tif (port->ops->dtr_rts)\n\t\tport->ops->dtr_rts(port, true);\n}\nEXPORT_SYMBOL(tty_port_raise_dtr_rts);\n\n \nvoid tty_port_lower_dtr_rts(struct tty_port *port)\n{\n\tif (port->ops->dtr_rts)\n\t\tport->ops->dtr_rts(port, false);\n}\nEXPORT_SYMBOL(tty_port_lower_dtr_rts);\n\n \nint tty_port_block_til_ready(struct tty_port *port,\n\t\t\t\tstruct tty_struct *tty, struct file *filp)\n{\n\tint do_clocal = 0, retval;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\n\t \n\tif (tty_io_error(tty)) {\n\t\ttty_port_set_active(port, true);\n\t\treturn 0;\n\t}\n\tif (filp == NULL || (filp->f_flags & O_NONBLOCK)) {\n\t\t \n\t\tif (C_BAUD(tty))\n\t\t\ttty_port_raise_dtr_rts(port);\n\t\ttty_port_set_active(port, true);\n\t\treturn 0;\n\t}\n\n\tif (C_CLOCAL(tty))\n\t\tdo_clocal = 1;\n\n\t \n\n\tretval = 0;\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tport->count--;\n\tport->blocked_open++;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\twhile (1) {\n\t\t \n\t\tif (C_BAUD(tty) && tty_port_initialized(port))\n\t\t\ttty_port_raise_dtr_rts(port);\n\n\t\tprepare_to_wait(&port->open_wait, &wait, TASK_INTERRUPTIBLE);\n\t\t \n\t\tif (tty_hung_up_p(filp) || !tty_port_initialized(port)) {\n\t\t\tif (port->flags & ASYNC_HUP_NOTIFY)\n\t\t\t\tretval = -EAGAIN;\n\t\t\telse\n\t\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (do_clocal || tty_port_carrier_raised(port))\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\ttty_unlock(tty);\n\t\tschedule();\n\t\ttty_lock(tty);\n\t}\n\tfinish_wait(&port->open_wait, &wait);\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\tif (!tty_hung_up_p(filp))\n\t\tport->count++;\n\tport->blocked_open--;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tif (retval == 0)\n\t\ttty_port_set_active(port, true);\n\treturn retval;\n}\nEXPORT_SYMBOL(tty_port_block_til_ready);\n\nstatic void tty_port_drain_delay(struct tty_port *port, struct tty_struct *tty)\n{\n\tunsigned int bps = tty_get_baud_rate(tty);\n\tlong timeout;\n\n\tif (bps > 1200) {\n\t\ttimeout = (HZ * 10 * port->drain_delay) / bps;\n\t\ttimeout = max_t(long, timeout, HZ / 10);\n\t} else {\n\t\ttimeout = 2 * HZ;\n\t}\n\tschedule_timeout_interruptible(timeout);\n}\n\n \nint tty_port_close_start(struct tty_port *port,\n\t\t\t\tstruct tty_struct *tty, struct file *filp)\n{\n\tunsigned long flags;\n\n\tif (tty_hung_up_p(filp))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (tty->count == 1 && port->count != 1) {\n\t\ttty_warn(tty, \"%s: tty->count = 1 port count = %d\\n\", __func__,\n\t\t\t port->count);\n\t\tport->count = 1;\n\t}\n\tif (--port->count < 0) {\n\t\ttty_warn(tty, \"%s: bad port count (%d)\\n\", __func__,\n\t\t\t port->count);\n\t\tport->count = 0;\n\t}\n\n\tif (port->count) {\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\ttty->closing = 1;\n\n\tif (tty_port_initialized(port)) {\n\t\t \n\t\tif (tty->flow.tco_stopped)\n\t\t\ttty_driver_flush_buffer(tty);\n\t\tif (port->closing_wait != ASYNC_CLOSING_WAIT_NONE)\n\t\t\ttty_wait_until_sent(tty, port->closing_wait);\n\t\tif (port->drain_delay)\n\t\t\ttty_port_drain_delay(port, tty);\n\t}\n\t \n\ttty_ldisc_flush(tty);\n\n\t \n\treturn 1;\n}\nEXPORT_SYMBOL(tty_port_close_start);\n\n \nvoid tty_port_close_end(struct tty_port *port, struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\ttty_ldisc_flush(tty);\n\ttty->closing = 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (port->blocked_open) {\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tif (port->close_delay)\n\t\t\tmsleep_interruptible(jiffies_to_msecs(port->close_delay));\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\twake_up_interruptible(&port->open_wait);\n\t}\n\tspin_unlock_irqrestore(&port->lock, flags);\n\ttty_port_set_active(port, false);\n}\nEXPORT_SYMBOL(tty_port_close_end);\n\n \nvoid tty_port_close(struct tty_port *port, struct tty_struct *tty,\n\t\t\t\t\t\t\tstruct file *filp)\n{\n\tif (tty_port_close_start(port, tty, filp) == 0)\n\t\treturn;\n\ttty_port_shutdown(port, tty);\n\tif (!port->console)\n\t\tset_bit(TTY_IO_ERROR, &tty->flags);\n\ttty_port_close_end(port, tty);\n\ttty_port_tty_set(port, NULL);\n}\nEXPORT_SYMBOL(tty_port_close);\n\n \nint tty_port_install(struct tty_port *port, struct tty_driver *driver,\n\t\tstruct tty_struct *tty)\n{\n\ttty->port = port;\n\treturn tty_standard_install(driver, tty);\n}\nEXPORT_SYMBOL_GPL(tty_port_install);\n\n \nint tty_port_open(struct tty_port *port, struct tty_struct *tty,\n\t\t\t\t\t\t\tstruct file *filp)\n{\n\tspin_lock_irq(&port->lock);\n\t++port->count;\n\tspin_unlock_irq(&port->lock);\n\ttty_port_tty_set(port, tty);\n\n\t \n\n\tmutex_lock(&port->mutex);\n\n\tif (!tty_port_initialized(port)) {\n\t\tclear_bit(TTY_IO_ERROR, &tty->flags);\n\t\tif (port->ops->activate) {\n\t\t\tint retval = port->ops->activate(port, tty);\n\n\t\t\tif (retval) {\n\t\t\t\tmutex_unlock(&port->mutex);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t\ttty_port_set_initialized(port, true);\n\t}\n\tmutex_unlock(&port->mutex);\n\treturn tty_port_block_til_ready(port, tty, filp);\n}\nEXPORT_SYMBOL(tty_port_open);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}