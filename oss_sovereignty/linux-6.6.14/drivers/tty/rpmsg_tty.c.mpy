{
  "module_name": "rpmsg_tty.c",
  "hash_id": "6a6da476f2422b78ac4fd6513c93b6c9736f3d8a90bd1d4015886caae5c4eb98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/rpmsg_tty.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/rpmsg.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#define RPMSG_TTY_NAME\t\"ttyRPMSG\"\n#define MAX_TTY_RPMSG\t32\n\nstatic DEFINE_IDR(tty_idr);\t \nstatic DEFINE_MUTEX(idr_lock);\t \n\nstatic struct tty_driver *rpmsg_tty_driver;\n\nstruct rpmsg_tty_port {\n\tstruct tty_port\t\tport;\t  \n\tint\t\t\tid;\t  \n\tstruct rpmsg_device\t*rpdev;\t  \n};\n\nstatic int rpmsg_tty_cb(struct rpmsg_device *rpdev, void *data, int len, void *priv, u32 src)\n{\n\tstruct rpmsg_tty_port *cport = dev_get_drvdata(&rpdev->dev);\n\tint copied;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\tcopied = tty_insert_flip_string(&cport->port, data, len);\n\tif (copied != len)\n\t\tdev_err_ratelimited(&rpdev->dev, \"Trunc buffer: available space is %d\\n\", copied);\n\ttty_flip_buffer_push(&cport->port);\n\n\treturn 0;\n}\n\nstatic int rpmsg_tty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct rpmsg_tty_port *cport = idr_find(&tty_idr, tty->index);\n\tstruct tty_port *port;\n\n\ttty->driver_data = cport;\n\n\tport = tty_port_get(&cport->port);\n\treturn tty_port_install(port, driver, tty);\n}\n\nstatic void rpmsg_tty_cleanup(struct tty_struct *tty)\n{\n\ttty_port_put(tty->port);\n}\n\nstatic int rpmsg_tty_open(struct tty_struct *tty, struct file *filp)\n{\n\treturn tty_port_open(tty->port, tty, filp);\n}\n\nstatic void rpmsg_tty_close(struct tty_struct *tty, struct file *filp)\n{\n\treturn tty_port_close(tty->port, tty, filp);\n}\n\nstatic ssize_t rpmsg_tty_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t       size_t len)\n{\n\tstruct rpmsg_tty_port *cport = tty->driver_data;\n\tstruct rpmsg_device *rpdev;\n\tint msg_max_size, msg_size;\n\tint ret;\n\n\trpdev = cport->rpdev;\n\n\tmsg_max_size = rpmsg_get_mtu(rpdev->ept);\n\tif (msg_max_size < 0)\n\t\treturn msg_max_size;\n\n\tmsg_size = min_t(unsigned int, len, msg_max_size);\n\n\t \n\tret = rpmsg_trysend(rpdev->ept, (void *)buf, msg_size);\n\tif (ret) {\n\t\tdev_dbg_ratelimited(&rpdev->dev, \"rpmsg_send failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn msg_size;\n}\n\nstatic unsigned int rpmsg_tty_write_room(struct tty_struct *tty)\n{\n\tstruct rpmsg_tty_port *cport = tty->driver_data;\n\tint size;\n\n\tsize = rpmsg_get_mtu(cport->rpdev->ept);\n\tif (size < 0)\n\t\treturn 0;\n\n\treturn size;\n}\n\nstatic void rpmsg_tty_hangup(struct tty_struct *tty)\n{\n\ttty_port_hangup(tty->port);\n}\n\nstatic const struct tty_operations rpmsg_tty_ops = {\n\t.install\t= rpmsg_tty_install,\n\t.open\t\t= rpmsg_tty_open,\n\t.close\t\t= rpmsg_tty_close,\n\t.write\t\t= rpmsg_tty_write,\n\t.write_room\t= rpmsg_tty_write_room,\n\t.hangup\t\t= rpmsg_tty_hangup,\n\t.cleanup\t= rpmsg_tty_cleanup,\n};\n\nstatic struct rpmsg_tty_port *rpmsg_tty_alloc_cport(void)\n{\n\tstruct rpmsg_tty_port *cport;\n\tint ret;\n\n\tcport = kzalloc(sizeof(*cport), GFP_KERNEL);\n\tif (!cport)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&idr_lock);\n\tret = idr_alloc(&tty_idr, cport, 0, MAX_TTY_RPMSG, GFP_KERNEL);\n\tmutex_unlock(&idr_lock);\n\n\tif (ret < 0) {\n\t\tkfree(cport);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tcport->id = ret;\n\n\treturn cport;\n}\n\nstatic void rpmsg_tty_destruct_port(struct tty_port *port)\n{\n\tstruct rpmsg_tty_port *cport = container_of(port, struct rpmsg_tty_port, port);\n\n\tmutex_lock(&idr_lock);\n\tidr_remove(&tty_idr, cport->id);\n\tmutex_unlock(&idr_lock);\n\n\tkfree(cport);\n}\n\nstatic const struct tty_port_operations rpmsg_tty_port_ops = {\n\t.destruct = rpmsg_tty_destruct_port,\n};\n\n\nstatic int rpmsg_tty_probe(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_tty_port *cport;\n\tstruct device *dev = &rpdev->dev;\n\tstruct device *tty_dev;\n\tint ret;\n\n\tcport = rpmsg_tty_alloc_cport();\n\tif (IS_ERR(cport))\n\t\treturn dev_err_probe(dev, PTR_ERR(cport), \"Failed to alloc tty port\\n\");\n\n\ttty_port_init(&cport->port);\n\tcport->port.ops = &rpmsg_tty_port_ops;\n\n\ttty_dev = tty_port_register_device(&cport->port, rpmsg_tty_driver,\n\t\t\t\t\t   cport->id, dev);\n\tif (IS_ERR(tty_dev)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(tty_dev), \"Failed to register tty port\\n\");\n\t\ttty_port_put(&cport->port);\n\t\treturn ret;\n\t}\n\n\tcport->rpdev = rpdev;\n\n\tdev_set_drvdata(dev, cport);\n\n\tdev_dbg(dev, \"New channel: 0x%x -> 0x%x: \" RPMSG_TTY_NAME \"%d\\n\",\n\t\trpdev->src, rpdev->dst, cport->id);\n\n\treturn 0;\n}\n\nstatic void rpmsg_tty_remove(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_tty_port *cport = dev_get_drvdata(&rpdev->dev);\n\n\tdev_dbg(&rpdev->dev, \"Removing rpmsg tty device %d\\n\", cport->id);\n\n\t \n\ttty_port_tty_hangup(&cport->port, false);\n\n\ttty_unregister_device(rpmsg_tty_driver, cport->id);\n\n\ttty_port_put(&cport->port);\n}\n\nstatic struct rpmsg_device_id rpmsg_driver_tty_id_table[] = {\n\t{ .name\t= \"rpmsg-tty\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(rpmsg, rpmsg_driver_tty_id_table);\n\nstatic struct rpmsg_driver rpmsg_tty_rpmsg_drv = {\n\t.drv.name\t= KBUILD_MODNAME,\n\t.id_table\t= rpmsg_driver_tty_id_table,\n\t.probe\t\t= rpmsg_tty_probe,\n\t.callback\t= rpmsg_tty_cb,\n\t.remove\t\t= rpmsg_tty_remove,\n};\n\nstatic int __init rpmsg_tty_init(void)\n{\n\tint ret;\n\n\trpmsg_tty_driver = tty_alloc_driver(MAX_TTY_RPMSG, TTY_DRIVER_REAL_RAW |\n\t\t\t\t\t    TTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(rpmsg_tty_driver))\n\t\treturn PTR_ERR(rpmsg_tty_driver);\n\n\trpmsg_tty_driver->driver_name = \"rpmsg_tty\";\n\trpmsg_tty_driver->name = RPMSG_TTY_NAME;\n\trpmsg_tty_driver->major = 0;\n\trpmsg_tty_driver->type = TTY_DRIVER_TYPE_CONSOLE;\n\n\t \n\trpmsg_tty_driver->init_termios = tty_std_termios;\n\trpmsg_tty_driver->init_termios.c_lflag &= ~(ECHO | ICANON);\n\trpmsg_tty_driver->init_termios.c_oflag &= ~(OPOST | ONLCR);\n\n\ttty_set_operations(rpmsg_tty_driver, &rpmsg_tty_ops);\n\n\tret = tty_register_driver(rpmsg_tty_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"Couldn't install driver: %d\\n\", ret);\n\t\tgoto error_put;\n\t}\n\n\tret = register_rpmsg_driver(&rpmsg_tty_rpmsg_drv);\n\tif (ret < 0) {\n\t\tpr_err(\"Couldn't register driver: %d\\n\", ret);\n\t\tgoto error_unregister;\n\t}\n\n\treturn 0;\n\nerror_unregister:\n\ttty_unregister_driver(rpmsg_tty_driver);\n\nerror_put:\n\ttty_driver_kref_put(rpmsg_tty_driver);\n\n\treturn ret;\n}\n\nstatic void __exit rpmsg_tty_exit(void)\n{\n\tunregister_rpmsg_driver(&rpmsg_tty_rpmsg_drv);\n\ttty_unregister_driver(rpmsg_tty_driver);\n\ttty_driver_kref_put(rpmsg_tty_driver);\n\tidr_destroy(&tty_idr);\n}\n\nmodule_init(rpmsg_tty_init);\nmodule_exit(rpmsg_tty_exit);\n\nMODULE_AUTHOR(\"Arnaud Pouliquen <arnaud.pouliquen@foss.st.com>\");\nMODULE_DESCRIPTION(\"remote processor messaging tty driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}