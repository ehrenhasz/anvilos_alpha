{
  "module_name": "ehv_bytechan.c",
  "hash_id": "da92d0f4fe0b68def2139018765ce2be978d7ea51a7f5253123f6250ffa9b9bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/ehv_bytechan.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <asm/epapr_hcalls.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/cdev.h>\n#include <linux/console.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/circ_buf.h>\n#include <asm/udbg.h>\n\n \n#define BUF_SIZE\t2048\n\n \nstruct ehv_bc_data {\n\tstruct device *dev;\n\tstruct tty_port port;\n\tuint32_t handle;\n\tunsigned int rx_irq;\n\tunsigned int tx_irq;\n\n\tspinlock_t lock;\t \n\tunsigned char buf[BUF_SIZE];\t \n\tunsigned int head;\t \n\tunsigned int tail;\t \n\n\tint tx_irq_enabled;\t \n};\n\n \nstatic struct ehv_bc_data *bcs;\n\n \nstatic unsigned int stdout_bc;\n\n \nstatic unsigned int stdout_irq;\n\n \n\n \nstatic void enable_tx_interrupt(struct ehv_bc_data *bc)\n{\n\tif (!bc->tx_irq_enabled) {\n\t\tenable_irq(bc->tx_irq);\n\t\tbc->tx_irq_enabled = 1;\n\t}\n}\n\nstatic void disable_tx_interrupt(struct ehv_bc_data *bc)\n{\n\tif (bc->tx_irq_enabled) {\n\t\tdisable_irq_nosync(bc->tx_irq);\n\t\tbc->tx_irq_enabled = 0;\n\t}\n}\n\n \nstatic int find_console_handle(void)\n{\n\tstruct device_node *np = of_stdout;\n\tconst uint32_t *iprop;\n\n\t \n\tif (!np || !of_device_is_compatible(np, \"epapr,hv-byte-channel\"))\n\t\treturn 0;\n\n\tstdout_irq = irq_of_parse_and_map(np, 0);\n\tif (!stdout_irq) {\n\t\tpr_err(\"ehv-bc: no 'interrupts' property in %pOF node\\n\", np);\n\t\treturn 0;\n\t}\n\n\t \n\tiprop = of_get_property(np, \"hv-handle\", NULL);\n\tif (!iprop) {\n\t\tpr_err(\"ehv-bc: no 'hv-handle' property in %pOFn node\\n\",\n\t\t       np);\n\t\treturn 0;\n\t}\n\tstdout_bc = be32_to_cpu(*iprop);\n\treturn 1;\n}\n\nstatic unsigned int local_ev_byte_channel_send(unsigned int handle,\n\t\t\t\t\t       unsigned int *count,\n\t\t\t\t\t       const char *p)\n{\n\tchar buffer[EV_BYTE_CHANNEL_MAX_BYTES];\n\tunsigned int c = *count;\n\n\tif (c < sizeof(buffer)) {\n\t\tmemcpy(buffer, p, c);\n\t\tmemset(&buffer[c], 0, sizeof(buffer) - c);\n\t\tp = buffer;\n\t}\n\treturn ev_byte_channel_send(handle, count, p);\n}\n\n \n\n#ifdef CONFIG_PPC_EARLY_DEBUG_EHV_BC\n\n \nstatic void byte_channel_spin_send(const char data)\n{\n\tint ret, count;\n\n\tdo {\n\t\tcount = 1;\n\t\tret = local_ev_byte_channel_send(CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE,\n\t\t\t\t\t   &count, &data);\n\t} while (ret == EV_EAGAIN);\n}\n\n \nstatic void ehv_bc_udbg_putc(char c)\n{\n\tif (c == '\\n')\n\t\tbyte_channel_spin_send('\\r');\n\n\tbyte_channel_spin_send(c);\n}\n\n \nvoid __init udbg_init_ehv_bc(void)\n{\n\tunsigned int rx_count, tx_count;\n\tunsigned int ret;\n\n\t \n\tret = ev_byte_channel_poll(CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE,\n\t\t\t\t   &rx_count, &tx_count);\n\tif (ret)\n\t\treturn;\n\n\tudbg_putc = ehv_bc_udbg_putc;\n\tregister_early_udbg_console();\n\n\tudbg_printf(\"ehv-bc: early console using byte channel handle %u\\n\",\n\t\t    CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE);\n}\n\n#endif\n\n \n\nstatic struct tty_driver *ehv_bc_driver;\n\n \nstatic int ehv_bc_console_byte_channel_send(unsigned int handle, const char *s,\n\t\t\t     unsigned int count)\n{\n\tunsigned int len;\n\tint ret = 0;\n\n\twhile (count) {\n\t\tlen = min_t(unsigned int, count, EV_BYTE_CHANNEL_MAX_BYTES);\n\t\tdo {\n\t\t\tret = local_ev_byte_channel_send(handle, &len, s);\n\t\t} while (ret == EV_EAGAIN);\n\t\tcount -= len;\n\t\ts += len;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void ehv_bc_console_write(struct console *co, const char *s,\n\t\t\t\t unsigned int count)\n{\n\tchar s2[EV_BYTE_CHANNEL_MAX_BYTES];\n\tunsigned int i, j = 0;\n\tchar c;\n\n\tfor (i = 0; i < count; i++) {\n\t\tc = *s++;\n\n\t\tif (c == '\\n')\n\t\t\ts2[j++] = '\\r';\n\n\t\ts2[j++] = c;\n\t\tif (j >= (EV_BYTE_CHANNEL_MAX_BYTES - 1)) {\n\t\t\tif (ehv_bc_console_byte_channel_send(stdout_bc, s2, j))\n\t\t\t\treturn;\n\t\t\tj = 0;\n\t\t}\n\t}\n\n\tif (j)\n\t\tehv_bc_console_byte_channel_send(stdout_bc, s2, j);\n}\n\n \nstatic struct tty_driver *ehv_bc_console_device(struct console *co, int *index)\n{\n\t*index = co->index;\n\n\treturn ehv_bc_driver;\n}\n\nstatic struct console ehv_bc_console = {\n\t.name\t\t= \"ttyEHV\",\n\t.write\t\t= ehv_bc_console_write,\n\t.device\t\t= ehv_bc_console_device,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n};\n\n \nstatic int __init ehv_bc_console_init(void)\n{\n\tif (!find_console_handle()) {\n\t\tpr_debug(\"ehv-bc: stdout is not a byte channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\n#ifdef CONFIG_PPC_EARLY_DEBUG_EHV_BC\n\t \n\tif (stdout_bc != CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE)\n\t\tpr_warn(\"ehv-bc: udbg handle %u is not the stdout handle\\n\",\n\t\t\tCONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE);\n#endif\n\n\t \n\n\tadd_preferred_console(ehv_bc_console.name, ehv_bc_console.index, NULL);\n\tregister_console(&ehv_bc_console);\n\n\tpr_info(\"ehv-bc: registered console driver for byte channel %u\\n\",\n\t\tstdout_bc);\n\n\treturn 0;\n}\nconsole_initcall(ehv_bc_console_init);\n\n \n\n \nstatic irqreturn_t ehv_bc_tty_rx_isr(int irq, void *data)\n{\n\tstruct ehv_bc_data *bc = data;\n\tunsigned int rx_count, tx_count, len;\n\tint count;\n\tchar buffer[EV_BYTE_CHANNEL_MAX_BYTES];\n\tint ret;\n\n\t \n\tev_byte_channel_poll(bc->handle, &rx_count, &tx_count);\n\tcount = tty_buffer_request_room(&bc->port, rx_count);\n\n\t \n\n\twhile (count > 0) {\n\t\tlen = min_t(unsigned int, count, sizeof(buffer));\n\n\t\t \n\t\tev_byte_channel_receive(bc->handle, &len, buffer);\n\n\t\t \n\n\t\t \n\t\tret = tty_insert_flip_string(&bc->port, buffer, len);\n\n\t\t \n\t\tif (ret != len)\n\t\t\tbreak;\n\n\t\tcount -= len;\n\t}\n\n\t \n\ttty_flip_buffer_push(&bc->port);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void ehv_bc_tx_dequeue(struct ehv_bc_data *bc)\n{\n\tunsigned int count;\n\tunsigned int len, ret;\n\tunsigned long flags;\n\n\tdo {\n\t\tspin_lock_irqsave(&bc->lock, flags);\n\t\tlen = min_t(unsigned int,\n\t\t\t    CIRC_CNT_TO_END(bc->head, bc->tail, BUF_SIZE),\n\t\t\t    EV_BYTE_CHANNEL_MAX_BYTES);\n\n\t\tret = local_ev_byte_channel_send(bc->handle, &len, bc->buf + bc->tail);\n\n\t\t \n\t\tif (!ret || (ret == EV_EAGAIN))\n\t\t\tbc->tail = (bc->tail + len) & (BUF_SIZE - 1);\n\n\t\tcount = CIRC_CNT(bc->head, bc->tail, BUF_SIZE);\n\t\tspin_unlock_irqrestore(&bc->lock, flags);\n\t} while (count && !ret);\n\n\tspin_lock_irqsave(&bc->lock, flags);\n\tif (CIRC_CNT(bc->head, bc->tail, BUF_SIZE))\n\t\t \n\t\tenable_tx_interrupt(bc);\n\telse\n\t\tdisable_tx_interrupt(bc);\n\tspin_unlock_irqrestore(&bc->lock, flags);\n}\n\n \nstatic irqreturn_t ehv_bc_tty_tx_isr(int irq, void *data)\n{\n\tstruct ehv_bc_data *bc = data;\n\n\tehv_bc_tx_dequeue(bc);\n\ttty_port_tty_wakeup(&bc->port);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic ssize_t ehv_bc_tty_write(struct tty_struct *ttys, const u8 *s,\n\t\t\t\tsize_t count)\n{\n\tstruct ehv_bc_data *bc = ttys->driver_data;\n\tunsigned long flags;\n\tunsigned int len;\n\tunsigned int written = 0;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&bc->lock, flags);\n\t\tlen = CIRC_SPACE_TO_END(bc->head, bc->tail, BUF_SIZE);\n\t\tif (count < len)\n\t\t\tlen = count;\n\t\tif (len) {\n\t\t\tmemcpy(bc->buf + bc->head, s, len);\n\t\t\tbc->head = (bc->head + len) & (BUF_SIZE - 1);\n\t\t}\n\t\tspin_unlock_irqrestore(&bc->lock, flags);\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\ts += len;\n\t\tcount -= len;\n\t\twritten += len;\n\t}\n\n\tehv_bc_tx_dequeue(bc);\n\n\treturn written;\n}\n\n \nstatic int ehv_bc_tty_open(struct tty_struct *ttys, struct file *filp)\n{\n\tstruct ehv_bc_data *bc = &bcs[ttys->index];\n\n\tif (!bc->dev)\n\t\treturn -ENODEV;\n\n\treturn tty_port_open(&bc->port, ttys, filp);\n}\n\n \nstatic void ehv_bc_tty_close(struct tty_struct *ttys, struct file *filp)\n{\n\tstruct ehv_bc_data *bc = &bcs[ttys->index];\n\n\tif (bc->dev)\n\t\ttty_port_close(&bc->port, ttys, filp);\n}\n\n \nstatic unsigned int ehv_bc_tty_write_room(struct tty_struct *ttys)\n{\n\tstruct ehv_bc_data *bc = ttys->driver_data;\n\tunsigned long flags;\n\tunsigned int count;\n\n\tspin_lock_irqsave(&bc->lock, flags);\n\tcount = CIRC_SPACE(bc->head, bc->tail, BUF_SIZE);\n\tspin_unlock_irqrestore(&bc->lock, flags);\n\n\treturn count;\n}\n\n \nstatic void ehv_bc_tty_throttle(struct tty_struct *ttys)\n{\n\tstruct ehv_bc_data *bc = ttys->driver_data;\n\n\tdisable_irq(bc->rx_irq);\n}\n\n \nstatic void ehv_bc_tty_unthrottle(struct tty_struct *ttys)\n{\n\tstruct ehv_bc_data *bc = ttys->driver_data;\n\n\t \n\tenable_irq(bc->rx_irq);\n}\n\nstatic void ehv_bc_tty_hangup(struct tty_struct *ttys)\n{\n\tstruct ehv_bc_data *bc = ttys->driver_data;\n\n\tehv_bc_tx_dequeue(bc);\n\ttty_port_hangup(&bc->port);\n}\n\n \nstatic const struct tty_operations ehv_bc_ops = {\n\t.open\t\t= ehv_bc_tty_open,\n\t.close\t\t= ehv_bc_tty_close,\n\t.write\t\t= ehv_bc_tty_write,\n\t.write_room\t= ehv_bc_tty_write_room,\n\t.throttle\t= ehv_bc_tty_throttle,\n\t.unthrottle\t= ehv_bc_tty_unthrottle,\n\t.hangup\t\t= ehv_bc_tty_hangup,\n};\n\n \nstatic int ehv_bc_tty_port_activate(struct tty_port *port,\n\t\t\t\t    struct tty_struct *ttys)\n{\n\tstruct ehv_bc_data *bc = container_of(port, struct ehv_bc_data, port);\n\tint ret;\n\n\tttys->driver_data = bc;\n\n\tret = request_irq(bc->rx_irq, ehv_bc_tty_rx_isr, 0, \"ehv-bc\", bc);\n\tif (ret < 0) {\n\t\tdev_err(bc->dev, \"could not request rx irq %u (ret=%i)\\n\",\n\t\t       bc->rx_irq, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tbc->tx_irq_enabled = 1;\n\n\tret = request_irq(bc->tx_irq, ehv_bc_tty_tx_isr, 0, \"ehv-bc\", bc);\n\tif (ret < 0) {\n\t\tdev_err(bc->dev, \"could not request tx irq %u (ret=%i)\\n\",\n\t\t       bc->tx_irq, ret);\n\t\tfree_irq(bc->rx_irq, bc);\n\t\treturn ret;\n\t}\n\n\t \n\tdisable_tx_interrupt(bc);\n\n\treturn 0;\n}\n\nstatic void ehv_bc_tty_port_shutdown(struct tty_port *port)\n{\n\tstruct ehv_bc_data *bc = container_of(port, struct ehv_bc_data, port);\n\n\tfree_irq(bc->tx_irq, bc);\n\tfree_irq(bc->rx_irq, bc);\n}\n\nstatic const struct tty_port_operations ehv_bc_tty_port_ops = {\n\t.activate = ehv_bc_tty_port_activate,\n\t.shutdown = ehv_bc_tty_port_shutdown,\n};\n\nstatic int ehv_bc_tty_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct ehv_bc_data *bc;\n\tconst uint32_t *iprop;\n\tunsigned int handle;\n\tint ret;\n\tstatic unsigned int index = 1;\n\tunsigned int i;\n\n\tiprop = of_get_property(np, \"hv-handle\", NULL);\n\tif (!iprop) {\n\t\tdev_err(&pdev->dev, \"no 'hv-handle' property in %pOFn node\\n\",\n\t\t\tnp);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\thandle = be32_to_cpu(*iprop);\n\ti = (handle == stdout_bc) ? 0 : index++;\n\tbc = &bcs[i];\n\n\tbc->handle = handle;\n\tbc->head = 0;\n\tbc->tail = 0;\n\tspin_lock_init(&bc->lock);\n\n\tbc->rx_irq = irq_of_parse_and_map(np, 0);\n\tbc->tx_irq = irq_of_parse_and_map(np, 1);\n\tif (!bc->rx_irq || !bc->tx_irq) {\n\t\tdev_err(&pdev->dev, \"no 'interrupts' property in %pOFn node\\n\",\n\t\t\tnp);\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\ttty_port_init(&bc->port);\n\tbc->port.ops = &ehv_bc_tty_port_ops;\n\n\tbc->dev = tty_port_register_device(&bc->port, ehv_bc_driver, i,\n\t\t\t&pdev->dev);\n\tif (IS_ERR(bc->dev)) {\n\t\tret = PTR_ERR(bc->dev);\n\t\tdev_err(&pdev->dev, \"could not register tty (ret=%i)\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, bc);\n\n\tdev_info(&pdev->dev, \"registered /dev/%s%u for byte channel %u\\n\",\n\t\tehv_bc_driver->name, i, bc->handle);\n\n\treturn 0;\n\nerror:\n\ttty_port_destroy(&bc->port);\n\tirq_dispose_mapping(bc->tx_irq);\n\tirq_dispose_mapping(bc->rx_irq);\n\n\tmemset(bc, 0, sizeof(struct ehv_bc_data));\n\treturn ret;\n}\n\nstatic const struct of_device_id ehv_bc_tty_of_ids[] = {\n\t{ .compatible = \"epapr,hv-byte-channel\" },\n\t{}\n};\n\nstatic struct platform_driver ehv_bc_tty_driver = {\n\t.driver = {\n\t\t.name = \"ehv-bc\",\n\t\t.of_match_table = ehv_bc_tty_of_ids,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= ehv_bc_tty_probe,\n};\n\n \nstatic int __init ehv_bc_init(void)\n{\n\tstruct tty_driver *driver;\n\tstruct device_node *np;\n\tunsigned int count = 0;  \n\tint ret;\n\n\tpr_info(\"ePAPR hypervisor byte channel driver\\n\");\n\n\t \n\tfor_each_compatible_node(np, NULL, \"epapr,hv-byte-channel\")\n\t\tcount++;\n\n\tif (!count)\n\t\treturn -ENODEV;\n\n\t \n\tbcs = kcalloc(count, sizeof(struct ehv_bc_data), GFP_KERNEL);\n\tif (!bcs)\n\t\treturn -ENOMEM;\n\n\tdriver = tty_alloc_driver(count, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(driver)) {\n\t\tret = PTR_ERR(driver);\n\t\tgoto err_free_bcs;\n\t}\n\n\tdriver->driver_name = \"ehv-bc\";\n\tdriver->name = ehv_bc_console.name;\n\tdriver->type = TTY_DRIVER_TYPE_CONSOLE;\n\tdriver->subtype = SYSTEM_TYPE_CONSOLE;\n\tdriver->init_termios = tty_std_termios;\n\ttty_set_operations(driver, &ehv_bc_ops);\n\n\tret = tty_register_driver(driver);\n\tif (ret) {\n\t\tpr_err(\"ehv-bc: could not register tty driver (ret=%i)\\n\", ret);\n\t\tgoto err_tty_driver_kref_put;\n\t}\n\n\tehv_bc_driver = driver;\n\n\tret = platform_driver_register(&ehv_bc_tty_driver);\n\tif (ret) {\n\t\tpr_err(\"ehv-bc: could not register platform driver (ret=%i)\\n\",\n\t\t       ret);\n\t\tgoto err_deregister_tty_driver;\n\t}\n\n\treturn 0;\n\nerr_deregister_tty_driver:\n\tehv_bc_driver = NULL;\n\ttty_unregister_driver(driver);\nerr_tty_driver_kref_put:\n\ttty_driver_kref_put(driver);\nerr_free_bcs:\n\tkfree(bcs);\n\n\treturn ret;\n}\ndevice_initcall(ehv_bc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}