{
  "module_name": "vcc.c",
  "hash_id": "62e803dbfa4940d10ae21686757e3d0dd598bfc9e9f20442631fe57db141a3aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/vcc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/termios_internal.h>\n#include <asm/vio.h>\n#include <asm/ldc.h>\n\nMODULE_DESCRIPTION(\"Sun LDOM virtual console concentrator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.1\");\n\nstruct vcc_port {\n\tstruct vio_driver_state vio;\n\n\tspinlock_t lock;\n\tchar *domain;\n\tstruct tty_struct *tty;\t \n\tunsigned long index;\t \n\n\tu64 refcnt;\n\tbool excl_locked;\n\n\tbool removed;\n\n\t \n\tsize_t chars_in_buffer;\n\tstruct vio_vcc buffer;\n\n\tstruct timer_list rx_timer;\n\tstruct timer_list tx_timer;\n};\n\n \n#define VCC_REF_DELAY\t\t100\n\n#define VCC_MAX_PORTS\t\t1024\n#define VCC_MINOR_START\t\t0\t \n#define VCC_BUFF_LEN\t\tVIO_VCC_MTU_SIZE\n\n#define VCC_CTL_BREAK\t\t-1\n#define VCC_CTL_HUP\t\t-2\n\nstatic struct tty_driver *vcc_tty_driver;\n\nstatic struct vcc_port *vcc_table[VCC_MAX_PORTS];\nstatic DEFINE_SPINLOCK(vcc_table_lock);\n\nstatic unsigned int vcc_dbg;\nstatic unsigned int vcc_dbg_ldc;\nstatic unsigned int vcc_dbg_vio;\n\nmodule_param(vcc_dbg, uint, 0664);\nmodule_param(vcc_dbg_ldc, uint, 0664);\nmodule_param(vcc_dbg_vio, uint, 0664);\n\n#define VCC_DBG_DRV\t0x1\n#define VCC_DBG_LDC\t0x2\n#define VCC_DBG_PKT\t0x4\n\n#define vccdbg(f, a...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (vcc_dbg & VCC_DBG_DRV)\t\t\t\\\n\t\t\tpr_info(f, ## a);\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define vccdbgl(l)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (vcc_dbg & VCC_DBG_LDC)\t\t\t\\\n\t\t\tldc_print(l);\t\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define vccdbgp(pkt)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (vcc_dbg & VCC_DBG_PKT) {\t\t\t\\\n\t\t\tint i;\t\t\t\t\t\\\n\t\t\tfor (i = 0; i < pkt.tag.stype; i++)\t\\\n\t\t\t\tpr_info(\"[%c]\", pkt.data[i]);\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n \nstatic const struct ktermios vcc_tty_termios = {\n\t.c_iflag = IGNBRK | IGNPAR,\n\t.c_oflag = OPOST,\n\t.c_cflag = B38400 | CS8 | CREAD | HUPCL,\n\t.c_cc = INIT_C_CC,\n\t.c_ispeed = 38400,\n\t.c_ospeed = 38400\n};\n\n \nstatic int vcc_table_add(struct vcc_port *port)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&vcc_table_lock, flags);\n\tfor (i = VCC_MINOR_START; i < VCC_MAX_PORTS; i++) {\n\t\tif (!vcc_table[i]) {\n\t\t\tvcc_table[i] = port;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vcc_table_lock, flags);\n\n\tif (i < VCC_MAX_PORTS)\n\t\treturn i;\n\telse\n\t\treturn -1;\n}\n\n \nstatic void vcc_table_remove(unsigned long index)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON(index >= VCC_MAX_PORTS))\n\t\treturn;\n\n\tspin_lock_irqsave(&vcc_table_lock, flags);\n\tvcc_table[index] = NULL;\n\tspin_unlock_irqrestore(&vcc_table_lock, flags);\n}\n\n \nstatic struct vcc_port *vcc_get(unsigned long index, bool excl)\n{\n\tstruct vcc_port *port;\n\tunsigned long flags;\n\ntry_again:\n\tspin_lock_irqsave(&vcc_table_lock, flags);\n\n\tport = vcc_table[index];\n\tif (!port) {\n\t\tspin_unlock_irqrestore(&vcc_table_lock, flags);\n\t\treturn NULL;\n\t}\n\n\tif (!excl) {\n\t\tif (port->excl_locked) {\n\t\t\tspin_unlock_irqrestore(&vcc_table_lock, flags);\n\t\t\tudelay(VCC_REF_DELAY);\n\t\t\tgoto try_again;\n\t\t}\n\t\tport->refcnt++;\n\t\tspin_unlock_irqrestore(&vcc_table_lock, flags);\n\t\treturn port;\n\t}\n\n\tif (port->refcnt) {\n\t\tspin_unlock_irqrestore(&vcc_table_lock, flags);\n\t\t \n\t\tudelay(VCC_REF_DELAY/2);\n\t\tgoto try_again;\n\t}\n\n\tport->refcnt++;\n\tport->excl_locked = true;\n\tspin_unlock_irqrestore(&vcc_table_lock, flags);\n\n\treturn port;\n}\n\n \nstatic void vcc_put(struct vcc_port *port, bool excl)\n{\n\tunsigned long flags;\n\n\tif (!port)\n\t\treturn;\n\n\tspin_lock_irqsave(&vcc_table_lock, flags);\n\n\t \n\tif (WARN_ON((excl && !port->excl_locked) ||\n\t\t    (!excl && port->excl_locked)))\n\t\tgoto done;\n\n\tport->refcnt--;\n\n\tif (excl)\n\t\tport->excl_locked = false;\n\ndone:\n\tspin_unlock_irqrestore(&vcc_table_lock, flags);\n}\n\n \nstatic struct vcc_port *vcc_get_ne(unsigned long index)\n{\n\tstruct vcc_port *port;\n\n\tport = vcc_get(index, false);\n\n\tif (port && port->removed) {\n\t\tvcc_put(port, false);\n\t\treturn NULL;\n\t}\n\n\treturn port;\n}\n\nstatic void vcc_kick_rx(struct vcc_port *port)\n{\n\tstruct vio_driver_state *vio = &port->vio;\n\n\tassert_spin_locked(&port->lock);\n\n\tif (!timer_pending(&port->rx_timer) && !port->removed) {\n\t\tdisable_irq_nosync(vio->vdev->rx_irq);\n\t\tport->rx_timer.expires = (jiffies + 1);\n\t\tadd_timer(&port->rx_timer);\n\t}\n}\n\nstatic void vcc_kick_tx(struct vcc_port *port)\n{\n\tassert_spin_locked(&port->lock);\n\n\tif (!timer_pending(&port->tx_timer) && !port->removed) {\n\t\tport->tx_timer.expires = (jiffies + 1);\n\t\tadd_timer(&port->tx_timer);\n\t}\n}\n\nstatic int vcc_rx_check(struct tty_struct *tty, int size)\n{\n\tif (WARN_ON(!tty || !tty->port))\n\t\treturn 1;\n\n\t \n\tif (test_bit(TTY_THROTTLED, &tty->flags) ||\n\t    (tty_buffer_request_room(tty->port, VCC_BUFF_LEN) < VCC_BUFF_LEN))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int vcc_rx(struct tty_struct *tty, char *buf, int size)\n{\n\tint len = 0;\n\n\tif (WARN_ON(!tty || !tty->port))\n\t\treturn len;\n\n\tlen = tty_insert_flip_string(tty->port, buf, size);\n\tif (len)\n\t\ttty_flip_buffer_push(tty->port);\n\n\treturn len;\n}\n\nstatic int vcc_ldc_read(struct vcc_port *port)\n{\n\tstruct vio_driver_state *vio = &port->vio;\n\tstruct tty_struct *tty;\n\tstruct vio_vcc pkt;\n\tint rv = 0;\n\n\ttty = port->tty;\n\tif (!tty) {\n\t\trv = ldc_rx_reset(vio->lp);\n\t\tvccdbg(\"VCC: reset rx q: rv=%d\\n\", rv);\n\t\tgoto done;\n\t}\n\n\t \n\twhile (1) {\n\t\tif (!vcc_rx_check(tty, VIO_VCC_MTU_SIZE)) {\n\t\t\tvcc_kick_rx(port);\n\t\t\tbreak;\n\t\t}\n\n\t\tvccdbgl(vio->lp);\n\n\t\trv = ldc_read(vio->lp, &pkt, sizeof(pkt));\n\t\tif (rv <= 0)\n\t\t\tbreak;\n\n\t\tvccdbg(\"VCC: ldc_read()=%d\\n\", rv);\n\t\tvccdbg(\"TAG [%02x:%02x:%04x:%08x]\\n\",\n\t\t       pkt.tag.type, pkt.tag.stype,\n\t\t       pkt.tag.stype_env, pkt.tag.sid);\n\n\t\tif (pkt.tag.type == VIO_TYPE_DATA) {\n\t\t\tvccdbgp(pkt);\n\t\t\t \n\t\t\tvcc_rx(tty, pkt.data, pkt.tag.stype);\n\t\t} else {\n\t\t\tpr_err(\"VCC: unknown msg [%02x:%02x:%04x:%08x]\\n\",\n\t\t\t       pkt.tag.type, pkt.tag.stype,\n\t\t\t       pkt.tag.stype_env, pkt.tag.sid);\n\t\t\trv = -ECONNRESET;\n\t\t\tbreak;\n\t\t}\n\n\t\tWARN_ON(rv != LDC_PACKET_SIZE);\n\t}\n\ndone:\n\treturn rv;\n}\n\nstatic void vcc_rx_timer(struct timer_list *t)\n{\n\tstruct vcc_port *port = from_timer(port, t, rx_timer);\n\tstruct vio_driver_state *vio;\n\tunsigned long flags;\n\tint rv;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tport->rx_timer.expires = 0;\n\n\tvio = &port->vio;\n\n\tenable_irq(vio->vdev->rx_irq);\n\n\tif (!port->tty || port->removed)\n\t\tgoto done;\n\n\trv = vcc_ldc_read(port);\n\tif (rv == -ECONNRESET)\n\t\tvio_conn_reset(vio);\n\ndone:\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tvcc_put(port, false);\n}\n\nstatic void vcc_tx_timer(struct timer_list *t)\n{\n\tstruct vcc_port *port = from_timer(port, t, tx_timer);\n\tstruct vio_vcc *pkt;\n\tunsigned long flags;\n\tsize_t tosend = 0;\n\tint rv;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tport->tx_timer.expires = 0;\n\n\tif (!port->tty || port->removed)\n\t\tgoto done;\n\n\ttosend = min(VCC_BUFF_LEN, port->chars_in_buffer);\n\tif (!tosend)\n\t\tgoto done;\n\n\tpkt = &port->buffer;\n\tpkt->tag.type = VIO_TYPE_DATA;\n\tpkt->tag.stype = tosend;\n\tvccdbgl(port->vio.lp);\n\n\trv = ldc_write(port->vio.lp, pkt, (VIO_TAG_SIZE + tosend));\n\tWARN_ON(!rv);\n\n\tif (rv < 0) {\n\t\tvccdbg(\"VCC: ldc_write()=%d\\n\", rv);\n\t\tvcc_kick_tx(port);\n\t} else {\n\t\tstruct tty_struct *tty = port->tty;\n\n\t\tport->chars_in_buffer = 0;\n\t\tif (tty)\n\t\t\ttty_wakeup(tty);\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&port->lock, flags);\n\tvcc_put(port, false);\n}\n\n \nstatic void vcc_event(void *arg, int event)\n{\n\tstruct vio_driver_state *vio;\n\tstruct vcc_port *port;\n\tunsigned long flags;\n\tint rv;\n\n\tport = arg;\n\tvio = &port->vio;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tswitch (event) {\n\tcase LDC_EVENT_RESET:\n\tcase LDC_EVENT_UP:\n\t\tvio_link_state_change(vio, event);\n\t\tbreak;\n\n\tcase LDC_EVENT_DATA_READY:\n\t\trv = vcc_ldc_read(port);\n\t\tif (rv == -ECONNRESET)\n\t\t\tvio_conn_reset(vio);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"VCC: unexpected LDC event(%d)\\n\", event);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic struct ldc_channel_config vcc_ldc_cfg = {\n\t.event\t\t= vcc_event,\n\t.mtu\t\t= VIO_VCC_MTU_SIZE,\n\t.mode\t\t= LDC_MODE_RAW,\n\t.debug\t\t= 0,\n};\n\n \nstatic struct vio_version vcc_versions[] = {\n\t{ .major = 1, .minor = 0 },\n};\n\nstatic struct tty_port_operations vcc_port_ops = { 0 };\n\nstatic ssize_t domain_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct vcc_port *port;\n\tint rv;\n\n\tport = dev_get_drvdata(dev);\n\tif (!port)\n\t\treturn -ENODEV;\n\n\trv = scnprintf(buf, PAGE_SIZE, \"%s\\n\", port->domain);\n\n\treturn rv;\n}\n\nstatic int vcc_send_ctl(struct vcc_port *port, int ctl)\n{\n\tstruct vio_vcc pkt;\n\tint rv;\n\n\tpkt.tag.type = VIO_TYPE_CTRL;\n\tpkt.tag.sid = ctl;\n\tpkt.tag.stype = 0;\n\n\trv = ldc_write(port->vio.lp, &pkt, sizeof(pkt.tag));\n\tWARN_ON(!rv);\n\tvccdbg(\"VCC: ldc_write(%ld)=%d\\n\", sizeof(pkt.tag), rv);\n\n\treturn rv;\n}\n\nstatic ssize_t break_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct vcc_port *port;\n\tunsigned long flags;\n\tint rv = count;\n\tint brk;\n\n\tport = dev_get_drvdata(dev);\n\tif (!port)\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (sscanf(buf, \"%ud\", &brk) != 1 || brk != 1)\n\t\trv = -EINVAL;\n\telse if (vcc_send_ctl(port, VCC_CTL_BREAK) < 0)\n\t\tvcc_kick_tx(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn rv;\n}\n\nstatic DEVICE_ATTR_ADMIN_RO(domain);\nstatic DEVICE_ATTR_WO(break);\n\nstatic struct attribute *vcc_sysfs_entries[] = {\n\t&dev_attr_domain.attr,\n\t&dev_attr_break.attr,\n\tNULL\n};\n\nstatic struct attribute_group vcc_attribute_group = {\n\t.name = NULL,\n\t.attrs = vcc_sysfs_entries,\n};\n\n \nstatic int vcc_probe(struct vio_dev *vdev, const struct vio_device_id *id)\n{\n\tstruct mdesc_handle *hp;\n\tstruct vcc_port *port;\n\tstruct device *dev;\n\tconst char *domain;\n\tchar *name;\n\tu64 node;\n\tint rv;\n\n\tvccdbg(\"VCC: name=%s\\n\", dev_name(&vdev->dev));\n\n\tif (!vcc_tty_driver) {\n\t\tpr_err(\"VCC: TTY driver not registered\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tport = kzalloc(sizeof(struct vcc_port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tname = kstrdup(dev_name(&vdev->dev), GFP_KERNEL);\n\tif (!name) {\n\t\trv = -ENOMEM;\n\t\tgoto free_port;\n\t}\n\n\trv = vio_driver_init(&port->vio, vdev, VDEV_CONSOLE_CON, vcc_versions,\n\t\t\t     ARRAY_SIZE(vcc_versions), NULL, name);\n\tif (rv)\n\t\tgoto free_name;\n\n\tport->vio.debug = vcc_dbg_vio;\n\tvcc_ldc_cfg.debug = vcc_dbg_ldc;\n\n\trv = vio_ldc_alloc(&port->vio, &vcc_ldc_cfg, port);\n\tif (rv)\n\t\tgoto free_name;\n\n\tspin_lock_init(&port->lock);\n\n\tport->index = vcc_table_add(port);\n\tif (port->index == -1) {\n\t\tpr_err(\"VCC: no more TTY indices left for allocation\\n\");\n\t\trv = -ENOMEM;\n\t\tgoto free_ldc;\n\t}\n\n\t \n\tdev = tty_register_device(vcc_tty_driver, port->index, &vdev->dev);\n\tif (IS_ERR(dev)) {\n\t\trv = PTR_ERR(dev);\n\t\tgoto free_table;\n\t}\n\n\thp = mdesc_grab();\n\n\tnode = vio_vdev_node(hp, vdev);\n\tif (node == MDESC_NODE_NULL) {\n\t\trv = -ENXIO;\n\t\tmdesc_release(hp);\n\t\tgoto unreg_tty;\n\t}\n\n\tdomain = mdesc_get_property(hp, node, \"vcc-domain-name\", NULL);\n\tif (!domain) {\n\t\trv = -ENXIO;\n\t\tmdesc_release(hp);\n\t\tgoto unreg_tty;\n\t}\n\tport->domain = kstrdup(domain, GFP_KERNEL);\n\tif (!port->domain) {\n\t\trv = -ENOMEM;\n\t\tgoto unreg_tty;\n\t}\n\n\n\tmdesc_release(hp);\n\n\trv = sysfs_create_group(&vdev->dev.kobj, &vcc_attribute_group);\n\tif (rv)\n\t\tgoto free_domain;\n\n\ttimer_setup(&port->rx_timer, vcc_rx_timer, 0);\n\ttimer_setup(&port->tx_timer, vcc_tx_timer, 0);\n\n\tdev_set_drvdata(&vdev->dev, port);\n\n\t \n\tdisable_irq_nosync(vdev->rx_irq);\n\tvio_port_up(&port->vio);\n\tenable_irq(vdev->rx_irq);\n\n\treturn 0;\n\nfree_domain:\n\tkfree(port->domain);\nunreg_tty:\n\ttty_unregister_device(vcc_tty_driver, port->index);\nfree_table:\n\tvcc_table_remove(port->index);\nfree_ldc:\n\tvio_ldc_free(&port->vio);\nfree_name:\n\tkfree(name);\nfree_port:\n\tkfree(port);\n\n\treturn rv;\n}\n\n \nstatic void vcc_remove(struct vio_dev *vdev)\n{\n\tstruct vcc_port *port = dev_get_drvdata(&vdev->dev);\n\n\tdel_timer_sync(&port->rx_timer);\n\tdel_timer_sync(&port->tx_timer);\n\n\t \n\tif (port->tty)\n\t\ttty_vhangup(port->tty);\n\n\t \n\tvcc_get(port->index, true);\n\n\ttty_unregister_device(vcc_tty_driver, port->index);\n\n\tdel_timer_sync(&port->vio.timer);\n\tvio_ldc_free(&port->vio);\n\tsysfs_remove_group(&vdev->dev.kobj, &vcc_attribute_group);\n\tdev_set_drvdata(&vdev->dev, NULL);\n\tif (port->tty) {\n\t\tport->removed = true;\n\t\tvcc_put(port, true);\n\t} else {\n\t\tvcc_table_remove(port->index);\n\n\t\tkfree(port->vio.name);\n\t\tkfree(port->domain);\n\t\tkfree(port);\n\t}\n}\n\nstatic const struct vio_device_id vcc_match[] = {\n\t{\n\t\t.type = \"vcc-port\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(vio, vcc_match);\n\nstatic struct vio_driver vcc_driver = {\n\t.id_table\t= vcc_match,\n\t.probe\t\t= vcc_probe,\n\t.remove\t\t= vcc_remove,\n\t.name\t\t= \"vcc\",\n};\n\nstatic int vcc_open(struct tty_struct *tty, struct file *vcc_file)\n{\n\tstruct vcc_port *port;\n\n\tif (tty->count > 1)\n\t\treturn -EBUSY;\n\n\tport = vcc_get_ne(tty->index);\n\tif (unlikely(!port)) {\n\t\tpr_err(\"VCC: open: Failed to find VCC port\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (unlikely(!port->vio.lp)) {\n\t\tpr_err(\"VCC: open: LDC channel not configured\\n\");\n\t\tvcc_put(port, false);\n\t\treturn -EPIPE;\n\t}\n\tvccdbgl(port->vio.lp);\n\n\tvcc_put(port, false);\n\n\tif (unlikely(!tty->port)) {\n\t\tpr_err(\"VCC: open: TTY port not found\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (unlikely(!tty->port->ops)) {\n\t\tpr_err(\"VCC: open: TTY ops not defined\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn tty_port_open(tty->port, tty, vcc_file);\n}\n\nstatic void vcc_close(struct tty_struct *tty, struct file *vcc_file)\n{\n\tif (unlikely(tty->count > 1))\n\t\treturn;\n\n\tif (unlikely(!tty->port)) {\n\t\tpr_err(\"VCC: close: TTY port not found\\n\");\n\t\treturn;\n\t}\n\n\ttty_port_close(tty->port, tty, vcc_file);\n}\n\nstatic void vcc_ldc_hup(struct vcc_port *port)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (vcc_send_ctl(port, VCC_CTL_HUP) < 0)\n\t\tvcc_kick_tx(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void vcc_hangup(struct tty_struct *tty)\n{\n\tstruct vcc_port *port;\n\n\tport = vcc_get_ne(tty->index);\n\tif (unlikely(!port)) {\n\t\tpr_err(\"VCC: hangup: Failed to find VCC port\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(!tty->port)) {\n\t\tpr_err(\"VCC: hangup: TTY port not found\\n\");\n\t\tvcc_put(port, false);\n\t\treturn;\n\t}\n\n\tvcc_ldc_hup(port);\n\n\tvcc_put(port, false);\n\n\ttty_port_hangup(tty->port);\n}\n\nstatic ssize_t vcc_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tstruct vcc_port *port;\n\tstruct vio_vcc *pkt;\n\tunsigned long flags;\n\tsize_t total_sent = 0;\n\tsize_t tosend = 0;\n\tint rv = -EINVAL;\n\n\tport = vcc_get_ne(tty->index);\n\tif (unlikely(!port)) {\n\t\tpr_err(\"VCC: write: Failed to find VCC port\");\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tpkt = &port->buffer;\n\tpkt->tag.type = VIO_TYPE_DATA;\n\n\twhile (count > 0) {\n\t\t \n\t\ttosend = min_t(size_t, count,\n\t\t\t       (VCC_BUFF_LEN - port->chars_in_buffer));\n\n\t\tif (!tosend)\n\t\t\tbreak;\n\n\t\tmemcpy(&pkt->data[port->chars_in_buffer], &buf[total_sent],\n\t\t       tosend);\n\t\tport->chars_in_buffer += tosend;\n\t\tpkt->tag.stype = tosend;\n\n\t\tvccdbg(\"TAG [%02x:%02x:%04x:%08x]\\n\", pkt->tag.type,\n\t\t       pkt->tag.stype, pkt->tag.stype_env, pkt->tag.sid);\n\t\tvccdbg(\"DATA [%s]\\n\", pkt->data);\n\t\tvccdbgl(port->vio.lp);\n\n\t\t \n\t\trv = ldc_write(port->vio.lp, pkt, (VIO_TAG_SIZE + tosend));\n\t\tvccdbg(\"VCC: write: ldc_write(%zu)=%d\\n\",\n\t\t       (VIO_TAG_SIZE + tosend), rv);\n\n\t\ttotal_sent += tosend;\n\t\tcount -= tosend;\n\t\tif (rv < 0) {\n\t\t\tvcc_kick_tx(port);\n\t\t\tbreak;\n\t\t}\n\n\t\tport->chars_in_buffer = 0;\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tvcc_put(port, false);\n\n\tvccdbg(\"VCC: write: total=%zu rv=%d\", total_sent, rv);\n\n\treturn total_sent ? total_sent : rv;\n}\n\nstatic unsigned int vcc_write_room(struct tty_struct *tty)\n{\n\tstruct vcc_port *port;\n\tunsigned int num;\n\n\tport = vcc_get_ne(tty->index);\n\tif (unlikely(!port)) {\n\t\tpr_err(\"VCC: write_room: Failed to find VCC port\\n\");\n\t\treturn 0;\n\t}\n\n\tnum = VCC_BUFF_LEN - port->chars_in_buffer;\n\n\tvcc_put(port, false);\n\n\treturn num;\n}\n\nstatic unsigned int vcc_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct vcc_port *port;\n\tunsigned int num;\n\n\tport = vcc_get_ne(tty->index);\n\tif (unlikely(!port)) {\n\t\tpr_err(\"VCC: chars_in_buffer: Failed to find VCC port\\n\");\n\t\treturn 0;\n\t}\n\n\tnum = port->chars_in_buffer;\n\n\tvcc_put(port, false);\n\n\treturn num;\n}\n\nstatic int vcc_break_ctl(struct tty_struct *tty, int state)\n{\n\tstruct vcc_port *port;\n\tunsigned long flags;\n\n\tport = vcc_get_ne(tty->index);\n\tif (unlikely(!port)) {\n\t\tpr_err(\"VCC: break_ctl: Failed to find VCC port\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (state == 0) {\n\t\tvcc_put(port, false);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (vcc_send_ctl(port, VCC_CTL_BREAK) < 0)\n\t\tvcc_kick_tx(port);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tvcc_put(port, false);\n\n\treturn 0;\n}\n\nstatic int vcc_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct vcc_port *port_vcc;\n\tstruct tty_port *port_tty;\n\tint ret;\n\n\tif (tty->index >= VCC_MAX_PORTS)\n\t\treturn -EINVAL;\n\n\tret = tty_standard_install(driver, tty);\n\tif (ret)\n\t\treturn ret;\n\n\tport_tty = kzalloc(sizeof(struct tty_port), GFP_KERNEL);\n\tif (!port_tty)\n\t\treturn -ENOMEM;\n\n\tport_vcc = vcc_get(tty->index, true);\n\tif (!port_vcc) {\n\t\tpr_err(\"VCC: install: Failed to find VCC port\\n\");\n\t\ttty->port = NULL;\n\t\tkfree(port_tty);\n\t\treturn -ENODEV;\n\t}\n\n\ttty_port_init(port_tty);\n\tport_tty->ops = &vcc_port_ops;\n\ttty->port = port_tty;\n\n\tport_vcc->tty = tty;\n\n\tvcc_put(port_vcc, true);\n\n\treturn 0;\n}\n\nstatic void vcc_cleanup(struct tty_struct *tty)\n{\n\tstruct vcc_port *port;\n\n\tport = vcc_get(tty->index, true);\n\tif (port) {\n\t\tport->tty = NULL;\n\n\t\tif (port->removed) {\n\t\t\tvcc_table_remove(tty->index);\n\t\t\tkfree(port->vio.name);\n\t\t\tkfree(port->domain);\n\t\t\tkfree(port);\n\t\t} else {\n\t\t\tvcc_put(port, true);\n\t\t}\n\t}\n\n\ttty_port_destroy(tty->port);\n\tkfree(tty->port);\n\ttty->port = NULL;\n}\n\nstatic const struct tty_operations vcc_ops = {\n\t.open\t\t\t= vcc_open,\n\t.close\t\t\t= vcc_close,\n\t.hangup\t\t\t= vcc_hangup,\n\t.write\t\t\t= vcc_write,\n\t.write_room\t\t= vcc_write_room,\n\t.chars_in_buffer\t= vcc_chars_in_buffer,\n\t.break_ctl\t\t= vcc_break_ctl,\n\t.install\t\t= vcc_install,\n\t.cleanup\t\t= vcc_cleanup,\n};\n\n#define VCC_TTY_FLAGS   (TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_REAL_RAW)\n\nstatic int vcc_tty_init(void)\n{\n\tint rv;\n\n\tvcc_tty_driver = tty_alloc_driver(VCC_MAX_PORTS, VCC_TTY_FLAGS);\n\tif (IS_ERR(vcc_tty_driver)) {\n\t\tpr_err(\"VCC: TTY driver alloc failed\\n\");\n\t\treturn PTR_ERR(vcc_tty_driver);\n\t}\n\n\tvcc_tty_driver->driver_name = \"vcc\";\n\tvcc_tty_driver->name = \"vcc\";\n\n\tvcc_tty_driver->minor_start = VCC_MINOR_START;\n\tvcc_tty_driver->type = TTY_DRIVER_TYPE_SYSTEM;\n\tvcc_tty_driver->init_termios = vcc_tty_termios;\n\n\ttty_set_operations(vcc_tty_driver, &vcc_ops);\n\n\trv = tty_register_driver(vcc_tty_driver);\n\tif (rv) {\n\t\tpr_err(\"VCC: TTY driver registration failed\\n\");\n\t\ttty_driver_kref_put(vcc_tty_driver);\n\t\tvcc_tty_driver = NULL;\n\t\treturn rv;\n\t}\n\n\tvccdbg(\"VCC: TTY driver registered\\n\");\n\n\treturn 0;\n}\n\nstatic void vcc_tty_exit(void)\n{\n\ttty_unregister_driver(vcc_tty_driver);\n\ttty_driver_kref_put(vcc_tty_driver);\n\tvccdbg(\"VCC: TTY driver unregistered\\n\");\n\n\tvcc_tty_driver = NULL;\n}\n\nstatic int __init vcc_init(void)\n{\n\tint rv;\n\n\trv = vcc_tty_init();\n\tif (rv) {\n\t\tpr_err(\"VCC: TTY init failed\\n\");\n\t\treturn rv;\n\t}\n\n\trv = vio_register_driver(&vcc_driver);\n\tif (rv) {\n\t\tpr_err(\"VCC: VIO driver registration failed\\n\");\n\t\tvcc_tty_exit();\n\t} else {\n\t\tvccdbg(\"VCC: VIO driver registered successfully\\n\");\n\t}\n\n\treturn rv;\n}\n\nstatic void __exit vcc_exit(void)\n{\n\tvio_unregister_driver(&vcc_driver);\n\tvccdbg(\"VCC: VIO driver unregistered\\n\");\n\tvcc_tty_exit();\n\tvccdbg(\"VCC: TTY driver unregistered\\n\");\n}\n\nmodule_init(vcc_init);\nmodule_exit(vcc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}