{
  "module_name": "core.c",
  "hash_id": "9c696db63a9ba071b4c1194ee5598a655e8d68375447f9f30267ecc8fc92f212",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serdev/core.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/errno.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/sched.h>\n#include <linux/serdev.h>\n#include <linux/slab.h>\n#include <linux/platform_data/x86/apple.h>\n\nstatic bool is_registered;\nstatic DEFINE_IDA(ctrl_ida);\n\nstatic ssize_t modalias_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint len;\n\n\tlen = acpi_device_modalias(dev, buf, PAGE_SIZE - 1);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\treturn of_device_modalias(dev, buf, PAGE_SIZE);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *serdev_device_attrs[] = {\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(serdev_device);\n\nstatic int serdev_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tint rc;\n\n\t \n\n\trc = acpi_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\treturn of_device_uevent_modalias(dev, env);\n}\n\nstatic void serdev_device_release(struct device *dev)\n{\n\tstruct serdev_device *serdev = to_serdev_device(dev);\n\tkfree(serdev);\n}\n\nstatic const struct device_type serdev_device_type = {\n\t.groups\t\t= serdev_device_groups,\n\t.uevent\t\t= serdev_device_uevent,\n\t.release\t= serdev_device_release,\n};\n\nstatic bool is_serdev_device(const struct device *dev)\n{\n\treturn dev->type == &serdev_device_type;\n}\n\nstatic void serdev_ctrl_release(struct device *dev)\n{\n\tstruct serdev_controller *ctrl = to_serdev_controller(dev);\n\tida_simple_remove(&ctrl_ida, ctrl->nr);\n\tkfree(ctrl);\n}\n\nstatic const struct device_type serdev_ctrl_type = {\n\t.release\t= serdev_ctrl_release,\n};\n\nstatic int serdev_device_match(struct device *dev, struct device_driver *drv)\n{\n\tif (!is_serdev_device(dev))\n\t\treturn 0;\n\n\t \n\tif (acpi_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\treturn of_driver_match_device(dev, drv);\n}\n\n \nint serdev_device_add(struct serdev_device *serdev)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\tstruct device *parent = serdev->dev.parent;\n\tint err;\n\n\tdev_set_name(&serdev->dev, \"%s-%d\", dev_name(parent), serdev->nr);\n\n\t \n\tif (ctrl->serdev) {\n\t\tdev_err(&serdev->dev, \"controller busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\tctrl->serdev = serdev;\n\n\terr = device_add(&serdev->dev);\n\tif (err < 0) {\n\t\tdev_err(&serdev->dev, \"Can't add %s, status %pe\\n\",\n\t\t\tdev_name(&serdev->dev), ERR_PTR(err));\n\t\tgoto err_clear_serdev;\n\t}\n\n\tdev_dbg(&serdev->dev, \"device %s registered\\n\", dev_name(&serdev->dev));\n\n\treturn 0;\n\nerr_clear_serdev:\n\tctrl->serdev = NULL;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(serdev_device_add);\n\n \nvoid serdev_device_remove(struct serdev_device *serdev)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tdevice_unregister(&serdev->dev);\n\tctrl->serdev = NULL;\n}\nEXPORT_SYMBOL_GPL(serdev_device_remove);\n\nint serdev_device_open(struct serdev_device *serdev)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\tint ret;\n\n\tif (!ctrl || !ctrl->ops->open)\n\t\treturn -EINVAL;\n\n\tret = ctrl->ops->open(ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_get_sync(&ctrl->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(&ctrl->dev);\n\t\tgoto err_close;\n\t}\n\n\treturn 0;\n\nerr_close:\n\tif (ctrl->ops->close)\n\t\tctrl->ops->close(ctrl);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(serdev_device_open);\n\nvoid serdev_device_close(struct serdev_device *serdev)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tif (!ctrl || !ctrl->ops->close)\n\t\treturn;\n\n\tpm_runtime_put(&ctrl->dev);\n\n\tctrl->ops->close(ctrl);\n}\nEXPORT_SYMBOL_GPL(serdev_device_close);\n\nstatic void devm_serdev_device_release(struct device *dev, void *dr)\n{\n\tserdev_device_close(*(struct serdev_device **)dr);\n}\n\nint devm_serdev_device_open(struct device *dev, struct serdev_device *serdev)\n{\n\tstruct serdev_device **dr;\n\tint ret;\n\n\tdr = devres_alloc(devm_serdev_device_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tret = serdev_device_open(serdev);\n\tif (ret) {\n\t\tdevres_free(dr);\n\t\treturn ret;\n\t}\n\n\t*dr = serdev;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_serdev_device_open);\n\nvoid serdev_device_write_wakeup(struct serdev_device *serdev)\n{\n\tcomplete(&serdev->write_comp);\n}\nEXPORT_SYMBOL_GPL(serdev_device_write_wakeup);\n\n \nint serdev_device_write_buf(struct serdev_device *serdev,\n\t\t\t    const unsigned char *buf, size_t count)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tif (!ctrl || !ctrl->ops->write_buf)\n\t\treturn -EINVAL;\n\n\treturn ctrl->ops->write_buf(ctrl, buf, count);\n}\nEXPORT_SYMBOL_GPL(serdev_device_write_buf);\n\n \nint serdev_device_write(struct serdev_device *serdev,\n\t\t\tconst unsigned char *buf, size_t count,\n\t\t\tlong timeout)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\tint written = 0;\n\tint ret;\n\n\tif (!ctrl || !ctrl->ops->write_buf || !serdev->ops->write_wakeup)\n\t\treturn -EINVAL;\n\n\tif (timeout == 0)\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\n\tmutex_lock(&serdev->write_lock);\n\tdo {\n\t\treinit_completion(&serdev->write_comp);\n\n\t\tret = ctrl->ops->write_buf(ctrl, buf, count);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\twritten += ret;\n\t\tbuf += ret;\n\t\tcount -= ret;\n\n\t\tif (count == 0)\n\t\t\tbreak;\n\n\t\ttimeout = wait_for_completion_interruptible_timeout(&serdev->write_comp,\n\t\t\t\t\t\t\t\t    timeout);\n\t} while (timeout > 0);\n\tmutex_unlock(&serdev->write_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (timeout <= 0 && written == 0) {\n\t\tif (timeout == -ERESTARTSYS)\n\t\t\treturn -ERESTARTSYS;\n\t\telse\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn written;\n}\nEXPORT_SYMBOL_GPL(serdev_device_write);\n\nvoid serdev_device_write_flush(struct serdev_device *serdev)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tif (!ctrl || !ctrl->ops->write_flush)\n\t\treturn;\n\n\tctrl->ops->write_flush(ctrl);\n}\nEXPORT_SYMBOL_GPL(serdev_device_write_flush);\n\nint serdev_device_write_room(struct serdev_device *serdev)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tif (!ctrl || !ctrl->ops->write_room)\n\t\treturn 0;\n\n\treturn serdev->ctrl->ops->write_room(ctrl);\n}\nEXPORT_SYMBOL_GPL(serdev_device_write_room);\n\nunsigned int serdev_device_set_baudrate(struct serdev_device *serdev, unsigned int speed)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tif (!ctrl || !ctrl->ops->set_baudrate)\n\t\treturn 0;\n\n\treturn ctrl->ops->set_baudrate(ctrl, speed);\n\n}\nEXPORT_SYMBOL_GPL(serdev_device_set_baudrate);\n\nvoid serdev_device_set_flow_control(struct serdev_device *serdev, bool enable)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tif (!ctrl || !ctrl->ops->set_flow_control)\n\t\treturn;\n\n\tctrl->ops->set_flow_control(ctrl, enable);\n}\nEXPORT_SYMBOL_GPL(serdev_device_set_flow_control);\n\nint serdev_device_set_parity(struct serdev_device *serdev,\n\t\t\t     enum serdev_parity parity)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tif (!ctrl || !ctrl->ops->set_parity)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ctrl->ops->set_parity(ctrl, parity);\n}\nEXPORT_SYMBOL_GPL(serdev_device_set_parity);\n\nvoid serdev_device_wait_until_sent(struct serdev_device *serdev, long timeout)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tif (!ctrl || !ctrl->ops->wait_until_sent)\n\t\treturn;\n\n\tctrl->ops->wait_until_sent(ctrl, timeout);\n}\nEXPORT_SYMBOL_GPL(serdev_device_wait_until_sent);\n\nint serdev_device_get_tiocm(struct serdev_device *serdev)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tif (!ctrl || !ctrl->ops->get_tiocm)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ctrl->ops->get_tiocm(ctrl);\n}\nEXPORT_SYMBOL_GPL(serdev_device_get_tiocm);\n\nint serdev_device_set_tiocm(struct serdev_device *serdev, int set, int clear)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tif (!ctrl || !ctrl->ops->set_tiocm)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ctrl->ops->set_tiocm(ctrl, set, clear);\n}\nEXPORT_SYMBOL_GPL(serdev_device_set_tiocm);\n\nint serdev_device_break_ctl(struct serdev_device *serdev, int break_state)\n{\n\tstruct serdev_controller *ctrl = serdev->ctrl;\n\n\tif (!ctrl || !ctrl->ops->break_ctl)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ctrl->ops->break_ctl(ctrl, break_state);\n}\nEXPORT_SYMBOL_GPL(serdev_device_break_ctl);\n\nstatic int serdev_drv_probe(struct device *dev)\n{\n\tconst struct serdev_device_driver *sdrv = to_serdev_device_driver(dev->driver);\n\tint ret;\n\n\tret = dev_pm_domain_attach(dev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sdrv->probe(to_serdev_device(dev));\n\tif (ret)\n\t\tdev_pm_domain_detach(dev, true);\n\n\treturn ret;\n}\n\nstatic void serdev_drv_remove(struct device *dev)\n{\n\tconst struct serdev_device_driver *sdrv = to_serdev_device_driver(dev->driver);\n\tif (sdrv->remove)\n\t\tsdrv->remove(to_serdev_device(dev));\n\n\tdev_pm_domain_detach(dev, true);\n}\n\nstatic struct bus_type serdev_bus_type = {\n\t.name\t\t= \"serial\",\n\t.match\t\t= serdev_device_match,\n\t.probe\t\t= serdev_drv_probe,\n\t.remove\t\t= serdev_drv_remove,\n};\n\n \nstruct serdev_device *serdev_device_alloc(struct serdev_controller *ctrl)\n{\n\tstruct serdev_device *serdev;\n\n\tserdev = kzalloc(sizeof(*serdev), GFP_KERNEL);\n\tif (!serdev)\n\t\treturn NULL;\n\n\tserdev->ctrl = ctrl;\n\tdevice_initialize(&serdev->dev);\n\tserdev->dev.parent = &ctrl->dev;\n\tserdev->dev.bus = &serdev_bus_type;\n\tserdev->dev.type = &serdev_device_type;\n\tinit_completion(&serdev->write_comp);\n\tmutex_init(&serdev->write_lock);\n\treturn serdev;\n}\nEXPORT_SYMBOL_GPL(serdev_device_alloc);\n\n \nstruct serdev_controller *serdev_controller_alloc(struct device *parent,\n\t\t\t\t\t      size_t size)\n{\n\tstruct serdev_controller *ctrl;\n\tint id;\n\n\tif (WARN_ON(!parent))\n\t\treturn NULL;\n\n\tctrl = kzalloc(sizeof(*ctrl) + size, GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn NULL;\n\n\tid = ida_simple_get(&ctrl_ida, 0, 0, GFP_KERNEL);\n\tif (id < 0) {\n\t\tdev_err(parent,\n\t\t\t\"unable to allocate serdev controller identifier.\\n\");\n\t\tgoto err_free;\n\t}\n\n\tctrl->nr = id;\n\n\tdevice_initialize(&ctrl->dev);\n\tctrl->dev.type = &serdev_ctrl_type;\n\tctrl->dev.bus = &serdev_bus_type;\n\tctrl->dev.parent = parent;\n\tctrl->dev.of_node = parent->of_node;\n\tserdev_controller_set_drvdata(ctrl, &ctrl[1]);\n\n\tdev_set_name(&ctrl->dev, \"serial%d\", id);\n\n\tpm_runtime_no_callbacks(&ctrl->dev);\n\tpm_suspend_ignore_children(&ctrl->dev, true);\n\n\tdev_dbg(&ctrl->dev, \"allocated controller 0x%p id %d\\n\", ctrl, id);\n\treturn ctrl;\n\nerr_free:\n\tkfree(ctrl);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(serdev_controller_alloc);\n\nstatic int of_serdev_register_devices(struct serdev_controller *ctrl)\n{\n\tstruct device_node *node;\n\tstruct serdev_device *serdev = NULL;\n\tint err;\n\tbool found = false;\n\n\tfor_each_available_child_of_node(ctrl->dev.of_node, node) {\n\t\tif (!of_get_property(node, \"compatible\", NULL))\n\t\t\tcontinue;\n\n\t\tdev_dbg(&ctrl->dev, \"adding child %pOF\\n\", node);\n\n\t\tserdev = serdev_device_alloc(ctrl);\n\t\tif (!serdev)\n\t\t\tcontinue;\n\n\t\tdevice_set_node(&serdev->dev, of_fwnode_handle(node));\n\n\t\terr = serdev_device_add(serdev);\n\t\tif (err) {\n\t\t\tdev_err(&serdev->dev,\n\t\t\t\t\"failure adding device. status %pe\\n\",\n\t\t\t\tERR_PTR(err));\n\t\t\tserdev_device_put(serdev);\n\t\t} else\n\t\t\tfound = true;\n\t}\n\tif (!found)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\n\n#define SERDEV_ACPI_MAX_SCAN_DEPTH 32\n\nstruct acpi_serdev_lookup {\n\tacpi_handle device_handle;\n\tacpi_handle controller_handle;\n\tint n;\n\tint index;\n};\n\n \nbool serdev_acpi_get_uart_resource(struct acpi_resource *ares,\n\t\t\t\t   struct acpi_resource_uart_serialbus **uart)\n{\n\tstruct acpi_resource_uart_serialbus *sb;\n\n\tif (ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)\n\t\treturn false;\n\n\tsb = &ares->data.uart_serial_bus;\n\tif (sb->type != ACPI_RESOURCE_SERIAL_TYPE_UART)\n\t\treturn false;\n\n\t*uart = sb;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(serdev_acpi_get_uart_resource);\n\nstatic int acpi_serdev_parse_resource(struct acpi_resource *ares, void *data)\n{\n\tstruct acpi_serdev_lookup *lookup = data;\n\tstruct acpi_resource_uart_serialbus *sb;\n\tacpi_status status;\n\n\tif (!serdev_acpi_get_uart_resource(ares, &sb))\n\t\treturn 1;\n\n\tif (lookup->index != -1 && lookup->n++ != lookup->index)\n\t\treturn 1;\n\n\tstatus = acpi_get_handle(lookup->device_handle,\n\t\t\t\t sb->resource_source.string_ptr,\n\t\t\t\t &lookup->controller_handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn 1;\n\n\t \n\n\treturn 1;\n}\n\nstatic int acpi_serdev_do_lookup(struct acpi_device *adev,\n                                 struct acpi_serdev_lookup *lookup)\n{\n\tstruct list_head resource_list;\n\tint ret;\n\n\tlookup->device_handle = acpi_device_handle(adev);\n\tlookup->controller_handle = NULL;\n\tlookup->n = 0;\n\n\tINIT_LIST_HEAD(&resource_list);\n\tret = acpi_dev_get_resources(adev, &resource_list,\n\t\t\t\t     acpi_serdev_parse_resource, lookup);\n\tacpi_dev_free_resource_list(&resource_list);\n\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int acpi_serdev_check_resources(struct serdev_controller *ctrl,\n\t\t\t\t       struct acpi_device *adev)\n{\n\tstruct acpi_serdev_lookup lookup;\n\tint ret;\n\n\tif (acpi_bus_get_status(adev) || !adev->status.present)\n\t\treturn -EINVAL;\n\n\t \n\tlookup.index = -1;\t\n\n\tret = acpi_serdev_do_lookup(adev, &lookup);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!lookup.controller_handle && x86_apple_machine &&\n\t    !acpi_dev_get_property(adev, \"baud\", ACPI_TYPE_BUFFER, NULL))\n\t\tacpi_get_parent(adev->handle, &lookup.controller_handle);\n\n\t \n\tif (ACPI_HANDLE(ctrl->dev.parent) != lookup.controller_handle)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic acpi_status acpi_serdev_register_device(struct serdev_controller *ctrl,\n\t\t\t\t\t       struct acpi_device *adev)\n{\n\tstruct serdev_device *serdev;\n\tint err;\n\n\tserdev = serdev_device_alloc(ctrl);\n\tif (!serdev) {\n\t\tdev_err(&ctrl->dev, \"failed to allocate serdev device for %s\\n\",\n\t\t\tdev_name(&adev->dev));\n\t\treturn AE_NO_MEMORY;\n\t}\n\n\tACPI_COMPANION_SET(&serdev->dev, adev);\n\tacpi_device_set_enumerated(adev);\n\n\terr = serdev_device_add(serdev);\n\tif (err) {\n\t\tdev_err(&serdev->dev,\n\t\t\t\"failure adding ACPI serdev device. status %pe\\n\",\n\t\t\tERR_PTR(err));\n\t\tserdev_device_put(serdev);\n\t}\n\n\treturn AE_OK;\n}\n\nstatic const struct acpi_device_id serdev_acpi_devices_blacklist[] = {\n\t{ \"INT3511\", 0 },\n\t{ \"INT3512\", 0 },\n\t{ },\n};\n\nstatic acpi_status acpi_serdev_add_device(acpi_handle handle, u32 level,\n\t\t\t\t\t  void *data, void **return_value)\n{\n\tstruct acpi_device *adev = acpi_fetch_acpi_dev(handle);\n\tstruct serdev_controller *ctrl = data;\n\n\tif (!adev || acpi_device_enumerated(adev))\n\t\treturn AE_OK;\n\n\t \n\tif (!acpi_match_device_ids(adev, serdev_acpi_devices_blacklist))\n\t\treturn AE_OK;\n\n\tif (acpi_serdev_check_resources(ctrl, adev))\n\t\treturn AE_OK;\n\n\treturn acpi_serdev_register_device(ctrl, adev);\n}\n\n\nstatic int acpi_serdev_register_devices(struct serdev_controller *ctrl)\n{\n\tacpi_status status;\n\tbool skip;\n\tint ret;\n\n\tif (!has_acpi_companion(ctrl->dev.parent))\n\t\treturn -ENODEV;\n\n\t \n\tret = acpi_quirk_skip_serdev_enumeration(ctrl->dev.parent, &skip);\n\tif (ret)\n\t\treturn ret;\n\tif (skip)\n\t\treturn 0;\n\n\tstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\n\t\t\t\t     SERDEV_ACPI_MAX_SCAN_DEPTH,\n\t\t\t\t     acpi_serdev_add_device, NULL, ctrl, NULL);\n\tif (ACPI_FAILURE(status))\n\t\tdev_warn(&ctrl->dev, \"failed to enumerate serdev slaves\\n\");\n\n\tif (!ctrl->serdev)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n#else\nstatic inline int acpi_serdev_register_devices(struct serdev_controller *ctrl)\n{\n\treturn -ENODEV;\n}\n#endif  \n\n \nint serdev_controller_add(struct serdev_controller *ctrl)\n{\n\tint ret_of, ret_acpi, ret;\n\n\t \n\tif (WARN_ON(!is_registered))\n\t\treturn -EAGAIN;\n\n\tret = device_add(&ctrl->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(&ctrl->dev);\n\n\tret_of = of_serdev_register_devices(ctrl);\n\tret_acpi = acpi_serdev_register_devices(ctrl);\n\tif (ret_of && ret_acpi) {\n\t\tdev_dbg(&ctrl->dev, \"no devices registered: of:%pe acpi:%pe\\n\",\n\t\t\tERR_PTR(ret_of), ERR_PTR(ret_acpi));\n\t\tret = -ENODEV;\n\t\tgoto err_rpm_disable;\n\t}\n\n\tdev_dbg(&ctrl->dev, \"serdev%d registered: dev:%p\\n\",\n\t\tctrl->nr, &ctrl->dev);\n\treturn 0;\n\nerr_rpm_disable:\n\tpm_runtime_disable(&ctrl->dev);\n\tdevice_del(&ctrl->dev);\n\treturn ret;\n};\nEXPORT_SYMBOL_GPL(serdev_controller_add);\n\n \nstatic int serdev_remove_device(struct device *dev, void *data)\n{\n\tstruct serdev_device *serdev = to_serdev_device(dev);\n\tif (dev->type == &serdev_device_type)\n\t\tserdev_device_remove(serdev);\n\treturn 0;\n}\n\n \nvoid serdev_controller_remove(struct serdev_controller *ctrl)\n{\n\tif (!ctrl)\n\t\treturn;\n\n\tdevice_for_each_child(&ctrl->dev, NULL, serdev_remove_device);\n\tpm_runtime_disable(&ctrl->dev);\n\tdevice_del(&ctrl->dev);\n}\nEXPORT_SYMBOL_GPL(serdev_controller_remove);\n\n \nint __serdev_device_driver_register(struct serdev_device_driver *sdrv, struct module *owner)\n{\n\tsdrv->driver.bus = &serdev_bus_type;\n\tsdrv->driver.owner = owner;\n\n\t \n        sdrv->driver.probe_type = PROBE_PREFER_ASYNCHRONOUS;\n\n\treturn driver_register(&sdrv->driver);\n}\nEXPORT_SYMBOL_GPL(__serdev_device_driver_register);\n\nstatic void __exit serdev_exit(void)\n{\n\tbus_unregister(&serdev_bus_type);\n\tida_destroy(&ctrl_ida);\n}\nmodule_exit(serdev_exit);\n\nstatic int __init serdev_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&serdev_bus_type);\n\tif (ret)\n\t\treturn ret;\n\n\tis_registered = true;\n\treturn 0;\n}\n \npostcore_initcall(serdev_init);\n\nMODULE_AUTHOR(\"Rob Herring <robh@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Serial attached device bus\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}