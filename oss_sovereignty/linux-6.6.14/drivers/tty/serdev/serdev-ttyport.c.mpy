{
  "module_name": "serdev-ttyport.c",
  "hash_id": "1f501c48201ed0356ce52452ab944629ffc19d6e4b4246ad341b3d3f48f41824",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/serdev/serdev-ttyport.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/serdev.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/poll.h>\n\n#define SERPORT_ACTIVE\t\t1\n\nstruct serport {\n\tstruct tty_port *port;\n\tstruct tty_struct *tty;\n\tstruct tty_driver *tty_drv;\n\tint tty_idx;\n\tunsigned long flags;\n};\n\n \n\nstatic size_t ttyport_receive_buf(struct tty_port *port, const u8 *cp,\n\t\t\t\t  const u8 *fp, size_t count)\n{\n\tstruct serdev_controller *ctrl = port->client_data;\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tint ret;\n\n\tif (!test_bit(SERPORT_ACTIVE, &serport->flags))\n\t\treturn 0;\n\n\tret = serdev_controller_receive_buf(ctrl, cp, count);\n\n\tdev_WARN_ONCE(&ctrl->dev, ret < 0 || ret > count,\n\t\t\t\t\"receive_buf returns %d (count = %zu)\\n\",\n\t\t\t\tret, count);\n\tif (ret < 0)\n\t\treturn 0;\n\telse if (ret > count)\n\t\treturn count;\n\n\treturn ret;\n}\n\nstatic void ttyport_write_wakeup(struct tty_port *port)\n{\n\tstruct serdev_controller *ctrl = port->client_data;\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty;\n\n\ttty = tty_port_tty_get(port);\n\tif (!tty)\n\t\treturn;\n\n\tif (test_and_clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags) &&\n\t    test_bit(SERPORT_ACTIVE, &serport->flags))\n\t\tserdev_controller_write_wakeup(ctrl);\n\n\t \n\twake_up_interruptible(&tty->write_wait);\n\n\ttty_kref_put(tty);\n}\n\nstatic const struct tty_port_client_operations client_ops = {\n\t.receive_buf = ttyport_receive_buf,\n\t.write_wakeup = ttyport_write_wakeup,\n};\n\n \n\nstatic int ttyport_write_buf(struct serdev_controller *ctrl, const unsigned char *data, size_t len)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty = serport->tty;\n\n\tif (!test_bit(SERPORT_ACTIVE, &serport->flags))\n\t\treturn 0;\n\n\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\treturn tty->ops->write(serport->tty, data, len);\n}\n\nstatic void ttyport_write_flush(struct serdev_controller *ctrl)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty = serport->tty;\n\n\ttty_driver_flush_buffer(tty);\n}\n\nstatic int ttyport_write_room(struct serdev_controller *ctrl)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty = serport->tty;\n\n\treturn tty_write_room(tty);\n}\n\nstatic int ttyport_open(struct serdev_controller *ctrl)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty;\n\tstruct ktermios ktermios;\n\tint ret;\n\n\ttty = tty_init_dev(serport->tty_drv, serport->tty_idx);\n\tif (IS_ERR(tty))\n\t\treturn PTR_ERR(tty);\n\tserport->tty = tty;\n\n\tif (!tty->ops->open || !tty->ops->close) {\n\t\tret = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tret = tty->ops->open(serport->tty, NULL);\n\tif (ret)\n\t\tgoto err_close;\n\n\ttty_unlock(serport->tty);\n\n\t \n\tktermios = tty->termios;\n\tktermios.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP |\n\t\t\t      INLCR | IGNCR | ICRNL | IXON);\n\tktermios.c_oflag &= ~OPOST;\n\tktermios.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);\n\tktermios.c_cflag &= ~(CSIZE | PARENB);\n\tktermios.c_cflag |= CS8;\n\tktermios.c_cflag |= CRTSCTS;\n\t \n\tktermios.c_cflag |= CLOCAL;\n\ttty_set_termios(tty, &ktermios);\n\n\tset_bit(SERPORT_ACTIVE, &serport->flags);\n\n\treturn 0;\n\nerr_close:\n\ttty->ops->close(tty, NULL);\nerr_unlock:\n\ttty_unlock(tty);\n\ttty_release_struct(tty, serport->tty_idx);\n\n\treturn ret;\n}\n\nstatic void ttyport_close(struct serdev_controller *ctrl)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty = serport->tty;\n\n\tclear_bit(SERPORT_ACTIVE, &serport->flags);\n\n\ttty_lock(tty);\n\tif (tty->ops->close)\n\t\ttty->ops->close(tty, NULL);\n\ttty_unlock(tty);\n\n\ttty_release_struct(tty, serport->tty_idx);\n}\n\nstatic unsigned int ttyport_set_baudrate(struct serdev_controller *ctrl, unsigned int speed)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty = serport->tty;\n\tstruct ktermios ktermios = tty->termios;\n\n\tktermios.c_cflag &= ~CBAUD;\n\ttty_termios_encode_baud_rate(&ktermios, speed, speed);\n\n\t \n\ttty_set_termios(tty, &ktermios);\n\treturn ktermios.c_ospeed;\n}\n\nstatic void ttyport_set_flow_control(struct serdev_controller *ctrl, bool enable)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty = serport->tty;\n\tstruct ktermios ktermios = tty->termios;\n\n\tif (enable)\n\t\tktermios.c_cflag |= CRTSCTS;\n\telse\n\t\tktermios.c_cflag &= ~CRTSCTS;\n\n\ttty_set_termios(tty, &ktermios);\n}\n\nstatic int ttyport_set_parity(struct serdev_controller *ctrl,\n\t\t\t      enum serdev_parity parity)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty = serport->tty;\n\tstruct ktermios ktermios = tty->termios;\n\n\tktermios.c_cflag &= ~(PARENB | PARODD | CMSPAR);\n\tif (parity != SERDEV_PARITY_NONE) {\n\t\tktermios.c_cflag |= PARENB;\n\t\tif (parity == SERDEV_PARITY_ODD)\n\t\t\tktermios.c_cflag |= PARODD;\n\t}\n\n\ttty_set_termios(tty, &ktermios);\n\n\tif ((tty->termios.c_cflag & (PARENB | PARODD | CMSPAR)) !=\n\t    (ktermios.c_cflag & (PARENB | PARODD | CMSPAR)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void ttyport_wait_until_sent(struct serdev_controller *ctrl, long timeout)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty = serport->tty;\n\n\ttty_wait_until_sent(tty, timeout);\n}\n\nstatic int ttyport_get_tiocm(struct serdev_controller *ctrl)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty = serport->tty;\n\n\tif (!tty->ops->tiocmget)\n\t\treturn -EOPNOTSUPP;\n\n\treturn tty->ops->tiocmget(tty);\n}\n\nstatic int ttyport_set_tiocm(struct serdev_controller *ctrl, unsigned int set, unsigned int clear)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty = serport->tty;\n\n\tif (!tty->ops->tiocmset)\n\t\treturn -EOPNOTSUPP;\n\n\treturn tty->ops->tiocmset(tty, set, clear);\n}\n\nstatic int ttyport_break_ctl(struct serdev_controller *ctrl, unsigned int break_state)\n{\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\tstruct tty_struct *tty = serport->tty;\n\n\tif (!tty->ops->break_ctl)\n\t\treturn -EOPNOTSUPP;\n\n\treturn tty->ops->break_ctl(tty, break_state);\n}\n\nstatic const struct serdev_controller_ops ctrl_ops = {\n\t.write_buf = ttyport_write_buf,\n\t.write_flush = ttyport_write_flush,\n\t.write_room = ttyport_write_room,\n\t.open = ttyport_open,\n\t.close = ttyport_close,\n\t.set_flow_control = ttyport_set_flow_control,\n\t.set_parity = ttyport_set_parity,\n\t.set_baudrate = ttyport_set_baudrate,\n\t.wait_until_sent = ttyport_wait_until_sent,\n\t.get_tiocm = ttyport_get_tiocm,\n\t.set_tiocm = ttyport_set_tiocm,\n\t.break_ctl = ttyport_break_ctl,\n};\n\nstruct device *serdev_tty_port_register(struct tty_port *port,\n\t\t\t\t\tstruct device *parent,\n\t\t\t\t\tstruct tty_driver *drv, int idx)\n{\n\tstruct serdev_controller *ctrl;\n\tstruct serport *serport;\n\tint ret;\n\n\tif (!port || !drv || !parent)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tctrl = serdev_controller_alloc(parent, sizeof(struct serport));\n\tif (!ctrl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tserport = serdev_controller_get_drvdata(ctrl);\n\n\tserport->port = port;\n\tserport->tty_idx = idx;\n\tserport->tty_drv = drv;\n\n\tctrl->ops = &ctrl_ops;\n\n\tport->client_ops = &client_ops;\n\tport->client_data = ctrl;\n\n\tret = serdev_controller_add(ctrl);\n\tif (ret)\n\t\tgoto err_reset_data;\n\n\tdev_info(&ctrl->dev, \"tty port %s%d registered\\n\", drv->name, idx);\n\treturn &ctrl->dev;\n\nerr_reset_data:\n\tport->client_data = NULL;\n\tport->client_ops = &tty_port_default_client_ops;\n\tserdev_controller_put(ctrl);\n\n\treturn ERR_PTR(ret);\n}\n\nint serdev_tty_port_unregister(struct tty_port *port)\n{\n\tstruct serdev_controller *ctrl = port->client_data;\n\tstruct serport *serport = serdev_controller_get_drvdata(ctrl);\n\n\tif (!serport)\n\t\treturn -ENODEV;\n\n\tserdev_controller_remove(ctrl);\n\tport->client_data = NULL;\n\tport->client_ops = &tty_port_default_client_ops;\n\tserdev_controller_put(ctrl);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}