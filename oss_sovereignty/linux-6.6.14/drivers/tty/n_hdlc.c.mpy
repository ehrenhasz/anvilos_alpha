{
  "module_name": "n_hdlc.c",
  "hash_id": "ad5aace75c95aa6217af8ac5c678170f35f6f41d9156c7b18ca063b9abb68a57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/n_hdlc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n\n#include <linux/poll.h>\n#include <linux/in.h>\n#include <linux/ioctl.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/string.h>\t \n#include <linux/signal.h>\t \n#include <linux/if.h>\n#include <linux/bitops.h>\n\n#include <linux/uaccess.h>\n#include \"tty.h\"\n\n \n#define MAX_HDLC_FRAME_SIZE 65535\n#define DEFAULT_RX_BUF_COUNT 10\n#define MAX_RX_BUF_COUNT 60\n#define DEFAULT_TX_BUF_COUNT 3\n\nstruct n_hdlc_buf {\n\tstruct list_head  list_item;\n\tint\t\t  count;\n\tchar\t\t  buf[];\n};\n\nstruct n_hdlc_buf_list {\n\tstruct list_head  list;\n\tint\t\t  count;\n\tspinlock_t\t  spinlock;\n};\n\n \nstruct n_hdlc {\n\tbool\t\t\ttbusy;\n\tbool\t\t\twoke_up;\n\tstruct n_hdlc_buf_list\ttx_buf_list;\n\tstruct n_hdlc_buf_list\trx_buf_list;\n\tstruct n_hdlc_buf_list\ttx_free_buf_list;\n\tstruct n_hdlc_buf_list\trx_free_buf_list;\n\tstruct work_struct\twrite_work;\n\tstruct tty_struct\t*tty_for_write_work;\n};\n\n \nstatic void n_hdlc_buf_return(struct n_hdlc_buf_list *buf_list,\n\t\t\t\t\t\tstruct n_hdlc_buf *buf);\nstatic void n_hdlc_buf_put(struct n_hdlc_buf_list *list,\n\t\t\t   struct n_hdlc_buf *buf);\nstatic struct n_hdlc_buf *n_hdlc_buf_get(struct n_hdlc_buf_list *list);\n\n \n\nstatic struct n_hdlc *n_hdlc_alloc(void);\nstatic void n_hdlc_tty_write_work(struct work_struct *work);\n\n \nstatic int maxframe = 4096;\n\nstatic void flush_rx_queue(struct tty_struct *tty)\n{\n\tstruct n_hdlc *n_hdlc = tty->disc_data;\n\tstruct n_hdlc_buf *buf;\n\n\twhile ((buf = n_hdlc_buf_get(&n_hdlc->rx_buf_list)))\n\t\tn_hdlc_buf_put(&n_hdlc->rx_free_buf_list, buf);\n}\n\nstatic void flush_tx_queue(struct tty_struct *tty)\n{\n\tstruct n_hdlc *n_hdlc = tty->disc_data;\n\tstruct n_hdlc_buf *buf;\n\n\twhile ((buf = n_hdlc_buf_get(&n_hdlc->tx_buf_list)))\n\t\tn_hdlc_buf_put(&n_hdlc->tx_free_buf_list, buf);\n}\n\nstatic void n_hdlc_free_buf_list(struct n_hdlc_buf_list *list)\n{\n\tstruct n_hdlc_buf *buf;\n\n\tdo {\n\t\tbuf = n_hdlc_buf_get(list);\n\t\tkfree(buf);\n\t} while (buf);\n}\n\n \nstatic void n_hdlc_tty_close(struct tty_struct *tty)\n{\n\tstruct n_hdlc *n_hdlc = tty->disc_data;\n\n#if defined(TTY_NO_WRITE_SPLIT)\n\tclear_bit(TTY_NO_WRITE_SPLIT, &tty->flags);\n#endif\n\ttty->disc_data = NULL;\n\n\t \n\twake_up_interruptible(&tty->read_wait);\n\twake_up_interruptible(&tty->write_wait);\n\n\tcancel_work_sync(&n_hdlc->write_work);\n\n\tn_hdlc_free_buf_list(&n_hdlc->rx_free_buf_list);\n\tn_hdlc_free_buf_list(&n_hdlc->tx_free_buf_list);\n\tn_hdlc_free_buf_list(&n_hdlc->rx_buf_list);\n\tn_hdlc_free_buf_list(&n_hdlc->tx_buf_list);\n\tkfree(n_hdlc);\n}\t \n\n \nstatic int n_hdlc_tty_open(struct tty_struct *tty)\n{\n\tstruct n_hdlc *n_hdlc = tty->disc_data;\n\n\tpr_debug(\"%s() called (device=%s)\\n\", __func__, tty->name);\n\n\t \n\tif (n_hdlc) {\n\t\tpr_err(\"%s: tty already associated!\\n\", __func__);\n\t\treturn -EEXIST;\n\t}\n\n\tn_hdlc = n_hdlc_alloc();\n\tif (!n_hdlc) {\n\t\tpr_err(\"%s: n_hdlc_alloc failed\\n\", __func__);\n\t\treturn -ENFILE;\n\t}\n\n\tINIT_WORK(&n_hdlc->write_work, n_hdlc_tty_write_work);\n\tn_hdlc->tty_for_write_work = tty;\n\ttty->disc_data = n_hdlc;\n\ttty->receive_room = 65536;\n\n\t \n\tset_bit(TTY_NO_WRITE_SPLIT, &tty->flags);\n\n\t \n\ttty_driver_flush_buffer(tty);\n\n\treturn 0;\n\n}\t \n\n \nstatic void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)\n{\n\tregister int actual;\n\tunsigned long flags;\n\tstruct n_hdlc_buf *tbuf;\n\ncheck_again:\n\n\tspin_lock_irqsave(&n_hdlc->tx_buf_list.spinlock, flags);\n\tif (n_hdlc->tbusy) {\n\t\tn_hdlc->woke_up = true;\n\t\tspin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock, flags);\n\t\treturn;\n\t}\n\tn_hdlc->tbusy = true;\n\tn_hdlc->woke_up = false;\n\tspin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock, flags);\n\n\ttbuf = n_hdlc_buf_get(&n_hdlc->tx_buf_list);\n\twhile (tbuf) {\n\t\tpr_debug(\"sending frame %p, count=%d\\n\", tbuf, tbuf->count);\n\n\t\t \n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\t\tactual = tty->ops->write(tty, tbuf->buf, tbuf->count);\n\n\t\t \n\t\tif (actual == -ERESTARTSYS) {\n\t\t\tn_hdlc_buf_return(&n_hdlc->tx_buf_list, tbuf);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\t \n\t\tif (actual < 0)\n\t\t\tactual = tbuf->count;\n\n\t\tif (actual == tbuf->count) {\n\t\t\tpr_debug(\"frame %p completed\\n\", tbuf);\n\n\t\t\t \n\t\t\tn_hdlc_buf_put(&n_hdlc->tx_free_buf_list, tbuf);\n\n\t\t\t \n\t\t\twake_up_interruptible(&tty->write_wait);\n\n\t\t\t \n\t\t\ttbuf = n_hdlc_buf_get(&n_hdlc->tx_buf_list);\n\t\t} else {\n\t\t\tpr_debug(\"frame %p pending\\n\", tbuf);\n\n\t\t\t \n\t\t\tn_hdlc_buf_return(&n_hdlc->tx_buf_list, tbuf);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!tbuf)\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\n\t \n\tspin_lock_irqsave(&n_hdlc->tx_buf_list.spinlock, flags);\n\tn_hdlc->tbusy = false;\n\tspin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock, flags);\n\n\tif (n_hdlc->woke_up)\n\t\tgoto check_again;\n}\t \n\n \nstatic void n_hdlc_tty_write_work(struct work_struct *work)\n{\n\tstruct n_hdlc *n_hdlc = container_of(work, struct n_hdlc, write_work);\n\tstruct tty_struct *tty = n_hdlc->tty_for_write_work;\n\n\tn_hdlc_send_frames(n_hdlc, tty);\n}\t \n\n \nstatic void n_hdlc_tty_wakeup(struct tty_struct *tty)\n{\n\tstruct n_hdlc *n_hdlc = tty->disc_data;\n\n\tschedule_work(&n_hdlc->write_work);\n}\t \n\n \nstatic void n_hdlc_tty_receive(struct tty_struct *tty, const u8 *data,\n\t\t\t       const u8 *flags, size_t count)\n{\n\tregister struct n_hdlc *n_hdlc = tty->disc_data;\n\tregister struct n_hdlc_buf *buf;\n\n\tpr_debug(\"%s() called count=%zu\\n\", __func__, count);\n\n\tif (count > maxframe) {\n\t\tpr_debug(\"rx count>maxframesize, data discarded\\n\");\n\t\treturn;\n\t}\n\n\t \n\tbuf = n_hdlc_buf_get(&n_hdlc->rx_free_buf_list);\n\tif (!buf) {\n\t\t \n\t\tif (n_hdlc->rx_buf_list.count < MAX_RX_BUF_COUNT)\n\t\t\tbuf = kmalloc(struct_size(buf, buf, maxframe),\n\t\t\t\t      GFP_ATOMIC);\n\t}\n\n\tif (!buf) {\n\t\tpr_debug(\"no more rx buffers, data discarded\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmemcpy(buf->buf, data, count);\n\tbuf->count = count;\n\n\t \n\tn_hdlc_buf_put(&n_hdlc->rx_buf_list, buf);\n\n\t \n\twake_up_interruptible(&tty->read_wait);\n\tif (tty->fasync != NULL)\n\t\tkill_fasync(&tty->fasync, SIGIO, POLL_IN);\n\n}\t \n\n \nstatic ssize_t n_hdlc_tty_read(struct tty_struct *tty, struct file *file,\n\t\t\t       u8 *kbuf, size_t nr, void **cookie,\n\t\t\t       unsigned long offset)\n{\n\tstruct n_hdlc *n_hdlc = tty->disc_data;\n\tint ret = 0;\n\tstruct n_hdlc_buf *rbuf;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\t \n\trbuf = *cookie;\n\tif (rbuf)\n\t\tgoto have_rbuf;\n\n\tadd_wait_queue(&tty->read_wait, &wait);\n\n\tfor (;;) {\n\t\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file))\n\t\t\tbreak;\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\trbuf = n_hdlc_buf_get(&n_hdlc->rx_buf_list);\n\t\tif (rbuf)\n\t\t\tbreak;\n\n\t\t \n\t\tif (tty_io_nonblock(tty, file)) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule();\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tremove_wait_queue(&tty->read_wait, &wait);\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!rbuf)\n\t\treturn ret;\n\t*cookie = rbuf;\n\nhave_rbuf:\n\t \n\tif (offset >= rbuf->count)\n\t\tgoto done_with_rbuf;\n\n\t \n\tret = -EOVERFLOW;\n\tif (!nr)\n\t\tgoto done_with_rbuf;\n\n\t \n\tret = rbuf->count - offset;\n\tif (ret > nr)\n\t\tret = nr;\n\tmemcpy(kbuf, rbuf->buf+offset, ret);\n\toffset += ret;\n\n\t \n\tif (offset < rbuf->count)\n\t\treturn ret;\n\ndone_with_rbuf:\n\t*cookie = NULL;\n\n\tif (n_hdlc->rx_free_buf_list.count > DEFAULT_RX_BUF_COUNT)\n\t\tkfree(rbuf);\n\telse\n\t\tn_hdlc_buf_put(&n_hdlc->rx_free_buf_list, rbuf);\n\n\treturn ret;\n\n}\t \n\n \nstatic ssize_t n_hdlc_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t\tconst u8 *data, size_t count)\n{\n\tstruct n_hdlc *n_hdlc = tty->disc_data;\n\tint error = 0;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct n_hdlc_buf *tbuf;\n\n\tpr_debug(\"%s() called count=%zd\\n\", __func__, count);\n\n\t \n\tif (count > maxframe) {\n\t\tpr_debug(\"%s: truncating user packet from %zu to %d\\n\",\n\t\t\t\t__func__, count, maxframe);\n\t\tcount = maxframe;\n\t}\n\n\tadd_wait_queue(&tty->write_wait, &wait);\n\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\ttbuf = n_hdlc_buf_get(&n_hdlc->tx_free_buf_list);\n\t\tif (tbuf)\n\t\t\tbreak;\n\n\t\tif (tty_io_nonblock(tty, file)) {\n\t\t\terror = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\n\t\tif (signal_pending(current)) {\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\n\tif (!error) {\n\t\t \n\t\tmemcpy(tbuf->buf, data, count);\n\n\t\t \n\t\ttbuf->count = error = count;\n\t\tn_hdlc_buf_put(&n_hdlc->tx_buf_list, tbuf);\n\t\tn_hdlc_send_frames(n_hdlc, tty);\n\t}\n\n\treturn error;\n\n}\t \n\n \nstatic int n_hdlc_tty_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct n_hdlc *n_hdlc = tty->disc_data;\n\tint error = 0;\n\tint count;\n\tunsigned long flags;\n\tstruct n_hdlc_buf *buf = NULL;\n\n\tpr_debug(\"%s() called %d\\n\", __func__, cmd);\n\n\tswitch (cmd) {\n\tcase FIONREAD:\n\t\t \n\t\t \n\t\tspin_lock_irqsave(&n_hdlc->rx_buf_list.spinlock, flags);\n\t\tbuf = list_first_entry_or_null(&n_hdlc->rx_buf_list.list,\n\t\t\t\t\t\tstruct n_hdlc_buf, list_item);\n\t\tif (buf)\n\t\t\tcount = buf->count;\n\t\telse\n\t\t\tcount = 0;\n\t\tspin_unlock_irqrestore(&n_hdlc->rx_buf_list.spinlock, flags);\n\t\terror = put_user(count, (int __user *)arg);\n\t\tbreak;\n\n\tcase TIOCOUTQ:\n\t\t \n\t\tcount = tty_chars_in_buffer(tty);\n\t\t \n\t\tspin_lock_irqsave(&n_hdlc->tx_buf_list.spinlock, flags);\n\t\tbuf = list_first_entry_or_null(&n_hdlc->tx_buf_list.list,\n\t\t\t\t\t\tstruct n_hdlc_buf, list_item);\n\t\tif (buf)\n\t\t\tcount += buf->count;\n\t\tspin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock, flags);\n\t\terror = put_user(count, (int __user *)arg);\n\t\tbreak;\n\n\tcase TCFLSH:\n\t\tswitch (arg) {\n\t\tcase TCIOFLUSH:\n\t\tcase TCOFLUSH:\n\t\t\tflush_tx_queue(tty);\n\t\t}\n\t\tfallthrough;\t \n\n\tdefault:\n\t\terror = n_tty_ioctl_helper(tty, cmd, arg);\n\t\tbreak;\n\t}\n\treturn error;\n\n}\t \n\n \nstatic __poll_t n_hdlc_tty_poll(struct tty_struct *tty, struct file *filp,\n\t\t\t\t    poll_table *wait)\n{\n\tstruct n_hdlc *n_hdlc = tty->disc_data;\n\t__poll_t mask = 0;\n\n\t \n\tpoll_wait(filp, &tty->read_wait, wait);\n\tpoll_wait(filp, &tty->write_wait, wait);\n\n\t \n\tif (!list_empty(&n_hdlc->rx_buf_list.list))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\t \n\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\n\t\tmask |= EPOLLHUP;\n\tif (tty_hung_up_p(filp))\n\t\tmask |= EPOLLHUP;\n\tif (!tty_is_writelocked(tty) &&\n\t\t\t!list_empty(&n_hdlc->tx_free_buf_list.list))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\t \n\n\treturn mask;\n}\t \n\nstatic void n_hdlc_alloc_buf(struct n_hdlc_buf_list *list, unsigned int count,\n\t\tconst char *name)\n{\n\tstruct n_hdlc_buf *buf;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tbuf = kmalloc(struct_size(buf, buf, maxframe), GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_debug(\"%s(), kmalloc() failed for %s buffer %u\\n\",\n\t\t\t\t\t__func__, name, i);\n\t\t\treturn;\n\t\t}\n\t\tn_hdlc_buf_put(list, buf);\n\t}\n}\n\n \nstatic struct n_hdlc *n_hdlc_alloc(void)\n{\n\tstruct n_hdlc *n_hdlc = kzalloc(sizeof(*n_hdlc), GFP_KERNEL);\n\n\tif (!n_hdlc)\n\t\treturn NULL;\n\n\tspin_lock_init(&n_hdlc->rx_free_buf_list.spinlock);\n\tspin_lock_init(&n_hdlc->tx_free_buf_list.spinlock);\n\tspin_lock_init(&n_hdlc->rx_buf_list.spinlock);\n\tspin_lock_init(&n_hdlc->tx_buf_list.spinlock);\n\n\tINIT_LIST_HEAD(&n_hdlc->rx_free_buf_list.list);\n\tINIT_LIST_HEAD(&n_hdlc->tx_free_buf_list.list);\n\tINIT_LIST_HEAD(&n_hdlc->rx_buf_list.list);\n\tINIT_LIST_HEAD(&n_hdlc->tx_buf_list.list);\n\n\tn_hdlc_alloc_buf(&n_hdlc->rx_free_buf_list, DEFAULT_RX_BUF_COUNT, \"rx\");\n\tn_hdlc_alloc_buf(&n_hdlc->tx_free_buf_list, DEFAULT_TX_BUF_COUNT, \"tx\");\n\n\treturn n_hdlc;\n\n}\t \n\n \nstatic void n_hdlc_buf_return(struct n_hdlc_buf_list *buf_list,\n\t\t\t\t\t\tstruct n_hdlc_buf *buf)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&buf_list->spinlock, flags);\n\n\tlist_add(&buf->list_item, &buf_list->list);\n\tbuf_list->count++;\n\n\tspin_unlock_irqrestore(&buf_list->spinlock, flags);\n}\n\n \nstatic void n_hdlc_buf_put(struct n_hdlc_buf_list *buf_list,\n\t\t\t   struct n_hdlc_buf *buf)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&buf_list->spinlock, flags);\n\n\tlist_add_tail(&buf->list_item, &buf_list->list);\n\tbuf_list->count++;\n\n\tspin_unlock_irqrestore(&buf_list->spinlock, flags);\n}\t \n\n \nstatic struct n_hdlc_buf *n_hdlc_buf_get(struct n_hdlc_buf_list *buf_list)\n{\n\tunsigned long flags;\n\tstruct n_hdlc_buf *buf;\n\n\tspin_lock_irqsave(&buf_list->spinlock, flags);\n\n\tbuf = list_first_entry_or_null(&buf_list->list,\n\t\t\t\t\t\tstruct n_hdlc_buf, list_item);\n\tif (buf) {\n\t\tlist_del(&buf->list_item);\n\t\tbuf_list->count--;\n\t}\n\n\tspin_unlock_irqrestore(&buf_list->spinlock, flags);\n\treturn buf;\n}\t \n\nstatic struct tty_ldisc_ops n_hdlc_ldisc = {\n\t.owner\t\t= THIS_MODULE,\n\t.num\t\t= N_HDLC,\n\t.name\t\t= \"hdlc\",\n\t.open\t\t= n_hdlc_tty_open,\n\t.close\t\t= n_hdlc_tty_close,\n\t.read\t\t= n_hdlc_tty_read,\n\t.write\t\t= n_hdlc_tty_write,\n\t.ioctl\t\t= n_hdlc_tty_ioctl,\n\t.poll\t\t= n_hdlc_tty_poll,\n\t.receive_buf\t= n_hdlc_tty_receive,\n\t.write_wakeup\t= n_hdlc_tty_wakeup,\n\t.flush_buffer   = flush_rx_queue,\n};\n\nstatic int __init n_hdlc_init(void)\n{\n\tint status;\n\n\t \n\tmaxframe = clamp(maxframe, 4096, MAX_HDLC_FRAME_SIZE);\n\n\tstatus = tty_register_ldisc(&n_hdlc_ldisc);\n\tif (!status)\n\t\tpr_info(\"N_HDLC line discipline registered with maxframe=%d\\n\",\n\t\t\t\tmaxframe);\n\telse\n\t\tpr_err(\"N_HDLC: error registering line discipline: %d\\n\",\n\t\t\t\tstatus);\n\n\treturn status;\n\n}\t \n\nstatic void __exit n_hdlc_exit(void)\n{\n\ttty_unregister_ldisc(&n_hdlc_ldisc);\n}\n\nmodule_init(n_hdlc_init);\nmodule_exit(n_hdlc_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Paul Fulghum paulkf@microgate.com\");\nmodule_param(maxframe, int, 0);\nMODULE_ALIAS_LDISC(N_HDLC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}