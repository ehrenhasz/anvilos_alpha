{
  "module_name": "sysrq.c",
  "hash_id": "8cf11fb30eb1eed5a27a7afa7a3709339878b935ddb558eabb6a8a56ede63f56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/sysrq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/ctype.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/kdev_t.h>\n#include <linux/major.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/kbd_kern.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/quotaops.h>\n#include <linux/perf_event.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/spinlock.h>\n#include <linux/vt_kern.h>\n#include <linux/workqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/oom.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/of.h>\n#include <linux/rcupdate.h>\n\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n\n \nstatic int __read_mostly sysrq_enabled = CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE;\nstatic bool __read_mostly sysrq_always_enabled;\n\nstatic bool sysrq_on(void)\n{\n\treturn sysrq_enabled || sysrq_always_enabled;\n}\n\n \nint sysrq_mask(void)\n{\n\tif (sysrq_always_enabled)\n\t\treturn 1;\n\treturn sysrq_enabled;\n}\nEXPORT_SYMBOL_GPL(sysrq_mask);\n\n \nstatic bool sysrq_on_mask(int mask)\n{\n\treturn sysrq_always_enabled ||\n\t       sysrq_enabled == 1 ||\n\t       (sysrq_enabled & mask);\n}\n\nstatic int __init sysrq_always_enabled_setup(char *str)\n{\n\tsysrq_always_enabled = true;\n\tpr_info(\"sysrq always enabled.\\n\");\n\n\treturn 1;\n}\n\n__setup(\"sysrq_always_enabled\", sysrq_always_enabled_setup);\n\n\nstatic void sysrq_handle_loglevel(u8 key)\n{\n\tu8 loglevel = key - '0';\n\n\tconsole_loglevel = CONSOLE_LOGLEVEL_DEFAULT;\n\tpr_info(\"Loglevel set to %u\\n\", loglevel);\n\tconsole_loglevel = loglevel;\n}\nstatic const struct sysrq_key_op sysrq_loglevel_op = {\n\t.handler\t= sysrq_handle_loglevel,\n\t.help_msg\t= \"loglevel(0-9)\",\n\t.action_msg\t= \"Changing Loglevel\",\n\t.enable_mask\t= SYSRQ_ENABLE_LOG,\n};\n\n#ifdef CONFIG_VT\nstatic void sysrq_handle_SAK(u8 key)\n{\n\tstruct work_struct *SAK_work = &vc_cons[fg_console].SAK_work;\n\n\tschedule_work(SAK_work);\n}\nstatic const struct sysrq_key_op sysrq_SAK_op = {\n\t.handler\t= sysrq_handle_SAK,\n\t.help_msg\t= \"sak(k)\",\n\t.action_msg\t= \"SAK\",\n\t.enable_mask\t= SYSRQ_ENABLE_KEYBOARD,\n};\n#else\n#define sysrq_SAK_op (*(const struct sysrq_key_op *)NULL)\n#endif\n\n#ifdef CONFIG_VT\nstatic void sysrq_handle_unraw(u8 key)\n{\n\tvt_reset_unicode(fg_console);\n}\n\nstatic const struct sysrq_key_op sysrq_unraw_op = {\n\t.handler\t= sysrq_handle_unraw,\n\t.help_msg\t= \"unraw(r)\",\n\t.action_msg\t= \"Keyboard mode set to system default\",\n\t.enable_mask\t= SYSRQ_ENABLE_KEYBOARD,\n};\n#else\n#define sysrq_unraw_op (*(const struct sysrq_key_op *)NULL)\n#endif  \n\nstatic void sysrq_handle_crash(u8 key)\n{\n\t \n\trcu_read_unlock();\n\n\tpanic(\"sysrq triggered crash\\n\");\n}\nstatic const struct sysrq_key_op sysrq_crash_op = {\n\t.handler\t= sysrq_handle_crash,\n\t.help_msg\t= \"crash(c)\",\n\t.action_msg\t= \"Trigger a crash\",\n\t.enable_mask\t= SYSRQ_ENABLE_DUMP,\n};\n\nstatic void sysrq_handle_reboot(u8 key)\n{\n\tlockdep_off();\n\tlocal_irq_enable();\n\temergency_restart();\n}\nstatic const struct sysrq_key_op sysrq_reboot_op = {\n\t.handler\t= sysrq_handle_reboot,\n\t.help_msg\t= \"reboot(b)\",\n\t.action_msg\t= \"Resetting\",\n\t.enable_mask\t= SYSRQ_ENABLE_BOOT,\n};\n\nconst struct sysrq_key_op *__sysrq_reboot_op = &sysrq_reboot_op;\n\nstatic void sysrq_handle_sync(u8 key)\n{\n\temergency_sync();\n}\nstatic const struct sysrq_key_op sysrq_sync_op = {\n\t.handler\t= sysrq_handle_sync,\n\t.help_msg\t= \"sync(s)\",\n\t.action_msg\t= \"Emergency Sync\",\n\t.enable_mask\t= SYSRQ_ENABLE_SYNC,\n};\n\nstatic void sysrq_handle_show_timers(u8 key)\n{\n\tsysrq_timer_list_show();\n}\n\nstatic const struct sysrq_key_op sysrq_show_timers_op = {\n\t.handler\t= sysrq_handle_show_timers,\n\t.help_msg\t= \"show-all-timers(q)\",\n\t.action_msg\t= \"Show clockevent devices & pending hrtimers (no others)\",\n};\n\nstatic void sysrq_handle_mountro(u8 key)\n{\n\temergency_remount();\n}\nstatic const struct sysrq_key_op sysrq_mountro_op = {\n\t.handler\t= sysrq_handle_mountro,\n\t.help_msg\t= \"unmount(u)\",\n\t.action_msg\t= \"Emergency Remount R/O\",\n\t.enable_mask\t= SYSRQ_ENABLE_REMOUNT,\n};\n\n#ifdef CONFIG_LOCKDEP\nstatic void sysrq_handle_showlocks(u8 key)\n{\n\tdebug_show_all_locks();\n}\n\nstatic const struct sysrq_key_op sysrq_showlocks_op = {\n\t.handler\t= sysrq_handle_showlocks,\n\t.help_msg\t= \"show-all-locks(d)\",\n\t.action_msg\t= \"Show Locks Held\",\n};\n#else\n#define sysrq_showlocks_op (*(const struct sysrq_key_op *)NULL)\n#endif\n\n#ifdef CONFIG_SMP\nstatic DEFINE_RAW_SPINLOCK(show_lock);\n\nstatic void showacpu(void *dummy)\n{\n\tunsigned long flags;\n\n\t \n\tif (idle_cpu(smp_processor_id())) {\n\t\tpr_info(\"CPU%d: backtrace skipped as idling\\n\", smp_processor_id());\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&show_lock, flags);\n\tpr_info(\"CPU%d:\\n\", smp_processor_id());\n\tshow_stack(NULL, NULL, KERN_INFO);\n\traw_spin_unlock_irqrestore(&show_lock, flags);\n}\n\nstatic void sysrq_showregs_othercpus(struct work_struct *dummy)\n{\n\tsmp_call_function(showacpu, NULL, 0);\n}\n\nstatic DECLARE_WORK(sysrq_showallcpus, sysrq_showregs_othercpus);\n\nstatic void sysrq_handle_showallcpus(u8 key)\n{\n\t \n\tif (!trigger_all_cpu_backtrace()) {\n\t\tstruct pt_regs *regs = NULL;\n\n\t\tif (in_hardirq())\n\t\t\tregs = get_irq_regs();\n\n\t\tpr_info(\"CPU%d:\\n\", get_cpu());\n\t\tif (regs)\n\t\t\tshow_regs(regs);\n\t\telse\n\t\t\tshow_stack(NULL, NULL, KERN_INFO);\n\n\t\tschedule_work(&sysrq_showallcpus);\n\t\tput_cpu();\n\t}\n}\n\nstatic const struct sysrq_key_op sysrq_showallcpus_op = {\n\t.handler\t= sysrq_handle_showallcpus,\n\t.help_msg\t= \"show-backtrace-all-active-cpus(l)\",\n\t.action_msg\t= \"Show backtrace of all active CPUs\",\n\t.enable_mask\t= SYSRQ_ENABLE_DUMP,\n};\n#else\n#define sysrq_showallcpus_op (*(const struct sysrq_key_op *)NULL)\n#endif\n\nstatic void sysrq_handle_showregs(u8 key)\n{\n\tstruct pt_regs *regs = NULL;\n\n\tif (in_hardirq())\n\t\tregs = get_irq_regs();\n\tif (regs)\n\t\tshow_regs(regs);\n\tperf_event_print_debug();\n}\nstatic const struct sysrq_key_op sysrq_showregs_op = {\n\t.handler\t= sysrq_handle_showregs,\n\t.help_msg\t= \"show-registers(p)\",\n\t.action_msg\t= \"Show Regs\",\n\t.enable_mask\t= SYSRQ_ENABLE_DUMP,\n};\n\nstatic void sysrq_handle_showstate(u8 key)\n{\n\tshow_state();\n\tshow_all_workqueues();\n}\nstatic const struct sysrq_key_op sysrq_showstate_op = {\n\t.handler\t= sysrq_handle_showstate,\n\t.help_msg\t= \"show-task-states(t)\",\n\t.action_msg\t= \"Show State\",\n\t.enable_mask\t= SYSRQ_ENABLE_DUMP,\n};\n\nstatic void sysrq_handle_showstate_blocked(u8 key)\n{\n\tshow_state_filter(TASK_UNINTERRUPTIBLE);\n}\nstatic const struct sysrq_key_op sysrq_showstate_blocked_op = {\n\t.handler\t= sysrq_handle_showstate_blocked,\n\t.help_msg\t= \"show-blocked-tasks(w)\",\n\t.action_msg\t= \"Show Blocked State\",\n\t.enable_mask\t= SYSRQ_ENABLE_DUMP,\n};\n\n#ifdef CONFIG_TRACING\n#include <linux/ftrace.h>\n\nstatic void sysrq_ftrace_dump(u8 key)\n{\n\tftrace_dump(DUMP_ALL);\n}\nstatic const struct sysrq_key_op sysrq_ftrace_dump_op = {\n\t.handler\t= sysrq_ftrace_dump,\n\t.help_msg\t= \"dump-ftrace-buffer(z)\",\n\t.action_msg\t= \"Dump ftrace buffer\",\n\t.enable_mask\t= SYSRQ_ENABLE_DUMP,\n};\n#else\n#define sysrq_ftrace_dump_op (*(const struct sysrq_key_op *)NULL)\n#endif\n\nstatic void sysrq_handle_showmem(u8 key)\n{\n\tshow_mem();\n}\nstatic const struct sysrq_key_op sysrq_showmem_op = {\n\t.handler\t= sysrq_handle_showmem,\n\t.help_msg\t= \"show-memory-usage(m)\",\n\t.action_msg\t= \"Show Memory\",\n\t.enable_mask\t= SYSRQ_ENABLE_DUMP,\n};\n\n \nstatic void send_sig_all(int sig)\n{\n\tstruct task_struct *p;\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process(p) {\n\t\tif (p->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tif (is_global_init(p))\n\t\t\tcontinue;\n\n\t\tdo_send_sig_info(sig, SEND_SIG_PRIV, p, PIDTYPE_MAX);\n\t}\n\tread_unlock(&tasklist_lock);\n}\n\nstatic void sysrq_handle_term(u8 key)\n{\n\tsend_sig_all(SIGTERM);\n\tconsole_loglevel = CONSOLE_LOGLEVEL_DEBUG;\n}\nstatic const struct sysrq_key_op sysrq_term_op = {\n\t.handler\t= sysrq_handle_term,\n\t.help_msg\t= \"terminate-all-tasks(e)\",\n\t.action_msg\t= \"Terminate All Tasks\",\n\t.enable_mask\t= SYSRQ_ENABLE_SIGNAL,\n};\n\nstatic void moom_callback(struct work_struct *ignored)\n{\n\tconst gfp_t gfp_mask = GFP_KERNEL;\n\tstruct oom_control oc = {\n\t\t.zonelist = node_zonelist(first_memory_node, gfp_mask),\n\t\t.nodemask = NULL,\n\t\t.memcg = NULL,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = -1,\n\t};\n\n\tmutex_lock(&oom_lock);\n\tif (!out_of_memory(&oc))\n\t\tpr_info(\"OOM request ignored. No task eligible\\n\");\n\tmutex_unlock(&oom_lock);\n}\n\nstatic DECLARE_WORK(moom_work, moom_callback);\n\nstatic void sysrq_handle_moom(u8 key)\n{\n\tschedule_work(&moom_work);\n}\nstatic const struct sysrq_key_op sysrq_moom_op = {\n\t.handler\t= sysrq_handle_moom,\n\t.help_msg\t= \"memory-full-oom-kill(f)\",\n\t.action_msg\t= \"Manual OOM execution\",\n\t.enable_mask\t= SYSRQ_ENABLE_SIGNAL,\n};\n\n#ifdef CONFIG_BLOCK\nstatic void sysrq_handle_thaw(u8 key)\n{\n\temergency_thaw_all();\n}\nstatic const struct sysrq_key_op sysrq_thaw_op = {\n\t.handler\t= sysrq_handle_thaw,\n\t.help_msg\t= \"thaw-filesystems(j)\",\n\t.action_msg\t= \"Emergency Thaw of all frozen filesystems\",\n\t.enable_mask\t= SYSRQ_ENABLE_SIGNAL,\n};\n#else\n#define sysrq_thaw_op (*(const struct sysrq_key_op *)NULL)\n#endif\n\nstatic void sysrq_handle_kill(u8 key)\n{\n\tsend_sig_all(SIGKILL);\n\tconsole_loglevel = CONSOLE_LOGLEVEL_DEBUG;\n}\nstatic const struct sysrq_key_op sysrq_kill_op = {\n\t.handler\t= sysrq_handle_kill,\n\t.help_msg\t= \"kill-all-tasks(i)\",\n\t.action_msg\t= \"Kill All Tasks\",\n\t.enable_mask\t= SYSRQ_ENABLE_SIGNAL,\n};\n\nstatic void sysrq_handle_unrt(u8 key)\n{\n\tnormalize_rt_tasks();\n}\nstatic const struct sysrq_key_op sysrq_unrt_op = {\n\t.handler\t= sysrq_handle_unrt,\n\t.help_msg\t= \"nice-all-RT-tasks(n)\",\n\t.action_msg\t= \"Nice All RT Tasks\",\n\t.enable_mask\t= SYSRQ_ENABLE_RTNICE,\n};\n\n \nstatic DEFINE_SPINLOCK(sysrq_key_table_lock);\n\nstatic const struct sysrq_key_op *sysrq_key_table[62] = {\n\t&sysrq_loglevel_op,\t\t \n\t&sysrq_loglevel_op,\t\t \n\t&sysrq_loglevel_op,\t\t \n\t&sysrq_loglevel_op,\t\t \n\t&sysrq_loglevel_op,\t\t \n\t&sysrq_loglevel_op,\t\t \n\t&sysrq_loglevel_op,\t\t \n\t&sysrq_loglevel_op,\t\t \n\t&sysrq_loglevel_op,\t\t \n\t&sysrq_loglevel_op,\t\t \n\n\t \n\tNULL,\t\t\t\t \n\t&sysrq_reboot_op,\t\t \n\t&sysrq_crash_op,\t\t \n\t&sysrq_showlocks_op,\t\t \n\t&sysrq_term_op,\t\t\t \n\t&sysrq_moom_op,\t\t\t \n\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\t&sysrq_kill_op,\t\t\t \n\t&sysrq_thaw_op,\t\t\t \n\t&sysrq_SAK_op,\t\t\t \n\t&sysrq_showallcpus_op,\t\t \n\t&sysrq_showmem_op,\t\t \n\t&sysrq_unrt_op,\t\t\t \n\t \n\tNULL,\t\t\t\t \n\t&sysrq_showregs_op,\t\t \n\t&sysrq_show_timers_op,\t\t \n\t&sysrq_unraw_op,\t\t \n\t&sysrq_sync_op,\t\t\t \n\t&sysrq_showstate_op,\t\t \n\t&sysrq_mountro_op,\t\t \n\t \n\tNULL,\t\t\t\t \n\t&sysrq_showstate_blocked_op,\t \n\t \n\t \n\t \n\tNULL,\t\t\t\t \n\t \n\tNULL,\t\t\t\t \n\t&sysrq_ftrace_dump_op,\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n};\n\n \nstatic int sysrq_key_table_key2index(u8 key)\n{\n\tswitch (key) {\n\tcase '0' ... '9':\n\t\treturn key - '0';\n\tcase 'a' ... 'z':\n\t\treturn key - 'a' + 10;\n\tcase 'A' ... 'Z':\n\t\treturn key - 'A' + 10 + 26;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n \nstatic const struct sysrq_key_op *__sysrq_get_key_op(u8 key)\n{\n\tconst struct sysrq_key_op *op_p = NULL;\n\tint i;\n\n\ti = sysrq_key_table_key2index(key);\n\tif (i != -1)\n\t\top_p = sysrq_key_table[i];\n\n\treturn op_p;\n}\n\nstatic void __sysrq_put_key_op(u8 key, const struct sysrq_key_op *op_p)\n{\n\tint i = sysrq_key_table_key2index(key);\n\n\tif (i != -1)\n\t\tsysrq_key_table[i] = op_p;\n}\n\nvoid __handle_sysrq(u8 key, bool check_mask)\n{\n\tconst struct sysrq_key_op *op_p;\n\tint orig_log_level;\n\tint orig_suppress_printk;\n\tint i;\n\n\torig_suppress_printk = suppress_printk;\n\tsuppress_printk = 0;\n\n\trcu_sysrq_start();\n\trcu_read_lock();\n\t \n\torig_log_level = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_DEFAULT;\n\n\top_p = __sysrq_get_key_op(key);\n\tif (op_p) {\n\t\t \n\t\tif (!check_mask || sysrq_on_mask(op_p->enable_mask)) {\n\t\t\tpr_info(\"%s\\n\", op_p->action_msg);\n\t\t\tconsole_loglevel = orig_log_level;\n\t\t\top_p->handler(key);\n\t\t} else {\n\t\t\tpr_info(\"This sysrq operation is disabled.\\n\");\n\t\t\tconsole_loglevel = orig_log_level;\n\t\t}\n\t} else {\n\t\tpr_info(\"HELP : \");\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(sysrq_key_table); i++) {\n\t\t\tif (sysrq_key_table[i]) {\n\t\t\t\tint j;\n\n\t\t\t\tfor (j = 0; sysrq_key_table[i] !=\n\t\t\t\t\t\tsysrq_key_table[j]; j++)\n\t\t\t\t\t;\n\t\t\t\tif (j != i)\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\"%s \", sysrq_key_table[i]->help_msg);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t\tconsole_loglevel = orig_log_level;\n\t}\n\trcu_read_unlock();\n\trcu_sysrq_end();\n\n\tsuppress_printk = orig_suppress_printk;\n}\n\nvoid handle_sysrq(u8 key)\n{\n\tif (sysrq_on())\n\t\t__handle_sysrq(key, true);\n}\nEXPORT_SYMBOL(handle_sysrq);\n\n#ifdef CONFIG_INPUT\nstatic int sysrq_reset_downtime_ms;\n\n \nstatic const unsigned char sysrq_xlate[KEY_CNT] =\n\t\"\\000\\0331234567890-=\\177\\t\"                     \n\t\"qwertyuiop[]\\r\\000as\"                           \n\t\"dfghjkl;'`\\000\\\\zxcv\"                           \n\t\"bnm,./\\000*\\000 \\000\\201\\202\\203\\204\\205\"       \n\t\"\\206\\207\\210\\211\\212\\000\\000789-456+1\"          \n\t\"230\\177\\000\\000\\213\\214\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"  \n\t\"\\r\\000/\";                                       \n\nstruct sysrq_state {\n\tstruct input_handle handle;\n\tstruct work_struct reinject_work;\n\tunsigned long key_down[BITS_TO_LONGS(KEY_CNT)];\n\tunsigned int alt;\n\tunsigned int alt_use;\n\tunsigned int shift;\n\tunsigned int shift_use;\n\tbool active;\n\tbool need_reinject;\n\tbool reinjecting;\n\n\t \n\tbool reset_canceled;\n\tbool reset_requested;\n\tunsigned long reset_keybit[BITS_TO_LONGS(KEY_CNT)];\n\tint reset_seq_len;\n\tint reset_seq_cnt;\n\tint reset_seq_version;\n\tstruct timer_list keyreset_timer;\n};\n\n#define SYSRQ_KEY_RESET_MAX\t20  \nstatic unsigned short sysrq_reset_seq[SYSRQ_KEY_RESET_MAX];\nstatic unsigned int sysrq_reset_seq_len;\nstatic unsigned int sysrq_reset_seq_version = 1;\n\nstatic void sysrq_parse_reset_sequence(struct sysrq_state *state)\n{\n\tint i;\n\tunsigned short key;\n\n\tstate->reset_seq_cnt = 0;\n\n\tfor (i = 0; i < sysrq_reset_seq_len; i++) {\n\t\tkey = sysrq_reset_seq[i];\n\n\t\tif (key == KEY_RESERVED || key > KEY_MAX)\n\t\t\tbreak;\n\n\t\t__set_bit(key, state->reset_keybit);\n\t\tstate->reset_seq_len++;\n\n\t\tif (test_bit(key, state->key_down))\n\t\t\tstate->reset_seq_cnt++;\n\t}\n\n\t \n\tstate->reset_canceled = state->reset_seq_cnt != 0;\n\n\tstate->reset_seq_version = sysrq_reset_seq_version;\n}\n\nstatic void sysrq_do_reset(struct timer_list *t)\n{\n\tstruct sysrq_state *state = from_timer(state, t, keyreset_timer);\n\n\tstate->reset_requested = true;\n\n\torderly_reboot();\n}\n\nstatic void sysrq_handle_reset_request(struct sysrq_state *state)\n{\n\tif (state->reset_requested)\n\t\t__handle_sysrq(sysrq_xlate[KEY_B], false);\n\n\tif (sysrq_reset_downtime_ms)\n\t\tmod_timer(&state->keyreset_timer,\n\t\t\tjiffies + msecs_to_jiffies(sysrq_reset_downtime_ms));\n\telse\n\t\tsysrq_do_reset(&state->keyreset_timer);\n}\n\nstatic void sysrq_detect_reset_sequence(struct sysrq_state *state,\n\t\t\t\t\tunsigned int code, int value)\n{\n\tif (!test_bit(code, state->reset_keybit)) {\n\t\t \n\t\tif (value && state->reset_seq_cnt) {\n\t\t\tstate->reset_canceled = true;\n\t\t\tdel_timer(&state->keyreset_timer);\n\t\t}\n\t} else if (value == 0) {\n\t\t \n\t\tdel_timer(&state->keyreset_timer);\n\n\t\tif (--state->reset_seq_cnt == 0)\n\t\t\tstate->reset_canceled = false;\n\t} else if (value == 1) {\n\t\t \n\t\tif (++state->reset_seq_cnt == state->reset_seq_len &&\n\t\t    !state->reset_canceled) {\n\t\t\tsysrq_handle_reset_request(state);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_OF\nstatic void sysrq_of_get_keyreset_config(void)\n{\n\tu32 key;\n\tstruct device_node *np;\n\tstruct property *prop;\n\tconst __be32 *p;\n\n\tnp = of_find_node_by_path(\"/chosen/linux,sysrq-reset-seq\");\n\tif (!np) {\n\t\tpr_debug(\"No sysrq node found\");\n\t\treturn;\n\t}\n\n\t \n\tsysrq_reset_seq_len = 0;\n\n\tof_property_for_each_u32(np, \"keyset\", prop, p, key) {\n\t\tif (key == KEY_RESERVED || key > KEY_MAX ||\n\t\t    sysrq_reset_seq_len == SYSRQ_KEY_RESET_MAX)\n\t\t\tbreak;\n\n\t\tsysrq_reset_seq[sysrq_reset_seq_len++] = (unsigned short)key;\n\t}\n\n\t \n\tof_property_read_u32(np, \"timeout-ms\", &sysrq_reset_downtime_ms);\n\n\tof_node_put(np);\n}\n#else\nstatic void sysrq_of_get_keyreset_config(void)\n{\n}\n#endif\n\nstatic void sysrq_reinject_alt_sysrq(struct work_struct *work)\n{\n\tstruct sysrq_state *sysrq =\n\t\t\tcontainer_of(work, struct sysrq_state, reinject_work);\n\tstruct input_handle *handle = &sysrq->handle;\n\tunsigned int alt_code = sysrq->alt_use;\n\n\tif (sysrq->need_reinject) {\n\t\t \n\t\tsysrq->reinjecting = true;\n\t\tmb();\n\n\t\t \n\t\tinput_inject_event(handle, EV_KEY, alt_code, 1);\n\t\tinput_inject_event(handle, EV_KEY, KEY_SYSRQ, 1);\n\t\tinput_inject_event(handle, EV_SYN, SYN_REPORT, 1);\n\n\t\tinput_inject_event(handle, EV_KEY, KEY_SYSRQ, 0);\n\t\tinput_inject_event(handle, EV_KEY, alt_code, 0);\n\t\tinput_inject_event(handle, EV_SYN, SYN_REPORT, 1);\n\n\t\tmb();\n\t\tsysrq->reinjecting = false;\n\t}\n}\n\nstatic bool sysrq_handle_keypress(struct sysrq_state *sysrq,\n\t\t\t\t  unsigned int code, int value)\n{\n\tbool was_active = sysrq->active;\n\tbool suppress;\n\n\tswitch (code) {\n\n\tcase KEY_LEFTALT:\n\tcase KEY_RIGHTALT:\n\t\tif (!value) {\n\t\t\t \n\t\t\tif (sysrq->active && code == sysrq->alt_use)\n\t\t\t\tsysrq->active = false;\n\n\t\t\tsysrq->alt = KEY_RESERVED;\n\n\t\t} else if (value != 2) {\n\t\t\tsysrq->alt = code;\n\t\t\tsysrq->need_reinject = false;\n\t\t}\n\t\tbreak;\n\n\tcase KEY_LEFTSHIFT:\n\tcase KEY_RIGHTSHIFT:\n\t\tif (!value)\n\t\t\tsysrq->shift = KEY_RESERVED;\n\t\telse if (value != 2)\n\t\t\tsysrq->shift = code;\n\t\tif (sysrq->active)\n\t\t\tsysrq->shift_use = sysrq->shift;\n\t\tbreak;\n\n\tcase KEY_SYSRQ:\n\t\tif (value == 1 && sysrq->alt != KEY_RESERVED) {\n\t\t\tsysrq->active = true;\n\t\t\tsysrq->alt_use = sysrq->alt;\n\t\t\t \n\t\t\tsysrq->shift_use = sysrq->shift;\n\t\t\t \n\t\t\tsysrq->need_reinject = true;\n\t\t}\n\n\t\t \n\t\tif (sysrq->active)\n\t\t\tclear_bit(KEY_SYSRQ, sysrq->handle.dev->key);\n\n\t\tbreak;\n\n\tdefault:\n\t\tif (sysrq->active && value && value != 2) {\n\t\t\tunsigned char c = sysrq_xlate[code];\n\n\t\t\tsysrq->need_reinject = false;\n\t\t\tif (sysrq->shift_use != KEY_RESERVED)\n\t\t\t\tc = toupper(c);\n\t\t\t__handle_sysrq(c, true);\n\t\t}\n\t\tbreak;\n\t}\n\n\tsuppress = sysrq->active;\n\n\tif (!sysrq->active) {\n\n\t\t \n\t\tif (sysrq->reset_seq_version != sysrq_reset_seq_version)\n\t\t\tsysrq_parse_reset_sequence(sysrq);\n\n\t\t \n\t\tif (value)\n\t\t\tset_bit(code, sysrq->key_down);\n\t\telse\n\t\t\tclear_bit(code, sysrq->key_down);\n\n\t\tif (was_active)\n\t\t\tschedule_work(&sysrq->reinject_work);\n\n\t\t \n\t\tsysrq_detect_reset_sequence(sysrq, code, value);\n\n\t} else if (value == 0 && test_and_clear_bit(code, sysrq->key_down)) {\n\t\t \n\t\tsuppress = false;\n\t}\n\n\treturn suppress;\n}\n\nstatic bool sysrq_filter(struct input_handle *handle,\n\t\t\t unsigned int type, unsigned int code, int value)\n{\n\tstruct sysrq_state *sysrq = handle->private;\n\tbool suppress;\n\n\t \n\tif (sysrq->reinjecting)\n\t\treturn false;\n\n\tswitch (type) {\n\n\tcase EV_SYN:\n\t\tsuppress = false;\n\t\tbreak;\n\n\tcase EV_KEY:\n\t\tsuppress = sysrq_handle_keypress(sysrq, code, value);\n\t\tbreak;\n\n\tdefault:\n\t\tsuppress = sysrq->active;\n\t\tbreak;\n\t}\n\n\treturn suppress;\n}\n\nstatic int sysrq_connect(struct input_handler *handler,\n\t\t\t struct input_dev *dev,\n\t\t\t const struct input_device_id *id)\n{\n\tstruct sysrq_state *sysrq;\n\tint error;\n\n\tsysrq = kzalloc(sizeof(struct sysrq_state), GFP_KERNEL);\n\tif (!sysrq)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&sysrq->reinject_work, sysrq_reinject_alt_sysrq);\n\n\tsysrq->handle.dev = dev;\n\tsysrq->handle.handler = handler;\n\tsysrq->handle.name = \"sysrq\";\n\tsysrq->handle.private = sysrq;\n\ttimer_setup(&sysrq->keyreset_timer, sysrq_do_reset, 0);\n\n\terror = input_register_handle(&sysrq->handle);\n\tif (error) {\n\t\tpr_err(\"Failed to register input sysrq handler, error %d\\n\",\n\t\t\terror);\n\t\tgoto err_free;\n\t}\n\n\terror = input_open_device(&sysrq->handle);\n\tif (error) {\n\t\tpr_err(\"Failed to open input device, error %d\\n\", error);\n\t\tgoto err_unregister;\n\t}\n\n\treturn 0;\n\n err_unregister:\n\tinput_unregister_handle(&sysrq->handle);\n err_free:\n\tkfree(sysrq);\n\treturn error;\n}\n\nstatic void sysrq_disconnect(struct input_handle *handle)\n{\n\tstruct sysrq_state *sysrq = handle->private;\n\n\tinput_close_device(handle);\n\tcancel_work_sync(&sysrq->reinject_work);\n\ttimer_shutdown_sync(&sysrq->keyreset_timer);\n\tinput_unregister_handle(handle);\n\tkfree(sysrq);\n}\n\n \nstatic const struct input_device_id sysrq_ids[] = {\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_KEYBIT,\n\t\t.evbit = { [BIT_WORD(EV_KEY)] = BIT_MASK(EV_KEY) },\n\t\t.keybit = { [BIT_WORD(KEY_LEFTALT)] = BIT_MASK(KEY_LEFTALT) },\n\t},\n\t{ },\n};\n\nstatic struct input_handler sysrq_handler = {\n\t.filter\t\t= sysrq_filter,\n\t.connect\t= sysrq_connect,\n\t.disconnect\t= sysrq_disconnect,\n\t.name\t\t= \"sysrq\",\n\t.id_table\t= sysrq_ids,\n};\n\nstatic inline void sysrq_register_handler(void)\n{\n\tint error;\n\n\tsysrq_of_get_keyreset_config();\n\n\terror = input_register_handler(&sysrq_handler);\n\tif (error)\n\t\tpr_err(\"Failed to register input handler, error %d\", error);\n}\n\nstatic inline void sysrq_unregister_handler(void)\n{\n\tinput_unregister_handler(&sysrq_handler);\n}\n\nstatic int sysrq_reset_seq_param_set(const char *buffer,\n\t\t\t\t     const struct kernel_param *kp)\n{\n\tunsigned long val;\n\tint error;\n\n\terror = kstrtoul(buffer, 0, &val);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (val > KEY_MAX)\n\t\treturn -EINVAL;\n\n\t*((unsigned short *)kp->arg) = val;\n\tsysrq_reset_seq_version++;\n\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops param_ops_sysrq_reset_seq = {\n\t.get\t= param_get_ushort,\n\t.set\t= sysrq_reset_seq_param_set,\n};\n\n#define param_check_sysrq_reset_seq(name, p)\t\\\n\t__param_check(name, p, unsigned short)\n\n \nmodule_param_array_named(reset_seq, sysrq_reset_seq, sysrq_reset_seq,\n\t\t\t &sysrq_reset_seq_len, 0644);\n\nmodule_param_named(sysrq_downtime_ms, sysrq_reset_downtime_ms, int, 0644);\n\n#else\n\nstatic inline void sysrq_register_handler(void)\n{\n}\n\nstatic inline void sysrq_unregister_handler(void)\n{\n}\n\n#endif  \n\nint sysrq_toggle_support(int enable_mask)\n{\n\tbool was_enabled = sysrq_on();\n\n\tsysrq_enabled = enable_mask;\n\n\tif (was_enabled != sysrq_on()) {\n\t\tif (sysrq_on())\n\t\t\tsysrq_register_handler();\n\t\telse\n\t\t\tsysrq_unregister_handler();\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sysrq_toggle_support);\n\nstatic int __sysrq_swap_key_ops(u8 key, const struct sysrq_key_op *insert_op_p,\n\t\t\t\tconst struct sysrq_key_op *remove_op_p)\n{\n\tint retval;\n\n\tspin_lock(&sysrq_key_table_lock);\n\tif (__sysrq_get_key_op(key) == remove_op_p) {\n\t\t__sysrq_put_key_op(key, insert_op_p);\n\t\tretval = 0;\n\t} else {\n\t\tretval = -1;\n\t}\n\tspin_unlock(&sysrq_key_table_lock);\n\n\t \n\tsynchronize_rcu();\n\n\treturn retval;\n}\n\nint register_sysrq_key(u8 key, const struct sysrq_key_op *op_p)\n{\n\treturn __sysrq_swap_key_ops(key, op_p, NULL);\n}\nEXPORT_SYMBOL(register_sysrq_key);\n\nint unregister_sysrq_key(u8 key, const struct sysrq_key_op *op_p)\n{\n\treturn __sysrq_swap_key_ops(key, NULL, op_p);\n}\nEXPORT_SYMBOL(unregister_sysrq_key);\n\n#ifdef CONFIG_PROC_FS\n \nstatic ssize_t write_sysrq_trigger(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tif (count) {\n\t\tchar c;\n\n\t\tif (get_user(c, buf))\n\t\t\treturn -EFAULT;\n\t\t__handle_sysrq(c, false);\n\t}\n\n\treturn count;\n}\n\nstatic const struct proc_ops sysrq_trigger_proc_ops = {\n\t.proc_write\t= write_sysrq_trigger,\n\t.proc_lseek\t= noop_llseek,\n};\n\nstatic void sysrq_init_procfs(void)\n{\n\tif (!proc_create(\"sysrq-trigger\", S_IWUSR, NULL,\n\t\t\t &sysrq_trigger_proc_ops))\n\t\tpr_err(\"Failed to register proc interface\\n\");\n}\n\n#else\n\nstatic inline void sysrq_init_procfs(void)\n{\n}\n\n#endif  \n\nstatic int __init sysrq_init(void)\n{\n\tsysrq_init_procfs();\n\n\tif (sysrq_on())\n\t\tsysrq_register_handler();\n\n\treturn 0;\n}\ndevice_initcall(sysrq_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}