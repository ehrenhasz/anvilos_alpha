{
  "module_name": "Kconfig",
  "hash_id": "3f3e6477721bc9c084e9ee91be6f973248533dbe32574484238909166de3b4d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\nconfig TTY\n\tbool \"Enable TTY\" if EXPERT\n\tdefault y\n\thelp\n\t  Allows you to remove TTY support which can save space, and\n\t  blocks features that require TTY from inclusion in the kernel.\n\t  TTY is required for any text terminals or serial port\n\t  communication. Most users should leave this enabled.\n\nif TTY\n\nconfig VT\n\tbool \"Virtual terminal\" if EXPERT\n\tselect INPUT\n\tdefault y if !UML\n\thelp\n\t  If you say Y here, you will get support for terminal devices with\n\t  display and keyboard devices. These are called \"virtual\" because you\n\t  can run several virtual terminals (also called virtual consoles) on\n\t  one physical terminal. This is rather useful, for example one\n\t  virtual terminal can collect system messages and warnings, another\n\t  one can be used for a text-mode user session, and a third could run\n\t  an X session, all in parallel. Switching between virtual terminals\n\t  is done with certain key combinations, usually Alt-<function key>.\n\n\t  The setterm command (\"man setterm\") can be used to change the\n\t  properties (such as colors or beeping) of a virtual terminal. The\n\t  man page console_codes(4) (\"man console_codes\") contains the special\n\t  character sequences that can be used to change those properties\n\t  directly. The fonts used on virtual terminals can be changed with\n\t  the setfont (\"man setfont\") command and the key bindings are defined\n\t  with the loadkeys (\"man loadkeys\") command.\n\n\t  You need at least one virtual terminal device in order to make use\n\t  of your keyboard and monitor. Therefore, only people configuring an\n\t  embedded system would want to say N here in order to save some\n\t  memory; the only way to log into such a system is then via a serial\n\t  or network connection.\n\n\t  If unsure, say Y, or else you won't be able to do much with your new\n\t  shiny Linux system :-)\n\nconfig CONSOLE_TRANSLATIONS\n\tdepends on VT\n\tdefault y\n\tbool \"Enable character translations in console\" if EXPERT\n\thelp\n\t  This enables support for font mapping and Unicode translation\n\t  on virtual consoles.\n\nconfig VT_CONSOLE\n\tbool \"Support for console on virtual terminal\" if EXPERT\n\tdepends on VT\n\tdefault y\n\thelp\n\t  The system console is the device which receives all kernel messages\n\t  and warnings and which allows logins in single user mode. If you\n\t  answer Y here, a virtual terminal (the device used to interact with\n\t  a physical terminal) can be used as system console. This is the most\n\t  common mode of operations, so you should say Y here unless you want\n\t  the kernel messages be output only to a serial port (in which case\n\t  you should say Y to \"Console on serial port\", below).\n\n\t  If you do say Y here, by default the currently visible virtual\n\t  terminal (/dev/tty0) will be used as system console. You can change\n\t  that with a kernel command line option such as \"console=tty3\" which\n\t  would use the third virtual terminal as system console. (Try \"man\n\t  bootparam\" or see the documentation of your boot loader (lilo or\n\t  loadlin) about how to pass options to the kernel at boot time.)\n\n\t  If unsure, say Y.\n\nconfig VT_CONSOLE_SLEEP\n\tdef_bool y\n\tdepends on VT_CONSOLE && PM_SLEEP\n\nconfig HW_CONSOLE\n\tbool\n\tdepends on VT\n\tdefault y\n\nconfig VT_HW_CONSOLE_BINDING\n\tbool \"Support for binding and unbinding console drivers\"\n\tdepends on HW_CONSOLE\n\thelp\n\t  The virtual terminal is the device that interacts with the physical\n\t  terminal through console drivers. On these systems, at least one\n\t  console driver is loaded. In other configurations, additional console\n\t  drivers may be enabled, such as the framebuffer console. If more than\n\t  1 console driver is enabled, setting this to 'y' will allow you to\n\t  select the console driver that will serve as the backend for the\n\t  virtual terminals.\n\n\t  See <file:Documentation/driver-api/console.rst> for more\n\t  information. For framebuffer console users, please refer to\n\t  <file:Documentation/fb/fbcon.rst>.\n\nconfig UNIX98_PTYS\n\tbool \"Unix98 PTY support\" if EXPERT\n\tdefault y\n\thelp\n\t  A pseudo terminal (PTY) is a software device consisting of two\n\t  halves: a master and a slave. The slave device behaves identical to\n\t  a physical terminal; the master device is used by a process to\n\t  read data from and write data to the slave, thereby emulating a\n\t  terminal. Typical programs for the master side are telnet servers\n\t  and xterms.\n\n\t  Linux has traditionally used the BSD-like names /dev/ptyxx for\n\t  masters and /dev/ttyxx for slaves of pseudo terminals. This scheme\n\t  has a number of problems. The GNU C library glibc 2.1 and later,\n\t  however, supports the Unix98 naming standard: in order to acquire a\n\t  pseudo terminal, a process opens /dev/ptmx; the number of the pseudo\n\t  terminal is then made available to the process and the pseudo\n\t  terminal slave can be accessed as /dev/pts/<number>. What was\n\t  traditionally /dev/ttyp2 will then be /dev/pts/2, for example.\n\n\t  All modern Linux systems use the Unix98 ptys.  Say Y unless\n\t  you're on an embedded system and want to conserve memory.\n\nconfig LEGACY_PTYS\n\tbool \"Legacy (BSD) PTY support\"\n\tdefault y\n\thelp\n\t  A pseudo terminal (PTY) is a software device consisting of two\n\t  halves: a master and a slave. The slave device behaves identical to\n\t  a physical terminal; the master device is used by a process to\n\t  read data from and write data to the slave, thereby emulating a\n\t  terminal. Typical programs for the master side are telnet servers\n\t  and xterms.\n\n\t  Linux has traditionally used the BSD-like names /dev/ptyxx\n\t  for masters and /dev/ttyxx for slaves of pseudo\n\t  terminals. This scheme has a number of problems, including\n\t  security.  This option enables these legacy devices; on most\n\t  systems, it is safe to say N.\n\nconfig LEGACY_PTY_COUNT\n\tint \"Maximum number of legacy PTY in use\"\n\tdepends on LEGACY_PTYS\n\trange 0 256\n\tdefault \"256\"\n\thelp\n\t  The maximum number of legacy PTYs that can be used at any one time.\n\t  The default is 256, and should be more than enough.  Embedded\n\t  systems may want to reduce this to save memory.\n\n\t  When not in use, each legacy PTY occupies 12 bytes on 32-bit\n\t  architectures and 24 bytes on 64-bit architectures.\n\nconfig LEGACY_TIOCSTI\n\tbool \"Allow legacy TIOCSTI usage\"\n\tdefault y\n\thelp\n\t  Historically the kernel has allowed TIOCSTI, which will push\n\t  characters into a controlling TTY. This continues to be used\n\t  as a malicious privilege escalation mechanism, and provides no\n\t  meaningful real-world utility any more. Its use is considered\n\t  a dangerous legacy operation, and can be disabled on most\n\t  systems.\n\n\t  Say Y here only if you have confirmed that your system's\n\t  userspace depends on this functionality to continue operating\n\t  normally.\n\n\t  Processes which run with CAP_SYS_ADMIN, such as BRLTTY, can\n\t  use TIOCSTI even when this is set to N.\n\n\t  This functionality can be changed at runtime with the\n\t  dev.tty.legacy_tiocsti sysctl. This configuration option sets\n\t  the default value of the sysctl.\n\nconfig LDISC_AUTOLOAD\n\tbool \"Automatically load TTY Line Disciplines\"\n\tdefault y\n\thelp\n\t  Historically the kernel has always automatically loaded any\n\t  line discipline that is in a kernel module when a user asks\n\t  for it to be loaded with the TIOCSETD ioctl, or through other\n\t  means.  This is not always the best thing to do on systems\n\t  where you know you will not be using some of the more\n\t  \"ancient\" line disciplines, so prevent the kernel from doing\n\t  this unless the request is coming from a process with the\n\t  CAP_SYS_MODULE permissions.\n\n\t  Say 'Y' here if you trust your userspace users to do the right\n\t  thing, or if you have only provided the line disciplines that\n\t  you know you will be using, or if you wish to continue to use\n\t  the traditional method of on-demand loading of these modules\n\t  by any user.\n\n\t  This functionality can be changed at runtime with the\n\t  dev.tty.ldisc_autoload sysctl, this configuration option will\n\t  only set the default value of this functionality.\n\nsource \"drivers/tty/serial/Kconfig\"\n\nconfig SERIAL_NONSTANDARD\n\tbool \"Non-standard serial port support\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  Say Y here if you have any non-standard serial boards -- boards\n\t  which aren't supported using the standard \"dumb\" serial driver.\n\t  This includes intelligent serial boards such as\n\t  Digiboards, etc. These are usually used for systems that need many\n\t  serial ports because they serve many terminals or dial-in\n\t  connections.\n\n\t  Note that the answer to this question won't directly affect the\n\t  kernel: saying N will just cause the configurator to skip all\n\t  the questions about non-standard serial boards.\n\n\t  Most people can say N here.\n\nconfig MOXA_INTELLIO\n\ttristate \"Moxa Intellio support\"\n\tdepends on SERIAL_NONSTANDARD && (ISA || EISA || PCI)\n\tselect FW_LOADER\n\thelp\n\t  Say Y here if you have a Moxa Intellio multiport serial card.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called moxa.\n\nconfig MOXA_SMARTIO\n\ttristate \"Moxa SmartIO support v. 2.0\"\n\tdepends on SERIAL_NONSTANDARD && PCI\n\thelp\n\t  Say Y here if you have a Moxa SmartIO multiport serial card and/or\n\t  want to help develop a new version of this driver.\n\n\t  This is upgraded (1.9.1) driver from original Moxa drivers with\n\t  changes finally resulting in PCI probing.\n\n\t  This driver can also be built as a module. The module will be called\n\t  mxser. If you want to do that, say M here.\n\nconfig SYNCLINK_GT\n\ttristate \"SyncLink GT/AC support\"\n\tdepends on SERIAL_NONSTANDARD && PCI\n\tdepends on BROKEN\n\thelp\n\t  Support for SyncLink GT and SyncLink AC families of\n\t  synchronous and asynchronous serial adapters\n\t  manufactured by Microgate Systems, Ltd. (www.microgate.com)\n\nconfig N_HDLC\n\ttristate \"HDLC line discipline support\"\n\tdepends on SERIAL_NONSTANDARD\n\thelp\n\t  Allows synchronous HDLC communications with tty device drivers that\n\t  support synchronous HDLC such as the Microgate SyncLink adapter.\n\n\t  This driver can be built as a module ( = code which can be\n\t  inserted in and removed from the running kernel whenever you want).\n\t  The module will be called n_hdlc. If you want to do that, say M\n\t  here.\n\nconfig PPC_EPAPR_HV_BYTECHAN\n\tbool \"ePAPR hypervisor byte channel driver\"\n\tdepends on PPC\n\tselect EPAPR_PARAVIRT\n\thelp\n\t  This driver creates /dev entries for each ePAPR hypervisor byte\n\t  channel, thereby allowing applications to communicate with byte\n\t  channels as if they were serial ports.\n\nconfig PPC_EARLY_DEBUG_EHV_BC\n\tbool \"Early console (udbg) support for ePAPR hypervisors\"\n\tdepends on PPC_EPAPR_HV_BYTECHAN=y\n\thelp\n\t  Select this option to enable early console (a.k.a. \"udbg\") support\n\t  via an ePAPR byte channel.  You also need to choose the byte channel\n\t  handle below.\n\nconfig PPC_EARLY_DEBUG_EHV_BC_HANDLE\n\tint \"Byte channel handle for early console (udbg)\"\n\tdepends on PPC_EARLY_DEBUG_EHV_BC\n\tdefault 0\n\thelp\n\t  If you want early console (udbg) output through a byte channel,\n\t  specify the handle of the byte channel to use.\n\n\t  For this to work, the byte channel driver must be compiled\n\t  in-kernel, not as a module.\n\n\t  Note that only one early console driver can be enabled, so don't\n\t  enable any others if you enable this one.\n\n\t  If the number you specify is not a valid byte channel handle, then\n\t  there simply will be no early console output.  This is true also\n\t  if you don't boot under a hypervisor at all.\n\nconfig GOLDFISH_TTY\n\ttristate \"Goldfish TTY Driver\"\n\tdepends on GOLDFISH\n\tselect SERIAL_CORE\n\tselect SERIAL_CORE_CONSOLE\n\thelp\n\t  Console and system TTY driver for the Goldfish virtual platform.\n\nconfig GOLDFISH_TTY_EARLY_CONSOLE\n\tbool\n\tdefault y if GOLDFISH_TTY=y\n\tselect SERIAL_EARLYCON\n\nconfig IPWIRELESS\n\ttristate \"IPWireless 3G UMTS PCMCIA card support\"\n\tdepends on PCMCIA && NETDEVICES\n\tselect PPP\n\thelp\n\t  This is a driver for 3G UMTS PCMCIA card from IPWireless company. In\n\t  some countries (for example Czech Republic, T-Mobile ISP) this card\n\t  is shipped for service called UMTS 4G.\n\nconfig N_GSM\n\ttristate \"GSM MUX line discipline support (EXPERIMENTAL)\"\n\tdepends on NET\n\thelp\n\t  This line discipline provides support for the GSM MUX protocol and\n\t  presents the mux as a set of 61 individual tty devices.\n\nconfig NOZOMI\n\ttristate \"HSDPA Broadband Wireless Data Card - Globe Trotter\"\n\tdepends on PCI\n\thelp\n\t  If you have a HSDPA driver Broadband Wireless Data Card -\n\t  Globe Trotter PCMCIA card, say Y here.\n\n\t  To compile this driver as a module, choose M here, the module\n\t  will be called nozomi.\n\nconfig MIPS_EJTAG_FDC_TTY\n\tbool \"MIPS EJTAG Fast Debug Channel TTY\"\n\tdepends on MIPS_CDMM\n\thelp\n\t  This enables a TTY and console on the MIPS EJTAG Fast Debug Channels,\n\t  if they are present. This can be useful when working with an EJTAG\n\t  probe which supports it, to get console output and a login prompt via\n\t  EJTAG without needing to connect a serial cable.\n\n\t  TTY devices are named e.g. ttyFDC3c2 (for FDC channel 2 of the FDC on\n\t  CPU3).\n\n\t  The console can be enabled with console=fdc1 (for FDC channel 1 on all\n\t  CPUs). Do not use the console unless there is a debug probe attached\n\t  to drain the FDC TX FIFO.\n\n\t  If unsure, say N.\n\nconfig MIPS_EJTAG_FDC_EARLYCON\n\tbool \"Early FDC console\"\n\tdepends on MIPS_EJTAG_FDC_TTY\n\thelp\n\t  This registers a console on FDC channel 1 very early during boot (from\n\t  MIPS arch code). This is useful for bring-up and debugging early boot\n\t  issues.\n\n\t  Do not enable unless there is a debug probe attached to drain the FDC\n\t  TX FIFO.\n\n\t  If unsure, say N.\n\nconfig MIPS_EJTAG_FDC_KGDB\n\tbool \"Use KGDB over an FDC channel\"\n\tdepends on MIPS_EJTAG_FDC_TTY && KGDB\n\tdefault y\n\thelp\n\t  This enables the use of KGDB over an FDC channel, allowing KGDB to be\n\t  used remotely or when a serial port isn't available.\n\nconfig MIPS_EJTAG_FDC_KGDB_CHAN\n\tint \"KGDB FDC channel\"\n\tdepends on MIPS_EJTAG_FDC_KGDB\n\trange 2 15\n\tdefault 3\n\thelp\n\t  FDC channel number to use for KGDB.\n\nconfig NULL_TTY\n\ttristate \"NULL TTY driver\"\n\thelp\n\t  Say Y here if you want a NULL TTY which simply discards messages.\n\n\t  This is useful to allow userspace applications which expect a console\n\t  device to work without modifications even when no console is\n\t  available or desired.\n\n\t  In order to use this driver, you should redirect the console to this\n\t  TTY, or boot the kernel with console=ttynull.\n\n\t  If unsure, say N.\n\nconfig VCC\n\ttristate \"Sun Virtual Console Concentrator\"\n\tdepends on SUN_LDOMS\n\thelp\n\t  Support for Sun logical domain consoles.\n\nsource \"drivers/tty/hvc/Kconfig\"\n\nconfig RPMSG_TTY\n\ttristate \"RPMSG tty driver\"\n\tdepends on RPMSG\n\thelp\n\t  Say y here to export rpmsg endpoints as tty devices, usually found\n\t  in /dev/ttyRPMSGx.\n\t  This makes it possible for user-space programs to send and receive\n\t  rpmsg messages as a standard tty protocol.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called rpmsg_tty.\n\nendif # TTY\n\nsource \"drivers/tty/serdev/Kconfig\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}