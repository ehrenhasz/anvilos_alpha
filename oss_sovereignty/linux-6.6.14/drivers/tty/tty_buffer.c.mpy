{
  "module_name": "tty_buffer.c",
  "hash_id": "a3e59e00de1ecdd8aa872abb94479ea8c588e9d3eeba5ec9ffc3299ae580b1b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/tty_buffer.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/minmax.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/ratelimit.h>\n#include \"tty.h\"\n\n#define MIN_TTYB_SIZE\t256\n#define TTYB_ALIGN_MASK\t0xff\n\n \n#define TTYB_DEFAULT_MEM_LIMIT\t(640 * 1024UL)\n\n \n\n#define TTY_BUFFER_PAGE\t(((PAGE_SIZE - sizeof(struct tty_buffer)) / 2) & ~TTYB_ALIGN_MASK)\n\n \nvoid tty_buffer_lock_exclusive(struct tty_port *port)\n{\n\tstruct tty_bufhead *buf = &port->buf;\n\n\tatomic_inc(&buf->priority);\n\tmutex_lock(&buf->lock);\n}\nEXPORT_SYMBOL_GPL(tty_buffer_lock_exclusive);\n\n \nvoid tty_buffer_unlock_exclusive(struct tty_port *port)\n{\n\tstruct tty_bufhead *buf = &port->buf;\n\tint restart;\n\n\trestart = buf->head->commit != buf->head->read;\n\n\tatomic_dec(&buf->priority);\n\tmutex_unlock(&buf->lock);\n\tif (restart)\n\t\tqueue_work(system_unbound_wq, &buf->work);\n}\nEXPORT_SYMBOL_GPL(tty_buffer_unlock_exclusive);\n\n \nunsigned int tty_buffer_space_avail(struct tty_port *port)\n{\n\tint space = port->buf.mem_limit - atomic_read(&port->buf.mem_used);\n\n\treturn max(space, 0);\n}\nEXPORT_SYMBOL_GPL(tty_buffer_space_avail);\n\nstatic void tty_buffer_reset(struct tty_buffer *p, size_t size)\n{\n\tp->used = 0;\n\tp->size = size;\n\tp->next = NULL;\n\tp->commit = 0;\n\tp->lookahead = 0;\n\tp->read = 0;\n\tp->flags = true;\n}\n\n \nvoid tty_buffer_free_all(struct tty_port *port)\n{\n\tstruct tty_bufhead *buf = &port->buf;\n\tstruct tty_buffer *p, *next;\n\tstruct llist_node *llist;\n\tunsigned int freed = 0;\n\tint still_used;\n\n\twhile ((p = buf->head) != NULL) {\n\t\tbuf->head = p->next;\n\t\tfreed += p->size;\n\t\tif (p->size > 0)\n\t\t\tkfree(p);\n\t}\n\tllist = llist_del_all(&buf->free);\n\tllist_for_each_entry_safe(p, next, llist, free)\n\t\tkfree(p);\n\n\ttty_buffer_reset(&buf->sentinel, 0);\n\tbuf->head = &buf->sentinel;\n\tbuf->tail = &buf->sentinel;\n\n\tstill_used = atomic_xchg(&buf->mem_used, 0);\n\tWARN(still_used != freed, \"we still have not freed %d bytes!\",\n\t\t\tstill_used - freed);\n}\n\n \nstatic struct tty_buffer *tty_buffer_alloc(struct tty_port *port, size_t size)\n{\n\tstruct llist_node *free;\n\tstruct tty_buffer *p;\n\n\t \n\tsize = __ALIGN_MASK(size, TTYB_ALIGN_MASK);\n\n\tif (size <= MIN_TTYB_SIZE) {\n\t\tfree = llist_del_first(&port->buf.free);\n\t\tif (free) {\n\t\t\tp = llist_entry(free, struct tty_buffer, free);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t \n\tif (atomic_read(&port->buf.mem_used) > port->buf.mem_limit)\n\t\treturn NULL;\n\tp = kmalloc(struct_size(p, data, 2 * size), GFP_ATOMIC | __GFP_NOWARN);\n\tif (p == NULL)\n\t\treturn NULL;\n\nfound:\n\ttty_buffer_reset(p, size);\n\tatomic_add(size, &port->buf.mem_used);\n\treturn p;\n}\n\n \nstatic void tty_buffer_free(struct tty_port *port, struct tty_buffer *b)\n{\n\tstruct tty_bufhead *buf = &port->buf;\n\n\t \n\tWARN_ON(atomic_sub_return(b->size, &buf->mem_used) < 0);\n\n\tif (b->size > MIN_TTYB_SIZE)\n\t\tkfree(b);\n\telse if (b->size > 0)\n\t\tllist_add(&b->free, &buf->free);\n}\n\n \nvoid tty_buffer_flush(struct tty_struct *tty, struct tty_ldisc *ld)\n{\n\tstruct tty_port *port = tty->port;\n\tstruct tty_bufhead *buf = &port->buf;\n\tstruct tty_buffer *next;\n\n\tatomic_inc(&buf->priority);\n\n\tmutex_lock(&buf->lock);\n\t \n\twhile ((next = smp_load_acquire(&buf->head->next)) != NULL) {\n\t\ttty_buffer_free(port, buf->head);\n\t\tbuf->head = next;\n\t}\n\tbuf->head->read = buf->head->commit;\n\tbuf->head->lookahead = buf->head->read;\n\n\tif (ld && ld->ops->flush_buffer)\n\t\tld->ops->flush_buffer(tty);\n\n\tatomic_dec(&buf->priority);\n\tmutex_unlock(&buf->lock);\n}\n\n \nstatic int __tty_buffer_request_room(struct tty_port *port, size_t size,\n\t\t\t\t     bool flags)\n{\n\tstruct tty_bufhead *buf = &port->buf;\n\tstruct tty_buffer *n, *b = buf->tail;\n\tsize_t left = (b->flags ? 1 : 2) * b->size - b->used;\n\tbool change = !b->flags && flags;\n\n\tif (!change && left >= size)\n\t\treturn size;\n\n\t \n\tn = tty_buffer_alloc(port, size);\n\tif (n == NULL)\n\t\treturn change ? 0 : left;\n\n\tn->flags = flags;\n\tbuf->tail = n;\n\t \n\tsmp_store_release(&b->commit, b->used);\n\t \n\tsmp_store_release(&b->next, n);\n\n\treturn size;\n}\n\nint tty_buffer_request_room(struct tty_port *port, size_t size)\n{\n\treturn __tty_buffer_request_room(port, size, true);\n}\nEXPORT_SYMBOL_GPL(tty_buffer_request_room);\n\nsize_t __tty_insert_flip_string_flags(struct tty_port *port, const u8 *chars,\n\t\t\t\t      const u8 *flags, bool mutable_flags,\n\t\t\t\t      size_t size)\n{\n\tbool need_flags = mutable_flags || flags[0] != TTY_NORMAL;\n\tsize_t copied = 0;\n\n\tdo {\n\t\tsize_t goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);\n\t\tsize_t space = __tty_buffer_request_room(port, goal, need_flags);\n\t\tstruct tty_buffer *tb = port->buf.tail;\n\n\t\tif (unlikely(space == 0))\n\t\t\tbreak;\n\n\t\tmemcpy(char_buf_ptr(tb, tb->used), chars, space);\n\n\t\tif (mutable_flags) {\n\t\t\tmemcpy(flag_buf_ptr(tb, tb->used), flags, space);\n\t\t\tflags += space;\n\t\t} else if (tb->flags) {\n\t\t\tmemset(flag_buf_ptr(tb, tb->used), flags[0], space);\n\t\t} else {\n\t\t\t \n\t\t\tWARN_ON_ONCE(need_flags);\n\t\t}\n\n\t\ttb->used += space;\n\t\tcopied += space;\n\t\tchars += space;\n\n\t\t \n\t} while (unlikely(size > copied));\n\n\treturn copied;\n}\nEXPORT_SYMBOL(__tty_insert_flip_string_flags);\n\n \nsize_t tty_prepare_flip_string(struct tty_port *port, u8 **chars, size_t size)\n{\n\tsize_t space = __tty_buffer_request_room(port, size, false);\n\n\tif (likely(space)) {\n\t\tstruct tty_buffer *tb = port->buf.tail;\n\n\t\t*chars = char_buf_ptr(tb, tb->used);\n\t\tif (tb->flags)\n\t\t\tmemset(flag_buf_ptr(tb, tb->used), TTY_NORMAL, space);\n\t\ttb->used += space;\n\t}\n\n\treturn space;\n}\nEXPORT_SYMBOL_GPL(tty_prepare_flip_string);\n\n \nsize_t tty_ldisc_receive_buf(struct tty_ldisc *ld, const u8 *p, const u8 *f,\n\t\t\t     size_t count)\n{\n\tif (ld->ops->receive_buf2)\n\t\tcount = ld->ops->receive_buf2(ld->tty, p, f, count);\n\telse {\n\t\tcount = min_t(size_t, count, ld->tty->receive_room);\n\t\tif (count && ld->ops->receive_buf)\n\t\t\tld->ops->receive_buf(ld->tty, p, f, count);\n\t}\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_receive_buf);\n\nstatic void lookahead_bufs(struct tty_port *port, struct tty_buffer *head)\n{\n\thead->lookahead = max(head->lookahead, head->read);\n\n\twhile (head) {\n\t\tstruct tty_buffer *next;\n\t\tunsigned int count;\n\n\t\t \n\t\tnext = smp_load_acquire(&head->next);\n\t\t \n\t\tcount = smp_load_acquire(&head->commit) - head->lookahead;\n\t\tif (!count) {\n\t\t\thead = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (port->client_ops->lookahead_buf) {\n\t\t\tu8 *p, *f = NULL;\n\n\t\t\tp = char_buf_ptr(head, head->lookahead);\n\t\t\tif (head->flags)\n\t\t\t\tf = flag_buf_ptr(head, head->lookahead);\n\n\t\t\tport->client_ops->lookahead_buf(port, p, f, count);\n\t\t}\n\n\t\thead->lookahead += count;\n\t}\n}\n\nstatic size_t\nreceive_buf(struct tty_port *port, struct tty_buffer *head, size_t count)\n{\n\tu8 *p = char_buf_ptr(head, head->read);\n\tconst u8 *f = NULL;\n\tsize_t n;\n\n\tif (head->flags)\n\t\tf = flag_buf_ptr(head, head->read);\n\n\tn = port->client_ops->receive_buf(port, p, f, count);\n\tif (n > 0)\n\t\tmemset(p, 0, n);\n\treturn n;\n}\n\n \nstatic void flush_to_ldisc(struct work_struct *work)\n{\n\tstruct tty_port *port = container_of(work, struct tty_port, buf.work);\n\tstruct tty_bufhead *buf = &port->buf;\n\n\tmutex_lock(&buf->lock);\n\n\twhile (1) {\n\t\tstruct tty_buffer *head = buf->head;\n\t\tstruct tty_buffer *next;\n\t\tsize_t count, rcvd;\n\n\t\t \n\t\tif (atomic_read(&buf->priority))\n\t\t\tbreak;\n\n\t\t \n\t\tnext = smp_load_acquire(&head->next);\n\t\t \n\t\tcount = smp_load_acquire(&head->commit) - head->read;\n\t\tif (!count) {\n\t\t\tif (next == NULL)\n\t\t\t\tbreak;\n\t\t\tbuf->head = next;\n\t\t\ttty_buffer_free(port, head);\n\t\t\tcontinue;\n\t\t}\n\n\t\trcvd = receive_buf(port, head, count);\n\t\thead->read += rcvd;\n\t\tif (rcvd < count)\n\t\t\tlookahead_bufs(port, head);\n\t\tif (!rcvd)\n\t\t\tbreak;\n\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\t}\n\n\tmutex_unlock(&buf->lock);\n\n}\n\nstatic inline void tty_flip_buffer_commit(struct tty_buffer *tail)\n{\n\t \n\tsmp_store_release(&tail->commit, tail->used);\n}\n\n \nvoid tty_flip_buffer_push(struct tty_port *port)\n{\n\tstruct tty_bufhead *buf = &port->buf;\n\n\ttty_flip_buffer_commit(buf->tail);\n\tqueue_work(system_unbound_wq, &buf->work);\n}\nEXPORT_SYMBOL(tty_flip_buffer_push);\n\n \nint tty_insert_flip_string_and_push_buffer(struct tty_port *port,\n\t\t\t\t\t   const u8 *chars, size_t size)\n{\n\tstruct tty_bufhead *buf = &port->buf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tsize = tty_insert_flip_string(port, chars, size);\n\tif (size)\n\t\ttty_flip_buffer_commit(buf->tail);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tqueue_work(system_unbound_wq, &buf->work);\n\n\treturn size;\n}\n\n \nvoid tty_buffer_init(struct tty_port *port)\n{\n\tstruct tty_bufhead *buf = &port->buf;\n\n\tmutex_init(&buf->lock);\n\ttty_buffer_reset(&buf->sentinel, 0);\n\tbuf->head = &buf->sentinel;\n\tbuf->tail = &buf->sentinel;\n\tinit_llist_head(&buf->free);\n\tatomic_set(&buf->mem_used, 0);\n\tatomic_set(&buf->priority, 0);\n\tINIT_WORK(&buf->work, flush_to_ldisc);\n\tbuf->mem_limit = TTYB_DEFAULT_MEM_LIMIT;\n}\n\n \nint tty_buffer_set_limit(struct tty_port *port, int limit)\n{\n\tif (limit < MIN_TTYB_SIZE)\n\t\treturn -EINVAL;\n\tport->buf.mem_limit = limit;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tty_buffer_set_limit);\n\n \nvoid tty_buffer_set_lock_subclass(struct tty_port *port)\n{\n\tlockdep_set_subclass(&port->buf.lock, TTY_LOCK_SLAVE);\n}\n\nbool tty_buffer_restart_work(struct tty_port *port)\n{\n\treturn queue_work(system_unbound_wq, &port->buf.work);\n}\n\nbool tty_buffer_cancel_work(struct tty_port *port)\n{\n\treturn cancel_work_sync(&port->buf.work);\n}\n\nvoid tty_buffer_flush_work(struct tty_port *port)\n{\n\tflush_work(&port->buf.work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}