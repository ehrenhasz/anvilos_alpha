{
  "module_name": "main.c",
  "hash_id": "74ac676ddfbd588d0383ae996e1f161056dc85d6e20e81884f2bf0997218d183",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/ipwireless/main.c",
  "human_readable_source": "\n \n\n#include \"hardware.h\"\n#include \"network.h\"\n#include \"main.h\"\n#include \"tty.h\"\n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <pcmcia/cisreg.h>\n#include <pcmcia/device_id.h>\n#include <pcmcia/ss.h>\n#include <pcmcia/ds.h>\n\nstatic const struct pcmcia_device_id ipw_ids[] = {\n\tPCMCIA_DEVICE_MANF_CARD(0x02f2, 0x0100),\n\tPCMCIA_DEVICE_MANF_CARD(0x02f2, 0x0200),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, ipw_ids);\n\nstatic void ipwireless_detach(struct pcmcia_device *link);\n\n \n \nint ipwireless_debug;\nint ipwireless_loopback;\nint ipwireless_out_queue = 10;\n\nmodule_param_named(debug, ipwireless_debug, int, 0);\nmodule_param_named(loopback, ipwireless_loopback, int, 0);\nmodule_param_named(out_queue, ipwireless_out_queue, int, 0);\nMODULE_PARM_DESC(debug, \"switch on debug messages [0]\");\nMODULE_PARM_DESC(loopback,\n\t\t\"debug: enable ras_raw channel [0]\");\nMODULE_PARM_DESC(out_queue, \"debug: set size of outgoing PPP queue [10]\");\n\n \nstatic void signalled_reboot_work(struct work_struct *work_reboot)\n{\n\tstruct ipw_dev *ipw = container_of(work_reboot, struct ipw_dev,\n\t\t\twork_reboot);\n\tstruct pcmcia_device *link = ipw->link;\n\tpcmcia_reset_card(link->socket);\n}\n\nstatic void signalled_reboot_callback(void *callback_data)\n{\n\tstruct ipw_dev *ipw = (struct ipw_dev *) callback_data;\n\n\t \n\tschedule_work(&ipw->work_reboot);\n}\n\nstatic int ipwireless_probe(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tstruct ipw_dev *ipw = priv_data;\n\tint ret;\n\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n\n\t \n\t \n\tp_dev->config_index |= 0x44;\n\tp_dev->io_lines = 16;\n\tret = pcmcia_request_io(p_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!request_region(p_dev->resource[0]->start,\n\t\t\t    resource_size(p_dev->resource[0]),\n\t\t\t    IPWIRELESS_PCCARD_NAME)) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tp_dev->resource[2]->flags |=\n\t\tWIN_DATA_WIDTH_16 | WIN_MEMORY_TYPE_CM | WIN_ENABLE;\n\n\tret = pcmcia_request_window(p_dev, p_dev->resource[2], 0);\n\tif (ret != 0)\n\t\tgoto exit1;\n\n\tret = pcmcia_map_mem_page(p_dev, p_dev->resource[2], p_dev->card_addr);\n\tif (ret != 0)\n\t\tgoto exit1;\n\n\tipw->is_v2_card = resource_size(p_dev->resource[2]) == 0x100;\n\n\tipw->common_memory = ioremap(p_dev->resource[2]->start,\n\t\t\t\tresource_size(p_dev->resource[2]));\n\tif (!ipw->common_memory) {\n\t\tret = -ENOMEM;\n\t\tgoto exit1;\n\t}\n\tif (!request_mem_region(p_dev->resource[2]->start,\n\t\t\t\tresource_size(p_dev->resource[2]),\n\t\t\t\tIPWIRELESS_PCCARD_NAME)) {\n\t\tret = -EBUSY;\n\t\tgoto exit2;\n\t}\n\n\tp_dev->resource[3]->flags |= WIN_DATA_WIDTH_16 | WIN_MEMORY_TYPE_AM |\n\t\t\t\t\tWIN_ENABLE;\n\tp_dev->resource[3]->end = 0;  \n\tret = pcmcia_request_window(p_dev, p_dev->resource[3], 0);\n\tif (ret != 0)\n\t\tgoto exit3;\n\n\tret = pcmcia_map_mem_page(p_dev, p_dev->resource[3], 0);\n\tif (ret != 0)\n\t\tgoto exit3;\n\n\tipw->attr_memory = ioremap(p_dev->resource[3]->start,\n\t\t\t\tresource_size(p_dev->resource[3]));\n\tif (!ipw->attr_memory) {\n\t\tret = -ENOMEM;\n\t\tgoto exit3;\n\t}\n\tif (!request_mem_region(p_dev->resource[3]->start,\n\t\t\t\tresource_size(p_dev->resource[3]),\n\t\t\t\tIPWIRELESS_PCCARD_NAME)) {\n\t\tret = -EBUSY;\n\t\tgoto exit4;\n\t}\n\n\treturn 0;\n\nexit4:\n\tiounmap(ipw->attr_memory);\nexit3:\n\trelease_mem_region(p_dev->resource[2]->start,\n\t\t\tresource_size(p_dev->resource[2]));\nexit2:\n\tiounmap(ipw->common_memory);\nexit1:\n\trelease_region(p_dev->resource[0]->start,\n\t\t       resource_size(p_dev->resource[0]));\nexit:\n\tpcmcia_disable_device(p_dev);\n\treturn ret;\n}\n\nstatic int config_ipwireless(struct ipw_dev *ipw)\n{\n\tstruct pcmcia_device *link = ipw->link;\n\tint ret = 0;\n\n\tipw->is_v2_card = 0;\n\tlink->config_flags |= CONF_AUTO_SET_IO | CONF_AUTO_SET_IOMEM |\n\t\tCONF_ENABLE_IRQ;\n\n\tret = pcmcia_loop_config(link, ipwireless_probe, ipw);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tINIT_WORK(&ipw->work_reboot, signalled_reboot_work);\n\n\tipwireless_init_hardware_v1(ipw->hardware, link->resource[0]->start,\n\t\t\t\t    ipw->attr_memory, ipw->common_memory,\n\t\t\t\t    ipw->is_v2_card, signalled_reboot_callback,\n\t\t\t\t    ipw);\n\n\tret = pcmcia_request_irq(link, ipwireless_interrupt);\n\tif (ret != 0)\n\t\tgoto exit;\n\n\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME \": Card type %s\\n\",\n\t\t\tipw->is_v2_card ? \"V2/V3\" : \"V1\");\n\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t\": I/O ports %pR, irq %d\\n\", link->resource[0],\n\t\t\t(unsigned int) link->irq);\n\tif (ipw->attr_memory && ipw->common_memory)\n\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t\t\": attr memory %pR, common memory %pR\\n\",\n\t\t\tlink->resource[3],\n\t\t\tlink->resource[2]);\n\n\tipw->network = ipwireless_network_create(ipw->hardware);\n\tif (!ipw->network)\n\t\tgoto exit;\n\n\tipw->tty = ipwireless_tty_create(ipw->hardware, ipw->network);\n\tif (!ipw->tty)\n\t\tgoto exit;\n\n\tipwireless_init_hardware_v2_v3(ipw->hardware);\n\n\t \n\tret = pcmcia_enable_device(link);\n\tif (ret != 0)\n\t\tgoto exit;\n\n\treturn 0;\n\nexit:\n\tif (ipw->common_memory) {\n\t\trelease_mem_region(link->resource[2]->start,\n\t\t\t\tresource_size(link->resource[2]));\n\t\tiounmap(ipw->common_memory);\n\t}\n\tif (ipw->attr_memory) {\n\t\trelease_mem_region(link->resource[3]->start,\n\t\t\t\tresource_size(link->resource[3]));\n\t\tiounmap(ipw->attr_memory);\n\t}\n\tpcmcia_disable_device(link);\n\treturn -1;\n}\n\nstatic void release_ipwireless(struct ipw_dev *ipw)\n{\n\trelease_region(ipw->link->resource[0]->start,\n\t\t       resource_size(ipw->link->resource[0]));\n\tif (ipw->common_memory) {\n\t\trelease_mem_region(ipw->link->resource[2]->start,\n\t\t\t\tresource_size(ipw->link->resource[2]));\n\t\tiounmap(ipw->common_memory);\n\t}\n\tif (ipw->attr_memory) {\n\t\trelease_mem_region(ipw->link->resource[3]->start,\n\t\t\t\tresource_size(ipw->link->resource[3]));\n\t\tiounmap(ipw->attr_memory);\n\t}\n\tpcmcia_disable_device(ipw->link);\n}\n\n \nstatic int ipwireless_attach(struct pcmcia_device *link)\n{\n\tstruct ipw_dev *ipw;\n\tint ret;\n\n\tipw = kzalloc(sizeof(struct ipw_dev), GFP_KERNEL);\n\tif (!ipw)\n\t\treturn -ENOMEM;\n\n\tipw->link = link;\n\tlink->priv = ipw;\n\n\tipw->hardware = ipwireless_hardware_create();\n\tif (!ipw->hardware) {\n\t\tkfree(ipw);\n\t\treturn -ENOMEM;\n\t}\n\t \n\n\tret = config_ipwireless(ipw);\n\n\tif (ret != 0) {\n\t\tipwireless_detach(link);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ipwireless_detach(struct pcmcia_device *link)\n{\n\tstruct ipw_dev *ipw = link->priv;\n\n\trelease_ipwireless(ipw);\n\n\tif (ipw->tty != NULL)\n\t\tipwireless_tty_free(ipw->tty);\n\tif (ipw->network != NULL)\n\t\tipwireless_network_free(ipw->network);\n\tif (ipw->hardware != NULL)\n\t\tipwireless_hardware_free(ipw->hardware);\n\tkfree(ipw);\n}\n\nstatic struct pcmcia_driver me = {\n\t.owner\t\t= THIS_MODULE,\n\t.probe          = ipwireless_attach,\n\t.remove         = ipwireless_detach,\n\t.name\t\t= IPWIRELESS_PCCARD_NAME,\n\t.id_table       = ipw_ids\n};\n\n \nstatic int __init init_ipwireless(void)\n{\n\tint ret;\n\n\tret = ipwireless_tty_init();\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = pcmcia_register_driver(&me);\n\tif (ret != 0)\n\t\tipwireless_tty_release();\n\n\treturn ret;\n}\n\n \nstatic void __exit exit_ipwireless(void)\n{\n\tpcmcia_unregister_driver(&me);\n\tipwireless_tty_release();\n}\n\nmodule_init(init_ipwireless);\nmodule_exit(exit_ipwireless);\n\nMODULE_AUTHOR(IPWIRELESS_PCMCIA_AUTHOR);\nMODULE_DESCRIPTION(IPWIRELESS_PCCARD_NAME \" \" IPWIRELESS_PCMCIA_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}