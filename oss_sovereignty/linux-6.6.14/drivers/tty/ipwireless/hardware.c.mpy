{
  "module_name": "hardware.c",
  "hash_id": "f06ea89895a0d23b6214af1ec53aafe97d0fb520716551044604faf5bfeee272",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/ipwireless/hardware.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include \"hardware.h\"\n#include \"setup_protocol.h\"\n#include \"network.h\"\n#include \"main.h\"\n\nstatic void ipw_send_setup_packet(struct ipw_hardware *hw);\nstatic void handle_received_SETUP_packet(struct ipw_hardware *ipw,\n\t\t\t\t\t unsigned int address,\n\t\t\t\t\t const unsigned char *data, int len,\n\t\t\t\t\t int is_last);\nstatic void ipwireless_setup_timer(struct timer_list *t);\nstatic void handle_received_CTRL_packet(struct ipw_hardware *hw,\n\t\tunsigned int channel_idx, const unsigned char *data, int len);\n\n \n\n#ifdef TIMING_DIAGNOSTICS\n\nstatic struct timing_stats {\n\tunsigned long last_report_time;\n\tunsigned long read_time;\n\tunsigned long write_time;\n\tunsigned long read_bytes;\n\tunsigned long write_bytes;\n\tunsigned long start_time;\n};\n\nstatic void start_timing(void)\n{\n\ttiming_stats.start_time = jiffies;\n}\n\nstatic void end_read_timing(unsigned length)\n{\n\ttiming_stats.read_time += (jiffies - start_time);\n\ttiming_stats.read_bytes += length + 2;\n\treport_timing();\n}\n\nstatic void end_write_timing(unsigned length)\n{\n\ttiming_stats.write_time += (jiffies - start_time);\n\ttiming_stats.write_bytes += length + 2;\n\treport_timing();\n}\n\nstatic void report_timing(void)\n{\n\tunsigned long since = jiffies - timing_stats.last_report_time;\n\n\t \n\tif (since >= HZ) {\n\t\tint first = (timing_stats.last_report_time == 0);\n\n\t\ttiming_stats.last_report_time = jiffies;\n\t\tif (!first)\n\t\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t\t       \": %u us elapsed - read %lu bytes in %u us, wrote %lu bytes in %u us\\n\",\n\t\t\t       jiffies_to_usecs(since),\n\t\t\t       timing_stats.read_bytes,\n\t\t\t       jiffies_to_usecs(timing_stats.read_time),\n\t\t\t       timing_stats.write_bytes,\n\t\t\t       jiffies_to_usecs(timing_stats.write_time));\n\n\t\ttiming_stats.read_time = 0;\n\t\ttiming_stats.write_time = 0;\n\t\ttiming_stats.read_bytes = 0;\n\t\ttiming_stats.write_bytes = 0;\n\t}\n}\n#else\nstatic void start_timing(void) { }\nstatic void end_read_timing(unsigned length) { }\nstatic void end_write_timing(unsigned length) { }\n#endif\n\n \n\n#define LL_MTU_V1 318\n#define LL_MTU_V2 250\n#define LL_MTU_MAX (LL_MTU_V1 > LL_MTU_V2 ? LL_MTU_V1 : LL_MTU_V2)\n\n#define PRIO_DATA  2\n#define PRIO_CTRL  1\n#define PRIO_SETUP 0\n\n \n#define ADDR_SETUP_PROT 0\n\n \nenum {\n\t \n\tTL_PROTOCOLID_COM_DATA = 0,\n\n\t \n\tTL_PROTOCOLID_COM_CTRL = 1,\n\n\t \n\tTL_PROTOCOLID_SETUP = 2\n};\n\n \n#define NL_FIRST_PACKET_HEADER_SIZE        3\n\n \n#define NL_FOLLOWING_PACKET_HEADER_SIZE    1\n\nstruct nl_first_packet_header {\n\tunsigned char protocol:3;\n\tunsigned char address:3;\n\tunsigned char packet_rank:2;\n\tunsigned char length_lsb;\n\tunsigned char length_msb;\n};\n\nstruct nl_packet_header {\n\tunsigned char protocol:3;\n\tunsigned char address:3;\n\tunsigned char packet_rank:2;\n};\n\n \n#define NL_INTERMEDIATE_PACKET    0x0\n#define NL_LAST_PACKET            0x1\n#define NL_FIRST_PACKET           0x2\n\nunion nl_packet {\n\t \n\tstruct nl_first_packet_header hdr_first;\n\t \n\tstruct nl_packet_header hdr;\n\t \n\tunsigned char rawpkt[LL_MTU_MAX];\n} __attribute__ ((__packed__));\n\n#define HW_VERSION_UNKNOWN -1\n#define HW_VERSION_1 1\n#define HW_VERSION_2 2\n\n \n#define IOIER 0x00\t\t \n#define IOIR  0x02\t\t \n#define IODCR 0x04\t\t \n#define IODRR 0x06\t\t \n#define IODWR 0x08\t\t \n#define IOESR 0x0A\t\t \n#define IORXR 0x0C\t\t \n#define IOTXR 0x0E\t\t \n\n \n\n \n#define IER_RXENABLED   0x1\n#define IER_TXENABLED   0x2\n\n \n#define IR_RXINTR       0x1\n#define IR_TXINTR       0x2\n\n \n#define DCR_RXDONE      0x1\n#define DCR_TXDONE      0x2\n#define DCR_RXRESET     0x4\n#define DCR_TXRESET     0x8\n\n \n\nstruct MEMCCR {\n\tunsigned short reg_config_option;\t \n\tunsigned short reg_config_and_status;\t \n\tunsigned short reg_pin_replacement;\t \n\tunsigned short reg_socket_and_copy;\t \n\tunsigned short reg_ext_status;\t\t \n\tunsigned short reg_io_base;\t\t \n};\n\nstruct MEMINFREG {\n\tunsigned short memreg_tx_old;\t \n\tunsigned short pad1;\n\tunsigned short memreg_rx_done;\t \n\tunsigned short pad2;\n\tunsigned short memreg_rx;\t \n\tunsigned short pad3;\n\tunsigned short memreg_pc_interrupt_ack;\t \n\tunsigned short pad4;\n\tunsigned long memreg_card_present; \n\tunsigned short memreg_tx_new;\t \n};\n\n#define CARD_PRESENT_VALUE (0xBEEFCAFEUL)\n\n#define MEMTX_TX                       0x0001\n#define MEMRX_RX                       0x0001\n#define MEMRX_RX_DONE                  0x0001\n#define MEMRX_PCINTACKK                0x0001\n\n#define NL_NUM_OF_PRIORITIES       3\n#define NL_NUM_OF_PROTOCOLS        3\n#define NL_NUM_OF_ADDRESSES        NO_OF_IPW_CHANNELS\n\nstruct ipw_hardware {\n\tunsigned int base_port;\n\tshort hw_version;\n\tunsigned short ll_mtu;\n\tspinlock_t lock;\n\n\tint initializing;\n\tint init_loops;\n\tstruct timer_list setup_timer;\n\n\t \n\tint tx_ready;\n\t \n\tint tx_queued;\n\tstruct list_head tx_queue[NL_NUM_OF_PRIORITIES];\n\n\tint rx_bytes_queued;\n\tstruct list_head rx_queue;\n\t \n\tstruct list_head rx_pool;\n\tint rx_pool_size;\n\t \n\tint blocking_rx;\n\t \n\tint rx_ready;\n\tunsigned short last_memtx_serial;\n\t \n\tint serial_number_detected;\n\tstruct work_struct work_rx;\n\n\t \n\tint to_setup;\n\n\t \n\tint removed;\n\t \n\tint irq;\n\t \n\tint shutting_down;\n\t \n\tunsigned int control_lines[NL_NUM_OF_ADDRESSES];\n\tstruct ipw_rx_packet *packet_assembler[NL_NUM_OF_ADDRESSES];\n\n\tstruct tasklet_struct tasklet;\n\n\t \n\tstruct ipw_network *network;\n\tstruct MEMINFREG __iomem *memory_info_regs;\n\tstruct MEMCCR __iomem *memregs_CCR;\n\tvoid (*reboot_callback) (void *data);\n\tvoid *reboot_callback_data;\n\n\tunsigned short __iomem *memreg_tx;\n};\n\n \nstruct ipw_tx_packet {\n\tstruct list_head queue;\n\t \n\tunsigned char dest_addr;\n\t \n\tunsigned char protocol;\n\t \n\tunsigned short length;\n\t \n\t \n\tunsigned long offset;\n\t \n\tint fragment_count;\n\n\t \n\tvoid (*packet_callback) (void *cb_data, unsigned int packet_length);\n\tvoid *callback_data;\n};\n\n \n#define COMCTRL_RTS\t0\n#define COMCTRL_DTR\t1\n\n \n#define COMCTRL_CTS\t2\n#define COMCTRL_DCD\t3\n#define COMCTRL_DSR\t4\n#define COMCTRL_RI\t5\n\nstruct ipw_control_packet_body {\n\t \n\tunsigned char sig_no;\n\t \n\tunsigned char value;\n} __attribute__ ((__packed__));\n\nstruct ipw_control_packet {\n\tstruct ipw_tx_packet header;\n\tstruct ipw_control_packet_body body;\n};\n\nstruct ipw_rx_packet {\n\tstruct list_head queue;\n\tunsigned int capacity;\n\tunsigned int length;\n\tunsigned int protocol;\n\tunsigned int channel_idx;\n};\n\nstatic char *data_type(const unsigned char *buf, unsigned length)\n{\n\tstruct nl_packet_header *hdr = (struct nl_packet_header *) buf;\n\n\tif (length == 0)\n\t\treturn \"     \";\n\n\tif (hdr->packet_rank & NL_FIRST_PACKET) {\n\t\tswitch (hdr->protocol) {\n\t\tcase TL_PROTOCOLID_COM_DATA:\treturn \"DATA \";\n\t\tcase TL_PROTOCOLID_COM_CTRL:\treturn \"CTRL \";\n\t\tcase TL_PROTOCOLID_SETUP:\treturn \"SETUP\";\n\t\tdefault: return \"???? \";\n\t\t}\n\t} else\n\t\treturn \"     \";\n}\n\n#define DUMP_MAX_BYTES 64\n\nstatic void dump_data_bytes(const char *type, const unsigned char *data,\n\t\t\t    unsigned length)\n{\n\tchar prefix[56];\n\n\tsprintf(prefix, IPWIRELESS_PCCARD_NAME \": %s %s \",\n\t\t\ttype, data_type(data, length));\n\tprint_hex_dump_bytes(prefix, 0, (void *)data,\n\t\t\tlength < DUMP_MAX_BYTES ? length : DUMP_MAX_BYTES);\n}\n\nstatic void swap_packet_bitfield_to_le(unsigned char *data)\n{\n#ifdef __BIG_ENDIAN_BITFIELD\n\tunsigned char tmp = *data, ret = 0;\n\n\t \n\tret |= (tmp & 0xc0) >> 6;\n\tret |= (tmp & 0x38) >> 1;\n\tret |= (tmp & 0x07) << 5;\n\t*data = ret & 0xff;\n#endif\n}\n\nstatic void swap_packet_bitfield_from_le(unsigned char *data)\n{\n#ifdef __BIG_ENDIAN_BITFIELD\n\tunsigned char tmp = *data, ret = 0;\n\n\t \n\tret |= (tmp & 0xe0) >> 5;\n\tret |= (tmp & 0x1c) << 1;\n\tret |= (tmp & 0x03) << 6;\n\t*data = ret & 0xff;\n#endif\n}\n\nstatic void do_send_fragment(struct ipw_hardware *hw, unsigned char *data,\n\t\t\t    unsigned length)\n{\n\tunsigned i;\n\tunsigned long flags;\n\n\tstart_timing();\n\tBUG_ON(length > hw->ll_mtu);\n\n\tif (ipwireless_debug)\n\t\tdump_data_bytes(\"send\", data, length);\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\n\thw->tx_ready = 0;\n\tswap_packet_bitfield_to_le(data);\n\n\tif (hw->hw_version == HW_VERSION_1) {\n\t\toutw((unsigned short) length, hw->base_port + IODWR);\n\n\t\tfor (i = 0; i < length; i += 2) {\n\t\t\tunsigned short d = data[i];\n\t\t\t__le16 raw_data;\n\n\t\t\tif (i + 1 < length)\n\t\t\t\td |= data[i + 1] << 8;\n\t\t\traw_data = cpu_to_le16(d);\n\t\t\toutw(raw_data, hw->base_port + IODWR);\n\t\t}\n\n\t\toutw(DCR_TXDONE, hw->base_port + IODCR);\n\t} else if (hw->hw_version == HW_VERSION_2) {\n\t\toutw((unsigned short) length, hw->base_port);\n\n\t\tfor (i = 0; i < length; i += 2) {\n\t\t\tunsigned short d = data[i];\n\t\t\t__le16 raw_data;\n\n\t\t\tif (i + 1 < length)\n\t\t\t\td |= data[i + 1] << 8;\n\t\t\traw_data = cpu_to_le16(d);\n\t\t\toutw(raw_data, hw->base_port);\n\t\t}\n\t\twhile ((i & 3) != 2) {\n\t\t\toutw((unsigned short) 0xDEAD, hw->base_port);\n\t\t\ti += 2;\n\t\t}\n\t\twritew(MEMRX_RX, &hw->memory_info_regs->memreg_rx);\n\t}\n\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\tend_write_timing(length);\n}\n\nstatic void do_send_packet(struct ipw_hardware *hw, struct ipw_tx_packet *packet)\n{\n\tunsigned short fragment_data_len;\n\tunsigned short data_left = packet->length - packet->offset;\n\tunsigned short header_size;\n\tunion nl_packet pkt;\n\n\theader_size =\n\t    (packet->fragment_count == 0)\n\t    ? NL_FIRST_PACKET_HEADER_SIZE\n\t    : NL_FOLLOWING_PACKET_HEADER_SIZE;\n\tfragment_data_len = hw->ll_mtu - header_size;\n\tif (data_left < fragment_data_len)\n\t\tfragment_data_len = data_left;\n\n\t \n\tpkt.hdr_first.protocol = packet->protocol;\n\tpkt.hdr_first.address = packet->dest_addr;\n\tpkt.hdr_first.packet_rank = 0;\n\n\t \n\tif (packet->fragment_count == 0) {\n\t\tpkt.hdr_first.packet_rank |= NL_FIRST_PACKET;\n\t\tpkt.hdr_first.length_lsb = (unsigned char) packet->length;\n\t\tpkt.hdr_first.length_msb =\n\t\t\t(unsigned char) (packet->length >> 8);\n\t}\n\n\tmemcpy(pkt.rawpkt + header_size,\n\t       ((unsigned char *) packet) + sizeof(struct ipw_tx_packet) +\n\t       packet->offset, fragment_data_len);\n\tpacket->offset += fragment_data_len;\n\tpacket->fragment_count++;\n\n\t \n\tif (packet->offset == packet->length)\n\t\tpkt.hdr_first.packet_rank |= NL_LAST_PACKET;\n\tdo_send_fragment(hw, pkt.rawpkt, header_size + fragment_data_len);\n\n\t \n\tif (packet->offset < packet->length) {\n\t\t \n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\tlist_add(&packet->queue, &hw->tx_queue[0]);\n\t\thw->tx_queued++;\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t} else {\n\t\tif (packet->packet_callback)\n\t\t\tpacket->packet_callback(packet->callback_data,\n\t\t\t\t\tpacket->length);\n\t\tkfree(packet);\n\t}\n}\n\nstatic void ipw_setup_hardware(struct ipw_hardware *hw)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (hw->hw_version == HW_VERSION_1) {\n\t\t \n\t\toutw(DCR_RXRESET, hw->base_port + IODCR);\n\t\t \n\t\toutw(DCR_TXRESET, hw->base_port + IODCR);\n\n\t\t \n\t\toutw(IER_TXENABLED | IER_RXENABLED, hw->base_port + IOIER);\n\t} else {\n\t\t \n\t\tunsigned short csr = readw(&hw->memregs_CCR->reg_config_and_status);\n\n\t\tcsr |= 1;\n\t\twritew(csr, &hw->memregs_CCR->reg_config_and_status);\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n}\n\n \nstatic struct ipw_rx_packet *pool_allocate(struct ipw_hardware *hw,\n\t\t\t\t\t   struct ipw_rx_packet *packet,\n\t\t\t\t\t   int minimum_free_space)\n{\n\n\tif (!packet) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\tif (!list_empty(&hw->rx_pool)) {\n\t\t\tpacket = list_first_entry(&hw->rx_pool,\n\t\t\t\t\tstruct ipw_rx_packet, queue);\n\t\t\thw->rx_pool_size--;\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\tlist_del(&packet->queue);\n\t\t} else {\n\t\t\tconst int min_capacity =\n\t\t\t\tipwireless_ppp_mru(hw->network) + 2;\n\t\t\tint new_capacity;\n\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\tnew_capacity =\n\t\t\t\t(minimum_free_space > min_capacity\n\t\t\t\t ? minimum_free_space\n\t\t\t\t : min_capacity);\n\t\t\tpacket = kmalloc(sizeof(struct ipw_rx_packet)\n\t\t\t\t\t+ new_capacity, GFP_ATOMIC);\n\t\t\tif (!packet)\n\t\t\t\treturn NULL;\n\t\t\tpacket->capacity = new_capacity;\n\t\t}\n\t\tpacket->length = 0;\n\t}\n\n\tif (packet->length + minimum_free_space > packet->capacity) {\n\t\tstruct ipw_rx_packet *old_packet = packet;\n\n\t\tpacket = kmalloc(sizeof(struct ipw_rx_packet) +\n\t\t\t\told_packet->length + minimum_free_space,\n\t\t\t\tGFP_ATOMIC);\n\t\tif (!packet) {\n\t\t\tkfree(old_packet);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(packet, old_packet,\n\t\t\t\tsizeof(struct ipw_rx_packet)\n\t\t\t\t\t+ old_packet->length);\n\t\tpacket->capacity = old_packet->length + minimum_free_space;\n\t\tkfree(old_packet);\n\t}\n\n\treturn packet;\n}\n\nstatic void pool_free(struct ipw_hardware *hw, struct ipw_rx_packet *packet)\n{\n\tif (hw->rx_pool_size > 6)\n\t\tkfree(packet);\n\telse {\n\t\thw->rx_pool_size++;\n\t\tlist_add(&packet->queue, &hw->rx_pool);\n\t}\n}\n\nstatic void queue_received_packet(struct ipw_hardware *hw,\n\t\t\t\t  unsigned int protocol,\n\t\t\t\t  unsigned int address,\n\t\t\t\t  const unsigned char *data, int length,\n\t\t\t\t  int is_last)\n{\n\tunsigned int channel_idx = address - 1;\n\tstruct ipw_rx_packet *packet = NULL;\n\tunsigned long flags;\n\n\t \n\tif (channel_idx >= NL_NUM_OF_ADDRESSES) {\n\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t       \": data packet has bad address %u\\n\", address);\n\t\treturn;\n\t}\n\n\t \n\tif (protocol == TL_PROTOCOLID_COM_DATA) {\n\t\tstruct ipw_rx_packet **assem =\n\t\t\t&hw->packet_assembler[channel_idx];\n\n\t\t \n\t\t(*assem) = pool_allocate(hw, *assem, length);\n\t\tif (!(*assem)) {\n\t\t\tprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\n\t\t\t\t\": no memory for incoming data packet, dropped!\\n\");\n\t\t\treturn;\n\t\t}\n\t\t(*assem)->protocol = protocol;\n\t\t(*assem)->channel_idx = channel_idx;\n\n\t\t \n\t\tmemcpy((unsigned char *)(*assem) +\n\t\t\t       sizeof(struct ipw_rx_packet)\n\t\t\t\t+ (*assem)->length, data, length);\n\t\t(*assem)->length += length;\n\t\tif (is_last) {\n\t\t\tpacket = *assem;\n\t\t\t*assem = NULL;\n\t\t\t \n\t\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\t\thw->rx_bytes_queued += packet->length;\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t}\n\t} else {\n\t\t \n\t\tpacket = pool_allocate(hw, NULL, length);\n\t\tif (!packet) {\n\t\t\tprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\n\t\t\t\t\": no memory for incoming ctrl packet, dropped!\\n\");\n\t\t\treturn;\n\t\t}\n\t\tpacket->protocol = protocol;\n\t\tpacket->channel_idx = channel_idx;\n\t\tmemcpy((unsigned char *)packet + sizeof(struct ipw_rx_packet),\n\t\t\t\tdata, length);\n\t\tpacket->length = length;\n\t}\n\n\t \n\tif (packet) {\n\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\tlist_add_tail(&packet->queue, &hw->rx_queue);\n\t\t \n\t\thw->blocking_rx =\n\t\t\t(hw->rx_bytes_queued >= IPWIRELESS_RX_QUEUE_SIZE);\n\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\tschedule_work(&hw->work_rx);\n\t}\n}\n\n \nstatic void ipw_receive_data_work(struct work_struct *work_rx)\n{\n\tstruct ipw_hardware *hw =\n\t    container_of(work_rx, struct ipw_hardware, work_rx);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\twhile (!list_empty(&hw->rx_queue)) {\n\t\tstruct ipw_rx_packet *packet =\n\t\t\tlist_first_entry(&hw->rx_queue,\n\t\t\t\t\tstruct ipw_rx_packet, queue);\n\n\t\tif (hw->shutting_down)\n\t\t\tbreak;\n\t\tlist_del(&packet->queue);\n\n\t\t \n\t\tif (packet->protocol == TL_PROTOCOLID_COM_DATA) {\n\t\t\tif (hw->network != NULL) {\n\t\t\t\t \n\t\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\t\t \n\t\t\t\tipwireless_network_packet_received(\n\t\t\t\t\t\thw->network,\n\t\t\t\t\t\tpacket->channel_idx,\n\t\t\t\t\t\t(unsigned char *)packet\n\t\t\t\t\t\t+ sizeof(struct ipw_rx_packet),\n\t\t\t\t\t\tpacket->length);\n\t\t\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\t\t}\n\t\t\t \n\t\t\thw->rx_bytes_queued -= packet->length;\n\t\t} else {\n\t\t\t \n\t\t\thandle_received_CTRL_packet(hw, packet->channel_idx,\n\t\t\t\t\t(unsigned char *)packet\n\t\t\t\t\t+ sizeof(struct ipw_rx_packet),\n\t\t\t\t\tpacket->length);\n\t\t}\n\t\tpool_free(hw, packet);\n\t\t \n\t\thw->blocking_rx =\n\t\t\thw->rx_bytes_queued >= IPWIRELESS_RX_QUEUE_SIZE;\n\t\tif (hw->shutting_down)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n}\n\nstatic void handle_received_CTRL_packet(struct ipw_hardware *hw,\n\t\t\t\t\tunsigned int channel_idx,\n\t\t\t\t\tconst unsigned char *data, int len)\n{\n\tconst struct ipw_control_packet_body *body =\n\t\t(const struct ipw_control_packet_body *) data;\n\tunsigned int changed_mask;\n\n\tif (len != sizeof(struct ipw_control_packet_body)) {\n\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t       \": control packet was %d bytes - wrong size!\\n\",\n\t\t       len);\n\t\treturn;\n\t}\n\n\tswitch (body->sig_no) {\n\tcase COMCTRL_CTS:\n\t\tchanged_mask = IPW_CONTROL_LINE_CTS;\n\t\tbreak;\n\tcase COMCTRL_DCD:\n\t\tchanged_mask = IPW_CONTROL_LINE_DCD;\n\t\tbreak;\n\tcase COMCTRL_DSR:\n\t\tchanged_mask = IPW_CONTROL_LINE_DSR;\n\t\tbreak;\n\tcase COMCTRL_RI:\n\t\tchanged_mask = IPW_CONTROL_LINE_RI;\n\t\tbreak;\n\tdefault:\n\t\tchanged_mask = 0;\n\t}\n\n\tif (changed_mask != 0) {\n\t\tif (body->value)\n\t\t\thw->control_lines[channel_idx] |= changed_mask;\n\t\telse\n\t\t\thw->control_lines[channel_idx] &= ~changed_mask;\n\t\tif (hw->network)\n\t\t\tipwireless_network_notify_control_line_change(\n\t\t\t\t\thw->network,\n\t\t\t\t\tchannel_idx,\n\t\t\t\t\thw->control_lines[channel_idx],\n\t\t\t\t\tchanged_mask);\n\t}\n}\n\nstatic void handle_received_packet(struct ipw_hardware *hw,\n\t\t\t\t   const union nl_packet *packet,\n\t\t\t\t   unsigned short len)\n{\n\tunsigned int protocol = packet->hdr.protocol;\n\tunsigned int address = packet->hdr.address;\n\tunsigned int header_length;\n\tconst unsigned char *data;\n\tunsigned int data_len;\n\tint is_last = packet->hdr.packet_rank & NL_LAST_PACKET;\n\n\tif (packet->hdr.packet_rank & NL_FIRST_PACKET)\n\t\theader_length = NL_FIRST_PACKET_HEADER_SIZE;\n\telse\n\t\theader_length = NL_FOLLOWING_PACKET_HEADER_SIZE;\n\n\tdata = packet->rawpkt + header_length;\n\tdata_len = len - header_length;\n\tswitch (protocol) {\n\tcase TL_PROTOCOLID_COM_DATA:\n\tcase TL_PROTOCOLID_COM_CTRL:\n\t\tqueue_received_packet(hw, protocol, address, data, data_len,\n\t\t\t\tis_last);\n\t\tbreak;\n\tcase TL_PROTOCOLID_SETUP:\n\t\thandle_received_SETUP_packet(hw, address, data, data_len,\n\t\t\t\tis_last);\n\t\tbreak;\n\t}\n}\n\nstatic void acknowledge_data_read(struct ipw_hardware *hw)\n{\n\tif (hw->hw_version == HW_VERSION_1)\n\t\toutw(DCR_RXDONE, hw->base_port + IODCR);\n\telse\n\t\twritew(MEMRX_PCINTACKK,\n\t\t\t\t&hw->memory_info_regs->memreg_pc_interrupt_ack);\n}\n\n \nstatic void do_receive_packet(struct ipw_hardware *hw)\n{\n\tunsigned len;\n\tunsigned i;\n\tunsigned char pkt[LL_MTU_MAX];\n\n\tstart_timing();\n\n\tif (hw->hw_version == HW_VERSION_1) {\n\t\tlen = inw(hw->base_port + IODRR);\n\t\tif (len > hw->ll_mtu) {\n\t\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t\t       \": received a packet of %u bytes - longer than the MTU!\\n\", len);\n\t\t\toutw(DCR_RXDONE | DCR_RXRESET, hw->base_port + IODCR);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (i = 0; i < len; i += 2) {\n\t\t\t__le16 raw_data = inw(hw->base_port + IODRR);\n\t\t\tunsigned short data = le16_to_cpu(raw_data);\n\n\t\t\tpkt[i] = (unsigned char) data;\n\t\t\tpkt[i + 1] = (unsigned char) (data >> 8);\n\t\t}\n\t} else {\n\t\tlen = inw(hw->base_port);\n\t\tif (len > hw->ll_mtu) {\n\t\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t\t       \": received a packet of %u bytes - longer than the MTU!\\n\", len);\n\t\t\twritew(MEMRX_PCINTACKK,\n\t\t\t\t&hw->memory_info_regs->memreg_pc_interrupt_ack);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (i = 0; i < len; i += 2) {\n\t\t\t__le16 raw_data = inw(hw->base_port);\n\t\t\tunsigned short data = le16_to_cpu(raw_data);\n\n\t\t\tpkt[i] = (unsigned char) data;\n\t\t\tpkt[i + 1] = (unsigned char) (data >> 8);\n\t\t}\n\n\t\twhile ((i & 3) != 2) {\n\t\t\tinw(hw->base_port);\n\t\t\ti += 2;\n\t\t}\n\t}\n\n\tacknowledge_data_read(hw);\n\n\tswap_packet_bitfield_from_le(pkt);\n\n\tif (ipwireless_debug)\n\t\tdump_data_bytes(\"recv\", pkt, len);\n\n\thandle_received_packet(hw, (union nl_packet *) pkt, len);\n\n\tend_read_timing(len);\n}\n\nstatic int get_current_packet_priority(struct ipw_hardware *hw)\n{\n\t \n\treturn (hw->to_setup || hw->initializing\n\t\t\t? PRIO_SETUP + 1 : NL_NUM_OF_PRIORITIES);\n}\n\n \nstatic int get_packets_from_hw(struct ipw_hardware *hw)\n{\n\tint received = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\twhile (hw->rx_ready && !hw->blocking_rx) {\n\t\treceived = 1;\n\t\thw->rx_ready--;\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\t\tdo_receive_packet(hw);\n\n\t\tspin_lock_irqsave(&hw->lock, flags);\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\treturn received;\n}\n\n \nstatic int send_pending_packet(struct ipw_hardware *hw, int priority_limit)\n{\n\tint more_to_send = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (hw->tx_queued && hw->tx_ready) {\n\t\tint priority;\n\t\tstruct ipw_tx_packet *packet = NULL;\n\n\t\t \n\t\tfor (priority = 0; priority < priority_limit; priority++) {\n\t\t\tif (!list_empty(&hw->tx_queue[priority])) {\n\t\t\t\tpacket = list_first_entry(\n\t\t\t\t\t\t&hw->tx_queue[priority],\n\t\t\t\t\t\tstruct ipw_tx_packet,\n\t\t\t\t\t\tqueue);\n\n\t\t\t\thw->tx_queued--;\n\t\t\t\tlist_del(&packet->queue);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!packet) {\n\t\t\thw->tx_queued = 0;\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\t\t \n\t\tdo_send_packet(hw, packet);\n\n\t\t \n\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\tfor (priority = 0; priority < priority_limit; priority++)\n\t\t\tif (!list_empty(&hw->tx_queue[priority])) {\n\t\t\t\tmore_to_send = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!more_to_send)\n\t\t\thw->tx_queued = 0;\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\treturn more_to_send;\n}\n\n \nstatic void ipwireless_do_tasklet(struct tasklet_struct *t)\n{\n\tstruct ipw_hardware *hw = from_tasklet(hw, t, tasklet);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (hw->shutting_down) {\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\treturn;\n\t}\n\n\tif (hw->to_setup == 1) {\n\t\t \n\t\thw->to_setup = 2;\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\t\tipw_setup_hardware(hw);\n\t\tipw_send_setup_packet(hw);\n\n\t\tsend_pending_packet(hw, PRIO_SETUP + 1);\n\t\tget_packets_from_hw(hw);\n\t} else {\n\t\tint priority_limit = get_current_packet_priority(hw);\n\t\tint again;\n\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\t\tdo {\n\t\t\tagain = send_pending_packet(hw, priority_limit);\n\t\t\tagain |= get_packets_from_hw(hw);\n\t\t} while (again);\n\t}\n}\n\n \nstatic int is_card_present(struct ipw_hardware *hw)\n{\n\tif (hw->hw_version == HW_VERSION_1)\n\t\treturn inw(hw->base_port + IOIR) != 0xFFFF;\n\telse\n\t\treturn readl(&hw->memory_info_regs->memreg_card_present) ==\n\t\t    CARD_PRESENT_VALUE;\n}\n\nstatic irqreturn_t ipwireless_handle_v1_interrupt(int irq,\n\t\t\t\t\t\t  struct ipw_hardware *hw)\n{\n\tunsigned short irqn;\n\n\tirqn = inw(hw->base_port + IOIR);\n\n\t \n\tif (irqn == 0xFFFF)\n\t\treturn IRQ_NONE;\n\telse if (irqn != 0) {\n\t\tunsigned short ack = 0;\n\t\tunsigned long flags;\n\n\t\t \n\t\tif (irqn & IR_TXINTR) {\n\t\t\tack |= IR_TXINTR;\n\t\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\t\thw->tx_ready = 1;\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t}\n\t\t \n\t\tif (irqn & IR_RXINTR) {\n\t\t\tack |= IR_RXINTR;\n\t\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\t\thw->rx_ready++;\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t}\n\t\tif (ack != 0) {\n\t\t\toutw(ack, hw->base_port + IOIR);\n\t\t\ttasklet_schedule(&hw->tasklet);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic void acknowledge_pcmcia_interrupt(struct ipw_hardware *hw)\n{\n\tunsigned short csr = readw(&hw->memregs_CCR->reg_config_and_status);\n\n\tcsr &= 0xfffd;\n\twritew(csr, &hw->memregs_CCR->reg_config_and_status);\n}\n\nstatic irqreturn_t ipwireless_handle_v2_v3_interrupt(int irq,\n\t\t\t\t\t\t     struct ipw_hardware *hw)\n{\n\tint tx = 0;\n\tint rx = 0;\n\tint rx_repeat = 0;\n\tint try_mem_tx_old;\n\tunsigned long flags;\n\n\tdo {\n\n\tunsigned short memtx = readw(hw->memreg_tx);\n\tunsigned short memtx_serial;\n\tunsigned short memrxdone =\n\t\treadw(&hw->memory_info_regs->memreg_rx_done);\n\n\ttry_mem_tx_old = 0;\n\n\t \n\tif (!(memtx & MEMTX_TX) && !(memrxdone & MEMRX_RX_DONE)) {\n\n\t\t \n\t\tif (hw->memreg_tx == &hw->memory_info_regs->memreg_tx_new) {\n\t\t\tmemtx = readw(&hw->memory_info_regs->memreg_tx_old);\n\t\t\tif (memtx & MEMTX_TX) {\n\t\t\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t\t\t\t\": Using memreg_tx_old\\n\");\n\t\t\t\thw->memreg_tx =\n\t\t\t\t\t&hw->memory_info_regs->memreg_tx_old;\n\t\t\t} else {\n\t\t\t\treturn IRQ_NONE;\n\t\t\t}\n\t\t} else\n\t\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (!is_card_present(hw)) {\n\t\tacknowledge_pcmcia_interrupt(hw);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tmemtx_serial = memtx & (unsigned short) 0xff00;\n\tif (memtx & MEMTX_TX) {\n\t\twritew(memtx_serial, hw->memreg_tx);\n\n\t\tif (hw->serial_number_detected) {\n\t\t\tif (memtx_serial != hw->last_memtx_serial) {\n\t\t\t\thw->last_memtx_serial = memtx_serial;\n\t\t\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\t\t\thw->rx_ready++;\n\t\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\t\trx = 1;\n\t\t\t} else\n\t\t\t\t \n\t\t\t\trx_repeat = 1;\n\t\t} else {\n\t\t\t \n\t\t\tif (memtx_serial != 0) {\n\t\t\t\thw->serial_number_detected = 1;\n\t\t\t\tprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME\n\t\t\t\t\t\": memreg_tx serial num detected\\n\");\n\n\t\t\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\t\t\thw->rx_ready++;\n\t\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\t}\n\t\t\trx = 1;\n\t\t}\n\t}\n\tif (memrxdone & MEMRX_RX_DONE) {\n\t\twritew(0, &hw->memory_info_regs->memreg_rx_done);\n\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\thw->tx_ready = 1;\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\ttx = 1;\n\t}\n\tif (tx)\n\t\twritew(MEMRX_PCINTACKK,\n\t\t\t\t&hw->memory_info_regs->memreg_pc_interrupt_ack);\n\n\tacknowledge_pcmcia_interrupt(hw);\n\n\tif (tx || rx)\n\t\ttasklet_schedule(&hw->tasklet);\n\telse if (!rx_repeat) {\n\t\tif (hw->memreg_tx == &hw->memory_info_regs->memreg_tx_new) {\n\t\t\tif (hw->serial_number_detected)\n\t\t\t\tprintk(KERN_WARNING IPWIRELESS_PCCARD_NAME\n\t\t\t\t\t\": spurious interrupt - new_tx mode\\n\");\n\t\t\telse {\n\t\t\t\tprintk(KERN_WARNING IPWIRELESS_PCCARD_NAME\n\t\t\t\t\t\": no valid memreg_tx value - switching to the old memreg_tx\\n\");\n\t\t\t\thw->memreg_tx =\n\t\t\t\t\t&hw->memory_info_regs->memreg_tx_old;\n\t\t\t\ttry_mem_tx_old = 1;\n\t\t\t}\n\t\t} else\n\t\t\tprintk(KERN_WARNING IPWIRELESS_PCCARD_NAME\n\t\t\t\t\t\": spurious interrupt - old_tx mode\\n\");\n\t}\n\n\t} while (try_mem_tx_old == 1);\n\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t ipwireless_interrupt(int irq, void *dev_id)\n{\n\tstruct ipw_dev *ipw = dev_id;\n\n\tif (ipw->hardware->hw_version == HW_VERSION_1)\n\t\treturn ipwireless_handle_v1_interrupt(irq, ipw->hardware);\n\telse\n\t\treturn ipwireless_handle_v2_v3_interrupt(irq, ipw->hardware);\n}\n\nstatic void flush_packets_to_hw(struct ipw_hardware *hw)\n{\n\tint priority_limit;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tpriority_limit = get_current_packet_priority(hw);\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\twhile (send_pending_packet(hw, priority_limit));\n}\n\nstatic void send_packet(struct ipw_hardware *hw, int priority,\n\t\t\tstruct ipw_tx_packet *packet)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tlist_add_tail(&packet->queue, &hw->tx_queue[priority]);\n\thw->tx_queued++;\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\tflush_packets_to_hw(hw);\n}\n\n \nstatic void *alloc_data_packet(int data_size,\n\t\t\t\tunsigned char dest_addr,\n\t\t\t\tunsigned char protocol)\n{\n\tstruct ipw_tx_packet *packet = kzalloc(\n\t\t\tsizeof(struct ipw_tx_packet) + data_size,\n\t\t\tGFP_ATOMIC);\n\n\tif (!packet)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&packet->queue);\n\tpacket->dest_addr = dest_addr;\n\tpacket->protocol = protocol;\n\tpacket->length = data_size;\n\n\treturn packet;\n}\n\nstatic void *alloc_ctrl_packet(int header_size,\n\t\t\t       unsigned char dest_addr,\n\t\t\t       unsigned char protocol,\n\t\t\t       unsigned char sig_no)\n{\n\t \n\tstruct ipw_control_packet *packet = kzalloc(header_size, GFP_ATOMIC);\n\n\tif (!packet)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&packet->header.queue);\n\tpacket->header.dest_addr = dest_addr;\n\tpacket->header.protocol = protocol;\n\tpacket->header.length = header_size - sizeof(struct ipw_tx_packet);\n\tpacket->body.sig_no = sig_no;\n\n\treturn packet;\n}\n\nint ipwireless_send_packet(struct ipw_hardware *hw, unsigned int channel_idx,\n\t\t\t    const u8 *data, unsigned int length,\n\t\t\t    void (*callback) (void *cb, unsigned int length),\n\t\t\t    void *callback_data)\n{\n\tstruct ipw_tx_packet *packet;\n\n\tpacket = alloc_data_packet(length, (channel_idx + 1),\n\t\t\tTL_PROTOCOLID_COM_DATA);\n\tif (!packet)\n\t\treturn -ENOMEM;\n\tpacket->packet_callback = callback;\n\tpacket->callback_data = callback_data;\n\tmemcpy((unsigned char *) packet + sizeof(struct ipw_tx_packet), data,\n\t\t\tlength);\n\n\tsend_packet(hw, PRIO_DATA, packet);\n\treturn 0;\n}\n\nstatic int set_control_line(struct ipw_hardware *hw, int prio,\n\t\t\t   unsigned int channel_idx, int line, int state)\n{\n\tstruct ipw_control_packet *packet;\n\tint protocolid = TL_PROTOCOLID_COM_CTRL;\n\n\tif (prio == PRIO_SETUP)\n\t\tprotocolid = TL_PROTOCOLID_SETUP;\n\n\tpacket = alloc_ctrl_packet(sizeof(struct ipw_control_packet),\n\t\t\t(channel_idx + 1), protocolid, line);\n\tif (!packet)\n\t\treturn -ENOMEM;\n\tpacket->header.length = sizeof(struct ipw_control_packet_body);\n\tpacket->body.value = (state == 0 ? 0 : 1);\n\tsend_packet(hw, prio, &packet->header);\n\treturn 0;\n}\n\n\nstatic int set_DTR(struct ipw_hardware *hw, int priority,\n\t\t   unsigned int channel_idx, int state)\n{\n\tif (state != 0)\n\t\thw->control_lines[channel_idx] |= IPW_CONTROL_LINE_DTR;\n\telse\n\t\thw->control_lines[channel_idx] &= ~IPW_CONTROL_LINE_DTR;\n\n\treturn set_control_line(hw, priority, channel_idx, COMCTRL_DTR, state);\n}\n\nstatic int set_RTS(struct ipw_hardware *hw, int priority,\n\t\t   unsigned int channel_idx, int state)\n{\n\tif (state != 0)\n\t\thw->control_lines[channel_idx] |= IPW_CONTROL_LINE_RTS;\n\telse\n\t\thw->control_lines[channel_idx] &= ~IPW_CONTROL_LINE_RTS;\n\n\treturn set_control_line(hw, priority, channel_idx, COMCTRL_RTS, state);\n}\n\nint ipwireless_set_DTR(struct ipw_hardware *hw, unsigned int channel_idx,\n\t\t       int state)\n{\n\treturn set_DTR(hw, PRIO_CTRL, channel_idx, state);\n}\n\nint ipwireless_set_RTS(struct ipw_hardware *hw, unsigned int channel_idx,\n\t\t       int state)\n{\n\treturn set_RTS(hw, PRIO_CTRL, channel_idx, state);\n}\n\nstruct ipw_setup_get_version_query_packet {\n\tstruct ipw_tx_packet header;\n\tstruct tl_setup_get_version_qry body;\n};\n\nstruct ipw_setup_config_packet {\n\tstruct ipw_tx_packet header;\n\tstruct tl_setup_config_msg body;\n};\n\nstruct ipw_setup_config_done_packet {\n\tstruct ipw_tx_packet header;\n\tstruct tl_setup_config_done_msg body;\n};\n\nstruct ipw_setup_open_packet {\n\tstruct ipw_tx_packet header;\n\tstruct tl_setup_open_msg body;\n};\n\nstruct ipw_setup_info_packet {\n\tstruct ipw_tx_packet header;\n\tstruct tl_setup_info_msg body;\n};\n\nstruct ipw_setup_reboot_msg_ack {\n\tstruct ipw_tx_packet header;\n\tstruct TlSetupRebootMsgAck body;\n};\n\n \nstatic void __handle_setup_get_version_rsp(struct ipw_hardware *hw)\n{\n\tstruct ipw_setup_config_packet *config_packet;\n\tstruct ipw_setup_config_done_packet *config_done_packet;\n\tstruct ipw_setup_open_packet *open_packet;\n\tstruct ipw_setup_info_packet *info_packet;\n\tint port;\n\tunsigned int channel_idx;\n\n\t \n\tfor (port = 1; port <= NL_NUM_OF_ADDRESSES; port++) {\n\t\tconfig_packet = alloc_ctrl_packet(\n\t\t\t\tsizeof(struct ipw_setup_config_packet),\n\t\t\t\tADDR_SETUP_PROT,\n\t\t\t\tTL_PROTOCOLID_SETUP,\n\t\t\t\tTL_SETUP_SIGNO_CONFIG_MSG);\n\t\tif (!config_packet)\n\t\t\tgoto exit_nomem;\n\t\tconfig_packet->header.length = sizeof(struct tl_setup_config_msg);\n\t\tconfig_packet->body.port_no = port;\n\t\tconfig_packet->body.prio_data = PRIO_DATA;\n\t\tconfig_packet->body.prio_ctrl = PRIO_CTRL;\n\t\tsend_packet(hw, PRIO_SETUP, &config_packet->header);\n\t}\n\tconfig_done_packet = alloc_ctrl_packet(\n\t\t\tsizeof(struct ipw_setup_config_done_packet),\n\t\t\tADDR_SETUP_PROT,\n\t\t\tTL_PROTOCOLID_SETUP,\n\t\t\tTL_SETUP_SIGNO_CONFIG_DONE_MSG);\n\tif (!config_done_packet)\n\t\tgoto exit_nomem;\n\tconfig_done_packet->header.length = sizeof(struct tl_setup_config_done_msg);\n\tsend_packet(hw, PRIO_SETUP, &config_done_packet->header);\n\n\t \n\tfor (port = 1; port <= NL_NUM_OF_ADDRESSES; port++) {\n\t\topen_packet = alloc_ctrl_packet(\n\t\t\t\tsizeof(struct ipw_setup_open_packet),\n\t\t\t\tADDR_SETUP_PROT,\n\t\t\t\tTL_PROTOCOLID_SETUP,\n\t\t\t\tTL_SETUP_SIGNO_OPEN_MSG);\n\t\tif (!open_packet)\n\t\t\tgoto exit_nomem;\n\t\topen_packet->header.length = sizeof(struct tl_setup_open_msg);\n\t\topen_packet->body.port_no = port;\n\t\tsend_packet(hw, PRIO_SETUP, &open_packet->header);\n\t}\n\tfor (channel_idx = 0;\n\t\t\tchannel_idx < NL_NUM_OF_ADDRESSES; channel_idx++) {\n\t\tint ret;\n\n\t\tret = set_DTR(hw, PRIO_SETUP, channel_idx,\n\t\t\t(hw->control_lines[channel_idx] &\n\t\t\t IPW_CONTROL_LINE_DTR) != 0);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\n\t\t\t\t\t\": error setting DTR (%d)\\n\", ret);\n\t\t\treturn;\n\t\t}\n\n\t\tret = set_RTS(hw, PRIO_SETUP, channel_idx,\n\t\t\t(hw->control_lines [channel_idx] &\n\t\t\t IPW_CONTROL_LINE_RTS) != 0);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\n\t\t\t\t\t\": error setting RTS (%d)\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tinfo_packet = alloc_ctrl_packet(sizeof(struct ipw_setup_info_packet),\n\t\t\tADDR_SETUP_PROT,\n\t\t\tTL_PROTOCOLID_SETUP,\n\t\t\tTL_SETUP_SIGNO_INFO_MSG);\n\tif (!info_packet)\n\t\tgoto exit_nomem;\n\tinfo_packet->header.length = sizeof(struct tl_setup_info_msg);\n\tinfo_packet->body.driver_type = NDISWAN_DRIVER;\n\tinfo_packet->body.major_version = NDISWAN_DRIVER_MAJOR_VERSION;\n\tinfo_packet->body.minor_version = NDISWAN_DRIVER_MINOR_VERSION;\n\tsend_packet(hw, PRIO_SETUP, &info_packet->header);\n\n\t \n\thw->to_setup = 0;\n\n\treturn;\n\nexit_nomem:\n\tprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\n\t\t\t\": not enough memory to alloc control packet\\n\");\n\thw->to_setup = -1;\n}\n\nstatic void handle_setup_get_version_rsp(struct ipw_hardware *hw,\n\t\tunsigned char vers_no)\n{\n\tdel_timer(&hw->setup_timer);\n\thw->initializing = 0;\n\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME \": card is ready.\\n\");\n\n\tif (vers_no == TL_SETUP_VERSION)\n\t\t__handle_setup_get_version_rsp(hw);\n\telse\n\t\tprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\n\t\t\t\t\": invalid hardware version no %u\\n\",\n\t\t\t\t(unsigned int) vers_no);\n}\n\nstatic void ipw_send_setup_packet(struct ipw_hardware *hw)\n{\n\tstruct ipw_setup_get_version_query_packet *ver_packet;\n\n\tver_packet = alloc_ctrl_packet(\n\t\t\tsizeof(struct ipw_setup_get_version_query_packet),\n\t\t\tADDR_SETUP_PROT, TL_PROTOCOLID_SETUP,\n\t\t\tTL_SETUP_SIGNO_GET_VERSION_QRY);\n\tif (!ver_packet)\n\t\treturn;\n\tver_packet->header.length = sizeof(struct tl_setup_get_version_qry);\n\n\t \n\tsend_packet(hw, PRIO_SETUP, &ver_packet->header);\n}\n\nstatic void handle_received_SETUP_packet(struct ipw_hardware *hw,\n\t\t\t\t\t unsigned int address,\n\t\t\t\t\t const unsigned char *data, int len,\n\t\t\t\t\t int is_last)\n{\n\tconst union ipw_setup_rx_msg *rx_msg = (const union ipw_setup_rx_msg *) data;\n\n\tif (address != ADDR_SETUP_PROT) {\n\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t       \": setup packet has bad address %d\\n\", address);\n\t\treturn;\n\t}\n\n\tswitch (rx_msg->sig_no) {\n\tcase TL_SETUP_SIGNO_GET_VERSION_RSP:\n\t\tif (hw->to_setup)\n\t\t\thandle_setup_get_version_rsp(hw,\n\t\t\t\t\trx_msg->version_rsp_msg.version);\n\t\tbreak;\n\n\tcase TL_SETUP_SIGNO_OPEN_MSG:\n\t\tif (ipwireless_debug) {\n\t\t\tunsigned int channel_idx = rx_msg->open_msg.port_no - 1;\n\n\t\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t\t       \": OPEN_MSG [channel %u] reply received\\n\",\n\t\t\t       channel_idx);\n\t\t}\n\t\tbreak;\n\n\tcase TL_SETUP_SIGNO_INFO_MSG_ACK:\n\t\tif (ipwireless_debug)\n\t\t\tprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME\n\t\t\t       \": card successfully configured as NDISWAN\\n\");\n\t\tbreak;\n\n\tcase TL_SETUP_SIGNO_REBOOT_MSG:\n\t\tif (hw->to_setup)\n\t\t\tprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME\n\t\t\t       \": Setup not completed - ignoring reboot msg\\n\");\n\t\telse {\n\t\t\tstruct ipw_setup_reboot_msg_ack *packet;\n\n\t\t\tprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME\n\t\t\t       \": Acknowledging REBOOT message\\n\");\n\t\t\tpacket = alloc_ctrl_packet(\n\t\t\t\t\tsizeof(struct ipw_setup_reboot_msg_ack),\n\t\t\t\t\tADDR_SETUP_PROT, TL_PROTOCOLID_SETUP,\n\t\t\t\t\tTL_SETUP_SIGNO_REBOOT_MSG_ACK);\n\t\t\tif (!packet) {\n\t\t\t\tpr_err(IPWIRELESS_PCCARD_NAME\n\t\t\t\t       \": Not enough memory to send reboot packet\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpacket->header.length =\n\t\t\t\tsizeof(struct TlSetupRebootMsgAck);\n\t\t\tsend_packet(hw, PRIO_SETUP, &packet->header);\n\t\t\tif (hw->reboot_callback)\n\t\t\t\thw->reboot_callback(hw->reboot_callback_data);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t       \": unknown setup message %u received\\n\",\n\t\t       (unsigned int) rx_msg->sig_no);\n\t}\n}\n\nstatic void do_close_hardware(struct ipw_hardware *hw)\n{\n\tunsigned int irqn;\n\n\tif (hw->hw_version == HW_VERSION_1) {\n\t\t \n\t\toutw(0, hw->base_port + IOIER);\n\n\t\t \n\t\tirqn = inw(hw->base_port + IOIR);\n\t\tif (irqn & IR_TXINTR)\n\t\t\toutw(IR_TXINTR, hw->base_port + IOIR);\n\t\tif (irqn & IR_RXINTR)\n\t\t\toutw(IR_RXINTR, hw->base_port + IOIR);\n\n\t\tsynchronize_irq(hw->irq);\n\t}\n}\n\nstruct ipw_hardware *ipwireless_hardware_create(void)\n{\n\tint i;\n\tstruct ipw_hardware *hw =\n\t\tkzalloc(sizeof(struct ipw_hardware), GFP_KERNEL);\n\n\tif (!hw)\n\t\treturn NULL;\n\n\thw->irq = -1;\n\thw->initializing = 1;\n\thw->tx_ready = 1;\n\thw->rx_bytes_queued = 0;\n\thw->rx_pool_size = 0;\n\thw->last_memtx_serial = (unsigned short) 0xffff;\n\tfor (i = 0; i < NL_NUM_OF_PRIORITIES; i++)\n\t\tINIT_LIST_HEAD(&hw->tx_queue[i]);\n\n\tINIT_LIST_HEAD(&hw->rx_queue);\n\tINIT_LIST_HEAD(&hw->rx_pool);\n\tspin_lock_init(&hw->lock);\n\ttasklet_setup(&hw->tasklet, ipwireless_do_tasklet);\n\tINIT_WORK(&hw->work_rx, ipw_receive_data_work);\n\ttimer_setup(&hw->setup_timer, ipwireless_setup_timer, 0);\n\n\treturn hw;\n}\n\nvoid ipwireless_init_hardware_v1(struct ipw_hardware *hw,\n\t\tunsigned int base_port,\n\t\tvoid __iomem *attr_memory,\n\t\tvoid __iomem *common_memory,\n\t\tint is_v2_card,\n\t\tvoid (*reboot_callback) (void *data),\n\t\tvoid *reboot_callback_data)\n{\n\tif (hw->removed) {\n\t\thw->removed = 0;\n\t\tenable_irq(hw->irq);\n\t}\n\thw->base_port = base_port;\n\thw->hw_version = (is_v2_card ? HW_VERSION_2 : HW_VERSION_1);\n\thw->ll_mtu = (hw->hw_version == HW_VERSION_1 ? LL_MTU_V1 : LL_MTU_V2);\n\thw->memregs_CCR = (struct MEMCCR __iomem *)\n\t\t\t((unsigned short __iomem *) attr_memory + 0x200);\n\thw->memory_info_regs = (struct MEMINFREG __iomem *) common_memory;\n\thw->memreg_tx = &hw->memory_info_regs->memreg_tx_new;\n\thw->reboot_callback = reboot_callback;\n\thw->reboot_callback_data = reboot_callback_data;\n}\n\nvoid ipwireless_init_hardware_v2_v3(struct ipw_hardware *hw)\n{\n\thw->initializing = 1;\n\thw->init_loops = 0;\n\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t       \": waiting for card to start up...\\n\");\n\tipwireless_setup_timer(&hw->setup_timer);\n}\n\nstatic void ipwireless_setup_timer(struct timer_list *t)\n{\n\tstruct ipw_hardware *hw = from_timer(hw, t, setup_timer);\n\n\thw->init_loops++;\n\n\tif (hw->init_loops == TL_SETUP_MAX_VERSION_QRY &&\n\t\t\thw->hw_version == HW_VERSION_2 &&\n\t\t\thw->memreg_tx == &hw->memory_info_regs->memreg_tx_new) {\n\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t\t\t\": failed to startup using TX2, trying TX\\n\");\n\n\t\thw->memreg_tx = &hw->memory_info_regs->memreg_tx_old;\n\t\thw->init_loops = 0;\n\t}\n\t \n\tif (hw->init_loops == TL_SETUP_MAX_VERSION_QRY) {\n\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t       \": card failed to start up!\\n\");\n\t\thw->initializing = 0;\n\t} else {\n\t\t \n\t\tif (is_card_present(hw)) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\t\thw->to_setup = 1;\n\t\t\thw->tx_ready = 1;\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\ttasklet_schedule(&hw->tasklet);\n\t\t}\n\n\t\tmod_timer(&hw->setup_timer,\n\t\t\tjiffies + msecs_to_jiffies(TL_SETUP_VERSION_QRY_TMO));\n\t}\n}\n\n \nvoid ipwireless_stop_interrupts(struct ipw_hardware *hw)\n{\n\tif (!hw->shutting_down) {\n\t\t \n\t\thw->shutting_down = 1;\n\t\tdel_timer(&hw->setup_timer);\n\n\t\t \n\t\tdo_close_hardware(hw);\n\t}\n}\n\nvoid ipwireless_hardware_free(struct ipw_hardware *hw)\n{\n\tint i;\n\tstruct ipw_rx_packet *rp, *rq;\n\tstruct ipw_tx_packet *tp, *tq;\n\n\tipwireless_stop_interrupts(hw);\n\n\tflush_work(&hw->work_rx);\n\n\tfor (i = 0; i < NL_NUM_OF_ADDRESSES; i++)\n\t\tkfree(hw->packet_assembler[i]);\n\n\tfor (i = 0; i < NL_NUM_OF_PRIORITIES; i++)\n\t\tlist_for_each_entry_safe(tp, tq, &hw->tx_queue[i], queue) {\n\t\t\tlist_del(&tp->queue);\n\t\t\tkfree(tp);\n\t\t}\n\n\tlist_for_each_entry_safe(rp, rq, &hw->rx_queue, queue) {\n\t\tlist_del(&rp->queue);\n\t\tkfree(rp);\n\t}\n\n\tlist_for_each_entry_safe(rp, rq, &hw->rx_pool, queue) {\n\t\tlist_del(&rp->queue);\n\t\tkfree(rp);\n\t}\n\tkfree(hw);\n}\n\n \nvoid ipwireless_associate_network(struct ipw_hardware *hw,\n\t\t\t\t  struct ipw_network *network)\n{\n\thw->network = network;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}