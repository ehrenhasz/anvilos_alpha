{
  "module_name": "network.c",
  "hash_id": "cf4c48dfa0f66948ea84081a49ca5a4fb6eb22b8bc7792d7c23b3f68ad28f951",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/ipwireless/network.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/ppp_channel.h>\n#include <linux/ppp_defs.h>\n#include <linux/slab.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/skbuff.h>\n\n#include \"network.h\"\n#include \"hardware.h\"\n#include \"main.h\"\n#include \"tty.h\"\n\n#define MAX_ASSOCIATED_TTYS 2\n\n#define SC_RCV_BITS     (SC_RCV_B7_1|SC_RCV_B7_0|SC_RCV_ODDP|SC_RCV_EVNP)\n\nstruct ipw_network {\n\t \n\tstruct ipw_hardware *hardware;\n\t \n\tstruct ppp_channel *ppp_channel;\n\t \n\tstruct ipw_tty *associated_ttys[NO_OF_IPW_CHANNELS][MAX_ASSOCIATED_TTYS];\n\t \n\tint ppp_blocked;\n\t \n\tint outgoing_packets_queued;\n\t \n\tspinlock_t lock;\n\tstruct mutex close_lock;\n\n\t \n\tunsigned int flags;\n\tunsigned int rbits;\n\tu32 xaccm[8];\n\tu32 raccm;\n\tint mru;\n\n\tint shutting_down;\n\tunsigned int ras_control_lines;\n\n\tstruct work_struct work_go_online;\n\tstruct work_struct work_go_offline;\n};\n\nstatic void notify_packet_sent(void *callback_data, unsigned int packet_length)\n{\n\tstruct ipw_network *network = callback_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&network->lock, flags);\n\tnetwork->outgoing_packets_queued--;\n\tif (network->ppp_channel != NULL) {\n\t\tif (network->ppp_blocked) {\n\t\t\tnetwork->ppp_blocked = 0;\n\t\t\tspin_unlock_irqrestore(&network->lock, flags);\n\t\t\tppp_output_wakeup(network->ppp_channel);\n\t\t\tif (ipwireless_debug)\n\t\t\t\tprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME\n\t\t\t\t       \": ppp unblocked\\n\");\n\t\t} else\n\t\t\tspin_unlock_irqrestore(&network->lock, flags);\n\t} else\n\t\tspin_unlock_irqrestore(&network->lock, flags);\n}\n\n \nstatic int ipwireless_ppp_start_xmit(struct ppp_channel *ppp_channel,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ipw_network *network = ppp_channel->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&network->lock, flags);\n\tif (network->outgoing_packets_queued < ipwireless_out_queue) {\n\t\tunsigned char *buf;\n\t\tstatic unsigned char header[] = {\n\t\t\tPPP_ALLSTATIONS,  \n\t\t\tPPP_UI,\t\t  \n\t\t};\n\t\tint ret;\n\n\t\tnetwork->outgoing_packets_queued++;\n\t\tspin_unlock_irqrestore(&network->lock, flags);\n\n\t\t \n\t\tif (skb_headroom(skb) >= 2) {\n\t\t\tmemcpy(skb_push(skb, 2), header, 2);\n\t\t\tret = ipwireless_send_packet(network->hardware,\n\t\t\t\t\t       IPW_CHANNEL_RAS, skb->data,\n\t\t\t\t\t       skb->len,\n\t\t\t\t\t       notify_packet_sent,\n\t\t\t\t\t       network);\n\t\t\tif (ret < 0) {\n\t\t\t\tskb_pull(skb, 2);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tbuf = kmalloc(skb->len + 2, GFP_ATOMIC);\n\t\t\tif (!buf)\n\t\t\t\treturn 0;\n\t\t\tmemcpy(buf + 2, skb->data, skb->len);\n\t\t\tmemcpy(buf, header, 2);\n\t\t\tret = ipwireless_send_packet(network->hardware,\n\t\t\t\t\t       IPW_CHANNEL_RAS, buf,\n\t\t\t\t\t       skb->len + 2,\n\t\t\t\t\t       notify_packet_sent,\n\t\t\t\t\t       network);\n\t\t\tkfree(buf);\n\t\t\tif (ret < 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\tkfree_skb(skb);\n\t\treturn 1;\n\t} else {\n\t\t \n\t\tnetwork->ppp_blocked = 1;\n\t\tspin_unlock_irqrestore(&network->lock, flags);\n\t\tif (ipwireless_debug)\n\t\t\tprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME \": ppp blocked\\n\");\n\t\treturn 0;\n\t}\n}\n\n \nstatic int ipwireless_ppp_ioctl(struct ppp_channel *ppp_channel,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct ipw_network *network = ppp_channel->private;\n\tint err, val;\n\tu32 accm[8];\n\tint __user *user_arg = (int __user *) arg;\n\n\terr = -EFAULT;\n\tswitch (cmd) {\n\tcase PPPIOCGFLAGS:\n\t\tval = network->flags | network->rbits;\n\t\tif (put_user(val, user_arg))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSFLAGS:\n\t\tif (get_user(val, user_arg))\n\t\t\tbreak;\n\t\tnetwork->flags = val & ~SC_RCV_BITS;\n\t\tnetwork->rbits = val & SC_RCV_BITS;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGASYNCMAP:\n\t\tif (put_user(network->xaccm[0], user_arg))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSASYNCMAP:\n\t\tif (get_user(network->xaccm[0], user_arg))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGRASYNCMAP:\n\t\tif (put_user(network->raccm, user_arg))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSRASYNCMAP:\n\t\tif (get_user(network->raccm, user_arg))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGXASYNCMAP:\n\t\tif (copy_to_user((void __user *) arg, network->xaccm,\n\t\t\t\t\tsizeof(network->xaccm)))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSXASYNCMAP:\n\t\tif (copy_from_user(accm, (void __user *) arg, sizeof(accm)))\n\t\t\tbreak;\n\t\taccm[2] &= ~0x40000000U;\t \n\t\taccm[3] |= 0x60000000U;\t \n\t\tmemcpy(network->xaccm, accm, sizeof(network->xaccm));\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGMRU:\n\t\tif (put_user(network->mru, user_arg))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSMRU:\n\t\tif (get_user(val, user_arg))\n\t\t\tbreak;\n\t\tif (val < PPP_MRU)\n\t\t\tval = PPP_MRU;\n\t\tnetwork->mru = val;\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\n\treturn err;\n}\n\nstatic const struct ppp_channel_ops ipwireless_ppp_channel_ops = {\n\t.start_xmit = ipwireless_ppp_start_xmit,\n\t.ioctl      = ipwireless_ppp_ioctl\n};\n\nstatic void do_go_online(struct work_struct *work_go_online)\n{\n\tstruct ipw_network *network =\n\t\tcontainer_of(work_go_online, struct ipw_network,\n\t\t\t\twork_go_online);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&network->lock, flags);\n\tif (!network->ppp_channel) {\n\t\tstruct ppp_channel *channel;\n\n\t\tspin_unlock_irqrestore(&network->lock, flags);\n\t\tchannel = kzalloc(sizeof(struct ppp_channel), GFP_KERNEL);\n\t\tif (!channel) {\n\t\t\tprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\n\t\t\t\t\t\": unable to allocate PPP channel\\n\");\n\t\t\treturn;\n\t\t}\n\t\tchannel->private = network;\n\t\tchannel->mtu = 16384;\t \n\t\tchannel->hdrlen = 2;\n\t\tchannel->ops = &ipwireless_ppp_channel_ops;\n\n\t\tnetwork->flags = 0;\n\t\tnetwork->rbits = 0;\n\t\tnetwork->mru = PPP_MRU;\n\t\tmemset(network->xaccm, 0, sizeof(network->xaccm));\n\t\tnetwork->xaccm[0] = ~0U;\n\t\tnetwork->xaccm[3] = 0x60000000U;\n\t\tnetwork->raccm = ~0U;\n\t\tif (ppp_register_channel(channel) < 0) {\n\t\t\tprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\n\t\t\t\t\t\": unable to register PPP channel\\n\");\n\t\t\tkfree(channel);\n\t\t\treturn;\n\t\t}\n\t\tspin_lock_irqsave(&network->lock, flags);\n\t\tnetwork->ppp_channel = channel;\n\t}\n\tspin_unlock_irqrestore(&network->lock, flags);\n}\n\nstatic void do_go_offline(struct work_struct *work_go_offline)\n{\n\tstruct ipw_network *network =\n\t\tcontainer_of(work_go_offline, struct ipw_network,\n\t\t\t\twork_go_offline);\n\tunsigned long flags;\n\n\tmutex_lock(&network->close_lock);\n\tspin_lock_irqsave(&network->lock, flags);\n\tif (network->ppp_channel != NULL) {\n\t\tstruct ppp_channel *channel = network->ppp_channel;\n\n\t\tnetwork->ppp_channel = NULL;\n\t\tspin_unlock_irqrestore(&network->lock, flags);\n\t\tmutex_unlock(&network->close_lock);\n\t\tppp_unregister_channel(channel);\n\t} else {\n\t\tspin_unlock_irqrestore(&network->lock, flags);\n\t\tmutex_unlock(&network->close_lock);\n\t}\n}\n\nvoid ipwireless_network_notify_control_line_change(struct ipw_network *network,\n\t\t\t\t\t\t   unsigned int channel_idx,\n\t\t\t\t\t\t   unsigned int control_lines,\n\t\t\t\t\t\t   unsigned int changed_mask)\n{\n\tint i;\n\n\tif (channel_idx == IPW_CHANNEL_RAS)\n\t\tnetwork->ras_control_lines = control_lines;\n\n\tfor (i = 0; i < MAX_ASSOCIATED_TTYS; i++) {\n\t\tstruct ipw_tty *tty =\n\t\t\tnetwork->associated_ttys[channel_idx][i];\n\n\t\t \n\t\tif (tty)\n\t\t\tipwireless_tty_notify_control_line_change(tty,\n\t\t\t\t\t\t\t\t  channel_idx,\n\t\t\t\t\t\t\t\t  control_lines,\n\t\t\t\t\t\t\t\t  changed_mask);\n\t}\n}\n\n \nstatic struct sk_buff *ipw_packet_received_skb(unsigned char *data,\n\t\t\t\t\t       unsigned int length)\n{\n\tstruct sk_buff *skb;\n\n\tif (length > 2 && data[0] == PPP_ALLSTATIONS && data[1] == PPP_UI) {\n\t\tlength -= 2;\n\t\tdata += 2;\n\t}\n\n\tskb = dev_alloc_skb(length + 4);\n\tif (skb == NULL)\n\t\treturn NULL;\n\tskb_reserve(skb, 2);\n\tskb_put_data(skb, data, length);\n\n\treturn skb;\n}\n\nvoid ipwireless_network_packet_received(struct ipw_network *network,\n\t\t\t\t\tunsigned int channel_idx,\n\t\t\t\t\tunsigned char *data,\n\t\t\t\t\tunsigned int length)\n{\n\tint i;\n\tunsigned long flags;\n\n\tfor (i = 0; i < MAX_ASSOCIATED_TTYS; i++) {\n\t\tstruct ipw_tty *tty = network->associated_ttys[channel_idx][i];\n\n\t\tif (!tty)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (channel_idx == IPW_CHANNEL_RAS\n\t\t\t\t&& (network->ras_control_lines &\n\t\t\t\t\tIPW_CONTROL_LINE_DCD) != 0\n\t\t\t\t&& ipwireless_tty_is_modem(tty)) {\n\t\t\t \n\t\t\tmutex_lock(&network->close_lock);\n\t\t\tspin_lock_irqsave(&network->lock, flags);\n\t\t\tif (network->ppp_channel != NULL) {\n\t\t\t\tstruct sk_buff *skb;\n\n\t\t\t\tspin_unlock_irqrestore(&network->lock,\n\t\t\t\t\t\tflags);\n\n\t\t\t\t \n\t\t\t\tskb = ipw_packet_received_skb(data, length);\n\t\t\t\tif (skb)\n\t\t\t\t\tppp_input(network->ppp_channel, skb);\n\t\t\t} else\n\t\t\t\tspin_unlock_irqrestore(&network->lock,\n\t\t\t\t\t\tflags);\n\t\t\tmutex_unlock(&network->close_lock);\n\t\t}\n\t\t \n\t\telse\n\t\t\tipwireless_tty_received(tty, data, length);\n\t}\n}\n\nstruct ipw_network *ipwireless_network_create(struct ipw_hardware *hw)\n{\n\tstruct ipw_network *network =\n\t\tkzalloc(sizeof(struct ipw_network), GFP_KERNEL);\n\n\tif (!network)\n\t\treturn NULL;\n\n\tspin_lock_init(&network->lock);\n\tmutex_init(&network->close_lock);\n\n\tnetwork->hardware = hw;\n\n\tINIT_WORK(&network->work_go_online, do_go_online);\n\tINIT_WORK(&network->work_go_offline, do_go_offline);\n\n\tipwireless_associate_network(hw, network);\n\n\treturn network;\n}\n\nvoid ipwireless_network_free(struct ipw_network *network)\n{\n\tnetwork->shutting_down = 1;\n\n\tipwireless_ppp_close(network);\n\tflush_work(&network->work_go_online);\n\tflush_work(&network->work_go_offline);\n\n\tipwireless_stop_interrupts(network->hardware);\n\tipwireless_associate_network(network->hardware, NULL);\n\n\tkfree(network);\n}\n\nvoid ipwireless_associate_network_tty(struct ipw_network *network,\n\t\t\t\t      unsigned int channel_idx,\n\t\t\t\t      struct ipw_tty *tty)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ASSOCIATED_TTYS; i++)\n\t\tif (network->associated_ttys[channel_idx][i] == NULL) {\n\t\t\tnetwork->associated_ttys[channel_idx][i] = tty;\n\t\t\tbreak;\n\t\t}\n}\n\nvoid ipwireless_disassociate_network_ttys(struct ipw_network *network,\n\t\t\t\t\t  unsigned int channel_idx)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ASSOCIATED_TTYS; i++)\n\t\tnetwork->associated_ttys[channel_idx][i] = NULL;\n}\n\nvoid ipwireless_ppp_open(struct ipw_network *network)\n{\n\tif (ipwireless_debug)\n\t\tprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME \": online\\n\");\n\tschedule_work(&network->work_go_online);\n}\n\nvoid ipwireless_ppp_close(struct ipw_network *network)\n{\n\t \n\tif (ipwireless_debug)\n\t\tprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME \": offline\\n\");\n\tschedule_work(&network->work_go_offline);\n}\n\nint ipwireless_ppp_channel_index(struct ipw_network *network)\n{\n\tint ret = -1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&network->lock, flags);\n\tif (network->ppp_channel != NULL)\n\t\tret = ppp_channel_index(network->ppp_channel);\n\tspin_unlock_irqrestore(&network->lock, flags);\n\n\treturn ret;\n}\n\nint ipwireless_ppp_unit_number(struct ipw_network *network)\n{\n\tint ret = -1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&network->lock, flags);\n\tif (network->ppp_channel != NULL)\n\t\tret = ppp_unit_number(network->ppp_channel);\n\tspin_unlock_irqrestore(&network->lock, flags);\n\n\treturn ret;\n}\n\nint ipwireless_ppp_mru(const struct ipw_network *network)\n{\n\treturn network->mru;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}