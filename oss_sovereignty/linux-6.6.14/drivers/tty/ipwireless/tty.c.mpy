{
  "module_name": "tty.c",
  "hash_id": "aa8da83ab935f74770cb0deb20b343512c834e1f69993ac22ab108bcc98bd3d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/ipwireless/tty.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/ppp_defs.h>\n#include <linux/if.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/sched.h>\n#include <linux/serial.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/uaccess.h>\n\n#include \"tty.h\"\n#include \"network.h\"\n#include \"hardware.h\"\n#include \"main.h\"\n\n#define IPWIRELESS_PCMCIA_START \t(0)\n#define IPWIRELESS_PCMCIA_MINORS\t(24)\n#define IPWIRELESS_PCMCIA_MINOR_RANGE\t(8)\n\n#define TTYTYPE_MODEM    (0)\n#define TTYTYPE_MONITOR  (1)\n#define TTYTYPE_RAS_RAW  (2)\n\nstruct ipw_tty {\n\tstruct tty_port port;\n\tint index;\n\tstruct ipw_hardware *hardware;\n\tunsigned int channel_idx;\n\tunsigned int secondary_channel_idx;\n\tint tty_type;\n\tstruct ipw_network *network;\n\tunsigned int control_lines;\n\tstruct mutex ipw_tty_mutex;\n\tint tx_bytes_queued;\n};\n\nstatic struct ipw_tty *ttys[IPWIRELESS_PCMCIA_MINORS];\n\nstatic struct tty_driver *ipw_tty_driver;\n\nstatic char *tty_type_name(int tty_type)\n{\n\tstatic char *channel_names[] = {\n\t\t\"modem\",\n\t\t\"monitor\",\n\t\t\"RAS-raw\"\n\t};\n\n\treturn channel_names[tty_type];\n}\n\nstatic struct ipw_tty *get_tty(int index)\n{\n\t \n\tif (!ipwireless_loopback && index >=\n\t\t\t IPWIRELESS_PCMCIA_MINOR_RANGE * TTYTYPE_RAS_RAW)\n\t\treturn NULL;\n\n\treturn ttys[index];\n}\n\nstatic int ipw_open(struct tty_struct *linux_tty, struct file *filp)\n{\n\tstruct ipw_tty *tty = get_tty(linux_tty->index);\n\n\tif (!tty)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&tty->ipw_tty_mutex);\n\tif (tty->port.count == 0)\n\t\ttty->tx_bytes_queued = 0;\n\n\ttty->port.count++;\n\n\ttty->port.tty = linux_tty;\n\tlinux_tty->driver_data = tty;\n\n\tif (tty->tty_type == TTYTYPE_MODEM)\n\t\tipwireless_ppp_open(tty->network);\n\n\tmutex_unlock(&tty->ipw_tty_mutex);\n\n\treturn 0;\n}\n\nstatic void do_ipw_close(struct ipw_tty *tty)\n{\n\ttty->port.count--;\n\n\tif (tty->port.count == 0) {\n\t\tstruct tty_struct *linux_tty = tty->port.tty;\n\n\t\tif (linux_tty != NULL) {\n\t\t\ttty->port.tty = NULL;\n\t\t\tlinux_tty->driver_data = NULL;\n\n\t\t\tif (tty->tty_type == TTYTYPE_MODEM)\n\t\t\t\tipwireless_ppp_close(tty->network);\n\t\t}\n\t}\n}\n\nstatic void ipw_hangup(struct tty_struct *linux_tty)\n{\n\tstruct ipw_tty *tty = linux_tty->driver_data;\n\n\tif (!tty)\n\t\treturn;\n\n\tmutex_lock(&tty->ipw_tty_mutex);\n\tif (tty->port.count == 0) {\n\t\tmutex_unlock(&tty->ipw_tty_mutex);\n\t\treturn;\n\t}\n\n\tdo_ipw_close(tty);\n\n\tmutex_unlock(&tty->ipw_tty_mutex);\n}\n\nstatic void ipw_close(struct tty_struct *linux_tty, struct file *filp)\n{\n\tipw_hangup(linux_tty);\n}\n\n \nvoid ipwireless_tty_received(struct ipw_tty *tty, unsigned char *data,\n\t\t\tunsigned int length)\n{\n\tint work = 0;\n\n\tmutex_lock(&tty->ipw_tty_mutex);\n\n\tif (!tty->port.count) {\n\t\tmutex_unlock(&tty->ipw_tty_mutex);\n\t\treturn;\n\t}\n\tmutex_unlock(&tty->ipw_tty_mutex);\n\n\twork = tty_insert_flip_string(&tty->port, data, length);\n\n\tif (work != length)\n\t\tprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME\n\t\t\t\t\": %d chars not inserted to flip buffer!\\n\",\n\t\t\t\tlength - work);\n\n\tif (work)\n\t\ttty_flip_buffer_push(&tty->port);\n}\n\nstatic void ipw_write_packet_sent_callback(void *callback_data,\n\t\t\t\t\t   unsigned int packet_length)\n{\n\tstruct ipw_tty *tty = callback_data;\n\n\t \n\ttty->tx_bytes_queued -= packet_length;\n}\n\nstatic ssize_t ipw_write(struct tty_struct *linux_tty, const u8 *buf,\n\t\t\t size_t count)\n{\n\tstruct ipw_tty *tty = linux_tty->driver_data;\n\tint room, ret;\n\n\tif (!tty)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&tty->ipw_tty_mutex);\n\tif (!tty->port.count) {\n\t\tmutex_unlock(&tty->ipw_tty_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\troom = IPWIRELESS_TX_QUEUE_SIZE - tty->tx_bytes_queued;\n\tif (room < 0)\n\t\troom = 0;\n\t \n\tif (count > room)\n\t\tcount = room;\n\n\tif (count == 0) {\n\t\tmutex_unlock(&tty->ipw_tty_mutex);\n\t\treturn 0;\n\t}\n\n\tret = ipwireless_send_packet(tty->hardware, IPW_CHANNEL_RAS,\n\t\t\t       buf, count,\n\t\t\t       ipw_write_packet_sent_callback, tty);\n\tif (ret < 0) {\n\t\tmutex_unlock(&tty->ipw_tty_mutex);\n\t\treturn 0;\n\t}\n\n\ttty->tx_bytes_queued += count;\n\tmutex_unlock(&tty->ipw_tty_mutex);\n\n\treturn count;\n}\n\nstatic unsigned int ipw_write_room(struct tty_struct *linux_tty)\n{\n\tstruct ipw_tty *tty = linux_tty->driver_data;\n\tint room;\n\n\t \n\tif (!tty)\n\t\treturn 0;\n\n\tif (!tty->port.count)\n\t\treturn 0;\n\n\troom = IPWIRELESS_TX_QUEUE_SIZE - tty->tx_bytes_queued;\n\tif (room < 0)\n\t\troom = 0;\n\n\treturn room;\n}\n\nstatic int ipwireless_get_serial_info(struct tty_struct *linux_tty,\n\t\t\t\t      struct serial_struct *ss)\n{\n\tstruct ipw_tty *tty = linux_tty->driver_data;\n\n\tif (!tty)\n\t\treturn -ENODEV;\n\n\tif (!tty->port.count)\n\t\treturn -EINVAL;\n\n\tss->type = PORT_UNKNOWN;\n\tss->line = tty->index;\n\tss->baud_base = 115200;\n\treturn 0;\n}\n\nstatic int ipwireless_set_serial_info(struct tty_struct *linux_tty,\n\t\t\t\t      struct serial_struct *ss)\n{\n\treturn 0;\t \n}\n\nstatic unsigned int ipw_chars_in_buffer(struct tty_struct *linux_tty)\n{\n\tstruct ipw_tty *tty = linux_tty->driver_data;\n\n\tif (!tty)\n\t\treturn 0;\n\n\tif (!tty->port.count)\n\t\treturn 0;\n\n\treturn tty->tx_bytes_queued;\n}\n\nstatic int get_control_lines(struct ipw_tty *tty)\n{\n\tunsigned int my = tty->control_lines;\n\tunsigned int out = 0;\n\n\tif (my & IPW_CONTROL_LINE_RTS)\n\t\tout |= TIOCM_RTS;\n\tif (my & IPW_CONTROL_LINE_DTR)\n\t\tout |= TIOCM_DTR;\n\tif (my & IPW_CONTROL_LINE_CTS)\n\t\tout |= TIOCM_CTS;\n\tif (my & IPW_CONTROL_LINE_DSR)\n\t\tout |= TIOCM_DSR;\n\tif (my & IPW_CONTROL_LINE_DCD)\n\t\tout |= TIOCM_CD;\n\n\treturn out;\n}\n\nstatic int set_control_lines(struct ipw_tty *tty, unsigned int set,\n\t\t\t     unsigned int clear)\n{\n\tint ret;\n\n\tif (set & TIOCM_RTS) {\n\t\tret = ipwireless_set_RTS(tty->hardware, tty->channel_idx, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (tty->secondary_channel_idx != -1) {\n\t\t\tret = ipwireless_set_RTS(tty->hardware,\n\t\t\t\t\t  tty->secondary_channel_idx, 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tif (set & TIOCM_DTR) {\n\t\tret = ipwireless_set_DTR(tty->hardware, tty->channel_idx, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (tty->secondary_channel_idx != -1) {\n\t\t\tret = ipwireless_set_DTR(tty->hardware,\n\t\t\t\t\t  tty->secondary_channel_idx, 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tif (clear & TIOCM_RTS) {\n\t\tret = ipwireless_set_RTS(tty->hardware, tty->channel_idx, 0);\n\t\tif (tty->secondary_channel_idx != -1) {\n\t\t\tret = ipwireless_set_RTS(tty->hardware,\n\t\t\t\t\t  tty->secondary_channel_idx, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tif (clear & TIOCM_DTR) {\n\t\tret = ipwireless_set_DTR(tty->hardware, tty->channel_idx, 0);\n\t\tif (tty->secondary_channel_idx != -1) {\n\t\t\tret = ipwireless_set_DTR(tty->hardware,\n\t\t\t\t\t  tty->secondary_channel_idx, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ipw_tiocmget(struct tty_struct *linux_tty)\n{\n\tstruct ipw_tty *tty = linux_tty->driver_data;\n\t \n\n\tif (!tty)\n\t\treturn -ENODEV;\n\n\tif (!tty->port.count)\n\t\treturn -EINVAL;\n\n\treturn get_control_lines(tty);\n}\n\nstatic int\nipw_tiocmset(struct tty_struct *linux_tty,\n\t     unsigned int set, unsigned int clear)\n{\n\tstruct ipw_tty *tty = linux_tty->driver_data;\n\t \n\n\tif (!tty)\n\t\treturn -ENODEV;\n\n\tif (!tty->port.count)\n\t\treturn -EINVAL;\n\n\treturn set_control_lines(tty, set, clear);\n}\n\nstatic int ipw_ioctl(struct tty_struct *linux_tty,\n\t\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct ipw_tty *tty = linux_tty->driver_data;\n\n\tif (!tty)\n\t\treturn -ENODEV;\n\n\tif (!tty->port.count)\n\t\treturn -EINVAL;\n\n\t \n\tif (tty->tty_type == TTYTYPE_MODEM) {\n\t\tswitch (cmd) {\n\t\tcase PPPIOCGCHAN:\n\t\t\t{\n\t\t\t\tint chan = ipwireless_ppp_channel_index(\n\t\t\t\t\t\t\ttty->network);\n\n\t\t\t\tif (chan < 0)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (put_user(chan, (int __user *) arg))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\tcase PPPIOCGUNIT:\n\t\t\t{\n\t\t\t\tint unit = ipwireless_ppp_unit_number(\n\t\t\t\t\t\ttty->network);\n\n\t\t\t\tif (unit < 0)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (put_user(unit, (int __user *) arg))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\tcase FIONREAD:\n\t\t\t{\n\t\t\t\tint val = 0;\n\n\t\t\t\tif (put_user(val, (int __user *) arg))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase TCFLSH:\n\t\t\treturn tty_perform_flush(linux_tty, arg);\n\t\t}\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\nstatic int add_tty(int j,\n\t\t    struct ipw_hardware *hardware,\n\t\t    struct ipw_network *network, int channel_idx,\n\t\t    int secondary_channel_idx, int tty_type)\n{\n\tttys[j] = kzalloc(sizeof(struct ipw_tty), GFP_KERNEL);\n\tif (!ttys[j])\n\t\treturn -ENOMEM;\n\tttys[j]->index = j;\n\tttys[j]->hardware = hardware;\n\tttys[j]->channel_idx = channel_idx;\n\tttys[j]->secondary_channel_idx = secondary_channel_idx;\n\tttys[j]->network = network;\n\tttys[j]->tty_type = tty_type;\n\tmutex_init(&ttys[j]->ipw_tty_mutex);\n\ttty_port_init(&ttys[j]->port);\n\n\ttty_port_register_device(&ttys[j]->port, ipw_tty_driver, j, NULL);\n\tipwireless_associate_network_tty(network, channel_idx, ttys[j]);\n\n\tif (secondary_channel_idx != -1)\n\t\tipwireless_associate_network_tty(network,\n\t\t\t\t\t\t secondary_channel_idx,\n\t\t\t\t\t\t ttys[j]);\n\t \n\tif (get_tty(j))\n\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t       \": registering %s device ttyIPWp%d\\n\",\n\t\t       tty_type_name(tty_type), j);\n\n\treturn 0;\n}\n\nstruct ipw_tty *ipwireless_tty_create(struct ipw_hardware *hardware,\n\t\t\t\t      struct ipw_network *network)\n{\n\tint i, j;\n\n\tfor (i = 0; i < IPWIRELESS_PCMCIA_MINOR_RANGE; i++) {\n\t\tint allfree = 1;\n\n\t\tfor (j = i; j < IPWIRELESS_PCMCIA_MINORS;\n\t\t\t\tj += IPWIRELESS_PCMCIA_MINOR_RANGE)\n\t\t\tif (ttys[j] != NULL) {\n\t\t\t\tallfree = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (allfree) {\n\t\t\tj = i;\n\n\t\t\tif (add_tty(j, hardware, network,\n\t\t\t\t\tIPW_CHANNEL_DIALLER, IPW_CHANNEL_RAS,\n\t\t\t\t\tTTYTYPE_MODEM))\n\t\t\t\treturn NULL;\n\n\t\t\tj += IPWIRELESS_PCMCIA_MINOR_RANGE;\n\t\t\tif (add_tty(j, hardware, network,\n\t\t\t\t\tIPW_CHANNEL_DIALLER, -1,\n\t\t\t\t\tTTYTYPE_MONITOR))\n\t\t\t\treturn NULL;\n\n\t\t\tj += IPWIRELESS_PCMCIA_MINOR_RANGE;\n\t\t\tif (add_tty(j, hardware, network,\n\t\t\t\t\tIPW_CHANNEL_RAS, -1,\n\t\t\t\t\tTTYTYPE_RAS_RAW))\n\t\t\t\treturn NULL;\n\n\t\t\treturn ttys[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nvoid ipwireless_tty_free(struct ipw_tty *tty)\n{\n\tint j;\n\tstruct ipw_network *network = ttys[tty->index]->network;\n\n\tfor (j = tty->index; j < IPWIRELESS_PCMCIA_MINORS;\n\t\t\tj += IPWIRELESS_PCMCIA_MINOR_RANGE) {\n\t\tstruct ipw_tty *ttyj = ttys[j];\n\n\t\tif (ttyj) {\n\t\t\tmutex_lock(&ttyj->ipw_tty_mutex);\n\t\t\tif (get_tty(j))\n\t\t\t\tprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\n\t\t\t\t       \": deregistering %s device ttyIPWp%d\\n\",\n\t\t\t\t       tty_type_name(ttyj->tty_type), j);\n\t\t\tif (ttyj->port.tty != NULL) {\n\t\t\t\tmutex_unlock(&ttyj->ipw_tty_mutex);\n\t\t\t\ttty_vhangup(ttyj->port.tty);\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tmutex_lock(&ttyj->ipw_tty_mutex);\n\t\t\t}\n\t\t\twhile (ttyj->port.count)\n\t\t\t\tdo_ipw_close(ttyj);\n\t\t\tipwireless_disassociate_network_ttys(network,\n\t\t\t\t\t\t\t     ttyj->channel_idx);\n\t\t\ttty_unregister_device(ipw_tty_driver, j);\n\t\t\ttty_port_destroy(&ttyj->port);\n\t\t\tttys[j] = NULL;\n\t\t\tmutex_unlock(&ttyj->ipw_tty_mutex);\n\t\t\tkfree(ttyj);\n\t\t}\n\t}\n}\n\nstatic const struct tty_operations tty_ops = {\n\t.open = ipw_open,\n\t.close = ipw_close,\n\t.hangup = ipw_hangup,\n\t.write = ipw_write,\n\t.write_room = ipw_write_room,\n\t.ioctl = ipw_ioctl,\n\t.chars_in_buffer = ipw_chars_in_buffer,\n\t.tiocmget = ipw_tiocmget,\n\t.tiocmset = ipw_tiocmset,\n\t.set_serial = ipwireless_set_serial_info,\n\t.get_serial = ipwireless_get_serial_info,\n};\n\nint ipwireless_tty_init(void)\n{\n\tint result;\n\n\tipw_tty_driver = tty_alloc_driver(IPWIRELESS_PCMCIA_MINORS,\n\t\t\tTTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(ipw_tty_driver))\n\t\treturn PTR_ERR(ipw_tty_driver);\n\n\tipw_tty_driver->driver_name = IPWIRELESS_PCCARD_NAME;\n\tipw_tty_driver->name = \"ttyIPWp\";\n\tipw_tty_driver->major = 0;\n\tipw_tty_driver->minor_start = IPWIRELESS_PCMCIA_START;\n\tipw_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;\n\tipw_tty_driver->subtype = SERIAL_TYPE_NORMAL;\n\tipw_tty_driver->init_termios = tty_std_termios;\n\tipw_tty_driver->init_termios.c_cflag =\n\t    B9600 | CS8 | CREAD | HUPCL | CLOCAL;\n\tipw_tty_driver->init_termios.c_ispeed = 9600;\n\tipw_tty_driver->init_termios.c_ospeed = 9600;\n\ttty_set_operations(ipw_tty_driver, &tty_ops);\n\tresult = tty_register_driver(ipw_tty_driver);\n\tif (result) {\n\t\tprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\n\t\t       \": failed to register tty driver\\n\");\n\t\ttty_driver_kref_put(ipw_tty_driver);\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nvoid ipwireless_tty_release(void)\n{\n\ttty_unregister_driver(ipw_tty_driver);\n\ttty_driver_kref_put(ipw_tty_driver);\n}\n\nint ipwireless_tty_is_modem(struct ipw_tty *tty)\n{\n\treturn tty->tty_type == TTYTYPE_MODEM;\n}\n\nvoid\nipwireless_tty_notify_control_line_change(struct ipw_tty *tty,\n\t\t\t\t\t  unsigned int channel_idx,\n\t\t\t\t\t  unsigned int control_lines,\n\t\t\t\t\t  unsigned int changed_mask)\n{\n\tunsigned int old_control_lines = tty->control_lines;\n\n\ttty->control_lines = (tty->control_lines & ~changed_mask)\n\t\t| (control_lines & changed_mask);\n\n\t \n\tif ((old_control_lines & IPW_CONTROL_LINE_DCD)\n\t\t\t&& !(tty->control_lines & IPW_CONTROL_LINE_DCD)\n\t\t\t&& tty->port.tty) {\n\t\ttty_hangup(tty->port.tty);\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}