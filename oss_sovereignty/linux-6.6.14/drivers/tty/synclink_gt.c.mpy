{
  "module_name": "synclink_gt.c",
  "hash_id": "06a406bac5d40232400c5ec7f6ff01c539d9209dd8bd9446ddae2baba56f8299",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/synclink_gt.c",
  "human_readable_source": "\n \n\n \n\n#define DBGINFO(fmt) if (debug_level >= DEBUG_LEVEL_INFO) printk fmt\n#define DBGERR(fmt) if (debug_level >= DEBUG_LEVEL_ERROR) printk fmt\n#define DBGBH(fmt) if (debug_level >= DEBUG_LEVEL_BH) printk fmt\n#define DBGISR(fmt) if (debug_level >= DEBUG_LEVEL_ISR) printk fmt\n#define DBGDATA(info, buf, size, label) if (debug_level >= DEBUG_LEVEL_DATA) trace_block((info), (buf), (size), (label))\n \n \n\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/ioctl.h>\n#include <linux/termios.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/hdlc.h>\n#include <linux/synclink.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/dma.h>\n#include <asm/types.h>\n#include <linux/uaccess.h>\n\n#if defined(CONFIG_HDLC) || (defined(CONFIG_HDLC_MODULE) && defined(CONFIG_SYNCLINK_GT_MODULE))\n#define SYNCLINK_GENERIC_HDLC 1\n#else\n#define SYNCLINK_GENERIC_HDLC 0\n#endif\n\n \nstatic const char driver_name[] = \"SyncLink GT\";\nstatic const char tty_dev_prefix[] = \"ttySLG\";\nMODULE_LICENSE(\"GPL\");\n#define MAX_DEVICES 32\n\nstatic const struct pci_device_id pci_table[] = {\n\t{ PCI_VDEVICE(MICROGATE, SYNCLINK_GT_DEVICE_ID) },\n\t{ PCI_VDEVICE(MICROGATE, SYNCLINK_GT2_DEVICE_ID) },\n\t{ PCI_VDEVICE(MICROGATE, SYNCLINK_GT4_DEVICE_ID) },\n\t{ PCI_VDEVICE(MICROGATE, SYNCLINK_AC_DEVICE_ID) },\n\t{ 0 },  \n};\nMODULE_DEVICE_TABLE(pci, pci_table);\n\nstatic int  init_one(struct pci_dev *dev,const struct pci_device_id *ent);\nstatic void remove_one(struct pci_dev *dev);\nstatic struct pci_driver pci_driver = {\n\t.name\t\t= \"synclink_gt\",\n\t.id_table\t= pci_table,\n\t.probe\t\t= init_one,\n\t.remove\t\t= remove_one,\n};\n\nstatic bool pci_registered;\n\n \nstatic struct slgt_info *slgt_device_list;\nstatic int slgt_device_count;\n\nstatic int ttymajor;\nstatic int debug_level;\nstatic int maxframe[MAX_DEVICES];\n\nmodule_param(ttymajor, int, 0);\nmodule_param(debug_level, int, 0);\nmodule_param_array(maxframe, int, NULL, 0);\n\nMODULE_PARM_DESC(ttymajor, \"TTY major device number override: 0=auto assigned\");\nMODULE_PARM_DESC(debug_level, \"Debug syslog output: 0=disabled, 1 to 5=increasing detail\");\nMODULE_PARM_DESC(maxframe, \"Maximum frame size used by device (4096 to 65535)\");\n\n \nstatic struct tty_driver *serial_driver;\n\nstatic void wait_until_sent(struct tty_struct *tty, int timeout);\nstatic void flush_buffer(struct tty_struct *tty);\nstatic void tx_release(struct tty_struct *tty);\n\n \n#define dev_to_port(D) (dev_to_hdlc(D)->priv)\n\n\n \n\n#define SLGT_MAX_PORTS 4\n#define SLGT_REG_SIZE  256\n\n \nstruct cond_wait {\n\tstruct cond_wait *next;\n\twait_queue_head_t q;\n\twait_queue_entry_t wait;\n\tunsigned int data;\n};\nstatic void flush_cond_wait(struct cond_wait **head);\n\n \nstruct slgt_desc\n{\n\t__le16 count;\n\t__le16 status;\n\t__le32 pbuf;   \n\t__le32 next;   \n\n\t \n\tchar *buf;           \n    \tunsigned int pdesc;  \n\tdma_addr_t buf_dma_addr;\n\tunsigned short buf_count;\n};\n\n#define set_desc_buffer(a,b) (a).pbuf = cpu_to_le32((unsigned int)(b))\n#define set_desc_next(a,b) (a).next   = cpu_to_le32((unsigned int)(b))\n#define set_desc_count(a,b)(a).count  = cpu_to_le16((unsigned short)(b))\n#define set_desc_eof(a,b)  (a).status = cpu_to_le16((b) ? (le16_to_cpu((a).status) | BIT0) : (le16_to_cpu((a).status) & ~BIT0))\n#define set_desc_status(a, b) (a).status = cpu_to_le16((unsigned short)(b))\n#define desc_count(a)      (le16_to_cpu((a).count))\n#define desc_status(a)     (le16_to_cpu((a).status))\n#define desc_complete(a)   (le16_to_cpu((a).status) & BIT15)\n#define desc_eof(a)        (le16_to_cpu((a).status) & BIT2)\n#define desc_crc_error(a)  (le16_to_cpu((a).status) & BIT1)\n#define desc_abort(a)      (le16_to_cpu((a).status) & BIT0)\n#define desc_residue(a)    ((le16_to_cpu((a).status) & 0x38) >> 3)\n\nstruct _input_signal_events {\n\tint ri_up;\n\tint ri_down;\n\tint dsr_up;\n\tint dsr_down;\n\tint dcd_up;\n\tint dcd_down;\n\tint cts_up;\n\tint cts_down;\n};\n\n \nstruct slgt_info {\n\tvoid *if_ptr;\t\t \n\tstruct tty_port port;\n\n\tstruct slgt_info *next_device;\t \n\n\tchar device_name[25];\n\tstruct pci_dev *pdev;\n\n\tint port_count;   \n\tint adapter_num;  \n\tint port_num;     \n\n\t \n\tstruct slgt_info *port_array[SLGT_MAX_PORTS];\n\n\tint\t\t\tline;\t\t \n\n\tstruct mgsl_icount\ticount;\n\n\tint\t\t\ttimeout;\n\tint\t\t\tx_char;\t\t \n\tunsigned int\t\tread_status_mask;\n\tunsigned int \t\tignore_status_mask;\n\n\twait_queue_head_t\tstatus_event_wait_q;\n\twait_queue_head_t\tevent_wait_q;\n\tstruct timer_list\ttx_timer;\n\tstruct timer_list\trx_timer;\n\n\tunsigned int            gpio_present;\n\tstruct cond_wait        *gpio_wait_q;\n\n\tspinlock_t lock;\t \n\n\tstruct work_struct task;\n\tu32 pending_bh;\n\tbool bh_requested;\n\tbool bh_running;\n\n\tint isr_overflow;\n\tbool irq_requested;\t \n\tbool irq_occurred;\t \n\n\t \n\n\tunsigned int bus_type;\n\tunsigned int irq_level;\n\tunsigned long irq_flags;\n\n\tunsigned char __iomem * reg_addr;   \n\tu32 phys_reg_addr;\n\tbool reg_addr_requested;\n\n\tMGSL_PARAMS params;        \n\tu32 idle_mode;\n\tu32 max_frame_size;        \n\n\tunsigned int rbuf_fill_level;\n\tunsigned int rx_pio;\n\tunsigned int if_mode;\n\tunsigned int base_clock;\n\tunsigned int xsync;\n\tunsigned int xctrl;\n\n\t \n\n\tbool rx_enabled;\n\tbool rx_restart;\n\n\tbool tx_enabled;\n\tbool tx_active;\n\n\tunsigned char signals;     \n\tint init_error;   \n\n\tunsigned char *tx_buf;\n\tint tx_count;\n\n\tbool drop_rts_on_tx_done;\n\tstruct\t_input_signal_events\tinput_signal_events;\n\n\tint dcd_chkcount;\t \n\tint cts_chkcount;\t \n\tint dsr_chkcount;\t \n\tint ri_chkcount;\n\n\tchar *bufs;\t\t \n\tdma_addr_t bufs_dma_addr;  \n\n\tunsigned int rbuf_count;\n\tstruct slgt_desc *rbufs;\n\tunsigned int rbuf_current;\n\tunsigned int rbuf_index;\n\tunsigned int rbuf_fill_index;\n\tunsigned short rbuf_fill_count;\n\n\tunsigned int tbuf_count;\n\tstruct slgt_desc *tbufs;\n\tunsigned int tbuf_current;\n\tunsigned int tbuf_start;\n\n\tunsigned char *tmp_rbuf;\n\tunsigned int tmp_rbuf_count;\n\n\t \n\n\tint netcount;\n\tspinlock_t netlock;\n#if SYNCLINK_GENERIC_HDLC\n\tstruct net_device *netdev;\n#endif\n\n};\n\nstatic const MGSL_PARAMS default_params = {\n\t.mode            = MGSL_MODE_HDLC,\n\t.loopback        = 0,\n\t.flags           = HDLC_FLAG_UNDERRUN_ABORT15,\n\t.encoding        = HDLC_ENCODING_NRZI_SPACE,\n\t.clock_speed     = 0,\n\t.addr_filter     = 0xff,\n\t.crc_type        = HDLC_CRC_16_CCITT,\n\t.preamble_length = HDLC_PREAMBLE_LENGTH_8BITS,\n\t.preamble        = HDLC_PREAMBLE_PATTERN_NONE,\n\t.data_rate       = 9600,\n\t.data_bits       = 8,\n\t.stop_bits       = 1,\n\t.parity          = ASYNC_PARITY_NONE\n};\n\n\n#define BH_RECEIVE  1\n#define BH_TRANSMIT 2\n#define BH_STATUS   4\n#define IO_PIN_SHUTDOWN_LIMIT 100\n\n#define DMABUFSIZE 256\n#define DESC_LIST_SIZE 4096\n\n#define MASK_PARITY  BIT1\n#define MASK_FRAMING BIT0\n#define MASK_BREAK   BIT14\n#define MASK_OVERRUN BIT4\n\n#define GSR   0x00  \n#define JCR   0x04  \n#define IODR  0x08  \n#define IOER  0x0c  \n#define IOVR  0x10  \n#define IOSR  0x14  \n#define TDR   0x80  \n#define RDR   0x80  \n#define TCR   0x82  \n#define TIR   0x84  \n#define TPR   0x85  \n#define RCR   0x86  \n#define VCR   0x88  \n#define CCR   0x89  \n#define BDR   0x8a  \n#define SCR   0x8c  \n#define SSR   0x8e  \n#define RDCSR 0x90  \n#define TDCSR 0x94  \n#define RDDAR 0x98  \n#define TDDAR 0x9c  \n#define XSR   0x40  \n#define XCR   0x44  \n\n#define RXIDLE      BIT14\n#define RXBREAK     BIT14\n#define IRQ_TXDATA  BIT13\n#define IRQ_TXIDLE  BIT12\n#define IRQ_TXUNDER BIT11  \n#define IRQ_RXDATA  BIT10\n#define IRQ_RXIDLE  BIT9   \n#define IRQ_RXBREAK BIT9   \n#define IRQ_RXOVER  BIT8\n#define IRQ_DSR     BIT7\n#define IRQ_CTS     BIT6\n#define IRQ_DCD     BIT5\n#define IRQ_RI      BIT4\n#define IRQ_ALL     0x3ff0\n#define IRQ_MASTER  BIT0\n\n#define slgt_irq_on(info, mask) \\\n\twr_reg16((info), SCR, (unsigned short)(rd_reg16((info), SCR) | (mask)))\n#define slgt_irq_off(info, mask) \\\n\twr_reg16((info), SCR, (unsigned short)(rd_reg16((info), SCR) & ~(mask)))\n\nstatic __u8  rd_reg8(struct slgt_info *info, unsigned int addr);\nstatic void  wr_reg8(struct slgt_info *info, unsigned int addr, __u8 value);\nstatic __u16 rd_reg16(struct slgt_info *info, unsigned int addr);\nstatic void  wr_reg16(struct slgt_info *info, unsigned int addr, __u16 value);\nstatic __u32 rd_reg32(struct slgt_info *info, unsigned int addr);\nstatic void  wr_reg32(struct slgt_info *info, unsigned int addr, __u32 value);\n\nstatic void  msc_set_vcr(struct slgt_info *info);\n\nstatic int  startup(struct slgt_info *info);\nstatic int  block_til_ready(struct tty_struct *tty, struct file * filp,struct slgt_info *info);\nstatic void shutdown(struct slgt_info *info);\nstatic void program_hw(struct slgt_info *info);\nstatic void change_params(struct slgt_info *info);\n\nstatic int  adapter_test(struct slgt_info *info);\n\nstatic void reset_port(struct slgt_info *info);\nstatic void async_mode(struct slgt_info *info);\nstatic void sync_mode(struct slgt_info *info);\n\nstatic void rx_stop(struct slgt_info *info);\nstatic void rx_start(struct slgt_info *info);\nstatic void reset_rbufs(struct slgt_info *info);\nstatic void free_rbufs(struct slgt_info *info, unsigned int first, unsigned int last);\nstatic bool rx_get_frame(struct slgt_info *info);\nstatic bool rx_get_buf(struct slgt_info *info);\n\nstatic void tx_start(struct slgt_info *info);\nstatic void tx_stop(struct slgt_info *info);\nstatic void tx_set_idle(struct slgt_info *info);\nstatic unsigned int tbuf_bytes(struct slgt_info *info);\nstatic void reset_tbufs(struct slgt_info *info);\nstatic void tdma_reset(struct slgt_info *info);\nstatic bool tx_load(struct slgt_info *info, const u8 *buf, unsigned int count);\n\nstatic void get_gtsignals(struct slgt_info *info);\nstatic void set_gtsignals(struct slgt_info *info);\nstatic void set_rate(struct slgt_info *info, u32 data_rate);\n\nstatic void bh_transmit(struct slgt_info *info);\nstatic void isr_txeom(struct slgt_info *info, unsigned short status);\n\nstatic void tx_timeout(struct timer_list *t);\nstatic void rx_timeout(struct timer_list *t);\n\n \nstatic int  get_stats(struct slgt_info *info, struct mgsl_icount __user *user_icount);\nstatic int  get_params(struct slgt_info *info, MGSL_PARAMS __user *params);\nstatic int  set_params(struct slgt_info *info, MGSL_PARAMS __user *params);\nstatic int  get_txidle(struct slgt_info *info, int __user *idle_mode);\nstatic int  set_txidle(struct slgt_info *info, int idle_mode);\nstatic int  tx_enable(struct slgt_info *info, int enable);\nstatic int  tx_abort(struct slgt_info *info);\nstatic int  rx_enable(struct slgt_info *info, int enable);\nstatic int  modem_input_wait(struct slgt_info *info,int arg);\nstatic int  wait_mgsl_event(struct slgt_info *info, int __user *mask_ptr);\nstatic int  get_interface(struct slgt_info *info, int __user *if_mode);\nstatic int  set_interface(struct slgt_info *info, int if_mode);\nstatic int  set_gpio(struct slgt_info *info, struct gpio_desc __user *gpio);\nstatic int  get_gpio(struct slgt_info *info, struct gpio_desc __user *gpio);\nstatic int  wait_gpio(struct slgt_info *info, struct gpio_desc __user *gpio);\nstatic int  get_xsync(struct slgt_info *info, int __user *if_mode);\nstatic int  set_xsync(struct slgt_info *info, int if_mode);\nstatic int  get_xctrl(struct slgt_info *info, int __user *if_mode);\nstatic int  set_xctrl(struct slgt_info *info, int if_mode);\n\n \nstatic void release_resources(struct slgt_info *info);\n\n \n#ifndef DBGINFO\n#define DBGINFO(fmt)\n#endif\n#ifndef DBGERR\n#define DBGERR(fmt)\n#endif\n#ifndef DBGBH\n#define DBGBH(fmt)\n#endif\n#ifndef DBGISR\n#define DBGISR(fmt)\n#endif\n\n#ifdef DBGDATA\nstatic void trace_block(struct slgt_info *info, const char *data, int count, const char *label)\n{\n\tint i;\n\tint linecount;\n\tprintk(\"%s %s data:\\n\",info->device_name, label);\n\twhile(count) {\n\t\tlinecount = (count > 16) ? 16 : count;\n\t\tfor(i=0; i < linecount; i++)\n\t\t\tprintk(\"%02X \",(unsigned char)data[i]);\n\t\tfor(;i<17;i++)\n\t\t\tprintk(\"   \");\n\t\tfor(i=0;i<linecount;i++) {\n\t\t\tif (data[i]>=040 && data[i]<=0176)\n\t\t\t\tprintk(\"%c\",data[i]);\n\t\t\telse\n\t\t\t\tprintk(\".\");\n\t\t}\n\t\tprintk(\"\\n\");\n\t\tdata  += linecount;\n\t\tcount -= linecount;\n\t}\n}\n#else\n#define DBGDATA(info, buf, size, label)\n#endif\n\n#ifdef DBGTBUF\nstatic void dump_tbufs(struct slgt_info *info)\n{\n\tint i;\n\tprintk(\"tbuf_current=%d\\n\", info->tbuf_current);\n\tfor (i=0 ; i < info->tbuf_count ; i++) {\n\t\tprintk(\"%d: count=%04X status=%04X\\n\",\n\t\t\ti, le16_to_cpu(info->tbufs[i].count), le16_to_cpu(info->tbufs[i].status));\n\t}\n}\n#else\n#define DBGTBUF(info)\n#endif\n\n#ifdef DBGRBUF\nstatic void dump_rbufs(struct slgt_info *info)\n{\n\tint i;\n\tprintk(\"rbuf_current=%d\\n\", info->rbuf_current);\n\tfor (i=0 ; i < info->rbuf_count ; i++) {\n\t\tprintk(\"%d: count=%04X status=%04X\\n\",\n\t\t\ti, le16_to_cpu(info->rbufs[i].count), le16_to_cpu(info->rbufs[i].status));\n\t}\n}\n#else\n#define DBGRBUF(info)\n#endif\n\nstatic inline int sanity_check(struct slgt_info *info, char *devname, const char *name)\n{\n#ifdef SANITY_CHECK\n\tif (!info) {\n\t\tprintk(\"null struct slgt_info for (%s) in %s\\n\", devname, name);\n\t\treturn 1;\n\t}\n#else\n\tif (!info)\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\n \nstatic void ldisc_receive_buf(struct tty_struct *tty,\n\t\t\t      const __u8 *data, char *flags, int count)\n{\n\tstruct tty_ldisc *ld;\n\tif (!tty)\n\t\treturn;\n\tld = tty_ldisc_ref(tty);\n\tif (ld) {\n\t\tif (ld->ops->receive_buf)\n\t\t\tld->ops->receive_buf(tty, data, flags, count);\n\t\ttty_ldisc_deref(ld);\n\t}\n}\n\n \n\nstatic int open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct slgt_info *info;\n\tint retval, line;\n\tunsigned long flags;\n\n\tline = tty->index;\n\tif (line >= slgt_device_count) {\n\t\tDBGERR((\"%s: open with invalid line #%d.\\n\", driver_name, line));\n\t\treturn -ENODEV;\n\t}\n\n\tinfo = slgt_device_list;\n\twhile(info && info->line != line)\n\t\tinfo = info->next_device;\n\tif (sanity_check(info, tty->name, \"open\"))\n\t\treturn -ENODEV;\n\tif (info->init_error) {\n\t\tDBGERR((\"%s init error=%d\\n\", info->device_name, info->init_error));\n\t\treturn -ENODEV;\n\t}\n\n\ttty->driver_data = info;\n\tinfo->port.tty = tty;\n\n\tDBGINFO((\"%s open, old ref count = %d\\n\", info->device_name, info->port.count));\n\n\tmutex_lock(&info->port.mutex);\n\n\tspin_lock_irqsave(&info->netlock, flags);\n\tif (info->netcount) {\n\t\tretval = -EBUSY;\n\t\tspin_unlock_irqrestore(&info->netlock, flags);\n\t\tmutex_unlock(&info->port.mutex);\n\t\tgoto cleanup;\n\t}\n\tinfo->port.count++;\n\tspin_unlock_irqrestore(&info->netlock, flags);\n\n\tif (info->port.count == 1) {\n\t\t \n\t\tretval = startup(info);\n\t\tif (retval < 0) {\n\t\t\tmutex_unlock(&info->port.mutex);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&info->port.mutex);\n\tretval = block_til_ready(tty, filp, info);\n\tif (retval) {\n\t\tDBGINFO((\"%s block_til_ready rc=%d\\n\", info->device_name, retval));\n\t\tgoto cleanup;\n\t}\n\n\tretval = 0;\n\ncleanup:\n\tif (retval) {\n\t\tif (tty->count == 1)\n\t\t\tinfo->port.tty = NULL;  \n\t\tif(info->port.count)\n\t\t\tinfo->port.count--;\n\t}\n\n\tDBGINFO((\"%s open rc=%d\\n\", info->device_name, retval));\n\treturn retval;\n}\n\nstatic void close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\n\tif (sanity_check(info, tty->name, \"close\"))\n\t\treturn;\n\tDBGINFO((\"%s close entry, count=%d\\n\", info->device_name, info->port.count));\n\n\tif (tty_port_close_start(&info->port, tty, filp) == 0)\n\t\tgoto cleanup;\n\n\tmutex_lock(&info->port.mutex);\n\tif (tty_port_initialized(&info->port))\n \t\twait_until_sent(tty, info->timeout);\n\tflush_buffer(tty);\n\ttty_ldisc_flush(tty);\n\n\tshutdown(info);\n\tmutex_unlock(&info->port.mutex);\n\n\ttty_port_close_end(&info->port, tty);\n\tinfo->port.tty = NULL;\ncleanup:\n\tDBGINFO((\"%s close exit, count=%d\\n\", tty->driver->name, info->port.count));\n}\n\nstatic void hangup(struct tty_struct *tty)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (sanity_check(info, tty->name, \"hangup\"))\n\t\treturn;\n\tDBGINFO((\"%s hangup\\n\", info->device_name));\n\n\tflush_buffer(tty);\n\n\tmutex_lock(&info->port.mutex);\n\tshutdown(info);\n\n\tspin_lock_irqsave(&info->port.lock, flags);\n\tinfo->port.count = 0;\n\tinfo->port.tty = NULL;\n\tspin_unlock_irqrestore(&info->port.lock, flags);\n\ttty_port_set_active(&info->port, false);\n\tmutex_unlock(&info->port.mutex);\n\n\twake_up_interruptible(&info->port.open_wait);\n}\n\nstatic void set_termios(struct tty_struct *tty,\n\t\t\tconst struct ktermios *old_termios)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long flags;\n\n\tDBGINFO((\"%s set_termios\\n\", tty->driver->name));\n\n\tchange_params(info);\n\n\t \n\tif ((old_termios->c_cflag & CBAUD) && !C_BAUD(tty)) {\n\t\tinfo->signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\n\t\tspin_lock_irqsave(&info->lock,flags);\n\t\tset_gtsignals(info);\n\t\tspin_unlock_irqrestore(&info->lock,flags);\n\t}\n\n\t \n\tif (!(old_termios->c_cflag & CBAUD) && C_BAUD(tty)) {\n\t\tinfo->signals |= SerialSignal_DTR;\n\t\tif (!C_CRTSCTS(tty) || !tty_throttled(tty))\n\t\t\tinfo->signals |= SerialSignal_RTS;\n\t\tspin_lock_irqsave(&info->lock,flags);\n\t \tset_gtsignals(info);\n\t\tspin_unlock_irqrestore(&info->lock,flags);\n\t}\n\n\t \n\tif ((old_termios->c_cflag & CRTSCTS) && !C_CRTSCTS(tty)) {\n\t\ttty->hw_stopped = false;\n\t\ttx_release(tty);\n\t}\n}\n\nstatic void update_tx_timer(struct slgt_info *info)\n{\n\t \n\tif (info->params.mode == MGSL_MODE_HDLC) {\n\t\tint timeout  = (tbuf_bytes(info) * 7) + 1000;\n\t\tmod_timer(&info->tx_timer, jiffies + msecs_to_jiffies(timeout));\n\t}\n}\n\nstatic ssize_t write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tint ret = 0;\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (sanity_check(info, tty->name, \"write\"))\n\t\treturn -EIO;\n\n\tDBGINFO((\"%s write count=%zu\\n\", info->device_name, count));\n\n\tif (!info->tx_buf || (count > info->max_frame_size))\n\t\treturn -EIO;\n\n\tif (!count || tty->flow.stopped || tty->hw_stopped)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\n\tif (info->tx_count) {\n\t\t \n\t\tif (!tx_load(info, info->tx_buf, info->tx_count))\n\t\t\tgoto cleanup;\n\t\tinfo->tx_count = 0;\n\t}\n\n\tif (tx_load(info, buf, count))\n\t\tret = count;\n\ncleanup:\n\tspin_unlock_irqrestore(&info->lock, flags);\n\tDBGINFO((\"%s write rc=%d\\n\", info->device_name, ret));\n\treturn ret;\n}\n\nstatic int put_char(struct tty_struct *tty, u8 ch)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (sanity_check(info, tty->name, \"put_char\"))\n\t\treturn 0;\n\tDBGINFO((\"%s put_char(%u)\\n\", info->device_name, ch));\n\tif (!info->tx_buf)\n\t\treturn 0;\n\tspin_lock_irqsave(&info->lock,flags);\n\tif (info->tx_count < info->max_frame_size) {\n\t\tinfo->tx_buf[info->tx_count++] = ch;\n\t\tret = 1;\n\t}\n\tspin_unlock_irqrestore(&info->lock,flags);\n\treturn ret;\n}\n\nstatic void send_xchar(struct tty_struct *tty, char ch)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (sanity_check(info, tty->name, \"send_xchar\"))\n\t\treturn;\n\tDBGINFO((\"%s send_xchar(%d)\\n\", info->device_name, ch));\n\tinfo->x_char = ch;\n\tif (ch) {\n\t\tspin_lock_irqsave(&info->lock,flags);\n\t\tif (!info->tx_enabled)\n\t\t \ttx_start(info);\n\t\tspin_unlock_irqrestore(&info->lock,flags);\n\t}\n}\n\nstatic void wait_until_sent(struct tty_struct *tty, int timeout)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long orig_jiffies, char_time;\n\n\tif (!info )\n\t\treturn;\n\tif (sanity_check(info, tty->name, \"wait_until_sent\"))\n\t\treturn;\n\tDBGINFO((\"%s wait_until_sent entry\\n\", info->device_name));\n\tif (!tty_port_initialized(&info->port))\n\t\tgoto exit;\n\n\torig_jiffies = jiffies;\n\n\t \n\n\tif (info->params.data_rate) {\n\t       \tchar_time = info->timeout/(32 * 5);\n\t\tif (!char_time)\n\t\t\tchar_time++;\n\t} else\n\t\tchar_time = 1;\n\n\tif (timeout)\n\t\tchar_time = min_t(unsigned long, char_time, timeout);\n\n\twhile (info->tx_active) {\n\t\tmsleep_interruptible(jiffies_to_msecs(char_time));\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tif (timeout && time_after(jiffies, orig_jiffies + timeout))\n\t\t\tbreak;\n\t}\nexit:\n\tDBGINFO((\"%s wait_until_sent exit\\n\", info->device_name));\n}\n\nstatic unsigned int write_room(struct tty_struct *tty)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned int ret;\n\n\tif (sanity_check(info, tty->name, \"write_room\"))\n\t\treturn 0;\n\tret = (info->tx_active) ? 0 : HDLC_MAX_FRAME_SIZE;\n\tDBGINFO((\"%s write_room=%u\\n\", info->device_name, ret));\n\treturn ret;\n}\n\nstatic void flush_chars(struct tty_struct *tty)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (sanity_check(info, tty->name, \"flush_chars\"))\n\t\treturn;\n\tDBGINFO((\"%s flush_chars entry tx_count=%d\\n\", info->device_name, info->tx_count));\n\n\tif (info->tx_count <= 0 || tty->flow.stopped ||\n\t    tty->hw_stopped || !info->tx_buf)\n\t\treturn;\n\n\tDBGINFO((\"%s flush_chars start transmit\\n\", info->device_name));\n\n\tspin_lock_irqsave(&info->lock,flags);\n\tif (info->tx_count && tx_load(info, info->tx_buf, info->tx_count))\n\t\tinfo->tx_count = 0;\n\tspin_unlock_irqrestore(&info->lock,flags);\n}\n\nstatic void flush_buffer(struct tty_struct *tty)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (sanity_check(info, tty->name, \"flush_buffer\"))\n\t\treturn;\n\tDBGINFO((\"%s flush_buffer\\n\", info->device_name));\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tinfo->tx_count = 0;\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\ttty_wakeup(tty);\n}\n\n \nstatic void tx_hold(struct tty_struct *tty)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (sanity_check(info, tty->name, \"tx_hold\"))\n\t\treturn;\n\tDBGINFO((\"%s tx_hold\\n\", info->device_name));\n\tspin_lock_irqsave(&info->lock,flags);\n\tif (info->tx_enabled && info->params.mode == MGSL_MODE_ASYNC)\n\t \ttx_stop(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n}\n\n \nstatic void tx_release(struct tty_struct *tty)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (sanity_check(info, tty->name, \"tx_release\"))\n\t\treturn;\n\tDBGINFO((\"%s tx_release\\n\", info->device_name));\n\tspin_lock_irqsave(&info->lock, flags);\n\tif (info->tx_count && tx_load(info, info->tx_buf, info->tx_count))\n\t\tinfo->tx_count = 0;\n\tspin_unlock_irqrestore(&info->lock, flags);\n}\n\n \nstatic int ioctl(struct tty_struct *tty,\n\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint ret;\n\n\tif (sanity_check(info, tty->name, \"ioctl\"))\n\t\treturn -ENODEV;\n\tDBGINFO((\"%s ioctl() cmd=%08X\\n\", info->device_name, cmd));\n\n\tif (cmd != TIOCMIWAIT) {\n\t\tif (tty_io_error(tty))\n\t\t    return -EIO;\n\t}\n\n\tswitch (cmd) {\n\tcase MGSL_IOCWAITEVENT:\n\t\treturn wait_mgsl_event(info, argp);\n\tcase TIOCMIWAIT:\n\t\treturn modem_input_wait(info,(int)arg);\n\tcase MGSL_IOCSGPIO:\n\t\treturn set_gpio(info, argp);\n\tcase MGSL_IOCGGPIO:\n\t\treturn get_gpio(info, argp);\n\tcase MGSL_IOCWAITGPIO:\n\t\treturn wait_gpio(info, argp);\n\tcase MGSL_IOCGXSYNC:\n\t\treturn get_xsync(info, argp);\n\tcase MGSL_IOCSXSYNC:\n\t\treturn set_xsync(info, (int)arg);\n\tcase MGSL_IOCGXCTRL:\n\t\treturn get_xctrl(info, argp);\n\tcase MGSL_IOCSXCTRL:\n\t\treturn set_xctrl(info, (int)arg);\n\t}\n\tmutex_lock(&info->port.mutex);\n\tswitch (cmd) {\n\tcase MGSL_IOCGPARAMS:\n\t\tret = get_params(info, argp);\n\t\tbreak;\n\tcase MGSL_IOCSPARAMS:\n\t\tret = set_params(info, argp);\n\t\tbreak;\n\tcase MGSL_IOCGTXIDLE:\n\t\tret = get_txidle(info, argp);\n\t\tbreak;\n\tcase MGSL_IOCSTXIDLE:\n\t\tret = set_txidle(info, (int)arg);\n\t\tbreak;\n\tcase MGSL_IOCTXENABLE:\n\t\tret = tx_enable(info, (int)arg);\n\t\tbreak;\n\tcase MGSL_IOCRXENABLE:\n\t\tret = rx_enable(info, (int)arg);\n\t\tbreak;\n\tcase MGSL_IOCTXABORT:\n\t\tret = tx_abort(info);\n\t\tbreak;\n\tcase MGSL_IOCGSTATS:\n\t\tret = get_stats(info, argp);\n\t\tbreak;\n\tcase MGSL_IOCGIF:\n\t\tret = get_interface(info, argp);\n\t\tbreak;\n\tcase MGSL_IOCSIF:\n\t\tret = set_interface(info,(int)arg);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\tmutex_unlock(&info->port.mutex);\n\treturn ret;\n}\n\nstatic int get_icount(struct tty_struct *tty,\n\t\t\t\tstruct serial_icounter_struct *icount)\n\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tstruct mgsl_icount cnow;\t \n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->lock,flags);\n\tcnow = info->icount;\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n\ticount->cts = cnow.cts;\n\ticount->dsr = cnow.dsr;\n\ticount->rng = cnow.rng;\n\ticount->dcd = cnow.dcd;\n\ticount->rx = cnow.rx;\n\ticount->tx = cnow.tx;\n\ticount->frame = cnow.frame;\n\ticount->overrun = cnow.overrun;\n\ticount->parity = cnow.parity;\n\ticount->brk = cnow.brk;\n\ticount->buf_overrun = cnow.buf_overrun;\n\n\treturn 0;\n}\n\n \n#ifdef CONFIG_COMPAT\nstatic long get_params32(struct slgt_info *info, struct MGSL_PARAMS32 __user *user_params)\n{\n\tstruct MGSL_PARAMS32 tmp_params;\n\n\tDBGINFO((\"%s get_params32\\n\", info->device_name));\n\tmemset(&tmp_params, 0, sizeof(tmp_params));\n\ttmp_params.mode            = (compat_ulong_t)info->params.mode;\n\ttmp_params.loopback        = info->params.loopback;\n\ttmp_params.flags           = info->params.flags;\n\ttmp_params.encoding        = info->params.encoding;\n\ttmp_params.clock_speed     = (compat_ulong_t)info->params.clock_speed;\n\ttmp_params.addr_filter     = info->params.addr_filter;\n\ttmp_params.crc_type        = info->params.crc_type;\n\ttmp_params.preamble_length = info->params.preamble_length;\n\ttmp_params.preamble        = info->params.preamble;\n\ttmp_params.data_rate       = (compat_ulong_t)info->params.data_rate;\n\ttmp_params.data_bits       = info->params.data_bits;\n\ttmp_params.stop_bits       = info->params.stop_bits;\n\ttmp_params.parity          = info->params.parity;\n\tif (copy_to_user(user_params, &tmp_params, sizeof(struct MGSL_PARAMS32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic long set_params32(struct slgt_info *info, struct MGSL_PARAMS32 __user *new_params)\n{\n\tstruct MGSL_PARAMS32 tmp_params;\n\tunsigned long flags;\n\n\tDBGINFO((\"%s set_params32\\n\", info->device_name));\n\tif (copy_from_user(&tmp_params, new_params, sizeof(struct MGSL_PARAMS32)))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tif (tmp_params.mode == MGSL_MODE_BASE_CLOCK) {\n\t\tinfo->base_clock = tmp_params.clock_speed;\n\t} else {\n\t\tinfo->params.mode            = tmp_params.mode;\n\t\tinfo->params.loopback        = tmp_params.loopback;\n\t\tinfo->params.flags           = tmp_params.flags;\n\t\tinfo->params.encoding        = tmp_params.encoding;\n\t\tinfo->params.clock_speed     = tmp_params.clock_speed;\n\t\tinfo->params.addr_filter     = tmp_params.addr_filter;\n\t\tinfo->params.crc_type        = tmp_params.crc_type;\n\t\tinfo->params.preamble_length = tmp_params.preamble_length;\n\t\tinfo->params.preamble        = tmp_params.preamble;\n\t\tinfo->params.data_rate       = tmp_params.data_rate;\n\t\tinfo->params.data_bits       = tmp_params.data_bits;\n\t\tinfo->params.stop_bits       = tmp_params.stop_bits;\n\t\tinfo->params.parity          = tmp_params.parity;\n\t}\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\tprogram_hw(info);\n\n\treturn 0;\n}\n\nstatic long slgt_compat_ioctl(struct tty_struct *tty,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tint rc;\n\n\tif (sanity_check(info, tty->name, \"compat_ioctl\"))\n\t\treturn -ENODEV;\n\tDBGINFO((\"%s compat_ioctl() cmd=%08X\\n\", info->device_name, cmd));\n\n\tswitch (cmd) {\n\tcase MGSL_IOCSPARAMS32:\n\t\trc = set_params32(info, compat_ptr(arg));\n\t\tbreak;\n\n\tcase MGSL_IOCGPARAMS32:\n\t\trc = get_params32(info, compat_ptr(arg));\n\t\tbreak;\n\n\tcase MGSL_IOCGPARAMS:\n\tcase MGSL_IOCSPARAMS:\n\tcase MGSL_IOCGTXIDLE:\n\tcase MGSL_IOCGSTATS:\n\tcase MGSL_IOCWAITEVENT:\n\tcase MGSL_IOCGIF:\n\tcase MGSL_IOCSGPIO:\n\tcase MGSL_IOCGGPIO:\n\tcase MGSL_IOCWAITGPIO:\n\tcase MGSL_IOCGXSYNC:\n\tcase MGSL_IOCGXCTRL:\n\t\trc = ioctl(tty, cmd, (unsigned long)compat_ptr(arg));\n\t\tbreak;\n\tdefault:\n\t\trc = ioctl(tty, cmd, arg);\n\t}\n\tDBGINFO((\"%s compat_ioctl() cmd=%08X rc=%d\\n\", info->device_name, cmd, rc));\n\treturn rc;\n}\n#else\n#define slgt_compat_ioctl NULL\n#endif  \n\n \nstatic inline void line_info(struct seq_file *m, struct slgt_info *info)\n{\n\tchar stat_buf[30];\n\tunsigned long flags;\n\n\tseq_printf(m, \"%s: IO=%08X IRQ=%d MaxFrameSize=%u\\n\",\n\t\t      info->device_name, info->phys_reg_addr,\n\t\t      info->irq_level, info->max_frame_size);\n\n\t \n\tspin_lock_irqsave(&info->lock,flags);\n\tget_gtsignals(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n\tstat_buf[0] = 0;\n\tstat_buf[1] = 0;\n\tif (info->signals & SerialSignal_RTS)\n\t\tstrcat(stat_buf, \"|RTS\");\n\tif (info->signals & SerialSignal_CTS)\n\t\tstrcat(stat_buf, \"|CTS\");\n\tif (info->signals & SerialSignal_DTR)\n\t\tstrcat(stat_buf, \"|DTR\");\n\tif (info->signals & SerialSignal_DSR)\n\t\tstrcat(stat_buf, \"|DSR\");\n\tif (info->signals & SerialSignal_DCD)\n\t\tstrcat(stat_buf, \"|CD\");\n\tif (info->signals & SerialSignal_RI)\n\t\tstrcat(stat_buf, \"|RI\");\n\n\tif (info->params.mode != MGSL_MODE_ASYNC) {\n\t\tseq_printf(m, \"\\tHDLC txok:%d rxok:%d\",\n\t\t\t       info->icount.txok, info->icount.rxok);\n\t\tif (info->icount.txunder)\n\t\t\tseq_printf(m, \" txunder:%d\", info->icount.txunder);\n\t\tif (info->icount.txabort)\n\t\t\tseq_printf(m, \" txabort:%d\", info->icount.txabort);\n\t\tif (info->icount.rxshort)\n\t\t\tseq_printf(m, \" rxshort:%d\", info->icount.rxshort);\n\t\tif (info->icount.rxlong)\n\t\t\tseq_printf(m, \" rxlong:%d\", info->icount.rxlong);\n\t\tif (info->icount.rxover)\n\t\t\tseq_printf(m, \" rxover:%d\", info->icount.rxover);\n\t\tif (info->icount.rxcrc)\n\t\t\tseq_printf(m, \" rxcrc:%d\", info->icount.rxcrc);\n\t} else {\n\t\tseq_printf(m, \"\\tASYNC tx:%d rx:%d\",\n\t\t\t       info->icount.tx, info->icount.rx);\n\t\tif (info->icount.frame)\n\t\t\tseq_printf(m, \" fe:%d\", info->icount.frame);\n\t\tif (info->icount.parity)\n\t\t\tseq_printf(m, \" pe:%d\", info->icount.parity);\n\t\tif (info->icount.brk)\n\t\t\tseq_printf(m, \" brk:%d\", info->icount.brk);\n\t\tif (info->icount.overrun)\n\t\t\tseq_printf(m, \" oe:%d\", info->icount.overrun);\n\t}\n\n\t \n\tseq_printf(m, \" %s\\n\", stat_buf+1);\n\n\tseq_printf(m, \"\\ttxactive=%d bh_req=%d bh_run=%d pending_bh=%x\\n\",\n\t\t       info->tx_active,info->bh_requested,info->bh_running,\n\t\t       info->pending_bh);\n}\n\n \nstatic int synclink_gt_proc_show(struct seq_file *m, void *v)\n{\n\tstruct slgt_info *info;\n\n\tseq_puts(m, \"synclink_gt driver\\n\");\n\n\tinfo = slgt_device_list;\n\twhile( info ) {\n\t\tline_info(m, info);\n\t\tinfo = info->next_device;\n\t}\n\treturn 0;\n}\n\n \nstatic unsigned int chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned int count;\n\tif (sanity_check(info, tty->name, \"chars_in_buffer\"))\n\t\treturn 0;\n\tcount = tbuf_bytes(info);\n\tDBGINFO((\"%s chars_in_buffer()=%u\\n\", info->device_name, count));\n\treturn count;\n}\n\n \nstatic void throttle(struct tty_struct * tty)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (sanity_check(info, tty->name, \"throttle\"))\n\t\treturn;\n\tDBGINFO((\"%s throttle\\n\", info->device_name));\n\tif (I_IXOFF(tty))\n\t\tsend_xchar(tty, STOP_CHAR(tty));\n\tif (C_CRTSCTS(tty)) {\n\t\tspin_lock_irqsave(&info->lock,flags);\n\t\tinfo->signals &= ~SerialSignal_RTS;\n\t\tset_gtsignals(info);\n\t\tspin_unlock_irqrestore(&info->lock,flags);\n\t}\n}\n\n \nstatic void unthrottle(struct tty_struct * tty)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned long flags;\n\n\tif (sanity_check(info, tty->name, \"unthrottle\"))\n\t\treturn;\n\tDBGINFO((\"%s unthrottle\\n\", info->device_name));\n\tif (I_IXOFF(tty)) {\n\t\tif (info->x_char)\n\t\t\tinfo->x_char = 0;\n\t\telse\n\t\t\tsend_xchar(tty, START_CHAR(tty));\n\t}\n\tif (C_CRTSCTS(tty)) {\n\t\tspin_lock_irqsave(&info->lock,flags);\n\t\tinfo->signals |= SerialSignal_RTS;\n\t\tset_gtsignals(info);\n\t\tspin_unlock_irqrestore(&info->lock,flags);\n\t}\n}\n\n \nstatic int set_break(struct tty_struct *tty, int break_state)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned short value;\n\tunsigned long flags;\n\n\tif (sanity_check(info, tty->name, \"set_break\"))\n\t\treturn -EINVAL;\n\tDBGINFO((\"%s set_break(%d)\\n\", info->device_name, break_state));\n\n\tspin_lock_irqsave(&info->lock,flags);\n\tvalue = rd_reg16(info, TCR);\n \tif (break_state == -1)\n\t\tvalue |= BIT6;\n\telse\n\t\tvalue &= ~BIT6;\n\twr_reg16(info, TCR, value);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\treturn 0;\n}\n\n#if SYNCLINK_GENERIC_HDLC\n\n \nstatic int hdlcdev_attach(struct net_device *dev, unsigned short encoding,\n\t\t\t  unsigned short parity)\n{\n\tstruct slgt_info *info = dev_to_port(dev);\n\tunsigned char  new_encoding;\n\tunsigned short new_crctype;\n\n\t \n\tif (info->port.count)\n\t\treturn -EBUSY;\n\n\tDBGINFO((\"%s hdlcdev_attach\\n\", info->device_name));\n\n\tswitch (encoding)\n\t{\n\tcase ENCODING_NRZ:        new_encoding = HDLC_ENCODING_NRZ; break;\n\tcase ENCODING_NRZI:       new_encoding = HDLC_ENCODING_NRZI_SPACE; break;\n\tcase ENCODING_FM_MARK:    new_encoding = HDLC_ENCODING_BIPHASE_MARK; break;\n\tcase ENCODING_FM_SPACE:   new_encoding = HDLC_ENCODING_BIPHASE_SPACE; break;\n\tcase ENCODING_MANCHESTER: new_encoding = HDLC_ENCODING_BIPHASE_LEVEL; break;\n\tdefault: return -EINVAL;\n\t}\n\n\tswitch (parity)\n\t{\n\tcase PARITY_NONE:            new_crctype = HDLC_CRC_NONE; break;\n\tcase PARITY_CRC16_PR1_CCITT: new_crctype = HDLC_CRC_16_CCITT; break;\n\tcase PARITY_CRC32_PR1_CCITT: new_crctype = HDLC_CRC_32_CCITT; break;\n\tdefault: return -EINVAL;\n\t}\n\n\tinfo->params.encoding = new_encoding;\n\tinfo->params.crc_type = new_crctype;\n\n\t \n\tif (info->netcount)\n\t\tprogram_hw(info);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t hdlcdev_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct slgt_info *info = dev_to_port(dev);\n\tunsigned long flags;\n\n\tDBGINFO((\"%s hdlc_xmit\\n\", dev->name));\n\n\tif (!skb->len)\n\t\treturn NETDEV_TX_OK;\n\n\t \n\tnetif_stop_queue(dev);\n\n\t \n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\t \n\tnetif_trans_update(dev);\n\n\tspin_lock_irqsave(&info->lock, flags);\n\ttx_load(info, skb->data, skb->len);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\t \n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic int hdlcdev_open(struct net_device *dev)\n{\n\tstruct slgt_info *info = dev_to_port(dev);\n\tint rc;\n\tunsigned long flags;\n\n\tDBGINFO((\"%s hdlcdev_open\\n\", dev->name));\n\n\t \n\tspin_lock_irqsave(&info->netlock, flags);\n\tif (info->port.count != 0 || info->netcount != 0) {\n\t\tDBGINFO((\"%s hdlc_open busy\\n\", dev->name));\n\t\tspin_unlock_irqrestore(&info->netlock, flags);\n\t\treturn -EBUSY;\n\t}\n\tinfo->netcount=1;\n\tspin_unlock_irqrestore(&info->netlock, flags);\n\n\t \n\tif ((rc = startup(info)) != 0) {\n\t\tspin_lock_irqsave(&info->netlock, flags);\n\t\tinfo->netcount=0;\n\t\tspin_unlock_irqrestore(&info->netlock, flags);\n\t\treturn rc;\n\t}\n\n\t \n\trc = hdlc_open(dev);\n\tif (rc) {\n\t\tshutdown(info);\n\t\tspin_lock_irqsave(&info->netlock, flags);\n\t\tinfo->netcount = 0;\n\t\tspin_unlock_irqrestore(&info->netlock, flags);\n\t\treturn rc;\n\t}\n\n\t \n\tinfo->signals |= SerialSignal_RTS | SerialSignal_DTR;\n\tprogram_hw(info);\n\n\t \n\tnetif_trans_update(dev);\n\tnetif_start_queue(dev);\n\n\t \n\tspin_lock_irqsave(&info->lock, flags);\n\tget_gtsignals(info);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\tif (info->signals & SerialSignal_DCD)\n\t\tnetif_carrier_on(dev);\n\telse\n\t\tnetif_carrier_off(dev);\n\treturn 0;\n}\n\n \nstatic int hdlcdev_close(struct net_device *dev)\n{\n\tstruct slgt_info *info = dev_to_port(dev);\n\tunsigned long flags;\n\n\tDBGINFO((\"%s hdlcdev_close\\n\", dev->name));\n\n\tnetif_stop_queue(dev);\n\n\t \n\tshutdown(info);\n\n\thdlc_close(dev);\n\n\tspin_lock_irqsave(&info->netlock, flags);\n\tinfo->netcount=0;\n\tspin_unlock_irqrestore(&info->netlock, flags);\n\n\treturn 0;\n}\n\n \nstatic int hdlcdev_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings new_line;\n\tsync_serial_settings __user *line = ifs->ifs_ifsu.sync;\n\tstruct slgt_info *info = dev_to_port(dev);\n\tunsigned int flags;\n\n\tDBGINFO((\"%s hdlcdev_ioctl\\n\", dev->name));\n\n\t \n\tif (info->port.count)\n\t\treturn -EBUSY;\n\n\tmemset(&new_line, 0, sizeof(new_line));\n\n\tswitch (ifs->type) {\n\tcase IF_GET_IFACE:  \n\n\t\tifs->type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifs->size < size) {\n\t\t\tifs->size = size;  \n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tflags = info->params.flags & (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\n\t\t\t\t\t      HDLC_FLAG_RXC_BRG    | HDLC_FLAG_RXC_TXCPIN |\n\t\t\t\t\t      HDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\n\t\t\t\t\t      HDLC_FLAG_TXC_BRG    | HDLC_FLAG_TXC_RXCPIN);\n\n\t\tswitch (flags){\n\t\tcase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN): new_line.clock_type = CLOCK_EXT; break;\n\t\tcase (HDLC_FLAG_RXC_BRG    | HDLC_FLAG_TXC_BRG):    new_line.clock_type = CLOCK_INT; break;\n\t\tcase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG):    new_line.clock_type = CLOCK_TXINT; break;\n\t\tcase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN): new_line.clock_type = CLOCK_TXFROMRX; break;\n\t\tdefault: new_line.clock_type = CLOCK_DEFAULT;\n\t\t}\n\n\t\tnew_line.clock_rate = info->params.clock_speed;\n\t\tnew_line.loopback   = info->params.loopback ? 1:0;\n\n\t\tif (copy_to_user(line, &new_line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_IFACE_SYNC_SERIAL:  \n\n\t\tif(!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&new_line, line, size))\n\t\t\treturn -EFAULT;\n\n\t\tswitch (new_line.clock_type)\n\t\t{\n\t\tcase CLOCK_EXT:      flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN; break;\n\t\tcase CLOCK_TXFROMRX: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN; break;\n\t\tcase CLOCK_INT:      flags = HDLC_FLAG_RXC_BRG    | HDLC_FLAG_TXC_BRG;    break;\n\t\tcase CLOCK_TXINT:    flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG;    break;\n\t\tcase CLOCK_DEFAULT:  flags = info->params.flags &\n\t\t\t\t\t     (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\n\t\t\t\t\t      HDLC_FLAG_RXC_BRG    | HDLC_FLAG_RXC_TXCPIN |\n\t\t\t\t\t      HDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\n\t\t\t\t\t      HDLC_FLAG_TXC_BRG    | HDLC_FLAG_TXC_RXCPIN); break;\n\t\tdefault: return -EINVAL;\n\t\t}\n\n\t\tif (new_line.loopback != 0 && new_line.loopback != 1)\n\t\t\treturn -EINVAL;\n\n\t\tinfo->params.flags &= ~(HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\n\t\t\t\t\tHDLC_FLAG_RXC_BRG    | HDLC_FLAG_RXC_TXCPIN |\n\t\t\t\t\tHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\n\t\t\t\t\tHDLC_FLAG_TXC_BRG    | HDLC_FLAG_TXC_RXCPIN);\n\t\tinfo->params.flags |= flags;\n\n\t\tinfo->params.loopback = new_line.loopback;\n\n\t\tif (flags & (HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG))\n\t\t\tinfo->params.clock_speed = new_line.clock_rate;\n\t\telse\n\t\t\tinfo->params.clock_speed = 0;\n\n\t\t \n\t\tif (info->netcount)\n\t\t\tprogram_hw(info);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifs);\n\t}\n}\n\n \nstatic void hdlcdev_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct slgt_info *info = dev_to_port(dev);\n\tunsigned long flags;\n\n\tDBGINFO((\"%s hdlcdev_tx_timeout\\n\", dev->name));\n\n\tdev->stats.tx_errors++;\n\tdev->stats.tx_aborted_errors++;\n\n\tspin_lock_irqsave(&info->lock,flags);\n\ttx_stop(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n\tnetif_wake_queue(dev);\n}\n\n \nstatic void hdlcdev_tx_done(struct slgt_info *info)\n{\n\tif (netif_queue_stopped(info->netdev))\n\t\tnetif_wake_queue(info->netdev);\n}\n\n \nstatic void hdlcdev_rx(struct slgt_info *info, char *buf, int size)\n{\n\tstruct sk_buff *skb = dev_alloc_skb(size);\n\tstruct net_device *dev = info->netdev;\n\n\tDBGINFO((\"%s hdlcdev_rx\\n\", dev->name));\n\n\tif (skb == NULL) {\n\t\tDBGERR((\"%s: can't alloc skb, drop packet\\n\", dev->name));\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\n\tskb_put_data(skb, buf, size);\n\n\tskb->protocol = hdlc_type_trans(skb, dev);\n\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += size;\n\n\tnetif_rx(skb);\n}\n\nstatic const struct net_device_ops hdlcdev_ops = {\n\t.ndo_open       = hdlcdev_open,\n\t.ndo_stop       = hdlcdev_close,\n\t.ndo_start_xmit = hdlc_start_xmit,\n\t.ndo_siocwandev = hdlcdev_ioctl,\n\t.ndo_tx_timeout = hdlcdev_tx_timeout,\n};\n\n \nstatic int hdlcdev_init(struct slgt_info *info)\n{\n\tint rc;\n\tstruct net_device *dev;\n\thdlc_device *hdlc;\n\n\t \n\n\tdev = alloc_hdlcdev(info);\n\tif (!dev) {\n\t\tprintk(KERN_ERR \"%s hdlc device alloc failure\\n\", info->device_name);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdev->mem_start = info->phys_reg_addr;\n\tdev->mem_end   = info->phys_reg_addr + SLGT_REG_SIZE - 1;\n\tdev->irq       = info->irq_level;\n\n\t \n\tdev->netdev_ops\t    = &hdlcdev_ops;\n\tdev->watchdog_timeo = 10 * HZ;\n\tdev->tx_queue_len   = 50;\n\n\t \n\thdlc         = dev_to_hdlc(dev);\n\thdlc->attach = hdlcdev_attach;\n\thdlc->xmit   = hdlcdev_xmit;\n\n\t \n\trc = register_hdlc_device(dev);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s:unable to register hdlc device\\n\",__FILE__);\n\t\tfree_netdev(dev);\n\t\treturn rc;\n\t}\n\n\tinfo->netdev = dev;\n\treturn 0;\n}\n\n \nstatic void hdlcdev_exit(struct slgt_info *info)\n{\n\tif (!info->netdev)\n\t\treturn;\n\tunregister_hdlc_device(info->netdev);\n\tfree_netdev(info->netdev);\n\tinfo->netdev = NULL;\n}\n\n#endif  \n\n \nstatic void rx_async(struct slgt_info *info)\n{\n \tstruct mgsl_icount *icount = &info->icount;\n\tunsigned int start, end;\n\tunsigned char *p;\n\tunsigned char status;\n\tstruct slgt_desc *bufs = info->rbufs;\n\tint i, count;\n\tint chars = 0;\n\tint stat;\n\tunsigned char ch;\n\n\tstart = end = info->rbuf_current;\n\n\twhile(desc_complete(bufs[end])) {\n\t\tcount = desc_count(bufs[end]) - info->rbuf_index;\n\t\tp     = bufs[end].buf + info->rbuf_index;\n\n\t\tDBGISR((\"%s rx_async count=%d\\n\", info->device_name, count));\n\t\tDBGDATA(info, p, count, \"rx\");\n\n\t\tfor(i=0 ; i < count; i+=2, p+=2) {\n\t\t\tch = *p;\n\t\t\ticount->rx++;\n\n\t\t\tstat = 0;\n\n\t\t\tstatus = *(p + 1) & (BIT1 + BIT0);\n\t\t\tif (status) {\n\t\t\t\tif (status & BIT1)\n\t\t\t\t\ticount->parity++;\n\t\t\t\telse if (status & BIT0)\n\t\t\t\t\ticount->frame++;\n\t\t\t\t \n\t\t\t\tif (status & info->ignore_status_mask)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (status & BIT1)\n\t\t\t\t\tstat = TTY_PARITY;\n\t\t\t\telse if (status & BIT0)\n\t\t\t\t\tstat = TTY_FRAME;\n\t\t\t}\n\t\t\ttty_insert_flip_char(&info->port, ch, stat);\n\t\t\tchars++;\n\t\t}\n\n\t\tif (i < count) {\n\t\t\t \n\t\t\tinfo->rbuf_index += i;\n\t\t\tmod_timer(&info->rx_timer, jiffies + 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->rbuf_index = 0;\n\t\tfree_rbufs(info, end, end);\n\n\t\tif (++end == info->rbuf_count)\n\t\t\tend = 0;\n\n\t\t \n\t\tif (end == start)\n\t\t\tbreak;\n\t}\n\n\tif (chars)\n\t\ttty_flip_buffer_push(&info->port);\n}\n\n \nstatic int bh_action(struct slgt_info *info)\n{\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&info->lock,flags);\n\n\tif (info->pending_bh & BH_RECEIVE) {\n\t\tinfo->pending_bh &= ~BH_RECEIVE;\n\t\trc = BH_RECEIVE;\n\t} else if (info->pending_bh & BH_TRANSMIT) {\n\t\tinfo->pending_bh &= ~BH_TRANSMIT;\n\t\trc = BH_TRANSMIT;\n\t} else if (info->pending_bh & BH_STATUS) {\n\t\tinfo->pending_bh &= ~BH_STATUS;\n\t\trc = BH_STATUS;\n\t} else {\n\t\t \n\t\tinfo->bh_running = false;\n\t\tinfo->bh_requested = false;\n\t\trc = 0;\n\t}\n\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n\treturn rc;\n}\n\n \nstatic void bh_handler(struct work_struct *work)\n{\n\tstruct slgt_info *info = container_of(work, struct slgt_info, task);\n\tint action;\n\n\tinfo->bh_running = true;\n\n\twhile((action = bh_action(info))) {\n\t\tswitch (action) {\n\t\tcase BH_RECEIVE:\n\t\t\tDBGBH((\"%s bh receive\\n\", info->device_name));\n\t\t\tswitch(info->params.mode) {\n\t\t\tcase MGSL_MODE_ASYNC:\n\t\t\t\trx_async(info);\n\t\t\t\tbreak;\n\t\t\tcase MGSL_MODE_HDLC:\n\t\t\t\twhile(rx_get_frame(info));\n\t\t\t\tbreak;\n\t\t\tcase MGSL_MODE_RAW:\n\t\t\tcase MGSL_MODE_MONOSYNC:\n\t\t\tcase MGSL_MODE_BISYNC:\n\t\t\tcase MGSL_MODE_XSYNC:\n\t\t\t\twhile(rx_get_buf(info));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (info->rx_restart)\n\t\t\t\trx_start(info);\n\t\t\tbreak;\n\t\tcase BH_TRANSMIT:\n\t\t\tbh_transmit(info);\n\t\t\tbreak;\n\t\tcase BH_STATUS:\n\t\t\tDBGBH((\"%s bh status\\n\", info->device_name));\n\t\t\tinfo->ri_chkcount = 0;\n\t\t\tinfo->dsr_chkcount = 0;\n\t\t\tinfo->dcd_chkcount = 0;\n\t\t\tinfo->cts_chkcount = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBGBH((\"%s unknown action\\n\", info->device_name));\n\t\t\tbreak;\n\t\t}\n\t}\n\tDBGBH((\"%s bh_handler exit\\n\", info->device_name));\n}\n\nstatic void bh_transmit(struct slgt_info *info)\n{\n\tstruct tty_struct *tty = info->port.tty;\n\n\tDBGBH((\"%s bh_transmit\\n\", info->device_name));\n\tif (tty)\n\t\ttty_wakeup(tty);\n}\n\nstatic void dsr_change(struct slgt_info *info, unsigned short status)\n{\n\tif (status & BIT3) {\n\t\tinfo->signals |= SerialSignal_DSR;\n\t\tinfo->input_signal_events.dsr_up++;\n\t} else {\n\t\tinfo->signals &= ~SerialSignal_DSR;\n\t\tinfo->input_signal_events.dsr_down++;\n\t}\n\tDBGISR((\"dsr_change %s signals=%04X\\n\", info->device_name, info->signals));\n\tif ((info->dsr_chkcount)++ == IO_PIN_SHUTDOWN_LIMIT) {\n\t\tslgt_irq_off(info, IRQ_DSR);\n\t\treturn;\n\t}\n\tinfo->icount.dsr++;\n\twake_up_interruptible(&info->status_event_wait_q);\n\twake_up_interruptible(&info->event_wait_q);\n\tinfo->pending_bh |= BH_STATUS;\n}\n\nstatic void cts_change(struct slgt_info *info, unsigned short status)\n{\n\tif (status & BIT2) {\n\t\tinfo->signals |= SerialSignal_CTS;\n\t\tinfo->input_signal_events.cts_up++;\n\t} else {\n\t\tinfo->signals &= ~SerialSignal_CTS;\n\t\tinfo->input_signal_events.cts_down++;\n\t}\n\tDBGISR((\"cts_change %s signals=%04X\\n\", info->device_name, info->signals));\n\tif ((info->cts_chkcount)++ == IO_PIN_SHUTDOWN_LIMIT) {\n\t\tslgt_irq_off(info, IRQ_CTS);\n\t\treturn;\n\t}\n\tinfo->icount.cts++;\n\twake_up_interruptible(&info->status_event_wait_q);\n\twake_up_interruptible(&info->event_wait_q);\n\tinfo->pending_bh |= BH_STATUS;\n\n\tif (tty_port_cts_enabled(&info->port)) {\n\t\tif (info->port.tty) {\n\t\t\tif (info->port.tty->hw_stopped) {\n\t\t\t\tif (info->signals & SerialSignal_CTS) {\n\t\t\t\t\tinfo->port.tty->hw_stopped = false;\n\t\t\t\t\tinfo->pending_bh |= BH_TRANSMIT;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!(info->signals & SerialSignal_CTS))\n\t\t\t\t\tinfo->port.tty->hw_stopped = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void dcd_change(struct slgt_info *info, unsigned short status)\n{\n\tif (status & BIT1) {\n\t\tinfo->signals |= SerialSignal_DCD;\n\t\tinfo->input_signal_events.dcd_up++;\n\t} else {\n\t\tinfo->signals &= ~SerialSignal_DCD;\n\t\tinfo->input_signal_events.dcd_down++;\n\t}\n\tDBGISR((\"dcd_change %s signals=%04X\\n\", info->device_name, info->signals));\n\tif ((info->dcd_chkcount)++ == IO_PIN_SHUTDOWN_LIMIT) {\n\t\tslgt_irq_off(info, IRQ_DCD);\n\t\treturn;\n\t}\n\tinfo->icount.dcd++;\n#if SYNCLINK_GENERIC_HDLC\n\tif (info->netcount) {\n\t\tif (info->signals & SerialSignal_DCD)\n\t\t\tnetif_carrier_on(info->netdev);\n\t\telse\n\t\t\tnetif_carrier_off(info->netdev);\n\t}\n#endif\n\twake_up_interruptible(&info->status_event_wait_q);\n\twake_up_interruptible(&info->event_wait_q);\n\tinfo->pending_bh |= BH_STATUS;\n\n\tif (tty_port_check_carrier(&info->port)) {\n\t\tif (info->signals & SerialSignal_DCD)\n\t\t\twake_up_interruptible(&info->port.open_wait);\n\t\telse {\n\t\t\tif (info->port.tty)\n\t\t\t\ttty_hangup(info->port.tty);\n\t\t}\n\t}\n}\n\nstatic void ri_change(struct slgt_info *info, unsigned short status)\n{\n\tif (status & BIT0) {\n\t\tinfo->signals |= SerialSignal_RI;\n\t\tinfo->input_signal_events.ri_up++;\n\t} else {\n\t\tinfo->signals &= ~SerialSignal_RI;\n\t\tinfo->input_signal_events.ri_down++;\n\t}\n\tDBGISR((\"ri_change %s signals=%04X\\n\", info->device_name, info->signals));\n\tif ((info->ri_chkcount)++ == IO_PIN_SHUTDOWN_LIMIT) {\n\t\tslgt_irq_off(info, IRQ_RI);\n\t\treturn;\n\t}\n\tinfo->icount.rng++;\n\twake_up_interruptible(&info->status_event_wait_q);\n\twake_up_interruptible(&info->event_wait_q);\n\tinfo->pending_bh |= BH_STATUS;\n}\n\nstatic void isr_rxdata(struct slgt_info *info)\n{\n\tunsigned int count = info->rbuf_fill_count;\n\tunsigned int i = info->rbuf_fill_index;\n\tunsigned short reg;\n\n\twhile (rd_reg16(info, SSR) & IRQ_RXDATA) {\n\t\treg = rd_reg16(info, RDR);\n\t\tDBGISR((\"isr_rxdata %s RDR=%04X\\n\", info->device_name, reg));\n\t\tif (desc_complete(info->rbufs[i])) {\n\t\t\t \n\t\t\trx_stop(info);\n\t\t\tinfo->rx_restart = true;\n\t\t\tcontinue;\n\t\t}\n\t\tinfo->rbufs[i].buf[count++] = (unsigned char)reg;\n\t\t \n\t\tif (info->params.mode == MGSL_MODE_ASYNC)\n\t\t\tinfo->rbufs[i].buf[count++] = (unsigned char)(reg >> 8);\n\t\tif (count == info->rbuf_fill_level || (reg & BIT10)) {\n\t\t\t \n\t\t\tset_desc_count(info->rbufs[i], count);\n\t\t\tset_desc_status(info->rbufs[i], BIT15 | (reg >> 8));\n\t\t\tinfo->rbuf_fill_count = count = 0;\n\t\t\tif (++i == info->rbuf_count)\n\t\t\t\ti = 0;\n\t\t\tinfo->pending_bh |= BH_RECEIVE;\n\t\t}\n\t}\n\n\tinfo->rbuf_fill_index = i;\n\tinfo->rbuf_fill_count = count;\n}\n\nstatic void isr_serial(struct slgt_info *info)\n{\n\tunsigned short status = rd_reg16(info, SSR);\n\n\tDBGISR((\"%s isr_serial status=%04X\\n\", info->device_name, status));\n\n\twr_reg16(info, SSR, status);  \n\n\tinfo->irq_occurred = true;\n\n\tif (info->params.mode == MGSL_MODE_ASYNC) {\n\t\tif (status & IRQ_TXIDLE) {\n\t\t\tif (info->tx_active)\n\t\t\t\tisr_txeom(info, status);\n\t\t}\n\t\tif (info->rx_pio && (status & IRQ_RXDATA))\n\t\t\tisr_rxdata(info);\n\t\tif ((status & IRQ_RXBREAK) && (status & RXBREAK)) {\n\t\t\tinfo->icount.brk++;\n\t\t\t \n\t\t\tif (info->port.tty) {\n\t\t\t\tif (!(status & info->ignore_status_mask)) {\n\t\t\t\t\tif (info->read_status_mask & MASK_BREAK) {\n\t\t\t\t\t\ttty_insert_flip_char(&info->port, 0, TTY_BREAK);\n\t\t\t\t\t\tif (info->port.flags & ASYNC_SAK)\n\t\t\t\t\t\t\tdo_SAK(info->port.tty);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (status & (IRQ_TXIDLE + IRQ_TXUNDER))\n\t\t\tisr_txeom(info, status);\n\t\tif (info->rx_pio && (status & IRQ_RXDATA))\n\t\t\tisr_rxdata(info);\n\t\tif (status & IRQ_RXIDLE) {\n\t\t\tif (status & RXIDLE)\n\t\t\t\tinfo->icount.rxidle++;\n\t\t\telse\n\t\t\t\tinfo->icount.exithunt++;\n\t\t\twake_up_interruptible(&info->event_wait_q);\n\t\t}\n\n\t\tif (status & IRQ_RXOVER)\n\t\t\trx_start(info);\n\t}\n\n\tif (status & IRQ_DSR)\n\t\tdsr_change(info, status);\n\tif (status & IRQ_CTS)\n\t\tcts_change(info, status);\n\tif (status & IRQ_DCD)\n\t\tdcd_change(info, status);\n\tif (status & IRQ_RI)\n\t\tri_change(info, status);\n}\n\nstatic void isr_rdma(struct slgt_info *info)\n{\n\tunsigned int status = rd_reg32(info, RDCSR);\n\n\tDBGISR((\"%s isr_rdma status=%08x\\n\", info->device_name, status));\n\n\t \n\twr_reg32(info, RDCSR, status);\t \n\n\tif (status & (BIT5 + BIT4)) {\n\t\tDBGISR((\"%s isr_rdma rx_restart=1\\n\", info->device_name));\n\t\tinfo->rx_restart = true;\n\t}\n\tinfo->pending_bh |= BH_RECEIVE;\n}\n\nstatic void isr_tdma(struct slgt_info *info)\n{\n\tunsigned int status = rd_reg32(info, TDCSR);\n\n\tDBGISR((\"%s isr_tdma status=%08x\\n\", info->device_name, status));\n\n\t \n\twr_reg32(info, TDCSR, status);\t \n\n\tif (status & (BIT5 + BIT4 + BIT3)) {\n\t\t\n\t\t\n\t\tinfo->pending_bh |= BH_TRANSMIT;\n\t}\n}\n\n \nstatic bool unsent_tbufs(struct slgt_info *info)\n{\n\tunsigned int i = info->tbuf_current;\n\tbool rc = false;\n\n\t \n\n\tdo {\n\t\tif (i)\n\t\t\ti--;\n\t\telse\n\t\t\ti = info->tbuf_count - 1;\n\t\tif (!desc_count(info->tbufs[i]))\n\t\t\tbreak;\n\t\tinfo->tbuf_start = i;\n\t\trc = true;\n\t} while (i != info->tbuf_current);\n\n\treturn rc;\n}\n\nstatic void isr_txeom(struct slgt_info *info, unsigned short status)\n{\n\tDBGISR((\"%s txeom status=%04x\\n\", info->device_name, status));\n\n\tslgt_irq_off(info, IRQ_TXDATA + IRQ_TXIDLE + IRQ_TXUNDER);\n\ttdma_reset(info);\n\tif (status & IRQ_TXUNDER) {\n\t\tunsigned short val = rd_reg16(info, TCR);\n\t\twr_reg16(info, TCR, (unsigned short)(val | BIT2));  \n\t\twr_reg16(info, TCR, val);  \n\t}\n\n\tif (info->tx_active) {\n\t\tif (info->params.mode != MGSL_MODE_ASYNC) {\n\t\t\tif (status & IRQ_TXUNDER)\n\t\t\t\tinfo->icount.txunder++;\n\t\t\telse if (status & IRQ_TXIDLE)\n\t\t\t\tinfo->icount.txok++;\n\t\t}\n\n\t\tif (unsent_tbufs(info)) {\n\t\t\ttx_start(info);\n\t\t\tupdate_tx_timer(info);\n\t\t\treturn;\n\t\t}\n\t\tinfo->tx_active = false;\n\n\t\tdel_timer(&info->tx_timer);\n\n\t\tif (info->params.mode != MGSL_MODE_ASYNC && info->drop_rts_on_tx_done) {\n\t\t\tinfo->signals &= ~SerialSignal_RTS;\n\t\t\tinfo->drop_rts_on_tx_done = false;\n\t\t\tset_gtsignals(info);\n\t\t}\n\n#if SYNCLINK_GENERIC_HDLC\n\t\tif (info->netcount)\n\t\t\thdlcdev_tx_done(info);\n\t\telse\n#endif\n\t\t{\n\t\t\tif (info->port.tty && (info->port.tty->flow.stopped || info->port.tty->hw_stopped)) {\n\t\t\t\ttx_stop(info);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tinfo->pending_bh |= BH_TRANSMIT;\n\t\t}\n\t}\n}\n\nstatic void isr_gpio(struct slgt_info *info, unsigned int changed, unsigned int state)\n{\n\tstruct cond_wait *w, *prev;\n\n\t \n\tfor (w = info->gpio_wait_q, prev = NULL ; w != NULL ; w = w->next) {\n\t\tif (w->data & changed) {\n\t\t\tw->data = state;\n\t\t\twake_up_interruptible(&w->q);\n\t\t\tif (prev != NULL)\n\t\t\t\tprev->next = w->next;\n\t\t\telse\n\t\t\t\tinfo->gpio_wait_q = w->next;\n\t\t} else\n\t\t\tprev = w;\n\t}\n}\n\n \nstatic irqreturn_t slgt_interrupt(int dummy, void *dev_id)\n{\n\tstruct slgt_info *info = dev_id;\n\tunsigned int gsr;\n\tunsigned int i;\n\n\tDBGISR((\"slgt_interrupt irq=%d entry\\n\", info->irq_level));\n\n\twhile((gsr = rd_reg32(info, GSR) & 0xffffff00)) {\n\t\tDBGISR((\"%s gsr=%08x\\n\", info->device_name, gsr));\n\t\tinfo->irq_occurred = true;\n\t\tfor(i=0; i < info->port_count ; i++) {\n\t\t\tif (info->port_array[i] == NULL)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&info->port_array[i]->lock);\n\t\t\tif (gsr & (BIT8 << i))\n\t\t\t\tisr_serial(info->port_array[i]);\n\t\t\tif (gsr & (BIT16 << (i*2)))\n\t\t\t\tisr_rdma(info->port_array[i]);\n\t\t\tif (gsr & (BIT17 << (i*2)))\n\t\t\t\tisr_tdma(info->port_array[i]);\n\t\t\tspin_unlock(&info->port_array[i]->lock);\n\t\t}\n\t}\n\n\tif (info->gpio_present) {\n\t\tunsigned int state;\n\t\tunsigned int changed;\n\t\tspin_lock(&info->lock);\n\t\twhile ((changed = rd_reg32(info, IOSR)) != 0) {\n\t\t\tDBGISR((\"%s iosr=%08x\\n\", info->device_name, changed));\n\t\t\t \n\t\t\tstate = rd_reg32(info, IOVR);\n\t\t\t \n\t\t\twr_reg32(info, IOSR, changed);\n\t\t\tfor (i=0 ; i < info->port_count ; i++) {\n\t\t\t\tif (info->port_array[i] != NULL)\n\t\t\t\t\tisr_gpio(info->port_array[i], changed, state);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&info->lock);\n\t}\n\n\tfor(i=0; i < info->port_count ; i++) {\n\t\tstruct slgt_info *port = info->port_array[i];\n\t\tif (port == NULL)\n\t\t\tcontinue;\n\t\tspin_lock(&port->lock);\n\t\tif ((port->port.count || port->netcount) &&\n\t\t    port->pending_bh && !port->bh_running &&\n\t\t    !port->bh_requested) {\n\t\t\tDBGISR((\"%s bh queued\\n\", port->device_name));\n\t\t\tschedule_work(&port->task);\n\t\t\tport->bh_requested = true;\n\t\t}\n\t\tspin_unlock(&port->lock);\n\t}\n\n\tDBGISR((\"slgt_interrupt irq=%d exit\\n\", info->irq_level));\n\treturn IRQ_HANDLED;\n}\n\nstatic int startup(struct slgt_info *info)\n{\n\tDBGINFO((\"%s startup\\n\", info->device_name));\n\n\tif (tty_port_initialized(&info->port))\n\t\treturn 0;\n\n\tif (!info->tx_buf) {\n\t\tinfo->tx_buf = kmalloc(info->max_frame_size, GFP_KERNEL);\n\t\tif (!info->tx_buf) {\n\t\t\tDBGERR((\"%s can't allocate tx buffer\\n\", info->device_name));\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tinfo->pending_bh = 0;\n\n\tmemset(&info->icount, 0, sizeof(info->icount));\n\n\t \n\tchange_params(info);\n\n\tif (info->port.tty)\n\t\tclear_bit(TTY_IO_ERROR, &info->port.tty->flags);\n\n\ttty_port_set_initialized(&info->port, true);\n\n\treturn 0;\n}\n\n \nstatic void shutdown(struct slgt_info *info)\n{\n\tunsigned long flags;\n\n\tif (!tty_port_initialized(&info->port))\n\t\treturn;\n\n\tDBGINFO((\"%s shutdown\\n\", info->device_name));\n\n\t \n\t \n\twake_up_interruptible(&info->status_event_wait_q);\n\twake_up_interruptible(&info->event_wait_q);\n\n\tdel_timer_sync(&info->tx_timer);\n\tdel_timer_sync(&info->rx_timer);\n\n\tkfree(info->tx_buf);\n\tinfo->tx_buf = NULL;\n\n\tspin_lock_irqsave(&info->lock,flags);\n\n\ttx_stop(info);\n\trx_stop(info);\n\n\tslgt_irq_off(info, IRQ_ALL | IRQ_MASTER);\n\n \tif (!info->port.tty || info->port.tty->termios.c_cflag & HUPCL) {\n\t\tinfo->signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\n\t\tset_gtsignals(info);\n\t}\n\n\tflush_cond_wait(&info->gpio_wait_q);\n\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n\tif (info->port.tty)\n\t\tset_bit(TTY_IO_ERROR, &info->port.tty->flags);\n\n\ttty_port_set_initialized(&info->port, false);\n}\n\nstatic void program_hw(struct slgt_info *info)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->lock,flags);\n\n\trx_stop(info);\n\ttx_stop(info);\n\n\tif (info->params.mode != MGSL_MODE_ASYNC ||\n\t    info->netcount)\n\t\tsync_mode(info);\n\telse\n\t\tasync_mode(info);\n\n\tset_gtsignals(info);\n\n\tinfo->dcd_chkcount = 0;\n\tinfo->cts_chkcount = 0;\n\tinfo->ri_chkcount = 0;\n\tinfo->dsr_chkcount = 0;\n\n\tslgt_irq_on(info, IRQ_DCD | IRQ_CTS | IRQ_DSR | IRQ_RI);\n\tget_gtsignals(info);\n\n\tif (info->netcount ||\n\t    (info->port.tty && info->port.tty->termios.c_cflag & CREAD))\n\t\trx_start(info);\n\n\tspin_unlock_irqrestore(&info->lock,flags);\n}\n\n \nstatic void change_params(struct slgt_info *info)\n{\n\tunsigned cflag;\n\tint bits_per_char;\n\n\tif (!info->port.tty)\n\t\treturn;\n\tDBGINFO((\"%s change_params\\n\", info->device_name));\n\n\tcflag = info->port.tty->termios.c_cflag;\n\n\t \n\t \n \tif (cflag & CBAUD)\n\t\tinfo->signals |= SerialSignal_RTS | SerialSignal_DTR;\n\telse\n\t\tinfo->signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\n\n\t \n\n\tinfo->params.data_bits = tty_get_char_size(cflag);\n\tinfo->params.stop_bits = (cflag & CSTOPB) ? 2 : 1;\n\n\tif (cflag & PARENB)\n\t\tinfo->params.parity = (cflag & PARODD) ? ASYNC_PARITY_ODD : ASYNC_PARITY_EVEN;\n\telse\n\t\tinfo->params.parity = ASYNC_PARITY_NONE;\n\n\t \n\tbits_per_char = info->params.data_bits +\n\t\t\tinfo->params.stop_bits + 1;\n\n\tinfo->params.data_rate = tty_get_baud_rate(info->port.tty);\n\n\tif (info->params.data_rate) {\n\t\tinfo->timeout = (32*HZ*bits_per_char) /\n\t\t\t\tinfo->params.data_rate;\n\t}\n\tinfo->timeout += HZ/50;\t\t \n\n\ttty_port_set_cts_flow(&info->port, cflag & CRTSCTS);\n\ttty_port_set_check_carrier(&info->port, ~cflag & CLOCAL);\n\n\t \n\n\tinfo->read_status_mask = IRQ_RXOVER;\n\tif (I_INPCK(info->port.tty))\n\t\tinfo->read_status_mask |= MASK_PARITY | MASK_FRAMING;\n\tif (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))\n\t\tinfo->read_status_mask |= MASK_BREAK;\n\tif (I_IGNPAR(info->port.tty))\n\t\tinfo->ignore_status_mask |= MASK_PARITY | MASK_FRAMING;\n\tif (I_IGNBRK(info->port.tty)) {\n\t\tinfo->ignore_status_mask |= MASK_BREAK;\n\t\t \n\t\tif (I_IGNPAR(info->port.tty))\n\t\t\tinfo->ignore_status_mask |= MASK_OVERRUN;\n\t}\n\n\tprogram_hw(info);\n}\n\nstatic int get_stats(struct slgt_info *info, struct mgsl_icount __user *user_icount)\n{\n\tDBGINFO((\"%s get_stats\\n\",  info->device_name));\n\tif (!user_icount) {\n\t\tmemset(&info->icount, 0, sizeof(info->icount));\n\t} else {\n\t\tif (copy_to_user(user_icount, &info->icount, sizeof(struct mgsl_icount)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int get_params(struct slgt_info *info, MGSL_PARAMS __user *user_params)\n{\n\tDBGINFO((\"%s get_params\\n\", info->device_name));\n\tif (copy_to_user(user_params, &info->params, sizeof(MGSL_PARAMS)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int set_params(struct slgt_info *info, MGSL_PARAMS __user *new_params)\n{\n \tunsigned long flags;\n\tMGSL_PARAMS tmp_params;\n\n\tDBGINFO((\"%s set_params\\n\", info->device_name));\n\tif (copy_from_user(&tmp_params, new_params, sizeof(MGSL_PARAMS)))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tif (tmp_params.mode == MGSL_MODE_BASE_CLOCK)\n\t\tinfo->base_clock = tmp_params.clock_speed;\n\telse\n\t\tmemcpy(&info->params, &tmp_params, sizeof(MGSL_PARAMS));\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\tprogram_hw(info);\n\n\treturn 0;\n}\n\nstatic int get_txidle(struct slgt_info *info, int __user *idle_mode)\n{\n\tDBGINFO((\"%s get_txidle=%d\\n\", info->device_name, info->idle_mode));\n\tif (put_user(info->idle_mode, idle_mode))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int set_txidle(struct slgt_info *info, int idle_mode)\n{\n \tunsigned long flags;\n\tDBGINFO((\"%s set_txidle(%d)\\n\", info->device_name, idle_mode));\n\tspin_lock_irqsave(&info->lock,flags);\n\tinfo->idle_mode = idle_mode;\n\tif (info->params.mode != MGSL_MODE_ASYNC)\n\t\ttx_set_idle(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\treturn 0;\n}\n\nstatic int tx_enable(struct slgt_info *info, int enable)\n{\n \tunsigned long flags;\n\tDBGINFO((\"%s tx_enable(%d)\\n\", info->device_name, enable));\n\tspin_lock_irqsave(&info->lock,flags);\n\tif (enable) {\n\t\tif (!info->tx_enabled)\n\t\t\ttx_start(info);\n\t} else {\n\t\tif (info->tx_enabled)\n\t\t\ttx_stop(info);\n\t}\n\tspin_unlock_irqrestore(&info->lock,flags);\n\treturn 0;\n}\n\n \nstatic int tx_abort(struct slgt_info *info)\n{\n \tunsigned long flags;\n\tDBGINFO((\"%s tx_abort\\n\", info->device_name));\n\tspin_lock_irqsave(&info->lock,flags);\n\ttdma_reset(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\treturn 0;\n}\n\nstatic int rx_enable(struct slgt_info *info, int enable)\n{\n \tunsigned long flags;\n\tunsigned int rbuf_fill_level;\n\tDBGINFO((\"%s rx_enable(%08x)\\n\", info->device_name, enable));\n\tspin_lock_irqsave(&info->lock,flags);\n\t \n\trbuf_fill_level = ((unsigned int)enable) >> 16;\n\tif (rbuf_fill_level) {\n\t\tif ((rbuf_fill_level > DMABUFSIZE) || (rbuf_fill_level % 4)) {\n\t\t\tspin_unlock_irqrestore(&info->lock, flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tinfo->rbuf_fill_level = rbuf_fill_level;\n\t\tif (rbuf_fill_level < 128)\n\t\t\tinfo->rx_pio = 1;  \n\t\telse\n\t\t\tinfo->rx_pio = 0;  \n\t\trx_stop(info);  \n\t}\n\n\t \n\tenable &= 3;\n\tif (enable) {\n\t\tif (!info->rx_enabled)\n\t\t\trx_start(info);\n\t\telse if (enable == 2) {\n\t\t\t \n\t\t\twr_reg16(info, RCR, rd_reg16(info, RCR) | BIT3);\n\t\t}\n\t} else {\n\t\tif (info->rx_enabled)\n\t\t\trx_stop(info);\n\t}\n\tspin_unlock_irqrestore(&info->lock,flags);\n\treturn 0;\n}\n\n \nstatic int wait_mgsl_event(struct slgt_info *info, int __user *mask_ptr)\n{\n \tunsigned long flags;\n\tint s;\n\tint rc=0;\n\tstruct mgsl_icount cprev, cnow;\n\tint events;\n\tint mask;\n\tstruct\t_input_signal_events oldsigs, newsigs;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tif (get_user(mask, mask_ptr))\n\t\treturn -EFAULT;\n\n\tDBGINFO((\"%s wait_mgsl_event(%d)\\n\", info->device_name, mask));\n\n\tspin_lock_irqsave(&info->lock,flags);\n\n\t \n\tget_gtsignals(info);\n\ts = info->signals;\n\n\tevents = mask &\n\t\t( ((s & SerialSignal_DSR) ? MgslEvent_DsrActive:MgslEvent_DsrInactive) +\n \t\t  ((s & SerialSignal_DCD) ? MgslEvent_DcdActive:MgslEvent_DcdInactive) +\n\t\t  ((s & SerialSignal_CTS) ? MgslEvent_CtsActive:MgslEvent_CtsInactive) +\n\t\t  ((s & SerialSignal_RI)  ? MgslEvent_RiActive :MgslEvent_RiInactive) );\n\tif (events) {\n\t\tspin_unlock_irqrestore(&info->lock,flags);\n\t\tgoto exit;\n\t}\n\n\t \n\tcprev = info->icount;\n\toldsigs = info->input_signal_events;\n\n\t \n\tif (mask & (MgslEvent_ExitHuntMode+MgslEvent_IdleReceived)) {\n\t\tunsigned short val = rd_reg16(info, SCR);\n\t\tif (!(val & IRQ_RXIDLE))\n\t\t\twr_reg16(info, SCR, (unsigned short)(val | IRQ_RXIDLE));\n\t}\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tadd_wait_queue(&info->event_wait_q, &wait);\n\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n\tfor(;;) {\n\t\tschedule();\n\t\tif (signal_pending(current)) {\n\t\t\trc = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tspin_lock_irqsave(&info->lock,flags);\n\t\tcnow = info->icount;\n\t\tnewsigs = info->input_signal_events;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_unlock_irqrestore(&info->lock,flags);\n\n\t\t \n\t\tif (newsigs.dsr_up   == oldsigs.dsr_up   &&\n\t\t    newsigs.dsr_down == oldsigs.dsr_down &&\n\t\t    newsigs.dcd_up   == oldsigs.dcd_up   &&\n\t\t    newsigs.dcd_down == oldsigs.dcd_down &&\n\t\t    newsigs.cts_up   == oldsigs.cts_up   &&\n\t\t    newsigs.cts_down == oldsigs.cts_down &&\n\t\t    newsigs.ri_up    == oldsigs.ri_up    &&\n\t\t    newsigs.ri_down  == oldsigs.ri_down  &&\n\t\t    cnow.exithunt    == cprev.exithunt   &&\n\t\t    cnow.rxidle      == cprev.rxidle) {\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tevents = mask &\n\t\t\t( (newsigs.dsr_up   != oldsigs.dsr_up   ? MgslEvent_DsrActive:0)   +\n\t\t\t  (newsigs.dsr_down != oldsigs.dsr_down ? MgslEvent_DsrInactive:0) +\n\t\t\t  (newsigs.dcd_up   != oldsigs.dcd_up   ? MgslEvent_DcdActive:0)   +\n\t\t\t  (newsigs.dcd_down != oldsigs.dcd_down ? MgslEvent_DcdInactive:0) +\n\t\t\t  (newsigs.cts_up   != oldsigs.cts_up   ? MgslEvent_CtsActive:0)   +\n\t\t\t  (newsigs.cts_down != oldsigs.cts_down ? MgslEvent_CtsInactive:0) +\n\t\t\t  (newsigs.ri_up    != oldsigs.ri_up    ? MgslEvent_RiActive:0)    +\n\t\t\t  (newsigs.ri_down  != oldsigs.ri_down  ? MgslEvent_RiInactive:0)  +\n\t\t\t  (cnow.exithunt    != cprev.exithunt   ? MgslEvent_ExitHuntMode:0) +\n\t\t\t  (cnow.rxidle      != cprev.rxidle     ? MgslEvent_IdleReceived:0) );\n\t\tif (events)\n\t\t\tbreak;\n\n\t\tcprev = cnow;\n\t\toldsigs = newsigs;\n\t}\n\n\tremove_wait_queue(&info->event_wait_q, &wait);\n\tset_current_state(TASK_RUNNING);\n\n\n\tif (mask & (MgslEvent_ExitHuntMode + MgslEvent_IdleReceived)) {\n\t\tspin_lock_irqsave(&info->lock,flags);\n\t\tif (!waitqueue_active(&info->event_wait_q)) {\n\t\t\t \n\t\t\twr_reg16(info, SCR,\n\t\t\t\t(unsigned short)(rd_reg16(info, SCR) & ~IRQ_RXIDLE));\n\t\t}\n\t\tspin_unlock_irqrestore(&info->lock,flags);\n\t}\nexit:\n\tif (rc == 0)\n\t\trc = put_user(events, mask_ptr);\n\treturn rc;\n}\n\nstatic int get_interface(struct slgt_info *info, int __user *if_mode)\n{\n\tDBGINFO((\"%s get_interface=%x\\n\", info->device_name, info->if_mode));\n\tif (put_user(info->if_mode, if_mode))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int set_interface(struct slgt_info *info, int if_mode)\n{\n \tunsigned long flags;\n\tunsigned short val;\n\n\tDBGINFO((\"%s set_interface=%x)\\n\", info->device_name, if_mode));\n\tspin_lock_irqsave(&info->lock,flags);\n\tinfo->if_mode = if_mode;\n\n\tmsc_set_vcr(info);\n\n\t \n\tval = rd_reg16(info, TCR);\n\tif (info->if_mode & MGSL_INTERFACE_RTS_EN)\n\t\tval |= BIT7;\n\telse\n\t\tval &= ~BIT7;\n\twr_reg16(info, TCR, val);\n\n\tspin_unlock_irqrestore(&info->lock,flags);\n\treturn 0;\n}\n\nstatic int get_xsync(struct slgt_info *info, int __user *xsync)\n{\n\tDBGINFO((\"%s get_xsync=%x\\n\", info->device_name, info->xsync));\n\tif (put_user(info->xsync, xsync))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic int set_xsync(struct slgt_info *info, int xsync)\n{\n\tunsigned long flags;\n\n\tDBGINFO((\"%s set_xsync=%x)\\n\", info->device_name, xsync));\n\tspin_lock_irqsave(&info->lock, flags);\n\tinfo->xsync = xsync;\n\twr_reg32(info, XSR, xsync);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\treturn 0;\n}\n\nstatic int get_xctrl(struct slgt_info *info, int __user *xctrl)\n{\n\tDBGINFO((\"%s get_xctrl=%x\\n\", info->device_name, info->xctrl));\n\tif (put_user(info->xctrl, xctrl))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic int set_xctrl(struct slgt_info *info, int xctrl)\n{\n\tunsigned long flags;\n\n\tDBGINFO((\"%s set_xctrl=%x)\\n\", info->device_name, xctrl));\n\tspin_lock_irqsave(&info->lock, flags);\n\tinfo->xctrl = xctrl;\n\twr_reg32(info, XCR, xctrl);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\treturn 0;\n}\n\n \nstatic int set_gpio(struct slgt_info *info, struct gpio_desc __user *user_gpio)\n{\n \tunsigned long flags;\n\tstruct gpio_desc gpio;\n\t__u32 data;\n\n\tif (!info->gpio_present)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&gpio, user_gpio, sizeof(gpio)))\n\t\treturn -EFAULT;\n\tDBGINFO((\"%s set_gpio state=%08x smask=%08x dir=%08x dmask=%08x\\n\",\n\t\t info->device_name, gpio.state, gpio.smask,\n\t\t gpio.dir, gpio.dmask));\n\n\tspin_lock_irqsave(&info->port_array[0]->lock, flags);\n\tif (gpio.dmask) {\n\t\tdata = rd_reg32(info, IODR);\n\t\tdata |= gpio.dmask & gpio.dir;\n\t\tdata &= ~(gpio.dmask & ~gpio.dir);\n\t\twr_reg32(info, IODR, data);\n\t}\n\tif (gpio.smask) {\n\t\tdata = rd_reg32(info, IOVR);\n\t\tdata |= gpio.smask & gpio.state;\n\t\tdata &= ~(gpio.smask & ~gpio.state);\n\t\twr_reg32(info, IOVR, data);\n\t}\n\tspin_unlock_irqrestore(&info->port_array[0]->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int get_gpio(struct slgt_info *info, struct gpio_desc __user *user_gpio)\n{\n\tstruct gpio_desc gpio;\n\tif (!info->gpio_present)\n\t\treturn -EINVAL;\n\tgpio.state = rd_reg32(info, IOVR);\n\tgpio.smask = 0xffffffff;\n\tgpio.dir   = rd_reg32(info, IODR);\n\tgpio.dmask = 0xffffffff;\n\tif (copy_to_user(user_gpio, &gpio, sizeof(gpio)))\n\t\treturn -EFAULT;\n\tDBGINFO((\"%s get_gpio state=%08x dir=%08x\\n\",\n\t\t info->device_name, gpio.state, gpio.dir));\n\treturn 0;\n}\n\n \nstatic void init_cond_wait(struct cond_wait *w, unsigned int data)\n{\n\tinit_waitqueue_head(&w->q);\n\tinit_waitqueue_entry(&w->wait, current);\n\tw->data = data;\n}\n\nstatic void add_cond_wait(struct cond_wait **head, struct cond_wait *w)\n{\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tadd_wait_queue(&w->q, &w->wait);\n\tw->next = *head;\n\t*head = w;\n}\n\nstatic void remove_cond_wait(struct cond_wait **head, struct cond_wait *cw)\n{\n\tstruct cond_wait *w, *prev;\n\tremove_wait_queue(&cw->q, &cw->wait);\n\tset_current_state(TASK_RUNNING);\n\tfor (w = *head, prev = NULL ; w != NULL ; prev = w, w = w->next) {\n\t\tif (w == cw) {\n\t\t\tif (prev != NULL)\n\t\t\t\tprev->next = w->next;\n\t\t\telse\n\t\t\t\t*head = w->next;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void flush_cond_wait(struct cond_wait **head)\n{\n\twhile (*head != NULL) {\n\t\twake_up_interruptible(&(*head)->q);\n\t\t*head = (*head)->next;\n\t}\n}\n\n \nstatic int wait_gpio(struct slgt_info *info, struct gpio_desc __user *user_gpio)\n{\n \tunsigned long flags;\n\tint rc = 0;\n\tstruct gpio_desc gpio;\n\tstruct cond_wait wait;\n\tu32 state;\n\n\tif (!info->gpio_present)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&gpio, user_gpio, sizeof(gpio)))\n\t\treturn -EFAULT;\n\tDBGINFO((\"%s wait_gpio() state=%08x smask=%08x\\n\",\n\t\t info->device_name, gpio.state, gpio.smask));\n\t \n\tif ((gpio.smask &= ~rd_reg32(info, IODR)) == 0)\n\t\treturn -EINVAL;\n\tinit_cond_wait(&wait, gpio.smask);\n\n\tspin_lock_irqsave(&info->port_array[0]->lock, flags);\n\t \n\twr_reg32(info, IOER, rd_reg32(info, IOER) | gpio.smask);\n\t \n\tstate = rd_reg32(info, IOVR);\n\n\tif (gpio.smask & ~(state ^ gpio.state)) {\n\t\t \n\t\tgpio.state = state;\n\t} else {\n\t\t \n\t\tadd_cond_wait(&info->gpio_wait_q, &wait);\n\t\tspin_unlock_irqrestore(&info->port_array[0]->lock, flags);\n\t\tschedule();\n\t\tif (signal_pending(current))\n\t\t\trc = -ERESTARTSYS;\n\t\telse\n\t\t\tgpio.state = wait.data;\n\t\tspin_lock_irqsave(&info->port_array[0]->lock, flags);\n\t\tremove_cond_wait(&info->gpio_wait_q, &wait);\n\t}\n\n\t \n\tif (info->gpio_wait_q == NULL)\n\t\twr_reg32(info, IOER, 0);\n\tspin_unlock_irqrestore(&info->port_array[0]->lock, flags);\n\n\tif ((rc == 0) && copy_to_user(user_gpio, &gpio, sizeof(gpio)))\n\t\trc = -EFAULT;\n\treturn rc;\n}\n\nstatic int modem_input_wait(struct slgt_info *info,int arg)\n{\n \tunsigned long flags;\n\tint rc;\n\tstruct mgsl_icount cprev, cnow;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\t \n\tspin_lock_irqsave(&info->lock,flags);\n\tcprev = info->icount;\n\tadd_wait_queue(&info->status_event_wait_q, &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n\tfor(;;) {\n\t\tschedule();\n\t\tif (signal_pending(current)) {\n\t\t\trc = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tspin_lock_irqsave(&info->lock,flags);\n\t\tcnow = info->icount;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_unlock_irqrestore(&info->lock,flags);\n\n\t\t \n\t\tif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\n\t\t    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif ((arg & TIOCM_RNG && cnow.rng != cprev.rng) ||\n\t\t    (arg & TIOCM_DSR && cnow.dsr != cprev.dsr) ||\n\t\t    (arg & TIOCM_CD  && cnow.dcd != cprev.dcd) ||\n\t\t    (arg & TIOCM_CTS && cnow.cts != cprev.cts)) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcprev = cnow;\n\t}\n\tremove_wait_queue(&info->status_event_wait_q, &wait);\n\tset_current_state(TASK_RUNNING);\n\treturn rc;\n}\n\n \nstatic int tiocmget(struct tty_struct *tty)\n{\n\tstruct slgt_info *info = tty->driver_data;\n\tunsigned int result;\n \tunsigned long flags;\n\n\tspin_lock_irqsave(&info->lock,flags);\n \tget_gtsignals(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n\tresult = ((info->signals & SerialSignal_RTS) ? TIOCM_RTS:0) +\n\t\t((info->signals & SerialSignal_DTR) ? TIOCM_DTR:0) +\n\t\t((info->signals & SerialSignal_DCD) ? TIOCM_CAR:0) +\n\t\t((info->signals & SerialSignal_RI)  ? TIOCM_RNG:0) +\n\t\t((info->signals & SerialSignal_DSR) ? TIOCM_DSR:0) +\n\t\t((info->signals & SerialSignal_CTS) ? TIOCM_CTS:0);\n\n\tDBGINFO((\"%s tiocmget value=%08X\\n\", info->device_name, result));\n\treturn result;\n}\n\n \nstatic int tiocmset(struct tty_struct *tty,\n\t\t    unsigned int set, unsigned int clear)\n{\n\tstruct slgt_info *info = tty->driver_data;\n \tunsigned long flags;\n\n\tDBGINFO((\"%s tiocmset(%x,%x)\\n\", info->device_name, set, clear));\n\n\tif (set & TIOCM_RTS)\n\t\tinfo->signals |= SerialSignal_RTS;\n\tif (set & TIOCM_DTR)\n\t\tinfo->signals |= SerialSignal_DTR;\n\tif (clear & TIOCM_RTS)\n\t\tinfo->signals &= ~SerialSignal_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tinfo->signals &= ~SerialSignal_DTR;\n\n\tspin_lock_irqsave(&info->lock,flags);\n\tset_gtsignals(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\treturn 0;\n}\n\nstatic bool carrier_raised(struct tty_port *port)\n{\n\tunsigned long flags;\n\tstruct slgt_info *info = container_of(port, struct slgt_info, port);\n\n\tspin_lock_irqsave(&info->lock,flags);\n\tget_gtsignals(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n\treturn info->signals & SerialSignal_DCD;\n}\n\nstatic void dtr_rts(struct tty_port *port, bool active)\n{\n\tunsigned long flags;\n\tstruct slgt_info *info = container_of(port, struct slgt_info, port);\n\n\tspin_lock_irqsave(&info->lock,flags);\n\tif (active)\n\t\tinfo->signals |= SerialSignal_RTS | SerialSignal_DTR;\n\telse\n\t\tinfo->signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\n\tset_gtsignals(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n}\n\n\n \nstatic int block_til_ready(struct tty_struct *tty, struct file *filp,\n\t\t\t   struct slgt_info *info)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint\t\tretval;\n\tbool\t\tdo_clocal = false;\n\tunsigned long\tflags;\n\tbool\t\tcd;\n\tstruct tty_port *port = &info->port;\n\n\tDBGINFO((\"%s block_til_ready\\n\", tty->driver->name));\n\n\tif (filp->f_flags & O_NONBLOCK || tty_io_error(tty)) {\n\t\t \n\t\ttty_port_set_active(port, true);\n\t\treturn 0;\n\t}\n\n\tif (C_CLOCAL(tty))\n\t\tdo_clocal = true;\n\n\t \n\n\tretval = 0;\n\tadd_wait_queue(&port->open_wait, &wait);\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tport->count--;\n\tspin_unlock_irqrestore(&info->lock, flags);\n\tport->blocked_open++;\n\n\twhile (1) {\n\t\tif (C_BAUD(tty) && tty_port_initialized(port))\n\t\t\ttty_port_raise_dtr_rts(port);\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (tty_hung_up_p(filp) || !tty_port_initialized(port)) {\n\t\t\tretval = (port->flags & ASYNC_HUP_NOTIFY) ?\n\t\t\t\t\t-EAGAIN : -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcd = tty_port_carrier_raised(port);\n\t\tif (do_clocal || cd)\n\t\t\tbreak;\n\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tDBGINFO((\"%s block_til_ready wait\\n\", tty->driver->name));\n\t\ttty_unlock(tty);\n\t\tschedule();\n\t\ttty_lock(tty);\n\t}\n\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&port->open_wait, &wait);\n\n\tif (!tty_hung_up_p(filp))\n\t\tport->count++;\n\tport->blocked_open--;\n\n\tif (!retval)\n\t\ttty_port_set_active(port, true);\n\n\tDBGINFO((\"%s block_til_ready ready, rc=%d\\n\", tty->driver->name, retval));\n\treturn retval;\n}\n\n \nstatic int alloc_tmp_rbuf(struct slgt_info *info)\n{\n\tinfo->tmp_rbuf = kmalloc(info->max_frame_size + 5, GFP_KERNEL);\n\tif (info->tmp_rbuf == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void free_tmp_rbuf(struct slgt_info *info)\n{\n\tkfree(info->tmp_rbuf);\n\tinfo->tmp_rbuf = NULL;\n}\n\n \nstatic int alloc_desc(struct slgt_info *info)\n{\n\tunsigned int i;\n\tunsigned int pbufs;\n\n\t \n\tinfo->bufs = dma_alloc_coherent(&info->pdev->dev, DESC_LIST_SIZE,\n\t\t\t\t\t&info->bufs_dma_addr, GFP_KERNEL);\n\tif (info->bufs == NULL)\n\t\treturn -ENOMEM;\n\n\tinfo->rbufs = (struct slgt_desc*)info->bufs;\n\tinfo->tbufs = ((struct slgt_desc*)info->bufs) + info->rbuf_count;\n\n\tpbufs = (unsigned int)info->bufs_dma_addr;\n\n\t \n\n\tfor (i=0; i < info->rbuf_count; i++) {\n\t\t \n\t\tinfo->rbufs[i].pdesc = pbufs + (i * sizeof(struct slgt_desc));\n\n\t\t \n\t\tif (i == info->rbuf_count - 1)\n\t\t\tinfo->rbufs[i].next = cpu_to_le32(pbufs);\n\t\telse\n\t\t\tinfo->rbufs[i].next = cpu_to_le32(pbufs + ((i+1) * sizeof(struct slgt_desc)));\n\t\tset_desc_count(info->rbufs[i], DMABUFSIZE);\n\t}\n\n\tfor (i=0; i < info->tbuf_count; i++) {\n\t\t \n\t\tinfo->tbufs[i].pdesc = pbufs + ((info->rbuf_count + i) * sizeof(struct slgt_desc));\n\n\t\t \n\t\tif (i == info->tbuf_count - 1)\n\t\t\tinfo->tbufs[i].next = cpu_to_le32(pbufs + info->rbuf_count * sizeof(struct slgt_desc));\n\t\telse\n\t\t\tinfo->tbufs[i].next = cpu_to_le32(pbufs + ((info->rbuf_count + i + 1) * sizeof(struct slgt_desc)));\n\t}\n\n\treturn 0;\n}\n\nstatic void free_desc(struct slgt_info *info)\n{\n\tif (info->bufs != NULL) {\n\t\tdma_free_coherent(&info->pdev->dev, DESC_LIST_SIZE,\n\t\t\t\t  info->bufs, info->bufs_dma_addr);\n\t\tinfo->bufs  = NULL;\n\t\tinfo->rbufs = NULL;\n\t\tinfo->tbufs = NULL;\n\t}\n}\n\nstatic int alloc_bufs(struct slgt_info *info, struct slgt_desc *bufs, int count)\n{\n\tint i;\n\tfor (i=0; i < count; i++) {\n\t\tbufs[i].buf = dma_alloc_coherent(&info->pdev->dev, DMABUFSIZE,\n\t\t\t\t\t\t &bufs[i].buf_dma_addr, GFP_KERNEL);\n\t\tif (!bufs[i].buf)\n\t\t\treturn -ENOMEM;\n\t\tbufs[i].pbuf  = cpu_to_le32((unsigned int)bufs[i].buf_dma_addr);\n\t}\n\treturn 0;\n}\n\nstatic void free_bufs(struct slgt_info *info, struct slgt_desc *bufs, int count)\n{\n\tint i;\n\tfor (i=0; i < count; i++) {\n\t\tif (bufs[i].buf == NULL)\n\t\t\tcontinue;\n\t\tdma_free_coherent(&info->pdev->dev, DMABUFSIZE, bufs[i].buf,\n\t\t\t\t  bufs[i].buf_dma_addr);\n\t\tbufs[i].buf = NULL;\n\t}\n}\n\nstatic int alloc_dma_bufs(struct slgt_info *info)\n{\n\tinfo->rbuf_count = 32;\n\tinfo->tbuf_count = 32;\n\n\tif (alloc_desc(info) < 0 ||\n\t    alloc_bufs(info, info->rbufs, info->rbuf_count) < 0 ||\n\t    alloc_bufs(info, info->tbufs, info->tbuf_count) < 0 ||\n\t    alloc_tmp_rbuf(info) < 0) {\n\t\tDBGERR((\"%s DMA buffer alloc fail\\n\", info->device_name));\n\t\treturn -ENOMEM;\n\t}\n\treset_rbufs(info);\n\treturn 0;\n}\n\nstatic void free_dma_bufs(struct slgt_info *info)\n{\n\tif (info->bufs) {\n\t\tfree_bufs(info, info->rbufs, info->rbuf_count);\n\t\tfree_bufs(info, info->tbufs, info->tbuf_count);\n\t\tfree_desc(info);\n\t}\n\tfree_tmp_rbuf(info);\n}\n\nstatic int claim_resources(struct slgt_info *info)\n{\n\tif (request_mem_region(info->phys_reg_addr, SLGT_REG_SIZE, \"synclink_gt\") == NULL) {\n\t\tDBGERR((\"%s reg addr conflict, addr=%08X\\n\",\n\t\t\tinfo->device_name, info->phys_reg_addr));\n\t\tinfo->init_error = DiagStatus_AddressConflict;\n\t\tgoto errout;\n\t}\n\telse\n\t\tinfo->reg_addr_requested = true;\n\n\tinfo->reg_addr = ioremap(info->phys_reg_addr, SLGT_REG_SIZE);\n\tif (!info->reg_addr) {\n\t\tDBGERR((\"%s can't map device registers, addr=%08X\\n\",\n\t\t\tinfo->device_name, info->phys_reg_addr));\n\t\tinfo->init_error = DiagStatus_CantAssignPciResources;\n\t\tgoto errout;\n\t}\n\treturn 0;\n\nerrout:\n\trelease_resources(info);\n\treturn -ENODEV;\n}\n\nstatic void release_resources(struct slgt_info *info)\n{\n\tif (info->irq_requested) {\n\t\tfree_irq(info->irq_level, info);\n\t\tinfo->irq_requested = false;\n\t}\n\n\tif (info->reg_addr_requested) {\n\t\trelease_mem_region(info->phys_reg_addr, SLGT_REG_SIZE);\n\t\tinfo->reg_addr_requested = false;\n\t}\n\n\tif (info->reg_addr) {\n\t\tiounmap(info->reg_addr);\n\t\tinfo->reg_addr = NULL;\n\t}\n}\n\n \nstatic void add_device(struct slgt_info *info)\n{\n\tchar *devstr;\n\n\tinfo->next_device = NULL;\n\tinfo->line = slgt_device_count;\n\tsprintf(info->device_name, \"%s%d\", tty_dev_prefix, info->line);\n\n\tif (info->line < MAX_DEVICES) {\n\t\tif (maxframe[info->line])\n\t\t\tinfo->max_frame_size = maxframe[info->line];\n\t}\n\n\tslgt_device_count++;\n\n\tif (!slgt_device_list)\n\t\tslgt_device_list = info;\n\telse {\n\t\tstruct slgt_info *current_dev = slgt_device_list;\n\t\twhile(current_dev->next_device)\n\t\t\tcurrent_dev = current_dev->next_device;\n\t\tcurrent_dev->next_device = info;\n\t}\n\n\tif (info->max_frame_size < 4096)\n\t\tinfo->max_frame_size = 4096;\n\telse if (info->max_frame_size > 65535)\n\t\tinfo->max_frame_size = 65535;\n\n\tswitch(info->pdev->device) {\n\tcase SYNCLINK_GT_DEVICE_ID:\n\t\tdevstr = \"GT\";\n\t\tbreak;\n\tcase SYNCLINK_GT2_DEVICE_ID:\n\t\tdevstr = \"GT2\";\n\t\tbreak;\n\tcase SYNCLINK_GT4_DEVICE_ID:\n\t\tdevstr = \"GT4\";\n\t\tbreak;\n\tcase SYNCLINK_AC_DEVICE_ID:\n\t\tdevstr = \"AC\";\n\t\tinfo->params.mode = MGSL_MODE_ASYNC;\n\t\tbreak;\n\tdefault:\n\t\tdevstr = \"(unknown model)\";\n\t}\n\tprintk(\"SyncLink %s %s IO=%08x IRQ=%d MaxFrameSize=%u\\n\",\n\t\tdevstr, info->device_name, info->phys_reg_addr,\n\t\tinfo->irq_level, info->max_frame_size);\n\n#if SYNCLINK_GENERIC_HDLC\n\thdlcdev_init(info);\n#endif\n}\n\nstatic const struct tty_port_operations slgt_port_ops = {\n\t.carrier_raised = carrier_raised,\n\t.dtr_rts = dtr_rts,\n};\n\n \nstatic struct slgt_info *alloc_dev(int adapter_num, int port_num, struct pci_dev *pdev)\n{\n\tstruct slgt_info *info;\n\n\tinfo = kzalloc(sizeof(struct slgt_info), GFP_KERNEL);\n\n\tif (!info) {\n\t\tDBGERR((\"%s device alloc failed adapter=%d port=%d\\n\",\n\t\t\tdriver_name, adapter_num, port_num));\n\t} else {\n\t\ttty_port_init(&info->port);\n\t\tinfo->port.ops = &slgt_port_ops;\n\t\tINIT_WORK(&info->task, bh_handler);\n\t\tinfo->max_frame_size = 4096;\n\t\tinfo->base_clock = 14745600;\n\t\tinfo->rbuf_fill_level = DMABUFSIZE;\n\t\tinit_waitqueue_head(&info->status_event_wait_q);\n\t\tinit_waitqueue_head(&info->event_wait_q);\n\t\tspin_lock_init(&info->netlock);\n\t\tmemcpy(&info->params,&default_params,sizeof(MGSL_PARAMS));\n\t\tinfo->idle_mode = HDLC_TXIDLE_FLAGS;\n\t\tinfo->adapter_num = adapter_num;\n\t\tinfo->port_num = port_num;\n\n\t\ttimer_setup(&info->tx_timer, tx_timeout, 0);\n\t\ttimer_setup(&info->rx_timer, rx_timeout, 0);\n\n\t\t \n\t\tinfo->pdev = pdev;\n\t\tinfo->irq_level = pdev->irq;\n\t\tinfo->phys_reg_addr = pci_resource_start(pdev,0);\n\n\t\tinfo->bus_type = MGSL_BUS_TYPE_PCI;\n\t\tinfo->irq_flags = IRQF_SHARED;\n\n\t\tinfo->init_error = -1;  \n\t}\n\n\treturn info;\n}\n\nstatic void device_init(int adapter_num, struct pci_dev *pdev)\n{\n\tstruct slgt_info *port_array[SLGT_MAX_PORTS];\n\tint i;\n\tint port_count = 1;\n\n\tif (pdev->device == SYNCLINK_GT2_DEVICE_ID)\n\t\tport_count = 2;\n\telse if (pdev->device == SYNCLINK_GT4_DEVICE_ID)\n\t\tport_count = 4;\n\n\t \n\tfor (i=0; i < port_count; ++i) {\n\t\tport_array[i] = alloc_dev(adapter_num, i, pdev);\n\t\tif (port_array[i] == NULL) {\n\t\t\tfor (--i; i >= 0; --i) {\n\t\t\t\ttty_port_destroy(&port_array[i]->port);\n\t\t\t\tkfree(port_array[i]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tfor (i=0; i < port_count; ++i) {\n\t\tmemcpy(port_array[i]->port_array, port_array, sizeof(port_array));\n\t\tadd_device(port_array[i]);\n\t\tport_array[i]->port_count = port_count;\n\t\tspin_lock_init(&port_array[i]->lock);\n\t}\n\n\t \n\tif (!claim_resources(port_array[0])) {\n\n\t\talloc_dma_bufs(port_array[0]);\n\n\t\t \n\t\tfor (i = 1; i < port_count; ++i) {\n\t\t\tport_array[i]->irq_level = port_array[0]->irq_level;\n\t\t\tport_array[i]->reg_addr  = port_array[0]->reg_addr;\n\t\t\talloc_dma_bufs(port_array[i]);\n\t\t}\n\n\t\tif (request_irq(port_array[0]->irq_level,\n\t\t\t\t\tslgt_interrupt,\n\t\t\t\t\tport_array[0]->irq_flags,\n\t\t\t\t\tport_array[0]->device_name,\n\t\t\t\t\tport_array[0]) < 0) {\n\t\t\tDBGERR((\"%s request_irq failed IRQ=%d\\n\",\n\t\t\t\tport_array[0]->device_name,\n\t\t\t\tport_array[0]->irq_level));\n\t\t} else {\n\t\t\tport_array[0]->irq_requested = true;\n\t\t\tadapter_test(port_array[0]);\n\t\t\tfor (i=1 ; i < port_count ; i++) {\n\t\t\t\tport_array[i]->init_error = port_array[0]->init_error;\n\t\t\t\tport_array[i]->gpio_present = port_array[0]->gpio_present;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < port_count; ++i) {\n\t\tstruct slgt_info *info = port_array[i];\n\t\ttty_port_register_device(&info->port, serial_driver, info->line,\n\t\t\t\t&info->pdev->dev);\n\t}\n}\n\nstatic int init_one(struct pci_dev *dev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tif (pci_enable_device(dev)) {\n\t\tprintk(\"error enabling pci device %p\\n\", dev);\n\t\treturn -EIO;\n\t}\n\tpci_set_master(dev);\n\tdevice_init(slgt_device_count, dev);\n\treturn 0;\n}\n\nstatic void remove_one(struct pci_dev *dev)\n{\n}\n\nstatic const struct tty_operations ops = {\n\t.open = open,\n\t.close = close,\n\t.write = write,\n\t.put_char = put_char,\n\t.flush_chars = flush_chars,\n\t.write_room = write_room,\n\t.chars_in_buffer = chars_in_buffer,\n\t.flush_buffer = flush_buffer,\n\t.ioctl = ioctl,\n\t.compat_ioctl = slgt_compat_ioctl,\n\t.throttle = throttle,\n\t.unthrottle = unthrottle,\n\t.send_xchar = send_xchar,\n\t.break_ctl = set_break,\n\t.wait_until_sent = wait_until_sent,\n\t.set_termios = set_termios,\n\t.stop = tx_hold,\n\t.start = tx_release,\n\t.hangup = hangup,\n\t.tiocmget = tiocmget,\n\t.tiocmset = tiocmset,\n\t.get_icount = get_icount,\n\t.proc_show = synclink_gt_proc_show,\n};\n\nstatic void slgt_cleanup(void)\n{\n\tstruct slgt_info *info;\n\tstruct slgt_info *tmp;\n\n\tif (serial_driver) {\n\t\tfor (info=slgt_device_list ; info != NULL ; info=info->next_device)\n\t\t\ttty_unregister_device(serial_driver, info->line);\n\t\ttty_unregister_driver(serial_driver);\n\t\ttty_driver_kref_put(serial_driver);\n\t}\n\n\t \n\tinfo = slgt_device_list;\n\twhile(info) {\n\t\treset_port(info);\n\t\tinfo = info->next_device;\n\t}\n\n\t \n\tinfo = slgt_device_list;\n\twhile(info) {\n#if SYNCLINK_GENERIC_HDLC\n\t\thdlcdev_exit(info);\n#endif\n\t\tfree_dma_bufs(info);\n\t\tfree_tmp_rbuf(info);\n\t\tif (info->port_num == 0)\n\t\t\trelease_resources(info);\n\t\ttmp = info;\n\t\tinfo = info->next_device;\n\t\ttty_port_destroy(&tmp->port);\n\t\tkfree(tmp);\n\t}\n\n\tif (pci_registered)\n\t\tpci_unregister_driver(&pci_driver);\n}\n\n \nstatic int __init slgt_init(void)\n{\n\tint rc;\n\n\tserial_driver = tty_alloc_driver(MAX_DEVICES, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(serial_driver)) {\n\t\tprintk(\"%s can't allocate tty driver\\n\", driver_name);\n\t\treturn PTR_ERR(serial_driver);\n\t}\n\n\t \n\n\tserial_driver->driver_name = \"synclink_gt\";\n\tserial_driver->name = tty_dev_prefix;\n\tserial_driver->major = ttymajor;\n\tserial_driver->minor_start = 64;\n\tserial_driver->type = TTY_DRIVER_TYPE_SERIAL;\n\tserial_driver->subtype = SERIAL_TYPE_NORMAL;\n\tserial_driver->init_termios = tty_std_termios;\n\tserial_driver->init_termios.c_cflag =\n\t\tB9600 | CS8 | CREAD | HUPCL | CLOCAL;\n\tserial_driver->init_termios.c_ispeed = 9600;\n\tserial_driver->init_termios.c_ospeed = 9600;\n\ttty_set_operations(serial_driver, &ops);\n\tif ((rc = tty_register_driver(serial_driver)) < 0) {\n\t\tDBGERR((\"%s can't register serial driver\\n\", driver_name));\n\t\ttty_driver_kref_put(serial_driver);\n\t\tserial_driver = NULL;\n\t\tgoto error;\n\t}\n\n\tslgt_device_count = 0;\n\tif ((rc = pci_register_driver(&pci_driver)) < 0) {\n\t\tprintk(\"%s pci_register_driver error=%d\\n\", driver_name, rc);\n\t\tgoto error;\n\t}\n\tpci_registered = true;\n\n\treturn 0;\n\nerror:\n\tslgt_cleanup();\n\treturn rc;\n}\n\nstatic void __exit slgt_exit(void)\n{\n\tslgt_cleanup();\n}\n\nmodule_init(slgt_init);\nmodule_exit(slgt_exit);\n\n \n\nstatic inline void __iomem *calc_regaddr(struct slgt_info *info,\n\t\t\t\t\t unsigned int addr)\n{\n\tvoid __iomem *reg_addr = info->reg_addr + addr;\n\n\tif (addr >= 0x80)\n\t\treg_addr += info->port_num * 32;\n\telse if (addr >= 0x40)\n\t\treg_addr += info->port_num * 16;\n\n\treturn reg_addr;\n}\n\nstatic __u8 rd_reg8(struct slgt_info *info, unsigned int addr)\n{\n\treturn readb(calc_regaddr(info, addr));\n}\n\nstatic void wr_reg8(struct slgt_info *info, unsigned int addr, __u8 value)\n{\n\twriteb(value, calc_regaddr(info, addr));\n}\n\nstatic __u16 rd_reg16(struct slgt_info *info, unsigned int addr)\n{\n\treturn readw(calc_regaddr(info, addr));\n}\n\nstatic void wr_reg16(struct slgt_info *info, unsigned int addr, __u16 value)\n{\n\twritew(value, calc_regaddr(info, addr));\n}\n\nstatic __u32 rd_reg32(struct slgt_info *info, unsigned int addr)\n{\n\treturn readl(calc_regaddr(info, addr));\n}\n\nstatic void wr_reg32(struct slgt_info *info, unsigned int addr, __u32 value)\n{\n\twritel(value, calc_regaddr(info, addr));\n}\n\nstatic void rdma_reset(struct slgt_info *info)\n{\n\tunsigned int i;\n\n\t \n\twr_reg32(info, RDCSR, BIT1);\n\n\t \n\tfor(i=0 ; i < 1000 ; i++)\n\t\tif (!(rd_reg32(info, RDCSR) & BIT0))\n\t\t\tbreak;\n}\n\nstatic void tdma_reset(struct slgt_info *info)\n{\n\tunsigned int i;\n\n\t \n\twr_reg32(info, TDCSR, BIT1);\n\n\t \n\tfor(i=0 ; i < 1000 ; i++)\n\t\tif (!(rd_reg32(info, TDCSR) & BIT0))\n\t\t\tbreak;\n}\n\n \nstatic void enable_loopback(struct slgt_info *info)\n{\n\t \n\twr_reg16(info, SCR, (unsigned short)(rd_reg16(info, SCR) | BIT2));\n\n\tif (info->params.mode != MGSL_MODE_ASYNC) {\n\t\t \n\t\twr_reg8(info, CCR, 0x49);\n\n\t\t \n\t\tif (info->params.clock_speed)\n\t\t\tset_rate(info, info->params.clock_speed);\n\t\telse\n\t\t\tset_rate(info, 3686400);\n\t}\n}\n\n \nstatic void set_rate(struct slgt_info *info, u32 rate)\n{\n\tunsigned int div;\n\tunsigned int osc = info->base_clock;\n\n\t \n\n\tif (rate) {\n\t\tdiv = osc/rate;\n\t\tif (!(osc % rate) && div)\n\t\t\tdiv--;\n\t\twr_reg16(info, BDR, (unsigned short)div);\n\t}\n}\n\nstatic void rx_stop(struct slgt_info *info)\n{\n\tunsigned short val;\n\n\t \n\tval = rd_reg16(info, RCR) & ~BIT1;           \n\twr_reg16(info, RCR, (unsigned short)(val | BIT2));  \n\twr_reg16(info, RCR, val);                   \n\n\tslgt_irq_off(info, IRQ_RXOVER + IRQ_RXDATA + IRQ_RXIDLE);\n\n\t \n\twr_reg16(info, SSR, IRQ_RXIDLE + IRQ_RXOVER);\n\n\trdma_reset(info);\n\n\tinfo->rx_enabled = false;\n\tinfo->rx_restart = false;\n}\n\nstatic void rx_start(struct slgt_info *info)\n{\n\tunsigned short val;\n\n\tslgt_irq_off(info, IRQ_RXOVER + IRQ_RXDATA);\n\n\t \n\twr_reg16(info, SSR, IRQ_RXOVER);\n\n\t \n\tval = rd_reg16(info, RCR) & ~BIT1;  \n\twr_reg16(info, RCR, (unsigned short)(val | BIT2));  \n\twr_reg16(info, RCR, val);                   \n\n\trdma_reset(info);\n\treset_rbufs(info);\n\n\tif (info->rx_pio) {\n\t\t \n\t\twr_reg16(info, SCR, (unsigned short)(rd_reg16(info, SCR) & ~BIT14));\n\t\tslgt_irq_on(info, IRQ_RXDATA);\n\t\tif (info->params.mode == MGSL_MODE_ASYNC) {\n\t\t\t \n\t\t\twr_reg32(info, RDCSR, BIT6);\n\t\t}\n\t} else {\n\t\t \n\t\twr_reg16(info, SCR, (unsigned short)(rd_reg16(info, SCR) | BIT14));\n\t\t \n\t\twr_reg32(info, RDDAR, info->rbufs[0].pdesc);\n\n\t\tif (info->params.mode != MGSL_MODE_ASYNC) {\n\t\t\t \n\t\t\twr_reg32(info, RDCSR, (BIT2 + BIT0));\n\t\t} else {\n\t\t\t \n\t\t\twr_reg32(info, RDCSR, (BIT6 + BIT2 + BIT0));\n\t\t}\n\t}\n\n\tslgt_irq_on(info, IRQ_RXOVER);\n\n\t \n\twr_reg16(info, RCR, (unsigned short)(rd_reg16(info, RCR) | BIT1));\n\n\tinfo->rx_restart = false;\n\tinfo->rx_enabled = true;\n}\n\nstatic void tx_start(struct slgt_info *info)\n{\n\tif (!info->tx_enabled) {\n\t\twr_reg16(info, TCR,\n\t\t\t (unsigned short)((rd_reg16(info, TCR) | BIT1) & ~BIT2));\n\t\tinfo->tx_enabled = true;\n\t}\n\n\tif (desc_count(info->tbufs[info->tbuf_start])) {\n\t\tinfo->drop_rts_on_tx_done = false;\n\n\t\tif (info->params.mode != MGSL_MODE_ASYNC) {\n\t\t\tif (info->params.flags & HDLC_FLAG_AUTO_RTS) {\n\t\t\t\tget_gtsignals(info);\n\t\t\t\tif (!(info->signals & SerialSignal_RTS)) {\n\t\t\t\t\tinfo->signals |= SerialSignal_RTS;\n\t\t\t\t\tset_gtsignals(info);\n\t\t\t\t\tinfo->drop_rts_on_tx_done = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tslgt_irq_off(info, IRQ_TXDATA);\n\t\t\tslgt_irq_on(info, IRQ_TXUNDER + IRQ_TXIDLE);\n\t\t\t \n\t\t\twr_reg16(info, SSR, (unsigned short)(IRQ_TXIDLE + IRQ_TXUNDER));\n\t\t} else {\n\t\t\tslgt_irq_off(info, IRQ_TXDATA);\n\t\t\tslgt_irq_on(info, IRQ_TXIDLE);\n\t\t\t \n\t\t\twr_reg16(info, SSR, IRQ_TXIDLE);\n\t\t}\n\t\t \n\t\twr_reg32(info, TDDAR, info->tbufs[info->tbuf_start].pdesc);\n\t\twr_reg32(info, TDCSR, BIT2 + BIT0);\n\t\tinfo->tx_active = true;\n\t}\n}\n\nstatic void tx_stop(struct slgt_info *info)\n{\n\tunsigned short val;\n\n\tdel_timer(&info->tx_timer);\n\n\ttdma_reset(info);\n\n\t \n\tval = rd_reg16(info, TCR) & ~BIT1;           \n\twr_reg16(info, TCR, (unsigned short)(val | BIT2));  \n\n\tslgt_irq_off(info, IRQ_TXDATA + IRQ_TXIDLE + IRQ_TXUNDER);\n\n\t \n\twr_reg16(info, SSR, (unsigned short)(IRQ_TXIDLE + IRQ_TXUNDER));\n\n\treset_tbufs(info);\n\n\tinfo->tx_enabled = false;\n\tinfo->tx_active = false;\n}\n\nstatic void reset_port(struct slgt_info *info)\n{\n\tif (!info->reg_addr)\n\t\treturn;\n\n\ttx_stop(info);\n\trx_stop(info);\n\n\tinfo->signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\n\tset_gtsignals(info);\n\n\tslgt_irq_off(info, IRQ_ALL | IRQ_MASTER);\n}\n\nstatic void reset_adapter(struct slgt_info *info)\n{\n\tint i;\n\tfor (i=0; i < info->port_count; ++i) {\n\t\tif (info->port_array[i])\n\t\t\treset_port(info->port_array[i]);\n\t}\n}\n\nstatic void async_mode(struct slgt_info *info)\n{\n  \tunsigned short val;\n\n\tslgt_irq_off(info, IRQ_ALL | IRQ_MASTER);\n\ttx_stop(info);\n\trx_stop(info);\n\n\t \n\tval = 0x4000;\n\n\tif (info->if_mode & MGSL_INTERFACE_RTS_EN)\n\t\tval |= BIT7;\n\n\tif (info->params.parity != ASYNC_PARITY_NONE) {\n\t\tval |= BIT9;\n\t\tif (info->params.parity == ASYNC_PARITY_ODD)\n\t\t\tval |= BIT8;\n\t}\n\n\tswitch (info->params.data_bits)\n\t{\n\tcase 6: val |= BIT4; break;\n\tcase 7: val |= BIT5; break;\n\tcase 8: val |= BIT5 + BIT4; break;\n\t}\n\n\tif (info->params.stop_bits != 1)\n\t\tval |= BIT3;\n\n\tif (info->params.flags & HDLC_FLAG_AUTO_CTS)\n\t\tval |= BIT0;\n\n\twr_reg16(info, TCR, val);\n\n\t \n\tval = 0x4000;\n\n\tif (info->params.parity != ASYNC_PARITY_NONE) {\n\t\tval |= BIT9;\n\t\tif (info->params.parity == ASYNC_PARITY_ODD)\n\t\t\tval |= BIT8;\n\t}\n\n\tswitch (info->params.data_bits)\n\t{\n\tcase 6: val |= BIT4; break;\n\tcase 7: val |= BIT5; break;\n\tcase 8: val |= BIT5 + BIT4; break;\n\t}\n\n\tif (info->params.flags & HDLC_FLAG_AUTO_DCD)\n\t\tval |= BIT0;\n\n\twr_reg16(info, RCR, val);\n\n\t \n\twr_reg8(info, CCR, 0x69);\n\n\tmsc_set_vcr(info);\n\n\t \n\tval = BIT15 + BIT14 + BIT0;\n\t \n\tif ((rd_reg32(info, JCR) & BIT8) && info->params.data_rate &&\n\t    ((info->base_clock < (info->params.data_rate * 16)) ||\n\t     (info->base_clock % (info->params.data_rate * 16)))) {\n\t\t \n\t\tval |= BIT3;\n\t\tset_rate(info, info->params.data_rate * 8);\n\t} else {\n\t\t \n\t\tset_rate(info, info->params.data_rate * 16);\n\t}\n\twr_reg16(info, SCR, val);\n\n\tslgt_irq_on(info, IRQ_RXBREAK | IRQ_RXOVER);\n\n\tif (info->params.loopback)\n\t\tenable_loopback(info);\n}\n\nstatic void sync_mode(struct slgt_info *info)\n{\n\tunsigned short val;\n\n\tslgt_irq_off(info, IRQ_ALL | IRQ_MASTER);\n\ttx_stop(info);\n\trx_stop(info);\n\n\t \n\tval = BIT2;\n\n\tswitch(info->params.mode) {\n\tcase MGSL_MODE_XSYNC:\n\t\tval |= BIT15 + BIT13;\n\t\tbreak;\n\tcase MGSL_MODE_MONOSYNC: val |= BIT14 + BIT13; break;\n\tcase MGSL_MODE_BISYNC:   val |= BIT15; break;\n\tcase MGSL_MODE_RAW:      val |= BIT13; break;\n\t}\n\tif (info->if_mode & MGSL_INTERFACE_RTS_EN)\n\t\tval |= BIT7;\n\n\tswitch(info->params.encoding)\n\t{\n\tcase HDLC_ENCODING_NRZB:          val |= BIT10; break;\n\tcase HDLC_ENCODING_NRZI_MARK:     val |= BIT11; break;\n\tcase HDLC_ENCODING_NRZI:          val |= BIT11 + BIT10; break;\n\tcase HDLC_ENCODING_BIPHASE_MARK:  val |= BIT12; break;\n\tcase HDLC_ENCODING_BIPHASE_SPACE: val |= BIT12 + BIT10; break;\n\tcase HDLC_ENCODING_BIPHASE_LEVEL: val |= BIT12 + BIT11; break;\n\tcase HDLC_ENCODING_DIFF_BIPHASE_LEVEL: val |= BIT12 + BIT11 + BIT10; break;\n\t}\n\n\tswitch (info->params.crc_type & HDLC_CRC_MASK)\n\t{\n\tcase HDLC_CRC_16_CCITT: val |= BIT9; break;\n\tcase HDLC_CRC_32_CCITT: val |= BIT9 + BIT8; break;\n\t}\n\n\tif (info->params.preamble != HDLC_PREAMBLE_PATTERN_NONE)\n\t\tval |= BIT6;\n\n\tswitch (info->params.preamble_length)\n\t{\n\tcase HDLC_PREAMBLE_LENGTH_16BITS: val |= BIT5; break;\n\tcase HDLC_PREAMBLE_LENGTH_32BITS: val |= BIT4; break;\n\tcase HDLC_PREAMBLE_LENGTH_64BITS: val |= BIT5 + BIT4; break;\n\t}\n\n\tif (info->params.flags & HDLC_FLAG_AUTO_CTS)\n\t\tval |= BIT0;\n\n\twr_reg16(info, TCR, val);\n\n\t \n\n\tswitch (info->params.preamble)\n\t{\n\tcase HDLC_PREAMBLE_PATTERN_FLAGS: val = 0x7e; break;\n\tcase HDLC_PREAMBLE_PATTERN_ONES:  val = 0xff; break;\n\tcase HDLC_PREAMBLE_PATTERN_ZEROS: val = 0x00; break;\n\tcase HDLC_PREAMBLE_PATTERN_10:    val = 0x55; break;\n\tcase HDLC_PREAMBLE_PATTERN_01:    val = 0xaa; break;\n\tdefault:                          val = 0x7e; break;\n\t}\n\twr_reg8(info, TPR, (unsigned char)val);\n\n\t \n\tval = 0;\n\n\tswitch(info->params.mode) {\n\tcase MGSL_MODE_XSYNC:\n\t\tval |= BIT15 + BIT13;\n\t\tbreak;\n\tcase MGSL_MODE_MONOSYNC: val |= BIT14 + BIT13; break;\n\tcase MGSL_MODE_BISYNC:   val |= BIT15; break;\n\tcase MGSL_MODE_RAW:      val |= BIT13; break;\n\t}\n\n\tswitch(info->params.encoding)\n\t{\n\tcase HDLC_ENCODING_NRZB:          val |= BIT10; break;\n\tcase HDLC_ENCODING_NRZI_MARK:     val |= BIT11; break;\n\tcase HDLC_ENCODING_NRZI:          val |= BIT11 + BIT10; break;\n\tcase HDLC_ENCODING_BIPHASE_MARK:  val |= BIT12; break;\n\tcase HDLC_ENCODING_BIPHASE_SPACE: val |= BIT12 + BIT10; break;\n\tcase HDLC_ENCODING_BIPHASE_LEVEL: val |= BIT12 + BIT11; break;\n\tcase HDLC_ENCODING_DIFF_BIPHASE_LEVEL: val |= BIT12 + BIT11 + BIT10; break;\n\t}\n\n\tswitch (info->params.crc_type & HDLC_CRC_MASK)\n\t{\n\tcase HDLC_CRC_16_CCITT: val |= BIT9; break;\n\tcase HDLC_CRC_32_CCITT: val |= BIT9 + BIT8; break;\n\t}\n\n\tif (info->params.flags & HDLC_FLAG_AUTO_DCD)\n\t\tval |= BIT0;\n\n\twr_reg16(info, RCR, val);\n\n\t \n\tval = 0;\n\n\tif (info->params.flags & HDLC_FLAG_TXC_BRG)\n\t{\n\t\t \n\t\t \n\t\t \n\t\tif (info->params.flags & HDLC_FLAG_RXC_DPLL)\n\t\t\tval |= BIT6 + BIT5;\t \n\t\telse\n\t\t\tval |= BIT6;\t \n\t}\n\telse if (info->params.flags & HDLC_FLAG_TXC_DPLL)\n\t\tval |= BIT7;\t \n\telse if (info->params.flags & HDLC_FLAG_TXC_RXCPIN)\n\t\tval |= BIT5;\t \n\n\tif (info->params.flags & HDLC_FLAG_RXC_BRG)\n\t\tval |= BIT3;\t \n\telse if (info->params.flags & HDLC_FLAG_RXC_DPLL)\n\t\tval |= BIT4;\t \n\telse if (info->params.flags & HDLC_FLAG_RXC_TXCPIN)\n\t\tval |= BIT2;\t \n\n\tif (info->params.clock_speed)\n\t\tval |= BIT1 + BIT0;\n\n\twr_reg8(info, CCR, (unsigned char)val);\n\n\tif (info->params.flags & (HDLC_FLAG_TXC_DPLL + HDLC_FLAG_RXC_DPLL))\n\t{\n\t\t \n\t\tswitch(info->params.encoding)\n\t\t{\n\t\tcase HDLC_ENCODING_BIPHASE_MARK:\n\t\tcase HDLC_ENCODING_BIPHASE_SPACE:\n\t\t\tval = BIT7; break;\n\t\tcase HDLC_ENCODING_BIPHASE_LEVEL:\n\t\tcase HDLC_ENCODING_DIFF_BIPHASE_LEVEL:\n\t\t\tval = BIT7 + BIT6; break;\n\t\tdefault: val = BIT6;\t \n\t\t}\n\t\twr_reg16(info, RCR, (unsigned short)(rd_reg16(info, RCR) | val));\n\n\t\t \n\t\tset_rate(info, info->params.clock_speed * 16);\n\t}\n\telse\n\t\tset_rate(info, info->params.clock_speed);\n\n\ttx_set_idle(info);\n\n\tmsc_set_vcr(info);\n\n\t \n\twr_reg16(info, SCR, BIT15 + BIT14 + BIT0);\n\n\tif (info->params.loopback)\n\t\tenable_loopback(info);\n}\n\n \nstatic void tx_set_idle(struct slgt_info *info)\n{\n\tunsigned char val;\n\tunsigned short tcr;\n\n\t \n\ttcr = rd_reg16(info, TCR);\n\tif (info->idle_mode & HDLC_TXIDLE_CUSTOM_16) {\n\t\t \n\t\ttcr = (tcr & ~(BIT6 + BIT5)) | BIT4;\n\t\t \n\t\twr_reg8(info, TPR, (unsigned char)((info->idle_mode >> 8) & 0xff));\n\t} else if (!(tcr & BIT6)) {\n\t\t \n\t\ttcr &= ~(BIT5 + BIT4);\n\t}\n\twr_reg16(info, TCR, tcr);\n\n\tif (info->idle_mode & (HDLC_TXIDLE_CUSTOM_8 | HDLC_TXIDLE_CUSTOM_16)) {\n\t\t \n\t\tval = (unsigned char)(info->idle_mode & 0xff);\n\t} else {\n\t\t \n\t\tswitch(info->idle_mode)\n\t\t{\n\t\tcase HDLC_TXIDLE_FLAGS:          val = 0x7e; break;\n\t\tcase HDLC_TXIDLE_ALT_ZEROS_ONES:\n\t\tcase HDLC_TXIDLE_ALT_MARK_SPACE: val = 0xaa; break;\n\t\tcase HDLC_TXIDLE_ZEROS:\n\t\tcase HDLC_TXIDLE_SPACE:          val = 0x00; break;\n\t\tdefault:                         val = 0xff;\n\t\t}\n\t}\n\n\twr_reg8(info, TIR, val);\n}\n\n \nstatic void get_gtsignals(struct slgt_info *info)\n{\n\tunsigned short status = rd_reg16(info, SSR);\n\n\t \n\tinfo->signals &= SerialSignal_RTS | SerialSignal_DTR;\n\n\tif (status & BIT3)\n\t\tinfo->signals |= SerialSignal_DSR;\n\tif (status & BIT2)\n\t\tinfo->signals |= SerialSignal_CTS;\n\tif (status & BIT1)\n\t\tinfo->signals |= SerialSignal_DCD;\n\tif (status & BIT0)\n\t\tinfo->signals |= SerialSignal_RI;\n}\n\n \nstatic void msc_set_vcr(struct slgt_info *info)\n{\n\tunsigned char val = 0;\n\n\t \n\n\tswitch(info->if_mode & MGSL_INTERFACE_MASK)\n\t{\n\tcase MGSL_INTERFACE_RS232:\n\t\tval |= BIT5;  \n\t\tbreak;\n\tcase MGSL_INTERFACE_V35:\n\t\tval |= BIT7 + BIT6 + BIT5;  \n\t\tbreak;\n\tcase MGSL_INTERFACE_RS422:\n\t\tval |= BIT6;  \n\t\tbreak;\n\t}\n\n\tif (info->if_mode & MGSL_INTERFACE_MSB_FIRST)\n\t\tval |= BIT4;\n\tif (info->signals & SerialSignal_DTR)\n\t\tval |= BIT3;\n\tif (info->signals & SerialSignal_RTS)\n\t\tval |= BIT2;\n\tif (info->if_mode & MGSL_INTERFACE_LL)\n\t\tval |= BIT1;\n\tif (info->if_mode & MGSL_INTERFACE_RL)\n\t\tval |= BIT0;\n\twr_reg8(info, VCR, val);\n}\n\n \nstatic void set_gtsignals(struct slgt_info *info)\n{\n\tunsigned char val = rd_reg8(info, VCR);\n\tif (info->signals & SerialSignal_DTR)\n\t\tval |= BIT3;\n\telse\n\t\tval &= ~BIT3;\n\tif (info->signals & SerialSignal_RTS)\n\t\tval |= BIT2;\n\telse\n\t\tval &= ~BIT2;\n\twr_reg8(info, VCR, val);\n}\n\n \nstatic void free_rbufs(struct slgt_info *info, unsigned int i, unsigned int last)\n{\n\tint done = 0;\n\n\twhile(!done) {\n\t\t \n\t\tinfo->rbufs[i].status = 0;\n\t\tset_desc_count(info->rbufs[i], info->rbuf_fill_level);\n\t\tif (i == last)\n\t\t\tdone = 1;\n\t\tif (++i == info->rbuf_count)\n\t\t\ti = 0;\n\t}\n\tinfo->rbuf_current = i;\n}\n\n \nstatic void reset_rbufs(struct slgt_info *info)\n{\n\tfree_rbufs(info, 0, info->rbuf_count - 1);\n\tinfo->rbuf_fill_index = 0;\n\tinfo->rbuf_fill_count = 0;\n}\n\n \nstatic bool rx_get_frame(struct slgt_info *info)\n{\n\tunsigned int start, end;\n\tunsigned short status;\n\tunsigned int framesize = 0;\n\tunsigned long flags;\n\tstruct tty_struct *tty = info->port.tty;\n\tunsigned char addr_field = 0xff;\n\tunsigned int crc_size = 0;\n\n\tswitch (info->params.crc_type & HDLC_CRC_MASK) {\n\tcase HDLC_CRC_16_CCITT: crc_size = 2; break;\n\tcase HDLC_CRC_32_CCITT: crc_size = 4; break;\n\t}\n\ncheck_again:\n\n\tframesize = 0;\n\taddr_field = 0xff;\n\tstart = end = info->rbuf_current;\n\n\tfor (;;) {\n\t\tif (!desc_complete(info->rbufs[end]))\n\t\t\tgoto cleanup;\n\n\t\tif (framesize == 0 && info->params.addr_filter != 0xff)\n\t\t\taddr_field = info->rbufs[end].buf[0];\n\n\t\tframesize += desc_count(info->rbufs[end]);\n\n\t\tif (desc_eof(info->rbufs[end]))\n\t\t\tbreak;\n\n\t\tif (++end == info->rbuf_count)\n\t\t\tend = 0;\n\n\t\tif (end == info->rbuf_current) {\n\t\t\tif (info->rx_enabled){\n\t\t\t\tspin_lock_irqsave(&info->lock,flags);\n\t\t\t\trx_start(info);\n\t\t\t\tspin_unlock_irqrestore(&info->lock,flags);\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tstatus = desc_status(info->rbufs[end]);\n\n\t \n\tif ((info->params.crc_type & HDLC_CRC_MASK) == HDLC_CRC_NONE)\n\t\tstatus &= ~BIT1;\n\n\tif (framesize == 0 ||\n\t\t (addr_field != 0xff && addr_field != info->params.addr_filter)) {\n\t\tfree_rbufs(info, start, end);\n\t\tgoto check_again;\n\t}\n\n\tif (framesize < (2 + crc_size) || status & BIT0) {\n\t\tinfo->icount.rxshort++;\n\t\tframesize = 0;\n\t} else if (status & BIT1) {\n\t\tinfo->icount.rxcrc++;\n\t\tif (!(info->params.crc_type & HDLC_CRC_RETURN_EX))\n\t\t\tframesize = 0;\n\t}\n\n#if SYNCLINK_GENERIC_HDLC\n\tif (framesize == 0) {\n\t\tinfo->netdev->stats.rx_errors++;\n\t\tinfo->netdev->stats.rx_frame_errors++;\n\t}\n#endif\n\n\tDBGBH((\"%s rx frame status=%04X size=%d\\n\",\n\t\tinfo->device_name, status, framesize));\n\tDBGDATA(info, info->rbufs[start].buf, min_t(int, framesize, info->rbuf_fill_level), \"rx\");\n\n\tif (framesize) {\n\t\tif (!(info->params.crc_type & HDLC_CRC_RETURN_EX)) {\n\t\t\tframesize -= crc_size;\n\t\t\tcrc_size = 0;\n\t\t}\n\n\t\tif (framesize > info->max_frame_size + crc_size)\n\t\t\tinfo->icount.rxlong++;\n\t\telse {\n\t\t\t \n\t\t\tint copy_count = framesize;\n\t\t\tint i = start;\n\t\t\tunsigned char *p = info->tmp_rbuf;\n\t\t\tinfo->tmp_rbuf_count = framesize;\n\n\t\t\tinfo->icount.rxok++;\n\n\t\t\twhile(copy_count) {\n\t\t\t\tint partial_count = min_t(int, copy_count, info->rbuf_fill_level);\n\t\t\t\tmemcpy(p, info->rbufs[i].buf, partial_count);\n\t\t\t\tp += partial_count;\n\t\t\t\tcopy_count -= partial_count;\n\t\t\t\tif (++i == info->rbuf_count)\n\t\t\t\t\ti = 0;\n\t\t\t}\n\n\t\t\tif (info->params.crc_type & HDLC_CRC_RETURN_EX) {\n\t\t\t\t*p = (status & BIT1) ? RX_CRC_ERROR : RX_OK;\n\t\t\t\tframesize++;\n\t\t\t}\n\n#if SYNCLINK_GENERIC_HDLC\n\t\t\tif (info->netcount)\n\t\t\t\thdlcdev_rx(info,info->tmp_rbuf, framesize);\n\t\t\telse\n#endif\n\t\t\t\tldisc_receive_buf(tty, info->tmp_rbuf, NULL,\n\t\t\t\t\t\t  framesize);\n\t\t}\n\t}\n\tfree_rbufs(info, start, end);\n\treturn true;\n\ncleanup:\n\treturn false;\n}\n\n \nstatic bool rx_get_buf(struct slgt_info *info)\n{\n\tunsigned int i = info->rbuf_current;\n\tunsigned int count;\n\n\tif (!desc_complete(info->rbufs[i]))\n\t\treturn false;\n\tcount = desc_count(info->rbufs[i]);\n\tswitch(info->params.mode) {\n\tcase MGSL_MODE_MONOSYNC:\n\tcase MGSL_MODE_BISYNC:\n\tcase MGSL_MODE_XSYNC:\n\t\t \n\t\tif (desc_residue(info->rbufs[i]))\n\t\t\tcount--;\n\t\tbreak;\n\t}\n\tDBGDATA(info, info->rbufs[i].buf, count, \"rx\");\n\tDBGINFO((\"rx_get_buf size=%d\\n\", count));\n\tif (count)\n\t\tldisc_receive_buf(info->port.tty, info->rbufs[i].buf, NULL,\n\t\t\t\t  count);\n\tfree_rbufs(info, i, i);\n\treturn true;\n}\n\nstatic void reset_tbufs(struct slgt_info *info)\n{\n\tunsigned int i;\n\tinfo->tbuf_current = 0;\n\tfor (i=0 ; i < info->tbuf_count ; i++) {\n\t\tinfo->tbufs[i].status = 0;\n\t\tinfo->tbufs[i].count  = 0;\n\t}\n}\n\n \nstatic unsigned int free_tbuf_count(struct slgt_info *info)\n{\n\tunsigned int count = 0;\n\tunsigned int i = info->tbuf_current;\n\n\tdo\n\t{\n\t\tif (desc_count(info->tbufs[i]))\n\t\t\tbreak;  \n\t\t++count;\n\t\tif (++i == info->tbuf_count)\n\t\t\ti=0;\n\t} while (i != info->tbuf_current);\n\n\t \n\tif (count && (rd_reg32(info, TDCSR) & BIT0))\n\t\t--count;\n\n\treturn count;\n}\n\n \nstatic unsigned int tbuf_bytes(struct slgt_info *info)\n{\n\tunsigned int total_count = 0;\n\tunsigned int i = info->tbuf_current;\n\tunsigned int reg_value;\n\tunsigned int count;\n\tunsigned int active_buf_count = 0;\n\n\t \n\tdo {\n\t\tcount = desc_count(info->tbufs[i]);\n\t\tif (count)\n\t\t\ttotal_count += count;\n\t\telse if (!total_count)\n\t\t\tactive_buf_count = info->tbufs[i].buf_count;\n\t\tif (++i == info->tbuf_count)\n\t\t\ti = 0;\n\t} while (i != info->tbuf_current);\n\n\t \n\treg_value = rd_reg32(info, TDCSR);\n\n\t \n\tif (reg_value & BIT0)\n\t\ttotal_count += active_buf_count;\n\n\t \n\ttotal_count += (reg_value >> 8) & 0xff;\n\n\t \n\tif (info->tx_active)\n\t\ttotal_count++;\n\n\treturn total_count;\n}\n\n \nstatic bool tx_load(struct slgt_info *info, const u8 *buf, unsigned int size)\n{\n\tunsigned short count;\n\tunsigned int i;\n\tstruct slgt_desc *d;\n\n\t \n\tif (DIV_ROUND_UP(size, DMABUFSIZE) > free_tbuf_count(info))\n\t\treturn false;\n\n\tDBGDATA(info, buf, size, \"tx\");\n\n\t \n\n\tinfo->tbuf_start = i = info->tbuf_current;\n\n\twhile (size) {\n\t\td = &info->tbufs[i];\n\n\t\tcount = (unsigned short)((size > DMABUFSIZE) ? DMABUFSIZE : size);\n\t\tmemcpy(d->buf, buf, count);\n\n\t\tsize -= count;\n\t\tbuf  += count;\n\n\t\t \n\t\tif ((!size && info->params.mode == MGSL_MODE_HDLC) ||\n\t\t    info->params.mode == MGSL_MODE_RAW)\n\t\t\tset_desc_eof(*d, 1);\n\t\telse\n\t\t\tset_desc_eof(*d, 0);\n\n\t\t \n\t\tif (i != info->tbuf_start)\n\t\t\tset_desc_count(*d, count);\n\t\td->buf_count = count;\n\n\t\tif (++i == info->tbuf_count)\n\t\t\ti = 0;\n\t}\n\n\tinfo->tbuf_current = i;\n\n\t \n\td = &info->tbufs[info->tbuf_start];\n\tset_desc_count(*d, d->buf_count);\n\n\t \n\tif (!info->tx_active)\n\t\ttx_start(info);\n\tupdate_tx_timer(info);\n\n\treturn true;\n}\n\nstatic int register_test(struct slgt_info *info)\n{\n\tstatic unsigned short patterns[] =\n\t\t{0x0000, 0xffff, 0xaaaa, 0x5555, 0x6969, 0x9696};\n\tstatic unsigned int count = ARRAY_SIZE(patterns);\n\tunsigned int i;\n\tint rc = 0;\n\n\tfor (i=0 ; i < count ; i++) {\n\t\twr_reg16(info, TIR, patterns[i]);\n\t\twr_reg16(info, BDR, patterns[(i+1)%count]);\n\t\tif ((rd_reg16(info, TIR) != patterns[i]) ||\n\t\t    (rd_reg16(info, BDR) != patterns[(i+1)%count])) {\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t}\n\tinfo->gpio_present = (rd_reg32(info, JCR) & BIT5) ? 1 : 0;\n\tinfo->init_error = rc ? 0 : DiagStatus_AddressFailure;\n\treturn rc;\n}\n\nstatic int irq_test(struct slgt_info *info)\n{\n\tunsigned long timeout;\n\tunsigned long flags;\n\tstruct tty_struct *oldtty = info->port.tty;\n\tu32 speed = info->params.data_rate;\n\n\tinfo->params.data_rate = 921600;\n\tinfo->port.tty = NULL;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tasync_mode(info);\n\tslgt_irq_on(info, IRQ_TXIDLE);\n\n\t \n\twr_reg16(info, TCR,\n\t\t(unsigned short)(rd_reg16(info, TCR) | BIT1));\n\n\t \n\twr_reg16(info, TDR, 0);\n\n\t \n\tinfo->init_error = DiagStatus_IrqFailure;\n\tinfo->irq_occurred = false;\n\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\ttimeout=100;\n\twhile(timeout-- && !info->irq_occurred)\n\t\tmsleep_interruptible(10);\n\n\tspin_lock_irqsave(&info->lock,flags);\n\treset_port(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n\tinfo->params.data_rate = speed;\n\tinfo->port.tty = oldtty;\n\n\tinfo->init_error = info->irq_occurred ? 0 : DiagStatus_IrqFailure;\n\treturn info->irq_occurred ? 0 : -ENODEV;\n}\n\nstatic int loopback_test_rx(struct slgt_info *info)\n{\n\tunsigned char *src, *dest;\n\tint count;\n\n\tif (desc_complete(info->rbufs[0])) {\n\t\tcount = desc_count(info->rbufs[0]);\n\t\tsrc   = info->rbufs[0].buf;\n\t\tdest  = info->tmp_rbuf;\n\n\t\tfor( ; count ; count-=2, src+=2) {\n\t\t\t \n\t\t\tif (!(*(src+1) & (BIT9 + BIT8))) {\n\t\t\t\t*dest = *src;\n\t\t\t\tdest++;\n\t\t\t\tinfo->tmp_rbuf_count++;\n\t\t\t}\n\t\t}\n\t\tDBGDATA(info, info->tmp_rbuf, info->tmp_rbuf_count, \"rx\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int loopback_test(struct slgt_info *info)\n{\n#define TESTFRAMESIZE 20\n\n\tunsigned long timeout;\n\tu16 count;\n\tunsigned char buf[TESTFRAMESIZE];\n\tint rc = -ENODEV;\n\tunsigned long flags;\n\n\tstruct tty_struct *oldtty = info->port.tty;\n\tMGSL_PARAMS params;\n\n\tmemcpy(&params, &info->params, sizeof(params));\n\n\tinfo->params.mode = MGSL_MODE_ASYNC;\n\tinfo->params.data_rate = 921600;\n\tinfo->params.loopback = 1;\n\tinfo->port.tty = NULL;\n\n\t \n\tfor (count = 0; count < TESTFRAMESIZE; ++count)\n\t\tbuf[count] = (unsigned char)count;\n\n\tinfo->tmp_rbuf_count = 0;\n\tmemset(info->tmp_rbuf, 0, TESTFRAMESIZE);\n\n\t \n\tspin_lock_irqsave(&info->lock,flags);\n\tasync_mode(info);\n\trx_start(info);\n\ttx_load(info, buf, count);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\t \n\tfor (timeout = 100; timeout; --timeout) {\n\t\tmsleep_interruptible(10);\n\t\tif (loopback_test_rx(info)) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!rc && (info->tmp_rbuf_count != count ||\n\t\t  memcmp(buf, info->tmp_rbuf, count))) {\n\t\trc = -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&info->lock,flags);\n\treset_adapter(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n\tmemcpy(&info->params, &params, sizeof(info->params));\n\tinfo->port.tty = oldtty;\n\n\tinfo->init_error = rc ? DiagStatus_DmaFailure : 0;\n\treturn rc;\n}\n\nstatic int adapter_test(struct slgt_info *info)\n{\n\tDBGINFO((\"testing %s\\n\", info->device_name));\n\tif (register_test(info) < 0) {\n\t\tprintk(\"register test failure %s addr=%08X\\n\",\n\t\t\tinfo->device_name, info->phys_reg_addr);\n\t} else if (irq_test(info) < 0) {\n\t\tprintk(\"IRQ test failure %s IRQ=%d\\n\",\n\t\t\tinfo->device_name, info->irq_level);\n\t} else if (loopback_test(info) < 0) {\n\t\tprintk(\"loopback test failure %s\\n\", info->device_name);\n\t}\n\treturn info->init_error;\n}\n\n \nstatic void tx_timeout(struct timer_list *t)\n{\n\tstruct slgt_info *info = from_timer(info, t, tx_timer);\n\tunsigned long flags;\n\n\tDBGINFO((\"%s tx_timeout\\n\", info->device_name));\n\tif(info->tx_active && info->params.mode == MGSL_MODE_HDLC) {\n\t\tinfo->icount.txtimeout++;\n\t}\n\tspin_lock_irqsave(&info->lock,flags);\n\ttx_stop(info);\n\tspin_unlock_irqrestore(&info->lock,flags);\n\n#if SYNCLINK_GENERIC_HDLC\n\tif (info->netcount)\n\t\thdlcdev_tx_done(info);\n\telse\n#endif\n\t\tbh_transmit(info);\n}\n\n \nstatic void rx_timeout(struct timer_list *t)\n{\n\tstruct slgt_info *info = from_timer(info, t, rx_timer);\n\tunsigned long flags;\n\n\tDBGINFO((\"%s rx_timeout\\n\", info->device_name));\n\tspin_lock_irqsave(&info->lock, flags);\n\tinfo->pending_bh |= BH_RECEIVE;\n\tspin_unlock_irqrestore(&info->lock, flags);\n\tbh_handler(&info->task);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}