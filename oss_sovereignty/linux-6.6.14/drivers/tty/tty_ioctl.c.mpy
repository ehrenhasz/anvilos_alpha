{
  "module_name": "tty_ioctl.c",
  "hash_id": "52a60c8d798d7fd211d4cdf5de77c5f89fa2d7f3bd2e7093c69bb7f95c57642a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/tty_ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/types.h>\n#include <linux/termios.h>\n#include <linux/errno.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/tty.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/termios_internal.h>\n#include \"tty.h\"\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#undef\tDEBUG\n\n \n#define TERMIOS_FLUSH\tBIT(0)\n#define TERMIOS_WAIT\tBIT(1)\n#define TERMIOS_TERMIO\tBIT(2)\n#define TERMIOS_OLD\tBIT(3)\n\n\n \n\nunsigned int tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tif (tty->ops->chars_in_buffer)\n\t\treturn tty->ops->chars_in_buffer(tty);\n\treturn 0;\n}\nEXPORT_SYMBOL(tty_chars_in_buffer);\n\n \n \nunsigned int tty_write_room(struct tty_struct *tty)\n{\n\tif (tty->ops->write_room)\n\t\treturn tty->ops->write_room(tty);\n\treturn 2048;\n}\nEXPORT_SYMBOL(tty_write_room);\n\n \nvoid tty_driver_flush_buffer(struct tty_struct *tty)\n{\n\tif (tty->ops->flush_buffer)\n\t\ttty->ops->flush_buffer(tty);\n}\nEXPORT_SYMBOL(tty_driver_flush_buffer);\n\n \n\nvoid tty_unthrottle(struct tty_struct *tty)\n{\n\tdown_write(&tty->termios_rwsem);\n\tif (test_and_clear_bit(TTY_THROTTLED, &tty->flags) &&\n\t    tty->ops->unthrottle)\n\t\ttty->ops->unthrottle(tty);\n\ttty->flow_change = 0;\n\tup_write(&tty->termios_rwsem);\n}\nEXPORT_SYMBOL(tty_unthrottle);\n\n \n\nint tty_throttle_safe(struct tty_struct *tty)\n{\n\tint ret = 0;\n\n\tmutex_lock(&tty->throttle_mutex);\n\tif (!tty_throttled(tty)) {\n\t\tif (tty->flow_change != TTY_THROTTLE_SAFE)\n\t\t\tret = 1;\n\t\telse {\n\t\t\tset_bit(TTY_THROTTLED, &tty->flags);\n\t\t\tif (tty->ops->throttle)\n\t\t\t\ttty->ops->throttle(tty);\n\t\t}\n\t}\n\tmutex_unlock(&tty->throttle_mutex);\n\n\treturn ret;\n}\n\n \n\nint tty_unthrottle_safe(struct tty_struct *tty)\n{\n\tint ret = 0;\n\n\tmutex_lock(&tty->throttle_mutex);\n\tif (tty_throttled(tty)) {\n\t\tif (tty->flow_change != TTY_UNTHROTTLE_SAFE)\n\t\t\tret = 1;\n\t\telse {\n\t\t\tclear_bit(TTY_THROTTLED, &tty->flags);\n\t\t\tif (tty->ops->unthrottle)\n\t\t\t\ttty->ops->unthrottle(tty);\n\t\t}\n\t}\n\tmutex_unlock(&tty->throttle_mutex);\n\n\treturn ret;\n}\n\n \n\nvoid tty_wait_until_sent(struct tty_struct *tty, long timeout)\n{\n\tif (!timeout)\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\n\ttimeout = wait_event_interruptible_timeout(tty->write_wait,\n\t\t\t!tty_chars_in_buffer(tty), timeout);\n\tif (timeout <= 0)\n\t\treturn;\n\n\tif (timeout == MAX_SCHEDULE_TIMEOUT)\n\t\ttimeout = 0;\n\n\tif (tty->ops->wait_until_sent)\n\t\ttty->ops->wait_until_sent(tty, timeout);\n}\nEXPORT_SYMBOL(tty_wait_until_sent);\n\n\n \n\nstatic void unset_locked_termios(struct tty_struct *tty, const struct ktermios *old)\n{\n\tstruct ktermios *termios = &tty->termios;\n\tstruct ktermios *locked  = &tty->termios_locked;\n\tint\ti;\n\n#define NOSET_MASK(x, y, z) (x = ((x) & ~(z)) | ((y) & (z)))\n\n\tNOSET_MASK(termios->c_iflag, old->c_iflag, locked->c_iflag);\n\tNOSET_MASK(termios->c_oflag, old->c_oflag, locked->c_oflag);\n\tNOSET_MASK(termios->c_cflag, old->c_cflag, locked->c_cflag);\n\tNOSET_MASK(termios->c_lflag, old->c_lflag, locked->c_lflag);\n\ttermios->c_line = locked->c_line ? old->c_line : termios->c_line;\n\tfor (i = 0; i < NCCS; i++)\n\t\ttermios->c_cc[i] = locked->c_cc[i] ?\n\t\t\told->c_cc[i] : termios->c_cc[i];\n\t \n}\n\n \n\nvoid tty_termios_copy_hw(struct ktermios *new, const struct ktermios *old)\n{\n\t \n\tnew->c_cflag &= HUPCL | CREAD | CLOCAL;\n\tnew->c_cflag |= old->c_cflag & ~(HUPCL | CREAD | CLOCAL);\n\tnew->c_ispeed = old->c_ispeed;\n\tnew->c_ospeed = old->c_ospeed;\n}\nEXPORT_SYMBOL(tty_termios_copy_hw);\n\n \n\nbool tty_termios_hw_change(const struct ktermios *a, const struct ktermios *b)\n{\n\tif (a->c_ispeed != b->c_ispeed || a->c_ospeed != b->c_ospeed)\n\t\treturn true;\n\tif ((a->c_cflag ^ b->c_cflag) & ~(HUPCL | CREAD | CLOCAL))\n\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL(tty_termios_hw_change);\n\n \nunsigned char tty_get_char_size(unsigned int cflag)\n{\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\treturn 5;\n\tcase CS6:\n\t\treturn 6;\n\tcase CS7:\n\t\treturn 7;\n\tcase CS8:\n\tdefault:\n\t\treturn 8;\n\t}\n}\nEXPORT_SYMBOL_GPL(tty_get_char_size);\n\n \nunsigned char tty_get_frame_size(unsigned int cflag)\n{\n\tunsigned char bits = 2 + tty_get_char_size(cflag);\n\n\tif (cflag & CSTOPB)\n\t\tbits++;\n\tif (cflag & PARENB)\n\t\tbits++;\n\tif (cflag & ADDRB)\n\t\tbits++;\n\n\treturn bits;\n}\nEXPORT_SYMBOL_GPL(tty_get_frame_size);\n\n \n\nint tty_set_termios(struct tty_struct *tty, struct ktermios *new_termios)\n{\n\tstruct ktermios old_termios;\n\tstruct tty_ldisc *ld;\n\n\tWARN_ON(tty->driver->type == TTY_DRIVER_TYPE_PTY &&\n\t\ttty->driver->subtype == PTY_TYPE_MASTER);\n\t \n\n\n\t \n\tdown_write(&tty->termios_rwsem);\n\told_termios = tty->termios;\n\ttty->termios = *new_termios;\n\tunset_locked_termios(tty, &old_termios);\n\t \n\ttty->termios.c_cflag ^= (tty->termios.c_cflag ^ old_termios.c_cflag) & ADDRB;\n\n\tif (tty->ops->set_termios)\n\t\ttty->ops->set_termios(tty, &old_termios);\n\telse\n\t\ttty_termios_copy_hw(&tty->termios, &old_termios);\n\n\tld = tty_ldisc_ref(tty);\n\tif (ld != NULL) {\n\t\tif (ld->ops->set_termios)\n\t\t\tld->ops->set_termios(tty, &old_termios);\n\t\ttty_ldisc_deref(ld);\n\t}\n\tup_write(&tty->termios_rwsem);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tty_set_termios);\n\n\n \n__weak int user_termio_to_kernel_termios(struct ktermios *termios,\n\t\t\t\t\t\tstruct termio __user *termio)\n{\n\tstruct termio v;\n\n\tif (copy_from_user(&v, termio, sizeof(struct termio)))\n\t\treturn -EFAULT;\n\n\ttermios->c_iflag = (0xffff0000 & termios->c_iflag) | v.c_iflag;\n\ttermios->c_oflag = (0xffff0000 & termios->c_oflag) | v.c_oflag;\n\ttermios->c_cflag = (0xffff0000 & termios->c_cflag) | v.c_cflag;\n\ttermios->c_lflag = (0xffff0000 & termios->c_lflag) | v.c_lflag;\n\ttermios->c_line = (0xffff0000 & termios->c_lflag) | v.c_line;\n\tmemcpy(termios->c_cc, v.c_cc, NCC);\n\treturn 0;\n}\n\n \n__weak int kernel_termios_to_user_termio(struct termio __user *termio,\n\t\t\t\t\t\tstruct ktermios *termios)\n{\n\tstruct termio v;\n\tmemset(&v, 0, sizeof(struct termio));\n\tv.c_iflag = termios->c_iflag;\n\tv.c_oflag = termios->c_oflag;\n\tv.c_cflag = termios->c_cflag;\n\tv.c_lflag = termios->c_lflag;\n\tv.c_line = termios->c_line;\n\tmemcpy(v.c_cc, termios->c_cc, NCC);\n\treturn copy_to_user(termio, &v, sizeof(struct termio));\n}\n\n#ifdef TCGETS2\n__weak int user_termios_to_kernel_termios(struct ktermios *k,\n\t\t\t\t\t\t struct termios2 __user *u)\n{\n\treturn copy_from_user(k, u, sizeof(struct termios2));\n}\n__weak int kernel_termios_to_user_termios(struct termios2 __user *u,\n\t\t\t\t\t\t struct ktermios *k)\n{\n\treturn copy_to_user(u, k, sizeof(struct termios2));\n}\n__weak int user_termios_to_kernel_termios_1(struct ktermios *k,\n\t\t\t\t\t\t   struct termios __user *u)\n{\n\treturn copy_from_user(k, u, sizeof(struct termios));\n}\n__weak int kernel_termios_to_user_termios_1(struct termios __user *u,\n\t\t\t\t\t\t   struct ktermios *k)\n{\n\treturn copy_to_user(u, k, sizeof(struct termios));\n}\n\n#else\n\n__weak int user_termios_to_kernel_termios(struct ktermios *k,\n\t\t\t\t\t\t struct termios __user *u)\n{\n\treturn copy_from_user(k, u, sizeof(struct termios));\n}\n__weak int kernel_termios_to_user_termios(struct termios __user *u,\n\t\t\t\t\t\t struct ktermios *k)\n{\n\treturn copy_to_user(u, k, sizeof(struct termios));\n}\n#endif  \n\n \n\nstatic int set_termios(struct tty_struct *tty, void __user *arg, int opt)\n{\n\tstruct ktermios tmp_termios;\n\tstruct tty_ldisc *ld;\n\tint retval = tty_check_change(tty);\n\n\tif (retval)\n\t\treturn retval;\n\n\tdown_read(&tty->termios_rwsem);\n\ttmp_termios = tty->termios;\n\tup_read(&tty->termios_rwsem);\n\n\tif (opt & TERMIOS_TERMIO) {\n\t\tif (user_termio_to_kernel_termios(&tmp_termios,\n\t\t\t\t\t\t(struct termio __user *)arg))\n\t\t\treturn -EFAULT;\n#ifdef TCGETS2\n\t} else if (opt & TERMIOS_OLD) {\n\t\tif (user_termios_to_kernel_termios_1(&tmp_termios,\n\t\t\t\t\t\t(struct termios __user *)arg))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (user_termios_to_kernel_termios(&tmp_termios,\n\t\t\t\t\t\t(struct termios2 __user *)arg))\n\t\t\treturn -EFAULT;\n\t}\n#else\n\t} else if (user_termios_to_kernel_termios(&tmp_termios,\n\t\t\t\t\t(struct termios __user *)arg))\n\t\treturn -EFAULT;\n#endif\n\n\t \n\ttmp_termios.c_ispeed = tty_termios_input_baud_rate(&tmp_termios);\n\ttmp_termios.c_ospeed = tty_termios_baud_rate(&tmp_termios);\n\n\tif (opt & (TERMIOS_FLUSH|TERMIOS_WAIT)) {\nretry_write_wait:\n\t\tretval = wait_event_interruptible(tty->write_wait, !tty_chars_in_buffer(tty));\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tif (tty_write_lock(tty, false) < 0)\n\t\t\tgoto retry_write_wait;\n\n\t\t \n\t\tif (tty_chars_in_buffer(tty)) {\n\t\t\ttty_write_unlock(tty);\n\t\t\tgoto retry_write_wait;\n\t\t}\n\n\t\tld = tty_ldisc_ref(tty);\n\t\tif (ld != NULL) {\n\t\t\tif ((opt & TERMIOS_FLUSH) && ld->ops->flush_buffer)\n\t\t\t\tld->ops->flush_buffer(tty);\n\t\t\ttty_ldisc_deref(ld);\n\t\t}\n\n\t\tif ((opt & TERMIOS_WAIT) && tty->ops->wait_until_sent) {\n\t\t\ttty->ops->wait_until_sent(tty, 0);\n\t\t\tif (signal_pending(current)) {\n\t\t\t\ttty_write_unlock(tty);\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\t}\n\t\t}\n\n\t\ttty_set_termios(tty, &tmp_termios);\n\n\t\ttty_write_unlock(tty);\n\t} else {\n\t\ttty_set_termios(tty, &tmp_termios);\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic void copy_termios(struct tty_struct *tty, struct ktermios *kterm)\n{\n\tdown_read(&tty->termios_rwsem);\n\t*kterm = tty->termios;\n\tup_read(&tty->termios_rwsem);\n}\n\nstatic void copy_termios_locked(struct tty_struct *tty, struct ktermios *kterm)\n{\n\tdown_read(&tty->termios_rwsem);\n\t*kterm = tty->termios_locked;\n\tup_read(&tty->termios_rwsem);\n}\n\nstatic int get_termio(struct tty_struct *tty, struct termio __user *termio)\n{\n\tstruct ktermios kterm;\n\tcopy_termios(tty, &kterm);\n\tif (kernel_termios_to_user_termio(termio, &kterm))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#ifdef TIOCGETP\n \nstatic int get_sgflags(struct tty_struct *tty)\n{\n\tint flags = 0;\n\n\tif (!L_ICANON(tty)) {\n\t\tif (L_ISIG(tty))\n\t\t\tflags |= 0x02;\t\t \n\t\telse\n\t\t\tflags |= 0x20;\t\t \n\t}\n\tif (L_ECHO(tty))\n\t\tflags |= 0x08;\t\t\t \n\tif (O_OPOST(tty))\n\t\tif (O_ONLCR(tty))\n\t\t\tflags |= 0x10;\t\t \n\treturn flags;\n}\n\nstatic int get_sgttyb(struct tty_struct *tty, struct sgttyb __user *sgttyb)\n{\n\tstruct sgttyb tmp;\n\n\tdown_read(&tty->termios_rwsem);\n\ttmp.sg_ispeed = tty->termios.c_ispeed;\n\ttmp.sg_ospeed = tty->termios.c_ospeed;\n\ttmp.sg_erase = tty->termios.c_cc[VERASE];\n\ttmp.sg_kill = tty->termios.c_cc[VKILL];\n\ttmp.sg_flags = get_sgflags(tty);\n\tup_read(&tty->termios_rwsem);\n\n\treturn copy_to_user(sgttyb, &tmp, sizeof(tmp)) ? -EFAULT : 0;\n}\n\nstatic void set_sgflags(struct ktermios *termios, int flags)\n{\n\ttermios->c_iflag = ICRNL | IXON;\n\ttermios->c_oflag = 0;\n\ttermios->c_lflag = ISIG | ICANON;\n\tif (flags & 0x02) {\t \n\t\ttermios->c_iflag = 0;\n\t\ttermios->c_lflag &= ~ICANON;\n\t}\n\tif (flags & 0x08) {\t\t \n\t\ttermios->c_lflag |= ECHO | ECHOE | ECHOK |\n\t\t\t\t    ECHOCTL | ECHOKE | IEXTEN;\n\t}\n\tif (flags & 0x10) {\t\t \n\t\ttermios->c_oflag |= OPOST | ONLCR;\n\t}\n\tif (flags & 0x20) {\t \n\t\ttermios->c_iflag = 0;\n\t\ttermios->c_lflag &= ~(ISIG | ICANON);\n\t}\n\tif (!(termios->c_lflag & ICANON)) {\n\t\ttermios->c_cc[VMIN] = 1;\n\t\ttermios->c_cc[VTIME] = 0;\n\t}\n}\n\n \n\nstatic int set_sgttyb(struct tty_struct *tty, struct sgttyb __user *sgttyb)\n{\n\tint retval;\n\tstruct sgttyb tmp;\n\tstruct ktermios termios;\n\n\tretval = tty_check_change(tty);\n\tif (retval)\n\t\treturn retval;\n\n\tif (copy_from_user(&tmp, sgttyb, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tdown_write(&tty->termios_rwsem);\n\ttermios = tty->termios;\n\ttermios.c_cc[VERASE] = tmp.sg_erase;\n\ttermios.c_cc[VKILL] = tmp.sg_kill;\n\tset_sgflags(&termios, tmp.sg_flags);\n\t \n\ttty_termios_encode_baud_rate(&termios, termios.c_ispeed,\n\t\t\t\t\t\ttermios.c_ospeed);\n\tup_write(&tty->termios_rwsem);\n\ttty_set_termios(tty, &termios);\n\treturn 0;\n}\n#endif\n\n#ifdef TIOCGETC\nstatic int get_tchars(struct tty_struct *tty, struct tchars __user *tchars)\n{\n\tstruct tchars tmp;\n\n\tdown_read(&tty->termios_rwsem);\n\ttmp.t_intrc = tty->termios.c_cc[VINTR];\n\ttmp.t_quitc = tty->termios.c_cc[VQUIT];\n\ttmp.t_startc = tty->termios.c_cc[VSTART];\n\ttmp.t_stopc = tty->termios.c_cc[VSTOP];\n\ttmp.t_eofc = tty->termios.c_cc[VEOF];\n\ttmp.t_brkc = tty->termios.c_cc[VEOL2];\t \n\tup_read(&tty->termios_rwsem);\n\treturn copy_to_user(tchars, &tmp, sizeof(tmp)) ? -EFAULT : 0;\n}\n\nstatic int set_tchars(struct tty_struct *tty, struct tchars __user *tchars)\n{\n\tstruct tchars tmp;\n\n\tif (copy_from_user(&tmp, tchars, sizeof(tmp)))\n\t\treturn -EFAULT;\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_cc[VINTR] = tmp.t_intrc;\n\ttty->termios.c_cc[VQUIT] = tmp.t_quitc;\n\ttty->termios.c_cc[VSTART] = tmp.t_startc;\n\ttty->termios.c_cc[VSTOP] = tmp.t_stopc;\n\ttty->termios.c_cc[VEOF] = tmp.t_eofc;\n\ttty->termios.c_cc[VEOL2] = tmp.t_brkc;\t \n\tup_write(&tty->termios_rwsem);\n\treturn 0;\n}\n#endif\n\n#ifdef TIOCGLTC\nstatic int get_ltchars(struct tty_struct *tty, struct ltchars __user *ltchars)\n{\n\tstruct ltchars tmp;\n\n\tdown_read(&tty->termios_rwsem);\n\ttmp.t_suspc = tty->termios.c_cc[VSUSP];\n\t \n\ttmp.t_dsuspc = tty->termios.c_cc[VSUSP];\n\ttmp.t_rprntc = tty->termios.c_cc[VREPRINT];\n\t \n\ttmp.t_flushc = tty->termios.c_cc[VEOL2];\n\ttmp.t_werasc = tty->termios.c_cc[VWERASE];\n\ttmp.t_lnextc = tty->termios.c_cc[VLNEXT];\n\tup_read(&tty->termios_rwsem);\n\treturn copy_to_user(ltchars, &tmp, sizeof(tmp)) ? -EFAULT : 0;\n}\n\nstatic int set_ltchars(struct tty_struct *tty, struct ltchars __user *ltchars)\n{\n\tstruct ltchars tmp;\n\n\tif (copy_from_user(&tmp, ltchars, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_cc[VSUSP] = tmp.t_suspc;\n\t \n\ttty->termios.c_cc[VEOL2] = tmp.t_dsuspc;\n\ttty->termios.c_cc[VREPRINT] = tmp.t_rprntc;\n\t \n\ttty->termios.c_cc[VEOL2] = tmp.t_flushc;\n\ttty->termios.c_cc[VWERASE] = tmp.t_werasc;\n\ttty->termios.c_cc[VLNEXT] = tmp.t_lnextc;\n\tup_write(&tty->termios_rwsem);\n\treturn 0;\n}\n#endif\n\n \n\nstatic int tty_change_softcar(struct tty_struct *tty, bool enable)\n{\n\tint ret = 0;\n\tstruct ktermios old;\n\ttcflag_t bit = enable ? CLOCAL : 0;\n\n\tdown_write(&tty->termios_rwsem);\n\told = tty->termios;\n\ttty->termios.c_cflag &= ~CLOCAL;\n\ttty->termios.c_cflag |= bit;\n\tif (tty->ops->set_termios)\n\t\ttty->ops->set_termios(tty, &old);\n\tif (C_CLOCAL(tty) != bit)\n\t\tret = -EINVAL;\n\tup_write(&tty->termios_rwsem);\n\treturn ret;\n}\n\n \n\nint tty_mode_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)\n{\n\tstruct tty_struct *real_tty;\n\tvoid __user *p = (void __user *)arg;\n\tint ret = 0;\n\tstruct ktermios kterm;\n\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\n\t    tty->driver->subtype == PTY_TYPE_MASTER)\n\t\treal_tty = tty->link;\n\telse\n\t\treal_tty = tty;\n\n\tswitch (cmd) {\n#ifdef TIOCGETP\n\tcase TIOCGETP:\n\t\treturn get_sgttyb(real_tty, (struct sgttyb __user *) arg);\n\tcase TIOCSETP:\n\tcase TIOCSETN:\n\t\treturn set_sgttyb(real_tty, (struct sgttyb __user *) arg);\n#endif\n#ifdef TIOCGETC\n\tcase TIOCGETC:\n\t\treturn get_tchars(real_tty, p);\n\tcase TIOCSETC:\n\t\treturn set_tchars(real_tty, p);\n#endif\n#ifdef TIOCGLTC\n\tcase TIOCGLTC:\n\t\treturn get_ltchars(real_tty, p);\n\tcase TIOCSLTC:\n\t\treturn set_ltchars(real_tty, p);\n#endif\n\tcase TCSETSF:\n\t\treturn set_termios(real_tty, p,  TERMIOS_FLUSH | TERMIOS_WAIT | TERMIOS_OLD);\n\tcase TCSETSW:\n\t\treturn set_termios(real_tty, p, TERMIOS_WAIT | TERMIOS_OLD);\n\tcase TCSETS:\n\t\treturn set_termios(real_tty, p, TERMIOS_OLD);\n#ifndef TCGETS2\n\tcase TCGETS:\n\t\tcopy_termios(real_tty, &kterm);\n\t\tif (kernel_termios_to_user_termios((struct termios __user *)arg, &kterm))\n\t\t\tret = -EFAULT;\n\t\treturn ret;\n#else\n\tcase TCGETS:\n\t\tcopy_termios(real_tty, &kterm);\n\t\tif (kernel_termios_to_user_termios_1((struct termios __user *)arg, &kterm))\n\t\t\tret = -EFAULT;\n\t\treturn ret;\n\tcase TCGETS2:\n\t\tcopy_termios(real_tty, &kterm);\n\t\tif (kernel_termios_to_user_termios((struct termios2 __user *)arg, &kterm))\n\t\t\tret = -EFAULT;\n\t\treturn ret;\n\tcase TCSETSF2:\n\t\treturn set_termios(real_tty, p,  TERMIOS_FLUSH | TERMIOS_WAIT);\n\tcase TCSETSW2:\n\t\treturn set_termios(real_tty, p, TERMIOS_WAIT);\n\tcase TCSETS2:\n\t\treturn set_termios(real_tty, p, 0);\n#endif\n\tcase TCGETA:\n\t\treturn get_termio(real_tty, p);\n\tcase TCSETAF:\n\t\treturn set_termios(real_tty, p, TERMIOS_FLUSH | TERMIOS_WAIT | TERMIOS_TERMIO);\n\tcase TCSETAW:\n\t\treturn set_termios(real_tty, p, TERMIOS_WAIT | TERMIOS_TERMIO);\n\tcase TCSETA:\n\t\treturn set_termios(real_tty, p, TERMIOS_TERMIO);\n#ifndef TCGETS2\n\tcase TIOCGLCKTRMIOS:\n\t\tcopy_termios_locked(real_tty, &kterm);\n\t\tif (kernel_termios_to_user_termios((struct termios __user *)arg, &kterm))\n\t\t\tret = -EFAULT;\n\t\treturn ret;\n\tcase TIOCSLCKTRMIOS:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tcopy_termios_locked(real_tty, &kterm);\n\t\tif (user_termios_to_kernel_termios(&kterm,\n\t\t\t\t\t       (struct termios __user *) arg))\n\t\t\treturn -EFAULT;\n\t\tdown_write(&real_tty->termios_rwsem);\n\t\treal_tty->termios_locked = kterm;\n\t\tup_write(&real_tty->termios_rwsem);\n\t\treturn 0;\n#else\n\tcase TIOCGLCKTRMIOS:\n\t\tcopy_termios_locked(real_tty, &kterm);\n\t\tif (kernel_termios_to_user_termios_1((struct termios __user *)arg, &kterm))\n\t\t\tret = -EFAULT;\n\t\treturn ret;\n\tcase TIOCSLCKTRMIOS:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tcopy_termios_locked(real_tty, &kterm);\n\t\tif (user_termios_to_kernel_termios_1(&kterm,\n\t\t\t\t\t       (struct termios __user *) arg))\n\t\t\treturn -EFAULT;\n\t\tdown_write(&real_tty->termios_rwsem);\n\t\treal_tty->termios_locked = kterm;\n\t\tup_write(&real_tty->termios_rwsem);\n\t\treturn ret;\n#endif\n#ifdef TCGETX\n\tcase TCGETX:\n\tcase TCSETX:\n\tcase TCSETXW:\n\tcase TCSETXF:\n\t\treturn -ENOTTY;\n#endif\n\tcase TIOCGSOFTCAR:\n\t\tcopy_termios(real_tty, &kterm);\n\t\tret = put_user((kterm.c_cflag & CLOCAL) ? 1 : 0,\n\t\t\t\t\t\t(int __user *)arg);\n\t\treturn ret;\n\tcase TIOCSSOFTCAR:\n\t\tif (get_user(arg, (unsigned int __user *) arg))\n\t\t\treturn -EFAULT;\n\t\treturn tty_change_softcar(real_tty, arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\nEXPORT_SYMBOL_GPL(tty_mode_ioctl);\n\n\n \nstatic int __tty_perform_flush(struct tty_struct *tty, unsigned long arg)\n{\n\tstruct tty_ldisc *ld = tty->ldisc;\n\n\tswitch (arg) {\n\tcase TCIFLUSH:\n\t\tif (ld && ld->ops->flush_buffer) {\n\t\t\tld->ops->flush_buffer(tty);\n\t\t\ttty_unthrottle(tty);\n\t\t}\n\t\tbreak;\n\tcase TCIOFLUSH:\n\t\tif (ld && ld->ops->flush_buffer) {\n\t\t\tld->ops->flush_buffer(tty);\n\t\t\ttty_unthrottle(tty);\n\t\t}\n\t\tfallthrough;\n\tcase TCOFLUSH:\n\t\ttty_driver_flush_buffer(tty);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint tty_perform_flush(struct tty_struct *tty, unsigned long arg)\n{\n\tstruct tty_ldisc *ld;\n\tint retval = tty_check_change(tty);\n\tif (retval)\n\t\treturn retval;\n\n\tld = tty_ldisc_ref_wait(tty);\n\tretval = __tty_perform_flush(tty, arg);\n\tif (ld)\n\t\ttty_ldisc_deref(ld);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(tty_perform_flush);\n\nint n_tty_ioctl_helper(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tint retval;\n\n\tswitch (cmd) {\n\tcase TCXONC:\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tswitch (arg) {\n\t\tcase TCOOFF:\n\t\t\tspin_lock_irq(&tty->flow.lock);\n\t\t\tif (!tty->flow.tco_stopped) {\n\t\t\t\ttty->flow.tco_stopped = true;\n\t\t\t\t__stop_tty(tty);\n\t\t\t}\n\t\t\tspin_unlock_irq(&tty->flow.lock);\n\t\t\tbreak;\n\t\tcase TCOON:\n\t\t\tspin_lock_irq(&tty->flow.lock);\n\t\t\tif (tty->flow.tco_stopped) {\n\t\t\t\ttty->flow.tco_stopped = false;\n\t\t\t\t__start_tty(tty);\n\t\t\t}\n\t\t\tspin_unlock_irq(&tty->flow.lock);\n\t\t\tbreak;\n\t\tcase TCIOFF:\n\t\t\tif (STOP_CHAR(tty) != __DISABLED_CHAR)\n\t\t\t\tretval = tty_send_xchar(tty, STOP_CHAR(tty));\n\t\t\tbreak;\n\t\tcase TCION:\n\t\t\tif (START_CHAR(tty) != __DISABLED_CHAR)\n\t\t\t\tretval = tty_send_xchar(tty, START_CHAR(tty));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn retval;\n\tcase TCFLSH:\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\treturn __tty_perform_flush(tty, arg);\n\tdefault:\n\t\t \n\t\treturn tty_mode_ioctl(tty, cmd, arg);\n\t}\n}\nEXPORT_SYMBOL(n_tty_ioctl_helper);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}