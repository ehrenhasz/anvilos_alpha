{
  "module_name": "n_gsm.c",
  "hash_id": "ac21bf603567b9de3720df4c456f631558027303131aa05cc69b9164d0d27e3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/n_gsm.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/fcntl.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/bitfield.h>\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/math.h>\n#include <linux/nospec.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/bitops.h>\n#include <linux/file.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/tty_flip.h>\n#include <linux/tty_driver.h>\n#include <linux/serial.h>\n#include <linux/kfifo.h>\n#include <linux/skbuff.h>\n#include <net/arp.h>\n#include <linux/ip.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/gsmmux.h>\n#include \"tty.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0600);\n\n \n#define DBG_DUMP\tBIT(0)  \n#define DBG_CD_ON\tBIT(1)  \n#define DBG_DATA\tBIT(2)  \n#define DBG_ERRORS\tBIT(3)  \n#define DBG_TTY\t\tBIT(4)  \n#define DBG_PAYLOAD\tBIT(5)  \n\n \n\n#define T1\t10\t\t \n#define T2\t34\t\t \n#define T3\t10\t\t \n#define N2\t3\t\t \n#define K\t2\t\t \n\n#define MAX_T3 255\t\t \n#define MAX_WINDOW_SIZE 7\t \n\n \n#ifdef DEBUG_TIMING\n#define T1\t100\n#define T2\t200\n#endif\n\n \n#define MAX_MRU 1500\n#define MAX_MTU 1500\n#define MIN_MTU (PROT_OVERHEAD + 1)\n \n#define PROT_OVERHEAD 7\n#define\tGSM_NET_TX_TIMEOUT (HZ*10)\n\n \nstruct gsm_mux_net {\n\tstruct kref ref;\n\tstruct gsm_dlci *dlci;\n};\n\n \n\nstruct gsm_msg {\n\tstruct list_head list;\n\tu8 addr;\t\t \n\tu8 ctrl;\t\t \n\tunsigned int len;\t \n\tunsigned char *data;\t \n\tunsigned char buffer[];\n};\n\nenum gsm_dlci_state {\n\tDLCI_CLOSED,\n\tDLCI_WAITING_CONFIG,\t \n\tDLCI_CONFIGURE,\t\t \n\tDLCI_OPENING,\t\t \n\tDLCI_OPEN,\t\t \n\tDLCI_CLOSING,\t\t \n};\n\nenum gsm_dlci_mode {\n\tDLCI_MODE_ABM,\t\t \n\tDLCI_MODE_ADM,\t\t \n};\n\n \n\nstruct gsm_dlci {\n\tstruct gsm_mux *gsm;\n\tint addr;\n\tenum gsm_dlci_state state;\n\tstruct mutex mutex;\n\n\t \n\tenum gsm_dlci_mode mode;\n\tspinlock_t lock;\t \n\tstruct timer_list t1;\t \n\tint retries;\n\t \n\tstruct tty_port port;\t \n#define TX_SIZE\t\t4096     \n\tstruct kfifo fifo;\t \n\tint adaption;\t\t \n\tint prev_adaption;\n\tu32 modem_rx;\t\t \n\tu32 modem_tx;\t\t \n\tunsigned int mtu;\n\tbool dead;\t\t \n\t \n\tu8 prio;\t\t \n\tu8 ftype;\t\t \n\tu8 k;\t\t\t \n\t \n\tbool throttled;\t\t \n\tbool constipated;\t \n\t \n\tstruct sk_buff *skb;\t \n\tstruct sk_buff_head skb_list;\t \n\t \n\tvoid (*data)(struct gsm_dlci *dlci, const u8 *data, int len);\n\tvoid (*prev_data)(struct gsm_dlci *dlci, const u8 *data, int len);\n\tstruct net_device *net;  \n};\n\n \n\nstruct gsm_dlci_param_bits {\n\tu8 d_bits;\n\tu8 i_cl_bits;\n\tu8 p_bits;\n\tu8 t_bits;\n\t__le16 n_bits;\n\tu8 na_bits;\n\tu8 k_bits;\n};\n\nstatic_assert(sizeof(struct gsm_dlci_param_bits) == 8);\n\n#define PN_D_FIELD_DLCI\t\tGENMASK(5, 0)\n#define PN_I_CL_FIELD_FTYPE\tGENMASK(3, 0)\n#define PN_I_CL_FIELD_ADAPTION\tGENMASK(7, 4)\n#define PN_P_FIELD_PRIO\t\tGENMASK(5, 0)\n#define PN_T_FIELD_T1\t\tGENMASK(7, 0)\n#define PN_N_FIELD_N1\t\tGENMASK(15, 0)\n#define PN_NA_FIELD_N2\t\tGENMASK(7, 0)\n#define PN_K_FIELD_K\t\tGENMASK(2, 0)\n\n \n#define GSM_TTY_MINORS\t\t256\n\n \n\n#define NUM_DLCI\t\t64\n\n \n\nstruct gsm_control {\n\tu8 cmd;\t\t \n\tu8 *data;\t \n\tint len;\t \n\tint done;\t \n\tint error;\t \n};\n\nenum gsm_encoding {\n\tGSM_BASIC_OPT,\n\tGSM_ADV_OPT,\n};\n\nenum gsm_mux_state {\n\tGSM_SEARCH,\n\tGSM_START,\n\tGSM_ADDRESS,\n\tGSM_CONTROL,\n\tGSM_LEN,\n\tGSM_DATA,\n\tGSM_FCS,\n\tGSM_OVERRUN,\n\tGSM_LEN0,\n\tGSM_LEN1,\n\tGSM_SSOF,\n};\n\n \n\nstruct gsm_mux {\n\tstruct tty_struct *tty;\t\t \n\tspinlock_t lock;\n\tstruct mutex mutex;\n\tunsigned int num;\n\tstruct kref ref;\n\n\t \n\twait_queue_head_t event;\n\n\t \n\tstruct work_struct tx_work;\n\n\t \n\n\t \n\tunsigned char *buf;\n\tenum gsm_mux_state state;\n\tunsigned int len;\n\tunsigned int address;\n\tunsigned int count;\n\tbool escape;\n\tenum gsm_encoding encoding;\n\tu8 control;\n\tu8 fcs;\n\tu8 *txframe;\t\t\t \n\n\t \n\tvoid (*receive)(struct gsm_mux *gsm, u8 ch);\n\n\t \n\tunsigned int mru;\n\tunsigned int mtu;\n\tint initiator;\t\t\t \n\tbool dead;\t\t\t \n\tstruct gsm_dlci *dlci[NUM_DLCI];\n\tint old_c_iflag;\t\t \n\tbool constipated;\t\t \n\tbool has_devices;\t\t \n\n\tspinlock_t tx_lock;\n\tunsigned int tx_bytes;\t\t \n#define TX_THRESH_HI\t\t8192\n#define TX_THRESH_LO\t\t2048\n\tstruct list_head tx_ctrl_list;\t \n\tstruct list_head tx_data_list;\t \n\n\t \n\tstruct timer_list kick_timer;\t \n\tstruct timer_list t2_timer;\t \n\tint cretries;\t\t\t \n\tstruct gsm_control *pending_cmd; \n\tspinlock_t control_lock;\t \n\n\t \n\tstruct timer_list ka_timer;\t \n\tu8 ka_num;\t\t\t \n\tsigned int ka_retries;\t\t \n\n\t \n\tint adaption;\t\t \n\tu8 ftype;\t\t \n\tint t1, t2;\t\t \n\tunsigned int t3;\t \n\tint n2;\t\t\t \n\tu8 k;\t\t\t \n\tbool wait_config;\t \n\tu32 keep_alive;\t\t \n\n\t \n\tunsigned long bad_fcs;\n\tunsigned long malformed;\n\tunsigned long io_error;\n\tunsigned long open_error;\n\tunsigned long bad_size;\n\tunsigned long unsupported;\n};\n\n\n \n\n#define MAX_MUX\t\t4\t\t\t \nstatic struct gsm_mux *gsm_mux[MAX_MUX];\t \nstatic DEFINE_SPINLOCK(gsm_mux_lock);\n\nstatic struct tty_driver *gsm_tty_driver;\n\n \n\n#define CR\t\t\t0x02\n#define EA\t\t\t0x01\n#define\tPF\t\t\t0x10\n\n \n#define RR\t\t\t0x01\n#define UI\t\t\t0x03\n#define RNR\t\t\t0x05\n#define REJ\t\t\t0x09\n#define DM\t\t\t0x0F\n#define SABM\t\t\t0x2F\n#define DISC\t\t\t0x43\n#define UA\t\t\t0x63\n#define\tUIH\t\t\t0xEF\n\n \n#define CMD_NSC\t\t\t0x09\n#define CMD_TEST\t\t0x11\n#define CMD_PSC\t\t\t0x21\n#define CMD_RLS\t\t\t0x29\n#define CMD_FCOFF\t\t0x31\n#define CMD_PN\t\t\t0x41\n#define CMD_RPN\t\t\t0x49\n#define CMD_FCON\t\t0x51\n#define CMD_CLD\t\t\t0x61\n#define CMD_SNC\t\t\t0x69\n#define CMD_MSC\t\t\t0x71\n\n \n#define MDM_FC\t\t\t0x01\n#define MDM_RTC\t\t\t0x02\n#define MDM_RTR\t\t\t0x04\n#define MDM_IC\t\t\t0x20\n#define MDM_DV\t\t\t0x40\n\n#define GSM0_SOF\t\t0xF9\n#define GSM1_SOF\t\t0x7E\n#define GSM1_ESCAPE\t\t0x7D\n#define GSM1_ESCAPE_BITS\t0x20\n#define XON\t\t\t0x11\n#define XOFF\t\t\t0x13\n#define ISO_IEC_646_MASK\t0x7F\n\nstatic const struct tty_port_operations gsm_port_ops;\n\n \n\nstatic const u8 gsm_fcs8[256] = {\n\t0x00, 0x91, 0xE3, 0x72, 0x07, 0x96, 0xE4, 0x75,\n\t0x0E, 0x9F, 0xED, 0x7C, 0x09, 0x98, 0xEA, 0x7B,\n\t0x1C, 0x8D, 0xFF, 0x6E, 0x1B, 0x8A, 0xF8, 0x69,\n\t0x12, 0x83, 0xF1, 0x60, 0x15, 0x84, 0xF6, 0x67,\n\t0x38, 0xA9, 0xDB, 0x4A, 0x3F, 0xAE, 0xDC, 0x4D,\n\t0x36, 0xA7, 0xD5, 0x44, 0x31, 0xA0, 0xD2, 0x43,\n\t0x24, 0xB5, 0xC7, 0x56, 0x23, 0xB2, 0xC0, 0x51,\n\t0x2A, 0xBB, 0xC9, 0x58, 0x2D, 0xBC, 0xCE, 0x5F,\n\t0x70, 0xE1, 0x93, 0x02, 0x77, 0xE6, 0x94, 0x05,\n\t0x7E, 0xEF, 0x9D, 0x0C, 0x79, 0xE8, 0x9A, 0x0B,\n\t0x6C, 0xFD, 0x8F, 0x1E, 0x6B, 0xFA, 0x88, 0x19,\n\t0x62, 0xF3, 0x81, 0x10, 0x65, 0xF4, 0x86, 0x17,\n\t0x48, 0xD9, 0xAB, 0x3A, 0x4F, 0xDE, 0xAC, 0x3D,\n\t0x46, 0xD7, 0xA5, 0x34, 0x41, 0xD0, 0xA2, 0x33,\n\t0x54, 0xC5, 0xB7, 0x26, 0x53, 0xC2, 0xB0, 0x21,\n\t0x5A, 0xCB, 0xB9, 0x28, 0x5D, 0xCC, 0xBE, 0x2F,\n\t0xE0, 0x71, 0x03, 0x92, 0xE7, 0x76, 0x04, 0x95,\n\t0xEE, 0x7F, 0x0D, 0x9C, 0xE9, 0x78, 0x0A, 0x9B,\n\t0xFC, 0x6D, 0x1F, 0x8E, 0xFB, 0x6A, 0x18, 0x89,\n\t0xF2, 0x63, 0x11, 0x80, 0xF5, 0x64, 0x16, 0x87,\n\t0xD8, 0x49, 0x3B, 0xAA, 0xDF, 0x4E, 0x3C, 0xAD,\n\t0xD6, 0x47, 0x35, 0xA4, 0xD1, 0x40, 0x32, 0xA3,\n\t0xC4, 0x55, 0x27, 0xB6, 0xC3, 0x52, 0x20, 0xB1,\n\t0xCA, 0x5B, 0x29, 0xB8, 0xCD, 0x5C, 0x2E, 0xBF,\n\t0x90, 0x01, 0x73, 0xE2, 0x97, 0x06, 0x74, 0xE5,\n\t0x9E, 0x0F, 0x7D, 0xEC, 0x99, 0x08, 0x7A, 0xEB,\n\t0x8C, 0x1D, 0x6F, 0xFE, 0x8B, 0x1A, 0x68, 0xF9,\n\t0x82, 0x13, 0x61, 0xF0, 0x85, 0x14, 0x66, 0xF7,\n\t0xA8, 0x39, 0x4B, 0xDA, 0xAF, 0x3E, 0x4C, 0xDD,\n\t0xA6, 0x37, 0x45, 0xD4, 0xA1, 0x30, 0x42, 0xD3,\n\t0xB4, 0x25, 0x57, 0xC6, 0xB3, 0x22, 0x50, 0xC1,\n\t0xBA, 0x2B, 0x59, 0xC8, 0xBD, 0x2C, 0x5E, 0xCF\n};\n\n#define INIT_FCS\t0xFF\n#define GOOD_FCS\t0xCF\n\nstatic void gsm_dlci_close(struct gsm_dlci *dlci);\nstatic int gsmld_output(struct gsm_mux *gsm, u8 *data, int len);\nstatic int gsm_modem_update(struct gsm_dlci *dlci, u8 brk);\nstatic struct gsm_msg *gsm_data_alloc(struct gsm_mux *gsm, u8 addr, int len,\n\t\t\t\t\t\t\t\tu8 ctrl);\nstatic int gsm_send_packet(struct gsm_mux *gsm, struct gsm_msg *msg);\nstatic struct gsm_dlci *gsm_dlci_alloc(struct gsm_mux *gsm, int addr);\nstatic void gsmld_write_trigger(struct gsm_mux *gsm);\nstatic void gsmld_write_task(struct work_struct *work);\n\n \n\nstatic inline u8 gsm_fcs_add(u8 fcs, u8 c)\n{\n\treturn gsm_fcs8[fcs ^ c];\n}\n\n \n\nstatic inline u8 gsm_fcs_add_block(u8 fcs, u8 *c, int len)\n{\n\twhile (len--)\n\t\tfcs = gsm_fcs8[fcs ^ *c++];\n\treturn fcs;\n}\n\n \n\nstatic int gsm_read_ea(unsigned int *val, u8 c)\n{\n\t \n\t*val <<= 7;\n\t*val |= c >> 1;\n\t \n\treturn c & EA;\n}\n\n \nstatic unsigned int gsm_read_ea_val(unsigned int *val, const u8 *data, int dlen)\n{\n\tunsigned int len = 0;\n\n\tfor (; dlen > 0; dlen--) {\n\t\tlen++;\n\t\tif (gsm_read_ea(val, *data++))\n\t\t\tbreak;\n\t}\n\treturn len;\n}\n\n \n\nstatic u8 gsm_encode_modem(const struct gsm_dlci *dlci)\n{\n\tu8 modembits = 0;\n\t \n\tif (dlci->throttled)\n\t\tmodembits |= MDM_FC;\n\tif (dlci->modem_tx & TIOCM_DTR)\n\t\tmodembits |= MDM_RTC;\n\tif (dlci->modem_tx & TIOCM_RTS)\n\t\tmodembits |= MDM_RTR;\n\tif (dlci->modem_tx & TIOCM_RI)\n\t\tmodembits |= MDM_IC;\n\tif (dlci->modem_tx & TIOCM_CD || dlci->gsm->initiator)\n\t\tmodembits |= MDM_DV;\n\t \n\tif (dlci->modem_tx & TIOCM_OUT1)\n\t\tmodembits |= MDM_IC;\n\tif (dlci->modem_tx & TIOCM_OUT2)\n\t\tmodembits |= MDM_DV;\n\treturn modembits;\n}\n\nstatic void gsm_hex_dump_bytes(const char *fname, const u8 *data,\n\t\t\t       unsigned long len)\n{\n\tchar *prefix;\n\n\tif (!fname) {\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_NONE, 16, 1, data, len,\n\t\t\t       true);\n\t\treturn;\n\t}\n\n\tprefix = kasprintf(GFP_ATOMIC, \"%s: \", fname);\n\tif (!prefix)\n\t\treturn;\n\tprint_hex_dump(KERN_INFO, prefix, DUMP_PREFIX_OFFSET, 16, 1, data, len,\n\t\t       true);\n\tkfree(prefix);\n}\n\n \nstatic int gsm_encode_params(const struct gsm_dlci *dlci,\n\t\t\t     struct gsm_dlci_param_bits *params)\n{\n\tconst struct gsm_mux *gsm = dlci->gsm;\n\tunsigned int i, cl;\n\n\tswitch (dlci->ftype) {\n\tcase UIH:\n\t\ti = 0;  \n\t\tbreak;\n\tcase UI:\n\t\ti = 1;  \n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"unsupported frame type %d\\n\", dlci->ftype);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dlci->adaption) {\n\tcase 1:  \n\t\tcl = 0;  \n\t\tbreak;\n\tcase 2:  \n\t\tcl = 1;  \n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"unsupported adaption %d\\n\", dlci->adaption);\n\t\treturn -EINVAL;\n\t}\n\n\tparams->d_bits = FIELD_PREP(PN_D_FIELD_DLCI, dlci->addr);\n\t \n\tparams->i_cl_bits = FIELD_PREP(PN_I_CL_FIELD_FTYPE, i) |\n\t\t\t    FIELD_PREP(PN_I_CL_FIELD_ADAPTION, cl);\n\tparams->p_bits = FIELD_PREP(PN_P_FIELD_PRIO, dlci->prio);\n\tparams->t_bits = FIELD_PREP(PN_T_FIELD_T1, gsm->t1);\n\tparams->n_bits = cpu_to_le16(FIELD_PREP(PN_N_FIELD_N1, dlci->mtu));\n\tparams->na_bits = FIELD_PREP(PN_NA_FIELD_N2, gsm->n2);\n\tparams->k_bits = FIELD_PREP(PN_K_FIELD_K, dlci->k);\n\n\treturn 0;\n}\n\n \nstatic int gsm_register_devices(struct tty_driver *driver, unsigned int index)\n{\n\tstruct device *dev;\n\tint i;\n\tunsigned int base;\n\n\tif (!driver || index >= MAX_MUX)\n\t\treturn -EINVAL;\n\n\tbase = index * NUM_DLCI;  \n\tfor (i = 1; i < NUM_DLCI; i++) {\n\t\t \n\t\tdev = tty_register_device(gsm_tty_driver, base + i, NULL);\n\t\tif (IS_ERR(dev)) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s failed to register device minor %u\",\n\t\t\t\t\t__func__, base + i);\n\t\t\tfor (i--; i >= 1; i--)\n\t\t\t\ttty_unregister_device(gsm_tty_driver, base + i);\n\t\t\treturn PTR_ERR(dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void gsm_unregister_devices(struct tty_driver *driver,\n\t\t\t\t   unsigned int index)\n{\n\tint i;\n\tunsigned int base;\n\n\tif (!driver || index >= MAX_MUX)\n\t\treturn;\n\n\tbase = index * NUM_DLCI;  \n\tfor (i = 1; i < NUM_DLCI; i++) {\n\t\t \n\t\ttty_unregister_device(gsm_tty_driver, base + i);\n\t}\n}\n\n \n\nstatic void gsm_print_packet(const char *hdr, int addr, int cr,\n\t\t\t\t\tu8 control, const u8 *data, int dlen)\n{\n\tif (!(debug & DBG_DUMP))\n\t\treturn;\n\t \n\tif (!(debug & DBG_PAYLOAD) && addr != 0)\n\t\tif ((control & ~PF) == UI || (control & ~PF) == UIH)\n\t\t\treturn;\n\n\tpr_info(\"%s %d) %c: \", hdr, addr, \"RC\"[cr]);\n\n\tswitch (control & ~PF) {\n\tcase SABM:\n\t\tpr_cont(\"SABM\");\n\t\tbreak;\n\tcase UA:\n\t\tpr_cont(\"UA\");\n\t\tbreak;\n\tcase DISC:\n\t\tpr_cont(\"DISC\");\n\t\tbreak;\n\tcase DM:\n\t\tpr_cont(\"DM\");\n\t\tbreak;\n\tcase UI:\n\t\tpr_cont(\"UI\");\n\t\tbreak;\n\tcase UIH:\n\t\tpr_cont(\"UIH\");\n\t\tbreak;\n\tdefault:\n\t\tif (!(control & 0x01)) {\n\t\t\tpr_cont(\"I N(S)%d N(R)%d\",\n\t\t\t\t(control & 0x0E) >> 1, (control & 0xE0) >> 5);\n\t\t} else switch (control & 0x0F) {\n\t\t\tcase RR:\n\t\t\t\tpr_cont(\"RR(%d)\", (control & 0xE0) >> 5);\n\t\t\t\tbreak;\n\t\t\tcase RNR:\n\t\t\t\tpr_cont(\"RNR(%d)\", (control & 0xE0) >> 5);\n\t\t\t\tbreak;\n\t\t\tcase REJ:\n\t\t\t\tpr_cont(\"REJ(%d)\", (control & 0xE0) >> 5);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_cont(\"[%02X]\", control);\n\t\t}\n\t}\n\n\tif (control & PF)\n\t\tpr_cont(\"(P)\");\n\telse\n\t\tpr_cont(\"(F)\");\n\n\tgsm_hex_dump_bytes(NULL, data, dlen);\n}\n\n\n \n\n \n\nstatic int gsm_stuff_frame(const u8 *input, u8 *output, int len)\n{\n\tint olen = 0;\n\twhile (len--) {\n\t\tif (*input == GSM1_SOF || *input == GSM1_ESCAPE\n\t\t    || (*input & ISO_IEC_646_MASK) == XON\n\t\t    || (*input & ISO_IEC_646_MASK) == XOFF) {\n\t\t\t*output++ = GSM1_ESCAPE;\n\t\t\t*output++ = *input++ ^ GSM1_ESCAPE_BITS;\n\t\t\tolen++;\n\t\t} else\n\t\t\t*output++ = *input++;\n\t\tolen++;\n\t}\n\treturn olen;\n}\n\n \nstatic int gsm_send(struct gsm_mux *gsm, int addr, int cr, int control)\n{\n\tstruct gsm_msg *msg;\n\tu8 *dp;\n\tint ocr;\n\tunsigned long flags;\n\n\tmsg = gsm_data_alloc(gsm, addr, 0, control);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\t \n\tocr = cr ^ (gsm->initiator ? 0 : 1);\n\n\tmsg->data -= 3;\n\tdp = msg->data;\n\t*dp++ = (addr << 2) | (ocr << 1) | EA;\n\t*dp++ = control;\n\n\tif (gsm->encoding == GSM_BASIC_OPT)\n\t\t*dp++ = EA;  \n\n\t*dp = 0xFF - gsm_fcs_add_block(INIT_FCS, msg->data, dp - msg->data);\n\tmsg->len = (dp - msg->data) + 1;\n\n\tgsm_print_packet(\"Q->\", addr, cr, control, NULL, 0);\n\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tlist_add_tail(&msg->list, &gsm->tx_ctrl_list);\n\tgsm->tx_bytes += msg->len;\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\tgsmld_write_trigger(gsm);\n\n\treturn 0;\n}\n\n \nstatic void gsm_dlci_clear_queues(struct gsm_mux *gsm, struct gsm_dlci *dlci)\n{\n\tstruct gsm_msg *msg, *nmsg;\n\tint addr = dlci->addr;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dlci->lock, flags);\n\tkfifo_reset(&dlci->fifo);\n\tspin_unlock_irqrestore(&dlci->lock, flags);\n\n\t \n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tlist_for_each_entry_safe(msg, nmsg, &gsm->tx_data_list, list) {\n\t\tif (msg->addr != addr)\n\t\t\tcontinue;\n\t\tgsm->tx_bytes -= msg->len;\n\t\tlist_del(&msg->list);\n\t\tkfree(msg);\n\t}\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n}\n\n \n\nstatic inline void gsm_response(struct gsm_mux *gsm, int addr, int control)\n{\n\tgsm_send(gsm, addr, 0, control);\n}\n\n \n\nstatic inline void gsm_command(struct gsm_mux *gsm, int addr, int control)\n{\n\tgsm_send(gsm, addr, 1, control);\n}\n\n \n\n#define HDR_LEN\t\t6\t \n\n \n\nstatic struct gsm_msg *gsm_data_alloc(struct gsm_mux *gsm, u8 addr, int len,\n\t\t\t\t\t\t\t\tu8 ctrl)\n{\n\tstruct gsm_msg *m = kmalloc(sizeof(struct gsm_msg) + len + HDR_LEN,\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\n\tif (m == NULL)\n\t\treturn NULL;\n\tm->data = m->buffer + HDR_LEN - 1;\t \n\tm->len = len;\n\tm->addr = addr;\n\tm->ctrl = ctrl;\n\tINIT_LIST_HEAD(&m->list);\n\treturn m;\n}\n\n \nstatic int gsm_send_packet(struct gsm_mux *gsm, struct gsm_msg *msg)\n{\n\tint len, ret;\n\n\n\tif (gsm->encoding == GSM_BASIC_OPT) {\n\t\tgsm->txframe[0] = GSM0_SOF;\n\t\tmemcpy(gsm->txframe + 1, msg->data, msg->len);\n\t\tgsm->txframe[msg->len + 1] = GSM0_SOF;\n\t\tlen = msg->len + 2;\n\t} else {\n\t\tgsm->txframe[0] = GSM1_SOF;\n\t\tlen = gsm_stuff_frame(msg->data, gsm->txframe + 1, msg->len);\n\t\tgsm->txframe[len + 1] = GSM1_SOF;\n\t\tlen += 2;\n\t}\n\n\tif (debug & DBG_DATA)\n\t\tgsm_hex_dump_bytes(__func__, gsm->txframe, len);\n\tgsm_print_packet(\"-->\", msg->addr, gsm->initiator, msg->ctrl, msg->data,\n\t\t\t msg->len);\n\n\tret = gsmld_output(gsm, gsm->txframe, len);\n\tif (ret <= 0)\n\t\treturn ret;\n\t \n\tgsm->tx_bytes -= msg->len;\n\n\treturn 0;\n}\n\n \nstatic bool gsm_is_flow_ctrl_msg(struct gsm_msg *msg)\n{\n\tunsigned int cmd;\n\n\tif (msg->addr > 0)\n\t\treturn false;\n\n\tswitch (msg->ctrl & ~PF) {\n\tcase UI:\n\tcase UIH:\n\t\tcmd = 0;\n\t\tif (gsm_read_ea_val(&cmd, msg->data + 2, msg->len - 2) < 1)\n\t\t\tbreak;\n\t\tswitch (cmd & ~PF) {\n\t\tcase CMD_FCOFF:\n\t\tcase CMD_FCON:\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n \nstatic int gsm_data_kick(struct gsm_mux *gsm)\n{\n\tstruct gsm_msg *msg, *nmsg;\n\tstruct gsm_dlci *dlci;\n\tint ret;\n\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &gsm->tty->flags);\n\n\t \n\tlist_for_each_entry_safe(msg, nmsg, &gsm->tx_ctrl_list, list) {\n\t\tif (gsm->constipated && !gsm_is_flow_ctrl_msg(msg))\n\t\t\tcontinue;\n\t\tret = gsm_send_packet(gsm, msg);\n\t\tswitch (ret) {\n\t\tcase -ENOSPC:\n\t\t\treturn -ENOSPC;\n\t\tcase -ENODEV:\n\t\t\t \n\t\t\tgsm->tx_bytes -= msg->len;\n\t\t\tlist_del(&msg->list);\n\t\t\tkfree(msg);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (ret >= 0) {\n\t\t\t\tlist_del(&msg->list);\n\t\t\t\tkfree(msg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (gsm->constipated)\n\t\treturn -EAGAIN;\n\n\t \n\tif (list_empty(&gsm->tx_data_list))\n\t\treturn 0;\n\tlist_for_each_entry_safe(msg, nmsg, &gsm->tx_data_list, list) {\n\t\tdlci = gsm->dlci[msg->addr];\n\t\t \n\t\tif (dlci->state != DLCI_OPEN) {\n\t\t\tgsm->tx_bytes -= msg->len;\n\t\t\tlist_del(&msg->list);\n\t\t\tkfree(msg);\n\t\t\tcontinue;\n\t\t}\n\t\tret = gsm_send_packet(gsm, msg);\n\t\tswitch (ret) {\n\t\tcase -ENOSPC:\n\t\t\treturn -ENOSPC;\n\t\tcase -ENODEV:\n\t\t\t \n\t\t\tgsm->tx_bytes -= msg->len;\n\t\t\tlist_del(&msg->list);\n\t\t\tkfree(msg);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (ret >= 0) {\n\t\t\t\tlist_del(&msg->list);\n\t\t\t\tkfree(msg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n \n\nstatic void __gsm_data_queue(struct gsm_dlci *dlci, struct gsm_msg *msg)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tu8 *dp = msg->data;\n\tu8 *fcs = dp + msg->len;\n\n\t \n\tif (gsm->encoding == GSM_BASIC_OPT) {\n\t\tif (msg->len < 128)\n\t\t\t*--dp = (msg->len << 1) | EA;\n\t\telse {\n\t\t\t*--dp = (msg->len >> 7);\t \n\t\t\t*--dp = (msg->len & 127) << 1;\t \n\t\t}\n\t}\n\n\t*--dp = msg->ctrl;\n\tif (gsm->initiator)\n\t\t*--dp = (msg->addr << 2) | CR | EA;\n\telse\n\t\t*--dp = (msg->addr << 2) | EA;\n\t*fcs = gsm_fcs_add_block(INIT_FCS, dp , msg->data - dp);\n\t \n\tif (msg->ctrl == UI || msg->ctrl == (UI|PF))\n\t\t*fcs = gsm_fcs_add_block(*fcs, msg->data, msg->len);\n\t*fcs = 0xFF - *fcs;\n\n\tgsm_print_packet(\"Q> \", msg->addr, gsm->initiator, msg->ctrl,\n\t\t\t\t\t\t\tmsg->data, msg->len);\n\n\t \n\tmsg->len += (msg->data - dp) + 1;\n\tmsg->data = dp;\n\n\t \n\tswitch (msg->ctrl & ~PF) {\n\tcase UI:\n\tcase UIH:\n\t\tif (msg->addr > 0) {\n\t\t\tlist_add_tail(&msg->list, &gsm->tx_data_list);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tlist_add_tail(&msg->list, &gsm->tx_ctrl_list);\n\t\tbreak;\n\t}\n\tgsm->tx_bytes += msg->len;\n\n\tgsmld_write_trigger(gsm);\n\tmod_timer(&gsm->kick_timer, jiffies + 10 * gsm->t1 * HZ / 100);\n}\n\n \n\nstatic void gsm_data_queue(struct gsm_dlci *dlci, struct gsm_msg *msg)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&dlci->gsm->tx_lock, flags);\n\t__gsm_data_queue(dlci, msg);\n\tspin_unlock_irqrestore(&dlci->gsm->tx_lock, flags);\n}\n\n \n\nstatic int gsm_dlci_data_output(struct gsm_mux *gsm, struct gsm_dlci *dlci)\n{\n\tstruct gsm_msg *msg;\n\tu8 *dp;\n\tint h, len, size;\n\n\t \n\th = ((dlci->adaption == 1) ? 0 : 1);\n\n\tlen = kfifo_len(&dlci->fifo);\n\tif (len == 0)\n\t\treturn 0;\n\n\t \n\tif ((len + h) > dlci->mtu)\n\t\tlen = dlci->mtu - h;\n\n\tsize = len + h;\n\n\tmsg = gsm_data_alloc(gsm, dlci->addr, size, dlci->ftype);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tdp = msg->data;\n\tswitch (dlci->adaption) {\n\tcase 1:  \n\t\tbreak;\n\tcase 2:  \n\t\t*dp++ = (gsm_encode_modem(dlci) << 1) | EA;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unsupported adaption %d\\n\", __func__,\n\t\t       dlci->adaption);\n\t\tbreak;\n\t}\n\n\tWARN_ON(len != kfifo_out_locked(&dlci->fifo, dp, len,\n\t\t&dlci->lock));\n\n\t \n\ttty_port_tty_wakeup(&dlci->port);\n\n\t__gsm_data_queue(dlci, msg);\n\t \n\treturn size;\n}\n\n \n\nstatic int gsm_dlci_data_output_framed(struct gsm_mux *gsm,\n\t\t\t\t\t\tstruct gsm_dlci *dlci)\n{\n\tstruct gsm_msg *msg;\n\tu8 *dp;\n\tint len, size;\n\tint last = 0, first = 0;\n\tint overhead = 0;\n\n\t \n\tif (dlci->adaption == 4)\n\t\toverhead = 1;\n\n\t \n\tif (dlci->skb == NULL) {\n\t\tdlci->skb = skb_dequeue_tail(&dlci->skb_list);\n\t\tif (dlci->skb == NULL)\n\t\t\treturn 0;\n\t\tfirst = 1;\n\t}\n\tlen = dlci->skb->len + overhead;\n\n\t \n\tif (len > dlci->mtu) {\n\t\tif (dlci->adaption == 3) {\n\t\t\t \n\t\t\tdev_kfree_skb_any(dlci->skb);\n\t\t\tdlci->skb = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tlen = dlci->mtu;\n\t} else\n\t\tlast = 1;\n\n\tsize = len + overhead;\n\tmsg = gsm_data_alloc(gsm, dlci->addr, size, dlci->ftype);\n\tif (msg == NULL) {\n\t\tskb_queue_tail(&dlci->skb_list, dlci->skb);\n\t\tdlci->skb = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tdp = msg->data;\n\n\tif (dlci->adaption == 4) {  \n\t\t \n\t\t*dp++ = last << 7 | first << 6 | 1;\t \n\t\tlen--;\n\t}\n\tmemcpy(dp, dlci->skb->data, len);\n\tskb_pull(dlci->skb, len);\n\t__gsm_data_queue(dlci, msg);\n\tif (last) {\n\t\tdev_kfree_skb_any(dlci->skb);\n\t\tdlci->skb = NULL;\n\t}\n\treturn size;\n}\n\n \n\nstatic int gsm_dlci_modem_output(struct gsm_mux *gsm, struct gsm_dlci *dlci,\n\t\t\t\t u8 brk)\n{\n\tu8 *dp = NULL;\n\tstruct gsm_msg *msg;\n\tint size = 0;\n\n\t \n\tswitch (dlci->adaption) {\n\tcase 1:  \n\t\tbreak;\n\tcase 2:  \n\t\tsize++;\n\t\tif (brk > 0)\n\t\t\tsize++;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unsupported adaption %d\\n\", __func__,\n\t\t       dlci->adaption);\n\t\treturn -EINVAL;\n\t}\n\n\tmsg = gsm_data_alloc(gsm, dlci->addr, size, dlci->ftype);\n\tif (!msg) {\n\t\tpr_err(\"%s: gsm_data_alloc error\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tdp = msg->data;\n\tswitch (dlci->adaption) {\n\tcase 1:  \n\t\tbreak;\n\tcase 2:  \n\t\tif (brk == 0) {\n\t\t\t*dp++ = (gsm_encode_modem(dlci) << 1) | EA;\n\t\t} else {\n\t\t\t*dp++ = gsm_encode_modem(dlci) << 1;\n\t\t\t*dp++ = (brk << 4) | 2 | EA;  \n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t__gsm_data_queue(dlci, msg);\n\treturn size;\n}\n\n \n\nstatic int gsm_dlci_data_sweep(struct gsm_mux *gsm)\n{\n\t \n\tint i, len, ret = 0;\n\tbool sent;\n\tstruct gsm_dlci *dlci;\n\n\twhile (gsm->tx_bytes < TX_THRESH_HI) {\n\t\tfor (sent = false, i = 1; i < NUM_DLCI; i++) {\n\t\t\tdlci = gsm->dlci[i];\n\t\t\t \n\t\t\tif (!dlci || dlci->constipated)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (dlci->state != DLCI_OPEN)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (dlci->adaption < 3 && !dlci->net)\n\t\t\t\tlen = gsm_dlci_data_output(gsm, dlci);\n\t\t\telse\n\t\t\t\tlen = gsm_dlci_data_output_framed(gsm, dlci);\n\t\t\t \n\t\t\tif (len < 0)\n\t\t\t\treturn ret;\n\t\t\tif (len > 0) {\n\t\t\t\tret++;\n\t\t\t\tsent = true;\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t}\n\t\tif (!sent)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic void gsm_dlci_data_kick(struct gsm_dlci *dlci)\n{\n\tunsigned long flags;\n\tint sweep;\n\n\tif (dlci->constipated)\n\t\treturn;\n\n\tspin_lock_irqsave(&dlci->gsm->tx_lock, flags);\n\t \n\tsweep = (dlci->gsm->tx_bytes < TX_THRESH_LO);\n\tif (dlci->gsm->tx_bytes == 0) {\n\t\tif (dlci->net)\n\t\t\tgsm_dlci_data_output_framed(dlci->gsm, dlci);\n\t\telse\n\t\t\tgsm_dlci_data_output(dlci->gsm, dlci);\n\t}\n\tif (sweep)\n\t\tgsm_dlci_data_sweep(dlci->gsm);\n\tspin_unlock_irqrestore(&dlci->gsm->tx_lock, flags);\n}\n\n \n\n\n \nstatic int gsm_control_command(struct gsm_mux *gsm, int cmd, const u8 *data,\n\t\t\t       int dlen)\n{\n\tstruct gsm_msg *msg;\n\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\n\tmsg = gsm_data_alloc(gsm, 0, dlen + 2, dlci->ftype);\n\tif (msg == NULL)\n\t\treturn -ENOMEM;\n\n\tmsg->data[0] = (cmd << 1) | CR | EA;\t \n\tmsg->data[1] = (dlen << 1) | EA;\n\tmemcpy(msg->data + 2, data, dlen);\n\tgsm_data_queue(dlci, msg);\n\n\treturn 0;\n}\n\n \n\nstatic void gsm_control_reply(struct gsm_mux *gsm, int cmd, const u8 *data,\n\t\t\t\t\tint dlen)\n{\n\tstruct gsm_msg *msg;\n\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\n\tmsg = gsm_data_alloc(gsm, 0, dlen + 2, dlci->ftype);\n\tif (msg == NULL)\n\t\treturn;\n\tmsg->data[0] = (cmd & 0xFE) << 1 | EA;\t \n\tmsg->data[1] = (dlen << 1) | EA;\n\tmemcpy(msg->data + 2, data, dlen);\n\tgsm_data_queue(dlci, msg);\n}\n\n \n\nstatic void gsm_process_modem(struct tty_struct *tty, struct gsm_dlci *dlci,\n\t\t\t\t\t\t\tu32 modem, int slen)\n{\n\tint  mlines = 0;\n\tu8 brk = 0;\n\tint fc;\n\n\t \n\n\tif (slen == 1)\n\t\tmodem = modem & 0x7f;\n\telse {\n\t\tbrk = modem & 0x7f;\n\t\tmodem = (modem >> 7) & 0x7f;\n\t}\n\n\t \n\tfc = (modem & MDM_FC) || !(modem & MDM_RTR);\n\tif (fc && !dlci->constipated) {\n\t\t \n\t\tdlci->constipated = true;\n\t} else if (!fc && dlci->constipated) {\n\t\tdlci->constipated = false;\n\t\tgsm_dlci_data_kick(dlci);\n\t}\n\n\t \n\tif (modem & MDM_RTC)\n\t\tmlines |= TIOCM_DSR | TIOCM_DTR;\n\tif (modem & MDM_RTR)\n\t\tmlines |= TIOCM_RTS | TIOCM_CTS;\n\tif (modem & MDM_IC)\n\t\tmlines |= TIOCM_RI;\n\tif (modem & MDM_DV)\n\t\tmlines |= TIOCM_CD;\n\n\t \n\tif (tty) {\n\t\tif ((mlines & TIOCM_CD) == 0 && (dlci->modem_rx & TIOCM_CD))\n\t\t\tif (!C_CLOCAL(tty))\n\t\t\t\ttty_hangup(tty);\n\t}\n\tif (brk & 0x01)\n\t\ttty_insert_flip_char(&dlci->port, 0, TTY_BREAK);\n\tdlci->modem_rx = mlines;\n\twake_up_interruptible(&dlci->gsm->event);\n}\n\n \nstatic int gsm_process_negotiation(struct gsm_mux *gsm, unsigned int addr,\n\t\t\t\t   unsigned int cr,\n\t\t\t\t   const struct gsm_dlci_param_bits *params)\n{\n\tstruct gsm_dlci *dlci = gsm->dlci[addr];\n\tunsigned int ftype, i, adaption, prio, n1, k;\n\n\ti = FIELD_GET(PN_I_CL_FIELD_FTYPE, params->i_cl_bits);\n\tadaption = FIELD_GET(PN_I_CL_FIELD_ADAPTION, params->i_cl_bits) + 1;\n\tprio = FIELD_GET(PN_P_FIELD_PRIO, params->p_bits);\n\tn1 = FIELD_GET(PN_N_FIELD_N1, get_unaligned_le16(&params->n_bits));\n\tk = FIELD_GET(PN_K_FIELD_K, params->k_bits);\n\n\tif (n1 < MIN_MTU) {\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s N1 out of range in PN\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (i) {\n\tcase 0x00:\n\t\tftype = UIH;\n\t\tbreak;\n\tcase 0x01:\n\t\tftype = UI;\n\t\tbreak;\n\tcase 0x02:  \n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s unsupported I frame request in PN\\n\",\n\t\t\t\t__func__);\n\t\tgsm->unsupported++;\n\t\treturn -EINVAL;\n\tdefault:\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s i out of range in PN\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cr && gsm->initiator) {\n\t\tif (adaption != dlci->adaption) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid adaption %d in PN\\n\",\n\t\t\t\t\t__func__, adaption);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (prio != dlci->prio) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid priority %d in PN\",\n\t\t\t\t\t__func__, prio);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (n1 > gsm->mru || n1 > dlci->mtu) {\n\t\t\t \n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid N1 %d in PN\\n\", __func__,\n\t\t\t\t\tn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdlci->mtu = n1;\n\t\tif (ftype != dlci->ftype) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid i %d in PN\\n\", __func__, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ftype != UI && ftype != UIH && k > dlci->k) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid k %d in PN\\n\", __func__, k);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdlci->k = k;\n\t} else if (cr && !gsm->initiator) {\n\t\t \n\t\tif (adaption != 1 && adaption != 2) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid adaption %d in PN\\n\",\n\t\t\t\t\t__func__, adaption);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdlci->adaption = adaption;\n\t\tif (n1 > gsm->mru) {\n\t\t\t \n\t\t\tdlci->mtu = gsm->mru;\n\t\t} else if (n1 > MAX_MTU) {\n\t\t\t \n\t\t\tdlci->mtu = MAX_MTU;\n\t\t} else {\n\t\t\tdlci->mtu = n1;\n\t\t}\n\t\tdlci->prio = prio;\n\t\tdlci->ftype = ftype;\n\t\tdlci->k = k;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void gsm_control_modem(struct gsm_mux *gsm, const u8 *data, int clen)\n{\n\tunsigned int addr = 0;\n\tunsigned int modem = 0;\n\tstruct gsm_dlci *dlci;\n\tint len = clen;\n\tint cl = clen;\n\tconst u8 *dp = data;\n\tstruct tty_struct *tty;\n\n\tlen = gsm_read_ea_val(&addr, data, cl);\n\tif (len < 1)\n\t\treturn;\n\n\taddr >>= 1;\n\t \n\tif (addr == 0 || addr >= NUM_DLCI || gsm->dlci[addr] == NULL)\n\t\treturn;\n\tdlci = gsm->dlci[addr];\n\n\t \n\tif ((cl - len) < 1)\n\t\treturn;\n\n\tdp += len;\n\tcl -= len;\n\n\t \n\tlen = gsm_read_ea_val(&modem, dp, cl);\n\tif (len < 1)\n\t\treturn;\n\n\ttty = tty_port_tty_get(&dlci->port);\n\tgsm_process_modem(tty, dlci, modem, cl);\n\tif (tty) {\n\t\ttty_wakeup(tty);\n\t\ttty_kref_put(tty);\n\t}\n\tgsm_control_reply(gsm, CMD_MSC, data, clen);\n}\n\n \nstatic void gsm_control_negotiation(struct gsm_mux *gsm, unsigned int cr,\n\t\t\t\t    const u8 *data, unsigned int dlen)\n{\n\tunsigned int addr;\n\tstruct gsm_dlci_param_bits pn_reply;\n\tstruct gsm_dlci *dlci;\n\tstruct gsm_dlci_param_bits *params;\n\n\tif (dlen < sizeof(struct gsm_dlci_param_bits)) {\n\t\tgsm->open_error++;\n\t\treturn;\n\t}\n\n\t \n\tparams = (struct gsm_dlci_param_bits *)data;\n\taddr = FIELD_GET(PN_D_FIELD_DLCI, params->d_bits);\n\tif (addr == 0 || addr >= NUM_DLCI || !gsm->dlci[addr]) {\n\t\tgsm->open_error++;\n\t\treturn;\n\t}\n\tdlci = gsm->dlci[addr];\n\n\t \n\tif ((!cr && dlci->state == DLCI_OPENING) || dlci->state == DLCI_OPEN) {\n\t\tgsm->open_error++;\n\t\treturn;\n\t}\n\n\t \n\tif (gsm_process_negotiation(gsm, addr, cr, params) != 0) {\n\t\t \n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s PN failed\\n\", __func__);\n\t\tgsm->open_error++;\n\t\tgsm_dlci_close(dlci);\n\t\treturn;\n\t}\n\n\tif (cr) {\n\t\t \n\t\tif (gsm_encode_params(dlci, &pn_reply) == 0)\n\t\t\tgsm_control_reply(gsm, CMD_PN, (const u8 *)&pn_reply,\n\t\t\t\t\t  sizeof(pn_reply));\n\t\telse if (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s PN invalid\\n\", __func__);\n\t} else if (dlci->state == DLCI_CONFIGURE) {\n\t\t \n\t\tdlci->state = DLCI_OPENING;\n\t\tgsm_command(gsm, dlci->addr, SABM|PF);\n\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t} else {\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s PN in invalid state\\n\", __func__);\n\t\tgsm->open_error++;\n\t}\n}\n\n \n\nstatic void gsm_control_rls(struct gsm_mux *gsm, const u8 *data, int clen)\n{\n\tstruct tty_port *port;\n\tunsigned int addr = 0;\n\tu8 bits;\n\tint len = clen;\n\tconst u8 *dp = data;\n\n\twhile (gsm_read_ea(&addr, *dp++) == 0) {\n\t\tlen--;\n\t\tif (len == 0)\n\t\t\treturn;\n\t}\n\t \n\tlen--;\n\tif (len <= 0)\n\t\treturn;\n\taddr >>= 1;\n\t \n\tif (addr == 0 || addr >= NUM_DLCI || gsm->dlci[addr] == NULL)\n\t\treturn;\n\t \n\tbits = *dp;\n\tif ((bits & 1) == 0)\n\t\treturn;\n\n\tport = &gsm->dlci[addr]->port;\n\n\tif (bits & 2)\n\t\ttty_insert_flip_char(port, 0, TTY_OVERRUN);\n\tif (bits & 4)\n\t\ttty_insert_flip_char(port, 0, TTY_PARITY);\n\tif (bits & 8)\n\t\ttty_insert_flip_char(port, 0, TTY_FRAME);\n\n\ttty_flip_buffer_push(port);\n\n\tgsm_control_reply(gsm, CMD_RLS, data, clen);\n}\n\nstatic void gsm_dlci_begin_close(struct gsm_dlci *dlci);\n\n \n\nstatic void gsm_control_message(struct gsm_mux *gsm, unsigned int command,\n\t\t\t\t\t\tconst u8 *data, int clen)\n{\n\tu8 buf[1];\n\n\tswitch (command) {\n\tcase CMD_CLD: {\n\t\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\t\t \n\t\tif (dlci) {\n\t\t\tdlci->dead = true;\n\t\t\tgsm->dead = true;\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase CMD_TEST:\n\t\t \n\t\tgsm_control_reply(gsm, CMD_TEST, data, clen);\n\t\tbreak;\n\tcase CMD_FCON:\n\t\t \n\t\tgsm->constipated = false;\n\t\tgsm_control_reply(gsm, CMD_FCON, NULL, 0);\n\t\t \n\t\tgsmld_write_trigger(gsm);\n\t\tbreak;\n\tcase CMD_FCOFF:\n\t\t \n\t\tgsm->constipated = true;\n\t\tgsm_control_reply(gsm, CMD_FCOFF, NULL, 0);\n\t\tbreak;\n\tcase CMD_MSC:\n\t\t \n\t\tgsm_control_modem(gsm, data, clen);\n\t\tbreak;\n\tcase CMD_RLS:\n\t\t \n\t\tgsm_control_rls(gsm, data, clen);\n\t\tbreak;\n\tcase CMD_PSC:\n\t\t \n\t\tgsm_control_reply(gsm, CMD_PSC, NULL, 0);\n\t\tbreak;\n\t\t \n\tcase CMD_PN:\n\t\t \n\t\tgsm_control_negotiation(gsm, 1, data, clen);\n\t\tbreak;\n\t\t \n\tcase CMD_RPN:\t \n\tcase CMD_SNC:\t \n\t\tgsm->unsupported++;\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tbuf[0] = command;\n\t\tgsm_control_reply(gsm, CMD_NSC, buf, 1);\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void gsm_control_response(struct gsm_mux *gsm, unsigned int command,\n\t\t\t\t\t\tconst u8 *data, int clen)\n{\n\tstruct gsm_control *ctrl;\n\tstruct gsm_dlci *dlci;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\n\tctrl = gsm->pending_cmd;\n\tdlci = gsm->dlci[0];\n\tcommand |= 1;\n\t \n\tif (ctrl != NULL && (command == ctrl->cmd || command == CMD_NSC)) {\n\t\t \n\t\tdel_timer(&gsm->t2_timer);\n\t\tgsm->pending_cmd = NULL;\n\t\t \n\t\tif (command == CMD_NSC)\n\t\t\tctrl->error = -EOPNOTSUPP;\n\t\tctrl->done = 1;\n\t\twake_up(&gsm->event);\n\t \n\t} else if (command == CMD_PN) {\n\t\tgsm_control_negotiation(gsm, 0, data, clen);\n\t \n\t} else if (command == CMD_TEST && clen == 1 && *data == gsm->ka_num) {\n\t\tgsm->ka_retries = -1;  \n\t\tif (dlci && !dlci->dead)\n\t\t\tmod_timer(&gsm->ka_timer, jiffies + gsm->keep_alive * HZ / 100);\n\t}\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n}\n\n \n\nstatic void gsm_control_keep_alive(struct timer_list *t)\n{\n\tstruct gsm_mux *gsm = from_timer(gsm, t, ka_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\tif (gsm->ka_num && gsm->ka_retries == 0) {\n\t\t \n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_debug(\"%s keep-alive timed out\\n\", __func__);\n\t\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\t\tif (gsm->dlci[0])\n\t\t\tgsm_dlci_begin_close(gsm->dlci[0]);\n\t\treturn;\n\t} else if (gsm->keep_alive && gsm->dlci[0] && !gsm->dlci[0]->dead) {\n\t\tif (gsm->ka_retries > 0) {\n\t\t\t \n\t\t\tgsm->ka_retries--;\n\t\t} else {\n\t\t\t \n\t\t\tgsm->ka_num++;\n\t\t\tif (!gsm->ka_num)\n\t\t\t\tgsm->ka_num++;\n\t\t\tgsm->ka_retries = (signed int)gsm->n2;\n\t\t}\n\t\tgsm_control_command(gsm, CMD_TEST, &gsm->ka_num,\n\t\t\t\t    sizeof(gsm->ka_num));\n\t\tmod_timer(&gsm->ka_timer,\n\t\t\t  jiffies + gsm->t2 * HZ / 100);\n\t}\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n}\n\n \n\nstatic void gsm_control_transmit(struct gsm_mux *gsm, struct gsm_control *ctrl)\n{\n\tgsm_control_command(gsm, ctrl->cmd, ctrl->data, ctrl->len);\n}\n\n \n\nstatic void gsm_control_retransmit(struct timer_list *t)\n{\n\tstruct gsm_mux *gsm = from_timer(gsm, t, t2_timer);\n\tstruct gsm_control *ctrl;\n\tunsigned long flags;\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\tctrl = gsm->pending_cmd;\n\tif (ctrl) {\n\t\tif (gsm->cretries == 0 || !gsm->dlci[0] || gsm->dlci[0]->dead) {\n\t\t\tgsm->pending_cmd = NULL;\n\t\t\tctrl->error = -ETIMEDOUT;\n\t\t\tctrl->done = 1;\n\t\t\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\t\t\twake_up(&gsm->event);\n\t\t\treturn;\n\t\t}\n\t\tgsm->cretries--;\n\t\tgsm_control_transmit(gsm, ctrl);\n\t\tmod_timer(&gsm->t2_timer, jiffies + gsm->t2 * HZ / 100);\n\t}\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n}\n\n \n\nstatic struct gsm_control *gsm_control_send(struct gsm_mux *gsm,\n\t\tunsigned int command, u8 *data, int clen)\n{\n\tstruct gsm_control *ctrl = kzalloc(sizeof(struct gsm_control),\n\t\t\t\t\t\tGFP_ATOMIC);\n\tunsigned long flags;\n\tif (ctrl == NULL)\n\t\treturn NULL;\nretry:\n\twait_event(gsm->event, gsm->pending_cmd == NULL);\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\tif (gsm->pending_cmd != NULL) {\n\t\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\t\tgoto retry;\n\t}\n\tctrl->cmd = command;\n\tctrl->data = data;\n\tctrl->len = clen;\n\tgsm->pending_cmd = ctrl;\n\n\t \n\tif (gsm->dlci[0]->mode == DLCI_MODE_ADM)\n\t\tgsm->cretries = 0;\n\telse\n\t\tgsm->cretries = gsm->n2;\n\n\tmod_timer(&gsm->t2_timer, jiffies + gsm->t2 * HZ / 100);\n\tgsm_control_transmit(gsm, ctrl);\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\treturn ctrl;\n}\n\n \n\nstatic int gsm_control_wait(struct gsm_mux *gsm, struct gsm_control *control)\n{\n\tint err;\n\twait_event(gsm->event, control->done == 1);\n\terr = control->error;\n\tkfree(control);\n\treturn err;\n}\n\n\n \n\n \n\n \n\nstatic void gsm_dlci_close(struct gsm_dlci *dlci)\n{\n\tdel_timer(&dlci->t1);\n\tif (debug & DBG_ERRORS)\n\t\tpr_debug(\"DLCI %d goes closed.\\n\", dlci->addr);\n\tdlci->state = DLCI_CLOSED;\n\t \n\tdlci->constipated = true;\n\tif (dlci->addr != 0) {\n\t\ttty_port_tty_hangup(&dlci->port, false);\n\t\tgsm_dlci_clear_queues(dlci->gsm, dlci);\n\t\t \n\t\ttty_port_set_initialized(&dlci->port, false);\n\t\twake_up_interruptible(&dlci->port.open_wait);\n\t} else {\n\t\tdel_timer(&dlci->gsm->ka_timer);\n\t\tdlci->gsm->dead = true;\n\t}\n\t \n\tgsm_dlci_data_kick(dlci);\n\twake_up_all(&dlci->gsm->event);\n}\n\n \n\nstatic void gsm_dlci_open(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\t \n\tdel_timer(&dlci->t1);\n\t \n\tdlci->state = DLCI_OPEN;\n\tdlci->constipated = false;\n\tif (debug & DBG_ERRORS)\n\t\tpr_debug(\"DLCI %d goes open.\\n\", dlci->addr);\n\t \n\tif (dlci->addr) {\n\t\tgsm_modem_update(dlci, 0);\n\t} else {\n\t\t \n\t\tgsm->ka_num = 0;\n\t\tgsm->ka_retries = -1;\n\t\tmod_timer(&gsm->ka_timer,\n\t\t\t  jiffies + gsm->keep_alive * HZ / 100);\n\t}\n\tgsm_dlci_data_kick(dlci);\n\twake_up(&dlci->gsm->event);\n}\n\n \nstatic int gsm_dlci_negotiate(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tstruct gsm_dlci_param_bits params;\n\tint ret;\n\n\tret = gsm_encode_params(dlci, &params);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tret = gsm_control_command(gsm, CMD_PN, (const u8 *)&params,\n\t\t\t\t  sizeof(params));\n\n\treturn ret;\n}\n\n \n\nstatic void gsm_dlci_t1(struct timer_list *t)\n{\n\tstruct gsm_dlci *dlci = from_timer(dlci, t, t1);\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\tswitch (dlci->state) {\n\tcase DLCI_CONFIGURE:\n\t\tif (dlci->retries && gsm_dlci_negotiate(dlci) == 0) {\n\t\t\tdlci->retries--;\n\t\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\t} else {\n\t\t\tgsm->open_error++;\n\t\t\tgsm_dlci_begin_close(dlci);  \n\t\t}\n\t\tbreak;\n\tcase DLCI_OPENING:\n\t\tif (dlci->retries) {\n\t\t\tdlci->retries--;\n\t\t\tgsm_command(dlci->gsm, dlci->addr, SABM|PF);\n\t\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\t} else if (!dlci->addr && gsm->control == (DM | PF)) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"DLCI %d opening in ADM mode.\\n\",\n\t\t\t\t\tdlci->addr);\n\t\t\tdlci->mode = DLCI_MODE_ADM;\n\t\t\tgsm_dlci_open(dlci);\n\t\t} else {\n\t\t\tgsm->open_error++;\n\t\t\tgsm_dlci_begin_close(dlci);  \n\t\t}\n\n\t\tbreak;\n\tcase DLCI_CLOSING:\n\t\tif (dlci->retries) {\n\t\t\tdlci->retries--;\n\t\t\tgsm_command(dlci->gsm, dlci->addr, DISC|PF);\n\t\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\t} else\n\t\t\tgsm_dlci_close(dlci);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__, dlci->state);\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void gsm_dlci_begin_open(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci ? dlci->gsm : NULL;\n\tbool need_pn = false;\n\n\tif (!gsm)\n\t\treturn;\n\n\tif (dlci->addr != 0) {\n\t\tif (gsm->adaption != 1 || gsm->adaption != dlci->adaption)\n\t\t\tneed_pn = true;\n\t\tif (dlci->prio != (roundup(dlci->addr + 1, 8) - 1))\n\t\t\tneed_pn = true;\n\t\tif (gsm->ftype != dlci->ftype)\n\t\t\tneed_pn = true;\n\t}\n\n\tswitch (dlci->state) {\n\tcase DLCI_CLOSED:\n\tcase DLCI_WAITING_CONFIG:\n\tcase DLCI_CLOSING:\n\t\tdlci->retries = gsm->n2;\n\t\tif (!need_pn) {\n\t\t\tdlci->state = DLCI_OPENING;\n\t\t\tgsm_command(gsm, dlci->addr, SABM|PF);\n\t\t} else {\n\t\t\t \n\t\t\tdlci->state = DLCI_CONFIGURE;\n\t\t\tif (gsm_dlci_negotiate(dlci) != 0) {\n\t\t\t\tgsm_dlci_close(dlci);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void gsm_dlci_set_opening(struct gsm_dlci *dlci)\n{\n\tswitch (dlci->state) {\n\tcase DLCI_CLOSED:\n\tcase DLCI_WAITING_CONFIG:\n\tcase DLCI_CLOSING:\n\t\tdlci->state = DLCI_OPENING;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void gsm_dlci_set_wait_config(struct gsm_dlci *dlci)\n{\n\tswitch (dlci->state) {\n\tcase DLCI_CLOSED:\n\tcase DLCI_CLOSING:\n\t\tdlci->state = DLCI_WAITING_CONFIG;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void gsm_dlci_begin_close(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tif (dlci->state == DLCI_CLOSED || dlci->state == DLCI_CLOSING)\n\t\treturn;\n\tdlci->retries = gsm->n2;\n\tdlci->state = DLCI_CLOSING;\n\tgsm_command(dlci->gsm, dlci->addr, DISC|PF);\n\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\twake_up_interruptible(&gsm->event);\n}\n\n \n\nstatic void gsm_dlci_data(struct gsm_dlci *dlci, const u8 *data, int clen)\n{\n\t \n\tstruct tty_port *port = &dlci->port;\n\tstruct tty_struct *tty;\n\tunsigned int modem = 0;\n\tint len;\n\n\tif (debug & DBG_TTY)\n\t\tpr_debug(\"%d bytes for tty\\n\", clen);\n\tswitch (dlci->adaption)  {\n\t \n\tcase 4:\t\t \n\t\tbreak;\n\tcase 3:\t\t \n\t\tbreak;\n\tcase 2:\t\t \n\t\tlen = gsm_read_ea_val(&modem, data, clen);\n\t\tif (len < 1)\n\t\t\treturn;\n\t\ttty = tty_port_tty_get(port);\n\t\tif (tty) {\n\t\t\tgsm_process_modem(tty, dlci, modem, len);\n\t\t\ttty_wakeup(tty);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\t \n\t\tdata += len;\n\t\tclen -= len;\n\t\tfallthrough;\n\tcase 1:\t\t \n\tdefault:\n\t\ttty_insert_flip_string(port, data, clen);\n\t\ttty_flip_buffer_push(port);\n\t}\n}\n\n \n\nstatic void gsm_dlci_command(struct gsm_dlci *dlci, const u8 *data, int len)\n{\n\t \n\tunsigned int command = 0;\n\tunsigned int clen = 0;\n\tunsigned int dlen;\n\n\t \n\tdlen = gsm_read_ea_val(&command, data, len);\n\tlen -= dlen;\n\tdata += dlen;\n\n\t \n\tdlen = gsm_read_ea_val(&clen, data, len);\n\tlen -= dlen;\n\tdata += dlen;\n\n\t \n\tif (clen > len) {\n\t\tdlci->gsm->malformed++;\n\t\treturn;\n\t}\n\n\tif (command & 1)\n\t\tgsm_control_message(dlci->gsm, command, data, clen);\n\telse\n\t\tgsm_control_response(dlci->gsm, command, data, clen);\n}\n\n \nstatic void gsm_kick_timer(struct timer_list *t)\n{\n\tstruct gsm_mux *gsm = from_timer(gsm, t, kick_timer);\n\tunsigned long flags;\n\tint sent = 0;\n\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\t \n\tif (gsm->tx_bytes < TX_THRESH_LO)\n\t\tsent = gsm_dlci_data_sweep(gsm);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\n\tif (sent && debug & DBG_DATA)\n\t\tpr_info(\"%s TX queue stalled\\n\", __func__);\n}\n\n \nstatic void gsm_dlci_copy_config_values(struct gsm_dlci *dlci, struct gsm_dlci_config *dc)\n{\n\tmemset(dc, 0, sizeof(*dc));\n\tdc->channel = (u32)dlci->addr;\n\tdc->adaption = (u32)dlci->adaption;\n\tdc->mtu = (u32)dlci->mtu;\n\tdc->priority = (u32)dlci->prio;\n\tif (dlci->ftype == UIH)\n\t\tdc->i = 1;\n\telse\n\t\tdc->i = 2;\n\tdc->k = (u32)dlci->k;\n}\n\n \nstatic int gsm_dlci_config(struct gsm_dlci *dlci, struct gsm_dlci_config *dc, int open)\n{\n\tstruct gsm_mux *gsm;\n\tbool need_restart = false;\n\tbool need_open = false;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dc->reserved); i++)\n\t\tif (dc->reserved[i])\n\t\t\treturn -EINVAL;\n\n\tif (!dlci)\n\t\treturn -EINVAL;\n\tgsm = dlci->gsm;\n\n\t \n\tif (dc->adaption != 1 && dc->adaption != 2)\n\t\treturn -EOPNOTSUPP;\n\tif (dc->mtu > MAX_MTU || dc->mtu < MIN_MTU || dc->mtu > gsm->mru)\n\t\treturn -EINVAL;\n\tif (dc->priority >= 64)\n\t\treturn -EINVAL;\n\tif (dc->i == 0 || dc->i > 2)   \n\t\treturn -EINVAL;\n\tif (dc->k > 7)\n\t\treturn -EINVAL;\n\tif (dc->flags & ~GSM_FL_RESTART)    \n\t\treturn -EINVAL;\n\n\t \n\t \n\tif (dc->adaption != dlci->adaption)\n\t\tneed_restart = true;\n\tif (dc->mtu != dlci->mtu)\n\t\tneed_restart = true;\n\tif (dc->i != dlci->ftype)\n\t\tneed_restart = true;\n\t \n\tif (dc->priority != dlci->prio)\n\t\tneed_restart = true;\n\tif (dc->flags & GSM_FL_RESTART)\n\t\tneed_restart = true;\n\n\tif ((open && gsm->wait_config) || need_restart)\n\t\tneed_open = true;\n\tif (dlci->state == DLCI_WAITING_CONFIG) {\n\t\tneed_restart = false;\n\t\tneed_open = true;\n\t}\n\n\t \n\tif (need_restart) {\n\t\tgsm_dlci_begin_close(dlci);\n\t\twait_event_interruptible(gsm->event, dlci->state == DLCI_CLOSED);\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t}\n\t \n\tdlci->adaption = (int)dc->adaption;\n\n\tif (dc->mtu)\n\t\tdlci->mtu = (unsigned int)dc->mtu;\n\telse\n\t\tdlci->mtu = gsm->mtu;\n\n\tif (dc->priority)\n\t\tdlci->prio = (u8)dc->priority;\n\telse\n\t\tdlci->prio = roundup(dlci->addr + 1, 8) - 1;\n\n\tif (dc->i == 1)\n\t\tdlci->ftype = UIH;\n\telse if (dc->i == 2)\n\t\tdlci->ftype = UI;\n\n\tif (dc->k)\n\t\tdlci->k = (u8)dc->k;\n\telse\n\t\tdlci->k = gsm->k;\n\n\tif (need_open) {\n\t\tif (gsm->initiator)\n\t\t\tgsm_dlci_begin_open(dlci);\n\t\telse\n\t\t\tgsm_dlci_set_opening(dlci);\n\t}\n\n\treturn 0;\n}\n\n \n\n \n\nstatic struct gsm_dlci *gsm_dlci_alloc(struct gsm_mux *gsm, int addr)\n{\n\tstruct gsm_dlci *dlci = kzalloc(sizeof(struct gsm_dlci), GFP_ATOMIC);\n\tif (dlci == NULL)\n\t\treturn NULL;\n\tspin_lock_init(&dlci->lock);\n\tmutex_init(&dlci->mutex);\n\tif (kfifo_alloc(&dlci->fifo, TX_SIZE, GFP_KERNEL) < 0) {\n\t\tkfree(dlci);\n\t\treturn NULL;\n\t}\n\n\tskb_queue_head_init(&dlci->skb_list);\n\ttimer_setup(&dlci->t1, gsm_dlci_t1, 0);\n\ttty_port_init(&dlci->port);\n\tdlci->port.ops = &gsm_port_ops;\n\tdlci->gsm = gsm;\n\tdlci->addr = addr;\n\tdlci->adaption = gsm->adaption;\n\tdlci->mtu = gsm->mtu;\n\tif (addr == 0)\n\t\tdlci->prio = 0;\n\telse\n\t\tdlci->prio = roundup(addr + 1, 8) - 1;\n\tdlci->ftype = gsm->ftype;\n\tdlci->k = gsm->k;\n\tdlci->state = DLCI_CLOSED;\n\tif (addr) {\n\t\tdlci->data = gsm_dlci_data;\n\t\t \n\t\tdlci->constipated = true;\n\t} else {\n\t\tdlci->data = gsm_dlci_command;\n\t}\n\tgsm->dlci[addr] = dlci;\n\treturn dlci;\n}\n\n \nstatic void gsm_dlci_free(struct tty_port *port)\n{\n\tstruct gsm_dlci *dlci = container_of(port, struct gsm_dlci, port);\n\n\ttimer_shutdown_sync(&dlci->t1);\n\tdlci->gsm->dlci[dlci->addr] = NULL;\n\tkfifo_free(&dlci->fifo);\n\twhile ((dlci->skb = skb_dequeue(&dlci->skb_list)))\n\t\tdev_kfree_skb(dlci->skb);\n\tkfree(dlci);\n}\n\nstatic inline void dlci_get(struct gsm_dlci *dlci)\n{\n\ttty_port_get(&dlci->port);\n}\n\nstatic inline void dlci_put(struct gsm_dlci *dlci)\n{\n\ttty_port_put(&dlci->port);\n}\n\nstatic void gsm_destroy_network(struct gsm_dlci *dlci);\n\n \nstatic void gsm_dlci_release(struct gsm_dlci *dlci)\n{\n\tstruct tty_struct *tty = tty_port_tty_get(&dlci->port);\n\tif (tty) {\n\t\tmutex_lock(&dlci->mutex);\n\t\tgsm_destroy_network(dlci);\n\t\tmutex_unlock(&dlci->mutex);\n\n\t\t \n\t\ttty_vhangup(tty);\n\n\t\ttty_port_tty_set(&dlci->port, NULL);\n\t\ttty_kref_put(tty);\n\t}\n\tdlci->state = DLCI_CLOSED;\n\tdlci_put(dlci);\n}\n\n \n\n \n\nstatic void gsm_queue(struct gsm_mux *gsm)\n{\n\tstruct gsm_dlci *dlci;\n\tu8 cr;\n\tint address;\n\n\tif (gsm->fcs != GOOD_FCS) {\n\t\tgsm->bad_fcs++;\n\t\tif (debug & DBG_DATA)\n\t\t\tpr_debug(\"BAD FCS %02x\\n\", gsm->fcs);\n\t\treturn;\n\t}\n\taddress = gsm->address >> 1;\n\tif (address >= NUM_DLCI)\n\t\tgoto invalid;\n\n\tcr = gsm->address & 1;\t\t \n\tcr ^= gsm->initiator ? 0 : 1;\t \n\n\tgsm_print_packet(\"<--\", address, cr, gsm->control, gsm->buf, gsm->len);\n\n\tdlci = gsm->dlci[address];\n\n\tswitch (gsm->control) {\n\tcase SABM|PF:\n\t\tif (cr == 1) {\n\t\t\tgsm->open_error++;\n\t\t\tgoto invalid;\n\t\t}\n\t\tif (dlci == NULL)\n\t\t\tdlci = gsm_dlci_alloc(gsm, address);\n\t\tif (dlci == NULL) {\n\t\t\tgsm->open_error++;\n\t\t\treturn;\n\t\t}\n\t\tif (dlci->dead)\n\t\t\tgsm_response(gsm, address, DM|PF);\n\t\telse {\n\t\t\tgsm_response(gsm, address, UA|PF);\n\t\t\tgsm_dlci_open(dlci);\n\t\t}\n\t\tbreak;\n\tcase DISC|PF:\n\t\tif (cr == 1)\n\t\t\tgoto invalid;\n\t\tif (dlci == NULL || dlci->state == DLCI_CLOSED) {\n\t\t\tgsm_response(gsm, address, DM|PF);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tgsm_response(gsm, address, UA|PF);\n\t\tgsm_dlci_close(dlci);\n\t\tbreak;\n\tcase UA|PF:\n\t\tif (cr == 0 || dlci == NULL)\n\t\t\tbreak;\n\t\tswitch (dlci->state) {\n\t\tcase DLCI_CLOSING:\n\t\t\tgsm_dlci_close(dlci);\n\t\t\tbreak;\n\t\tcase DLCI_OPENING:\n\t\t\tgsm_dlci_open(dlci);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__,\n\t\t\t\t\tdlci->state);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DM:\t \n\tcase DM|PF:\n\t\tif (cr)\n\t\t\tgoto invalid;\n\t\tif (dlci == NULL)\n\t\t\treturn;\n\t\tgsm_dlci_close(dlci);\n\t\tbreak;\n\tcase UI:\n\tcase UI|PF:\n\tcase UIH:\n\tcase UIH|PF:\n\t\tif (dlci == NULL || dlci->state != DLCI_OPEN) {\n\t\t\tgsm_response(gsm, address, DM|PF);\n\t\t\treturn;\n\t\t}\n\t\tdlci->data(dlci, gsm->buf, gsm->len);\n\t\tbreak;\n\tdefault:\n\t\tgoto invalid;\n\t}\n\treturn;\ninvalid:\n\tgsm->malformed++;\n\treturn;\n}\n\n\n \n\nstatic void gsm0_receive(struct gsm_mux *gsm, unsigned char c)\n{\n\tunsigned int len;\n\n\tswitch (gsm->state) {\n\tcase GSM_SEARCH:\t \n\t\tif (c == GSM0_SOF) {\n\t\t\tgsm->state = GSM_ADDRESS;\n\t\t\tgsm->address = 0;\n\t\t\tgsm->len = 0;\n\t\t\tgsm->fcs = INIT_FCS;\n\t\t}\n\t\tbreak;\n\tcase GSM_ADDRESS:\t \n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tif (gsm_read_ea(&gsm->address, c))\n\t\t\tgsm->state = GSM_CONTROL;\n\t\tbreak;\n\tcase GSM_CONTROL:\t \n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tgsm->control = c;\n\t\tgsm->state = GSM_LEN0;\n\t\tbreak;\n\tcase GSM_LEN0:\t\t \n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tif (gsm_read_ea(&gsm->len, c)) {\n\t\t\tif (gsm->len > gsm->mru) {\n\t\t\t\tgsm->bad_size++;\n\t\t\t\tgsm->state = GSM_SEARCH;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgsm->count = 0;\n\t\t\tif (!gsm->len)\n\t\t\t\tgsm->state = GSM_FCS;\n\t\t\telse\n\t\t\t\tgsm->state = GSM_DATA;\n\t\t\tbreak;\n\t\t}\n\t\tgsm->state = GSM_LEN1;\n\t\tbreak;\n\tcase GSM_LEN1:\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tlen = c;\n\t\tgsm->len |= len << 7;\n\t\tif (gsm->len > gsm->mru) {\n\t\t\tgsm->bad_size++;\n\t\t\tgsm->state = GSM_SEARCH;\n\t\t\tbreak;\n\t\t}\n\t\tgsm->count = 0;\n\t\tif (!gsm->len)\n\t\t\tgsm->state = GSM_FCS;\n\t\telse\n\t\t\tgsm->state = GSM_DATA;\n\t\tbreak;\n\tcase GSM_DATA:\t\t \n\t\tgsm->buf[gsm->count++] = c;\n\t\tif (gsm->count == gsm->len) {\n\t\t\t \n\t\t\tif ((gsm->control & ~PF) != UIH) {\n\t\t\t\tgsm->fcs = gsm_fcs_add_block(gsm->fcs, gsm->buf,\n\t\t\t\t\t\t\t     gsm->count);\n\t\t\t}\n\t\t\tgsm->state = GSM_FCS;\n\t\t}\n\t\tbreak;\n\tcase GSM_FCS:\t\t \n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tgsm->state = GSM_SSOF;\n\t\tbreak;\n\tcase GSM_SSOF:\n\t\tgsm->state = GSM_SEARCH;\n\t\tif (c == GSM0_SOF)\n\t\t\tgsm_queue(gsm);\n\t\telse\n\t\t\tgsm->bad_size++;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__, gsm->state);\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void gsm1_receive(struct gsm_mux *gsm, unsigned char c)\n{\n\t \n\tif ((c & ISO_IEC_646_MASK) == XON) {\n\t\tgsm->constipated = true;\n\t\treturn;\n\t} else if ((c & ISO_IEC_646_MASK) == XOFF) {\n\t\tgsm->constipated = false;\n\t\t \n\t\tgsmld_write_trigger(gsm);\n\t\treturn;\n\t}\n\tif (c == GSM1_SOF) {\n\t\t \n\t\tif (gsm->state == GSM_DATA) {\n\t\t\tif (gsm->count < 1) {\n\t\t\t\t \n\t\t\t\tgsm->malformed++;\n\t\t\t\tgsm->state = GSM_START;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tgsm->count--;\n\t\t\tif ((gsm->control & ~PF) != UIH) {\n\t\t\t\t \n\t\t\t\tgsm->fcs = gsm_fcs_add_block(gsm->fcs, gsm->buf,\n\t\t\t\t\t\t\t     gsm->count);\n\t\t\t}\n\t\t\t \n\t\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, gsm->buf[gsm->count]);\n\t\t\tgsm->len = gsm->count;\n\t\t\tgsm_queue(gsm);\n\t\t\tgsm->state  = GSM_START;\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (gsm->state != GSM_START) {\n\t\t\tif (gsm->state != GSM_SEARCH)\n\t\t\t\tgsm->malformed++;\n\t\t\tgsm->state = GSM_START;\n\t\t}\n\t\t \n\t\treturn;\n\t}\n\n\tif (c == GSM1_ESCAPE) {\n\t\tgsm->escape = true;\n\t\treturn;\n\t}\n\n\t \n\tif (gsm->state == GSM_SEARCH)\n\t\treturn;\n\n\tif (gsm->escape) {\n\t\tc ^= GSM1_ESCAPE_BITS;\n\t\tgsm->escape = false;\n\t}\n\tswitch (gsm->state) {\n\tcase GSM_START:\t\t \n\t\tgsm->address = 0;\n\t\tgsm->state = GSM_ADDRESS;\n\t\tgsm->fcs = INIT_FCS;\n\t\tfallthrough;\n\tcase GSM_ADDRESS:\t \n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tif (gsm_read_ea(&gsm->address, c))\n\t\t\tgsm->state = GSM_CONTROL;\n\t\tbreak;\n\tcase GSM_CONTROL:\t \n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tgsm->control = c;\n\t\tgsm->count = 0;\n\t\tgsm->state = GSM_DATA;\n\t\tbreak;\n\tcase GSM_DATA:\t\t \n\t\tif (gsm->count > gsm->mru) {\t \n\t\t\tgsm->state = GSM_OVERRUN;\n\t\t\tgsm->bad_size++;\n\t\t} else\n\t\t\tgsm->buf[gsm->count++] = c;\n\t\tbreak;\n\tcase GSM_OVERRUN:\t \n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__, gsm->state);\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void gsm_error(struct gsm_mux *gsm)\n{\n\tgsm->state = GSM_SEARCH;\n\tgsm->io_error++;\n}\n\n \n\nstatic void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)\n{\n\tint i;\n\tstruct gsm_dlci *dlci;\n\tstruct gsm_msg *txq, *ntxq;\n\n\tgsm->dead = true;\n\tmutex_lock(&gsm->mutex);\n\n\tdlci = gsm->dlci[0];\n\tif (dlci) {\n\t\tif (disc && dlci->state != DLCI_CLOSED) {\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t\twait_event(gsm->event, dlci->state == DLCI_CLOSED);\n\t\t}\n\t\tdlci->dead = true;\n\t}\n\n\t \n\tdel_timer_sync(&gsm->kick_timer);\n\tdel_timer_sync(&gsm->t2_timer);\n\tdel_timer_sync(&gsm->ka_timer);\n\n\t \n\tflush_work(&gsm->tx_work);\n\n\t \n\tif (gsm->has_devices) {\n\t\tgsm_unregister_devices(gsm_tty_driver, gsm->num);\n\t\tgsm->has_devices = false;\n\t}\n\tfor (i = NUM_DLCI - 1; i >= 0; i--)\n\t\tif (gsm->dlci[i])\n\t\t\tgsm_dlci_release(gsm->dlci[i]);\n\tmutex_unlock(&gsm->mutex);\n\t \n\ttty_ldisc_flush(gsm->tty);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_ctrl_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_data_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n}\n\n \n\nstatic int gsm_activate_mux(struct gsm_mux *gsm)\n{\n\tstruct gsm_dlci *dlci;\n\tint ret;\n\n\tdlci = gsm_dlci_alloc(gsm, 0);\n\tif (dlci == NULL)\n\t\treturn -ENOMEM;\n\n\tif (gsm->encoding == GSM_BASIC_OPT)\n\t\tgsm->receive = gsm0_receive;\n\telse\n\t\tgsm->receive = gsm1_receive;\n\n\tret = gsm_register_devices(gsm_tty_driver, gsm->num);\n\tif (ret)\n\t\treturn ret;\n\n\tgsm->has_devices = true;\n\tgsm->dead = false;\t\t \n\treturn 0;\n}\n\n \nstatic void gsm_free_mux(struct gsm_mux *gsm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_MUX; i++) {\n\t\tif (gsm == gsm_mux[i]) {\n\t\t\tgsm_mux[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_destroy(&gsm->mutex);\n\tkfree(gsm->txframe);\n\tkfree(gsm->buf);\n\tkfree(gsm);\n}\n\n \nstatic void gsm_free_muxr(struct kref *ref)\n{\n\tstruct gsm_mux *gsm = container_of(ref, struct gsm_mux, ref);\n\tgsm_free_mux(gsm);\n}\n\nstatic inline void mux_get(struct gsm_mux *gsm)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm_mux_lock, flags);\n\tkref_get(&gsm->ref);\n\tspin_unlock_irqrestore(&gsm_mux_lock, flags);\n}\n\nstatic inline void mux_put(struct gsm_mux *gsm)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm_mux_lock, flags);\n\tkref_put(&gsm->ref, gsm_free_muxr);\n\tspin_unlock_irqrestore(&gsm_mux_lock, flags);\n}\n\nstatic inline unsigned int mux_num_to_base(struct gsm_mux *gsm)\n{\n\treturn gsm->num * NUM_DLCI;\n}\n\nstatic inline unsigned int mux_line_to_num(unsigned int line)\n{\n\treturn line / NUM_DLCI;\n}\n\n \n\nstatic struct gsm_mux *gsm_alloc_mux(void)\n{\n\tint i;\n\tstruct gsm_mux *gsm = kzalloc(sizeof(struct gsm_mux), GFP_KERNEL);\n\tif (gsm == NULL)\n\t\treturn NULL;\n\tgsm->buf = kmalloc(MAX_MRU + 1, GFP_KERNEL);\n\tif (gsm->buf == NULL) {\n\t\tkfree(gsm);\n\t\treturn NULL;\n\t}\n\tgsm->txframe = kmalloc(2 * (MAX_MTU + PROT_OVERHEAD - 1), GFP_KERNEL);\n\tif (gsm->txframe == NULL) {\n\t\tkfree(gsm->buf);\n\t\tkfree(gsm);\n\t\treturn NULL;\n\t}\n\tspin_lock_init(&gsm->lock);\n\tmutex_init(&gsm->mutex);\n\tkref_init(&gsm->ref);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n\ttimer_setup(&gsm->kick_timer, gsm_kick_timer, 0);\n\ttimer_setup(&gsm->t2_timer, gsm_control_retransmit, 0);\n\ttimer_setup(&gsm->ka_timer, gsm_control_keep_alive, 0);\n\tINIT_WORK(&gsm->tx_work, gsmld_write_task);\n\tinit_waitqueue_head(&gsm->event);\n\tspin_lock_init(&gsm->control_lock);\n\tspin_lock_init(&gsm->tx_lock);\n\n\tgsm->t1 = T1;\n\tgsm->t2 = T2;\n\tgsm->t3 = T3;\n\tgsm->n2 = N2;\n\tgsm->k = K;\n\tgsm->ftype = UIH;\n\tgsm->adaption = 1;\n\tgsm->encoding = GSM_ADV_OPT;\n\tgsm->mru = 64;\t \n\tgsm->mtu = 64;\n\tgsm->dead = true;\t \n\tgsm->wait_config = false;  \n\tgsm->keep_alive = 0;\t \n\n\t \n\tspin_lock(&gsm_mux_lock);\n\tfor (i = 0; i < MAX_MUX; i++) {\n\t\tif (!gsm_mux[i]) {\n\t\t\tgsm_mux[i] = gsm;\n\t\t\tgsm->num = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&gsm_mux_lock);\n\tif (i == MAX_MUX) {\n\t\tmutex_destroy(&gsm->mutex);\n\t\tkfree(gsm->txframe);\n\t\tkfree(gsm->buf);\n\t\tkfree(gsm);\n\t\treturn NULL;\n\t}\n\n\treturn gsm;\n}\n\nstatic void gsm_copy_config_values(struct gsm_mux *gsm,\n\t\t\t\t   struct gsm_config *c)\n{\n\tmemset(c, 0, sizeof(*c));\n\tc->adaption = gsm->adaption;\n\tc->encapsulation = gsm->encoding;\n\tc->initiator = gsm->initiator;\n\tc->t1 = gsm->t1;\n\tc->t2 = gsm->t2;\n\tc->t3 = gsm->t3;\n\tc->n2 = gsm->n2;\n\tif (gsm->ftype == UIH)\n\t\tc->i = 1;\n\telse\n\t\tc->i = 2;\n\tpr_debug(\"Ftype %d i %d\\n\", gsm->ftype, c->i);\n\tc->mru = gsm->mru;\n\tc->mtu = gsm->mtu;\n\tc->k = gsm->k;\n}\n\nstatic int gsm_config(struct gsm_mux *gsm, struct gsm_config *c)\n{\n\tint need_close = 0;\n\tint need_restart = 0;\n\n\t \n\tif (c->adaption != 1 && c->adaption != 2)\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (c->mru < MIN_MTU || c->mtu < MIN_MTU)\n\t\treturn -EINVAL;\n\tif (c->mru > MAX_MRU || c->mtu > MAX_MTU)\n\t\treturn -EINVAL;\n\tif (c->t3 > MAX_T3)\n\t\treturn -EINVAL;\n\tif (c->n2 > 255)\n\t\treturn -EINVAL;\n\tif (c->encapsulation > 1)\t \n\t\treturn -EINVAL;\n\tif (c->initiator > 1)\n\t\treturn -EINVAL;\n\tif (c->k > MAX_WINDOW_SIZE)\n\t\treturn -EINVAL;\n\tif (c->i == 0 || c->i > 2)\t \n\t\treturn -EINVAL;\n\t \n\n\t \n\tif (c->t1 != 0 && c->t1 != gsm->t1)\n\t\tneed_restart = 1;\n\tif (c->t2 != 0 && c->t2 != gsm->t2)\n\t\tneed_restart = 1;\n\tif (c->encapsulation != gsm->encoding)\n\t\tneed_restart = 1;\n\tif (c->adaption != gsm->adaption)\n\t\tneed_restart = 1;\n\t \n\tif (c->initiator != gsm->initiator)\n\t\tneed_close = 1;\n\tif (c->mru != gsm->mru)\n\t\tneed_restart = 1;\n\tif (c->mtu != gsm->mtu)\n\t\tneed_restart = 1;\n\n\t \n\tif (need_close || need_restart)\n\t\tgsm_cleanup_mux(gsm, true);\n\n\tgsm->initiator = c->initiator;\n\tgsm->mru = c->mru;\n\tgsm->mtu = c->mtu;\n\tgsm->encoding = c->encapsulation ? GSM_ADV_OPT : GSM_BASIC_OPT;\n\tgsm->adaption = c->adaption;\n\tgsm->n2 = c->n2;\n\n\tif (c->i == 1)\n\t\tgsm->ftype = UIH;\n\telse if (c->i == 2)\n\t\tgsm->ftype = UI;\n\n\tif (c->t1)\n\t\tgsm->t1 = c->t1;\n\tif (c->t2)\n\t\tgsm->t2 = c->t2;\n\tif (c->t3)\n\t\tgsm->t3 = c->t3;\n\tif (c->k)\n\t\tgsm->k = c->k;\n\n\t \n\tif (gsm->dead) {\n\t\tint ret = gsm_activate_mux(gsm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (gsm->initiator)\n\t\t\tgsm_dlci_begin_open(gsm->dlci[0]);\n\t}\n\treturn 0;\n}\n\nstatic void gsm_copy_config_ext_values(struct gsm_mux *gsm,\n\t\t\t\t       struct gsm_config_ext *ce)\n{\n\tmemset(ce, 0, sizeof(*ce));\n\tce->wait_config = gsm->wait_config ? 1 : 0;\n\tce->keep_alive = gsm->keep_alive;\n}\n\nstatic int gsm_config_ext(struct gsm_mux *gsm, struct gsm_config_ext *ce)\n{\n\tbool need_restart = false;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ce->reserved); i++)\n\t\tif (ce->reserved[i])\n\t\t\treturn -EINVAL;\n\tif (ce->flags & ~GSM_FL_RESTART)\n\t\treturn -EINVAL;\n\n\t \n\tif (ce->flags & GSM_FL_RESTART)\n\t\tneed_restart = true;\n\n\t \n\tif (need_restart)\n\t\tgsm_cleanup_mux(gsm, true);\n\n\t \n\tgsm->wait_config = ce->wait_config ? true : false;\n\tgsm->keep_alive = ce->keep_alive;\n\n\tif (gsm->dead) {\n\t\tint ret = gsm_activate_mux(gsm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (gsm->initiator)\n\t\t\tgsm_dlci_begin_open(gsm->dlci[0]);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int gsmld_output(struct gsm_mux *gsm, u8 *data, int len)\n{\n\tif (tty_write_room(gsm->tty) < len) {\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &gsm->tty->flags);\n\t\treturn -ENOSPC;\n\t}\n\tif (debug & DBG_DATA)\n\t\tgsm_hex_dump_bytes(__func__, data, len);\n\treturn gsm->tty->ops->write(gsm->tty, data, len);\n}\n\n\n \nstatic void gsmld_write_trigger(struct gsm_mux *gsm)\n{\n\tif (!gsm || !gsm->dlci[0] || gsm->dlci[0]->dead)\n\t\treturn;\n\tschedule_work(&gsm->tx_work);\n}\n\n\n \nstatic void gsmld_write_task(struct work_struct *work)\n{\n\tstruct gsm_mux *gsm = container_of(work, struct gsm_mux, tx_work);\n\tunsigned long flags;\n\tint i, ret;\n\n\t \n\tret = -ENODEV;\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tif (gsm->tty)\n\t\tret = gsm_data_kick(gsm);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\n\tif (ret >= 0)\n\t\tfor (i = 0; i < NUM_DLCI; i++)\n\t\t\tif (gsm->dlci[i])\n\t\t\t\ttty_port_tty_wakeup(&gsm->dlci[i]->port);\n}\n\n \n\nstatic void gsmld_attach_gsm(struct tty_struct *tty, struct gsm_mux *gsm)\n{\n\tgsm->tty = tty_kref_get(tty);\n\t \n\tgsm->old_c_iflag = tty->termios.c_iflag;\n\ttty->termios.c_iflag &= (IXON | IXOFF);\n}\n\n \n\nstatic void gsmld_detach_gsm(struct tty_struct *tty, struct gsm_mux *gsm)\n{\n\tWARN_ON(tty != gsm->tty);\n\t \n\tgsm->tty->termios.c_iflag = gsm->old_c_iflag;\n\ttty_kref_put(gsm->tty);\n\tgsm->tty = NULL;\n}\n\nstatic void gsmld_receive_buf(struct tty_struct *tty, const u8 *cp,\n\t\t\t      const u8 *fp, size_t count)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\tchar flags = TTY_NORMAL;\n\n\tif (debug & DBG_DATA)\n\t\tgsm_hex_dump_bytes(__func__, cp, count);\n\n\tfor (; count; count--, cp++) {\n\t\tif (fp)\n\t\t\tflags = *fp++;\n\t\tswitch (flags) {\n\t\tcase TTY_NORMAL:\n\t\t\tif (gsm->receive)\n\t\t\t\tgsm->receive(gsm, *cp);\n\t\t\tbreak;\n\t\tcase TTY_OVERRUN:\n\t\tcase TTY_BREAK:\n\t\tcase TTY_PARITY:\n\t\tcase TTY_FRAME:\n\t\t\tgsm_error(gsm);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ONCE(1, \"%s: unknown flag %d\\n\",\n\t\t\t       tty_name(tty), flags);\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\t \n}\n\n \n\nstatic void gsmld_flush_buffer(struct tty_struct *tty)\n{\n}\n\n \n\nstatic void gsmld_close(struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\n\t \n\tgsm_cleanup_mux(gsm, false);\n\n\tgsmld_detach_gsm(tty, gsm);\n\n\tgsmld_flush_buffer(tty);\n\t \n\tmux_put(gsm);\n}\n\n \n\nstatic int gsmld_open(struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (tty->ops->write == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tgsm = gsm_alloc_mux();\n\tif (gsm == NULL)\n\t\treturn -ENOMEM;\n\n\ttty->disc_data = gsm;\n\ttty->receive_room = 65536;\n\n\t \n\tgsmld_attach_gsm(tty, gsm);\n\n\t \n\tif (gsm->encoding == GSM_BASIC_OPT)\n\t\tgsm->receive = gsm0_receive;\n\telse\n\t\tgsm->receive = gsm1_receive;\n\n\treturn 0;\n}\n\n \n\nstatic void gsmld_write_wakeup(struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\n\t \n\tgsmld_write_trigger(gsm);\n}\n\n \n\nstatic ssize_t gsmld_read(struct tty_struct *tty, struct file *file, u8 *buf,\n\t\t\t  size_t nr, void **cookie, unsigned long offset)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \n\nstatic ssize_t gsmld_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const u8 *buf, size_t nr)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\tunsigned long flags;\n\tint space;\n\tint ret;\n\n\tif (!gsm)\n\t\treturn -ENODEV;\n\n\tret = -ENOBUFS;\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tspace = tty_write_room(tty);\n\tif (space >= nr)\n\t\tret = tty->ops->write(tty, buf, nr);\n\telse\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\n\treturn ret;\n}\n\n \n\nstatic __poll_t gsmld_poll(struct tty_struct *tty, struct file *file,\n\t\t\t\t\t\t\tpoll_table *wait)\n{\n\t__poll_t mask = 0;\n\tstruct gsm_mux *gsm = tty->disc_data;\n\n\tpoll_wait(file, &tty->read_wait, wait);\n\tpoll_wait(file, &tty->write_wait, wait);\n\n\tif (gsm->dead)\n\t\tmask |= EPOLLHUP;\n\tif (tty_hung_up_p(file))\n\t\tmask |= EPOLLHUP;\n\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\n\t\tmask |= EPOLLHUP;\n\tif (!tty_is_writelocked(tty) && tty_write_room(tty) > 0)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\treturn mask;\n}\n\nstatic int gsmld_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t       unsigned long arg)\n{\n\tstruct gsm_config c;\n\tstruct gsm_config_ext ce;\n\tstruct gsm_dlci_config dc;\n\tstruct gsm_mux *gsm = tty->disc_data;\n\tunsigned int base, addr;\n\tstruct gsm_dlci *dlci;\n\n\tswitch (cmd) {\n\tcase GSMIOC_GETCONF:\n\t\tgsm_copy_config_values(gsm, &c);\n\t\tif (copy_to_user((void __user *)arg, &c, sizeof(c)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF:\n\t\tif (copy_from_user(&c, (void __user *)arg, sizeof(c)))\n\t\t\treturn -EFAULT;\n\t\treturn gsm_config(gsm, &c);\n\tcase GSMIOC_GETFIRST:\n\t\tbase = mux_num_to_base(gsm);\n\t\treturn put_user(base + 1, (__u32 __user *)arg);\n\tcase GSMIOC_GETCONF_EXT:\n\t\tgsm_copy_config_ext_values(gsm, &ce);\n\t\tif (copy_to_user((void __user *)arg, &ce, sizeof(ce)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF_EXT:\n\t\tif (copy_from_user(&ce, (void __user *)arg, sizeof(ce)))\n\t\t\treturn -EFAULT;\n\t\treturn gsm_config_ext(gsm, &ce);\n\tcase GSMIOC_GETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel == 0 || dc.channel >= NUM_DLCI)\n\t\t\treturn -EINVAL;\n\t\taddr = array_index_nospec(dc.channel, NUM_DLCI);\n\t\tdlci = gsm->dlci[addr];\n\t\tif (!dlci) {\n\t\t\tdlci = gsm_dlci_alloc(gsm, addr);\n\t\t\tif (!dlci)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tgsm_dlci_copy_config_values(dlci, &dc);\n\t\tif (copy_to_user((void __user *)arg, &dc, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel == 0 || dc.channel >= NUM_DLCI)\n\t\t\treturn -EINVAL;\n\t\taddr = array_index_nospec(dc.channel, NUM_DLCI);\n\t\tdlci = gsm->dlci[addr];\n\t\tif (!dlci) {\n\t\t\tdlci = gsm_dlci_alloc(gsm, addr);\n\t\t\tif (!dlci)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn gsm_dlci_config(dlci, &dc, 0);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, cmd, arg);\n\t}\n}\n\n \n\nstatic int gsm_mux_net_open(struct net_device *net)\n{\n\tpr_debug(\"%s called\\n\", __func__);\n\tnetif_start_queue(net);\n\treturn 0;\n}\n\nstatic int gsm_mux_net_close(struct net_device *net)\n{\n\tnetif_stop_queue(net);\n\treturn 0;\n}\n\nstatic void dlci_net_free(struct gsm_dlci *dlci)\n{\n\tif (!dlci->net) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tdlci->adaption = dlci->prev_adaption;\n\tdlci->data = dlci->prev_data;\n\tfree_netdev(dlci->net);\n\tdlci->net = NULL;\n}\nstatic void net_free(struct kref *ref)\n{\n\tstruct gsm_mux_net *mux_net;\n\tstruct gsm_dlci *dlci;\n\n\tmux_net = container_of(ref, struct gsm_mux_net, ref);\n\tdlci = mux_net->dlci;\n\n\tif (dlci->net) {\n\t\tunregister_netdev(dlci->net);\n\t\tdlci_net_free(dlci);\n\t}\n}\n\nstatic inline void muxnet_get(struct gsm_mux_net *mux_net)\n{\n\tkref_get(&mux_net->ref);\n}\n\nstatic inline void muxnet_put(struct gsm_mux_net *mux_net)\n{\n\tkref_put(&mux_net->ref, net_free);\n}\n\nstatic netdev_tx_t gsm_mux_net_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *net)\n{\n\tstruct gsm_mux_net *mux_net = netdev_priv(net);\n\tstruct gsm_dlci *dlci = mux_net->dlci;\n\tmuxnet_get(mux_net);\n\n\tskb_queue_head(&dlci->skb_list, skb);\n\tnet->stats.tx_packets++;\n\tnet->stats.tx_bytes += skb->len;\n\tgsm_dlci_data_kick(dlci);\n\t \n\tnetif_trans_update(net);\n\tmuxnet_put(mux_net);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void gsm_mux_net_tx_timeout(struct net_device *net, unsigned int txqueue)\n{\n\t \n\tdev_dbg(&net->dev, \"Tx timed out.\\n\");\n\n\t \n\tnet->stats.tx_errors++;\n}\n\nstatic void gsm_mux_rx_netchar(struct gsm_dlci *dlci,\n\t\t\t\tconst unsigned char *in_buf, int size)\n{\n\tstruct net_device *net = dlci->net;\n\tstruct sk_buff *skb;\n\tstruct gsm_mux_net *mux_net = netdev_priv(net);\n\tmuxnet_get(mux_net);\n\n\t \n\tskb = dev_alloc_skb(size + NET_IP_ALIGN);\n\tif (!skb) {\n\t\t \n\t\tnet->stats.rx_dropped++;\n\t\tmuxnet_put(mux_net);\n\t\treturn;\n\t}\n\tskb_reserve(skb, NET_IP_ALIGN);\n\tskb_put_data(skb, in_buf, size);\n\n\tskb->dev = net;\n\tskb->protocol = htons(ETH_P_IP);\n\n\t \n\tnetif_rx(skb);\n\n\t \n\tnet->stats.rx_packets++;\n\tnet->stats.rx_bytes += size;\n\tmuxnet_put(mux_net);\n\treturn;\n}\n\nstatic void gsm_mux_net_init(struct net_device *net)\n{\n\tstatic const struct net_device_ops gsm_netdev_ops = {\n\t\t.ndo_open\t\t= gsm_mux_net_open,\n\t\t.ndo_stop\t\t= gsm_mux_net_close,\n\t\t.ndo_start_xmit\t\t= gsm_mux_net_start_xmit,\n\t\t.ndo_tx_timeout\t\t= gsm_mux_net_tx_timeout,\n\t};\n\n\tnet->netdev_ops = &gsm_netdev_ops;\n\n\t \n\tnet->watchdog_timeo = GSM_NET_TX_TIMEOUT;\n\tnet->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\tnet->type = ARPHRD_NONE;\n\tnet->tx_queue_len = 10;\n}\n\n\n \nstatic void gsm_destroy_network(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux_net *mux_net;\n\n\tpr_debug(\"destroy network interface\\n\");\n\tif (!dlci->net)\n\t\treturn;\n\tmux_net = netdev_priv(dlci->net);\n\tmuxnet_put(mux_net);\n}\n\n\n \nstatic int gsm_create_network(struct gsm_dlci *dlci, struct gsm_netconfig *nc)\n{\n\tchar *netname;\n\tint retval = 0;\n\tstruct net_device *net;\n\tstruct gsm_mux_net *mux_net;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif (dlci->adaption > 2)\n\t\treturn -EBUSY;\n\n\tif (nc->protocol != htons(ETH_P_IP))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (nc->adaption != 3 && nc->adaption != 4)\n\t\treturn -EPROTONOSUPPORT;\n\n\tpr_debug(\"create network interface\\n\");\n\n\tnetname = \"gsm%d\";\n\tif (nc->if_name[0] != '\\0')\n\t\tnetname = nc->if_name;\n\tnet = alloc_netdev(sizeof(struct gsm_mux_net), netname,\n\t\t\t   NET_NAME_UNKNOWN, gsm_mux_net_init);\n\tif (!net) {\n\t\tpr_err(\"alloc_netdev failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tnet->mtu = dlci->mtu;\n\tnet->min_mtu = MIN_MTU;\n\tnet->max_mtu = dlci->mtu;\n\tmux_net = netdev_priv(net);\n\tmux_net->dlci = dlci;\n\tkref_init(&mux_net->ref);\n\tstrncpy(nc->if_name, net->name, IFNAMSIZ);  \n\n\t \n\tdlci->prev_adaption = dlci->adaption;\n\tdlci->prev_data = dlci->data;\n\tdlci->adaption = nc->adaption;\n\tdlci->data = gsm_mux_rx_netchar;\n\tdlci->net = net;\n\n\tpr_debug(\"register netdev\\n\");\n\tretval = register_netdev(net);\n\tif (retval) {\n\t\tpr_err(\"network register fail %d\\n\", retval);\n\t\tdlci_net_free(dlci);\n\t\treturn retval;\n\t}\n\treturn net->ifindex;\t \n}\n\n \nstatic struct tty_ldisc_ops tty_ldisc_packet = {\n\t.owner\t\t = THIS_MODULE,\n\t.num\t\t = N_GSM0710,\n\t.name            = \"n_gsm\",\n\t.open            = gsmld_open,\n\t.close           = gsmld_close,\n\t.flush_buffer    = gsmld_flush_buffer,\n\t.read            = gsmld_read,\n\t.write           = gsmld_write,\n\t.ioctl           = gsmld_ioctl,\n\t.poll            = gsmld_poll,\n\t.receive_buf     = gsmld_receive_buf,\n\t.write_wakeup    = gsmld_write_wakeup\n};\n\n \n\n \n\nstatic void gsm_modem_upd_via_data(struct gsm_dlci *dlci, u8 brk)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tunsigned long flags;\n\n\tif (dlci->state != DLCI_OPEN || dlci->adaption != 2)\n\t\treturn;\n\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tgsm_dlci_modem_output(gsm, dlci, brk);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n}\n\n \n\nstatic int gsm_modem_upd_via_msc(struct gsm_dlci *dlci, u8 brk)\n{\n\tu8 modembits[3];\n\tstruct gsm_control *ctrl;\n\tint len = 2;\n\n\tif (dlci->gsm->encoding != GSM_BASIC_OPT)\n\t\treturn 0;\n\n\tmodembits[0] = (dlci->addr << 2) | 2 | EA;   \n\tif (!brk) {\n\t\tmodembits[1] = (gsm_encode_modem(dlci) << 1) | EA;\n\t} else {\n\t\tmodembits[1] = gsm_encode_modem(dlci) << 1;\n\t\tmodembits[2] = (brk << 4) | 2 | EA;  \n\t\tlen++;\n\t}\n\tctrl = gsm_control_send(dlci->gsm, CMD_MSC, modembits, len);\n\tif (ctrl == NULL)\n\t\treturn -ENOMEM;\n\treturn gsm_control_wait(dlci->gsm, ctrl);\n}\n\n \n\nstatic int gsm_modem_update(struct gsm_dlci *dlci, u8 brk)\n{\n\tif (dlci->gsm->dead)\n\t\treturn -EL2HLT;\n\tif (dlci->adaption == 2) {\n\t\t \n\t\tgsm_modem_upd_via_data(dlci, brk);\n\t\treturn 0;\n\t} else if (dlci->gsm->encoding == GSM_BASIC_OPT) {\n\t\t \n\t\treturn gsm_modem_upd_via_msc(dlci, brk);\n\t}\n\n\t \n\treturn -EPROTONOSUPPORT;\n}\n\n \nstatic int gsm_wait_modem_change(struct gsm_dlci *dlci, u32 mask)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tu32 old = dlci->modem_rx;\n\tint ret;\n\n\tret = wait_event_interruptible(gsm->event, gsm->dead ||\n\t\t\t\t       dlci->state != DLCI_OPEN ||\n\t\t\t\t       (old ^ dlci->modem_rx) & mask);\n\tif (gsm->dead)\n\t\treturn -ENODEV;\n\tif (dlci->state != DLCI_OPEN)\n\t\treturn -EL2NSYNC;\n\treturn ret;\n}\n\nstatic bool gsm_carrier_raised(struct tty_port *port)\n{\n\tstruct gsm_dlci *dlci = container_of(port, struct gsm_dlci, port);\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\t \n\tif (dlci->state != DLCI_OPEN)\n\t\treturn false;\n\tif (debug & DBG_CD_ON)\n\t\treturn true;\n\n\t \n\tif (gsm->encoding == GSM_BASIC_OPT &&\n\t    gsm->dlci[0]->mode == DLCI_MODE_ADM && !dlci->modem_rx)\n\t\treturn true;\n\n\treturn dlci->modem_rx & TIOCM_CD;\n}\n\nstatic void gsm_dtr_rts(struct tty_port *port, bool active)\n{\n\tstruct gsm_dlci *dlci = container_of(port, struct gsm_dlci, port);\n\tunsigned int modem_tx = dlci->modem_tx;\n\tif (active)\n\t\tmodem_tx |= TIOCM_DTR | TIOCM_RTS;\n\telse\n\t\tmodem_tx &= ~(TIOCM_DTR | TIOCM_RTS);\n\tif (modem_tx != dlci->modem_tx) {\n\t\tdlci->modem_tx = modem_tx;\n\t\tgsm_modem_update(dlci, 0);\n\t}\n}\n\nstatic const struct tty_port_operations gsm_port_ops = {\n\t.carrier_raised = gsm_carrier_raised,\n\t.dtr_rts = gsm_dtr_rts,\n\t.destruct = gsm_dlci_free,\n};\n\nstatic int gsmtty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm;\n\tstruct gsm_dlci *dlci;\n\tunsigned int line = tty->index;\n\tunsigned int mux = mux_line_to_num(line);\n\tbool alloc = false;\n\tint ret;\n\n\tline = line & 0x3F;\n\n\tif (mux >= MAX_MUX)\n\t\treturn -ENXIO;\n\t \n\tif (gsm_mux[mux] == NULL)\n\t\treturn -EUNATCH;\n\tif (line == 0 || line > 61)\t \n\t\treturn -ECHRNG;\n\tgsm = gsm_mux[mux];\n\tif (gsm->dead)\n\t\treturn -EL2HLT;\n\t \n\tmutex_lock(&gsm->mutex);\n\tif (gsm->dlci[0] && gsm->dlci[0]->state != DLCI_OPEN) {\n\t\tmutex_unlock(&gsm->mutex);\n\t\treturn -EL2NSYNC;\n\t}\n\tdlci = gsm->dlci[line];\n\tif (dlci == NULL) {\n\t\talloc = true;\n\t\tdlci = gsm_dlci_alloc(gsm, line);\n\t}\n\tif (dlci == NULL) {\n\t\tmutex_unlock(&gsm->mutex);\n\t\treturn -ENOMEM;\n\t}\n\tret = tty_port_install(&dlci->port, driver, tty);\n\tif (ret) {\n\t\tif (alloc)\n\t\t\tdlci_put(dlci);\n\t\tmutex_unlock(&gsm->mutex);\n\t\treturn ret;\n\t}\n\n\tdlci_get(dlci);\n\tdlci_get(gsm->dlci[0]);\n\tmux_get(gsm);\n\ttty->driver_data = dlci;\n\tmutex_unlock(&gsm->mutex);\n\n\treturn 0;\n}\n\nstatic int gsmtty_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tstruct tty_port *port = &dlci->port;\n\n\tport->count++;\n\ttty_port_tty_set(port, tty);\n\n\tdlci->modem_rx = 0;\n\t \n\ttty_port_set_initialized(port, true);\n\t \n\tif (!dlci->gsm->wait_config) {\n\t\t \n\t\tif (dlci->gsm->initiator)\n\t\t\tgsm_dlci_begin_open(dlci);\n\t\telse\n\t\t\tgsm_dlci_set_opening(dlci);\n\t} else {\n\t\tgsm_dlci_set_wait_config(dlci);\n\t}\n\t \n\treturn tty_port_block_til_ready(port, tty, filp);\n}\n\nstatic void gsmtty_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\n\tif (dlci == NULL)\n\t\treturn;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\tmutex_lock(&dlci->mutex);\n\tgsm_destroy_network(dlci);\n\tmutex_unlock(&dlci->mutex);\n\tif (tty_port_close_start(&dlci->port, tty, filp) == 0)\n\t\treturn;\n\tgsm_dlci_begin_close(dlci);\n\tif (tty_port_initialized(&dlci->port) && C_HUPCL(tty))\n\t\ttty_port_lower_dtr_rts(&dlci->port);\n\ttty_port_close_end(&dlci->port, tty);\n\ttty_port_tty_set(&dlci->port, NULL);\n\treturn;\n}\n\nstatic void gsmtty_hangup(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\ttty_port_hangup(&dlci->port);\n\tgsm_dlci_begin_close(dlci);\n}\n\nstatic ssize_t gsmtty_write(struct tty_struct *tty, const u8 *buf, size_t len)\n{\n\tint sent;\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\t \n\tsent = kfifo_in_locked(&dlci->fifo, buf, len, &dlci->lock);\n\t \n\tgsm_dlci_data_kick(dlci);\n\treturn sent;\n}\n\nstatic unsigned int gsmtty_write_room(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn 0;\n\treturn kfifo_avail(&dlci->fifo);\n}\n\nstatic unsigned int gsmtty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn 0;\n\treturn kfifo_len(&dlci->fifo);\n}\n\nstatic void gsmtty_flush_buffer(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tunsigned long flags;\n\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\t \n\tspin_lock_irqsave(&dlci->lock, flags);\n\tkfifo_reset(&dlci->fifo);\n\tspin_unlock_irqrestore(&dlci->lock, flags);\n\t \n}\n\nstatic void gsmtty_wait_until_sent(struct tty_struct *tty, int timeout)\n{\n\t \n}\n\nstatic int gsmtty_tiocmget(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\treturn dlci->modem_rx;\n}\n\nstatic int gsmtty_tiocmset(struct tty_struct *tty,\n\tunsigned int set, unsigned int clear)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tunsigned int modem_tx = dlci->modem_tx;\n\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\tmodem_tx &= ~clear;\n\tmodem_tx |= set;\n\n\tif (modem_tx != dlci->modem_tx) {\n\t\tdlci->modem_tx = modem_tx;\n\t\treturn gsm_modem_update(dlci, 0);\n\t}\n\treturn 0;\n}\n\n\nstatic int gsmtty_ioctl(struct tty_struct *tty,\n\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tstruct gsm_netconfig nc;\n\tstruct gsm_dlci_config dc;\n\tint index;\n\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\tswitch (cmd) {\n\tcase GSMIOC_ENABLE_NET:\n\t\tif (copy_from_user(&nc, (void __user *)arg, sizeof(nc)))\n\t\t\treturn -EFAULT;\n\t\tnc.if_name[IFNAMSIZ-1] = '\\0';\n\t\t \n\t\tmutex_lock(&dlci->mutex);\n\t\tindex = gsm_create_network(dlci, &nc);\n\t\tmutex_unlock(&dlci->mutex);\n\t\tif (copy_to_user((void __user *)arg, &nc, sizeof(nc)))\n\t\t\treturn -EFAULT;\n\t\treturn index;\n\tcase GSMIOC_DISABLE_NET:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&dlci->mutex);\n\t\tgsm_destroy_network(dlci);\n\t\tmutex_unlock(&dlci->mutex);\n\t\treturn 0;\n\tcase GSMIOC_GETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel != dlci->addr)\n\t\t\treturn -EPERM;\n\t\tgsm_dlci_copy_config_values(dlci, &dc);\n\t\tif (copy_to_user((void __user *)arg, &dc, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel >= NUM_DLCI)\n\t\t\treturn -EINVAL;\n\t\tif (dc.channel != 0 && dc.channel != dlci->addr)\n\t\t\treturn -EPERM;\n\t\treturn gsm_dlci_config(dlci, &dc, 1);\n\tcase TIOCMIWAIT:\n\t\treturn gsm_wait_modem_change(dlci, (u32)arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic void gsmtty_set_termios(struct tty_struct *tty,\n\t\t\t       const struct ktermios *old)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\t \n\ttty_termios_copy_hw(&tty->termios, old);\n}\n\nstatic void gsmtty_throttle(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\tif (C_CRTSCTS(tty))\n\t\tdlci->modem_tx &= ~TIOCM_RTS;\n\tdlci->throttled = true;\n\t \n\tgsm_modem_update(dlci, 0);\n}\n\nstatic void gsmtty_unthrottle(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\tif (C_CRTSCTS(tty))\n\t\tdlci->modem_tx |= TIOCM_RTS;\n\tdlci->throttled = false;\n\t \n\tgsm_modem_update(dlci, 0);\n}\n\nstatic int gsmtty_break_ctl(struct tty_struct *tty, int state)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tint encode = 0;\t \n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\n\tif (state == -1)\t \n\t\tencode = 0x0F;\n\telse if (state > 0) {\n\t\tencode = state / 200;\t \n\t\tif (encode > 0x0F)\n\t\t\tencode = 0x0F;\t \n\t}\n\treturn gsm_modem_update(dlci, encode);\n}\n\nstatic void gsmtty_cleanup(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\tdlci_put(dlci);\n\tdlci_put(gsm->dlci[0]);\n\tmux_put(gsm);\n}\n\n \nstatic const struct tty_operations gsmtty_ops = {\n\t.install\t\t= gsmtty_install,\n\t.open\t\t\t= gsmtty_open,\n\t.close\t\t\t= gsmtty_close,\n\t.write\t\t\t= gsmtty_write,\n\t.write_room\t\t= gsmtty_write_room,\n\t.chars_in_buffer\t= gsmtty_chars_in_buffer,\n\t.flush_buffer\t\t= gsmtty_flush_buffer,\n\t.ioctl\t\t\t= gsmtty_ioctl,\n\t.throttle\t\t= gsmtty_throttle,\n\t.unthrottle\t\t= gsmtty_unthrottle,\n\t.set_termios\t\t= gsmtty_set_termios,\n\t.hangup\t\t\t= gsmtty_hangup,\n\t.wait_until_sent\t= gsmtty_wait_until_sent,\n\t.tiocmget\t\t= gsmtty_tiocmget,\n\t.tiocmset\t\t= gsmtty_tiocmset,\n\t.break_ctl\t\t= gsmtty_break_ctl,\n\t.cleanup\t\t= gsmtty_cleanup,\n};\n\n\n\nstatic int __init gsm_init(void)\n{\n\t \n\tint status = tty_register_ldisc(&tty_ldisc_packet);\n\tif (status != 0) {\n\t\tpr_err(\"n_gsm: can't register line discipline (err = %d)\\n\",\n\t\t\t\t\t\t\t\tstatus);\n\t\treturn status;\n\t}\n\n\tgsm_tty_driver = tty_alloc_driver(GSM_TTY_MINORS, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_HARDWARE_BREAK);\n\tif (IS_ERR(gsm_tty_driver)) {\n\t\tpr_err(\"gsm_init: tty allocation failed.\\n\");\n\t\tstatus = PTR_ERR(gsm_tty_driver);\n\t\tgoto err_unreg_ldisc;\n\t}\n\tgsm_tty_driver->driver_name\t= \"gsmtty\";\n\tgsm_tty_driver->name\t\t= \"gsmtty\";\n\tgsm_tty_driver->major\t\t= 0;\t \n\tgsm_tty_driver->minor_start\t= 0;\n\tgsm_tty_driver->type\t\t= TTY_DRIVER_TYPE_SERIAL;\n\tgsm_tty_driver->subtype\t= SERIAL_TYPE_NORMAL;\n\tgsm_tty_driver->init_termios\t= tty_std_termios;\n\t \n\tgsm_tty_driver->init_termios.c_lflag &= ~ECHO;\n\ttty_set_operations(gsm_tty_driver, &gsmtty_ops);\n\n\tif (tty_register_driver(gsm_tty_driver)) {\n\t\tpr_err(\"gsm_init: tty registration failed.\\n\");\n\t\tstatus = -EBUSY;\n\t\tgoto err_put_driver;\n\t}\n\tpr_debug(\"gsm_init: loaded as %d,%d.\\n\",\n\t\t\tgsm_tty_driver->major, gsm_tty_driver->minor_start);\n\treturn 0;\nerr_put_driver:\n\ttty_driver_kref_put(gsm_tty_driver);\nerr_unreg_ldisc:\n\ttty_unregister_ldisc(&tty_ldisc_packet);\n\treturn status;\n}\n\nstatic void __exit gsm_exit(void)\n{\n\ttty_unregister_ldisc(&tty_ldisc_packet);\n\ttty_unregister_driver(gsm_tty_driver);\n\ttty_driver_kref_put(gsm_tty_driver);\n}\n\nmodule_init(gsm_init);\nmodule_exit(gsm_exit);\n\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_GSM0710);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}