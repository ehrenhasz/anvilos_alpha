{
  "module_name": "vt.c",
  "hash_id": "296d4ccba0a3a2bc16e4412c7ac17a6017d2068b6e5ca51507718331281f37bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/vt/vt.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/sched/signal.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kd.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/major.h>\n#include <linux/mm.h>\n#include <linux/console.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/vt_kern.h>\n#include <linux/selection.h>\n#include <linux/tiocl.h>\n#include <linux/kbd_kern.h>\n#include <linux/consolemap.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/pm.h>\n#include <linux/font.h>\n#include <linux/bitops.h>\n#include <linux/notifier.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/kdb.h>\n#include <linux/ctype.h>\n#include <linux/bsearch.h>\n#include <linux/gcd.h>\n\n#define MAX_NR_CON_DRIVER 16\n\n#define CON_DRIVER_FLAG_MODULE 1\n#define CON_DRIVER_FLAG_INIT   2\n#define CON_DRIVER_FLAG_ATTR   4\n#define CON_DRIVER_FLAG_ZOMBIE 8\n\nstruct con_driver {\n\tconst struct consw *con;\n\tconst char *desc;\n\tstruct device *dev;\n\tint node;\n\tint first;\n\tint last;\n\tint flag;\n};\n\nstatic struct con_driver registered_con_driver[MAX_NR_CON_DRIVER];\nconst struct consw *conswitchp;\n\n \n#define DEFAULT_BELL_PITCH\t750\n#define DEFAULT_BELL_DURATION\t(HZ/8)\n#define DEFAULT_CURSOR_BLINK_MS\t200\n\nstruct vc vc_cons [MAX_NR_CONSOLES];\nEXPORT_SYMBOL(vc_cons);\n\nstatic const struct consw *con_driver_map[MAX_NR_CONSOLES];\n\nstatic int con_open(struct tty_struct *, struct file *);\nstatic void vc_init(struct vc_data *vc, int do_clear);\nstatic void gotoxy(struct vc_data *vc, int new_x, int new_y);\nstatic void save_cur(struct vc_data *vc);\nstatic void reset_terminal(struct vc_data *vc, int do_clear);\nstatic void con_flush_chars(struct tty_struct *tty);\nstatic int set_vesa_blanking(char __user *p);\nstatic void set_cursor(struct vc_data *vc);\nstatic void hide_cursor(struct vc_data *vc);\nstatic void console_callback(struct work_struct *ignored);\nstatic void con_driver_unregister_callback(struct work_struct *ignored);\nstatic void blank_screen_t(struct timer_list *unused);\nstatic void set_palette(struct vc_data *vc);\nstatic void unblank_screen(void);\n\n#define vt_get_kmsg_redirect() vt_kmsg_redirect(-1)\n\nint default_utf8 = true;\nmodule_param(default_utf8, int, S_IRUGO | S_IWUSR);\nint global_cursor_default = -1;\nmodule_param(global_cursor_default, int, S_IRUGO | S_IWUSR);\nEXPORT_SYMBOL(global_cursor_default);\n\nstatic int cur_default = CUR_UNDERLINE;\nmodule_param(cur_default, int, S_IRUGO | S_IWUSR);\n\n \nstatic int ignore_poke;\n\nint do_poke_blanked_console;\nint console_blanked;\nEXPORT_SYMBOL(console_blanked);\n\nstatic int vesa_blank_mode;  \nstatic int vesa_off_interval;\nstatic int blankinterval;\ncore_param(consoleblank, blankinterval, int, 0444);\n\nstatic DECLARE_WORK(console_work, console_callback);\nstatic DECLARE_WORK(con_driver_unregister_work, con_driver_unregister_callback);\n\n \nint fg_console;\nEXPORT_SYMBOL(fg_console);\nint last_console;\nint want_console = -1;\n\nstatic int saved_fg_console;\nstatic int saved_last_console;\nstatic int saved_want_console;\nstatic int saved_vc_mode;\nstatic int saved_console_blanked;\n\n \nstatic struct vc_data *master_display_fg;\n\n \n\n \nstatic int scrollback_delta;\n\n \nint (*console_blank_hook)(int);\nEXPORT_SYMBOL(console_blank_hook);\n\nstatic DEFINE_TIMER(console_timer, blank_screen_t);\nstatic int blank_state;\nstatic int blank_timer_expired;\nenum {\n\tblank_off = 0,\n\tblank_normal_wait,\n\tblank_vesa_wait,\n};\n\n \nstatic struct device *tty0dev;\n\n \nstatic ATOMIC_NOTIFIER_HEAD(vt_notifier_list);\n\nint register_vt_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&vt_notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(register_vt_notifier);\n\nint unregister_vt_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&vt_notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_vt_notifier);\n\nstatic void notify_write(struct vc_data *vc, unsigned int unicode)\n{\n\tstruct vt_notifier_param param = { .vc = vc, .c = unicode };\n\tatomic_notifier_call_chain(&vt_notifier_list, VT_WRITE, &param);\n}\n\nstatic void notify_update(struct vc_data *vc)\n{\n\tstruct vt_notifier_param param = { .vc = vc };\n\tatomic_notifier_call_chain(&vt_notifier_list, VT_UPDATE, &param);\n}\n \n\nstatic inline bool con_is_fg(const struct vc_data *vc)\n{\n\treturn vc->vc_num == fg_console;\n}\n\nstatic inline bool con_should_update(const struct vc_data *vc)\n{\n\treturn con_is_visible(vc) && !console_blanked;\n}\n\nstatic inline unsigned short *screenpos(const struct vc_data *vc, int offset,\n\t\tbool viewed)\n{\n\tunsigned short *p;\n\t\n\tif (!viewed)\n\t\tp = (unsigned short *)(vc->vc_origin + offset);\n\telse if (!vc->vc_sw->con_screen_pos)\n\t\tp = (unsigned short *)(vc->vc_visible_origin + offset);\n\telse\n\t\tp = vc->vc_sw->con_screen_pos(vc, offset);\n\treturn p;\n}\n\n \nstatic inline void scrolldelta(int lines)\n{\n\t \n\t \n\tscrollback_delta += lines;\n\tschedule_console_callback();\n}\n\nvoid schedule_console_callback(void)\n{\n\tschedule_work(&console_work);\n}\n\n \n\n \n\nstatic u32 **vc_uniscr_alloc(unsigned int cols, unsigned int rows)\n{\n\tu32 **uni_lines;\n\tvoid *p;\n\tunsigned int memsize, i, col_size = cols * sizeof(**uni_lines);\n\n\t \n\tmemsize = col_size * rows;\n\tmemsize += rows * sizeof(*uni_lines);\n\tuni_lines = vzalloc(memsize);\n\tif (!uni_lines)\n\t\treturn NULL;\n\n\t \n\tp = uni_lines + rows;\n\tfor (i = 0; i < rows; i++) {\n\t\tuni_lines[i] = p;\n\t\tp += col_size;\n\t}\n\n\treturn uni_lines;\n}\n\nstatic void vc_uniscr_free(u32 **uni_lines)\n{\n\tvfree(uni_lines);\n}\n\nstatic void vc_uniscr_set(struct vc_data *vc, u32 **new_uni_lines)\n{\n\tvc_uniscr_free(vc->vc_uni_lines);\n\tvc->vc_uni_lines = new_uni_lines;\n}\n\nstatic void vc_uniscr_putc(struct vc_data *vc, u32 uc)\n{\n\tif (vc->vc_uni_lines)\n\t\tvc->vc_uni_lines[vc->state.y][vc->state.x] = uc;\n}\n\nstatic void vc_uniscr_insert(struct vc_data *vc, unsigned int nr)\n{\n\tif (vc->vc_uni_lines) {\n\t\tu32 *ln = vc->vc_uni_lines[vc->state.y];\n\t\tunsigned int x = vc->state.x, cols = vc->vc_cols;\n\n\t\tmemmove(&ln[x + nr], &ln[x], (cols - x - nr) * sizeof(*ln));\n\t\tmemset32(&ln[x], ' ', nr);\n\t}\n}\n\nstatic void vc_uniscr_delete(struct vc_data *vc, unsigned int nr)\n{\n\tif (vc->vc_uni_lines) {\n\t\tu32 *ln = vc->vc_uni_lines[vc->state.y];\n\t\tunsigned int x = vc->state.x, cols = vc->vc_cols;\n\n\t\tmemcpy(&ln[x], &ln[x + nr], (cols - x - nr) * sizeof(*ln));\n\t\tmemset32(&ln[cols - nr], ' ', nr);\n\t}\n}\n\nstatic void vc_uniscr_clear_line(struct vc_data *vc, unsigned int x,\n\t\t\t\t unsigned int nr)\n{\n\tif (vc->vc_uni_lines)\n\t\tmemset32(&vc->vc_uni_lines[vc->state.y][x], ' ', nr);\n}\n\nstatic void vc_uniscr_clear_lines(struct vc_data *vc, unsigned int y,\n\t\t\t\t  unsigned int nr)\n{\n\tif (vc->vc_uni_lines)\n\t\twhile (nr--)\n\t\t\tmemset32(vc->vc_uni_lines[y++], ' ', vc->vc_cols);\n}\n\n \nstatic void juggle_array(u32 **array, unsigned int size, unsigned int nr)\n{\n\tunsigned int gcd_idx;\n\n\tfor (gcd_idx = 0; gcd_idx < gcd(nr, size); gcd_idx++) {\n\t\tu32 *gcd_idx_val = array[gcd_idx];\n\t\tunsigned int dst_idx = gcd_idx;\n\n\t\twhile (1) {\n\t\t\tunsigned int src_idx = (dst_idx + nr) % size;\n\t\t\tif (src_idx == gcd_idx)\n\t\t\t\tbreak;\n\n\t\t\tarray[dst_idx] = array[src_idx];\n\t\t\tdst_idx = src_idx;\n\t\t}\n\n\t\tarray[dst_idx] = gcd_idx_val;\n\t}\n}\n\nstatic void vc_uniscr_scroll(struct vc_data *vc, unsigned int top,\n\t\t\t     unsigned int bottom, enum con_scroll dir,\n\t\t\t     unsigned int nr)\n{\n\tu32 **uni_lines = vc->vc_uni_lines;\n\tunsigned int size = bottom - top;\n\n\tif (!uni_lines)\n\t\treturn;\n\n\tif (dir == SM_DOWN) {\n\t\tjuggle_array(&uni_lines[top], size, size - nr);\n\t\tvc_uniscr_clear_lines(vc, top, nr);\n\t} else {\n\t\tjuggle_array(&uni_lines[top], size, nr);\n\t\tvc_uniscr_clear_lines(vc, bottom - nr, nr);\n\t}\n}\n\nstatic void vc_uniscr_copy_area(u32 **dst_lines,\n\t\t\t\tunsigned int dst_cols,\n\t\t\t\tunsigned int dst_rows,\n\t\t\t\tu32 **src_lines,\n\t\t\t\tunsigned int src_cols,\n\t\t\t\tunsigned int src_top_row,\n\t\t\t\tunsigned int src_bot_row)\n{\n\tunsigned int dst_row = 0;\n\n\tif (!dst_lines)\n\t\treturn;\n\n\twhile (src_top_row < src_bot_row) {\n\t\tu32 *src_line = src_lines[src_top_row];\n\t\tu32 *dst_line = dst_lines[dst_row];\n\n\t\tmemcpy(dst_line, src_line, src_cols * sizeof(*src_line));\n\t\tif (dst_cols - src_cols)\n\t\t\tmemset32(dst_line + src_cols, ' ', dst_cols - src_cols);\n\t\tsrc_top_row++;\n\t\tdst_row++;\n\t}\n\twhile (dst_row < dst_rows) {\n\t\tu32 *dst_line = dst_lines[dst_row];\n\n\t\tmemset32(dst_line, ' ', dst_cols);\n\t\tdst_row++;\n\t}\n}\n\n \nint vc_uniscr_check(struct vc_data *vc)\n{\n\tu32 **uni_lines;\n\tunsigned short *p;\n\tint x, y, mask;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (!vc->vc_utf)\n\t\treturn -ENODATA;\n\n\tif (vc->vc_uni_lines)\n\t\treturn 0;\n\n\tuni_lines = vc_uniscr_alloc(vc->vc_cols, vc->vc_rows);\n\tif (!uni_lines)\n\t\treturn -ENOMEM;\n\n\t \n\tp = (unsigned short *)vc->vc_origin;\n\tmask = vc->vc_hi_font_mask | 0xff;\n\tfor (y = 0; y < vc->vc_rows; y++) {\n\t\tu32 *line = uni_lines[y];\n\t\tfor (x = 0; x < vc->vc_cols; x++) {\n\t\t\tu16 glyph = scr_readw(p++) & mask;\n\t\t\tline[x] = inverse_translate(vc, glyph, true);\n\t\t}\n\t}\n\n\tvc->vc_uni_lines = uni_lines;\n\n\treturn 0;\n}\n\n \nvoid vc_uniscr_copy_line(const struct vc_data *vc, void *dest, bool viewed,\n\t\t\t unsigned int row, unsigned int col, unsigned int nr)\n{\n\tu32 **uni_lines = vc->vc_uni_lines;\n\tint offset = row * vc->vc_size_row + col * 2;\n\tunsigned long pos;\n\n\tif (WARN_ON_ONCE(!uni_lines))\n\t\treturn;\n\n\tpos = (unsigned long)screenpos(vc, offset, viewed);\n\tif (pos >= vc->vc_origin && pos < vc->vc_scr_end) {\n\t\t \n\t\trow = (pos - vc->vc_origin) / vc->vc_size_row;\n\t\tcol = ((pos - vc->vc_origin) % vc->vc_size_row) / 2;\n\t\tmemcpy(dest, &uni_lines[row][col], nr * sizeof(u32));\n\t} else {\n\t\t \n\t\tu16 *p = (u16 *)pos;\n\t\tint mask = vc->vc_hi_font_mask | 0xff;\n\t\tu32 *uni_buf = dest;\n\t\twhile (nr--) {\n\t\t\tu16 glyph = scr_readw(p++) & mask;\n\t\t\t*uni_buf++ = inverse_translate(vc, glyph, true);\n\t\t}\n\t}\n}\n\nstatic void con_scroll(struct vc_data *vc, unsigned int top,\n\t\t       unsigned int bottom, enum con_scroll dir,\n\t\t       unsigned int nr)\n{\n\tunsigned int rows = bottom - top;\n\tu16 *clear, *dst, *src;\n\n\tif (top + nr >= bottom)\n\t\tnr = rows - 1;\n\tif (bottom > vc->vc_rows || top >= bottom || nr < 1)\n\t\treturn;\n\n\tvc_uniscr_scroll(vc, top, bottom, dir, nr);\n\tif (con_is_visible(vc) &&\n\t\t\tvc->vc_sw->con_scroll(vc, top, bottom, dir, nr))\n\t\treturn;\n\n\tsrc = clear = (u16 *)(vc->vc_origin + vc->vc_size_row * top);\n\tdst = (u16 *)(vc->vc_origin + vc->vc_size_row * (top + nr));\n\n\tif (dir == SM_UP) {\n\t\tclear = src + (rows - nr) * vc->vc_cols;\n\t\tswap(src, dst);\n\t}\n\tscr_memmovew(dst, src, (rows - nr) * vc->vc_size_row);\n\tscr_memsetw(clear, vc->vc_video_erase_char, vc->vc_size_row * nr);\n}\n\nstatic void do_update_region(struct vc_data *vc, unsigned long start, int count)\n{\n\tunsigned int xx, yy, offset;\n\tu16 *p;\n\n\tp = (u16 *) start;\n\tif (!vc->vc_sw->con_getxy) {\n\t\toffset = (start - vc->vc_origin) / 2;\n\t\txx = offset % vc->vc_cols;\n\t\tyy = offset / vc->vc_cols;\n\t} else {\n\t\tint nxx, nyy;\n\t\tstart = vc->vc_sw->con_getxy(vc, start, &nxx, &nyy);\n\t\txx = nxx; yy = nyy;\n\t}\n\tfor(;;) {\n\t\tu16 attrib = scr_readw(p) & 0xff00;\n\t\tint startx = xx;\n\t\tu16 *q = p;\n\t\twhile (xx < vc->vc_cols && count) {\n\t\t\tif (attrib != (scr_readw(p) & 0xff00)) {\n\t\t\t\tif (p > q)\n\t\t\t\t\tvc->vc_sw->con_putcs(vc, q, p-q, yy, startx);\n\t\t\t\tstartx = xx;\n\t\t\t\tq = p;\n\t\t\t\tattrib = scr_readw(p) & 0xff00;\n\t\t\t}\n\t\t\tp++;\n\t\t\txx++;\n\t\t\tcount--;\n\t\t}\n\t\tif (p > q)\n\t\t\tvc->vc_sw->con_putcs(vc, q, p-q, yy, startx);\n\t\tif (!count)\n\t\t\tbreak;\n\t\txx = 0;\n\t\tyy++;\n\t\tif (vc->vc_sw->con_getxy) {\n\t\t\tp = (u16 *)start;\n\t\t\tstart = vc->vc_sw->con_getxy(vc, start, NULL, NULL);\n\t\t}\n\t}\n}\n\nvoid update_region(struct vc_data *vc, unsigned long start, int count)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (con_should_update(vc)) {\n\t\thide_cursor(vc);\n\t\tdo_update_region(vc, start, count);\n\t\tset_cursor(vc);\n\t}\n}\nEXPORT_SYMBOL(update_region);\n\n \n\nstatic u8 build_attr(struct vc_data *vc, u8 _color,\n\t\tenum vc_intensity _intensity, bool _blink, bool _underline,\n\t\tbool _reverse, bool _italic)\n{\n\tif (vc->vc_sw->con_build_attr)\n\t\treturn vc->vc_sw->con_build_attr(vc, _color, _intensity,\n\t\t       _blink, _underline, _reverse, _italic);\n\n \n\t{\n\tu8 a = _color;\n\tif (!vc->vc_can_do_color)\n\t\treturn _intensity |\n\t\t       (_italic    << 1) |\n\t\t       (_underline << 2) |\n\t\t       (_reverse   << 3) |\n\t\t       (_blink     << 7);\n\tif (_italic)\n\t\ta = (a & 0xF0) | vc->vc_itcolor;\n\telse if (_underline)\n\t\ta = (a & 0xf0) | vc->vc_ulcolor;\n\telse if (_intensity == VCI_HALF_BRIGHT)\n\t\ta = (a & 0xf0) | vc->vc_halfcolor;\n\tif (_reverse)\n\t\ta = (a & 0x88) | (((a >> 4) | (a << 4)) & 0x77);\n\tif (_blink)\n\t\ta ^= 0x80;\n\tif (_intensity == VCI_BOLD)\n\t\ta ^= 0x08;\n\tif (vc->vc_hi_font_mask == 0x100)\n\t\ta <<= 1;\n\treturn a;\n\t}\n}\n\nstatic void update_attr(struct vc_data *vc)\n{\n\tvc->vc_attr = build_attr(vc, vc->state.color, vc->state.intensity,\n\t              vc->state.blink, vc->state.underline,\n\t              vc->state.reverse ^ vc->vc_decscnm, vc->state.italic);\n\tvc->vc_video_erase_char = ' ' | (build_attr(vc, vc->state.color,\n\t\t\t\tVCI_NORMAL, vc->state.blink, false,\n\t\t\t\tvc->vc_decscnm, false) << 8);\n}\n\n \nvoid invert_screen(struct vc_data *vc, int offset, int count, bool viewed)\n{\n\tunsigned short *p;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tcount /= 2;\n\tp = screenpos(vc, offset, viewed);\n\tif (vc->vc_sw->con_invert_region) {\n\t\tvc->vc_sw->con_invert_region(vc, p, count);\n\t} else {\n\t\tu16 *q = p;\n\t\tint cnt = count;\n\t\tu16 a;\n\n\t\tif (!vc->vc_can_do_color) {\n\t\t\twhile (cnt--) {\n\t\t\t    a = scr_readw(q);\n\t\t\t    a ^= 0x0800;\n\t\t\t    scr_writew(a, q);\n\t\t\t    q++;\n\t\t\t}\n\t\t} else if (vc->vc_hi_font_mask == 0x100) {\n\t\t\twhile (cnt--) {\n\t\t\t\ta = scr_readw(q);\n\t\t\t\ta = (a & 0x11ff) |\n\t\t\t\t   ((a & 0xe000) >> 4) |\n\t\t\t\t   ((a & 0x0e00) << 4);\n\t\t\t\tscr_writew(a, q);\n\t\t\t\tq++;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (cnt--) {\n\t\t\t\ta = scr_readw(q);\n\t\t\t\ta = (a & 0x88ff) |\n\t\t\t\t   ((a & 0x7000) >> 4) |\n\t\t\t\t   ((a & 0x0700) << 4);\n\t\t\t\tscr_writew(a, q);\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (con_should_update(vc))\n\t\tdo_update_region(vc, (unsigned long) p, count);\n\tnotify_update(vc);\n}\n\n \nvoid complement_pos(struct vc_data *vc, int offset)\n{\n\tstatic int old_offset = -1;\n\tstatic unsigned short old;\n\tstatic unsigned short oldx, oldy;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (old_offset != -1 && old_offset >= 0 &&\n\t    old_offset < vc->vc_screenbuf_size) {\n\t\tscr_writew(old, screenpos(vc, old_offset, true));\n\t\tif (con_should_update(vc))\n\t\t\tvc->vc_sw->con_putc(vc, old, oldy, oldx);\n\t\tnotify_update(vc);\n\t}\n\n\told_offset = offset;\n\n\tif (offset != -1 && offset >= 0 &&\n\t    offset < vc->vc_screenbuf_size) {\n\t\tunsigned short new;\n\t\tunsigned short *p;\n\t\tp = screenpos(vc, offset, true);\n\t\told = scr_readw(p);\n\t\tnew = old ^ vc->vc_complement_mask;\n\t\tscr_writew(new, p);\n\t\tif (con_should_update(vc)) {\n\t\t\toldx = (offset >> 1) % vc->vc_cols;\n\t\t\toldy = (offset >> 1) / vc->vc_cols;\n\t\t\tvc->vc_sw->con_putc(vc, new, oldy, oldx);\n\t\t}\n\t\tnotify_update(vc);\n\t}\n}\n\nstatic void insert_char(struct vc_data *vc, unsigned int nr)\n{\n\tunsigned short *p = (unsigned short *) vc->vc_pos;\n\n\tvc_uniscr_insert(vc, nr);\n\tscr_memmovew(p + nr, p, (vc->vc_cols - vc->state.x - nr) * 2);\n\tscr_memsetw(p, vc->vc_video_erase_char, nr * 2);\n\tvc->vc_need_wrap = 0;\n\tif (con_should_update(vc))\n\t\tdo_update_region(vc, (unsigned long) p,\n\t\t\tvc->vc_cols - vc->state.x);\n}\n\nstatic void delete_char(struct vc_data *vc, unsigned int nr)\n{\n\tunsigned short *p = (unsigned short *) vc->vc_pos;\n\n\tvc_uniscr_delete(vc, nr);\n\tscr_memmovew(p, p + nr, (vc->vc_cols - vc->state.x - nr) * 2);\n\tscr_memsetw(p + vc->vc_cols - vc->state.x - nr, vc->vc_video_erase_char,\n\t\t\tnr * 2);\n\tvc->vc_need_wrap = 0;\n\tif (con_should_update(vc))\n\t\tdo_update_region(vc, (unsigned long) p,\n\t\t\tvc->vc_cols - vc->state.x);\n}\n\nstatic int softcursor_original = -1;\n\nstatic void add_softcursor(struct vc_data *vc)\n{\n\tint i = scr_readw((u16 *) vc->vc_pos);\n\tu32 type = vc->vc_cursor_type;\n\n\tif (!(type & CUR_SW))\n\t\treturn;\n\tif (softcursor_original != -1)\n\t\treturn;\n\tsoftcursor_original = i;\n\ti |= CUR_SET(type);\n\ti ^= CUR_CHANGE(type);\n\tif ((type & CUR_ALWAYS_BG) &&\n\t\t\t(softcursor_original & CUR_BG) == (i & CUR_BG))\n\t\ti ^= CUR_BG;\n\tif ((type & CUR_INVERT_FG_BG) && (i & CUR_FG) == ((i & CUR_BG) >> 4))\n\t\ti ^= CUR_FG;\n\tscr_writew(i, (u16 *)vc->vc_pos);\n\tif (con_should_update(vc))\n\t\tvc->vc_sw->con_putc(vc, i, vc->state.y, vc->state.x);\n}\n\nstatic void hide_softcursor(struct vc_data *vc)\n{\n\tif (softcursor_original != -1) {\n\t\tscr_writew(softcursor_original, (u16 *)vc->vc_pos);\n\t\tif (con_should_update(vc))\n\t\t\tvc->vc_sw->con_putc(vc, softcursor_original,\n\t\t\t\t\tvc->state.y, vc->state.x);\n\t\tsoftcursor_original = -1;\n\t}\n}\n\nstatic void hide_cursor(struct vc_data *vc)\n{\n\tif (vc_is_sel(vc))\n\t\tclear_selection();\n\n\tvc->vc_sw->con_cursor(vc, CM_ERASE);\n\thide_softcursor(vc);\n}\n\nstatic void set_cursor(struct vc_data *vc)\n{\n\tif (!con_is_fg(vc) || console_blanked || vc->vc_mode == KD_GRAPHICS)\n\t\treturn;\n\tif (vc->vc_deccm) {\n\t\tif (vc_is_sel(vc))\n\t\t\tclear_selection();\n\t\tadd_softcursor(vc);\n\t\tif (CUR_SIZE(vc->vc_cursor_type) != CUR_NONE)\n\t\t\tvc->vc_sw->con_cursor(vc, CM_DRAW);\n\t} else\n\t\thide_cursor(vc);\n}\n\nstatic void set_origin(struct vc_data *vc)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (!con_is_visible(vc) ||\n\t    !vc->vc_sw->con_set_origin ||\n\t    !vc->vc_sw->con_set_origin(vc))\n\t\tvc->vc_origin = (unsigned long)vc->vc_screenbuf;\n\tvc->vc_visible_origin = vc->vc_origin;\n\tvc->vc_scr_end = vc->vc_origin + vc->vc_screenbuf_size;\n\tvc->vc_pos = vc->vc_origin + vc->vc_size_row * vc->state.y +\n\t\t2 * vc->state.x;\n}\n\nstatic void save_screen(struct vc_data *vc)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (vc->vc_sw->con_save_screen)\n\t\tvc->vc_sw->con_save_screen(vc);\n}\n\nstatic void flush_scrollback(struct vc_data *vc)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\tset_origin(vc);\n\tif (vc->vc_sw->con_flush_scrollback) {\n\t\tvc->vc_sw->con_flush_scrollback(vc);\n\t} else if (con_is_visible(vc)) {\n\t\t \n\t\thide_cursor(vc);\n\t\tvc->vc_sw->con_switch(vc);\n\t\tset_cursor(vc);\n\t}\n}\n\n \n\nvoid clear_buffer_attributes(struct vc_data *vc)\n{\n\tunsigned short *p = (unsigned short *)vc->vc_origin;\n\tint count = vc->vc_screenbuf_size / 2;\n\tint mask = vc->vc_hi_font_mask | 0xff;\n\n\tfor (; count > 0; count--, p++) {\n\t\tscr_writew((scr_readw(p)&mask) | (vc->vc_video_erase_char & ~mask), p);\n\t}\n}\n\nvoid redraw_screen(struct vc_data *vc, int is_switch)\n{\n\tint redraw = 0;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (!vc) {\n\t\t \n\t\t \n\t\treturn;\n\t}\n\n\tif (is_switch) {\n\t\tstruct vc_data *old_vc = vc_cons[fg_console].d;\n\t\tif (old_vc == vc)\n\t\t\treturn;\n\t\tif (!con_is_visible(vc))\n\t\t\tredraw = 1;\n\t\t*vc->vc_display_fg = vc;\n\t\tfg_console = vc->vc_num;\n\t\thide_cursor(old_vc);\n\t\tif (!con_is_visible(old_vc)) {\n\t\t\tsave_screen(old_vc);\n\t\t\tset_origin(old_vc);\n\t\t}\n\t\tif (tty0dev)\n\t\t\tsysfs_notify(&tty0dev->kobj, NULL, \"active\");\n\t} else {\n\t\thide_cursor(vc);\n\t\tredraw = 1;\n\t}\n\n\tif (redraw) {\n\t\tint update;\n\t\tint old_was_color = vc->vc_can_do_color;\n\n\t\tset_origin(vc);\n\t\tupdate = vc->vc_sw->con_switch(vc);\n\t\tset_palette(vc);\n\t\t \n\t\tif (old_was_color != vc->vc_can_do_color) {\n\t\t\tupdate_attr(vc);\n\t\t\tclear_buffer_attributes(vc);\n\t\t}\n\n\t\tif (update && vc->vc_mode != KD_GRAPHICS)\n\t\t\tdo_update_region(vc, vc->vc_origin, vc->vc_screenbuf_size / 2);\n\t}\n\tset_cursor(vc);\n\tif (is_switch) {\n\t\tvt_set_leds_compute_shiftstate();\n\t\tnotify_update(vc);\n\t}\n}\nEXPORT_SYMBOL(redraw_screen);\n\n \n\nint vc_cons_allocated(unsigned int i)\n{\n\treturn (i < MAX_NR_CONSOLES && vc_cons[i].d);\n}\n\nstatic void visual_init(struct vc_data *vc, int num, int init)\n{\n\t \n\tif (vc->vc_sw)\n\t\tmodule_put(vc->vc_sw->owner);\n\tvc->vc_sw = conswitchp;\n\n\tif (con_driver_map[num])\n\t\tvc->vc_sw = con_driver_map[num];\n\n\t__module_get(vc->vc_sw->owner);\n\tvc->vc_num = num;\n\tvc->vc_display_fg = &master_display_fg;\n\tif (vc->uni_pagedict_loc)\n\t\tcon_free_unimap(vc);\n\tvc->uni_pagedict_loc = &vc->uni_pagedict;\n\tvc->uni_pagedict = NULL;\n\tvc->vc_hi_font_mask = 0;\n\tvc->vc_complement_mask = 0;\n\tvc->vc_can_do_color = 0;\n\tvc->vc_cur_blink_ms = DEFAULT_CURSOR_BLINK_MS;\n\tvc->vc_sw->con_init(vc, init);\n\tif (!vc->vc_complement_mask)\n\t\tvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\n\tvc->vc_s_complement_mask = vc->vc_complement_mask;\n\tvc->vc_size_row = vc->vc_cols << 1;\n\tvc->vc_screenbuf_size = vc->vc_rows * vc->vc_size_row;\n}\n\n\nstatic void visual_deinit(struct vc_data *vc)\n{\n\tvc->vc_sw->con_deinit(vc);\n\tmodule_put(vc->vc_sw->owner);\n}\n\nstatic void vc_port_destruct(struct tty_port *port)\n{\n\tstruct vc_data *vc = container_of(port, struct vc_data, port);\n\n\tkfree(vc);\n}\n\nstatic const struct tty_port_operations vc_port_ops = {\n\t.destruct = vc_port_destruct,\n};\n\n \n#define VC_MAXCOL (32767)\n#define VC_MAXROW (32767)\n\nint vc_allocate(unsigned int currcons)\t \n{\n\tstruct vt_notifier_param param;\n\tstruct vc_data *vc;\n\tint err;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (currcons >= MAX_NR_CONSOLES)\n\t\treturn -ENXIO;\n\n\tif (vc_cons[currcons].d)\n\t\treturn 0;\n\n\t \n\t \n\t \n\tparam.vc = vc = kzalloc(sizeof(struct vc_data), GFP_KERNEL);\n\tif (!vc)\n\t\treturn -ENOMEM;\n\n\tvc_cons[currcons].d = vc;\n\ttty_port_init(&vc->port);\n\tvc->port.ops = &vc_port_ops;\n\tINIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);\n\n\tvisual_init(vc, currcons, 1);\n\n\tif (!*vc->uni_pagedict_loc)\n\t\tcon_set_default_unimap(vc);\n\n\terr = -EINVAL;\n\tif (vc->vc_cols > VC_MAXCOL || vc->vc_rows > VC_MAXROW ||\n\t    vc->vc_screenbuf_size > KMALLOC_MAX_SIZE || !vc->vc_screenbuf_size)\n\t\tgoto err_free;\n\terr = -ENOMEM;\n\tvc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_KERNEL);\n\tif (!vc->vc_screenbuf)\n\t\tgoto err_free;\n\n\t \n\tif (global_cursor_default == -1)\n\t\tglobal_cursor_default = 1;\n\n\tvc_init(vc, 1);\n\tvcs_make_sysfs(currcons);\n\tatomic_notifier_call_chain(&vt_notifier_list, VT_ALLOCATE, &param);\n\n\treturn 0;\nerr_free:\n\tvisual_deinit(vc);\n\tkfree(vc);\n\tvc_cons[currcons].d = NULL;\n\treturn err;\n}\n\nstatic inline int resize_screen(struct vc_data *vc, int width, int height,\n\t\t\t\tint user)\n{\n\t \n\tint err = 0;\n\n\tif (vc->vc_sw->con_resize)\n\t\terr = vc->vc_sw->con_resize(vc, width, height, user);\n\n\treturn err;\n}\n\n \n\nstatic int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,\n\t\t\t\tunsigned int cols, unsigned int lines)\n{\n\tunsigned long old_origin, new_origin, new_scr_end, rlth, rrem, err = 0;\n\tunsigned long end;\n\tunsigned int old_rows, old_row_size, first_copied_row;\n\tunsigned int new_cols, new_rows, new_row_size, new_screen_size;\n\tunsigned int user;\n\tunsigned short *oldscreen, *newscreen;\n\tu32 **new_uniscr = NULL;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (!vc)\n\t\treturn -ENXIO;\n\n\tuser = vc->vc_resize_user;\n\tvc->vc_resize_user = 0;\n\n\tif (cols > VC_MAXCOL || lines > VC_MAXROW)\n\t\treturn -EINVAL;\n\n\tnew_cols = (cols ? cols : vc->vc_cols);\n\tnew_rows = (lines ? lines : vc->vc_rows);\n\tnew_row_size = new_cols << 1;\n\tnew_screen_size = new_row_size * new_rows;\n\n\tif (new_cols == vc->vc_cols && new_rows == vc->vc_rows) {\n\t\t \n\t\treturn resize_screen(vc, new_cols, new_rows, user);\n\t}\n\n\tif (new_screen_size > KMALLOC_MAX_SIZE || !new_screen_size)\n\t\treturn -EINVAL;\n\tnewscreen = kzalloc(new_screen_size, GFP_USER);\n\tif (!newscreen)\n\t\treturn -ENOMEM;\n\n\tif (vc->vc_uni_lines) {\n\t\tnew_uniscr = vc_uniscr_alloc(new_cols, new_rows);\n\t\tif (!new_uniscr) {\n\t\t\tkfree(newscreen);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (vc_is_sel(vc))\n\t\tclear_selection();\n\n\told_rows = vc->vc_rows;\n\told_row_size = vc->vc_size_row;\n\n\terr = resize_screen(vc, new_cols, new_rows, user);\n\tif (err) {\n\t\tkfree(newscreen);\n\t\tvc_uniscr_free(new_uniscr);\n\t\treturn err;\n\t}\n\n\tvc->vc_rows = new_rows;\n\tvc->vc_cols = new_cols;\n\tvc->vc_size_row = new_row_size;\n\tvc->vc_screenbuf_size = new_screen_size;\n\n\trlth = min(old_row_size, new_row_size);\n\trrem = new_row_size - rlth;\n\told_origin = vc->vc_origin;\n\tnew_origin = (long) newscreen;\n\tnew_scr_end = new_origin + new_screen_size;\n\n\tif (vc->state.y > new_rows) {\n\t\tif (old_rows - vc->state.y < new_rows) {\n\t\t\t \n\t\t\tfirst_copied_row = (old_rows - new_rows);\n\t\t} else {\n\t\t\t \n\t\t\tfirst_copied_row = (vc->state.y - new_rows/2);\n\t\t}\n\t\told_origin += first_copied_row * old_row_size;\n\t} else\n\t\tfirst_copied_row = 0;\n\tend = old_origin + old_row_size * min(old_rows, new_rows);\n\n\tvc_uniscr_copy_area(new_uniscr, new_cols, new_rows,\n\t\t\t    vc->vc_uni_lines, rlth/2, first_copied_row,\n\t\t\t    min(old_rows, new_rows));\n\tvc_uniscr_set(vc, new_uniscr);\n\n\tupdate_attr(vc);\n\n\twhile (old_origin < end) {\n\t\tscr_memcpyw((unsigned short *) new_origin,\n\t\t\t    (unsigned short *) old_origin, rlth);\n\t\tif (rrem)\n\t\t\tscr_memsetw((void *)(new_origin + rlth),\n\t\t\t\t    vc->vc_video_erase_char, rrem);\n\t\told_origin += old_row_size;\n\t\tnew_origin += new_row_size;\n\t}\n\tif (new_scr_end > new_origin)\n\t\tscr_memsetw((void *)new_origin, vc->vc_video_erase_char,\n\t\t\t    new_scr_end - new_origin);\n\toldscreen = vc->vc_screenbuf;\n\tvc->vc_screenbuf = newscreen;\n\tvc->vc_screenbuf_size = new_screen_size;\n\tset_origin(vc);\n\tkfree(oldscreen);\n\n\t \n\tvc->vc_top = 0;\n\tvc->vc_bottom = vc->vc_rows;\n\tgotoxy(vc, vc->state.x, vc->state.y);\n\tsave_cur(vc);\n\n\tif (tty) {\n\t\t \n\t\tstruct winsize ws;\n\t\tmemset(&ws, 0, sizeof(ws));\n\t\tws.ws_row = vc->vc_rows;\n\t\tws.ws_col = vc->vc_cols;\n\t\tws.ws_ypixel = vc->vc_scan_lines;\n\t\ttty_do_resize(tty, &ws);\n\t}\n\n\tif (con_is_visible(vc))\n\t\tupdate_screen(vc);\n\tvt_event_post(VT_EVENT_RESIZE, vc->vc_num, vc->vc_num);\n\tnotify_update(vc);\n\treturn err;\n}\n\n \n\nint vc_resize(struct vc_data *vc, unsigned int cols, unsigned int rows)\n{\n\treturn vc_do_resize(vc->port.tty, vc, cols, rows);\n}\nEXPORT_SYMBOL(vc_resize);\n\n \nstatic int vt_resize(struct tty_struct *tty, struct winsize *ws)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tint ret;\n\n\tconsole_lock();\n\tret = vc_do_resize(tty, vc, ws->ws_col, ws->ws_row);\n\tconsole_unlock();\n\treturn ret;\n}\n\nstruct vc_data *vc_deallocate(unsigned int currcons)\n{\n\tstruct vc_data *vc = NULL;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (vc_cons_allocated(currcons)) {\n\t\tstruct vt_notifier_param param;\n\n\t\tparam.vc = vc = vc_cons[currcons].d;\n\t\tatomic_notifier_call_chain(&vt_notifier_list, VT_DEALLOCATE, &param);\n\t\tvcs_remove_sysfs(currcons);\n\t\tvisual_deinit(vc);\n\t\tcon_free_unimap(vc);\n\t\tput_pid(vc->vt_pid);\n\t\tvc_uniscr_set(vc, NULL);\n\t\tkfree(vc->vc_screenbuf);\n\t\tvc_cons[currcons].d = NULL;\n\t}\n\treturn vc;\n}\n\n \n\nenum { EPecma = 0, EPdec, EPeq, EPgt, EPlt};\n\n#define set_kbd(vc, x)\tvt_set_kbd_mode_bit((vc)->vc_num, (x))\n#define clr_kbd(vc, x)\tvt_clr_kbd_mode_bit((vc)->vc_num, (x))\n#define is_kbd(vc, x)\tvt_get_kbd_mode_bit((vc)->vc_num, (x))\n\n#define decarm\t\tVC_REPEAT\n#define decckm\t\tVC_CKMODE\n#define kbdapplic\tVC_APPLIC\n#define lnm\t\tVC_CRLF\n\nconst unsigned char color_table[] = { 0, 4, 2, 6, 1, 5, 3, 7,\n\t\t\t\t       8,12,10,14, 9,13,11,15 };\nEXPORT_SYMBOL(color_table);\n\n \nunsigned char default_red[] = {\n\t0x00, 0xaa, 0x00, 0xaa, 0x00, 0xaa, 0x00, 0xaa,\n\t0x55, 0xff, 0x55, 0xff, 0x55, 0xff, 0x55, 0xff\n};\nmodule_param_array(default_red, byte, NULL, S_IRUGO | S_IWUSR);\nEXPORT_SYMBOL(default_red);\n\nunsigned char default_grn[] = {\n\t0x00, 0x00, 0xaa, 0x55, 0x00, 0x00, 0xaa, 0xaa,\n\t0x55, 0x55, 0xff, 0xff, 0x55, 0x55, 0xff, 0xff\n};\nmodule_param_array(default_grn, byte, NULL, S_IRUGO | S_IWUSR);\nEXPORT_SYMBOL(default_grn);\n\nunsigned char default_blu[] = {\n\t0x00, 0x00, 0x00, 0x00, 0xaa, 0xaa, 0xaa, 0xaa,\n\t0x55, 0x55, 0x55, 0x55, 0xff, 0xff, 0xff, 0xff\n};\nmodule_param_array(default_blu, byte, NULL, S_IRUGO | S_IWUSR);\nEXPORT_SYMBOL(default_blu);\n\n \nstatic void gotoxy(struct vc_data *vc, int new_x, int new_y)\n{\n\tint min_y, max_y;\n\n\tif (new_x < 0)\n\t\tvc->state.x = 0;\n\telse {\n\t\tif (new_x >= vc->vc_cols)\n\t\t\tvc->state.x = vc->vc_cols - 1;\n\t\telse\n\t\t\tvc->state.x = new_x;\n\t}\n\n \tif (vc->vc_decom) {\n\t\tmin_y = vc->vc_top;\n\t\tmax_y = vc->vc_bottom;\n\t} else {\n\t\tmin_y = 0;\n\t\tmax_y = vc->vc_rows;\n\t}\n\tif (new_y < min_y)\n\t\tvc->state.y = min_y;\n\telse if (new_y >= max_y)\n\t\tvc->state.y = max_y - 1;\n\telse\n\t\tvc->state.y = new_y;\n\tvc->vc_pos = vc->vc_origin + vc->state.y * vc->vc_size_row +\n\t\t(vc->state.x << 1);\n\tvc->vc_need_wrap = 0;\n}\n\n \nstatic void gotoxay(struct vc_data *vc, int new_x, int new_y)\n{\n\tgotoxy(vc, new_x, vc->vc_decom ? (vc->vc_top + new_y) : new_y);\n}\n\nvoid scrollback(struct vc_data *vc)\n{\n\tscrolldelta(-(vc->vc_rows / 2));\n}\n\nvoid scrollfront(struct vc_data *vc, int lines)\n{\n\tif (!lines)\n\t\tlines = vc->vc_rows / 2;\n\tscrolldelta(lines);\n}\n\nstatic void lf(struct vc_data *vc)\n{\n    \t \n\tif (vc->state.y + 1 == vc->vc_bottom)\n\t\tcon_scroll(vc, vc->vc_top, vc->vc_bottom, SM_UP, 1);\n\telse if (vc->state.y < vc->vc_rows - 1) {\n\t\tvc->state.y++;\n\t\tvc->vc_pos += vc->vc_size_row;\n\t}\n\tvc->vc_need_wrap = 0;\n\tnotify_write(vc, '\\n');\n}\n\nstatic void ri(struct vc_data *vc)\n{\n    \t \n\tif (vc->state.y == vc->vc_top)\n\t\tcon_scroll(vc, vc->vc_top, vc->vc_bottom, SM_DOWN, 1);\n\telse if (vc->state.y > 0) {\n\t\tvc->state.y--;\n\t\tvc->vc_pos -= vc->vc_size_row;\n\t}\n\tvc->vc_need_wrap = 0;\n}\n\nstatic inline void cr(struct vc_data *vc)\n{\n\tvc->vc_pos -= vc->state.x << 1;\n\tvc->vc_need_wrap = vc->state.x = 0;\n\tnotify_write(vc, '\\r');\n}\n\nstatic inline void bs(struct vc_data *vc)\n{\n\tif (vc->state.x) {\n\t\tvc->vc_pos -= 2;\n\t\tvc->state.x--;\n\t\tvc->vc_need_wrap = 0;\n\t\tnotify_write(vc, '\\b');\n\t}\n}\n\nstatic inline void del(struct vc_data *vc)\n{\n\t \n}\n\nstatic void csi_J(struct vc_data *vc, int vpar)\n{\n\tunsigned int count;\n\tunsigned short * start;\n\n\tswitch (vpar) {\n\t\tcase 0:\t \n\t\t\tvc_uniscr_clear_line(vc, vc->state.x,\n\t\t\t\t\t     vc->vc_cols - vc->state.x);\n\t\t\tvc_uniscr_clear_lines(vc, vc->state.y + 1,\n\t\t\t\t\t      vc->vc_rows - vc->state.y - 1);\n\t\t\tcount = (vc->vc_scr_end - vc->vc_pos) >> 1;\n\t\t\tstart = (unsigned short *)vc->vc_pos;\n\t\t\tbreak;\n\t\tcase 1:\t \n\t\t\tvc_uniscr_clear_line(vc, 0, vc->state.x + 1);\n\t\t\tvc_uniscr_clear_lines(vc, 0, vc->state.y);\n\t\t\tcount = ((vc->vc_pos - vc->vc_origin) >> 1) + 1;\n\t\t\tstart = (unsigned short *)vc->vc_origin;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tflush_scrollback(vc);\n\t\t\tfallthrough;\n\t\tcase 2:  \n\t\t\tvc_uniscr_clear_lines(vc, 0, vc->vc_rows);\n\t\t\tcount = vc->vc_cols * vc->vc_rows;\n\t\t\tstart = (unsigned short *)vc->vc_origin;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\tscr_memsetw(start, vc->vc_video_erase_char, 2 * count);\n\tif (con_should_update(vc))\n\t\tdo_update_region(vc, (unsigned long) start, count);\n\tvc->vc_need_wrap = 0;\n}\n\nstatic void csi_K(struct vc_data *vc, int vpar)\n{\n\tunsigned int count;\n\tunsigned short *start = (unsigned short *)vc->vc_pos;\n\tint offset;\n\n\tswitch (vpar) {\n\t\tcase 0:\t \n\t\t\toffset = 0;\n\t\t\tcount = vc->vc_cols - vc->state.x;\n\t\t\tbreak;\n\t\tcase 1:\t \n\t\t\toffset = -vc->state.x;\n\t\t\tcount = vc->state.x + 1;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\toffset = -vc->state.x;\n\t\t\tcount = vc->vc_cols;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\tvc_uniscr_clear_line(vc, vc->state.x + offset, count);\n\tscr_memsetw(start + offset, vc->vc_video_erase_char, 2 * count);\n\tvc->vc_need_wrap = 0;\n\tif (con_should_update(vc))\n\t\tdo_update_region(vc, (unsigned long)(start + offset), count);\n}\n\n \nstatic void csi_X(struct vc_data *vc, unsigned int vpar)\n{\t\t\t\t\t   \n\tunsigned int count;\n\n\tif (!vpar)\n\t\tvpar++;\n\n\tcount = min(vpar, vc->vc_cols - vc->state.x);\n\n\tvc_uniscr_clear_line(vc, vc->state.x, count);\n\tscr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);\n\tif (con_should_update(vc))\n\t\tvc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);\n\tvc->vc_need_wrap = 0;\n}\n\nstatic void default_attr(struct vc_data *vc)\n{\n\tvc->state.intensity = VCI_NORMAL;\n\tvc->state.italic = false;\n\tvc->state.underline = false;\n\tvc->state.reverse = false;\n\tvc->state.blink = false;\n\tvc->state.color = vc->vc_def_color;\n}\n\nstruct rgb { u8 r; u8 g; u8 b; };\n\nstatic void rgb_from_256(int i, struct rgb *c)\n{\n\tif (i < 8) {             \n\t\tc->r = i&1 ? 0xaa : 0x00;\n\t\tc->g = i&2 ? 0xaa : 0x00;\n\t\tc->b = i&4 ? 0xaa : 0x00;\n\t} else if (i < 16) {\n\t\tc->r = i&1 ? 0xff : 0x55;\n\t\tc->g = i&2 ? 0xff : 0x55;\n\t\tc->b = i&4 ? 0xff : 0x55;\n\t} else if (i < 232) {    \n\t\tc->r = (i - 16) / 36 * 85 / 2;\n\t\tc->g = (i - 16) / 6 % 6 * 85 / 2;\n\t\tc->b = (i - 16) % 6 * 85 / 2;\n\t} else                   \n\t\tc->r = c->g = c->b = i * 10 - 2312;\n}\n\nstatic void rgb_foreground(struct vc_data *vc, const struct rgb *c)\n{\n\tu8 hue = 0, max = max3(c->r, c->g, c->b);\n\n\tif (c->r > max / 2)\n\t\thue |= 4;\n\tif (c->g > max / 2)\n\t\thue |= 2;\n\tif (c->b > max / 2)\n\t\thue |= 1;\n\n\tif (hue == 7 && max <= 0x55) {\n\t\thue = 0;\n\t\tvc->state.intensity = VCI_BOLD;\n\t} else if (max > 0xaa)\n\t\tvc->state.intensity = VCI_BOLD;\n\telse\n\t\tvc->state.intensity = VCI_NORMAL;\n\n\tvc->state.color = (vc->state.color & 0xf0) | hue;\n}\n\nstatic void rgb_background(struct vc_data *vc, const struct rgb *c)\n{\n\t \n\tvc->state.color = (vc->state.color & 0x0f)\n\t\t| (c->r&0x80) >> 1 | (c->g&0x80) >> 2 | (c->b&0x80) >> 3;\n}\n\n \nstatic int vc_t416_color(struct vc_data *vc, int i,\n\t\tvoid(*set_color)(struct vc_data *vc, const struct rgb *c))\n{\n\tstruct rgb c;\n\n\ti++;\n\tif (i > vc->vc_npar)\n\t\treturn i;\n\n\tif (vc->vc_par[i] == 5 && i + 1 <= vc->vc_npar) {\n\t\t \n\t\ti++;\n\t\trgb_from_256(vc->vc_par[i], &c);\n\t} else if (vc->vc_par[i] == 2 && i + 3 <= vc->vc_npar) {\n\t\t \n\t\tc.r = vc->vc_par[i + 1];\n\t\tc.g = vc->vc_par[i + 2];\n\t\tc.b = vc->vc_par[i + 3];\n\t\ti += 3;\n\t} else\n\t\treturn i;\n\n\tset_color(vc, &c);\n\n\treturn i;\n}\n\n \nstatic void csi_m(struct vc_data *vc)\n{\n\tint i;\n\n\tfor (i = 0; i <= vc->vc_npar; i++)\n\t\tswitch (vc->vc_par[i]) {\n\t\tcase 0:\t \n\t\t\tdefault_attr(vc);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tvc->state.intensity = VCI_BOLD;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvc->state.intensity = VCI_HALF_BRIGHT;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tvc->state.italic = true;\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\t \n\t\tcase 4:\n\t\t\tvc->state.underline = true;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tvc->state.blink = true;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tvc->state.reverse = true;\n\t\t\tbreak;\n\t\tcase 10:  \n\t\t\tvc->vc_translate = set_translate(vc->state.Gx_charset[vc->state.charset], vc);\n\t\t\tvc->vc_disp_ctrl = 0;\n\t\t\tvc->vc_toggle_meta = 0;\n\t\t\tbreak;\n\t\tcase 11:  \n\t\t\tvc->vc_translate = set_translate(IBMPC_MAP, vc);\n\t\t\tvc->vc_disp_ctrl = 1;\n\t\t\tvc->vc_toggle_meta = 0;\n\t\t\tbreak;\n\t\tcase 12:  \n\t\t\tvc->vc_translate = set_translate(IBMPC_MAP, vc);\n\t\t\tvc->vc_disp_ctrl = 1;\n\t\t\tvc->vc_toggle_meta = 1;\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tvc->state.intensity = VCI_NORMAL;\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tvc->state.italic = false;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tvc->state.underline = false;\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\tvc->state.blink = false;\n\t\t\tbreak;\n\t\tcase 27:\n\t\t\tvc->state.reverse = false;\n\t\t\tbreak;\n\t\tcase 38:\n\t\t\ti = vc_t416_color(vc, i, rgb_foreground);\n\t\t\tbreak;\n\t\tcase 48:\n\t\t\ti = vc_t416_color(vc, i, rgb_background);\n\t\t\tbreak;\n\t\tcase 39:\n\t\t\tvc->state.color = (vc->vc_def_color & 0x0f) |\n\t\t\t\t(vc->state.color & 0xf0);\n\t\t\tbreak;\n\t\tcase 49:\n\t\t\tvc->state.color = (vc->vc_def_color & 0xf0) |\n\t\t\t\t(vc->state.color & 0x0f);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (vc->vc_par[i] >= 90 && vc->vc_par[i] <= 107) {\n\t\t\t\tif (vc->vc_par[i] < 100)\n\t\t\t\t\tvc->state.intensity = VCI_BOLD;\n\t\t\t\tvc->vc_par[i] -= 60;\n\t\t\t}\n\t\t\tif (vc->vc_par[i] >= 30 && vc->vc_par[i] <= 37)\n\t\t\t\tvc->state.color = color_table[vc->vc_par[i] - 30]\n\t\t\t\t\t| (vc->state.color & 0xf0);\n\t\t\telse if (vc->vc_par[i] >= 40 && vc->vc_par[i] <= 47)\n\t\t\t\tvc->state.color = (color_table[vc->vc_par[i] - 40] << 4)\n\t\t\t\t\t| (vc->state.color & 0x0f);\n\t\t\tbreak;\n\t\t}\n\tupdate_attr(vc);\n}\n\nstatic void respond_string(const char *p, size_t len, struct tty_port *port)\n{\n\ttty_insert_flip_string(port, p, len);\n\ttty_flip_buffer_push(port);\n}\n\nstatic void cursor_report(struct vc_data *vc, struct tty_struct *tty)\n{\n\tchar buf[40];\n\tint len;\n\n\tlen = sprintf(buf, \"\\033[%d;%dR\", vc->state.y +\n\t\t\t(vc->vc_decom ? vc->vc_top + 1 : 1),\n\t\t\tvc->state.x + 1);\n\trespond_string(buf, len, tty->port);\n}\n\nstatic inline void status_report(struct tty_struct *tty)\n{\n\tstatic const char teminal_ok[] = \"\\033[0n\";\n\n\trespond_string(teminal_ok, strlen(teminal_ok), tty->port);\n}\n\nstatic inline void respond_ID(struct tty_struct *tty)\n{\n\t \n\tstatic const char vt102_id[] = \"\\033[?6c\";\n\n\trespond_string(vt102_id, strlen(vt102_id), tty->port);\n}\n\nvoid mouse_report(struct tty_struct *tty, int butt, int mrx, int mry)\n{\n\tchar buf[8];\n\tint len;\n\n\tlen = sprintf(buf, \"\\033[M%c%c%c\", (char)(' ' + butt),\n\t\t\t(char)('!' + mrx), (char)('!' + mry));\n\trespond_string(buf, len, tty->port);\n}\n\n \nint mouse_reporting(void)\n{\n\treturn vc_cons[fg_console].d->vc_report_mouse;\n}\n\n \nstatic void set_mode(struct vc_data *vc, int on_off)\n{\n\tint i;\n\n\tfor (i = 0; i <= vc->vc_npar; i++)\n\t\tif (vc->vc_priv == EPdec) {\n\t\t\tswitch(vc->vc_par[i]) {\t \n\t\t\tcase 1:\t\t\t \n\t\t\t\tif (on_off)\n\t\t\t\t\tset_kbd(vc, decckm);\n\t\t\t\telse\n\t\t\t\t\tclr_kbd(vc, decckm);\n\t\t\t\tbreak;\n\t\t\tcase 3:\t \n#if 0\n\t\t\t\tvc_resize(deccolm ? 132 : 80, vc->vc_rows);\n\t\t\t\t \n#endif\n\t\t\t\tbreak;\n\t\t\tcase 5:\t\t\t \n\t\t\t\tif (vc->vc_decscnm != on_off) {\n\t\t\t\t\tvc->vc_decscnm = on_off;\n\t\t\t\t\tinvert_screen(vc, 0,\n\t\t\t\t\t\t\tvc->vc_screenbuf_size,\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t\tupdate_attr(vc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 6:\t\t\t \n\t\t\t\tvc->vc_decom = on_off;\n\t\t\t\tgotoxay(vc, 0, 0);\n\t\t\t\tbreak;\n\t\t\tcase 7:\t\t\t \n\t\t\t\tvc->vc_decawm = on_off;\n\t\t\t\tbreak;\n\t\t\tcase 8:\t\t\t \n\t\t\t\tif (on_off)\n\t\t\t\t\tset_kbd(vc, decarm);\n\t\t\t\telse\n\t\t\t\t\tclr_kbd(vc, decarm);\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tvc->vc_report_mouse = on_off ? 1 : 0;\n\t\t\t\tbreak;\n\t\t\tcase 25:\t\t \n\t\t\t\tvc->vc_deccm = on_off;\n\t\t\t\tbreak;\n\t\t\tcase 1000:\n\t\t\t\tvc->vc_report_mouse = on_off ? 2 : 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch(vc->vc_par[i]) {\t \n\t\t\tcase 3:\t\t\t \n\t\t\t\tvc->vc_disp_ctrl = on_off;\n\t\t\t\tbreak;\n\t\t\tcase 4:\t\t\t \n\t\t\t\tvc->vc_decim = on_off;\n\t\t\t\tbreak;\n\t\t\tcase 20:\t\t \n\t\t\t\tif (on_off)\n\t\t\t\t\tset_kbd(vc, lnm);\n\t\t\t\telse\n\t\t\t\t\tclr_kbd(vc, lnm);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n}\n\n \nstatic void setterm_command(struct vc_data *vc)\n{\n\tswitch (vc->vc_par[0]) {\n\tcase 1:\t \n\t\tif (vc->vc_can_do_color && vc->vc_par[1] < 16) {\n\t\t\tvc->vc_ulcolor = color_table[vc->vc_par[1]];\n\t\t\tif (vc->state.underline)\n\t\t\t\tupdate_attr(vc);\n\t\t}\n\t\tbreak;\n\tcase 2:\t \n\t\tif (vc->vc_can_do_color && vc->vc_par[1] < 16) {\n\t\t\tvc->vc_halfcolor = color_table[vc->vc_par[1]];\n\t\t\tif (vc->state.intensity == VCI_HALF_BRIGHT)\n\t\t\t\tupdate_attr(vc);\n\t\t}\n\t\tbreak;\n\tcase 8:\t \n\t\tvc->vc_def_color = vc->vc_attr;\n\t\tif (vc->vc_hi_font_mask == 0x100)\n\t\t\tvc->vc_def_color >>= 1;\n\t\tdefault_attr(vc);\n\t\tupdate_attr(vc);\n\t\tbreak;\n\tcase 9:\t \n\t\tblankinterval = min(vc->vc_par[1], 60U) * 60;\n\t\tpoke_blanked_console();\n\t\tbreak;\n\tcase 10:  \n\t\tif (vc->vc_npar >= 1)\n\t\t\tvc->vc_bell_pitch = vc->vc_par[1];\n\t\telse\n\t\t\tvc->vc_bell_pitch = DEFAULT_BELL_PITCH;\n\t\tbreak;\n\tcase 11:  \n\t\tif (vc->vc_npar >= 1)\n\t\t\tvc->vc_bell_duration = (vc->vc_par[1] < 2000) ?\n\t\t\t\tmsecs_to_jiffies(vc->vc_par[1]) : 0;\n\t\telse\n\t\t\tvc->vc_bell_duration = DEFAULT_BELL_DURATION;\n\t\tbreak;\n\tcase 12:  \n\t\tif (vc->vc_par[1] >= 1 && vc_cons_allocated(vc->vc_par[1] - 1))\n\t\t\tset_console(vc->vc_par[1] - 1);\n\t\tbreak;\n\tcase 13:  \n\t\tpoke_blanked_console();\n\t\tbreak;\n\tcase 14:  \n\t\tvesa_off_interval = min(vc->vc_par[1], 60U) * 60 * HZ;\n\t\tbreak;\n\tcase 15:  \n\t\tset_console(last_console);\n\t\tbreak;\n\tcase 16:  \n\t\tif (vc->vc_npar >= 1 && vc->vc_par[1] >= 50 &&\n\t\t\t\tvc->vc_par[1] <= USHRT_MAX)\n\t\t\tvc->vc_cur_blink_ms = vc->vc_par[1];\n\t\telse\n\t\t\tvc->vc_cur_blink_ms = DEFAULT_CURSOR_BLINK_MS;\n\t\tbreak;\n\t}\n}\n\n \nstatic void csi_at(struct vc_data *vc, unsigned int nr)\n{\n\tif (nr > vc->vc_cols - vc->state.x)\n\t\tnr = vc->vc_cols - vc->state.x;\n\telse if (!nr)\n\t\tnr = 1;\n\tinsert_char(vc, nr);\n}\n\n \nstatic void csi_L(struct vc_data *vc, unsigned int nr)\n{\n\tif (nr > vc->vc_rows - vc->state.y)\n\t\tnr = vc->vc_rows - vc->state.y;\n\telse if (!nr)\n\t\tnr = 1;\n\tcon_scroll(vc, vc->state.y, vc->vc_bottom, SM_DOWN, nr);\n\tvc->vc_need_wrap = 0;\n}\n\n \nstatic void csi_P(struct vc_data *vc, unsigned int nr)\n{\n\tif (nr > vc->vc_cols - vc->state.x)\n\t\tnr = vc->vc_cols - vc->state.x;\n\telse if (!nr)\n\t\tnr = 1;\n\tdelete_char(vc, nr);\n}\n\n \nstatic void csi_M(struct vc_data *vc, unsigned int nr)\n{\n\tif (nr > vc->vc_rows - vc->state.y)\n\t\tnr = vc->vc_rows - vc->state.y;\n\telse if (!nr)\n\t\tnr=1;\n\tcon_scroll(vc, vc->state.y, vc->vc_bottom, SM_UP, nr);\n\tvc->vc_need_wrap = 0;\n}\n\n \nstatic void save_cur(struct vc_data *vc)\n{\n\tmemcpy(&vc->saved_state, &vc->state, sizeof(vc->state));\n}\n\n \nstatic void restore_cur(struct vc_data *vc)\n{\n\tmemcpy(&vc->state, &vc->saved_state, sizeof(vc->state));\n\n\tgotoxy(vc, vc->state.x, vc->state.y);\n\tvc->vc_translate = set_translate(vc->state.Gx_charset[vc->state.charset],\n\t\t\tvc);\n\tupdate_attr(vc);\n\tvc->vc_need_wrap = 0;\n}\n\nenum { ESnormal, ESesc, ESsquare, ESgetpars, ESfunckey,\n\tEShash, ESsetG0, ESsetG1, ESpercent, EScsiignore, ESnonstd,\n\tESpalette, ESosc, ESapc, ESpm, ESdcs };\n\n \nstatic void reset_terminal(struct vc_data *vc, int do_clear)\n{\n\tunsigned int i;\n\n\tvc->vc_top\t\t= 0;\n\tvc->vc_bottom\t\t= vc->vc_rows;\n\tvc->vc_state\t\t= ESnormal;\n\tvc->vc_priv\t\t= EPecma;\n\tvc->vc_translate\t= set_translate(LAT1_MAP, vc);\n\tvc->state.Gx_charset[0]\t= LAT1_MAP;\n\tvc->state.Gx_charset[1]\t= GRAF_MAP;\n\tvc->state.charset\t= 0;\n\tvc->vc_need_wrap\t= 0;\n\tvc->vc_report_mouse\t= 0;\n\tvc->vc_utf              = default_utf8;\n\tvc->vc_utf_count\t= 0;\n\n\tvc->vc_disp_ctrl\t= 0;\n\tvc->vc_toggle_meta\t= 0;\n\n\tvc->vc_decscnm\t\t= 0;\n\tvc->vc_decom\t\t= 0;\n\tvc->vc_decawm\t\t= 1;\n\tvc->vc_deccm\t\t= global_cursor_default;\n\tvc->vc_decim\t\t= 0;\n\n\tvt_reset_keyboard(vc->vc_num);\n\n\tvc->vc_cursor_type = cur_default;\n\tvc->vc_complement_mask = vc->vc_s_complement_mask;\n\n\tdefault_attr(vc);\n\tupdate_attr(vc);\n\n\tbitmap_zero(vc->vc_tab_stop, VC_TABSTOPS_COUNT);\n\tfor (i = 0; i < VC_TABSTOPS_COUNT; i += 8)\n\t\tset_bit(i, vc->vc_tab_stop);\n\n\tvc->vc_bell_pitch = DEFAULT_BELL_PITCH;\n\tvc->vc_bell_duration = DEFAULT_BELL_DURATION;\n\tvc->vc_cur_blink_ms = DEFAULT_CURSOR_BLINK_MS;\n\n\tgotoxy(vc, 0, 0);\n\tsave_cur(vc);\n\tif (do_clear)\n\t    csi_J(vc, 2);\n}\n\nstatic void vc_setGx(struct vc_data *vc, unsigned int which, int c)\n{\n\tunsigned char *charset = &vc->state.Gx_charset[which];\n\n\tswitch (c) {\n\tcase '0':\n\t\t*charset = GRAF_MAP;\n\t\tbreak;\n\tcase 'B':\n\t\t*charset = LAT1_MAP;\n\t\tbreak;\n\tcase 'U':\n\t\t*charset = IBMPC_MAP;\n\t\tbreak;\n\tcase 'K':\n\t\t*charset = USER_MAP;\n\t\tbreak;\n\t}\n\n\tif (vc->state.charset == which)\n\t\tvc->vc_translate = set_translate(*charset, vc);\n}\n\n \nstatic bool ansi_control_string(unsigned int state)\n{\n\tif (state == ESosc || state == ESapc || state == ESpm || state == ESdcs)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic void do_con_trol(struct tty_struct *tty, struct vc_data *vc, int c)\n{\n\t \n\tif (ansi_control_string(vc->vc_state) && c >= 8 && c <= 13)\n\t\treturn;\n\tswitch (c) {\n\tcase 0:\n\t\treturn;\n\tcase 7:\n\t\tif (ansi_control_string(vc->vc_state))\n\t\t\tvc->vc_state = ESnormal;\n\t\telse if (vc->vc_bell_duration)\n\t\t\tkd_mksound(vc->vc_bell_pitch, vc->vc_bell_duration);\n\t\treturn;\n\tcase 8:\n\t\tbs(vc);\n\t\treturn;\n\tcase 9:\n\t\tvc->vc_pos -= (vc->state.x << 1);\n\n\t\tvc->state.x = find_next_bit(vc->vc_tab_stop,\n\t\t\t\tmin(vc->vc_cols - 1, VC_TABSTOPS_COUNT),\n\t\t\t\tvc->state.x + 1);\n\t\tif (vc->state.x >= VC_TABSTOPS_COUNT)\n\t\t\tvc->state.x = vc->vc_cols - 1;\n\n\t\tvc->vc_pos += (vc->state.x << 1);\n\t\tnotify_write(vc, '\\t');\n\t\treturn;\n\tcase 10: case 11: case 12:\n\t\tlf(vc);\n\t\tif (!is_kbd(vc, lnm))\n\t\t\treturn;\n\t\tfallthrough;\n\tcase 13:\n\t\tcr(vc);\n\t\treturn;\n\tcase 14:\n\t\tvc->state.charset = 1;\n\t\tvc->vc_translate = set_translate(vc->state.Gx_charset[1], vc);\n\t\tvc->vc_disp_ctrl = 1;\n\t\treturn;\n\tcase 15:\n\t\tvc->state.charset = 0;\n\t\tvc->vc_translate = set_translate(vc->state.Gx_charset[0], vc);\n\t\tvc->vc_disp_ctrl = 0;\n\t\treturn;\n\tcase 24: case 26:\n\t\tvc->vc_state = ESnormal;\n\t\treturn;\n\tcase 27:\n\t\tvc->vc_state = ESesc;\n\t\treturn;\n\tcase 127:\n\t\tdel(vc);\n\t\treturn;\n\tcase 128+27:\n\t\tvc->vc_state = ESsquare;\n\t\treturn;\n\t}\n\tswitch(vc->vc_state) {\n\tcase ESesc:\n\t\tvc->vc_state = ESnormal;\n\t\tswitch (c) {\n\t\tcase '[':\n\t\t\tvc->vc_state = ESsquare;\n\t\t\treturn;\n\t\tcase ']':\n\t\t\tvc->vc_state = ESnonstd;\n\t\t\treturn;\n\t\tcase '_':\n\t\t\tvc->vc_state = ESapc;\n\t\t\treturn;\n\t\tcase '^':\n\t\t\tvc->vc_state = ESpm;\n\t\t\treturn;\n\t\tcase '%':\n\t\t\tvc->vc_state = ESpercent;\n\t\t\treturn;\n\t\tcase 'E':\n\t\t\tcr(vc);\n\t\t\tlf(vc);\n\t\t\treturn;\n\t\tcase 'M':\n\t\t\tri(vc);\n\t\t\treturn;\n\t\tcase 'D':\n\t\t\tlf(vc);\n\t\t\treturn;\n\t\tcase 'H':\n\t\t\tif (vc->state.x < VC_TABSTOPS_COUNT)\n\t\t\t\tset_bit(vc->state.x, vc->vc_tab_stop);\n\t\t\treturn;\n\t\tcase 'P':\n\t\t\tvc->vc_state = ESdcs;\n\t\t\treturn;\n\t\tcase 'Z':\n\t\t\trespond_ID(tty);\n\t\t\treturn;\n\t\tcase '7':\n\t\t\tsave_cur(vc);\n\t\t\treturn;\n\t\tcase '8':\n\t\t\trestore_cur(vc);\n\t\t\treturn;\n\t\tcase '(':\n\t\t\tvc->vc_state = ESsetG0;\n\t\t\treturn;\n\t\tcase ')':\n\t\t\tvc->vc_state = ESsetG1;\n\t\t\treturn;\n\t\tcase '#':\n\t\t\tvc->vc_state = EShash;\n\t\t\treturn;\n\t\tcase 'c':\n\t\t\treset_terminal(vc, 1);\n\t\t\treturn;\n\t\tcase '>':   \n\t\t\tclr_kbd(vc, kbdapplic);\n\t\t\treturn;\n\t\tcase '=':   \n\t\t\tset_kbd(vc, kbdapplic);\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\tcase ESnonstd:\n\t\tif (c=='P') {    \n\t\t\tfor (vc->vc_npar = 0; vc->vc_npar < NPAR; vc->vc_npar++)\n\t\t\t\tvc->vc_par[vc->vc_npar] = 0;\n\t\t\tvc->vc_npar = 0;\n\t\t\tvc->vc_state = ESpalette;\n\t\t\treturn;\n\t\t} else if (c=='R') {    \n\t\t\treset_palette(vc);\n\t\t\tvc->vc_state = ESnormal;\n\t\t} else if (c>='0' && c<='9')\n\t\t\tvc->vc_state = ESosc;\n\t\telse\n\t\t\tvc->vc_state = ESnormal;\n\t\treturn;\n\tcase ESpalette:\n\t\tif (isxdigit(c)) {\n\t\t\tvc->vc_par[vc->vc_npar++] = hex_to_bin(c);\n\t\t\tif (vc->vc_npar == 7) {\n\t\t\t\tint i = vc->vc_par[0] * 3, j = 1;\n\t\t\t\tvc->vc_palette[i] = 16 * vc->vc_par[j++];\n\t\t\t\tvc->vc_palette[i++] += vc->vc_par[j++];\n\t\t\t\tvc->vc_palette[i] = 16 * vc->vc_par[j++];\n\t\t\t\tvc->vc_palette[i++] += vc->vc_par[j++];\n\t\t\t\tvc->vc_palette[i] = 16 * vc->vc_par[j++];\n\t\t\t\tvc->vc_palette[i] += vc->vc_par[j];\n\t\t\t\tset_palette(vc);\n\t\t\t\tvc->vc_state = ESnormal;\n\t\t\t}\n\t\t} else\n\t\t\tvc->vc_state = ESnormal;\n\t\treturn;\n\tcase ESsquare:\n\t\tfor (vc->vc_npar = 0; vc->vc_npar < NPAR; vc->vc_npar++)\n\t\t\tvc->vc_par[vc->vc_npar] = 0;\n\t\tvc->vc_npar = 0;\n\t\tvc->vc_state = ESgetpars;\n\t\tif (c == '[') {  \n\t\t\tvc->vc_state=ESfunckey;\n\t\t\treturn;\n\t\t}\n\t\tswitch (c) {\n\t\tcase '?':\n\t\t\tvc->vc_priv = EPdec;\n\t\t\treturn;\n\t\tcase '>':\n\t\t\tvc->vc_priv = EPgt;\n\t\t\treturn;\n\t\tcase '=':\n\t\t\tvc->vc_priv = EPeq;\n\t\t\treturn;\n\t\tcase '<':\n\t\t\tvc->vc_priv = EPlt;\n\t\t\treturn;\n\t\t}\n\t\tvc->vc_priv = EPecma;\n\t\tfallthrough;\n\tcase ESgetpars:\n\t\tif (c == ';' && vc->vc_npar < NPAR - 1) {\n\t\t\tvc->vc_npar++;\n\t\t\treturn;\n\t\t} else if (c>='0' && c<='9') {\n\t\t\tvc->vc_par[vc->vc_npar] *= 10;\n\t\t\tvc->vc_par[vc->vc_npar] += c - '0';\n\t\t\treturn;\n\t\t}\n\t\tif (c >= 0x20 && c <= 0x3f) {  \n\t\t\tvc->vc_state = EScsiignore;\n\t\t\treturn;\n\t\t}\n\t\tvc->vc_state = ESnormal;\n\t\tswitch(c) {\n\t\tcase 'h':\n\t\t\tif (vc->vc_priv <= EPdec)\n\t\t\t\tset_mode(vc, 1);\n\t\t\treturn;\n\t\tcase 'l':\n\t\t\tif (vc->vc_priv <= EPdec)\n\t\t\t\tset_mode(vc, 0);\n\t\t\treturn;\n\t\tcase 'c':\n\t\t\tif (vc->vc_priv == EPdec) {\n\t\t\t\tif (vc->vc_par[0])\n\t\t\t\t\tvc->vc_cursor_type =\n\t\t\t\t\t\tCUR_MAKE(vc->vc_par[0],\n\t\t\t\t\t\t\t vc->vc_par[1],\n\t\t\t\t\t\t\t vc->vc_par[2]);\n\t\t\t\telse\n\t\t\t\t\tvc->vc_cursor_type = cur_default;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (vc->vc_priv == EPdec) {\n\t\t\t\tclear_selection();\n\t\t\t\tif (vc->vc_par[0])\n\t\t\t\t\tvc->vc_complement_mask = vc->vc_par[0] << 8 | vc->vc_par[1];\n\t\t\t\telse\n\t\t\t\t\tvc->vc_complement_mask = vc->vc_s_complement_mask;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (vc->vc_priv == EPecma) {\n\t\t\t\tif (vc->vc_par[0] == 5)\n\t\t\t\t\tstatus_report(tty);\n\t\t\t\telse if (vc->vc_par[0] == 6)\n\t\t\t\t\tcursor_report(vc, tty);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (vc->vc_priv != EPecma) {\n\t\t\tvc->vc_priv = EPecma;\n\t\t\treturn;\n\t\t}\n\t\tswitch(c) {\n\t\tcase 'G': case '`':\n\t\t\tif (vc->vc_par[0])\n\t\t\t\tvc->vc_par[0]--;\n\t\t\tgotoxy(vc, vc->vc_par[0], vc->state.y);\n\t\t\treturn;\n\t\tcase 'A':\n\t\t\tif (!vc->vc_par[0])\n\t\t\t\tvc->vc_par[0]++;\n\t\t\tgotoxy(vc, vc->state.x, vc->state.y - vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase 'B': case 'e':\n\t\t\tif (!vc->vc_par[0])\n\t\t\t\tvc->vc_par[0]++;\n\t\t\tgotoxy(vc, vc->state.x, vc->state.y + vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase 'C': case 'a':\n\t\t\tif (!vc->vc_par[0])\n\t\t\t\tvc->vc_par[0]++;\n\t\t\tgotoxy(vc, vc->state.x + vc->vc_par[0], vc->state.y);\n\t\t\treturn;\n\t\tcase 'D':\n\t\t\tif (!vc->vc_par[0])\n\t\t\t\tvc->vc_par[0]++;\n\t\t\tgotoxy(vc, vc->state.x - vc->vc_par[0], vc->state.y);\n\t\t\treturn;\n\t\tcase 'E':\n\t\t\tif (!vc->vc_par[0])\n\t\t\t\tvc->vc_par[0]++;\n\t\t\tgotoxy(vc, 0, vc->state.y + vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase 'F':\n\t\t\tif (!vc->vc_par[0])\n\t\t\t\tvc->vc_par[0]++;\n\t\t\tgotoxy(vc, 0, vc->state.y - vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase 'd':\n\t\t\tif (vc->vc_par[0])\n\t\t\t\tvc->vc_par[0]--;\n\t\t\tgotoxay(vc, vc->state.x ,vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase 'H': case 'f':\n\t\t\tif (vc->vc_par[0])\n\t\t\t\tvc->vc_par[0]--;\n\t\t\tif (vc->vc_par[1])\n\t\t\t\tvc->vc_par[1]--;\n\t\t\tgotoxay(vc, vc->vc_par[1], vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase 'J':\n\t\t\tcsi_J(vc, vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase 'K':\n\t\t\tcsi_K(vc, vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase 'L':\n\t\t\tcsi_L(vc, vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase 'M':\n\t\t\tcsi_M(vc, vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase 'P':\n\t\t\tcsi_P(vc, vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase 'c':\n\t\t\tif (!vc->vc_par[0])\n\t\t\t\trespond_ID(tty);\n\t\t\treturn;\n\t\tcase 'g':\n\t\t\tif (!vc->vc_par[0] && vc->state.x < VC_TABSTOPS_COUNT)\n\t\t\t\tset_bit(vc->state.x, vc->vc_tab_stop);\n\t\t\telse if (vc->vc_par[0] == 3)\n\t\t\t\tbitmap_zero(vc->vc_tab_stop, VC_TABSTOPS_COUNT);\n\t\t\treturn;\n\t\tcase 'm':\n\t\t\tcsi_m(vc);\n\t\t\treturn;\n\t\tcase 'q':  \n\t\t\t \n\t\t\tif (vc->vc_par[0] < 4)\n\t\t\t\tvt_set_led_state(vc->vc_num,\n\t\t\t\t\t    (vc->vc_par[0] < 3) ? vc->vc_par[0] : 4);\n\t\t\treturn;\n\t\tcase 'r':\n\t\t\tif (!vc->vc_par[0])\n\t\t\t\tvc->vc_par[0]++;\n\t\t\tif (!vc->vc_par[1])\n\t\t\t\tvc->vc_par[1] = vc->vc_rows;\n\t\t\t \n\t\t\tif (vc->vc_par[0] < vc->vc_par[1] &&\n\t\t\t    vc->vc_par[1] <= vc->vc_rows) {\n\t\t\t\tvc->vc_top = vc->vc_par[0] - 1;\n\t\t\t\tvc->vc_bottom = vc->vc_par[1];\n\t\t\t\tgotoxay(vc, 0, 0);\n\t\t\t}\n\t\t\treturn;\n\t\tcase 's':\n\t\t\tsave_cur(vc);\n\t\t\treturn;\n\t\tcase 'u':\n\t\t\trestore_cur(vc);\n\t\t\treturn;\n\t\tcase 'X':\n\t\t\tcsi_X(vc, vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase '@':\n\t\t\tcsi_at(vc, vc->vc_par[0]);\n\t\t\treturn;\n\t\tcase ']':  \n\t\t\tsetterm_command(vc);\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\tcase EScsiignore:\n\t\tif (c >= 20 && c <= 0x3f)\n\t\t\treturn;\n\t\tvc->vc_state = ESnormal;\n\t\treturn;\n\tcase ESpercent:\n\t\tvc->vc_state = ESnormal;\n\t\tswitch (c) {\n\t\tcase '@':   \n\t\t\tvc->vc_utf = 0;\n\t\t\treturn;\n\t\tcase 'G':   \n\t\tcase '8':   \n\t\t\tvc->vc_utf = 1;\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\tcase ESfunckey:\n\t\tvc->vc_state = ESnormal;\n\t\treturn;\n\tcase EShash:\n\t\tvc->vc_state = ESnormal;\n\t\tif (c == '8') {\n\t\t\t \n\t\t\tvc->vc_video_erase_char =\n\t\t\t\t(vc->vc_video_erase_char & 0xff00) | 'E';\n\t\t\tcsi_J(vc, 2);\n\t\t\tvc->vc_video_erase_char =\n\t\t\t\t(vc->vc_video_erase_char & 0xff00) | ' ';\n\t\t\tdo_update_region(vc, vc->vc_origin, vc->vc_screenbuf_size / 2);\n\t\t}\n\t\treturn;\n\tcase ESsetG0:\n\t\tvc_setGx(vc, 0, c);\n\t\tvc->vc_state = ESnormal;\n\t\treturn;\n\tcase ESsetG1:\n\t\tvc_setGx(vc, 1, c);\n\t\tvc->vc_state = ESnormal;\n\t\treturn;\n\tcase ESapc:\n\t\treturn;\n\tcase ESosc:\n\t\treturn;\n\tcase ESpm:\n\t\treturn;\n\tcase ESdcs:\n\t\treturn;\n\tdefault:\n\t\tvc->vc_state = ESnormal;\n\t}\n}\n\n \nstruct interval {\n\tuint32_t first;\n\tuint32_t last;\n};\n\nstatic int ucs_cmp(const void *key, const void *elt)\n{\n\tuint32_t ucs = *(uint32_t *)key;\n\tstruct interval e = *(struct interval *) elt;\n\n\tif (ucs > e.last)\n\t\treturn 1;\n\telse if (ucs < e.first)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int is_double_width(uint32_t ucs)\n{\n\tstatic const struct interval double_width[] = {\n\t\t{ 0x1100, 0x115F }, { 0x2329, 0x232A }, { 0x2E80, 0x303E },\n\t\t{ 0x3040, 0xA4CF }, { 0xAC00, 0xD7A3 }, { 0xF900, 0xFAFF },\n\t\t{ 0xFE10, 0xFE19 }, { 0xFE30, 0xFE6F }, { 0xFF00, 0xFF60 },\n\t\t{ 0xFFE0, 0xFFE6 }, { 0x20000, 0x2FFFD }, { 0x30000, 0x3FFFD }\n\t};\n\tif (ucs < double_width[0].first ||\n\t    ucs > double_width[ARRAY_SIZE(double_width) - 1].last)\n\t\treturn 0;\n\n\treturn bsearch(&ucs, double_width, ARRAY_SIZE(double_width),\n\t\t\tsizeof(struct interval), ucs_cmp) != NULL;\n}\n\nstruct vc_draw_region {\n\tunsigned long from, to;\n\tint x;\n};\n\nstatic void con_flush(struct vc_data *vc, struct vc_draw_region *draw)\n{\n\tif (draw->x < 0)\n\t\treturn;\n\n\tvc->vc_sw->con_putcs(vc, (u16 *)draw->from,\n\t\t\t(u16 *)draw->to - (u16 *)draw->from, vc->state.y,\n\t\t\tdraw->x);\n\tdraw->x = -1;\n}\n\nstatic inline int vc_translate_ascii(const struct vc_data *vc, int c)\n{\n\tif (IS_ENABLED(CONFIG_CONSOLE_TRANSLATIONS)) {\n\t\tif (vc->vc_toggle_meta)\n\t\t\tc |= 0x80;\n\n\t\treturn vc->vc_translate[c];\n\t}\n\n\treturn c;\n}\n\n\n \nstatic inline int vc_sanitize_unicode(const int c)\n{\n\tif ((c >= 0xd800 && c <= 0xdfff) || c == 0xfffe || c == 0xffff)\n\t\treturn 0xfffd;\n\n\treturn c;\n}\n\n \nstatic int vc_translate_unicode(struct vc_data *vc, int c, bool *rescan)\n{\n\tstatic const u32 utf8_length_changes[] = {\n\t\t0x0000007f, 0x000007ff, 0x0000ffff,\n\t\t0x001fffff, 0x03ffffff, 0x7fffffff\n\t};\n\n\t \n\tif ((c & 0xc0) == 0x80) {\n\t\t \n\t\tif (!vc->vc_utf_count)\n\t\t\treturn 0xfffd;\n\n\t\tvc->vc_utf_char = (vc->vc_utf_char << 6) | (c & 0x3f);\n\t\tvc->vc_npar++;\n\t\tif (--vc->vc_utf_count)\n\t\t\tgoto need_more_bytes;\n\n\t\t \n\t\tc = vc->vc_utf_char;\n\t\t \n\t\tif (c <= utf8_length_changes[vc->vc_npar - 1] ||\n\t\t\t\tc > utf8_length_changes[vc->vc_npar])\n\t\t\treturn 0xfffd;\n\n\t\treturn vc_sanitize_unicode(c);\n\t}\n\n\t \n\tif (vc->vc_utf_count) {\n\t\t \n\t\t*rescan = true;\n\t\tvc->vc_utf_count = 0;\n\t\treturn 0xfffd;\n\t}\n\n\t \n\tif (c <= 0x7f)\n\t\treturn c;\n\n\t \n\tvc->vc_npar = 0;\n\tif ((c & 0xe0) == 0xc0) {\n\t\tvc->vc_utf_count = 1;\n\t\tvc->vc_utf_char = (c & 0x1f);\n\t} else if ((c & 0xf0) == 0xe0) {\n\t\tvc->vc_utf_count = 2;\n\t\tvc->vc_utf_char = (c & 0x0f);\n\t} else if ((c & 0xf8) == 0xf0) {\n\t\tvc->vc_utf_count = 3;\n\t\tvc->vc_utf_char = (c & 0x07);\n\t} else if ((c & 0xfc) == 0xf8) {\n\t\tvc->vc_utf_count = 4;\n\t\tvc->vc_utf_char = (c & 0x03);\n\t} else if ((c & 0xfe) == 0xfc) {\n\t\tvc->vc_utf_count = 5;\n\t\tvc->vc_utf_char = (c & 0x01);\n\t} else {\n\t\t \n\t\treturn 0xfffd;\n\t}\n\nneed_more_bytes:\n\treturn -1;\n}\n\nstatic int vc_translate(struct vc_data *vc, int *c, bool *rescan)\n{\n\t \n\tif (vc->vc_state != ESnormal)\n\t\treturn *c;\n\n\tif (vc->vc_utf && !vc->vc_disp_ctrl)\n\t\treturn *c = vc_translate_unicode(vc, *c, rescan);\n\n\t \n\treturn vc_translate_ascii(vc, *c);\n}\n\nstatic inline unsigned char vc_invert_attr(const struct vc_data *vc)\n{\n\tif (!vc->vc_can_do_color)\n\t\treturn vc->vc_attr ^ 0x08;\n\n\tif (vc->vc_hi_font_mask == 0x100)\n\t\treturn   (vc->vc_attr & 0x11) |\n\t\t\t((vc->vc_attr & 0xe0) >> 4) |\n\t\t\t((vc->vc_attr & 0x0e) << 4);\n\n\treturn   (vc->vc_attr & 0x88) |\n\t\t((vc->vc_attr & 0x70) >> 4) |\n\t\t((vc->vc_attr & 0x07) << 4);\n}\n\nstatic bool vc_is_control(struct vc_data *vc, int tc, int c)\n{\n\t \n\tstatic const u32 CTRL_ACTION = 0x0d00ff81;\n\t \n\tstatic const u32 CTRL_ALWAYS = 0x0800f501;\n\n\tif (vc->vc_state != ESnormal)\n\t\treturn true;\n\n\tif (!tc)\n\t\treturn true;\n\n\t \n\tif (c < 32) {\n\t\tif (vc->vc_disp_ctrl)\n\t\t\treturn CTRL_ALWAYS & BIT(c);\n\t\telse\n\t\t\treturn vc->vc_utf || (CTRL_ACTION & BIT(c));\n\t}\n\n\tif (c == 127 && !vc->vc_disp_ctrl)\n\t\treturn true;\n\n\tif (c == 128 + 27)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int vc_con_write_normal(struct vc_data *vc, int tc, int c,\n\t\tstruct vc_draw_region *draw)\n{\n\tint next_c;\n\tunsigned char vc_attr = vc->vc_attr;\n\tu16 himask = vc->vc_hi_font_mask, charmask = himask ? 0x1ff : 0xff;\n\tu8 width = 1;\n\tbool inverse = false;\n\n\tif (vc->vc_utf && !vc->vc_disp_ctrl) {\n\t\tif (is_double_width(c))\n\t\t\twidth = 2;\n\t}\n\n\t \n\ttc = conv_uni_to_pc(vc, tc);\n\tif (tc & ~charmask) {\n\t\tif (tc == -1 || tc == -2)\n\t\t\treturn -1;  \n\n\t\t \n\t\tif ((!vc->vc_utf || vc->vc_disp_ctrl || c < 128) &&\n\t\t\t\t!(c & ~charmask)) {\n\t\t\t \n\t\t\ttc = c;\n\t\t} else {\n\t\t\t \n\t\t\ttc = conv_uni_to_pc(vc, 0xfffd);\n\t\t\tif (tc < 0) {\n\t\t\t\tinverse = true;\n\t\t\t\ttc = conv_uni_to_pc(vc, '?');\n\t\t\t\tif (tc < 0)\n\t\t\t\t\ttc = '?';\n\n\t\t\t\tvc_attr = vc_invert_attr(vc);\n\t\t\t\tcon_flush(vc, draw);\n\t\t\t}\n\t\t}\n\t}\n\n\tnext_c = c;\n\twhile (1) {\n\t\tif (vc->vc_need_wrap || vc->vc_decim)\n\t\t\tcon_flush(vc, draw);\n\t\tif (vc->vc_need_wrap) {\n\t\t\tcr(vc);\n\t\t\tlf(vc);\n\t\t}\n\t\tif (vc->vc_decim)\n\t\t\tinsert_char(vc, 1);\n\t\tvc_uniscr_putc(vc, next_c);\n\n\t\tif (himask)\n\t\t\ttc = ((tc & 0x100) ? himask : 0) |\n\t\t\t      (tc &  0xff);\n\t\ttc |= (vc_attr << 8) & ~himask;\n\n\t\tscr_writew(tc, (u16 *)vc->vc_pos);\n\n\t\tif (con_should_update(vc) && draw->x < 0) {\n\t\t\tdraw->x = vc->state.x;\n\t\t\tdraw->from = vc->vc_pos;\n\t\t}\n\t\tif (vc->state.x == vc->vc_cols - 1) {\n\t\t\tvc->vc_need_wrap = vc->vc_decawm;\n\t\t\tdraw->to = vc->vc_pos + 2;\n\t\t} else {\n\t\t\tvc->state.x++;\n\t\t\tdraw->to = (vc->vc_pos += 2);\n\t\t}\n\n\t\tif (!--width)\n\t\t\tbreak;\n\n\t\t \n\t\ttc = conv_uni_to_pc(vc, ' ');\n\t\tif (tc < 0)\n\t\t\ttc = ' ';\n\t\tnext_c = ' ';\n\t}\n\tnotify_write(vc, c);\n\n\tif (inverse)\n\t\tcon_flush(vc, draw);\n\n\treturn 0;\n}\n\n \nstatic int do_con_write(struct tty_struct *tty, const u8 *buf, int count)\n{\n\tstruct vc_draw_region draw = {\n\t\t.x = -1,\n\t};\n\tint c, tc, n = 0;\n\tunsigned int currcons;\n\tstruct vc_data *vc;\n\tstruct vt_notifier_param param;\n\tbool rescan;\n\n\tif (in_interrupt())\n\t\treturn count;\n\n\tconsole_lock();\n\tvc = tty->driver_data;\n\tif (vc == NULL) {\n\t\tpr_err(\"vt: argh, driver_data is NULL !\\n\");\n\t\tconsole_unlock();\n\t\treturn 0;\n\t}\n\n\tcurrcons = vc->vc_num;\n\tif (!vc_cons_allocated(currcons)) {\n\t\t \n\t\tpr_warn_once(\"con_write: tty %d not allocated\\n\", currcons+1);\n\t\tconsole_unlock();\n\t\treturn 0;\n\t}\n\n\n\t \n\tif (con_is_fg(vc))\n\t\thide_cursor(vc);\n\n\tparam.vc = vc;\n\n\twhile (!tty->flow.stopped && count) {\n\t\tint orig = *buf;\n\t\tbuf++;\n\t\tn++;\n\t\tcount--;\nrescan_last_byte:\n\t\tc = orig;\n\t\trescan = false;\n\n\t\ttc = vc_translate(vc, &c, &rescan);\n\t\tif (tc == -1)\n\t\t\tcontinue;\n\n\t\tparam.c = tc;\n\t\tif (atomic_notifier_call_chain(&vt_notifier_list, VT_PREWRITE,\n\t\t\t\t\t&param) == NOTIFY_STOP)\n\t\t\tcontinue;\n\n\t\tif (vc_is_control(vc, tc, c)) {\n\t\t\tcon_flush(vc, &draw);\n\t\t\tdo_con_trol(tty, vc, orig);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (vc_con_write_normal(vc, tc, c, &draw) < 0)\n\t\t\tcontinue;\n\n\t\tif (rescan)\n\t\t\tgoto rescan_last_byte;\n\t}\n\tcon_flush(vc, &draw);\n\tconsole_conditional_schedule();\n\tnotify_update(vc);\n\tconsole_unlock();\n\treturn n;\n}\n\n \nstatic void console_callback(struct work_struct *ignored)\n{\n\tconsole_lock();\n\n\tif (want_console >= 0) {\n\t\tif (want_console != fg_console &&\n\t\t    vc_cons_allocated(want_console)) {\n\t\t\thide_cursor(vc_cons[fg_console].d);\n\t\t\tchange_console(vc_cons[want_console].d);\n\t\t\t \n\t\t}\n\t\twant_console = -1;\n\t}\n\tif (do_poke_blanked_console) {  \n\t\tdo_poke_blanked_console = 0;\n\t\tpoke_blanked_console();\n\t}\n\tif (scrollback_delta) {\n\t\tstruct vc_data *vc = vc_cons[fg_console].d;\n\t\tclear_selection();\n\t\tif (vc->vc_mode == KD_TEXT && vc->vc_sw->con_scrolldelta)\n\t\t\tvc->vc_sw->con_scrolldelta(vc, scrollback_delta);\n\t\tscrollback_delta = 0;\n\t}\n\tif (blank_timer_expired) {\n\t\tdo_blank_screen(0);\n\t\tblank_timer_expired = 0;\n\t}\n\tnotify_update(vc_cons[fg_console].d);\n\n\tconsole_unlock();\n}\n\nint set_console(int nr)\n{\n\tstruct vc_data *vc = vc_cons[fg_console].d;\n\n\tif (!vc_cons_allocated(nr) || vt_dont_switch ||\n\t\t(vc->vt_mode.mode == VT_AUTO && vc->vc_mode == KD_GRAPHICS)) {\n\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\twant_console = nr;\n\tschedule_console_callback();\n\n\treturn 0;\n}\n\nstruct tty_driver *console_driver;\n\n#ifdef CONFIG_VT_CONSOLE\n\n \nint vt_kmsg_redirect(int new)\n{\n\tstatic int kmsg_con;\n\n\tif (new != -1)\n\t\treturn xchg(&kmsg_con, new);\n\telse\n\t\treturn kmsg_con;\n}\n\n \n\nstatic void vt_console_print(struct console *co, const char *b, unsigned count)\n{\n\tstruct vc_data *vc = vc_cons[fg_console].d;\n\tunsigned char c;\n\tstatic DEFINE_SPINLOCK(printing_lock);\n\tconst ushort *start;\n\tushort start_x, cnt;\n\tint kmsg_console;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\t \n\tif (!spin_trylock(&printing_lock))\n\t\treturn;\n\n\tkmsg_console = vt_get_kmsg_redirect();\n\tif (kmsg_console && vc_cons_allocated(kmsg_console - 1))\n\t\tvc = vc_cons[kmsg_console - 1].d;\n\n\tif (!vc_cons_allocated(fg_console)) {\n\t\t \n\t\t \n\t\tgoto quit;\n\t}\n\n\tif (vc->vc_mode != KD_TEXT)\n\t\tgoto quit;\n\n\t \n\tif (con_is_fg(vc))\n\t\thide_cursor(vc);\n\n\tstart = (ushort *)vc->vc_pos;\n\tstart_x = vc->state.x;\n\tcnt = 0;\n\twhile (count--) {\n\t\tc = *b++;\n\t\tif (c == 10 || c == 13 || c == 8 || vc->vc_need_wrap) {\n\t\t\tif (cnt && con_is_visible(vc))\n\t\t\t\tvc->vc_sw->con_putcs(vc, start, cnt, vc->state.y, start_x);\n\t\t\tcnt = 0;\n\t\t\tif (c == 8) {\t\t \n\t\t\t\tbs(vc);\n\t\t\t\tstart = (ushort *)vc->vc_pos;\n\t\t\t\tstart_x = vc->state.x;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c != 13)\n\t\t\t\tlf(vc);\n\t\t\tcr(vc);\n\t\t\tstart = (ushort *)vc->vc_pos;\n\t\t\tstart_x = vc->state.x;\n\t\t\tif (c == 10 || c == 13)\n\t\t\t\tcontinue;\n\t\t}\n\t\tvc_uniscr_putc(vc, c);\n\t\tscr_writew((vc->vc_attr << 8) + c, (unsigned short *)vc->vc_pos);\n\t\tnotify_write(vc, c);\n\t\tcnt++;\n\t\tif (vc->state.x == vc->vc_cols - 1) {\n\t\t\tvc->vc_need_wrap = 1;\n\t\t} else {\n\t\t\tvc->vc_pos += 2;\n\t\t\tvc->state.x++;\n\t\t}\n\t}\n\tif (cnt && con_is_visible(vc))\n\t\tvc->vc_sw->con_putcs(vc, start, cnt, vc->state.y, start_x);\n\tset_cursor(vc);\n\tnotify_update(vc);\n\nquit:\n\tspin_unlock(&printing_lock);\n}\n\nstatic struct tty_driver *vt_console_device(struct console *c, int *index)\n{\n\t*index = c->index ? c->index-1 : fg_console;\n\treturn console_driver;\n}\n\nstatic int vt_console_setup(struct console *co, char *options)\n{\n\treturn co->index >= MAX_NR_CONSOLES ? -EINVAL : 0;\n}\n\nstatic struct console vt_console_driver = {\n\t.name\t\t= \"tty\",\n\t.setup\t\t= vt_console_setup,\n\t.write\t\t= vt_console_print,\n\t.device\t\t= vt_console_device,\n\t.unblank\t= unblank_screen,\n\t.flags\t\t= CON_PRINTBUFFER,\n\t.index\t\t= -1,\n};\n#endif\n\n \n\n \n\nint tioclinux(struct tty_struct *tty, unsigned long arg)\n{\n\tchar type, data;\n\tchar __user *p = (char __user *)arg;\n\tint lines;\n\tint ret;\n\n\tif (current->signal->tty != tty && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (get_user(type, p))\n\t\treturn -EFAULT;\n\tret = 0;\n\n\tswitch (type) {\n\tcase TIOCL_SETSEL:\n\t\treturn set_selection_user((struct tiocl_selection\n\t\t\t\t\t __user *)(p+1), tty);\n\tcase TIOCL_PASTESEL:\n\t\treturn paste_selection(tty);\n\tcase TIOCL_UNBLANKSCREEN:\n\t\tconsole_lock();\n\t\tunblank_screen();\n\t\tconsole_unlock();\n\t\tbreak;\n\tcase TIOCL_SELLOADLUT:\n\t\tconsole_lock();\n\t\tret = sel_loadlut(p);\n\t\tconsole_unlock();\n\t\tbreak;\n\tcase TIOCL_GETSHIFTSTATE:\n\t\t \n\t\tdata = vt_get_shift_state();\n\t\treturn put_user(data, p);\n\tcase TIOCL_GETMOUSEREPORTING:\n\t\tconsole_lock();\t \n\t\tdata = mouse_reporting();\n\t\tconsole_unlock();\n\t\treturn put_user(data, p);\n\tcase TIOCL_SETVESABLANK:\n\t\tconsole_lock();\n\t\tret = set_vesa_blanking(p);\n\t\tconsole_unlock();\n\t\tbreak;\n\tcase TIOCL_GETKMSGREDIRECT:\n\t\tdata = vt_get_kmsg_redirect();\n\t\treturn put_user(data, p);\n\tcase TIOCL_SETKMSGREDIRECT:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(data, p+1))\n\t\t\treturn -EFAULT;\n\n\t\tvt_kmsg_redirect(data);\n\n\t\tbreak;\n\tcase TIOCL_GETFGCONSOLE:\n\t\t \n\t\treturn fg_console;\n\tcase TIOCL_SCROLLCONSOLE:\n\t\tif (get_user(lines, (s32 __user *)(p+4)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tconsole_lock();\n\t\tscrollfront(vc_cons[fg_console].d, lines);\n\t\tconsole_unlock();\n\t\tbreak;\n\tcase TIOCL_BLANKSCREEN:\t \n\t\tconsole_lock();\n\t\tignore_poke = 1;\n\t\tdo_blank_screen(0);\n\t\tconsole_unlock();\n\t\tbreak;\n\tcase TIOCL_BLANKEDSCREEN:\n\t\treturn console_blanked;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic ssize_t con_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tint\tretval;\n\n\tretval = do_con_write(tty, buf, count);\n\tcon_flush_chars(tty);\n\n\treturn retval;\n}\n\nstatic int con_put_char(struct tty_struct *tty, u8 ch)\n{\n\treturn do_con_write(tty, &ch, 1);\n}\n\nstatic unsigned int con_write_room(struct tty_struct *tty)\n{\n\tif (tty->flow.stopped)\n\t\treturn 0;\n\treturn 32768;\t\t \n}\n\n \nstatic void con_throttle(struct tty_struct *tty)\n{\n}\n\nstatic void con_unthrottle(struct tty_struct *tty)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\n\twake_up_interruptible(&vc->paste_wait);\n}\n\n \nstatic void con_stop(struct tty_struct *tty)\n{\n\tint console_num;\n\tif (!tty)\n\t\treturn;\n\tconsole_num = tty->index;\n\tif (!vc_cons_allocated(console_num))\n\t\treturn;\n\tvt_kbd_con_stop(console_num);\n}\n\n \nstatic void con_start(struct tty_struct *tty)\n{\n\tint console_num;\n\tif (!tty)\n\t\treturn;\n\tconsole_num = tty->index;\n\tif (!vc_cons_allocated(console_num))\n\t\treturn;\n\tvt_kbd_con_start(console_num);\n}\n\nstatic void con_flush_chars(struct tty_struct *tty)\n{\n\tstruct vc_data *vc;\n\n\tif (in_interrupt())\t \n\t\treturn;\n\n\t \n\tconsole_lock();\n\tvc = tty->driver_data;\n\tif (vc)\n\t\tset_cursor(vc);\n\tconsole_unlock();\n}\n\n \nstatic int con_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tunsigned int currcons = tty->index;\n\tstruct vc_data *vc;\n\tint ret;\n\n\tconsole_lock();\n\tret = vc_allocate(currcons);\n\tif (ret)\n\t\tgoto unlock;\n\n\tvc = vc_cons[currcons].d;\n\n\t \n\tif (vc->port.tty) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto unlock;\n\t}\n\n\tret = tty_port_install(&vc->port, driver, tty);\n\tif (ret)\n\t\tgoto unlock;\n\n\ttty->driver_data = vc;\n\tvc->port.tty = tty;\n\ttty_port_get(&vc->port);\n\n\tif (!tty->winsize.ws_row && !tty->winsize.ws_col) {\n\t\ttty->winsize.ws_row = vc_cons[currcons].d->vc_rows;\n\t\ttty->winsize.ws_col = vc_cons[currcons].d->vc_cols;\n\t}\n\tif (vc->vc_utf)\n\t\ttty->termios.c_iflag |= IUTF8;\n\telse\n\t\ttty->termios.c_iflag &= ~IUTF8;\nunlock:\n\tconsole_unlock();\n\treturn ret;\n}\n\nstatic int con_open(struct tty_struct *tty, struct file *filp)\n{\n\t \n\treturn 0;\n}\n\n\nstatic void con_close(struct tty_struct *tty, struct file *filp)\n{\n\t \n}\n\nstatic void con_shutdown(struct tty_struct *tty)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tBUG_ON(vc == NULL);\n\tconsole_lock();\n\tvc->port.tty = NULL;\n\tconsole_unlock();\n}\n\nstatic void con_cleanup(struct tty_struct *tty)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\n\ttty_port_put(&vc->port);\n}\n\nstatic int default_color           = 7;  \nstatic int default_italic_color    = 2; \nstatic int default_underline_color = 3; \nmodule_param_named(color, default_color, int, S_IRUGO | S_IWUSR);\nmodule_param_named(italic, default_italic_color, int, S_IRUGO | S_IWUSR);\nmodule_param_named(underline, default_underline_color, int, S_IRUGO | S_IWUSR);\n\nstatic void vc_init(struct vc_data *vc, int do_clear)\n{\n\tint j, k ;\n\n\tset_origin(vc);\n\tvc->vc_pos = vc->vc_origin;\n\treset_vc(vc);\n\tfor (j=k=0; j<16; j++) {\n\t\tvc->vc_palette[k++] = default_red[j] ;\n\t\tvc->vc_palette[k++] = default_grn[j] ;\n\t\tvc->vc_palette[k++] = default_blu[j] ;\n\t}\n\tvc->vc_def_color       = default_color;\n\tvc->vc_ulcolor         = default_underline_color;\n\tvc->vc_itcolor         = default_italic_color;\n\tvc->vc_halfcolor       = 0x08;    \n\tinit_waitqueue_head(&vc->paste_wait);\n\treset_terminal(vc, do_clear);\n}\n\n \n\nstatic int __init con_init(void)\n{\n\tconst char *display_desc = NULL;\n\tstruct vc_data *vc;\n\tunsigned int currcons = 0, i;\n\n\tconsole_lock();\n\n\tif (!conswitchp)\n\t\tconswitchp = &dummy_con;\n\tdisplay_desc = conswitchp->con_startup();\n\tif (!display_desc) {\n\t\tfg_console = 0;\n\t\tconsole_unlock();\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\n\t\tstruct con_driver *con_driver = &registered_con_driver[i];\n\n\t\tif (con_driver->con == NULL) {\n\t\t\tcon_driver->con = conswitchp;\n\t\t\tcon_driver->desc = display_desc;\n\t\t\tcon_driver->flag = CON_DRIVER_FLAG_INIT;\n\t\t\tcon_driver->first = 0;\n\t\t\tcon_driver->last = MAX_NR_CONSOLES - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++)\n\t\tcon_driver_map[i] = conswitchp;\n\n\tif (blankinterval) {\n\t\tblank_state = blank_normal_wait;\n\t\tmod_timer(&console_timer, jiffies + (blankinterval * HZ));\n\t}\n\n\tfor (currcons = 0; currcons < MIN_NR_CONSOLES; currcons++) {\n\t\tvc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);\n\t\tINIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);\n\t\ttty_port_init(&vc->port);\n\t\tvisual_init(vc, currcons, 1);\n\t\t \n\t\tvc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_NOWAIT);\n\t\tvc_init(vc, currcons || !vc->vc_sw->con_save_screen);\n\t}\n\tcurrcons = fg_console = 0;\n\tmaster_display_fg = vc = vc_cons[currcons].d;\n\tset_origin(vc);\n\tsave_screen(vc);\n\tgotoxy(vc, vc->state.x, vc->state.y);\n\tcsi_J(vc, 0);\n\tupdate_screen(vc);\n\tpr_info(\"Console: %s %s %dx%d\\n\",\n\t\tvc->vc_can_do_color ? \"colour\" : \"mono\",\n\t\tdisplay_desc, vc->vc_cols, vc->vc_rows);\n\n\tconsole_unlock();\n\n#ifdef CONFIG_VT_CONSOLE\n\tregister_console(&vt_console_driver);\n#endif\n\treturn 0;\n}\nconsole_initcall(con_init);\n\nstatic const struct tty_operations con_ops = {\n\t.install = con_install,\n\t.open = con_open,\n\t.close = con_close,\n\t.write = con_write,\n\t.write_room = con_write_room,\n\t.put_char = con_put_char,\n\t.flush_chars = con_flush_chars,\n\t.ioctl = vt_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = vt_compat_ioctl,\n#endif\n\t.stop = con_stop,\n\t.start = con_start,\n\t.throttle = con_throttle,\n\t.unthrottle = con_unthrottle,\n\t.resize = vt_resize,\n\t.shutdown = con_shutdown,\n\t.cleanup = con_cleanup,\n};\n\nstatic struct cdev vc0_cdev;\n\nstatic ssize_t show_tty_active(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"tty%d\\n\", fg_console + 1);\n}\nstatic DEVICE_ATTR(active, S_IRUGO, show_tty_active, NULL);\n\nstatic struct attribute *vt_dev_attrs[] = {\n\t&dev_attr_active.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(vt_dev);\n\nint __init vty_init(const struct file_operations *console_fops)\n{\n\tcdev_init(&vc0_cdev, console_fops);\n\tif (cdev_add(&vc0_cdev, MKDEV(TTY_MAJOR, 0), 1) ||\n\t    register_chrdev_region(MKDEV(TTY_MAJOR, 0), 1, \"/dev/vc/0\") < 0)\n\t\tpanic(\"Couldn't register /dev/tty0 driver\\n\");\n\ttty0dev = device_create_with_groups(&tty_class, NULL,\n\t\t\t\t\t    MKDEV(TTY_MAJOR, 0), NULL,\n\t\t\t\t\t    vt_dev_groups, \"tty0\");\n\tif (IS_ERR(tty0dev))\n\t\ttty0dev = NULL;\n\n\tvcs_init();\n\n\tconsole_driver = tty_alloc_driver(MAX_NR_CONSOLES, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_RESET_TERMIOS);\n\tif (IS_ERR(console_driver))\n\t\tpanic(\"Couldn't allocate console driver\\n\");\n\n\tconsole_driver->name = \"tty\";\n\tconsole_driver->name_base = 1;\n\tconsole_driver->major = TTY_MAJOR;\n\tconsole_driver->minor_start = 1;\n\tconsole_driver->type = TTY_DRIVER_TYPE_CONSOLE;\n\tconsole_driver->init_termios = tty_std_termios;\n\tif (default_utf8)\n\t\tconsole_driver->init_termios.c_iflag |= IUTF8;\n\ttty_set_operations(console_driver, &con_ops);\n\tif (tty_register_driver(console_driver))\n\t\tpanic(\"Couldn't register console driver\\n\");\n\tkbd_init();\n\tconsole_map_init();\n#ifdef CONFIG_MDA_CONSOLE\n\tmda_console_init();\n#endif\n\treturn 0;\n}\n\nstatic struct class *vtconsole_class;\n\nstatic int do_bind_con_driver(const struct consw *csw, int first, int last,\n\t\t\t   int deflt)\n{\n\tstruct module *owner = csw->owner;\n\tconst char *desc = NULL;\n\tstruct con_driver *con_driver;\n\tint i, j = -1, k = -1, retval = -ENODEV;\n\n\tif (!try_module_get(owner))\n\t\treturn -ENODEV;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\t \n\tfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\n\t\tcon_driver = &registered_con_driver[i];\n\n\t\tif (con_driver->con == csw) {\n\t\t\tdesc = con_driver->desc;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retval)\n\t\tgoto err;\n\n\tif (!(con_driver->flag & CON_DRIVER_FLAG_INIT)) {\n\t\tcsw->con_startup();\n\t\tcon_driver->flag |= CON_DRIVER_FLAG_INIT;\n\t}\n\n\tif (deflt) {\n\t\tif (conswitchp)\n\t\t\tmodule_put(conswitchp->owner);\n\n\t\t__module_get(owner);\n\t\tconswitchp = csw;\n\t}\n\n\tfirst = max(first, con_driver->first);\n\tlast = min(last, con_driver->last);\n\n\tfor (i = first; i <= last; i++) {\n\t\tint old_was_color;\n\t\tstruct vc_data *vc = vc_cons[i].d;\n\n\t\tif (con_driver_map[i])\n\t\t\tmodule_put(con_driver_map[i]->owner);\n\t\t__module_get(owner);\n\t\tcon_driver_map[i] = csw;\n\n\t\tif (!vc || !vc->vc_sw)\n\t\t\tcontinue;\n\n\t\tj = i;\n\n\t\tif (con_is_visible(vc)) {\n\t\t\tk = i;\n\t\t\tsave_screen(vc);\n\t\t}\n\n\t\told_was_color = vc->vc_can_do_color;\n\t\tvc->vc_sw->con_deinit(vc);\n\t\tvc->vc_origin = (unsigned long)vc->vc_screenbuf;\n\t\tvisual_init(vc, i, 0);\n\t\tset_origin(vc);\n\t\tupdate_attr(vc);\n\n\t\t \n\t\tif (old_was_color != vc->vc_can_do_color)\n\t\t\tclear_buffer_attributes(vc);\n\t}\n\n\tpr_info(\"Console: switching \");\n\tif (!deflt)\n\t\tpr_cont(\"consoles %d-%d \", first + 1, last + 1);\n\tif (j >= 0) {\n\t\tstruct vc_data *vc = vc_cons[j].d;\n\n\t\tpr_cont(\"to %s %s %dx%d\\n\",\n\t\t\tvc->vc_can_do_color ? \"colour\" : \"mono\",\n\t\t\tdesc, vc->vc_cols, vc->vc_rows);\n\n\t\tif (k >= 0) {\n\t\t\tvc = vc_cons[k].d;\n\t\t\tupdate_screen(vc);\n\t\t}\n\t} else {\n\t\tpr_cont(\"to %s\\n\", desc);\n\t}\n\n\tretval = 0;\nerr:\n\tmodule_put(owner);\n\treturn retval;\n};\n\n\n#ifdef CONFIG_VT_HW_CONSOLE_BINDING\nint do_unbind_con_driver(const struct consw *csw, int first, int last, int deflt)\n{\n\tstruct module *owner = csw->owner;\n\tconst struct consw *defcsw = NULL;\n\tstruct con_driver *con_driver = NULL, *con_back = NULL;\n\tint i, retval = -ENODEV;\n\n\tif (!try_module_get(owner))\n\t\treturn -ENODEV;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\t \n\tfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\n\t\tcon_driver = &registered_con_driver[i];\n\n\t\tif (con_driver->con == csw &&\n\t\t    con_driver->flag & CON_DRIVER_FLAG_MODULE) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retval)\n\t\tgoto err;\n\n\tretval = -ENODEV;\n\n\t \n\tfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\n\t\tcon_back = &registered_con_driver[i];\n\n\t\tif (con_back->con && con_back->con != csw) {\n\t\t\tdefcsw = con_back->con;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retval)\n\t\tgoto err;\n\n\tif (!con_is_bound(csw))\n\t\tgoto err;\n\n\tfirst = max(first, con_driver->first);\n\tlast = min(last, con_driver->last);\n\n\tfor (i = first; i <= last; i++) {\n\t\tif (con_driver_map[i] == csw) {\n\t\t\tmodule_put(csw->owner);\n\t\t\tcon_driver_map[i] = NULL;\n\t\t}\n\t}\n\n\tif (!con_is_bound(defcsw)) {\n\t\tconst struct consw *defconsw = conswitchp;\n\n\t\tdefcsw->con_startup();\n\t\tcon_back->flag |= CON_DRIVER_FLAG_INIT;\n\t\t \n\t\tconswitchp = defconsw;\n\t}\n\n\tif (!con_is_bound(csw))\n\t\tcon_driver->flag &= ~CON_DRIVER_FLAG_INIT;\n\n\t \n\tdo_bind_con_driver(defcsw, first, last, deflt);\nerr:\n\tmodule_put(owner);\n\treturn retval;\n\n}\nEXPORT_SYMBOL_GPL(do_unbind_con_driver);\n\nstatic int vt_bind(struct con_driver *con)\n{\n\tconst struct consw *defcsw = NULL, *csw = NULL;\n\tint i, more = 1, first = -1, last = -1, deflt = 0;\n\n \tif (!con->con || !(con->flag & CON_DRIVER_FLAG_MODULE))\n\t\tgoto err;\n\n\tcsw = con->con;\n\n\tfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\n\t\tstruct con_driver *con = &registered_con_driver[i];\n\n\t\tif (con->con && !(con->flag & CON_DRIVER_FLAG_MODULE)) {\n\t\t\tdefcsw = con->con;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!defcsw)\n\t\tgoto err;\n\n\twhile (more) {\n\t\tmore = 0;\n\n\t\tfor (i = con->first; i <= con->last; i++) {\n\t\t\tif (con_driver_map[i] == defcsw) {\n\t\t\t\tif (first == -1)\n\t\t\t\t\tfirst = i;\n\t\t\t\tlast = i;\n\t\t\t\tmore = 1;\n\t\t\t} else if (first != -1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (first == 0 && last == MAX_NR_CONSOLES -1)\n\t\t\tdeflt = 1;\n\n\t\tif (first != -1)\n\t\t\tdo_bind_con_driver(csw, first, last, deflt);\n\n\t\tfirst = -1;\n\t\tlast = -1;\n\t\tdeflt = 0;\n\t}\n\nerr:\n\treturn 0;\n}\n\nstatic int vt_unbind(struct con_driver *con)\n{\n\tconst struct consw *csw = NULL;\n\tint i, more = 1, first = -1, last = -1, deflt = 0;\n\tint ret;\n\n \tif (!con->con || !(con->flag & CON_DRIVER_FLAG_MODULE))\n\t\tgoto err;\n\n\tcsw = con->con;\n\n\twhile (more) {\n\t\tmore = 0;\n\n\t\tfor (i = con->first; i <= con->last; i++) {\n\t\t\tif (con_driver_map[i] == csw) {\n\t\t\t\tif (first == -1)\n\t\t\t\t\tfirst = i;\n\t\t\t\tlast = i;\n\t\t\t\tmore = 1;\n\t\t\t} else if (first != -1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (first == 0 && last == MAX_NR_CONSOLES -1)\n\t\t\tdeflt = 1;\n\n\t\tif (first != -1) {\n\t\t\tret = do_unbind_con_driver(csw, first, last, deflt);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tfirst = -1;\n\t\tlast = -1;\n\t\tdeflt = 0;\n\t}\n\nerr:\n\treturn 0;\n}\n#else\nstatic inline int vt_bind(struct con_driver *con)\n{\n\treturn 0;\n}\nstatic inline int vt_unbind(struct con_driver *con)\n{\n\treturn 0;\n}\n#endif  \n\nstatic ssize_t store_bind(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct con_driver *con = dev_get_drvdata(dev);\n\tint bind = simple_strtoul(buf, NULL, 0);\n\n\tconsole_lock();\n\n\tif (bind)\n\t\tvt_bind(con);\n\telse\n\t\tvt_unbind(con);\n\n\tconsole_unlock();\n\n\treturn count;\n}\n\nstatic ssize_t show_bind(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct con_driver *con = dev_get_drvdata(dev);\n\tint bind;\n\n\tconsole_lock();\n\tbind = con_is_bound(con->con);\n\tconsole_unlock();\n\n\treturn sysfs_emit(buf, \"%i\\n\", bind);\n}\n\nstatic ssize_t show_name(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct con_driver *con = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s %s\\n\",\n\t\t\t(con->flag & CON_DRIVER_FLAG_MODULE) ? \"(M)\" : \"(S)\",\n\t\t\t con->desc);\n\n}\n\nstatic DEVICE_ATTR(bind, S_IRUGO|S_IWUSR, show_bind, store_bind);\nstatic DEVICE_ATTR(name, S_IRUGO, show_name, NULL);\n\nstatic struct attribute *con_dev_attrs[] = {\n\t&dev_attr_bind.attr,\n\t&dev_attr_name.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(con_dev);\n\nstatic int vtconsole_init_device(struct con_driver *con)\n{\n\tcon->flag |= CON_DRIVER_FLAG_ATTR;\n\treturn 0;\n}\n\nstatic void vtconsole_deinit_device(struct con_driver *con)\n{\n\tcon->flag &= ~CON_DRIVER_FLAG_ATTR;\n}\n\n \nint con_is_bound(const struct consw *csw)\n{\n\tint i, bound = 0;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tif (con_driver_map[i] == csw) {\n\t\t\tbound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bound;\n}\nEXPORT_SYMBOL(con_is_bound);\n\n \nbool con_is_visible(const struct vc_data *vc)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\treturn *vc->vc_display_fg == vc;\n}\nEXPORT_SYMBOL(con_is_visible);\n\n \nint con_debug_enter(struct vc_data *vc)\n{\n\tint ret = 0;\n\n\tsaved_fg_console = fg_console;\n\tsaved_last_console = last_console;\n\tsaved_want_console = want_console;\n\tsaved_vc_mode = vc->vc_mode;\n\tsaved_console_blanked = console_blanked;\n\tvc->vc_mode = KD_TEXT;\n\tconsole_blanked = 0;\n\tif (vc->vc_sw->con_debug_enter)\n\t\tret = vc->vc_sw->con_debug_enter(vc);\n#ifdef CONFIG_KGDB_KDB\n\t \n\tif (vc->vc_rows < 999) {\n\t\tint linecount;\n\t\tchar lns[4];\n\t\tconst char *setargs[3] = {\n\t\t\t\"set\",\n\t\t\t\"LINES\",\n\t\t\tlns,\n\t\t};\n\t\tif (kdbgetintenv(setargs[0], &linecount)) {\n\t\t\tsnprintf(lns, 4, \"%i\", vc->vc_rows);\n\t\t\tkdb_set(2, setargs);\n\t\t}\n\t}\n\tif (vc->vc_cols < 999) {\n\t\tint colcount;\n\t\tchar cols[4];\n\t\tconst char *setargs[3] = {\n\t\t\t\"set\",\n\t\t\t\"COLUMNS\",\n\t\t\tcols,\n\t\t};\n\t\tif (kdbgetintenv(setargs[0], &colcount)) {\n\t\t\tsnprintf(cols, 4, \"%i\", vc->vc_cols);\n\t\t\tkdb_set(2, setargs);\n\t\t}\n\t}\n#endif  \n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(con_debug_enter);\n\n \nint con_debug_leave(void)\n{\n\tstruct vc_data *vc;\n\tint ret = 0;\n\n\tfg_console = saved_fg_console;\n\tlast_console = saved_last_console;\n\twant_console = saved_want_console;\n\tconsole_blanked = saved_console_blanked;\n\tvc_cons[fg_console].d->vc_mode = saved_vc_mode;\n\n\tvc = vc_cons[fg_console].d;\n\tif (vc->vc_sw->con_debug_leave)\n\t\tret = vc->vc_sw->con_debug_leave(vc);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(con_debug_leave);\n\nstatic int do_register_con_driver(const struct consw *csw, int first, int last)\n{\n\tstruct module *owner = csw->owner;\n\tstruct con_driver *con_driver;\n\tconst char *desc;\n\tint i, retval;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (!try_module_get(owner))\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\n\t\tcon_driver = &registered_con_driver[i];\n\n\t\t \n\t\tif (con_driver->con == csw) {\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdesc = csw->con_startup();\n\tif (!desc) {\n\t\tretval = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tretval = -EINVAL;\n\n\tfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\n\t\tcon_driver = &registered_con_driver[i];\n\n\t\tif (con_driver->con == NULL &&\n\t\t    !(con_driver->flag & CON_DRIVER_FLAG_ZOMBIE)) {\n\t\t\tcon_driver->con = csw;\n\t\t\tcon_driver->desc = desc;\n\t\t\tcon_driver->node = i;\n\t\t\tcon_driver->flag = CON_DRIVER_FLAG_MODULE |\n\t\t\t                   CON_DRIVER_FLAG_INIT;\n\t\t\tcon_driver->first = first;\n\t\t\tcon_driver->last = last;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retval)\n\t\tgoto err;\n\n\tcon_driver->dev =\n\t\tdevice_create_with_groups(vtconsole_class, NULL,\n\t\t\t\t\t  MKDEV(0, con_driver->node),\n\t\t\t\t\t  con_driver, con_dev_groups,\n\t\t\t\t\t  \"vtcon%i\", con_driver->node);\n\tif (IS_ERR(con_driver->dev)) {\n\t\tpr_warn(\"Unable to create device for %s; errno = %ld\\n\",\n\t\t\tcon_driver->desc, PTR_ERR(con_driver->dev));\n\t\tcon_driver->dev = NULL;\n\t} else {\n\t\tvtconsole_init_device(con_driver);\n\t}\n\nerr:\n\tmodule_put(owner);\n\treturn retval;\n}\n\n\n \nint do_unregister_con_driver(const struct consw *csw)\n{\n\tint i;\n\n\t \n\tif (con_is_bound(csw))\n\t\treturn -EBUSY;\n\n\tif (csw == conswitchp)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\n\t\tstruct con_driver *con_driver = &registered_con_driver[i];\n\n\t\tif (con_driver->con == csw) {\n\t\t\t \n\t\t\tcon_driver->con = NULL;\n\t\t\tcon_driver->flag = CON_DRIVER_FLAG_ZOMBIE;\n\t\t\tschedule_work(&con_driver_unregister_work);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(do_unregister_con_driver);\n\nstatic void con_driver_unregister_callback(struct work_struct *ignored)\n{\n\tint i;\n\n\tconsole_lock();\n\n\tfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\n\t\tstruct con_driver *con_driver = &registered_con_driver[i];\n\n\t\tif (!(con_driver->flag & CON_DRIVER_FLAG_ZOMBIE))\n\t\t\tcontinue;\n\n\t\tconsole_unlock();\n\n\t\tvtconsole_deinit_device(con_driver);\n\t\tdevice_destroy(vtconsole_class, MKDEV(0, con_driver->node));\n\n\t\tconsole_lock();\n\n\t\tif (WARN_ON_ONCE(con_driver->con))\n\t\t\tcon_driver->con = NULL;\n\t\tcon_driver->desc = NULL;\n\t\tcon_driver->dev = NULL;\n\t\tcon_driver->node = 0;\n\t\tWARN_ON_ONCE(con_driver->flag != CON_DRIVER_FLAG_ZOMBIE);\n\t\tcon_driver->flag = 0;\n\t\tcon_driver->first = 0;\n\t\tcon_driver->last = 0;\n\t}\n\n\tconsole_unlock();\n}\n\n \nint do_take_over_console(const struct consw *csw, int first, int last, int deflt)\n{\n\tint err;\n\n\terr = do_register_con_driver(csw, first, last);\n\t \n\tif (err == -EBUSY)\n\t\terr = 0;\n\tif (!err)\n\t\tdo_bind_con_driver(csw, first, last, deflt);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(do_take_over_console);\n\n\n \nvoid give_up_console(const struct consw *csw)\n{\n\tconsole_lock();\n\tdo_unregister_con_driver(csw);\n\tconsole_unlock();\n}\nEXPORT_SYMBOL(give_up_console);\n\nstatic int __init vtconsole_class_init(void)\n{\n\tint i;\n\n\tvtconsole_class = class_create(\"vtconsole\");\n\tif (IS_ERR(vtconsole_class)) {\n\t\tpr_warn(\"Unable to create vt console class; errno = %ld\\n\",\n\t\t\tPTR_ERR(vtconsole_class));\n\t\tvtconsole_class = NULL;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\n\t\tstruct con_driver *con = &registered_con_driver[i];\n\n\t\tif (con->con && !con->dev) {\n\t\t\tcon->dev =\n\t\t\t\tdevice_create_with_groups(vtconsole_class, NULL,\n\t\t\t\t\t\t\t  MKDEV(0, con->node),\n\t\t\t\t\t\t\t  con, con_dev_groups,\n\t\t\t\t\t\t\t  \"vtcon%i\", con->node);\n\n\t\t\tif (IS_ERR(con->dev)) {\n\t\t\t\tpr_warn(\"Unable to create device for %s; errno = %ld\\n\",\n\t\t\t\t\tcon->desc, PTR_ERR(con->dev));\n\t\t\t\tcon->dev = NULL;\n\t\t\t} else {\n\t\t\t\tvtconsole_init_device(con);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\npostcore_initcall(vtconsole_class_init);\n\n \n\nstatic int set_vesa_blanking(char __user *p)\n{\n\tunsigned int mode;\n\n\tif (get_user(mode, p + 1))\n\t\treturn -EFAULT;\n\n\tvesa_blank_mode = (mode < 4) ? mode : 0;\n\treturn 0;\n}\n\nvoid do_blank_screen(int entering_gfx)\n{\n\tstruct vc_data *vc = vc_cons[fg_console].d;\n\tint i;\n\n\tmight_sleep();\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (console_blanked) {\n\t\tif (blank_state == blank_vesa_wait) {\n\t\t\tblank_state = blank_off;\n\t\t\tvc->vc_sw->con_blank(vc, vesa_blank_mode + 1, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (entering_gfx) {\n\t\thide_cursor(vc);\n\t\tsave_screen(vc);\n\t\tvc->vc_sw->con_blank(vc, -1, 1);\n\t\tconsole_blanked = fg_console + 1;\n\t\tblank_state = blank_off;\n\t\tset_origin(vc);\n\t\treturn;\n\t}\n\n\tblank_state = blank_off;\n\n\t \n\tif (vc->vc_mode != KD_TEXT) {\n\t\tconsole_blanked = fg_console + 1;\n\t\treturn;\n\t}\n\n\thide_cursor(vc);\n\tdel_timer_sync(&console_timer);\n\tblank_timer_expired = 0;\n\n\tsave_screen(vc);\n\t \n\ti = vc->vc_sw->con_blank(vc, vesa_off_interval ? 1 : (vesa_blank_mode + 1), 0);\n\tconsole_blanked = fg_console + 1;\n\tif (i)\n\t\tset_origin(vc);\n\n\tif (console_blank_hook && console_blank_hook(1))\n\t\treturn;\n\n\tif (vesa_off_interval && vesa_blank_mode) {\n\t\tblank_state = blank_vesa_wait;\n\t\tmod_timer(&console_timer, jiffies + vesa_off_interval);\n\t}\n\tvt_event_post(VT_EVENT_BLANK, vc->vc_num, vc->vc_num);\n}\nEXPORT_SYMBOL(do_blank_screen);\n\n \nvoid do_unblank_screen(int leaving_gfx)\n{\n\tstruct vc_data *vc;\n\n\t \n\tif (!oops_in_progress)\n\t\tmight_sleep();\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tignore_poke = 0;\n\tif (!console_blanked)\n\t\treturn;\n\tif (!vc_cons_allocated(fg_console)) {\n\t\t \n\t\tpr_warn(\"unblank_screen: tty %d not allocated ??\\n\",\n\t\t\tfg_console + 1);\n\t\treturn;\n\t}\n\tvc = vc_cons[fg_console].d;\n\tif (vc->vc_mode != KD_TEXT)\n\t\treturn;  \n\n\tif (blankinterval) {\n\t\tmod_timer(&console_timer, jiffies + (blankinterval * HZ));\n\t\tblank_state = blank_normal_wait;\n\t}\n\n\tconsole_blanked = 0;\n\tif (vc->vc_sw->con_blank(vc, 0, leaving_gfx))\n\t\t \n\t\tupdate_screen(vc);\n\tif (console_blank_hook)\n\t\tconsole_blank_hook(0);\n\tset_palette(vc);\n\tset_cursor(vc);\n\tvt_event_post(VT_EVENT_UNBLANK, vc->vc_num, vc->vc_num);\n}\nEXPORT_SYMBOL(do_unblank_screen);\n\n \nstatic void unblank_screen(void)\n{\n\tdo_unblank_screen(0);\n}\n\n \nstatic void blank_screen_t(struct timer_list *unused)\n{\n\tblank_timer_expired = 1;\n\tschedule_work(&console_work);\n}\n\nvoid poke_blanked_console(void)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\t \n\tmight_sleep();\n\n\t \n\tdel_timer(&console_timer);\n\tblank_timer_expired = 0;\n\n\tif (ignore_poke || !vc_cons[fg_console].d || vc_cons[fg_console].d->vc_mode == KD_GRAPHICS)\n\t\treturn;\n\tif (console_blanked)\n\t\tunblank_screen();\n\telse if (blankinterval) {\n\t\tmod_timer(&console_timer, jiffies + (blankinterval * HZ));\n\t\tblank_state = blank_normal_wait;\n\t}\n}\n\n \n\nstatic void set_palette(struct vc_data *vc)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (vc->vc_mode != KD_GRAPHICS && vc->vc_sw->con_set_palette)\n\t\tvc->vc_sw->con_set_palette(vc, color_table);\n}\n\n \n\nint con_set_cmap(unsigned char __user *arg)\n{\n\tint i, j, k;\n\tunsigned char colormap[3*16];\n\n\tif (copy_from_user(colormap, arg, sizeof(colormap)))\n\t\treturn -EFAULT;\n\n\tconsole_lock();\n\tfor (i = k = 0; i < 16; i++) {\n\t\tdefault_red[i] = colormap[k++];\n\t\tdefault_grn[i] = colormap[k++];\n\t\tdefault_blu[i] = colormap[k++];\n\t}\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tif (!vc_cons_allocated(i))\n\t\t\tcontinue;\n\t\tfor (j = k = 0; j < 16; j++) {\n\t\t\tvc_cons[i].d->vc_palette[k++] = default_red[j];\n\t\t\tvc_cons[i].d->vc_palette[k++] = default_grn[j];\n\t\t\tvc_cons[i].d->vc_palette[k++] = default_blu[j];\n\t\t}\n\t\tset_palette(vc_cons[i].d);\n\t}\n\tconsole_unlock();\n\n\treturn 0;\n}\n\nint con_get_cmap(unsigned char __user *arg)\n{\n\tint i, k;\n\tunsigned char colormap[3*16];\n\n\tconsole_lock();\n\tfor (i = k = 0; i < 16; i++) {\n\t\tcolormap[k++] = default_red[i];\n\t\tcolormap[k++] = default_grn[i];\n\t\tcolormap[k++] = default_blu[i];\n\t}\n\tconsole_unlock();\n\n\tif (copy_to_user(arg, colormap, sizeof(colormap)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nvoid reset_palette(struct vc_data *vc)\n{\n\tint j, k;\n\tfor (j=k=0; j<16; j++) {\n\t\tvc->vc_palette[k++] = default_red[j];\n\t\tvc->vc_palette[k++] = default_grn[j];\n\t\tvc->vc_palette[k++] = default_blu[j];\n\t}\n\tset_palette(vc);\n}\n\n \n\n#define max_font_width\t64\n#define max_font_height\t128\n#define max_font_glyphs\t512\n#define max_font_size\t(max_font_glyphs*max_font_width*max_font_height)\n\nstatic int con_font_get(struct vc_data *vc, struct console_font_op *op)\n{\n\tstruct console_font font;\n\tint rc = -EINVAL;\n\tint c;\n\tunsigned int vpitch = op->op == KD_FONT_OP_GET_TALL ? op->height : 32;\n\n\tif (vpitch > max_font_height)\n\t\treturn -EINVAL;\n\n\tif (op->data) {\n\t\tfont.data = kvmalloc(max_font_size, GFP_KERNEL);\n\t\tif (!font.data)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tfont.data = NULL;\n\n\tconsole_lock();\n\tif (vc->vc_mode != KD_TEXT)\n\t\trc = -EINVAL;\n\telse if (vc->vc_sw->con_font_get)\n\t\trc = vc->vc_sw->con_font_get(vc, &font, vpitch);\n\telse\n\t\trc = -ENOSYS;\n\tconsole_unlock();\n\n\tif (rc)\n\t\tgoto out;\n\n\tc = (font.width+7)/8 * vpitch * font.charcount;\n\n\tif (op->data && font.charcount > op->charcount)\n\t\trc = -ENOSPC;\n\tif (font.width > op->width || font.height > op->height)\n\t\trc = -ENOSPC;\n\tif (rc)\n\t\tgoto out;\n\n\top->height = font.height;\n\top->width = font.width;\n\top->charcount = font.charcount;\n\n\tif (op->data && copy_to_user(op->data, font.data, c))\n\t\trc = -EFAULT;\n\nout:\n\tkvfree(font.data);\n\treturn rc;\n}\n\nstatic int con_font_set(struct vc_data *vc, struct console_font_op *op)\n{\n\tstruct console_font font;\n\tint rc = -EINVAL;\n\tint size;\n\tunsigned int vpitch = op->op == KD_FONT_OP_SET_TALL ? op->height : 32;\n\n\tif (vc->vc_mode != KD_TEXT)\n\t\treturn -EINVAL;\n\tif (!op->data)\n\t\treturn -EINVAL;\n\tif (op->charcount > max_font_glyphs)\n\t\treturn -EINVAL;\n\tif (op->width <= 0 || op->width > max_font_width || !op->height ||\n\t    op->height > max_font_height)\n\t\treturn -EINVAL;\n\tif (vpitch < op->height)\n\t\treturn -EINVAL;\n\tsize = (op->width+7)/8 * vpitch * op->charcount;\n\tif (size > max_font_size)\n\t\treturn -ENOSPC;\n\n\tfont.data = memdup_user(op->data, size);\n\tif (IS_ERR(font.data))\n\t\treturn PTR_ERR(font.data);\n\n\tfont.charcount = op->charcount;\n\tfont.width = op->width;\n\tfont.height = op->height;\n\n\tconsole_lock();\n\tif (vc->vc_mode != KD_TEXT)\n\t\trc = -EINVAL;\n\telse if (vc->vc_sw->con_font_set) {\n\t\tif (vc_is_sel(vc))\n\t\t\tclear_selection();\n\t\trc = vc->vc_sw->con_font_set(vc, &font, vpitch, op->flags);\n\t} else\n\t\trc = -ENOSYS;\n\tconsole_unlock();\n\tkfree(font.data);\n\treturn rc;\n}\n\nstatic int con_font_default(struct vc_data *vc, struct console_font_op *op)\n{\n\tstruct console_font font = {.width = op->width, .height = op->height};\n\tchar name[MAX_FONT_NAME];\n\tchar *s = name;\n\tint rc;\n\n\n\tif (!op->data)\n\t\ts = NULL;\n\telse if (strncpy_from_user(name, op->data, MAX_FONT_NAME - 1) < 0)\n\t\treturn -EFAULT;\n\telse\n\t\tname[MAX_FONT_NAME - 1] = 0;\n\n\tconsole_lock();\n\tif (vc->vc_mode != KD_TEXT) {\n\t\tconsole_unlock();\n\t\treturn -EINVAL;\n\t}\n\tif (vc->vc_sw->con_font_default) {\n\t\tif (vc_is_sel(vc))\n\t\t\tclear_selection();\n\t\trc = vc->vc_sw->con_font_default(vc, &font, s);\n\t} else\n\t\trc = -ENOSYS;\n\tconsole_unlock();\n\tif (!rc) {\n\t\top->width = font.width;\n\t\top->height = font.height;\n\t}\n\treturn rc;\n}\n\nint con_font_op(struct vc_data *vc, struct console_font_op *op)\n{\n\tswitch (op->op) {\n\tcase KD_FONT_OP_SET:\n\tcase KD_FONT_OP_SET_TALL:\n\t\treturn con_font_set(vc, op);\n\tcase KD_FONT_OP_GET:\n\tcase KD_FONT_OP_GET_TALL:\n\t\treturn con_font_get(vc, op);\n\tcase KD_FONT_OP_SET_DEFAULT:\n\t\treturn con_font_default(vc, op);\n\tcase KD_FONT_OP_COPY:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\treturn -ENOSYS;\n}\n\n \n\n \nu16 screen_glyph(const struct vc_data *vc, int offset)\n{\n\tu16 w = scr_readw(screenpos(vc, offset, true));\n\tu16 c = w & 0xff;\n\n\tif (w & vc->vc_hi_font_mask)\n\t\tc |= 0x100;\n\treturn c;\n}\nEXPORT_SYMBOL_GPL(screen_glyph);\n\nu32 screen_glyph_unicode(const struct vc_data *vc, int n)\n{\n\tu32 **uni_lines = vc->vc_uni_lines;\n\n\tif (uni_lines)\n\t\treturn uni_lines[n / vc->vc_cols][n % vc->vc_cols];\n\n\treturn inverse_translate(vc, screen_glyph(vc, n * 2), true);\n}\nEXPORT_SYMBOL_GPL(screen_glyph_unicode);\n\n \nunsigned short *screen_pos(const struct vc_data *vc, int w_offset, bool viewed)\n{\n\treturn screenpos(vc, 2 * w_offset, viewed);\n}\nEXPORT_SYMBOL_GPL(screen_pos);\n\nvoid getconsxy(const struct vc_data *vc, unsigned char xy[static 2])\n{\n\t \n\txy[0] = min(vc->state.x, 0xFFu);\n\txy[1] = min(vc->state.y, 0xFFu);\n}\n\nvoid putconsxy(struct vc_data *vc, unsigned char xy[static const 2])\n{\n\thide_cursor(vc);\n\tgotoxy(vc, xy[0], xy[1]);\n\tset_cursor(vc);\n}\n\nu16 vcs_scr_readw(const struct vc_data *vc, const u16 *org)\n{\n\tif ((unsigned long)org == vc->vc_pos && softcursor_original != -1)\n\t\treturn softcursor_original;\n\treturn scr_readw(org);\n}\n\nvoid vcs_scr_writew(struct vc_data *vc, u16 val, u16 *org)\n{\n\tscr_writew(val, org);\n\tif ((unsigned long)org == vc->vc_pos) {\n\t\tsoftcursor_original = -1;\n\t\tadd_softcursor(vc);\n\t}\n}\n\nvoid vcs_scr_updated(struct vc_data *vc)\n{\n\tnotify_update(vc);\n}\n\nvoid vc_scrolldelta_helper(struct vc_data *c, int lines,\n\t\tunsigned int rolled_over, void *base, unsigned int size)\n{\n\tunsigned long ubase = (unsigned long)base;\n\tptrdiff_t scr_end = (void *)c->vc_scr_end - base;\n\tptrdiff_t vorigin = (void *)c->vc_visible_origin - base;\n\tptrdiff_t origin = (void *)c->vc_origin - base;\n\tint margin = c->vc_size_row * 4;\n\tint from, wrap, from_off, avail;\n\n\t \n\tif (!lines) {\n\t\tc->vc_visible_origin = c->vc_origin;\n\t\treturn;\n\t}\n\n\t \n\tif (rolled_over > scr_end + margin) {\n\t\tfrom = scr_end;\n\t\twrap = rolled_over + c->vc_size_row;\n\t} else {\n\t\tfrom = 0;\n\t\twrap = size;\n\t}\n\n\tfrom_off = (vorigin - from + wrap) % wrap + lines * c->vc_size_row;\n\tavail = (origin - from + wrap) % wrap;\n\n\t \n\tif (avail < 2 * margin)\n\t\tmargin = 0;\n\tif (from_off < margin)\n\t\tfrom_off = 0;\n\tif (from_off > avail - margin)\n\t\tfrom_off = avail;\n\n\tc->vc_visible_origin = ubase + (from + from_off) % wrap;\n}\nEXPORT_SYMBOL_GPL(vc_scrolldelta_helper);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}