{
  "module_name": "selection.c",
  "hash_id": "4caad383471e682cd009fd66f124f477b093ab9ad023b00cf6ed3a8eeaee56c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/vt/selection.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/tty.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <linux/uaccess.h>\n\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/consolemap.h>\n#include <linux/selection.h>\n#include <linux/tiocl.h>\n#include <linux/console.h>\n#include <linux/tty_flip.h>\n\n#include <linux/sched/signal.h>\n\n \n#define is_space_on_vt(c)\t((c) == ' ')\n\n \nstatic struct vc_selection {\n\tstruct mutex lock;\n\tstruct vc_data *cons;\t\t\t \n\tchar *buffer;\n\tunsigned int buf_len;\n\tvolatile int start;\t\t\t \n\tint end;\n} vc_sel = {\n\t.lock = __MUTEX_INITIALIZER(vc_sel.lock),\n\t.start = -1,\n};\n\n \n\n \nstatic inline void highlight(const int s, const int e)\n{\n\tinvert_screen(vc_sel.cons, s, e-s+2, true);\n}\n\n \nstatic inline void highlight_pointer(const int where)\n{\n\tcomplement_pos(vc_sel.cons, where);\n}\n\nstatic u32\nsel_pos(int n, bool unicode)\n{\n\tif (unicode)\n\t\treturn screen_glyph_unicode(vc_sel.cons, n / 2);\n\treturn inverse_translate(vc_sel.cons, screen_glyph(vc_sel.cons, n),\n\t\t\tfalse);\n}\n\n \nvoid clear_selection(void)\n{\n\thighlight_pointer(-1);  \n\tif (vc_sel.start != -1) {\n\t\thighlight(vc_sel.start, vc_sel.end);\n\t\tvc_sel.start = -1;\n\t}\n}\nEXPORT_SYMBOL_GPL(clear_selection);\n\nbool vc_is_sel(struct vc_data *vc)\n{\n\treturn vc == vc_sel.cons;\n}\n\n \nstatic u32 inwordLut[]={\n  0x00000000,  \n  0x03FFE000,  \n  0x87FFFFFE,  \n  0x07FFFFFE,  \n};\n\nstatic inline int inword(const u32 c)\n{\n\treturn c > 0x7f || (( inwordLut[c>>5] >> (c & 0x1F) ) & 1);\n}\n\n \nint sel_loadlut(char __user *p)\n{\n\tu32 tmplut[ARRAY_SIZE(inwordLut)];\n\tif (copy_from_user(tmplut, (u32 __user *)(p+4), sizeof(inwordLut)))\n\t\treturn -EFAULT;\n\tmemcpy(inwordLut, tmplut, sizeof(inwordLut));\n\treturn 0;\n}\n\n \nstatic inline int atedge(const int p, int size_row)\n{\n\treturn (!(p % size_row)\t|| !((p + 2) % size_row));\n}\n\n \nstatic int store_utf8(u32 c, char *p)\n{\n\tif (c < 0x80) {\n\t\t \n\t\tp[0] = c;\n\t\treturn 1;\n\t} else if (c < 0x800) {\n\t\t \n\t\tp[0] = 0xc0 | (c >> 6);\n\t\tp[1] = 0x80 | (c & 0x3f);\n\t\treturn 2;\n\t} else if (c < 0x10000) {\n\t\t \n\t\tp[0] = 0xe0 | (c >> 12);\n\t\tp[1] = 0x80 | ((c >> 6) & 0x3f);\n\t\tp[2] = 0x80 | (c & 0x3f);\n\t\treturn 3;\n\t} else if (c < 0x110000) {\n\t\t \n\t\tp[0] = 0xf0 | (c >> 18);\n\t\tp[1] = 0x80 | ((c >> 12) & 0x3f);\n\t\tp[2] = 0x80 | ((c >> 6) & 0x3f);\n\t\tp[3] = 0x80 | (c & 0x3f);\n\t\treturn 4;\n\t} else {\n\t\t \n\t\tp[0] = 0xef;\n\t\tp[1] = 0xbf;\n\t\tp[2] = 0xbd;\n\t\treturn 3;\n\t}\n}\n\n \nint set_selection_user(const struct tiocl_selection __user *sel,\n\t\t       struct tty_struct *tty)\n{\n\tstruct tiocl_selection v;\n\n\tif (copy_from_user(&v, sel, sizeof(*sel)))\n\t\treturn -EFAULT;\n\n\treturn set_selection_kernel(&v, tty);\n}\n\nstatic int vc_selection_store_chars(struct vc_data *vc, bool unicode)\n{\n\tchar *bp, *obp;\n\tunsigned int i;\n\n\t \n\t \n\tbp = kmalloc_array((vc_sel.end - vc_sel.start) / 2 + 1, unicode ? 4 : 1,\n\t\t\t   GFP_KERNEL | __GFP_NOWARN);\n\tif (!bp) {\n\t\tprintk(KERN_WARNING \"selection: kmalloc() failed\\n\");\n\t\tclear_selection();\n\t\treturn -ENOMEM;\n\t}\n\tkfree(vc_sel.buffer);\n\tvc_sel.buffer = bp;\n\n\tobp = bp;\n\tfor (i = vc_sel.start; i <= vc_sel.end; i += 2) {\n\t\tu32 c = sel_pos(i, unicode);\n\t\tif (unicode)\n\t\t\tbp += store_utf8(c, bp);\n\t\telse\n\t\t\t*bp++ = c;\n\t\tif (!is_space_on_vt(c))\n\t\t\tobp = bp;\n\t\tif (!((i + 2) % vc->vc_size_row)) {\n\t\t\t \n\t\t\tif (obp != bp) {\n\t\t\t\tbp = obp;\n\t\t\t\t*bp++ = '\\r';\n\t\t\t}\n\t\t\tobp = bp;\n\t\t}\n\t}\n\tvc_sel.buf_len = bp - vc_sel.buffer;\n\n\treturn 0;\n}\n\nstatic int vc_do_selection(struct vc_data *vc, unsigned short mode, int ps,\n\t\tint pe)\n{\n\tint new_sel_start, new_sel_end, spc;\n\tbool unicode = vt_do_kdgkbmode(fg_console) == K_UNICODE;\n\n\tswitch (mode) {\n\tcase TIOCL_SELCHAR:\t \n\t\tnew_sel_start = ps;\n\t\tnew_sel_end = pe;\n\t\tbreak;\n\tcase TIOCL_SELWORD:\t \n\t\tspc = is_space_on_vt(sel_pos(ps, unicode));\n\t\tfor (new_sel_start = ps; ; ps -= 2) {\n\t\t\tif ((spc && !is_space_on_vt(sel_pos(ps, unicode))) ||\n\t\t\t    (!spc && !inword(sel_pos(ps, unicode))))\n\t\t\t\tbreak;\n\t\t\tnew_sel_start = ps;\n\t\t\tif (!(ps % vc->vc_size_row))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tspc = is_space_on_vt(sel_pos(pe, unicode));\n\t\tfor (new_sel_end = pe; ; pe += 2) {\n\t\t\tif ((spc && !is_space_on_vt(sel_pos(pe, unicode))) ||\n\t\t\t    (!spc && !inword(sel_pos(pe, unicode))))\n\t\t\t\tbreak;\n\t\t\tnew_sel_end = pe;\n\t\t\tif (!((pe + 2) % vc->vc_size_row))\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TIOCL_SELLINE:\t \n\t\tnew_sel_start = rounddown(ps, vc->vc_size_row);\n\t\tnew_sel_end = rounddown(pe, vc->vc_size_row) +\n\t\t\tvc->vc_size_row - 2;\n\t\tbreak;\n\tcase TIOCL_SELPOINTER:\n\t\thighlight_pointer(pe);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thighlight_pointer(-1);\n\n\t \n\tif (new_sel_end > new_sel_start &&\n\t\t!atedge(new_sel_end, vc->vc_size_row) &&\n\t\tis_space_on_vt(sel_pos(new_sel_end, unicode))) {\n\t\tfor (pe = new_sel_end + 2; ; pe += 2)\n\t\t\tif (!is_space_on_vt(sel_pos(pe, unicode)) ||\n\t\t\t    atedge(pe, vc->vc_size_row))\n\t\t\t\tbreak;\n\t\tif (is_space_on_vt(sel_pos(pe, unicode)))\n\t\t\tnew_sel_end = pe;\n\t}\n\tif (vc_sel.start == -1)\t \n\t\thighlight(new_sel_start, new_sel_end);\n\telse if (new_sel_start == vc_sel.start)\n\t{\n\t\tif (new_sel_end == vc_sel.end)\t \n\t\t\treturn 0;\n\t\telse if (new_sel_end > vc_sel.end)\t \n\t\t\thighlight(vc_sel.end + 2, new_sel_end);\n\t\telse\t\t\t\t \n\t\t\thighlight(new_sel_end + 2, vc_sel.end);\n\t}\n\telse if (new_sel_end == vc_sel.end)\n\t{\n\t\tif (new_sel_start < vc_sel.start)  \n\t\t\thighlight(new_sel_start, vc_sel.start - 2);\n\t\telse\t\t\t\t \n\t\t\thighlight(vc_sel.start, new_sel_start - 2);\n\t}\n\telse\t \n\t{\n\t\tclear_selection();\n\t\thighlight(new_sel_start, new_sel_end);\n\t}\n\tvc_sel.start = new_sel_start;\n\tvc_sel.end = new_sel_end;\n\n\treturn vc_selection_store_chars(vc, unicode);\n}\n\nstatic int vc_selection(struct vc_data *vc, struct tiocl_selection *v,\n\t\tstruct tty_struct *tty)\n{\n\tint ps, pe;\n\n\tpoke_blanked_console();\n\n\tif (v->sel_mode == TIOCL_SELCLEAR) {\n\t\t \n\t\tclear_selection();\n\t\treturn 0;\n\t}\n\n\tv->xs = min_t(u16, v->xs - 1, vc->vc_cols - 1);\n\tv->ys = min_t(u16, v->ys - 1, vc->vc_rows - 1);\n\tv->xe = min_t(u16, v->xe - 1, vc->vc_cols - 1);\n\tv->ye = min_t(u16, v->ye - 1, vc->vc_rows - 1);\n\n\tif (mouse_reporting() && (v->sel_mode & TIOCL_SELMOUSEREPORT)) {\n\t\tmouse_report(tty, v->sel_mode & TIOCL_SELBUTTONMASK, v->xs,\n\t\t\t     v->ys);\n\t\treturn 0;\n\t}\n\n\tps = v->ys * vc->vc_size_row + (v->xs << 1);\n\tpe = v->ye * vc->vc_size_row + (v->xe << 1);\n\tif (ps > pe)\t \n\t\tswap(ps, pe);\n\n\tif (vc_sel.cons != vc) {\n\t\tclear_selection();\n\t\tvc_sel.cons = vc;\n\t}\n\n\treturn vc_do_selection(vc, v->sel_mode, ps, pe);\n}\n\nint set_selection_kernel(struct tiocl_selection *v, struct tty_struct *tty)\n{\n\tint ret;\n\n\tmutex_lock(&vc_sel.lock);\n\tconsole_lock();\n\tret = vc_selection(vc_cons[fg_console].d, v, tty);\n\tconsole_unlock();\n\tmutex_unlock(&vc_sel.lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(set_selection_kernel);\n\n \nint paste_selection(struct tty_struct *tty)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tint\tpasted = 0;\n\tsize_t count;\n\tstruct  tty_ldisc *ld;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint ret = 0;\n\n\tconsole_lock();\n\tpoke_blanked_console();\n\tconsole_unlock();\n\n\tld = tty_ldisc_ref_wait(tty);\n\tif (!ld)\n\t\treturn -EIO;\t \n\ttty_buffer_lock_exclusive(&vc->port);\n\n\tadd_wait_queue(&vc->paste_wait, &wait);\n\tmutex_lock(&vc_sel.lock);\n\twhile (vc_sel.buffer && vc_sel.buf_len > pasted) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_throttled(tty)) {\n\t\t\tmutex_unlock(&vc_sel.lock);\n\t\t\tschedule();\n\t\t\tmutex_lock(&vc_sel.lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t\tcount = vc_sel.buf_len - pasted;\n\t\tcount = tty_ldisc_receive_buf(ld, vc_sel.buffer + pasted, NULL,\n\t\t\t\t\t      count);\n\t\tpasted += count;\n\t}\n\tmutex_unlock(&vc_sel.lock);\n\tremove_wait_queue(&vc->paste_wait, &wait);\n\t__set_current_state(TASK_RUNNING);\n\n\ttty_buffer_unlock_exclusive(&vc->port);\n\ttty_ldisc_deref(ld);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(paste_selection);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}