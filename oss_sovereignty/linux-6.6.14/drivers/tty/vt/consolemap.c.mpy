{
  "module_name": "consolemap.c",
  "hash_id": "fc0a20c6894879a7c5327179137898053fccd21e02c08bc7fcc986d2eecb09fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/vt/consolemap.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/module.h>\n#include <linux/kd.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/tty.h>\n#include <linux/uaccess.h>\n#include <linux/console.h>\n#include <linux/consolemap.h>\n#include <linux/vt_kern.h>\n#include <linux/string.h>\n\nstatic unsigned short translations[][E_TABSZ] = {\n   \n  [LAT1_MAP] = {\n    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,\n    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,\n    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,\n    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,\n    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,\n    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,\n    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,\n    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,\n    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,\n    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,\n    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,\n    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,\n    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,\n    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,\n    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,\n    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,\n    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,\n    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,\n    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,\n    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,\n    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,\n    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,\n    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,\n    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,\n    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,\n    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,\n    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,\n    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff\n  },\n   \n  [GRAF_MAP] = {\n    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,\n    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,\n    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,\n    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,\n    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,\n    0x0028, 0x0029, 0x002a, 0x2192, 0x2190, 0x2191, 0x2193, 0x002f,\n    0x2588, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,\n    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,\n    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,\n    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,\n    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,\n    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x00a0,\n    0x25c6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0, 0x00b1,\n    0x2591, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c, 0x23ba,\n    0x23bb, 0x2500, 0x23bc, 0x23bd, 0x251c, 0x2524, 0x2534, 0x252c,\n    0x2502, 0x2264, 0x2265, 0x03c0, 0x2260, 0x00a3, 0x00b7, 0x007f,\n    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,\n    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,\n    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,\n    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,\n    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,\n    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,\n    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,\n    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,\n    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,\n    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,\n    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,\n    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff\n  },\n   \n  [IBMPC_MAP] = {\n    0x0000, 0x263a, 0x263b, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022,\n    0x25d8, 0x25cb, 0x25d9, 0x2642, 0x2640, 0x266a, 0x266b, 0x263c,\n    0x25b6, 0x25c0, 0x2195, 0x203c, 0x00b6, 0x00a7, 0x25ac, 0x21a8,\n    0x2191, 0x2193, 0x2192, 0x2190, 0x221f, 0x2194, 0x25b2, 0x25bc,\n    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,\n    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,\n    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,\n    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,\n    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,\n    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,\n    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,\n    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,\n    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,\n    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,\n    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,\n    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x2302,\n    0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7,\n    0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,\n    0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n    0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,\n    0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba,\n    0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,\n    0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,\n    0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n    0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,\n    0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b,\n    0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n    0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4,\n    0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,\n    0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n    0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0\n  },\n   \n  [USER_MAP] = {\n    0xf000, 0xf001, 0xf002, 0xf003, 0xf004, 0xf005, 0xf006, 0xf007,\n    0xf008, 0xf009, 0xf00a, 0xf00b, 0xf00c, 0xf00d, 0xf00e, 0xf00f,\n    0xf010, 0xf011, 0xf012, 0xf013, 0xf014, 0xf015, 0xf016, 0xf017,\n    0xf018, 0xf019, 0xf01a, 0xf01b, 0xf01c, 0xf01d, 0xf01e, 0xf01f,\n    0xf020, 0xf021, 0xf022, 0xf023, 0xf024, 0xf025, 0xf026, 0xf027,\n    0xf028, 0xf029, 0xf02a, 0xf02b, 0xf02c, 0xf02d, 0xf02e, 0xf02f,\n    0xf030, 0xf031, 0xf032, 0xf033, 0xf034, 0xf035, 0xf036, 0xf037,\n    0xf038, 0xf039, 0xf03a, 0xf03b, 0xf03c, 0xf03d, 0xf03e, 0xf03f,\n    0xf040, 0xf041, 0xf042, 0xf043, 0xf044, 0xf045, 0xf046, 0xf047,\n    0xf048, 0xf049, 0xf04a, 0xf04b, 0xf04c, 0xf04d, 0xf04e, 0xf04f,\n    0xf050, 0xf051, 0xf052, 0xf053, 0xf054, 0xf055, 0xf056, 0xf057,\n    0xf058, 0xf059, 0xf05a, 0xf05b, 0xf05c, 0xf05d, 0xf05e, 0xf05f,\n    0xf060, 0xf061, 0xf062, 0xf063, 0xf064, 0xf065, 0xf066, 0xf067,\n    0xf068, 0xf069, 0xf06a, 0xf06b, 0xf06c, 0xf06d, 0xf06e, 0xf06f,\n    0xf070, 0xf071, 0xf072, 0xf073, 0xf074, 0xf075, 0xf076, 0xf077,\n    0xf078, 0xf079, 0xf07a, 0xf07b, 0xf07c, 0xf07d, 0xf07e, 0xf07f,\n    0xf080, 0xf081, 0xf082, 0xf083, 0xf084, 0xf085, 0xf086, 0xf087,\n    0xf088, 0xf089, 0xf08a, 0xf08b, 0xf08c, 0xf08d, 0xf08e, 0xf08f,\n    0xf090, 0xf091, 0xf092, 0xf093, 0xf094, 0xf095, 0xf096, 0xf097,\n    0xf098, 0xf099, 0xf09a, 0xf09b, 0xf09c, 0xf09d, 0xf09e, 0xf09f,\n    0xf0a0, 0xf0a1, 0xf0a2, 0xf0a3, 0xf0a4, 0xf0a5, 0xf0a6, 0xf0a7,\n    0xf0a8, 0xf0a9, 0xf0aa, 0xf0ab, 0xf0ac, 0xf0ad, 0xf0ae, 0xf0af,\n    0xf0b0, 0xf0b1, 0xf0b2, 0xf0b3, 0xf0b4, 0xf0b5, 0xf0b6, 0xf0b7,\n    0xf0b8, 0xf0b9, 0xf0ba, 0xf0bb, 0xf0bc, 0xf0bd, 0xf0be, 0xf0bf,\n    0xf0c0, 0xf0c1, 0xf0c2, 0xf0c3, 0xf0c4, 0xf0c5, 0xf0c6, 0xf0c7,\n    0xf0c8, 0xf0c9, 0xf0ca, 0xf0cb, 0xf0cc, 0xf0cd, 0xf0ce, 0xf0cf,\n    0xf0d0, 0xf0d1, 0xf0d2, 0xf0d3, 0xf0d4, 0xf0d5, 0xf0d6, 0xf0d7,\n    0xf0d8, 0xf0d9, 0xf0da, 0xf0db, 0xf0dc, 0xf0dd, 0xf0de, 0xf0df,\n    0xf0e0, 0xf0e1, 0xf0e2, 0xf0e3, 0xf0e4, 0xf0e5, 0xf0e6, 0xf0e7,\n    0xf0e8, 0xf0e9, 0xf0ea, 0xf0eb, 0xf0ec, 0xf0ed, 0xf0ee, 0xf0ef,\n    0xf0f0, 0xf0f1, 0xf0f2, 0xf0f3, 0xf0f4, 0xf0f5, 0xf0f6, 0xf0f7,\n    0xf0f8, 0xf0f9, 0xf0fa, 0xf0fb, 0xf0fc, 0xf0fd, 0xf0fe, 0xf0ff\n  }\n};\n\n \n\n#define MAX_GLYPH 512\t\t \n\nstatic enum translation_map inv_translate[MAX_NR_CONSOLES];\n\n#define UNI_DIRS\t32U\n#define UNI_DIR_ROWS\t32U\n#define UNI_ROW_GLYPHS\t64U\n\n#define UNI_DIR_BITS\t\tGENMASK(15, 11)\n#define UNI_ROW_BITS\t\tGENMASK(10,  6)\n#define UNI_GLYPH_BITS\t\tGENMASK( 5,  0)\n\n#define UNI_DIR(uni)\t\tFIELD_GET(UNI_DIR_BITS, (uni))\n#define UNI_ROW(uni)\t\tFIELD_GET(UNI_ROW_BITS, (uni))\n#define UNI_GLYPH(uni)\t\tFIELD_GET(UNI_GLYPH_BITS, (uni))\n\n#define UNI(dir, row, glyph)\t(FIELD_PREP(UNI_DIR_BITS, (dir)) | \\\n\t\t\t\t FIELD_PREP(UNI_ROW_BITS, (row)) | \\\n\t\t\t\t FIELD_PREP(UNI_GLYPH_BITS, (glyph)))\n\n \nstruct uni_pagedict {\n\tu16\t\t**uni_pgdir[UNI_DIRS];\n\tunsigned long\trefcount;\n\tunsigned long\tsum;\n\tunsigned char\t*inverse_translations[LAST_MAP + 1];\n\tu16\t\t*inverse_trans_unicode;\n};\n\nstatic struct uni_pagedict *dflt;\n\nstatic void set_inverse_transl(struct vc_data *conp, struct uni_pagedict *dict,\n\t       enum translation_map m)\n{\n\tunsigned short *t = translations[m];\n\tunsigned char *inv;\n\n\tif (!dict)\n\t\treturn;\n\tinv = dict->inverse_translations[m];\n\n\tif (!inv) {\n\t\tinv = dict->inverse_translations[m] = kmalloc(MAX_GLYPH,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!inv)\n\t\t\treturn;\n\t}\n\tmemset(inv, 0, MAX_GLYPH);\n\n\tfor (unsigned int ch = 0; ch < ARRAY_SIZE(translations[m]); ch++) {\n\t\tint glyph = conv_uni_to_pc(conp, t[ch]);\n\t\tif (glyph >= 0 && glyph < MAX_GLYPH && inv[glyph] < 32) {\n\t\t\t \n\t\t\tinv[glyph] = ch;\n\t\t}\n\t}\n}\n\nstatic void set_inverse_trans_unicode(struct uni_pagedict *dict)\n{\n\tunsigned int d, r, g;\n\tu16 *inv;\n\n\tif (!dict)\n\t\treturn;\n\n\tinv = dict->inverse_trans_unicode;\n\tif (!inv) {\n\t\tinv = dict->inverse_trans_unicode = kmalloc_array(MAX_GLYPH,\n\t\t\t\tsizeof(*inv), GFP_KERNEL);\n\t\tif (!inv)\n\t\t\treturn;\n\t}\n\tmemset(inv, 0, MAX_GLYPH * sizeof(*inv));\n\n\tfor (d = 0; d < UNI_DIRS; d++) {\n\t\tu16 **dir = dict->uni_pgdir[d];\n\t\tif (!dir)\n\t\t\tcontinue;\n\t\tfor (r = 0; r < UNI_DIR_ROWS; r++) {\n\t\t\tu16 *row = dir[r];\n\t\t\tif (!row)\n\t\t\t\tcontinue;\n\t\t\tfor (g = 0; g < UNI_ROW_GLYPHS; g++) {\n\t\t\t\tu16 glyph = row[g];\n\t\t\t\tif (glyph < MAX_GLYPH && inv[glyph] < 32)\n\t\t\t\t\tinv[glyph] = UNI(d, r, g);\n\t\t\t}\n\t\t}\n\t}\n}\n\nunsigned short *set_translate(enum translation_map m, struct vc_data *vc)\n{\n\tinv_translate[vc->vc_num] = m;\n\treturn translations[m];\n}\n\n \nu16 inverse_translate(const struct vc_data *conp, u16 glyph, bool use_unicode)\n{\n\tstruct uni_pagedict *p;\n\tenum translation_map m;\n\n\tif (glyph >= MAX_GLYPH)\n\t\treturn 0;\n\n\tp = *conp->uni_pagedict_loc;\n\tif (!p)\n\t\treturn glyph;\n\n\tif (use_unicode) {\n\t\tif (!p->inverse_trans_unicode)\n\t\t\treturn glyph;\n\n\t\treturn p->inverse_trans_unicode[glyph];\n\t}\n\n\tm = inv_translate[conp->vc_num];\n\tif (!p->inverse_translations[m])\n\t\treturn glyph;\n\n\treturn p->inverse_translations[m][glyph];\n}\nEXPORT_SYMBOL_GPL(inverse_translate);\n\nstatic void update_user_maps(void)\n{\n\tint i;\n\tstruct uni_pagedict *p, *q = NULL;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tif (!vc_cons_allocated(i))\n\t\t\tcontinue;\n\t\tp = *vc_cons[i].d->uni_pagedict_loc;\n\t\tif (p && p != q) {\n\t\t\tset_inverse_transl(vc_cons[i].d, p, USER_MAP);\n\t\t\tset_inverse_trans_unicode(p);\n\t\t\tq = p;\n\t\t}\n\t}\n}\n\n \nint con_set_trans_old(unsigned char __user * arg)\n{\n\tunsigned short inbuf[E_TABSZ];\n\tunsigned int i;\n\tunsigned char ch;\n\n\tfor (i = 0; i < ARRAY_SIZE(inbuf); i++) {\n\t\tif (get_user(ch, &arg[i]))\n\t\t\treturn -EFAULT;\n\t\tinbuf[i] = UNI_DIRECT_BASE | ch;\n\t}\n\n\tconsole_lock();\n\tmemcpy(translations[USER_MAP], inbuf, sizeof(inbuf));\n\tupdate_user_maps();\n\tconsole_unlock();\n\treturn 0;\n}\n\nint con_get_trans_old(unsigned char __user * arg)\n{\n\tint i, ch;\n\tunsigned short *p = translations[USER_MAP];\n\tunsigned char outbuf[E_TABSZ];\n\n\tconsole_lock();\n\tfor (i = 0; i < ARRAY_SIZE(outbuf); i++)\n\t{\n\t\tch = conv_uni_to_pc(vc_cons[fg_console].d, p[i]);\n\t\toutbuf[i] = (ch & ~0xff) ? 0 : ch;\n\t}\n\tconsole_unlock();\n\n\treturn copy_to_user(arg, outbuf, sizeof(outbuf)) ? -EFAULT : 0;\n}\n\nint con_set_trans_new(ushort __user * arg)\n{\n\tunsigned short inbuf[E_TABSZ];\n\n\tif (copy_from_user(inbuf, arg, sizeof(inbuf)))\n\t\treturn -EFAULT;\n\n\tconsole_lock();\n\tmemcpy(translations[USER_MAP], inbuf, sizeof(inbuf));\n\tupdate_user_maps();\n\tconsole_unlock();\n\treturn 0;\n}\n\nint con_get_trans_new(ushort __user * arg)\n{\n\tunsigned short outbuf[E_TABSZ];\n\n\tconsole_lock();\n\tmemcpy(outbuf, translations[USER_MAP], sizeof(outbuf));\n\tconsole_unlock();\n\n\treturn copy_to_user(arg, outbuf, sizeof(outbuf)) ? -EFAULT : 0;\n}\n\n \n\nextern u8 dfont_unicount[];\t \nextern u16 dfont_unitable[];\n\nstatic void con_release_unimap(struct uni_pagedict *dict)\n{\n\tunsigned int d, r;\n\n\tif (dict == dflt)\n\t\tdflt = NULL;\n\n\tfor (d = 0; d < UNI_DIRS; d++) {\n\t\tu16 **dir = dict->uni_pgdir[d];\n\t\tif (dir != NULL) {\n\t\t\tfor (r = 0; r < UNI_DIR_ROWS; r++)\n\t\t\t\tkfree(dir[r]);\n\t\t\tkfree(dir);\n\t\t}\n\t\tdict->uni_pgdir[d] = NULL;\n\t}\n\n\tfor (r = 0; r < ARRAY_SIZE(dict->inverse_translations); r++) {\n\t\tkfree(dict->inverse_translations[r]);\n\t\tdict->inverse_translations[r] = NULL;\n\t}\n\n\tkfree(dict->inverse_trans_unicode);\n\tdict->inverse_trans_unicode = NULL;\n}\n\n \nvoid con_free_unimap(struct vc_data *vc)\n{\n\tstruct uni_pagedict *p;\n\n\tp = *vc->uni_pagedict_loc;\n\tif (!p)\n\t\treturn;\n\t*vc->uni_pagedict_loc = NULL;\n\tif (--p->refcount)\n\t\treturn;\n\tcon_release_unimap(p);\n\tkfree(p);\n}\n\nstatic int con_unify_unimap(struct vc_data *conp, struct uni_pagedict *dict1)\n{\n\tstruct uni_pagedict *dict2;\n\tunsigned int cons, d, r;\n\n\tfor (cons = 0; cons < MAX_NR_CONSOLES; cons++) {\n\t\tif (!vc_cons_allocated(cons))\n\t\t\tcontinue;\n\t\tdict2 = *vc_cons[cons].d->uni_pagedict_loc;\n\t\tif (!dict2 || dict2 == dict1 || dict2->sum != dict1->sum)\n\t\t\tcontinue;\n\t\tfor (d = 0; d < UNI_DIRS; d++) {\n\t\t\tu16 **dir1 = dict1->uni_pgdir[d];\n\t\t\tu16 **dir2 = dict2->uni_pgdir[d];\n\t\t\tif (!dir1 && !dir2)\n\t\t\t\tcontinue;\n\t\t\tif (!dir1 || !dir2)\n\t\t\t\tbreak;\n\t\t\tfor (r = 0; r < UNI_DIR_ROWS; r++) {\n\t\t\t\tif (!dir1[r] && !dir2[r])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!dir1[r] || !dir2[r])\n\t\t\t\t\tbreak;\n\t\t\t\tif (memcmp(dir1[r], dir2[r], UNI_ROW_GLYPHS *\n\t\t\t\t\t\t\tsizeof(*dir1[r])))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (r < UNI_DIR_ROWS)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (d == UNI_DIRS) {\n\t\t\tdict2->refcount++;\n\t\t\t*conp->uni_pagedict_loc = dict2;\n\t\t\tcon_release_unimap(dict1);\n\t\t\tkfree(dict1);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\ncon_insert_unipair(struct uni_pagedict *p, u_short unicode, u_short fontpos)\n{\n\tu16 **dir, *row;\n\tunsigned int n;\n\n\tn = UNI_DIR(unicode);\n\tdir = p->uni_pgdir[n];\n\tif (!dir) {\n\t\tdir = p->uni_pgdir[n] = kcalloc(UNI_DIR_ROWS, sizeof(*dir),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!dir)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tn = UNI_ROW(unicode);\n\trow = dir[n];\n\tif (!row) {\n\t\trow = dir[n] = kmalloc_array(UNI_ROW_GLYPHS, sizeof(*row),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!row)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tmemset(row, 0xff, UNI_ROW_GLYPHS * sizeof(*row));\n\t}\n\n\trow[UNI_GLYPH(unicode)] = fontpos;\n\n\tp->sum += (fontpos << 20U) + unicode;\n\n\treturn 0;\n}\n\nstatic int con_allocate_new(struct vc_data *vc)\n{\n\tstruct uni_pagedict *new, *old = *vc->uni_pagedict_loc;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->refcount = 1;\n\t*vc->uni_pagedict_loc = new;\n\n\tif (old)\n\t\told->refcount--;\n\n\treturn 0;\n}\n\n \nstatic int con_do_clear_unimap(struct vc_data *vc)\n{\n\tstruct uni_pagedict *old = *vc->uni_pagedict_loc;\n\n\tif (!old || old->refcount > 1)\n\t\treturn con_allocate_new(vc);\n\n\told->sum = 0;\n\tcon_release_unimap(old);\n\n\treturn 0;\n}\n\nint con_clear_unimap(struct vc_data *vc)\n{\n\tint ret;\n\tconsole_lock();\n\tret = con_do_clear_unimap(vc);\n\tconsole_unlock();\n\treturn ret;\n}\n\nstatic struct uni_pagedict *con_unshare_unimap(struct vc_data *vc,\n\t\tstruct uni_pagedict *old)\n{\n\tstruct uni_pagedict *new;\n\tunsigned int d, r, g;\n\tint ret;\n\tu16 uni = 0;\n\n\tret = con_allocate_new(vc);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tnew = *vc->uni_pagedict_loc;\n\n\t \n\tfor (d = 0; d < UNI_DIRS; d++) {\n\t\tu16 **dir = old->uni_pgdir[d];\n\t\tif (!dir) {\n\t\t\t \n\t\t\tuni += UNI_DIR_ROWS * UNI_ROW_GLYPHS;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (r = 0; r < UNI_DIR_ROWS; r++) {\n\t\t\tu16 *row = dir[r];\n\t\t\tif (!row) {\n\t\t\t\t \n\t\t\t\tuni += UNI_ROW_GLYPHS;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (g = 0; g < UNI_ROW_GLYPHS; g++, uni++) {\n\t\t\t\tif (row[g] == 0xffff)\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tret = con_insert_unipair(new, uni, row[g]);\n\t\t\t\tif (ret) {\n\t\t\t\t\told->refcount++;\n\t\t\t\t\t*vc->uni_pagedict_loc = old;\n\t\t\t\t\tcon_release_unimap(new);\n\t\t\t\t\tkfree(new);\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new;\n}\n\nint con_set_unimap(struct vc_data *vc, ushort ct, struct unipair __user *list)\n{\n\tint err = 0, err1;\n\tstruct uni_pagedict *dict;\n\tstruct unipair *unilist, *plist;\n\n\tif (!ct)\n\t\treturn 0;\n\n\tunilist = vmemdup_user(list, array_size(sizeof(*unilist), ct));\n\tif (IS_ERR(unilist))\n\t\treturn PTR_ERR(unilist);\n\n\tconsole_lock();\n\n\t \n\tdict = *vc->uni_pagedict_loc;\n\tif (!dict) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (dict->refcount > 1) {\n\t\tdict = con_unshare_unimap(vc, dict);\n\t\tif (IS_ERR(dict)) {\n\t\t\terr = PTR_ERR(dict);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else if (dict == dflt) {\n\t\tdflt = NULL;\n\t}\n\n\t \n\tfor (plist = unilist; ct; ct--, plist++) {\n\t\terr1 = con_insert_unipair(dict, plist->unicode, plist->fontpos);\n\t\tif (err1)\n\t\t\terr = err1;\n\t}\n\n\t \n\tif (con_unify_unimap(vc, dict))\n\t\tgoto out_unlock;\n\n\tfor (enum translation_map m = FIRST_MAP; m <= LAST_MAP; m++)\n\t\tset_inverse_transl(vc, dict, m);\n\tset_inverse_trans_unicode(dict);\n\nout_unlock:\n\tconsole_unlock();\n\tkvfree(unilist);\n\treturn err;\n}\n\n \nint con_set_default_unimap(struct vc_data *vc)\n{\n\tstruct uni_pagedict *dict;\n\tunsigned int fontpos, count;\n\tint err = 0, err1;\n\tu16 *dfont;\n\n\tif (dflt) {\n\t\tdict = *vc->uni_pagedict_loc;\n\t\tif (dict == dflt)\n\t\t\treturn 0;\n\n\t\tdflt->refcount++;\n\t\t*vc->uni_pagedict_loc = dflt;\n\t\tif (dict && !--dict->refcount) {\n\t\t\tcon_release_unimap(dict);\n\t\t\tkfree(dict);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\n\terr = con_do_clear_unimap(vc);\n\tif (err)\n\t\treturn err;\n\n\tdict = *vc->uni_pagedict_loc;\n\tdfont = dfont_unitable;\n\n\tfor (fontpos = 0; fontpos < 256U; fontpos++)\n\t\tfor (count = dfont_unicount[fontpos]; count; count--) {\n\t\t\terr1 = con_insert_unipair(dict, *(dfont++), fontpos);\n\t\t\tif (err1)\n\t\t\t\terr = err1;\n\t\t}\n\n\tif (con_unify_unimap(vc, dict)) {\n\t\tdflt = *vc->uni_pagedict_loc;\n\t\treturn err;\n\t}\n\n\tfor (enum translation_map m = FIRST_MAP; m <= LAST_MAP; m++)\n\t\tset_inverse_transl(vc, dict, m);\n\tset_inverse_trans_unicode(dict);\n\tdflt = dict;\n\treturn err;\n}\nEXPORT_SYMBOL(con_set_default_unimap);\n\n \nint con_copy_unimap(struct vc_data *dst_vc, struct vc_data *src_vc)\n{\n\tstruct uni_pagedict *src;\n\n\tif (!*src_vc->uni_pagedict_loc)\n\t\treturn -EINVAL;\n\tif (*dst_vc->uni_pagedict_loc == *src_vc->uni_pagedict_loc)\n\t\treturn 0;\n\tcon_free_unimap(dst_vc);\n\tsrc = *src_vc->uni_pagedict_loc;\n\tsrc->refcount++;\n\t*dst_vc->uni_pagedict_loc = src;\n\treturn 0;\n}\nEXPORT_SYMBOL(con_copy_unimap);\n\n \nint con_get_unimap(struct vc_data *vc, ushort ct, ushort __user *uct,\n\t\tstruct unipair __user *list)\n{\n\tushort ect;\n\tstruct uni_pagedict *dict;\n\tstruct unipair *unilist;\n\tunsigned int d, r, g;\n\tint ret = 0;\n\n\tunilist = kvmalloc_array(ct, sizeof(*unilist), GFP_KERNEL);\n\tif (!unilist)\n\t\treturn -ENOMEM;\n\n\tconsole_lock();\n\n\tect = 0;\n\tdict = *vc->uni_pagedict_loc;\n\tif (!dict)\n\t\tgoto unlock;\n\n\tfor (d = 0; d < UNI_DIRS; d++) {\n\t\tu16 **dir = dict->uni_pgdir[d];\n\t\tif (!dir)\n\t\t\tcontinue;\n\n\t\tfor (r = 0; r < UNI_DIR_ROWS; r++) {\n\t\t\tu16 *row = dir[r];\n\t\t\tif (!row)\n\t\t\t\tcontinue;\n\n\t\t\tfor (g = 0; g < UNI_ROW_GLYPHS; g++, row++) {\n\t\t\t\tif (*row >= MAX_GLYPH)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ect < ct) {\n\t\t\t\t\tunilist[ect].unicode = UNI(d, r, g);\n\t\t\t\t\tunilist[ect].fontpos = *row;\n\t\t\t\t}\n\t\t\t\tect++;\n\t\t\t}\n\t\t}\n\t}\nunlock:\n\tconsole_unlock();\n\tif (copy_to_user(list, unilist, min(ect, ct) * sizeof(*unilist)))\n\t\tret = -EFAULT;\n\tif (put_user(ect, uct))\n\t\tret = -EFAULT;\n\tkvfree(unilist);\n\treturn ret ? ret : (ect <= ct) ? 0 : -ENOMEM;\n}\n\n \n \nu32 conv_8bit_to_uni(unsigned char c)\n{\n\tunsigned short uni = translations[USER_MAP][c];\n\treturn uni == (0xf000 | c) ? c : uni;\n}\n\nint conv_uni_to_8bit(u32 uni)\n{\n\tint c;\n\tfor (c = 0; c < ARRAY_SIZE(translations[USER_MAP]); c++)\n\t\tif (translations[USER_MAP][c] == uni ||\n\t\t   (translations[USER_MAP][c] == (c | 0xf000) && uni == c))\n\t\t\treturn c;\n\treturn -1;\n}\n\nint conv_uni_to_pc(struct vc_data *conp, long ucs)\n{\n\tstruct uni_pagedict *dict;\n\tu16 **dir, *row, glyph;\n\n\t \n\tif (ucs > 0xffff)\n\t\treturn -4;\t\t \n\telse if (ucs < 0x20)\n\t\treturn -1;\t\t \n\telse if (ucs == 0xfeff || (ucs >= 0x200b && ucs <= 0x200f))\n\t\treturn -2;\t\t\t \n\t \n\telse if ((ucs & ~UNI_DIRECT_MASK) == UNI_DIRECT_BASE)\n\t\treturn ucs & UNI_DIRECT_MASK;\n\n\tdict = *conp->uni_pagedict_loc;\n\tif (!dict)\n\t\treturn -3;\n\n\tdir = dict->uni_pgdir[UNI_DIR(ucs)];\n\tif (!dir)\n\t\treturn -4;\n\n\trow = dir[UNI_ROW(ucs)];\n\tif (!row)\n\t\treturn -4;\n\n\tglyph = row[UNI_GLYPH(ucs)];\n\tif (glyph >= MAX_GLYPH)\n\t\treturn -4;\n\n\treturn glyph;\n}\n\n \nvoid __init\nconsole_map_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++)\n\t\tif (vc_cons_allocated(i) && !*vc_cons[i].d->uni_pagedict_loc)\n\t\t\tcon_set_default_unimap(vc_cons[i].d);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}