{
  "module_name": "vc_screen.c",
  "hash_id": "8e5f6514f3315e68b13d67600e818980094b4651db63dcf7bef0e294158144aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/vt/vc_screen.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/tty.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/vt_kern.h>\n#include <linux/selection.h>\n#include <linux/kbd_kern.h>\n#include <linux/console.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/notifier.h>\n\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n\n#define HEADER_SIZE\t4u\n#define CON_BUF_SIZE (CONFIG_BASE_SMALL ? 256 : PAGE_SIZE)\n\n \n#if MAX_NR_CONSOLES > 63\n#warning \"/dev/vcs* devices may not accommodate more than 63 consoles\"\n#endif\n\n#define console(inode)\t\t(iminor(inode) & 63)\n#define use_unicode(inode)\t(iminor(inode) & 64)\n#define use_attributes(inode)\t(iminor(inode) & 128)\n\n\nstruct vcs_poll_data {\n\tstruct notifier_block notifier;\n\tunsigned int cons_num;\n\tint event;\n\twait_queue_head_t waitq;\n\tstruct fasync_struct *fasync;\n};\n\nstatic int\nvcs_notifier(struct notifier_block *nb, unsigned long code, void *_param)\n{\n\tstruct vt_notifier_param *param = _param;\n\tstruct vc_data *vc = param->vc;\n\tstruct vcs_poll_data *poll =\n\t\tcontainer_of(nb, struct vcs_poll_data, notifier);\n\tint currcons = poll->cons_num;\n\tint fa_band;\n\n\tswitch (code) {\n\tcase VT_UPDATE:\n\t\tfa_band = POLL_PRI;\n\t\tbreak;\n\tcase VT_DEALLOCATE:\n\t\tfa_band = POLL_HUP;\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tif (currcons == 0)\n\t\tcurrcons = fg_console;\n\telse\n\t\tcurrcons--;\n\tif (currcons != vc->vc_num)\n\t\treturn NOTIFY_DONE;\n\n\tpoll->event = code;\n\twake_up_interruptible(&poll->waitq);\n\tkill_fasync(&poll->fasync, SIGIO, fa_band);\n\treturn NOTIFY_OK;\n}\n\nstatic void\nvcs_poll_data_free(struct vcs_poll_data *poll)\n{\n\tunregister_vt_notifier(&poll->notifier);\n\tkfree(poll);\n}\n\nstatic struct vcs_poll_data *\nvcs_poll_data_get(struct file *file)\n{\n\tstruct vcs_poll_data *poll = file->private_data, *kill = NULL;\n\n\tif (poll)\n\t\treturn poll;\n\n\tpoll = kzalloc(sizeof(*poll), GFP_KERNEL);\n\tif (!poll)\n\t\treturn NULL;\n\tpoll->cons_num = console(file_inode(file));\n\tinit_waitqueue_head(&poll->waitq);\n\tpoll->notifier.notifier_call = vcs_notifier;\n\t \n\tpoll->event = VT_UPDATE;\n\n\tif (register_vt_notifier(&poll->notifier) != 0) {\n\t\tkfree(poll);\n\t\treturn NULL;\n\t}\n\n\t \n\tspin_lock(&file->f_lock);\n\tif (!file->private_data) {\n\t\tfile->private_data = poll;\n\t} else {\n\t\t \n\t\tkill = poll;\n\t\tpoll = file->private_data;\n\t}\n\tspin_unlock(&file->f_lock);\n\tif (kill)\n\t\tvcs_poll_data_free(kill);\n\n\treturn poll;\n}\n\n \nstatic struct vc_data *vcs_vc(struct inode *inode, bool *viewed)\n{\n\tunsigned int currcons = console(inode);\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (currcons == 0) {\n\t\tcurrcons = fg_console;\n\t\tif (viewed)\n\t\t\t*viewed = true;\n\t} else {\n\t\tcurrcons--;\n\t\tif (viewed)\n\t\t\t*viewed = false;\n\t}\n\treturn vc_cons[currcons].d;\n}\n\n \nstatic int vcs_size(const struct vc_data *vc, bool attr, bool unicode)\n{\n\tint size;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tsize = vc->vc_rows * vc->vc_cols;\n\n\tif (attr) {\n\t\tif (unicode)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tsize = 2 * size + HEADER_SIZE;\n\t} else if (unicode)\n\t\tsize *= 4;\n\n\treturn size;\n}\n\nstatic loff_t vcs_lseek(struct file *file, loff_t offset, int orig)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tint size;\n\n\tconsole_lock();\n\tvc = vcs_vc(inode, NULL);\n\tif (!vc) {\n\t\tconsole_unlock();\n\t\treturn -ENXIO;\n\t}\n\n\tsize = vcs_size(vc, use_attributes(inode), use_unicode(inode));\n\tconsole_unlock();\n\tif (size < 0)\n\t\treturn size;\n\treturn fixed_size_llseek(file, offset, orig, size);\n}\n\nstatic int vcs_read_buf_uni(struct vc_data *vc, char *con_buf,\n\t\tunsigned int pos, unsigned int count, bool viewed)\n{\n\tunsigned int nr, row, col, maxcol = vc->vc_cols;\n\tint ret;\n\n\tret = vc_uniscr_check(vc);\n\tif (ret)\n\t\treturn ret;\n\n\tpos /= 4;\n\trow = pos / maxcol;\n\tcol = pos % maxcol;\n\tnr = maxcol - col;\n\tdo {\n\t\tif (nr > count / 4)\n\t\t\tnr = count / 4;\n\t\tvc_uniscr_copy_line(vc, con_buf, viewed, row, col, nr);\n\t\tcon_buf += nr * 4;\n\t\tcount -= nr * 4;\n\t\trow++;\n\t\tcol = 0;\n\t\tnr = maxcol;\n\t} while (count);\n\n\treturn 0;\n}\n\nstatic void vcs_read_buf_noattr(const struct vc_data *vc, char *con_buf,\n\t\tunsigned int pos, unsigned int count, bool viewed)\n{\n\tu16 *org;\n\tunsigned int col, maxcol = vc->vc_cols;\n\n\torg = screen_pos(vc, pos, viewed);\n\tcol = pos % maxcol;\n\tpos += maxcol - col;\n\n\twhile (count-- > 0) {\n\t\t*con_buf++ = (vcs_scr_readw(vc, org++) & 0xff);\n\t\tif (++col == maxcol) {\n\t\t\torg = screen_pos(vc, pos, viewed);\n\t\t\tcol = 0;\n\t\t\tpos += maxcol;\n\t\t}\n\t}\n}\n\nstatic unsigned int vcs_read_buf(const struct vc_data *vc, char *con_buf,\n\t\tunsigned int pos, unsigned int count, bool viewed,\n\t\tunsigned int *skip)\n{\n\tu16 *org, *con_buf16;\n\tunsigned int col, maxcol = vc->vc_cols;\n\tunsigned int filled = count;\n\n\tif (pos < HEADER_SIZE) {\n\t\t \n\t\tcon_buf[0] = min(vc->vc_rows, 0xFFu);\n\t\tcon_buf[1] = min(vc->vc_cols, 0xFFu);\n\t\tgetconsxy(vc, con_buf + 2);\n\n\t\t*skip += pos;\n\t\tcount += pos;\n\t\tif (count > CON_BUF_SIZE) {\n\t\t\tcount = CON_BUF_SIZE;\n\t\t\tfilled = count - pos;\n\t\t}\n\n\t\t \n\t\tcount -= min(HEADER_SIZE, count);\n\t\tpos = HEADER_SIZE;\n\t\tcon_buf += HEADER_SIZE;\n\t\t \n\t} else if (pos & 1) {\n\t\t \n\t\t(*skip)++;\n\t\tif (count < CON_BUF_SIZE)\n\t\t\tcount++;\n\t\telse\n\t\t\tfilled--;\n\t}\n\n\tif (!count)\n\t\treturn filled;\n\n\tpos -= HEADER_SIZE;\n\tpos /= 2;\n\tcol = pos % maxcol;\n\n\torg = screen_pos(vc, pos, viewed);\n\tpos += maxcol - col;\n\n\t \n\tcount = (count + 1) / 2;\n\tcon_buf16 = (u16 *)con_buf;\n\n\twhile (count) {\n\t\t*con_buf16++ = vcs_scr_readw(vc, org++);\n\t\tcount--;\n\t\tif (++col == maxcol) {\n\t\t\torg = screen_pos(vc, pos, viewed);\n\t\t\tcol = 0;\n\t\t\tpos += maxcol;\n\t\t}\n\t}\n\n\treturn filled;\n}\n\nstatic ssize_t\nvcs_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tstruct vcs_poll_data *poll;\n\tunsigned int read;\n\tssize_t ret;\n\tchar *con_buf;\n\tloff_t pos;\n\tbool viewed, attr, uni_mode;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t \n\tconsole_lock();\n\n\tuni_mode = use_unicode(inode);\n\tattr = use_attributes(inode);\n\n\tret = -EINVAL;\n\tif (pos < 0)\n\t\tgoto unlock_out;\n\t \n\tif (uni_mode && (pos | count) & 3)\n\t\tgoto unlock_out;\n\n\tpoll = file->private_data;\n\tif (count && poll)\n\t\tpoll->event = 0;\n\tread = 0;\n\tret = 0;\n\twhile (count) {\n\t\tunsigned int this_round, skip = 0;\n\t\tint size;\n\n\t\tvc = vcs_vc(inode, &viewed);\n\t\tif (!vc) {\n\t\t\tret = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsize = vcs_size(vc, attr, uni_mode);\n\t\tif (size < 0) {\n\t\t\tret = size;\n\t\t\tbreak;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (count > size - pos)\n\t\t\tcount = size - pos;\n\n\t\tthis_round = count;\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t \n\n\t\tif (uni_mode) {\n\t\t\tret = vcs_read_buf_uni(vc, con_buf, pos, this_round,\n\t\t\t\t\tviewed);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (!attr) {\n\t\t\tvcs_read_buf_noattr(vc, con_buf, pos, this_round,\n\t\t\t\t\tviewed);\n\t\t} else {\n\t\t\tthis_round = vcs_read_buf(vc, con_buf, pos, this_round,\n\t\t\t\t\tviewed, &skip);\n\t\t}\n\n\t\t \n\n\t\tconsole_unlock();\n\t\tret = copy_to_user(buf, con_buf + skip, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tread += this_round - ret;\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuf += this_round;\n\t\tpos += this_round;\n\t\tread += this_round;\n\t\tcount -= this_round;\n\t}\n\t*ppos += read;\n\tif (read)\n\t\tret = read;\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}\n\nstatic u16 *vcs_write_buf_noattr(struct vc_data *vc, const char *con_buf,\n\t\tunsigned int pos, unsigned int count, bool viewed, u16 **org0)\n{\n\tu16 *org;\n\tunsigned int col, maxcol = vc->vc_cols;\n\n\t*org0 = org = screen_pos(vc, pos, viewed);\n\tcol = pos % maxcol;\n\tpos += maxcol - col;\n\n\twhile (count > 0) {\n\t\tunsigned char c = *con_buf++;\n\n\t\tcount--;\n\t\tvcs_scr_writew(vc,\n\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\torg++;\n\t\tif (++col == maxcol) {\n\t\t\torg = screen_pos(vc, pos, viewed);\n\t\t\tcol = 0;\n\t\t\tpos += maxcol;\n\t\t}\n\t}\n\n\treturn org;\n}\n\n \nstatic inline u16 vc_compile_le16(u8 hi, u8 lo)\n{\n#ifdef __BIG_ENDIAN\n\treturn (lo << 8u) | hi;\n#else\n\treturn (hi << 8u) | lo;\n#endif\n}\n\nstatic u16 *vcs_write_buf(struct vc_data *vc, const char *con_buf,\n\t\tunsigned int pos, unsigned int count, bool viewed, u16 **org0)\n{\n\tu16 *org;\n\tunsigned int col, maxcol = vc->vc_cols;\n\tunsigned char c;\n\n\t \n\tif (pos < HEADER_SIZE) {\n\t\tchar header[HEADER_SIZE];\n\n\t\tgetconsxy(vc, header + 2);\n\t\twhile (pos < HEADER_SIZE && count > 0) {\n\t\t\tcount--;\n\t\t\theader[pos++] = *con_buf++;\n\t\t}\n\t\tif (!viewed)\n\t\t\tputconsxy(vc, header + 2);\n\t}\n\n\tif (!count)\n\t\treturn NULL;\n\n\tpos -= HEADER_SIZE;\n\tcol = (pos/2) % maxcol;\n\n\t*org0 = org = screen_pos(vc, pos/2, viewed);\n\n\t \n\tif (pos & 1) {\n\t\tcount--;\n\t\tc = *con_buf++;\n\t\tvcs_scr_writew(vc, vc_compile_le16(c, vcs_scr_readw(vc, org)),\n\t\t\t\torg);\n\t\torg++;\n\t\tpos++;\n\t\tif (++col == maxcol) {\n\t\t\torg = screen_pos(vc, pos/2, viewed);\n\t\t\tcol = 0;\n\t\t}\n\t}\n\n\tpos /= 2;\n\tpos += maxcol - col;\n\n\t \n\twhile (count > 1) {\n\t\tunsigned short w;\n\n\t\tw = get_unaligned(((unsigned short *)con_buf));\n\t\tvcs_scr_writew(vc, w, org++);\n\t\tcon_buf += 2;\n\t\tcount -= 2;\n\t\tif (++col == maxcol) {\n\t\t\torg = screen_pos(vc, pos, viewed);\n\t\t\tcol = 0;\n\t\t\tpos += maxcol;\n\t\t}\n\t}\n\n\tif (!count)\n\t\treturn org;\n\n\t \n\tc = *con_buf++;\n\tvcs_scr_writew(vc, vc_compile_le16(vcs_scr_readw(vc, org) >> 8, c),\n\t\t\t\torg);\n\n\treturn org;\n}\n\nstatic ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tchar *con_buf;\n\tu16 *org0, *org;\n\tunsigned int written;\n\tint size;\n\tssize_t ret;\n\tloff_t pos;\n\tbool viewed, attr;\n\n\tif (use_unicode(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t \n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(vc, attr, false);\n\tif (size < 0) {\n\t\tret = size;\n\t\tgoto unlock_out;\n\t}\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tunsigned int this_round = count;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t \n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t \n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tvc = vcs_vc(inode, &viewed);\n\t\tif (!vc) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = -ENXIO;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsize = vcs_size(vc, attr, false);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t \n\n\t\tif (attr)\n\t\t\torg = vcs_write_buf(vc, con_buf, pos, this_round,\n\t\t\t\t\tviewed, &org0);\n\t\telse\n\t\t\torg = vcs_write_buf_noattr(vc, con_buf, pos, this_round,\n\t\t\t\t\tviewed, &org0);\n\n\t\tcount -= this_round;\n\t\twritten += this_round;\n\t\tbuf += this_round;\n\t\tpos += this_round;\n\t\tif (org)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}\n\nstatic __poll_t\nvcs_poll(struct file *file, poll_table *wait)\n{\n\tstruct vcs_poll_data *poll = vcs_poll_data_get(file);\n\t__poll_t ret = DEFAULT_POLLMASK|EPOLLERR;\n\n\tif (poll) {\n\t\tpoll_wait(file, &poll->waitq, wait);\n\t\tswitch (poll->event) {\n\t\tcase VT_UPDATE:\n\t\t\tret = DEFAULT_POLLMASK|EPOLLPRI;\n\t\t\tbreak;\n\t\tcase VT_DEALLOCATE:\n\t\t\tret = DEFAULT_POLLMASK|EPOLLHUP|EPOLLERR;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tret = DEFAULT_POLLMASK;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int\nvcs_fasync(int fd, struct file *file, int on)\n{\n\tstruct vcs_poll_data *poll = file->private_data;\n\n\tif (!poll) {\n\t\t \n\t\tif (!on)\n\t\t\treturn 0;\n\t\tpoll = vcs_poll_data_get(file);\n\t\tif (!poll)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn fasync_helper(fd, file, on, &poll->fasync);\n}\n\nstatic int\nvcs_open(struct inode *inode, struct file *filp)\n{\n\tunsigned int currcons = console(inode);\n\tbool attr = use_attributes(inode);\n\tbool uni_mode = use_unicode(inode);\n\tint ret = 0;\n\n\t \n\tif (attr && uni_mode)\n\t\treturn -EOPNOTSUPP;\n\n\tconsole_lock();\n\tif(currcons && !vc_cons_allocated(currcons-1))\n\t\tret = -ENXIO;\n\tconsole_unlock();\n\treturn ret;\n}\n\nstatic int vcs_release(struct inode *inode, struct file *file)\n{\n\tstruct vcs_poll_data *poll = file->private_data;\n\n\tif (poll)\n\t\tvcs_poll_data_free(poll);\n\treturn 0;\n}\n\nstatic const struct file_operations vcs_fops = {\n\t.llseek\t\t= vcs_lseek,\n\t.read\t\t= vcs_read,\n\t.write\t\t= vcs_write,\n\t.poll\t\t= vcs_poll,\n\t.fasync\t\t= vcs_fasync,\n\t.open\t\t= vcs_open,\n\t.release\t= vcs_release,\n};\n\nstatic struct class *vc_class;\n\nvoid vcs_make_sysfs(int index)\n{\n\tdevice_create(vc_class, NULL, MKDEV(VCS_MAJOR, index + 1), NULL,\n\t\t      \"vcs%u\", index + 1);\n\tdevice_create(vc_class, NULL, MKDEV(VCS_MAJOR, index + 65), NULL,\n\t\t      \"vcsu%u\", index + 1);\n\tdevice_create(vc_class, NULL, MKDEV(VCS_MAJOR, index + 129), NULL,\n\t\t      \"vcsa%u\", index + 1);\n}\n\nvoid vcs_remove_sysfs(int index)\n{\n\tdevice_destroy(vc_class, MKDEV(VCS_MAJOR, index + 1));\n\tdevice_destroy(vc_class, MKDEV(VCS_MAJOR, index + 65));\n\tdevice_destroy(vc_class, MKDEV(VCS_MAJOR, index + 129));\n}\n\nint __init vcs_init(void)\n{\n\tunsigned int i;\n\n\tif (register_chrdev(VCS_MAJOR, \"vcs\", &vcs_fops))\n\t\tpanic(\"unable to get major %d for vcs device\", VCS_MAJOR);\n\tvc_class = class_create(\"vc\");\n\n\tdevice_create(vc_class, NULL, MKDEV(VCS_MAJOR, 0), NULL, \"vcs\");\n\tdevice_create(vc_class, NULL, MKDEV(VCS_MAJOR, 64), NULL, \"vcsu\");\n\tdevice_create(vc_class, NULL, MKDEV(VCS_MAJOR, 128), NULL, \"vcsa\");\n\tfor (i = 0; i < MIN_NR_CONSOLES; i++)\n\t\tvcs_make_sysfs(i);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}