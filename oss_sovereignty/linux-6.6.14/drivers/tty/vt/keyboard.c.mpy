{
  "module_name": "keyboard.c",
  "hash_id": "efffe73837126d3cdc096b03bbd0998e217c723ddf4d52afd652cfd1c55553e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/vt/keyboard.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/consolemap.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n#include <linux/kbd_diacr.h>\n#include <linux/kbd_kern.h>\n#include <linux/leds.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/nospec.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/tty_flip.h>\n#include <linux/tty.h>\n#include <linux/uaccess.h>\n#include <linux/vt_kern.h>\n\n#include <asm/irq_regs.h>\n\n \n\n#define KBD_DEFMODE (BIT(VC_REPEAT) | BIT(VC_META))\n\n#if defined(CONFIG_X86) || defined(CONFIG_PARISC)\n#include <asm/kbdleds.h>\n#else\nstatic inline int kbd_defleds(void)\n{\n\treturn 0;\n}\n#endif\n\n#define KBD_DEFLOCK 0\n\n \n\n#define K_HANDLERS\\\n\tk_self,\t\tk_fn,\t\tk_spec,\t\tk_pad,\\\n\tk_dead,\t\tk_cons,\t\tk_cur,\t\tk_shift,\\\n\tk_meta,\t\tk_ascii,\tk_lock,\t\tk_lowercase,\\\n\tk_slock,\tk_dead2,\tk_brl,\t\tk_ignore\n\ntypedef void (k_handler_fn)(struct vc_data *vc, unsigned char value,\n\t\t\t    char up_flag);\nstatic k_handler_fn K_HANDLERS;\nstatic k_handler_fn *k_handler[16] = { K_HANDLERS };\n\n#define FN_HANDLERS\\\n\tfn_null,\tfn_enter,\tfn_show_ptregs,\tfn_show_mem,\\\n\tfn_show_state,\tfn_send_intr,\tfn_lastcons,\tfn_caps_toggle,\\\n\tfn_num,\t\tfn_hold,\tfn_scroll_forw,\tfn_scroll_back,\\\n\tfn_boot_it,\tfn_caps_on,\tfn_compose,\tfn_SAK,\\\n\tfn_dec_console, fn_inc_console, fn_spawn_con,\tfn_bare_num\n\ntypedef void (fn_handler_fn)(struct vc_data *vc);\nstatic fn_handler_fn FN_HANDLERS;\nstatic fn_handler_fn *fn_handler[] = { FN_HANDLERS };\n\n \n\nstruct vt_spawn_console vt_spawn_con = {\n\t.lock = __SPIN_LOCK_UNLOCKED(vt_spawn_con.lock),\n\t.pid  = NULL,\n\t.sig  = 0,\n};\n\n\n \n\nstatic struct kbd_struct kbd_table[MAX_NR_CONSOLES];\nstatic struct kbd_struct *kbd = kbd_table;\n\n \nstatic const unsigned char max_vals[] = {\n\t[ KT_LATIN\t] = 255,\n\t[ KT_FN\t\t] = ARRAY_SIZE(func_table) - 1,\n\t[ KT_SPEC\t] = ARRAY_SIZE(fn_handler) - 1,\n\t[ KT_PAD\t] = NR_PAD - 1,\n\t[ KT_DEAD\t] = NR_DEAD - 1,\n\t[ KT_CONS\t] = 255,\n\t[ KT_CUR\t] = 3,\n\t[ KT_SHIFT\t] = NR_SHIFT - 1,\n\t[ KT_META\t] = 255,\n\t[ KT_ASCII\t] = NR_ASCII - 1,\n\t[ KT_LOCK\t] = NR_LOCK - 1,\n\t[ KT_LETTER\t] = 255,\n\t[ KT_SLOCK\t] = NR_LOCK - 1,\n\t[ KT_DEAD2\t] = 255,\n\t[ KT_BRL\t] = NR_BRL - 1,\n};\n\nstatic const int NR_TYPES = ARRAY_SIZE(max_vals);\n\nstatic void kbd_bh(struct tasklet_struct *unused);\nstatic DECLARE_TASKLET_DISABLED(keyboard_tasklet, kbd_bh);\n\nstatic struct input_handler kbd_handler;\nstatic DEFINE_SPINLOCK(kbd_event_lock);\nstatic DEFINE_SPINLOCK(led_lock);\nstatic DEFINE_SPINLOCK(func_buf_lock);  \nstatic DECLARE_BITMAP(key_down, KEY_CNT);\t \nstatic unsigned char shift_down[NR_SHIFT];\t\t \nstatic bool dead_key_next;\n\n \nstatic bool npadch_active;\nstatic unsigned int npadch_value;\n\nstatic unsigned int diacr;\nstatic bool rep;\t\t\t \n\nstatic int shift_state = 0;\n\nstatic unsigned int ledstate = -1U;\t\t\t \nstatic unsigned char ledioctl;\nstatic bool vt_switch;\n\n \nstatic ATOMIC_NOTIFIER_HEAD(keyboard_notifier_list);\n\nint register_keyboard_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&keyboard_notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(register_keyboard_notifier);\n\nint unregister_keyboard_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&keyboard_notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_keyboard_notifier);\n\n \n\nstruct getset_keycode_data {\n\tstruct input_keymap_entry ke;\n\tint error;\n};\n\nstatic int getkeycode_helper(struct input_handle *handle, void *data)\n{\n\tstruct getset_keycode_data *d = data;\n\n\td->error = input_get_keycode(handle->dev, &d->ke);\n\n\treturn d->error == 0;  \n}\n\nstatic int getkeycode(unsigned int scancode)\n{\n\tstruct getset_keycode_data d = {\n\t\t.ke\t= {\n\t\t\t.flags\t\t= 0,\n\t\t\t.len\t\t= sizeof(scancode),\n\t\t\t.keycode\t= 0,\n\t\t},\n\t\t.error\t= -ENODEV,\n\t};\n\n\tmemcpy(d.ke.scancode, &scancode, sizeof(scancode));\n\n\tinput_handler_for_each_handle(&kbd_handler, &d, getkeycode_helper);\n\n\treturn d.error ?: d.ke.keycode;\n}\n\nstatic int setkeycode_helper(struct input_handle *handle, void *data)\n{\n\tstruct getset_keycode_data *d = data;\n\n\td->error = input_set_keycode(handle->dev, &d->ke);\n\n\treturn d->error == 0;  \n}\n\nstatic int setkeycode(unsigned int scancode, unsigned int keycode)\n{\n\tstruct getset_keycode_data d = {\n\t\t.ke\t= {\n\t\t\t.flags\t\t= 0,\n\t\t\t.len\t\t= sizeof(scancode),\n\t\t\t.keycode\t= keycode,\n\t\t},\n\t\t.error\t= -ENODEV,\n\t};\n\n\tmemcpy(d.ke.scancode, &scancode, sizeof(scancode));\n\n\tinput_handler_for_each_handle(&kbd_handler, &d, setkeycode_helper);\n\n\treturn d.error;\n}\n\n \n\nstatic int kd_sound_helper(struct input_handle *handle, void *data)\n{\n\tunsigned int *hz = data;\n\tstruct input_dev *dev = handle->dev;\n\n\tif (test_bit(EV_SND, dev->evbit)) {\n\t\tif (test_bit(SND_TONE, dev->sndbit)) {\n\t\t\tinput_inject_event(handle, EV_SND, SND_TONE, *hz);\n\t\t\tif (*hz)\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (test_bit(SND_BELL, dev->sndbit))\n\t\t\tinput_inject_event(handle, EV_SND, SND_BELL, *hz ? 1 : 0);\n\t}\n\n\treturn 0;\n}\n\nstatic void kd_nosound(struct timer_list *unused)\n{\n\tstatic unsigned int zero;\n\n\tinput_handler_for_each_handle(&kbd_handler, &zero, kd_sound_helper);\n}\n\nstatic DEFINE_TIMER(kd_mksound_timer, kd_nosound);\n\nvoid kd_mksound(unsigned int hz, unsigned int ticks)\n{\n\tdel_timer_sync(&kd_mksound_timer);\n\n\tinput_handler_for_each_handle(&kbd_handler, &hz, kd_sound_helper);\n\n\tif (hz && ticks)\n\t\tmod_timer(&kd_mksound_timer, jiffies + ticks);\n}\nEXPORT_SYMBOL(kd_mksound);\n\n \n\nstatic int kbd_rate_helper(struct input_handle *handle, void *data)\n{\n\tstruct input_dev *dev = handle->dev;\n\tstruct kbd_repeat *rpt = data;\n\n\tif (test_bit(EV_REP, dev->evbit)) {\n\n\t\tif (rpt[0].delay > 0)\n\t\t\tinput_inject_event(handle,\n\t\t\t\t\t   EV_REP, REP_DELAY, rpt[0].delay);\n\t\tif (rpt[0].period > 0)\n\t\t\tinput_inject_event(handle,\n\t\t\t\t\t   EV_REP, REP_PERIOD, rpt[0].period);\n\n\t\trpt[1].delay = dev->rep[REP_DELAY];\n\t\trpt[1].period = dev->rep[REP_PERIOD];\n\t}\n\n\treturn 0;\n}\n\nint kbd_rate(struct kbd_repeat *rpt)\n{\n\tstruct kbd_repeat data[2] = { *rpt };\n\n\tinput_handler_for_each_handle(&kbd_handler, data, kbd_rate_helper);\n\t*rpt = data[1];\t \n\n\treturn 0;\n}\n\n \nstatic void put_queue(struct vc_data *vc, int ch)\n{\n\ttty_insert_flip_char(&vc->port, ch, 0);\n\ttty_flip_buffer_push(&vc->port);\n}\n\nstatic void puts_queue(struct vc_data *vc, const char *cp)\n{\n\ttty_insert_flip_string(&vc->port, cp, strlen(cp));\n\ttty_flip_buffer_push(&vc->port);\n}\n\nstatic void applkey(struct vc_data *vc, int key, char mode)\n{\n\tstatic char buf[] = { 0x1b, 'O', 0x00, 0x00 };\n\n\tbuf[1] = (mode ? 'O' : '[');\n\tbuf[2] = key;\n\tputs_queue(vc, buf);\n}\n\n \nstatic void to_utf8(struct vc_data *vc, uint c)\n{\n\tif (c < 0x80)\n\t\t \n\t\tput_queue(vc, c);\n\telse if (c < 0x800) {\n\t\t \n\t\tput_queue(vc, 0xc0 | (c >> 6));\n\t\tput_queue(vc, 0x80 | (c & 0x3f));\n\t} else if (c < 0x10000) {\n\t\tif (c >= 0xD800 && c < 0xE000)\n\t\t\treturn;\n\t\tif (c == 0xFFFF)\n\t\t\treturn;\n\t\t \n\t\tput_queue(vc, 0xe0 | (c >> 12));\n\t\tput_queue(vc, 0x80 | ((c >> 6) & 0x3f));\n\t\tput_queue(vc, 0x80 | (c & 0x3f));\n\t} else if (c < 0x110000) {\n\t\t \n\t\tput_queue(vc, 0xf0 | (c >> 18));\n\t\tput_queue(vc, 0x80 | ((c >> 12) & 0x3f));\n\t\tput_queue(vc, 0x80 | ((c >> 6) & 0x3f));\n\t\tput_queue(vc, 0x80 | (c & 0x3f));\n\t}\n}\n\n \nstatic void set_leds(void)\n{\n\ttasklet_schedule(&keyboard_tasklet);\n}\n\n \n\nstatic void do_compute_shiftstate(void)\n{\n\tunsigned int k, sym, val;\n\n\tshift_state = 0;\n\tmemset(shift_down, 0, sizeof(shift_down));\n\n\tfor_each_set_bit(k, key_down, min(NR_KEYS, KEY_CNT)) {\n\t\tsym = U(key_maps[0][k]);\n\t\tif (KTYP(sym) != KT_SHIFT && KTYP(sym) != KT_SLOCK)\n\t\t\tcontinue;\n\n\t\tval = KVAL(sym);\n\t\tif (val == KVAL(K_CAPSSHIFT))\n\t\t\tval = KVAL(K_SHIFT);\n\n\t\tshift_down[val]++;\n\t\tshift_state |= BIT(val);\n\t}\n}\n\n \nvoid vt_set_leds_compute_shiftstate(void)\n{\n\tunsigned long flags;\n\n\t \n\tvt_switch = true;\n\tset_leds();\n\n\tspin_lock_irqsave(&kbd_event_lock, flags);\n\tdo_compute_shiftstate();\n\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n}\n\n \nstatic unsigned int handle_diacr(struct vc_data *vc, unsigned int ch)\n{\n\tunsigned int d = diacr;\n\tunsigned int i;\n\n\tdiacr = 0;\n\n\tif ((d & ~0xff) == BRL_UC_ROW) {\n\t\tif ((ch & ~0xff) == BRL_UC_ROW)\n\t\t\treturn d | ch;\n\t} else {\n\t\tfor (i = 0; i < accent_table_size; i++)\n\t\t\tif (accent_table[i].diacr == d && accent_table[i].base == ch)\n\t\t\t\treturn accent_table[i].result;\n\t}\n\n\tif (ch == ' ' || ch == (BRL_UC_ROW|0) || ch == d)\n\t\treturn d;\n\n\tif (kbd->kbdmode == VC_UNICODE)\n\t\tto_utf8(vc, d);\n\telse {\n\t\tint c = conv_uni_to_8bit(d);\n\t\tif (c != -1)\n\t\t\tput_queue(vc, c);\n\t}\n\n\treturn ch;\n}\n\n \nstatic void fn_enter(struct vc_data *vc)\n{\n\tif (diacr) {\n\t\tif (kbd->kbdmode == VC_UNICODE)\n\t\t\tto_utf8(vc, diacr);\n\t\telse {\n\t\t\tint c = conv_uni_to_8bit(diacr);\n\t\t\tif (c != -1)\n\t\t\t\tput_queue(vc, c);\n\t\t}\n\t\tdiacr = 0;\n\t}\n\n\tput_queue(vc, '\\r');\n\tif (vc_kbd_mode(kbd, VC_CRLF))\n\t\tput_queue(vc, '\\n');\n}\n\nstatic void fn_caps_toggle(struct vc_data *vc)\n{\n\tif (rep)\n\t\treturn;\n\n\tchg_vc_kbd_led(kbd, VC_CAPSLOCK);\n}\n\nstatic void fn_caps_on(struct vc_data *vc)\n{\n\tif (rep)\n\t\treturn;\n\n\tset_vc_kbd_led(kbd, VC_CAPSLOCK);\n}\n\nstatic void fn_show_ptregs(struct vc_data *vc)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (regs)\n\t\tshow_regs(regs);\n}\n\nstatic void fn_hold(struct vc_data *vc)\n{\n\tstruct tty_struct *tty = vc->port.tty;\n\n\tif (rep || !tty)\n\t\treturn;\n\n\t \n\tif (tty->flow.stopped)\n\t\tstart_tty(tty);\n\telse\n\t\tstop_tty(tty);\n}\n\nstatic void fn_num(struct vc_data *vc)\n{\n\tif (vc_kbd_mode(kbd, VC_APPLIC))\n\t\tapplkey(vc, 'P', 1);\n\telse\n\t\tfn_bare_num(vc);\n}\n\n \nstatic void fn_bare_num(struct vc_data *vc)\n{\n\tif (!rep)\n\t\tchg_vc_kbd_led(kbd, VC_NUMLOCK);\n}\n\nstatic void fn_lastcons(struct vc_data *vc)\n{\n\t \n\tset_console(last_console);\n}\n\nstatic void fn_dec_console(struct vc_data *vc)\n{\n\tint i, cur = fg_console;\n\n\t \n\tif (want_console != -1)\n\t\tcur = want_console;\n\n\tfor (i = cur - 1; i != cur; i--) {\n\t\tif (i == -1)\n\t\t\ti = MAX_NR_CONSOLES - 1;\n\t\tif (vc_cons_allocated(i))\n\t\t\tbreak;\n\t}\n\tset_console(i);\n}\n\nstatic void fn_inc_console(struct vc_data *vc)\n{\n\tint i, cur = fg_console;\n\n\t \n\tif (want_console != -1)\n\t\tcur = want_console;\n\n\tfor (i = cur+1; i != cur; i++) {\n\t\tif (i == MAX_NR_CONSOLES)\n\t\t\ti = 0;\n\t\tif (vc_cons_allocated(i))\n\t\t\tbreak;\n\t}\n\tset_console(i);\n}\n\nstatic void fn_send_intr(struct vc_data *vc)\n{\n\ttty_insert_flip_char(&vc->port, 0, TTY_BREAK);\n\ttty_flip_buffer_push(&vc->port);\n}\n\nstatic void fn_scroll_forw(struct vc_data *vc)\n{\n\tscrollfront(vc, 0);\n}\n\nstatic void fn_scroll_back(struct vc_data *vc)\n{\n\tscrollback(vc);\n}\n\nstatic void fn_show_mem(struct vc_data *vc)\n{\n\tshow_mem();\n}\n\nstatic void fn_show_state(struct vc_data *vc)\n{\n\tshow_state();\n}\n\nstatic void fn_boot_it(struct vc_data *vc)\n{\n\tctrl_alt_del();\n}\n\nstatic void fn_compose(struct vc_data *vc)\n{\n\tdead_key_next = true;\n}\n\nstatic void fn_spawn_con(struct vc_data *vc)\n{\n\tspin_lock(&vt_spawn_con.lock);\n\tif (vt_spawn_con.pid)\n\t\tif (kill_pid(vt_spawn_con.pid, vt_spawn_con.sig, 1)) {\n\t\t\tput_pid(vt_spawn_con.pid);\n\t\t\tvt_spawn_con.pid = NULL;\n\t\t}\n\tspin_unlock(&vt_spawn_con.lock);\n}\n\nstatic void fn_SAK(struct vc_data *vc)\n{\n\tstruct work_struct *SAK_work = &vc_cons[fg_console].SAK_work;\n\tschedule_work(SAK_work);\n}\n\nstatic void fn_null(struct vc_data *vc)\n{\n\tdo_compute_shiftstate();\n}\n\n \nstatic void k_ignore(struct vc_data *vc, unsigned char value, char up_flag)\n{\n}\n\nstatic void k_spec(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tif (up_flag)\n\t\treturn;\n\tif (value >= ARRAY_SIZE(fn_handler))\n\t\treturn;\n\tif ((kbd->kbdmode == VC_RAW ||\n\t     kbd->kbdmode == VC_MEDIUMRAW ||\n\t     kbd->kbdmode == VC_OFF) &&\n\t     value != KVAL(K_SAK))\n\t\treturn;\t\t \n\tfn_handler[value](vc);\n}\n\nstatic void k_lowercase(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tpr_err(\"k_lowercase was called - impossible\\n\");\n}\n\nstatic void k_unicode(struct vc_data *vc, unsigned int value, char up_flag)\n{\n\tif (up_flag)\n\t\treturn;\t\t \n\n\tif (diacr)\n\t\tvalue = handle_diacr(vc, value);\n\n\tif (dead_key_next) {\n\t\tdead_key_next = false;\n\t\tdiacr = value;\n\t\treturn;\n\t}\n\tif (kbd->kbdmode == VC_UNICODE)\n\t\tto_utf8(vc, value);\n\telse {\n\t\tint c = conv_uni_to_8bit(value);\n\t\tif (c != -1)\n\t\t\tput_queue(vc, c);\n\t}\n}\n\n \nstatic void k_deadunicode(struct vc_data *vc, unsigned int value, char up_flag)\n{\n\tif (up_flag)\n\t\treturn;\n\n\tdiacr = (diacr ? handle_diacr(vc, value) : value);\n}\n\nstatic void k_self(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tk_unicode(vc, conv_8bit_to_uni(value), up_flag);\n}\n\nstatic void k_dead2(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tk_deadunicode(vc, value, up_flag);\n}\n\n \nstatic void k_dead(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tstatic const unsigned char ret_diacr[NR_DEAD] = {\n\t\t'`',\t \n\t\t'\\'',\t \n\t\t'^',\t \n\t\t'~',\t \n\t\t'\"',\t \n\t\t',',\t \n\t\t'_',\t \n\t\t'U',\t \n\t\t'.',\t \n\t\t'*',\t \n\t\t'=',\t \n\t\t'c',\t \n\t\t'k',\t \n\t\t'i',\t \n\t\t'#',\t \n\t\t'o',\t \n\t\t'!',\t \n\t\t'?',\t \n\t\t'+',\t \n\t\t'-',\t \n\t\t')',\t \n\t\t'(',\t \n\t\t':',\t \n\t\t'n',\t \n\t\t';',\t \n\t\t'$',\t \n\t\t'@',\t \n\t};\n\n\tk_deadunicode(vc, ret_diacr[value], up_flag);\n}\n\nstatic void k_cons(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tif (up_flag)\n\t\treturn;\n\n\tset_console(value);\n}\n\nstatic void k_fn(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tif (up_flag)\n\t\treturn;\n\n\tif ((unsigned)value < ARRAY_SIZE(func_table)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&func_buf_lock, flags);\n\t\tif (func_table[value])\n\t\t\tputs_queue(vc, func_table[value]);\n\t\tspin_unlock_irqrestore(&func_buf_lock, flags);\n\n\t} else\n\t\tpr_err(\"k_fn called with value=%d\\n\", value);\n}\n\nstatic void k_cur(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tstatic const char cur_chars[] = \"BDCA\";\n\n\tif (up_flag)\n\t\treturn;\n\n\tapplkey(vc, cur_chars[value], vc_kbd_mode(kbd, VC_CKMODE));\n}\n\nstatic void k_pad(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tstatic const char pad_chars[] = \"0123456789+-*/\\015,.?()#\";\n\tstatic const char app_map[] = \"pqrstuvwxylSRQMnnmPQS\";\n\n\tif (up_flag)\n\t\treturn;\t\t \n\n\t \n\tif (vc_kbd_mode(kbd, VC_APPLIC) && !shift_down[KG_SHIFT]) {\n\t\tapplkey(vc, app_map[value], 1);\n\t\treturn;\n\t}\n\n\tif (!vc_kbd_led(kbd, VC_NUMLOCK)) {\n\n\t\tswitch (value) {\n\t\tcase KVAL(K_PCOMMA):\n\t\tcase KVAL(K_PDOT):\n\t\t\tk_fn(vc, KVAL(K_REMOVE), 0);\n\t\t\treturn;\n\t\tcase KVAL(K_P0):\n\t\t\tk_fn(vc, KVAL(K_INSERT), 0);\n\t\t\treturn;\n\t\tcase KVAL(K_P1):\n\t\t\tk_fn(vc, KVAL(K_SELECT), 0);\n\t\t\treturn;\n\t\tcase KVAL(K_P2):\n\t\t\tk_cur(vc, KVAL(K_DOWN), 0);\n\t\t\treturn;\n\t\tcase KVAL(K_P3):\n\t\t\tk_fn(vc, KVAL(K_PGDN), 0);\n\t\t\treturn;\n\t\tcase KVAL(K_P4):\n\t\t\tk_cur(vc, KVAL(K_LEFT), 0);\n\t\t\treturn;\n\t\tcase KVAL(K_P6):\n\t\t\tk_cur(vc, KVAL(K_RIGHT), 0);\n\t\t\treturn;\n\t\tcase KVAL(K_P7):\n\t\t\tk_fn(vc, KVAL(K_FIND), 0);\n\t\t\treturn;\n\t\tcase KVAL(K_P8):\n\t\t\tk_cur(vc, KVAL(K_UP), 0);\n\t\t\treturn;\n\t\tcase KVAL(K_P9):\n\t\t\tk_fn(vc, KVAL(K_PGUP), 0);\n\t\t\treturn;\n\t\tcase KVAL(K_P5):\n\t\t\tapplkey(vc, 'G', vc_kbd_mode(kbd, VC_APPLIC));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tput_queue(vc, pad_chars[value]);\n\tif (value == KVAL(K_PENTER) && vc_kbd_mode(kbd, VC_CRLF))\n\t\tput_queue(vc, '\\n');\n}\n\nstatic void k_shift(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tint old_state = shift_state;\n\n\tif (rep)\n\t\treturn;\n\t \n\tif (value == KVAL(K_CAPSSHIFT)) {\n\t\tvalue = KVAL(K_SHIFT);\n\t\tif (!up_flag)\n\t\t\tclr_vc_kbd_led(kbd, VC_CAPSLOCK);\n\t}\n\n\tif (up_flag) {\n\t\t \n\t\tif (shift_down[value])\n\t\t\tshift_down[value]--;\n\t} else\n\t\tshift_down[value]++;\n\n\tif (shift_down[value])\n\t\tshift_state |= BIT(value);\n\telse\n\t\tshift_state &= ~BIT(value);\n\n\t \n\tif (up_flag && shift_state != old_state && npadch_active) {\n\t\tif (kbd->kbdmode == VC_UNICODE)\n\t\t\tto_utf8(vc, npadch_value);\n\t\telse\n\t\t\tput_queue(vc, npadch_value & 0xff);\n\t\tnpadch_active = false;\n\t}\n}\n\nstatic void k_meta(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tif (up_flag)\n\t\treturn;\n\n\tif (vc_kbd_mode(kbd, VC_META)) {\n\t\tput_queue(vc, '\\033');\n\t\tput_queue(vc, value);\n\t} else\n\t\tput_queue(vc, value | BIT(7));\n}\n\nstatic void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tunsigned int base;\n\n\tif (up_flag)\n\t\treturn;\n\n\tif (value < 10) {\n\t\t \n\t\tbase = 10;\n\t} else {\n\t\t \n\t\tvalue -= 10;\n\t\tbase = 16;\n\t}\n\n\tif (!npadch_active) {\n\t\tnpadch_value = 0;\n\t\tnpadch_active = true;\n\t}\n\n\tnpadch_value = npadch_value * base + value;\n}\n\nstatic void k_lock(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tif (up_flag || rep)\n\t\treturn;\n\n\tchg_vc_kbd_lock(kbd, value);\n}\n\nstatic void k_slock(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tk_shift(vc, value, up_flag);\n\tif (up_flag || rep)\n\t\treturn;\n\n\tchg_vc_kbd_slock(kbd, value);\n\t \n\tif (!key_maps[kbd->lockstate ^ kbd->slockstate]) {\n\t\tkbd->slockstate = 0;\n\t\tchg_vc_kbd_slock(kbd, value);\n\t}\n}\n\n \nstatic unsigned brl_timeout = 300;\nMODULE_PARM_DESC(brl_timeout, \"Braille keys release delay in ms (0 for commit on first key release)\");\nmodule_param(brl_timeout, uint, 0644);\n\nstatic unsigned brl_nbchords = 1;\nMODULE_PARM_DESC(brl_nbchords, \"Number of chords that produce a braille pattern (0 for dead chords)\");\nmodule_param(brl_nbchords, uint, 0644);\n\nstatic void k_brlcommit(struct vc_data *vc, unsigned int pattern, char up_flag)\n{\n\tstatic unsigned long chords;\n\tstatic unsigned committed;\n\n\tif (!brl_nbchords)\n\t\tk_deadunicode(vc, BRL_UC_ROW | pattern, up_flag);\n\telse {\n\t\tcommitted |= pattern;\n\t\tchords++;\n\t\tif (chords == brl_nbchords) {\n\t\t\tk_unicode(vc, BRL_UC_ROW | committed, up_flag);\n\t\t\tchords = 0;\n\t\t\tcommitted = 0;\n\t\t}\n\t}\n}\n\nstatic void k_brl(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tstatic unsigned pressed, committing;\n\tstatic unsigned long releasestart;\n\n\tif (kbd->kbdmode != VC_UNICODE) {\n\t\tif (!up_flag)\n\t\t\tpr_warn(\"keyboard mode must be unicode for braille patterns\\n\");\n\t\treturn;\n\t}\n\n\tif (!value) {\n\t\tk_unicode(vc, BRL_UC_ROW, up_flag);\n\t\treturn;\n\t}\n\n\tif (value > 8)\n\t\treturn;\n\n\tif (!up_flag) {\n\t\tpressed |= BIT(value - 1);\n\t\tif (!brl_timeout)\n\t\t\tcommitting = pressed;\n\t} else if (brl_timeout) {\n\t\tif (!committing ||\n\t\t    time_after(jiffies,\n\t\t\t       releasestart + msecs_to_jiffies(brl_timeout))) {\n\t\t\tcommitting = pressed;\n\t\t\treleasestart = jiffies;\n\t\t}\n\t\tpressed &= ~BIT(value - 1);\n\t\tif (!pressed && committing) {\n\t\t\tk_brlcommit(vc, committing, 0);\n\t\t\tcommitting = 0;\n\t\t}\n\t} else {\n\t\tif (committing) {\n\t\t\tk_brlcommit(vc, committing, 0);\n\t\t\tcommitting = 0;\n\t\t}\n\t\tpressed &= ~BIT(value - 1);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_INPUT_LEDS) && IS_ENABLED(CONFIG_LEDS_TRIGGERS)\n\nstruct kbd_led_trigger {\n\tstruct led_trigger trigger;\n\tunsigned int mask;\n};\n\nstatic int kbd_led_trigger_activate(struct led_classdev *cdev)\n{\n\tstruct kbd_led_trigger *trigger =\n\t\tcontainer_of(cdev->trigger, struct kbd_led_trigger, trigger);\n\n\ttasklet_disable(&keyboard_tasklet);\n\tif (ledstate != -1U)\n\t\tled_trigger_event(&trigger->trigger,\n\t\t\t\t  ledstate & trigger->mask ?\n\t\t\t\t\tLED_FULL : LED_OFF);\n\ttasklet_enable(&keyboard_tasklet);\n\n\treturn 0;\n}\n\n#define KBD_LED_TRIGGER(_led_bit, _name) {\t\t\t\\\n\t\t.trigger = {\t\t\t\t\t\\\n\t\t\t.name = _name,\t\t\t\t\\\n\t\t\t.activate = kbd_led_trigger_activate,\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.mask\t= BIT(_led_bit),\t\t\t\\\n\t}\n\n#define KBD_LOCKSTATE_TRIGGER(_led_bit, _name)\t\t\\\n\tKBD_LED_TRIGGER((_led_bit) + 8, _name)\n\nstatic struct kbd_led_trigger kbd_led_triggers[] = {\n\tKBD_LED_TRIGGER(VC_SCROLLOCK, \"kbd-scrolllock\"),\n\tKBD_LED_TRIGGER(VC_NUMLOCK,   \"kbd-numlock\"),\n\tKBD_LED_TRIGGER(VC_CAPSLOCK,  \"kbd-capslock\"),\n\tKBD_LED_TRIGGER(VC_KANALOCK,  \"kbd-kanalock\"),\n\n\tKBD_LOCKSTATE_TRIGGER(VC_SHIFTLOCK,  \"kbd-shiftlock\"),\n\tKBD_LOCKSTATE_TRIGGER(VC_ALTGRLOCK,  \"kbd-altgrlock\"),\n\tKBD_LOCKSTATE_TRIGGER(VC_CTRLLOCK,   \"kbd-ctrllock\"),\n\tKBD_LOCKSTATE_TRIGGER(VC_ALTLOCK,    \"kbd-altlock\"),\n\tKBD_LOCKSTATE_TRIGGER(VC_SHIFTLLOCK, \"kbd-shiftllock\"),\n\tKBD_LOCKSTATE_TRIGGER(VC_SHIFTRLOCK, \"kbd-shiftrlock\"),\n\tKBD_LOCKSTATE_TRIGGER(VC_CTRLLLOCK,  \"kbd-ctrlllock\"),\n\tKBD_LOCKSTATE_TRIGGER(VC_CTRLRLOCK,  \"kbd-ctrlrlock\"),\n};\n\nstatic void kbd_propagate_led_state(unsigned int old_state,\n\t\t\t\t    unsigned int new_state)\n{\n\tstruct kbd_led_trigger *trigger;\n\tunsigned int changed = old_state ^ new_state;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(kbd_led_triggers); i++) {\n\t\ttrigger = &kbd_led_triggers[i];\n\n\t\tif (changed & trigger->mask)\n\t\t\tled_trigger_event(&trigger->trigger,\n\t\t\t\t\t  new_state & trigger->mask ?\n\t\t\t\t\t\tLED_FULL : LED_OFF);\n\t}\n}\n\nstatic int kbd_update_leds_helper(struct input_handle *handle, void *data)\n{\n\tunsigned int led_state = *(unsigned int *)data;\n\n\tif (test_bit(EV_LED, handle->dev->evbit))\n\t\tkbd_propagate_led_state(~led_state, led_state);\n\n\treturn 0;\n}\n\nstatic void kbd_init_leds(void)\n{\n\tint error;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(kbd_led_triggers); i++) {\n\t\terror = led_trigger_register(&kbd_led_triggers[i].trigger);\n\t\tif (error)\n\t\t\tpr_err(\"error %d while registering trigger %s\\n\",\n\t\t\t       error, kbd_led_triggers[i].trigger.name);\n\t}\n}\n\n#else\n\nstatic int kbd_update_leds_helper(struct input_handle *handle, void *data)\n{\n\tunsigned int leds = *(unsigned int *)data;\n\n\tif (test_bit(EV_LED, handle->dev->evbit)) {\n\t\tinput_inject_event(handle, EV_LED, LED_SCROLLL, !!(leds & BIT(0)));\n\t\tinput_inject_event(handle, EV_LED, LED_NUML,    !!(leds & BIT(1)));\n\t\tinput_inject_event(handle, EV_LED, LED_CAPSL,   !!(leds & BIT(2)));\n\t\tinput_inject_event(handle, EV_SYN, SYN_REPORT, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic void kbd_propagate_led_state(unsigned int old_state,\n\t\t\t\t    unsigned int new_state)\n{\n\tinput_handler_for_each_handle(&kbd_handler, &new_state,\n\t\t\t\t      kbd_update_leds_helper);\n}\n\nstatic void kbd_init_leds(void)\n{\n}\n\n#endif\n\n \nstatic unsigned char getledstate(void)\n{\n\treturn ledstate & 0xff;\n}\n\nvoid setledstate(struct kbd_struct *kb, unsigned int led)\n{\n        unsigned long flags;\n        spin_lock_irqsave(&led_lock, flags);\n\tif (!(led & ~7)) {\n\t\tledioctl = led;\n\t\tkb->ledmode = LED_SHOW_IOCTL;\n\t} else\n\t\tkb->ledmode = LED_SHOW_FLAGS;\n\n\tset_leds();\n\tspin_unlock_irqrestore(&led_lock, flags);\n}\n\nstatic inline unsigned char getleds(void)\n{\n\tstruct kbd_struct *kb = kbd_table + fg_console;\n\n\tif (kb->ledmode == LED_SHOW_IOCTL)\n\t\treturn ledioctl;\n\n\treturn kb->ledflagstate;\n}\n\n \nint vt_get_leds(unsigned int console, int flag)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&led_lock, flags);\n\tret = vc_kbd_led(kb, flag);\n\tspin_unlock_irqrestore(&led_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vt_get_leds);\n\n \nvoid vt_set_led_state(unsigned int console, int leds)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\tsetledstate(kb, leds);\n}\n\n \nvoid vt_kbd_con_start(unsigned int console)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\tunsigned long flags;\n\tspin_lock_irqsave(&led_lock, flags);\n\tclr_vc_kbd_led(kb, VC_SCROLLOCK);\n\tset_leds();\n\tspin_unlock_irqrestore(&led_lock, flags);\n}\n\n \nvoid vt_kbd_con_stop(unsigned int console)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\tunsigned long flags;\n\tspin_lock_irqsave(&led_lock, flags);\n\tset_vc_kbd_led(kb, VC_SCROLLOCK);\n\tset_leds();\n\tspin_unlock_irqrestore(&led_lock, flags);\n}\n\n \nstatic void kbd_bh(struct tasklet_struct *unused)\n{\n\tunsigned int leds;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&led_lock, flags);\n\tleds = getleds();\n\tleds |= (unsigned int)kbd->lockstate << 8;\n\tspin_unlock_irqrestore(&led_lock, flags);\n\n\tif (vt_switch) {\n\t\tledstate = ~leds;\n\t\tvt_switch = false;\n\t}\n\n\tif (leds != ledstate) {\n\t\tkbd_propagate_led_state(ledstate, leds);\n\t\tledstate = leds;\n\t}\n}\n\n#if defined(CONFIG_X86) || defined(CONFIG_IA64) || defined(CONFIG_ALPHA) ||\\\n    defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(CONFIG_SPARC) ||\\\n    defined(CONFIG_PARISC) || defined(CONFIG_SUPERH) ||\\\n    (defined(CONFIG_ARM) && defined(CONFIG_KEYBOARD_ATKBD) && !defined(CONFIG_ARCH_RPC))\n\nstatic inline bool kbd_is_hw_raw(const struct input_dev *dev)\n{\n\tif (!test_bit(EV_MSC, dev->evbit) || !test_bit(MSC_RAW, dev->mscbit))\n\t\treturn false;\n\n\treturn dev->id.bustype == BUS_I8042 &&\n\t\tdev->id.vendor == 0x0001 && dev->id.product == 0x0001;\n}\n\nstatic const unsigned short x86_keycodes[256] =\n\t{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n\t 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n\t 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n\t 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n\t 80, 81, 82, 83, 84,118, 86, 87, 88,115,120,119,121,112,123, 92,\n\t284,285,309,  0,312, 91,327,328,329,331,333,335,336,337,338,339,\n\t367,288,302,304,350, 89,334,326,267,126,268,269,125,347,348,349,\n\t360,261,262,263,268,376,100,101,321,316,373,286,289,102,351,355,\n\t103,104,105,275,287,279,258,106,274,107,294,364,358,363,362,361,\n\t291,108,381,281,290,272,292,305,280, 99,112,257,306,359,113,114,\n\t264,117,271,374,379,265,266, 93, 94, 95, 85,259,375,260, 90,116,\n\t377,109,111,277,278,282,283,295,296,297,299,300,301,293,303,307,\n\t308,310,313,314,315,317,318,319,320,357,322,323,324,325,276,330,\n\t332,340,365,342,343,344,345,346,356,270,341,368,369,370,371,372 };\n\n#ifdef CONFIG_SPARC\nstatic int sparc_l1_a_state;\nextern void sun_do_break(void);\n#endif\n\nstatic int emulate_raw(struct vc_data *vc, unsigned int keycode,\n\t\t       unsigned char up_flag)\n{\n\tint code;\n\n\tswitch (keycode) {\n\n\tcase KEY_PAUSE:\n\t\tput_queue(vc, 0xe1);\n\t\tput_queue(vc, 0x1d | up_flag);\n\t\tput_queue(vc, 0x45 | up_flag);\n\t\tbreak;\n\n\tcase KEY_HANGEUL:\n\t\tif (!up_flag)\n\t\t\tput_queue(vc, 0xf2);\n\t\tbreak;\n\n\tcase KEY_HANJA:\n\t\tif (!up_flag)\n\t\t\tput_queue(vc, 0xf1);\n\t\tbreak;\n\n\tcase KEY_SYSRQ:\n\t\t \n\t\tif (test_bit(KEY_LEFTALT, key_down) ||\n\t\t    test_bit(KEY_RIGHTALT, key_down)) {\n\t\t\tput_queue(vc, 0x54 | up_flag);\n\t\t} else {\n\t\t\tput_queue(vc, 0xe0);\n\t\t\tput_queue(vc, 0x2a | up_flag);\n\t\t\tput_queue(vc, 0xe0);\n\t\t\tput_queue(vc, 0x37 | up_flag);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (keycode > 255)\n\t\t\treturn -1;\n\n\t\tcode = x86_keycodes[keycode];\n\t\tif (!code)\n\t\t\treturn -1;\n\n\t\tif (code & 0x100)\n\t\t\tput_queue(vc, 0xe0);\n\t\tput_queue(vc, (code & 0x7f) | up_flag);\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#else\n\nstatic inline bool kbd_is_hw_raw(const struct input_dev *dev)\n{\n\treturn false;\n}\n\nstatic int emulate_raw(struct vc_data *vc, unsigned int keycode, unsigned char up_flag)\n{\n\tif (keycode > 127)\n\t\treturn -1;\n\n\tput_queue(vc, keycode | up_flag);\n\treturn 0;\n}\n#endif\n\nstatic void kbd_rawcode(unsigned char data)\n{\n\tstruct vc_data *vc = vc_cons[fg_console].d;\n\n\tkbd = &kbd_table[vc->vc_num];\n\tif (kbd->kbdmode == VC_RAW)\n\t\tput_queue(vc, data);\n}\n\nstatic void kbd_keycode(unsigned int keycode, int down, bool hw_raw)\n{\n\tstruct vc_data *vc = vc_cons[fg_console].d;\n\tunsigned short keysym, *key_map;\n\tunsigned char type;\n\tbool raw_mode;\n\tstruct tty_struct *tty;\n\tint shift_final;\n\tstruct keyboard_notifier_param param = { .vc = vc, .value = keycode, .down = down };\n\tint rc;\n\n\ttty = vc->port.tty;\n\n\tif (tty && (!tty->driver_data)) {\n\t\t \n\t\ttty->driver_data = vc;\n\t}\n\n\tkbd = &kbd_table[vc->vc_num];\n\n#ifdef CONFIG_SPARC\n\tif (keycode == KEY_STOP)\n\t\tsparc_l1_a_state = down;\n#endif\n\n\trep = (down == 2);\n\n\traw_mode = (kbd->kbdmode == VC_RAW);\n\tif (raw_mode && !hw_raw)\n\t\tif (emulate_raw(vc, keycode, !down << 7))\n\t\t\tif (keycode < BTN_MISC && printk_ratelimit())\n\t\t\t\tpr_warn(\"can't emulate rawmode for keycode %d\\n\",\n\t\t\t\t\tkeycode);\n\n#ifdef CONFIG_SPARC\n\tif (keycode == KEY_A && sparc_l1_a_state) {\n\t\tsparc_l1_a_state = false;\n\t\tsun_do_break();\n\t}\n#endif\n\n\tif (kbd->kbdmode == VC_MEDIUMRAW) {\n\t\t \n\t\tif (keycode < 128) {\n\t\t\tput_queue(vc, keycode | (!down << 7));\n\t\t} else {\n\t\t\tput_queue(vc, !down << 7);\n\t\t\tput_queue(vc, (keycode >> 7) | BIT(7));\n\t\t\tput_queue(vc, keycode | BIT(7));\n\t\t}\n\t\traw_mode = true;\n\t}\n\n\tassign_bit(keycode, key_down, down);\n\n\tif (rep &&\n\t    (!vc_kbd_mode(kbd, VC_REPEAT) ||\n\t     (tty && !L_ECHO(tty) && tty_chars_in_buffer(tty)))) {\n\t\t \n\t\treturn;\n\t}\n\n\tparam.shift = shift_final = (shift_state | kbd->slockstate) ^ kbd->lockstate;\n\tparam.ledstate = kbd->ledflagstate;\n\tkey_map = key_maps[shift_final];\n\n\trc = atomic_notifier_call_chain(&keyboard_notifier_list,\n\t\t\t\t\tKBD_KEYCODE, &param);\n\tif (rc == NOTIFY_STOP || !key_map) {\n\t\tatomic_notifier_call_chain(&keyboard_notifier_list,\n\t\t\t\t\t   KBD_UNBOUND_KEYCODE, &param);\n\t\tdo_compute_shiftstate();\n\t\tkbd->slockstate = 0;\n\t\treturn;\n\t}\n\n\tif (keycode < NR_KEYS)\n\t\tkeysym = key_map[keycode];\n\telse if (keycode >= KEY_BRL_DOT1 && keycode <= KEY_BRL_DOT8)\n\t\tkeysym = U(K(KT_BRL, keycode - KEY_BRL_DOT1 + 1));\n\telse\n\t\treturn;\n\n\ttype = KTYP(keysym);\n\n\tif (type < 0xf0) {\n\t\tparam.value = keysym;\n\t\trc = atomic_notifier_call_chain(&keyboard_notifier_list,\n\t\t\t\t\t\tKBD_UNICODE, &param);\n\t\tif (rc != NOTIFY_STOP)\n\t\t\tif (down && !raw_mode)\n\t\t\t\tk_unicode(vc, keysym, !down);\n\t\treturn;\n\t}\n\n\ttype -= 0xf0;\n\n\tif (type == KT_LETTER) {\n\t\ttype = KT_LATIN;\n\t\tif (vc_kbd_led(kbd, VC_CAPSLOCK)) {\n\t\t\tkey_map = key_maps[shift_final ^ BIT(KG_SHIFT)];\n\t\t\tif (key_map)\n\t\t\t\tkeysym = key_map[keycode];\n\t\t}\n\t}\n\n\tparam.value = keysym;\n\trc = atomic_notifier_call_chain(&keyboard_notifier_list,\n\t\t\t\t\tKBD_KEYSYM, &param);\n\tif (rc == NOTIFY_STOP)\n\t\treturn;\n\n\tif ((raw_mode || kbd->kbdmode == VC_OFF) && type != KT_SPEC && type != KT_SHIFT)\n\t\treturn;\n\n\t(*k_handler[type])(vc, keysym & 0xff, !down);\n\n\tparam.ledstate = kbd->ledflagstate;\n\tatomic_notifier_call_chain(&keyboard_notifier_list, KBD_POST_KEYSYM, &param);\n\n\tif (type != KT_SLOCK)\n\t\tkbd->slockstate = 0;\n}\n\nstatic void kbd_event(struct input_handle *handle, unsigned int event_type,\n\t\t      unsigned int event_code, int value)\n{\n\t \n\tspin_lock(&kbd_event_lock);\n\n\tif (event_type == EV_MSC && event_code == MSC_RAW &&\n\t\t\tkbd_is_hw_raw(handle->dev))\n\t\tkbd_rawcode(value);\n\tif (event_type == EV_KEY && event_code <= KEY_MAX)\n\t\tkbd_keycode(event_code, value, kbd_is_hw_raw(handle->dev));\n\n\tspin_unlock(&kbd_event_lock);\n\n\ttasklet_schedule(&keyboard_tasklet);\n\tdo_poke_blanked_console = 1;\n\tschedule_console_callback();\n}\n\nstatic bool kbd_match(struct input_handler *handler, struct input_dev *dev)\n{\n\tif (test_bit(EV_SND, dev->evbit))\n\t\treturn true;\n\n\tif (test_bit(EV_KEY, dev->evbit)) {\n\t\tif (find_next_bit(dev->keybit, BTN_MISC, KEY_RESERVED) <\n\t\t\t\tBTN_MISC)\n\t\t\treturn true;\n\t\tif (find_next_bit(dev->keybit, KEY_BRL_DOT10 + 1,\n\t\t\t\t\tKEY_BRL_DOT1) <= KEY_BRL_DOT10)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic int kbd_connect(struct input_handler *handler, struct input_dev *dev,\n\t\t\tconst struct input_device_id *id)\n{\n\tstruct input_handle *handle;\n\tint error;\n\n\thandle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);\n\tif (!handle)\n\t\treturn -ENOMEM;\n\n\thandle->dev = dev;\n\thandle->handler = handler;\n\thandle->name = \"kbd\";\n\n\terror = input_register_handle(handle);\n\tif (error)\n\t\tgoto err_free_handle;\n\n\terror = input_open_device(handle);\n\tif (error)\n\t\tgoto err_unregister_handle;\n\n\treturn 0;\n\n err_unregister_handle:\n\tinput_unregister_handle(handle);\n err_free_handle:\n\tkfree(handle);\n\treturn error;\n}\n\nstatic void kbd_disconnect(struct input_handle *handle)\n{\n\tinput_close_device(handle);\n\tinput_unregister_handle(handle);\n\tkfree(handle);\n}\n\n \nstatic void kbd_start(struct input_handle *handle)\n{\n\ttasklet_disable(&keyboard_tasklet);\n\n\tif (ledstate != -1U)\n\t\tkbd_update_leds_helper(handle, &ledstate);\n\n\ttasklet_enable(&keyboard_tasklet);\n}\n\nstatic const struct input_device_id kbd_ids[] = {\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t},\n\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT,\n\t\t.evbit = { BIT_MASK(EV_SND) },\n\t},\n\n\t{ },     \n};\n\nMODULE_DEVICE_TABLE(input, kbd_ids);\n\nstatic struct input_handler kbd_handler = {\n\t.event\t\t= kbd_event,\n\t.match\t\t= kbd_match,\n\t.connect\t= kbd_connect,\n\t.disconnect\t= kbd_disconnect,\n\t.start\t\t= kbd_start,\n\t.name\t\t= \"kbd\",\n\t.id_table\t= kbd_ids,\n};\n\nint __init kbd_init(void)\n{\n\tint i;\n\tint error;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tkbd_table[i].ledflagstate = kbd_defleds();\n\t\tkbd_table[i].default_ledflagstate = kbd_defleds();\n\t\tkbd_table[i].ledmode = LED_SHOW_FLAGS;\n\t\tkbd_table[i].lockstate = KBD_DEFLOCK;\n\t\tkbd_table[i].slockstate = 0;\n\t\tkbd_table[i].modeflags = KBD_DEFMODE;\n\t\tkbd_table[i].kbdmode = default_utf8 ? VC_UNICODE : VC_XLATE;\n\t}\n\n\tkbd_init_leds();\n\n\terror = input_register_handler(&kbd_handler);\n\tif (error)\n\t\treturn error;\n\n\ttasklet_enable(&keyboard_tasklet);\n\ttasklet_schedule(&keyboard_tasklet);\n\n\treturn 0;\n}\n\n \n\n \nint vt_do_diacrit(unsigned int cmd, void __user *udp, int perm)\n{\n\tunsigned long flags;\n\tint asize;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase KDGKBDIACR:\n\t{\n\t\tstruct kbdiacrs __user *a = udp;\n\t\tstruct kbdiacr *dia;\n\t\tint i;\n\n\t\tdia = kmalloc_array(MAX_DIACR, sizeof(struct kbdiacr),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!dia)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tspin_lock_irqsave(&kbd_event_lock, flags);\n\n\t\tasize = accent_table_size;\n\t\tfor (i = 0; i < asize; i++) {\n\t\t\tdia[i].diacr = conv_uni_to_8bit(\n\t\t\t\t\t\taccent_table[i].diacr);\n\t\t\tdia[i].base = conv_uni_to_8bit(\n\t\t\t\t\t\taccent_table[i].base);\n\t\t\tdia[i].result = conv_uni_to_8bit(\n\t\t\t\t\t\taccent_table[i].result);\n\t\t}\n\t\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\n\t\tif (put_user(asize, &a->kb_cnt))\n\t\t\tret = -EFAULT;\n\t\telse  if (copy_to_user(a->kbdiacr, dia,\n\t\t\t\tasize * sizeof(struct kbdiacr)))\n\t\t\tret = -EFAULT;\n\t\tkfree(dia);\n\t\treturn ret;\n\t}\n\tcase KDGKBDIACRUC:\n\t{\n\t\tstruct kbdiacrsuc __user *a = udp;\n\t\tvoid *buf;\n\n\t\tbuf = kmalloc_array(MAX_DIACR, sizeof(struct kbdiacruc),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tspin_lock_irqsave(&kbd_event_lock, flags);\n\n\t\tasize = accent_table_size;\n\t\tmemcpy(buf, accent_table, asize * sizeof(struct kbdiacruc));\n\n\t\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\n\t\tif (put_user(asize, &a->kb_cnt))\n\t\t\tret = -EFAULT;\n\t\telse if (copy_to_user(a->kbdiacruc, buf,\n\t\t\t\tasize*sizeof(struct kbdiacruc)))\n\t\t\tret = -EFAULT;\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tcase KDSKBDIACR:\n\t{\n\t\tstruct kbdiacrs __user *a = udp;\n\t\tstruct kbdiacr *dia = NULL;\n\t\tunsigned int ct;\n\t\tint i;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (get_user(ct, &a->kb_cnt))\n\t\t\treturn -EFAULT;\n\t\tif (ct >= MAX_DIACR)\n\t\t\treturn -EINVAL;\n\n\t\tif (ct) {\n\n\t\t\tdia = memdup_user(a->kbdiacr,\n\t\t\t\t\tsizeof(struct kbdiacr) * ct);\n\t\t\tif (IS_ERR(dia))\n\t\t\t\treturn PTR_ERR(dia);\n\n\t\t}\n\n\t\tspin_lock_irqsave(&kbd_event_lock, flags);\n\t\taccent_table_size = ct;\n\t\tfor (i = 0; i < ct; i++) {\n\t\t\taccent_table[i].diacr =\n\t\t\t\t\tconv_8bit_to_uni(dia[i].diacr);\n\t\t\taccent_table[i].base =\n\t\t\t\t\tconv_8bit_to_uni(dia[i].base);\n\t\t\taccent_table[i].result =\n\t\t\t\t\tconv_8bit_to_uni(dia[i].result);\n\t\t}\n\t\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\t\tkfree(dia);\n\t\treturn 0;\n\t}\n\n\tcase KDSKBDIACRUC:\n\t{\n\t\tstruct kbdiacrsuc __user *a = udp;\n\t\tunsigned int ct;\n\t\tvoid *buf = NULL;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(ct, &a->kb_cnt))\n\t\t\treturn -EFAULT;\n\n\t\tif (ct >= MAX_DIACR)\n\t\t\treturn -EINVAL;\n\n\t\tif (ct) {\n\t\t\tbuf = memdup_user(a->kbdiacruc,\n\t\t\t\t\t  ct * sizeof(struct kbdiacruc));\n\t\t\tif (IS_ERR(buf))\n\t\t\t\treturn PTR_ERR(buf);\n\t\t} \n\t\tspin_lock_irqsave(&kbd_event_lock, flags);\n\t\tif (ct)\n\t\t\tmemcpy(accent_table, buf,\n\t\t\t\t\tct * sizeof(struct kbdiacruc));\n\t\taccent_table_size = ct;\n\t\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\t\tkfree(buf);\n\t\treturn 0;\n\t}\n\t}\n\treturn ret;\n}\n\n \nint vt_do_kdskbmode(unsigned int console, unsigned int arg)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kbd_event_lock, flags);\n\tswitch(arg) {\n\tcase K_RAW:\n\t\tkb->kbdmode = VC_RAW;\n\t\tbreak;\n\tcase K_MEDIUMRAW:\n\t\tkb->kbdmode = VC_MEDIUMRAW;\n\t\tbreak;\n\tcase K_XLATE:\n\t\tkb->kbdmode = VC_XLATE;\n\t\tdo_compute_shiftstate();\n\t\tbreak;\n\tcase K_UNICODE:\n\t\tkb->kbdmode = VC_UNICODE;\n\t\tdo_compute_shiftstate();\n\t\tbreak;\n\tcase K_OFF:\n\t\tkb->kbdmode = VC_OFF;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\treturn ret;\n}\n\n \nint vt_do_kdskbmeta(unsigned int console, unsigned int arg)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kbd_event_lock, flags);\n\tswitch(arg) {\n\tcase K_METABIT:\n\t\tclr_vc_kbd_mode(kb, VC_META);\n\t\tbreak;\n\tcase K_ESCPREFIX:\n\t\tset_vc_kbd_mode(kb, VC_META);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\treturn ret;\n}\n\nint vt_do_kbkeycode_ioctl(int cmd, struct kbkeycode __user *user_kbkc,\n\t\t\t\t\t\t\t\tint perm)\n{\n\tstruct kbkeycode tmp;\n\tint kc = 0;\n\n\tif (copy_from_user(&tmp, user_kbkc, sizeof(struct kbkeycode)))\n\t\treturn -EFAULT;\n\tswitch (cmd) {\n\tcase KDGETKEYCODE:\n\t\tkc = getkeycode(tmp.scancode);\n\t\tif (kc >= 0)\n\t\t\tkc = put_user(kc, &user_kbkc->keycode);\n\t\tbreak;\n\tcase KDSETKEYCODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tkc = setkeycode(tmp.scancode, tmp.keycode);\n\t\tbreak;\n\t}\n\treturn kc;\n}\n\nstatic unsigned short vt_kdgkbent(unsigned char kbdmode, unsigned char idx,\n\t\tunsigned char map)\n{\n\tunsigned short *key_map, val;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&kbd_event_lock, flags);\n\tkey_map = key_maps[map];\n\tif (key_map) {\n\t\tval = U(key_map[idx]);\n\t\tif (kbdmode != VC_UNICODE && KTYP(val) >= NR_TYPES)\n\t\t\tval = K_HOLE;\n\t} else\n\t\tval = idx ? K_HOLE : K_NOSUCHMAP;\n\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\n\treturn val;\n}\n\nstatic int vt_kdskbent(unsigned char kbdmode, unsigned char idx,\n\t\tunsigned char map, unsigned short val)\n{\n\tunsigned long flags;\n\tunsigned short *key_map, *new_map, oldval;\n\n\tif (!idx && val == K_NOSUCHMAP) {\n\t\tspin_lock_irqsave(&kbd_event_lock, flags);\n\t\t \n\t\tkey_map = key_maps[map];\n\t\tif (map && key_map) {\n\t\t\tkey_maps[map] = NULL;\n\t\t\tif (key_map[0] == U(K_ALLOCATED)) {\n\t\t\t\tkfree(key_map);\n\t\t\t\tkeymap_count--;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\n\t\treturn 0;\n\t}\n\n\tif (KTYP(val) < NR_TYPES) {\n\t\tif (KVAL(val) > max_vals[KTYP(val)])\n\t\t\treturn -EINVAL;\n\t} else if (kbdmode != VC_UNICODE)\n\t\treturn -EINVAL;\n\n\t \n#if !defined(__mc68000__) && !defined(__powerpc__)\n\t \n\tif (!idx)\n\t\treturn 0;\n#endif\n\n\tnew_map = kmalloc(sizeof(plain_map), GFP_KERNEL);\n\tif (!new_map)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&kbd_event_lock, flags);\n\tkey_map = key_maps[map];\n\tif (key_map == NULL) {\n\t\tint j;\n\n\t\tif (keymap_count >= MAX_NR_OF_USER_KEYMAPS &&\n\t\t    !capable(CAP_SYS_RESOURCE)) {\n\t\t\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\t\t\tkfree(new_map);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tkey_maps[map] = new_map;\n\t\tkey_map = new_map;\n\t\tkey_map[0] = U(K_ALLOCATED);\n\t\tfor (j = 1; j < NR_KEYS; j++)\n\t\t\tkey_map[j] = U(K_HOLE);\n\t\tkeymap_count++;\n\t} else\n\t\tkfree(new_map);\n\n\toldval = U(key_map[idx]);\n\tif (val == oldval)\n\t\tgoto out;\n\n\t \n\tif ((oldval == K_SAK || val == K_SAK) && !capable(CAP_SYS_ADMIN)) {\n\t\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\t\treturn -EPERM;\n\t}\n\n\tkey_map[idx] = U(val);\n\tif (!map && (KTYP(oldval) == KT_SHIFT || KTYP(val) == KT_SHIFT))\n\t\tdo_compute_shiftstate();\nout:\n\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\n\treturn 0;\n}\n\nint vt_do_kdsk_ioctl(int cmd, struct kbentry __user *user_kbe, int perm,\n\t\t\t\t\t\tunsigned int console)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\tstruct kbentry kbe;\n\n\tif (copy_from_user(&kbe, user_kbe, sizeof(struct kbentry)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase KDGKBENT:\n\t\treturn put_user(vt_kdgkbent(kb->kbdmode, kbe.kb_index,\n\t\t\t\t\tkbe.kb_table),\n\t\t\t\t&user_kbe->kb_value);\n\tcase KDSKBENT:\n\t\tif (!perm || !capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\t\treturn vt_kdskbent(kb->kbdmode, kbe.kb_index, kbe.kb_table,\n\t\t\t\tkbe.kb_value);\n\t}\n\treturn 0;\n}\n\nstatic char *vt_kdskbsent(char *kbs, unsigned char cur)\n{\n\tstatic DECLARE_BITMAP(is_kmalloc, MAX_NR_FUNC);\n\tchar *cur_f = func_table[cur];\n\n\tif (cur_f && strlen(cur_f) >= strlen(kbs)) {\n\t\tstrcpy(cur_f, kbs);\n\t\treturn kbs;\n\t}\n\n\tfunc_table[cur] = kbs;\n\n\treturn __test_and_set_bit(cur, is_kmalloc) ? cur_f : NULL;\n}\n\nint vt_do_kdgkb_ioctl(int cmd, struct kbsentry __user *user_kdgkb, int perm)\n{\n\tunsigned char kb_func;\n\tunsigned long flags;\n\tchar *kbs;\n\tint ret;\n\n\tif (get_user(kb_func, &user_kdgkb->kb_func))\n\t\treturn -EFAULT;\n\n\tkb_func = array_index_nospec(kb_func, MAX_NR_FUNC);\n\n\tswitch (cmd) {\n\tcase KDGKBSENT: {\n\t\t \n\t\tssize_t len = sizeof(user_kdgkb->kb_string);\n\n\t\tkbs = kmalloc(len, GFP_KERNEL);\n\t\tif (!kbs)\n\t\t\treturn -ENOMEM;\n\n\t\tspin_lock_irqsave(&func_buf_lock, flags);\n\t\tlen = strlcpy(kbs, func_table[kb_func] ? : \"\", len);\n\t\tspin_unlock_irqrestore(&func_buf_lock, flags);\n\n\t\tret = copy_to_user(user_kdgkb->kb_string, kbs, len + 1) ?\n\t\t\t-EFAULT : 0;\n\n\t\tbreak;\n\t}\n\tcase KDSKBSENT:\n\t\tif (!perm || !capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\n\t\tkbs = strndup_user(user_kdgkb->kb_string,\n\t\t\t\tsizeof(user_kdgkb->kb_string));\n\t\tif (IS_ERR(kbs))\n\t\t\treturn PTR_ERR(kbs);\n\n\t\tspin_lock_irqsave(&func_buf_lock, flags);\n\t\tkbs = vt_kdskbsent(kbs, kb_func);\n\t\tspin_unlock_irqrestore(&func_buf_lock, flags);\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\tkfree(kbs);\n\n\treturn ret;\n}\n\nint vt_do_kdskled(unsigned int console, int cmd, unsigned long arg, int perm)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n        unsigned long flags;\n\tunsigned char ucval;\n\n        switch(cmd) {\n\t \n\t \n\tcase KDGKBLED:\n                spin_lock_irqsave(&kbd_event_lock, flags);\n\t\tucval = kb->ledflagstate | (kb->default_ledflagstate << 4);\n                spin_unlock_irqrestore(&kbd_event_lock, flags);\n\t\treturn put_user(ucval, (char __user *)arg);\n\n\tcase KDSKBLED:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (arg & ~0x77)\n\t\t\treturn -EINVAL;\n                spin_lock_irqsave(&led_lock, flags);\n\t\tkb->ledflagstate = (arg & 7);\n\t\tkb->default_ledflagstate = ((arg >> 4) & 7);\n\t\tset_leds();\n                spin_unlock_irqrestore(&led_lock, flags);\n\t\treturn 0;\n\n\t \n\t \n\tcase KDGETLED:\n\t\tucval = getledstate();\n\t\treturn put_user(ucval, (char __user *)arg);\n\n\tcase KDSETLED:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tsetledstate(kb, arg);\n\t\treturn 0;\n        }\n        return -ENOIOCTLCMD;\n}\n\nint vt_do_kdgkbmode(unsigned int console)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\t \n\tswitch (kb->kbdmode) {\n\tcase VC_RAW:\n\t\treturn K_RAW;\n\tcase VC_MEDIUMRAW:\n\t\treturn K_MEDIUMRAW;\n\tcase VC_UNICODE:\n\t\treturn K_UNICODE;\n\tcase VC_OFF:\n\t\treturn K_OFF;\n\tdefault:\n\t\treturn K_XLATE;\n\t}\n}\n\n \nint vt_do_kdgkbmeta(unsigned int console)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n         \n\treturn vc_kbd_mode(kb, VC_META) ? K_ESCPREFIX : K_METABIT;\n}\n\n \nvoid vt_reset_unicode(unsigned int console)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kbd_event_lock, flags);\n\tkbd_table[console].kbdmode = default_utf8 ? VC_UNICODE : VC_XLATE;\n\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n}\n\n \nint vt_get_shift_state(void)\n{\n         \n        return shift_state;\n}\n\n \nvoid vt_reset_keyboard(unsigned int console)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kbd_event_lock, flags);\n\tset_vc_kbd_mode(kb, VC_REPEAT);\n\tclr_vc_kbd_mode(kb, VC_CKMODE);\n\tclr_vc_kbd_mode(kb, VC_APPLIC);\n\tclr_vc_kbd_mode(kb, VC_CRLF);\n\tkb->lockstate = 0;\n\tkb->slockstate = 0;\n\tspin_lock(&led_lock);\n\tkb->ledmode = LED_SHOW_FLAGS;\n\tkb->ledflagstate = kb->default_ledflagstate;\n\tspin_unlock(&led_lock);\n\t \n\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n}\n\n \n\nint vt_get_kbd_mode_bit(unsigned int console, int bit)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\treturn vc_kbd_mode(kb, bit);\n}\n\n \n\nvoid vt_set_kbd_mode_bit(unsigned int console, int bit)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kbd_event_lock, flags);\n\tset_vc_kbd_mode(kb, bit);\n\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n}\n\n \n\nvoid vt_clr_kbd_mode_bit(unsigned int console, int bit)\n{\n\tstruct kbd_struct *kb = &kbd_table[console];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kbd_event_lock, flags);\n\tclr_vc_kbd_mode(kb, bit);\n\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}