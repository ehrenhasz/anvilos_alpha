{
  "module_name": "conmakehash.c",
  "hash_id": "2ea95e3050b7a9cd8b879646d2a902ee6cc4a545cb5b0b8b20a6815c856dd72a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/vt/conmakehash.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sysexits.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_FONTLEN 256\n\ntypedef unsigned short unicode;\n\nstatic void usage(char *argv0)\n{\n  fprintf(stderr, \"Usage: \\n\"\n         \"        %s chartable [hashsize] [hashstep] [maxhashlevel]\\n\", argv0);\n  exit(EX_USAGE);\n}\n\nstatic int getunicode(char **p0)\n{\n  char *p = *p0;\n\n  while (*p == ' ' || *p == '\\t')\n    p++;\n  if (*p != 'U' || p[1] != '+' ||\n      !isxdigit(p[2]) || !isxdigit(p[3]) || !isxdigit(p[4]) ||\n      !isxdigit(p[5]) || isxdigit(p[6]))\n    return -1;\n  *p0 = p+6;\n  return strtol(p+2,0,16);\n}\n\nunicode unitable[MAX_FONTLEN][255];\n\t\t\t\t \nint unicount[MAX_FONTLEN];\n\nstatic void addpair(int fp, int un)\n{\n  int i;\n\n  if ( un <= 0xfffe )\n    {\n       \n\n      for ( i = 0 ; i < unicount[fp] ; i++ )\n\tif ( unitable[fp][i] == un )\n\t  return;\n\n       \n\n      if ( unicount[fp] > 254 )\n\t{\n\t  fprintf(stderr, \"ERROR: Only 255 unicodes/glyph permitted!\\n\");\n\t  exit(EX_DATAERR);\n\t}\n\n      unitable[fp][unicount[fp]] = un;\n      unicount[fp]++;\n    }\n\n   \n}\n\nint main(int argc, char *argv[])\n{\n  FILE *ctbl;\n  char *tblname;\n  char buffer[65536];\n  int fontlen;\n  int i, nuni, nent;\n  int fp0, fp1, un0, un1;\n  char *p, *p1;\n\n  if ( argc < 2 || argc > 5 )\n    usage(argv[0]);\n\n  if ( !strcmp(argv[1],\"-\") )\n    {\n      ctbl = stdin;\n      tblname = \"stdin\";\n    }\n  else\n    {\n      ctbl = fopen(tblname = argv[1], \"r\");\n      if ( !ctbl )\n\t{\n\t  perror(tblname);\n\t  exit(EX_NOINPUT);\n\t}\n    }\n\n   \n  fontlen = 256;\n\n   \n\n  for ( i = 0 ; i < fontlen ; i++ )\n    unicount[i] = 0;\n\n   \n\n  while ( fgets(buffer, sizeof(buffer), ctbl) != NULL )\n    {\n      if ( (p = strchr(buffer, '\\n')) != NULL )\n\t*p = '\\0';\n      else\n\tfprintf(stderr, \"%s: Warning: line too long\\n\", tblname);\n\n      p = buffer;\n\n \n\n      while (*p == ' ' || *p == '\\t')\n\tp++;\n      if (!*p || *p == '#')\n\tcontinue;\t \n\n      fp0 = strtol(p, &p1, 0);\n      if (p1 == p)\n\t{\n\t  fprintf(stderr, \"Bad input line: %s\\n\", buffer);\n\t  exit(EX_DATAERR);\n        }\n      p = p1;\n\n      while (*p == ' ' || *p == '\\t')\n\tp++;\n      if (*p == '-')\n\t{\n\t  p++;\n\t  fp1 = strtol(p, &p1, 0);\n\t  if (p1 == p)\n\t    {\n\t      fprintf(stderr, \"Bad input line: %s\\n\", buffer);\n\t      exit(EX_DATAERR);\n\t    }\n\t  p = p1;\n        }\n      else\n\tfp1 = 0;\n\n      if ( fp0 < 0 || fp0 >= fontlen )\n\t{\n\t    fprintf(stderr,\n\t\t    \"%s: Glyph number (0x%x) larger than font length\\n\",\n\t\t    tblname, fp0);\n\t    exit(EX_DATAERR);\n\t}\n      if ( fp1 && (fp1 < fp0 || fp1 >= fontlen) )\n\t{\n\t    fprintf(stderr,\n\t\t    \"%s: Bad end of range (0x%x)\\n\",\n\t\t    tblname, fp1);\n\t    exit(EX_DATAERR);\n\t}\n\n      if (fp1)\n\t{\n\t   \n\t  while (*p == ' ' || *p == '\\t')\n\t    p++;\n\t  if (!strncmp(p, \"idem\", 4))\n\t    {\n\t      for (i=fp0; i<=fp1; i++)\n\t\taddpair(i,i);\n\t      p += 4;\n\t    }\n\t  else\n\t    {\n\t      un0 = getunicode(&p);\n\t      while (*p == ' ' || *p == '\\t')\n\t\tp++;\n\t      if (*p != '-')\n\t\t{\n\t\t  fprintf(stderr,\n\"%s: Corresponding to a range of font positions, there should be a Unicode range\\n\",\n\t\t\t  tblname);\n\t\t  exit(EX_DATAERR);\n\t        }\n\t      p++;\n\t      un1 = getunicode(&p);\n\t      if (un0 < 0 || un1 < 0)\n\t\t{\n\t\t  fprintf(stderr,\n\"%s: Bad Unicode range corresponding to font position range 0x%x-0x%x\\n\",\n\t\t\t  tblname, fp0, fp1);\n\t\t  exit(EX_DATAERR);\n\t        }\n\t      if (un1 - un0 != fp1 - fp0)\n\t\t{\n\t\t  fprintf(stderr,\n\"%s: Unicode range U+%x-U+%x not of the same length as font position range 0x%x-0x%x\\n\",\n\t\t\t  tblname, un0, un1, fp0, fp1);\n\t\t  exit(EX_DATAERR);\n\t        }\n\t      for(i=fp0; i<=fp1; i++)\n\t\taddpair(i,un0-fp0+i);\n\t    }\n        }\n      else\n\t{\n\t     \n\n\t    while ( (un0 = getunicode(&p)) >= 0 )\n\t      addpair(fp0, un0);\n\t}\n      while (*p == ' ' || *p == '\\t')\n\tp++;\n      if (*p && *p != '#')\n\tfprintf(stderr, \"%s: trailing junk (%s) ignored\\n\", tblname, p);\n    }\n\n   \n\n  fclose(ctbl);\n\n\n   \n  nuni = 0;\n  for ( i = 0 ; i < fontlen ; i++ )\n    nuni += unicount[i];\n\n  printf(\"\\\n \\n\\\n\\n\\\n#include <linux/types.h>\\n\\\n\\n\\\nu8 dfont_unicount[%d] = \\n\\\n{\\n\\t\", argv[1], fontlen);\n\n  for ( i = 0 ; i < fontlen ; i++ )\n    {\n      printf(\"%3d\", unicount[i]);\n      if ( i == fontlen-1 )\n        printf(\"\\n};\\n\");\n      else if ( i % 8 == 7 )\n        printf(\",\\n\\t\");\n      else\n        printf(\", \");\n    }\n\n  printf(\"\\nu16 dfont_unitable[%d] = \\n{\\n\\t\", nuni);\n\n  fp0 = 0;\n  nent = 0;\n  for ( i = 0 ; i < nuni ; i++ )\n    {\n      while ( nent >= unicount[fp0] )\n\t{\n\t  fp0++;\n\t  nent = 0;\n\t}\n      printf(\"0x%04x\", unitable[fp0][nent++]);\n      if ( i == nuni-1 )\n         printf(\"\\n};\\n\");\n       else if ( i % 8 == 7 )\n         printf(\",\\n\\t\");\n       else\n         printf(\", \");\n    }\n\n  exit(EX_OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}