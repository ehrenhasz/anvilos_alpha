{
  "module_name": "vt_ioctl.c",
  "hash_id": "6eef0b4b044e017667a073d641c161c8493431e7d9a322d0196e0243dc69804a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/vt/vt_ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/sched/signal.h>\n#include <linux/tty.h>\n#include <linux/timer.h>\n#include <linux/kernel.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/kd.h>\n#include <linux/vt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/major.h>\n#include <linux/fs.h>\n#include <linux/console.h>\n#include <linux/consolemap.h>\n#include <linux/signal.h>\n#include <linux/suspend.h>\n#include <linux/timex.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <linux/nospec.h>\n\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/kbd_diacr.h>\n#include <linux/selection.h>\n\nbool vt_dont_switch;\n\nstatic inline bool vt_in_use(unsigned int i)\n{\n\tconst struct vc_data *vc = vc_cons[i].d;\n\n\t \n\tWARN_CONSOLE_UNLOCKED();\n\n\treturn vc && kref_read(&vc->port.kref) > 1;\n}\n\nstatic inline bool vt_busy(int i)\n{\n\tif (vt_in_use(i))\n\t\treturn true;\n\tif (i == fg_console)\n\t\treturn true;\n\tif (vc_is_sel(vc_cons[i].d))\n\t\treturn true;\n\n\treturn false;\n}\n\n \n\n#ifdef CONFIG_X86\n#include <asm/syscalls.h>\n#endif\n\nstatic void complete_change_console(struct vc_data *vc);\n\n \n\nstruct vt_event_wait {\n\tstruct list_head list;\n\tstruct vt_event event;\n\tint done;\n};\n\nstatic LIST_HEAD(vt_events);\nstatic DEFINE_SPINLOCK(vt_event_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(vt_event_waitqueue);\n\n \n\nvoid vt_event_post(unsigned int event, unsigned int old, unsigned int new)\n{\n\tstruct list_head *pos, *head;\n\tunsigned long flags;\n\tint wake = 0;\n\n\tspin_lock_irqsave(&vt_event_lock, flags);\n\thead = &vt_events;\n\n\tlist_for_each(pos, head) {\n\t\tstruct vt_event_wait *ve = list_entry(pos,\n\t\t\t\t\t\tstruct vt_event_wait, list);\n\t\tif (!(ve->event.event & event))\n\t\t\tcontinue;\n\t\tve->event.event = event;\n\t\t \n\t\tve->event.oldev = old + 1;\n\t\tve->event.newev = new + 1;\n\t\twake = 1;\n\t\tve->done = 1;\n\t}\n\tspin_unlock_irqrestore(&vt_event_lock, flags);\n\tif (wake)\n\t\twake_up_interruptible(&vt_event_waitqueue);\n}\n\nstatic void __vt_event_queue(struct vt_event_wait *vw)\n{\n\tunsigned long flags;\n\t \n\tINIT_LIST_HEAD(&vw->list);\n\tvw->done = 0;\n\t \n\tspin_lock_irqsave(&vt_event_lock, flags);\n\tlist_add(&vw->list, &vt_events);\n\tspin_unlock_irqrestore(&vt_event_lock, flags);\n}\n\nstatic void __vt_event_wait(struct vt_event_wait *vw)\n{\n\t \n\twait_event_interruptible(vt_event_waitqueue, vw->done);\n}\n\nstatic void __vt_event_dequeue(struct vt_event_wait *vw)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&vt_event_lock, flags);\n\tlist_del(&vw->list);\n\tspin_unlock_irqrestore(&vt_event_lock, flags);\n}\n\n \n\nstatic void vt_event_wait(struct vt_event_wait *vw)\n{\n\t__vt_event_queue(vw);\n\t__vt_event_wait(vw);\n\t__vt_event_dequeue(vw);\n}\n\n \n\nstatic int vt_event_wait_ioctl(struct vt_event __user *event)\n{\n\tstruct vt_event_wait vw;\n\n\tif (copy_from_user(&vw.event, event, sizeof(struct vt_event)))\n\t\treturn -EFAULT;\n\t \n\tif (vw.event.event & ~VT_MAX_EVENT)\n\t\treturn -EINVAL;\n\n\tvt_event_wait(&vw);\n\t \n\tif (vw.done) {\n\t\tif (copy_to_user(event, &vw.event, sizeof(struct vt_event)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -EINTR;\n}\n\n \n\nint vt_waitactive(int n)\n{\n\tstruct vt_event_wait vw;\n\tdo {\n\t\tvw.event.event = VT_EVENT_SWITCH;\n\t\t__vt_event_queue(&vw);\n\t\tif (n == fg_console + 1) {\n\t\t\t__vt_event_dequeue(&vw);\n\t\t\tbreak;\n\t\t}\n\t\t__vt_event_wait(&vw);\n\t\t__vt_event_dequeue(&vw);\n\t\tif (vw.done == 0)\n\t\t\treturn -EINTR;\n\t} while (vw.event.newev != n);\n\treturn 0;\n}\n\n \n#define GPFIRST 0x3b4\n#define GPLAST 0x3df\n#define GPNUM (GPLAST - GPFIRST + 1)\n\n \nstatic int vt_kdsetmode(struct vc_data *vc, unsigned long mode)\n{\n\tswitch (mode) {\n\tcase KD_GRAPHICS:\n\t\tbreak;\n\tcase KD_TEXT0:\n\tcase KD_TEXT1:\n\t\tmode = KD_TEXT;\n\t\tfallthrough;\n\tcase KD_TEXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (vc->vc_mode == mode)\n\t\treturn 0;\n\n\tvc->vc_mode = mode;\n\tif (vc->vc_num != fg_console)\n\t\treturn 0;\n\n\t \n\tif (mode == KD_TEXT)\n\t\tdo_unblank_screen(1);\n\telse\n\t\tdo_blank_screen(1);\n\n\treturn 0;\n}\n\nstatic int vt_k_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg, bool perm)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tvoid __user *up = (void __user *)arg;\n\tunsigned int console = vc->vc_num;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase KIOCSOUND:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\t \n\t\tif (arg)\n\t\t\targ = PIT_TICK_RATE / arg;\n\t\tkd_mksound(arg, 0);\n\t\tbreak;\n\n\tcase KDMKTONE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t{\n\t\tunsigned int ticks, count;\n\n\t\t \n\t\tticks = msecs_to_jiffies((arg >> 16) & 0xffff);\n\t\tcount = ticks ? (arg & 0xffff) : 0;\n\t\tif (count)\n\t\t\tcount = PIT_TICK_RATE / count;\n\t\tkd_mksound(count, ticks);\n\t\tbreak;\n\t}\n\n\tcase KDGKBTYPE:\n\t\t \n\t\treturn put_user(KB_101, (char __user *)arg);\n\n\t\t \n#ifdef CONFIG_X86\n\tcase KDADDIO:\n\tcase KDDELIO:\n\t\t \n\t\tif (arg < GPFIRST || arg > GPLAST)\n\t\t\treturn -EINVAL;\n\n\t\treturn ksys_ioperm(arg, 1, (cmd == KDADDIO)) ? -ENXIO : 0;\n\n\tcase KDENABIO:\n\tcase KDDISABIO:\n\t\treturn ksys_ioperm(GPFIRST, GPNUM,\n\t\t\t\t  (cmd == KDENABIO)) ? -ENXIO : 0;\n#endif\n\n\t \n\n\tcase KDKBDREP:\n\t{\n\t\tstruct kbd_repeat kbrep;\n\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&kbrep, up, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\n\t\tret = kbd_rate(&kbrep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &kbrep, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tcase KDSETMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\tconsole_lock();\n\t\tret = vt_kdsetmode(vc, arg);\n\t\tconsole_unlock();\n\t\treturn ret;\n\n\tcase KDGETMODE:\n\t\treturn put_user(vc->vc_mode, (int __user *)arg);\n\n\tcase KDMAPDISP:\n\tcase KDUNMAPDISP:\n\t\t \n\t\treturn -EINVAL;\n\n\tcase KDSKBMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tret = vt_do_kdskbmode(console, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttty_ldisc_flush(tty);\n\t\tbreak;\n\n\tcase KDGKBMODE:\n\t\treturn put_user(vt_do_kdgkbmode(console), (int __user *)arg);\n\n\t \n\tcase KDSKBMETA:\n\t\treturn vt_do_kdskbmeta(console, arg);\n\n\tcase KDGKBMETA:\n\t\t \n\t\treturn put_user(vt_do_kdgkbmeta(console), (int __user *)arg);\n\n\tcase KDGETKEYCODE:\n\tcase KDSETKEYCODE:\n\t\tif(!capable(CAP_SYS_TTY_CONFIG))\n\t\t\tperm = 0;\n\t\treturn vt_do_kbkeycode_ioctl(cmd, up, perm);\n\n\tcase KDGKBENT:\n\tcase KDSKBENT:\n\t\treturn vt_do_kdsk_ioctl(cmd, up, perm, console);\n\n\tcase KDGKBSENT:\n\tcase KDSKBSENT:\n\t\treturn vt_do_kdgkb_ioctl(cmd, up, perm);\n\n\t \n\tcase KDGKBDIACR:\n\tcase KDGKBDIACRUC:\n\tcase KDSKBDIACR:\n\tcase KDSKBDIACRUC:\n\t\treturn vt_do_diacrit(cmd, up, perm);\n\n\t \n\t \n\tcase KDGKBLED:\n\tcase KDSKBLED:\n\tcase KDGETLED:\n\tcase KDSETLED:\n\t\treturn vt_do_kdskled(console, cmd, arg, perm);\n\n\t \n\tcase KDSIGACCEPT:\n\t\tif (!perm || !capable(CAP_KILL))\n\t\t\treturn -EPERM;\n\t\tif (!valid_signal(arg) || arg < 1 || arg == SIGKILL)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irq(&vt_spawn_con.lock);\n\t\tput_pid(vt_spawn_con.pid);\n\t\tvt_spawn_con.pid = get_pid(task_pid(current));\n\t\tvt_spawn_con.sig = arg;\n\t\tspin_unlock_irq(&vt_spawn_con.lock);\n\t\tbreak;\n\n\tcase KDFONTOP: {\n\t\tstruct console_font_op op;\n\n\t\tif (copy_from_user(&op, up, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tif (!perm && op.op != KD_FONT_OP_GET)\n\t\t\treturn -EPERM;\n\t\tret = con_font_op(vc, &op);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &op, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int do_unimap_ioctl(int cmd, struct unimapdesc __user *user_ud,\n\t\tbool perm, struct vc_data *vc)\n{\n\tstruct unimapdesc tmp;\n\n\tif (copy_from_user(&tmp, user_ud, sizeof tmp))\n\t\treturn -EFAULT;\n\tswitch (cmd) {\n\tcase PIO_UNIMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_unimap(vc, tmp.entry_ct, tmp.entries);\n\tcase GIO_UNIMAP:\n\t\tif (!perm && fg_console != vc->vc_num)\n\t\t\treturn -EPERM;\n\t\treturn con_get_unimap(vc, tmp.entry_ct, &(user_ud->entry_ct),\n\t\t\t\ttmp.entries);\n\t}\n\treturn 0;\n}\n\nstatic int vt_io_ioctl(struct vc_data *vc, unsigned int cmd, void __user *up,\n\t\tbool perm)\n{\n\tswitch (cmd) {\n\tcase PIO_CMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_cmap(up);\n\n\tcase GIO_CMAP:\n\t\treturn con_get_cmap(up);\n\n\tcase PIO_SCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_old(up);\n\n\tcase GIO_SCRNMAP:\n\t\treturn con_get_trans_old(up);\n\n\tcase PIO_UNISCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_new(up);\n\n\tcase GIO_UNISCRNMAP:\n\t\treturn con_get_trans_new(up);\n\n\tcase PIO_UNIMAPCLR:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tcon_clear_unimap(vc);\n\t\tbreak;\n\n\tcase PIO_UNIMAP:\n\tcase GIO_UNIMAP:\n\t\treturn do_unimap_ioctl(cmd, up, perm, vc);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic int vt_reldisp(struct vc_data *vc, unsigned int swtch)\n{\n\tint newvt, ret;\n\n\tif (vc->vt_mode.mode != VT_PROCESS)\n\t\treturn -EINVAL;\n\n\t \n\tif (vc->vt_newvt < 0) {\n\t\t  \n\t\treturn swtch == VT_ACKACQ ? 0 : -EINVAL;\n\t}\n\n\t \n\tif (swtch == 0) {\n\t\t \n\t\tvc->vt_newvt = -1;\n\t\treturn 0;\n\t}\n\n\t \n\tnewvt = vc->vt_newvt;\n\tvc->vt_newvt = -1;\n\tret = vc_allocate(newvt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcomplete_change_console(vc_cons[newvt].d);\n\n\treturn 0;\n}\n\nstatic int vt_setactivate(struct vt_setactivate __user *sa)\n{\n\tstruct vt_setactivate vsa;\n\tstruct vc_data *nvc;\n\tint ret;\n\n\tif (copy_from_user(&vsa, sa, sizeof(vsa)))\n\t\treturn -EFAULT;\n\tif (vsa.console == 0 || vsa.console > MAX_NR_CONSOLES)\n\t\treturn -ENXIO;\n\n\tvsa.console--;\n\tvsa.console = array_index_nospec(vsa.console, MAX_NR_CONSOLES);\n\tconsole_lock();\n\tret = vc_allocate(vsa.console);\n\tif (ret) {\n\t\tconsole_unlock();\n\t\treturn ret;\n\t}\n\n\t \n\tnvc = vc_cons[vsa.console].d;\n\tnvc->vt_mode = vsa.mode;\n\tnvc->vt_mode.frsig = 0;\n\tput_pid(nvc->vt_pid);\n\tnvc->vt_pid = get_pid(task_pid(current));\n\tconsole_unlock();\n\n\t \n\t \n\tset_console(vsa.console);\n\n\treturn 0;\n}\n\n \nstatic int vt_disallocate(unsigned int vc_num)\n{\n\tstruct vc_data *vc = NULL;\n\tint ret = 0;\n\n\tconsole_lock();\n\tif (vt_busy(vc_num))\n\t\tret = -EBUSY;\n\telse if (vc_num)\n\t\tvc = vc_deallocate(vc_num);\n\tconsole_unlock();\n\n\tif (vc && vc_num >= MIN_NR_CONSOLES)\n\t\ttty_port_put(&vc->port);\n\n\treturn ret;\n}\n\n \nstatic void vt_disallocate_all(void)\n{\n\tstruct vc_data *vc[MAX_NR_CONSOLES];\n\tint i;\n\n\tconsole_lock();\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++)\n\t\tif (!vt_busy(i))\n\t\t\tvc[i] = vc_deallocate(i);\n\t\telse\n\t\t\tvc[i] = NULL;\n\tconsole_unlock();\n\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++) {\n\t\tif (vc[i] && i >= MIN_NR_CONSOLES)\n\t\t\ttty_port_put(&vc[i]->port);\n\t}\n}\n\nstatic int vt_resizex(struct vc_data *vc, struct vt_consize __user *cs)\n{\n\tstruct vt_consize v;\n\tint i;\n\n\tif (copy_from_user(&v, cs, sizeof(struct vt_consize)))\n\t\treturn -EFAULT;\n\n\t \n\tif (!v.v_vlin)\n\t\tv.v_vlin = vc->vc_scan_lines;\n\n\tif (v.v_clin) {\n\t\tint rows = v.v_vlin / v.v_clin;\n\t\tif (v.v_rows != rows) {\n\t\t\tif (v.v_rows)  \n\t\t\t\treturn -EINVAL;\n\t\t\tv.v_rows = rows;\n\t\t}\n\t}\n\n\tif (v.v_vcol && v.v_ccol) {\n\t\tint cols = v.v_vcol / v.v_ccol;\n\t\tif (v.v_cols != cols) {\n\t\t\tif (v.v_cols)\n\t\t\t\treturn -EINVAL;\n\t\t\tv.v_cols = cols;\n\t\t}\n\t}\n\n\tif (v.v_clin > 32)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tstruct vc_data *vcp;\n\n\t\tif (!vc_cons[i].d)\n\t\t\tcontinue;\n\t\tconsole_lock();\n\t\tvcp = vc_cons[i].d;\n\t\tif (vcp) {\n\t\t\tint ret;\n\t\t\tint save_scan_lines = vcp->vc_scan_lines;\n\t\t\tint save_cell_height = vcp->vc_cell_height;\n\n\t\t\tif (v.v_vlin)\n\t\t\t\tvcp->vc_scan_lines = v.v_vlin;\n\t\t\tif (v.v_clin)\n\t\t\t\tvcp->vc_cell_height = v.v_clin;\n\t\t\tvcp->vc_resize_user = 1;\n\t\t\tret = vc_resize(vcp, v.v_cols, v.v_rows);\n\t\t\tif (ret) {\n\t\t\t\tvcp->vc_scan_lines = save_scan_lines;\n\t\t\t\tvcp->vc_cell_height = save_cell_height;\n\t\t\t\tconsole_unlock();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tconsole_unlock();\n\t}\n\n\treturn 0;\n}\n\n \nint vt_ioctl(struct tty_struct *tty,\n\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tvoid __user *up = (void __user *)arg;\n\tint i, perm;\n\tint ret;\n\n\t \n\tperm = 0;\n\tif (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))\n\t\tperm = 1;\n\n\tret = vt_k_ioctl(tty, cmd, arg, perm);\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\tret = vt_io_ioctl(vc, cmd, up, perm);\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\tswitch (cmd) {\n\tcase TIOCLINUX:\n\t\treturn tioclinux(tty, arg);\n\tcase VT_SETMODE:\n\t{\n\t\tstruct vt_mode tmp;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&tmp, up, sizeof(struct vt_mode)))\n\t\t\treturn -EFAULT;\n\t\tif (tmp.mode != VT_AUTO && tmp.mode != VT_PROCESS)\n\t\t\treturn -EINVAL;\n\n\t\tconsole_lock();\n\t\tvc->vt_mode = tmp;\n\t\t \n\t\tvc->vt_mode.frsig = 0;\n\t\tput_pid(vc->vt_pid);\n\t\tvc->vt_pid = get_pid(task_pid(current));\n\t\t \n\t\tvc->vt_newvt = -1;\n\t\tconsole_unlock();\n\t\tbreak;\n\t}\n\n\tcase VT_GETMODE:\n\t{\n\t\tstruct vt_mode tmp;\n\t\tint rc;\n\n\t\tconsole_lock();\n\t\tmemcpy(&tmp, &vc->vt_mode, sizeof(struct vt_mode));\n\t\tconsole_unlock();\n\n\t\trc = copy_to_user(up, &tmp, sizeof(struct vt_mode));\n\t\tif (rc)\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\t \n\tcase VT_GETSTATE:\n\t{\n\t\tstruct vt_stat __user *vtstat = up;\n\t\tunsigned short state, mask;\n\n\t\tif (put_user(fg_console + 1, &vtstat->v_active))\n\t\t\treturn -EFAULT;\n\n\t\tstate = 1;\t \n\t\tconsole_lock();  \n\t\tfor (i = 0, mask = 2; i < MAX_NR_CONSOLES && mask;\n\t\t\t\t++i, mask <<= 1)\n\t\t\tif (vt_in_use(i))\n\t\t\t\tstate |= mask;\n\t\tconsole_unlock();\n\t\treturn put_user(state, &vtstat->v_state);\n\t}\n\n\t \n\tcase VT_OPENQRY:\n\t\tconsole_lock();  \n\t\tfor (i = 0; i < MAX_NR_CONSOLES; ++i)\n\t\t\tif (!vt_in_use(i))\n\t\t\t\tbreak;\n\t\tconsole_unlock();\n\t\ti = i < MAX_NR_CONSOLES ? (i+1) : -1;\n\t\treturn put_user(i, (int __user *)arg);\n\n\t \n\tcase VT_ACTIVATE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (arg == 0 || arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\n\t\targ--;\n\t\targ = array_index_nospec(arg, MAX_NR_CONSOLES);\n\t\tconsole_lock();\n\t\tret = vc_allocate(arg);\n\t\tconsole_unlock();\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tset_console(arg);\n\t\tbreak;\n\n\tcase VT_SETACTIVATE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\treturn vt_setactivate(up);\n\n\t \n\tcase VT_WAITACTIVE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (arg == 0 || arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\t\treturn vt_waitactive(arg);\n\n\t \n\tcase VT_RELDISP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\tconsole_lock();\n\t\tret = vt_reldisp(vc, arg);\n\t\tconsole_unlock();\n\n\t\treturn ret;\n\n\n\t  \n\t case VT_DISALLOCATE:\n\t\tif (arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\n\t\tif (arg == 0) {\n\t\t\tvt_disallocate_all();\n\t\t\tbreak;\n\t\t}\n\n\t\targ = array_index_nospec(arg - 1, MAX_NR_CONSOLES);\n\t\treturn vt_disallocate(arg);\n\n\tcase VT_RESIZE:\n\t{\n\t\tstruct vt_sizes __user *vtsizes = up;\n\t\tstruct vc_data *vc;\n\t\tushort ll,cc;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (get_user(ll, &vtsizes->v_rows) ||\n\t\t    get_user(cc, &vtsizes->v_cols))\n\t\t\treturn -EFAULT;\n\n\t\tconsole_lock();\n\t\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\t\tvc = vc_cons[i].d;\n\n\t\t\tif (vc) {\n\t\t\t\tvc->vc_resize_user = 1;\n\t\t\t\t \n\t\t\t\tvc_resize(vc_cons[i].d, cc, ll);\n\t\t\t}\n\t\t}\n\t\tconsole_unlock();\n\t\tbreak;\n\t}\n\n\tcase VT_RESIZEX:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\treturn vt_resizex(vc, up);\n\n\tcase VT_LOCKSWITCH:\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\t\tvt_dont_switch = true;\n\t\tbreak;\n\tcase VT_UNLOCKSWITCH:\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\t\tvt_dont_switch = false;\n\t\tbreak;\n\tcase VT_GETHIFONTMASK:\n\t\treturn put_user(vc->vc_hi_font_mask,\n\t\t\t\t\t(unsigned short __user *)arg);\n\tcase VT_WAITEVENT:\n\t\treturn vt_event_wait_ioctl((struct vt_event __user *)arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nvoid reset_vc(struct vc_data *vc)\n{\n\tvc->vc_mode = KD_TEXT;\n\tvt_reset_unicode(vc->vc_num);\n\tvc->vt_mode.mode = VT_AUTO;\n\tvc->vt_mode.waitv = 0;\n\tvc->vt_mode.relsig = 0;\n\tvc->vt_mode.acqsig = 0;\n\tvc->vt_mode.frsig = 0;\n\tput_pid(vc->vt_pid);\n\tvc->vt_pid = NULL;\n\tvc->vt_newvt = -1;\n\treset_palette(vc);\n}\n\nvoid vc_SAK(struct work_struct *work)\n{\n\tstruct vc *vc_con =\n\t\tcontainer_of(work, struct vc, SAK_work);\n\tstruct vc_data *vc;\n\tstruct tty_struct *tty;\n\n\tconsole_lock();\n\tvc = vc_con->d;\n\tif (vc) {\n\t\t \n\t\ttty = vc->port.tty;\n\t\t \n\t\tif (tty)\n\t\t\t__do_SAK(tty);\n\t\treset_vc(vc);\n\t}\n\tconsole_unlock();\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_console_font_op {\n\tcompat_uint_t op;         \n\tcompat_uint_t flags;      \n\tcompat_uint_t width, height;      \n\tcompat_uint_t charcount;\n\tcompat_caddr_t data;     \n};\n\nstatic inline int\ncompat_kdfontop_ioctl(struct compat_console_font_op __user *fontop,\n\t\t\t int perm, struct console_font_op *op, struct vc_data *vc)\n{\n\tint i;\n\n\tif (copy_from_user(op, fontop, sizeof(struct compat_console_font_op)))\n\t\treturn -EFAULT;\n\tif (!perm && op->op != KD_FONT_OP_GET)\n\t\treturn -EPERM;\n\top->data = compat_ptr(((struct compat_console_font_op *)op)->data);\n\ti = con_font_op(vc, op);\n\tif (i)\n\t\treturn i;\n\t((struct compat_console_font_op *)op)->data = (unsigned long)op->data;\n\tif (copy_to_user(fontop, op, sizeof(struct compat_console_font_op)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstruct compat_unimapdesc {\n\tunsigned short entry_ct;\n\tcompat_caddr_t entries;\n};\n\nstatic inline int\ncompat_unimap_ioctl(unsigned int cmd, struct compat_unimapdesc __user *user_ud,\n\t\t\t int perm, struct vc_data *vc)\n{\n\tstruct compat_unimapdesc tmp;\n\tstruct unipair __user *tmp_entries;\n\n\tif (copy_from_user(&tmp, user_ud, sizeof tmp))\n\t\treturn -EFAULT;\n\ttmp_entries = compat_ptr(tmp.entries);\n\tswitch (cmd) {\n\tcase PIO_UNIMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_unimap(vc, tmp.entry_ct, tmp_entries);\n\tcase GIO_UNIMAP:\n\t\tif (!perm && fg_console != vc->vc_num)\n\t\t\treturn -EPERM;\n\t\treturn con_get_unimap(vc, tmp.entry_ct, &(user_ud->entry_ct), tmp_entries);\n\t}\n\treturn 0;\n}\n\nlong vt_compat_ioctl(struct tty_struct *tty,\n\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tstruct console_font_op op;\t \n\tvoid __user *up = compat_ptr(arg);\n\tint perm;\n\n\t \n\tperm = 0;\n\tif (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))\n\t\tperm = 1;\n\n\tswitch (cmd) {\n\t \n\n\tcase KDFONTOP:\n\t\treturn compat_kdfontop_ioctl(up, perm, &op, vc);\n\n\tcase PIO_UNIMAP:\n\tcase GIO_UNIMAP:\n\t\treturn compat_unimap_ioctl(cmd, up, perm, vc);\n\n\t \n\tcase KIOCSOUND:\n\tcase KDMKTONE:\n#ifdef CONFIG_X86\n\tcase KDADDIO:\n\tcase KDDELIO:\n#endif\n\tcase KDSETMODE:\n\tcase KDMAPDISP:\n\tcase KDUNMAPDISP:\n\tcase KDSKBMODE:\n\tcase KDSKBMETA:\n\tcase KDSKBLED:\n\tcase KDSETLED:\n\tcase KDSIGACCEPT:\n\tcase VT_ACTIVATE:\n\tcase VT_WAITACTIVE:\n\tcase VT_RELDISP:\n\tcase VT_DISALLOCATE:\n\tcase VT_RESIZE:\n\tcase VT_RESIZEX:\n\t\treturn vt_ioctl(tty, cmd, arg);\n\n\t \n\tdefault:\n\t\treturn vt_ioctl(tty, cmd, (unsigned long)up);\n\t}\n}\n\n\n#endif  \n\n\n \nstatic void complete_change_console(struct vc_data *vc)\n{\n\tunsigned char old_vc_mode;\n\tint old = fg_console;\n\n\tlast_console = fg_console;\n\n\t \n\told_vc_mode = vc_cons[fg_console].d->vc_mode;\n\tswitch_screen(vc);\n\n\t \n\tif (old_vc_mode != vc->vc_mode) {\n\t\tif (vc->vc_mode == KD_TEXT)\n\t\t\tdo_unblank_screen(1);\n\t\telse\n\t\t\tdo_blank_screen(1);\n\t}\n\n\t \n\tif (vc->vt_mode.mode == VT_PROCESS) {\n\t\t \n\t\tif (kill_pid(vc->vt_pid, vc->vt_mode.acqsig, 1) != 0) {\n\t\t \n\t\t\treset_vc(vc);\n\n\t\t\tif (old_vc_mode != vc->vc_mode) {\n\t\t\t\tif (vc->vc_mode == KD_TEXT)\n\t\t\t\t\tdo_unblank_screen(1);\n\t\t\t\telse\n\t\t\t\t\tdo_blank_screen(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tvt_event_post(VT_EVENT_SWITCH, old, vc->vc_num);\n\treturn;\n}\n\n \nvoid change_console(struct vc_data *new_vc)\n{\n\tstruct vc_data *vc;\n\n\tif (!new_vc || new_vc->vc_num == fg_console || vt_dont_switch)\n\t\treturn;\n\n\t \n\tvc = vc_cons[fg_console].d;\n\tif (vc->vt_mode.mode == VT_PROCESS) {\n\t\t \n\t\tvc->vt_newvt = new_vc->vc_num;\n\t\tif (kill_pid(vc->vt_pid, vc->vt_mode.relsig, 1) == 0) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\treset_vc(vc);\n\n\t\t \n\t}\n\n\t \n\tif (vc->vc_mode == KD_GRAPHICS)\n\t\treturn;\n\n\tcomplete_change_console(new_vc);\n}\n\n \n\nstatic int disable_vt_switch;\n\nint vt_move_to_console(unsigned int vt, int alloc)\n{\n\tint prev;\n\n\tconsole_lock();\n\t \n\tif (disable_vt_switch) {\n\t\tconsole_unlock();\n\t\treturn 0;\n\t}\n\tprev = fg_console;\n\n\tif (alloc && vc_allocate(vt)) {\n\t\t \n\t\tconsole_unlock();\n\t\treturn -ENOSPC;\n\t}\n\n\tif (set_console(vt)) {\n\t\t \n\t\tconsole_unlock();\n\t\treturn -EIO;\n\t}\n\tconsole_unlock();\n\tif (vt_waitactive(vt + 1)) {\n\t\tpr_debug(\"Suspend: Can't switch VCs.\");\n\t\treturn -EINTR;\n\t}\n\treturn prev;\n}\n\n \nvoid pm_set_vt_switch(int do_switch)\n{\n\tconsole_lock();\n\tdisable_vt_switch = !do_switch;\n\tconsole_unlock();\n}\nEXPORT_SYMBOL(pm_set_vt_switch);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}