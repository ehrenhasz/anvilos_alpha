{
  "module_name": "tty_audit.c",
  "hash_id": "6fd711c0b7e1c6e937f98745be3eeae3a0f9e947b34c8b88ab1338b4cbdb9901",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tty/tty_audit.c",
  "human_readable_source": "\n \n\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include \"tty.h\"\n\nstruct tty_audit_buf {\n\tstruct mutex mutex;\t \n\tdev_t dev;\t\t \n\tbool icanon;\n\tsize_t valid;\n\tu8 *data;\t\t \n};\n\nstatic struct tty_audit_buf *tty_audit_buf_ref(void)\n{\n\tstruct tty_audit_buf *buf;\n\n\tbuf = current->signal->tty_audit_buf;\n\tWARN_ON(buf == ERR_PTR(-ESRCH));\n\treturn buf;\n}\n\nstatic struct tty_audit_buf *tty_audit_buf_alloc(void)\n{\n\tstruct tty_audit_buf *buf;\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\tbuf->data = kmalloc(N_TTY_BUF_SIZE, GFP_KERNEL);\n\tif (!buf->data)\n\t\tgoto err_buf;\n\n\tmutex_init(&buf->mutex);\n\n\treturn buf;\n\nerr_buf:\n\tkfree(buf);\nerr:\n\treturn NULL;\n}\n\nstatic void tty_audit_buf_free(struct tty_audit_buf *buf)\n{\n\tWARN_ON(buf->valid != 0);\n\tkfree(buf->data);\n\tkfree(buf);\n}\n\nstatic void tty_audit_log(const char *description, dev_t dev,\n\t\t\t  const u8 *data, size_t size)\n{\n\tstruct audit_buffer *ab;\n\tpid_t pid = task_pid_nr(current);\n\tuid_t uid = from_kuid(&init_user_ns, task_uid(current));\n\tuid_t loginuid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tchar name[TASK_COMM_LEN];\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_TTY);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"%s pid=%u uid=%u auid=%u ses=%u major=%d minor=%d comm=\",\n\t\t\t description, pid, uid, loginuid, sessionid,\n\t\t\t MAJOR(dev), MINOR(dev));\n\tget_task_comm(name, current);\n\taudit_log_untrustedstring(ab, name);\n\taudit_log_format(ab, \" data=\");\n\taudit_log_n_hex(ab, data, size);\n\taudit_log_end(ab);\n}\n\n \nstatic void tty_audit_buf_push(struct tty_audit_buf *buf)\n{\n\tif (buf->valid == 0)\n\t\treturn;\n\tif (audit_enabled == AUDIT_OFF) {\n\t\tbuf->valid = 0;\n\t\treturn;\n\t}\n\ttty_audit_log(\"tty\", buf->dev, buf->data, buf->valid);\n\tbuf->valid = 0;\n}\n\n \nvoid tty_audit_exit(void)\n{\n\tstruct tty_audit_buf *buf;\n\n\tbuf = xchg(&current->signal->tty_audit_buf, ERR_PTR(-ESRCH));\n\tif (!buf)\n\t\treturn;\n\n\ttty_audit_buf_push(buf);\n\ttty_audit_buf_free(buf);\n}\n\n \nvoid tty_audit_fork(struct signal_struct *sig)\n{\n\tsig->audit_tty = current->signal->audit_tty;\n}\n\n \nvoid tty_audit_tiocsti(const struct tty_struct *tty, u8 ch)\n{\n\tdev_t dev;\n\n\tdev = MKDEV(tty->driver->major, tty->driver->minor_start) + tty->index;\n\tif (tty_audit_push())\n\t\treturn;\n\n\tif (audit_enabled)\n\t\ttty_audit_log(\"ioctl=TIOCSTI\", dev, &ch, 1);\n}\n\n \nint tty_audit_push(void)\n{\n\tstruct tty_audit_buf *buf;\n\n\tif (~current->signal->audit_tty & AUDIT_TTY_ENABLE)\n\t\treturn -EPERM;\n\n\tbuf = tty_audit_buf_ref();\n\tif (!IS_ERR_OR_NULL(buf)) {\n\t\tmutex_lock(&buf->mutex);\n\t\ttty_audit_buf_push(buf);\n\t\tmutex_unlock(&buf->mutex);\n\t}\n\treturn 0;\n}\n\n \nstatic struct tty_audit_buf *tty_audit_buf_get(void)\n{\n\tstruct tty_audit_buf *buf;\n\n\tbuf = tty_audit_buf_ref();\n\tif (buf)\n\t\treturn buf;\n\n\tbuf = tty_audit_buf_alloc();\n\tif (buf == NULL) {\n\t\taudit_log_lost(\"out of memory in TTY auditing\");\n\t\treturn NULL;\n\t}\n\n\t \n\tif (cmpxchg(&current->signal->tty_audit_buf, NULL, buf) != NULL)\n\t\ttty_audit_buf_free(buf);\n\treturn tty_audit_buf_ref();\n}\n\n \nvoid tty_audit_add_data(const struct tty_struct *tty, const void *data,\n\t\t\tsize_t size)\n{\n\tstruct tty_audit_buf *buf;\n\tunsigned int audit_tty;\n\tbool icanon = L_ICANON(tty);\n\tdev_t dev;\n\n\taudit_tty = READ_ONCE(current->signal->audit_tty);\n\tif (~audit_tty & AUDIT_TTY_ENABLE)\n\t\treturn;\n\n\tif (unlikely(size == 0))\n\t\treturn;\n\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY\n\t    && tty->driver->subtype == PTY_TYPE_MASTER)\n\t\treturn;\n\n\tif ((~audit_tty & AUDIT_TTY_LOG_PASSWD) && icanon && !L_ECHO(tty))\n\t\treturn;\n\n\tbuf = tty_audit_buf_get();\n\tif (IS_ERR_OR_NULL(buf))\n\t\treturn;\n\n\tmutex_lock(&buf->mutex);\n\tdev = MKDEV(tty->driver->major, tty->driver->minor_start) + tty->index;\n\tif (buf->dev != dev || buf->icanon != icanon) {\n\t\ttty_audit_buf_push(buf);\n\t\tbuf->dev = dev;\n\t\tbuf->icanon = icanon;\n\t}\n\tdo {\n\t\tsize_t run;\n\n\t\trun = N_TTY_BUF_SIZE - buf->valid;\n\t\tif (run > size)\n\t\t\trun = size;\n\t\tmemcpy(buf->data + buf->valid, data, run);\n\t\tbuf->valid += run;\n\t\tdata += run;\n\t\tsize -= run;\n\t\tif (buf->valid == N_TTY_BUF_SIZE)\n\t\t\ttty_audit_buf_push(buf);\n\t} while (size != 0);\n\tmutex_unlock(&buf->mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}