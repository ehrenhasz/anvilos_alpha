{
  "module_name": "core.c",
  "hash_id": "fdb8957b1b640168d10f3b91b95296b501af605633da44168293555b4eb87a23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cb710/core.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/idr.h>\n#include <linux/cb710.h>\n#include <linux/gfp.h>\n\nstatic DEFINE_IDA(cb710_ida);\n\nvoid cb710_pci_update_config_reg(struct pci_dev *pdev,\n\tint reg, uint32_t mask, uint32_t xor)\n{\n\tu32 rval;\n\n\tpci_read_config_dword(pdev, reg, &rval);\n\trval = (rval & mask) ^ xor;\n\tpci_write_config_dword(pdev, reg, rval);\n}\nEXPORT_SYMBOL_GPL(cb710_pci_update_config_reg);\n\n \nstatic int cb710_pci_configure(struct pci_dev *pdev)\n{\n\tunsigned int devfn = PCI_DEVFN(PCI_SLOT(pdev->devfn), 0);\n\tstruct pci_dev *pdev0;\n\tu32 val;\n\n\tcb710_pci_update_config_reg(pdev, 0x48,\n\t\t~0x000000FF, 0x0000003F);\n\n\tpci_read_config_dword(pdev, 0x48, &val);\n\tif (val & 0x80000000)\n\t\treturn 0;\n\n\tpdev0 = pci_get_slot(pdev->bus, devfn);\n\tif (!pdev0)\n\t\treturn -ENODEV;\n\n\tif (pdev0->vendor == PCI_VENDOR_ID_ENE\n\t    && pdev0->device == PCI_DEVICE_ID_ENE_720) {\n\t\tcb710_pci_update_config_reg(pdev0, 0x8C,\n\t\t\t~0x00F00000, 0x00100000);\n\t\tcb710_pci_update_config_reg(pdev0, 0xB0,\n\t\t\t~0x08000000, 0x08000000);\n\t}\n\n\tcb710_pci_update_config_reg(pdev0, 0x8C,\n\t\t~0x00000F00, 0x00000200);\n\tcb710_pci_update_config_reg(pdev0, 0x90,\n\t\t~0x00060000, 0x00040000);\n\n\tpci_dev_put(pdev0);\n\n\treturn 0;\n}\n\nstatic irqreturn_t cb710_irq_handler(int irq, void *data)\n{\n\tstruct cb710_chip *chip = data;\n\tstruct cb710_slot *slot = &chip->slot[0];\n\tirqreturn_t handled = IRQ_NONE;\n\tunsigned nr;\n\n\tspin_lock(&chip->irq_lock);  \n\n\tfor (nr = chip->slots; nr; ++slot, --nr) {\n\t\tcb710_irq_handler_t handler_func = slot->irq_handler;\n\t\tif (handler_func && handler_func(slot))\n\t\t\thandled = IRQ_HANDLED;\n\t}\n\n\tspin_unlock(&chip->irq_lock);\n\n\treturn handled;\n}\n\nstatic void cb710_release_slot(struct device *dev)\n{\n#ifdef CONFIG_CB710_DEBUG_ASSUMPTIONS\n\tstruct cb710_slot *slot = cb710_pdev_to_slot(to_platform_device(dev));\n\tstruct cb710_chip *chip = cb710_slot_to_chip(slot);\n\n\t \n\tatomic_dec(&chip->slot_refs_count);\n#endif\n}\n\nstatic int cb710_register_slot(struct cb710_chip *chip,\n\tunsigned slot_mask, unsigned io_offset, const char *name)\n{\n\tint nr = chip->slots;\n\tstruct cb710_slot *slot = &chip->slot[nr];\n\tint err;\n\n\tdev_dbg(cb710_chip_dev(chip),\n\t\t\"register: %s.%d; slot %d; mask %d; IO offset: 0x%02X\\n\",\n\t\tname, chip->platform_id, nr, slot_mask, io_offset);\n\n\t \n\t++chip->slots;\n\tsmp_wmb();\n\n\tslot->iobase = chip->iobase + io_offset;\n\tslot->pdev.name = name;\n\tslot->pdev.id = chip->platform_id;\n\tslot->pdev.dev.parent = &chip->pdev->dev;\n\tslot->pdev.dev.release = cb710_release_slot;\n\n\terr = platform_device_register(&slot->pdev);\n\n#ifdef CONFIG_CB710_DEBUG_ASSUMPTIONS\n\tatomic_inc(&chip->slot_refs_count);\n#endif\n\n\tif (err) {\n\t\t \n\t\tplatform_device_put(&slot->pdev);\n\n\t\t \n\t\t--chip->slots;\n\t\treturn err;\n\t}\n\n\tchip->slot_mask |= slot_mask;\n\n\treturn 0;\n}\n\nstatic void cb710_unregister_slot(struct cb710_chip *chip,\n\tunsigned slot_mask)\n{\n\tint nr = chip->slots - 1;\n\n\tif (!(chip->slot_mask & slot_mask))\n\t\treturn;\n\n\tplatform_device_unregister(&chip->slot[nr].pdev);\n\n\t \n\tsmp_rmb();\n\tBUG_ON(chip->slot[nr].irq_handler != NULL);\n\n\t \n\t--chip->slots;\n\tchip->slot_mask &= ~slot_mask;\n}\n\nvoid cb710_set_irq_handler(struct cb710_slot *slot,\n\tcb710_irq_handler_t handler)\n{\n\tstruct cb710_chip *chip = cb710_slot_to_chip(slot);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->irq_lock, flags);\n\tslot->irq_handler = handler;\n\tspin_unlock_irqrestore(&chip->irq_lock, flags);\n}\nEXPORT_SYMBOL_GPL(cb710_set_irq_handler);\n\nstatic int __maybe_unused cb710_suspend(struct device *dev_d)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_d);\n\tstruct cb710_chip *chip = pci_get_drvdata(pdev);\n\n\tdevm_free_irq(&pdev->dev, pdev->irq, chip);\n\treturn 0;\n}\n\nstatic int __maybe_unused cb710_resume(struct device *dev_d)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_d);\n\tstruct cb710_chip *chip = pci_get_drvdata(pdev);\n\n\treturn devm_request_irq(&pdev->dev, pdev->irq,\n\t\tcb710_irq_handler, IRQF_SHARED, KBUILD_MODNAME, chip);\n}\n\nstatic int cb710_probe(struct pci_dev *pdev,\n\tconst struct pci_device_id *ent)\n{\n\tstruct cb710_chip *chip;\n\tu32 val;\n\tint err;\n\tint n = 0;\n\n\terr = cb710_pci_configure(pdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tpci_read_config_dword(pdev, 0x48, &val);\n\tif (!(val & 0x80000000)) {\n\t\tpci_write_config_dword(pdev, 0x48, val|0x71000000);\n\t\tpci_read_config_dword(pdev, 0x48, &val);\n\t}\n\n\tdev_dbg(&pdev->dev, \"PCI config[0x48] = 0x%08X\\n\", val);\n\tif (!(val & 0x70000000))\n\t\treturn -ENODEV;\n\tval = (val >> 28) & 7;\n\tif (val & CB710_SLOT_MMC)\n\t\t++n;\n\tif (val & CB710_SLOT_MS)\n\t\t++n;\n\tif (val & CB710_SLOT_SM)\n\t\t++n;\n\n\tchip = devm_kzalloc(&pdev->dev, struct_size(chip, slot, n),\n\t\t\t    GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\terr = pcim_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = pcim_iomap_regions(pdev, 0x0001, KBUILD_MODNAME);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_init(&chip->irq_lock);\n\tchip->pdev = pdev;\n\tchip->iobase = pcim_iomap_table(pdev)[0];\n\n\tpci_set_drvdata(pdev, chip);\n\n\terr = devm_request_irq(&pdev->dev, pdev->irq,\n\t\tcb710_irq_handler, IRQF_SHARED, KBUILD_MODNAME, chip);\n\tif (err)\n\t\treturn err;\n\n\terr = ida_alloc(&cb710_ida, GFP_KERNEL);\n\tif (err < 0)\n\t\treturn err;\n\tchip->platform_id = err;\n\n\tdev_info(&pdev->dev, \"id %d, IO 0x%p, IRQ %d\\n\",\n\t\tchip->platform_id, chip->iobase, pdev->irq);\n\n\tif (val & CB710_SLOT_MMC) {\t \n\t\terr = cb710_register_slot(chip,\n\t\t\tCB710_SLOT_MMC, 0x00, \"cb710-mmc\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (val & CB710_SLOT_MS) {\t \n\t\terr = cb710_register_slot(chip,\n\t\t\tCB710_SLOT_MS, 0x40, \"cb710-ms\");\n\t\tif (err)\n\t\t\tgoto unreg_mmc;\n\t}\n\n\tif (val & CB710_SLOT_SM) {\t \n\t\terr = cb710_register_slot(chip,\n\t\t\tCB710_SLOT_SM, 0x60, \"cb710-sm\");\n\t\tif (err)\n\t\t\tgoto unreg_ms;\n\t}\n\n\treturn 0;\nunreg_ms:\n\tcb710_unregister_slot(chip, CB710_SLOT_MS);\nunreg_mmc:\n\tcb710_unregister_slot(chip, CB710_SLOT_MMC);\n\n#ifdef CONFIG_CB710_DEBUG_ASSUMPTIONS\n\tBUG_ON(atomic_read(&chip->slot_refs_count) != 0);\n#endif\n\treturn err;\n}\n\nstatic void cb710_remove_one(struct pci_dev *pdev)\n{\n\tstruct cb710_chip *chip = pci_get_drvdata(pdev);\n\n\tcb710_unregister_slot(chip, CB710_SLOT_SM);\n\tcb710_unregister_slot(chip, CB710_SLOT_MS);\n\tcb710_unregister_slot(chip, CB710_SLOT_MMC);\n#ifdef CONFIG_CB710_DEBUG_ASSUMPTIONS\n\tBUG_ON(atomic_read(&chip->slot_refs_count) != 0);\n#endif\n\n\tida_free(&cb710_ida, chip->platform_id);\n}\n\nstatic const struct pci_device_id cb710_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_ENE, PCI_DEVICE_ID_ENE_CB710_FLASH,\n\t\tPCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0, }\n};\n\nstatic SIMPLE_DEV_PM_OPS(cb710_pm_ops, cb710_suspend, cb710_resume);\n\nstatic struct pci_driver cb710_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = cb710_pci_tbl,\n\t.probe = cb710_probe,\n\t.remove = cb710_remove_one,\n\t.driver.pm = &cb710_pm_ops,\n};\n\nstatic int __init cb710_init_module(void)\n{\n\treturn pci_register_driver(&cb710_driver);\n}\n\nstatic void __exit cb710_cleanup_module(void)\n{\n\tpci_unregister_driver(&cb710_driver);\n\tida_destroy(&cb710_ida);\n}\n\nmodule_init(cb710_init_module);\nmodule_exit(cb710_cleanup_module);\n\nMODULE_AUTHOR(\"Micha\u0142 Miros\u0142aw <mirq-linux@rere.qmqm.pl>\");\nMODULE_DESCRIPTION(\"ENE CB710 memory card reader driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, cb710_pci_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}