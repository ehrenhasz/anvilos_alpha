{
  "module_name": "debug.c",
  "hash_id": "adf4bc3f85587b69f41ec629ea376c387f1852b1c994a855c2262fb9bb61b636",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cb710/debug.c",
  "human_readable_source": "\n \n#include <linux/cb710.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define CB710_REG_COUNT\t\t0x80\n\nstatic const u16 allow[CB710_REG_COUNT/16] = {\n\t0xFFF0, 0xFFFF, 0xFFFF, 0xFFFF,\n\t0xFFF0, 0xFFFF, 0xFFFF, 0xFFFF,\n};\nstatic const char *const prefix[ARRAY_SIZE(allow)] = {\n\t\"MMC\", \"MMC\", \"MMC\", \"MMC\",\n\t\"MS?\", \"MS?\", \"SM?\", \"SM?\"\n};\n\nstatic inline int allow_reg_read(unsigned block, unsigned offset, unsigned bits)\n{\n\tunsigned mask = (1 << bits/8) - 1;\n\toffset *= bits/8;\n\treturn ((allow[block] >> offset) & mask) == mask;\n}\n\n#define CB710_READ_REGS_TEMPLATE(t)\t\t\t\t\t\\\nstatic void cb710_read_regs_##t(void __iomem *iobase,\t\t\t\\\n\tu##t *reg, unsigned select)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned i, j;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(allow); ++i, reg += 16/(t/8)) {\t\\\n\t\tif (!(select & (1 << i)))\t\t\t\t\t\\\n\t\t\tcontinue;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor (j = 0; j < 0x10/(t/8); ++j) {\t\t\t\\\n\t\t\tif (!allow_reg_read(i, j, t))\t\t\t\\\n\t\t\t\tcontinue;\t\t\t\t\\\n\t\t\treg[j] = ioread##t(iobase\t\t\t\\\n\t\t\t\t+ (i << 4) + (j * (t/8)));\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\nstatic const char cb710_regf_8[] = \"%02X\";\nstatic const char cb710_regf_16[] = \"%04X\";\nstatic const char cb710_regf_32[] = \"%08X\";\nstatic const char cb710_xes[] = \"xxxxxxxx\";\n\n#define CB710_DUMP_REGS_TEMPLATE(t)\t\t\t\t\t\\\nstatic void cb710_dump_regs_##t(struct device *dev,\t\t\t\\\n\tconst u##t *reg, unsigned select)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tconst char *const xp = &cb710_xes[8 - t/4];\t\t\t\\\n\tconst char *const format = cb710_regf_##t;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tchar msg[100], *p;\t\t\t\t\t\t\\\n\tunsigned i, j;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(allow); ++i, reg += 16/(t/8)) {\t\\\n\t\tif (!(select & (1 << i)))\t\t\t\t\\\n\t\t\tcontinue;\t\t\t\t\t\\\n\t\tp = msg;\t\t\t\t\t\t\\\n\t\tfor (j = 0; j < 0x10/(t/8); ++j) {\t\t\t\\\n\t\t\t*p++ = ' ';\t\t\t\t\t\\\n\t\t\tif (j == 8/(t/8))\t\t\t\t\\\n\t\t\t\t*p++ = ' ';\t\t\t\t\\\n\t\t\tif (allow_reg_read(i, j, t))\t\t\t\\\n\t\t\t\tp += sprintf(p, format, reg[j]);\t\\\n\t\t\telse\t\t\t\t\t\t\\\n\t\t\t\tp += sprintf(p, \"%s\", xp);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tdev_dbg(dev, \"%s 0x%02X %s\\n\", prefix[i], i << 4, msg);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n#define CB710_READ_AND_DUMP_REGS_TEMPLATE(t)\t\t\t\t\\\nstatic void cb710_read_and_dump_regs_##t(struct cb710_chip *chip,\t\\\n\tunsigned select)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu##t regs[CB710_REG_COUNT/sizeof(u##t)];\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmemset(&regs, 0, sizeof(regs));\t\t\t\t\t\\\n\tcb710_read_regs_##t(chip->iobase, regs, select);\t\t\\\n\tcb710_dump_regs_##t(cb710_chip_dev(chip), regs, select);\t\\\n}\n\n#define CB710_REG_ACCESS_TEMPLATES(t)\t\t\\\n  CB710_READ_REGS_TEMPLATE(t)\t\t\t\\\n  CB710_DUMP_REGS_TEMPLATE(t)\t\t\t\\\n  CB710_READ_AND_DUMP_REGS_TEMPLATE(t)\n\nCB710_REG_ACCESS_TEMPLATES(8)\nCB710_REG_ACCESS_TEMPLATES(16)\nCB710_REG_ACCESS_TEMPLATES(32)\n\nvoid cb710_dump_regs(struct cb710_chip *chip, unsigned select)\n{\n\tif (!(select & CB710_DUMP_REGS_MASK))\n\t\tselect = CB710_DUMP_REGS_ALL;\n\tif (!(select & CB710_DUMP_ACCESS_MASK))\n\t\tselect |= CB710_DUMP_ACCESS_8;\n\n\tif (select & CB710_DUMP_ACCESS_32)\n\t\tcb710_read_and_dump_regs_32(chip, select);\n\tif (select & CB710_DUMP_ACCESS_16)\n\t\tcb710_read_and_dump_regs_16(chip, select);\n\tif (select & CB710_DUMP_ACCESS_8)\n\t\tcb710_read_and_dump_regs_8(chip, select);\n}\nEXPORT_SYMBOL_GPL(cb710_dump_regs);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}