{
  "module_name": "xilinx_sdfec.c",
  "hash_id": "d807fb28b2e3d819ee3cce68b0907987ce8d2b0dc3bb49dc4d265ac0c1ed0d05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/xilinx_sdfec.c",
  "human_readable_source": "\n \n\n#include <linux/miscdevice.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/compat.h>\n#include <linux/highmem.h>\n\n#include <uapi/misc/xilinx_sdfec.h>\n\n#define DEV_NAME_LEN 12\n\nstatic DEFINE_IDA(dev_nrs);\n\n \n \n#define XSDFEC_CODE_WR_PROTECT_ADDR (0x4)\n\n \n#define XSDFEC_ACTIVE_ADDR (0x8)\n#define XSDFEC_IS_ACTIVITY_SET (0x1)\n\n \n#define XSDFEC_AXIS_WIDTH_ADDR (0xC)\n#define XSDFEC_AXIS_DOUT_WORDS_LSB (5)\n#define XSDFEC_AXIS_DOUT_WIDTH_LSB (3)\n#define XSDFEC_AXIS_DIN_WORDS_LSB (2)\n#define XSDFEC_AXIS_DIN_WIDTH_LSB (0)\n\n \n#define XSDFEC_AXIS_ENABLE_ADDR (0x10)\n#define XSDFEC_AXIS_OUT_ENABLE_MASK (0x38)\n#define XSDFEC_AXIS_IN_ENABLE_MASK (0x7)\n#define XSDFEC_AXIS_ENABLE_MASK                                                \\\n\t(XSDFEC_AXIS_OUT_ENABLE_MASK | XSDFEC_AXIS_IN_ENABLE_MASK)\n\n \n#define XSDFEC_FEC_CODE_ADDR (0x14)\n\n \n#define XSDFEC_ORDER_ADDR (0x18)\n\n \n#define XSDFEC_ISR_ADDR (0x1C)\n \n#define XSDFEC_ISR_MASK (0x3F)\n\n \n#define XSDFEC_IER_ADDR (0x20)\n \n#define XSDFEC_IDR_ADDR (0x24)\n \n#define XSDFEC_IMR_ADDR (0x28)\n\n \n#define XSDFEC_ECC_ISR_ADDR (0x2C)\n \n#define XSDFEC_ECC_ISR_SBE_MASK (0x7FF)\n \n#define XSDFEC_PL_INIT_ECC_ISR_SBE_MASK (0x3C00000)\n \n#define XSDFEC_ECC_ISR_MBE_MASK (0x3FF800)\n \n#define XSDFEC_PL_INIT_ECC_ISR_MBE_MASK (0x3C000000)\n \n#define XSDFEC_ECC_ISR_MBE_TO_EVENT_SHIFT (11)\n \n#define XSDFEC_PL_INIT_ECC_ISR_MBE_TO_EVENT_SHIFT (4)\n \n#define XSDFEC_ECC_ISR_MASK (XSDFEC_ECC_ISR_SBE_MASK | XSDFEC_ECC_ISR_MBE_MASK)\n \n#define XSDFEC_PL_INIT_ECC_ISR_MASK                                            \\\n\t(XSDFEC_PL_INIT_ECC_ISR_SBE_MASK | XSDFEC_PL_INIT_ECC_ISR_MBE_MASK)\n \n#define XSDFEC_ALL_ECC_ISR_MASK                                                \\\n\t(XSDFEC_ECC_ISR_MASK | XSDFEC_PL_INIT_ECC_ISR_MASK)\n \n#define XSDFEC_ALL_ECC_ISR_SBE_MASK                                            \\\n\t(XSDFEC_ECC_ISR_SBE_MASK | XSDFEC_PL_INIT_ECC_ISR_SBE_MASK)\n \n#define XSDFEC_ALL_ECC_ISR_MBE_MASK                                            \\\n\t(XSDFEC_ECC_ISR_MBE_MASK | XSDFEC_PL_INIT_ECC_ISR_MBE_MASK)\n\n \n#define XSDFEC_ECC_IER_ADDR (0x30)\n \n#define XSDFEC_ECC_IDR_ADDR (0x34)\n \n#define XSDFEC_ECC_IMR_ADDR (0x38)\n\n \n#define XSDFEC_BYPASS_ADDR (0x3C)\n\n \n#define XSDFEC_TURBO_ADDR (0x100)\n#define XSDFEC_TURBO_SCALE_MASK (0xFFF)\n#define XSDFEC_TURBO_SCALE_BIT_POS (8)\n#define XSDFEC_TURBO_SCALE_MAX (15)\n\n \n#define XSDFEC_LDPC_CODE_REG0_ADDR_BASE (0x2000)\n#define XSDFEC_LDPC_CODE_REG0_ADDR_HIGH (0x27F0)\n#define XSDFEC_REG0_N_MIN (4)\n#define XSDFEC_REG0_N_MAX (32768)\n#define XSDFEC_REG0_N_MUL_P (256)\n#define XSDFEC_REG0_N_LSB (0)\n#define XSDFEC_REG0_K_MIN (2)\n#define XSDFEC_REG0_K_MAX (32766)\n#define XSDFEC_REG0_K_MUL_P (256)\n#define XSDFEC_REG0_K_LSB (16)\n\n \n#define XSDFEC_LDPC_CODE_REG1_ADDR_BASE (0x2004)\n#define XSDFEC_LDPC_CODE_REG1_ADDR_HIGH (0x27f4)\n#define XSDFEC_REG1_PSIZE_MIN (2)\n#define XSDFEC_REG1_PSIZE_MAX (512)\n#define XSDFEC_REG1_NO_PACKING_MASK (0x400)\n#define XSDFEC_REG1_NO_PACKING_LSB (10)\n#define XSDFEC_REG1_NM_MASK (0xFF800)\n#define XSDFEC_REG1_NM_LSB (11)\n#define XSDFEC_REG1_BYPASS_MASK (0x100000)\n\n \n#define XSDFEC_LDPC_CODE_REG2_ADDR_BASE (0x2008)\n#define XSDFEC_LDPC_CODE_REG2_ADDR_HIGH (0x27f8)\n#define XSDFEC_REG2_NLAYERS_MIN (1)\n#define XSDFEC_REG2_NLAYERS_MAX (256)\n#define XSDFEC_REG2_NNMQC_MASK (0xFFE00)\n#define XSDFEC_REG2_NMQC_LSB (9)\n#define XSDFEC_REG2_NORM_TYPE_MASK (0x100000)\n#define XSDFEC_REG2_NORM_TYPE_LSB (20)\n#define XSDFEC_REG2_SPECIAL_QC_MASK (0x200000)\n#define XSDFEC_REG2_SPEICAL_QC_LSB (21)\n#define XSDFEC_REG2_NO_FINAL_PARITY_MASK (0x400000)\n#define XSDFEC_REG2_NO_FINAL_PARITY_LSB (22)\n#define XSDFEC_REG2_MAX_SCHEDULE_MASK (0x1800000)\n#define XSDFEC_REG2_MAX_SCHEDULE_LSB (23)\n\n \n#define XSDFEC_LDPC_CODE_REG3_ADDR_BASE (0x200C)\n#define XSDFEC_LDPC_CODE_REG3_ADDR_HIGH (0x27FC)\n#define XSDFEC_REG3_LA_OFF_LSB (8)\n#define XSDFEC_REG3_QC_OFF_LSB (16)\n\n#define XSDFEC_LDPC_REG_JUMP (0x10)\n#define XSDFEC_REG_WIDTH_JUMP (4)\n\n \n#define MAX_NUM_PAGES ((XSDFEC_QC_TABLE_DEPTH / PAGE_SIZE) + 1)\n\n \nstruct xsdfec_clks {\n\tstruct clk *core_clk;\n\tstruct clk *axi_clk;\n\tstruct clk *din_words_clk;\n\tstruct clk *din_clk;\n\tstruct clk *dout_clk;\n\tstruct clk *dout_words_clk;\n\tstruct clk *ctrl_clk;\n\tstruct clk *status_clk;\n};\n\n \nstruct xsdfec_dev {\n\tstruct miscdevice miscdev;\n\tstruct xsdfec_clks clks;\n\twait_queue_head_t waitq;\n\tstruct xsdfec_config config;\n\tchar dev_name[DEV_NAME_LEN];\n\tunsigned long flags;\n\tvoid __iomem *regs;\n\tstruct device *dev;\n\tenum xsdfec_state state;\n\t \n\tspinlock_t error_data_lock;\n\tint dev_id;\n\tu32 isr_err_count;\n\tu32 cecc_count;\n\tu32 uecc_count;\n\tint irq;\n\tbool state_updated;\n\tbool stats_updated;\n\tbool intr_enabled;\n};\n\nstatic inline void xsdfec_regwrite(struct xsdfec_dev *xsdfec, u32 addr,\n\t\t\t\t   u32 value)\n{\n\tdev_dbg(xsdfec->dev, \"Writing 0x%x to offset 0x%x\", value, addr);\n\tiowrite32(value, xsdfec->regs + addr);\n}\n\nstatic inline u32 xsdfec_regread(struct xsdfec_dev *xsdfec, u32 addr)\n{\n\tu32 rval;\n\n\trval = ioread32(xsdfec->regs + addr);\n\tdev_dbg(xsdfec->dev, \"Read value = 0x%x from offset 0x%x\", rval, addr);\n\treturn rval;\n}\n\nstatic void update_bool_config_from_reg(struct xsdfec_dev *xsdfec,\n\t\t\t\t\tu32 reg_offset, u32 bit_num,\n\t\t\t\t\tchar *config_value)\n{\n\tu32 reg_val;\n\tu32 bit_mask = 1 << bit_num;\n\n\treg_val = xsdfec_regread(xsdfec, reg_offset);\n\t*config_value = (reg_val & bit_mask) > 0;\n}\n\nstatic void update_config_from_hw(struct xsdfec_dev *xsdfec)\n{\n\tu32 reg_value;\n\tbool sdfec_started;\n\n\t \n\treg_value = xsdfec_regread(xsdfec, XSDFEC_ORDER_ADDR);\n\txsdfec->config.order = reg_value;\n\n\tupdate_bool_config_from_reg(xsdfec, XSDFEC_BYPASS_ADDR,\n\t\t\t\t    0,  \n\t\t\t\t    &xsdfec->config.bypass);\n\n\tupdate_bool_config_from_reg(xsdfec, XSDFEC_CODE_WR_PROTECT_ADDR,\n\t\t\t\t    0,  \n\t\t\t\t    &xsdfec->config.code_wr_protect);\n\n\treg_value = xsdfec_regread(xsdfec, XSDFEC_IMR_ADDR);\n\txsdfec->config.irq.enable_isr = (reg_value & XSDFEC_ISR_MASK) > 0;\n\n\treg_value = xsdfec_regread(xsdfec, XSDFEC_ECC_IMR_ADDR);\n\txsdfec->config.irq.enable_ecc_isr =\n\t\t(reg_value & XSDFEC_ECC_ISR_MASK) > 0;\n\n\treg_value = xsdfec_regread(xsdfec, XSDFEC_AXIS_ENABLE_ADDR);\n\tsdfec_started = (reg_value & XSDFEC_AXIS_IN_ENABLE_MASK) > 0;\n\tif (sdfec_started)\n\t\txsdfec->state = XSDFEC_STARTED;\n\telse\n\t\txsdfec->state = XSDFEC_STOPPED;\n}\n\nstatic int xsdfec_get_status(struct xsdfec_dev *xsdfec, void __user *arg)\n{\n\tstruct xsdfec_status status;\n\tint err;\n\n\tmemset(&status, 0, sizeof(status));\n\tspin_lock_irqsave(&xsdfec->error_data_lock, xsdfec->flags);\n\tstatus.state = xsdfec->state;\n\txsdfec->state_updated = false;\n\tspin_unlock_irqrestore(&xsdfec->error_data_lock, xsdfec->flags);\n\tstatus.activity = (xsdfec_regread(xsdfec, XSDFEC_ACTIVE_ADDR) &\n\t\t\t   XSDFEC_IS_ACTIVITY_SET);\n\n\terr = copy_to_user(arg, &status, sizeof(status));\n\tif (err)\n\t\terr = -EFAULT;\n\n\treturn err;\n}\n\nstatic int xsdfec_get_config(struct xsdfec_dev *xsdfec, void __user *arg)\n{\n\tint err;\n\n\terr = copy_to_user(arg, &xsdfec->config, sizeof(xsdfec->config));\n\tif (err)\n\t\terr = -EFAULT;\n\n\treturn err;\n}\n\nstatic int xsdfec_isr_enable(struct xsdfec_dev *xsdfec, bool enable)\n{\n\tu32 mask_read;\n\n\tif (enable) {\n\t\t \n\t\txsdfec_regwrite(xsdfec, XSDFEC_IER_ADDR, XSDFEC_ISR_MASK);\n\t\tmask_read = xsdfec_regread(xsdfec, XSDFEC_IMR_ADDR);\n\t\tif (mask_read & XSDFEC_ISR_MASK) {\n\t\t\tdev_dbg(xsdfec->dev,\n\t\t\t\t\"SDFEC enabling irq with IER failed\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t \n\t\txsdfec_regwrite(xsdfec, XSDFEC_IDR_ADDR, XSDFEC_ISR_MASK);\n\t\tmask_read = xsdfec_regread(xsdfec, XSDFEC_IMR_ADDR);\n\t\tif ((mask_read & XSDFEC_ISR_MASK) != XSDFEC_ISR_MASK) {\n\t\t\tdev_dbg(xsdfec->dev,\n\t\t\t\t\"SDFEC disabling irq with IDR failed\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int xsdfec_ecc_isr_enable(struct xsdfec_dev *xsdfec, bool enable)\n{\n\tu32 mask_read;\n\n\tif (enable) {\n\t\t \n\t\txsdfec_regwrite(xsdfec, XSDFEC_ECC_IER_ADDR,\n\t\t\t\tXSDFEC_ALL_ECC_ISR_MASK);\n\t\tmask_read = xsdfec_regread(xsdfec, XSDFEC_ECC_IMR_ADDR);\n\t\tif (mask_read & XSDFEC_ALL_ECC_ISR_MASK) {\n\t\t\tdev_dbg(xsdfec->dev,\n\t\t\t\t\"SDFEC enabling ECC irq with ECC IER failed\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t \n\t\txsdfec_regwrite(xsdfec, XSDFEC_ECC_IDR_ADDR,\n\t\t\t\tXSDFEC_ALL_ECC_ISR_MASK);\n\t\tmask_read = xsdfec_regread(xsdfec, XSDFEC_ECC_IMR_ADDR);\n\t\tif (!(((mask_read & XSDFEC_ALL_ECC_ISR_MASK) ==\n\t\t       XSDFEC_ECC_ISR_MASK) ||\n\t\t      ((mask_read & XSDFEC_ALL_ECC_ISR_MASK) ==\n\t\t       XSDFEC_PL_INIT_ECC_ISR_MASK))) {\n\t\t\tdev_dbg(xsdfec->dev,\n\t\t\t\t\"SDFEC disable ECC irq with ECC IDR failed\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int xsdfec_set_irq(struct xsdfec_dev *xsdfec, void __user *arg)\n{\n\tstruct xsdfec_irq irq;\n\tint err;\n\tint isr_err;\n\tint ecc_err;\n\n\terr = copy_from_user(&irq, arg, sizeof(irq));\n\tif (err)\n\t\treturn -EFAULT;\n\n\t \n\tisr_err = xsdfec_isr_enable(xsdfec, irq.enable_isr);\n\tif (!isr_err)\n\t\txsdfec->config.irq.enable_isr = irq.enable_isr;\n\n\t \n\tecc_err = xsdfec_ecc_isr_enable(xsdfec, irq.enable_ecc_isr);\n\tif (!ecc_err)\n\t\txsdfec->config.irq.enable_ecc_isr = irq.enable_ecc_isr;\n\n\tif (isr_err < 0 || ecc_err < 0)\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nstatic int xsdfec_set_turbo(struct xsdfec_dev *xsdfec, void __user *arg)\n{\n\tstruct xsdfec_turbo turbo;\n\tint err;\n\tu32 turbo_write;\n\n\terr = copy_from_user(&turbo, arg, sizeof(turbo));\n\tif (err)\n\t\treturn -EFAULT;\n\n\tif (turbo.alg >= XSDFEC_TURBO_ALG_MAX)\n\t\treturn -EINVAL;\n\n\tif (turbo.scale > XSDFEC_TURBO_SCALE_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tif (xsdfec->config.code == XSDFEC_LDPC_CODE)\n\t\treturn -EIO;\n\n\tturbo_write = ((turbo.scale & XSDFEC_TURBO_SCALE_MASK)\n\t\t       << XSDFEC_TURBO_SCALE_BIT_POS) |\n\t\t      turbo.alg;\n\txsdfec_regwrite(xsdfec, XSDFEC_TURBO_ADDR, turbo_write);\n\treturn err;\n}\n\nstatic int xsdfec_get_turbo(struct xsdfec_dev *xsdfec, void __user *arg)\n{\n\tu32 reg_value;\n\tstruct xsdfec_turbo turbo_params;\n\tint err;\n\n\tif (xsdfec->config.code == XSDFEC_LDPC_CODE)\n\t\treturn -EIO;\n\n\tmemset(&turbo_params, 0, sizeof(turbo_params));\n\treg_value = xsdfec_regread(xsdfec, XSDFEC_TURBO_ADDR);\n\n\tturbo_params.scale = (reg_value & XSDFEC_TURBO_SCALE_MASK) >>\n\t\t\t     XSDFEC_TURBO_SCALE_BIT_POS;\n\tturbo_params.alg = reg_value & 0x1;\n\n\terr = copy_to_user(arg, &turbo_params, sizeof(turbo_params));\n\tif (err)\n\t\terr = -EFAULT;\n\n\treturn err;\n}\n\nstatic int xsdfec_reg0_write(struct xsdfec_dev *xsdfec, u32 n, u32 k, u32 psize,\n\t\t\t     u32 offset)\n{\n\tu32 wdata;\n\n\tif (n < XSDFEC_REG0_N_MIN || n > XSDFEC_REG0_N_MAX || psize == 0 ||\n\t    (n > XSDFEC_REG0_N_MUL_P * psize) || n <= k || ((n % psize) != 0)) {\n\t\tdev_dbg(xsdfec->dev, \"N value is not in range\");\n\t\treturn -EINVAL;\n\t}\n\tn <<= XSDFEC_REG0_N_LSB;\n\n\tif (k < XSDFEC_REG0_K_MIN || k > XSDFEC_REG0_K_MAX ||\n\t    (k > XSDFEC_REG0_K_MUL_P * psize) || ((k % psize) != 0)) {\n\t\tdev_dbg(xsdfec->dev, \"K value is not in range\");\n\t\treturn -EINVAL;\n\t}\n\tk = k << XSDFEC_REG0_K_LSB;\n\twdata = k | n;\n\n\tif (XSDFEC_LDPC_CODE_REG0_ADDR_BASE + (offset * XSDFEC_LDPC_REG_JUMP) >\n\t    XSDFEC_LDPC_CODE_REG0_ADDR_HIGH) {\n\t\tdev_dbg(xsdfec->dev, \"Writing outside of LDPC reg0 space 0x%x\",\n\t\t\tXSDFEC_LDPC_CODE_REG0_ADDR_BASE +\n\t\t\t\t(offset * XSDFEC_LDPC_REG_JUMP));\n\t\treturn -EINVAL;\n\t}\n\txsdfec_regwrite(xsdfec,\n\t\t\tXSDFEC_LDPC_CODE_REG0_ADDR_BASE +\n\t\t\t\t(offset * XSDFEC_LDPC_REG_JUMP),\n\t\t\twdata);\n\treturn 0;\n}\n\nstatic int xsdfec_reg1_write(struct xsdfec_dev *xsdfec, u32 psize,\n\t\t\t     u32 no_packing, u32 nm, u32 offset)\n{\n\tu32 wdata;\n\n\tif (psize < XSDFEC_REG1_PSIZE_MIN || psize > XSDFEC_REG1_PSIZE_MAX) {\n\t\tdev_dbg(xsdfec->dev, \"Psize is not in range\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (no_packing != 0 && no_packing != 1)\n\t\tdev_dbg(xsdfec->dev, \"No-packing bit register invalid\");\n\tno_packing = ((no_packing << XSDFEC_REG1_NO_PACKING_LSB) &\n\t\t      XSDFEC_REG1_NO_PACKING_MASK);\n\n\tif (nm & ~(XSDFEC_REG1_NM_MASK >> XSDFEC_REG1_NM_LSB))\n\t\tdev_dbg(xsdfec->dev, \"NM is beyond 10 bits\");\n\tnm = (nm << XSDFEC_REG1_NM_LSB) & XSDFEC_REG1_NM_MASK;\n\n\twdata = nm | no_packing | psize;\n\tif (XSDFEC_LDPC_CODE_REG1_ADDR_BASE + (offset * XSDFEC_LDPC_REG_JUMP) >\n\t    XSDFEC_LDPC_CODE_REG1_ADDR_HIGH) {\n\t\tdev_dbg(xsdfec->dev, \"Writing outside of LDPC reg1 space 0x%x\",\n\t\t\tXSDFEC_LDPC_CODE_REG1_ADDR_BASE +\n\t\t\t\t(offset * XSDFEC_LDPC_REG_JUMP));\n\t\treturn -EINVAL;\n\t}\n\txsdfec_regwrite(xsdfec,\n\t\t\tXSDFEC_LDPC_CODE_REG1_ADDR_BASE +\n\t\t\t\t(offset * XSDFEC_LDPC_REG_JUMP),\n\t\t\twdata);\n\treturn 0;\n}\n\nstatic int xsdfec_reg2_write(struct xsdfec_dev *xsdfec, u32 nlayers, u32 nmqc,\n\t\t\t     u32 norm_type, u32 special_qc, u32 no_final_parity,\n\t\t\t     u32 max_schedule, u32 offset)\n{\n\tu32 wdata;\n\n\tif (nlayers < XSDFEC_REG2_NLAYERS_MIN ||\n\t    nlayers > XSDFEC_REG2_NLAYERS_MAX) {\n\t\tdev_dbg(xsdfec->dev, \"Nlayers is not in range\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nmqc & ~(XSDFEC_REG2_NNMQC_MASK >> XSDFEC_REG2_NMQC_LSB))\n\t\tdev_dbg(xsdfec->dev, \"NMQC exceeds 11 bits\");\n\tnmqc = (nmqc << XSDFEC_REG2_NMQC_LSB) & XSDFEC_REG2_NNMQC_MASK;\n\n\tif (norm_type > 1)\n\t\tdev_dbg(xsdfec->dev, \"Norm type is invalid\");\n\tnorm_type = ((norm_type << XSDFEC_REG2_NORM_TYPE_LSB) &\n\t\t     XSDFEC_REG2_NORM_TYPE_MASK);\n\tif (special_qc > 1)\n\t\tdev_dbg(xsdfec->dev, \"Special QC in invalid\");\n\tspecial_qc = ((special_qc << XSDFEC_REG2_SPEICAL_QC_LSB) &\n\t\t      XSDFEC_REG2_SPECIAL_QC_MASK);\n\n\tif (no_final_parity > 1)\n\t\tdev_dbg(xsdfec->dev, \"No final parity check invalid\");\n\tno_final_parity =\n\t\t((no_final_parity << XSDFEC_REG2_NO_FINAL_PARITY_LSB) &\n\t\t XSDFEC_REG2_NO_FINAL_PARITY_MASK);\n\tif (max_schedule &\n\t    ~(XSDFEC_REG2_MAX_SCHEDULE_MASK >> XSDFEC_REG2_MAX_SCHEDULE_LSB))\n\t\tdev_dbg(xsdfec->dev, \"Max Schedule exceeds 2 bits\");\n\tmax_schedule = ((max_schedule << XSDFEC_REG2_MAX_SCHEDULE_LSB) &\n\t\t\tXSDFEC_REG2_MAX_SCHEDULE_MASK);\n\n\twdata = (max_schedule | no_final_parity | special_qc | norm_type |\n\t\t nmqc | nlayers);\n\n\tif (XSDFEC_LDPC_CODE_REG2_ADDR_BASE + (offset * XSDFEC_LDPC_REG_JUMP) >\n\t    XSDFEC_LDPC_CODE_REG2_ADDR_HIGH) {\n\t\tdev_dbg(xsdfec->dev, \"Writing outside of LDPC reg2 space 0x%x\",\n\t\t\tXSDFEC_LDPC_CODE_REG2_ADDR_BASE +\n\t\t\t\t(offset * XSDFEC_LDPC_REG_JUMP));\n\t\treturn -EINVAL;\n\t}\n\txsdfec_regwrite(xsdfec,\n\t\t\tXSDFEC_LDPC_CODE_REG2_ADDR_BASE +\n\t\t\t\t(offset * XSDFEC_LDPC_REG_JUMP),\n\t\t\twdata);\n\treturn 0;\n}\n\nstatic int xsdfec_reg3_write(struct xsdfec_dev *xsdfec, u8 sc_off, u8 la_off,\n\t\t\t     u16 qc_off, u32 offset)\n{\n\tu32 wdata;\n\n\twdata = ((qc_off << XSDFEC_REG3_QC_OFF_LSB) |\n\t\t (la_off << XSDFEC_REG3_LA_OFF_LSB) | sc_off);\n\tif (XSDFEC_LDPC_CODE_REG3_ADDR_BASE + (offset * XSDFEC_LDPC_REG_JUMP) >\n\t    XSDFEC_LDPC_CODE_REG3_ADDR_HIGH) {\n\t\tdev_dbg(xsdfec->dev, \"Writing outside of LDPC reg3 space 0x%x\",\n\t\t\tXSDFEC_LDPC_CODE_REG3_ADDR_BASE +\n\t\t\t\t(offset * XSDFEC_LDPC_REG_JUMP));\n\t\treturn -EINVAL;\n\t}\n\txsdfec_regwrite(xsdfec,\n\t\t\tXSDFEC_LDPC_CODE_REG3_ADDR_BASE +\n\t\t\t\t(offset * XSDFEC_LDPC_REG_JUMP),\n\t\t\twdata);\n\treturn 0;\n}\n\nstatic int xsdfec_table_write(struct xsdfec_dev *xsdfec, u32 offset,\n\t\t\t      u32 *src_ptr, u32 len, const u32 base_addr,\n\t\t\t      const u32 depth)\n{\n\tu32 reg = 0;\n\tint res, i, nr_pages;\n\tu32 n;\n\tu32 *addr = NULL;\n\tstruct page *pages[MAX_NUM_PAGES];\n\n\t \n\tif (offset > depth / XSDFEC_REG_WIDTH_JUMP ||\n\t    len > depth / XSDFEC_REG_WIDTH_JUMP ||\n\t    offset + len > depth / XSDFEC_REG_WIDTH_JUMP) {\n\t\tdev_dbg(xsdfec->dev, \"Write exceeds SC table length\");\n\t\treturn -EINVAL;\n\t}\n\n\tn = (len * XSDFEC_REG_WIDTH_JUMP) / PAGE_SIZE;\n\tif ((len * XSDFEC_REG_WIDTH_JUMP) % PAGE_SIZE)\n\t\tn += 1;\n\n\tif (WARN_ON_ONCE(n > INT_MAX))\n\t\treturn -EINVAL;\n\n\tnr_pages = n;\n\n\tres = pin_user_pages_fast((unsigned long)src_ptr, nr_pages, 0, pages);\n\tif (res < nr_pages) {\n\t\tif (res > 0)\n\t\t\tunpin_user_pages(pages, res);\n\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\taddr = kmap_local_page(pages[i]);\n\t\tdo {\n\t\t\txsdfec_regwrite(xsdfec,\n\t\t\t\t\tbase_addr + ((offset + reg) *\n\t\t\t\t\t\t     XSDFEC_REG_WIDTH_JUMP),\n\t\t\t\t\taddr[reg]);\n\t\t\treg++;\n\t\t} while ((reg < len) &&\n\t\t\t ((reg * XSDFEC_REG_WIDTH_JUMP) % PAGE_SIZE));\n\t\tkunmap_local(addr);\n\t\tunpin_user_page(pages[i]);\n\t}\n\treturn 0;\n}\n\nstatic int xsdfec_add_ldpc(struct xsdfec_dev *xsdfec, void __user *arg)\n{\n\tstruct xsdfec_ldpc_params *ldpc;\n\tint ret, n;\n\n\tldpc = memdup_user(arg, sizeof(*ldpc));\n\tif (IS_ERR(ldpc))\n\t\treturn PTR_ERR(ldpc);\n\n\tif (xsdfec->config.code == XSDFEC_TURBO_CODE) {\n\t\tret = -EIO;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (xsdfec->state == XSDFEC_STARTED) {\n\t\tret = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (xsdfec->config.code_wr_protect) {\n\t\tret = -EIO;\n\t\tgoto err_out;\n\t}\n\n\t \n\tret = xsdfec_reg0_write(xsdfec, ldpc->n, ldpc->k, ldpc->psize,\n\t\t\t\tldpc->code_id);\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\tret = xsdfec_reg1_write(xsdfec, ldpc->psize, ldpc->no_packing, ldpc->nm,\n\t\t\t\tldpc->code_id);\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\tret = xsdfec_reg2_write(xsdfec, ldpc->nlayers, ldpc->nmqc,\n\t\t\t\tldpc->norm_type, ldpc->special_qc,\n\t\t\t\tldpc->no_final_parity, ldpc->max_schedule,\n\t\t\t\tldpc->code_id);\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\tret = xsdfec_reg3_write(xsdfec, ldpc->sc_off, ldpc->la_off,\n\t\t\t\tldpc->qc_off, ldpc->code_id);\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\tn = ldpc->nlayers / 4;\n\tif (ldpc->nlayers % 4)\n\t\tn++;\n\n\tret = xsdfec_table_write(xsdfec, ldpc->sc_off, ldpc->sc_table, n,\n\t\t\t\t XSDFEC_LDPC_SC_TABLE_ADDR_BASE,\n\t\t\t\t XSDFEC_SC_TABLE_DEPTH);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\tret = xsdfec_table_write(xsdfec, 4 * ldpc->la_off, ldpc->la_table,\n\t\t\t\t ldpc->nlayers, XSDFEC_LDPC_LA_TABLE_ADDR_BASE,\n\t\t\t\t XSDFEC_LA_TABLE_DEPTH);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\tret = xsdfec_table_write(xsdfec, 4 * ldpc->qc_off, ldpc->qc_table,\n\t\t\t\t ldpc->nqc, XSDFEC_LDPC_QC_TABLE_ADDR_BASE,\n\t\t\t\t XSDFEC_QC_TABLE_DEPTH);\nerr_out:\n\tkfree(ldpc);\n\treturn ret;\n}\n\nstatic int xsdfec_set_order(struct xsdfec_dev *xsdfec, void __user *arg)\n{\n\tbool order_invalid;\n\tenum xsdfec_order order;\n\tint err;\n\n\terr = get_user(order, (enum xsdfec_order __user *)arg);\n\tif (err)\n\t\treturn -EFAULT;\n\n\torder_invalid = (order != XSDFEC_MAINTAIN_ORDER) &&\n\t\t\t(order != XSDFEC_OUT_OF_ORDER);\n\tif (order_invalid)\n\t\treturn -EINVAL;\n\n\t \n\tif (xsdfec->state == XSDFEC_STARTED)\n\t\treturn -EIO;\n\n\txsdfec_regwrite(xsdfec, XSDFEC_ORDER_ADDR, order);\n\n\txsdfec->config.order = order;\n\n\treturn 0;\n}\n\nstatic int xsdfec_set_bypass(struct xsdfec_dev *xsdfec, bool __user *arg)\n{\n\tbool bypass;\n\tint err;\n\n\terr = get_user(bypass, arg);\n\tif (err)\n\t\treturn -EFAULT;\n\n\t \n\tif (xsdfec->state == XSDFEC_STARTED)\n\t\treturn -EIO;\n\n\tif (bypass)\n\t\txsdfec_regwrite(xsdfec, XSDFEC_BYPASS_ADDR, 1);\n\telse\n\t\txsdfec_regwrite(xsdfec, XSDFEC_BYPASS_ADDR, 0);\n\n\txsdfec->config.bypass = bypass;\n\n\treturn 0;\n}\n\nstatic int xsdfec_is_active(struct xsdfec_dev *xsdfec, bool __user *arg)\n{\n\tu32 reg_value;\n\tbool is_active;\n\tint err;\n\n\treg_value = xsdfec_regread(xsdfec, XSDFEC_ACTIVE_ADDR);\n\t \n\tis_active = !!(reg_value & XSDFEC_IS_ACTIVITY_SET);\n\terr = put_user(is_active, arg);\n\tif (err)\n\t\treturn -EFAULT;\n\n\treturn err;\n}\n\nstatic u32\nxsdfec_translate_axis_width_cfg_val(enum xsdfec_axis_width axis_width_cfg)\n{\n\tu32 axis_width_field = 0;\n\n\tswitch (axis_width_cfg) {\n\tcase XSDFEC_1x128b:\n\t\taxis_width_field = 0;\n\t\tbreak;\n\tcase XSDFEC_2x128b:\n\t\taxis_width_field = 1;\n\t\tbreak;\n\tcase XSDFEC_4x128b:\n\t\taxis_width_field = 2;\n\t\tbreak;\n\t}\n\n\treturn axis_width_field;\n}\n\nstatic u32 xsdfec_translate_axis_words_cfg_val(enum xsdfec_axis_word_include\n\taxis_word_inc_cfg)\n{\n\tu32 axis_words_field = 0;\n\n\tif (axis_word_inc_cfg == XSDFEC_FIXED_VALUE ||\n\t    axis_word_inc_cfg == XSDFEC_IN_BLOCK)\n\t\taxis_words_field = 0;\n\telse if (axis_word_inc_cfg == XSDFEC_PER_AXI_TRANSACTION)\n\t\taxis_words_field = 1;\n\n\treturn axis_words_field;\n}\n\nstatic int xsdfec_cfg_axi_streams(struct xsdfec_dev *xsdfec)\n{\n\tu32 reg_value;\n\tu32 dout_words_field;\n\tu32 dout_width_field;\n\tu32 din_words_field;\n\tu32 din_width_field;\n\tstruct xsdfec_config *config = &xsdfec->config;\n\n\t \n\tdout_words_field =\n\t\txsdfec_translate_axis_words_cfg_val(config->dout_word_include);\n\tdout_width_field =\n\t\txsdfec_translate_axis_width_cfg_val(config->dout_width);\n\tdin_words_field =\n\t\txsdfec_translate_axis_words_cfg_val(config->din_word_include);\n\tdin_width_field =\n\t\txsdfec_translate_axis_width_cfg_val(config->din_width);\n\n\treg_value = dout_words_field << XSDFEC_AXIS_DOUT_WORDS_LSB;\n\treg_value |= dout_width_field << XSDFEC_AXIS_DOUT_WIDTH_LSB;\n\treg_value |= din_words_field << XSDFEC_AXIS_DIN_WORDS_LSB;\n\treg_value |= din_width_field << XSDFEC_AXIS_DIN_WIDTH_LSB;\n\n\txsdfec_regwrite(xsdfec, XSDFEC_AXIS_WIDTH_ADDR, reg_value);\n\n\treturn 0;\n}\n\nstatic int xsdfec_start(struct xsdfec_dev *xsdfec)\n{\n\tu32 regread;\n\n\tregread = xsdfec_regread(xsdfec, XSDFEC_FEC_CODE_ADDR);\n\tregread &= 0x1;\n\tif (regread != xsdfec->config.code) {\n\t\tdev_dbg(xsdfec->dev,\n\t\t\t\"%s SDFEC HW code does not match driver code, reg %d, code %d\",\n\t\t\t__func__, regread, xsdfec->config.code);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\txsdfec_regwrite(xsdfec, XSDFEC_AXIS_ENABLE_ADDR,\n\t\t\tXSDFEC_AXIS_ENABLE_MASK);\n\t \n\txsdfec->state = XSDFEC_STARTED;\n\treturn 0;\n}\n\nstatic int xsdfec_stop(struct xsdfec_dev *xsdfec)\n{\n\tu32 regread;\n\n\tif (xsdfec->state != XSDFEC_STARTED)\n\t\tdev_dbg(xsdfec->dev, \"Device not started correctly\");\n\t \n\tregread = xsdfec_regread(xsdfec, XSDFEC_AXIS_ENABLE_ADDR);\n\tregread &= (~XSDFEC_AXIS_IN_ENABLE_MASK);\n\txsdfec_regwrite(xsdfec, XSDFEC_AXIS_ENABLE_ADDR, regread);\n\t \n\txsdfec->state = XSDFEC_STOPPED;\n\treturn 0;\n}\n\nstatic int xsdfec_clear_stats(struct xsdfec_dev *xsdfec)\n{\n\tspin_lock_irqsave(&xsdfec->error_data_lock, xsdfec->flags);\n\txsdfec->isr_err_count = 0;\n\txsdfec->uecc_count = 0;\n\txsdfec->cecc_count = 0;\n\tspin_unlock_irqrestore(&xsdfec->error_data_lock, xsdfec->flags);\n\n\treturn 0;\n}\n\nstatic int xsdfec_get_stats(struct xsdfec_dev *xsdfec, void __user *arg)\n{\n\tint err;\n\tstruct xsdfec_stats user_stats;\n\n\tspin_lock_irqsave(&xsdfec->error_data_lock, xsdfec->flags);\n\tuser_stats.isr_err_count = xsdfec->isr_err_count;\n\tuser_stats.cecc_count = xsdfec->cecc_count;\n\tuser_stats.uecc_count = xsdfec->uecc_count;\n\txsdfec->stats_updated = false;\n\tspin_unlock_irqrestore(&xsdfec->error_data_lock, xsdfec->flags);\n\n\terr = copy_to_user(arg, &user_stats, sizeof(user_stats));\n\tif (err)\n\t\terr = -EFAULT;\n\n\treturn err;\n}\n\nstatic int xsdfec_set_default_config(struct xsdfec_dev *xsdfec)\n{\n\t \n\txsdfec_regwrite(xsdfec, XSDFEC_FEC_CODE_ADDR, xsdfec->config.code);\n\txsdfec_cfg_axi_streams(xsdfec);\n\tupdate_config_from_hw(xsdfec);\n\n\treturn 0;\n}\n\nstatic long xsdfec_dev_ioctl(struct file *fptr, unsigned int cmd,\n\t\t\t     unsigned long data)\n{\n\tstruct xsdfec_dev *xsdfec;\n\tvoid __user *arg = (void __user *)data;\n\tint rval;\n\n\txsdfec = container_of(fptr->private_data, struct xsdfec_dev, miscdev);\n\n\t \n\tif (xsdfec->state == XSDFEC_NEEDS_RESET &&\n\t    (cmd != XSDFEC_SET_DEFAULT_CONFIG && cmd != XSDFEC_GET_STATUS &&\n\t     cmd != XSDFEC_GET_STATS && cmd != XSDFEC_CLEAR_STATS)) {\n\t\treturn -EPERM;\n\t}\n\n\tswitch (cmd) {\n\tcase XSDFEC_START_DEV:\n\t\trval = xsdfec_start(xsdfec);\n\t\tbreak;\n\tcase XSDFEC_STOP_DEV:\n\t\trval = xsdfec_stop(xsdfec);\n\t\tbreak;\n\tcase XSDFEC_CLEAR_STATS:\n\t\trval = xsdfec_clear_stats(xsdfec);\n\t\tbreak;\n\tcase XSDFEC_GET_STATS:\n\t\trval = xsdfec_get_stats(xsdfec, arg);\n\t\tbreak;\n\tcase XSDFEC_GET_STATUS:\n\t\trval = xsdfec_get_status(xsdfec, arg);\n\t\tbreak;\n\tcase XSDFEC_GET_CONFIG:\n\t\trval = xsdfec_get_config(xsdfec, arg);\n\t\tbreak;\n\tcase XSDFEC_SET_DEFAULT_CONFIG:\n\t\trval = xsdfec_set_default_config(xsdfec);\n\t\tbreak;\n\tcase XSDFEC_SET_IRQ:\n\t\trval = xsdfec_set_irq(xsdfec, arg);\n\t\tbreak;\n\tcase XSDFEC_SET_TURBO:\n\t\trval = xsdfec_set_turbo(xsdfec, arg);\n\t\tbreak;\n\tcase XSDFEC_GET_TURBO:\n\t\trval = xsdfec_get_turbo(xsdfec, arg);\n\t\tbreak;\n\tcase XSDFEC_ADD_LDPC_CODE_PARAMS:\n\t\trval = xsdfec_add_ldpc(xsdfec, arg);\n\t\tbreak;\n\tcase XSDFEC_SET_ORDER:\n\t\trval = xsdfec_set_order(xsdfec, arg);\n\t\tbreak;\n\tcase XSDFEC_SET_BYPASS:\n\t\trval = xsdfec_set_bypass(xsdfec, arg);\n\t\tbreak;\n\tcase XSDFEC_IS_ACTIVE:\n\t\trval = xsdfec_is_active(xsdfec, (bool __user *)arg);\n\t\tbreak;\n\tdefault:\n\t\trval = -ENOTTY;\n\t\tbreak;\n\t}\n\treturn rval;\n}\n\nstatic __poll_t xsdfec_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t mask = 0;\n\tstruct xsdfec_dev *xsdfec;\n\n\txsdfec = container_of(file->private_data, struct xsdfec_dev, miscdev);\n\n\tpoll_wait(file, &xsdfec->waitq, wait);\n\n\t \n\tspin_lock_irqsave(&xsdfec->error_data_lock, xsdfec->flags);\n\tif (xsdfec->state_updated)\n\t\tmask |= EPOLLIN | EPOLLPRI;\n\n\tif (xsdfec->stats_updated)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tspin_unlock_irqrestore(&xsdfec->error_data_lock, xsdfec->flags);\n\n\treturn mask;\n}\n\nstatic const struct file_operations xsdfec_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = xsdfec_dev_ioctl,\n\t.poll = xsdfec_poll,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\nstatic int xsdfec_parse_of(struct xsdfec_dev *xsdfec)\n{\n\tstruct device *dev = xsdfec->dev;\n\tstruct device_node *node = dev->of_node;\n\tint rval;\n\tconst char *fec_code;\n\tu32 din_width;\n\tu32 din_word_include;\n\tu32 dout_width;\n\tu32 dout_word_include;\n\n\trval = of_property_read_string(node, \"xlnx,sdfec-code\", &fec_code);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (!strcasecmp(fec_code, \"ldpc\"))\n\t\txsdfec->config.code = XSDFEC_LDPC_CODE;\n\telse if (!strcasecmp(fec_code, \"turbo\"))\n\t\txsdfec->config.code = XSDFEC_TURBO_CODE;\n\telse\n\t\treturn -EINVAL;\n\n\trval = of_property_read_u32(node, \"xlnx,sdfec-din-words\",\n\t\t\t\t    &din_word_include);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (din_word_include < XSDFEC_AXIS_WORDS_INCLUDE_MAX)\n\t\txsdfec->config.din_word_include = din_word_include;\n\telse\n\t\treturn -EINVAL;\n\n\trval = of_property_read_u32(node, \"xlnx,sdfec-din-width\", &din_width);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tswitch (din_width) {\n\t \n\tcase XSDFEC_1x128b:\n\tcase XSDFEC_2x128b:\n\tcase XSDFEC_4x128b:\n\t\txsdfec->config.din_width = din_width;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trval = of_property_read_u32(node, \"xlnx,sdfec-dout-words\",\n\t\t\t\t    &dout_word_include);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (dout_word_include < XSDFEC_AXIS_WORDS_INCLUDE_MAX)\n\t\txsdfec->config.dout_word_include = dout_word_include;\n\telse\n\t\treturn -EINVAL;\n\n\trval = of_property_read_u32(node, \"xlnx,sdfec-dout-width\", &dout_width);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tswitch (dout_width) {\n\t \n\tcase XSDFEC_1x128b:\n\tcase XSDFEC_2x128b:\n\tcase XSDFEC_4x128b:\n\t\txsdfec->config.dout_width = dout_width;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\txsdfec_regwrite(xsdfec, XSDFEC_FEC_CODE_ADDR, xsdfec->config.code);\n\n\txsdfec_cfg_axi_streams(xsdfec);\n\n\treturn 0;\n}\n\nstatic irqreturn_t xsdfec_irq_thread(int irq, void *dev_id)\n{\n\tstruct xsdfec_dev *xsdfec = dev_id;\n\tirqreturn_t ret = IRQ_HANDLED;\n\tu32 ecc_err;\n\tu32 isr_err;\n\tu32 uecc_count;\n\tu32 cecc_count;\n\tu32 isr_err_count;\n\tu32 aecc_count;\n\tu32 tmp;\n\n\tWARN_ON(xsdfec->irq != irq);\n\n\t \n\txsdfec_isr_enable(xsdfec, false);\n\txsdfec_ecc_isr_enable(xsdfec, false);\n\t \n\tecc_err = xsdfec_regread(xsdfec, XSDFEC_ECC_ISR_ADDR);\n\tisr_err = xsdfec_regread(xsdfec, XSDFEC_ISR_ADDR);\n\t \n\txsdfec_regwrite(xsdfec, XSDFEC_ECC_ISR_ADDR, ecc_err);\n\txsdfec_regwrite(xsdfec, XSDFEC_ISR_ADDR, isr_err);\n\n\ttmp = ecc_err & XSDFEC_ALL_ECC_ISR_MBE_MASK;\n\t \n\tuecc_count = hweight32(tmp);\n\t \n\taecc_count = hweight32(ecc_err);\n\t \n\tcecc_count = aecc_count - 2 * uecc_count;\n\t \n\tisr_err_count = hweight32(isr_err);\n\tdev_dbg(xsdfec->dev, \"tmp=%x, uecc=%x, aecc=%x, cecc=%x, isr=%x\", tmp,\n\t\tuecc_count, aecc_count, cecc_count, isr_err_count);\n\tdev_dbg(xsdfec->dev, \"uecc=%x, cecc=%x, isr=%x\", xsdfec->uecc_count,\n\t\txsdfec->cecc_count, xsdfec->isr_err_count);\n\n\tspin_lock_irqsave(&xsdfec->error_data_lock, xsdfec->flags);\n\t \n\tif (uecc_count)\n\t\txsdfec->uecc_count += uecc_count;\n\t \n\tif (cecc_count)\n\t\txsdfec->cecc_count += cecc_count;\n\t \n\tif (isr_err_count)\n\t\txsdfec->isr_err_count += isr_err_count;\n\n\t \n\tif (uecc_count) {\n\t\tif (ecc_err & XSDFEC_ECC_ISR_MBE_MASK)\n\t\t\txsdfec->state = XSDFEC_NEEDS_RESET;\n\t\telse if (ecc_err & XSDFEC_PL_INIT_ECC_ISR_MBE_MASK)\n\t\t\txsdfec->state = XSDFEC_PL_RECONFIGURE;\n\t\txsdfec->stats_updated = true;\n\t\txsdfec->state_updated = true;\n\t}\n\n\tif (cecc_count)\n\t\txsdfec->stats_updated = true;\n\n\tif (isr_err_count) {\n\t\txsdfec->state = XSDFEC_NEEDS_RESET;\n\t\txsdfec->stats_updated = true;\n\t\txsdfec->state_updated = true;\n\t}\n\n\tspin_unlock_irqrestore(&xsdfec->error_data_lock, xsdfec->flags);\n\tdev_dbg(xsdfec->dev, \"state=%x, stats=%x\", xsdfec->state_updated,\n\t\txsdfec->stats_updated);\n\n\t \n\tif (xsdfec->state_updated || xsdfec->stats_updated)\n\t\twake_up_interruptible(&xsdfec->waitq);\n\telse\n\t\tret = IRQ_NONE;\n\n\t \n\txsdfec_isr_enable(xsdfec, true);\n\txsdfec_ecc_isr_enable(xsdfec, true);\n\n\treturn ret;\n}\n\nstatic int xsdfec_clk_init(struct platform_device *pdev,\n\t\t\t   struct xsdfec_clks *clks)\n{\n\tint err;\n\n\tclks->core_clk = devm_clk_get(&pdev->dev, \"core_clk\");\n\tif (IS_ERR(clks->core_clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get core_clk\");\n\t\treturn PTR_ERR(clks->core_clk);\n\t}\n\n\tclks->axi_clk = devm_clk_get(&pdev->dev, \"s_axi_aclk\");\n\tif (IS_ERR(clks->axi_clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get axi_clk\");\n\t\treturn PTR_ERR(clks->axi_clk);\n\t}\n\n\tclks->din_words_clk = devm_clk_get(&pdev->dev, \"s_axis_din_words_aclk\");\n\tif (IS_ERR(clks->din_words_clk)) {\n\t\tif (PTR_ERR(clks->din_words_clk) != -ENOENT) {\n\t\t\terr = PTR_ERR(clks->din_words_clk);\n\t\t\treturn err;\n\t\t}\n\t\tclks->din_words_clk = NULL;\n\t}\n\n\tclks->din_clk = devm_clk_get(&pdev->dev, \"s_axis_din_aclk\");\n\tif (IS_ERR(clks->din_clk)) {\n\t\tif (PTR_ERR(clks->din_clk) != -ENOENT) {\n\t\t\terr = PTR_ERR(clks->din_clk);\n\t\t\treturn err;\n\t\t}\n\t\tclks->din_clk = NULL;\n\t}\n\n\tclks->dout_clk = devm_clk_get(&pdev->dev, \"m_axis_dout_aclk\");\n\tif (IS_ERR(clks->dout_clk)) {\n\t\tif (PTR_ERR(clks->dout_clk) != -ENOENT) {\n\t\t\terr = PTR_ERR(clks->dout_clk);\n\t\t\treturn err;\n\t\t}\n\t\tclks->dout_clk = NULL;\n\t}\n\n\tclks->dout_words_clk =\n\t\tdevm_clk_get(&pdev->dev, \"s_axis_dout_words_aclk\");\n\tif (IS_ERR(clks->dout_words_clk)) {\n\t\tif (PTR_ERR(clks->dout_words_clk) != -ENOENT) {\n\t\t\terr = PTR_ERR(clks->dout_words_clk);\n\t\t\treturn err;\n\t\t}\n\t\tclks->dout_words_clk = NULL;\n\t}\n\n\tclks->ctrl_clk = devm_clk_get(&pdev->dev, \"s_axis_ctrl_aclk\");\n\tif (IS_ERR(clks->ctrl_clk)) {\n\t\tif (PTR_ERR(clks->ctrl_clk) != -ENOENT) {\n\t\t\terr = PTR_ERR(clks->ctrl_clk);\n\t\t\treturn err;\n\t\t}\n\t\tclks->ctrl_clk = NULL;\n\t}\n\n\tclks->status_clk = devm_clk_get(&pdev->dev, \"m_axis_status_aclk\");\n\tif (IS_ERR(clks->status_clk)) {\n\t\tif (PTR_ERR(clks->status_clk) != -ENOENT) {\n\t\t\terr = PTR_ERR(clks->status_clk);\n\t\t\treturn err;\n\t\t}\n\t\tclks->status_clk = NULL;\n\t}\n\n\terr = clk_prepare_enable(clks->core_clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable core_clk (%d)\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(clks->axi_clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable axi_clk (%d)\", err);\n\t\tgoto err_disable_core_clk;\n\t}\n\n\terr = clk_prepare_enable(clks->din_clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable din_clk (%d)\", err);\n\t\tgoto err_disable_axi_clk;\n\t}\n\n\terr = clk_prepare_enable(clks->din_words_clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable din_words_clk (%d)\", err);\n\t\tgoto err_disable_din_clk;\n\t}\n\n\terr = clk_prepare_enable(clks->dout_clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable dout_clk (%d)\", err);\n\t\tgoto err_disable_din_words_clk;\n\t}\n\n\terr = clk_prepare_enable(clks->dout_words_clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable dout_words_clk (%d)\",\n\t\t\terr);\n\t\tgoto err_disable_dout_clk;\n\t}\n\n\terr = clk_prepare_enable(clks->ctrl_clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable ctrl_clk (%d)\", err);\n\t\tgoto err_disable_dout_words_clk;\n\t}\n\n\terr = clk_prepare_enable(clks->status_clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable status_clk (%d)\\n\", err);\n\t\tgoto err_disable_ctrl_clk;\n\t}\n\n\treturn err;\n\nerr_disable_ctrl_clk:\n\tclk_disable_unprepare(clks->ctrl_clk);\nerr_disable_dout_words_clk:\n\tclk_disable_unprepare(clks->dout_words_clk);\nerr_disable_dout_clk:\n\tclk_disable_unprepare(clks->dout_clk);\nerr_disable_din_words_clk:\n\tclk_disable_unprepare(clks->din_words_clk);\nerr_disable_din_clk:\n\tclk_disable_unprepare(clks->din_clk);\nerr_disable_axi_clk:\n\tclk_disable_unprepare(clks->axi_clk);\nerr_disable_core_clk:\n\tclk_disable_unprepare(clks->core_clk);\n\n\treturn err;\n}\n\nstatic void xsdfec_disable_all_clks(struct xsdfec_clks *clks)\n{\n\tclk_disable_unprepare(clks->status_clk);\n\tclk_disable_unprepare(clks->ctrl_clk);\n\tclk_disable_unprepare(clks->dout_words_clk);\n\tclk_disable_unprepare(clks->dout_clk);\n\tclk_disable_unprepare(clks->din_words_clk);\n\tclk_disable_unprepare(clks->din_clk);\n\tclk_disable_unprepare(clks->core_clk);\n\tclk_disable_unprepare(clks->axi_clk);\n}\n\nstatic int xsdfec_probe(struct platform_device *pdev)\n{\n\tstruct xsdfec_dev *xsdfec;\n\tstruct device *dev;\n\tint err;\n\tbool irq_enabled = true;\n\n\txsdfec = devm_kzalloc(&pdev->dev, sizeof(*xsdfec), GFP_KERNEL);\n\tif (!xsdfec)\n\t\treturn -ENOMEM;\n\n\txsdfec->dev = &pdev->dev;\n\tspin_lock_init(&xsdfec->error_data_lock);\n\n\terr = xsdfec_clk_init(pdev, &xsdfec->clks);\n\tif (err)\n\t\treturn err;\n\n\tdev = xsdfec->dev;\n\txsdfec->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xsdfec->regs)) {\n\t\terr = PTR_ERR(xsdfec->regs);\n\t\tgoto err_xsdfec_dev;\n\t}\n\n\txsdfec->irq = platform_get_irq(pdev, 0);\n\tif (xsdfec->irq < 0) {\n\t\tdev_dbg(dev, \"platform_get_irq failed\");\n\t\tirq_enabled = false;\n\t}\n\n\terr = xsdfec_parse_of(xsdfec);\n\tif (err < 0)\n\t\tgoto err_xsdfec_dev;\n\n\tupdate_config_from_hw(xsdfec);\n\n\t \n\tplatform_set_drvdata(pdev, xsdfec);\n\n\tif (irq_enabled) {\n\t\tinit_waitqueue_head(&xsdfec->waitq);\n\t\t \n\t\terr = devm_request_threaded_irq(dev, xsdfec->irq, NULL,\n\t\t\t\t\t\txsdfec_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\t\t\"xilinx-sdfec16\", xsdfec);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"unable to request IRQ%d\", xsdfec->irq);\n\t\t\tgoto err_xsdfec_dev;\n\t\t}\n\t}\n\n\terr = ida_alloc(&dev_nrs, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_xsdfec_dev;\n\txsdfec->dev_id = err;\n\n\tsnprintf(xsdfec->dev_name, DEV_NAME_LEN, \"xsdfec%d\", xsdfec->dev_id);\n\txsdfec->miscdev.minor = MISC_DYNAMIC_MINOR;\n\txsdfec->miscdev.name = xsdfec->dev_name;\n\txsdfec->miscdev.fops = &xsdfec_fops;\n\txsdfec->miscdev.parent = dev;\n\terr = misc_register(&xsdfec->miscdev);\n\tif (err) {\n\t\tdev_err(dev, \"error:%d. Unable to register device\", err);\n\t\tgoto err_xsdfec_ida;\n\t}\n\treturn 0;\n\nerr_xsdfec_ida:\n\tida_free(&dev_nrs, xsdfec->dev_id);\nerr_xsdfec_dev:\n\txsdfec_disable_all_clks(&xsdfec->clks);\n\treturn err;\n}\n\nstatic int xsdfec_remove(struct platform_device *pdev)\n{\n\tstruct xsdfec_dev *xsdfec;\n\n\txsdfec = platform_get_drvdata(pdev);\n\tmisc_deregister(&xsdfec->miscdev);\n\tida_free(&dev_nrs, xsdfec->dev_id);\n\txsdfec_disable_all_clks(&xsdfec->clks);\n\treturn 0;\n}\n\nstatic const struct of_device_id xsdfec_of_match[] = {\n\t{\n\t\t.compatible = \"xlnx,sd-fec-1.1\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, xsdfec_of_match);\n\nstatic struct platform_driver xsdfec_driver = {\n\t.driver = {\n\t\t.name = \"xilinx-sdfec\",\n\t\t.of_match_table = xsdfec_of_match,\n\t},\n\t.probe = xsdfec_probe,\n\t.remove =  xsdfec_remove,\n};\n\nmodule_platform_driver(xsdfec_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc\");\nMODULE_DESCRIPTION(\"Xilinx SD-FEC16 Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}