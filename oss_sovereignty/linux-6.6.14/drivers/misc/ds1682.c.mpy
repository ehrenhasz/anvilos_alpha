{
  "module_name": "ds1682.c",
  "hash_id": "48c0eaa7f2b1dd18b95b353f5c8204b263d1d3653d41748460861fdb23cb70c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ds1682.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/sysfs.h>\n#include <linux/ctype.h>\n#include <linux/hwmon-sysfs.h>\n\n \n#define DS1682_REG_CONFIG\t\t0x00\n#define DS1682_REG_ALARM\t\t0x01\n#define DS1682_REG_ELAPSED\t\t0x05\n#define DS1682_REG_EVT_CNTR\t\t0x09\n#define DS1682_REG_EEPROM\t\t0x0b\n#define DS1682_REG_RESET\t\t0x1d\n#define DS1682_REG_WRITE_DISABLE\t0x1e\n#define DS1682_REG_WRITE_MEM_DISABLE\t0x1f\n\n#define DS1682_EEPROM_SIZE\t\t10\n\n \nstatic ssize_t ds1682_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned long long val, check;\n\t__le32 val_le = 0;\n\tint rc;\n\n\tdev_dbg(dev, \"ds1682_show() called on %s\\n\", attr->attr.name);\n\n\t \n\trc = i2c_smbus_read_i2c_block_data(client, sattr->index, sattr->nr,\n\t\t\t\t\t   (u8 *)&val_le);\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\tval = le32_to_cpu(val_le);\n\n\tif (sattr->index == DS1682_REG_ELAPSED) {\n\t\tint retries = 5;\n\n\t\t \n\t\tdo {\n\t\t\trc = i2c_smbus_read_i2c_block_data(client, sattr->index,\n\t\t\t\t\t\t\t   sattr->nr,\n\t\t\t\t\t\t\t   (u8 *)&val_le);\n\t\t\tif (rc < 0 || retries <= 0)\n\t\t\t\treturn -EIO;\n\n\t\t\tcheck = val;\n\t\t\tval = le32_to_cpu(val_le);\n\t\t\tretries--;\n\t\t} while (val != check && val != (check + 1));\n\t}\n\n\t \n\treturn sprintf(buf, \"%llu\\n\", (sattr->nr == 4) ? (val * 250) : val);\n}\n\nstatic ssize_t ds1682_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu64 val;\n\t__le32 val_le;\n\tint rc;\n\n\tdev_dbg(dev, \"ds1682_store() called on %s\\n\", attr->attr.name);\n\n\t \n\trc = kstrtoull(buf, 0, &val);\n\tif (rc < 0) {\n\t\tdev_dbg(dev, \"input string not a number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (sattr->nr == 4)\n\t\tdo_div(val, 250);\n\n\t \n\tval_le = cpu_to_le32(val);\n\trc = i2c_smbus_write_i2c_block_data(client, sattr->index, sattr->nr,\n\t\t\t\t\t    (u8 *) & val_le);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"register write failed; reg=0x%x, size=%i\\n\",\n\t\t\tsattr->index, sattr->nr);\n\t\treturn -EIO;\n\t}\n\n\treturn count;\n}\n\n \nstatic SENSOR_DEVICE_ATTR_2(elapsed_time, S_IRUGO | S_IWUSR, ds1682_show,\n\t\t\t    ds1682_store, 4, DS1682_REG_ELAPSED);\nstatic SENSOR_DEVICE_ATTR_2(alarm_time, S_IRUGO | S_IWUSR, ds1682_show,\n\t\t\t    ds1682_store, 4, DS1682_REG_ALARM);\nstatic SENSOR_DEVICE_ATTR_2(event_count, S_IRUGO | S_IWUSR, ds1682_show,\n\t\t\t    ds1682_store, 2, DS1682_REG_EVT_CNTR);\n\nstatic const struct attribute_group ds1682_group = {\n\t.attrs = (struct attribute *[]) {\n\t\t&sensor_dev_attr_elapsed_time.dev_attr.attr,\n\t\t&sensor_dev_attr_alarm_time.dev_attr.attr,\n\t\t&sensor_dev_attr_event_count.dev_attr.attr,\n\t\tNULL,\n\t},\n};\n\n \nstatic ssize_t ds1682_eeprom_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t  struct bin_attribute *attr,\n\t\t\t\t  char *buf, loff_t off, size_t count)\n{\n\tstruct i2c_client *client = kobj_to_i2c_client(kobj);\n\tint rc;\n\n\tdev_dbg(&client->dev, \"ds1682_eeprom_read(p=%p, off=%lli, c=%zi)\\n\",\n\t\tbuf, off, count);\n\n\trc = i2c_smbus_read_i2c_block_data(client, DS1682_REG_EEPROM + off,\n\t\t\t\t\t   count, buf);\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic ssize_t ds1682_eeprom_write(struct file *filp, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *attr,\n\t\t\t\t   char *buf, loff_t off, size_t count)\n{\n\tstruct i2c_client *client = kobj_to_i2c_client(kobj);\n\n\tdev_dbg(&client->dev, \"ds1682_eeprom_write(p=%p, off=%lli, c=%zi)\\n\",\n\t\tbuf, off, count);\n\n\t \n\tif (i2c_smbus_write_i2c_block_data(client, DS1682_REG_EEPROM + off,\n\t\t\t\t\t   count, buf) < 0)\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic const struct bin_attribute ds1682_eeprom_attr = {\n\t.attr = {\n\t\t.name = \"eeprom\",\n\t\t.mode = S_IRUGO | S_IWUSR,\n\t},\n\t.size = DS1682_EEPROM_SIZE,\n\t.read = ds1682_eeprom_read,\n\t.write = ds1682_eeprom_write,\n};\n\n \nstatic int ds1682_probe(struct i2c_client *client)\n{\n\tint rc;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_I2C_BLOCK)) {\n\t\tdev_err(&client->dev, \"i2c bus does not support the ds1682\\n\");\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\trc = sysfs_create_group(&client->dev.kobj, &ds1682_group);\n\tif (rc)\n\t\tgoto exit;\n\n\trc = sysfs_create_bin_file(&client->dev.kobj, &ds1682_eeprom_attr);\n\tif (rc)\n\t\tgoto exit_bin_attr;\n\n\treturn 0;\n\n exit_bin_attr:\n\tsysfs_remove_group(&client->dev.kobj, &ds1682_group);\n exit:\n\treturn rc;\n}\n\nstatic void ds1682_remove(struct i2c_client *client)\n{\n\tsysfs_remove_bin_file(&client->dev.kobj, &ds1682_eeprom_attr);\n\tsysfs_remove_group(&client->dev.kobj, &ds1682_group);\n}\n\nstatic const struct i2c_device_id ds1682_id[] = {\n\t{ \"ds1682\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ds1682_id);\n\nstatic const struct of_device_id ds1682_of_match[] = {\n\t{ .compatible = \"dallas,ds1682\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ds1682_of_match);\n\nstatic struct i2c_driver ds1682_driver = {\n\t.driver = {\n\t\t.name = \"ds1682\",\n\t\t.of_match_table = ds1682_of_match,\n\t},\n\t.probe = ds1682_probe,\n\t.remove = ds1682_remove,\n\t.id_table = ds1682_id,\n};\n\nmodule_i2c_driver(ds1682_driver);\n\nMODULE_AUTHOR(\"Grant Likely <grant.likely@secretlab.ca>\");\nMODULE_DESCRIPTION(\"DS1682 Elapsed Time Indicator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}