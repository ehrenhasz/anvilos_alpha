{
  "module_name": "kgdbts.c",
  "hash_id": "85baf0cfcf6c3c2a75fbb0b38d78f44ffa3def9380ee03904d8a3cdcb02e4fe1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/kgdbts.c",
  "human_readable_source": "\n \n \n\n#include <linux/kernel.h>\n#include <linux/kgdb.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/sched/task.h>\n#include <linux/kallsyms.h>\n\n#include <asm/sections.h>\n\n#define v1printk(a...) do {\t\t\\\n\tif (verbose)\t\t\t\\\n\t\tprintk(KERN_INFO a);\t\\\n} while (0)\n#define v2printk(a...) do {\t\t\\\n\tif (verbose > 1) {\t\t\\\n\t\tprintk(KERN_INFO a);\t\\\n\t}\t\t\t\t\\\n\ttouch_nmi_watchdog();\t\t\\\n} while (0)\n#define eprintk(a...) do {\t\t\\\n\tprintk(KERN_ERR a);\t\t\\\n\tWARN_ON(1);\t\t\t\\\n} while (0)\n#define MAX_CONFIG_LEN\t\t40\n\nstatic struct kgdb_io kgdbts_io_ops;\nstatic char get_buf[BUFMAX];\nstatic int get_buf_cnt;\nstatic char put_buf[BUFMAX];\nstatic int put_buf_cnt;\nstatic char scratch_buf[BUFMAX];\nstatic int verbose;\nstatic int repeat_test;\nstatic int test_complete;\nstatic int send_ack;\nstatic int final_ack;\nstatic int force_hwbrks;\nstatic int hwbreaks_ok;\nstatic int hw_break_val;\nstatic int hw_break_val2;\nstatic int cont_instead_of_sstep;\nstatic unsigned long cont_thread_id;\nstatic unsigned long sstep_thread_id;\n#if defined(CONFIG_ARM) || defined(CONFIG_MIPS) || defined(CONFIG_SPARC)\nstatic int arch_needs_sstep_emulation = 1;\n#else\nstatic int arch_needs_sstep_emulation;\n#endif\nstatic unsigned long cont_addr;\nstatic unsigned long sstep_addr;\nstatic int restart_from_top_after_write;\nstatic int sstep_state;\n\n \nstatic unsigned long kgdbts_gdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\nstatic struct pt_regs kgdbts_regs;\n\n \nstatic int configured\t\t= -1;\n\n#ifdef CONFIG_KGDB_TESTS_BOOT_STRING\nstatic char config[MAX_CONFIG_LEN] = CONFIG_KGDB_TESTS_BOOT_STRING;\n#else\nstatic char config[MAX_CONFIG_LEN];\n#endif\nstatic struct kparam_string kps = {\n\t.string\t\t\t= config,\n\t.maxlen\t\t\t= MAX_CONFIG_LEN,\n};\n\nstatic void fill_get_buf(char *buf);\n\nstruct test_struct {\n\tchar *get;\n\tchar *put;\n\tvoid (*get_handler)(char *);\n\tint (*put_handler)(char *, char *);\n};\n\nstruct test_state {\n\tchar *name;\n\tstruct test_struct *tst;\n\tint idx;\n\tint (*run_test) (int, int);\n\tint (*validate_put) (char *);\n};\n\nstatic struct test_state ts;\n\nstatic int kgdbts_unreg_thread(void *ptr)\n{\n\t \n\twhile (!final_ack)\n\t\tmsleep_interruptible(1500);\n\t \n\tmsleep_interruptible(1000);\n\tif (configured)\n\t\tkgdb_unregister_io_module(&kgdbts_io_ops);\n\tconfigured = 0;\n\n\treturn 0;\n}\n\n \nstatic noinline void kgdbts_break_test(void)\n{\n\tv2printk(\"kgdbts: breakpoint complete\\n\");\n}\n\n \nstatic unsigned long lookup_addr(char *arg)\n{\n\tstatic char cached_arg[KSYM_NAME_LEN];\n\tstatic unsigned long cached_addr;\n\n\tif (strcmp(arg, cached_arg)) {\n\t\tstrscpy(cached_arg, arg, KSYM_NAME_LEN);\n\t\tcached_addr = kallsyms_lookup_name(arg);\n\t}\n\n\treturn (unsigned long)dereference_function_descriptor(\n\t\t\t(void *)cached_addr);\n}\n\nstatic void break_helper(char *bp_type, char *arg, unsigned long vaddr)\n{\n\tunsigned long addr;\n\n\tif (arg)\n\t\taddr = lookup_addr(arg);\n\telse\n\t\taddr = vaddr;\n\n\tsprintf(scratch_buf, \"%s,%lx,%i\", bp_type, addr,\n\t\tBREAK_INSTR_SIZE);\n\tfill_get_buf(scratch_buf);\n}\n\nstatic void sw_break(char *arg)\n{\n\tbreak_helper(force_hwbrks ? \"Z1\" : \"Z0\", arg, 0);\n}\n\nstatic void sw_rem_break(char *arg)\n{\n\tbreak_helper(force_hwbrks ? \"z1\" : \"z0\", arg, 0);\n}\n\nstatic void hw_break(char *arg)\n{\n\tbreak_helper(\"Z1\", arg, 0);\n}\n\nstatic void hw_rem_break(char *arg)\n{\n\tbreak_helper(\"z1\", arg, 0);\n}\n\nstatic void hw_write_break(char *arg)\n{\n\tbreak_helper(\"Z2\", arg, 0);\n}\n\nstatic void hw_rem_write_break(char *arg)\n{\n\tbreak_helper(\"z2\", arg, 0);\n}\n\nstatic void hw_access_break(char *arg)\n{\n\tbreak_helper(\"Z4\", arg, 0);\n}\n\nstatic void hw_rem_access_break(char *arg)\n{\n\tbreak_helper(\"z4\", arg, 0);\n}\n\nstatic void hw_break_val_access(void)\n{\n\thw_break_val2 = hw_break_val;\n}\n\nstatic void hw_break_val_write(void)\n{\n\thw_break_val++;\n}\n\nstatic int get_thread_id_continue(char *put_str, char *arg)\n{\n\tchar *ptr = &put_str[11];\n\n\tif (put_str[1] != 'T' || put_str[2] != '0')\n\t\treturn 1;\n\tkgdb_hex2long(&ptr, &cont_thread_id);\n\treturn 0;\n}\n\nstatic int check_and_rewind_pc(char *put_str, char *arg)\n{\n\tunsigned long addr = lookup_addr(arg);\n\tunsigned long ip;\n\tint offset = 0;\n\n\tkgdb_hex2mem(&put_str[1], (char *)kgdbts_gdb_regs,\n\t\t NUMREGBYTES);\n\tgdb_regs_to_pt_regs(kgdbts_gdb_regs, &kgdbts_regs);\n\tip = instruction_pointer(&kgdbts_regs);\n\tv2printk(\"Stopped at IP: %lx\\n\", ip);\n#ifdef GDB_ADJUSTS_BREAK_OFFSET\n\t \n\tif (addr + BREAK_INSTR_SIZE == ip)\n\t\toffset = -BREAK_INSTR_SIZE;\n#endif\n\n\tif (arch_needs_sstep_emulation && sstep_addr &&\n\t    ip + offset == sstep_addr &&\n\t    ((!strcmp(arg, \"do_sys_openat2\") || !strcmp(arg, \"kernel_clone\")))) {\n\t\t \n\t\tv2printk(\"Emul: rewind hit single step bp\\n\");\n\t\trestart_from_top_after_write = 1;\n\t} else if (strcmp(arg, \"silent\") && ip + offset != addr) {\n\t\teprintk(\"kgdbts: BP mismatch %lx expected %lx\\n\",\n\t\t\t   ip + offset, addr);\n\t\treturn 1;\n\t}\n\t \n\tip += offset;\n\tcont_addr = ip;\n#ifdef GDB_ADJUSTS_BREAK_OFFSET\n\tinstruction_pointer_set(&kgdbts_regs, ip);\n#endif\n\treturn 0;\n}\n\nstatic int check_single_step(char *put_str, char *arg)\n{\n\tunsigned long addr = lookup_addr(arg);\n\tstatic int matched_id;\n\n\t \n\tkgdb_hex2mem(&put_str[1], (char *)kgdbts_gdb_regs,\n\t\t NUMREGBYTES);\n\tgdb_regs_to_pt_regs(kgdbts_gdb_regs, &kgdbts_regs);\n\tv2printk(\"Singlestep stopped at IP: %lx\\n\",\n\t\t   instruction_pointer(&kgdbts_regs));\n\n\tif (sstep_thread_id != cont_thread_id) {\n\t\t \n\t\tv2printk(\"ThrID does not match: %lx\\n\", cont_thread_id);\n\t\tif (arch_needs_sstep_emulation) {\n\t\t\tif (matched_id &&\n\t\t\t    instruction_pointer(&kgdbts_regs) != addr)\n\t\t\t\tgoto continue_test;\n\t\t\tmatched_id++;\n\t\t\tts.idx -= 2;\n\t\t\tsstep_state = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tcont_instead_of_sstep = 1;\n\t\tts.idx -= 4;\n\t\treturn 0;\n\t}\ncontinue_test:\n\tmatched_id = 0;\n\tif (instruction_pointer(&kgdbts_regs) == addr) {\n\t\teprintk(\"kgdbts: SingleStep failed at %lx\\n\",\n\t\t\t   instruction_pointer(&kgdbts_regs));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void write_regs(char *arg)\n{\n\tmemset(scratch_buf, 0, sizeof(scratch_buf));\n\tscratch_buf[0] = 'G';\n\tpt_regs_to_gdb_regs(kgdbts_gdb_regs, &kgdbts_regs);\n\tkgdb_mem2hex((char *)kgdbts_gdb_regs, &scratch_buf[1], NUMREGBYTES);\n\tfill_get_buf(scratch_buf);\n}\n\nstatic void skip_back_repeat_test(char *arg)\n{\n\tint go_back = simple_strtol(arg, NULL, 10);\n\n\trepeat_test--;\n\tif (repeat_test <= 0) {\n\t\tts.idx++;\n\t} else {\n\t\tif (repeat_test % 100 == 0)\n\t\t\tv1printk(\"kgdbts:RUN ... %d remaining\\n\", repeat_test);\n\n\t\tts.idx -= go_back;\n\t}\n\tfill_get_buf(ts.tst[ts.idx].get);\n}\n\nstatic int got_break(char *put_str, char *arg)\n{\n\ttest_complete = 1;\n\tif (!strncmp(put_str+1, arg, 2)) {\n\t\tif (!strncmp(arg, \"T0\", 2))\n\t\t\ttest_complete = 2;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void get_cont_catch(char *arg)\n{\n\t \n\tfill_get_buf(\"D\");\n}\n\nstatic int put_cont_catch(char *put_str, char *arg)\n{\n\t \n\tv2printk(\"kgdbts: cleanup task: %lx\\n\", sstep_thread_id);\n\tts.idx--;\n\treturn 0;\n}\n\nstatic int emul_reset(char *put_str, char *arg)\n{\n\tif (strncmp(put_str, \"$OK\", 3))\n\t\treturn 1;\n\tif (restart_from_top_after_write) {\n\t\trestart_from_top_after_write = 0;\n\t\tts.idx = -1;\n\t}\n\treturn 0;\n}\n\nstatic void emul_sstep_get(char *arg)\n{\n\tif (!arch_needs_sstep_emulation) {\n\t\tif (cont_instead_of_sstep) {\n\t\t\tcont_instead_of_sstep = 0;\n\t\t\tfill_get_buf(\"c\");\n\t\t} else {\n\t\t\tfill_get_buf(arg);\n\t\t}\n\t\treturn;\n\t}\n\tswitch (sstep_state) {\n\tcase 0:\n\t\tv2printk(\"Emulate single step\\n\");\n\t\t \n\t\tfill_get_buf(\"g\");\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tbreak_helper(\"Z0\", NULL, sstep_addr);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tfill_get_buf(\"c\");\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tbreak_helper(\"z0\", NULL, sstep_addr);\n\t\tbreak;\n\tdefault:\n\t\teprintk(\"kgdbts: ERROR failed sstep get emulation\\n\");\n\t}\n\tsstep_state++;\n}\n\nstatic int emul_sstep_put(char *put_str, char *arg)\n{\n\tif (!arch_needs_sstep_emulation) {\n\t\tchar *ptr = &put_str[11];\n\t\tif (put_str[1] != 'T' || put_str[2] != '0')\n\t\t\treturn 1;\n\t\tkgdb_hex2long(&ptr, &sstep_thread_id);\n\t\treturn 0;\n\t}\n\tswitch (sstep_state) {\n\tcase 1:\n\t\t \n\t\tkgdb_hex2mem(&put_str[1], (char *)kgdbts_gdb_regs,\n\t\t\t NUMREGBYTES);\n\t\tgdb_regs_to_pt_regs(kgdbts_gdb_regs, &kgdbts_regs);\n\t\tv2printk(\"Stopped at IP: %lx\\n\",\n\t\t\t instruction_pointer(&kgdbts_regs));\n\t\t \n\t\tsstep_addr = cont_addr + BREAK_INSTR_SIZE;\n\t\tbreak;\n\tcase 2:\n\t\tif (strncmp(put_str, \"$OK\", 3)) {\n\t\t\teprintk(\"kgdbts: failed sstep break set\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tif (strncmp(put_str, \"$T0\", 3)) {\n\t\t\teprintk(\"kgdbts: failed continue sstep\\n\");\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tchar *ptr = &put_str[11];\n\t\t\tkgdb_hex2long(&ptr, &sstep_thread_id);\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tif (strncmp(put_str, \"$OK\", 3)) {\n\t\t\teprintk(\"kgdbts: failed sstep break unset\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t \n\t\tsstep_state = 0;\n\t\treturn 0;\n\tdefault:\n\t\teprintk(\"kgdbts: ERROR failed sstep put emulation\\n\");\n\t}\n\n\t \n\tts.idx--;\n\treturn 0;\n}\n\nstatic int final_ack_set(char *put_str, char *arg)\n{\n\tif (strncmp(put_str+1, arg, 2))\n\t\treturn 1;\n\tfinal_ack = 1;\n\treturn 0;\n}\n \nstatic struct test_struct plant_and_detach_test[] = {\n\t{ \"?\", \"S0*\" },  \n\t{ \"kgdbts_break_test\", \"OK\", sw_break, },  \n\t{ \"D\", \"OK\" },  \n\t{ \"\", \"\" },\n};\n\n \nstatic struct test_struct sw_breakpoint_test[] = {\n\t{ \"?\", \"S0*\" },  \n\t{ \"kgdbts_break_test\", \"OK\", sw_break, },  \n\t{ \"c\", \"T0*\", },  \n\t{ \"g\", \"kgdbts_break_test\", NULL, check_and_rewind_pc },\n\t{ \"write\", \"OK\", write_regs },\n\t{ \"kgdbts_break_test\", \"OK\", sw_rem_break },  \n\t{ \"D\", \"OK\" },  \n\t{ \"D\", \"OK\", NULL,  got_break },  \n\t{ \"\", \"\" },\n};\n\n \nstatic struct test_struct bad_read_test[] = {\n\t{ \"?\", \"S0*\" },  \n\t{ \"m0,1\", \"E*\" },  \n\t{ \"m0,2\", \"E*\" },  \n\t{ \"m0,3\", \"E*\" },  \n\t{ \"m0,4\", \"E*\" },  \n\t{ \"m0,5\", \"E*\" },  \n\t{ \"m0,6\", \"E*\" },  \n\t{ \"m0,7\", \"E*\" },  \n\t{ \"m0,8\", \"E*\" },  \n\t{ \"D\", \"OK\" },  \n\t{ \"\", \"\" },\n};\n\n \nstatic struct test_struct singlestep_break_test[] = {\n\t{ \"?\", \"S0*\" },  \n\t{ \"kgdbts_break_test\", \"OK\", sw_break, },  \n\t{ \"c\", \"T0*\", NULL, get_thread_id_continue },  \n\t{ \"kgdbts_break_test\", \"OK\", sw_rem_break },  \n\t{ \"g\", \"kgdbts_break_test\", NULL, check_and_rewind_pc },\n\t{ \"write\", \"OK\", write_regs },  \n\t{ \"s\", \"T0*\", emul_sstep_get, emul_sstep_put },  \n\t{ \"g\", \"kgdbts_break_test\", NULL, check_single_step },\n\t{ \"kgdbts_break_test\", \"OK\", sw_break, },  \n\t{ \"c\", \"T0*\", },  \n\t{ \"g\", \"kgdbts_break_test\", NULL, check_and_rewind_pc },\n\t{ \"write\", \"OK\", write_regs },  \n\t{ \"D\", \"OK\" },  \n\t{ \"\", \"\" },\n};\n\n \nstatic struct test_struct do_kernel_clone_test[] = {\n\t{ \"?\", \"S0*\" },  \n\t{ \"kernel_clone\", \"OK\", sw_break, },  \n\t{ \"c\", \"T0*\", NULL, get_thread_id_continue },  \n\t{ \"kernel_clone\", \"OK\", sw_rem_break },  \n\t{ \"g\", \"kernel_clone\", NULL, check_and_rewind_pc },  \n\t{ \"write\", \"OK\", write_regs, emul_reset },  \n\t{ \"s\", \"T0*\", emul_sstep_get, emul_sstep_put },  \n\t{ \"g\", \"kernel_clone\", NULL, check_single_step },\n\t{ \"kernel_clone\", \"OK\", sw_break, },  \n\t{ \"7\", \"T0*\", skip_back_repeat_test },  \n\t{ \"D\", \"OK\", NULL, final_ack_set },  \n\t{ \"\", \"\", get_cont_catch, put_cont_catch },\n};\n\n \nstatic struct test_struct sys_open_test[] = {\n\t{ \"?\", \"S0*\" },  \n\t{ \"do_sys_openat2\", \"OK\", sw_break, },  \n\t{ \"c\", \"T0*\", NULL, get_thread_id_continue },  \n\t{ \"do_sys_openat2\", \"OK\", sw_rem_break },  \n\t{ \"g\", \"do_sys_openat2\", NULL, check_and_rewind_pc },  \n\t{ \"write\", \"OK\", write_regs, emul_reset },  \n\t{ \"s\", \"T0*\", emul_sstep_get, emul_sstep_put },  \n\t{ \"g\", \"do_sys_openat2\", NULL, check_single_step },\n\t{ \"do_sys_openat2\", \"OK\", sw_break, },  \n\t{ \"7\", \"T0*\", skip_back_repeat_test },  \n\t{ \"D\", \"OK\", NULL, final_ack_set },  \n\t{ \"\", \"\", get_cont_catch, put_cont_catch },\n};\n\n \nstatic struct test_struct hw_breakpoint_test[] = {\n\t{ \"?\", \"S0*\" },  \n\t{ \"kgdbts_break_test\", \"OK\", hw_break, },  \n\t{ \"c\", \"T0*\", },  \n\t{ \"g\", \"kgdbts_break_test\", NULL, check_and_rewind_pc },\n\t{ \"write\", \"OK\", write_regs },\n\t{ \"kgdbts_break_test\", \"OK\", hw_rem_break },  \n\t{ \"D\", \"OK\" },  \n\t{ \"D\", \"OK\", NULL,  got_break },  \n\t{ \"\", \"\" },\n};\n\n \nstatic struct test_struct hw_write_break_test[] = {\n\t{ \"?\", \"S0*\" },  \n\t{ \"hw_break_val\", \"OK\", hw_write_break, },  \n\t{ \"c\", \"T0*\", NULL, got_break },  \n\t{ \"g\", \"silent\", NULL, check_and_rewind_pc },\n\t{ \"write\", \"OK\", write_regs },\n\t{ \"hw_break_val\", \"OK\", hw_rem_write_break },  \n\t{ \"D\", \"OK\" },  \n\t{ \"D\", \"OK\", NULL,  got_break },  \n\t{ \"\", \"\" },\n};\n\n \nstatic struct test_struct hw_access_break_test[] = {\n\t{ \"?\", \"S0*\" },  \n\t{ \"hw_break_val\", \"OK\", hw_access_break, },  \n\t{ \"c\", \"T0*\", NULL, got_break },  \n\t{ \"g\", \"silent\", NULL, check_and_rewind_pc },\n\t{ \"write\", \"OK\", write_regs },\n\t{ \"hw_break_val\", \"OK\", hw_rem_access_break },  \n\t{ \"D\", \"OK\" },  \n\t{ \"D\", \"OK\", NULL,  got_break },  \n\t{ \"\", \"\" },\n};\n\n \nstatic struct test_struct nmi_sleep_test[] = {\n\t{ \"?\", \"S0*\" },  \n\t{ \"c\", \"T0*\", NULL, got_break },  \n\t{ \"D\", \"OK\" },  \n\t{ \"D\", \"OK\", NULL,  got_break },  \n\t{ \"\", \"\" },\n};\n\nstatic void fill_get_buf(char *buf)\n{\n\tunsigned char checksum = 0;\n\tint count = 0;\n\tchar ch;\n\n\tstrcpy(get_buf, \"$\");\n\tstrcat(get_buf, buf);\n\twhile ((ch = buf[count])) {\n\t\tchecksum += ch;\n\t\tcount++;\n\t}\n\tstrcat(get_buf, \"#\");\n\tget_buf[count + 2] = hex_asc_hi(checksum);\n\tget_buf[count + 3] = hex_asc_lo(checksum);\n\tget_buf[count + 4] = '\\0';\n\tv2printk(\"get%i: %s\\n\", ts.idx, get_buf);\n}\n\nstatic int validate_simple_test(char *put_str)\n{\n\tchar *chk_str;\n\n\tif (ts.tst[ts.idx].put_handler)\n\t\treturn ts.tst[ts.idx].put_handler(put_str,\n\t\t\tts.tst[ts.idx].put);\n\n\tchk_str = ts.tst[ts.idx].put;\n\tif (*put_str == '$')\n\t\tput_str++;\n\n\twhile (*chk_str != '\\0' && *put_str != '\\0') {\n\t\t \n\t\tif (*put_str == '#' || *chk_str == '*')\n\t\t\treturn 0;\n\t\tif (*put_str != *chk_str)\n\t\t\treturn 1;\n\n\t\tchk_str++;\n\t\tput_str++;\n\t}\n\tif (*chk_str == '\\0' && (*put_str == '\\0' || *put_str == '#'))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int run_simple_test(int is_get_char, int chr)\n{\n\tint ret = 0;\n\tif (is_get_char) {\n\t\t \n\t\tif (send_ack) {\n\t\t\tsend_ack = 0;\n\t\t\treturn '+';\n\t\t}\n\t\t \n\t\tif (get_buf_cnt == 0) {\n\t\t\tif (ts.tst[ts.idx].get_handler)\n\t\t\t\tts.tst[ts.idx].get_handler(ts.tst[ts.idx].get);\n\t\t\telse\n\t\t\t\tfill_get_buf(ts.tst[ts.idx].get);\n\t\t}\n\n\t\tif (get_buf[get_buf_cnt] == '\\0') {\n\t\t\teprintk(\"kgdbts: ERROR GET: EOB on '%s' at %i\\n\",\n\t\t\t   ts.name, ts.idx);\n\t\t\tget_buf_cnt = 0;\n\t\t\tfill_get_buf(\"D\");\n\t\t}\n\t\tret = get_buf[get_buf_cnt];\n\t\tget_buf_cnt++;\n\t\treturn ret;\n\t}\n\n\t \n\tif (ts.tst[ts.idx].get[0] == '\\0' && ts.tst[ts.idx].put[0] == '\\0' &&\n\t    !ts.tst[ts.idx].get_handler) {\n\t\teprintk(\"kgdbts: ERROR: beyond end of test on\"\n\t\t\t   \" '%s' line %i\\n\", ts.name, ts.idx);\n\t\treturn 0;\n\t}\n\n\tif (put_buf_cnt >= BUFMAX) {\n\t\teprintk(\"kgdbts: ERROR: put buffer overflow on\"\n\t\t\t   \" '%s' line %i\\n\", ts.name, ts.idx);\n\t\tput_buf_cnt = 0;\n\t\treturn 0;\n\t}\n\t \n\tif (put_buf_cnt == 0 && chr != '$')\n\t\treturn 0;\n\n\tput_buf[put_buf_cnt] = chr;\n\tput_buf_cnt++;\n\n\t \n\tif (put_buf_cnt > 3 && put_buf[put_buf_cnt - 3] == '#') {\n\t\tif (put_buf_cnt >= BUFMAX) {\n\t\t\teprintk(\"kgdbts: ERROR: put buffer overflow on\"\n\t\t\t\t\" '%s' line %i\\n\", ts.name, ts.idx);\n\t\t\tput_buf_cnt = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tput_buf[put_buf_cnt] = '\\0';\n\t\tv2printk(\"put%i: %s\\n\", ts.idx, put_buf);\n\t\t \n\t\tif (ts.validate_put && ts.validate_put(put_buf)) {\n\t\t\teprintk(\"kgdbts: ERROR PUT: end of test \"\n\t\t\t   \"buffer on '%s' line %i expected %s got %s\\n\",\n\t\t\t   ts.name, ts.idx, ts.tst[ts.idx].put, put_buf);\n\t\t}\n\t\tts.idx++;\n\t\tput_buf_cnt = 0;\n\t\tget_buf_cnt = 0;\n\t\tsend_ack = 1;\n\t}\n\treturn 0;\n}\n\nstatic void init_simple_test(void)\n{\n\tmemset(&ts, 0, sizeof(ts));\n\tts.run_test = run_simple_test;\n\tts.validate_put = validate_simple_test;\n}\n\nstatic void run_plant_and_detach_test(int is_early)\n{\n\tchar before[BREAK_INSTR_SIZE];\n\tchar after[BREAK_INSTR_SIZE];\n\n\tcopy_from_kernel_nofault(before, (char *)kgdbts_break_test,\n\t  BREAK_INSTR_SIZE);\n\tinit_simple_test();\n\tts.tst = plant_and_detach_test;\n\tts.name = \"plant_and_detach_test\";\n\t \n\tif (!is_early)\n\t\tkgdb_breakpoint();\n\tcopy_from_kernel_nofault(after, (char *)kgdbts_break_test,\n\t\t\tBREAK_INSTR_SIZE);\n\tif (memcmp(before, after, BREAK_INSTR_SIZE)) {\n\t\tprintk(KERN_CRIT \"kgdbts: ERROR kgdb corrupted memory\\n\");\n\t\tpanic(\"kgdb memory corruption\");\n\t}\n\n\t \n\tif (!is_early)\n\t\tkgdbts_break_test();\n}\n\nstatic void run_breakpoint_test(int is_hw_breakpoint)\n{\n\ttest_complete = 0;\n\tinit_simple_test();\n\tif (is_hw_breakpoint) {\n\t\tts.tst = hw_breakpoint_test;\n\t\tts.name = \"hw_breakpoint_test\";\n\t} else {\n\t\tts.tst = sw_breakpoint_test;\n\t\tts.name = \"sw_breakpoint_test\";\n\t}\n\t \n\tkgdb_breakpoint();\n\t \n\tkgdbts_break_test();\n\tkgdb_breakpoint();\n\n\tif (test_complete)\n\t\treturn;\n\n\teprintk(\"kgdbts: ERROR %s test failed\\n\", ts.name);\n\tif (is_hw_breakpoint)\n\t\thwbreaks_ok = 0;\n}\n\nstatic void run_hw_break_test(int is_write_test)\n{\n\ttest_complete = 0;\n\tinit_simple_test();\n\tif (is_write_test) {\n\t\tts.tst = hw_write_break_test;\n\t\tts.name = \"hw_write_break_test\";\n\t} else {\n\t\tts.tst = hw_access_break_test;\n\t\tts.name = \"hw_access_break_test\";\n\t}\n\t \n\tkgdb_breakpoint();\n\thw_break_val_access();\n\tif (is_write_test) {\n\t\tif (test_complete == 2) {\n\t\t\teprintk(\"kgdbts: ERROR %s broke on access\\n\",\n\t\t\t\tts.name);\n\t\t\thwbreaks_ok = 0;\n\t\t}\n\t\thw_break_val_write();\n\t}\n\tkgdb_breakpoint();\n\n\tif (test_complete == 1)\n\t\treturn;\n\n\teprintk(\"kgdbts: ERROR %s test failed\\n\", ts.name);\n\thwbreaks_ok = 0;\n}\n\nstatic void run_nmi_sleep_test(int nmi_sleep)\n{\n\tunsigned long flags;\n\n\tinit_simple_test();\n\tts.tst = nmi_sleep_test;\n\tts.name = \"nmi_sleep_test\";\n\t \n\tkgdb_breakpoint();\n\tlocal_irq_save(flags);\n\tmdelay(nmi_sleep*1000);\n\ttouch_nmi_watchdog();\n\tlocal_irq_restore(flags);\n\tif (test_complete != 2)\n\t\teprintk(\"kgdbts: ERROR nmi_test did not hit nmi\\n\");\n\tkgdb_breakpoint();\n\tif (test_complete == 1)\n\t\treturn;\n\n\teprintk(\"kgdbts: ERROR %s test failed\\n\", ts.name);\n}\n\nstatic void run_bad_read_test(void)\n{\n\tinit_simple_test();\n\tts.tst = bad_read_test;\n\tts.name = \"bad_read_test\";\n\t \n\tkgdb_breakpoint();\n}\n\nstatic void run_kernel_clone_test(void)\n{\n\tinit_simple_test();\n\tts.tst = do_kernel_clone_test;\n\tts.name = \"do_kernel_clone_test\";\n\t \n\tkgdb_breakpoint();\n}\n\nstatic void run_sys_open_test(void)\n{\n\tinit_simple_test();\n\tts.tst = sys_open_test;\n\tts.name = \"sys_open_test\";\n\t \n\tkgdb_breakpoint();\n}\n\nstatic void run_singlestep_break_test(void)\n{\n\tinit_simple_test();\n\tts.tst = singlestep_break_test;\n\tts.name = \"singlestep_breakpoint_test\";\n\t \n\tkgdb_breakpoint();\n\tkgdbts_break_test();\n\tkgdbts_break_test();\n}\n\nstatic void kgdbts_run_tests(void)\n{\n\tchar *ptr;\n\tint clone_test = 0;\n\tint do_sys_open_test = 0;\n\tint sstep_test = 1000;\n\tint nmi_sleep = 0;\n\tint i;\n\n\tverbose = 0;\n\tif (strstr(config, \"V1\"))\n\t\tverbose = 1;\n\tif (strstr(config, \"V2\"))\n\t\tverbose = 2;\n\n\tptr = strchr(config, 'F');\n\tif (ptr)\n\t\tclone_test = simple_strtol(ptr + 1, NULL, 10);\n\tptr = strchr(config, 'S');\n\tif (ptr)\n\t\tdo_sys_open_test = simple_strtol(ptr + 1, NULL, 10);\n\tptr = strchr(config, 'N');\n\tif (ptr)\n\t\tnmi_sleep = simple_strtol(ptr+1, NULL, 10);\n\tptr = strchr(config, 'I');\n\tif (ptr)\n\t\tsstep_test = simple_strtol(ptr+1, NULL, 10);\n\n\t \n\tif (arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT) {\n\t\thwbreaks_ok = 1;\n\t\tv1printk(\"kgdbts:RUN hw breakpoint test\\n\");\n\t\trun_breakpoint_test(1);\n\t\tv1printk(\"kgdbts:RUN hw write breakpoint test\\n\");\n\t\trun_hw_break_test(1);\n\t\tv1printk(\"kgdbts:RUN access write breakpoint test\\n\");\n\t\trun_hw_break_test(0);\n\t}\n\n\t \n\tv1printk(\"kgdbts:RUN plant and detach test\\n\");\n\trun_plant_and_detach_test(0);\n\tv1printk(\"kgdbts:RUN sw breakpoint test\\n\");\n\trun_breakpoint_test(0);\n\tv1printk(\"kgdbts:RUN bad memory access test\\n\");\n\trun_bad_read_test();\n\tv1printk(\"kgdbts:RUN singlestep test %i iterations\\n\", sstep_test);\n\tfor (i = 0; i < sstep_test; i++) {\n\t\trun_singlestep_break_test();\n\t\tif (i % 100 == 0)\n\t\t\tv1printk(\"kgdbts:RUN singlestep [%i/%i]\\n\",\n\t\t\t\t i, sstep_test);\n\t}\n\n\t \n\n\tif (nmi_sleep) {\n\t\tv1printk(\"kgdbts:RUN NMI sleep %i seconds test\\n\", nmi_sleep);\n\t\trun_nmi_sleep_test(nmi_sleep);\n\t}\n\n\t \n\tif (clone_test) {\n\t\trepeat_test = clone_test;\n\t\tprintk(KERN_INFO \"kgdbts:RUN kernel_clone for %i breakpoints\\n\",\n\t\t\trepeat_test);\n\t\tkthread_run(kgdbts_unreg_thread, NULL, \"kgdbts_unreg\");\n\t\trun_kernel_clone_test();\n\t\treturn;\n\t}\n\n\t \n\tif (do_sys_open_test) {\n\t\trepeat_test = do_sys_open_test;\n\t\tprintk(KERN_INFO \"kgdbts:RUN sys_open for %i breakpoints\\n\",\n\t\t\trepeat_test);\n\t\tkthread_run(kgdbts_unreg_thread, NULL, \"kgdbts_unreg\");\n\t\trun_sys_open_test();\n\t\treturn;\n\t}\n\t \n\tkgdb_unregister_io_module(&kgdbts_io_ops);\n\tconfigured = 0;\n}\n\nstatic int kgdbts_option_setup(char *opt)\n{\n\tif (strlen(opt) >= MAX_CONFIG_LEN) {\n\t\tprintk(KERN_ERR \"kgdbts: config string too long\\n\");\n\t\treturn 1;\n\t}\n\tstrcpy(config, opt);\n\treturn 1;\n}\n\n__setup(\"kgdbts=\", kgdbts_option_setup);\n\nstatic int configure_kgdbts(void)\n{\n\tint err = 0;\n\n\tif (!strlen(config) || isspace(config[0]))\n\t\tgoto noconfig;\n\n\tfinal_ack = 0;\n\trun_plant_and_detach_test(1);\n\n\terr = kgdb_register_io_module(&kgdbts_io_ops);\n\tif (err) {\n\t\tconfigured = 0;\n\t\treturn err;\n\t}\n\tconfigured = 1;\n\tkgdbts_run_tests();\n\n\treturn err;\n\nnoconfig:\n\tconfig[0] = 0;\n\tconfigured = 0;\n\n\treturn err;\n}\n\nstatic int __init init_kgdbts(void)\n{\n\t \n\tif (configured == 1)\n\t\treturn 0;\n\n\treturn configure_kgdbts();\n}\ndevice_initcall(init_kgdbts);\n\nstatic int kgdbts_get_char(void)\n{\n\tint val = 0;\n\n\tif (ts.run_test)\n\t\tval = ts.run_test(1, 0);\n\n\treturn val;\n}\n\nstatic void kgdbts_put_char(u8 chr)\n{\n\tif (ts.run_test)\n\t\tts.run_test(0, chr);\n}\n\nstatic int param_set_kgdbts_var(const char *kmessage,\n\t\t\t\tconst struct kernel_param *kp)\n{\n\tsize_t len = strlen(kmessage);\n\n\tif (len >= MAX_CONFIG_LEN) {\n\t\tprintk(KERN_ERR \"kgdbts: config string too long\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tif (configured < 0) {\n\t\tstrcpy(config, kmessage);\n\t\treturn 0;\n\t}\n\n\tif (configured == 1) {\n\t\tprintk(KERN_ERR \"kgdbts: ERROR: Already configured and running.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tstrcpy(config, kmessage);\n\t \n\tif (len && config[len - 1] == '\\n')\n\t\tconfig[len - 1] = '\\0';\n\n\t \n\treturn configure_kgdbts();\n}\n\nstatic void kgdbts_pre_exp_handler(void)\n{\n\t \n\tif (!kgdb_connected)\n\t\ttry_module_get(THIS_MODULE);\n}\n\nstatic void kgdbts_post_exp_handler(void)\n{\n\t \n\tif (!kgdb_connected)\n\t\tmodule_put(THIS_MODULE);\n}\n\nstatic struct kgdb_io kgdbts_io_ops = {\n\t.name\t\t\t= \"kgdbts\",\n\t.read_char\t\t= kgdbts_get_char,\n\t.write_char\t\t= kgdbts_put_char,\n\t.pre_exception\t\t= kgdbts_pre_exp_handler,\n\t.post_exception\t\t= kgdbts_post_exp_handler,\n};\n\n \nmodule_param_call(kgdbts, param_set_kgdbts_var, param_get_string, &kps, 0644);\nMODULE_PARM_DESC(kgdbts, \"<A|V1|V2>[F#|S#][N#]\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}