{
  "module_name": "sram.c",
  "hash_id": "247a8ffa1a80f594e611121441b19bdbd05b91b93ac0c552e5206ac04229e30e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sram.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/genalloc.h>\n#include <linux/io.h>\n#include <linux/list_sort.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/mfd/syscon.h>\n#include <soc/at91/atmel-secumod.h>\n\n#include \"sram.h\"\n\n#define SRAM_GRANULARITY\t32\n\nstatic ssize_t sram_read(struct file *filp, struct kobject *kobj,\n\t\t\t struct bin_attribute *attr,\n\t\t\t char *buf, loff_t pos, size_t count)\n{\n\tstruct sram_partition *part;\n\n\tpart = container_of(attr, struct sram_partition, battr);\n\n\tmutex_lock(&part->lock);\n\tmemcpy_fromio(buf, part->base + pos, count);\n\tmutex_unlock(&part->lock);\n\n\treturn count;\n}\n\nstatic ssize_t sram_write(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *attr,\n\t\t\t  char *buf, loff_t pos, size_t count)\n{\n\tstruct sram_partition *part;\n\n\tpart = container_of(attr, struct sram_partition, battr);\n\n\tmutex_lock(&part->lock);\n\tmemcpy_toio(part->base + pos, buf, count);\n\tmutex_unlock(&part->lock);\n\n\treturn count;\n}\n\nstatic int sram_add_pool(struct sram_dev *sram, struct sram_reserve *block,\n\t\t\t phys_addr_t start, struct sram_partition *part)\n{\n\tint ret;\n\n\tpart->pool = devm_gen_pool_create(sram->dev, ilog2(SRAM_GRANULARITY),\n\t\t\t\t\t  NUMA_NO_NODE, block->label);\n\tif (IS_ERR(part->pool))\n\t\treturn PTR_ERR(part->pool);\n\n\tret = gen_pool_add_virt(part->pool, (unsigned long)part->base, start,\n\t\t\t\tblock->size, NUMA_NO_NODE);\n\tif (ret < 0) {\n\t\tdev_err(sram->dev, \"failed to register subpool: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sram_add_export(struct sram_dev *sram, struct sram_reserve *block,\n\t\t\t   phys_addr_t start, struct sram_partition *part)\n{\n\tsysfs_bin_attr_init(&part->battr);\n\tpart->battr.attr.name = devm_kasprintf(sram->dev, GFP_KERNEL,\n\t\t\t\t\t       \"%llx.sram\",\n\t\t\t\t\t       (unsigned long long)start);\n\tif (!part->battr.attr.name)\n\t\treturn -ENOMEM;\n\n\tpart->battr.attr.mode = S_IRUSR | S_IWUSR;\n\tpart->battr.read = sram_read;\n\tpart->battr.write = sram_write;\n\tpart->battr.size = block->size;\n\n\treturn device_create_bin_file(sram->dev, &part->battr);\n}\n\nstatic int sram_add_partition(struct sram_dev *sram, struct sram_reserve *block,\n\t\t\t      phys_addr_t start)\n{\n\tint ret;\n\tstruct sram_partition *part = &sram->partition[sram->partitions];\n\n\tmutex_init(&part->lock);\n\n\tif (sram->config && sram->config->map_only_reserved) {\n\t\tvoid __iomem *virt_base;\n\n\t\tif (sram->no_memory_wc)\n\t\t\tvirt_base = devm_ioremap_resource(sram->dev, &block->res);\n\t\telse\n\t\t\tvirt_base = devm_ioremap_resource_wc(sram->dev, &block->res);\n\n\t\tif (IS_ERR(virt_base)) {\n\t\t\tdev_err(sram->dev, \"could not map SRAM at %pr\\n\", &block->res);\n\t\t\treturn PTR_ERR(virt_base);\n\t\t}\n\n\t\tpart->base = virt_base;\n\t} else {\n\t\tpart->base = sram->virt_base + block->start;\n\t}\n\n\tif (block->pool) {\n\t\tret = sram_add_pool(sram, block, start, part);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (block->export) {\n\t\tret = sram_add_export(sram, block, start, part);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (block->protect_exec) {\n\t\tret = sram_check_protect_exec(sram, block, part);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = sram_add_pool(sram, block, start, part);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsram_add_protect_exec(part);\n\t}\n\n\tsram->partitions++;\n\n\treturn 0;\n}\n\nstatic void sram_free_partitions(struct sram_dev *sram)\n{\n\tstruct sram_partition *part;\n\n\tif (!sram->partitions)\n\t\treturn;\n\n\tpart = &sram->partition[sram->partitions - 1];\n\tfor (; sram->partitions; sram->partitions--, part--) {\n\t\tif (part->battr.size)\n\t\t\tdevice_remove_bin_file(sram->dev, &part->battr);\n\n\t\tif (part->pool &&\n\t\t    gen_pool_avail(part->pool) < gen_pool_size(part->pool))\n\t\t\tdev_err(sram->dev, \"removed pool while SRAM allocated\\n\");\n\t}\n}\n\nstatic int sram_reserve_cmp(void *priv, const struct list_head *a,\n\t\t\t\t\tconst struct list_head *b)\n{\n\tstruct sram_reserve *ra = list_entry(a, struct sram_reserve, list);\n\tstruct sram_reserve *rb = list_entry(b, struct sram_reserve, list);\n\n\treturn ra->start - rb->start;\n}\n\nstatic int sram_reserve_regions(struct sram_dev *sram, struct resource *res)\n{\n\tstruct device_node *np = sram->dev->of_node, *child;\n\tunsigned long size, cur_start, cur_size;\n\tstruct sram_reserve *rblocks, *block;\n\tstruct list_head reserve_list;\n\tunsigned int nblocks, exports = 0;\n\tconst char *label;\n\tint ret = 0;\n\n\tINIT_LIST_HEAD(&reserve_list);\n\n\tsize = resource_size(res);\n\n\t \n\tnblocks = (np) ? of_get_available_child_count(np) + 1 : 1;\n\trblocks = kcalloc(nblocks, sizeof(*rblocks), GFP_KERNEL);\n\tif (!rblocks)\n\t\treturn -ENOMEM;\n\n\tblock = &rblocks[0];\n\tfor_each_available_child_of_node(np, child) {\n\t\tstruct resource child_res;\n\n\t\tret = of_address_to_resource(child, 0, &child_res);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sram->dev,\n\t\t\t\t\"could not get address for node %pOF\\n\",\n\t\t\t\tchild);\n\t\t\tgoto err_chunks;\n\t\t}\n\n\t\tif (child_res.start < res->start || child_res.end > res->end) {\n\t\t\tdev_err(sram->dev,\n\t\t\t\t\"reserved block %pOF outside the sram area\\n\",\n\t\t\t\tchild);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_chunks;\n\t\t}\n\n\t\tblock->start = child_res.start - res->start;\n\t\tblock->size = resource_size(&child_res);\n\t\tblock->res = child_res;\n\t\tlist_add_tail(&block->list, &reserve_list);\n\n\t\tblock->export = of_property_read_bool(child, \"export\");\n\t\tblock->pool = of_property_read_bool(child, \"pool\");\n\t\tblock->protect_exec = of_property_read_bool(child, \"protect-exec\");\n\n\t\tif ((block->export || block->pool || block->protect_exec) &&\n\t\t    block->size) {\n\t\t\texports++;\n\n\t\t\tlabel = NULL;\n\t\t\tret = of_property_read_string(child, \"label\", &label);\n\t\t\tif (ret && ret != -EINVAL) {\n\t\t\t\tdev_err(sram->dev,\n\t\t\t\t\t\"%pOF has invalid label name\\n\",\n\t\t\t\t\tchild);\n\t\t\t\tgoto err_chunks;\n\t\t\t}\n\t\t\tif (!label)\n\t\t\t\tblock->label = devm_kasprintf(sram->dev, GFP_KERNEL,\n\t\t\t\t\t\t\t      \"%s\", of_node_full_name(child));\n\t\t\telse\n\t\t\t\tblock->label = devm_kstrdup(sram->dev,\n\t\t\t\t\t\t\t    label, GFP_KERNEL);\n\t\t\tif (!block->label) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_chunks;\n\t\t\t}\n\n\t\t\tdev_dbg(sram->dev, \"found %sblock '%s' 0x%x-0x%x\\n\",\n\t\t\t\tblock->export ? \"exported \" : \"\", block->label,\n\t\t\t\tblock->start, block->start + block->size);\n\t\t} else {\n\t\t\tdev_dbg(sram->dev, \"found reserved block 0x%x-0x%x\\n\",\n\t\t\t\tblock->start, block->start + block->size);\n\t\t}\n\n\t\tblock++;\n\t}\n\tchild = NULL;\n\n\t \n\trblocks[nblocks - 1].start = size;\n\trblocks[nblocks - 1].size = 0;\n\tlist_add_tail(&rblocks[nblocks - 1].list, &reserve_list);\n\n\tlist_sort(NULL, &reserve_list, sram_reserve_cmp);\n\n\tif (exports) {\n\t\tsram->partition = devm_kcalloc(sram->dev,\n\t\t\t\t       exports, sizeof(*sram->partition),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!sram->partition) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_chunks;\n\t\t}\n\t}\n\n\tcur_start = 0;\n\tlist_for_each_entry(block, &reserve_list, list) {\n\t\t \n\t\tif (block->start < cur_start) {\n\t\t\tdev_err(sram->dev,\n\t\t\t\t\"block at 0x%x starts after current offset 0x%lx\\n\",\n\t\t\t\tblock->start, cur_start);\n\t\t\tret = -EINVAL;\n\t\t\tsram_free_partitions(sram);\n\t\t\tgoto err_chunks;\n\t\t}\n\n\t\tif ((block->export || block->pool || block->protect_exec) &&\n\t\t    block->size) {\n\t\t\tret = sram_add_partition(sram, block,\n\t\t\t\t\t\t res->start + block->start);\n\t\t\tif (ret) {\n\t\t\t\tsram_free_partitions(sram);\n\t\t\t\tgoto err_chunks;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (block->start == cur_start) {\n\t\t\tcur_start = block->start + block->size;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tcur_size = block->start - cur_start;\n\n\t\tif (sram->pool) {\n\t\t\tdev_dbg(sram->dev, \"adding chunk 0x%lx-0x%lx\\n\",\n\t\t\t\tcur_start, cur_start + cur_size);\n\n\t\t\tret = gen_pool_add_virt(sram->pool,\n\t\t\t\t\t(unsigned long)sram->virt_base + cur_start,\n\t\t\t\t\tres->start + cur_start, cur_size, -1);\n\t\t\tif (ret < 0) {\n\t\t\t\tsram_free_partitions(sram);\n\t\t\t\tgoto err_chunks;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tcur_start = block->start + block->size;\n\t}\n\nerr_chunks:\n\tof_node_put(child);\n\tkfree(rblocks);\n\n\treturn ret;\n}\n\nstatic int atmel_securam_wait(void)\n{\n\tstruct regmap *regmap;\n\tu32 val;\n\n\tregmap = syscon_regmap_lookup_by_compatible(\"atmel,sama5d2-secumod\");\n\tif (IS_ERR(regmap))\n\t\treturn -ENODEV;\n\n\treturn regmap_read_poll_timeout(regmap, AT91_SECUMOD_RAMRDY, val,\n\t\t\t\t\tval & AT91_SECUMOD_RAMRDY_READY,\n\t\t\t\t\t10000, 500000);\n}\n\nstatic const struct sram_config atmel_securam_config = {\n\t.init = atmel_securam_wait,\n};\n\n \nstatic const struct sram_config tegra_sysram_config = {\n\t.map_only_reserved = true,\n};\n\nstatic const struct of_device_id sram_dt_ids[] = {\n\t{ .compatible = \"mmio-sram\" },\n\t{ .compatible = \"atmel,sama5d2-securam\", .data = &atmel_securam_config },\n\t{ .compatible = \"nvidia,tegra186-sysram\", .data = &tegra_sysram_config },\n\t{ .compatible = \"nvidia,tegra194-sysram\", .data = &tegra_sysram_config },\n\t{ .compatible = \"nvidia,tegra234-sysram\", .data = &tegra_sysram_config },\n\t{}\n};\n\nstatic int sram_probe(struct platform_device *pdev)\n{\n\tconst struct sram_config *config;\n\tstruct sram_dev *sram;\n\tint ret;\n\tstruct resource *res;\n\tstruct clk *clk;\n\n\tconfig = of_device_get_match_data(&pdev->dev);\n\n\tsram = devm_kzalloc(&pdev->dev, sizeof(*sram), GFP_KERNEL);\n\tif (!sram)\n\t\treturn -ENOMEM;\n\n\tsram->dev = &pdev->dev;\n\tsram->no_memory_wc = of_property_read_bool(pdev->dev.of_node, \"no-memory-wc\");\n\tsram->config = config;\n\n\tif (!config || !config->map_only_reserved) {\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\tif (sram->no_memory_wc)\n\t\t\tsram->virt_base = devm_ioremap_resource(&pdev->dev, res);\n\t\telse\n\t\t\tsram->virt_base = devm_ioremap_resource_wc(&pdev->dev, res);\n\t\tif (IS_ERR(sram->virt_base)) {\n\t\t\tdev_err(&pdev->dev, \"could not map SRAM registers\\n\");\n\t\t\treturn PTR_ERR(sram->virt_base);\n\t\t}\n\n\t\tsram->pool = devm_gen_pool_create(sram->dev, ilog2(SRAM_GRANULARITY),\n\t\t\t\t\t\t  NUMA_NO_NODE, NULL);\n\t\tif (IS_ERR(sram->pool))\n\t\t\treturn PTR_ERR(sram->pool);\n\t}\n\n\tclk = devm_clk_get_optional_enabled(sram->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tret = sram_reserve_regions(sram,\n\t\t\tplatform_get_resource(pdev, IORESOURCE_MEM, 0));\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, sram);\n\n\tif (config && config->init) {\n\t\tret = config->init();\n\t\tif (ret)\n\t\t\tgoto err_free_partitions;\n\t}\n\n\tif (sram->pool)\n\t\tdev_dbg(sram->dev, \"SRAM pool: %zu KiB @ 0x%p\\n\",\n\t\t\tgen_pool_size(sram->pool) / 1024, sram->virt_base);\n\n\treturn 0;\n\nerr_free_partitions:\n\tsram_free_partitions(sram);\n\n\treturn ret;\n}\n\nstatic int sram_remove(struct platform_device *pdev)\n{\n\tstruct sram_dev *sram = platform_get_drvdata(pdev);\n\n\tsram_free_partitions(sram);\n\n\tif (sram->pool && gen_pool_avail(sram->pool) < gen_pool_size(sram->pool))\n\t\tdev_err(sram->dev, \"removed while SRAM allocated\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver sram_driver = {\n\t.driver = {\n\t\t.name = \"sram\",\n\t\t.of_match_table = sram_dt_ids,\n\t},\n\t.probe = sram_probe,\n\t.remove = sram_remove,\n};\n\nstatic int __init sram_init(void)\n{\n\treturn platform_driver_register(&sram_driver);\n}\n\npostcore_initcall(sram_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}