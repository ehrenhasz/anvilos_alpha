{
  "module_name": "atmel-ssc.c",
  "hash_id": "fe65ce82f87c0fc66427437498dedc2f5f856ebf51e94936d010df4238caa5c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/atmel-ssc.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/list.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mutex.h>\n#include <linux/atmel-ssc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <linux/of.h>\n\n#include \"../../sound/soc/atmel/atmel_ssc_dai.h\"\n\n \nstatic DEFINE_MUTEX(user_lock);\nstatic LIST_HEAD(ssc_list);\n\nstruct ssc_device *ssc_request(unsigned int ssc_num)\n{\n\tint ssc_valid = 0;\n\tstruct ssc_device *ssc;\n\n\tmutex_lock(&user_lock);\n\tlist_for_each_entry(ssc, &ssc_list, list) {\n\t\tif (ssc->pdev->dev.of_node) {\n\t\t\tif (of_alias_get_id(ssc->pdev->dev.of_node, \"ssc\")\n\t\t\t\t== ssc_num) {\n\t\t\t\tssc->pdev->id = ssc_num;\n\t\t\t\tssc_valid = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ssc->pdev->id == ssc_num) {\n\t\t\tssc_valid = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ssc_valid) {\n\t\tmutex_unlock(&user_lock);\n\t\tpr_err(\"ssc: ssc%d platform device is missing\\n\", ssc_num);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tif (ssc->user) {\n\t\tmutex_unlock(&user_lock);\n\t\tdev_dbg(&ssc->pdev->dev, \"module busy\\n\");\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tssc->user++;\n\tmutex_unlock(&user_lock);\n\n\tclk_prepare(ssc->clk);\n\n\treturn ssc;\n}\nEXPORT_SYMBOL(ssc_request);\n\nvoid ssc_free(struct ssc_device *ssc)\n{\n\tbool disable_clk = true;\n\n\tmutex_lock(&user_lock);\n\tif (ssc->user)\n\t\tssc->user--;\n\telse {\n\t\tdisable_clk = false;\n\t\tdev_dbg(&ssc->pdev->dev, \"device already free\\n\");\n\t}\n\tmutex_unlock(&user_lock);\n\n\tif (disable_clk)\n\t\tclk_unprepare(ssc->clk);\n}\nEXPORT_SYMBOL(ssc_free);\n\nstatic struct atmel_ssc_platform_data at91rm9200_config = {\n\t.use_dma = 0,\n\t.has_fslen_ext = 0,\n};\n\nstatic struct atmel_ssc_platform_data at91sam9rl_config = {\n\t.use_dma = 0,\n\t.has_fslen_ext = 1,\n};\n\nstatic struct atmel_ssc_platform_data at91sam9g45_config = {\n\t.use_dma = 1,\n\t.has_fslen_ext = 1,\n};\n\nstatic const struct platform_device_id atmel_ssc_devtypes[] = {\n\t{\n\t\t.name = \"at91rm9200_ssc\",\n\t\t.driver_data = (unsigned long) &at91rm9200_config,\n\t}, {\n\t\t.name = \"at91sam9rl_ssc\",\n\t\t.driver_data = (unsigned long) &at91sam9rl_config,\n\t}, {\n\t\t.name = \"at91sam9g45_ssc\",\n\t\t.driver_data = (unsigned long) &at91sam9g45_config,\n\t}, {\n\t\t \n\t}\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id atmel_ssc_dt_ids[] = {\n\t{\n\t\t.compatible = \"atmel,at91rm9200-ssc\",\n\t\t.data = &at91rm9200_config,\n\t}, {\n\t\t.compatible = \"atmel,at91sam9rl-ssc\",\n\t\t.data = &at91sam9rl_config,\n\t}, {\n\t\t.compatible = \"atmel,at91sam9g45-ssc\",\n\t\t.data = &at91sam9g45_config,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, atmel_ssc_dt_ids);\n#endif\n\nstatic inline const struct atmel_ssc_platform_data *\n\tatmel_ssc_get_driver_data(struct platform_device *pdev)\n{\n\tif (pdev->dev.of_node) {\n\t\tconst struct of_device_id *match;\n\t\tmatch = of_match_node(atmel_ssc_dt_ids, pdev->dev.of_node);\n\t\tif (match == NULL)\n\t\t\treturn NULL;\n\t\treturn match->data;\n\t}\n\n\treturn (struct atmel_ssc_platform_data *)\n\t\tplatform_get_device_id(pdev)->driver_data;\n}\n\n#ifdef CONFIG_SND_ATMEL_SOC_SSC\nstatic int ssc_sound_dai_probe(struct ssc_device *ssc)\n{\n\tstruct device_node *np = ssc->pdev->dev.of_node;\n\tint ret;\n\tint id;\n\n\tssc->sound_dai = false;\n\n\tif (!of_property_read_bool(np, \"#sound-dai-cells\"))\n\t\treturn 0;\n\n\tid = of_alias_get_id(np, \"ssc\");\n\tif (id < 0)\n\t\treturn id;\n\n\tret = atmel_ssc_set_audio(id);\n\tssc->sound_dai = !ret;\n\n\treturn ret;\n}\n\nstatic void ssc_sound_dai_remove(struct ssc_device *ssc)\n{\n\tif (!ssc->sound_dai)\n\t\treturn;\n\n\tatmel_ssc_put_audio(of_alias_get_id(ssc->pdev->dev.of_node, \"ssc\"));\n}\n#else\nstatic inline int ssc_sound_dai_probe(struct ssc_device *ssc)\n{\n\tif (of_property_read_bool(ssc->pdev->dev.of_node, \"#sound-dai-cells\"))\n\t\treturn -ENOTSUPP;\n\n\treturn 0;\n}\n\nstatic inline void ssc_sound_dai_remove(struct ssc_device *ssc)\n{\n}\n#endif\n\nstatic int ssc_probe(struct platform_device *pdev)\n{\n\tstruct resource *regs;\n\tstruct ssc_device *ssc;\n\tconst struct atmel_ssc_platform_data *plat_dat;\n\n\tssc = devm_kzalloc(&pdev->dev, sizeof(struct ssc_device), GFP_KERNEL);\n\tif (!ssc) {\n\t\tdev_dbg(&pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tssc->pdev = pdev;\n\n\tplat_dat = atmel_ssc_get_driver_data(pdev);\n\tif (!plat_dat)\n\t\treturn -ENODEV;\n\tssc->pdata = (struct atmel_ssc_platform_data *)plat_dat;\n\n\tif (pdev->dev.of_node) {\n\t\tstruct device_node *np = pdev->dev.of_node;\n\t\tssc->clk_from_rk_pin =\n\t\t\tof_property_read_bool(np, \"atmel,clk-from-rk-pin\");\n\t}\n\n\tssc->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &regs);\n\tif (IS_ERR(ssc->regs))\n\t\treturn PTR_ERR(ssc->regs);\n\n\tssc->phybase = regs->start;\n\n\tssc->clk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(ssc->clk)) {\n\t\tdev_dbg(&pdev->dev, \"no pclk clock defined\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tclk_prepare_enable(ssc->clk);\n\tssc_writel(ssc->regs, IDR, -1);\n\tssc_readl(ssc->regs, SR);\n\tclk_disable_unprepare(ssc->clk);\n\n\tssc->irq = platform_get_irq(pdev, 0);\n\tif (ssc->irq < 0) {\n\t\tdev_dbg(&pdev->dev, \"could not get irq\\n\");\n\t\treturn ssc->irq;\n\t}\n\n\tmutex_lock(&user_lock);\n\tlist_add_tail(&ssc->list, &ssc_list);\n\tmutex_unlock(&user_lock);\n\n\tplatform_set_drvdata(pdev, ssc);\n\n\tdev_info(&pdev->dev, \"Atmel SSC device at 0x%p (irq %d)\\n\",\n\t\t\tssc->regs, ssc->irq);\n\n\tif (ssc_sound_dai_probe(ssc))\n\t\tdev_err(&pdev->dev, \"failed to auto-setup ssc for audio\\n\");\n\n\treturn 0;\n}\n\nstatic int ssc_remove(struct platform_device *pdev)\n{\n\tstruct ssc_device *ssc = platform_get_drvdata(pdev);\n\n\tssc_sound_dai_remove(ssc);\n\n\tmutex_lock(&user_lock);\n\tlist_del(&ssc->list);\n\tmutex_unlock(&user_lock);\n\n\treturn 0;\n}\n\nstatic struct platform_driver ssc_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"ssc\",\n\t\t.of_match_table\t= of_match_ptr(atmel_ssc_dt_ids),\n\t},\n\t.id_table\t= atmel_ssc_devtypes,\n\t.probe\t\t= ssc_probe,\n\t.remove\t\t= ssc_remove,\n};\nmodule_platform_driver(ssc_driver);\n\nMODULE_AUTHOR(\"Hans-Christian Noren Egtvedt <egtvedt@samfundet.no>\");\nMODULE_DESCRIPTION(\"SSC driver for Atmel AT91\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ssc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}