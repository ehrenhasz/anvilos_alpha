{
  "module_name": "open-dice.c",
  "hash_id": "4f0211bd56780d674f617f2b6401bf278e67fa5bcdcd9ff3a586e9a25ad7be97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/open-dice.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/miscdevice.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n\n#define DRIVER_NAME \"open-dice\"\n\nstruct open_dice_drvdata {\n\tstruct mutex lock;\n\tchar name[16];\n\tstruct reserved_mem *rmem;\n\tstruct miscdevice misc;\n};\n\nstatic inline struct open_dice_drvdata *to_open_dice_drvdata(struct file *filp)\n{\n\treturn container_of(filp->private_data, struct open_dice_drvdata, misc);\n}\n\nstatic int open_dice_wipe(struct open_dice_drvdata *drvdata)\n{\n\tvoid *kaddr;\n\n\tmutex_lock(&drvdata->lock);\n\tkaddr = devm_memremap(drvdata->misc.this_device, drvdata->rmem->base,\n\t\t\t      drvdata->rmem->size, MEMREMAP_WC);\n\tif (IS_ERR(kaddr)) {\n\t\tmutex_unlock(&drvdata->lock);\n\t\treturn PTR_ERR(kaddr);\n\t}\n\n\tmemset(kaddr, 0, drvdata->rmem->size);\n\tdevm_memunmap(drvdata->misc.this_device, kaddr);\n\tmutex_unlock(&drvdata->lock);\n\treturn 0;\n}\n\n \nstatic ssize_t open_dice_read(struct file *filp, char __user *ptr, size_t len,\n\t\t\t      loff_t *off)\n{\n\tunsigned long val = to_open_dice_drvdata(filp)->rmem->size;\n\n\treturn simple_read_from_buffer(ptr, len, off, &val, sizeof(val));\n}\n\n \nstatic ssize_t open_dice_write(struct file *filp, const char __user *ptr,\n\t\t\t       size_t len, loff_t *off)\n{\n\tif (open_dice_wipe(to_open_dice_drvdata(filp)))\n\t\treturn -EIO;\n\n\t \n\treturn len;\n}\n\n \nstatic int open_dice_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct open_dice_drvdata *drvdata = to_open_dice_drvdata(filp);\n\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\t \n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\treturn -EPERM;\n\t\t \n\t\tvm_flags_clear(vma, VM_MAYWRITE);\n\t}\n\n\t \n\tvma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);\n\tvm_flags_set(vma, VM_DONTCOPY | VM_DONTDUMP);\n\treturn vm_iomap_memory(vma, drvdata->rmem->base, drvdata->rmem->size);\n}\n\nstatic const struct file_operations open_dice_fops = {\n\t.owner = THIS_MODULE,\n\t.read = open_dice_read,\n\t.write = open_dice_write,\n\t.mmap = open_dice_mmap,\n};\n\nstatic int __init open_dice_probe(struct platform_device *pdev)\n{\n\tstatic unsigned int dev_idx;\n\tstruct device *dev = &pdev->dev;\n\tstruct reserved_mem *rmem;\n\tstruct open_dice_drvdata *drvdata;\n\tint ret;\n\n\trmem = of_reserved_mem_lookup(dev->of_node);\n\tif (!rmem) {\n\t\tdev_err(dev, \"failed to lookup reserved memory\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rmem->size || (rmem->size > ULONG_MAX)) {\n\t\tdev_err(dev, \"invalid memory region size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!PAGE_ALIGNED(rmem->base) || !PAGE_ALIGNED(rmem->size)) {\n\t\tdev_err(dev, \"memory region must be page-aligned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrvdata = devm_kmalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\t*drvdata = (struct open_dice_drvdata){\n\t\t.lock = __MUTEX_INITIALIZER(drvdata->lock),\n\t\t.rmem = rmem,\n\t\t.misc = (struct miscdevice){\n\t\t\t.parent\t= dev,\n\t\t\t.name\t= drvdata->name,\n\t\t\t.minor\t= MISC_DYNAMIC_MINOR,\n\t\t\t.fops\t= &open_dice_fops,\n\t\t\t.mode\t= 0600,\n\t\t},\n\t};\n\n\t \n\tsnprintf(drvdata->name, sizeof(drvdata->name), DRIVER_NAME\"%u\", dev_idx++);\n\n\tret = misc_register(&drvdata->misc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register misc device '%s': %d\\n\",\n\t\t\tdrvdata->name, ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, drvdata);\n\treturn 0;\n}\n\nstatic int open_dice_remove(struct platform_device *pdev)\n{\n\tstruct open_dice_drvdata *drvdata = platform_get_drvdata(pdev);\n\n\tmisc_deregister(&drvdata->misc);\n\treturn 0;\n}\n\nstatic const struct of_device_id open_dice_of_match[] = {\n\t{ .compatible = \"google,open-dice\" },\n\t{},\n};\n\nstatic struct platform_driver open_dice_driver = {\n\t.remove = open_dice_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = open_dice_of_match,\n\t},\n};\n\nstatic int __init open_dice_init(void)\n{\n\tint ret = platform_driver_probe(&open_dice_driver, open_dice_probe);\n\n\t \n\treturn (ret == -ENODEV) ? 0 : ret;\n}\n\nstatic void __exit open_dice_exit(void)\n{\n\tplatform_driver_unregister(&open_dice_driver);\n}\n\nmodule_init(open_dice_init);\nmodule_exit(open_dice_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"David Brazdil <dbrazdil@google.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}