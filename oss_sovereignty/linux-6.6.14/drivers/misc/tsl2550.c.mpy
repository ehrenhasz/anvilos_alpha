{
  "module_name": "tsl2550.c",
  "hash_id": "b7a2cdd23fda2e6e006cb75b4405c7016de728da79536718e5ef841a7aceac52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/tsl2550.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n\n#define TSL2550_DRV_NAME\t\"tsl2550\"\n#define DRIVER_VERSION\t\t\"1.2\"\n\n \n\n#define TSL2550_POWER_DOWN\t\t0x00\n#define TSL2550_POWER_UP\t\t0x03\n#define TSL2550_STANDARD_RANGE\t\t0x18\n#define TSL2550_EXTENDED_RANGE\t\t0x1d\n#define TSL2550_READ_ADC0\t\t0x43\n#define TSL2550_READ_ADC1\t\t0x83\n\n \n\nstruct tsl2550_data {\n\tstruct i2c_client *client;\n\tstruct mutex update_lock;\n\n\tunsigned int power_state:1;\n\tunsigned int operating_mode:1;\n};\n\n \n\nstatic const u8 TSL2550_MODE_RANGE[2] = {\n\tTSL2550_STANDARD_RANGE, TSL2550_EXTENDED_RANGE,\n};\n\n \n\nstatic int tsl2550_set_operating_mode(struct i2c_client *client, int mode)\n{\n\tstruct tsl2550_data *data = i2c_get_clientdata(client);\n\n\tint ret = i2c_smbus_write_byte(client, TSL2550_MODE_RANGE[mode]);\n\n\tdata->operating_mode = mode;\n\n\treturn ret;\n}\n\nstatic int tsl2550_set_power_state(struct i2c_client *client, int state)\n{\n\tstruct tsl2550_data *data = i2c_get_clientdata(client);\n\tint ret;\n\n\tif (state == 0)\n\t\tret = i2c_smbus_write_byte(client, TSL2550_POWER_DOWN);\n\telse {\n\t\tret = i2c_smbus_write_byte(client, TSL2550_POWER_UP);\n\n\t\t \n\t\ttsl2550_set_operating_mode(client, data->operating_mode);\n\t}\n\n\tdata->power_state = state;\n\n\treturn ret;\n}\n\nstatic int tsl2550_get_adc_value(struct i2c_client *client, u8 cmd)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!(ret & 0x80))\n\t\treturn -EAGAIN;\n\treturn ret & 0x7f;\t \n}\n\n \n\n#define\tTSL2550_MAX_LUX\t\t1846\n\nstatic const u8 ratio_lut[] = {\n\t100, 100, 100, 100, 100, 100, 100, 100,\n\t100, 100, 100, 100, 100, 100, 99, 99,\n\t99, 99, 99, 99, 99, 99, 99, 99,\n\t99, 99, 99, 98, 98, 98, 98, 98,\n\t98, 98, 97, 97, 97, 97, 97, 96,\n\t96, 96, 96, 95, 95, 95, 94, 94,\n\t93, 93, 93, 92, 92, 91, 91, 90,\n\t89, 89, 88, 87, 87, 86, 85, 84,\n\t83, 82, 81, 80, 79, 78, 77, 75,\n\t74, 73, 71, 69, 68, 66, 64, 62,\n\t60, 58, 56, 54, 52, 49, 47, 44,\n\t42, 41, 40, 40, 39, 39, 38, 38,\n\t37, 37, 37, 36, 36, 36, 35, 35,\n\t35, 35, 34, 34, 34, 34, 33, 33,\n\t33, 33, 32, 32, 32, 32, 32, 31,\n\t31, 31, 31, 31, 30, 30, 30, 30,\n\t30,\n};\n\nstatic const u16 count_lut[] = {\n\t0, 1, 2, 3, 4, 5, 6, 7,\n\t8, 9, 10, 11, 12, 13, 14, 15,\n\t16, 18, 20, 22, 24, 26, 28, 30,\n\t32, 34, 36, 38, 40, 42, 44, 46,\n\t49, 53, 57, 61, 65, 69, 73, 77,\n\t81, 85, 89, 93, 97, 101, 105, 109,\n\t115, 123, 131, 139, 147, 155, 163, 171,\n\t179, 187, 195, 203, 211, 219, 227, 235,\n\t247, 263, 279, 295, 311, 327, 343, 359,\n\t375, 391, 407, 423, 439, 455, 471, 487,\n\t511, 543, 575, 607, 639, 671, 703, 735,\n\t767, 799, 831, 863, 895, 927, 959, 991,\n\t1039, 1103, 1167, 1231, 1295, 1359, 1423, 1487,\n\t1551, 1615, 1679, 1743, 1807, 1871, 1935, 1999,\n\t2095, 2223, 2351, 2479, 2607, 2735, 2863, 2991,\n\t3119, 3247, 3375, 3503, 3631, 3759, 3887, 4015,\n};\n\n \nstatic int tsl2550_calculate_lux(u8 ch0, u8 ch1)\n{\n\tunsigned int lux;\n\n\t \n\tu16 c0 = count_lut[ch0];\n\tu16 c1 = count_lut[ch1];\n\n\t \n\tif (c1 <= c0)\n\t\tif (c0) {\n\t\t\t \n\t\t\tu8 r = c1 * 128 / c0;\n\n\t\t\t \n\t\t\tlux = ((c0 - c1) * ratio_lut[r]) / 256;\n\t\t} else\n\t\t\tlux = 0;\n\telse\n\t\treturn 0;\n\n\t \n\treturn lux > TSL2550_MAX_LUX ? TSL2550_MAX_LUX : lux;\n}\n\n \n\nstatic ssize_t tsl2550_show_power_state(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct tsl2550_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\n\treturn sprintf(buf, \"%u\\n\", data->power_state);\n}\n\nstatic ssize_t tsl2550_store_power_state(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct tsl2550_data *data = i2c_get_clientdata(client);\n\tunsigned long val = simple_strtoul(buf, NULL, 10);\n\tint ret;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->update_lock);\n\tret = tsl2550_set_power_state(client, val);\n\tmutex_unlock(&data->update_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(power_state, S_IWUSR | S_IRUGO,\n\t\t   tsl2550_show_power_state, tsl2550_store_power_state);\n\nstatic ssize_t tsl2550_show_operating_mode(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct tsl2550_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\n\treturn sprintf(buf, \"%u\\n\", data->operating_mode);\n}\n\nstatic ssize_t tsl2550_store_operating_mode(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct tsl2550_data *data = i2c_get_clientdata(client);\n\tunsigned long val = simple_strtoul(buf, NULL, 10);\n\tint ret;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tif (data->power_state == 0)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&data->update_lock);\n\tret = tsl2550_set_operating_mode(client, val);\n\tmutex_unlock(&data->update_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(operating_mode, S_IWUSR | S_IRUGO,\n\t\t   tsl2550_show_operating_mode, tsl2550_store_operating_mode);\n\nstatic ssize_t __tsl2550_show_lux(struct i2c_client *client, char *buf)\n{\n\tstruct tsl2550_data *data = i2c_get_clientdata(client);\n\tu8 ch0, ch1;\n\tint ret;\n\n\tret = tsl2550_get_adc_value(client, TSL2550_READ_ADC0);\n\tif (ret < 0)\n\t\treturn ret;\n\tch0 = ret;\n\n\tret = tsl2550_get_adc_value(client, TSL2550_READ_ADC1);\n\tif (ret < 0)\n\t\treturn ret;\n\tch1 = ret;\n\n\t \n\tret = tsl2550_calculate_lux(ch0, ch1);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (data->operating_mode == 1)\n\t\tret *= 5;\n\n\treturn sprintf(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t tsl2550_show_lux1_input(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct tsl2550_data *data = i2c_get_clientdata(client);\n\tint ret;\n\n\t \n\tif (!data->power_state)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&data->update_lock);\n\tret = __tsl2550_show_lux(client, buf);\n\tmutex_unlock(&data->update_lock);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(lux1_input, S_IRUGO,\n\t\t   tsl2550_show_lux1_input, NULL);\n\nstatic struct attribute *tsl2550_attributes[] = {\n\t&dev_attr_power_state.attr,\n\t&dev_attr_operating_mode.attr,\n\t&dev_attr_lux1_input.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tsl2550_attr_group = {\n\t.attrs = tsl2550_attributes,\n};\n\n \n\nstatic int tsl2550_init_client(struct i2c_client *client)\n{\n\tstruct tsl2550_data *data = i2c_get_clientdata(client);\n\tint err;\n\n\t \n\terr = i2c_smbus_read_byte_data(client, TSL2550_POWER_UP);\n\tif (err < 0)\n\t\treturn err;\n\tif (err != TSL2550_POWER_UP)\n\t\treturn -ENODEV;\n\tdata->power_state = 1;\n\n\t \n\terr = i2c_smbus_write_byte(client,\n\t\t\t\t   TSL2550_MODE_RANGE[data->operating_mode]);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \n\nstatic struct i2c_driver tsl2550_driver;\nstatic int tsl2550_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct tsl2550_data *data;\n\tint *opmode, err = 0;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_BYTE\n\t\t\t\t\t    | I2C_FUNC_SMBUS_READ_BYTE_DATA)) {\n\t\terr = -EIO;\n\t\tgoto exit;\n\t}\n\n\tdata = kzalloc(sizeof(struct tsl2550_data), GFP_KERNEL);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tdata->client = client;\n\ti2c_set_clientdata(client, data);\n\n\t \n\topmode = client->dev.platform_data;\n\tif (opmode) {\n\t\tif (*opmode < 0 || *opmode > 1) {\n\t\t\tdev_err(&client->dev, \"invalid operating_mode (%d)\\n\",\n\t\t\t\t\t*opmode);\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_kfree;\n\t\t}\n\t\tdata->operating_mode = *opmode;\n\t} else\n\t\tdata->operating_mode = 0;\t \n\tdev_info(&client->dev, \"%s operating mode\\n\",\n\t\t\tdata->operating_mode ? \"extended\" : \"standard\");\n\n\tmutex_init(&data->update_lock);\n\n\t \n\terr = tsl2550_init_client(client);\n\tif (err)\n\t\tgoto exit_kfree;\n\n\t \n\terr = sysfs_create_group(&client->dev.kobj, &tsl2550_attr_group);\n\tif (err)\n\t\tgoto exit_kfree;\n\n\tdev_info(&client->dev, \"support ver. %s enabled\\n\", DRIVER_VERSION);\n\n\treturn 0;\n\nexit_kfree:\n\tkfree(data);\nexit:\n\treturn err;\n}\n\nstatic void tsl2550_remove(struct i2c_client *client)\n{\n\tsysfs_remove_group(&client->dev.kobj, &tsl2550_attr_group);\n\n\t \n\ttsl2550_set_power_state(client, 0);\n\n\tkfree(i2c_get_clientdata(client));\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int tsl2550_suspend(struct device *dev)\n{\n\treturn tsl2550_set_power_state(to_i2c_client(dev), 0);\n}\n\nstatic int tsl2550_resume(struct device *dev)\n{\n\treturn tsl2550_set_power_state(to_i2c_client(dev), 1);\n}\n\nstatic SIMPLE_DEV_PM_OPS(tsl2550_pm_ops, tsl2550_suspend, tsl2550_resume);\n#define TSL2550_PM_OPS (&tsl2550_pm_ops)\n\n#else\n\n#define TSL2550_PM_OPS NULL\n\n#endif  \n\nstatic const struct i2c_device_id tsl2550_id[] = {\n\t{ \"tsl2550\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tsl2550_id);\n\nstatic const struct of_device_id tsl2550_of_match[] = {\n\t{ .compatible = \"taos,tsl2550\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tsl2550_of_match);\n\nstatic struct i2c_driver tsl2550_driver = {\n\t.driver = {\n\t\t.name\t= TSL2550_DRV_NAME,\n\t\t.of_match_table = tsl2550_of_match,\n\t\t.pm\t= TSL2550_PM_OPS,\n\t},\n\t.probe = tsl2550_probe,\n\t.remove\t= tsl2550_remove,\n\t.id_table = tsl2550_id,\n};\n\nmodule_i2c_driver(tsl2550_driver);\n\nMODULE_AUTHOR(\"Rodolfo Giometti <giometti@linux.it>\");\nMODULE_DESCRIPTION(\"TSL2550 ambient light sensor driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRIVER_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}