{
  "module_name": "xilinx_tmr_inject.c",
  "hash_id": "dd703933236efdee5d20b90271893ee0603f440a088a034610cabd9ea4992158",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/xilinx_tmr_inject.c",
  "human_readable_source": "\n \n\n#include <asm/xilinx_mb_manager.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/fault-inject.h>\n\n \n#define XTMR_INJECT_CR_OFFSET\t\t0x0\n#define XTMR_INJECT_AIR_OFFSET\t\t0x4\n#define XTMR_INJECT_IIR_OFFSET\t\t0xC\n#define XTMR_INJECT_EAIR_OFFSET\t\t0x10\n#define XTMR_INJECT_ERR_OFFSET\t\t0x204\n\n \n#define XTMR_INJECT_CR_CPUID_SHIFT\t8\n#define XTMR_INJECT_CR_IE_SHIFT\t\t10\n#define XTMR_INJECT_IIR_ADDR_MASK\tGENMASK(31, 16)\n\n#define XTMR_INJECT_MAGIC_MAX_VAL\t255\n\n \nstruct xtmr_inject_dev {\n\tvoid __iomem *regs;\n\tu32 magic;\n};\n\nstatic DECLARE_FAULT_ATTR(inject_fault);\nstatic char *inject_request;\nmodule_param(inject_request, charp, 0);\nMODULE_PARM_DESC(inject_request, \"default fault injection attributes\");\nstatic struct dentry *dbgfs_root;\n\n \nstatic inline void xtmr_inject_write(struct xtmr_inject_dev *xtmr_inject,\n\t\t\t\t     u32 addr, u32 value)\n{\n\tiowrite32(value, xtmr_inject->regs + addr);\n}\n\nstatic inline u32 xtmr_inject_read(struct xtmr_inject_dev *xtmr_inject,\n\t\t\t\t   u32 addr)\n{\n\treturn ioread32(xtmr_inject->regs + addr);\n}\n\nstatic int xtmr_inject_set(void *data, u64 val)\n{\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\txmb_inject_err();\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(xtmr_inject_fops, NULL, xtmr_inject_set, \"%llu\\n\");\n\nstatic void xtmr_init_debugfs(struct xtmr_inject_dev *xtmr_inject)\n{\n\tstruct dentry *dir;\n\n\tdbgfs_root = debugfs_create_dir(\"xtmr_inject\", NULL);\n\tdir = fault_create_debugfs_attr(\"inject_fault\", dbgfs_root,\n\t\t\t\t\t&inject_fault);\n\tdebugfs_create_file(\"inject_fault\", 0200, dir, NULL,\n\t\t\t    &xtmr_inject_fops);\n}\n\nstatic void xtmr_inject_init(struct xtmr_inject_dev *xtmr_inject)\n{\n\tu32 cr_val;\n\n\tif (inject_request)\n\t\tsetup_fault_attr(&inject_fault, inject_request);\n\t \n\tcr_val = xtmr_inject->magic |\n\t\t (1 << XTMR_INJECT_CR_IE_SHIFT) |\n\t\t (1 << XTMR_INJECT_CR_CPUID_SHIFT);\n\txtmr_inject_write(xtmr_inject, XTMR_INJECT_CR_OFFSET,\n\t\t\t  cr_val);\n\t \n\txtmr_inject_write(xtmr_inject, XTMR_INJECT_AIR_OFFSET,\n\t\t\t  XMB_INJECT_ERR_OFFSET);\n\txtmr_inject_write(xtmr_inject, XTMR_INJECT_IIR_OFFSET,\n\t\t\t  XMB_INJECT_ERR_OFFSET & XTMR_INJECT_IIR_ADDR_MASK);\n}\n\n \nstatic int xtmr_inject_probe(struct platform_device *pdev)\n{\n\tstruct xtmr_inject_dev *xtmr_inject;\n\tint err;\n\n\txtmr_inject = devm_kzalloc(&pdev->dev, sizeof(*xtmr_inject),\n\t\t\t\t   GFP_KERNEL);\n\tif (!xtmr_inject)\n\t\treturn -ENOMEM;\n\n\txtmr_inject->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xtmr_inject->regs))\n\t\treturn PTR_ERR(xtmr_inject->regs);\n\n\terr = of_property_read_u32(pdev->dev.of_node, \"xlnx,magic\",\n\t\t\t\t   &xtmr_inject->magic);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"unable to read xlnx,magic property\");\n\t\treturn err;\n\t}\n\n\tif (xtmr_inject->magic > XTMR_INJECT_MAGIC_MAX_VAL) {\n\t\tdev_err(&pdev->dev, \"invalid xlnx,magic property value\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\txtmr_inject_init(xtmr_inject);\n\n\txtmr_init_debugfs(xtmr_inject);\n\n\tplatform_set_drvdata(pdev, xtmr_inject);\n\n\treturn 0;\n}\n\nstatic int xtmr_inject_remove(struct platform_device *pdev)\n{\n\tdebugfs_remove_recursive(dbgfs_root);\n\tdbgfs_root = NULL;\n\treturn 0;\n}\n\nstatic const struct of_device_id xtmr_inject_of_match[] = {\n\t{\n\t\t.compatible = \"xlnx,tmr-inject-1.0\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, xtmr_inject_of_match);\n\nstatic struct platform_driver xtmr_inject_driver = {\n\t.driver = {\n\t\t.name = \"xilinx-tmr_inject\",\n\t\t.of_match_table = xtmr_inject_of_match,\n\t},\n\t.probe = xtmr_inject_probe,\n\t.remove = xtmr_inject_remove,\n};\nmodule_platform_driver(xtmr_inject_driver);\nMODULE_AUTHOR(\"Advanced Micro Devices, Inc\");\nMODULE_DESCRIPTION(\"Xilinx TMR Inject Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}