{
  "module_name": "bh1770glc.c",
  "hash_id": "177779874509dd522eb7e2ad6f9d09baaef926b700d1560a434767875fca12b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/bh1770glc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/platform_data/bh1770glc.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n\n#define BH1770_ALS_CONTROL\t0x80  \n#define BH1770_PS_CONTROL\t0x81  \n#define BH1770_I_LED\t\t0x82  \n#define BH1770_I_LED3\t\t0x83  \n#define BH1770_ALS_PS_MEAS\t0x84  \n#define BH1770_PS_MEAS_RATE\t0x85  \n#define BH1770_ALS_MEAS_RATE\t0x86  \n#define BH1770_PART_ID\t\t0x8a  \n#define BH1770_MANUFACT_ID\t0x8b  \n#define BH1770_ALS_DATA_0\t0x8c  \n#define BH1770_ALS_DATA_1\t0x8d  \n#define BH1770_ALS_PS_STATUS\t0x8e  \n#define BH1770_PS_DATA_LED1\t0x8f  \n#define BH1770_PS_DATA_LED2\t0x90  \n#define BH1770_PS_DATA_LED3\t0x91  \n#define BH1770_INTERRUPT\t0x92  \n#define BH1770_PS_TH_LED1\t0x93  \n#define BH1770_PS_TH_LED2\t0x94  \n#define BH1770_PS_TH_LED3\t0x95  \n#define BH1770_ALS_TH_UP_0\t0x96  \n#define BH1770_ALS_TH_UP_1\t0x97  \n#define BH1770_ALS_TH_LOW_0\t0x98  \n#define BH1770_ALS_TH_LOW_1\t0x99  \n\n \n#define BH1770_MANUFACT_ROHM\t0x01\n#define BH1770_MANUFACT_OSRAM\t0x03\n\n \n#define BH1770_PART\t\t0x90\n#define BH1770_PART_MASK\t0xf0\n#define BH1770_REV_MASK\t\t0x0f\n#define BH1770_REV_SHIFT\t0\n#define BH1770_REV_0\t\t0x00\n#define BH1770_REV_1\t\t0x01\n\n \n#define BH1770_STANDBY\t\t0x00\n#define BH1770_FORCED\t\t0x02\n#define BH1770_STANDALONE\t0x03\n#define BH1770_SWRESET\t\t(0x01 << 2)\n\n#define BH1770_PS_TRIG_MEAS\t(1 << 0)\n#define BH1770_ALS_TRIG_MEAS\t(1 << 1)\n\n \n#define BH1770_INT_OUTPUT_MODE\t(1 << 3)  \n#define BH1770_INT_POLARITY\t(1 << 2)  \n#define BH1770_INT_ALS_ENA\t(1 << 1)\n#define BH1770_INT_PS_ENA\t(1 << 0)\n\n \n#define BH1770_INT_LED1_DATA\t(1 << 0)\n#define BH1770_INT_LED1_INT\t(1 << 1)\n#define BH1770_INT_LED2_DATA\t(1 << 2)\n#define BH1770_INT_LED2_INT\t(1 << 3)\n#define BH1770_INT_LED3_DATA\t(1 << 4)\n#define BH1770_INT_LED3_INT\t(1 << 5)\n#define BH1770_INT_LEDS_INT\t((1 << 1) | (1 << 3) | (1 << 5))\n#define BH1770_INT_ALS_DATA\t(1 << 6)\n#define BH1770_INT_ALS_INT\t(1 << 7)\n\n \n#define BH1770_LED1\t\t0x00\n\n#define BH1770_DISABLE\t\t0\n#define BH1770_ENABLE\t\t1\n#define BH1770_PROX_CHANNELS\t1\n\n#define BH1770_LUX_DEFAULT_RATE\t1  \n#define BH1770_PROX_DEFAULT_RATE 1  \n#define BH1770_PROX_DEF_RATE_THRESH 6  \n#define BH1770_STARTUP_DELAY\t50\n#define BH1770_RESET_TIME\t10\n#define BH1770_TIMEOUT\t\t2100  \n\n#define BH1770_LUX_RANGE\t65535\n#define BH1770_PROX_RANGE\t255\n#define BH1770_COEF_SCALER\t1024\n#define BH1770_CALIB_SCALER\t8192\n#define BH1770_LUX_NEUTRAL_CALIB_VALUE (1 * BH1770_CALIB_SCALER)\n#define BH1770_LUX_DEF_THRES\t1000\n#define BH1770_PROX_DEF_THRES\t70\n#define BH1770_PROX_DEF_ABS_THRES   100\n#define BH1770_DEFAULT_PERSISTENCE  10\n#define BH1770_PROX_MAX_PERSISTENCE 50\n#define BH1770_LUX_GA_SCALE\t16384\n#define BH1770_LUX_CF_SCALE\t2048  \n#define BH1770_NEUTRAL_CF\tBH1770_LUX_CF_SCALE\n#define BH1770_LUX_CORR_SCALE\t4096\n\n#define PROX_ABOVE_THRESHOLD\t1\n#define PROX_BELOW_THRESHOLD\t0\n\n#define PROX_IGNORE_LUX_LIMIT\t500\n\nstruct bh1770_chip {\n\tstruct bh1770_platform_data\t*pdata;\n\tchar\t\t\t\tchipname[10];\n\tu8\t\t\t\trevision;\n\tstruct i2c_client\t\t*client;\n\tstruct regulator_bulk_data\tregs[2];\n\tstruct mutex\t\t\tmutex;  \n\twait_queue_head_t\t\twait;\n\n\tbool\t\t\tint_mode_prox;\n\tbool\t\t\tint_mode_lux;\n\tstruct delayed_work\tprox_work;\n\tu32\tlux_cf;  \n\tu32\tlux_ga;\n\tu32\tlux_calib;\n\tint\tlux_rate_index;\n\tu32\tlux_corr;\n\tu16\tlux_data_raw;\n\tu16\tlux_threshold_hi;\n\tu16\tlux_threshold_lo;\n\tu16\tlux_thres_hi_onchip;\n\tu16\tlux_thres_lo_onchip;\n\tbool\tlux_wait_result;\n\n\tint\tprox_enable_count;\n\tu16\tprox_coef;\n\tu16\tprox_const;\n\tint\tprox_rate;\n\tint\tprox_rate_threshold;\n\tu8\tprox_persistence;\n\tu8\tprox_persistence_counter;\n\tu8\tprox_data;\n\tu8\tprox_threshold;\n\tu8\tprox_threshold_hw;\n\tbool\tprox_force_update;\n\tu8\tprox_abs_thres;\n\tu8\tprox_led;\n};\n\nstatic const char reg_vcc[] = \"Vcc\";\nstatic const char reg_vleds[] = \"Vleds\";\n\n \nstatic const s16 prox_rates_hz[] = {100, 50, 33, 25, 14, 10, 5, 2};\nstatic const s16 prox_rates_ms[] = {10, 20, 30, 40, 70, 100, 200, 500};\n\n \nstatic const s16 lux_rates_hz[] = {10, 5, 2, 1, 0};\n\n \nstatic inline int bh1770_lux_interrupt_control(struct bh1770_chip *chip,\n\t\t\t\t\tint lux)\n{\n\tchip->int_mode_lux = lux;\n\t \n\treturn i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tBH1770_INTERRUPT,\n\t\t\t\t\t(lux << 1) | chip->int_mode_prox);\n}\n\nstatic inline int bh1770_prox_interrupt_control(struct bh1770_chip *chip,\n\t\t\t\t\tint ps)\n{\n\tchip->int_mode_prox = ps;\n\treturn i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tBH1770_INTERRUPT,\n\t\t\t\t\t(chip->int_mode_lux << 1) | (ps << 0));\n}\n\n \nstatic int bh1770_lux_rate(struct bh1770_chip *chip, int rate_index)\n{\n\t \n\tif (pm_runtime_suspended(&chip->client->dev))\n\t\treturn 0;\n\n\t \n\tif (chip->prox_enable_count)\n\t\trate_index = 0;\n\n\treturn i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tBH1770_ALS_MEAS_RATE,\n\t\t\t\t\trate_index);\n}\n\nstatic int bh1770_prox_rate(struct bh1770_chip *chip, int mode)\n{\n\tint rate;\n\n\trate = (mode == PROX_ABOVE_THRESHOLD) ?\n\t\tchip->prox_rate_threshold : chip->prox_rate;\n\n\treturn i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tBH1770_PS_MEAS_RATE,\n\t\t\t\t\trate);\n}\n\n \nstatic inline int bh1770_led_cfg(struct bh1770_chip *chip)\n{\n\t \n\treturn i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tBH1770_I_LED,\n\t\t\t\t\t(BH1770_LED1 << 6) |\n\t\t\t\t\t(BH1770_LED_5mA << 3) |\n\t\t\t\t\tchip->prox_led);\n}\n\n \nstatic inline u8 bh1770_psraw_to_adjusted(struct bh1770_chip *chip, u8 psraw)\n{\n\tu16 adjusted;\n\tadjusted = (u16)(((u32)(psraw + chip->prox_const) * chip->prox_coef) /\n\t\tBH1770_COEF_SCALER);\n\tif (adjusted > BH1770_PROX_RANGE)\n\t\tadjusted = BH1770_PROX_RANGE;\n\treturn adjusted;\n}\n\nstatic inline u8 bh1770_psadjusted_to_raw(struct bh1770_chip *chip, u8 ps)\n{\n\tu16 raw;\n\n\traw = (((u32)ps * BH1770_COEF_SCALER) / chip->prox_coef);\n\tif (raw > chip->prox_const)\n\t\traw = raw - chip->prox_const;\n\telse\n\t\traw = 0;\n\treturn raw;\n}\n\n \nstatic int bh1770_prox_set_threshold(struct bh1770_chip *chip)\n{\n\tu8 tmp = 0;\n\n\t \n\tif (pm_runtime_suspended(&chip->client->dev))\n\t\treturn 0;\n\n\ttmp = bh1770_psadjusted_to_raw(chip, chip->prox_threshold);\n\tchip->prox_threshold_hw = tmp;\n\n\treturn\ti2c_smbus_write_byte_data(chip->client, BH1770_PS_TH_LED1,\n\t\t\t\t\ttmp);\n}\n\nstatic inline u16 bh1770_lux_raw_to_adjusted(struct bh1770_chip *chip, u16 raw)\n{\n\tu32 lux;\n\tlux = ((u32)raw * chip->lux_corr) / BH1770_LUX_CORR_SCALE;\n\treturn min(lux, (u32)BH1770_LUX_RANGE);\n}\n\nstatic inline u16 bh1770_lux_adjusted_to_raw(struct bh1770_chip *chip,\n\t\t\t\t\tu16 adjusted)\n{\n\treturn (u32)adjusted * BH1770_LUX_CORR_SCALE / chip->lux_corr;\n}\n\n \nstatic int bh1770_lux_update_thresholds(struct bh1770_chip *chip,\n\t\t\t\t\tu16 threshold_hi, u16 threshold_lo)\n{\n\tu8 data[4];\n\tint ret;\n\n\t \n\tif (pm_runtime_suspended(&chip->client->dev))\n\t\treturn 0;\n\n\t \n\tif (threshold_hi != BH1770_LUX_RANGE && threshold_hi != 0)\n\t\tthreshold_hi = bh1770_lux_adjusted_to_raw(chip, threshold_hi);\n\n\tif (threshold_lo != BH1770_LUX_RANGE && threshold_lo != 0)\n\t\tthreshold_lo = bh1770_lux_adjusted_to_raw(chip, threshold_lo);\n\n\tif (chip->lux_thres_hi_onchip == threshold_hi &&\n\t    chip->lux_thres_lo_onchip == threshold_lo)\n\t\treturn 0;\n\n\tchip->lux_thres_hi_onchip = threshold_hi;\n\tchip->lux_thres_lo_onchip = threshold_lo;\n\n\tdata[0] = threshold_hi;\n\tdata[1] = threshold_hi >> 8;\n\tdata[2] = threshold_lo;\n\tdata[3] = threshold_lo >> 8;\n\n\tret = i2c_smbus_write_i2c_block_data(chip->client,\n\t\t\t\t\tBH1770_ALS_TH_UP_0,\n\t\t\t\t\tARRAY_SIZE(data),\n\t\t\t\t\tdata);\n\treturn ret;\n}\n\nstatic int bh1770_lux_get_result(struct bh1770_chip *chip)\n{\n\tu16 data;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(chip->client, BH1770_ALS_DATA_0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata = ret & 0xff;\n\tret = i2c_smbus_read_byte_data(chip->client, BH1770_ALS_DATA_1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchip->lux_data_raw = data | ((ret & 0xff) << 8);\n\n\treturn 0;\n}\n\n \nstatic u32 bh1770_get_corr_value(struct bh1770_chip *chip)\n{\n\tu32 tmp;\n\t \n\ttmp = (BH1770_LUX_CORR_SCALE * chip->lux_ga) / BH1770_LUX_GA_SCALE;\n\t \n\ttmp = (tmp * chip->lux_cf) / BH1770_LUX_CF_SCALE;\n\t \n\ttmp = (tmp * chip->lux_calib) / BH1770_CALIB_SCALER;\n\treturn tmp;\n}\n\nstatic int bh1770_lux_read_result(struct bh1770_chip *chip)\n{\n\tbh1770_lux_get_result(chip);\n\treturn bh1770_lux_raw_to_adjusted(chip, chip->lux_data_raw);\n}\n\n \nstatic int bh1770_chip_on(struct bh1770_chip *chip)\n{\n\tint ret = regulator_bulk_enable(ARRAY_SIZE(chip->regs),\n\t\t\t\t\tchip->regs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(BH1770_STARTUP_DELAY, BH1770_STARTUP_DELAY * 2);\n\n\t \n\ti2c_smbus_write_byte_data(chip->client, BH1770_ALS_CONTROL,\n\t\t\t\tBH1770_SWRESET);\n\tusleep_range(BH1770_RESET_TIME, BH1770_RESET_TIME * 2);\n\n\t \n\tchip->lux_data_raw = 0;\n\tchip->prox_data = 0;\n\tret = i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tBH1770_ALS_CONTROL, BH1770_STANDALONE);\n\n\t \n\tchip->lux_thres_hi_onchip = BH1770_LUX_RANGE;\n\tchip->lux_thres_lo_onchip = 0;\n\n\treturn ret;\n}\n\nstatic void bh1770_chip_off(struct bh1770_chip *chip)\n{\n\ti2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tBH1770_INTERRUPT, BH1770_DISABLE);\n\ti2c_smbus_write_byte_data(chip->client,\n\t\t\t\tBH1770_ALS_CONTROL, BH1770_STANDBY);\n\ti2c_smbus_write_byte_data(chip->client,\n\t\t\t\tBH1770_PS_CONTROL, BH1770_STANDBY);\n\tregulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);\n}\n\n \nstatic int bh1770_prox_mode_control(struct bh1770_chip *chip)\n{\n\tif (chip->prox_enable_count) {\n\t\tchip->prox_force_update = true;  \n\n\t\tbh1770_lux_rate(chip, chip->lux_rate_index);\n\t\tbh1770_prox_set_threshold(chip);\n\t\tbh1770_led_cfg(chip);\n\t\tbh1770_prox_rate(chip, PROX_BELOW_THRESHOLD);\n\t\tbh1770_prox_interrupt_control(chip, BH1770_ENABLE);\n\t\ti2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tBH1770_PS_CONTROL, BH1770_STANDALONE);\n\t} else {\n\t\tchip->prox_data = 0;\n\t\tbh1770_lux_rate(chip, chip->lux_rate_index);\n\t\tbh1770_prox_interrupt_control(chip, BH1770_DISABLE);\n\t\ti2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tBH1770_PS_CONTROL, BH1770_STANDBY);\n\t}\n\treturn 0;\n}\n\n \nstatic int bh1770_prox_read_result(struct bh1770_chip *chip)\n{\n\tint ret;\n\tbool above;\n\tu8 mode;\n\n\tret = i2c_smbus_read_byte_data(chip->client, BH1770_PS_DATA_LED1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > chip->prox_threshold_hw)\n\t\tabove = true;\n\telse\n\t\tabove = false;\n\n\t \n\tif (chip->lux_data_raw > PROX_IGNORE_LUX_LIMIT)\n\t\tret = 0;\n\n\tchip->prox_data = bh1770_psraw_to_adjusted(chip, ret);\n\n\t \n\tif (chip->prox_data >= chip->prox_abs_thres ||\n\t    chip->prox_force_update)\n\t\tchip->prox_persistence_counter = chip->prox_persistence;\n\n\tchip->prox_force_update = false;\n\n\t \n\tif (likely(above)) {\n\t\tif (chip->prox_persistence_counter < chip->prox_persistence) {\n\t\t\tchip->prox_persistence_counter++;\n\t\t\tret = -ENODATA;\n\t\t} else {\n\t\t\tmode = PROX_ABOVE_THRESHOLD;\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tchip->prox_persistence_counter = 0;\n\t\tmode = PROX_BELOW_THRESHOLD;\n\t\tchip->prox_data = 0;\n\t\tret = 0;\n\t}\n\n\t \n\tif (ret == 0) {\n\t\tbh1770_prox_rate(chip, mode);\n\t\tsysfs_notify(&chip->client->dev.kobj, NULL, \"prox0_raw\");\n\t}\nout:\n\treturn ret;\n}\n\nstatic int bh1770_detect(struct bh1770_chip *chip)\n{\n\tstruct i2c_client *client = chip->client;\n\ts32 ret;\n\tu8 manu, part;\n\n\tret = i2c_smbus_read_byte_data(client, BH1770_MANUFACT_ID);\n\tif (ret < 0)\n\t\tgoto error;\n\tmanu = (u8)ret;\n\n\tret = i2c_smbus_read_byte_data(client, BH1770_PART_ID);\n\tif (ret < 0)\n\t\tgoto error;\n\tpart = (u8)ret;\n\n\tchip->revision = (part & BH1770_REV_MASK) >> BH1770_REV_SHIFT;\n\tchip->prox_coef = BH1770_COEF_SCALER;\n\tchip->prox_const = 0;\n\tchip->lux_cf = BH1770_NEUTRAL_CF;\n\n\tif ((manu == BH1770_MANUFACT_ROHM) &&\n\t    ((part & BH1770_PART_MASK) == BH1770_PART)) {\n\t\tsnprintf(chip->chipname, sizeof(chip->chipname), \"BH1770GLC\");\n\t\treturn 0;\n\t}\n\n\tif ((manu == BH1770_MANUFACT_OSRAM) &&\n\t    ((part & BH1770_PART_MASK) == BH1770_PART)) {\n\t\tsnprintf(chip->chipname, sizeof(chip->chipname), \"SFH7770\");\n\t\t \n\t\tchip->prox_coef = 819;  \n\t\tchip->prox_const = 40;\n\t\treturn 0;\n\t}\n\n\tret = -ENODEV;\nerror:\n\tdev_dbg(&client->dev, \"BH1770 or SFH7770 not found\\n\");\n\n\treturn ret;\n}\n\n \n\nstatic void bh1770_prox_work(struct work_struct *work)\n{\n\tstruct bh1770_chip *chip =\n\t\tcontainer_of(work, struct bh1770_chip, prox_work.work);\n\n\tmutex_lock(&chip->mutex);\n\tbh1770_prox_read_result(chip);\n\tmutex_unlock(&chip->mutex);\n}\n\n \nstatic irqreturn_t bh1770_irq(int irq, void *data)\n{\n\tstruct bh1770_chip *chip = data;\n\tint status;\n\tint rate = 0;\n\n\tmutex_lock(&chip->mutex);\n\tstatus = i2c_smbus_read_byte_data(chip->client, BH1770_ALS_PS_STATUS);\n\n\t \n\ti2c_smbus_read_byte_data(chip->client, BH1770_INTERRUPT);\n\n\t \n\tif (status & BH1770_INT_ALS_DATA) {\n\t\tbh1770_lux_get_result(chip);\n\t\tif (unlikely(chip->lux_wait_result)) {\n\t\t\tchip->lux_wait_result = false;\n\t\t\twake_up(&chip->wait);\n\t\t\tbh1770_lux_update_thresholds(chip,\n\t\t\t\t\t\tchip->lux_threshold_hi,\n\t\t\t\t\t\tchip->lux_threshold_lo);\n\t\t}\n\t}\n\n\t \n\ti2c_smbus_write_byte_data(chip->client, BH1770_INTERRUPT,\n\t\t\t\t  (0 << 1) | (0 << 0));\n\n\tif ((status & BH1770_INT_ALS_INT))\n\t\tsysfs_notify(&chip->client->dev.kobj, NULL, \"lux0_input\");\n\n\tif (chip->int_mode_prox && (status & BH1770_INT_LEDS_INT)) {\n\t\trate = prox_rates_ms[chip->prox_rate_threshold];\n\t\tbh1770_prox_read_result(chip);\n\t}\n\n\t \n\ti2c_smbus_write_byte_data(chip->client, BH1770_INTERRUPT,\n\t\t\t\t  (chip->int_mode_lux << 1) |\n\t\t\t\t  (chip->int_mode_prox << 0));\n\tmutex_unlock(&chip->mutex);\n\n\t \n\tif (rate) {\n\t\t \n\t\tcancel_delayed_work_sync(&chip->prox_work);\n\t\tschedule_delayed_work(&chip->prox_work,\n\t\t\t\tmsecs_to_jiffies(rate + 50));\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t bh1770_power_state_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\tunsigned long value;\n\tssize_t ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&chip->mutex);\n\tif (value) {\n\t\tpm_runtime_get_sync(dev);\n\n\t\tret = bh1770_lux_rate(chip, chip->lux_rate_index);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put(dev);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tret = bh1770_lux_interrupt_control(chip, BH1770_ENABLE);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put(dev);\n\t\t\tgoto leave;\n\t\t}\n\n\t\t \n\t\tbh1770_lux_update_thresholds(chip, BH1770_LUX_DEF_THRES,\n\t\t\t\t\tBH1770_LUX_DEF_THRES);\n\t\t \n\t\tchip->lux_wait_result = true;\n\t\tbh1770_prox_mode_control(chip);\n\t} else if (!pm_runtime_suspended(dev)) {\n\t\tpm_runtime_put(dev);\n\t}\n\tret = count;\nleave:\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic ssize_t bh1770_power_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !pm_runtime_suspended(dev));\n}\n\nstatic ssize_t bh1770_lux_result_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\tssize_t ret;\n\tlong timeout;\n\n\tif (pm_runtime_suspended(dev))\n\t\treturn -EIO;  \n\n\ttimeout = wait_event_interruptible_timeout(chip->wait,\n\t\t\t\t\t!chip->lux_wait_result,\n\t\t\t\t\tmsecs_to_jiffies(BH1770_TIMEOUT));\n\tif (!timeout)\n\t\treturn -EIO;\n\n\tmutex_lock(&chip->mutex);\n\tret = sprintf(buf, \"%d\\n\", bh1770_lux_read_result(chip));\n\tmutex_unlock(&chip->mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t bh1770_lux_range_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", BH1770_LUX_RANGE);\n}\n\nstatic ssize_t bh1770_prox_enable_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&chip->mutex);\n\t \n\tif (!chip->prox_enable_count)\n\t\tchip->prox_data = 0;\n\n\tif (value)\n\t\tchip->prox_enable_count++;\n\telse if (chip->prox_enable_count > 0)\n\t\tchip->prox_enable_count--;\n\telse\n\t\tgoto leave;\n\n\t \n\tif (!pm_runtime_suspended(dev))\n\t\tbh1770_prox_mode_control(chip);\nleave:\n\tmutex_unlock(&chip->mutex);\n\treturn count;\n}\n\nstatic ssize_t bh1770_prox_enable_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\tssize_t len;\n\n\tmutex_lock(&chip->mutex);\n\tlen = sprintf(buf, \"%d\\n\", chip->prox_enable_count);\n\tmutex_unlock(&chip->mutex);\n\treturn len;\n}\n\nstatic ssize_t bh1770_prox_result_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\tssize_t ret;\n\n\tmutex_lock(&chip->mutex);\n\tif (chip->prox_enable_count && !pm_runtime_suspended(dev))\n\t\tret = sprintf(buf, \"%d\\n\", chip->prox_data);\n\telse\n\t\tret = -EIO;\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic ssize_t bh1770_prox_range_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", BH1770_PROX_RANGE);\n}\n\nstatic ssize_t bh1770_get_prox_rate_avail(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint i;\n\tint pos = 0;\n\tfor (i = 0; i < ARRAY_SIZE(prox_rates_hz); i++)\n\t\tpos += sprintf(buf + pos, \"%d \", prox_rates_hz[i]);\n\tsprintf(buf + pos - 1, \"\\n\");\n\treturn pos;\n}\n\nstatic ssize_t bh1770_get_prox_rate_above(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", prox_rates_hz[chip->prox_rate_threshold]);\n}\n\nstatic ssize_t bh1770_get_prox_rate_below(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", prox_rates_hz[chip->prox_rate]);\n}\n\nstatic int bh1770_prox_rate_validate(int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(prox_rates_hz) - 1; i++)\n\t\tif (rate >= prox_rates_hz[i])\n\t\t\tbreak;\n\treturn i;\n}\n\nstatic ssize_t bh1770_set_prox_rate_above(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&chip->mutex);\n\tchip->prox_rate_threshold = bh1770_prox_rate_validate(value);\n\tmutex_unlock(&chip->mutex);\n\treturn count;\n}\n\nstatic ssize_t bh1770_set_prox_rate_below(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&chip->mutex);\n\tchip->prox_rate = bh1770_prox_rate_validate(value);\n\tmutex_unlock(&chip->mutex);\n\treturn count;\n}\n\nstatic ssize_t bh1770_get_prox_thres(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", chip->prox_threshold);\n}\n\nstatic ssize_t bh1770_set_prox_thres(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value > BH1770_PROX_RANGE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->mutex);\n\tchip->prox_threshold = value;\n\tret = bh1770_prox_set_threshold(chip);\n\tmutex_unlock(&chip->mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic ssize_t bh1770_prox_persistence_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", chip->prox_persistence);\n}\n\nstatic ssize_t bh1770_prox_persistence_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct bh1770_chip *chip = dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value > BH1770_PROX_MAX_PERSISTENCE)\n\t\treturn -EINVAL;\n\n\tchip->prox_persistence = value;\n\n\treturn len;\n}\n\nstatic ssize_t bh1770_prox_abs_thres_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%u\\n\", chip->prox_abs_thres);\n}\n\nstatic ssize_t bh1770_prox_abs_thres_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct bh1770_chip *chip = dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value > BH1770_PROX_RANGE)\n\t\treturn -EINVAL;\n\n\tchip->prox_abs_thres = value;\n\n\treturn len;\n}\n\nstatic ssize_t bh1770_chip_id_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%s rev %d\\n\", chip->chipname, chip->revision);\n}\n\nstatic ssize_t bh1770_lux_calib_default_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", BH1770_CALIB_SCALER);\n}\n\nstatic ssize_t bh1770_lux_calib_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip = dev_get_drvdata(dev);\n\tssize_t len;\n\n\tmutex_lock(&chip->mutex);\n\tlen = sprintf(buf, \"%u\\n\", chip->lux_calib);\n\tmutex_unlock(&chip->mutex);\n\treturn len;\n}\n\nstatic ssize_t bh1770_lux_calib_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct bh1770_chip *chip = dev_get_drvdata(dev);\n\tunsigned long value;\n\tu32 old_calib;\n\tu32 new_corr;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&chip->mutex);\n\told_calib = chip->lux_calib;\n\tchip->lux_calib = value;\n\tnew_corr = bh1770_get_corr_value(chip);\n\tif (new_corr == 0) {\n\t\tchip->lux_calib = old_calib;\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn -EINVAL;\n\t}\n\tchip->lux_corr = new_corr;\n\t \n\tbh1770_lux_update_thresholds(chip, chip->lux_threshold_hi,\n\t\t\t\tchip->lux_threshold_lo);\n\n\tmutex_unlock(&chip->mutex);\n\n\treturn len;\n}\n\nstatic ssize_t bh1770_get_lux_rate_avail(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint i;\n\tint pos = 0;\n\tfor (i = 0; i < ARRAY_SIZE(lux_rates_hz); i++)\n\t\tpos += sprintf(buf + pos, \"%d \", lux_rates_hz[i]);\n\tsprintf(buf + pos - 1, \"\\n\");\n\treturn pos;\n}\n\nstatic ssize_t bh1770_get_lux_rate(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", lux_rates_hz[chip->lux_rate_index]);\n}\n\nstatic ssize_t bh1770_set_lux_rate(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\tunsigned long rate_hz;\n\tint ret, i;\n\n\tret = kstrtoul(buf, 0, &rate_hz);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(lux_rates_hz) - 1; i++)\n\t\tif (rate_hz >= lux_rates_hz[i])\n\t\t\tbreak;\n\n\tmutex_lock(&chip->mutex);\n\tchip->lux_rate_index = i;\n\tret = bh1770_lux_rate(chip, i);\n\tmutex_unlock(&chip->mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t bh1770_get_lux_thresh_above(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", chip->lux_threshold_hi);\n}\n\nstatic ssize_t bh1770_get_lux_thresh_below(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", chip->lux_threshold_lo);\n}\n\nstatic ssize_t bh1770_set_lux_thresh(struct bh1770_chip *chip, u16 *target,\n\t\t\t\tconst char *buf)\n{\n\tunsigned long thresh;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &thresh);\n\tif (ret)\n\t\treturn ret;\n\n\tif (thresh > BH1770_LUX_RANGE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->mutex);\n\t*target = thresh;\n\t \n\tif (!chip->lux_wait_result)\n\t\tret = bh1770_lux_update_thresholds(chip,\n\t\t\t\t\t\tchip->lux_threshold_hi,\n\t\t\t\t\t\tchip->lux_threshold_lo);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n\n}\n\nstatic ssize_t bh1770_set_lux_thresh_above(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\tint ret = bh1770_set_lux_thresh(chip, &chip->lux_threshold_hi, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}\n\nstatic ssize_t bh1770_set_lux_thresh_below(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct bh1770_chip *chip =  dev_get_drvdata(dev);\n\tint ret = bh1770_set_lux_thresh(chip, &chip->lux_threshold_lo, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}\n\nstatic DEVICE_ATTR(prox0_raw_en, S_IRUGO | S_IWUSR, bh1770_prox_enable_show,\n\t\t\t\t\t\tbh1770_prox_enable_store);\nstatic DEVICE_ATTR(prox0_thresh_above1_value, S_IRUGO | S_IWUSR,\n\t\t\t\t\t\tbh1770_prox_abs_thres_show,\n\t\t\t\t\t\tbh1770_prox_abs_thres_store);\nstatic DEVICE_ATTR(prox0_thresh_above0_value, S_IRUGO | S_IWUSR,\n\t\t\t\t\t\tbh1770_get_prox_thres,\n\t\t\t\t\t\tbh1770_set_prox_thres);\nstatic DEVICE_ATTR(prox0_raw, S_IRUGO, bh1770_prox_result_show, NULL);\nstatic DEVICE_ATTR(prox0_sensor_range, S_IRUGO, bh1770_prox_range_show, NULL);\nstatic DEVICE_ATTR(prox0_thresh_above_count, S_IRUGO | S_IWUSR,\n\t\t\t\t\t\tbh1770_prox_persistence_show,\n\t\t\t\t\t\tbh1770_prox_persistence_store);\nstatic DEVICE_ATTR(prox0_rate_above, S_IRUGO | S_IWUSR,\n\t\t\t\t\t\tbh1770_get_prox_rate_above,\n\t\t\t\t\t\tbh1770_set_prox_rate_above);\nstatic DEVICE_ATTR(prox0_rate_below, S_IRUGO | S_IWUSR,\n\t\t\t\t\t\tbh1770_get_prox_rate_below,\n\t\t\t\t\t\tbh1770_set_prox_rate_below);\nstatic DEVICE_ATTR(prox0_rate_avail, S_IRUGO, bh1770_get_prox_rate_avail, NULL);\n\nstatic DEVICE_ATTR(lux0_calibscale, S_IRUGO | S_IWUSR, bh1770_lux_calib_show,\n\t\t\t\t\t\tbh1770_lux_calib_store);\nstatic DEVICE_ATTR(lux0_calibscale_default, S_IRUGO,\n\t\t\t\t\t\tbh1770_lux_calib_default_show,\n\t\t\t\t\t\tNULL);\nstatic DEVICE_ATTR(lux0_input, S_IRUGO, bh1770_lux_result_show, NULL);\nstatic DEVICE_ATTR(lux0_sensor_range, S_IRUGO, bh1770_lux_range_show, NULL);\nstatic DEVICE_ATTR(lux0_rate, S_IRUGO | S_IWUSR, bh1770_get_lux_rate,\n\t\t\t\t\t\tbh1770_set_lux_rate);\nstatic DEVICE_ATTR(lux0_rate_avail, S_IRUGO, bh1770_get_lux_rate_avail, NULL);\nstatic DEVICE_ATTR(lux0_thresh_above_value, S_IRUGO | S_IWUSR,\n\t\t\t\t\t\tbh1770_get_lux_thresh_above,\n\t\t\t\t\t\tbh1770_set_lux_thresh_above);\nstatic DEVICE_ATTR(lux0_thresh_below_value, S_IRUGO | S_IWUSR,\n\t\t\t\t\t\tbh1770_get_lux_thresh_below,\n\t\t\t\t\t\tbh1770_set_lux_thresh_below);\nstatic DEVICE_ATTR(chip_id, S_IRUGO, bh1770_chip_id_show, NULL);\nstatic DEVICE_ATTR(power_state, S_IRUGO | S_IWUSR, bh1770_power_state_show,\n\t\t\t\t\t\t bh1770_power_state_store);\n\n\nstatic struct attribute *sysfs_attrs[] = {\n\t&dev_attr_lux0_calibscale.attr,\n\t&dev_attr_lux0_calibscale_default.attr,\n\t&dev_attr_lux0_input.attr,\n\t&dev_attr_lux0_sensor_range.attr,\n\t&dev_attr_lux0_rate.attr,\n\t&dev_attr_lux0_rate_avail.attr,\n\t&dev_attr_lux0_thresh_above_value.attr,\n\t&dev_attr_lux0_thresh_below_value.attr,\n\t&dev_attr_prox0_raw.attr,\n\t&dev_attr_prox0_sensor_range.attr,\n\t&dev_attr_prox0_raw_en.attr,\n\t&dev_attr_prox0_thresh_above_count.attr,\n\t&dev_attr_prox0_rate_above.attr,\n\t&dev_attr_prox0_rate_below.attr,\n\t&dev_attr_prox0_rate_avail.attr,\n\t&dev_attr_prox0_thresh_above0_value.attr,\n\t&dev_attr_prox0_thresh_above1_value.attr,\n\t&dev_attr_chip_id.attr,\n\t&dev_attr_power_state.attr,\n\tNULL\n};\n\nstatic const struct attribute_group bh1770_attribute_group = {\n\t.attrs = sysfs_attrs\n};\n\nstatic int bh1770_probe(struct i2c_client *client)\n{\n\tstruct bh1770_chip *chip;\n\tint err;\n\n\tchip = devm_kzalloc(&client->dev, sizeof *chip, GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, chip);\n\tchip->client  = client;\n\n\tmutex_init(&chip->mutex);\n\tinit_waitqueue_head(&chip->wait);\n\tINIT_DELAYED_WORK(&chip->prox_work, bh1770_prox_work);\n\n\tif (client->dev.platform_data == NULL) {\n\t\tdev_err(&client->dev, \"platform data is mandatory\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip->pdata\t\t= client->dev.platform_data;\n\tchip->lux_calib\t\t= BH1770_LUX_NEUTRAL_CALIB_VALUE;\n\tchip->lux_rate_index\t= BH1770_LUX_DEFAULT_RATE;\n\tchip->lux_threshold_lo\t= BH1770_LUX_DEF_THRES;\n\tchip->lux_threshold_hi\t= BH1770_LUX_DEF_THRES;\n\n\tif (chip->pdata->glass_attenuation == 0)\n\t\tchip->lux_ga = BH1770_NEUTRAL_GA;\n\telse\n\t\tchip->lux_ga = chip->pdata->glass_attenuation;\n\n\tchip->prox_threshold\t= BH1770_PROX_DEF_THRES;\n\tchip->prox_led\t\t= chip->pdata->led_def_curr;\n\tchip->prox_abs_thres\t= BH1770_PROX_DEF_ABS_THRES;\n\tchip->prox_persistence\t= BH1770_DEFAULT_PERSISTENCE;\n\tchip->prox_rate_threshold = BH1770_PROX_DEF_RATE_THRESH;\n\tchip->prox_rate\t\t= BH1770_PROX_DEFAULT_RATE;\n\tchip->prox_data\t\t= 0;\n\n\tchip->regs[0].supply = reg_vcc;\n\tchip->regs[1].supply = reg_vleds;\n\n\terr = devm_regulator_bulk_get(&client->dev,\n\t\t\t\t      ARRAY_SIZE(chip->regs), chip->regs);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Cannot get regulators\\n\");\n\t\treturn err;\n\t}\n\n\terr = regulator_bulk_enable(ARRAY_SIZE(chip->regs),\n\t\t\t\tchip->regs);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Cannot enable regulators\\n\");\n\t\treturn err;\n\t}\n\n\tusleep_range(BH1770_STARTUP_DELAY, BH1770_STARTUP_DELAY * 2);\n\terr = bh1770_detect(chip);\n\tif (err < 0)\n\t\tgoto fail0;\n\n\t \n\tbh1770_chip_on(chip);\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\n\tchip->lux_corr = bh1770_get_corr_value(chip);\n\tif (chip->lux_corr == 0) {\n\t\tdev_err(&client->dev, \"Improper correction values\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail0;\n\t}\n\n\tif (chip->pdata->setup_resources) {\n\t\terr = chip->pdata->setup_resources();\n\t\tif (err) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail0;\n\t\t}\n\t}\n\n\terr = sysfs_create_group(&chip->client->dev.kobj,\n\t\t\t\t&bh1770_attribute_group);\n\tif (err < 0) {\n\t\tdev_err(&chip->client->dev, \"Sysfs registration failed\\n\");\n\t\tgoto fail1;\n\t}\n\n\t \n\terr = request_threaded_irq(client->irq, NULL,\n\t\t\t\tbh1770_irq,\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT |\n\t\t\t\tIRQF_TRIGGER_LOW,\n\t\t\t\t\"bh1770\", chip);\n\tif (err) {\n\t\tdev_err(&client->dev, \"could not get IRQ %d\\n\",\n\t\t\tclient->irq);\n\t\tgoto fail2;\n\t}\n\tregulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);\n\treturn err;\nfail2:\n\tsysfs_remove_group(&chip->client->dev.kobj,\n\t\t\t&bh1770_attribute_group);\nfail1:\n\tif (chip->pdata->release_resources)\n\t\tchip->pdata->release_resources();\nfail0:\n\tregulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);\n\treturn err;\n}\n\nstatic void bh1770_remove(struct i2c_client *client)\n{\n\tstruct bh1770_chip *chip = i2c_get_clientdata(client);\n\n\tfree_irq(client->irq, chip);\n\n\tsysfs_remove_group(&chip->client->dev.kobj,\n\t\t\t&bh1770_attribute_group);\n\n\tif (chip->pdata->release_resources)\n\t\tchip->pdata->release_resources();\n\n\tcancel_delayed_work_sync(&chip->prox_work);\n\n\tif (!pm_runtime_suspended(&client->dev))\n\t\tbh1770_chip_off(chip);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bh1770_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bh1770_chip *chip = i2c_get_clientdata(client);\n\n\tbh1770_chip_off(chip);\n\n\treturn 0;\n}\n\nstatic int bh1770_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bh1770_chip *chip = i2c_get_clientdata(client);\n\tint ret = 0;\n\n\tbh1770_chip_on(chip);\n\n\tif (!pm_runtime_suspended(dev)) {\n\t\t \n\t\tret = bh1770_lux_rate(chip, chip->lux_rate_index);\n\t\tret |= bh1770_lux_interrupt_control(chip, BH1770_ENABLE);\n\n\t\t \n\t\tbh1770_lux_update_thresholds(chip, BH1770_LUX_DEF_THRES,\n\t\t\t\t\tBH1770_LUX_DEF_THRES);\n\t\t \n\t\tchip->lux_wait_result = true;\n\t\tbh1770_prox_mode_control(chip);\n\t}\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int bh1770_runtime_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bh1770_chip *chip = i2c_get_clientdata(client);\n\n\tbh1770_chip_off(chip);\n\n\treturn 0;\n}\n\nstatic int bh1770_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bh1770_chip *chip = i2c_get_clientdata(client);\n\n\tbh1770_chip_on(chip);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct i2c_device_id bh1770_id[] = {\n\t{\"bh1770glc\", 0 },\n\t{\"sfh7770\", 0 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, bh1770_id);\n\nstatic const struct dev_pm_ops bh1770_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(bh1770_suspend, bh1770_resume)\n\tSET_RUNTIME_PM_OPS(bh1770_runtime_suspend, bh1770_runtime_resume, NULL)\n};\n\nstatic struct i2c_driver bh1770_driver = {\n\t.driver\t  = {\n\t\t.name\t= \"bh1770glc\",\n\t\t.pm\t= &bh1770_pm_ops,\n\t},\n\t.probe    = bh1770_probe,\n\t.remove\t  = bh1770_remove,\n\t.id_table = bh1770_id,\n};\n\nmodule_i2c_driver(bh1770_driver);\n\nMODULE_DESCRIPTION(\"BH1770GLC / SFH7770 combined ALS and proximity sensor\");\nMODULE_AUTHOR(\"Samu Onkalo, Nokia Corporation\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}