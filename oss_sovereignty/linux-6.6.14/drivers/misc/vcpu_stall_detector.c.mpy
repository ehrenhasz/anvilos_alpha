{
  "module_name": "vcpu_stall_detector.c",
  "hash_id": "c1fccf073fcd50710d22451a7ba4f86751fefc2e7ddf1f730a1698add2c8517f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/vcpu_stall_detector.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/cpu.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/of.h>\n#include <linux/param.h>\n#include <linux/percpu.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define VCPU_STALL_REG_STATUS\t\t(0x00)\n#define VCPU_STALL_REG_LOAD_CNT\t\t(0x04)\n#define VCPU_STALL_REG_CURRENT_CNT\t(0x08)\n#define VCPU_STALL_REG_CLOCK_FREQ_HZ\t(0x0C)\n#define VCPU_STALL_REG_LEN\t\t(0x10)\n\n#define VCPU_STALL_DEFAULT_CLOCK_HZ\t(10)\n#define VCPU_STALL_MAX_CLOCK_HZ\t\t(100)\n#define VCPU_STALL_DEFAULT_TIMEOUT_SEC\t(8)\n#define VCPU_STALL_MAX_TIMEOUT_SEC\t(600)\n\nstruct vcpu_stall_detect_config {\n\tu32 clock_freq_hz;\n\tu32 stall_timeout_sec;\n\n\tvoid __iomem *membase;\n\tstruct platform_device *dev;\n\tenum cpuhp_state hp_online;\n};\n\nstruct vcpu_stall_priv {\n\tstruct hrtimer vcpu_hrtimer;\n\tbool is_initialized;\n};\n\n \nstatic struct vcpu_stall_detect_config vcpu_stall_config;\n\n#define vcpu_stall_reg_write(vcpu, reg, value)\t\t\t\t\\\n\twritel_relaxed((value),\t\t\t\t\t\t\\\n\t\t       (void __iomem *)(vcpu_stall_config.membase +\t\\\n\t\t       (vcpu) * VCPU_STALL_REG_LEN + (reg)))\n\n\nstatic struct vcpu_stall_priv __percpu *vcpu_stall_detectors;\n\nstatic enum hrtimer_restart\nvcpu_stall_detect_timer_fn(struct hrtimer *hrtimer)\n{\n\tu32 ticks, ping_timeout_ms;\n\n\t \n\tticks = vcpu_stall_config.clock_freq_hz *\n\t\tvcpu_stall_config.stall_timeout_sec;\n\tvcpu_stall_reg_write(smp_processor_id(),\n\t\t\t     VCPU_STALL_REG_LOAD_CNT, ticks);\n\n\tping_timeout_ms = vcpu_stall_config.stall_timeout_sec *\n\t\t\t  MSEC_PER_SEC / 2;\n\thrtimer_forward_now(hrtimer,\n\t\t\t    ms_to_ktime(ping_timeout_ms));\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic int start_stall_detector_cpu(unsigned int cpu)\n{\n\tu32 ticks, ping_timeout_ms;\n\tstruct vcpu_stall_priv *vcpu_stall_detector =\n\t\tthis_cpu_ptr(vcpu_stall_detectors);\n\tstruct hrtimer *vcpu_hrtimer = &vcpu_stall_detector->vcpu_hrtimer;\n\n\tvcpu_stall_reg_write(cpu, VCPU_STALL_REG_CLOCK_FREQ_HZ,\n\t\t\t     vcpu_stall_config.clock_freq_hz);\n\n\t \n\tticks = vcpu_stall_config.clock_freq_hz *\n\t\tvcpu_stall_config.stall_timeout_sec;\n\tvcpu_stall_reg_write(cpu, VCPU_STALL_REG_LOAD_CNT, ticks);\n\n\t \n\tvcpu_stall_reg_write(cpu, VCPU_STALL_REG_STATUS, 1);\n\n\t \n\tping_timeout_ms = vcpu_stall_config.stall_timeout_sec *\n\t\t\t  MSEC_PER_SEC / 2;\n\n\thrtimer_init(vcpu_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tvcpu_hrtimer->function = vcpu_stall_detect_timer_fn;\n\tvcpu_stall_detector->is_initialized = true;\n\n\thrtimer_start(vcpu_hrtimer, ms_to_ktime(ping_timeout_ms),\n\t\t      HRTIMER_MODE_REL_PINNED);\n\n\treturn 0;\n}\n\nstatic int stop_stall_detector_cpu(unsigned int cpu)\n{\n\tstruct vcpu_stall_priv *vcpu_stall_detector =\n\t\tper_cpu_ptr(vcpu_stall_detectors, cpu);\n\n\tif (!vcpu_stall_detector->is_initialized)\n\t\treturn 0;\n\n\t \n\thrtimer_cancel(&vcpu_stall_detector->vcpu_hrtimer);\n\tvcpu_stall_reg_write(cpu, VCPU_STALL_REG_STATUS, 0);\n\tvcpu_stall_detector->is_initialized = false;\n\n\treturn 0;\n}\n\nstatic int vcpu_stall_detect_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct resource *r;\n\tvoid __iomem *membase;\n\tu32 clock_freq_hz = VCPU_STALL_DEFAULT_CLOCK_HZ;\n\tu32 stall_timeout_sec = VCPU_STALL_DEFAULT_TIMEOUT_SEC;\n\tstruct device_node *np = pdev->dev.of_node;\n\n\tvcpu_stall_detectors = devm_alloc_percpu(&pdev->dev,\n\t\t\t\t\t\t typeof(struct vcpu_stall_priv));\n\tif (!vcpu_stall_detectors)\n\t\treturn -ENOMEM;\n\n\tmembase = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(membase)) {\n\t\tdev_err(&pdev->dev, \"Failed to get memory resource\\n\");\n\t\treturn PTR_ERR(membase);\n\t}\n\n\tif (!of_property_read_u32(np, \"clock-frequency\", &clock_freq_hz)) {\n\t\tif (!(clock_freq_hz > 0 &&\n\t\t      clock_freq_hz < VCPU_STALL_MAX_CLOCK_HZ)) {\n\t\t\tdev_warn(&pdev->dev, \"clk out of range\\n\");\n\t\t\tclock_freq_hz = VCPU_STALL_DEFAULT_CLOCK_HZ;\n\t\t}\n\t}\n\n\tif (!of_property_read_u32(np, \"timeout-sec\", &stall_timeout_sec)) {\n\t\tif (!(stall_timeout_sec > 0 &&\n\t\t      stall_timeout_sec < VCPU_STALL_MAX_TIMEOUT_SEC)) {\n\t\t\tdev_warn(&pdev->dev, \"stall timeout out of range\\n\");\n\t\t\tstall_timeout_sec = VCPU_STALL_DEFAULT_TIMEOUT_SEC;\n\t\t}\n\t}\n\n\tvcpu_stall_config = (struct vcpu_stall_detect_config) {\n\t\t.membase\t\t= membase,\n\t\t.clock_freq_hz\t\t= clock_freq_hz,\n\t\t.stall_timeout_sec\t= stall_timeout_sec\n\t};\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\"virt/vcpu_stall_detector:online\",\n\t\t\t\tstart_stall_detector_cpu,\n\t\t\t\tstop_stall_detector_cpu);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to install cpu hotplug\");\n\t\tgoto err;\n\t}\n\n\tvcpu_stall_config.hp_online = ret;\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int vcpu_stall_detect_remove(struct platform_device *pdev)\n{\n\tint cpu;\n\n\tcpuhp_remove_state(vcpu_stall_config.hp_online);\n\n\tfor_each_possible_cpu(cpu)\n\t\tstop_stall_detector_cpu(cpu);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id vcpu_stall_detect_of_match[] = {\n\t{ .compatible = \"qemu,vcpu-stall-detector\", },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, vcpu_stall_detect_of_match);\n\nstatic struct platform_driver vcpu_stall_detect_driver = {\n\t.probe  = vcpu_stall_detect_probe,\n\t.remove = vcpu_stall_detect_remove,\n\t.driver = {\n\t\t.name           = KBUILD_MODNAME,\n\t\t.of_match_table = vcpu_stall_detect_of_match,\n\t},\n};\n\nmodule_platform_driver(vcpu_stall_detect_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Sebastian Ene <sebastianene@google.com>\");\nMODULE_DESCRIPTION(\"VCPU stall detector\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}