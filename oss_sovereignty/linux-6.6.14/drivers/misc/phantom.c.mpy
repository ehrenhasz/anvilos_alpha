{
  "module_name": "phantom.c",
  "hash_id": "644e8f0be65a0e6fb9bc2c18652ea5acccbe2c058206745dfd852dcb8220ca77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/phantom.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/interrupt.h>\n#include <linux/cdev.h>\n#include <linux/slab.h>\n#include <linux/phantom.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#include <linux/atomic.h>\n#include <asm/io.h>\n\n#define PHANTOM_VERSION\t\t\"n0.9.8\"\n\n#define PHANTOM_MAX_MINORS\t8\n\n#define PHN_IRQCTL\t\t0x4c     \n\n#define PHB_RUNNING\t\t1\n#define PHB_NOT_OH\t\t2\n\nstatic DEFINE_MUTEX(phantom_mutex);\nstatic struct class *phantom_class;\nstatic int phantom_major;\n\nstruct phantom_device {\n\tunsigned int opened;\n\tvoid __iomem *caddr;\n\tu32 __iomem *iaddr;\n\tu32 __iomem *oaddr;\n\tunsigned long status;\n\tatomic_t counter;\n\n\twait_queue_head_t wait;\n\tstruct cdev cdev;\n\n\tstruct mutex open_lock;\n\tspinlock_t regs_lock;\n\n\t \n\tstruct phm_regs oregs;\n\tu32 ctl_reg;\n};\n\nstatic unsigned char phantom_devices[PHANTOM_MAX_MINORS];\n\nstatic int phantom_status(struct phantom_device *dev, unsigned long newstat)\n{\n\tpr_debug(\"phantom_status %lx %lx\\n\", dev->status, newstat);\n\n\tif (!(dev->status & PHB_RUNNING) && (newstat & PHB_RUNNING)) {\n\t\tatomic_set(&dev->counter, 0);\n\t\tiowrite32(PHN_CTL_IRQ, dev->iaddr + PHN_CONTROL);\n\t\tiowrite32(0x43, dev->caddr + PHN_IRQCTL);\n\t\tioread32(dev->caddr + PHN_IRQCTL);  \n\t} else if ((dev->status & PHB_RUNNING) && !(newstat & PHB_RUNNING)) {\n\t\tiowrite32(0, dev->caddr + PHN_IRQCTL);\n\t\tioread32(dev->caddr + PHN_IRQCTL);  \n\t}\n\n\tdev->status = newstat;\n\n\treturn 0;\n}\n\n \n\nstatic long phantom_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct phantom_device *dev = file->private_data;\n\tstruct phm_regs rs;\n\tstruct phm_reg r;\n\tvoid __user *argp = (void __user *)arg;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tswitch (cmd) {\n\tcase PHN_SETREG:\n\tcase PHN_SET_REG:\n\t\tif (copy_from_user(&r, argp, sizeof(r)))\n\t\t\treturn -EFAULT;\n\n\t\tif (r.reg > 7)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irqsave(&dev->regs_lock, flags);\n\t\tif (r.reg == PHN_CONTROL && (r.value & PHN_CTL_IRQ) &&\n\t\t\t\tphantom_status(dev, dev->status | PHB_RUNNING)){\n\t\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tpr_debug(\"phantom: writing %x to %u\\n\", r.value, r.reg);\n\n\t\t \n\t\tif (r.reg == PHN_CONTROL && (dev->status & PHB_NOT_OH)) {\n\t\t\tr.value &= ~PHN_CTL_AMP;\n\t\t\tr.value |= dev->ctl_reg & PHN_CTL_AMP;\n\t\t\tdev->ctl_reg = r.value;\n\t\t}\n\n\t\tiowrite32(r.value, dev->iaddr + r.reg);\n\t\tioread32(dev->iaddr);  \n\n\t\tif (r.reg == PHN_CONTROL && !(r.value & PHN_CTL_IRQ))\n\t\t\tphantom_status(dev, dev->status & ~PHB_RUNNING);\n\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\t\tbreak;\n\tcase PHN_SETREGS:\n\tcase PHN_SET_REGS:\n\t\tif (copy_from_user(&rs, argp, sizeof(rs)))\n\t\t\treturn -EFAULT;\n\n\t\tpr_debug(\"phantom: SRS %u regs %x\\n\", rs.count, rs.mask);\n\t\tspin_lock_irqsave(&dev->regs_lock, flags);\n\t\tif (dev->status & PHB_NOT_OH)\n\t\t\tmemcpy(&dev->oregs, &rs, sizeof(rs));\n\t\telse {\n\t\t\tu32 m = min(rs.count, 8U);\n\t\t\tfor (i = 0; i < m; i++)\n\t\t\t\tif (rs.mask & BIT(i))\n\t\t\t\t\tiowrite32(rs.values[i], dev->oaddr + i);\n\t\t\tioread32(dev->iaddr);  \n\t\t}\n\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\t\tbreak;\n\tcase PHN_GETREG:\n\tcase PHN_GET_REG:\n\t\tif (copy_from_user(&r, argp, sizeof(r)))\n\t\t\treturn -EFAULT;\n\n\t\tif (r.reg > 7)\n\t\t\treturn -EINVAL;\n\n\t\tr.value = ioread32(dev->iaddr + r.reg);\n\n\t\tif (copy_to_user(argp, &r, sizeof(r)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase PHN_GETREGS:\n\tcase PHN_GET_REGS: {\n\t\tu32 m;\n\n\t\tif (copy_from_user(&rs, argp, sizeof(rs)))\n\t\t\treturn -EFAULT;\n\n\t\tm = min(rs.count, 8U);\n\n\t\tpr_debug(\"phantom: GRS %u regs %x\\n\", rs.count, rs.mask);\n\t\tspin_lock_irqsave(&dev->regs_lock, flags);\n\t\tfor (i = 0; i < m; i++)\n\t\t\tif (rs.mask & BIT(i))\n\t\t\t\trs.values[i] = ioread32(dev->iaddr + i);\n\t\tatomic_set(&dev->counter, 0);\n\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\n\t\tif (copy_to_user(argp, &rs, sizeof(rs)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t} case PHN_NOT_OH:\n\t\tspin_lock_irqsave(&dev->regs_lock, flags);\n\t\tif (dev->status & PHB_RUNNING) {\n\t\t\tprintk(KERN_ERR \"phantom: you need to set NOT_OH \"\n\t\t\t\t\t\"before you start the device!\\n\");\n\t\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev->status |= PHB_NOT_OH;\n\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long phantom_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tif (_IOC_NR(cmd) <= 3 && _IOC_SIZE(cmd) == sizeof(compat_uptr_t)) {\n\t\tcmd &= ~(_IOC_SIZEMASK << _IOC_SIZESHIFT);\n\t\tcmd |= sizeof(void *) << _IOC_SIZESHIFT;\n\t}\n\treturn phantom_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\n}\n#else\n#define phantom_compat_ioctl NULL\n#endif\n\nstatic int phantom_open(struct inode *inode, struct file *file)\n{\n\tstruct phantom_device *dev = container_of(inode->i_cdev,\n\t\t\tstruct phantom_device, cdev);\n\n\tmutex_lock(&phantom_mutex);\n\tnonseekable_open(inode, file);\n\n\tif (mutex_lock_interruptible(&dev->open_lock)) {\n\t\tmutex_unlock(&phantom_mutex);\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tif (dev->opened) {\n\t\tmutex_unlock(&dev->open_lock);\n\t\tmutex_unlock(&phantom_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(dev->status & PHB_NOT_OH);\n\n\tfile->private_data = dev;\n\n\tatomic_set(&dev->counter, 0);\n\tdev->opened++;\n\tmutex_unlock(&dev->open_lock);\n\tmutex_unlock(&phantom_mutex);\n\treturn 0;\n}\n\nstatic int phantom_release(struct inode *inode, struct file *file)\n{\n\tstruct phantom_device *dev = file->private_data;\n\n\tmutex_lock(&dev->open_lock);\n\n\tdev->opened = 0;\n\tphantom_status(dev, dev->status & ~PHB_RUNNING);\n\tdev->status &= ~PHB_NOT_OH;\n\n\tmutex_unlock(&dev->open_lock);\n\n\treturn 0;\n}\n\nstatic __poll_t phantom_poll(struct file *file, poll_table *wait)\n{\n\tstruct phantom_device *dev = file->private_data;\n\t__poll_t mask = 0;\n\n\tpr_debug(\"phantom_poll: %d\\n\", atomic_read(&dev->counter));\n\tpoll_wait(file, &dev->wait, wait);\n\n\tif (!(dev->status & PHB_RUNNING))\n\t\tmask = EPOLLERR;\n\telse if (atomic_read(&dev->counter))\n\t\tmask = EPOLLIN | EPOLLRDNORM;\n\n\tpr_debug(\"phantom_poll end: %x/%d\\n\", mask, atomic_read(&dev->counter));\n\n\treturn mask;\n}\n\nstatic const struct file_operations phantom_file_ops = {\n\t.open = phantom_open,\n\t.release = phantom_release,\n\t.unlocked_ioctl = phantom_ioctl,\n\t.compat_ioctl = phantom_compat_ioctl,\n\t.poll = phantom_poll,\n\t.llseek = no_llseek,\n};\n\nstatic irqreturn_t phantom_isr(int irq, void *data)\n{\n\tstruct phantom_device *dev = data;\n\tunsigned int i;\n\tu32 ctl;\n\n\tspin_lock(&dev->regs_lock);\n\tctl = ioread32(dev->iaddr + PHN_CONTROL);\n\tif (!(ctl & PHN_CTL_IRQ)) {\n\t\tspin_unlock(&dev->regs_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tiowrite32(0, dev->iaddr);\n\tiowrite32(0xc0, dev->iaddr);\n\n\tif (dev->status & PHB_NOT_OH) {\n\t\tstruct phm_regs *r = &dev->oregs;\n\t\tu32 m = min(r->count, 8U);\n\n\t\tfor (i = 0; i < m; i++)\n\t\t\tif (r->mask & BIT(i))\n\t\t\t\tiowrite32(r->values[i], dev->oaddr + i);\n\n\t\tdev->ctl_reg ^= PHN_CTL_AMP;\n\t\tiowrite32(dev->ctl_reg, dev->iaddr + PHN_CONTROL);\n\t}\n\tspin_unlock(&dev->regs_lock);\n\n\tioread32(dev->iaddr);  \n\n\tatomic_inc(&dev->counter);\n\twake_up_interruptible(&dev->wait);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic unsigned int phantom_get_free(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < PHANTOM_MAX_MINORS; i++)\n\t\tif (phantom_devices[i] == 0)\n\t\t\tbreak;\n\n\treturn i;\n}\n\nstatic int phantom_probe(struct pci_dev *pdev,\n\tconst struct pci_device_id *pci_id)\n{\n\tstruct phantom_device *pht;\n\tunsigned int minor;\n\tint retval;\n\n\tretval = pci_enable_device(pdev);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"pci_enable_device failed!\\n\");\n\t\tgoto err;\n\t}\n\n\tminor = phantom_get_free();\n\tif (minor == PHANTOM_MAX_MINORS) {\n\t\tdev_err(&pdev->dev, \"too many devices found!\\n\");\n\t\tretval = -EIO;\n\t\tgoto err_dis;\n\t}\n\n\tphantom_devices[minor] = 1;\n\n\tretval = pci_request_regions(pdev, \"phantom\");\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"pci_request_regions failed!\\n\");\n\t\tgoto err_null;\n\t}\n\n\tretval = -ENOMEM;\n\tpht = kzalloc(sizeof(*pht), GFP_KERNEL);\n\tif (pht == NULL) {\n\t\tdev_err(&pdev->dev, \"unable to allocate device\\n\");\n\t\tgoto err_reg;\n\t}\n\n\tpht->caddr = pci_iomap(pdev, 0, 0);\n\tif (pht->caddr == NULL) {\n\t\tdev_err(&pdev->dev, \"can't remap conf space\\n\");\n\t\tgoto err_fr;\n\t}\n\tpht->iaddr = pci_iomap(pdev, 2, 0);\n\tif (pht->iaddr == NULL) {\n\t\tdev_err(&pdev->dev, \"can't remap input space\\n\");\n\t\tgoto err_unmc;\n\t}\n\tpht->oaddr = pci_iomap(pdev, 3, 0);\n\tif (pht->oaddr == NULL) {\n\t\tdev_err(&pdev->dev, \"can't remap output space\\n\");\n\t\tgoto err_unmi;\n\t}\n\n\tmutex_init(&pht->open_lock);\n\tspin_lock_init(&pht->regs_lock);\n\tinit_waitqueue_head(&pht->wait);\n\tcdev_init(&pht->cdev, &phantom_file_ops);\n\tpht->cdev.owner = THIS_MODULE;\n\n\tiowrite32(0, pht->caddr + PHN_IRQCTL);\n\tioread32(pht->caddr + PHN_IRQCTL);  \n\tretval = request_irq(pdev->irq, phantom_isr,\n\t\t\tIRQF_SHARED, \"phantom\", pht);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"can't establish ISR\\n\");\n\t\tgoto err_unmo;\n\t}\n\n\tretval = cdev_add(&pht->cdev, MKDEV(phantom_major, minor), 1);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"chardev registration failed\\n\");\n\t\tgoto err_irq;\n\t}\n\n\tif (IS_ERR(device_create(phantom_class, &pdev->dev,\n\t\t\t\t MKDEV(phantom_major, minor), NULL,\n\t\t\t\t \"phantom%u\", minor)))\n\t\tdev_err(&pdev->dev, \"can't create device\\n\");\n\n\tpci_set_drvdata(pdev, pht);\n\n\treturn 0;\nerr_irq:\n\tfree_irq(pdev->irq, pht);\nerr_unmo:\n\tpci_iounmap(pdev, pht->oaddr);\nerr_unmi:\n\tpci_iounmap(pdev, pht->iaddr);\nerr_unmc:\n\tpci_iounmap(pdev, pht->caddr);\nerr_fr:\n\tkfree(pht);\nerr_reg:\n\tpci_release_regions(pdev);\nerr_null:\n\tphantom_devices[minor] = 0;\nerr_dis:\n\tpci_disable_device(pdev);\nerr:\n\treturn retval;\n}\n\nstatic void phantom_remove(struct pci_dev *pdev)\n{\n\tstruct phantom_device *pht = pci_get_drvdata(pdev);\n\tunsigned int minor = MINOR(pht->cdev.dev);\n\n\tdevice_destroy(phantom_class, MKDEV(phantom_major, minor));\n\n\tcdev_del(&pht->cdev);\n\n\tiowrite32(0, pht->caddr + PHN_IRQCTL);\n\tioread32(pht->caddr + PHN_IRQCTL);  \n\tfree_irq(pdev->irq, pht);\n\n\tpci_iounmap(pdev, pht->oaddr);\n\tpci_iounmap(pdev, pht->iaddr);\n\tpci_iounmap(pdev, pht->caddr);\n\n\tkfree(pht);\n\n\tpci_release_regions(pdev);\n\n\tphantom_devices[minor] = 0;\n\n\tpci_disable_device(pdev);\n}\n\nstatic int __maybe_unused phantom_suspend(struct device *dev_d)\n{\n\tstruct phantom_device *dev = dev_get_drvdata(dev_d);\n\n\tiowrite32(0, dev->caddr + PHN_IRQCTL);\n\tioread32(dev->caddr + PHN_IRQCTL);  \n\n\tsynchronize_irq(to_pci_dev(dev_d)->irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused phantom_resume(struct device *dev_d)\n{\n\tstruct phantom_device *dev = dev_get_drvdata(dev_d);\n\n\tiowrite32(0, dev->caddr + PHN_IRQCTL);\n\n\treturn 0;\n}\n\nstatic struct pci_device_id phantom_pci_tbl[] = {\n\t{ .vendor = PCI_VENDOR_ID_PLX, .device = PCI_DEVICE_ID_PLX_9050,\n\t  .subvendor = PCI_VENDOR_ID_PLX, .subdevice = PCI_DEVICE_ID_PLX_9050,\n\t  .class = PCI_CLASS_BRIDGE_OTHER << 8, .class_mask = 0xffff00 },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, phantom_pci_tbl);\n\nstatic SIMPLE_DEV_PM_OPS(phantom_pm_ops, phantom_suspend, phantom_resume);\n\nstatic struct pci_driver phantom_pci_driver = {\n\t.name = \"phantom\",\n\t.id_table = phantom_pci_tbl,\n\t.probe = phantom_probe,\n\t.remove = phantom_remove,\n\t.driver.pm = &phantom_pm_ops,\n};\n\nstatic CLASS_ATTR_STRING(version, 0444, PHANTOM_VERSION);\n\nstatic int __init phantom_init(void)\n{\n\tint retval;\n\tdev_t dev;\n\n\tphantom_class = class_create(\"phantom\");\n\tif (IS_ERR(phantom_class)) {\n\t\tretval = PTR_ERR(phantom_class);\n\t\tprintk(KERN_ERR \"phantom: can't register phantom class\\n\");\n\t\tgoto err;\n\t}\n\tretval = class_create_file(phantom_class, &class_attr_version.attr);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"phantom: can't create sysfs version file\\n\");\n\t\tgoto err_class;\n\t}\n\n\tretval = alloc_chrdev_region(&dev, 0, PHANTOM_MAX_MINORS, \"phantom\");\n\tif (retval) {\n\t\tprintk(KERN_ERR \"phantom: can't register character device\\n\");\n\t\tgoto err_attr;\n\t}\n\tphantom_major = MAJOR(dev);\n\n\tretval = pci_register_driver(&phantom_pci_driver);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"phantom: can't register pci driver\\n\");\n\t\tgoto err_unchr;\n\t}\n\n\tprintk(KERN_INFO \"Phantom Linux Driver, version \" PHANTOM_VERSION \", \"\n\t\t\t\"init OK\\n\");\n\n\treturn 0;\nerr_unchr:\n\tunregister_chrdev_region(dev, PHANTOM_MAX_MINORS);\nerr_attr:\n\tclass_remove_file(phantom_class, &class_attr_version.attr);\nerr_class:\n\tclass_destroy(phantom_class);\nerr:\n\treturn retval;\n}\n\nstatic void __exit phantom_exit(void)\n{\n\tpci_unregister_driver(&phantom_pci_driver);\n\n\tunregister_chrdev_region(MKDEV(phantom_major, 0), PHANTOM_MAX_MINORS);\n\n\tclass_remove_file(phantom_class, &class_attr_version.attr);\n\tclass_destroy(phantom_class);\n\n\tpr_debug(\"phantom: module successfully removed\\n\");\n}\n\nmodule_init(phantom_init);\nmodule_exit(phantom_exit);\n\nMODULE_AUTHOR(\"Jiri Slaby <jirislaby@gmail.com>\");\nMODULE_DESCRIPTION(\"Sensable Phantom driver (PCI devices)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(PHANTOM_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}