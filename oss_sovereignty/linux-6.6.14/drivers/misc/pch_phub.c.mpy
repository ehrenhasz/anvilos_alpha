{
  "module_name": "pch_phub.c",
  "hash_id": "d0cd366c7eab19a131cf617679e63a5fee4c71cbd57ce2c8fdc76c76b6aee10c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/pch_phub.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/if_ether.h>\n#include <linux/ctype.h>\n#include <linux/dmi.h>\n#include <linux/of.h>\n\n#define PHUB_STATUS 0x00\t\t \n#define PHUB_CONTROL 0x04\t\t \n#define PHUB_TIMEOUT 0x05\t\t \n#define PCH_PHUB_ROM_WRITE_ENABLE 0x01\t \n#define PCH_PHUB_ROM_WRITE_DISABLE 0x00\t \n#define PCH_PHUB_MAC_START_ADDR_EG20T 0x14   \n#define PCH_PHUB_MAC_START_ADDR_ML7223 0x20C   \n#define PCH_PHUB_ROM_START_ADDR_EG20T 0x80  \n#define PCH_PHUB_ROM_START_ADDR_ML7213 0x400  \n#define PCH_PHUB_ROM_START_ADDR_ML7223 0x400  \n\n \n#define MAX_NUM_INT_REDUCE_CONTROL_REG 128\n#define PCI_DEVICE_ID_PCH1_PHUB 0x8801\n#define PCH_MINOR_NOS 1\n#define CLKCFG_CAN_50MHZ 0x12000000\n#define CLKCFG_CANCLK_MASK 0xFF000000\n#define CLKCFG_UART_MASK\t\t\t0xFFFFFF\n\n \n#define CLKCFG_UART_48MHZ\t\t\t(1 << 16)\n#define CLKCFG_UART_25MHZ\t\t\t(2 << 16)\n#define CLKCFG_BAUDDIV\t\t\t\t(2 << 20)\n#define CLKCFG_PLL2VCO\t\t\t\t(8 << 9)\n#define CLKCFG_UARTCLKSEL\t\t\t(1 << 18)\n\n \n#define PCI_DEVICE_ID_ROHM_ML7213_PHUB\t\t0x801A\n\n \n#define PCI_DEVICE_ID_ROHM_ML7223_mPHUB\t0x8012  \n#define PCI_DEVICE_ID_ROHM_ML7223_nPHUB\t0x8002  \n\n \n#define PCI_DEVICE_ID_ROHM_ML7831_PHUB 0x8801\n\n \n#define PCH_WORD_ADDR_MASK (~((1 << 2) - 1))\n\n \n#define PCH_PHUB_ID_REG\t\t\t\t0x0000\n#define PCH_PHUB_QUEUE_PRI_VAL_REG\t\t0x0004\n#define PCH_PHUB_RC_QUEUE_MAXSIZE_REG\t\t0x0008\n#define PCH_PHUB_BRI_QUEUE_MAXSIZE_REG\t\t0x000C\n#define PCH_PHUB_COMP_RESP_TIMEOUT_REG\t\t0x0010\n#define PCH_PHUB_BUS_SLAVE_CONTROL_REG\t\t0x0014\n#define PCH_PHUB_DEADLOCK_AVOID_TYPE_REG\t0x0018\n#define PCH_PHUB_INTPIN_REG_WPERMIT_REG0\t0x0020\n#define PCH_PHUB_INTPIN_REG_WPERMIT_REG1\t0x0024\n#define PCH_PHUB_INTPIN_REG_WPERMIT_REG2\t0x0028\n#define PCH_PHUB_INTPIN_REG_WPERMIT_REG3\t0x002C\n#define PCH_PHUB_INT_REDUCE_CONTROL_REG_BASE\t0x0040\n#define CLKCFG_REG_OFFSET\t\t\t0x500\n#define FUNCSEL_REG_OFFSET\t\t\t0x508\n\n#define PCH_PHUB_OROM_SIZE 15360\n\n \nstruct pch_phub_reg {\n\tu32 phub_id_reg;\n\tu32 q_pri_val_reg;\n\tu32 rc_q_maxsize_reg;\n\tu32 bri_q_maxsize_reg;\n\tu32 comp_resp_timeout_reg;\n\tu32 bus_slave_control_reg;\n\tu32 deadlock_avoid_type_reg;\n\tu32 intpin_reg_wpermit_reg0;\n\tu32 intpin_reg_wpermit_reg1;\n\tu32 intpin_reg_wpermit_reg2;\n\tu32 intpin_reg_wpermit_reg3;\n\tu32 int_reduce_control_reg[MAX_NUM_INT_REDUCE_CONTROL_REG];\n\tu32 clkcfg_reg;\n\tu32 funcsel_reg;\n\tvoid __iomem *pch_phub_base_address;\n\tvoid __iomem *pch_phub_extrom_base_address;\n\tu32 pch_mac_start_address;\n\tu32 pch_opt_rom_start_address;\n\tint ioh_type;\n\tstruct pci_dev *pdev;\n};\n\n \nstatic const int pch_phub_mac_offset[ETH_ALEN] = {0x3, 0x2, 0x1, 0x0, 0xb, 0xa};\n\nstatic DEFINE_MUTEX(pch_phub_mutex);\n\n \nstatic void pch_phub_read_modify_write_reg(struct pch_phub_reg *chip,\n\t\t\t\t\t   unsigned int reg_addr_offset,\n\t\t\t\t\t   unsigned int data, unsigned int mask)\n{\n\tvoid __iomem *reg_addr = chip->pch_phub_base_address + reg_addr_offset;\n\tiowrite32(((ioread32(reg_addr) & ~mask)) | data, reg_addr);\n}\n\n \nstatic void __maybe_unused pch_phub_save_reg_conf(struct pci_dev *pdev)\n{\n\tunsigned int i;\n\tstruct pch_phub_reg *chip = pci_get_drvdata(pdev);\n\n\tvoid __iomem *p = chip->pch_phub_base_address;\n\n\tchip->phub_id_reg = ioread32(p + PCH_PHUB_ID_REG);\n\tchip->q_pri_val_reg = ioread32(p + PCH_PHUB_QUEUE_PRI_VAL_REG);\n\tchip->rc_q_maxsize_reg = ioread32(p + PCH_PHUB_RC_QUEUE_MAXSIZE_REG);\n\tchip->bri_q_maxsize_reg = ioread32(p + PCH_PHUB_BRI_QUEUE_MAXSIZE_REG);\n\tchip->comp_resp_timeout_reg =\n\t\t\t\tioread32(p + PCH_PHUB_COMP_RESP_TIMEOUT_REG);\n\tchip->bus_slave_control_reg =\n\t\t\t\tioread32(p + PCH_PHUB_BUS_SLAVE_CONTROL_REG);\n\tchip->deadlock_avoid_type_reg =\n\t\t\t\tioread32(p + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);\n\tchip->intpin_reg_wpermit_reg0 =\n\t\t\t\tioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);\n\tchip->intpin_reg_wpermit_reg1 =\n\t\t\t\tioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG1);\n\tchip->intpin_reg_wpermit_reg2 =\n\t\t\t\tioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG2);\n\tchip->intpin_reg_wpermit_reg3 =\n\t\t\t\tioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG3);\n\tdev_dbg(&pdev->dev, \"%s : \"\n\t\t\"chip->phub_id_reg=%x, \"\n\t\t\"chip->q_pri_val_reg=%x, \"\n\t\t\"chip->rc_q_maxsize_reg=%x, \"\n\t\t\"chip->bri_q_maxsize_reg=%x, \"\n\t\t\"chip->comp_resp_timeout_reg=%x, \"\n\t\t\"chip->bus_slave_control_reg=%x, \"\n\t\t\"chip->deadlock_avoid_type_reg=%x, \"\n\t\t\"chip->intpin_reg_wpermit_reg0=%x, \"\n\t\t\"chip->intpin_reg_wpermit_reg1=%x, \"\n\t\t\"chip->intpin_reg_wpermit_reg2=%x, \"\n\t\t\"chip->intpin_reg_wpermit_reg3=%x\\n\", __func__,\n\t\tchip->phub_id_reg,\n\t\tchip->q_pri_val_reg,\n\t\tchip->rc_q_maxsize_reg,\n\t\tchip->bri_q_maxsize_reg,\n\t\tchip->comp_resp_timeout_reg,\n\t\tchip->bus_slave_control_reg,\n\t\tchip->deadlock_avoid_type_reg,\n\t\tchip->intpin_reg_wpermit_reg0,\n\t\tchip->intpin_reg_wpermit_reg1,\n\t\tchip->intpin_reg_wpermit_reg2,\n\t\tchip->intpin_reg_wpermit_reg3);\n\tfor (i = 0; i < MAX_NUM_INT_REDUCE_CONTROL_REG; i++) {\n\t\tchip->int_reduce_control_reg[i] =\n\t\t    ioread32(p + PCH_PHUB_INT_REDUCE_CONTROL_REG_BASE + 4 * i);\n\t\tdev_dbg(&pdev->dev, \"%s : \"\n\t\t\t\"chip->int_reduce_control_reg[%d]=%x\\n\",\n\t\t\t__func__, i, chip->int_reduce_control_reg[i]);\n\t}\n\tchip->clkcfg_reg = ioread32(p + CLKCFG_REG_OFFSET);\n\tif ((chip->ioh_type == 2) || (chip->ioh_type == 4))\n\t\tchip->funcsel_reg = ioread32(p + FUNCSEL_REG_OFFSET);\n}\n\n \nstatic void __maybe_unused pch_phub_restore_reg_conf(struct pci_dev *pdev)\n{\n\tunsigned int i;\n\tstruct pch_phub_reg *chip = pci_get_drvdata(pdev);\n\tvoid __iomem *p;\n\tp = chip->pch_phub_base_address;\n\n\tiowrite32(chip->phub_id_reg, p + PCH_PHUB_ID_REG);\n\tiowrite32(chip->q_pri_val_reg, p + PCH_PHUB_QUEUE_PRI_VAL_REG);\n\tiowrite32(chip->rc_q_maxsize_reg, p + PCH_PHUB_RC_QUEUE_MAXSIZE_REG);\n\tiowrite32(chip->bri_q_maxsize_reg, p + PCH_PHUB_BRI_QUEUE_MAXSIZE_REG);\n\tiowrite32(chip->comp_resp_timeout_reg,\n\t\t\t\t\tp + PCH_PHUB_COMP_RESP_TIMEOUT_REG);\n\tiowrite32(chip->bus_slave_control_reg,\n\t\t\t\t\tp + PCH_PHUB_BUS_SLAVE_CONTROL_REG);\n\tiowrite32(chip->deadlock_avoid_type_reg,\n\t\t\t\t\tp + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);\n\tiowrite32(chip->intpin_reg_wpermit_reg0,\n\t\t\t\t\tp + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);\n\tiowrite32(chip->intpin_reg_wpermit_reg1,\n\t\t\t\t\tp + PCH_PHUB_INTPIN_REG_WPERMIT_REG1);\n\tiowrite32(chip->intpin_reg_wpermit_reg2,\n\t\t\t\t\tp + PCH_PHUB_INTPIN_REG_WPERMIT_REG2);\n\tiowrite32(chip->intpin_reg_wpermit_reg3,\n\t\t\t\t\tp + PCH_PHUB_INTPIN_REG_WPERMIT_REG3);\n\tdev_dbg(&pdev->dev, \"%s : \"\n\t\t\"chip->phub_id_reg=%x, \"\n\t\t\"chip->q_pri_val_reg=%x, \"\n\t\t\"chip->rc_q_maxsize_reg=%x, \"\n\t\t\"chip->bri_q_maxsize_reg=%x, \"\n\t\t\"chip->comp_resp_timeout_reg=%x, \"\n\t\t\"chip->bus_slave_control_reg=%x, \"\n\t\t\"chip->deadlock_avoid_type_reg=%x, \"\n\t\t\"chip->intpin_reg_wpermit_reg0=%x, \"\n\t\t\"chip->intpin_reg_wpermit_reg1=%x, \"\n\t\t\"chip->intpin_reg_wpermit_reg2=%x, \"\n\t\t\"chip->intpin_reg_wpermit_reg3=%x\\n\", __func__,\n\t\tchip->phub_id_reg,\n\t\tchip->q_pri_val_reg,\n\t\tchip->rc_q_maxsize_reg,\n\t\tchip->bri_q_maxsize_reg,\n\t\tchip->comp_resp_timeout_reg,\n\t\tchip->bus_slave_control_reg,\n\t\tchip->deadlock_avoid_type_reg,\n\t\tchip->intpin_reg_wpermit_reg0,\n\t\tchip->intpin_reg_wpermit_reg1,\n\t\tchip->intpin_reg_wpermit_reg2,\n\t\tchip->intpin_reg_wpermit_reg3);\n\tfor (i = 0; i < MAX_NUM_INT_REDUCE_CONTROL_REG; i++) {\n\t\tiowrite32(chip->int_reduce_control_reg[i],\n\t\t\tp + PCH_PHUB_INT_REDUCE_CONTROL_REG_BASE + 4 * i);\n\t\tdev_dbg(&pdev->dev, \"%s : \"\n\t\t\t\"chip->int_reduce_control_reg[%d]=%x\\n\",\n\t\t\t__func__, i, chip->int_reduce_control_reg[i]);\n\t}\n\n\tiowrite32(chip->clkcfg_reg, p + CLKCFG_REG_OFFSET);\n\tif ((chip->ioh_type == 2) || (chip->ioh_type == 4))\n\t\tiowrite32(chip->funcsel_reg, p + FUNCSEL_REG_OFFSET);\n}\n\n \nstatic void pch_phub_read_serial_rom(struct pch_phub_reg *chip,\n\t\t\t\t     unsigned int offset_address, u8 *data)\n{\n\tvoid __iomem *mem_addr = chip->pch_phub_extrom_base_address +\n\t\t\t\t\t\t\t\toffset_address;\n\n\t*data = ioread8(mem_addr);\n}\n\n \nstatic int pch_phub_write_serial_rom(struct pch_phub_reg *chip,\n\t\t\t\t     unsigned int offset_address, u8 data)\n{\n\tvoid __iomem *mem_addr = chip->pch_phub_extrom_base_address +\n\t\t\t\t\t(offset_address & PCH_WORD_ADDR_MASK);\n\tint i;\n\tunsigned int word_data;\n\tunsigned int pos;\n\tunsigned int mask;\n\tpos = (offset_address % 4) * 8;\n\tmask = ~(0xFF << pos);\n\n\tiowrite32(PCH_PHUB_ROM_WRITE_ENABLE,\n\t\t\tchip->pch_phub_extrom_base_address + PHUB_CONTROL);\n\n\tword_data = ioread32(mem_addr);\n\tiowrite32((word_data & mask) | (u32)data << pos, mem_addr);\n\n\ti = 0;\n\twhile (ioread8(chip->pch_phub_extrom_base_address +\n\t\t\t\t\t\tPHUB_STATUS) != 0x00) {\n\t\tmsleep(1);\n\t\tif (i == PHUB_TIMEOUT)\n\t\t\treturn -ETIMEDOUT;\n\t\ti++;\n\t}\n\n\tiowrite32(PCH_PHUB_ROM_WRITE_DISABLE,\n\t\t\tchip->pch_phub_extrom_base_address + PHUB_CONTROL);\n\n\treturn 0;\n}\n\n \nstatic void pch_phub_read_serial_rom_val(struct pch_phub_reg *chip,\n\t\t\t\t\t unsigned int offset_address, u8 *data)\n{\n\tunsigned int mem_addr;\n\n\tmem_addr = chip->pch_mac_start_address +\n\t\t\tpch_phub_mac_offset[offset_address];\n\n\tpch_phub_read_serial_rom(chip, mem_addr, data);\n}\n\n \nstatic int pch_phub_write_serial_rom_val(struct pch_phub_reg *chip,\n\t\t\t\t\t unsigned int offset_address, u8 data)\n{\n\tint retval;\n\tunsigned int mem_addr;\n\n\tmem_addr = chip->pch_mac_start_address +\n\t\t\tpch_phub_mac_offset[offset_address];\n\n\tretval = pch_phub_write_serial_rom(chip, mem_addr, data);\n\n\treturn retval;\n}\n\n \nstatic int pch_phub_gbe_serial_rom_conf(struct pch_phub_reg *chip)\n{\n\tint retval;\n\n\tretval = pch_phub_write_serial_rom(chip, 0x0b, 0xbc);\n\tretval |= pch_phub_write_serial_rom(chip, 0x0a, 0x10);\n\tretval |= pch_phub_write_serial_rom(chip, 0x09, 0x01);\n\tretval |= pch_phub_write_serial_rom(chip, 0x08, 0x02);\n\n\tretval |= pch_phub_write_serial_rom(chip, 0x0f, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x0e, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x0d, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x0c, 0x80);\n\n\tretval |= pch_phub_write_serial_rom(chip, 0x13, 0xbc);\n\tretval |= pch_phub_write_serial_rom(chip, 0x12, 0x10);\n\tretval |= pch_phub_write_serial_rom(chip, 0x11, 0x01);\n\tretval |= pch_phub_write_serial_rom(chip, 0x10, 0x18);\n\n\tretval |= pch_phub_write_serial_rom(chip, 0x1b, 0xbc);\n\tretval |= pch_phub_write_serial_rom(chip, 0x1a, 0x10);\n\tretval |= pch_phub_write_serial_rom(chip, 0x19, 0x01);\n\tretval |= pch_phub_write_serial_rom(chip, 0x18, 0x19);\n\n\tretval |= pch_phub_write_serial_rom(chip, 0x23, 0xbc);\n\tretval |= pch_phub_write_serial_rom(chip, 0x22, 0x10);\n\tretval |= pch_phub_write_serial_rom(chip, 0x21, 0x01);\n\tretval |= pch_phub_write_serial_rom(chip, 0x20, 0x3a);\n\n\tretval |= pch_phub_write_serial_rom(chip, 0x27, 0x01);\n\tretval |= pch_phub_write_serial_rom(chip, 0x26, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x25, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x24, 0x00);\n\n\treturn retval;\n}\n\n \nstatic int pch_phub_gbe_serial_rom_conf_mp(struct pch_phub_reg *chip)\n{\n\tint retval;\n\tu32 offset_addr;\n\n\toffset_addr = 0x200;\n\tretval = pch_phub_write_serial_rom(chip, 0x03 + offset_addr, 0xbc);\n\tretval |= pch_phub_write_serial_rom(chip, 0x02 + offset_addr, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x01 + offset_addr, 0x40);\n\tretval |= pch_phub_write_serial_rom(chip, 0x00 + offset_addr, 0x02);\n\n\tretval |= pch_phub_write_serial_rom(chip, 0x07 + offset_addr, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x06 + offset_addr, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x05 + offset_addr, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x04 + offset_addr, 0x80);\n\n\tretval |= pch_phub_write_serial_rom(chip, 0x0b + offset_addr, 0xbc);\n\tretval |= pch_phub_write_serial_rom(chip, 0x0a + offset_addr, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x09 + offset_addr, 0x40);\n\tretval |= pch_phub_write_serial_rom(chip, 0x08 + offset_addr, 0x18);\n\n\tretval |= pch_phub_write_serial_rom(chip, 0x13 + offset_addr, 0xbc);\n\tretval |= pch_phub_write_serial_rom(chip, 0x12 + offset_addr, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x11 + offset_addr, 0x40);\n\tretval |= pch_phub_write_serial_rom(chip, 0x10 + offset_addr, 0x19);\n\n\tretval |= pch_phub_write_serial_rom(chip, 0x1b + offset_addr, 0xbc);\n\tretval |= pch_phub_write_serial_rom(chip, 0x1a + offset_addr, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x19 + offset_addr, 0x40);\n\tretval |= pch_phub_write_serial_rom(chip, 0x18 + offset_addr, 0x3a);\n\n\tretval |= pch_phub_write_serial_rom(chip, 0x1f + offset_addr, 0x01);\n\tretval |= pch_phub_write_serial_rom(chip, 0x1e + offset_addr, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x1d + offset_addr, 0x00);\n\tretval |= pch_phub_write_serial_rom(chip, 0x1c + offset_addr, 0x00);\n\n\treturn retval;\n}\n\n \nstatic void pch_phub_read_gbe_mac_addr(struct pch_phub_reg *chip, u8 *data)\n{\n\tint i;\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tpch_phub_read_serial_rom_val(chip, i, &data[i]);\n}\n\n \nstatic int pch_phub_write_gbe_mac_addr(struct pch_phub_reg *chip, u8 *data)\n{\n\tint retval;\n\tint i;\n\n\tif ((chip->ioh_type == 1) || (chip->ioh_type == 5))  \n\t\tretval = pch_phub_gbe_serial_rom_conf(chip);\n\telse\t \n\t\tretval = pch_phub_gbe_serial_rom_conf_mp(chip);\n\tif (retval)\n\t\treturn retval;\n\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tretval = pch_phub_write_serial_rom_val(chip, i, data[i]);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\treturn retval;\n}\n\nstatic ssize_t pch_phub_bin_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t struct bin_attribute *attr, char *buf,\n\t\t\t\t loff_t off, size_t count)\n{\n\tunsigned int rom_signature;\n\tunsigned char rom_length;\n\tunsigned int tmp;\n\tunsigned int addr_offset;\n\tunsigned int orom_size;\n\tint ret;\n\tint err;\n\tssize_t rom_size;\n\n\tstruct pch_phub_reg *chip = dev_get_drvdata(kobj_to_dev(kobj));\n\n\tret = mutex_lock_interruptible(&pch_phub_mutex);\n\tif (ret) {\n\t\terr = -ERESTARTSYS;\n\t\tgoto return_err_nomutex;\n\t}\n\n\t \n\tchip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);\n\tif (!chip->pch_phub_extrom_base_address) {\n\t\terr = -ENODATA;\n\t\tgoto exrom_map_err;\n\t}\n\n\tpch_phub_read_serial_rom(chip, chip->pch_opt_rom_start_address,\n\t\t\t\t(unsigned char *)&rom_signature);\n\trom_signature &= 0xff;\n\tpch_phub_read_serial_rom(chip, chip->pch_opt_rom_start_address + 1,\n\t\t\t\t(unsigned char *)&tmp);\n\trom_signature |= (tmp & 0xff) << 8;\n\tif (rom_signature == 0xAA55) {\n\t\tpch_phub_read_serial_rom(chip,\n\t\t\t\t\t chip->pch_opt_rom_start_address + 2,\n\t\t\t\t\t &rom_length);\n\t\torom_size = rom_length * 512;\n\t\tif (orom_size < off) {\n\t\t\taddr_offset = 0;\n\t\t\tgoto return_ok;\n\t\t}\n\t\tif (orom_size < count) {\n\t\t\taddr_offset = 0;\n\t\t\tgoto return_ok;\n\t\t}\n\n\t\tfor (addr_offset = 0; addr_offset < count; addr_offset++) {\n\t\t\tpch_phub_read_serial_rom(chip,\n\t\t\t    chip->pch_opt_rom_start_address + addr_offset + off,\n\t\t\t    &buf[addr_offset]);\n\t\t}\n\t} else {\n\t\terr = -ENODATA;\n\t\tgoto return_err;\n\t}\nreturn_ok:\n\tpci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\n\tmutex_unlock(&pch_phub_mutex);\n\treturn addr_offset;\n\nreturn_err:\n\tpci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\nexrom_map_err:\n\tmutex_unlock(&pch_phub_mutex);\nreturn_err_nomutex:\n\treturn err;\n}\n\nstatic ssize_t pch_phub_bin_write(struct file *filp, struct kobject *kobj,\n\t\t\t\t  struct bin_attribute *attr,\n\t\t\t\t  char *buf, loff_t off, size_t count)\n{\n\tint err;\n\tunsigned int addr_offset;\n\tint ret;\n\tssize_t rom_size;\n\tstruct pch_phub_reg *chip = dev_get_drvdata(kobj_to_dev(kobj));\n\n\tret = mutex_lock_interruptible(&pch_phub_mutex);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\n\tif (off > PCH_PHUB_OROM_SIZE) {\n\t\taddr_offset = 0;\n\t\tgoto return_ok;\n\t}\n\tif (count > PCH_PHUB_OROM_SIZE) {\n\t\taddr_offset = 0;\n\t\tgoto return_ok;\n\t}\n\n\tchip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);\n\tif (!chip->pch_phub_extrom_base_address) {\n\t\terr = -ENOMEM;\n\t\tgoto exrom_map_err;\n\t}\n\n\tfor (addr_offset = 0; addr_offset < count; addr_offset++) {\n\t\tif (PCH_PHUB_OROM_SIZE < off + addr_offset)\n\t\t\tgoto return_ok;\n\n\t\tret = pch_phub_write_serial_rom(chip,\n\t\t\t    chip->pch_opt_rom_start_address + addr_offset + off,\n\t\t\t    buf[addr_offset]);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto return_err;\n\t\t}\n\t}\n\nreturn_ok:\n\tpci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\n\tmutex_unlock(&pch_phub_mutex);\n\treturn addr_offset;\n\nreturn_err:\n\tpci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\n\nexrom_map_err:\n\tmutex_unlock(&pch_phub_mutex);\n\treturn err;\n}\n\nstatic ssize_t show_pch_mac(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tu8 mac[8];\n\tstruct pch_phub_reg *chip = dev_get_drvdata(dev);\n\tssize_t rom_size;\n\n\tchip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);\n\tif (!chip->pch_phub_extrom_base_address)\n\t\treturn -ENOMEM;\n\n\tpch_phub_read_gbe_mac_addr(chip, mac);\n\tpci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\n\n\treturn sprintf(buf, \"%pM\\n\", mac);\n}\n\nstatic ssize_t store_pch_mac(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tu8 mac[ETH_ALEN];\n\tssize_t rom_size;\n\tstruct pch_phub_reg *chip = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!mac_pton(buf, mac))\n\t\treturn -EINVAL;\n\n\tchip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);\n\tif (!chip->pch_phub_extrom_base_address)\n\t\treturn -ENOMEM;\n\n\tret = pch_phub_write_gbe_mac_addr(chip, mac);\n\tpci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(pch_mac, S_IRUGO | S_IWUSR, show_pch_mac, store_pch_mac);\n\nstatic const struct bin_attribute pch_bin_attr = {\n\t.attr = {\n\t\t.name = \"pch_firmware\",\n\t\t.mode = S_IRUGO | S_IWUSR,\n\t},\n\t.size = PCH_PHUB_OROM_SIZE + 1,\n\t.read = pch_phub_bin_read,\n\t.write = pch_phub_bin_write,\n};\n\nstatic int pch_phub_probe(struct pci_dev *pdev,\n\t\t\t\t    const struct pci_device_id *id)\n{\n\tint ret;\n\tstruct pch_phub_reg *chip;\n\n\tchip = kzalloc(sizeof(struct pch_phub_reg), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\"%s : pci_enable_device FAILED(ret=%d)\", __func__, ret);\n\t\tgoto err_pci_enable_dev;\n\t}\n\tdev_dbg(&pdev->dev, \"%s : pci_enable_device returns %d\\n\", __func__,\n\t\tret);\n\n\tret = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\"%s : pci_request_regions FAILED(ret=%d)\", __func__, ret);\n\t\tgoto err_req_regions;\n\t}\n\tdev_dbg(&pdev->dev, \"%s : \"\n\t\t\"pci_request_regions returns %d\\n\", __func__, ret);\n\n\tchip->pch_phub_base_address = pci_iomap(pdev, 1, 0);\n\n\n\tif (chip->pch_phub_base_address == NULL) {\n\t\tdev_err(&pdev->dev, \"%s : pci_iomap FAILED\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto err_pci_iomap;\n\t}\n\tdev_dbg(&pdev->dev, \"%s : pci_iomap SUCCESS and value \"\n\t\t\"in pch_phub_base_address variable is %p\\n\", __func__,\n\t\tchip->pch_phub_base_address);\n\n\tchip->pdev = pdev;  \n\n\tif (id->driver_data == 1) {  \n\t\tconst char *board_name;\n\t\tunsigned int prefetch = 0x000affaa;\n\n\t\tif (pdev->dev.of_node)\n\t\t\tof_property_read_u32(pdev->dev.of_node,\n\t\t\t\t\t\t  \"intel,eg20t-prefetch\",\n\t\t\t\t\t\t  &prefetch);\n\n\t\tret = sysfs_create_file(&pdev->dev.kobj,\n\t\t\t\t\t&dev_attr_pch_mac.attr);\n\t\tif (ret)\n\t\t\tgoto err_sysfs_create;\n\n\t\tret = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);\n\t\tif (ret)\n\t\t\tgoto exit_bin_attr;\n\n\t\tpch_phub_read_modify_write_reg(chip,\n\t\t\t\t\t       (unsigned int)CLKCFG_REG_OFFSET,\n\t\t\t\t\t       CLKCFG_CAN_50MHZ,\n\t\t\t\t\t       CLKCFG_CANCLK_MASK);\n\n\t\t \n\t\tboard_name = dmi_get_system_info(DMI_BOARD_NAME);\n\t\tif (board_name && strstr(board_name, \"CM-iTC\"))\n\t\t\tpch_phub_read_modify_write_reg(chip,\n\t\t\t\t\t\t(unsigned int)CLKCFG_REG_OFFSET,\n\t\t\t\t\t\tCLKCFG_UART_48MHZ | CLKCFG_BAUDDIV |\n\t\t\t\t\t\tCLKCFG_PLL2VCO | CLKCFG_UARTCLKSEL,\n\t\t\t\t\t\tCLKCFG_UART_MASK);\n\n\t\t \n\t\tiowrite32(prefetch, chip->pch_phub_base_address + 0x14);\n\t\t \n\t\tiowrite32(0x25, chip->pch_phub_base_address + 0x44);\n\t\tchip->pch_opt_rom_start_address = PCH_PHUB_ROM_START_ADDR_EG20T;\n\t\tchip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_EG20T;\n\n\t\t \n\t\tif (pdev->dev.of_node) {\n\t\t\tif (of_machine_is_compatible(\"img,boston\")) {\n\t\t\t\tpch_phub_read_modify_write_reg(chip,\n\t\t\t\t\t(unsigned int)CLKCFG_REG_OFFSET,\n\t\t\t\t\tCLKCFG_UART_25MHZ,\n\t\t\t\t\tCLKCFG_UART_MASK);\n\t\t\t}\n\t\t}\n\t} else if (id->driver_data == 2) {  \n\t\tret = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);\n\t\tif (ret)\n\t\t\tgoto err_sysfs_create;\n\t\t \n\t\tiowrite32(0x000affa0, chip->pch_phub_base_address + 0x14);\n\t\tchip->pch_opt_rom_start_address =\\\n\t\t\t\t\t\t PCH_PHUB_ROM_START_ADDR_ML7213;\n\t} else if (id->driver_data == 3) {  \n\t\t \n\t\tiowrite32(0x000a0000, chip->pch_phub_base_address + 0x14);\n\t\t \n\t\tiowrite32(0x25, chip->pch_phub_base_address + 0x140);\n\t\tchip->pch_opt_rom_start_address =\\\n\t\t\t\t\t\t PCH_PHUB_ROM_START_ADDR_ML7223;\n\t\tchip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_ML7223;\n\t} else if (id->driver_data == 4) {  \n\t\tret = sysfs_create_file(&pdev->dev.kobj,\n\t\t\t\t\t&dev_attr_pch_mac.attr);\n\t\tif (ret)\n\t\t\tgoto err_sysfs_create;\n\t\tret = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);\n\t\tif (ret)\n\t\t\tgoto exit_bin_attr;\n\t\t \n\t\tiowrite32(0x0000ffa0, chip->pch_phub_base_address + 0x14);\n\t\tchip->pch_opt_rom_start_address =\\\n\t\t\t\t\t\t PCH_PHUB_ROM_START_ADDR_ML7223;\n\t\tchip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_ML7223;\n\t} else if (id->driver_data == 5) {  \n\t\tret = sysfs_create_file(&pdev->dev.kobj,\n\t\t\t\t\t&dev_attr_pch_mac.attr);\n\t\tif (ret)\n\t\t\tgoto err_sysfs_create;\n\n\t\tret = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);\n\t\tif (ret)\n\t\t\tgoto exit_bin_attr;\n\n\t\t \n\t\tiowrite32(0x000affaa, chip->pch_phub_base_address + 0x14);\n\t\t \n\t\tiowrite32(0x25, chip->pch_phub_base_address + 0x44);\n\t\tchip->pch_opt_rom_start_address = PCH_PHUB_ROM_START_ADDR_EG20T;\n\t\tchip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_EG20T;\n\t}\n\n\tchip->ioh_type = id->driver_data;\n\tpci_set_drvdata(pdev, chip);\n\n\treturn 0;\nexit_bin_attr:\n\tsysfs_remove_file(&pdev->dev.kobj, &dev_attr_pch_mac.attr);\n\nerr_sysfs_create:\n\tpci_iounmap(pdev, chip->pch_phub_base_address);\nerr_pci_iomap:\n\tpci_release_regions(pdev);\nerr_req_regions:\n\tpci_disable_device(pdev);\nerr_pci_enable_dev:\n\tkfree(chip);\n\tdev_err(&pdev->dev, \"%s returns %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic void pch_phub_remove(struct pci_dev *pdev)\n{\n\tstruct pch_phub_reg *chip = pci_get_drvdata(pdev);\n\n\tsysfs_remove_file(&pdev->dev.kobj, &dev_attr_pch_mac.attr);\n\tsysfs_remove_bin_file(&pdev->dev.kobj, &pch_bin_attr);\n\tpci_iounmap(pdev, chip->pch_phub_base_address);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tkfree(chip);\n}\n\nstatic int __maybe_unused pch_phub_suspend(struct device *dev_d)\n{\n\tdevice_wakeup_disable(dev_d);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pch_phub_resume(struct device *dev_d)\n{\n\tdevice_wakeup_disable(dev_d);\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id pch_phub_pcidev_id[] = {\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_PCH1_PHUB),       1,  },\n\t{ PCI_VDEVICE(ROHM, PCI_DEVICE_ID_ROHM_ML7213_PHUB), 2,  },\n\t{ PCI_VDEVICE(ROHM, PCI_DEVICE_ID_ROHM_ML7223_mPHUB), 3,  },\n\t{ PCI_VDEVICE(ROHM, PCI_DEVICE_ID_ROHM_ML7223_nPHUB), 4,  },\n\t{ PCI_VDEVICE(ROHM, PCI_DEVICE_ID_ROHM_ML7831_PHUB), 5,  },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, pch_phub_pcidev_id);\n\nstatic SIMPLE_DEV_PM_OPS(pch_phub_pm_ops, pch_phub_suspend, pch_phub_resume);\n\nstatic struct pci_driver pch_phub_driver = {\n\t.name = \"pch_phub\",\n\t.id_table = pch_phub_pcidev_id,\n\t.probe = pch_phub_probe,\n\t.remove = pch_phub_remove,\n\t.driver.pm = &pch_phub_pm_ops,\n};\n\nmodule_pci_driver(pch_phub_driver);\n\nMODULE_DESCRIPTION(\"Intel EG20T PCH/LAPIS Semiconductor IOH(ML7213/ML7223) PHUB\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}