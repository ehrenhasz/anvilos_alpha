{
  "module_name": "xilinx_tmr_manager.c",
  "hash_id": "262377d30b2d5b40c94743695693c42a827e0b0a7e26fce05784d29797cc6fdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/xilinx_tmr_manager.c",
  "human_readable_source": "\n \n\n#include <asm/xilinx_mb_manager.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n \n#define XTMR_MANAGER_CR_OFFSET\t\t0x0\n#define XTMR_MANAGER_FFR_OFFSET\t\t0x4\n#define XTMR_MANAGER_CMR0_OFFSET\t0x8\n#define XTMR_MANAGER_CMR1_OFFSET\t0xC\n#define XTMR_MANAGER_BDIR_OFFSET\t0x10\n#define XTMR_MANAGER_SEMIMR_OFFSET\t0x1C\n\n \n#define XTMR_MANAGER_CR_MAGIC1_MASK\tGENMASK(7, 0)\n#define XTMR_MANAGER_CR_MAGIC2_MASK\tGENMASK(15, 8)\n#define XTMR_MANAGER_CR_RIR_MASK\tBIT(16)\n#define XTMR_MANAGER_FFR_LM12_MASK\tBIT(0)\n#define XTMR_MANAGER_FFR_LM13_MASK\tBIT(1)\n#define XTMR_MANAGER_FFR_LM23_MASK\tBIT(2)\n\n#define XTMR_MANAGER_CR_MAGIC2_SHIFT\t4\n#define XTMR_MANAGER_CR_RIR_SHIFT\t16\n#define XTMR_MANAGER_CR_BB_SHIFT\t18\n\n#define XTMR_MANAGER_MAGIC1_MAX_VAL\t255\n\n \nstruct xtmr_manager_dev {\n\tvoid __iomem *regs;\n\tu32 cr_val;\n\tu32 magic1;\n\tu32 err_cnt;\n\tresource_size_t phys_baseaddr;\n};\n\n \nstatic inline void xtmr_manager_write(struct xtmr_manager_dev *xtmr_manager,\n\t\t\t\t      u32 addr, u32 value)\n{\n\tiowrite32(value, xtmr_manager->regs + addr);\n}\n\nstatic inline u32 xtmr_manager_read(struct xtmr_manager_dev *xtmr_manager,\n\t\t\t\t    u32 addr)\n{\n\treturn ioread32(xtmr_manager->regs + addr);\n}\n\nstatic void xmb_manager_reset_handler(struct xtmr_manager_dev *xtmr_manager)\n{\n\t \n\txtmr_manager_write(xtmr_manager, XTMR_MANAGER_FFR_OFFSET, 0);\n}\n\nstatic void xmb_manager_update_errcnt(struct xtmr_manager_dev *xtmr_manager)\n{\n\txtmr_manager->err_cnt++;\n}\n\nstatic ssize_t errcnt_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct xtmr_manager_dev *xtmr_manager = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%x\\n\", xtmr_manager->err_cnt);\n}\nstatic DEVICE_ATTR_RO(errcnt);\n\nstatic ssize_t dis_block_break_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t size)\n{\n\tstruct xtmr_manager_dev *xtmr_manager = dev_get_drvdata(dev);\n\tint ret;\n\tlong value;\n\n\tret = kstrtoul(buf, 16, &value);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\txtmr_manager->cr_val &= ~(1 << XTMR_MANAGER_CR_BB_SHIFT);\n\txtmr_manager_write(xtmr_manager, XTMR_MANAGER_CR_OFFSET,\n\t\t\t   xtmr_manager->cr_val);\n\treturn size;\n}\nstatic DEVICE_ATTR_WO(dis_block_break);\n\nstatic struct attribute *xtmr_manager_dev_attrs[] = {\n\t&dev_attr_dis_block_break.attr,\n\t&dev_attr_errcnt.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(xtmr_manager_dev);\n\nstatic void xtmr_manager_init(struct xtmr_manager_dev *xtmr_manager)\n{\n\t \n\txtmr_manager_write(xtmr_manager, XTMR_MANAGER_SEMIMR_OFFSET, 0);\n\n\t \n\txtmr_manager->cr_val = (1 << XTMR_MANAGER_CR_RIR_SHIFT) |\n\t\t\t\txtmr_manager->magic1;\n\txtmr_manager_write(xtmr_manager, XTMR_MANAGER_CR_OFFSET,\n\t\t\t   xtmr_manager->cr_val);\n\t \n\txtmr_manager_write(xtmr_manager, XTMR_MANAGER_BDIR_OFFSET, 0);\n\n\t \n\txtmr_manager->cr_val |= (1 << XTMR_MANAGER_CR_BB_SHIFT);\n\n\t \n\txmb_manager_register(xtmr_manager->phys_baseaddr, xtmr_manager->cr_val,\n\t\t\t     (void *)xmb_manager_update_errcnt,\n\t\t\t     xtmr_manager, (void *)xmb_manager_reset_handler);\n}\n\n \nstatic int xtmr_manager_probe(struct platform_device *pdev)\n{\n\tstruct xtmr_manager_dev *xtmr_manager;\n\tstruct resource *res;\n\tint err;\n\n\txtmr_manager = devm_kzalloc(&pdev->dev, sizeof(*xtmr_manager),\n\t\t\t\t    GFP_KERNEL);\n\tif (!xtmr_manager)\n\t\treturn -ENOMEM;\n\n\txtmr_manager->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(xtmr_manager->regs))\n\t\treturn PTR_ERR(xtmr_manager->regs);\n\n\txtmr_manager->phys_baseaddr = res->start;\n\n\terr = of_property_read_u32(pdev->dev.of_node, \"xlnx,magic1\",\n\t\t\t\t   &xtmr_manager->magic1);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"unable to read xlnx,magic1 property\");\n\t\treturn err;\n\t}\n\n\tif (xtmr_manager->magic1 > XTMR_MANAGER_MAGIC1_MAX_VAL) {\n\t\tdev_err(&pdev->dev, \"invalid xlnx,magic1 property value\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\txtmr_manager_init(xtmr_manager);\n\n\tplatform_set_drvdata(pdev, xtmr_manager);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id xtmr_manager_of_match[] = {\n\t{\n\t\t.compatible = \"xlnx,tmr-manager-1.0\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, xtmr_manager_of_match);\n\nstatic struct platform_driver xtmr_manager_driver = {\n\t.driver = {\n\t\t.name = \"xilinx-tmr_manager\",\n\t\t.of_match_table = xtmr_manager_of_match,\n\t\t.dev_groups = xtmr_manager_dev_groups,\n\t},\n\t.probe = xtmr_manager_probe,\n};\nmodule_platform_driver(xtmr_manager_driver);\n\nMODULE_AUTHOR(\"Advanced Micro Devices, Inc\");\nMODULE_DESCRIPTION(\"Xilinx TMR Manager Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}