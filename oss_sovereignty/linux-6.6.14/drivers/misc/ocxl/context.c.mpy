{
  "module_name": "context.c",
  "hash_id": "780d244c8090079b652d4b7973fbf471c68dfd8dae7936db9c1aa98f718ca339",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ocxl/context.c",
  "human_readable_source": "\n\n#include <linux/sched/mm.h>\n#include \"trace.h\"\n#include \"ocxl_internal.h\"\n\nint ocxl_context_alloc(struct ocxl_context **context, struct ocxl_afu *afu,\n\t\tstruct address_space *mapping)\n{\n\tint pasid;\n\tstruct ocxl_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->afu = afu;\n\tmutex_lock(&afu->contexts_lock);\n\tpasid = idr_alloc(&afu->contexts_idr, ctx, afu->pasid_base,\n\t\t\tafu->pasid_base + afu->pasid_max, GFP_KERNEL);\n\tif (pasid < 0) {\n\t\tmutex_unlock(&afu->contexts_lock);\n\t\tkfree(ctx);\n\t\treturn pasid;\n\t}\n\tafu->pasid_count++;\n\tmutex_unlock(&afu->contexts_lock);\n\n\tctx->pasid = pasid;\n\tctx->status = OPENED;\n\tmutex_init(&ctx->status_mutex);\n\tctx->mapping = mapping;\n\tmutex_init(&ctx->mapping_lock);\n\tinit_waitqueue_head(&ctx->events_wq);\n\tmutex_init(&ctx->xsl_error_lock);\n\tmutex_init(&ctx->irq_lock);\n\tidr_init(&ctx->irq_idr);\n\tctx->tidr = 0;\n\n\t \n\tocxl_afu_get(afu);\n\t*context = ctx;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocxl_context_alloc);\n\n \nstatic void xsl_fault_error(void *data, u64 addr, u64 dsisr)\n{\n\tstruct ocxl_context *ctx = (struct ocxl_context *) data;\n\n\tmutex_lock(&ctx->xsl_error_lock);\n\tctx->xsl_error.addr = addr;\n\tctx->xsl_error.dsisr = dsisr;\n\tctx->xsl_error.count++;\n\tmutex_unlock(&ctx->xsl_error_lock);\n\n\twake_up_all(&ctx->events_wq);\n}\n\nint ocxl_context_attach(struct ocxl_context *ctx, u64 amr, struct mm_struct *mm)\n{\n\tint rc;\n\tunsigned long pidr = 0;\n\tstruct pci_dev *dev;\n\n\t \n\tmutex_lock(&ctx->status_mutex);\n\tif (ctx->status != OPENED) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (mm)\n\t\tpidr = mm->context.id;\n\n\tdev = to_pci_dev(ctx->afu->fn->dev.parent);\n\trc = ocxl_link_add_pe(ctx->afu->fn->link, ctx->pasid, pidr, ctx->tidr,\n\t\t\t      amr, pci_dev_id(dev), mm, xsl_fault_error, ctx);\n\tif (rc)\n\t\tgoto out;\n\n\tctx->status = ATTACHED;\nout:\n\tmutex_unlock(&ctx->status_mutex);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ocxl_context_attach);\n\nstatic vm_fault_t map_afu_irq(struct vm_area_struct *vma, unsigned long address,\n\t\tu64 offset, struct ocxl_context *ctx)\n{\n\tu64 trigger_addr;\n\tint irq_id = ocxl_irq_offset_to_id(ctx, offset);\n\n\ttrigger_addr = ocxl_afu_irq_get_addr(ctx, irq_id);\n\tif (!trigger_addr)\n\t\treturn VM_FAULT_SIGBUS;\n\n\treturn vmf_insert_pfn(vma, address, trigger_addr >> PAGE_SHIFT);\n}\n\nstatic vm_fault_t map_pp_mmio(struct vm_area_struct *vma, unsigned long address,\n\t\tu64 offset, struct ocxl_context *ctx)\n{\n\tu64 pp_mmio_addr;\n\tint pasid_off;\n\tvm_fault_t ret;\n\n\tif (offset >= ctx->afu->config.pp_mmio_stride)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tmutex_lock(&ctx->status_mutex);\n\tif (ctx->status != ATTACHED) {\n\t\tmutex_unlock(&ctx->status_mutex);\n\t\tpr_debug(\"%s: Context not attached, failing mmio mmap\\n\",\n\t\t\t__func__);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tpasid_off = ctx->pasid - ctx->afu->pasid_base;\n\tpp_mmio_addr = ctx->afu->pp_mmio_start +\n\t\tpasid_off * ctx->afu->config.pp_mmio_stride +\n\t\toffset;\n\n\tret = vmf_insert_pfn(vma, address, pp_mmio_addr >> PAGE_SHIFT);\n\tmutex_unlock(&ctx->status_mutex);\n\treturn ret;\n}\n\nstatic vm_fault_t ocxl_mmap_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct ocxl_context *ctx = vma->vm_file->private_data;\n\tu64 offset;\n\tvm_fault_t ret;\n\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tpr_debug(\"%s: pasid %d address 0x%lx offset 0x%llx\\n\", __func__,\n\t\tctx->pasid, vmf->address, offset);\n\n\tif (offset < ctx->afu->irq_base_offset)\n\t\tret = map_pp_mmio(vma, vmf->address, offset, ctx);\n\telse\n\t\tret = map_afu_irq(vma, vmf->address, offset, ctx);\n\treturn ret;\n}\n\nstatic const struct vm_operations_struct ocxl_vmops = {\n\t.fault = ocxl_mmap_fault,\n};\n\nstatic int check_mmap_afu_irq(struct ocxl_context *ctx,\n\t\t\tstruct vm_area_struct *vma)\n{\n\tint irq_id = ocxl_irq_offset_to_id(ctx, vma->vm_pgoff << PAGE_SHIFT);\n\n\t \n\tif (vma_pages(vma) != 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (!ocxl_afu_irq_get_addr(ctx, irq_id))\n\t\treturn -EINVAL;\n\n\t \n\tif ((vma->vm_flags & VM_READ) || (vma->vm_flags & VM_EXEC) ||\n\t\t!(vma->vm_flags & VM_WRITE))\n\t\treturn -EINVAL;\n\tvm_flags_clear(vma, VM_MAYREAD | VM_MAYEXEC);\n\treturn 0;\n}\n\nstatic int check_mmap_mmio(struct ocxl_context *ctx,\n\t\t\tstruct vm_area_struct *vma)\n{\n\tif ((vma_pages(vma) + vma->vm_pgoff) >\n\t\t(ctx->afu->config.pp_mmio_stride >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint ocxl_context_mmap(struct ocxl_context *ctx, struct vm_area_struct *vma)\n{\n\tint rc;\n\n\tif ((vma->vm_pgoff << PAGE_SHIFT) < ctx->afu->irq_base_offset)\n\t\trc = check_mmap_mmio(ctx, vma);\n\telse\n\t\trc = check_mmap_afu_irq(ctx, vma);\n\tif (rc)\n\t\treturn rc;\n\n\tvm_flags_set(vma, VM_IO | VM_PFNMAP);\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tvma->vm_ops = &ocxl_vmops;\n\treturn 0;\n}\n\nint ocxl_context_detach(struct ocxl_context *ctx)\n{\n\tstruct pci_dev *dev;\n\tint afu_control_pos;\n\tenum ocxl_context_status status;\n\tint rc;\n\n\tmutex_lock(&ctx->status_mutex);\n\tstatus = ctx->status;\n\tctx->status = CLOSED;\n\tmutex_unlock(&ctx->status_mutex);\n\tif (status != ATTACHED)\n\t\treturn 0;\n\n\tdev = to_pci_dev(ctx->afu->fn->dev.parent);\n\tafu_control_pos = ctx->afu->config.dvsec_afu_control_pos;\n\n\tmutex_lock(&ctx->afu->afu_control_lock);\n\trc = ocxl_config_terminate_pasid(dev, afu_control_pos, ctx->pasid);\n\tmutex_unlock(&ctx->afu->afu_control_lock);\n\ttrace_ocxl_terminate_pasid(ctx->pasid, rc);\n\tif (rc) {\n\t\t \n\t\tif (rc == -EBUSY)\n\t\t\treturn rc;\n\t}\n\trc = ocxl_link_remove_pe(ctx->afu->fn->link, ctx->pasid);\n\tif (rc) {\n\t\tdev_warn(&dev->dev,\n\t\t\t\"Couldn't remove PE entry cleanly: %d\\n\", rc);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocxl_context_detach);\n\nvoid ocxl_context_detach_all(struct ocxl_afu *afu)\n{\n\tstruct ocxl_context *ctx;\n\tint tmp;\n\n\tmutex_lock(&afu->contexts_lock);\n\tidr_for_each_entry(&afu->contexts_idr, ctx, tmp) {\n\t\tocxl_context_detach(ctx);\n\t\t \n\t\tmutex_lock(&ctx->mapping_lock);\n\t\tif (ctx->mapping)\n\t\t\tunmap_mapping_range(ctx->mapping, 0, 0, 1);\n\t\tmutex_unlock(&ctx->mapping_lock);\n\t}\n\tmutex_unlock(&afu->contexts_lock);\n}\n\nvoid ocxl_context_free(struct ocxl_context *ctx)\n{\n\tmutex_lock(&ctx->afu->contexts_lock);\n\tctx->afu->pasid_count--;\n\tidr_remove(&ctx->afu->contexts_idr, ctx->pasid);\n\tmutex_unlock(&ctx->afu->contexts_lock);\n\n\tocxl_afu_irq_free_all(ctx);\n\tidr_destroy(&ctx->irq_idr);\n\t \n\tocxl_afu_put(ctx->afu);\n\tkfree(ctx);\n}\nEXPORT_SYMBOL_GPL(ocxl_context_free);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}