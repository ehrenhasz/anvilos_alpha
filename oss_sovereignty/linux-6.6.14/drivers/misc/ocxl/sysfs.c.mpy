{
  "module_name": "sysfs.c",
  "hash_id": "cf8aab51291e926b6426ad635b876de00d0b53005193d9ac10b17b958eb0d0ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ocxl/sysfs.c",
  "human_readable_source": "\n\n#include <linux/sysfs.h>\n#include \"ocxl_internal.h\"\n\nstatic inline struct ocxl_afu *to_afu(struct device *device)\n{\n\tstruct ocxl_file_info *info = container_of(device, struct ocxl_file_info, dev);\n\n\treturn info->afu;\n}\n\nstatic ssize_t global_mmio_size_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct ocxl_afu *afu = to_afu(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tafu->config.global_mmio_size);\n}\n\nstatic ssize_t pp_mmio_size_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct ocxl_afu *afu = to_afu(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tafu->config.pp_mmio_stride);\n}\n\nstatic ssize_t afu_version_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct ocxl_afu *afu = to_afu(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%hhu:%hhu\\n\",\n\t\t\tafu->config.version_major,\n\t\t\tafu->config.version_minor);\n}\n\nstatic ssize_t contexts_show(struct device *device,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct ocxl_afu *afu = to_afu(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d/%d\\n\",\n\t\t\tafu->pasid_count, afu->pasid_max);\n}\n\nstatic ssize_t reload_on_reset_show(struct device *device,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct ocxl_afu *afu = to_afu(device);\n\tstruct ocxl_fn *fn = afu->fn;\n\tstruct pci_dev *pci_dev = to_pci_dev(fn->dev.parent);\n\tint val;\n\n\tif (ocxl_config_get_reset_reload(pci_dev, &val))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"unavailable\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", val);\n}\n\nstatic ssize_t reload_on_reset_store(struct device *device,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ocxl_afu *afu = to_afu(device);\n\tstruct ocxl_fn *fn = afu->fn;\n\tstruct pci_dev *pci_dev = to_pci_dev(fn->dev.parent);\n\tint rc, val;\n\n\trc = kstrtoint(buf, 0, &val);\n\tif (rc || (val != 0 && val != 1))\n\t\treturn -EINVAL;\n\n\tif (ocxl_config_set_reset_reload(pci_dev, val))\n\t\treturn -ENODEV;\n\n\treturn count;\n}\n\nstatic struct device_attribute afu_attrs[] = {\n\t__ATTR_RO(global_mmio_size),\n\t__ATTR_RO(pp_mmio_size),\n\t__ATTR_RO(afu_version),\n\t__ATTR_RO(contexts),\n\t__ATTR_RW(reload_on_reset),\n};\n\nstatic ssize_t global_mmio_read(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr, char *buf,\n\t\t\t\tloff_t off, size_t count)\n{\n\tstruct ocxl_afu *afu = to_afu(kobj_to_dev(kobj));\n\n\tif (count == 0 || off < 0 ||\n\t\toff >= afu->config.global_mmio_size)\n\t\treturn 0;\n\tmemcpy_fromio(buf, afu->global_mmio_ptr + off, count);\n\treturn count;\n}\n\nstatic vm_fault_t global_mmio_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct ocxl_afu *afu = vma->vm_private_data;\n\tunsigned long offset;\n\n\tif (vmf->pgoff >= (afu->config.global_mmio_size >> PAGE_SHIFT))\n\t\treturn VM_FAULT_SIGBUS;\n\n\toffset = vmf->pgoff;\n\toffset += (afu->global_mmio_start >> PAGE_SHIFT);\n\treturn vmf_insert_pfn(vma, vmf->address, offset);\n}\n\nstatic const struct vm_operations_struct global_mmio_vmops = {\n\t.fault = global_mmio_fault,\n};\n\nstatic int global_mmio_mmap(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *bin_attr,\n\t\t\tstruct vm_area_struct *vma)\n{\n\tstruct ocxl_afu *afu = to_afu(kobj_to_dev(kobj));\n\n\tif ((vma_pages(vma) + vma->vm_pgoff) >\n\t\t(afu->config.global_mmio_size >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\tvm_flags_set(vma, VM_IO | VM_PFNMAP);\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tvma->vm_ops = &global_mmio_vmops;\n\tvma->vm_private_data = afu;\n\treturn 0;\n}\n\nint ocxl_sysfs_register_afu(struct ocxl_file_info *info)\n{\n\tint i, rc;\n\n\tfor (i = 0; i < ARRAY_SIZE(afu_attrs); i++) {\n\t\trc = device_create_file(&info->dev, &afu_attrs[i]);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\tsysfs_attr_init(&info->attr_global_mmio.attr);\n\tinfo->attr_global_mmio.attr.name = \"global_mmio_area\";\n\tinfo->attr_global_mmio.attr.mode = 0600;\n\tinfo->attr_global_mmio.size = info->afu->config.global_mmio_size;\n\tinfo->attr_global_mmio.read = global_mmio_read;\n\tinfo->attr_global_mmio.mmap = global_mmio_mmap;\n\trc = device_create_bin_file(&info->dev, &info->attr_global_mmio);\n\tif (rc) {\n\t\tdev_err(&info->dev, \"Unable to create global mmio attr for afu: %d\\n\", rc);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i--; i >= 0; i--)\n\t\tdevice_remove_file(&info->dev, &afu_attrs[i]);\n\n\treturn rc;\n}\n\nvoid ocxl_sysfs_unregister_afu(struct ocxl_file_info *info)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(afu_attrs); i++)\n\t\tdevice_remove_file(&info->dev, &afu_attrs[i]);\n\tdevice_remove_bin_file(&info->dev, &info->attr_global_mmio);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}