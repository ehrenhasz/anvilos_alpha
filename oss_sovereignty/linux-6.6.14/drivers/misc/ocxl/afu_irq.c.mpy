{
  "module_name": "afu_irq.c",
  "hash_id": "6959dd1f478c3b1bc0ee4b732b0719133e5b0864279afdfe19fc6ffd4c81028b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ocxl/afu_irq.c",
  "human_readable_source": "\n\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <asm/pnv-ocxl.h>\n#include <asm/xive.h>\n#include \"ocxl_internal.h\"\n#include \"trace.h\"\n\nstruct afu_irq {\n\tint id;\n\tint hw_irq;\n\tunsigned int virq;\n\tchar *name;\n\tirqreturn_t (*handler)(void *private);\n\tvoid (*free_private)(void *private);\n\tvoid *private;\n};\n\nint ocxl_irq_offset_to_id(struct ocxl_context *ctx, u64 offset)\n{\n\treturn (offset - ctx->afu->irq_base_offset) >> PAGE_SHIFT;\n}\n\nu64 ocxl_irq_id_to_offset(struct ocxl_context *ctx, int irq_id)\n{\n\treturn ctx->afu->irq_base_offset + (irq_id << PAGE_SHIFT);\n}\n\nint ocxl_irq_set_handler(struct ocxl_context *ctx, int irq_id,\n\t\tirqreturn_t (*handler)(void *private),\n\t\tvoid (*free_private)(void *private),\n\t\tvoid *private)\n{\n\tstruct afu_irq *irq;\n\tint rc;\n\n\tmutex_lock(&ctx->irq_lock);\n\tirq = idr_find(&ctx->irq_idr, irq_id);\n\tif (!irq) {\n\t\trc = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tirq->handler = handler;\n\tirq->private = private;\n\tirq->free_private = free_private;\n\n\trc = 0;\n\t\n\nunlock:\n\tmutex_unlock(&ctx->irq_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ocxl_irq_set_handler);\n\nstatic irqreturn_t afu_irq_handler(int virq, void *data)\n{\n\tstruct afu_irq *irq = (struct afu_irq *) data;\n\n\ttrace_ocxl_afu_irq_receive(virq);\n\n\tif (irq->handler)\n\t\treturn irq->handler(irq->private);\n\n\treturn IRQ_HANDLED; \n}\n\nstatic int setup_afu_irq(struct ocxl_context *ctx, struct afu_irq *irq)\n{\n\tint rc;\n\n\tirq->virq = irq_create_mapping(NULL, irq->hw_irq);\n\tif (!irq->virq) {\n\t\tpr_err(\"irq_create_mapping failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpr_debug(\"hw_irq %d mapped to virq %u\\n\", irq->hw_irq, irq->virq);\n\n\tirq->name = kasprintf(GFP_KERNEL, \"ocxl-afu-%u\", irq->virq);\n\tif (!irq->name) {\n\t\tirq_dispose_mapping(irq->virq);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = request_irq(irq->virq, afu_irq_handler, 0, irq->name, irq);\n\tif (rc) {\n\t\tkfree(irq->name);\n\t\tirq->name = NULL;\n\t\tirq_dispose_mapping(irq->virq);\n\t\tpr_err(\"request_irq failed: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void release_afu_irq(struct afu_irq *irq)\n{\n\tfree_irq(irq->virq, irq);\n\tirq_dispose_mapping(irq->virq);\n\tkfree(irq->name);\n}\n\nint ocxl_afu_irq_alloc(struct ocxl_context *ctx, int *irq_id)\n{\n\tstruct afu_irq *irq;\n\tint rc;\n\n\tirq = kzalloc(sizeof(struct afu_irq), GFP_KERNEL);\n\tif (!irq)\n\t\treturn -ENOMEM;\n\n\t \n\n\tmutex_lock(&ctx->irq_lock);\n\n\tirq->id = idr_alloc(&ctx->irq_idr, irq, 0, MAX_IRQ_PER_CONTEXT,\n\t\t\tGFP_KERNEL);\n\tif (irq->id < 0) {\n\t\trc = -ENOSPC;\n\t\tgoto err_unlock;\n\t}\n\n\trc = ocxl_link_irq_alloc(ctx->afu->fn->link, &irq->hw_irq);\n\tif (rc)\n\t\tgoto err_idr;\n\n\trc = setup_afu_irq(ctx, irq);\n\tif (rc)\n\t\tgoto err_alloc;\n\n\ttrace_ocxl_afu_irq_alloc(ctx->pasid, irq->id, irq->virq, irq->hw_irq);\n\tmutex_unlock(&ctx->irq_lock);\n\n\t*irq_id = irq->id;\n\n\treturn 0;\n\nerr_alloc:\n\tocxl_link_free_irq(ctx->afu->fn->link, irq->hw_irq);\nerr_idr:\n\tidr_remove(&ctx->irq_idr, irq->id);\nerr_unlock:\n\tmutex_unlock(&ctx->irq_lock);\n\tkfree(irq);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ocxl_afu_irq_alloc);\n\nstatic void afu_irq_free(struct afu_irq *irq, struct ocxl_context *ctx)\n{\n\ttrace_ocxl_afu_irq_free(ctx->pasid, irq->id);\n\tif (ctx->mapping)\n\t\tunmap_mapping_range(ctx->mapping,\n\t\t\t\tocxl_irq_id_to_offset(ctx, irq->id),\n\t\t\t\t1 << PAGE_SHIFT, 1);\n\trelease_afu_irq(irq);\n\tif (irq->free_private)\n\t\tirq->free_private(irq->private);\n\tocxl_link_free_irq(ctx->afu->fn->link, irq->hw_irq);\n\tkfree(irq);\n}\n\nint ocxl_afu_irq_free(struct ocxl_context *ctx, int irq_id)\n{\n\tstruct afu_irq *irq;\n\n\tmutex_lock(&ctx->irq_lock);\n\n\tirq = idr_find(&ctx->irq_idr, irq_id);\n\tif (!irq) {\n\t\tmutex_unlock(&ctx->irq_lock);\n\t\treturn -EINVAL;\n\t}\n\tidr_remove(&ctx->irq_idr, irq->id);\n\tafu_irq_free(irq, ctx);\n\tmutex_unlock(&ctx->irq_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocxl_afu_irq_free);\n\nvoid ocxl_afu_irq_free_all(struct ocxl_context *ctx)\n{\n\tstruct afu_irq *irq;\n\tint id;\n\n\tmutex_lock(&ctx->irq_lock);\n\tidr_for_each_entry(&ctx->irq_idr, irq, id)\n\t\tafu_irq_free(irq, ctx);\n\tmutex_unlock(&ctx->irq_lock);\n}\n\nu64 ocxl_afu_irq_get_addr(struct ocxl_context *ctx, int irq_id)\n{\n\tstruct xive_irq_data *xd;\n\tstruct afu_irq *irq;\n\tu64 addr = 0;\n\n\tmutex_lock(&ctx->irq_lock);\n\tirq = idr_find(&ctx->irq_idr, irq_id);\n\tif (irq) {\n\t\txd = irq_get_handler_data(irq->virq);\n\t\taddr = xd ? xd->trig_page : 0;\n\t}\n\tmutex_unlock(&ctx->irq_lock);\n\treturn addr;\n}\nEXPORT_SYMBOL_GPL(ocxl_afu_irq_get_addr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}