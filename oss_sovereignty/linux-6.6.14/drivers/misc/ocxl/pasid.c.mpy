{
  "module_name": "pasid.c",
  "hash_id": "7426ccb7ee5f035a56860718393637054055c9a560107f629034f25f626823c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ocxl/pasid.c",
  "human_readable_source": "\n\n#include \"ocxl_internal.h\"\n\n\nstruct id_range {\n\tstruct list_head list;\n\tu32 start;\n\tu32 end;\n};\n\n#ifdef DEBUG\nstatic void dump_list(struct list_head *head, char *type_str)\n{\n\tstruct id_range *cur;\n\n\tpr_debug(\"%s ranges allocated:\\n\", type_str);\n\tlist_for_each_entry(cur, head, list) {\n\t\tpr_debug(\"Range %d->%d\\n\", cur->start, cur->end);\n\t}\n}\n#endif\n\nstatic int range_alloc(struct list_head *head, u32 size, int max_id,\n\t\tchar *type_str)\n{\n\tstruct list_head *pos;\n\tstruct id_range *cur, *new;\n\tint rc, last_end;\n\n\tnew = kmalloc(sizeof(struct id_range), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tpos = head;\n\tlast_end = -1;\n\tlist_for_each_entry(cur, head, list) {\n\t\tif ((cur->start - last_end) > size)\n\t\t\tbreak;\n\t\tlast_end = cur->end;\n\t\tpos = &cur->list;\n\t}\n\n\tnew->start = last_end + 1;\n\tnew->end = new->start + size - 1;\n\n\tif (new->end > max_id) {\n\t\tkfree(new);\n\t\trc = -ENOSPC;\n\t} else {\n\t\tlist_add(&new->list, pos);\n\t\trc = new->start;\n\t}\n\n#ifdef DEBUG\n\tdump_list(head, type_str);\n#endif\n\treturn rc;\n}\n\nstatic void range_free(struct list_head *head, u32 start, u32 size,\n\t\tchar *type_str)\n{\n\tbool found = false;\n\tstruct id_range *cur, *tmp;\n\n\tlist_for_each_entry_safe(cur, tmp, head, list) {\n\t\tif (cur->start == start && cur->end == (start + size - 1)) {\n\t\t\tfound = true;\n\t\t\tlist_del(&cur->list);\n\t\t\tkfree(cur);\n\t\t\tbreak;\n\t\t}\n\t}\n\tWARN_ON(!found);\n#ifdef DEBUG\n\tdump_list(head, type_str);\n#endif\n}\n\nint ocxl_pasid_afu_alloc(struct ocxl_fn *fn, u32 size)\n{\n\tint max_pasid;\n\n\tif (fn->config.max_pasid_log < 0)\n\t\treturn -ENOSPC;\n\tmax_pasid = 1 << fn->config.max_pasid_log;\n\treturn range_alloc(&fn->pasid_list, size, max_pasid, \"afu pasid\");\n}\n\nvoid ocxl_pasid_afu_free(struct ocxl_fn *fn, u32 start, u32 size)\n{\n\treturn range_free(&fn->pasid_list, start, size, \"afu pasid\");\n}\n\nint ocxl_actag_afu_alloc(struct ocxl_fn *fn, u32 size)\n{\n\tint max_actag;\n\n\tmax_actag = fn->actag_enabled;\n\treturn range_alloc(&fn->actag_list, size, max_actag, \"afu actag\");\n}\n\nvoid ocxl_actag_afu_free(struct ocxl_fn *fn, u32 start, u32 size)\n{\n\treturn range_free(&fn->actag_list, start, size, \"afu actag\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}