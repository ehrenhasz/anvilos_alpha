{
  "module_name": "core.c",
  "hash_id": "28e25a43b03d86b200bc9dab129c80256ac5880118e47ea15118edd3bcfe281e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ocxl/core.c",
  "human_readable_source": "\n\n#include <linux/idr.h>\n#include \"ocxl_internal.h\"\n\nstatic struct ocxl_fn *ocxl_fn_get(struct ocxl_fn *fn)\n{\n\treturn (get_device(&fn->dev) == NULL) ? NULL : fn;\n}\n\nstatic void ocxl_fn_put(struct ocxl_fn *fn)\n{\n\tput_device(&fn->dev);\n}\n\nstatic struct ocxl_afu *alloc_afu(struct ocxl_fn *fn)\n{\n\tstruct ocxl_afu *afu;\n\n\tafu = kzalloc(sizeof(struct ocxl_afu), GFP_KERNEL);\n\tif (!afu)\n\t\treturn NULL;\n\n\tkref_init(&afu->kref);\n\tmutex_init(&afu->contexts_lock);\n\tmutex_init(&afu->afu_control_lock);\n\tidr_init(&afu->contexts_idr);\n\tafu->fn = fn;\n\tocxl_fn_get(fn);\n\treturn afu;\n}\n\nstatic void free_afu(struct kref *kref)\n{\n\tstruct ocxl_afu *afu = container_of(kref, struct ocxl_afu, kref);\n\n\tidr_destroy(&afu->contexts_idr);\n\tocxl_fn_put(afu->fn);\n\tkfree(afu);\n}\n\nvoid ocxl_afu_get(struct ocxl_afu *afu)\n{\n\tkref_get(&afu->kref);\n}\nEXPORT_SYMBOL_GPL(ocxl_afu_get);\n\nvoid ocxl_afu_put(struct ocxl_afu *afu)\n{\n\tkref_put(&afu->kref, free_afu);\n}\nEXPORT_SYMBOL_GPL(ocxl_afu_put);\n\nstatic int assign_afu_actag(struct ocxl_afu *afu)\n{\n\tstruct ocxl_fn *fn = afu->fn;\n\tint actag_count, actag_offset;\n\tstruct pci_dev *pci_dev = to_pci_dev(fn->dev.parent);\n\n\t \n\tactag_count = afu->config.actag_supported *\n\t\tfn->actag_enabled / fn->actag_supported;\n\tactag_offset = ocxl_actag_afu_alloc(fn, actag_count);\n\tif (actag_offset < 0) {\n\t\tdev_err(&pci_dev->dev, \"Can't allocate %d actags for AFU: %d\\n\",\n\t\t\tactag_count, actag_offset);\n\t\treturn actag_offset;\n\t}\n\tafu->actag_base = fn->actag_base + actag_offset;\n\tafu->actag_enabled = actag_count;\n\n\tocxl_config_set_afu_actag(pci_dev, afu->config.dvsec_afu_control_pos,\n\t\t\t\tafu->actag_base, afu->actag_enabled);\n\tdev_dbg(&pci_dev->dev, \"actag base=%d enabled=%d\\n\",\n\t\tafu->actag_base, afu->actag_enabled);\n\treturn 0;\n}\n\nstatic void reclaim_afu_actag(struct ocxl_afu *afu)\n{\n\tstruct ocxl_fn *fn = afu->fn;\n\tint start_offset, size;\n\n\tstart_offset = afu->actag_base - fn->actag_base;\n\tsize = afu->actag_enabled;\n\tocxl_actag_afu_free(afu->fn, start_offset, size);\n}\n\nstatic int assign_afu_pasid(struct ocxl_afu *afu)\n{\n\tstruct ocxl_fn *fn = afu->fn;\n\tint pasid_count, pasid_offset;\n\tstruct pci_dev *pci_dev = to_pci_dev(fn->dev.parent);\n\n\t \n\tpasid_count = 1 << afu->config.pasid_supported_log;\n\tpasid_offset = ocxl_pasid_afu_alloc(fn, pasid_count);\n\tif (pasid_offset < 0) {\n\t\tdev_err(&pci_dev->dev, \"Can't allocate %d PASIDs for AFU: %d\\n\",\n\t\t\tpasid_count, pasid_offset);\n\t\treturn pasid_offset;\n\t}\n\tafu->pasid_base = fn->pasid_base + pasid_offset;\n\tafu->pasid_count = 0;\n\tafu->pasid_max = pasid_count;\n\n\tocxl_config_set_afu_pasid(pci_dev, afu->config.dvsec_afu_control_pos,\n\t\t\t\tafu->pasid_base,\n\t\t\t\tafu->config.pasid_supported_log);\n\tdev_dbg(&pci_dev->dev, \"PASID base=%d, enabled=%d\\n\",\n\t\tafu->pasid_base, pasid_count);\n\treturn 0;\n}\n\nstatic void reclaim_afu_pasid(struct ocxl_afu *afu)\n{\n\tstruct ocxl_fn *fn = afu->fn;\n\tint start_offset, size;\n\n\tstart_offset = afu->pasid_base - fn->pasid_base;\n\tsize = 1 << afu->config.pasid_supported_log;\n\tocxl_pasid_afu_free(afu->fn, start_offset, size);\n}\n\nstatic int reserve_fn_bar(struct ocxl_fn *fn, int bar)\n{\n\tstruct pci_dev *dev = to_pci_dev(fn->dev.parent);\n\tint rc, idx;\n\n\tif (bar != 0 && bar != 2 && bar != 4)\n\t\treturn -EINVAL;\n\n\tidx = bar >> 1;\n\tif (fn->bar_used[idx]++ == 0) {\n\t\trc = pci_request_region(dev, bar, \"ocxl\");\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void release_fn_bar(struct ocxl_fn *fn, int bar)\n{\n\tstruct pci_dev *dev = to_pci_dev(fn->dev.parent);\n\tint idx;\n\n\tif (bar != 0 && bar != 2 && bar != 4)\n\t\treturn;\n\n\tidx = bar >> 1;\n\tif (--fn->bar_used[idx] == 0)\n\t\tpci_release_region(dev, bar);\n\tWARN_ON(fn->bar_used[idx] < 0);\n}\n\nstatic int map_mmio_areas(struct ocxl_afu *afu)\n{\n\tint rc;\n\tstruct pci_dev *pci_dev = to_pci_dev(afu->fn->dev.parent);\n\n\trc = reserve_fn_bar(afu->fn, afu->config.global_mmio_bar);\n\tif (rc)\n\t\treturn rc;\n\n\trc = reserve_fn_bar(afu->fn, afu->config.pp_mmio_bar);\n\tif (rc) {\n\t\trelease_fn_bar(afu->fn, afu->config.global_mmio_bar);\n\t\treturn rc;\n\t}\n\n\tafu->global_mmio_start =\n\t\tpci_resource_start(pci_dev, afu->config.global_mmio_bar) +\n\t\tafu->config.global_mmio_offset;\n\tafu->pp_mmio_start =\n\t\tpci_resource_start(pci_dev, afu->config.pp_mmio_bar) +\n\t\tafu->config.pp_mmio_offset;\n\n\tafu->global_mmio_ptr = ioremap(afu->global_mmio_start,\n\t\t\t\tafu->config.global_mmio_size);\n\tif (!afu->global_mmio_ptr) {\n\t\trelease_fn_bar(afu->fn, afu->config.pp_mmio_bar);\n\t\trelease_fn_bar(afu->fn, afu->config.global_mmio_bar);\n\t\tdev_err(&pci_dev->dev, \"Error mapping global mmio area\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tafu->irq_base_offset = afu->config.pp_mmio_stride + PAGE_SIZE;\n\treturn 0;\n}\n\nstatic void unmap_mmio_areas(struct ocxl_afu *afu)\n{\n\tif (afu->global_mmio_ptr) {\n\t\tiounmap(afu->global_mmio_ptr);\n\t\tafu->global_mmio_ptr = NULL;\n\t}\n\tafu->global_mmio_start = 0;\n\tafu->pp_mmio_start = 0;\n\trelease_fn_bar(afu->fn, afu->config.pp_mmio_bar);\n\trelease_fn_bar(afu->fn, afu->config.global_mmio_bar);\n}\n\nstatic int configure_afu(struct ocxl_afu *afu, u8 afu_idx, struct pci_dev *dev)\n{\n\tint rc;\n\n\trc = ocxl_config_read_afu(dev, &afu->fn->config, &afu->config, afu_idx);\n\tif (rc)\n\t\treturn rc;\n\n\trc = assign_afu_actag(afu);\n\tif (rc)\n\t\treturn rc;\n\n\trc = assign_afu_pasid(afu);\n\tif (rc)\n\t\tgoto err_free_actag;\n\n\trc = map_mmio_areas(afu);\n\tif (rc)\n\t\tgoto err_free_pasid;\n\n\treturn 0;\n\nerr_free_pasid:\n\treclaim_afu_pasid(afu);\nerr_free_actag:\n\treclaim_afu_actag(afu);\n\treturn rc;\n}\n\nstatic void deconfigure_afu(struct ocxl_afu *afu)\n{\n\tunmap_mmio_areas(afu);\n\treclaim_afu_pasid(afu);\n\treclaim_afu_actag(afu);\n}\n\nstatic int activate_afu(struct pci_dev *dev, struct ocxl_afu *afu)\n{\n\tocxl_config_set_afu_state(dev, afu->config.dvsec_afu_control_pos, 1);\n\n\treturn 0;\n}\n\nstatic void deactivate_afu(struct ocxl_afu *afu)\n{\n\tstruct pci_dev *dev = to_pci_dev(afu->fn->dev.parent);\n\n\tocxl_config_set_afu_state(dev, afu->config.dvsec_afu_control_pos, 0);\n}\n\nstatic int init_afu(struct pci_dev *dev, struct ocxl_fn *fn, u8 afu_idx)\n{\n\tint rc;\n\tstruct ocxl_afu *afu;\n\n\tafu = alloc_afu(fn);\n\tif (!afu)\n\t\treturn -ENOMEM;\n\n\trc = configure_afu(afu, afu_idx, dev);\n\tif (rc) {\n\t\tocxl_afu_put(afu);\n\t\treturn rc;\n\t}\n\n\trc = activate_afu(dev, afu);\n\tif (rc) {\n\t\tdeconfigure_afu(afu);\n\t\tocxl_afu_put(afu);\n\t\treturn rc;\n\t}\n\n\tlist_add_tail(&afu->list, &fn->afu_list);\n\n\treturn 0;\n}\n\nstatic void remove_afu(struct ocxl_afu *afu)\n{\n\tlist_del(&afu->list);\n\tocxl_context_detach_all(afu);\n\tdeactivate_afu(afu);\n\tdeconfigure_afu(afu);\n\tocxl_afu_put(afu); \n}\n\nstatic struct ocxl_fn *alloc_function(void)\n{\n\tstruct ocxl_fn *fn;\n\n\tfn = kzalloc(sizeof(struct ocxl_fn), GFP_KERNEL);\n\tif (!fn)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&fn->afu_list);\n\tINIT_LIST_HEAD(&fn->pasid_list);\n\tINIT_LIST_HEAD(&fn->actag_list);\n\n\treturn fn;\n}\n\nstatic void free_function(struct ocxl_fn *fn)\n{\n\tWARN_ON(!list_empty(&fn->afu_list));\n\tWARN_ON(!list_empty(&fn->pasid_list));\n\tkfree(fn);\n}\n\nstatic void free_function_dev(struct device *dev)\n{\n\tstruct ocxl_fn *fn = container_of(dev, struct ocxl_fn, dev);\n\n\tfree_function(fn);\n}\n\nstatic int set_function_device(struct ocxl_fn *fn, struct pci_dev *dev)\n{\n\tfn->dev.parent = &dev->dev;\n\tfn->dev.release = free_function_dev;\n\treturn dev_set_name(&fn->dev, \"ocxlfn.%s\", dev_name(&dev->dev));\n}\n\nstatic int assign_function_actag(struct ocxl_fn *fn)\n{\n\tstruct pci_dev *dev = to_pci_dev(fn->dev.parent);\n\tu16 base, enabled, supported;\n\tint rc;\n\n\trc = ocxl_config_get_actag_info(dev, &base, &enabled, &supported);\n\tif (rc)\n\t\treturn rc;\n\n\tfn->actag_base = base;\n\tfn->actag_enabled = enabled;\n\tfn->actag_supported = supported;\n\n\tocxl_config_set_actag(dev, fn->config.dvsec_function_pos,\n\t\t\tfn->actag_base,\tfn->actag_enabled);\n\tdev_dbg(&fn->dev, \"actag range starting at %d, enabled %d\\n\",\n\t\tfn->actag_base, fn->actag_enabled);\n\treturn 0;\n}\n\nstatic int set_function_pasid(struct ocxl_fn *fn)\n{\n\tstruct pci_dev *dev = to_pci_dev(fn->dev.parent);\n\tint rc, desired_count, max_count;\n\n\t \n\tif (fn->config.max_pasid_log < 0)\n\t\treturn 0;\n\n\trc = ocxl_config_get_pasid_info(dev, &max_count);\n\tif (rc)\n\t\treturn rc;\n\n\tdesired_count = 1 << fn->config.max_pasid_log;\n\n\tif (desired_count > max_count) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Function requires more PASIDs than is available (%d vs. %d)\\n\",\n\t\t\tdesired_count, max_count);\n\t\treturn -ENOSPC;\n\t}\n\n\tfn->pasid_base = 0;\n\treturn 0;\n}\n\nstatic int configure_function(struct ocxl_fn *fn, struct pci_dev *dev)\n{\n\tint rc;\n\n\trc = pci_enable_device(dev);\n\tif (rc) {\n\t\tdev_err(&dev->dev, \"pci_enable_device failed: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\trc = ocxl_config_read_function(dev, &fn->config);\n\tif (rc)\n\t\treturn rc;\n\n\trc = set_function_device(fn, dev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = assign_function_actag(fn);\n\tif (rc)\n\t\treturn rc;\n\n\trc = set_function_pasid(fn);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ocxl_link_setup(dev, 0, &fn->link);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ocxl_config_set_TL(dev, fn->config.dvsec_tl_pos);\n\tif (rc) {\n\t\tocxl_link_release(dev, fn->link);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void deconfigure_function(struct ocxl_fn *fn)\n{\n\tstruct pci_dev *dev = to_pci_dev(fn->dev.parent);\n\n\tocxl_link_release(dev, fn->link);\n\tpci_disable_device(dev);\n}\n\nstatic struct ocxl_fn *init_function(struct pci_dev *dev)\n{\n\tstruct ocxl_fn *fn;\n\tint rc;\n\n\tfn = alloc_function();\n\tif (!fn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = configure_function(fn, dev);\n\tif (rc) {\n\t\tfree_function(fn);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\trc = device_register(&fn->dev);\n\tif (rc) {\n\t\tdeconfigure_function(fn);\n\t\tput_device(&fn->dev);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn fn;\n}\n\n\n\nstruct ocxl_fn *ocxl_function_open(struct pci_dev *dev)\n{\n\tint rc, afu_count = 0;\n\tu8 afu;\n\tstruct ocxl_fn *fn;\n\n\tif (!radix_enabled()) {\n\t\tdev_err(&dev->dev, \"Unsupported memory model (hash)\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tfn = init_function(dev);\n\tif (IS_ERR(fn)) {\n\t\tdev_err(&dev->dev, \"function init failed: %li\\n\",\n\t\t\tPTR_ERR(fn));\n\t\treturn fn;\n\t}\n\n\tfor (afu = 0; afu <= fn->config.max_afu_index; afu++) {\n\t\trc = ocxl_config_check_afu_index(dev, &fn->config, afu);\n\t\tif (rc > 0) {\n\t\t\trc = init_afu(dev, fn, afu);\n\t\t\tif (rc) {\n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t\"Can't initialize AFU index %d\\n\", afu);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tafu_count++;\n\t\t}\n\t}\n\tdev_info(&dev->dev, \"%d AFU(s) configured\\n\", afu_count);\n\treturn fn;\n}\nEXPORT_SYMBOL_GPL(ocxl_function_open);\n\nstruct list_head *ocxl_function_afu_list(struct ocxl_fn *fn)\n{\n\treturn &fn->afu_list;\n}\nEXPORT_SYMBOL_GPL(ocxl_function_afu_list);\n\nstruct ocxl_afu *ocxl_function_fetch_afu(struct ocxl_fn *fn, u8 afu_idx)\n{\n\tstruct ocxl_afu *afu;\n\n\tlist_for_each_entry(afu, &fn->afu_list, list) {\n\t\tif (afu->config.idx == afu_idx)\n\t\t\treturn afu;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ocxl_function_fetch_afu);\n\nconst struct ocxl_fn_config *ocxl_function_config(struct ocxl_fn *fn)\n{\n\treturn &fn->config;\n}\nEXPORT_SYMBOL_GPL(ocxl_function_config);\n\nvoid ocxl_function_close(struct ocxl_fn *fn)\n{\n\tstruct ocxl_afu *afu, *tmp;\n\n\tlist_for_each_entry_safe(afu, tmp, &fn->afu_list, list) {\n\t\tremove_afu(afu);\n\t}\n\n\tdeconfigure_function(fn);\n\tdevice_unregister(&fn->dev);\n}\nEXPORT_SYMBOL_GPL(ocxl_function_close);\n\n\n\nstruct ocxl_afu_config *ocxl_afu_config(struct ocxl_afu *afu)\n{\n\treturn &afu->config;\n}\nEXPORT_SYMBOL_GPL(ocxl_afu_config);\n\nvoid ocxl_afu_set_private(struct ocxl_afu *afu, void *private)\n{\n\tafu->private = private;\n}\nEXPORT_SYMBOL_GPL(ocxl_afu_set_private);\n\nvoid *ocxl_afu_get_private(struct ocxl_afu *afu)\n{\n\tif (afu)\n\t\treturn afu->private;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ocxl_afu_get_private);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}