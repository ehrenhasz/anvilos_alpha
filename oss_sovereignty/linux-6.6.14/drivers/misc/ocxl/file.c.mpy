{
  "module_name": "file.c",
  "hash_id": "c1df06a25b45927ed867701635d8bd001cce4b75a0973048c0ff04a56884c2f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ocxl/file.c",
  "human_readable_source": "\n\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/sched/signal.h>\n#include <linux/eventfd.h>\n#include <linux/uaccess.h>\n#include <uapi/misc/ocxl.h>\n#include <asm/reg.h>\n#include <asm/switch_to.h>\n#include \"ocxl_internal.h\"\n\n\n#define OCXL_NUM_MINORS 256  \n\nstatic dev_t ocxl_dev;\nstatic struct class *ocxl_class;\nstatic DEFINE_MUTEX(minors_idr_lock);\nstatic struct idr minors_idr;\n\nstatic struct ocxl_file_info *find_and_get_file_info(dev_t devno)\n{\n\tstruct ocxl_file_info *info;\n\n\tmutex_lock(&minors_idr_lock);\n\tinfo = idr_find(&minors_idr, MINOR(devno));\n\tif (info)\n\t\tget_device(&info->dev);\n\tmutex_unlock(&minors_idr_lock);\n\treturn info;\n}\n\nstatic int allocate_minor(struct ocxl_file_info *info)\n{\n\tint minor;\n\n\tmutex_lock(&minors_idr_lock);\n\tminor = idr_alloc(&minors_idr, info, 0, OCXL_NUM_MINORS, GFP_KERNEL);\n\tmutex_unlock(&minors_idr_lock);\n\treturn minor;\n}\n\nstatic void free_minor(struct ocxl_file_info *info)\n{\n\tmutex_lock(&minors_idr_lock);\n\tidr_remove(&minors_idr, MINOR(info->dev.devt));\n\tmutex_unlock(&minors_idr_lock);\n}\n\nstatic int afu_open(struct inode *inode, struct file *file)\n{\n\tstruct ocxl_file_info *info;\n\tstruct ocxl_context *ctx;\n\tint rc;\n\n\tpr_debug(\"%s for device %x\\n\", __func__, inode->i_rdev);\n\n\tinfo = find_and_get_file_info(inode->i_rdev);\n\tif (!info)\n\t\treturn -ENODEV;\n\n\trc = ocxl_context_alloc(&ctx, info->afu, inode->i_mapping);\n\tif (rc) {\n\t\tput_device(&info->dev);\n\t\treturn rc;\n\t}\n\tput_device(&info->dev);\n\tfile->private_data = ctx;\n\treturn 0;\n}\n\nstatic long afu_ioctl_attach(struct ocxl_context *ctx,\n\t\t\tstruct ocxl_ioctl_attach __user *uarg)\n{\n\tstruct ocxl_ioctl_attach arg;\n\tu64 amr = 0;\n\n\tpr_debug(\"%s for context %d\\n\", __func__, ctx->pasid);\n\n\tif (copy_from_user(&arg, uarg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\t \n\tif (arg.reserved1 || arg.reserved2 || arg.reserved3)\n\t\treturn -EINVAL;\n\n\tamr = arg.amr & mfspr(SPRN_UAMOR);\n\treturn ocxl_context_attach(ctx, amr, current->mm);\n}\n\nstatic long afu_ioctl_get_metadata(struct ocxl_context *ctx,\n\t\tstruct ocxl_ioctl_metadata __user *uarg)\n{\n\tstruct ocxl_ioctl_metadata arg;\n\n\tmemset(&arg, 0, sizeof(arg));\n\n\targ.version = 0;\n\n\targ.afu_version_major = ctx->afu->config.version_major;\n\targ.afu_version_minor = ctx->afu->config.version_minor;\n\targ.pasid = ctx->pasid;\n\targ.pp_mmio_size = ctx->afu->config.pp_mmio_stride;\n\targ.global_mmio_size = ctx->afu->config.global_mmio_size;\n\n\tif (copy_to_user(uarg, &arg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PPC64\nstatic long afu_ioctl_enable_p9_wait(struct ocxl_context *ctx,\n\t\tstruct ocxl_ioctl_p9_wait __user *uarg)\n{\n\tstruct ocxl_ioctl_p9_wait arg;\n\n\tmemset(&arg, 0, sizeof(arg));\n\n\tif (cpu_has_feature(CPU_FTR_P9_TIDR)) {\n\t\tenum ocxl_context_status status;\n\n\t\t\n\t\tmutex_lock(&ctx->status_mutex);\n\t\tif (!ctx->tidr) {\n\t\t\tif (set_thread_tidr(current)) {\n\t\t\t\tmutex_unlock(&ctx->status_mutex);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\tctx->tidr = current->thread.tidr;\n\t\t}\n\n\t\tstatus = ctx->status;\n\t\tmutex_unlock(&ctx->status_mutex);\n\n\t\tif (status == ATTACHED) {\n\t\t\tint rc = ocxl_link_update_pe(ctx->afu->fn->link,\n\t\t\t\tctx->pasid, ctx->tidr);\n\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\targ.thread_id = ctx->tidr;\n\t} else\n\t\treturn -ENOENT;\n\n\tif (copy_to_user(uarg, &arg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n#endif\n\n\nstatic long afu_ioctl_get_features(struct ocxl_context *ctx,\n\t\tstruct ocxl_ioctl_features __user *uarg)\n{\n\tstruct ocxl_ioctl_features arg;\n\n\tmemset(&arg, 0, sizeof(arg));\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_P9_TIDR))\n\t\targ.flags[0] |= OCXL_IOCTL_FEATURES_FLAGS0_P9_WAIT;\n#endif\n\n\tif (copy_to_user(uarg, &arg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#define CMD_STR(x) (x == OCXL_IOCTL_ATTACH ? \"ATTACH\" :\t\t\t\\\n\t\t\tx == OCXL_IOCTL_IRQ_ALLOC ? \"IRQ_ALLOC\" :\t\\\n\t\t\tx == OCXL_IOCTL_IRQ_FREE ? \"IRQ_FREE\" :\t\t\\\n\t\t\tx == OCXL_IOCTL_IRQ_SET_FD ? \"IRQ_SET_FD\" :\t\\\n\t\t\tx == OCXL_IOCTL_GET_METADATA ? \"GET_METADATA\" :\t\\\n\t\t\tx == OCXL_IOCTL_ENABLE_P9_WAIT ? \"ENABLE_P9_WAIT\" :\t\\\n\t\t\tx == OCXL_IOCTL_GET_FEATURES ? \"GET_FEATURES\" :\t\\\n\t\t\t\"UNKNOWN\")\n\nstatic irqreturn_t irq_handler(void *private)\n{\n\tstruct eventfd_ctx *ev_ctx = private;\n\n\teventfd_signal(ev_ctx, 1);\n\treturn IRQ_HANDLED;\n}\n\nstatic void irq_free(void *private)\n{\n\tstruct eventfd_ctx *ev_ctx = private;\n\n\teventfd_ctx_put(ev_ctx);\n}\n\nstatic long afu_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long args)\n{\n\tstruct ocxl_context *ctx = file->private_data;\n\tstruct ocxl_ioctl_irq_fd irq_fd;\n\tstruct eventfd_ctx *ev_ctx;\n\tint irq_id;\n\tu64 irq_offset;\n\tlong rc;\n\tbool closed;\n\n\tpr_debug(\"%s for context %d, command %s\\n\", __func__, ctx->pasid,\n\t\tCMD_STR(cmd));\n\n\tmutex_lock(&ctx->status_mutex);\n\tclosed = (ctx->status == CLOSED);\n\tmutex_unlock(&ctx->status_mutex);\n\n\tif (closed)\n\t\treturn -EIO;\n\n\tswitch (cmd) {\n\tcase OCXL_IOCTL_ATTACH:\n\t\trc = afu_ioctl_attach(ctx,\n\t\t\t\t(struct ocxl_ioctl_attach __user *) args);\n\t\tbreak;\n\n\tcase OCXL_IOCTL_IRQ_ALLOC:\n\t\trc = ocxl_afu_irq_alloc(ctx, &irq_id);\n\t\tif (!rc) {\n\t\t\tirq_offset = ocxl_irq_id_to_offset(ctx, irq_id);\n\t\t\trc = copy_to_user((u64 __user *) args, &irq_offset,\n\t\t\t\t\tsizeof(irq_offset));\n\t\t\tif (rc) {\n\t\t\t\tocxl_afu_irq_free(ctx, irq_id);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OCXL_IOCTL_IRQ_FREE:\n\t\trc = copy_from_user(&irq_offset, (u64 __user *) args,\n\t\t\t\tsizeof(irq_offset));\n\t\tif (rc)\n\t\t\treturn -EFAULT;\n\t\tirq_id = ocxl_irq_offset_to_id(ctx, irq_offset);\n\t\trc = ocxl_afu_irq_free(ctx, irq_id);\n\t\tbreak;\n\n\tcase OCXL_IOCTL_IRQ_SET_FD:\n\t\trc = copy_from_user(&irq_fd, (u64 __user *) args,\n\t\t\t\tsizeof(irq_fd));\n\t\tif (rc)\n\t\t\treturn -EFAULT;\n\t\tif (irq_fd.reserved)\n\t\t\treturn -EINVAL;\n\t\tirq_id = ocxl_irq_offset_to_id(ctx, irq_fd.irq_offset);\n\t\tev_ctx = eventfd_ctx_fdget(irq_fd.eventfd);\n\t\tif (IS_ERR(ev_ctx))\n\t\t\treturn PTR_ERR(ev_ctx);\n\t\trc = ocxl_irq_set_handler(ctx, irq_id, irq_handler, irq_free, ev_ctx);\n\t\tif (rc)\n\t\t\teventfd_ctx_put(ev_ctx);\n\t\tbreak;\n\n\tcase OCXL_IOCTL_GET_METADATA:\n\t\trc = afu_ioctl_get_metadata(ctx,\n\t\t\t\t(struct ocxl_ioctl_metadata __user *) args);\n\t\tbreak;\n\n#ifdef CONFIG_PPC64\n\tcase OCXL_IOCTL_ENABLE_P9_WAIT:\n\t\trc = afu_ioctl_enable_p9_wait(ctx,\n\t\t\t\t(struct ocxl_ioctl_p9_wait __user *) args);\n\t\tbreak;\n#endif\n\n\tcase OCXL_IOCTL_GET_FEATURES:\n\t\trc = afu_ioctl_get_features(ctx,\n\t\t\t\t(struct ocxl_ioctl_features __user *) args);\n\t\tbreak;\n\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}\n\nstatic long afu_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\tunsigned long args)\n{\n\treturn afu_ioctl(file, cmd, args);\n}\n\nstatic int afu_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct ocxl_context *ctx = file->private_data;\n\n\tpr_debug(\"%s for context %d\\n\", __func__, ctx->pasid);\n\treturn ocxl_context_mmap(ctx, vma);\n}\n\nstatic bool has_xsl_error(struct ocxl_context *ctx)\n{\n\tbool ret;\n\n\tmutex_lock(&ctx->xsl_error_lock);\n\tret = !!ctx->xsl_error.addr;\n\tmutex_unlock(&ctx->xsl_error_lock);\n\n\treturn ret;\n}\n\n \nstatic bool afu_events_pending(struct ocxl_context *ctx)\n{\n\tif (has_xsl_error(ctx))\n\t\treturn true;\n\treturn false;\n}\n\nstatic unsigned int afu_poll(struct file *file, struct poll_table_struct *wait)\n{\n\tstruct ocxl_context *ctx = file->private_data;\n\tunsigned int mask = 0;\n\tbool closed;\n\n\tpr_debug(\"%s for context %d\\n\", __func__, ctx->pasid);\n\n\tpoll_wait(file, &ctx->events_wq, wait);\n\n\tmutex_lock(&ctx->status_mutex);\n\tclosed = (ctx->status == CLOSED);\n\tmutex_unlock(&ctx->status_mutex);\n\n\tif (afu_events_pending(ctx))\n\t\tmask = EPOLLIN | EPOLLRDNORM;\n\telse if (closed)\n\t\tmask = EPOLLERR;\n\n\treturn mask;\n}\n\n \nstatic ssize_t append_xsl_error(struct ocxl_context *ctx,\n\t\t\t\tstruct ocxl_kernel_event_header *header,\n\t\t\t\tchar __user *buf)\n{\n\tstruct ocxl_kernel_event_xsl_fault_error body;\n\n\tmemset(&body, 0, sizeof(body));\n\n\tmutex_lock(&ctx->xsl_error_lock);\n\tif (!ctx->xsl_error.addr) {\n\t\tmutex_unlock(&ctx->xsl_error_lock);\n\t\treturn 0;\n\t}\n\n\tbody.addr = ctx->xsl_error.addr;\n\tbody.dsisr = ctx->xsl_error.dsisr;\n\tbody.count = ctx->xsl_error.count;\n\n\tctx->xsl_error.addr = 0;\n\tctx->xsl_error.dsisr = 0;\n\tctx->xsl_error.count = 0;\n\n\tmutex_unlock(&ctx->xsl_error_lock);\n\n\theader->type = OCXL_AFU_EVENT_XSL_FAULT_ERROR;\n\n\tif (copy_to_user(buf, &body, sizeof(body)))\n\t\treturn -EFAULT;\n\n\treturn sizeof(body);\n}\n\n#define AFU_EVENT_BODY_MAX_SIZE sizeof(struct ocxl_kernel_event_xsl_fault_error)\n\n \nstatic ssize_t afu_read(struct file *file, char __user *buf, size_t count,\n\t\t\tloff_t *off)\n{\n\tstruct ocxl_context *ctx = file->private_data;\n\tstruct ocxl_kernel_event_header header;\n\tssize_t rc;\n\tssize_t used = 0;\n\tDEFINE_WAIT(event_wait);\n\n\tmemset(&header, 0, sizeof(header));\n\n\t \n\tif (*off != 0)\n\t\treturn -EINVAL;\n\n\tif (count < (sizeof(struct ocxl_kernel_event_header) +\n\t\t\tAFU_EVENT_BODY_MAX_SIZE))\n\t\treturn -EINVAL;\n\n\tfor (;;) {\n\t\tprepare_to_wait(&ctx->events_wq, &event_wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\n\t\tif (afu_events_pending(ctx))\n\t\t\tbreak;\n\n\t\tif (ctx->status == CLOSED)\n\t\t\tbreak;\n\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tfinish_wait(&ctx->events_wq, &event_wait);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tfinish_wait(&ctx->events_wq, &event_wait);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\n\t\tschedule();\n\t}\n\n\tfinish_wait(&ctx->events_wq, &event_wait);\n\n\tif (has_xsl_error(ctx)) {\n\t\tused = append_xsl_error(ctx, &header, buf + sizeof(header));\n\t\tif (used < 0)\n\t\t\treturn used;\n\t}\n\n\tif (!afu_events_pending(ctx))\n\t\theader.flags |= OCXL_KERNEL_EVENT_FLAG_LAST;\n\n\tif (copy_to_user(buf, &header, sizeof(header)))\n\t\treturn -EFAULT;\n\n\tused += sizeof(header);\n\n\trc = used;\n\treturn rc;\n}\n\nstatic int afu_release(struct inode *inode, struct file *file)\n{\n\tstruct ocxl_context *ctx = file->private_data;\n\tint rc;\n\n\tpr_debug(\"%s for device %x\\n\", __func__, inode->i_rdev);\n\trc = ocxl_context_detach(ctx);\n\tmutex_lock(&ctx->mapping_lock);\n\tctx->mapping = NULL;\n\tmutex_unlock(&ctx->mapping_lock);\n\twake_up_all(&ctx->events_wq);\n\tif (rc != -EBUSY)\n\t\tocxl_context_free(ctx);\n\treturn 0;\n}\n\nstatic const struct file_operations ocxl_afu_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = afu_open,\n\t.unlocked_ioctl = afu_ioctl,\n\t.compat_ioctl   = afu_compat_ioctl,\n\t.mmap           = afu_mmap,\n\t.poll           = afu_poll,\n\t.read           = afu_read,\n\t.release        = afu_release,\n};\n\n\nstatic void info_release(struct device *dev)\n{\n\tstruct ocxl_file_info *info = container_of(dev, struct ocxl_file_info, dev);\n\n\tocxl_afu_put(info->afu);\n\tkfree(info);\n}\n\nstatic int ocxl_file_make_visible(struct ocxl_file_info *info)\n{\n\tint rc;\n\n\tcdev_init(&info->cdev, &ocxl_afu_fops);\n\trc = cdev_add(&info->cdev, info->dev.devt, 1);\n\tif (rc) {\n\t\tdev_err(&info->dev, \"Unable to add afu char device: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void ocxl_file_make_invisible(struct ocxl_file_info *info)\n{\n\tcdev_del(&info->cdev);\n}\n\nint ocxl_file_register_afu(struct ocxl_afu *afu)\n{\n\tint minor;\n\tint rc;\n\tstruct ocxl_file_info *info;\n\tstruct ocxl_fn *fn = afu->fn;\n\tstruct pci_dev *pci_dev = to_pci_dev(fn->dev.parent);\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\tminor = allocate_minor(info);\n\tif (minor < 0) {\n\t\tkfree(info);\n\t\treturn minor;\n\t}\n\n\tinfo->dev.parent = &fn->dev;\n\tinfo->dev.devt = MKDEV(MAJOR(ocxl_dev), minor);\n\tinfo->dev.class = ocxl_class;\n\tinfo->dev.release = info_release;\n\n\tinfo->afu = afu;\n\tocxl_afu_get(afu);\n\n\trc = dev_set_name(&info->dev, \"%s.%s.%hhu\",\n\t\tafu->config.name, dev_name(&pci_dev->dev), afu->config.idx);\n\tif (rc)\n\t\tgoto err_put;\n\n\trc = device_register(&info->dev);\n\tif (rc) {\n\t\tfree_minor(info);\n\t\tput_device(&info->dev);\n\t\treturn rc;\n\t}\n\n\trc = ocxl_sysfs_register_afu(info);\n\tif (rc)\n\t\tgoto err_unregister;\n\n\trc = ocxl_file_make_visible(info);\n\tif (rc)\n\t\tgoto err_unregister;\n\n\tocxl_afu_set_private(afu, info);\n\n\treturn 0;\n\nerr_unregister:\n\tocxl_sysfs_unregister_afu(info); \n\tfree_minor(info);\n\tdevice_unregister(&info->dev);\n\treturn rc;\nerr_put:\n\tocxl_afu_put(afu);\n\tfree_minor(info);\n\tkfree(info);\n\treturn rc;\n}\n\nvoid ocxl_file_unregister_afu(struct ocxl_afu *afu)\n{\n\tstruct ocxl_file_info *info = ocxl_afu_get_private(afu);\n\n\tif (!info)\n\t\treturn;\n\n\tocxl_file_make_invisible(info);\n\tocxl_sysfs_unregister_afu(info);\n\tfree_minor(info);\n\tdevice_unregister(&info->dev);\n}\n\nstatic char *ocxl_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"ocxl/%s\", dev_name(dev));\n}\n\nint ocxl_file_init(void)\n{\n\tint rc;\n\n\tidr_init(&minors_idr);\n\n\trc = alloc_chrdev_region(&ocxl_dev, 0, OCXL_NUM_MINORS, \"ocxl\");\n\tif (rc) {\n\t\tpr_err(\"Unable to allocate ocxl major number: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tocxl_class = class_create(\"ocxl\");\n\tif (IS_ERR(ocxl_class)) {\n\t\tpr_err(\"Unable to create ocxl class\\n\");\n\t\tunregister_chrdev_region(ocxl_dev, OCXL_NUM_MINORS);\n\t\treturn PTR_ERR(ocxl_class);\n\t}\n\n\tocxl_class->devnode = ocxl_devnode;\n\treturn 0;\n}\n\nvoid ocxl_file_exit(void)\n{\n\tclass_destroy(ocxl_class);\n\tunregister_chrdev_region(ocxl_dev, OCXL_NUM_MINORS);\n\tidr_destroy(&minors_idr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}