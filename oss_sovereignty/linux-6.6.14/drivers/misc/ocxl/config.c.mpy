{
  "module_name": "config.c",
  "hash_id": "22c58de1c5bf8b39c9ae8ca38de51f71148d5daaa527e1b821317c5412f23221",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ocxl/config.c",
  "human_readable_source": "\n\n#include <linux/pci.h>\n#include <asm/pnv-ocxl.h>\n#include <misc/ocxl-config.h>\n#include \"ocxl_internal.h\"\n\n#define EXTRACT_BIT(val, bit) (!!(val & BIT(bit)))\n#define EXTRACT_BITS(val, s, e) ((val & GENMASK(e, s)) >> s)\n\n#define OCXL_DVSEC_AFU_IDX_MASK              GENMASK(5, 0)\n#define OCXL_DVSEC_ACTAG_MASK                GENMASK(11, 0)\n#define OCXL_DVSEC_PASID_MASK                GENMASK(19, 0)\n#define OCXL_DVSEC_PASID_LOG_MASK            GENMASK(4, 0)\n\n#define OCXL_DVSEC_TEMPL_VERSION         0x0\n#define OCXL_DVSEC_TEMPL_NAME            0x4\n#define OCXL_DVSEC_TEMPL_AFU_VERSION     0x1C\n#define OCXL_DVSEC_TEMPL_MMIO_GLOBAL     0x20\n#define OCXL_DVSEC_TEMPL_MMIO_GLOBAL_SZ  0x28\n#define OCXL_DVSEC_TEMPL_MMIO_PP         0x30\n#define OCXL_DVSEC_TEMPL_MMIO_PP_SZ      0x38\n#define OCXL_DVSEC_TEMPL_ALL_MEM_SZ      0x3C\n#define OCXL_DVSEC_TEMPL_LPC_MEM_START   0x40\n#define OCXL_DVSEC_TEMPL_WWID            0x48\n#define OCXL_DVSEC_TEMPL_LPC_MEM_SZ      0x58\n\n#define OCXL_MAX_AFU_PER_FUNCTION 64\n#define OCXL_TEMPL_LEN_1_0        0x58\n#define OCXL_TEMPL_LEN_1_1        0x60\n#define OCXL_TEMPL_NAME_LEN       24\n#define OCXL_CFG_TIMEOUT     3\n\nstatic int find_dvsec(struct pci_dev *dev, int dvsec_id)\n{\n\treturn pci_find_dvsec_capability(dev, PCI_VENDOR_ID_IBM, dvsec_id);\n}\n\nstatic int find_dvsec_afu_ctrl(struct pci_dev *dev, u8 afu_idx)\n{\n\tint vsec = 0;\n\tu16 vendor, id;\n\tu8 idx;\n\n\twhile ((vsec = pci_find_next_ext_capability(dev, vsec,\n\t\t\t\t\t\t    OCXL_EXT_CAP_ID_DVSEC))) {\n\t\tpci_read_config_word(dev, vsec + OCXL_DVSEC_VENDOR_OFFSET,\n\t\t\t\t&vendor);\n\t\tpci_read_config_word(dev, vsec + OCXL_DVSEC_ID_OFFSET, &id);\n\n\t\tif (vendor == PCI_VENDOR_ID_IBM &&\n\t\t\tid == OCXL_DVSEC_AFU_CTRL_ID) {\n\t\t\tpci_read_config_byte(dev,\n\t\t\t\t\tvsec + OCXL_DVSEC_AFU_CTRL_AFU_IDX,\n\t\t\t\t\t&idx);\n\t\t\tif (idx == afu_idx)\n\t\t\t\treturn vsec;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic struct pci_dev *get_function_0(struct pci_dev *dev)\n{\n\tunsigned int devfn = PCI_DEVFN(PCI_SLOT(dev->devfn), 0);\n\n\treturn pci_get_domain_bus_and_slot(pci_domain_nr(dev->bus),\n\t\t\t\t\t   dev->bus->number, devfn);\n}\n\nstatic void read_pasid(struct pci_dev *dev, struct ocxl_fn_config *fn)\n{\n\tu16 val;\n\tint pos;\n\n\tpos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_PASID);\n\tif (!pos) {\n\t\t \n\t\tdev_dbg(&dev->dev, \"Function doesn't require any PASID\\n\");\n\t\tfn->max_pasid_log = -1;\n\t\tgoto out;\n\t}\n\tpci_read_config_word(dev, pos + PCI_PASID_CAP, &val);\n\tfn->max_pasid_log = EXTRACT_BITS(val, 8, 12);\n\nout:\n\tdev_dbg(&dev->dev, \"PASID capability:\\n\");\n\tdev_dbg(&dev->dev, \"  Max PASID log = %d\\n\", fn->max_pasid_log);\n}\n\nstatic int read_dvsec_tl(struct pci_dev *dev, struct ocxl_fn_config *fn)\n{\n\tint pos;\n\n\tpos = find_dvsec(dev, OCXL_DVSEC_TL_ID);\n\tif (!pos && PCI_FUNC(dev->devfn) == 0) {\n\t\tdev_err(&dev->dev, \"Can't find TL DVSEC\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (pos && PCI_FUNC(dev->devfn) != 0) {\n\t\tdev_err(&dev->dev, \"TL DVSEC is only allowed on function 0\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfn->dvsec_tl_pos = pos;\n\treturn 0;\n}\n\nstatic int read_dvsec_function(struct pci_dev *dev, struct ocxl_fn_config *fn)\n{\n\tint pos, afu_present;\n\tu32 val;\n\n\tpos = find_dvsec(dev, OCXL_DVSEC_FUNC_ID);\n\tif (!pos) {\n\t\tdev_err(&dev->dev, \"Can't find function DVSEC\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfn->dvsec_function_pos = pos;\n\n\tpci_read_config_dword(dev, pos + OCXL_DVSEC_FUNC_OFF_INDEX, &val);\n\tafu_present = EXTRACT_BIT(val, 31);\n\tif (!afu_present) {\n\t\tfn->max_afu_index = -1;\n\t\tdev_dbg(&dev->dev, \"Function doesn't define any AFU\\n\");\n\t\tgoto out;\n\t}\n\tfn->max_afu_index = EXTRACT_BITS(val, 24, 29);\n\nout:\n\tdev_dbg(&dev->dev, \"Function DVSEC:\\n\");\n\tdev_dbg(&dev->dev, \"  Max AFU index = %d\\n\", fn->max_afu_index);\n\treturn 0;\n}\n\nstatic int read_dvsec_afu_info(struct pci_dev *dev, struct ocxl_fn_config *fn)\n{\n\tint pos;\n\n\tif (fn->max_afu_index < 0) {\n\t\tfn->dvsec_afu_info_pos = -1;\n\t\treturn 0;\n\t}\n\n\tpos = find_dvsec(dev, OCXL_DVSEC_AFU_INFO_ID);\n\tif (!pos) {\n\t\tdev_err(&dev->dev, \"Can't find AFU information DVSEC\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfn->dvsec_afu_info_pos = pos;\n\treturn 0;\n}\n\nstatic int read_dvsec_vendor(struct pci_dev *dev)\n{\n\tint pos;\n\tu32 cfg, tlx, dlx, reset_reload;\n\n\t \n\tif (PCI_FUNC(dev->devfn) != 0)\n\t\treturn 0;\n\n\tpos = find_dvsec(dev, OCXL_DVSEC_VENDOR_ID);\n\tif (!pos)\n\t\treturn 0;\n\n\tpci_read_config_dword(dev, pos + OCXL_DVSEC_VENDOR_CFG_VERS, &cfg);\n\tpci_read_config_dword(dev, pos + OCXL_DVSEC_VENDOR_TLX_VERS, &tlx);\n\tpci_read_config_dword(dev, pos + OCXL_DVSEC_VENDOR_DLX_VERS, &dlx);\n\tpci_read_config_dword(dev, pos + OCXL_DVSEC_VENDOR_RESET_RELOAD,\n\t\t\t      &reset_reload);\n\n\tdev_dbg(&dev->dev, \"Vendor specific DVSEC:\\n\");\n\tdev_dbg(&dev->dev, \"  CFG version = 0x%x\\n\", cfg);\n\tdev_dbg(&dev->dev, \"  TLX version = 0x%x\\n\", tlx);\n\tdev_dbg(&dev->dev, \"  DLX version = 0x%x\\n\", dlx);\n\tdev_dbg(&dev->dev, \"  ResetReload = 0x%x\\n\", reset_reload);\n\treturn 0;\n}\n\n \nstatic int get_dvsec_vendor0(struct pci_dev *dev, struct pci_dev **dev0,\n\t\t\t     int *out_pos)\n{\n\tint pos;\n\n\tif (PCI_FUNC(dev->devfn) != 0) {\n\t\tdev = get_function_0(dev);\n\t\tif (!dev)\n\t\t\treturn -1;\n\t} else {\n\t\tdev = pci_dev_get(dev);\n\t}\n\tpos = find_dvsec(dev, OCXL_DVSEC_VENDOR_ID);\n\tif (!pos) {\n\t\tpci_dev_put(dev);\n\t\treturn -1;\n\t}\n\t*dev0 = dev;\n\t*out_pos = pos;\n\treturn 0;\n}\n\nint ocxl_config_get_reset_reload(struct pci_dev *dev, int *val)\n{\n\tstruct pci_dev *dev0;\n\tu32 reset_reload;\n\tint pos;\n\n\tif (get_dvsec_vendor0(dev, &dev0, &pos))\n\t\treturn -1;\n\n\tpci_read_config_dword(dev0, pos + OCXL_DVSEC_VENDOR_RESET_RELOAD,\n\t\t\t      &reset_reload);\n\tpci_dev_put(dev0);\n\t*val = !!(reset_reload & BIT(0));\n\treturn 0;\n}\n\nint ocxl_config_set_reset_reload(struct pci_dev *dev, int val)\n{\n\tstruct pci_dev *dev0;\n\tu32 reset_reload;\n\tint pos;\n\n\tif (get_dvsec_vendor0(dev, &dev0, &pos))\n\t\treturn -1;\n\n\tpci_read_config_dword(dev0, pos + OCXL_DVSEC_VENDOR_RESET_RELOAD,\n\t\t\t      &reset_reload);\n\tif (val)\n\t\treset_reload |= BIT(0);\n\telse\n\t\treset_reload &= ~BIT(0);\n\tpci_write_config_dword(dev0, pos + OCXL_DVSEC_VENDOR_RESET_RELOAD,\n\t\t\t       reset_reload);\n\tpci_dev_put(dev0);\n\treturn 0;\n}\n\nstatic int validate_function(struct pci_dev *dev, struct ocxl_fn_config *fn)\n{\n\tif (fn->max_pasid_log == -1 && fn->max_afu_index >= 0) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"AFUs are defined but no PASIDs are requested\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fn->max_afu_index > OCXL_MAX_AFU_PER_FUNCTION) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Max AFU index out of architectural limit (%d vs %d)\\n\",\n\t\t\tfn->max_afu_index, OCXL_MAX_AFU_PER_FUNCTION);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint ocxl_config_read_function(struct pci_dev *dev, struct ocxl_fn_config *fn)\n{\n\tint rc;\n\n\tread_pasid(dev, fn);\n\n\trc = read_dvsec_tl(dev, fn);\n\tif (rc) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Invalid Transaction Layer DVSEC configuration: %d\\n\",\n\t\t\trc);\n\t\treturn -ENODEV;\n\t}\n\n\trc = read_dvsec_function(dev, fn);\n\tif (rc) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Invalid Function DVSEC configuration: %d\\n\", rc);\n\t\treturn -ENODEV;\n\t}\n\n\trc = read_dvsec_afu_info(dev, fn);\n\tif (rc) {\n\t\tdev_err(&dev->dev, \"Invalid AFU configuration: %d\\n\", rc);\n\t\treturn -ENODEV;\n\t}\n\n\trc = read_dvsec_vendor(dev);\n\tif (rc) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Invalid vendor specific DVSEC configuration: %d\\n\",\n\t\t\trc);\n\t\treturn -ENODEV;\n\t}\n\n\trc = validate_function(dev, fn);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ocxl_config_read_function);\n\nstatic int read_afu_info(struct pci_dev *dev, struct ocxl_fn_config *fn,\n\t\t\tint offset, u32 *data)\n{\n\tu32 val;\n\tunsigned long timeout = jiffies + (HZ * OCXL_CFG_TIMEOUT);\n\tint pos = fn->dvsec_afu_info_pos;\n\n\t \n\tif (EXTRACT_BIT(offset, 31)) {\n\t\tdev_err(&dev->dev, \"Invalid offset in AFU info DVSEC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpci_write_config_dword(dev, pos + OCXL_DVSEC_AFU_INFO_OFF, offset);\n\tpci_read_config_dword(dev, pos + OCXL_DVSEC_AFU_INFO_OFF, &val);\n\twhile (!EXTRACT_BIT(val, 31)) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"Timeout while reading AFU info DVSEC (offset=%d)\\n\",\n\t\t\t\toffset);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tcpu_relax();\n\t\tpci_read_config_dword(dev, pos + OCXL_DVSEC_AFU_INFO_OFF, &val);\n\t}\n\tpci_read_config_dword(dev, pos + OCXL_DVSEC_AFU_INFO_DATA, data);\n\treturn 0;\n}\n\n \nstatic int read_template_version(struct pci_dev *dev, struct ocxl_fn_config *fn,\n\t\t\t\t u16 *len, u16 *version)\n{\n\tu32 val32;\n\tu8 major, minor;\n\tint rc;\n\n\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_VERSION, &val32);\n\tif (rc)\n\t\treturn rc;\n\n\t*len = EXTRACT_BITS(val32, 16, 31);\n\tmajor = EXTRACT_BITS(val32, 8, 15);\n\tminor = EXTRACT_BITS(val32, 0, 7);\n\t*version = (major << 8) + minor;\n\treturn 0;\n}\n\nint ocxl_config_check_afu_index(struct pci_dev *dev,\n\t\t\t\tstruct ocxl_fn_config *fn, int afu_idx)\n{\n\tint rc;\n\tu16 templ_version;\n\tu16 len, expected_len;\n\n\tpci_write_config_byte(dev,\n\t\t\tfn->dvsec_afu_info_pos + OCXL_DVSEC_AFU_INFO_AFU_IDX,\n\t\t\tafu_idx);\n\n\trc = read_template_version(dev, fn, &len, &templ_version);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (!templ_version && !len)\n\t\treturn 0;\n\n\tdev_dbg(&dev->dev, \"AFU descriptor template version %d.%d\\n\",\n\t\ttempl_version >> 8, templ_version & 0xFF);\n\n\tswitch (templ_version) {\n\tcase 0x0005:  \n\tcase 0x0100:\n\t\texpected_len = OCXL_TEMPL_LEN_1_0;\n\t\tbreak;\n\tcase 0x0101:\n\t\texpected_len = OCXL_TEMPL_LEN_1_1;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&dev->dev, \"Unknown AFU template version %#x\\n\",\n\t\t\ttempl_version);\n\t\texpected_len = len;\n\t}\n\tif (len != expected_len)\n\t\tdev_warn(&dev->dev,\n\t\t\t\"Unexpected template length %#x in AFU information, expected %#x for version %#x\\n\",\n\t\t\tlen, expected_len, templ_version);\n\treturn 1;\n}\n\nstatic int read_afu_name(struct pci_dev *dev, struct ocxl_fn_config *fn,\n\t\t\tstruct ocxl_afu_config *afu)\n{\n\tint i, rc;\n\tu32 val, *ptr;\n\n\tBUILD_BUG_ON(OCXL_AFU_NAME_SZ < OCXL_TEMPL_NAME_LEN);\n\tfor (i = 0; i < OCXL_TEMPL_NAME_LEN; i += 4) {\n\t\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_NAME + i, &val);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tptr = (u32 *) &afu->name[i];\n\t\t*ptr = le32_to_cpu((__force __le32) val);\n\t}\n\tafu->name[OCXL_AFU_NAME_SZ - 1] = '\\0';  \n\treturn 0;\n}\n\nstatic int read_afu_mmio(struct pci_dev *dev, struct ocxl_fn_config *fn,\n\t\t\tstruct ocxl_afu_config *afu)\n{\n\tint rc;\n\tu32 val;\n\n\t \n\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_MMIO_GLOBAL, &val);\n\tif (rc)\n\t\treturn rc;\n\tafu->global_mmio_bar = EXTRACT_BITS(val, 0, 2);\n\tafu->global_mmio_offset = EXTRACT_BITS(val, 16, 31) << 16;\n\n\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_MMIO_GLOBAL + 4, &val);\n\tif (rc)\n\t\treturn rc;\n\tafu->global_mmio_offset += (u64) val << 32;\n\n\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_MMIO_GLOBAL_SZ, &val);\n\tif (rc)\n\t\treturn rc;\n\tafu->global_mmio_size = val;\n\n\t \n\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_MMIO_PP, &val);\n\tif (rc)\n\t\treturn rc;\n\tafu->pp_mmio_bar = EXTRACT_BITS(val, 0, 2);\n\tafu->pp_mmio_offset = EXTRACT_BITS(val, 16, 31) << 16;\n\n\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_MMIO_PP + 4, &val);\n\tif (rc)\n\t\treturn rc;\n\tafu->pp_mmio_offset += (u64) val << 32;\n\n\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_MMIO_PP_SZ, &val);\n\tif (rc)\n\t\treturn rc;\n\tafu->pp_mmio_stride = val;\n\n\treturn 0;\n}\n\nstatic int read_afu_control(struct pci_dev *dev, struct ocxl_afu_config *afu)\n{\n\tint pos;\n\tu8 val8;\n\tu16 val16;\n\n\tpos = find_dvsec_afu_ctrl(dev, afu->idx);\n\tif (!pos) {\n\t\tdev_err(&dev->dev, \"Can't find AFU control DVSEC for AFU %d\\n\",\n\t\t\tafu->idx);\n\t\treturn -ENODEV;\n\t}\n\tafu->dvsec_afu_control_pos = pos;\n\n\tpci_read_config_byte(dev, pos + OCXL_DVSEC_AFU_CTRL_PASID_SUP, &val8);\n\tafu->pasid_supported_log = EXTRACT_BITS(val8, 0, 4);\n\n\tpci_read_config_word(dev, pos + OCXL_DVSEC_AFU_CTRL_ACTAG_SUP, &val16);\n\tafu->actag_supported = EXTRACT_BITS(val16, 0, 11);\n\treturn 0;\n}\n\nstatic bool char_allowed(int c)\n{\n\t \n\tif ((c >= 0x30 && c <= 0x39)   ||\n\t\t(c >= 0x41 && c <= 0x5A)   ||\n\t\t(c >= 0x61 && c <= 0x7A)   ||\n\t\tc == 0   ||\n\t\tc == 0x2D   ||\n\t\tc == 0x5F   ||\n\t\tc == 0x2C  )\n\t\treturn true;\n\treturn false;\n}\n\nstatic int validate_afu(struct pci_dev *dev, struct ocxl_afu_config *afu)\n{\n\tint i;\n\n\tif (!afu->name[0]) {\n\t\tdev_err(&dev->dev, \"Empty AFU name\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < OCXL_TEMPL_NAME_LEN; i++) {\n\t\tif (!char_allowed(afu->name[i])) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"Invalid character in AFU name\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (afu->global_mmio_bar != 0 &&\n\t\tafu->global_mmio_bar != 2 &&\n\t\tafu->global_mmio_bar != 4) {\n\t\tdev_err(&dev->dev, \"Invalid global MMIO bar number\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (afu->pp_mmio_bar != 0 &&\n\t\tafu->pp_mmio_bar != 2 &&\n\t\tafu->pp_mmio_bar != 4) {\n\t\tdev_err(&dev->dev, \"Invalid per-process MMIO bar number\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int read_afu_lpc_memory_info(struct pci_dev *dev,\n\t\t\t\t    struct ocxl_fn_config *fn,\n\t\t\t\t    struct ocxl_afu_config *afu)\n{\n\tint rc;\n\tu32 val32;\n\tu16 templ_version;\n\tu16 templ_len;\n\tu64 total_mem_size = 0;\n\tu64 lpc_mem_size = 0;\n\n\tafu->lpc_mem_offset = 0;\n\tafu->lpc_mem_size = 0;\n\tafu->special_purpose_mem_offset = 0;\n\tafu->special_purpose_mem_size = 0;\n\t \n\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_ALL_MEM_SZ, &val32);\n\tif (rc)\n\t\treturn rc;\n\n\tval32 = EXTRACT_BITS(val32, 0, 7);\n\tif (!val32)\n\t\treturn 0;  \n\n\t \n\ttotal_mem_size = 1ull << val32;\n\n\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_LPC_MEM_START, &val32);\n\tif (rc)\n\t\treturn rc;\n\n\tafu->lpc_mem_offset = val32;\n\n\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_LPC_MEM_START + 4, &val32);\n\tif (rc)\n\t\treturn rc;\n\n\tafu->lpc_mem_offset |= (u64) val32 << 32;\n\n\trc = read_template_version(dev, fn, &templ_len, &templ_version);\n\tif (rc)\n\t\treturn rc;\n\n\tif (templ_version >= 0x0101) {\n\t\trc = read_afu_info(dev, fn,\n\t\t\t\tOCXL_DVSEC_TEMPL_LPC_MEM_SZ, &val32);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tlpc_mem_size = val32;\n\n\t\trc = read_afu_info(dev, fn,\n\t\t\t\tOCXL_DVSEC_TEMPL_LPC_MEM_SZ + 4, &val32);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tlpc_mem_size |= (u64) val32 << 32;\n\t} else {\n\t\tlpc_mem_size = total_mem_size;\n\t}\n\tafu->lpc_mem_size = lpc_mem_size;\n\n\tif (lpc_mem_size < total_mem_size) {\n\t\tafu->special_purpose_mem_offset =\n\t\t\tafu->lpc_mem_offset + lpc_mem_size;\n\t\tafu->special_purpose_mem_size =\n\t\t\ttotal_mem_size - lpc_mem_size;\n\t}\n\treturn 0;\n}\n\nint ocxl_config_read_afu(struct pci_dev *dev, struct ocxl_fn_config *fn,\n\t\t\tstruct ocxl_afu_config *afu, u8 afu_idx)\n{\n\tint rc;\n\tu32 val32;\n\n\t \n\tWARN_ON((afu_idx & OCXL_DVSEC_AFU_IDX_MASK) != afu_idx);\n\tafu->idx = afu_idx;\n\tpci_write_config_byte(dev,\n\t\t\tfn->dvsec_afu_info_pos + OCXL_DVSEC_AFU_INFO_AFU_IDX,\n\t\t\tafu->idx);\n\n\trc = read_afu_name(dev, fn, afu);\n\tif (rc)\n\t\treturn rc;\n\n\trc = read_afu_info(dev, fn, OCXL_DVSEC_TEMPL_AFU_VERSION, &val32);\n\tif (rc)\n\t\treturn rc;\n\tafu->version_major = EXTRACT_BITS(val32, 24, 31);\n\tafu->version_minor = EXTRACT_BITS(val32, 16, 23);\n\tafu->afuc_type = EXTRACT_BITS(val32, 14, 15);\n\tafu->afum_type = EXTRACT_BITS(val32, 12, 13);\n\tafu->profile = EXTRACT_BITS(val32, 0, 7);\n\n\trc = read_afu_mmio(dev, fn, afu);\n\tif (rc)\n\t\treturn rc;\n\n\trc = read_afu_lpc_memory_info(dev, fn, afu);\n\tif (rc)\n\t\treturn rc;\n\n\trc = read_afu_control(dev, afu);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_dbg(&dev->dev, \"AFU configuration:\\n\");\n\tdev_dbg(&dev->dev, \"  name = %s\\n\", afu->name);\n\tdev_dbg(&dev->dev, \"  version = %d.%d\\n\", afu->version_major,\n\t\tafu->version_minor);\n\tdev_dbg(&dev->dev, \"  global mmio bar = %hhu\\n\", afu->global_mmio_bar);\n\tdev_dbg(&dev->dev, \"  global mmio offset = %#llx\\n\",\n\t\tafu->global_mmio_offset);\n\tdev_dbg(&dev->dev, \"  global mmio size = %#x\\n\", afu->global_mmio_size);\n\tdev_dbg(&dev->dev, \"  pp mmio bar = %hhu\\n\", afu->pp_mmio_bar);\n\tdev_dbg(&dev->dev, \"  pp mmio offset = %#llx\\n\", afu->pp_mmio_offset);\n\tdev_dbg(&dev->dev, \"  pp mmio stride = %#x\\n\", afu->pp_mmio_stride);\n\tdev_dbg(&dev->dev, \"  lpc_mem offset = %#llx\\n\", afu->lpc_mem_offset);\n\tdev_dbg(&dev->dev, \"  lpc_mem size = %#llx\\n\", afu->lpc_mem_size);\n\tdev_dbg(&dev->dev, \"  special purpose mem offset = %#llx\\n\",\n\t\tafu->special_purpose_mem_offset);\n\tdev_dbg(&dev->dev, \"  special purpose mem size = %#llx\\n\",\n\t\tafu->special_purpose_mem_size);\n\tdev_dbg(&dev->dev, \"  pasid supported (log) = %u\\n\",\n\t\tafu->pasid_supported_log);\n\tdev_dbg(&dev->dev, \"  actag supported = %u\\n\",\n\t\tafu->actag_supported);\n\n\trc = validate_afu(dev, afu);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ocxl_config_read_afu);\n\nint ocxl_config_get_actag_info(struct pci_dev *dev, u16 *base, u16 *enabled,\n\t\t\tu16 *supported)\n{\n\tint rc;\n\n\t \n\trc = pnv_ocxl_get_actag(dev, base, enabled, supported);\n\tif (rc) {\n\t\tdev_err(&dev->dev, \"Can't get actag for device: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocxl_config_get_actag_info);\n\nvoid ocxl_config_set_afu_actag(struct pci_dev *dev, int pos, int actag_base,\n\t\t\tint actag_count)\n{\n\tu16 val;\n\n\tval = actag_count & OCXL_DVSEC_ACTAG_MASK;\n\tpci_write_config_byte(dev, pos + OCXL_DVSEC_AFU_CTRL_ACTAG_EN, val);\n\n\tval = actag_base & OCXL_DVSEC_ACTAG_MASK;\n\tpci_write_config_dword(dev, pos + OCXL_DVSEC_AFU_CTRL_ACTAG_BASE, val);\n}\nEXPORT_SYMBOL_GPL(ocxl_config_set_afu_actag);\n\nint ocxl_config_get_pasid_info(struct pci_dev *dev, int *count)\n{\n\treturn pnv_ocxl_get_pasid_count(dev, count);\n}\n\nvoid ocxl_config_set_afu_pasid(struct pci_dev *dev, int pos, int pasid_base,\n\t\t\tu32 pasid_count_log)\n{\n\tu8 val8;\n\tu32 val32;\n\n\tval8 = pasid_count_log & OCXL_DVSEC_PASID_LOG_MASK;\n\tpci_write_config_byte(dev, pos + OCXL_DVSEC_AFU_CTRL_PASID_EN, val8);\n\n\tpci_read_config_dword(dev, pos + OCXL_DVSEC_AFU_CTRL_PASID_BASE,\n\t\t\t&val32);\n\tval32 &= ~OCXL_DVSEC_PASID_MASK;\n\tval32 |= pasid_base & OCXL_DVSEC_PASID_MASK;\n\tpci_write_config_dword(dev, pos + OCXL_DVSEC_AFU_CTRL_PASID_BASE,\n\t\t\tval32);\n}\nEXPORT_SYMBOL_GPL(ocxl_config_set_afu_pasid);\n\nvoid ocxl_config_set_afu_state(struct pci_dev *dev, int pos, int enable)\n{\n\tu8 val;\n\n\tpci_read_config_byte(dev, pos + OCXL_DVSEC_AFU_CTRL_ENABLE, &val);\n\tif (enable)\n\t\tval |= 1;\n\telse\n\t\tval &= 0xFE;\n\tpci_write_config_byte(dev, pos + OCXL_DVSEC_AFU_CTRL_ENABLE, val);\n}\nEXPORT_SYMBOL_GPL(ocxl_config_set_afu_state);\n\nint ocxl_config_set_TL(struct pci_dev *dev, int tl_dvsec)\n{\n\tu32 val;\n\t__be32 *be32ptr;\n\tu8 timers;\n\tint i, rc;\n\tlong recv_cap;\n\tchar *recv_rate;\n\n\t \n\tif (PCI_FUNC(dev->devfn) != 0)\n\t\treturn 0;\n\n\trecv_rate = kzalloc(PNV_OCXL_TL_RATE_BUF_SIZE, GFP_KERNEL);\n\tif (!recv_rate)\n\t\treturn -ENOMEM;\n\t \n\n\t \n\trc = pnv_ocxl_get_tl_cap(dev, &recv_cap, recv_rate,\n\t\t\t\tPNV_OCXL_TL_RATE_BUF_SIZE);\n\tif (rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < PNV_OCXL_TL_RATE_BUF_SIZE; i += 4) {\n\t\tbe32ptr = (__be32 *) &recv_rate[i];\n\t\tpci_write_config_dword(dev,\n\t\t\t\ttl_dvsec + OCXL_DVSEC_TL_SEND_RATE + i,\n\t\t\t\tbe32_to_cpu(*be32ptr));\n\t}\n\tval = recv_cap >> 32;\n\tpci_write_config_dword(dev, tl_dvsec + OCXL_DVSEC_TL_SEND_CAP, val);\n\tval = recv_cap & GENMASK(31, 0);\n\tpci_write_config_dword(dev, tl_dvsec + OCXL_DVSEC_TL_SEND_CAP + 4, val);\n\n\t \n\tfor (i = 0; i < PNV_OCXL_TL_RATE_BUF_SIZE; i += 4) {\n\t\tpci_read_config_dword(dev,\n\t\t\t\ttl_dvsec + OCXL_DVSEC_TL_RECV_RATE + i,\n\t\t\t\t&val);\n\t\tbe32ptr = (__be32 *) &recv_rate[i];\n\t\t*be32ptr = cpu_to_be32(val);\n\t}\n\tpci_read_config_dword(dev, tl_dvsec + OCXL_DVSEC_TL_RECV_CAP, &val);\n\trecv_cap = (long) val << 32;\n\tpci_read_config_dword(dev, tl_dvsec + OCXL_DVSEC_TL_RECV_CAP + 4, &val);\n\trecv_cap |= val;\n\n\trc = pnv_ocxl_set_tl_conf(dev, recv_cap, __pa(recv_rate),\n\t\t\t\tPNV_OCXL_TL_RATE_BUF_SIZE);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\ttimers = 0x2 << 4;  \n\tpci_write_config_byte(dev, tl_dvsec + OCXL_DVSEC_TL_BACKOFF_TIMERS,\n\t\t\ttimers);\n\n\trc = 0;\nout:\n\tkfree(recv_rate);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ocxl_config_set_TL);\n\nint ocxl_config_terminate_pasid(struct pci_dev *dev, int afu_control, int pasid)\n{\n\tu32 val;\n\tunsigned long timeout;\n\n\tpci_read_config_dword(dev, afu_control + OCXL_DVSEC_AFU_CTRL_TERM_PASID,\n\t\t\t&val);\n\tif (EXTRACT_BIT(val, 20)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Can't terminate PASID %#x, previous termination didn't complete\\n\",\n\t\t\tpasid);\n\t\treturn -EBUSY;\n\t}\n\n\tval &= ~OCXL_DVSEC_PASID_MASK;\n\tval |= pasid & OCXL_DVSEC_PASID_MASK;\n\tval |= BIT(20);\n\tpci_write_config_dword(dev,\n\t\t\tafu_control + OCXL_DVSEC_AFU_CTRL_TERM_PASID,\n\t\t\tval);\n\n\ttimeout = jiffies + (HZ * OCXL_CFG_TIMEOUT);\n\tpci_read_config_dword(dev, afu_control + OCXL_DVSEC_AFU_CTRL_TERM_PASID,\n\t\t\t&val);\n\twhile (EXTRACT_BIT(val, 20)) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"Timeout while waiting for AFU to terminate PASID %#x\\n\",\n\t\t\t\tpasid);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tcpu_relax();\n\t\tpci_read_config_dword(dev,\n\t\t\t\tafu_control + OCXL_DVSEC_AFU_CTRL_TERM_PASID,\n\t\t\t\t&val);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocxl_config_terminate_pasid);\n\nvoid ocxl_config_set_actag(struct pci_dev *dev, int func_dvsec, u32 tag_first,\n\t\t\tu32 tag_count)\n{\n\tu32 val;\n\n\tval = (tag_first & OCXL_DVSEC_ACTAG_MASK) << 16;\n\tval |= tag_count & OCXL_DVSEC_ACTAG_MASK;\n\tpci_write_config_dword(dev, func_dvsec + OCXL_DVSEC_FUNC_OFF_ACTAG,\n\t\t\tval);\n}\nEXPORT_SYMBOL_GPL(ocxl_config_set_actag);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}