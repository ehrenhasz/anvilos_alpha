{
  "module_name": "smpro-errmon.c",
  "hash_id": "a88024e1bea7af6d96bb4ca47922765a2e4ad80429d92926598768c257950739",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/smpro-errmon.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define GPI_RAS_ERR\t\t0x7E\n\n \n#define CORE_CE_ERR_CNT\t\t0x80\n#define CORE_CE_ERR_LEN\t\t0x81\n#define CORE_CE_ERR_DATA\t0x82\n#define CORE_UE_ERR_CNT\t\t0x83\n#define CORE_UE_ERR_LEN\t\t0x84\n#define CORE_UE_ERR_DATA\t0x85\n\n \n#define MEM_CE_ERR_CNT\t\t0x90\n#define MEM_CE_ERR_LEN\t\t0x91\n#define MEM_CE_ERR_DATA\t\t0x92\n#define MEM_UE_ERR_CNT\t\t0x93\n#define MEM_UE_ERR_LEN\t\t0x94\n#define MEM_UE_ERR_DATA\t\t0x95\n\n \n#define ERR_SMPRO_TYPE\t\t0xA0\n#define ERR_PMPRO_TYPE\t\t0xA1\n#define ERR_SMPRO_INFO_LO\t0xA2\n#define ERR_SMPRO_INFO_HI\t0xA3\n#define ERR_SMPRO_DATA_LO\t0xA4\n#define ERR_SMPRO_DATA_HI\t0xA5\n#define WARN_SMPRO_INFO_LO\t0xAA\n#define WARN_SMPRO_INFO_HI\t0xAB\n#define ERR_PMPRO_INFO_LO\t0xA6\n#define ERR_PMPRO_INFO_HI\t0xA7\n#define ERR_PMPRO_DATA_LO\t0xA8\n#define ERR_PMPRO_DATA_HI\t0xA9\n#define WARN_PMPRO_INFO_LO\t0xAC\n#define WARN_PMPRO_INFO_HI\t0xAD\n\n \n#define BOOTSTAGE\t\t0xB0\n#define DIMM_SYNDROME_SEL\t0xB4\n#define DIMM_SYNDROME_ERR\t0xB5\n#define DIMM_SYNDROME_STAGE\t4\n\n \n#define PCIE_CE_ERR_CNT\t\t0xC0\n#define PCIE_CE_ERR_LEN\t\t0xC1\n#define PCIE_CE_ERR_DATA\t0xC2\n#define PCIE_UE_ERR_CNT\t\t0xC3\n#define PCIE_UE_ERR_LEN\t\t0xC4\n#define PCIE_UE_ERR_DATA\t0xC5\n\n \n#define OTHER_CE_ERR_CNT\t0xD0\n#define OTHER_CE_ERR_LEN\t0xD1\n#define OTHER_CE_ERR_DATA\t0xD2\n#define OTHER_UE_ERR_CNT\t0xD8\n#define OTHER_UE_ERR_LEN\t0xD9\n#define OTHER_UE_ERR_DATA\t0xDA\n\n \n#define VRD_WARN_FAULT_EVENT_DATA\t0x78\n#define VRD_HOT_EVENT_DATA\t\t0x79\n#define DIMM_HOT_EVENT_DATA\t\t0x7A\n#define DIMM_2X_REFRESH_EVENT_DATA\t0x96\n\n#define MAX_READ_BLOCK_LENGTH\t48\n\n#define RAS_SMPRO_ERR\t\t0\n#define RAS_PMPRO_ERR\t\t1\n\nenum RAS_48BYTES_ERR_TYPES {\n\tCORE_CE_ERR,\n\tCORE_UE_ERR,\n\tMEM_CE_ERR,\n\tMEM_UE_ERR,\n\tPCIE_CE_ERR,\n\tPCIE_UE_ERR,\n\tOTHER_CE_ERR,\n\tOTHER_UE_ERR,\n\tNUM_48BYTES_ERR_TYPE,\n};\n\nstruct smpro_error_hdr {\n\tu8 count;\t \n\tu8 len;\t\t \n\tu8 data;\t \n\tu8 max_cnt;\t \n};\n\n \nstatic struct smpro_error_hdr smpro_error_table[] = {\n\t[CORE_CE_ERR] = {\n\t\t.count = CORE_CE_ERR_CNT,\n\t\t.len = CORE_CE_ERR_LEN,\n\t\t.data = CORE_CE_ERR_DATA,\n\t\t.max_cnt = 32\n\t},\n\t[CORE_UE_ERR] = {\n\t\t.count = CORE_UE_ERR_CNT,\n\t\t.len = CORE_UE_ERR_LEN,\n\t\t.data = CORE_UE_ERR_DATA,\n\t\t.max_cnt = 32\n\t},\n\t[MEM_CE_ERR] = {\n\t\t.count = MEM_CE_ERR_CNT,\n\t\t.len = MEM_CE_ERR_LEN,\n\t\t.data = MEM_CE_ERR_DATA,\n\t\t.max_cnt = 16\n\t},\n\t[MEM_UE_ERR] = {\n\t\t.count = MEM_UE_ERR_CNT,\n\t\t.len = MEM_UE_ERR_LEN,\n\t\t.data = MEM_UE_ERR_DATA,\n\t\t.max_cnt = 16\n\t},\n\t[PCIE_CE_ERR] = {\n\t\t.count = PCIE_CE_ERR_CNT,\n\t\t.len = PCIE_CE_ERR_LEN,\n\t\t.data = PCIE_CE_ERR_DATA,\n\t\t.max_cnt = 96\n\t},\n\t[PCIE_UE_ERR] = {\n\t\t.count = PCIE_UE_ERR_CNT,\n\t\t.len = PCIE_UE_ERR_LEN,\n\t\t.data = PCIE_UE_ERR_DATA,\n\t\t.max_cnt = 96\n\t},\n\t[OTHER_CE_ERR] = {\n\t\t.count = OTHER_CE_ERR_CNT,\n\t\t.len = OTHER_CE_ERR_LEN,\n\t\t.data = OTHER_CE_ERR_DATA,\n\t\t.max_cnt = 8\n\t},\n\t[OTHER_UE_ERR] = {\n\t\t.count = OTHER_UE_ERR_CNT,\n\t\t.len = OTHER_UE_ERR_LEN,\n\t\t.data = OTHER_UE_ERR_DATA,\n\t\t.max_cnt = 8\n\t},\n};\n\n \nstruct smpro_int_error_hdr {\n\tu8 type;\n\tu8 info_l;\n\tu8 info_h;\n\tu8 data_l;\n\tu8 data_h;\n\tu8 warn_l;\n\tu8 warn_h;\n};\n\nstatic struct smpro_int_error_hdr list_smpro_int_error_hdr[] = {\n\t[RAS_SMPRO_ERR] = {\n\t\t.type = ERR_SMPRO_TYPE,\n\t\t.info_l = ERR_SMPRO_INFO_LO,\n\t\t.info_h = ERR_SMPRO_INFO_HI,\n\t\t.data_l = ERR_SMPRO_DATA_LO,\n\t\t.data_h = ERR_SMPRO_DATA_HI,\n\t\t.warn_l = WARN_SMPRO_INFO_LO,\n\t\t.warn_h = WARN_SMPRO_INFO_HI,\n\t},\n\t[RAS_PMPRO_ERR] = {\n\t\t.type = ERR_PMPRO_TYPE,\n\t\t.info_l = ERR_PMPRO_INFO_LO,\n\t\t.info_h = ERR_PMPRO_INFO_HI,\n\t\t.data_l = ERR_PMPRO_DATA_LO,\n\t\t.data_h = ERR_PMPRO_DATA_HI,\n\t\t.warn_l = WARN_PMPRO_INFO_LO,\n\t\t.warn_h = WARN_PMPRO_INFO_HI,\n\t},\n};\n\nstruct smpro_errmon {\n\tstruct regmap *regmap;\n};\n\nenum EVENT_TYPES {\n\tVRD_WARN_FAULT_EVENT,\n\tVRD_HOT_EVENT,\n\tDIMM_HOT_EVENT,\n\tDIMM_2X_REFRESH_EVENT,\n\tNUM_EVENTS_TYPE,\n};\n\n \nstatic u8 smpro_event_table[NUM_EVENTS_TYPE] = {\n\tVRD_WARN_FAULT_EVENT_DATA,\n\tVRD_HOT_EVENT_DATA,\n\tDIMM_HOT_EVENT_DATA,\n\tDIMM_2X_REFRESH_EVENT_DATA,\n};\n\nstatic ssize_t smpro_event_data_read(struct device *dev,\n\t\t\t\t     struct device_attribute *da, char *buf,\n\t\t\t\t     int channel)\n{\n\tstruct smpro_errmon *errmon = dev_get_drvdata(dev);\n\ts32 event_data;\n\tint ret;\n\n\tret = regmap_read(errmon->regmap, smpro_event_table[channel], &event_data);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (event_data != 0)\n\t\tregmap_write(errmon->regmap, smpro_event_table[channel], event_data);\n\n\treturn sysfs_emit(buf, \"%04x\\n\", event_data);\n}\n\nstatic ssize_t smpro_overflow_data_read(struct device *dev, struct device_attribute *da,\n\t\t\t\t\tchar *buf, int channel)\n{\n\tstruct smpro_errmon *errmon = dev_get_drvdata(dev);\n\tstruct smpro_error_hdr *err_info;\n\ts32 err_count;\n\tint ret;\n\n\terr_info = &smpro_error_table[channel];\n\n\tret = regmap_read(errmon->regmap, err_info->count, &err_count);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn sysfs_emit(buf, \"%d\\n\", (err_count & BIT(8)) ? 1 : 0);\n}\n\nstatic ssize_t smpro_error_data_read(struct device *dev, struct device_attribute *da,\n\t\t\t\t     char *buf, int channel)\n{\n\tstruct smpro_errmon *errmon = dev_get_drvdata(dev);\n\tunsigned char err_data[MAX_READ_BLOCK_LENGTH];\n\tstruct smpro_error_hdr *err_info;\n\ts32 err_count, err_length;\n\tint ret;\n\n\terr_info = &smpro_error_table[channel];\n\n\tret = regmap_read(errmon->regmap, err_info->count, &err_count);\n\t \n\terr_count &= 0xff;\n\tif (ret || !err_count || err_count > err_info->max_cnt)\n\t\treturn ret;\n\n\tret = regmap_read(errmon->regmap, err_info->len, &err_length);\n\tif (ret || err_length <= 0)\n\t\treturn ret;\n\n\tif (err_length > MAX_READ_BLOCK_LENGTH)\n\t\terr_length = MAX_READ_BLOCK_LENGTH;\n\n\tmemset(err_data, 0x00, MAX_READ_BLOCK_LENGTH);\n\tret = regmap_noinc_read(errmon->regmap, err_info->data, err_data, err_length);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(errmon->regmap, err_info->count, 0x100);\n\tif (ret)\n\t\treturn ret;\n\t \n\treturn sysfs_emit(buf, \"%*phN\\n\", MAX_READ_BLOCK_LENGTH, err_data);\n}\n\n \nstatic ssize_t smpro_internal_err_read(struct device *dev, struct device_attribute *da,\n\t\t\t\t       char *buf, int channel)\n{\n\tstruct smpro_errmon *errmon = dev_get_drvdata(dev);\n\tstruct smpro_int_error_hdr *err_info;\n\tunsigned int err[4] = { 0 };\n\tunsigned int err_type;\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_read(errmon->regmap, GPI_RAS_ERR, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((channel == RAS_SMPRO_ERR && !(val & BIT(0))) ||\n\t    (channel == RAS_PMPRO_ERR && !(val & BIT(1))))\n\t\treturn 0;\n\n\terr_info = &list_smpro_int_error_hdr[channel];\n\tret = regmap_read(errmon->regmap, err_info->type, &val);\n\tif (ret)\n\t\treturn ret;\n\n\terr_type = (val & BIT(1)) ? BIT(1) :\n\t\t   (val & BIT(2)) ? BIT(2) : 0;\n\n\tif (!err_type)\n\t\treturn 0;\n\n\tret = regmap_read(errmon->regmap, err_info->info_l, err + 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(errmon->regmap, err_info->info_h, err);\n\tif (ret)\n\t\treturn ret;\n\n\tif (err_type & BIT(2)) {\n\t\t \n\t\tret = regmap_read(errmon->regmap, err_info->data_l, err + 3);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_read(errmon->regmap, err_info->data_h, err + 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(errmon->regmap, err_info->type, err_type);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%*phN\\n\", (int)sizeof(err), err);\n}\n\n \nstatic ssize_t smpro_internal_warn_read(struct device *dev, struct device_attribute *da,\n\t\t\t\t\tchar *buf, int channel)\n{\n\tstruct smpro_errmon *errmon = dev_get_drvdata(dev);\n\tstruct smpro_int_error_hdr *err_info;\n\tunsigned int warn[2] = { 0 };\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_read(errmon->regmap, GPI_RAS_ERR, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((channel == RAS_SMPRO_ERR && !(val & BIT(0))) ||\n\t    (channel == RAS_PMPRO_ERR && !(val & BIT(1))))\n\t\treturn 0;\n\n\terr_info = &list_smpro_int_error_hdr[channel];\n\tret = regmap_read(errmon->regmap, err_info->type, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(val & BIT(0)))\n\t\treturn 0;\n\n\tret = regmap_read(errmon->regmap, err_info->warn_l, warn + 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(errmon->regmap, err_info->warn_h, warn);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(errmon->regmap, err_info->type, BIT(0));\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%*phN\\n\", (int)sizeof(warn), warn);\n}\n\n#define ERROR_OVERFLOW_RO(_error, _index) \\\n\tstatic ssize_t overflow_##_error##_show(struct device *dev,            \\\n\t\t\t\t\t\tstruct device_attribute *da,   \\\n\t\t\t\t\t\tchar *buf)                     \\\n\t{                                                                      \\\n\t\treturn smpro_overflow_data_read(dev, da, buf, _index);         \\\n\t}                                                                      \\\n\tstatic DEVICE_ATTR_RO(overflow_##_error)\n\nERROR_OVERFLOW_RO(core_ce, CORE_CE_ERR);\nERROR_OVERFLOW_RO(core_ue, CORE_UE_ERR);\nERROR_OVERFLOW_RO(mem_ce, MEM_CE_ERR);\nERROR_OVERFLOW_RO(mem_ue, MEM_UE_ERR);\nERROR_OVERFLOW_RO(pcie_ce, PCIE_CE_ERR);\nERROR_OVERFLOW_RO(pcie_ue, PCIE_UE_ERR);\nERROR_OVERFLOW_RO(other_ce, OTHER_CE_ERR);\nERROR_OVERFLOW_RO(other_ue, OTHER_UE_ERR);\n\n#define ERROR_RO(_error, _index) \\\n\tstatic ssize_t error_##_error##_show(struct device *dev,            \\\n\t\t\t\t\t     struct device_attribute *da,   \\\n\t\t\t\t\t     char *buf)                     \\\n\t{                                                                   \\\n\t\treturn smpro_error_data_read(dev, da, buf, _index);         \\\n\t}                                                                   \\\n\tstatic DEVICE_ATTR_RO(error_##_error)\n\nERROR_RO(core_ce, CORE_CE_ERR);\nERROR_RO(core_ue, CORE_UE_ERR);\nERROR_RO(mem_ce, MEM_CE_ERR);\nERROR_RO(mem_ue, MEM_UE_ERR);\nERROR_RO(pcie_ce, PCIE_CE_ERR);\nERROR_RO(pcie_ue, PCIE_UE_ERR);\nERROR_RO(other_ce, OTHER_CE_ERR);\nERROR_RO(other_ue, OTHER_UE_ERR);\n\nstatic ssize_t error_smpro_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\treturn smpro_internal_err_read(dev, da, buf, RAS_SMPRO_ERR);\n}\nstatic DEVICE_ATTR_RO(error_smpro);\n\nstatic ssize_t error_pmpro_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\treturn smpro_internal_err_read(dev, da, buf, RAS_PMPRO_ERR);\n}\nstatic DEVICE_ATTR_RO(error_pmpro);\n\nstatic ssize_t warn_smpro_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\treturn smpro_internal_warn_read(dev, da, buf, RAS_SMPRO_ERR);\n}\nstatic DEVICE_ATTR_RO(warn_smpro);\n\nstatic ssize_t warn_pmpro_show(struct device *dev, struct device_attribute *da, char *buf)\n{\n\treturn smpro_internal_warn_read(dev, da, buf, RAS_PMPRO_ERR);\n}\nstatic DEVICE_ATTR_RO(warn_pmpro);\n\n#define EVENT_RO(_event, _index) \\\n\tstatic ssize_t event_##_event##_show(struct device *dev,            \\\n\t\t\t\t\t     struct device_attribute *da,   \\\n\t\t\t\t\t     char *buf)                     \\\n\t{                                                                   \\\n\t\treturn smpro_event_data_read(dev, da, buf, _index);         \\\n\t}                                                                   \\\n\tstatic DEVICE_ATTR_RO(event_##_event)\n\nEVENT_RO(vrd_warn_fault, VRD_WARN_FAULT_EVENT);\nEVENT_RO(vrd_hot, VRD_HOT_EVENT);\nEVENT_RO(dimm_hot, DIMM_HOT_EVENT);\nEVENT_RO(dimm_2x_refresh, DIMM_2X_REFRESH_EVENT);\n\nstatic ssize_t smpro_dimm_syndrome_read(struct device *dev, struct device_attribute *da,\n\t\t\t\t\tchar *buf, unsigned int slot)\n{\n\tstruct smpro_errmon *errmon = dev_get_drvdata(dev);\n\tunsigned int data;\n\tint ret;\n\n\tret = regmap_read(errmon->regmap, BOOTSTAGE, &data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdata = (data >> 8) & 0xff;\n\tif (data != DIMM_SYNDROME_STAGE)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(errmon->regmap, DIMM_SYNDROME_SEL, slot);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(errmon->regmap, DIMM_SYNDROME_ERR, &data);\n\tif (ret || !data)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%04x\\n\", data);\n}\n\n#define EVENT_DIMM_SYNDROME(_slot) \\\n\tstatic ssize_t event_dimm##_slot##_syndrome_show(struct device *dev,          \\\n\t\t\t\t\t\t\t struct device_attribute *da, \\\n\t\t\t\t\t\t\t char *buf)                   \\\n\t{                                                                             \\\n\t\treturn smpro_dimm_syndrome_read(dev, da, buf, _slot);                 \\\n\t}                                                                             \\\n\tstatic DEVICE_ATTR_RO(event_dimm##_slot##_syndrome)\n\nEVENT_DIMM_SYNDROME(0);\nEVENT_DIMM_SYNDROME(1);\nEVENT_DIMM_SYNDROME(2);\nEVENT_DIMM_SYNDROME(3);\nEVENT_DIMM_SYNDROME(4);\nEVENT_DIMM_SYNDROME(5);\nEVENT_DIMM_SYNDROME(6);\nEVENT_DIMM_SYNDROME(7);\nEVENT_DIMM_SYNDROME(8);\nEVENT_DIMM_SYNDROME(9);\nEVENT_DIMM_SYNDROME(10);\nEVENT_DIMM_SYNDROME(11);\nEVENT_DIMM_SYNDROME(12);\nEVENT_DIMM_SYNDROME(13);\nEVENT_DIMM_SYNDROME(14);\nEVENT_DIMM_SYNDROME(15);\n\nstatic struct attribute *smpro_errmon_attrs[] = {\n\t&dev_attr_overflow_core_ce.attr,\n\t&dev_attr_overflow_core_ue.attr,\n\t&dev_attr_overflow_mem_ce.attr,\n\t&dev_attr_overflow_mem_ue.attr,\n\t&dev_attr_overflow_pcie_ce.attr,\n\t&dev_attr_overflow_pcie_ue.attr,\n\t&dev_attr_overflow_other_ce.attr,\n\t&dev_attr_overflow_other_ue.attr,\n\t&dev_attr_error_core_ce.attr,\n\t&dev_attr_error_core_ue.attr,\n\t&dev_attr_error_mem_ce.attr,\n\t&dev_attr_error_mem_ue.attr,\n\t&dev_attr_error_pcie_ce.attr,\n\t&dev_attr_error_pcie_ue.attr,\n\t&dev_attr_error_other_ce.attr,\n\t&dev_attr_error_other_ue.attr,\n\t&dev_attr_error_smpro.attr,\n\t&dev_attr_error_pmpro.attr,\n\t&dev_attr_warn_smpro.attr,\n\t&dev_attr_warn_pmpro.attr,\n\t&dev_attr_event_vrd_warn_fault.attr,\n\t&dev_attr_event_vrd_hot.attr,\n\t&dev_attr_event_dimm_hot.attr,\n\t&dev_attr_event_dimm_2x_refresh.attr,\n\t&dev_attr_event_dimm0_syndrome.attr,\n\t&dev_attr_event_dimm1_syndrome.attr,\n\t&dev_attr_event_dimm2_syndrome.attr,\n\t&dev_attr_event_dimm3_syndrome.attr,\n\t&dev_attr_event_dimm4_syndrome.attr,\n\t&dev_attr_event_dimm5_syndrome.attr,\n\t&dev_attr_event_dimm6_syndrome.attr,\n\t&dev_attr_event_dimm7_syndrome.attr,\n\t&dev_attr_event_dimm8_syndrome.attr,\n\t&dev_attr_event_dimm9_syndrome.attr,\n\t&dev_attr_event_dimm10_syndrome.attr,\n\t&dev_attr_event_dimm11_syndrome.attr,\n\t&dev_attr_event_dimm12_syndrome.attr,\n\t&dev_attr_event_dimm13_syndrome.attr,\n\t&dev_attr_event_dimm14_syndrome.attr,\n\t&dev_attr_event_dimm15_syndrome.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(smpro_errmon);\n\nstatic int smpro_errmon_probe(struct platform_device *pdev)\n{\n\tstruct smpro_errmon *errmon;\n\n\terrmon = devm_kzalloc(&pdev->dev, sizeof(struct smpro_errmon), GFP_KERNEL);\n\tif (!errmon)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, errmon);\n\n\terrmon->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!errmon->regmap)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct platform_driver smpro_errmon_driver = {\n\t.probe          = smpro_errmon_probe,\n\t.driver = {\n\t\t.name   = \"smpro-errmon\",\n\t\t.dev_groups = smpro_errmon_groups,\n\t},\n};\n\nmodule_platform_driver(smpro_errmon_driver);\n\nMODULE_AUTHOR(\"Tung Nguyen <tung.nguyen@amperecomputing.com>\");\nMODULE_AUTHOR(\"Thinh Pham <thinh.pham@amperecomputing.com>\");\nMODULE_AUTHOR(\"Hoang Nguyen <hnguyen@amperecomputing.com>\");\nMODULE_AUTHOR(\"Thu Nguyen <thu@os.amperecomputing.com>\");\nMODULE_AUTHOR(\"Quan Nguyen <quan@os.amperecomputing.com>\");\nMODULE_DESCRIPTION(\"Ampere Altra SMpro driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}