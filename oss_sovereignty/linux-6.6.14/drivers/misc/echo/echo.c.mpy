{
  "module_name": "echo.c",
  "hash_id": "1f451e8e0ca550b764aa9bb680524468ceb6f5006c3a6f16d7e313809b7c16bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/echo/echo.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"echo.h\"\n\n#define MIN_TX_POWER_FOR_ADAPTION\t64\n#define MIN_RX_POWER_FOR_ADAPTION\t64\n#define DTD_HANGOVER\t\t\t600\t \n#define DC_LOG2BETA\t\t\t3\t \n\n \n\nstatic inline void lms_adapt_bg(struct oslec_state *ec, int clean, int shift)\n{\n\tint i;\n\n\tint offset1;\n\tint offset2;\n\tint factor;\n\tint exp;\n\n\tif (shift > 0)\n\t\tfactor = clean << shift;\n\telse\n\t\tfactor = clean >> -shift;\n\n\t \n\n\toffset2 = ec->curr_pos;\n\toffset1 = ec->taps - offset2;\n\n\tfor (i = ec->taps - 1; i >= offset1; i--) {\n\t\texp = (ec->fir_state_bg.history[i - offset1] * factor);\n\t\tec->fir_taps16[1][i] += (int16_t) ((exp + (1 << 14)) >> 15);\n\t}\n\tfor (; i >= 0; i--) {\n\t\texp = (ec->fir_state_bg.history[i + offset2] * factor);\n\t\tec->fir_taps16[1][i] += (int16_t) ((exp + (1 << 14)) >> 15);\n\t}\n}\n\nstatic inline int top_bit(unsigned int bits)\n{\n\tif (bits == 0)\n\t\treturn -1;\n\telse\n\t\treturn (int)fls((int32_t) bits) - 1;\n}\n\nstruct oslec_state *oslec_create(int len, int adaption_mode)\n{\n\tstruct oslec_state *ec;\n\tint i;\n\tconst int16_t *history;\n\n\tec = kzalloc(sizeof(*ec), GFP_KERNEL);\n\tif (!ec)\n\t\treturn NULL;\n\n\tec->taps = len;\n\tec->log2taps = top_bit(len);\n\tec->curr_pos = ec->taps - 1;\n\n\tec->fir_taps16[0] =\n\t    kcalloc(ec->taps, sizeof(int16_t), GFP_KERNEL);\n\tif (!ec->fir_taps16[0])\n\t\tgoto error_oom_0;\n\n\tec->fir_taps16[1] =\n\t    kcalloc(ec->taps, sizeof(int16_t), GFP_KERNEL);\n\tif (!ec->fir_taps16[1])\n\t\tgoto error_oom_1;\n\n\thistory = fir16_create(&ec->fir_state, ec->fir_taps16[0], ec->taps);\n\tif (!history)\n\t\tgoto error_state;\n\thistory = fir16_create(&ec->fir_state_bg, ec->fir_taps16[1], ec->taps);\n\tif (!history)\n\t\tgoto error_state_bg;\n\n\tfor (i = 0; i < 5; i++)\n\t\tec->xvtx[i] = ec->yvtx[i] = ec->xvrx[i] = ec->yvrx[i] = 0;\n\n\tec->cng_level = 1000;\n\toslec_adaption_mode(ec, adaption_mode);\n\n\tec->snapshot = kcalloc(ec->taps, sizeof(int16_t), GFP_KERNEL);\n\tif (!ec->snapshot)\n\t\tgoto error_snap;\n\n\tec->cond_met = 0;\n\tec->pstates = 0;\n\tec->ltxacc = ec->lrxacc = ec->lcleanacc = ec->lclean_bgacc = 0;\n\tec->ltx = ec->lrx = ec->lclean = ec->lclean_bg = 0;\n\tec->tx_1 = ec->tx_2 = ec->rx_1 = ec->rx_2 = 0;\n\tec->lbgn = ec->lbgn_acc = 0;\n\tec->lbgn_upper = 200;\n\tec->lbgn_upper_acc = ec->lbgn_upper << 13;\n\n\treturn ec;\n\nerror_snap:\n\tfir16_free(&ec->fir_state_bg);\nerror_state_bg:\n\tfir16_free(&ec->fir_state);\nerror_state:\n\tkfree(ec->fir_taps16[1]);\nerror_oom_1:\n\tkfree(ec->fir_taps16[0]);\nerror_oom_0:\n\tkfree(ec);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(oslec_create);\n\nvoid oslec_free(struct oslec_state *ec)\n{\n\tint i;\n\n\tfir16_free(&ec->fir_state);\n\tfir16_free(&ec->fir_state_bg);\n\tfor (i = 0; i < 2; i++)\n\t\tkfree(ec->fir_taps16[i]);\n\tkfree(ec->snapshot);\n\tkfree(ec);\n}\nEXPORT_SYMBOL_GPL(oslec_free);\n\nvoid oslec_adaption_mode(struct oslec_state *ec, int adaption_mode)\n{\n\tec->adaption_mode = adaption_mode;\n}\nEXPORT_SYMBOL_GPL(oslec_adaption_mode);\n\nvoid oslec_flush(struct oslec_state *ec)\n{\n\tint i;\n\n\tec->ltxacc = ec->lrxacc = ec->lcleanacc = ec->lclean_bgacc = 0;\n\tec->ltx = ec->lrx = ec->lclean = ec->lclean_bg = 0;\n\tec->tx_1 = ec->tx_2 = ec->rx_1 = ec->rx_2 = 0;\n\n\tec->lbgn = ec->lbgn_acc = 0;\n\tec->lbgn_upper = 200;\n\tec->lbgn_upper_acc = ec->lbgn_upper << 13;\n\n\tec->nonupdate_dwell = 0;\n\n\tfir16_flush(&ec->fir_state);\n\tfir16_flush(&ec->fir_state_bg);\n\tec->fir_state.curr_pos = ec->taps - 1;\n\tec->fir_state_bg.curr_pos = ec->taps - 1;\n\tfor (i = 0; i < 2; i++)\n\t\tmemset(ec->fir_taps16[i], 0, ec->taps * sizeof(int16_t));\n\n\tec->curr_pos = ec->taps - 1;\n\tec->pstates = 0;\n}\nEXPORT_SYMBOL_GPL(oslec_flush);\n\nvoid oslec_snapshot(struct oslec_state *ec)\n{\n\tmemcpy(ec->snapshot, ec->fir_taps16[0], ec->taps * sizeof(int16_t));\n}\nEXPORT_SYMBOL_GPL(oslec_snapshot);\n\n \n\nint16_t oslec_update(struct oslec_state *ec, int16_t tx, int16_t rx)\n{\n\tint32_t echo_value;\n\tint clean_bg;\n\tint tmp;\n\tint tmp1;\n\n\t \n\n\tec->tx = tx;\n\tec->rx = rx;\n\ttx >>= 1;\n\trx >>= 1;\n\n\t \n\n\tif (ec->adaption_mode & ECHO_CAN_USE_RX_HPF) {\n\t\ttmp = rx << 15;\n\n\t\t \n\t\ttmp -= (tmp >> 4);\n\n\t\tec->rx_1 += -(ec->rx_1 >> DC_LOG2BETA) + tmp - ec->rx_2;\n\n\t\t \n\t\ttmp1 = ec->rx_1 >> 15;\n\t\tif (tmp1 > 16383)\n\t\t\ttmp1 = 16383;\n\t\tif (tmp1 < -16383)\n\t\t\ttmp1 = -16383;\n\t\trx = tmp1;\n\t\tec->rx_2 = tmp;\n\t}\n\n\t \n\n\t{\n\t\tint new, old;\n\n\t\t \n\t\tnew = (int)tx * (int)tx;\n\t\told = (int)ec->fir_state.history[ec->fir_state.curr_pos] *\n\t\t    (int)ec->fir_state.history[ec->fir_state.curr_pos];\n\t\tec->pstates +=\n\t\t    ((new - old) + (1 << (ec->log2taps - 1))) >> ec->log2taps;\n\t\tif (ec->pstates < 0)\n\t\t\tec->pstates = 0;\n\t}\n\n\t \n\n\tec->ltxacc += abs(tx) - ec->ltx;\n\tec->ltx = (ec->ltxacc + (1 << 4)) >> 5;\n\tec->lrxacc += abs(rx) - ec->lrx;\n\tec->lrx = (ec->lrxacc + (1 << 4)) >> 5;\n\n\t \n\n\tec->fir_state.coeffs = ec->fir_taps16[0];\n\techo_value = fir16(&ec->fir_state, tx);\n\tec->clean = rx - echo_value;\n\tec->lcleanacc += abs(ec->clean) - ec->lclean;\n\tec->lclean = (ec->lcleanacc + (1 << 4)) >> 5;\n\n\t \n\n\techo_value = fir16(&ec->fir_state_bg, tx);\n\tclean_bg = rx - echo_value;\n\tec->lclean_bgacc += abs(clean_bg) - ec->lclean_bg;\n\tec->lclean_bg = (ec->lclean_bgacc + (1 << 4)) >> 5;\n\n\t \n\n\t \n\tec->factor = 0;\n\tec->shift = 0;\n\tif (!ec->nonupdate_dwell) {\n\t\tint p, logp, shift;\n\n\t\t \n\n\t\tp = MIN_TX_POWER_FOR_ADAPTION + ec->pstates;\n\t\tlogp = top_bit(p) + ec->log2taps;\n\t\tshift = 30 - 2 - logp;\n\t\tec->shift = shift;\n\n\t\tlms_adapt_bg(ec, clean_bg, shift);\n\t}\n\n\t \n\n\tec->adapt = 0;\n\tif ((ec->lrx > MIN_RX_POWER_FOR_ADAPTION) && (ec->lrx > ec->ltx))\n\t\tec->nonupdate_dwell = DTD_HANGOVER;\n\tif (ec->nonupdate_dwell)\n\t\tec->nonupdate_dwell--;\n\n\t \n\n\t \n\n\tif ((ec->adaption_mode & ECHO_CAN_USE_ADAPTION) &&\n\t    (ec->nonupdate_dwell == 0) &&\n\t     \n\t    (8 * ec->lclean_bg < 7 * ec->lclean) &&\n\t     \n\t    (8 * ec->lclean_bg < ec->ltx)) {\n\t\tif (ec->cond_met == 6) {\n\t\t\t \n\t\t\tec->adapt = 1;\n\t\t\tmemcpy(ec->fir_taps16[0], ec->fir_taps16[1],\n\t\t\t       ec->taps * sizeof(int16_t));\n\t\t} else\n\t\t\tec->cond_met++;\n\t} else\n\t\tec->cond_met = 0;\n\n\t \n\n\tec->clean_nlp = ec->clean;\n\tif (ec->adaption_mode & ECHO_CAN_USE_NLP) {\n\t\t \n\n\t\tif ((16 * ec->lclean < ec->ltx)) {\n\t\t\t \n\t\t\tif (ec->adaption_mode & ECHO_CAN_USE_CNG) {\n\t\t\t\tec->cng_level = ec->lbgn;\n\n\t\t\t\t \n\n\t\t\t\tec->cng_rndnum =\n\t\t\t\t    1664525U * ec->cng_rndnum + 1013904223U;\n\t\t\t\tec->cng_filter =\n\t\t\t\t    ((ec->cng_rndnum & 0xFFFF) - 32768 +\n\t\t\t\t     5 * ec->cng_filter) >> 3;\n\t\t\t\tec->clean_nlp =\n\t\t\t\t    (ec->cng_filter * ec->cng_level * 8) >> 14;\n\n\t\t\t} else if (ec->adaption_mode & ECHO_CAN_USE_CLIP) {\n\t\t\t\t \n\t\t\t\tif (ec->clean_nlp > ec->lbgn)\n\t\t\t\t\tec->clean_nlp = ec->lbgn;\n\t\t\t\tif (ec->clean_nlp < -ec->lbgn)\n\t\t\t\t\tec->clean_nlp = -ec->lbgn;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tec->clean_nlp = 0;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (ec->lclean < 40) {\n\t\t\t\tec->lbgn_acc += abs(ec->clean) - ec->lbgn;\n\t\t\t\tec->lbgn = (ec->lbgn_acc + (1 << 11)) >> 12;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ec->curr_pos <= 0)\n\t\tec->curr_pos = ec->taps;\n\tec->curr_pos--;\n\n\tif (ec->adaption_mode & ECHO_CAN_DISABLE)\n\t\tec->clean_nlp = rx;\n\n\t \n\n\treturn (int16_t) ec->clean_nlp << 1;\n}\nEXPORT_SYMBOL_GPL(oslec_update);\n\n \n\nint16_t oslec_hpf_tx(struct oslec_state *ec, int16_t tx)\n{\n\tint tmp;\n\tint tmp1;\n\n\tif (ec->adaption_mode & ECHO_CAN_USE_TX_HPF) {\n\t\ttmp = tx << 15;\n\n\t\t \n\t\ttmp -= (tmp >> 4);\n\n\t\tec->tx_1 += -(ec->tx_1 >> DC_LOG2BETA) + tmp - ec->tx_2;\n\t\ttmp1 = ec->tx_1 >> 15;\n\t\tif (tmp1 > 32767)\n\t\t\ttmp1 = 32767;\n\t\tif (tmp1 < -32767)\n\t\t\ttmp1 = -32767;\n\t\ttx = tmp1;\n\t\tec->tx_2 = tmp;\n\t}\n\n\treturn tx;\n}\nEXPORT_SYMBOL_GPL(oslec_hpf_tx);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Rowe\");\nMODULE_DESCRIPTION(\"Open Source Line Echo Canceller\");\nMODULE_VERSION(\"0.3.0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}