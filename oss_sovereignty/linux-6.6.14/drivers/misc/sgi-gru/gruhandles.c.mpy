{
  "module_name": "gruhandles.c",
  "hash_id": "f4866f52d4c4a4304c09e418fa5f7b2422e834507f967cdef1c3af812a327f98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sgi-gru/gruhandles.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include \"gru.h\"\n#include \"grulib.h\"\n#include \"grutables.h\"\n\n \n#ifdef CONFIG_IA64\n#include <asm/processor.h>\n#define GRU_OPERATION_TIMEOUT\t(((cycles_t) local_cpu_data->itc_freq)*10)\n#define CLKS2NSEC(c)\t\t((c) *1000000000 / local_cpu_data->itc_freq)\n#else\n#include <linux/sync_core.h>\n#include <asm/tsc.h>\n#define GRU_OPERATION_TIMEOUT\t((cycles_t) tsc_khz*10*1000)\n#define CLKS2NSEC(c)\t\t((c) * 1000000 / tsc_khz)\n#endif\n\n \n#define GET_MSEG_HANDLE_STATUS(h)\t(((*(unsigned long *)(h)) >> 16) & 3)\n\nstruct mcs_op_statistic mcs_op_statistics[mcsop_last];\n\nstatic void update_mcs_stats(enum mcs_op op, unsigned long clks)\n{\n\tunsigned long nsec;\n\n\tnsec = CLKS2NSEC(clks);\n\tatomic_long_inc(&mcs_op_statistics[op].count);\n\tatomic_long_add(nsec, &mcs_op_statistics[op].total);\n\tif (mcs_op_statistics[op].max < nsec)\n\t\tmcs_op_statistics[op].max = nsec;\n}\n\nstatic void start_instruction(void *h)\n{\n\tunsigned long *w0 = h;\n\n\twmb();\t\t \n\t*w0 = *w0 | 0x20001;\n\tgru_flush_cache(h);\n}\n\nstatic void report_instruction_timeout(void *h)\n{\n\tunsigned long goff = GSEGPOFF((unsigned long)h);\n\tchar *id = \"???\";\n\n\tif (TYPE_IS(CCH, goff))\n\t\tid = \"CCH\";\n\telse if (TYPE_IS(TGH, goff))\n\t\tid = \"TGH\";\n\telse if (TYPE_IS(TFH, goff))\n\t\tid = \"TFH\";\n\n\tpanic(KERN_ALERT \"GRU %p (%s) is malfunctioning\\n\", h, id);\n}\n\nstatic int wait_instruction_complete(void *h, enum mcs_op opc)\n{\n\tint status;\n\tunsigned long start_time = get_cycles();\n\n\twhile (1) {\n\t\tcpu_relax();\n\t\tstatus = GET_MSEG_HANDLE_STATUS(h);\n\t\tif (status != CCHSTATUS_ACTIVE)\n\t\t\tbreak;\n\t\tif (GRU_OPERATION_TIMEOUT < (get_cycles() - start_time)) {\n\t\t\treport_instruction_timeout(h);\n\t\t\tstart_time = get_cycles();\n\t\t}\n\t}\n\tif (gru_options & OPT_STATS)\n\t\tupdate_mcs_stats(opc, get_cycles() - start_time);\n\treturn status;\n}\n\nint cch_allocate(struct gru_context_configuration_handle *cch)\n{\n\tint ret;\n\n\tcch->opc = CCHOP_ALLOCATE;\n\tstart_instruction(cch);\n\tret = wait_instruction_complete(cch, cchop_allocate);\n\n\t \n\tsync_core();\n\treturn ret;\n}\n\nint cch_start(struct gru_context_configuration_handle *cch)\n{\n\tcch->opc = CCHOP_START;\n\tstart_instruction(cch);\n\treturn wait_instruction_complete(cch, cchop_start);\n}\n\nint cch_interrupt(struct gru_context_configuration_handle *cch)\n{\n\tcch->opc = CCHOP_INTERRUPT;\n\tstart_instruction(cch);\n\treturn wait_instruction_complete(cch, cchop_interrupt);\n}\n\nint cch_deallocate(struct gru_context_configuration_handle *cch)\n{\n\tint ret;\n\n\tcch->opc = CCHOP_DEALLOCATE;\n\tstart_instruction(cch);\n\tret = wait_instruction_complete(cch, cchop_deallocate);\n\n\t \n\tsync_core();\n\treturn ret;\n}\n\nint cch_interrupt_sync(struct gru_context_configuration_handle\n\t\t\t\t     *cch)\n{\n\tcch->opc = CCHOP_INTERRUPT_SYNC;\n\tstart_instruction(cch);\n\treturn wait_instruction_complete(cch, cchop_interrupt_sync);\n}\n\nint tgh_invalidate(struct gru_tlb_global_handle *tgh,\n\t\t\t\t unsigned long vaddr, unsigned long vaddrmask,\n\t\t\t\t int asid, int pagesize, int global, int n,\n\t\t\t\t unsigned short ctxbitmap)\n{\n\ttgh->vaddr = vaddr;\n\ttgh->asid = asid;\n\ttgh->pagesize = pagesize;\n\ttgh->n = n;\n\ttgh->global = global;\n\ttgh->vaddrmask = vaddrmask;\n\ttgh->ctxbitmap = ctxbitmap;\n\ttgh->opc = TGHOP_TLBINV;\n\tstart_instruction(tgh);\n\treturn wait_instruction_complete(tgh, tghop_invalidate);\n}\n\nint tfh_write_only(struct gru_tlb_fault_handle *tfh,\n\t\t\t\t  unsigned long paddr, int gaa,\n\t\t\t\t  unsigned long vaddr, int asid, int dirty,\n\t\t\t\t  int pagesize)\n{\n\ttfh->fillasid = asid;\n\ttfh->fillvaddr = vaddr;\n\ttfh->pfn = paddr >> GRU_PADDR_SHIFT;\n\ttfh->gaa = gaa;\n\ttfh->dirty = dirty;\n\ttfh->pagesize = pagesize;\n\ttfh->opc = TFHOP_WRITE_ONLY;\n\tstart_instruction(tfh);\n\treturn wait_instruction_complete(tfh, tfhop_write_only);\n}\n\nvoid tfh_write_restart(struct gru_tlb_fault_handle *tfh,\n\t\t\t\t     unsigned long paddr, int gaa,\n\t\t\t\t     unsigned long vaddr, int asid, int dirty,\n\t\t\t\t     int pagesize)\n{\n\ttfh->fillasid = asid;\n\ttfh->fillvaddr = vaddr;\n\ttfh->pfn = paddr >> GRU_PADDR_SHIFT;\n\ttfh->gaa = gaa;\n\ttfh->dirty = dirty;\n\ttfh->pagesize = pagesize;\n\ttfh->opc = TFHOP_WRITE_RESTART;\n\tstart_instruction(tfh);\n}\n\nvoid tfh_user_polling_mode(struct gru_tlb_fault_handle *tfh)\n{\n\ttfh->opc = TFHOP_USER_POLLING_MODE;\n\tstart_instruction(tfh);\n}\n\nvoid tfh_exception(struct gru_tlb_fault_handle *tfh)\n{\n\ttfh->opc = TFHOP_EXCEPTION;\n\tstart_instruction(tfh);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}