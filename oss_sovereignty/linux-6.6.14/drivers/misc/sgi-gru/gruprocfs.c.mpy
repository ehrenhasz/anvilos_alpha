{
  "module_name": "gruprocfs.c",
  "hash_id": "0f9ce74ba46bf0c0c73ee96325e619a650576b374ac1d830926adc3c46666db4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sgi-gru/gruprocfs.c",
  "human_readable_source": "\n \n\n#include <linux/proc_fs.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include \"gru.h\"\n#include \"grulib.h\"\n#include \"grutables.h\"\n\n#define printstat(s, f)\t\tprintstat_val(s, &gru_stats.f, #f)\n\nstatic void printstat_val(struct seq_file *s, atomic_long_t *v, char *id)\n{\n\tunsigned long val = atomic_long_read(v);\n\n\tseq_printf(s, \"%16lu %s\\n\", val, id);\n}\n\nstatic int statistics_show(struct seq_file *s, void *p)\n{\n\tprintstat(s, vdata_alloc);\n\tprintstat(s, vdata_free);\n\tprintstat(s, gts_alloc);\n\tprintstat(s, gts_free);\n\tprintstat(s, gms_alloc);\n\tprintstat(s, gms_free);\n\tprintstat(s, gts_double_allocate);\n\tprintstat(s, assign_context);\n\tprintstat(s, assign_context_failed);\n\tprintstat(s, free_context);\n\tprintstat(s, load_user_context);\n\tprintstat(s, load_kernel_context);\n\tprintstat(s, lock_kernel_context);\n\tprintstat(s, unlock_kernel_context);\n\tprintstat(s, steal_user_context);\n\tprintstat(s, steal_kernel_context);\n\tprintstat(s, steal_context_failed);\n\tprintstat(s, nopfn);\n\tprintstat(s, asid_new);\n\tprintstat(s, asid_next);\n\tprintstat(s, asid_wrap);\n\tprintstat(s, asid_reuse);\n\tprintstat(s, intr);\n\tprintstat(s, intr_cbr);\n\tprintstat(s, intr_tfh);\n\tprintstat(s, intr_spurious);\n\tprintstat(s, intr_mm_lock_failed);\n\tprintstat(s, call_os);\n\tprintstat(s, call_os_wait_queue);\n\tprintstat(s, user_flush_tlb);\n\tprintstat(s, user_unload_context);\n\tprintstat(s, user_exception);\n\tprintstat(s, set_context_option);\n\tprintstat(s, check_context_retarget_intr);\n\tprintstat(s, check_context_unload);\n\tprintstat(s, tlb_dropin);\n\tprintstat(s, tlb_preload_page);\n\tprintstat(s, tlb_dropin_fail_no_asid);\n\tprintstat(s, tlb_dropin_fail_upm);\n\tprintstat(s, tlb_dropin_fail_invalid);\n\tprintstat(s, tlb_dropin_fail_range_active);\n\tprintstat(s, tlb_dropin_fail_idle);\n\tprintstat(s, tlb_dropin_fail_fmm);\n\tprintstat(s, tlb_dropin_fail_no_exception);\n\tprintstat(s, tfh_stale_on_fault);\n\tprintstat(s, mmu_invalidate_range);\n\tprintstat(s, mmu_invalidate_page);\n\tprintstat(s, flush_tlb);\n\tprintstat(s, flush_tlb_gru);\n\tprintstat(s, flush_tlb_gru_tgh);\n\tprintstat(s, flush_tlb_gru_zero_asid);\n\tprintstat(s, copy_gpa);\n\tprintstat(s, read_gpa);\n\tprintstat(s, mesq_receive);\n\tprintstat(s, mesq_receive_none);\n\tprintstat(s, mesq_send);\n\tprintstat(s, mesq_send_failed);\n\tprintstat(s, mesq_noop);\n\tprintstat(s, mesq_send_unexpected_error);\n\tprintstat(s, mesq_send_lb_overflow);\n\tprintstat(s, mesq_send_qlimit_reached);\n\tprintstat(s, mesq_send_amo_nacked);\n\tprintstat(s, mesq_send_put_nacked);\n\tprintstat(s, mesq_qf_locked);\n\tprintstat(s, mesq_qf_noop_not_full);\n\tprintstat(s, mesq_qf_switch_head_failed);\n\tprintstat(s, mesq_qf_unexpected_error);\n\tprintstat(s, mesq_noop_unexpected_error);\n\tprintstat(s, mesq_noop_lb_overflow);\n\tprintstat(s, mesq_noop_qlimit_reached);\n\tprintstat(s, mesq_noop_amo_nacked);\n\tprintstat(s, mesq_noop_put_nacked);\n\tprintstat(s, mesq_noop_page_overflow);\n\treturn 0;\n}\n\nstatic ssize_t statistics_write(struct file *file, const char __user *userbuf,\n\t\t\t\tsize_t count, loff_t *data)\n{\n\tmemset(&gru_stats, 0, sizeof(gru_stats));\n\treturn count;\n}\n\nstatic int mcs_statistics_show(struct seq_file *s, void *p)\n{\n\tint op;\n\tunsigned long total, count, max;\n\tstatic char *id[] = {\"cch_allocate\", \"cch_start\", \"cch_interrupt\",\n\t\t\"cch_interrupt_sync\", \"cch_deallocate\", \"tfh_write_only\",\n\t\t\"tfh_write_restart\", \"tgh_invalidate\"};\n\n\tseq_puts(s, \"#id                        count   aver-clks    max-clks\\n\");\n\tfor (op = 0; op < mcsop_last; op++) {\n\t\tcount = atomic_long_read(&mcs_op_statistics[op].count);\n\t\ttotal = atomic_long_read(&mcs_op_statistics[op].total);\n\t\tmax = mcs_op_statistics[op].max;\n\t\tseq_printf(s, \"%-20s%12ld%12ld%12ld\\n\", id[op], count,\n\t\t\t   count ? total / count : 0, max);\n\t}\n\treturn 0;\n}\n\nstatic ssize_t mcs_statistics_write(struct file *file,\n\t\t\tconst char __user *userbuf, size_t count, loff_t *data)\n{\n\tmemset(mcs_op_statistics, 0, sizeof(mcs_op_statistics));\n\treturn count;\n}\n\nstatic int options_show(struct seq_file *s, void *p)\n{\n\tseq_printf(s, \"#bitmask: 1=trace, 2=statistics\\n\");\n\tseq_printf(s, \"0x%lx\\n\", gru_options);\n\treturn 0;\n}\n\nstatic ssize_t options_write(struct file *file, const char __user *userbuf,\n\t\t\t     size_t count, loff_t *data)\n{\n\tint ret;\n\n\tret = kstrtoul_from_user(userbuf, count, 0, &gru_options);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic int cch_seq_show(struct seq_file *file, void *data)\n{\n\tlong gid = *(long *)data;\n\tint i;\n\tstruct gru_state *gru = GID_TO_GRU(gid);\n\tstruct gru_thread_state *ts;\n\tconst char *mode[] = { \"??\", \"UPM\", \"INTR\", \"OS_POLL\" };\n\n\tif (gid == 0)\n\t\tseq_puts(file, \"#  gid  bid  ctx#   asid      pid  cbrs dsbytes    mode\\n\");\n\tif (gru)\n\t\tfor (i = 0; i < GRU_NUM_CCH; i++) {\n\t\t\tts = gru->gs_gts[i];\n\t\t\tif (!ts)\n\t\t\t\tcontinue;\n\t\t\tseq_printf(file, \" %5d%5d%6d%7d%9d%6d%8d%8s\\n\",\n\t\t\t\t   gru->gs_gid, gru->gs_blade_id, i,\n\t\t\t\t   is_kernel_context(ts) ? 0 : ts->ts_gms->ms_asids[gid].mt_asid,\n\t\t\t\t   is_kernel_context(ts) ? 0 : ts->ts_tgid_owner,\n\t\t\t\t   ts->ts_cbr_au_count * GRU_CBR_AU_SIZE,\n\t\t\t\t   ts->ts_cbr_au_count * GRU_DSR_AU_BYTES,\n\t\t\t\t   mode[ts->ts_user_options &\n\t\t\t\t\tGRU_OPT_MISS_MASK]);\n\t\t}\n\n\treturn 0;\n}\n\nstatic int gru_seq_show(struct seq_file *file, void *data)\n{\n\tlong gid = *(long *)data, ctxfree, cbrfree, dsrfree;\n\tstruct gru_state *gru = GID_TO_GRU(gid);\n\n\tif (gid == 0) {\n\t\tseq_puts(file, \"#  gid  nid    ctx   cbr   dsr     ctx   cbr   dsr\\n\");\n\t\tseq_puts(file, \"#             busy  busy  busy    free  free  free\\n\");\n\t}\n\tif (gru) {\n\t\tctxfree = GRU_NUM_CCH - gru->gs_active_contexts;\n\t\tcbrfree = hweight64(gru->gs_cbr_map) * GRU_CBR_AU_SIZE;\n\t\tdsrfree = hweight64(gru->gs_dsr_map) * GRU_DSR_AU_BYTES;\n\t\tseq_printf(file, \" %5d%5d%7ld%6ld%6ld%8ld%6ld%6ld\\n\",\n\t\t\t   gru->gs_gid, gru->gs_blade_id, GRU_NUM_CCH - ctxfree,\n\t\t\t   GRU_NUM_CBE - cbrfree, GRU_NUM_DSR_BYTES - dsrfree,\n\t\t\t   ctxfree, cbrfree, dsrfree);\n\t}\n\n\treturn 0;\n}\n\nstatic void seq_stop(struct seq_file *file, void *data)\n{\n}\n\nstatic void *seq_start(struct seq_file *file, loff_t *gid)\n{\n\tif (*gid < gru_max_gids)\n\t\treturn gid;\n\treturn NULL;\n}\n\nstatic void *seq_next(struct seq_file *file, void *data, loff_t *gid)\n{\n\t(*gid)++;\n\tif (*gid < gru_max_gids)\n\t\treturn gid;\n\treturn NULL;\n}\n\nstatic const struct seq_operations cch_seq_ops = {\n\t.start\t= seq_start,\n\t.next\t= seq_next,\n\t.stop\t= seq_stop,\n\t.show\t= cch_seq_show\n};\n\nstatic const struct seq_operations gru_seq_ops = {\n\t.start\t= seq_start,\n\t.next\t= seq_next,\n\t.stop\t= seq_stop,\n\t.show\t= gru_seq_show\n};\n\nstatic int statistics_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, statistics_show, NULL);\n}\n\nstatic int mcs_statistics_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, mcs_statistics_show, NULL);\n}\n\nstatic int options_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, options_show, NULL);\n}\n\n \nstatic const struct proc_ops statistics_proc_ops = {\n\t.proc_open\t= statistics_open,\n\t.proc_read\t= seq_read,\n\t.proc_write\t= statistics_write,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n};\n\nstatic const struct proc_ops mcs_statistics_proc_ops = {\n\t.proc_open\t= mcs_statistics_open,\n\t.proc_read\t= seq_read,\n\t.proc_write\t= mcs_statistics_write,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n};\n\nstatic const struct proc_ops options_proc_ops = {\n\t.proc_open\t= options_open,\n\t.proc_read\t= seq_read,\n\t.proc_write\t= options_write,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n};\n\nstatic struct proc_dir_entry *proc_gru __read_mostly;\n\nint gru_proc_init(void)\n{\n\tproc_gru = proc_mkdir(\"sgi_uv/gru\", NULL);\n\tif (!proc_gru)\n\t\treturn -1;\n\tif (!proc_create(\"statistics\", 0644, proc_gru, &statistics_proc_ops))\n\t\tgoto err;\n\tif (!proc_create(\"mcs_statistics\", 0644, proc_gru, &mcs_statistics_proc_ops))\n\t\tgoto err;\n\tif (!proc_create(\"debug_options\", 0644, proc_gru, &options_proc_ops))\n\t\tgoto err;\n\tif (!proc_create_seq(\"cch_status\", 0444, proc_gru, &cch_seq_ops))\n\t\tgoto err;\n\tif (!proc_create_seq(\"gru_status\", 0444, proc_gru, &gru_seq_ops))\n\t\tgoto err;\n\treturn 0;\nerr:\n\tremove_proc_subtree(\"sgi_uv/gru\", NULL);\n\treturn -1;\n}\n\nvoid gru_proc_exit(void)\n{\n\tremove_proc_subtree(\"sgi_uv/gru\", NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}