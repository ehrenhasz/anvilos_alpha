{
  "module_name": "grukdump.c",
  "hash_id": "40194edee011a262c1753307058e7bcb7e8d22f0901924770f8daf6063d21cd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sgi-gru/grukdump.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <asm/uv/uv_hub.h>\n\n#include <linux/nospec.h>\n\n#include \"gru.h\"\n#include \"grutables.h\"\n#include \"gruhandles.h\"\n#include \"grulib.h\"\n\n#define CCH_LOCK_ATTEMPTS\t10\n\nstatic int gru_user_copy_handle(void __user **dp, void *s)\n{\n\tif (copy_to_user(*dp, s, GRU_HANDLE_BYTES))\n\t\treturn -1;\n\t*dp += GRU_HANDLE_BYTES;\n\treturn 0;\n}\n\nstatic int gru_dump_context_data(void *grubase,\n\t\t\tstruct gru_context_configuration_handle *cch,\n\t\t\tvoid __user *ubuf, int ctxnum, int dsrcnt,\n\t\t\tint flush_cbrs)\n{\n\tvoid *cb, *cbe, *tfh, *gseg;\n\tint i, scr;\n\n\tgseg = grubase + ctxnum * GRU_GSEG_STRIDE;\n\tcb = gseg + GRU_CB_BASE;\n\tcbe = grubase + GRU_CBE_BASE;\n\ttfh = grubase + GRU_TFH_BASE;\n\n\tfor_each_cbr_in_allocation_map(i, &cch->cbr_allocation_map, scr) {\n\t\tif (flush_cbrs)\n\t\t\tgru_flush_cache(cb);\n\t\tif (gru_user_copy_handle(&ubuf, cb))\n\t\t\tgoto fail;\n\t\tif (gru_user_copy_handle(&ubuf, tfh + i * GRU_HANDLE_STRIDE))\n\t\t\tgoto fail;\n\t\tif (gru_user_copy_handle(&ubuf, cbe + i * GRU_HANDLE_STRIDE))\n\t\t\tgoto fail;\n\t\tcb += GRU_HANDLE_STRIDE;\n\t}\n\tif (dsrcnt)\n\t\tmemcpy(ubuf, gseg + GRU_DS_BASE, dsrcnt * GRU_HANDLE_STRIDE);\n\treturn 0;\n\nfail:\n\treturn -EFAULT;\n}\n\nstatic int gru_dump_tfm(struct gru_state *gru,\n\t\tvoid __user *ubuf, void __user *ubufend)\n{\n\tstruct gru_tlb_fault_map *tfm;\n\tint i;\n\n\tif (GRU_NUM_TFM * GRU_CACHE_LINE_BYTES > ubufend - ubuf)\n\t\treturn -EFBIG;\n\n\tfor (i = 0; i < GRU_NUM_TFM; i++) {\n\t\ttfm = get_tfm(gru->gs_gru_base_vaddr, i);\n\t\tif (gru_user_copy_handle(&ubuf, tfm))\n\t\t\tgoto fail;\n\t}\n\treturn GRU_NUM_TFM * GRU_CACHE_LINE_BYTES;\n\nfail:\n\treturn -EFAULT;\n}\n\nstatic int gru_dump_tgh(struct gru_state *gru,\n\t\tvoid __user *ubuf, void __user *ubufend)\n{\n\tstruct gru_tlb_global_handle *tgh;\n\tint i;\n\n\tif (GRU_NUM_TGH * GRU_CACHE_LINE_BYTES > ubufend - ubuf)\n\t\treturn -EFBIG;\n\n\tfor (i = 0; i < GRU_NUM_TGH; i++) {\n\t\ttgh = get_tgh(gru->gs_gru_base_vaddr, i);\n\t\tif (gru_user_copy_handle(&ubuf, tgh))\n\t\t\tgoto fail;\n\t}\n\treturn GRU_NUM_TGH * GRU_CACHE_LINE_BYTES;\n\nfail:\n\treturn -EFAULT;\n}\n\nstatic int gru_dump_context(struct gru_state *gru, int ctxnum,\n\t\tvoid __user *ubuf, void __user *ubufend, char data_opt,\n\t\tchar lock_cch, char flush_cbrs)\n{\n\tstruct gru_dump_context_header hdr;\n\tstruct gru_dump_context_header __user *uhdr = ubuf;\n\tstruct gru_context_configuration_handle *cch, *ubufcch;\n\tstruct gru_thread_state *gts;\n\tint try, cch_locked, cbrcnt = 0, dsrcnt = 0, bytes = 0, ret = 0;\n\tvoid *grubase;\n\n\tmemset(&hdr, 0, sizeof(hdr));\n\tgrubase = gru->gs_gru_base_vaddr;\n\tcch = get_cch(grubase, ctxnum);\n\tfor (try = 0; try < CCH_LOCK_ATTEMPTS; try++) {\n\t\tcch_locked =  trylock_cch_handle(cch);\n\t\tif (cch_locked)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\tubuf += sizeof(hdr);\n\tubufcch = ubuf;\n\tif (gru_user_copy_handle(&ubuf, cch)) {\n\t\tif (cch_locked)\n\t\t\tunlock_cch_handle(cch);\n\t\treturn -EFAULT;\n\t}\n\tif (cch_locked)\n\t\tubufcch->delresp = 0;\n\tbytes = sizeof(hdr) + GRU_CACHE_LINE_BYTES;\n\n\tif (cch_locked || !lock_cch) {\n\t\tgts = gru->gs_gts[ctxnum];\n\t\tif (gts && gts->ts_vma) {\n\t\t\thdr.pid = gts->ts_tgid_owner;\n\t\t\thdr.vaddr = gts->ts_vma->vm_start;\n\t\t}\n\t\tif (cch->state != CCHSTATE_INACTIVE) {\n\t\t\tcbrcnt = hweight64(cch->cbr_allocation_map) *\n\t\t\t\t\t\tGRU_CBR_AU_SIZE;\n\t\t\tdsrcnt = data_opt ? hweight32(cch->dsr_allocation_map) *\n\t\t\t\t\t\tGRU_DSR_AU_CL : 0;\n\t\t}\n\t\tbytes += (3 * cbrcnt + dsrcnt) * GRU_CACHE_LINE_BYTES;\n\t\tif (bytes > ubufend - ubuf)\n\t\t\tret = -EFBIG;\n\t\telse\n\t\t\tret = gru_dump_context_data(grubase, cch, ubuf, ctxnum,\n\t\t\t\t\t\t\tdsrcnt, flush_cbrs);\n\t}\n\tif (cch_locked)\n\t\tunlock_cch_handle(cch);\n\tif (ret)\n\t\treturn ret;\n\n\thdr.magic = GRU_DUMP_MAGIC;\n\thdr.gid = gru->gs_gid;\n\thdr.ctxnum = ctxnum;\n\thdr.cbrcnt = cbrcnt;\n\thdr.dsrcnt = dsrcnt;\n\thdr.cch_locked = cch_locked;\n\tif (copy_to_user(uhdr, &hdr, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\treturn bytes;\n}\n\nint gru_dump_chiplet_request(unsigned long arg)\n{\n\tstruct gru_state *gru;\n\tstruct gru_dump_chiplet_state_req req;\n\tvoid __user *ubuf;\n\tvoid __user *ubufend;\n\tint ctxnum, ret, cnt = 0;\n\n\tif (copy_from_user(&req, (void __user *)arg, sizeof(req)))\n\t\treturn -EFAULT;\n\n\t \n\tif (req.gid >= gru_max_gids)\n\t\treturn -EINVAL;\n\treq.gid = array_index_nospec(req.gid, gru_max_gids);\n\n\tgru = GID_TO_GRU(req.gid);\n\tubuf = req.buf;\n\tubufend = req.buf + req.buflen;\n\n\tret = gru_dump_tfm(gru, ubuf, ubufend);\n\tif (ret < 0)\n\t\tgoto fail;\n\tubuf += ret;\n\n\tret = gru_dump_tgh(gru, ubuf, ubufend);\n\tif (ret < 0)\n\t\tgoto fail;\n\tubuf += ret;\n\n\tfor (ctxnum = 0; ctxnum < GRU_NUM_CCH; ctxnum++) {\n\t\tif (req.ctxnum == ctxnum || req.ctxnum < 0) {\n\t\t\tret = gru_dump_context(gru, ctxnum, ubuf, ubufend,\n\t\t\t\t\t\treq.data_opt, req.lock_cch,\n\t\t\t\t\t\treq.flush_cbrs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tubuf += ret;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (copy_to_user((void __user *)arg, &req, sizeof(req)))\n\t\treturn -EFAULT;\n\treturn cnt;\n\nfail:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}