{
  "module_name": "gru_instructions.h",
  "hash_id": "13613583f4e54417d9ecdbe5f74c361ddd1c35a0d5bec7f92513bde561a59d25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sgi-gru/gru_instructions.h",
  "human_readable_source": " \n\n#ifndef __GRU_INSTRUCTIONS_H__\n#define __GRU_INSTRUCTIONS_H__\n\nextern int gru_check_status_proc(void *cb);\nextern int gru_wait_proc(void *cb);\nextern void gru_wait_abort_proc(void *cb);\n\n\n\n \n\n#if defined(CONFIG_IA64)\n#include <linux/compiler.h>\n#include <asm/intrinsics.h>\n#define __flush_cache(p)\t\tia64_fc((unsigned long)p)\n \n#define gru_ordered_store_ulong(p, v)\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\\\n\t\t\tbarrier();\t\t\t\t\t\\\n\t\t\t*((volatile unsigned long *)(p)) = v;  \t\\\n\t\t} while (0)\n#elif defined(CONFIG_X86_64)\n#include <asm/cacheflush.h>\n#define __flush_cache(p)\t\tclflush(p)\n#define gru_ordered_store_ulong(p, v)\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\\\n\t\t\tbarrier();\t\t\t\t\t\\\n\t\t\t*(unsigned long *)p = v;\t\t\t\\\n\t\t} while (0)\n#else\n#error \"Unsupported architecture\"\n#endif\n\n \n#define CBS_IDLE\t\t\t0\n#define CBS_EXCEPTION\t\t\t1\n#define CBS_ACTIVE\t\t\t2\n#define CBS_CALL_OS\t\t\t3\n\n \n#define CBSS_MSG_QUEUE_MASK\t\t7\n#define CBSS_IMPLICIT_ABORT_ACTIVE_MASK\t8\n\n \n#define CBSS_NO_ERROR\t\t\t0\n#define CBSS_LB_OVERFLOWED\t\t1\n#define CBSS_QLIMIT_REACHED\t\t2\n#define CBSS_PAGE_OVERFLOW\t\t3\n#define CBSS_AMO_NACKED\t\t\t4\n#define CBSS_PUT_NACKED\t\t\t5\n\n \nstruct control_block_extended_exc_detail {\n\tunsigned long\tcb;\n\tint\t\topc;\n\tint\t\tecause;\n\tint\t\texopc;\n\tlong\t\texceptdet0;\n\tint\t\texceptdet1;\n\tint\t\tcbrstate;\n\tint\t\tcbrexecstatus;\n};\n\n \n\n \nstruct gru_instruction_bits {\n     \n    unsigned int\t\ticmd:      1;\n    unsigned char\t\tima:\t   3;\t \n    unsigned char\t\treserved0: 4;\n    unsigned int\t\txtype:     3;\n    unsigned int\t\tiaa0:      2;\n    unsigned int\t\tiaa1:      2;\n    unsigned char\t\treserved1: 1;\n    unsigned char\t\topc:       8;\t \n    unsigned char\t\texopc:     8;\t \n     \n    unsigned int\t\tidef2:    22;\t \n    unsigned char\t\treserved2: 2;\n    unsigned char\t\tistatus:   2;\n    unsigned char\t\tisubstatus:4;\n    unsigned char\t\treserved3: 1;\n    unsigned char\t\ttlb_fault_color: 1;\n     \n    unsigned long\t\tidef4;\t\t \n     \n    unsigned long\t\tidef1;\t\t \n    unsigned long\t\tidef5;\t\t \n    unsigned long\t\tidef6;\t\t \n    unsigned long\t\tidef3;\t\t \n    unsigned long\t\treserved4;\n     \n    unsigned long\t\tavalue;\t\t  \n};\n\n \nstruct gru_instruction {\n     \n    union {\n    \tunsigned long\t\top64;     \n\tstruct {\n\t\tunsigned int\top32;\n\t\tunsigned int\ttri0;\n\t};\n    };\n    unsigned long\t\ttri1_bufsize;\t\t \n    unsigned long\t\tbaddr0;\t\t\t \n    unsigned long\t\tnelem;\t\t\t \n    unsigned long\t\top1_stride;\t\t \n    unsigned long\t\top2_value_baddr1;\t \n    unsigned long\t\treserved0;\t\t \n    unsigned long\t\tavalue;\t\t\t \n};\n\n \n#define GRU_CB_ICMD_SHFT\t0\n#define GRU_CB_ICMD_MASK\t0x1\n#define GRU_CB_XTYPE_SHFT\t8\n#define GRU_CB_XTYPE_MASK\t0x7\n#define GRU_CB_IAA0_SHFT\t11\n#define GRU_CB_IAA0_MASK\t0x3\n#define GRU_CB_IAA1_SHFT\t13\n#define GRU_CB_IAA1_MASK\t0x3\n#define GRU_CB_IMA_SHFT\t\t1\n#define GRU_CB_IMA_MASK\t\t0x3\n#define GRU_CB_OPC_SHFT\t\t16\n#define GRU_CB_OPC_MASK\t\t0xff\n#define GRU_CB_EXOPC_SHFT\t24\n#define GRU_CB_EXOPC_MASK\t0xff\n#define GRU_IDEF2_SHFT\t\t32\n#define GRU_IDEF2_MASK\t\t0x3ffff\n#define GRU_ISTATUS_SHFT\t56\n#define GRU_ISTATUS_MASK\t0x3\n\n \n#define OP_NOP\t\t0x00\n#define OP_BCOPY\t0x01\n#define OP_VLOAD\t0x02\n#define OP_IVLOAD\t0x03\n#define OP_VSTORE\t0x04\n#define OP_IVSTORE\t0x05\n#define OP_VSET\t\t0x06\n#define OP_IVSET\t0x07\n#define OP_MESQ\t\t0x08\n#define OP_GAMXR\t0x09\n#define OP_GAMIR\t0x0a\n#define OP_GAMIRR\t0x0b\n#define OP_GAMER\t0x0c\n#define OP_GAMERR\t0x0d\n#define OP_BSTORE\t0x0e\n#define OP_VFLUSH\t0x0f\n\n\n \n\n \n#define EOP_IR_FETCH\t0x01  \n#define EOP_IR_CLR\t0x02  \n#define EOP_IR_INC\t0x05  \n#define EOP_IR_DEC\t0x07  \n#define EOP_IR_QCHK1\t0x0d  \n#define EOP_IR_QCHK2\t0x0e  \n\n \n#define EOP_IRR_FETCH\t0x01  \n#define EOP_IRR_CLR\t0x02  \n#define EOP_IRR_INC\t0x05  \n#define EOP_IRR_DEC\t0x07  \n#define EOP_IRR_DECZ\t0x0f  \n\n \n#define EOP_ER_SWAP\t0x00  \n#define EOP_ER_OR\t0x01  \n#define EOP_ER_AND\t0x02  \n#define EOP_ER_XOR\t0x03  \n#define EOP_ER_ADD\t0x04  \n#define EOP_ER_CSWAP\t0x08  \n#define EOP_ER_CADD\t0x0c  \n\n \n#define EOP_ERR_SWAP\t0x00  \n#define EOP_ERR_OR\t0x01  \n#define EOP_ERR_AND\t0x02  \n#define EOP_ERR_XOR\t0x03  \n#define EOP_ERR_ADD\t0x04  \n#define EOP_ERR_CSWAP\t0x08  \n#define EOP_ERR_EPOLL\t0x09  \n#define EOP_ERR_NPOLL\t0x0a  \n\n \n#define EOP_XR_CSWAP\t0x0b  \n\n\n \n#define XTYPE_B\t\t0x0\t \n#define XTYPE_S\t\t0x1\t \n#define XTYPE_W\t\t0x2\t \n#define XTYPE_DW\t0x3\t \n#define XTYPE_CL\t0x6\t \n\n\n \n#define IAA_RAM\t\t0x0\t \n#define IAA_NCRAM\t0x2\t \n#define IAA_MMIO\t0x1\t \n#define IAA_REGISTER\t0x3\t \n\n\n \n#define IMA_MAPPED\t0x0\t \n#define IMA_CB_DELAY\t0x1\t \n#define IMA_UNMAPPED\t0x2\t \n#define IMA_INTERRUPT\t0x4\t \n\n \n#define CBE_CAUSE_RI\t\t\t\t(1 << 0)\n#define CBE_CAUSE_INVALID_INSTRUCTION\t\t(1 << 1)\n#define CBE_CAUSE_UNMAPPED_MODE_FORBIDDEN\t(1 << 2)\n#define CBE_CAUSE_PE_CHECK_DATA_ERROR\t\t(1 << 3)\n#define CBE_CAUSE_IAA_GAA_MISMATCH\t\t(1 << 4)\n#define CBE_CAUSE_DATA_SEGMENT_LIMIT_EXCEPTION\t(1 << 5)\n#define CBE_CAUSE_OS_FATAL_TLB_FAULT\t\t(1 << 6)\n#define CBE_CAUSE_EXECUTION_HW_ERROR\t\t(1 << 7)\n#define CBE_CAUSE_TLBHW_ERROR\t\t\t(1 << 8)\n#define CBE_CAUSE_RA_REQUEST_TIMEOUT\t\t(1 << 9)\n#define CBE_CAUSE_HA_REQUEST_TIMEOUT\t\t(1 << 10)\n#define CBE_CAUSE_RA_RESPONSE_FATAL\t\t(1 << 11)\n#define CBE_CAUSE_RA_RESPONSE_NON_FATAL\t\t(1 << 12)\n#define CBE_CAUSE_HA_RESPONSE_FATAL\t\t(1 << 13)\n#define CBE_CAUSE_HA_RESPONSE_NON_FATAL\t\t(1 << 14)\n#define CBE_CAUSE_ADDRESS_SPACE_DECODE_ERROR\t(1 << 15)\n#define CBE_CAUSE_PROTOCOL_STATE_DATA_ERROR\t(1 << 16)\n#define CBE_CAUSE_RA_RESPONSE_DATA_ERROR\t(1 << 17)\n#define CBE_CAUSE_HA_RESPONSE_DATA_ERROR\t(1 << 18)\n#define CBE_CAUSE_FORCED_ERROR\t\t\t(1 << 19)\n\n \n#define CBR_EXS_ABORT_OCC_BIT\t\t\t0\n#define CBR_EXS_INT_OCC_BIT\t\t\t1\n#define CBR_EXS_PENDING_BIT\t\t\t2\n#define CBR_EXS_QUEUED_BIT\t\t\t3\n#define CBR_EXS_TLB_INVAL_BIT\t\t\t4\n#define CBR_EXS_EXCEPTION_BIT\t\t\t5\n#define CBR_EXS_CB_INT_PENDING_BIT\t\t6\n\n#define CBR_EXS_ABORT_OCC\t\t\t(1 << CBR_EXS_ABORT_OCC_BIT)\n#define CBR_EXS_INT_OCC\t\t\t\t(1 << CBR_EXS_INT_OCC_BIT)\n#define CBR_EXS_PENDING\t\t\t\t(1 << CBR_EXS_PENDING_BIT)\n#define CBR_EXS_QUEUED\t\t\t\t(1 << CBR_EXS_QUEUED_BIT)\n#define CBR_EXS_TLB_INVAL\t\t\t(1 << CBR_EXS_TLB_INVAL_BIT)\n#define CBR_EXS_EXCEPTION\t\t\t(1 << CBR_EXS_EXCEPTION_BIT)\n#define CBR_EXS_CB_INT_PENDING\t\t\t(1 << CBR_EXS_CB_INT_PENDING_BIT)\n\n \n#define EXCEPTION_RETRY_BITS (CBE_CAUSE_EXECUTION_HW_ERROR |\t\t\\\n\t\t\t      CBE_CAUSE_TLBHW_ERROR |\t\t\t\\\n\t\t\t      CBE_CAUSE_RA_REQUEST_TIMEOUT |\t\t\\\n\t\t\t      CBE_CAUSE_RA_RESPONSE_NON_FATAL |\t\t\\\n\t\t\t      CBE_CAUSE_HA_RESPONSE_NON_FATAL |\t\t\\\n\t\t\t      CBE_CAUSE_RA_RESPONSE_DATA_ERROR |\t\\\n\t\t\t      CBE_CAUSE_HA_RESPONSE_DATA_ERROR\t\t\\\n\t\t\t      )\n\n \nunion gru_mesqhead {\n\tunsigned long\tval;\n\tstruct {\n\t\tunsigned int\thead;\n\t\tunsigned int\tlimit;\n\t};\n};\n\n\n \nstatic inline unsigned long\n__opdword(unsigned char opcode, unsigned char exopc, unsigned char xtype,\n       unsigned char iaa0, unsigned char iaa1,\n       unsigned long idef2, unsigned char ima)\n{\n    return (1 << GRU_CB_ICMD_SHFT) |\n\t   ((unsigned long)CBS_ACTIVE << GRU_ISTATUS_SHFT) |\n\t   (idef2<< GRU_IDEF2_SHFT) |\n\t   (iaa0 << GRU_CB_IAA0_SHFT) |\n\t   (iaa1 << GRU_CB_IAA1_SHFT) |\n\t   (ima << GRU_CB_IMA_SHFT) |\n\t   (xtype << GRU_CB_XTYPE_SHFT) |\n\t   (opcode << GRU_CB_OPC_SHFT) |\n\t   (exopc << GRU_CB_EXOPC_SHFT);\n}\n\n \nstatic inline void gru_flush_cache(void *p)\n{\n\t__flush_cache(p);\n}\n\n \nstatic inline void gru_start_instruction(struct gru_instruction *ins, unsigned long op64)\n{\n\tgru_ordered_store_ulong(ins, op64);\n\tmb();\n\tgru_flush_cache(ins);\n}\n\n\n \n#define CB_IMA(h)\t\t((h) | IMA_UNMAPPED)\n\n \n#define GRU_DINDEX(i)\t\t((i) * GRU_CACHE_LINE_BYTES)\n\n \nstatic inline void gru_vload_phys(void *cb, unsigned long gpa,\n\t\tunsigned int tri0, int iaa, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (struct gru_instruction *)cb;\n\n\tins->baddr0 = (long)gpa | ((unsigned long)iaa << 62);\n\tins->nelem = 1;\n\tins->op1_stride = 1;\n\tgru_start_instruction(ins, __opdword(OP_VLOAD, 0, XTYPE_DW, iaa, 0,\n\t\t\t\t\t(unsigned long)tri0, CB_IMA(hints)));\n}\n\nstatic inline void gru_vstore_phys(void *cb, unsigned long gpa,\n\t\tunsigned int tri0, int iaa, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (struct gru_instruction *)cb;\n\n\tins->baddr0 = (long)gpa | ((unsigned long)iaa << 62);\n\tins->nelem = 1;\n\tins->op1_stride = 1;\n\tgru_start_instruction(ins, __opdword(OP_VSTORE, 0, XTYPE_DW, iaa, 0,\n\t\t\t\t\t(unsigned long)tri0, CB_IMA(hints)));\n}\n\nstatic inline void gru_vload(void *cb, unsigned long mem_addr,\n\t\tunsigned int tri0, unsigned char xtype, unsigned long nelem,\n\t\tunsigned long stride, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (struct gru_instruction *)cb;\n\n\tins->baddr0 = (long)mem_addr;\n\tins->nelem = nelem;\n\tins->op1_stride = stride;\n\tgru_start_instruction(ins, __opdword(OP_VLOAD, 0, xtype, IAA_RAM, 0,\n\t\t\t\t\t(unsigned long)tri0, CB_IMA(hints)));\n}\n\nstatic inline void gru_vstore(void *cb, unsigned long mem_addr,\n\t\tunsigned int tri0, unsigned char xtype, unsigned long nelem,\n\t\tunsigned long stride, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)mem_addr;\n\tins->nelem = nelem;\n\tins->op1_stride = stride;\n\tgru_start_instruction(ins, __opdword(OP_VSTORE, 0, xtype, IAA_RAM, 0,\n\t\t\t\t\ttri0, CB_IMA(hints)));\n}\n\nstatic inline void gru_ivload(void *cb, unsigned long mem_addr,\n\t\tunsigned int tri0, unsigned int tri1, unsigned char xtype,\n\t\tunsigned long nelem, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)mem_addr;\n\tins->nelem = nelem;\n\tins->tri1_bufsize = tri1;\n\tgru_start_instruction(ins, __opdword(OP_IVLOAD, 0, xtype, IAA_RAM, 0,\n\t\t\t\t\ttri0, CB_IMA(hints)));\n}\n\nstatic inline void gru_ivstore(void *cb, unsigned long mem_addr,\n\t\tunsigned int tri0, unsigned int tri1,\n\t\tunsigned char xtype, unsigned long nelem, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)mem_addr;\n\tins->nelem = nelem;\n\tins->tri1_bufsize = tri1;\n\tgru_start_instruction(ins, __opdword(OP_IVSTORE, 0, xtype, IAA_RAM, 0,\n\t\t\t\t\ttri0, CB_IMA(hints)));\n}\n\nstatic inline void gru_vset(void *cb, unsigned long mem_addr,\n\t\tunsigned long value, unsigned char xtype, unsigned long nelem,\n\t\tunsigned long stride, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)mem_addr;\n\tins->op2_value_baddr1 = value;\n\tins->nelem = nelem;\n\tins->op1_stride = stride;\n\tgru_start_instruction(ins, __opdword(OP_VSET, 0, xtype, IAA_RAM, 0,\n\t\t\t\t\t 0, CB_IMA(hints)));\n}\n\nstatic inline void gru_ivset(void *cb, unsigned long mem_addr,\n\t\tunsigned int tri1, unsigned long value, unsigned char xtype,\n\t\tunsigned long nelem, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)mem_addr;\n\tins->op2_value_baddr1 = value;\n\tins->nelem = nelem;\n\tins->tri1_bufsize = tri1;\n\tgru_start_instruction(ins, __opdword(OP_IVSET, 0, xtype, IAA_RAM, 0,\n\t\t\t\t\t0, CB_IMA(hints)));\n}\n\nstatic inline void gru_vflush(void *cb, unsigned long mem_addr,\n\t\tunsigned long nelem, unsigned char xtype, unsigned long stride,\n\t\tunsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)mem_addr;\n\tins->op1_stride = stride;\n\tins->nelem = nelem;\n\tgru_start_instruction(ins, __opdword(OP_VFLUSH, 0, xtype, IAA_RAM, 0,\n\t\t\t\t\t0, CB_IMA(hints)));\n}\n\nstatic inline void gru_nop(void *cb, int hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tgru_start_instruction(ins, __opdword(OP_NOP, 0, 0, 0, 0, 0, CB_IMA(hints)));\n}\n\n\nstatic inline void gru_bcopy(void *cb, const unsigned long src,\n\t\tunsigned long dest,\n\t\tunsigned int tri0, unsigned int xtype, unsigned long nelem,\n\t\tunsigned int bufsize, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)src;\n\tins->op2_value_baddr1 = (long)dest;\n\tins->nelem = nelem;\n\tins->tri1_bufsize = bufsize;\n\tgru_start_instruction(ins, __opdword(OP_BCOPY, 0, xtype, IAA_RAM,\n\t\t\t\t\tIAA_RAM, tri0, CB_IMA(hints)));\n}\n\nstatic inline void gru_bstore(void *cb, const unsigned long src,\n\t\tunsigned long dest, unsigned int tri0, unsigned int xtype,\n\t\tunsigned long nelem, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)src;\n\tins->op2_value_baddr1 = (long)dest;\n\tins->nelem = nelem;\n\tgru_start_instruction(ins, __opdword(OP_BSTORE, 0, xtype, 0, IAA_RAM,\n\t\t\t\t\ttri0, CB_IMA(hints)));\n}\n\nstatic inline void gru_gamir(void *cb, int exopc, unsigned long src,\n\t\tunsigned int xtype, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)src;\n\tgru_start_instruction(ins, __opdword(OP_GAMIR, exopc, xtype, IAA_RAM, 0,\n\t\t\t\t\t0, CB_IMA(hints)));\n}\n\nstatic inline void gru_gamirr(void *cb, int exopc, unsigned long src,\n\t\tunsigned int xtype, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)src;\n\tgru_start_instruction(ins, __opdword(OP_GAMIRR, exopc, xtype, IAA_RAM, 0,\n\t\t\t\t\t0, CB_IMA(hints)));\n}\n\nstatic inline void gru_gamer(void *cb, int exopc, unsigned long src,\n\t\tunsigned int xtype,\n\t\tunsigned long operand1, unsigned long operand2,\n\t\tunsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)src;\n\tins->op1_stride = operand1;\n\tins->op2_value_baddr1 = operand2;\n\tgru_start_instruction(ins, __opdword(OP_GAMER, exopc, xtype, IAA_RAM, 0,\n\t\t\t\t\t0, CB_IMA(hints)));\n}\n\nstatic inline void gru_gamerr(void *cb, int exopc, unsigned long src,\n\t\tunsigned int xtype, unsigned long operand1,\n\t\tunsigned long operand2, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)src;\n\tins->op1_stride = operand1;\n\tins->op2_value_baddr1 = operand2;\n\tgru_start_instruction(ins, __opdword(OP_GAMERR, exopc, xtype, IAA_RAM, 0,\n\t\t\t\t\t0, CB_IMA(hints)));\n}\n\nstatic inline void gru_gamxr(void *cb, unsigned long src,\n\t\tunsigned int tri0, unsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)src;\n\tins->nelem = 4;\n\tgru_start_instruction(ins, __opdword(OP_GAMXR, EOP_XR_CSWAP, XTYPE_DW,\n\t\t\t\t IAA_RAM, 0, 0, CB_IMA(hints)));\n}\n\nstatic inline void gru_mesq(void *cb, unsigned long queue,\n\t\tunsigned long tri0, unsigned long nelem,\n\t\tunsigned long hints)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\tins->baddr0 = (long)queue;\n\tins->nelem = nelem;\n\tgru_start_instruction(ins, __opdword(OP_MESQ, 0, XTYPE_CL, IAA_RAM, 0,\n\t\t\t\t\ttri0, CB_IMA(hints)));\n}\n\nstatic inline unsigned long gru_get_amo_value(void *cb)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\treturn ins->avalue;\n}\n\nstatic inline int gru_get_amo_value_head(void *cb)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\treturn ins->avalue & 0xffffffff;\n}\n\nstatic inline int gru_get_amo_value_limit(void *cb)\n{\n\tstruct gru_instruction *ins = (void *)cb;\n\n\treturn ins->avalue >> 32;\n}\n\nstatic inline union gru_mesqhead  gru_mesq_head(int head, int limit)\n{\n\tunion gru_mesqhead mqh;\n\n\tmqh.head = head;\n\tmqh.limit = limit;\n\treturn mqh;\n}\n\n \nextern int gru_get_cb_exception_detail(void *cb,\n\t\t       struct control_block_extended_exc_detail *excdet);\n\n#define GRU_EXC_STR_SIZE\t\t256\n\n\n \nstruct gru_control_block_status {\n\tunsigned int\ticmd\t\t:1;\n\tunsigned int\tima\t\t:3;\n\tunsigned int\treserved0\t:4;\n\tunsigned int\tunused1\t\t:24;\n\tunsigned int\tunused2\t\t:24;\n\tunsigned int\tistatus\t\t:2;\n\tunsigned int\tisubstatus\t:4;\n\tunsigned int\tunused3\t\t:2;\n};\n\n \nstatic inline int gru_get_cb_status(void *cb)\n{\n\tstruct gru_control_block_status *cbs = (void *)cb;\n\n\treturn cbs->istatus;\n}\n\n \nstatic inline int gru_get_cb_message_queue_substatus(void *cb)\n{\n\tstruct gru_control_block_status *cbs = (void *)cb;\n\n\treturn cbs->isubstatus & CBSS_MSG_QUEUE_MASK;\n}\n\n \nstatic inline int gru_get_cb_substatus(void *cb)\n{\n\tstruct gru_control_block_status *cbs = (void *)cb;\n\n\treturn cbs->isubstatus;\n}\n\n \nstatic inline int gru_check_status(void *cb)\n{\n\tstruct gru_control_block_status *cbs = (void *)cb;\n\tint ret;\n\n\tret = cbs->istatus;\n\tif (ret != CBS_ACTIVE)\n\t\tret = gru_check_status_proc(cb);\n\treturn ret;\n}\n\n \nstatic inline int gru_wait(void *cb)\n{\n\treturn gru_wait_proc(cb);\n}\n\n \nstatic inline void gru_wait_abort(void *cb)\n{\n\tgru_wait_abort_proc(cb);\n}\n\n \nstatic inline void *gru_get_gseg_pointer (void *p)\n{\n\treturn (void *)((unsigned long)p & ~(GRU_GSEG_PAGESIZE - 1));\n}\n\n \nstatic inline void *gru_get_cb_pointer(void *gseg,\n\t\t\t\t\t\t      int index)\n{\n\treturn gseg + GRU_CB_BASE + index * GRU_HANDLE_STRIDE;\n}\n\n \nstatic inline void *gru_get_data_pointer(void *gseg, int index)\n{\n\treturn gseg + GRU_DS_BASE + index * GRU_CACHE_LINE_BYTES;\n}\n\n \nstatic inline int gru_get_tri(void *vaddr)\n{\n\treturn ((unsigned long)vaddr & (GRU_GSEG_PAGESIZE - 1)) - GRU_DS_BASE;\n}\n#endif\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}