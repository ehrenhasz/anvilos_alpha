{
  "module_name": "gruhandles.h",
  "hash_id": "2601eabe27f35eb5a7061dc5f24c92e8480d4c09dadb61443ee8e678d7e67288",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sgi-gru/gruhandles.h",
  "human_readable_source": " \n \n\n#ifndef __GRUHANDLES_H__\n#define __GRUHANDLES_H__\n#include \"gru_instructions.h\"\n\n \n#define GRU_GSEG0_BASE\t\t0\n#define GRU_MCS_BASE\t\t(64 * 1024 * 1024)\n#define GRU_SIZE\t\t(128UL * 1024 * 1024)\n\n \n#define GRU_NUM_CB\t\t128\n#define GRU_NUM_DSR_BYTES\t(32 * 1024)\n#define GRU_NUM_TFM\t\t16\n#define GRU_NUM_TGH\t\t24\n#define GRU_NUM_CBE\t\t128\n#define GRU_NUM_TFH\t\t128\n#define GRU_NUM_CCH\t\t16\n\n \n#define GRU_NUM_USER_CBR\tGRU_NUM_CBE\n#define GRU_NUM_USER_DSR_BYTES\tGRU_NUM_DSR_BYTES\n\n \n#define GRU_HANDLE_BYTES\t64\n#define GRU_HANDLE_STRIDE\t256\n\n \n#define GRU_TFM_BASE\t\t(GRU_MCS_BASE + 0x00000)\n#define GRU_TGH_BASE\t\t(GRU_MCS_BASE + 0x08000)\n#define GRU_CBE_BASE\t\t(GRU_MCS_BASE + 0x10000)\n#define GRU_TFH_BASE\t\t(GRU_MCS_BASE + 0x18000)\n#define GRU_CCH_BASE\t\t(GRU_MCS_BASE + 0x20000)\n\n \n#define GRU_GSEG_STRIDE\t\t(4 * 1024 * 1024)\n#define GSEG_BASE(a)\t\t((a) & ~(GRU_GSEG_PAGESIZE - 1))\n\n \n#define GRU_DSR_AU_BYTES\t1024\n#define GRU_DSR_CL\t\t(GRU_NUM_DSR_BYTES / GRU_CACHE_LINE_BYTES)\n#define GRU_DSR_AU_CL\t\t(GRU_DSR_AU_BYTES / GRU_CACHE_LINE_BYTES)\n#define GRU_DSR_AU\t\t(GRU_NUM_DSR_BYTES / GRU_DSR_AU_BYTES)\n\n \n#define GRU_CBR_AU_SIZE\t\t2\n#define GRU_CBR_AU\t\t(GRU_NUM_CBE / GRU_CBR_AU_SIZE)\n\n \n#define GRU_DS_BYTES_TO_AU(n)\tDIV_ROUND_UP(n, GRU_DSR_AU_BYTES)\n#define GRU_CB_COUNT_TO_AU(n)\tDIV_ROUND_UP(n, GRU_CBR_AU_SIZE)\n\n \n#define GRU_CHIPLETS_PER_HUB\t2\n#define GRU_HUBS_PER_BLADE\t1\n#define GRU_CHIPLETS_PER_BLADE\t(GRU_HUBS_PER_BLADE * GRU_CHIPLETS_PER_HUB)\n\n \n#define GRU_CB_BASE\t\t0\n#define GRU_CB_LIMIT\t\t(GRU_CB_BASE + GRU_HANDLE_STRIDE * GRU_NUM_CBE)\n#define GRU_DS_BASE\t\t0x20000\n#define GRU_DS_LIMIT\t\t(GRU_DS_BASE + GRU_NUM_DSR_BYTES)\n\n \n#define GSEGPOFF(h) \t\t((h) & (GRU_SIZE - 1))\n\n \n#define GRUBASE(h)\t\t((void *)((unsigned long)(h) & ~(GRU_SIZE - 1)))\n\n \n#define TYPE_IS(hn, h)\t\t((h) >= GRU_##hn##_BASE && (h) <\t\\\n\t\tGRU_##hn##_BASE + GRU_NUM_##hn * GRU_HANDLE_STRIDE &&   \\\n\t\t(((h) & (GRU_HANDLE_STRIDE - 1)) == 0))\n\n\n \nstatic inline void *get_gseg_base_address(void *base, int ctxnum)\n{\n\treturn (void *)(base + GRU_GSEG0_BASE + GRU_GSEG_STRIDE * ctxnum);\n}\n\nstatic inline void *get_gseg_base_address_cb(void *base, int ctxnum, int line)\n{\n\treturn (void *)(get_gseg_base_address(base, ctxnum) +\n\t\t\tGRU_CB_BASE + GRU_HANDLE_STRIDE * line);\n}\n\nstatic inline void *get_gseg_base_address_ds(void *base, int ctxnum, int line)\n{\n\treturn (void *)(get_gseg_base_address(base, ctxnum) + GRU_DS_BASE +\n\t\t\tGRU_CACHE_LINE_BYTES * line);\n}\n\nstatic inline struct gru_tlb_fault_map *get_tfm(void *base, int ctxnum)\n{\n\treturn (struct gru_tlb_fault_map *)(base + GRU_TFM_BASE +\n\t\t\t\t\tctxnum * GRU_HANDLE_STRIDE);\n}\n\nstatic inline struct gru_tlb_global_handle *get_tgh(void *base, int ctxnum)\n{\n\treturn (struct gru_tlb_global_handle *)(base + GRU_TGH_BASE +\n\t\t\t\t\tctxnum * GRU_HANDLE_STRIDE);\n}\n\nstatic inline struct gru_control_block_extended *get_cbe(void *base, int ctxnum)\n{\n\treturn (struct gru_control_block_extended *)(base + GRU_CBE_BASE +\n\t\t\t\t\tctxnum * GRU_HANDLE_STRIDE);\n}\n\nstatic inline struct gru_tlb_fault_handle *get_tfh(void *base, int ctxnum)\n{\n\treturn (struct gru_tlb_fault_handle *)(base + GRU_TFH_BASE +\n\t\t\t\t\tctxnum * GRU_HANDLE_STRIDE);\n}\n\nstatic inline struct gru_context_configuration_handle *get_cch(void *base,\n\t\t\t\t\tint ctxnum)\n{\n\treturn (struct gru_context_configuration_handle *)(base +\n\t\t\t\tGRU_CCH_BASE + ctxnum * GRU_HANDLE_STRIDE);\n}\n\nstatic inline unsigned long get_cb_number(void *cb)\n{\n\treturn (((unsigned long)cb - GRU_CB_BASE) % GRU_GSEG_PAGESIZE) /\n\t\t\t\t\tGRU_HANDLE_STRIDE;\n}\n\n \nstatic inline unsigned long gru_chiplet_paddr(unsigned long paddr, int pnode,\n\t\t\t\t\t\t\tint chiplet)\n{\n\treturn paddr + GRU_SIZE * (2 * pnode  + chiplet);\n}\n\nstatic inline void *gru_chiplet_vaddr(void *vaddr, int pnode, int chiplet)\n{\n\treturn vaddr + GRU_SIZE * (2 * pnode  + chiplet);\n}\n\nstatic inline struct gru_control_block_extended *gru_tfh_to_cbe(\n\t\t\t\t\tstruct gru_tlb_fault_handle *tfh)\n{\n\tunsigned long cbe;\n\n\tcbe = (unsigned long)tfh - GRU_TFH_BASE + GRU_CBE_BASE;\n\treturn (struct gru_control_block_extended*)cbe;\n}\n\n\n\n\n \nstruct gru_tlb_fault_map {\n\tunsigned long fault_bits[BITS_TO_LONGS(GRU_NUM_CBE)];\n\tunsigned long fill0[2];\n\tunsigned long done_bits[BITS_TO_LONGS(GRU_NUM_CBE)];\n\tunsigned long fill1[2];\n};\n\n \nstruct gru_tlb_global_handle {\n\tunsigned int cmd:1;\t\t \n\tunsigned int delresp:1;\n\tunsigned int opc:1;\n\tunsigned int fill1:5;\n\n\tunsigned int fill2:8;\n\n\tunsigned int status:2;\n\tunsigned long fill3:2;\n\tunsigned int state:3;\n\tunsigned long fill4:1;\n\n\tunsigned int cause:3;\n\tunsigned long fill5:37;\n\n\tunsigned long vaddr:64;\t\t \n\n\tunsigned int asid:24;\t\t \n\tunsigned int fill6:8;\n\n\tunsigned int pagesize:5;\n\tunsigned int fill7:11;\n\n\tunsigned int global:1;\n\tunsigned int fill8:15;\n\n\tunsigned long vaddrmask:39;\t \n\tunsigned int fill9:9;\n\tunsigned int n:10;\n\tunsigned int fill10:6;\n\n\tunsigned int ctxbitmap:16;\t \n\tunsigned long fill11[3];\n};\n\nenum gru_tgh_cmd {\n\tTGHCMD_START\n};\n\nenum gru_tgh_opc {\n\tTGHOP_TLBNOP,\n\tTGHOP_TLBINV\n};\n\nenum gru_tgh_status {\n\tTGHSTATUS_IDLE,\n\tTGHSTATUS_EXCEPTION,\n\tTGHSTATUS_ACTIVE\n};\n\nenum gru_tgh_state {\n\tTGHSTATE_IDLE,\n\tTGHSTATE_PE_INVAL,\n\tTGHSTATE_INTERRUPT_INVAL,\n\tTGHSTATE_WAITDONE,\n\tTGHSTATE_RESTART_CTX,\n};\n\nenum gru_tgh_cause {\n\tTGHCAUSE_RR_ECC,\n\tTGHCAUSE_TLB_ECC,\n\tTGHCAUSE_LRU_ECC,\n\tTGHCAUSE_PS_ECC,\n\tTGHCAUSE_MUL_ERR,\n\tTGHCAUSE_DATA_ERR,\n\tTGHCAUSE_SW_FORCE\n};\n\n\n \nstruct gru_tlb_fault_handle {\n\tunsigned int cmd:1;\t\t \n\tunsigned int delresp:1;\n\tunsigned int fill0:2;\n\tunsigned int opc:3;\n\tunsigned int fill1:9;\n\n\tunsigned int status:2;\n\tunsigned int fill2:2;\n\tunsigned int state:3;\n\tunsigned int fill3:1;\n\n\tunsigned int cause:6;\n\tunsigned int cb_int:1;\n\tunsigned int fill4:1;\n\n\tunsigned int indexway:12;\t \n\tunsigned int fill5:4;\n\n\tunsigned int ctxnum:4;\n\tunsigned int fill6:12;\n\n\tunsigned long missvaddr:64;\t \n\n\tunsigned int missasid:24;\t \n\tunsigned int fill7:8;\n\tunsigned int fillasid:24;\n\tunsigned int dirty:1;\n\tunsigned int gaa:2;\n\tunsigned long fill8:5;\n\n\tunsigned long pfn:41;\t\t \n\tunsigned int fill9:7;\n\tunsigned int pagesize:5;\n\tunsigned int fill10:11;\n\n\tunsigned long fillvaddr:64;\t \n\n\tunsigned long fill11[3];\n};\n\nenum gru_tfh_opc {\n\tTFHOP_NOOP,\n\tTFHOP_RESTART,\n\tTFHOP_WRITE_ONLY,\n\tTFHOP_WRITE_RESTART,\n\tTFHOP_EXCEPTION,\n\tTFHOP_USER_POLLING_MODE = 7,\n};\n\nenum tfh_status {\n\tTFHSTATUS_IDLE,\n\tTFHSTATUS_EXCEPTION,\n\tTFHSTATUS_ACTIVE,\n};\n\nenum tfh_state {\n\tTFHSTATE_INACTIVE,\n\tTFHSTATE_IDLE,\n\tTFHSTATE_MISS_UPM,\n\tTFHSTATE_MISS_FMM,\n\tTFHSTATE_HW_ERR,\n\tTFHSTATE_WRITE_TLB,\n\tTFHSTATE_RESTART_CBR,\n};\n\n \nenum tfh_cause {\n\tTFHCAUSE_NONE,\n\tTFHCAUSE_TLB_MISS,\n\tTFHCAUSE_TLB_MOD,\n\tTFHCAUSE_HW_ERROR_RR,\n\tTFHCAUSE_HW_ERROR_MAIN_ARRAY,\n\tTFHCAUSE_HW_ERROR_VALID,\n\tTFHCAUSE_HW_ERROR_PAGESIZE,\n\tTFHCAUSE_INSTRUCTION_EXCEPTION,\n\tTFHCAUSE_UNCORRECTIBLE_ERROR,\n};\n\n \n#define GAA_RAM\t\t\t\t0x0\n#define GAA_NCRAM\t\t\t0x2\n#define GAA_MMIO\t\t\t0x1\n#define GAA_REGISTER\t\t\t0x3\n\n \n#define GRU_PADDR_SHIFT\t\t\t12\n\n \nstruct gru_context_configuration_handle {\n\tunsigned int cmd:1;\t\t\t \n\tunsigned int delresp:1;\n\tunsigned int opc:3;\n\tunsigned int unmap_enable:1;\n\tunsigned int req_slice_set_enable:1;\n\tunsigned int req_slice:2;\n\tunsigned int cb_int_enable:1;\n\tunsigned int tlb_int_enable:1;\n\tunsigned int tfm_fault_bit_enable:1;\n\tunsigned int tlb_int_select:4;\n\n\tunsigned int status:2;\n\tunsigned int state:2;\n\tunsigned int reserved2:4;\n\n\tunsigned int cause:4;\n\tunsigned int tfm_done_bit_enable:1;\n\tunsigned int unused:3;\n\n\tunsigned int dsr_allocation_map;\n\n\tunsigned long cbr_allocation_map;\t \n\n\tunsigned int asid[8];\t\t\t \n\tunsigned short sizeavail[8];\t\t \n} __attribute__ ((packed));\n\nenum gru_cch_opc {\n\tCCHOP_START = 1,\n\tCCHOP_ALLOCATE,\n\tCCHOP_INTERRUPT,\n\tCCHOP_DEALLOCATE,\n\tCCHOP_INTERRUPT_SYNC,\n};\n\nenum gru_cch_status {\n\tCCHSTATUS_IDLE,\n\tCCHSTATUS_EXCEPTION,\n\tCCHSTATUS_ACTIVE,\n};\n\nenum gru_cch_state {\n\tCCHSTATE_INACTIVE,\n\tCCHSTATE_MAPPED,\n\tCCHSTATE_ACTIVE,\n\tCCHSTATE_INTERRUPTED,\n};\n\n \nenum gru_cch_cause {\n\tCCHCAUSE_REGION_REGISTER_WRITE_ERROR = 1,\n\tCCHCAUSE_ILLEGAL_OPCODE = 2,\n\tCCHCAUSE_INVALID_START_REQUEST = 3,\n\tCCHCAUSE_INVALID_ALLOCATION_REQUEST = 4,\n\tCCHCAUSE_INVALID_DEALLOCATION_REQUEST = 5,\n\tCCHCAUSE_INVALID_INTERRUPT_REQUEST = 6,\n\tCCHCAUSE_CCH_BUSY = 7,\n\tCCHCAUSE_NO_CBRS_TO_ALLOCATE = 8,\n\tCCHCAUSE_BAD_TFM_CONFIG = 9,\n\tCCHCAUSE_CBR_RESOURCES_OVERSUBSCRIPED = 10,\n\tCCHCAUSE_DSR_RESOURCES_OVERSUBSCRIPED = 11,\n\tCCHCAUSE_CBR_DEALLOCATION_ERROR = 12,\n};\n \nstruct gru_control_block_extended {\n\tunsigned int reserved0:1;\t \n\tunsigned int imacpy:3;\n\tunsigned int reserved1:4;\n\tunsigned int xtypecpy:3;\n\tunsigned int iaa0cpy:2;\n\tunsigned int iaa1cpy:2;\n\tunsigned int reserved2:1;\n\tunsigned int opccpy:8;\n\tunsigned int exopccpy:8;\n\n\tunsigned int idef2cpy:22;\t \n\tunsigned int reserved3:10;\n\n\tunsigned int idef4cpy:22;\t \n\tunsigned int reserved4:10;\n\tunsigned int idef4upd:22;\n\tunsigned int reserved5:10;\n\n\tunsigned long idef1upd:64;\t \n\n\tunsigned long idef5cpy:64;\t \n\n\tunsigned long idef6cpy:64;\t \n\n\tunsigned long idef3upd:64;\t \n\n\tunsigned long idef5upd:64;\t \n\n\tunsigned int idef2upd:22;\t \n\tunsigned int reserved6:10;\n\n\tunsigned int ecause:20;\n\tunsigned int cbrstate:4;\n\tunsigned int cbrexecstatus:8;\n};\n\n \n#define cbe_baddr0\tidef1upd\n#define cbe_baddr1\tidef3upd\n#define cbe_src_cl\tidef6cpy\n#define cbe_nelemcur\tidef5upd\n\nenum gru_cbr_state {\n\tCBRSTATE_INACTIVE,\n\tCBRSTATE_IDLE,\n\tCBRSTATE_PE_CHECK,\n\tCBRSTATE_QUEUED,\n\tCBRSTATE_WAIT_RESPONSE,\n\tCBRSTATE_INTERRUPTED,\n\tCBRSTATE_INTERRUPTED_MISS_FMM,\n\tCBRSTATE_BUSY_INTERRUPT_MISS_FMM,\n\tCBRSTATE_INTERRUPTED_MISS_UPM,\n\tCBRSTATE_BUSY_INTERRUPTED_MISS_UPM,\n\tCBRSTATE_REQUEST_ISSUE,\n\tCBRSTATE_BUSY_INTERRUPT,\n};\n\n \n \n\n \n#define GRU_PAGESIZE(sh)\t((((sh) > 20 ? (sh) + 2 : (sh)) >> 1) - 6)\n#define GRU_SIZEAVAIL(sh)\t(1UL << GRU_PAGESIZE(sh))\n\n \n#define GRUMAXINVAL\t\t1024UL\n\nint cch_allocate(struct gru_context_configuration_handle *cch);\nint cch_start(struct gru_context_configuration_handle *cch);\nint cch_interrupt(struct gru_context_configuration_handle *cch);\nint cch_deallocate(struct gru_context_configuration_handle *cch);\nint cch_interrupt_sync(struct gru_context_configuration_handle *cch);\nint tgh_invalidate(struct gru_tlb_global_handle *tgh, unsigned long vaddr,\n\tunsigned long vaddrmask, int asid, int pagesize, int global, int n,\n\tunsigned short ctxbitmap);\nint tfh_write_only(struct gru_tlb_fault_handle *tfh, unsigned long paddr,\n\tint gaa, unsigned long vaddr, int asid, int dirty, int pagesize);\nvoid tfh_write_restart(struct gru_tlb_fault_handle *tfh, unsigned long paddr,\n\tint gaa, unsigned long vaddr, int asid, int dirty, int pagesize);\nvoid tfh_user_polling_mode(struct gru_tlb_fault_handle *tfh);\nvoid tfh_exception(struct gru_tlb_fault_handle *tfh);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}