{
  "module_name": "lattice-ecp3-config.c",
  "hash_id": "12d4a594c99db68c335b2a4c827ffed6b5a3b5b855d8234ddb11fdcc4533030f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/lattice-ecp3-config.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <asm/unaligned.h>\n\n#define FIRMWARE_NAME\t\"lattice-ecp3.bit\"\n\n \n#define ID_ECP3_17\t0xc2088080\n#define ID_ECP3_35\t0xc2048080\n\n \n#define FPGA_CMD_READ_ID\t0x07\t \n#define FPGA_CMD_READ_STATUS\t0x09\t \n#define FPGA_CMD_CLEAR\t\t0x70\n#define FPGA_CMD_REFRESH\t0x71\n#define FPGA_CMD_WRITE_EN\t0x4a\t \n#define FPGA_CMD_WRITE_DIS\t0x4f\t \n#define FPGA_CMD_WRITE_INC\t0x41\t \n\n \n#define FPGA_STATUS_DONE\t0x00004000\n#define FPGA_STATUS_CLEARED\t0x00010000\n\n#define FPGA_CLEAR_TIMEOUT\t5000\t \n#define FPGA_CLEAR_MSLEEP\t10\n#define FPGA_CLEAR_LOOP_COUNT\t(FPGA_CLEAR_TIMEOUT / FPGA_CLEAR_MSLEEP)\n\nstruct fpga_data {\n\tstruct completion fw_loaded;\n};\n\nstruct ecp3_dev {\n\tu32 jedec_id;\n\tchar *name;\n};\n\nstatic const struct ecp3_dev ecp3_dev[] = {\n\t{\n\t\t.jedec_id = ID_ECP3_17,\n\t\t.name = \"Lattice ECP3-17\",\n\t},\n\t{\n\t\t.jedec_id = ID_ECP3_35,\n\t\t.name = \"Lattice ECP3-35\",\n\t},\n};\n\nstatic void firmware_load(const struct firmware *fw, void *context)\n{\n\tstruct spi_device *spi = (struct spi_device *)context;\n\tstruct fpga_data *data = spi_get_drvdata(spi);\n\tu8 *buffer;\n\tu8 txbuf[8];\n\tu8 rxbuf[8];\n\tint rx_len = 8;\n\tint i;\n\tu32 jedec_id;\n\tu32 status;\n\n\tif (fw == NULL) {\n\t\tdev_err(&spi->dev, \"Cannot load firmware, aborting\\n\");\n\t\tgoto out;\n\t}\n\n\tif (fw->size == 0) {\n\t\tdev_err(&spi->dev, \"Error: Firmware size is 0!\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\ttxbuf[1] = 0x00;\n\ttxbuf[2] = 0x00;\n\ttxbuf[3] = 0x00;\n\n\t \n\ttxbuf[0] = FPGA_CMD_READ_ID;\n\tspi_write_then_read(spi, txbuf, 8, rxbuf, rx_len);\n\tjedec_id = get_unaligned_be32(&rxbuf[4]);\n\tdev_dbg(&spi->dev, \"FPGA JTAG ID=%08x\\n\", jedec_id);\n\n\tfor (i = 0; i < ARRAY_SIZE(ecp3_dev); i++) {\n\t\tif (jedec_id == ecp3_dev[i].jedec_id)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(ecp3_dev)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Error: No supported FPGA detected (JEDEC_ID=%08x)!\\n\",\n\t\t\tjedec_id);\n\t\tgoto out;\n\t}\n\n\tdev_info(&spi->dev, \"FPGA %s detected\\n\", ecp3_dev[i].name);\n\n\ttxbuf[0] = FPGA_CMD_READ_STATUS;\n\tspi_write_then_read(spi, txbuf, 8, rxbuf, rx_len);\n\tstatus = get_unaligned_be32(&rxbuf[4]);\n\tdev_dbg(&spi->dev, \"FPGA Status=%08x\\n\", status);\n\n\tbuffer = kzalloc(fw->size + 8, GFP_KERNEL);\n\tif (!buffer) {\n\t\tdev_err(&spi->dev, \"Error: Can't allocate memory!\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tbuffer[0] = FPGA_CMD_WRITE_INC;\n\tbuffer[1] = 0xff;\n\tbuffer[2] = 0xff;\n\tbuffer[3] = 0xff;\n\tmemcpy(buffer + 4, fw->data, fw->size);\n\n\ttxbuf[0] = FPGA_CMD_REFRESH;\n\tspi_write(spi, txbuf, 4);\n\n\ttxbuf[0] = FPGA_CMD_WRITE_EN;\n\tspi_write(spi, txbuf, 4);\n\n\ttxbuf[0] = FPGA_CMD_CLEAR;\n\tspi_write(spi, txbuf, 4);\n\n\t \n\tfor (i = 0; i < FPGA_CLEAR_LOOP_COUNT; i++) {\n\t\ttxbuf[0] = FPGA_CMD_READ_STATUS;\n\t\tspi_write_then_read(spi, txbuf, 8, rxbuf, rx_len);\n\t\tstatus = get_unaligned_be32(&rxbuf[4]);\n\t\tif (status == FPGA_STATUS_CLEARED)\n\t\t\tbreak;\n\n\t\tmsleep(FPGA_CLEAR_MSLEEP);\n\t}\n\n\tif (i == FPGA_CLEAR_LOOP_COUNT) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Error: Timeout waiting for FPGA to clear (status=%08x)!\\n\",\n\t\t\tstatus);\n\t\tkfree(buffer);\n\t\tgoto out;\n\t}\n\n\tdev_info(&spi->dev, \"Configuring the FPGA...\\n\");\n\tspi_write(spi, buffer, fw->size + 8);\n\n\ttxbuf[0] = FPGA_CMD_WRITE_DIS;\n\tspi_write(spi, txbuf, 4);\n\n\ttxbuf[0] = FPGA_CMD_READ_STATUS;\n\tspi_write_then_read(spi, txbuf, 8, rxbuf, rx_len);\n\tstatus = get_unaligned_be32(&rxbuf[4]);\n\tdev_dbg(&spi->dev, \"FPGA Status=%08x\\n\", status);\n\n\t \n\tif (status & FPGA_STATUS_DONE)\n\t\tdev_info(&spi->dev, \"FPGA successfully configured!\\n\");\n\telse\n\t\tdev_info(&spi->dev, \"FPGA not configured (DONE not set)\\n\");\n\n\t \n\trelease_firmware(fw);\n\n\tkfree(buffer);\nout:\n\tcomplete(&data->fw_loaded);\n}\n\nstatic int lattice_ecp3_probe(struct spi_device *spi)\n{\n\tstruct fpga_data *data;\n\tint err;\n\n\tdata = devm_kzalloc(&spi->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tdev_err(&spi->dev, \"Memory allocation for fpga_data failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspi_set_drvdata(spi, data);\n\n\tinit_completion(&data->fw_loaded);\n\terr = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,\n\t\t\t\t      FIRMWARE_NAME, &spi->dev,\n\t\t\t\t      GFP_KERNEL, spi, firmware_load);\n\tif (err) {\n\t\tdev_err(&spi->dev, \"Firmware loading failed with %d!\\n\", err);\n\t\treturn err;\n\t}\n\n\tdev_info(&spi->dev, \"FPGA bitstream configuration driver registered\\n\");\n\n\treturn 0;\n}\n\nstatic void lattice_ecp3_remove(struct spi_device *spi)\n{\n\tstruct fpga_data *data = spi_get_drvdata(spi);\n\n\twait_for_completion(&data->fw_loaded);\n}\n\nstatic const struct spi_device_id lattice_ecp3_id[] = {\n\t{ \"ecp3-17\", 0 },\n\t{ \"ecp3-35\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, lattice_ecp3_id);\n\nstatic struct spi_driver lattice_ecp3_driver = {\n\t.driver = {\n\t\t.name = \"lattice-ecp3\",\n\t},\n\t.probe = lattice_ecp3_probe,\n\t.remove = lattice_ecp3_remove,\n\t.id_table = lattice_ecp3_id,\n};\n\nmodule_spi_driver(lattice_ecp3_driver);\n\nMODULE_AUTHOR(\"Stefan Roese <sr@denx.de>\");\nMODULE_DESCRIPTION(\"Lattice ECP3 FPGA configuration via SPI\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}