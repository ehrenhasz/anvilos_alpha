{
  "module_name": "altera-jtag.c",
  "hash_id": "20f8263604b6d70cca222062e2c6364818b233361346044eacfc57339ce280e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/altera-stapl/altera-jtag.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <misc/altera.h>\n#include \"altera-exprt.h\"\n#include \"altera-jtag.h\"\n\n#define\talt_jtag_io(a, b, c)\\\n\t\tastate->config->jtag_io(astate->config->dev, a, b, c);\n\n#define\talt_malloc(a)\tkzalloc(a, GFP_KERNEL);\n\n \nstruct altera_jtag_machine {\n\tenum altera_jtag_state tms_high;\n\tenum altera_jtag_state tms_low;\n};\n\nstatic const struct altera_jtag_machine altera_transitions[] = {\n\t \t{ RESET,\tIDLE },\n\t \t{ DRSELECT,\tIDLE },\n\t \t{ IRSELECT,\tDRCAPTURE },\n\t \t{ DREXIT1,\tDRSHIFT },\n\t \t{ DREXIT1,\tDRSHIFT },\n\t \t{ DRUPDATE,\tDRPAUSE },\n\t \t{ DREXIT2,\tDRPAUSE },\n\t \t{ DRUPDATE,\tDRSHIFT },\n\t \t{ DRSELECT,\tIDLE },\n\t \t{ RESET,\tIRCAPTURE },\n\t \t{ IREXIT1,\tIRSHIFT },\n\t \t{ IREXIT1,\tIRSHIFT },\n\t \t{ IRUPDATE,\tIRPAUSE },\n\t \t{ IREXIT2,\tIRPAUSE },\n\t \t{ IRUPDATE,\tIRSHIFT },\n\t \t{ DRSELECT,\tIDLE }\n};\n\n \nstatic const u16 altera_jtag_path_map[16] = {\n\t \n\t0x0001,\t0xFFFD,\t0xFE01,\t0xFFE7,\t0xFFEF,\t0xFF0F,\t0xFFBF,\t0xFFFF,\n\t \n\t0xFEFD,\t0x0001,\t0xF3FF,\t0xF7FF,\t0x87FF,\t0xDFFF,\t0xFFFF,\t0x7FFD\n};\n\n \n#define TMS_HIGH   1\n#define TMS_LOW    0\n#define TDI_HIGH   1\n#define TDI_LOW    0\n#define READ_TDO   1\n#define IGNORE_TDO 0\n\nint altera_jinit(struct altera_state *astate)\n{\n\tstruct altera_jtag *js = &astate->js;\n\n\t \n\tjs->jtag_state = ILLEGAL_JTAG_STATE;\n\n\t \n\tjs->drstop_state = IDLE;\n\tjs->irstop_state = IDLE;\n\tjs->dr_pre  = 0;\n\tjs->dr_post = 0;\n\tjs->ir_pre  = 0;\n\tjs->ir_post = 0;\n\tjs->dr_length    = 0;\n\tjs->ir_length    = 0;\n\n\tjs->dr_pre_data  = NULL;\n\tjs->dr_post_data = NULL;\n\tjs->ir_pre_data  = NULL;\n\tjs->ir_post_data = NULL;\n\tjs->dr_buffer\t = NULL;\n\tjs->ir_buffer\t = NULL;\n\n\treturn 0;\n}\n\nint altera_set_drstop(struct altera_jtag *js, enum altera_jtag_state state)\n{\n\tjs->drstop_state = state;\n\n\treturn 0;\n}\n\nint altera_set_irstop(struct altera_jtag *js, enum altera_jtag_state state)\n{\n\tjs->irstop_state = state;\n\n\treturn 0;\n}\n\nint altera_set_dr_pre(struct altera_jtag *js,\n\t\t\t\tu32 count, u32 start_index,\n\t\t\t\tu8 *preamble_data)\n{\n\tint status = 0;\n\tu32 i;\n\tu32 j;\n\n\tif (count > js->dr_pre) {\n\t\tkfree(js->dr_pre_data);\n\t\tjs->dr_pre_data = (u8 *)alt_malloc((count + 7) >> 3);\n\t\tif (js->dr_pre_data == NULL)\n\t\t\tstatus = -ENOMEM;\n\t\telse\n\t\t\tjs->dr_pre = count;\n\t} else\n\t\tjs->dr_pre = count;\n\n\tif (status == 0) {\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tj = i + start_index;\n\n\t\t\tif (preamble_data == NULL)\n\t\t\t\tjs->dr_pre_data[i >> 3] |= (1 << (i & 7));\n\t\t\telse {\n\t\t\t\tif (preamble_data[j >> 3] & (1 << (j & 7)))\n\t\t\t\t\tjs->dr_pre_data[i >> 3] |=\n\t\t\t\t\t\t\t(1 << (i & 7));\n\t\t\t\telse\n\t\t\t\t\tjs->dr_pre_data[i >> 3] &=\n\t\t\t\t\t\t\t~(u32)(1 << (i & 7));\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n\nint altera_set_ir_pre(struct altera_jtag *js, u32 count, u32 start_index,\n\t\t\t\t\t\t\tu8 *preamble_data)\n{\n\tint status = 0;\n\tu32 i;\n\tu32 j;\n\n\tif (count > js->ir_pre) {\n\t\tkfree(js->ir_pre_data);\n\t\tjs->ir_pre_data = (u8 *)alt_malloc((count + 7) >> 3);\n\t\tif (js->ir_pre_data == NULL)\n\t\t\tstatus = -ENOMEM;\n\t\telse\n\t\t\tjs->ir_pre = count;\n\n\t} else\n\t\tjs->ir_pre = count;\n\n\tif (status == 0) {\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tj = i + start_index;\n\t\t\tif (preamble_data == NULL)\n\t\t\t\tjs->ir_pre_data[i >> 3] |= (1 << (i & 7));\n\t\t\telse {\n\t\t\t\tif (preamble_data[j >> 3] & (1 << (j & 7)))\n\t\t\t\t\tjs->ir_pre_data[i >> 3] |=\n\t\t\t\t\t\t\t(1 << (i & 7));\n\t\t\t\telse\n\t\t\t\t\tjs->ir_pre_data[i >> 3] &=\n\t\t\t\t\t\t\t~(u32)(1 << (i & 7));\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n\nint altera_set_dr_post(struct altera_jtag *js, u32 count, u32 start_index,\n\t\t\t\t\t\tu8 *postamble_data)\n{\n\tint status = 0;\n\tu32 i;\n\tu32 j;\n\n\tif (count > js->dr_post) {\n\t\tkfree(js->dr_post_data);\n\t\tjs->dr_post_data = (u8 *)alt_malloc((count + 7) >> 3);\n\n\t\tif (js->dr_post_data == NULL)\n\t\t\tstatus = -ENOMEM;\n\t\telse\n\t\t\tjs->dr_post = count;\n\n\t} else\n\t\tjs->dr_post = count;\n\n\tif (status == 0) {\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tj = i + start_index;\n\n\t\t\tif (postamble_data == NULL)\n\t\t\t\tjs->dr_post_data[i >> 3] |= (1 << (i & 7));\n\t\t\telse {\n\t\t\t\tif (postamble_data[j >> 3] & (1 << (j & 7)))\n\t\t\t\t\tjs->dr_post_data[i >> 3] |=\n\t\t\t\t\t\t\t\t(1 << (i & 7));\n\t\t\t\telse\n\t\t\t\t\tjs->dr_post_data[i >> 3] &=\n\t\t\t\t\t    ~(u32)(1 << (i & 7));\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n\nint altera_set_ir_post(struct altera_jtag *js, u32 count, u32 start_index,\n\t\t\t\t\t\tu8 *postamble_data)\n{\n\tint status = 0;\n\tu32 i;\n\tu32 j;\n\n\tif (count > js->ir_post) {\n\t\tkfree(js->ir_post_data);\n\t\tjs->ir_post_data = (u8 *)alt_malloc((count + 7) >> 3);\n\t\tif (js->ir_post_data == NULL)\n\t\t\tstatus = -ENOMEM;\n\t\telse\n\t\t\tjs->ir_post = count;\n\n\t} else\n\t\tjs->ir_post = count;\n\n\tif (status != 0)\n\t\treturn status;\n\n\tfor (i = 0; i < count; ++i) {\n\t\tj = i + start_index;\n\n\t\tif (postamble_data == NULL)\n\t\t\tjs->ir_post_data[i >> 3] |= (1 << (i & 7));\n\t\telse {\n\t\t\tif (postamble_data[j >> 3] & (1 << (j & 7)))\n\t\t\t\tjs->ir_post_data[i >> 3] |= (1 << (i & 7));\n\t\t\telse\n\t\t\t\tjs->ir_post_data[i >> 3] &=\n\t\t\t\t    ~(u32)(1 << (i & 7));\n\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic void altera_jreset_idle(struct altera_state *astate)\n{\n\tstruct altera_jtag *js = &astate->js;\n\tint i;\n\t \n\tfor (i = 0; i < 5; ++i)\n\t\talt_jtag_io(TMS_HIGH, TDI_LOW, IGNORE_TDO);\n\n\t \n\talt_jtag_io(TMS_LOW, TDI_LOW, IGNORE_TDO);\n\tjs->jtag_state = IDLE;\n}\n\nint altera_goto_jstate(struct altera_state *astate,\n\t\t\t\t\tenum altera_jtag_state state)\n{\n\tstruct altera_jtag *js = &astate->js;\n\tint tms;\n\tint count = 0;\n\tint status = 0;\n\n\tif (js->jtag_state == ILLEGAL_JTAG_STATE)\n\t\t \n\t\taltera_jreset_idle(astate);\n\n\tif (js->jtag_state == state) {\n\t\t \n\t\tif ((state == IDLE) || (state == DRSHIFT) ||\n\t\t\t(state == DRPAUSE) || (state == IRSHIFT) ||\n\t\t\t\t(state == IRPAUSE)) {\n\t\t\talt_jtag_io(TMS_LOW, TDI_LOW, IGNORE_TDO);\n\t\t} else if (state == RESET)\n\t\t\talt_jtag_io(TMS_HIGH, TDI_LOW, IGNORE_TDO);\n\n\t} else {\n\t\twhile ((js->jtag_state != state) && (count < 9)) {\n\t\t\t \n\t\t\ttms = (altera_jtag_path_map[js->jtag_state] &\n\t\t\t\t\t\t\t(1 << state))\n\t\t\t\t\t\t\t? TMS_HIGH : TMS_LOW;\n\n\t\t\t \n\t\t\talt_jtag_io(tms, TDI_LOW, IGNORE_TDO);\n\n\t\t\tif (tms)\n\t\t\t\tjs->jtag_state =\n\t\t\t\t\taltera_transitions[js->jtag_state].tms_high;\n\t\t\telse\n\t\t\t\tjs->jtag_state =\n\t\t\t\t\taltera_transitions[js->jtag_state].tms_low;\n\n\t\t\t++count;\n\t\t}\n\t}\n\n\tif (js->jtag_state != state)\n\t\tstatus = -EREMOTEIO;\n\n\treturn status;\n}\n\nint altera_wait_cycles(struct altera_state *astate,\n\t\t\t\t\ts32 cycles,\n\t\t\t\t\tenum altera_jtag_state wait_state)\n{\n\tstruct altera_jtag *js = &astate->js;\n\tint tms;\n\ts32 count;\n\tint status = 0;\n\n\tif (js->jtag_state != wait_state)\n\t\tstatus = altera_goto_jstate(astate, wait_state);\n\n\tif (status == 0) {\n\t\t \n\t\ttms = (wait_state == RESET) ? TMS_HIGH : TMS_LOW;\n\n\t\tfor (count = 0L; count < cycles; count++)\n\t\t\talt_jtag_io(tms, TDI_LOW, IGNORE_TDO);\n\n\t}\n\n\treturn status;\n}\n\nint altera_wait_msecs(struct altera_state *astate,\n\t\t\ts32 microseconds, enum altera_jtag_state wait_state)\n \n{\n\tstruct altera_jtag *js = &astate->js;\n\tint status = 0;\n\n\tif ((js->jtag_state != ILLEGAL_JTAG_STATE) &&\n\t    (js->jtag_state != wait_state))\n\t\tstatus = altera_goto_jstate(astate, wait_state);\n\n\tif (status == 0)\n\t\t \n\t\tudelay(microseconds);\n\n\treturn status;\n}\n\nstatic void altera_concatenate_data(u8 *buffer,\n\t\t\t\tu8 *preamble_data,\n\t\t\t\tu32 preamble_count,\n\t\t\t\tu8 *target_data,\n\t\t\t\tu32 start_index,\n\t\t\t\tu32 target_count,\n\t\t\t\tu8 *postamble_data,\n\t\t\t\tu32 postamble_count)\n \n{\n\tu32 i, j, k;\n\n\tfor (i = 0L; i < preamble_count; ++i) {\n\t\tif (preamble_data[i >> 3L] & (1L << (i & 7L)))\n\t\t\tbuffer[i >> 3L] |= (1L << (i & 7L));\n\t\telse\n\t\t\tbuffer[i >> 3L] &= ~(u32)(1L << (i & 7L));\n\n\t}\n\n\tj = start_index;\n\tk = preamble_count + target_count;\n\tfor (; i < k; ++i, ++j) {\n\t\tif (target_data[j >> 3L] & (1L << (j & 7L)))\n\t\t\tbuffer[i >> 3L] |= (1L << (i & 7L));\n\t\telse\n\t\t\tbuffer[i >> 3L] &= ~(u32)(1L << (i & 7L));\n\n\t}\n\n\tj = 0L;\n\tk = preamble_count + target_count + postamble_count;\n\tfor (; i < k; ++i, ++j) {\n\t\tif (postamble_data[j >> 3L] & (1L << (j & 7L)))\n\t\t\tbuffer[i >> 3L] |= (1L << (i & 7L));\n\t\telse\n\t\t\tbuffer[i >> 3L] &= ~(u32)(1L << (i & 7L));\n\n\t}\n}\n\nstatic int alt_jtag_drscan(struct altera_state *astate,\n\t\t\tint start_state,\n\t\t\tint count,\n\t\t\tu8 *tdi,\n\t\t\tu8 *tdo)\n{\n\tint i = 0;\n\tint tdo_bit = 0;\n\tint status = 1;\n\n\t \n\tswitch (start_state) {\n\tcase 0:\t\t\t\t\t\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\tbreak;\n\n\tcase 1:\t\t\t\t\t\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\tbreak;\n\n\tcase 2:\t\t\t\t\t\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\tbreak;\n\n\tdefault:\n\t\tstatus = 0;\n\t}\n\n\tif (status) {\n\t\t \n\t\tfor (i = 0; i < count; i++) {\n\t\t\ttdo_bit = alt_jtag_io(\n\t\t\t\t\t(i == count - 1),\n\t\t\t\t\ttdi[i >> 3] & (1 << (i & 7)),\n\t\t\t\t\t(tdo != NULL));\n\n\t\t\tif (tdo != NULL) {\n\t\t\t\tif (tdo_bit)\n\t\t\t\t\ttdo[i >> 3] |= (1 << (i & 7));\n\t\t\t\telse\n\t\t\t\t\ttdo[i >> 3] &= ~(u32)(1 << (i & 7));\n\n\t\t\t}\n\t\t}\n\n\t\talt_jtag_io(0, 0, 0);\t \n\t}\n\n\treturn status;\n}\n\nstatic int alt_jtag_irscan(struct altera_state *astate,\n\t\t    int start_state,\n\t\t    int count,\n\t\t    u8 *tdi,\n\t\t    u8 *tdo)\n{\n\tint i = 0;\n\tint tdo_bit = 0;\n\tint status = 1;\n\n\t \n\tswitch (start_state) {\n\tcase 0:\t\t\t\t\t\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\tbreak;\n\n\tcase 1:\t\t\t\t\t\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\tbreak;\n\n\tcase 2:\t\t\t\t\t\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(1, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\talt_jtag_io(0, 0, 0);\t \n\t\tbreak;\n\n\tdefault:\n\t\tstatus = 0;\n\t}\n\n\tif (status) {\n\t\t \n\t\tfor (i = 0; i < count; i++) {\n\t\t\ttdo_bit = alt_jtag_io(\n\t\t\t\t      (i == count - 1),\n\t\t\t\t      tdi[i >> 3] & (1 << (i & 7)),\n\t\t\t\t      (tdo != NULL));\n\t\t\tif (tdo != NULL) {\n\t\t\t\tif (tdo_bit)\n\t\t\t\t\ttdo[i >> 3] |= (1 << (i & 7));\n\t\t\t\telse\n\t\t\t\t\ttdo[i >> 3] &= ~(u32)(1 << (i & 7));\n\n\t\t\t}\n\t\t}\n\n\t\talt_jtag_io(0, 0, 0);\t \n\t}\n\n\treturn status;\n}\n\nstatic void altera_extract_target_data(u8 *buffer,\n\t\t\t\tu8 *target_data,\n\t\t\t\tu32 start_index,\n\t\t\t\tu32 preamble_count,\n\t\t\t\tu32 target_count)\n \n{\n\tu32 i;\n\tu32 j;\n\tu32 k;\n\n\tj = preamble_count;\n\tk = start_index + target_count;\n\tfor (i = start_index; i < k; ++i, ++j) {\n\t\tif (buffer[j >> 3] & (1 << (j & 7)))\n\t\t\ttarget_data[i >> 3] |= (1 << (i & 7));\n\t\telse\n\t\t\ttarget_data[i >> 3] &= ~(u32)(1 << (i & 7));\n\n\t}\n}\n\nint altera_irscan(struct altera_state *astate,\n\t\t\t\tu32 count,\n\t\t\t\tu8 *tdi_data,\n\t\t\t\tu32 start_index)\n \n{\n\tstruct altera_jtag *js = &astate->js;\n\tint start_code = 0;\n\tu32 alloc_chars = 0;\n\tu32 shift_count = js->ir_pre + count + js->ir_post;\n\tint status = 0;\n\tenum altera_jtag_state start_state = ILLEGAL_JTAG_STATE;\n\n\tswitch (js->jtag_state) {\n\tcase ILLEGAL_JTAG_STATE:\n\tcase RESET:\n\tcase IDLE:\n\t\tstart_code = 0;\n\t\tstart_state = IDLE;\n\t\tbreak;\n\n\tcase DRSELECT:\n\tcase DRCAPTURE:\n\tcase DRSHIFT:\n\tcase DREXIT1:\n\tcase DRPAUSE:\n\tcase DREXIT2:\n\tcase DRUPDATE:\n\t\tstart_code = 1;\n\t\tstart_state = DRPAUSE;\n\t\tbreak;\n\n\tcase IRSELECT:\n\tcase IRCAPTURE:\n\tcase IRSHIFT:\n\tcase IREXIT1:\n\tcase IRPAUSE:\n\tcase IREXIT2:\n\tcase IRUPDATE:\n\t\tstart_code = 2;\n\t\tstart_state = IRPAUSE;\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EREMOTEIO;\n\t\tbreak;\n\t}\n\n\tif (status == 0)\n\t\tif (js->jtag_state != start_state)\n\t\t\tstatus = altera_goto_jstate(astate, start_state);\n\n\tif (status == 0) {\n\t\tif (shift_count > js->ir_length) {\n\t\t\talloc_chars = (shift_count + 7) >> 3;\n\t\t\tkfree(js->ir_buffer);\n\t\t\tjs->ir_buffer = (u8 *)alt_malloc(alloc_chars);\n\t\t\tif (js->ir_buffer == NULL)\n\t\t\t\tstatus = -ENOMEM;\n\t\t\telse\n\t\t\t\tjs->ir_length = alloc_chars * 8;\n\n\t\t}\n\t}\n\n\tif (status == 0) {\n\t\t \n\t\taltera_concatenate_data(js->ir_buffer,\n\t\t\t\t\tjs->ir_pre_data,\n\t\t\t\t\tjs->ir_pre,\n\t\t\t\t\ttdi_data,\n\t\t\t\t\tstart_index,\n\t\t\t\t\tcount,\n\t\t\t\t\tjs->ir_post_data,\n\t\t\t\t\tjs->ir_post);\n\t\t \n\t\talt_jtag_irscan(astate,\n\t\t\t\tstart_code,\n\t\t\t\tshift_count,\n\t\t\t\tjs->ir_buffer,\n\t\t\t\tNULL);\n\n\t\t \n\t\tjs->jtag_state = IRPAUSE;\n\t}\n\n\tif (status == 0)\n\t\tif (js->irstop_state != IRPAUSE)\n\t\t\tstatus = altera_goto_jstate(astate, js->irstop_state);\n\n\n\treturn status;\n}\n\nint altera_swap_ir(struct altera_state *astate,\n\t\t\t    u32 count,\n\t\t\t    u8 *in_data,\n\t\t\t    u32 in_index,\n\t\t\t    u8 *out_data,\n\t\t\t    u32 out_index)\n \n{\n\tstruct altera_jtag *js = &astate->js;\n\tint start_code = 0;\n\tu32 alloc_chars = 0;\n\tu32 shift_count = js->ir_pre + count + js->ir_post;\n\tint status = 0;\n\tenum altera_jtag_state start_state = ILLEGAL_JTAG_STATE;\n\n\tswitch (js->jtag_state) {\n\tcase ILLEGAL_JTAG_STATE:\n\tcase RESET:\n\tcase IDLE:\n\t\tstart_code = 0;\n\t\tstart_state = IDLE;\n\t\tbreak;\n\n\tcase DRSELECT:\n\tcase DRCAPTURE:\n\tcase DRSHIFT:\n\tcase DREXIT1:\n\tcase DRPAUSE:\n\tcase DREXIT2:\n\tcase DRUPDATE:\n\t\tstart_code = 1;\n\t\tstart_state = DRPAUSE;\n\t\tbreak;\n\n\tcase IRSELECT:\n\tcase IRCAPTURE:\n\tcase IRSHIFT:\n\tcase IREXIT1:\n\tcase IRPAUSE:\n\tcase IREXIT2:\n\tcase IRUPDATE:\n\t\tstart_code = 2;\n\t\tstart_state = IRPAUSE;\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EREMOTEIO;\n\t\tbreak;\n\t}\n\n\tif (status == 0)\n\t\tif (js->jtag_state != start_state)\n\t\t\tstatus = altera_goto_jstate(astate, start_state);\n\n\tif (status == 0) {\n\t\tif (shift_count > js->ir_length) {\n\t\t\talloc_chars = (shift_count + 7) >> 3;\n\t\t\tkfree(js->ir_buffer);\n\t\t\tjs->ir_buffer = (u8 *)alt_malloc(alloc_chars);\n\t\t\tif (js->ir_buffer == NULL)\n\t\t\t\tstatus = -ENOMEM;\n\t\t\telse\n\t\t\t\tjs->ir_length = alloc_chars * 8;\n\n\t\t}\n\t}\n\n\tif (status == 0) {\n\t\t \n\t\taltera_concatenate_data(js->ir_buffer,\n\t\t\t\t\tjs->ir_pre_data,\n\t\t\t\t\tjs->ir_pre,\n\t\t\t\t\tin_data,\n\t\t\t\t\tin_index,\n\t\t\t\t\tcount,\n\t\t\t\t\tjs->ir_post_data,\n\t\t\t\t\tjs->ir_post);\n\n\t\t \n\t\talt_jtag_irscan(astate,\n\t\t\t\tstart_code,\n\t\t\t\tshift_count,\n\t\t\t\tjs->ir_buffer,\n\t\t\t\tjs->ir_buffer);\n\n\t\t \n\t\tjs->jtag_state = IRPAUSE;\n\t}\n\n\tif (status == 0)\n\t\tif (js->irstop_state != IRPAUSE)\n\t\t\tstatus = altera_goto_jstate(astate, js->irstop_state);\n\n\n\tif (status == 0)\n\t\t \n\t\taltera_extract_target_data(js->ir_buffer,\n\t\t\t\t\tout_data, out_index,\n\t\t\t\t\tjs->ir_pre, count);\n\n\treturn status;\n}\n\nint altera_drscan(struct altera_state *astate,\n\t\t\t\tu32 count,\n\t\t\t\tu8 *tdi_data,\n\t\t\t\tu32 start_index)\n \n{\n\tstruct altera_jtag *js = &astate->js;\n\tint start_code = 0;\n\tu32 alloc_chars = 0;\n\tu32 shift_count = js->dr_pre + count + js->dr_post;\n\tint status = 0;\n\tenum altera_jtag_state start_state = ILLEGAL_JTAG_STATE;\n\n\tswitch (js->jtag_state) {\n\tcase ILLEGAL_JTAG_STATE:\n\tcase RESET:\n\tcase IDLE:\n\t\tstart_code = 0;\n\t\tstart_state = IDLE;\n\t\tbreak;\n\n\tcase DRSELECT:\n\tcase DRCAPTURE:\n\tcase DRSHIFT:\n\tcase DREXIT1:\n\tcase DRPAUSE:\n\tcase DREXIT2:\n\tcase DRUPDATE:\n\t\tstart_code = 1;\n\t\tstart_state = DRPAUSE;\n\t\tbreak;\n\n\tcase IRSELECT:\n\tcase IRCAPTURE:\n\tcase IRSHIFT:\n\tcase IREXIT1:\n\tcase IRPAUSE:\n\tcase IREXIT2:\n\tcase IRUPDATE:\n\t\tstart_code = 2;\n\t\tstart_state = IRPAUSE;\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EREMOTEIO;\n\t\tbreak;\n\t}\n\n\tif (status == 0)\n\t\tif (js->jtag_state != start_state)\n\t\t\tstatus = altera_goto_jstate(astate, start_state);\n\n\tif (status == 0) {\n\t\tif (shift_count > js->dr_length) {\n\t\t\talloc_chars = (shift_count + 7) >> 3;\n\t\t\tkfree(js->dr_buffer);\n\t\t\tjs->dr_buffer = (u8 *)alt_malloc(alloc_chars);\n\t\t\tif (js->dr_buffer == NULL)\n\t\t\t\tstatus = -ENOMEM;\n\t\t\telse\n\t\t\t\tjs->dr_length = alloc_chars * 8;\n\n\t\t}\n\t}\n\n\tif (status == 0) {\n\t\t \n\t\taltera_concatenate_data(js->dr_buffer,\n\t\t\t\t\tjs->dr_pre_data,\n\t\t\t\t\tjs->dr_pre,\n\t\t\t\t\ttdi_data,\n\t\t\t\t\tstart_index,\n\t\t\t\t\tcount,\n\t\t\t\t\tjs->dr_post_data,\n\t\t\t\t\tjs->dr_post);\n\t\t \n\t\talt_jtag_drscan(astate, start_code, shift_count,\n\t\t\t\tjs->dr_buffer, NULL);\n\t\t \n\t\tjs->jtag_state = DRPAUSE;\n\t}\n\n\tif (status == 0)\n\t\tif (js->drstop_state != DRPAUSE)\n\t\t\tstatus = altera_goto_jstate(astate, js->drstop_state);\n\n\treturn status;\n}\n\nint altera_swap_dr(struct altera_state *astate, u32 count,\n\t\t\t\tu8 *in_data, u32 in_index,\n\t\t\t\tu8 *out_data, u32 out_index)\n \n{\n\tstruct altera_jtag *js = &astate->js;\n\tint start_code = 0;\n\tu32 alloc_chars = 0;\n\tu32 shift_count = js->dr_pre + count + js->dr_post;\n\tint status = 0;\n\tenum altera_jtag_state start_state = ILLEGAL_JTAG_STATE;\n\n\tswitch (js->jtag_state) {\n\tcase ILLEGAL_JTAG_STATE:\n\tcase RESET:\n\tcase IDLE:\n\t\tstart_code = 0;\n\t\tstart_state = IDLE;\n\t\tbreak;\n\n\tcase DRSELECT:\n\tcase DRCAPTURE:\n\tcase DRSHIFT:\n\tcase DREXIT1:\n\tcase DRPAUSE:\n\tcase DREXIT2:\n\tcase DRUPDATE:\n\t\tstart_code = 1;\n\t\tstart_state = DRPAUSE;\n\t\tbreak;\n\n\tcase IRSELECT:\n\tcase IRCAPTURE:\n\tcase IRSHIFT:\n\tcase IREXIT1:\n\tcase IRPAUSE:\n\tcase IREXIT2:\n\tcase IRUPDATE:\n\t\tstart_code = 2;\n\t\tstart_state = IRPAUSE;\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EREMOTEIO;\n\t\tbreak;\n\t}\n\n\tif (status == 0)\n\t\tif (js->jtag_state != start_state)\n\t\t\tstatus = altera_goto_jstate(astate, start_state);\n\n\tif (status == 0) {\n\t\tif (shift_count > js->dr_length) {\n\t\t\talloc_chars = (shift_count + 7) >> 3;\n\t\t\tkfree(js->dr_buffer);\n\t\t\tjs->dr_buffer = (u8 *)alt_malloc(alloc_chars);\n\n\t\t\tif (js->dr_buffer == NULL)\n\t\t\t\tstatus = -ENOMEM;\n\t\t\telse\n\t\t\t\tjs->dr_length = alloc_chars * 8;\n\n\t\t}\n\t}\n\n\tif (status == 0) {\n\t\t \n\t\taltera_concatenate_data(js->dr_buffer,\n\t\t\t\tjs->dr_pre_data,\n\t\t\t\tjs->dr_pre,\n\t\t\t\tin_data,\n\t\t\t\tin_index,\n\t\t\t\tcount,\n\t\t\t\tjs->dr_post_data,\n\t\t\t\tjs->dr_post);\n\n\t\t \n\t\talt_jtag_drscan(astate,\n\t\t\t\tstart_code,\n\t\t\t\tshift_count,\n\t\t\t\tjs->dr_buffer,\n\t\t\t\tjs->dr_buffer);\n\n\t\t \n\t\tjs->jtag_state = DRPAUSE;\n\t}\n\n\tif (status == 0)\n\t\tif (js->drstop_state != DRPAUSE)\n\t\t\tstatus = altera_goto_jstate(astate, js->drstop_state);\n\n\tif (status == 0)\n\t\t \n\t\taltera_extract_target_data(js->dr_buffer,\n\t\t\t\t\tout_data,\n\t\t\t\t\tout_index,\n\t\t\t\t\tjs->dr_pre,\n\t\t\t\t\tcount);\n\n\treturn status;\n}\n\nvoid altera_free_buffers(struct altera_state *astate)\n{\n\tstruct altera_jtag *js = &astate->js;\n\t \n\tif (js->jtag_state != ILLEGAL_JTAG_STATE)\n\t\taltera_jreset_idle(astate);\n\n\tkfree(js->dr_pre_data);\n\tjs->dr_pre_data = NULL;\n\n\tkfree(js->dr_post_data);\n\tjs->dr_post_data = NULL;\n\n\tkfree(js->dr_buffer);\n\tjs->dr_buffer = NULL;\n\n\tkfree(js->ir_pre_data);\n\tjs->ir_pre_data = NULL;\n\n\tkfree(js->ir_post_data);\n\tjs->ir_post_data = NULL;\n\n\tkfree(js->ir_buffer);\n\tjs->ir_buffer = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}