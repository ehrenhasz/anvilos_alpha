{
  "module_name": "altera.c",
  "hash_id": "7132cf4094f3684e349f191311f1a57570d1d3272dc84cfe6291e411a8651fbb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/altera-stapl/altera.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <misc/altera.h>\n#include \"altera-exprt.h\"\n#include \"altera-jtag.h\"\n\nstatic int debug = 1;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debugging information\");\n\nMODULE_DESCRIPTION(\"altera FPGA kernel module\");\nMODULE_AUTHOR(\"Igor M. Liplianin  <liplianin@netup.ru>\");\nMODULE_LICENSE(\"GPL\");\n\n#define dprintk(args...) \\\n\tif (debug) { \\\n\t\tprintk(KERN_DEBUG args); \\\n\t}\n\nenum altera_fpga_opcode {\n\tOP_NOP = 0,\n\tOP_DUP,\n\tOP_SWP,\n\tOP_ADD,\n\tOP_SUB,\n\tOP_MULT,\n\tOP_DIV,\n\tOP_MOD,\n\tOP_SHL,\n\tOP_SHR,\n\tOP_NOT,\n\tOP_AND,\n\tOP_OR,\n\tOP_XOR,\n\tOP_INV,\n\tOP_GT,\n\tOP_LT,\n\tOP_RET,\n\tOP_CMPS,\n\tOP_PINT,\n\tOP_PRNT,\n\tOP_DSS,\n\tOP_DSSC,\n\tOP_ISS,\n\tOP_ISSC,\n\tOP_DPR = 0x1c,\n\tOP_DPRL,\n\tOP_DPO,\n\tOP_DPOL,\n\tOP_IPR,\n\tOP_IPRL,\n\tOP_IPO,\n\tOP_IPOL,\n\tOP_PCHR,\n\tOP_EXIT,\n\tOP_EQU,\n\tOP_POPT,\n\tOP_ABS = 0x2c,\n\tOP_BCH0,\n\tOP_PSH0 = 0x2f,\n\tOP_PSHL = 0x40,\n\tOP_PSHV,\n\tOP_JMP,\n\tOP_CALL,\n\tOP_NEXT,\n\tOP_PSTR,\n\tOP_SINT = 0x47,\n\tOP_ST,\n\tOP_ISTP,\n\tOP_DSTP,\n\tOP_SWPN,\n\tOP_DUPN,\n\tOP_POPV,\n\tOP_POPE,\n\tOP_POPA,\n\tOP_JMPZ,\n\tOP_DS,\n\tOP_IS,\n\tOP_DPRA,\n\tOP_DPOA,\n\tOP_IPRA,\n\tOP_IPOA,\n\tOP_EXPT,\n\tOP_PSHE,\n\tOP_PSHA,\n\tOP_DYNA,\n\tOP_EXPV = 0x5c,\n\tOP_COPY = 0x80,\n\tOP_REVA,\n\tOP_DSC,\n\tOP_ISC,\n\tOP_WAIT,\n\tOP_VS,\n\tOP_CMPA = 0xc0,\n\tOP_VSC,\n};\n\nstruct altera_procinfo {\n\tchar\t\t\t*name;\n\tu8\t\t\tattrs;\n\tstruct altera_procinfo\t*next;\n};\n\n \nstatic int altera_check_stack(int stack_ptr, int count, int *status)\n{\n\tif (stack_ptr < count) {\n\t\t*status = -EOVERFLOW;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void altera_export_int(char *key, s32 value)\n{\n\tdprintk(\"Export: key = \\\"%s\\\", value = %d\\n\", key, value);\n}\n\n#define HEX_LINE_CHARS 72\n#define HEX_LINE_BITS (HEX_LINE_CHARS * 4)\n\nstatic void altera_export_bool_array(char *key, u8 *data, s32 count)\n{\n\tchar string[HEX_LINE_CHARS + 1];\n\ts32 i, offset;\n\tu32 size, line, lines, linebits, value, j, k;\n\n\tif (count > HEX_LINE_BITS) {\n\t\tdprintk(\"Export: key = \\\"%s\\\", %d bits, value = HEX\\n\",\n\t\t\t\t\t\t\tkey, count);\n\t\tlines = (count + (HEX_LINE_BITS - 1)) / HEX_LINE_BITS;\n\n\t\tfor (line = 0; line < lines; ++line) {\n\t\t\tif (line < (lines - 1)) {\n\t\t\t\tlinebits = HEX_LINE_BITS;\n\t\t\t\tsize = HEX_LINE_CHARS;\n\t\t\t\toffset = count - ((line + 1) * HEX_LINE_BITS);\n\t\t\t} else {\n\t\t\t\tlinebits =\n\t\t\t\t\tcount - ((lines - 1) * HEX_LINE_BITS);\n\t\t\t\tsize = (linebits + 3) / 4;\n\t\t\t\toffset = 0L;\n\t\t\t}\n\n\t\t\tstring[size] = '\\0';\n\t\t\tj = size - 1;\n\t\t\tvalue = 0;\n\n\t\t\tfor (k = 0; k < linebits; ++k) {\n\t\t\t\ti = k + offset;\n\t\t\t\tif (data[i >> 3] & (1 << (i & 7)))\n\t\t\t\t\tvalue |= (1 << (i & 3));\n\t\t\t\tif ((i & 3) == 3) {\n\t\t\t\t\tsprintf(&string[j], \"%1x\", value);\n\t\t\t\t\tvalue = 0;\n\t\t\t\t\t--j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((k & 3) > 0)\n\t\t\t\tsprintf(&string[j], \"%1x\", value);\n\n\t\t\tdprintk(\"%s\\n\", string);\n\t\t}\n\n\t} else {\n\t\tsize = (count + 3) / 4;\n\t\tstring[size] = '\\0';\n\t\tj = size - 1;\n\t\tvalue = 0;\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tif (data[i >> 3] & (1 << (i & 7)))\n\t\t\t\tvalue |= (1 << (i & 3));\n\t\t\tif ((i & 3) == 3) {\n\t\t\t\tsprintf(&string[j], \"%1x\", value);\n\t\t\t\tvalue = 0;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\tif ((i & 3) > 0)\n\t\t\tsprintf(&string[j], \"%1x\", value);\n\n\t\tdprintk(\"Export: key = \\\"%s\\\", %d bits, value = HEX %s\\n\",\n\t\t\tkey, count, string);\n\t}\n}\n\nstatic int altera_execute(struct altera_state *astate,\n\t\t\t\tu8 *p,\n\t\t\t\ts32 program_size,\n\t\t\t\ts32 *error_address,\n\t\t\t\tint *exit_code,\n\t\t\t\tint *format_version)\n{\n\tstruct altera_config *aconf = astate->config;\n\tchar *msg_buff = astate->msg_buff;\n\tlong *stack = astate->stack;\n\tint status = 0;\n\tu32 first_word = 0L;\n\tu32 action_table = 0L;\n\tu32 proc_table = 0L;\n\tu32 str_table = 0L;\n\tu32 sym_table = 0L;\n\tu32 data_sect = 0L;\n\tu32 code_sect = 0L;\n\tu32 debug_sect = 0L;\n\tu32 action_count = 0L;\n\tu32 proc_count = 0L;\n\tu32 sym_count = 0L;\n\tlong *vars = NULL;\n\ts32 *var_size = NULL;\n\tchar *attrs = NULL;\n\tu8 *proc_attributes = NULL;\n\tu32 pc;\n\tu32 opcode_address;\n\tu32 args[3];\n\tu32 opcode;\n\tu32 name_id;\n\tu8 charbuf[4];\n\tlong long_tmp;\n\tu32 variable_id;\n\tu8 *charptr_tmp;\n\tu8 *charptr_tmp2;\n\tlong *longptr_tmp;\n\tint version = 0;\n\tint delta = 0;\n\tint stack_ptr = 0;\n\tu32 arg_count;\n\tint done = 0;\n\tint bad_opcode = 0;\n\tu32 count;\n\tu32 index;\n\tu32 index2;\n\ts32 long_count;\n\ts32 long_idx;\n\ts32 long_idx2;\n\tu32 i;\n\tu32 j;\n\tu32 uncomp_size;\n\tu32 offset;\n\tu32 value;\n\tint current_proc = 0;\n\tint reverse;\n\n\tchar *name;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tif (program_size > 52L) {\n\t\tfirst_word    = get_unaligned_be32(&p[0]);\n\t\tversion = (first_word & 1L);\n\t\t*format_version = version + 1;\n\t\tdelta = version * 8;\n\n\t\taction_table  = get_unaligned_be32(&p[4]);\n\t\tproc_table    = get_unaligned_be32(&p[8]);\n\t\tstr_table  = get_unaligned_be32(&p[4 + delta]);\n\t\tsym_table  = get_unaligned_be32(&p[16 + delta]);\n\t\tdata_sect  = get_unaligned_be32(&p[20 + delta]);\n\t\tcode_sect  = get_unaligned_be32(&p[24 + delta]);\n\t\tdebug_sect = get_unaligned_be32(&p[28 + delta]);\n\t\taction_count  = get_unaligned_be32(&p[40 + delta]);\n\t\tproc_count    = get_unaligned_be32(&p[44 + delta]);\n\t\tsym_count  = get_unaligned_be32(&p[48 + (2 * delta)]);\n\t}\n\n\tif ((first_word != 0x4A414D00L) && (first_word != 0x4A414D01L)) {\n\t\tdone = 1;\n\t\tstatus = -EIO;\n\t\tgoto exit_done;\n\t}\n\n\tif (sym_count <= 0)\n\t\tgoto exit_done;\n\n\tvars = kcalloc(sym_count, sizeof(long), GFP_KERNEL);\n\n\tif (vars == NULL)\n\t\tstatus = -ENOMEM;\n\n\tif (status == 0) {\n\t\tvar_size = kcalloc(sym_count, sizeof(s32), GFP_KERNEL);\n\n\t\tif (var_size == NULL)\n\t\t\tstatus = -ENOMEM;\n\t}\n\n\tif (status == 0) {\n\t\tattrs = kzalloc(sym_count, GFP_KERNEL);\n\n\t\tif (attrs == NULL)\n\t\t\tstatus = -ENOMEM;\n\t}\n\n\tif ((status == 0) && (version > 0)) {\n\t\tproc_attributes = kzalloc(proc_count, GFP_KERNEL);\n\n\t\tif (proc_attributes == NULL)\n\t\t\tstatus = -ENOMEM;\n\t}\n\n\tif (status != 0)\n\t\tgoto exit_done;\n\n\tdelta = version * 2;\n\n\tfor (i = 0; i < sym_count; ++i) {\n\t\toffset = (sym_table + ((11 + delta) * i));\n\n\t\tvalue = get_unaligned_be32(&p[offset + 3 + delta]);\n\n\t\tattrs[i] = p[offset];\n\n\t\t \n\t\tattrs[i] &= 0x7f;\n\n\t\tvar_size[i] = get_unaligned_be32(&p[offset + 7 + delta]);\n\n\t\t \n\n\t\tif ((attrs[i] & 0x0c) == 0x04)\n\t\t\t \n\t\t\tvars[i] = value;\n\t\telse if ((attrs[i] & 0x1e) == 0x0e) {\n\t\t\t \n\t\t\tuncomp_size = get_unaligned_le32(&p[data_sect + value]);\n\n\t\t\t \n\t\t\tvars[i] = (long)kzalloc(uncomp_size, GFP_KERNEL);\n\t\t\tif (vars[i] == 0L)\n\t\t\t\tstatus = -ENOMEM;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tattrs[i] |= 0x80;\n\n\t\t\t\t \n\t\t\t\tif (altera_shrink(&p[data_sect + value],\n\t\t\t\t\t\tvar_size[i],\n\t\t\t\t\t\t(u8 *)vars[i],\n\t\t\t\t\t\tuncomp_size,\n\t\t\t\t\t\tversion) != uncomp_size)\n\t\t\t\t\t \n\t\t\t\t\tstatus = -EIO;\n\t\t\t\telse\n\t\t\t\t\tvar_size[i] = uncomp_size * 8L;\n\n\t\t\t}\n\t\t} else if ((attrs[i] & 0x1e) == 0x0c) {\n\t\t\t \n\t\t\tvars[i] = value + data_sect + (long)p;\n\t\t} else if ((attrs[i] & 0x1c) == 0x1c) {\n\t\t\t \n\t\t\tvars[i] = value + data_sect;\n\t\t} else if ((attrs[i] & 0x0c) == 0x08) {\n\t\t\t \n\n\t\t\t \n\t\t\tattrs[i] |= 0x80;\n\n\t\t\tif (var_size[i] > 0) {\n\t\t\t\tu32 size;\n\n\t\t\t\tif (attrs[i] & 0x10)\n\t\t\t\t\t \n\t\t\t\t\tsize = (var_size[i] * sizeof(s32));\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tsize = ((var_size[i] + 7L) / 8L);\n\n\t\t\t\tvars[i] = (long)kzalloc(size, GFP_KERNEL);\n\n\t\t\t\tif (vars[i] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tfor (j = 0; j < size; ++j)\n\t\t\t\t\t\t((u8 *)(vars[i]))[j] = 0;\n\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tvars[i] = 0;\n\n\t\t} else\n\t\t\tvars[i] = 0;\n\n\t}\n\nexit_done:\n\tif (status != 0)\n\t\tdone = 1;\n\n\taltera_jinit(astate);\n\n\tpc = code_sect;\n\tmsg_buff[0] = '\\0';\n\n\t \n\tif (version > 0) {\n\t\tif (aconf->action == NULL) {\n\t\t\tstatus = -EINVAL;\n\t\t\tdone = 1;\n\t\t} else {\n\t\t\tint action_found = 0;\n\t\t\tfor (i = 0; (i < action_count) && !action_found; ++i) {\n\t\t\t\tname_id = get_unaligned_be32(&p[action_table +\n\t\t\t\t\t\t\t\t(12 * i)]);\n\n\t\t\t\tname = &p[str_table + name_id];\n\n\t\t\t\tif (strncasecmp(aconf->action, name, strlen(name)) == 0) {\n\t\t\t\t\taction_found = 1;\n\t\t\t\t\tcurrent_proc =\n\t\t\t\t\t\tget_unaligned_be32(&p[action_table +\n\t\t\t\t\t\t\t\t(12 * i) + 8]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!action_found) {\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (status == 0) {\n\t\t\tint first_time = 1;\n\t\t\ti = current_proc;\n\t\t\twhile ((i != 0) || first_time) {\n\t\t\t\tfirst_time = 0;\n\t\t\t\t \n\t\t\t\tproc_attributes[i] =\n\t\t\t\t\t\t(p[proc_table +\n\t\t\t\t\t\t\t\t(13 * i) + 8] &\n\t\t\t\t\t\t\t\t\t0x03);\n\n\t\t\t\t \n\n\t\t\t\ti = get_unaligned_be32(&p[proc_table +\n\t\t\t\t\t\t\t(13 * i) + 4]);\n\t\t\t}\n\n\t\t\t \n\t\t\ti = current_proc;\n\t\t\twhile ((i != 0) &&\n\t\t\t\t((proc_attributes[i] == 1) ||\n\t\t\t\t((proc_attributes[i] & 0xc0) == 0x40))) {\n\t\t\t\ti = get_unaligned_be32(&p[proc_table +\n\t\t\t\t\t\t\t(13 * i) + 4]);\n\t\t\t}\n\n\t\t\tif ((i != 0) || ((i == 0) && (current_proc == 0) &&\n\t\t\t\t((proc_attributes[0] != 1) &&\n\t\t\t\t((proc_attributes[0] & 0xc0) != 0x40)))) {\n\t\t\t\tcurrent_proc = i;\n\t\t\t\tpc = code_sect +\n\t\t\t\t\tget_unaligned_be32(&p[proc_table +\n\t\t\t\t\t\t\t\t(13 * i) + 9]);\n\t\t\t\tif ((pc < code_sect) || (pc >= debug_sect))\n\t\t\t\t\tstatus = -ERANGE;\n\t\t\t} else\n\t\t\t\t \n\t\t\t\tdone = 1;\n\n\t\t}\n\t}\n\n\tmsg_buff[0] = '\\0';\n\n\twhile (!done) {\n\t\topcode = (p[pc] & 0xff);\n\t\topcode_address = pc;\n\t\t++pc;\n\n\t\tif (debug > 1)\n\t\t\tprintk(\"opcode: %02x\\n\", opcode);\n\n\t\targ_count = (opcode >> 6) & 3;\n\t\tfor (i = 0; i < arg_count; ++i) {\n\t\t\targs[i] = get_unaligned_be32(&p[pc]);\n\t\t\tpc += 4;\n\t\t}\n\n\t\tswitch (opcode) {\n\t\tcase OP_NOP:\n\t\t\tbreak;\n\t\tcase OP_DUP:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tstack[stack_ptr] = stack[stack_ptr - 1];\n\t\t\t\t++stack_ptr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_SWP:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tswap(stack[stack_ptr - 2], stack[stack_ptr - 1]);\n\t\t\tbreak;\n\t\tcase OP_ADD:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] += stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_SUB:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] -= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_MULT:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] *= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_DIV:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] /= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_MOD:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] %= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_SHL:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] <<= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_SHR:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] >>= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_NOT:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tstack[stack_ptr - 1] ^= (-1L);\n\n\t\t\tbreak;\n\t\tcase OP_AND:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] &= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_OR:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] |= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_XOR:\n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\t--stack_ptr;\n\t\t\t\tstack[stack_ptr - 1] ^= stack[stack_ptr];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_INV:\n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tstack[stack_ptr - 1] = stack[stack_ptr - 1] ? 0L : 1L;\n\t\t\tbreak;\n\t\tcase OP_GT:\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\t--stack_ptr;\n\t\t\tstack[stack_ptr - 1] =\n\t\t\t\t(stack[stack_ptr - 1] > stack[stack_ptr]) ?\n\t\t\t\t\t\t\t\t\t1L : 0L;\n\n\t\t\tbreak;\n\t\tcase OP_LT:\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\t--stack_ptr;\n\t\t\tstack[stack_ptr - 1] =\n\t\t\t\t(stack[stack_ptr - 1] < stack[stack_ptr]) ?\n\t\t\t\t\t\t\t\t\t1L : 0L;\n\n\t\t\tbreak;\n\t\tcase OP_RET:\n\t\t\tif ((version > 0) && (stack_ptr == 0)) {\n\t\t\t\t \n\t\t\t\ti = get_unaligned_be32(&p[proc_table +\n\t\t\t\t\t\t(13 * current_proc) + 4]);\n\t\t\t\twhile ((i != 0) &&\n\t\t\t\t\t((proc_attributes[i] == 1) ||\n\t\t\t\t\t((proc_attributes[i] & 0xc0) == 0x40)))\n\t\t\t\t\ti = get_unaligned_be32(&p[proc_table +\n\t\t\t\t\t\t\t\t(13 * i) + 4]);\n\n\t\t\t\tif (i == 0) {\n\t\t\t\t\t \n\t\t\t\t\tdone = 1;\n\t\t\t\t\t*exit_code = 0;\t \n\t\t\t\t} else {\n\t\t\t\t\tcurrent_proc = i;\n\t\t\t\t\tpc = code_sect + get_unaligned_be32(\n\t\t\t\t\t\t\t\t&p[proc_table +\n\t\t\t\t\t\t\t\t(13 * i) + 9]);\n\t\t\t\t\tif ((pc < code_sect) ||\n\t\t\t\t\t    (pc >= debug_sect))\n\t\t\t\t\t\tstatus = -ERANGE;\n\t\t\t\t}\n\n\t\t\t} else\n\t\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\t\tpc = stack[--stack_ptr] + code_sect;\n\t\t\t\t\tif ((pc <= code_sect) ||\n\t\t\t\t\t    (pc >= debug_sect))\n\t\t\t\t\t\tstatus = -ERANGE;\n\n\t\t\t\t}\n\n\t\t\tbreak;\n\t\tcase OP_CMPS:\n\t\t\t \n\t\t\tif (altera_check_stack(stack_ptr, 4, &status)) {\n\t\t\t\ts32 a = stack[--stack_ptr];\n\t\t\t\ts32 b = stack[--stack_ptr];\n\t\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\t\tcount = stack[stack_ptr - 1];\n\n\t\t\t\tif ((count < 1) || (count > 32))\n\t\t\t\t\tstatus = -ERANGE;\n\t\t\t\telse {\n\t\t\t\t\tlong_tmp &= ((-1L) >> (32 - count));\n\n\t\t\t\t\tstack[stack_ptr - 1] =\n\t\t\t\t\t((a & long_tmp) == (b & long_tmp))\n\t\t\t\t\t\t\t\t? 1L : 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_PINT:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tsprintf(&msg_buff[strlen(msg_buff)],\n\t\t\t\t\t\"%ld\", stack[--stack_ptr]);\n\t\t\tbreak;\n\t\tcase OP_PRNT:\n\t\t\t \n\t\t\tif (debug)\n\t\t\t\tprintk(msg_buff, \"\\n\");\n\n\t\t\tmsg_buff[0] = '\\0';\n\t\t\tbreak;\n\t\tcase OP_DSS:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_drscan(astate, count, charbuf, 0);\n\t\t\tbreak;\n\t\tcase OP_DSSC:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tcount = stack[stack_ptr - 1];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_swap_dr(astate, count, charbuf,\n\t\t\t\t\t\t\t0, charbuf, 0);\n\t\t\tstack[stack_ptr - 1] = get_unaligned_le32(&charbuf[0]);\n\t\t\tbreak;\n\t\tcase OP_ISS:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_irscan(astate, count, charbuf, 0);\n\t\t\tbreak;\n\t\tcase OP_ISSC:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tcount = stack[stack_ptr - 1];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_swap_ir(astate, count, charbuf,\n\t\t\t\t\t\t\t0, charbuf, 0);\n\t\t\tstack[stack_ptr - 1] = get_unaligned_le32(&charbuf[0]);\n\t\t\tbreak;\n\t\tcase OP_DPR:\n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tstatus = altera_set_dr_pre(&astate->js, count, 0, NULL);\n\t\t\tbreak;\n\t\tcase OP_DPRL:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_set_dr_pre(&astate->js, count, 0,\n\t\t\t\t\t\tcharbuf);\n\t\t\tbreak;\n\t\tcase OP_DPO:\n\t\t\t \n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tcount = stack[--stack_ptr];\n\t\t\t\tstatus = altera_set_dr_post(&astate->js, count,\n\t\t\t\t\t\t\t\t0, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_DPOL:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_set_dr_post(&astate->js, count, 0,\n\t\t\t\t\t\t\tcharbuf);\n\t\t\tbreak;\n\t\tcase OP_IPR:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tcount = stack[--stack_ptr];\n\t\t\t\tstatus = altera_set_ir_pre(&astate->js, count,\n\t\t\t\t\t\t\t\t0, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_IPRL:\n\t\t\t \n\t\t\tif (altera_check_stack(stack_ptr, 2, &status)) {\n\t\t\t\tcount = stack[--stack_ptr];\n\t\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\t\tstatus = altera_set_ir_pre(&astate->js, count,\n\t\t\t\t\t\t\t0, charbuf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_IPO:\n\t\t\t \n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tcount = stack[--stack_ptr];\n\t\t\t\tstatus = altera_set_ir_post(&astate->js, count,\n\t\t\t\t\t\t\t0, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_IPOL:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tcount = stack[--stack_ptr];\n\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\tput_unaligned_le32(long_tmp, &charbuf[0]);\n\t\t\tstatus = altera_set_ir_post(&astate->js, count, 0,\n\t\t\t\t\t\t\tcharbuf);\n\t\t\tbreak;\n\t\tcase OP_PCHR:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tu8 ch;\n\t\t\t\tcount = strlen(msg_buff);\n\t\t\t\tch = (char) stack[--stack_ptr];\n\t\t\t\tif ((ch < 1) || (ch > 127)) {\n\t\t\t\t\t \n\t\t\t\t\tch = 127;\n\t\t\t\t}\n\t\t\t\tmsg_buff[count] = ch;\n\t\t\t\tmsg_buff[count + 1] = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_EXIT:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\t*exit_code = stack[--stack_ptr];\n\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\tcase OP_EQU:\n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\t--stack_ptr;\n\t\t\tstack[stack_ptr - 1] =\n\t\t\t\t(stack[stack_ptr - 1] == stack[stack_ptr]) ?\n\t\t\t\t\t\t\t\t\t1L : 0L;\n\t\t\tbreak;\n\t\tcase OP_POPT:\n\t\t\tif (altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\t--stack_ptr;\n\n\t\t\tbreak;\n\t\tcase OP_ABS:\n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tif (stack[stack_ptr - 1] < 0)\n\t\t\t\tstack[stack_ptr - 1] = 0 - stack[stack_ptr - 1];\n\n\t\t\tbreak;\n\t\tcase OP_BCH0:\n\t\t\t \n\n\t\t\t \n\t\t\tif (altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tswap(stack[stack_ptr - 2], stack[stack_ptr - 1]);\n\n\t\t\t \n\t\t\tindex = 7 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status))\n\t\t\t\tswap(stack[stack_ptr - index], stack[stack_ptr - 1]);\n\n\t\t\t \n\t\t\tif (altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tswap(stack[stack_ptr - 2], stack[stack_ptr - 1]);\n\n\t\t\t \n\t\t\tindex = 6 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status))\n\t\t\t\tswap(stack[stack_ptr - index], stack[stack_ptr - 1]);\n\n\t\t\t \n\t\t\tindex = 8 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tstack[stack_ptr] = stack[stack_ptr - index];\n\t\t\t\t++stack_ptr;\n\t\t\t}\n\n\t\t\t \n\t\t\tindex = 2 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status))\n\t\t\t\tswap(stack[stack_ptr - index], stack[stack_ptr - 1]);\n\n\t\t\t \n\t\t\tif (altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tswap(stack[stack_ptr - 2], stack[stack_ptr - 1]);\n\n\t\t\t \n\t\t\tindex = 6 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tstack[stack_ptr] = stack[stack_ptr - index];\n\t\t\t\t++stack_ptr;\n\t\t\t}\n\n\t\t\t \n\t\t\tindex = 6 + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tstack[stack_ptr] = stack[stack_ptr - index];\n\t\t\t\t++stack_ptr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_PSH0:\n\t\t\tstack[stack_ptr++] = 0;\n\t\t\tbreak;\n\t\tcase OP_PSHL:\n\t\t\tstack[stack_ptr++] = (s32) args[0];\n\t\t\tbreak;\n\t\tcase OP_PSHV:\n\t\t\tstack[stack_ptr++] = vars[args[0]];\n\t\t\tbreak;\n\t\tcase OP_JMP:\n\t\t\tpc = args[0] + code_sect;\n\t\t\tif ((pc < code_sect) || (pc >= debug_sect))\n\t\t\t\tstatus = -ERANGE;\n\t\t\tbreak;\n\t\tcase OP_CALL:\n\t\t\tstack[stack_ptr++] = pc;\n\t\t\tpc = args[0] + code_sect;\n\t\t\tif ((pc < code_sect) || (pc >= debug_sect))\n\t\t\t\tstatus = -ERANGE;\n\t\t\tbreak;\n\t\tcase OP_NEXT:\n\t\t\t \n\t\t\tif (altera_check_stack(stack_ptr, 3, &status)) {\n\t\t\t\ts32 step = stack[stack_ptr - 1];\n\t\t\t\ts32 end = stack[stack_ptr - 2];\n\t\t\t\ts32 top = stack[stack_ptr - 3];\n\t\t\t\ts32 iterator = vars[args[0]];\n\t\t\t\tint break_out = 0;\n\n\t\t\t\tif (step < 0) {\n\t\t\t\t\tif (iterator <= end)\n\t\t\t\t\t\tbreak_out = 1;\n\t\t\t\t} else if (iterator >= end)\n\t\t\t\t\tbreak_out = 1;\n\n\t\t\t\tif (break_out) {\n\t\t\t\t\tstack_ptr -= 3;\n\t\t\t\t} else {\n\t\t\t\t\tvars[args[0]] = iterator + step;\n\t\t\t\t\tpc = top + code_sect;\n\t\t\t\t\tif ((pc < code_sect) ||\n\t\t\t\t\t    (pc >= debug_sect))\n\t\t\t\t\t\tstatus = -ERANGE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_PSTR:\n\t\t\t \n\t\t\tcount = strlen(msg_buff);\n\t\t\tstrscpy(&msg_buff[count],\n\t\t\t\t&p[str_table + args[0]],\n\t\t\t\tALTERA_MESSAGE_LENGTH - count);\n\t\t\tbreak;\n\t\tcase OP_SINT:\n\t\t\t \n\t\t\tstatus = altera_goto_jstate(astate, args[0]);\n\t\t\tbreak;\n\t\tcase OP_ST:\n\t\t\t \n\t\t\tstatus = altera_goto_jstate(astate, args[0]);\n\t\t\tbreak;\n\t\tcase OP_ISTP:\n\t\t\t \n\t\t\tstatus = altera_set_irstop(&astate->js, args[0]);\n\t\t\tbreak;\n\t\tcase OP_DSTP:\n\t\t\t \n\t\t\tstatus = altera_set_drstop(&astate->js, args[0]);\n\t\t\tbreak;\n\n\t\tcase OP_SWPN:\n\t\t\t \n\t\t\tindex = (args[0]) + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status))\n\t\t\t\tswap(stack[stack_ptr - index], stack[stack_ptr - 1]);\n\t\t\tbreak;\n\t\tcase OP_DUPN:\n\t\t\t \n\t\t\tindex = (args[0]) + 1;\n\t\t\tif (altera_check_stack(stack_ptr, index, &status)) {\n\t\t\t\tstack[stack_ptr] = stack[stack_ptr - index];\n\t\t\t\t++stack_ptr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_POPV:\n\t\t\t \n\t\t\tif (altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tvars[args[0]] = stack[--stack_ptr];\n\n\t\t\tbreak;\n\t\tcase OP_POPE:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tvariable_id = args[0];\n\n\t\t\t \n\t\t\tif ((version > 0) &&\n\t\t\t\t((attrs[variable_id] & 0x9c) == 0x1c)) {\n\t\t\t\t \n\t\t\t\tcount = var_size[variable_id];\n\t\t\t\tlong_tmp = vars[variable_id];\n\t\t\t\tlongptr_tmp = kcalloc(count, sizeof(long),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tvars[variable_id] = (long)longptr_tmp;\n\n\t\t\t\tif (vars[variable_id] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t\tlongptr_tmp[i] =\n\t\t\t\t\t\tget_unaligned_be32(&p[long_tmp]);\n\t\t\t\t\tlong_tmp += sizeof(long);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tattrs[variable_id] |= 0x80;\n\n\t\t\t\t \n\t\t\t\tattrs[variable_id] &= ~0x04;\n\t\t\t\tattrs[variable_id] |= 0x01;\n\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((attrs[variable_id] & 0x1c) != 0x18)\n\t\t\t\tstatus = -ERANGE;\n\t\t\telse {\n\t\t\t\tlongptr_tmp = (long *)vars[variable_id];\n\n\t\t\t\t \n\t\t\t\tindex = stack[--stack_ptr];\n\n\t\t\t\t \n\t\t\t\tlongptr_tmp[index] = stack[--stack_ptr];\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase OP_POPA:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 3, &status))\n\t\t\t\tbreak;\n\t\t\tvariable_id = args[0];\n\n\t\t\t \n\t\t\tif ((version > 0) &&\n\t\t\t\t((attrs[variable_id] & 0x9c) == 0x0c)) {\n\t\t\t\t \n\t\t\t\tlong_tmp =\n\t\t\t\t\t(var_size[variable_id] + 7L) >> 3L;\n\t\t\t\tcharptr_tmp2 = (u8 *)vars[variable_id];\n\t\t\t\tcharptr_tmp =\n\t\t\t\t\tkzalloc(long_tmp, GFP_KERNEL);\n\t\t\t\tvars[variable_id] = (long)charptr_tmp;\n\n\t\t\t\tif (vars[variable_id] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tfor (long_idx = 0L;\n\t\t\t\t\tlong_idx < long_tmp;\n\t\t\t\t\t++long_idx) {\n\t\t\t\t\tcharptr_tmp[long_idx] = 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tfor (long_idx = 0L;\n\t\t\t\t\tlong_idx < var_size[variable_id];\n\t\t\t\t\t++long_idx) {\n\t\t\t\t\tlong_idx2 = long_idx;\n\n\t\t\t\t\tif (charptr_tmp2[long_idx2 >> 3] &\n\t\t\t\t\t\t(1 << (long_idx2 & 7))) {\n\t\t\t\t\t\tcharptr_tmp[long_idx >> 3] |=\n\t\t\t\t\t\t\t(1 << (long_idx & 7));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tattrs[variable_id] |= 0x80;\n\n\t\t\t\t \n\t\t\t\tattrs[variable_id] &= ~0x04;\n\t\t\t\tattrs[variable_id] |= 0x01;\n\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((attrs[variable_id] & 0x1c) != 0x08) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcharptr_tmp = (u8 *)vars[variable_id];\n\n\t\t\t \n\t\t\tlong_count = stack[--stack_ptr];\n\n\t\t\t \n\t\t\tlong_idx = stack[--stack_ptr];\n\n\t\t\treverse = 0;\n\n\t\t\tif (version > 0) {\n\t\t\t\t \n\n\t\t\t\tif (long_idx > long_count) {\n\t\t\t\t\treverse = 1;\n\t\t\t\t\tlong_tmp = long_count;\n\t\t\t\t\tlong_count = 1 + long_idx -\n\t\t\t\t\t\t\t\tlong_count;\n\t\t\t\t\tlong_idx = long_tmp;\n\n\t\t\t\t\t \n\t\t\t\t\tstatus = -ERANGE;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tlong_count = 1 + long_count -\n\t\t\t\t\t\t\t\tlong_idx;\n\n\t\t\t}\n\n\t\t\t \n\t\t\tlong_tmp = stack[--stack_ptr];\n\n\t\t\tif (long_count < 1) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < long_count; ++i) {\n\t\t\t\tif (long_tmp & (1L << (s32) i))\n\t\t\t\t\tcharptr_tmp[long_idx >> 3L] |=\n\t\t\t\t\t\t(1L << (long_idx & 7L));\n\t\t\t\telse\n\t\t\t\t\tcharptr_tmp[long_idx >> 3L] &=\n\t\t\t\t\t\t~(1L << (long_idx & 7L));\n\n\t\t\t\t++long_idx;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase OP_JMPZ:\n\t\t\t \n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tif (stack[--stack_ptr] == 0) {\n\t\t\t\t\tpc = args[0] + code_sect;\n\t\t\t\t\tif ((pc < code_sect) ||\n\t\t\t\t\t    (pc >= debug_sect))\n\t\t\t\t\t\tstatus = -ERANGE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_DS:\n\t\tcase OP_IS:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_idx = stack[--stack_ptr];\n\t\t\tlong_count = stack[--stack_ptr];\n\t\t\treverse = 0;\n\t\t\tif (version > 0) {\n\t\t\t\t \n\t\t\t\tlong_tmp = long_count;\n\t\t\t\tlong_count = stack[--stack_ptr];\n\n\t\t\t\tif (long_idx > long_tmp) {\n\t\t\t\t\treverse = 1;\n\t\t\t\t\tlong_idx = long_tmp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\n\t\t\tif (reverse) {\n\t\t\t\t \n\t\t\t\tcharptr_tmp2 = charptr_tmp;\n\t\t\t\tcharptr_tmp = kzalloc((long_count >> 3) + 1,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (charptr_tmp == NULL) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlong_tmp = long_idx + long_count - 1;\n\t\t\t\tlong_idx2 = 0;\n\t\t\t\twhile (long_idx2 < long_count) {\n\t\t\t\t\tif (charptr_tmp2[long_tmp >> 3] &\n\t\t\t\t\t\t\t(1 << (long_tmp & 7)))\n\t\t\t\t\t\tcharptr_tmp[long_idx2 >> 3] |=\n\t\t\t\t\t\t\t(1 << (long_idx2 & 7));\n\t\t\t\t\telse\n\t\t\t\t\t\tcharptr_tmp[long_idx2 >> 3] &=\n\t\t\t\t\t\t\t~(1 << (long_idx2 & 7));\n\n\t\t\t\t\t--long_tmp;\n\t\t\t\t\t++long_idx2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (opcode == 0x51)  \n\t\t\t\tstatus = altera_drscan(astate, long_count,\n\t\t\t\t\t\tcharptr_tmp, long_idx);\n\t\t\telse  \n\t\t\t\tstatus = altera_irscan(astate, long_count,\n\t\t\t\t\t\tcharptr_tmp, long_idx);\n\n\t\t\tif (reverse)\n\t\t\t\tkfree(charptr_tmp);\n\n\t\t\tbreak;\n\t\tcase OP_DPRA:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tindex = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\n\t\t\tif (version > 0)\n\t\t\t\t \n\t\t\t\tcount = 1 + count - index;\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\t\t\tstatus = altera_set_dr_pre(&astate->js, count, index,\n\t\t\t\t\t\t\tcharptr_tmp);\n\t\t\tbreak;\n\t\tcase OP_DPOA:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tindex = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\n\t\t\tif (version > 0)\n\t\t\t\t \n\t\t\t\tcount = 1 + count - index;\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\t\t\tstatus = altera_set_dr_post(&astate->js, count, index,\n\t\t\t\t\t\t\tcharptr_tmp);\n\t\t\tbreak;\n\t\tcase OP_IPRA:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tindex = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\n\t\t\tif (version > 0)\n\t\t\t\t \n\t\t\t\tcount = 1 + count - index;\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\t\t\tstatus = altera_set_ir_pre(&astate->js, count, index,\n\t\t\t\t\t\t\tcharptr_tmp);\n\n\t\t\tbreak;\n\t\tcase OP_IPOA:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tindex = stack[--stack_ptr];\n\t\t\tcount = stack[--stack_ptr];\n\n\t\t\tif (version > 0)\n\t\t\t\t \n\t\t\t\tcount = 1 + count - index;\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\t\t\tstatus = altera_set_ir_post(&astate->js, count, index,\n\t\t\t\t\t\t\tcharptr_tmp);\n\n\t\t\tbreak;\n\t\tcase OP_EXPT:\n\t\t\t \n\t\t\tif (altera_check_stack(stack_ptr, 1, &status)) {\n\t\t\t\tname = &p[str_table + args[0]];\n\t\t\t\tlong_tmp = stack[--stack_ptr];\n\t\t\t\taltera_export_int(name, long_tmp);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_PSHE:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tvariable_id = args[0];\n\t\t\tindex = stack[stack_ptr - 1];\n\n\t\t\t \n\t\t\tif ((attrs[variable_id] & 0x1f) == 0x19) {\n\t\t\t\t \n\t\t\t\tlongptr_tmp = (long *)vars[variable_id];\n\t\t\t\tstack[stack_ptr - 1] = longptr_tmp[index];\n\t\t\t} else if ((attrs[variable_id] & 0x1f) == 0x1c) {\n\t\t\t\t \n\t\t\t\tlong_tmp = vars[variable_id] +\n\t\t\t\t\t\t(index * sizeof(long));\n\t\t\t\tstack[stack_ptr - 1] =\n\t\t\t\t\tget_unaligned_be32(&p[long_tmp]);\n\t\t\t} else\n\t\t\t\tstatus = -ERANGE;\n\n\t\t\tbreak;\n\t\tcase OP_PSHA:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tvariable_id = args[0];\n\n\t\t\t \n\t\t\tif ((attrs[variable_id] & 0x18) != 0x08) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcharptr_tmp = (u8 *)vars[variable_id];\n\n\t\t\t \n\t\t\tcount = stack[--stack_ptr];\n\n\t\t\t \n\t\t\tindex = stack[stack_ptr - 1];\n\n\t\t\tif (version > 0)\n\t\t\t\t \n\t\t\t\tcount = 1 + count - index;\n\n\t\t\tif ((count < 1) || (count > 32)) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlong_tmp = 0L;\n\n\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\tif (charptr_tmp[(i + index) >> 3] &\n\t\t\t\t\t\t(1 << ((i + index) & 7)))\n\t\t\t\t\tlong_tmp |= (1L << i);\n\n\t\t\tstack[stack_ptr - 1] = long_tmp;\n\n\t\t\tbreak;\n\t\tcase OP_DYNA:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 1, &status))\n\t\t\t\tbreak;\n\t\t\tvariable_id = args[0];\n\t\t\tlong_tmp = stack[--stack_ptr];\n\n\t\t\tif (long_tmp > var_size[variable_id]) {\n\t\t\t\tvar_size[variable_id] = long_tmp;\n\n\t\t\t\tif (attrs[variable_id] & 0x10)\n\t\t\t\t\t \n\t\t\t\t\tlong_tmp *= sizeof(long);\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tlong_tmp = (long_tmp + 7) >> 3;\n\n\t\t\t\t \n\t\t\t\tif (attrs[variable_id] & 0x80) {\n\t\t\t\t\tkfree((void *)vars[variable_id]);\n\t\t\t\t\tvars[variable_id] = 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tvars[variable_id] = (long)\n\t\t\t\t\tkzalloc(long_tmp, GFP_KERNEL);\n\n\t\t\t\tif (vars[variable_id] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tattrs[variable_id] |= 0x80;\n\n\t\t\t\t \n\t\t\t\tcount = ((var_size[variable_id] + 7L) /\n\t\t\t\t\t\t\t\t\t8L);\n\t\t\t\tcharptr_tmp = (u8 *)(vars[variable_id]);\n\t\t\t\tfor (index = 0; index < count; ++index)\n\t\t\t\t\tcharptr_tmp[index] = 0;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase OP_EXPV:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 3, &status))\n\t\t\t\tbreak;\n\t\t\tif (version == 0) {\n\t\t\t\t \n\t\t\t\tbad_opcode = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tname = &p[str_table + args[0]];\n\t\t\tvariable_id = stack[--stack_ptr];\n\t\t\tlong_idx = stack[--stack_ptr]; \n\t\t\tlong_idx2 = stack[--stack_ptr]; \n\n\t\t\tif (long_idx > long_idx2) {\n\t\t\t\t \n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlong_count = 1 + long_idx2 - long_idx;\n\n\t\t\tcharptr_tmp = (u8 *)vars[variable_id];\n\t\t\tcharptr_tmp2 = NULL;\n\n\t\t\tif ((long_idx & 7L) != 0) {\n\t\t\t\ts32 k = long_idx;\n\t\t\t\tcharptr_tmp2 =\n\t\t\t\t\tkzalloc(((long_count + 7L) / 8L),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (charptr_tmp2 == NULL) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < long_count; ++i) {\n\t\t\t\t\tif (charptr_tmp[k >> 3] &\n\t\t\t\t\t\t\t(1 << (k & 7)))\n\t\t\t\t\t\tcharptr_tmp2[i >> 3] |=\n\t\t\t\t\t\t\t\t(1 << (i & 7));\n\t\t\t\t\telse\n\t\t\t\t\t\tcharptr_tmp2[i >> 3] &=\n\t\t\t\t\t\t\t\t~(1 << (i & 7));\n\n\t\t\t\t\t++k;\n\t\t\t\t}\n\t\t\t\tcharptr_tmp = charptr_tmp2;\n\n\t\t\t} else if (long_idx != 0)\n\t\t\t\tcharptr_tmp = &charptr_tmp[long_idx >> 3];\n\n\t\t\taltera_export_bool_array(name, charptr_tmp,\n\t\t\t\t\t\t\tlong_count);\n\n\t\t\t \n\t\t\tif ((long_idx & 7L) != 0)\n\t\t\t\tkfree(charptr_tmp2);\n\n\t\t\tbreak;\n\t\tcase OP_COPY: {\n\t\t\t \n\t\t\ts32 copy_count;\n\t\t\ts32 copy_index;\n\t\t\ts32 copy_index2;\n\t\t\ts32 destleft;\n\t\t\ts32 src_count;\n\t\t\ts32 dest_count;\n\t\t\tint src_reverse = 0;\n\t\t\tint dest_reverse = 0;\n\n\t\t\tif (!altera_check_stack(stack_ptr, 3, &status))\n\t\t\t\tbreak;\n\n\t\t\tcopy_count = stack[--stack_ptr];\n\t\t\tcopy_index = stack[--stack_ptr];\n\t\t\tcopy_index2 = stack[--stack_ptr];\n\t\t\treverse = 0;\n\n\t\t\tif (version > 0) {\n\t\t\t\t \n\t\t\t\tdestleft = stack[--stack_ptr];\n\n\t\t\t\tif (copy_count > copy_index) {\n\t\t\t\t\tsrc_reverse = 1;\n\t\t\t\t\treverse = 1;\n\t\t\t\t\tsrc_count = 1 + copy_count - copy_index;\n\t\t\t\t\t \n\t\t\t\t} else {\n\t\t\t\t\tsrc_count = 1 + copy_index - copy_count;\n\t\t\t\t\t \n\t\t\t\t\tcopy_index = copy_count;\n\t\t\t\t}\n\n\t\t\t\tif (copy_index2 > destleft) {\n\t\t\t\t\tdest_reverse = 1;\n\t\t\t\t\treverse = !reverse;\n\t\t\t\t\tdest_count = 1 + copy_index2 - destleft;\n\t\t\t\t\t \n\t\t\t\t\tcopy_index2 = destleft;\n\t\t\t\t} else\n\t\t\t\t\tdest_count = 1 + destleft - copy_index2;\n\n\t\t\t\tcopy_count = (src_count < dest_count) ?\n\t\t\t\t\t\t\tsrc_count : dest_count;\n\n\t\t\t\tif ((src_reverse || dest_reverse) &&\n\t\t\t\t\t(src_count != dest_count))\n\t\t\t\t\t \n\t\t\t\t\tstatus = -ERANGE;\n\n\t\t\t}\n\n\t\t\tcount = copy_count;\n\t\t\tindex = copy_index;\n\t\t\tindex2 = copy_index2;\n\n\t\t\t \n\t\t\tvariable_id = args[1];\n\t\t\tif ((version > 0) &&\n\t\t\t\t((attrs[variable_id] & 0x9c) == 0x0c)) {\n\t\t\t\t \n\t\t\t\tlong_tmp =\n\t\t\t\t\t(var_size[variable_id] + 7L) >> 3L;\n\t\t\t\tcharptr_tmp2 = (u8 *)vars[variable_id];\n\t\t\t\tcharptr_tmp =\n\t\t\t\t\tkzalloc(long_tmp, GFP_KERNEL);\n\t\t\t\tvars[variable_id] = (long)charptr_tmp;\n\n\t\t\t\tif (vars[variable_id] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tfor (long_idx = 0L; long_idx < long_tmp;\n\t\t\t\t\t\t\t\t++long_idx)\n\t\t\t\t\tcharptr_tmp[long_idx] = 0;\n\n\t\t\t\t \n\t\t\t\tfor (long_idx = 0L;\n\t\t\t\t\tlong_idx < var_size[variable_id];\n\t\t\t\t\t\t\t\t++long_idx) {\n\t\t\t\t\tlong_idx2 = long_idx;\n\n\t\t\t\t\tif (charptr_tmp2[long_idx2 >> 3] &\n\t\t\t\t\t\t(1 << (long_idx2 & 7)))\n\t\t\t\t\t\tcharptr_tmp[long_idx >> 3] |=\n\t\t\t\t\t\t\t(1 << (long_idx & 7));\n\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tattrs[variable_id] |= 0x80;\n\n\t\t\t\t \n\t\t\t\tattrs[variable_id] &= ~0x04;\n\t\t\t\tattrs[variable_id] |= 0x01;\n\t\t\t}\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[1]];\n\t\t\tcharptr_tmp2 = (u8 *)vars[args[0]];\n\n\t\t\t \n\t\t\tif ((attrs[args[1]] & 0x1c) != 0x08) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (count < 1) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (reverse)\n\t\t\t\tindex2 += (count - 1);\n\n\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\tif (charptr_tmp2[index >> 3] &\n\t\t\t\t\t\t\t(1 << (index & 7)))\n\t\t\t\t\tcharptr_tmp[index2 >> 3] |=\n\t\t\t\t\t\t\t(1 << (index2 & 7));\n\t\t\t\telse\n\t\t\t\t\tcharptr_tmp[index2 >> 3] &=\n\t\t\t\t\t\t~(1 << (index2 & 7));\n\n\t\t\t\t++index;\n\t\t\t\tif (reverse)\n\t\t\t\t\t--index2;\n\t\t\t\telse\n\t\t\t\t\t++index2;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_DSC:\n\t\tcase OP_ISC: {\n\t\t\t \n\t\t\ts32 scan_right, scan_left;\n\t\t\ts32 capture_count = 0;\n\t\t\ts32 scan_count = 0;\n\t\t\ts32 capture_index;\n\t\t\ts32 scan_index;\n\n\t\t\tif (!altera_check_stack(stack_ptr, 3, &status))\n\t\t\t\tbreak;\n\n\t\t\tcapture_index = stack[--stack_ptr];\n\t\t\tscan_index = stack[--stack_ptr];\n\n\t\t\tif (version > 0) {\n\t\t\t\t \n\t\t\t\tscan_right = stack[--stack_ptr];\n\t\t\t\tscan_left = stack[--stack_ptr];\n\t\t\t\tcapture_count = 1 + scan_index - capture_index;\n\t\t\t\tscan_count = 1 + scan_left - scan_right;\n\t\t\t\tscan_index = scan_right;\n\t\t\t}\n\n\t\t\tlong_count = stack[--stack_ptr];\n\t\t\t \n\t\t\tvariable_id = args[1];\n\t\t\tif ((version > 0) &&\n\t\t\t\t((attrs[variable_id] & 0x9c) == 0x0c)) {\n\t\t\t\t \n\t\t\t\tlong_tmp =\n\t\t\t\t\t(var_size[variable_id] + 7L) >> 3L;\n\t\t\t\tcharptr_tmp2 = (u8 *)vars[variable_id];\n\t\t\t\tcharptr_tmp =\n\t\t\t\t\tkzalloc(long_tmp, GFP_KERNEL);\n\t\t\t\tvars[variable_id] = (long)charptr_tmp;\n\n\t\t\t\tif (vars[variable_id] == 0) {\n\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tfor (long_idx = 0L; long_idx < long_tmp;\n\t\t\t\t\t\t\t\t++long_idx)\n\t\t\t\t\tcharptr_tmp[long_idx] = 0;\n\n\t\t\t\t \n\t\t\t\tfor (long_idx = 0L;\n\t\t\t\t\tlong_idx < var_size[variable_id];\n\t\t\t\t\t\t\t\t++long_idx) {\n\t\t\t\t\tlong_idx2 = long_idx;\n\n\t\t\t\t\tif (charptr_tmp2[long_idx2 >> 3] &\n\t\t\t\t\t\t(1 << (long_idx2 & 7)))\n\t\t\t\t\t\tcharptr_tmp[long_idx >> 3] |=\n\t\t\t\t\t\t\t(1 << (long_idx & 7));\n\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tattrs[variable_id] |= 0x80;\n\n\t\t\t\t \n\t\t\t\tattrs[variable_id] &= ~0x04;\n\t\t\t\tattrs[variable_id] |= 0x01;\n\n\t\t\t}\n\n\t\t\tcharptr_tmp = (u8 *)vars[args[0]];\n\t\t\tcharptr_tmp2 = (u8 *)vars[args[1]];\n\n\t\t\tif ((version > 0) &&\n\t\t\t\t\t((long_count > capture_count) ||\n\t\t\t\t\t(long_count > scan_count))) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((attrs[args[1]] & 0x1c) != 0x08) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (status == 0) {\n\t\t\t\tif (opcode == 0x82)  \n\t\t\t\t\tstatus = altera_swap_dr(astate,\n\t\t\t\t\t\t\tlong_count,\n\t\t\t\t\t\t\tcharptr_tmp,\n\t\t\t\t\t\t\tscan_index,\n\t\t\t\t\t\t\tcharptr_tmp2,\n\t\t\t\t\t\t\tcapture_index);\n\t\t\t\telse  \n\t\t\t\t\tstatus = altera_swap_ir(astate,\n\t\t\t\t\t\t\tlong_count,\n\t\t\t\t\t\t\tcharptr_tmp,\n\t\t\t\t\t\t\tscan_index,\n\t\t\t\t\t\t\tcharptr_tmp2,\n\t\t\t\t\t\t\tcapture_index);\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_WAIT:\n\t\t\t \n\t\t\tif (!altera_check_stack(stack_ptr, 2, &status))\n\t\t\t\tbreak;\n\t\t\tlong_tmp = stack[--stack_ptr];\n\n\t\t\tif (long_tmp != 0L)\n\t\t\t\tstatus = altera_wait_cycles(astate, long_tmp,\n\t\t\t\t\t\t\t\targs[0]);\n\n\t\t\tlong_tmp = stack[--stack_ptr];\n\n\t\t\tif ((status == 0) && (long_tmp != 0L))\n\t\t\t\tstatus = altera_wait_msecs(astate,\n\t\t\t\t\t\t\t\tlong_tmp,\n\t\t\t\t\t\t\t\targs[0]);\n\n\t\t\tif ((status == 0) && (args[1] != args[0]))\n\t\t\t\tstatus = altera_goto_jstate(astate,\n\t\t\t\t\t\t\t\targs[1]);\n\n\t\t\tif (version > 0) {\n\t\t\t\t--stack_ptr;  \n\t\t\t\t--stack_ptr;  \n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_CMPA: {\n\t\t\t \n\t\t\ts32 a, b;\n\t\t\tu8 *source1 = (u8 *)vars[args[0]];\n\t\t\tu8 *source2 = (u8 *)vars[args[1]];\n\t\t\tu8 *mask = (u8 *)vars[args[2]];\n\t\t\tu32 index1;\n\t\t\tu32 index2;\n\t\t\tu32 mask_index;\n\n\t\t\tif (!altera_check_stack(stack_ptr, 4, &status))\n\t\t\t\tbreak;\n\n\t\t\tindex1 = stack[--stack_ptr];\n\t\t\tindex2 = stack[--stack_ptr];\n\t\t\tmask_index = stack[--stack_ptr];\n\t\t\tlong_count = stack[--stack_ptr];\n\n\t\t\tif (version > 0) {\n\t\t\t\t \n\t\t\t\ts32 mask_right = stack[--stack_ptr];\n\t\t\t\ts32 mask_left = stack[--stack_ptr];\n\t\t\t\t \n\t\t\t\ta = 1 + index2 - index1;\n\t\t\t\t \n\t\t\t\tb = 1 + long_count - mask_index;\n\t\t\t\ta = (a < b) ? a : b;\n\t\t\t\t \n\t\t\t\tb = 1 + mask_left - mask_right;\n\t\t\t\ta = (a < b) ? a : b;\n\t\t\t\t \n\t\t\t\tindex2 = mask_index;\n\t\t\t\t \n\t\t\t\tmask_index = mask_right;\n\t\t\t\tlong_count = a;\n\t\t\t}\n\n\t\t\tlong_tmp = 1L;\n\n\t\t\tif (long_count < 1)\n\t\t\t\tstatus = -ERANGE;\n\t\t\telse {\n\t\t\t\tcount = long_count;\n\n\t\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t\tif (mask[mask_index >> 3] &\n\t\t\t\t\t\t(1 << (mask_index & 7))) {\n\t\t\t\t\t\ta = source1[index1 >> 3] &\n\t\t\t\t\t\t\t(1 << (index1 & 7))\n\t\t\t\t\t\t\t\t? 1 : 0;\n\t\t\t\t\t\tb = source2[index2 >> 3] &\n\t\t\t\t\t\t\t(1 << (index2 & 7))\n\t\t\t\t\t\t\t\t? 1 : 0;\n\n\t\t\t\t\t\tif (a != b)  \n\t\t\t\t\t\t\tlong_tmp = 0L;\n\t\t\t\t\t}\n\t\t\t\t\t++index1;\n\t\t\t\t\t++index2;\n\t\t\t\t\t++mask_index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstack[stack_ptr++] = long_tmp;\n\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t \n\t\t\tbad_opcode = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (bad_opcode)\n\t\t\tstatus = -ENOSYS;\n\n\t\tif ((stack_ptr < 0) || (stack_ptr >= ALTERA_STACK_SIZE))\n\t\t\tstatus = -EOVERFLOW;\n\n\t\tif (status != 0) {\n\t\t\tdone = 1;\n\t\t\t*error_address = (s32)(opcode_address - code_sect);\n\t\t}\n\t}\n\n\taltera_free_buffers(astate);\n\n\t \n\tif ((attrs != NULL) && (vars != NULL))\n\t\tfor (i = 0; i < sym_count; ++i)\n\t\t\tif (attrs[i] & 0x80)\n\t\t\t\tkfree((void *)vars[i]);\n\n\tkfree(vars);\n\tkfree(var_size);\n\tkfree(attrs);\n\tkfree(proc_attributes);\n\n\treturn status;\n}\n\nstatic int altera_get_note(u8 *p, s32 program_size, s32 *offset,\n\t\t\t   char *key, char *value, int keylen, int vallen)\n \n{\n\tint status = -ENODATA;\n\tu32 note_strings = 0L;\n\tu32 note_table = 0L;\n\tu32 note_count = 0L;\n\tu32 first_word = 0L;\n\tint version = 0;\n\tint delta = 0;\n\tchar *key_ptr;\n\tchar *value_ptr;\n\tint i;\n\n\t \n\tif (program_size > 52L) {\n\t\tfirst_word    = get_unaligned_be32(&p[0]);\n\t\tversion = (first_word & 1L);\n\t\tdelta = version * 8;\n\n\t\tnote_strings  = get_unaligned_be32(&p[8 + delta]);\n\t\tnote_table    = get_unaligned_be32(&p[12 + delta]);\n\t\tnote_count    = get_unaligned_be32(&p[44 + (2 * delta)]);\n\t}\n\n\tif ((first_word != 0x4A414D00L) && (first_word != 0x4A414D01L))\n\t\treturn -EIO;\n\n\tif (note_count <= 0L)\n\t\treturn status;\n\n\tif (offset == NULL) {\n\t\t \n\t\tfor (i = 0; (i < note_count) &&\n\t\t\t\t\t\t(status != 0); ++i) {\n\t\t\tkey_ptr = &p[note_strings +\n\t\t\t\t\tget_unaligned_be32(\n\t\t\t\t\t&p[note_table + (8 * i)])];\n\t\t\tif (key && !strncasecmp(key, key_ptr, strlen(key_ptr))) {\n\t\t\t\tstatus = 0;\n\n\t\t\t\tvalue_ptr = &p[note_strings +\n\t\t\t\t\t\tget_unaligned_be32(\n\t\t\t\t\t\t&p[note_table + (8 * i) + 4])];\n\n\t\t\t\tif (value != NULL)\n\t\t\t\t\tstrscpy(value, value_ptr, vallen);\n\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\n\t\ti = *offset;\n\n\t\tif ((i >= 0) && (i < note_count)) {\n\t\t\tstatus = 0;\n\n\t\t\tif (key != NULL)\n\t\t\t\tstrscpy(key, &p[note_strings +\n\t\t\t\t\t\tget_unaligned_be32(\n\t\t\t\t\t\t&p[note_table + (8 * i)])],\n\t\t\t\t\tkeylen);\n\n\t\t\tif (value != NULL)\n\t\t\t\tstrscpy(value, &p[note_strings +\n\t\t\t\t\t\tget_unaligned_be32(\n\t\t\t\t\t\t&p[note_table + (8 * i) + 4])],\n\t\t\t\t\tvallen);\n\n\t\t\t*offset = i + 1;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic int altera_check_crc(u8 *p, s32 program_size)\n{\n\tint status = 0;\n\tu16 local_expected = 0,\n\t    local_actual = 0,\n\t    shift_reg = 0xffff;\n\tint bit, feedback;\n\tu8 databyte;\n\tu32 i;\n\tu32 crc_section = 0L;\n\tu32 first_word = 0L;\n\tint version = 0;\n\tint delta = 0;\n\n\tif (program_size > 52L) {\n\t\tfirst_word  = get_unaligned_be32(&p[0]);\n\t\tversion = (first_word & 1L);\n\t\tdelta = version * 8;\n\n\t\tcrc_section = get_unaligned_be32(&p[32 + delta]);\n\t}\n\n\tif ((first_word != 0x4A414D00L) && (first_word != 0x4A414D01L))\n\t\tstatus = -EIO;\n\n\tif (crc_section >= program_size)\n\t\tstatus = -EIO;\n\n\tif (status == 0) {\n\t\tlocal_expected = (u16)get_unaligned_be16(&p[crc_section]);\n\n\t\tfor (i = 0; i < crc_section; ++i) {\n\t\t\tdatabyte = p[i];\n\t\t\tfor (bit = 0; bit < 8; bit++) {\n\t\t\t\tfeedback = (databyte ^ shift_reg) & 0x01;\n\t\t\t\tshift_reg >>= 1;\n\t\t\t\tif (feedback)\n\t\t\t\t\tshift_reg ^= 0x8408;\n\n\t\t\t\tdatabyte >>= 1;\n\t\t\t}\n\t\t}\n\n\t\tlocal_actual = (u16)~shift_reg;\n\n\t\tif (local_expected != local_actual)\n\t\t\tstatus = -EILSEQ;\n\n\t}\n\n\tif (debug || status) {\n\t\tswitch (status) {\n\t\tcase 0:\n\t\t\tprintk(KERN_INFO \"%s: CRC matched: %04x\\n\", __func__,\n\t\t\t\tlocal_actual);\n\t\t\tbreak;\n\t\tcase -EILSEQ:\n\t\t\tprintk(KERN_ERR \"%s: CRC mismatch: expected %04x, \"\n\t\t\t\t\"actual %04x\\n\", __func__, local_expected,\n\t\t\t\tlocal_actual);\n\t\t\tbreak;\n\t\tcase -EIO:\n\t\t\tprintk(KERN_ERR \"%s: error: format isn't \"\n\t\t\t\t\"recognized.\\n\", __func__);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: CRC function returned error \"\n\t\t\t\t\"code %d\\n\", __func__, status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic int altera_get_file_info(u8 *p,\n\t\t\t\t\ts32 program_size,\n\t\t\t\t\tint *format_version,\n\t\t\t\t\tint *action_count,\n\t\t\t\t\tint *procedure_count)\n{\n\tint status = -EIO;\n\tu32 first_word = 0;\n\tint version = 0;\n\n\tif (program_size <= 52L)\n\t\treturn status;\n\n\tfirst_word = get_unaligned_be32(&p[0]);\n\n\tif ((first_word == 0x4A414D00L) || (first_word == 0x4A414D01L)) {\n\t\tstatus = 0;\n\n\t\tversion = (first_word & 1L);\n\t\t*format_version = version + 1;\n\n\t\tif (version > 0) {\n\t\t\t*action_count = get_unaligned_be32(&p[48]);\n\t\t\t*procedure_count = get_unaligned_be32(&p[52]);\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic int altera_get_act_info(u8 *p,\n\t\t\t\t\ts32 program_size,\n\t\t\t\t\tint index,\n\t\t\t\t\tchar **name,\n\t\t\t\t\tchar **description,\n\t\t\t\t\tstruct altera_procinfo **proc_list)\n{\n\tint status = -EIO;\n\tstruct altera_procinfo *procptr = NULL;\n\tstruct altera_procinfo *tmpptr = NULL;\n\tu32 first_word = 0L;\n\tu32 action_table = 0L;\n\tu32 proc_table = 0L;\n\tu32 str_table = 0L;\n\tu32 note_strings = 0L;\n\tu32 action_count = 0L;\n\tu32 proc_count = 0L;\n\tu32 act_name_id = 0L;\n\tu32 act_desc_id = 0L;\n\tu32 act_proc_id = 0L;\n\tu32 act_proc_name = 0L;\n\tu8 act_proc_attribute = 0;\n\n\tif (program_size <= 52L)\n\t\treturn status;\n\t \n\tfirst_word = get_unaligned_be32(&p[0]);\n\n\tif (first_word != 0x4A414D01L)\n\t\treturn status;\n\n\taction_table = get_unaligned_be32(&p[4]);\n\tproc_table   = get_unaligned_be32(&p[8]);\n\tstr_table = get_unaligned_be32(&p[12]);\n\tnote_strings = get_unaligned_be32(&p[16]);\n\taction_count = get_unaligned_be32(&p[48]);\n\tproc_count   = get_unaligned_be32(&p[52]);\n\n\tif (index >= action_count)\n\t\treturn status;\n\n\tact_name_id = get_unaligned_be32(&p[action_table + (12 * index)]);\n\tact_desc_id = get_unaligned_be32(&p[action_table + (12 * index) + 4]);\n\tact_proc_id = get_unaligned_be32(&p[action_table + (12 * index) + 8]);\n\n\t*name = &p[str_table + act_name_id];\n\n\tif (act_desc_id < (note_strings - str_table))\n\t\t*description = &p[str_table + act_desc_id];\n\n\tdo {\n\t\tact_proc_name = get_unaligned_be32(\n\t\t\t\t\t&p[proc_table + (13 * act_proc_id)]);\n\t\tact_proc_attribute =\n\t\t\t(p[proc_table + (13 * act_proc_id) + 8] & 0x03);\n\n\t\tprocptr =\n\t\t\t\tkzalloc(sizeof(struct altera_procinfo),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (procptr == NULL)\n\t\t\tstatus = -ENOMEM;\n\t\telse {\n\t\t\tprocptr->name = &p[str_table + act_proc_name];\n\t\t\tprocptr->attrs = act_proc_attribute;\n\t\t\tprocptr->next = NULL;\n\n\t\t\t \n\t\t\tif (*proc_list == NULL)\n\t\t\t\t*proc_list = procptr;\n\t\t\telse {\n\t\t\t\ttmpptr = *proc_list;\n\t\t\t\twhile (tmpptr->next != NULL)\n\t\t\t\t\ttmpptr = tmpptr->next;\n\t\t\t\ttmpptr->next = procptr;\n\t\t\t}\n\t\t}\n\n\t\tact_proc_id = get_unaligned_be32(\n\t\t\t\t&p[proc_table + (13 * act_proc_id) + 4]);\n\t} while ((act_proc_id != 0) && (act_proc_id < proc_count));\n\n\treturn status;\n}\n\nint altera_init(struct altera_config *config, const struct firmware *fw)\n{\n\tstruct altera_state *astate = NULL;\n\tstruct altera_procinfo *proc_list = NULL;\n\tstruct altera_procinfo *procptr = NULL;\n\tchar *key = NULL;\n\tchar *value = NULL;\n\tchar *action_name = NULL;\n\tchar *description = NULL;\n\tint exec_result = 0;\n\tint exit_code = 0;\n\tint format_version = 0;\n\tint action_count = 0;\n\tint procedure_count = 0;\n\tint index = 0;\n\ts32 offset = 0L;\n\ts32 error_address = 0L;\n\tint retval = 0;\n\n\tkey = kzalloc(33, GFP_KERNEL);\n\tif (!key) {\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\tvalue = kzalloc(257, GFP_KERNEL);\n\tif (!value) {\n\t\tretval = -ENOMEM;\n\t\tgoto free_key;\n\t}\n\tastate = kzalloc(sizeof(struct altera_state), GFP_KERNEL);\n\tif (!astate) {\n\t\tretval = -ENOMEM;\n\t\tgoto free_value;\n\t}\n\n\tastate->config = config;\n\tif (!astate->config->jtag_io) {\n\t\tif (!IS_ENABLED(CONFIG_HAS_IOPORT)) {\n\t\t\tretval = -ENODEV;\n\t\t\tgoto free_state;\n\t\t}\n\t\tdprintk(\"%s: using byteblaster!\\n\", __func__);\n\t\tastate->config->jtag_io = netup_jtag_io_lpt;\n\t}\n\n\taltera_check_crc((u8 *)fw->data, fw->size);\n\n\tif (debug) {\n\t\taltera_get_file_info((u8 *)fw->data, fw->size, &format_version,\n\t\t\t\t\t&action_count, &procedure_count);\n\t\tprintk(KERN_INFO \"%s: File format is %s ByteCode format\\n\",\n\t\t\t__func__, (format_version == 2) ? \"Jam STAPL\" :\n\t\t\t\t\t\t\"pre-standardized Jam 1.1\");\n\t\twhile (altera_get_note((u8 *)fw->data, fw->size,\n\t\t\t\t\t&offset, key, value, 32, 256) == 0)\n\t\t\tprintk(KERN_INFO \"%s: NOTE \\\"%s\\\" = \\\"%s\\\"\\n\",\n\t\t\t\t\t__func__, key, value);\n\t}\n\n\tif (debug && (format_version == 2) && (action_count > 0)) {\n\t\tprintk(KERN_INFO \"%s: Actions available:\\n\", __func__);\n\t\tfor (index = 0; index < action_count; ++index) {\n\t\t\taltera_get_act_info((u8 *)fw->data, fw->size,\n\t\t\t\t\t\tindex, &action_name,\n\t\t\t\t\t\t&description,\n\t\t\t\t\t\t&proc_list);\n\n\t\t\tif (description == NULL)\n\t\t\t\tprintk(KERN_INFO \"%s: %s\\n\",\n\t\t\t\t\t\t__func__,\n\t\t\t\t\t\taction_name);\n\t\t\telse\n\t\t\t\tprintk(KERN_INFO \"%s: %s \\\"%s\\\"\\n\",\n\t\t\t\t\t\t__func__,\n\t\t\t\t\t\taction_name,\n\t\t\t\t\t\tdescription);\n\n\t\t\tprocptr = proc_list;\n\t\t\twhile (procptr != NULL) {\n\t\t\t\tif (procptr->attrs != 0)\n\t\t\t\t\tprintk(KERN_INFO \"%s:    %s (%s)\\n\",\n\t\t\t\t\t\t__func__,\n\t\t\t\t\t\tprocptr->name,\n\t\t\t\t\t\t(procptr->attrs == 1) ?\n\t\t\t\t\t\t\"optional\" : \"recommended\");\n\n\t\t\t\tproc_list = procptr->next;\n\t\t\t\tkfree(procptr);\n\t\t\t\tprocptr = proc_list;\n\t\t\t}\n\t\t}\n\n\t\tprintk(KERN_INFO \"\\n\");\n\t}\n\n\texec_result = altera_execute(astate, (u8 *)fw->data, fw->size,\n\t\t\t\t&error_address, &exit_code, &format_version);\n\n\tif (exit_code)\n\t\texec_result = -EREMOTEIO;\n\n\tif ((format_version == 2) && (exec_result == -EINVAL)) {\n\t\tif (astate->config->action == NULL)\n\t\t\tprintk(KERN_ERR \"%s: error: no action specified for \"\n\t\t\t\t\"Jam STAPL file.\\nprogram terminated.\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\tprintk(KERN_ERR \"%s: error: action \\\"%s\\\"\"\n\t\t\t\t\" is not supported \"\n\t\t\t\t\"for this Jam STAPL file.\\n\"\n\t\t\t\t\"Program terminated.\\n\", __func__,\n\t\t\t\tastate->config->action);\n\n\t} else if (exec_result)\n\t\tprintk(KERN_ERR \"%s: error %d\\n\", __func__, exec_result);\nfree_state:\n\tkfree(astate);\nfree_value:\n\tkfree(value);\nfree_key:\n\tkfree(key);\nout:\n\treturn retval;\n}\nEXPORT_SYMBOL(altera_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}