{
  "module_name": "st_core.c",
  "hash_id": "629962efc47b3300582b3da842265c18098b20b1a75422aa546b32744f42ef99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ti-st/st_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"(stc): \" fmt\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/tty.h>\n\n#include <linux/seq_file.h>\n#include <linux/skbuff.h>\n\n#include <linux/ti_wilink_st.h>\n#include <linux/netdevice.h>\n\n \nstatic void (*st_recv)(void *disc_data, const u8 *ptr, size_t count);\n\n \nstatic void add_channel_to_table(struct st_data_s *st_gdata,\n\t\tstruct st_proto_s *new_proto)\n{\n\tpr_info(\"%s: id %d\\n\", __func__, new_proto->chnl_id);\n\t \n\tst_gdata->list[new_proto->chnl_id] = new_proto;\n\tst_gdata->is_registered[new_proto->chnl_id] = true;\n}\n\nstatic void remove_channel_from_table(struct st_data_s *st_gdata,\n\t\tstruct st_proto_s *proto)\n{\n\tpr_info(\"%s: id %d\\n\", __func__, proto->chnl_id);\n \n\tst_gdata->is_registered[proto->chnl_id] = false;\n}\n\n \nint st_get_uart_wr_room(struct st_data_s *st_gdata)\n{\n\tif (unlikely(st_gdata == NULL || st_gdata->tty == NULL)) {\n\t\tpr_err(\"tty unavailable to perform write\");\n\t\treturn -1;\n\t}\n\n\treturn tty_write_room(st_gdata->tty);\n}\n\n \nint st_int_write(struct st_data_s *st_gdata,\n\tconst unsigned char *data, int count)\n{\n\tstruct tty_struct *tty;\n\tif (unlikely(st_gdata == NULL || st_gdata->tty == NULL)) {\n\t\tpr_err(\"tty unavailable to perform write\");\n\t\treturn -EINVAL;\n\t}\n\ttty = st_gdata->tty;\n#ifdef VERBOSE\n\tprint_hex_dump(KERN_DEBUG, \"<out<\", DUMP_PREFIX_NONE,\n\t\t16, 1, data, count, 0);\n#endif\n\treturn tty->ops->write(tty, data, count);\n\n}\n\n \nstatic void st_send_frame(unsigned char chnl_id, struct st_data_s *st_gdata)\n{\n\tpr_debug(\" %s(prot:%d) \", __func__, chnl_id);\n\n\tif (unlikely\n\t    (st_gdata == NULL || st_gdata->rx_skb == NULL\n\t     || st_gdata->is_registered[chnl_id] == false)) {\n\t\tpr_err(\"chnl_id %d not registered, no data to send?\",\n\t\t\t   chnl_id);\n\t\tkfree_skb(st_gdata->rx_skb);\n\t\treturn;\n\t}\n\t \n\tif (likely(st_gdata->list[chnl_id]->recv != NULL)) {\n\t\tif (unlikely\n\t\t\t(st_gdata->list[chnl_id]->recv\n\t\t\t(st_gdata->list[chnl_id]->priv_data, st_gdata->rx_skb)\n\t\t\t     != 0)) {\n\t\t\tpr_err(\" proto stack %d's ->recv failed\", chnl_id);\n\t\t\tkfree_skb(st_gdata->rx_skb);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tpr_err(\" proto stack %d's ->recv null\", chnl_id);\n\t\tkfree_skb(st_gdata->rx_skb);\n\t}\n\treturn;\n}\n\n \nstatic void st_reg_complete(struct st_data_s *st_gdata, int err)\n{\n\tunsigned char i = 0;\n\tpr_info(\" %s \", __func__);\n\tfor (i = 0; i < ST_MAX_CHANNELS; i++) {\n\t\tif (likely(st_gdata != NULL &&\n\t\t\tst_gdata->is_registered[i] == true &&\n\t\t\t\tst_gdata->list[i]->reg_complete_cb != NULL)) {\n\t\t\tst_gdata->list[i]->reg_complete_cb\n\t\t\t\t(st_gdata->list[i]->priv_data, err);\n\t\t\tpr_info(\"protocol %d's cb sent %d\\n\", i, err);\n\t\t\tif (err) {  \n\t\t\t\tst_gdata->is_registered[i] = false;\n\t\t\t\tif (st_gdata->protos_registered)\n\t\t\t\t\tst_gdata->protos_registered--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline int st_check_data_len(struct st_data_s *st_gdata,\n\tunsigned char chnl_id, int len)\n{\n\tint room = skb_tailroom(st_gdata->rx_skb);\n\n\tpr_debug(\"len %d room %d\", len, room);\n\n\tif (!len) {\n\t\t \n\t\tst_send_frame(chnl_id, st_gdata);\n\n\t} else if (len > room) {\n\t\t \n\t\tpr_err(\"Data length is too large len %d room %d\", len,\n\t\t\t   room);\n\t\tkfree_skb(st_gdata->rx_skb);\n\t} else {\n\t\t \n\t\tst_gdata->rx_state = ST_W4_DATA;\n\t\tst_gdata->rx_count = len;\n\t\treturn len;\n\t}\n\n\t \n\tst_gdata->rx_state = ST_W4_PACKET_TYPE;\n\tst_gdata->rx_skb = NULL;\n\tst_gdata->rx_count = 0;\n\tst_gdata->rx_chnl = 0;\n\n\treturn 0;\n}\n\n \nstatic inline void st_wakeup_ack(struct st_data_s *st_gdata,\n\tunsigned char cmd)\n{\n\tstruct sk_buff *waiting_skb;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&st_gdata->lock, flags);\n\t \n\twhile ((waiting_skb = skb_dequeue(&st_gdata->tx_waitq)))\n\t\tskb_queue_tail(&st_gdata->txq, waiting_skb);\n\n\t \n\tst_ll_sleep_state(st_gdata, (unsigned long)cmd);\n\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\n\t \n\tst_tx_wakeup(st_gdata);\n}\n\n \nstatic void st_int_recv(void *disc_data, const u8 *ptr, size_t count)\n{\n\tstruct st_proto_s *proto;\n\tunsigned short payload_len = 0;\n\tint len = 0;\n\tunsigned char type = 0;\n\tunsigned char *plen;\n\tstruct st_data_s *st_gdata = (struct st_data_s *)disc_data;\n\tunsigned long flags;\n\n\tif (st_gdata == NULL) {\n\t\tpr_err(\" received null from TTY \");\n\t\treturn;\n\t}\n\n\tpr_debug(\"count %zu rx_state %ld\"\n\t\t   \"rx_count %ld\", count, st_gdata->rx_state,\n\t\t   st_gdata->rx_count);\n\n\tspin_lock_irqsave(&st_gdata->lock, flags);\n\t \n\twhile (count) {\n\t\tif (st_gdata->rx_count) {\n\t\t\tlen = min_t(unsigned int, st_gdata->rx_count, count);\n\t\t\tskb_put_data(st_gdata->rx_skb, ptr, len);\n\t\t\tst_gdata->rx_count -= len;\n\t\t\tcount -= len;\n\t\t\tptr += len;\n\n\t\t\tif (st_gdata->rx_count)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tswitch (st_gdata->rx_state) {\n\t\t\t \n\t\t\tcase ST_W4_DATA:\n\t\t\t\tpr_debug(\"Complete pkt received\");\n\t\t\t\t \n\t\t\t\tst_send_frame(st_gdata->rx_chnl, st_gdata);\n\n\t\t\t\tst_gdata->rx_state = ST_W4_PACKET_TYPE;\n\t\t\t\tst_gdata->rx_skb = NULL;\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tcase ST_W4_HEADER:\n\t\t\t\tproto = st_gdata->list[st_gdata->rx_chnl];\n\t\t\t\tplen =\n\t\t\t\t&st_gdata->rx_skb->data\n\t\t\t\t[proto->offset_len_in_hdr];\n\t\t\t\tpr_debug(\"plen pointing to %x\\n\", *plen);\n\t\t\t\tif (proto->len_size == 1)  \n\t\t\t\t\tpayload_len = *(unsigned char *)plen;\n\t\t\t\telse if (proto->len_size == 2)\n\t\t\t\t\tpayload_len =\n\t\t\t\t\t__le16_to_cpu(*(unsigned short *)plen);\n\t\t\t\telse\n\t\t\t\t\tpr_info(\"%s: invalid length \"\n\t\t\t\t\t\"for id %d\\n\",\n\t\t\t\t\t__func__, proto->chnl_id);\n\t\t\t\tst_check_data_len(st_gdata, proto->chnl_id,\n\t\t\t\t\t\tpayload_len);\n\t\t\t\tpr_debug(\"off %d, pay len %d\\n\",\n\t\t\t\t\tproto->offset_len_in_hdr, payload_len);\n\t\t\t\tcontinue;\n\t\t\t}\t \n\t\t}\n\n\t\t \n\n\t\t \n\t\tswitch (*ptr) {\n\t\tcase LL_SLEEP_IND:\n\t\tcase LL_SLEEP_ACK:\n\t\tcase LL_WAKE_UP_IND:\n\t\t\tpr_debug(\"PM packet\");\n\t\t\t \n\t\t\tst_ll_sleep_state(st_gdata, *ptr);\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\t\t\tif (st_ll_getstate(st_gdata) == ST_LL_AWAKE)\n\t\t\t\tst_wakeup_ack(st_gdata, LL_WAKE_UP_ACK);\n\t\t\tspin_lock_irqsave(&st_gdata->lock, flags);\n\n\t\t\tptr++;\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\tcase LL_WAKE_UP_ACK:\n\t\t\tpr_debug(\"PM packet\");\n\n\t\t\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\t\t\t \n\t\t\tst_wakeup_ack(st_gdata, *ptr);\n\t\t\tspin_lock_irqsave(&st_gdata->lock, flags);\n\n\t\t\tptr++;\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t\t \n\t\tdefault:\n\t\t\ttype = *ptr;\n\n\t\t\t \n\n\t\t\tif ((type >= ST_MAX_CHANNELS) ||\n\t\t\t\t\t(st_gdata->list[type] == NULL)) {\n\t\t\t\tpr_err(\"chip/interface misbehavior: \"\n\t\t\t\t\t\t\"dropping frame starting \"\n\t\t\t\t\t\t\"with 0x%02x\\n\", type);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tst_gdata->rx_skb = alloc_skb(\n\t\t\t\t\tst_gdata->list[type]->max_frame_size,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (st_gdata->rx_skb == NULL) {\n\t\t\t\tpr_err(\"out of memory: dropping\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tskb_reserve(st_gdata->rx_skb,\n\t\t\t\t\tst_gdata->list[type]->reserve);\n\t\t\t \n\t\t\tst_gdata->rx_skb->cb[0] = type;  \n\t\t\tst_gdata->rx_skb->cb[1] = 0;  \n\t\t\tst_gdata->rx_chnl = *ptr;\n\t\t\tst_gdata->rx_state = ST_W4_HEADER;\n\t\t\tst_gdata->rx_count = st_gdata->list[type]->hdr_len;\n\t\t\tpr_debug(\"rx_count %ld\\n\", st_gdata->rx_count);\n\t\t}\n\t\tptr++;\n\t\tcount--;\n\t}\ndone:\n\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\tpr_debug(\"done %s\", __func__);\n\treturn;\n}\n\n \nstatic struct sk_buff *st_int_dequeue(struct st_data_s *st_gdata)\n{\n\tstruct sk_buff *returning_skb;\n\n\tpr_debug(\"%s\", __func__);\n\tif (st_gdata->tx_skb != NULL) {\n\t\treturning_skb = st_gdata->tx_skb;\n\t\tst_gdata->tx_skb = NULL;\n\t\treturn returning_skb;\n\t}\n\treturn skb_dequeue(&st_gdata->txq);\n}\n\n \nstatic void st_int_enqueue(struct st_data_s *st_gdata, struct sk_buff *skb)\n{\n\tunsigned long flags = 0;\n\n\tpr_debug(\"%s\", __func__);\n\tspin_lock_irqsave(&st_gdata->lock, flags);\n\n\tswitch (st_ll_getstate(st_gdata)) {\n\tcase ST_LL_AWAKE:\n\t\tpr_debug(\"ST LL is AWAKE, sending normally\");\n\t\tskb_queue_tail(&st_gdata->txq, skb);\n\t\tbreak;\n\tcase ST_LL_ASLEEP_TO_AWAKE:\n\t\tskb_queue_tail(&st_gdata->tx_waitq, skb);\n\t\tbreak;\n\tcase ST_LL_AWAKE_TO_ASLEEP:\n\t\tpr_err(\"ST LL is illegal state(%ld),\"\n\t\t\t   \"purging received skb.\", st_ll_getstate(st_gdata));\n\t\tdev_kfree_skb_irq(skb);\n\t\tbreak;\n\tcase ST_LL_ASLEEP:\n\t\tskb_queue_tail(&st_gdata->tx_waitq, skb);\n\t\tst_ll_wakeup(st_gdata);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"ST LL is illegal state(%ld),\"\n\t\t\t   \"purging received skb.\", st_ll_getstate(st_gdata));\n\t\tdev_kfree_skb_irq(skb);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\tpr_debug(\"done %s\", __func__);\n\treturn;\n}\n\n \nstatic void work_fn_write_wakeup(struct work_struct *work)\n{\n\tstruct st_data_s *st_gdata = container_of(work, struct st_data_s,\n\t\t\twork_write_wakeup);\n\n\tst_tx_wakeup((void *)st_gdata);\n}\nvoid st_tx_wakeup(struct st_data_s *st_data)\n{\n\tstruct sk_buff *skb;\n\tunsigned long flags;\t \n\tpr_debug(\"%s\", __func__);\n\t \n\tif (test_and_set_bit(ST_TX_SENDING, &st_data->tx_state)) {\n\t\tpr_debug(\"ST already sending\");\n\t\t \n\t\tset_bit(ST_TX_WAKEUP, &st_data->tx_state);\n\t\treturn;\n\t\t \n\t}\n\tdo {\t\t\t \n\t\t \n\t\tclear_bit(ST_TX_WAKEUP, &st_data->tx_state);\n\t\twhile ((skb = st_int_dequeue(st_data))) {\n\t\t\tint len;\n\t\t\tspin_lock_irqsave(&st_data->lock, flags);\n\t\t\t \n\t\t\tset_bit(TTY_DO_WRITE_WAKEUP, &st_data->tty->flags);\n\t\t\tlen = st_int_write(st_data, skb->data, skb->len);\n\t\t\tskb_pull(skb, len);\n\t\t\t \n\t\t\tif (skb->len) {\n\t\t\t\t \n\t\t\t\tst_data->tx_skb = skb;\n\t\t\t\tspin_unlock_irqrestore(&st_data->lock, flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tspin_unlock_irqrestore(&st_data->lock, flags);\n\t\t}\n\t\t \n\t} while (test_bit(ST_TX_WAKEUP, &st_data->tx_state));\n\n\t \n\tclear_bit(ST_TX_SENDING, &st_data->tx_state);\n}\n\n \n \nvoid kim_st_list_protocols(struct st_data_s *st_gdata, void *buf)\n{\n\tseq_printf(buf, \"[%d]\\nBT=%c\\nFM=%c\\nGPS=%c\\n\",\n\t\t\tst_gdata->protos_registered,\n\t\t\tst_gdata->is_registered[0x04] == true ? 'R' : 'U',\n\t\t\tst_gdata->is_registered[0x08] == true ? 'R' : 'U',\n\t\t\tst_gdata->is_registered[0x09] == true ? 'R' : 'U');\n}\n\n \n \nlong st_register(struct st_proto_s *new_proto)\n{\n\tstruct st_data_s\t*st_gdata;\n\tlong err = 0;\n\tunsigned long flags = 0;\n\n\tst_kim_ref(&st_gdata, 0);\n\tif (st_gdata == NULL || new_proto == NULL || new_proto->recv == NULL\n\t    || new_proto->reg_complete_cb == NULL) {\n\t\tpr_err(\"gdata/new_proto/recv or reg_complete_cb not ready\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_proto->chnl_id >= ST_MAX_CHANNELS) {\n\t\tpr_err(\"chnl_id %d not supported\", new_proto->chnl_id);\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tif (st_gdata->is_registered[new_proto->chnl_id] == true) {\n\t\tpr_err(\"chnl_id %d already registered\", new_proto->chnl_id);\n\t\treturn -EALREADY;\n\t}\n\n\t \n\tspin_lock_irqsave(&st_gdata->lock, flags);\n\n\tif (test_bit(ST_REG_IN_PROGRESS, &st_gdata->st_state)) {\n\t\tpr_info(\" ST_REG_IN_PROGRESS:%d \", new_proto->chnl_id);\n\t\t \n\n\t\tadd_channel_to_table(st_gdata, new_proto);\n\t\tst_gdata->protos_registered++;\n\t\tnew_proto->write = st_write;\n\n\t\tset_bit(ST_REG_PENDING, &st_gdata->st_state);\n\t\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\t\treturn -EINPROGRESS;\n\t} else if (st_gdata->protos_registered == ST_EMPTY) {\n\t\tpr_info(\" chnl_id list empty :%d \", new_proto->chnl_id);\n\t\tset_bit(ST_REG_IN_PROGRESS, &st_gdata->st_state);\n\t\tst_recv = st_kim_recv;\n\n\t\t \n\t\tst_ll_enable(st_gdata);\n\n\t\t \n\t\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\n\t\t \n\t\terr = st_kim_start(st_gdata->kim_data);\n\t\tif (err != 0) {\n\t\t\tclear_bit(ST_REG_IN_PROGRESS, &st_gdata->st_state);\n\t\t\tif ((st_gdata->protos_registered != ST_EMPTY) &&\n\t\t\t    (test_bit(ST_REG_PENDING, &st_gdata->st_state))) {\n\t\t\t\tpr_err(\" KIM failure complete callback \");\n\t\t\t\tspin_lock_irqsave(&st_gdata->lock, flags);\n\t\t\t\tst_reg_complete(st_gdata, err);\n\t\t\t\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\t\t\t\tclear_bit(ST_REG_PENDING, &st_gdata->st_state);\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tspin_lock_irqsave(&st_gdata->lock, flags);\n\n\t\tclear_bit(ST_REG_IN_PROGRESS, &st_gdata->st_state);\n\t\tst_recv = st_int_recv;\n\n\t\t \n\t\tif ((st_gdata->protos_registered != ST_EMPTY) &&\n\t\t    (test_bit(ST_REG_PENDING, &st_gdata->st_state))) {\n\t\t\tpr_debug(\" call reg complete callback \");\n\t\t\tst_reg_complete(st_gdata, 0);\n\t\t}\n\t\tclear_bit(ST_REG_PENDING, &st_gdata->st_state);\n\n\t\t \n\t\tif (st_gdata->is_registered[new_proto->chnl_id] == true) {\n\t\t\tpr_err(\" proto %d already registered \",\n\t\t\t\t   new_proto->chnl_id);\n\t\t\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\tadd_channel_to_table(st_gdata, new_proto);\n\t\tst_gdata->protos_registered++;\n\t\tnew_proto->write = st_write;\n\t\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\t\treturn err;\n\t}\n\t \n\telse {\n\t\tadd_channel_to_table(st_gdata, new_proto);\n\t\tst_gdata->protos_registered++;\n\t\tnew_proto->write = st_write;\n\n\t\t \n\t\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\t\treturn err;\n\t}\n}\nEXPORT_SYMBOL_GPL(st_register);\n\n \nlong st_unregister(struct st_proto_s *proto)\n{\n\tlong err = 0;\n\tunsigned long flags = 0;\n\tstruct st_data_s\t*st_gdata;\n\n\tpr_debug(\"%s: %d \", __func__, proto->chnl_id);\n\n\tst_kim_ref(&st_gdata, 0);\n\tif (!st_gdata || proto->chnl_id >= ST_MAX_CHANNELS) {\n\t\tpr_err(\" chnl_id %d not supported\", proto->chnl_id);\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tspin_lock_irqsave(&st_gdata->lock, flags);\n\n\tif (st_gdata->is_registered[proto->chnl_id] == false) {\n\t\tpr_err(\" chnl_id %d not registered\", proto->chnl_id);\n\t\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tif (st_gdata->protos_registered)\n\t\tst_gdata->protos_registered--;\n\n\tremove_channel_from_table(st_gdata, proto);\n\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\n\tif ((st_gdata->protos_registered == ST_EMPTY) &&\n\t    (!test_bit(ST_REG_PENDING, &st_gdata->st_state))) {\n\t\tpr_info(\" all chnl_ids unregistered \");\n\n\t\t \n\t\tif (st_gdata->tty) {\n\t\t\ttty_ldisc_flush(st_gdata->tty);\n\t\t\tstop_tty(st_gdata->tty);\n\t\t}\n\n\t\t \n\t\tst_kim_stop(st_gdata->kim_data);\n\t\t \n\t\tst_ll_disable(st_gdata);\n\t}\n\treturn err;\n}\n\n \nlong st_write(struct sk_buff *skb)\n{\n\tstruct st_data_s *st_gdata;\n\tlong len;\n\n\tst_kim_ref(&st_gdata, 0);\n\tif (unlikely(skb == NULL || st_gdata == NULL\n\t\t|| st_gdata->tty == NULL)) {\n\t\tpr_err(\"data/tty unavailable to perform write\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"%d to be written\", skb->len);\n\tlen = skb->len;\n\n\t \n\tst_int_enqueue(st_gdata, skb);\n\t \n\tst_tx_wakeup(st_gdata);\n\n\t \n\treturn len;\n}\n\n \nEXPORT_SYMBOL_GPL(st_unregister);\n\n \n \nstatic int st_tty_open(struct tty_struct *tty)\n{\n\tstruct st_data_s *st_gdata;\n\tpr_info(\"%s \", __func__);\n\n\tst_kim_ref(&st_gdata, 0);\n\tst_gdata->tty = tty;\n\ttty->disc_data = st_gdata;\n\n\t \n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\n\t \n\ttty->receive_room = 65536;\n\t \n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\t \n\tst_kim_complete(st_gdata->kim_data);\n\tpr_debug(\"done %s\", __func__);\n\n\treturn 0;\n}\n\nstatic void st_tty_close(struct tty_struct *tty)\n{\n\tunsigned char i;\n\tunsigned long flags;\n\tstruct\tst_data_s *st_gdata = tty->disc_data;\n\n\tpr_info(\"%s \", __func__);\n\n\t \n\tspin_lock_irqsave(&st_gdata->lock, flags);\n\tfor (i = ST_BT; i < ST_MAX_CHANNELS; i++) {\n\t\tif (st_gdata->is_registered[i] == true)\n\t\t\tpr_err(\"%d not un-registered\", i);\n\t\tst_gdata->list[i] = NULL;\n\t\tst_gdata->is_registered[i] = false;\n\t}\n\tst_gdata->protos_registered = 0;\n\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\t \n\tst_kim_complete(st_gdata->kim_data);\n\tst_gdata->tty = NULL;\n\t \n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\n\tspin_lock_irqsave(&st_gdata->lock, flags);\n\t \n\tskb_queue_purge(&st_gdata->txq);\n\tskb_queue_purge(&st_gdata->tx_waitq);\n\t \n\tst_gdata->rx_count = 0;\n\tst_gdata->rx_state = ST_W4_PACKET_TYPE;\n\tkfree_skb(st_gdata->rx_skb);\n\tst_gdata->rx_skb = NULL;\n\tspin_unlock_irqrestore(&st_gdata->lock, flags);\n\n\tpr_debug(\"%s: done \", __func__);\n}\n\nstatic void st_tty_receive(struct tty_struct *tty, const u8 *data,\n\t\t\t   const u8 *tty_flags, size_t count)\n{\n#ifdef VERBOSE\n\tprint_hex_dump(KERN_DEBUG, \">in>\", DUMP_PREFIX_NONE,\n\t\t16, 1, data, count, 0);\n#endif\n\n\t \n\tst_recv(tty->disc_data, data, count);\n\tpr_debug(\"done %s\", __func__);\n}\n\n \nstatic void st_tty_wakeup(struct tty_struct *tty)\n{\n\tstruct\tst_data_s *st_gdata = tty->disc_data;\n\tpr_debug(\"%s \", __func__);\n\t \n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\n\t \n\tschedule_work(&st_gdata->work_write_wakeup);\n}\n\nstatic void st_tty_flush_buffer(struct tty_struct *tty)\n{\n\tstruct\tst_data_s *st_gdata = tty->disc_data;\n\tpr_debug(\"%s \", __func__);\n\n\tkfree_skb(st_gdata->tx_skb);\n\tst_gdata->tx_skb = NULL;\n\n\ttty_driver_flush_buffer(tty);\n\treturn;\n}\n\nstatic struct tty_ldisc_ops st_ldisc_ops = {\n\t.num = N_TI_WL,\n\t.name = \"n_st\",\n\t.open = st_tty_open,\n\t.close = st_tty_close,\n\t.receive_buf = st_tty_receive,\n\t.write_wakeup = st_tty_wakeup,\n\t.flush_buffer = st_tty_flush_buffer,\n\t.owner = THIS_MODULE\n};\n\n \nint st_core_init(struct st_data_s **core_data)\n{\n\tstruct st_data_s *st_gdata;\n\tlong err;\n\n\terr = tty_register_ldisc(&st_ldisc_ops);\n\tif (err) {\n\t\tpr_err(\"error registering %d line discipline %ld\",\n\t\t\t   N_TI_WL, err);\n\t\treturn err;\n\t}\n\tpr_debug(\"registered n_shared line discipline\");\n\n\tst_gdata = kzalloc(sizeof(struct st_data_s), GFP_KERNEL);\n\tif (!st_gdata) {\n\t\tpr_err(\"memory allocation failed\");\n\t\terr = -ENOMEM;\n\t\tgoto err_unreg_ldisc;\n\t}\n\n\t \n\tskb_queue_head_init(&st_gdata->txq);\n\tskb_queue_head_init(&st_gdata->tx_waitq);\n\n\t \n\tspin_lock_init(&st_gdata->lock);\n\n\terr = st_ll_init(st_gdata);\n\tif (err) {\n\t\tpr_err(\"error during st_ll initialization(%ld)\", err);\n\t\tgoto err_free_gdata;\n\t}\n\n\tINIT_WORK(&st_gdata->work_write_wakeup, work_fn_write_wakeup);\n\n\t*core_data = st_gdata;\n\treturn 0;\nerr_free_gdata:\n\tkfree(st_gdata);\nerr_unreg_ldisc:\n\ttty_unregister_ldisc(&st_ldisc_ops);\n\treturn err;\n}\n\nvoid st_core_exit(struct st_data_s *st_gdata)\n{\n\tlong err;\n\t \n\terr = st_ll_deinit(st_gdata);\n\tif (err)\n\t\tpr_err(\"error during deinit of ST LL %ld\", err);\n\n\tif (st_gdata != NULL) {\n\t\t \n\t\tskb_queue_purge(&st_gdata->txq);\n\t\tskb_queue_purge(&st_gdata->tx_waitq);\n\t\tkfree_skb(st_gdata->rx_skb);\n\t\tkfree_skb(st_gdata->tx_skb);\n\t\t \n\t\ttty_unregister_ldisc(&st_ldisc_ops);\n\t\t \n\t\tkfree(st_gdata);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}