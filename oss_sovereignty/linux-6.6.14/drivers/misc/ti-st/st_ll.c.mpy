{
  "module_name": "st_ll.c",
  "hash_id": "e87cdfeae15f9a7895353ab089fd9b9ae5c95c275641a7a8015cb289097400c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ti-st/st_ll.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"(stll) :\" fmt\n#include <linux/skbuff.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/ti_wilink_st.h>\n\n \n \nstatic void send_ll_cmd(struct st_data_s *st_data,\n\tunsigned char cmd)\n{\n\n\tpr_debug(\"%s: writing %x\", __func__, cmd);\n\tst_int_write(st_data, &cmd, 1);\n\treturn;\n}\n\nstatic void ll_device_want_to_sleep(struct st_data_s *st_data)\n{\n\tstruct kim_data_s\t*kim_data;\n\tstruct ti_st_plat_data\t*pdata;\n\n\tpr_debug(\"%s\", __func__);\n\t \n\tif (st_data->ll_state != ST_LL_AWAKE)\n\t\tpr_err(\"ERR hcill: ST_LL_GO_TO_SLEEP_IND\"\n\t\t\t  \"in state %ld\", st_data->ll_state);\n\n\tsend_ll_cmd(st_data, LL_SLEEP_ACK);\n\t \n\tst_data->ll_state = ST_LL_ASLEEP;\n\n\t \n\tkim_data = st_data->kim_data;\n\tpdata = kim_data->kim_pdev->dev.platform_data;\n\tif (pdata->chip_asleep)\n\t\tpdata->chip_asleep(NULL);\n}\n\nstatic void ll_device_want_to_wakeup(struct st_data_s *st_data)\n{\n\tstruct kim_data_s\t*kim_data;\n\tstruct ti_st_plat_data\t*pdata;\n\n\t \n\tswitch (st_data->ll_state) {\n\tcase ST_LL_ASLEEP:\n\t\tsend_ll_cmd(st_data, LL_WAKE_UP_ACK);\t \n\t\tbreak;\n\tcase ST_LL_ASLEEP_TO_AWAKE:\n\t\t \n\t\tpr_err(\"duplicate wake_ind while waiting for Wake ack\");\n\t\tbreak;\n\tcase ST_LL_AWAKE:\n\t\t \n\t\tpr_err(\"duplicate wake_ind already AWAKE\");\n\t\tbreak;\n\tcase ST_LL_AWAKE_TO_ASLEEP:\n\t\t \n\t\tpr_err(\"duplicate wake_ind\");\n\t\tbreak;\n\t}\n\t \n\tst_data->ll_state = ST_LL_AWAKE;\n\n\t \n\tkim_data = st_data->kim_data;\n\tpdata = kim_data->kim_pdev->dev.platform_data;\n\tif (pdata->chip_awake)\n\t\tpdata->chip_awake(NULL);\n}\n\n \n \n\n \nvoid st_ll_enable(struct st_data_s *ll)\n{\n\tll->ll_state = ST_LL_AWAKE;\n}\n\n \nvoid st_ll_disable(struct st_data_s *ll)\n{\n\tll->ll_state = ST_LL_INVALID;\n}\n\n \nvoid st_ll_wakeup(struct st_data_s *ll)\n{\n\tif (likely(ll->ll_state != ST_LL_AWAKE)) {\n\t\tsend_ll_cmd(ll, LL_WAKE_UP_IND);\t \n\t\tll->ll_state = ST_LL_ASLEEP_TO_AWAKE;\n\t} else {\n\t\t \n\t\tpr_err(\" Chip already AWAKE \");\n\t}\n}\n\n \nunsigned long st_ll_getstate(struct st_data_s *ll)\n{\n\tpr_debug(\" returning state %ld\", ll->ll_state);\n\treturn ll->ll_state;\n}\n\n \nunsigned long st_ll_sleep_state(struct st_data_s *st_data,\n\tunsigned char cmd)\n{\n\tswitch (cmd) {\n\tcase LL_SLEEP_IND:\t \n\t\tpr_debug(\"sleep indication recvd\");\n\t\tll_device_want_to_sleep(st_data);\n\t\tbreak;\n\tcase LL_SLEEP_ACK:\t \n\t\tpr_err(\"sleep ack rcvd: host shouldn't\");\n\t\tbreak;\n\tcase LL_WAKE_UP_IND:\t \n\t\tpr_debug(\"wake indication recvd\");\n\t\tll_device_want_to_wakeup(st_data);\n\t\tbreak;\n\tcase LL_WAKE_UP_ACK:\t \n\t\tpr_debug(\"wake ack rcvd\");\n\t\tst_data->ll_state = ST_LL_AWAKE;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\" unknown input/state \");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nlong st_ll_init(struct st_data_s *ll)\n{\n\t \n\tll->ll_state = ST_LL_INVALID;\n\treturn 0;\n}\n\n \nlong st_ll_deinit(struct st_data_s *ll)\n{\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}