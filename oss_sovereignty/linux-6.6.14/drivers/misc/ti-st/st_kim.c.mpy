{
  "module_name": "st_kim.c",
  "hash_id": "2b4e6715dee3a84a672452c6dfe28926ba637c072a2d2dbfde773fd80b6974c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ti-st/st_kim.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"(stk) :\" fmt\n#include <linux/platform_device.h>\n#include <linux/jiffies.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <linux/wait.h>\n#include <linux/gpio.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/sysfs.h>\n#include <linux/tty.h>\n\n#include <linux/skbuff.h>\n#include <linux/ti_wilink_st.h>\n#include <linux/module.h>\n\n#define MAX_ST_DEVICES\t3\t \nstatic struct platform_device *st_kim_devices[MAX_ST_DEVICES];\n\n \n \n\n \nstatic struct platform_device *st_get_plat_device(int id)\n{\n\treturn st_kim_devices[id];\n}\n\n \nstatic void validate_firmware_response(struct kim_data_s *kim_gdata)\n{\n\tstruct sk_buff *skb = kim_gdata->rx_skb;\n\tif (!skb)\n\t\treturn;\n\n\t \n\tif (skb->data[2] == 0x01 && skb->data[3] == 0x01 &&\n\t\t\tskb->data[4] == 0x10 && skb->data[5] == 0x00) {\n\t\t \n\t\tmemcpy(kim_gdata->resp_buffer,\n\t\t\t\tkim_gdata->rx_skb->data,\n\t\t\t\tkim_gdata->rx_skb->len);\n\t\tkim_gdata->rx_state = ST_W4_PACKET_TYPE;\n\t\tkim_gdata->rx_skb = NULL;\n\t\tkim_gdata->rx_count = 0;\n\t} else if (unlikely(skb->data[5] != 0)) {\n\t\tpr_err(\"no proper response during fw download\");\n\t\tpr_err(\"data6 %x\", skb->data[5]);\n\t\tkfree_skb(skb);\n\t\treturn;\t\t \n\t}\n\t \n\tcomplete_all(&kim_gdata->kim_rcvd);\n\tkfree_skb(skb);\n}\n\n \nstatic inline int kim_check_data_len(struct kim_data_s *kim_gdata, int len)\n{\n\tregister int room = skb_tailroom(kim_gdata->rx_skb);\n\n\tpr_debug(\"len %d room %d\", len, room);\n\n\tif (!len) {\n\t\tvalidate_firmware_response(kim_gdata);\n\t} else if (len > room) {\n\t\t \n\t\tpr_err(\"Data length is too large len %d room %d\", len,\n\t\t\t   room);\n\t\tkfree_skb(kim_gdata->rx_skb);\n\t} else {\n\t\t \n\t\tkim_gdata->rx_state = ST_W4_DATA;\n\t\tkim_gdata->rx_count = len;\n\t\treturn len;\n\t}\n\n\t \n\tkim_gdata->rx_state = ST_W4_PACKET_TYPE;\n\tkim_gdata->rx_skb = NULL;\n\tkim_gdata->rx_count = 0;\n\n\treturn 0;\n}\n\n \nstatic void kim_int_recv(struct kim_data_s *kim_gdata, const u8 *ptr,\n\t\t\t size_t count)\n{\n\tint len = 0;\n\tunsigned char *plen;\n\n\tpr_debug(\"%s\", __func__);\n\t \n\twhile (count) {\n\t\tif (kim_gdata->rx_count) {\n\t\t\tlen = min_t(unsigned int, kim_gdata->rx_count, count);\n\t\t\tskb_put_data(kim_gdata->rx_skb, ptr, len);\n\t\t\tkim_gdata->rx_count -= len;\n\t\t\tcount -= len;\n\t\t\tptr += len;\n\n\t\t\tif (kim_gdata->rx_count)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tswitch (kim_gdata->rx_state) {\n\t\t\t\t \n\t\t\tcase ST_W4_DATA:\n\t\t\t\tpr_debug(\"Complete pkt received\");\n\t\t\t\tvalidate_firmware_response(kim_gdata);\n\t\t\t\tkim_gdata->rx_state = ST_W4_PACKET_TYPE;\n\t\t\t\tkim_gdata->rx_skb = NULL;\n\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\tcase ST_W4_HEADER:\n\t\t\t\tplen =\n\t\t\t\t(unsigned char *)&kim_gdata->rx_skb->data[1];\n\t\t\t\tpr_debug(\"event hdr: plen 0x%02x\\n\", *plen);\n\t\t\t\tkim_check_data_len(kim_gdata, *plen);\n\t\t\t\tcontinue;\n\t\t\t}\t \n\t\t}\t\t \n\t\tswitch (*ptr) {\n\t\t\t \n\t\tcase 0x04:\n\t\t\tkim_gdata->rx_state = ST_W4_HEADER;\n\t\t\tkim_gdata->rx_count = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"unknown packet\");\n\t\t\tptr++;\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\t\tptr++;\n\t\tcount--;\n\t\tkim_gdata->rx_skb =\n\t\t\talloc_skb(1024+8, GFP_ATOMIC);\n\t\tif (!kim_gdata->rx_skb) {\n\t\t\tpr_err(\"can't allocate mem for new packet\");\n\t\t\tkim_gdata->rx_state = ST_W4_PACKET_TYPE;\n\t\t\tkim_gdata->rx_count = 0;\n\t\t\treturn;\n\t\t}\n\t\tskb_reserve(kim_gdata->rx_skb, 8);\n\t\tkim_gdata->rx_skb->cb[0] = 4;\n\t\tkim_gdata->rx_skb->cb[1] = 0;\n\n\t}\n\treturn;\n}\n\nstatic long read_local_version(struct kim_data_s *kim_gdata, char *bts_scr_name)\n{\n\tunsigned short version = 0, chip = 0, min_ver = 0, maj_ver = 0;\n\tstatic const char read_ver_cmd[] = { 0x01, 0x01, 0x10, 0x00 };\n\tlong timeout;\n\n\tpr_debug(\"%s\", __func__);\n\n\treinit_completion(&kim_gdata->kim_rcvd);\n\tif (4 != st_int_write(kim_gdata->core_data, read_ver_cmd, 4)) {\n\t\tpr_err(\"kim: couldn't write 4 bytes\");\n\t\treturn -EIO;\n\t}\n\n\ttimeout = wait_for_completion_interruptible_timeout(\n\t\t&kim_gdata->kim_rcvd, msecs_to_jiffies(CMD_RESP_TIME));\n\tif (timeout <= 0) {\n\t\tpr_err(\" waiting for ver info- timed out or received signal\");\n\t\treturn timeout ? -ERESTARTSYS : -ETIMEDOUT;\n\t}\n\treinit_completion(&kim_gdata->kim_rcvd);\n\t \n\n\tversion =\n\t\tMAKEWORD(kim_gdata->resp_buffer[12],\n\t\t\t\tkim_gdata->resp_buffer[13]);\n\tchip = (version & 0x7C00) >> 10;\n\tmin_ver = (version & 0x007F);\n\tmaj_ver = (version & 0x0380) >> 7;\n\n\tif (version & 0x8000)\n\t\tmaj_ver |= 0x0008;\n\n\tsprintf(bts_scr_name, \"ti-connectivity/TIInit_%d.%d.%d.bts\",\n\t\tchip, maj_ver, min_ver);\n\n\t \n\tkim_gdata->version.full = version;\n\tkim_gdata->version.chip = chip;\n\tkim_gdata->version.maj_ver = maj_ver;\n\tkim_gdata->version.min_ver = min_ver;\n\n\tpr_info(\"%s\", bts_scr_name);\n\treturn 0;\n}\n\nstatic void skip_change_remote_baud(unsigned char **ptr, long *len)\n{\n\tunsigned char *nxt_action, *cur_action;\n\tcur_action = *ptr;\n\n\tnxt_action = cur_action + sizeof(struct bts_action) +\n\t\t((struct bts_action *) cur_action)->size;\n\n\tif (((struct bts_action *) nxt_action)->type != ACTION_WAIT_EVENT) {\n\t\tpr_err(\"invalid action after change remote baud command\");\n\t} else {\n\t\t*ptr = *ptr + sizeof(struct bts_action) +\n\t\t\t((struct bts_action *)cur_action)->size;\n\t\t*len = *len - (sizeof(struct bts_action) +\n\t\t\t\t((struct bts_action *)cur_action)->size);\n\t\t \n\t\tpr_warn(\"skipping the wait event of change remote baud\");\n\t}\n}\n\n \nstatic long download_firmware(struct kim_data_s *kim_gdata)\n{\n\tlong err = 0;\n\tlong len = 0;\n\tunsigned char *ptr = NULL;\n\tunsigned char *action_ptr = NULL;\n\tunsigned char bts_scr_name[40] = { 0 };\t \n\tint wr_room_space;\n\tint cmd_size;\n\tunsigned long timeout;\n\n\terr = read_local_version(kim_gdata, bts_scr_name);\n\tif (err != 0) {\n\t\tpr_err(\"kim: failed to read local ver\");\n\t\treturn err;\n\t}\n\terr =\n\t    request_firmware(&kim_gdata->fw_entry, bts_scr_name,\n\t\t\t     &kim_gdata->kim_pdev->dev);\n\tif (unlikely((err != 0) || (kim_gdata->fw_entry->data == NULL) ||\n\t\t     (kim_gdata->fw_entry->size == 0))) {\n\t\tpr_err(\" request_firmware failed(errno %ld) for %s\", err,\n\t\t\t   bts_scr_name);\n\t\treturn -EINVAL;\n\t}\n\tptr = (void *)kim_gdata->fw_entry->data;\n\tlen = kim_gdata->fw_entry->size;\n\t \n\tptr += sizeof(struct bts_header);\n\tlen -= sizeof(struct bts_header);\n\n\twhile (len > 0 && ptr) {\n\t\tpr_debug(\" action size %d, type %d \",\n\t\t\t   ((struct bts_action *)ptr)->size,\n\t\t\t   ((struct bts_action *)ptr)->type);\n\n\t\tswitch (((struct bts_action *)ptr)->type) {\n\t\tcase ACTION_SEND_COMMAND:\t \n\t\t\tpr_debug(\"S\");\n\t\t\taction_ptr = &(((struct bts_action *)ptr)->data[0]);\n\t\t\tif (unlikely\n\t\t\t    (((struct hci_command *)action_ptr)->opcode ==\n\t\t\t     0xFF36)) {\n\t\t\t\t \n\t\t\t\tpr_warn(\"change remote baud\"\n\t\t\t\t    \" rate command in firmware\");\n\t\t\t\tskip_change_remote_baud(&ptr, &len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tcmd_size = ((struct bts_action *)ptr)->size;\n\t\t\ttimeout = jiffies + msecs_to_jiffies(CMD_WR_TIME);\n\t\t\tdo {\n\t\t\t\twr_room_space =\n\t\t\t\t\tst_get_uart_wr_room(kim_gdata->core_data);\n\t\t\t\tif (wr_room_space < 0) {\n\t\t\t\t\tpr_err(\"Unable to get free \"\n\t\t\t\t\t\t\t\"space info from uart tx buffer\");\n\t\t\t\t\trelease_firmware(kim_gdata->fw_entry);\n\t\t\t\t\treturn wr_room_space;\n\t\t\t\t}\n\t\t\t\tmdelay(1);  \n\t\t\t} while ((wr_room_space < cmd_size) &&\n\t\t\t\t\ttime_before(jiffies, timeout));\n\n\t\t\t \n\t\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\t\tpr_err(\"Timeout while waiting for free \"\n\t\t\t\t\t\t\"free space in uart tx buffer\");\n\t\t\t\trelease_firmware(kim_gdata->fw_entry);\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t\t \n\t\t\treinit_completion(&kim_gdata->kim_rcvd);\n\n\t\t\t \n\t\t\terr = st_int_write(kim_gdata->core_data,\n\t\t\t((struct bts_action_send *)action_ptr)->data,\n\t\t\t\t\t   ((struct bts_action *)ptr)->size);\n\t\t\tif (unlikely(err < 0)) {\n\t\t\t\trelease_firmware(kim_gdata->fw_entry);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\t \n\t\t\tif (err != cmd_size) {\n\t\t\t\tpr_err(\"Number of bytes written to uart \"\n\t\t\t\t\t\t\"tx buffer are not matching with \"\n\t\t\t\t\t\t\"requested cmd write size\");\n\t\t\t\trelease_firmware(kim_gdata->fw_entry);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACTION_WAIT_EVENT:   \n\t\t\tpr_debug(\"W\");\n\t\t\terr = wait_for_completion_interruptible_timeout(\n\t\t\t\t\t&kim_gdata->kim_rcvd,\n\t\t\t\t\tmsecs_to_jiffies(CMD_RESP_TIME));\n\t\t\tif (err <= 0) {\n\t\t\t\tpr_err(\"response timeout/signaled during fw download \");\n\t\t\t\t \n\t\t\t\trelease_firmware(kim_gdata->fw_entry);\n\t\t\t\treturn err ? -ERESTARTSYS : -ETIMEDOUT;\n\t\t\t}\n\t\t\treinit_completion(&kim_gdata->kim_rcvd);\n\t\t\tbreak;\n\t\tcase ACTION_DELAY:\t \n\t\t\tpr_info(\"sleep command in scr\");\n\t\t\taction_ptr = &(((struct bts_action *)ptr)->data[0]);\n\t\t\tmdelay(((struct bts_action_delay *)action_ptr)->msec);\n\t\t\tbreak;\n\t\t}\n\t\tlen =\n\t\t    len - (sizeof(struct bts_action) +\n\t\t\t   ((struct bts_action *)ptr)->size);\n\t\tptr =\n\t\t    ptr + sizeof(struct bts_action) +\n\t\t    ((struct bts_action *)ptr)->size;\n\t}\n\t \n\trelease_firmware(kim_gdata->fw_entry);\n\treturn 0;\n}\n\n \n \n \nvoid st_kim_recv(void *disc_data, const u8 *data, size_t count)\n{\n\tstruct st_data_s\t*st_gdata = (struct st_data_s *)disc_data;\n\tstruct kim_data_s\t*kim_gdata = st_gdata->kim_data;\n\n\t \n\tkim_int_recv(kim_gdata, data, count);\n\treturn;\n}\n\n \nvoid st_kim_complete(void *kim_data)\n{\n\tstruct kim_data_s\t*kim_gdata = (struct kim_data_s *)kim_data;\n\tcomplete(&kim_gdata->ldisc_installed);\n}\n\n \nlong st_kim_start(void *kim_data)\n{\n\tlong err = 0;\n\tlong retry = POR_RETRY_COUNT;\n\tstruct ti_st_plat_data\t*pdata;\n\tstruct kim_data_s\t*kim_gdata = (struct kim_data_s *)kim_data;\n\n\tpr_info(\" %s\", __func__);\n\tpdata = kim_gdata->kim_pdev->dev.platform_data;\n\n\tdo {\n\t\t \n\t\tif (pdata->chip_enable)\n\t\t\tpdata->chip_enable(kim_gdata);\n\n\t\t \n\t\tgpio_set_value_cansleep(kim_gdata->nshutdown, GPIO_LOW);\n\t\tmdelay(5);\t \n\t\tgpio_set_value_cansleep(kim_gdata->nshutdown, GPIO_HIGH);\n\t\tmdelay(100);\n\t\t \n\t\treinit_completion(&kim_gdata->ldisc_installed);\n\t\t \n\t\tkim_gdata->ldisc_install = 1;\n\t\tpr_info(\"ldisc_install = 1\");\n\t\tsysfs_notify(&kim_gdata->kim_pdev->dev.kobj,\n\t\t\t\tNULL, \"install\");\n\t\t \n\t\terr = wait_for_completion_interruptible_timeout(\n\t\t\t&kim_gdata->ldisc_installed, msecs_to_jiffies(LDISC_TIME));\n\t\tif (!err) {\n\t\t\t \n\t\t\tpr_err(\"ldisc installation timeout\");\n\t\t\terr = st_kim_stop(kim_gdata);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tpr_info(\"line discipline installed\");\n\t\t\terr = download_firmware(kim_gdata);\n\t\t\tif (err != 0) {\n\t\t\t\t \n\t\t\t\tpr_err(\"download firmware failed\");\n\t\t\t\terr = st_kim_stop(kim_gdata);\n\t\t\t\tcontinue;\n\t\t\t} else {\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (retry--);\n\treturn err;\n}\n\n \nlong st_kim_stop(void *kim_data)\n{\n\tlong err = 0;\n\tstruct kim_data_s\t*kim_gdata = (struct kim_data_s *)kim_data;\n\tstruct ti_st_plat_data\t*pdata =\n\t\tkim_gdata->kim_pdev->dev.platform_data;\n\tstruct tty_struct\t*tty = kim_gdata->core_data->tty;\n\n\treinit_completion(&kim_gdata->ldisc_installed);\n\n\tif (tty) {\t \n\t\t \n\t\ttty_ldisc_flush(tty);\n\t\ttty_driver_flush_buffer(tty);\n\t}\n\n\t \n\tpr_info(\"ldisc_install = 0\");\n\tkim_gdata->ldisc_install = 0;\n\tsysfs_notify(&kim_gdata->kim_pdev->dev.kobj, NULL, \"install\");\n\n\t \n\terr = wait_for_completion_interruptible_timeout(\n\t\t&kim_gdata->ldisc_installed, msecs_to_jiffies(LDISC_TIME));\n\tif (!err) {\t\t \n\t\tpr_err(\" timed out waiting for ldisc to be un-installed\");\n\t\terr = -ETIMEDOUT;\n\t}\n\n\t \n\tgpio_set_value_cansleep(kim_gdata->nshutdown, GPIO_LOW);\n\tmdelay(1);\n\tgpio_set_value_cansleep(kim_gdata->nshutdown, GPIO_HIGH);\n\tmdelay(1);\n\tgpio_set_value_cansleep(kim_gdata->nshutdown, GPIO_LOW);\n\n\t \n\tif (pdata->chip_disable)\n\t\tpdata->chip_disable(kim_gdata);\n\treturn err;\n}\n\n \n \n \n\nstatic int version_show(struct seq_file *s, void *unused)\n{\n\tstruct kim_data_s *kim_gdata = (struct kim_data_s *)s->private;\n\tseq_printf(s, \"%04X %d.%d.%d\\n\", kim_gdata->version.full,\n\t\t\tkim_gdata->version.chip, kim_gdata->version.maj_ver,\n\t\t\tkim_gdata->version.min_ver);\n\treturn 0;\n}\n\nstatic int list_show(struct seq_file *s, void *unused)\n{\n\tstruct kim_data_s *kim_gdata = (struct kim_data_s *)s->private;\n\tkim_st_list_protocols(kim_gdata->core_data, s);\n\treturn 0;\n}\n\nstatic ssize_t show_install(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct kim_data_s *kim_data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", kim_data->ldisc_install);\n}\n\n#ifdef DEBUG\nstatic ssize_t store_dev_name(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct kim_data_s *kim_data = dev_get_drvdata(dev);\n\tpr_debug(\"storing dev name >%s<\", buf);\n\tstrncpy(kim_data->dev_name, buf, count);\n\tpr_debug(\"stored dev name >%s<\", kim_data->dev_name);\n\treturn count;\n}\n\nstatic ssize_t store_baud_rate(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct kim_data_s *kim_data = dev_get_drvdata(dev);\n\tpr_debug(\"storing baud rate >%s<\", buf);\n\tsscanf(buf, \"%ld\", &kim_data->baud_rate);\n\tpr_debug(\"stored baud rate >%ld<\", kim_data->baud_rate);\n\treturn count;\n}\n#endif\t \n\nstatic ssize_t show_dev_name(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct kim_data_s *kim_data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%s\\n\", kim_data->dev_name);\n}\n\nstatic ssize_t show_baud_rate(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct kim_data_s *kim_data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", kim_data->baud_rate);\n}\n\nstatic ssize_t show_flow_cntrl(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct kim_data_s *kim_data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", kim_data->flow_cntrl);\n}\n\n \nstatic struct kobj_attribute ldisc_install =\n__ATTR(install, 0444, (void *)show_install, NULL);\n\nstatic struct kobj_attribute uart_dev_name =\n#ifdef DEBUG\t \n__ATTR(dev_name, 0644, (void *)show_dev_name, (void *)store_dev_name);\n#else\n__ATTR(dev_name, 0444, (void *)show_dev_name, NULL);\n#endif\n\nstatic struct kobj_attribute uart_baud_rate =\n#ifdef DEBUG\t \n__ATTR(baud_rate, 0644, (void *)show_baud_rate, (void *)store_baud_rate);\n#else\n__ATTR(baud_rate, 0444, (void *)show_baud_rate, NULL);\n#endif\n\nstatic struct kobj_attribute uart_flow_cntrl =\n__ATTR(flow_cntrl, 0444, (void *)show_flow_cntrl, NULL);\n\nstatic struct attribute *uim_attrs[] = {\n\t&ldisc_install.attr,\n\t&uart_dev_name.attr,\n\t&uart_baud_rate.attr,\n\t&uart_flow_cntrl.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group uim_attr_grp = {\n\t.attrs = uim_attrs,\n};\n\n \nvoid st_kim_ref(struct st_data_s **core_data, int id)\n{\n\tstruct platform_device\t*pdev;\n\tstruct kim_data_s\t*kim_gdata;\n\t \n\tpdev = st_get_plat_device(id);\n\tif (!pdev)\n\t\tgoto err;\n\tkim_gdata = platform_get_drvdata(pdev);\n\tif (!kim_gdata)\n\t\tgoto err;\n\n\t*core_data = kim_gdata->core_data;\n\treturn;\nerr:\n\t*core_data = NULL;\n}\n\nDEFINE_SHOW_ATTRIBUTE(version);\nDEFINE_SHOW_ATTRIBUTE(list);\n\n \n \n\nstatic struct dentry *kim_debugfs_dir;\nstatic int kim_probe(struct platform_device *pdev)\n{\n\tstruct kim_data_s\t*kim_gdata;\n\tstruct ti_st_plat_data\t*pdata = pdev->dev.platform_data;\n\tint err;\n\n\tif ((pdev->id != -1) && (pdev->id < MAX_ST_DEVICES)) {\n\t\t \n\t\tst_kim_devices[pdev->id] = pdev;\n\t} else {\n\t\t \n\t\tst_kim_devices[0] = pdev;\n\t}\n\n\tkim_gdata = kzalloc(sizeof(struct kim_data_s), GFP_KERNEL);\n\tif (!kim_gdata) {\n\t\tpr_err(\"no mem to allocate\");\n\t\treturn -ENOMEM;\n\t}\n\tplatform_set_drvdata(pdev, kim_gdata);\n\n\terr = st_core_init(&kim_gdata->core_data);\n\tif (err != 0) {\n\t\tpr_err(\" ST core init failed\");\n\t\terr = -EIO;\n\t\tgoto err_core_init;\n\t}\n\t \n\tkim_gdata->core_data->kim_data = kim_gdata;\n\n\t \n\tkim_gdata->nshutdown = pdata->nshutdown_gpio;\n\terr = gpio_request(kim_gdata->nshutdown, \"kim\");\n\tif (unlikely(err)) {\n\t\tpr_err(\" gpio %d request failed \", kim_gdata->nshutdown);\n\t\tgoto err_sysfs_group;\n\t}\n\n\t \n\terr = gpio_direction_output(kim_gdata->nshutdown, 0);\n\tif (unlikely(err)) {\n\t\tpr_err(\" unable to configure gpio %d\", kim_gdata->nshutdown);\n\t\tgoto err_sysfs_group;\n\t}\n\t \n\tkim_gdata->kim_pdev = pdev;\n\tinit_completion(&kim_gdata->kim_rcvd);\n\tinit_completion(&kim_gdata->ldisc_installed);\n\n\terr = sysfs_create_group(&pdev->dev.kobj, &uim_attr_grp);\n\tif (err) {\n\t\tpr_err(\"failed to create sysfs entries\");\n\t\tgoto err_sysfs_group;\n\t}\n\n\t \n\tstrncpy(kim_gdata->dev_name, pdata->dev_name, UART_DEV_NAME_LEN);\n\tkim_gdata->flow_cntrl = pdata->flow_cntrl;\n\tkim_gdata->baud_rate = pdata->baud_rate;\n\tpr_info(\"sysfs entries created\\n\");\n\n\tkim_debugfs_dir = debugfs_create_dir(\"ti-st\", NULL);\n\n\tdebugfs_create_file(\"version\", S_IRUGO, kim_debugfs_dir,\n\t\t\t\tkim_gdata, &version_fops);\n\tdebugfs_create_file(\"protocols\", S_IRUGO, kim_debugfs_dir,\n\t\t\t\tkim_gdata, &list_fops);\n\treturn 0;\n\nerr_sysfs_group:\n\tst_core_exit(kim_gdata->core_data);\n\nerr_core_init:\n\tkfree(kim_gdata);\n\n\treturn err;\n}\n\nstatic int kim_remove(struct platform_device *pdev)\n{\n\t \n\tstruct ti_st_plat_data\t*pdata = pdev->dev.platform_data;\n\tstruct kim_data_s\t*kim_gdata;\n\n\tkim_gdata = platform_get_drvdata(pdev);\n\n\t \n\tgpio_free(pdata->nshutdown_gpio);\n\tpr_info(\"nshutdown GPIO Freed\");\n\n\tdebugfs_remove_recursive(kim_debugfs_dir);\n\tsysfs_remove_group(&pdev->dev.kobj, &uim_attr_grp);\n\tpr_info(\"sysfs entries removed\");\n\n\tkim_gdata->kim_pdev = NULL;\n\tst_core_exit(kim_gdata->core_data);\n\n\tkfree(kim_gdata);\n\tkim_gdata = NULL;\n\treturn 0;\n}\n\nstatic int kim_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct ti_st_plat_data\t*pdata = pdev->dev.platform_data;\n\n\tif (pdata->suspend)\n\t\treturn pdata->suspend(pdev, state);\n\n\treturn 0;\n}\n\nstatic int kim_resume(struct platform_device *pdev)\n{\n\tstruct ti_st_plat_data\t*pdata = pdev->dev.platform_data;\n\n\tif (pdata->resume)\n\t\treturn pdata->resume(pdev);\n\n\treturn 0;\n}\n\n \n \nstatic struct platform_driver kim_platform_driver = {\n\t.probe = kim_probe,\n\t.remove = kim_remove,\n\t.suspend = kim_suspend,\n\t.resume = kim_resume,\n\t.driver = {\n\t\t.name = \"kim\",\n\t},\n};\n\nmodule_platform_driver(kim_platform_driver);\n\nMODULE_AUTHOR(\"Pavan Savoy <pavan_savoy@ti.com>\");\nMODULE_DESCRIPTION(\"Shared Transport Driver for TI BT/FM/GPS combo chips \");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}