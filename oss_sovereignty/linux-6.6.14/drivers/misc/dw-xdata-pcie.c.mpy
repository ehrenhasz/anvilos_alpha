{
  "module_name": "dw-xdata-pcie.c",
  "hash_id": "2fdadf444608c3d1a4e2f5b7635b6a3d9681f6679e3be52ea686552467b08c77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/dw-xdata-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/miscdevice.h>\n#include <linux/bitfield.h>\n#include <linux/pci-epf.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/bitops.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n\n#define DW_XDATA_DRIVER_NAME\t\t\"dw-xdata-pcie\"\n\n#define DW_XDATA_EP_MEM_OFFSET\t\t0x8000000\n\nstatic DEFINE_IDA(xdata_ida);\n\n#define STATUS_DONE\t\t\tBIT(0)\n\n#define CONTROL_DOORBELL\t\tBIT(0)\n#define CONTROL_IS_WRITE\t\tBIT(1)\n#define CONTROL_LENGTH(a)\t\tFIELD_PREP(GENMASK(13, 2), a)\n#define CONTROL_PATTERN_INC\t\tBIT(16)\n#define CONTROL_NO_ADDR_INC\t\tBIT(18)\n\n#define XPERF_CONTROL_ENABLE\t\tBIT(5)\n\n#define BURST_REPEAT\t\t\tBIT(31)\n#define BURST_VALUE\t\t\t0x1001\n\n#define PATTERN_VALUE\t\t\t0x0\n\nstruct dw_xdata_regs {\n\tu32 addr_lsb;\t\t\t\t\t \n\tu32 addr_msb;\t\t\t\t\t \n\tu32 burst_cnt;\t\t\t\t\t \n\tu32 control;\t\t\t\t\t \n\tu32 pattern;\t\t\t\t\t \n\tu32 status;\t\t\t\t\t \n\tu32 RAM_addr;\t\t\t\t\t \n\tu32 RAM_port;\t\t\t\t\t \n\tu32 _reserved0[14];\t\t\t\t \n\tu32 perf_control;\t\t\t\t \n\tu32 _reserved1[41];\t\t\t\t \n\tu32 wr_cnt_lsb;\t\t\t\t\t \n\tu32 wr_cnt_msb;\t\t\t\t\t \n\tu32 rd_cnt_lsb;\t\t\t\t\t \n\tu32 rd_cnt_msb;\t\t\t\t\t \n} __packed;\n\nstruct dw_xdata_region {\n\tphys_addr_t paddr;\t\t\t\t \n\tvoid __iomem *vaddr;\t\t\t\t \n};\n\nstruct dw_xdata {\n\tstruct dw_xdata_region rg_region;\t\t \n\tsize_t max_wr_len;\t\t\t\t \n\tsize_t max_rd_len;\t\t\t\t \n\tstruct mutex mutex;\n\tstruct pci_dev *pdev;\n\tstruct miscdevice misc_dev;\n};\n\nstatic inline struct dw_xdata_regs __iomem *__dw_regs(struct dw_xdata *dw)\n{\n\treturn dw->rg_region.vaddr;\n}\n\nstatic void dw_xdata_stop(struct dw_xdata *dw)\n{\n\tu32 burst;\n\n\tmutex_lock(&dw->mutex);\n\n\tburst = readl(&(__dw_regs(dw)->burst_cnt));\n\n\tif (burst & BURST_REPEAT) {\n\t\tburst &= ~(u32)BURST_REPEAT;\n\t\twritel(burst, &(__dw_regs(dw)->burst_cnt));\n\t}\n\n\tmutex_unlock(&dw->mutex);\n}\n\nstatic void dw_xdata_start(struct dw_xdata *dw, bool write)\n{\n\tstruct device *dev = &dw->pdev->dev;\n\tu32 control, status;\n\n\t \n\tdw_xdata_stop(dw);\n\n\tmutex_lock(&dw->mutex);\n\n\t \n\twritel(0x0, &(__dw_regs(dw)->status));\n\n\t \n\twritel(BURST_REPEAT | BURST_VALUE, &(__dw_regs(dw)->burst_cnt));\n\n\t \n\twritel(PATTERN_VALUE, &(__dw_regs(dw)->pattern));\n\n\t \n\tcontrol = CONTROL_DOORBELL | CONTROL_PATTERN_INC | CONTROL_NO_ADDR_INC;\n\tif (write) {\n\t\tcontrol |= CONTROL_IS_WRITE;\n\t\tcontrol |= CONTROL_LENGTH(dw->max_wr_len);\n\t} else {\n\t\tcontrol |= CONTROL_LENGTH(dw->max_rd_len);\n\t}\n\twritel(control, &(__dw_regs(dw)->control));\n\n\t \n\tusleep_range(100, 150);\n\n\tstatus = readl(&(__dw_regs(dw)->status));\n\n\tmutex_unlock(&dw->mutex);\n\n\tif (!(status & STATUS_DONE))\n\t\tdev_dbg(dev, \"xData: started %s direction\\n\",\n\t\t\twrite ? \"write\" : \"read\");\n}\n\nstatic void dw_xdata_perf_meas(struct dw_xdata *dw, u64 *data, bool write)\n{\n\tif (write) {\n\t\t*data = readl(&(__dw_regs(dw)->wr_cnt_msb));\n\t\t*data <<= 32;\n\t\t*data |= readl(&(__dw_regs(dw)->wr_cnt_lsb));\n\t} else {\n\t\t*data = readl(&(__dw_regs(dw)->rd_cnt_msb));\n\t\t*data <<= 32;\n\t\t*data |= readl(&(__dw_regs(dw)->rd_cnt_lsb));\n\t}\n}\n\nstatic u64 dw_xdata_perf_diff(u64 *m1, u64 *m2, u64 time)\n{\n\tu64 rate = (*m1 - *m2);\n\n\trate *= (1000 * 1000 * 1000);\n\trate >>= 20;\n\trate = DIV_ROUND_CLOSEST_ULL(rate, time);\n\n\treturn rate;\n}\n\nstatic void dw_xdata_perf(struct dw_xdata *dw, u64 *rate, bool write)\n{\n\tstruct device *dev = &dw->pdev->dev;\n\tu64 data[2], time[2], diff;\n\n\tmutex_lock(&dw->mutex);\n\n\t \n\twritel(0x0, &(__dw_regs(dw)->perf_control));\n\tdw_xdata_perf_meas(dw, &data[0], write);\n\ttime[0] = jiffies;\n\twritel((u32)XPERF_CONTROL_ENABLE, &(__dw_regs(dw)->perf_control));\n\n\t \n\tmdelay(100);\n\n\t \n\twritel(0x0, &(__dw_regs(dw)->perf_control));\n\tdw_xdata_perf_meas(dw, &data[1], write);\n\ttime[1] = jiffies;\n\twritel((u32)XPERF_CONTROL_ENABLE, &(__dw_regs(dw)->perf_control));\n\n\t \n\tdiff = jiffies_to_nsecs(time[1] - time[0]);\n\t*rate = dw_xdata_perf_diff(&data[1], &data[0], diff);\n\n\tmutex_unlock(&dw->mutex);\n\n\tdev_dbg(dev, \"xData: time=%llu us, %s=%llu MB/s\\n\",\n\t\tdiff, write ? \"write\" : \"read\", *rate);\n}\n\nstatic struct dw_xdata *misc_dev_to_dw(struct miscdevice *misc_dev)\n{\n\treturn container_of(misc_dev, struct dw_xdata, misc_dev);\n}\n\nstatic ssize_t write_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct miscdevice *misc_dev = dev_get_drvdata(dev);\n\tstruct dw_xdata *dw = misc_dev_to_dw(misc_dev);\n\tu64 rate;\n\n\tdw_xdata_perf(dw, &rate, true);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", rate);\n}\n\nstatic ssize_t write_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t size)\n{\n\tstruct miscdevice *misc_dev = dev_get_drvdata(dev);\n\tstruct dw_xdata *dw = misc_dev_to_dw(misc_dev);\n\tbool enabled;\n\tint ret;\n\n\tret = kstrtobool(buf, &enabled);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enabled) {\n\t\tdev_dbg(dev, \"xData: requested write transfer\\n\");\n\t\tdw_xdata_start(dw, true);\n\t} else {\n\t\tdev_dbg(dev, \"xData: requested stop transfer\\n\");\n\t\tdw_xdata_stop(dw);\n\t}\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(write);\n\nstatic ssize_t read_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct miscdevice *misc_dev = dev_get_drvdata(dev);\n\tstruct dw_xdata *dw = misc_dev_to_dw(misc_dev);\n\tu64 rate;\n\n\tdw_xdata_perf(dw, &rate, false);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", rate);\n}\n\nstatic ssize_t read_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t size)\n{\n\tstruct miscdevice *misc_dev = dev_get_drvdata(dev);\n\tstruct dw_xdata *dw = misc_dev_to_dw(misc_dev);\n\tbool enabled;\n\tint ret;\n\n\tret = kstrtobool(buf, &enabled);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enabled) {\n\t\tdev_dbg(dev, \"xData: requested read transfer\\n\");\n\t\tdw_xdata_start(dw, false);\n\t} else {\n\t\tdev_dbg(dev, \"xData: requested stop transfer\\n\");\n\t\tdw_xdata_stop(dw);\n\t}\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(read);\n\nstatic struct attribute *xdata_attrs[] = {\n\t&dev_attr_write.attr,\n\t&dev_attr_read.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(xdata);\n\nstatic int dw_xdata_pcie_probe(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *pid)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_xdata *dw;\n\tchar name[24];\n\tu64 addr;\n\tint err;\n\tint id;\n\n\t \n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(dev, \"enabling device failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = pcim_iomap_regions(pdev, BIT(BAR_0), pci_name(pdev));\n\tif (err) {\n\t\tdev_err(dev, \"xData BAR I/O remapping failed\\n\");\n\t\treturn err;\n\t}\n\n\tpci_set_master(pdev);\n\n\t \n\tdw = devm_kzalloc(dev, sizeof(*dw), GFP_KERNEL);\n\tif (!dw)\n\t\treturn -ENOMEM;\n\n\t \n\tmutex_init(&dw->mutex);\n\n\tdw->rg_region.vaddr = pcim_iomap_table(pdev)[BAR_0];\n\tif (!dw->rg_region.vaddr)\n\t\treturn -ENOMEM;\n\n\tdw->rg_region.paddr = pdev->resource[BAR_0].start;\n\n\tdw->max_wr_len = pcie_get_mps(pdev);\n\tdw->max_wr_len >>= 2;\n\n\tdw->max_rd_len = pcie_get_readrq(pdev);\n\tdw->max_rd_len >>= 2;\n\n\tdw->pdev = pdev;\n\n\tid = ida_simple_get(&xdata_ida, 0, 0, GFP_KERNEL);\n\tif (id < 0) {\n\t\tdev_err(dev, \"xData: unable to get id\\n\");\n\t\treturn id;\n\t}\n\n\tsnprintf(name, sizeof(name), DW_XDATA_DRIVER_NAME \".%d\", id);\n\tdw->misc_dev.name = kstrdup(name, GFP_KERNEL);\n\tif (!dw->misc_dev.name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_ida_remove;\n\t}\n\n\tdw->misc_dev.minor = MISC_DYNAMIC_MINOR;\n\tdw->misc_dev.parent = dev;\n\tdw->misc_dev.groups = xdata_groups;\n\n\twritel(0x0, &(__dw_regs(dw)->RAM_addr));\n\twritel(0x0, &(__dw_regs(dw)->RAM_port));\n\n\taddr = dw->rg_region.paddr + DW_XDATA_EP_MEM_OFFSET;\n\twritel(lower_32_bits(addr), &(__dw_regs(dw)->addr_lsb));\n\twritel(upper_32_bits(addr), &(__dw_regs(dw)->addr_msb));\n\tdev_dbg(dev, \"xData: target address = 0x%.16llx\\n\", addr);\n\n\tdev_dbg(dev, \"xData: wr_len = %zu, rd_len = %zu\\n\",\n\t\tdw->max_wr_len * 4, dw->max_rd_len * 4);\n\n\t \n\tpci_set_drvdata(pdev, dw);\n\n\t \n\terr = misc_register(&dw->misc_dev);\n\tif (err) {\n\t\tdev_err(dev, \"xData: failed to register device\\n\");\n\t\tgoto err_kfree_name;\n\t}\n\n\treturn 0;\n\nerr_kfree_name:\n\tkfree(dw->misc_dev.name);\n\nerr_ida_remove:\n\tida_simple_remove(&xdata_ida, id);\n\n\treturn err;\n}\n\nstatic void dw_xdata_pcie_remove(struct pci_dev *pdev)\n{\n\tstruct dw_xdata *dw = pci_get_drvdata(pdev);\n\tint id;\n\n\tif (sscanf(dw->misc_dev.name, DW_XDATA_DRIVER_NAME \".%d\", &id) != 1)\n\t\treturn;\n\n\tif (id < 0)\n\t\treturn;\n\n\tdw_xdata_stop(dw);\n\tmisc_deregister(&dw->misc_dev);\n\tkfree(dw->misc_dev.name);\n\tida_simple_remove(&xdata_ida, id);\n}\n\nstatic const struct pci_device_id dw_xdata_pcie_id_table[] = {\n\t{ PCI_DEVICE_DATA(SYNOPSYS, EDDA, NULL) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, dw_xdata_pcie_id_table);\n\nstatic struct pci_driver dw_xdata_pcie_driver = {\n\t.name\t\t= DW_XDATA_DRIVER_NAME,\n\t.id_table\t= dw_xdata_pcie_id_table,\n\t.probe\t\t= dw_xdata_pcie_probe,\n\t.remove\t\t= dw_xdata_pcie_remove,\n};\n\nmodule_pci_driver(dw_xdata_pcie_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Synopsys DesignWare xData PCIe driver\");\nMODULE_AUTHOR(\"Gustavo Pimentel <gustavo.pimentel@synopsys.com>\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}