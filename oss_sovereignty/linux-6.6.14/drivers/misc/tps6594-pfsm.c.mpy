{
  "module_name": "tps6594-pfsm.c",
  "hash_id": "6444e86ce36aa5739b81acdd5a19ed5e0e554e27cc6921b3f4e34dc9eb8c9744",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/tps6594-pfsm.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/ioctl.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <linux/mfd/tps6594.h>\n\n#include <linux/tps6594_pfsm.h>\n\n#define TPS6594_STARTUP_DEST_MCU_ONLY_VAL 2\n#define TPS6594_STARTUP_DEST_ACTIVE_VAL   3\n#define TPS6594_STARTUP_DEST_SHIFT\t  5\n#define TPS6594_STARTUP_DEST_MCU_ONLY\t  (TPS6594_STARTUP_DEST_MCU_ONLY_VAL \\\n\t\t\t\t\t   << TPS6594_STARTUP_DEST_SHIFT)\n#define TPS6594_STARTUP_DEST_ACTIVE\t  (TPS6594_STARTUP_DEST_ACTIVE_VAL \\\n\t\t\t\t\t   << TPS6594_STARTUP_DEST_SHIFT)\n\n \n#define TPS6594_PMIC_MAX_POS 0x200\n\n#define TPS6594_FILE_TO_PFSM(f) container_of((f)->private_data, struct tps6594_pfsm, miscdev)\n\n \nstruct tps6594_pfsm {\n\tstruct miscdevice miscdev;\n\tstruct regmap *regmap;\n};\n\nstatic ssize_t tps6594_pfsm_read(struct file *f, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct tps6594_pfsm *pfsm = TPS6594_FILE_TO_PFSM(f);\n\tloff_t pos = *ppos;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= TPS6594_PMIC_MAX_POS)\n\t\treturn 0;\n\tif (count > TPS6594_PMIC_MAX_POS - pos)\n\t\tcount = TPS6594_PMIC_MAX_POS - pos;\n\n\tfor (i = 0 ; i < count ; i++) {\n\t\tret = regmap_read(pfsm->regmap, pos + i, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (put_user(val, buf + i))\n\t\t\treturn -EFAULT;\n\t}\n\n\t*ppos = pos + count;\n\n\treturn count;\n}\n\nstatic ssize_t tps6594_pfsm_write(struct file *f, const char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct tps6594_pfsm *pfsm = TPS6594_FILE_TO_PFSM(f);\n\tloff_t pos = *ppos;\n\tchar val;\n\tint ret;\n\tint i;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= TPS6594_PMIC_MAX_POS || !count)\n\t\treturn 0;\n\tif (count > TPS6594_PMIC_MAX_POS - pos)\n\t\tcount = TPS6594_PMIC_MAX_POS - pos;\n\n\tfor (i = 0 ; i < count ; i++) {\n\t\tif (get_user(val, buf + i))\n\t\t\treturn -EFAULT;\n\n\t\tret = regmap_write(pfsm->regmap, pos + i, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*ppos = pos + count;\n\n\treturn count;\n}\n\nstatic int tps6594_pfsm_configure_ret_trig(struct regmap *regmap, u8 gpio_ret, u8 ddr_ret)\n{\n\tint ret;\n\n\tif (gpio_ret)\n\t\tret = regmap_set_bits(regmap, TPS6594_REG_FSM_I2C_TRIGGERS,\n\t\t\t\t      TPS6594_BIT_TRIGGER_I2C(5) | TPS6594_BIT_TRIGGER_I2C(6));\n\telse\n\t\tret = regmap_clear_bits(regmap, TPS6594_REG_FSM_I2C_TRIGGERS,\n\t\t\t\t\tTPS6594_BIT_TRIGGER_I2C(5) | TPS6594_BIT_TRIGGER_I2C(6));\n\tif (ret)\n\t\treturn ret;\n\n\tif (ddr_ret)\n\t\tret = regmap_set_bits(regmap, TPS6594_REG_FSM_I2C_TRIGGERS,\n\t\t\t\t      TPS6594_BIT_TRIGGER_I2C(7));\n\telse\n\t\tret = regmap_clear_bits(regmap, TPS6594_REG_FSM_I2C_TRIGGERS,\n\t\t\t\t\tTPS6594_BIT_TRIGGER_I2C(7));\n\n\treturn ret;\n}\n\nstatic long tps6594_pfsm_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tstruct tps6594_pfsm *pfsm = TPS6594_FILE_TO_PFSM(f);\n\tstruct pmic_state_opt state_opt;\n\tvoid __user *argp = (void __user *)arg;\n\tint ret = -ENOIOCTLCMD;\n\n\tswitch (cmd) {\n\tcase PMIC_GOTO_STANDBY:\n\t\t \n\t\tret = regmap_clear_bits(pfsm->regmap, TPS6594_REG_RTC_CTRL_2,\n\t\t\t\t\tTPS6594_BIT_LP_STANDBY_SEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_write_bits(pfsm->regmap, TPS6594_REG_FSM_I2C_TRIGGERS,\n\t\t\t\t\tTPS6594_BIT_TRIGGER_I2C(0), TPS6594_BIT_TRIGGER_I2C(0));\n\t\tbreak;\n\tcase PMIC_GOTO_LP_STANDBY:\n\t\t \n\t\tret = regmap_set_bits(pfsm->regmap, TPS6594_REG_RTC_CTRL_2,\n\t\t\t\t      TPS6594_BIT_LP_STANDBY_SEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_write_bits(pfsm->regmap, TPS6594_REG_FSM_I2C_TRIGGERS,\n\t\t\t\t\tTPS6594_BIT_TRIGGER_I2C(0), TPS6594_BIT_TRIGGER_I2C(0));\n\t\tbreak;\n\tcase PMIC_UPDATE_PGM:\n\t\t \n\t\tret = regmap_write_bits(pfsm->regmap, TPS6594_REG_FSM_I2C_TRIGGERS,\n\t\t\t\t\tTPS6594_BIT_TRIGGER_I2C(3), TPS6594_BIT_TRIGGER_I2C(3));\n\t\tbreak;\n\tcase PMIC_SET_ACTIVE_STATE:\n\t\t \n\t\tret = regmap_set_bits(pfsm->regmap, TPS6594_REG_FSM_NSLEEP_TRIGGERS,\n\t\t\t\t      TPS6594_BIT_NSLEEP1B | TPS6594_BIT_NSLEEP2B);\n\t\tbreak;\n\tcase PMIC_SET_MCU_ONLY_STATE:\n\t\tif (copy_from_user(&state_opt, argp, sizeof(state_opt)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tret = tps6594_pfsm_configure_ret_trig(pfsm->regmap, state_opt.gpio_retention,\n\t\t\t\t\t\t      state_opt.ddr_retention);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_clear_bits(pfsm->regmap, TPS6594_REG_FSM_NSLEEP_TRIGGERS,\n\t\t\t\t\tTPS6594_BIT_NSLEEP1B);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_set_bits(pfsm->regmap, TPS6594_REG_FSM_NSLEEP_TRIGGERS,\n\t\t\t\t      TPS6594_BIT_NSLEEP2B);\n\t\tbreak;\n\tcase PMIC_SET_RETENTION_STATE:\n\t\tif (copy_from_user(&state_opt, argp, sizeof(state_opt)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (state_opt.mcu_only_startup_dest)\n\t\t\tret = regmap_write_bits(pfsm->regmap, TPS6594_REG_RTC_CTRL_2,\n\t\t\t\t\t\tTPS6594_MASK_STARTUP_DEST,\n\t\t\t\t\t\tTPS6594_STARTUP_DEST_MCU_ONLY);\n\t\telse\n\t\t\tret = regmap_write_bits(pfsm->regmap, TPS6594_REG_RTC_CTRL_2,\n\t\t\t\t\t\tTPS6594_MASK_STARTUP_DEST,\n\t\t\t\t\t\tTPS6594_STARTUP_DEST_ACTIVE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = tps6594_pfsm_configure_ret_trig(pfsm->regmap, state_opt.gpio_retention,\n\t\t\t\t\t\t      state_opt.ddr_retention);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_clear_bits(pfsm->regmap, TPS6594_REG_FSM_NSLEEP_TRIGGERS,\n\t\t\t\t\tTPS6594_BIT_NSLEEP2B);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct file_operations tps6594_pfsm_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= tps6594_pfsm_read,\n\t.write\t\t= tps6594_pfsm_write,\n\t.unlocked_ioctl\t= tps6594_pfsm_ioctl,\n\t.compat_ioctl   = compat_ptr_ioctl,\n};\n\nstatic irqreturn_t tps6594_pfsm_isr(int irq, void *dev_id)\n{\n\tstruct platform_device *pdev = dev_id;\n\tint i;\n\n\tfor (i = 0 ; i < pdev->num_resources ; i++) {\n\t\tif (irq == platform_get_irq_byname(pdev, pdev->resource[i].name)) {\n\t\t\tdev_err(pdev->dev.parent, \"%s event detected\\n\", pdev->resource[i].name);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int tps6594_pfsm_probe(struct platform_device *pdev)\n{\n\tstruct tps6594_pfsm *pfsm;\n\tstruct tps6594 *tps = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tint irq;\n\tint ret;\n\tint i;\n\n\tpfsm = devm_kzalloc(dev, sizeof(struct tps6594_pfsm), GFP_KERNEL);\n\tif (!pfsm)\n\t\treturn -ENOMEM;\n\n\tpfsm->regmap = tps->regmap;\n\n\tpfsm->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tpfsm->miscdev.name = devm_kasprintf(dev, GFP_KERNEL, \"pfsm-%ld-0x%02x\",\n\t\t\t\t\t    tps->chip_id, tps->reg);\n\tpfsm->miscdev.fops = &tps6594_pfsm_fops;\n\tpfsm->miscdev.parent = dev->parent;\n\n\tfor (i = 0 ; i < pdev->num_resources ; i++) {\n\t\tirq = platform_get_irq_byname(pdev, pdev->resource[i].name);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\t\ttps6594_pfsm_isr, IRQF_ONESHOT,\n\t\t\t\t\t\tpdev->resource[i].name, pdev);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"Failed to request irq\\n\");\n\t}\n\n\tplatform_set_drvdata(pdev, pfsm);\n\n\treturn misc_register(&pfsm->miscdev);\n}\n\nstatic void tps6594_pfsm_remove(struct platform_device *pdev)\n{\n\tstruct tps6594_pfsm *pfsm = platform_get_drvdata(pdev);\n\n\tmisc_deregister(&pfsm->miscdev);\n}\n\nstatic struct platform_driver tps6594_pfsm_driver = {\n\t.driver\t= {\n\t\t.name = \"tps6594-pfsm\",\n\t},\n\t.probe = tps6594_pfsm_probe,\n\t.remove_new = tps6594_pfsm_remove,\n};\n\nmodule_platform_driver(tps6594_pfsm_driver);\n\nMODULE_ALIAS(\"platform:tps6594-pfsm\");\nMODULE_AUTHOR(\"Julien Panis <jpanis@baylibre.com>\");\nMODULE_DESCRIPTION(\"TPS6594 Pre-configurable Finite State Machine Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}