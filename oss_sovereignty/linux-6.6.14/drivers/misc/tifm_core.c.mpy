{
  "module_name": "tifm_core.c",
  "hash_id": "e6850c0927ecffd9003a2dd893fb4f3c11f32715942e4bebfa09e1f7b2876fd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/tifm_core.c",
  "human_readable_source": "\n \n\n#include <linux/tifm.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/module.h>\n\n#define DRIVER_NAME \"tifm_core\"\n#define DRIVER_VERSION \"0.8\"\n\nstatic struct workqueue_struct *workqueue;\nstatic DEFINE_IDR(tifm_adapter_idr);\nstatic DEFINE_SPINLOCK(tifm_adapter_lock);\n\nstatic const char *tifm_media_type_name(unsigned char type, unsigned char nt)\n{\n\tconst char *card_type_name[3][3] = {\n\t\t{ \"SmartMedia/xD\", \"MemoryStick\", \"MMC/SD\" },\n\t\t{ \"XD\", \"MS\", \"SD\"},\n\t\t{ \"xd\", \"ms\", \"sd\"}\n\t};\n\n\tif (nt > 2 || type < 1 || type > 3)\n\t\treturn NULL;\n\treturn card_type_name[nt][type - 1];\n}\n\nstatic int tifm_dev_match(struct tifm_dev *sock, struct tifm_device_id *id)\n{\n\tif (sock->type == id->type)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int tifm_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\n\tstruct tifm_driver *fm_drv = container_of(drv, struct tifm_driver,\n\t\t\t\t\t\t  driver);\n\tstruct tifm_device_id *ids = fm_drv->id_table;\n\n\tif (ids) {\n\t\twhile (ids->type) {\n\t\t\tif (tifm_dev_match(sock, ids))\n\t\t\t\treturn 1;\n\t\t\t++ids;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int tifm_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct tifm_dev *sock = container_of_const(dev, struct tifm_dev, dev);\n\n\tif (add_uevent_var(env, \"TIFM_CARD_TYPE=%s\", tifm_media_type_name(sock->type, 1)))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int tifm_device_probe(struct device *dev)\n{\n\tstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\n\tstruct tifm_driver *drv = container_of(dev->driver, struct tifm_driver,\n\t\t\t\t\t       driver);\n\tint rc = -ENODEV;\n\n\tget_device(dev);\n\tif (dev->driver && drv->probe) {\n\t\trc = drv->probe(sock);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\tput_device(dev);\n\treturn rc;\n}\n\nstatic void tifm_dummy_event(struct tifm_dev *sock)\n{\n\treturn;\n}\n\nstatic void tifm_device_remove(struct device *dev)\n{\n\tstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\n\tstruct tifm_driver *drv = container_of(dev->driver, struct tifm_driver,\n\t\t\t\t\t       driver);\n\n\tif (dev->driver && drv->remove) {\n\t\tsock->card_event = tifm_dummy_event;\n\t\tsock->data_event = tifm_dummy_event;\n\t\tdrv->remove(sock);\n\t\tsock->dev.driver = NULL;\n\t}\n\n\tput_device(dev);\n}\n\n#ifdef CONFIG_PM\n\nstatic int tifm_device_suspend(struct device *dev, pm_message_t state)\n{\n\tstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\n\tstruct tifm_driver *drv = container_of(dev->driver, struct tifm_driver,\n\t\t\t\t\t       driver);\n\n\tif (dev->driver && drv->suspend)\n\t\treturn drv->suspend(sock, state);\n\treturn 0;\n}\n\nstatic int tifm_device_resume(struct device *dev)\n{\n\tstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\n\tstruct tifm_driver *drv = container_of(dev->driver, struct tifm_driver,\n\t\t\t\t\t       driver);\n\n\tif (dev->driver && drv->resume)\n\t\treturn drv->resume(sock);\n\treturn 0;\n}\n\n#else\n\n#define tifm_device_suspend NULL\n#define tifm_device_resume NULL\n\n#endif  \n\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\n\treturn sprintf(buf, \"%x\", sock->type);\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic struct attribute *tifm_dev_attrs[] = {\n\t&dev_attr_type.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(tifm_dev);\n\nstatic struct bus_type tifm_bus_type = {\n\t.name      = \"tifm\",\n\t.dev_groups = tifm_dev_groups,\n\t.match     = tifm_bus_match,\n\t.uevent    = tifm_uevent,\n\t.probe     = tifm_device_probe,\n\t.remove    = tifm_device_remove,\n\t.suspend   = tifm_device_suspend,\n\t.resume    = tifm_device_resume\n};\n\nstatic void tifm_free(struct device *dev)\n{\n\tstruct tifm_adapter *fm = container_of(dev, struct tifm_adapter, dev);\n\n\tkfree(fm);\n}\n\nstatic struct class tifm_adapter_class = {\n\t.name    = \"tifm_adapter\",\n\t.dev_release = tifm_free\n};\n\nstruct tifm_adapter *tifm_alloc_adapter(unsigned int num_sockets,\n\t\t\t\t\tstruct device *dev)\n{\n\tstruct tifm_adapter *fm;\n\n\tfm = kzalloc(struct_size(fm, sockets, num_sockets), GFP_KERNEL);\n\tif (fm) {\n\t\tfm->dev.class = &tifm_adapter_class;\n\t\tfm->dev.parent = dev;\n\t\tdevice_initialize(&fm->dev);\n\t\tspin_lock_init(&fm->lock);\n\t\tfm->num_sockets = num_sockets;\n\t}\n\treturn fm;\n}\nEXPORT_SYMBOL(tifm_alloc_adapter);\n\nint tifm_add_adapter(struct tifm_adapter *fm)\n{\n\tint rc;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&tifm_adapter_lock);\n\trc = idr_alloc(&tifm_adapter_idr, fm, 0, 0, GFP_NOWAIT);\n\tif (rc >= 0)\n\t\tfm->id = rc;\n\tspin_unlock(&tifm_adapter_lock);\n\tidr_preload_end();\n\tif (rc < 0)\n\t\treturn rc;\n\n\tdev_set_name(&fm->dev, \"tifm%u\", fm->id);\n\trc = device_add(&fm->dev);\n\tif (rc) {\n\t\tspin_lock(&tifm_adapter_lock);\n\t\tidr_remove(&tifm_adapter_idr, fm->id);\n\t\tspin_unlock(&tifm_adapter_lock);\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL(tifm_add_adapter);\n\nvoid tifm_remove_adapter(struct tifm_adapter *fm)\n{\n\tunsigned int cnt;\n\n\tflush_workqueue(workqueue);\n\tfor (cnt = 0; cnt < fm->num_sockets; ++cnt) {\n\t\tif (fm->sockets[cnt])\n\t\t\tdevice_unregister(&fm->sockets[cnt]->dev);\n\t}\n\n\tspin_lock(&tifm_adapter_lock);\n\tidr_remove(&tifm_adapter_idr, fm->id);\n\tspin_unlock(&tifm_adapter_lock);\n\tdevice_del(&fm->dev);\n}\nEXPORT_SYMBOL(tifm_remove_adapter);\n\nvoid tifm_free_adapter(struct tifm_adapter *fm)\n{\n\tput_device(&fm->dev);\n}\nEXPORT_SYMBOL(tifm_free_adapter);\n\nvoid tifm_free_device(struct device *dev)\n{\n\tstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\n\tkfree(sock);\n}\nEXPORT_SYMBOL(tifm_free_device);\n\nstruct tifm_dev *tifm_alloc_device(struct tifm_adapter *fm, unsigned int id,\n\t\t\t\t   unsigned char type)\n{\n\tstruct tifm_dev *sock = NULL;\n\n\tif (!tifm_media_type_name(type, 0))\n\t\treturn sock;\n\n\tsock = kzalloc(sizeof(struct tifm_dev), GFP_KERNEL);\n\tif (sock) {\n\t\tspin_lock_init(&sock->lock);\n\t\tsock->type = type;\n\t\tsock->socket_id = id;\n\t\tsock->card_event = tifm_dummy_event;\n\t\tsock->data_event = tifm_dummy_event;\n\n\t\tsock->dev.parent = fm->dev.parent;\n\t\tsock->dev.bus = &tifm_bus_type;\n\t\tsock->dev.dma_mask = fm->dev.parent->dma_mask;\n\t\tsock->dev.release = tifm_free_device;\n\n\t\tdev_set_name(&sock->dev, \"tifm_%s%u:%u\",\n\t\t\t     tifm_media_type_name(type, 2), fm->id, id);\n\t\tprintk(KERN_INFO DRIVER_NAME\n\t\t       \": %s card detected in socket %u:%u\\n\",\n\t\t       tifm_media_type_name(type, 0), fm->id, id);\n\t}\n\treturn sock;\n}\nEXPORT_SYMBOL(tifm_alloc_device);\n\nvoid tifm_eject(struct tifm_dev *sock)\n{\n\tstruct tifm_adapter *fm = dev_get_drvdata(sock->dev.parent);\n\tfm->eject(fm, sock);\n}\nEXPORT_SYMBOL(tifm_eject);\n\nint tifm_has_ms_pif(struct tifm_dev *sock)\n{\n\tstruct tifm_adapter *fm = dev_get_drvdata(sock->dev.parent);\n\treturn fm->has_ms_pif(fm, sock);\n}\nEXPORT_SYMBOL(tifm_has_ms_pif);\n\nint tifm_map_sg(struct tifm_dev *sock, struct scatterlist *sg, int nents,\n\t\tint direction)\n{\n\treturn dma_map_sg(&to_pci_dev(sock->dev.parent)->dev, sg, nents,\n\t\t\t  direction);\n}\nEXPORT_SYMBOL(tifm_map_sg);\n\nvoid tifm_unmap_sg(struct tifm_dev *sock, struct scatterlist *sg, int nents,\n\t\t   int direction)\n{\n\tdma_unmap_sg(&to_pci_dev(sock->dev.parent)->dev, sg, nents, direction);\n}\nEXPORT_SYMBOL(tifm_unmap_sg);\n\nvoid tifm_queue_work(struct work_struct *work)\n{\n\tqueue_work(workqueue, work);\n}\nEXPORT_SYMBOL(tifm_queue_work);\n\nint tifm_register_driver(struct tifm_driver *drv)\n{\n\tdrv->driver.bus = &tifm_bus_type;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL(tifm_register_driver);\n\nvoid tifm_unregister_driver(struct tifm_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL(tifm_unregister_driver);\n\nstatic int __init tifm_init(void)\n{\n\tint rc;\n\n\tworkqueue = create_freezable_workqueue(\"tifm\");\n\tif (!workqueue)\n\t\treturn -ENOMEM;\n\n\trc = bus_register(&tifm_bus_type);\n\n\tif (rc)\n\t\tgoto err_out_wq;\n\n\trc = class_register(&tifm_adapter_class);\n\tif (!rc)\n\t\treturn 0;\n\n\tbus_unregister(&tifm_bus_type);\n\nerr_out_wq:\n\tdestroy_workqueue(workqueue);\n\n\treturn rc;\n}\n\nstatic void __exit tifm_exit(void)\n{\n\tclass_unregister(&tifm_adapter_class);\n\tbus_unregister(&tifm_bus_type);\n\tdestroy_workqueue(workqueue);\n}\n\nsubsys_initcall(tifm_init);\nmodule_exit(tifm_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alex Dubov\");\nMODULE_DESCRIPTION(\"TI FlashMedia core driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRIVER_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}