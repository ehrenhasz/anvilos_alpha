{
  "module_name": "event.c",
  "hash_id": "093fdfdbabe339b9f3860a5289db0c305208a17c7a21be30a122886600cc9d20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ibmasm/event.c",
  "human_readable_source": "\n\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include \"ibmasm.h\"\n#include \"lowlevel.h\"\n\n \n\nstatic void wake_up_event_readers(struct service_processor *sp)\n{\n\tstruct event_reader *reader;\n\n\tlist_for_each_entry(reader, &sp->event_buffer->readers, node)\n                wake_up_interruptible(&reader->wait);\n}\n\n \nvoid ibmasm_receive_event(struct service_processor *sp, void *data, unsigned int data_size)\n{\n\tstruct event_buffer *buffer = sp->event_buffer;\n\tstruct ibmasm_event *event;\n\tunsigned long flags;\n\n\tdata_size = min(data_size, IBMASM_EVENT_MAX_SIZE);\n\n\tspin_lock_irqsave(&sp->lock, flags);\n\t \n\tevent = &buffer->events[buffer->next_index];\n\tmemcpy_fromio(event->data, data, data_size);\n\tevent->data_size = data_size;\n\tevent->serial_number = buffer->next_serial_number;\n\n\t \n\tbuffer->next_index = (buffer->next_index + 1) % IBMASM_NUM_EVENTS;\n\tbuffer->next_serial_number++;\n\tspin_unlock_irqrestore(&sp->lock, flags);\n\n\twake_up_event_readers(sp);\n}\n\nstatic inline int event_available(struct event_buffer *b, struct event_reader *r)\n{\n\treturn (r->next_serial_number < b->next_serial_number);\n}\n\n \nint ibmasm_get_next_event(struct service_processor *sp, struct event_reader *reader)\n{\n\tstruct event_buffer *buffer = sp->event_buffer;\n\tstruct ibmasm_event *event;\n\tunsigned int index;\n\tunsigned long flags;\n\n\treader->cancelled = 0;\n\n\tif (wait_event_interruptible(reader->wait,\n\t\t\tevent_available(buffer, reader) || reader->cancelled))\n\t\treturn -ERESTARTSYS;\n\n\tif (!event_available(buffer, reader))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&sp->lock, flags);\n\n\tindex = buffer->next_index;\n\tevent = &buffer->events[index];\n\twhile (event->serial_number < reader->next_serial_number) {\n\t\tindex = (index + 1) % IBMASM_NUM_EVENTS;\n\t\tevent = &buffer->events[index];\n\t}\n\tmemcpy(reader->data, event->data, event->data_size);\n\treader->data_size = event->data_size;\n\treader->next_serial_number = event->serial_number + 1;\n\n\tspin_unlock_irqrestore(&sp->lock, flags);\n\n\treturn event->data_size;\n}\n\nvoid ibmasm_cancel_next_event(struct event_reader *reader)\n{\n        reader->cancelled = 1;\n        wake_up_interruptible(&reader->wait);\n}\n\nvoid ibmasm_event_reader_register(struct service_processor *sp, struct event_reader *reader)\n{\n\tunsigned long flags;\n\n\treader->next_serial_number = sp->event_buffer->next_serial_number;\n\tinit_waitqueue_head(&reader->wait);\n\tspin_lock_irqsave(&sp->lock, flags);\n\tlist_add(&reader->node, &sp->event_buffer->readers);\n\tspin_unlock_irqrestore(&sp->lock, flags);\n}\n\nvoid ibmasm_event_reader_unregister(struct service_processor *sp, struct event_reader *reader)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sp->lock, flags);\n\tlist_del(&reader->node);\n\tspin_unlock_irqrestore(&sp->lock, flags);\n}\n\nint ibmasm_event_buffer_init(struct service_processor *sp)\n{\n\tstruct event_buffer *buffer;\n\tstruct ibmasm_event *event;\n\tint i;\n\n\tbuffer = kmalloc(sizeof(struct event_buffer), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer->next_index = 0;\n\tbuffer->next_serial_number = 1;\n\n\tevent = buffer->events;\n\tfor (i=0; i<IBMASM_NUM_EVENTS; i++, event++)\n\t\tevent->serial_number = 0;\n\n\tINIT_LIST_HEAD(&buffer->readers);\n\n\tsp->event_buffer = buffer;\n\n\treturn 0;\n}\n\nvoid ibmasm_event_buffer_exit(struct service_processor *sp)\n{\n\tkfree(sp->event_buffer);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}