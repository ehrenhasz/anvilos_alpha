{
  "module_name": "ibmasmfs.c",
  "hash_id": "b8aa0fa18c71312f61de7beaf91222fd0462bbee18dda11fc6d7500a97d69986",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ibmasm/ibmasmfs.c",
  "human_readable_source": "\n \n\n \n\n\n \n\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include \"ibmasm.h\"\n#include \"remote.h\"\n#include \"dot_command.h\"\n\n#define IBMASMFS_MAGIC 0x66726f67\n\nstatic LIST_HEAD(service_processors);\n\nstatic struct inode *ibmasmfs_make_inode(struct super_block *sb, int mode);\nstatic void ibmasmfs_create_files (struct super_block *sb);\nstatic int ibmasmfs_fill_super(struct super_block *sb, struct fs_context *fc);\n\nstatic int ibmasmfs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_single(fc, ibmasmfs_fill_super);\n}\n\nstatic const struct fs_context_operations ibmasmfs_context_ops = {\n\t.get_tree\t= ibmasmfs_get_tree,\n};\n\nstatic int ibmasmfs_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &ibmasmfs_context_ops;\n\treturn 0;\n}\n\nstatic const struct super_operations ibmasmfs_s_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n};\n\nstatic const struct file_operations *ibmasmfs_dir_ops = &simple_dir_operations;\n\nstatic struct file_system_type ibmasmfs_type = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"ibmasmfs\",\n\t.init_fs_context = ibmasmfs_init_fs_context,\n\t.kill_sb        = kill_litter_super,\n};\nMODULE_ALIAS_FS(\"ibmasmfs\");\n\nstatic int ibmasmfs_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct inode *root;\n\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic = IBMASMFS_MAGIC;\n\tsb->s_op = &ibmasmfs_s_ops;\n\tsb->s_time_gran = 1;\n\n\troot = ibmasmfs_make_inode (sb, S_IFDIR | 0500);\n\tif (!root)\n\t\treturn -ENOMEM;\n\n\troot->i_op = &simple_dir_inode_operations;\n\troot->i_fop = ibmasmfs_dir_ops;\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\tibmasmfs_create_files(sb);\n\treturn 0;\n}\n\nstatic struct inode *ibmasmfs_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_ino = get_next_ino();\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = inode_set_ctime_current(ret);\n\t}\n\treturn ret;\n}\n\nstatic struct dentry *ibmasmfs_create_file(struct dentry *parent,\n\t\t\tconst char *name,\n\t\t\tconst struct file_operations *fops,\n\t\t\tvoid *data,\n\t\t\tint mode)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tdentry = d_alloc_name(parent, name);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tinode = ibmasmfs_make_inode(parent->d_sb, S_IFREG | mode);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\tinode->i_fop = fops;\n\tinode->i_private = data;\n\n\td_add(dentry, inode);\n\treturn dentry;\n}\n\nstatic struct dentry *ibmasmfs_create_dir(struct dentry *parent,\n\t\t\t\tconst char *name)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tdentry = d_alloc_name(parent, name);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tinode = ibmasmfs_make_inode(parent->d_sb, S_IFDIR | 0500);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = ibmasmfs_dir_ops;\n\n\td_add(dentry, inode);\n\treturn dentry;\n}\n\nint ibmasmfs_register(void)\n{\n\treturn register_filesystem(&ibmasmfs_type);\n}\n\nvoid ibmasmfs_unregister(void)\n{\n\tunregister_filesystem(&ibmasmfs_type);\n}\n\nvoid ibmasmfs_add_sp(struct service_processor *sp)\n{\n\tlist_add(&sp->node, &service_processors);\n}\n\n \nstruct ibmasmfs_command_data {\n\tstruct service_processor\t*sp;\n\tstruct command\t\t\t*command;\n};\n\n \nstruct ibmasmfs_event_data {\n\tstruct service_processor\t*sp;\n\tstruct event_reader\t\treader;\n\tint\t\t\t\tactive;\n};\n\n \nstruct ibmasmfs_heartbeat_data {\n\tstruct service_processor\t*sp;\n\tstruct reverse_heartbeat\theartbeat;\n\tint\t\t\t\tactive;\n};\n\nstatic int command_file_open(struct inode *inode, struct file *file)\n{\n\tstruct ibmasmfs_command_data *command_data;\n\n\tif (!inode->i_private)\n\t\treturn -ENODEV;\n\n\tcommand_data = kmalloc(sizeof(struct ibmasmfs_command_data), GFP_KERNEL);\n\tif (!command_data)\n\t\treturn -ENOMEM;\n\n\tcommand_data->command = NULL;\n\tcommand_data->sp = inode->i_private;\n\tfile->private_data = command_data;\n\treturn 0;\n}\n\nstatic int command_file_close(struct inode *inode, struct file *file)\n{\n\tstruct ibmasmfs_command_data *command_data = file->private_data;\n\n\tif (command_data->command)\n\t\tcommand_put(command_data->command);\n\n\tkfree(command_data);\n\treturn 0;\n}\n\nstatic ssize_t command_file_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\n{\n\tstruct ibmasmfs_command_data *command_data = file->private_data;\n\tstruct command *cmd;\n\tint len;\n\tunsigned long flags;\n\n\tif (*offset < 0)\n\t\treturn -EINVAL;\n\tif (count == 0 || count > IBMASM_CMD_MAX_BUFFER_SIZE)\n\t\treturn 0;\n\tif (*offset != 0)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&command_data->sp->lock, flags);\n\tcmd = command_data->command;\n\tif (cmd == NULL) {\n\t\tspin_unlock_irqrestore(&command_data->sp->lock, flags);\n\t\treturn 0;\n\t}\n\tcommand_data->command = NULL;\n\tspin_unlock_irqrestore(&command_data->sp->lock, flags);\n\n\tif (cmd->status != IBMASM_CMD_COMPLETE) {\n\t\tcommand_put(cmd);\n\t\treturn -EIO;\n\t}\n\tlen = min(count, cmd->buffer_size);\n\tif (copy_to_user(buf, cmd->buffer, len)) {\n\t\tcommand_put(cmd);\n\t\treturn -EFAULT;\n\t}\n\tcommand_put(cmd);\n\n\treturn len;\n}\n\nstatic ssize_t command_file_write(struct file *file, const char __user *ubuff, size_t count, loff_t *offset)\n{\n\tstruct ibmasmfs_command_data *command_data = file->private_data;\n\tstruct command *cmd;\n\tunsigned long flags;\n\n\tif (*offset < 0)\n\t\treturn -EINVAL;\n\tif (count == 0 || count > IBMASM_CMD_MAX_BUFFER_SIZE)\n\t\treturn 0;\n\tif (*offset != 0)\n\t\treturn 0;\n\n\t \n\tif (command_data->command)\n\t\treturn -EAGAIN;\n\n\tcmd = ibmasm_new_command(command_data->sp, count);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(cmd->buffer, ubuff, count)) {\n\t\tcommand_put(cmd);\n\t\treturn -EFAULT;\n\t}\n\n\tspin_lock_irqsave(&command_data->sp->lock, flags);\n\tif (command_data->command) {\n\t\tspin_unlock_irqrestore(&command_data->sp->lock, flags);\n\t\tcommand_put(cmd);\n\t\treturn -EAGAIN;\n\t}\n\tcommand_data->command = cmd;\n\tspin_unlock_irqrestore(&command_data->sp->lock, flags);\n\n\tibmasm_exec_command(command_data->sp, cmd);\n\tibmasm_wait_for_response(cmd, get_dot_command_timeout(cmd->buffer));\n\n\treturn count;\n}\n\nstatic int event_file_open(struct inode *inode, struct file *file)\n{\n\tstruct ibmasmfs_event_data *event_data;\n\tstruct service_processor *sp;\n\n\tif (!inode->i_private)\n\t\treturn -ENODEV;\n\n\tsp = inode->i_private;\n\n\tevent_data = kmalloc(sizeof(struct ibmasmfs_event_data), GFP_KERNEL);\n\tif (!event_data)\n\t\treturn -ENOMEM;\n\n\tibmasm_event_reader_register(sp, &event_data->reader);\n\n\tevent_data->sp = sp;\n\tevent_data->active = 0;\n\tfile->private_data = event_data;\n\treturn 0;\n}\n\nstatic int event_file_close(struct inode *inode, struct file *file)\n{\n\tstruct ibmasmfs_event_data *event_data = file->private_data;\n\n\tibmasm_event_reader_unregister(event_data->sp, &event_data->reader);\n\tkfree(event_data);\n\treturn 0;\n}\n\nstatic ssize_t event_file_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\n{\n\tstruct ibmasmfs_event_data *event_data = file->private_data;\n\tstruct event_reader *reader = &event_data->reader;\n\tstruct service_processor *sp = event_data->sp;\n\tint ret;\n\tunsigned long flags;\n\n\tif (*offset < 0)\n\t\treturn -EINVAL;\n\tif (count == 0 || count > IBMASM_EVENT_MAX_SIZE)\n\t\treturn 0;\n\tif (*offset != 0)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&sp->lock, flags);\n\tif (event_data->active) {\n\t\tspin_unlock_irqrestore(&sp->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\tevent_data->active = 1;\n\tspin_unlock_irqrestore(&sp->lock, flags);\n\n\tret = ibmasm_get_next_event(sp, reader);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tif (count < reader->data_size) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n        if (copy_to_user(buf, reader->data, reader->data_size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tret = reader->data_size;\n\nout:\n\tevent_data->active = 0;\n\treturn ret;\n}\n\nstatic ssize_t event_file_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\n{\n\tstruct ibmasmfs_event_data *event_data = file->private_data;\n\n\tif (*offset < 0)\n\t\treturn -EINVAL;\n\tif (count != 1)\n\t\treturn 0;\n\tif (*offset != 0)\n\t\treturn 0;\n\n\tibmasm_cancel_next_event(&event_data->reader);\n\treturn 0;\n}\n\nstatic int r_heartbeat_file_open(struct inode *inode, struct file *file)\n{\n\tstruct ibmasmfs_heartbeat_data *rhbeat;\n\n\tif (!inode->i_private)\n\t\treturn -ENODEV;\n\n\trhbeat = kmalloc(sizeof(struct ibmasmfs_heartbeat_data), GFP_KERNEL);\n\tif (!rhbeat)\n\t\treturn -ENOMEM;\n\n\trhbeat->sp = inode->i_private;\n\trhbeat->active = 0;\n\tibmasm_init_reverse_heartbeat(rhbeat->sp, &rhbeat->heartbeat);\n\tfile->private_data = rhbeat;\n\treturn 0;\n}\n\nstatic int r_heartbeat_file_close(struct inode *inode, struct file *file)\n{\n\tstruct ibmasmfs_heartbeat_data *rhbeat = file->private_data;\n\n\tkfree(rhbeat);\n\treturn 0;\n}\n\nstatic ssize_t r_heartbeat_file_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\n{\n\tstruct ibmasmfs_heartbeat_data *rhbeat = file->private_data;\n\tunsigned long flags;\n\tint result;\n\n\tif (*offset < 0)\n\t\treturn -EINVAL;\n\tif (count == 0 || count > 1024)\n\t\treturn 0;\n\tif (*offset != 0)\n\t\treturn 0;\n\n\t \n\tspin_lock_irqsave(&rhbeat->sp->lock, flags);\n\tif (rhbeat->active) {\n\t\tspin_unlock_irqrestore(&rhbeat->sp->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\trhbeat->active = 1;\n\tspin_unlock_irqrestore(&rhbeat->sp->lock, flags);\n\n\tresult = ibmasm_start_reverse_heartbeat(rhbeat->sp, &rhbeat->heartbeat);\n\trhbeat->active = 0;\n\n\treturn result;\n}\n\nstatic ssize_t r_heartbeat_file_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\n{\n\tstruct ibmasmfs_heartbeat_data *rhbeat = file->private_data;\n\n\tif (*offset < 0)\n\t\treturn -EINVAL;\n\tif (count != 1)\n\t\treturn 0;\n\tif (*offset != 0)\n\t\treturn 0;\n\n\tif (rhbeat->active)\n\t\tibmasm_stop_reverse_heartbeat(&rhbeat->heartbeat);\n\n\treturn 1;\n}\n\nstatic int remote_settings_file_close(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\nstatic ssize_t remote_settings_file_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\n{\n\tvoid __iomem *address = (void __iomem *)file->private_data;\n\tint len = 0;\n\tunsigned int value;\n\tchar lbuf[20];\n\n\tvalue = readl(address);\n\tlen = snprintf(lbuf, sizeof(lbuf), \"%d\\n\", value);\n\n\treturn simple_read_from_buffer(buf, count, offset, lbuf, len);\n}\n\nstatic ssize_t remote_settings_file_write(struct file *file, const char __user *ubuff, size_t count, loff_t *offset)\n{\n\tvoid __iomem *address = (void __iomem *)file->private_data;\n\tchar *buff;\n\tunsigned int value;\n\n\tif (*offset < 0)\n\t\treturn -EINVAL;\n\tif (count == 0 || count > 1024)\n\t\treturn 0;\n\tif (*offset != 0)\n\t\treturn 0;\n\n\tbuff = kzalloc (count + 1, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\n\tif (copy_from_user(buff, ubuff, count)) {\n\t\tkfree(buff);\n\t\treturn -EFAULT;\n\t}\n\n\tvalue = simple_strtoul(buff, NULL, 10);\n\twritel(value, address);\n\tkfree(buff);\n\n\treturn count;\n}\n\nstatic const struct file_operations command_fops = {\n\t.open =\t\tcommand_file_open,\n\t.release =\tcommand_file_close,\n\t.read =\t\tcommand_file_read,\n\t.write =\tcommand_file_write,\n\t.llseek =\tgeneric_file_llseek,\n};\n\nstatic const struct file_operations event_fops = {\n\t.open =\t\tevent_file_open,\n\t.release =\tevent_file_close,\n\t.read =\t\tevent_file_read,\n\t.write =\tevent_file_write,\n\t.llseek =\tgeneric_file_llseek,\n};\n\nstatic const struct file_operations r_heartbeat_fops = {\n\t.open =\t\tr_heartbeat_file_open,\n\t.release =\tr_heartbeat_file_close,\n\t.read =\t\tr_heartbeat_file_read,\n\t.write =\tr_heartbeat_file_write,\n\t.llseek =\tgeneric_file_llseek,\n};\n\nstatic const struct file_operations remote_settings_fops = {\n\t.open =\t\tsimple_open,\n\t.release =\tremote_settings_file_close,\n\t.read =\t\tremote_settings_file_read,\n\t.write =\tremote_settings_file_write,\n\t.llseek =\tgeneric_file_llseek,\n};\n\n\nstatic void ibmasmfs_create_files (struct super_block *sb)\n{\n\tstruct list_head *entry;\n\tstruct service_processor *sp;\n\n\tlist_for_each(entry, &service_processors) {\n\t\tstruct dentry *dir;\n\t\tstruct dentry *remote_dir;\n\t\tsp = list_entry(entry, struct service_processor, node);\n\t\tdir = ibmasmfs_create_dir(sb->s_root, sp->dirname);\n\t\tif (!dir)\n\t\t\tcontinue;\n\n\t\tibmasmfs_create_file(dir, \"command\", &command_fops, sp, S_IRUSR|S_IWUSR);\n\t\tibmasmfs_create_file(dir, \"event\", &event_fops, sp, S_IRUSR|S_IWUSR);\n\t\tibmasmfs_create_file(dir, \"reverse_heartbeat\", &r_heartbeat_fops, sp, S_IRUSR|S_IWUSR);\n\n\t\tremote_dir = ibmasmfs_create_dir(dir, \"remote_video\");\n\t\tif (!remote_dir)\n\t\t\tcontinue;\n\n\t\tibmasmfs_create_file(remote_dir, \"width\", &remote_settings_fops, (void *)display_width(sp), S_IRUSR|S_IWUSR);\n\t\tibmasmfs_create_file(remote_dir, \"height\", &remote_settings_fops, (void *)display_height(sp), S_IRUSR|S_IWUSR);\n\t\tibmasmfs_create_file(remote_dir, \"depth\", &remote_settings_fops, (void *)display_depth(sp), S_IRUSR|S_IWUSR);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}