{
  "module_name": "module.c",
  "hash_id": "648fa3e09588be7728bace204201ce50ea889cd9c39fd3def754637c89a0db99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ibmasm/module.c",
  "human_readable_source": "\n\n \n\n \n\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include \"ibmasm.h\"\n#include \"lowlevel.h\"\n#include \"remote.h\"\n\nint ibmasm_debug = 0;\nmodule_param(ibmasm_debug, int , S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ibmasm_debug, \" Set debug mode on or off\");\n\n\nstatic int ibmasm_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint result;\n\tstruct service_processor *sp;\n\n\tif ((result = pci_enable_device(pdev))) {\n\t\tdev_err(&pdev->dev, \"Failed to enable PCI device\\n\");\n\t\treturn result;\n\t}\n\tif ((result = pci_request_regions(pdev, DRIVER_NAME))) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate PCI resources\\n\");\n\t\tgoto error_resources;\n\t}\n\t \n\tpci_set_master(pdev);\n\n\tsp = kzalloc(sizeof(struct service_processor), GFP_KERNEL);\n\tif (sp == NULL) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate memory\\n\");\n\t\tresult = -ENOMEM;\n\t\tgoto error_kmalloc;\n\t}\n\n\tspin_lock_init(&sp->lock);\n\tINIT_LIST_HEAD(&sp->command_queue);\n\n\tpci_set_drvdata(pdev, (void *)sp);\n\tsp->dev = &pdev->dev;\n\tsp->number = pdev->bus->number;\n\tsnprintf(sp->dirname, IBMASM_NAME_SIZE, \"%d\", sp->number);\n\tsnprintf(sp->devname, IBMASM_NAME_SIZE, \"%s%d\", DRIVER_NAME, sp->number);\n\n\tresult = ibmasm_event_buffer_init(sp);\n\tif (result) {\n\t\tdev_err(sp->dev, \"Failed to allocate event buffer\\n\");\n\t\tgoto error_eventbuffer;\n\t}\n\n\tresult = ibmasm_heartbeat_init(sp);\n\tif (result) {\n\t\tdev_err(sp->dev, \"Failed to allocate heartbeat command\\n\");\n\t\tgoto error_heartbeat;\n\t}\n\n\tsp->irq = pdev->irq;\n\tsp->base_address = pci_ioremap_bar(pdev, 0);\n\tif (!sp->base_address) {\n\t\tdev_err(sp->dev, \"Failed to ioremap pci memory\\n\");\n\t\tresult =  -ENODEV;\n\t\tgoto error_ioremap;\n\t}\n\n\tresult = request_irq(sp->irq, ibmasm_interrupt_handler, IRQF_SHARED, sp->devname, (void*)sp);\n\tif (result) {\n\t\tdev_err(sp->dev, \"Failed to register interrupt handler\\n\");\n\t\tgoto error_request_irq;\n\t}\n\n\tenable_sp_interrupts(sp->base_address);\n\n\tresult = ibmasm_init_remote_input_dev(sp);\n\tif (result) {\n\t\tdev_err(sp->dev, \"Failed to initialize remote queue\\n\");\n\t\tgoto error_init_remote;\n\t}\n\n\tresult = ibmasm_send_driver_vpd(sp);\n\tif (result) {\n\t\tdev_err(sp->dev, \"Failed to send driver VPD to service processor\\n\");\n\t\tgoto error_send_message;\n\t}\n\tresult = ibmasm_send_os_state(sp, SYSTEM_STATE_OS_UP);\n\tif (result) {\n\t\tdev_err(sp->dev, \"Failed to send OS state to service processor\\n\");\n\t\tgoto error_send_message;\n\t}\n\tibmasmfs_add_sp(sp);\n\n\tibmasm_register_uart(sp);\n\n\treturn 0;\n\nerror_send_message:\n\tibmasm_free_remote_input_dev(sp);\nerror_init_remote:\n\tdisable_sp_interrupts(sp->base_address);\n\tfree_irq(sp->irq, (void *)sp);\nerror_request_irq:\n\tiounmap(sp->base_address);\nerror_ioremap:\n\tibmasm_heartbeat_exit(sp);\nerror_heartbeat:\n\tibmasm_event_buffer_exit(sp);\nerror_eventbuffer:\n\tkfree(sp);\nerror_kmalloc:\n        pci_release_regions(pdev);\nerror_resources:\n        pci_disable_device(pdev);\n\n\treturn result;\n}\n\nstatic void ibmasm_remove_one(struct pci_dev *pdev)\n{\n\tstruct service_processor *sp = pci_get_drvdata(pdev);\n\n\tdbg(\"Unregistering UART\\n\");\n\tibmasm_unregister_uart(sp);\n\tdbg(\"Sending OS down message\\n\");\n\tif (ibmasm_send_os_state(sp, SYSTEM_STATE_OS_DOWN))\n\t\terr(\"failed to get response to 'Send OS State' command\\n\");\n\tdbg(\"Disabling heartbeats\\n\");\n\tibmasm_heartbeat_exit(sp);\n\tdbg(\"Disabling interrupts\\n\");\n\tdisable_sp_interrupts(sp->base_address);\n\tdbg(\"Freeing SP irq\\n\");\n\tfree_irq(sp->irq, (void *)sp);\n\tdbg(\"Cleaning up\\n\");\n\tibmasm_free_remote_input_dev(sp);\n\tiounmap(sp->base_address);\n\tibmasm_event_buffer_exit(sp);\n\tkfree(sp);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_device_id ibmasm_pci_table[] =\n{\n\t{ PCI_DEVICE(VENDORID_IBM, DEVICEID_RSA) },\n\t{},\n};\n\nstatic struct pci_driver ibmasm_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.id_table\t= ibmasm_pci_table,\n\t.probe\t\t= ibmasm_init_one,\n\t.remove\t\t= ibmasm_remove_one,\n};\n\nstatic void __exit ibmasm_exit (void)\n{\n\tibmasm_unregister_panic_notifier();\n\tibmasmfs_unregister();\n\tpci_unregister_driver(&ibmasm_driver);\n\tinfo(DRIVER_DESC \" version \" DRIVER_VERSION \" unloaded\");\n}\n\nstatic int __init ibmasm_init(void)\n{\n\tint result = pci_register_driver(&ibmasm_driver);\n\tif (result)\n\t\treturn result;\n\n\tresult = ibmasmfs_register();\n\tif (result) {\n\t\tpci_unregister_driver(&ibmasm_driver);\n\t\terr(\"Failed to register ibmasmfs file system\");\n\t\treturn result;\n\t}\n\n\tibmasm_register_panic_notifier();\n\tinfo(DRIVER_DESC \" version \" DRIVER_VERSION \" loaded\");\n\treturn 0;\n}\n\nmodule_init(ibmasm_init);\nmodule_exit(ibmasm_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, ibmasm_pci_table);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}