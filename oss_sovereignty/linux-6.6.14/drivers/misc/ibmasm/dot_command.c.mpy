{
  "module_name": "dot_command.c",
  "hash_id": "ecd38bd6c1276f98cce8a9d704409a636d05441fe3b5d2feb28110685fd9b2fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ibmasm/dot_command.c",
  "human_readable_source": "\n \n\n#include \"ibmasm.h\"\n#include \"dot_command.h\"\n\n \nvoid ibmasm_receive_message(struct service_processor *sp, void *message, int message_size)\n{\n\tu32 size;\n\tstruct dot_command_header *header = (struct dot_command_header *)message;\n\n\tif (message_size == 0)\n\t\treturn;\n\n\tsize = get_dot_command_size(message);\n\tif (size == 0)\n\t\treturn;\n\n\tif (size > message_size)\n\t\tsize = message_size;\n\n\tswitch (header->type) {\n\tcase sp_event:\n\t\tibmasm_receive_event(sp, message, size);\n\t\tbreak;\n\tcase sp_command_response:\n\t\tibmasm_receive_command_response(sp, message, size);\n\t\tbreak;\n\tcase sp_heartbeat:\n\t\tibmasm_receive_heartbeat(sp, message, size);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sp->dev, \"Received unknown message from service processor\\n\");\n\t}\n}\n\n\n#define INIT_BUFFER_SIZE 32\n\n\n \nint ibmasm_send_driver_vpd(struct service_processor *sp)\n{\n\tstruct command *command;\n\tstruct dot_command_header *header;\n\tu8 *vpd_command;\n\tu8 *vpd_data;\n\tint result = 0;\n\n\tcommand = ibmasm_new_command(sp, INIT_BUFFER_SIZE);\n\tif (command == NULL)\n\t\treturn -ENOMEM;\n\n\theader = (struct dot_command_header *)command->buffer;\n\theader->type                = sp_write;\n\theader->command_size        = 4;\n\theader->data_size           = 16;\n\theader->status              = 0;\n\theader->reserved            = 0;\n\n\tvpd_command = command->buffer + sizeof(struct dot_command_header);\n\tvpd_command[0] = 0x4;\n\tvpd_command[1] = 0x3;\n\tvpd_command[2] = 0x5;\n\tvpd_command[3] = 0xa;\n\n\tvpd_data = vpd_command + header->command_size;\n\tvpd_data[0] = 0;\n\tstrcat(vpd_data, IBMASM_DRIVER_VPD);\n\tvpd_data[10] = 0;\n\tvpd_data[15] = 0;\n\n\tibmasm_exec_command(sp, command);\n\tibmasm_wait_for_response(command, IBMASM_CMD_TIMEOUT_NORMAL);\n\n\tif (command->status != IBMASM_CMD_COMPLETE)\n\t\tresult = -ENODEV;\n\n\tcommand_put(command);\n\n\treturn result;\n}\n\nstruct os_state_command {\n\tstruct dot_command_header\theader;\n\tunsigned char\t\t\tcommand[3];\n\tunsigned char\t\t\tdata;\n};\n\n \nint ibmasm_send_os_state(struct service_processor *sp, int os_state)\n{\n\tstruct command *cmd;\n\tstruct os_state_command *os_state_cmd;\n\tint result = 0;\n\n\tcmd = ibmasm_new_command(sp, sizeof(struct os_state_command));\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tos_state_cmd = (struct os_state_command *)cmd->buffer;\n\tos_state_cmd->header.type\t\t= sp_write;\n\tos_state_cmd->header.command_size\t= 3;\n\tos_state_cmd->header.data_size\t\t= 1;\n\tos_state_cmd->header.status\t\t= 0;\n\tos_state_cmd->command[0]\t\t= 4;\n\tos_state_cmd->command[1]\t\t= 3;\n\tos_state_cmd->command[2]\t\t= 6;\n\tos_state_cmd->data\t\t\t= os_state;\n\n\tibmasm_exec_command(sp, cmd);\n\tibmasm_wait_for_response(cmd, IBMASM_CMD_TIMEOUT_NORMAL);\n\n\tif (cmd->status != IBMASM_CMD_COMPLETE)\n\t\tresult = -ENODEV;\n\n\tcommand_put(cmd);\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}