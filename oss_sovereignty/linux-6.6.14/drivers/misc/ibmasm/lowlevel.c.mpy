{
  "module_name": "lowlevel.c",
  "hash_id": "7367895998595169db3ffeffcc557babc2abde3b6fce125e5ee0083a3176dcf2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ibmasm/lowlevel.c",
  "human_readable_source": "\n \n\n#include \"ibmasm.h\"\n#include \"lowlevel.h\"\n#include \"i2o.h\"\n#include \"dot_command.h\"\n#include \"remote.h\"\n\nstatic struct i2o_header header = I2O_HEADER_TEMPLATE;\n\n\nint ibmasm_send_i2o_message(struct service_processor *sp)\n{\n\tu32 mfa;\n\tunsigned int command_size;\n\tstruct i2o_message *message;\n\tstruct command *command = sp->current_command;\n\n\tmfa = get_mfa_inbound(sp->base_address);\n\tif (!mfa)\n\t\treturn 1;\n\n\tcommand_size = get_dot_command_size(command->buffer);\n\theader.message_size = outgoing_message_size(command_size);\n\n\tmessage = get_i2o_message(sp->base_address, mfa);\n\n\tmemcpy_toio(&message->header, &header, sizeof(struct i2o_header));\n\tmemcpy_toio(&message->data, command->buffer, command_size);\n\n\tset_mfa_inbound(sp->base_address, mfa);\n\n\treturn 0;\n}\n\nirqreturn_t ibmasm_interrupt_handler(int irq, void * dev_id)\n{\n\tu32\tmfa;\n\tstruct service_processor *sp = (struct service_processor *)dev_id;\n\tvoid __iomem *base_address = sp->base_address;\n\tchar tsbuf[32];\n\n\tif (!sp_interrupt_pending(base_address))\n\t\treturn IRQ_NONE;\n\n\tdbg(\"respond to interrupt at %s\\n\", get_timestamp(tsbuf));\n\n\tif (mouse_interrupt_pending(sp)) {\n\t\tibmasm_handle_mouse_interrupt(sp);\n\t\tclear_mouse_interrupt(sp);\n\t}\n\n\tmfa = get_mfa_outbound(base_address);\n\tif (valid_mfa(mfa)) {\n\t\tstruct i2o_message *msg = get_i2o_message(base_address, mfa);\n\t\tibmasm_receive_message(sp, &msg->data, incoming_data_size(msg));\n\t} else\n\t\tdbg(\"didn't get a valid MFA\\n\");\n\n\tset_mfa_outbound(base_address, mfa);\n\tdbg(\"finished interrupt at   %s\\n\", get_timestamp(tsbuf));\n\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}