{
  "module_name": "lowlevel.h",
  "hash_id": "d01e0cde2027f905c0bb298bda22fe85a824e7a4c6a9668cf41f6b66af3e557c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ibmasm/lowlevel.h",
  "human_readable_source": " \n \n\n \n\n#ifndef __IBMASM_CONDOR_H__\n#define __IBMASM_CONDOR_H__\n\n#include <asm/io.h>\n\n#define VENDORID_IBM\t0x1014\n#define DEVICEID_RSA\t0x010F\n\n#define GET_MFA_ADDR(x)  (x & 0xFFFFFF00)\n\n#define MAILBOX_FULL(x)  (x & 0x00000001)\n\n#define NO_MFAS_AVAILABLE     0xFFFFFFFF\n\n\n#define INBOUND_QUEUE_PORT   0x40   \n#define OUTBOUND_QUEUE_PORT  0x44   \n\n#define SP_INTR_MASK\t0x00000008\n#define UART_INTR_MASK\t0x00000010\n\n#define INTR_STATUS_REGISTER   0x13A0\n#define INTR_CONTROL_REGISTER  0x13A4\n\n#define SCOUT_COM_A_BASE         0x0000\n#define SCOUT_COM_B_BASE         0x0100\n#define SCOUT_COM_C_BASE         0x0200\n#define SCOUT_COM_D_BASE         0x0300\n\nstatic inline int sp_interrupt_pending(void __iomem *base_address)\n{\n\treturn SP_INTR_MASK & readl(base_address + INTR_STATUS_REGISTER);\n}\n\nstatic inline int uart_interrupt_pending(void __iomem *base_address)\n{\n\treturn UART_INTR_MASK & readl(base_address + INTR_STATUS_REGISTER);\n}\n\nstatic inline void ibmasm_enable_interrupts(void __iomem *base_address, int mask)\n{\n\tvoid __iomem *ctrl_reg = base_address + INTR_CONTROL_REGISTER;\n\twritel( readl(ctrl_reg) & ~mask, ctrl_reg);\n}\n\nstatic inline void ibmasm_disable_interrupts(void __iomem *base_address, int mask)\n{\n\tvoid __iomem *ctrl_reg = base_address + INTR_CONTROL_REGISTER;\n\twritel( readl(ctrl_reg) | mask, ctrl_reg);\n}\n\nstatic inline void enable_sp_interrupts(void __iomem *base_address)\n{\n\tibmasm_enable_interrupts(base_address, SP_INTR_MASK);\n}\n\nstatic inline void disable_sp_interrupts(void __iomem *base_address)\n{\n\tibmasm_disable_interrupts(base_address, SP_INTR_MASK);\n}\n\nstatic inline void enable_uart_interrupts(void __iomem *base_address)\n{\n\tibmasm_enable_interrupts(base_address, UART_INTR_MASK);\n}\n\nstatic inline void disable_uart_interrupts(void __iomem *base_address)\n{\n\tibmasm_disable_interrupts(base_address, UART_INTR_MASK);\n}\n\n#define valid_mfa(mfa)\t( (mfa) != NO_MFAS_AVAILABLE )\n\nstatic inline u32 get_mfa_outbound(void __iomem *base_address)\n{\n\tint retry;\n\tu32 mfa;\n\n\tfor (retry=0; retry<=10; retry++) {\n\t\tmfa = readl(base_address + OUTBOUND_QUEUE_PORT);\n\t\tif (valid_mfa(mfa))\n\t\t\tbreak;\n\t}\n\treturn mfa;\n}\n\nstatic inline void set_mfa_outbound(void __iomem *base_address, u32 mfa)\n{\n\twritel(mfa, base_address + OUTBOUND_QUEUE_PORT);\n}\n\nstatic inline u32 get_mfa_inbound(void __iomem *base_address)\n{\n\tu32 mfa = readl(base_address + INBOUND_QUEUE_PORT);\n\n\tif (MAILBOX_FULL(mfa))\n\t\treturn 0;\n\n\treturn mfa;\n}\n\nstatic inline void set_mfa_inbound(void __iomem *base_address, u32 mfa)\n{\n\twritel(mfa, base_address + INBOUND_QUEUE_PORT);\n}\n\nstatic inline struct i2o_message *get_i2o_message(void __iomem *base_address, u32 mfa)\n{\n\treturn (struct i2o_message *)(GET_MFA_ADDR(mfa) + base_address);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}