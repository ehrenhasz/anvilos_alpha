{
  "module_name": "ibmasm.h",
  "hash_id": "ac180d9e15b3d7cb1fe8b1005913e88f0b42244cdca8c258c7ee4d1bbbf21a94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ibmasm/ibmasm.h",
  "human_readable_source": " \n\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/kref.h>\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/time64.h>\n\n \n#define DRIVER_NAME\t\"ibmasm\"\n#define DRIVER_VERSION  \"1.0\"\n#define DRIVER_AUTHOR   \"Max Asbock <masbock@us.ibm.com>, Vernon Mauery <vernux@us.ibm.com>\"\n#define DRIVER_DESC     \"IBM ASM Service Processor Driver\"\n\n#define err(msg) printk(KERN_ERR \"%s: \" msg \"\\n\", DRIVER_NAME)\n#define info(msg) printk(KERN_INFO \"%s: \" msg \"\\n\", DRIVER_NAME)\n\nextern int ibmasm_debug;\n#define dbg(STR, ARGS...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (ibmasm_debug)\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG STR , ##ARGS);\t\\\n\t} while (0)\n\nstatic inline char *get_timestamp(char *buf)\n{\n\tstruct timespec64 now;\n\n\tktime_get_real_ts64(&now);\n\tsprintf(buf, \"%llu.%.08lu\", (long long)now.tv_sec,\n\t\t\t\tnow.tv_nsec / NSEC_PER_USEC);\n\treturn buf;\n}\n\n#define IBMASM_CMD_PENDING\t0\n#define IBMASM_CMD_COMPLETE\t1\n#define IBMASM_CMD_FAILED\t2\n\n#define IBMASM_CMD_TIMEOUT_NORMAL\t45\n#define IBMASM_CMD_TIMEOUT_EXTRA\t240\n\n#define IBMASM_CMD_MAX_BUFFER_SIZE\t0x8000\n\n#define REVERSE_HEARTBEAT_TIMEOUT\t120\n\n#define HEARTBEAT_BUFFER_SIZE\t\t0x400\n\n#ifdef IA64\n#define IBMASM_DRIVER_VPD \"Lin64 6.08      \"\n#else\n#define IBMASM_DRIVER_VPD \"Lin32 6.08      \"\n#endif\n\n#define SYSTEM_STATE_OS_UP      5\n#define SYSTEM_STATE_OS_DOWN    4\n\n#define IBMASM_NAME_SIZE\t16\n\n#define IBMASM_NUM_EVENTS\t10\n#define IBMASM_EVENT_MAX_SIZE\t2048u\n\n\nstruct command {\n\tstruct list_head\tqueue_node;\n\twait_queue_head_t\twait;\n\tunsigned char\t\t*buffer;\n\tsize_t\t\t\tbuffer_size;\n\tint\t\t\tstatus;\n\tstruct kref\t\tkref;\n\tspinlock_t\t\t*lock;\n};\n#define to_command(c) container_of(c, struct command, kref)\n\nvoid ibmasm_free_command(struct kref *kref);\nstatic inline void command_put(struct command *cmd)\n{\n\tunsigned long flags;\n\tspinlock_t *lock = cmd->lock;\n\n\tspin_lock_irqsave(lock, flags);\n\tkref_put(&cmd->kref, ibmasm_free_command);\n\tspin_unlock_irqrestore(lock, flags);\n}\n\nstatic inline void command_get(struct command *cmd)\n{\n\tkref_get(&cmd->kref);\n}\n\n\nstruct ibmasm_event {\n\tunsigned int\tserial_number;\n\tunsigned int\tdata_size;\n\tunsigned char\tdata[IBMASM_EVENT_MAX_SIZE];\n};\n\nstruct event_buffer {\n\tstruct ibmasm_event\tevents[IBMASM_NUM_EVENTS];\n\tunsigned int\t\tnext_serial_number;\n\tunsigned int\t\tnext_index;\n\tstruct list_head\treaders;\n};\n\nstruct event_reader {\n\tint\t\t\tcancelled;\n\tunsigned int\t\tnext_serial_number;\n\twait_queue_head_t\twait;\n\tstruct list_head\tnode;\n\tunsigned int\t\tdata_size;\n\tunsigned char\t\tdata[IBMASM_EVENT_MAX_SIZE];\n};\n\nstruct reverse_heartbeat {\n\twait_queue_head_t\twait;\n\tunsigned int\t\tstopped;\n};\n\nstruct ibmasm_remote {\n\tstruct input_dev *keybd_dev;\n\tstruct input_dev *mouse_dev;\n};\n\nstruct service_processor {\n\tstruct list_head\tnode;\n\tspinlock_t\t\tlock;\n\tvoid __iomem\t\t*base_address;\n\tunsigned int\t\tirq;\n\tstruct command\t\t*current_command;\n\tstruct command\t\t*heartbeat;\n\tstruct list_head\tcommand_queue;\n\tstruct event_buffer\t*event_buffer;\n\tchar\t\t\tdirname[IBMASM_NAME_SIZE];\n\tchar\t\t\tdevname[IBMASM_NAME_SIZE];\n\tunsigned int\t\tnumber;\n\tstruct ibmasm_remote\tremote;\n\tint\t\t\tserial_line;\n\tstruct device\t\t*dev;\n};\n\n \nstruct command *ibmasm_new_command(struct service_processor *sp, size_t buffer_size);\nvoid ibmasm_exec_command(struct service_processor *sp, struct command *cmd);\nvoid ibmasm_wait_for_response(struct command *cmd, int timeout);\nvoid ibmasm_receive_command_response(struct service_processor *sp, void *response,  size_t size);\n\n \nint ibmasm_event_buffer_init(struct service_processor *sp);\nvoid ibmasm_event_buffer_exit(struct service_processor *sp);\nvoid ibmasm_receive_event(struct service_processor *sp, void *data,  unsigned int data_size);\nvoid ibmasm_event_reader_register(struct service_processor *sp, struct event_reader *reader);\nvoid ibmasm_event_reader_unregister(struct service_processor *sp, struct event_reader *reader);\nint ibmasm_get_next_event(struct service_processor *sp, struct event_reader *reader);\nvoid ibmasm_cancel_next_event(struct event_reader *reader);\n\n \nvoid ibmasm_register_panic_notifier(void);\nvoid ibmasm_unregister_panic_notifier(void);\nint ibmasm_heartbeat_init(struct service_processor *sp);\nvoid ibmasm_heartbeat_exit(struct service_processor *sp);\nvoid ibmasm_receive_heartbeat(struct service_processor *sp,  void *message, size_t size);\n\n \nvoid ibmasm_init_reverse_heartbeat(struct service_processor *sp, struct reverse_heartbeat *rhb);\nint ibmasm_start_reverse_heartbeat(struct service_processor *sp, struct reverse_heartbeat *rhb);\nvoid ibmasm_stop_reverse_heartbeat(struct reverse_heartbeat *rhb);\n\n \nvoid ibmasm_receive_message(struct service_processor *sp, void *data, int data_size);\nint ibmasm_send_driver_vpd(struct service_processor *sp);\nint ibmasm_send_os_state(struct service_processor *sp, int os_state);\n\n \nint ibmasm_send_i2o_message(struct service_processor *sp);\nirqreturn_t ibmasm_interrupt_handler(int irq, void * dev_id);\n\n \nvoid ibmasm_handle_mouse_interrupt(struct service_processor *sp);\nint ibmasm_init_remote_input_dev(struct service_processor *sp);\nvoid ibmasm_free_remote_input_dev(struct service_processor *sp);\n\n \nint ibmasmfs_register(void);\nvoid ibmasmfs_unregister(void);\nvoid ibmasmfs_add_sp(struct service_processor *sp);\n\n \n#if IS_ENABLED(CONFIG_SERIAL_8250)\nvoid ibmasm_register_uart(struct service_processor *sp);\nvoid ibmasm_unregister_uart(struct service_processor *sp);\n#else\n#define ibmasm_register_uart(sp)\tdo { } while(0)\n#define ibmasm_unregister_uart(sp)\tdo { } while(0)\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}