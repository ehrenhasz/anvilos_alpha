{
  "module_name": "command.c",
  "hash_id": "a272ed7f7587687f399e8c3093941e66df67846467ee10fcc3ba8f9c5ba074f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ibmasm/command.c",
  "human_readable_source": "\n\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include \"ibmasm.h\"\n#include \"lowlevel.h\"\n\nstatic void exec_next_command(struct service_processor *sp);\n\nstatic atomic_t command_count = ATOMIC_INIT(0);\n\nstruct command *ibmasm_new_command(struct service_processor *sp, size_t buffer_size)\n{\n\tstruct command *cmd;\n\n\tif (buffer_size > IBMASM_CMD_MAX_BUFFER_SIZE)\n\t\treturn NULL;\n\n\tcmd = kzalloc(sizeof(struct command), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn NULL;\n\n\n\tcmd->buffer = kzalloc(buffer_size, GFP_KERNEL);\n\tif (cmd->buffer == NULL) {\n\t\tkfree(cmd);\n\t\treturn NULL;\n\t}\n\tcmd->buffer_size = buffer_size;\n\n\tkref_init(&cmd->kref);\n\tcmd->lock = &sp->lock;\n\n\tcmd->status = IBMASM_CMD_PENDING;\n\tinit_waitqueue_head(&cmd->wait);\n\tINIT_LIST_HEAD(&cmd->queue_node);\n\n\tatomic_inc(&command_count);\n\tdbg(\"command count: %d\\n\", atomic_read(&command_count));\n\n\treturn cmd;\n}\n\nvoid ibmasm_free_command(struct kref *kref)\n{\n\tstruct command *cmd = to_command(kref);\n\n\tlist_del(&cmd->queue_node);\n\tatomic_dec(&command_count);\n\tdbg(\"command count: %d\\n\", atomic_read(&command_count));\n\tkfree(cmd->buffer);\n\tkfree(cmd);\n}\n\nstatic void enqueue_command(struct service_processor *sp, struct command *cmd)\n{\n\tlist_add_tail(&cmd->queue_node, &sp->command_queue);\n}\n\nstatic struct command *dequeue_command(struct service_processor *sp)\n{\n\tstruct command *cmd;\n\tstruct list_head *next;\n\n\tif (list_empty(&sp->command_queue))\n\t\treturn NULL;\n\n\tnext = sp->command_queue.next;\n\tlist_del_init(next);\n\tcmd = list_entry(next, struct command, queue_node);\n\n\treturn cmd;\n}\n\nstatic inline void do_exec_command(struct service_processor *sp)\n{\n\tchar tsbuf[32];\n\n\tdbg(\"%s:%d at %s\\n\", __func__, __LINE__, get_timestamp(tsbuf));\n\n\tif (ibmasm_send_i2o_message(sp)) {\n\t\tsp->current_command->status = IBMASM_CMD_FAILED;\n\t\twake_up(&sp->current_command->wait);\n\t\tcommand_put(sp->current_command);\n\t\texec_next_command(sp);\n\t}\n}\n\n \nvoid ibmasm_exec_command(struct service_processor *sp, struct command *cmd)\n{\n\tunsigned long flags;\n\tchar tsbuf[32];\n\n\tdbg(\"%s:%d at %s\\n\", __func__, __LINE__, get_timestamp(tsbuf));\n\n\tspin_lock_irqsave(&sp->lock, flags);\n\n\tif (!sp->current_command) {\n\t\tsp->current_command = cmd;\n\t\tcommand_get(sp->current_command);\n\t\tspin_unlock_irqrestore(&sp->lock, flags);\n\t\tdo_exec_command(sp);\n\t} else {\n\t\tenqueue_command(sp, cmd);\n\t\tspin_unlock_irqrestore(&sp->lock, flags);\n\t}\n}\n\nstatic void exec_next_command(struct service_processor *sp)\n{\n\tunsigned long flags;\n\tchar tsbuf[32];\n\n\tdbg(\"%s:%d at %s\\n\", __func__, __LINE__, get_timestamp(tsbuf));\n\n\tspin_lock_irqsave(&sp->lock, flags);\n\tsp->current_command = dequeue_command(sp);\n\tif (sp->current_command) {\n\t\tcommand_get(sp->current_command);\n\t\tspin_unlock_irqrestore(&sp->lock, flags);\n\t\tdo_exec_command(sp);\n\t} else {\n\t\tspin_unlock_irqrestore(&sp->lock, flags);\n\t}\n}\n\n \nvoid ibmasm_wait_for_response(struct command *cmd, int timeout)\n{\n\twait_event_interruptible_timeout(cmd->wait,\n\t\t\t\tcmd->status == IBMASM_CMD_COMPLETE ||\n\t\t\t\tcmd->status == IBMASM_CMD_FAILED,\n\t\t\t\ttimeout * HZ);\n}\n\n \nvoid ibmasm_receive_command_response(struct service_processor *sp, void *response, size_t size)\n{\n\tstruct command *cmd = sp->current_command;\n\n\tif (!sp->current_command)\n\t\treturn;\n\n\tmemcpy_fromio(cmd->buffer, response, min(size, cmd->buffer_size));\n\tcmd->status = IBMASM_CMD_COMPLETE;\n\twake_up(&sp->current_command->wait);\n\tcommand_put(sp->current_command);\n\texec_next_command(sp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}