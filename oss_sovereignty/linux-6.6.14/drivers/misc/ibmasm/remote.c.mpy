{
  "module_name": "remote.c",
  "hash_id": "9cef701539814fa66bfedeb609962e4c4c15571abdbc57672296097694ffc006",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ibmasm/remote.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/pci.h>\n#include \"ibmasm.h\"\n#include \"remote.h\"\n\n#define MOUSE_X_MAX\t1600\n#define MOUSE_Y_MAX\t1200\n\nstatic const unsigned short xlate_high[XLATE_SIZE] = {\n\t[KEY_SYM_ENTER & 0xff] = KEY_ENTER,\n\t[KEY_SYM_KPSLASH & 0xff] = KEY_KPSLASH,\n\t[KEY_SYM_KPSTAR & 0xff] = KEY_KPASTERISK,\n\t[KEY_SYM_KPMINUS & 0xff] = KEY_KPMINUS,\n\t[KEY_SYM_KPDOT & 0xff] = KEY_KPDOT,\n\t[KEY_SYM_KPPLUS & 0xff] = KEY_KPPLUS,\n\t[KEY_SYM_KP0 & 0xff] = KEY_KP0,\n\t[KEY_SYM_KP1 & 0xff] = KEY_KP1,\n\t[KEY_SYM_KP2 & 0xff] = KEY_KP2, [KEY_SYM_KPDOWN & 0xff] = KEY_KP2,\n\t[KEY_SYM_KP3 & 0xff] = KEY_KP3,\n\t[KEY_SYM_KP4 & 0xff] = KEY_KP4, [KEY_SYM_KPLEFT & 0xff] = KEY_KP4,\n\t[KEY_SYM_KP5 & 0xff] = KEY_KP5,\n\t[KEY_SYM_KP6 & 0xff] = KEY_KP6, [KEY_SYM_KPRIGHT & 0xff] = KEY_KP6,\n\t[KEY_SYM_KP7 & 0xff] = KEY_KP7,\n\t[KEY_SYM_KP8 & 0xff] = KEY_KP8, [KEY_SYM_KPUP & 0xff] = KEY_KP8,\n\t[KEY_SYM_KP9 & 0xff] = KEY_KP9,\n\t[KEY_SYM_BK_SPC & 0xff] = KEY_BACKSPACE,\n\t[KEY_SYM_TAB & 0xff] = KEY_TAB,\n\t[KEY_SYM_CTRL & 0xff] = KEY_LEFTCTRL,\n\t[KEY_SYM_ALT & 0xff] = KEY_LEFTALT,\n\t[KEY_SYM_INSERT & 0xff] = KEY_INSERT,\n\t[KEY_SYM_DELETE & 0xff] = KEY_DELETE,\n\t[KEY_SYM_SHIFT & 0xff] = KEY_LEFTSHIFT,\n\t[KEY_SYM_UARROW & 0xff] = KEY_UP,\n\t[KEY_SYM_DARROW & 0xff] = KEY_DOWN,\n\t[KEY_SYM_LARROW & 0xff] = KEY_LEFT,\n\t[KEY_SYM_RARROW & 0xff] = KEY_RIGHT,\n\t[KEY_SYM_ESCAPE & 0xff] = KEY_ESC,\n        [KEY_SYM_PAGEUP & 0xff] = KEY_PAGEUP,\n        [KEY_SYM_PAGEDOWN & 0xff] = KEY_PAGEDOWN,\n        [KEY_SYM_HOME & 0xff] = KEY_HOME,\n        [KEY_SYM_END & 0xff] = KEY_END,\n\t[KEY_SYM_F1 & 0xff] = KEY_F1,\n\t[KEY_SYM_F2 & 0xff] = KEY_F2,\n\t[KEY_SYM_F3 & 0xff] = KEY_F3,\n\t[KEY_SYM_F4 & 0xff] = KEY_F4,\n\t[KEY_SYM_F5 & 0xff] = KEY_F5,\n\t[KEY_SYM_F6 & 0xff] = KEY_F6,\n\t[KEY_SYM_F7 & 0xff] = KEY_F7,\n\t[KEY_SYM_F8 & 0xff] = KEY_F8,\n\t[KEY_SYM_F9 & 0xff] = KEY_F9,\n\t[KEY_SYM_F10 & 0xff] = KEY_F10,\n\t[KEY_SYM_F11 & 0xff] = KEY_F11,\n\t[KEY_SYM_F12 & 0xff] = KEY_F12,\n\t[KEY_SYM_CAP_LOCK & 0xff] = KEY_CAPSLOCK,\n\t[KEY_SYM_NUM_LOCK & 0xff] = KEY_NUMLOCK,\n\t[KEY_SYM_SCR_LOCK & 0xff] = KEY_SCROLLLOCK,\n};\n\nstatic const unsigned short xlate[XLATE_SIZE] = {\n\t[NO_KEYCODE] = KEY_RESERVED,\n\t[KEY_SYM_SPACE] = KEY_SPACE,\n\t[KEY_SYM_TILDE] = KEY_GRAVE,        [KEY_SYM_BKTIC] = KEY_GRAVE,\n\t[KEY_SYM_ONE] = KEY_1,              [KEY_SYM_BANG] = KEY_1,\n\t[KEY_SYM_TWO] = KEY_2,              [KEY_SYM_AT] = KEY_2,\n\t[KEY_SYM_THREE] = KEY_3,            [KEY_SYM_POUND] = KEY_3,\n\t[KEY_SYM_FOUR] = KEY_4,             [KEY_SYM_DOLLAR] = KEY_4,\n\t[KEY_SYM_FIVE] = KEY_5,             [KEY_SYM_PERCENT] = KEY_5,\n\t[KEY_SYM_SIX] = KEY_6,              [KEY_SYM_CARAT] = KEY_6,\n\t[KEY_SYM_SEVEN] = KEY_7,            [KEY_SYM_AMPER] = KEY_7,\n\t[KEY_SYM_EIGHT] = KEY_8,            [KEY_SYM_STAR] = KEY_8,\n\t[KEY_SYM_NINE] = KEY_9,             [KEY_SYM_LPAREN] = KEY_9,\n\t[KEY_SYM_ZERO] = KEY_0,             [KEY_SYM_RPAREN] = KEY_0,\n\t[KEY_SYM_MINUS] = KEY_MINUS,        [KEY_SYM_USCORE] = KEY_MINUS,\n\t[KEY_SYM_EQUAL] = KEY_EQUAL,        [KEY_SYM_PLUS] = KEY_EQUAL,\n\t[KEY_SYM_LBRKT] = KEY_LEFTBRACE,    [KEY_SYM_LCURLY] = KEY_LEFTBRACE,\n\t[KEY_SYM_RBRKT] = KEY_RIGHTBRACE,   [KEY_SYM_RCURLY] = KEY_RIGHTBRACE,\n\t[KEY_SYM_SLASH] = KEY_BACKSLASH,    [KEY_SYM_PIPE] = KEY_BACKSLASH,\n\t[KEY_SYM_TIC] = KEY_APOSTROPHE,     [KEY_SYM_QUOTE] = KEY_APOSTROPHE,\n\t[KEY_SYM_SEMIC] = KEY_SEMICOLON,    [KEY_SYM_COLON] = KEY_SEMICOLON,\n\t[KEY_SYM_COMMA] = KEY_COMMA,        [KEY_SYM_LT] = KEY_COMMA,\n\t[KEY_SYM_PERIOD] = KEY_DOT,         [KEY_SYM_GT] = KEY_DOT,\n\t[KEY_SYM_BSLASH] = KEY_SLASH,       [KEY_SYM_QMARK] = KEY_SLASH,\n\t[KEY_SYM_A] = KEY_A,                [KEY_SYM_a] = KEY_A,\n\t[KEY_SYM_B] = KEY_B,                [KEY_SYM_b] = KEY_B,\n\t[KEY_SYM_C] = KEY_C,                [KEY_SYM_c] = KEY_C,\n\t[KEY_SYM_D] = KEY_D,                [KEY_SYM_d] = KEY_D,\n\t[KEY_SYM_E] = KEY_E,                [KEY_SYM_e] = KEY_E,\n\t[KEY_SYM_F] = KEY_F,                [KEY_SYM_f] = KEY_F,\n\t[KEY_SYM_G] = KEY_G,                [KEY_SYM_g] = KEY_G,\n\t[KEY_SYM_H] = KEY_H,                [KEY_SYM_h] = KEY_H,\n\t[KEY_SYM_I] = KEY_I,                [KEY_SYM_i] = KEY_I,\n\t[KEY_SYM_J] = KEY_J,                [KEY_SYM_j] = KEY_J,\n\t[KEY_SYM_K] = KEY_K,                [KEY_SYM_k] = KEY_K,\n\t[KEY_SYM_L] = KEY_L,                [KEY_SYM_l] = KEY_L,\n\t[KEY_SYM_M] = KEY_M,                [KEY_SYM_m] = KEY_M,\n\t[KEY_SYM_N] = KEY_N,                [KEY_SYM_n] = KEY_N,\n\t[KEY_SYM_O] = KEY_O,                [KEY_SYM_o] = KEY_O,\n\t[KEY_SYM_P] = KEY_P,                [KEY_SYM_p] = KEY_P,\n\t[KEY_SYM_Q] = KEY_Q,                [KEY_SYM_q] = KEY_Q,\n\t[KEY_SYM_R] = KEY_R,                [KEY_SYM_r] = KEY_R,\n\t[KEY_SYM_S] = KEY_S,                [KEY_SYM_s] = KEY_S,\n\t[KEY_SYM_T] = KEY_T,                [KEY_SYM_t] = KEY_T,\n\t[KEY_SYM_U] = KEY_U,                [KEY_SYM_u] = KEY_U,\n\t[KEY_SYM_V] = KEY_V,                [KEY_SYM_v] = KEY_V,\n\t[KEY_SYM_W] = KEY_W,                [KEY_SYM_w] = KEY_W,\n\t[KEY_SYM_X] = KEY_X,                [KEY_SYM_x] = KEY_X,\n\t[KEY_SYM_Y] = KEY_Y,                [KEY_SYM_y] = KEY_Y,\n\t[KEY_SYM_Z] = KEY_Z,                [KEY_SYM_z] = KEY_Z,\n};\n\nstatic void print_input(struct remote_input *input)\n{\n\tif (input->type == INPUT_TYPE_MOUSE) {\n\t\tunsigned char buttons = input->mouse_buttons;\n\t\tdbg(\"remote mouse movement: (x,y)=(%d,%d)%s%s%s%s\\n\",\n\t\t\tinput->data.mouse.x, input->data.mouse.y,\n\t\t\t(buttons) ? \" -- buttons:\" : \"\",\n\t\t\t(buttons & REMOTE_BUTTON_LEFT) ? \"left \" : \"\",\n\t\t\t(buttons & REMOTE_BUTTON_MIDDLE) ? \"middle \" : \"\",\n\t\t\t(buttons & REMOTE_BUTTON_RIGHT) ? \"right\" : \"\"\n\t\t      );\n\t} else {\n\t\tdbg(\"remote keypress (code, flag, down):\"\n\t\t\t   \"%d (0x%x) [0x%x] [0x%x]\\n\",\n\t\t\t\tinput->data.keyboard.key_code,\n\t\t\t\tinput->data.keyboard.key_code,\n\t\t\t\tinput->data.keyboard.key_flag,\n\t\t\t\tinput->data.keyboard.key_down\n\t\t      );\n\t}\n}\n\nstatic void send_mouse_event(struct input_dev *dev, struct remote_input *input)\n{\n\tunsigned char buttons = input->mouse_buttons;\n\n\tinput_report_abs(dev, ABS_X, input->data.mouse.x);\n\tinput_report_abs(dev, ABS_Y, input->data.mouse.y);\n\tinput_report_key(dev, BTN_LEFT, buttons & REMOTE_BUTTON_LEFT);\n\tinput_report_key(dev, BTN_MIDDLE, buttons & REMOTE_BUTTON_MIDDLE);\n\tinput_report_key(dev, BTN_RIGHT, buttons & REMOTE_BUTTON_RIGHT);\n\tinput_sync(dev);\n}\n\nstatic void send_keyboard_event(struct input_dev *dev,\n\t\tstruct remote_input *input)\n{\n\tunsigned int key;\n\tunsigned short code = input->data.keyboard.key_code;\n\n\tif (code & 0xff00)\n\t\tkey = xlate_high[code & 0xff];\n\telse\n\t\tkey = xlate[code];\n\tinput_report_key(dev, key, input->data.keyboard.key_down);\n\tinput_sync(dev);\n}\n\nvoid ibmasm_handle_mouse_interrupt(struct service_processor *sp)\n{\n\tunsigned long reader;\n\tunsigned long writer;\n\tstruct remote_input input;\n\n\treader = get_queue_reader(sp);\n\twriter = get_queue_writer(sp);\n\n\twhile (reader != writer) {\n\t\tmemcpy_fromio(&input, get_queue_entry(sp, reader),\n\t\t\t\tsizeof(struct remote_input));\n\n\t\tprint_input(&input);\n\t\tif (input.type == INPUT_TYPE_MOUSE) {\n\t\t\tsend_mouse_event(sp->remote.mouse_dev, &input);\n\t\t} else if (input.type == INPUT_TYPE_KEYBOARD) {\n\t\t\tsend_keyboard_event(sp->remote.keybd_dev, &input);\n\t\t} else\n\t\t\tbreak;\n\n\t\treader = advance_queue_reader(sp, reader);\n\t\twriter = get_queue_writer(sp);\n\t}\n}\n\nint ibmasm_init_remote_input_dev(struct service_processor *sp)\n{\n\t \n\tstruct input_dev *mouse_dev, *keybd_dev;\n\tstruct pci_dev *pdev = to_pci_dev(sp->dev);\n\tint error = -ENOMEM;\n\tint i;\n\n\tsp->remote.mouse_dev = mouse_dev = input_allocate_device();\n\tsp->remote.keybd_dev = keybd_dev = input_allocate_device();\n\n\tif (!mouse_dev || !keybd_dev)\n\t\tgoto err_free_devices;\n\n\tmouse_dev->id.bustype = BUS_PCI;\n\tmouse_dev->id.vendor = pdev->vendor;\n\tmouse_dev->id.product = pdev->device;\n\tmouse_dev->id.version = 1;\n\tmouse_dev->dev.parent = sp->dev;\n\tmouse_dev->evbit[0]  = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tmouse_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |\n\t\tBIT_MASK(BTN_RIGHT) | BIT_MASK(BTN_MIDDLE);\n\tset_bit(BTN_TOUCH, mouse_dev->keybit);\n\tmouse_dev->name = \"ibmasm RSA I remote mouse\";\n\tinput_set_abs_params(mouse_dev, ABS_X, 0, MOUSE_X_MAX, 0, 0);\n\tinput_set_abs_params(mouse_dev, ABS_Y, 0, MOUSE_Y_MAX, 0, 0);\n\n\tkeybd_dev->id.bustype = BUS_PCI;\n\tkeybd_dev->id.vendor = pdev->vendor;\n\tkeybd_dev->id.product = pdev->device;\n\tkeybd_dev->id.version = 2;\n\tkeybd_dev->dev.parent = sp->dev;\n\tkeybd_dev->evbit[0]  = BIT_MASK(EV_KEY);\n\tkeybd_dev->name = \"ibmasm RSA I remote keyboard\";\n\n\tfor (i = 0; i < XLATE_SIZE; i++) {\n\t\tif (xlate_high[i])\n\t\t\tset_bit(xlate_high[i], keybd_dev->keybit);\n\t\tif (xlate[i])\n\t\t\tset_bit(xlate[i], keybd_dev->keybit);\n\t}\n\n\terror = input_register_device(mouse_dev);\n\tif (error)\n\t\tgoto err_free_devices;\n\n\terror = input_register_device(keybd_dev);\n\tif (error)\n\t\tgoto err_unregister_mouse_dev;\n\n\tenable_mouse_interrupts(sp);\n\n\tprintk(KERN_INFO \"ibmasm remote responding to events on RSA card %d\\n\", sp->number);\n\n\treturn 0;\n\n err_unregister_mouse_dev:\n\tinput_unregister_device(mouse_dev);\n\tmouse_dev = NULL;  \n err_free_devices:\n\tinput_free_device(mouse_dev);\n\tinput_free_device(keybd_dev);\n\n\treturn error;\n}\n\nvoid ibmasm_free_remote_input_dev(struct service_processor *sp)\n{\n\tdisable_mouse_interrupts(sp);\n\tinput_unregister_device(sp->remote.mouse_dev);\n\tinput_unregister_device(sp->remote.keybd_dev);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}