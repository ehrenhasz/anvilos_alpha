{
  "module_name": "hpilo.c",
  "hash_id": "affc49b4647ef0e751dab963bfc492bff9dfca3db6a273eadd0dcc68240777be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/hpilo.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/device.h>\n#include <linux/file.h>\n#include <linux/cdev.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include \"hpilo.h\"\n\nstatic const struct class ilo_class = {\n\t.name = \"iLO\",\n};\nstatic unsigned int ilo_major;\nstatic unsigned int max_ccb = 16;\nstatic char ilo_hwdev[MAX_ILO_DEV];\nstatic const struct pci_device_id ilo_blacklist[] = {\n\t \n\t{PCI_DEVICE_SUB(PCI_VENDOR_ID_HP, 0x3307, PCI_VENDOR_ID_HP, 0x1979)},\n\t \n\t{PCI_DEVICE_SUB(PCI_VENDOR_ID_HP, 0x3307, PCI_VENDOR_ID_HP_3PAR, 0x0289)},\n\t{}\n};\n\nstatic inline int get_entry_id(int entry)\n{\n\treturn (entry & ENTRY_MASK_DESCRIPTOR) >> ENTRY_BITPOS_DESCRIPTOR;\n}\n\nstatic inline int get_entry_len(int entry)\n{\n\treturn ((entry & ENTRY_MASK_QWORDS) >> ENTRY_BITPOS_QWORDS) << 3;\n}\n\nstatic inline int mk_entry(int id, int len)\n{\n\tint qlen = len & 7 ? (len >> 3) + 1 : len >> 3;\n\treturn id << ENTRY_BITPOS_DESCRIPTOR | qlen << ENTRY_BITPOS_QWORDS;\n}\n\nstatic inline int desc_mem_sz(int nr_entry)\n{\n\treturn nr_entry << L2_QENTRY_SZ;\n}\n\n \nstatic int fifo_enqueue(struct ilo_hwinfo *hw, char *fifobar, int entry)\n{\n\tstruct fifo *fifo_q = FIFOBARTOHANDLE(fifobar);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&hw->fifo_lock, flags);\n\tif (!(fifo_q->fifobar[(fifo_q->tail + 1) & fifo_q->imask]\n\t      & ENTRY_MASK_O)) {\n\t\tfifo_q->fifobar[fifo_q->tail & fifo_q->imask] |=\n\t\t\t\t(entry & ENTRY_MASK_NOSTATE) | fifo_q->merge;\n\t\tfifo_q->tail += 1;\n\t\tret = 1;\n\t}\n\tspin_unlock_irqrestore(&hw->fifo_lock, flags);\n\n\treturn ret;\n}\n\nstatic int fifo_dequeue(struct ilo_hwinfo *hw, char *fifobar, int *entry)\n{\n\tstruct fifo *fifo_q = FIFOBARTOHANDLE(fifobar);\n\tunsigned long flags;\n\tint ret = 0;\n\tu64 c;\n\n\tspin_lock_irqsave(&hw->fifo_lock, flags);\n\tc = fifo_q->fifobar[fifo_q->head & fifo_q->imask];\n\tif (c & ENTRY_MASK_C) {\n\t\tif (entry)\n\t\t\t*entry = c & ENTRY_MASK_NOSTATE;\n\n\t\tfifo_q->fifobar[fifo_q->head & fifo_q->imask] =\n\t\t\t\t\t\t\t(c | ENTRY_MASK) + 1;\n\t\tfifo_q->head += 1;\n\t\tret = 1;\n\t}\n\tspin_unlock_irqrestore(&hw->fifo_lock, flags);\n\n\treturn ret;\n}\n\nstatic int fifo_check_recv(struct ilo_hwinfo *hw, char *fifobar)\n{\n\tstruct fifo *fifo_q = FIFOBARTOHANDLE(fifobar);\n\tunsigned long flags;\n\tint ret = 0;\n\tu64 c;\n\n\tspin_lock_irqsave(&hw->fifo_lock, flags);\n\tc = fifo_q->fifobar[fifo_q->head & fifo_q->imask];\n\tif (c & ENTRY_MASK_C)\n\t\tret = 1;\n\tspin_unlock_irqrestore(&hw->fifo_lock, flags);\n\n\treturn ret;\n}\n\nstatic int ilo_pkt_enqueue(struct ilo_hwinfo *hw, struct ccb *ccb,\n\t\t\t   int dir, int id, int len)\n{\n\tchar *fifobar;\n\tint entry;\n\n\tif (dir == SENDQ)\n\t\tfifobar = ccb->ccb_u1.send_fifobar;\n\telse\n\t\tfifobar = ccb->ccb_u3.recv_fifobar;\n\n\tentry = mk_entry(id, len);\n\treturn fifo_enqueue(hw, fifobar, entry);\n}\n\nstatic int ilo_pkt_dequeue(struct ilo_hwinfo *hw, struct ccb *ccb,\n\t\t\t   int dir, int *id, int *len, void **pkt)\n{\n\tchar *fifobar, *desc;\n\tint entry = 0, pkt_id = 0;\n\tint ret;\n\n\tif (dir == SENDQ) {\n\t\tfifobar = ccb->ccb_u1.send_fifobar;\n\t\tdesc = ccb->ccb_u2.send_desc;\n\t} else {\n\t\tfifobar = ccb->ccb_u3.recv_fifobar;\n\t\tdesc = ccb->ccb_u4.recv_desc;\n\t}\n\n\tret = fifo_dequeue(hw, fifobar, &entry);\n\tif (ret) {\n\t\tpkt_id = get_entry_id(entry);\n\t\tif (id)\n\t\t\t*id = pkt_id;\n\t\tif (len)\n\t\t\t*len = get_entry_len(entry);\n\t\tif (pkt)\n\t\t\t*pkt = (void *)(desc + desc_mem_sz(pkt_id));\n\t}\n\n\treturn ret;\n}\n\nstatic int ilo_pkt_recv(struct ilo_hwinfo *hw, struct ccb *ccb)\n{\n\tchar *fifobar = ccb->ccb_u3.recv_fifobar;\n\n\treturn fifo_check_recv(hw, fifobar);\n}\n\nstatic inline void doorbell_set(struct ccb *ccb)\n{\n\tiowrite8(1, ccb->ccb_u5.db_base);\n}\n\nstatic inline void doorbell_clr(struct ccb *ccb)\n{\n\tiowrite8(2, ccb->ccb_u5.db_base);\n}\n\nstatic inline int ctrl_set(int l2sz, int idxmask, int desclim)\n{\n\tint active = 0, go = 1;\n\treturn l2sz << CTRL_BITPOS_L2SZ |\n\t       idxmask << CTRL_BITPOS_FIFOINDEXMASK |\n\t       desclim << CTRL_BITPOS_DESCLIMIT |\n\t       active << CTRL_BITPOS_A |\n\t       go << CTRL_BITPOS_G;\n}\n\nstatic void ctrl_setup(struct ccb *ccb, int nr_desc, int l2desc_sz)\n{\n\t \n\tccb->send_ctrl = ctrl_set(l2desc_sz, nr_desc-1, nr_desc-1);\n\tccb->recv_ctrl = ctrl_set(l2desc_sz, nr_desc-1, nr_desc-1);\n}\n\nstatic inline int fifo_sz(int nr_entry)\n{\n\t \n\treturn nr_entry * sizeof(u64) + FIFOHANDLESIZE;\n}\n\nstatic void fifo_setup(void *base_addr, int nr_entry)\n{\n\tstruct fifo *fifo_q = base_addr;\n\tint i;\n\n\t \n\tfifo_q->head = 0;\n\tfifo_q->tail = 0;\n\tfifo_q->reset = 0;\n\tfifo_q->nrents = nr_entry;\n\tfifo_q->imask = nr_entry - 1;\n\tfifo_q->merge = ENTRY_MASK_O;\n\n\tfor (i = 0; i < nr_entry; i++)\n\t\tfifo_q->fifobar[i] = 0;\n}\n\nstatic void ilo_ccb_close(struct pci_dev *pdev, struct ccb_data *data)\n{\n\tstruct ccb *driver_ccb = &data->driver_ccb;\n\tstruct ccb __iomem *device_ccb = data->mapped_ccb;\n\tint retries;\n\n\t \n\tdoorbell_clr(driver_ccb);\n\tiowrite32(ioread32(&device_ccb->send_ctrl) & ~(1 << CTRL_BITPOS_G),\n\t\t  &device_ccb->send_ctrl);\n\tiowrite32(ioread32(&device_ccb->recv_ctrl) & ~(1 << CTRL_BITPOS_G),\n\t\t  &device_ccb->recv_ctrl);\n\n\t \n\tfor (retries = MAX_WAIT; retries > 0; retries--) {\n\t\tdoorbell_set(driver_ccb);\n\t\tudelay(WAIT_TIME);\n\t\tif (!(ioread32(&device_ccb->send_ctrl) & (1 << CTRL_BITPOS_A))\n\t\t    &&\n\t\t    !(ioread32(&device_ccb->recv_ctrl) & (1 << CTRL_BITPOS_A)))\n\t\t\tbreak;\n\t}\n\tif (retries == 0)\n\t\tdev_err(&pdev->dev, \"Closing, but controller still active\\n\");\n\n\t \n\tmemset_io(device_ccb, 0, sizeof(struct ccb));\n\n\t \n\tdma_free_coherent(&pdev->dev, data->dma_size, data->dma_va,\n\t\t\t  data->dma_pa);\n}\n\nstatic int ilo_ccb_setup(struct ilo_hwinfo *hw, struct ccb_data *data, int slot)\n{\n\tchar *dma_va;\n\tdma_addr_t dma_pa;\n\tstruct ccb *driver_ccb, *ilo_ccb;\n\n\tdriver_ccb = &data->driver_ccb;\n\tilo_ccb = &data->ilo_ccb;\n\n\tdata->dma_size = 2 * fifo_sz(NR_QENTRY) +\n\t\t\t 2 * desc_mem_sz(NR_QENTRY) +\n\t\t\t ILO_START_ALIGN + ILO_CACHE_SZ;\n\n\tdata->dma_va = dma_alloc_coherent(&hw->ilo_dev->dev, data->dma_size,\n\t\t\t\t\t  &data->dma_pa, GFP_ATOMIC);\n\tif (!data->dma_va)\n\t\treturn -ENOMEM;\n\n\tdma_va = (char *)data->dma_va;\n\tdma_pa = data->dma_pa;\n\n\tdma_va = (char *)roundup((unsigned long)dma_va, ILO_START_ALIGN);\n\tdma_pa = roundup(dma_pa, ILO_START_ALIGN);\n\n\t \n\tctrl_setup(driver_ccb, NR_QENTRY, L2_QENTRY_SZ);\n\tctrl_setup(ilo_ccb, NR_QENTRY, L2_QENTRY_SZ);\n\n\tfifo_setup(dma_va, NR_QENTRY);\n\tdriver_ccb->ccb_u1.send_fifobar = dma_va + FIFOHANDLESIZE;\n\tilo_ccb->ccb_u1.send_fifobar_pa = dma_pa + FIFOHANDLESIZE;\n\tdma_va += fifo_sz(NR_QENTRY);\n\tdma_pa += fifo_sz(NR_QENTRY);\n\n\tdma_va = (char *)roundup((unsigned long)dma_va, ILO_CACHE_SZ);\n\tdma_pa = roundup(dma_pa, ILO_CACHE_SZ);\n\n\tfifo_setup(dma_va, NR_QENTRY);\n\tdriver_ccb->ccb_u3.recv_fifobar = dma_va + FIFOHANDLESIZE;\n\tilo_ccb->ccb_u3.recv_fifobar_pa = dma_pa + FIFOHANDLESIZE;\n\tdma_va += fifo_sz(NR_QENTRY);\n\tdma_pa += fifo_sz(NR_QENTRY);\n\n\tdriver_ccb->ccb_u2.send_desc = dma_va;\n\tilo_ccb->ccb_u2.send_desc_pa = dma_pa;\n\tdma_pa += desc_mem_sz(NR_QENTRY);\n\tdma_va += desc_mem_sz(NR_QENTRY);\n\n\tdriver_ccb->ccb_u4.recv_desc = dma_va;\n\tilo_ccb->ccb_u4.recv_desc_pa = dma_pa;\n\n\tdriver_ccb->channel = slot;\n\tilo_ccb->channel = slot;\n\n\tdriver_ccb->ccb_u5.db_base = hw->db_vaddr + (slot << L2_DB_SIZE);\n\tilo_ccb->ccb_u5.db_base = NULL;  \n\n\treturn 0;\n}\n\nstatic void ilo_ccb_open(struct ilo_hwinfo *hw, struct ccb_data *data, int slot)\n{\n\tint pkt_id, pkt_sz;\n\tstruct ccb *driver_ccb = &data->driver_ccb;\n\n\t \n\tdata->mapped_ccb = (struct ccb __iomem *)\n\t\t\t\t(hw->ram_vaddr + (slot * ILOHW_CCB_SZ));\n\tmemcpy_toio(data->mapped_ccb, &data->ilo_ccb, sizeof(struct ccb));\n\n\t \n\tpkt_sz = 0;\n\tfor (pkt_id = 0; pkt_id < NR_QENTRY; pkt_id++) {\n\t\tilo_pkt_enqueue(hw, driver_ccb, SENDQ, pkt_id, pkt_sz);\n\t\tdoorbell_set(driver_ccb);\n\t}\n\n\tpkt_sz = desc_mem_sz(1);\n\tfor (pkt_id = 0; pkt_id < NR_QENTRY; pkt_id++)\n\t\tilo_pkt_enqueue(hw, driver_ccb, RECVQ, pkt_id, pkt_sz);\n\n\t \n\tdoorbell_clr(driver_ccb);\n}\n\nstatic int ilo_ccb_verify(struct ilo_hwinfo *hw, struct ccb_data *data)\n{\n\tint pkt_id, i;\n\tstruct ccb *driver_ccb = &data->driver_ccb;\n\n\t \n\tfor (i = MAX_WAIT; i > 0; i--) {\n\t\tif (ilo_pkt_dequeue(hw, driver_ccb, SENDQ, &pkt_id, NULL, NULL))\n\t\t\tbreak;\n\t\tudelay(WAIT_TIME);\n\t}\n\n\tif (i == 0) {\n\t\tdev_err(&hw->ilo_dev->dev, \"Open could not dequeue a packet\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tilo_pkt_enqueue(hw, driver_ccb, SENDQ, pkt_id, 0);\n\tdoorbell_set(driver_ccb);\n\treturn 0;\n}\n\nstatic inline int is_channel_reset(struct ccb *ccb)\n{\n\t \n\treturn FIFOBARTOHANDLE(ccb->ccb_u1.send_fifobar)->reset;\n}\n\nstatic inline void set_channel_reset(struct ccb *ccb)\n{\n\t \n\tFIFOBARTOHANDLE(ccb->ccb_u1.send_fifobar)->reset = 1;\n}\n\nstatic inline int get_device_outbound(struct ilo_hwinfo *hw)\n{\n\treturn ioread32(&hw->mmio_vaddr[DB_OUT]);\n}\n\nstatic inline int is_db_reset(int db_out)\n{\n\treturn db_out & (1 << DB_RESET);\n}\n\nstatic inline void clear_pending_db(struct ilo_hwinfo *hw, int clr)\n{\n\tiowrite32(clr, &hw->mmio_vaddr[DB_OUT]);\n}\n\nstatic inline void clear_device(struct ilo_hwinfo *hw)\n{\n\t \n\tclear_pending_db(hw, -1);\n}\n\nstatic inline void ilo_enable_interrupts(struct ilo_hwinfo *hw)\n{\n\tiowrite8(ioread8(&hw->mmio_vaddr[DB_IRQ]) | 1, &hw->mmio_vaddr[DB_IRQ]);\n}\n\nstatic inline void ilo_disable_interrupts(struct ilo_hwinfo *hw)\n{\n\tiowrite8(ioread8(&hw->mmio_vaddr[DB_IRQ]) & ~1,\n\t\t &hw->mmio_vaddr[DB_IRQ]);\n}\n\nstatic void ilo_set_reset(struct ilo_hwinfo *hw)\n{\n\tint slot;\n\n\t \n\tfor (slot = 0; slot < max_ccb; slot++) {\n\t\tif (!hw->ccb_alloc[slot])\n\t\t\tcontinue;\n\t\tset_channel_reset(&hw->ccb_alloc[slot]->driver_ccb);\n\t}\n}\n\nstatic ssize_t ilo_read(struct file *fp, char __user *buf,\n\t\t\tsize_t len, loff_t *off)\n{\n\tint err, found, cnt, pkt_id, pkt_len;\n\tstruct ccb_data *data = fp->private_data;\n\tstruct ccb *driver_ccb = &data->driver_ccb;\n\tstruct ilo_hwinfo *hw = data->ilo_hw;\n\tvoid *pkt;\n\n\tif (is_channel_reset(driver_ccb)) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\t \n\tcnt = 20;\n\tdo {\n\t\t \n\t\tfound = ilo_pkt_dequeue(hw, driver_ccb, RECVQ, &pkt_id,\n\t\t\t\t\t&pkt_len, &pkt);\n\t\tif (found)\n\t\t\tbreak;\n\t\tcnt--;\n\t\tmsleep(100);\n\t} while (!found && cnt);\n\n\tif (!found)\n\t\treturn -EAGAIN;\n\n\t \n\tif (pkt_len < len)\n\t\tlen = pkt_len;\n\n\terr = copy_to_user(buf, pkt, len);\n\n\t \n\tilo_pkt_enqueue(hw, driver_ccb, RECVQ, pkt_id, desc_mem_sz(1));\n\n\treturn err ? -EFAULT : len;\n}\n\nstatic ssize_t ilo_write(struct file *fp, const char __user *buf,\n\t\t\t size_t len, loff_t *off)\n{\n\tint err, pkt_id, pkt_len;\n\tstruct ccb_data *data = fp->private_data;\n\tstruct ccb *driver_ccb = &data->driver_ccb;\n\tstruct ilo_hwinfo *hw = data->ilo_hw;\n\tvoid *pkt;\n\n\tif (is_channel_reset(driver_ccb))\n\t\treturn -ENODEV;\n\n\t \n\tif (!ilo_pkt_dequeue(hw, driver_ccb, SENDQ, &pkt_id, &pkt_len, &pkt))\n\t\treturn -EBUSY;\n\n\t \n\tif (pkt_len < len)\n\t\tlen = pkt_len;\n\n\t \n\terr = copy_from_user(pkt, buf, len);\n\tif (err)\n\t\tlen = 0;\n\n\t \n\tilo_pkt_enqueue(hw, driver_ccb, SENDQ, pkt_id, len);\n\tdoorbell_set(driver_ccb);\n\n\treturn err ? -EFAULT : len;\n}\n\nstatic __poll_t ilo_poll(struct file *fp, poll_table *wait)\n{\n\tstruct ccb_data *data = fp->private_data;\n\tstruct ccb *driver_ccb = &data->driver_ccb;\n\n\tpoll_wait(fp, &data->ccb_waitq, wait);\n\n\tif (is_channel_reset(driver_ccb))\n\t\treturn EPOLLERR;\n\telse if (ilo_pkt_recv(data->ilo_hw, driver_ccb))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\n\treturn 0;\n}\n\nstatic int ilo_close(struct inode *ip, struct file *fp)\n{\n\tint slot;\n\tstruct ccb_data *data;\n\tstruct ilo_hwinfo *hw;\n\tunsigned long flags;\n\n\tslot = iminor(ip) % max_ccb;\n\thw = container_of(ip->i_cdev, struct ilo_hwinfo, cdev);\n\n\tspin_lock(&hw->open_lock);\n\n\tif (hw->ccb_alloc[slot]->ccb_cnt == 1) {\n\n\t\tdata = fp->private_data;\n\n\t\tspin_lock_irqsave(&hw->alloc_lock, flags);\n\t\thw->ccb_alloc[slot] = NULL;\n\t\tspin_unlock_irqrestore(&hw->alloc_lock, flags);\n\n\t\tilo_ccb_close(hw->ilo_dev, data);\n\n\t\tkfree(data);\n\t} else\n\t\thw->ccb_alloc[slot]->ccb_cnt--;\n\n\tspin_unlock(&hw->open_lock);\n\n\treturn 0;\n}\n\nstatic int ilo_open(struct inode *ip, struct file *fp)\n{\n\tint slot, error;\n\tstruct ccb_data *data;\n\tstruct ilo_hwinfo *hw;\n\tunsigned long flags;\n\n\tslot = iminor(ip) % max_ccb;\n\thw = container_of(ip->i_cdev, struct ilo_hwinfo, cdev);\n\n\t \n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&hw->open_lock);\n\n\t \n\tif (hw->ccb_alloc[slot] == NULL) {\n\t\t \n\t\terror = ilo_ccb_setup(hw, data, slot);\n\t\tif (error) {\n\t\t\tkfree(data);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->ccb_cnt = 1;\n\t\tdata->ccb_excl = fp->f_flags & O_EXCL;\n\t\tdata->ilo_hw = hw;\n\t\tinit_waitqueue_head(&data->ccb_waitq);\n\n\t\t \n\t\tspin_lock_irqsave(&hw->alloc_lock, flags);\n\t\tilo_ccb_open(hw, data, slot);\n\t\thw->ccb_alloc[slot] = data;\n\t\tspin_unlock_irqrestore(&hw->alloc_lock, flags);\n\n\t\t \n\t\terror = ilo_ccb_verify(hw, data);\n\t\tif (error) {\n\n\t\t\tspin_lock_irqsave(&hw->alloc_lock, flags);\n\t\t\thw->ccb_alloc[slot] = NULL;\n\t\t\tspin_unlock_irqrestore(&hw->alloc_lock, flags);\n\n\t\t\tilo_ccb_close(hw->ilo_dev, data);\n\n\t\t\tkfree(data);\n\t\t\tgoto out;\n\t\t}\n\n\t} else {\n\t\tkfree(data);\n\t\tif (fp->f_flags & O_EXCL || hw->ccb_alloc[slot]->ccb_excl) {\n\t\t\t \n\t\t\terror = -EBUSY;\n\t\t} else {\n\t\t\thw->ccb_alloc[slot]->ccb_cnt++;\n\t\t\terror = 0;\n\t\t}\n\t}\nout:\n\tspin_unlock(&hw->open_lock);\n\n\tif (!error)\n\t\tfp->private_data = hw->ccb_alloc[slot];\n\n\treturn error;\n}\n\nstatic const struct file_operations ilo_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= ilo_read,\n\t.write\t\t= ilo_write,\n\t.poll\t\t= ilo_poll,\n\t.open \t\t= ilo_open,\n\t.release \t= ilo_close,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic irqreturn_t ilo_isr(int irq, void *data)\n{\n\tstruct ilo_hwinfo *hw = data;\n\tint pending, i;\n\n\tspin_lock(&hw->alloc_lock);\n\n\t \n\tpending = get_device_outbound(hw);\n\tif (!pending) {\n\t\tspin_unlock(&hw->alloc_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (is_db_reset(pending)) {\n\t\t \n\t\tpending = -1;\n\t\tilo_set_reset(hw);\n\t}\n\n\tfor (i = 0; i < max_ccb; i++) {\n\t\tif (!hw->ccb_alloc[i])\n\t\t\tcontinue;\n\t\tif (pending & (1 << i))\n\t\t\twake_up_interruptible(&hw->ccb_alloc[i]->ccb_waitq);\n\t}\n\n\t \n\tclear_pending_db(hw, pending);\n\n\tspin_unlock(&hw->alloc_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ilo_unmap_device(struct pci_dev *pdev, struct ilo_hwinfo *hw)\n{\n\tpci_iounmap(pdev, hw->db_vaddr);\n\tpci_iounmap(pdev, hw->ram_vaddr);\n\tpci_iounmap(pdev, hw->mmio_vaddr);\n}\n\nstatic int ilo_map_device(struct pci_dev *pdev, struct ilo_hwinfo *hw)\n{\n\tint bar;\n\tunsigned long off;\n\tu8 pci_rev_id;\n\tint rc;\n\n\t \n\thw->mmio_vaddr = pci_iomap(pdev, 1, 0);\n\tif (hw->mmio_vaddr == NULL) {\n\t\tdev_err(&pdev->dev, \"Error mapping mmio\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\trc = pci_read_config_byte(pdev, PCI_REVISION_ID, &pci_rev_id);\n\tif (rc != 0) {\n\t\tdev_err(&pdev->dev, \"Error reading PCI rev id: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (pci_rev_id >= PCI_REV_ID_NECHES) {\n\t\tbar = 5;\n\t\t \n\t\toff = pci_resource_len(pdev, bar) - 0x2000;\n\t} else {\n\t\tbar = 2;\n\t\toff = 0;\n\t}\n\thw->ram_vaddr = pci_iomap_range(pdev, bar, off, max_ccb * ILOHW_CCB_SZ);\n\tif (hw->ram_vaddr == NULL) {\n\t\tdev_err(&pdev->dev, \"Error mapping shared mem\\n\");\n\t\tgoto mmio_free;\n\t}\n\n\t \n\thw->db_vaddr = pci_iomap(pdev, 3, max_ccb * ONE_DB_SIZE);\n\tif (hw->db_vaddr == NULL) {\n\t\tdev_err(&pdev->dev, \"Error mapping doorbell\\n\");\n\t\tgoto ram_free;\n\t}\n\n\treturn 0;\nram_free:\n\tpci_iounmap(pdev, hw->ram_vaddr);\nmmio_free:\n\tpci_iounmap(pdev, hw->mmio_vaddr);\nout:\n\treturn -ENOMEM;\n}\n\nstatic void ilo_remove(struct pci_dev *pdev)\n{\n\tint i, minor;\n\tstruct ilo_hwinfo *ilo_hw = pci_get_drvdata(pdev);\n\n\tif (!ilo_hw)\n\t\treturn;\n\n\tclear_device(ilo_hw);\n\n\tminor = MINOR(ilo_hw->cdev.dev);\n\tfor (i = minor; i < minor + max_ccb; i++)\n\t\tdevice_destroy(&ilo_class, MKDEV(ilo_major, i));\n\n\tcdev_del(&ilo_hw->cdev);\n\tilo_disable_interrupts(ilo_hw);\n\tfree_irq(pdev->irq, ilo_hw);\n\tilo_unmap_device(pdev, ilo_hw);\n\tpci_release_regions(pdev);\n\t \n\tkfree(ilo_hw);\n\tilo_hwdev[(minor / max_ccb)] = 0;\n}\n\nstatic int ilo_probe(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *ent)\n{\n\tint devnum, minor, start, error = 0;\n\tstruct ilo_hwinfo *ilo_hw;\n\n\tif (pci_match_id(ilo_blacklist, pdev)) {\n\t\tdev_dbg(&pdev->dev, \"Not supported on this device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (max_ccb > MAX_CCB)\n\t\tmax_ccb = MAX_CCB;\n\telse if (max_ccb < MIN_CCB)\n\t\tmax_ccb = MIN_CCB;\n\n\t \n\tfor (devnum = 0; devnum < MAX_ILO_DEV; devnum++) {\n\t\tif (ilo_hwdev[devnum] == 0) {\n\t\t\tilo_hwdev[devnum] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (devnum == MAX_ILO_DEV) {\n\t\tdev_err(&pdev->dev, \"Error finding free device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\terror = -ENOMEM;\n\tilo_hw = kzalloc(sizeof(*ilo_hw), GFP_KERNEL);\n\tif (!ilo_hw)\n\t\tgoto out;\n\n\tilo_hw->ilo_dev = pdev;\n\tspin_lock_init(&ilo_hw->alloc_lock);\n\tspin_lock_init(&ilo_hw->fifo_lock);\n\tspin_lock_init(&ilo_hw->open_lock);\n\n\terror = pci_enable_device(pdev);\n\tif (error)\n\t\tgoto free;\n\n\tpci_set_master(pdev);\n\n\terror = pci_request_regions(pdev, ILO_NAME);\n\tif (error)\n\t\tgoto disable;\n\n\terror = ilo_map_device(pdev, ilo_hw);\n\tif (error)\n\t\tgoto free_regions;\n\n\tpci_set_drvdata(pdev, ilo_hw);\n\tclear_device(ilo_hw);\n\n\terror = request_irq(pdev->irq, ilo_isr, IRQF_SHARED, \"hpilo\", ilo_hw);\n\tif (error)\n\t\tgoto unmap;\n\n\tilo_enable_interrupts(ilo_hw);\n\n\tcdev_init(&ilo_hw->cdev, &ilo_fops);\n\tilo_hw->cdev.owner = THIS_MODULE;\n\tstart = devnum * max_ccb;\n\terror = cdev_add(&ilo_hw->cdev, MKDEV(ilo_major, start), max_ccb);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Could not add cdev\\n\");\n\t\tgoto remove_isr;\n\t}\n\n\tfor (minor = 0 ; minor < max_ccb; minor++) {\n\t\tstruct device *dev;\n\t\tdev = device_create(&ilo_class, &pdev->dev,\n\t\t\t\t    MKDEV(ilo_major, minor), NULL,\n\t\t\t\t    \"hpilo!d%dccb%d\", devnum, minor);\n\t\tif (IS_ERR(dev))\n\t\t\tdev_err(&pdev->dev, \"Could not create files\\n\");\n\t}\n\n\treturn 0;\nremove_isr:\n\tilo_disable_interrupts(ilo_hw);\n\tfree_irq(pdev->irq, ilo_hw);\nunmap:\n\tilo_unmap_device(pdev, ilo_hw);\nfree_regions:\n\tpci_release_regions(pdev);\ndisable:\n \nfree:\n\tkfree(ilo_hw);\nout:\n\tilo_hwdev[devnum] = 0;\n\treturn error;\n}\n\nstatic const struct pci_device_id ilo_devices[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_COMPAQ, 0xB204) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HP, 0x3307) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, ilo_devices);\n\nstatic struct pci_driver ilo_driver = {\n\t.name \t  = ILO_NAME,\n\t.id_table = ilo_devices,\n\t.probe \t  = ilo_probe,\n\t.remove   = ilo_remove,\n};\n\nstatic int __init ilo_init(void)\n{\n\tint error;\n\tdev_t dev;\n\n\terror = class_register(&ilo_class);\n\tif (error)\n\t\tgoto out;\n\n\terror = alloc_chrdev_region(&dev, 0, MAX_OPEN, ILO_NAME);\n\tif (error)\n\t\tgoto class_destroy;\n\n\tilo_major = MAJOR(dev);\n\n\terror =\tpci_register_driver(&ilo_driver);\n\tif (error)\n\t\tgoto chr_remove;\n\n\treturn 0;\nchr_remove:\n\tunregister_chrdev_region(dev, MAX_OPEN);\nclass_destroy:\n\tclass_unregister(&ilo_class);\nout:\n\treturn error;\n}\n\nstatic void __exit ilo_exit(void)\n{\n\tpci_unregister_driver(&ilo_driver);\n\tunregister_chrdev_region(MKDEV(ilo_major, 0), MAX_OPEN);\n\tclass_unregister(&ilo_class);\n}\n\nMODULE_VERSION(\"1.5.0\");\nMODULE_ALIAS(ILO_NAME);\nMODULE_DESCRIPTION(ILO_NAME);\nMODULE_AUTHOR(\"David Altobelli <david.altobelli@hpe.com>\");\nMODULE_LICENSE(\"GPL v2\");\n\nmodule_param(max_ccb, uint, 0444);\nMODULE_PARM_DESC(max_ccb, \"Maximum number of HP iLO channels to attach (8-24)(default=16)\");\n\nmodule_init(ilo_init);\nmodule_exit(ilo_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}