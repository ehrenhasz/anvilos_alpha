{
  "module_name": "ics932s401.c",
  "hash_id": "6c22ff9ef50f51d13ed020d4fbbabeac6ea5a29a0f79a794c77febcb22f1cd21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ics932s401.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x69, I2C_CLIENT_END };\n\n \n#define ICS932S401_REG_CFG2\t\t\t0x01\n#define\t\tICS932S401_CFG1_SPREAD\t\t0x01\n#define ICS932S401_REG_CFG7\t\t\t0x06\n#define\t\tICS932S401_FS_MASK\t\t0x07\n#define\tICS932S401_REG_VENDOR_REV\t\t0x07\n#define\t\tICS932S401_VENDOR\t\t1\n#define\t\tICS932S401_VENDOR_MASK\t\t0x0F\n#define\t\tICS932S401_REV\t\t\t4\n#define\t\tICS932S401_REV_SHIFT\t\t4\n#define ICS932S401_REG_DEVICE\t\t\t0x09\n#define\t\tICS932S401_DEVICE\t\t11\n#define\tICS932S401_REG_CTRL\t\t\t0x0A\n#define\t\tICS932S401_MN_ENABLED\t\t0x80\n#define\t\tICS932S401_CPU_ALT\t\t0x04\n#define\t\tICS932S401_SRC_ALT\t\t0x08\n#define ICS932S401_REG_CPU_M_CTRL\t\t0x0B\n#define\t\tICS932S401_M_MASK\t\t0x3F\n#define\tICS932S401_REG_CPU_N_CTRL\t\t0x0C\n#define\tICS932S401_REG_CPU_SPREAD1\t\t0x0D\n#define ICS932S401_REG_CPU_SPREAD2\t\t0x0E\n#define\t\tICS932S401_SPREAD_MASK\t\t0x7FFF\n#define ICS932S401_REG_SRC_M_CTRL\t\t0x0F\n#define ICS932S401_REG_SRC_N_CTRL\t\t0x10\n#define\tICS932S401_REG_SRC_SPREAD1\t\t0x11\n#define ICS932S401_REG_SRC_SPREAD2\t\t0x12\n#define ICS932S401_REG_CPU_DIVISOR\t\t0x13\n#define\t\tICS932S401_CPU_DIVISOR_SHIFT\t4\n#define ICS932S401_REG_PCISRC_DIVISOR\t\t0x14\n#define\t\tICS932S401_SRC_DIVISOR_MASK\t0x0F\n#define\t\tICS932S401_PCI_DIVISOR_SHIFT\t4\n\n \n#define BASE_CLOCK\t\t\t\t14318\n\n#define NUM_REGS\t\t\t\t21\n#define NUM_MIRRORED_REGS\t\t\t15\n\nstatic int regs_to_copy[NUM_MIRRORED_REGS] = {\n\tICS932S401_REG_CFG2,\n\tICS932S401_REG_CFG7,\n\tICS932S401_REG_VENDOR_REV,\n\tICS932S401_REG_DEVICE,\n\tICS932S401_REG_CTRL,\n\tICS932S401_REG_CPU_M_CTRL,\n\tICS932S401_REG_CPU_N_CTRL,\n\tICS932S401_REG_CPU_SPREAD1,\n\tICS932S401_REG_CPU_SPREAD2,\n\tICS932S401_REG_SRC_M_CTRL,\n\tICS932S401_REG_SRC_N_CTRL,\n\tICS932S401_REG_SRC_SPREAD1,\n\tICS932S401_REG_SRC_SPREAD2,\n\tICS932S401_REG_CPU_DIVISOR,\n\tICS932S401_REG_PCISRC_DIVISOR,\n};\n\n \n#define SENSOR_REFRESH_INTERVAL\t(2 * HZ)\n\n \n#define LIMIT_REFRESH_INTERVAL\t(60 * HZ)\n\nstruct ics932s401_data {\n\tstruct attribute_group\tattrs;\n\tstruct mutex\t\tlock;\n\tchar\t\t\tsensors_valid;\n\tunsigned long\t\tsensors_last_updated;\t \n\n\tu8\t\t\tregs[NUM_REGS];\n};\n\nstatic int ics932s401_probe(struct i2c_client *client);\nstatic int ics932s401_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info);\nstatic void ics932s401_remove(struct i2c_client *client);\n\nstatic const struct i2c_device_id ics932s401_id[] = {\n\t{ \"ics932s401\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ics932s401_id);\n\nstatic struct i2c_driver ics932s401_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name\t= \"ics932s401\",\n\t},\n\t.probe\t\t= ics932s401_probe,\n\t.remove\t\t= ics932s401_remove,\n\t.id_table\t= ics932s401_id,\n\t.detect\t\t= ics932s401_detect,\n\t.address_list\t= normal_i2c,\n};\n\nstatic struct ics932s401_data *ics932s401_update_device(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ics932s401_data *data = i2c_get_clientdata(client);\n\tunsigned long local_jiffies = jiffies;\n\tint i, temp;\n\n\tmutex_lock(&data->lock);\n\tif (time_before(local_jiffies, data->sensors_last_updated +\n\t\tSENSOR_REFRESH_INTERVAL)\n\t\t&& data->sensors_valid)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < NUM_MIRRORED_REGS; i++) {\n\t\ttemp = i2c_smbus_read_word_data(client, regs_to_copy[i]);\n\t\tif (temp < 0)\n\t\t\ttemp = 0;\n\t\tdata->regs[regs_to_copy[i]] = temp >> 8;\n\t}\n\n\tdata->sensors_last_updated = local_jiffies;\n\tdata->sensors_valid = 1;\n\nout:\n\tmutex_unlock(&data->lock);\n\treturn data;\n}\n\nstatic ssize_t show_spread_enabled(struct device *dev,\n\t\t\t\t   struct device_attribute *devattr,\n\t\t\t\t   char *buf)\n{\n\tstruct ics932s401_data *data = ics932s401_update_device(dev);\n\n\tif (data->regs[ICS932S401_REG_CFG2] & ICS932S401_CFG1_SPREAD)\n\t\treturn sprintf(buf, \"1\\n\");\n\n\treturn sprintf(buf, \"0\\n\");\n}\n\n \nstatic const int fs_speeds[] = {\n\t266666,\n\t133333,\n\t200000,\n\t166666,\n\t333333,\n\t100000,\n\t400000,\n\t0,\n};\n\n \nstatic const int divisors[] = {2, 3, 5, 15, 4, 6, 10, 30, 8, 12, 20, 60, 16,\n\t\t\t       24, 40, 120};\n\n \nstatic int calculate_cpu_freq(struct ics932s401_data *data)\n{\n\tint m, n, freq;\n\n\tm = data->regs[ICS932S401_REG_CPU_M_CTRL] & ICS932S401_M_MASK;\n\tn = data->regs[ICS932S401_REG_CPU_N_CTRL];\n\n\t \n\tn |= ((int)data->regs[ICS932S401_REG_CPU_M_CTRL] & 0x80) << 1;\n\tn |= ((int)data->regs[ICS932S401_REG_CPU_M_CTRL] & 0x40) << 3;\n\n\tfreq = BASE_CLOCK * (n + 8) / (m + 2);\n\tfreq /= divisors[data->regs[ICS932S401_REG_CPU_DIVISOR] >>\n\t\t\t ICS932S401_CPU_DIVISOR_SHIFT];\n\n\treturn freq;\n}\n\nstatic ssize_t show_cpu_clock(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      char *buf)\n{\n\tstruct ics932s401_data *data = ics932s401_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", calculate_cpu_freq(data));\n}\n\nstatic ssize_t show_cpu_clock_sel(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr,\n\t\t\t\t  char *buf)\n{\n\tstruct ics932s401_data *data = ics932s401_update_device(dev);\n\tint freq;\n\n\tif (data->regs[ICS932S401_REG_CTRL] & ICS932S401_MN_ENABLED)\n\t\tfreq = calculate_cpu_freq(data);\n\telse {\n\t\t \n\t\tint fid = data->regs[ICS932S401_REG_CFG7] & ICS932S401_FS_MASK;\n\n\t\tfreq = fs_speeds[fid];\n\t\tif (data->regs[ICS932S401_REG_CTRL] & ICS932S401_CPU_ALT) {\n\t\t\tswitch (freq) {\n\t\t\tcase 166666:\n\t\t\t\tfreq = 160000;\n\t\t\t\tbreak;\n\t\t\tcase 333333:\n\t\t\t\tfreq = 320000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", freq);\n}\n\n \nstatic int calculate_src_freq(struct ics932s401_data *data)\n{\n\tint m, n, freq;\n\n\tm = data->regs[ICS932S401_REG_SRC_M_CTRL] & ICS932S401_M_MASK;\n\tn = data->regs[ICS932S401_REG_SRC_N_CTRL];\n\n\t \n\tn |= ((int)data->regs[ICS932S401_REG_SRC_M_CTRL] & 0x80) << 1;\n\tn |= ((int)data->regs[ICS932S401_REG_SRC_M_CTRL] & 0x40) << 3;\n\n\tfreq = BASE_CLOCK * (n + 8) / (m + 2);\n\tfreq /= divisors[data->regs[ICS932S401_REG_PCISRC_DIVISOR] &\n\t\t\t ICS932S401_SRC_DIVISOR_MASK];\n\n\treturn freq;\n}\n\nstatic ssize_t show_src_clock(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      char *buf)\n{\n\tstruct ics932s401_data *data = ics932s401_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", calculate_src_freq(data));\n}\n\nstatic ssize_t show_src_clock_sel(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr,\n\t\t\t\t  char *buf)\n{\n\tstruct ics932s401_data *data = ics932s401_update_device(dev);\n\tint freq;\n\n\tif (data->regs[ICS932S401_REG_CTRL] & ICS932S401_MN_ENABLED)\n\t\tfreq = calculate_src_freq(data);\n\telse\n\t\t \n\t\tif (data->regs[ICS932S401_REG_CTRL] & ICS932S401_CPU_ALT &&\n\t\t    data->regs[ICS932S401_REG_CTRL] & ICS932S401_SRC_ALT)\n\t\t\tfreq = 96000;\n\t\telse\n\t\t\tfreq = 100000;\n\n\treturn sprintf(buf, \"%d\\n\", freq);\n}\n\n \nstatic int calculate_pci_freq(struct ics932s401_data *data)\n{\n\tint m, n, freq;\n\n\tm = data->regs[ICS932S401_REG_SRC_M_CTRL] & ICS932S401_M_MASK;\n\tn = data->regs[ICS932S401_REG_SRC_N_CTRL];\n\n\t \n\tn |= ((int)data->regs[ICS932S401_REG_SRC_M_CTRL] & 0x80) << 1;\n\tn |= ((int)data->regs[ICS932S401_REG_SRC_M_CTRL] & 0x40) << 3;\n\n\tfreq = BASE_CLOCK * (n + 8) / (m + 2);\n\tfreq /= divisors[data->regs[ICS932S401_REG_PCISRC_DIVISOR] >>\n\t\t\t ICS932S401_PCI_DIVISOR_SHIFT];\n\n\treturn freq;\n}\n\nstatic ssize_t show_pci_clock(struct device *dev,\n\t\t\t      struct device_attribute *devattr,\n\t\t\t      char *buf)\n{\n\tstruct ics932s401_data *data = ics932s401_update_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", calculate_pci_freq(data));\n}\n\nstatic ssize_t show_pci_clock_sel(struct device *dev,\n\t\t\t\t  struct device_attribute *devattr,\n\t\t\t\t  char *buf)\n{\n\tstruct ics932s401_data *data = ics932s401_update_device(dev);\n\tint freq;\n\n\tif (data->regs[ICS932S401_REG_CTRL] & ICS932S401_MN_ENABLED)\n\t\tfreq = calculate_pci_freq(data);\n\telse\n\t\tfreq = 33333;\n\n\treturn sprintf(buf, \"%d\\n\", freq);\n}\n\nstatic ssize_t show_value(struct device *dev,\n\t\t\t  struct device_attribute *devattr,\n\t\t\t  char *buf);\n\nstatic ssize_t show_spread(struct device *dev,\n\t\t\t   struct device_attribute *devattr,\n\t\t\t   char *buf);\n\nstatic DEVICE_ATTR(spread_enabled, S_IRUGO, show_spread_enabled, NULL);\nstatic DEVICE_ATTR(cpu_clock_selection, S_IRUGO, show_cpu_clock_sel, NULL);\nstatic DEVICE_ATTR(cpu_clock, S_IRUGO, show_cpu_clock, NULL);\nstatic DEVICE_ATTR(src_clock_selection, S_IRUGO, show_src_clock_sel, NULL);\nstatic DEVICE_ATTR(src_clock, S_IRUGO, show_src_clock, NULL);\nstatic DEVICE_ATTR(pci_clock_selection, S_IRUGO, show_pci_clock_sel, NULL);\nstatic DEVICE_ATTR(pci_clock, S_IRUGO, show_pci_clock, NULL);\nstatic DEVICE_ATTR(usb_clock, S_IRUGO, show_value, NULL);\nstatic DEVICE_ATTR(ref_clock, S_IRUGO, show_value, NULL);\nstatic DEVICE_ATTR(cpu_spread, S_IRUGO, show_spread, NULL);\nstatic DEVICE_ATTR(src_spread, S_IRUGO, show_spread, NULL);\n\nstatic struct attribute *ics932s401_attr[] = {\n\t&dev_attr_spread_enabled.attr,\n\t&dev_attr_cpu_clock_selection.attr,\n\t&dev_attr_cpu_clock.attr,\n\t&dev_attr_src_clock_selection.attr,\n\t&dev_attr_src_clock.attr,\n\t&dev_attr_pci_clock_selection.attr,\n\t&dev_attr_pci_clock.attr,\n\t&dev_attr_usb_clock.attr,\n\t&dev_attr_ref_clock.attr,\n\t&dev_attr_cpu_spread.attr,\n\t&dev_attr_src_spread.attr,\n\tNULL\n};\n\nstatic ssize_t show_value(struct device *dev,\n\t\t\t  struct device_attribute *devattr,\n\t\t\t  char *buf)\n{\n\tint x;\n\n\tif (devattr == &dev_attr_usb_clock)\n\t\tx = 48000;\n\telse if (devattr == &dev_attr_ref_clock)\n\t\tx = BASE_CLOCK;\n\telse\n\t\tBUG();\n\n\treturn sprintf(buf, \"%d\\n\", x);\n}\n\nstatic ssize_t show_spread(struct device *dev,\n\t\t\t   struct device_attribute *devattr,\n\t\t\t   char *buf)\n{\n\tstruct ics932s401_data *data = ics932s401_update_device(dev);\n\tint reg;\n\tunsigned long val;\n\n\tif (!(data->regs[ICS932S401_REG_CFG2] & ICS932S401_CFG1_SPREAD))\n\t\treturn sprintf(buf, \"0%%\\n\");\n\n\tif (devattr == &dev_attr_src_spread)\n\t\treg = ICS932S401_REG_SRC_SPREAD1;\n\telse if (devattr == &dev_attr_cpu_spread)\n\t\treg = ICS932S401_REG_CPU_SPREAD1;\n\telse\n\t\tBUG();\n\n\tval = data->regs[reg] | (data->regs[reg + 1] << 8);\n\tval &= ICS932S401_SPREAD_MASK;\n\n\t \n\tval = 500000 * val / 16384;\n\treturn sprintf(buf, \"-0.%lu%%\\n\", val);\n}\n\n \nstatic int ics932s401_detect(struct i2c_client *client,\n\t\t\t  struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint vendor, device, revision;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tvendor = i2c_smbus_read_word_data(client, ICS932S401_REG_VENDOR_REV);\n\tvendor >>= 8;\n\trevision = vendor >> ICS932S401_REV_SHIFT;\n\tvendor &= ICS932S401_VENDOR_MASK;\n\tif (vendor != ICS932S401_VENDOR)\n\t\treturn -ENODEV;\n\n\tdevice = i2c_smbus_read_word_data(client, ICS932S401_REG_DEVICE);\n\tdevice >>= 8;\n\tif (device != ICS932S401_DEVICE)\n\t\treturn -ENODEV;\n\n\tif (revision != ICS932S401_REV)\n\t\tdev_info(&adapter->dev, \"Unknown revision %d\\n\", revision);\n\n\tstrscpy(info->type, \"ics932s401\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int ics932s401_probe(struct i2c_client *client)\n{\n\tstruct ics932s401_data *data;\n\tint err;\n\n\tdata = kzalloc(sizeof(struct ics932s401_data), GFP_KERNEL);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->lock);\n\n\tdev_info(&client->dev, \"%s chip found\\n\", client->name);\n\n\t \n\tdata->attrs.attrs = ics932s401_attr;\n\terr = sysfs_create_group(&client->dev.kobj, &data->attrs);\n\tif (err)\n\t\tgoto exit_free;\n\n\treturn 0;\n\nexit_free:\n\tkfree(data);\nexit:\n\treturn err;\n}\n\nstatic void ics932s401_remove(struct i2c_client *client)\n{\n\tstruct ics932s401_data *data = i2c_get_clientdata(client);\n\n\tsysfs_remove_group(&client->dev.kobj, &data->attrs);\n\tkfree(data);\n}\n\nmodule_i2c_driver(ics932s401_driver);\n\nMODULE_AUTHOR(\"Darrick J. Wong <darrick.wong@oracle.com>\");\nMODULE_DESCRIPTION(\"ICS932S401 driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nMODULE_ALIAS(\"dmi:bvnIBM:*:rn9228:*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:rn9232:*\");\n\n \nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3650*\");\nMODULE_ALIAS(\"dmi:bvnIBM:*:pnIBMSystemx3550*\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}