{
  "module_name": "ad525x_dpot.c",
  "hash_id": "0fd3ac0be782303bb2ba5f5e2ee44e0b199817f71b3cfbedfe5eab77094cd290",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ad525x_dpot.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include \"ad525x_dpot.h\"\n\n \n\nstruct dpot_data {\n\tstruct ad_dpot_bus_data\tbdata;\n\tstruct mutex update_lock;\n\tunsigned int rdac_mask;\n\tunsigned int max_pos;\n\tunsigned long devid;\n\tunsigned int uid;\n\tunsigned int feat;\n\tunsigned int wipers;\n\tu16 rdac_cache[MAX_RDACS];\n\tDECLARE_BITMAP(otp_en_mask, MAX_RDACS);\n};\n\nstatic inline int dpot_read_d8(struct dpot_data *dpot)\n{\n\treturn dpot->bdata.bops->read_d8(dpot->bdata.client);\n}\n\nstatic inline int dpot_read_r8d8(struct dpot_data *dpot, u8 reg)\n{\n\treturn dpot->bdata.bops->read_r8d8(dpot->bdata.client, reg);\n}\n\nstatic inline int dpot_read_r8d16(struct dpot_data *dpot, u8 reg)\n{\n\treturn dpot->bdata.bops->read_r8d16(dpot->bdata.client, reg);\n}\n\nstatic inline int dpot_write_d8(struct dpot_data *dpot, u8 val)\n{\n\treturn dpot->bdata.bops->write_d8(dpot->bdata.client, val);\n}\n\nstatic inline int dpot_write_r8d8(struct dpot_data *dpot, u8 reg, u16 val)\n{\n\treturn dpot->bdata.bops->write_r8d8(dpot->bdata.client, reg, val);\n}\n\nstatic inline int dpot_write_r8d16(struct dpot_data *dpot, u8 reg, u16 val)\n{\n\treturn dpot->bdata.bops->write_r8d16(dpot->bdata.client, reg, val);\n}\n\nstatic s32 dpot_read_spi(struct dpot_data *dpot, u8 reg)\n{\n\tunsigned int ctrl = 0;\n\tint value;\n\n\tif (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD))) {\n\n\t\tif (dpot->feat & F_RDACS_WONLY)\n\t\t\treturn dpot->rdac_cache[reg & DPOT_RDAC_MASK];\n\t\tif (dpot->uid == DPOT_UID(AD5291_ID) ||\n\t\t\tdpot->uid == DPOT_UID(AD5292_ID) ||\n\t\t\tdpot->uid == DPOT_UID(AD5293_ID)) {\n\n\t\t\tvalue = dpot_read_r8d8(dpot,\n\t\t\t\tDPOT_AD5291_READ_RDAC << 2);\n\n\t\t\tif (value < 0)\n\t\t\t\treturn value;\n\n\t\t\tif (dpot->uid == DPOT_UID(AD5291_ID))\n\t\t\t\tvalue = value >> 2;\n\n\t\t\treturn value;\n\t\t} else if (dpot->uid == DPOT_UID(AD5270_ID) ||\n\t\t\tdpot->uid == DPOT_UID(AD5271_ID)) {\n\n\t\t\tvalue = dpot_read_r8d8(dpot,\n\t\t\t\tDPOT_AD5270_1_2_4_READ_RDAC << 2);\n\n\t\t\tif (value < 0)\n\t\t\t\treturn value;\n\n\t\t\tif (dpot->uid == DPOT_UID(AD5271_ID))\n\t\t\t\tvalue = value >> 2;\n\n\t\t\treturn value;\n\t\t}\n\n\t\tctrl = DPOT_SPI_READ_RDAC;\n\t} else if (reg & DPOT_ADDR_EEPROM) {\n\t\tctrl = DPOT_SPI_READ_EEPROM;\n\t}\n\n\tif (dpot->feat & F_SPI_16BIT)\n\t\treturn dpot_read_r8d8(dpot, ctrl);\n\telse if (dpot->feat & F_SPI_24BIT)\n\t\treturn dpot_read_r8d16(dpot, ctrl);\n\n\treturn -EFAULT;\n}\n\nstatic s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)\n{\n\tint value;\n\tunsigned int ctrl = 0;\n\n\tswitch (dpot->uid) {\n\tcase DPOT_UID(AD5246_ID):\n\tcase DPOT_UID(AD5247_ID):\n\t\treturn dpot_read_d8(dpot);\n\tcase DPOT_UID(AD5245_ID):\n\tcase DPOT_UID(AD5241_ID):\n\tcase DPOT_UID(AD5242_ID):\n\tcase DPOT_UID(AD5243_ID):\n\tcase DPOT_UID(AD5248_ID):\n\tcase DPOT_UID(AD5280_ID):\n\tcase DPOT_UID(AD5282_ID):\n\t\tctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?\n\t\t\t0 : DPOT_AD5282_RDAC_AB;\n\t\treturn dpot_read_r8d8(dpot, ctrl);\n\tcase DPOT_UID(AD5170_ID):\n\tcase DPOT_UID(AD5171_ID):\n\tcase DPOT_UID(AD5273_ID):\n\t\t\treturn dpot_read_d8(dpot);\n\tcase DPOT_UID(AD5172_ID):\n\tcase DPOT_UID(AD5173_ID):\n\t\tctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?\n\t\t\t0 : DPOT_AD5172_3_A0;\n\t\treturn dpot_read_r8d8(dpot, ctrl);\n\tcase DPOT_UID(AD5272_ID):\n\tcase DPOT_UID(AD5274_ID):\n\t\tdpot_write_r8d8(dpot,\n\t\t\t\t(DPOT_AD5270_1_2_4_READ_RDAC << 2), 0);\n\n\t\tvalue = dpot_read_r8d16(dpot, DPOT_AD5270_1_2_4_RDAC << 2);\n\t\tif (value < 0)\n\t\t\treturn value;\n\t\t \n\t\tvalue = swab16(value);\n\n\t\tif (dpot->uid == DPOT_UID(AD5274_ID))\n\t\t\tvalue = value >> 2;\n\t\treturn value;\n\tdefault:\n\t\tif ((reg & DPOT_REG_TOL) || (dpot->max_pos > 256))\n\t\t\treturn dpot_read_r8d16(dpot, (reg & 0xF8) |\n\t\t\t\t\t((reg & 0x7) << 1));\n\t\telse\n\t\t\treturn dpot_read_r8d8(dpot, reg);\n\t}\n}\n\nstatic s32 dpot_read(struct dpot_data *dpot, u8 reg)\n{\n\tif (dpot->feat & F_SPI)\n\t\treturn dpot_read_spi(dpot, reg);\n\telse\n\t\treturn dpot_read_i2c(dpot, reg);\n}\n\nstatic s32 dpot_write_spi(struct dpot_data *dpot, u8 reg, u16 value)\n{\n\tunsigned int val = 0;\n\n\tif (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD | DPOT_ADDR_OTP))) {\n\t\tif (dpot->feat & F_RDACS_WONLY)\n\t\t\tdpot->rdac_cache[reg & DPOT_RDAC_MASK] = value;\n\n\t\tif (dpot->feat & F_AD_APPDATA) {\n\t\t\tif (dpot->feat & F_SPI_8BIT) {\n\t\t\t\tval = ((reg & DPOT_RDAC_MASK) <<\n\t\t\t\t\tDPOT_MAX_POS(dpot->devid)) |\n\t\t\t\t\tvalue;\n\t\t\t\treturn dpot_write_d8(dpot, val);\n\t\t\t} else if (dpot->feat & F_SPI_16BIT) {\n\t\t\t\tval = ((reg & DPOT_RDAC_MASK) <<\n\t\t\t\t\tDPOT_MAX_POS(dpot->devid)) |\n\t\t\t\t\tvalue;\n\t\t\t\treturn dpot_write_r8d8(dpot, val >> 8,\n\t\t\t\t\tval & 0xFF);\n\t\t\t} else\n\t\t\t\tBUG();\n\t\t} else {\n\t\t\tif (dpot->uid == DPOT_UID(AD5291_ID) ||\n\t\t\t\tdpot->uid == DPOT_UID(AD5292_ID) ||\n\t\t\t\tdpot->uid == DPOT_UID(AD5293_ID)) {\n\n\t\t\t\tdpot_write_r8d8(dpot, DPOT_AD5291_CTRLREG << 2,\n\t\t\t\t\t\tDPOT_AD5291_UNLOCK_CMD);\n\n\t\t\t\tif (dpot->uid == DPOT_UID(AD5291_ID))\n\t\t\t\t\tvalue = value << 2;\n\n\t\t\t\treturn dpot_write_r8d8(dpot,\n\t\t\t\t\t(DPOT_AD5291_RDAC << 2) |\n\t\t\t\t\t(value >> 8), value & 0xFF);\n\t\t\t} else if (dpot->uid == DPOT_UID(AD5270_ID) ||\n\t\t\t\tdpot->uid == DPOT_UID(AD5271_ID)) {\n\t\t\t\tdpot_write_r8d8(dpot,\n\t\t\t\t\t\tDPOT_AD5270_1_2_4_CTRLREG << 2,\n\t\t\t\t\t\tDPOT_AD5270_1_2_4_UNLOCK_CMD);\n\n\t\t\t\tif (dpot->uid == DPOT_UID(AD5271_ID))\n\t\t\t\t\tvalue = value << 2;\n\n\t\t\t\treturn dpot_write_r8d8(dpot,\n\t\t\t\t\t(DPOT_AD5270_1_2_4_RDAC << 2) |\n\t\t\t\t\t(value >> 8), value & 0xFF);\n\t\t\t}\n\t\t\tval = DPOT_SPI_RDAC | (reg & DPOT_RDAC_MASK);\n\t\t}\n\t} else if (reg & DPOT_ADDR_EEPROM) {\n\t\tval = DPOT_SPI_EEPROM | (reg & DPOT_RDAC_MASK);\n\t} else if (reg & DPOT_ADDR_CMD) {\n\t\tswitch (reg) {\n\t\tcase DPOT_DEC_ALL_6DB:\n\t\t\tval = DPOT_SPI_DEC_ALL_6DB;\n\t\t\tbreak;\n\t\tcase DPOT_INC_ALL_6DB:\n\t\t\tval = DPOT_SPI_INC_ALL_6DB;\n\t\t\tbreak;\n\t\tcase DPOT_DEC_ALL:\n\t\t\tval = DPOT_SPI_DEC_ALL;\n\t\t\tbreak;\n\t\tcase DPOT_INC_ALL:\n\t\t\tval = DPOT_SPI_INC_ALL;\n\t\t\tbreak;\n\t\t}\n\t} else if (reg & DPOT_ADDR_OTP) {\n\t\tif (dpot->uid == DPOT_UID(AD5291_ID) ||\n\t\t\tdpot->uid == DPOT_UID(AD5292_ID)) {\n\t\t\treturn dpot_write_r8d8(dpot,\n\t\t\t\tDPOT_AD5291_STORE_XTPM << 2, 0);\n\t\t} else if (dpot->uid == DPOT_UID(AD5270_ID) ||\n\t\t\tdpot->uid == DPOT_UID(AD5271_ID)) {\n\t\t\treturn dpot_write_r8d8(dpot,\n\t\t\t\tDPOT_AD5270_1_2_4_STORE_XTPM << 2, 0);\n\t\t}\n\t} else\n\t\tBUG();\n\n\tif (dpot->feat & F_SPI_16BIT)\n\t\treturn dpot_write_r8d8(dpot, val, value);\n\telse if (dpot->feat & F_SPI_24BIT)\n\t\treturn dpot_write_r8d16(dpot, val, value);\n\n\treturn -EFAULT;\n}\n\nstatic s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)\n{\n\t \n\tunsigned int tmp = 0, ctrl = 0;\n\n\tswitch (dpot->uid) {\n\tcase DPOT_UID(AD5246_ID):\n\tcase DPOT_UID(AD5247_ID):\n\t\treturn dpot_write_d8(dpot, value);\n\n\tcase DPOT_UID(AD5245_ID):\n\tcase DPOT_UID(AD5241_ID):\n\tcase DPOT_UID(AD5242_ID):\n\tcase DPOT_UID(AD5243_ID):\n\tcase DPOT_UID(AD5248_ID):\n\tcase DPOT_UID(AD5280_ID):\n\tcase DPOT_UID(AD5282_ID):\n\t\tctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?\n\t\t\t0 : DPOT_AD5282_RDAC_AB;\n\t\treturn dpot_write_r8d8(dpot, ctrl, value);\n\tcase DPOT_UID(AD5171_ID):\n\tcase DPOT_UID(AD5273_ID):\n\t\tif (reg & DPOT_ADDR_OTP) {\n\t\t\ttmp = dpot_read_d8(dpot);\n\t\t\tif (tmp >> 6)  \n\t\t\t\treturn -EFAULT;\n\t\t\tctrl = DPOT_AD5273_FUSE;\n\t\t}\n\t\treturn dpot_write_r8d8(dpot, ctrl, value);\n\tcase DPOT_UID(AD5172_ID):\n\tcase DPOT_UID(AD5173_ID):\n\t\tctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?\n\t\t\t0 : DPOT_AD5172_3_A0;\n\t\tif (reg & DPOT_ADDR_OTP) {\n\t\t\ttmp = dpot_read_r8d16(dpot, ctrl);\n\t\t\tif (tmp >> 14)  \n\t\t\t\treturn -EFAULT;\n\t\t\tctrl |= DPOT_AD5170_2_3_FUSE;\n\t\t}\n\t\treturn dpot_write_r8d8(dpot, ctrl, value);\n\tcase DPOT_UID(AD5170_ID):\n\t\tif (reg & DPOT_ADDR_OTP) {\n\t\t\ttmp = dpot_read_r8d16(dpot, tmp);\n\t\t\tif (tmp >> 14)  \n\t\t\t\treturn -EFAULT;\n\t\t\tctrl = DPOT_AD5170_2_3_FUSE;\n\t\t}\n\t\treturn dpot_write_r8d8(dpot, ctrl, value);\n\tcase DPOT_UID(AD5272_ID):\n\tcase DPOT_UID(AD5274_ID):\n\t\tdpot_write_r8d8(dpot, DPOT_AD5270_1_2_4_CTRLREG << 2,\n\t\t\t\tDPOT_AD5270_1_2_4_UNLOCK_CMD);\n\n\t\tif (reg & DPOT_ADDR_OTP)\n\t\t\treturn dpot_write_r8d8(dpot,\n\t\t\t\t\tDPOT_AD5270_1_2_4_STORE_XTPM << 2, 0);\n\n\t\tif (dpot->uid == DPOT_UID(AD5274_ID))\n\t\t\tvalue = value << 2;\n\n\t\treturn dpot_write_r8d8(dpot, (DPOT_AD5270_1_2_4_RDAC << 2) |\n\t\t\t\t       (value >> 8), value & 0xFF);\n\tdefault:\n\t\tif (reg & DPOT_ADDR_CMD)\n\t\t\treturn dpot_write_d8(dpot, reg);\n\n\t\tif (dpot->max_pos > 256)\n\t\t\treturn dpot_write_r8d16(dpot, (reg & 0xF8) |\n\t\t\t\t\t\t((reg & 0x7) << 1), value);\n\t\telse\n\t\t\t \n\t\t\treturn dpot_write_r8d8(dpot, reg, value);\n\t}\n}\n\nstatic s32 dpot_write(struct dpot_data *dpot, u8 reg, u16 value)\n{\n\tif (dpot->feat & F_SPI)\n\t\treturn dpot_write_spi(dpot, reg, value);\n\telse\n\t\treturn dpot_write_i2c(dpot, reg, value);\n}\n\n \n\nstatic ssize_t sysfs_show_reg(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf, u32 reg)\n{\n\tstruct dpot_data *data = dev_get_drvdata(dev);\n\ts32 value;\n\n\tif (reg & DPOT_ADDR_OTP_EN)\n\t\treturn sprintf(buf, \"%s\\n\",\n\t\t\ttest_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask) ?\n\t\t\t\"enabled\" : \"disabled\");\n\n\n\tmutex_lock(&data->update_lock);\n\tvalue = dpot_read(data, reg);\n\tmutex_unlock(&data->update_lock);\n\n\tif (value < 0)\n\t\treturn -EINVAL;\n\t \n\n\tif (reg & DPOT_REG_TOL)\n\t\treturn sprintf(buf, \"0x%04x\\n\", value & 0xFFFF);\n\telse\n\t\treturn sprintf(buf, \"%u\\n\", value & data->rdac_mask);\n}\n\nstatic ssize_t sysfs_set_reg(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count, u32 reg)\n{\n\tstruct dpot_data *data = dev_get_drvdata(dev);\n\tunsigned long value;\n\tint err;\n\n\tif (reg & DPOT_ADDR_OTP_EN) {\n\t\tif (sysfs_streq(buf, \"enabled\"))\n\t\t\tset_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask);\n\t\telse\n\t\t\tclear_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask);\n\n\t\treturn count;\n\t}\n\n\tif ((reg & DPOT_ADDR_OTP) &&\n\t\t!test_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask))\n\t\treturn -EPERM;\n\n\terr = kstrtoul(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value > data->rdac_mask)\n\t\tvalue = data->rdac_mask;\n\n\tmutex_lock(&data->update_lock);\n\tdpot_write(data, reg, value);\n\tif (reg & DPOT_ADDR_EEPROM)\n\t\tmsleep(26);\t \n\telse if (reg & DPOT_ADDR_OTP)\n\t\tmsleep(400);\t \n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t sysfs_do_cmd(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count, u32 reg)\n{\n\tstruct dpot_data *data = dev_get_drvdata(dev);\n\n\tmutex_lock(&data->update_lock);\n\tdpot_write(data, reg, 0);\n\tmutex_unlock(&data->update_lock);\n\n\treturn count;\n}\n\n \n\n#define DPOT_DEVICE_SHOW(_name, _reg) static ssize_t \\\nshow_##_name(struct device *dev, \\\n\t\t\t  struct device_attribute *attr, char *buf) \\\n{ \\\n\treturn sysfs_show_reg(dev, attr, buf, _reg); \\\n}\n\n#define DPOT_DEVICE_SET(_name, _reg) static ssize_t \\\nset_##_name(struct device *dev, \\\n\t\t\t struct device_attribute *attr, \\\n\t\t\t const char *buf, size_t count) \\\n{ \\\n\treturn sysfs_set_reg(dev, attr, buf, count, _reg); \\\n}\n\n#define DPOT_DEVICE_SHOW_SET(name, reg) \\\nDPOT_DEVICE_SHOW(name, reg) \\\nDPOT_DEVICE_SET(name, reg) \\\nstatic DEVICE_ATTR(name, S_IWUSR | S_IRUGO, show_##name, set_##name)\n\n#define DPOT_DEVICE_SHOW_ONLY(name, reg) \\\nDPOT_DEVICE_SHOW(name, reg) \\\nstatic DEVICE_ATTR(name, S_IWUSR | S_IRUGO, show_##name, NULL)\n\nDPOT_DEVICE_SHOW_SET(rdac0, DPOT_ADDR_RDAC | DPOT_RDAC0);\nDPOT_DEVICE_SHOW_SET(eeprom0, DPOT_ADDR_EEPROM | DPOT_RDAC0);\nDPOT_DEVICE_SHOW_ONLY(tolerance0, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC0);\nDPOT_DEVICE_SHOW_SET(otp0, DPOT_ADDR_OTP | DPOT_RDAC0);\nDPOT_DEVICE_SHOW_SET(otp0en, DPOT_ADDR_OTP_EN | DPOT_RDAC0);\n\nDPOT_DEVICE_SHOW_SET(rdac1, DPOT_ADDR_RDAC | DPOT_RDAC1);\nDPOT_DEVICE_SHOW_SET(eeprom1, DPOT_ADDR_EEPROM | DPOT_RDAC1);\nDPOT_DEVICE_SHOW_ONLY(tolerance1, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC1);\nDPOT_DEVICE_SHOW_SET(otp1, DPOT_ADDR_OTP | DPOT_RDAC1);\nDPOT_DEVICE_SHOW_SET(otp1en, DPOT_ADDR_OTP_EN | DPOT_RDAC1);\n\nDPOT_DEVICE_SHOW_SET(rdac2, DPOT_ADDR_RDAC | DPOT_RDAC2);\nDPOT_DEVICE_SHOW_SET(eeprom2, DPOT_ADDR_EEPROM | DPOT_RDAC2);\nDPOT_DEVICE_SHOW_ONLY(tolerance2, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC2);\nDPOT_DEVICE_SHOW_SET(otp2, DPOT_ADDR_OTP | DPOT_RDAC2);\nDPOT_DEVICE_SHOW_SET(otp2en, DPOT_ADDR_OTP_EN | DPOT_RDAC2);\n\nDPOT_DEVICE_SHOW_SET(rdac3, DPOT_ADDR_RDAC | DPOT_RDAC3);\nDPOT_DEVICE_SHOW_SET(eeprom3, DPOT_ADDR_EEPROM | DPOT_RDAC3);\nDPOT_DEVICE_SHOW_ONLY(tolerance3, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC3);\nDPOT_DEVICE_SHOW_SET(otp3, DPOT_ADDR_OTP | DPOT_RDAC3);\nDPOT_DEVICE_SHOW_SET(otp3en, DPOT_ADDR_OTP_EN | DPOT_RDAC3);\n\nDPOT_DEVICE_SHOW_SET(rdac4, DPOT_ADDR_RDAC | DPOT_RDAC4);\nDPOT_DEVICE_SHOW_SET(eeprom4, DPOT_ADDR_EEPROM | DPOT_RDAC4);\nDPOT_DEVICE_SHOW_ONLY(tolerance4, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC4);\nDPOT_DEVICE_SHOW_SET(otp4, DPOT_ADDR_OTP | DPOT_RDAC4);\nDPOT_DEVICE_SHOW_SET(otp4en, DPOT_ADDR_OTP_EN | DPOT_RDAC4);\n\nDPOT_DEVICE_SHOW_SET(rdac5, DPOT_ADDR_RDAC | DPOT_RDAC5);\nDPOT_DEVICE_SHOW_SET(eeprom5, DPOT_ADDR_EEPROM | DPOT_RDAC5);\nDPOT_DEVICE_SHOW_ONLY(tolerance5, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC5);\nDPOT_DEVICE_SHOW_SET(otp5, DPOT_ADDR_OTP | DPOT_RDAC5);\nDPOT_DEVICE_SHOW_SET(otp5en, DPOT_ADDR_OTP_EN | DPOT_RDAC5);\n\nstatic const struct attribute *dpot_attrib_wipers[] = {\n\t&dev_attr_rdac0.attr,\n\t&dev_attr_rdac1.attr,\n\t&dev_attr_rdac2.attr,\n\t&dev_attr_rdac3.attr,\n\t&dev_attr_rdac4.attr,\n\t&dev_attr_rdac5.attr,\n\tNULL\n};\n\nstatic const struct attribute *dpot_attrib_eeprom[] = {\n\t&dev_attr_eeprom0.attr,\n\t&dev_attr_eeprom1.attr,\n\t&dev_attr_eeprom2.attr,\n\t&dev_attr_eeprom3.attr,\n\t&dev_attr_eeprom4.attr,\n\t&dev_attr_eeprom5.attr,\n\tNULL\n};\n\nstatic const struct attribute *dpot_attrib_otp[] = {\n\t&dev_attr_otp0.attr,\n\t&dev_attr_otp1.attr,\n\t&dev_attr_otp2.attr,\n\t&dev_attr_otp3.attr,\n\t&dev_attr_otp4.attr,\n\t&dev_attr_otp5.attr,\n\tNULL\n};\n\nstatic const struct attribute *dpot_attrib_otp_en[] = {\n\t&dev_attr_otp0en.attr,\n\t&dev_attr_otp1en.attr,\n\t&dev_attr_otp2en.attr,\n\t&dev_attr_otp3en.attr,\n\t&dev_attr_otp4en.attr,\n\t&dev_attr_otp5en.attr,\n\tNULL\n};\n\nstatic const struct attribute *dpot_attrib_tolerance[] = {\n\t&dev_attr_tolerance0.attr,\n\t&dev_attr_tolerance1.attr,\n\t&dev_attr_tolerance2.attr,\n\t&dev_attr_tolerance3.attr,\n\t&dev_attr_tolerance4.attr,\n\t&dev_attr_tolerance5.attr,\n\tNULL\n};\n\n \n\n#define DPOT_DEVICE_DO_CMD(_name, _cmd) static ssize_t \\\nset_##_name(struct device *dev, \\\n\t\t\t struct device_attribute *attr, \\\n\t\t\t const char *buf, size_t count) \\\n{ \\\n\treturn sysfs_do_cmd(dev, attr, buf, count, _cmd); \\\n} \\\nstatic DEVICE_ATTR(_name, S_IWUSR | S_IRUGO, NULL, set_##_name)\n\nDPOT_DEVICE_DO_CMD(inc_all, DPOT_INC_ALL);\nDPOT_DEVICE_DO_CMD(dec_all, DPOT_DEC_ALL);\nDPOT_DEVICE_DO_CMD(inc_all_6db, DPOT_INC_ALL_6DB);\nDPOT_DEVICE_DO_CMD(dec_all_6db, DPOT_DEC_ALL_6DB);\n\nstatic struct attribute *ad525x_attributes_commands[] = {\n\t&dev_attr_inc_all.attr,\n\t&dev_attr_dec_all.attr,\n\t&dev_attr_inc_all_6db.attr,\n\t&dev_attr_dec_all_6db.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ad525x_group_commands = {\n\t.attrs = ad525x_attributes_commands,\n};\n\nstatic int ad_dpot_add_files(struct device *dev,\n\t\tunsigned int features, unsigned int rdac)\n{\n\tint err = sysfs_create_file(&dev->kobj,\n\t\tdpot_attrib_wipers[rdac]);\n\tif (features & F_CMD_EEP)\n\t\terr |= sysfs_create_file(&dev->kobj,\n\t\t\tdpot_attrib_eeprom[rdac]);\n\tif (features & F_CMD_TOL)\n\t\terr |= sysfs_create_file(&dev->kobj,\n\t\t\tdpot_attrib_tolerance[rdac]);\n\tif (features & F_CMD_OTP) {\n\t\terr |= sysfs_create_file(&dev->kobj,\n\t\t\tdpot_attrib_otp_en[rdac]);\n\t\terr |= sysfs_create_file(&dev->kobj,\n\t\t\tdpot_attrib_otp[rdac]);\n\t}\n\n\tif (err)\n\t\tdev_err(dev, \"failed to register sysfs hooks for RDAC%d\\n\",\n\t\t\trdac);\n\n\treturn err;\n}\n\nstatic inline void ad_dpot_remove_files(struct device *dev,\n\t\tunsigned int features, unsigned int rdac)\n{\n\tsysfs_remove_file(&dev->kobj,\n\t\tdpot_attrib_wipers[rdac]);\n\tif (features & F_CMD_EEP)\n\t\tsysfs_remove_file(&dev->kobj,\n\t\t\tdpot_attrib_eeprom[rdac]);\n\tif (features & F_CMD_TOL)\n\t\tsysfs_remove_file(&dev->kobj,\n\t\t\tdpot_attrib_tolerance[rdac]);\n\tif (features & F_CMD_OTP) {\n\t\tsysfs_remove_file(&dev->kobj,\n\t\t\tdpot_attrib_otp_en[rdac]);\n\t\tsysfs_remove_file(&dev->kobj,\n\t\t\tdpot_attrib_otp[rdac]);\n\t}\n}\n\nint ad_dpot_probe(struct device *dev,\n\t\tstruct ad_dpot_bus_data *bdata, unsigned long devid,\n\t\t\t    const char *name)\n{\n\n\tstruct dpot_data *data;\n\tint i, err = 0;\n\n\tdata = kzalloc(sizeof(struct dpot_data), GFP_KERNEL);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tdev_set_drvdata(dev, data);\n\tmutex_init(&data->update_lock);\n\n\tdata->bdata = *bdata;\n\tdata->devid = devid;\n\n\tdata->max_pos = 1 << DPOT_MAX_POS(devid);\n\tdata->rdac_mask = data->max_pos - 1;\n\tdata->feat = DPOT_FEAT(devid);\n\tdata->uid = DPOT_UID(devid);\n\tdata->wipers = DPOT_WIPERS(devid);\n\n\tfor (i = DPOT_RDAC0; i < MAX_RDACS; i++)\n\t\tif (data->wipers & (1 << i)) {\n\t\t\terr = ad_dpot_add_files(dev, data->feat, i);\n\t\t\tif (err)\n\t\t\t\tgoto exit_remove_files;\n\t\t\t \n\t\t\tif (data->feat & F_RDACS_WONLY)\n\t\t\t\tdata->rdac_cache[i] = data->max_pos / 2;\n\t\t}\n\n\tif (data->feat & F_CMD_INC)\n\t\terr = sysfs_create_group(&dev->kobj, &ad525x_group_commands);\n\n\tif (err) {\n\t\tdev_err(dev, \"failed to register sysfs hooks\\n\");\n\t\tgoto exit_free;\n\t}\n\n\tdev_info(dev, \"%s %d-Position Digital Potentiometer registered\\n\",\n\t\t name, data->max_pos);\n\n\treturn 0;\n\nexit_remove_files:\n\tfor (i = DPOT_RDAC0; i < MAX_RDACS; i++)\n\t\tif (data->wipers & (1 << i))\n\t\t\tad_dpot_remove_files(dev, data->feat, i);\n\nexit_free:\n\tkfree(data);\n\tdev_set_drvdata(dev, NULL);\nexit:\n\tdev_err(dev, \"failed to create client for %s ID 0x%lX\\n\",\n\t\tname, devid);\n\treturn err;\n}\nEXPORT_SYMBOL(ad_dpot_probe);\n\nvoid ad_dpot_remove(struct device *dev)\n{\n\tstruct dpot_data *data = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = DPOT_RDAC0; i < MAX_RDACS; i++)\n\t\tif (data->wipers & (1 << i))\n\t\t\tad_dpot_remove_files(dev, data->feat, i);\n\n\tkfree(data);\n}\nEXPORT_SYMBOL(ad_dpot_remove);\n\n\nMODULE_AUTHOR(\"Chris Verges <chrisv@cyberswitching.com>, \"\n\t      \"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Digital potentiometer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}