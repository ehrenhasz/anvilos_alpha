{
  "module_name": "of.c",
  "hash_id": "c098ebafdafc41415af5c51e56dedf495bdfb8f31fe78a882936a62beb1cb194",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cxl/of.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n\n#include \"cxl.h\"\n\n\nstatic const __be32 *read_prop_string(const struct device_node *np,\n\t\t\t\tconst char *prop_name)\n{\n\tconst __be32 *prop;\n\n\tprop = of_get_property(np, prop_name, NULL);\n\tif (cxl_verbose && prop)\n\t\tpr_info(\"%s: %s\\n\", prop_name, (char *) prop);\n\treturn prop;\n}\n\nstatic const __be32 *read_prop_dword(const struct device_node *np,\n\t\t\t\tconst char *prop_name, u32 *val)\n{\n\tconst __be32 *prop;\n\n\tprop = of_get_property(np, prop_name, NULL);\n\tif (prop)\n\t\t*val = be32_to_cpu(prop[0]);\n\tif (cxl_verbose && prop)\n\t\tpr_info(\"%s: %#x (%u)\\n\", prop_name, *val, *val);\n\treturn prop;\n}\n\nstatic const __be64 *read_prop64_dword(const struct device_node *np,\n\t\t\t\tconst char *prop_name, u64 *val)\n{\n\tconst __be64 *prop;\n\n\tprop = of_get_property(np, prop_name, NULL);\n\tif (prop)\n\t\t*val = be64_to_cpu(prop[0]);\n\tif (cxl_verbose && prop)\n\t\tpr_info(\"%s: %#llx (%llu)\\n\", prop_name, *val, *val);\n\treturn prop;\n}\n\n\nstatic int read_handle(struct device_node *np, u64 *handle)\n{\n\tconst __be32 *prop;\n\tu64 size;\n\n\t \n\tprop = of_get_address(np, 0, &size, NULL);\n\tif (size)\n\t\treturn -EINVAL;\n\n\t \n\t*handle = of_read_number(prop, of_n_addr_cells(np));\n\treturn 0;\n}\n\nstatic int read_phys_addr(struct device_node *np, char *prop_name,\n\t\t\tstruct cxl_afu *afu)\n{\n\tint i, len, entry_size, naddr, nsize, type;\n\tu64 addr, size;\n\tconst __be32 *prop;\n\n\tnaddr = of_n_addr_cells(np);\n\tnsize = of_n_size_cells(np);\n\n\tprop = of_get_property(np, prop_name, &len);\n\tif (prop) {\n\t\tentry_size = naddr + nsize;\n\t\tfor (i = 0; i < (len / 4); i += entry_size, prop += entry_size) {\n\t\t\ttype = be32_to_cpu(prop[0]);\n\t\t\taddr = of_read_number(prop, naddr);\n\t\t\tsize = of_read_number(&prop[naddr], nsize);\n\t\t\tswitch (type) {\n\t\t\tcase 0:  \n\t\t\t\tafu->guest->handle = addr;\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\tafu->guest->p2n_phys += addr;\n\t\t\t\tafu->guest->p2n_size = size;\n\t\t\t\tbreak;\n\t\t\tcase 2:  \n\t\t\t\tafu->psn_phys += addr;\n\t\t\t\tafu->adapter->ps_size = size;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_err(\"Invalid address type %d found in %s property of AFU\\n\",\n\t\t\t\t\ttype, prop_name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (cxl_verbose)\n\t\t\t\tpr_info(\"%s: %#x %#llx (size %#llx)\\n\",\n\t\t\t\t\tprop_name, type, addr, size);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int read_vpd(struct cxl *adapter, struct cxl_afu *afu)\n{\n\tchar vpd[256];\n\tint rc;\n\tsize_t len = sizeof(vpd);\n\n\tmemset(vpd, 0, len);\n\n\tif (adapter)\n\t\trc = cxl_guest_read_adapter_vpd(adapter, vpd, len);\n\telse\n\t\trc = cxl_guest_read_afu_vpd(afu, vpd, len);\n\n\tif (rc > 0) {\n\t\tcxl_dump_debug_buffer(vpd, rc);\n\t\trc = 0;\n\t}\n\treturn rc;\n}\n\nint cxl_of_read_afu_handle(struct cxl_afu *afu, struct device_node *afu_np)\n{\n\tif (read_handle(afu_np, &afu->guest->handle))\n\t\treturn -EINVAL;\n\tpr_devel(\"AFU handle: 0x%.16llx\\n\", afu->guest->handle);\n\n\treturn 0;\n}\n\nint cxl_of_read_afu_properties(struct cxl_afu *afu, struct device_node *np)\n{\n\tint i, len, rc;\n\tchar *p;\n\tconst __be32 *prop;\n\tu16 device_id, vendor_id;\n\tu32 val = 0, class_code;\n\n\t \n\n\tif (cxl_verbose) {\n\t\tpr_info(\"Dump of the 'ibm,coherent-platform-function' node properties:\\n\");\n\n\t\tprop = of_get_property(np, \"compatible\", &len);\n\t\ti = 0;\n\t\twhile (i < len) {\n\t\t\tp = (char *) prop + i;\n\t\t\tpr_info(\"compatible: %s\\n\", p);\n\t\t\ti += strlen(p) + 1;\n\t\t}\n\t\tread_prop_string(np, \"name\");\n\t}\n\n\trc = read_phys_addr(np, \"reg\", afu);\n\tif (rc)\n\t\treturn rc;\n\n\trc = read_phys_addr(np, \"assigned-addresses\", afu);\n\tif (rc)\n\t\treturn rc;\n\n\tif (afu->psn_phys == 0)\n\t\tafu->psa = false;\n\telse\n\t\tafu->psa = true;\n\n\tif (cxl_verbose) {\n\t\tread_prop_string(np, \"ibm,loc-code\");\n\t\tread_prop_string(np, \"device_type\");\n\t}\n\n\tread_prop_dword(np, \"ibm,#processes\", &afu->max_procs_virtualised);\n\n\tif (cxl_verbose) {\n\t\tread_prop_dword(np, \"ibm,scratchpad-size\", &val);\n\t\tread_prop_dword(np, \"ibm,programmable\", &val);\n\t\tread_prop_string(np, \"ibm,phandle\");\n\t\tread_vpd(NULL, afu);\n\t}\n\n\tread_prop_dword(np, \"ibm,max-ints-per-process\", &afu->guest->max_ints);\n\tafu->irqs_max = afu->guest->max_ints;\n\n\tprop = read_prop_dword(np, \"ibm,min-ints-per-process\", &afu->pp_irqs);\n\tif (prop) {\n\t\t \n\t\tafu->pp_irqs--;\n\t}\n\n\tif (cxl_verbose) {\n\t\tread_prop_dword(np, \"ibm,max-ints\", &val);\n\t\tread_prop_dword(np, \"ibm,vpd-size\", &val);\n\t}\n\n\tread_prop64_dword(np, \"ibm,error-buffer-size\", &afu->eb_len);\n\tafu->eb_offset = 0;\n\n\tif (cxl_verbose)\n\t\tread_prop_dword(np, \"ibm,config-record-type\", &val);\n\n\tread_prop64_dword(np, \"ibm,config-record-size\", &afu->crs_len);\n\tafu->crs_offset = 0;\n\n\tread_prop_dword(np, \"ibm,#config-records\", &afu->crs_num);\n\n\tif (cxl_verbose) {\n\t\tfor (i = 0; i < afu->crs_num; i++) {\n\t\t\trc = cxl_ops->afu_cr_read16(afu, i, PCI_DEVICE_ID,\n\t\t\t\t\t\t&device_id);\n\t\t\tif (!rc)\n\t\t\t\tpr_info(\"record %d - device-id: %#x\\n\",\n\t\t\t\t\ti, device_id);\n\t\t\trc = cxl_ops->afu_cr_read16(afu, i, PCI_VENDOR_ID,\n\t\t\t\t\t\t&vendor_id);\n\t\t\tif (!rc)\n\t\t\t\tpr_info(\"record %d - vendor-id: %#x\\n\",\n\t\t\t\t\ti, vendor_id);\n\t\t\trc = cxl_ops->afu_cr_read32(afu, i, PCI_CLASS_REVISION,\n\t\t\t\t\t\t&class_code);\n\t\t\tif (!rc) {\n\t\t\t\tclass_code >>= 8;\n\t\t\t\tpr_info(\"record %d - class-code: %#x\\n\",\n\t\t\t\t\ti, class_code);\n\t\t\t}\n\t\t}\n\n\t\tread_prop_dword(np, \"ibm,function-number\", &val);\n\t\tread_prop_dword(np, \"ibm,privileged-function\", &val);\n\t\tread_prop_dword(np, \"vendor-id\", &val);\n\t\tread_prop_dword(np, \"device-id\", &val);\n\t\tread_prop_dword(np, \"revision-id\", &val);\n\t\tread_prop_dword(np, \"class-code\", &val);\n\t\tread_prop_dword(np, \"subsystem-vendor-id\", &val);\n\t\tread_prop_dword(np, \"subsystem-id\", &val);\n\t}\n\t \n\tval = 0;\n\tprop = read_prop_dword(np, \"ibm,process-mmio\", &val);\n\tif (prop && val == 1)\n\t\tafu->pp_psa = true;\n\telse\n\t\tafu->pp_psa = false;\n\n\tif (cxl_verbose) {\n\t\tread_prop_dword(np, \"ibm,supports-aur\", &val);\n\t\tread_prop_dword(np, \"ibm,supports-csrp\", &val);\n\t\tread_prop_dword(np, \"ibm,supports-prr\", &val);\n\t}\n\n\tprop = read_prop_dword(np, \"ibm,function-error-interrupt\", &val);\n\tif (prop)\n\t\tafu->serr_hwirq = val;\n\n\tpr_devel(\"AFU handle: %#llx\\n\", afu->guest->handle);\n\tpr_devel(\"p2n_phys: %#llx (size %#llx)\\n\",\n\t\tafu->guest->p2n_phys, afu->guest->p2n_size);\n\tpr_devel(\"psn_phys: %#llx (size %#llx)\\n\",\n\t\tafu->psn_phys, afu->adapter->ps_size);\n\tpr_devel(\"Max number of processes virtualised=%i\\n\",\n\t\tafu->max_procs_virtualised);\n\tpr_devel(\"Per-process irqs min=%i, max=%i\\n\", afu->pp_irqs,\n\t\t afu->irqs_max);\n\tpr_devel(\"Slice error interrupt=%#lx\\n\", afu->serr_hwirq);\n\n\treturn 0;\n}\n\nstatic int read_adapter_irq_config(struct cxl *adapter, struct device_node *np)\n{\n\tconst __be32 *ranges;\n\tint len, nranges, i;\n\tstruct irq_avail *cur;\n\n\tranges = of_get_property(np, \"interrupt-ranges\", &len);\n\tif (ranges == NULL || len < (2 * sizeof(int)))\n\t\treturn -EINVAL;\n\n\t \n\tnranges = len / (2 * sizeof(int));\n\tif (nranges == 0 || (nranges * 2 * sizeof(int)) != len)\n\t\treturn -EINVAL;\n\n\tadapter->guest->irq_avail = kcalloc(nranges, sizeof(struct irq_avail),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (adapter->guest->irq_avail == NULL)\n\t\treturn -ENOMEM;\n\n\tadapter->guest->irq_base_offset = be32_to_cpu(ranges[0]);\n\tfor (i = 0; i < nranges; i++) {\n\t\tcur = &adapter->guest->irq_avail[i];\n\t\tcur->offset = be32_to_cpu(ranges[i * 2]);\n\t\tcur->range  = be32_to_cpu(ranges[i * 2 + 1]);\n\t\tcur->bitmap = bitmap_zalloc(cur->range, GFP_KERNEL);\n\t\tif (cur->bitmap == NULL)\n\t\t\tgoto err;\n\t\tif (cur->offset < adapter->guest->irq_base_offset)\n\t\t\tadapter->guest->irq_base_offset = cur->offset;\n\t\tif (cxl_verbose)\n\t\t\tpr_info(\"available IRQ range: %#lx-%#lx (%lu)\\n\",\n\t\t\t\tcur->offset, cur->offset + cur->range - 1,\n\t\t\t\tcur->range);\n\t}\n\tadapter->guest->irq_nranges = nranges;\n\tspin_lock_init(&adapter->guest->irq_alloc_lock);\n\n\treturn 0;\nerr:\n\tfor (i--; i >= 0; i--) {\n\t\tcur = &adapter->guest->irq_avail[i];\n\t\tbitmap_free(cur->bitmap);\n\t}\n\tkfree(adapter->guest->irq_avail);\n\tadapter->guest->irq_avail = NULL;\n\treturn -ENOMEM;\n}\n\nint cxl_of_read_adapter_handle(struct cxl *adapter, struct device_node *np)\n{\n\tif (read_handle(np, &adapter->guest->handle))\n\t\treturn -EINVAL;\n\tpr_devel(\"Adapter handle: 0x%.16llx\\n\", adapter->guest->handle);\n\n\treturn 0;\n}\n\nint cxl_of_read_adapter_properties(struct cxl *adapter, struct device_node *np)\n{\n\tint rc, len, naddr, i;\n\tchar *p;\n\tconst __be32 *prop;\n\tu32 val = 0;\n\n\t \n\n\tnaddr = of_n_addr_cells(np);\n\n\tif (cxl_verbose) {\n\t\tpr_info(\"Dump of the 'ibm,coherent-platform-facility' node properties:\\n\");\n\n\t\tread_prop_dword(np, \"#address-cells\", &val);\n\t\tread_prop_dword(np, \"#size-cells\", &val);\n\n\t\tprop = of_get_property(np, \"compatible\", &len);\n\t\ti = 0;\n\t\twhile (i < len) {\n\t\t\tp = (char *) prop + i;\n\t\t\tpr_info(\"compatible: %s\\n\", p);\n\t\t\ti += strlen(p) + 1;\n\t\t}\n\t\tread_prop_string(np, \"name\");\n\t\tread_prop_string(np, \"model\");\n\n\t\tprop = of_get_property(np, \"reg\", NULL);\n\t\tif (prop) {\n\t\t\tpr_info(\"reg: addr:%#llx size:%#x\\n\",\n\t\t\t\tof_read_number(prop, naddr),\n\t\t\t\tbe32_to_cpu(prop[naddr]));\n\t\t}\n\n\t\tread_prop_string(np, \"ibm,loc-code\");\n\t}\n\n\tif ((rc = read_adapter_irq_config(adapter, np)))\n\t\treturn rc;\n\n\tif (cxl_verbose) {\n\t\tread_prop_string(np, \"device_type\");\n\t\tread_prop_string(np, \"ibm,phandle\");\n\t}\n\n\tprop = read_prop_dword(np, \"ibm,caia-version\", &val);\n\tif (prop) {\n\t\tadapter->caia_major = (val & 0xFF00) >> 8;\n\t\tadapter->caia_minor = val & 0xFF;\n\t}\n\n\tprop = read_prop_dword(np, \"ibm,psl-revision\", &val);\n\tif (prop)\n\t\tadapter->psl_rev = val;\n\n\tprop = read_prop_string(np, \"status\");\n\tif (prop) {\n\t\tadapter->guest->status = kasprintf(GFP_KERNEL, \"%s\", (char *) prop);\n\t\tif (adapter->guest->status == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tprop = read_prop_dword(np, \"vendor-id\", &val);\n\tif (prop)\n\t\tadapter->guest->vendor = val;\n\n\tprop = read_prop_dword(np, \"device-id\", &val);\n\tif (prop)\n\t\tadapter->guest->device = val;\n\n\tif (cxl_verbose) {\n\t\tread_prop_dword(np, \"ibm,privileged-facility\", &val);\n\t\tread_prop_dword(np, \"revision-id\", &val);\n\t\tread_prop_dword(np, \"class-code\", &val);\n\t}\n\n\tprop = read_prop_dword(np, \"subsystem-vendor-id\", &val);\n\tif (prop)\n\t\tadapter->guest->subsystem_vendor = val;\n\n\tprop = read_prop_dword(np, \"subsystem-id\", &val);\n\tif (prop)\n\t\tadapter->guest->subsystem = val;\n\n\tif (cxl_verbose)\n\t\tread_vpd(adapter, NULL);\n\n\treturn 0;\n}\n\nstatic int cxl_of_remove(struct platform_device *pdev)\n{\n\tstruct cxl *adapter;\n\tint afu;\n\n\tadapter = dev_get_drvdata(&pdev->dev);\n\tfor (afu = 0; afu < adapter->slices; afu++)\n\t\tcxl_guest_remove_afu(adapter->afu[afu]);\n\n\tcxl_guest_remove_adapter(adapter);\n\treturn 0;\n}\n\nstatic void cxl_of_shutdown(struct platform_device *pdev)\n{\n\tcxl_of_remove(pdev);\n}\n\nint cxl_of_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = NULL;\n\tstruct device_node *afu_np = NULL;\n\tstruct cxl *adapter = NULL;\n\tint ret;\n\tint slice = 0, slice_ok = 0;\n\n\tpr_devel(\"in %s\\n\", __func__);\n\n\tnp = pdev->dev.of_node;\n\tif (np == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tadapter = cxl_guest_init_adapter(np, pdev);\n\tif (IS_ERR(adapter)) {\n\t\tdev_err(&pdev->dev, \"guest_init_adapter failed: %li\\n\", PTR_ERR(adapter));\n\t\treturn PTR_ERR(adapter);\n\t}\n\n\t \n\tfor_each_child_of_node(np, afu_np) {\n\t\tif ((ret = cxl_guest_init_afu(adapter, slice, afu_np)))\n\t\t\tdev_err(&pdev->dev, \"AFU %i failed to initialise: %i\\n\",\n\t\t\t\tslice, ret);\n\t\telse\n\t\t\tslice_ok++;\n\t\tslice++;\n\t}\n\n\tif (slice_ok == 0) {\n\t\tdev_info(&pdev->dev, \"No active AFU\");\n\t\tadapter->slices = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cxl_of_match[] = {\n\t{ .compatible = \"ibm,coherent-platform-facility\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cxl_of_match);\n\nstruct platform_driver cxl_of_driver = {\n\t.driver = {\n\t\t.name = \"cxl_of\",\n\t\t.of_match_table = cxl_of_match,\n\t\t.owner = THIS_MODULE\n\t},\n\t.probe = cxl_of_probe,\n\t.remove = cxl_of_remove,\n\t.shutdown = cxl_of_shutdown,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}