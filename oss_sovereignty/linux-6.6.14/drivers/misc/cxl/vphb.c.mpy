{
  "module_name": "vphb.c",
  "hash_id": "4ee6814c6dabb8d7c27776160176078a3b5e7dd8cc38fee0b9de13581ef5b4b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cxl/vphb.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <misc/cxl.h>\n#include \"cxl.h\"\n\nstatic int cxl_pci_probe_mode(struct pci_bus *bus)\n{\n\treturn PCI_PROBE_NORMAL;\n}\n\nstatic int cxl_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)\n{\n\treturn -ENODEV;\n}\n\nstatic void cxl_teardown_msi_irqs(struct pci_dev *pdev)\n{\n\t \n}\n\nstatic bool cxl_pci_enable_device_hook(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\tstruct cxl_afu *afu;\n\tstruct cxl_context *ctx;\n\n\tphb = pci_bus_to_host(dev->bus);\n\tafu = (struct cxl_afu *)phb->private_data;\n\n\tif (!cxl_ops->link_ok(afu->adapter, afu)) {\n\t\tdev_warn(&dev->dev, \"%s: Device link is down, refusing to enable AFU\\n\", __func__);\n\t\treturn false;\n\t}\n\n\tdev->dev.archdata.dma_offset = PAGE_OFFSET;\n\n\t \n\tctx = cxl_dev_context_init(dev);\n\tif (IS_ERR(ctx))\n\t\treturn false;\n\tdev->dev.archdata.cxl_ctx = ctx;\n\n\treturn (cxl_ops->afu_check_and_enable(afu) == 0);\n}\n\nstatic void cxl_pci_disable_device(struct pci_dev *dev)\n{\n\tstruct cxl_context *ctx = cxl_get_context(dev);\n\n\tif (ctx) {\n\t\tif (ctx->status == STARTED) {\n\t\t\tdev_err(&dev->dev, \"Default context started\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdev->dev.archdata.cxl_ctx = NULL;\n\t\tcxl_release_context(ctx);\n\t}\n}\n\nstatic void cxl_pci_reset_secondary_bus(struct pci_dev *dev)\n{\n\t \n}\n\nstatic int cxl_pcie_cfg_record(u8 bus, u8 devfn)\n{\n\treturn (bus << 8) + devfn;\n}\n\nstatic inline struct cxl_afu *pci_bus_to_afu(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb = bus ? pci_bus_to_host(bus) : NULL;\n\n\treturn phb ? phb->private_data : NULL;\n}\n\nstatic void cxl_afu_configured_put(struct cxl_afu *afu)\n{\n\tatomic_dec_if_positive(&afu->configured_state);\n}\n\nstatic bool cxl_afu_configured_get(struct cxl_afu *afu)\n{\n\treturn atomic_inc_unless_negative(&afu->configured_state);\n}\n\nstatic inline int cxl_pcie_config_info(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t       struct cxl_afu *afu, int *_record)\n{\n\tint record;\n\n\trecord = cxl_pcie_cfg_record(bus->number, devfn);\n\tif (record > afu->crs_num)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t*_record = record;\n\treturn 0;\n}\n\nstatic int cxl_pcie_read_config(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\tint offset, int len, u32 *val)\n{\n\tint rc, record;\n\tstruct cxl_afu *afu;\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\n\tafu = pci_bus_to_afu(bus);\n\t \n\tif (afu == NULL || !cxl_afu_configured_get(afu))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\trc = cxl_pcie_config_info(bus, devfn, afu, &record);\n\tif (rc)\n\t\tgoto out;\n\n\tswitch (len) {\n\tcase 1:\n\t\trc = cxl_ops->afu_cr_read8(afu, record, offset,\t&val8);\n\t\t*val = val8;\n\t\tbreak;\n\tcase 2:\n\t\trc = cxl_ops->afu_cr_read16(afu, record, offset, &val16);\n\t\t*val = val16;\n\t\tbreak;\n\tcase 4:\n\t\trc = cxl_ops->afu_cr_read32(afu, record, offset, &val32);\n\t\t*val = val32;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\nout:\n\tcxl_afu_configured_put(afu);\n\treturn rc ? PCIBIOS_DEVICE_NOT_FOUND : 0;\n}\n\nstatic int cxl_pcie_write_config(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t int offset, int len, u32 val)\n{\n\tint rc, record;\n\tstruct cxl_afu *afu;\n\n\tafu = pci_bus_to_afu(bus);\n\t \n\tif (afu == NULL || !cxl_afu_configured_get(afu))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\trc = cxl_pcie_config_info(bus, devfn, afu, &record);\n\tif (rc)\n\t\tgoto out;\n\n\tswitch (len) {\n\tcase 1:\n\t\trc = cxl_ops->afu_cr_write8(afu, record, offset, val & 0xff);\n\t\tbreak;\n\tcase 2:\n\t\trc = cxl_ops->afu_cr_write16(afu, record, offset, val & 0xffff);\n\t\tbreak;\n\tcase 4:\n\t\trc = cxl_ops->afu_cr_write32(afu, record, offset, val);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\nout:\n\tcxl_afu_configured_put(afu);\n\treturn rc ? PCIBIOS_SET_FAILED : 0;\n}\n\nstatic struct pci_ops cxl_pcie_pci_ops =\n{\n\t.read = cxl_pcie_read_config,\n\t.write = cxl_pcie_write_config,\n};\n\n\nstatic struct pci_controller_ops cxl_pci_controller_ops =\n{\n\t.probe_mode = cxl_pci_probe_mode,\n\t.enable_device_hook = cxl_pci_enable_device_hook,\n\t.disable_device = cxl_pci_disable_device,\n\t.release_device = cxl_pci_disable_device,\n\t.reset_secondary_bus = cxl_pci_reset_secondary_bus,\n\t.setup_msi_irqs = cxl_setup_msi_irqs,\n\t.teardown_msi_irqs = cxl_teardown_msi_irqs,\n};\n\nint cxl_pci_vphb_add(struct cxl_afu *afu)\n{\n\tstruct pci_controller *phb;\n\tstruct device_node *vphb_dn;\n\tstruct device *parent;\n\n\t \n\tif (!afu->crs_num)\n\t\treturn 0;\n\n\t \n\tparent = afu->adapter->dev.parent;\n\tvphb_dn = parent->of_node;\n\n\t \n\tphb = pcibios_alloc_controller(vphb_dn);\n\tif (!phb)\n\t\treturn -ENODEV;\n\n\t \n\tphb->parent = parent;\n\n\t \n\tphb->ops = &cxl_pcie_pci_ops;\n\tphb->cfg_addr = NULL;\n\tphb->cfg_data = NULL;\n\tphb->private_data = afu;\n\tphb->controller_ops = cxl_pci_controller_ops;\n\n\t \n\tpcibios_scan_phb(phb);\n\tif (phb->bus == NULL)\n\t\treturn -ENXIO;\n\n\t \n\tpci_set_host_bridge_release(to_pci_host_bridge(phb->bus->bridge),\n\t\t\t\t    pcibios_free_controller_deferred,\n\t\t\t\t    (void *) phb);\n\n\t \n\tpcibios_claim_one_bus(phb->bus);\n\n\t \n\tpci_bus_add_devices(phb->bus);\n\n\tafu->phb = phb;\n\n\treturn 0;\n}\n\nvoid cxl_pci_vphb_remove(struct cxl_afu *afu)\n{\n\tstruct pci_controller *phb;\n\n\t \n\tif (!afu || !afu->phb)\n\t\treturn;\n\n\tphb = afu->phb;\n\tafu->phb = NULL;\n\n\tpci_remove_root_bus(phb->bus);\n\t \n}\n\nbool cxl_pci_is_vphb_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\n\tphb = pci_bus_to_host(dev->bus);\n\n\treturn (phb->ops == &cxl_pcie_pci_ops);\n}\n\nstruct cxl_afu *cxl_pci_to_afu(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\n\tphb = pci_bus_to_host(dev->bus);\n\n\treturn (struct cxl_afu *)phb->private_data;\n}\nEXPORT_SYMBOL_GPL(cxl_pci_to_afu);\n\nunsigned int cxl_pci_to_cfg_record(struct pci_dev *dev)\n{\n\treturn cxl_pcie_cfg_record(dev->bus->number, dev->devfn);\n}\nEXPORT_SYMBOL_GPL(cxl_pci_to_cfg_record);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}