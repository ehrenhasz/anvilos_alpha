{
  "module_name": "sysfs.c",
  "hash_id": "0515304f9df4d32a02df3359d1472c9fe92711348e8ae6cc6364508db52e54c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cxl/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/pci_regs.h>\n\n#include \"cxl.h\"\n\n#define to_afu_chardev_m(d) dev_get_drvdata(d)\n\n \n\nstatic ssize_t caia_version_show(struct device *device,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct cxl *adapter = to_cxl_adapter(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%i.%i\\n\", adapter->caia_major,\n\t\t\t adapter->caia_minor);\n}\n\nstatic ssize_t psl_revision_show(struct device *device,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct cxl *adapter = to_cxl_adapter(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", adapter->psl_rev);\n}\n\nstatic ssize_t base_image_show(struct device *device,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct cxl *adapter = to_cxl_adapter(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", adapter->base_image);\n}\n\nstatic ssize_t image_loaded_show(struct device *device,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct cxl *adapter = to_cxl_adapter(device);\n\n\tif (adapter->user_image_loaded)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"user\\n\");\n\treturn scnprintf(buf, PAGE_SIZE, \"factory\\n\");\n}\n\nstatic ssize_t psl_timebase_synced_show(struct device *device,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct cxl *adapter = to_cxl_adapter(device);\n\tu64 psl_tb, delta;\n\n\t \n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\tpsl_tb = adapter->native->sl_ops->timebase_read(adapter);\n\t\tdelta = abs(mftb() - psl_tb);\n\n\t\t \n\t\tadapter->psl_timebase_synced = (tb_to_ns(delta) < 16000) ? true : false;\n\t\tpr_devel(\"PSL timebase %s - delta: 0x%016llx\\n\",\n\t\t\t (tb_to_ns(delta) < 16000) ? \"synchronized\" :\n\t\t\t \"not synchronized\", tb_to_ns(delta));\n\t}\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", adapter->psl_timebase_synced);\n}\n\nstatic ssize_t tunneled_ops_supported_show(struct device *device,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct cxl *adapter = to_cxl_adapter(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", adapter->tunneled_ops_supported);\n}\n\nstatic ssize_t reset_adapter_store(struct device *device,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct cxl *adapter = to_cxl_adapter(device);\n\tint rc;\n\tint val;\n\n\trc = sscanf(buf, \"%i\", &val);\n\tif ((rc != 1) || (val != 1 && val != -1))\n\t\treturn -EINVAL;\n\n\t \n\tif (val == 1) {\n\t\trc =  cxl_adapter_context_lock(adapter);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = cxl_ops->adapter_reset(adapter);\n\t\t \n\t\tif (rc)\n\t\t\tcxl_adapter_context_unlock(adapter);\n\n\t} else if (val == -1) {\n\t\t \n\t\trc = cxl_ops->adapter_reset(adapter);\n\t}\n\nout:\n\treturn rc ? rc : count;\n}\n\nstatic ssize_t load_image_on_perst_show(struct device *device,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct cxl *adapter = to_cxl_adapter(device);\n\n\tif (!adapter->perst_loads_image)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"none\\n\");\n\n\tif (adapter->perst_select_user)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"user\\n\");\n\treturn scnprintf(buf, PAGE_SIZE, \"factory\\n\");\n}\n\nstatic ssize_t load_image_on_perst_store(struct device *device,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct cxl *adapter = to_cxl_adapter(device);\n\tint rc;\n\n\tif (!strncmp(buf, \"none\", 4))\n\t\tadapter->perst_loads_image = false;\n\telse if (!strncmp(buf, \"user\", 4)) {\n\t\tadapter->perst_select_user = true;\n\t\tadapter->perst_loads_image = true;\n\t} else if (!strncmp(buf, \"factory\", 7)) {\n\t\tadapter->perst_select_user = false;\n\t\tadapter->perst_loads_image = true;\n\t} else\n\t\treturn -EINVAL;\n\n\tif ((rc = cxl_update_image_control(adapter)))\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic ssize_t perst_reloads_same_image_show(struct device *device,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct cxl *adapter = to_cxl_adapter(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", adapter->perst_same_image);\n}\n\nstatic ssize_t perst_reloads_same_image_store(struct device *device,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct cxl *adapter = to_cxl_adapter(device);\n\tint rc;\n\tint val;\n\n\trc = sscanf(buf, \"%i\", &val);\n\tif ((rc != 1) || !(val == 1 || val == 0))\n\t\treturn -EINVAL;\n\n\tadapter->perst_same_image = (val == 1);\n\treturn count;\n}\n\nstatic struct device_attribute adapter_attrs[] = {\n\t__ATTR_RO(caia_version),\n\t__ATTR_RO(psl_revision),\n\t__ATTR_RO(base_image),\n\t__ATTR_RO(image_loaded),\n\t__ATTR_RO(psl_timebase_synced),\n\t__ATTR_RO(tunneled_ops_supported),\n\t__ATTR_RW(load_image_on_perst),\n\t__ATTR_RW(perst_reloads_same_image),\n\t__ATTR(reset, S_IWUSR, NULL, reset_adapter_store),\n};\n\n\n \n\nstatic ssize_t mmio_size_show_master(struct device *device,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct cxl_afu *afu = to_afu_chardev_m(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\", afu->adapter->ps_size);\n}\n\nstatic ssize_t pp_mmio_off_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct cxl_afu *afu = to_afu_chardev_m(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\", afu->native->pp_offset);\n}\n\nstatic ssize_t pp_mmio_len_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct cxl_afu *afu = to_afu_chardev_m(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\", afu->pp_size);\n}\n\nstatic struct device_attribute afu_master_attrs[] = {\n\t__ATTR(mmio_size, S_IRUGO, mmio_size_show_master, NULL),\n\t__ATTR_RO(pp_mmio_off),\n\t__ATTR_RO(pp_mmio_len),\n};\n\n\n \n\nstatic ssize_t mmio_size_show(struct device *device,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(device);\n\n\tif (afu->pp_size)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\", afu->pp_size);\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\", afu->adapter->ps_size);\n}\n\nstatic ssize_t reset_store_afu(struct device *device,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(device);\n\tint rc;\n\n\t \n\tmutex_lock(&afu->contexts_lock);\n\tif (!idr_is_empty(&afu->contexts_idr)) {\n\t\trc = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tif ((rc = cxl_ops->afu_reset(afu)))\n\t\tgoto err;\n\n\trc = count;\nerr:\n\tmutex_unlock(&afu->contexts_lock);\n\treturn rc;\n}\n\nstatic ssize_t irqs_min_show(struct device *device,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", afu->pp_irqs);\n}\n\nstatic ssize_t irqs_max_show(struct device *device,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(device);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", afu->irqs_max);\n}\n\nstatic ssize_t irqs_max_store(struct device *device,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(device);\n\tssize_t ret;\n\tint irqs_max;\n\n\tret = sscanf(buf, \"%i\", &irqs_max);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tif (irqs_max < afu->pp_irqs)\n\t\treturn -EINVAL;\n\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\tif (irqs_max > afu->adapter->user_irqs)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tif (irqs_max > afu->guest->max_ints)\n\t\t\treturn -EINVAL;\n\t}\n\n\tafu->irqs_max = irqs_max;\n\treturn count;\n}\n\nstatic ssize_t modes_supported_show(struct device *device,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(device);\n\tchar *p = buf, *end = buf + PAGE_SIZE;\n\n\tif (afu->modes_supported & CXL_MODE_DEDICATED)\n\t\tp += scnprintf(p, end - p, \"dedicated_process\\n\");\n\tif (afu->modes_supported & CXL_MODE_DIRECTED)\n\t\tp += scnprintf(p, end - p, \"afu_directed\\n\");\n\treturn (p - buf);\n}\n\nstatic ssize_t prefault_mode_show(struct device *device,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(device);\n\n\tswitch (afu->prefault_mode) {\n\tcase CXL_PREFAULT_WED:\n\t\treturn scnprintf(buf, PAGE_SIZE, \"work_element_descriptor\\n\");\n\tcase CXL_PREFAULT_ALL:\n\t\treturn scnprintf(buf, PAGE_SIZE, \"all\\n\");\n\tdefault:\n\t\treturn scnprintf(buf, PAGE_SIZE, \"none\\n\");\n\t}\n}\n\nstatic ssize_t prefault_mode_store(struct device *device,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(device);\n\tenum prefault_modes mode = -1;\n\n\tif (!strncmp(buf, \"none\", 4))\n\t\tmode = CXL_PREFAULT_NONE;\n\telse {\n\t\tif (!radix_enabled()) {\n\n\t\t\t \n\t\t\tif (!strncmp(buf, \"work_element_descriptor\", 23))\n\t\t\t\tmode = CXL_PREFAULT_WED;\n\t\t\tif (!strncmp(buf, \"all\", 3))\n\t\t\t\tmode = CXL_PREFAULT_ALL;\n\t\t} else {\n\t\t\tdev_err(device, \"Cannot prefault with radix enabled\\n\");\n\t\t}\n\t}\n\n\tif (mode == -1)\n\t\treturn -EINVAL;\n\n\tafu->prefault_mode = mode;\n\treturn count;\n}\n\nstatic ssize_t mode_show(struct device *device,\n\t\t\t struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(device);\n\n\tif (afu->current_mode == CXL_MODE_DEDICATED)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"dedicated_process\\n\");\n\tif (afu->current_mode == CXL_MODE_DIRECTED)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"afu_directed\\n\");\n\treturn scnprintf(buf, PAGE_SIZE, \"none\\n\");\n}\n\nstatic ssize_t mode_store(struct device *device, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(device);\n\tint old_mode, mode = -1;\n\tint rc = -EBUSY;\n\n\t \n\tmutex_lock(&afu->contexts_lock);\n\tif (!idr_is_empty(&afu->contexts_idr))\n\t\tgoto err;\n\n\tif (!strncmp(buf, \"dedicated_process\", 17))\n\t\tmode = CXL_MODE_DEDICATED;\n\tif (!strncmp(buf, \"afu_directed\", 12))\n\t\tmode = CXL_MODE_DIRECTED;\n\tif (!strncmp(buf, \"none\", 4))\n\t\tmode = 0;\n\n\tif (mode == -1) {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\told_mode = afu->current_mode;\n\tafu->current_mode = 0;\n\tafu->num_procs = 0;\n\n\tmutex_unlock(&afu->contexts_lock);\n\n\tif ((rc = cxl_ops->afu_deactivate_mode(afu, old_mode)))\n\t\treturn rc;\n\tif ((rc = cxl_ops->afu_activate_mode(afu, mode)))\n\t\treturn rc;\n\n\treturn count;\nerr:\n\tmutex_unlock(&afu->contexts_lock);\n\treturn rc;\n}\n\nstatic ssize_t api_version_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", CXL_API_VERSION);\n}\n\nstatic ssize_t api_version_compatible_show(struct device *device,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", CXL_API_VERSION_COMPATIBLE);\n}\n\nstatic ssize_t afu_eb_read(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *bin_attr, char *buf,\n\t\t\t       loff_t off, size_t count)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(kobj_to_dev(kobj));\n\n\treturn cxl_ops->afu_read_err_buffer(afu, buf, off, count);\n}\n\nstatic struct device_attribute afu_attrs[] = {\n\t__ATTR_RO(mmio_size),\n\t__ATTR_RO(irqs_min),\n\t__ATTR_RW(irqs_max),\n\t__ATTR_RO(modes_supported),\n\t__ATTR_RW(mode),\n\t__ATTR_RW(prefault_mode),\n\t__ATTR_RO(api_version),\n\t__ATTR_RO(api_version_compatible),\n\t__ATTR(reset, S_IWUSR, NULL, reset_store_afu),\n};\n\nint cxl_sysfs_adapter_add(struct cxl *adapter)\n{\n\tstruct device_attribute *dev_attr;\n\tint i, rc;\n\n\tfor (i = 0; i < ARRAY_SIZE(adapter_attrs); i++) {\n\t\tdev_attr = &adapter_attrs[i];\n\t\tif (cxl_ops->support_attributes(dev_attr->attr.name,\n\t\t\t\t\t\tCXL_ADAPTER_ATTRS)) {\n\t\t\tif ((rc = device_create_file(&adapter->dev, dev_attr)))\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tfor (i--; i >= 0; i--) {\n\t\tdev_attr = &adapter_attrs[i];\n\t\tif (cxl_ops->support_attributes(dev_attr->attr.name,\n\t\t\t\t\t\tCXL_ADAPTER_ATTRS))\n\t\t\tdevice_remove_file(&adapter->dev, dev_attr);\n\t}\n\treturn rc;\n}\n\nvoid cxl_sysfs_adapter_remove(struct cxl *adapter)\n{\n\tstruct device_attribute *dev_attr;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(adapter_attrs); i++) {\n\t\tdev_attr = &adapter_attrs[i];\n\t\tif (cxl_ops->support_attributes(dev_attr->attr.name,\n\t\t\t\t\t\tCXL_ADAPTER_ATTRS))\n\t\t\tdevice_remove_file(&adapter->dev, dev_attr);\n\t}\n}\n\nstruct afu_config_record {\n\tstruct kobject kobj;\n\tstruct bin_attribute config_attr;\n\tstruct list_head list;\n\tint cr;\n\tu16 device;\n\tu16 vendor;\n\tu32 class;\n};\n\n#define to_cr(obj) container_of(obj, struct afu_config_record, kobj)\n\nstatic ssize_t vendor_show(struct kobject *kobj,\n\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\tstruct afu_config_record *cr = to_cr(kobj);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%.4x\\n\", cr->vendor);\n}\n\nstatic ssize_t device_show(struct kobject *kobj,\n\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\tstruct afu_config_record *cr = to_cr(kobj);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%.4x\\n\", cr->device);\n}\n\nstatic ssize_t class_show(struct kobject *kobj,\n\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\tstruct afu_config_record *cr = to_cr(kobj);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%.6x\\n\", cr->class);\n}\n\nstatic ssize_t afu_read_config(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *bin_attr, char *buf,\n\t\t\t       loff_t off, size_t count)\n{\n\tstruct afu_config_record *cr = to_cr(kobj);\n\tstruct cxl_afu *afu = to_cxl_afu(kobj_to_dev(kobj->parent));\n\n\tu64 i, j, val, rc;\n\n\tfor (i = 0; i < count;) {\n\t\trc = cxl_ops->afu_cr_read64(afu, cr->cr, off & ~0x7, &val);\n\t\tif (rc)\n\t\t\tval = ~0ULL;\n\t\tfor (j = off & 0x7; j < 8 && i < count; i++, j++, off++)\n\t\t\tbuf[i] = (val >> (j * 8)) & 0xff;\n\t}\n\n\treturn count;\n}\n\nstatic struct kobj_attribute vendor_attribute =\n\t__ATTR_RO(vendor);\nstatic struct kobj_attribute device_attribute =\n\t__ATTR_RO(device);\nstatic struct kobj_attribute class_attribute =\n\t__ATTR_RO(class);\n\nstatic struct attribute *afu_cr_attrs[] = {\n\t&vendor_attribute.attr,\n\t&device_attribute.attr,\n\t&class_attribute.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(afu_cr);\n\nstatic void release_afu_config_record(struct kobject *kobj)\n{\n\tstruct afu_config_record *cr = to_cr(kobj);\n\n\tkfree(cr);\n}\n\nstatic struct kobj_type afu_config_record_type = {\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.release = release_afu_config_record,\n\t.default_groups = afu_cr_groups,\n};\n\nstatic struct afu_config_record *cxl_sysfs_afu_new_cr(struct cxl_afu *afu, int cr_idx)\n{\n\tstruct afu_config_record *cr;\n\tint rc;\n\n\tcr = kzalloc(sizeof(struct afu_config_record), GFP_KERNEL);\n\tif (!cr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcr->cr = cr_idx;\n\n\trc = cxl_ops->afu_cr_read16(afu, cr_idx, PCI_DEVICE_ID, &cr->device);\n\tif (rc)\n\t\tgoto err;\n\trc = cxl_ops->afu_cr_read16(afu, cr_idx, PCI_VENDOR_ID, &cr->vendor);\n\tif (rc)\n\t\tgoto err;\n\trc = cxl_ops->afu_cr_read32(afu, cr_idx, PCI_CLASS_REVISION, &cr->class);\n\tif (rc)\n\t\tgoto err;\n\tcr->class >>= 8;\n\n\t \n\tsysfs_bin_attr_init(&cr->config_attr);\n\tcr->config_attr.attr.name = \"config\";\n\tcr->config_attr.attr.mode = S_IRUSR;\n\tcr->config_attr.size = afu->crs_len;\n\tcr->config_attr.read = afu_read_config;\n\n\trc = kobject_init_and_add(&cr->kobj, &afu_config_record_type,\n\t\t\t\t  &afu->dev.kobj, \"cr%i\", cr->cr);\n\tif (rc)\n\t\tgoto err1;\n\n\trc = sysfs_create_bin_file(&cr->kobj, &cr->config_attr);\n\tif (rc)\n\t\tgoto err1;\n\n\trc = kobject_uevent(&cr->kobj, KOBJ_ADD);\n\tif (rc)\n\t\tgoto err2;\n\n\treturn cr;\nerr2:\n\tsysfs_remove_bin_file(&cr->kobj, &cr->config_attr);\nerr1:\n\tkobject_put(&cr->kobj);\n\treturn ERR_PTR(rc);\nerr:\n\tkfree(cr);\n\treturn ERR_PTR(rc);\n}\n\nvoid cxl_sysfs_afu_remove(struct cxl_afu *afu)\n{\n\tstruct device_attribute *dev_attr;\n\tstruct afu_config_record *cr, *tmp;\n\tint i;\n\n\t \n\tif (afu->eb_len)\n\t\tdevice_remove_bin_file(&afu->dev, &afu->attr_eb);\n\n\tfor (i = 0; i < ARRAY_SIZE(afu_attrs); i++) {\n\t\tdev_attr = &afu_attrs[i];\n\t\tif (cxl_ops->support_attributes(dev_attr->attr.name,\n\t\t\t\t\t\tCXL_AFU_ATTRS))\n\t\t\tdevice_remove_file(&afu->dev, &afu_attrs[i]);\n\t}\n\n\tlist_for_each_entry_safe(cr, tmp, &afu->crs, list) {\n\t\tsysfs_remove_bin_file(&cr->kobj, &cr->config_attr);\n\t\tkobject_put(&cr->kobj);\n\t}\n}\n\nint cxl_sysfs_afu_add(struct cxl_afu *afu)\n{\n\tstruct device_attribute *dev_attr;\n\tstruct afu_config_record *cr;\n\tint i, rc;\n\n\tINIT_LIST_HEAD(&afu->crs);\n\n\tfor (i = 0; i < ARRAY_SIZE(afu_attrs); i++) {\n\t\tdev_attr = &afu_attrs[i];\n\t\tif (cxl_ops->support_attributes(dev_attr->attr.name,\n\t\t\t\t\t\tCXL_AFU_ATTRS)) {\n\t\t\tif ((rc = device_create_file(&afu->dev, &afu_attrs[i])))\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tif (afu->eb_len) {\n\t\tsysfs_attr_init(&afu->attr_eb.attr);\n\n\t\tafu->attr_eb.attr.name = \"afu_err_buff\";\n\t\tafu->attr_eb.attr.mode = S_IRUGO;\n\t\tafu->attr_eb.size = afu->eb_len;\n\t\tafu->attr_eb.read = afu_eb_read;\n\n\t\trc = device_create_bin_file(&afu->dev, &afu->attr_eb);\n\t\tif (rc) {\n\t\t\tdev_err(&afu->dev,\n\t\t\t\t\"Unable to create eb attr for the afu. Err(%d)\\n\",\n\t\t\t\trc);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tfor (i = 0; i < afu->crs_num; i++) {\n\t\tcr = cxl_sysfs_afu_new_cr(afu, i);\n\t\tif (IS_ERR(cr)) {\n\t\t\trc = PTR_ERR(cr);\n\t\t\tgoto err1;\n\t\t}\n\t\tlist_add(&cr->list, &afu->crs);\n\t}\n\n\treturn 0;\n\nerr1:\n\tcxl_sysfs_afu_remove(afu);\n\treturn rc;\nerr:\n\t \n\tafu->eb_len = 0;\n\n\tfor (i--; i >= 0; i--) {\n\t\tdev_attr = &afu_attrs[i];\n\t\tif (cxl_ops->support_attributes(dev_attr->attr.name,\n\t\t\t\t\t\tCXL_AFU_ATTRS))\n\t\tdevice_remove_file(&afu->dev, &afu_attrs[i]);\n\t}\n\treturn rc;\n}\n\nint cxl_sysfs_afu_m_add(struct cxl_afu *afu)\n{\n\tstruct device_attribute *dev_attr;\n\tint i, rc;\n\n\tfor (i = 0; i < ARRAY_SIZE(afu_master_attrs); i++) {\n\t\tdev_attr = &afu_master_attrs[i];\n\t\tif (cxl_ops->support_attributes(dev_attr->attr.name,\n\t\t\t\t\t\tCXL_AFU_MASTER_ATTRS)) {\n\t\t\tif ((rc = device_create_file(afu->chardev_m, &afu_master_attrs[i])))\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i--; i >= 0; i--) {\n\t\tdev_attr = &afu_master_attrs[i];\n\t\tif (cxl_ops->support_attributes(dev_attr->attr.name,\n\t\t\t\t\t\tCXL_AFU_MASTER_ATTRS))\n\t\t\tdevice_remove_file(afu->chardev_m, &afu_master_attrs[i]);\n\t}\n\treturn rc;\n}\n\nvoid cxl_sysfs_afu_m_remove(struct cxl_afu *afu)\n{\n\tstruct device_attribute *dev_attr;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(afu_master_attrs); i++) {\n\t\tdev_attr = &afu_master_attrs[i];\n\t\tif (cxl_ops->support_attributes(dev_attr->attr.name,\n\t\t\t\t\t\tCXL_AFU_MASTER_ATTRS))\n\t\t\tdevice_remove_file(afu->chardev_m, &afu_master_attrs[i]);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}