{
  "module_name": "base.c",
  "hash_id": "91fb1ed68a084e6980dfdd6a50768e05ed8286988cd5d886cf19b1d6a140ffd2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cxl/base.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <asm/errno.h>\n#include <misc/cxl-base.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include \"cxl.h\"\n\n \nstatic struct cxl_calls *cxl_calls;\n\natomic_t cxl_use_count = ATOMIC_INIT(0);\nEXPORT_SYMBOL(cxl_use_count);\n\n#ifdef CONFIG_CXL_MODULE\n\nstatic inline struct cxl_calls *cxl_calls_get(void)\n{\n\tstruct cxl_calls *calls = NULL;\n\n\trcu_read_lock();\n\tcalls = rcu_dereference(cxl_calls);\n\tif (calls && !try_module_get(calls->owner))\n\t\tcalls = NULL;\n\trcu_read_unlock();\n\n\treturn calls;\n}\n\nstatic inline void cxl_calls_put(struct cxl_calls *calls)\n{\n\tBUG_ON(calls != cxl_calls);\n\n\t \n\tmodule_put(cxl_calls->owner);\n}\n\n#else  \n\nstatic inline struct cxl_calls *cxl_calls_get(void)\n{\n\treturn cxl_calls;\n}\n\nstatic inline void cxl_calls_put(struct cxl_calls *calls) { }\n\n#endif  \n\n \nstruct cxl_afu *cxl_afu_get(struct cxl_afu *afu)\n{\n\treturn (get_device(&afu->dev) == NULL) ? NULL : afu;\n}\nEXPORT_SYMBOL_GPL(cxl_afu_get);\n\nvoid cxl_afu_put(struct cxl_afu *afu)\n{\n\tput_device(&afu->dev);\n}\nEXPORT_SYMBOL_GPL(cxl_afu_put);\n\nvoid cxl_slbia(struct mm_struct *mm)\n{\n\tstruct cxl_calls *calls;\n\n\tcalls = cxl_calls_get();\n\tif (!calls)\n\t\treturn;\n\n\tif (cxl_ctx_in_use())\n\t    calls->cxl_slbia(mm);\n\n\tcxl_calls_put(calls);\n}\n\nint register_cxl_calls(struct cxl_calls *calls)\n{\n\tif (cxl_calls)\n\t\treturn -EBUSY;\n\n\trcu_assign_pointer(cxl_calls, calls);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(register_cxl_calls);\n\nvoid unregister_cxl_calls(struct cxl_calls *calls)\n{\n\tBUG_ON(cxl_calls->owner != calls->owner);\n\tRCU_INIT_POINTER(cxl_calls, NULL);\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL_GPL(unregister_cxl_calls);\n\nint cxl_update_properties(struct device_node *dn,\n\t\t\t  struct property *new_prop)\n{\n\treturn of_update_property(dn, new_prop);\n}\nEXPORT_SYMBOL_GPL(cxl_update_properties);\n\nstatic int __init cxl_base_init(void)\n{\n\tstruct device_node *np;\n\tstruct platform_device *dev;\n\tint count = 0;\n\n\t \n\tif (cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn 0;\n\n\tfor_each_compatible_node(np, NULL, \"ibm,coherent-platform-facility\") {\n\t\tdev = of_platform_device_create(np, NULL, NULL);\n\t\tif (dev)\n\t\t\tcount++;\n\t}\n\tpr_devel(\"Found %d cxl device(s)\\n\", count);\n\treturn 0;\n}\ndevice_initcall(cxl_base_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}