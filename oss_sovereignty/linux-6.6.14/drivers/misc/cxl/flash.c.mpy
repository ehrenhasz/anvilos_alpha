{
  "module_name": "flash.c",
  "hash_id": "dabb7b0a005cbdb3c69ce55d05889da0de3f9adf0db2ffb1716dee1aa78618ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cxl/flash.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/semaphore.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/of.h>\n#include <asm/rtas.h>\n\n#include \"cxl.h\"\n#include \"hcalls.h\"\n\n#define DOWNLOAD_IMAGE 1\n#define VALIDATE_IMAGE 2\n\nstruct ai_header {\n\tu16 version;\n\tu8  reserved0[6];\n\tu16 vendor;\n\tu16 device;\n\tu16 subsystem_vendor;\n\tu16 subsystem;\n\tu64 image_offset;\n\tu64 image_length;\n\tu8  reserved1[96];\n};\n\nstatic struct semaphore sem;\nstatic unsigned long *buffer[CXL_AI_MAX_ENTRIES];\nstatic struct sg_list *le;\nstatic u64 continue_token;\nstatic unsigned int transfer;\n\nstruct update_props_workarea {\n\t__be32 phandle;\n\t__be32 state;\n\t__be64 reserved;\n\t__be32 nprops;\n} __packed;\n\nstruct update_nodes_workarea {\n\t__be32 state;\n\t__be64 unit_address;\n\t__be32 reserved;\n} __packed;\n\n#define DEVICE_SCOPE 3\n#define NODE_ACTION_MASK\t0xff000000\n#define NODE_COUNT_MASK\t\t0x00ffffff\n#define OPCODE_DELETE\t0x01000000\n#define OPCODE_UPDATE\t0x02000000\n#define OPCODE_ADD\t0x03000000\n\nstatic int rcall(int token, char *buf, s32 scope)\n{\n\tint rc;\n\n\tspin_lock(&rtas_data_buf_lock);\n\n\tmemcpy(rtas_data_buf, buf, RTAS_DATA_BUF_SIZE);\n\trc = rtas_call(token, 2, 1, NULL, rtas_data_buf, scope);\n\tmemcpy(buf, rtas_data_buf, RTAS_DATA_BUF_SIZE);\n\n\tspin_unlock(&rtas_data_buf_lock);\n\treturn rc;\n}\n\nstatic int update_property(struct device_node *dn, const char *name,\n\t\t\t   u32 vd, char *value)\n{\n\tstruct property *new_prop;\n\tu32 *val;\n\tint rc;\n\n\tnew_prop = kzalloc(sizeof(*new_prop), GFP_KERNEL);\n\tif (!new_prop)\n\t\treturn -ENOMEM;\n\n\tnew_prop->name = kstrdup(name, GFP_KERNEL);\n\tif (!new_prop->name) {\n\t\tkfree(new_prop);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_prop->length = vd;\n\tnew_prop->value = kzalloc(new_prop->length, GFP_KERNEL);\n\tif (!new_prop->value) {\n\t\tkfree(new_prop->name);\n\t\tkfree(new_prop);\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(new_prop->value, value, vd);\n\n\tval = (u32 *)new_prop->value;\n\trc = cxl_update_properties(dn, new_prop);\n\tpr_devel(\"%pOFn: update property (%s, length: %i, value: %#x)\\n\",\n\t\t  dn, name, vd, be32_to_cpu(*val));\n\n\tif (rc) {\n\t\tkfree(new_prop->name);\n\t\tkfree(new_prop->value);\n\t\tkfree(new_prop);\n\t}\n\treturn rc;\n}\n\nstatic int update_node(__be32 phandle, s32 scope)\n{\n\tstruct update_props_workarea *upwa;\n\tstruct device_node *dn;\n\tint i, rc, ret;\n\tchar *prop_data;\n\tchar *buf;\n\tint token;\n\tu32 nprops;\n\tu32 vd;\n\n\ttoken = rtas_token(\"ibm,update-properties\");\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -EINVAL;\n\n\tbuf = kzalloc(RTAS_DATA_BUF_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdn = of_find_node_by_phandle(be32_to_cpu(phandle));\n\tif (!dn) {\n\t\tkfree(buf);\n\t\treturn -ENOENT;\n\t}\n\n\tupwa = (struct update_props_workarea *)&buf[0];\n\tupwa->phandle = phandle;\n\tdo {\n\t\trc = rcall(token, buf, scope);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tprop_data = buf + sizeof(*upwa);\n\t\tnprops = be32_to_cpu(upwa->nprops);\n\n\t\tif (*prop_data == 0) {\n\t\t\tprop_data++;\n\t\t\tvd = be32_to_cpu(*(__be32 *)prop_data);\n\t\t\tprop_data += vd + sizeof(vd);\n\t\t\tnprops--;\n\t\t}\n\n\t\tfor (i = 0; i < nprops; i++) {\n\t\t\tchar *prop_name;\n\n\t\t\tprop_name = prop_data;\n\t\t\tprop_data += strlen(prop_name) + 1;\n\t\t\tvd = be32_to_cpu(*(__be32 *)prop_data);\n\t\t\tprop_data += sizeof(vd);\n\n\t\t\tif ((vd != 0x00000000) && (vd != 0x80000000)) {\n\t\t\t\tret = update_property(dn, prop_name, vd,\n\t\t\t\t\t\tprop_data);\n\t\t\t\tif (ret)\n\t\t\t\t\tpr_err(\"cxl: Could not update property %s - %i\\n\",\n\t\t\t\t\t       prop_name, ret);\n\n\t\t\t\tprop_data += vd;\n\t\t\t}\n\t\t}\n\t} while (rc == 1);\n\n\tof_node_put(dn);\n\tkfree(buf);\n\treturn rc;\n}\n\nstatic int update_devicetree(struct cxl *adapter, s32 scope)\n{\n\tstruct update_nodes_workarea *unwa;\n\tu32 action, node_count;\n\tint token, rc, i;\n\t__be32 *data, phandle;\n\tchar *buf;\n\n\ttoken = rtas_token(\"ibm,update-nodes\");\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -EINVAL;\n\n\tbuf = kzalloc(RTAS_DATA_BUF_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tunwa = (struct update_nodes_workarea *)&buf[0];\n\tunwa->unit_address = cpu_to_be64(adapter->guest->handle);\n\tdo {\n\t\trc = rcall(token, buf, scope);\n\t\tif (rc && rc != 1)\n\t\t\tbreak;\n\n\t\tdata = (__be32 *)buf + 4;\n\t\twhile (be32_to_cpu(*data) & NODE_ACTION_MASK) {\n\t\t\taction = be32_to_cpu(*data) & NODE_ACTION_MASK;\n\t\t\tnode_count = be32_to_cpu(*data) & NODE_COUNT_MASK;\n\t\t\tpr_devel(\"device reconfiguration - action: %#x, nodes: %#x\\n\",\n\t\t\t\t action, node_count);\n\t\t\tdata++;\n\n\t\t\tfor (i = 0; i < node_count; i++) {\n\t\t\t\tphandle = *data++;\n\n\t\t\t\tswitch (action) {\n\t\t\t\tcase OPCODE_DELETE:\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\tcase OPCODE_UPDATE:\n\t\t\t\t\tupdate_node(phandle, scope);\n\t\t\t\t\tbreak;\n\t\t\t\tcase OPCODE_ADD:\n\t\t\t\t\t \n\t\t\t\t\tdata++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (rc == 1);\n\n\tkfree(buf);\n\treturn 0;\n}\n\nstatic int handle_image(struct cxl *adapter, int operation,\n\t\t\tlong (*fct)(u64, u64, u64, u64 *),\n\t\t\tstruct cxl_adapter_image *ai)\n{\n\tsize_t mod, s_copy, len_chunk = 0;\n\tstruct ai_header *header = NULL;\n\tunsigned int entries = 0, i;\n\tvoid *dest, *from;\n\tint rc = 0, need_header;\n\n\t \n\tneed_header = (ai->flags & CXL_AI_NEED_HEADER);\n\tif (need_header) {\n\t\theader = kzalloc(sizeof(struct ai_header), GFP_KERNEL);\n\t\tif (!header)\n\t\t\treturn -ENOMEM;\n\t\theader->version = cpu_to_be16(1);\n\t\theader->vendor = cpu_to_be16(adapter->guest->vendor);\n\t\theader->device = cpu_to_be16(adapter->guest->device);\n\t\theader->subsystem_vendor = cpu_to_be16(adapter->guest->subsystem_vendor);\n\t\theader->subsystem = cpu_to_be16(adapter->guest->subsystem);\n\t\theader->image_offset = cpu_to_be64(CXL_AI_HEADER_SIZE);\n\t\theader->image_length = cpu_to_be64(ai->len_image);\n\t}\n\n\t \n\tlen_chunk = ai->len_data;\n\tif (need_header)\n\t\tlen_chunk += CXL_AI_HEADER_SIZE;\n\n\tentries = len_chunk / CXL_AI_BUFFER_SIZE;\n\tmod = len_chunk % CXL_AI_BUFFER_SIZE;\n\tif (mod)\n\t\tentries++;\n\n\tif (entries > CXL_AI_MAX_ENTRIES) {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tfrom = (void *) ai->data;\n\tfor (i = 0; i < entries; i++) {\n\t\tdest = buffer[i];\n\t\ts_copy = CXL_AI_BUFFER_SIZE;\n\n\t\tif ((need_header) && (i == 0)) {\n\t\t\t \n\t\t\tmemcpy(buffer[i], header, sizeof(struct ai_header));\n\t\t\ts_copy = CXL_AI_BUFFER_SIZE - CXL_AI_HEADER_SIZE;\n\t\t\tdest += CXL_AI_HEADER_SIZE;  \n\t\t}\n\t\tif ((i == (entries - 1)) && mod)\n\t\t\ts_copy = mod;\n\n\t\t \n\t\tif (copy_from_user(dest, from, s_copy))\n\t\t\tgoto err;\n\n\t\t \n\t\tle[i].phys_addr = cpu_to_be64(virt_to_phys(buffer[i]));\n\t\tle[i].len = cpu_to_be64(CXL_AI_BUFFER_SIZE);\n\t\tif ((i == (entries - 1)) && mod)\n\t\t\tle[i].len = cpu_to_be64(mod);\n\t\tfrom += s_copy;\n\t}\n\tpr_devel(\"%s (op: %i, need header: %i, entries: %i, token: %#llx)\\n\",\n\t\t __func__, operation, need_header, entries, continue_token);\n\n\t \n\trc = fct(adapter->guest->handle, virt_to_phys(le), entries,\n\t\t&continue_token);\n\tif (rc == 0)  \n\t\tcontinue_token = 0;\n\nerr:\n\tkfree(header);\n\n\treturn rc;\n}\n\nstatic int transfer_image(struct cxl *adapter, int operation,\n\t\t\tstruct cxl_adapter_image *ai)\n{\n\tint rc = 0;\n\tint afu;\n\n\tswitch (operation) {\n\tcase DOWNLOAD_IMAGE:\n\t\trc = handle_image(adapter, operation,\n\t\t\t\t&cxl_h_download_adapter_image, ai);\n\t\tif (rc < 0) {\n\t\t\tpr_devel(\"resetting adapter\\n\");\n\t\t\tcxl_h_reset_adapter(adapter->guest->handle);\n\t\t}\n\t\treturn rc;\n\n\tcase VALIDATE_IMAGE:\n\t\trc = handle_image(adapter, operation,\n\t\t\t\t&cxl_h_validate_adapter_image, ai);\n\t\tif (rc < 0) {\n\t\t\tpr_devel(\"resetting adapter\\n\");\n\t\t\tcxl_h_reset_adapter(adapter->guest->handle);\n\t\t\treturn rc;\n\t\t}\n\t\tif (rc == 0) {\n\t\t\tpr_devel(\"remove current afu\\n\");\n\t\t\tfor (afu = 0; afu < adapter->slices; afu++)\n\t\t\t\tcxl_guest_remove_afu(adapter->afu[afu]);\n\n\t\t\tpr_devel(\"resetting adapter\\n\");\n\t\t\tcxl_h_reset_adapter(adapter->guest->handle);\n\n\t\t\t \n\t\t\trc = update_devicetree(adapter, DEVICE_SCOPE);\n\t\t\ttransfer = 1;\n\t\t}\n\t\treturn rc;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic long ioctl_transfer_image(struct cxl *adapter, int operation,\n\t\t\t\tstruct cxl_adapter_image __user *uai)\n{\n\tstruct cxl_adapter_image ai;\n\n\tpr_devel(\"%s\\n\", __func__);\n\n\tif (copy_from_user(&ai, uai, sizeof(struct cxl_adapter_image)))\n\t\treturn -EFAULT;\n\n\t \n\tif (ai.reserved1 || ai.reserved2 || ai.reserved3 || ai.reserved4 ||\n\t\t(ai.flags & ~CXL_AI_ALL))\n\t\treturn -EINVAL;\n\n\treturn transfer_image(adapter, operation, &ai);\n}\n\nstatic int device_open(struct inode *inode, struct file *file)\n{\n\tint adapter_num = CXL_DEVT_ADAPTER(inode->i_rdev);\n\tstruct cxl *adapter;\n\tint rc = 0, i;\n\n\tpr_devel(\"in %s\\n\", __func__);\n\n\tBUG_ON(sizeof(struct ai_header) != CXL_AI_HEADER_SIZE);\n\n\t \n\tif (down_interruptible(&sem) != 0)\n\t\treturn -EPERM;\n\n\tif (!(adapter = get_cxl_adapter(adapter_num))) {\n\t\trc = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tfile->private_data = adapter;\n\tcontinue_token = 0;\n\ttransfer = 0;\n\n\tfor (i = 0; i < CXL_AI_MAX_ENTRIES; i++)\n\t\tbuffer[i] = NULL;\n\n\t \n\tle = (struct sg_list *)get_zeroed_page(GFP_KERNEL);\n\tif (!le) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < CXL_AI_MAX_ENTRIES; i++) {\n\t\tbuffer[i] = (unsigned long *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!buffer[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr1:\n\tfor (i = 0; i < CXL_AI_MAX_ENTRIES; i++) {\n\t\tif (buffer[i])\n\t\t\tfree_page((unsigned long) buffer[i]);\n\t}\n\n\tif (le)\n\t\tfree_page((unsigned long) le);\nerr:\n\tput_device(&adapter->dev);\nerr_unlock:\n\tup(&sem);\n\n\treturn rc;\n}\n\nstatic long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct cxl *adapter = file->private_data;\n\n\tpr_devel(\"in %s\\n\", __func__);\n\n\tif (cmd == CXL_IOCTL_DOWNLOAD_IMAGE)\n\t\treturn ioctl_transfer_image(adapter,\n\t\t\t\t\tDOWNLOAD_IMAGE,\n\t\t\t\t\t(struct cxl_adapter_image __user *)arg);\n\telse if (cmd == CXL_IOCTL_VALIDATE_IMAGE)\n\t\treturn ioctl_transfer_image(adapter,\n\t\t\t\t\tVALIDATE_IMAGE,\n\t\t\t\t\t(struct cxl_adapter_image __user *)arg);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int device_close(struct inode *inode, struct file *file)\n{\n\tstruct cxl *adapter = file->private_data;\n\tint i;\n\n\tpr_devel(\"in %s\\n\", __func__);\n\n\tfor (i = 0; i < CXL_AI_MAX_ENTRIES; i++) {\n\t\tif (buffer[i])\n\t\t\tfree_page((unsigned long) buffer[i]);\n\t}\n\n\tif (le)\n\t\tfree_page((unsigned long) le);\n\n\tup(&sem);\n\tput_device(&adapter->dev);\n\tcontinue_token = 0;\n\n\t \n\tif (transfer)\n\t\tcxl_guest_reload_module(adapter);\n\telse {\n\t\tpr_devel(\"resetting adapter\\n\");\n\t\tcxl_h_reset_adapter(adapter->guest->handle);\n\t}\n\n\ttransfer = 0;\n\treturn 0;\n}\n\nstatic const struct file_operations fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= device_open,\n\t.unlocked_ioctl\t= device_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.release\t= device_close,\n};\n\nvoid cxl_guest_remove_chardev(struct cxl *adapter)\n{\n\tcdev_del(&adapter->guest->cdev);\n}\n\nint cxl_guest_add_chardev(struct cxl *adapter)\n{\n\tdev_t devt;\n\tint rc;\n\n\tdevt = MKDEV(MAJOR(cxl_get_dev()), CXL_CARD_MINOR(adapter));\n\tcdev_init(&adapter->guest->cdev, &fops);\n\tif ((rc = cdev_add(&adapter->guest->cdev, devt, 1))) {\n\t\tdev_err(&adapter->dev,\n\t\t\t\"Unable to add chardev on adapter (card%i): %i\\n\",\n\t\t\tadapter->adapter_num, rc);\n\t\tgoto err;\n\t}\n\tadapter->dev.devt = devt;\n\tsema_init(&sem, 1);\nerr:\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}