{
  "module_name": "pci.c",
  "hash_id": "f2f0f311a0ac2825fcef838f6149acfa7d5177228c318dadb27a914e1d67027f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cxl/pci.c",
  "human_readable_source": "\n \n\n#include <linux/pci_regs.h>\n#include <linux/pci_ids.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/pci.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <asm/opal.h>\n#include <asm/msi_bitmap.h>\n#include <asm/pnv-pci.h>\n#include <asm/io.h>\n#include <asm/reg.h>\n\n#include \"cxl.h\"\n#include <misc/cxl.h>\n\n\n#define CXL_PCI_VSEC_ID\t0x1280\n#define CXL_VSEC_MIN_SIZE 0x80\n\n#define CXL_READ_VSEC_LENGTH(dev, vsec, dest)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\tpci_read_config_word(dev, vsec + 0x6, dest);\t\\\n\t\t*dest >>= 4;\t\t\t\t\t\\\n\t}\n#define CXL_READ_VSEC_NAFUS(dev, vsec, dest) \\\n\tpci_read_config_byte(dev, vsec + 0x8, dest)\n\n#define CXL_READ_VSEC_STATUS(dev, vsec, dest) \\\n\tpci_read_config_byte(dev, vsec + 0x9, dest)\n#define CXL_STATUS_SECOND_PORT  0x80\n#define CXL_STATUS_MSI_X_FULL   0x40\n#define CXL_STATUS_MSI_X_SINGLE 0x20\n#define CXL_STATUS_FLASH_RW     0x08\n#define CXL_STATUS_FLASH_RO     0x04\n#define CXL_STATUS_LOADABLE_AFU 0x02\n#define CXL_STATUS_LOADABLE_PSL 0x01\n \n#define CXL_UNSUPPORTED_FEATURES \\\n\t(CXL_STATUS_MSI_X_FULL | CXL_STATUS_MSI_X_SINGLE)\n\n#define CXL_READ_VSEC_MODE_CONTROL(dev, vsec, dest) \\\n\tpci_read_config_byte(dev, vsec + 0xa, dest)\n#define CXL_WRITE_VSEC_MODE_CONTROL(dev, vsec, val) \\\n\tpci_write_config_byte(dev, vsec + 0xa, val)\n#define CXL_VSEC_PROTOCOL_MASK   0xe0\n#define CXL_VSEC_PROTOCOL_1024TB 0x80\n#define CXL_VSEC_PROTOCOL_512TB  0x40\n#define CXL_VSEC_PROTOCOL_256TB  0x20  \n#define CXL_VSEC_PROTOCOL_ENABLE 0x01\n\n#define CXL_READ_VSEC_PSL_REVISION(dev, vsec, dest) \\\n\tpci_read_config_word(dev, vsec + 0xc, dest)\n#define CXL_READ_VSEC_CAIA_MINOR(dev, vsec, dest) \\\n\tpci_read_config_byte(dev, vsec + 0xe, dest)\n#define CXL_READ_VSEC_CAIA_MAJOR(dev, vsec, dest) \\\n\tpci_read_config_byte(dev, vsec + 0xf, dest)\n#define CXL_READ_VSEC_BASE_IMAGE(dev, vsec, dest) \\\n\tpci_read_config_word(dev, vsec + 0x10, dest)\n\n#define CXL_READ_VSEC_IMAGE_STATE(dev, vsec, dest) \\\n\tpci_read_config_byte(dev, vsec + 0x13, dest)\n#define CXL_WRITE_VSEC_IMAGE_STATE(dev, vsec, val) \\\n\tpci_write_config_byte(dev, vsec + 0x13, val)\n#define CXL_VSEC_USER_IMAGE_LOADED 0x80  \n#define CXL_VSEC_PERST_LOADS_IMAGE 0x20  \n#define CXL_VSEC_PERST_SELECT_USER 0x10  \n\n#define CXL_READ_VSEC_AFU_DESC_OFF(dev, vsec, dest) \\\n\tpci_read_config_dword(dev, vsec + 0x20, dest)\n#define CXL_READ_VSEC_AFU_DESC_SIZE(dev, vsec, dest) \\\n\tpci_read_config_dword(dev, vsec + 0x24, dest)\n#define CXL_READ_VSEC_PS_OFF(dev, vsec, dest) \\\n\tpci_read_config_dword(dev, vsec + 0x28, dest)\n#define CXL_READ_VSEC_PS_SIZE(dev, vsec, dest) \\\n\tpci_read_config_dword(dev, vsec + 0x2c, dest)\n\n\n \n#define AFUD_READ(afu, off)\t\tin_be64(afu->native->afu_desc_mmio + off)\n#define AFUD_READ_LE(afu, off)\t\tin_le64(afu->native->afu_desc_mmio + off)\n#define EXTRACT_PPC_BIT(val, bit)\t(!!(val & PPC_BIT(bit)))\n#define EXTRACT_PPC_BITS(val, bs, be)\t((val & PPC_BITMASK(bs, be)) >> PPC_BITLSHIFT(be))\n\n#define AFUD_READ_INFO(afu)\t\tAFUD_READ(afu, 0x0)\n#define   AFUD_NUM_INTS_PER_PROC(val)\tEXTRACT_PPC_BITS(val,  0, 15)\n#define   AFUD_NUM_PROCS(val)\t\tEXTRACT_PPC_BITS(val, 16, 31)\n#define   AFUD_NUM_CRS(val)\t\tEXTRACT_PPC_BITS(val, 32, 47)\n#define   AFUD_MULTIMODE(val)\t\tEXTRACT_PPC_BIT(val, 48)\n#define   AFUD_PUSH_BLOCK_TRANSFER(val)\tEXTRACT_PPC_BIT(val, 55)\n#define   AFUD_DEDICATED_PROCESS(val)\tEXTRACT_PPC_BIT(val, 59)\n#define   AFUD_AFU_DIRECTED(val)\tEXTRACT_PPC_BIT(val, 61)\n#define   AFUD_TIME_SLICED(val)\t\tEXTRACT_PPC_BIT(val, 63)\n#define AFUD_READ_CR(afu)\t\tAFUD_READ(afu, 0x20)\n#define   AFUD_CR_LEN(val)\t\tEXTRACT_PPC_BITS(val, 8, 63)\n#define AFUD_READ_CR_OFF(afu)\t\tAFUD_READ(afu, 0x28)\n#define AFUD_READ_PPPSA(afu)\t\tAFUD_READ(afu, 0x30)\n#define   AFUD_PPPSA_PP(val)\t\tEXTRACT_PPC_BIT(val, 6)\n#define   AFUD_PPPSA_PSA(val)\t\tEXTRACT_PPC_BIT(val, 7)\n#define   AFUD_PPPSA_LEN(val)\t\tEXTRACT_PPC_BITS(val, 8, 63)\n#define AFUD_READ_PPPSA_OFF(afu)\tAFUD_READ(afu, 0x38)\n#define AFUD_READ_EB(afu)\t\tAFUD_READ(afu, 0x40)\n#define   AFUD_EB_LEN(val)\t\tEXTRACT_PPC_BITS(val, 8, 63)\n#define AFUD_READ_EB_OFF(afu)\t\tAFUD_READ(afu, 0x48)\n\nstatic const struct pci_device_id cxl_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_IBM, 0x0477), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_IBM, 0x044b), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_IBM, 0x04cf), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_IBM, 0x0601), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_IBM, 0x0623), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_IBM, 0x0628), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, cxl_pci_tbl);\n\n\n \nstatic inline resource_size_t p1_base(struct pci_dev *dev)\n{\n\treturn pci_resource_start(dev, 2);\n}\n\nstatic inline resource_size_t p1_size(struct pci_dev *dev)\n{\n\treturn pci_resource_len(dev, 2);\n}\n\nstatic inline resource_size_t p2_base(struct pci_dev *dev)\n{\n\treturn pci_resource_start(dev, 0);\n}\n\nstatic inline resource_size_t p2_size(struct pci_dev *dev)\n{\n\treturn pci_resource_len(dev, 0);\n}\n\nstatic int find_cxl_vsec(struct pci_dev *dev)\n{\n\treturn pci_find_vsec_capability(dev, PCI_VENDOR_ID_IBM, CXL_PCI_VSEC_ID);\n}\n\nstatic void dump_cxl_config_space(struct pci_dev *dev)\n{\n\tint vsec;\n\tu32 val;\n\n\tdev_info(&dev->dev, \"dump_cxl_config_space\\n\");\n\n\tpci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &val);\n\tdev_info(&dev->dev, \"BAR0: %#.8x\\n\", val);\n\tpci_read_config_dword(dev, PCI_BASE_ADDRESS_1, &val);\n\tdev_info(&dev->dev, \"BAR1: %#.8x\\n\", val);\n\tpci_read_config_dword(dev, PCI_BASE_ADDRESS_2, &val);\n\tdev_info(&dev->dev, \"BAR2: %#.8x\\n\", val);\n\tpci_read_config_dword(dev, PCI_BASE_ADDRESS_3, &val);\n\tdev_info(&dev->dev, \"BAR3: %#.8x\\n\", val);\n\tpci_read_config_dword(dev, PCI_BASE_ADDRESS_4, &val);\n\tdev_info(&dev->dev, \"BAR4: %#.8x\\n\", val);\n\tpci_read_config_dword(dev, PCI_BASE_ADDRESS_5, &val);\n\tdev_info(&dev->dev, \"BAR5: %#.8x\\n\", val);\n\n\tdev_info(&dev->dev, \"p1 regs: %#llx, len: %#llx\\n\",\n\t\tp1_base(dev), p1_size(dev));\n\tdev_info(&dev->dev, \"p2 regs: %#llx, len: %#llx\\n\",\n\t\tp2_base(dev), p2_size(dev));\n\tdev_info(&dev->dev, \"BAR 4/5: %#llx, len: %#llx\\n\",\n\t\tpci_resource_start(dev, 4), pci_resource_len(dev, 4));\n\n\tif (!(vsec = find_cxl_vsec(dev)))\n\t\treturn;\n\n#define show_reg(name, what) \\\n\tdev_info(&dev->dev, \"cxl vsec: %30s: %#x\\n\", name, what)\n\n\tpci_read_config_dword(dev, vsec + 0x0, &val);\n\tshow_reg(\"Cap ID\", (val >> 0) & 0xffff);\n\tshow_reg(\"Cap Ver\", (val >> 16) & 0xf);\n\tshow_reg(\"Next Cap Ptr\", (val >> 20) & 0xfff);\n\tpci_read_config_dword(dev, vsec + 0x4, &val);\n\tshow_reg(\"VSEC ID\", (val >> 0) & 0xffff);\n\tshow_reg(\"VSEC Rev\", (val >> 16) & 0xf);\n\tshow_reg(\"VSEC Length\",\t(val >> 20) & 0xfff);\n\tpci_read_config_dword(dev, vsec + 0x8, &val);\n\tshow_reg(\"Num AFUs\", (val >> 0) & 0xff);\n\tshow_reg(\"Status\", (val >> 8) & 0xff);\n\tshow_reg(\"Mode Control\", (val >> 16) & 0xff);\n\tshow_reg(\"Reserved\", (val >> 24) & 0xff);\n\tpci_read_config_dword(dev, vsec + 0xc, &val);\n\tshow_reg(\"PSL Rev\", (val >> 0) & 0xffff);\n\tshow_reg(\"CAIA Ver\", (val >> 16) & 0xffff);\n\tpci_read_config_dword(dev, vsec + 0x10, &val);\n\tshow_reg(\"Base Image Rev\", (val >> 0) & 0xffff);\n\tshow_reg(\"Reserved\", (val >> 16) & 0x0fff);\n\tshow_reg(\"Image Control\", (val >> 28) & 0x3);\n\tshow_reg(\"Reserved\", (val >> 30) & 0x1);\n\tshow_reg(\"Image Loaded\", (val >> 31) & 0x1);\n\n\tpci_read_config_dword(dev, vsec + 0x14, &val);\n\tshow_reg(\"Reserved\", val);\n\tpci_read_config_dword(dev, vsec + 0x18, &val);\n\tshow_reg(\"Reserved\", val);\n\tpci_read_config_dword(dev, vsec + 0x1c, &val);\n\tshow_reg(\"Reserved\", val);\n\n\tpci_read_config_dword(dev, vsec + 0x20, &val);\n\tshow_reg(\"AFU Descriptor Offset\", val);\n\tpci_read_config_dword(dev, vsec + 0x24, &val);\n\tshow_reg(\"AFU Descriptor Size\", val);\n\tpci_read_config_dword(dev, vsec + 0x28, &val);\n\tshow_reg(\"Problem State Offset\", val);\n\tpci_read_config_dword(dev, vsec + 0x2c, &val);\n\tshow_reg(\"Problem State Size\", val);\n\n\tpci_read_config_dword(dev, vsec + 0x30, &val);\n\tshow_reg(\"Reserved\", val);\n\tpci_read_config_dword(dev, vsec + 0x34, &val);\n\tshow_reg(\"Reserved\", val);\n\tpci_read_config_dword(dev, vsec + 0x38, &val);\n\tshow_reg(\"Reserved\", val);\n\tpci_read_config_dword(dev, vsec + 0x3c, &val);\n\tshow_reg(\"Reserved\", val);\n\n\tpci_read_config_dword(dev, vsec + 0x40, &val);\n\tshow_reg(\"PSL Programming Port\", val);\n\tpci_read_config_dword(dev, vsec + 0x44, &val);\n\tshow_reg(\"PSL Programming Control\", val);\n\n\tpci_read_config_dword(dev, vsec + 0x48, &val);\n\tshow_reg(\"Reserved\", val);\n\tpci_read_config_dword(dev, vsec + 0x4c, &val);\n\tshow_reg(\"Reserved\", val);\n\n\tpci_read_config_dword(dev, vsec + 0x50, &val);\n\tshow_reg(\"Flash Address Register\", val);\n\tpci_read_config_dword(dev, vsec + 0x54, &val);\n\tshow_reg(\"Flash Size Register\", val);\n\tpci_read_config_dword(dev, vsec + 0x58, &val);\n\tshow_reg(\"Flash Status/Control Register\", val);\n\tpci_read_config_dword(dev, vsec + 0x58, &val);\n\tshow_reg(\"Flash Data Port\", val);\n\n#undef show_reg\n}\n\nstatic void dump_afu_descriptor(struct cxl_afu *afu)\n{\n\tu64 val, afu_cr_num, afu_cr_off, afu_cr_len;\n\tint i;\n\n#define show_reg(name, what) \\\n\tdev_info(&afu->dev, \"afu desc: %30s: %#llx\\n\", name, what)\n\n\tval = AFUD_READ_INFO(afu);\n\tshow_reg(\"num_ints_per_process\", AFUD_NUM_INTS_PER_PROC(val));\n\tshow_reg(\"num_of_processes\", AFUD_NUM_PROCS(val));\n\tshow_reg(\"num_of_afu_CRs\", AFUD_NUM_CRS(val));\n\tshow_reg(\"req_prog_mode\", val & 0xffffULL);\n\tafu_cr_num = AFUD_NUM_CRS(val);\n\n\tval = AFUD_READ(afu, 0x8);\n\tshow_reg(\"Reserved\", val);\n\tval = AFUD_READ(afu, 0x10);\n\tshow_reg(\"Reserved\", val);\n\tval = AFUD_READ(afu, 0x18);\n\tshow_reg(\"Reserved\", val);\n\n\tval = AFUD_READ_CR(afu);\n\tshow_reg(\"Reserved\", (val >> (63-7)) & 0xff);\n\tshow_reg(\"AFU_CR_len\", AFUD_CR_LEN(val));\n\tafu_cr_len = AFUD_CR_LEN(val) * 256;\n\n\tval = AFUD_READ_CR_OFF(afu);\n\tafu_cr_off = val;\n\tshow_reg(\"AFU_CR_offset\", val);\n\n\tval = AFUD_READ_PPPSA(afu);\n\tshow_reg(\"PerProcessPSA_control\", (val >> (63-7)) & 0xff);\n\tshow_reg(\"PerProcessPSA Length\", AFUD_PPPSA_LEN(val));\n\n\tval = AFUD_READ_PPPSA_OFF(afu);\n\tshow_reg(\"PerProcessPSA_offset\", val);\n\n\tval = AFUD_READ_EB(afu);\n\tshow_reg(\"Reserved\", (val >> (63-7)) & 0xff);\n\tshow_reg(\"AFU_EB_len\", AFUD_EB_LEN(val));\n\n\tval = AFUD_READ_EB_OFF(afu);\n\tshow_reg(\"AFU_EB_offset\", val);\n\n\tfor (i = 0; i < afu_cr_num; i++) {\n\t\tval = AFUD_READ_LE(afu, afu_cr_off + i * afu_cr_len);\n\t\tshow_reg(\"CR Vendor\", val & 0xffff);\n\t\tshow_reg(\"CR Device\", (val >> 16) & 0xffff);\n\t}\n#undef show_reg\n}\n\n#define P8_CAPP_UNIT0_ID 0xBA\n#define P8_CAPP_UNIT1_ID 0XBE\n#define P9_CAPP_UNIT0_ID 0xC0\n#define P9_CAPP_UNIT1_ID 0xE0\n\nstatic int get_phb_index(struct device_node *np, u32 *phb_index)\n{\n\tif (of_property_read_u32(np, \"ibm,phb-index\", phb_index))\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic u64 get_capp_unit_id(struct device_node *np, u32 phb_index)\n{\n\t \n\tif (cxl_is_power8()) {\n\t\tif (!pvr_version_is(PVR_POWER8NVL))\n\t\t\treturn P8_CAPP_UNIT0_ID;\n\n\t\tif (phb_index == 0)\n\t\t\treturn P8_CAPP_UNIT0_ID;\n\n\t\tif (phb_index == 1)\n\t\t\treturn P8_CAPP_UNIT1_ID;\n\t}\n\n\t \n\tif (cxl_is_power9()) {\n\t\tif (phb_index == 0)\n\t\t\treturn P9_CAPP_UNIT0_ID;\n\n\t\tif (phb_index == 3)\n\t\t\treturn P9_CAPP_UNIT1_ID;\n\t}\n\n\treturn 0;\n}\n\nint cxl_calc_capp_routing(struct pci_dev *dev, u64 *chipid,\n\t\t\t     u32 *phb_index, u64 *capp_unit_id)\n{\n\tint rc;\n\tstruct device_node *np;\n\tconst __be32 *prop;\n\n\tif (!(np = pnv_pci_get_phb_node(dev)))\n\t\treturn -ENODEV;\n\n\twhile (np && !(prop = of_get_property(np, \"ibm,chip-id\", NULL)))\n\t\tnp = of_get_next_parent(np);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\t*chipid = be32_to_cpup(prop);\n\n\trc = get_phb_index(np, phb_index);\n\tif (rc) {\n\t\tpr_err(\"cxl: invalid phb index\\n\");\n\t\tof_node_put(np);\n\t\treturn rc;\n\t}\n\n\t*capp_unit_id = get_capp_unit_id(np, *phb_index);\n\tof_node_put(np);\n\tif (!*capp_unit_id) {\n\t\tpr_err(\"cxl: No capp unit found for PHB[%lld,%d]. Make sure the adapter is on a capi-compatible slot\\n\",\n\t\t       *chipid, *phb_index);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(indications_mutex);\n\nstatic int get_phb_indications(struct pci_dev *dev, u64 *capiind, u64 *asnind,\n\t\t\t       u64 *nbwind)\n{\n\tstatic u64 nbw, asn, capi = 0;\n\tstruct device_node *np;\n\tconst __be32 *prop;\n\n\tmutex_lock(&indications_mutex);\n\tif (!capi) {\n\t\tif (!(np = pnv_pci_get_phb_node(dev))) {\n\t\t\tmutex_unlock(&indications_mutex);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tprop = of_get_property(np, \"ibm,phb-indications\", NULL);\n\t\tif (!prop) {\n\t\t\tnbw = 0x0300UL;  \n\t\t\tasn = 0x0400UL;\n\t\t\tcapi = 0x0200UL;\n\t\t} else {\n\t\t\tnbw = (u64)be32_to_cpu(prop[2]);\n\t\t\tasn = (u64)be32_to_cpu(prop[1]);\n\t\t\tcapi = (u64)be32_to_cpu(prop[0]);\n\t\t}\n\t\tof_node_put(np);\n\t}\n\t*capiind = capi;\n\t*asnind = asn;\n\t*nbwind = nbw;\n\tmutex_unlock(&indications_mutex);\n\treturn 0;\n}\n\nint cxl_get_xsl9_dsnctl(struct pci_dev *dev, u64 capp_unit_id, u64 *reg)\n{\n\tu64 xsl_dsnctl;\n\tu64 capiind, asnind, nbwind;\n\n\t \n\tif (get_phb_indications(dev, &capiind, &asnind, &nbwind))\n\t\treturn -ENODEV;\n\n\t \n\txsl_dsnctl = (capiind << (63-15));  \n\txsl_dsnctl |= (capp_unit_id << (63-15));\n\n\t \n\txsl_dsnctl |= ((u64)0x09 << (63-28));\n\n\t \n\txsl_dsnctl |= (nbwind << (63-55));\n\n\t \n\txsl_dsnctl |= asnind;\n\n\t*reg = xsl_dsnctl;\n\treturn 0;\n}\n\nstatic int init_implementation_adapter_regs_psl9(struct cxl *adapter,\n\t\t\t\t\t\t struct pci_dev *dev)\n{\n\tu64 xsl_dsnctl, psl_fircntl;\n\tu64 chipid;\n\tu32 phb_index;\n\tu64 capp_unit_id;\n\tu64 psl_debug;\n\tint rc;\n\n\trc = cxl_calc_capp_routing(dev, &chipid, &phb_index, &capp_unit_id);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cxl_get_xsl9_dsnctl(dev, capp_unit_id, &xsl_dsnctl);\n\tif (rc)\n\t\treturn rc;\n\n\tcxl_p1_write(adapter, CXL_XSL9_DSNCTL, xsl_dsnctl);\n\n\t \n\tpsl_fircntl = (0x2ULL << (63-3));  \n\tpsl_fircntl |= (0x1ULL << (63-6));  \n\tpsl_fircntl |= 0x1ULL;  \n\tcxl_p1_write(adapter, CXL_PSL9_FIR_CNTL, psl_fircntl);\n\n\t \n\tcxl_p1_write(adapter, CXL_PSL9_DSNDCTL, 0x0001001000012A10ULL);\n\n\t \n\n\t \n\tcxl_p1_write(adapter, CXL_XSL9_DEF, 0x51F8000000000005ULL);\n\n\t \n\tcxl_p1_write(adapter, CXL_XSL9_INV, 0x0000040007FFC200ULL);\n\n\tif (phb_index == 3) {\n\t\t \n\t\tcxl_p1_write(adapter, CXL_PSL9_APCDEDTYPE, 0x40000FF3FFFF0000ULL);\n\t}\n\n\t \n\tcxl_p1_write(adapter, CXL_PSL9_APCDEDALLOC, 0x800F000200000000ULL);\n\n\t \n\tcxl_p1_write(adapter, CXL_PSL9_DEBUG, 0xC000000000000000ULL);\n\n\t \n\tpsl_debug = cxl_p1_read(adapter, CXL_PSL9_DEBUG);\n\tif (psl_debug & CXL_PSL_DEBUG_CDC) {\n\t\tdev_dbg(&dev->dev, \"No data-cache present\\n\");\n\t\tadapter->native->no_data_cache = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int init_implementation_adapter_regs_psl8(struct cxl *adapter, struct pci_dev *dev)\n{\n\tu64 psl_dsnctl, psl_fircntl;\n\tu64 chipid;\n\tu32 phb_index;\n\tu64 capp_unit_id;\n\tint rc;\n\n\trc = cxl_calc_capp_routing(dev, &chipid, &phb_index, &capp_unit_id);\n\tif (rc)\n\t\treturn rc;\n\n\tpsl_dsnctl = 0x0000900000000000ULL;  \n\tpsl_dsnctl |= (0x2ULL << (63-38));  \n\t \n\tpsl_dsnctl |= (chipid << (63-5));\n\tpsl_dsnctl |= (capp_unit_id << (63-13));\n\n\tcxl_p1_write(adapter, CXL_PSL_DSNDCTL, psl_dsnctl);\n\tcxl_p1_write(adapter, CXL_PSL_RESLCKTO, 0x20000000200ULL);\n\t \n\tcxl_p1_write(adapter, CXL_PSL_SNWRALLOC, 0x00000000FFFFFFFFULL);\n\t \n\tpsl_fircntl = (0x2ULL << (63-3));  \n\tpsl_fircntl |= (0x1ULL << (63-6));  \n\tpsl_fircntl |= 0x1ULL;  \n\tcxl_p1_write(adapter, CXL_PSL_FIR_CNTL, psl_fircntl);\n\t \n\tcxl_p1_write(adapter, CXL_PSL_TRACE, 0x0000FF7C00000000ULL);\n\n\treturn 0;\n}\n\n \n#define TBSYNC_CAL(n) (((u64)n & 0x7) << (63-3))\n#define TBSYNC_CNT(n) (((u64)n & 0x7) << (63-6))\n \n#define PSL_2048_250MHZ_CYCLES 1\n\nstatic void write_timebase_ctrl_psl8(struct cxl *adapter)\n{\n\tcxl_p1_write(adapter, CXL_PSL_TB_CTLSTAT,\n\t\t     TBSYNC_CNT(2 * PSL_2048_250MHZ_CYCLES));\n}\n\nstatic u64 timebase_read_psl9(struct cxl *adapter)\n{\n\treturn cxl_p1_read(adapter, CXL_PSL9_Timebase);\n}\n\nstatic u64 timebase_read_psl8(struct cxl *adapter)\n{\n\treturn cxl_p1_read(adapter, CXL_PSL_Timebase);\n}\n\nstatic void cxl_setup_psl_timebase(struct cxl *adapter, struct pci_dev *dev)\n{\n\tstruct device_node *np;\n\n\tadapter->psl_timebase_synced = false;\n\n\tif (!(np = pnv_pci_get_phb_node(dev)))\n\t\treturn;\n\n\t \n\tof_node_get(np);\n\tif (! of_get_property(np, \"ibm,capp-timebase-sync\", NULL)) {\n\t\tof_node_put(np);\n\t\tdev_info(&dev->dev, \"PSL timebase inactive: OPAL support missing\\n\");\n\t\treturn;\n\t}\n\tof_node_put(np);\n\n\t \n\tif (adapter->native->sl_ops->write_timebase_ctrl)\n\t\tadapter->native->sl_ops->write_timebase_ctrl(adapter);\n\n\t \n\tcxl_p1_write(adapter, CXL_PSL_Control, 0x0000000000000000);\n\tcxl_p1_write(adapter, CXL_PSL_Control, CXL_PSL_Control_tb);\n\n\treturn;\n}\n\nstatic int init_implementation_afu_regs_psl9(struct cxl_afu *afu)\n{\n\treturn 0;\n}\n\nstatic int init_implementation_afu_regs_psl8(struct cxl_afu *afu)\n{\n\t \n\tcxl_p1n_write(afu, CXL_PSL_APCALLOC_A, 0xFFFFFFFEFEFEFEFEULL);\n\t \n\tcxl_p1n_write(afu, CXL_PSL_COALLOC_A, 0xFF000000FEFEFEFEULL);\n\t \n\tcxl_p1n_write(afu, CXL_PSL_SLICE_TRACE, 0x0000FFFF00000000ULL);\n\tcxl_p1n_write(afu, CXL_PSL_RXCTL_A, CXL_PSL_RXCTL_AFUHP_4S);\n\n\treturn 0;\n}\n\nint cxl_pci_setup_irq(struct cxl *adapter, unsigned int hwirq,\n\t\tunsigned int virq)\n{\n\tstruct pci_dev *dev = to_pci_dev(adapter->dev.parent);\n\n\treturn pnv_cxl_ioda_msi_setup(dev, hwirq, virq);\n}\n\nint cxl_update_image_control(struct cxl *adapter)\n{\n\tstruct pci_dev *dev = to_pci_dev(adapter->dev.parent);\n\tint rc;\n\tint vsec;\n\tu8 image_state;\n\n\tif (!(vsec = find_cxl_vsec(dev))) {\n\t\tdev_err(&dev->dev, \"ABORTING: CXL VSEC not found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif ((rc = CXL_READ_VSEC_IMAGE_STATE(dev, vsec, &image_state))) {\n\t\tdev_err(&dev->dev, \"failed to read image state: %i\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (adapter->perst_loads_image)\n\t\timage_state |= CXL_VSEC_PERST_LOADS_IMAGE;\n\telse\n\t\timage_state &= ~CXL_VSEC_PERST_LOADS_IMAGE;\n\n\tif (adapter->perst_select_user)\n\t\timage_state |= CXL_VSEC_PERST_SELECT_USER;\n\telse\n\t\timage_state &= ~CXL_VSEC_PERST_SELECT_USER;\n\n\tif ((rc = CXL_WRITE_VSEC_IMAGE_STATE(dev, vsec, image_state))) {\n\t\tdev_err(&dev->dev, \"failed to update image control: %i\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nint cxl_pci_alloc_one_irq(struct cxl *adapter)\n{\n\tstruct pci_dev *dev = to_pci_dev(adapter->dev.parent);\n\n\treturn pnv_cxl_alloc_hwirqs(dev, 1);\n}\n\nvoid cxl_pci_release_one_irq(struct cxl *adapter, int hwirq)\n{\n\tstruct pci_dev *dev = to_pci_dev(adapter->dev.parent);\n\n\treturn pnv_cxl_release_hwirqs(dev, hwirq, 1);\n}\n\nint cxl_pci_alloc_irq_ranges(struct cxl_irq_ranges *irqs,\n\t\t\tstruct cxl *adapter, unsigned int num)\n{\n\tstruct pci_dev *dev = to_pci_dev(adapter->dev.parent);\n\n\treturn pnv_cxl_alloc_hwirq_ranges(irqs, dev, num);\n}\n\nvoid cxl_pci_release_irq_ranges(struct cxl_irq_ranges *irqs,\n\t\t\t\tstruct cxl *adapter)\n{\n\tstruct pci_dev *dev = to_pci_dev(adapter->dev.parent);\n\n\tpnv_cxl_release_hwirq_ranges(irqs, dev);\n}\n\nstatic int setup_cxl_bars(struct pci_dev *dev)\n{\n\t \n\tif ((p1_base(dev) < 0x100000000ULL) ||\n\t    (p2_base(dev) < 0x100000000ULL)) {\n\t\tdev_err(&dev->dev, \"ABORTING: M32 BAR assignment incompatible with CXL\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpci_write_config_dword(dev, PCI_BASE_ADDRESS_4, 0x00000000);\n\tpci_write_config_dword(dev, PCI_BASE_ADDRESS_5, 0x00020000);\n\n\treturn 0;\n}\n\n \nstatic int switch_card_to_cxl(struct pci_dev *dev)\n{\n\tint vsec;\n\tu8 val;\n\tint rc;\n\n\tdev_info(&dev->dev, \"switch card to CXL\\n\");\n\n\tif (!(vsec = find_cxl_vsec(dev))) {\n\t\tdev_err(&dev->dev, \"ABORTING: CXL VSEC not found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif ((rc = CXL_READ_VSEC_MODE_CONTROL(dev, vsec, &val))) {\n\t\tdev_err(&dev->dev, \"failed to read current mode control: %i\", rc);\n\t\treturn rc;\n\t}\n\tval &= ~CXL_VSEC_PROTOCOL_MASK;\n\tval |= CXL_VSEC_PROTOCOL_256TB | CXL_VSEC_PROTOCOL_ENABLE;\n\tif ((rc = CXL_WRITE_VSEC_MODE_CONTROL(dev, vsec, val))) {\n\t\tdev_err(&dev->dev, \"failed to enable CXL protocol: %i\", rc);\n\t\treturn rc;\n\t}\n\t \n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int pci_map_slice_regs(struct cxl_afu *afu, struct cxl *adapter, struct pci_dev *dev)\n{\n\tu64 p1n_base, p2n_base, afu_desc;\n\tconst u64 p1n_size = 0x100;\n\tconst u64 p2n_size = 0x1000;\n\n\tp1n_base = p1_base(dev) + 0x10000 + (afu->slice * p1n_size);\n\tp2n_base = p2_base(dev) + (afu->slice * p2n_size);\n\tafu->psn_phys = p2_base(dev) + (adapter->native->ps_off + (afu->slice * adapter->ps_size));\n\tafu_desc = p2_base(dev) + adapter->native->afu_desc_off + (afu->slice * adapter->native->afu_desc_size);\n\n\tif (!(afu->native->p1n_mmio = ioremap(p1n_base, p1n_size)))\n\t\tgoto err;\n\tif (!(afu->p2n_mmio = ioremap(p2n_base, p2n_size)))\n\t\tgoto err1;\n\tif (afu_desc) {\n\t\tif (!(afu->native->afu_desc_mmio = ioremap(afu_desc, adapter->native->afu_desc_size)))\n\t\t\tgoto err2;\n\t}\n\n\treturn 0;\nerr2:\n\tiounmap(afu->p2n_mmio);\nerr1:\n\tiounmap(afu->native->p1n_mmio);\nerr:\n\tdev_err(&afu->dev, \"Error mapping AFU MMIO regions\\n\");\n\treturn -ENOMEM;\n}\n\nstatic void pci_unmap_slice_regs(struct cxl_afu *afu)\n{\n\tif (afu->p2n_mmio) {\n\t\tiounmap(afu->p2n_mmio);\n\t\tafu->p2n_mmio = NULL;\n\t}\n\tif (afu->native->p1n_mmio) {\n\t\tiounmap(afu->native->p1n_mmio);\n\t\tafu->native->p1n_mmio = NULL;\n\t}\n\tif (afu->native->afu_desc_mmio) {\n\t\tiounmap(afu->native->afu_desc_mmio);\n\t\tafu->native->afu_desc_mmio = NULL;\n\t}\n}\n\nvoid cxl_pci_release_afu(struct device *dev)\n{\n\tstruct cxl_afu *afu = to_cxl_afu(dev);\n\n\tpr_devel(\"%s\\n\", __func__);\n\n\tidr_destroy(&afu->contexts_idr);\n\tcxl_release_spa(afu);\n\n\tkfree(afu->native);\n\tkfree(afu);\n}\n\n \nstatic int cxl_read_afu_descriptor(struct cxl_afu *afu)\n{\n\tu64 val;\n\n\tval = AFUD_READ_INFO(afu);\n\tafu->pp_irqs = AFUD_NUM_INTS_PER_PROC(val);\n\tafu->max_procs_virtualised = AFUD_NUM_PROCS(val);\n\tafu->crs_num = AFUD_NUM_CRS(val);\n\n\tif (AFUD_AFU_DIRECTED(val))\n\t\tafu->modes_supported |= CXL_MODE_DIRECTED;\n\tif (AFUD_DEDICATED_PROCESS(val))\n\t\tafu->modes_supported |= CXL_MODE_DEDICATED;\n\tif (AFUD_TIME_SLICED(val))\n\t\tafu->modes_supported |= CXL_MODE_TIME_SLICED;\n\n\tval = AFUD_READ_PPPSA(afu);\n\tafu->pp_size = AFUD_PPPSA_LEN(val) * 4096;\n\tafu->psa = AFUD_PPPSA_PSA(val);\n\tif ((afu->pp_psa = AFUD_PPPSA_PP(val)))\n\t\tafu->native->pp_offset = AFUD_READ_PPPSA_OFF(afu);\n\n\tval = AFUD_READ_CR(afu);\n\tafu->crs_len = AFUD_CR_LEN(val) * 256;\n\tafu->crs_offset = AFUD_READ_CR_OFF(afu);\n\n\n\t \n\tafu->eb_len = AFUD_EB_LEN(AFUD_READ_EB(afu)) * 4096;\n\tafu->eb_offset = AFUD_READ_EB_OFF(afu);\n\n\t \n\tif (EXTRACT_PPC_BITS(afu->eb_offset, 0, 11) != 0) {\n\t\tdev_warn(&afu->dev,\n\t\t\t \"Invalid AFU error buffer offset %Lx\\n\",\n\t\t\t afu->eb_offset);\n\t\tdev_info(&afu->dev,\n\t\t\t \"Ignoring AFU error buffer in the descriptor\\n\");\n\t\t \n\t\tafu->eb_len = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxl_afu_descriptor_looks_ok(struct cxl_afu *afu)\n{\n\tint i, rc;\n\tu32 val;\n\n\tif (afu->psa && afu->adapter->ps_size <\n\t\t\t(afu->native->pp_offset + afu->pp_size*afu->max_procs_virtualised)) {\n\t\tdev_err(&afu->dev, \"per-process PSA can't fit inside the PSA!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (afu->pp_psa && (afu->pp_size < PAGE_SIZE))\n\t\tdev_warn(&afu->dev, \"AFU uses pp_size(%#016llx) < PAGE_SIZE per-process PSA!\\n\", afu->pp_size);\n\n\tfor (i = 0; i < afu->crs_num; i++) {\n\t\trc = cxl_ops->afu_cr_read32(afu, i, 0, &val);\n\t\tif (rc || val == 0) {\n\t\t\tdev_err(&afu->dev, \"ABORTING: AFU configuration record %i is invalid\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif ((afu->modes_supported & ~CXL_MODE_DEDICATED) && afu->max_procs_virtualised == 0) {\n\t\t \n\t\tdev_err(&afu->dev, \"AFU does not support any processes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sanitise_afu_regs_psl9(struct cxl_afu *afu)\n{\n\tu64 reg;\n\n\t \n\treg = cxl_p2n_read(afu, CXL_AFU_Cntl_An);\n\tif ((reg & CXL_AFU_Cntl_An_ES_MASK) != CXL_AFU_Cntl_An_ES_Disabled) {\n\t\tdev_warn(&afu->dev, \"WARNING: AFU was not disabled: %#016llx\\n\", reg);\n\t\tif (cxl_ops->afu_reset(afu))\n\t\t\treturn -EIO;\n\t\tif (cxl_afu_disable(afu))\n\t\t\treturn -EIO;\n\t\tif (cxl_psl_purge(afu))\n\t\t\treturn -EIO;\n\t}\n\tcxl_p1n_write(afu, CXL_PSL_SPAP_An, 0x0000000000000000);\n\tcxl_p1n_write(afu, CXL_PSL_AMBAR_An, 0x0000000000000000);\n\treg = cxl_p2n_read(afu, CXL_PSL_DSISR_An);\n\tif (reg) {\n\t\tdev_warn(&afu->dev, \"AFU had pending DSISR: %#016llx\\n\", reg);\n\t\tif (reg & CXL_PSL9_DSISR_An_TF)\n\t\t\tcxl_p2n_write(afu, CXL_PSL_TFC_An, CXL_PSL_TFC_An_AE);\n\t\telse\n\t\t\tcxl_p2n_write(afu, CXL_PSL_TFC_An, CXL_PSL_TFC_An_A);\n\t}\n\tif (afu->adapter->native->sl_ops->register_serr_irq) {\n\t\treg = cxl_p1n_read(afu, CXL_PSL_SERR_An);\n\t\tif (reg) {\n\t\t\tif (reg & ~0x000000007fffffff)\n\t\t\t\tdev_warn(&afu->dev, \"AFU had pending SERR: %#016llx\\n\", reg);\n\t\t\tcxl_p1n_write(afu, CXL_PSL_SERR_An, reg & ~0xffff);\n\t\t}\n\t}\n\treg = cxl_p2n_read(afu, CXL_PSL_ErrStat_An);\n\tif (reg) {\n\t\tdev_warn(&afu->dev, \"AFU had pending error status: %#016llx\\n\", reg);\n\t\tcxl_p2n_write(afu, CXL_PSL_ErrStat_An, reg);\n\t}\n\n\treturn 0;\n}\n\nstatic int sanitise_afu_regs_psl8(struct cxl_afu *afu)\n{\n\tu64 reg;\n\n\t \n\treg = cxl_p2n_read(afu, CXL_AFU_Cntl_An);\n\tif ((reg & CXL_AFU_Cntl_An_ES_MASK) != CXL_AFU_Cntl_An_ES_Disabled) {\n\t\tdev_warn(&afu->dev, \"WARNING: AFU was not disabled: %#016llx\\n\", reg);\n\t\tif (cxl_ops->afu_reset(afu))\n\t\t\treturn -EIO;\n\t\tif (cxl_afu_disable(afu))\n\t\t\treturn -EIO;\n\t\tif (cxl_psl_purge(afu))\n\t\t\treturn -EIO;\n\t}\n\tcxl_p1n_write(afu, CXL_PSL_SPAP_An, 0x0000000000000000);\n\tcxl_p1n_write(afu, CXL_PSL_IVTE_Limit_An, 0x0000000000000000);\n\tcxl_p1n_write(afu, CXL_PSL_IVTE_Offset_An, 0x0000000000000000);\n\tcxl_p1n_write(afu, CXL_PSL_AMBAR_An, 0x0000000000000000);\n\tcxl_p1n_write(afu, CXL_PSL_SPOffset_An, 0x0000000000000000);\n\tcxl_p1n_write(afu, CXL_HAURP_An, 0x0000000000000000);\n\tcxl_p2n_write(afu, CXL_CSRP_An, 0x0000000000000000);\n\tcxl_p2n_write(afu, CXL_AURP1_An, 0x0000000000000000);\n\tcxl_p2n_write(afu, CXL_AURP0_An, 0x0000000000000000);\n\tcxl_p2n_write(afu, CXL_SSTP1_An, 0x0000000000000000);\n\tcxl_p2n_write(afu, CXL_SSTP0_An, 0x0000000000000000);\n\treg = cxl_p2n_read(afu, CXL_PSL_DSISR_An);\n\tif (reg) {\n\t\tdev_warn(&afu->dev, \"AFU had pending DSISR: %#016llx\\n\", reg);\n\t\tif (reg & CXL_PSL_DSISR_TRANS)\n\t\t\tcxl_p2n_write(afu, CXL_PSL_TFC_An, CXL_PSL_TFC_An_AE);\n\t\telse\n\t\t\tcxl_p2n_write(afu, CXL_PSL_TFC_An, CXL_PSL_TFC_An_A);\n\t}\n\tif (afu->adapter->native->sl_ops->register_serr_irq) {\n\t\treg = cxl_p1n_read(afu, CXL_PSL_SERR_An);\n\t\tif (reg) {\n\t\t\tif (reg & ~0xffff)\n\t\t\t\tdev_warn(&afu->dev, \"AFU had pending SERR: %#016llx\\n\", reg);\n\t\t\tcxl_p1n_write(afu, CXL_PSL_SERR_An, reg & ~0xffff);\n\t\t}\n\t}\n\treg = cxl_p2n_read(afu, CXL_PSL_ErrStat_An);\n\tif (reg) {\n\t\tdev_warn(&afu->dev, \"AFU had pending error status: %#016llx\\n\", reg);\n\t\tcxl_p2n_write(afu, CXL_PSL_ErrStat_An, reg);\n\t}\n\n\treturn 0;\n}\n\n#define ERR_BUFF_MAX_COPY_SIZE PAGE_SIZE\n \nssize_t cxl_pci_afu_read_err_buffer(struct cxl_afu *afu, char *buf,\n\t\t\t\tloff_t off, size_t count)\n{\n\tloff_t aligned_start, aligned_end;\n\tsize_t aligned_length;\n\tvoid *tbuf;\n\tconst void __iomem *ebuf = afu->native->afu_desc_mmio + afu->eb_offset;\n\n\tif (count == 0 || off < 0 || (size_t)off >= afu->eb_len)\n\t\treturn 0;\n\n\t \n\tcount = min((size_t)(afu->eb_len - off), count);\n\taligned_start = round_down(off, 8);\n\taligned_end = round_up(off + count, 8);\n\taligned_length = aligned_end - aligned_start;\n\n\t \n\tif (aligned_length > ERR_BUFF_MAX_COPY_SIZE) {\n\t\taligned_length = ERR_BUFF_MAX_COPY_SIZE;\n\t\tcount = ERR_BUFF_MAX_COPY_SIZE - (off & 0x7);\n\t}\n\n\t \n\ttbuf = (void *)__get_free_page(GFP_KERNEL);\n\tif (!tbuf)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy_fromio(tbuf, ebuf + aligned_start, aligned_length);\n\tmemcpy(buf, tbuf + (off & 0x7), count);\n\n\tfree_page((unsigned long)tbuf);\n\n\treturn count;\n}\n\nstatic int pci_configure_afu(struct cxl_afu *afu, struct cxl *adapter, struct pci_dev *dev)\n{\n\tint rc;\n\n\tif ((rc = pci_map_slice_regs(afu, adapter, dev)))\n\t\treturn rc;\n\n\tif (adapter->native->sl_ops->sanitise_afu_regs) {\n\t\trc = adapter->native->sl_ops->sanitise_afu_regs(afu);\n\t\tif (rc)\n\t\t\tgoto err1;\n\t}\n\n\t \n\tif ((rc = cxl_ops->afu_reset(afu)))\n\t\tgoto err1;\n\n\tif (cxl_verbose)\n\t\tdump_afu_descriptor(afu);\n\n\tif ((rc = cxl_read_afu_descriptor(afu)))\n\t\tgoto err1;\n\n\tif ((rc = cxl_afu_descriptor_looks_ok(afu)))\n\t\tgoto err1;\n\n\tif (adapter->native->sl_ops->afu_regs_init)\n\t\tif ((rc = adapter->native->sl_ops->afu_regs_init(afu)))\n\t\t\tgoto err1;\n\n\tif (adapter->native->sl_ops->register_serr_irq)\n\t\tif ((rc = adapter->native->sl_ops->register_serr_irq(afu)))\n\t\t\tgoto err1;\n\n\tif ((rc = cxl_native_register_psl_irq(afu)))\n\t\tgoto err2;\n\n\tatomic_set(&afu->configured_state, 0);\n\treturn 0;\n\nerr2:\n\tif (adapter->native->sl_ops->release_serr_irq)\n\t\tadapter->native->sl_ops->release_serr_irq(afu);\nerr1:\n\tpci_unmap_slice_regs(afu);\n\treturn rc;\n}\n\nstatic void pci_deconfigure_afu(struct cxl_afu *afu)\n{\n\t \n\tif (atomic_read(&afu->configured_state) != -1) {\n\t\twhile (atomic_cmpxchg(&afu->configured_state, 0, -1) != -1)\n\t\t\tschedule();\n\t}\n\tcxl_native_release_psl_irq(afu);\n\tif (afu->adapter->native->sl_ops->release_serr_irq)\n\t\tafu->adapter->native->sl_ops->release_serr_irq(afu);\n\tpci_unmap_slice_regs(afu);\n}\n\nstatic int pci_init_afu(struct cxl *adapter, int slice, struct pci_dev *dev)\n{\n\tstruct cxl_afu *afu;\n\tint rc = -ENOMEM;\n\n\tafu = cxl_alloc_afu(adapter, slice);\n\tif (!afu)\n\t\treturn -ENOMEM;\n\n\tafu->native = kzalloc(sizeof(struct cxl_afu_native), GFP_KERNEL);\n\tif (!afu->native)\n\t\tgoto err_free_afu;\n\n\tmutex_init(&afu->native->spa_mutex);\n\n\trc = dev_set_name(&afu->dev, \"afu%i.%i\", adapter->adapter_num, slice);\n\tif (rc)\n\t\tgoto err_free_native;\n\n\trc = pci_configure_afu(afu, adapter, dev);\n\tif (rc)\n\t\tgoto err_free_native;\n\n\t \n\tcxl_debugfs_afu_add(afu);\n\n\t \n\tif ((rc = cxl_register_afu(afu)))\n\t\tgoto err_put_dev;\n\n\tif ((rc = cxl_sysfs_afu_add(afu)))\n\t\tgoto err_del_dev;\n\n\tadapter->afu[afu->slice] = afu;\n\n\tif ((rc = cxl_pci_vphb_add(afu)))\n\t\tdev_info(&afu->dev, \"Can't register vPHB\\n\");\n\n\treturn 0;\n\nerr_del_dev:\n\tdevice_del(&afu->dev);\nerr_put_dev:\n\tpci_deconfigure_afu(afu);\n\tcxl_debugfs_afu_remove(afu);\n\tput_device(&afu->dev);\n\treturn rc;\n\nerr_free_native:\n\tkfree(afu->native);\nerr_free_afu:\n\tkfree(afu);\n\treturn rc;\n\n}\n\nstatic void cxl_pci_remove_afu(struct cxl_afu *afu)\n{\n\tpr_devel(\"%s\\n\", __func__);\n\n\tif (!afu)\n\t\treturn;\n\n\tcxl_pci_vphb_remove(afu);\n\tcxl_sysfs_afu_remove(afu);\n\tcxl_debugfs_afu_remove(afu);\n\n\tspin_lock(&afu->adapter->afu_list_lock);\n\tafu->adapter->afu[afu->slice] = NULL;\n\tspin_unlock(&afu->adapter->afu_list_lock);\n\n\tcxl_context_detach_all(afu);\n\tcxl_ops->afu_deactivate_mode(afu, afu->current_mode);\n\n\tpci_deconfigure_afu(afu);\n\tdevice_unregister(&afu->dev);\n}\n\nint cxl_pci_reset(struct cxl *adapter)\n{\n\tstruct pci_dev *dev = to_pci_dev(adapter->dev.parent);\n\tint rc;\n\n\tif (adapter->perst_same_image) {\n\t\tdev_warn(&dev->dev,\n\t\t\t \"cxl: refusing to reset/reflash when perst_reloads_same_image is set.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(&dev->dev, \"CXL reset\\n\");\n\n\t \n\tcxl_data_cache_flush(adapter);\n\n\t \n\tif ((rc = pci_set_pcie_reset_state(dev, pcie_warm_reset))) {\n\t\tdev_err(&dev->dev, \"cxl: pcie_warm_reset failed\\n\");\n\t\treturn rc;\n\t}\n\n\treturn rc;\n}\n\nstatic int cxl_map_adapter_regs(struct cxl *adapter, struct pci_dev *dev)\n{\n\tif (pci_request_region(dev, 2, \"priv 2 regs\"))\n\t\tgoto err1;\n\tif (pci_request_region(dev, 0, \"priv 1 regs\"))\n\t\tgoto err2;\n\n\tpr_devel(\"cxl_map_adapter_regs: p1: %#016llx %#llx, p2: %#016llx %#llx\",\n\t\t\tp1_base(dev), p1_size(dev), p2_base(dev), p2_size(dev));\n\n\tif (!(adapter->native->p1_mmio = ioremap(p1_base(dev), p1_size(dev))))\n\t\tgoto err3;\n\n\tif (!(adapter->native->p2_mmio = ioremap(p2_base(dev), p2_size(dev))))\n\t\tgoto err4;\n\n\treturn 0;\n\nerr4:\n\tiounmap(adapter->native->p1_mmio);\n\tadapter->native->p1_mmio = NULL;\nerr3:\n\tpci_release_region(dev, 0);\nerr2:\n\tpci_release_region(dev, 2);\nerr1:\n\treturn -ENOMEM;\n}\n\nstatic void cxl_unmap_adapter_regs(struct cxl *adapter)\n{\n\tif (adapter->native->p1_mmio) {\n\t\tiounmap(adapter->native->p1_mmio);\n\t\tadapter->native->p1_mmio = NULL;\n\t\tpci_release_region(to_pci_dev(adapter->dev.parent), 2);\n\t}\n\tif (adapter->native->p2_mmio) {\n\t\tiounmap(adapter->native->p2_mmio);\n\t\tadapter->native->p2_mmio = NULL;\n\t\tpci_release_region(to_pci_dev(adapter->dev.parent), 0);\n\t}\n}\n\nstatic int cxl_read_vsec(struct cxl *adapter, struct pci_dev *dev)\n{\n\tint vsec;\n\tu32 afu_desc_off, afu_desc_size;\n\tu32 ps_off, ps_size;\n\tu16 vseclen;\n\tu8 image_state;\n\n\tif (!(vsec = find_cxl_vsec(dev))) {\n\t\tdev_err(&dev->dev, \"ABORTING: CXL VSEC not found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tCXL_READ_VSEC_LENGTH(dev, vsec, &vseclen);\n\tif (vseclen < CXL_VSEC_MIN_SIZE) {\n\t\tdev_err(&dev->dev, \"ABORTING: CXL VSEC too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tCXL_READ_VSEC_STATUS(dev, vsec, &adapter->vsec_status);\n\tCXL_READ_VSEC_PSL_REVISION(dev, vsec, &adapter->psl_rev);\n\tCXL_READ_VSEC_CAIA_MAJOR(dev, vsec, &adapter->caia_major);\n\tCXL_READ_VSEC_CAIA_MINOR(dev, vsec, &adapter->caia_minor);\n\tCXL_READ_VSEC_BASE_IMAGE(dev, vsec, &adapter->base_image);\n\tCXL_READ_VSEC_IMAGE_STATE(dev, vsec, &image_state);\n\tadapter->user_image_loaded = !!(image_state & CXL_VSEC_USER_IMAGE_LOADED);\n\tadapter->perst_select_user = !!(image_state & CXL_VSEC_USER_IMAGE_LOADED);\n\tadapter->perst_loads_image = !!(image_state & CXL_VSEC_PERST_LOADS_IMAGE);\n\n\tCXL_READ_VSEC_NAFUS(dev, vsec, &adapter->slices);\n\tCXL_READ_VSEC_AFU_DESC_OFF(dev, vsec, &afu_desc_off);\n\tCXL_READ_VSEC_AFU_DESC_SIZE(dev, vsec, &afu_desc_size);\n\tCXL_READ_VSEC_PS_OFF(dev, vsec, &ps_off);\n\tCXL_READ_VSEC_PS_SIZE(dev, vsec, &ps_size);\n\n\t \n\tadapter->native->ps_off = ps_off * 64 * 1024;\n\tadapter->ps_size = ps_size * 64 * 1024;\n\tadapter->native->afu_desc_off = afu_desc_off * 64 * 1024;\n\tadapter->native->afu_desc_size = afu_desc_size * 64 * 1024;\n\n\t \n\tadapter->user_irqs = pnv_cxl_get_irq_count(dev) - 1 - 2*adapter->slices;\n\n\treturn 0;\n}\n\n \nstatic void cxl_fixup_malformed_tlp(struct cxl *adapter, struct pci_dev *dev)\n{\n\tint aer;\n\tu32 data;\n\n\tif (adapter->psl_rev & 0xf000)\n\t\treturn;\n\tif (!(aer = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR)))\n\t\treturn;\n\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_MASK, &data);\n\tif (data & PCI_ERR_UNC_MALF_TLP)\n\t\tif (data & PCI_ERR_UNC_INTN)\n\t\t\treturn;\n\tdata |= PCI_ERR_UNC_MALF_TLP;\n\tdata |= PCI_ERR_UNC_INTN;\n\tpci_write_config_dword(dev, aer + PCI_ERR_UNCOR_MASK, data);\n}\n\nstatic bool cxl_compatible_caia_version(struct cxl *adapter)\n{\n\tif (cxl_is_power8() && (adapter->caia_major == 1))\n\t\treturn true;\n\n\tif (cxl_is_power9() && (adapter->caia_major == 2))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int cxl_vsec_looks_ok(struct cxl *adapter, struct pci_dev *dev)\n{\n\tif (adapter->vsec_status & CXL_STATUS_SECOND_PORT)\n\t\treturn -EBUSY;\n\n\tif (adapter->vsec_status & CXL_UNSUPPORTED_FEATURES) {\n\t\tdev_err(&dev->dev, \"ABORTING: CXL requires unsupported features\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cxl_compatible_caia_version(adapter)) {\n\t\tdev_info(&dev->dev, \"Ignoring card. PSL type is not supported (caia version: %d)\\n\",\n\t\t\t adapter->caia_major);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!adapter->slices) {\n\t\t \n\t\tdev_err(&dev->dev, \"ABORTING: Device has no AFUs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!adapter->native->afu_desc_off || !adapter->native->afu_desc_size) {\n\t\tdev_err(&dev->dev, \"ABORTING: VSEC shows no AFU descriptors\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (adapter->ps_size > p2_size(dev) - adapter->native->ps_off) {\n\t\tdev_err(&dev->dev, \"ABORTING: Problem state size larger than \"\n\t\t\t\t   \"available in BAR2: 0x%llx > 0x%llx\\n\",\n\t\t\t adapter->ps_size, p2_size(dev) - adapter->native->ps_off);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nssize_t cxl_pci_read_adapter_vpd(struct cxl *adapter, void *buf, size_t len)\n{\n\treturn pci_read_vpd(to_pci_dev(adapter->dev.parent), 0, len, buf);\n}\n\nstatic void cxl_release_adapter(struct device *dev)\n{\n\tstruct cxl *adapter = to_cxl_adapter(dev);\n\n\tpr_devel(\"cxl_release_adapter\\n\");\n\n\tcxl_remove_adapter_nr(adapter);\n\n\tkfree(adapter->native);\n\tkfree(adapter);\n}\n\n#define CXL_PSL_ErrIVTE_tberror (0x1ull << (63-31))\n\nstatic int sanitise_adapter_regs(struct cxl *adapter)\n{\n\tint rc = 0;\n\n\t \n\tcxl_p1_write(adapter, CXL_PSL_ErrIVTE, CXL_PSL_ErrIVTE_tberror);\n\n\tif (adapter->native->sl_ops->invalidate_all) {\n\t\t \n\t\tif (cxl_is_power9() && (adapter->perst_loads_image))\n\t\t\treturn 0;\n\t\trc = adapter->native->sl_ops->invalidate_all(adapter);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int cxl_configure_adapter(struct cxl *adapter, struct pci_dev *dev)\n{\n\tint rc;\n\n\tadapter->dev.parent = &dev->dev;\n\tadapter->dev.release = cxl_release_adapter;\n\tpci_set_drvdata(dev, adapter);\n\n\trc = pci_enable_device(dev);\n\tif (rc) {\n\t\tdev_err(&dev->dev, \"pci_enable_device failed: %i\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif ((rc = cxl_read_vsec(adapter, dev)))\n\t\treturn rc;\n\n\tif ((rc = cxl_vsec_looks_ok(adapter, dev)))\n\t        return rc;\n\n\tcxl_fixup_malformed_tlp(adapter, dev);\n\n\tif ((rc = setup_cxl_bars(dev)))\n\t\treturn rc;\n\n\tif ((rc = switch_card_to_cxl(dev)))\n\t\treturn rc;\n\n\tif ((rc = cxl_update_image_control(adapter)))\n\t\treturn rc;\n\n\tif ((rc = cxl_map_adapter_regs(adapter, dev)))\n\t\treturn rc;\n\n\tif ((rc = sanitise_adapter_regs(adapter)))\n\t\tgoto err;\n\n\tif ((rc = adapter->native->sl_ops->adapter_regs_init(adapter, dev)))\n\t\tgoto err;\n\n\t \n\tpci_set_master(dev);\n\n\tadapter->tunneled_ops_supported = false;\n\n\tif (cxl_is_power9()) {\n\t\tif (pnv_pci_set_tunnel_bar(dev, 0x00020000E0000000ull, 1))\n\t\t\tdev_info(&dev->dev, \"Tunneled operations unsupported\\n\");\n\t\telse\n\t\t\tadapter->tunneled_ops_supported = true;\n\t}\n\n\tif ((rc = pnv_phb_to_cxl_mode(dev, adapter->native->sl_ops->capi_mode)))\n\t\tgoto err;\n\n\t \n\tif ((rc = pnv_phb_to_cxl_mode(dev, OPAL_PHB_CAPI_MODE_SNOOP_ON)))\n\t\tgoto err;\n\n\t \n\tcxl_setup_psl_timebase(adapter, dev);\n\n\tif ((rc = cxl_native_register_psl_err_irq(adapter)))\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tcxl_unmap_adapter_regs(adapter);\n\treturn rc;\n\n}\n\nstatic void cxl_deconfigure_adapter(struct cxl *adapter)\n{\n\tstruct pci_dev *pdev = to_pci_dev(adapter->dev.parent);\n\n\tif (cxl_is_power9())\n\t\tpnv_pci_set_tunnel_bar(pdev, 0x00020000E0000000ull, 0);\n\n\tcxl_native_release_psl_err_irq(adapter);\n\tcxl_unmap_adapter_regs(adapter);\n\n\tpci_disable_device(pdev);\n}\n\nstatic void cxl_stop_trace_psl9(struct cxl *adapter)\n{\n\tint traceid;\n\tu64 trace_state, trace_mask;\n\tstruct pci_dev *dev = to_pci_dev(adapter->dev.parent);\n\n\t \n\tfor (traceid = 0; traceid <= CXL_PSL9_TRACEID_MAX; ++traceid) {\n\t\ttrace_state = cxl_p1_read(adapter, CXL_PSL9_CTCCFG);\n\t\ttrace_mask = (0x3ULL << (62 - traceid * 2));\n\t\ttrace_state = (trace_state & trace_mask) >> (62 - traceid * 2);\n\t\tdev_dbg(&dev->dev, \"cxl: Traceid-%d trace_state=0x%0llX\\n\",\n\t\t\ttraceid, trace_state);\n\n\t\t \n\t\tif (trace_state != CXL_PSL9_TRACESTATE_FIN)\n\t\t\tcxl_p1_write(adapter, CXL_PSL9_TRACECFG,\n\t\t\t\t     0x8400000000000000ULL | traceid);\n\t}\n}\n\nstatic void cxl_stop_trace_psl8(struct cxl *adapter)\n{\n\tint slice;\n\n\t \n\tcxl_p1_write(adapter, CXL_PSL_TRACE, 0x8000000000000017LL);\n\n\t \n\tspin_lock(&adapter->afu_list_lock);\n\tfor (slice = 0; slice < adapter->slices; slice++) {\n\t\tif (adapter->afu[slice])\n\t\t\tcxl_p1n_write(adapter->afu[slice], CXL_PSL_SLICE_TRACE,\n\t\t\t\t      0x8000000000000000LL);\n\t}\n\tspin_unlock(&adapter->afu_list_lock);\n}\n\nstatic const struct cxl_service_layer_ops psl9_ops = {\n\t.adapter_regs_init = init_implementation_adapter_regs_psl9,\n\t.invalidate_all = cxl_invalidate_all_psl9,\n\t.afu_regs_init = init_implementation_afu_regs_psl9,\n\t.sanitise_afu_regs = sanitise_afu_regs_psl9,\n\t.register_serr_irq = cxl_native_register_serr_irq,\n\t.release_serr_irq = cxl_native_release_serr_irq,\n\t.handle_interrupt = cxl_irq_psl9,\n\t.fail_irq = cxl_fail_irq_psl,\n\t.activate_dedicated_process = cxl_activate_dedicated_process_psl9,\n\t.attach_afu_directed = cxl_attach_afu_directed_psl9,\n\t.attach_dedicated_process = cxl_attach_dedicated_process_psl9,\n\t.update_dedicated_ivtes = cxl_update_dedicated_ivtes_psl9,\n\t.debugfs_add_adapter_regs = cxl_debugfs_add_adapter_regs_psl9,\n\t.debugfs_add_afu_regs = cxl_debugfs_add_afu_regs_psl9,\n\t.psl_irq_dump_registers = cxl_native_irq_dump_regs_psl9,\n\t.err_irq_dump_registers = cxl_native_err_irq_dump_regs_psl9,\n\t.debugfs_stop_trace = cxl_stop_trace_psl9,\n\t.timebase_read = timebase_read_psl9,\n\t.capi_mode = OPAL_PHB_CAPI_MODE_CAPI,\n\t.needs_reset_before_disable = true,\n};\n\nstatic const struct cxl_service_layer_ops psl8_ops = {\n\t.adapter_regs_init = init_implementation_adapter_regs_psl8,\n\t.invalidate_all = cxl_invalidate_all_psl8,\n\t.afu_regs_init = init_implementation_afu_regs_psl8,\n\t.sanitise_afu_regs = sanitise_afu_regs_psl8,\n\t.register_serr_irq = cxl_native_register_serr_irq,\n\t.release_serr_irq = cxl_native_release_serr_irq,\n\t.handle_interrupt = cxl_irq_psl8,\n\t.fail_irq = cxl_fail_irq_psl,\n\t.activate_dedicated_process = cxl_activate_dedicated_process_psl8,\n\t.attach_afu_directed = cxl_attach_afu_directed_psl8,\n\t.attach_dedicated_process = cxl_attach_dedicated_process_psl8,\n\t.update_dedicated_ivtes = cxl_update_dedicated_ivtes_psl8,\n\t.debugfs_add_adapter_regs = cxl_debugfs_add_adapter_regs_psl8,\n\t.debugfs_add_afu_regs = cxl_debugfs_add_afu_regs_psl8,\n\t.psl_irq_dump_registers = cxl_native_irq_dump_regs_psl8,\n\t.err_irq_dump_registers = cxl_native_err_irq_dump_regs_psl8,\n\t.debugfs_stop_trace = cxl_stop_trace_psl8,\n\t.write_timebase_ctrl = write_timebase_ctrl_psl8,\n\t.timebase_read = timebase_read_psl8,\n\t.capi_mode = OPAL_PHB_CAPI_MODE_CAPI,\n\t.needs_reset_before_disable = true,\n};\n\nstatic void set_sl_ops(struct cxl *adapter, struct pci_dev *dev)\n{\n\tif (cxl_is_power8()) {\n\t\tdev_info(&dev->dev, \"Device uses a PSL8\\n\");\n\t\tadapter->native->sl_ops = &psl8_ops;\n\t} else {\n\t\tdev_info(&dev->dev, \"Device uses a PSL9\\n\");\n\t\tadapter->native->sl_ops = &psl9_ops;\n\t}\n}\n\n\nstatic struct cxl *cxl_pci_init_adapter(struct pci_dev *dev)\n{\n\tstruct cxl *adapter;\n\tint rc;\n\n\tadapter = cxl_alloc_adapter();\n\tif (!adapter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tadapter->native = kzalloc(sizeof(struct cxl_native), GFP_KERNEL);\n\tif (!adapter->native) {\n\t\trc = -ENOMEM;\n\t\tgoto err_release;\n\t}\n\n\tset_sl_ops(adapter, dev);\n\n\t \n\tadapter->perst_loads_image = true;\n\tadapter->perst_same_image = false;\n\n\trc = cxl_configure_adapter(adapter, dev);\n\tif (rc) {\n\t\tpci_disable_device(dev);\n\t\tgoto err_release;\n\t}\n\n\t \n\tcxl_debugfs_adapter_add(adapter);\n\n\t \n\tif ((rc = cxl_register_adapter(adapter)))\n\t\tgoto err_put_dev;\n\n\tif ((rc = cxl_sysfs_adapter_add(adapter)))\n\t\tgoto err_del_dev;\n\n\t \n\tcxl_adapter_context_unlock(adapter);\n\n\treturn adapter;\n\nerr_del_dev:\n\tdevice_del(&adapter->dev);\nerr_put_dev:\n\t \n\tcxl_debugfs_adapter_remove(adapter);\n\tcxl_deconfigure_adapter(adapter);\n\tput_device(&adapter->dev);\n\treturn ERR_PTR(rc);\n\nerr_release:\n\tcxl_release_adapter(&adapter->dev);\n\treturn ERR_PTR(rc);\n}\n\nstatic void cxl_pci_remove_adapter(struct cxl *adapter)\n{\n\tpr_devel(\"cxl_remove_adapter\\n\");\n\n\tcxl_sysfs_adapter_remove(adapter);\n\tcxl_debugfs_adapter_remove(adapter);\n\n\t \n\tcxl_data_cache_flush(adapter);\n\n\tcxl_deconfigure_adapter(adapter);\n\n\tdevice_unregister(&adapter->dev);\n}\n\n#define CXL_MAX_PCIEX_PARENT 2\n\nint cxl_slot_is_switched(struct pci_dev *dev)\n{\n\tstruct device_node *np;\n\tint depth = 0;\n\n\tif (!(np = pci_device_to_OF_node(dev))) {\n\t\tpr_err(\"cxl: np = NULL\\n\");\n\t\treturn -ENODEV;\n\t}\n\tof_node_get(np);\n\twhile (np) {\n\t\tnp = of_get_next_parent(np);\n\t\tif (!of_node_is_type(np, \"pciex\"))\n\t\t\tbreak;\n\t\tdepth++;\n\t}\n\tof_node_put(np);\n\treturn (depth > CXL_MAX_PCIEX_PARENT);\n}\n\nstatic int cxl_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct cxl *adapter;\n\tint slice;\n\tint rc;\n\n\tif (cxl_pci_is_vphb_device(dev)) {\n\t\tdev_dbg(&dev->dev, \"cxl_init_adapter: Ignoring cxl vphb device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (cxl_slot_is_switched(dev)) {\n\t\tdev_info(&dev->dev, \"Ignoring card on incompatible PCI slot\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (cxl_is_power9() && !radix_enabled()) {\n\t\tdev_info(&dev->dev, \"Only Radix mode supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (cxl_verbose)\n\t\tdump_cxl_config_space(dev);\n\n\tadapter = cxl_pci_init_adapter(dev);\n\tif (IS_ERR(adapter)) {\n\t\tdev_err(&dev->dev, \"cxl_init_adapter failed: %li\\n\", PTR_ERR(adapter));\n\t\treturn PTR_ERR(adapter);\n\t}\n\n\tfor (slice = 0; slice < adapter->slices; slice++) {\n\t\tif ((rc = pci_init_afu(adapter, slice, dev))) {\n\t\t\tdev_err(&dev->dev, \"AFU %i failed to initialise: %i\\n\", slice, rc);\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = cxl_afu_select_best_mode(adapter->afu[slice]);\n\t\tif (rc)\n\t\t\tdev_err(&dev->dev, \"AFU %i failed to start: %i\\n\", slice, rc);\n\t}\n\n\treturn 0;\n}\n\nstatic void cxl_remove(struct pci_dev *dev)\n{\n\tstruct cxl *adapter = pci_get_drvdata(dev);\n\tstruct cxl_afu *afu;\n\tint i;\n\n\t \n\tfor (i = 0; i < adapter->slices; i++) {\n\t\tafu = adapter->afu[i];\n\t\tcxl_pci_remove_afu(afu);\n\t}\n\tcxl_pci_remove_adapter(adapter);\n}\n\nstatic pci_ers_result_t cxl_vphb_error_detected(struct cxl_afu *afu,\n\t\t\t\t\t\tpci_channel_state_t state)\n{\n\tstruct pci_dev *afu_dev;\n\tstruct pci_driver *afu_drv;\n\tconst struct pci_error_handlers *err_handler;\n\tpci_ers_result_t result = PCI_ERS_RESULT_NEED_RESET;\n\tpci_ers_result_t afu_result = PCI_ERS_RESULT_NEED_RESET;\n\n\t \n\tif (afu == NULL || afu->phb == NULL)\n\t\treturn result;\n\n\tlist_for_each_entry(afu_dev, &afu->phb->bus->devices, bus_list) {\n\t\tafu_drv = to_pci_driver(afu_dev->dev.driver);\n\t\tif (!afu_drv)\n\t\t\tcontinue;\n\n\t\tafu_dev->error_state = state;\n\n\t\terr_handler = afu_drv->err_handler;\n\t\tif (err_handler)\n\t\t\tafu_result = err_handler->error_detected(afu_dev,\n\t\t\t\t\t\t\t\t state);\n\t\t \n\t\tif (afu_result == PCI_ERS_RESULT_DISCONNECT)\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\telse if ((afu_result == PCI_ERS_RESULT_NONE) &&\n\t\t\t (result == PCI_ERS_RESULT_NEED_RESET))\n\t\t\tresult = PCI_ERS_RESULT_NONE;\n\t}\n\treturn result;\n}\n\nstatic pci_ers_result_t cxl_pci_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t       pci_channel_state_t state)\n{\n\tstruct cxl *adapter = pci_get_drvdata(pdev);\n\tstruct cxl_afu *afu;\n\tpci_ers_result_t result = PCI_ERS_RESULT_NEED_RESET;\n\tpci_ers_result_t afu_result = PCI_ERS_RESULT_NEED_RESET;\n\tint i;\n\n\t \n\tschedule();\n\n\t \n\tif (state == pci_channel_io_perm_failure) {\n\t\tspin_lock(&adapter->afu_list_lock);\n\t\tfor (i = 0; i < adapter->slices; i++) {\n\t\t\tafu = adapter->afu[i];\n\t\t\t \n\t\t\tcxl_vphb_error_detected(afu, state);\n\t\t}\n\t\tspin_unlock(&adapter->afu_list_lock);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\t \n\tif (adapter->perst_loads_image && !adapter->perst_same_image) {\n\t\t \n\t\tdev_info(&pdev->dev, \"reflashing, so opting out of EEH!\\n\");\n\t\treturn PCI_ERS_RESULT_NONE;\n\t}\n\n\t \n\n\t \n\tspin_lock(&adapter->afu_list_lock);\n\n\tfor (i = 0; i < adapter->slices; i++) {\n\t\tafu = adapter->afu[i];\n\n\t\tif (afu == NULL)\n\t\t\tcontinue;\n\n\t\tafu_result = cxl_vphb_error_detected(afu, state);\n\t\tcxl_context_detach_all(afu);\n\t\tcxl_ops->afu_deactivate_mode(afu, afu->current_mode);\n\t\tpci_deconfigure_afu(afu);\n\n\t\t \n\t\tif (afu_result == PCI_ERS_RESULT_DISCONNECT)\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\telse if ((afu_result == PCI_ERS_RESULT_NONE) &&\n\t\t\t (result == PCI_ERS_RESULT_NEED_RESET))\n\t\t\tresult = PCI_ERS_RESULT_NONE;\n\t}\n\tspin_unlock(&adapter->afu_list_lock);\n\n\t \n\tif (cxl_adapter_context_lock(adapter) != 0)\n\t\tdev_warn(&adapter->dev,\n\t\t\t \"Couldn't take context lock with %d active-contexts\\n\",\n\t\t\t atomic_read(&adapter->contexts_num));\n\n\tcxl_deconfigure_adapter(adapter);\n\n\treturn result;\n}\n\nstatic pci_ers_result_t cxl_pci_slot_reset(struct pci_dev *pdev)\n{\n\tstruct cxl *adapter = pci_get_drvdata(pdev);\n\tstruct cxl_afu *afu;\n\tstruct cxl_context *ctx;\n\tstruct pci_dev *afu_dev;\n\tstruct pci_driver *afu_drv;\n\tconst struct pci_error_handlers *err_handler;\n\tpci_ers_result_t afu_result = PCI_ERS_RESULT_RECOVERED;\n\tpci_ers_result_t result = PCI_ERS_RESULT_RECOVERED;\n\tint i;\n\n\tif (cxl_configure_adapter(adapter, pdev))\n\t\tgoto err;\n\n\t \n\tcxl_adapter_context_unlock(adapter);\n\n\tspin_lock(&adapter->afu_list_lock);\n\tfor (i = 0; i < adapter->slices; i++) {\n\t\tafu = adapter->afu[i];\n\n\t\tif (afu == NULL)\n\t\t\tcontinue;\n\n\t\tif (pci_configure_afu(afu, adapter, pdev))\n\t\t\tgoto err_unlock;\n\n\t\tif (cxl_afu_select_best_mode(afu))\n\t\t\tgoto err_unlock;\n\n\t\tif (afu->phb == NULL)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(afu_dev, &afu->phb->bus->devices, bus_list) {\n\t\t\t \n\t\t\tctx = cxl_get_context(afu_dev);\n\n\t\t\tif (ctx && cxl_release_context(ctx))\n\t\t\t\tgoto err_unlock;\n\n\t\t\tctx = cxl_dev_context_init(afu_dev);\n\t\t\tif (IS_ERR(ctx))\n\t\t\t\tgoto err_unlock;\n\n\t\t\tafu_dev->dev.archdata.cxl_ctx = ctx;\n\n\t\t\tif (cxl_ops->afu_check_and_enable(afu))\n\t\t\t\tgoto err_unlock;\n\n\t\t\tafu_dev->error_state = pci_channel_io_normal;\n\n\t\t\t \n\t\t\tafu_drv = to_pci_driver(afu_dev->dev.driver);\n\t\t\tif (!afu_drv)\n\t\t\t\tcontinue;\n\n\t\t\terr_handler = afu_drv->err_handler;\n\t\t\tif (err_handler && err_handler->slot_reset)\n\t\t\t\tafu_result = err_handler->slot_reset(afu_dev);\n\n\t\t\tif (afu_result == PCI_ERS_RESULT_DISCONNECT)\n\t\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\tspin_unlock(&adapter->afu_list_lock);\n\treturn result;\n\nerr_unlock:\n\tspin_unlock(&adapter->afu_list_lock);\n\nerr:\n\t \n\tdev_err(&pdev->dev, \"EEH recovery failed. Asking to be disconnected.\\n\");\n\treturn PCI_ERS_RESULT_DISCONNECT;\n}\n\nstatic void cxl_pci_resume(struct pci_dev *pdev)\n{\n\tstruct cxl *adapter = pci_get_drvdata(pdev);\n\tstruct cxl_afu *afu;\n\tstruct pci_dev *afu_dev;\n\tstruct pci_driver *afu_drv;\n\tconst struct pci_error_handlers *err_handler;\n\tint i;\n\n\t \n\tspin_lock(&adapter->afu_list_lock);\n\tfor (i = 0; i < adapter->slices; i++) {\n\t\tafu = adapter->afu[i];\n\n\t\tif (afu == NULL || afu->phb == NULL)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(afu_dev, &afu->phb->bus->devices, bus_list) {\n\t\t\tafu_drv = to_pci_driver(afu_dev->dev.driver);\n\t\t\tif (!afu_drv)\n\t\t\t\tcontinue;\n\n\t\t\terr_handler = afu_drv->err_handler;\n\t\t\tif (err_handler && err_handler->resume)\n\t\t\t\terr_handler->resume(afu_dev);\n\t\t}\n\t}\n\tspin_unlock(&adapter->afu_list_lock);\n}\n\nstatic const struct pci_error_handlers cxl_err_handler = {\n\t.error_detected = cxl_pci_error_detected,\n\t.slot_reset = cxl_pci_slot_reset,\n\t.resume = cxl_pci_resume,\n};\n\nstruct pci_driver cxl_pci_driver = {\n\t.name = \"cxl-pci\",\n\t.id_table = cxl_pci_tbl,\n\t.probe = cxl_probe,\n\t.remove = cxl_remove,\n\t.shutdown = cxl_remove,\n\t.err_handler = &cxl_err_handler,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}