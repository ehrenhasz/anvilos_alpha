{
  "module_name": "main.c",
  "hash_id": "7e52655b10182f483bb6d3d08dee398aa23a7058ee3d644469f2c0dd60bc0646",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cxl/main.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/sched/task.h>\n\n#include <asm/cputable.h>\n#include <asm/mmu.h>\n#include <misc/cxl-base.h>\n\n#include \"cxl.h\"\n#include \"trace.h\"\n\nstatic DEFINE_SPINLOCK(adapter_idr_lock);\nstatic DEFINE_IDR(cxl_adapter_idr);\n\nuint cxl_verbose;\nmodule_param_named(verbose, cxl_verbose, uint, 0600);\nMODULE_PARM_DESC(verbose, \"Enable verbose dmesg output\");\n\nconst struct cxl_backend_ops *cxl_ops;\n\nint cxl_afu_slbia(struct cxl_afu *afu)\n{\n\tunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\n\n\tpr_devel(\"cxl_afu_slbia issuing SLBIA command\\n\");\n\tcxl_p2n_write(afu, CXL_SLBIA_An, CXL_TLB_SLB_IQ_ALL);\n\twhile (cxl_p2n_read(afu, CXL_SLBIA_An) & CXL_TLB_SLB_P) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tdev_warn(&afu->dev, \"WARNING: CXL AFU SLBIA timed out!\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t \n\t\tif (!cxl_ops->link_ok(afu->adapter, afu))\n\t\t\treturn -EIO;\n\t\tcpu_relax();\n\t}\n\treturn 0;\n}\n\nstatic inline void _cxl_slbia(struct cxl_context *ctx, struct mm_struct *mm)\n{\n\tunsigned long flags;\n\n\tif (ctx->mm != mm)\n\t\treturn;\n\n\tpr_devel(\"%s matched mm - card: %i afu: %i pe: %i\\n\", __func__,\n\t\t ctx->afu->adapter->adapter_num, ctx->afu->slice, ctx->pe);\n\n\tspin_lock_irqsave(&ctx->sste_lock, flags);\n\ttrace_cxl_slbia(ctx);\n\tmemset(ctx->sstp, 0, ctx->sst_size);\n\tspin_unlock_irqrestore(&ctx->sste_lock, flags);\n\tmb();\n\tcxl_afu_slbia(ctx->afu);\n}\n\nstatic inline void cxl_slbia_core(struct mm_struct *mm)\n{\n\tstruct cxl *adapter;\n\tstruct cxl_afu *afu;\n\tstruct cxl_context *ctx;\n\tint card, slice, id;\n\n\tpr_devel(\"%s called\\n\", __func__);\n\n\tspin_lock(&adapter_idr_lock);\n\tidr_for_each_entry(&cxl_adapter_idr, adapter, card) {\n\t\t \n\t\tspin_lock(&adapter->afu_list_lock);\n\t\tfor (slice = 0; slice < adapter->slices; slice++) {\n\t\t\tafu = adapter->afu[slice];\n\t\t\tif (!afu || !afu->enabled)\n\t\t\t\tcontinue;\n\t\t\trcu_read_lock();\n\t\t\tidr_for_each_entry(&afu->contexts_idr, ctx, id)\n\t\t\t\t_cxl_slbia(ctx, mm);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\tspin_unlock(&adapter->afu_list_lock);\n\t}\n\tspin_unlock(&adapter_idr_lock);\n}\n\nstatic struct cxl_calls cxl_calls = {\n\t.cxl_slbia = cxl_slbia_core,\n\t.owner = THIS_MODULE,\n};\n\nint cxl_alloc_sst(struct cxl_context *ctx)\n{\n\tunsigned long vsid;\n\tu64 ea_mask, size, sstp0, sstp1;\n\n\tsstp0 = 0;\n\tsstp1 = 0;\n\n\tctx->sst_size = PAGE_SIZE;\n\tctx->sst_lru = 0;\n\tctx->sstp = (struct cxl_sste *)get_zeroed_page(GFP_KERNEL);\n\tif (!ctx->sstp) {\n\t\tpr_err(\"cxl_alloc_sst: Unable to allocate segment table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpr_devel(\"SSTP allocated at 0x%p\\n\", ctx->sstp);\n\n\tvsid  = get_kernel_vsid((u64)ctx->sstp, mmu_kernel_ssize) << 12;\n\n\tsstp0 |= (u64)mmu_kernel_ssize << CXL_SSTP0_An_B_SHIFT;\n\tsstp0 |= (SLB_VSID_KERNEL | mmu_psize_defs[mmu_linear_psize].sllp) << 50;\n\n\tsize = (((u64)ctx->sst_size >> 8) - 1) << CXL_SSTP0_An_SegTableSize_SHIFT;\n\tif (unlikely(size & ~CXL_SSTP0_An_SegTableSize_MASK)) {\n\t\tWARN(1, \"Impossible segment table size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsstp0 |= size;\n\n\tif (mmu_kernel_ssize == MMU_SEGSIZE_256M)\n\t\tea_mask = 0xfffff00ULL;\n\telse\n\t\tea_mask = 0xffffffff00ULL;\n\n\tsstp0 |=  vsid >>     (50-14);   \n\tsstp1 |= (vsid << (64-(50-14))) & ~ea_mask;\n\tsstp1 |= (u64)ctx->sstp & ea_mask;\n\tsstp1 |= CXL_SSTP1_An_V;\n\n\tpr_devel(\"Looked up %#llx: slbfee. %#llx (ssize: %x, vsid: %#lx), copied to SSTP0: %#llx, SSTP1: %#llx\\n\",\n\t\t\t(u64)ctx->sstp, (u64)ctx->sstp & ESID_MASK, mmu_kernel_ssize, vsid, sstp0, sstp1);\n\n\t \n\tctx->sstp0 = sstp0;\n\tctx->sstp1 = sstp1;\n\n\treturn 0;\n}\n\n \nvoid cxl_dump_debug_buffer(void *buf, size_t buf_len)\n{\n#ifdef DEBUG\n\tint i, *ptr;\n\n\t \n\tptr = (int *) buf;\n\tfor (i = 0; i * 4 < buf_len; i += 4) {\n\t\tif ((i + 3) * 4 < buf_len)\n\t\t\tpr_devel(\"%.8x %.8x %.8x %.8x\\n\", ptr[i], ptr[i + 1],\n\t\t\t\tptr[i + 2], ptr[i + 3]);\n\t\telse if ((i + 2) * 4 < buf_len)\n\t\t\tpr_devel(\"%.8x %.8x %.8x\\n\", ptr[i], ptr[i + 1],\n\t\t\t\tptr[i + 2]);\n\t\telse if ((i + 1) * 4 < buf_len)\n\t\t\tpr_devel(\"%.8x %.8x\\n\", ptr[i], ptr[i + 1]);\n\t\telse\n\t\t\tpr_devel(\"%.8x\\n\", ptr[i]);\n\t}\n#endif  \n}\n\n \nstruct cxl *get_cxl_adapter(int num)\n{\n\tstruct cxl *adapter;\n\n\tspin_lock(&adapter_idr_lock);\n\tif ((adapter = idr_find(&cxl_adapter_idr, num)))\n\t\tget_device(&adapter->dev);\n\tspin_unlock(&adapter_idr_lock);\n\n\treturn adapter;\n}\n\nstatic int cxl_alloc_adapter_nr(struct cxl *adapter)\n{\n\tint i;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&adapter_idr_lock);\n\ti = idr_alloc(&cxl_adapter_idr, adapter, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&adapter_idr_lock);\n\tidr_preload_end();\n\tif (i < 0)\n\t\treturn i;\n\n\tadapter->adapter_num = i;\n\n\treturn 0;\n}\n\nvoid cxl_remove_adapter_nr(struct cxl *adapter)\n{\n\tidr_remove(&cxl_adapter_idr, adapter->adapter_num);\n}\n\nstruct cxl *cxl_alloc_adapter(void)\n{\n\tstruct cxl *adapter;\n\n\tif (!(adapter = kzalloc(sizeof(struct cxl), GFP_KERNEL)))\n\t\treturn NULL;\n\n\tspin_lock_init(&adapter->afu_list_lock);\n\n\tif (cxl_alloc_adapter_nr(adapter))\n\t\tgoto err1;\n\n\tif (dev_set_name(&adapter->dev, \"card%i\", adapter->adapter_num))\n\t\tgoto err2;\n\n\t \n\tatomic_set(&adapter->contexts_num, -1);\n\n\treturn adapter;\nerr2:\n\tcxl_remove_adapter_nr(adapter);\nerr1:\n\tkfree(adapter);\n\treturn NULL;\n}\n\nstruct cxl_afu *cxl_alloc_afu(struct cxl *adapter, int slice)\n{\n\tstruct cxl_afu *afu;\n\n\tif (!(afu = kzalloc(sizeof(struct cxl_afu), GFP_KERNEL)))\n\t\treturn NULL;\n\n\tafu->adapter = adapter;\n\tafu->dev.parent = &adapter->dev;\n\tafu->dev.release = cxl_ops->release_afu;\n\tafu->slice = slice;\n\tidr_init(&afu->contexts_idr);\n\tmutex_init(&afu->contexts_lock);\n\tspin_lock_init(&afu->afu_cntl_lock);\n\tatomic_set(&afu->configured_state, -1);\n\tafu->prefault_mode = CXL_PREFAULT_NONE;\n\tafu->irqs_max = afu->adapter->user_irqs;\n\n\treturn afu;\n}\n\nint cxl_afu_select_best_mode(struct cxl_afu *afu)\n{\n\tif (afu->modes_supported & CXL_MODE_DIRECTED)\n\t\treturn cxl_ops->afu_activate_mode(afu, CXL_MODE_DIRECTED);\n\n\tif (afu->modes_supported & CXL_MODE_DEDICATED)\n\t\treturn cxl_ops->afu_activate_mode(afu, CXL_MODE_DEDICATED);\n\n\tdev_warn(&afu->dev, \"No supported programming modes available\\n\");\n\t \n\treturn 0;\n}\n\nint cxl_adapter_context_get(struct cxl *adapter)\n{\n\tint rc;\n\n\trc = atomic_inc_unless_negative(&adapter->contexts_num);\n\treturn rc ? 0 : -EBUSY;\n}\n\nvoid cxl_adapter_context_put(struct cxl *adapter)\n{\n\tatomic_dec_if_positive(&adapter->contexts_num);\n}\n\nint cxl_adapter_context_lock(struct cxl *adapter)\n{\n\tint rc;\n\t \n\trc = atomic_cmpxchg(&adapter->contexts_num, 0, -1);\n\treturn rc ? -EBUSY : 0;\n}\n\nvoid cxl_adapter_context_unlock(struct cxl *adapter)\n{\n\tint val = atomic_cmpxchg(&adapter->contexts_num, -1, 0);\n\n\t \n\tif (val != -1) {\n\t\tatomic_set(&adapter->contexts_num, 0);\n\t\tWARN(1, \"Adapter context unlocked with %d active contexts\",\n\t\t     val);\n\t}\n}\n\nstatic int __init init_cxl(void)\n{\n\tint rc = 0;\n\n\tif (!tlbie_capable)\n\t\treturn -EINVAL;\n\n\tif ((rc = cxl_file_init()))\n\t\treturn rc;\n\n\tcxl_debugfs_init();\n\n\t \n\tif (cxl_is_power8()) {\n\t\trc = register_cxl_calls(&cxl_calls);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\tcxl_ops = &cxl_native_ops;\n\t\trc = pci_register_driver(&cxl_pci_driver);\n\t}\n#ifdef CONFIG_PPC_PSERIES\n\telse {\n\t\tcxl_ops = &cxl_guest_ops;\n\t\trc = platform_driver_register(&cxl_of_driver);\n\t}\n#endif\n\tif (rc)\n\t\tgoto err1;\n\n\treturn 0;\nerr1:\n\tif (cxl_is_power8())\n\t\tunregister_cxl_calls(&cxl_calls);\nerr:\n\tcxl_debugfs_exit();\n\tcxl_file_exit();\n\n\treturn rc;\n}\n\nstatic void exit_cxl(void)\n{\n\tif (cpu_has_feature(CPU_FTR_HVMODE))\n\t\tpci_unregister_driver(&cxl_pci_driver);\n#ifdef CONFIG_PPC_PSERIES\n\telse\n\t\tplatform_driver_unregister(&cxl_of_driver);\n#endif\n\n\tcxl_debugfs_exit();\n\tcxl_file_exit();\n\tif (cxl_is_power8())\n\t\tunregister_cxl_calls(&cxl_calls);\n\tidr_destroy(&cxl_adapter_idr);\n}\n\nmodule_init(init_cxl);\nmodule_exit(exit_cxl);\n\nMODULE_DESCRIPTION(\"IBM Coherent Accelerator\");\nMODULE_AUTHOR(\"Ian Munsie <imunsie@au1.ibm.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}