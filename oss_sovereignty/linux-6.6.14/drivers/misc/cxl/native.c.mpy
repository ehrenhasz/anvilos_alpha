{
  "module_name": "native.c",
  "hash_id": "440d728a552330e855999744ba4c695567bae0f447f50864a171155b6d9f1ac9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cxl/native.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/sched/clock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/irqdomain.h>\n#include <asm/synch.h>\n#include <asm/switch_to.h>\n#include <misc/cxl-base.h>\n\n#include \"cxl.h\"\n#include \"trace.h\"\n\nstatic int afu_control(struct cxl_afu *afu, u64 command, u64 clear,\n\t\t       u64 result, u64 mask, bool enabled)\n{\n\tu64 AFU_Cntl;\n\tunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\n\tint rc = 0;\n\n\tspin_lock(&afu->afu_cntl_lock);\n\tpr_devel(\"AFU command starting: %llx\\n\", command);\n\n\ttrace_cxl_afu_ctrl(afu, command);\n\n\tAFU_Cntl = cxl_p2n_read(afu, CXL_AFU_Cntl_An);\n\tcxl_p2n_write(afu, CXL_AFU_Cntl_An, (AFU_Cntl & ~clear) | command);\n\n\tAFU_Cntl = cxl_p2n_read(afu, CXL_AFU_Cntl_An);\n\twhile ((AFU_Cntl & mask) != result) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tdev_warn(&afu->dev, \"WARNING: AFU control timed out!\\n\");\n\t\t\trc = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!cxl_ops->link_ok(afu->adapter, afu)) {\n\t\t\tafu->enabled = enabled;\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpr_devel_ratelimited(\"AFU control... (0x%016llx)\\n\",\n\t\t\t\t     AFU_Cntl | command);\n\t\tcpu_relax();\n\t\tAFU_Cntl = cxl_p2n_read(afu, CXL_AFU_Cntl_An);\n\t}\n\n\tif (AFU_Cntl & CXL_AFU_Cntl_An_RA) {\n\t\t \n\t\tcxl_p2n_write(afu, CXL_AFU_Cntl_An, AFU_Cntl & ~CXL_AFU_Cntl_An_RA);\n\t}\n\n\tpr_devel(\"AFU command complete: %llx\\n\", command);\n\tafu->enabled = enabled;\nout:\n\ttrace_cxl_afu_ctrl_done(afu, command, rc);\n\tspin_unlock(&afu->afu_cntl_lock);\n\n\treturn rc;\n}\n\nstatic int afu_enable(struct cxl_afu *afu)\n{\n\tpr_devel(\"AFU enable request\\n\");\n\n\treturn afu_control(afu, CXL_AFU_Cntl_An_E, 0,\n\t\t\t   CXL_AFU_Cntl_An_ES_Enabled,\n\t\t\t   CXL_AFU_Cntl_An_ES_MASK, true);\n}\n\nint cxl_afu_disable(struct cxl_afu *afu)\n{\n\tpr_devel(\"AFU disable request\\n\");\n\n\treturn afu_control(afu, 0, CXL_AFU_Cntl_An_E,\n\t\t\t   CXL_AFU_Cntl_An_ES_Disabled,\n\t\t\t   CXL_AFU_Cntl_An_ES_MASK, false);\n}\n\n \nstatic int native_afu_reset(struct cxl_afu *afu)\n{\n\tint rc;\n\tu64 serr;\n\n\tpr_devel(\"AFU reset request\\n\");\n\n\trc = afu_control(afu, CXL_AFU_Cntl_An_RA, 0,\n\t\t\t   CXL_AFU_Cntl_An_RS_Complete | CXL_AFU_Cntl_An_ES_Disabled,\n\t\t\t   CXL_AFU_Cntl_An_RS_MASK | CXL_AFU_Cntl_An_ES_MASK,\n\t\t\t   false);\n\n\t \n\tif (afu->current_mode == 0) {\n\t\tserr = cxl_p1n_read(afu, CXL_PSL_SERR_An);\n\t\tserr &= ~CXL_PSL_SERR_An_IRQ_MASKS;\n\t\tcxl_p1n_write(afu, CXL_PSL_SERR_An, serr);\n\t}\n\n\treturn rc;\n}\n\nstatic int native_afu_check_and_enable(struct cxl_afu *afu)\n{\n\tif (!cxl_ops->link_ok(afu->adapter, afu)) {\n\t\tWARN(1, \"Refusing to enable afu while link down!\\n\");\n\t\treturn -EIO;\n\t}\n\tif (afu->enabled)\n\t\treturn 0;\n\treturn afu_enable(afu);\n}\n\nint cxl_psl_purge(struct cxl_afu *afu)\n{\n\tu64 PSL_CNTL = cxl_p1n_read(afu, CXL_PSL_SCNTL_An);\n\tu64 AFU_Cntl = cxl_p2n_read(afu, CXL_AFU_Cntl_An);\n\tu64 dsisr, dar;\n\tu64 start, end;\n\tu64 trans_fault = 0x0ULL;\n\tunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\n\tint rc = 0;\n\n\ttrace_cxl_psl_ctrl(afu, CXL_PSL_SCNTL_An_Pc);\n\n\tpr_devel(\"PSL purge request\\n\");\n\n\tif (cxl_is_power8())\n\t\ttrans_fault = CXL_PSL_DSISR_TRANS;\n\tif (cxl_is_power9())\n\t\ttrans_fault = CXL_PSL9_DSISR_An_TF;\n\n\tif (!cxl_ops->link_ok(afu->adapter, afu)) {\n\t\tdev_warn(&afu->dev, \"PSL Purge called with link down, ignoring\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\tif ((AFU_Cntl & CXL_AFU_Cntl_An_ES_MASK) != CXL_AFU_Cntl_An_ES_Disabled) {\n\t\tWARN(1, \"psl_purge request while AFU not disabled!\\n\");\n\t\tcxl_afu_disable(afu);\n\t}\n\n\tcxl_p1n_write(afu, CXL_PSL_SCNTL_An,\n\t\t       PSL_CNTL | CXL_PSL_SCNTL_An_Pc);\n\tstart = local_clock();\n\tPSL_CNTL = cxl_p1n_read(afu, CXL_PSL_SCNTL_An);\n\twhile ((PSL_CNTL &  CXL_PSL_SCNTL_An_Ps_MASK)\n\t\t\t== CXL_PSL_SCNTL_An_Ps_Pending) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tdev_warn(&afu->dev, \"WARNING: PSL Purge timed out!\\n\");\n\t\t\trc = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!cxl_ops->link_ok(afu->adapter, afu)) {\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdsisr = cxl_p2n_read(afu, CXL_PSL_DSISR_An);\n\t\tpr_devel_ratelimited(\"PSL purging... PSL_CNTL: 0x%016llx  PSL_DSISR: 0x%016llx\\n\",\n\t\t\t\t     PSL_CNTL, dsisr);\n\n\t\tif (dsisr & trans_fault) {\n\t\t\tdar = cxl_p2n_read(afu, CXL_PSL_DAR_An);\n\t\t\tdev_notice(&afu->dev, \"PSL purge terminating pending translation, DSISR: 0x%016llx, DAR: 0x%016llx\\n\",\n\t\t\t\t   dsisr, dar);\n\t\t\tcxl_p2n_write(afu, CXL_PSL_TFC_An, CXL_PSL_TFC_An_AE);\n\t\t} else if (dsisr) {\n\t\t\tdev_notice(&afu->dev, \"PSL purge acknowledging pending non-translation fault, DSISR: 0x%016llx\\n\",\n\t\t\t\t   dsisr);\n\t\t\tcxl_p2n_write(afu, CXL_PSL_TFC_An, CXL_PSL_TFC_An_A);\n\t\t} else {\n\t\t\tcpu_relax();\n\t\t}\n\t\tPSL_CNTL = cxl_p1n_read(afu, CXL_PSL_SCNTL_An);\n\t}\n\tend = local_clock();\n\tpr_devel(\"PSL purged in %lld ns\\n\", end - start);\n\n\tcxl_p1n_write(afu, CXL_PSL_SCNTL_An,\n\t\t       PSL_CNTL & ~CXL_PSL_SCNTL_An_Pc);\nout:\n\ttrace_cxl_psl_ctrl_done(afu, CXL_PSL_SCNTL_An_Pc, rc);\n\treturn rc;\n}\n\nstatic int spa_max_procs(int spa_size)\n{\n\t \n\treturn ((spa_size / 8) - 96) / 17;\n}\n\nstatic int cxl_alloc_spa(struct cxl_afu *afu, int mode)\n{\n\tunsigned spa_size;\n\n\t \n\tafu->native->spa_order = -1;\n\tdo {\n\t\tafu->native->spa_order++;\n\t\tspa_size = (1 << afu->native->spa_order) * PAGE_SIZE;\n\n\t\tif (spa_size > 0x100000) {\n\t\t\tdev_warn(&afu->dev, \"num_of_processes too large for the SPA, limiting to %i (0x%x)\\n\",\n\t\t\t\t\tafu->native->spa_max_procs, afu->native->spa_size);\n\t\t\tif (mode != CXL_MODE_DEDICATED)\n\t\t\t\tafu->num_procs = afu->native->spa_max_procs;\n\t\t\tbreak;\n\t\t}\n\n\t\tafu->native->spa_size = spa_size;\n\t\tafu->native->spa_max_procs = spa_max_procs(afu->native->spa_size);\n\t} while (afu->native->spa_max_procs < afu->num_procs);\n\n\tif (!(afu->native->spa = (struct cxl_process_element *)\n\t      __get_free_pages(GFP_KERNEL | __GFP_ZERO, afu->native->spa_order))) {\n\t\tpr_err(\"cxl_alloc_spa: Unable to allocate scheduled process area\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpr_devel(\"spa pages: %i afu->spa_max_procs: %i   afu->num_procs: %i\\n\",\n\t\t 1<<afu->native->spa_order, afu->native->spa_max_procs, afu->num_procs);\n\n\treturn 0;\n}\n\nstatic void attach_spa(struct cxl_afu *afu)\n{\n\tu64 spap;\n\n\tafu->native->sw_command_status = (__be64 *)((char *)afu->native->spa +\n\t\t\t\t\t    ((afu->native->spa_max_procs + 3) * 128));\n\n\tspap = virt_to_phys(afu->native->spa) & CXL_PSL_SPAP_Addr;\n\tspap |= ((afu->native->spa_size >> (12 - CXL_PSL_SPAP_Size_Shift)) - 1) & CXL_PSL_SPAP_Size;\n\tspap |= CXL_PSL_SPAP_V;\n\tpr_devel(\"cxl: SPA allocated at 0x%p. Max processes: %i, sw_command_status: 0x%p CXL_PSL_SPAP_An=0x%016llx\\n\",\n\t\tafu->native->spa, afu->native->spa_max_procs,\n\t\tafu->native->sw_command_status, spap);\n\tcxl_p1n_write(afu, CXL_PSL_SPAP_An, spap);\n}\n\nvoid cxl_release_spa(struct cxl_afu *afu)\n{\n\tif (afu->native->spa) {\n\t\tfree_pages((unsigned long) afu->native->spa,\n\t\t\tafu->native->spa_order);\n\t\tafu->native->spa = NULL;\n\t}\n}\n\n \nint cxl_invalidate_all_psl9(struct cxl *adapter)\n{\n\tunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\n\tu64 ierat;\n\n\tpr_devel(\"CXL adapter - invalidation of all ERAT entries\\n\");\n\n\t \n\tierat = CXL_XSL9_IERAT_IALL;\n\tif (radix_enabled())\n\t\tierat |= CXL_XSL9_IERAT_INVR;\n\tcxl_p1_write(adapter, CXL_XSL9_IERAT, ierat);\n\n\twhile (cxl_p1_read(adapter, CXL_XSL9_IERAT) & CXL_XSL9_IERAT_IINPROG) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tdev_warn(&adapter->dev,\n\t\t\t\"WARNING: CXL adapter invalidation of all ERAT entries timed out!\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (!cxl_ops->link_ok(adapter, NULL))\n\t\t\treturn -EIO;\n\t\tcpu_relax();\n\t}\n\treturn 0;\n}\n\nint cxl_invalidate_all_psl8(struct cxl *adapter)\n{\n\tunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\n\n\tpr_devel(\"CXL adapter wide TLBIA & SLBIA\\n\");\n\n\tcxl_p1_write(adapter, CXL_PSL_AFUSEL, CXL_PSL_AFUSEL_A);\n\n\tcxl_p1_write(adapter, CXL_PSL_TLBIA, CXL_TLB_SLB_IQ_ALL);\n\twhile (cxl_p1_read(adapter, CXL_PSL_TLBIA) & CXL_TLB_SLB_P) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tdev_warn(&adapter->dev, \"WARNING: CXL adapter wide TLBIA timed out!\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (!cxl_ops->link_ok(adapter, NULL))\n\t\t\treturn -EIO;\n\t\tcpu_relax();\n\t}\n\n\tcxl_p1_write(adapter, CXL_PSL_SLBIA, CXL_TLB_SLB_IQ_ALL);\n\twhile (cxl_p1_read(adapter, CXL_PSL_SLBIA) & CXL_TLB_SLB_P) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tdev_warn(&adapter->dev, \"WARNING: CXL adapter wide SLBIA timed out!\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (!cxl_ops->link_ok(adapter, NULL))\n\t\t\treturn -EIO;\n\t\tcpu_relax();\n\t}\n\treturn 0;\n}\n\nint cxl_data_cache_flush(struct cxl *adapter)\n{\n\tu64 reg;\n\tunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\n\n\t \n\tif (adapter->native->no_data_cache) {\n\t\tpr_devel(\"No PSL data cache. Ignoring cache flush req.\\n\");\n\t\treturn 0;\n\t}\n\n\tpr_devel(\"Flushing data cache\\n\");\n\treg = cxl_p1_read(adapter, CXL_PSL_Control);\n\treg |= CXL_PSL_Control_Fr;\n\tcxl_p1_write(adapter, CXL_PSL_Control, reg);\n\n\treg = cxl_p1_read(adapter, CXL_PSL_Control);\n\twhile ((reg & CXL_PSL_Control_Fs_MASK) != CXL_PSL_Control_Fs_Complete) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tdev_warn(&adapter->dev, \"WARNING: cache flush timed out!\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (!cxl_ops->link_ok(adapter, NULL)) {\n\t\t\tdev_warn(&adapter->dev, \"WARNING: link down when flushing cache\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tcpu_relax();\n\t\treg = cxl_p1_read(adapter, CXL_PSL_Control);\n\t}\n\n\treg &= ~CXL_PSL_Control_Fr;\n\tcxl_p1_write(adapter, CXL_PSL_Control, reg);\n\treturn 0;\n}\n\nstatic int cxl_write_sstp(struct cxl_afu *afu, u64 sstp0, u64 sstp1)\n{\n\tint rc;\n\n\t \n\tcxl_p2n_write(afu, CXL_SSTP1_An, 0);\n\n\t \n\tif ((rc = cxl_afu_slbia(afu)))\n\t\treturn rc;\n\n\t \n\tcxl_p2n_write(afu, CXL_SSTP0_An, sstp0);\n\n\t \n\tcxl_p2n_write(afu, CXL_SSTP1_An, sstp1);\n\n\treturn 0;\n}\n\n \nstatic void slb_invalid(struct cxl_context *ctx)\n{\n\tstruct cxl *adapter = ctx->afu->adapter;\n\tu64 slbia;\n\n\tWARN_ON(!mutex_is_locked(&ctx->afu->native->spa_mutex));\n\n\tcxl_p1_write(adapter, CXL_PSL_LBISEL,\n\t\t\t((u64)be32_to_cpu(ctx->elem->common.pid) << 32) |\n\t\t\tbe32_to_cpu(ctx->elem->lpid));\n\tcxl_p1_write(adapter, CXL_PSL_SLBIA, CXL_TLB_SLB_IQ_LPIDPID);\n\n\twhile (1) {\n\t\tif (!cxl_ops->link_ok(adapter, NULL))\n\t\t\tbreak;\n\t\tslbia = cxl_p1_read(adapter, CXL_PSL_SLBIA);\n\t\tif (!(slbia & CXL_TLB_SLB_P))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n}\n\nstatic int do_process_element_cmd(struct cxl_context *ctx,\n\t\t\t\t  u64 cmd, u64 pe_state)\n{\n\tu64 state;\n\tunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\n\tint rc = 0;\n\n\ttrace_cxl_llcmd(ctx, cmd);\n\n\tWARN_ON(!ctx->afu->enabled);\n\n\tctx->elem->software_state = cpu_to_be32(pe_state);\n\tsmp_wmb();\n\t*(ctx->afu->native->sw_command_status) = cpu_to_be64(cmd | 0 | ctx->pe);\n\tsmp_mb();\n\tcxl_p1n_write(ctx->afu, CXL_PSL_LLCMD_An, cmd | ctx->pe);\n\twhile (1) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tdev_warn(&ctx->afu->dev, \"WARNING: Process Element Command timed out!\\n\");\n\t\t\trc = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!cxl_ops->link_ok(ctx->afu->adapter, ctx->afu)) {\n\t\t\tdev_warn(&ctx->afu->dev, \"WARNING: Device link down, aborting Process Element Command!\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tstate = be64_to_cpup(ctx->afu->native->sw_command_status);\n\t\tif (state == ~0ULL) {\n\t\t\tpr_err(\"cxl: Error adding process element to AFU\\n\");\n\t\t\trc = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((state & (CXL_SPA_SW_CMD_MASK | CXL_SPA_SW_STATE_MASK  | CXL_SPA_SW_LINK_MASK)) ==\n\t\t    (cmd | (cmd >> 16) | ctx->pe))\n\t\t\tbreak;\n\t\t \n\t\tschedule();\n\n\t}\nout:\n\ttrace_cxl_llcmd_done(ctx, cmd, rc);\n\treturn rc;\n}\n\nstatic int add_process_element(struct cxl_context *ctx)\n{\n\tint rc = 0;\n\n\tmutex_lock(&ctx->afu->native->spa_mutex);\n\tpr_devel(\"%s Adding pe: %i started\\n\", __func__, ctx->pe);\n\tif (!(rc = do_process_element_cmd(ctx, CXL_SPA_SW_CMD_ADD, CXL_PE_SOFTWARE_STATE_V)))\n\t\tctx->pe_inserted = true;\n\tpr_devel(\"%s Adding pe: %i finished\\n\", __func__, ctx->pe);\n\tmutex_unlock(&ctx->afu->native->spa_mutex);\n\treturn rc;\n}\n\nstatic int terminate_process_element(struct cxl_context *ctx)\n{\n\tint rc = 0;\n\n\t \n\tif (!(ctx->elem->software_state & cpu_to_be32(CXL_PE_SOFTWARE_STATE_V)))\n\t\treturn rc;\n\n\tmutex_lock(&ctx->afu->native->spa_mutex);\n\tpr_devel(\"%s Terminate pe: %i started\\n\", __func__, ctx->pe);\n\t \n\tif (cxl_ops->link_ok(ctx->afu->adapter, ctx->afu))\n\t\trc = do_process_element_cmd(ctx, CXL_SPA_SW_CMD_TERMINATE,\n\t\t\t\t\t    CXL_PE_SOFTWARE_STATE_V | CXL_PE_SOFTWARE_STATE_T);\n\tctx->elem->software_state = 0;\t \n\tpr_devel(\"%s Terminate pe: %i finished\\n\", __func__, ctx->pe);\n\tmutex_unlock(&ctx->afu->native->spa_mutex);\n\treturn rc;\n}\n\nstatic int remove_process_element(struct cxl_context *ctx)\n{\n\tint rc = 0;\n\n\tmutex_lock(&ctx->afu->native->spa_mutex);\n\tpr_devel(\"%s Remove pe: %i started\\n\", __func__, ctx->pe);\n\n\t \n\tif (cxl_ops->link_ok(ctx->afu->adapter, ctx->afu))\n\t\trc = do_process_element_cmd(ctx, CXL_SPA_SW_CMD_REMOVE, 0);\n\n\tif (!rc)\n\t\tctx->pe_inserted = false;\n\tif (cxl_is_power8())\n\t\tslb_invalid(ctx);\n\tpr_devel(\"%s Remove pe: %i finished\\n\", __func__, ctx->pe);\n\tmutex_unlock(&ctx->afu->native->spa_mutex);\n\n\treturn rc;\n}\n\nvoid cxl_assign_psn_space(struct cxl_context *ctx)\n{\n\tif (!ctx->afu->pp_size || ctx->master) {\n\t\tctx->psn_phys = ctx->afu->psn_phys;\n\t\tctx->psn_size = ctx->afu->adapter->ps_size;\n\t} else {\n\t\tctx->psn_phys = ctx->afu->psn_phys +\n\t\t\t(ctx->afu->native->pp_offset + ctx->afu->pp_size * ctx->pe);\n\t\tctx->psn_size = ctx->afu->pp_size;\n\t}\n}\n\nstatic int activate_afu_directed(struct cxl_afu *afu)\n{\n\tint rc;\n\n\tdev_info(&afu->dev, \"Activating AFU directed mode\\n\");\n\n\tafu->num_procs = afu->max_procs_virtualised;\n\tif (afu->native->spa == NULL) {\n\t\tif (cxl_alloc_spa(afu, CXL_MODE_DIRECTED))\n\t\t\treturn -ENOMEM;\n\t}\n\tattach_spa(afu);\n\n\tcxl_p1n_write(afu, CXL_PSL_SCNTL_An, CXL_PSL_SCNTL_An_PM_AFU);\n\tif (cxl_is_power8())\n\t\tcxl_p1n_write(afu, CXL_PSL_AMOR_An, 0xFFFFFFFFFFFFFFFFULL);\n\tcxl_p1n_write(afu, CXL_PSL_ID_An, CXL_PSL_ID_An_F | CXL_PSL_ID_An_L);\n\n\tafu->current_mode = CXL_MODE_DIRECTED;\n\n\tif ((rc = cxl_chardev_m_afu_add(afu)))\n\t\treturn rc;\n\n\tif ((rc = cxl_sysfs_afu_m_add(afu)))\n\t\tgoto err;\n\n\tif ((rc = cxl_chardev_s_afu_add(afu)))\n\t\tgoto err1;\n\n\treturn 0;\nerr1:\n\tcxl_sysfs_afu_m_remove(afu);\nerr:\n\tcxl_chardev_afu_remove(afu);\n\treturn rc;\n}\n\n#ifdef CONFIG_CPU_LITTLE_ENDIAN\n#define set_endian(sr) ((sr) |= CXL_PSL_SR_An_LE)\n#else\n#define set_endian(sr) ((sr) &= ~(CXL_PSL_SR_An_LE))\n#endif\n\nu64 cxl_calculate_sr(bool master, bool kernel, bool real_mode, bool p9)\n{\n\tu64 sr = 0;\n\n\tset_endian(sr);\n\tif (master)\n\t\tsr |= CXL_PSL_SR_An_MP;\n\tif (mfspr(SPRN_LPCR) & LPCR_TC)\n\t\tsr |= CXL_PSL_SR_An_TC;\n\n\tif (kernel) {\n\t\tif (!real_mode)\n\t\t\tsr |= CXL_PSL_SR_An_R;\n\t\tsr |= (mfmsr() & MSR_SF) | CXL_PSL_SR_An_HV;\n\t} else {\n\t\tsr |= CXL_PSL_SR_An_PR | CXL_PSL_SR_An_R;\n\t\tif (radix_enabled())\n\t\t\tsr |= CXL_PSL_SR_An_HV;\n\t\telse\n\t\t\tsr &= ~(CXL_PSL_SR_An_HV);\n\t\tif (!test_tsk_thread_flag(current, TIF_32BIT))\n\t\t\tsr |= CXL_PSL_SR_An_SF;\n\t}\n\tif (p9) {\n\t\tif (radix_enabled())\n\t\t\tsr |= CXL_PSL_SR_An_XLAT_ror;\n\t\telse\n\t\t\tsr |= CXL_PSL_SR_An_XLAT_hpt;\n\t}\n\treturn sr;\n}\n\nstatic u64 calculate_sr(struct cxl_context *ctx)\n{\n\treturn cxl_calculate_sr(ctx->master, ctx->kernel, false,\n\t\t\t\tcxl_is_power9());\n}\n\nstatic void update_ivtes_directed(struct cxl_context *ctx)\n{\n\tbool need_update = (ctx->status == STARTED);\n\tint r;\n\n\tif (need_update) {\n\t\tWARN_ON(terminate_process_element(ctx));\n\t\tWARN_ON(remove_process_element(ctx));\n\t}\n\n\tfor (r = 0; r < CXL_IRQ_RANGES; r++) {\n\t\tctx->elem->ivte_offsets[r] = cpu_to_be16(ctx->irqs.offset[r]);\n\t\tctx->elem->ivte_ranges[r] = cpu_to_be16(ctx->irqs.range[r]);\n\t}\n\n\t \n\tif (need_update)\n\t\tWARN_ON(add_process_element(ctx));\n}\n\nstatic int process_element_entry_psl9(struct cxl_context *ctx, u64 wed, u64 amr)\n{\n\tu32 pid;\n\tint rc;\n\n\tcxl_assign_psn_space(ctx);\n\n\tctx->elem->ctxtime = 0;  \n\tctx->elem->lpid = cpu_to_be32(mfspr(SPRN_LPID));\n\tctx->elem->haurp = 0;  \n\n\tif (ctx->kernel)\n\t\tpid = 0;\n\telse {\n\t\tif (ctx->mm == NULL) {\n\t\t\tpr_devel(\"%s: unable to get mm for pe=%d pid=%i\\n\",\n\t\t\t\t__func__, ctx->pe, pid_nr(ctx->pid));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpid = ctx->mm->context.id;\n\t}\n\n\t \n\tif (!(ctx->tidr) && (ctx->assign_tidr)) {\n\t\trc = set_thread_tidr(current);\n\t\tif (rc)\n\t\t\treturn -ENODEV;\n\t\tctx->tidr = current->thread.tidr;\n\t\tpr_devel(\"%s: current tidr: %d\\n\", __func__, ctx->tidr);\n\t}\n\n\tctx->elem->common.tid = cpu_to_be32(ctx->tidr);\n\tctx->elem->common.pid = cpu_to_be32(pid);\n\n\tctx->elem->sr = cpu_to_be64(calculate_sr(ctx));\n\n\tctx->elem->common.csrp = 0;  \n\n\tcxl_prefault(ctx, wed);\n\n\t \n\tif (ctx->irqs.range[0] == 0) {\n\t\tctx->irqs.offset[0] = ctx->afu->native->psl_hwirq;\n\t\tctx->irqs.range[0] = 1;\n\t}\n\n\tctx->elem->common.amr = cpu_to_be64(amr);\n\tctx->elem->common.wed = cpu_to_be64(wed);\n\n\treturn 0;\n}\n\nint cxl_attach_afu_directed_psl9(struct cxl_context *ctx, u64 wed, u64 amr)\n{\n\tint result;\n\n\t \n\tresult = process_element_entry_psl9(ctx, wed, amr);\n\tif (result)\n\t\treturn result;\n\n\tupdate_ivtes_directed(ctx);\n\n\t \n\tresult = cxl_ops->afu_check_and_enable(ctx->afu);\n\tif (result)\n\t\treturn result;\n\n\treturn add_process_element(ctx);\n}\n\nint cxl_attach_afu_directed_psl8(struct cxl_context *ctx, u64 wed, u64 amr)\n{\n\tu32 pid;\n\tint result;\n\n\tcxl_assign_psn_space(ctx);\n\n\tctx->elem->ctxtime = 0;  \n\tctx->elem->lpid = cpu_to_be32(mfspr(SPRN_LPID));\n\tctx->elem->haurp = 0;  \n\tctx->elem->u.sdr = cpu_to_be64(mfspr(SPRN_SDR1));\n\n\tpid = current->pid;\n\tif (ctx->kernel)\n\t\tpid = 0;\n\tctx->elem->common.tid = 0;\n\tctx->elem->common.pid = cpu_to_be32(pid);\n\n\tctx->elem->sr = cpu_to_be64(calculate_sr(ctx));\n\n\tctx->elem->common.csrp = 0;  \n\tctx->elem->common.u.psl8.aurp0 = 0;  \n\tctx->elem->common.u.psl8.aurp1 = 0;  \n\n\tcxl_prefault(ctx, wed);\n\n\tctx->elem->common.u.psl8.sstp0 = cpu_to_be64(ctx->sstp0);\n\tctx->elem->common.u.psl8.sstp1 = cpu_to_be64(ctx->sstp1);\n\n\t \n\tif (ctx->irqs.range[0] == 0) {\n\t\tctx->irqs.offset[0] = ctx->afu->native->psl_hwirq;\n\t\tctx->irqs.range[0] = 1;\n\t}\n\n\tupdate_ivtes_directed(ctx);\n\n\tctx->elem->common.amr = cpu_to_be64(amr);\n\tctx->elem->common.wed = cpu_to_be64(wed);\n\n\t \n\tif ((result = cxl_ops->afu_check_and_enable(ctx->afu)))\n\t\treturn result;\n\n\treturn add_process_element(ctx);\n}\n\nstatic int deactivate_afu_directed(struct cxl_afu *afu)\n{\n\tdev_info(&afu->dev, \"Deactivating AFU directed mode\\n\");\n\n\tafu->current_mode = 0;\n\tafu->num_procs = 0;\n\n\tcxl_sysfs_afu_m_remove(afu);\n\tcxl_chardev_afu_remove(afu);\n\n\t \n\tif (afu->adapter->native->sl_ops->needs_reset_before_disable)\n\t\tcxl_ops->afu_reset(afu);\n\tcxl_afu_disable(afu);\n\tcxl_psl_purge(afu);\n\n\treturn 0;\n}\n\nint cxl_activate_dedicated_process_psl9(struct cxl_afu *afu)\n{\n\tdev_info(&afu->dev, \"Activating dedicated process mode\\n\");\n\n\t \n\tafu->num_procs = 1;\n\tif (afu->native->spa == NULL) {\n\t\tif (cxl_alloc_spa(afu, CXL_MODE_DEDICATED))\n\t\t\treturn -ENOMEM;\n\t}\n\tattach_spa(afu);\n\n\tcxl_p1n_write(afu, CXL_PSL_SCNTL_An, CXL_PSL_SCNTL_An_PM_Process);\n\tcxl_p1n_write(afu, CXL_PSL_ID_An, CXL_PSL_ID_An_F | CXL_PSL_ID_An_L);\n\n\tafu->current_mode = CXL_MODE_DEDICATED;\n\n\treturn cxl_chardev_d_afu_add(afu);\n}\n\nint cxl_activate_dedicated_process_psl8(struct cxl_afu *afu)\n{\n\tdev_info(&afu->dev, \"Activating dedicated process mode\\n\");\n\n\tcxl_p1n_write(afu, CXL_PSL_SCNTL_An, CXL_PSL_SCNTL_An_PM_Process);\n\n\tcxl_p1n_write(afu, CXL_PSL_CtxTime_An, 0);  \n\tcxl_p1n_write(afu, CXL_PSL_SPAP_An, 0);     \n\tcxl_p1n_write(afu, CXL_PSL_AMOR_An, 0xFFFFFFFFFFFFFFFFULL);\n\tcxl_p1n_write(afu, CXL_PSL_LPID_An, mfspr(SPRN_LPID));\n\tcxl_p1n_write(afu, CXL_HAURP_An, 0);        \n\tcxl_p1n_write(afu, CXL_PSL_SDR_An, mfspr(SPRN_SDR1));\n\n\tcxl_p2n_write(afu, CXL_CSRP_An, 0);         \n\tcxl_p2n_write(afu, CXL_AURP0_An, 0);        \n\tcxl_p2n_write(afu, CXL_AURP1_An, 0);        \n\n\tafu->current_mode = CXL_MODE_DEDICATED;\n\tafu->num_procs = 1;\n\n\treturn cxl_chardev_d_afu_add(afu);\n}\n\nvoid cxl_update_dedicated_ivtes_psl9(struct cxl_context *ctx)\n{\n\tint r;\n\n\tfor (r = 0; r < CXL_IRQ_RANGES; r++) {\n\t\tctx->elem->ivte_offsets[r] = cpu_to_be16(ctx->irqs.offset[r]);\n\t\tctx->elem->ivte_ranges[r] = cpu_to_be16(ctx->irqs.range[r]);\n\t}\n}\n\nvoid cxl_update_dedicated_ivtes_psl8(struct cxl_context *ctx)\n{\n\tstruct cxl_afu *afu = ctx->afu;\n\n\tcxl_p1n_write(afu, CXL_PSL_IVTE_Offset_An,\n\t\t       (((u64)ctx->irqs.offset[0] & 0xffff) << 48) |\n\t\t       (((u64)ctx->irqs.offset[1] & 0xffff) << 32) |\n\t\t       (((u64)ctx->irqs.offset[2] & 0xffff) << 16) |\n\t\t\t((u64)ctx->irqs.offset[3] & 0xffff));\n\tcxl_p1n_write(afu, CXL_PSL_IVTE_Limit_An, (u64)\n\t\t       (((u64)ctx->irqs.range[0] & 0xffff) << 48) |\n\t\t       (((u64)ctx->irqs.range[1] & 0xffff) << 32) |\n\t\t       (((u64)ctx->irqs.range[2] & 0xffff) << 16) |\n\t\t\t((u64)ctx->irqs.range[3] & 0xffff));\n}\n\nint cxl_attach_dedicated_process_psl9(struct cxl_context *ctx, u64 wed, u64 amr)\n{\n\tstruct cxl_afu *afu = ctx->afu;\n\tint result;\n\n\t \n\tresult = process_element_entry_psl9(ctx, wed, amr);\n\tif (result)\n\t\treturn result;\n\n\tif (ctx->afu->adapter->native->sl_ops->update_dedicated_ivtes)\n\t\tafu->adapter->native->sl_ops->update_dedicated_ivtes(ctx);\n\n\tctx->elem->software_state = cpu_to_be32(CXL_PE_SOFTWARE_STATE_V);\n\t \n\n\tresult = cxl_ops->afu_reset(afu);\n\tif (result)\n\t\treturn result;\n\n\treturn afu_enable(afu);\n}\n\nint cxl_attach_dedicated_process_psl8(struct cxl_context *ctx, u64 wed, u64 amr)\n{\n\tstruct cxl_afu *afu = ctx->afu;\n\tu64 pid;\n\tint rc;\n\n\tpid = (u64)current->pid << 32;\n\tif (ctx->kernel)\n\t\tpid = 0;\n\tcxl_p2n_write(afu, CXL_PSL_PID_TID_An, pid);\n\n\tcxl_p1n_write(afu, CXL_PSL_SR_An, calculate_sr(ctx));\n\n\tif ((rc = cxl_write_sstp(afu, ctx->sstp0, ctx->sstp1)))\n\t\treturn rc;\n\n\tcxl_prefault(ctx, wed);\n\n\tif (ctx->afu->adapter->native->sl_ops->update_dedicated_ivtes)\n\t\tafu->adapter->native->sl_ops->update_dedicated_ivtes(ctx);\n\n\tcxl_p2n_write(afu, CXL_PSL_AMR_An, amr);\n\n\t \n\tcxl_assign_psn_space(ctx);\n\n\tif ((rc = cxl_ops->afu_reset(afu)))\n\t\treturn rc;\n\n\tcxl_p2n_write(afu, CXL_PSL_WED_An, wed);\n\n\treturn afu_enable(afu);\n}\n\nstatic int deactivate_dedicated_process(struct cxl_afu *afu)\n{\n\tdev_info(&afu->dev, \"Deactivating dedicated process mode\\n\");\n\n\tafu->current_mode = 0;\n\tafu->num_procs = 0;\n\n\tcxl_chardev_afu_remove(afu);\n\n\treturn 0;\n}\n\nstatic int native_afu_deactivate_mode(struct cxl_afu *afu, int mode)\n{\n\tif (mode == CXL_MODE_DIRECTED)\n\t\treturn deactivate_afu_directed(afu);\n\tif (mode == CXL_MODE_DEDICATED)\n\t\treturn deactivate_dedicated_process(afu);\n\treturn 0;\n}\n\nstatic int native_afu_activate_mode(struct cxl_afu *afu, int mode)\n{\n\tif (!mode)\n\t\treturn 0;\n\tif (!(mode & afu->modes_supported))\n\t\treturn -EINVAL;\n\n\tif (!cxl_ops->link_ok(afu->adapter, afu)) {\n\t\tWARN(1, \"Device link is down, refusing to activate!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (mode == CXL_MODE_DIRECTED)\n\t\treturn activate_afu_directed(afu);\n\tif ((mode == CXL_MODE_DEDICATED) &&\n\t    (afu->adapter->native->sl_ops->activate_dedicated_process))\n\t\treturn afu->adapter->native->sl_ops->activate_dedicated_process(afu);\n\n\treturn -EINVAL;\n}\n\nstatic int native_attach_process(struct cxl_context *ctx, bool kernel,\n\t\t\t\tu64 wed, u64 amr)\n{\n\tif (!cxl_ops->link_ok(ctx->afu->adapter, ctx->afu)) {\n\t\tWARN(1, \"Device link is down, refusing to attach process!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tctx->kernel = kernel;\n\tif ((ctx->afu->current_mode == CXL_MODE_DIRECTED) &&\n\t    (ctx->afu->adapter->native->sl_ops->attach_afu_directed))\n\t\treturn ctx->afu->adapter->native->sl_ops->attach_afu_directed(ctx, wed, amr);\n\n\tif ((ctx->afu->current_mode == CXL_MODE_DEDICATED) &&\n\t    (ctx->afu->adapter->native->sl_ops->attach_dedicated_process))\n\t\treturn ctx->afu->adapter->native->sl_ops->attach_dedicated_process(ctx, wed, amr);\n\n\treturn -EINVAL;\n}\n\nstatic inline int detach_process_native_dedicated(struct cxl_context *ctx)\n{\n\t \n\tcxl_ops->afu_reset(ctx->afu);\n\tcxl_afu_disable(ctx->afu);\n\tcxl_psl_purge(ctx->afu);\n\treturn 0;\n}\n\nstatic void native_update_ivtes(struct cxl_context *ctx)\n{\n\tif (ctx->afu->current_mode == CXL_MODE_DIRECTED)\n\t\treturn update_ivtes_directed(ctx);\n\tif ((ctx->afu->current_mode == CXL_MODE_DEDICATED) &&\n\t    (ctx->afu->adapter->native->sl_ops->update_dedicated_ivtes))\n\t\treturn ctx->afu->adapter->native->sl_ops->update_dedicated_ivtes(ctx);\n\tWARN(1, \"native_update_ivtes: Bad mode\\n\");\n}\n\nstatic inline int detach_process_native_afu_directed(struct cxl_context *ctx)\n{\n\tif (!ctx->pe_inserted)\n\t\treturn 0;\n\tif (terminate_process_element(ctx))\n\t\treturn -1;\n\tif (remove_process_element(ctx))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int native_detach_process(struct cxl_context *ctx)\n{\n\ttrace_cxl_detach(ctx);\n\n\tif (ctx->afu->current_mode == CXL_MODE_DEDICATED)\n\t\treturn detach_process_native_dedicated(ctx);\n\n\treturn detach_process_native_afu_directed(ctx);\n}\n\nstatic int native_get_irq_info(struct cxl_afu *afu, struct cxl_irq_info *info)\n{\n\t \n\tif (!cxl_ops->link_ok(afu->adapter, afu))\n\t\treturn -EIO;\n\n\tinfo->dsisr = cxl_p2n_read(afu, CXL_PSL_DSISR_An);\n\tinfo->dar = cxl_p2n_read(afu, CXL_PSL_DAR_An);\n\tif (cxl_is_power8())\n\t\tinfo->dsr = cxl_p2n_read(afu, CXL_PSL_DSR_An);\n\tinfo->afu_err = cxl_p2n_read(afu, CXL_AFU_ERR_An);\n\tinfo->errstat = cxl_p2n_read(afu, CXL_PSL_ErrStat_An);\n\tinfo->proc_handle = 0;\n\n\treturn 0;\n}\n\nvoid cxl_native_irq_dump_regs_psl9(struct cxl_context *ctx)\n{\n\tu64 fir1, serr;\n\n\tfir1 = cxl_p1_read(ctx->afu->adapter, CXL_PSL9_FIR1);\n\n\tdev_crit(&ctx->afu->dev, \"PSL_FIR1: 0x%016llx\\n\", fir1);\n\tif (ctx->afu->adapter->native->sl_ops->register_serr_irq) {\n\t\tserr = cxl_p1n_read(ctx->afu, CXL_PSL_SERR_An);\n\t\tcxl_afu_decode_psl_serr(ctx->afu, serr);\n\t}\n}\n\nvoid cxl_native_irq_dump_regs_psl8(struct cxl_context *ctx)\n{\n\tu64 fir1, fir2, fir_slice, serr, afu_debug;\n\n\tfir1 = cxl_p1_read(ctx->afu->adapter, CXL_PSL_FIR1);\n\tfir2 = cxl_p1_read(ctx->afu->adapter, CXL_PSL_FIR2);\n\tfir_slice = cxl_p1n_read(ctx->afu, CXL_PSL_FIR_SLICE_An);\n\tafu_debug = cxl_p1n_read(ctx->afu, CXL_AFU_DEBUG_An);\n\n\tdev_crit(&ctx->afu->dev, \"PSL_FIR1: 0x%016llx\\n\", fir1);\n\tdev_crit(&ctx->afu->dev, \"PSL_FIR2: 0x%016llx\\n\", fir2);\n\tif (ctx->afu->adapter->native->sl_ops->register_serr_irq) {\n\t\tserr = cxl_p1n_read(ctx->afu, CXL_PSL_SERR_An);\n\t\tcxl_afu_decode_psl_serr(ctx->afu, serr);\n\t}\n\tdev_crit(&ctx->afu->dev, \"PSL_FIR_SLICE_An: 0x%016llx\\n\", fir_slice);\n\tdev_crit(&ctx->afu->dev, \"CXL_PSL_AFU_DEBUG_An: 0x%016llx\\n\", afu_debug);\n}\n\nstatic irqreturn_t native_handle_psl_slice_error(struct cxl_context *ctx,\n\t\t\t\t\t\tu64 dsisr, u64 errstat)\n{\n\n\tdev_crit(&ctx->afu->dev, \"PSL ERROR STATUS: 0x%016llx\\n\", errstat);\n\n\tif (ctx->afu->adapter->native->sl_ops->psl_irq_dump_registers)\n\t\tctx->afu->adapter->native->sl_ops->psl_irq_dump_registers(ctx);\n\n\tif (ctx->afu->adapter->native->sl_ops->debugfs_stop_trace) {\n\t\tdev_crit(&ctx->afu->dev, \"STOPPING CXL TRACE\\n\");\n\t\tctx->afu->adapter->native->sl_ops->debugfs_stop_trace(ctx->afu->adapter);\n\t}\n\n\treturn cxl_ops->ack_irq(ctx, 0, errstat);\n}\n\nstatic bool cxl_is_translation_fault(struct cxl_afu *afu, u64 dsisr)\n{\n\tif ((cxl_is_power8()) && (dsisr & CXL_PSL_DSISR_TRANS))\n\t\treturn true;\n\n\tif ((cxl_is_power9()) && (dsisr & CXL_PSL9_DSISR_An_TF))\n\t\treturn true;\n\n\treturn false;\n}\n\nirqreturn_t cxl_fail_irq_psl(struct cxl_afu *afu, struct cxl_irq_info *irq_info)\n{\n\tif (cxl_is_translation_fault(afu, irq_info->dsisr))\n\t\tcxl_p2n_write(afu, CXL_PSL_TFC_An, CXL_PSL_TFC_An_AE);\n\telse\n\t\tcxl_p2n_write(afu, CXL_PSL_TFC_An, CXL_PSL_TFC_An_A);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t native_irq_multiplexed(int irq, void *data)\n{\n\tstruct cxl_afu *afu = data;\n\tstruct cxl_context *ctx;\n\tstruct cxl_irq_info irq_info;\n\tu64 phreg = cxl_p2n_read(afu, CXL_PSL_PEHandle_An);\n\tint ph, ret = IRQ_HANDLED, res;\n\n\t \n\tif (unlikely(phreg == ~0ULL)) {\n\t\tdev_warn(&afu->dev,\n\t\t\t \"Ignoring slice interrupt(%d) due to fenced card\",\n\t\t\t irq);\n\t\treturn IRQ_HANDLED;\n\t}\n\t \n\tph = phreg & 0xffff;\n\tif ((res = native_get_irq_info(afu, &irq_info))) {\n\t\tWARN(1, \"Unable to get CXL IRQ Info: %i\\n\", res);\n\t\tif (afu->adapter->native->sl_ops->fail_irq)\n\t\t\treturn afu->adapter->native->sl_ops->fail_irq(afu, &irq_info);\n\t\treturn ret;\n\t}\n\n\trcu_read_lock();\n\tctx = idr_find(&afu->contexts_idr, ph);\n\tif (ctx) {\n\t\tif (afu->adapter->native->sl_ops->handle_interrupt)\n\t\t\tret = afu->adapter->native->sl_ops->handle_interrupt(irq, ctx, &irq_info);\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\trcu_read_unlock();\n\n\tWARN(1, \"Unable to demultiplex CXL PSL IRQ for PE %i DSISR %016llx DAR\"\n\t\t\" %016llx\\n(Possible AFU HW issue - was a term/remove acked\"\n\t\t\" with outstanding transactions?)\\n\", ph, irq_info.dsisr,\n\t\tirq_info.dar);\n\tif (afu->adapter->native->sl_ops->fail_irq)\n\t\tret = afu->adapter->native->sl_ops->fail_irq(afu, &irq_info);\n\treturn ret;\n}\n\nstatic void native_irq_wait(struct cxl_context *ctx)\n{\n\tu64 dsisr;\n\tint timeout = 1000;\n\tint ph;\n\n\t \n\twhile (timeout--) {\n\t\tph = cxl_p2n_read(ctx->afu, CXL_PSL_PEHandle_An) & 0xffff;\n\t\tif (ph != ctx->pe)\n\t\t\treturn;\n\t\tdsisr = cxl_p2n_read(ctx->afu, CXL_PSL_DSISR_An);\n\t\tif (cxl_is_power8() &&\n\t\t   ((dsisr & CXL_PSL_DSISR_PENDING) == 0))\n\t\t\treturn;\n\t\tif (cxl_is_power9() &&\n\t\t   ((dsisr & CXL_PSL9_DSISR_PENDING) == 0))\n\t\t\treturn;\n\t\t \n\t\tmsleep(1);\n\t}\n\n\tdev_warn(&ctx->afu->dev, \"WARNING: waiting on DSI for PE %i\"\n\t\t \" DSISR %016llx!\\n\", ph, dsisr);\n\treturn;\n}\n\nstatic irqreturn_t native_slice_irq_err(int irq, void *data)\n{\n\tstruct cxl_afu *afu = data;\n\tu64 errstat, serr, afu_error, dsisr;\n\tu64 fir_slice, afu_debug, irq_mask;\n\n\t \n\tserr = cxl_p1n_read(afu, CXL_PSL_SERR_An);\n\terrstat = cxl_p2n_read(afu, CXL_PSL_ErrStat_An);\n\tafu_error = cxl_p2n_read(afu, CXL_AFU_ERR_An);\n\tdsisr = cxl_p2n_read(afu, CXL_PSL_DSISR_An);\n\tcxl_afu_decode_psl_serr(afu, serr);\n\n\tif (cxl_is_power8()) {\n\t\tfir_slice = cxl_p1n_read(afu, CXL_PSL_FIR_SLICE_An);\n\t\tafu_debug = cxl_p1n_read(afu, CXL_AFU_DEBUG_An);\n\t\tdev_crit(&afu->dev, \"PSL_FIR_SLICE_An: 0x%016llx\\n\", fir_slice);\n\t\tdev_crit(&afu->dev, \"CXL_PSL_AFU_DEBUG_An: 0x%016llx\\n\", afu_debug);\n\t}\n\tdev_crit(&afu->dev, \"CXL_PSL_ErrStat_An: 0x%016llx\\n\", errstat);\n\tdev_crit(&afu->dev, \"AFU_ERR_An: 0x%.16llx\\n\", afu_error);\n\tdev_crit(&afu->dev, \"PSL_DSISR_An: 0x%.16llx\\n\", dsisr);\n\n\t \n\tirq_mask = (serr & CXL_PSL_SERR_An_IRQS) >> 32;\n\tserr |= irq_mask;\n\tcxl_p1n_write(afu, CXL_PSL_SERR_An, serr);\n\tdev_info(&afu->dev, \"Further such interrupts will be masked until the AFU is reset\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nvoid cxl_native_err_irq_dump_regs_psl9(struct cxl *adapter)\n{\n\tu64 fir1;\n\n\tfir1 = cxl_p1_read(adapter, CXL_PSL9_FIR1);\n\tdev_crit(&adapter->dev, \"PSL_FIR: 0x%016llx\\n\", fir1);\n}\n\nvoid cxl_native_err_irq_dump_regs_psl8(struct cxl *adapter)\n{\n\tu64 fir1, fir2;\n\n\tfir1 = cxl_p1_read(adapter, CXL_PSL_FIR1);\n\tfir2 = cxl_p1_read(adapter, CXL_PSL_FIR2);\n\tdev_crit(&adapter->dev,\n\t\t \"PSL_FIR1: 0x%016llx\\nPSL_FIR2: 0x%016llx\\n\",\n\t\t fir1, fir2);\n}\n\nstatic irqreturn_t native_irq_err(int irq, void *data)\n{\n\tstruct cxl *adapter = data;\n\tu64 err_ivte;\n\n\tWARN(1, \"CXL ERROR interrupt %i\\n\", irq);\n\n\terr_ivte = cxl_p1_read(adapter, CXL_PSL_ErrIVTE);\n\tdev_crit(&adapter->dev, \"PSL_ErrIVTE: 0x%016llx\\n\", err_ivte);\n\n\tif (adapter->native->sl_ops->debugfs_stop_trace) {\n\t\tdev_crit(&adapter->dev, \"STOPPING CXL TRACE\\n\");\n\t\tadapter->native->sl_ops->debugfs_stop_trace(adapter);\n\t}\n\n\tif (adapter->native->sl_ops->err_irq_dump_registers)\n\t\tadapter->native->sl_ops->err_irq_dump_registers(adapter);\n\n\treturn IRQ_HANDLED;\n}\n\nint cxl_native_register_psl_err_irq(struct cxl *adapter)\n{\n\tint rc;\n\n\tadapter->irq_name = kasprintf(GFP_KERNEL, \"cxl-%s-err\",\n\t\t\t\t      dev_name(&adapter->dev));\n\tif (!adapter->irq_name)\n\t\treturn -ENOMEM;\n\n\tif ((rc = cxl_register_one_irq(adapter, native_irq_err, adapter,\n\t\t\t\t       &adapter->native->err_hwirq,\n\t\t\t\t       &adapter->native->err_virq,\n\t\t\t\t       adapter->irq_name))) {\n\t\tkfree(adapter->irq_name);\n\t\tadapter->irq_name = NULL;\n\t\treturn rc;\n\t}\n\n\tcxl_p1_write(adapter, CXL_PSL_ErrIVTE, adapter->native->err_hwirq & 0xffff);\n\n\treturn 0;\n}\n\nvoid cxl_native_release_psl_err_irq(struct cxl *adapter)\n{\n\tif (adapter->native->err_virq == 0 ||\n\t    adapter->native->err_virq !=\n\t    irq_find_mapping(NULL, adapter->native->err_hwirq))\n\t\treturn;\n\n\tcxl_p1_write(adapter, CXL_PSL_ErrIVTE, 0x0000000000000000);\n\tcxl_unmap_irq(adapter->native->err_virq, adapter);\n\tcxl_ops->release_one_irq(adapter, adapter->native->err_hwirq);\n\tkfree(adapter->irq_name);\n\tadapter->native->err_virq = 0;\n}\n\nint cxl_native_register_serr_irq(struct cxl_afu *afu)\n{\n\tu64 serr;\n\tint rc;\n\n\tafu->err_irq_name = kasprintf(GFP_KERNEL, \"cxl-%s-err\",\n\t\t\t\t      dev_name(&afu->dev));\n\tif (!afu->err_irq_name)\n\t\treturn -ENOMEM;\n\n\tif ((rc = cxl_register_one_irq(afu->adapter, native_slice_irq_err, afu,\n\t\t\t\t       &afu->serr_hwirq,\n\t\t\t\t       &afu->serr_virq, afu->err_irq_name))) {\n\t\tkfree(afu->err_irq_name);\n\t\tafu->err_irq_name = NULL;\n\t\treturn rc;\n\t}\n\n\tserr = cxl_p1n_read(afu, CXL_PSL_SERR_An);\n\tif (cxl_is_power8())\n\t\tserr = (serr & 0x00ffffffffff0000ULL) | (afu->serr_hwirq & 0xffff);\n\tif (cxl_is_power9()) {\n\t\t \n\t\tserr = (serr & ~0xff0000007fffffffULL) | (afu->serr_hwirq & 0xffff);\n\t}\n\tcxl_p1n_write(afu, CXL_PSL_SERR_An, serr);\n\n\treturn 0;\n}\n\nvoid cxl_native_release_serr_irq(struct cxl_afu *afu)\n{\n\tif (afu->serr_virq == 0 ||\n\t    afu->serr_virq != irq_find_mapping(NULL, afu->serr_hwirq))\n\t\treturn;\n\n\tcxl_p1n_write(afu, CXL_PSL_SERR_An, 0x0000000000000000);\n\tcxl_unmap_irq(afu->serr_virq, afu);\n\tcxl_ops->release_one_irq(afu->adapter, afu->serr_hwirq);\n\tkfree(afu->err_irq_name);\n\tafu->serr_virq = 0;\n}\n\nint cxl_native_register_psl_irq(struct cxl_afu *afu)\n{\n\tint rc;\n\n\tafu->psl_irq_name = kasprintf(GFP_KERNEL, \"cxl-%s\",\n\t\t\t\t      dev_name(&afu->dev));\n\tif (!afu->psl_irq_name)\n\t\treturn -ENOMEM;\n\n\tif ((rc = cxl_register_one_irq(afu->adapter, native_irq_multiplexed,\n\t\t\t\t    afu, &afu->native->psl_hwirq, &afu->native->psl_virq,\n\t\t\t\t    afu->psl_irq_name))) {\n\t\tkfree(afu->psl_irq_name);\n\t\tafu->psl_irq_name = NULL;\n\t}\n\treturn rc;\n}\n\nvoid cxl_native_release_psl_irq(struct cxl_afu *afu)\n{\n\tif (afu->native->psl_virq == 0 ||\n\t    afu->native->psl_virq !=\n\t    irq_find_mapping(NULL, afu->native->psl_hwirq))\n\t\treturn;\n\n\tcxl_unmap_irq(afu->native->psl_virq, afu);\n\tcxl_ops->release_one_irq(afu->adapter, afu->native->psl_hwirq);\n\tkfree(afu->psl_irq_name);\n\tafu->native->psl_virq = 0;\n}\n\nstatic void recover_psl_err(struct cxl_afu *afu, u64 errstat)\n{\n\tu64 dsisr;\n\n\tpr_devel(\"RECOVERING FROM PSL ERROR... (0x%016llx)\\n\", errstat);\n\n\t \n\tdsisr = cxl_p2n_read(afu, CXL_PSL_DSISR_An);\n\tcxl_p2n_write(afu, CXL_PSL_DSISR_An, dsisr & ~CXL_PSL_DSISR_An_PE);\n\n\t \n\tcxl_p2n_write(afu, CXL_PSL_ErrStat_An, errstat);\n}\n\nstatic int native_ack_irq(struct cxl_context *ctx, u64 tfc, u64 psl_reset_mask)\n{\n\ttrace_cxl_psl_irq_ack(ctx, tfc);\n\tif (tfc)\n\t\tcxl_p2n_write(ctx->afu, CXL_PSL_TFC_An, tfc);\n\tif (psl_reset_mask)\n\t\trecover_psl_err(ctx->afu, psl_reset_mask);\n\n\treturn 0;\n}\n\nint cxl_check_error(struct cxl_afu *afu)\n{\n\treturn (cxl_p1n_read(afu, CXL_PSL_SCNTL_An) == ~0ULL);\n}\n\nstatic bool native_support_attributes(const char *attr_name,\n\t\t\t\t      enum cxl_attrs type)\n{\n\treturn true;\n}\n\nstatic int native_afu_cr_read64(struct cxl_afu *afu, int cr, u64 off, u64 *out)\n{\n\tif (unlikely(!cxl_ops->link_ok(afu->adapter, afu)))\n\t\treturn -EIO;\n\tif (unlikely(off >= afu->crs_len))\n\t\treturn -ERANGE;\n\t*out = in_le64(afu->native->afu_desc_mmio + afu->crs_offset +\n\t\t(cr * afu->crs_len) + off);\n\treturn 0;\n}\n\nstatic int native_afu_cr_read32(struct cxl_afu *afu, int cr, u64 off, u32 *out)\n{\n\tif (unlikely(!cxl_ops->link_ok(afu->adapter, afu)))\n\t\treturn -EIO;\n\tif (unlikely(off >= afu->crs_len))\n\t\treturn -ERANGE;\n\t*out = in_le32(afu->native->afu_desc_mmio + afu->crs_offset +\n\t\t(cr * afu->crs_len) + off);\n\treturn 0;\n}\n\nstatic int native_afu_cr_read16(struct cxl_afu *afu, int cr, u64 off, u16 *out)\n{\n\tu64 aligned_off = off & ~0x3L;\n\tu32 val;\n\tint rc;\n\n\trc = native_afu_cr_read32(afu, cr, aligned_off, &val);\n\tif (!rc)\n\t\t*out = (val >> ((off & 0x3) * 8)) & 0xffff;\n\treturn rc;\n}\n\nstatic int native_afu_cr_read8(struct cxl_afu *afu, int cr, u64 off, u8 *out)\n{\n\tu64 aligned_off = off & ~0x3L;\n\tu32 val;\n\tint rc;\n\n\trc = native_afu_cr_read32(afu, cr, aligned_off, &val);\n\tif (!rc)\n\t\t*out = (val >> ((off & 0x3) * 8)) & 0xff;\n\treturn rc;\n}\n\nstatic int native_afu_cr_write32(struct cxl_afu *afu, int cr, u64 off, u32 in)\n{\n\tif (unlikely(!cxl_ops->link_ok(afu->adapter, afu)))\n\t\treturn -EIO;\n\tif (unlikely(off >= afu->crs_len))\n\t\treturn -ERANGE;\n\tout_le32(afu->native->afu_desc_mmio + afu->crs_offset +\n\t\t(cr * afu->crs_len) + off, in);\n\treturn 0;\n}\n\nstatic int native_afu_cr_write16(struct cxl_afu *afu, int cr, u64 off, u16 in)\n{\n\tu64 aligned_off = off & ~0x3L;\n\tu32 val32, mask, shift;\n\tint rc;\n\n\trc = native_afu_cr_read32(afu, cr, aligned_off, &val32);\n\tif (rc)\n\t\treturn rc;\n\tshift = (off & 0x3) * 8;\n\tWARN_ON(shift == 24);\n\tmask = 0xffff << shift;\n\tval32 = (val32 & ~mask) | (in << shift);\n\n\trc = native_afu_cr_write32(afu, cr, aligned_off, val32);\n\treturn rc;\n}\n\nstatic int native_afu_cr_write8(struct cxl_afu *afu, int cr, u64 off, u8 in)\n{\n\tu64 aligned_off = off & ~0x3L;\n\tu32 val32, mask, shift;\n\tint rc;\n\n\trc = native_afu_cr_read32(afu, cr, aligned_off, &val32);\n\tif (rc)\n\t\treturn rc;\n\tshift = (off & 0x3) * 8;\n\tmask = 0xff << shift;\n\tval32 = (val32 & ~mask) | (in << shift);\n\n\trc = native_afu_cr_write32(afu, cr, aligned_off, val32);\n\treturn rc;\n}\n\nconst struct cxl_backend_ops cxl_native_ops = {\n\t.module = THIS_MODULE,\n\t.adapter_reset = cxl_pci_reset,\n\t.alloc_one_irq = cxl_pci_alloc_one_irq,\n\t.release_one_irq = cxl_pci_release_one_irq,\n\t.alloc_irq_ranges = cxl_pci_alloc_irq_ranges,\n\t.release_irq_ranges = cxl_pci_release_irq_ranges,\n\t.setup_irq = cxl_pci_setup_irq,\n\t.handle_psl_slice_error = native_handle_psl_slice_error,\n\t.psl_interrupt = NULL,\n\t.ack_irq = native_ack_irq,\n\t.irq_wait = native_irq_wait,\n\t.attach_process = native_attach_process,\n\t.detach_process = native_detach_process,\n\t.update_ivtes = native_update_ivtes,\n\t.support_attributes = native_support_attributes,\n\t.link_ok = cxl_adapter_link_ok,\n\t.release_afu = cxl_pci_release_afu,\n\t.afu_read_err_buffer = cxl_pci_afu_read_err_buffer,\n\t.afu_check_and_enable = native_afu_check_and_enable,\n\t.afu_activate_mode = native_afu_activate_mode,\n\t.afu_deactivate_mode = native_afu_deactivate_mode,\n\t.afu_reset = native_afu_reset,\n\t.afu_cr_read8 = native_afu_cr_read8,\n\t.afu_cr_read16 = native_afu_cr_read16,\n\t.afu_cr_read32 = native_afu_cr_read32,\n\t.afu_cr_read64 = native_afu_cr_read64,\n\t.afu_cr_write8 = native_afu_cr_write8,\n\t.afu_cr_write16 = native_afu_cr_write16,\n\t.afu_cr_write32 = native_afu_cr_write32,\n\t.read_adapter_vpd = cxl_pci_read_adapter_vpd,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}