{
  "module_name": "cxllib.c",
  "hash_id": "97149117949a292046c41836a9c111c01efe5af4656a92edeaea11e696e1ec51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cxl/cxllib.c",
  "human_readable_source": "\n \n\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <asm/opal-api.h>\n#include <asm/pnv-pci.h>\n#include <misc/cxllib.h>\n\n#include \"cxl.h\"\n\n#define CXL_INVALID_DRA                 ~0ull\n#define CXL_DUMMY_READ_SIZE             128\n#define CXL_DUMMY_READ_ALIGN            8\n#define CXL_CAPI_WINDOW_START           0x2000000000000ull\n#define CXL_CAPI_WINDOW_LOG_SIZE        48\n#define CXL_XSL_CONFIG_CURRENT_VERSION  CXL_XSL_CONFIG_VERSION1\n\n\nbool cxllib_slot_is_supported(struct pci_dev *dev, unsigned long flags)\n{\n\tint rc;\n\tu32 phb_index;\n\tu64 chip_id, capp_unit_id;\n\n\t \n\tif (flags)\n\t\treturn false;\n\n\tif (!cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn false;\n\n\tif (!cxl_is_power9())\n\t\treturn false;\n\n\tif (cxl_slot_is_switched(dev))\n\t\treturn false;\n\n\t \n\trc = cxl_calc_capp_routing(dev, &chip_id, &phb_index, &capp_unit_id);\n\tif (rc)\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(cxllib_slot_is_supported);\n\nstatic DEFINE_MUTEX(dra_mutex);\nstatic u64 dummy_read_addr = CXL_INVALID_DRA;\n\nstatic int allocate_dummy_read_buf(void)\n{\n\tu64 buf, vaddr;\n\tsize_t buf_size;\n\n\t \n\tbuf_size = CXL_DUMMY_READ_SIZE + (1ull << CXL_DUMMY_READ_ALIGN);\n\tbuf = (u64) kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tvaddr = (buf + (1ull << CXL_DUMMY_READ_ALIGN) - 1) &\n\t\t\t\t\t(~0ull << CXL_DUMMY_READ_ALIGN);\n\n\tWARN((vaddr + CXL_DUMMY_READ_SIZE) > (buf + buf_size),\n\t\t\"Dummy read buffer alignment issue\");\n\tdummy_read_addr = virt_to_phys((void *) vaddr);\n\treturn 0;\n}\n\nint cxllib_get_xsl_config(struct pci_dev *dev, struct cxllib_xsl_config *cfg)\n{\n\tint rc;\n\tu32 phb_index;\n\tu64 chip_id, capp_unit_id;\n\n\tif (!cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dra_mutex);\n\tif (dummy_read_addr == CXL_INVALID_DRA) {\n\t\trc = allocate_dummy_read_buf();\n\t\tif (rc) {\n\t\t\tmutex_unlock(&dra_mutex);\n\t\t\treturn rc;\n\t\t}\n\t}\n\tmutex_unlock(&dra_mutex);\n\n\trc = cxl_calc_capp_routing(dev, &chip_id, &phb_index, &capp_unit_id);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cxl_get_xsl9_dsnctl(dev, capp_unit_id, &cfg->dsnctl);\n\tif (rc)\n\t\treturn rc;\n\n\tcfg->version  = CXL_XSL_CONFIG_CURRENT_VERSION;\n\tcfg->log_bar_size = CXL_CAPI_WINDOW_LOG_SIZE;\n\tcfg->bar_addr = CXL_CAPI_WINDOW_START;\n\tcfg->dra = dummy_read_addr;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cxllib_get_xsl_config);\n\nint cxllib_switch_phb_mode(struct pci_dev *dev, enum cxllib_mode mode,\n\t\t\tunsigned long flags)\n{\n\tint rc = 0;\n\n\tif (!cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn -EINVAL;\n\n\tswitch (mode) {\n\tcase CXL_MODE_PCI:\n\t\t \n\t\trc = pnv_phb_to_cxl_mode(dev, OPAL_PHB_CAPI_MODE_SNOOP_OFF);\n\t\tif (rc)\n\t\t\trc = -EBUSY;\n\t\telse\n\t\t\trc = -EPERM;\n\t\tbreak;\n\tcase CXL_MODE_CXL:\n\t\t \n\t\tif (flags != CXL_MODE_DMA_TVT1)\n\t\t\treturn -EINVAL;\n\t\trc = pnv_phb_to_cxl_mode(dev, OPAL_PHB_CAPI_MODE_DMA_TVT1);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = pnv_phb_to_cxl_mode(dev, OPAL_PHB_CAPI_MODE_SNOOP_ON);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(cxllib_switch_phb_mode);\n\n \nint cxllib_set_device_dma(struct pci_dev *dev, unsigned long flags)\n{\n\tint rc;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\trc = dma_set_mask(&dev->dev, DMA_BIT_MASK(64));\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(cxllib_set_device_dma);\n\nint cxllib_get_PE_attributes(struct task_struct *task,\n\t\t\t     unsigned long translation_mode,\n\t\t\t     struct cxllib_pe_attributes *attr)\n{\n\tif (translation_mode != CXL_TRANSLATED_MODE &&\n\t\ttranslation_mode != CXL_REAL_MODE)\n\t\treturn -EINVAL;\n\n\tattr->sr = cxl_calculate_sr(false,\n\t\t\t\ttask == NULL,\n\t\t\t\ttranslation_mode == CXL_REAL_MODE,\n\t\t\t\ttrue);\n\tattr->lpid = mfspr(SPRN_LPID);\n\tif (task) {\n\t\tstruct mm_struct *mm = get_task_mm(task);\n\t\tif (mm == NULL)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tattr->pid = mm->context.id;\n\t\tmmput(mm);\n\t\tattr->tid = task->thread.tidr;\n\t} else {\n\t\tattr->pid = 0;\n\t\tattr->tid = 0;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cxllib_get_PE_attributes);\n\nstatic int get_vma_info(struct mm_struct *mm, u64 addr,\n\t\t\tu64 *vma_start, u64 *vma_end,\n\t\t\tunsigned long *page_size)\n{\n\tstruct vm_area_struct *vma = NULL;\n\tint rc = 0;\n\n\tmmap_read_lock(mm);\n\n\tvma = find_vma(mm, addr);\n\tif (!vma) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\t*page_size = vma_kernel_pagesize(vma);\n\t*vma_start = vma->vm_start;\n\t*vma_end = vma->vm_end;\nout:\n\tmmap_read_unlock(mm);\n\treturn rc;\n}\n\nint cxllib_handle_fault(struct mm_struct *mm, u64 addr, u64 size, u64 flags)\n{\n\tint rc;\n\tu64 dar, vma_start, vma_end;\n\tunsigned long page_size;\n\n\tif (mm == NULL)\n\t\treturn -EFAULT;\n\n\t \n\trc = get_vma_info(mm, addr, &vma_start, &vma_end, &page_size);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (dar = (addr & ~(page_size - 1)); dar < (addr + size);\n\t     dar += page_size) {\n\t\tif (dar < vma_start || dar >= vma_end) {\n\t\t\t \n\t\t\trc = get_vma_info(mm, dar, &vma_start, &vma_end,\n\t\t\t\t\t&page_size);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\trc = cxl_handle_mm_fault(mm, flags, dar);\n\t\tif (rc)\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cxllib_handle_fault);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}