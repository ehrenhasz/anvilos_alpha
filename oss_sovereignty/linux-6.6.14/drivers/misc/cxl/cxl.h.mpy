{
  "module_name": "cxl.h",
  "hash_id": "987b617ee2fa17f49d351a6fcb17266710a89f4993a670c2c23792401b969fa9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cxl/cxl.h",
  "human_readable_source": " \n \n\n#ifndef _CXL_H_\n#define _CXL_H_\n\n#include <linux/interrupt.h>\n#include <linux/semaphore.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/cdev.h>\n#include <linux/pid.h>\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/fs.h>\n#include <asm/cputable.h>\n#include <asm/mmu.h>\n#include <asm/reg.h>\n#include <misc/cxl-base.h>\n\n#include <misc/cxl.h>\n#include <uapi/misc/cxl.h>\n\nextern uint cxl_verbose;\n\nstruct property;\n\n#define CXL_TIMEOUT 5\n\n \n#define CXL_API_VERSION 3\n#define CXL_API_VERSION_COMPATIBLE 1\n\n \ntypedef struct {\n\tconst int x;\n} cxl_p1_reg_t;\ntypedef struct {\n\tconst int x;\n} cxl_p1n_reg_t;\ntypedef struct {\n\tconst int x;\n} cxl_p2n_reg_t;\n#define cxl_reg_off(reg) \\\n\t(reg.x)\n\n \n\n \n \nstatic const cxl_p1_reg_t CXL_PSL_CtxTime = {0x0000};\nstatic const cxl_p1_reg_t CXL_PSL_ErrIVTE = {0x0008};\nstatic const cxl_p1_reg_t CXL_PSL_KEY1    = {0x0010};\nstatic const cxl_p1_reg_t CXL_PSL_KEY2    = {0x0018};\nstatic const cxl_p1_reg_t CXL_PSL_Control = {0x0020};\n \nstatic const cxl_p1_reg_t CXL_PSL_DLCNTL  = {0x0060};\nstatic const cxl_p1_reg_t CXL_PSL_DLADDR  = {0x0068};\n\n \nstatic const cxl_p1_reg_t CXL_PSL_LBISEL  = {0x0080};\nstatic const cxl_p1_reg_t CXL_PSL_SLBIE   = {0x0088};\nstatic const cxl_p1_reg_t CXL_PSL_SLBIA   = {0x0090};\nstatic const cxl_p1_reg_t CXL_PSL_TLBIE   = {0x00A0};\nstatic const cxl_p1_reg_t CXL_PSL_TLBIA   = {0x00A8};\nstatic const cxl_p1_reg_t CXL_PSL_AFUSEL  = {0x00B0};\n\n \n \nstatic const cxl_p1_reg_t CXL_PSL_FIR1      = {0x0100};\nstatic const cxl_p1_reg_t CXL_PSL_FIR2      = {0x0108};\nstatic const cxl_p1_reg_t CXL_PSL_Timebase  = {0x0110};\nstatic const cxl_p1_reg_t CXL_PSL_VERSION   = {0x0118};\nstatic const cxl_p1_reg_t CXL_PSL_RESLCKTO  = {0x0128};\nstatic const cxl_p1_reg_t CXL_PSL_TB_CTLSTAT = {0x0140};\nstatic const cxl_p1_reg_t CXL_PSL_FIR_CNTL  = {0x0148};\nstatic const cxl_p1_reg_t CXL_PSL_DSNDCTL   = {0x0150};\nstatic const cxl_p1_reg_t CXL_PSL_SNWRALLOC = {0x0158};\nstatic const cxl_p1_reg_t CXL_PSL_TRACE     = {0x0170};\n \nstatic const cxl_p1_reg_t CXL_PSL9_CONTROL  = {0x0020};\nstatic const cxl_p1_reg_t CXL_XSL9_INV      = {0x0110};\nstatic const cxl_p1_reg_t CXL_XSL9_DBG      = {0x0130};\nstatic const cxl_p1_reg_t CXL_XSL9_DEF      = {0x0140};\nstatic const cxl_p1_reg_t CXL_XSL9_DSNCTL   = {0x0168};\nstatic const cxl_p1_reg_t CXL_PSL9_FIR1     = {0x0300};\nstatic const cxl_p1_reg_t CXL_PSL9_FIR_MASK = {0x0308};\nstatic const cxl_p1_reg_t CXL_PSL9_Timebase = {0x0310};\nstatic const cxl_p1_reg_t CXL_PSL9_DEBUG    = {0x0320};\nstatic const cxl_p1_reg_t CXL_PSL9_FIR_CNTL = {0x0348};\nstatic const cxl_p1_reg_t CXL_PSL9_DSNDCTL  = {0x0350};\nstatic const cxl_p1_reg_t CXL_PSL9_TB_CTLSTAT = {0x0340};\nstatic const cxl_p1_reg_t CXL_PSL9_TRACECFG = {0x0368};\nstatic const cxl_p1_reg_t CXL_PSL9_APCDEDALLOC = {0x0378};\nstatic const cxl_p1_reg_t CXL_PSL9_APCDEDTYPE = {0x0380};\nstatic const cxl_p1_reg_t CXL_PSL9_TNR_ADDR = {0x0388};\nstatic const cxl_p1_reg_t CXL_PSL9_CTCCFG = {0x0390};\nstatic const cxl_p1_reg_t CXL_PSL9_GP_CT = {0x0398};\nstatic const cxl_p1_reg_t CXL_XSL9_IERAT = {0x0588};\nstatic const cxl_p1_reg_t CXL_XSL9_ILPP  = {0x0590};\n\n \n \n\n \n \nstatic const cxl_p1n_reg_t CXL_PSL_SR_An          = {0x00};\nstatic const cxl_p1n_reg_t CXL_PSL_LPID_An        = {0x08};\nstatic const cxl_p1n_reg_t CXL_PSL_AMBAR_An       = {0x10};\nstatic const cxl_p1n_reg_t CXL_PSL_SPOffset_An    = {0x18};\nstatic const cxl_p1n_reg_t CXL_PSL_ID_An          = {0x20};\nstatic const cxl_p1n_reg_t CXL_PSL_SERR_An        = {0x28};\n \nstatic const cxl_p1n_reg_t CXL_PSL_SDR_An         = {0x30};\n \nstatic const cxl_p1n_reg_t CXL_PSL_AMOR_An        = {0x38};\n \nstatic const cxl_p1n_reg_t CXL_HAURP_An           = {0x80};\nstatic const cxl_p1n_reg_t CXL_PSL_SPAP_An        = {0x88};\nstatic const cxl_p1n_reg_t CXL_PSL_LLCMD_An       = {0x90};\n \nstatic const cxl_p1n_reg_t CXL_PSL_SCNTL_An       = {0xA0};\nstatic const cxl_p1n_reg_t CXL_PSL_CtxTime_An     = {0xA8};\nstatic const cxl_p1n_reg_t CXL_PSL_IVTE_Offset_An = {0xB0};\nstatic const cxl_p1n_reg_t CXL_PSL_IVTE_Limit_An  = {0xB8};\n \nstatic const cxl_p1n_reg_t CXL_PSL_FIR_SLICE_An   = {0xC0};\nstatic const cxl_p1n_reg_t CXL_AFU_DEBUG_An       = {0xC8};\n \nstatic const cxl_p1n_reg_t CXL_PSL_APCALLOC_A     = {0xD0};\nstatic const cxl_p1n_reg_t CXL_PSL_COALLOC_A      = {0xD8};\nstatic const cxl_p1n_reg_t CXL_PSL_RXCTL_A        = {0xE0};\nstatic const cxl_p1n_reg_t CXL_PSL_SLICE_TRACE    = {0xE8};\n\n \n \nstatic const cxl_p2n_reg_t CXL_PSL_PID_TID_An = {0x000};\nstatic const cxl_p2n_reg_t CXL_CSRP_An        = {0x008};\n \nstatic const cxl_p2n_reg_t CXL_AURP0_An       = {0x010};\nstatic const cxl_p2n_reg_t CXL_AURP1_An       = {0x018};\nstatic const cxl_p2n_reg_t CXL_SSTP0_An       = {0x020};\nstatic const cxl_p2n_reg_t CXL_SSTP1_An       = {0x028};\n \nstatic const cxl_p2n_reg_t CXL_PSL_AMR_An     = {0x030};\n \nstatic const cxl_p2n_reg_t CXL_SLBIE_An       = {0x040};\nstatic const cxl_p2n_reg_t CXL_SLBIA_An       = {0x048};\nstatic const cxl_p2n_reg_t CXL_SLBI_Select_An = {0x050};\n \nstatic const cxl_p2n_reg_t CXL_PSL_DSISR_An   = {0x060};\nstatic const cxl_p2n_reg_t CXL_PSL_DAR_An     = {0x068};\nstatic const cxl_p2n_reg_t CXL_PSL_DSR_An     = {0x070};\nstatic const cxl_p2n_reg_t CXL_PSL_TFC_An     = {0x078};\nstatic const cxl_p2n_reg_t CXL_PSL_PEHandle_An = {0x080};\nstatic const cxl_p2n_reg_t CXL_PSL_ErrStat_An = {0x088};\n \nstatic const cxl_p2n_reg_t CXL_AFU_Cntl_An    = {0x090};\nstatic const cxl_p2n_reg_t CXL_AFU_ERR_An     = {0x098};\n \nstatic const cxl_p2n_reg_t CXL_PSL_WED_An     = {0x0A0};\n \n\n#define CXL_PSL_SPAP_Addr 0x0ffffffffffff000ULL\n#define CXL_PSL_SPAP_Size 0x0000000000000ff0ULL\n#define CXL_PSL_SPAP_Size_Shift 4\n#define CXL_PSL_SPAP_V    0x0000000000000001ULL\n\n \n#define CXL_PSL_Control_tb              (0x1ull << (63-63))\n#define CXL_PSL_Control_Fr              (0x1ull << (63-31))\n#define CXL_PSL_Control_Fs_MASK         (0x3ull << (63-29))\n#define CXL_PSL_Control_Fs_Complete     (0x3ull << (63-29))\n\n \n#define CXL_PSL_DLCNTL_D (0x1ull << (63-28))\n#define CXL_PSL_DLCNTL_C (0x1ull << (63-29))\n#define CXL_PSL_DLCNTL_E (0x1ull << (63-30))\n#define CXL_PSL_DLCNTL_S (0x1ull << (63-31))\n#define CXL_PSL_DLCNTL_CE (CXL_PSL_DLCNTL_C | CXL_PSL_DLCNTL_E)\n#define CXL_PSL_DLCNTL_DCES (CXL_PSL_DLCNTL_D | CXL_PSL_DLCNTL_CE | CXL_PSL_DLCNTL_S)\n\n \n#define CXL_PSL_SR_An_SF  MSR_SF             \n#define CXL_PSL_SR_An_TA  (1ull << (63-1))   \n#define CXL_PSL_SR_An_HV  MSR_HV             \n#define CXL_PSL_SR_An_XLAT_hpt (0ull << (63-6)) \n#define CXL_PSL_SR_An_XLAT_roh (2ull << (63-6)) \n#define CXL_PSL_SR_An_XLAT_ror (3ull << (63-6)) \n#define CXL_PSL_SR_An_BOT (1ull << (63-10))  \n#define CXL_PSL_SR_An_PR  MSR_PR             \n#define CXL_PSL_SR_An_ISL (1ull << (63-53))  \n#define CXL_PSL_SR_An_TC  (1ull << (63-54))  \n#define CXL_PSL_SR_An_US  (1ull << (63-56))  \n#define CXL_PSL_SR_An_SC  (1ull << (63-58))  \n#define CXL_PSL_SR_An_R   MSR_DR             \n#define CXL_PSL_SR_An_MP  (1ull << (63-62))  \n#define CXL_PSL_SR_An_LE  (1ull << (63-63))  \n\n \n#define CXL_PSL_ID_An_F\t(1ull << (63-31))\n#define CXL_PSL_ID_An_L\t(1ull << (63-30))\n\n \n#define CXL_PSL_SERR_An_afuto\t(1ull << (63-0))\n#define CXL_PSL_SERR_An_afudis\t(1ull << (63-1))\n#define CXL_PSL_SERR_An_afuov\t(1ull << (63-2))\n#define CXL_PSL_SERR_An_badsrc\t(1ull << (63-3))\n#define CXL_PSL_SERR_An_badctx\t(1ull << (63-4))\n#define CXL_PSL_SERR_An_llcmdis\t(1ull << (63-5))\n#define CXL_PSL_SERR_An_llcmdto\t(1ull << (63-6))\n#define CXL_PSL_SERR_An_afupar\t(1ull << (63-7))\n#define CXL_PSL_SERR_An_afudup\t(1ull << (63-8))\n#define CXL_PSL_SERR_An_IRQS\t( \\\n\tCXL_PSL_SERR_An_afuto | CXL_PSL_SERR_An_afudis | CXL_PSL_SERR_An_afuov | \\\n\tCXL_PSL_SERR_An_badsrc | CXL_PSL_SERR_An_badctx | CXL_PSL_SERR_An_llcmdis | \\\n\tCXL_PSL_SERR_An_llcmdto | CXL_PSL_SERR_An_afupar | CXL_PSL_SERR_An_afudup)\n#define CXL_PSL_SERR_An_afuto_mask\t(1ull << (63-32))\n#define CXL_PSL_SERR_An_afudis_mask\t(1ull << (63-33))\n#define CXL_PSL_SERR_An_afuov_mask\t(1ull << (63-34))\n#define CXL_PSL_SERR_An_badsrc_mask\t(1ull << (63-35))\n#define CXL_PSL_SERR_An_badctx_mask\t(1ull << (63-36))\n#define CXL_PSL_SERR_An_llcmdis_mask\t(1ull << (63-37))\n#define CXL_PSL_SERR_An_llcmdto_mask\t(1ull << (63-38))\n#define CXL_PSL_SERR_An_afupar_mask\t(1ull << (63-39))\n#define CXL_PSL_SERR_An_afudup_mask\t(1ull << (63-40))\n#define CXL_PSL_SERR_An_IRQ_MASKS\t( \\\n\tCXL_PSL_SERR_An_afuto_mask | CXL_PSL_SERR_An_afudis_mask | CXL_PSL_SERR_An_afuov_mask | \\\n\tCXL_PSL_SERR_An_badsrc_mask | CXL_PSL_SERR_An_badctx_mask | CXL_PSL_SERR_An_llcmdis_mask | \\\n\tCXL_PSL_SERR_An_llcmdto_mask | CXL_PSL_SERR_An_afupar_mask | CXL_PSL_SERR_An_afudup_mask)\n\n#define CXL_PSL_SERR_An_AE\t(1ull << (63-30))\n\n \n#define CXL_PSL_SCNTL_An_CR          (0x1ull << (63-15))\n \n#define CXL_PSL_SCNTL_An_PM_MASK     (0xffffull << (63-31))\n#define CXL_PSL_SCNTL_An_PM_Shared   (0x0000ull << (63-31))\n#define CXL_PSL_SCNTL_An_PM_OS       (0x0001ull << (63-31))\n#define CXL_PSL_SCNTL_An_PM_Process  (0x0002ull << (63-31))\n#define CXL_PSL_SCNTL_An_PM_AFU      (0x0004ull << (63-31))\n#define CXL_PSL_SCNTL_An_PM_AFU_PBT  (0x0104ull << (63-31))\n \n#define CXL_PSL_SCNTL_An_Ps_MASK     (0x3ull << (63-39))\n#define CXL_PSL_SCNTL_An_Ps_Pending  (0x1ull << (63-39))\n#define CXL_PSL_SCNTL_An_Ps_Complete (0x3ull << (63-39))\n \n#define CXL_PSL_SCNTL_An_Pc          (0x1ull << (63-48))\n \n#define CXL_PSL_SCNTL_An_Ss_MASK     (0x3ull << (63-55))\n#define CXL_PSL_SCNTL_An_Ss_Pending  (0x1ull << (63-55))\n#define CXL_PSL_SCNTL_An_Ss_Complete (0x3ull << (63-55))\n \n#define CXL_PSL_SCNTL_An_Sc          (0x1ull << (63-63))\n\n \n#define CXL_AFU_Cntl_An_ES_MASK     (0x7ull << (63-2))\n#define CXL_AFU_Cntl_An_ES_Disabled (0x0ull << (63-2))\n#define CXL_AFU_Cntl_An_ES_Enabled  (0x4ull << (63-2))\n \n#define CXL_AFU_Cntl_An_E           (0x1ull << (63-3))\n \n#define CXL_AFU_Cntl_An_RS_MASK     (0x3ull << (63-5))\n#define CXL_AFU_Cntl_An_RS_Pending  (0x1ull << (63-5))\n#define CXL_AFU_Cntl_An_RS_Complete (0x2ull << (63-5))\n \n#define CXL_AFU_Cntl_An_RA          (0x1ull << (63-7))\n\n \n \n#define CXL_SSTP0_An_B_SHIFT    SLB_VSID_SSIZE_SHIFT\n#define CXL_SSTP0_An_KS             (1ull << (63-2))\n#define CXL_SSTP0_An_KP             (1ull << (63-3))\n#define CXL_SSTP0_An_N              (1ull << (63-4))\n#define CXL_SSTP0_An_L              (1ull << (63-5))\n#define CXL_SSTP0_An_C              (1ull << (63-6))\n#define CXL_SSTP0_An_TA             (1ull << (63-7))\n#define CXL_SSTP0_An_LP_SHIFT                (63-9)   \n \n#define CXL_SSTP0_An_SegTableSize_SHIFT      (63-31)  \n#define CXL_SSTP0_An_SegTableSize_MASK \\\n\t(((1ull << 12) - 1) << CXL_SSTP0_An_SegTableSize_SHIFT)\n#define CXL_SSTP0_An_STVA_U_MASK   ((1ull << (63-49))-1)\n#define CXL_SSTP1_An_STVA_L_MASK (~((1ull << (63-55))-1))\n#define CXL_SSTP1_An_V              (1ull << (63-63))\n\n \n \n#define CXL_SLBIE_C        PPC_BIT(36)          \n#define CXL_SLBIE_SS       PPC_BITMASK(37, 38)  \n#define CXL_SLBIE_SS_SHIFT PPC_BITLSHIFT(38)\n#define CXL_SLBIE_TA       PPC_BIT(38)          \n \n#define CXL_SLBIE_MAX      PPC_BITMASK(24, 31)\n#define CXL_SLBIE_PENDING  PPC_BITMASK(56, 63)\n\n \n#define CXL_TLB_SLB_P          (1ull)  \n\n \n#define CXL_TLB_SLB_IQ_ALL     (0ull)  \n#define CXL_TLB_SLB_IQ_LPID    (1ull)  \n#define CXL_TLB_SLB_IQ_LPIDPID (3ull)  \n\n \n#define CXL_PSL_AFUSEL_A (1ull << (63-55))  \n\n \n#define CXL_PSL_DSISR_An_DS (1ull << (63-0))   \n#define CXL_PSL_DSISR_An_DM (1ull << (63-1))   \n#define CXL_PSL_DSISR_An_ST (1ull << (63-2))   \n#define CXL_PSL_DSISR_An_UR (1ull << (63-3))   \n#define CXL_PSL_DSISR_TRANS (CXL_PSL_DSISR_An_DS | CXL_PSL_DSISR_An_DM | CXL_PSL_DSISR_An_ST | CXL_PSL_DSISR_An_UR)\n#define CXL_PSL_DSISR_An_PE (1ull << (63-4))   \n#define CXL_PSL_DSISR_An_AE (1ull << (63-5))   \n#define CXL_PSL_DSISR_An_OC (1ull << (63-6))   \n#define CXL_PSL_DSISR_PENDING (CXL_PSL_DSISR_TRANS | CXL_PSL_DSISR_An_PE | CXL_PSL_DSISR_An_AE | CXL_PSL_DSISR_An_OC)\n \n#define CXL_PSL_DSISR_An_M  DSISR_NOHPTE       \n#define CXL_PSL_DSISR_An_P  DSISR_PROTFAULT    \n#define CXL_PSL_DSISR_An_A  (1ull << (63-37))  \n#define CXL_PSL_DSISR_An_S  DSISR_ISSTORE      \n#define CXL_PSL_DSISR_An_K  DSISR_KEYFAULT     \n\n \n#define CXL_PSL9_DSISR_An_TF (1ull << (63-3))   \n#define CXL_PSL9_DSISR_An_PE (1ull << (63-4))   \n#define CXL_PSL9_DSISR_An_AE (1ull << (63-5))   \n#define CXL_PSL9_DSISR_An_OC (1ull << (63-6))   \n#define CXL_PSL9_DSISR_An_S (1ull << (63-38))   \n#define CXL_PSL9_DSISR_PENDING (CXL_PSL9_DSISR_An_TF | CXL_PSL9_DSISR_An_PE | CXL_PSL9_DSISR_An_AE | CXL_PSL9_DSISR_An_OC)\n \n#define CXL_PSL9_DSISR_An_CO_MASK 0x00000000000000ffULL\n#define CXL_PSL9_DSISR_An_SF      0x0000000000000080ULL   \n#define CXL_PSL9_DSISR_An_PF_SLR  0x0000000000000088ULL   \n#define CXL_PSL9_DSISR_An_PF_RGC  0x000000000000008CULL   \n#define CXL_PSL9_DSISR_An_PF_RGP  0x0000000000000090ULL   \n#define CXL_PSL9_DSISR_An_PF_HRH  0x0000000000000094ULL   \n#define CXL_PSL9_DSISR_An_PF_STEG 0x000000000000009CULL   \n#define CXL_PSL9_DSISR_An_URTCH   0x00000000000000B4ULL   \n\n \n#define CXL_PSL_TFC_An_A  (1ull << (63-28))  \n#define CXL_PSL_TFC_An_C  (1ull << (63-29))  \n#define CXL_PSL_TFC_An_AE (1ull << (63-30))  \n#define CXL_PSL_TFC_An_R  (1ull << (63-31))  \n\n \n#define CXL_PSL_DEBUG_CDC  (1ull << (63-27))  \n\n \n#define CXL_XSL9_IERAT_MLPID    (1ull << (63-0))   \n#define CXL_XSL9_IERAT_MPID     (1ull << (63-1))   \n#define CXL_XSL9_IERAT_PRS      (1ull << (63-4))   \n#define CXL_XSL9_IERAT_INVR     (1ull << (63-3))   \n#define CXL_XSL9_IERAT_IALL     (1ull << (63-8))   \n#define CXL_XSL9_IERAT_IINPROG  (1ull << (63-63))  \n\n \n#define CXL_PE_SOFTWARE_STATE_V (1ul << (31 -  0))  \n#define CXL_PE_SOFTWARE_STATE_C (1ul << (31 - 29))  \n#define CXL_PE_SOFTWARE_STATE_S (1ul << (31 - 30))  \n#define CXL_PE_SOFTWARE_STATE_T (1ul << (31 - 31))  \n\n \n#define CXL_PSL_RXCTL_AFUHP_4S      0x7000000000000000ULL\n\n \n#define CXL_SPA_SW_CMD_MASK         0xffff000000000000ULL\n#define CXL_SPA_SW_CMD_TERMINATE    0x0001000000000000ULL\n#define CXL_SPA_SW_CMD_REMOVE       0x0002000000000000ULL\n#define CXL_SPA_SW_CMD_SUSPEND      0x0003000000000000ULL\n#define CXL_SPA_SW_CMD_RESUME       0x0004000000000000ULL\n#define CXL_SPA_SW_CMD_ADD          0x0005000000000000ULL\n#define CXL_SPA_SW_CMD_UPDATE       0x0006000000000000ULL\n#define CXL_SPA_SW_STATE_MASK       0x0000ffff00000000ULL\n#define CXL_SPA_SW_STATE_TERMINATED 0x0000000100000000ULL\n#define CXL_SPA_SW_STATE_REMOVED    0x0000000200000000ULL\n#define CXL_SPA_SW_STATE_SUSPENDED  0x0000000300000000ULL\n#define CXL_SPA_SW_STATE_RESUMED    0x0000000400000000ULL\n#define CXL_SPA_SW_STATE_ADDED      0x0000000500000000ULL\n#define CXL_SPA_SW_STATE_UPDATED    0x0000000600000000ULL\n#define CXL_SPA_SW_PSL_ID_MASK      0x00000000ffff0000ULL\n#define CXL_SPA_SW_LINK_MASK        0x000000000000ffffULL\n\n#define CXL_MAX_SLICES 4\n#define MAX_AFU_MMIO_REGS 3\n\n#define CXL_MODE_TIME_SLICED 0x4\n#define CXL_SUPPORTED_MODES (CXL_MODE_DEDICATED | CXL_MODE_DIRECTED)\n\n#define CXL_DEV_MINORS 13    \n#define CXL_CARD_MINOR(adapter) (adapter->adapter_num * CXL_DEV_MINORS)\n#define CXL_DEVT_ADAPTER(dev) (MINOR(dev) / CXL_DEV_MINORS)\n\n#define CXL_PSL9_TRACEID_MAX 0xAU\n#define CXL_PSL9_TRACESTATE_FIN 0x3U\n\nenum cxl_context_status {\n\tCLOSED,\n\tOPENED,\n\tSTARTED\n};\n\nenum prefault_modes {\n\tCXL_PREFAULT_NONE,\n\tCXL_PREFAULT_WED,\n\tCXL_PREFAULT_ALL,\n};\n\nenum cxl_attrs {\n\tCXL_ADAPTER_ATTRS,\n\tCXL_AFU_MASTER_ATTRS,\n\tCXL_AFU_ATTRS,\n};\n\nstruct cxl_sste {\n\t__be64 esid_data;\n\t__be64 vsid_data;\n};\n\n#define to_cxl_adapter(d) container_of(d, struct cxl, dev)\n#define to_cxl_afu(d) container_of(d, struct cxl_afu, dev)\n\nstruct cxl_afu_native {\n\tvoid __iomem *p1n_mmio;\n\tvoid __iomem *afu_desc_mmio;\n\tirq_hw_number_t psl_hwirq;\n\tunsigned int psl_virq;\n\tstruct mutex spa_mutex;\n\t \n\tstruct cxl_process_element *spa;\n\t__be64 *sw_command_status;\n\tunsigned int spa_size;\n\tint spa_order;\n\tint spa_max_procs;\n\tu64 pp_offset;\n};\n\nstruct cxl_afu_guest {\n\tstruct cxl_afu *parent;\n\tu64 handle;\n\tphys_addr_t p2n_phys;\n\tu64 p2n_size;\n\tint max_ints;\n\tbool handle_err;\n\tstruct delayed_work work_err;\n\tint previous_state;\n};\n\nstruct cxl_afu {\n\tstruct cxl_afu_native *native;\n\tstruct cxl_afu_guest *guest;\n\tirq_hw_number_t serr_hwirq;\n\tunsigned int serr_virq;\n\tchar *psl_irq_name;\n\tchar *err_irq_name;\n\tvoid __iomem *p2n_mmio;\n\tphys_addr_t psn_phys;\n\tu64 pp_size;\n\n\tstruct cxl *adapter;\n\tstruct device dev;\n\tstruct cdev afu_cdev_s, afu_cdev_m, afu_cdev_d;\n\tstruct device *chardev_s, *chardev_m, *chardev_d;\n\tstruct idr contexts_idr;\n\tstruct dentry *debugfs;\n\tstruct mutex contexts_lock;\n\tspinlock_t afu_cntl_lock;\n\n\t \n\tatomic_t configured_state;\n\n\t \n\tu64 eb_len, eb_offset;\n\tstruct bin_attribute attr_eb;\n\n\t \n\tstruct pci_controller *phb;\n\n\tint pp_irqs;\n\tint irqs_max;\n\tint num_procs;\n\tint max_procs_virtualised;\n\tint slice;\n\tint modes_supported;\n\tint current_mode;\n\tint crs_num;\n\tu64 crs_len;\n\tu64 crs_offset;\n\tstruct list_head crs;\n\tenum prefault_modes prefault_mode;\n\tbool psa;\n\tbool pp_psa;\n\tbool enabled;\n};\n\n\nstruct cxl_irq_name {\n\tstruct list_head list;\n\tchar *name;\n};\n\nstruct irq_avail {\n\tirq_hw_number_t offset;\n\tirq_hw_number_t range;\n\tunsigned long   *bitmap;\n};\n\n \nstruct cxl_context {\n\tstruct cxl_afu *afu;\n\n\t \n\tphys_addr_t psn_phys;\n\tu64 psn_size;\n\n\t \n\tstruct address_space *mapping;\n\tstruct mutex mapping_lock;\n\tstruct page *ff_page;\n\tbool mmio_err_ff;\n\tbool kernelapi;\n\n\tspinlock_t sste_lock;  \n\tstruct cxl_sste *sstp;\n\tu64 sstp0, sstp1;\n\tunsigned int sst_size, sst_lru;\n\n\twait_queue_head_t wq;\n\t \n\tstruct pid *pid;\n\tspinlock_t lock;  \n\t \n\tu64 process_token;\n\n\t \n\tvoid *priv;\n\n\tunsigned long *irq_bitmap;  \n\tstruct cxl_irq_ranges irqs;\n\tstruct list_head irq_names;\n\tu64 fault_addr;\n\tu64 fault_dsisr;\n\tu64 afu_err;\n\n\t \n\tenum cxl_context_status status;\n\tstruct mutex status_mutex;\n\n\n\t \n\tstruct work_struct fault_work;\n\tu64 dsisr;\n\tu64 dar;\n\n\tstruct cxl_process_element *elem;\n\n\t \n\tint pe;\n\tint external_pe;\n\n\tu32 irq_count;\n\tbool pe_inserted;\n\tbool master;\n\tbool kernel;\n\tbool pending_irq;\n\tbool pending_fault;\n\tbool pending_afu_err;\n\n\t \n\tstruct cxl_afu_driver_ops *afu_driver_ops;\n\tatomic_t afu_driver_events;\n\n\tstruct rcu_head rcu;\n\n\tstruct mm_struct *mm;\n\n\tu16 tidr;\n\tbool assign_tidr;\n};\n\nstruct cxl_irq_info;\n\nstruct cxl_service_layer_ops {\n\tint (*adapter_regs_init)(struct cxl *adapter, struct pci_dev *dev);\n\tint (*invalidate_all)(struct cxl *adapter);\n\tint (*afu_regs_init)(struct cxl_afu *afu);\n\tint (*sanitise_afu_regs)(struct cxl_afu *afu);\n\tint (*register_serr_irq)(struct cxl_afu *afu);\n\tvoid (*release_serr_irq)(struct cxl_afu *afu);\n\tirqreturn_t (*handle_interrupt)(int irq, struct cxl_context *ctx, struct cxl_irq_info *irq_info);\n\tirqreturn_t (*fail_irq)(struct cxl_afu *afu, struct cxl_irq_info *irq_info);\n\tint (*activate_dedicated_process)(struct cxl_afu *afu);\n\tint (*attach_afu_directed)(struct cxl_context *ctx, u64 wed, u64 amr);\n\tint (*attach_dedicated_process)(struct cxl_context *ctx, u64 wed, u64 amr);\n\tvoid (*update_dedicated_ivtes)(struct cxl_context *ctx);\n\tvoid (*debugfs_add_adapter_regs)(struct cxl *adapter, struct dentry *dir);\n\tvoid (*debugfs_add_afu_regs)(struct cxl_afu *afu, struct dentry *dir);\n\tvoid (*psl_irq_dump_registers)(struct cxl_context *ctx);\n\tvoid (*err_irq_dump_registers)(struct cxl *adapter);\n\tvoid (*debugfs_stop_trace)(struct cxl *adapter);\n\tvoid (*write_timebase_ctrl)(struct cxl *adapter);\n\tu64 (*timebase_read)(struct cxl *adapter);\n\tint capi_mode;\n\tbool needs_reset_before_disable;\n};\n\nstruct cxl_native {\n\tu64 afu_desc_off;\n\tu64 afu_desc_size;\n\tvoid __iomem *p1_mmio;\n\tvoid __iomem *p2_mmio;\n\tirq_hw_number_t err_hwirq;\n\tunsigned int err_virq;\n\tu64 ps_off;\n\tbool no_data_cache;  \n\tconst struct cxl_service_layer_ops *sl_ops;\n};\n\nstruct cxl_guest {\n\tstruct platform_device *pdev;\n\tint irq_nranges;\n\tstruct cdev cdev;\n\tirq_hw_number_t irq_base_offset;\n\tstruct irq_avail *irq_avail;\n\tspinlock_t irq_alloc_lock;\n\tu64 handle;\n\tchar *status;\n\tu16 vendor;\n\tu16 device;\n\tu16 subsystem_vendor;\n\tu16 subsystem;\n};\n\nstruct cxl {\n\tstruct cxl_native *native;\n\tstruct cxl_guest *guest;\n\tspinlock_t afu_list_lock;\n\tstruct cxl_afu *afu[CXL_MAX_SLICES];\n\tstruct device dev;\n\tstruct dentry *trace;\n\tstruct dentry *psl_err_chk;\n\tstruct dentry *debugfs;\n\tchar *irq_name;\n\tstruct bin_attribute cxl_attr;\n\tint adapter_num;\n\tint user_irqs;\n\tu64 ps_size;\n\tu16 psl_rev;\n\tu16 base_image;\n\tu8 vsec_status;\n\tu8 caia_major;\n\tu8 caia_minor;\n\tu8 slices;\n\tbool user_image_loaded;\n\tbool perst_loads_image;\n\tbool perst_select_user;\n\tbool perst_same_image;\n\tbool psl_timebase_synced;\n\tbool tunneled_ops_supported;\n\n\t \n\tatomic_t contexts_num;\n};\n\nint cxl_pci_alloc_one_irq(struct cxl *adapter);\nvoid cxl_pci_release_one_irq(struct cxl *adapter, int hwirq);\nint cxl_pci_alloc_irq_ranges(struct cxl_irq_ranges *irqs, struct cxl *adapter, unsigned int num);\nvoid cxl_pci_release_irq_ranges(struct cxl_irq_ranges *irqs, struct cxl *adapter);\nint cxl_pci_setup_irq(struct cxl *adapter, unsigned int hwirq, unsigned int virq);\nint cxl_update_image_control(struct cxl *adapter);\nint cxl_pci_reset(struct cxl *adapter);\nvoid cxl_pci_release_afu(struct device *dev);\nssize_t cxl_pci_read_adapter_vpd(struct cxl *adapter, void *buf, size_t len);\n\n \nstruct cxl_process_element_common {\n\t__be32 tid;\n\t__be32 pid;\n\t__be64 csrp;\n\tunion {\n\t\tstruct {\n\t\t\t__be64 aurp0;\n\t\t\t__be64 aurp1;\n\t\t\t__be64 sstp0;\n\t\t\t__be64 sstp1;\n\t\t} psl8;   \n\t\tstruct {\n\t\t\tu8     reserved2[8];\n\t\t\tu8     reserved3[8];\n\t\t\tu8     reserved4[8];\n\t\t\tu8     reserved5[8];\n\t\t} psl9;   \n\t} u;\n\t__be64 amr;\n\tu8     reserved6[4];\n\t__be64 wed;\n} __packed;\n\n \nstruct cxl_process_element {\n\t__be64 sr;\n\t__be64 SPOffset;\n\tunion {\n\t\t__be64 sdr;           \n\t\tu8     reserved1[8];  \n\t} u;\n\t__be64 haurp;\n\t__be32 ctxtime;\n\t__be16 ivte_offsets[4];\n\t__be16 ivte_ranges[4];\n\t__be32 lpid;\n\tstruct cxl_process_element_common common;\n\t__be32 software_state;\n} __packed;\n\nstatic inline bool cxl_adapter_link_ok(struct cxl *cxl, struct cxl_afu *afu)\n{\n\tstruct pci_dev *pdev;\n\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\tpdev = to_pci_dev(cxl->dev.parent);\n\t\treturn !pci_channel_offline(pdev);\n\t}\n\treturn true;\n}\n\nstatic inline void __iomem *_cxl_p1_addr(struct cxl *cxl, cxl_p1_reg_t reg)\n{\n\tWARN_ON(!cpu_has_feature(CPU_FTR_HVMODE));\n\treturn cxl->native->p1_mmio + cxl_reg_off(reg);\n}\n\nstatic inline void cxl_p1_write(struct cxl *cxl, cxl_p1_reg_t reg, u64 val)\n{\n\tif (likely(cxl_adapter_link_ok(cxl, NULL)))\n\t\tout_be64(_cxl_p1_addr(cxl, reg), val);\n}\n\nstatic inline u64 cxl_p1_read(struct cxl *cxl, cxl_p1_reg_t reg)\n{\n\tif (likely(cxl_adapter_link_ok(cxl, NULL)))\n\t\treturn in_be64(_cxl_p1_addr(cxl, reg));\n\telse\n\t\treturn ~0ULL;\n}\n\nstatic inline void __iomem *_cxl_p1n_addr(struct cxl_afu *afu, cxl_p1n_reg_t reg)\n{\n\tWARN_ON(!cpu_has_feature(CPU_FTR_HVMODE));\n\treturn afu->native->p1n_mmio + cxl_reg_off(reg);\n}\n\nstatic inline void cxl_p1n_write(struct cxl_afu *afu, cxl_p1n_reg_t reg, u64 val)\n{\n\tif (likely(cxl_adapter_link_ok(afu->adapter, afu)))\n\t\tout_be64(_cxl_p1n_addr(afu, reg), val);\n}\n\nstatic inline u64 cxl_p1n_read(struct cxl_afu *afu, cxl_p1n_reg_t reg)\n{\n\tif (likely(cxl_adapter_link_ok(afu->adapter, afu)))\n\t\treturn in_be64(_cxl_p1n_addr(afu, reg));\n\telse\n\t\treturn ~0ULL;\n}\n\nstatic inline void __iomem *_cxl_p2n_addr(struct cxl_afu *afu, cxl_p2n_reg_t reg)\n{\n\treturn afu->p2n_mmio + cxl_reg_off(reg);\n}\n\nstatic inline void cxl_p2n_write(struct cxl_afu *afu, cxl_p2n_reg_t reg, u64 val)\n{\n\tif (likely(cxl_adapter_link_ok(afu->adapter, afu)))\n\t\tout_be64(_cxl_p2n_addr(afu, reg), val);\n}\n\nstatic inline u64 cxl_p2n_read(struct cxl_afu *afu, cxl_p2n_reg_t reg)\n{\n\tif (likely(cxl_adapter_link_ok(afu->adapter, afu)))\n\t\treturn in_be64(_cxl_p2n_addr(afu, reg));\n\telse\n\t\treturn ~0ULL;\n}\n\nstatic inline bool cxl_is_power8(void)\n{\n\tif ((pvr_version_is(PVR_POWER8E)) ||\n\t    (pvr_version_is(PVR_POWER8NVL)) ||\n\t    (pvr_version_is(PVR_POWER8)))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool cxl_is_power9(void)\n{\n\tif (pvr_version_is(PVR_POWER9))\n\t\treturn true;\n\treturn false;\n}\n\nssize_t cxl_pci_afu_read_err_buffer(struct cxl_afu *afu, char *buf,\n\t\t\t\tloff_t off, size_t count);\n\n\nstruct cxl_calls {\n\tvoid (*cxl_slbia)(struct mm_struct *mm);\n\tstruct module *owner;\n};\nint register_cxl_calls(struct cxl_calls *calls);\nvoid unregister_cxl_calls(struct cxl_calls *calls);\nint cxl_update_properties(struct device_node *dn, struct property *new_prop);\n\nvoid cxl_remove_adapter_nr(struct cxl *adapter);\n\nvoid cxl_release_spa(struct cxl_afu *afu);\n\ndev_t cxl_get_dev(void);\nint cxl_file_init(void);\nvoid cxl_file_exit(void);\nint cxl_register_adapter(struct cxl *adapter);\nint cxl_register_afu(struct cxl_afu *afu);\nint cxl_chardev_d_afu_add(struct cxl_afu *afu);\nint cxl_chardev_m_afu_add(struct cxl_afu *afu);\nint cxl_chardev_s_afu_add(struct cxl_afu *afu);\nvoid cxl_chardev_afu_remove(struct cxl_afu *afu);\n\nvoid cxl_context_detach_all(struct cxl_afu *afu);\nvoid cxl_context_free(struct cxl_context *ctx);\nvoid cxl_context_detach(struct cxl_context *ctx);\n\nint cxl_sysfs_adapter_add(struct cxl *adapter);\nvoid cxl_sysfs_adapter_remove(struct cxl *adapter);\nint cxl_sysfs_afu_add(struct cxl_afu *afu);\nvoid cxl_sysfs_afu_remove(struct cxl_afu *afu);\nint cxl_sysfs_afu_m_add(struct cxl_afu *afu);\nvoid cxl_sysfs_afu_m_remove(struct cxl_afu *afu);\n\nstruct cxl *cxl_alloc_adapter(void);\nstruct cxl_afu *cxl_alloc_afu(struct cxl *adapter, int slice);\nint cxl_afu_select_best_mode(struct cxl_afu *afu);\n\nint cxl_native_register_psl_irq(struct cxl_afu *afu);\nvoid cxl_native_release_psl_irq(struct cxl_afu *afu);\nint cxl_native_register_psl_err_irq(struct cxl *adapter);\nvoid cxl_native_release_psl_err_irq(struct cxl *adapter);\nint cxl_native_register_serr_irq(struct cxl_afu *afu);\nvoid cxl_native_release_serr_irq(struct cxl_afu *afu);\nint afu_register_irqs(struct cxl_context *ctx, u32 count);\nvoid afu_release_irqs(struct cxl_context *ctx, void *cookie);\nvoid afu_irq_name_free(struct cxl_context *ctx);\n\nint cxl_attach_afu_directed_psl9(struct cxl_context *ctx, u64 wed, u64 amr);\nint cxl_attach_afu_directed_psl8(struct cxl_context *ctx, u64 wed, u64 amr);\nint cxl_activate_dedicated_process_psl9(struct cxl_afu *afu);\nint cxl_activate_dedicated_process_psl8(struct cxl_afu *afu);\nint cxl_attach_dedicated_process_psl9(struct cxl_context *ctx, u64 wed, u64 amr);\nint cxl_attach_dedicated_process_psl8(struct cxl_context *ctx, u64 wed, u64 amr);\nvoid cxl_update_dedicated_ivtes_psl9(struct cxl_context *ctx);\nvoid cxl_update_dedicated_ivtes_psl8(struct cxl_context *ctx);\n\n#ifdef CONFIG_DEBUG_FS\n\nvoid cxl_debugfs_init(void);\nvoid cxl_debugfs_exit(void);\nvoid cxl_debugfs_adapter_add(struct cxl *adapter);\nvoid cxl_debugfs_adapter_remove(struct cxl *adapter);\nvoid cxl_debugfs_afu_add(struct cxl_afu *afu);\nvoid cxl_debugfs_afu_remove(struct cxl_afu *afu);\nvoid cxl_debugfs_add_adapter_regs_psl9(struct cxl *adapter, struct dentry *dir);\nvoid cxl_debugfs_add_adapter_regs_psl8(struct cxl *adapter, struct dentry *dir);\nvoid cxl_debugfs_add_afu_regs_psl9(struct cxl_afu *afu, struct dentry *dir);\nvoid cxl_debugfs_add_afu_regs_psl8(struct cxl_afu *afu, struct dentry *dir);\n\n#else  \n\nstatic inline void __init cxl_debugfs_init(void)\n{\n}\n\nstatic inline void cxl_debugfs_exit(void)\n{\n}\n\nstatic inline void cxl_debugfs_adapter_add(struct cxl *adapter)\n{\n}\n\nstatic inline void cxl_debugfs_adapter_remove(struct cxl *adapter)\n{\n}\n\nstatic inline void cxl_debugfs_afu_add(struct cxl_afu *afu)\n{\n}\n\nstatic inline void cxl_debugfs_afu_remove(struct cxl_afu *afu)\n{\n}\n\nstatic inline void cxl_debugfs_add_adapter_regs_psl9(struct cxl *adapter,\n\t\t\t\t\t\t    struct dentry *dir)\n{\n}\n\nstatic inline void cxl_debugfs_add_adapter_regs_psl8(struct cxl *adapter,\n\t\t\t\t\t\t    struct dentry *dir)\n{\n}\n\nstatic inline void cxl_debugfs_add_afu_regs_psl9(struct cxl_afu *afu, struct dentry *dir)\n{\n}\n\nstatic inline void cxl_debugfs_add_afu_regs_psl8(struct cxl_afu *afu, struct dentry *dir)\n{\n}\n\n#endif  \n\nvoid cxl_handle_fault(struct work_struct *work);\nvoid cxl_prefault(struct cxl_context *ctx, u64 wed);\nint cxl_handle_mm_fault(struct mm_struct *mm, u64 dsisr, u64 dar);\n\nstruct cxl *get_cxl_adapter(int num);\nint cxl_alloc_sst(struct cxl_context *ctx);\nvoid cxl_dump_debug_buffer(void *addr, size_t size);\n\nvoid init_cxl_native(void);\n\nstruct cxl_context *cxl_context_alloc(void);\nint cxl_context_init(struct cxl_context *ctx, struct cxl_afu *afu, bool master);\nvoid cxl_context_set_mapping(struct cxl_context *ctx,\n\t\t\tstruct address_space *mapping);\nvoid cxl_context_free(struct cxl_context *ctx);\nint cxl_context_iomap(struct cxl_context *ctx, struct vm_area_struct *vma);\nunsigned int cxl_map_irq(struct cxl *adapter, irq_hw_number_t hwirq,\n\t\t\t irq_handler_t handler, void *cookie, const char *name);\nvoid cxl_unmap_irq(unsigned int virq, void *cookie);\nint __detach_context(struct cxl_context *ctx);\n\n \nstruct cxl_irq_info {\n\tu64 dsisr;\n\tu64 dar;\n\tu64 dsr;\n\tu64 reserved;\n\tu64 afu_err;\n\tu64 errstat;\n\tu64 proc_handle;\n\tu64 padding[2];  \n};\n\nvoid cxl_assign_psn_space(struct cxl_context *ctx);\nint cxl_invalidate_all_psl9(struct cxl *adapter);\nint cxl_invalidate_all_psl8(struct cxl *adapter);\nirqreturn_t cxl_irq_psl9(int irq, struct cxl_context *ctx, struct cxl_irq_info *irq_info);\nirqreturn_t cxl_irq_psl8(int irq, struct cxl_context *ctx, struct cxl_irq_info *irq_info);\nirqreturn_t cxl_fail_irq_psl(struct cxl_afu *afu, struct cxl_irq_info *irq_info);\nint cxl_register_one_irq(struct cxl *adapter, irq_handler_t handler,\n\t\t\tvoid *cookie, irq_hw_number_t *dest_hwirq,\n\t\t\tunsigned int *dest_virq, const char *name);\n\nint cxl_check_error(struct cxl_afu *afu);\nint cxl_afu_slbia(struct cxl_afu *afu);\nint cxl_data_cache_flush(struct cxl *adapter);\nint cxl_afu_disable(struct cxl_afu *afu);\nint cxl_psl_purge(struct cxl_afu *afu);\nint cxl_calc_capp_routing(struct pci_dev *dev, u64 *chipid,\n\t\t\t  u32 *phb_index, u64 *capp_unit_id);\nint cxl_slot_is_switched(struct pci_dev *dev);\nint cxl_get_xsl9_dsnctl(struct pci_dev *dev, u64 capp_unit_id, u64 *reg);\nu64 cxl_calculate_sr(bool master, bool kernel, bool real_mode, bool p9);\n\nvoid cxl_native_irq_dump_regs_psl9(struct cxl_context *ctx);\nvoid cxl_native_irq_dump_regs_psl8(struct cxl_context *ctx);\nvoid cxl_native_err_irq_dump_regs_psl8(struct cxl *adapter);\nvoid cxl_native_err_irq_dump_regs_psl9(struct cxl *adapter);\nint cxl_pci_vphb_add(struct cxl_afu *afu);\nvoid cxl_pci_vphb_remove(struct cxl_afu *afu);\nvoid cxl_release_mapping(struct cxl_context *ctx);\n\nextern struct pci_driver cxl_pci_driver;\nextern struct platform_driver cxl_of_driver;\nint afu_allocate_irqs(struct cxl_context *ctx, u32 count);\n\nint afu_open(struct inode *inode, struct file *file);\nint afu_release(struct inode *inode, struct file *file);\nlong afu_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\nint afu_mmap(struct file *file, struct vm_area_struct *vm);\n__poll_t afu_poll(struct file *file, struct poll_table_struct *poll);\nssize_t afu_read(struct file *file, char __user *buf, size_t count, loff_t *off);\nextern const struct file_operations afu_fops;\n\nstruct cxl *cxl_guest_init_adapter(struct device_node *np, struct platform_device *dev);\nvoid cxl_guest_remove_adapter(struct cxl *adapter);\nint cxl_of_read_adapter_handle(struct cxl *adapter, struct device_node *np);\nint cxl_of_read_adapter_properties(struct cxl *adapter, struct device_node *np);\nssize_t cxl_guest_read_adapter_vpd(struct cxl *adapter, void *buf, size_t len);\nssize_t cxl_guest_read_afu_vpd(struct cxl_afu *afu, void *buf, size_t len);\nint cxl_guest_init_afu(struct cxl *adapter, int slice, struct device_node *afu_np);\nvoid cxl_guest_remove_afu(struct cxl_afu *afu);\nint cxl_of_read_afu_handle(struct cxl_afu *afu, struct device_node *afu_np);\nint cxl_of_read_afu_properties(struct cxl_afu *afu, struct device_node *afu_np);\nint cxl_guest_add_chardev(struct cxl *adapter);\nvoid cxl_guest_remove_chardev(struct cxl *adapter);\nvoid cxl_guest_reload_module(struct cxl *adapter);\nint cxl_of_probe(struct platform_device *pdev);\n\nstruct cxl_backend_ops {\n\tstruct module *module;\n\tint (*adapter_reset)(struct cxl *adapter);\n\tint (*alloc_one_irq)(struct cxl *adapter);\n\tvoid (*release_one_irq)(struct cxl *adapter, int hwirq);\n\tint (*alloc_irq_ranges)(struct cxl_irq_ranges *irqs,\n\t\t\t\tstruct cxl *adapter, unsigned int num);\n\tvoid (*release_irq_ranges)(struct cxl_irq_ranges *irqs,\n\t\t\t\tstruct cxl *adapter);\n\tint (*setup_irq)(struct cxl *adapter, unsigned int hwirq,\n\t\t\tunsigned int virq);\n\tirqreturn_t (*handle_psl_slice_error)(struct cxl_context *ctx,\n\t\t\t\t\tu64 dsisr, u64 errstat);\n\tirqreturn_t (*psl_interrupt)(int irq, void *data);\n\tint (*ack_irq)(struct cxl_context *ctx, u64 tfc, u64 psl_reset_mask);\n\tvoid (*irq_wait)(struct cxl_context *ctx);\n\tint (*attach_process)(struct cxl_context *ctx, bool kernel,\n\t\t\tu64 wed, u64 amr);\n\tint (*detach_process)(struct cxl_context *ctx);\n\tvoid (*update_ivtes)(struct cxl_context *ctx);\n\tbool (*support_attributes)(const char *attr_name, enum cxl_attrs type);\n\tbool (*link_ok)(struct cxl *cxl, struct cxl_afu *afu);\n\tvoid (*release_afu)(struct device *dev);\n\tssize_t (*afu_read_err_buffer)(struct cxl_afu *afu, char *buf,\n\t\t\t\tloff_t off, size_t count);\n\tint (*afu_check_and_enable)(struct cxl_afu *afu);\n\tint (*afu_activate_mode)(struct cxl_afu *afu, int mode);\n\tint (*afu_deactivate_mode)(struct cxl_afu *afu, int mode);\n\tint (*afu_reset)(struct cxl_afu *afu);\n\tint (*afu_cr_read8)(struct cxl_afu *afu, int cr_idx, u64 offset, u8 *val);\n\tint (*afu_cr_read16)(struct cxl_afu *afu, int cr_idx, u64 offset, u16 *val);\n\tint (*afu_cr_read32)(struct cxl_afu *afu, int cr_idx, u64 offset, u32 *val);\n\tint (*afu_cr_read64)(struct cxl_afu *afu, int cr_idx, u64 offset, u64 *val);\n\tint (*afu_cr_write8)(struct cxl_afu *afu, int cr_idx, u64 offset, u8 val);\n\tint (*afu_cr_write16)(struct cxl_afu *afu, int cr_idx, u64 offset, u16 val);\n\tint (*afu_cr_write32)(struct cxl_afu *afu, int cr_idx, u64 offset, u32 val);\n\tssize_t (*read_adapter_vpd)(struct cxl *adapter, void *buf, size_t count);\n};\nextern const struct cxl_backend_ops cxl_native_ops;\nextern const struct cxl_backend_ops cxl_guest_ops;\nextern const struct cxl_backend_ops *cxl_ops;\n\n \nbool cxl_pci_is_vphb_device(struct pci_dev *dev);\n\n \nvoid cxl_afu_decode_psl_serr(struct cxl_afu *afu, u64 serr);\n\n \nint cxl_adapter_context_get(struct cxl *adapter);\n\n \nvoid cxl_adapter_context_put(struct cxl *adapter);\n\n \nint cxl_adapter_context_lock(struct cxl *adapter);\n\n \nvoid cxl_adapter_context_unlock(struct cxl *adapter);\n\n \nvoid cxl_context_mm_count_get(struct cxl_context *ctx);\n\n \nvoid cxl_context_mm_count_put(struct cxl_context *ctx);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}