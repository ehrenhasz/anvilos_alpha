{
  "module_name": "gehc-achc.c",
  "hash_id": "c52ff6e815f5e8f553effe10932f5ac588a79e5864d10732c9533ee42867d973",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/gehc-achc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n\n#define ACHC_MAX_FREQ_HZ 300000\n#define ACHC_FAST_READ_FREQ_HZ 1000000\n\nstruct achc_data {\n\tstruct spi_device *main;\n\tstruct spi_device *ezport;\n\tstruct gpio_desc *reset;\n\n\tstruct mutex device_lock;  \n};\n\n#define EZPORT_RESET_DELAY_MS\t100\n#define EZPORT_STARTUP_DELAY_MS\t200\n#define EZPORT_WRITE_WAIT_MS\t10\n#define EZPORT_TRANSFER_SIZE\t2048\n\n#define EZPORT_CMD_SP\t\t0x02  \n#define EZPORT_CMD_RDSR\t\t0x05  \n#define EZPORT_CMD_WREN\t\t0x06  \n#define EZPORT_CMD_FAST_READ\t0x0b  \n#define EZPORT_CMD_RESET\t0xb9  \n#define EZPORT_CMD_BE\t\t0xc7  \n#define EZPORT_CMD_SE\t\t0xd8  \n\n#define EZPORT_SECTOR_SIZE\t4096\n#define EZPORT_SECTOR_MASK\t(EZPORT_SECTOR_SIZE - 1)\n\n#define EZPORT_STATUS_WIP\tBIT(0)  \n#define EZPORT_STATUS_WEN\tBIT(1)  \n#define EZPORT_STATUS_BEDIS\tBIT(2)  \n#define EZPORT_STATUS_FLEXRAM\tBIT(3)  \n#define EZPORT_STATUS_WEF\tBIT(6)  \n#define EZPORT_STATUS_FS\tBIT(7)  \n\nstatic void ezport_reset(struct gpio_desc *reset)\n{\n\tgpiod_set_value(reset, 1);\n\tmsleep(EZPORT_RESET_DELAY_MS);\n\tgpiod_set_value(reset, 0);\n\tmsleep(EZPORT_STARTUP_DELAY_MS);\n}\n\nstatic int ezport_start_programming(struct spi_device *spi, struct gpio_desc *reset)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer assert_cs = {\n\t\t.cs_change   = 1,\n\t};\n\tstruct spi_transfer release_cs = { };\n\tint ret;\n\n\tspi_bus_lock(spi->master);\n\n\t \n\tspi_message_init(&msg);\n\tspi_message_add_tail(&assert_cs, &msg);\n\tret = spi_sync_locked(spi, &msg);\n\tif (ret)\n\t\tgoto fail;\n\n\tmsleep(EZPORT_STARTUP_DELAY_MS);\n\n\t \n\tezport_reset(reset);\n\n\t \n\tspi_message_init(&msg);\n\tspi_message_add_tail(&release_cs, &msg);\n\tret = spi_sync_locked(spi, &msg);\n\nfail:\n\tspi_bus_unlock(spi->master);\n\treturn ret;\n}\n\nstatic void ezport_stop_programming(struct spi_device *spi, struct gpio_desc *reset)\n{\n\t \n\tspi_bus_lock(spi->master);\n\tezport_reset(reset);\n\tspi_bus_unlock(spi->master);\n}\n\nstatic int ezport_get_status_register(struct spi_device *spi)\n{\n\tint ret;\n\n\tret = spi_w8r8(spi, EZPORT_CMD_RDSR);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0xff) {\n\t\tdev_err(&spi->dev, \"Invalid EzPort status, EzPort is not functional!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int ezport_soft_reset(struct spi_device *spi)\n{\n\tu8 cmd = EZPORT_CMD_RESET;\n\tint ret;\n\n\tret = spi_write(spi, &cmd, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(EZPORT_STARTUP_DELAY_MS);\n\n\treturn 0;\n}\n\nstatic int ezport_send_simple(struct spi_device *spi, u8 cmd)\n{\n\tint ret;\n\n\tret = spi_write(spi, &cmd, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ezport_get_status_register(spi);\n}\n\nstatic int ezport_wait_write(struct spi_device *spi, u32 retries)\n{\n\tint ret;\n\tu32 i;\n\n\tfor (i = 0; i < retries; i++) {\n\t\tret = ezport_get_status_register(spi);\n\t\tif (ret >= 0 && !(ret & EZPORT_STATUS_WIP))\n\t\t\tbreak;\n\t\tmsleep(EZPORT_WRITE_WAIT_MS);\n\t}\n\n\treturn ret;\n}\n\nstatic int ezport_write_enable(struct spi_device *spi)\n{\n\tint ret = 0, retries = 3;\n\n\tfor (retries = 0; retries < 3; retries++) {\n\t\tret = ezport_send_simple(spi, EZPORT_CMD_WREN);\n\t\tif (ret > 0 && ret & EZPORT_STATUS_WEN)\n\t\t\tbreak;\n\t}\n\n\tif (!(ret & EZPORT_STATUS_WEN)) {\n\t\tdev_err(&spi->dev, \"EzPort write enable timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\nstatic int ezport_bulk_erase(struct spi_device *spi)\n{\n\tint ret;\n\tstatic const u8 cmd = EZPORT_CMD_BE;\n\n\tdev_dbg(&spi->dev, \"EzPort bulk erase...\\n\");\n\n\tret = ezport_write_enable(spi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = spi_write(spi, &cmd, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ezport_wait_write(spi, 1000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ezport_section_erase(struct spi_device *spi, u32 address)\n{\n\tu8 query[] = {EZPORT_CMD_SE, (address >> 16) & 0xff, (address >> 8) & 0xff, address & 0xff};\n\tint ret;\n\n\tdev_dbg(&spi->dev, \"Ezport section erase @ 0x%06x...\\n\", address);\n\n\tif (address & EZPORT_SECTOR_MASK)\n\t\treturn -EINVAL;\n\n\tret = ezport_write_enable(spi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = spi_write(spi, query, sizeof(query));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ezport_wait_write(spi, 200);\n}\n\nstatic int ezport_flash_transfer(struct spi_device *spi, u32 address,\n\t\t\t\t const u8 *payload, size_t payload_size)\n{\n\tstruct spi_transfer xfers[2] = {};\n\tu8 *command;\n\tint ret;\n\n\tdev_dbg(&spi->dev, \"EzPort write %zu bytes @ 0x%06x...\\n\", payload_size, address);\n\n\tret = ezport_write_enable(spi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcommand = kmalloc(4, GFP_KERNEL | GFP_DMA);\n\tif (!command)\n\t\treturn -ENOMEM;\n\n\tcommand[0] = EZPORT_CMD_SP;\n\tcommand[1] = address >> 16;\n\tcommand[2] = address >> 8;\n\tcommand[3] = address >> 0;\n\n\txfers[0].tx_buf = command;\n\txfers[0].len = 4;\n\n\txfers[1].tx_buf = payload;\n\txfers[1].len = payload_size;\n\n\tret = spi_sync_transfer(spi, xfers, 2);\n\tkfree(command);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ezport_wait_write(spi, 40);\n}\n\nstatic int ezport_flash_compare(struct spi_device *spi, u32 address,\n\t\t\t\tconst u8 *payload, size_t payload_size)\n{\n\tstruct spi_transfer xfers[2] = {};\n\tu8 *buffer;\n\tint ret;\n\n\tbuffer = kmalloc(payload_size + 5, GFP_KERNEL | GFP_DMA);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer[0] = EZPORT_CMD_FAST_READ;\n\tbuffer[1] = address >> 16;\n\tbuffer[2] = address >> 8;\n\tbuffer[3] = address >> 0;\n\n\txfers[0].tx_buf = buffer;\n\txfers[0].len = 4;\n\txfers[0].speed_hz = ACHC_FAST_READ_FREQ_HZ;\n\n\txfers[1].rx_buf = buffer + 4;\n\txfers[1].len = payload_size + 1;\n\txfers[1].speed_hz = ACHC_FAST_READ_FREQ_HZ;\n\n\tret = spi_sync_transfer(spi, xfers, 2);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = memcmp(payload, buffer + 4 + 1, payload_size);\n\tif (ret) {\n\t\tret = -EBADMSG;\n\t\tdev_dbg(&spi->dev, \"Verification failure @ %06x\", address);\n\t\tprint_hex_dump_bytes(\"fw:  \", DUMP_PREFIX_OFFSET, payload, payload_size);\n\t\tprint_hex_dump_bytes(\"dev: \", DUMP_PREFIX_OFFSET, buffer + 4, payload_size);\n\t}\n\nerr:\n\tkfree(buffer);\n\treturn ret;\n}\n\nstatic int ezport_firmware_compare_data(struct spi_device *spi,\n\t\t\t\t\tconst u8 *data, size_t size)\n{\n\tint ret;\n\tsize_t address = 0;\n\tsize_t transfer_size;\n\n\tdev_dbg(&spi->dev, \"EzPort compare data with %zu bytes...\\n\", size);\n\n\tret = ezport_get_status_register(spi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & EZPORT_STATUS_FS) {\n\t\tdev_info(&spi->dev, \"Device is in secure mode (status=0x%02x)!\\n\", ret);\n\t\tdev_info(&spi->dev, \"FW verification is not possible\\n\");\n\t\treturn -EACCES;\n\t}\n\n\twhile (size - address > 0) {\n\t\ttransfer_size = min((size_t) EZPORT_TRANSFER_SIZE, size - address);\n\n\t\tret = ezport_flash_compare(spi, address, data+address, transfer_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taddress += transfer_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int ezport_firmware_flash_data(struct spi_device *spi,\n\t\t\t\t      const u8 *data, size_t size)\n{\n\tint ret;\n\tsize_t address = 0;\n\tsize_t transfer_size;\n\n\tdev_dbg(&spi->dev, \"EzPort flash data with %zu bytes...\\n\", size);\n\n\tret = ezport_get_status_register(spi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & EZPORT_STATUS_FS) {\n\t\tret = ezport_bulk_erase(spi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret & EZPORT_STATUS_FS)\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (size - address > 0) {\n\t\tif (!(address & EZPORT_SECTOR_MASK)) {\n\t\t\tret = ezport_section_erase(spi, address);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret & EZPORT_STATUS_WIP || ret & EZPORT_STATUS_WEF)\n\t\t\t\treturn -EIO;\n\t\t}\n\n\t\ttransfer_size = min((size_t) EZPORT_TRANSFER_SIZE, size - address);\n\n\t\tret = ezport_flash_transfer(spi, address,\n\t\t\t\t\t    data+address, transfer_size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret & EZPORT_STATUS_WIP)\n\t\t\treturn -ETIMEDOUT;\n\t\telse if (ret & EZPORT_STATUS_WEF)\n\t\t\treturn -EIO;\n\n\t\taddress += transfer_size;\n\t}\n\n\tdev_dbg(&spi->dev, \"EzPort verify flashed data...\\n\");\n\tret = ezport_firmware_compare_data(spi, data, size);\n\n\t \n\tif (ret == -EACCES)\n\t\tret = 0;\n\n\tif (ret < 0)\n\t\tdev_err(&spi->dev, \"Failed to verify flashed data: %d\\n\", ret);\n\n\tret = ezport_soft_reset(spi);\n\tif (ret < 0)\n\t\tdev_warn(&spi->dev, \"EzPort reset failed!\\n\");\n\n\treturn ret;\n}\n\nstatic int ezport_firmware_load(struct spi_device *spi, const char *fwname)\n{\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = request_firmware(&fw, fwname, &spi->dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Could not get firmware: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ezport_firmware_flash_data(spi, fw->data, fw->size);\n\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\n \nstatic int ezport_flash(struct spi_device *spi, struct gpio_desc *reset, const char *fwname)\n{\n\tint ret;\n\n\tret = ezport_start_programming(spi, reset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ezport_firmware_load(spi, fwname);\n\n\tezport_stop_programming(spi, reset);\n\n\tif (ret)\n\t\tdev_err(&spi->dev, \"Failed to flash firmware: %d\\n\", ret);\n\telse\n\t\tdev_dbg(&spi->dev, \"Finished FW flashing!\\n\");\n\n\treturn ret;\n}\n\nstatic ssize_t update_firmware_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct achc_data *achc = dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret < 0 || value != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&achc->device_lock);\n\tret = ezport_flash(achc->ezport, achc->reset, \"achc.bin\");\n\tmutex_unlock(&achc->device_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(update_firmware);\n\nstatic ssize_t reset_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct achc_data *achc = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&achc->device_lock);\n\tret = gpiod_get_value(achc->reset);\n\tmutex_unlock(&achc->device_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t reset_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct achc_data *achc = dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret < 0 || value > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&achc->device_lock);\n\tgpiod_set_value(achc->reset, value);\n\tmutex_unlock(&achc->device_lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(reset);\n\nstatic struct attribute *gehc_achc_attrs[] = {\n\t&dev_attr_update_firmware.attr,\n\t&dev_attr_reset.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(gehc_achc);\n\nstatic void unregister_ezport(void *data)\n{\n\tstruct spi_device *ezport = data;\n\n\tspi_unregister_device(ezport);\n}\n\nstatic int gehc_achc_probe(struct spi_device *spi)\n{\n\tstruct achc_data *achc;\n\tint ezport_reg, ret;\n\n\tspi->max_speed_hz = ACHC_MAX_FREQ_HZ;\n\tspi->bits_per_word = 8;\n\tspi->mode = SPI_MODE_0;\n\n\tachc = devm_kzalloc(&spi->dev, sizeof(*achc), GFP_KERNEL);\n\tif (!achc)\n\t\treturn -ENOMEM;\n\tspi_set_drvdata(spi, achc);\n\tachc->main = spi;\n\n\tmutex_init(&achc->device_lock);\n\n\tret = of_property_read_u32_index(spi->dev.of_node, \"reg\", 1, &ezport_reg);\n\tif (ret)\n\t\treturn dev_err_probe(&spi->dev, ret, \"missing second reg entry!\\n\");\n\n\tachc->ezport = spi_new_ancillary_device(spi, ezport_reg);\n\tif (IS_ERR(achc->ezport))\n\t\treturn PTR_ERR(achc->ezport);\n\n\tret = devm_add_action_or_reset(&spi->dev, unregister_ezport, achc->ezport);\n\tif (ret)\n\t\treturn ret;\n\n\tachc->reset = devm_gpiod_get(&spi->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(achc->reset))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(achc->reset), \"Could not get reset gpio\\n\");\n\n\treturn 0;\n}\n\nstatic const struct spi_device_id gehc_achc_id[] = {\n\t{ \"ge,achc\", 0 },\n\t{ \"achc\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, gehc_achc_id);\n\nstatic const struct of_device_id gehc_achc_of_match[] = {\n\t{ .compatible = \"ge,achc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, gehc_achc_of_match);\n\nstatic struct spi_driver gehc_achc_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"gehc-achc\",\n\t\t.of_match_table = gehc_achc_of_match,\n\t\t.dev_groups = gehc_achc_groups,\n\t},\n\t.probe\t\t= gehc_achc_probe,\n\t.id_table\t= gehc_achc_id,\n};\nmodule_spi_driver(gehc_achc_spi_driver);\n\nMODULE_DESCRIPTION(\"GEHC ACHC driver\");\nMODULE_AUTHOR(\"Sebastian Reichel <sebastian.reichel@collabora.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}