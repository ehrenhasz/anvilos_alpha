{
  "module_name": "vmci_datagram.c",
  "hash_id": "585f81e7fb7210a6100c6703e6ad940cd7700460b0405a1f1c674230b3936a68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/vmw_vmci/vmci_datagram.c",
  "human_readable_source": "\n \n\n#include <linux/vmw_vmci_defs.h>\n#include <linux/vmw_vmci_api.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/bug.h>\n\n#include \"vmci_datagram.h\"\n#include \"vmci_resource.h\"\n#include \"vmci_context.h\"\n#include \"vmci_driver.h\"\n#include \"vmci_event.h\"\n#include \"vmci_route.h\"\n\n \nstruct datagram_entry {\n\tstruct vmci_resource resource;\n\tu32 flags;\n\tbool run_delayed;\n\tvmci_datagram_recv_cb recv_cb;\n\tvoid *client_data;\n\tu32 priv_flags;\n};\n\nstruct delayed_datagram_info {\n\tstruct datagram_entry *entry;\n\tstruct work_struct work;\n\tbool in_dg_host_queue;\n\t \n\tstruct vmci_datagram msg;\n\tu8 msg_payload[];\n};\n\n \nstatic atomic_t delayed_dg_host_queue_size = ATOMIC_INIT(0);\n\n \nstatic int dg_create_handle(u32 resource_id,\n\t\t\t    u32 flags,\n\t\t\t    u32 priv_flags,\n\t\t\t    vmci_datagram_recv_cb recv_cb,\n\t\t\t    void *client_data, struct vmci_handle *out_handle)\n{\n\tint result;\n\tu32 context_id;\n\tstruct vmci_handle handle;\n\tstruct datagram_entry *entry;\n\n\tif ((flags & VMCI_FLAG_WELLKNOWN_DG_HND) != 0)\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tif ((flags & VMCI_FLAG_ANYCID_DG_HND) != 0) {\n\t\tcontext_id = VMCI_INVALID_ID;\n\t} else {\n\t\tcontext_id = vmci_get_context_id();\n\t\tif (context_id == VMCI_INVALID_ID)\n\t\t\treturn VMCI_ERROR_NO_RESOURCES;\n\t}\n\n\thandle = vmci_make_handle(context_id, resource_id);\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tpr_warn(\"Failed allocating memory for datagram entry\\n\");\n\t\treturn VMCI_ERROR_NO_MEM;\n\t}\n\n\tentry->run_delayed = (flags & VMCI_FLAG_DG_DELAYED_CB) ? true : false;\n\tentry->flags = flags;\n\tentry->recv_cb = recv_cb;\n\tentry->client_data = client_data;\n\tentry->priv_flags = priv_flags;\n\n\t \n\tresult = vmci_resource_add(&entry->resource,\n\t\t\t\t   VMCI_RESOURCE_TYPE_DATAGRAM,\n\t\t\t\t   handle);\n\tif (result != VMCI_SUCCESS) {\n\t\tpr_warn(\"Failed to add new resource (handle=0x%x:0x%x), error: %d\\n\",\n\t\t\thandle.context, handle.resource, result);\n\t\tkfree(entry);\n\t\treturn result;\n\t}\n\n\t*out_handle = vmci_resource_handle(&entry->resource);\n\treturn VMCI_SUCCESS;\n}\n\n \nstatic int vmci_datagram_get_priv_flags(u32 context_id,\n\t\t\t\t\tstruct vmci_handle handle,\n\t\t\t\t\tu32 *priv_flags)\n{\n\tif (context_id == VMCI_INVALID_ID)\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tif (context_id == VMCI_HOST_CONTEXT_ID) {\n\t\tstruct datagram_entry *src_entry;\n\t\tstruct vmci_resource *resource;\n\n\t\tresource = vmci_resource_by_handle(handle,\n\t\t\t\t\t\t   VMCI_RESOURCE_TYPE_DATAGRAM);\n\t\tif (!resource)\n\t\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\t\tsrc_entry = container_of(resource, struct datagram_entry,\n\t\t\t\t\t resource);\n\t\t*priv_flags = src_entry->priv_flags;\n\t\tvmci_resource_put(resource);\n\t} else if (context_id == VMCI_HYPERVISOR_CONTEXT_ID)\n\t\t*priv_flags = VMCI_MAX_PRIVILEGE_FLAGS;\n\telse\n\t\t*priv_flags = vmci_context_get_priv_flags(context_id);\n\n\treturn VMCI_SUCCESS;\n}\n\n \nstatic void dg_delayed_dispatch(struct work_struct *work)\n{\n\tstruct delayed_datagram_info *dg_info =\n\t\t\tcontainer_of(work, struct delayed_datagram_info, work);\n\n\tdg_info->entry->recv_cb(dg_info->entry->client_data, &dg_info->msg);\n\n\tvmci_resource_put(&dg_info->entry->resource);\n\n\tif (dg_info->in_dg_host_queue)\n\t\tatomic_dec(&delayed_dg_host_queue_size);\n\n\tkfree(dg_info);\n}\n\n \nstatic int dg_dispatch_as_host(u32 context_id, struct vmci_datagram *dg)\n{\n\tint retval;\n\tsize_t dg_size;\n\tu32 src_priv_flags;\n\n\tdg_size = VMCI_DG_SIZE(dg);\n\n\t \n\tif (dg->dst.context == VMCI_HYPERVISOR_CONTEXT_ID)\n\t\treturn VMCI_ERROR_DST_UNREACHABLE;\n\n\t \n\tif (dg->src.context != context_id) {\n\t\tpr_devel(\"Sender context (ID=0x%x) is not owner of src datagram entry (handle=0x%x:0x%x)\\n\",\n\t\t\t context_id, dg->src.context, dg->src.resource);\n\t\treturn VMCI_ERROR_NO_ACCESS;\n\t}\n\n\t \n\tretval = vmci_datagram_get_priv_flags(context_id, dg->src,\n\t\t\t\t\t      &src_priv_flags);\n\tif (retval != VMCI_SUCCESS) {\n\t\tpr_warn(\"Couldn't get privileges (handle=0x%x:0x%x)\\n\",\n\t\t\tdg->src.context, dg->src.resource);\n\t\treturn retval;\n\t}\n\n\t \n\tif (dg->dst.context == VMCI_HOST_CONTEXT_ID) {\n\t\t \n\t\tstruct datagram_entry *dst_entry;\n\t\tstruct vmci_resource *resource;\n\n\t\tif (dg->src.context == VMCI_HYPERVISOR_CONTEXT_ID &&\n\t\t    dg->dst.resource == VMCI_EVENT_HANDLER) {\n\t\t\treturn vmci_event_dispatch(dg);\n\t\t}\n\n\t\tresource = vmci_resource_by_handle(dg->dst,\n\t\t\t\t\t\t   VMCI_RESOURCE_TYPE_DATAGRAM);\n\t\tif (!resource) {\n\t\t\tpr_devel(\"Sending to invalid destination (handle=0x%x:0x%x)\\n\",\n\t\t\t\t dg->dst.context, dg->dst.resource);\n\t\t\treturn VMCI_ERROR_INVALID_RESOURCE;\n\t\t}\n\t\tdst_entry = container_of(resource, struct datagram_entry,\n\t\t\t\t\t resource);\n\t\tif (vmci_deny_interaction(src_priv_flags,\n\t\t\t\t\t  dst_entry->priv_flags)) {\n\t\t\tvmci_resource_put(resource);\n\t\t\treturn VMCI_ERROR_NO_ACCESS;\n\t\t}\n\n\t\t \n\t\tif (dst_entry->run_delayed ||\n\t\t    dg->src.context == VMCI_HOST_CONTEXT_ID) {\n\t\t\tstruct delayed_datagram_info *dg_info;\n\n\t\t\tif (atomic_add_return(1, &delayed_dg_host_queue_size)\n\t\t\t    == VMCI_MAX_DELAYED_DG_HOST_QUEUE_SIZE) {\n\t\t\t\tatomic_dec(&delayed_dg_host_queue_size);\n\t\t\t\tvmci_resource_put(resource);\n\t\t\t\treturn VMCI_ERROR_NO_MEM;\n\t\t\t}\n\n\t\t\tdg_info = kmalloc(sizeof(*dg_info) +\n\t\t\t\t    (size_t) dg->payload_size, GFP_ATOMIC);\n\t\t\tif (!dg_info) {\n\t\t\t\tatomic_dec(&delayed_dg_host_queue_size);\n\t\t\t\tvmci_resource_put(resource);\n\t\t\t\treturn VMCI_ERROR_NO_MEM;\n\t\t\t}\n\n\t\t\tdg_info->in_dg_host_queue = true;\n\t\t\tdg_info->entry = dst_entry;\n\t\t\tmemcpy(&dg_info->msg, dg, dg_size);\n\n\t\t\tINIT_WORK(&dg_info->work, dg_delayed_dispatch);\n\t\t\tschedule_work(&dg_info->work);\n\t\t\tretval = VMCI_SUCCESS;\n\n\t\t} else {\n\t\t\tretval = dst_entry->recv_cb(dst_entry->client_data, dg);\n\t\t\tvmci_resource_put(resource);\n\t\t\tif (retval < VMCI_SUCCESS)\n\t\t\t\treturn retval;\n\t\t}\n\t} else {\n\t\t \n\t\tstruct vmci_datagram *new_dg;\n\n\t\tif (context_id != dg->dst.context) {\n\t\t\tif (vmci_deny_interaction(src_priv_flags,\n\t\t\t\t\t\t  vmci_context_get_priv_flags\n\t\t\t\t\t\t  (dg->dst.context))) {\n\t\t\t\treturn VMCI_ERROR_NO_ACCESS;\n\t\t\t} else if (VMCI_CONTEXT_IS_VM(context_id)) {\n\t\t\t\t \n\n\t\t\t\tpr_devel(\"Datagram communication between VMs not supported (src=0x%x, dst=0x%x)\\n\",\n\t\t\t\t\t context_id, dg->dst.context);\n\t\t\t\treturn VMCI_ERROR_DST_UNREACHABLE;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tnew_dg = kmemdup(dg, dg_size, GFP_KERNEL);\n\t\tif (new_dg == NULL)\n\t\t\treturn VMCI_ERROR_NO_MEM;\n\n\t\tretval = vmci_ctx_enqueue_datagram(dg->dst.context, new_dg);\n\t\tif (retval < VMCI_SUCCESS) {\n\t\t\tkfree(new_dg);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\t \n\treturn (int)dg_size;\n}\n\n \nstatic int dg_dispatch_as_guest(struct vmci_datagram *dg)\n{\n\tint retval;\n\tstruct vmci_resource *resource;\n\n\tresource = vmci_resource_by_handle(dg->src,\n\t\t\t\t\t   VMCI_RESOURCE_TYPE_DATAGRAM);\n\tif (!resource)\n\t\treturn VMCI_ERROR_NO_HANDLE;\n\n\tretval = vmci_send_datagram(dg);\n\tvmci_resource_put(resource);\n\treturn retval;\n}\n\n \nint vmci_datagram_dispatch(u32 context_id,\n\t\t\t   struct vmci_datagram *dg, bool from_guest)\n{\n\tint retval;\n\tenum vmci_route route;\n\n\tBUILD_BUG_ON(sizeof(struct vmci_datagram) != 24);\n\n\tif (dg->payload_size > VMCI_MAX_DG_SIZE ||\n\t    VMCI_DG_SIZE(dg) > VMCI_MAX_DG_SIZE) {\n\t\tpr_devel(\"Payload (size=%llu bytes) too big to send\\n\",\n\t\t\t (unsigned long long)dg->payload_size);\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\t}\n\n\tretval = vmci_route(&dg->src, &dg->dst, from_guest, &route);\n\tif (retval < VMCI_SUCCESS) {\n\t\tpr_devel(\"Failed to route datagram (src=0x%x, dst=0x%x, err=%d)\\n\",\n\t\t\t dg->src.context, dg->dst.context, retval);\n\t\treturn retval;\n\t}\n\n\tif (VMCI_ROUTE_AS_HOST == route) {\n\t\tif (VMCI_INVALID_ID == context_id)\n\t\t\tcontext_id = VMCI_HOST_CONTEXT_ID;\n\t\treturn dg_dispatch_as_host(context_id, dg);\n\t}\n\n\tif (VMCI_ROUTE_AS_GUEST == route)\n\t\treturn dg_dispatch_as_guest(dg);\n\n\tpr_warn(\"Unknown route (%d) for datagram\\n\", route);\n\treturn VMCI_ERROR_DST_UNREACHABLE;\n}\n\n \nint vmci_datagram_invoke_guest_handler(struct vmci_datagram *dg)\n{\n\tstruct vmci_resource *resource;\n\tstruct datagram_entry *dst_entry;\n\n\tresource = vmci_resource_by_handle(dg->dst,\n\t\t\t\t\t   VMCI_RESOURCE_TYPE_DATAGRAM);\n\tif (!resource) {\n\t\tpr_devel(\"destination (handle=0x%x:0x%x) doesn't exist\\n\",\n\t\t\t dg->dst.context, dg->dst.resource);\n\t\treturn VMCI_ERROR_NO_HANDLE;\n\t}\n\n\tdst_entry = container_of(resource, struct datagram_entry, resource);\n\tif (dst_entry->run_delayed) {\n\t\tstruct delayed_datagram_info *dg_info;\n\n\t\tdg_info = kmalloc(sizeof(*dg_info) + (size_t)dg->payload_size,\n\t\t\t\t  GFP_ATOMIC);\n\t\tif (!dg_info) {\n\t\t\tvmci_resource_put(resource);\n\t\t\treturn VMCI_ERROR_NO_MEM;\n\t\t}\n\n\t\tdg_info->in_dg_host_queue = false;\n\t\tdg_info->entry = dst_entry;\n\t\tmemcpy(&dg_info->msg, dg, VMCI_DG_SIZE(dg));\n\n\t\tINIT_WORK(&dg_info->work, dg_delayed_dispatch);\n\t\tschedule_work(&dg_info->work);\n\t} else {\n\t\tdst_entry->recv_cb(dst_entry->client_data, dg);\n\t\tvmci_resource_put(resource);\n\t}\n\n\treturn VMCI_SUCCESS;\n}\n\n \nint vmci_datagram_create_handle_priv(u32 resource_id,\n\t\t\t\t     u32 flags,\n\t\t\t\t     u32 priv_flags,\n\t\t\t\t     vmci_datagram_recv_cb recv_cb,\n\t\t\t\t     void *client_data,\n\t\t\t\t     struct vmci_handle *out_handle)\n{\n\tif (out_handle == NULL)\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tif (recv_cb == NULL) {\n\t\tpr_devel(\"Client callback needed when creating datagram\\n\");\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\t}\n\n\tif (priv_flags & ~VMCI_PRIVILEGE_ALL_FLAGS)\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\treturn dg_create_handle(resource_id, flags, priv_flags, recv_cb,\n\t\t\t\tclient_data, out_handle);\n}\nEXPORT_SYMBOL_GPL(vmci_datagram_create_handle_priv);\n\n \nint vmci_datagram_create_handle(u32 resource_id,\n\t\t\t\tu32 flags,\n\t\t\t\tvmci_datagram_recv_cb recv_cb,\n\t\t\t\tvoid *client_data,\n\t\t\t\tstruct vmci_handle *out_handle)\n{\n\treturn vmci_datagram_create_handle_priv(\n\t\tresource_id, flags,\n\t\tVMCI_DEFAULT_PROC_PRIVILEGE_FLAGS,\n\t\trecv_cb, client_data,\n\t\tout_handle);\n}\nEXPORT_SYMBOL_GPL(vmci_datagram_create_handle);\n\n \nint vmci_datagram_destroy_handle(struct vmci_handle handle)\n{\n\tstruct datagram_entry *entry;\n\tstruct vmci_resource *resource;\n\n\tresource = vmci_resource_by_handle(handle, VMCI_RESOURCE_TYPE_DATAGRAM);\n\tif (!resource) {\n\t\tpr_devel(\"Failed to destroy datagram (handle=0x%x:0x%x)\\n\",\n\t\t\t handle.context, handle.resource);\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\t}\n\n\tentry = container_of(resource, struct datagram_entry, resource);\n\n\tvmci_resource_put(&entry->resource);\n\tvmci_resource_remove(&entry->resource);\n\tkfree(entry);\n\n\treturn VMCI_SUCCESS;\n}\nEXPORT_SYMBOL_GPL(vmci_datagram_destroy_handle);\n\n \nint vmci_datagram_send(struct vmci_datagram *msg)\n{\n\tif (msg == NULL)\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\treturn vmci_datagram_dispatch(VMCI_INVALID_ID, msg, false);\n}\nEXPORT_SYMBOL_GPL(vmci_datagram_send);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}