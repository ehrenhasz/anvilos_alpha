{
  "module_name": "vmci_queue_pair.h",
  "hash_id": "0bd1bb7063e4af1d5eb682024654d2eaee796ac3a570e08070a73149919a2f41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/vmw_vmci/vmci_queue_pair.h",
  "human_readable_source": " \n \n\n#ifndef _VMCI_QUEUE_PAIR_H_\n#define _VMCI_QUEUE_PAIR_H_\n\n#include <linux/vmw_vmci_defs.h>\n#include <linux/types.h>\n\n#include \"vmci_context.h\"\n\n \ntypedef int (*vmci_event_release_cb) (void *client_data);\n\n \nstruct ppn_set {\n\tu64 num_produce_pages;\n\tu64 num_consume_pages;\n\tu64 *produce_ppns;\n\tu64 *consume_ppns;\n\tbool initialized;\n};\n\n \nstruct vmci_qp_alloc_info {\n\tstruct vmci_handle handle;\n\tu32 peer;\n\tu32 flags;\n\tu64 produce_size;\n\tu64 consume_size;\n\tu64 ppn_va;\t \n\tu64 num_ppns;\n\ts32 result;\n\tu32 version;\n};\n\n \nstruct vmci_qp_set_va_info {\n\tstruct vmci_handle handle;\n\tu64 va;\t\t \n\tu64 num_ppns;\n\tu32 version;\n\ts32 result;\n};\n\n \n\n \nstruct vmci_qp_page_file_info {\n\tstruct vmci_handle handle;\n\tu64 produce_page_file;\t   \n\tu64 consume_page_file;\t   \n\tu64 produce_page_file_size;   \n\tu64 consume_page_file_size;   \n\ts32 result;\n\tu32 version;\t \n\tu64 produce_va;\t \n\tu64 consume_va;\t \n};\n\n \nstruct vmci_qp_dtch_info {\n\tstruct vmci_handle handle;\n\ts32 result;\n\tu32 _pad;\n};\n\n \nstruct vmci_qp_page_store {\n\t \n\tu64 pages;\n\t \n\tu32 len;\n};\n\n \nstruct vmci_queue {\n\tstruct vmci_queue_header *q_header;\n\tstruct vmci_queue_header *saved_header;\n\tstruct vmci_queue_kern_if *kernel_if;\n};\n\n \nstatic inline bool\nVMCI_QP_PAGESTORE_IS_WELLFORMED(struct vmci_qp_page_store *page_store)\n{\n\treturn page_store->len >= 2;\n}\n\nvoid vmci_qp_broker_exit(void);\nint vmci_qp_broker_alloc(struct vmci_handle handle, u32 peer,\n\t\t\t u32 flags, u32 priv_flags,\n\t\t\t u64 produce_size, u64 consume_size,\n\t\t\t struct vmci_qp_page_store *page_store,\n\t\t\t struct vmci_ctx *context);\nint vmci_qp_broker_set_page_store(struct vmci_handle handle,\n\t\t\t\t  u64 produce_uva, u64 consume_uva,\n\t\t\t\t  struct vmci_ctx *context);\nint vmci_qp_broker_detach(struct vmci_handle handle, struct vmci_ctx *context);\n\nvoid vmci_qp_guest_endpoints_exit(void);\n\nint vmci_qp_alloc(struct vmci_handle *handle,\n\t\t  struct vmci_queue **produce_q, u64 produce_size,\n\t\t  struct vmci_queue **consume_q, u64 consume_size,\n\t\t  u32 peer, u32 flags, u32 priv_flags,\n\t\t  bool guest_endpoint, vmci_event_release_cb wakeup_cb,\n\t\t  void *client_data);\nint vmci_qp_broker_map(struct vmci_handle handle,\n\t\t       struct vmci_ctx *context, u64 guest_mem);\nint vmci_qp_broker_unmap(struct vmci_handle handle,\n\t\t\t struct vmci_ctx *context, u32 gid);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}