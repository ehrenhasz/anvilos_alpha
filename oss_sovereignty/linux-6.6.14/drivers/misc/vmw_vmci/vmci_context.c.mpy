{
  "module_name": "vmci_context.c",
  "hash_id": "cf5598b934f4d992114acaed6fc3cee7726ec042f338e2da2b0496540b2f20bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/vmw_vmci/vmci_context.c",
  "human_readable_source": "\n \n\n#include <linux/vmw_vmci_defs.h>\n#include <linux/vmw_vmci_api.h>\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n\n#include \"vmci_queue_pair.h\"\n#include \"vmci_datagram.h\"\n#include \"vmci_doorbell.h\"\n#include \"vmci_context.h\"\n#include \"vmci_driver.h\"\n#include \"vmci_event.h\"\n\n \n#define VMCI_MAX_CONTEXTS 2000\n\n \nstatic struct {\n\tstruct list_head head;\n\tspinlock_t lock;  \n} ctx_list = {\n\t.head = LIST_HEAD_INIT(ctx_list.head),\n\t.lock = __SPIN_LOCK_UNLOCKED(ctx_list.lock),\n};\n\n \nstatic bool ctx_dummy_notify;\n\nstatic void ctx_signal_notify(struct vmci_ctx *context)\n{\n\t*context->notify = true;\n}\n\nstatic void ctx_clear_notify(struct vmci_ctx *context)\n{\n\t*context->notify = false;\n}\n\n \nstatic void ctx_clear_notify_call(struct vmci_ctx *context)\n{\n\tif (context->pending_datagrams == 0 &&\n\t    vmci_handle_arr_get_size(context->pending_doorbell_array) == 0)\n\t\tctx_clear_notify(context);\n}\n\n \nvoid vmci_ctx_check_signal_notify(struct vmci_ctx *context)\n{\n\tspin_lock(&context->lock);\n\tif (context->pending_datagrams)\n\t\tctx_signal_notify(context);\n\tspin_unlock(&context->lock);\n}\n\n \nstruct vmci_ctx *vmci_ctx_create(u32 cid, u32 priv_flags,\n\t\t\t\t uintptr_t event_hnd,\n\t\t\t\t int user_version,\n\t\t\t\t const struct cred *cred)\n{\n\tstruct vmci_ctx *context;\n\tint error;\n\n\tif (cid == VMCI_INVALID_ID) {\n\t\tpr_devel(\"Invalid context ID for VMCI context\\n\");\n\t\terror = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (priv_flags & ~VMCI_PRIVILEGE_ALL_FLAGS) {\n\t\tpr_devel(\"Invalid flag (flags=0x%x) for VMCI context\\n\",\n\t\t\t priv_flags);\n\t\terror = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (user_version == 0) {\n\t\tpr_devel(\"Invalid suer_version %d\\n\", user_version);\n\t\terror = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context) {\n\t\tpr_warn(\"Failed to allocate memory for VMCI context\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tkref_init(&context->kref);\n\tspin_lock_init(&context->lock);\n\tINIT_LIST_HEAD(&context->list_item);\n\tINIT_LIST_HEAD(&context->datagram_queue);\n\tINIT_LIST_HEAD(&context->notifier_list);\n\n\t \n\tinit_waitqueue_head(&context->host_context.wait_queue);\n\n\tcontext->queue_pair_array =\n\t\tvmci_handle_arr_create(0, VMCI_MAX_GUEST_QP_COUNT);\n\tif (!context->queue_pair_array) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_ctx;\n\t}\n\n\tcontext->doorbell_array =\n\t\tvmci_handle_arr_create(0, VMCI_MAX_GUEST_DOORBELL_COUNT);\n\tif (!context->doorbell_array) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_qp_array;\n\t}\n\n\tcontext->pending_doorbell_array =\n\t\tvmci_handle_arr_create(0, VMCI_MAX_GUEST_DOORBELL_COUNT);\n\tif (!context->pending_doorbell_array) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_db_array;\n\t}\n\n\tcontext->user_version = user_version;\n\n\tcontext->priv_flags = priv_flags;\n\n\tif (cred)\n\t\tcontext->cred = get_cred(cred);\n\n\tcontext->notify = &ctx_dummy_notify;\n\tcontext->notify_page = NULL;\n\n\t \n\tspin_lock(&ctx_list.lock);\n\n\twhile (vmci_ctx_exists(cid)) {\n\t\t \n\t\tcid = max(cid, VMCI_RESERVED_CID_LIMIT - 1) + 1;\n\t\tif (cid == VMCI_INVALID_ID)\n\t\t\tcid = VMCI_RESERVED_CID_LIMIT;\n\t}\n\tcontext->cid = cid;\n\n\tlist_add_tail_rcu(&context->list_item, &ctx_list.head);\n\tspin_unlock(&ctx_list.lock);\n\n\treturn context;\n\n err_free_db_array:\n\tvmci_handle_arr_destroy(context->doorbell_array);\n err_free_qp_array:\n\tvmci_handle_arr_destroy(context->queue_pair_array);\n err_free_ctx:\n\tkfree(context);\n err_out:\n\treturn ERR_PTR(error);\n}\n\n \nvoid vmci_ctx_destroy(struct vmci_ctx *context)\n{\n\tspin_lock(&ctx_list.lock);\n\tlist_del_rcu(&context->list_item);\n\tspin_unlock(&ctx_list.lock);\n\tsynchronize_rcu();\n\n\tvmci_ctx_put(context);\n}\n\n \nstatic int ctx_fire_notification(u32 context_id, u32 priv_flags)\n{\n\tu32 i, array_size;\n\tstruct vmci_ctx *sub_ctx;\n\tstruct vmci_handle_arr *subscriber_array;\n\tstruct vmci_handle context_handle =\n\t\tvmci_make_handle(context_id, VMCI_EVENT_HANDLER);\n\n\t \n\tsubscriber_array = vmci_handle_arr_create(0, VMCI_MAX_CONTEXTS);\n\tif (subscriber_array == NULL)\n\t\treturn VMCI_ERROR_NO_MEM;\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sub_ctx, &ctx_list.head, list_item) {\n\t\tstruct vmci_handle_list *node;\n\n\t\t \n\t\tif (vmci_deny_interaction(priv_flags, sub_ctx->priv_flags))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_rcu(node, &sub_ctx->notifier_list, node) {\n\t\t\tif (!vmci_handle_is_equal(node->handle, context_handle))\n\t\t\t\tcontinue;\n\n\t\t\tvmci_handle_arr_append_entry(&subscriber_array,\n\t\t\t\t\tvmci_make_handle(sub_ctx->cid,\n\t\t\t\t\t\t\t VMCI_EVENT_HANDLER));\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t \n\tarray_size = vmci_handle_arr_get_size(subscriber_array);\n\tfor (i = 0; i < array_size; i++) {\n\t\tint result;\n\t\tstruct vmci_event_ctx ev;\n\n\t\tev.msg.hdr.dst = vmci_handle_arr_get_entry(subscriber_array, i);\n\t\tev.msg.hdr.src = vmci_make_handle(VMCI_HYPERVISOR_CONTEXT_ID,\n\t\t\t\t\t\t  VMCI_CONTEXT_RESOURCE_ID);\n\t\tev.msg.hdr.payload_size = sizeof(ev) - sizeof(ev.msg.hdr);\n\t\tev.msg.event_data.event = VMCI_EVENT_CTX_REMOVED;\n\t\tev.payload.context_id = context_id;\n\n\t\tresult = vmci_datagram_dispatch(VMCI_HYPERVISOR_CONTEXT_ID,\n\t\t\t\t\t\t&ev.msg.hdr, false);\n\t\tif (result < VMCI_SUCCESS) {\n\t\t\tpr_devel(\"Failed to enqueue event datagram (type=%d) for context (ID=0x%x)\\n\",\n\t\t\t\t ev.msg.event_data.event,\n\t\t\t\t ev.msg.hdr.dst.context);\n\t\t\t \n\t\t}\n\t}\n\tvmci_handle_arr_destroy(subscriber_array);\n\n\treturn VMCI_SUCCESS;\n}\n\n \nint vmci_ctx_pending_datagrams(u32 cid, u32 *pending)\n{\n\tstruct vmci_ctx *context;\n\n\tcontext = vmci_ctx_get(cid);\n\tif (context == NULL)\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tspin_lock(&context->lock);\n\tif (pending)\n\t\t*pending = context->pending_datagrams;\n\tspin_unlock(&context->lock);\n\tvmci_ctx_put(context);\n\n\treturn VMCI_SUCCESS;\n}\n\n \nint vmci_ctx_enqueue_datagram(u32 cid, struct vmci_datagram *dg)\n{\n\tstruct vmci_datagram_queue_entry *dq_entry;\n\tstruct vmci_ctx *context;\n\tstruct vmci_handle dg_src;\n\tsize_t vmci_dg_size;\n\n\tvmci_dg_size = VMCI_DG_SIZE(dg);\n\tif (vmci_dg_size > VMCI_MAX_DG_SIZE) {\n\t\tpr_devel(\"Datagram too large (bytes=%zu)\\n\", vmci_dg_size);\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\t}\n\n\t \n\tcontext = vmci_ctx_get(cid);\n\tif (!context) {\n\t\tpr_devel(\"Invalid context (ID=0x%x)\\n\", cid);\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\t}\n\n\t \n\tdq_entry = kmalloc(sizeof(*dq_entry), GFP_KERNEL);\n\tif (dq_entry == NULL) {\n\t\tpr_warn(\"Failed to allocate memory for datagram\\n\");\n\t\tvmci_ctx_put(context);\n\t\treturn VMCI_ERROR_NO_MEM;\n\t}\n\tdq_entry->dg = dg;\n\tdq_entry->dg_size = vmci_dg_size;\n\tdg_src = dg->src;\n\tINIT_LIST_HEAD(&dq_entry->list_item);\n\n\tspin_lock(&context->lock);\n\n\t \n\tif (context->datagram_queue_size + vmci_dg_size >=\n\t    VMCI_MAX_DATAGRAM_QUEUE_SIZE &&\n\t    (!vmci_handle_is_equal(dg_src,\n\t\t\t\tvmci_make_handle\n\t\t\t\t(VMCI_HYPERVISOR_CONTEXT_ID,\n\t\t\t\t VMCI_CONTEXT_RESOURCE_ID)) ||\n\t     context->datagram_queue_size + vmci_dg_size >=\n\t     VMCI_MAX_DATAGRAM_AND_EVENT_QUEUE_SIZE)) {\n\t\tspin_unlock(&context->lock);\n\t\tvmci_ctx_put(context);\n\t\tkfree(dq_entry);\n\t\tpr_devel(\"Context (ID=0x%x) receive queue is full\\n\", cid);\n\t\treturn VMCI_ERROR_NO_RESOURCES;\n\t}\n\n\tlist_add(&dq_entry->list_item, &context->datagram_queue);\n\tcontext->pending_datagrams++;\n\tcontext->datagram_queue_size += vmci_dg_size;\n\tctx_signal_notify(context);\n\twake_up(&context->host_context.wait_queue);\n\tspin_unlock(&context->lock);\n\tvmci_ctx_put(context);\n\n\treturn vmci_dg_size;\n}\n\n \nbool vmci_ctx_exists(u32 cid)\n{\n\tstruct vmci_ctx *context;\n\tbool exists = false;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(context, &ctx_list.head, list_item) {\n\t\tif (context->cid == cid) {\n\t\t\texists = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn exists;\n}\n\n \nstruct vmci_ctx *vmci_ctx_get(u32 cid)\n{\n\tstruct vmci_ctx *c, *context = NULL;\n\n\tif (cid == VMCI_INVALID_ID)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(c, &ctx_list.head, list_item) {\n\t\tif (c->cid == cid) {\n\t\t\t \n\t\t\tcontext = c;\n\t\t\tkref_get(&context->kref);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn context;\n}\n\n \nstatic void ctx_free_ctx(struct kref *kref)\n{\n\tstruct vmci_ctx *context = container_of(kref, struct vmci_ctx, kref);\n\tstruct vmci_datagram_queue_entry *dq_entry, *dq_entry_tmp;\n\tstruct vmci_handle temp_handle;\n\tstruct vmci_handle_list *notifier, *tmp;\n\n\t \n\tctx_fire_notification(context->cid, context->priv_flags);\n\n\t \n\ttemp_handle = vmci_handle_arr_get_entry(context->queue_pair_array, 0);\n\twhile (!vmci_handle_is_equal(temp_handle, VMCI_INVALID_HANDLE)) {\n\t\tif (vmci_qp_broker_detach(temp_handle,\n\t\t\t\t\t  context) < VMCI_SUCCESS) {\n\t\t\t \n\t\t\tvmci_handle_arr_remove_entry(context->queue_pair_array,\n\t\t\t\t\t\t     temp_handle);\n\t\t}\n\t\ttemp_handle =\n\t\t    vmci_handle_arr_get_entry(context->queue_pair_array, 0);\n\t}\n\n\t \n\tlist_for_each_entry_safe(dq_entry, dq_entry_tmp,\n\t\t\t\t &context->datagram_queue, list_item) {\n\t\tWARN_ON(dq_entry->dg_size != VMCI_DG_SIZE(dq_entry->dg));\n\t\tlist_del(&dq_entry->list_item);\n\t\tkfree(dq_entry->dg);\n\t\tkfree(dq_entry);\n\t}\n\n\tlist_for_each_entry_safe(notifier, tmp,\n\t\t\t\t &context->notifier_list, node) {\n\t\tlist_del(&notifier->node);\n\t\tkfree(notifier);\n\t}\n\n\tvmci_handle_arr_destroy(context->queue_pair_array);\n\tvmci_handle_arr_destroy(context->doorbell_array);\n\tvmci_handle_arr_destroy(context->pending_doorbell_array);\n\tvmci_ctx_unset_notify(context);\n\tif (context->cred)\n\t\tput_cred(context->cred);\n\tkfree(context);\n}\n\n \nvoid vmci_ctx_put(struct vmci_ctx *context)\n{\n\tkref_put(&context->kref, ctx_free_ctx);\n}\n\n \nint vmci_ctx_dequeue_datagram(struct vmci_ctx *context,\n\t\t\t      size_t *max_size,\n\t\t\t      struct vmci_datagram **dg)\n{\n\tstruct vmci_datagram_queue_entry *dq_entry;\n\tstruct list_head *list_item;\n\tint rv;\n\n\t \n\tspin_lock(&context->lock);\n\tif (context->pending_datagrams == 0) {\n\t\tctx_clear_notify_call(context);\n\t\tspin_unlock(&context->lock);\n\t\tpr_devel(\"No datagrams pending\\n\");\n\t\treturn VMCI_ERROR_NO_MORE_DATAGRAMS;\n\t}\n\n\tlist_item = context->datagram_queue.next;\n\n\tdq_entry =\n\t    list_entry(list_item, struct vmci_datagram_queue_entry, list_item);\n\n\t \n\tif (*max_size < dq_entry->dg_size) {\n\t\t*max_size = dq_entry->dg_size;\n\t\tspin_unlock(&context->lock);\n\t\tpr_devel(\"Caller's buffer should be at least (size=%u bytes)\\n\",\n\t\t\t (u32) *max_size);\n\t\treturn VMCI_ERROR_NO_MEM;\n\t}\n\n\tlist_del(list_item);\n\tcontext->pending_datagrams--;\n\tcontext->datagram_queue_size -= dq_entry->dg_size;\n\tif (context->pending_datagrams == 0) {\n\t\tctx_clear_notify_call(context);\n\t\trv = VMCI_SUCCESS;\n\t} else {\n\t\t \n\t\tstruct vmci_datagram_queue_entry *next_entry;\n\n\t\tlist_item = context->datagram_queue.next;\n\t\tnext_entry =\n\t\t    list_entry(list_item, struct vmci_datagram_queue_entry,\n\t\t\t       list_item);\n\n\t\t \n\t\trv = (int)next_entry->dg_size;\n\t}\n\tspin_unlock(&context->lock);\n\n\t \n\t*dg = dq_entry->dg;\n\tdq_entry->dg = NULL;\n\tkfree(dq_entry);\n\n\treturn rv;\n}\n\n \nvoid vmci_ctx_unset_notify(struct vmci_ctx *context)\n{\n\tstruct page *notify_page;\n\n\tspin_lock(&context->lock);\n\n\tnotify_page = context->notify_page;\n\tcontext->notify = &ctx_dummy_notify;\n\tcontext->notify_page = NULL;\n\n\tspin_unlock(&context->lock);\n\n\tif (notify_page) {\n\t\tkunmap(notify_page);\n\t\tput_page(notify_page);\n\t}\n}\n\n \nint vmci_ctx_add_notification(u32 context_id, u32 remote_cid)\n{\n\tstruct vmci_ctx *context;\n\tstruct vmci_handle_list *notifier, *n;\n\tint result;\n\tbool exists = false;\n\n\tcontext = vmci_ctx_get(context_id);\n\tif (!context)\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\n\tif (VMCI_CONTEXT_IS_VM(context_id) && VMCI_CONTEXT_IS_VM(remote_cid)) {\n\t\tpr_devel(\"Context removed notifications for other VMs not supported (src=0x%x, remote=0x%x)\\n\",\n\t\t\t context_id, remote_cid);\n\t\tresult = VMCI_ERROR_DST_UNREACHABLE;\n\t\tgoto out;\n\t}\n\n\tif (context->priv_flags & VMCI_PRIVILEGE_FLAG_RESTRICTED) {\n\t\tresult = VMCI_ERROR_NO_ACCESS;\n\t\tgoto out;\n\t}\n\n\tnotifier = kmalloc(sizeof(struct vmci_handle_list), GFP_KERNEL);\n\tif (!notifier) {\n\t\tresult = VMCI_ERROR_NO_MEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&notifier->node);\n\tnotifier->handle = vmci_make_handle(remote_cid, VMCI_EVENT_HANDLER);\n\n\tspin_lock(&context->lock);\n\n\tif (context->n_notifiers < VMCI_MAX_CONTEXTS) {\n\t\tlist_for_each_entry(n, &context->notifier_list, node) {\n\t\t\tif (vmci_handle_is_equal(n->handle, notifier->handle)) {\n\t\t\t\texists = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (exists) {\n\t\t\tkfree(notifier);\n\t\t\tresult = VMCI_ERROR_ALREADY_EXISTS;\n\t\t} else {\n\t\t\tlist_add_tail_rcu(&notifier->node,\n\t\t\t\t\t  &context->notifier_list);\n\t\t\tcontext->n_notifiers++;\n\t\t\tresult = VMCI_SUCCESS;\n\t\t}\n\t} else {\n\t\tkfree(notifier);\n\t\tresult = VMCI_ERROR_NO_MEM;\n\t}\n\n\tspin_unlock(&context->lock);\n\n out:\n\tvmci_ctx_put(context);\n\treturn result;\n}\n\n \nint vmci_ctx_remove_notification(u32 context_id, u32 remote_cid)\n{\n\tstruct vmci_ctx *context;\n\tstruct vmci_handle_list *notifier = NULL, *iter, *tmp;\n\tstruct vmci_handle handle;\n\n\tcontext = vmci_ctx_get(context_id);\n\tif (!context)\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\n\thandle = vmci_make_handle(remote_cid, VMCI_EVENT_HANDLER);\n\n\tspin_lock(&context->lock);\n\tlist_for_each_entry_safe(iter, tmp,\n\t\t\t\t &context->notifier_list, node) {\n\t\tif (vmci_handle_is_equal(iter->handle, handle)) {\n\t\t\tlist_del_rcu(&iter->node);\n\t\t\tcontext->n_notifiers--;\n\t\t\tnotifier = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&context->lock);\n\n\tif (notifier)\n\t\tkvfree_rcu_mightsleep(notifier);\n\n\tvmci_ctx_put(context);\n\n\treturn notifier ? VMCI_SUCCESS : VMCI_ERROR_NOT_FOUND;\n}\n\nstatic int vmci_ctx_get_chkpt_notifiers(struct vmci_ctx *context,\n\t\t\t\t\tu32 *buf_size, void **pbuf)\n{\n\tu32 *notifiers;\n\tsize_t data_size;\n\tstruct vmci_handle_list *entry;\n\tint i = 0;\n\n\tif (context->n_notifiers == 0) {\n\t\t*buf_size = 0;\n\t\t*pbuf = NULL;\n\t\treturn VMCI_SUCCESS;\n\t}\n\n\tdata_size = context->n_notifiers * sizeof(*notifiers);\n\tif (*buf_size < data_size) {\n\t\t*buf_size = data_size;\n\t\treturn VMCI_ERROR_MORE_DATA;\n\t}\n\n\tnotifiers = kmalloc(data_size, GFP_ATOMIC);  \n\tif (!notifiers)\n\t\treturn VMCI_ERROR_NO_MEM;\n\n\tlist_for_each_entry(entry, &context->notifier_list, node)\n\t\tnotifiers[i++] = entry->handle.context;\n\n\t*buf_size = data_size;\n\t*pbuf = notifiers;\n\treturn VMCI_SUCCESS;\n}\n\nstatic int vmci_ctx_get_chkpt_doorbells(struct vmci_ctx *context,\n\t\t\t\t\tu32 *buf_size, void **pbuf)\n{\n\tstruct dbell_cpt_state *dbells;\n\tu32 i, n_doorbells;\n\n\tn_doorbells = vmci_handle_arr_get_size(context->doorbell_array);\n\tif (n_doorbells > 0) {\n\t\tsize_t data_size = n_doorbells * sizeof(*dbells);\n\t\tif (*buf_size < data_size) {\n\t\t\t*buf_size = data_size;\n\t\t\treturn VMCI_ERROR_MORE_DATA;\n\t\t}\n\n\t\tdbells = kzalloc(data_size, GFP_ATOMIC);\n\t\tif (!dbells)\n\t\t\treturn VMCI_ERROR_NO_MEM;\n\n\t\tfor (i = 0; i < n_doorbells; i++)\n\t\t\tdbells[i].handle = vmci_handle_arr_get_entry(\n\t\t\t\t\t\tcontext->doorbell_array, i);\n\n\t\t*buf_size = data_size;\n\t\t*pbuf = dbells;\n\t} else {\n\t\t*buf_size = 0;\n\t\t*pbuf = NULL;\n\t}\n\n\treturn VMCI_SUCCESS;\n}\n\n \nint vmci_ctx_get_chkpt_state(u32 context_id,\n\t\t\t     u32 cpt_type,\n\t\t\t     u32 *buf_size,\n\t\t\t     void **pbuf)\n{\n\tstruct vmci_ctx *context;\n\tint result;\n\n\tcontext = vmci_ctx_get(context_id);\n\tif (!context)\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\n\tspin_lock(&context->lock);\n\n\tswitch (cpt_type) {\n\tcase VMCI_NOTIFICATION_CPT_STATE:\n\t\tresult = vmci_ctx_get_chkpt_notifiers(context, buf_size, pbuf);\n\t\tbreak;\n\n\tcase VMCI_WELLKNOWN_CPT_STATE:\n\t\t \n\n\t\t*buf_size = 0;\n\t\t*pbuf = NULL;\n\t\tresult = VMCI_SUCCESS;\n\t\tbreak;\n\n\tcase VMCI_DOORBELL_CPT_STATE:\n\t\tresult = vmci_ctx_get_chkpt_doorbells(context, buf_size, pbuf);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_devel(\"Invalid cpt state (type=%d)\\n\", cpt_type);\n\t\tresult = VMCI_ERROR_INVALID_ARGS;\n\t\tbreak;\n\t}\n\n\tspin_unlock(&context->lock);\n\tvmci_ctx_put(context);\n\n\treturn result;\n}\n\n \nint vmci_ctx_set_chkpt_state(u32 context_id,\n\t\t\t     u32 cpt_type,\n\t\t\t     u32 buf_size,\n\t\t\t     void *cpt_buf)\n{\n\tu32 i;\n\tu32 current_id;\n\tint result = VMCI_SUCCESS;\n\tu32 num_ids = buf_size / sizeof(u32);\n\n\tif (cpt_type == VMCI_WELLKNOWN_CPT_STATE && num_ids > 0) {\n\t\t \n\t\tpr_warn(\"Attempt to restore checkpoint with obsolete wellknown handles\\n\");\n\t\treturn VMCI_ERROR_OBSOLETE;\n\t}\n\n\tif (cpt_type != VMCI_NOTIFICATION_CPT_STATE) {\n\t\tpr_devel(\"Invalid cpt state (type=%d)\\n\", cpt_type);\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\t}\n\n\tfor (i = 0; i < num_ids && result == VMCI_SUCCESS; i++) {\n\t\tcurrent_id = ((u32 *)cpt_buf)[i];\n\t\tresult = vmci_ctx_add_notification(context_id, current_id);\n\t\tif (result != VMCI_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (result != VMCI_SUCCESS)\n\t\tpr_devel(\"Failed to set cpt state (type=%d) (error=%d)\\n\",\n\t\t\t cpt_type, result);\n\n\treturn result;\n}\n\n \nint vmci_ctx_rcv_notifications_get(u32 context_id,\n\t\t\t\t   struct vmci_handle_arr **db_handle_array,\n\t\t\t\t   struct vmci_handle_arr **qp_handle_array)\n{\n\tstruct vmci_ctx *context;\n\tint result = VMCI_SUCCESS;\n\n\tcontext = vmci_ctx_get(context_id);\n\tif (context == NULL)\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\n\tspin_lock(&context->lock);\n\n\t*db_handle_array = context->pending_doorbell_array;\n\tcontext->pending_doorbell_array =\n\t\tvmci_handle_arr_create(0, VMCI_MAX_GUEST_DOORBELL_COUNT);\n\tif (!context->pending_doorbell_array) {\n\t\tcontext->pending_doorbell_array = *db_handle_array;\n\t\t*db_handle_array = NULL;\n\t\tresult = VMCI_ERROR_NO_MEM;\n\t}\n\t*qp_handle_array = NULL;\n\n\tspin_unlock(&context->lock);\n\tvmci_ctx_put(context);\n\n\treturn result;\n}\n\n \nvoid vmci_ctx_rcv_notifications_release(u32 context_id,\n\t\t\t\t\tstruct vmci_handle_arr *db_handle_array,\n\t\t\t\t\tstruct vmci_handle_arr *qp_handle_array,\n\t\t\t\t\tbool success)\n{\n\tstruct vmci_ctx *context = vmci_ctx_get(context_id);\n\n\tspin_lock(&context->lock);\n\tif (!success) {\n\t\tstruct vmci_handle handle;\n\n\t\t \n\n\t\thandle = vmci_handle_arr_remove_tail(\n\t\t\t\t\tcontext->pending_doorbell_array);\n\t\twhile (!vmci_handle_is_invalid(handle)) {\n\t\t\tif (!vmci_handle_arr_has_entry(db_handle_array,\n\t\t\t\t\t\t       handle)) {\n\t\t\t\tvmci_handle_arr_append_entry(\n\t\t\t\t\t\t&db_handle_array, handle);\n\t\t\t}\n\t\t\thandle = vmci_handle_arr_remove_tail(\n\t\t\t\t\tcontext->pending_doorbell_array);\n\t\t}\n\t\tvmci_handle_arr_destroy(context->pending_doorbell_array);\n\t\tcontext->pending_doorbell_array = db_handle_array;\n\t\tdb_handle_array = NULL;\n\t} else {\n\t\tctx_clear_notify_call(context);\n\t}\n\tspin_unlock(&context->lock);\n\tvmci_ctx_put(context);\n\n\tif (db_handle_array)\n\t\tvmci_handle_arr_destroy(db_handle_array);\n\n\tif (qp_handle_array)\n\t\tvmci_handle_arr_destroy(qp_handle_array);\n}\n\n \nint vmci_ctx_dbell_create(u32 context_id, struct vmci_handle handle)\n{\n\tstruct vmci_ctx *context;\n\tint result;\n\n\tif (context_id == VMCI_INVALID_ID || vmci_handle_is_invalid(handle))\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tcontext = vmci_ctx_get(context_id);\n\tif (context == NULL)\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\n\tspin_lock(&context->lock);\n\tif (!vmci_handle_arr_has_entry(context->doorbell_array, handle))\n\t\tresult = vmci_handle_arr_append_entry(&context->doorbell_array,\n\t\t\t\t\t\t      handle);\n\telse\n\t\tresult = VMCI_ERROR_DUPLICATE_ENTRY;\n\n\tspin_unlock(&context->lock);\n\tvmci_ctx_put(context);\n\n\treturn result;\n}\n\n \nint vmci_ctx_dbell_destroy(u32 context_id, struct vmci_handle handle)\n{\n\tstruct vmci_ctx *context;\n\tstruct vmci_handle removed_handle;\n\n\tif (context_id == VMCI_INVALID_ID || vmci_handle_is_invalid(handle))\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tcontext = vmci_ctx_get(context_id);\n\tif (context == NULL)\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\n\tspin_lock(&context->lock);\n\tremoved_handle =\n\t    vmci_handle_arr_remove_entry(context->doorbell_array, handle);\n\tvmci_handle_arr_remove_entry(context->pending_doorbell_array, handle);\n\tspin_unlock(&context->lock);\n\n\tvmci_ctx_put(context);\n\n\treturn vmci_handle_is_invalid(removed_handle) ?\n\t    VMCI_ERROR_NOT_FOUND : VMCI_SUCCESS;\n}\n\n \nint vmci_ctx_dbell_destroy_all(u32 context_id)\n{\n\tstruct vmci_ctx *context;\n\tstruct vmci_handle handle;\n\n\tif (context_id == VMCI_INVALID_ID)\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tcontext = vmci_ctx_get(context_id);\n\tif (context == NULL)\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\n\tspin_lock(&context->lock);\n\tdo {\n\t\tstruct vmci_handle_arr *arr = context->doorbell_array;\n\t\thandle = vmci_handle_arr_remove_tail(arr);\n\t} while (!vmci_handle_is_invalid(handle));\n\tdo {\n\t\tstruct vmci_handle_arr *arr = context->pending_doorbell_array;\n\t\thandle = vmci_handle_arr_remove_tail(arr);\n\t} while (!vmci_handle_is_invalid(handle));\n\tspin_unlock(&context->lock);\n\n\tvmci_ctx_put(context);\n\n\treturn VMCI_SUCCESS;\n}\n\n \nint vmci_ctx_notify_dbell(u32 src_cid,\n\t\t\t  struct vmci_handle handle,\n\t\t\t  u32 src_priv_flags)\n{\n\tstruct vmci_ctx *dst_context;\n\tint result;\n\n\tif (vmci_handle_is_invalid(handle))\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\t \n\tdst_context = vmci_ctx_get(handle.context);\n\tif (!dst_context) {\n\t\tpr_devel(\"Invalid context (ID=0x%x)\\n\", handle.context);\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\t}\n\n\tif (src_cid != handle.context) {\n\t\tu32 dst_priv_flags;\n\n\t\tif (VMCI_CONTEXT_IS_VM(src_cid) &&\n\t\t    VMCI_CONTEXT_IS_VM(handle.context)) {\n\t\t\tpr_devel(\"Doorbell notification from VM to VM not supported (src=0x%x, dst=0x%x)\\n\",\n\t\t\t\t src_cid, handle.context);\n\t\t\tresult = VMCI_ERROR_DST_UNREACHABLE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tresult = vmci_dbell_get_priv_flags(handle, &dst_priv_flags);\n\t\tif (result < VMCI_SUCCESS) {\n\t\t\tpr_warn(\"Failed to get privilege flags for destination (handle=0x%x:0x%x)\\n\",\n\t\t\t\thandle.context, handle.resource);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (src_cid != VMCI_HOST_CONTEXT_ID ||\n\t\t    src_priv_flags == VMCI_NO_PRIVILEGE_FLAGS) {\n\t\t\tsrc_priv_flags = vmci_context_get_priv_flags(src_cid);\n\t\t}\n\n\t\tif (vmci_deny_interaction(src_priv_flags, dst_priv_flags)) {\n\t\t\tresult = VMCI_ERROR_NO_ACCESS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (handle.context == VMCI_HOST_CONTEXT_ID) {\n\t\tresult = vmci_dbell_host_context_notify(src_cid, handle);\n\t} else {\n\t\tspin_lock(&dst_context->lock);\n\n\t\tif (!vmci_handle_arr_has_entry(dst_context->doorbell_array,\n\t\t\t\t\t       handle)) {\n\t\t\tresult = VMCI_ERROR_NOT_FOUND;\n\t\t} else {\n\t\t\tif (!vmci_handle_arr_has_entry(\n\t\t\t\t\tdst_context->pending_doorbell_array,\n\t\t\t\t\thandle)) {\n\t\t\t\tresult = vmci_handle_arr_append_entry(\n\t\t\t\t\t&dst_context->pending_doorbell_array,\n\t\t\t\t\thandle);\n\t\t\t\tif (result == VMCI_SUCCESS) {\n\t\t\t\t\tctx_signal_notify(dst_context);\n\t\t\t\t\twake_up(&dst_context->host_context.wait_queue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = VMCI_SUCCESS;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dst_context->lock);\n\t}\n\n out:\n\tvmci_ctx_put(dst_context);\n\n\treturn result;\n}\n\nbool vmci_ctx_supports_host_qp(struct vmci_ctx *context)\n{\n\treturn context && context->user_version >= VMCI_VERSION_HOSTQP;\n}\n\n \nint vmci_ctx_qp_create(struct vmci_ctx *context, struct vmci_handle handle)\n{\n\tint result;\n\n\tif (context == NULL || vmci_handle_is_invalid(handle))\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tif (!vmci_handle_arr_has_entry(context->queue_pair_array, handle))\n\t\tresult = vmci_handle_arr_append_entry(\n\t\t\t&context->queue_pair_array, handle);\n\telse\n\t\tresult = VMCI_ERROR_DUPLICATE_ENTRY;\n\n\treturn result;\n}\n\n \nint vmci_ctx_qp_destroy(struct vmci_ctx *context, struct vmci_handle handle)\n{\n\tstruct vmci_handle hndl;\n\n\tif (context == NULL || vmci_handle_is_invalid(handle))\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\thndl = vmci_handle_arr_remove_entry(context->queue_pair_array, handle);\n\n\treturn vmci_handle_is_invalid(hndl) ?\n\t\tVMCI_ERROR_NOT_FOUND : VMCI_SUCCESS;\n}\n\n \nbool vmci_ctx_qp_exists(struct vmci_ctx *context, struct vmci_handle handle)\n{\n\tif (context == NULL || vmci_handle_is_invalid(handle))\n\t\treturn false;\n\n\treturn vmci_handle_arr_has_entry(context->queue_pair_array, handle);\n}\n\n \nu32 vmci_context_get_priv_flags(u32 context_id)\n{\n\tif (vmci_host_code_active()) {\n\t\tu32 flags;\n\t\tstruct vmci_ctx *context;\n\n\t\tcontext = vmci_ctx_get(context_id);\n\t\tif (!context)\n\t\t\treturn VMCI_LEAST_PRIVILEGE_FLAGS;\n\n\t\tflags = context->priv_flags;\n\t\tvmci_ctx_put(context);\n\t\treturn flags;\n\t}\n\treturn VMCI_NO_PRIVILEGE_FLAGS;\n}\nEXPORT_SYMBOL_GPL(vmci_context_get_priv_flags);\n\n \nbool vmci_is_context_owner(u32 context_id, kuid_t uid)\n{\n\tbool is_owner = false;\n\n\tif (vmci_host_code_active()) {\n\t\tstruct vmci_ctx *context = vmci_ctx_get(context_id);\n\t\tif (context) {\n\t\t\tif (context->cred)\n\t\t\t\tis_owner = uid_eq(context->cred->uid, uid);\n\t\t\tvmci_ctx_put(context);\n\t\t}\n\t}\n\n\treturn is_owner;\n}\nEXPORT_SYMBOL_GPL(vmci_is_context_owner);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}