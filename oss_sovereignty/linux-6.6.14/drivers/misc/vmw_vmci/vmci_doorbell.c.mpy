{
  "module_name": "vmci_doorbell.c",
  "hash_id": "4934767255f7d252f80100305124bf85d74415bf507e520575444133e5168b4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/vmw_vmci/vmci_doorbell.c",
  "human_readable_source": "\n \n\n#include <linux/vmw_vmci_defs.h>\n#include <linux/vmw_vmci_api.h>\n#include <linux/completion.h>\n#include <linux/hash.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include \"vmci_datagram.h\"\n#include \"vmci_doorbell.h\"\n#include \"vmci_resource.h\"\n#include \"vmci_driver.h\"\n#include \"vmci_route.h\"\n\n\n#define VMCI_DOORBELL_INDEX_BITS\t6\n#define VMCI_DOORBELL_INDEX_TABLE_SIZE\t(1 << VMCI_DOORBELL_INDEX_BITS)\n#define VMCI_DOORBELL_HASH(_idx)\thash_32(_idx, VMCI_DOORBELL_INDEX_BITS)\n\n \nstruct dbell_entry {\n\tstruct vmci_resource resource;\n\tstruct hlist_node node;\n\tstruct work_struct work;\n\tvmci_callback notify_cb;\n\tvoid *client_data;\n\tu32 idx;\n\tu32 priv_flags;\n\tbool run_delayed;\n\tatomic_t active;\t \n};\n\n \nstruct dbell_index_table {\n\tspinlock_t lock;\t \n\tstruct hlist_head entries[VMCI_DOORBELL_INDEX_TABLE_SIZE];\n};\n\nstatic struct dbell_index_table vmci_doorbell_it = {\n\t.lock = __SPIN_LOCK_UNLOCKED(vmci_doorbell_it.lock),\n};\n\n \nstatic u32 max_notify_idx;\n\n \nstatic u32 notify_idx_count;\n\n \nstatic u32 last_notify_idx_reserved;\n\n \nstatic u32 last_notify_idx_released = PAGE_SIZE;\n\n\n \nint vmci_dbell_get_priv_flags(struct vmci_handle handle, u32 *priv_flags)\n{\n\tif (priv_flags == NULL || handle.context == VMCI_INVALID_ID)\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tif (handle.context == VMCI_HOST_CONTEXT_ID) {\n\t\tstruct dbell_entry *entry;\n\t\tstruct vmci_resource *resource;\n\n\t\tresource = vmci_resource_by_handle(handle,\n\t\t\t\t\t\t   VMCI_RESOURCE_TYPE_DOORBELL);\n\t\tif (!resource)\n\t\t\treturn VMCI_ERROR_NOT_FOUND;\n\n\t\tentry = container_of(resource, struct dbell_entry, resource);\n\t\t*priv_flags = entry->priv_flags;\n\t\tvmci_resource_put(resource);\n\t} else if (handle.context == VMCI_HYPERVISOR_CONTEXT_ID) {\n\t\t \n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\t} else {\n\t\t*priv_flags = vmci_context_get_priv_flags(handle.context);\n\t}\n\n\treturn VMCI_SUCCESS;\n}\n\n \nstatic struct dbell_entry *dbell_index_table_find(u32 idx)\n{\n\tu32 bucket = VMCI_DOORBELL_HASH(idx);\n\tstruct dbell_entry *dbell;\n\n\thlist_for_each_entry(dbell, &vmci_doorbell_it.entries[bucket],\n\t\t\t     node) {\n\t\tif (idx == dbell->idx)\n\t\t\treturn dbell;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void dbell_index_table_add(struct dbell_entry *entry)\n{\n\tu32 bucket;\n\tu32 new_notify_idx;\n\n\tvmci_resource_get(&entry->resource);\n\n\tspin_lock_bh(&vmci_doorbell_it.lock);\n\n\t \n\tif (max_notify_idx < PAGE_SIZE || notify_idx_count < PAGE_SIZE) {\n\t\tif (last_notify_idx_released < max_notify_idx &&\n\t\t    !dbell_index_table_find(last_notify_idx_released)) {\n\t\t\tnew_notify_idx = last_notify_idx_released;\n\t\t\tlast_notify_idx_released = PAGE_SIZE;\n\t\t} else {\n\t\t\tbool reused = false;\n\t\t\tnew_notify_idx = last_notify_idx_reserved;\n\t\t\tif (notify_idx_count + 1 < max_notify_idx) {\n\t\t\t\tdo {\n\t\t\t\t\tif (!dbell_index_table_find\n\t\t\t\t\t    (new_notify_idx)) {\n\t\t\t\t\t\treused = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnew_notify_idx = (new_notify_idx + 1) %\n\t\t\t\t\t    max_notify_idx;\n\t\t\t\t} while (new_notify_idx !=\n\t\t\t\t\t last_notify_idx_released);\n\t\t\t}\n\t\t\tif (!reused) {\n\t\t\t\tnew_notify_idx = max_notify_idx;\n\t\t\t\tmax_notify_idx++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnew_notify_idx = (last_notify_idx_reserved + 1) % PAGE_SIZE;\n\t}\n\n\tlast_notify_idx_reserved = new_notify_idx;\n\tnotify_idx_count++;\n\n\tentry->idx = new_notify_idx;\n\tbucket = VMCI_DOORBELL_HASH(entry->idx);\n\thlist_add_head(&entry->node, &vmci_doorbell_it.entries[bucket]);\n\n\tspin_unlock_bh(&vmci_doorbell_it.lock);\n}\n\n \nstatic void dbell_index_table_remove(struct dbell_entry *entry)\n{\n\tspin_lock_bh(&vmci_doorbell_it.lock);\n\n\thlist_del_init(&entry->node);\n\n\tnotify_idx_count--;\n\tif (entry->idx == max_notify_idx - 1) {\n\t\t \n\t\twhile (max_notify_idx > 0 &&\n\t\t       !dbell_index_table_find(max_notify_idx - 1))\n\t\t\tmax_notify_idx--;\n\t}\n\n\tlast_notify_idx_released = entry->idx;\n\n\tspin_unlock_bh(&vmci_doorbell_it.lock);\n\n\tvmci_resource_put(&entry->resource);\n}\n\n \nstatic int dbell_link(struct vmci_handle handle, u32 notify_idx)\n{\n\tstruct vmci_doorbell_link_msg link_msg;\n\n\tlink_msg.hdr.dst = vmci_make_handle(VMCI_HYPERVISOR_CONTEXT_ID,\n\t\t\t\t\t    VMCI_DOORBELL_LINK);\n\tlink_msg.hdr.src = VMCI_ANON_SRC_HANDLE;\n\tlink_msg.hdr.payload_size = sizeof(link_msg) - VMCI_DG_HEADERSIZE;\n\tlink_msg.handle = handle;\n\tlink_msg.notify_idx = notify_idx;\n\n\treturn vmci_send_datagram(&link_msg.hdr);\n}\n\n \nstatic int dbell_unlink(struct vmci_handle handle)\n{\n\tstruct vmci_doorbell_unlink_msg unlink_msg;\n\n\tunlink_msg.hdr.dst = vmci_make_handle(VMCI_HYPERVISOR_CONTEXT_ID,\n\t\t\t\t\t      VMCI_DOORBELL_UNLINK);\n\tunlink_msg.hdr.src = VMCI_ANON_SRC_HANDLE;\n\tunlink_msg.hdr.payload_size = sizeof(unlink_msg) - VMCI_DG_HEADERSIZE;\n\tunlink_msg.handle = handle;\n\n\treturn vmci_send_datagram(&unlink_msg.hdr);\n}\n\n \nstatic int dbell_notify_as_guest(struct vmci_handle handle, u32 priv_flags)\n{\n\tstruct vmci_doorbell_notify_msg notify_msg;\n\n\tnotify_msg.hdr.dst = vmci_make_handle(VMCI_HYPERVISOR_CONTEXT_ID,\n\t\t\t\t\t      VMCI_DOORBELL_NOTIFY);\n\tnotify_msg.hdr.src = VMCI_ANON_SRC_HANDLE;\n\tnotify_msg.hdr.payload_size = sizeof(notify_msg) - VMCI_DG_HEADERSIZE;\n\tnotify_msg.handle = handle;\n\n\treturn vmci_send_datagram(&notify_msg.hdr);\n}\n\n \nstatic void dbell_delayed_dispatch(struct work_struct *work)\n{\n\tstruct dbell_entry *entry = container_of(work,\n\t\t\t\t\t\t struct dbell_entry, work);\n\n\tentry->notify_cb(entry->client_data);\n\tvmci_resource_put(&entry->resource);\n}\n\n \nint vmci_dbell_host_context_notify(u32 src_cid, struct vmci_handle handle)\n{\n\tstruct dbell_entry *entry;\n\tstruct vmci_resource *resource;\n\n\tif (vmci_handle_is_invalid(handle)) {\n\t\tpr_devel(\"Notifying an invalid doorbell (handle=0x%x:0x%x)\\n\",\n\t\t\t handle.context, handle.resource);\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\t}\n\n\tresource = vmci_resource_by_handle(handle,\n\t\t\t\t\t   VMCI_RESOURCE_TYPE_DOORBELL);\n\tif (!resource) {\n\t\tpr_devel(\"Notifying an unknown doorbell (handle=0x%x:0x%x)\\n\",\n\t\t\t handle.context, handle.resource);\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\t}\n\n\tentry = container_of(resource, struct dbell_entry, resource);\n\tif (entry->run_delayed) {\n\t\tif (!schedule_work(&entry->work))\n\t\t\tvmci_resource_put(resource);\n\t} else {\n\t\tentry->notify_cb(entry->client_data);\n\t\tvmci_resource_put(resource);\n\t}\n\n\treturn VMCI_SUCCESS;\n}\n\n \nbool vmci_dbell_register_notification_bitmap(u64 bitmap_ppn)\n{\n\tint result;\n\tstruct vmci_notify_bm_set_msg bitmap_set_msg = { };\n\n\tbitmap_set_msg.hdr.dst = vmci_make_handle(VMCI_HYPERVISOR_CONTEXT_ID,\n\t\t\t\t\t\t  VMCI_SET_NOTIFY_BITMAP);\n\tbitmap_set_msg.hdr.src = VMCI_ANON_SRC_HANDLE;\n\tbitmap_set_msg.hdr.payload_size = sizeof(bitmap_set_msg) -\n\t    VMCI_DG_HEADERSIZE;\n\tif (vmci_use_ppn64())\n\t\tbitmap_set_msg.bitmap_ppn64 = bitmap_ppn;\n\telse\n\t\tbitmap_set_msg.bitmap_ppn32 = (u32) bitmap_ppn;\n\n\tresult = vmci_send_datagram(&bitmap_set_msg.hdr);\n\tif (result != VMCI_SUCCESS) {\n\t\tpr_devel(\"Failed to register (PPN=%llu) as notification bitmap (error=%d)\\n\",\n\t\t\t bitmap_ppn, result);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic void dbell_fire_entries(u32 notify_idx)\n{\n\tu32 bucket = VMCI_DOORBELL_HASH(notify_idx);\n\tstruct dbell_entry *dbell;\n\n\tspin_lock_bh(&vmci_doorbell_it.lock);\n\n\thlist_for_each_entry(dbell, &vmci_doorbell_it.entries[bucket], node) {\n\t\tif (dbell->idx == notify_idx &&\n\t\t    atomic_read(&dbell->active) == 1) {\n\t\t\tif (dbell->run_delayed) {\n\t\t\t\tvmci_resource_get(&dbell->resource);\n\t\t\t\tif (!schedule_work(&dbell->work))\n\t\t\t\t\tvmci_resource_put(&dbell->resource);\n\t\t\t} else {\n\t\t\t\tdbell->notify_cb(dbell->client_data);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&vmci_doorbell_it.lock);\n}\n\n \nvoid vmci_dbell_scan_notification_entries(u8 *bitmap)\n{\n\tu32 idx;\n\n\tfor (idx = 0; idx < max_notify_idx; idx++) {\n\t\tif (bitmap[idx] & 0x1) {\n\t\t\tbitmap[idx] &= ~1;\n\t\t\tdbell_fire_entries(idx);\n\t\t}\n\t}\n}\n\n \nint vmci_doorbell_create(struct vmci_handle *handle,\n\t\t\t u32 flags,\n\t\t\t u32 priv_flags,\n\t\t\t vmci_callback notify_cb, void *client_data)\n{\n\tstruct dbell_entry *entry;\n\tstruct vmci_handle new_handle;\n\tint result;\n\n\tif (!handle || !notify_cb || flags & ~VMCI_FLAG_DELAYED_CB ||\n\t    priv_flags & ~VMCI_PRIVILEGE_ALL_FLAGS)\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (entry == NULL) {\n\t\tpr_warn(\"Failed allocating memory for datagram entry\\n\");\n\t\treturn VMCI_ERROR_NO_MEM;\n\t}\n\n\tif (vmci_handle_is_invalid(*handle)) {\n\t\tu32 context_id = vmci_get_context_id();\n\n\t\tif (context_id == VMCI_INVALID_ID) {\n\t\t\tpr_warn(\"Failed to get context ID\\n\");\n\t\t\tresult = VMCI_ERROR_NO_RESOURCES;\n\t\t\tgoto free_mem;\n\t\t}\n\n\t\t \n\t\tnew_handle = vmci_make_handle(context_id, VMCI_INVALID_ID);\n\t} else {\n\t\tbool valid_context = false;\n\n\t\t \n\t\tif (handle->context == VMCI_HOST_CONTEXT_ID ||\n\t\t    (vmci_guest_code_active() &&\n\t\t     vmci_get_context_id() == handle->context)) {\n\t\t\tvalid_context = true;\n\t\t}\n\n\t\tif (!valid_context || handle->resource == VMCI_INVALID_ID) {\n\t\t\tpr_devel(\"Invalid argument (handle=0x%x:0x%x)\\n\",\n\t\t\t\t handle->context, handle->resource);\n\t\t\tresult = VMCI_ERROR_INVALID_ARGS;\n\t\t\tgoto free_mem;\n\t\t}\n\n\t\tnew_handle = *handle;\n\t}\n\n\tentry->idx = 0;\n\tINIT_HLIST_NODE(&entry->node);\n\tentry->priv_flags = priv_flags;\n\tINIT_WORK(&entry->work, dbell_delayed_dispatch);\n\tentry->run_delayed = flags & VMCI_FLAG_DELAYED_CB;\n\tentry->notify_cb = notify_cb;\n\tentry->client_data = client_data;\n\tatomic_set(&entry->active, 0);\n\n\tresult = vmci_resource_add(&entry->resource,\n\t\t\t\t   VMCI_RESOURCE_TYPE_DOORBELL,\n\t\t\t\t   new_handle);\n\tif (result != VMCI_SUCCESS) {\n\t\tpr_warn(\"Failed to add new resource (handle=0x%x:0x%x), error: %d\\n\",\n\t\t\tnew_handle.context, new_handle.resource, result);\n\t\tgoto free_mem;\n\t}\n\n\tnew_handle = vmci_resource_handle(&entry->resource);\n\tif (vmci_guest_code_active()) {\n\t\tdbell_index_table_add(entry);\n\t\tresult = dbell_link(new_handle, entry->idx);\n\t\tif (VMCI_SUCCESS != result)\n\t\t\tgoto destroy_resource;\n\n\t\tatomic_set(&entry->active, 1);\n\t}\n\n\t*handle = new_handle;\n\n\treturn result;\n\n destroy_resource:\n\tdbell_index_table_remove(entry);\n\tvmci_resource_remove(&entry->resource);\n free_mem:\n\tkfree(entry);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(vmci_doorbell_create);\n\n \nint vmci_doorbell_destroy(struct vmci_handle handle)\n{\n\tstruct dbell_entry *entry;\n\tstruct vmci_resource *resource;\n\n\tif (vmci_handle_is_invalid(handle))\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tresource = vmci_resource_by_handle(handle,\n\t\t\t\t\t   VMCI_RESOURCE_TYPE_DOORBELL);\n\tif (!resource) {\n\t\tpr_devel(\"Failed to destroy doorbell (handle=0x%x:0x%x)\\n\",\n\t\t\t handle.context, handle.resource);\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\t}\n\n\tentry = container_of(resource, struct dbell_entry, resource);\n\n\tif (!hlist_unhashed(&entry->node)) {\n\t\tint result;\n\n\t\tdbell_index_table_remove(entry);\n\n\t\tresult = dbell_unlink(handle);\n\t\tif (VMCI_SUCCESS != result) {\n\n\t\t\t \n\t\t\tpr_devel(\"Unlink of doorbell (handle=0x%x:0x%x) unknown by hypervisor (error=%d)\\n\",\n\t\t\t\t handle.context, handle.resource, result);\n\t\t}\n\t}\n\n\t \n\tvmci_resource_put(&entry->resource);\n\tvmci_resource_remove(&entry->resource);\n\n\tkfree(entry);\n\n\treturn VMCI_SUCCESS;\n}\nEXPORT_SYMBOL_GPL(vmci_doorbell_destroy);\n\n \nint vmci_doorbell_notify(struct vmci_handle dst, u32 priv_flags)\n{\n\tint retval;\n\tenum vmci_route route;\n\tstruct vmci_handle src;\n\n\tif (vmci_handle_is_invalid(dst) ||\n\t    (priv_flags & ~VMCI_PRIVILEGE_ALL_FLAGS))\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tsrc = VMCI_INVALID_HANDLE;\n\tretval = vmci_route(&src, &dst, false, &route);\n\tif (retval < VMCI_SUCCESS)\n\t\treturn retval;\n\n\tif (VMCI_ROUTE_AS_HOST == route)\n\t\treturn vmci_ctx_notify_dbell(VMCI_HOST_CONTEXT_ID,\n\t\t\t\t\t     dst, priv_flags);\n\n\tif (VMCI_ROUTE_AS_GUEST == route)\n\t\treturn dbell_notify_as_guest(dst, priv_flags);\n\n\tpr_warn(\"Unknown route (%d) for doorbell\\n\", route);\n\treturn VMCI_ERROR_DST_UNREACHABLE;\n}\nEXPORT_SYMBOL_GPL(vmci_doorbell_notify);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}