{
  "module_name": "vmci_host.c",
  "hash_id": "ac8a5aeebcde7a12f5cc795c49744650fe8ea6e9e1f3f12844348b9d685bf82d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/vmw_vmci/vmci_host.c",
  "human_readable_source": "\n \n\n#include <linux/vmw_vmci_defs.h>\n#include <linux/vmw_vmci_api.h>\n#include <linux/miscdevice.h>\n#include <linux/interrupt.h>\n#include <linux/highmem.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/pci.h>\n#include <linux/smp.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n\n#include \"vmci_handle_array.h\"\n#include \"vmci_queue_pair.h\"\n#include \"vmci_datagram.h\"\n#include \"vmci_doorbell.h\"\n#include \"vmci_resource.h\"\n#include \"vmci_context.h\"\n#include \"vmci_driver.h\"\n#include \"vmci_event.h\"\n\n#define VMCI_UTIL_NUM_RESOURCES 1\n\nenum {\n\tVMCI_NOTIFY_RESOURCE_QUEUE_PAIR = 0,\n\tVMCI_NOTIFY_RESOURCE_DOOR_BELL = 1,\n};\n\nenum {\n\tVMCI_NOTIFY_RESOURCE_ACTION_NOTIFY = 0,\n\tVMCI_NOTIFY_RESOURCE_ACTION_CREATE = 1,\n\tVMCI_NOTIFY_RESOURCE_ACTION_DESTROY = 2,\n};\n\n \nstruct vmci_init_blk {\n\tu32 cid;\n\tu32 flags;\n};\n\n \nstruct vmci_qp_alloc_info_vmvm {\n\tstruct vmci_handle handle;\n\tu32 peer;\n\tu32 flags;\n\tu64 produce_size;\n\tu64 consume_size;\n\tu64 produce_page_file;\t   \n\tu64 consume_page_file;\t   \n\tu64 produce_page_file_size;   \n\tu64 consume_page_file_size;   \n\ts32 result;\n\tu32 _pad;\n};\n\n \nstruct vmci_set_notify_info {\n\tu64 notify_uva;\n\ts32 result;\n\tu32 _pad;\n};\n\n \nstruct vmci_host_dev {\n\tstruct vmci_ctx *context;\n\tint user_version;\n\tenum vmci_obj_type ct_type;\n\tstruct mutex lock;   \n};\n\nstatic struct vmci_ctx *host_context;\nstatic bool vmci_host_device_initialized;\nstatic atomic_t vmci_host_active_users = ATOMIC_INIT(0);\n\n \nbool vmci_host_code_active(void)\n{\n\treturn vmci_host_device_initialized &&\n\t    (!vmci_guest_code_active() ||\n\t     atomic_read(&vmci_host_active_users) > 0);\n}\n\nint vmci_host_users(void)\n{\n\treturn atomic_read(&vmci_host_active_users);\n}\n\n \nstatic int vmci_host_open(struct inode *inode, struct file *filp)\n{\n\tstruct vmci_host_dev *vmci_host_dev;\n\n\tvmci_host_dev = kzalloc(sizeof(struct vmci_host_dev), GFP_KERNEL);\n\tif (vmci_host_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tvmci_host_dev->ct_type = VMCIOBJ_NOT_SET;\n\tmutex_init(&vmci_host_dev->lock);\n\tfilp->private_data = vmci_host_dev;\n\n\treturn 0;\n}\n\n \nstatic int vmci_host_close(struct inode *inode, struct file *filp)\n{\n\tstruct vmci_host_dev *vmci_host_dev = filp->private_data;\n\n\tif (vmci_host_dev->ct_type == VMCIOBJ_CONTEXT) {\n\t\tvmci_ctx_destroy(vmci_host_dev->context);\n\t\tvmci_host_dev->context = NULL;\n\n\t\t \n\t\tatomic_dec(&vmci_host_active_users);\n\t}\n\tvmci_host_dev->ct_type = VMCIOBJ_NOT_SET;\n\n\tkfree(vmci_host_dev);\n\tfilp->private_data = NULL;\n\treturn 0;\n}\n\n \nstatic __poll_t vmci_host_poll(struct file *filp, poll_table *wait)\n{\n\tstruct vmci_host_dev *vmci_host_dev = filp->private_data;\n\tstruct vmci_ctx *context;\n\t__poll_t mask = 0;\n\n\tif (vmci_host_dev->ct_type == VMCIOBJ_CONTEXT) {\n\t\t \n\t\tcontext = vmci_host_dev->context;\n\n\t\t \n\t\tif (wait)\n\t\t\tpoll_wait(filp, &context->host_context.wait_queue,\n\t\t\t\t  wait);\n\n\t\tspin_lock(&context->lock);\n\t\tif (context->pending_datagrams > 0 ||\n\t\t    vmci_handle_arr_get_size(\n\t\t\t\tcontext->pending_doorbell_array) > 0) {\n\t\t\tmask = EPOLLIN;\n\t\t}\n\t\tspin_unlock(&context->lock);\n\t}\n\treturn mask;\n}\n\n \nstatic int drv_cp_harray_to_user(void __user *user_buf_uva,\n\t\t\t\t u64 *user_buf_size,\n\t\t\t\t struct vmci_handle_arr *handle_array,\n\t\t\t\t int *retval)\n{\n\tu32 array_size = 0;\n\tstruct vmci_handle *handles;\n\n\tif (handle_array)\n\t\tarray_size = vmci_handle_arr_get_size(handle_array);\n\n\tif (array_size * sizeof(*handles) > *user_buf_size)\n\t\treturn VMCI_ERROR_MORE_DATA;\n\n\t*user_buf_size = array_size * sizeof(*handles);\n\tif (*user_buf_size)\n\t\t*retval = copy_to_user(user_buf_uva,\n\t\t\t\t       vmci_handle_arr_get_handles\n\t\t\t\t       (handle_array), *user_buf_size);\n\n\treturn VMCI_SUCCESS;\n}\n\n \nstatic int vmci_host_setup_notify(struct vmci_ctx *context,\n\t\t\t\t  unsigned long uva)\n{\n\tint retval;\n\n\tif (context->notify_page) {\n\t\tpr_devel(\"%s: Notify mechanism is already set up\\n\", __func__);\n\t\treturn VMCI_ERROR_DUPLICATE_ENTRY;\n\t}\n\n\t \n\tBUILD_BUG_ON(sizeof(bool) != sizeof(u8));\n\n\t \n\tretval = get_user_pages_fast(uva, 1, FOLL_WRITE, &context->notify_page);\n\tif (retval != 1) {\n\t\tcontext->notify_page = NULL;\n\t\treturn VMCI_ERROR_GENERIC;\n\t}\n\tif (context->notify_page == NULL)\n\t\treturn VMCI_ERROR_UNAVAILABLE;\n\n\t \n\tcontext->notify = kmap(context->notify_page) + (uva & (PAGE_SIZE - 1));\n\tvmci_ctx_check_signal_notify(context);\n\n\treturn VMCI_SUCCESS;\n}\n\nstatic int vmci_host_get_version(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t unsigned int cmd, void __user *uptr)\n{\n\tif (cmd == IOCTL_VMCI_VERSION2) {\n\t\tint __user *vptr = uptr;\n\t\tif (get_user(vmci_host_dev->user_version, vptr))\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\n\tif (vmci_host_dev->user_version > 0 &&\n\t    vmci_host_dev->user_version < VMCI_VERSION_HOSTQP) {\n\t\treturn vmci_host_dev->user_version;\n\t}\n\n\treturn VMCI_VERSION;\n}\n\n#define vmci_ioctl_err(fmt, ...)\t\\\n\tpr_devel(\"%s: \" fmt, ioctl_name, ##__VA_ARGS__)\n\nstatic int vmci_host_do_init_context(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t     const char *ioctl_name,\n\t\t\t\t     void __user *uptr)\n{\n\tstruct vmci_init_blk init_block;\n\tconst struct cred *cred;\n\tint retval;\n\n\tif (copy_from_user(&init_block, uptr, sizeof(init_block))) {\n\t\tvmci_ioctl_err(\"error reading init block\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tmutex_lock(&vmci_host_dev->lock);\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_NOT_SET) {\n\t\tvmci_ioctl_err(\"received VMCI init on initialized handle\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (init_block.flags & ~VMCI_PRIVILEGE_FLAG_RESTRICTED) {\n\t\tvmci_ioctl_err(\"unsupported VMCI restriction flag\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcred = get_current_cred();\n\tvmci_host_dev->context = vmci_ctx_create(init_block.cid,\n\t\t\t\t\t\t init_block.flags, 0,\n\t\t\t\t\t\t vmci_host_dev->user_version,\n\t\t\t\t\t\t cred);\n\tput_cred(cred);\n\tif (IS_ERR(vmci_host_dev->context)) {\n\t\tretval = PTR_ERR(vmci_host_dev->context);\n\t\tvmci_ioctl_err(\"error initializing context\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tinit_block.cid = vmci_ctx_get_id(vmci_host_dev->context);\n\tif (copy_to_user(uptr, &init_block, sizeof(init_block))) {\n\t\tvmci_ctx_destroy(vmci_host_dev->context);\n\t\tvmci_host_dev->context = NULL;\n\t\tvmci_ioctl_err(\"error writing init block\\n\");\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tvmci_host_dev->ct_type = VMCIOBJ_CONTEXT;\n\tatomic_inc(&vmci_host_active_users);\n\n\tvmci_call_vsock_callback(true);\n\n\tretval = 0;\n\nout:\n\tmutex_unlock(&vmci_host_dev->lock);\n\treturn retval;\n}\n\nstatic int vmci_host_do_send_datagram(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t      const char *ioctl_name,\n\t\t\t\t      void __user *uptr)\n{\n\tstruct vmci_datagram_snd_rcv_info send_info;\n\tstruct vmci_datagram *dg = NULL;\n\tu32 cid;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&send_info, uptr, sizeof(send_info)))\n\t\treturn -EFAULT;\n\n\tif (send_info.len > VMCI_MAX_DG_SIZE) {\n\t\tvmci_ioctl_err(\"datagram is too big (size=%d)\\n\",\n\t\t\t       send_info.len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (send_info.len < sizeof(*dg)) {\n\t\tvmci_ioctl_err(\"datagram is too small (size=%d)\\n\",\n\t\t\t       send_info.len);\n\t\treturn -EINVAL;\n\t}\n\n\tdg = memdup_user((void __user *)(uintptr_t)send_info.addr,\n\t\t\t send_info.len);\n\tif (IS_ERR(dg)) {\n\t\tvmci_ioctl_err(\n\t\t\t\"cannot allocate memory to dispatch datagram\\n\");\n\t\treturn PTR_ERR(dg);\n\t}\n\n\tif (VMCI_DG_SIZE(dg) != send_info.len) {\n\t\tvmci_ioctl_err(\"datagram size mismatch\\n\");\n\t\tkfree(dg);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_devel(\"Datagram dst (handle=0x%x:0x%x) src (handle=0x%x:0x%x), payload (size=%llu bytes)\\n\",\n\t\t dg->dst.context, dg->dst.resource,\n\t\t dg->src.context, dg->src.resource,\n\t\t (unsigned long long)dg->payload_size);\n\n\t \n\tcid = vmci_ctx_get_id(vmci_host_dev->context);\n\tsend_info.result = vmci_datagram_dispatch(cid, dg, true);\n\tkfree(dg);\n\n\treturn copy_to_user(uptr, &send_info, sizeof(send_info)) ? -EFAULT : 0;\n}\n\nstatic int vmci_host_do_receive_datagram(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t\t const char *ioctl_name,\n\t\t\t\t\t void __user *uptr)\n{\n\tstruct vmci_datagram_snd_rcv_info recv_info;\n\tstruct vmci_datagram *dg = NULL;\n\tint retval;\n\tsize_t size;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&recv_info, uptr, sizeof(recv_info)))\n\t\treturn -EFAULT;\n\n\tsize = recv_info.len;\n\trecv_info.result = vmci_ctx_dequeue_datagram(vmci_host_dev->context,\n\t\t\t\t\t\t     &size, &dg);\n\n\tif (recv_info.result >= VMCI_SUCCESS) {\n\t\tvoid __user *ubuf = (void __user *)(uintptr_t)recv_info.addr;\n\t\tretval = copy_to_user(ubuf, dg, VMCI_DG_SIZE(dg));\n\t\tkfree(dg);\n\t\tif (retval != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn copy_to_user(uptr, &recv_info, sizeof(recv_info)) ? -EFAULT : 0;\n}\n\nstatic int vmci_host_do_alloc_queuepair(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t\tconst char *ioctl_name,\n\t\t\t\t\tvoid __user *uptr)\n{\n\tstruct vmci_handle handle;\n\tint vmci_status;\n\tint __user *retptr;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vmci_host_dev->user_version < VMCI_VERSION_NOVMVM) {\n\t\tstruct vmci_qp_alloc_info_vmvm alloc_info;\n\t\tstruct vmci_qp_alloc_info_vmvm __user *info = uptr;\n\n\t\tif (copy_from_user(&alloc_info, uptr, sizeof(alloc_info)))\n\t\t\treturn -EFAULT;\n\n\t\thandle = alloc_info.handle;\n\t\tretptr = &info->result;\n\n\t\tvmci_status = vmci_qp_broker_alloc(alloc_info.handle,\n\t\t\t\t\t\talloc_info.peer,\n\t\t\t\t\t\talloc_info.flags,\n\t\t\t\t\t\tVMCI_NO_PRIVILEGE_FLAGS,\n\t\t\t\t\t\talloc_info.produce_size,\n\t\t\t\t\t\talloc_info.consume_size,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tvmci_host_dev->context);\n\n\t\tif (vmci_status == VMCI_SUCCESS)\n\t\t\tvmci_status = VMCI_SUCCESS_QUEUEPAIR_CREATE;\n\t} else {\n\t\tstruct vmci_qp_alloc_info alloc_info;\n\t\tstruct vmci_qp_alloc_info __user *info = uptr;\n\t\tstruct vmci_qp_page_store page_store;\n\n\t\tif (copy_from_user(&alloc_info, uptr, sizeof(alloc_info)))\n\t\t\treturn -EFAULT;\n\n\t\thandle = alloc_info.handle;\n\t\tretptr = &info->result;\n\n\t\tpage_store.pages = alloc_info.ppn_va;\n\t\tpage_store.len = alloc_info.num_ppns;\n\n\t\tvmci_status = vmci_qp_broker_alloc(alloc_info.handle,\n\t\t\t\t\t\talloc_info.peer,\n\t\t\t\t\t\talloc_info.flags,\n\t\t\t\t\t\tVMCI_NO_PRIVILEGE_FLAGS,\n\t\t\t\t\t\talloc_info.produce_size,\n\t\t\t\t\t\talloc_info.consume_size,\n\t\t\t\t\t\t&page_store,\n\t\t\t\t\t\tvmci_host_dev->context);\n\t}\n\n\tif (put_user(vmci_status, retptr)) {\n\t\tif (vmci_status >= VMCI_SUCCESS) {\n\t\t\tvmci_status = vmci_qp_broker_detach(handle,\n\t\t\t\t\t\t\tvmci_host_dev->context);\n\t\t}\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int vmci_host_do_queuepair_setva(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t\tconst char *ioctl_name,\n\t\t\t\t\tvoid __user *uptr)\n{\n\tstruct vmci_qp_set_va_info set_va_info;\n\tstruct vmci_qp_set_va_info __user *info = uptr;\n\ts32 result;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vmci_host_dev->user_version < VMCI_VERSION_NOVMVM) {\n\t\tvmci_ioctl_err(\"is not allowed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&set_va_info, uptr, sizeof(set_va_info)))\n\t\treturn -EFAULT;\n\n\tif (set_va_info.va) {\n\t\t \n\t\tresult = vmci_qp_broker_map(set_va_info.handle,\n\t\t\t\t\t    vmci_host_dev->context,\n\t\t\t\t\t    set_va_info.va);\n\t} else {\n\t\t \n\t\tresult = vmci_qp_broker_unmap(set_va_info.handle,\n\t\t\t\t\t vmci_host_dev->context, 0);\n\t}\n\n\treturn put_user(result, &info->result) ? -EFAULT : 0;\n}\n\nstatic int vmci_host_do_queuepair_setpf(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t\tconst char *ioctl_name,\n\t\t\t\t\tvoid __user *uptr)\n{\n\tstruct vmci_qp_page_file_info page_file_info;\n\tstruct vmci_qp_page_file_info __user *info = uptr;\n\ts32 result;\n\n\tif (vmci_host_dev->user_version < VMCI_VERSION_HOSTQP ||\n\t    vmci_host_dev->user_version >= VMCI_VERSION_NOVMVM) {\n\t\tvmci_ioctl_err(\"not supported on this VMX (version=%d)\\n\",\n\t\t\t       vmci_host_dev->user_version);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&page_file_info, uptr, sizeof(*info)))\n\t\treturn -EFAULT;\n\n\t \n\n\tif (put_user(VMCI_SUCCESS, &info->result)) {\n\t\t \n\t\treturn -EFAULT;\n\t}\n\n\tresult = vmci_qp_broker_set_page_store(page_file_info.handle,\n\t\t\t\t\t\tpage_file_info.produce_va,\n\t\t\t\t\t\tpage_file_info.consume_va,\n\t\t\t\t\t\tvmci_host_dev->context);\n\tif (result < VMCI_SUCCESS) {\n\t\tif (put_user(result, &info->result)) {\n\t\t\t \n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vmci_host_do_qp_detach(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t  const char *ioctl_name,\n\t\t\t\t  void __user *uptr)\n{\n\tstruct vmci_qp_dtch_info detach_info;\n\tstruct vmci_qp_dtch_info __user *info = uptr;\n\ts32 result;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&detach_info, uptr, sizeof(detach_info)))\n\t\treturn -EFAULT;\n\n\tresult = vmci_qp_broker_detach(detach_info.handle,\n\t\t\t\t       vmci_host_dev->context);\n\tif (result == VMCI_SUCCESS &&\n\t    vmci_host_dev->user_version < VMCI_VERSION_NOVMVM) {\n\t\tresult = VMCI_SUCCESS_LAST_DETACH;\n\t}\n\n\treturn put_user(result, &info->result) ? -EFAULT : 0;\n}\n\nstatic int vmci_host_do_ctx_add_notify(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t       const char *ioctl_name,\n\t\t\t\t       void __user *uptr)\n{\n\tstruct vmci_ctx_info ar_info;\n\tstruct vmci_ctx_info __user *info = uptr;\n\ts32 result;\n\tu32 cid;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&ar_info, uptr, sizeof(ar_info)))\n\t\treturn -EFAULT;\n\n\tcid = vmci_ctx_get_id(vmci_host_dev->context);\n\tresult = vmci_ctx_add_notification(cid, ar_info.remote_cid);\n\n\treturn put_user(result, &info->result) ? -EFAULT : 0;\n}\n\nstatic int vmci_host_do_ctx_remove_notify(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t\t  const char *ioctl_name,\n\t\t\t\t\t  void __user *uptr)\n{\n\tstruct vmci_ctx_info ar_info;\n\tstruct vmci_ctx_info __user *info = uptr;\n\tu32 cid;\n\tint result;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&ar_info, uptr, sizeof(ar_info)))\n\t\treturn -EFAULT;\n\n\tcid = vmci_ctx_get_id(vmci_host_dev->context);\n\tresult = vmci_ctx_remove_notification(cid,\n\t\t\t\t\t      ar_info.remote_cid);\n\n\treturn put_user(result, &info->result) ? -EFAULT : 0;\n}\n\nstatic int vmci_host_do_ctx_get_cpt_state(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t\t  const char *ioctl_name,\n\t\t\t\t\t  void __user *uptr)\n{\n\tstruct vmci_ctx_chkpt_buf_info get_info;\n\tu32 cid;\n\tvoid *cpt_buf;\n\tint retval;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&get_info, uptr, sizeof(get_info)))\n\t\treturn -EFAULT;\n\n\tcid = vmci_ctx_get_id(vmci_host_dev->context);\n\tget_info.result = vmci_ctx_get_chkpt_state(cid, get_info.cpt_type,\n\t\t\t\t\t\t&get_info.buf_size, &cpt_buf);\n\tif (get_info.result == VMCI_SUCCESS && get_info.buf_size) {\n\t\tvoid __user *ubuf = (void __user *)(uintptr_t)get_info.cpt_buf;\n\t\tretval = copy_to_user(ubuf, cpt_buf, get_info.buf_size);\n\t\tkfree(cpt_buf);\n\n\t\tif (retval)\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn copy_to_user(uptr, &get_info, sizeof(get_info)) ? -EFAULT : 0;\n}\n\nstatic int vmci_host_do_ctx_set_cpt_state(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t\t  const char *ioctl_name,\n\t\t\t\t\t  void __user *uptr)\n{\n\tstruct vmci_ctx_chkpt_buf_info set_info;\n\tu32 cid;\n\tvoid *cpt_buf;\n\tint retval;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&set_info, uptr, sizeof(set_info)))\n\t\treturn -EFAULT;\n\n\tcpt_buf = memdup_user((void __user *)(uintptr_t)set_info.cpt_buf,\n\t\t\t\tset_info.buf_size);\n\tif (IS_ERR(cpt_buf))\n\t\treturn PTR_ERR(cpt_buf);\n\n\tcid = vmci_ctx_get_id(vmci_host_dev->context);\n\tset_info.result = vmci_ctx_set_chkpt_state(cid, set_info.cpt_type,\n\t\t\t\t\t\t   set_info.buf_size, cpt_buf);\n\n\tretval = copy_to_user(uptr, &set_info, sizeof(set_info)) ? -EFAULT : 0;\n\n\tkfree(cpt_buf);\n\treturn retval;\n}\n\nstatic int vmci_host_do_get_context_id(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t       const char *ioctl_name,\n\t\t\t\t       void __user *uptr)\n{\n\tu32 __user *u32ptr = uptr;\n\n\treturn put_user(VMCI_HOST_CONTEXT_ID, u32ptr) ? -EFAULT : 0;\n}\n\nstatic int vmci_host_do_set_notify(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t   const char *ioctl_name,\n\t\t\t\t   void __user *uptr)\n{\n\tstruct vmci_set_notify_info notify_info;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&notify_info, uptr, sizeof(notify_info)))\n\t\treturn -EFAULT;\n\n\tif (notify_info.notify_uva) {\n\t\tnotify_info.result =\n\t\t\tvmci_host_setup_notify(vmci_host_dev->context,\n\t\t\t\t\t       notify_info.notify_uva);\n\t} else {\n\t\tvmci_ctx_unset_notify(vmci_host_dev->context);\n\t\tnotify_info.result = VMCI_SUCCESS;\n\t}\n\n\treturn copy_to_user(uptr, &notify_info, sizeof(notify_info)) ?\n\t\t-EFAULT : 0;\n}\n\nstatic int vmci_host_do_notify_resource(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t\tconst char *ioctl_name,\n\t\t\t\t\tvoid __user *uptr)\n{\n\tstruct vmci_dbell_notify_resource_info info;\n\tu32 cid;\n\n\tif (vmci_host_dev->user_version < VMCI_VERSION_NOTIFY) {\n\t\tvmci_ioctl_err(\"invalid for current VMX versions\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&info, uptr, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tcid = vmci_ctx_get_id(vmci_host_dev->context);\n\n\tswitch (info.action) {\n\tcase VMCI_NOTIFY_RESOURCE_ACTION_NOTIFY:\n\t\tif (info.resource == VMCI_NOTIFY_RESOURCE_DOOR_BELL) {\n\t\t\tu32 flags = VMCI_NO_PRIVILEGE_FLAGS;\n\t\t\tinfo.result = vmci_ctx_notify_dbell(cid, info.handle,\n\t\t\t\t\t\t\t    flags);\n\t\t} else {\n\t\t\tinfo.result = VMCI_ERROR_UNAVAILABLE;\n\t\t}\n\t\tbreak;\n\n\tcase VMCI_NOTIFY_RESOURCE_ACTION_CREATE:\n\t\tinfo.result = vmci_ctx_dbell_create(cid, info.handle);\n\t\tbreak;\n\n\tcase VMCI_NOTIFY_RESOURCE_ACTION_DESTROY:\n\t\tinfo.result = vmci_ctx_dbell_destroy(cid, info.handle);\n\t\tbreak;\n\n\tdefault:\n\t\tvmci_ioctl_err(\"got unknown action (action=%d)\\n\",\n\t\t\t       info.action);\n\t\tinfo.result = VMCI_ERROR_INVALID_ARGS;\n\t}\n\n\treturn copy_to_user(uptr, &info, sizeof(info)) ? -EFAULT : 0;\n}\n\nstatic int vmci_host_do_recv_notifications(struct vmci_host_dev *vmci_host_dev,\n\t\t\t\t\t   const char *ioctl_name,\n\t\t\t\t\t   void __user *uptr)\n{\n\tstruct vmci_ctx_notify_recv_info info;\n\tstruct vmci_handle_arr *db_handle_array;\n\tstruct vmci_handle_arr *qp_handle_array;\n\tvoid __user *ubuf;\n\tu32 cid;\n\tint retval = 0;\n\n\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\n\t\tvmci_ioctl_err(\"only valid for contexts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vmci_host_dev->user_version < VMCI_VERSION_NOTIFY) {\n\t\tvmci_ioctl_err(\"not supported for the current vmx version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&info, uptr, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif ((info.db_handle_buf_size && !info.db_handle_buf_uva) ||\n\t    (info.qp_handle_buf_size && !info.qp_handle_buf_uva)) {\n\t\treturn -EINVAL;\n\t}\n\n\tcid = vmci_ctx_get_id(vmci_host_dev->context);\n\n\tinfo.result = vmci_ctx_rcv_notifications_get(cid,\n\t\t\t\t&db_handle_array, &qp_handle_array);\n\tif (info.result != VMCI_SUCCESS)\n\t\treturn copy_to_user(uptr, &info, sizeof(info)) ? -EFAULT : 0;\n\n\tubuf = (void __user *)(uintptr_t)info.db_handle_buf_uva;\n\tinfo.result = drv_cp_harray_to_user(ubuf, &info.db_handle_buf_size,\n\t\t\t\t\t    db_handle_array, &retval);\n\tif (info.result == VMCI_SUCCESS && !retval) {\n\t\tubuf = (void __user *)(uintptr_t)info.qp_handle_buf_uva;\n\t\tinfo.result = drv_cp_harray_to_user(ubuf,\n\t\t\t\t\t\t    &info.qp_handle_buf_size,\n\t\t\t\t\t\t    qp_handle_array, &retval);\n\t}\n\n\tif (!retval && copy_to_user(uptr, &info, sizeof(info)))\n\t\tretval = -EFAULT;\n\n\tvmci_ctx_rcv_notifications_release(cid,\n\t\t\t\tdb_handle_array, qp_handle_array,\n\t\t\t\tinfo.result == VMCI_SUCCESS && !retval);\n\n\treturn retval;\n}\n\nstatic long vmci_host_unlocked_ioctl(struct file *filp,\n\t\t\t\t     unsigned int iocmd, unsigned long ioarg)\n{\n#define VMCI_DO_IOCTL(ioctl_name, ioctl_fn) do {\t\t\t\\\n\t\tchar *name = \"IOCTL_VMCI_\" # ioctl_name;\t\t\\\n\t\treturn vmci_host_do_ ## ioctl_fn(\t\t\t\\\n\t\t\tvmci_host_dev, name, uptr);\t\t\t\\\n\t} while (0)\n\n\tstruct vmci_host_dev *vmci_host_dev = filp->private_data;\n\tvoid __user *uptr = (void __user *)ioarg;\n\n\tswitch (iocmd) {\n\tcase IOCTL_VMCI_INIT_CONTEXT:\n\t\tVMCI_DO_IOCTL(INIT_CONTEXT, init_context);\n\tcase IOCTL_VMCI_DATAGRAM_SEND:\n\t\tVMCI_DO_IOCTL(DATAGRAM_SEND, send_datagram);\n\tcase IOCTL_VMCI_DATAGRAM_RECEIVE:\n\t\tVMCI_DO_IOCTL(DATAGRAM_RECEIVE, receive_datagram);\n\tcase IOCTL_VMCI_QUEUEPAIR_ALLOC:\n\t\tVMCI_DO_IOCTL(QUEUEPAIR_ALLOC, alloc_queuepair);\n\tcase IOCTL_VMCI_QUEUEPAIR_SETVA:\n\t\tVMCI_DO_IOCTL(QUEUEPAIR_SETVA, queuepair_setva);\n\tcase IOCTL_VMCI_QUEUEPAIR_SETPAGEFILE:\n\t\tVMCI_DO_IOCTL(QUEUEPAIR_SETPAGEFILE, queuepair_setpf);\n\tcase IOCTL_VMCI_QUEUEPAIR_DETACH:\n\t\tVMCI_DO_IOCTL(QUEUEPAIR_DETACH, qp_detach);\n\tcase IOCTL_VMCI_CTX_ADD_NOTIFICATION:\n\t\tVMCI_DO_IOCTL(CTX_ADD_NOTIFICATION, ctx_add_notify);\n\tcase IOCTL_VMCI_CTX_REMOVE_NOTIFICATION:\n\t\tVMCI_DO_IOCTL(CTX_REMOVE_NOTIFICATION, ctx_remove_notify);\n\tcase IOCTL_VMCI_CTX_GET_CPT_STATE:\n\t\tVMCI_DO_IOCTL(CTX_GET_CPT_STATE, ctx_get_cpt_state);\n\tcase IOCTL_VMCI_CTX_SET_CPT_STATE:\n\t\tVMCI_DO_IOCTL(CTX_SET_CPT_STATE, ctx_set_cpt_state);\n\tcase IOCTL_VMCI_GET_CONTEXT_ID:\n\t\tVMCI_DO_IOCTL(GET_CONTEXT_ID, get_context_id);\n\tcase IOCTL_VMCI_SET_NOTIFY:\n\t\tVMCI_DO_IOCTL(SET_NOTIFY, set_notify);\n\tcase IOCTL_VMCI_NOTIFY_RESOURCE:\n\t\tVMCI_DO_IOCTL(NOTIFY_RESOURCE, notify_resource);\n\tcase IOCTL_VMCI_NOTIFICATIONS_RECEIVE:\n\t\tVMCI_DO_IOCTL(NOTIFICATIONS_RECEIVE, recv_notifications);\n\n\tcase IOCTL_VMCI_VERSION:\n\tcase IOCTL_VMCI_VERSION2:\n\t\treturn vmci_host_get_version(vmci_host_dev, iocmd, uptr);\n\n\tdefault:\n\t\tpr_devel(\"%s: Unknown ioctl (iocmd=%d)\\n\", __func__, iocmd);\n\t\treturn -EINVAL;\n\t}\n\n#undef VMCI_DO_IOCTL\n}\n\nstatic const struct file_operations vmuser_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= vmci_host_open,\n\t.release\t= vmci_host_close,\n\t.poll\t\t= vmci_host_poll,\n\t.unlocked_ioctl\t= vmci_host_unlocked_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n};\n\nstatic struct miscdevice vmci_host_miscdev = {\n\t .name = \"vmci\",\n\t .minor = MISC_DYNAMIC_MINOR,\n\t .fops = &vmuser_fops,\n};\n\nint __init vmci_host_init(void)\n{\n\tint error;\n\n\thost_context = vmci_ctx_create(VMCI_HOST_CONTEXT_ID,\n\t\t\t\t\tVMCI_DEFAULT_PROC_PRIVILEGE_FLAGS,\n\t\t\t\t\t-1, VMCI_VERSION, NULL);\n\tif (IS_ERR(host_context)) {\n\t\terror = PTR_ERR(host_context);\n\t\tpr_warn(\"Failed to initialize VMCIContext (error%d)\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = misc_register(&vmci_host_miscdev);\n\tif (error) {\n\t\tpr_warn(\"Module registration error (name=%s, major=%d, minor=%d, err=%d)\\n\",\n\t\t\tvmci_host_miscdev.name,\n\t\t\tMISC_MAJOR, vmci_host_miscdev.minor,\n\t\t\terror);\n\t\tpr_warn(\"Unable to initialize host personality\\n\");\n\t\tvmci_ctx_destroy(host_context);\n\t\treturn error;\n\t}\n\n\tpr_info(\"VMCI host device registered (name=%s, major=%d, minor=%d)\\n\",\n\t\tvmci_host_miscdev.name, MISC_MAJOR, vmci_host_miscdev.minor);\n\n\tvmci_host_device_initialized = true;\n\treturn 0;\n}\n\nvoid __exit vmci_host_exit(void)\n{\n\tvmci_host_device_initialized = false;\n\n\tmisc_deregister(&vmci_host_miscdev);\n\tvmci_ctx_destroy(host_context);\n\tvmci_qp_broker_exit();\n\n\tpr_debug(\"VMCI host driver module unloaded\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}