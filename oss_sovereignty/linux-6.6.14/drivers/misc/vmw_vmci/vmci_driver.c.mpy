{
  "module_name": "vmci_driver.c",
  "hash_id": "5c9183129042dcc51c61d8d1cece4c41f72b6199674e768dbc35de3e3eb10fcf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/vmw_vmci/vmci_driver.c",
  "human_readable_source": "\n \n\n#include <linux/vmw_vmci_defs.h>\n#include <linux/vmw_vmci_api.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#include \"vmci_driver.h\"\n#include \"vmci_event.h\"\n\nstatic bool vmci_disable_host;\nmodule_param_named(disable_host, vmci_disable_host, bool, 0);\nMODULE_PARM_DESC(disable_host,\n\t\t \"Disable driver host personality (default=enabled)\");\n\nstatic bool vmci_disable_guest;\nmodule_param_named(disable_guest, vmci_disable_guest, bool, 0);\nMODULE_PARM_DESC(disable_guest,\n\t\t \"Disable driver guest personality (default=enabled)\");\n\nstatic bool vmci_guest_personality_initialized;\nstatic bool vmci_host_personality_initialized;\n\nstatic DEFINE_MUTEX(vmci_vsock_mutex);  \nstatic vmci_vsock_cb vmci_vsock_transport_cb;\nstatic bool vmci_vsock_cb_host_called;\n\n \nu32 vmci_get_context_id(void)\n{\n\tif (vmci_guest_code_active())\n\t\treturn vmci_get_vm_context_id();\n\telse if (vmci_host_code_active())\n\t\treturn VMCI_HOST_CONTEXT_ID;\n\n\treturn VMCI_INVALID_ID;\n}\nEXPORT_SYMBOL_GPL(vmci_get_context_id);\n\n \nint vmci_register_vsock_callback(vmci_vsock_cb callback)\n{\n\tint err = 0;\n\n\tmutex_lock(&vmci_vsock_mutex);\n\n\tif (vmci_vsock_transport_cb && callback) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tvmci_vsock_transport_cb = callback;\n\n\tif (!vmci_vsock_transport_cb) {\n\t\tvmci_vsock_cb_host_called = false;\n\t\tgoto out;\n\t}\n\n\tif (vmci_guest_code_active())\n\t\tvmci_vsock_transport_cb(false);\n\n\tif (vmci_host_users() > 0) {\n\t\tvmci_vsock_cb_host_called = true;\n\t\tvmci_vsock_transport_cb(true);\n\t}\n\nout:\n\tmutex_unlock(&vmci_vsock_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vmci_register_vsock_callback);\n\nvoid vmci_call_vsock_callback(bool is_host)\n{\n\tmutex_lock(&vmci_vsock_mutex);\n\n\tif (!vmci_vsock_transport_cb)\n\t\tgoto out;\n\n\t \n\tif (is_host) {\n\t\tif (vmci_vsock_cb_host_called)\n\t\t\tgoto out;\n\n\t\tvmci_vsock_cb_host_called = true;\n\t}\n\n\tvmci_vsock_transport_cb(is_host);\nout:\n\tmutex_unlock(&vmci_vsock_mutex);\n}\n\nstatic int __init vmci_drv_init(void)\n{\n\tint vmci_err;\n\tint error;\n\n\tvmci_err = vmci_event_init();\n\tif (vmci_err < VMCI_SUCCESS) {\n\t\tpr_err(\"Failed to initialize VMCIEvent (result=%d)\\n\",\n\t\t       vmci_err);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vmci_disable_guest) {\n\t\terror = vmci_guest_init();\n\t\tif (error) {\n\t\t\tpr_warn(\"Failed to initialize guest personality (err=%d)\\n\",\n\t\t\t\terror);\n\t\t} else {\n\t\t\tvmci_guest_personality_initialized = true;\n\t\t\tpr_info(\"Guest personality initialized and is %s\\n\",\n\t\t\t\tvmci_guest_code_active() ?\n\t\t\t\t\"active\" : \"inactive\");\n\t\t}\n\t}\n\n\tif (!vmci_disable_host) {\n\t\terror = vmci_host_init();\n\t\tif (error) {\n\t\t\tpr_warn(\"Unable to initialize host personality (err=%d)\\n\",\n\t\t\t\terror);\n\t\t} else {\n\t\t\tvmci_host_personality_initialized = true;\n\t\t\tpr_info(\"Initialized host personality\\n\");\n\t\t}\n\t}\n\n\tif (!vmci_guest_personality_initialized &&\n\t    !vmci_host_personality_initialized) {\n\t\tvmci_event_exit();\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\nmodule_init(vmci_drv_init);\n\nstatic void __exit vmci_drv_exit(void)\n{\n\tif (vmci_guest_personality_initialized)\n\t\tvmci_guest_exit();\n\n\tif (vmci_host_personality_initialized)\n\t\tvmci_host_exit();\n\n\tvmci_event_exit();\n}\nmodule_exit(vmci_drv_exit);\n\nMODULE_AUTHOR(\"VMware, Inc.\");\nMODULE_DESCRIPTION(\"VMware Virtual Machine Communication Interface.\");\nMODULE_VERSION(\"1.1.6.0-k\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}