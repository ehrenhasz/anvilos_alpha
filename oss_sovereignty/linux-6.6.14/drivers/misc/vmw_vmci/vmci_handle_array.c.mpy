{
  "module_name": "vmci_handle_array.c",
  "hash_id": "812c9ec0bc5d3ee044aa9ebc6b38c4b40fc5da286f12dcc5a904306eef90b4ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/vmw_vmci/vmci_handle_array.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"vmci_handle_array.h\"\n\nstatic size_t handle_arr_calc_size(u32 capacity)\n{\n\treturn VMCI_HANDLE_ARRAY_HEADER_SIZE +\n\t    capacity * sizeof(struct vmci_handle);\n}\n\nstruct vmci_handle_arr *vmci_handle_arr_create(u32 capacity, u32 max_capacity)\n{\n\tstruct vmci_handle_arr *array;\n\n\tif (max_capacity == 0 || capacity > max_capacity)\n\t\treturn NULL;\n\n\tif (capacity == 0)\n\t\tcapacity = min((u32)VMCI_HANDLE_ARRAY_DEFAULT_CAPACITY,\n\t\t\t       max_capacity);\n\n\tarray = kmalloc(handle_arr_calc_size(capacity), GFP_ATOMIC);\n\tif (!array)\n\t\treturn NULL;\n\n\tarray->capacity = capacity;\n\tarray->max_capacity = max_capacity;\n\tarray->size = 0;\n\n\treturn array;\n}\n\nvoid vmci_handle_arr_destroy(struct vmci_handle_arr *array)\n{\n\tkfree(array);\n}\n\nint vmci_handle_arr_append_entry(struct vmci_handle_arr **array_ptr,\n\t\t\t\t struct vmci_handle handle)\n{\n\tstruct vmci_handle_arr *array = *array_ptr;\n\n\tif (unlikely(array->size >= array->capacity)) {\n\t\t \n\t\tstruct vmci_handle_arr *new_array;\n\t\tu32 capacity_bump = min(array->max_capacity - array->capacity,\n\t\t\t\t\tarray->capacity);\n\t\tsize_t new_size = handle_arr_calc_size(array->capacity +\n\t\t\t\t\t\t       capacity_bump);\n\n\t\tif (array->size >= array->max_capacity)\n\t\t\treturn VMCI_ERROR_NO_MEM;\n\n\t\tnew_array = krealloc(array, new_size, GFP_ATOMIC);\n\t\tif (!new_array)\n\t\t\treturn VMCI_ERROR_NO_MEM;\n\n\t\tnew_array->capacity += capacity_bump;\n\t\t*array_ptr = array = new_array;\n\t}\n\n\tarray->entries[array->size] = handle;\n\tarray->size++;\n\n\treturn VMCI_SUCCESS;\n}\n\n \nstruct vmci_handle vmci_handle_arr_remove_entry(struct vmci_handle_arr *array,\n\t\t\t\t\t\tstruct vmci_handle entry_handle)\n{\n\tstruct vmci_handle handle = VMCI_INVALID_HANDLE;\n\tu32 i;\n\n\tfor (i = 0; i < array->size; i++) {\n\t\tif (vmci_handle_is_equal(array->entries[i], entry_handle)) {\n\t\t\thandle = array->entries[i];\n\t\t\tarray->size--;\n\t\t\tarray->entries[i] = array->entries[array->size];\n\t\t\tarray->entries[array->size] = VMCI_INVALID_HANDLE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn handle;\n}\n\n \nstruct vmci_handle vmci_handle_arr_remove_tail(struct vmci_handle_arr *array)\n{\n\tstruct vmci_handle handle = VMCI_INVALID_HANDLE;\n\n\tif (array->size) {\n\t\tarray->size--;\n\t\thandle = array->entries[array->size];\n\t\tarray->entries[array->size] = VMCI_INVALID_HANDLE;\n\t}\n\n\treturn handle;\n}\n\n \nstruct vmci_handle\nvmci_handle_arr_get_entry(const struct vmci_handle_arr *array, u32 index)\n{\n\tif (unlikely(index >= array->size))\n\t\treturn VMCI_INVALID_HANDLE;\n\n\treturn array->entries[index];\n}\n\nbool vmci_handle_arr_has_entry(const struct vmci_handle_arr *array,\n\t\t\t       struct vmci_handle entry_handle)\n{\n\tu32 i;\n\n\tfor (i = 0; i < array->size; i++)\n\t\tif (vmci_handle_is_equal(array->entries[i], entry_handle))\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstruct vmci_handle *vmci_handle_arr_get_handles(struct vmci_handle_arr *array)\n{\n\tif (array->size)\n\t\treturn array->entries;\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}