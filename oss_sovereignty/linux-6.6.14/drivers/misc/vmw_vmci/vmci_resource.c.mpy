{
  "module_name": "vmci_resource.c",
  "hash_id": "7e053fd3cb9ff6dede97197baa6422c30392185f29dcc0ae858ac59e6fbb001a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/vmw_vmci/vmci_resource.c",
  "human_readable_source": "\n \n\n#include <linux/vmw_vmci_defs.h>\n#include <linux/hash.h>\n#include <linux/types.h>\n#include <linux/rculist.h>\n#include <linux/completion.h>\n\n#include \"vmci_resource.h\"\n#include \"vmci_driver.h\"\n\n\n#define VMCI_RESOURCE_HASH_BITS         7\n#define VMCI_RESOURCE_HASH_BUCKETS      (1 << VMCI_RESOURCE_HASH_BITS)\n\nstruct vmci_hash_table {\n\tspinlock_t lock;\n\tstruct hlist_head entries[VMCI_RESOURCE_HASH_BUCKETS];\n};\n\nstatic struct vmci_hash_table vmci_resource_table = {\n\t.lock = __SPIN_LOCK_UNLOCKED(vmci_resource_table.lock),\n};\n\nstatic unsigned int vmci_resource_hash(struct vmci_handle handle)\n{\n\treturn hash_32(handle.resource, VMCI_RESOURCE_HASH_BITS);\n}\n\n \nstatic struct vmci_resource *vmci_resource_lookup(struct vmci_handle handle,\n\t\t\t\t\t\t  enum vmci_resource_type type)\n{\n\tstruct vmci_resource *r, *resource = NULL;\n\tunsigned int idx = vmci_resource_hash(handle);\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(r,\n\t\t\t\t &vmci_resource_table.entries[idx], node) {\n\t\tu32 cid = r->handle.context;\n\t\tu32 rid = r->handle.resource;\n\n\t\tif (r->type == type &&\n\t\t    rid == handle.resource &&\n\t\t    (cid == handle.context || cid == VMCI_INVALID_ID ||\n\t\t     handle.context == VMCI_INVALID_ID)) {\n\t\t\tresource = r;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn resource;\n}\n\n \nstatic u32 vmci_resource_find_id(u32 context_id,\n\t\t\t\t enum vmci_resource_type resource_type)\n{\n\tstatic u32 resource_id = VMCI_RESERVED_RESOURCE_ID_MAX + 1;\n\tu32 old_rid = resource_id;\n\tu32 current_rid;\n\n\t \n\tdo {\n\t\tstruct vmci_handle handle;\n\n\t\tcurrent_rid = resource_id;\n\t\tresource_id++;\n\t\tif (unlikely(resource_id == VMCI_INVALID_ID)) {\n\t\t\t \n\t\t\tresource_id = VMCI_RESERVED_RESOURCE_ID_MAX + 1;\n\t\t}\n\n\t\thandle = vmci_make_handle(context_id, current_rid);\n\t\tif (!vmci_resource_lookup(handle, resource_type))\n\t\t\treturn current_rid;\n\t} while (resource_id != old_rid);\n\n\treturn VMCI_INVALID_ID;\n}\n\n\nint vmci_resource_add(struct vmci_resource *resource,\n\t\t      enum vmci_resource_type resource_type,\n\t\t      struct vmci_handle handle)\n\n{\n\tunsigned int idx;\n\tint result;\n\n\tspin_lock(&vmci_resource_table.lock);\n\n\tif (handle.resource == VMCI_INVALID_ID) {\n\t\thandle.resource = vmci_resource_find_id(handle.context,\n\t\t\tresource_type);\n\t\tif (handle.resource == VMCI_INVALID_ID) {\n\t\t\tresult = VMCI_ERROR_NO_HANDLE;\n\t\t\tgoto out;\n\t\t}\n\t} else if (vmci_resource_lookup(handle, resource_type)) {\n\t\tresult = VMCI_ERROR_ALREADY_EXISTS;\n\t\tgoto out;\n\t}\n\n\tresource->handle = handle;\n\tresource->type = resource_type;\n\tINIT_HLIST_NODE(&resource->node);\n\tkref_init(&resource->kref);\n\tinit_completion(&resource->done);\n\n\tidx = vmci_resource_hash(resource->handle);\n\thlist_add_head_rcu(&resource->node, &vmci_resource_table.entries[idx]);\n\n\tresult = VMCI_SUCCESS;\n\nout:\n\tspin_unlock(&vmci_resource_table.lock);\n\treturn result;\n}\n\nvoid vmci_resource_remove(struct vmci_resource *resource)\n{\n\tstruct vmci_handle handle = resource->handle;\n\tunsigned int idx = vmci_resource_hash(handle);\n\tstruct vmci_resource *r;\n\n\t \n\tspin_lock(&vmci_resource_table.lock);\n\n\thlist_for_each_entry(r, &vmci_resource_table.entries[idx], node) {\n\t\tif (vmci_handle_is_equal(r->handle, resource->handle)) {\n\t\t\thlist_del_init_rcu(&r->node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&vmci_resource_table.lock);\n\tsynchronize_rcu();\n\n\tvmci_resource_put(resource);\n\twait_for_completion(&resource->done);\n}\n\nstruct vmci_resource *\nvmci_resource_by_handle(struct vmci_handle resource_handle,\n\t\t\tenum vmci_resource_type resource_type)\n{\n\tstruct vmci_resource *r, *resource = NULL;\n\n\trcu_read_lock();\n\n\tr = vmci_resource_lookup(resource_handle, resource_type);\n\tif (r &&\n\t    (resource_type == r->type ||\n\t     resource_type == VMCI_RESOURCE_TYPE_ANY)) {\n\t\tresource = vmci_resource_get(r);\n\t}\n\n\trcu_read_unlock();\n\n\treturn resource;\n}\n\n \nstruct vmci_resource *vmci_resource_get(struct vmci_resource *resource)\n{\n\tkref_get(&resource->kref);\n\n\treturn resource;\n}\n\nstatic void vmci_release_resource(struct kref *kref)\n{\n\tstruct vmci_resource *resource =\n\t\tcontainer_of(kref, struct vmci_resource, kref);\n\n\t \n\tWARN_ON(!hlist_unhashed(&resource->node));\n\n\t \n\tcomplete(&resource->done);\n}\n\n \nint vmci_resource_put(struct vmci_resource *resource)\n{\n\t \n\treturn kref_put(&resource->kref, vmci_release_resource) ?\n\t\tVMCI_SUCCESS_ENTRY_DEAD : VMCI_SUCCESS;\n}\n\nstruct vmci_handle vmci_resource_handle(struct vmci_resource *resource)\n{\n\treturn resource->handle;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}