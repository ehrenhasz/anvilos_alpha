{
  "module_name": "vmci_event.c",
  "hash_id": "959e6e4898242efc34644dc50f5143e92bc44eb177c3814d9a29f0733f16f4c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/vmw_vmci/vmci_event.c",
  "human_readable_source": "\n \n\n#include <linux/vmw_vmci_defs.h>\n#include <linux/vmw_vmci_api.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n\n#include \"vmci_driver.h\"\n#include \"vmci_event.h\"\n\n#define EVENT_MAGIC 0xEABE0000\n#define VMCI_EVENT_MAX_ATTEMPTS 10\n\nstruct vmci_subscription {\n\tu32 id;\n\tu32 event;\n\tvmci_event_cb callback;\n\tvoid *callback_data;\n\tstruct list_head node;\t \n};\n\nstatic struct list_head subscriber_array[VMCI_EVENT_MAX];\nstatic DEFINE_MUTEX(subscriber_mutex);\n\nint __init vmci_event_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < VMCI_EVENT_MAX; i++)\n\t\tINIT_LIST_HEAD(&subscriber_array[i]);\n\n\treturn VMCI_SUCCESS;\n}\n\nvoid vmci_event_exit(void)\n{\n\tint e;\n\n\t \n\tfor (e = 0; e < VMCI_EVENT_MAX; e++) {\n\t\tstruct vmci_subscription *cur, *p2;\n\t\tlist_for_each_entry_safe(cur, p2, &subscriber_array[e], node) {\n\n\t\t\t \n\t\t\tpr_warn(\"Unexpected free events occurring\\n\");\n\t\t\tlist_del(&cur->node);\n\t\t\tkfree(cur);\n\t\t}\n\t}\n}\n\n \nstatic struct vmci_subscription *event_find(u32 sub_id)\n{\n\tint e;\n\n\tfor (e = 0; e < VMCI_EVENT_MAX; e++) {\n\t\tstruct vmci_subscription *cur;\n\t\tlist_for_each_entry(cur, &subscriber_array[e], node) {\n\t\t\tif (cur->id == sub_id)\n\t\t\t\treturn cur;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic void event_deliver(struct vmci_event_msg *event_msg)\n{\n\tstruct vmci_subscription *cur;\n\tstruct list_head *subscriber_list;\n\n\trcu_read_lock();\n\tsubscriber_list = &subscriber_array[event_msg->event_data.event];\n\tlist_for_each_entry_rcu(cur, subscriber_list, node) {\n\t\tcur->callback(cur->id, &event_msg->event_data,\n\t\t\t      cur->callback_data);\n\t}\n\trcu_read_unlock();\n}\n\n \nint vmci_event_dispatch(struct vmci_datagram *msg)\n{\n\tstruct vmci_event_msg *event_msg = (struct vmci_event_msg *)msg;\n\n\tif (msg->payload_size < sizeof(u32) ||\n\t    msg->payload_size > sizeof(struct vmci_event_data_max))\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tif (!VMCI_EVENT_VALID(event_msg->event_data.event))\n\t\treturn VMCI_ERROR_EVENT_UNKNOWN;\n\n\tevent_deliver(event_msg);\n\treturn VMCI_SUCCESS;\n}\n\n \nint vmci_event_subscribe(u32 event,\n\t\t\t vmci_event_cb callback,\n\t\t\t void *callback_data,\n\t\t\t u32 *new_subscription_id)\n{\n\tstruct vmci_subscription *sub;\n\tint attempts;\n\tint retval;\n\tbool have_new_id = false;\n\n\tif (!new_subscription_id) {\n\t\tpr_devel(\"%s: Invalid subscription (NULL)\\n\", __func__);\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!VMCI_EVENT_VALID(event) || !callback) {\n\t\tpr_devel(\"%s: Failed to subscribe to event (type=%d) (callback=%p) (data=%p)\\n\",\n\t\t\t __func__, event, callback, callback_data);\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\t}\n\n\tsub = kzalloc(sizeof(*sub), GFP_KERNEL);\n\tif (!sub)\n\t\treturn VMCI_ERROR_NO_MEM;\n\n\tsub->id = VMCI_EVENT_MAX;\n\tsub->event = event;\n\tsub->callback = callback;\n\tsub->callback_data = callback_data;\n\tINIT_LIST_HEAD(&sub->node);\n\n\tmutex_lock(&subscriber_mutex);\n\n\t \n\tfor (attempts = 0; attempts < VMCI_EVENT_MAX_ATTEMPTS; attempts++) {\n\t\tstatic u32 subscription_id;\n\t\t \n\n\t\t \n\t\tif (!event_find(++subscription_id)) {\n\t\t\tsub->id = subscription_id;\n\t\t\thave_new_id = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (have_new_id) {\n\t\tlist_add_rcu(&sub->node, &subscriber_array[event]);\n\t\tretval = VMCI_SUCCESS;\n\t} else {\n\t\tretval = VMCI_ERROR_NO_RESOURCES;\n\t}\n\n\tmutex_unlock(&subscriber_mutex);\n\n\t*new_subscription_id = sub->id;\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(vmci_event_subscribe);\n\n \nint vmci_event_unsubscribe(u32 sub_id)\n{\n\tstruct vmci_subscription *s;\n\n\tmutex_lock(&subscriber_mutex);\n\ts = event_find(sub_id);\n\tif (s)\n\t\tlist_del_rcu(&s->node);\n\tmutex_unlock(&subscriber_mutex);\n\n\tif (!s)\n\t\treturn VMCI_ERROR_NOT_FOUND;\n\n\tkvfree_rcu_mightsleep(s);\n\n\treturn VMCI_SUCCESS;\n}\nEXPORT_SYMBOL_GPL(vmci_event_unsubscribe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}