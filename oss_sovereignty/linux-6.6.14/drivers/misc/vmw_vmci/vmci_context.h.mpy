{
  "module_name": "vmci_context.h",
  "hash_id": "6cfba3dd15fe1f61751df06d91d2399549022999f6664539aed87a0b17f5c86f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/vmw_vmci/vmci_context.h",
  "human_readable_source": " \n \n\n#ifndef _VMCI_CONTEXT_H_\n#define _VMCI_CONTEXT_H_\n\n#include <linux/vmw_vmci_defs.h>\n#include <linux/atomic.h>\n#include <linux/kref.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n\n#include \"vmci_handle_array.h\"\n#include \"vmci_datagram.h\"\n\n \nenum {\n\tVMCI_NOTIFICATION_CPT_STATE = 1,\n\tVMCI_WELLKNOWN_CPT_STATE    = 2,\n\tVMCI_DG_OUT_STATE           = 3,\n\tVMCI_DG_IN_STATE            = 4,\n\tVMCI_DG_IN_SIZE_STATE       = 5,\n\tVMCI_DOORBELL_CPT_STATE     = 6,\n};\n\n \nstruct vmci_host {\n\twait_queue_head_t wait_queue;\n};\n\nstruct vmci_handle_list {\n\tstruct list_head node;\n\tstruct vmci_handle handle;\n};\n\nstruct vmci_ctx {\n\tstruct list_head list_item;        \n\tu32 cid;\n\tstruct kref kref;\n\tstruct list_head datagram_queue;   \n\tu32 pending_datagrams;\n\tsize_t datagram_queue_size;\t   \n\n\t \n\tint user_version;\n\tspinlock_t lock;   \n\n\t \n\tstruct vmci_handle_arr *queue_pair_array;\n\n\t \n\tstruct vmci_handle_arr *doorbell_array;\n\n\t \n\tstruct vmci_handle_arr *pending_doorbell_array;\n\n\t \n\tstruct list_head notifier_list;\n\tunsigned int n_notifiers;\n\n\tstruct vmci_host host_context;\n\tu32 priv_flags;\n\n\tconst struct cred *cred;\n\tbool *notify;\t\t \n\tstruct page *notify_page;\t \n};\n\n \nstruct vmci_ctx_info {\n\tu32 remote_cid;\n\tint result;\n};\n\n \nstruct vmci_ctx_chkpt_buf_info {\n\tu64 cpt_buf;\n\tu32 cpt_type;\n\tu32 buf_size;\n\ts32 result;\n\tu32 _pad;\n};\n\n \nstruct vmci_ctx_notify_recv_info {\n\tu64 db_handle_buf_uva;\n\tu64 db_handle_buf_size;\n\tu64 qp_handle_buf_uva;\n\tu64 qp_handle_buf_size;\n\ts32 result;\n\tu32 _pad;\n};\n\n \nstatic inline bool vmci_deny_interaction(u32 part_one, u32 part_two)\n{\n\treturn ((part_one & VMCI_PRIVILEGE_FLAG_RESTRICTED) &&\n\t\t!(part_two & VMCI_PRIVILEGE_FLAG_TRUSTED)) ||\n\t       ((part_two & VMCI_PRIVILEGE_FLAG_RESTRICTED) &&\n\t\t!(part_one & VMCI_PRIVILEGE_FLAG_TRUSTED));\n}\n\nstruct vmci_ctx *vmci_ctx_create(u32 cid, u32 flags,\n\t\t\t\t uintptr_t event_hnd, int version,\n\t\t\t\t const struct cred *cred);\nvoid vmci_ctx_destroy(struct vmci_ctx *context);\n\nbool vmci_ctx_supports_host_qp(struct vmci_ctx *context);\nint vmci_ctx_enqueue_datagram(u32 cid, struct vmci_datagram *dg);\nint vmci_ctx_dequeue_datagram(struct vmci_ctx *context,\n\t\t\t      size_t *max_size, struct vmci_datagram **dg);\nint vmci_ctx_pending_datagrams(u32 cid, u32 *pending);\nstruct vmci_ctx *vmci_ctx_get(u32 cid);\nvoid vmci_ctx_put(struct vmci_ctx *context);\nbool vmci_ctx_exists(u32 cid);\n\nint vmci_ctx_add_notification(u32 context_id, u32 remote_cid);\nint vmci_ctx_remove_notification(u32 context_id, u32 remote_cid);\nint vmci_ctx_get_chkpt_state(u32 context_id, u32 cpt_type,\n\t\t\t     u32 *num_cids, void **cpt_buf_ptr);\nint vmci_ctx_set_chkpt_state(u32 context_id, u32 cpt_type,\n\t\t\t     u32 num_cids, void *cpt_buf);\n\nint vmci_ctx_qp_create(struct vmci_ctx *context, struct vmci_handle handle);\nint vmci_ctx_qp_destroy(struct vmci_ctx *context, struct vmci_handle handle);\nbool vmci_ctx_qp_exists(struct vmci_ctx *context, struct vmci_handle handle);\n\nvoid vmci_ctx_check_signal_notify(struct vmci_ctx *context);\nvoid vmci_ctx_unset_notify(struct vmci_ctx *context);\n\nint vmci_ctx_dbell_create(u32 context_id, struct vmci_handle handle);\nint vmci_ctx_dbell_destroy(u32 context_id, struct vmci_handle handle);\nint vmci_ctx_dbell_destroy_all(u32 context_id);\nint vmci_ctx_notify_dbell(u32 cid, struct vmci_handle handle,\n\t\t\t  u32 src_priv_flags);\n\nint vmci_ctx_rcv_notifications_get(u32 context_id, struct vmci_handle_arr\n\t\t\t\t   **db_handle_array, struct vmci_handle_arr\n\t\t\t\t   **qp_handle_array);\nvoid vmci_ctx_rcv_notifications_release(u32 context_id, struct vmci_handle_arr\n\t\t\t\t\t*db_handle_array, struct vmci_handle_arr\n\t\t\t\t\t*qp_handle_array, bool success);\n\nstatic inline u32 vmci_ctx_get_id(struct vmci_ctx *context)\n{\n\tif (!context)\n\t\treturn VMCI_INVALID_ID;\n\treturn context->cid;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}