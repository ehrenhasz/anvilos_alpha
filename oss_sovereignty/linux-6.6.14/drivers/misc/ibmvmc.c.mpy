{
  "module_name": "ibmvmc.c",
  "hash_id": "f58ef6358ee72f5fed219efe61941f4e2f9bd655292c35a02f7b51717b9bf8dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ibmvmc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/miscdevice.h>\n#include <linux/sched/signal.h>\n\n#include <asm/byteorder.h>\n#include <asm/irq.h>\n#include <asm/vio.h>\n\n#include \"ibmvmc.h\"\n\n#define IBMVMC_DRIVER_VERSION \"1.0\"\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(ibmvmc_read_wait);\n\nstatic const char ibmvmc_driver_name[] = \"ibmvmc\";\n\nstatic struct ibmvmc_struct ibmvmc;\nstatic struct ibmvmc_hmc hmcs[MAX_HMCS];\nstatic struct crq_server_adapter ibmvmc_adapter;\n\nstatic int ibmvmc_max_buf_pool_size = DEFAULT_BUF_POOL_SIZE;\nstatic int ibmvmc_max_hmcs = DEFAULT_HMCS;\nstatic int ibmvmc_max_mtu = DEFAULT_MTU;\n\nstatic inline long h_copy_rdma(s64 length, u64 sliobn, u64 slioba,\n\t\t\t       u64 dliobn, u64 dlioba)\n{\n\tlong rc = 0;\n\n\t \n\tdma_wmb();\n\tpr_debug(\"ibmvmc: h_copy_rdma(0x%llx, 0x%llx, 0x%llx, 0x%llx, 0x%llx\\n\",\n\t\t length, sliobn, slioba, dliobn, dlioba);\n\trc = plpar_hcall_norets(H_COPY_RDMA, length, sliobn, slioba,\n\t\t\t\tdliobn, dlioba);\n\tpr_debug(\"ibmvmc: h_copy_rdma rc = 0x%lx\\n\", rc);\n\n\treturn rc;\n}\n\nstatic inline void h_free_crq(uint32_t unit_address)\n{\n\tlong rc = 0;\n\n\tdo {\n\t\tif (H_IS_LONG_BUSY(rc))\n\t\t\tmsleep(get_longbusy_msecs(rc));\n\n\t\trc = plpar_hcall_norets(H_FREE_CRQ, unit_address);\n\t} while ((rc == H_BUSY) || (H_IS_LONG_BUSY(rc)));\n}\n\n \nstatic inline long h_request_vmc(u32 *vmc_index)\n{\n\tlong rc = 0;\n\tunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\n\n\tdo {\n\t\tif (H_IS_LONG_BUSY(rc))\n\t\t\tmsleep(get_longbusy_msecs(rc));\n\n\t\t \n\t\trc = plpar_hcall(H_REQUEST_VMC, retbuf);\n\t\tpr_debug(\"ibmvmc: %s rc = 0x%lx\\n\", __func__, rc);\n\t\t*vmc_index = retbuf[0];\n\t} while ((rc == H_BUSY) || (H_IS_LONG_BUSY(rc)));\n\n\treturn rc;\n}\n\n \n \nstatic irqreturn_t ibmvmc_handle_event(int irq, void *dev_instance)\n{\n\tstruct crq_server_adapter *adapter =\n\t\t(struct crq_server_adapter *)dev_instance;\n\n\tvio_disable_interrupts(to_vio_dev(adapter->dev));\n\ttasklet_schedule(&adapter->work_task);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void ibmvmc_release_crq_queue(struct crq_server_adapter *adapter)\n{\n\tstruct vio_dev *vdev = to_vio_dev(adapter->dev);\n\tstruct crq_queue *queue = &adapter->queue;\n\n\tfree_irq(vdev->irq, (void *)adapter);\n\ttasklet_kill(&adapter->work_task);\n\n\tif (adapter->reset_task)\n\t\tkthread_stop(adapter->reset_task);\n\n\th_free_crq(vdev->unit_address);\n\tdma_unmap_single(adapter->dev,\n\t\t\t queue->msg_token,\n\t\t\t queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);\n\tfree_page((unsigned long)queue->msgs);\n}\n\n \nstatic int ibmvmc_reset_crq_queue(struct crq_server_adapter *adapter)\n{\n\tstruct vio_dev *vdev = to_vio_dev(adapter->dev);\n\tstruct crq_queue *queue = &adapter->queue;\n\tint rc = 0;\n\n\t \n\th_free_crq(vdev->unit_address);\n\n\t \n\tmemset(queue->msgs, 0x00, PAGE_SIZE);\n\tqueue->cur = 0;\n\n\t \n\trc = plpar_hcall_norets(H_REG_CRQ,\n\t\t\t\tvdev->unit_address,\n\t\t\t\tqueue->msg_token, PAGE_SIZE);\n\tif (rc == 2)\n\t\t \n\t\tdev_warn(adapter->dev, \"Partner adapter not ready\\n\");\n\telse if (rc != 0)\n\t\tdev_err(adapter->dev, \"couldn't register crq--rc 0x%x\\n\", rc);\n\n\treturn rc;\n}\n\n \nstatic struct ibmvmc_crq_msg *crq_queue_next_crq(struct crq_queue *queue)\n{\n\tstruct ibmvmc_crq_msg *crq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->lock, flags);\n\tcrq = &queue->msgs[queue->cur];\n\tif (crq->valid & 0x80) {\n\t\tif (++queue->cur == queue->size)\n\t\t\tqueue->cur = 0;\n\n\t\t \n\t\tdma_rmb();\n\t} else {\n\t\tcrq = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&queue->lock, flags);\n\n\treturn crq;\n}\n\n \nstatic long ibmvmc_send_crq(struct crq_server_adapter *adapter,\n\t\t\t    u64 word1, u64 word2)\n{\n\tstruct vio_dev *vdev = to_vio_dev(adapter->dev);\n\tlong rc = 0;\n\n\tdev_dbg(adapter->dev, \"(0x%x, 0x%016llx, 0x%016llx)\\n\",\n\t\tvdev->unit_address, word1, word2);\n\n\t \n\tdma_wmb();\n\trc = plpar_hcall_norets(H_SEND_CRQ, vdev->unit_address, word1, word2);\n\tdev_dbg(adapter->dev, \"rc = 0x%lx\\n\", rc);\n\n\treturn rc;\n}\n\n \nstatic void *alloc_dma_buffer(struct vio_dev *vdev, size_t size,\n\t\t\t      dma_addr_t *dma_handle)\n{\n\t \n\tvoid *buffer = kzalloc(size, GFP_ATOMIC);\n\n\tif (!buffer) {\n\t\t*dma_handle = 0;\n\t\treturn NULL;\n\t}\n\n\t \n\t*dma_handle = dma_map_single(&vdev->dev, buffer, size,\n\t\t\t\t     DMA_BIDIRECTIONAL);\n\n\tif (dma_mapping_error(&vdev->dev, *dma_handle)) {\n\t\t*dma_handle = 0;\n\t\tkfree_sensitive(buffer);\n\t\treturn NULL;\n\t}\n\n\treturn buffer;\n}\n\n \nstatic void free_dma_buffer(struct vio_dev *vdev, size_t size, void *vaddr,\n\t\t\t    dma_addr_t dma_handle)\n{\n\t \n\tdma_unmap_single(&vdev->dev, dma_handle, size, DMA_BIDIRECTIONAL);\n\n\t \n\tkfree_sensitive(vaddr);\n}\n\n \nstatic struct ibmvmc_buffer *ibmvmc_get_valid_hmc_buffer(u8 hmc_index)\n{\n\tstruct ibmvmc_buffer *buffer;\n\tstruct ibmvmc_buffer *ret_buf = NULL;\n\tunsigned long i;\n\n\tif (hmc_index > ibmvmc.max_hmc_index)\n\t\treturn NULL;\n\n\tbuffer = hmcs[hmc_index].buffer;\n\n\tfor (i = 0; i < ibmvmc_max_buf_pool_size; i++) {\n\t\tif (buffer[i].valid && buffer[i].free &&\n\t\t    buffer[i].owner == VMC_BUF_OWNER_ALPHA) {\n\t\t\tbuffer[i].free = 0;\n\t\t\tret_buf = &buffer[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret_buf;\n}\n\n \nstatic struct ibmvmc_buffer *ibmvmc_get_free_hmc_buffer(struct crq_server_adapter *adapter,\n\t\t\t\t\t\t\tu8 hmc_index)\n{\n\tstruct ibmvmc_buffer *buffer;\n\tstruct ibmvmc_buffer *ret_buf = NULL;\n\tunsigned long i;\n\n\tif (hmc_index > ibmvmc.max_hmc_index) {\n\t\tdev_info(adapter->dev, \"get_free_hmc_buffer: invalid hmc_index=0x%x\\n\",\n\t\t\t hmc_index);\n\t\treturn NULL;\n\t}\n\n\tbuffer = hmcs[hmc_index].buffer;\n\n\tfor (i = 0; i < ibmvmc_max_buf_pool_size; i++) {\n\t\tif (buffer[i].free &&\n\t\t    buffer[i].owner == VMC_BUF_OWNER_ALPHA) {\n\t\t\tbuffer[i].free = 0;\n\t\t\tret_buf = &buffer[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret_buf;\n}\n\n \nstatic void ibmvmc_free_hmc_buffer(struct ibmvmc_hmc *hmc,\n\t\t\t\t   struct ibmvmc_buffer *buffer)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hmc->lock, flags);\n\tbuffer->free = 1;\n\tspin_unlock_irqrestore(&hmc->lock, flags);\n}\n\n \nstatic void ibmvmc_count_hmc_buffers(u8 hmc_index, unsigned int *valid,\n\t\t\t\t     unsigned int *free)\n{\n\tstruct ibmvmc_buffer *buffer;\n\tunsigned long i;\n\tunsigned long flags;\n\n\tif (hmc_index > ibmvmc.max_hmc_index)\n\t\treturn;\n\n\tif (!valid || !free)\n\t\treturn;\n\n\t*valid = 0; *free = 0;\n\n\tbuffer = hmcs[hmc_index].buffer;\n\tspin_lock_irqsave(&hmcs[hmc_index].lock, flags);\n\n\tfor (i = 0; i < ibmvmc_max_buf_pool_size; i++) {\n\t\tif (buffer[i].valid) {\n\t\t\t*valid = *valid + 1;\n\t\t\tif (buffer[i].free)\n\t\t\t\t*free = *free + 1;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&hmcs[hmc_index].lock, flags);\n}\n\n \nstatic struct ibmvmc_hmc *ibmvmc_get_free_hmc(void)\n{\n\tunsigned long i;\n\tunsigned long flags;\n\n\t \n\tfor (i = 0; i <= ibmvmc.max_hmc_index; i++) {\n\t\tspin_lock_irqsave(&hmcs[i].lock, flags);\n\t\tif (hmcs[i].state == ibmhmc_state_free) {\n\t\t\thmcs[i].index = i;\n\t\t\thmcs[i].state = ibmhmc_state_initial;\n\t\t\tspin_unlock_irqrestore(&hmcs[i].lock, flags);\n\t\t\treturn &hmcs[i];\n\t\t}\n\t\tspin_unlock_irqrestore(&hmcs[i].lock, flags);\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int ibmvmc_return_hmc(struct ibmvmc_hmc *hmc, bool release_readers)\n{\n\tstruct ibmvmc_buffer *buffer;\n\tstruct crq_server_adapter *adapter;\n\tstruct vio_dev *vdev;\n\tunsigned long i;\n\tunsigned long flags;\n\n\tif (!hmc || !hmc->adapter)\n\t\treturn -EIO;\n\n\tif (release_readers) {\n\t\tif (hmc->file_session) {\n\t\t\tstruct ibmvmc_file_session *session = hmc->file_session;\n\n\t\t\tsession->valid = 0;\n\t\t\twake_up_interruptible(&ibmvmc_read_wait);\n\t\t}\n\t}\n\n\tadapter = hmc->adapter;\n\tvdev = to_vio_dev(adapter->dev);\n\n\tspin_lock_irqsave(&hmc->lock, flags);\n\thmc->index = 0;\n\thmc->state = ibmhmc_state_free;\n\thmc->queue_head = 0;\n\thmc->queue_tail = 0;\n\tbuffer = hmc->buffer;\n\tfor (i = 0; i < ibmvmc_max_buf_pool_size; i++) {\n\t\tif (buffer[i].valid) {\n\t\t\tfree_dma_buffer(vdev,\n\t\t\t\t\tibmvmc.max_mtu,\n\t\t\t\t\tbuffer[i].real_addr_local,\n\t\t\t\t\tbuffer[i].dma_addr_local);\n\t\t\tdev_dbg(adapter->dev, \"Forgot buffer id 0x%lx\\n\", i);\n\t\t}\n\t\tmemset(&buffer[i], 0, sizeof(struct ibmvmc_buffer));\n\n\t\thmc->queue_outbound_msgs[i] = VMC_INVALID_BUFFER_ID;\n\t}\n\n\tspin_unlock_irqrestore(&hmc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int ibmvmc_send_open(struct ibmvmc_buffer *buffer,\n\t\t\t    struct ibmvmc_hmc *hmc)\n{\n\tstruct ibmvmc_crq_msg crq_msg;\n\tstruct crq_server_adapter *adapter;\n\t__be64 *crq_as_u64 = (__be64 *)&crq_msg;\n\tint rc = 0;\n\n\tif (!hmc || !hmc->adapter)\n\t\treturn -EIO;\n\n\tadapter = hmc->adapter;\n\n\tdev_dbg(adapter->dev, \"send_open: 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t(unsigned long)buffer->size, (unsigned long)adapter->liobn,\n\t\t(unsigned long)buffer->dma_addr_local,\n\t\t(unsigned long)adapter->riobn,\n\t\t(unsigned long)buffer->dma_addr_remote);\n\n\trc = h_copy_rdma(buffer->size,\n\t\t\t adapter->liobn,\n\t\t\t buffer->dma_addr_local,\n\t\t\t adapter->riobn,\n\t\t\t buffer->dma_addr_remote);\n\tif (rc) {\n\t\tdev_err(adapter->dev, \"Error: In send_open, h_copy_rdma rc 0x%x\\n\",\n\t\t\trc);\n\t\treturn -EIO;\n\t}\n\n\thmc->state = ibmhmc_state_opening;\n\n\tcrq_msg.valid = 0x80;\n\tcrq_msg.type = VMC_MSG_OPEN;\n\tcrq_msg.status = 0;\n\tcrq_msg.var1.rsvd = 0;\n\tcrq_msg.hmc_session = hmc->session;\n\tcrq_msg.hmc_index = hmc->index;\n\tcrq_msg.var2.buffer_id = cpu_to_be16(buffer->id);\n\tcrq_msg.rsvd = 0;\n\tcrq_msg.var3.rsvd = 0;\n\n\tibmvmc_send_crq(adapter, be64_to_cpu(crq_as_u64[0]),\n\t\t\tbe64_to_cpu(crq_as_u64[1]));\n\n\treturn rc;\n}\n\n \nstatic int ibmvmc_send_close(struct ibmvmc_hmc *hmc)\n{\n\tstruct ibmvmc_crq_msg crq_msg;\n\tstruct crq_server_adapter *adapter;\n\t__be64 *crq_as_u64 = (__be64 *)&crq_msg;\n\tint rc = 0;\n\n\tif (!hmc || !hmc->adapter)\n\t\treturn -EIO;\n\n\tadapter = hmc->adapter;\n\n\tdev_info(adapter->dev, \"CRQ send: close\\n\");\n\n\tcrq_msg.valid = 0x80;\n\tcrq_msg.type = VMC_MSG_CLOSE;\n\tcrq_msg.status = 0;\n\tcrq_msg.var1.rsvd = 0;\n\tcrq_msg.hmc_session = hmc->session;\n\tcrq_msg.hmc_index = hmc->index;\n\tcrq_msg.var2.rsvd = 0;\n\tcrq_msg.rsvd = 0;\n\tcrq_msg.var3.rsvd = 0;\n\n\tibmvmc_send_crq(adapter, be64_to_cpu(crq_as_u64[0]),\n\t\t\tbe64_to_cpu(crq_as_u64[1]));\n\n\treturn rc;\n}\n\n \nstatic int ibmvmc_send_capabilities(struct crq_server_adapter *adapter)\n{\n\tstruct ibmvmc_admin_crq_msg crq_msg;\n\t__be64 *crq_as_u64 = (__be64 *)&crq_msg;\n\n\tdev_dbg(adapter->dev, \"ibmvmc: CRQ send: capabilities\\n\");\n\tcrq_msg.valid = 0x80;\n\tcrq_msg.type = VMC_MSG_CAP;\n\tcrq_msg.status = 0;\n\tcrq_msg.rsvd[0] = 0;\n\tcrq_msg.rsvd[1] = 0;\n\tcrq_msg.max_hmc = ibmvmc_max_hmcs;\n\tcrq_msg.max_mtu = cpu_to_be32(ibmvmc_max_mtu);\n\tcrq_msg.pool_size = cpu_to_be16(ibmvmc_max_buf_pool_size);\n\tcrq_msg.crq_size = cpu_to_be16(adapter->queue.size);\n\tcrq_msg.version = cpu_to_be16(IBMVMC_PROTOCOL_VERSION);\n\n\tibmvmc_send_crq(adapter, be64_to_cpu(crq_as_u64[0]),\n\t\t\tbe64_to_cpu(crq_as_u64[1]));\n\n\tibmvmc.state = ibmvmc_state_capabilities;\n\n\treturn 0;\n}\n\n \nstatic int ibmvmc_send_add_buffer_resp(struct crq_server_adapter *adapter,\n\t\t\t\t       u8 status, u8 hmc_session,\n\t\t\t\t       u8 hmc_index, u16 buffer_id)\n{\n\tstruct ibmvmc_crq_msg crq_msg;\n\t__be64 *crq_as_u64 = (__be64 *)&crq_msg;\n\n\tdev_dbg(adapter->dev, \"CRQ send: add_buffer_resp\\n\");\n\tcrq_msg.valid = 0x80;\n\tcrq_msg.type = VMC_MSG_ADD_BUF_RESP;\n\tcrq_msg.status = status;\n\tcrq_msg.var1.rsvd = 0;\n\tcrq_msg.hmc_session = hmc_session;\n\tcrq_msg.hmc_index = hmc_index;\n\tcrq_msg.var2.buffer_id = cpu_to_be16(buffer_id);\n\tcrq_msg.rsvd = 0;\n\tcrq_msg.var3.rsvd = 0;\n\n\tibmvmc_send_crq(adapter, be64_to_cpu(crq_as_u64[0]),\n\t\t\tbe64_to_cpu(crq_as_u64[1]));\n\n\treturn 0;\n}\n\n \nstatic int ibmvmc_send_rem_buffer_resp(struct crq_server_adapter *adapter,\n\t\t\t\t       u8 status, u8 hmc_session,\n\t\t\t\t       u8 hmc_index, u16 buffer_id)\n{\n\tstruct ibmvmc_crq_msg crq_msg;\n\t__be64 *crq_as_u64 = (__be64 *)&crq_msg;\n\n\tdev_dbg(adapter->dev, \"CRQ send: rem_buffer_resp\\n\");\n\tcrq_msg.valid = 0x80;\n\tcrq_msg.type = VMC_MSG_REM_BUF_RESP;\n\tcrq_msg.status = status;\n\tcrq_msg.var1.rsvd = 0;\n\tcrq_msg.hmc_session = hmc_session;\n\tcrq_msg.hmc_index = hmc_index;\n\tcrq_msg.var2.buffer_id = cpu_to_be16(buffer_id);\n\tcrq_msg.rsvd = 0;\n\tcrq_msg.var3.rsvd = 0;\n\n\tibmvmc_send_crq(adapter, be64_to_cpu(crq_as_u64[0]),\n\t\t\tbe64_to_cpu(crq_as_u64[1]));\n\n\treturn 0;\n}\n\n \nstatic int ibmvmc_send_msg(struct crq_server_adapter *adapter,\n\t\t\t   struct ibmvmc_buffer *buffer,\n\t\t\t   struct ibmvmc_hmc *hmc, int msg_len)\n{\n\tstruct ibmvmc_crq_msg crq_msg;\n\t__be64 *crq_as_u64 = (__be64 *)&crq_msg;\n\tint rc = 0;\n\n\tdev_dbg(adapter->dev, \"CRQ send: rdma to HV\\n\");\n\trc = h_copy_rdma(msg_len,\n\t\t\t adapter->liobn,\n\t\t\t buffer->dma_addr_local,\n\t\t\t adapter->riobn,\n\t\t\t buffer->dma_addr_remote);\n\tif (rc) {\n\t\tdev_err(adapter->dev, \"Error in send_msg, h_copy_rdma rc 0x%x\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tcrq_msg.valid = 0x80;\n\tcrq_msg.type = VMC_MSG_SIGNAL;\n\tcrq_msg.status = 0;\n\tcrq_msg.var1.rsvd = 0;\n\tcrq_msg.hmc_session = hmc->session;\n\tcrq_msg.hmc_index = hmc->index;\n\tcrq_msg.var2.buffer_id = cpu_to_be16(buffer->id);\n\tcrq_msg.var3.msg_len = cpu_to_be32(msg_len);\n\tdev_dbg(adapter->dev, \"CRQ send: msg to HV 0x%llx 0x%llx\\n\",\n\t\tbe64_to_cpu(crq_as_u64[0]), be64_to_cpu(crq_as_u64[1]));\n\n\tbuffer->owner = VMC_BUF_OWNER_HV;\n\tibmvmc_send_crq(adapter, be64_to_cpu(crq_as_u64[0]),\n\t\t\tbe64_to_cpu(crq_as_u64[1]));\n\n\treturn rc;\n}\n\n \nstatic int ibmvmc_open(struct inode *inode, struct file *file)\n{\n\tstruct ibmvmc_file_session *session;\n\n\tpr_debug(\"%s: inode = 0x%lx, file = 0x%lx, state = 0x%x\\n\", __func__,\n\t\t (unsigned long)inode, (unsigned long)file,\n\t\t ibmvmc.state);\n\n\tsession = kzalloc(sizeof(*session), GFP_KERNEL);\n\tif (!session)\n\t\treturn -ENOMEM;\n\n\tsession->file = file;\n\tfile->private_data = session;\n\n\treturn 0;\n}\n\n \nstatic int ibmvmc_close(struct inode *inode, struct file *file)\n{\n\tstruct ibmvmc_file_session *session;\n\tstruct ibmvmc_hmc *hmc;\n\tint rc = 0;\n\tunsigned long flags;\n\n\tpr_debug(\"%s: file = 0x%lx, state = 0x%x\\n\", __func__,\n\t\t (unsigned long)file, ibmvmc.state);\n\n\tsession = file->private_data;\n\tif (!session)\n\t\treturn -EIO;\n\n\thmc = session->hmc;\n\tif (hmc) {\n\t\tif (!hmc->adapter)\n\t\t\treturn -EIO;\n\n\t\tif (ibmvmc.state == ibmvmc_state_failed) {\n\t\t\tdev_warn(hmc->adapter->dev, \"close: state_failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tspin_lock_irqsave(&hmc->lock, flags);\n\t\tif (hmc->state >= ibmhmc_state_opening) {\n\t\t\trc = ibmvmc_send_close(hmc);\n\t\t\tif (rc)\n\t\t\t\tdev_warn(hmc->adapter->dev, \"close: send_close failed.\\n\");\n\t\t}\n\t\tspin_unlock_irqrestore(&hmc->lock, flags);\n\t}\n\n\tkfree_sensitive(session);\n\n\treturn rc;\n}\n\n \nstatic ssize_t ibmvmc_read(struct file *file, char *buf, size_t nbytes,\n\t\t\t   loff_t *ppos)\n{\n\tstruct ibmvmc_file_session *session;\n\tstruct ibmvmc_hmc *hmc;\n\tstruct crq_server_adapter *adapter;\n\tstruct ibmvmc_buffer *buffer;\n\tssize_t n;\n\tssize_t retval = 0;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"ibmvmc: read: file = 0x%lx, buf = 0x%lx, nbytes = 0x%lx\\n\",\n\t\t (unsigned long)file, (unsigned long)buf,\n\t\t (unsigned long)nbytes);\n\n\tif (nbytes == 0)\n\t\treturn 0;\n\n\tif (nbytes > ibmvmc.max_mtu) {\n\t\tpr_warn(\"ibmvmc: read: nbytes invalid 0x%x\\n\",\n\t\t\t(unsigned int)nbytes);\n\t\treturn -EINVAL;\n\t}\n\n\tsession = file->private_data;\n\tif (!session) {\n\t\tpr_warn(\"ibmvmc: read: no session\\n\");\n\t\treturn -EIO;\n\t}\n\n\thmc = session->hmc;\n\tif (!hmc) {\n\t\tpr_warn(\"ibmvmc: read: no hmc\\n\");\n\t\treturn -EIO;\n\t}\n\n\tadapter = hmc->adapter;\n\tif (!adapter) {\n\t\tpr_warn(\"ibmvmc: read: no adapter\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tprepare_to_wait(&ibmvmc_read_wait, &wait, TASK_INTERRUPTIBLE);\n\n\t\tspin_lock_irqsave(&hmc->lock, flags);\n\t\tif (hmc->queue_tail != hmc->queue_head)\n\t\t\t \n\t\t\tbreak;\n\n\t\tspin_unlock_irqrestore(&hmc->lock, flags);\n\n\t\tif (!session->valid) {\n\t\t\tretval = -EBADFD;\n\t\t\tgoto out;\n\t\t}\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tschedule();\n\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tgoto out;\n\t\t}\n\t} while (1);\n\n\tbuffer = &(hmc->buffer[hmc->queue_outbound_msgs[hmc->queue_tail]]);\n\thmc->queue_tail++;\n\tif (hmc->queue_tail == ibmvmc_max_buf_pool_size)\n\t\thmc->queue_tail = 0;\n\tspin_unlock_irqrestore(&hmc->lock, flags);\n\n\tnbytes = min_t(size_t, nbytes, buffer->msg_len);\n\tn = copy_to_user((void *)buf, buffer->real_addr_local, nbytes);\n\tdev_dbg(adapter->dev, \"read: copy to user nbytes = 0x%lx.\\n\", nbytes);\n\tibmvmc_free_hmc_buffer(hmc, buffer);\n\tretval = nbytes;\n\n\tif (n) {\n\t\tdev_warn(adapter->dev, \"read: copy to user failed.\\n\");\n\t\tretval = -EFAULT;\n\t}\n\n out:\n\tfinish_wait(&ibmvmc_read_wait, &wait);\n\tdev_dbg(adapter->dev, \"read: out %ld\\n\", retval);\n\treturn retval;\n}\n\n \nstatic unsigned int ibmvmc_poll(struct file *file, poll_table *wait)\n{\n\tstruct ibmvmc_file_session *session;\n\tstruct ibmvmc_hmc *hmc;\n\tunsigned int mask = 0;\n\n\tsession = file->private_data;\n\tif (!session)\n\t\treturn 0;\n\n\thmc = session->hmc;\n\tif (!hmc)\n\t\treturn 0;\n\n\tpoll_wait(file, &ibmvmc_read_wait, wait);\n\n\tif (hmc->queue_head != hmc->queue_tail)\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\treturn mask;\n}\n\n \nstatic ssize_t ibmvmc_write(struct file *file, const char *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct inode *inode;\n\tstruct ibmvmc_buffer *vmc_buffer;\n\tstruct ibmvmc_file_session *session;\n\tstruct crq_server_adapter *adapter;\n\tstruct ibmvmc_hmc *hmc;\n\tunsigned char *buf;\n\tunsigned long flags;\n\tsize_t bytes;\n\tconst char *p = buffer;\n\tsize_t c = count;\n\tint ret = 0;\n\n\tsession = file->private_data;\n\tif (!session)\n\t\treturn -EIO;\n\n\thmc = session->hmc;\n\tif (!hmc)\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&hmc->lock, flags);\n\tif (hmc->state == ibmhmc_state_free) {\n\t\t \n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tadapter = hmc->adapter;\n\tif (!adapter) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (count > ibmvmc.max_mtu) {\n\t\tdev_warn(adapter->dev, \"invalid buffer size 0x%lx\\n\",\n\t\t\t (unsigned long)count);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tif (hmc->state == ibmhmc_state_opening) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (hmc->state != ibmhmc_state_ready) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tvmc_buffer = ibmvmc_get_valid_hmc_buffer(hmc->index);\n\tif (!vmc_buffer) {\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!vmc_buffer->real_addr_local) {\n\t\tdev_err(adapter->dev, \"no buffer storage assigned\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tbuf = vmc_buffer->real_addr_local;\n\n\twhile (c > 0) {\n\t\tbytes = min_t(size_t, c, vmc_buffer->size);\n\n\t\tbytes -= copy_from_user(buf, p, bytes);\n\t\tif (!bytes) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tc -= bytes;\n\t\tp += bytes;\n\t}\n\tif (p == buffer)\n\t\tgoto out;\n\n\tinode = file_inode(file);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\n\tdev_dbg(adapter->dev, \"write: file = 0x%lx, count = 0x%lx\\n\",\n\t\t(unsigned long)file, (unsigned long)count);\n\n\tibmvmc_send_msg(adapter, vmc_buffer, hmc, count);\n\tret = p - buffer;\n out:\n\tspin_unlock_irqrestore(&hmc->lock, flags);\n\treturn (ssize_t)(ret);\n}\n\n \nstatic long ibmvmc_setup_hmc(struct ibmvmc_file_session *session)\n{\n\tstruct ibmvmc_hmc *hmc;\n\tunsigned int valid, free, index;\n\n\tif (ibmvmc.state == ibmvmc_state_failed) {\n\t\tpr_warn(\"ibmvmc: Reserve HMC: state_failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ibmvmc.state < ibmvmc_state_ready) {\n\t\tpr_warn(\"ibmvmc: Reserve HMC: not state_ready\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tfor (index = 0; index <= ibmvmc.max_hmc_index; index++) {\n\t\tvalid = 0;\n\t\tibmvmc_count_hmc_buffers(index, &valid, &free);\n\t\tif (valid == 0) {\n\t\t\tpr_warn(\"ibmvmc: buffers not ready for index %d\\n\",\n\t\t\t\tindex);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t}\n\n\t \n\thmc = ibmvmc_get_free_hmc();\n\tif (!hmc) {\n\t\tpr_warn(\"%s: free hmc not found\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\thmc->session = hmc->session + 1;\n\tif (hmc->session == 0xff)\n\t\thmc->session = 1;\n\n\tsession->hmc = hmc;\n\thmc->adapter = &ibmvmc_adapter;\n\thmc->file_session = session;\n\tsession->valid = 1;\n\n\treturn 0;\n}\n\n \nstatic long ibmvmc_ioctl_sethmcid(struct ibmvmc_file_session *session,\n\t\t\t\t  unsigned char __user *new_hmc_id)\n{\n\tstruct ibmvmc_hmc *hmc;\n\tstruct ibmvmc_buffer *buffer;\n\tsize_t bytes;\n\tchar print_buffer[HMC_ID_LEN + 1];\n\tunsigned long flags;\n\tlong rc = 0;\n\n\t \n\thmc = session->hmc;\n\tif (!hmc) {\n\t\trc = ibmvmc_setup_hmc(session);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\thmc = session->hmc;\n\t\tif (!hmc) {\n\t\t\tpr_err(\"ibmvmc: setup_hmc success but no hmc\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (hmc->state != ibmhmc_state_initial) {\n\t\tpr_warn(\"ibmvmc: sethmcid: invalid state to send open 0x%x\\n\",\n\t\t\thmc->state);\n\t\treturn -EIO;\n\t}\n\n\tbytes = copy_from_user(hmc->hmc_id, new_hmc_id, HMC_ID_LEN);\n\tif (bytes)\n\t\treturn -EFAULT;\n\n\t \n\tspin_lock_irqsave(&hmc->lock, flags);\n\tbuffer = ibmvmc_get_valid_hmc_buffer(hmc->index);\n\tspin_unlock_irqrestore(&hmc->lock, flags);\n\n\tif (!buffer || !buffer->real_addr_local) {\n\t\tpr_warn(\"ibmvmc: sethmcid: no buffer available\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tmemset(print_buffer, 0, HMC_ID_LEN + 1);\n\tstrncpy(print_buffer, hmc->hmc_id, HMC_ID_LEN);\n\tpr_info(\"ibmvmc: sethmcid: Set HMC ID: \\\"%s\\\"\\n\", print_buffer);\n\n\tmemcpy(buffer->real_addr_local, hmc->hmc_id, HMC_ID_LEN);\n\t \n\trc = ibmvmc_send_open(buffer, hmc);\n\n\treturn rc;\n}\n\n \nstatic long ibmvmc_ioctl_query(struct ibmvmc_file_session *session,\n\t\t\t       struct ibmvmc_query_struct __user *ret_struct)\n{\n\tstruct ibmvmc_query_struct query_struct;\n\tsize_t bytes;\n\n\tmemset(&query_struct, 0, sizeof(query_struct));\n\tquery_struct.have_vmc = (ibmvmc.state > ibmvmc_state_initial);\n\tquery_struct.state = ibmvmc.state;\n\tquery_struct.vmc_drc_index = ibmvmc.vmc_drc_index;\n\n\tbytes = copy_to_user(ret_struct, &query_struct,\n\t\t\t     sizeof(query_struct));\n\tif (bytes)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic long ibmvmc_ioctl_requestvmc(struct ibmvmc_file_session *session,\n\t\t\t\t    u32 __user *ret_vmc_index)\n{\n\t \n\tsize_t bytes;\n\tlong rc;\n\tu32 vmc_drc_index;\n\n\t \n\trc = h_request_vmc(&vmc_drc_index);\n\tpr_debug(\"ibmvmc: requestvmc: H_REQUEST_VMC rc = 0x%lx\\n\", rc);\n\n\tif (rc == H_SUCCESS) {\n\t\trc = 0;\n\t} else if (rc == H_FUNCTION) {\n\t\tpr_err(\"ibmvmc: requestvmc: h_request_vmc not supported\\n\");\n\t\treturn -EPERM;\n\t} else if (rc == H_AUTHORITY) {\n\t\tpr_err(\"ibmvmc: requestvmc: hypervisor denied vmc request\\n\");\n\t\treturn -EPERM;\n\t} else if (rc == H_HARDWARE) {\n\t\tpr_err(\"ibmvmc: requestvmc: hypervisor hardware fault\\n\");\n\t\treturn -EIO;\n\t} else if (rc == H_RESOURCE) {\n\t\tpr_err(\"ibmvmc: requestvmc: vmc resource unavailable\\n\");\n\t\treturn -ENODEV;\n\t} else if (rc == H_NOT_AVAILABLE) {\n\t\tpr_err(\"ibmvmc: requestvmc: system cannot be vmc managed\\n\");\n\t\treturn -EPERM;\n\t} else if (rc == H_PARAMETER) {\n\t\tpr_err(\"ibmvmc: requestvmc: invalid parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tibmvmc.vmc_drc_index = vmc_drc_index;\n\n\tbytes = copy_to_user(ret_vmc_index, &vmc_drc_index,\n\t\t\t     sizeof(*ret_vmc_index));\n\tif (bytes) {\n\t\tpr_warn(\"ibmvmc: requestvmc: copy to user failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn rc;\n}\n\n \nstatic long ibmvmc_ioctl(struct file *file,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct ibmvmc_file_session *session = file->private_data;\n\n\tpr_debug(\"ibmvmc: ioctl file=0x%lx, cmd=0x%x, arg=0x%lx, ses=0x%lx\\n\",\n\t\t (unsigned long)file, cmd, arg,\n\t\t (unsigned long)session);\n\n\tif (!session) {\n\t\tpr_warn(\"ibmvmc: ioctl: no session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tswitch (cmd) {\n\tcase VMC_IOCTL_SETHMCID:\n\t\treturn ibmvmc_ioctl_sethmcid(session,\n\t\t\t(unsigned char __user *)arg);\n\tcase VMC_IOCTL_QUERY:\n\t\treturn ibmvmc_ioctl_query(session,\n\t\t\t(struct ibmvmc_query_struct __user *)arg);\n\tcase VMC_IOCTL_REQUESTVMC:\n\t\treturn ibmvmc_ioctl_requestvmc(session,\n\t\t\t(unsigned int __user *)arg);\n\tdefault:\n\t\tpr_warn(\"ibmvmc: unknown ioctl 0x%x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct file_operations ibmvmc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= ibmvmc_read,\n\t.write\t\t= ibmvmc_write,\n\t.poll\t\t= ibmvmc_poll,\n\t.unlocked_ioctl\t= ibmvmc_ioctl,\n\t.open           = ibmvmc_open,\n\t.release        = ibmvmc_close,\n};\n\n \nstatic int ibmvmc_add_buffer(struct crq_server_adapter *adapter,\n\t\t\t     struct ibmvmc_crq_msg *crq)\n{\n\tstruct ibmvmc_buffer *buffer;\n\tu8 hmc_index;\n\tu8 hmc_session;\n\tu16 buffer_id;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tif (!crq)\n\t\treturn -1;\n\n\thmc_session = crq->hmc_session;\n\thmc_index = crq->hmc_index;\n\tbuffer_id = be16_to_cpu(crq->var2.buffer_id);\n\n\tif (hmc_index > ibmvmc.max_hmc_index) {\n\t\tdev_err(adapter->dev, \"add_buffer: invalid hmc_index = 0x%x\\n\",\n\t\t\thmc_index);\n\t\tibmvmc_send_add_buffer_resp(adapter, VMC_MSG_INVALID_HMC_INDEX,\n\t\t\t\t\t    hmc_session, hmc_index, buffer_id);\n\t\treturn -1;\n\t}\n\n\tif (buffer_id >= ibmvmc.max_buffer_pool_size) {\n\t\tdev_err(adapter->dev, \"add_buffer: invalid buffer_id = 0x%x\\n\",\n\t\t\tbuffer_id);\n\t\tibmvmc_send_add_buffer_resp(adapter, VMC_MSG_INVALID_BUFFER_ID,\n\t\t\t\t\t    hmc_session, hmc_index, buffer_id);\n\t\treturn -1;\n\t}\n\n\tspin_lock_irqsave(&hmcs[hmc_index].lock, flags);\n\tbuffer = &hmcs[hmc_index].buffer[buffer_id];\n\n\tif (buffer->real_addr_local || buffer->dma_addr_local) {\n\t\tdev_warn(adapter->dev, \"add_buffer: already allocated id = 0x%lx\\n\",\n\t\t\t (unsigned long)buffer_id);\n\t\tspin_unlock_irqrestore(&hmcs[hmc_index].lock, flags);\n\t\tibmvmc_send_add_buffer_resp(adapter, VMC_MSG_INVALID_BUFFER_ID,\n\t\t\t\t\t    hmc_session, hmc_index, buffer_id);\n\t\treturn -1;\n\t}\n\n\tbuffer->real_addr_local = alloc_dma_buffer(to_vio_dev(adapter->dev),\n\t\t\t\t\t\t   ibmvmc.max_mtu,\n\t\t\t\t\t\t   &buffer->dma_addr_local);\n\n\tif (!buffer->real_addr_local) {\n\t\tdev_err(adapter->dev, \"add_buffer: alloc_dma_buffer failed.\\n\");\n\t\tspin_unlock_irqrestore(&hmcs[hmc_index].lock, flags);\n\t\tibmvmc_send_add_buffer_resp(adapter, VMC_MSG_INTERFACE_FAILURE,\n\t\t\t\t\t    hmc_session, hmc_index, buffer_id);\n\t\treturn -1;\n\t}\n\n\tbuffer->dma_addr_remote = be32_to_cpu(crq->var3.lioba);\n\tbuffer->size = ibmvmc.max_mtu;\n\tbuffer->owner = crq->var1.owner;\n\tbuffer->free = 1;\n\t \n\tdma_wmb();\n\tbuffer->valid = 1;\n\tbuffer->id = buffer_id;\n\n\tdev_dbg(adapter->dev, \"add_buffer: successfully added a buffer:\\n\");\n\tdev_dbg(adapter->dev, \"   index: %d, session: %d, buffer: 0x%x, owner: %d\\n\",\n\t\thmc_index, hmc_session, buffer_id, buffer->owner);\n\tdev_dbg(adapter->dev, \"   local: 0x%x, remote: 0x%x\\n\",\n\t\t(u32)buffer->dma_addr_local,\n\t\t(u32)buffer->dma_addr_remote);\n\tspin_unlock_irqrestore(&hmcs[hmc_index].lock, flags);\n\n\tibmvmc_send_add_buffer_resp(adapter, VMC_MSG_SUCCESS, hmc_session,\n\t\t\t\t    hmc_index, buffer_id);\n\n\treturn rc;\n}\n\n \n \nstatic int ibmvmc_rem_buffer(struct crq_server_adapter *adapter,\n\t\t\t     struct ibmvmc_crq_msg *crq)\n{\n\tstruct ibmvmc_buffer *buffer;\n\tu8 hmc_index;\n\tu8 hmc_session;\n\tu16 buffer_id = 0;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tif (!crq)\n\t\treturn -1;\n\n\thmc_session = crq->hmc_session;\n\thmc_index = crq->hmc_index;\n\n\tif (hmc_index > ibmvmc.max_hmc_index) {\n\t\tdev_warn(adapter->dev, \"rem_buffer: invalid hmc_index = 0x%x\\n\",\n\t\t\t hmc_index);\n\t\tibmvmc_send_rem_buffer_resp(adapter, VMC_MSG_INVALID_HMC_INDEX,\n\t\t\t\t\t    hmc_session, hmc_index, buffer_id);\n\t\treturn -1;\n\t}\n\n\tspin_lock_irqsave(&hmcs[hmc_index].lock, flags);\n\tbuffer = ibmvmc_get_free_hmc_buffer(adapter, hmc_index);\n\tif (!buffer) {\n\t\tdev_info(adapter->dev, \"rem_buffer: no buffer to remove\\n\");\n\t\tspin_unlock_irqrestore(&hmcs[hmc_index].lock, flags);\n\t\tibmvmc_send_rem_buffer_resp(adapter, VMC_MSG_NO_BUFFER,\n\t\t\t\t\t    hmc_session, hmc_index,\n\t\t\t\t\t    VMC_INVALID_BUFFER_ID);\n\t\treturn -1;\n\t}\n\n\tbuffer_id = buffer->id;\n\n\tif (buffer->valid)\n\t\tfree_dma_buffer(to_vio_dev(adapter->dev),\n\t\t\t\tibmvmc.max_mtu,\n\t\t\t\tbuffer->real_addr_local,\n\t\t\t\tbuffer->dma_addr_local);\n\n\tmemset(buffer, 0, sizeof(struct ibmvmc_buffer));\n\tspin_unlock_irqrestore(&hmcs[hmc_index].lock, flags);\n\n\tdev_dbg(adapter->dev, \"rem_buffer: removed buffer 0x%x.\\n\", buffer_id);\n\tibmvmc_send_rem_buffer_resp(adapter, VMC_MSG_SUCCESS, hmc_session,\n\t\t\t\t    hmc_index, buffer_id);\n\n\treturn rc;\n}\n\nstatic int ibmvmc_recv_msg(struct crq_server_adapter *adapter,\n\t\t\t   struct ibmvmc_crq_msg *crq)\n{\n\tstruct ibmvmc_buffer *buffer;\n\tstruct ibmvmc_hmc *hmc;\n\tunsigned long msg_len;\n\tu8 hmc_index;\n\tu8 hmc_session;\n\tu16 buffer_id;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tif (!crq)\n\t\treturn -1;\n\n\t \n\tdev_dbg(adapter->dev, \"Recv_msg: msg from HV 0x%016llx 0x%016llx\\n\",\n\t\tbe64_to_cpu(*((unsigned long *)crq)),\n\t\tbe64_to_cpu(*(((unsigned long *)crq) + 1)));\n\n\thmc_session = crq->hmc_session;\n\thmc_index = crq->hmc_index;\n\tbuffer_id = be16_to_cpu(crq->var2.buffer_id);\n\tmsg_len = be32_to_cpu(crq->var3.msg_len);\n\n\tif (hmc_index > ibmvmc.max_hmc_index) {\n\t\tdev_err(adapter->dev, \"Recv_msg: invalid hmc_index = 0x%x\\n\",\n\t\t\thmc_index);\n\t\tibmvmc_send_add_buffer_resp(adapter, VMC_MSG_INVALID_HMC_INDEX,\n\t\t\t\t\t    hmc_session, hmc_index, buffer_id);\n\t\treturn -1;\n\t}\n\n\tif (buffer_id >= ibmvmc.max_buffer_pool_size) {\n\t\tdev_err(adapter->dev, \"Recv_msg: invalid buffer_id = 0x%x\\n\",\n\t\t\tbuffer_id);\n\t\tibmvmc_send_add_buffer_resp(adapter, VMC_MSG_INVALID_BUFFER_ID,\n\t\t\t\t\t    hmc_session, hmc_index, buffer_id);\n\t\treturn -1;\n\t}\n\n\thmc = &hmcs[hmc_index];\n\tspin_lock_irqsave(&hmc->lock, flags);\n\n\tif (hmc->state == ibmhmc_state_free) {\n\t\tdev_err(adapter->dev, \"Recv_msg: invalid hmc state = 0x%x\\n\",\n\t\t\thmc->state);\n\t\t \n\t\tspin_unlock_irqrestore(&hmc->lock, flags);\n\t\treturn -1;\n\t}\n\n\tbuffer = &hmc->buffer[buffer_id];\n\n\tif (buffer->valid == 0 || buffer->owner == VMC_BUF_OWNER_ALPHA) {\n\t\tdev_err(adapter->dev, \"Recv_msg: not valid, or not HV.  0x%x 0x%x\\n\",\n\t\t\tbuffer->valid, buffer->owner);\n\t\tspin_unlock_irqrestore(&hmc->lock, flags);\n\t\treturn -1;\n\t}\n\n\t \n\trc = h_copy_rdma(msg_len,\n\t\t\t adapter->riobn,\n\t\t\t buffer->dma_addr_remote,\n\t\t\t adapter->liobn,\n\t\t\t buffer->dma_addr_local);\n\n\tdev_dbg(adapter->dev, \"Recv_msg: msg_len = 0x%x, buffer_id = 0x%x, queue_head = 0x%x, hmc_idx = 0x%x\\n\",\n\t\t(unsigned int)msg_len, (unsigned int)buffer_id,\n\t\t(unsigned int)hmc->queue_head, (unsigned int)hmc_index);\n\tbuffer->msg_len = msg_len;\n\tbuffer->free = 0;\n\tbuffer->owner = VMC_BUF_OWNER_ALPHA;\n\n\tif (rc) {\n\t\tdev_err(adapter->dev, \"Failure in recv_msg: h_copy_rdma = 0x%x\\n\",\n\t\t\trc);\n\t\tspin_unlock_irqrestore(&hmc->lock, flags);\n\t\treturn -1;\n\t}\n\n\t \n\thmc->queue_outbound_msgs[hmc->queue_head] = buffer_id;\n\thmc->queue_head++;\n\tif (hmc->queue_head == ibmvmc_max_buf_pool_size)\n\t\thmc->queue_head = 0;\n\n\tif (hmc->queue_head == hmc->queue_tail)\n\t\tdev_err(adapter->dev, \"outbound buffer queue wrapped.\\n\");\n\n\tspin_unlock_irqrestore(&hmc->lock, flags);\n\n\twake_up_interruptible(&ibmvmc_read_wait);\n\n\treturn 0;\n}\n\n \nstatic void ibmvmc_process_capabilities(struct crq_server_adapter *adapter,\n\t\t\t\t\tstruct ibmvmc_crq_msg *crqp)\n{\n\tstruct ibmvmc_admin_crq_msg *crq = (struct ibmvmc_admin_crq_msg *)crqp;\n\n\tif ((be16_to_cpu(crq->version) >> 8) !=\n\t\t\t(IBMVMC_PROTOCOL_VERSION >> 8)) {\n\t\tdev_err(adapter->dev, \"init failed, incompatible versions 0x%x 0x%x\\n\",\n\t\t\tbe16_to_cpu(crq->version),\n\t\t\tIBMVMC_PROTOCOL_VERSION);\n\t\tibmvmc.state = ibmvmc_state_failed;\n\t\treturn;\n\t}\n\n\tibmvmc.max_mtu = min_t(u32, ibmvmc_max_mtu, be32_to_cpu(crq->max_mtu));\n\tibmvmc.max_buffer_pool_size = min_t(u16, ibmvmc_max_buf_pool_size,\n\t\t\t\t\t    be16_to_cpu(crq->pool_size));\n\tibmvmc.max_hmc_index = min_t(u8, ibmvmc_max_hmcs, crq->max_hmc) - 1;\n\tibmvmc.state = ibmvmc_state_ready;\n\n\tdev_info(adapter->dev, \"Capabilities: mtu=0x%x, pool_size=0x%x, max_hmc=0x%x\\n\",\n\t\t ibmvmc.max_mtu, ibmvmc.max_buffer_pool_size,\n\t\t ibmvmc.max_hmc_index);\n}\n\n \nstatic int ibmvmc_validate_hmc_session(struct crq_server_adapter *adapter,\n\t\t\t\t       struct ibmvmc_crq_msg *crq)\n{\n\tunsigned char hmc_index;\n\n\thmc_index = crq->hmc_index;\n\n\tif (crq->hmc_session == 0)\n\t\treturn 0;\n\n\tif (hmc_index > ibmvmc.max_hmc_index)\n\t\treturn -1;\n\n\tif (hmcs[hmc_index].session != crq->hmc_session) {\n\t\tdev_warn(adapter->dev, \"Drop, bad session: expected 0x%x, recv 0x%x\\n\",\n\t\t\t hmcs[hmc_index].session, crq->hmc_session);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ibmvmc_reset(struct crq_server_adapter *adapter, bool xport_event)\n{\n\tint i;\n\n\tif (ibmvmc.state != ibmvmc_state_sched_reset) {\n\t\tdev_info(adapter->dev, \"*** Reset to initial state.\\n\");\n\t\tfor (i = 0; i < ibmvmc_max_hmcs; i++)\n\t\t\tibmvmc_return_hmc(&hmcs[i], xport_event);\n\n\t\tif (xport_event) {\n\t\t\t \n\t\t\tibmvmc.state = ibmvmc_state_crqinit;\n\t\t} else {\n\t\t\t \n\t\t\tibmvmc.state = ibmvmc_state_sched_reset;\n\t\t\tdev_dbg(adapter->dev, \"Device reset scheduled\");\n\t\t\twake_up_interruptible(&adapter->reset_wait_queue);\n\t\t}\n\t}\n}\n\n \nstatic int ibmvmc_reset_task(void *data)\n{\n\tstruct crq_server_adapter *adapter = data;\n\tint rc;\n\n\tset_user_nice(current, -20);\n\n\twhile (!kthread_should_stop()) {\n\t\twait_event_interruptible(adapter->reset_wait_queue,\n\t\t\t(ibmvmc.state == ibmvmc_state_sched_reset) ||\n\t\t\tkthread_should_stop());\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tdev_dbg(adapter->dev, \"CRQ resetting in process context\");\n\t\ttasklet_disable(&adapter->work_task);\n\n\t\trc = ibmvmc_reset_crq_queue(adapter);\n\n\t\tif (rc != H_SUCCESS && rc != H_RESOURCE) {\n\t\t\tdev_err(adapter->dev, \"Error initializing CRQ.  rc = 0x%x\\n\",\n\t\t\t\trc);\n\t\t\tibmvmc.state = ibmvmc_state_failed;\n\t\t} else {\n\t\t\tibmvmc.state = ibmvmc_state_crqinit;\n\n\t\t\tif (ibmvmc_send_crq(adapter, 0xC001000000000000LL, 0)\n\t\t\t    != 0 && rc != H_RESOURCE)\n\t\t\t\tdev_warn(adapter->dev, \"Failed to send initialize CRQ message\\n\");\n\t\t}\n\n\t\tvio_enable_interrupts(to_vio_dev(adapter->dev));\n\t\ttasklet_enable(&adapter->work_task);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ibmvmc_process_open_resp(struct ibmvmc_crq_msg *crq,\n\t\t\t\t     struct crq_server_adapter *adapter)\n{\n\tunsigned char hmc_index;\n\tunsigned short buffer_id;\n\n\thmc_index = crq->hmc_index;\n\tif (hmc_index > ibmvmc.max_hmc_index) {\n\t\t \n\t\tibmvmc_reset(adapter, false);\n\t\treturn;\n\t}\n\n\tif (crq->status) {\n\t\tdev_warn(adapter->dev, \"open_resp: failed - status 0x%x\\n\",\n\t\t\t crq->status);\n\t\tibmvmc_return_hmc(&hmcs[hmc_index], false);\n\t\treturn;\n\t}\n\n\tif (hmcs[hmc_index].state == ibmhmc_state_opening) {\n\t\tbuffer_id = be16_to_cpu(crq->var2.buffer_id);\n\t\tif (buffer_id >= ibmvmc.max_buffer_pool_size) {\n\t\t\tdev_err(adapter->dev, \"open_resp: invalid buffer_id = 0x%x\\n\",\n\t\t\t\tbuffer_id);\n\t\t\thmcs[hmc_index].state = ibmhmc_state_failed;\n\t\t} else {\n\t\t\tibmvmc_free_hmc_buffer(&hmcs[hmc_index],\n\t\t\t\t\t       &hmcs[hmc_index].buffer[buffer_id]);\n\t\t\thmcs[hmc_index].state = ibmhmc_state_ready;\n\t\t\tdev_dbg(adapter->dev, \"open_resp: set hmc state = ready\\n\");\n\t\t}\n\t} else {\n\t\tdev_warn(adapter->dev, \"open_resp: invalid hmc state (0x%x)\\n\",\n\t\t\t hmcs[hmc_index].state);\n\t}\n}\n\n \nstatic void ibmvmc_process_close_resp(struct ibmvmc_crq_msg *crq,\n\t\t\t\t      struct crq_server_adapter *adapter)\n{\n\tunsigned char hmc_index;\n\n\thmc_index = crq->hmc_index;\n\tif (hmc_index > ibmvmc.max_hmc_index) {\n\t\tibmvmc_reset(adapter, false);\n\t\treturn;\n\t}\n\n\tif (crq->status) {\n\t\tdev_warn(adapter->dev, \"close_resp: failed - status 0x%x\\n\",\n\t\t\t crq->status);\n\t\tibmvmc_reset(adapter, false);\n\t\treturn;\n\t}\n\n\tibmvmc_return_hmc(&hmcs[hmc_index], false);\n}\n\n \nstatic void ibmvmc_crq_process(struct crq_server_adapter *adapter,\n\t\t\t       struct ibmvmc_crq_msg *crq)\n{\n\tswitch (crq->type) {\n\tcase VMC_MSG_CAP_RESP:\n\t\tdev_dbg(adapter->dev, \"CRQ recv: capabilities resp (0x%x)\\n\",\n\t\t\tcrq->type);\n\t\tif (ibmvmc.state == ibmvmc_state_capabilities)\n\t\t\tibmvmc_process_capabilities(adapter, crq);\n\t\telse\n\t\t\tdev_warn(adapter->dev, \"caps msg invalid in state 0x%x\\n\",\n\t\t\t\t ibmvmc.state);\n\t\tbreak;\n\tcase VMC_MSG_OPEN_RESP:\n\t\tdev_dbg(adapter->dev, \"CRQ recv: open resp (0x%x)\\n\",\n\t\t\tcrq->type);\n\t\tif (ibmvmc_validate_hmc_session(adapter, crq) == 0)\n\t\t\tibmvmc_process_open_resp(crq, adapter);\n\t\tbreak;\n\tcase VMC_MSG_ADD_BUF:\n\t\tdev_dbg(adapter->dev, \"CRQ recv: add buf (0x%x)\\n\",\n\t\t\tcrq->type);\n\t\tif (ibmvmc_validate_hmc_session(adapter, crq) == 0)\n\t\t\tibmvmc_add_buffer(adapter, crq);\n\t\tbreak;\n\tcase VMC_MSG_REM_BUF:\n\t\tdev_dbg(adapter->dev, \"CRQ recv: rem buf (0x%x)\\n\",\n\t\t\tcrq->type);\n\t\tif (ibmvmc_validate_hmc_session(adapter, crq) == 0)\n\t\t\tibmvmc_rem_buffer(adapter, crq);\n\t\tbreak;\n\tcase VMC_MSG_SIGNAL:\n\t\tdev_dbg(adapter->dev, \"CRQ recv: signal msg (0x%x)\\n\",\n\t\t\tcrq->type);\n\t\tif (ibmvmc_validate_hmc_session(adapter, crq) == 0)\n\t\t\tibmvmc_recv_msg(adapter, crq);\n\t\tbreak;\n\tcase VMC_MSG_CLOSE_RESP:\n\t\tdev_dbg(adapter->dev, \"CRQ recv: close resp (0x%x)\\n\",\n\t\t\tcrq->type);\n\t\tif (ibmvmc_validate_hmc_session(adapter, crq) == 0)\n\t\t\tibmvmc_process_close_resp(crq, adapter);\n\t\tbreak;\n\tcase VMC_MSG_CAP:\n\tcase VMC_MSG_OPEN:\n\tcase VMC_MSG_CLOSE:\n\tcase VMC_MSG_ADD_BUF_RESP:\n\tcase VMC_MSG_REM_BUF_RESP:\n\t\tdev_warn(adapter->dev, \"CRQ recv: unexpected msg (0x%x)\\n\",\n\t\t\t crq->type);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(adapter->dev, \"CRQ recv: unknown msg (0x%x)\\n\",\n\t\t\t crq->type);\n\t\tbreak;\n\t}\n}\n\n \nstatic void ibmvmc_handle_crq_init(struct ibmvmc_crq_msg *crq,\n\t\t\t\t   struct crq_server_adapter *adapter)\n{\n\tswitch (crq->type) {\n\tcase 0x01:\t \n\t\tdev_dbg(adapter->dev, \"CRQ recv: CRQ init msg - state 0x%x\\n\",\n\t\t\tibmvmc.state);\n\t\tif (ibmvmc.state == ibmvmc_state_crqinit) {\n\t\t\t \n\t\t\tif (ibmvmc_send_crq(adapter, 0xC002000000000000,\n\t\t\t\t\t    0) == 0)\n\t\t\t\tibmvmc_send_capabilities(adapter);\n\t\t\telse\n\t\t\t\tdev_err(adapter->dev, \" Unable to send init rsp\\n\");\n\t\t} else {\n\t\t\tdev_err(adapter->dev, \"Invalid state 0x%x mtu = 0x%x\\n\",\n\t\t\t\tibmvmc.state, ibmvmc.max_mtu);\n\t\t}\n\n\t\tbreak;\n\tcase 0x02:\t \n\t\tdev_dbg(adapter->dev, \"CRQ recv: initialization resp msg - state 0x%x\\n\",\n\t\t\tibmvmc.state);\n\t\tif (ibmvmc.state == ibmvmc_state_crqinit)\n\t\t\tibmvmc_send_capabilities(adapter);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(adapter->dev, \"Unknown crq message type 0x%lx\\n\",\n\t\t\t (unsigned long)crq->type);\n\t}\n}\n\n \nstatic void ibmvmc_handle_crq(struct ibmvmc_crq_msg *crq,\n\t\t\t      struct crq_server_adapter *adapter)\n{\n\tswitch (crq->valid) {\n\tcase 0xC0:\t\t \n\t\tibmvmc_handle_crq_init(crq, adapter);\n\t\tbreak;\n\tcase 0xFF:\t \n\t\tdev_warn(adapter->dev, \"CRQ recv: virtual adapter failed - resetting.\\n\");\n\t\tibmvmc_reset(adapter, true);\n\t\tbreak;\n\tcase 0x80:\t \n\t\tibmvmc_crq_process(adapter, crq);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(adapter->dev, \"CRQ recv: unknown msg 0x%02x.\\n\",\n\t\t\t crq->valid);\n\t\tbreak;\n\t}\n}\n\nstatic void ibmvmc_task(unsigned long data)\n{\n\tstruct crq_server_adapter *adapter =\n\t\t(struct crq_server_adapter *)data;\n\tstruct vio_dev *vdev = to_vio_dev(adapter->dev);\n\tstruct ibmvmc_crq_msg *crq;\n\tint done = 0;\n\n\twhile (!done) {\n\t\t \n\t\twhile ((crq = crq_queue_next_crq(&adapter->queue)) != NULL) {\n\t\t\tibmvmc_handle_crq(crq, adapter);\n\t\t\tcrq->valid = 0x00;\n\t\t\t \n\t\t\tif (ibmvmc.state == ibmvmc_state_sched_reset)\n\t\t\t\treturn;\n\t\t}\n\n\t\tvio_enable_interrupts(vdev);\n\t\tcrq = crq_queue_next_crq(&adapter->queue);\n\t\tif (crq) {\n\t\t\tvio_disable_interrupts(vdev);\n\t\t\tibmvmc_handle_crq(crq, adapter);\n\t\t\tcrq->valid = 0x00;\n\t\t\t \n\t\t\tif (ibmvmc.state == ibmvmc_state_sched_reset)\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tdone = 1;\n\t\t}\n\t}\n}\n\n \nstatic int ibmvmc_init_crq_queue(struct crq_server_adapter *adapter)\n{\n\tstruct vio_dev *vdev = to_vio_dev(adapter->dev);\n\tstruct crq_queue *queue = &adapter->queue;\n\tint rc = 0;\n\tint retrc = 0;\n\n\tqueue->msgs = (struct ibmvmc_crq_msg *)get_zeroed_page(GFP_KERNEL);\n\n\tif (!queue->msgs)\n\t\tgoto malloc_failed;\n\n\tqueue->size = PAGE_SIZE / sizeof(*queue->msgs);\n\n\tqueue->msg_token = dma_map_single(adapter->dev, queue->msgs,\n\t\t\t\t\t  queue->size * sizeof(*queue->msgs),\n\t\t\t\t\t  DMA_BIDIRECTIONAL);\n\n\tif (dma_mapping_error(adapter->dev, queue->msg_token))\n\t\tgoto map_failed;\n\n\tretrc = plpar_hcall_norets(H_REG_CRQ,\n\t\t\t\t   vdev->unit_address,\n\t\t\t\t   queue->msg_token, PAGE_SIZE);\n\trc = retrc;\n\n\tif (rc == H_RESOURCE)\n\t\trc = ibmvmc_reset_crq_queue(adapter);\n\n\tif (rc == 2) {\n\t\tdev_warn(adapter->dev, \"Partner adapter not ready\\n\");\n\t\tretrc = 0;\n\t} else if (rc != 0) {\n\t\tdev_err(adapter->dev, \"Error %d opening adapter\\n\", rc);\n\t\tgoto reg_crq_failed;\n\t}\n\n\tqueue->cur = 0;\n\tspin_lock_init(&queue->lock);\n\n\ttasklet_init(&adapter->work_task, ibmvmc_task, (unsigned long)adapter);\n\n\tif (request_irq(vdev->irq,\n\t\t\tibmvmc_handle_event,\n\t\t\t0, \"ibmvmc\", (void *)adapter) != 0) {\n\t\tdev_err(adapter->dev, \"couldn't register irq 0x%x\\n\",\n\t\t\tvdev->irq);\n\t\tgoto req_irq_failed;\n\t}\n\n\trc = vio_enable_interrupts(vdev);\n\tif (rc != 0) {\n\t\tdev_err(adapter->dev, \"Error %d enabling interrupts!!!\\n\", rc);\n\t\tgoto req_irq_failed;\n\t}\n\n\treturn retrc;\n\nreq_irq_failed:\n\t \n\ttasklet_kill(&adapter->work_task);\n\th_free_crq(vdev->unit_address);\nreg_crq_failed:\n\tdma_unmap_single(adapter->dev,\n\t\t\t queue->msg_token,\n\t\t\t queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);\nmap_failed:\n\tfree_page((unsigned long)queue->msgs);\nmalloc_failed:\n\treturn -ENOMEM;\n}\n\n \nstatic int read_dma_window(struct vio_dev *vdev,\n\t\t\t   struct crq_server_adapter *adapter)\n{\n\tconst __be32 *dma_window;\n\tconst __be32 *prop;\n\n\t \n\tdma_window =\n\t\t(const __be32 *)vio_get_attribute(vdev, \"ibm,my-dma-window\",\n\t\t\t\t\t\tNULL);\n\tif (!dma_window) {\n\t\tdev_warn(adapter->dev, \"Couldn't find ibm,my-dma-window property\\n\");\n\t\treturn -1;\n\t}\n\n\tadapter->liobn = be32_to_cpu(*dma_window);\n\tdma_window++;\n\n\tprop = (const __be32 *)vio_get_attribute(vdev, \"ibm,#dma-address-cells\",\n\t\t\t\t\t\tNULL);\n\tif (!prop) {\n\t\tdev_warn(adapter->dev, \"Couldn't find ibm,#dma-address-cells property\\n\");\n\t\tdma_window++;\n\t} else {\n\t\tdma_window += be32_to_cpu(*prop);\n\t}\n\n\tprop = (const __be32 *)vio_get_attribute(vdev, \"ibm,#dma-size-cells\",\n\t\t\t\t\t\tNULL);\n\tif (!prop) {\n\t\tdev_warn(adapter->dev, \"Couldn't find ibm,#dma-size-cells property\\n\");\n\t\tdma_window++;\n\t} else {\n\t\tdma_window += be32_to_cpu(*prop);\n\t}\n\n\t \n\tadapter->riobn = be32_to_cpu(*dma_window);\n\n\treturn 0;\n}\n\nstatic int ibmvmc_probe(struct vio_dev *vdev, const struct vio_device_id *id)\n{\n\tstruct crq_server_adapter *adapter = &ibmvmc_adapter;\n\tint rc;\n\n\tdev_set_drvdata(&vdev->dev, NULL);\n\tmemset(adapter, 0, sizeof(*adapter));\n\tadapter->dev = &vdev->dev;\n\n\tdev_info(adapter->dev, \"Probe for UA 0x%x\\n\", vdev->unit_address);\n\n\trc = read_dma_window(vdev, adapter);\n\tif (rc != 0) {\n\t\tibmvmc.state = ibmvmc_state_failed;\n\t\treturn -1;\n\t}\n\n\tdev_dbg(adapter->dev, \"Probe: liobn 0x%x, riobn 0x%x\\n\",\n\t\tadapter->liobn, adapter->riobn);\n\n\tinit_waitqueue_head(&adapter->reset_wait_queue);\n\tadapter->reset_task = kthread_run(ibmvmc_reset_task, adapter, \"ibmvmc\");\n\tif (IS_ERR(adapter->reset_task)) {\n\t\tdev_err(adapter->dev, \"Failed to start reset thread\\n\");\n\t\tibmvmc.state = ibmvmc_state_failed;\n\t\trc = PTR_ERR(adapter->reset_task);\n\t\tadapter->reset_task = NULL;\n\t\treturn rc;\n\t}\n\n\trc = ibmvmc_init_crq_queue(adapter);\n\tif (rc != 0 && rc != H_RESOURCE) {\n\t\tdev_err(adapter->dev, \"Error initializing CRQ.  rc = 0x%x\\n\",\n\t\t\trc);\n\t\tibmvmc.state = ibmvmc_state_failed;\n\t\tgoto crq_failed;\n\t}\n\n\tibmvmc.state = ibmvmc_state_crqinit;\n\n\t \n\tif (ibmvmc_send_crq(adapter, 0xC001000000000000LL, 0) != 0 &&\n\t    rc != H_RESOURCE)\n\t\tdev_warn(adapter->dev, \"Failed to send initialize CRQ message\\n\");\n\n\tdev_set_drvdata(&vdev->dev, adapter);\n\n\treturn 0;\n\ncrq_failed:\n\tkthread_stop(adapter->reset_task);\n\tadapter->reset_task = NULL;\n\treturn -EPERM;\n}\n\nstatic void ibmvmc_remove(struct vio_dev *vdev)\n{\n\tstruct crq_server_adapter *adapter = dev_get_drvdata(&vdev->dev);\n\n\tdev_info(adapter->dev, \"Entering remove for UA 0x%x\\n\",\n\t\t vdev->unit_address);\n\tibmvmc_release_crq_queue(adapter);\n}\n\nstatic struct vio_device_id ibmvmc_device_table[] = {\n\t{ \"ibm,vmc\", \"IBM,vmc\" },\n\t{ \"\", \"\" }\n};\nMODULE_DEVICE_TABLE(vio, ibmvmc_device_table);\n\nstatic struct vio_driver ibmvmc_driver = {\n\t.name        = ibmvmc_driver_name,\n\t.id_table    = ibmvmc_device_table,\n\t.probe       = ibmvmc_probe,\n\t.remove      = ibmvmc_remove,\n};\n\nstatic void __init ibmvmc_scrub_module_parms(void)\n{\n\tif (ibmvmc_max_mtu > MAX_MTU) {\n\t\tpr_warn(\"ibmvmc: Max MTU reduced to %d\\n\", MAX_MTU);\n\t\tibmvmc_max_mtu = MAX_MTU;\n\t} else if (ibmvmc_max_mtu < MIN_MTU) {\n\t\tpr_warn(\"ibmvmc: Max MTU increased to %d\\n\", MIN_MTU);\n\t\tibmvmc_max_mtu = MIN_MTU;\n\t}\n\n\tif (ibmvmc_max_buf_pool_size > MAX_BUF_POOL_SIZE) {\n\t\tpr_warn(\"ibmvmc: Max buffer pool size reduced to %d\\n\",\n\t\t\tMAX_BUF_POOL_SIZE);\n\t\tibmvmc_max_buf_pool_size = MAX_BUF_POOL_SIZE;\n\t} else if (ibmvmc_max_buf_pool_size < MIN_BUF_POOL_SIZE) {\n\t\tpr_warn(\"ibmvmc: Max buffer pool size increased to %d\\n\",\n\t\t\tMIN_BUF_POOL_SIZE);\n\t\tibmvmc_max_buf_pool_size = MIN_BUF_POOL_SIZE;\n\t}\n\n\tif (ibmvmc_max_hmcs > MAX_HMCS) {\n\t\tpr_warn(\"ibmvmc: Max HMCs reduced to %d\\n\", MAX_HMCS);\n\t\tibmvmc_max_hmcs = MAX_HMCS;\n\t} else if (ibmvmc_max_hmcs < MIN_HMCS) {\n\t\tpr_warn(\"ibmvmc: Max HMCs increased to %d\\n\", MIN_HMCS);\n\t\tibmvmc_max_hmcs = MIN_HMCS;\n\t}\n}\n\nstatic struct miscdevice ibmvmc_miscdev = {\n\t.name = ibmvmc_driver_name,\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.fops = &ibmvmc_fops,\n};\n\nstatic int __init ibmvmc_module_init(void)\n{\n\tint rc, i, j;\n\n\tibmvmc.state = ibmvmc_state_initial;\n\tpr_info(\"ibmvmc: version %s\\n\", IBMVMC_DRIVER_VERSION);\n\n\trc = misc_register(&ibmvmc_miscdev);\n\tif (rc) {\n\t\tpr_err(\"ibmvmc: misc registration failed\\n\");\n\t\tgoto misc_register_failed;\n\t}\n\tpr_info(\"ibmvmc: node %d:%d\\n\", MISC_MAJOR,\n\t\tibmvmc_miscdev.minor);\n\n\t \n\tmemset(hmcs, 0, sizeof(struct ibmvmc_hmc) * MAX_HMCS);\n\tfor (i = 0; i < MAX_HMCS; i++) {\n\t\tspin_lock_init(&hmcs[i].lock);\n\t\thmcs[i].state = ibmhmc_state_free;\n\t\tfor (j = 0; j < MAX_BUF_POOL_SIZE; j++)\n\t\t\thmcs[i].queue_outbound_msgs[j] = VMC_INVALID_BUFFER_ID;\n\t}\n\n\t \n\tibmvmc_scrub_module_parms();\n\n\t \n\tibmvmc.max_mtu = ibmvmc_max_mtu;\n\tibmvmc.max_buffer_pool_size = ibmvmc_max_buf_pool_size;\n\tibmvmc.max_hmc_index = ibmvmc_max_hmcs - 1;\n\n\trc = vio_register_driver(&ibmvmc_driver);\n\n\tif (rc) {\n\t\tpr_err(\"ibmvmc: rc %d from vio_register_driver\\n\", rc);\n\t\tgoto vio_reg_failed;\n\t}\n\n\treturn 0;\n\nvio_reg_failed:\n\tmisc_deregister(&ibmvmc_miscdev);\nmisc_register_failed:\n\treturn rc;\n}\n\nstatic void __exit ibmvmc_module_exit(void)\n{\n\tpr_info(\"ibmvmc: module exit\\n\");\n\tvio_unregister_driver(&ibmvmc_driver);\n\tmisc_deregister(&ibmvmc_miscdev);\n}\n\nmodule_init(ibmvmc_module_init);\nmodule_exit(ibmvmc_module_exit);\n\nmodule_param_named(buf_pool_size, ibmvmc_max_buf_pool_size,\n\t\t   int, 0644);\nMODULE_PARM_DESC(buf_pool_size, \"Buffer pool size\");\nmodule_param_named(max_hmcs, ibmvmc_max_hmcs, int, 0644);\nMODULE_PARM_DESC(max_hmcs, \"Max HMCs\");\nmodule_param_named(max_mtu, ibmvmc_max_mtu, int, 0644);\nMODULE_PARM_DESC(max_mtu, \"Max MTU\");\n\nMODULE_AUTHOR(\"Steven Royer <seroyer@linux.vnet.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM VMC\");\nMODULE_VERSION(IBMVMC_DRIVER_VERSION);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}