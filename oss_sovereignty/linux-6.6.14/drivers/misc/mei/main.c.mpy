{
  "module_name": "main.c",
  "hash_id": "1e246b6b39dafe6bf0dfad56b23b51b5f4fcb6e22e94d6c8be7fbd4a01167010",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/cdev.h>\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/jiffies.h>\n#include <linux/interrupt.h>\n\n#include <linux/mei.h>\n\n#include \"mei_dev.h\"\n#include \"client.h\"\n\nstatic const struct class mei_class = {\n\t.name = \"mei\",\n};\n\nstatic dev_t mei_devt;\n#define MEI_MAX_DEVS  MINORMASK\nstatic DEFINE_MUTEX(mei_minor_lock);\nstatic DEFINE_IDR(mei_idr);\n\n \nstatic int mei_open(struct inode *inode, struct file *file)\n{\n\tstruct mei_device *dev;\n\tstruct mei_cl *cl;\n\n\tint err;\n\n\tdev = container_of(inode->i_cdev, struct mei_device, cdev);\n\n\tmutex_lock(&dev->device_lock);\n\n\tif (dev->dev_state != MEI_DEV_ENABLED) {\n\t\tdev_dbg(dev->dev, \"dev_state != MEI_ENABLED  dev_state = %s\\n\",\n\t\t    mei_dev_state_str(dev->dev_state));\n\t\terr = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tcl = mei_cl_alloc_linked(dev);\n\tif (IS_ERR(cl)) {\n\t\terr = PTR_ERR(cl);\n\t\tgoto err_unlock;\n\t}\n\n\tcl->fp = file;\n\tfile->private_data = cl;\n\n\tmutex_unlock(&dev->device_lock);\n\n\treturn nonseekable_open(inode, file);\n\nerr_unlock:\n\tmutex_unlock(&dev->device_lock);\n\treturn err;\n}\n\n \nstatic void mei_cl_vtag_remove_by_fp(const struct mei_cl *cl,\n\t\t\t\t     const struct file *fp)\n{\n\tstruct mei_cl_vtag *vtag_l, *next;\n\n\tlist_for_each_entry_safe(vtag_l, next, &cl->vtag_map, list) {\n\t\tif (vtag_l->fp == fp) {\n\t\t\tlist_del(&vtag_l->list);\n\t\t\tkfree(vtag_l);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic int mei_release(struct inode *inode, struct file *file)\n{\n\tstruct mei_cl *cl = file->private_data;\n\tstruct mei_device *dev;\n\tint rets;\n\n\tif (WARN_ON(!cl || !cl->dev))\n\t\treturn -ENODEV;\n\n\tdev = cl->dev;\n\n\tmutex_lock(&dev->device_lock);\n\n\tmei_cl_vtag_remove_by_fp(cl, file);\n\n\tif (!list_empty(&cl->vtag_map)) {\n\t\tcl_dbg(dev, cl, \"not the last vtag\\n\");\n\t\tmei_cl_flush_queues(cl, file);\n\t\trets = 0;\n\t\tgoto out;\n\t}\n\n\trets = mei_cl_disconnect(cl);\n\t \n\tif (!list_empty(&cl->vtag_map)) {\n\t\tcl_dbg(dev, cl, \"not the last vtag after disconnect\\n\");\n\t\tmei_cl_flush_queues(cl, file);\n\t\tgoto out;\n\t}\n\n\tmei_cl_flush_queues(cl, NULL);\n\tcl_dbg(dev, cl, \"removing\\n\");\n\n\tmei_cl_unlink(cl);\n\tkfree(cl);\n\nout:\n\tfile->private_data = NULL;\n\n\tmutex_unlock(&dev->device_lock);\n\treturn rets;\n}\n\n\n \nstatic ssize_t mei_read(struct file *file, char __user *ubuf,\n\t\t\tsize_t length, loff_t *offset)\n{\n\tstruct mei_cl *cl = file->private_data;\n\tstruct mei_device *dev;\n\tstruct mei_cl_cb *cb = NULL;\n\tbool nonblock = !!(file->f_flags & O_NONBLOCK);\n\tssize_t rets;\n\n\tif (WARN_ON(!cl || !cl->dev))\n\t\treturn -ENODEV;\n\n\tdev = cl->dev;\n\n\n\tmutex_lock(&dev->device_lock);\n\tif (dev->dev_state != MEI_DEV_ENABLED) {\n\t\trets = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (length == 0) {\n\t\trets = 0;\n\t\tgoto out;\n\t}\n\n\tif (ubuf == NULL) {\n\t\trets = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tcb = mei_cl_read_cb(cl, file);\n\tif (cb)\n\t\tgoto copy_buffer;\n\n\tif (*offset > 0)\n\t\t*offset = 0;\n\n\trets = mei_cl_read_start(cl, length, file);\n\tif (rets && rets != -EBUSY) {\n\t\tcl_dbg(dev, cl, \"mei start read failure status = %zd\\n\", rets);\n\t\tgoto out;\n\t}\n\n\tif (nonblock) {\n\t\trets = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tmutex_unlock(&dev->device_lock);\n\tif (wait_event_interruptible(cl->rx_wait,\n\t\t\t\t     mei_cl_read_cb(cl, file) ||\n\t\t\t\t     !mei_cl_is_connected(cl))) {\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t\treturn -ERESTARTSYS;\n\t}\n\tmutex_lock(&dev->device_lock);\n\n\tif (!mei_cl_is_connected(cl)) {\n\t\trets = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tcb = mei_cl_read_cb(cl, file);\n\tif (!cb) {\n\t\trets = 0;\n\t\tgoto out;\n\t}\n\ncopy_buffer:\n\t \n\tif (cb->status) {\n\t\trets = cb->status;\n\t\tcl_dbg(dev, cl, \"read operation failed %zd\\n\", rets);\n\t\tgoto free;\n\t}\n\n\tcl_dbg(dev, cl, \"buf.size = %zu buf.idx = %zu offset = %lld\\n\",\n\t       cb->buf.size, cb->buf_idx, *offset);\n\tif (*offset >= cb->buf_idx) {\n\t\trets = 0;\n\t\tgoto free;\n\t}\n\n\t \n\tlength = min_t(size_t, length, cb->buf_idx - *offset);\n\n\tif (copy_to_user(ubuf, cb->buf.data + *offset, length)) {\n\t\tdev_dbg(dev->dev, \"failed to copy data to userland\\n\");\n\t\trets = -EFAULT;\n\t\tgoto free;\n\t}\n\n\trets = length;\n\t*offset += length;\n\t \n\tif (*offset < cb->buf_idx)\n\t\tgoto out;\n\nfree:\n\tmei_cl_del_rd_completed(cl, cb);\n\t*offset = 0;\n\nout:\n\tcl_dbg(dev, cl, \"end mei read rets = %zd\\n\", rets);\n\tmutex_unlock(&dev->device_lock);\n\treturn rets;\n}\n\n \nstatic u8 mei_cl_vtag_by_fp(const struct mei_cl *cl, const struct file *fp)\n{\n\tstruct mei_cl_vtag *cl_vtag;\n\n\tif (!fp)\n\t\treturn 0;\n\n\tlist_for_each_entry(cl_vtag, &cl->vtag_map, list)\n\t\tif (cl_vtag->fp == fp)\n\t\t\treturn cl_vtag->vtag;\n\treturn 0;\n}\n\n \nstatic ssize_t mei_write(struct file *file, const char __user *ubuf,\n\t\t\t size_t length, loff_t *offset)\n{\n\tstruct mei_cl *cl = file->private_data;\n\tstruct mei_cl_cb *cb;\n\tstruct mei_device *dev;\n\tssize_t rets;\n\n\tif (WARN_ON(!cl || !cl->dev))\n\t\treturn -ENODEV;\n\n\tdev = cl->dev;\n\n\tmutex_lock(&dev->device_lock);\n\n\tif (dev->dev_state != MEI_DEV_ENABLED) {\n\t\trets = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!mei_cl_is_connected(cl)) {\n\t\tcl_err(dev, cl, \"is not connected\");\n\t\trets = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!mei_me_cl_is_active(cl->me_cl)) {\n\t\trets = -ENOTTY;\n\t\tgoto out;\n\t}\n\n\tif (length > mei_cl_mtu(cl)) {\n\t\trets = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tif (length == 0) {\n\t\trets = 0;\n\t\tgoto out;\n\t}\n\n\twhile (cl->tx_cb_queued >= dev->tx_queue_limit) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\trets = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_unlock(&dev->device_lock);\n\t\trets = wait_event_interruptible(cl->tx_wait,\n\t\t\t\tcl->writing_state == MEI_WRITE_COMPLETE ||\n\t\t\t\t(!mei_cl_is_connected(cl)));\n\t\tmutex_lock(&dev->device_lock);\n\t\tif (rets) {\n\t\t\tif (signal_pending(current))\n\t\t\t\trets = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!mei_cl_is_connected(cl)) {\n\t\t\trets = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, file);\n\tif (!cb) {\n\t\trets = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcb->vtag = mei_cl_vtag_by_fp(cl, file);\n\n\trets = copy_from_user(cb->buf.data, ubuf, length);\n\tif (rets) {\n\t\tdev_dbg(dev->dev, \"failed to copy data from userland\\n\");\n\t\trets = -EFAULT;\n\t\tmei_io_cb_free(cb);\n\t\tgoto out;\n\t}\n\n\trets = mei_cl_write(cl, cb, MAX_SCHEDULE_TIMEOUT);\nout:\n\tmutex_unlock(&dev->device_lock);\n\treturn rets;\n}\n\n \nstatic int mei_ioctl_connect_client(struct file *file,\n\t\t\t\t    const uuid_le *in_client_uuid,\n\t\t\t\t    struct mei_client *client)\n{\n\tstruct mei_device *dev;\n\tstruct mei_me_client *me_cl;\n\tstruct mei_cl *cl;\n\tint rets;\n\n\tcl = file->private_data;\n\tdev = cl->dev;\n\n\tif (cl->state != MEI_FILE_INITIALIZING &&\n\t    cl->state != MEI_FILE_DISCONNECTED)\n\t\treturn  -EBUSY;\n\n\t \n\tme_cl = mei_me_cl_by_uuid(dev, in_client_uuid);\n\tif (!me_cl) {\n\t\tdev_dbg(dev->dev, \"Cannot connect to FW Client UUID = %pUl\\n\",\n\t\t\tin_client_uuid);\n\t\trets = -ENOTTY;\n\t\tgoto end;\n\t}\n\n\tif (me_cl->props.fixed_address) {\n\t\tbool forbidden = dev->override_fixed_address ?\n\t\t\t !dev->allow_fixed_address : !dev->hbm_f_fa_supported;\n\t\tif (forbidden) {\n\t\t\tdev_dbg(dev->dev, \"Connection forbidden to FW Client UUID = %pUl\\n\",\n\t\t\t\tin_client_uuid);\n\t\t\trets = -ENOTTY;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tdev_dbg(dev->dev, \"Connect to FW Client ID = %d\\n\",\n\t\t\tme_cl->client_id);\n\tdev_dbg(dev->dev, \"FW Client - Protocol Version = %d\\n\",\n\t\t\tme_cl->props.protocol_version);\n\tdev_dbg(dev->dev, \"FW Client - Max Msg Len = %d\\n\",\n\t\t\tme_cl->props.max_msg_length);\n\n\t \n\tclient->max_msg_length = me_cl->props.max_msg_length;\n\tclient->protocol_version = me_cl->props.protocol_version;\n\tdev_dbg(dev->dev, \"Can connect?\\n\");\n\n\trets = mei_cl_connect(cl, me_cl, file);\n\nend:\n\tmei_me_cl_put(me_cl);\n\treturn rets;\n}\n\n \nstatic int mei_vt_support_check(struct mei_device *dev, const uuid_le *uuid)\n{\n\tstruct mei_me_client *me_cl;\n\tint ret;\n\n\tif (!dev->hbm_f_vt_supported)\n\t\treturn -EOPNOTSUPP;\n\n\tme_cl = mei_me_cl_by_uuid(dev, uuid);\n\tif (!me_cl) {\n\t\tdev_dbg(dev->dev, \"Cannot connect to FW Client UUID = %pUl\\n\",\n\t\t\tuuid);\n\t\treturn -ENOTTY;\n\t}\n\tret = me_cl->props.vt_supported ? 0 : -EOPNOTSUPP;\n\tmei_me_cl_put(me_cl);\n\n\treturn ret;\n}\n\n \nstatic int mei_ioctl_connect_vtag(struct file *file,\n\t\t\t\t  const uuid_le *in_client_uuid,\n\t\t\t\t  struct mei_client *client,\n\t\t\t\t  u8 vtag)\n{\n\tstruct mei_device *dev;\n\tstruct mei_cl *cl;\n\tstruct mei_cl *pos;\n\tstruct mei_cl_vtag *cl_vtag;\n\n\tcl = file->private_data;\n\tdev = cl->dev;\n\n\tdev_dbg(dev->dev, \"FW Client %pUl vtag %d\\n\", in_client_uuid, vtag);\n\n\tswitch (cl->state) {\n\tcase MEI_FILE_DISCONNECTED:\n\t\tif (mei_cl_vtag_by_fp(cl, file) != vtag) {\n\t\t\tdev_err(dev->dev, \"reconnect with different vtag\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase MEI_FILE_INITIALIZING:\n\t\t \n\t\tif (!IS_ERR(mei_cl_fp_by_vtag(cl, vtag))) {\n\t\t\tdev_err(dev->dev, \"vtag already filled\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlist_for_each_entry(pos, &dev->file_list, link) {\n\t\t\tif (pos == cl)\n\t\t\t\tcontinue;\n\t\t\tif (!pos->me_cl)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (uuid_le_cmp(*mei_cl_uuid(pos), *in_client_uuid))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!IS_ERR(mei_cl_fp_by_vtag(pos, vtag)))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tdev_dbg(dev->dev, \"replacing with existing cl\\n\");\n\t\t\tmei_cl_unlink(cl);\n\t\t\tkfree(cl);\n\t\t\tfile->private_data = pos;\n\t\t\tcl = pos;\n\t\t\tbreak;\n\t\t}\n\n\t\tcl_vtag = mei_cl_vtag_alloc(file, vtag);\n\t\tif (IS_ERR(cl_vtag))\n\t\t\treturn -ENOMEM;\n\n\t\tlist_add_tail(&cl_vtag->list, &cl->vtag_map);\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\twhile (cl->state != MEI_FILE_INITIALIZING &&\n\t       cl->state != MEI_FILE_DISCONNECTED &&\n\t       cl->state != MEI_FILE_CONNECTED) {\n\t\tmutex_unlock(&dev->device_lock);\n\t\twait_event_timeout(cl->wait,\n\t\t\t\t   (cl->state == MEI_FILE_CONNECTED ||\n\t\t\t\t    cl->state == MEI_FILE_DISCONNECTED ||\n\t\t\t\t    cl->state == MEI_FILE_DISCONNECT_REQUIRED ||\n\t\t\t\t    cl->state == MEI_FILE_DISCONNECT_REPLY),\n\t\t\t\t   dev->timeouts.cl_connect);\n\t\tmutex_lock(&dev->device_lock);\n\t}\n\n\tif (!mei_cl_is_connected(cl))\n\t\treturn mei_ioctl_connect_client(file, in_client_uuid, client);\n\n\tclient->max_msg_length = cl->me_cl->props.max_msg_length;\n\tclient->protocol_version = cl->me_cl->props.protocol_version;\n\n\treturn 0;\n}\n\n \nstatic int mei_ioctl_client_notify_request(const struct file *file, u32 request)\n{\n\tstruct mei_cl *cl = file->private_data;\n\n\tif (request != MEI_HBM_NOTIFICATION_START &&\n\t    request != MEI_HBM_NOTIFICATION_STOP)\n\t\treturn -EINVAL;\n\n\treturn mei_cl_notify_request(cl, file, (u8)request);\n}\n\n \nstatic int mei_ioctl_client_notify_get(const struct file *file, u32 *notify_get)\n{\n\tstruct mei_cl *cl = file->private_data;\n\tbool notify_ev;\n\tbool block = (file->f_flags & O_NONBLOCK) == 0;\n\tint rets;\n\n\trets = mei_cl_notify_get(cl, block, &notify_ev);\n\tif (rets)\n\t\treturn rets;\n\n\t*notify_get = notify_ev ? 1 : 0;\n\treturn 0;\n}\n\n \nstatic long mei_ioctl(struct file *file, unsigned int cmd, unsigned long data)\n{\n\tstruct mei_device *dev;\n\tstruct mei_cl *cl = file->private_data;\n\tstruct mei_connect_client_data conn;\n\tstruct mei_connect_client_data_vtag conn_vtag;\n\tconst uuid_le *cl_uuid;\n\tstruct mei_client *props;\n\tu8 vtag;\n\tu32 notify_get, notify_req;\n\tint rets;\n\n\n\tif (WARN_ON(!cl || !cl->dev))\n\t\treturn -ENODEV;\n\n\tdev = cl->dev;\n\n\tdev_dbg(dev->dev, \"IOCTL cmd = 0x%x\", cmd);\n\n\tmutex_lock(&dev->device_lock);\n\tif (dev->dev_state != MEI_DEV_ENABLED) {\n\t\trets = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase IOCTL_MEI_CONNECT_CLIENT:\n\t\tdev_dbg(dev->dev, \": IOCTL_MEI_CONNECT_CLIENT.\\n\");\n\t\tif (copy_from_user(&conn, (char __user *)data, sizeof(conn))) {\n\t\t\tdev_dbg(dev->dev, \"failed to copy data from userland\\n\");\n\t\t\trets = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tcl_uuid = &conn.in_client_uuid;\n\t\tprops = &conn.out_client_properties;\n\t\tvtag = 0;\n\n\t\trets = mei_vt_support_check(dev, cl_uuid);\n\t\tif (rets == -ENOTTY)\n\t\t\tgoto out;\n\t\tif (!rets)\n\t\t\trets = mei_ioctl_connect_vtag(file, cl_uuid, props,\n\t\t\t\t\t\t      vtag);\n\t\telse\n\t\t\trets = mei_ioctl_connect_client(file, cl_uuid, props);\n\t\tif (rets)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (copy_to_user((char __user *)data, &conn, sizeof(conn))) {\n\t\t\tdev_dbg(dev->dev, \"failed to copy data to userland\\n\");\n\t\t\trets = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\n\tcase IOCTL_MEI_CONNECT_CLIENT_VTAG:\n\t\tdev_dbg(dev->dev, \"IOCTL_MEI_CONNECT_CLIENT_VTAG\\n\");\n\t\tif (copy_from_user(&conn_vtag, (char __user *)data,\n\t\t\t\t   sizeof(conn_vtag))) {\n\t\t\tdev_dbg(dev->dev, \"failed to copy data from userland\\n\");\n\t\t\trets = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcl_uuid = &conn_vtag.connect.in_client_uuid;\n\t\tprops = &conn_vtag.out_client_properties;\n\t\tvtag = conn_vtag.connect.vtag;\n\n\t\trets = mei_vt_support_check(dev, cl_uuid);\n\t\tif (rets == -EOPNOTSUPP)\n\t\t\tdev_dbg(dev->dev, \"FW Client %pUl does not support vtags\\n\",\n\t\t\t\tcl_uuid);\n\t\tif (rets)\n\t\t\tgoto out;\n\n\t\tif (!vtag) {\n\t\t\tdev_dbg(dev->dev, \"vtag can't be zero\\n\");\n\t\t\trets = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trets = mei_ioctl_connect_vtag(file, cl_uuid, props, vtag);\n\t\tif (rets)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (copy_to_user((char __user *)data, &conn_vtag,\n\t\t\t\t sizeof(conn_vtag))) {\n\t\t\tdev_dbg(dev->dev, \"failed to copy data to userland\\n\");\n\t\t\trets = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\n\tcase IOCTL_MEI_NOTIFY_SET:\n\t\tdev_dbg(dev->dev, \": IOCTL_MEI_NOTIFY_SET.\\n\");\n\t\tif (copy_from_user(&notify_req,\n\t\t\t\t   (char __user *)data, sizeof(notify_req))) {\n\t\t\tdev_dbg(dev->dev, \"failed to copy data from userland\\n\");\n\t\t\trets = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\trets = mei_ioctl_client_notify_request(file, notify_req);\n\t\tbreak;\n\n\tcase IOCTL_MEI_NOTIFY_GET:\n\t\tdev_dbg(dev->dev, \": IOCTL_MEI_NOTIFY_GET.\\n\");\n\t\trets = mei_ioctl_client_notify_get(file, &notify_get);\n\t\tif (rets)\n\t\t\tgoto out;\n\n\t\tdev_dbg(dev->dev, \"copy connect data to user\\n\");\n\t\tif (copy_to_user((char __user *)data,\n\t\t\t\t&notify_get, sizeof(notify_get))) {\n\t\t\tdev_dbg(dev->dev, \"failed to copy data to userland\\n\");\n\t\t\trets = -EFAULT;\n\t\t\tgoto out;\n\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trets = -ENOIOCTLCMD;\n\t}\n\nout:\n\tmutex_unlock(&dev->device_lock);\n\treturn rets;\n}\n\n \nstatic __poll_t mei_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t req_events = poll_requested_events(wait);\n\tstruct mei_cl *cl = file->private_data;\n\tstruct mei_device *dev;\n\t__poll_t mask = 0;\n\tbool notify_en;\n\n\tif (WARN_ON(!cl || !cl->dev))\n\t\treturn EPOLLERR;\n\n\tdev = cl->dev;\n\n\tmutex_lock(&dev->device_lock);\n\n\tnotify_en = cl->notify_en && (req_events & EPOLLPRI);\n\n\tif (dev->dev_state != MEI_DEV_ENABLED ||\n\t    !mei_cl_is_connected(cl)) {\n\t\tmask = EPOLLERR;\n\t\tgoto out;\n\t}\n\n\tif (notify_en) {\n\t\tpoll_wait(file, &cl->ev_wait, wait);\n\t\tif (cl->notify_ev)\n\t\t\tmask |= EPOLLPRI;\n\t}\n\n\tif (req_events & (EPOLLIN | EPOLLRDNORM)) {\n\t\tpoll_wait(file, &cl->rx_wait, wait);\n\n\t\tif (mei_cl_read_cb(cl, file))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t\telse\n\t\t\tmei_cl_read_start(cl, mei_cl_mtu(cl), file);\n\t}\n\n\tif (req_events & (EPOLLOUT | EPOLLWRNORM)) {\n\t\tpoll_wait(file, &cl->tx_wait, wait);\n\t\tif (cl->tx_cb_queued < dev->tx_queue_limit)\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t}\n\nout:\n\tmutex_unlock(&dev->device_lock);\n\treturn mask;\n}\n\n \nstatic bool mei_cl_is_write_queued(struct mei_cl *cl)\n{\n\tstruct mei_device *dev = cl->dev;\n\tstruct mei_cl_cb *cb;\n\n\tlist_for_each_entry(cb, &dev->write_list, list)\n\t\tif (cb->cl == cl)\n\t\t\treturn true;\n\tlist_for_each_entry(cb, &dev->write_waiting_list, list)\n\t\tif (cb->cl == cl)\n\t\t\treturn true;\n\treturn false;\n}\n\n \nstatic int mei_fsync(struct file *fp, loff_t start, loff_t end, int datasync)\n{\n\tstruct mei_cl *cl = fp->private_data;\n\tstruct mei_device *dev;\n\tint rets;\n\n\tif (WARN_ON(!cl || !cl->dev))\n\t\treturn -ENODEV;\n\n\tdev = cl->dev;\n\n\tmutex_lock(&dev->device_lock);\n\n\tif (dev->dev_state != MEI_DEV_ENABLED || !mei_cl_is_connected(cl)) {\n\t\trets = -ENODEV;\n\t\tgoto out;\n\t}\n\n\twhile (mei_cl_is_write_queued(cl)) {\n\t\tmutex_unlock(&dev->device_lock);\n\t\trets = wait_event_interruptible(cl->tx_wait,\n\t\t\t\tcl->writing_state == MEI_WRITE_COMPLETE ||\n\t\t\t\t!mei_cl_is_connected(cl));\n\t\tmutex_lock(&dev->device_lock);\n\t\tif (rets) {\n\t\t\tif (signal_pending(current))\n\t\t\t\trets = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!mei_cl_is_connected(cl)) {\n\t\t\trets = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trets = 0;\nout:\n\tmutex_unlock(&dev->device_lock);\n\treturn rets;\n}\n\n \nstatic int mei_fasync(int fd, struct file *file, int band)\n{\n\n\tstruct mei_cl *cl = file->private_data;\n\n\tif (!mei_cl_is_connected(cl))\n\t\treturn -ENODEV;\n\n\treturn fasync_helper(fd, file, band, &cl->ev_async);\n}\n\n \nstatic ssize_t trc_show(struct device *device,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\tu32 trc;\n\tint ret;\n\n\tret = mei_trc_status(dev, &trc);\n\tif (ret)\n\t\treturn ret;\n\treturn sprintf(buf, \"%08X\\n\", trc);\n}\nstatic DEVICE_ATTR_RO(trc);\n\n \nstatic ssize_t fw_status_show(struct device *device,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\tstruct mei_fw_status fw_status;\n\tint err, i;\n\tssize_t cnt = 0;\n\n\tmutex_lock(&dev->device_lock);\n\terr = mei_fw_status(dev, &fw_status);\n\tmutex_unlock(&dev->device_lock);\n\tif (err) {\n\t\tdev_err(device, \"read fw_status error = %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < fw_status.count; i++)\n\t\tcnt += scnprintf(buf + cnt, PAGE_SIZE - cnt, \"%08X\\n\",\n\t\t\t\tfw_status.status[i]);\n\treturn cnt;\n}\nstatic DEVICE_ATTR_RO(fw_status);\n\n \nstatic ssize_t hbm_ver_show(struct device *device,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\tstruct hbm_version ver;\n\n\tmutex_lock(&dev->device_lock);\n\tver = dev->version;\n\tmutex_unlock(&dev->device_lock);\n\n\treturn sprintf(buf, \"%u.%u\\n\", ver.major_version, ver.minor_version);\n}\nstatic DEVICE_ATTR_RO(hbm_ver);\n\n \nstatic ssize_t hbm_ver_drv_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u.%u\\n\", HBM_MAJOR_VERSION, HBM_MINOR_VERSION);\n}\nstatic DEVICE_ATTR_RO(hbm_ver_drv);\n\nstatic ssize_t tx_queue_limit_show(struct device *device,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\tu8 size = 0;\n\n\tmutex_lock(&dev->device_lock);\n\tsize = dev->tx_queue_limit;\n\tmutex_unlock(&dev->device_lock);\n\n\treturn sysfs_emit(buf, \"%u\\n\", size);\n}\n\nstatic ssize_t tx_queue_limit_store(struct device *device,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\tu8 limit;\n\tunsigned int inp;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &inp);\n\tif (err)\n\t\treturn err;\n\tif (inp > MEI_TX_QUEUE_LIMIT_MAX || inp < MEI_TX_QUEUE_LIMIT_MIN)\n\t\treturn -EINVAL;\n\tlimit = inp;\n\n\tmutex_lock(&dev->device_lock);\n\tdev->tx_queue_limit = limit;\n\tmutex_unlock(&dev->device_lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(tx_queue_limit);\n\n \nstatic ssize_t fw_ver_show(struct device *device,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\tstruct mei_fw_version *ver;\n\tssize_t cnt = 0;\n\tint i;\n\n\tver = dev->fw_ver;\n\n\tfor (i = 0; i < MEI_MAX_FW_VER_BLOCKS; i++)\n\t\tcnt += scnprintf(buf + cnt, PAGE_SIZE - cnt, \"%u:%u.%u.%u.%u\\n\",\n\t\t\t\t ver[i].platform, ver[i].major, ver[i].minor,\n\t\t\t\t ver[i].hotfix, ver[i].buildno);\n\treturn cnt;\n}\nstatic DEVICE_ATTR_RO(fw_ver);\n\n \nstatic ssize_t dev_state_show(struct device *device,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\tenum mei_dev_state dev_state;\n\n\tmutex_lock(&dev->device_lock);\n\tdev_state = dev->dev_state;\n\tmutex_unlock(&dev->device_lock);\n\n\treturn sprintf(buf, \"%s\", mei_dev_state_str(dev_state));\n}\nstatic DEVICE_ATTR_RO(dev_state);\n\n \nvoid mei_set_devstate(struct mei_device *dev, enum mei_dev_state state)\n{\n\tstruct device *clsdev;\n\n\tif (dev->dev_state == state)\n\t\treturn;\n\n\tdev->dev_state = state;\n\n\tclsdev = class_find_device_by_devt(&mei_class, dev->cdev.dev);\n\tif (clsdev) {\n\t\tsysfs_notify(&clsdev->kobj, NULL, \"dev_state\");\n\t\tput_device(clsdev);\n\t}\n}\n\n \nstatic ssize_t kind_show(struct device *device,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\tssize_t ret;\n\n\tif (dev->kind)\n\t\tret = sprintf(buf, \"%s\\n\", dev->kind);\n\telse\n\t\tret = sprintf(buf, \"%s\\n\", \"mei\");\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(kind);\n\nstatic struct attribute *mei_attrs[] = {\n\t&dev_attr_fw_status.attr,\n\t&dev_attr_hbm_ver.attr,\n\t&dev_attr_hbm_ver_drv.attr,\n\t&dev_attr_tx_queue_limit.attr,\n\t&dev_attr_fw_ver.attr,\n\t&dev_attr_dev_state.attr,\n\t&dev_attr_trc.attr,\n\t&dev_attr_kind.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(mei);\n\n \nstatic const struct file_operations mei_fops = {\n\t.owner = THIS_MODULE,\n\t.read = mei_read,\n\t.unlocked_ioctl = mei_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.open = mei_open,\n\t.release = mei_release,\n\t.write = mei_write,\n\t.poll = mei_poll,\n\t.fsync = mei_fsync,\n\t.fasync = mei_fasync,\n\t.llseek = no_llseek\n};\n\n \nstatic int mei_minor_get(struct mei_device *dev)\n{\n\tint ret;\n\n\tmutex_lock(&mei_minor_lock);\n\tret = idr_alloc(&mei_idr, dev, 0, MEI_MAX_DEVS, GFP_KERNEL);\n\tif (ret >= 0)\n\t\tdev->minor = ret;\n\telse if (ret == -ENOSPC)\n\t\tdev_err(dev->dev, \"too many mei devices\\n\");\n\n\tmutex_unlock(&mei_minor_lock);\n\treturn ret;\n}\n\n \nstatic void mei_minor_free(struct mei_device *dev)\n{\n\tmutex_lock(&mei_minor_lock);\n\tidr_remove(&mei_idr, dev->minor);\n\tmutex_unlock(&mei_minor_lock);\n}\n\nint mei_register(struct mei_device *dev, struct device *parent)\n{\n\tstruct device *clsdev;  \n\tint ret, devno;\n\n\tret = mei_minor_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdevno = MKDEV(MAJOR(mei_devt), dev->minor);\n\tcdev_init(&dev->cdev, &mei_fops);\n\tdev->cdev.owner = parent->driver->owner;\n\n\t \n\tret = cdev_add(&dev->cdev, devno, 1);\n\tif (ret) {\n\t\tdev_err(parent, \"unable to add device %d:%d\\n\",\n\t\t\tMAJOR(mei_devt), dev->minor);\n\t\tgoto err_dev_add;\n\t}\n\n\tclsdev = device_create_with_groups(&mei_class, parent, devno,\n\t\t\t\t\t   dev, mei_groups,\n\t\t\t\t\t   \"mei%d\", dev->minor);\n\n\tif (IS_ERR(clsdev)) {\n\t\tdev_err(parent, \"unable to create device %d:%d\\n\",\n\t\t\tMAJOR(mei_devt), dev->minor);\n\t\tret = PTR_ERR(clsdev);\n\t\tgoto err_dev_create;\n\t}\n\n\tmei_dbgfs_register(dev, dev_name(clsdev));\n\n\treturn 0;\n\nerr_dev_create:\n\tcdev_del(&dev->cdev);\nerr_dev_add:\n\tmei_minor_free(dev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mei_register);\n\nvoid mei_deregister(struct mei_device *dev)\n{\n\tint devno;\n\n\tdevno = dev->cdev.dev;\n\tcdev_del(&dev->cdev);\n\n\tmei_dbgfs_deregister(dev);\n\n\tdevice_destroy(&mei_class, devno);\n\n\tmei_minor_free(dev);\n}\nEXPORT_SYMBOL_GPL(mei_deregister);\n\nstatic int __init mei_init(void)\n{\n\tint ret;\n\n\tret = class_register(&mei_class);\n\tif (ret)\n\t\treturn ret;\n\n\tret = alloc_chrdev_region(&mei_devt, 0, MEI_MAX_DEVS, \"mei\");\n\tif (ret < 0) {\n\t\tpr_err(\"unable to allocate char dev region\\n\");\n\t\tgoto err_class;\n\t}\n\n\tret = mei_cl_bus_init();\n\tif (ret < 0) {\n\t\tpr_err(\"unable to initialize bus\\n\");\n\t\tgoto err_chrdev;\n\t}\n\n\treturn 0;\n\nerr_chrdev:\n\tunregister_chrdev_region(mei_devt, MEI_MAX_DEVS);\nerr_class:\n\tclass_unregister(&mei_class);\n\treturn ret;\n}\n\nstatic void __exit mei_exit(void)\n{\n\tunregister_chrdev_region(mei_devt, MEI_MAX_DEVS);\n\tclass_unregister(&mei_class);\n\tmei_cl_bus_exit();\n}\n\nmodule_init(mei_init);\nmodule_exit(mei_exit);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_DESCRIPTION(\"Intel(R) Management Engine Interface\");\nMODULE_LICENSE(\"GPL v2\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}