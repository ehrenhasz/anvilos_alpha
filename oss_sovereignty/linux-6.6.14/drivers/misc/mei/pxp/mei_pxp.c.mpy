{
  "module_name": "mei_pxp.c",
  "hash_id": "9bd816f440b5bfde909b5b902e61415c97ce1462045a59d27d7a38b338317eb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/pxp/mei_pxp.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mei.h>\n#include <linux/mei_cl_bus.h>\n#include <linux/component.h>\n#include <drm/drm_connector.h>\n#include <drm/i915_component.h>\n#include <drm/i915_pxp_tee_interface.h>\n\n#include \"mei_pxp.h\"\n\n \nstatic int\nmei_pxp_send_message(struct device *dev, const void *message, size_t size)\n{\n\tstruct mei_cl_device *cldev;\n\tssize_t byte;\n\n\tif (!dev || !message)\n\t\treturn -EINVAL;\n\n\tcldev = to_mei_cl_device(dev);\n\n\tbyte = mei_cldev_send(cldev, message, size);\n\tif (byte < 0) {\n\t\tdev_dbg(dev, \"mei_cldev_send failed. %zd\\n\", byte);\n\t\treturn byte;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmei_pxp_receive_message(struct device *dev, void *buffer, size_t size)\n{\n\tstruct mei_cl_device *cldev;\n\tssize_t byte;\n\n\tif (!dev || !buffer)\n\t\treturn -EINVAL;\n\n\tcldev = to_mei_cl_device(dev);\n\n\tbyte = mei_cldev_recv(cldev, buffer, size);\n\tif (byte < 0) {\n\t\tdev_dbg(dev, \"mei_cldev_recv failed. %zd\\n\", byte);\n\t\treturn byte;\n\t}\n\n\treturn byte;\n}\n\n \nstatic ssize_t mei_pxp_gsc_command(struct device *dev, u8 client_id, u32 fence_id,\n\t\t\t\t   struct scatterlist *sg_in, size_t total_in_len,\n\t\t\t\t   struct scatterlist *sg_out)\n{\n\tstruct mei_cl_device *cldev;\n\n\tcldev = to_mei_cl_device(dev);\n\n\treturn mei_cldev_send_gsc_command(cldev, client_id, fence_id, sg_in, total_in_len, sg_out);\n}\n\nstatic const struct i915_pxp_component_ops mei_pxp_ops = {\n\t.owner = THIS_MODULE,\n\t.send = mei_pxp_send_message,\n\t.recv = mei_pxp_receive_message,\n\t.gsc_command = mei_pxp_gsc_command,\n};\n\nstatic int mei_component_master_bind(struct device *dev)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tstruct i915_pxp_component *comp_master = mei_cldev_get_drvdata(cldev);\n\tint ret;\n\n\tcomp_master->ops = &mei_pxp_ops;\n\tcomp_master->tee_dev = dev;\n\tret = component_bind_all(dev, comp_master);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void mei_component_master_unbind(struct device *dev)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tstruct i915_pxp_component *comp_master = mei_cldev_get_drvdata(cldev);\n\n\tcomponent_unbind_all(dev, comp_master);\n}\n\nstatic const struct component_master_ops mei_component_master_ops = {\n\t.bind = mei_component_master_bind,\n\t.unbind = mei_component_master_unbind,\n};\n\n \nstatic int mei_pxp_component_match(struct device *dev, int subcomponent,\n\t\t\t\t   void *data)\n{\n\tstruct device *base = data;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (!dev->driver || strcmp(dev->driver->name, \"i915\") ||\n\t    subcomponent != I915_COMPONENT_PXP)\n\t\treturn 0;\n\n\tbase = base->parent;\n\tif (!base)  \n\t\treturn 0;\n\n\tbase = base->parent;  \n\t \n\tif (base && dev == base)\n\t\treturn 1;\n\n\t \n\tdev = dev->parent;\n\treturn (base && dev && dev == base);\n}\n\nstatic int mei_pxp_probe(struct mei_cl_device *cldev,\n\t\t\t const struct mei_cl_device_id *id)\n{\n\tstruct i915_pxp_component *comp_master;\n\tstruct component_match *master_match;\n\tint ret;\n\n\tret = mei_cldev_enable(cldev);\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"mei_cldev_enable Failed. %d\\n\", ret);\n\t\tgoto enable_err_exit;\n\t}\n\n\tcomp_master = kzalloc(sizeof(*comp_master), GFP_KERNEL);\n\tif (!comp_master) {\n\t\tret = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\tmaster_match = NULL;\n\tcomponent_match_add_typed(&cldev->dev, &master_match,\n\t\t\t\t  mei_pxp_component_match, &cldev->dev);\n\tif (IS_ERR_OR_NULL(master_match)) {\n\t\tret = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\tmei_cldev_set_drvdata(cldev, comp_master);\n\tret = component_master_add_with_match(&cldev->dev,\n\t\t\t\t\t      &mei_component_master_ops,\n\t\t\t\t\t      master_match);\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"Master comp add failed %d\\n\", ret);\n\t\tgoto err_exit;\n\t}\n\n\treturn 0;\n\nerr_exit:\n\tmei_cldev_set_drvdata(cldev, NULL);\n\tkfree(comp_master);\n\tmei_cldev_disable(cldev);\nenable_err_exit:\n\treturn ret;\n}\n\nstatic void mei_pxp_remove(struct mei_cl_device *cldev)\n{\n\tstruct i915_pxp_component *comp_master = mei_cldev_get_drvdata(cldev);\n\tint ret;\n\n\tcomponent_master_del(&cldev->dev, &mei_component_master_ops);\n\tkfree(comp_master);\n\tmei_cldev_set_drvdata(cldev, NULL);\n\n\tret = mei_cldev_disable(cldev);\n\tif (ret)\n\t\tdev_warn(&cldev->dev, \"mei_cldev_disable() failed\\n\");\n}\n\n \n#define MEI_GUID_PXP UUID_LE(0xfbf6fcf1, 0x96cf, 0x4e2e, 0xA6, \\\n\t\t\t     0xa6, 0x1b, 0xab, 0x8c, 0xbe, 0x36, 0xb1)\n\nstatic struct mei_cl_device_id mei_pxp_tbl[] = {\n\t{ .uuid = MEI_GUID_PXP, .version = MEI_CL_VERSION_ANY },\n\t{ }\n};\nMODULE_DEVICE_TABLE(mei, mei_pxp_tbl);\n\nstatic struct mei_cl_driver mei_pxp_driver = {\n\t.id_table = mei_pxp_tbl,\n\t.name = KBUILD_MODNAME,\n\t.probe = mei_pxp_probe,\n\t.remove\t= mei_pxp_remove,\n};\n\nmodule_mei_cl_driver(mei_pxp_driver);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MEI PXP\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}