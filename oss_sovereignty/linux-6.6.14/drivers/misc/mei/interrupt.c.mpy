{
  "module_name": "interrupt.c",
  "hash_id": "40bf6afb24f3a849a63842633622e6c68b0ad26b51e230c260ee6f52e07d2791",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/interrupt.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/fs.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/mei.h>\n\n#include \"mei_dev.h\"\n#include \"hbm.h\"\n#include \"client.h\"\n\n\n \nvoid mei_irq_compl_handler(struct mei_device *dev, struct list_head *cmpl_list)\n{\n\tstruct mei_cl_cb *cb, *next;\n\tstruct mei_cl *cl;\n\n\tlist_for_each_entry_safe(cb, next, cmpl_list, list) {\n\t\tcl = cb->cl;\n\t\tlist_del_init(&cb->list);\n\n\t\tdev_dbg(dev->dev, \"completing call back.\\n\");\n\t\tmei_cl_complete(cl, cb);\n\t}\n}\nEXPORT_SYMBOL_GPL(mei_irq_compl_handler);\n\n \nstatic inline int mei_cl_hbm_equal(struct mei_cl *cl,\n\t\t\tstruct mei_msg_hdr *mei_hdr)\n{\n\treturn  mei_cl_host_addr(cl) == mei_hdr->host_addr &&\n\t\tmei_cl_me_id(cl) == mei_hdr->me_addr;\n}\n\n \nstatic void mei_irq_discard_msg(struct mei_device *dev, struct mei_msg_hdr *hdr,\n\t\t\t\tsize_t discard_len)\n{\n\tif (hdr->dma_ring) {\n\t\tmei_dma_ring_read(dev, NULL,\n\t\t\t\t  hdr->extension[dev->rd_msg_hdr_count - 2]);\n\t\tdiscard_len = 0;\n\t}\n\t \n\tmei_read_slots(dev, dev->rd_msg_buf, discard_len);\n\tdev_dbg(dev->dev, \"discarding message \" MEI_HDR_FMT \"\\n\",\n\t\tMEI_HDR_PRM(hdr));\n}\n\n \nstatic int mei_cl_irq_read_msg(struct mei_cl *cl,\n\t\t\t       struct mei_msg_hdr *mei_hdr,\n\t\t\t       struct mei_ext_meta_hdr *meta,\n\t\t\t       struct list_head *cmpl_list)\n{\n\tstruct mei_device *dev = cl->dev;\n\tstruct mei_cl_cb *cb;\n\n\tstruct mei_ext_hdr_vtag *vtag_hdr = NULL;\n\tstruct mei_ext_hdr_gsc_f2h *gsc_f2h = NULL;\n\n\tsize_t buf_sz;\n\tu32 length;\n\tu32 ext_len;\n\n\tlength = mei_hdr->length;\n\text_len = 0;\n\tif (mei_hdr->extended) {\n\t\text_len = sizeof(*meta) + mei_slots2data(meta->size);\n\t\tlength -= ext_len;\n\t}\n\n\tcb = list_first_entry_or_null(&cl->rd_pending, struct mei_cl_cb, list);\n\tif (!cb) {\n\t\tif (!mei_cl_is_fixed_address(cl)) {\n\t\t\tcl_err(dev, cl, \"pending read cb not found\\n\");\n\t\t\tgoto discard;\n\t\t}\n\t\tcb = mei_cl_alloc_cb(cl, mei_cl_mtu(cl), MEI_FOP_READ, cl->fp);\n\t\tif (!cb)\n\t\t\tgoto discard;\n\t\tlist_add_tail(&cb->list, &cl->rd_pending);\n\t}\n\n\tif (mei_hdr->extended) {\n\t\tstruct mei_ext_hdr *ext = mei_ext_begin(meta);\n\t\tdo {\n\t\t\tswitch (ext->type) {\n\t\t\tcase MEI_EXT_HDR_VTAG:\n\t\t\t\tvtag_hdr = (struct mei_ext_hdr_vtag *)ext;\n\t\t\t\tbreak;\n\t\t\tcase MEI_EXT_HDR_GSC:\n\t\t\t\tgsc_f2h = (struct mei_ext_hdr_gsc_f2h *)ext;\n\t\t\t\tcb->ext_hdr = kzalloc(sizeof(*gsc_f2h), GFP_KERNEL);\n\t\t\t\tif (!cb->ext_hdr) {\n\t\t\t\t\tcb->status = -ENOMEM;\n\t\t\t\t\tgoto discard;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MEI_EXT_HDR_NONE:\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tcl_err(dev, cl, \"unknown extended header\\n\");\n\t\t\t\tcb->status = -EPROTO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\text = mei_ext_next(ext);\n\t\t} while (!mei_ext_last(meta, ext));\n\n\t\tif (!vtag_hdr && !gsc_f2h) {\n\t\t\tcl_dbg(dev, cl, \"no vtag or gsc found in extended header.\\n\");\n\t\t\tcb->status = -EPROTO;\n\t\t\tgoto discard;\n\t\t}\n\t}\n\n\tif (vtag_hdr) {\n\t\tcl_dbg(dev, cl, \"vtag: %d\\n\", vtag_hdr->vtag);\n\t\tif (cb->vtag && cb->vtag != vtag_hdr->vtag) {\n\t\t\tcl_err(dev, cl, \"mismatched tag: %d != %d\\n\",\n\t\t\t       cb->vtag, vtag_hdr->vtag);\n\t\t\tcb->status = -EPROTO;\n\t\t\tgoto discard;\n\t\t}\n\t\tcb->vtag = vtag_hdr->vtag;\n\t}\n\n\tif (gsc_f2h) {\n\t\tu32 ext_hdr_len = mei_ext_hdr_len(&gsc_f2h->hdr);\n\n\t\tif (!dev->hbm_f_gsc_supported) {\n\t\t\tcl_err(dev, cl, \"gsc extended header is not supported\\n\");\n\t\t\tcb->status = -EPROTO;\n\t\t\tgoto discard;\n\t\t}\n\n\t\tif (length) {\n\t\t\tcl_err(dev, cl, \"no data allowed in cb with gsc\\n\");\n\t\t\tcb->status = -EPROTO;\n\t\t\tgoto discard;\n\t\t}\n\t\tif (ext_hdr_len > sizeof(*gsc_f2h)) {\n\t\t\tcl_err(dev, cl, \"gsc extended header is too big %u\\n\", ext_hdr_len);\n\t\t\tcb->status = -EPROTO;\n\t\t\tgoto discard;\n\t\t}\n\t\tmemcpy(cb->ext_hdr, gsc_f2h, ext_hdr_len);\n\t}\n\n\tif (!mei_cl_is_connected(cl)) {\n\t\tcl_dbg(dev, cl, \"not connected\\n\");\n\t\tcb->status = -ENODEV;\n\t\tgoto discard;\n\t}\n\n\tif (mei_hdr->dma_ring)\n\t\tlength = mei_hdr->extension[mei_data2slots(ext_len)];\n\n\tbuf_sz = length + cb->buf_idx;\n\t \n\tif (buf_sz < cb->buf_idx) {\n\t\tcl_err(dev, cl, \"message is too big len %d idx %zu\\n\",\n\t\t       length, cb->buf_idx);\n\t\tcb->status = -EMSGSIZE;\n\t\tgoto discard;\n\t}\n\n\tif (cb->buf.size < buf_sz) {\n\t\tcl_dbg(dev, cl, \"message overflow. size %zu len %d idx %zu\\n\",\n\t\t\tcb->buf.size, length, cb->buf_idx);\n\t\tcb->status = -EMSGSIZE;\n\t\tgoto discard;\n\t}\n\n\tif (mei_hdr->dma_ring) {\n\t\tmei_dma_ring_read(dev, cb->buf.data + cb->buf_idx, length);\n\t\t \n\t\tmei_read_slots(dev, cb->buf.data + cb->buf_idx, 0);\n\t} else {\n\t\tmei_read_slots(dev, cb->buf.data + cb->buf_idx, length);\n\t}\n\n\tcb->buf_idx += length;\n\n\tif (mei_hdr->msg_complete) {\n\t\tcl_dbg(dev, cl, \"completed read length = %zu\\n\", cb->buf_idx);\n\t\tlist_move_tail(&cb->list, cmpl_list);\n\t} else {\n\t\tpm_runtime_mark_last_busy(dev->dev);\n\t\tpm_request_autosuspend(dev->dev);\n\t}\n\n\treturn 0;\n\ndiscard:\n\tif (cb)\n\t\tlist_move_tail(&cb->list, cmpl_list);\n\tmei_irq_discard_msg(dev, mei_hdr, length);\n\treturn 0;\n}\n\n \nstatic int mei_cl_irq_disconnect_rsp(struct mei_cl *cl, struct mei_cl_cb *cb,\n\t\t\t\t     struct list_head *cmpl_list)\n{\n\tstruct mei_device *dev = cl->dev;\n\tu32 msg_slots;\n\tint slots;\n\tint ret;\n\n\tmsg_slots = mei_hbm2slots(sizeof(struct hbm_client_connect_response));\n\tslots = mei_hbuf_empty_slots(dev);\n\tif (slots < 0)\n\t\treturn -EOVERFLOW;\n\n\tif ((u32)slots < msg_slots)\n\t\treturn -EMSGSIZE;\n\n\tret = mei_hbm_cl_disconnect_rsp(dev, cl);\n\tlist_move_tail(&cb->list, cmpl_list);\n\n\treturn ret;\n}\n\n \nstatic int mei_cl_irq_read(struct mei_cl *cl, struct mei_cl_cb *cb,\n\t\t\t   struct list_head *cmpl_list)\n{\n\tstruct mei_device *dev = cl->dev;\n\tu32 msg_slots;\n\tint slots;\n\tint ret;\n\n\tif (!list_empty(&cl->rd_pending))\n\t\treturn 0;\n\n\tmsg_slots = mei_hbm2slots(sizeof(struct hbm_flow_control));\n\tslots = mei_hbuf_empty_slots(dev);\n\tif (slots < 0)\n\t\treturn -EOVERFLOW;\n\n\tif ((u32)slots < msg_slots)\n\t\treturn -EMSGSIZE;\n\n\tret = mei_hbm_cl_flow_control_req(dev, cl);\n\tif (ret) {\n\t\tcl->status = ret;\n\t\tcb->buf_idx = 0;\n\t\tlist_move_tail(&cb->list, cmpl_list);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_request_autosuspend(dev->dev);\n\n\tlist_move_tail(&cb->list, &cl->rd_pending);\n\n\treturn 0;\n}\n\nstatic inline bool hdr_is_hbm(struct mei_msg_hdr *mei_hdr)\n{\n\treturn mei_hdr->host_addr == 0 && mei_hdr->me_addr == 0;\n}\n\nstatic inline bool hdr_is_fixed(struct mei_msg_hdr *mei_hdr)\n{\n\treturn mei_hdr->host_addr == 0 && mei_hdr->me_addr != 0;\n}\n\nstatic inline int hdr_is_valid(u32 msg_hdr)\n{\n\tstruct mei_msg_hdr *mei_hdr;\n\tu32 expected_len = 0;\n\n\tmei_hdr = (struct mei_msg_hdr *)&msg_hdr;\n\tif (!msg_hdr || mei_hdr->reserved)\n\t\treturn -EBADMSG;\n\n\tif (mei_hdr->dma_ring)\n\t\texpected_len += MEI_SLOT_SIZE;\n\tif (mei_hdr->extended)\n\t\texpected_len += MEI_SLOT_SIZE;\n\tif (mei_hdr->length < expected_len)\n\t\treturn -EBADMSG;\n\n\treturn 0;\n}\n\n \nint mei_irq_read_handler(struct mei_device *dev,\n\t\t\t struct list_head *cmpl_list, s32 *slots)\n{\n\tstruct mei_msg_hdr *mei_hdr;\n\tstruct mei_ext_meta_hdr *meta_hdr = NULL;\n\tstruct mei_cl *cl;\n\tint ret;\n\tu32 hdr_size_left;\n\tu32 hdr_size_ext;\n\tint i;\n\tint ext_hdr_end;\n\n\tif (!dev->rd_msg_hdr[0]) {\n\t\tdev->rd_msg_hdr[0] = mei_read_hdr(dev);\n\t\tdev->rd_msg_hdr_count = 1;\n\t\t(*slots)--;\n\t\tdev_dbg(dev->dev, \"slots =%08x.\\n\", *slots);\n\n\t\tret = hdr_is_valid(dev->rd_msg_hdr[0]);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev, \"corrupted message header 0x%08X\\n\",\n\t\t\t\tdev->rd_msg_hdr[0]);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tmei_hdr = (struct mei_msg_hdr *)dev->rd_msg_hdr;\n\tdev_dbg(dev->dev, MEI_HDR_FMT, MEI_HDR_PRM(mei_hdr));\n\n\tif (mei_slots2data(*slots) < mei_hdr->length) {\n\t\tdev_err(dev->dev, \"less data available than length=%08x.\\n\",\n\t\t\t\t*slots);\n\t\t \n\t\tret = -ENODATA;\n\t\tgoto end;\n\t}\n\n\text_hdr_end = 1;\n\thdr_size_left = mei_hdr->length;\n\n\tif (mei_hdr->extended) {\n\t\tif (!dev->rd_msg_hdr[1]) {\n\t\t\tdev->rd_msg_hdr[1] = mei_read_hdr(dev);\n\t\t\tdev->rd_msg_hdr_count++;\n\t\t\t(*slots)--;\n\t\t\tdev_dbg(dev->dev, \"extended header is %08x\\n\", dev->rd_msg_hdr[1]);\n\t\t}\n\t\tmeta_hdr = ((struct mei_ext_meta_hdr *)&dev->rd_msg_hdr[1]);\n\t\tif (check_add_overflow((u32)sizeof(*meta_hdr),\n\t\t\t\t       mei_slots2data(meta_hdr->size),\n\t\t\t\t       &hdr_size_ext)) {\n\t\t\tdev_err(dev->dev, \"extended message size too big %d\\n\",\n\t\t\t\tmeta_hdr->size);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tif (hdr_size_left < hdr_size_ext) {\n\t\t\tdev_err(dev->dev, \"corrupted message header len %d\\n\",\n\t\t\t\tmei_hdr->length);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\thdr_size_left -= hdr_size_ext;\n\n\t\text_hdr_end = meta_hdr->size + 2;\n\t\tfor (i = dev->rd_msg_hdr_count; i < ext_hdr_end; i++) {\n\t\t\tdev->rd_msg_hdr[i] = mei_read_hdr(dev);\n\t\t\tdev_dbg(dev->dev, \"extended header %d is %08x\\n\", i,\n\t\t\t\tdev->rd_msg_hdr[i]);\n\t\t\tdev->rd_msg_hdr_count++;\n\t\t\t(*slots)--;\n\t\t}\n\t}\n\n\tif (mei_hdr->dma_ring) {\n\t\tif (hdr_size_left != sizeof(dev->rd_msg_hdr[ext_hdr_end])) {\n\t\t\tdev_err(dev->dev, \"corrupted message header len %d\\n\",\n\t\t\t\tmei_hdr->length);\n\t\t\treturn -EBADMSG;\n\t\t}\n\n\t\tdev->rd_msg_hdr[ext_hdr_end] = mei_read_hdr(dev);\n\t\tdev->rd_msg_hdr_count++;\n\t\t(*slots)--;\n\t\tmei_hdr->length -= sizeof(dev->rd_msg_hdr[ext_hdr_end]);\n\t}\n\n\t \n\tif (hdr_is_hbm(mei_hdr)) {\n\t\tret = mei_hbm_dispatch(dev, mei_hdr);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev->dev, \"mei_hbm_dispatch failed ret = %d\\n\",\n\t\t\t\t\tret);\n\t\t\tgoto end;\n\t\t}\n\t\tgoto reset_slots;\n\t}\n\n\t \n\tlist_for_each_entry(cl, &dev->file_list, link) {\n\t\tif (mei_cl_hbm_equal(cl, mei_hdr)) {\n\t\t\tcl_dbg(dev, cl, \"got a message\\n\");\n\t\t\tret = mei_cl_irq_read_msg(cl, mei_hdr, meta_hdr, cmpl_list);\n\t\t\tgoto reset_slots;\n\t\t}\n\t}\n\n\t \n\t \n\tif (hdr_is_fixed(mei_hdr) ||\n\t    dev->dev_state == MEI_DEV_POWER_DOWN) {\n\t\tmei_irq_discard_msg(dev, mei_hdr, mei_hdr->length);\n\t\tret = 0;\n\t\tgoto reset_slots;\n\t}\n\tdev_err(dev->dev, \"no destination client found 0x%08X\\n\", dev->rd_msg_hdr[0]);\n\tret = -EBADMSG;\n\tgoto end;\n\nreset_slots:\n\t \n\tmemset(dev->rd_msg_hdr, 0, sizeof(dev->rd_msg_hdr));\n\tdev->rd_msg_hdr_count = 0;\n\t*slots = mei_count_full_read_slots(dev);\n\tif (*slots == -EOVERFLOW) {\n\t\t \n\t\tdev_err(dev->dev, \"resetting due to slots overflow.\\n\");\n\t\t \n\t\tret = -ERANGE;\n\t\tgoto end;\n\t}\nend:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mei_irq_read_handler);\n\n\n \nint mei_irq_write_handler(struct mei_device *dev, struct list_head *cmpl_list)\n{\n\n\tstruct mei_cl *cl;\n\tstruct mei_cl_cb *cb, *next;\n\ts32 slots;\n\tint ret;\n\n\n\tif (!mei_hbuf_acquire(dev))\n\t\treturn 0;\n\n\tslots = mei_hbuf_empty_slots(dev);\n\tif (slots < 0)\n\t\treturn -EOVERFLOW;\n\n\tif (slots == 0)\n\t\treturn -EMSGSIZE;\n\n\t \n\tdev_dbg(dev->dev, \"complete all waiting for write cb.\\n\");\n\n\tlist_for_each_entry_safe(cb, next, &dev->write_waiting_list, list) {\n\t\tcl = cb->cl;\n\n\t\tcl->status = 0;\n\t\tcl_dbg(dev, cl, \"MEI WRITE COMPLETE\\n\");\n\t\tcl->writing_state = MEI_WRITE_COMPLETE;\n\t\tlist_move_tail(&cb->list, cmpl_list);\n\t}\n\n\t \n\tdev_dbg(dev->dev, \"complete control write list cb.\\n\");\n\tlist_for_each_entry_safe(cb, next, &dev->ctrl_wr_list, list) {\n\t\tcl = cb->cl;\n\t\tswitch (cb->fop_type) {\n\t\tcase MEI_FOP_DISCONNECT:\n\t\t\t \n\t\t\tret = mei_cl_irq_disconnect(cl, cb, cmpl_list);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\t\tcase MEI_FOP_READ:\n\t\t\t \n\t\t\tret = mei_cl_irq_read(cl, cb, cmpl_list);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\t\tcase MEI_FOP_CONNECT:\n\t\t\t \n\t\t\tret = mei_cl_irq_connect(cl, cb, cmpl_list);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\t\tcase MEI_FOP_DISCONNECT_RSP:\n\t\t\t \n\t\t\tret = mei_cl_irq_disconnect_rsp(cl, cb, cmpl_list);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tcase MEI_FOP_NOTIFY_START:\n\t\tcase MEI_FOP_NOTIFY_STOP:\n\t\t\tret = mei_cl_irq_notify(cl, cb, cmpl_list);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase MEI_FOP_DMA_MAP:\n\t\t\tret = mei_cl_irq_dma_map(cl, cb, cmpl_list);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase MEI_FOP_DMA_UNMAP:\n\t\t\tret = mei_cl_irq_dma_unmap(cl, cb, cmpl_list);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t}\n\t \n\tdev_dbg(dev->dev, \"complete write list cb.\\n\");\n\tlist_for_each_entry_safe(cb, next, &dev->write_list, list) {\n\t\tcl = cb->cl;\n\t\tret = mei_cl_irq_write(cl, cb, cmpl_list);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mei_irq_write_handler);\n\n\n \nstatic void mei_connect_timeout(struct mei_cl *cl)\n{\n\tstruct mei_device *dev = cl->dev;\n\n\tif (cl->state == MEI_FILE_CONNECTING) {\n\t\tif (dev->hbm_f_dot_supported) {\n\t\t\tcl->state = MEI_FILE_DISCONNECT_REQUIRED;\n\t\t\twake_up(&cl->wait);\n\t\t\treturn;\n\t\t}\n\t}\n\tmei_reset(dev);\n}\n\n#define MEI_STALL_TIMER_FREQ (2 * HZ)\n \nvoid mei_schedule_stall_timer(struct mei_device *dev)\n{\n\tschedule_delayed_work(&dev->timer_work, MEI_STALL_TIMER_FREQ);\n}\n\n \nvoid mei_timer(struct work_struct *work)\n{\n\tstruct mei_cl *cl;\n\tstruct mei_device *dev = container_of(work,\n\t\t\t\t\tstruct mei_device, timer_work.work);\n\tbool reschedule_timer = false;\n\n\tmutex_lock(&dev->device_lock);\n\n\t \n\tif (dev->dev_state == MEI_DEV_INIT_CLIENTS &&\n\t    dev->hbm_state != MEI_HBM_IDLE) {\n\n\t\tif (dev->init_clients_timer) {\n\t\t\tif (--dev->init_clients_timer == 0) {\n\t\t\t\tdev_err(dev->dev, \"timer: init clients timeout hbm_state = %d.\\n\",\n\t\t\t\t\tdev->hbm_state);\n\t\t\t\tmei_reset(dev);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\treschedule_timer = true;\n\t\t}\n\t}\n\n\tif (dev->dev_state != MEI_DEV_ENABLED)\n\t\tgoto out;\n\n\t \n\tlist_for_each_entry(cl, &dev->file_list, link) {\n\t\tif (cl->timer_count) {\n\t\t\tif (--cl->timer_count == 0) {\n\t\t\t\tdev_err(dev->dev, \"timer: connect/disconnect timeout.\\n\");\n\t\t\t\tmei_connect_timeout(cl);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\treschedule_timer = true;\n\t\t}\n\t}\n\nout:\n\tif (dev->dev_state != MEI_DEV_DISABLED && reschedule_timer)\n\t\tmei_schedule_stall_timer(dev);\n\n\tmutex_unlock(&dev->device_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}