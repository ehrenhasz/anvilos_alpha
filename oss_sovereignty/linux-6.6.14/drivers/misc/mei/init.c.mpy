{
  "module_name": "init.c",
  "hash_id": "582f8c5f09813756c99df1a720fb69eef75c61d478da9b902d287e45a94430a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/init.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n\n#include <linux/mei.h>\n\n#include \"mei_dev.h\"\n#include \"hbm.h\"\n#include \"client.h\"\n\nconst char *mei_dev_state_str(int state)\n{\n#define MEI_DEV_STATE(state) case MEI_DEV_##state: return #state\n\tswitch (state) {\n\tMEI_DEV_STATE(INITIALIZING);\n\tMEI_DEV_STATE(INIT_CLIENTS);\n\tMEI_DEV_STATE(ENABLED);\n\tMEI_DEV_STATE(RESETTING);\n\tMEI_DEV_STATE(DISABLED);\n\tMEI_DEV_STATE(POWERING_DOWN);\n\tMEI_DEV_STATE(POWER_DOWN);\n\tMEI_DEV_STATE(POWER_UP);\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n#undef MEI_DEV_STATE\n}\n\nconst char *mei_pg_state_str(enum mei_pg_state state)\n{\n#define MEI_PG_STATE(state) case MEI_PG_##state: return #state\n\tswitch (state) {\n\tMEI_PG_STATE(OFF);\n\tMEI_PG_STATE(ON);\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n#undef MEI_PG_STATE\n}\n\n \nssize_t mei_fw_status2str(struct mei_fw_status *fw_status,\n\t\t\t  char *buf, size_t len)\n{\n\tssize_t cnt = 0;\n\tint i;\n\n\tbuf[0] = '\\0';\n\n\tif (len < MEI_FW_STATUS_STR_SZ)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < fw_status->count; i++)\n\t\tcnt += scnprintf(buf + cnt, len - cnt, \"%08X \",\n\t\t\t\tfw_status->status[i]);\n\n\t \n\tbuf[cnt] = '\\0';\n\treturn cnt;\n}\nEXPORT_SYMBOL_GPL(mei_fw_status2str);\n\n \nvoid mei_cancel_work(struct mei_device *dev)\n{\n\tcancel_work_sync(&dev->reset_work);\n\tcancel_work_sync(&dev->bus_rescan_work);\n\n\tcancel_delayed_work_sync(&dev->timer_work);\n}\nEXPORT_SYMBOL_GPL(mei_cancel_work);\n\n \nint mei_reset(struct mei_device *dev)\n{\n\tenum mei_dev_state state = dev->dev_state;\n\tbool interrupts_enabled;\n\tint ret;\n\n\tif (state != MEI_DEV_INITIALIZING &&\n\t    state != MEI_DEV_DISABLED &&\n\t    state != MEI_DEV_POWER_DOWN &&\n\t    state != MEI_DEV_POWER_UP) {\n\t\tchar fw_sts_str[MEI_FW_STATUS_STR_SZ];\n\n\t\tmei_fw_status_str(dev, fw_sts_str, MEI_FW_STATUS_STR_SZ);\n\t\tdev_warn(dev->dev, \"unexpected reset: dev_state = %s fw status = %s\\n\",\n\t\t\t mei_dev_state_str(state), fw_sts_str);\n\t}\n\n\tmei_clear_interrupts(dev);\n\n\t \n\tmei_hbm_idle(dev);\n\n\t \n\tinterrupts_enabled = state != MEI_DEV_POWER_DOWN;\n\tmei_set_devstate(dev, MEI_DEV_RESETTING);\n\n\tdev->reset_count++;\n\tif (dev->reset_count > MEI_MAX_CONSEC_RESET) {\n\t\tdev_err(dev->dev, \"reset: reached maximal consecutive resets: disabling the device\\n\");\n\t\tmei_set_devstate(dev, MEI_DEV_DISABLED);\n\t\treturn -ENODEV;\n\t}\n\n\tret = mei_hw_reset(dev, interrupts_enabled);\n\t \n\n\t \n\tif (state != MEI_DEV_INITIALIZING && state != MEI_DEV_POWER_UP)\n\t\tmei_cl_all_disconnect(dev);\n\n\tmei_hbm_reset(dev);\n\n\t \n\tdev->fw_ver_received = 0;\n\n\tmemset(dev->rd_msg_hdr, 0, sizeof(dev->rd_msg_hdr));\n\n\tif (ret) {\n\t\tdev_err(dev->dev, \"hw_reset failed ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (state == MEI_DEV_POWER_DOWN) {\n\t\tdev_dbg(dev->dev, \"powering down: end of reset\\n\");\n\t\tmei_set_devstate(dev, MEI_DEV_DISABLED);\n\t\treturn 0;\n\t}\n\n\tret = mei_hw_start(dev);\n\tif (ret) {\n\t\tchar fw_sts_str[MEI_FW_STATUS_STR_SZ];\n\n\t\tmei_fw_status_str(dev, fw_sts_str, MEI_FW_STATUS_STR_SZ);\n\t\tdev_err(dev->dev, \"hw_start failed ret = %d fw status = %s\\n\", ret, fw_sts_str);\n\t\treturn ret;\n\t}\n\n\tif (dev->dev_state != MEI_DEV_RESETTING) {\n\t\tdev_dbg(dev->dev, \"wrong state = %d on link start\\n\", dev->dev_state);\n\t\treturn 0;\n\t}\n\n\tdev_dbg(dev->dev, \"link is established start sending messages.\\n\");\n\n\tmei_set_devstate(dev, MEI_DEV_INIT_CLIENTS);\n\tret = mei_hbm_start_req(dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"hbm_start failed ret = %d\\n\", ret);\n\t\tmei_set_devstate(dev, MEI_DEV_RESETTING);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mei_reset);\n\n \nint mei_start(struct mei_device *dev)\n{\n\tint ret;\n\n\tmutex_lock(&dev->device_lock);\n\n\t \n\tmei_clear_interrupts(dev);\n\n\tret = mei_hw_config(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(dev->dev, \"reset in start the mei device.\\n\");\n\n\tdev->reset_count = 0;\n\tdo {\n\t\tmei_set_devstate(dev, MEI_DEV_INITIALIZING);\n\t\tret = mei_reset(dev);\n\n\t\tif (ret == -ENODEV || dev->dev_state == MEI_DEV_DISABLED) {\n\t\t\tdev_err(dev->dev, \"reset failed ret = %d\", ret);\n\t\t\tgoto err;\n\t\t}\n\t} while (ret);\n\n\tif (mei_hbm_start_wait(dev)) {\n\t\tdev_err(dev->dev, \"HBM haven't started\");\n\t\tgoto err;\n\t}\n\n\tif (!mei_hbm_version_is_supported(dev)) {\n\t\tdev_dbg(dev->dev, \"MEI start failed.\\n\");\n\t\tgoto err;\n\t}\n\n\tdev_dbg(dev->dev, \"link layer has been established.\\n\");\n\n\tmutex_unlock(&dev->device_lock);\n\treturn 0;\nerr:\n\tdev_err(dev->dev, \"link layer initialization failed.\\n\");\n\tmei_set_devstate(dev, MEI_DEV_DISABLED);\n\tmutex_unlock(&dev->device_lock);\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(mei_start);\n\n \nint mei_restart(struct mei_device *dev)\n{\n\tint err;\n\n\tmutex_lock(&dev->device_lock);\n\n\tmei_set_devstate(dev, MEI_DEV_POWER_UP);\n\tdev->reset_count = 0;\n\n\terr = mei_reset(dev);\n\n\tmutex_unlock(&dev->device_lock);\n\n\tif (err == -ENODEV || dev->dev_state == MEI_DEV_DISABLED) {\n\t\tdev_err(dev->dev, \"device disabled = %d\\n\", err);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (err)\n\t\tschedule_work(&dev->reset_work);\n\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mei_restart);\n\nstatic void mei_reset_work(struct work_struct *work)\n{\n\tstruct mei_device *dev =\n\t\tcontainer_of(work, struct mei_device,  reset_work);\n\tint ret;\n\n\tmei_clear_interrupts(dev);\n\tmei_synchronize_irq(dev);\n\n\tmutex_lock(&dev->device_lock);\n\n\tret = mei_reset(dev);\n\n\tmutex_unlock(&dev->device_lock);\n\n\tif (dev->dev_state == MEI_DEV_DISABLED) {\n\t\tdev_err(dev->dev, \"device disabled = %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tif (ret)\n\t\tschedule_work(&dev->reset_work);\n}\n\nvoid mei_stop(struct mei_device *dev)\n{\n\tdev_dbg(dev->dev, \"stopping the device.\\n\");\n\n\tmutex_lock(&dev->device_lock);\n\tmei_set_devstate(dev, MEI_DEV_POWERING_DOWN);\n\tmutex_unlock(&dev->device_lock);\n\tmei_cl_bus_remove_devices(dev);\n\tmutex_lock(&dev->device_lock);\n\tmei_set_devstate(dev, MEI_DEV_POWER_DOWN);\n\tmutex_unlock(&dev->device_lock);\n\n\tmei_cancel_work(dev);\n\n\tmei_clear_interrupts(dev);\n\tmei_synchronize_irq(dev);\n\t \n\tmei_cancel_work(dev);\n\n\tmutex_lock(&dev->device_lock);\n\n\tmei_reset(dev);\n\t \n\tmei_set_devstate(dev, MEI_DEV_DISABLED);\n\n\tmutex_unlock(&dev->device_lock);\n}\nEXPORT_SYMBOL_GPL(mei_stop);\n\n \nbool mei_write_is_idle(struct mei_device *dev)\n{\n\tbool idle = (dev->dev_state == MEI_DEV_ENABLED &&\n\t\tlist_empty(&dev->ctrl_wr_list) &&\n\t\tlist_empty(&dev->write_list)   &&\n\t\tlist_empty(&dev->write_waiting_list));\n\n\tdev_dbg(dev->dev, \"write pg: is idle[%d] state=%s ctrl=%01d write=%01d wwait=%01d\\n\",\n\t\tidle,\n\t\tmei_dev_state_str(dev->dev_state),\n\t\tlist_empty(&dev->ctrl_wr_list),\n\t\tlist_empty(&dev->write_list),\n\t\tlist_empty(&dev->write_waiting_list));\n\n\treturn idle;\n}\nEXPORT_SYMBOL_GPL(mei_write_is_idle);\n\n \nvoid mei_device_init(struct mei_device *dev,\n\t\t     struct device *device,\n\t\t     bool slow_fw,\n\t\t     const struct mei_hw_ops *hw_ops)\n{\n\t \n\tINIT_LIST_HEAD(&dev->file_list);\n\tINIT_LIST_HEAD(&dev->device_list);\n\tINIT_LIST_HEAD(&dev->me_clients);\n\tmutex_init(&dev->device_lock);\n\tinit_rwsem(&dev->me_clients_rwsem);\n\tmutex_init(&dev->cl_bus_lock);\n\tinit_waitqueue_head(&dev->wait_hw_ready);\n\tinit_waitqueue_head(&dev->wait_pg);\n\tinit_waitqueue_head(&dev->wait_hbm_start);\n\tdev->dev_state = MEI_DEV_INITIALIZING;\n\tdev->reset_count = 0;\n\n\tINIT_LIST_HEAD(&dev->write_list);\n\tINIT_LIST_HEAD(&dev->write_waiting_list);\n\tINIT_LIST_HEAD(&dev->ctrl_wr_list);\n\tINIT_LIST_HEAD(&dev->ctrl_rd_list);\n\tdev->tx_queue_limit = MEI_TX_QUEUE_LIMIT_DEFAULT;\n\n\tINIT_DELAYED_WORK(&dev->timer_work, mei_timer);\n\tINIT_WORK(&dev->reset_work, mei_reset_work);\n\tINIT_WORK(&dev->bus_rescan_work, mei_cl_bus_rescan_work);\n\n\tbitmap_zero(dev->host_clients_map, MEI_CLIENTS_MAX);\n\tdev->open_handle_count = 0;\n\n\tdev->pxp_mode = MEI_DEV_PXP_DEFAULT;\n\n\t \n\tbitmap_set(dev->host_clients_map, 0, 1);\n\n\tdev->pg_event = MEI_PG_EVENT_IDLE;\n\tdev->ops      = hw_ops;\n\tdev->dev      = device;\n\n\tdev->timeouts.hw_ready = mei_secs_to_jiffies(MEI_HW_READY_TIMEOUT);\n\tdev->timeouts.connect = MEI_CONNECT_TIMEOUT;\n\tdev->timeouts.client_init = MEI_CLIENTS_INIT_TIMEOUT;\n\tdev->timeouts.pgi = mei_secs_to_jiffies(MEI_PGI_TIMEOUT);\n\tdev->timeouts.d0i3 = mei_secs_to_jiffies(MEI_D0I3_TIMEOUT);\n\tif (slow_fw) {\n\t\tdev->timeouts.cl_connect = mei_secs_to_jiffies(MEI_CL_CONNECT_TIMEOUT_SLOW);\n\t\tdev->timeouts.hbm = mei_secs_to_jiffies(MEI_HBM_TIMEOUT_SLOW);\n\t\tdev->timeouts.mkhi_recv = msecs_to_jiffies(MKHI_RCV_TIMEOUT_SLOW);\n\t} else {\n\t\tdev->timeouts.cl_connect = mei_secs_to_jiffies(MEI_CL_CONNECT_TIMEOUT);\n\t\tdev->timeouts.hbm = mei_secs_to_jiffies(MEI_HBM_TIMEOUT);\n\t\tdev->timeouts.mkhi_recv = msecs_to_jiffies(MKHI_RCV_TIMEOUT);\n\t}\n}\nEXPORT_SYMBOL_GPL(mei_device_init);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}