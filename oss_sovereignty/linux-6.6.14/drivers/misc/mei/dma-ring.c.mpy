{
  "module_name": "dma-ring.c",
  "hash_id": "04ce1723d924e3f1c57d92831eae11b69fcd6584ede334ca280a29465c287cdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/dma-ring.c",
  "human_readable_source": "\n \n#include <linux/dma-mapping.h>\n#include <linux/mei.h>\n\n#include \"mei_dev.h\"\n\n \nstatic int mei_dmam_dscr_alloc(struct mei_device *dev,\n\t\t\t       struct mei_dma_dscr *dscr)\n{\n\tif (!dscr->size)\n\t\treturn 0;\n\n\tif (WARN_ON(!is_power_of_2(dscr->size)))\n\t\treturn -EINVAL;\n\n\tif (dscr->vaddr)\n\t\treturn 0;\n\n\tdscr->vaddr = dmam_alloc_coherent(dev->dev, dscr->size, &dscr->daddr,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!dscr->vaddr)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic void mei_dmam_dscr_free(struct mei_device *dev,\n\t\t\t       struct mei_dma_dscr *dscr)\n{\n\tif (!dscr->vaddr)\n\t\treturn;\n\n\tdmam_free_coherent(dev->dev, dscr->size, dscr->vaddr, dscr->daddr);\n\tdscr->vaddr = NULL;\n}\n\n \nvoid mei_dmam_ring_free(struct mei_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < DMA_DSCR_NUM; i++)\n\t\tmei_dmam_dscr_free(dev, &dev->dr_dscr[i]);\n}\n\n \nint mei_dmam_ring_alloc(struct mei_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < DMA_DSCR_NUM; i++)\n\t\tif (mei_dmam_dscr_alloc(dev, &dev->dr_dscr[i]))\n\t\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tmei_dmam_ring_free(dev);\n\treturn -ENOMEM;\n}\n\n \nbool mei_dma_ring_is_allocated(struct mei_device *dev)\n{\n\treturn !!dev->dr_dscr[DMA_DSCR_HOST].vaddr;\n}\n\nstatic inline\nstruct hbm_dma_ring_ctrl *mei_dma_ring_ctrl(struct mei_device *dev)\n{\n\treturn (struct hbm_dma_ring_ctrl *)dev->dr_dscr[DMA_DSCR_CTRL].vaddr;\n}\n\n \nvoid mei_dma_ring_reset(struct mei_device *dev)\n{\n\tstruct hbm_dma_ring_ctrl *ctrl = mei_dma_ring_ctrl(dev);\n\n\tif (!ctrl)\n\t\treturn;\n\n\tmemset(ctrl, 0, sizeof(*ctrl));\n}\n\n \nstatic size_t mei_dma_copy_from(struct mei_device *dev, unsigned char *buf,\n\t\t\t\tu32 offset, u32 n)\n{\n\tunsigned char *dbuf = dev->dr_dscr[DMA_DSCR_DEVICE].vaddr;\n\n\tsize_t b_offset = offset << 2;\n\tsize_t b_n = n << 2;\n\n\tmemcpy(buf, dbuf + b_offset, b_n);\n\n\treturn b_n;\n}\n\n \nstatic size_t mei_dma_copy_to(struct mei_device *dev, unsigned char *buf,\n\t\t\t      u32 offset, u32 n)\n{\n\tunsigned char *hbuf = dev->dr_dscr[DMA_DSCR_HOST].vaddr;\n\n\tsize_t b_offset = offset << 2;\n\tsize_t b_n = n << 2;\n\n\tmemcpy(hbuf + b_offset, buf, b_n);\n\n\treturn b_n;\n}\n\n \nvoid mei_dma_ring_read(struct mei_device *dev, unsigned char *buf, u32 len)\n{\n\tstruct hbm_dma_ring_ctrl *ctrl = mei_dma_ring_ctrl(dev);\n\tu32 dbuf_depth;\n\tu32 rd_idx, rem, slots;\n\n\tif (WARN_ON(!ctrl))\n\t\treturn;\n\n\tdev_dbg(dev->dev, \"reading from dma %u bytes\\n\", len);\n\n\tif (!len)\n\t\treturn;\n\n\tdbuf_depth = dev->dr_dscr[DMA_DSCR_DEVICE].size >> 2;\n\trd_idx = READ_ONCE(ctrl->dbuf_rd_idx) & (dbuf_depth - 1);\n\tslots = mei_data2slots(len);\n\n\t \n\tif (!buf)\n\t\tgoto out;\n\n\tif (rd_idx + slots > dbuf_depth) {\n\t\tbuf += mei_dma_copy_from(dev, buf, rd_idx, dbuf_depth - rd_idx);\n\t\trem = slots - (dbuf_depth - rd_idx);\n\t\trd_idx = 0;\n\t} else {\n\t\trem = slots;\n\t}\n\n\tmei_dma_copy_from(dev, buf, rd_idx, rem);\nout:\n\tWRITE_ONCE(ctrl->dbuf_rd_idx, ctrl->dbuf_rd_idx + slots);\n}\n\nstatic inline u32 mei_dma_ring_hbuf_depth(struct mei_device *dev)\n{\n\treturn dev->dr_dscr[DMA_DSCR_HOST].size >> 2;\n}\n\n \nu32 mei_dma_ring_empty_slots(struct mei_device *dev)\n{\n\tstruct hbm_dma_ring_ctrl *ctrl = mei_dma_ring_ctrl(dev);\n\tu32 wr_idx, rd_idx, hbuf_depth, empty;\n\n\tif (!mei_dma_ring_is_allocated(dev))\n\t\treturn 0;\n\n\tif (WARN_ON(!ctrl))\n\t\treturn 0;\n\n\t \n\thbuf_depth = mei_dma_ring_hbuf_depth(dev);\n\trd_idx = READ_ONCE(ctrl->hbuf_rd_idx);\n\twr_idx = READ_ONCE(ctrl->hbuf_wr_idx);\n\n\tif (rd_idx > wr_idx)\n\t\tempty = rd_idx - wr_idx;\n\telse\n\t\tempty = hbuf_depth - (wr_idx - rd_idx);\n\n\treturn empty;\n}\n\n \nvoid mei_dma_ring_write(struct mei_device *dev, unsigned char *buf, u32 len)\n{\n\tstruct hbm_dma_ring_ctrl *ctrl = mei_dma_ring_ctrl(dev);\n\tu32 hbuf_depth;\n\tu32 wr_idx, rem, slots;\n\n\tif (WARN_ON(!ctrl))\n\t\treturn;\n\n\tdev_dbg(dev->dev, \"writing to dma %u bytes\\n\", len);\n\thbuf_depth = mei_dma_ring_hbuf_depth(dev);\n\twr_idx = READ_ONCE(ctrl->hbuf_wr_idx) & (hbuf_depth - 1);\n\tslots = mei_data2slots(len);\n\n\tif (wr_idx + slots > hbuf_depth) {\n\t\tbuf += mei_dma_copy_to(dev, buf, wr_idx, hbuf_depth - wr_idx);\n\t\trem = slots - (hbuf_depth - wr_idx);\n\t\twr_idx = 0;\n\t} else {\n\t\trem = slots;\n\t}\n\n\tmei_dma_copy_to(dev, buf, wr_idx, rem);\n\n\tWRITE_ONCE(ctrl->hbuf_wr_idx, ctrl->hbuf_wr_idx + slots);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}