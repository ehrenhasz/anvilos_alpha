{
  "module_name": "bus.c",
  "hash_id": "1871fbaf66ed97cb1a8d6233ff161f5107d6883e1cef4973e86490d2619fbbe1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/bus.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/interrupt.h>\n#include <linux/scatterlist.h>\n#include <linux/mei_cl_bus.h>\n\n#include \"mei_dev.h\"\n#include \"client.h\"\n\n#define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)\n\n \nssize_t __mei_cl_send(struct mei_cl *cl, const u8 *buf, size_t length, u8 vtag,\n\t\t      unsigned int mode)\n{\n\treturn __mei_cl_send_timeout(cl, buf, length, vtag, mode, MAX_SCHEDULE_TIMEOUT);\n}\n\n \nssize_t __mei_cl_send_timeout(struct mei_cl *cl, const u8 *buf, size_t length, u8 vtag,\n\t\t\t      unsigned int mode, unsigned long timeout)\n{\n\tstruct mei_device *bus;\n\tstruct mei_cl_cb *cb;\n\tssize_t rets;\n\n\tif (WARN_ON(!cl || !cl->dev))\n\t\treturn -ENODEV;\n\n\tbus = cl->dev;\n\n\tmutex_lock(&bus->device_lock);\n\tif (bus->dev_state != MEI_DEV_ENABLED &&\n\t    bus->dev_state != MEI_DEV_POWERING_DOWN) {\n\t\trets = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!mei_cl_is_connected(cl)) {\n\t\trets = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!mei_me_cl_is_active(cl->me_cl)) {\n\t\trets = -ENOTTY;\n\t\tgoto out;\n\t}\n\n\tif (vtag) {\n\t\t \n\t\trets = mei_cl_vt_support_check(cl);\n\t\tif (rets)\n\t\t\tgoto out;\n\t}\n\n\tif (length > mei_cl_mtu(cl)) {\n\t\trets = -EFBIG;\n\t\tgoto out;\n\t}\n\n\twhile (cl->tx_cb_queued >= bus->tx_queue_limit) {\n\t\tmutex_unlock(&bus->device_lock);\n\t\trets = wait_event_interruptible(cl->tx_wait,\n\t\t\t\tcl->writing_state == MEI_WRITE_COMPLETE ||\n\t\t\t\t(!mei_cl_is_connected(cl)));\n\t\tmutex_lock(&bus->device_lock);\n\t\tif (rets) {\n\t\t\tif (signal_pending(current))\n\t\t\t\trets = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!mei_cl_is_connected(cl)) {\n\t\t\trets = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);\n\tif (!cb) {\n\t\trets = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcb->vtag = vtag;\n\n\tcb->internal = !!(mode & MEI_CL_IO_TX_INTERNAL);\n\tcb->blocking = !!(mode & MEI_CL_IO_TX_BLOCKING);\n\tmemcpy(cb->buf.data, buf, length);\n\t \n\tif (mode & MEI_CL_IO_SGL) {\n\t\tcb->ext_hdr = (struct mei_ext_hdr *)cb->buf.data;\n\t\tcb->buf.data = NULL;\n\t\tcb->buf.size = 0;\n\t}\n\n\trets = mei_cl_write(cl, cb, timeout);\n\n\tif (mode & MEI_CL_IO_SGL && rets == 0)\n\t\trets = length;\n\nout:\n\tmutex_unlock(&bus->device_lock);\n\n\treturn rets;\n}\n\n \nssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length, u8 *vtag,\n\t\t      unsigned int mode, unsigned long timeout)\n{\n\tstruct mei_device *bus;\n\tstruct mei_cl_cb *cb;\n\tsize_t r_length;\n\tssize_t rets;\n\tbool nonblock = !!(mode & MEI_CL_IO_RX_NONBLOCK);\n\n\tif (WARN_ON(!cl || !cl->dev))\n\t\treturn -ENODEV;\n\n\tbus = cl->dev;\n\n\tmutex_lock(&bus->device_lock);\n\tif (bus->dev_state != MEI_DEV_ENABLED &&\n\t    bus->dev_state != MEI_DEV_POWERING_DOWN) {\n\t\trets = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tcb = mei_cl_read_cb(cl, NULL);\n\tif (cb)\n\t\tgoto copy;\n\n\trets = mei_cl_read_start(cl, length, NULL);\n\tif (rets && rets != -EBUSY)\n\t\tgoto out;\n\n\tif (nonblock) {\n\t\trets = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t \n\t \n\tif (!waitqueue_active(&cl->rx_wait)) {\n\n\t\tmutex_unlock(&bus->device_lock);\n\n\t\tif (timeout) {\n\t\t\trets = wait_event_interruptible_timeout\n\t\t\t\t\t(cl->rx_wait,\n\t\t\t\t\tmei_cl_read_cb(cl, NULL) ||\n\t\t\t\t\t(!mei_cl_is_connected(cl)),\n\t\t\t\t\tmsecs_to_jiffies(timeout));\n\t\t\tif (rets == 0)\n\t\t\t\treturn -ETIME;\n\t\t\tif (rets < 0) {\n\t\t\t\tif (signal_pending(current))\n\t\t\t\t\treturn -EINTR;\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\t}\n\t\t} else {\n\t\t\tif (wait_event_interruptible\n\t\t\t\t\t(cl->rx_wait,\n\t\t\t\t\tmei_cl_read_cb(cl, NULL) ||\n\t\t\t\t\t(!mei_cl_is_connected(cl)))) {\n\t\t\t\tif (signal_pending(current))\n\t\t\t\t\treturn -EINTR;\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\t}\n\t\t}\n\n\t\tmutex_lock(&bus->device_lock);\n\n\t\tif (!mei_cl_is_connected(cl)) {\n\t\t\trets = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcb = mei_cl_read_cb(cl, NULL);\n\tif (!cb) {\n\t\trets = 0;\n\t\tgoto out;\n\t}\n\ncopy:\n\tif (cb->status) {\n\t\trets = cb->status;\n\t\tgoto free;\n\t}\n\n\t \n\tif (cb->ext_hdr && cb->ext_hdr->type == MEI_EXT_HDR_GSC) {\n\t\tr_length = min_t(size_t, length, cb->ext_hdr->length * sizeof(u32));\n\t\tmemcpy(buf, cb->ext_hdr, r_length);\n\t} else {\n\t\tr_length = min_t(size_t, length, cb->buf_idx);\n\t\tmemcpy(buf, cb->buf.data, r_length);\n\t}\n\trets = r_length;\n\n\tif (vtag)\n\t\t*vtag = cb->vtag;\n\nfree:\n\tmei_cl_del_rd_completed(cl, cb);\nout:\n\tmutex_unlock(&bus->device_lock);\n\n\treturn rets;\n}\n\n \n\nssize_t mei_cldev_send_vtag(struct mei_cl_device *cldev, const u8 *buf,\n\t\t\t    size_t length, u8 vtag)\n{\n\tstruct mei_cl *cl = cldev->cl;\n\n\treturn __mei_cl_send(cl, buf, length, vtag, MEI_CL_IO_TX_BLOCKING);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_send_vtag);\n\n \n\nssize_t mei_cldev_recv_vtag(struct mei_cl_device *cldev, u8 *buf, size_t length,\n\t\t\t    u8 *vtag)\n{\n\tstruct mei_cl *cl = cldev->cl;\n\n\treturn __mei_cl_recv(cl, buf, length, vtag, 0, 0);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_recv_vtag);\n\n \nssize_t mei_cldev_recv_nonblock_vtag(struct mei_cl_device *cldev, u8 *buf,\n\t\t\t\t     size_t length, u8 *vtag)\n{\n\tstruct mei_cl *cl = cldev->cl;\n\n\treturn __mei_cl_recv(cl, buf, length, vtag, MEI_CL_IO_RX_NONBLOCK, 0);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_recv_nonblock_vtag);\n\n \nssize_t mei_cldev_send(struct mei_cl_device *cldev, const u8 *buf, size_t length)\n{\n\treturn mei_cldev_send_vtag(cldev, buf, length, 0);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_send);\n\n \nssize_t mei_cldev_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)\n{\n\treturn mei_cldev_recv_vtag(cldev, buf, length, NULL);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_recv);\n\n \nssize_t mei_cldev_recv_nonblock(struct mei_cl_device *cldev, u8 *buf,\n\t\t\t\tsize_t length)\n{\n\treturn mei_cldev_recv_nonblock_vtag(cldev, buf, length, NULL);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_recv_nonblock);\n\n \nstatic void mei_cl_bus_rx_work(struct work_struct *work)\n{\n\tstruct mei_cl_device *cldev;\n\tstruct mei_device *bus;\n\n\tcldev = container_of(work, struct mei_cl_device, rx_work);\n\n\tbus = cldev->bus;\n\n\tif (cldev->rx_cb)\n\t\tcldev->rx_cb(cldev);\n\n\tmutex_lock(&bus->device_lock);\n\tif (mei_cl_is_connected(cldev->cl))\n\t\tmei_cl_read_start(cldev->cl, mei_cl_mtu(cldev->cl), NULL);\n\tmutex_unlock(&bus->device_lock);\n}\n\n \nstatic void mei_cl_bus_notif_work(struct work_struct *work)\n{\n\tstruct mei_cl_device *cldev;\n\n\tcldev = container_of(work, struct mei_cl_device, notif_work);\n\n\tif (cldev->notif_cb)\n\t\tcldev->notif_cb(cldev);\n}\n\n \nbool mei_cl_bus_notify_event(struct mei_cl *cl)\n{\n\tstruct mei_cl_device *cldev = cl->cldev;\n\n\tif (!cldev || !cldev->notif_cb)\n\t\treturn false;\n\n\tif (!cl->notify_ev)\n\t\treturn false;\n\n\tschedule_work(&cldev->notif_work);\n\n\tcl->notify_ev = false;\n\n\treturn true;\n}\n\n \nbool mei_cl_bus_rx_event(struct mei_cl *cl)\n{\n\tstruct mei_cl_device *cldev = cl->cldev;\n\n\tif (!cldev || !cldev->rx_cb)\n\t\treturn false;\n\n\tschedule_work(&cldev->rx_work);\n\n\treturn true;\n}\n\n \nint mei_cldev_register_rx_cb(struct mei_cl_device *cldev, mei_cldev_cb_t rx_cb)\n{\n\tstruct mei_device *bus = cldev->bus;\n\tint ret;\n\n\tif (!rx_cb)\n\t\treturn -EINVAL;\n\tif (cldev->rx_cb)\n\t\treturn -EALREADY;\n\n\tcldev->rx_cb = rx_cb;\n\tINIT_WORK(&cldev->rx_work, mei_cl_bus_rx_work);\n\n\tmutex_lock(&bus->device_lock);\n\tif (mei_cl_is_connected(cldev->cl))\n\t\tret = mei_cl_read_start(cldev->cl, mei_cl_mtu(cldev->cl), NULL);\n\telse\n\t\tret = -ENODEV;\n\tmutex_unlock(&bus->device_lock);\n\tif (ret && ret != -EBUSY) {\n\t\tcancel_work_sync(&cldev->rx_work);\n\t\tcldev->rx_cb = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mei_cldev_register_rx_cb);\n\n \nint mei_cldev_register_notif_cb(struct mei_cl_device *cldev,\n\t\t\t\tmei_cldev_cb_t notif_cb)\n{\n\tstruct mei_device *bus = cldev->bus;\n\tint ret;\n\n\tif (!notif_cb)\n\t\treturn -EINVAL;\n\n\tif (cldev->notif_cb)\n\t\treturn -EALREADY;\n\n\tcldev->notif_cb = notif_cb;\n\tINIT_WORK(&cldev->notif_work, mei_cl_bus_notif_work);\n\n\tmutex_lock(&bus->device_lock);\n\tret = mei_cl_notify_request(cldev->cl, NULL, 1);\n\tmutex_unlock(&bus->device_lock);\n\tif (ret) {\n\t\tcancel_work_sync(&cldev->notif_work);\n\t\tcldev->notif_cb = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mei_cldev_register_notif_cb);\n\n \nvoid *mei_cldev_get_drvdata(const struct mei_cl_device *cldev)\n{\n\treturn dev_get_drvdata(&cldev->dev);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_get_drvdata);\n\n \nvoid mei_cldev_set_drvdata(struct mei_cl_device *cldev, void *data)\n{\n\tdev_set_drvdata(&cldev->dev, data);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_set_drvdata);\n\n \nconst uuid_le *mei_cldev_uuid(const struct mei_cl_device *cldev)\n{\n\treturn mei_me_cl_uuid(cldev->me_cl);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_uuid);\n\n \nu8 mei_cldev_ver(const struct mei_cl_device *cldev)\n{\n\treturn mei_me_cl_ver(cldev->me_cl);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_ver);\n\n \nbool mei_cldev_enabled(const struct mei_cl_device *cldev)\n{\n\treturn mei_cl_is_connected(cldev->cl);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_enabled);\n\n \nstatic bool mei_cl_bus_module_get(struct mei_cl_device *cldev)\n{\n\treturn try_module_get(cldev->bus->dev->driver->owner);\n}\n\n \nstatic void mei_cl_bus_module_put(struct mei_cl_device *cldev)\n{\n\tmodule_put(cldev->bus->dev->driver->owner);\n}\n\n \nstatic inline struct mei_cl_vtag *mei_cl_bus_vtag(struct mei_cl *cl)\n{\n\treturn list_first_entry_or_null(&cl->vtag_map,\n\t\t\t\t\tstruct mei_cl_vtag, list);\n}\n\n \nstatic int mei_cl_bus_vtag_alloc(struct mei_cl_device *cldev)\n{\n\tstruct mei_cl *cl = cldev->cl;\n\tstruct mei_cl_vtag *cl_vtag;\n\n\t \n\tif (mei_cl_vt_support_check(cl) || mei_cl_bus_vtag(cl))\n\t\treturn 0;\n\n\tcl_vtag = mei_cl_vtag_alloc(NULL, 0);\n\tif (IS_ERR(cl_vtag))\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&cl_vtag->list, &cl->vtag_map);\n\n\treturn 0;\n}\n\n \nstatic void mei_cl_bus_vtag_free(struct mei_cl_device *cldev)\n{\n\tstruct mei_cl *cl = cldev->cl;\n\tstruct mei_cl_vtag *cl_vtag;\n\n\tcl_vtag = mei_cl_bus_vtag(cl);\n\tif (!cl_vtag)\n\t\treturn;\n\n\tlist_del(&cl_vtag->list);\n\tkfree(cl_vtag);\n}\n\nvoid *mei_cldev_dma_map(struct mei_cl_device *cldev, u8 buffer_id, size_t size)\n{\n\tstruct mei_device *bus;\n\tstruct mei_cl *cl;\n\tint ret;\n\n\tif (!cldev || !buffer_id || !size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!IS_ALIGNED(size, MEI_FW_PAGE_SIZE)) {\n\t\tdev_err(&cldev->dev, \"Map size should be aligned to %lu\\n\",\n\t\t\tMEI_FW_PAGE_SIZE);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcl = cldev->cl;\n\tbus = cldev->bus;\n\n\tmutex_lock(&bus->device_lock);\n\tif (cl->state == MEI_FILE_UNINITIALIZED) {\n\t\tret = mei_cl_link(cl);\n\t\tif (ret)\n\t\t\tgoto notlinked;\n\t\t \n\t\tcl->cldev = cldev;\n\t}\n\n\tret = mei_cl_dma_alloc_and_map(cl, NULL, buffer_id, size);\n\tif (ret)\n\t\tmei_cl_unlink(cl);\nnotlinked:\n\tmutex_unlock(&bus->device_lock);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\treturn cl->dma.vaddr;\n}\nEXPORT_SYMBOL_GPL(mei_cldev_dma_map);\n\nint mei_cldev_dma_unmap(struct mei_cl_device *cldev)\n{\n\tstruct mei_device *bus;\n\tstruct mei_cl *cl;\n\tint ret;\n\n\tif (!cldev)\n\t\treturn -EINVAL;\n\n\tcl = cldev->cl;\n\tbus = cldev->bus;\n\n\tmutex_lock(&bus->device_lock);\n\tret = mei_cl_dma_unmap(cl, NULL);\n\n\tmei_cl_flush_queues(cl, NULL);\n\tmei_cl_unlink(cl);\n\tmutex_unlock(&bus->device_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mei_cldev_dma_unmap);\n\n \nint mei_cldev_enable(struct mei_cl_device *cldev)\n{\n\tstruct mei_device *bus = cldev->bus;\n\tstruct mei_cl *cl;\n\tint ret;\n\n\tcl = cldev->cl;\n\n\tmutex_lock(&bus->device_lock);\n\tif (cl->state == MEI_FILE_UNINITIALIZED) {\n\t\tret = mei_cl_link(cl);\n\t\tif (ret)\n\t\t\tgoto notlinked;\n\t\t \n\t\tcl->cldev = cldev;\n\t}\n\n\tif (mei_cl_is_connected(cl)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (!mei_me_cl_is_active(cldev->me_cl)) {\n\t\tdev_err(&cldev->dev, \"me client is not active\\n\");\n\t\tret = -ENOTTY;\n\t\tgoto out;\n\t}\n\n\tret = mei_cl_bus_vtag_alloc(cldev);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mei_cl_connect(cl, cldev->me_cl, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"cannot connect\\n\");\n\t\tmei_cl_bus_vtag_free(cldev);\n\t}\n\nout:\n\tif (ret)\n\t\tmei_cl_unlink(cl);\nnotlinked:\n\tmutex_unlock(&bus->device_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mei_cldev_enable);\n\n \nstatic void mei_cldev_unregister_callbacks(struct mei_cl_device *cldev)\n{\n\tif (cldev->rx_cb) {\n\t\tcancel_work_sync(&cldev->rx_work);\n\t\tcldev->rx_cb = NULL;\n\t}\n\n\tif (cldev->notif_cb) {\n\t\tcancel_work_sync(&cldev->notif_work);\n\t\tcldev->notif_cb = NULL;\n\t}\n}\n\n \nint mei_cldev_disable(struct mei_cl_device *cldev)\n{\n\tstruct mei_device *bus;\n\tstruct mei_cl *cl;\n\tint err;\n\n\tif (!cldev)\n\t\treturn -ENODEV;\n\n\tcl = cldev->cl;\n\n\tbus = cldev->bus;\n\n\tmei_cldev_unregister_callbacks(cldev);\n\n\tmutex_lock(&bus->device_lock);\n\n\tmei_cl_bus_vtag_free(cldev);\n\n\tif (!mei_cl_is_connected(cl)) {\n\t\tdev_dbg(bus->dev, \"Already disconnected\\n\");\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = mei_cl_disconnect(cl);\n\tif (err < 0)\n\t\tdev_err(bus->dev, \"Could not disconnect from the ME client\\n\");\n\nout:\n\t \n\tif (!cl->dma_mapped) {\n\t\tmei_cl_flush_queues(cl, NULL);\n\t\tmei_cl_unlink(cl);\n\t}\n\n\tmutex_unlock(&bus->device_lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mei_cldev_disable);\n\n \nssize_t mei_cldev_send_gsc_command(struct mei_cl_device *cldev,\n\t\t\t\t   u8 client_id, u32 fence_id,\n\t\t\t\t   struct scatterlist *sg_in,\n\t\t\t\t   size_t total_in_len,\n\t\t\t\t   struct scatterlist *sg_out)\n{\n\tstruct mei_cl *cl;\n\tstruct mei_device *bus;\n\tssize_t ret = 0;\n\n\tstruct mei_ext_hdr_gsc_h2f *ext_hdr;\n\tsize_t buf_sz = sizeof(struct mei_ext_hdr_gsc_h2f);\n\tint sg_out_nents, sg_in_nents;\n\tint i;\n\tstruct scatterlist *sg;\n\tstruct mei_ext_hdr_gsc_f2h rx_msg;\n\tunsigned int sg_len;\n\n\tif (!cldev || !sg_in || !sg_out)\n\t\treturn -EINVAL;\n\n\tcl = cldev->cl;\n\tbus = cldev->bus;\n\n\tdev_dbg(bus->dev, \"client_id %u, fence_id %u\\n\", client_id, fence_id);\n\n\tif (!bus->hbm_f_gsc_supported)\n\t\treturn -EOPNOTSUPP;\n\n\tsg_out_nents = sg_nents(sg_out);\n\tsg_in_nents = sg_nents(sg_in);\n\t \n\tif (sg_out_nents <= 0 || sg_in_nents <= 0)\n\t\treturn -EINVAL;\n\n\tbuf_sz += (sg_out_nents + sg_in_nents) * sizeof(struct mei_gsc_sgl);\n\text_hdr = kzalloc(buf_sz, GFP_KERNEL);\n\tif (!ext_hdr)\n\t\treturn -ENOMEM;\n\n\t \n\text_hdr->hdr.type = MEI_EXT_HDR_GSC;\n\text_hdr->hdr.length = buf_sz / sizeof(u32);  \n\n\text_hdr->client_id = client_id;\n\text_hdr->addr_type = GSC_ADDRESS_TYPE_PHYSICAL_SGL;\n\text_hdr->fence_id = fence_id;\n\text_hdr->input_address_count = sg_in_nents;\n\text_hdr->output_address_count = sg_out_nents;\n\text_hdr->reserved[0] = 0;\n\text_hdr->reserved[1] = 0;\n\n\t \n\tfor (i = 0, sg = sg_in; i < sg_in_nents; i++, sg++) {\n\t\text_hdr->sgl[i].low = lower_32_bits(sg_dma_address(sg));\n\t\text_hdr->sgl[i].high = upper_32_bits(sg_dma_address(sg));\n\t\tsg_len = min_t(unsigned int, sg_dma_len(sg), PAGE_SIZE);\n\t\text_hdr->sgl[i].length = (sg_len <= total_in_len) ? sg_len : total_in_len;\n\t\ttotal_in_len -= ext_hdr->sgl[i].length;\n\t}\n\n\t \n\tfor (i = sg_in_nents, sg = sg_out; i < sg_in_nents + sg_out_nents; i++, sg++) {\n\t\text_hdr->sgl[i].low = lower_32_bits(sg_dma_address(sg));\n\t\text_hdr->sgl[i].high = upper_32_bits(sg_dma_address(sg));\n\t\tsg_len = min_t(unsigned int, sg_dma_len(sg), PAGE_SIZE);\n\t\text_hdr->sgl[i].length = sg_len;\n\t}\n\n\t \n\tret = __mei_cl_send(cl, (u8 *)ext_hdr, buf_sz, 0, MEI_CL_IO_SGL);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"__mei_cl_send failed, returned %zd\\n\", ret);\n\t\tgoto end;\n\t}\n\tif (ret != buf_sz) {\n\t\tdev_err(bus->dev, \"__mei_cl_send returned %zd instead of expected %zd\\n\",\n\t\t\tret, buf_sz);\n\t\tret = -EIO;\n\t\tgoto end;\n\t}\n\n\t \n\tret = __mei_cl_recv(cl, (u8 *)&rx_msg, sizeof(rx_msg), NULL, MEI_CL_IO_SGL, 0);\n\n\tif (ret != sizeof(rx_msg)) {\n\t\tdev_err(bus->dev, \"__mei_cl_recv returned %zd instead of expected %zd\\n\",\n\t\t\tret, sizeof(rx_msg));\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto end;\n\t}\n\n\t \n\tif (rx_msg.client_id != client_id || rx_msg.fence_id != fence_id) {\n\t\tdev_err(bus->dev, \"received client_id/fence_id  %u/%u  instead of %u/%u sent\\n\",\n\t\t\trx_msg.client_id, rx_msg.fence_id, client_id, fence_id);\n\t\tret = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tdev_dbg(bus->dev, \"gsc command: successfully written %u bytes\\n\",  rx_msg.written);\n\tret = rx_msg.written;\n\nend:\n\tkfree(ext_hdr);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mei_cldev_send_gsc_command);\n\n \nstatic const\nstruct mei_cl_device_id *mei_cl_device_find(const struct mei_cl_device *cldev,\n\t\t\t\t\t    const struct mei_cl_driver *cldrv)\n{\n\tconst struct mei_cl_device_id *id;\n\tconst uuid_le *uuid;\n\tu8 version;\n\tbool match;\n\n\tuuid = mei_me_cl_uuid(cldev->me_cl);\n\tversion = mei_me_cl_ver(cldev->me_cl);\n\n\tid = cldrv->id_table;\n\twhile (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {\n\t\tif (!uuid_le_cmp(*uuid, id->uuid)) {\n\t\t\tmatch = true;\n\n\t\t\tif (cldev->name[0])\n\t\t\t\tif (strncmp(cldev->name, id->name,\n\t\t\t\t\t    sizeof(id->name)))\n\t\t\t\t\tmatch = false;\n\n\t\t\tif (id->version != MEI_CL_VERSION_ANY)\n\t\t\t\tif (id->version != version)\n\t\t\t\t\tmatch = false;\n\t\t\tif (match)\n\t\t\t\treturn id;\n\t\t}\n\n\t\tid++;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int mei_cl_device_match(struct device *dev, struct device_driver *drv)\n{\n\tconst struct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tconst struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);\n\tconst struct mei_cl_device_id *found_id;\n\n\tif (!cldev->do_match)\n\t\treturn 0;\n\n\tif (!cldrv || !cldrv->id_table)\n\t\treturn 0;\n\n\tfound_id = mei_cl_device_find(cldev, cldrv);\n\tif (found_id)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int mei_cl_device_probe(struct device *dev)\n{\n\tstruct mei_cl_device *cldev;\n\tstruct mei_cl_driver *cldrv;\n\tconst struct mei_cl_device_id *id;\n\tint ret;\n\n\tcldev = to_mei_cl_device(dev);\n\tcldrv = to_mei_cl_driver(dev->driver);\n\n\tif (!cldrv || !cldrv->probe)\n\t\treturn -ENODEV;\n\n\tid = mei_cl_device_find(cldev, cldrv);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tif (!mei_cl_bus_module_get(cldev)) {\n\t\tdev_err(&cldev->dev, \"get hw module failed\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = cldrv->probe(cldev, id);\n\tif (ret) {\n\t\tmei_cl_bus_module_put(cldev);\n\t\treturn ret;\n\t}\n\n\t__module_get(THIS_MODULE);\n\treturn 0;\n}\n\n \nstatic void mei_cl_device_remove(struct device *dev)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tstruct mei_cl_driver *cldrv = to_mei_cl_driver(dev->driver);\n\n\tif (cldrv->remove)\n\t\tcldrv->remove(cldev);\n\n\tmei_cldev_unregister_callbacks(cldev);\n\n\tmei_cl_bus_module_put(cldev);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *a,\n\t\t\t     char *buf)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\", cldev->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t uuid_show(struct device *dev, struct device_attribute *a,\n\t\t\t     char *buf)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tconst uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);\n\n\treturn sprintf(buf, \"%pUl\", uuid);\n}\nstatic DEVICE_ATTR_RO(uuid);\n\nstatic ssize_t version_show(struct device *dev, struct device_attribute *a,\n\t\t\t     char *buf)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tu8 version = mei_me_cl_ver(cldev->me_cl);\n\n\treturn sprintf(buf, \"%02X\", version);\n}\nstatic DEVICE_ATTR_RO(version);\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *a,\n\t\t\t     char *buf)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tconst uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);\n\tu8 version = mei_me_cl_ver(cldev->me_cl);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"mei:%s:%pUl:%02X:\",\n\t\t\t cldev->name, uuid, version);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t max_conn_show(struct device *dev, struct device_attribute *a,\n\t\t\t     char *buf)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tu8 maxconn = mei_me_cl_max_conn(cldev->me_cl);\n\n\treturn sprintf(buf, \"%d\", maxconn);\n}\nstatic DEVICE_ATTR_RO(max_conn);\n\nstatic ssize_t fixed_show(struct device *dev, struct device_attribute *a,\n\t\t\t  char *buf)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tu8 fixed = mei_me_cl_fixed(cldev->me_cl);\n\n\treturn sprintf(buf, \"%d\", fixed);\n}\nstatic DEVICE_ATTR_RO(fixed);\n\nstatic ssize_t vtag_show(struct device *dev, struct device_attribute *a,\n\t\t\t char *buf)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tbool vt = mei_me_cl_vt(cldev->me_cl);\n\n\treturn sprintf(buf, \"%d\", vt);\n}\nstatic DEVICE_ATTR_RO(vtag);\n\nstatic ssize_t max_len_show(struct device *dev, struct device_attribute *a,\n\t\t\t    char *buf)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tu32 maxlen = mei_me_cl_max_len(cldev->me_cl);\n\n\treturn sprintf(buf, \"%u\", maxlen);\n}\nstatic DEVICE_ATTR_RO(max_len);\n\nstatic struct attribute *mei_cldev_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_uuid.attr,\n\t&dev_attr_version.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_max_conn.attr,\n\t&dev_attr_fixed.attr,\n\t&dev_attr_vtag.attr,\n\t&dev_attr_max_len.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(mei_cldev);\n\n \nstatic int mei_cl_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tconst uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);\n\tu8 version = mei_me_cl_ver(cldev->me_cl);\n\n\tif (add_uevent_var(env, \"MEI_CL_VERSION=%d\", version))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"MEI_CL_UUID=%pUl\", uuid))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"MEI_CL_NAME=%s\", cldev->name))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"MODALIAS=mei:%s:%pUl:%02X:\",\n\t\t\t   cldev->name, uuid, version))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic struct bus_type mei_cl_bus_type = {\n\t.name\t\t= \"mei\",\n\t.dev_groups\t= mei_cldev_groups,\n\t.match\t\t= mei_cl_device_match,\n\t.probe\t\t= mei_cl_device_probe,\n\t.remove\t\t= mei_cl_device_remove,\n\t.uevent\t\t= mei_cl_device_uevent,\n};\n\nstatic struct mei_device *mei_dev_bus_get(struct mei_device *bus)\n{\n\tif (bus)\n\t\tget_device(bus->dev);\n\n\treturn bus;\n}\n\nstatic void mei_dev_bus_put(struct mei_device *bus)\n{\n\tif (bus)\n\t\tput_device(bus->dev);\n}\n\nstatic void mei_cl_bus_dev_release(struct device *dev)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\n\tmei_cl_flush_queues(cldev->cl, NULL);\n\tmei_me_cl_put(cldev->me_cl);\n\tmei_dev_bus_put(cldev->bus);\n\tkfree(cldev->cl);\n\tkfree(cldev);\n}\n\nstatic const struct device_type mei_cl_device_type = {\n\t.release = mei_cl_bus_dev_release,\n};\n\n \nstatic inline void mei_cl_bus_set_name(struct mei_cl_device *cldev)\n{\n\tdev_set_name(&cldev->dev, \"%s-%pUl\",\n\t\t     dev_name(cldev->bus->dev),\n\t\t     mei_me_cl_uuid(cldev->me_cl));\n}\n\n \nstatic struct mei_cl_device *mei_cl_bus_dev_alloc(struct mei_device *bus,\n\t\t\t\t\t\t  struct mei_me_client *me_cl)\n{\n\tstruct mei_cl_device *cldev;\n\tstruct mei_cl *cl;\n\n\tcldev = kzalloc(sizeof(*cldev), GFP_KERNEL);\n\tif (!cldev)\n\t\treturn NULL;\n\n\tcl = mei_cl_allocate(bus);\n\tif (!cl) {\n\t\tkfree(cldev);\n\t\treturn NULL;\n\t}\n\n\tdevice_initialize(&cldev->dev);\n\tcldev->dev.parent = bus->dev;\n\tcldev->dev.bus    = &mei_cl_bus_type;\n\tcldev->dev.type   = &mei_cl_device_type;\n\tcldev->bus        = mei_dev_bus_get(bus);\n\tcldev->me_cl      = mei_me_cl_get(me_cl);\n\tcldev->cl         = cl;\n\tmei_cl_bus_set_name(cldev);\n\tcldev->is_added   = 0;\n\tINIT_LIST_HEAD(&cldev->bus_list);\n\tdevice_enable_async_suspend(&cldev->dev);\n\n\treturn cldev;\n}\n\n \nstatic bool mei_cl_bus_dev_setup(struct mei_device *bus,\n\t\t\t\t struct mei_cl_device *cldev)\n{\n\tcldev->do_match = 1;\n\tmei_cl_bus_dev_fixup(cldev);\n\n\t \n\tif (cldev->do_match)\n\t\tmei_cl_bus_set_name(cldev);\n\n\treturn cldev->do_match == 1;\n}\n\n \nstatic int mei_cl_bus_dev_add(struct mei_cl_device *cldev)\n{\n\tint ret;\n\n\tdev_dbg(cldev->bus->dev, \"adding %pUL:%02X\\n\",\n\t\tmei_me_cl_uuid(cldev->me_cl),\n\t\tmei_me_cl_ver(cldev->me_cl));\n\tret = device_add(&cldev->dev);\n\tif (!ret)\n\t\tcldev->is_added = 1;\n\n\treturn ret;\n}\n\n \nstatic void mei_cl_bus_dev_stop(struct mei_cl_device *cldev)\n{\n\tcldev->do_match = 0;\n\tif (cldev->is_added)\n\t\tdevice_release_driver(&cldev->dev);\n}\n\n \nstatic void mei_cl_bus_dev_destroy(struct mei_cl_device *cldev)\n{\n\n\tWARN_ON(!mutex_is_locked(&cldev->bus->cl_bus_lock));\n\n\tif (!cldev->is_added)\n\t\treturn;\n\n\tdevice_del(&cldev->dev);\n\n\tlist_del_init(&cldev->bus_list);\n\n\tcldev->is_added = 0;\n\tput_device(&cldev->dev);\n}\n\n \nstatic void mei_cl_bus_remove_device(struct mei_cl_device *cldev)\n{\n\tmei_cl_bus_dev_stop(cldev);\n\tmei_cl_bus_dev_destroy(cldev);\n}\n\n \nvoid mei_cl_bus_remove_devices(struct mei_device *bus)\n{\n\tstruct mei_cl_device *cldev, *next;\n\n\tmutex_lock(&bus->cl_bus_lock);\n\tlist_for_each_entry_safe(cldev, next, &bus->device_list, bus_list)\n\t\tmei_cl_bus_remove_device(cldev);\n\tmutex_unlock(&bus->cl_bus_lock);\n}\n\n\n \nstatic void mei_cl_bus_dev_init(struct mei_device *bus,\n\t\t\t\tstruct mei_me_client *me_cl)\n{\n\tstruct mei_cl_device *cldev;\n\n\tWARN_ON(!mutex_is_locked(&bus->cl_bus_lock));\n\n\tdev_dbg(bus->dev, \"initializing %pUl\", mei_me_cl_uuid(me_cl));\n\n\tif (me_cl->bus_added)\n\t\treturn;\n\n\tcldev = mei_cl_bus_dev_alloc(bus, me_cl);\n\tif (!cldev)\n\t\treturn;\n\n\tme_cl->bus_added = true;\n\tlist_add_tail(&cldev->bus_list, &bus->device_list);\n\n}\n\n \nstatic void mei_cl_bus_rescan(struct mei_device *bus)\n{\n\tstruct mei_cl_device *cldev, *n;\n\tstruct mei_me_client *me_cl;\n\n\tmutex_lock(&bus->cl_bus_lock);\n\n\tdown_read(&bus->me_clients_rwsem);\n\tlist_for_each_entry(me_cl, &bus->me_clients, list)\n\t\tmei_cl_bus_dev_init(bus, me_cl);\n\tup_read(&bus->me_clients_rwsem);\n\n\tlist_for_each_entry_safe(cldev, n, &bus->device_list, bus_list) {\n\n\t\tif (!mei_me_cl_is_active(cldev->me_cl)) {\n\t\t\tmei_cl_bus_remove_device(cldev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cldev->is_added)\n\t\t\tcontinue;\n\n\t\tif (mei_cl_bus_dev_setup(bus, cldev))\n\t\t\tmei_cl_bus_dev_add(cldev);\n\t\telse {\n\t\t\tlist_del_init(&cldev->bus_list);\n\t\t\tput_device(&cldev->dev);\n\t\t}\n\t}\n\tmutex_unlock(&bus->cl_bus_lock);\n\n\tdev_dbg(bus->dev, \"rescan end\");\n}\n\nvoid mei_cl_bus_rescan_work(struct work_struct *work)\n{\n\tstruct mei_device *bus =\n\t\tcontainer_of(work, struct mei_device, bus_rescan_work);\n\n\tmei_cl_bus_rescan(bus);\n}\n\nint __mei_cldev_driver_register(struct mei_cl_driver *cldrv,\n\t\t\t\tstruct module *owner)\n{\n\tint err;\n\n\tcldrv->driver.name = cldrv->name;\n\tcldrv->driver.owner = owner;\n\tcldrv->driver.bus = &mei_cl_bus_type;\n\n\terr = driver_register(&cldrv->driver);\n\tif (err)\n\t\treturn err;\n\n\tpr_debug(\"mei: driver [%s] registered\\n\", cldrv->driver.name);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__mei_cldev_driver_register);\n\nvoid mei_cldev_driver_unregister(struct mei_cl_driver *cldrv)\n{\n\tdriver_unregister(&cldrv->driver);\n\n\tpr_debug(\"mei: driver [%s] unregistered\\n\", cldrv->driver.name);\n}\nEXPORT_SYMBOL_GPL(mei_cldev_driver_unregister);\n\n\nint __init mei_cl_bus_init(void)\n{\n\treturn bus_register(&mei_cl_bus_type);\n}\n\nvoid __exit mei_cl_bus_exit(void)\n{\n\tbus_unregister(&mei_cl_bus_type);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}