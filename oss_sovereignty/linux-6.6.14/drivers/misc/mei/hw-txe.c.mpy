{
  "module_name": "hw-txe.c",
  "hash_id": "0e5caa2519d2adb20fab7f21a0a2d186833239f64862d177b9481a34da09a25c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/hw-txe.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/jiffies.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/mei.h>\n\n#include \"mei_dev.h\"\n#include \"hw-txe.h\"\n#include \"client.h\"\n#include \"hbm.h\"\n\n#include \"mei-trace.h\"\n\n#define TXE_HBUF_DEPTH (PAYLOAD_SIZE / MEI_SLOT_SIZE)\n\n \nstatic inline u32 mei_txe_reg_read(void __iomem *base_addr,\n\t\t\t\t\tunsigned long offset)\n{\n\treturn ioread32(base_addr + offset);\n}\n\n \nstatic inline void mei_txe_reg_write(void __iomem *base_addr,\n\t\t\t\tunsigned long offset, u32 value)\n{\n\tiowrite32(value, base_addr + offset);\n}\n\n \nstatic inline u32 mei_txe_sec_reg_read_silent(struct mei_txe_hw *hw,\n\t\t\t\tunsigned long offset)\n{\n\treturn mei_txe_reg_read(hw->mem_addr[SEC_BAR], offset);\n}\n\n \nstatic inline u32 mei_txe_sec_reg_read(struct mei_txe_hw *hw,\n\t\t\t\tunsigned long offset)\n{\n\tWARN(!hw->aliveness, \"sec read: aliveness not asserted\\n\");\n\treturn mei_txe_sec_reg_read_silent(hw, offset);\n}\n \nstatic inline void mei_txe_sec_reg_write_silent(struct mei_txe_hw *hw,\n\t\t\t\tunsigned long offset, u32 value)\n{\n\tmei_txe_reg_write(hw->mem_addr[SEC_BAR], offset, value);\n}\n\n \nstatic inline void mei_txe_sec_reg_write(struct mei_txe_hw *hw,\n\t\t\t\tunsigned long offset, u32 value)\n{\n\tWARN(!hw->aliveness, \"sec write: aliveness not asserted\\n\");\n\tmei_txe_sec_reg_write_silent(hw, offset, value);\n}\n \nstatic inline u32 mei_txe_br_reg_read(struct mei_txe_hw *hw,\n\t\t\t\tunsigned long offset)\n{\n\treturn mei_txe_reg_read(hw->mem_addr[BRIDGE_BAR], offset);\n}\n\n \nstatic inline void mei_txe_br_reg_write(struct mei_txe_hw *hw,\n\t\t\t\tunsigned long offset, u32 value)\n{\n\tmei_txe_reg_write(hw->mem_addr[BRIDGE_BAR], offset, value);\n}\n\n \nstatic bool mei_txe_aliveness_set(struct mei_device *dev, u32 req)\n{\n\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tbool do_req = hw->aliveness != req;\n\n\tdev_dbg(dev->dev, \"Aliveness current=%d request=%d\\n\",\n\t\t\t\thw->aliveness, req);\n\tif (do_req) {\n\t\tdev->pg_event = MEI_PG_EVENT_WAIT;\n\t\tmei_txe_br_reg_write(hw, SICR_HOST_ALIVENESS_REQ_REG, req);\n\t}\n\treturn do_req;\n}\n\n\n \nstatic u32 mei_txe_aliveness_req_get(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tu32 reg;\n\n\treg = mei_txe_br_reg_read(hw, SICR_HOST_ALIVENESS_REQ_REG);\n\treturn reg & SICR_HOST_ALIVENESS_REQ_REQUESTED;\n}\n\n \nstatic u32 mei_txe_aliveness_get(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tu32 reg;\n\n\treg = mei_txe_br_reg_read(hw, HICR_HOST_ALIVENESS_RESP_REG);\n\treturn reg & HICR_HOST_ALIVENESS_RESP_ACK;\n}\n\n \nstatic int mei_txe_aliveness_poll(struct mei_device *dev, u32 expected)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tktime_t stop, start;\n\n\tstart = ktime_get();\n\tstop = ktime_add(start, ms_to_ktime(SEC_ALIVENESS_WAIT_TIMEOUT));\n\tdo {\n\t\thw->aliveness = mei_txe_aliveness_get(dev);\n\t\tif (hw->aliveness == expected) {\n\t\t\tdev->pg_event = MEI_PG_EVENT_IDLE;\n\t\t\tdev_dbg(dev->dev, \"aliveness settled after %lld usecs\\n\",\n\t\t\t\tktime_to_us(ktime_sub(ktime_get(), start)));\n\t\t\treturn 0;\n\t\t}\n\t\tusleep_range(20, 50);\n\t} while (ktime_before(ktime_get(), stop));\n\n\tdev->pg_event = MEI_PG_EVENT_IDLE;\n\tdev_err(dev->dev, \"aliveness timed out\\n\");\n\treturn -ETIME;\n}\n\n \nstatic int mei_txe_aliveness_wait(struct mei_device *dev, u32 expected)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tconst unsigned long timeout =\n\t\t\tmsecs_to_jiffies(SEC_ALIVENESS_WAIT_TIMEOUT);\n\tlong err;\n\tint ret;\n\n\thw->aliveness = mei_txe_aliveness_get(dev);\n\tif (hw->aliveness == expected)\n\t\treturn 0;\n\n\tmutex_unlock(&dev->device_lock);\n\terr = wait_event_timeout(hw->wait_aliveness_resp,\n\t\t\tdev->pg_event == MEI_PG_EVENT_RECEIVED, timeout);\n\tmutex_lock(&dev->device_lock);\n\n\thw->aliveness = mei_txe_aliveness_get(dev);\n\tret = hw->aliveness == expected ? 0 : -ETIME;\n\n\tif (ret)\n\t\tdev_warn(dev->dev, \"aliveness timed out = %ld aliveness = %d event = %d\\n\",\n\t\t\terr, hw->aliveness, dev->pg_event);\n\telse\n\t\tdev_dbg(dev->dev, \"aliveness settled after = %d msec aliveness = %d event = %d\\n\",\n\t\t\tjiffies_to_msecs(timeout - err),\n\t\t\thw->aliveness, dev->pg_event);\n\n\tdev->pg_event = MEI_PG_EVENT_IDLE;\n\treturn ret;\n}\n\n \nint mei_txe_aliveness_set_sync(struct mei_device *dev, u32 req)\n{\n\tif (mei_txe_aliveness_set(dev, req))\n\t\treturn mei_txe_aliveness_wait(dev, req);\n\treturn 0;\n}\n\n \nstatic bool mei_txe_pg_in_transition(struct mei_device *dev)\n{\n\treturn dev->pg_event == MEI_PG_EVENT_WAIT;\n}\n\n \nstatic bool mei_txe_pg_is_enabled(struct mei_device *dev)\n{\n\treturn true;\n}\n\n \nstatic inline enum mei_pg_state mei_txe_pg_state(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\treturn hw->aliveness ? MEI_PG_OFF : MEI_PG_ON;\n}\n\n \nstatic void mei_txe_input_ready_interrupt_enable(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tu32 hintmsk;\n\t \n\thintmsk = mei_txe_sec_reg_read(hw, SEC_IPC_HOST_INT_MASK_REG);\n\thintmsk |= SEC_IPC_HOST_INT_MASK_IN_RDY;\n\tmei_txe_sec_reg_write(hw, SEC_IPC_HOST_INT_MASK_REG, hintmsk);\n}\n\n \nstatic void mei_txe_input_doorbell_set(struct mei_txe_hw *hw)\n{\n\t \n\tclear_bit(TXE_INTR_IN_READY_BIT, &hw->intr_cause);\n\tmei_txe_sec_reg_write(hw, SEC_IPC_INPUT_DOORBELL_REG, 1);\n}\n\n \nstatic void mei_txe_output_ready_set(struct mei_txe_hw *hw)\n{\n\tmei_txe_br_reg_write(hw,\n\t\t\tSICR_SEC_IPC_OUTPUT_STATUS_REG,\n\t\t\tSEC_IPC_OUTPUT_STATUS_RDY);\n}\n\n \nstatic bool mei_txe_is_input_ready(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tu32 status;\n\n\tstatus = mei_txe_sec_reg_read(hw, SEC_IPC_INPUT_STATUS_REG);\n\treturn !!(SEC_IPC_INPUT_STATUS_RDY & status);\n}\n\n \nstatic inline void mei_txe_intr_clear(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\tmei_txe_sec_reg_write_silent(hw, SEC_IPC_HOST_INT_STATUS_REG,\n\t\tSEC_IPC_HOST_INT_STATUS_PENDING);\n\tmei_txe_br_reg_write(hw, HISR_REG, HISR_INT_STS_MSK);\n\tmei_txe_br_reg_write(hw, HHISR_REG, IPC_HHIER_MSK);\n}\n\n \nstatic void mei_txe_intr_disable(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\tmei_txe_br_reg_write(hw, HHIER_REG, 0);\n\tmei_txe_br_reg_write(hw, HIER_REG, 0);\n}\n \nstatic void mei_txe_intr_enable(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\tmei_txe_br_reg_write(hw, HHIER_REG, IPC_HHIER_MSK);\n\tmei_txe_br_reg_write(hw, HIER_REG, HIER_INT_EN_MSK);\n}\n\n \nstatic void mei_txe_synchronize_irq(struct mei_device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tsynchronize_irq(pdev->irq);\n}\n\n \nstatic bool mei_txe_pending_interrupts(struct mei_device *dev)\n{\n\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tbool ret = (hw->intr_cause & (TXE_INTR_READINESS |\n\t\t\t\t      TXE_INTR_ALIVENESS |\n\t\t\t\t      TXE_INTR_IN_READY  |\n\t\t\t\t      TXE_INTR_OUT_DB));\n\n\tif (ret) {\n\t\tdev_dbg(dev->dev,\n\t\t\t\"Pending Interrupts InReady=%01d Readiness=%01d, Aliveness=%01d, OutDoor=%01d\\n\",\n\t\t\t!!(hw->intr_cause & TXE_INTR_IN_READY),\n\t\t\t!!(hw->intr_cause & TXE_INTR_READINESS),\n\t\t\t!!(hw->intr_cause & TXE_INTR_ALIVENESS),\n\t\t\t!!(hw->intr_cause & TXE_INTR_OUT_DB));\n\t}\n\treturn ret;\n}\n\n \nstatic void mei_txe_input_payload_write(struct mei_device *dev,\n\t\t\tunsigned long idx, u32 value)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\tmei_txe_sec_reg_write(hw, SEC_IPC_INPUT_PAYLOAD_REG +\n\t\t\t(idx * sizeof(u32)), value);\n}\n\n \nstatic u32 mei_txe_out_data_read(const struct mei_device *dev,\n\t\t\t\t\tunsigned long idx)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\treturn mei_txe_br_reg_read(hw,\n\t\tBRIDGE_IPC_OUTPUT_PAYLOAD_REG + (idx * sizeof(u32)));\n}\n\n \n\n \nstatic void mei_txe_readiness_set_host_rdy(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\tmei_txe_br_reg_write(hw,\n\t\tSICR_HOST_IPC_READINESS_REQ_REG,\n\t\tSICR_HOST_IPC_READINESS_HOST_RDY);\n}\n\n \nstatic void mei_txe_readiness_clear(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\tmei_txe_br_reg_write(hw, SICR_HOST_IPC_READINESS_REQ_REG,\n\t\t\t\tSICR_HOST_IPC_READINESS_RDY_CLR);\n}\n \nstatic u32 mei_txe_readiness_get(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\treturn mei_txe_br_reg_read(hw, HICR_SEC_IPC_READINESS_REG);\n}\n\n\n \nstatic inline bool mei_txe_readiness_is_sec_rdy(u32 readiness)\n{\n\treturn !!(readiness & HICR_SEC_IPC_READINESS_SEC_RDY);\n}\n\n \nstatic bool mei_txe_hw_is_ready(struct mei_device *dev)\n{\n\tu32 readiness =  mei_txe_readiness_get(dev);\n\n\treturn mei_txe_readiness_is_sec_rdy(readiness);\n}\n\n \nstatic inline bool mei_txe_host_is_ready(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tu32 reg = mei_txe_br_reg_read(hw, HICR_SEC_IPC_READINESS_REG);\n\n\treturn !!(reg & HICR_SEC_IPC_READINESS_HOST_RDY);\n}\n\n \nstatic int mei_txe_readiness_wait(struct mei_device *dev)\n{\n\tif (mei_txe_hw_is_ready(dev))\n\t\treturn 0;\n\n\tmutex_unlock(&dev->device_lock);\n\twait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready,\n\t\t\tmsecs_to_jiffies(SEC_RESET_WAIT_TIMEOUT));\n\tmutex_lock(&dev->device_lock);\n\tif (!dev->recvd_hw_ready) {\n\t\tdev_err(dev->dev, \"wait for readiness failed\\n\");\n\t\treturn -ETIME;\n\t}\n\n\tdev->recvd_hw_ready = false;\n\treturn 0;\n}\n\nstatic const struct mei_fw_status mei_txe_fw_sts = {\n\t.count = 2,\n\t.status[0] = PCI_CFG_TXE_FW_STS0,\n\t.status[1] = PCI_CFG_TXE_FW_STS1\n};\n\n \nstatic int mei_txe_fw_status(struct mei_device *dev,\n\t\t\t     struct mei_fw_status *fw_status)\n{\n\tconst struct mei_fw_status *fw_src = &mei_txe_fw_sts;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tint ret;\n\tint i;\n\n\tif (!fw_status)\n\t\treturn -EINVAL;\n\n\tfw_status->count = fw_src->count;\n\tfor (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {\n\t\tret = pci_read_config_dword(pdev, fw_src->status[i],\n\t\t\t\t\t    &fw_status->status[i]);\n\t\ttrace_mei_pci_cfg_read(dev->dev, \"PCI_CFG_HSF_X\",\n\t\t\t\t       fw_src->status[i],\n\t\t\t\t       fw_status->status[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mei_txe_hw_config(struct mei_device *dev)\n{\n\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\thw->aliveness = mei_txe_aliveness_get(dev);\n\thw->readiness = mei_txe_readiness_get(dev);\n\n\tdev_dbg(dev->dev, \"aliveness_resp = 0x%08x, readiness = 0x%08x.\\n\",\n\t\thw->aliveness, hw->readiness);\n\n\treturn 0;\n}\n\n \nstatic int mei_txe_write(struct mei_device *dev,\n\t\t\t const void *hdr, size_t hdr_len,\n\t\t\t const void *data, size_t data_len)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tunsigned long rem;\n\tconst u32 *reg_buf;\n\tu32 slots = TXE_HBUF_DEPTH;\n\tu32 dw_cnt;\n\tunsigned long i, j;\n\n\tif (WARN_ON(!hdr || !data || hdr_len & 0x3))\n\t\treturn -EINVAL;\n\n\tdev_dbg(dev->dev, MEI_HDR_FMT, MEI_HDR_PRM((struct mei_msg_hdr *)hdr));\n\n\tdw_cnt = mei_data2slots(hdr_len + data_len);\n\tif (dw_cnt > slots)\n\t\treturn -EMSGSIZE;\n\n\tif (WARN(!hw->aliveness, \"txe write: aliveness not asserted\\n\"))\n\t\treturn -EAGAIN;\n\n\t \n\tmei_txe_input_ready_interrupt_enable(dev);\n\n\tif (!mei_txe_is_input_ready(dev)) {\n\t\tchar fw_sts_str[MEI_FW_STATUS_STR_SZ];\n\n\t\tmei_fw_status_str(dev, fw_sts_str, MEI_FW_STATUS_STR_SZ);\n\t\tdev_err(dev->dev, \"Input is not ready %s\\n\", fw_sts_str);\n\t\treturn -EAGAIN;\n\t}\n\n\treg_buf = hdr;\n\tfor (i = 0; i < hdr_len / MEI_SLOT_SIZE; i++)\n\t\tmei_txe_input_payload_write(dev, i, reg_buf[i]);\n\n\treg_buf = data;\n\tfor (j = 0; j < data_len / MEI_SLOT_SIZE; j++)\n\t\tmei_txe_input_payload_write(dev, i + j, reg_buf[j]);\n\n\trem = data_len & 0x3;\n\tif (rem > 0) {\n\t\tu32 reg = 0;\n\n\t\tmemcpy(&reg, (const u8 *)data + data_len - rem, rem);\n\t\tmei_txe_input_payload_write(dev, i + j, reg);\n\t}\n\n\t \n\thw->slots = 0;\n\n\t \n\tmei_txe_input_doorbell_set(hw);\n\n\treturn 0;\n}\n\n \nstatic u32 mei_txe_hbuf_depth(const struct mei_device *dev)\n{\n\treturn TXE_HBUF_DEPTH;\n}\n\n \nstatic int mei_txe_hbuf_empty_slots(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\treturn hw->slots;\n}\n\n \nstatic int mei_txe_count_full_read_slots(struct mei_device *dev)\n{\n\t \n\treturn TXE_HBUF_DEPTH;\n}\n\n \n\nstatic u32 mei_txe_read_hdr(const struct mei_device *dev)\n{\n\treturn mei_txe_out_data_read(dev, 0);\n}\n \nstatic int mei_txe_read(struct mei_device *dev,\n\t\tunsigned char *buf, unsigned long len)\n{\n\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tu32 *reg_buf, reg;\n\tu32 rem;\n\tu32 i;\n\n\tif (WARN_ON(!buf || !len))\n\t\treturn -EINVAL;\n\n\treg_buf = (u32 *)buf;\n\trem = len & 0x3;\n\n\tdev_dbg(dev->dev, \"buffer-length = %lu buf[0]0x%08X\\n\",\n\t\tlen, mei_txe_out_data_read(dev, 0));\n\n\tfor (i = 0; i < len / MEI_SLOT_SIZE; i++) {\n\t\t \n\t\treg = mei_txe_out_data_read(dev, i + 1);\n\t\tdev_dbg(dev->dev, \"buf[%d] = 0x%08X\\n\", i, reg);\n\t\t*reg_buf++ = reg;\n\t}\n\n\tif (rem) {\n\t\treg = mei_txe_out_data_read(dev, i + 1);\n\t\tmemcpy(reg_buf, &reg, rem);\n\t}\n\n\tmei_txe_output_ready_set(hw);\n\treturn 0;\n}\n\n \nstatic int mei_txe_hw_reset(struct mei_device *dev, bool intr_enable)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\tu32 aliveness_req;\n\t \n\t(void)mei_txe_sec_reg_read_silent(hw, SEC_IPC_INPUT_DOORBELL_REG);\n\n\taliveness_req = mei_txe_aliveness_req_get(dev);\n\thw->aliveness = mei_txe_aliveness_get(dev);\n\n\t \n\tmei_txe_intr_disable(dev);\n\n\t \n\tif (aliveness_req != hw->aliveness)\n\t\tif (mei_txe_aliveness_poll(dev, aliveness_req) < 0) {\n\t\t\tdev_err(dev->dev, \"wait for aliveness settle failed ... bailing out\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t \n\tif (aliveness_req) {\n\t\tmei_txe_aliveness_set(dev, 0);\n\t\tif (mei_txe_aliveness_poll(dev, 0) < 0) {\n\t\t\tdev_err(dev->dev, \"wait for aliveness failed ... bailing out\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tmei_txe_readiness_clear(dev);\n\n\treturn 0;\n}\n\n \nstatic int mei_txe_hw_start(struct mei_device *dev)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tint ret;\n\n\tu32 hisr;\n\n\t \n\tmei_txe_intr_enable(dev);\n\n\tret = mei_txe_readiness_wait(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"waiting for readiness failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\thisr = mei_txe_br_reg_read(hw, HISR_REG);\n\tif (hisr & HISR_INT_2_STS)\n\t\tmei_txe_br_reg_write(hw, HISR_REG, HISR_INT_2_STS);\n\n\t \n\tclear_bit(TXE_INTR_OUT_DB_BIT, &hw->intr_cause);\n\n\tret = mei_txe_aliveness_set_sync(dev, 1);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"wait for aliveness failed ... bailing out\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_set_active(dev->dev);\n\n\t \n\tmei_txe_input_ready_interrupt_enable(dev);\n\n\n\t \n\tmei_txe_output_ready_set(hw);\n\n\t \n\tmei_txe_readiness_set_host_rdy(dev);\n\n\treturn 0;\n}\n\n \nstatic bool mei_txe_check_and_ack_intrs(struct mei_device *dev, bool do_ack)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tu32 hisr;\n\tu32 hhisr;\n\tu32 ipc_isr;\n\tu32 aliveness;\n\tbool generated;\n\n\t \n\thhisr = mei_txe_br_reg_read(hw, HHISR_REG);\n\tgenerated = (hhisr & IPC_HHIER_MSK);\n\tif (!generated)\n\t\tgoto out;\n\n\thisr = mei_txe_br_reg_read(hw, HISR_REG);\n\n\taliveness = mei_txe_aliveness_get(dev);\n\tif (hhisr & IPC_HHIER_SEC && aliveness) {\n\t\tipc_isr = mei_txe_sec_reg_read_silent(hw,\n\t\t\t\tSEC_IPC_HOST_INT_STATUS_REG);\n\t} else {\n\t\tipc_isr = 0;\n\t\thhisr &= ~IPC_HHIER_SEC;\n\t}\n\n\tif (do_ack) {\n\t\t \n\t\thw->intr_cause |= hisr & HISR_INT_STS_MSK;\n\t\tif (ipc_isr & SEC_IPC_HOST_INT_STATUS_IN_RDY)\n\t\t\thw->intr_cause |= TXE_INTR_IN_READY;\n\n\n\t\tmei_txe_intr_disable(dev);\n\t\t \n\t\tmei_txe_sec_reg_write_silent(hw,\n\t\t\tSEC_IPC_HOST_INT_STATUS_REG, ipc_isr);\n\t\tmei_txe_br_reg_write(hw, HISR_REG, hisr);\n\t\tmei_txe_br_reg_write(hw, HHISR_REG, hhisr);\n\t}\n\nout:\n\treturn generated;\n}\n\n \nirqreturn_t mei_txe_irq_quick_handler(int irq, void *dev_id)\n{\n\tstruct mei_device *dev = dev_id;\n\n\tif (mei_txe_check_and_ack_intrs(dev, true))\n\t\treturn IRQ_WAKE_THREAD;\n\treturn IRQ_NONE;\n}\n\n\n \nirqreturn_t mei_txe_irq_thread_handler(int irq, void *dev_id)\n{\n\tstruct mei_device *dev = (struct mei_device *) dev_id;\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\tstruct list_head cmpl_list;\n\ts32 slots;\n\tint rets = 0;\n\n\tdev_dbg(dev->dev, \"irq thread: Interrupt Registers HHISR|HISR|SEC=%02X|%04X|%02X\\n\",\n\t\tmei_txe_br_reg_read(hw, HHISR_REG),\n\t\tmei_txe_br_reg_read(hw, HISR_REG),\n\t\tmei_txe_sec_reg_read_silent(hw, SEC_IPC_HOST_INT_STATUS_REG));\n\n\n\t \n\tmutex_lock(&dev->device_lock);\n\tINIT_LIST_HEAD(&cmpl_list);\n\n\tif (pci_dev_msi_enabled(to_pci_dev(dev->dev)))\n\t\tmei_txe_check_and_ack_intrs(dev, true);\n\n\t \n\tmei_txe_pending_interrupts(dev);\n\n\thw->aliveness = mei_txe_aliveness_get(dev);\n\thw->readiness = mei_txe_readiness_get(dev);\n\n\t \n\tif (test_and_clear_bit(TXE_INTR_READINESS_BIT, &hw->intr_cause)) {\n\t\tdev_dbg(dev->dev, \"Readiness Interrupt was received...\\n\");\n\n\t\t \n\t\tif (mei_txe_readiness_is_sec_rdy(hw->readiness)) {\n\t\t\tdev_dbg(dev->dev, \"we need to start the dev.\\n\");\n\t\t\tdev->recvd_hw_ready = true;\n\t\t} else {\n\t\t\tdev->recvd_hw_ready = false;\n\t\t\tif (dev->dev_state != MEI_DEV_RESETTING) {\n\n\t\t\t\tdev_warn(dev->dev, \"FW not ready: resetting.\\n\");\n\t\t\t\tschedule_work(&dev->reset_work);\n\t\t\t\tgoto end;\n\n\t\t\t}\n\t\t}\n\t\twake_up(&dev->wait_hw_ready);\n\t}\n\n\t \n\t \n\n\tif (test_and_clear_bit(TXE_INTR_ALIVENESS_BIT, &hw->intr_cause)) {\n\t\t \n\t\tdev_dbg(dev->dev,\n\t\t\t\"Aliveness Interrupt: Status: %d\\n\", hw->aliveness);\n\t\tdev->pg_event = MEI_PG_EVENT_RECEIVED;\n\t\tif (waitqueue_active(&hw->wait_aliveness_resp))\n\t\t\twake_up(&hw->wait_aliveness_resp);\n\t}\n\n\n\t \n\tslots = mei_count_full_read_slots(dev);\n\tif (test_and_clear_bit(TXE_INTR_OUT_DB_BIT, &hw->intr_cause)) {\n\t\t \n\t\trets = mei_irq_read_handler(dev, &cmpl_list, &slots);\n\t\tif (rets &&\n\t\t    (dev->dev_state != MEI_DEV_RESETTING &&\n\t\t     dev->dev_state != MEI_DEV_POWER_DOWN)) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"mei_irq_read_handler ret = %d.\\n\", rets);\n\n\t\t\tschedule_work(&dev->reset_work);\n\t\t\tgoto end;\n\t\t}\n\t}\n\t \n\tif (test_and_clear_bit(TXE_INTR_IN_READY_BIT, &hw->intr_cause)) {\n\t\tdev->hbuf_is_ready = true;\n\t\thw->slots = TXE_HBUF_DEPTH;\n\t}\n\n\tif (hw->aliveness && dev->hbuf_is_ready) {\n\t\t \n\t\tdev->hbuf_is_ready = mei_hbuf_is_ready(dev);\n\t\trets = mei_irq_write_handler(dev, &cmpl_list);\n\t\tif (rets && rets != -EMSGSIZE)\n\t\t\tdev_err(dev->dev, \"mei_irq_write_handler ret = %d.\\n\",\n\t\t\t\trets);\n\t\tdev->hbuf_is_ready = mei_hbuf_is_ready(dev);\n\t}\n\n\tmei_irq_compl_handler(dev, &cmpl_list);\n\nend:\n\tdev_dbg(dev->dev, \"interrupt thread end ret = %d\\n\", rets);\n\n\tmutex_unlock(&dev->device_lock);\n\n\tmei_enable_interrupts(dev);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct mei_hw_ops mei_txe_hw_ops = {\n\n\t.host_is_ready = mei_txe_host_is_ready,\n\n\t.fw_status = mei_txe_fw_status,\n\t.pg_state = mei_txe_pg_state,\n\n\t.hw_is_ready = mei_txe_hw_is_ready,\n\t.hw_reset = mei_txe_hw_reset,\n\t.hw_config = mei_txe_hw_config,\n\t.hw_start = mei_txe_hw_start,\n\n\t.pg_in_transition = mei_txe_pg_in_transition,\n\t.pg_is_enabled = mei_txe_pg_is_enabled,\n\n\t.intr_clear = mei_txe_intr_clear,\n\t.intr_enable = mei_txe_intr_enable,\n\t.intr_disable = mei_txe_intr_disable,\n\t.synchronize_irq = mei_txe_synchronize_irq,\n\n\t.hbuf_free_slots = mei_txe_hbuf_empty_slots,\n\t.hbuf_is_ready = mei_txe_is_input_ready,\n\t.hbuf_depth = mei_txe_hbuf_depth,\n\n\t.write = mei_txe_write,\n\n\t.rdbuf_full_slots = mei_txe_count_full_read_slots,\n\t.read_hdr = mei_txe_read_hdr,\n\n\t.read = mei_txe_read,\n\n};\n\n \nstruct mei_device *mei_txe_dev_init(struct pci_dev *pdev)\n{\n\tstruct mei_device *dev;\n\tstruct mei_txe_hw *hw;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev) + sizeof(*hw), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tmei_device_init(dev, &pdev->dev, false, &mei_txe_hw_ops);\n\n\thw = to_txe_hw(dev);\n\n\tinit_waitqueue_head(&hw->wait_aliveness_resp);\n\n\treturn dev;\n}\n\n \nint mei_txe_setup_satt2(struct mei_device *dev, phys_addr_t addr, u32 range)\n{\n\tstruct mei_txe_hw *hw = to_txe_hw(dev);\n\n\tu32 lo32 = lower_32_bits(addr);\n\tu32 hi32 = upper_32_bits(addr);\n\tu32 ctrl;\n\n\t \n\tif (hi32 & ~0xF)\n\t\treturn -EINVAL;\n\n\t \n\tif (lo32 & 0xF)\n\t\treturn -EINVAL;\n\n\t \n\tif (range & 0x4)\n\t\treturn -EINVAL;\n\n\t \n\tif (range > SATT_RANGE_MAX)\n\t\treturn -EINVAL;\n\n\tctrl = SATT2_CTRL_VALID_MSK;\n\tctrl |= hi32  << SATT2_CTRL_BR_BASE_ADDR_REG_SHIFT;\n\n\tmei_txe_br_reg_write(hw, SATT2_SAP_SIZE_REG, range);\n\tmei_txe_br_reg_write(hw, SATT2_BRG_BA_LSB_REG, lo32);\n\tmei_txe_br_reg_write(hw, SATT2_CTRL_REG, ctrl);\n\tdev_dbg(dev->dev, \"SATT2: SAP_SIZE_OFFSET=0x%08X, BRG_BA_LSB_OFFSET=0x%08X, CTRL_OFFSET=0x%08X\\n\",\n\t\trange, lo32, ctrl);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}