{
  "module_name": "mei_dev.h",
  "hash_id": "888670344bd973bebede077c0fa20902d142226dfc124eb9d4bd2f778d6c43b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/mei_dev.h",
  "human_readable_source": " \n \n\n#ifndef _MEI_DEV_H_\n#define _MEI_DEV_H_\n\n#include <linux/types.h>\n#include <linux/cdev.h>\n#include <linux/poll.h>\n#include <linux/mei.h>\n#include <linux/mei_cl_bus.h>\n\nstatic inline int uuid_le_cmp(const uuid_le u1, const uuid_le u2)\n{\n\treturn memcmp(&u1, &u2, sizeof(uuid_le));\n}\n\n#include \"hw.h\"\n#include \"hbm.h\"\n\n#define MEI_SLOT_SIZE             sizeof(u32)\n#define MEI_RD_MSG_BUF_SIZE       (128 * MEI_SLOT_SIZE)\n\n \n#define MEI_CLIENTS_MAX 256\n\n \n#define MEI_MAX_CONSEC_RESET  3\n\n \n#define  MEI_MAX_OPEN_HANDLE_COUNT (MEI_CLIENTS_MAX - 1)\n\n \nenum file_state {\n\tMEI_FILE_UNINITIALIZED = 0,\n\tMEI_FILE_INITIALIZING,\n\tMEI_FILE_CONNECTING,\n\tMEI_FILE_CONNECTED,\n\tMEI_FILE_DISCONNECTING,\n\tMEI_FILE_DISCONNECT_REPLY,\n\tMEI_FILE_DISCONNECT_REQUIRED,\n\tMEI_FILE_DISCONNECTED,\n};\n\n \nenum mei_dev_state {\n\tMEI_DEV_INITIALIZING = 0,\n\tMEI_DEV_INIT_CLIENTS,\n\tMEI_DEV_ENABLED,\n\tMEI_DEV_RESETTING,\n\tMEI_DEV_DISABLED,\n\tMEI_DEV_POWERING_DOWN,\n\tMEI_DEV_POWER_DOWN,\n\tMEI_DEV_POWER_UP\n};\n\n \nenum mei_dev_pxp_mode {\n\tMEI_DEV_PXP_DEFAULT = 0,\n\tMEI_DEV_PXP_INIT    = 1,\n\tMEI_DEV_PXP_SETUP   = 2,\n\tMEI_DEV_PXP_READY   = 3,\n};\n\nconst char *mei_dev_state_str(int state);\n\nenum mei_file_transaction_states {\n\tMEI_IDLE,\n\tMEI_WRITING,\n\tMEI_WRITE_COMPLETE,\n};\n\n \nenum mei_cb_file_ops {\n\tMEI_FOP_READ = 0,\n\tMEI_FOP_WRITE,\n\tMEI_FOP_CONNECT,\n\tMEI_FOP_DISCONNECT,\n\tMEI_FOP_DISCONNECT_RSP,\n\tMEI_FOP_NOTIFY_START,\n\tMEI_FOP_NOTIFY_STOP,\n\tMEI_FOP_DMA_MAP,\n\tMEI_FOP_DMA_UNMAP,\n};\n\n \nenum mei_cl_io_mode {\n\tMEI_CL_IO_TX_BLOCKING = BIT(0),\n\tMEI_CL_IO_TX_INTERNAL = BIT(1),\n\n\tMEI_CL_IO_RX_NONBLOCK = BIT(2),\n\n\tMEI_CL_IO_SGL         = BIT(3),\n};\n\n \nstruct mei_msg_data {\n\tsize_t size;\n\tunsigned char *data;\n};\n\nstruct mei_dma_data {\n\tu8 buffer_id;\n\tvoid *vaddr;\n\tdma_addr_t daddr;\n\tsize_t size;\n};\n\n \nstruct mei_dma_dscr {\n\tvoid *vaddr;\n\tdma_addr_t daddr;\n\tsize_t size;\n};\n\n \n#define MEI_FW_STATUS_MAX 6\n \n#define MEI_FW_STATUS_STR_SZ (MEI_FW_STATUS_MAX * (8 + 1))\n\n\n \nstruct mei_fw_status {\n\tint count;\n\tu32 status[MEI_FW_STATUS_MAX];\n};\n\n \nstruct mei_me_client {\n\tstruct list_head list;\n\tstruct kref refcnt;\n\tstruct mei_client_properties props;\n\tu8 client_id;\n\tu8 tx_flow_ctrl_creds;\n\tu8 connect_count;\n\tu8 bus_added;\n};\n\n\nstruct mei_cl;\n\n \nstruct mei_cl_cb {\n\tstruct list_head list;\n\tstruct mei_cl *cl;\n\tenum mei_cb_file_ops fop_type;\n\tstruct mei_msg_data buf;\n\tsize_t buf_idx;\n\tu8 vtag;\n\tconst struct file *fp;\n\tint status;\n\tu32 internal:1;\n\tu32 blocking:1;\n\tstruct mei_ext_hdr *ext_hdr;\n};\n\n \nstruct mei_cl_vtag {\n\tstruct list_head list;\n\tconst struct file *fp;\n\tu8 vtag;\n\tu8 pending_read:1;\n};\n\n \nstruct mei_cl {\n\tstruct list_head link;\n\tstruct mei_device *dev;\n\tenum file_state state;\n\twait_queue_head_t tx_wait;\n\twait_queue_head_t rx_wait;\n\twait_queue_head_t wait;\n\twait_queue_head_t ev_wait;\n\tstruct fasync_struct *ev_async;\n\tint status;\n\tstruct mei_me_client *me_cl;\n\tconst struct file *fp;\n\tu8 host_client_id;\n\tstruct list_head vtag_map;\n\tu8 tx_flow_ctrl_creds;\n\tu8 rx_flow_ctrl_creds;\n\tu8 timer_count;\n\tu8 notify_en;\n\tu8 notify_ev;\n\tu8 tx_cb_queued;\n\tenum mei_file_transaction_states writing_state;\n\tstruct list_head rd_pending;\n\tspinlock_t rd_completed_lock;  \n\tstruct list_head rd_completed;\n\tstruct mei_dma_data dma;\n\tu8 dma_mapped;\n\n\tstruct mei_cl_device *cldev;\n};\n\n#define MEI_TX_QUEUE_LIMIT_DEFAULT 50\n#define MEI_TX_QUEUE_LIMIT_MAX 255\n#define MEI_TX_QUEUE_LIMIT_MIN 30\n\n \nstruct mei_hw_ops {\n\n\tbool (*host_is_ready)(struct mei_device *dev);\n\n\tbool (*hw_is_ready)(struct mei_device *dev);\n\tint (*hw_reset)(struct mei_device *dev, bool enable);\n\tint (*hw_start)(struct mei_device *dev);\n\tint (*hw_config)(struct mei_device *dev);\n\n\tint (*fw_status)(struct mei_device *dev, struct mei_fw_status *fw_sts);\n\tint (*trc_status)(struct mei_device *dev, u32 *trc);\n\n\tenum mei_pg_state (*pg_state)(struct mei_device *dev);\n\tbool (*pg_in_transition)(struct mei_device *dev);\n\tbool (*pg_is_enabled)(struct mei_device *dev);\n\n\tvoid (*intr_clear)(struct mei_device *dev);\n\tvoid (*intr_enable)(struct mei_device *dev);\n\tvoid (*intr_disable)(struct mei_device *dev);\n\tvoid (*synchronize_irq)(struct mei_device *dev);\n\n\tint (*hbuf_free_slots)(struct mei_device *dev);\n\tbool (*hbuf_is_ready)(struct mei_device *dev);\n\tu32 (*hbuf_depth)(const struct mei_device *dev);\n\tint (*write)(struct mei_device *dev,\n\t\t     const void *hdr, size_t hdr_len,\n\t\t     const void *data, size_t data_len);\n\n\tint (*rdbuf_full_slots)(struct mei_device *dev);\n\n\tu32 (*read_hdr)(const struct mei_device *dev);\n\tint (*read)(struct mei_device *dev,\n\t\t     unsigned char *buf, unsigned long len);\n};\n\n \nvoid mei_cl_bus_rescan_work(struct work_struct *work);\nvoid mei_cl_bus_dev_fixup(struct mei_cl_device *dev);\nssize_t __mei_cl_send(struct mei_cl *cl, const u8 *buf, size_t length, u8 vtag,\n\t\t      unsigned int mode);\nssize_t __mei_cl_send_timeout(struct mei_cl *cl, const u8 *buf, size_t length, u8 vtag,\n\t\t\t      unsigned int mode, unsigned long timeout);\nssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length, u8 *vtag,\n\t\t      unsigned int mode, unsigned long timeout);\nbool mei_cl_bus_rx_event(struct mei_cl *cl);\nbool mei_cl_bus_notify_event(struct mei_cl *cl);\nvoid mei_cl_bus_remove_devices(struct mei_device *bus);\nint mei_cl_bus_init(void);\nvoid mei_cl_bus_exit(void);\n\n \nenum mei_pg_event {\n\tMEI_PG_EVENT_IDLE,\n\tMEI_PG_EVENT_WAIT,\n\tMEI_PG_EVENT_RECEIVED,\n\tMEI_PG_EVENT_INTR_WAIT,\n\tMEI_PG_EVENT_INTR_RECEIVED,\n};\n\n \nenum mei_pg_state {\n\tMEI_PG_OFF = 0,\n\tMEI_PG_ON =  1,\n};\n\nconst char *mei_pg_state_str(enum mei_pg_state state);\n\n \nstruct mei_fw_version {\n\tu8 platform;\n\tu8 major;\n\tu16 minor;\n\tu16 buildno;\n\tu16 hotfix;\n};\n\n#define MEI_MAX_FW_VER_BLOCKS 3\n\nstruct mei_dev_timeouts {\n\tunsigned long hw_ready;  \n\tint connect;  \n\tunsigned long cl_connect;  \n\tint client_init;  \n\tunsigned long pgi;  \n\tunsigned int d0i3;  \n\tunsigned long hbm;  \n\tunsigned long mkhi_recv;  \n};\n\n \nstruct mei_device {\n\tstruct device *dev;\n\tstruct cdev cdev;\n\tint minor;\n\n\tstruct list_head write_list;\n\tstruct list_head write_waiting_list;\n\tstruct list_head ctrl_wr_list;\n\tstruct list_head ctrl_rd_list;\n\tu8 tx_queue_limit;\n\n\tstruct list_head file_list;\n\tlong open_handle_count;\n\n\tstruct mutex device_lock;\n\tstruct delayed_work timer_work;\n\n\tbool recvd_hw_ready;\n\t \n\twait_queue_head_t wait_hw_ready;\n\twait_queue_head_t wait_pg;\n\twait_queue_head_t wait_hbm_start;\n\n\t \n\tunsigned long reset_count;\n\tenum mei_dev_state dev_state;\n\tenum mei_hbm_state hbm_state;\n\tenum mei_dev_pxp_mode pxp_mode;\n\tu16 init_clients_timer;\n\n\t \n\tenum mei_pg_event pg_event;\n#ifdef CONFIG_PM\n\tstruct dev_pm_domain pg_domain;\n#endif  \n\n\tunsigned char rd_msg_buf[MEI_RD_MSG_BUF_SIZE];\n\tu32 rd_msg_hdr[MEI_RD_MSG_BUF_SIZE];\n\tint rd_msg_hdr_count;\n\n\t \n\tbool hbuf_is_ready;\n\n\tstruct mei_dma_dscr dr_dscr[DMA_DSCR_NUM];\n\n\tstruct hbm_version version;\n\tunsigned int hbm_f_pg_supported:1;\n\tunsigned int hbm_f_dc_supported:1;\n\tunsigned int hbm_f_dot_supported:1;\n\tunsigned int hbm_f_ev_supported:1;\n\tunsigned int hbm_f_fa_supported:1;\n\tunsigned int hbm_f_ie_supported:1;\n\tunsigned int hbm_f_os_supported:1;\n\tunsigned int hbm_f_dr_supported:1;\n\tunsigned int hbm_f_vt_supported:1;\n\tunsigned int hbm_f_cap_supported:1;\n\tunsigned int hbm_f_cd_supported:1;\n\tunsigned int hbm_f_gsc_supported:1;\n\n\tstruct mei_fw_version fw_ver[MEI_MAX_FW_VER_BLOCKS];\n\n\tunsigned int fw_f_fw_ver_supported:1;\n\tunsigned int fw_ver_received:1;\n\n\tstruct rw_semaphore me_clients_rwsem;\n\tstruct list_head me_clients;\n\tDECLARE_BITMAP(me_clients_map, MEI_CLIENTS_MAX);\n\tDECLARE_BITMAP(host_clients_map, MEI_CLIENTS_MAX);\n\n\tbool allow_fixed_address;\n\tbool override_fixed_address;\n\n\tstruct mei_dev_timeouts timeouts;\n\n\tstruct work_struct reset_work;\n\tstruct work_struct bus_rescan_work;\n\n\t \n\tstruct list_head device_list;\n\tstruct mutex cl_bus_lock;\n\n\tconst char *kind;\n\n#if IS_ENABLED(CONFIG_DEBUG_FS)\n\tstruct dentry *dbgfs_dir;\n#endif  \n\n\tconst struct mei_hw_ops *ops;\n\tchar hw[] __aligned(sizeof(void *));\n};\n\nstatic inline unsigned long mei_secs_to_jiffies(unsigned long sec)\n{\n\treturn msecs_to_jiffies(sec * MSEC_PER_SEC);\n}\n\n \nstatic inline u32 mei_data2slots(size_t length)\n{\n\treturn DIV_ROUND_UP(length, MEI_SLOT_SIZE);\n}\n\n \nstatic inline u32 mei_hbm2slots(size_t length)\n{\n\treturn DIV_ROUND_UP(sizeof(struct mei_msg_hdr) + length, MEI_SLOT_SIZE);\n}\n\n \nstatic inline u32 mei_slots2data(int slots)\n{\n\treturn slots * MEI_SLOT_SIZE;\n}\n\n \nvoid mei_device_init(struct mei_device *dev,\n\t\t     struct device *device,\n\t\t     bool slow_fw,\n\t\t     const struct mei_hw_ops *hw_ops);\nint mei_reset(struct mei_device *dev);\nint mei_start(struct mei_device *dev);\nint mei_restart(struct mei_device *dev);\nvoid mei_stop(struct mei_device *dev);\nvoid mei_cancel_work(struct mei_device *dev);\n\nvoid mei_set_devstate(struct mei_device *dev, enum mei_dev_state state);\n\nint mei_dmam_ring_alloc(struct mei_device *dev);\nvoid mei_dmam_ring_free(struct mei_device *dev);\nbool mei_dma_ring_is_allocated(struct mei_device *dev);\nvoid mei_dma_ring_reset(struct mei_device *dev);\nvoid mei_dma_ring_read(struct mei_device *dev, unsigned char *buf, u32 len);\nvoid mei_dma_ring_write(struct mei_device *dev, unsigned char *buf, u32 len);\nu32 mei_dma_ring_empty_slots(struct mei_device *dev);\n\n \n\nvoid mei_timer(struct work_struct *work);\nvoid mei_schedule_stall_timer(struct mei_device *dev);\nint mei_irq_read_handler(struct mei_device *dev,\n\t\t\t struct list_head *cmpl_list, s32 *slots);\n\nint mei_irq_write_handler(struct mei_device *dev, struct list_head *cmpl_list);\nvoid mei_irq_compl_handler(struct mei_device *dev, struct list_head *cmpl_list);\n\n \n\n\nstatic inline int mei_hw_config(struct mei_device *dev)\n{\n\treturn dev->ops->hw_config(dev);\n}\n\nstatic inline enum mei_pg_state mei_pg_state(struct mei_device *dev)\n{\n\treturn dev->ops->pg_state(dev);\n}\n\nstatic inline bool mei_pg_in_transition(struct mei_device *dev)\n{\n\treturn dev->ops->pg_in_transition(dev);\n}\n\nstatic inline bool mei_pg_is_enabled(struct mei_device *dev)\n{\n\treturn dev->ops->pg_is_enabled(dev);\n}\n\nstatic inline int mei_hw_reset(struct mei_device *dev, bool enable)\n{\n\treturn dev->ops->hw_reset(dev, enable);\n}\n\nstatic inline int mei_hw_start(struct mei_device *dev)\n{\n\treturn dev->ops->hw_start(dev);\n}\n\nstatic inline void mei_clear_interrupts(struct mei_device *dev)\n{\n\tdev->ops->intr_clear(dev);\n}\n\nstatic inline void mei_enable_interrupts(struct mei_device *dev)\n{\n\tdev->ops->intr_enable(dev);\n}\n\nstatic inline void mei_disable_interrupts(struct mei_device *dev)\n{\n\tdev->ops->intr_disable(dev);\n}\n\nstatic inline void mei_synchronize_irq(struct mei_device *dev)\n{\n\tdev->ops->synchronize_irq(dev);\n}\n\nstatic inline bool mei_host_is_ready(struct mei_device *dev)\n{\n\treturn dev->ops->host_is_ready(dev);\n}\nstatic inline bool mei_hw_is_ready(struct mei_device *dev)\n{\n\treturn dev->ops->hw_is_ready(dev);\n}\n\nstatic inline bool mei_hbuf_is_ready(struct mei_device *dev)\n{\n\treturn dev->ops->hbuf_is_ready(dev);\n}\n\nstatic inline int mei_hbuf_empty_slots(struct mei_device *dev)\n{\n\treturn dev->ops->hbuf_free_slots(dev);\n}\n\nstatic inline u32 mei_hbuf_depth(const struct mei_device *dev)\n{\n\treturn dev->ops->hbuf_depth(dev);\n}\n\nstatic inline int mei_write_message(struct mei_device *dev,\n\t\t\t\t    const void *hdr, size_t hdr_len,\n\t\t\t\t    const void *data, size_t data_len)\n{\n\treturn dev->ops->write(dev, hdr, hdr_len, data, data_len);\n}\n\nstatic inline u32 mei_read_hdr(const struct mei_device *dev)\n{\n\treturn dev->ops->read_hdr(dev);\n}\n\nstatic inline void mei_read_slots(struct mei_device *dev,\n\t\t     unsigned char *buf, unsigned long len)\n{\n\tdev->ops->read(dev, buf, len);\n}\n\nstatic inline int mei_count_full_read_slots(struct mei_device *dev)\n{\n\treturn dev->ops->rdbuf_full_slots(dev);\n}\n\nstatic inline int mei_trc_status(struct mei_device *dev, u32 *trc)\n{\n\tif (dev->ops->trc_status)\n\t\treturn dev->ops->trc_status(dev, trc);\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int mei_fw_status(struct mei_device *dev,\n\t\t\t\tstruct mei_fw_status *fw_status)\n{\n\treturn dev->ops->fw_status(dev, fw_status);\n}\n\nbool mei_hbuf_acquire(struct mei_device *dev);\n\nbool mei_write_is_idle(struct mei_device *dev);\n\n#if IS_ENABLED(CONFIG_DEBUG_FS)\nvoid mei_dbgfs_register(struct mei_device *dev, const char *name);\nvoid mei_dbgfs_deregister(struct mei_device *dev);\n#else\nstatic inline void mei_dbgfs_register(struct mei_device *dev, const char *name) {}\nstatic inline void mei_dbgfs_deregister(struct mei_device *dev) {}\n#endif  \n\nint mei_register(struct mei_device *dev, struct device *parent);\nvoid mei_deregister(struct mei_device *dev);\n\n#define MEI_HDR_FMT \"hdr:host=%02d me=%02d len=%d dma=%1d ext=%1d internal=%1d comp=%1d\"\n#define MEI_HDR_PRM(hdr)                  \\\n\t(hdr)->host_addr, (hdr)->me_addr, \\\n\t(hdr)->length, (hdr)->dma_ring, (hdr)->extended, \\\n\t(hdr)->internal, (hdr)->msg_complete\n\nssize_t mei_fw_status2str(struct mei_fw_status *fw_sts, char *buf, size_t len);\n \nstatic inline ssize_t mei_fw_status_str(struct mei_device *dev,\n\t\t\t\t\tchar *buf, size_t len)\n{\n\tstruct mei_fw_status fw_status;\n\tint ret;\n\n\tbuf[0] = '\\0';\n\n\tret = mei_fw_status(dev, &fw_status);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mei_fw_status2str(&fw_status, buf, MEI_FW_STATUS_STR_SZ);\n\n\treturn ret;\n}\n\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}