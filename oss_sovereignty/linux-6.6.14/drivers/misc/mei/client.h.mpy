{
  "module_name": "client.h",
  "hash_id": "9b2759a3bed6bc12cc774cee541e7d86c37f94f81210dc60f7a7cc87c38a5bf7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/client.h",
  "human_readable_source": " \n \n\n#ifndef _MEI_CLIENT_H_\n#define _MEI_CLIENT_H_\n\n#include <linux/types.h>\n#include <linux/poll.h>\n#include <linux/mei.h>\n\n#include \"mei_dev.h\"\n\n \nvoid mei_me_cl_init(struct mei_me_client *me_cl);\nvoid mei_me_cl_put(struct mei_me_client *me_cl);\nstruct mei_me_client *mei_me_cl_get(struct mei_me_client *me_cl);\n\nvoid mei_me_cl_add(struct mei_device *dev, struct mei_me_client *me_cl);\nvoid mei_me_cl_del(struct mei_device *dev, struct mei_me_client *me_cl);\n\nstruct mei_me_client *mei_me_cl_by_uuid(struct mei_device *dev,\n\t\t\t\t\tconst uuid_le *uuid);\nstruct mei_me_client *mei_me_cl_by_id(struct mei_device *dev, u8 client_id);\nstruct mei_me_client *mei_me_cl_by_uuid_id(struct mei_device *dev,\n\t\t\t\t\t   const uuid_le *uuid, u8 client_id);\nvoid mei_me_cl_rm_by_uuid(struct mei_device *dev, const uuid_le *uuid);\nvoid mei_me_cl_rm_by_uuid_id(struct mei_device *dev,\n\t\t\t     const uuid_le *uuid, u8 id);\nvoid mei_me_cl_rm_all(struct mei_device *dev);\n\n \nstatic inline bool mei_me_cl_is_active(const struct mei_me_client *me_cl)\n{\n\treturn !list_empty_careful(&me_cl->list);\n}\n\n \nstatic inline const uuid_le *mei_me_cl_uuid(const struct mei_me_client *me_cl)\n{\n\treturn &me_cl->props.protocol_name;\n}\n\n \nstatic inline u8 mei_me_cl_ver(const struct mei_me_client *me_cl)\n{\n\treturn me_cl->props.protocol_version;\n}\n\n \nstatic inline u8 mei_me_cl_max_conn(const struct mei_me_client *me_cl)\n{\n\treturn me_cl->props.max_number_of_connections;\n}\n\n \nstatic inline u8 mei_me_cl_fixed(const struct mei_me_client *me_cl)\n{\n\treturn me_cl->props.fixed_address;\n}\n\n \nstatic inline bool mei_me_cl_vt(const struct mei_me_client *me_cl)\n{\n\treturn me_cl->props.vt_supported == 1;\n}\n\n \nstatic inline u32 mei_me_cl_max_len(const struct mei_me_client *me_cl)\n{\n\treturn me_cl->props.max_msg_length;\n}\n\n \nvoid mei_io_cb_free(struct mei_cl_cb *priv_cb);\n\n \n\nstruct mei_cl *mei_cl_allocate(struct mei_device *dev);\n\nint mei_cl_link(struct mei_cl *cl);\nint mei_cl_unlink(struct mei_cl *cl);\n\nstruct mei_cl *mei_cl_alloc_linked(struct mei_device *dev);\n\nstruct mei_cl_cb *mei_cl_read_cb(struct mei_cl *cl, const struct file *fp);\n\nvoid mei_cl_add_rd_completed(struct mei_cl *cl, struct mei_cl_cb *cb);\nvoid mei_cl_del_rd_completed(struct mei_cl *cl, struct mei_cl_cb *cb);\n\nstruct mei_cl_cb *mei_cl_alloc_cb(struct mei_cl *cl, size_t length,\n\t\t\t\t  enum mei_cb_file_ops type,\n\t\t\t\t  const struct file *fp);\nstruct mei_cl_cb *mei_cl_enqueue_ctrl_wr_cb(struct mei_cl *cl, size_t length,\n\t\t\t\t\t    enum mei_cb_file_ops type,\n\t\t\t\t\t    const struct file *fp);\nint mei_cl_flush_queues(struct mei_cl *cl, const struct file *fp);\n\nstruct mei_cl_vtag *mei_cl_vtag_alloc(struct file *fp, u8 vtag);\nconst struct file *mei_cl_fp_by_vtag(const struct mei_cl *cl, u8 vtag);\nint mei_cl_vt_support_check(const struct mei_cl *cl);\n \n\n \nstatic inline bool mei_cl_is_connected(const struct mei_cl *cl)\n{\n\treturn  cl->state == MEI_FILE_CONNECTED;\n}\n\n \nstatic inline u8 mei_cl_me_id(const struct mei_cl *cl)\n{\n\treturn cl->me_cl ? cl->me_cl->client_id : 0;\n}\n\n \nstatic inline size_t mei_cl_mtu(const struct mei_cl *cl)\n{\n\treturn cl->me_cl ? cl->me_cl->props.max_msg_length : 0;\n}\n\n \nstatic inline bool mei_cl_is_fixed_address(const struct mei_cl *cl)\n{\n\treturn cl->me_cl && cl->me_cl->props.fixed_address;\n}\n\n \nstatic inline bool mei_cl_is_single_recv_buf(const struct mei_cl *cl)\n{\n\treturn cl->me_cl->props.single_recv_buf;\n}\n\n \nstatic inline const uuid_le *mei_cl_uuid(const struct mei_cl *cl)\n{\n\treturn mei_me_cl_uuid(cl->me_cl);\n}\n\n \nstatic inline u8 mei_cl_host_addr(const struct mei_cl *cl)\n{\n\treturn  mei_cl_is_fixed_address(cl) ? 0 : cl->host_client_id;\n}\n\nint mei_cl_disconnect(struct mei_cl *cl);\nint mei_cl_irq_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb,\n\t\t\t  struct list_head *cmpl_list);\nint mei_cl_connect(struct mei_cl *cl, struct mei_me_client *me_cl,\n\t\t   const struct file *file);\nint mei_cl_irq_connect(struct mei_cl *cl, struct mei_cl_cb *cb,\n\t\t       struct list_head *cmpl_list);\nint mei_cl_read_start(struct mei_cl *cl, size_t length, const struct file *fp);\nssize_t mei_cl_write(struct mei_cl *cl, struct mei_cl_cb *cb, unsigned long timeout);\nint mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,\n\t\t     struct list_head *cmpl_list);\n\nvoid mei_cl_complete(struct mei_cl *cl, struct mei_cl_cb *cb);\n\nvoid mei_host_client_init(struct mei_device *dev);\n\nu8 mei_cl_notify_fop2req(enum mei_cb_file_ops fop);\nenum mei_cb_file_ops mei_cl_notify_req2fop(u8 request);\nint mei_cl_notify_request(struct mei_cl *cl,\n\t\t\t  const struct file *file, u8 request);\nint mei_cl_irq_notify(struct mei_cl *cl, struct mei_cl_cb *cb,\n\t\t      struct list_head *cmpl_list);\nint mei_cl_notify_get(struct mei_cl *cl, bool block, bool *notify_ev);\nvoid mei_cl_notify(struct mei_cl *cl);\n\nvoid mei_cl_all_disconnect(struct mei_device *dev);\n\nint mei_cl_irq_dma_map(struct mei_cl *cl, struct mei_cl_cb *cb,\n\t\t       struct list_head *cmpl_list);\nint mei_cl_irq_dma_unmap(struct mei_cl *cl, struct mei_cl_cb *cb,\n\t\t\t struct list_head *cmpl_list);\nint mei_cl_dma_alloc_and_map(struct mei_cl *cl, const struct file *fp,\n\t\t\t     u8 buffer_id, size_t size);\nint mei_cl_dma_unmap(struct mei_cl *cl, const struct file *fp);\n\n#define MEI_CL_FMT \"cl:host=%02d me=%02d \"\n#define MEI_CL_PRM(cl) (cl)->host_client_id, mei_cl_me_id(cl)\n\n#define cl_dbg(dev, cl, format, arg...) \\\n\tdev_dbg((dev)->dev, MEI_CL_FMT format, MEI_CL_PRM(cl), ##arg)\n\n#define cl_warn(dev, cl, format, arg...) \\\n\tdev_warn((dev)->dev, MEI_CL_FMT format, MEI_CL_PRM(cl), ##arg)\n\n#define cl_err(dev, cl, format, arg...) \\\n\tdev_err((dev)->dev, MEI_CL_FMT format, MEI_CL_PRM(cl), ##arg)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}