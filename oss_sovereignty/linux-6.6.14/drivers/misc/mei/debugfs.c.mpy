{
  "module_name": "debugfs.c",
  "hash_id": "40dfdd9f881c1659a2e192da54183508ec3a336816ced3c55d5e2bc5bf1fa53c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#include <linux/mei.h>\n\n#include \"mei_dev.h\"\n#include \"client.h\"\n#include \"hw.h\"\n\nstatic int mei_dbgfs_meclients_show(struct seq_file *m, void *unused)\n{\n\tstruct mei_device *dev = m->private;\n\tstruct mei_me_client *me_cl;\n\tint i = 0;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdown_read(&dev->me_clients_rwsem);\n\n\tseq_puts(m, \"  |id|fix|         UUID                       |con|msg len|sb|refc|vt|\\n\");\n\n\t \n\tif (dev->dev_state != MEI_DEV_ENABLED)\n\t\tgoto out;\n\n\tlist_for_each_entry(me_cl, &dev->me_clients, list) {\n\t\tif (!mei_me_cl_get(me_cl))\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"%2d|%2d|%3d|%pUl|%3d|%7d|%2d|%4d|%2d|\\n\",\n\t\t\t   i++, me_cl->client_id,\n\t\t\t   me_cl->props.fixed_address,\n\t\t\t   &me_cl->props.protocol_name,\n\t\t\t   me_cl->props.max_number_of_connections,\n\t\t\t   me_cl->props.max_msg_length,\n\t\t\t   me_cl->props.single_recv_buf,\n\t\t\t   kref_read(&me_cl->refcnt),\n\t\t\t   me_cl->props.vt_supported);\n\t\tmei_me_cl_put(me_cl);\n\t}\n\nout:\n\tup_read(&dev->me_clients_rwsem);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(mei_dbgfs_meclients);\n\nstatic int mei_dbgfs_active_show(struct seq_file *m, void *unused)\n{\n\tstruct mei_device *dev = m->private;\n\tstruct mei_cl *cl;\n\tint i = 0;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->device_lock);\n\n\tseq_puts(m, \"   |me|host|state|rd|wr|wrq\\n\");\n\n\t \n\tif (dev->dev_state != MEI_DEV_ENABLED)\n\t\tgoto out;\n\n\tlist_for_each_entry(cl, &dev->file_list, link) {\n\n\t\tseq_printf(m, \"%3d|%2d|%4d|%5d|%2d|%2d|%3u\\n\",\n\t\t\t   i, mei_cl_me_id(cl), cl->host_client_id, cl->state,\n\t\t\t   !list_empty(&cl->rd_completed), cl->writing_state,\n\t\t\t   cl->tx_cb_queued);\n\t\ti++;\n\t}\nout:\n\tmutex_unlock(&dev->device_lock);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(mei_dbgfs_active);\n\nstatic const char *mei_dev_pxp_mode_str(enum mei_dev_pxp_mode state)\n{\n#define MEI_PXP_MODE(state) case MEI_DEV_PXP_##state: return #state\n\tswitch (state) {\n\tMEI_PXP_MODE(DEFAULT);\n\tMEI_PXP_MODE(INIT);\n\tMEI_PXP_MODE(SETUP);\n\tMEI_PXP_MODE(READY);\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n#undef MEI_PXP_MODE\n}\n\nstatic int mei_dbgfs_devstate_show(struct seq_file *m, void *unused)\n{\n\tstruct mei_device *dev = m->private;\n\n\tseq_printf(m, \"dev: %s\\n\", mei_dev_state_str(dev->dev_state));\n\tseq_printf(m, \"hbm: %s\\n\", mei_hbm_state_str(dev->hbm_state));\n\n\tif (dev->hbm_state >= MEI_HBM_ENUM_CLIENTS &&\n\t    dev->hbm_state <= MEI_HBM_STARTED) {\n\t\tseq_puts(m, \"hbm features:\\n\");\n\t\tseq_printf(m, \"\\tPG: %01d\\n\", dev->hbm_f_pg_supported);\n\t\tseq_printf(m, \"\\tDC: %01d\\n\", dev->hbm_f_dc_supported);\n\t\tseq_printf(m, \"\\tIE: %01d\\n\", dev->hbm_f_ie_supported);\n\t\tseq_printf(m, \"\\tDOT: %01d\\n\", dev->hbm_f_dot_supported);\n\t\tseq_printf(m, \"\\tEV: %01d\\n\", dev->hbm_f_ev_supported);\n\t\tseq_printf(m, \"\\tFA: %01d\\n\", dev->hbm_f_fa_supported);\n\t\tseq_printf(m, \"\\tOS: %01d\\n\", dev->hbm_f_os_supported);\n\t\tseq_printf(m, \"\\tDR: %01d\\n\", dev->hbm_f_dr_supported);\n\t\tseq_printf(m, \"\\tVT: %01d\\n\", dev->hbm_f_vt_supported);\n\t\tseq_printf(m, \"\\tCAP: %01d\\n\", dev->hbm_f_cap_supported);\n\t\tseq_printf(m, \"\\tCD: %01d\\n\", dev->hbm_f_cd_supported);\n\t}\n\n\tseq_printf(m, \"pg:  %s, %s\\n\",\n\t\t   mei_pg_is_enabled(dev) ? \"ENABLED\" : \"DISABLED\",\n\t\t   mei_pg_state_str(mei_pg_state(dev)));\n\n\tseq_printf(m, \"pxp: %s\\n\", mei_dev_pxp_mode_str(dev->pxp_mode));\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(mei_dbgfs_devstate);\n\nstatic ssize_t mei_dbgfs_write_allow_fa(struct file *file,\n\t\t\t\t\tconst char __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct mei_device *dev;\n\tint ret;\n\n\tdev = container_of(file->private_data,\n\t\t\t   struct mei_device, allow_fixed_address);\n\n\tret = debugfs_write_file_bool(file, user_buf, count, ppos);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev->override_fixed_address = true;\n\treturn ret;\n}\n\nstatic const struct file_operations mei_dbgfs_allow_fa_fops = {\n\t.open = simple_open,\n\t.read = debugfs_read_file_bool,\n\t.write = mei_dbgfs_write_allow_fa,\n\t.llseek = generic_file_llseek,\n};\n\n \nvoid mei_dbgfs_deregister(struct mei_device *dev)\n{\n\tif (!dev->dbgfs_dir)\n\t\treturn;\n\tdebugfs_remove_recursive(dev->dbgfs_dir);\n\tdev->dbgfs_dir = NULL;\n}\n\n \nvoid mei_dbgfs_register(struct mei_device *dev, const char *name)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(name, NULL);\n\tdev->dbgfs_dir = dir;\n\n\tdebugfs_create_file(\"meclients\", S_IRUSR, dir, dev,\n\t\t\t    &mei_dbgfs_meclients_fops);\n\tdebugfs_create_file(\"active\", S_IRUSR, dir, dev,\n\t\t\t    &mei_dbgfs_active_fops);\n\tdebugfs_create_file(\"devstate\", S_IRUSR, dir, dev,\n\t\t\t    &mei_dbgfs_devstate_fops);\n\tdebugfs_create_file(\"allow_fixed_address\", S_IRUSR | S_IWUSR, dir,\n\t\t\t    &dev->allow_fixed_address,\n\t\t\t    &mei_dbgfs_allow_fa_fops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}