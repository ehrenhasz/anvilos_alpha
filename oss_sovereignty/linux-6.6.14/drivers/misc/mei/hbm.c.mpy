{
  "module_name": "hbm.c",
  "hash_id": "ec955d41398074fc6e4cf03cd95a7e98f458f19daff14e07095e71e813adf5e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/hbm.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include <linux/mei.h>\n\n#include \"mei_dev.h\"\n#include \"hbm.h\"\n#include \"client.h\"\n\nstatic const char *mei_hbm_status_str(enum mei_hbm_status status)\n{\n#define MEI_HBM_STATUS(status) case MEI_HBMS_##status: return #status\n\tswitch (status) {\n\tMEI_HBM_STATUS(SUCCESS);\n\tMEI_HBM_STATUS(CLIENT_NOT_FOUND);\n\tMEI_HBM_STATUS(ALREADY_EXISTS);\n\tMEI_HBM_STATUS(REJECTED);\n\tMEI_HBM_STATUS(INVALID_PARAMETER);\n\tMEI_HBM_STATUS(NOT_ALLOWED);\n\tMEI_HBM_STATUS(ALREADY_STARTED);\n\tMEI_HBM_STATUS(NOT_STARTED);\n\tdefault: return \"unknown\";\n\t}\n#undef MEI_HBM_STATUS\n};\n\nstatic const char *mei_cl_conn_status_str(enum mei_cl_connect_status status)\n{\n#define MEI_CL_CS(status) case MEI_CL_CONN_##status: return #status\n\tswitch (status) {\n\tMEI_CL_CS(SUCCESS);\n\tMEI_CL_CS(NOT_FOUND);\n\tMEI_CL_CS(ALREADY_STARTED);\n\tMEI_CL_CS(OUT_OF_RESOURCES);\n\tMEI_CL_CS(MESSAGE_SMALL);\n\tMEI_CL_CS(NOT_ALLOWED);\n\tdefault: return \"unknown\";\n\t}\n#undef MEI_CL_CCS\n}\n\nconst char *mei_hbm_state_str(enum mei_hbm_state state)\n{\n#define MEI_HBM_STATE(state) case MEI_HBM_##state: return #state\n\tswitch (state) {\n\tMEI_HBM_STATE(IDLE);\n\tMEI_HBM_STATE(STARTING);\n\tMEI_HBM_STATE(STARTED);\n\tMEI_HBM_STATE(DR_SETUP);\n\tMEI_HBM_STATE(ENUM_CLIENTS);\n\tMEI_HBM_STATE(CLIENT_PROPERTIES);\n\tMEI_HBM_STATE(STOPPED);\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n#undef MEI_HBM_STATE\n}\n\n \nstatic int mei_cl_conn_status_to_errno(enum mei_cl_connect_status status)\n{\n\tswitch (status) {\n\tcase MEI_CL_CONN_SUCCESS:          return 0;\n\tcase MEI_CL_CONN_NOT_FOUND:        return -ENOTTY;\n\tcase MEI_CL_CONN_ALREADY_STARTED:  return -EBUSY;\n\tcase MEI_CL_CONN_OUT_OF_RESOURCES: return -EBUSY;\n\tcase MEI_CL_CONN_MESSAGE_SMALL:    return -EINVAL;\n\tcase MEI_CL_CONN_NOT_ALLOWED:      return -EBUSY;\n\tdefault:                           return -EINVAL;\n\t}\n}\n\n \nstatic inline int mei_hbm_write_message(struct mei_device *dev,\n\t\t\t\t\tstruct mei_msg_hdr *hdr,\n\t\t\t\t\tconst void *data)\n{\n\treturn mei_write_message(dev, hdr, sizeof(*hdr), data, hdr->length);\n}\n\n \nvoid mei_hbm_idle(struct mei_device *dev)\n{\n\tdev->init_clients_timer = 0;\n\tdev->hbm_state = MEI_HBM_IDLE;\n}\n\n \nvoid mei_hbm_reset(struct mei_device *dev)\n{\n\tmei_me_cl_rm_all(dev);\n\n\tmei_hbm_idle(dev);\n}\n\n \n\nstatic inline void mei_hbm_hdr(struct mei_msg_hdr *mei_hdr, size_t length)\n{\n\tmemset(mei_hdr, 0, sizeof(*mei_hdr));\n\tmei_hdr->length = length;\n\tmei_hdr->msg_complete = 1;\n}\n\n \nstatic inline\nvoid mei_hbm_cl_hdr(struct mei_cl *cl, u8 hbm_cmd, void *buf, size_t len)\n{\n\tstruct mei_hbm_cl_cmd *cmd = buf;\n\n\tmemset(cmd, 0, len);\n\n\tcmd->hbm_cmd = hbm_cmd;\n\tcmd->host_addr = mei_cl_host_addr(cl);\n\tcmd->me_addr = mei_cl_me_id(cl);\n}\n\n \nstatic inline int mei_hbm_cl_write(struct mei_device *dev, struct mei_cl *cl,\n\t\t\t\t   u8 hbm_cmd, void *buf, size_t len)\n{\n\tstruct mei_msg_hdr mei_hdr;\n\n\tmei_hbm_hdr(&mei_hdr, len);\n\tmei_hbm_cl_hdr(cl, hbm_cmd, buf, len);\n\n\treturn mei_hbm_write_message(dev, &mei_hdr, buf);\n}\n\n \nstatic inline\nbool mei_hbm_cl_addr_equal(struct mei_cl *cl, struct mei_hbm_cl_cmd *cmd)\n{\n\treturn  mei_cl_host_addr(cl) == cmd->host_addr &&\n\t\tmei_cl_me_id(cl) == cmd->me_addr;\n}\n\n \nstatic inline\nstruct mei_cl *mei_hbm_cl_find_by_cmd(struct mei_device *dev, void *buf)\n{\n\tstruct mei_hbm_cl_cmd *cmd = (struct mei_hbm_cl_cmd *)buf;\n\tstruct mei_cl *cl;\n\n\tlist_for_each_entry(cl, &dev->file_list, link)\n\t\tif (mei_hbm_cl_addr_equal(cl, cmd))\n\t\t\treturn cl;\n\treturn NULL;\n}\n\n\n \nint mei_hbm_start_wait(struct mei_device *dev)\n{\n\tint ret;\n\n\tif (dev->hbm_state > MEI_HBM_STARTING)\n\t\treturn 0;\n\n\tmutex_unlock(&dev->device_lock);\n\tret = wait_event_timeout(dev->wait_hbm_start,\n\t\t\tdev->hbm_state != MEI_HBM_STARTING,\n\t\t\tdev->timeouts.hbm);\n\tmutex_lock(&dev->device_lock);\n\n\tif (ret == 0 && (dev->hbm_state <= MEI_HBM_STARTING)) {\n\t\tdev->hbm_state = MEI_HBM_IDLE;\n\t\tdev_err(dev->dev, \"waiting for mei start failed\\n\");\n\t\treturn -ETIME;\n\t}\n\treturn 0;\n}\n\n \nint mei_hbm_start_req(struct mei_device *dev)\n{\n\tstruct mei_msg_hdr mei_hdr;\n\tstruct hbm_host_version_request req;\n\tint ret;\n\n\tmei_hbm_reset(dev);\n\n\tmei_hbm_hdr(&mei_hdr, sizeof(req));\n\n\t \n\tmemset(&req, 0, sizeof(req));\n\treq.hbm_cmd = HOST_START_REQ_CMD;\n\treq.host_version.major_version = HBM_MAJOR_VERSION;\n\treq.host_version.minor_version = HBM_MINOR_VERSION;\n\n\tdev->hbm_state = MEI_HBM_IDLE;\n\tret = mei_hbm_write_message(dev, &mei_hdr, &req);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"version message write failed: ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tdev->hbm_state = MEI_HBM_STARTING;\n\tdev->init_clients_timer = dev->timeouts.client_init;\n\tmei_schedule_stall_timer(dev);\n\treturn 0;\n}\n\n \nstatic int mei_hbm_dma_setup_req(struct mei_device *dev)\n{\n\tstruct mei_msg_hdr mei_hdr;\n\tstruct hbm_dma_setup_request req;\n\tunsigned int i;\n\tint ret;\n\n\tmei_hbm_hdr(&mei_hdr, sizeof(req));\n\n\tmemset(&req, 0, sizeof(req));\n\treq.hbm_cmd = MEI_HBM_DMA_SETUP_REQ_CMD;\n\tfor (i = 0; i < DMA_DSCR_NUM; i++) {\n\t\tphys_addr_t paddr;\n\n\t\tpaddr = dev->dr_dscr[i].daddr;\n\t\treq.dma_dscr[i].addr_hi = upper_32_bits(paddr);\n\t\treq.dma_dscr[i].addr_lo = lower_32_bits(paddr);\n\t\treq.dma_dscr[i].size = dev->dr_dscr[i].size;\n\t}\n\n\tmei_dma_ring_reset(dev);\n\n\tret = mei_hbm_write_message(dev, &mei_hdr, &req);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"dma setup request write failed: ret = %d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tdev->hbm_state = MEI_HBM_DR_SETUP;\n\tdev->init_clients_timer = dev->timeouts.client_init;\n\tmei_schedule_stall_timer(dev);\n\treturn 0;\n}\n\n \nstatic int mei_hbm_capabilities_req(struct mei_device *dev)\n{\n\tstruct mei_msg_hdr mei_hdr;\n\tstruct hbm_capability_request req;\n\tint ret;\n\n\tmei_hbm_hdr(&mei_hdr, sizeof(req));\n\n\tmemset(&req, 0, sizeof(req));\n\treq.hbm_cmd = MEI_HBM_CAPABILITIES_REQ_CMD;\n\tif (dev->hbm_f_vt_supported)\n\t\treq.capability_requested[0] |= HBM_CAP_VT;\n\n\tif (dev->hbm_f_cd_supported)\n\t\treq.capability_requested[0] |= HBM_CAP_CD;\n\n\tif (dev->hbm_f_gsc_supported)\n\t\treq.capability_requested[0] |= HBM_CAP_GSC;\n\n\tret = mei_hbm_write_message(dev, &mei_hdr, &req);\n\tif (ret) {\n\t\tdev_err(dev->dev,\n\t\t\t\"capabilities request write failed: ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev->hbm_state = MEI_HBM_CAP_SETUP;\n\tdev->init_clients_timer = dev->timeouts.client_init;\n\tmei_schedule_stall_timer(dev);\n\treturn 0;\n}\n\n \nstatic int mei_hbm_enum_clients_req(struct mei_device *dev)\n{\n\tstruct mei_msg_hdr mei_hdr;\n\tstruct hbm_host_enum_request req;\n\tint ret;\n\n\t \n\tmei_hbm_hdr(&mei_hdr, sizeof(req));\n\n\tmemset(&req, 0, sizeof(req));\n\treq.hbm_cmd = HOST_ENUM_REQ_CMD;\n\treq.flags |= dev->hbm_f_dc_supported ? MEI_HBM_ENUM_F_ALLOW_ADD : 0;\n\treq.flags |= dev->hbm_f_ie_supported ?\n\t\t\t  MEI_HBM_ENUM_F_IMMEDIATE_ENUM : 0;\n\n\tret = mei_hbm_write_message(dev, &mei_hdr, &req);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"enumeration request write failed: ret = %d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tdev->hbm_state = MEI_HBM_ENUM_CLIENTS;\n\tdev->init_clients_timer = dev->timeouts.client_init;\n\tmei_schedule_stall_timer(dev);\n\treturn 0;\n}\n\n \n\nstatic int mei_hbm_me_cl_add(struct mei_device *dev,\n\t\t\t     struct hbm_props_response *res)\n{\n\tstruct mei_me_client *me_cl;\n\tconst uuid_le *uuid = &res->client_properties.protocol_name;\n\n\tmei_me_cl_rm_by_uuid(dev, uuid);\n\n\tme_cl = kzalloc(sizeof(*me_cl), GFP_KERNEL);\n\tif (!me_cl)\n\t\treturn -ENOMEM;\n\n\tmei_me_cl_init(me_cl);\n\n\tme_cl->props = res->client_properties;\n\tme_cl->client_id = res->me_addr;\n\tme_cl->tx_flow_ctrl_creds = 0;\n\n\tmei_me_cl_add(dev, me_cl);\n\n\treturn 0;\n}\n\n \nstatic int mei_hbm_add_cl_resp(struct mei_device *dev, u8 addr, u8 status)\n{\n\tstruct mei_msg_hdr mei_hdr;\n\tstruct hbm_add_client_response resp;\n\tint ret;\n\n\tdev_dbg(dev->dev, \"adding client response\\n\");\n\n\tmei_hbm_hdr(&mei_hdr, sizeof(resp));\n\n\tmemset(&resp, 0, sizeof(resp));\n\tresp.hbm_cmd = MEI_HBM_ADD_CLIENT_RES_CMD;\n\tresp.me_addr = addr;\n\tresp.status  = status;\n\n\tret = mei_hbm_write_message(dev, &mei_hdr, &resp);\n\tif (ret)\n\t\tdev_err(dev->dev, \"add client response write failed: ret = %d\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\n \nstatic int mei_hbm_fw_add_cl_req(struct mei_device *dev,\n\t\t\t      struct hbm_add_client_request *req)\n{\n\tint ret;\n\tu8 status = MEI_HBMS_SUCCESS;\n\n\tBUILD_BUG_ON(sizeof(struct hbm_add_client_request) !=\n\t\t\tsizeof(struct hbm_props_response));\n\n\tret = mei_hbm_me_cl_add(dev, (struct hbm_props_response *)req);\n\tif (ret)\n\t\tstatus = !MEI_HBMS_SUCCESS;\n\n\tif (dev->dev_state == MEI_DEV_ENABLED)\n\t\tschedule_work(&dev->bus_rescan_work);\n\n\treturn mei_hbm_add_cl_resp(dev, req->me_addr, status);\n}\n\n \nint mei_hbm_cl_notify_req(struct mei_device *dev,\n\t\t\t  struct mei_cl *cl, u8 start)\n{\n\n\tstruct mei_msg_hdr mei_hdr;\n\tstruct hbm_notification_request req;\n\tint ret;\n\n\tmei_hbm_hdr(&mei_hdr, sizeof(req));\n\tmei_hbm_cl_hdr(cl, MEI_HBM_NOTIFY_REQ_CMD, &req, sizeof(req));\n\n\treq.start = start;\n\n\tret = mei_hbm_write_message(dev, &mei_hdr, &req);\n\tif (ret)\n\t\tdev_err(dev->dev, \"notify request failed: ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic inline enum mei_cb_file_ops notify_res_to_fop(struct mei_hbm_cl_cmd *cmd)\n{\n\tstruct hbm_notification_response *rs =\n\t\t(struct hbm_notification_response *)cmd;\n\n\treturn mei_cl_notify_req2fop(rs->start);\n}\n\n \nstatic void mei_hbm_cl_notify_start_res(struct mei_device *dev,\n\t\t\t\t\tstruct mei_cl *cl,\n\t\t\t\t\tstruct mei_hbm_cl_cmd *cmd)\n{\n\tstruct hbm_notification_response *rs =\n\t\t(struct hbm_notification_response *)cmd;\n\n\tcl_dbg(dev, cl, \"hbm: notify start response status=%d\\n\", rs->status);\n\n\tif (rs->status == MEI_HBMS_SUCCESS ||\n\t    rs->status == MEI_HBMS_ALREADY_STARTED) {\n\t\tcl->notify_en = true;\n\t\tcl->status = 0;\n\t} else {\n\t\tcl->status = -EINVAL;\n\t}\n}\n\n \nstatic void mei_hbm_cl_notify_stop_res(struct mei_device *dev,\n\t\t\t\t       struct mei_cl *cl,\n\t\t\t\t       struct mei_hbm_cl_cmd *cmd)\n{\n\tstruct hbm_notification_response *rs =\n\t\t(struct hbm_notification_response *)cmd;\n\n\tcl_dbg(dev, cl, \"hbm: notify stop response status=%d\\n\", rs->status);\n\n\tif (rs->status == MEI_HBMS_SUCCESS ||\n\t    rs->status == MEI_HBMS_NOT_STARTED) {\n\t\tcl->notify_en = false;\n\t\tcl->status = 0;\n\t} else {\n\t\t \n\t\tcl->status = -EINVAL;\n\t}\n}\n\n \nstatic void mei_hbm_cl_notify(struct mei_device *dev,\n\t\t\t      struct mei_hbm_cl_cmd *cmd)\n{\n\tstruct mei_cl *cl;\n\n\tcl = mei_hbm_cl_find_by_cmd(dev, cmd);\n\tif (cl)\n\t\tmei_cl_notify(cl);\n}\n\n \nint mei_hbm_cl_dma_map_req(struct mei_device *dev, struct mei_cl *cl)\n{\n\tstruct mei_msg_hdr mei_hdr;\n\tstruct hbm_client_dma_map_request req;\n\tint ret;\n\n\tmei_hbm_hdr(&mei_hdr, sizeof(req));\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.hbm_cmd = MEI_HBM_CLIENT_DMA_MAP_REQ_CMD;\n\treq.client_buffer_id = cl->dma.buffer_id;\n\treq.address_lsb = lower_32_bits(cl->dma.daddr);\n\treq.address_msb = upper_32_bits(cl->dma.daddr);\n\treq.size = cl->dma.size;\n\n\tret = mei_hbm_write_message(dev, &mei_hdr, &req);\n\tif (ret)\n\t\tdev_err(dev->dev, \"dma map request failed: ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nint mei_hbm_cl_dma_unmap_req(struct mei_device *dev, struct mei_cl *cl)\n{\n\tstruct mei_msg_hdr mei_hdr;\n\tstruct hbm_client_dma_unmap_request req;\n\tint ret;\n\n\tmei_hbm_hdr(&mei_hdr, sizeof(req));\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.hbm_cmd = MEI_HBM_CLIENT_DMA_UNMAP_REQ_CMD;\n\treq.client_buffer_id = cl->dma.buffer_id;\n\n\tret = mei_hbm_write_message(dev, &mei_hdr, &req);\n\tif (ret)\n\t\tdev_err(dev->dev, \"dma unmap request failed: ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void mei_hbm_cl_dma_map_res(struct mei_device *dev,\n\t\t\t\t   struct hbm_client_dma_response *res)\n{\n\tstruct mei_cl *cl;\n\tstruct mei_cl_cb *cb, *next;\n\n\tcl = NULL;\n\tlist_for_each_entry_safe(cb, next, &dev->ctrl_rd_list, list) {\n\t\tif (cb->fop_type != MEI_FOP_DMA_MAP)\n\t\t\tcontinue;\n\t\tif (!cb->cl->dma.buffer_id || cb->cl->dma_mapped)\n\t\t\tcontinue;\n\n\t\tcl = cb->cl;\n\t\tbreak;\n\t}\n\tif (!cl)\n\t\treturn;\n\n\tif (res->status) {\n\t\tdev_err(dev->dev, \"cl dma map failed %d\\n\", res->status);\n\t\tcl->status = -EFAULT;\n\t} else {\n\t\tdev_dbg(dev->dev, \"cl dma map succeeded\\n\");\n\t\tcl->dma_mapped = 1;\n\t\tcl->status = 0;\n\t}\n\twake_up(&cl->wait);\n}\n\nstatic void mei_hbm_cl_dma_unmap_res(struct mei_device *dev,\n\t\t\t\t     struct hbm_client_dma_response *res)\n{\n\tstruct mei_cl *cl;\n\tstruct mei_cl_cb *cb, *next;\n\n\tcl = NULL;\n\tlist_for_each_entry_safe(cb, next, &dev->ctrl_rd_list, list) {\n\t\tif (cb->fop_type != MEI_FOP_DMA_UNMAP)\n\t\t\tcontinue;\n\t\tif (!cb->cl->dma.buffer_id || !cb->cl->dma_mapped)\n\t\t\tcontinue;\n\n\t\tcl = cb->cl;\n\t\tbreak;\n\t}\n\tif (!cl)\n\t\treturn;\n\n\tif (res->status) {\n\t\tdev_err(dev->dev, \"cl dma unmap failed %d\\n\", res->status);\n\t\tcl->status = -EFAULT;\n\t} else {\n\t\tdev_dbg(dev->dev, \"cl dma unmap succeeded\\n\");\n\t\tcl->dma_mapped = 0;\n\t\tcl->status = 0;\n\t}\n\twake_up(&cl->wait);\n}\n\n \nstatic int mei_hbm_prop_req(struct mei_device *dev, unsigned long start_idx)\n{\n\tstruct mei_msg_hdr mei_hdr;\n\tstruct hbm_props_request req;\n\tunsigned long addr;\n\tint ret;\n\n\taddr = find_next_bit(dev->me_clients_map, MEI_CLIENTS_MAX, start_idx);\n\n\t \n\tif (addr == MEI_CLIENTS_MAX) {\n\t\tdev->hbm_state = MEI_HBM_STARTED;\n\t\tmei_host_client_init(dev);\n\t\treturn 0;\n\t}\n\n\tmei_hbm_hdr(&mei_hdr, sizeof(req));\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.hbm_cmd = HOST_CLIENT_PROPERTIES_REQ_CMD;\n\treq.me_addr = addr;\n\n\tret = mei_hbm_write_message(dev, &mei_hdr, &req);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"properties request write failed: ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tdev->init_clients_timer = dev->timeouts.client_init;\n\tmei_schedule_stall_timer(dev);\n\n\treturn 0;\n}\n\n \nint mei_hbm_pg(struct mei_device *dev, u8 pg_cmd)\n{\n\tstruct mei_msg_hdr mei_hdr;\n\tstruct hbm_power_gate req;\n\tint ret;\n\n\tif (!dev->hbm_f_pg_supported)\n\t\treturn -EOPNOTSUPP;\n\n\tmei_hbm_hdr(&mei_hdr, sizeof(req));\n\n\tmemset(&req, 0, sizeof(req));\n\treq.hbm_cmd = pg_cmd;\n\n\tret = mei_hbm_write_message(dev, &mei_hdr, &req);\n\tif (ret)\n\t\tdev_err(dev->dev, \"power gate command write failed.\\n\");\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mei_hbm_pg);\n\n \nstatic int mei_hbm_stop_req(struct mei_device *dev)\n{\n\tstruct mei_msg_hdr mei_hdr;\n\tstruct hbm_host_stop_request req;\n\n\tmei_hbm_hdr(&mei_hdr, sizeof(req));\n\n\tmemset(&req, 0, sizeof(req));\n\treq.hbm_cmd = HOST_STOP_REQ_CMD;\n\treq.reason = DRIVER_STOP_REQUEST;\n\n\treturn mei_hbm_write_message(dev, &mei_hdr, &req);\n}\n\n \nint mei_hbm_cl_flow_control_req(struct mei_device *dev, struct mei_cl *cl)\n{\n\tstruct hbm_flow_control req;\n\n\tcl_dbg(dev, cl, \"sending flow control\\n\");\n\treturn mei_hbm_cl_write(dev, cl, MEI_FLOW_CONTROL_CMD,\n\t\t\t\t&req, sizeof(req));\n}\n\n \nstatic int mei_hbm_add_single_tx_flow_ctrl_creds(struct mei_device *dev,\n\t\t\t\t\t\t struct hbm_flow_control *fctrl)\n{\n\tstruct mei_me_client *me_cl;\n\tint rets;\n\n\tme_cl = mei_me_cl_by_id(dev, fctrl->me_addr);\n\tif (!me_cl) {\n\t\tdev_err(dev->dev, \"no such me client %d\\n\", fctrl->me_addr);\n\t\treturn -ENOENT;\n\t}\n\n\tif (WARN_ON(me_cl->props.single_recv_buf == 0)) {\n\t\trets = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tme_cl->tx_flow_ctrl_creds++;\n\tdev_dbg(dev->dev, \"recv flow ctrl msg ME %d (single) creds = %d.\\n\",\n\t\tfctrl->me_addr, me_cl->tx_flow_ctrl_creds);\n\n\trets = 0;\nout:\n\tmei_me_cl_put(me_cl);\n\treturn rets;\n}\n\n \nstatic void mei_hbm_cl_tx_flow_ctrl_creds_res(struct mei_device *dev,\n\t\t\t\t\t       struct hbm_flow_control *fctrl)\n{\n\tstruct mei_cl *cl;\n\n\tif (!fctrl->host_addr) {\n\t\t \n\t\tmei_hbm_add_single_tx_flow_ctrl_creds(dev, fctrl);\n\t\treturn;\n\t}\n\n\tcl = mei_hbm_cl_find_by_cmd(dev, fctrl);\n\tif (cl) {\n\t\tcl->tx_flow_ctrl_creds++;\n\t\tcl_dbg(dev, cl, \"flow control creds = %d.\\n\",\n\t\t\t\tcl->tx_flow_ctrl_creds);\n\t}\n}\n\n\n \nint mei_hbm_cl_disconnect_req(struct mei_device *dev, struct mei_cl *cl)\n{\n\tstruct hbm_client_connect_request req;\n\n\treturn mei_hbm_cl_write(dev, cl, CLIENT_DISCONNECT_REQ_CMD,\n\t\t\t\t&req, sizeof(req));\n}\n\n \nint mei_hbm_cl_disconnect_rsp(struct mei_device *dev, struct mei_cl *cl)\n{\n\tstruct hbm_client_connect_response resp;\n\n\treturn mei_hbm_cl_write(dev, cl, CLIENT_DISCONNECT_RES_CMD,\n\t\t\t\t&resp, sizeof(resp));\n}\n\n \nstatic void mei_hbm_cl_disconnect_res(struct mei_device *dev, struct mei_cl *cl,\n\t\t\t\t      struct mei_hbm_cl_cmd *cmd)\n{\n\tstruct hbm_client_connect_response *rs =\n\t\t(struct hbm_client_connect_response *)cmd;\n\n\tcl_dbg(dev, cl, \"hbm: disconnect response status=%d\\n\", rs->status);\n\n\tif (rs->status == MEI_CL_DISCONN_SUCCESS)\n\t\tcl->state = MEI_FILE_DISCONNECT_REPLY;\n\tcl->status = 0;\n}\n\n \nint mei_hbm_cl_connect_req(struct mei_device *dev, struct mei_cl *cl)\n{\n\tstruct hbm_client_connect_request req;\n\n\treturn mei_hbm_cl_write(dev, cl, CLIENT_CONNECT_REQ_CMD,\n\t\t\t\t&req, sizeof(req));\n}\n\n \nstatic void mei_hbm_cl_connect_res(struct mei_device *dev, struct mei_cl *cl,\n\t\t\t\t   struct mei_hbm_cl_cmd *cmd)\n{\n\tstruct hbm_client_connect_response *rs =\n\t\t(struct hbm_client_connect_response *)cmd;\n\n\tcl_dbg(dev, cl, \"hbm: connect response status=%s\\n\",\n\t\t\tmei_cl_conn_status_str(rs->status));\n\n\tif (rs->status == MEI_CL_CONN_SUCCESS)\n\t\tcl->state = MEI_FILE_CONNECTED;\n\telse {\n\t\tcl->state = MEI_FILE_DISCONNECT_REPLY;\n\t\tif (rs->status == MEI_CL_CONN_NOT_FOUND) {\n\t\t\tmei_me_cl_del(dev, cl->me_cl);\n\t\t\tif (dev->dev_state == MEI_DEV_ENABLED)\n\t\t\t\tschedule_work(&dev->bus_rescan_work);\n\t\t}\n\t}\n\tcl->status = mei_cl_conn_status_to_errno(rs->status);\n}\n\n \nstatic void mei_hbm_cl_res(struct mei_device *dev,\n\t\t\t   struct mei_hbm_cl_cmd *rs,\n\t\t\t   enum mei_cb_file_ops fop_type)\n{\n\tstruct mei_cl *cl;\n\tstruct mei_cl_cb *cb, *next;\n\n\tcl = NULL;\n\tlist_for_each_entry_safe(cb, next, &dev->ctrl_rd_list, list) {\n\n\t\tcl = cb->cl;\n\n\t\tif (cb->fop_type != fop_type)\n\t\t\tcontinue;\n\n\t\tif (mei_hbm_cl_addr_equal(cl, rs)) {\n\t\t\tlist_del_init(&cb->list);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!cl)\n\t\treturn;\n\n\tswitch (fop_type) {\n\tcase MEI_FOP_CONNECT:\n\t\tmei_hbm_cl_connect_res(dev, cl, rs);\n\t\tbreak;\n\tcase MEI_FOP_DISCONNECT:\n\t\tmei_hbm_cl_disconnect_res(dev, cl, rs);\n\t\tbreak;\n\tcase MEI_FOP_NOTIFY_START:\n\t\tmei_hbm_cl_notify_start_res(dev, cl, rs);\n\t\tbreak;\n\tcase MEI_FOP_NOTIFY_STOP:\n\t\tmei_hbm_cl_notify_stop_res(dev, cl, rs);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tcl->timer_count = 0;\n\twake_up(&cl->wait);\n}\n\n\n \nstatic int mei_hbm_fw_disconnect_req(struct mei_device *dev,\n\t\tstruct hbm_client_connect_request *disconnect_req)\n{\n\tstruct mei_cl *cl;\n\tstruct mei_cl_cb *cb;\n\n\tcl = mei_hbm_cl_find_by_cmd(dev, disconnect_req);\n\tif (cl) {\n\t\tcl_warn(dev, cl, \"fw disconnect request received\\n\");\n\t\tcl->state = MEI_FILE_DISCONNECTING;\n\t\tcl->timer_count = 0;\n\n\t\tcb = mei_cl_enqueue_ctrl_wr_cb(cl, 0, MEI_FOP_DISCONNECT_RSP,\n\t\t\t\t\t       NULL);\n\t\tif (!cb)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nstatic int mei_hbm_pg_enter_res(struct mei_device *dev)\n{\n\tif (mei_pg_state(dev) != MEI_PG_OFF ||\n\t    dev->pg_event != MEI_PG_EVENT_WAIT) {\n\t\tdev_err(dev->dev, \"hbm: pg entry response: state mismatch [%s, %d]\\n\",\n\t\t\tmei_pg_state_str(mei_pg_state(dev)), dev->pg_event);\n\t\treturn -EPROTO;\n\t}\n\n\tdev->pg_event = MEI_PG_EVENT_RECEIVED;\n\twake_up(&dev->wait_pg);\n\n\treturn 0;\n}\n\n \nvoid mei_hbm_pg_resume(struct mei_device *dev)\n{\n\tpm_request_resume(dev->dev);\n}\nEXPORT_SYMBOL_GPL(mei_hbm_pg_resume);\n\n \nstatic int mei_hbm_pg_exit_res(struct mei_device *dev)\n{\n\tif (mei_pg_state(dev) != MEI_PG_ON ||\n\t    (dev->pg_event != MEI_PG_EVENT_WAIT &&\n\t     dev->pg_event != MEI_PG_EVENT_IDLE)) {\n\t\tdev_err(dev->dev, \"hbm: pg exit response: state mismatch [%s, %d]\\n\",\n\t\t\tmei_pg_state_str(mei_pg_state(dev)), dev->pg_event);\n\t\treturn -EPROTO;\n\t}\n\n\tswitch (dev->pg_event) {\n\tcase MEI_PG_EVENT_WAIT:\n\t\tdev->pg_event = MEI_PG_EVENT_RECEIVED;\n\t\twake_up(&dev->wait_pg);\n\t\tbreak;\n\tcase MEI_PG_EVENT_IDLE:\n\t\t \n\t\tdev->pg_event = MEI_PG_EVENT_RECEIVED;\n\t\tmei_hbm_pg_resume(dev);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"hbm: pg exit response: unexpected pg event = %d\\n\",\n\t\t     dev->pg_event);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void mei_hbm_config_features(struct mei_device *dev)\n{\n\t \n\tdev->hbm_f_pg_supported = 0;\n\tif (dev->version.major_version > HBM_MAJOR_VERSION_PGI)\n\t\tdev->hbm_f_pg_supported = 1;\n\n\tif (dev->version.major_version == HBM_MAJOR_VERSION_PGI &&\n\t    dev->version.minor_version >= HBM_MINOR_VERSION_PGI)\n\t\tdev->hbm_f_pg_supported = 1;\n\n\tdev->hbm_f_dc_supported = 0;\n\tif (dev->version.major_version >= HBM_MAJOR_VERSION_DC)\n\t\tdev->hbm_f_dc_supported = 1;\n\n\tdev->hbm_f_ie_supported = 0;\n\tif (dev->version.major_version >= HBM_MAJOR_VERSION_IE)\n\t\tdev->hbm_f_ie_supported = 1;\n\n\t \n\tdev->hbm_f_dot_supported = 0;\n\tif (dev->version.major_version >= HBM_MAJOR_VERSION_DOT)\n\t\tdev->hbm_f_dot_supported = 1;\n\n\t \n\tdev->hbm_f_ev_supported = 0;\n\tif (dev->version.major_version >= HBM_MAJOR_VERSION_EV)\n\t\tdev->hbm_f_ev_supported = 1;\n\n\t \n\tdev->hbm_f_fa_supported = 0;\n\tif (dev->version.major_version >= HBM_MAJOR_VERSION_FA)\n\t\tdev->hbm_f_fa_supported = 1;\n\n\t \n\tdev->hbm_f_os_supported = 0;\n\tif (dev->version.major_version >= HBM_MAJOR_VERSION_OS)\n\t\tdev->hbm_f_os_supported = 1;\n\n\t \n\tdev->hbm_f_dr_supported = 0;\n\tif (dev->version.major_version > HBM_MAJOR_VERSION_DR ||\n\t    (dev->version.major_version == HBM_MAJOR_VERSION_DR &&\n\t     dev->version.minor_version >= HBM_MINOR_VERSION_DR))\n\t\tdev->hbm_f_dr_supported = 1;\n\n\t \n\tdev->hbm_f_vt_supported = 0;\n\tif (dev->version.major_version > HBM_MAJOR_VERSION_VT ||\n\t    (dev->version.major_version == HBM_MAJOR_VERSION_VT &&\n\t     dev->version.minor_version >= HBM_MINOR_VERSION_VT))\n\t\tdev->hbm_f_vt_supported = 1;\n\n\t \n\tif (dev->version.major_version > HBM_MAJOR_VERSION_GSC ||\n\t    (dev->version.major_version == HBM_MAJOR_VERSION_GSC &&\n\t     dev->version.minor_version >= HBM_MINOR_VERSION_GSC))\n\t\tdev->hbm_f_gsc_supported = 1;\n\n\t \n\tdev->hbm_f_cap_supported = 0;\n\tif (dev->version.major_version > HBM_MAJOR_VERSION_CAP ||\n\t    (dev->version.major_version == HBM_MAJOR_VERSION_CAP &&\n\t     dev->version.minor_version >= HBM_MINOR_VERSION_CAP))\n\t\tdev->hbm_f_cap_supported = 1;\n\n\t \n\tdev->hbm_f_cd_supported = 0;\n\tif (dev->version.major_version > HBM_MAJOR_VERSION_CD ||\n\t    (dev->version.major_version == HBM_MAJOR_VERSION_CD &&\n\t     dev->version.minor_version >= HBM_MINOR_VERSION_CD))\n\t\tdev->hbm_f_cd_supported = 1;\n}\n\n \nbool mei_hbm_version_is_supported(struct mei_device *dev)\n{\n\treturn\t(dev->version.major_version < HBM_MAJOR_VERSION) ||\n\t\t(dev->version.major_version == HBM_MAJOR_VERSION &&\n\t\t dev->version.minor_version <= HBM_MINOR_VERSION);\n}\n\n \nint mei_hbm_dispatch(struct mei_device *dev, struct mei_msg_hdr *hdr)\n{\n\tstruct mei_bus_message *mei_msg;\n\tstruct hbm_host_version_response *version_res;\n\tstruct hbm_props_response *props_res;\n\tstruct hbm_host_enum_response *enum_res;\n\tstruct hbm_dma_setup_response *dma_setup_res;\n\tstruct hbm_add_client_request *add_cl_req;\n\tstruct hbm_capability_response *capability_res;\n\tint ret;\n\n\tstruct mei_hbm_cl_cmd *cl_cmd;\n\tstruct hbm_client_connect_request *disconnect_req;\n\tstruct hbm_flow_control *fctrl;\n\tstruct hbm_client_dma_response *client_dma_res;\n\n\t \n\tBUG_ON(hdr->length >= sizeof(dev->rd_msg_buf));\n\tmei_read_slots(dev, dev->rd_msg_buf, hdr->length);\n\tmei_msg = (struct mei_bus_message *)dev->rd_msg_buf;\n\tcl_cmd  = (struct mei_hbm_cl_cmd *)mei_msg;\n\n\t \n\tif (dev->hbm_state == MEI_HBM_IDLE) {\n\t\tdev_dbg(dev->dev, \"hbm: state is idle ignore spurious messages\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (mei_msg->hbm_cmd) {\n\tcase HOST_START_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: start: response message received.\\n\");\n\n\t\tdev->init_clients_timer = 0;\n\n\t\tversion_res = (struct hbm_host_version_response *)mei_msg;\n\n\t\tdev_dbg(dev->dev, \"HBM VERSION: DRIVER=%02d:%02d DEVICE=%02d:%02d\\n\",\n\t\t\t\tHBM_MAJOR_VERSION, HBM_MINOR_VERSION,\n\t\t\t\tversion_res->me_max_version.major_version,\n\t\t\t\tversion_res->me_max_version.minor_version);\n\n\t\tif (version_res->host_version_supported) {\n\t\t\tdev->version.major_version = HBM_MAJOR_VERSION;\n\t\t\tdev->version.minor_version = HBM_MINOR_VERSION;\n\t\t} else {\n\t\t\tdev->version.major_version =\n\t\t\t\tversion_res->me_max_version.major_version;\n\t\t\tdev->version.minor_version =\n\t\t\t\tversion_res->me_max_version.minor_version;\n\t\t}\n\n\t\tif (!mei_hbm_version_is_supported(dev)) {\n\t\t\tdev_warn(dev->dev, \"hbm: start: version mismatch - stopping the driver.\\n\");\n\n\t\t\tdev->hbm_state = MEI_HBM_STOPPED;\n\t\t\tif (mei_hbm_stop_req(dev)) {\n\t\t\t\tdev_err(dev->dev, \"hbm: start: failed to send stop request\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tmei_hbm_config_features(dev);\n\n\t\tif (dev->dev_state != MEI_DEV_INIT_CLIENTS ||\n\t\t    dev->hbm_state != MEI_HBM_STARTING) {\n\t\t\tif (dev->dev_state == MEI_DEV_POWER_DOWN ||\n\t\t\t    dev->dev_state == MEI_DEV_POWERING_DOWN) {\n\t\t\t\tdev_dbg(dev->dev, \"hbm: start: on shutdown, ignoring\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdev_err(dev->dev, \"hbm: start: state mismatch, [%d, %d]\\n\",\n\t\t\t\tdev->dev_state, dev->hbm_state);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tif (dev->hbm_f_cap_supported) {\n\t\t\tif (mei_hbm_capabilities_req(dev))\n\t\t\t\treturn -EIO;\n\t\t\twake_up(&dev->wait_hbm_start);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dev->hbm_f_dr_supported) {\n\t\t\tif (mei_dmam_ring_alloc(dev))\n\t\t\t\tdev_info(dev->dev, \"running w/o dma ring\\n\");\n\t\t\tif (mei_dma_ring_is_allocated(dev)) {\n\t\t\t\tif (mei_hbm_dma_setup_req(dev))\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\twake_up(&dev->wait_hbm_start);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdev->hbm_f_dr_supported = 0;\n\t\tmei_dmam_ring_free(dev);\n\n\t\tif (mei_hbm_enum_clients_req(dev))\n\t\t\treturn -EIO;\n\n\t\twake_up(&dev->wait_hbm_start);\n\t\tbreak;\n\n\tcase MEI_HBM_CAPABILITIES_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: capabilities response: message received.\\n\");\n\n\t\tdev->init_clients_timer = 0;\n\n\t\tif (dev->dev_state != MEI_DEV_INIT_CLIENTS ||\n\t\t    dev->hbm_state != MEI_HBM_CAP_SETUP) {\n\t\t\tif (dev->dev_state == MEI_DEV_POWER_DOWN ||\n\t\t\t    dev->dev_state == MEI_DEV_POWERING_DOWN) {\n\t\t\t\tdev_dbg(dev->dev, \"hbm: capabilities response: on shutdown, ignoring\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdev_err(dev->dev, \"hbm: capabilities response: state mismatch, [%d, %d]\\n\",\n\t\t\t\tdev->dev_state, dev->hbm_state);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tcapability_res = (struct hbm_capability_response *)mei_msg;\n\t\tif (!(capability_res->capability_granted[0] & HBM_CAP_VT))\n\t\t\tdev->hbm_f_vt_supported = 0;\n\t\tif (!(capability_res->capability_granted[0] & HBM_CAP_CD))\n\t\t\tdev->hbm_f_cd_supported = 0;\n\n\t\tif (!(capability_res->capability_granted[0] & HBM_CAP_GSC))\n\t\t\tdev->hbm_f_gsc_supported = 0;\n\n\t\tif (dev->hbm_f_dr_supported) {\n\t\t\tif (mei_dmam_ring_alloc(dev))\n\t\t\t\tdev_info(dev->dev, \"running w/o dma ring\\n\");\n\t\t\tif (mei_dma_ring_is_allocated(dev)) {\n\t\t\t\tif (mei_hbm_dma_setup_req(dev))\n\t\t\t\t\treturn -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdev->hbm_f_dr_supported = 0;\n\t\tmei_dmam_ring_free(dev);\n\n\t\tif (mei_hbm_enum_clients_req(dev))\n\t\t\treturn -EIO;\n\t\tbreak;\n\n\tcase MEI_HBM_DMA_SETUP_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: dma setup response: message received.\\n\");\n\n\t\tdev->init_clients_timer = 0;\n\n\t\tif (dev->dev_state != MEI_DEV_INIT_CLIENTS ||\n\t\t    dev->hbm_state != MEI_HBM_DR_SETUP) {\n\t\t\tif (dev->dev_state == MEI_DEV_POWER_DOWN ||\n\t\t\t    dev->dev_state == MEI_DEV_POWERING_DOWN) {\n\t\t\t\tdev_dbg(dev->dev, \"hbm: dma setup response: on shutdown, ignoring\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdev_err(dev->dev, \"hbm: dma setup response: state mismatch, [%d, %d]\\n\",\n\t\t\t\tdev->dev_state, dev->hbm_state);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tdma_setup_res = (struct hbm_dma_setup_response *)mei_msg;\n\n\t\tif (dma_setup_res->status) {\n\t\t\tu8 status = dma_setup_res->status;\n\n\t\t\tif (status == MEI_HBMS_NOT_ALLOWED) {\n\t\t\t\tdev_dbg(dev->dev, \"hbm: dma setup not allowed\\n\");\n\t\t\t} else {\n\t\t\t\tdev_info(dev->dev, \"hbm: dma setup response: failure = %d %s\\n\",\n\t\t\t\t\t status,\n\t\t\t\t\t mei_hbm_status_str(status));\n\t\t\t}\n\t\t\tdev->hbm_f_dr_supported = 0;\n\t\t\tmei_dmam_ring_free(dev);\n\t\t}\n\n\t\tif (mei_hbm_enum_clients_req(dev))\n\t\t\treturn -EIO;\n\t\tbreak;\n\n\tcase CLIENT_CONNECT_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: client connect response: message received.\\n\");\n\t\tmei_hbm_cl_res(dev, cl_cmd, MEI_FOP_CONNECT);\n\t\tbreak;\n\n\tcase CLIENT_DISCONNECT_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: client disconnect response: message received.\\n\");\n\t\tmei_hbm_cl_res(dev, cl_cmd, MEI_FOP_DISCONNECT);\n\t\tbreak;\n\n\tcase MEI_FLOW_CONTROL_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: client flow control response: message received.\\n\");\n\n\t\tfctrl = (struct hbm_flow_control *)mei_msg;\n\t\tmei_hbm_cl_tx_flow_ctrl_creds_res(dev, fctrl);\n\t\tbreak;\n\n\tcase MEI_PG_ISOLATION_ENTRY_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: power gate isolation entry response received\\n\");\n\t\tret = mei_hbm_pg_enter_res(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase MEI_PG_ISOLATION_EXIT_REQ_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: power gate isolation exit request received\\n\");\n\t\tret = mei_hbm_pg_exit_res(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase HOST_CLIENT_PROPERTIES_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: properties response: message received.\\n\");\n\n\t\tdev->init_clients_timer = 0;\n\n\t\tif (dev->dev_state != MEI_DEV_INIT_CLIENTS ||\n\t\t    dev->hbm_state != MEI_HBM_CLIENT_PROPERTIES) {\n\t\t\tif (dev->dev_state == MEI_DEV_POWER_DOWN ||\n\t\t\t    dev->dev_state == MEI_DEV_POWERING_DOWN) {\n\t\t\t\tdev_dbg(dev->dev, \"hbm: properties response: on shutdown, ignoring\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdev_err(dev->dev, \"hbm: properties response: state mismatch, [%d, %d]\\n\",\n\t\t\t\tdev->dev_state, dev->hbm_state);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tprops_res = (struct hbm_props_response *)mei_msg;\n\n\t\tif (props_res->status == MEI_HBMS_CLIENT_NOT_FOUND) {\n\t\t\tdev_dbg(dev->dev, \"hbm: properties response: %d CLIENT_NOT_FOUND\\n\",\n\t\t\t\tprops_res->me_addr);\n\t\t} else if (props_res->status) {\n\t\t\tdev_err(dev->dev, \"hbm: properties response: wrong status = %d %s\\n\",\n\t\t\t\tprops_res->status,\n\t\t\t\tmei_hbm_status_str(props_res->status));\n\t\t\treturn -EPROTO;\n\t\t} else {\n\t\t\tmei_hbm_me_cl_add(dev, props_res);\n\t\t}\n\n\t\t \n\t\tif (mei_hbm_prop_req(dev, props_res->me_addr + 1))\n\t\t\treturn -EIO;\n\n\t\tbreak;\n\n\tcase HOST_ENUM_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: enumeration response: message received\\n\");\n\n\t\tdev->init_clients_timer = 0;\n\n\t\tenum_res = (struct hbm_host_enum_response *) mei_msg;\n\t\tBUILD_BUG_ON(sizeof(dev->me_clients_map)\n\t\t\t\t< sizeof(enum_res->valid_addresses));\n\t\tmemcpy(dev->me_clients_map, enum_res->valid_addresses,\n\t\t\t\tsizeof(enum_res->valid_addresses));\n\n\t\tif (dev->dev_state != MEI_DEV_INIT_CLIENTS ||\n\t\t    dev->hbm_state != MEI_HBM_ENUM_CLIENTS) {\n\t\t\tif (dev->dev_state == MEI_DEV_POWER_DOWN ||\n\t\t\t    dev->dev_state == MEI_DEV_POWERING_DOWN) {\n\t\t\t\tdev_dbg(dev->dev, \"hbm: enumeration response: on shutdown, ignoring\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdev_err(dev->dev, \"hbm: enumeration response: state mismatch, [%d, %d]\\n\",\n\t\t\t\tdev->dev_state, dev->hbm_state);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tdev->hbm_state = MEI_HBM_CLIENT_PROPERTIES;\n\n\t\t \n\t\tif (mei_hbm_prop_req(dev, 0))\n\t\t\treturn -EIO;\n\n\t\tbreak;\n\n\tcase HOST_STOP_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: stop response: message received\\n\");\n\n\t\tdev->init_clients_timer = 0;\n\n\t\tif (dev->hbm_state != MEI_HBM_STOPPED) {\n\t\t\tdev_err(dev->dev, \"hbm: stop response: state mismatch, [%d, %d]\\n\",\n\t\t\t\tdev->dev_state, dev->hbm_state);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tmei_set_devstate(dev, MEI_DEV_POWER_DOWN);\n\t\tdev_info(dev->dev, \"hbm: stop response: resetting.\\n\");\n\t\t \n\t\treturn -EPROTO;\n\n\tcase CLIENT_DISCONNECT_REQ_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: disconnect request: message received\\n\");\n\n\t\tdisconnect_req = (struct hbm_client_connect_request *)mei_msg;\n\t\tmei_hbm_fw_disconnect_req(dev, disconnect_req);\n\t\tbreak;\n\n\tcase ME_STOP_REQ_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: stop request: message received\\n\");\n\t\tdev->hbm_state = MEI_HBM_STOPPED;\n\t\tif (mei_hbm_stop_req(dev)) {\n\t\t\tdev_err(dev->dev, \"hbm: stop request: failed to send stop request\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\tcase MEI_HBM_ADD_CLIENT_REQ_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: add client request received\\n\");\n\t\t \n\t\tif (dev->hbm_state <= MEI_HBM_ENUM_CLIENTS ||\n\t\t    dev->hbm_state >= MEI_HBM_STOPPED) {\n\t\t\tdev_err(dev->dev, \"hbm: add client: state mismatch, [%d, %d]\\n\",\n\t\t\t\tdev->dev_state, dev->hbm_state);\n\t\t\treturn -EPROTO;\n\t\t}\n\t\tadd_cl_req = (struct hbm_add_client_request *)mei_msg;\n\t\tret = mei_hbm_fw_add_cl_req(dev, add_cl_req);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev, \"hbm: add client: failed to send response %d\\n\",\n\t\t\t\tret);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdev_dbg(dev->dev, \"hbm: add client request processed\\n\");\n\t\tbreak;\n\n\tcase MEI_HBM_NOTIFY_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: notify response received\\n\");\n\t\tmei_hbm_cl_res(dev, cl_cmd, notify_res_to_fop(cl_cmd));\n\t\tbreak;\n\n\tcase MEI_HBM_NOTIFICATION_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: notification\\n\");\n\t\tmei_hbm_cl_notify(dev, cl_cmd);\n\t\tbreak;\n\n\tcase MEI_HBM_CLIENT_DMA_MAP_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: client dma map response: message received.\\n\");\n\t\tclient_dma_res = (struct hbm_client_dma_response *)mei_msg;\n\t\tmei_hbm_cl_dma_map_res(dev, client_dma_res);\n\t\tbreak;\n\n\tcase MEI_HBM_CLIENT_DMA_UNMAP_RES_CMD:\n\t\tdev_dbg(dev->dev, \"hbm: client dma unmap response: message received.\\n\");\n\t\tclient_dma_res = (struct hbm_client_dma_response *)mei_msg;\n\t\tmei_hbm_cl_dma_unmap_res(dev, client_dma_res);\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"hbm: wrong command %d\\n\", mei_msg->hbm_cmd);\n\t\treturn -EPROTO;\n\n\t}\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}