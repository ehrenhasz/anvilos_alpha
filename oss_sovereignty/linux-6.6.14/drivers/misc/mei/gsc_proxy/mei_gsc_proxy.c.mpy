{
  "module_name": "mei_gsc_proxy.c",
  "hash_id": "c0c109a1d4094e99c7a41548c8b27205c4d7a6d648ecd4602f5d6554d8e203d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/gsc_proxy/mei_gsc_proxy.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/component.h>\n#include <linux/mei_cl_bus.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <drm/drm_connector.h>\n#include <drm/i915_component.h>\n#include <drm/i915_gsc_proxy_mei_interface.h>\n\n \nstatic int mei_gsc_proxy_send(struct device *dev, const void *buf, size_t size)\n{\n\tssize_t ret;\n\n\tif (!dev || !buf)\n\t\treturn -EINVAL;\n\n\tret = mei_cldev_send(to_mei_cl_device(dev), buf, size);\n\tif (ret < 0)\n\t\tdev_dbg(dev, \"mei_cldev_send failed. %zd\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int mei_gsc_proxy_recv(struct device *dev, void *buf, size_t size)\n{\n\tssize_t ret;\n\n\tif (!dev || !buf)\n\t\treturn -EINVAL;\n\n\tret = mei_cldev_recv(to_mei_cl_device(dev), buf, size);\n\tif (ret < 0)\n\t\tdev_dbg(dev, \"mei_cldev_recv failed. %zd\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct i915_gsc_proxy_component_ops mei_gsc_proxy_ops = {\n\t.owner = THIS_MODULE,\n\t.send = mei_gsc_proxy_send,\n\t.recv = mei_gsc_proxy_recv,\n};\n\nstatic int mei_component_master_bind(struct device *dev)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tstruct i915_gsc_proxy_component *comp_master = mei_cldev_get_drvdata(cldev);\n\n\tcomp_master->ops = &mei_gsc_proxy_ops;\n\tcomp_master->mei_dev = dev;\n\treturn component_bind_all(dev, comp_master);\n}\n\nstatic void mei_component_master_unbind(struct device *dev)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tstruct i915_gsc_proxy_component *comp_master = mei_cldev_get_drvdata(cldev);\n\n\tcomponent_unbind_all(dev, comp_master);\n}\n\nstatic const struct component_master_ops mei_component_master_ops = {\n\t.bind = mei_component_master_bind,\n\t.unbind = mei_component_master_unbind,\n};\n\n \nstatic int mei_gsc_proxy_component_match(struct device *dev, int subcomponent,\n\t\t\t\t\t void *data)\n{\n\tstruct pci_dev *pdev;\n\n\tif (!dev_is_pci(dev))\n\t\treturn 0;\n\n\tpdev = to_pci_dev(dev);\n\n\tif (pdev->class != (PCI_CLASS_DISPLAY_VGA << 8) ||\n\t    pdev->vendor != PCI_VENDOR_ID_INTEL)\n\t\treturn 0;\n\n\tif (subcomponent != I915_COMPONENT_GSC_PROXY)\n\t\treturn 0;\n\n\treturn component_compare_dev(dev->parent, ((struct device *)data)->parent);\n}\n\nstatic int mei_gsc_proxy_probe(struct mei_cl_device *cldev,\n\t\t\t       const struct mei_cl_device_id *id)\n{\n\tstruct i915_gsc_proxy_component *comp_master;\n\tstruct component_match *master_match = NULL;\n\tint ret;\n\n\tret = mei_cldev_enable(cldev);\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"mei_cldev_enable Failed. %d\\n\", ret);\n\t\tgoto enable_err_exit;\n\t}\n\n\tcomp_master = kzalloc(sizeof(*comp_master), GFP_KERNEL);\n\tif (!comp_master) {\n\t\tret = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\tcomponent_match_add_typed(&cldev->dev, &master_match,\n\t\t\t\t  mei_gsc_proxy_component_match, cldev->dev.parent);\n\tif (IS_ERR_OR_NULL(master_match)) {\n\t\tret = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\tmei_cldev_set_drvdata(cldev, comp_master);\n\tret = component_master_add_with_match(&cldev->dev,\n\t\t\t\t\t      &mei_component_master_ops,\n\t\t\t\t\t      master_match);\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"Master comp add failed %d\\n\", ret);\n\t\tgoto err_exit;\n\t}\n\n\treturn 0;\n\nerr_exit:\n\tmei_cldev_set_drvdata(cldev, NULL);\n\tkfree(comp_master);\n\tmei_cldev_disable(cldev);\nenable_err_exit:\n\treturn ret;\n}\n\nstatic void mei_gsc_proxy_remove(struct mei_cl_device *cldev)\n{\n\tstruct i915_gsc_proxy_component *comp_master = mei_cldev_get_drvdata(cldev);\n\tint ret;\n\n\tcomponent_master_del(&cldev->dev, &mei_component_master_ops);\n\tkfree(comp_master);\n\tmei_cldev_set_drvdata(cldev, NULL);\n\n\tret = mei_cldev_disable(cldev);\n\tif (ret)\n\t\tdev_warn(&cldev->dev, \"mei_cldev_disable() failed %d\\n\", ret);\n}\n\n#define MEI_UUID_GSC_PROXY UUID_LE(0xf73db04, 0x97ab, 0x4125, \\\n\t\t\t\t   0xb8, 0x93, 0xe9, 0x4, 0xad, 0xd, 0x54, 0x64)\n\nstatic struct mei_cl_device_id mei_gsc_proxy_tbl[] = {\n\t{ .uuid = MEI_UUID_GSC_PROXY, .version = MEI_CL_VERSION_ANY },\n\t{ }\n};\nMODULE_DEVICE_TABLE(mei, mei_gsc_proxy_tbl);\n\nstatic struct mei_cl_driver mei_gsc_proxy_driver = {\n\t.id_table = mei_gsc_proxy_tbl,\n\t.name = KBUILD_MODNAME,\n\t.probe = mei_gsc_proxy_probe,\n\t.remove\t= mei_gsc_proxy_remove,\n};\n\nmodule_mei_cl_driver(mei_gsc_proxy_driver);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MEI GSC PROXY\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}