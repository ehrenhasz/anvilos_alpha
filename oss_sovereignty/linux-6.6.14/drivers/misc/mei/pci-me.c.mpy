{
  "module_name": "pci-me.c",
  "hash_id": "00a8c661ae68266d7245b083e0d10d429838fb03c4cf4e56c710eff41ffa7633",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/pci-me.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/mei.h>\n\n#include \"mei_dev.h\"\n#include \"client.h\"\n#include \"hw-me-regs.h\"\n#include \"hw-me.h\"\n\n \nstatic const struct pci_device_id mei_me_pci_tbl[] = {\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_82946GZ, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_82G35, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_82Q965, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_82G965, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_82GM965, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_82GME965, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9_82Q35, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9_82G33, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9_82Q33, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9_82X38, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9_3200, MEI_ME_ICH_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9_6, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9_7, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9_8, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9_9, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9_10, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9M_1, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9M_2, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9M_3, MEI_ME_ICH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH9M_4, MEI_ME_ICH_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH10_1, MEI_ME_ICH10_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH10_2, MEI_ME_ICH10_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH10_3, MEI_ME_ICH10_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICH10_4, MEI_ME_ICH10_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_IBXPK_1, MEI_ME_PCH6_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_IBXPK_2, MEI_ME_PCH6_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_CPT_1, MEI_ME_PCH_CPT_PBG_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_PBG_1, MEI_ME_PCH_CPT_PBG_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_PPT_1, MEI_ME_PCH7_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_PPT_2, MEI_ME_PCH7_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_PPT_3, MEI_ME_PCH7_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_LPT_H, MEI_ME_PCH8_SPS_4_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_LPT_W, MEI_ME_PCH8_SPS_4_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_LPT_LP, MEI_ME_PCH8_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_LPT_HR, MEI_ME_PCH8_SPS_4_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_WPT_LP, MEI_ME_PCH8_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_WPT_LP_2, MEI_ME_PCH8_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_SPT, MEI_ME_PCH8_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_2, MEI_ME_PCH8_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_3, MEI_ME_PCH8_ITOUCH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H, MEI_ME_PCH8_SPS_4_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H_2, MEI_ME_PCH8_SPS_4_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_LBG, MEI_ME_PCH12_SPS_4_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_BXT_M, MEI_ME_PCH8_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_APL_I, MEI_ME_PCH8_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_DNV_IE, MEI_ME_PCH8_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_GLK, MEI_ME_PCH8_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_KBP, MEI_ME_PCH8_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_KBP_2, MEI_ME_PCH8_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_KBP_3, MEI_ME_PCH8_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_CNP_LP, MEI_ME_PCH12_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_CNP_LP_3, MEI_ME_PCH8_ITOUCH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_CNP_H, MEI_ME_PCH12_SPS_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_CNP_H_3, MEI_ME_PCH12_SPS_ITOUCH_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_CMP_LP, MEI_ME_PCH12_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_CMP_LP_3, MEI_ME_PCH8_ITOUCH_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_CMP_V, MEI_ME_PCH12_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_CMP_H, MEI_ME_PCH12_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_CMP_H_3, MEI_ME_PCH8_ITOUCH_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_LP, MEI_ME_PCH12_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_N, MEI_ME_PCH12_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_TGP_LP, MEI_ME_PCH15_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_TGP_H, MEI_ME_PCH15_SPS_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_JSP_N, MEI_ME_PCH15_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_MCC, MEI_ME_PCH15_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_MCC_4, MEI_ME_PCH8_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_CDF, MEI_ME_PCH8_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_EBG, MEI_ME_PCH15_SPS_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ADP_S, MEI_ME_PCH15_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ADP_LP, MEI_ME_PCH15_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ADP_P, MEI_ME_PCH15_CFG)},\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_ADP_N, MEI_ME_PCH15_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_RPL_S, MEI_ME_PCH15_CFG)},\n\n\t{MEI_PCI_DEVICE(MEI_DEV_ID_MTL_M, MEI_ME_PCH15_CFG)},\n\n\t \n\t{0, }\n};\n\nMODULE_DEVICE_TABLE(pci, mei_me_pci_tbl);\n\n#ifdef CONFIG_PM\nstatic inline void mei_me_set_pm_domain(struct mei_device *dev);\nstatic inline void mei_me_unset_pm_domain(struct mei_device *dev);\n#else\nstatic inline void mei_me_set_pm_domain(struct mei_device *dev) {}\nstatic inline void mei_me_unset_pm_domain(struct mei_device *dev) {}\n#endif  \n\nstatic int mei_me_read_fws(const struct mei_device *dev, int where, u32 *val)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\treturn pci_read_config_dword(pdev, where, val);\n}\n\n \nstatic bool mei_me_quirk_probe(struct pci_dev *pdev,\n\t\t\t\tconst struct mei_cfg *cfg)\n{\n\tif (cfg->quirk_probe && cfg->quirk_probe(pdev)) {\n\t\tdev_info(&pdev->dev, \"Device doesn't have valid ME Interface\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int mei_me_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tconst struct mei_cfg *cfg;\n\tstruct mei_device *dev;\n\tstruct mei_me_hw *hw;\n\tunsigned int irqflags;\n\tint err;\n\n\tcfg = mei_me_get_cfg(ent->driver_data);\n\tif (!cfg)\n\t\treturn -ENODEV;\n\n\tif (!mei_me_quirk_probe(pdev, cfg))\n\t\treturn -ENODEV;\n\n\t \n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable pci device.\\n\");\n\t\tgoto end;\n\t}\n\t \n\tpci_set_master(pdev);\n\t \n\terr = pcim_iomap_regions(pdev, BIT(0), KBUILD_MODNAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to get pci regions.\\n\");\n\t\tgoto end;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"No usable DMA configuration, aborting\\n\");\n\t\tgoto end;\n\t}\n\n\t \n\tdev = mei_me_dev_init(&pdev->dev, cfg, false);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto end;\n\t}\n\thw = to_me_hw(dev);\n\thw->mem_addr = pcim_iomap_table(pdev)[0];\n\thw->read_fws = mei_me_read_fws;\n\n\tpci_enable_msi(pdev);\n\n\thw->irq = pdev->irq;\n\n\t  \n\tirqflags = pci_dev_msi_enabled(pdev) ? IRQF_ONESHOT : IRQF_SHARED;\n\n\terr = request_threaded_irq(pdev->irq,\n\t\t\tmei_me_irq_quick_handler,\n\t\t\tmei_me_irq_thread_handler,\n\t\t\tirqflags, KBUILD_MODNAME, dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"request_threaded_irq failure. irq = %d\\n\",\n\t\t       pdev->irq);\n\t\tgoto end;\n\t}\n\n\tif (mei_start(dev)) {\n\t\tdev_err(&pdev->dev, \"init hw failure.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto release_irq;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, MEI_ME_RPM_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\n\terr = mei_register(dev, &pdev->dev);\n\tif (err)\n\t\tgoto stop;\n\n\tpci_set_drvdata(pdev, dev);\n\n\t \n\tdev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_NO_DIRECT_COMPLETE);\n\n\t \n\tmei_me_set_pm_domain(dev);\n\n\tif (mei_pg_is_enabled(dev)) {\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\t\tif (hw->d0i3_supported)\n\t\t\tpm_runtime_allow(&pdev->dev);\n\t}\n\n\tdev_dbg(&pdev->dev, \"initialization successful.\\n\");\n\n\treturn 0;\n\nstop:\n\tmei_stop(dev);\nrelease_irq:\n\tmei_cancel_work(dev);\n\tmei_disable_interrupts(dev);\n\tfree_irq(pdev->irq, dev);\nend:\n\tdev_err(&pdev->dev, \"initialization failed.\\n\");\n\treturn err;\n}\n\n \nstatic void mei_me_shutdown(struct pci_dev *pdev)\n{\n\tstruct mei_device *dev;\n\n\tdev = pci_get_drvdata(pdev);\n\tif (!dev)\n\t\treturn;\n\n\tdev_dbg(&pdev->dev, \"shutdown\\n\");\n\tmei_stop(dev);\n\n\tmei_me_unset_pm_domain(dev);\n\n\tmei_disable_interrupts(dev);\n\tfree_irq(pdev->irq, dev);\n}\n\n \nstatic void mei_me_remove(struct pci_dev *pdev)\n{\n\tstruct mei_device *dev;\n\n\tdev = pci_get_drvdata(pdev);\n\tif (!dev)\n\t\treturn;\n\n\tif (mei_pg_is_enabled(dev))\n\t\tpm_runtime_get_noresume(&pdev->dev);\n\n\tdev_dbg(&pdev->dev, \"stop\\n\");\n\tmei_stop(dev);\n\n\tmei_me_unset_pm_domain(dev);\n\n\tmei_disable_interrupts(dev);\n\n\tfree_irq(pdev->irq, dev);\n\n\tmei_deregister(dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mei_me_pci_prepare(struct device *device)\n{\n\tpm_runtime_resume(device);\n\treturn 0;\n}\n\nstatic int mei_me_pci_suspend(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct mei_device *dev = pci_get_drvdata(pdev);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdev_dbg(&pdev->dev, \"suspend\\n\");\n\n\tmei_stop(dev);\n\n\tmei_disable_interrupts(dev);\n\n\tfree_irq(pdev->irq, dev);\n\tpci_disable_msi(pdev);\n\n\treturn 0;\n}\n\nstatic int mei_me_pci_resume(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct mei_device *dev;\n\tunsigned int irqflags;\n\tint err;\n\n\tdev = pci_get_drvdata(pdev);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tpci_enable_msi(pdev);\n\n\tirqflags = pci_dev_msi_enabled(pdev) ? IRQF_ONESHOT : IRQF_SHARED;\n\n\t \n\terr = request_threaded_irq(pdev->irq,\n\t\t\tmei_me_irq_quick_handler,\n\t\t\tmei_me_irq_thread_handler,\n\t\t\tirqflags, KBUILD_MODNAME, dev);\n\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"request_threaded_irq failed: irq = %d.\\n\",\n\t\t\t\tpdev->irq);\n\t\treturn err;\n\t}\n\n\terr = mei_restart(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tschedule_delayed_work(&dev->timer_work, HZ);\n\n\treturn 0;\n}\n\nstatic void mei_me_pci_complete(struct device *device)\n{\n\tpm_runtime_suspend(device);\n}\n#else  \n\n#define mei_me_pci_prepare NULL\n#define mei_me_pci_complete NULL\n\n#endif  \n\n#ifdef CONFIG_PM\nstatic int mei_me_pm_runtime_idle(struct device *device)\n{\n\tstruct mei_device *dev;\n\n\tdev_dbg(device, \"rpm: me: runtime_idle\\n\");\n\n\tdev = dev_get_drvdata(device);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tif (mei_write_is_idle(dev))\n\t\tpm_runtime_autosuspend(device);\n\n\treturn -EBUSY;\n}\n\nstatic int mei_me_pm_runtime_suspend(struct device *device)\n{\n\tstruct mei_device *dev;\n\tint ret;\n\n\tdev_dbg(device, \"rpm: me: runtime suspend\\n\");\n\n\tdev = dev_get_drvdata(device);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->device_lock);\n\n\tif (mei_write_is_idle(dev))\n\t\tret = mei_me_pg_enter_sync(dev);\n\telse\n\t\tret = -EAGAIN;\n\n\tmutex_unlock(&dev->device_lock);\n\n\tdev_dbg(device, \"rpm: me: runtime suspend ret=%d\\n\", ret);\n\n\tif (ret && ret != -EAGAIN)\n\t\tschedule_work(&dev->reset_work);\n\n\treturn ret;\n}\n\nstatic int mei_me_pm_runtime_resume(struct device *device)\n{\n\tstruct mei_device *dev;\n\tint ret;\n\n\tdev_dbg(device, \"rpm: me: runtime resume\\n\");\n\n\tdev = dev_get_drvdata(device);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->device_lock);\n\n\tret = mei_me_pg_exit_sync(dev);\n\n\tmutex_unlock(&dev->device_lock);\n\n\tdev_dbg(device, \"rpm: me: runtime resume ret = %d\\n\", ret);\n\n\tif (ret)\n\t\tschedule_work(&dev->reset_work);\n\n\treturn ret;\n}\n\n \nstatic inline void mei_me_set_pm_domain(struct mei_device *dev)\n{\n\tstruct pci_dev *pdev  = to_pci_dev(dev->dev);\n\n\tif (pdev->dev.bus && pdev->dev.bus->pm) {\n\t\tdev->pg_domain.ops = *pdev->dev.bus->pm;\n\n\t\tdev->pg_domain.ops.runtime_suspend = mei_me_pm_runtime_suspend;\n\t\tdev->pg_domain.ops.runtime_resume = mei_me_pm_runtime_resume;\n\t\tdev->pg_domain.ops.runtime_idle = mei_me_pm_runtime_idle;\n\n\t\tdev_pm_domain_set(&pdev->dev, &dev->pg_domain);\n\t}\n}\n\n \nstatic inline void mei_me_unset_pm_domain(struct mei_device *dev)\n{\n\t \n\tdev_pm_domain_set(dev->dev, NULL);\n}\n\nstatic const struct dev_pm_ops mei_me_pm_ops = {\n\t.prepare = mei_me_pci_prepare,\n\t.complete = mei_me_pci_complete,\n\tSET_SYSTEM_SLEEP_PM_OPS(mei_me_pci_suspend,\n\t\t\t\tmei_me_pci_resume)\n\tSET_RUNTIME_PM_OPS(\n\t\tmei_me_pm_runtime_suspend,\n\t\tmei_me_pm_runtime_resume,\n\t\tmei_me_pm_runtime_idle)\n};\n\n#define MEI_ME_PM_OPS\t(&mei_me_pm_ops)\n#else\n#define MEI_ME_PM_OPS\tNULL\n#endif  \n \nstatic struct pci_driver mei_me_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = mei_me_pci_tbl,\n\t.probe = mei_me_probe,\n\t.remove = mei_me_remove,\n\t.shutdown = mei_me_shutdown,\n\t.driver.pm = MEI_ME_PM_OPS,\n\t.driver.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n};\n\nmodule_pci_driver(mei_me_driver);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_DESCRIPTION(\"Intel(R) Management Engine Interface\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}