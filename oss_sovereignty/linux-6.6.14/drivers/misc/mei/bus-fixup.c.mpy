{
  "module_name": "bus-fixup.c",
  "hash_id": "fdb5860c7a5ba80e7826100cd7fb98d4632c8c20cf28d969c333d62f51b8c668",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/bus-fixup.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n\n#include <linux/mei.h>\n#include <linux/mei_cl_bus.h>\n\n#include \"mei_dev.h\"\n#include \"client.h\"\n#include \"mkhi.h\"\n\n#define MEI_UUID_NFC_INFO UUID_LE(0xd2de1625, 0x382d, 0x417d, \\\n\t\t\t0x48, 0xa4, 0xef, 0xab, 0xba, 0x8a, 0x12, 0x06)\n\nstatic const uuid_le mei_nfc_info_guid = MEI_UUID_NFC_INFO;\n\n#define MEI_UUID_NFC_HCI UUID_LE(0x0bb17a78, 0x2a8e, 0x4c50, \\\n\t\t\t0x94, 0xd4, 0x50, 0x26, 0x67, 0x23, 0x77, 0x5c)\n\n#define MEI_UUID_WD UUID_LE(0x05B79A6F, 0x4628, 0x4D7F, \\\n\t\t\t    0x89, 0x9D, 0xA9, 0x15, 0x14, 0xCB, 0x32, 0xAB)\n\n#define MEI_UUID_MKHIF_FIX UUID_LE(0x55213584, 0x9a29, 0x4916, \\\n\t\t\t0xba, 0xdf, 0xf, 0xb7, 0xed, 0x68, 0x2a, 0xeb)\n\n#define MEI_UUID_IGSC_MKHI UUID_LE(0xE2C2AFA2, 0x3817, 0x4D19, \\\n\t\t\t0x9D, 0x95, 0x06, 0xB1, 0x6B, 0x58, 0x8A, 0x5D)\n\n#define MEI_UUID_IGSC_MKHI_FIX UUID_LE(0x46E0C1FB, 0xA546, 0x414F, \\\n\t\t\t0x91, 0x70, 0xB7, 0xF4, 0x6D, 0x57, 0xB4, 0xAD)\n\n#define MEI_UUID_HDCP UUID_LE(0xB638AB7E, 0x94E2, 0x4EA2, \\\n\t\t\t      0xA5, 0x52, 0xD1, 0xC5, 0x4B, 0x62, 0x7F, 0x04)\n\n#define MEI_UUID_PAVP UUID_LE(0xfbf6fcf1, 0x96cf, 0x4e2e, 0xA6, \\\n\t\t\t      0xa6, 0x1b, 0xab, 0x8c, 0xbe, 0x36, 0xb1)\n\n#define MEI_UUID_ANY NULL_UUID_LE\n\n \nstatic void number_of_connections(struct mei_cl_device *cldev)\n{\n\tif (cldev->me_cl->props.max_number_of_connections > 1)\n\t\tcldev->do_match = 0;\n}\n\n \nstatic void blacklist(struct mei_cl_device *cldev)\n{\n\tcldev->do_match = 0;\n}\n\n \nstatic void whitelist(struct mei_cl_device *cldev)\n{\n\tcldev->do_match = 1;\n}\n\n#define OSTYPE_LINUX    2\nstruct mei_os_ver {\n\t__le16 build;\n\t__le16 reserved1;\n\tu8  os_type;\n\tu8  major;\n\tu8  minor;\n\tu8  reserved2;\n} __packed;\n\nstruct mkhi_fw_ver_block {\n\tu16 minor;\n\tu8 major;\n\tu8 platform;\n\tu16 buildno;\n\tu16 hotfix;\n} __packed;\n\nstruct mkhi_fw_ver {\n\tstruct mkhi_fw_ver_block ver[MEI_MAX_FW_VER_BLOCKS];\n} __packed;\n\n#define MKHI_OSVER_BUF_LEN (sizeof(struct mkhi_msg_hdr) + \\\n\t\t\t    sizeof(struct mkhi_fwcaps) + \\\n\t\t\t    sizeof(struct mei_os_ver))\nstatic int mei_osver(struct mei_cl_device *cldev)\n{\n\tconst size_t size = MKHI_OSVER_BUF_LEN;\n\tu8 buf[MKHI_OSVER_BUF_LEN];\n\tstruct mkhi_msg *req;\n\tstruct mkhi_fwcaps *fwcaps;\n\tstruct mei_os_ver *os_ver;\n\tunsigned int mode = MEI_CL_IO_TX_BLOCKING | MEI_CL_IO_TX_INTERNAL;\n\n\tmemset(buf, 0, size);\n\n\treq = (struct mkhi_msg *)buf;\n\treq->hdr.group_id = MKHI_FWCAPS_GROUP_ID;\n\treq->hdr.command = MKHI_FWCAPS_SET_OS_VER_APP_RULE_CMD;\n\n\tfwcaps = (struct mkhi_fwcaps *)req->data;\n\n\tfwcaps->id.rule_type = 0x0;\n\tfwcaps->id.feature_id = MKHI_FEATURE_PTT;\n\tfwcaps->len = sizeof(*os_ver);\n\tos_ver = (struct mei_os_ver *)fwcaps->data;\n\tos_ver->os_type = OSTYPE_LINUX;\n\n\treturn __mei_cl_send(cldev->cl, buf, size, 0, mode);\n}\n\n#define MKHI_FWVER_BUF_LEN (sizeof(struct mkhi_msg_hdr) + \\\n\t\t\t    sizeof(struct mkhi_fw_ver))\n#define MKHI_FWVER_LEN(__num) (sizeof(struct mkhi_msg_hdr) + \\\n\t\t\t       sizeof(struct mkhi_fw_ver_block) * (__num))\nstatic int mei_fwver(struct mei_cl_device *cldev)\n{\n\tu8 buf[MKHI_FWVER_BUF_LEN];\n\tstruct mkhi_msg req;\n\tstruct mkhi_msg *rsp;\n\tstruct mkhi_fw_ver *fwver;\n\tint bytes_recv, ret, i;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\treq.hdr.group_id = MKHI_GEN_GROUP_ID;\n\treq.hdr.command = MKHI_GEN_GET_FW_VERSION_CMD;\n\n\tret = __mei_cl_send(cldev->cl, (u8 *)&req, sizeof(req), 0,\n\t\t\t    MEI_CL_IO_TX_BLOCKING);\n\tif (ret < 0) {\n\t\tdev_info(&cldev->dev, \"Could not send ReqFWVersion cmd ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = 0;\n\tbytes_recv = __mei_cl_recv(cldev->cl, buf, sizeof(buf), NULL, 0,\n\t\t\t\t   cldev->bus->timeouts.mkhi_recv);\n\tif (bytes_recv < 0 || (size_t)bytes_recv < MKHI_FWVER_LEN(1)) {\n\t\t \n\t\tdev_info(&cldev->dev, \"Could not read FW version ret = %d\\n\", bytes_recv);\n\t\treturn -EIO;\n\t}\n\n\trsp = (struct mkhi_msg *)buf;\n\tfwver = (struct mkhi_fw_ver *)rsp->data;\n\tmemset(cldev->bus->fw_ver, 0, sizeof(cldev->bus->fw_ver));\n\tfor (i = 0; i < MEI_MAX_FW_VER_BLOCKS; i++) {\n\t\tif ((size_t)bytes_recv < MKHI_FWVER_LEN(i + 1))\n\t\t\tbreak;\n\t\tdev_dbg(&cldev->dev, \"FW version%d %d:%d.%d.%d.%d\\n\",\n\t\t\ti, fwver->ver[i].platform,\n\t\t\tfwver->ver[i].major, fwver->ver[i].minor,\n\t\t\tfwver->ver[i].hotfix, fwver->ver[i].buildno);\n\n\t\tcldev->bus->fw_ver[i].platform = fwver->ver[i].platform;\n\t\tcldev->bus->fw_ver[i].major = fwver->ver[i].major;\n\t\tcldev->bus->fw_ver[i].minor = fwver->ver[i].minor;\n\t\tcldev->bus->fw_ver[i].hotfix = fwver->ver[i].hotfix;\n\t\tcldev->bus->fw_ver[i].buildno = fwver->ver[i].buildno;\n\t}\n\tcldev->bus->fw_ver_received = 1;\n\n\treturn ret;\n}\n\n#define GFX_MEMORY_READY_TIMEOUT 200  \n\nstatic int mei_gfx_memory_ready(struct mei_cl_device *cldev)\n{\n\tstruct mkhi_gfx_mem_ready req = {0};\n\tunsigned int mode = MEI_CL_IO_TX_INTERNAL | MEI_CL_IO_TX_BLOCKING;\n\n\treq.hdr.group_id = MKHI_GROUP_ID_GFX;\n\treq.hdr.command = MKHI_GFX_MEMORY_READY_CMD_REQ;\n\treq.flags = MKHI_GFX_MEM_READY_PXP_ALLOWED;\n\n\tdev_dbg(&cldev->dev, \"Sending memory ready command\\n\");\n\treturn __mei_cl_send_timeout(cldev->cl, (u8 *)&req, sizeof(req), 0,\n\t\t\t\t     mode, GFX_MEMORY_READY_TIMEOUT);\n}\n\nstatic void mei_mkhi_fix(struct mei_cl_device *cldev)\n{\n\tint ret;\n\n\t \n\tif (!cldev->bus->fw_f_fw_ver_supported &&\n\t    !cldev->bus->hbm_f_os_supported)\n\t\treturn;\n\n\tret = mei_cldev_enable(cldev);\n\tif (ret)\n\t\treturn;\n\n\tif (cldev->bus->fw_f_fw_ver_supported) {\n\t\tret = mei_fwver(cldev);\n\t\tif (ret < 0)\n\t\t\tdev_info(&cldev->dev, \"FW version command failed %d\\n\",\n\t\t\t\t ret);\n\t}\n\n\tif (cldev->bus->hbm_f_os_supported) {\n\t\tret = mei_osver(cldev);\n\t\tif (ret < 0)\n\t\t\tdev_info(&cldev->dev, \"OS version command failed %d\\n\",\n\t\t\t\t ret);\n\t}\n\tmei_cldev_disable(cldev);\n}\n\nstatic void mei_gsc_mkhi_ver(struct mei_cl_device *cldev)\n{\n\tint ret;\n\n\t \n\tif (!cldev->bus->fw_f_fw_ver_supported || cldev->bus->fw_ver_received)\n\t\treturn;\n\n\tret = mei_cldev_enable(cldev);\n\tif (ret)\n\t\treturn;\n\n\tret = mei_fwver(cldev);\n\tif (ret < 0)\n\t\tdev_info(&cldev->dev, \"FW version command failed %d\\n\", ret);\n\tmei_cldev_disable(cldev);\n}\n\nstatic void mei_gsc_mkhi_fix_ver(struct mei_cl_device *cldev)\n{\n\tint ret;\n\n\t \n\tif (!cldev->bus->fw_f_fw_ver_supported &&\n\t    cldev->bus->pxp_mode != MEI_DEV_PXP_INIT)\n\t\treturn;\n\n\tret = mei_cldev_enable(cldev);\n\tif (ret)\n\t\treturn;\n\n\tif (cldev->bus->pxp_mode == MEI_DEV_PXP_INIT) {\n\t\tret = mei_gfx_memory_ready(cldev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&cldev->dev, \"memory ready command failed %d\\n\", ret);\n\t\t} else {\n\t\t\tdev_dbg(&cldev->dev, \"memory ready command sent\\n\");\n\t\t\tcldev->bus->pxp_mode = MEI_DEV_PXP_SETUP;\n\t\t}\n\t\t \n\t\tgoto out;\n\t}\n\n\tret = mei_fwver(cldev);\n\tif (ret < 0)\n\t\tdev_info(&cldev->dev, \"FW version command failed %d\\n\",\n\t\t\t ret);\nout:\n\tmei_cldev_disable(cldev);\n}\n\n \n#if IS_ENABLED(CONFIG_INTEL_MEI_ME)\n#include <linux/pci.h>\n#include \"hw-me-regs.h\"\nstatic void mei_wd(struct mei_cl_device *cldev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(cldev->dev.parent);\n\n\tif (pdev->device == MEI_DEV_ID_WPT_LP ||\n\t    pdev->device == MEI_DEV_ID_SPT ||\n\t    pdev->device == MEI_DEV_ID_SPT_H)\n\t\tcldev->me_cl->props.protocol_version = 0x2;\n\n\tcldev->do_match = 1;\n}\n#else\nstatic inline void mei_wd(struct mei_cl_device *cldev) {}\n#endif  \n\nstruct mei_nfc_cmd {\n\tu8 command;\n\tu8 status;\n\tu16 req_id;\n\tu32 reserved;\n\tu16 data_size;\n\tu8 sub_command;\n\tu8 data[];\n} __packed;\n\nstruct mei_nfc_reply {\n\tu8 command;\n\tu8 status;\n\tu16 req_id;\n\tu32 reserved;\n\tu16 data_size;\n\tu8 sub_command;\n\tu8 reply_status;\n\tu8 data[];\n} __packed;\n\nstruct mei_nfc_if_version {\n\tu8 radio_version_sw[3];\n\tu8 reserved[3];\n\tu8 radio_version_hw[3];\n\tu8 i2c_addr;\n\tu8 fw_ivn;\n\tu8 vendor_id;\n\tu8 radio_type;\n} __packed;\n\n\n#define MEI_NFC_CMD_MAINTENANCE 0x00\n#define MEI_NFC_SUBCMD_IF_VERSION 0x01\n\n \n#define MEI_NFC_VENDOR_INSIDE 0x00\n#define MEI_NFC_VENDOR_NXP    0x01\n\n \n#define MEI_NFC_VENDOR_INSIDE_UREAD 0x00\n#define MEI_NFC_VENDOR_NXP_PN544    0x01\n\n \nstatic int mei_nfc_if_version(struct mei_cl *cl,\n\t\t\t      struct mei_nfc_if_version *ver)\n{\n\tstruct mei_device *bus;\n\tstruct mei_nfc_cmd cmd = {\n\t\t.command = MEI_NFC_CMD_MAINTENANCE,\n\t\t.data_size = 1,\n\t\t.sub_command = MEI_NFC_SUBCMD_IF_VERSION,\n\t};\n\tstruct mei_nfc_reply *reply = NULL;\n\tsize_t if_version_length;\n\tu8 vtag;\n\tint bytes_recv, ret;\n\n\tbus = cl->dev;\n\n\tWARN_ON(mutex_is_locked(&bus->device_lock));\n\n\tret = __mei_cl_send(cl, (u8 *)&cmd, sizeof(cmd), 0,\n\t\t\t    MEI_CL_IO_TX_BLOCKING);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"Could not send IF version cmd ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif_version_length = sizeof(*reply) + sizeof(*ver);\n\n\treply = kzalloc(if_version_length, GFP_KERNEL);\n\tif (!reply)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tbytes_recv = __mei_cl_recv(cl, (u8 *)reply, if_version_length, &vtag,\n\t\t\t\t   0, 0);\n\tif (bytes_recv < 0 || (size_t)bytes_recv < if_version_length) {\n\t\tdev_err(bus->dev, \"Could not read IF version ret = %d\\n\", bytes_recv);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tmemcpy(ver, reply->data, sizeof(*ver));\n\n\tdev_info(bus->dev, \"NFC MEI VERSION: IVN 0x%x Vendor ID 0x%x Type 0x%x\\n\",\n\t\t ver->fw_ivn, ver->vendor_id, ver->radio_type);\n\nerr:\n\tkfree(reply);\n\treturn ret;\n}\n\n \nstatic const char *mei_nfc_radio_name(struct mei_nfc_if_version *ver)\n{\n\n\tif (ver->vendor_id == MEI_NFC_VENDOR_INSIDE) {\n\t\tif (ver->radio_type == MEI_NFC_VENDOR_INSIDE_UREAD)\n\t\t\treturn \"microread\";\n\t}\n\n\tif (ver->vendor_id == MEI_NFC_VENDOR_NXP) {\n\t\tif (ver->radio_type == MEI_NFC_VENDOR_NXP_PN544)\n\t\t\treturn \"pn544\";\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void mei_nfc(struct mei_cl_device *cldev)\n{\n\tstruct mei_device *bus;\n\tstruct mei_cl *cl;\n\tstruct mei_me_client *me_cl = NULL;\n\tstruct mei_nfc_if_version ver;\n\tconst char *radio_name = NULL;\n\tint ret;\n\n\tbus = cldev->bus;\n\n\tmutex_lock(&bus->device_lock);\n\t \n\tcl = mei_cl_alloc_linked(bus);\n\tif (IS_ERR(cl)) {\n\t\tret = PTR_ERR(cl);\n\t\tcl = NULL;\n\t\tdev_err(bus->dev, \"nfc hook alloc failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tme_cl = mei_me_cl_by_uuid(bus, &mei_nfc_info_guid);\n\tif (!me_cl) {\n\t\tret = -ENOTTY;\n\t\tdev_err(bus->dev, \"Cannot find nfc info %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = mei_cl_connect(cl, me_cl, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"Can't connect to the NFC INFO ME ret = %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tmutex_unlock(&bus->device_lock);\n\n\tret = mei_nfc_if_version(cl, &ver);\n\tif (ret)\n\t\tgoto disconnect;\n\n\tradio_name = mei_nfc_radio_name(&ver);\n\n\tif (!radio_name) {\n\t\tret = -ENOENT;\n\t\tdev_err(&cldev->dev, \"Can't get the NFC interface version ret = %d\\n\",\n\t\t\tret);\n\t\tgoto disconnect;\n\t}\n\n\tdev_dbg(bus->dev, \"nfc radio %s\\n\", radio_name);\n\tstrscpy(cldev->name, radio_name, sizeof(cldev->name));\n\ndisconnect:\n\tmutex_lock(&bus->device_lock);\n\tif (mei_cl_disconnect(cl) < 0)\n\t\tdev_err(bus->dev, \"Can't disconnect the NFC INFO ME\\n\");\n\n\tmei_cl_flush_queues(cl, NULL);\n\nout:\n\tmei_cl_unlink(cl);\n\tmutex_unlock(&bus->device_lock);\n\tmei_me_cl_put(me_cl);\n\tkfree(cl);\n\n\tif (ret)\n\t\tcldev->do_match = 0;\n\n\tdev_dbg(bus->dev, \"end of fixup match = %d\\n\", cldev->do_match);\n}\n\n \nstatic void vt_support(struct mei_cl_device *cldev)\n{\n\tif (cldev->me_cl->props.vt_supported == 1)\n\t\tcldev->do_match = 1;\n}\n\n \nstatic void pxp_is_ready(struct mei_cl_device *cldev)\n{\n\tstruct mei_device *bus = cldev->bus;\n\n\tswitch (bus->pxp_mode) {\n\tcase MEI_DEV_PXP_READY:\n\tcase MEI_DEV_PXP_DEFAULT:\n\t\tcldev->do_match = 1;\n\tbreak;\n\tdefault:\n\t\tcldev->do_match = 0;\n\tbreak;\n\t}\n}\n\n#define MEI_FIXUP(_uuid, _hook) { _uuid, _hook }\n\nstatic struct mei_fixup {\n\n\tconst uuid_le uuid;\n\tvoid (*hook)(struct mei_cl_device *cldev);\n} mei_fixups[] = {\n\tMEI_FIXUP(MEI_UUID_ANY, number_of_connections),\n\tMEI_FIXUP(MEI_UUID_NFC_INFO, blacklist),\n\tMEI_FIXUP(MEI_UUID_NFC_HCI, mei_nfc),\n\tMEI_FIXUP(MEI_UUID_WD, mei_wd),\n\tMEI_FIXUP(MEI_UUID_MKHIF_FIX, mei_mkhi_fix),\n\tMEI_FIXUP(MEI_UUID_IGSC_MKHI_FIX, mei_gsc_mkhi_fix_ver),\n\tMEI_FIXUP(MEI_UUID_IGSC_MKHI, mei_gsc_mkhi_ver),\n\tMEI_FIXUP(MEI_UUID_HDCP, whitelist),\n\tMEI_FIXUP(MEI_UUID_ANY, vt_support),\n\tMEI_FIXUP(MEI_UUID_PAVP, pxp_is_ready),\n};\n\n \nvoid mei_cl_bus_dev_fixup(struct mei_cl_device *cldev)\n{\n\tstruct mei_fixup *f;\n\tconst uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mei_fixups); i++) {\n\n\t\tf = &mei_fixups[i];\n\t\tif (uuid_le_cmp(f->uuid, MEI_UUID_ANY) == 0 ||\n\t\t    uuid_le_cmp(f->uuid, *uuid) == 0)\n\t\t\tf->hook(cldev);\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}