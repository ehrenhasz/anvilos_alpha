{
  "module_name": "gsc-me.c",
  "hash_id": "6e9f025a14cc51ec9bd15a84cd10ca960136c180cbf0ae250fd985f5fbfc50c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/gsc-me.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mei_aux.h>\n#include <linux/device.h>\n#include <linux/irqreturn.h>\n#include <linux/jiffies.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/kthread.h>\n\n#include \"mei_dev.h\"\n#include \"hw-me.h\"\n#include \"hw-me-regs.h\"\n\n#include \"mei-trace.h\"\n\n#define MEI_GSC_RPM_TIMEOUT 500\n\nstatic int mei_gsc_read_hfs(const struct mei_device *dev, int where, u32 *val)\n{\n\tstruct mei_me_hw *hw = to_me_hw(dev);\n\n\t*val = ioread32(hw->mem_addr + where + 0xC00);\n\n\treturn 0;\n}\n\nstatic void mei_gsc_set_ext_op_mem(const struct mei_me_hw *hw, struct resource *mem)\n{\n\tu32 low = lower_32_bits(mem->start);\n\tu32 hi  = upper_32_bits(mem->start);\n\tu32 limit = (resource_size(mem) / SZ_4K) | GSC_EXT_OP_MEM_VALID;\n\n\tiowrite32(low, hw->mem_addr + H_GSC_EXT_OP_MEM_BASE_ADDR_LO_REG);\n\tiowrite32(hi, hw->mem_addr + H_GSC_EXT_OP_MEM_BASE_ADDR_HI_REG);\n\tiowrite32(limit, hw->mem_addr + H_GSC_EXT_OP_MEM_LIMIT_REG);\n}\n\nstatic int mei_gsc_probe(struct auxiliary_device *aux_dev,\n\t\t\t const struct auxiliary_device_id *aux_dev_id)\n{\n\tstruct mei_aux_device *adev = auxiliary_dev_to_mei_aux_dev(aux_dev);\n\tstruct mei_device *dev;\n\tstruct mei_me_hw *hw;\n\tstruct device *device;\n\tconst struct mei_cfg *cfg;\n\tint ret;\n\n\tcfg = mei_me_get_cfg(aux_dev_id->driver_data);\n\tif (!cfg)\n\t\treturn -ENODEV;\n\n\tdevice = &aux_dev->dev;\n\n\tdev = mei_me_dev_init(device, cfg, adev->slow_firmware);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\thw = to_me_hw(dev);\n\thw->mem_addr = devm_ioremap_resource(device, &adev->bar);\n\tif (IS_ERR(hw->mem_addr)) {\n\t\tret = PTR_ERR(hw->mem_addr);\n\t\tgoto err;\n\t}\n\n\thw->irq = adev->irq;\n\thw->read_fws = mei_gsc_read_hfs;\n\n\tdev_set_drvdata(device, dev);\n\n\tif (adev->ext_op_mem.start) {\n\t\tmei_gsc_set_ext_op_mem(hw, &adev->ext_op_mem);\n\t\tdev->pxp_mode = MEI_DEV_PXP_INIT;\n\t}\n\n\t \n\tif (mei_me_hw_use_polling(hw)) {\n\t\tmei_disable_interrupts(dev);\n\t\tmei_clear_interrupts(dev);\n\t\tinit_waitqueue_head(&hw->wait_active);\n\t\thw->is_active = true;  \n\t\thw->polling_thread = kthread_run(mei_me_polling_thread, dev,\n\t\t\t\t\t\t \"kmegscirqd/%s\", dev_name(device));\n\t\tif (IS_ERR(hw->polling_thread)) {\n\t\t\tret = PTR_ERR(hw->polling_thread);\n\t\t\tdev_err(device, \"unable to create kernel thread: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tret = devm_request_threaded_irq(device, hw->irq,\n\t\t\t\t\t\tmei_me_irq_quick_handler,\n\t\t\t\t\t\tmei_me_irq_thread_handler,\n\t\t\t\t\t\tIRQF_ONESHOT, KBUILD_MODNAME, dev);\n\t\tif (ret) {\n\t\t\tdev_err(device, \"irq register failed %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tpm_runtime_get_noresume(device);\n\tpm_runtime_set_active(device);\n\tpm_runtime_enable(device);\n\n\t \n\tif (mei_start(dev))\n\t\tdev_warn(device, \"init hw failure.\\n\");\n\n\tpm_runtime_set_autosuspend_delay(device, MEI_GSC_RPM_TIMEOUT);\n\tpm_runtime_use_autosuspend(device);\n\n\tret = mei_register(dev, device);\n\tif (ret)\n\t\tgoto register_err;\n\n\tpm_runtime_put_noidle(device);\n\treturn 0;\n\nregister_err:\n\tmei_stop(dev);\n\tif (!mei_me_hw_use_polling(hw))\n\t\tdevm_free_irq(device, hw->irq, dev);\n\nerr:\n\tdev_err(device, \"probe failed: %d\\n\", ret);\n\tdev_set_drvdata(device, NULL);\n\treturn ret;\n}\n\nstatic void mei_gsc_remove(struct auxiliary_device *aux_dev)\n{\n\tstruct mei_device *dev;\n\tstruct mei_me_hw *hw;\n\n\tdev = dev_get_drvdata(&aux_dev->dev);\n\tif (!dev)\n\t\treturn;\n\n\thw = to_me_hw(dev);\n\n\tmei_stop(dev);\n\n\thw = to_me_hw(dev);\n\tif (mei_me_hw_use_polling(hw))\n\t\tkthread_stop(hw->polling_thread);\n\n\tmei_deregister(dev);\n\n\tpm_runtime_disable(&aux_dev->dev);\n\n\tmei_disable_interrupts(dev);\n\tif (!mei_me_hw_use_polling(hw))\n\t\tdevm_free_irq(&aux_dev->dev, hw->irq, dev);\n}\n\nstatic int __maybe_unused mei_gsc_pm_suspend(struct device *device)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmei_stop(dev);\n\n\tmei_disable_interrupts(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mei_gsc_pm_resume(struct device *device)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\tstruct auxiliary_device *aux_dev;\n\tstruct mei_aux_device *adev;\n\tint err;\n\tstruct mei_me_hw *hw;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\thw = to_me_hw(dev);\n\taux_dev = to_auxiliary_dev(device);\n\tadev = auxiliary_dev_to_mei_aux_dev(aux_dev);\n\tif (adev->ext_op_mem.start) {\n\t\tmei_gsc_set_ext_op_mem(hw, &adev->ext_op_mem);\n\t\tdev->pxp_mode = MEI_DEV_PXP_INIT;\n\t}\n\n\terr = mei_restart(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tschedule_delayed_work(&dev->timer_work, HZ);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mei_gsc_pm_runtime_idle(struct device *device)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\tif (mei_write_is_idle(dev))\n\t\tpm_runtime_autosuspend(device);\n\n\treturn -EBUSY;\n}\n\nstatic int  __maybe_unused mei_gsc_pm_runtime_suspend(struct device *device)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\tstruct mei_me_hw *hw;\n\tint ret;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->device_lock);\n\n\tif (mei_write_is_idle(dev)) {\n\t\thw = to_me_hw(dev);\n\t\thw->pg_state = MEI_PG_ON;\n\n\t\tif (mei_me_hw_use_polling(hw))\n\t\t\thw->is_active = false;\n\t\tret = 0;\n\t} else {\n\t\tret = -EAGAIN;\n\t}\n\n\tmutex_unlock(&dev->device_lock);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused mei_gsc_pm_runtime_resume(struct device *device)\n{\n\tstruct mei_device *dev = dev_get_drvdata(device);\n\tstruct mei_me_hw *hw;\n\tirqreturn_t irq_ret;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->device_lock);\n\n\thw = to_me_hw(dev);\n\thw->pg_state = MEI_PG_OFF;\n\n\tif (mei_me_hw_use_polling(hw)) {\n\t\thw->is_active = true;\n\t\twake_up(&hw->wait_active);\n\t}\n\n\tmutex_unlock(&dev->device_lock);\n\n\tirq_ret = mei_me_irq_thread_handler(1, dev);\n\tif (irq_ret != IRQ_HANDLED)\n\t\tdev_err(dev->dev, \"thread handler fail %d\\n\", irq_ret);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mei_gsc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(mei_gsc_pm_suspend,\n\t\t\t\tmei_gsc_pm_resume)\n\tSET_RUNTIME_PM_OPS(mei_gsc_pm_runtime_suspend,\n\t\t\t   mei_gsc_pm_runtime_resume,\n\t\t\t   mei_gsc_pm_runtime_idle)\n};\n\nstatic const struct auxiliary_device_id mei_gsc_id_table[] = {\n\t{\n\t\t.name = \"i915.mei-gsc\",\n\t\t.driver_data = MEI_ME_GSC_CFG,\n\n\t},\n\t{\n\t\t.name = \"i915.mei-gscfi\",\n\t\t.driver_data = MEI_ME_GSCFI_CFG,\n\t},\n\t{\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(auxiliary, mei_gsc_id_table);\n\nstatic struct auxiliary_driver mei_gsc_driver = {\n\t.probe\t= mei_gsc_probe,\n\t.remove = mei_gsc_remove,\n\t.driver = {\n\t\t \n\t\t.pm = &mei_gsc_pm_ops,\n\t},\n\t.id_table = mei_gsc_id_table\n};\nmodule_auxiliary_driver(mei_gsc_driver);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_ALIAS(\"auxiliary:i915.mei-gsc\");\nMODULE_ALIAS(\"auxiliary:i915.mei-gscfi\");\nMODULE_DESCRIPTION(\"Intel(R) Graphics System Controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}