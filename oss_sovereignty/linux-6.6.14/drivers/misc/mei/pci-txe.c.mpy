{
  "module_name": "pci-txe.c",
  "hash_id": "08a6000a4ae4a2a670ab1ae410713b1f9db4ac5cd5616c388b8d04678008b7c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mei/pci-txe.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/mei.h>\n\n\n#include \"mei_dev.h\"\n#include \"hw-txe.h\"\n\nstatic const struct pci_device_id mei_txe_pci_tbl[] = {\n\t{PCI_VDEVICE(INTEL, 0x0F18)},  \n\t{PCI_VDEVICE(INTEL, 0x2298)},  \n\n\t{0, }\n};\nMODULE_DEVICE_TABLE(pci, mei_txe_pci_tbl);\n\n#ifdef CONFIG_PM\nstatic inline void mei_txe_set_pm_domain(struct mei_device *dev);\nstatic inline void mei_txe_unset_pm_domain(struct mei_device *dev);\n#else\nstatic inline void mei_txe_set_pm_domain(struct mei_device *dev) {}\nstatic inline void mei_txe_unset_pm_domain(struct mei_device *dev) {}\n#endif  \n\n \nstatic int mei_txe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct mei_device *dev;\n\tstruct mei_txe_hw *hw;\n\tconst int mask = BIT(SEC_BAR) | BIT(BRIDGE_BAR);\n\tint err;\n\n\t \n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable pci device.\\n\");\n\t\tgoto end;\n\t}\n\t \n\tpci_set_master(pdev);\n\t \n\terr = pcim_iomap_regions(pdev, mask, KBUILD_MODNAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to get pci regions.\\n\");\n\t\tgoto end;\n\t}\n\n\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(36));\n\tif (err) {\n\t\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"No suitable DMA available.\\n\");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t \n\tdev = mei_txe_dev_init(pdev);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto end;\n\t}\n\thw = to_txe_hw(dev);\n\thw->mem_addr = pcim_iomap_table(pdev);\n\n\tpci_enable_msi(pdev);\n\n\t \n\tmei_clear_interrupts(dev);\n\n\t \n\tif (pci_dev_msi_enabled(pdev))\n\t\terr = request_threaded_irq(pdev->irq,\n\t\t\tNULL,\n\t\t\tmei_txe_irq_thread_handler,\n\t\t\tIRQF_ONESHOT, KBUILD_MODNAME, dev);\n\telse\n\t\terr = request_threaded_irq(pdev->irq,\n\t\t\tmei_txe_irq_quick_handler,\n\t\t\tmei_txe_irq_thread_handler,\n\t\t\tIRQF_SHARED, KBUILD_MODNAME, dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"mei: request_threaded_irq failure. irq = %d\\n\",\n\t\t\tpdev->irq);\n\t\tgoto end;\n\t}\n\n\tif (mei_start(dev)) {\n\t\tdev_err(&pdev->dev, \"init hw failure.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto release_irq;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, MEI_TXI_RPM_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\n\terr = mei_register(dev, &pdev->dev);\n\tif (err)\n\t\tgoto stop;\n\n\tpci_set_drvdata(pdev, dev);\n\n\t \n\tdev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_NO_DIRECT_COMPLETE);\n\n\t \n\tmei_txe_set_pm_domain(dev);\n\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\treturn 0;\n\nstop:\n\tmei_stop(dev);\nrelease_irq:\n\tmei_cancel_work(dev);\n\tmei_disable_interrupts(dev);\n\tfree_irq(pdev->irq, dev);\nend:\n\tdev_err(&pdev->dev, \"initialization failed.\\n\");\n\treturn err;\n}\n\n \nstatic void mei_txe_shutdown(struct pci_dev *pdev)\n{\n\tstruct mei_device *dev;\n\n\tdev = pci_get_drvdata(pdev);\n\tif (!dev)\n\t\treturn;\n\n\tdev_dbg(&pdev->dev, \"shutdown\\n\");\n\tmei_stop(dev);\n\n\tmei_txe_unset_pm_domain(dev);\n\n\tmei_disable_interrupts(dev);\n\tfree_irq(pdev->irq, dev);\n}\n\n \nstatic void mei_txe_remove(struct pci_dev *pdev)\n{\n\tstruct mei_device *dev;\n\n\tdev = pci_get_drvdata(pdev);\n\tif (!dev) {\n\t\tdev_err(&pdev->dev, \"mei: dev == NULL\\n\");\n\t\treturn;\n\t}\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\n\tmei_stop(dev);\n\n\tmei_txe_unset_pm_domain(dev);\n\n\tmei_disable_interrupts(dev);\n\tfree_irq(pdev->irq, dev);\n\n\tmei_deregister(dev);\n}\n\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mei_txe_pci_suspend(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct mei_device *dev = pci_get_drvdata(pdev);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdev_dbg(&pdev->dev, \"suspend\\n\");\n\n\tmei_stop(dev);\n\n\tmei_disable_interrupts(dev);\n\n\tfree_irq(pdev->irq, dev);\n\tpci_disable_msi(pdev);\n\n\treturn 0;\n}\n\nstatic int mei_txe_pci_resume(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct mei_device *dev;\n\tint err;\n\n\tdev = pci_get_drvdata(pdev);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tpci_enable_msi(pdev);\n\n\tmei_clear_interrupts(dev);\n\n\t \n\tif (pci_dev_msi_enabled(pdev))\n\t\terr = request_threaded_irq(pdev->irq,\n\t\t\tNULL,\n\t\t\tmei_txe_irq_thread_handler,\n\t\t\tIRQF_ONESHOT, KBUILD_MODNAME, dev);\n\telse\n\t\terr = request_threaded_irq(pdev->irq,\n\t\t\tmei_txe_irq_quick_handler,\n\t\t\tmei_txe_irq_thread_handler,\n\t\t\tIRQF_SHARED, KBUILD_MODNAME, dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"request_threaded_irq failed: irq = %d.\\n\",\n\t\t\t\tpdev->irq);\n\t\treturn err;\n\t}\n\n\terr = mei_restart(dev);\n\n\treturn err;\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int mei_txe_pm_runtime_idle(struct device *device)\n{\n\tstruct mei_device *dev;\n\n\tdev_dbg(device, \"rpm: txe: runtime_idle\\n\");\n\n\tdev = dev_get_drvdata(device);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tif (mei_write_is_idle(dev))\n\t\tpm_runtime_autosuspend(device);\n\n\treturn -EBUSY;\n}\nstatic int mei_txe_pm_runtime_suspend(struct device *device)\n{\n\tstruct mei_device *dev;\n\tint ret;\n\n\tdev_dbg(device, \"rpm: txe: runtime suspend\\n\");\n\n\tdev = dev_get_drvdata(device);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->device_lock);\n\n\tif (mei_write_is_idle(dev))\n\t\tret = mei_txe_aliveness_set_sync(dev, 0);\n\telse\n\t\tret = -EAGAIN;\n\n\t \n\n\tdev_dbg(device, \"rpm: txe: runtime suspend ret=%d\\n\", ret);\n\n\tmutex_unlock(&dev->device_lock);\n\n\tif (ret && ret != -EAGAIN)\n\t\tschedule_work(&dev->reset_work);\n\n\treturn ret;\n}\n\nstatic int mei_txe_pm_runtime_resume(struct device *device)\n{\n\tstruct mei_device *dev;\n\tint ret;\n\n\tdev_dbg(device, \"rpm: txe: runtime resume\\n\");\n\n\tdev = dev_get_drvdata(device);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->device_lock);\n\n\tmei_enable_interrupts(dev);\n\n\tret = mei_txe_aliveness_set_sync(dev, 1);\n\n\tmutex_unlock(&dev->device_lock);\n\n\tdev_dbg(device, \"rpm: txe: runtime resume ret = %d\\n\", ret);\n\n\tif (ret)\n\t\tschedule_work(&dev->reset_work);\n\n\treturn ret;\n}\n\n \nstatic inline void mei_txe_set_pm_domain(struct mei_device *dev)\n{\n\tstruct pci_dev *pdev  = to_pci_dev(dev->dev);\n\n\tif (pdev->dev.bus && pdev->dev.bus->pm) {\n\t\tdev->pg_domain.ops = *pdev->dev.bus->pm;\n\n\t\tdev->pg_domain.ops.runtime_suspend = mei_txe_pm_runtime_suspend;\n\t\tdev->pg_domain.ops.runtime_resume = mei_txe_pm_runtime_resume;\n\t\tdev->pg_domain.ops.runtime_idle = mei_txe_pm_runtime_idle;\n\n\t\tdev_pm_domain_set(&pdev->dev, &dev->pg_domain);\n\t}\n}\n\n \nstatic inline void mei_txe_unset_pm_domain(struct mei_device *dev)\n{\n\t \n\tdev_pm_domain_set(dev->dev, NULL);\n}\n\nstatic const struct dev_pm_ops mei_txe_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(mei_txe_pci_suspend,\n\t\t\t\tmei_txe_pci_resume)\n\tSET_RUNTIME_PM_OPS(\n\t\tmei_txe_pm_runtime_suspend,\n\t\tmei_txe_pm_runtime_resume,\n\t\tmei_txe_pm_runtime_idle)\n};\n\n#define MEI_TXE_PM_OPS\t(&mei_txe_pm_ops)\n#else\n#define MEI_TXE_PM_OPS\tNULL\n#endif  \n\n \nstatic struct pci_driver mei_txe_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = mei_txe_pci_tbl,\n\t.probe = mei_txe_probe,\n\t.remove = mei_txe_remove,\n\t.shutdown = mei_txe_shutdown,\n\t.driver.pm = MEI_TXE_PM_OPS,\n};\n\nmodule_pci_driver(mei_txe_driver);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_DESCRIPTION(\"Intel(R) Trusted Execution Environment Interface\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}