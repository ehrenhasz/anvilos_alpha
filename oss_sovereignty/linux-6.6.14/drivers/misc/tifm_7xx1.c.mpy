{
  "module_name": "tifm_7xx1.c",
  "hash_id": "ec1b7c3ff0f84b5302849298b29a4d5be089f921c4ec759264e4a8addecc95f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/tifm_7xx1.c",
  "human_readable_source": "\n \n\n#include <linux/tifm.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n\n#define DRIVER_NAME \"tifm_7xx1\"\n#define DRIVER_VERSION \"0.8\"\n\n#define TIFM_IRQ_ENABLE           0x80000000\n#define TIFM_IRQ_SOCKMASK(x)      (x)\n#define TIFM_IRQ_CARDMASK(x)      ((x) << 8)\n#define TIFM_IRQ_FIFOMASK(x)      ((x) << 16)\n#define TIFM_IRQ_SETALL           0xffffffff\n\nstatic void tifm_7xx1_dummy_eject(struct tifm_adapter *fm,\n\t\t\t\t  struct tifm_dev *sock)\n{\n}\n\nstatic void tifm_7xx1_eject(struct tifm_adapter *fm, struct tifm_dev *sock)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fm->lock, flags);\n\tfm->socket_change_set |= 1 << sock->socket_id;\n\ttifm_queue_work(&fm->media_switcher);\n\tspin_unlock_irqrestore(&fm->lock, flags);\n}\n\nstatic irqreturn_t tifm_7xx1_isr(int irq, void *dev_id)\n{\n\tstruct tifm_adapter *fm = dev_id;\n\tstruct tifm_dev *sock;\n\tunsigned int irq_status, cnt;\n\n\tspin_lock(&fm->lock);\n\tirq_status = readl(fm->addr + FM_INTERRUPT_STATUS);\n\tif (irq_status == 0 || irq_status == (~0)) {\n\t\tspin_unlock(&fm->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (irq_status & TIFM_IRQ_ENABLE) {\n\t\twritel(TIFM_IRQ_ENABLE, fm->addr + FM_CLEAR_INTERRUPT_ENABLE);\n\n\t\tfor (cnt = 0; cnt < fm->num_sockets; cnt++) {\n\t\t\tsock = fm->sockets[cnt];\n\t\t\tif (sock) {\n\t\t\t\tif ((irq_status >> cnt) & TIFM_IRQ_FIFOMASK(1))\n\t\t\t\t\tsock->data_event(sock);\n\t\t\t\tif ((irq_status >> cnt) & TIFM_IRQ_CARDMASK(1))\n\t\t\t\t\tsock->card_event(sock);\n\t\t\t}\n\t\t}\n\n\t\tfm->socket_change_set |= irq_status\n\t\t\t\t\t & ((1 << fm->num_sockets) - 1);\n\t}\n\twritel(irq_status, fm->addr + FM_INTERRUPT_STATUS);\n\n\tif (fm->finish_me)\n\t\tcomplete_all(fm->finish_me);\n\telse if (!fm->socket_change_set)\n\t\twritel(TIFM_IRQ_ENABLE, fm->addr + FM_SET_INTERRUPT_ENABLE);\n\telse\n\t\ttifm_queue_work(&fm->media_switcher);\n\n\tspin_unlock(&fm->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned char tifm_7xx1_toggle_sock_power(char __iomem *sock_addr)\n{\n\tunsigned int s_state;\n\tint cnt;\n\n\twritel(0x0e00, sock_addr + SOCK_CONTROL);\n\n\tfor (cnt = 16; cnt <= 256; cnt <<= 1) {\n\t\tif (!(TIFM_SOCK_STATE_POWERED\n\t\t      & readl(sock_addr + SOCK_PRESENT_STATE)))\n\t\t\tbreak;\n\n\t\tmsleep(cnt);\n\t}\n\n\ts_state = readl(sock_addr + SOCK_PRESENT_STATE);\n\tif (!(TIFM_SOCK_STATE_OCCUPIED & s_state))\n\t\treturn 0;\n\n\twritel(readl(sock_addr + SOCK_CONTROL) | TIFM_CTRL_LED,\n\t       sock_addr + SOCK_CONTROL);\n\n\t \n\tif (((readl(sock_addr + SOCK_PRESENT_STATE) >> 4) & 7)\n\t    == TIFM_TYPE_XD)\n\t\tmsleep(40);\n\n\twritel((s_state & TIFM_CTRL_POWER_MASK) | 0x0c00,\n\t       sock_addr + SOCK_CONTROL);\n\t \n\tmsleep(20);\n\tfor (cnt = 16; cnt <= 256; cnt <<= 1) {\n\t\tif ((TIFM_SOCK_STATE_POWERED\n\t\t     & readl(sock_addr + SOCK_PRESENT_STATE)))\n\t\t\tbreak;\n\n\t\tmsleep(cnt);\n\t}\n\n\twritel(readl(sock_addr + SOCK_CONTROL) & (~TIFM_CTRL_LED),\n\t       sock_addr + SOCK_CONTROL);\n\n\treturn (readl(sock_addr + SOCK_PRESENT_STATE) >> 4) & 7;\n}\n\ninline static void tifm_7xx1_sock_power_off(char __iomem *sock_addr)\n{\n\twritel((~TIFM_CTRL_POWER_MASK) & readl(sock_addr + SOCK_CONTROL),\n\t       sock_addr + SOCK_CONTROL);\n}\n\ninline static char __iomem *\ntifm_7xx1_sock_addr(char __iomem *base_addr, unsigned int sock_num)\n{\n\treturn base_addr + ((sock_num + 1) << 10);\n}\n\nstatic void tifm_7xx1_switch_media(struct work_struct *work)\n{\n\tstruct tifm_adapter *fm = container_of(work, struct tifm_adapter,\n\t\t\t\t\t       media_switcher);\n\tstruct tifm_dev *sock;\n\tchar __iomem *sock_addr;\n\tunsigned long flags;\n\tunsigned char media_id;\n\tunsigned int socket_change_set, cnt;\n\n\tspin_lock_irqsave(&fm->lock, flags);\n\tsocket_change_set = fm->socket_change_set;\n\tfm->socket_change_set = 0;\n\n\tdev_dbg(fm->dev.parent, \"checking media set %x\\n\",\n\t\tsocket_change_set);\n\n\tif (!socket_change_set) {\n\t\tspin_unlock_irqrestore(&fm->lock, flags);\n\t\treturn;\n\t}\n\n\tfor (cnt = 0; cnt < fm->num_sockets; cnt++) {\n\t\tif (!(socket_change_set & (1 << cnt)))\n\t\t\tcontinue;\n\t\tsock = fm->sockets[cnt];\n\t\tif (sock) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"%s : demand removing card from socket %u:%u\\n\",\n\t\t\t       dev_name(&fm->dev), fm->id, cnt);\n\t\t\tfm->sockets[cnt] = NULL;\n\t\t\tsock_addr = sock->addr;\n\t\t\tspin_unlock_irqrestore(&fm->lock, flags);\n\t\t\tdevice_unregister(&sock->dev);\n\t\t\tspin_lock_irqsave(&fm->lock, flags);\n\t\t\ttifm_7xx1_sock_power_off(sock_addr);\n\t\t\twritel(0x0e00, sock_addr + SOCK_CONTROL);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&fm->lock, flags);\n\n\t\tmedia_id = tifm_7xx1_toggle_sock_power(\n\t\t\t\ttifm_7xx1_sock_addr(fm->addr, cnt));\n\n\t\t\n\t\tsock = tifm_alloc_device(fm, cnt, media_id);\n\t\tif (sock) {\n\t\t\tsock->addr = tifm_7xx1_sock_addr(fm->addr, cnt);\n\n\t\t\tif (!device_register(&sock->dev)) {\n\t\t\t\tspin_lock_irqsave(&fm->lock, flags);\n\t\t\t\tif (!fm->sockets[cnt]) {\n\t\t\t\t\tfm->sockets[cnt] = sock;\n\t\t\t\t\tsock = NULL;\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&fm->lock, flags);\n\t\t\t}\n\t\t\tif (sock)\n\t\t\t\tput_device(&sock->dev);\n\t\t}\n\t\tspin_lock_irqsave(&fm->lock, flags);\n\t}\n\n\twritel(TIFM_IRQ_FIFOMASK(socket_change_set)\n\t       | TIFM_IRQ_CARDMASK(socket_change_set),\n\t       fm->addr + FM_CLEAR_INTERRUPT_ENABLE);\n\n\twritel(TIFM_IRQ_FIFOMASK(socket_change_set)\n\t       | TIFM_IRQ_CARDMASK(socket_change_set),\n\t       fm->addr + FM_SET_INTERRUPT_ENABLE);\n\n\twritel(TIFM_IRQ_ENABLE, fm->addr + FM_SET_INTERRUPT_ENABLE);\n\tspin_unlock_irqrestore(&fm->lock, flags);\n}\n\nstatic int __maybe_unused tifm_7xx1_suspend(struct device *dev_d)\n{\n\tstruct pci_dev *dev = to_pci_dev(dev_d);\n\tstruct tifm_adapter *fm = pci_get_drvdata(dev);\n\tint cnt;\n\n\tdev_dbg(&dev->dev, \"suspending host\\n\");\n\n\tfor (cnt = 0; cnt < fm->num_sockets; cnt++) {\n\t\tif (fm->sockets[cnt])\n\t\t\ttifm_7xx1_sock_power_off(fm->sockets[cnt]->addr);\n\t}\n\n\tdevice_wakeup_disable(dev_d);\n\treturn 0;\n}\n\nstatic int __maybe_unused tifm_7xx1_resume(struct device *dev_d)\n{\n\tstruct pci_dev *dev = to_pci_dev(dev_d);\n\tstruct tifm_adapter *fm = pci_get_drvdata(dev);\n\tint rc;\n\tunsigned long timeout;\n\tunsigned int good_sockets = 0, bad_sockets = 0;\n\tunsigned long flags;\n\t \n\tunsigned char new_ids[4];\n\tDECLARE_COMPLETION_ONSTACK(finish_resume);\n\n\tif (WARN_ON(fm->num_sockets > ARRAY_SIZE(new_ids)))\n\t\treturn -ENXIO;\n\n\tpci_set_master(dev);\n\n\tdev_dbg(&dev->dev, \"resuming host\\n\");\n\n\tfor (rc = 0; rc < fm->num_sockets; rc++)\n\t\tnew_ids[rc] = tifm_7xx1_toggle_sock_power(\n\t\t\t\t\ttifm_7xx1_sock_addr(fm->addr, rc));\n\tspin_lock_irqsave(&fm->lock, flags);\n\tfor (rc = 0; rc < fm->num_sockets; rc++) {\n\t\tif (fm->sockets[rc]) {\n\t\t\tif (fm->sockets[rc]->type == new_ids[rc])\n\t\t\t\tgood_sockets |= 1 << rc;\n\t\t\telse\n\t\t\t\tbad_sockets |= 1 << rc;\n\t\t}\n\t}\n\n\twritel(TIFM_IRQ_ENABLE | TIFM_IRQ_SOCKMASK((1 << fm->num_sockets) - 1),\n\t       fm->addr + FM_SET_INTERRUPT_ENABLE);\n\tdev_dbg(&dev->dev, \"change sets on resume: good %x, bad %x\\n\",\n\t\tgood_sockets, bad_sockets);\n\n\tfm->socket_change_set = 0;\n\tif (good_sockets) {\n\t\tfm->finish_me = &finish_resume;\n\t\tspin_unlock_irqrestore(&fm->lock, flags);\n\t\ttimeout = wait_for_completion_timeout(&finish_resume, HZ);\n\t\tdev_dbg(&dev->dev, \"wait returned %lu\\n\", timeout);\n\t\twritel(TIFM_IRQ_FIFOMASK(good_sockets)\n\t\t       | TIFM_IRQ_CARDMASK(good_sockets),\n\t\t       fm->addr + FM_CLEAR_INTERRUPT_ENABLE);\n\t\twritel(TIFM_IRQ_FIFOMASK(good_sockets)\n\t\t       | TIFM_IRQ_CARDMASK(good_sockets),\n\t\t       fm->addr + FM_SET_INTERRUPT_ENABLE);\n\t\tspin_lock_irqsave(&fm->lock, flags);\n\t\tfm->finish_me = NULL;\n\t\tfm->socket_change_set ^= good_sockets & fm->socket_change_set;\n\t}\n\n\tfm->socket_change_set |= bad_sockets;\n\tif (fm->socket_change_set)\n\t\ttifm_queue_work(&fm->media_switcher);\n\n\tspin_unlock_irqrestore(&fm->lock, flags);\n\twritel(TIFM_IRQ_ENABLE,\n\t       fm->addr + FM_SET_INTERRUPT_ENABLE);\n\n\treturn 0;\n}\n\nstatic int tifm_7xx1_dummy_has_ms_pif(struct tifm_adapter *fm,\n\t\t\t\t      struct tifm_dev *sock)\n{\n\treturn 0;\n}\n\nstatic int tifm_7xx1_has_ms_pif(struct tifm_adapter *fm, struct tifm_dev *sock)\n{\n\tif (((fm->num_sockets == 4) && (sock->socket_id == 2))\n\t    || ((fm->num_sockets == 2) && (sock->socket_id == 0)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int tifm_7xx1_probe(struct pci_dev *dev,\n\t\t\t   const struct pci_device_id *dev_id)\n{\n\tstruct tifm_adapter *fm;\n\tint pci_dev_busy = 0;\n\tint rc;\n\n\trc = dma_set_mask(&dev->dev, DMA_BIT_MASK(32));\n\tif (rc)\n\t\treturn rc;\n\n\trc = pci_enable_device(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_set_master(dev);\n\n\trc = pci_request_regions(dev, DRIVER_NAME);\n\tif (rc) {\n\t\tpci_dev_busy = 1;\n\t\tgoto err_out;\n\t}\n\n\tpci_intx(dev, 1);\n\n\tfm = tifm_alloc_adapter(dev->device == PCI_DEVICE_ID_TI_XX21_XX11_FM\n\t\t\t\t? 4 : 2, &dev->dev);\n\tif (!fm) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_int;\n\t}\n\n\tINIT_WORK(&fm->media_switcher, tifm_7xx1_switch_media);\n\tfm->eject = tifm_7xx1_eject;\n\tfm->has_ms_pif = tifm_7xx1_has_ms_pif;\n\tpci_set_drvdata(dev, fm);\n\n\tfm->addr = pci_ioremap_bar(dev, 0);\n\tif (!fm->addr) {\n\t\trc = -ENODEV;\n\t\tgoto err_out_free;\n\t}\n\n\trc = request_irq(dev->irq, tifm_7xx1_isr, IRQF_SHARED, DRIVER_NAME, fm);\n\tif (rc)\n\t\tgoto err_out_unmap;\n\n\trc = tifm_add_adapter(fm);\n\tif (rc)\n\t\tgoto err_out_irq;\n\n\twritel(TIFM_IRQ_ENABLE | TIFM_IRQ_SOCKMASK((1 << fm->num_sockets) - 1),\n\t       fm->addr + FM_CLEAR_INTERRUPT_ENABLE);\n\twritel(TIFM_IRQ_ENABLE | TIFM_IRQ_SOCKMASK((1 << fm->num_sockets) - 1),\n\t       fm->addr + FM_SET_INTERRUPT_ENABLE);\n\treturn 0;\n\nerr_out_irq:\n\tfree_irq(dev->irq, fm);\nerr_out_unmap:\n\tiounmap(fm->addr);\nerr_out_free:\n\ttifm_free_adapter(fm);\nerr_out_int:\n\tpci_intx(dev, 0);\n\tpci_release_regions(dev);\nerr_out:\n\tif (!pci_dev_busy)\n\t\tpci_disable_device(dev);\n\treturn rc;\n}\n\nstatic void tifm_7xx1_remove(struct pci_dev *dev)\n{\n\tstruct tifm_adapter *fm = pci_get_drvdata(dev);\n\tint cnt;\n\n\tfm->eject = tifm_7xx1_dummy_eject;\n\tfm->has_ms_pif = tifm_7xx1_dummy_has_ms_pif;\n\twritel(TIFM_IRQ_SETALL, fm->addr + FM_CLEAR_INTERRUPT_ENABLE);\n\tfree_irq(dev->irq, fm);\n\n\ttifm_remove_adapter(fm);\n\n\tfor (cnt = 0; cnt < fm->num_sockets; cnt++)\n\t\ttifm_7xx1_sock_power_off(tifm_7xx1_sock_addr(fm->addr, cnt));\n\n\tiounmap(fm->addr);\n\tpci_intx(dev, 0);\n\tpci_release_regions(dev);\n\n\tpci_disable_device(dev);\n\ttifm_free_adapter(fm);\n}\n\nstatic const struct pci_device_id tifm_7xx1_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_XX21_XX11_FM, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },  \n        { PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_XX12_FM, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_XX20_FM, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ }\n};\n\nstatic SIMPLE_DEV_PM_OPS(tifm_7xx1_pm_ops, tifm_7xx1_suspend, tifm_7xx1_resume);\n\nstatic struct pci_driver tifm_7xx1_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = tifm_7xx1_pci_tbl,\n\t.probe = tifm_7xx1_probe,\n\t.remove = tifm_7xx1_remove,\n\t.driver.pm = &tifm_7xx1_pm_ops,\n};\n\nmodule_pci_driver(tifm_7xx1_driver);\nMODULE_AUTHOR(\"Alex Dubov\");\nMODULE_DESCRIPTION(\"TI FlashMedia host driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, tifm_7xx1_pci_tbl);\nMODULE_VERSION(DRIVER_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}