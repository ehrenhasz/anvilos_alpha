{
  "module_name": "mchp_pci1xxxx_gp.c",
  "hash_id": "8d394a85bfa03bb1c45c6285a4fa443573fac1d0ac2f00328219d7242821d72f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mchp_pci1xxxx/mchp_pci1xxxx_gp.c",
  "human_readable_source": "\n\n\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/idr.h>\n#include \"mchp_pci1xxxx_gp.h\"\n\nstruct aux_bus_device {\n\tstruct auxiliary_device_wrapper *aux_device_wrapper[2];\n};\n\nstatic DEFINE_IDA(gp_client_ida);\nstatic const char aux_dev_otp_e2p_name[15] = \"gp_otp_e2p\";\nstatic const char aux_dev_gpio_name[15] = \"gp_gpio\";\n\nstatic void gp_auxiliary_device_release(struct device *dev)\n{\n\tstruct auxiliary_device_wrapper *aux_device_wrapper =\n\t\t(struct auxiliary_device_wrapper *)container_of(dev,\n\t\t\t\tstruct auxiliary_device_wrapper, aux_dev.dev);\n\n\tida_free(&gp_client_ida, aux_device_wrapper->aux_dev.id);\n\tkfree(aux_device_wrapper);\n}\n\nstatic int gp_aux_bus_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct aux_bus_device *aux_bus;\n\tint retval;\n\n\tretval = pcim_enable_device(pdev);\n\tif (retval)\n\t\treturn retval;\n\n\taux_bus = devm_kzalloc(&pdev->dev, sizeof(*aux_bus), GFP_KERNEL);\n\tif (!aux_bus)\n\t\treturn -ENOMEM;\n\n\taux_bus->aux_device_wrapper[0] = kzalloc(sizeof(*aux_bus->aux_device_wrapper[0]),\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!aux_bus->aux_device_wrapper[0])\n\t\treturn -ENOMEM;\n\n\tretval = ida_alloc(&gp_client_ida, GFP_KERNEL);\n\tif (retval < 0)\n\t\tgoto err_ida_alloc_0;\n\n\taux_bus->aux_device_wrapper[0]->aux_dev.name = aux_dev_otp_e2p_name;\n\taux_bus->aux_device_wrapper[0]->aux_dev.dev.parent = &pdev->dev;\n\taux_bus->aux_device_wrapper[0]->aux_dev.dev.release = gp_auxiliary_device_release;\n\taux_bus->aux_device_wrapper[0]->aux_dev.id = retval;\n\n\taux_bus->aux_device_wrapper[0]->gp_aux_data.region_start = pci_resource_start(pdev, 0);\n\taux_bus->aux_device_wrapper[0]->gp_aux_data.region_length = pci_resource_end(pdev, 0);\n\n\tretval = auxiliary_device_init(&aux_bus->aux_device_wrapper[0]->aux_dev);\n\tif (retval < 0)\n\t\tgoto err_aux_dev_init_0;\n\n\tretval = auxiliary_device_add(&aux_bus->aux_device_wrapper[0]->aux_dev);\n\tif (retval)\n\t\tgoto err_aux_dev_add_0;\n\n\taux_bus->aux_device_wrapper[1] = kzalloc(sizeof(*aux_bus->aux_device_wrapper[1]),\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!aux_bus->aux_device_wrapper[1])\n\t\treturn -ENOMEM;\n\n\tretval = ida_alloc(&gp_client_ida, GFP_KERNEL);\n\tif (retval < 0)\n\t\tgoto err_ida_alloc_1;\n\n\taux_bus->aux_device_wrapper[1]->aux_dev.name = aux_dev_gpio_name;\n\taux_bus->aux_device_wrapper[1]->aux_dev.dev.parent = &pdev->dev;\n\taux_bus->aux_device_wrapper[1]->aux_dev.dev.release = gp_auxiliary_device_release;\n\taux_bus->aux_device_wrapper[1]->aux_dev.id = retval;\n\n\taux_bus->aux_device_wrapper[1]->gp_aux_data.region_start = pci_resource_start(pdev, 0);\n\taux_bus->aux_device_wrapper[1]->gp_aux_data.region_length = pci_resource_end(pdev, 0);\n\n\tretval = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\n\tif (retval < 0)\n\t\tgoto err_aux_dev_init_1;\n\n\tretval = pci_irq_vector(pdev, 0);\n\tif (retval < 0)\n\t\tgoto err_aux_dev_init_1;\n\n\tpdev->irq = retval;\n\taux_bus->aux_device_wrapper[1]->gp_aux_data.irq_num = pdev->irq;\n\n\tretval = auxiliary_device_init(&aux_bus->aux_device_wrapper[1]->aux_dev);\n\tif (retval < 0)\n\t\tgoto err_aux_dev_init_1;\n\n\tretval = auxiliary_device_add(&aux_bus->aux_device_wrapper[1]->aux_dev);\n\tif (retval)\n\t\tgoto err_aux_dev_add_1;\n\n\tpci_set_drvdata(pdev, aux_bus);\n\tpci_set_master(pdev);\n\n\treturn 0;\n\nerr_aux_dev_add_1:\n\tauxiliary_device_uninit(&aux_bus->aux_device_wrapper[1]->aux_dev);\n\nerr_aux_dev_init_1:\n\tida_free(&gp_client_ida, aux_bus->aux_device_wrapper[1]->aux_dev.id);\n\nerr_ida_alloc_1:\n\tkfree(aux_bus->aux_device_wrapper[1]);\n\nerr_aux_dev_add_0:\n\tauxiliary_device_uninit(&aux_bus->aux_device_wrapper[0]->aux_dev);\n\nerr_aux_dev_init_0:\n\tida_free(&gp_client_ida, aux_bus->aux_device_wrapper[0]->aux_dev.id);\n\nerr_ida_alloc_0:\n\tkfree(aux_bus->aux_device_wrapper[0]);\n\n\treturn retval;\n}\n\nstatic void gp_aux_bus_remove(struct pci_dev *pdev)\n{\n\tstruct aux_bus_device *aux_bus = pci_get_drvdata(pdev);\n\n\tauxiliary_device_delete(&aux_bus->aux_device_wrapper[0]->aux_dev);\n\tauxiliary_device_uninit(&aux_bus->aux_device_wrapper[0]->aux_dev);\n\tauxiliary_device_delete(&aux_bus->aux_device_wrapper[1]->aux_dev);\n\tauxiliary_device_uninit(&aux_bus->aux_device_wrapper[1]->aux_dev);\n}\n\nstatic const struct pci_device_id pci1xxxx_tbl[] = {\n\t{ PCI_DEVICE(0x1055, 0xA005) },\n\t{ PCI_DEVICE(0x1055, 0xA015) },\n\t{ PCI_DEVICE(0x1055, 0xA025) },\n\t{ PCI_DEVICE(0x1055, 0xA035) },\n\t{ PCI_DEVICE(0x1055, 0xA045) },\n\t{ PCI_DEVICE(0x1055, 0xA055) },\n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, pci1xxxx_tbl);\n\nstatic struct pci_driver pci1xxxx_gp_driver = {\n\t.name = \"PCI1xxxxGP\",\n\t.id_table = pci1xxxx_tbl,\n\t.probe = gp_aux_bus_probe,\n\t.remove = gp_aux_bus_remove,\n};\n\nmodule_pci_driver(pci1xxxx_gp_driver);\n\nMODULE_DESCRIPTION(\"Microchip Technology Inc. PCI1xxxx GP expander\");\nMODULE_AUTHOR(\"Kumaravel Thiagarajan <kumaravel.thiagarajan@microchip.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}