{
  "module_name": "mchp_pci1xxxx_gpio.c",
  "hash_id": "4479419d03f01429f62b0b3b292bcf0e4125ad046d55503bc8edc7e46e854d4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mchp_pci1xxxx/mchp_pci1xxxx_gpio.c",
  "human_readable_source": "\n\n\n\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/gpio/driver.h>\n#include <linux/bio.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n\n#include \"mchp_pci1xxxx_gp.h\"\n\n#define PCI1XXXX_NR_PINS\t\t93\n#define PERI_GEN_RESET\t\t\t0\n#define OUT_EN_OFFSET(x)\t\t((((x) / 32) * 4) + 0x400)\n#define INP_EN_OFFSET(x)\t\t((((x) / 32) * 4) + 0x400 + 0x10)\n#define OUT_OFFSET(x)\t\t\t((((x) / 32) * 4) + 0x400 + 0x20)\n#define INP_OFFSET(x)\t\t\t((((x) / 32) * 4) + 0x400 + 0x30)\n#define PULLUP_OFFSET(x)\t\t((((x) / 32) * 4) + 0x400 + 0x40)\n#define PULLDOWN_OFFSET(x)\t\t((((x) / 32) * 4) + 0x400 + 0x50)\n#define OPENDRAIN_OFFSET(x)\t\t((((x) / 32) * 4) + 0x400 + 0x60)\n#define WAKEMASK_OFFSET(x)\t\t((((x) / 32) * 4) + 0x400 + 0x70)\n#define MODE_OFFSET(x)\t\t\t((((x) / 32) * 4) + 0x400 + 0x80)\n#define INTR_LO_TO_HI_EDGE_CONFIG(x)\t((((x) / 32) * 4) + 0x400 + 0x90)\n#define INTR_HI_TO_LO_EDGE_CONFIG(x)\t((((x) / 32) * 4) + 0x400 + 0xA0)\n#define INTR_LEVEL_CONFIG_OFFSET(x)\t((((x) / 32) * 4) + 0x400 + 0xB0)\n#define INTR_LEVEL_MASK_OFFSET(x)\t((((x) / 32) * 4) + 0x400 + 0xC0)\n#define INTR_STAT_OFFSET(x)\t\t((((x) / 32) * 4) + 0x400 + 0xD0)\n#define DEBOUNCE_OFFSET(x)\t\t((((x) / 32) * 4) + 0x400 + 0xE0)\n#define PIO_GLOBAL_CONFIG_OFFSET\t(0x400 + 0xF0)\n#define PIO_PCI_CTRL_REG_OFFSET\t(0x400 + 0xF4)\n#define INTR_MASK_OFFSET(x)\t\t((((x) / 32) * 4) + 0x400 + 0x100)\n#define INTR_STATUS_OFFSET(x)\t\t(((x) * 4) + 0x400 + 0xD0)\n\nstruct pci1xxxx_gpio {\n\tstruct auxiliary_device *aux_dev;\n\tvoid __iomem *reg_base;\n\tstruct gpio_chip gpio;\n\tspinlock_t lock;\n\tint irq_base;\n};\n\nstatic int pci1xxxx_gpio_get_direction(struct gpio_chip *gpio, unsigned int nr)\n{\n\tstruct pci1xxxx_gpio *priv = gpiochip_get_data(gpio);\n\tu32 data;\n\tint ret = -EINVAL;\n\n\tdata = readl(priv->reg_base + INP_EN_OFFSET(nr));\n\tif (data & BIT(nr % 32)) {\n\t\tret =  1;\n\t} else {\n\t\tdata = readl(priv->reg_base + OUT_EN_OFFSET(nr));\n\t\tif (data & BIT(nr % 32))\n\t\t\tret =  0;\n\t}\n\n\treturn ret;\n}\n\nstatic inline void pci1xxx_assign_bit(void __iomem *base_addr, unsigned int reg_offset,\n\t\t\t\t      unsigned int bitpos, bool set)\n{\n\tu32 data;\n\n\tdata = readl(base_addr + reg_offset);\n\tif (set)\n\t\tdata |= BIT(bitpos);\n\telse\n\t\tdata &= ~BIT(bitpos);\n\twritel(data, base_addr + reg_offset);\n}\n\nstatic int pci1xxxx_gpio_direction_input(struct gpio_chip *gpio, unsigned int nr)\n{\n\tstruct pci1xxxx_gpio *priv = gpiochip_get_data(gpio);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpci1xxx_assign_bit(priv->reg_base, INP_EN_OFFSET(nr), (nr % 32), true);\n\tpci1xxx_assign_bit(priv->reg_base, OUT_EN_OFFSET(nr), (nr % 32), false);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int pci1xxxx_gpio_get(struct gpio_chip *gpio, unsigned int nr)\n{\n\tstruct pci1xxxx_gpio *priv = gpiochip_get_data(gpio);\n\n\treturn (readl(priv->reg_base + INP_OFFSET(nr)) >> (nr % 32)) & 1;\n}\n\nstatic int pci1xxxx_gpio_direction_output(struct gpio_chip *gpio,\n\t\t\t\t\t  unsigned int nr, int val)\n{\n\tstruct pci1xxxx_gpio *priv = gpiochip_get_data(gpio);\n\tunsigned long flags;\n\tu32 data;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpci1xxx_assign_bit(priv->reg_base, INP_EN_OFFSET(nr), (nr % 32), false);\n\tpci1xxx_assign_bit(priv->reg_base, OUT_EN_OFFSET(nr), (nr % 32), true);\n\tdata = readl(priv->reg_base + OUT_OFFSET(nr));\n\tif (val)\n\t\tdata |= (1 << (nr % 32));\n\telse\n\t\tdata &= ~(1 << (nr % 32));\n\twritel(data, priv->reg_base + OUT_OFFSET(nr));\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic void pci1xxxx_gpio_set(struct gpio_chip *gpio,\n\t\t\t      unsigned int nr, int val)\n{\n\tstruct pci1xxxx_gpio *priv = gpiochip_get_data(gpio);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpci1xxx_assign_bit(priv->reg_base, OUT_OFFSET(nr), (nr % 32), val);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int pci1xxxx_gpio_set_config(struct gpio_chip *gpio, unsigned int offset,\n\t\t\t\t    unsigned long config)\n{\n\tstruct pci1xxxx_gpio *priv = gpiochip_get_data(gpio);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tpci1xxx_assign_bit(priv->reg_base, PULLUP_OFFSET(offset), (offset % 32), true);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tpci1xxx_assign_bit(priv->reg_base, PULLDOWN_OFFSET(offset), (offset % 32), true);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tpci1xxx_assign_bit(priv->reg_base, PULLUP_OFFSET(offset), (offset % 32), false);\n\t\tpci1xxx_assign_bit(priv->reg_base, PULLDOWN_OFFSET(offset), (offset % 32), false);\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tpci1xxx_assign_bit(priv->reg_base, OPENDRAIN_OFFSET(offset), (offset % 32), true);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret;\n}\n\nstatic void pci1xxxx_gpio_irq_ack(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct pci1xxxx_gpio *priv = gpiochip_get_data(chip);\n\tunsigned int gpio = irqd_to_hwirq(data);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpci1xxx_assign_bit(priv->reg_base, INTR_STAT_OFFSET(gpio), (gpio % 32), true);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void pci1xxxx_gpio_irq_set_mask(struct irq_data *data, bool set)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct pci1xxxx_gpio *priv = gpiochip_get_data(chip);\n\tunsigned int gpio = irqd_to_hwirq(data);\n\tunsigned long flags;\n\n\tif (!set)\n\t\tgpiochip_enable_irq(chip, gpio);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpci1xxx_assign_bit(priv->reg_base, INTR_MASK_OFFSET(gpio), (gpio % 32), set);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tif (set)\n\t\tgpiochip_disable_irq(chip, gpio);\n}\n\nstatic void pci1xxxx_gpio_irq_mask(struct irq_data *data)\n{\n\tpci1xxxx_gpio_irq_set_mask(data, true);\n}\n\nstatic void pci1xxxx_gpio_irq_unmask(struct irq_data *data)\n{\n\tpci1xxxx_gpio_irq_set_mask(data, false);\n}\n\nstatic int pci1xxxx_gpio_set_type(struct irq_data *data, unsigned int trigger_type)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct pci1xxxx_gpio *priv = gpiochip_get_data(chip);\n\tunsigned int gpio = irqd_to_hwirq(data);\n\tunsigned int bitpos = gpio % 32;\n\n\tif (trigger_type & IRQ_TYPE_EDGE_FALLING) {\n\t\tpci1xxx_assign_bit(priv->reg_base, INTR_HI_TO_LO_EDGE_CONFIG(gpio),\n\t\t\t\t   bitpos, false);\n\t\tpci1xxx_assign_bit(priv->reg_base, MODE_OFFSET(gpio),\n\t\t\t\t   bitpos, false);\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t} else {\n\t\tpci1xxx_assign_bit(priv->reg_base, INTR_HI_TO_LO_EDGE_CONFIG(gpio),\n\t\t\t\t   bitpos, true);\n\t}\n\n\tif (trigger_type & IRQ_TYPE_EDGE_RISING) {\n\t\tpci1xxx_assign_bit(priv->reg_base, INTR_LO_TO_HI_EDGE_CONFIG(gpio),\n\t\t\t\t   bitpos, false);\n\t\tpci1xxx_assign_bit(priv->reg_base, MODE_OFFSET(gpio), bitpos,\n\t\t\t\t   false);\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t} else {\n\t\tpci1xxx_assign_bit(priv->reg_base, INTR_LO_TO_HI_EDGE_CONFIG(gpio),\n\t\t\t\t   bitpos, true);\n\t}\n\n\tif (trigger_type & IRQ_TYPE_LEVEL_LOW) {\n\t\tpci1xxx_assign_bit(priv->reg_base, INTR_LEVEL_CONFIG_OFFSET(gpio),\n\t\t\t\t   bitpos, true);\n\t\tpci1xxx_assign_bit(priv->reg_base, INTR_LEVEL_MASK_OFFSET(gpio),\n\t\t\t\t   bitpos, false);\n\t\tpci1xxx_assign_bit(priv->reg_base, MODE_OFFSET(gpio), bitpos,\n\t\t\t\t   true);\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t}\n\n\tif (trigger_type & IRQ_TYPE_LEVEL_HIGH) {\n\t\tpci1xxx_assign_bit(priv->reg_base, INTR_LEVEL_CONFIG_OFFSET(gpio),\n\t\t\t\t   bitpos, false);\n\t\tpci1xxx_assign_bit(priv->reg_base, INTR_LEVEL_MASK_OFFSET(gpio),\n\t\t\t\t   bitpos, false);\n\t\tpci1xxx_assign_bit(priv->reg_base, MODE_OFFSET(gpio), bitpos,\n\t\t\t\t   true);\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t}\n\n\tif ((!(trigger_type & IRQ_TYPE_LEVEL_LOW)) && (!(trigger_type & IRQ_TYPE_LEVEL_HIGH)))\n\t\tpci1xxx_assign_bit(priv->reg_base, INTR_LEVEL_MASK_OFFSET(gpio), bitpos, true);\n\n\treturn true;\n}\n\nstatic irqreturn_t pci1xxxx_gpio_irq_handler(int irq, void *dev_id)\n{\n\tstruct pci1xxxx_gpio *priv = dev_id;\n\tstruct gpio_chip *gc =  &priv->gpio;\n\tunsigned long int_status = 0;\n\tunsigned long flags;\n\tu8 pincount;\n\tint bit;\n\tu8 gpiobank;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpci1xxx_assign_bit(priv->reg_base, PIO_GLOBAL_CONFIG_OFFSET, 16, true);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tfor (gpiobank = 0; gpiobank < 3; gpiobank++) {\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tint_status = readl(priv->reg_base + INTR_STATUS_OFFSET(gpiobank));\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tif (gpiobank == 2)\n\t\t\tpincount = 29;\n\t\telse\n\t\t\tpincount = 32;\n\t\tfor_each_set_bit(bit, &int_status, pincount) {\n\t\t\tunsigned int irq;\n\n\t\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\t\twritel(BIT(bit), priv->reg_base + INTR_STATUS_OFFSET(gpiobank));\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\tirq = irq_find_mapping(gc->irq.domain, (bit + (gpiobank * 32)));\n\t\t\tgeneric_handle_irq(irq);\n\t\t}\n\t}\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpci1xxx_assign_bit(priv->reg_base, PIO_GLOBAL_CONFIG_OFFSET, 16, false);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct irq_chip pci1xxxx_gpio_irqchip = {\n\t.name = \"pci1xxxx_gpio\",\n\t.irq_ack = pci1xxxx_gpio_irq_ack,\n\t.irq_mask = pci1xxxx_gpio_irq_mask,\n\t.irq_unmask = pci1xxxx_gpio_irq_unmask,\n\t.irq_set_type = pci1xxxx_gpio_set_type,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int pci1xxxx_gpio_suspend(struct device *dev)\n{\n\tstruct pci1xxxx_gpio *priv = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpci1xxx_assign_bit(priv->reg_base, PIO_GLOBAL_CONFIG_OFFSET,\n\t\t\t   16, true);\n\tpci1xxx_assign_bit(priv->reg_base, PIO_GLOBAL_CONFIG_OFFSET,\n\t\t\t   17, false);\n\tpci1xxx_assign_bit(priv->reg_base, PERI_GEN_RESET, 16, true);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int pci1xxxx_gpio_resume(struct device *dev)\n{\n\tstruct pci1xxxx_gpio *priv = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpci1xxx_assign_bit(priv->reg_base, PIO_GLOBAL_CONFIG_OFFSET,\n\t\t\t   17, true);\n\tpci1xxx_assign_bit(priv->reg_base, PIO_GLOBAL_CONFIG_OFFSET,\n\t\t\t   16, false);\n\tpci1xxx_assign_bit(priv->reg_base, PERI_GEN_RESET, 16, false);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int pci1xxxx_gpio_setup(struct pci1xxxx_gpio *priv, int irq)\n{\n\tstruct gpio_chip *gchip = &priv->gpio;\n\tstruct gpio_irq_chip *girq;\n\tint retval;\n\n\tgchip->label = dev_name(&priv->aux_dev->dev);\n\tgchip->parent = &priv->aux_dev->dev;\n\tgchip->owner = THIS_MODULE;\n\tgchip->direction_input = pci1xxxx_gpio_direction_input;\n\tgchip->direction_output = pci1xxxx_gpio_direction_output;\n\tgchip->get_direction = pci1xxxx_gpio_get_direction;\n\tgchip->get = pci1xxxx_gpio_get;\n\tgchip->set = pci1xxxx_gpio_set;\n\tgchip->set_config = pci1xxxx_gpio_set_config;\n\tgchip->dbg_show = NULL;\n\tgchip->base = -1;\n\tgchip->ngpio =  PCI1XXXX_NR_PINS;\n\tgchip->can_sleep = false;\n\n\tretval = devm_request_threaded_irq(&priv->aux_dev->dev, irq,\n\t\t\t\t\t   NULL, pci1xxxx_gpio_irq_handler,\n\t\t\t\t\t   IRQF_ONESHOT, \"PCI1xxxxGPIO\", priv);\n\n\tif (retval)\n\t\treturn retval;\n\n\tgirq = &priv->gpio.irq;\n\tgpio_irq_chip_set_chip(girq, &pci1xxxx_gpio_irqchip);\n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\n\treturn 0;\n}\n\nstatic int pci1xxxx_gpio_probe(struct auxiliary_device *aux_dev,\n\t\t\t       const struct auxiliary_device_id *id)\n\n{\n\tstruct auxiliary_device_wrapper *aux_dev_wrapper;\n\tstruct gp_aux_data_type *pdata;\n\tstruct pci1xxxx_gpio *priv;\n\tint retval;\n\n\taux_dev_wrapper = (struct auxiliary_device_wrapper *)\n\t\t\t  container_of(aux_dev, struct auxiliary_device_wrapper, aux_dev);\n\n\tpdata = &aux_dev_wrapper->gp_aux_data;\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(&aux_dev->dev, sizeof(struct pci1xxxx_gpio), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\tpriv->aux_dev = aux_dev;\n\n\tif (!devm_request_mem_region(&aux_dev->dev, pdata->region_start, 0x800, aux_dev->name))\n\t\treturn -EBUSY;\n\n\tpriv->reg_base = devm_ioremap(&aux_dev->dev, pdata->region_start, 0x800);\n\tif (!priv->reg_base)\n\t\treturn -ENOMEM;\n\n\twritel(0x0264, (priv->reg_base + 0x400 + 0xF0));\n\n\tretval = pci1xxxx_gpio_setup(priv, pdata->irq_num);\n\n\tif (retval < 0)\n\t\treturn retval;\n\n\tdev_set_drvdata(&aux_dev->dev, priv);\n\n\treturn devm_gpiochip_add_data(&aux_dev->dev, &priv->gpio, priv);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pci1xxxx_gpio_pm_ops, pci1xxxx_gpio_suspend, pci1xxxx_gpio_resume);\n\nstatic const struct auxiliary_device_id pci1xxxx_gpio_auxiliary_id_table[] = {\n\t{.name = \"mchp_pci1xxxx_gp.gp_gpio\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(auxiliary, pci1xxxx_gpio_auxiliary_id_table);\n\nstatic struct auxiliary_driver pci1xxxx_gpio_driver = {\n\t.driver = {\n\t\t.name = \"PCI1xxxxGPIO\",\n\t\t.pm = &pci1xxxx_gpio_pm_ops,\n\t\t},\n\t.probe = pci1xxxx_gpio_probe,\n\t.id_table = pci1xxxx_gpio_auxiliary_id_table\n};\nmodule_auxiliary_driver(pci1xxxx_gpio_driver);\n\nMODULE_DESCRIPTION(\"Microchip Technology Inc. PCI1xxxx GPIO controller\");\nMODULE_AUTHOR(\"Kumaravel Thiagarajan <kumaravel.thiagarajan@microchip.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}