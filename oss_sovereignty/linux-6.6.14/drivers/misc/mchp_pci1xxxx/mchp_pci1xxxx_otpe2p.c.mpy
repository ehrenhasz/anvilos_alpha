{
  "module_name": "mchp_pci1xxxx_otpe2p.c",
  "hash_id": "af4cbeb1fafc65c464a37971638e46ca346cec95b82fe2a30b5f20a2d7273012",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/mchp_pci1xxxx/mchp_pci1xxxx_otpe2p.c",
  "human_readable_source": "\n\n\n\n#include <linux/auxiliary_bus.h>\n#include <linux/device.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n\n#include \"mchp_pci1xxxx_gp.h\"\n\n#define AUX_DRIVER_NAME\t\t\t\"PCI1xxxxOTPE2P\"\n#define EEPROM_NAME\t\t\t\"pci1xxxx_eeprom\"\n#define OTP_NAME\t\t\t\"pci1xxxx_otp\"\n\n#define PERI_PF3_SYSTEM_REG_ADDR_BASE\t0x2000\n#define PERI_PF3_SYSTEM_REG_LENGTH\t0x4000\n\n#define EEPROM_SIZE_BYTES\t\t8192\n#define OTP_SIZE_BYTES\t\t\t8192\n\n#define CONFIG_REG_ADDR_BASE\t\t0\n#define EEPROM_REG_ADDR_BASE\t\t0x0E00\n#define OTP_REG_ADDR_BASE\t\t0x1000\n\n#define MMAP_OTP_OFFSET(x)\t\t(OTP_REG_ADDR_BASE + (x))\n#define MMAP_EEPROM_OFFSET(x)\t\t(EEPROM_REG_ADDR_BASE + (x))\n#define MMAP_CFG_OFFSET(x)\t\t(CONFIG_REG_ADDR_BASE + (x))\n\n#define EEPROM_CMD_REG\t\t\t0x00\n#define EEPROM_DATA_REG\t\t\t0x04\n\n#define EEPROM_CMD_EPC_WRITE\t\t(BIT(29) | BIT(28))\n#define EEPROM_CMD_EPC_TIMEOUT_BIT\tBIT(17)\n#define EEPROM_CMD_EPC_BUSY_BIT\t\tBIT(31)\n\n#define STATUS_READ_DELAY_US\t\t1\n#define STATUS_READ_TIMEOUT_US\t\t20000\n\n#define OTP_ADDR_HIGH_OFFSET\t\t0x04\n#define OTP_ADDR_LOW_OFFSET\t\t0x08\n#define OTP_PRGM_DATA_OFFSET\t\t0x10\n#define OTP_PRGM_MODE_OFFSET\t\t0x14\n#define OTP_RD_DATA_OFFSET\t\t0x18\n#define OTP_FUNC_CMD_OFFSET\t\t0x20\n#define OTP_CMD_GO_OFFSET\t\t0x28\n#define OTP_PASS_FAIL_OFFSET\t\t0x2C\n#define OTP_STATUS_OFFSET\t\t0x30\n\n#define OTP_FUNC_RD_BIT\t\t\tBIT(0)\n#define OTP_FUNC_PGM_BIT\t\tBIT(1)\n#define OTP_CMD_GO_BIT\t\t\tBIT(0)\n#define OTP_STATUS_BUSY_BIT\t\tBIT(0)\n#define OTP_PGM_MODE_BYTE_BIT\t\tBIT(0)\n#define OTP_FAIL_BIT\t\t\tBIT(0)\n\n#define OTP_PWR_DN_BIT\t\t\tBIT(0)\n#define OTP_PWR_DN_OFFSET\t\t0x00\n\n#define CFG_SYS_LOCK_OFFSET\t\t0xA0\n#define CFG_SYS_LOCK_PF3\t\tBIT(5)\n\n#define BYTE_LOW\t\t\t(GENMASK(7, 0))\n#define BYTE_HIGH\t\t\t(GENMASK(12, 8))\n\nstruct pci1xxxx_otp_eeprom_device {\n\tstruct auxiliary_device *pdev;\n\tvoid __iomem *reg_base;\n\tstruct nvmem_config nvmem_config_eeprom;\n\tstruct nvmem_device *nvmem_eeprom;\n\tstruct nvmem_config nvmem_config_otp;\n\tstruct nvmem_device *nvmem_otp;\n};\n\nstatic int set_sys_lock(struct pci1xxxx_otp_eeprom_device *priv)\n{\n\tvoid __iomem *sys_lock = priv->reg_base +\n\t\t\t\t MMAP_CFG_OFFSET(CFG_SYS_LOCK_OFFSET);\n\tu8 data;\n\n\twritel(CFG_SYS_LOCK_PF3, sys_lock);\n\tdata = readl(sys_lock);\n\tif (data != CFG_SYS_LOCK_PF3)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic void release_sys_lock(struct pci1xxxx_otp_eeprom_device *priv)\n{\n\tvoid __iomem *sys_lock = priv->reg_base +\n\t\t\t\t MMAP_CFG_OFFSET(CFG_SYS_LOCK_OFFSET);\n\twritel(0, sys_lock);\n}\n\nstatic bool is_eeprom_responsive(struct pci1xxxx_otp_eeprom_device *priv)\n{\n\tvoid __iomem *rb = priv->reg_base;\n\tu32 regval;\n\tint ret;\n\n\twritel(EEPROM_CMD_EPC_TIMEOUT_BIT,\n\t       rb + MMAP_EEPROM_OFFSET(EEPROM_CMD_REG));\n\twritel(EEPROM_CMD_EPC_BUSY_BIT,\n\t       rb + MMAP_EEPROM_OFFSET(EEPROM_CMD_REG));\n\n\t \n\tret = read_poll_timeout(readl, regval, !(regval & EEPROM_CMD_EPC_BUSY_BIT),\n\t\t\t\tSTATUS_READ_DELAY_US, STATUS_READ_TIMEOUT_US,\n\t\t\t\ttrue, rb + MMAP_EEPROM_OFFSET(EEPROM_CMD_REG));\n\n\t \n\tif (ret < 0 || (!ret && (regval & EEPROM_CMD_EPC_TIMEOUT_BIT)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int pci1xxxx_eeprom_read(void *priv_t, unsigned int off,\n\t\t\t\tvoid *buf_t, size_t count)\n{\n\tstruct pci1xxxx_otp_eeprom_device *priv = priv_t;\n\tvoid __iomem *rb = priv->reg_base;\n\tchar *buf = buf_t;\n\tu32 regval;\n\tu32 byte;\n\tint ret;\n\n\tif (off >= priv->nvmem_config_eeprom.size)\n\t\treturn -EFAULT;\n\n\tif ((off + count) > priv->nvmem_config_eeprom.size)\n\t\tcount = priv->nvmem_config_eeprom.size - off;\n\n\tret = set_sys_lock(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (byte = 0; byte < count; byte++) {\n\t\twritel(EEPROM_CMD_EPC_BUSY_BIT | (off + byte), rb +\n\t\t       MMAP_EEPROM_OFFSET(EEPROM_CMD_REG));\n\n\t\tret = read_poll_timeout(readl, regval,\n\t\t\t\t\t!(regval & EEPROM_CMD_EPC_BUSY_BIT),\n\t\t\t\t\tSTATUS_READ_DELAY_US,\n\t\t\t\t\tSTATUS_READ_TIMEOUT_US, true,\n\t\t\t\t\trb + MMAP_EEPROM_OFFSET(EEPROM_CMD_REG));\n\t\tif (ret < 0 || (!ret && (regval & EEPROM_CMD_EPC_TIMEOUT_BIT))) {\n\t\t\tret = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbuf[byte] = readl(rb + MMAP_EEPROM_OFFSET(EEPROM_DATA_REG));\n\t}\n\tret = byte;\nerror:\n\trelease_sys_lock(priv);\n\treturn ret;\n}\n\nstatic int pci1xxxx_eeprom_write(void *priv_t, unsigned int off,\n\t\t\t\t void *value_t, size_t count)\n{\n\tstruct pci1xxxx_otp_eeprom_device *priv = priv_t;\n\tvoid __iomem *rb = priv->reg_base;\n\tchar *value = value_t;\n\tu32 regval;\n\tu32 byte;\n\tint ret;\n\n\tif (off >= priv->nvmem_config_eeprom.size)\n\t\treturn -EFAULT;\n\n\tif ((off + count) > priv->nvmem_config_eeprom.size)\n\t\tcount = priv->nvmem_config_eeprom.size - off;\n\n\tret = set_sys_lock(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (byte = 0; byte < count; byte++) {\n\t\twritel(*(value + byte), rb + MMAP_EEPROM_OFFSET(EEPROM_DATA_REG));\n\t\tregval = EEPROM_CMD_EPC_TIMEOUT_BIT | EEPROM_CMD_EPC_WRITE |\n\t\t\t (off + byte);\n\t\twritel(regval, rb + MMAP_EEPROM_OFFSET(EEPROM_CMD_REG));\n\t\twritel(EEPROM_CMD_EPC_BUSY_BIT | regval,\n\t\t       rb + MMAP_EEPROM_OFFSET(EEPROM_CMD_REG));\n\n\t\tret = read_poll_timeout(readl, regval,\n\t\t\t\t\t!(regval & EEPROM_CMD_EPC_BUSY_BIT),\n\t\t\t\t\tSTATUS_READ_DELAY_US,\n\t\t\t\t\tSTATUS_READ_TIMEOUT_US, true,\n\t\t\t\t\trb + MMAP_EEPROM_OFFSET(EEPROM_CMD_REG));\n\t\tif (ret < 0 || (!ret && (regval & EEPROM_CMD_EPC_TIMEOUT_BIT))) {\n\t\t\tret = -EIO;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = byte;\nerror:\n\trelease_sys_lock(priv);\n\treturn ret;\n}\n\nstatic void otp_device_set_address(struct pci1xxxx_otp_eeprom_device *priv,\n\t\t\t\t   u16 address)\n{\n\tu16 lo, hi;\n\n\tlo = address & BYTE_LOW;\n\thi = (address & BYTE_HIGH) >> 8;\n\twritew(lo, priv->reg_base + MMAP_OTP_OFFSET(OTP_ADDR_LOW_OFFSET));\n\twritew(hi, priv->reg_base + MMAP_OTP_OFFSET(OTP_ADDR_HIGH_OFFSET));\n}\n\nstatic int pci1xxxx_otp_read(void *priv_t, unsigned int off,\n\t\t\t     void *buf_t, size_t count)\n{\n\tstruct pci1xxxx_otp_eeprom_device *priv = priv_t;\n\tvoid __iomem *rb = priv->reg_base;\n\tchar *buf = buf_t;\n\tu32 regval;\n\tu32 byte;\n\tint ret;\n\tu8 data;\n\n\tif (off >= priv->nvmem_config_otp.size)\n\t\treturn -EFAULT;\n\n\tif ((off + count) > priv->nvmem_config_otp.size)\n\t\tcount = priv->nvmem_config_otp.size - off;\n\n\tret = set_sys_lock(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (byte = 0; byte < count; byte++) {\n\t\totp_device_set_address(priv, (u16)(off + byte));\n\t\tdata = readl(rb + MMAP_OTP_OFFSET(OTP_FUNC_CMD_OFFSET));\n\t\twritel(data | OTP_FUNC_RD_BIT,\n\t\t       rb + MMAP_OTP_OFFSET(OTP_FUNC_CMD_OFFSET));\n\t\tdata = readl(rb + MMAP_OTP_OFFSET(OTP_CMD_GO_OFFSET));\n\t\twritel(data | OTP_CMD_GO_BIT,\n\t\t       rb + MMAP_OTP_OFFSET(OTP_CMD_GO_OFFSET));\n\n\t\tret = read_poll_timeout(readl, regval,\n\t\t\t\t\t!(regval & OTP_STATUS_BUSY_BIT),\n\t\t\t\t\tSTATUS_READ_DELAY_US,\n\t\t\t\t\tSTATUS_READ_TIMEOUT_US, true,\n\t\t\t\t\trb + MMAP_OTP_OFFSET(OTP_STATUS_OFFSET));\n\n\t\tdata = readl(rb + MMAP_OTP_OFFSET(OTP_PASS_FAIL_OFFSET));\n\t\tif (ret < 0 || data & OTP_FAIL_BIT) {\n\t\t\tret = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbuf[byte] = readl(rb + MMAP_OTP_OFFSET(OTP_RD_DATA_OFFSET));\n\t}\n\tret = byte;\nerror:\n\trelease_sys_lock(priv);\n\treturn ret;\n}\n\nstatic int pci1xxxx_otp_write(void *priv_t, unsigned int off,\n\t\t\t      void *value_t, size_t count)\n{\n\tstruct pci1xxxx_otp_eeprom_device *priv = priv_t;\n\tvoid __iomem *rb = priv->reg_base;\n\tchar *value = value_t;\n\tu32 regval;\n\tu32 byte;\n\tint ret;\n\tu8 data;\n\n\tif (off >= priv->nvmem_config_otp.size)\n\t\treturn -EFAULT;\n\n\tif ((off + count) > priv->nvmem_config_otp.size)\n\t\tcount = priv->nvmem_config_otp.size - off;\n\n\tret = set_sys_lock(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (byte = 0; byte < count; byte++) {\n\t\totp_device_set_address(priv, (u16)(off + byte));\n\n\t\t \n\t\tdata = readl(rb + MMAP_OTP_OFFSET(OTP_PRGM_MODE_OFFSET));\n\t\twritel(data | OTP_PGM_MODE_BYTE_BIT,\n\t\t       rb + MMAP_OTP_OFFSET(OTP_PRGM_MODE_OFFSET));\n\t\twritel(*(value + byte), rb + MMAP_OTP_OFFSET(OTP_PRGM_DATA_OFFSET));\n\t\tdata = readl(rb + MMAP_OTP_OFFSET(OTP_FUNC_CMD_OFFSET));\n\t\twritel(data | OTP_FUNC_PGM_BIT,\n\t\t       rb + MMAP_OTP_OFFSET(OTP_FUNC_CMD_OFFSET));\n\t\tdata = readl(rb + MMAP_OTP_OFFSET(OTP_CMD_GO_OFFSET));\n\t\twritel(data | OTP_CMD_GO_BIT,\n\t\t       rb + MMAP_OTP_OFFSET(OTP_CMD_GO_OFFSET));\n\n\t\tret = read_poll_timeout(readl, regval,\n\t\t\t\t\t!(regval & OTP_STATUS_BUSY_BIT),\n\t\t\t\t\tSTATUS_READ_DELAY_US,\n\t\t\t\t\tSTATUS_READ_TIMEOUT_US, true,\n\t\t\t\t\trb + MMAP_OTP_OFFSET(OTP_STATUS_OFFSET));\n\n\t\tdata = readl(rb + MMAP_OTP_OFFSET(OTP_PASS_FAIL_OFFSET));\n\t\tif (ret < 0 || data & OTP_FAIL_BIT) {\n\t\t\tret = -EIO;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = byte;\nerror:\n\trelease_sys_lock(priv);\n\treturn ret;\n}\n\nstatic int pci1xxxx_otp_eeprom_probe(struct auxiliary_device *aux_dev,\n\t\t\t\t     const struct auxiliary_device_id *id)\n{\n\tstruct auxiliary_device_wrapper *aux_dev_wrapper;\n\tstruct pci1xxxx_otp_eeprom_device *priv;\n\tstruct gp_aux_data_type *pdata;\n\tint ret;\n\tu8 data;\n\n\taux_dev_wrapper = container_of(aux_dev, struct auxiliary_device_wrapper,\n\t\t\t\t       aux_dev);\n\tpdata = &aux_dev_wrapper->gp_aux_data;\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(&aux_dev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->pdev = aux_dev;\n\n\tif (!devm_request_mem_region(&aux_dev->dev, pdata->region_start +\n\t\t\t\t     PERI_PF3_SYSTEM_REG_ADDR_BASE,\n\t\t\t\t     PERI_PF3_SYSTEM_REG_LENGTH,\n\t\t\t\t     aux_dev->name))\n\t\treturn -ENOMEM;\n\n\tpriv->reg_base = devm_ioremap(&aux_dev->dev, pdata->region_start +\n\t\t\t\t      PERI_PF3_SYSTEM_REG_ADDR_BASE,\n\t\t\t\t      PERI_PF3_SYSTEM_REG_LENGTH);\n\tif (!priv->reg_base)\n\t\treturn -ENOMEM;\n\n\tret = set_sys_lock(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdata = readl(priv->reg_base + MMAP_OTP_OFFSET(OTP_PWR_DN_OFFSET));\n\twritel(data & ~OTP_PWR_DN_BIT,\n\t       priv->reg_base + MMAP_OTP_OFFSET(OTP_PWR_DN_OFFSET));\n\n\tdev_set_drvdata(&aux_dev->dev, priv);\n\n\tif (is_eeprom_responsive(priv)) {\n\t\tpriv->nvmem_config_eeprom.type = NVMEM_TYPE_EEPROM;\n\t\tpriv->nvmem_config_eeprom.name = EEPROM_NAME;\n\t\tpriv->nvmem_config_eeprom.dev = &aux_dev->dev;\n\t\tpriv->nvmem_config_eeprom.owner = THIS_MODULE;\n\t\tpriv->nvmem_config_eeprom.reg_read = pci1xxxx_eeprom_read;\n\t\tpriv->nvmem_config_eeprom.reg_write = pci1xxxx_eeprom_write;\n\t\tpriv->nvmem_config_eeprom.priv = priv;\n\t\tpriv->nvmem_config_eeprom.stride = 1;\n\t\tpriv->nvmem_config_eeprom.word_size = 1;\n\t\tpriv->nvmem_config_eeprom.size = EEPROM_SIZE_BYTES;\n\n\t\tpriv->nvmem_eeprom = devm_nvmem_register(&aux_dev->dev,\n\t\t\t\t\t\t\t &priv->nvmem_config_eeprom);\n\t\tif (IS_ERR(priv->nvmem_eeprom))\n\t\t\treturn PTR_ERR(priv->nvmem_eeprom);\n\t}\n\n\trelease_sys_lock(priv);\n\n\tpriv->nvmem_config_otp.type = NVMEM_TYPE_OTP;\n\tpriv->nvmem_config_otp.name = OTP_NAME;\n\tpriv->nvmem_config_otp.dev = &aux_dev->dev;\n\tpriv->nvmem_config_otp.owner = THIS_MODULE;\n\tpriv->nvmem_config_otp.reg_read = pci1xxxx_otp_read;\n\tpriv->nvmem_config_otp.reg_write = pci1xxxx_otp_write;\n\tpriv->nvmem_config_otp.priv = priv;\n\tpriv->nvmem_config_otp.stride = 1;\n\tpriv->nvmem_config_otp.word_size = 1;\n\tpriv->nvmem_config_otp.size = OTP_SIZE_BYTES;\n\n\tpriv->nvmem_otp = devm_nvmem_register(&aux_dev->dev,\n\t\t\t\t\t      &priv->nvmem_config_otp);\n\tif (IS_ERR(priv->nvmem_otp))\n\t\treturn PTR_ERR(priv->nvmem_otp);\n\n\treturn ret;\n}\n\nstatic void pci1xxxx_otp_eeprom_remove(struct auxiliary_device *aux_dev)\n{\n\tstruct pci1xxxx_otp_eeprom_device *priv;\n\tvoid __iomem *sys_lock;\n\n\tpriv = dev_get_drvdata(&aux_dev->dev);\n\tsys_lock = priv->reg_base + MMAP_CFG_OFFSET(CFG_SYS_LOCK_OFFSET);\n\twritel(CFG_SYS_LOCK_PF3, sys_lock);\n\n\t \n\twritel(OTP_PWR_DN_BIT,\n\t       priv->reg_base + MMAP_OTP_OFFSET(OTP_PWR_DN_OFFSET));\n\n\twritel(0, sys_lock);\n}\n\nstatic const struct auxiliary_device_id pci1xxxx_otp_eeprom_auxiliary_id_table[] = {\n\t{.name = \"mchp_pci1xxxx_gp.gp_otp_e2p\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(auxiliary, pci1xxxx_otp_eeprom_auxiliary_id_table);\n\nstatic struct auxiliary_driver pci1xxxx_otp_eeprom_driver = {\n\t.driver = {\n\t\t.name = AUX_DRIVER_NAME,\n\t},\n\t.probe = pci1xxxx_otp_eeprom_probe,\n\t.remove = pci1xxxx_otp_eeprom_remove,\n\t.id_table = pci1xxxx_otp_eeprom_auxiliary_id_table\n};\nmodule_auxiliary_driver(pci1xxxx_otp_eeprom_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kumaravel Thiagarajan <kumaravel.thiagarajan@microchip.com>\");\nMODULE_AUTHOR(\"Tharun Kumar P <tharunkumar.pasumarthi@microchip.com>\");\nMODULE_AUTHOR(\"Vaibhaav Ram T.L <vaibhaavram.tl@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip Technology Inc. PCI1xxxx OTP EEPROM Programmer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}