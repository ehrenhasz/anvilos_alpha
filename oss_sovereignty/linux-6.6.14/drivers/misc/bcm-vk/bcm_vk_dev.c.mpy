{
  "module_name": "bcm_vk_dev.c",
  "hash_id": "ec8aa812325604e3dae8d4a8aa8aeed73c841ec339f44bbfbda3245dd5ad8189",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/bcm-vk/bcm_vk_dev.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/panic_notifier.h>\n#include <linux/kref.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/pci_regs.h>\n#include <uapi/linux/misc/bcm_vk.h>\n\n#include \"bcm_vk.h\"\n\n#define PCI_DEVICE_ID_VALKYRIE\t0x5e87\n#define PCI_DEVICE_ID_VIPER\t0x5e88\n\nstatic DEFINE_IDA(bcm_vk_ida);\n\nenum soc_idx {\n\tVALKYRIE_A0 = 0,\n\tVALKYRIE_B0,\n\tVIPER,\n\tVK_IDX_INVALID\n};\n\nenum img_idx {\n\tIMG_PRI = 0,\n\tIMG_SEC,\n\tIMG_PER_TYPE_MAX\n};\n\nstruct load_image_entry {\n\tconst u32 image_type;\n\tconst char *image_name[IMG_PER_TYPE_MAX];\n};\n\n#define NUM_BOOT_STAGES 2\n \nstatic const struct load_image_entry image_tab[][NUM_BOOT_STAGES] = {\n\t[VALKYRIE_A0] = {\n\t\t{VK_IMAGE_TYPE_BOOT1, {\"vk_a0-boot1.bin\", \"vk-boot1.bin\"}},\n\t\t{VK_IMAGE_TYPE_BOOT2, {\"vk_a0-boot2.bin\", \"vk-boot2.bin\"}}\n\t},\n\t[VALKYRIE_B0] = {\n\t\t{VK_IMAGE_TYPE_BOOT1, {\"vk_b0-boot1.bin\", \"vk-boot1.bin\"}},\n\t\t{VK_IMAGE_TYPE_BOOT2, {\"vk_b0-boot2.bin\", \"vk-boot2.bin\"}}\n\t},\n\n\t[VIPER] = {\n\t\t{VK_IMAGE_TYPE_BOOT1, {\"vp-boot1.bin\", \"\"}},\n\t\t{VK_IMAGE_TYPE_BOOT2, {\"vp-boot2.bin\", \"\"}}\n\t},\n};\n\n \n \n#define BAR1_CODEPUSH_BASE_BOOT1\t0x100000\n\n \n#define LOAD_IMAGE_TIMEOUT_MS\t\t(1 * MSEC_PER_SEC)\n\n \n#define BOOT1_STARTUP_TIMEOUT_MS\t(5 * MSEC_PER_SEC)\n#define BOOT2_STARTUP_TIMEOUT_MS\t(10 * MSEC_PER_SEC)\n\n \n#define TXFR_COMPLETE_TIMEOUT_MS\t1\n\n \n#define VK_MSIX_MSGQ_MAX\t\t3\n#define VK_MSIX_NOTF_MAX\t\t1\n#define VK_MSIX_TTY_MAX\t\t\tBCM_VK_NUM_TTY\n#define VK_MSIX_IRQ_MAX\t\t\t(VK_MSIX_MSGQ_MAX + VK_MSIX_NOTF_MAX + \\\n\t\t\t\t\t VK_MSIX_TTY_MAX)\n#define VK_MSIX_IRQ_MIN_REQ             (VK_MSIX_MSGQ_MAX + VK_MSIX_NOTF_MAX)\n\n \n#define BCM_VK_DMA_BITS\t\t\t64\n\n \n#define BCM_VK_UCODE_BOOT_US            (100 * USEC_PER_MSEC)\n \n#define BCM_VK_UCODE_BOOT_MAX_US        ((BCM_VK_UCODE_BOOT_US * 3) >> 1)\n\n \n#define BCM_VK_DEINIT_TIME_MS\t\t(2 * MSEC_PER_SEC)\n\n \nstatic bool auto_load = true;\nmodule_param(auto_load, bool, 0444);\nMODULE_PARM_DESC(auto_load,\n\t\t \"Load images automatically at PCIe probe time.\\n\");\nstatic uint nr_scratch_pages = VK_BAR1_SCRATCH_DEF_NR_PAGES;\nmodule_param(nr_scratch_pages, uint, 0444);\nMODULE_PARM_DESC(nr_scratch_pages,\n\t\t \"Number of pre allocated DMAable coherent pages.\\n\");\nstatic uint nr_ib_sgl_blk = BCM_VK_DEF_IB_SGL_BLK_LEN;\nmodule_param(nr_ib_sgl_blk, uint, 0444);\nMODULE_PARM_DESC(nr_ib_sgl_blk,\n\t\t \"Number of in-band msg blks for short SGL.\\n\");\n\n \nconst struct bcm_vk_entry bcm_vk_peer_err[BCM_VK_PEER_ERR_NUM] = {\n\t{ERR_LOG_UECC, ERR_LOG_UECC, \"uecc\"},\n\t{ERR_LOG_SSIM_BUSY, ERR_LOG_SSIM_BUSY, \"ssim_busy\"},\n\t{ERR_LOG_AFBC_BUSY, ERR_LOG_AFBC_BUSY, \"afbc_busy\"},\n\t{ERR_LOG_HIGH_TEMP_ERR, ERR_LOG_HIGH_TEMP_ERR, \"high_temp\"},\n\t{ERR_LOG_WDOG_TIMEOUT, ERR_LOG_WDOG_TIMEOUT, \"wdog_timeout\"},\n\t{ERR_LOG_SYS_FAULT, ERR_LOG_SYS_FAULT, \"sys_fault\"},\n\t{ERR_LOG_RAMDUMP, ERR_LOG_RAMDUMP, \"ramdump\"},\n\t{ERR_LOG_COP_WDOG_TIMEOUT, ERR_LOG_COP_WDOG_TIMEOUT,\n\t \"cop_wdog_timeout\"},\n\t{ERR_LOG_MEM_ALLOC_FAIL, ERR_LOG_MEM_ALLOC_FAIL, \"malloc_fail warn\"},\n\t{ERR_LOG_LOW_TEMP_WARN, ERR_LOG_LOW_TEMP_WARN, \"low_temp warn\"},\n\t{ERR_LOG_ECC, ERR_LOG_ECC, \"ecc\"},\n\t{ERR_LOG_IPC_DWN, ERR_LOG_IPC_DWN, \"ipc_down\"},\n};\n\n \nconst struct bcm_vk_entry bcm_vk_host_err[BCM_VK_HOST_ERR_NUM] = {\n\t{ERR_LOG_HOST_PCIE_DWN, ERR_LOG_HOST_PCIE_DWN, \"PCIe_down\"},\n\t{ERR_LOG_HOST_HB_FAIL, ERR_LOG_HOST_HB_FAIL, \"hb_fail\"},\n\t{ERR_LOG_HOST_INTF_V_FAIL, ERR_LOG_HOST_INTF_V_FAIL, \"intf_ver_fail\"},\n};\n\nirqreturn_t bcm_vk_notf_irqhandler(int irq, void *dev_id)\n{\n\tstruct bcm_vk *vk = dev_id;\n\n\tif (!bcm_vk_drv_access_ok(vk)) {\n\t\tdev_err(&vk->pdev->dev,\n\t\t\t\"Interrupt %d received when msgq not inited\\n\", irq);\n\t\tgoto skip_schedule_work;\n\t}\n\n\t \n\tif (test_and_set_bit(BCM_VK_WQ_NOTF_PEND, vk->wq_offload) == 0)\n\t\tqueue_work(vk->wq_thread, &vk->wq_work);\n\nskip_schedule_work:\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm_vk_intf_ver_chk(struct bcm_vk *vk)\n{\n\tstruct device *dev = &vk->pdev->dev;\n\tu32 reg;\n\tu16 major, minor;\n\tint ret = 0;\n\n\t \n\treg = vkread32(vk, BAR_0, BAR_INTF_VER);\n\tmajor = (reg >> BAR_INTF_VER_MAJOR_SHIFT) & BAR_INTF_VER_MASK;\n\tminor = reg & BAR_INTF_VER_MASK;\n\n\t \n\tif (!major) {\n\t\tdev_warn(dev, \"Pre-release major.minor=%d.%d - drv %d.%d\\n\",\n\t\t\t major, minor, SEMANTIC_MAJOR, SEMANTIC_MINOR);\n\t} else if (major != SEMANTIC_MAJOR) {\n\t\tdev_err(dev,\n\t\t\t\"Intf major.minor=%d.%d rejected - drv %d.%d\\n\",\n\t\t\tmajor, minor, SEMANTIC_MAJOR, SEMANTIC_MINOR);\n\t\tbcm_vk_set_host_alert(vk, ERR_LOG_HOST_INTF_V_FAIL);\n\t\tret = -EPFNOSUPPORT;\n\t} else {\n\t\tdev_dbg(dev,\n\t\t\t\"Intf major.minor=%d.%d passed - drv %d.%d\\n\",\n\t\t\tmajor, minor, SEMANTIC_MAJOR, SEMANTIC_MINOR);\n\t}\n\treturn ret;\n}\n\nstatic void bcm_vk_log_notf(struct bcm_vk *vk,\n\t\t\t    struct bcm_vk_alert *alert,\n\t\t\t    struct bcm_vk_entry const *entry_tab,\n\t\t\t    const u32 table_size)\n{\n\tu32 i;\n\tu32 masked_val, latched_val;\n\tstruct bcm_vk_entry const *entry;\n\tu32 reg;\n\tu16 ecc_mem_err, uecc_mem_err;\n\tstruct device *dev = &vk->pdev->dev;\n\n\tfor (i = 0; i < table_size; i++) {\n\t\tentry = &entry_tab[i];\n\t\tmasked_val = entry->mask & alert->notfs;\n\t\tlatched_val = entry->mask & alert->flags;\n\n\t\tif (masked_val == ERR_LOG_UECC) {\n\t\t\t \n\t\t\treg = vkread32(vk, BAR_0, BAR_CARD_ERR_MEM);\n\t\t\tBCM_VK_EXTRACT_FIELD(uecc_mem_err, reg,\n\t\t\t\t\t     BCM_VK_MEM_ERR_FIELD_MASK,\n\t\t\t\t\t     BCM_VK_UECC_MEM_ERR_SHIFT);\n\t\t\tif ((uecc_mem_err != vk->alert_cnts.uecc) &&\n\t\t\t    (uecc_mem_err >= BCM_VK_UECC_THRESHOLD))\n\t\t\t\tdev_info(dev,\n\t\t\t\t\t \"ALERT! %s.%d uecc RAISED - ErrCnt %d\\n\",\n\t\t\t\t\t DRV_MODULE_NAME, vk->devid,\n\t\t\t\t\t uecc_mem_err);\n\t\t\tvk->alert_cnts.uecc = uecc_mem_err;\n\t\t} else if (masked_val == ERR_LOG_ECC) {\n\t\t\treg = vkread32(vk, BAR_0, BAR_CARD_ERR_MEM);\n\t\t\tBCM_VK_EXTRACT_FIELD(ecc_mem_err, reg,\n\t\t\t\t\t     BCM_VK_MEM_ERR_FIELD_MASK,\n\t\t\t\t\t     BCM_VK_ECC_MEM_ERR_SHIFT);\n\t\t\tif ((ecc_mem_err != vk->alert_cnts.ecc) &&\n\t\t\t    (ecc_mem_err >= BCM_VK_ECC_THRESHOLD))\n\t\t\t\tdev_info(dev, \"ALERT! %s.%d ecc RAISED - ErrCnt %d\\n\",\n\t\t\t\t\t DRV_MODULE_NAME, vk->devid,\n\t\t\t\t\t ecc_mem_err);\n\t\t\tvk->alert_cnts.ecc = ecc_mem_err;\n\t\t} else if (masked_val != latched_val) {\n\t\t\t \n\t\t\tdev_info(dev, \"ALERT! %s.%d %s %s\\n\",\n\t\t\t\t DRV_MODULE_NAME, vk->devid, entry->str,\n\t\t\t\t masked_val ? \"RAISED\" : \"CLEARED\");\n\t\t}\n\t}\n}\n\nstatic void bcm_vk_dump_peer_log(struct bcm_vk *vk)\n{\n\tstruct bcm_vk_peer_log log;\n\tstruct bcm_vk_peer_log *log_info = &vk->peerlog_info;\n\tchar loc_buf[BCM_VK_PEER_LOG_LINE_MAX];\n\tint cnt;\n\tstruct device *dev = &vk->pdev->dev;\n\tunsigned int data_offset;\n\n\tmemcpy_fromio(&log, vk->bar[BAR_2] + vk->peerlog_off, sizeof(log));\n\n\tdev_dbg(dev, \"Peer PANIC: Size 0x%x(0x%x), [Rd Wr] = [%d %d]\\n\",\n\t\tlog.buf_size, log.mask, log.rd_idx, log.wr_idx);\n\n\tif (!log_info->buf_size) {\n\t\tdev_err(dev, \"Peer log dump disabled - skipped!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif ((log.rd_idx > log_info->mask) ||\n\t    (log.wr_idx > log_info->mask) ||\n\t    (log.buf_size != log_info->buf_size) ||\n\t    (log.mask != log_info->mask)) {\n\t\tdev_err(dev,\n\t\t\t\"Corrupted Ptrs: Size 0x%x(0x%x) Mask 0x%x(0x%x) [Rd Wr] = [%d %d], skip log dump.\\n\",\n\t\t\tlog_info->buf_size, log.buf_size,\n\t\t\tlog_info->mask, log.mask,\n\t\t\tlog.rd_idx, log.wr_idx);\n\t\treturn;\n\t}\n\n\tcnt = 0;\n\tdata_offset = vk->peerlog_off + sizeof(struct bcm_vk_peer_log);\n\tloc_buf[BCM_VK_PEER_LOG_LINE_MAX - 1] = '\\0';\n\twhile (log.rd_idx != log.wr_idx) {\n\t\tloc_buf[cnt] = vkread8(vk, BAR_2, data_offset + log.rd_idx);\n\n\t\tif ((loc_buf[cnt] == '\\0') ||\n\t\t    (cnt == (BCM_VK_PEER_LOG_LINE_MAX - 1))) {\n\t\t\tdev_err(dev, \"%s\", loc_buf);\n\t\t\tcnt = 0;\n\t\t} else {\n\t\t\tcnt++;\n\t\t}\n\t\tlog.rd_idx = (log.rd_idx + 1) & log.mask;\n\t}\n\t \n\tvkwrite32(vk, log.rd_idx, BAR_2,\n\t\t  vk->peerlog_off + offsetof(struct bcm_vk_peer_log, rd_idx));\n}\n\nvoid bcm_vk_handle_notf(struct bcm_vk *vk)\n{\n\tu32 reg;\n\tstruct bcm_vk_alert alert;\n\tbool intf_down;\n\tunsigned long flags;\n\n\t \n\treg = vkread32(vk, BAR_0, BAR_CARD_ERR_LOG);\n\tintf_down = BCM_VK_INTF_IS_DOWN(reg);\n\tif (!intf_down) {\n\t\tvk->peer_alert.notfs = reg;\n\t\tbcm_vk_log_notf(vk, &vk->peer_alert, bcm_vk_peer_err,\n\t\t\t\tARRAY_SIZE(bcm_vk_peer_err));\n\t\tvk->peer_alert.flags = vk->peer_alert.notfs;\n\t} else {\n\t\t \n\t\tbcm_vk_blk_drv_access(vk);\n\t}\n\n\t \n\tspin_lock_irqsave(&vk->host_alert_lock, flags);\n\tif (intf_down)\n\t\tvk->host_alert.notfs |= ERR_LOG_HOST_PCIE_DWN;\n\n\talert = vk->host_alert;\n\tvk->host_alert.flags = vk->host_alert.notfs;\n\tspin_unlock_irqrestore(&vk->host_alert_lock, flags);\n\n\t \n\tbcm_vk_log_notf(vk, &alert, bcm_vk_host_err,\n\t\t\tARRAY_SIZE(bcm_vk_host_err));\n\n\t \n\tif (!intf_down &&\n\t    ((vk->host_alert.flags & ERR_LOG_HOST_HB_FAIL) ||\n\t     (vk->peer_alert.flags & ERR_LOG_SYS_FAULT)))\n\t\tbcm_vk_dump_peer_log(vk);\n}\n\nstatic inline int bcm_vk_wait(struct bcm_vk *vk, enum pci_barno bar,\n\t\t\t      u64 offset, u32 mask, u32 value,\n\t\t\t      unsigned long timeout_ms)\n{\n\tstruct device *dev = &vk->pdev->dev;\n\tunsigned long start_time;\n\tunsigned long timeout;\n\tu32 rd_val, boot_status;\n\n\tstart_time = jiffies;\n\ttimeout = start_time + msecs_to_jiffies(timeout_ms);\n\n\tdo {\n\t\trd_val = vkread32(vk, bar, offset);\n\t\tdev_dbg(dev, \"BAR%d Offset=0x%llx: 0x%x\\n\",\n\t\t\tbar, offset, rd_val);\n\n\t\t \n\t\tboot_status = vkread32(vk, BAR_0, BAR_BOOT_STATUS);\n\t\tif (boot_status & BOOT_ERR_MASK) {\n\t\t\tdev_err(dev, \"Boot Err 0x%x, progress 0x%x after %d ms\\n\",\n\t\t\t\t(boot_status & BOOT_ERR_MASK) >> BOOT_ERR_SHIFT,\n\t\t\t\tboot_status & BOOT_PROG_MASK,\n\t\t\t\tjiffies_to_msecs(jiffies - start_time));\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tcpu_relax();\n\t\tcond_resched();\n\t} while ((rd_val & mask) != value);\n\n\treturn 0;\n}\n\nstatic void bcm_vk_get_card_info(struct bcm_vk *vk)\n{\n\tstruct device *dev = &vk->pdev->dev;\n\tu32 offset;\n\tint i;\n\tu8 *dst;\n\tstruct bcm_vk_card_info *info = &vk->card_info;\n\n\t \n\toffset = vkread32(vk, BAR_0, BAR_CARD_STATIC_INFO);\n\toffset &= (pci_resource_len(vk->pdev, BAR_2 * 2) - 1);\n\n\t \n\tdst = (u8 *)info;\n\tfor (i = 0; i < sizeof(*info); i++)\n\t\t*dst++ = vkread8(vk, BAR_2, offset++);\n\n#define CARD_INFO_LOG_FMT \"version   : %x\\n\" \\\n\t\t\t  \"os_tag    : %s\\n\" \\\n\t\t\t  \"cmpt_tag  : %s\\n\" \\\n\t\t\t  \"cpu_freq  : %d MHz\\n\" \\\n\t\t\t  \"cpu_scale : %d full, %d lowest\\n\" \\\n\t\t\t  \"ddr_freq  : %d MHz\\n\" \\\n\t\t\t  \"ddr_size  : %d MB\\n\" \\\n\t\t\t  \"video_freq: %d MHz\\n\"\n\tdev_dbg(dev, CARD_INFO_LOG_FMT, info->version, info->os_tag,\n\t\tinfo->cmpt_tag, info->cpu_freq_mhz, info->cpu_scale[0],\n\t\tinfo->cpu_scale[MAX_OPP - 1], info->ddr_freq_mhz,\n\t\tinfo->ddr_size_MB, info->video_core_freq_mhz);\n\n\t \n\tvk->peerlog_off = offset;\n\tmemcpy_fromio(&vk->peerlog_info, vk->bar[BAR_2] + vk->peerlog_off,\n\t\t      sizeof(vk->peerlog_info));\n\n\t \n\tif ((vk->peerlog_info.buf_size > BCM_VK_PEER_LOG_BUF_MAX) ||\n\t    (vk->peerlog_info.mask != (vk->peerlog_info.buf_size - 1)) ||\n\t    (vk->peerlog_info.rd_idx > vk->peerlog_info.mask) ||\n\t    (vk->peerlog_info.wr_idx > vk->peerlog_info.mask)) {\n\t\tdev_err(dev, \"Peer log disabled - range error: Size 0x%x(0x%x), [Rd Wr] = [%d %d]\\n\",\n\t\t\tvk->peerlog_info.buf_size,\n\t\t\tvk->peerlog_info.mask,\n\t\t\tvk->peerlog_info.rd_idx,\n\t\t\tvk->peerlog_info.wr_idx);\n\t\tmemset(&vk->peerlog_info, 0, sizeof(vk->peerlog_info));\n\t} else {\n\t\tdev_dbg(dev, \"Peer log: Size 0x%x(0x%x), [Rd Wr] = [%d %d]\\n\",\n\t\t\tvk->peerlog_info.buf_size,\n\t\t\tvk->peerlog_info.mask,\n\t\t\tvk->peerlog_info.rd_idx,\n\t\t\tvk->peerlog_info.wr_idx);\n\t}\n}\n\nstatic void bcm_vk_get_proc_mon_info(struct bcm_vk *vk)\n{\n\tstruct device *dev = &vk->pdev->dev;\n\tstruct bcm_vk_proc_mon_info *mon = &vk->proc_mon_info;\n\tu32 num, entry_size, offset, buf_size;\n\tu8 *dst;\n\n\t \n\tbuf_size = vkread32(vk, BAR_2,\n\t\t\t    vk->peerlog_off\n\t\t\t    + offsetof(struct bcm_vk_peer_log, buf_size));\n\toffset = vk->peerlog_off + sizeof(struct bcm_vk_peer_log)\n\t\t + buf_size;\n\n\t \n\tnum = vkread32(vk, BAR_2, offset);\n\tentry_size = vkread32(vk, BAR_2, offset + sizeof(num));\n\n\t \n\tif (num > BCM_VK_PROC_MON_MAX) {\n\t\tdev_err(dev, \"Processing monitoring entry %d exceeds max %d\\n\",\n\t\t\tnum, BCM_VK_PROC_MON_MAX);\n\t\treturn;\n\t}\n\tmon->num = num;\n\tmon->entry_size = entry_size;\n\n\tvk->proc_mon_off = offset;\n\n\t \n\tdst = (u8 *)&mon->entries[0];\n\toffset += sizeof(num) + sizeof(entry_size);\n\tmemcpy_fromio(dst, vk->bar[BAR_2] + offset, num * entry_size);\n}\n\nstatic int bcm_vk_sync_card_info(struct bcm_vk *vk)\n{\n\tu32 rdy_marker = vkread32(vk, BAR_1, VK_BAR1_MSGQ_DEF_RDY);\n\n\t \n\tif (!bcm_vk_msgq_marker_valid(vk))\n\t\treturn (rdy_marker == VK_BAR1_DIAG_RDY_MARKER ? 0 : -EINVAL);\n\n\t \n\tif (vk->tdma_addr) {\n\t\tvkwrite32(vk, (u64)vk->tdma_addr >> 32, BAR_1,\n\t\t\t  VK_BAR1_SCRATCH_OFF_HI);\n\t\tvkwrite32(vk, (u32)vk->tdma_addr, BAR_1,\n\t\t\t  VK_BAR1_SCRATCH_OFF_LO);\n\t\tvkwrite32(vk, nr_scratch_pages * PAGE_SIZE, BAR_1,\n\t\t\t  VK_BAR1_SCRATCH_SZ_ADDR);\n\t}\n\n\t \n\tbcm_vk_get_card_info(vk);\n\n\t \n\tbcm_vk_get_proc_mon_info(vk);\n\n\treturn 0;\n}\n\nvoid bcm_vk_blk_drv_access(struct bcm_vk *vk)\n{\n\tint i;\n\n\t \n\tspin_lock(&vk->ctx_lock);\n\n\t \n\tatomic_set(&vk->msgq_inited, 0);\n\n\tfor (i = 0; i < VK_PID_HT_SZ; i++) {\n\t\tstruct bcm_vk_ctx *ctx;\n\n\t\tlist_for_each_entry(ctx, &vk->pid_ht[i].head, node) {\n\t\t\tif (ctx->pid != vk->reset_pid) {\n\t\t\t\tdev_dbg(&vk->pdev->dev,\n\t\t\t\t\t\"Send kill signal to pid %d\\n\",\n\t\t\t\t\tctx->pid);\n\t\t\t\tkill_pid(find_vpid(ctx->pid), SIGKILL, 1);\n\t\t\t}\n\t\t}\n\t}\n\tbcm_vk_tty_terminate_tty_user(vk);\n\tspin_unlock(&vk->ctx_lock);\n}\n\nstatic void bcm_vk_buf_notify(struct bcm_vk *vk, void *bufp,\n\t\t\t      dma_addr_t host_buf_addr, u32 buf_size)\n{\n\t \n\tvkwrite32(vk, (u64)host_buf_addr >> 32, BAR_1,\n\t\t  VK_BAR1_DMA_BUF_OFF_HI);\n\tvkwrite32(vk, (u32)host_buf_addr, BAR_1,\n\t\t  VK_BAR1_DMA_BUF_OFF_LO);\n\tvkwrite32(vk, buf_size, BAR_1, VK_BAR1_DMA_BUF_SZ);\n}\n\nstatic int bcm_vk_load_image_by_type(struct bcm_vk *vk, u32 load_type,\n\t\t\t\t     const char *filename)\n{\n\tstruct device *dev = &vk->pdev->dev;\n\tconst struct firmware *fw = NULL;\n\tvoid *bufp = NULL;\n\tsize_t max_buf, offset;\n\tint ret;\n\tu64 offset_codepush;\n\tu32 codepush;\n\tu32 value;\n\tdma_addr_t boot_dma_addr;\n\tbool is_stdalone;\n\n\tif (load_type == VK_IMAGE_TYPE_BOOT1) {\n\t\t \n\t\tvalue = vkread32(vk, BAR_0, BAR_BOOTSRC_SELECT);\n\t\tvalue |= BOOTSRC_SOFT_ENABLE;\n\t\tvkwrite32(vk, value, BAR_0, BAR_BOOTSRC_SELECT);\n\n\t\tcodepush = CODEPUSH_BOOTSTART + CODEPUSH_BOOT1_ENTRY;\n\t\toffset_codepush = BAR_CODEPUSH_SBL;\n\n\t\t \n\t\tvkwrite32(vk, CODEPUSH_BOOTSTART, BAR_0, offset_codepush);\n\n\t\t \n\t\tret = bcm_vk_wait(vk, BAR_0, BAR_BOOT_STATUS, SRAM_OPEN,\n\t\t\t\t  SRAM_OPEN, LOAD_IMAGE_TIMEOUT_MS);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"boot1 wait SRAM err - ret(%d)\\n\", ret);\n\t\t\tgoto err_buf_out;\n\t\t}\n\n\t\tmax_buf = SZ_256K;\n\t\tbufp = dma_alloc_coherent(dev,\n\t\t\t\t\t  max_buf,\n\t\t\t\t\t  &boot_dma_addr, GFP_KERNEL);\n\t\tif (!bufp) {\n\t\t\tdev_err(dev, \"Error allocating 0x%zx\\n\", max_buf);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_buf_out;\n\t\t}\n\t} else if (load_type == VK_IMAGE_TYPE_BOOT2) {\n\t\tcodepush = CODEPUSH_BOOT2_ENTRY;\n\t\toffset_codepush = BAR_CODEPUSH_SBI;\n\n\t\t \n\t\tret = bcm_vk_wait(vk, BAR_0, BAR_BOOT_STATUS, DDR_OPEN,\n\t\t\t\t  DDR_OPEN, LOAD_IMAGE_TIMEOUT_MS);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"boot2 wait DDR open error - ret(%d)\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_buf_out;\n\t\t}\n\n\t\tmax_buf = SZ_4M;\n\t\tbufp = dma_alloc_coherent(dev,\n\t\t\t\t\t  max_buf,\n\t\t\t\t\t  &boot_dma_addr, GFP_KERNEL);\n\t\tif (!bufp) {\n\t\t\tdev_err(dev, \"Error allocating 0x%zx\\n\", max_buf);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_buf_out;\n\t\t}\n\n\t\tbcm_vk_buf_notify(vk, bufp, boot_dma_addr, max_buf);\n\t} else {\n\t\tdev_err(dev, \"Error invalid image type 0x%x\\n\", load_type);\n\t\tret = -EINVAL;\n\t\tgoto err_buf_out;\n\t}\n\n\toffset = 0;\n\tret = request_partial_firmware_into_buf(&fw, filename, dev,\n\t\t\t\t\t\tbufp, max_buf, offset);\n\tif (ret) {\n\t\tdev_err(dev, \"Error %d requesting firmware file: %s\\n\",\n\t\t\tret, filename);\n\t\tgoto err_firmware_out;\n\t}\n\tdev_dbg(dev, \"size=0x%zx\\n\", fw->size);\n\tif (load_type == VK_IMAGE_TYPE_BOOT1)\n\t\tmemcpy_toio(vk->bar[BAR_1] + BAR1_CODEPUSH_BASE_BOOT1,\n\t\t\t    bufp,\n\t\t\t    fw->size);\n\n\tdev_dbg(dev, \"Signaling 0x%x to 0x%llx\\n\", codepush, offset_codepush);\n\tvkwrite32(vk, codepush, BAR_0, offset_codepush);\n\n\tif (load_type == VK_IMAGE_TYPE_BOOT1) {\n\t\tu32 boot_status;\n\n\t\t \n\t\tret = bcm_vk_wait(vk, BAR_0, BAR_BOOT_STATUS,\n\t\t\t\t  BOOT1_RUNNING,\n\t\t\t\t  BOOT1_RUNNING,\n\t\t\t\t  BOOT1_STARTUP_TIMEOUT_MS);\n\n\t\tboot_status = vkread32(vk, BAR_0, BAR_BOOT_STATUS);\n\t\tis_stdalone = !BCM_VK_INTF_IS_DOWN(boot_status) &&\n\t\t\t      (boot_status & BOOT_STDALONE_RUNNING);\n\t\tif (ret && !is_stdalone) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Timeout %ld ms waiting for boot1 to come up - ret(%d)\\n\",\n\t\t\t\tBOOT1_STARTUP_TIMEOUT_MS, ret);\n\t\t\tgoto err_firmware_out;\n\t\t} else if (is_stdalone) {\n\t\t\tu32 reg;\n\n\t\t\treg = vkread32(vk, BAR_0, BAR_BOOT1_STDALONE_PROGRESS);\n\t\t\tif ((reg & BOOT1_STDALONE_PROGRESS_MASK) ==\n\t\t\t\t     BOOT1_STDALONE_SUCCESS) {\n\t\t\t\tdev_info(dev, \"Boot1 standalone success\\n\");\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\tdev_err(dev, \"Timeout %ld ms - Boot1 standalone failure\\n\",\n\t\t\t\t\tBOOT1_STARTUP_TIMEOUT_MS);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_firmware_out;\n\t\t\t}\n\t\t}\n\t} else if (load_type == VK_IMAGE_TYPE_BOOT2) {\n\t\tunsigned long timeout;\n\n\t\ttimeout = jiffies + msecs_to_jiffies(LOAD_IMAGE_TIMEOUT_MS);\n\n\t\t \n\t\tdo {\n\t\t\t \n\t\t\tret = bcm_vk_wait(vk, BAR_0, BAR_BOOT_STATUS,\n\t\t\t\t\t  FW_LOADER_ACK_RCVD_ALL_DATA,\n\t\t\t\t\t  FW_LOADER_ACK_RCVD_ALL_DATA,\n\t\t\t\t\t  TXFR_COMPLETE_TIMEOUT_MS);\n\t\t\tif (ret == 0) {\n\t\t\t\tdev_dbg(dev, \"Exit boot2 download\\n\");\n\t\t\t\tbreak;\n\t\t\t} else if (ret == -EFAULT) {\n\t\t\t\tdev_err(dev, \"Error detected during ACK waiting\");\n\t\t\t\tgoto err_firmware_out;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tdev_err(dev, \"Error. No reply from card\\n\");\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tgoto err_firmware_out;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = bcm_vk_wait(vk, BAR_0, offset_codepush,\n\t\t\t\t\t  codepush, 0,\n\t\t\t\t\t  TXFR_COMPLETE_TIMEOUT_MS);\n\t\t\tif (ret == 0) {\n\t\t\t\toffset += max_buf;\n\t\t\t\tret = request_partial_firmware_into_buf\n\t\t\t\t\t\t(&fw,\n\t\t\t\t\t\t filename,\n\t\t\t\t\t\t dev, bufp,\n\t\t\t\t\t\t max_buf,\n\t\t\t\t\t\t offset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(dev,\n\t\t\t\t\t\t\"Error %d requesting firmware file: %s offset: 0x%zx\\n\",\n\t\t\t\t\t\tret, filename, offset);\n\t\t\t\t\tgoto err_firmware_out;\n\t\t\t\t}\n\t\t\t\tdev_dbg(dev, \"size=0x%zx\\n\", fw->size);\n\t\t\t\tdev_dbg(dev, \"Signaling 0x%x to 0x%llx\\n\",\n\t\t\t\t\tcodepush, offset_codepush);\n\t\t\t\tvkwrite32(vk, codepush, BAR_0, offset_codepush);\n\t\t\t\t \n\t\t\t\ttimeout = jiffies +\n\t\t\t\t    msecs_to_jiffies(LOAD_IMAGE_TIMEOUT_MS);\n\t\t\t} else if (ret == -EFAULT) {\n\t\t\t\tdev_err(dev, \"Error detected waiting for transfer\\n\");\n\t\t\t\tgoto err_firmware_out;\n\t\t\t}\n\t\t} while (1);\n\n\t\t \n\t\tret = bcm_vk_wait(vk, BAR_0, VK_BAR_FWSTS,\n\t\t\t\t  VK_FWSTS_READY,\n\t\t\t\t  VK_FWSTS_READY,\n\t\t\t\t  BOOT2_STARTUP_TIMEOUT_MS);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Boot2 not ready - ret(%d)\\n\", ret);\n\t\t\tgoto err_firmware_out;\n\t\t}\n\n\t\tis_stdalone = vkread32(vk, BAR_0, BAR_BOOT_STATUS) &\n\t\t\t      BOOT_STDALONE_RUNNING;\n\t\tif (!is_stdalone) {\n\t\t\tret = bcm_vk_intf_ver_chk(vk);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"failure in intf version check\\n\");\n\t\t\t\tgoto err_firmware_out;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = bcm_vk_sync_msgq(vk, true);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Boot2 Error reading comm msg Q info\\n\");\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto err_firmware_out;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = bcm_vk_sync_card_info(vk);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Syncing Card Info failure\\n\");\n\t\t\t\tgoto err_firmware_out;\n\t\t\t}\n\t\t}\n\t}\n\nerr_firmware_out:\n\trelease_firmware(fw);\n\nerr_buf_out:\n\tif (bufp)\n\t\tdma_free_coherent(dev, max_buf, bufp, boot_dma_addr);\n\n\treturn ret;\n}\n\nstatic u32 bcm_vk_next_boot_image(struct bcm_vk *vk)\n{\n\tu32 boot_status;\n\tu32 fw_status;\n\tu32 load_type = 0;   \n\n\tboot_status = vkread32(vk, BAR_0, BAR_BOOT_STATUS);\n\tfw_status = vkread32(vk, BAR_0, VK_BAR_FWSTS);\n\n\tif (!BCM_VK_INTF_IS_DOWN(boot_status) && (boot_status & SRAM_OPEN))\n\t\tload_type = VK_IMAGE_TYPE_BOOT1;\n\telse if (boot_status == BOOT1_RUNNING)\n\t\tload_type = VK_IMAGE_TYPE_BOOT2;\n\n\t \n\tdev_info(&vk->pdev->dev,\n\t\t \"boot-status value for next image: 0x%x : fw-status 0x%x\\n\",\n\t\t boot_status, fw_status);\n\n\treturn load_type;\n}\n\nstatic enum soc_idx get_soc_idx(struct bcm_vk *vk)\n{\n\tstruct pci_dev *pdev = vk->pdev;\n\tenum soc_idx idx = VK_IDX_INVALID;\n\tu32 rev;\n\tstatic enum soc_idx const vk_soc_tab[] = { VALKYRIE_A0, VALKYRIE_B0 };\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_VALKYRIE:\n\t\t \n\t\trev = MAJOR_SOC_REV(vkread32(vk, BAR_0, BAR_CHIP_ID));\n\t\tif (rev < ARRAY_SIZE(vk_soc_tab)) {\n\t\t\tidx = vk_soc_tab[rev];\n\t\t} else {\n\t\t\t \n\t\t\tidx = VALKYRIE_A0;\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Rev %d not in image lookup table, default to idx=%d\\n\",\n\t\t\t\t rev, idx);\n\t\t}\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_VIPER:\n\t\tidx = VIPER;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev, \"no images for 0x%x\\n\", pdev->device);\n\t}\n\treturn idx;\n}\n\nstatic const char *get_load_fw_name(struct bcm_vk *vk,\n\t\t\t\t    const struct load_image_entry *entry)\n{\n\tconst struct firmware *fw;\n\tstruct device *dev = &vk->pdev->dev;\n\tint ret;\n\tunsigned long dummy;\n\tint i;\n\n\tfor (i = 0; i < IMG_PER_TYPE_MAX; i++) {\n\t\tfw = NULL;\n\t\tret = request_partial_firmware_into_buf(&fw,\n\t\t\t\t\t\t\tentry->image_name[i],\n\t\t\t\t\t\t\tdev, &dummy,\n\t\t\t\t\t\t\tsizeof(dummy),\n\t\t\t\t\t\t\t0);\n\t\trelease_firmware(fw);\n\t\tif (!ret)\n\t\t\treturn entry->image_name[i];\n\t}\n\treturn NULL;\n}\n\nint bcm_vk_auto_load_all_images(struct bcm_vk *vk)\n{\n\tint i, ret = -1;\n\tenum soc_idx idx;\n\tstruct device *dev = &vk->pdev->dev;\n\tu32 curr_type;\n\tconst char *curr_name;\n\n\tidx = get_soc_idx(vk);\n\tif (idx == VK_IDX_INVALID)\n\t\tgoto auto_load_all_exit;\n\n\t \n\tdev_dbg(dev, \"Load All for device %d\\n\", vk->devid);\n\n\tfor (i = 0; i < NUM_BOOT_STAGES; i++) {\n\t\tcurr_type = image_tab[idx][i].image_type;\n\t\tif (bcm_vk_next_boot_image(vk) == curr_type) {\n\t\t\tcurr_name = get_load_fw_name(vk, &image_tab[idx][i]);\n\t\t\tif (!curr_name) {\n\t\t\t\tdev_err(dev, \"No suitable firmware exists for type %d\",\n\t\t\t\t\tcurr_type);\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto auto_load_all_exit;\n\t\t\t}\n\t\t\tret = bcm_vk_load_image_by_type(vk, curr_type,\n\t\t\t\t\t\t\tcurr_name);\n\t\t\tdev_info(dev, \"Auto load %s, ret %d\\n\",\n\t\t\t\t curr_name, ret);\n\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Error loading default %s\\n\",\n\t\t\t\t\tcurr_name);\n\t\t\t\tgoto auto_load_all_exit;\n\t\t\t}\n\t\t}\n\t}\n\nauto_load_all_exit:\n\treturn ret;\n}\n\nstatic int bcm_vk_trigger_autoload(struct bcm_vk *vk)\n{\n\tif (test_and_set_bit(BCM_VK_WQ_DWNLD_PEND, vk->wq_offload) != 0)\n\t\treturn -EPERM;\n\n\tset_bit(BCM_VK_WQ_DWNLD_AUTO, vk->wq_offload);\n\tqueue_work(vk->wq_thread, &vk->wq_work);\n\n\treturn 0;\n}\n\n \nstatic void bcm_vk_wq_handler(struct work_struct *work)\n{\n\tstruct bcm_vk *vk = container_of(work, struct bcm_vk, wq_work);\n\tstruct device *dev = &vk->pdev->dev;\n\ts32 ret;\n\n\t \n\tif (test_bit(BCM_VK_WQ_NOTF_PEND, vk->wq_offload)) {\n\t\t \n\t\tclear_bit(BCM_VK_WQ_NOTF_PEND, vk->wq_offload);\n\t\tbcm_vk_handle_notf(vk);\n\t}\n\tif (test_bit(BCM_VK_WQ_DWNLD_AUTO, vk->wq_offload)) {\n\t\tbcm_vk_auto_load_all_images(vk);\n\n\t\t \n\t\tclear_bit(BCM_VK_WQ_DWNLD_AUTO, vk->wq_offload);\n\t\tclear_bit(BCM_VK_WQ_DWNLD_PEND, vk->wq_offload);\n\t}\n\n\t \n\tret = bcm_to_h_msg_dequeue(vk);\n\n\tif (ret == 0)\n\t\tdev_dbg(dev, \"Spurious trigger for workqueue\\n\");\n\telse if (ret < 0)\n\t\tbcm_vk_blk_drv_access(vk);\n}\n\nstatic long bcm_vk_load_image(struct bcm_vk *vk,\n\t\t\t      const struct vk_image __user *arg)\n{\n\tstruct device *dev = &vk->pdev->dev;\n\tconst char *image_name;\n\tstruct vk_image image;\n\tu32 next_loadable;\n\tenum soc_idx idx;\n\tint image_idx;\n\tint ret = -EPERM;\n\n\tif (copy_from_user(&image, arg, sizeof(image)))\n\t\treturn -EACCES;\n\n\tif ((image.type != VK_IMAGE_TYPE_BOOT1) &&\n\t    (image.type != VK_IMAGE_TYPE_BOOT2)) {\n\t\tdev_err(dev, \"invalid image.type %u\\n\", image.type);\n\t\treturn ret;\n\t}\n\n\tnext_loadable = bcm_vk_next_boot_image(vk);\n\tif (next_loadable != image.type) {\n\t\tdev_err(dev, \"Next expected image %u, Loading %u\\n\",\n\t\t\tnext_loadable, image.type);\n\t\treturn ret;\n\t}\n\n\t \n\tif (test_and_set_bit(BCM_VK_WQ_DWNLD_PEND, vk->wq_offload) != 0) {\n\t\tdev_err(dev, \"Download operation already pending.\\n\");\n\t\treturn ret;\n\t}\n\n\timage_name = image.filename;\n\tif (image_name[0] == '\\0') {\n\t\t \n\t\tidx = get_soc_idx(vk);\n\t\tif (idx == VK_IDX_INVALID)\n\t\t\tgoto err_idx;\n\n\t\t \n\t\timage_idx = image.type - VK_IMAGE_TYPE_BOOT1;\n\t\timage_name = get_load_fw_name(vk, &image_tab[idx][image_idx]);\n\t\tif (!image_name) {\n\t\t\tdev_err(dev, \"No suitable image found for type %d\",\n\t\t\t\timage.type);\n\t\t\tret = -ENOENT;\n\t\t\tgoto err_idx;\n\t\t}\n\t} else {\n\t\t \n\t\timage.filename[sizeof(image.filename) - 1] = '\\0';\n\t}\n\tret = bcm_vk_load_image_by_type(vk, image.type, image_name);\n\tdev_info(dev, \"Load %s, ret %d\\n\", image_name, ret);\nerr_idx:\n\tclear_bit(BCM_VK_WQ_DWNLD_PEND, vk->wq_offload);\n\n\treturn ret;\n}\n\nstatic int bcm_vk_reset_successful(struct bcm_vk *vk)\n{\n\tstruct device *dev = &vk->pdev->dev;\n\tu32 fw_status, reset_reason;\n\tint ret = -EAGAIN;\n\n\t \n\tfw_status = vkread32(vk, BAR_0, VK_BAR_FWSTS);\n\t \n\tif (BCM_VK_INTF_IS_DOWN(fw_status)) {\n\t\tdev_err(dev, \"PCIe Intf Down!\\n\");\n\t\tgoto reset_exit;\n\t}\n\n\treset_reason = (fw_status & VK_FWSTS_RESET_REASON_MASK);\n\tif ((reset_reason == VK_FWSTS_RESET_MBOX_DB) ||\n\t    (reset_reason == VK_FWSTS_RESET_UNKNOWN))\n\t\tret = 0;\n\n\t \n\tif ((fw_status & VK_FWSTS_DEINIT_TRIGGERED) &&\n\t    !(fw_status & VK_FWSTS_RESET_DONE))\n\t\tret = -EAGAIN;\n\nreset_exit:\n\tdev_dbg(dev, \"FW status = 0x%x ret %d\\n\", fw_status, ret);\n\n\treturn ret;\n}\n\nstatic void bcm_to_v_reset_doorbell(struct bcm_vk *vk, u32 db_val)\n{\n\tvkwrite32(vk, db_val, BAR_0, VK_BAR0_RESET_DB_BASE);\n}\n\nstatic int bcm_vk_trigger_reset(struct bcm_vk *vk)\n{\n\tu32 i;\n\tu32 value, boot_status;\n\tbool is_stdalone, is_boot2;\n\tstatic const u32 bar0_reg_clr_list[] = { BAR_OS_UPTIME,\n\t\t\t\t\t\t BAR_INTF_VER,\n\t\t\t\t\t\t BAR_CARD_VOLTAGE,\n\t\t\t\t\t\t BAR_CARD_TEMPERATURE,\n\t\t\t\t\t\t BAR_CARD_PWR_AND_THRE };\n\n\t \n\tbcm_vk_drain_msg_on_reset(vk);\n\tvkwrite32(vk, 0, BAR_1, VK_BAR1_MSGQ_DEF_RDY);\n\t \n\tvkwrite32(vk, 0, BAR_1, VK_BAR1_BOOT1_VER_TAG);\n\n\tfor (i = 0; i < VK_BAR1_DAUTH_MAX; i++) {\n\t\tvkwrite32(vk, 0, BAR_1, VK_BAR1_DAUTH_STORE_ADDR(i));\n\t\tvkwrite32(vk, 0, BAR_1, VK_BAR1_DAUTH_VALID_ADDR(i));\n\t}\n\tfor (i = 0; i < VK_BAR1_SOTP_REVID_MAX; i++)\n\t\tvkwrite32(vk, 0, BAR_1, VK_BAR1_SOTP_REVID_ADDR(i));\n\n\tmemset(&vk->card_info, 0, sizeof(vk->card_info));\n\tmemset(&vk->peerlog_info, 0, sizeof(vk->peerlog_info));\n\tmemset(&vk->proc_mon_info, 0, sizeof(vk->proc_mon_info));\n\tmemset(&vk->alert_cnts, 0, sizeof(vk->alert_cnts));\n\n\t \n\tboot_status = vkread32(vk, BAR_0, BAR_BOOT_STATUS);\n\tif (boot_status & BOOT_ERR_MASK) {\n\t\tdev_info(&vk->pdev->dev,\n\t\t\t \"Card in boot error 0x%x, clear CODEPUSH val\\n\",\n\t\t\t boot_status);\n\t\tvalue = 0;\n\t} else {\n\t\tvalue = vkread32(vk, BAR_0, BAR_CODEPUSH_SBL);\n\t\tvalue &= CODEPUSH_MASK;\n\t}\n\tvkwrite32(vk, value, BAR_0, BAR_CODEPUSH_SBL);\n\n\t \n\tis_stdalone = boot_status & BOOT_STDALONE_RUNNING;\n\tis_boot2 = (boot_status & BOOT_STATE_MASK) == BOOT2_RUNNING;\n\tif (vk->peer_alert.flags & ERR_LOG_RAMDUMP) {\n\t\t \n\t\tvkwrite32(vk, VK_BAR0_RESET_RAMPDUMP, BAR_0, VK_BAR_FWSTS);\n\t\treturn VK_BAR0_RESET_RAMPDUMP;\n\t} else if (is_stdalone && !is_boot2) {\n\t\tdev_info(&vk->pdev->dev, \"Hard reset on Standalone mode\");\n\t\tbcm_to_v_reset_doorbell(vk, VK_BAR0_RESET_DB_HARD);\n\t\treturn VK_BAR0_RESET_DB_HARD;\n\t}\n\n\t \n\tvkwrite32(vk, VK_FWSTS_RESET_MBOX_DB, BAR_0, VK_BAR_FWSTS);\n\tbcm_to_v_reset_doorbell(vk, VK_BAR0_RESET_DB_SOFT);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(bar0_reg_clr_list); i++)\n\t\tvkwrite32(vk, 0, BAR_0, bar0_reg_clr_list[i]);\n\tmemset(&vk->host_alert, 0, sizeof(vk->host_alert));\n\tmemset(&vk->peer_alert, 0, sizeof(vk->peer_alert));\n\t \n\tbitmap_clear(vk->bmap, 0, VK_MSG_ID_BITMAP_SIZE);\n\n\treturn 0;\n}\n\nstatic long bcm_vk_reset(struct bcm_vk *vk, struct vk_reset __user *arg)\n{\n\tstruct device *dev = &vk->pdev->dev;\n\tstruct vk_reset reset;\n\tint ret = 0;\n\tu32 ramdump_reset;\n\tint special_reset;\n\n\tif (copy_from_user(&reset, arg, sizeof(struct vk_reset)))\n\t\treturn -EFAULT;\n\n\t \n\tif (test_and_set_bit(BCM_VK_WQ_DWNLD_PEND, vk->wq_offload) != 0) {\n\t\tdev_err(dev, \"Download operation pending - skip reset.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tramdump_reset = vk->peer_alert.flags & ERR_LOG_RAMDUMP;\n\tdev_info(dev, \"Issue Reset %s\\n\",\n\t\t ramdump_reset ? \"in ramdump mode\" : \"\");\n\n\t \n\tbcm_vk_send_shutdown_msg(vk, VK_SHUTDOWN_GRACEFUL, 0, 0);\n\n\tspin_lock(&vk->ctx_lock);\n\tif (!vk->reset_pid) {\n\t\tvk->reset_pid = task_pid_nr(current);\n\t} else {\n\t\tdev_err(dev, \"Reset already launched by process pid %d\\n\",\n\t\t\tvk->reset_pid);\n\t\tret = -EACCES;\n\t}\n\tspin_unlock(&vk->ctx_lock);\n\tif (ret)\n\t\tgoto err_exit;\n\n\tbcm_vk_blk_drv_access(vk);\n\tspecial_reset = bcm_vk_trigger_reset(vk);\n\n\t \n\tmsleep(BCM_VK_DEINIT_TIME_MS);\n\n\tif (special_reset) {\n\t\t \n\t\treset.arg2 = special_reset;\n\t\tif (copy_to_user(arg, &reset, sizeof(reset)))\n\t\t\tret = -EFAULT;\n\t} else {\n\t\tret = bcm_vk_reset_successful(vk);\n\t}\n\nerr_exit:\n\tclear_bit(BCM_VK_WQ_DWNLD_PEND, vk->wq_offload);\n\treturn ret;\n}\n\nstatic int bcm_vk_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct bcm_vk_ctx *ctx = file->private_data;\n\tstruct bcm_vk *vk = container_of(ctx->miscdev, struct bcm_vk, miscdev);\n\tunsigned long pg_size;\n\n\t \n#define VK_MMAPABLE_BAR 4\n\n\tpg_size = ((pci_resource_len(vk->pdev, VK_MMAPABLE_BAR) - 1)\n\t\t    >> PAGE_SHIFT) + 1;\n\tif (vma->vm_pgoff + vma_pages(vma) > pg_size)\n\t\treturn -EINVAL;\n\n\tvma->vm_pgoff += (pci_resource_start(vk->pdev, VK_MMAPABLE_BAR)\n\t\t\t  >> PAGE_SHIFT);\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\treturn io_remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\n\t\t\t\t  vma->vm_end - vma->vm_start,\n\t\t\t\t  vma->vm_page_prot);\n}\n\nstatic long bcm_vk_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong ret = -EINVAL;\n\tstruct bcm_vk_ctx *ctx = file->private_data;\n\tstruct bcm_vk *vk = container_of(ctx->miscdev, struct bcm_vk, miscdev);\n\tvoid __user *argp = (void __user *)arg;\n\n\tdev_dbg(&vk->pdev->dev,\n\t\t\"ioctl, cmd=0x%02x, arg=0x%02lx\\n\",\n\t\tcmd, arg);\n\n\tmutex_lock(&vk->mutex);\n\n\tswitch (cmd) {\n\tcase VK_IOCTL_LOAD_IMAGE:\n\t\tret = bcm_vk_load_image(vk, argp);\n\t\tbreak;\n\n\tcase VK_IOCTL_RESET:\n\t\tret = bcm_vk_reset(vk, argp);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&vk->mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations bcm_vk_fops = {\n\t.owner = THIS_MODULE,\n\t.open = bcm_vk_open,\n\t.read = bcm_vk_read,\n\t.write = bcm_vk_write,\n\t.poll = bcm_vk_poll,\n\t.release = bcm_vk_release,\n\t.mmap = bcm_vk_mmap,\n\t.unlocked_ioctl = bcm_vk_ioctl,\n};\n\nstatic int bcm_vk_on_panic(struct notifier_block *nb,\n\t\t\t   unsigned long e, void *p)\n{\n\tstruct bcm_vk *vk = container_of(nb, struct bcm_vk, panic_nb);\n\n\tbcm_to_v_reset_doorbell(vk, VK_BAR0_RESET_DB_HARD);\n\n\treturn 0;\n}\n\nstatic int bcm_vk_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint err;\n\tint i;\n\tint id;\n\tint irq;\n\tchar name[20];\n\tstruct bcm_vk *vk;\n\tstruct device *dev = &pdev->dev;\n\tstruct miscdevice *misc_device;\n\tu32 boot_status;\n\n\t \n\tvk = kzalloc(sizeof(*vk), GFP_KERNEL);\n\tif (!vk)\n\t\treturn -ENOMEM;\n\n\tkref_init(&vk->kref);\n\tif (nr_ib_sgl_blk > BCM_VK_IB_SGL_BLK_MAX) {\n\t\tdev_warn(dev, \"Inband SGL blk %d limited to max %d\\n\",\n\t\t\t nr_ib_sgl_blk, BCM_VK_IB_SGL_BLK_MAX);\n\t\tnr_ib_sgl_blk = BCM_VK_IB_SGL_BLK_MAX;\n\t}\n\tvk->ib_sgl_size = nr_ib_sgl_blk * VK_MSGQ_BLK_SIZE;\n\tmutex_init(&vk->mutex);\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot enable PCI device\\n\");\n\t\tgoto err_free_exit;\n\t}\n\tvk->pdev = pci_dev_get(pdev);\n\n\terr = pci_request_regions(pdev, DRV_MODULE_NAME);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot obtain PCI resources\\n\");\n\t\tgoto err_disable_pdev;\n\t}\n\n\t \n\terr = dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t\t\tDMA_BIT_MASK(BCM_VK_DMA_BITS));\n\tif (err) {\n\t\tdev_err(dev, \"failed to set DMA mask\\n\");\n\t\tgoto err_disable_pdev;\n\t}\n\n\t \n\tif (nr_scratch_pages) {\n\t\tvk->tdma_vaddr = dma_alloc_coherent\n\t\t\t\t\t(dev,\n\t\t\t\t\t nr_scratch_pages * PAGE_SIZE,\n\t\t\t\t\t &vk->tdma_addr, GFP_KERNEL);\n\t\tif (!vk->tdma_vaddr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_disable_pdev;\n\t\t}\n\t}\n\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, vk);\n\n\tirq = pci_alloc_irq_vectors(pdev,\n\t\t\t\t    VK_MSIX_IRQ_MIN_REQ,\n\t\t\t\t    VK_MSIX_IRQ_MAX,\n\t\t\t\t    PCI_IRQ_MSI | PCI_IRQ_MSIX);\n\n\tif (irq < VK_MSIX_IRQ_MIN_REQ) {\n\t\tdev_err(dev, \"failed to get min %d MSIX interrupts, irq(%d)\\n\",\n\t\t\tVK_MSIX_IRQ_MIN_REQ, irq);\n\t\terr = (irq >= 0) ? -EINVAL : irq;\n\t\tgoto err_disable_pdev;\n\t}\n\n\tif (irq != VK_MSIX_IRQ_MAX)\n\t\tdev_warn(dev, \"Number of IRQs %d allocated - requested(%d).\\n\",\n\t\t\t irq, VK_MSIX_IRQ_MAX);\n\n\tfor (i = 0; i < MAX_BAR; i++) {\n\t\t \n\t\tvk->bar[i] = pci_ioremap_bar(pdev, i * 2);\n\t\tif (!vk->bar[i]) {\n\t\t\tdev_err(dev, \"failed to remap BAR%d\\n\", i);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_iounmap;\n\t\t}\n\t}\n\n\tfor (vk->num_irqs = 0;\n\t     vk->num_irqs < VK_MSIX_MSGQ_MAX;\n\t     vk->num_irqs++) {\n\t\terr = devm_request_irq(dev, pci_irq_vector(pdev, vk->num_irqs),\n\t\t\t\t       bcm_vk_msgq_irqhandler,\n\t\t\t\t       IRQF_SHARED, DRV_MODULE_NAME, vk);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to request msgq IRQ %d for MSIX %d\\n\",\n\t\t\t\tpdev->irq + vk->num_irqs, vk->num_irqs + 1);\n\t\t\tgoto err_irq;\n\t\t}\n\t}\n\t \n\terr = devm_request_irq(dev, pci_irq_vector(pdev, vk->num_irqs),\n\t\t\t       bcm_vk_notf_irqhandler,\n\t\t\t       IRQF_SHARED, DRV_MODULE_NAME, vk);\n\tif (err) {\n\t\tdev_err(dev, \"failed to request notf IRQ %d for MSIX %d\\n\",\n\t\t\tpdev->irq + vk->num_irqs, vk->num_irqs + 1);\n\t\tgoto err_irq;\n\t}\n\tvk->num_irqs++;\n\n\tfor (i = 0;\n\t     (i < VK_MSIX_TTY_MAX) && (vk->num_irqs < irq);\n\t     i++, vk->num_irqs++) {\n\t\terr = devm_request_irq(dev, pci_irq_vector(pdev, vk->num_irqs),\n\t\t\t\t       bcm_vk_tty_irqhandler,\n\t\t\t\t       IRQF_SHARED, DRV_MODULE_NAME, vk);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed request tty IRQ %d for MSIX %d\\n\",\n\t\t\t\tpdev->irq + vk->num_irqs, vk->num_irqs + 1);\n\t\t\tgoto err_irq;\n\t\t}\n\t\tbcm_vk_tty_set_irq_enabled(vk, i);\n\t}\n\n\tid = ida_alloc(&bcm_vk_ida, GFP_KERNEL);\n\tif (id < 0) {\n\t\terr = id;\n\t\tdev_err(dev, \"unable to get id\\n\");\n\t\tgoto err_irq;\n\t}\n\n\tvk->devid = id;\n\tsnprintf(name, sizeof(name), DRV_MODULE_NAME \".%d\", id);\n\tmisc_device = &vk->miscdev;\n\tmisc_device->minor = MISC_DYNAMIC_MINOR;\n\tmisc_device->name = kstrdup(name, GFP_KERNEL);\n\tif (!misc_device->name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_ida_remove;\n\t}\n\tmisc_device->fops = &bcm_vk_fops,\n\n\terr = misc_register(misc_device);\n\tif (err) {\n\t\tdev_err(dev, \"failed to register device\\n\");\n\t\tgoto err_kfree_name;\n\t}\n\n\tINIT_WORK(&vk->wq_work, bcm_vk_wq_handler);\n\n\t \n\tvk->wq_thread = create_singlethread_workqueue(name);\n\tif (!vk->wq_thread) {\n\t\tdev_err(dev, \"Fail to create workqueue thread\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_misc_deregister;\n\t}\n\n\terr = bcm_vk_msg_init(vk);\n\tif (err) {\n\t\tdev_err(dev, \"failed to init msg queue info\\n\");\n\t\tgoto err_destroy_workqueue;\n\t}\n\n\t \n\tbcm_vk_sync_card_info(vk);\n\n\t \n\tvk->panic_nb.notifier_call = bcm_vk_on_panic;\n\terr = atomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t     &vk->panic_nb);\n\tif (err) {\n\t\tdev_err(dev, \"Fail to register panic notifier\\n\");\n\t\tgoto err_destroy_workqueue;\n\t}\n\n\tsnprintf(name, sizeof(name), KBUILD_MODNAME \".%d_ttyVK\", id);\n\terr = bcm_vk_tty_init(vk, name);\n\tif (err)\n\t\tgoto err_unregister_panic_notifier;\n\n\t \n\tboot_status = vkread32(vk, BAR_0, BAR_BOOT_STATUS);\n\tif (auto_load) {\n\t\tif ((boot_status & BOOT_STATE_MASK) == BROM_RUNNING) {\n\t\t\terr = bcm_vk_trigger_autoload(vk);\n\t\t\tif (err)\n\t\t\t\tgoto err_bcm_vk_tty_exit;\n\t\t} else {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Auto-load skipped - BROM not in proper state (0x%x)\\n\",\n\t\t\t\tboot_status);\n\t\t}\n\t}\n\n\t \n\tbcm_vk_hb_init(vk);\n\n\tdev_dbg(dev, \"BCM-VK:%u created\\n\", id);\n\n\treturn 0;\n\nerr_bcm_vk_tty_exit:\n\tbcm_vk_tty_exit(vk);\n\nerr_unregister_panic_notifier:\n\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t &vk->panic_nb);\n\nerr_destroy_workqueue:\n\tdestroy_workqueue(vk->wq_thread);\n\nerr_misc_deregister:\n\tmisc_deregister(misc_device);\n\nerr_kfree_name:\n\tkfree(misc_device->name);\n\tmisc_device->name = NULL;\n\nerr_ida_remove:\n\tida_free(&bcm_vk_ida, id);\n\nerr_irq:\n\tfor (i = 0; i < vk->num_irqs; i++)\n\t\tdevm_free_irq(dev, pci_irq_vector(pdev, i), vk);\n\n\tpci_disable_msix(pdev);\n\tpci_disable_msi(pdev);\n\nerr_iounmap:\n\tfor (i = 0; i < MAX_BAR; i++) {\n\t\tif (vk->bar[i])\n\t\t\tpci_iounmap(pdev, vk->bar[i]);\n\t}\n\tpci_release_regions(pdev);\n\nerr_disable_pdev:\n\tif (vk->tdma_vaddr)\n\t\tdma_free_coherent(&pdev->dev, nr_scratch_pages * PAGE_SIZE,\n\t\t\t\t  vk->tdma_vaddr, vk->tdma_addr);\n\n\tpci_free_irq_vectors(pdev);\n\tpci_disable_device(pdev);\n\tpci_dev_put(pdev);\n\nerr_free_exit:\n\tkfree(vk);\n\n\treturn err;\n}\n\nvoid bcm_vk_release_data(struct kref *kref)\n{\n\tstruct bcm_vk *vk = container_of(kref, struct bcm_vk, kref);\n\tstruct pci_dev *pdev = vk->pdev;\n\n\tdev_dbg(&pdev->dev, \"BCM-VK:%d release data 0x%p\\n\", vk->devid, vk);\n\tpci_dev_put(pdev);\n\tkfree(vk);\n}\n\nstatic void bcm_vk_remove(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct bcm_vk *vk = pci_get_drvdata(pdev);\n\tstruct miscdevice *misc_device = &vk->miscdev;\n\n\tbcm_vk_hb_deinit(vk);\n\n\t \n\tbcm_vk_trigger_reset(vk);\n\tusleep_range(BCM_VK_UCODE_BOOT_US, BCM_VK_UCODE_BOOT_MAX_US);\n\n\t \n\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t &vk->panic_nb);\n\n\tbcm_vk_msg_remove(vk);\n\tbcm_vk_tty_exit(vk);\n\n\tif (vk->tdma_vaddr)\n\t\tdma_free_coherent(&pdev->dev, nr_scratch_pages * PAGE_SIZE,\n\t\t\t\t  vk->tdma_vaddr, vk->tdma_addr);\n\n\t \n\tif (misc_device->name) {\n\t\tmisc_deregister(misc_device);\n\t\tkfree(misc_device->name);\n\t\tida_free(&bcm_vk_ida, vk->devid);\n\t}\n\tfor (i = 0; i < vk->num_irqs; i++)\n\t\tdevm_free_irq(&pdev->dev, pci_irq_vector(pdev, i), vk);\n\n\tpci_disable_msix(pdev);\n\tpci_disable_msi(pdev);\n\n\tcancel_work_sync(&vk->wq_work);\n\tdestroy_workqueue(vk->wq_thread);\n\tbcm_vk_tty_wq_exit(vk);\n\n\tfor (i = 0; i < MAX_BAR; i++) {\n\t\tif (vk->bar[i])\n\t\t\tpci_iounmap(pdev, vk->bar[i]);\n\t}\n\n\tdev_dbg(&pdev->dev, \"BCM-VK:%d released\\n\", vk->devid);\n\n\tpci_release_regions(pdev);\n\tpci_free_irq_vectors(pdev);\n\tpci_disable_device(pdev);\n\n\tkref_put(&vk->kref, bcm_vk_release_data);\n}\n\nstatic void bcm_vk_shutdown(struct pci_dev *pdev)\n{\n\tstruct bcm_vk *vk = pci_get_drvdata(pdev);\n\tu32 reg, boot_stat;\n\n\treg = vkread32(vk, BAR_0, BAR_BOOT_STATUS);\n\tboot_stat = reg & BOOT_STATE_MASK;\n\n\tif (boot_stat == BOOT1_RUNNING) {\n\t\t \n\t\tbcm_vk_trigger_reset(vk);\n\t} else if (boot_stat == BROM_NOT_RUN) {\n\t\tint err;\n\t\tu16 lnksta;\n\n\t\t \n\t\terr = pcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnksta);\n\t\tif (!err &&\n\t\t    (lnksta & PCI_EXP_LNKSTA_CLS) != PCI_EXP_LNKSTA_CLS_2_5GB) {\n\t\t\treg |= BROM_STATUS_COMPLETE;\n\t\t\tvkwrite32(vk, reg, BAR_0, BAR_BOOT_STATUS);\n\t\t}\n\t}\n}\n\nstatic const struct pci_device_id bcm_vk_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_VALKYRIE), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, bcm_vk_ids);\n\nstatic struct pci_driver pci_driver = {\n\t.name     = DRV_MODULE_NAME,\n\t.id_table = bcm_vk_ids,\n\t.probe    = bcm_vk_probe,\n\t.remove   = bcm_vk_remove,\n\t.shutdown = bcm_vk_shutdown,\n};\nmodule_pci_driver(pci_driver);\n\nMODULE_DESCRIPTION(\"Broadcom VK Host Driver\");\nMODULE_AUTHOR(\"Scott Branden <scott.branden@broadcom.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(\"1.0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}