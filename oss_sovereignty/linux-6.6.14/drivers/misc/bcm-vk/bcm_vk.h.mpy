{
  "module_name": "bcm_vk.h",
  "hash_id": "ecc7a4594b9edb7dc87082b8c0eb57e52203cc91d8f5c49da4da8637594f899b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/bcm-vk/bcm_vk.h",
  "human_readable_source": " \n \n\n#ifndef BCM_VK_H\n#define BCM_VK_H\n\n#include <linux/atomic.h>\n#include <linux/firmware.h>\n#include <linux/irq.h>\n#include <linux/kref.h>\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/poll.h>\n#include <linux/sched/signal.h>\n#include <linux/tty.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/misc/bcm_vk.h>\n\n#include \"bcm_vk_msg.h\"\n\n#define DRV_MODULE_NAME\t\t\"bcm-vk\"\n\n \n \n\n \n#define BAR_CODEPUSH_SBL\t\t0x400\n \n#define CODEPUSH_BOOT1_ENTRY\t\t0x00400000\n#define CODEPUSH_MASK\t\t        0xfffff000\n#define CODEPUSH_BOOTSTART\t\tBIT(0)\n\n \n#define BAR_BOOT_STATUS\t\t\t0x404\n\n#define SRAM_OPEN\t\t\tBIT(16)\n#define DDR_OPEN\t\t\tBIT(17)\n\n \n#define FW_LOADER_ACK_SEND_MORE_DATA\tBIT(18)\n#define FW_LOADER_ACK_IN_PROGRESS\tBIT(19)\n#define FW_LOADER_ACK_RCVD_ALL_DATA\tBIT(20)\n\n \n#define BOOT_STDALONE_RUNNING\t\tBIT(21)\n\n \n#define BOOT_STATE_MASK\t\t\t(0xffffffff & \\\n\t\t\t\t\t ~(FW_LOADER_ACK_SEND_MORE_DATA | \\\n\t\t\t\t\t   FW_LOADER_ACK_IN_PROGRESS | \\\n\t\t\t\t\t   BOOT_STDALONE_RUNNING))\n\n#define BOOT_ERR_SHIFT\t\t\t4\n#define BOOT_ERR_MASK\t\t\t(0xf << BOOT_ERR_SHIFT)\n#define BOOT_PROG_MASK\t\t\t0xf\n\n#define BROM_STATUS_NOT_RUN\t\t0x2\n#define BROM_NOT_RUN\t\t\t(SRAM_OPEN | BROM_STATUS_NOT_RUN)\n#define BROM_STATUS_COMPLETE\t\t0x6\n#define BROM_RUNNING\t\t\t(SRAM_OPEN | BROM_STATUS_COMPLETE)\n#define BOOT1_STATUS_COMPLETE\t\t0x6\n#define BOOT1_RUNNING\t\t\t(DDR_OPEN | BOOT1_STATUS_COMPLETE)\n#define BOOT2_STATUS_COMPLETE\t\t0x6\n#define BOOT2_RUNNING\t\t\t(FW_LOADER_ACK_RCVD_ALL_DATA | \\\n\t\t\t\t\t BOOT2_STATUS_COMPLETE)\n\n \n#define BAR_CODEPUSH_SBI\t\t0x408\n \n#define CODEPUSH_BOOT2_ENTRY\t\t0x60000000\n\n#define BAR_CARD_STATUS\t\t\t0x410\n \n#define CARD_STATUS_TTYVK0_READY\tBIT(0)\n#define CARD_STATUS_TTYVK1_READY\tBIT(1)\n\n#define BAR_BOOT1_STDALONE_PROGRESS\t0x420\n#define BOOT1_STDALONE_SUCCESS\t\t(BIT(13) | BIT(14))\n#define BOOT1_STDALONE_PROGRESS_MASK\tBOOT1_STDALONE_SUCCESS\n\n#define BAR_METADATA_VERSION\t\t0x440\n#define BAR_OS_UPTIME\t\t\t0x444\n#define BAR_CHIP_ID\t\t\t0x448\n#define MAJOR_SOC_REV(_chip_id)\t\t(((_chip_id) >> 20) & 0xf)\n\n#define BAR_CARD_TEMPERATURE\t\t0x45c\n \n#define BCM_VK_TEMP_FIELD_MASK\t\t0xff\n#define BCM_VK_CPU_TEMP_SHIFT\t\t0\n#define BCM_VK_DDR0_TEMP_SHIFT\t\t8\n#define BCM_VK_DDR1_TEMP_SHIFT\t\t16\n\n#define BAR_CARD_VOLTAGE\t\t0x460\n \n#define BCM_VK_VOLT_RAIL_MASK\t\t0xffff\n#define BCM_VK_3P3_VOLT_REG_SHIFT\t16\n\n#define BAR_CARD_ERR_LOG\t\t0x464\n \n#define ERR_LOG_UECC\t\t\tBIT(0)\n#define ERR_LOG_SSIM_BUSY\t\tBIT(1)\n#define ERR_LOG_AFBC_BUSY\t\tBIT(2)\n#define ERR_LOG_HIGH_TEMP_ERR\t\tBIT(3)\n#define ERR_LOG_WDOG_TIMEOUT\t\tBIT(4)\n#define ERR_LOG_SYS_FAULT\t\tBIT(5)\n#define ERR_LOG_RAMDUMP\t\t\tBIT(6)\n#define ERR_LOG_COP_WDOG_TIMEOUT\tBIT(7)\n \n#define ERR_LOG_MEM_ALLOC_FAIL\t\tBIT(8)\n#define ERR_LOG_LOW_TEMP_WARN\t\tBIT(9)\n#define ERR_LOG_ECC\t\t\tBIT(10)\n#define ERR_LOG_IPC_DWN\t\t\tBIT(11)\n\n \n#define ERR_LOG_HOST_INTF_V_FAIL\tBIT(13)\n#define ERR_LOG_HOST_HB_FAIL\t\tBIT(14)\n#define ERR_LOG_HOST_PCIE_DWN\t\tBIT(15)\n\n#define BAR_CARD_ERR_MEM\t\t0x468\n \n#define BCM_VK_MEM_ERR_FIELD_MASK\t0xff\n#define BCM_VK_ECC_MEM_ERR_SHIFT\t0\n#define BCM_VK_UECC_MEM_ERR_SHIFT\t8\n \n#define BCM_VK_ECC_THRESHOLD\t\t10\n#define BCM_VK_UECC_THRESHOLD\t\t1\n\n#define BAR_CARD_PWR_AND_THRE\t\t0x46c\n \n#define BCM_VK_PWR_AND_THRE_FIELD_MASK\t0xff\n#define BCM_VK_LOW_TEMP_THRE_SHIFT\t0\n#define BCM_VK_HIGH_TEMP_THRE_SHIFT\t8\n#define BCM_VK_PWR_STATE_SHIFT\t\t16\n\n#define BAR_CARD_STATIC_INFO\t\t0x470\n\n#define BAR_INTF_VER\t\t\t0x47c\n#define BAR_INTF_VER_MAJOR_SHIFT\t16\n#define BAR_INTF_VER_MASK\t\t0xffff\n \n#define SEMANTIC_MAJOR\t\t\t1\n#define SEMANTIC_MINOR\t\t\t0\n\n \n#define VK_BAR0_REGSEG_DB_BASE\t\t0x484\n#define VK_BAR0_REGSEG_DB_REG_GAP\t8  \n\n \n#define VK_BAR0_RESET_DB_NUM\t\t3\n#define VK_BAR0_RESET_DB_SOFT\t\t0xffffffff\n#define VK_BAR0_RESET_DB_HARD\t\t0xfffffffd\n#define VK_BAR0_RESET_RAMPDUMP\t\t0xa0000000\n\n#define VK_BAR0_Q_DB_BASE(q_num)\t(VK_BAR0_REGSEG_DB_BASE + \\\n\t\t\t\t\t ((q_num) * VK_BAR0_REGSEG_DB_REG_GAP))\n#define VK_BAR0_RESET_DB_BASE\t\t(VK_BAR0_REGSEG_DB_BASE + \\\n\t\t\t\t\t (VK_BAR0_RESET_DB_NUM * VK_BAR0_REGSEG_DB_REG_GAP))\n\n#define BAR_BOOTSRC_SELECT\t\t0xc78\n \n#define BOOTSRC_SOFT_ENABLE\t\tBIT(14)\n\n \n#define BAR_FIRMWARE_TAG_SIZE\t\t50\n#define FIRMWARE_STATUS_PRE_INIT_DONE\t0x1f\n\n \n#define VK_MSG_ID_BITMAP_SIZE\t\t4096\n#define VK_MSG_ID_BITMAP_MASK\t\t(VK_MSG_ID_BITMAP_SIZE - 1)\n#define VK_MSG_ID_OVERFLOW\t\t0xffff\n\n \n\n \n\n \n#define VK_BAR1_MSGQ_DEF_RDY\t\t0x60c0\n \n#define VK_BAR1_MSGQ_RDY_MARKER\t\t0xbeefcafe\n \n#define VK_BAR1_DIAG_RDY_MARKER\t\t0xdeadcafe\n \n#define VK_BAR1_MSGQ_NR\t\t\t0x60c4\n \n#define VK_BAR1_MSGQ_CTRL_OFF\t\t0x60c8\n\n \n#define VK_BAR1_UCODE_VER_TAG\t\t0x6170\n#define VK_BAR1_BOOT1_VER_TAG\t\t0x61b0\n#define VK_BAR1_VER_TAG_SIZE\t\t64\n\n \n#define VK_BAR1_DMA_BUF_OFF_HI\t\t0x61e0\n#define VK_BAR1_DMA_BUF_OFF_LO\t\t(VK_BAR1_DMA_BUF_OFF_HI + 4)\n#define VK_BAR1_DMA_BUF_SZ\t\t(VK_BAR1_DMA_BUF_OFF_HI + 8)\n\n \n#define VK_BAR1_SCRATCH_OFF_HI\t\t0x61f0\n#define VK_BAR1_SCRATCH_OFF_LO\t\t(VK_BAR1_SCRATCH_OFF_HI + 4)\n#define VK_BAR1_SCRATCH_SZ_ADDR\t\t(VK_BAR1_SCRATCH_OFF_HI + 8)\n#define VK_BAR1_SCRATCH_DEF_NR_PAGES\t32\n\n \n#define VK_BAR1_DAUTH_BASE_ADDR\t\t0x6200\n#define VK_BAR1_DAUTH_STORE_SIZE\t0x48\n#define VK_BAR1_DAUTH_VALID_SIZE\t0x8\n#define VK_BAR1_DAUTH_MAX\t\t4\n#define VK_BAR1_DAUTH_STORE_ADDR(x) \\\n\t\t(VK_BAR1_DAUTH_BASE_ADDR + \\\n\t\t (x) * (VK_BAR1_DAUTH_STORE_SIZE + VK_BAR1_DAUTH_VALID_SIZE))\n#define VK_BAR1_DAUTH_VALID_ADDR(x) \\\n\t\t(VK_BAR1_DAUTH_STORE_ADDR(x) + VK_BAR1_DAUTH_STORE_SIZE)\n\n \n#define VK_BAR1_SOTP_REVID_BASE_ADDR\t0x6340\n#define VK_BAR1_SOTP_REVID_SIZE\t\t0x10\n#define VK_BAR1_SOTP_REVID_MAX\t\t2\n#define VK_BAR1_SOTP_REVID_ADDR(x) \\\n\t\t(VK_BAR1_SOTP_REVID_BASE_ADDR + (x) * VK_BAR1_SOTP_REVID_SIZE)\n\n \n#define MAX_BAR\t3\n\n \n#define BCM_VK_DEF_IB_SGL_BLK_LEN\t 16\n#define BCM_VK_IB_SGL_BLK_MAX\t\t 24\n\nenum pci_barno {\n\tBAR_0 = 0,\n\tBAR_1,\n\tBAR_2\n};\n\n#ifdef CONFIG_BCM_VK_TTY\n#define BCM_VK_NUM_TTY 2\n#else\n#define BCM_VK_NUM_TTY 0\n#endif\n\nstruct bcm_vk_tty {\n\tstruct tty_port port;\n\tu32 to_offset;\t \n\tu32 to_size;\t \n\tu32 wr;\t\t \n\tu32 from_offset;\t \n\tu32 from_size;\t \n\tu32 rd;\t\t \n\tpid_t pid;\n\tbool irq_enabled;\n\tbool is_opened;\t\t \n};\n\n \n#define MAX_OPP 3\n#define MAX_CARD_INFO_TAG_SIZE 64\n\nstruct bcm_vk_card_info {\n\tu32 version;\n\tchar os_tag[MAX_CARD_INFO_TAG_SIZE];\n\tchar cmpt_tag[MAX_CARD_INFO_TAG_SIZE];\n\tu32 cpu_freq_mhz;\n\tu32 cpu_scale[MAX_OPP];\n\tu32 ddr_freq_mhz;\n\tu32 ddr_size_MB;\n\tu32 video_core_freq_mhz;\n};\n\n \nstruct bcm_vk_dauth_key {\n\tchar store[VK_BAR1_DAUTH_STORE_SIZE];\n\tchar valid[VK_BAR1_DAUTH_VALID_SIZE];\n};\n\nstruct bcm_vk_dauth_info {\n\tstruct bcm_vk_dauth_key keys[VK_BAR1_DAUTH_MAX];\n};\n\n \nstruct bcm_vk_peer_log {\n\tu32 rd_idx;\n\tu32 wr_idx;\n\tu32 buf_size;\n\tu32 mask;\n\tchar data[];\n};\n\n \n#define BCM_VK_PEER_LOG_BUF_MAX SZ_16K\n \n#define BCM_VK_PEER_LOG_LINE_MAX  256\n\n \n#define BCM_VK_PROC_TYPE_TAG_LEN 8\nstruct bcm_vk_proc_mon_entry_t {\n\tchar tag[BCM_VK_PROC_TYPE_TAG_LEN];\n\tu32 used;\n\tu32 max;  \n};\n\n \n#define BCM_VK_PROC_MON_MAX 8  \nstruct bcm_vk_proc_mon_info {\n\tu32 num;  \n\tu32 entry_size;  \n\tstruct bcm_vk_proc_mon_entry_t entries[BCM_VK_PROC_MON_MAX];\n};\n\nstruct bcm_vk_hb_ctrl {\n\tstruct delayed_work work;\n\tu32 last_uptime;\n\tu32 lost_cnt;\n};\n\nstruct bcm_vk_alert {\n\tu16 flags;\n\tu16 notfs;\n};\n\n \nstruct bcm_vk_alert_cnts {\n\tu16 ecc;\n\tu16 uecc;\n};\n\nstruct bcm_vk {\n\tstruct pci_dev *pdev;\n\tvoid __iomem *bar[MAX_BAR];\n\tint num_irqs;\n\n\tstruct bcm_vk_card_info card_info;\n\tstruct bcm_vk_proc_mon_info proc_mon_info;\n\tstruct bcm_vk_dauth_info dauth_info;\n\n\t \n\tstruct mutex mutex;\n\tstruct miscdevice miscdev;\n\tint devid;  \n\n#ifdef CONFIG_BCM_VK_TTY\n\tstruct tty_driver *tty_drv;\n\tstruct timer_list serial_timer;\n\tstruct bcm_vk_tty tty[BCM_VK_NUM_TTY];\n\tstruct workqueue_struct *tty_wq_thread;\n\tstruct work_struct tty_wq_work;\n#endif\n\n\t \n\tstruct kref kref;\n\n\tspinlock_t msg_id_lock;  \n\tu16 msg_id;\n\tDECLARE_BITMAP(bmap, VK_MSG_ID_BITMAP_SIZE);\n\tspinlock_t ctx_lock;  \n\tstruct bcm_vk_ctx ctx[VK_CMPT_CTX_MAX];\n\tstruct bcm_vk_ht_entry pid_ht[VK_PID_HT_SZ];\n\tpid_t reset_pid;  \n\n\tatomic_t msgq_inited;  \n\tstruct bcm_vk_msg_chan to_v_msg_chan;\n\tstruct bcm_vk_msg_chan to_h_msg_chan;\n\n\tstruct workqueue_struct *wq_thread;\n\tstruct work_struct wq_work;  \n\tunsigned long wq_offload[1];  \n\tvoid *tdma_vaddr;  \n\tdma_addr_t tdma_addr;  \n\n\tstruct notifier_block panic_nb;\n\tu32 ib_sgl_size;  \n\n\t \n\tstruct bcm_vk_hb_ctrl hb_ctrl;\n\t \n\tspinlock_t host_alert_lock;  \n\tstruct bcm_vk_alert host_alert;\n\tstruct bcm_vk_alert peer_alert;  \n\tstruct bcm_vk_alert_cnts alert_cnts;\n\n\t \n\tu32 peerlog_off;\n\tstruct bcm_vk_peer_log peerlog_info;  \n\t \n\tu32 proc_mon_off;\n};\n\n \nenum bcm_vk_wq_offload_flags {\n\tBCM_VK_WQ_DWNLD_PEND = 0,\n\tBCM_VK_WQ_DWNLD_AUTO = 1,\n\tBCM_VK_WQ_NOTF_PEND  = 2,\n};\n\n \n#define BCM_VK_EXTRACT_FIELD(_field, _reg, _mask, _shift) \\\n\t\t(_field = (((_reg) >> (_shift)) & (_mask)))\n\nstruct bcm_vk_entry {\n\tconst u32 mask;\n\tconst u32 exp_val;\n\tconst char *str;\n};\n\n \n#define BCM_VK_PEER_ERR_NUM 12\nextern struct bcm_vk_entry const bcm_vk_peer_err[BCM_VK_PEER_ERR_NUM];\n \n#define BCM_VK_HOST_ERR_NUM 3\nextern struct bcm_vk_entry const bcm_vk_host_err[BCM_VK_HOST_ERR_NUM];\n\n \n#define BCM_VK_INTF_IS_DOWN(val) ((val) == 0xffffffff)\n\nstatic inline u32 vkread32(struct bcm_vk *vk, enum pci_barno bar, u64 offset)\n{\n\treturn readl(vk->bar[bar] + offset);\n}\n\nstatic inline void vkwrite32(struct bcm_vk *vk,\n\t\t\t     u32 value,\n\t\t\t     enum pci_barno bar,\n\t\t\t     u64 offset)\n{\n\twritel(value, vk->bar[bar] + offset);\n}\n\nstatic inline u8 vkread8(struct bcm_vk *vk, enum pci_barno bar, u64 offset)\n{\n\treturn readb(vk->bar[bar] + offset);\n}\n\nstatic inline void vkwrite8(struct bcm_vk *vk,\n\t\t\t    u8 value,\n\t\t\t    enum pci_barno bar,\n\t\t\t    u64 offset)\n{\n\twriteb(value, vk->bar[bar] + offset);\n}\n\nstatic inline bool bcm_vk_msgq_marker_valid(struct bcm_vk *vk)\n{\n\tu32 rdy_marker = 0;\n\tu32 fw_status;\n\n\tfw_status = vkread32(vk, BAR_0, VK_BAR_FWSTS);\n\n\tif ((fw_status & VK_FWSTS_READY) == VK_FWSTS_READY)\n\t\trdy_marker = vkread32(vk, BAR_1, VK_BAR1_MSGQ_DEF_RDY);\n\n\treturn (rdy_marker == VK_BAR1_MSGQ_RDY_MARKER);\n}\n\nint bcm_vk_open(struct inode *inode, struct file *p_file);\nssize_t bcm_vk_read(struct file *p_file, char __user *buf, size_t count,\n\t\t    loff_t *f_pos);\nssize_t bcm_vk_write(struct file *p_file, const char __user *buf,\n\t\t     size_t count, loff_t *f_pos);\n__poll_t bcm_vk_poll(struct file *p_file, struct poll_table_struct *wait);\nint bcm_vk_release(struct inode *inode, struct file *p_file);\nvoid bcm_vk_release_data(struct kref *kref);\nirqreturn_t bcm_vk_msgq_irqhandler(int irq, void *dev_id);\nirqreturn_t bcm_vk_notf_irqhandler(int irq, void *dev_id);\nirqreturn_t bcm_vk_tty_irqhandler(int irq, void *dev_id);\nint bcm_vk_msg_init(struct bcm_vk *vk);\nvoid bcm_vk_msg_remove(struct bcm_vk *vk);\nvoid bcm_vk_drain_msg_on_reset(struct bcm_vk *vk);\nint bcm_vk_sync_msgq(struct bcm_vk *vk, bool force_sync);\nvoid bcm_vk_blk_drv_access(struct bcm_vk *vk);\ns32 bcm_to_h_msg_dequeue(struct bcm_vk *vk);\nint bcm_vk_send_shutdown_msg(struct bcm_vk *vk, u32 shut_type,\n\t\t\t     const pid_t pid, const u32 q_num);\nvoid bcm_to_v_q_doorbell(struct bcm_vk *vk, u32 q_num, u32 db_val);\nint bcm_vk_auto_load_all_images(struct bcm_vk *vk);\nvoid bcm_vk_hb_init(struct bcm_vk *vk);\nvoid bcm_vk_hb_deinit(struct bcm_vk *vk);\nvoid bcm_vk_handle_notf(struct bcm_vk *vk);\nbool bcm_vk_drv_access_ok(struct bcm_vk *vk);\nvoid bcm_vk_set_host_alert(struct bcm_vk *vk, u32 bit_mask);\n\n#ifdef CONFIG_BCM_VK_TTY\nint bcm_vk_tty_init(struct bcm_vk *vk, char *name);\nvoid bcm_vk_tty_exit(struct bcm_vk *vk);\nvoid bcm_vk_tty_terminate_tty_user(struct bcm_vk *vk);\nvoid bcm_vk_tty_wq_exit(struct bcm_vk *vk);\n\nstatic inline void bcm_vk_tty_set_irq_enabled(struct bcm_vk *vk, int index)\n{\n\tvk->tty[index].irq_enabled = true;\n}\n#else\nstatic inline int bcm_vk_tty_init(struct bcm_vk *vk, char *name)\n{\n\treturn 0;\n}\n\nstatic inline void bcm_vk_tty_exit(struct bcm_vk *vk)\n{\n}\n\nstatic inline void bcm_vk_tty_terminate_tty_user(struct bcm_vk *vk)\n{\n}\n\nstatic inline void bcm_vk_tty_wq_exit(struct bcm_vk *vk)\n{\n}\n\nstatic inline void bcm_vk_tty_set_irq_enabled(struct bcm_vk *vk, int index)\n{\n}\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}