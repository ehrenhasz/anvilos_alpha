{
  "module_name": "bcm_vk_sg.c",
  "hash_id": "8b5ed2e065a378f03136adc6cf3ad90135aa107d9dc6cdb01563f9b3da02621e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/bcm-vk/bcm_vk_sg.c",
  "human_readable_source": "\n \n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n\n#include <asm/page.h>\n#include <asm/unaligned.h>\n\n#include <uapi/linux/misc/bcm_vk.h>\n\n#include \"bcm_vk.h\"\n#include \"bcm_vk_msg.h\"\n#include \"bcm_vk_sg.h\"\n\n \n#define BCM_VK_MAX_SGL_CHUNK SZ_16M\n\nstatic int bcm_vk_dma_alloc(struct device *dev,\n\t\t\t    struct bcm_vk_dma *dma,\n\t\t\t    int dir,\n\t\t\t    struct _vk_data *vkdata);\nstatic int bcm_vk_dma_free(struct device *dev, struct bcm_vk_dma *dma);\n\n \n \n\nstatic int bcm_vk_dma_alloc(struct device *dev,\n\t\t\t    struct bcm_vk_dma *dma,\n\t\t\t    int direction,\n\t\t\t    struct _vk_data *vkdata)\n{\n\tdma_addr_t addr, sg_addr;\n\tint err;\n\tint i;\n\tint offset;\n\tu32 size;\n\tu32 remaining_size;\n\tu32 transfer_size;\n\tu64 data;\n\tunsigned long first, last;\n\tstruct _vk_data *sgdata;\n\n\t \n\tdata = get_unaligned(&vkdata->address);\n\n\t \n\toffset = offset_in_page(data);\n\n\t \n\tfirst = (data & PAGE_MASK) >> PAGE_SHIFT;\n\tlast  = ((data + vkdata->size - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tdma->nr_pages = last - first + 1;\n\n\t \n\tdma->pages = kmalloc_array(dma->nr_pages,\n\t\t\t\t   sizeof(struct page *),\n\t\t\t\t   GFP_KERNEL);\n\tif (!dma->pages)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(dev, \"Alloc DMA Pages [0x%llx+0x%x => %d pages]\\n\",\n\t\tdata, vkdata->size, dma->nr_pages);\n\n\tdma->direction = direction;\n\n\t \n\terr = get_user_pages_fast(data & PAGE_MASK,\n\t\t\t\t  dma->nr_pages,\n\t\t\t\t  direction == DMA_FROM_DEVICE,\n\t\t\t\t  dma->pages);\n\tif (err != dma->nr_pages) {\n\t\tdma->nr_pages = (err >= 0) ? err : 0;\n\t\tdev_err(dev, \"get_user_pages_fast, err=%d [%d]\\n\",\n\t\t\terr, dma->nr_pages);\n\t\treturn err < 0 ? err : -EINVAL;\n\t}\n\n\t \n\tdma->sglen = (dma->nr_pages * sizeof(*sgdata)) +\n\t\t     (sizeof(u32) * SGLIST_VKDATA_START);\n\n\t \n\tdma->sglist = dma_alloc_coherent(dev,\n\t\t\t\t\t dma->sglen,\n\t\t\t\t\t &dma->handle,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!dma->sglist)\n\t\treturn -ENOMEM;\n\n\tdma->sglist[SGLIST_NUM_SG] = 0;\n\tdma->sglist[SGLIST_TOTALSIZE] = vkdata->size;\n\tremaining_size = vkdata->size;\n\tsgdata = (struct _vk_data *)&dma->sglist[SGLIST_VKDATA_START];\n\n\t \n\tsize = min_t(size_t, PAGE_SIZE - offset, remaining_size);\n\tremaining_size -= size;\n\tsg_addr = dma_map_page(dev,\n\t\t\t       dma->pages[0],\n\t\t\t       offset,\n\t\t\t       size,\n\t\t\t       dma->direction);\n\ttransfer_size = size;\n\tif (unlikely(dma_mapping_error(dev, sg_addr))) {\n\t\t__free_page(dma->pages[0]);\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 1; i < dma->nr_pages; i++) {\n\t\tsize = min_t(size_t, PAGE_SIZE, remaining_size);\n\t\tremaining_size -= size;\n\t\taddr = dma_map_page(dev,\n\t\t\t\t    dma->pages[i],\n\t\t\t\t    0,\n\t\t\t\t    size,\n\t\t\t\t    dma->direction);\n\t\tif (unlikely(dma_mapping_error(dev, addr))) {\n\t\t\t__free_page(dma->pages[i]);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif ((addr == (sg_addr + transfer_size)) &&\n\t\t    ((transfer_size + size) <= BCM_VK_MAX_SGL_CHUNK)) {\n\t\t\t \n\t\t\ttransfer_size += size;\n\t\t} else {\n\t\t\t \n\t\t\tsgdata->size = transfer_size;\n\t\t\tput_unaligned(sg_addr, (u64 *)&sgdata->address);\n\t\t\tdma->sglist[SGLIST_NUM_SG]++;\n\n\t\t\t \n\t\t\tsgdata++;\n\t\t\tsg_addr = addr;\n\t\t\ttransfer_size = size;\n\t\t}\n\t}\n\t \n\tsgdata->size = transfer_size;\n\tput_unaligned(sg_addr, (u64 *)&sgdata->address);\n\tdma->sglist[SGLIST_NUM_SG]++;\n\n\t \n\tput_unaligned((u64)dma->handle, &vkdata->address);\n\tvkdata->size = (dma->sglist[SGLIST_NUM_SG] * sizeof(*sgdata)) +\n\t\t       (sizeof(u32) * SGLIST_VKDATA_START);\n\n#ifdef BCM_VK_DUMP_SGLIST\n\tdev_dbg(dev,\n\t\t\"sgl 0x%llx handle 0x%llx, sglen: 0x%x sgsize: 0x%x\\n\",\n\t\t(u64)dma->sglist,\n\t\tdma->handle,\n\t\tdma->sglen,\n\t\tvkdata->size);\n\tfor (i = 0; i < vkdata->size / sizeof(u32); i++)\n\t\tdev_dbg(dev, \"i:0x%x 0x%x\\n\", i, dma->sglist[i]);\n#endif\n\n\treturn 0;\n}\n\nint bcm_vk_sg_alloc(struct device *dev,\n\t\t    struct bcm_vk_dma *dma,\n\t\t    int dir,\n\t\t    struct _vk_data *vkdata,\n\t\t    int num)\n{\n\tint i;\n\tint rc = -EINVAL;\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tif (vkdata[i].size && vkdata[i].address) {\n\t\t\t \n\t\t\trc = bcm_vk_dma_alloc(dev,\n\t\t\t\t\t      &dma[i],\n\t\t\t\t\t      dir,\n\t\t\t\t\t      &vkdata[i]);\n\t\t} else if (vkdata[i].size ||\n\t\t\t   vkdata[i].address) {\n\t\t\t \n\t\t\tdev_err(dev,\n\t\t\t\t\"Invalid vkdata %x 0x%x 0x%llx\\n\",\n\t\t\t\ti, vkdata[i].size, vkdata[i].address);\n\t\t\trc = -EINVAL;\n\t\t} else {\n\t\t\t \n\t\t\trc = 0;\n\t\t}\n\n\t\tif (rc)\n\t\t\tgoto fail_alloc;\n\t}\n\treturn rc;\n\nfail_alloc:\n\twhile (i > 0) {\n\t\ti--;\n\t\tif (dma[i].sglist)\n\t\t\tbcm_vk_dma_free(dev, &dma[i]);\n\t}\n\treturn rc;\n}\n\nstatic int bcm_vk_dma_free(struct device *dev, struct bcm_vk_dma *dma)\n{\n\tdma_addr_t addr;\n\tint i;\n\tint num_sg;\n\tu32 size;\n\tstruct _vk_data *vkdata;\n\n\tdev_dbg(dev, \"free sglist=%p sglen=0x%x\\n\", dma->sglist, dma->sglen);\n\n\t \n\tnum_sg = dma->sglist[SGLIST_NUM_SG];\n\tvkdata = (struct _vk_data *)&dma->sglist[SGLIST_VKDATA_START];\n\tfor (i = 0; i < num_sg; i++) {\n\t\tsize = vkdata[i].size;\n\t\taddr = get_unaligned(&vkdata[i].address);\n\n\t\tdma_unmap_page(dev, addr, size, dma->direction);\n\t}\n\n\t \n\tdma_free_coherent(dev, dma->sglen, dma->sglist, dma->handle);\n\n\t \n\tfor (i = 0; i < dma->nr_pages; i++)\n\t\tput_page(dma->pages[i]);\n\n\t \n\tkfree(dma->pages);\n\tdma->sglist = NULL;\n\n\treturn 0;\n}\n\nint bcm_vk_sg_free(struct device *dev, struct bcm_vk_dma *dma, int num,\n\t\t   int *proc_cnt)\n{\n\tint i;\n\n\t*proc_cnt = 0;\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tif (dma[i].sglist) {\n\t\t\tbcm_vk_dma_free(dev, &dma[i]);\n\t\t\t*proc_cnt += 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}