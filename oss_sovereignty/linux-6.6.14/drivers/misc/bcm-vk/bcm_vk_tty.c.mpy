{
  "module_name": "bcm_vk_tty.c",
  "hash_id": "51945629505d80c5d17efd3bf3f1f266b7e09fac54127a67f5866a622a01fe1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/bcm-vk/bcm_vk_tty.c",
  "human_readable_source": "\n \n\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n\n#include \"bcm_vk.h\"\n\n \n#define BAR1_TTYVK_BASE_OFFSET\t0x300000\n \n#define BAR1_TTYVK_CHAN_OFFSET\t0x100000\n \n#define BAR1_TTYVK_BASE(index)\t(BAR1_TTYVK_BASE_OFFSET + \\\n\t\t\t\t ((index) * BAR1_TTYVK_CHAN_OFFSET * 2))\n \n#define TO_TTYK_BASE(index)\tBAR1_TTYVK_BASE(index)\n#define FROM_TTYK_BASE(index)\t(BAR1_TTYVK_BASE(index) + \\\n\t\t\t\t BAR1_TTYVK_CHAN_OFFSET)\n\nstruct bcm_vk_tty_chan {\n\tu32 reserved;\n\tu32 size;\n\tu32 wr;\n\tu32 rd;\n\tu32 *data;\n};\n\n#define VK_BAR_CHAN(v, DIR, e)\t((v)->DIR##_offset \\\n\t\t\t\t + offsetof(struct bcm_vk_tty_chan, e))\n#define VK_BAR_CHAN_SIZE(v, DIR)\tVK_BAR_CHAN(v, DIR, size)\n#define VK_BAR_CHAN_WR(v, DIR)\t\tVK_BAR_CHAN(v, DIR, wr)\n#define VK_BAR_CHAN_RD(v, DIR)\t\tVK_BAR_CHAN(v, DIR, rd)\n#define VK_BAR_CHAN_DATA(v, DIR, off)\t(VK_BAR_CHAN(v, DIR, data) + (off))\n\n#define VK_BAR0_REGSEG_TTY_DB_OFFSET\t0x86c\n\n \n#define SERIAL_TIMER_VALUE (HZ / 10)\n\nstatic void bcm_vk_tty_poll(struct timer_list *t)\n{\n\tstruct bcm_vk *vk = from_timer(vk, t, serial_timer);\n\n\tqueue_work(vk->tty_wq_thread, &vk->tty_wq_work);\n\tmod_timer(&vk->serial_timer, jiffies + SERIAL_TIMER_VALUE);\n}\n\nirqreturn_t bcm_vk_tty_irqhandler(int irq, void *dev_id)\n{\n\tstruct bcm_vk *vk = dev_id;\n\n\tqueue_work(vk->tty_wq_thread, &vk->tty_wq_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void bcm_vk_tty_wq_handler(struct work_struct *work)\n{\n\tstruct bcm_vk *vk = container_of(work, struct bcm_vk, tty_wq_work);\n\tstruct bcm_vk_tty *vktty;\n\tint card_status;\n\tint count;\n\tunsigned char c;\n\tint i;\n\tint wr;\n\n\tcard_status = vkread32(vk, BAR_0, BAR_CARD_STATUS);\n\tif (BCM_VK_INTF_IS_DOWN(card_status))\n\t\treturn;\n\n\tfor (i = 0; i < BCM_VK_NUM_TTY; i++) {\n\t\tcount = 0;\n\t\t \n\t\tif ((card_status & BIT(i)) == 0)\n\t\t\tcontinue;\n\n\t\tvktty = &vk->tty[i];\n\n\t\t \n\t\tif (!vktty->is_opened)\n\t\t\tcontinue;\n\n\t\t \n\t\twr = vkread32(vk, BAR_1, VK_BAR_CHAN_WR(vktty, from));\n\n\t\t \n\t\tif (vktty->from_size == 0)\n\t\t\tcontinue;\n\n\t\tif (wr >= vktty->from_size) {\n\t\t\tdev_err(&vk->pdev->dev,\n\t\t\t\t\"ERROR: wq handler ttyVK%d wr:0x%x > 0x%x\\n\",\n\t\t\t\ti, wr, vktty->from_size);\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\twhile (vk->tty[i].rd != wr) {\n\t\t\tc = vkread8(vk, BAR_1,\n\t\t\t\t    VK_BAR_CHAN_DATA(vktty, from, vktty->rd));\n\t\t\tvktty->rd++;\n\t\t\tif (vktty->rd >= vktty->from_size)\n\t\t\t\tvktty->rd = 0;\n\t\t\ttty_insert_flip_char(&vktty->port, c, TTY_NORMAL);\n\t\t\tcount++;\n\t\t}\n\n\t\tif (count) {\n\t\t\ttty_flip_buffer_push(&vktty->port);\n\n\t\t\t \n\t\t\tvkwrite32(vk, vktty->rd, BAR_1,\n\t\t\t\t  VK_BAR_CHAN_RD(vktty, from));\n\t\t}\n\t}\n}\n\nstatic int bcm_vk_tty_open(struct tty_struct *tty, struct file *file)\n{\n\tint card_status;\n\tstruct bcm_vk *vk;\n\tstruct bcm_vk_tty *vktty;\n\tint index;\n\n\t \n\ttty->driver_data = NULL;\n\n\tvk = (struct bcm_vk *)dev_get_drvdata(tty->dev);\n\tindex = tty->index;\n\n\tif (index >= BCM_VK_NUM_TTY)\n\t\treturn -EINVAL;\n\n\tvktty = &vk->tty[index];\n\n\tvktty->pid = task_pid_nr(current);\n\tvktty->to_offset = TO_TTYK_BASE(index);\n\tvktty->from_offset = FROM_TTYK_BASE(index);\n\n\t \n\tcard_status = vkread32(vk, BAR_0, BAR_CARD_STATUS);\n\tif (BCM_VK_INTF_IS_DOWN(card_status) || ((card_status & BIT(index)) == 0))\n\t\treturn -EBUSY;\n\n\t \n\tvktty->to_size = vkread32(vk, BAR_1, VK_BAR_CHAN_SIZE(vktty, to));\n\tvktty->wr = vkread32(vk, BAR_1,  VK_BAR_CHAN_WR(vktty, to));\n\tvktty->from_size = vkread32(vk, BAR_1, VK_BAR_CHAN_SIZE(vktty, from));\n\tvktty->rd = vkread32(vk, BAR_1,  VK_BAR_CHAN_RD(vktty, from));\n\tvktty->is_opened = true;\n\n\tif (tty->count == 1 && !vktty->irq_enabled) {\n\t\ttimer_setup(&vk->serial_timer, bcm_vk_tty_poll, 0);\n\t\tmod_timer(&vk->serial_timer, jiffies + SERIAL_TIMER_VALUE);\n\t}\n\treturn 0;\n}\n\nstatic void bcm_vk_tty_close(struct tty_struct *tty, struct file *file)\n{\n\tstruct bcm_vk *vk = dev_get_drvdata(tty->dev);\n\n\tif (tty->index >= BCM_VK_NUM_TTY)\n\t\treturn;\n\n\tvk->tty[tty->index].is_opened = false;\n\n\tif (tty->count == 1)\n\t\tdel_timer_sync(&vk->serial_timer);\n}\n\nstatic void bcm_vk_tty_doorbell(struct bcm_vk *vk, u32 db_val)\n{\n\tvkwrite32(vk, db_val, BAR_0,\n\t\t  VK_BAR0_REGSEG_DB_BASE + VK_BAR0_REGSEG_TTY_DB_OFFSET);\n}\n\nstatic ssize_t bcm_vk_tty_write(struct tty_struct *tty, const u8 *buffer,\n\t\t\t\tsize_t count)\n{\n\tint index;\n\tstruct bcm_vk *vk;\n\tstruct bcm_vk_tty *vktty;\n\tint i;\n\n\tindex = tty->index;\n\tvk = dev_get_drvdata(tty->dev);\n\tvktty = &vk->tty[index];\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tvkwrite8(vk, buffer[i], BAR_1,\n\t\t\t VK_BAR_CHAN_DATA(vktty, to, vktty->wr));\n\t\tvktty->wr++;\n\t\tif (vktty->wr >= vktty->to_size)\n\t\t\tvktty->wr = 0;\n\t}\n\t \n\tvkwrite32(vk, vktty->wr, BAR_1, VK_BAR_CHAN_WR(vktty, to));\n\tbcm_vk_tty_doorbell(vk, 0);\n\n\treturn count;\n}\n\nstatic unsigned int bcm_vk_tty_write_room(struct tty_struct *tty)\n{\n\tstruct bcm_vk *vk = dev_get_drvdata(tty->dev);\n\n\treturn vk->tty[tty->index].to_size - 1;\n}\n\nstatic const struct tty_operations serial_ops = {\n\t.open = bcm_vk_tty_open,\n\t.close = bcm_vk_tty_close,\n\t.write = bcm_vk_tty_write,\n\t.write_room = bcm_vk_tty_write_room,\n};\n\nint bcm_vk_tty_init(struct bcm_vk *vk, char *name)\n{\n\tint i;\n\tint err;\n\tstruct tty_driver *tty_drv;\n\tstruct device *dev = &vk->pdev->dev;\n\n\ttty_drv = tty_alloc_driver\n\t\t\t\t(BCM_VK_NUM_TTY,\n\t\t\t\t TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(tty_drv))\n\t\treturn PTR_ERR(tty_drv);\n\n\t \n\tvk->tty_drv = tty_drv;\n\n\t \n\ttty_drv->driver_name = KBUILD_MODNAME;\n\ttty_drv->name = kstrdup(name, GFP_KERNEL);\n\tif (!tty_drv->name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_tty_driver_kref_put;\n\t}\n\ttty_drv->type = TTY_DRIVER_TYPE_SERIAL;\n\ttty_drv->subtype = SERIAL_TYPE_NORMAL;\n\ttty_drv->init_termios = tty_std_termios;\n\ttty_set_operations(tty_drv, &serial_ops);\n\n\t \n\terr = tty_register_driver(tty_drv);\n\tif (err) {\n\t\tdev_err(dev, \"tty_register_driver failed\\n\");\n\t\tgoto err_kfree_tty_name;\n\t}\n\n\tfor (i = 0; i < BCM_VK_NUM_TTY; i++) {\n\t\tstruct device *tty_dev;\n\n\t\ttty_port_init(&vk->tty[i].port);\n\t\ttty_dev = tty_port_register_device_attr(&vk->tty[i].port,\n\t\t\t\t\t\t\ttty_drv, i, dev, vk,\n\t\t\t\t\t\t\tNULL);\n\t\tif (IS_ERR(tty_dev)) {\n\t\t\terr = PTR_ERR(tty_dev);\n\t\t\tgoto unwind;\n\t\t}\n\t\tvk->tty[i].is_opened = false;\n\t}\n\n\tINIT_WORK(&vk->tty_wq_work, bcm_vk_tty_wq_handler);\n\tvk->tty_wq_thread = create_singlethread_workqueue(\"tty\");\n\tif (!vk->tty_wq_thread) {\n\t\tdev_err(dev, \"Fail to create tty workqueue thread\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\treturn 0;\n\nunwind:\n\twhile (--i >= 0)\n\t\ttty_port_unregister_device(&vk->tty[i].port, tty_drv, i);\n\ttty_unregister_driver(tty_drv);\n\nerr_kfree_tty_name:\n\tkfree(tty_drv->name);\n\ttty_drv->name = NULL;\n\nerr_tty_driver_kref_put:\n\ttty_driver_kref_put(tty_drv);\n\n\treturn err;\n}\n\nvoid bcm_vk_tty_exit(struct bcm_vk *vk)\n{\n\tint i;\n\n\tdel_timer_sync(&vk->serial_timer);\n\tfor (i = 0; i < BCM_VK_NUM_TTY; ++i) {\n\t\ttty_port_unregister_device(&vk->tty[i].port,\n\t\t\t\t\t   vk->tty_drv,\n\t\t\t\t\t   i);\n\t\ttty_port_destroy(&vk->tty[i].port);\n\t}\n\ttty_unregister_driver(vk->tty_drv);\n\n\tkfree(vk->tty_drv->name);\n\tvk->tty_drv->name = NULL;\n\n\ttty_driver_kref_put(vk->tty_drv);\n}\n\nvoid bcm_vk_tty_terminate_tty_user(struct bcm_vk *vk)\n{\n\tstruct bcm_vk_tty *vktty;\n\tint i;\n\n\tfor (i = 0; i < BCM_VK_NUM_TTY; ++i) {\n\t\tvktty = &vk->tty[i];\n\t\tif (vktty->pid)\n\t\t\tkill_pid(find_vpid(vktty->pid), SIGKILL, 1);\n\t}\n}\n\nvoid bcm_vk_tty_wq_exit(struct bcm_vk *vk)\n{\n\tcancel_work_sync(&vk->tty_wq_work);\n\tdestroy_workqueue(vk->tty_wq_thread);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}