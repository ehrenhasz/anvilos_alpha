{
  "module_name": "hi6421v600-irq.c",
  "hash_id": "4c59fc121dd2218ddc779a291bc9de1417909a9f736cb697edd4e4e07485a3e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/hi6421v600-irq.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of_gpio.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/regmap.h>\n\nstruct hi6421v600_irq {\n\tstruct device\t\t*dev;\n\tstruct irq_domain\t*domain;\n\tint\t\t\tirq;\n\tunsigned int\t\t*irqs;\n\tstruct regmap\t\t*regmap;\n\n\t \n\tspinlock_t\t\tlock;\n};\n\nenum hi6421v600_irq_list {\n\tOTMP = 0,\n\tVBUS_CONNECT,\n\tVBUS_DISCONNECT,\n\tALARMON_R,\n\tHOLD_6S,\n\tHOLD_1S,\n\tPOWERKEY_UP,\n\tPOWERKEY_DOWN,\n\tOCP_SCP_R,\n\tCOUL_R,\n\tSIM0_HPD_R,\n\tSIM0_HPD_F,\n\tSIM1_HPD_R,\n\tSIM1_HPD_F,\n\n\tPMIC_IRQ_LIST_MAX\n};\n\n#define HISI_IRQ_BANK_SIZE\t\t2\n\n \n#define HISI_POWERKEY_IRQ_NUM\t\t0\n#define HISI_IRQ_POWERKEY_UP_DOWN\t(BIT(POWERKEY_DOWN) | BIT(POWERKEY_UP))\n\n \n#define SOC_PMIC_IRQ_MASK_0_ADDR\t0x0202\n#define SOC_PMIC_IRQ0_ADDR\t\t0x0212\n\n \n#define HISI_IRQ_MASK_REG(irq_data)\t(SOC_PMIC_IRQ_MASK_0_ADDR + \\\n\t\t\t\t\t (irqd_to_hwirq(irq_data) / BITS_PER_BYTE))\n#define HISI_IRQ_MASK_BIT(irq_data)\tBIT(irqd_to_hwirq(irq_data) & (BITS_PER_BYTE - 1))\n#define HISI_8BITS_MASK\t\t\t0xff\n\nstatic irqreturn_t hi6421v600_irq_handler(int irq, void *__priv)\n{\n\tstruct hi6421v600_irq *priv = __priv;\n\tunsigned long pending;\n\tunsigned int in;\n\tint i, offset;\n\n\tfor (i = 0; i < HISI_IRQ_BANK_SIZE; i++) {\n\t\tregmap_read(priv->regmap, SOC_PMIC_IRQ0_ADDR + i, &in);\n\n\t\t \n\t\tregmap_write(priv->regmap, SOC_PMIC_IRQ0_ADDR + i, in);\n\n\t\tpending = in & HISI_8BITS_MASK;\n\n\t\tif (i == HISI_POWERKEY_IRQ_NUM &&\n\t\t    (pending & HISI_IRQ_POWERKEY_UP_DOWN) == HISI_IRQ_POWERKEY_UP_DOWN) {\n\t\t\t \n\t\t\tgeneric_handle_irq_safe(priv->irqs[POWERKEY_DOWN]);\n\t\t\tgeneric_handle_irq_safe(priv->irqs[POWERKEY_UP]);\n\t\t\tpending &= ~HISI_IRQ_POWERKEY_UP_DOWN;\n\t\t}\n\n\t\tif (!pending)\n\t\t\tcontinue;\n\n\t\tfor_each_set_bit(offset, &pending, BITS_PER_BYTE) {\n\t\t\tgeneric_handle_irq_safe(priv->irqs[offset + i * BITS_PER_BYTE]);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void hi6421v600_irq_mask(struct irq_data *d)\n{\n\tstruct hi6421v600_irq *priv = irq_data_get_irq_chip_data(d);\n\tunsigned long flags;\n\tunsigned int data;\n\tu32 offset;\n\n\toffset = HISI_IRQ_MASK_REG(d);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tregmap_read(priv->regmap, offset, &data);\n\tdata |= HISI_IRQ_MASK_BIT(d);\n\tregmap_write(priv->regmap, offset, data);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void hi6421v600_irq_unmask(struct irq_data *d)\n{\n\tstruct hi6421v600_irq *priv = irq_data_get_irq_chip_data(d);\n\tu32 data, offset;\n\tunsigned long flags;\n\n\toffset = HISI_IRQ_MASK_REG(d);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tregmap_read(priv->regmap, offset, &data);\n\tdata &= ~HISI_IRQ_MASK_BIT(d);\n\tregmap_write(priv->regmap, offset, data);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic struct irq_chip hi6421v600_pmu_irqchip = {\n\t.name\t\t= \"hi6421v600-irq\",\n\t.irq_mask\t= hi6421v600_irq_mask,\n\t.irq_unmask\t= hi6421v600_irq_unmask,\n\t.irq_disable\t= hi6421v600_irq_mask,\n\t.irq_enable\t= hi6421v600_irq_unmask,\n};\n\nstatic int hi6421v600_irq_map(struct irq_domain *d, unsigned int virq,\n\t\t\t      irq_hw_number_t hw)\n{\n\tstruct hi6421v600_irq *priv = d->host_data;\n\n\tirq_set_chip_and_handler_name(virq, &hi6421v600_pmu_irqchip,\n\t\t\t\t      handle_simple_irq, \"hi6421v600\");\n\tirq_set_chip_data(virq, priv);\n\tirq_set_irq_type(virq, IRQ_TYPE_NONE);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops hi6421v600_domain_ops = {\n\t.map\t= hi6421v600_irq_map,\n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\nstatic void hi6421v600_irq_init(struct hi6421v600_irq *priv)\n{\n\tint i;\n\tunsigned int pending;\n\n\t \n\tfor (i = 0; i < HISI_IRQ_BANK_SIZE; i++)\n\t\tregmap_write(priv->regmap, SOC_PMIC_IRQ_MASK_0_ADDR + i,\n\t\t\t     HISI_8BITS_MASK);\n\n\t \n\tfor (i = 0; i < HISI_IRQ_BANK_SIZE; i++) {\n\t\tregmap_read(priv->regmap, SOC_PMIC_IRQ0_ADDR + i, &pending);\n\t\tregmap_write(priv->regmap, SOC_PMIC_IRQ0_ADDR + i,\n\t\t\t     HISI_8BITS_MASK);\n\t}\n}\n\nstatic int hi6421v600_irq_probe(struct platform_device *pdev)\n{\n\tstruct device *pmic_dev = pdev->dev.parent;\n\tstruct device_node *np = pmic_dev->of_node;\n\tstruct platform_device *pmic_pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct hi6421v600_irq *priv;\n\tstruct regmap *regmap;\n\tunsigned int virq;\n\tint i, ret;\n\n\t \n\tregmap = dev_get_drvdata(pmic_dev);\n\tif (WARN_ON(!regmap))\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->regmap = regmap;\n\n\tspin_lock_init(&priv->lock);\n\n\tpmic_pdev = container_of(pmic_dev, struct platform_device, dev);\n\n\tpriv->irq = platform_get_irq(pmic_pdev, 0);\n\tif (priv->irq < 0)\n\t\treturn priv->irq;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\thi6421v600_irq_init(priv);\n\n\tpriv->irqs = devm_kzalloc(dev, PMIC_IRQ_LIST_MAX * sizeof(int), GFP_KERNEL);\n\tif (!priv->irqs)\n\t\treturn -ENOMEM;\n\n\tpriv->domain = irq_domain_add_simple(np, PMIC_IRQ_LIST_MAX, 0,\n\t\t\t\t\t     &hi6421v600_domain_ops, priv);\n\tif (!priv->domain) {\n\t\tdev_err(dev, \"Failed to create IRQ domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < PMIC_IRQ_LIST_MAX; i++) {\n\t\tvirq = irq_create_mapping(priv->domain, i);\n\t\tif (!virq) {\n\t\t\tdev_err(dev, \"Failed to map H/W IRQ\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tpriv->irqs[i] = virq;\n\t}\n\n\tret = devm_request_threaded_irq(dev,\n\t\t\t\t\tpriv->irq, hi6421v600_irq_handler,\n\t\t\t\t\tNULL,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_SHARED | IRQF_NO_SUSPEND,\n\t\t\t\t\t\"pmic\", priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to start IRQ handling thread: error %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id hi6421v600_irq_table[] = {\n\t{ .name = \"hi6421v600-irq\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, hi6421v600_irq_table);\n\nstatic struct platform_driver hi6421v600_irq_driver = {\n\t.id_table = hi6421v600_irq_table,\n\t.driver = {\n\t\t.name = \"hi6421v600-irq\",\n\t},\n\t.probe\t= hi6421v600_irq_probe,\n};\nmodule_platform_driver(hi6421v600_irq_driver);\n\nMODULE_DESCRIPTION(\"HiSilicon Hi6421v600 IRQ driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}