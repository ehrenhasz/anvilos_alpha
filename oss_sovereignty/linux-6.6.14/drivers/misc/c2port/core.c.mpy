{
  "module_name": "core.c",
  "hash_id": "4482108cd73977f610dd132f1d5698cee27af493c0596318fafe52272902f73a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/c2port/core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <linux/c2port.h>\n\n#define DRIVER_NAME             \"c2port\"\n#define DRIVER_VERSION          \"0.51.0\"\n\nstatic DEFINE_SPINLOCK(c2port_idr_lock);\nstatic DEFINE_IDR(c2port_idr);\n\n \n\nstatic struct class *c2port_class;\n\n \n\n \n#define C2PORT_DEVICEID\t\t0x00\n#define C2PORT_REVID\t\t0x01\n#define C2PORT_FPCTL\t\t0x02\n#define C2PORT_FPDAT\t\t0xB4\n\n \n#define C2PORT_GET_VERSION\t0x01\n#define C2PORT_DEVICE_ERASE\t0x03\n#define C2PORT_BLOCK_READ\t0x06\n#define C2PORT_BLOCK_WRITE\t0x07\n#define C2PORT_PAGE_ERASE\t0x08\n\n \n#define C2PORT_INVALID_COMMAND\t0x00\n#define C2PORT_COMMAND_FAILED\t0x02\n#define C2PORT_COMMAND_OK\t0x0d\n\n \n\nstatic void c2port_reset(struct c2port_device *dev)\n{\n\tstruct c2port_ops *ops = dev->ops;\n\n\t \n\tlocal_irq_disable();\n\tops->c2ck_set(dev, 0);\n\tudelay(25);\n\tops->c2ck_set(dev, 1);\n\tlocal_irq_enable();\n\n\tudelay(1);\n}\n\nstatic void c2port_strobe_ck(struct c2port_device *dev)\n{\n\tstruct c2port_ops *ops = dev->ops;\n\n\t \n\tlocal_irq_disable();\n\tops->c2ck_set(dev, 0);\n\tudelay(1);\n\tops->c2ck_set(dev, 1);\n\tlocal_irq_enable();\n\n\tudelay(1);\n}\n\n \n\nstatic void c2port_write_ar(struct c2port_device *dev, u8 addr)\n{\n\tstruct c2port_ops *ops = dev->ops;\n\tint i;\n\n\t \n\tc2port_strobe_ck(dev);\n\n\t \n\tops->c2d_dir(dev, 0);\n\tops->c2d_set(dev, 1);\n\tc2port_strobe_ck(dev);\n\tops->c2d_set(dev, 1);\n\tc2port_strobe_ck(dev);\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tops->c2d_set(dev, addr & 0x01);\n\t\tc2port_strobe_ck(dev);\n\n\t\taddr >>= 1;\n\t}\n\n\t \n\tops->c2d_dir(dev, 1);\n\tc2port_strobe_ck(dev);\n}\n\nstatic int c2port_read_ar(struct c2port_device *dev, u8 *addr)\n{\n\tstruct c2port_ops *ops = dev->ops;\n\tint i;\n\n\t \n\tc2port_strobe_ck(dev);\n\n\t \n\tops->c2d_dir(dev, 0);\n\tops->c2d_set(dev, 0);\n\tc2port_strobe_ck(dev);\n\tops->c2d_set(dev, 1);\n\tc2port_strobe_ck(dev);\n\n\t \n\tops->c2d_dir(dev, 1);\n\t*addr = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\t*addr >>= 1;\t \n\n\t\tc2port_strobe_ck(dev);\n\t\tif (ops->c2d_get(dev))\n\t\t\t*addr |= 0x80;\n\t}\n\n\t \n\tc2port_strobe_ck(dev);\n\n\treturn 0;\n}\n\nstatic int c2port_write_dr(struct c2port_device *dev, u8 data)\n{\n\tstruct c2port_ops *ops = dev->ops;\n\tint timeout, i;\n\n\t \n\tc2port_strobe_ck(dev);\n\n\t \n\tops->c2d_dir(dev, 0);\n\tops->c2d_set(dev, 1);\n\tc2port_strobe_ck(dev);\n\tops->c2d_set(dev, 0);\n\tc2port_strobe_ck(dev);\n\n\t \n\tops->c2d_set(dev, 0);\n\tc2port_strobe_ck(dev);\n\tops->c2d_set(dev, 0);\n\tc2port_strobe_ck(dev);\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tops->c2d_set(dev, data & 0x01);\n\t\tc2port_strobe_ck(dev);\n\n\t\tdata >>= 1;\n\t}\n\n\t \n\tops->c2d_dir(dev, 1);\n\ttimeout = 20;\n\tdo {\n\t\tc2port_strobe_ck(dev);\n\t\tif (ops->c2d_get(dev))\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t} while (--timeout > 0);\n\tif (timeout == 0)\n\t\treturn -EIO;\n\n\t \n\tc2port_strobe_ck(dev);\n\n\treturn 0;\n}\n\nstatic int c2port_read_dr(struct c2port_device *dev, u8 *data)\n{\n\tstruct c2port_ops *ops = dev->ops;\n\tint timeout, i;\n\n\t \n\tc2port_strobe_ck(dev);\n\n\t \n\tops->c2d_dir(dev, 0);\n\tops->c2d_set(dev, 0);\n\tc2port_strobe_ck(dev);\n\tops->c2d_set(dev, 0);\n\tc2port_strobe_ck(dev);\n\n\t \n\tops->c2d_set(dev, 0);\n\tc2port_strobe_ck(dev);\n\tops->c2d_set(dev, 0);\n\tc2port_strobe_ck(dev);\n\n\t \n\tops->c2d_dir(dev, 1);\n\ttimeout = 20;\n\tdo {\n\t\tc2port_strobe_ck(dev);\n\t\tif (ops->c2d_get(dev))\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t} while (--timeout > 0);\n\tif (timeout == 0)\n\t\treturn -EIO;\n\n\t \n\t*data = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\t*data >>= 1;\t \n\n\t\tc2port_strobe_ck(dev);\n\t\tif (ops->c2d_get(dev))\n\t\t\t*data |= 0x80;\n\t}\n\n\t \n\tc2port_strobe_ck(dev);\n\n\treturn 0;\n}\n\nstatic int c2port_poll_in_busy(struct c2port_device *dev)\n{\n\tu8 addr;\n\tint ret, timeout = 20;\n\n\tdo {\n\t\tret = (c2port_read_ar(dev, &addr));\n\t\tif (ret < 0)\n\t\t\treturn -EIO;\n\n\t\tif (!(addr & 0x02))\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t} while (--timeout > 0);\n\tif (timeout == 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int c2port_poll_out_ready(struct c2port_device *dev)\n{\n\tu8 addr;\n\tint ret, timeout = 10000;  \n\n\tdo {\n\t\tret = (c2port_read_ar(dev, &addr));\n\t\tif (ret < 0)\n\t\t\treturn -EIO;\n\n\t\tif (addr & 0x01)\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t} while (--timeout > 0);\n\tif (timeout == 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \n\nstatic ssize_t c2port_show_name(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", c2dev->name);\n}\nstatic DEVICE_ATTR(name, 0444, c2port_show_name, NULL);\n\nstatic ssize_t c2port_show_flash_blocks_num(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\tstruct c2port_ops *ops = c2dev->ops;\n\n\treturn sprintf(buf, \"%d\\n\", ops->blocks_num);\n}\nstatic DEVICE_ATTR(flash_blocks_num, 0444, c2port_show_flash_blocks_num, NULL);\n\nstatic ssize_t c2port_show_flash_block_size(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\tstruct c2port_ops *ops = c2dev->ops;\n\n\treturn sprintf(buf, \"%d\\n\", ops->block_size);\n}\nstatic DEVICE_ATTR(flash_block_size, 0444, c2port_show_flash_block_size, NULL);\n\nstatic ssize_t c2port_show_flash_size(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\tstruct c2port_ops *ops = c2dev->ops;\n\n\treturn sprintf(buf, \"%d\\n\", ops->blocks_num * ops->block_size);\n}\nstatic DEVICE_ATTR(flash_size, 0444, c2port_show_flash_size, NULL);\n\nstatic ssize_t access_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", c2dev->access);\n}\n\nstatic ssize_t access_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\tstruct c2port_ops *ops = c2dev->ops;\n\tint status, ret;\n\n\tret = sscanf(buf, \"%d\", &status);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&c2dev->mutex);\n\n\tc2dev->access = !!status;\n\n\t \n\tif (c2dev->access)\n\t\tops->c2ck_set(c2dev, 1);\n\tops->access(c2dev, c2dev->access);\n\tif (c2dev->access)\n\t\tops->c2d_dir(c2dev, 1);\n\n\tmutex_unlock(&c2dev->mutex);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(access);\n\nstatic ssize_t c2port_store_reset(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\n\t \n\tif (!c2dev->access)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&c2dev->mutex);\n\n\tc2port_reset(c2dev);\n\tc2dev->flash_access = 0;\n\n\tmutex_unlock(&c2dev->mutex);\n\n\treturn count;\n}\nstatic DEVICE_ATTR(reset, 0200, NULL, c2port_store_reset);\n\nstatic ssize_t __c2port_show_dev_id(struct c2port_device *dev, char *buf)\n{\n\tu8 data;\n\tint ret;\n\n\t \n\tc2port_write_ar(dev, C2PORT_DEVICEID);\n\n\t \n\tret = c2port_read_dr(dev, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", data);\n}\n\nstatic ssize_t c2port_show_dev_id(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\tssize_t ret;\n\n\t \n\tif (!c2dev->access)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&c2dev->mutex);\n\tret = __c2port_show_dev_id(c2dev, buf);\n\tmutex_unlock(&c2dev->mutex);\n\n\tif (ret < 0)\n\t\tdev_err(dev, \"cannot read from %s\\n\", c2dev->name);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR(dev_id, 0444, c2port_show_dev_id, NULL);\n\nstatic ssize_t __c2port_show_rev_id(struct c2port_device *dev, char *buf)\n{\n\tu8 data;\n\tint ret;\n\n\t \n\tc2port_write_ar(dev, C2PORT_REVID);\n\n\t \n\tret = c2port_read_dr(dev, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", data);\n}\n\nstatic ssize_t c2port_show_rev_id(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\tssize_t ret;\n\n\t \n\tif (!c2dev->access)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&c2dev->mutex);\n\tret = __c2port_show_rev_id(c2dev, buf);\n\tmutex_unlock(&c2dev->mutex);\n\n\tif (ret < 0)\n\t\tdev_err(c2dev->dev, \"cannot read from %s\\n\", c2dev->name);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR(rev_id, 0444, c2port_show_rev_id, NULL);\n\nstatic ssize_t c2port_show_flash_access(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", c2dev->flash_access);\n}\n\nstatic ssize_t __c2port_store_flash_access(struct c2port_device *dev,\n\t\t\t\t\t\tint status)\n{\n\tint ret;\n\n\t \n\tif (!dev->access)\n\t\treturn -EBUSY;\n\n\tdev->flash_access = !!status;\n\n\t \n\tif (dev->flash_access == 0)\n\t\treturn 0;\n\n\t \n\tc2port_write_ar(dev, C2PORT_FPCTL);\n\n\t \n\tret = c2port_write_dr(dev, 0x02);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = c2port_write_dr(dev, 0x01);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmdelay(25);\n\n\treturn 0;\n}\n\nstatic ssize_t c2port_store_flash_access(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\tint status;\n\tssize_t ret;\n\n\tret = sscanf(buf, \"%d\", &status);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&c2dev->mutex);\n\tret = __c2port_store_flash_access(c2dev, status);\n\tmutex_unlock(&c2dev->mutex);\n\n\tif (ret < 0) {\n\t\tdev_err(c2dev->dev, \"cannot enable %s flash programming\\n\",\n\t\t\tc2dev->name);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR(flash_access, 0644, c2port_show_flash_access,\n\t\t   c2port_store_flash_access);\n\nstatic ssize_t __c2port_write_flash_erase(struct c2port_device *dev)\n{\n\tu8 status;\n\tint ret;\n\n\t \n\tc2port_write_ar(dev, C2PORT_FPDAT);\n\n\t \n\tc2port_write_dr(dev, C2PORT_DEVICE_ERASE);\n\n\t \n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\t \n\tret = c2port_poll_out_ready(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = c2port_read_dr(dev, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (status != C2PORT_COMMAND_OK)\n\t\treturn -EBUSY;\n\n\t \n\tc2port_write_dr(dev, 0xde);\n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tc2port_write_dr(dev, 0xad);\n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tc2port_write_dr(dev, 0xa5);\n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = c2port_poll_out_ready(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic ssize_t c2port_store_flash_erase(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tif (!c2dev->access || !c2dev->flash_access)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&c2dev->mutex);\n\tret = __c2port_write_flash_erase(c2dev);\n\tmutex_unlock(&c2dev->mutex);\n\n\tif (ret < 0) {\n\t\tdev_err(c2dev->dev, \"cannot erase %s flash\\n\", c2dev->name);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR(flash_erase, 0200, NULL, c2port_store_flash_erase);\n\nstatic ssize_t __c2port_read_flash_data(struct c2port_device *dev,\n\t\t\t\tchar *buffer, loff_t offset, size_t count)\n{\n\tstruct c2port_ops *ops = dev->ops;\n\tu8 status, nread = 128;\n\tint i, ret;\n\n\t \n\tif (offset >= ops->block_size * ops->blocks_num)\n\t\treturn 0;\n\n\tif (ops->block_size * ops->blocks_num - offset < nread)\n\t\tnread = ops->block_size * ops->blocks_num - offset;\n\tif (count < nread)\n\t\tnread = count;\n\tif (nread == 0)\n\t\treturn nread;\n\n\t \n\tc2port_write_ar(dev, C2PORT_FPDAT);\n\n\t \n\tc2port_write_dr(dev, C2PORT_BLOCK_READ);\n\n\t \n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\t \n\tret = c2port_poll_out_ready(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = c2port_read_dr(dev, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (status != C2PORT_COMMAND_OK)\n\t\treturn -EBUSY;\n\n\t \n\tc2port_write_dr(dev, offset >> 8);\n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tc2port_write_dr(dev, offset & 0x00ff);\n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tc2port_write_dr(dev, nread);\n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\t \n\tret = c2port_poll_out_ready(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = c2port_read_dr(dev, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (status != C2PORT_COMMAND_OK)\n\t\treturn -EBUSY;\n\n\t \n\tfor (i = 0; i < nread; i++) {\n\t\tret = c2port_poll_out_ready(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = c2port_read_dr(dev, buffer+i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn nread;\n}\n\nstatic ssize_t c2port_read_flash_data(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *attr,\n\t\t\t\tchar *buffer, loff_t offset, size_t count)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(kobj_to_dev(kobj));\n\tssize_t ret;\n\n\t \n\tif (!c2dev->access || !c2dev->flash_access)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&c2dev->mutex);\n\tret = __c2port_read_flash_data(c2dev, buffer, offset, count);\n\tmutex_unlock(&c2dev->mutex);\n\n\tif (ret < 0)\n\t\tdev_err(c2dev->dev, \"cannot read %s flash\\n\", c2dev->name);\n\n\treturn ret;\n}\n\nstatic ssize_t __c2port_write_flash_data(struct c2port_device *dev,\n\t\t\t\tchar *buffer, loff_t offset, size_t count)\n{\n\tstruct c2port_ops *ops = dev->ops;\n\tu8 status, nwrite = 128;\n\tint i, ret;\n\n\tif (nwrite > count)\n\t\tnwrite = count;\n\tif (ops->block_size * ops->blocks_num - offset < nwrite)\n\t\tnwrite = ops->block_size * ops->blocks_num - offset;\n\n\t \n\tif (offset >= ops->block_size * ops->blocks_num)\n\t\treturn -EINVAL;\n\n\t \n\tc2port_write_ar(dev, C2PORT_FPDAT);\n\n\t \n\tc2port_write_dr(dev, C2PORT_BLOCK_WRITE);\n\n\t \n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\t \n\tret = c2port_poll_out_ready(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = c2port_read_dr(dev, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (status != C2PORT_COMMAND_OK)\n\t\treturn -EBUSY;\n\n\t \n\tc2port_write_dr(dev, offset >> 8);\n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tc2port_write_dr(dev, offset & 0x00ff);\n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tc2port_write_dr(dev, nwrite);\n\tret = c2port_poll_in_busy(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\t \n\tret = c2port_poll_out_ready(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = c2port_read_dr(dev, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (status != C2PORT_COMMAND_OK)\n\t\treturn -EBUSY;\n\n\t \n\tfor (i = 0; i < nwrite; i++) {\n\t\tret = c2port_write_dr(dev, *(buffer+i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = c2port_poll_in_busy(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t}\n\n\t \n\tret = c2port_poll_out_ready(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn nwrite;\n}\n\nstatic ssize_t c2port_write_flash_data(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *attr,\n\t\t\t\tchar *buffer, loff_t offset, size_t count)\n{\n\tstruct c2port_device *c2dev = dev_get_drvdata(kobj_to_dev(kobj));\n\tint ret;\n\n\t \n\tif (!c2dev->access || !c2dev->flash_access)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&c2dev->mutex);\n\tret = __c2port_write_flash_data(c2dev, buffer, offset, count);\n\tmutex_unlock(&c2dev->mutex);\n\n\tif (ret < 0)\n\t\tdev_err(c2dev->dev, \"cannot write %s flash\\n\", c2dev->name);\n\n\treturn ret;\n}\n \nstatic BIN_ATTR(flash_data, 0644, c2port_read_flash_data,\n\t\tc2port_write_flash_data, 0);\n\n \nstatic struct attribute *c2port_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_flash_blocks_num.attr,\n\t&dev_attr_flash_block_size.attr,\n\t&dev_attr_flash_size.attr,\n\t&dev_attr_access.attr,\n\t&dev_attr_reset.attr,\n\t&dev_attr_dev_id.attr,\n\t&dev_attr_rev_id.attr,\n\t&dev_attr_flash_access.attr,\n\t&dev_attr_flash_erase.attr,\n\tNULL,\n};\n\nstatic struct bin_attribute *c2port_bin_attrs[] = {\n\t&bin_attr_flash_data,\n\tNULL,\n};\n\nstatic const struct attribute_group c2port_group = {\n\t.attrs = c2port_attrs,\n\t.bin_attrs = c2port_bin_attrs,\n};\n\nstatic const struct attribute_group *c2port_groups[] = {\n\t&c2port_group,\n\tNULL,\n};\n\n \n\nstruct c2port_device *c2port_device_register(char *name,\n\t\t\t\t\tstruct c2port_ops *ops, void *devdata)\n{\n\tstruct c2port_device *c2dev;\n\tint ret;\n\n\tif (unlikely(!ops) || unlikely(!ops->access) || \\\n\t\tunlikely(!ops->c2d_dir) || unlikely(!ops->c2ck_set) || \\\n\t\tunlikely(!ops->c2d_get) || unlikely(!ops->c2d_set))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tc2dev = kzalloc(sizeof(struct c2port_device), GFP_KERNEL);\n\tif (unlikely(!c2dev))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_irq(&c2port_idr_lock);\n\tret = idr_alloc(&c2port_idr, c2dev, 0, 0, GFP_NOWAIT);\n\tspin_unlock_irq(&c2port_idr_lock);\n\tidr_preload_end();\n\n\tif (ret < 0)\n\t\tgoto error_idr_alloc;\n\tc2dev->id = ret;\n\n\tbin_attr_flash_data.size = ops->blocks_num * ops->block_size;\n\n\tc2dev->dev = device_create(c2port_class, NULL, 0, c2dev,\n\t\t\t\t   \"c2port%d\", c2dev->id);\n\tif (IS_ERR(c2dev->dev)) {\n\t\tret = PTR_ERR(c2dev->dev);\n\t\tgoto error_device_create;\n\t}\n\tdev_set_drvdata(c2dev->dev, c2dev);\n\n\tstrncpy(c2dev->name, name, C2PORT_NAME_LEN - 1);\n\tc2dev->ops = ops;\n\tmutex_init(&c2dev->mutex);\n\n\t \n\tc2dev->access = c2dev->flash_access = 0;\n\tops->access(c2dev, 0);\n\n\tdev_info(c2dev->dev, \"C2 port %s added\\n\", name);\n\tdev_info(c2dev->dev, \"%s flash has %d blocks x %d bytes \"\n\t\t\t\t\"(%d bytes total)\\n\",\n\t\t\t\tname, ops->blocks_num, ops->block_size,\n\t\t\t\tops->blocks_num * ops->block_size);\n\n\treturn c2dev;\n\nerror_device_create:\n\tspin_lock_irq(&c2port_idr_lock);\n\tidr_remove(&c2port_idr, c2dev->id);\n\tspin_unlock_irq(&c2port_idr_lock);\n\nerror_idr_alloc:\n\tkfree(c2dev);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(c2port_device_register);\n\nvoid c2port_device_unregister(struct c2port_device *c2dev)\n{\n\tif (!c2dev)\n\t\treturn;\n\n\tdev_info(c2dev->dev, \"C2 port %s removed\\n\", c2dev->name);\n\n\tspin_lock_irq(&c2port_idr_lock);\n\tidr_remove(&c2port_idr, c2dev->id);\n\tspin_unlock_irq(&c2port_idr_lock);\n\n\tdevice_destroy(c2port_class, c2dev->id);\n\n\tkfree(c2dev);\n}\nEXPORT_SYMBOL(c2port_device_unregister);\n\n \n\nstatic int __init c2port_init(void)\n{\n\tprintk(KERN_INFO \"Silicon Labs C2 port support v. \" DRIVER_VERSION\n\t\t\" - (C) 2007 Rodolfo Giometti\\n\");\n\n\tc2port_class = class_create(\"c2port\");\n\tif (IS_ERR(c2port_class)) {\n\t\tprintk(KERN_ERR \"c2port: failed to allocate class\\n\");\n\t\treturn PTR_ERR(c2port_class);\n\t}\n\tc2port_class->dev_groups = c2port_groups;\n\n\treturn 0;\n}\n\nstatic void __exit c2port_exit(void)\n{\n\tclass_destroy(c2port_class);\n}\n\nmodule_init(c2port_init);\nmodule_exit(c2port_exit);\n\nMODULE_AUTHOR(\"Rodolfo Giometti <giometti@linux.it>\");\nMODULE_DESCRIPTION(\"Silicon Labs C2 port support v. \" DRIVER_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}