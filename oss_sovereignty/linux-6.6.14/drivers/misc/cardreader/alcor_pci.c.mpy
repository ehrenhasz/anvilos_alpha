{
  "module_name": "alcor_pci.c",
  "hash_id": "13d92ec930a79e77903d4ef3f724ad4e779c84c4b2d56dbb3a6c7848475f49cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cardreader/alcor_pci.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n\n#include <linux/alcor_pci.h>\n\n#define DRV_NAME_ALCOR_PCI\t\t\t\"alcor_pci\"\n\nstatic DEFINE_IDA(alcor_pci_idr);\n\nstatic struct mfd_cell alcor_pci_cells[] = {\n\t[ALCOR_SD_CARD] = {\n\t\t.name = DRV_NAME_ALCOR_PCI_SDMMC,\n\t},\n\t[ALCOR_MS_CARD] = {\n\t\t.name = DRV_NAME_ALCOR_PCI_MS,\n\t},\n};\n\nstatic const struct alcor_dev_cfg alcor_cfg = {\n\t.dma = 0,\n};\n\nstatic const struct alcor_dev_cfg au6621_cfg = {\n\t.dma = 1,\n};\n\nstatic const struct alcor_dev_cfg au6625_cfg = {\n\t.dma = 0,\n};\n\nstatic const struct pci_device_id pci_ids[] = {\n\t{ PCI_DEVICE(PCI_ID_ALCOR_MICRO, PCI_ID_AU6601),\n\t\t.driver_data = (kernel_ulong_t)&alcor_cfg },\n\t{ PCI_DEVICE(PCI_ID_ALCOR_MICRO, PCI_ID_AU6621),\n\t\t.driver_data = (kernel_ulong_t)&au6621_cfg },\n\t{ PCI_DEVICE(PCI_ID_ALCOR_MICRO, PCI_ID_AU6625),\n\t\t.driver_data = (kernel_ulong_t)&au6625_cfg },\n\t{},\n};\nMODULE_DEVICE_TABLE(pci, pci_ids);\n\nvoid alcor_write8(struct alcor_pci_priv *priv, u8 val, unsigned int addr)\n{\n\twriteb(val, priv->iobase + addr);\n}\nEXPORT_SYMBOL_GPL(alcor_write8);\n\nvoid alcor_write16(struct alcor_pci_priv *priv, u16 val, unsigned int addr)\n{\n\twritew(val, priv->iobase + addr);\n}\nEXPORT_SYMBOL_GPL(alcor_write16);\n\nvoid alcor_write32(struct alcor_pci_priv *priv, u32 val, unsigned int addr)\n{\n\twritel(val, priv->iobase + addr);\n}\nEXPORT_SYMBOL_GPL(alcor_write32);\n\nvoid alcor_write32be(struct alcor_pci_priv *priv, u32 val, unsigned int addr)\n{\n\tiowrite32be(val, priv->iobase + addr);\n}\nEXPORT_SYMBOL_GPL(alcor_write32be);\n\nu8 alcor_read8(struct alcor_pci_priv *priv, unsigned int addr)\n{\n\treturn readb(priv->iobase + addr);\n}\nEXPORT_SYMBOL_GPL(alcor_read8);\n\nu32 alcor_read32(struct alcor_pci_priv *priv, unsigned int addr)\n{\n\treturn readl(priv->iobase + addr);\n}\nEXPORT_SYMBOL_GPL(alcor_read32);\n\nu32 alcor_read32be(struct alcor_pci_priv *priv, unsigned int addr)\n{\n\treturn ioread32be(priv->iobase + addr);\n}\nEXPORT_SYMBOL_GPL(alcor_read32be);\n\nstatic int alcor_pci_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tstruct alcor_dev_cfg *cfg;\n\tstruct alcor_pci_priv *priv;\n\tint ret, i, bar = 0;\n\n\tcfg = (void *)ent->driver_data;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = ida_alloc(&alcor_pci_idr, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\tpriv->id = ret;\n\n\tpriv->pdev = pdev;\n\tpriv->parent_pdev = pdev->bus->self;\n\tpriv->dev = &pdev->dev;\n\tpriv->cfg = cfg;\n\tpriv->irq = pdev->irq;\n\n\tret = pci_request_regions(pdev, DRV_NAME_ALCOR_PCI);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot request region\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error_free_ida;\n\t}\n\n\tif (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {\n\t\tdev_err(&pdev->dev, \"BAR %d is not iomem. Aborting.\\n\", bar);\n\t\tret = -ENODEV;\n\t\tgoto error_release_regions;\n\t}\n\n\tpriv->iobase = pcim_iomap(pdev, bar, 0);\n\tif (!priv->iobase) {\n\t\tret = -ENOMEM;\n\t\tgoto error_release_regions;\n\t}\n\n\t \n\talcor_write32(priv, 0, AU6601_REG_INT_ENABLE);\n\talcor_write32(priv, 0, AU6601_MS_INT_ENABLE);\n\n\tret = dma_set_mask_and_coherent(priv->dev, AU6601_SDMA_MASK);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to set DMA mask\\n\");\n\t\tgoto error_release_regions;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, priv);\n\n\tfor (i = 0; i < ARRAY_SIZE(alcor_pci_cells); i++) {\n\t\talcor_pci_cells[i].platform_data = priv;\n\t\talcor_pci_cells[i].pdata_size = sizeof(*priv);\n\t}\n\tret = mfd_add_devices(&pdev->dev, priv->id, alcor_pci_cells,\n\t\t\tARRAY_SIZE(alcor_pci_cells), NULL, 0, NULL);\n\tif (ret < 0)\n\t\tgoto error_clear_drvdata;\n\n\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1);\n\n\treturn 0;\n\nerror_clear_drvdata:\n\tpci_clear_master(pdev);\n\tpci_set_drvdata(pdev, NULL);\nerror_release_regions:\n\tpci_release_regions(pdev);\nerror_free_ida:\n\tida_free(&alcor_pci_idr, priv->id);\n\treturn ret;\n}\n\nstatic void alcor_pci_remove(struct pci_dev *pdev)\n{\n\tstruct alcor_pci_priv *priv;\n\n\tpriv = pci_get_drvdata(pdev);\n\n\tmfd_remove_devices(&pdev->dev);\n\n\tida_free(&alcor_pci_idr, priv->id);\n\n\tpci_release_regions(pdev);\n\tpci_clear_master(pdev);\n\tpci_set_drvdata(pdev, NULL);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int alcor_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int alcor_resume(struct device *dev)\n{\n\tstruct alcor_pci_priv *priv = dev_get_drvdata(dev);\n\n\tpci_disable_link_state(priv->pdev,\n\t\t\t       PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1);\n\n\treturn 0;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(alcor_pci_pm_ops, alcor_suspend, alcor_resume);\n\nstatic struct pci_driver alcor_driver = {\n\t.name\t=\tDRV_NAME_ALCOR_PCI,\n\t.id_table =\tpci_ids,\n\t.probe\t=\talcor_pci_probe,\n\t.remove =\talcor_pci_remove,\n\t.driver\t=\t{\n\t\t.pm\t= &alcor_pci_pm_ops\n\t},\n};\n\nmodule_pci_driver(alcor_driver);\n\nMODULE_AUTHOR(\"Oleksij Rempel <linux@rempel-privat.de>\");\nMODULE_DESCRIPTION(\"PCI driver for Alcor Micro AU6601 Secure Digital Host Controller Interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}