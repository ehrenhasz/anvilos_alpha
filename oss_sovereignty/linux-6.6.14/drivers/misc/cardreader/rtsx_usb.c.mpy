{
  "module_name": "rtsx_usb.c",
  "hash_id": "6e2b51b36876c31eea97a0e40c7411fe377c17cfcf13918436cbf2650027e816",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cardreader/rtsx_usb.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/usb.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/core.h>\n#include <linux/rtsx_usb.h>\n\nstatic int polling_pipe = 1;\nmodule_param(polling_pipe, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(polling_pipe, \"polling pipe (0: ctl, 1: bulk)\");\n\nstatic const struct mfd_cell rtsx_usb_cells[] = {\n\t[RTSX_USB_SD_CARD] = {\n\t\t.name = \"rtsx_usb_sdmmc\",\n\t\t.pdata_size = 0,\n\t},\n\t[RTSX_USB_MS_CARD] = {\n\t\t.name = \"rtsx_usb_ms\",\n\t\t.pdata_size = 0,\n\t},\n};\n\nstatic void rtsx_usb_sg_timed_out(struct timer_list *t)\n{\n\tstruct rtsx_ucr *ucr = from_timer(ucr, t, sg_timer);\n\n\tdev_dbg(&ucr->pusb_intf->dev, \"%s: sg transfer timed out\", __func__);\n\tusb_sg_cancel(&ucr->current_sg);\n}\n\nstatic int rtsx_usb_bulk_transfer_sglist(struct rtsx_ucr *ucr,\n\t\tunsigned int pipe, struct scatterlist *sg, int num_sg,\n\t\tunsigned int length, unsigned int *act_len, int timeout)\n{\n\tint ret;\n\n\tdev_dbg(&ucr->pusb_intf->dev, \"%s: xfer %u bytes, %d entries\\n\",\n\t\t\t__func__, length, num_sg);\n\tret = usb_sg_init(&ucr->current_sg, ucr->pusb_dev, pipe, 0,\n\t\t\tsg, num_sg, length, GFP_NOIO);\n\tif (ret)\n\t\treturn ret;\n\n\tucr->sg_timer.expires = jiffies + msecs_to_jiffies(timeout);\n\tadd_timer(&ucr->sg_timer);\n\tusb_sg_wait(&ucr->current_sg);\n\tif (!del_timer_sync(&ucr->sg_timer))\n\t\tret = -ETIMEDOUT;\n\telse\n\t\tret = ucr->current_sg.status;\n\n\tif (act_len)\n\t\t*act_len = ucr->current_sg.bytes;\n\n\treturn ret;\n}\n\nint rtsx_usb_transfer_data(struct rtsx_ucr *ucr, unsigned int pipe,\n\t\t\t      void *buf, unsigned int len, int num_sg,\n\t\t\t      unsigned int *act_len, int timeout)\n{\n\tif (timeout < 600)\n\t\ttimeout = 600;\n\n\tif (num_sg)\n\t\treturn rtsx_usb_bulk_transfer_sglist(ucr, pipe,\n\t\t\t\t(struct scatterlist *)buf, num_sg, len, act_len,\n\t\t\t\ttimeout);\n\telse\n\t\treturn usb_bulk_msg(ucr->pusb_dev, pipe, buf, len, act_len,\n\t\t\t\ttimeout);\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_transfer_data);\n\nstatic inline void rtsx_usb_seq_cmd_hdr(struct rtsx_ucr *ucr,\n\t\tu16 addr, u16 len, u8 seq_type)\n{\n\trtsx_usb_cmd_hdr_tag(ucr);\n\n\tucr->cmd_buf[PACKET_TYPE] = seq_type;\n\tucr->cmd_buf[5] = (u8)(len >> 8);\n\tucr->cmd_buf[6] = (u8)len;\n\tucr->cmd_buf[8] = (u8)(addr >> 8);\n\tucr->cmd_buf[9] = (u8)addr;\n\n\tif (seq_type == SEQ_WRITE)\n\t\tucr->cmd_buf[STAGE_FLAG] = 0;\n\telse\n\t\tucr->cmd_buf[STAGE_FLAG] = STAGE_R;\n}\n\nstatic int rtsx_usb_seq_write_register(struct rtsx_ucr *ucr,\n\t\tu16 addr, u16 len, u8 *data)\n{\n\tu16 cmd_len = ALIGN(SEQ_WRITE_DATA_OFFSET + len, 4);\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tif (cmd_len > IOBUF_SIZE)\n\t\treturn -EINVAL;\n\n\trtsx_usb_seq_cmd_hdr(ucr, addr, len, SEQ_WRITE);\n\tmemcpy(ucr->cmd_buf + SEQ_WRITE_DATA_OFFSET, data, len);\n\n\treturn rtsx_usb_transfer_data(ucr,\n\t\t\tusb_sndbulkpipe(ucr->pusb_dev, EP_BULK_OUT),\n\t\t\tucr->cmd_buf, cmd_len, 0, NULL, 100);\n}\n\nstatic int rtsx_usb_seq_read_register(struct rtsx_ucr *ucr,\n\t\tu16 addr, u16 len, u8 *data)\n{\n\tint i, ret;\n\tu16 rsp_len = round_down(len, 4);\n\tu16 res_len = len - rsp_len;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\t \n\tif (rsp_len) {\n\t\trtsx_usb_seq_cmd_hdr(ucr, addr, len, SEQ_READ);\n\t\tret = rtsx_usb_transfer_data(ucr,\n\t\t\t\tusb_sndbulkpipe(ucr->pusb_dev, EP_BULK_OUT),\n\t\t\t\tucr->cmd_buf, 12, 0, NULL, 100);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = rtsx_usb_transfer_data(ucr,\n\t\t\t\tusb_rcvbulkpipe(ucr->pusb_dev, EP_BULK_IN),\n\t\t\t\tdata, rsp_len, 0, NULL, 100);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < res_len; i++) {\n\t\tret = rtsx_usb_read_register(ucr, addr + rsp_len + i,\n\t\t\t\tdata + rsp_len + i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint rtsx_usb_read_ppbuf(struct rtsx_ucr *ucr, u8 *buf, int buf_len)\n{\n\treturn rtsx_usb_seq_read_register(ucr, PPBUF_BASE2, (u16)buf_len, buf);\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_read_ppbuf);\n\nint rtsx_usb_write_ppbuf(struct rtsx_ucr *ucr, u8 *buf, int buf_len)\n{\n\treturn rtsx_usb_seq_write_register(ucr, PPBUF_BASE2, (u16)buf_len, buf);\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_write_ppbuf);\n\nint rtsx_usb_ep0_write_register(struct rtsx_ucr *ucr, u16 addr,\n\t\tu8 mask, u8 data)\n{\n\tu16 value, index;\n\n\taddr |= EP0_WRITE_REG_CMD << EP0_OP_SHIFT;\n\tvalue = swab16(addr);\n\tindex = mask | data << 8;\n\n\treturn usb_control_msg(ucr->pusb_dev,\n\t\t\tusb_sndctrlpipe(ucr->pusb_dev, 0), RTSX_USB_REQ_REG_OP,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, index, NULL, 0, 100);\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_ep0_write_register);\n\nint rtsx_usb_ep0_read_register(struct rtsx_ucr *ucr, u16 addr, u8 *data)\n{\n\tu16 value;\n\tu8 *buf;\n\tint ret;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tbuf = kzalloc(sizeof(u8), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\taddr |= EP0_READ_REG_CMD << EP0_OP_SHIFT;\n\tvalue = swab16(addr);\n\n\tret = usb_control_msg(ucr->pusb_dev,\n\t\t\tusb_rcvctrlpipe(ucr->pusb_dev, 0), RTSX_USB_REQ_REG_OP,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, 0, buf, 1, 100);\n\t*data = *buf;\n\n\tkfree(buf);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_ep0_read_register);\n\nvoid rtsx_usb_add_cmd(struct rtsx_ucr *ucr, u8 cmd_type, u16 reg_addr,\n\t\tu8 mask, u8 data)\n{\n\tint i;\n\n\tif (ucr->cmd_idx < (IOBUF_SIZE - CMD_OFFSET) / 4) {\n\t\ti = CMD_OFFSET + ucr->cmd_idx * 4;\n\n\t\tucr->cmd_buf[i++] = ((cmd_type & 0x03) << 6) |\n\t\t\t(u8)((reg_addr >> 8) & 0x3F);\n\t\tucr->cmd_buf[i++] = (u8)reg_addr;\n\t\tucr->cmd_buf[i++] = mask;\n\t\tucr->cmd_buf[i++] = data;\n\n\t\tucr->cmd_idx++;\n\t}\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_add_cmd);\n\nint rtsx_usb_send_cmd(struct rtsx_ucr *ucr, u8 flag, int timeout)\n{\n\tint ret;\n\n\tucr->cmd_buf[CNT_H] = (u8)(ucr->cmd_idx >> 8);\n\tucr->cmd_buf[CNT_L] = (u8)(ucr->cmd_idx);\n\tucr->cmd_buf[STAGE_FLAG] = flag;\n\n\tret = rtsx_usb_transfer_data(ucr,\n\t\t\tusb_sndbulkpipe(ucr->pusb_dev, EP_BULK_OUT),\n\t\t\tucr->cmd_buf, ucr->cmd_idx * 4 + CMD_OFFSET,\n\t\t\t0, NULL, timeout);\n\tif (ret) {\n\t\trtsx_usb_clear_fsm_err(ucr);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_send_cmd);\n\nint rtsx_usb_get_rsp(struct rtsx_ucr *ucr, int rsp_len, int timeout)\n{\n\tif (rsp_len <= 0)\n\t\treturn -EINVAL;\n\n\trsp_len = ALIGN(rsp_len, 4);\n\n\treturn rtsx_usb_transfer_data(ucr,\n\t\t\tusb_rcvbulkpipe(ucr->pusb_dev, EP_BULK_IN),\n\t\t\tucr->rsp_buf, rsp_len, 0, NULL, timeout);\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_get_rsp);\n\nstatic int rtsx_usb_get_status_with_bulk(struct rtsx_ucr *ucr, u16 *status)\n{\n\tint ret;\n\n\trtsx_usb_init_cmd(ucr);\n\trtsx_usb_add_cmd(ucr, READ_REG_CMD, CARD_EXIST, 0x00, 0x00);\n\trtsx_usb_add_cmd(ucr, READ_REG_CMD, OCPSTAT, 0x00, 0x00);\n\tret = rtsx_usb_send_cmd(ucr, MODE_CR, 100);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtsx_usb_get_rsp(ucr, 2, 100);\n\tif (ret)\n\t\treturn ret;\n\n\t*status = ((ucr->rsp_buf[0] >> 2) & 0x0f) |\n\t\t  ((ucr->rsp_buf[1] & 0x03) << 4);\n\n\treturn 0;\n}\n\nint rtsx_usb_get_card_status(struct rtsx_ucr *ucr, u16 *status)\n{\n\tint ret;\n\tu16 *buf;\n\n\tif (!status)\n\t\treturn -EINVAL;\n\n\tif (polling_pipe == 0) {\n\t\tbuf = kzalloc(sizeof(u16), GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tret = usb_control_msg(ucr->pusb_dev,\n\t\t\t\tusb_rcvctrlpipe(ucr->pusb_dev, 0),\n\t\t\t\tRTSX_USB_REQ_POLL,\n\t\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0, 0, buf, 2, 100);\n\t\t*status = *buf;\n\n\t\tkfree(buf);\n\t} else {\n\t\tret = rtsx_usb_get_status_with_bulk(ucr, status);\n\t}\n\n\t \n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_get_card_status);\n\nstatic int rtsx_usb_write_phy_register(struct rtsx_ucr *ucr, u8 addr, u8 val)\n{\n\tdev_dbg(&ucr->pusb_intf->dev, \"Write 0x%x to phy register 0x%x\\n\",\n\t\t\tval, addr);\n\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VSTAIN, 0xFF, val);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VCONTROL, 0xFF, addr & 0x0F);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x01);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VCONTROL,\n\t\t\t0xFF, (addr >> 4) & 0x0F);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x01);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nint rtsx_usb_write_register(struct rtsx_ucr *ucr, u16 addr, u8 mask, u8 data)\n{\n\trtsx_usb_init_cmd(ucr);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, addr, mask, data);\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_write_register);\n\nint rtsx_usb_read_register(struct rtsx_ucr *ucr, u16 addr, u8 *data)\n{\n\tint ret;\n\n\tif (data != NULL)\n\t\t*data = 0;\n\n\trtsx_usb_init_cmd(ucr);\n\trtsx_usb_add_cmd(ucr, READ_REG_CMD, addr, 0, 0);\n\tret = rtsx_usb_send_cmd(ucr, MODE_CR, 100);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtsx_usb_get_rsp(ucr, 1, 100);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data != NULL)\n\t\t*data = ucr->rsp_buf[0];\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_read_register);\n\nstatic inline u8 double_ssc_depth(u8 depth)\n{\n\treturn (depth > 1) ? (depth - 1) : depth;\n}\n\nstatic u8 revise_ssc_depth(u8 ssc_depth, u8 div)\n{\n\tif (div > CLK_DIV_1) {\n\t\tif (ssc_depth > div - 1)\n\t\t\tssc_depth -= (div - 1);\n\t\telse\n\t\t\tssc_depth = SSC_DEPTH_2M;\n\t}\n\n\treturn ssc_depth;\n}\n\nint rtsx_usb_switch_clock(struct rtsx_ucr *ucr, unsigned int card_clock,\n\t\tu8 ssc_depth, bool initial_mode, bool double_clk, bool vpclk)\n{\n\tint ret;\n\tu8 n, clk_divider, mcu_cnt, div;\n\n\tif (!card_clock) {\n\t\tucr->cur_clk = 0;\n\t\treturn 0;\n\t}\n\n\tif (initial_mode) {\n\t\t \n\t\tclk_divider = SD_CLK_DIVIDE_128;\n\t\tcard_clock = 30000000;\n\t} else {\n\t\tclk_divider = SD_CLK_DIVIDE_0;\n\t}\n\n\tret = rtsx_usb_write_register(ucr, SD_CFG1,\n\t\t\tSD_CLK_DIVIDE_MASK, clk_divider);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcard_clock /= 1000000;\n\tdev_dbg(&ucr->pusb_intf->dev,\n\t\t\t\"Switch card clock to %dMHz\\n\", card_clock);\n\n\tif (!initial_mode && double_clk)\n\t\tcard_clock *= 2;\n\tdev_dbg(&ucr->pusb_intf->dev,\n\t\t\t\"Internal SSC clock: %dMHz (cur_clk = %d)\\n\",\n\t\t\tcard_clock, ucr->cur_clk);\n\n\tif (card_clock == ucr->cur_clk)\n\t\treturn 0;\n\n\t \n\tn = card_clock - 2;\n\tif ((card_clock <= 2) || (n > MAX_DIV_N))\n\t\treturn -EINVAL;\n\n\tmcu_cnt = 60/card_clock + 3;\n\tif (mcu_cnt > 15)\n\t\tmcu_cnt = 15;\n\n\t \n\n\tdiv = CLK_DIV_1;\n\twhile (n < MIN_DIV_N && div < CLK_DIV_4) {\n\t\tn = (n + 2) * 2 - 2;\n\t\tdiv++;\n\t}\n\tdev_dbg(&ucr->pusb_intf->dev, \"n = %d, div = %d\\n\", n, div);\n\n\tif (double_clk)\n\t\tssc_depth = double_ssc_depth(ssc_depth);\n\n\tssc_depth = revise_ssc_depth(ssc_depth, div);\n\tdev_dbg(&ucr->pusb_intf->dev, \"ssc_depth = %d\\n\", ssc_depth);\n\n\trtsx_usb_init_cmd(ucr);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CLK_DIV, CLK_CHANGE, CLK_CHANGE);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CLK_DIV,\n\t\t\t0x3F, (div << 4) | mcu_cnt);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, 0);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SSC_CTL2,\n\t\t\tSSC_DEPTH_MASK, ssc_depth);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SSC_DIV_N_0, 0xFF, n);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, SSC_RSTB);\n\tif (vpclk) {\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK0_CTL,\n\t\t\t\tPHASE_NOT_RESET, 0);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK0_CTL,\n\t\t\t\tPHASE_NOT_RESET, PHASE_NOT_RESET);\n\t}\n\n\tret = rtsx_usb_send_cmd(ucr, MODE_C, 2000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rtsx_usb_write_register(ucr, SSC_CTL1, 0xff,\n\t\t\tSSC_RSTB | SSC_8X_EN | SSC_SEL_4M);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tusleep_range(100, 1000);\n\n\tret = rtsx_usb_write_register(ucr, CLK_DIV, CLK_CHANGE, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tucr->cur_clk = card_clock;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_switch_clock);\n\nint rtsx_usb_card_exclusive_check(struct rtsx_ucr *ucr, int card)\n{\n\tint ret;\n\tu16 val;\n\tu16 cd_mask[] = {\n\t\t[RTSX_USB_SD_CARD] = (CD_MASK & ~SD_CD),\n\t\t[RTSX_USB_MS_CARD] = (CD_MASK & ~MS_CD)\n\t};\n\n\tret = rtsx_usb_get_card_status(ucr, &val);\n\t \n\tif (ret)\n\t\treturn 0;\n\n\tif (val & cd_mask[card])\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_usb_card_exclusive_check);\n\nstatic int rtsx_usb_reset_chip(struct rtsx_ucr *ucr)\n{\n\tint ret;\n\tu8 val;\n\n\trtsx_usb_init_cmd(ucr);\n\n\tif (CHECK_PKG(ucr, LQFP48)) {\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\n\t\t\t\tLDO3318_PWR_MASK, LDO_SUSPEND);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\n\t\t\t\tFORCE_LDO_POWERB, FORCE_LDO_POWERB);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1,\n\t\t\t\t0x30, 0x10);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5,\n\t\t\t\t0x03, 0x01);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6,\n\t\t\t\t0x0C, 0x04);\n\t}\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SYS_DUMMY0, NYET_MSAK, NYET_EN);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CD_DEGLITCH_WIDTH, 0xFF, 0x08);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\tCD_DEGLITCH_EN, XD_CD_DEGLITCH_EN, 0x0);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD30_DRIVE_SEL,\n\t\t\tSD30_DRIVE_MASK, DRIVER_TYPE_D);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\tCARD_DRIVE_SEL, SD20_DRIVE_MASK, 0x0);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, LDO_POWER_CFG, 0xE0, 0x0);\n\n\tif (ucr->is_rts5179)\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tCARD_PULL_CTL5, 0x03, 0x01);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DMA1_CTL,\n\t\t       EXTEND_DMA1_ASYNC_SIGNAL, EXTEND_DMA1_ASYNC_SIGNAL);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_INT_PEND,\n\t\t\tXD_INT | MS_INT | SD_INT,\n\t\t\tXD_INT | MS_INT | SD_INT);\n\n\tret = rtsx_usb_send_cmd(ucr, MODE_C, 100);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trtsx_usb_read_register(ucr, CFG_MODE, &val);\n\tif ((val & XTAL_FREE) || ((val & CLK_MODE_MASK) == CLK_MODE_NON_XTAL)) {\n\t\tret = rtsx_usb_write_phy_register(ucr, 0xC2, 0x7C);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtsx_usb_init_chip(struct rtsx_ucr *ucr)\n{\n\tint ret;\n\tu8 val;\n\n\trtsx_usb_clear_fsm_err(ucr);\n\n\t \n\tret = rtsx_usb_write_register(ucr,\n\t\t\tFPDCTL, SSC_POWER_MASK, SSC_POWER_ON);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(100, 1000);\n\tret = rtsx_usb_write_register(ucr, CLK_DIV, CLK_CHANGE, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = rtsx_usb_read_register(ucr, HW_VERSION, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tucr->ic_version = val & HW_VER_MASK;\n\n\t \n\tret = rtsx_usb_read_register(ucr, CARD_SHARE_MODE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & CARD_SHARE_LQFP_SEL) {\n\t\tucr->package = LQFP48;\n\t\tdev_dbg(&ucr->pusb_intf->dev, \"Package: LQFP48\\n\");\n\t} else {\n\t\tucr->package = QFN24;\n\t\tdev_dbg(&ucr->pusb_intf->dev, \"Package: QFN24\\n\");\n\t}\n\n\t \n\trtsx_usb_read_register(ucr, CFG_MODE_1, &val);\n\tif (val & RTS5179) {\n\t\tucr->is_rts5179 = true;\n\t\tdev_dbg(&ucr->pusb_intf->dev, \"Device is rts5179\\n\");\n\t} else {\n\t\tucr->is_rts5179 = false;\n\t}\n\n\treturn rtsx_usb_reset_chip(ucr);\n}\n\nstatic int rtsx_usb_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct rtsx_ucr *ucr;\n\tint ret;\n\n\tdev_dbg(&intf->dev,\n\t\t\": Realtek USB Card Reader found at bus %03d address %03d\\n\",\n\t\t usb_dev->bus->busnum, usb_dev->devnum);\n\n\tucr = devm_kzalloc(&intf->dev, sizeof(*ucr), GFP_KERNEL);\n\tif (!ucr)\n\t\treturn -ENOMEM;\n\n\tucr->pusb_dev = usb_dev;\n\n\tucr->cmd_buf = kmalloc(IOBUF_SIZE, GFP_KERNEL);\n\tif (!ucr->cmd_buf)\n\t\treturn -ENOMEM;\n\n\tucr->rsp_buf = kmalloc(IOBUF_SIZE, GFP_KERNEL);\n\tif (!ucr->rsp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_cmd_buf;\n\t}\n\n\tusb_set_intfdata(intf, ucr);\n\n\tucr->vendor_id = id->idVendor;\n\tucr->product_id = id->idProduct;\n\n\tmutex_init(&ucr->dev_mutex);\n\n\tucr->pusb_intf = intf;\n\n\t \n\tret = rtsx_usb_init_chip(ucr);\n\tif (ret)\n\t\tgoto out_init_fail;\n\n\t \n\ttimer_setup(&ucr->sg_timer, rtsx_usb_sg_timed_out, 0);\n\n\tret = mfd_add_hotplug_devices(&intf->dev, rtsx_usb_cells,\n\t\t\t\t      ARRAY_SIZE(rtsx_usb_cells));\n\tif (ret)\n\t\tgoto out_init_fail;\n\n#ifdef CONFIG_PM\n\tintf->needs_remote_wakeup = 1;\n\tusb_enable_autosuspend(usb_dev);\n#endif\n\n\treturn 0;\n\nout_init_fail:\n\tusb_set_intfdata(ucr->pusb_intf, NULL);\n\tkfree(ucr->rsp_buf);\n\tucr->rsp_buf = NULL;\nout_free_cmd_buf:\n\tkfree(ucr->cmd_buf);\n\tucr->cmd_buf = NULL;\n\treturn ret;\n}\n\nstatic void rtsx_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct rtsx_ucr *ucr = (struct rtsx_ucr *)usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s called\\n\", __func__);\n\n\tmfd_remove_devices(&intf->dev);\n\n\tusb_set_intfdata(ucr->pusb_intf, NULL);\n\n\tkfree(ucr->cmd_buf);\n\tucr->cmd_buf = NULL;\n\n\tkfree(ucr->rsp_buf);\n\tucr->rsp_buf = NULL;\n}\n\n#ifdef CONFIG_PM\nstatic int rtsx_usb_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct rtsx_ucr *ucr =\n\t\t(struct rtsx_ucr *)usb_get_intfdata(intf);\n\tu16 val = 0;\n\n\tdev_dbg(&intf->dev, \"%s called with pm message 0x%04x\\n\",\n\t\t\t__func__, message.event);\n\n\tif (PMSG_IS_AUTO(message)) {\n\t\tif (mutex_trylock(&ucr->dev_mutex)) {\n\t\t\trtsx_usb_get_card_status(ucr, &val);\n\t\t\tmutex_unlock(&ucr->dev_mutex);\n\n\t\t\t \n\t\t\tif (val & (SD_CD | MS_CD))\n\t\t\t\treturn -EAGAIN;\n\t\t} else {\n\t\t\t \n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtsx_usb_resume_child(struct device *dev, void *data)\n{\n\tpm_request_resume(dev);\n\treturn 0;\n}\n\nstatic int rtsx_usb_resume(struct usb_interface *intf)\n{\n\tdevice_for_each_child(&intf->dev, NULL, rtsx_usb_resume_child);\n\treturn 0;\n}\n\nstatic int rtsx_usb_reset_resume(struct usb_interface *intf)\n{\n\tstruct rtsx_ucr *ucr =\n\t\t(struct rtsx_ucr *)usb_get_intfdata(intf);\n\n\trtsx_usb_reset_chip(ucr);\n\tdevice_for_each_child(&intf->dev, NULL, rtsx_usb_resume_child);\n\treturn 0;\n}\n\n#else  \n\n#define rtsx_usb_suspend NULL\n#define rtsx_usb_resume NULL\n#define rtsx_usb_reset_resume NULL\n\n#endif  \n\n\nstatic int rtsx_usb_pre_reset(struct usb_interface *intf)\n{\n\tstruct rtsx_ucr *ucr = (struct rtsx_ucr *)usb_get_intfdata(intf);\n\n\tmutex_lock(&ucr->dev_mutex);\n\treturn 0;\n}\n\nstatic int rtsx_usb_post_reset(struct usb_interface *intf)\n{\n\tstruct rtsx_ucr *ucr = (struct rtsx_ucr *)usb_get_intfdata(intf);\n\n\tmutex_unlock(&ucr->dev_mutex);\n\treturn 0;\n}\n\nstatic const struct usb_device_id rtsx_usb_usb_ids[] = {\n\t{ USB_DEVICE(0x0BDA, 0x0129) },\n\t{ USB_DEVICE(0x0BDA, 0x0139) },\n\t{ USB_DEVICE(0x0BDA, 0x0140) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, rtsx_usb_usb_ids);\n\nstatic struct usb_driver rtsx_usb_driver = {\n\t.name\t\t\t= \"rtsx_usb\",\n\t.probe\t\t\t= rtsx_usb_probe,\n\t.disconnect\t\t= rtsx_usb_disconnect,\n\t.suspend\t\t= rtsx_usb_suspend,\n\t.resume\t\t\t= rtsx_usb_resume,\n\t.reset_resume\t\t= rtsx_usb_reset_resume,\n\t.pre_reset\t\t= rtsx_usb_pre_reset,\n\t.post_reset\t\t= rtsx_usb_post_reset,\n\t.id_table\t\t= rtsx_usb_usb_ids,\n\t.supports_autosuspend\t= 1,\n\t.soft_unbind\t\t= 1,\n};\n\nmodule_usb_driver(rtsx_usb_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Roger Tseng <rogerable@realtek.com>\");\nMODULE_DESCRIPTION(\"Realtek USB Card Reader Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}