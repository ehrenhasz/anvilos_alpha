{
  "module_name": "rts5261.c",
  "hash_id": "c4ea05aa90ee3435e042b9d824a20d3ae503e54bf7102d25b4c67ec21802552a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cardreader/rts5261.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/rtsx_pci.h>\n\n#include \"rts5261.h\"\n#include \"rtsx_pcr.h\"\n\nstatic u8 rts5261_get_ic_version(struct rtsx_pcr *pcr)\n{\n\tu8 val;\n\n\trtsx_pci_read_register(pcr, DUMMY_REG_RESET_0, &val);\n\treturn val & IC_VERSION_MASK;\n}\n\nstatic void rts5261_fill_driving(struct rtsx_pcr *pcr, u8 voltage)\n{\n\tu8 driving_3v3[4][3] = {\n\t\t{0x96, 0x96, 0x96},\n\t\t{0x96, 0x96, 0x96},\n\t\t{0x7F, 0x7F, 0x7F},\n\t\t{0x13, 0x13, 0x13},\n\t};\n\tu8 driving_1v8[4][3] = {\n\t\t{0xB3, 0xB3, 0xB3},\n\t\t{0x3A, 0x3A, 0x3A},\n\t\t{0xE6, 0xE6, 0xE6},\n\t\t{0x99, 0x99, 0x99},\n\t};\n\tu8 (*driving)[3], drive_sel;\n\n\tif (voltage == OUTPUT_3V3) {\n\t\tdriving = driving_3v3;\n\t\tdrive_sel = pcr->sd30_drive_sel_3v3;\n\t} else {\n\t\tdriving = driving_1v8;\n\t\tdrive_sel = pcr->sd30_drive_sel_1v8;\n\t}\n\n\trtsx_pci_write_register(pcr, SD30_CLK_DRIVE_SEL,\n\t\t\t 0xFF, driving[drive_sel][0]);\n\n\trtsx_pci_write_register(pcr, SD30_CMD_DRIVE_SEL,\n\t\t\t 0xFF, driving[drive_sel][1]);\n\n\trtsx_pci_write_register(pcr, SD30_DAT_DRIVE_SEL,\n\t\t\t 0xFF, driving[drive_sel][2]);\n}\n\nstatic void rts5261_force_power_down(struct rtsx_pcr *pcr, u8 pm_state, bool runtime)\n{\n\t \n\trtsx_pci_write_register(pcr, AUTOLOAD_CFG_BASE + 1, MASK_8_BIT_DEF, 0);\n\trtsx_pci_write_register(pcr, AUTOLOAD_CFG_BASE + 2, MASK_8_BIT_DEF, 0);\n\trtsx_pci_write_register(pcr, AUTOLOAD_CFG_BASE + 3,\n\t\t\t\tRELINK_TIME_MASK, 0);\n\n\tif (pm_state == HOST_ENTER_S3)\n\t\trtsx_pci_write_register(pcr, pcr->reg_pm_ctrl3,\n\t\t\t\t\tD3_DELINK_MODE_EN, D3_DELINK_MODE_EN);\n\n\tif (!runtime) {\n\t\trtsx_pci_write_register(pcr, RTS5261_AUTOLOAD_CFG1,\n\t\t\t\tCD_RESUME_EN_MASK, 0);\n\t\trtsx_pci_write_register(pcr, pcr->reg_pm_ctrl3, 0x01, 0x00);\n\t\trtsx_pci_write_register(pcr, RTS5261_REG_PME_FORCE_CTL,\n\t\t\t\tFORCE_PM_CONTROL | FORCE_PM_VALUE, FORCE_PM_CONTROL);\n\n\t} else {\n\t\trtsx_pci_write_register(pcr, RTS5261_REG_PME_FORCE_CTL,\n\t\t\t\tFORCE_PM_CONTROL | FORCE_PM_VALUE, 0);\n\n\t\trtsx_pci_write_register(pcr, RTS5261_FW_CTL,\n\t\t\t\tRTS5261_INFORM_RTD3_COLD, RTS5261_INFORM_RTD3_COLD);\n\t\trtsx_pci_write_register(pcr, RTS5261_AUTOLOAD_CFG4,\n\t\t\t\tRTS5261_FORCE_PRSNT_LOW, RTS5261_FORCE_PRSNT_LOW);\n\n\t}\n\n\trtsx_pci_write_register(pcr, RTS5261_REG_FPDCTL,\n\t\tSSC_POWER_DOWN, SSC_POWER_DOWN);\n}\n\nstatic int rts5261_enable_auto_blink(struct rtsx_pcr *pcr)\n{\n\treturn rtsx_pci_write_register(pcr, OLT_LED_CTL,\n\t\tLED_SHINE_MASK, LED_SHINE_EN);\n}\n\nstatic int rts5261_disable_auto_blink(struct rtsx_pcr *pcr)\n{\n\treturn rtsx_pci_write_register(pcr, OLT_LED_CTL,\n\t\tLED_SHINE_MASK, LED_SHINE_DISABLE);\n}\n\nstatic int rts5261_turn_on_led(struct rtsx_pcr *pcr)\n{\n\treturn rtsx_pci_write_register(pcr, GPIO_CTL,\n\t\t0x02, 0x02);\n}\n\nstatic int rts5261_turn_off_led(struct rtsx_pcr *pcr)\n{\n\treturn rtsx_pci_write_register(pcr, GPIO_CTL,\n\t\t0x02, 0x00);\n}\n\n \nstatic const u32 rts5261_sd_pull_ctl_enable_tbl[] = {\n\tRTSX_REG_PAIR(CARD_PULL_CTL2, 0xAA),\n\tRTSX_REG_PAIR(CARD_PULL_CTL3, 0xE9),\n\t0,\n};\n\n \nstatic const u32 rts5261_sd_pull_ctl_disable_tbl[] = {\n\tRTSX_REG_PAIR(CARD_PULL_CTL2, 0x55),\n\tRTSX_REG_PAIR(CARD_PULL_CTL3, 0xD5),\n\t0,\n};\n\nstatic int rts5261_sd_set_sample_push_timing_sd30(struct rtsx_pcr *pcr)\n{\n\trtsx_pci_write_register(pcr, SD_CFG1, SD_MODE_SELECT_MASK\n\t\t| SD_ASYNC_FIFO_NOT_RST, SD_30_MODE | SD_ASYNC_FIFO_NOT_RST);\n\trtsx_pci_write_register(pcr, CLK_CTL, CLK_LOW_FREQ, CLK_LOW_FREQ);\n\trtsx_pci_write_register(pcr, CARD_CLK_SOURCE, 0xFF,\n\t\t\tCRC_VAR_CLK0 | SD30_FIX_CLK | SAMPLE_VAR_CLK1);\n\trtsx_pci_write_register(pcr, CLK_CTL, CLK_LOW_FREQ, 0);\n\n\treturn 0;\n}\n\nstatic int rts5261_card_power_on(struct rtsx_pcr *pcr, int card)\n{\n\tstruct rtsx_cr_option *option = &pcr->option;\n\n\tif (option->ocp_en)\n\t\trtsx_pci_enable_ocp(pcr);\n\n\trtsx_pci_write_register(pcr, REG_CRC_DUMMY_0,\n\t\tCFG_SD_POW_AUTO_PD, CFG_SD_POW_AUTO_PD);\n\n\trtsx_pci_write_register(pcr, RTS5261_LDO1_CFG1,\n\t\t\tRTS5261_LDO1_TUNE_MASK, RTS5261_LDO1_33);\n\trtsx_pci_write_register(pcr, RTS5261_LDO1233318_POW_CTL,\n\t\t\tRTS5261_LDO1_POWERON, RTS5261_LDO1_POWERON);\n\n\trtsx_pci_write_register(pcr, RTS5261_LDO1233318_POW_CTL,\n\t\t\tRTS5261_LDO3318_POWERON, RTS5261_LDO3318_POWERON);\n\n\tmsleep(20);\n\n\trtsx_pci_write_register(pcr, CARD_OE, SD_OUTPUT_EN, SD_OUTPUT_EN);\n\n\t \n\trtsx_pci_write_register(pcr, SD_CFG1, 0xFF,\n\t\t\tSD_CLK_DIVIDE_128 | SD_20_MODE | SD_BUS_WIDTH_1BIT);\n\n\trtsx_pci_write_register(pcr, SD_SAMPLE_POINT_CTL,\n\t\t\t0xFF, SD20_RX_POS_EDGE);\n\trtsx_pci_write_register(pcr, SD_PUSH_POINT_CTL, 0xFF, 0);\n\trtsx_pci_write_register(pcr, CARD_STOP, SD_STOP | SD_CLR_ERR,\n\t\t\tSD_STOP | SD_CLR_ERR);\n\n\t \n\trtsx_pci_write_register(pcr, SD_CFG3, SD30_CLK_END_EN, 0);\n\trtsx_pci_write_register(pcr, REG_SD_STOP_SDCLK_CFG,\n\t\t\tSD30_CLK_STOP_CFG_EN | SD30_CLK_STOP_CFG1 |\n\t\t\tSD30_CLK_STOP_CFG0, 0);\n\n\tif (pcr->extra_caps & EXTRA_CAPS_SD_SDR50 ||\n\t    pcr->extra_caps & EXTRA_CAPS_SD_SDR104)\n\t\trts5261_sd_set_sample_push_timing_sd30(pcr);\n\n\treturn 0;\n}\n\nstatic int rts5261_switch_output_voltage(struct rtsx_pcr *pcr, u8 voltage)\n{\n\tint err;\n\tu16 val = 0;\n\n\trtsx_pci_write_register(pcr, RTS5261_CARD_PWR_CTL,\n\t\t\tRTS5261_PUPDC, RTS5261_PUPDC);\n\n\tswitch (voltage) {\n\tcase OUTPUT_3V3:\n\t\trtsx_pci_read_phy_register(pcr, PHY_TUNE, &val);\n\t\tval |= PHY_TUNE_SDBUS_33;\n\t\terr = rtsx_pci_write_phy_register(pcr, PHY_TUNE, val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\trtsx_pci_write_register(pcr, RTS5261_DV3318_CFG,\n\t\t\t\tRTS5261_DV3318_TUNE_MASK, RTS5261_DV3318_33);\n\t\trtsx_pci_write_register(pcr, SD_PAD_CTL,\n\t\t\t\tSD_IO_USING_1V8, 0);\n\t\tbreak;\n\tcase OUTPUT_1V8:\n\t\trtsx_pci_read_phy_register(pcr, PHY_TUNE, &val);\n\t\tval &= ~PHY_TUNE_SDBUS_33;\n\t\terr = rtsx_pci_write_phy_register(pcr, PHY_TUNE, val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\trtsx_pci_write_register(pcr, RTS5261_DV3318_CFG,\n\t\t\t\tRTS5261_DV3318_TUNE_MASK, RTS5261_DV3318_18);\n\t\trtsx_pci_write_register(pcr, SD_PAD_CTL,\n\t\t\t\tSD_IO_USING_1V8, SD_IO_USING_1V8);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trts5261_fill_driving(pcr, voltage);\n\n\treturn 0;\n}\n\nstatic void rts5261_stop_cmd(struct rtsx_pcr *pcr)\n{\n\trtsx_pci_writel(pcr, RTSX_HCBCTLR, STOP_CMD);\n\trtsx_pci_writel(pcr, RTSX_HDBCTLR, STOP_DMA);\n\trtsx_pci_write_register(pcr, RTS5260_DMA_RST_CTL_0,\n\t\t\t\tRTS5260_DMA_RST | RTS5260_ADMA3_RST,\n\t\t\t\tRTS5260_DMA_RST | RTS5260_ADMA3_RST);\n\trtsx_pci_write_register(pcr, RBCTL, RB_FLUSH, RB_FLUSH);\n}\n\nstatic void rts5261_card_before_power_off(struct rtsx_pcr *pcr)\n{\n\trts5261_stop_cmd(pcr);\n\trts5261_switch_output_voltage(pcr, OUTPUT_3V3);\n\n}\n\nstatic void rts5261_enable_ocp(struct rtsx_pcr *pcr)\n{\n\tu8 val = 0;\n\n\tval = SD_OCP_INT_EN | SD_DETECT_EN;\n\trtsx_pci_write_register(pcr, RTS5261_LDO1_CFG0,\n\t\t\tRTS5261_LDO1_OCP_EN | RTS5261_LDO1_OCP_LMT_EN,\n\t\t\tRTS5261_LDO1_OCP_EN | RTS5261_LDO1_OCP_LMT_EN);\n\trtsx_pci_write_register(pcr, REG_OCPCTL, 0xFF, val);\n\n}\n\nstatic void rts5261_disable_ocp(struct rtsx_pcr *pcr)\n{\n\tu8 mask = 0;\n\n\tmask = SD_OCP_INT_EN | SD_DETECT_EN;\n\trtsx_pci_write_register(pcr, REG_OCPCTL, mask, 0);\n\trtsx_pci_write_register(pcr, RTS5261_LDO1_CFG0,\n\t\t\tRTS5261_LDO1_OCP_EN | RTS5261_LDO1_OCP_LMT_EN, 0);\n\n}\n\nstatic int rts5261_card_power_off(struct rtsx_pcr *pcr, int card)\n{\n\tint err = 0;\n\n\trts5261_card_before_power_off(pcr);\n\terr = rtsx_pci_write_register(pcr, RTS5261_LDO1233318_POW_CTL,\n\t\t\t\tRTS5261_LDO_POWERON_MASK, 0);\n\n\trtsx_pci_write_register(pcr, REG_CRC_DUMMY_0,\n\t\tCFG_SD_POW_AUTO_PD, 0);\n\tif (pcr->option.ocp_en)\n\t\trtsx_pci_disable_ocp(pcr);\n\n\treturn err;\n}\n\nstatic void rts5261_init_ocp(struct rtsx_pcr *pcr)\n{\n\tstruct rtsx_cr_option *option = &pcr->option;\n\n\tif (option->ocp_en) {\n\t\tu8 mask, val;\n\n\t\trtsx_pci_write_register(pcr, RTS5261_LDO1_CFG0,\n\t\t\tRTS5261_LDO1_OCP_EN | RTS5261_LDO1_OCP_LMT_EN,\n\t\t\tRTS5261_LDO1_OCP_EN | RTS5261_LDO1_OCP_LMT_EN);\n\n\t\trtsx_pci_write_register(pcr, RTS5261_LDO1_CFG0,\n\t\t\tRTS5261_LDO1_OCP_THD_MASK, option->sd_800mA_ocp_thd);\n\n\t\trtsx_pci_write_register(pcr, RTS5261_LDO1_CFG0,\n\t\t\tRTS5261_LDO1_OCP_LMT_THD_MASK,\n\t\t\tRTS5261_LDO1_LMT_THD_2000);\n\n\t\tmask = SD_OCP_GLITCH_MASK;\n\t\tval = pcr->hw_param.ocp_glitch;\n\t\trtsx_pci_write_register(pcr, REG_OCPGLITCH, mask, val);\n\n\t\trts5261_enable_ocp(pcr);\n\t} else {\n\t\trtsx_pci_write_register(pcr, RTS5261_LDO1_CFG0,\n\t\t\tRTS5261_LDO1_OCP_EN | RTS5261_LDO1_OCP_LMT_EN, 0);\n\t}\n}\n\nstatic void rts5261_clear_ocpstat(struct rtsx_pcr *pcr)\n{\n\tu8 mask = 0;\n\tu8 val = 0;\n\n\tmask = SD_OCP_INT_CLR | SD_OC_CLR;\n\tval = SD_OCP_INT_CLR | SD_OC_CLR;\n\n\trtsx_pci_write_register(pcr, REG_OCPCTL, mask, val);\n\n\tudelay(1000);\n\trtsx_pci_write_register(pcr, REG_OCPCTL, mask, 0);\n\n}\n\nstatic void rts5261_process_ocp(struct rtsx_pcr *pcr)\n{\n\tif (!pcr->option.ocp_en)\n\t\treturn;\n\n\trtsx_pci_get_ocpstat(pcr, &pcr->ocp_stat);\n\n\tif (pcr->ocp_stat & (SD_OC_NOW | SD_OC_EVER)) {\n\t\trts5261_clear_ocpstat(pcr);\n\t\trts5261_card_power_off(pcr, RTSX_SD_CARD);\n\t\trtsx_pci_write_register(pcr, CARD_OE, SD_OUTPUT_EN, 0);\n\t\tpcr->ocp_stat = 0;\n\t}\n\n}\n\nstatic void rts5261_init_from_hw(struct rtsx_pcr *pcr)\n{\n\tstruct pci_dev *pdev = pcr->pci;\n\tu32 lval1, lval2, i;\n\tu16 setting_reg1, setting_reg2;\n\tu8 valid, efuse_valid, tmp;\n\n\trtsx_pci_write_register(pcr, RTS5261_REG_PME_FORCE_CTL,\n\t\tREG_EFUSE_POR | REG_EFUSE_POWER_MASK,\n\t\tREG_EFUSE_POR | REG_EFUSE_POWERON);\n\tudelay(1);\n\trtsx_pci_write_register(pcr, RTS5261_EFUSE_ADDR,\n\t\tRTS5261_EFUSE_ADDR_MASK, 0x00);\n\trtsx_pci_write_register(pcr, RTS5261_EFUSE_CTL,\n\t\tRTS5261_EFUSE_ENABLE | RTS5261_EFUSE_MODE_MASK,\n\t\tRTS5261_EFUSE_ENABLE);\n\n\t \n\tfor (i = 0; i < MAX_RW_REG_CNT; i++) {\n\t\trtsx_pci_read_register(pcr, RTS5261_EFUSE_CTL, &tmp);\n\t\tif ((tmp & 0x80) == 0)\n\t\t\tbreak;\n\t}\n\trtsx_pci_read_register(pcr, RTS5261_EFUSE_READ_DATA, &tmp);\n\tefuse_valid = ((tmp & 0x0C) >> 2);\n\tpcr_dbg(pcr, \"Load efuse valid: 0x%x\\n\", efuse_valid);\n\n\tpci_read_config_dword(pdev, PCR_SETTING_REG2, &lval2);\n\tpcr_dbg(pcr, \"Cfg 0x%x: 0x%x\\n\", PCR_SETTING_REG2, lval2);\n\t \n\tvalid = (u8)((lval2 >> 16) & 0x03);\n\n\trtsx_pci_write_register(pcr, RTS5261_REG_PME_FORCE_CTL,\n\t\tREG_EFUSE_POR, 0);\n\tpcr_dbg(pcr, \"Disable efuse por!\\n\");\n\n\tif (efuse_valid == 2 || efuse_valid == 3) {\n\t\tif (valid == 3) {\n\t\t\t \n\t\t\tsetting_reg1 = PCR_SETTING_REG1;\n\t\t\tsetting_reg2 = PCR_SETTING_REG2;\n\t\t} else {\n\t\t\t \n\t\t\tsetting_reg1 = PCR_SETTING_REG4;\n\t\t\tsetting_reg2 = PCR_SETTING_REG5;\n\t\t}\n\t} else if (efuse_valid == 0) {\n\t\t\n\t\tsetting_reg1 = PCR_SETTING_REG1;\n\t\tsetting_reg2 = PCR_SETTING_REG2;\n\t} else {\n\t\treturn;\n\t}\n\n\tpci_read_config_dword(pdev, setting_reg2, &lval2);\n\tpcr_dbg(pcr, \"Cfg 0x%x: 0x%x\\n\", setting_reg2, lval2);\n\n\tif (!rts5261_vendor_setting_valid(lval2)) {\n\t\t \n\t\tpcr->extra_caps |= EXTRA_CAPS_NO_MMC;\n\t\tpcr_dbg(pcr, \"skip fetch vendor setting\\n\");\n\t\treturn;\n\t}\n\n\tif (!rts5261_reg_check_mmc_support(lval2))\n\t\tpcr->extra_caps |= EXTRA_CAPS_NO_MMC;\n\n\tpcr->rtd3_en = rts5261_reg_to_rtd3(lval2);\n\n\tif (rts5261_reg_check_reverse_socket(lval2))\n\t\tpcr->flags |= PCR_REVERSE_SOCKET;\n\n\tpci_read_config_dword(pdev, setting_reg1, &lval1);\n\tpcr_dbg(pcr, \"Cfg 0x%x: 0x%x\\n\", setting_reg1, lval1);\n\n\tpcr->aspm_en = rts5261_reg_to_aspm(lval1);\n\tpcr->sd30_drive_sel_1v8 = rts5261_reg_to_sd30_drive_sel_1v8(lval1);\n\tpcr->sd30_drive_sel_3v3 = rts5261_reg_to_sd30_drive_sel_3v3(lval1);\n\n\tif (setting_reg1 == PCR_SETTING_REG1) {\n\t\t \n\t\trtsx_pci_write_register(pcr, 0xFF0C, 0xFF, (u8)(lval1 & 0xFF));\n\t\trtsx_pci_write_register(pcr, 0xFF0D, 0xFF, (u8)((lval1 >> 8) & 0xFF));\n\t\trtsx_pci_write_register(pcr, 0xFF0E, 0xFF, (u8)((lval1 >> 16) & 0xFF));\n\t\trtsx_pci_write_register(pcr, 0xFF0F, 0xFF, (u8)((lval1 >> 24) & 0xFF));\n\t\trtsx_pci_write_register(pcr, 0xFF10, 0xFF, (u8)(lval2 & 0xFF));\n\t\trtsx_pci_write_register(pcr, 0xFF11, 0xFF, (u8)((lval2 >> 8) & 0xFF));\n\t\trtsx_pci_write_register(pcr, 0xFF12, 0xFF, (u8)((lval2 >> 16) & 0xFF));\n\n\t\tpci_write_config_dword(pdev, PCR_SETTING_REG4, lval1);\n\t\tlval2 = lval2 & 0x00FFFFFF;\n\t\tpci_write_config_dword(pdev, PCR_SETTING_REG5, lval2);\n\t}\n}\n\nstatic void rts5261_init_from_cfg(struct rtsx_pcr *pcr)\n{\n\tstruct rtsx_cr_option *option = &pcr->option;\n\n\tif (option->ltr_en) {\n\t\tif (option->ltr_enabled)\n\t\t\trtsx_set_ltr_latency(pcr, option->ltr_active_latency);\n\t}\n}\n\nstatic int rts5261_extra_init_hw(struct rtsx_pcr *pcr)\n{\n\tstruct rtsx_cr_option *option = &pcr->option;\n\tu32 val;\n\n\trtsx_pci_write_register(pcr, RTS5261_AUTOLOAD_CFG1,\n\t\t\tCD_RESUME_EN_MASK, CD_RESUME_EN_MASK);\n\n\trts5261_init_from_cfg(pcr);\n\trts5261_init_from_hw(pcr);\n\n\t \n\trtsx_pci_write_register(pcr, RTS5261_REG_PME_FORCE_CTL,\n\t\t\tREG_EFUSE_POWER_MASK, REG_EFUSE_POWEROFF);\n\trtsx_pci_write_register(pcr, L1SUB_CONFIG1,\n\t\t\tAUX_CLK_ACTIVE_SEL_MASK, MAC_CKSW_DONE);\n\trtsx_pci_write_register(pcr, L1SUB_CONFIG3, 0xFF, 0);\n\n\tif (is_version_higher_than(pcr, PID_5261, IC_VER_B)) {\n\t\tval = rtsx_pci_readl(pcr, RTSX_DUM_REG);\n\t\trtsx_pci_writel(pcr, RTSX_DUM_REG, val | 0x1);\n\t}\n\trtsx_pci_write_register(pcr, RTS5261_AUTOLOAD_CFG4,\n\t\t\tRTS5261_AUX_CLK_16M_EN, 0);\n\n\t \n\trtsx_pci_write_register(pcr, RTS5261_AUTOLOAD_CFG4,\n\t\t\tRTS5261_FORCE_PRSNT_LOW, 0);\n\trtsx_pci_write_register(pcr, FUNC_FORCE_CTL,\n\t\t\tFUNC_FORCE_UPME_XMT_DBG, FUNC_FORCE_UPME_XMT_DBG);\n\n\trtsx_pci_write_register(pcr, PCLK_CTL,\n\t\t\tPCLK_MODE_SEL, PCLK_MODE_SEL);\n\n\trtsx_pci_write_register(pcr, PM_EVENT_DEBUG, PME_DEBUG_0, PME_DEBUG_0);\n\trtsx_pci_write_register(pcr, PM_CLK_FORCE_CTL, CLK_PM_EN, CLK_PM_EN);\n\n\t \n\trtsx_pci_write_register(pcr, OLT_LED_CTL, 0x0F, 0x02);\n\n\t \n\trts5261_fill_driving(pcr, OUTPUT_3V3);\n\n\tif (pcr->flags & PCR_REVERSE_SOCKET)\n\t\trtsx_pci_write_register(pcr, PETXCFG, 0x30, 0x30);\n\telse\n\t\trtsx_pci_write_register(pcr, PETXCFG, 0x30, 0x00);\n\n\t \n\tif (option->force_clkreq_0)\n\t\trtsx_pci_write_register(pcr, PETXCFG,\n\t\t\t\t FORCE_CLKREQ_DELINK_MASK, FORCE_CLKREQ_LOW);\n\telse\n\t\trtsx_pci_write_register(pcr, PETXCFG,\n\t\t\t\t FORCE_CLKREQ_DELINK_MASK, FORCE_CLKREQ_HIGH);\n\n\trtsx_pci_write_register(pcr, PWD_SUSPEND_EN, 0xFF, 0xFB);\n\n\tif (pcr->rtd3_en) {\n\t\trtsx_pci_write_register(pcr, pcr->reg_pm_ctrl3, 0x01, 0x01);\n\t\trtsx_pci_write_register(pcr, RTS5261_REG_PME_FORCE_CTL,\n\t\t\t\tFORCE_PM_CONTROL | FORCE_PM_VALUE,\n\t\t\t\tFORCE_PM_CONTROL | FORCE_PM_VALUE);\n\t} else {\n\t\trtsx_pci_write_register(pcr, pcr->reg_pm_ctrl3, 0x01, 0x00);\n\t\trtsx_pci_write_register(pcr, RTS5261_REG_PME_FORCE_CTL,\n\t\t\t\tFORCE_PM_CONTROL | FORCE_PM_VALUE, FORCE_PM_CONTROL);\n\t}\n\trtsx_pci_write_register(pcr, pcr->reg_pm_ctrl3, D3_DELINK_MODE_EN, 0x00);\n\n\t \n\trtsx_pci_write_register(pcr, RTS5261_FW_CTL,\n\t\tRTS5261_INFORM_RTD3_COLD, 0);\n\n\treturn 0;\n}\n\nstatic void rts5261_enable_aspm(struct rtsx_pcr *pcr, bool enable)\n{\n\tu8 val = FORCE_ASPM_CTL0 | FORCE_ASPM_CTL1;\n\tu8 mask = FORCE_ASPM_VAL_MASK | FORCE_ASPM_CTL0 | FORCE_ASPM_CTL1;\n\n\tif (pcr->aspm_enabled == enable)\n\t\treturn;\n\n\tval |= (pcr->aspm_en & 0x02);\n\trtsx_pci_write_register(pcr, ASPM_FORCE_CTL, mask, val);\n\tpcie_capability_clear_and_set_word(pcr->pci, PCI_EXP_LNKCTL,\n\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC, pcr->aspm_en);\n\tpcr->aspm_enabled = enable;\n}\n\nstatic void rts5261_disable_aspm(struct rtsx_pcr *pcr, bool enable)\n{\n\tu8 val = FORCE_ASPM_CTL0 | FORCE_ASPM_CTL1;\n\tu8 mask = FORCE_ASPM_VAL_MASK | FORCE_ASPM_CTL0 | FORCE_ASPM_CTL1;\n\n\tif (pcr->aspm_enabled == enable)\n\t\treturn;\n\n\tpcie_capability_clear_and_set_word(pcr->pci, PCI_EXP_LNKCTL,\n\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC, 0);\n\trtsx_pci_write_register(pcr, ASPM_FORCE_CTL, mask, val);\n\trtsx_pci_write_register(pcr, SD_CFG1, SD_ASYNC_FIFO_NOT_RST, 0);\n\tudelay(10);\n\tpcr->aspm_enabled = enable;\n}\n\nstatic void rts5261_set_aspm(struct rtsx_pcr *pcr, bool enable)\n{\n\tif (enable)\n\t\trts5261_enable_aspm(pcr, true);\n\telse\n\t\trts5261_disable_aspm(pcr, false);\n}\n\nstatic void rts5261_set_l1off_cfg_sub_d0(struct rtsx_pcr *pcr, int active)\n{\n\tstruct rtsx_cr_option *option = &pcr->option;\n\tint aspm_L1_1, aspm_L1_2;\n\tu8 val = 0;\n\n\taspm_L1_1 = rtsx_check_dev_flag(pcr, ASPM_L1_1_EN);\n\taspm_L1_2 = rtsx_check_dev_flag(pcr, ASPM_L1_2_EN);\n\n\tif (active) {\n\t\t \n\t\tif (aspm_L1_1)\n\t\t\tval = option->ltr_l1off_snooze_sspwrgate;\n\t} else {\n\t\t \n\t\tif (aspm_L1_2)\n\t\t\tval = option->ltr_l1off_sspwrgate;\n\t}\n\n\trtsx_set_l1off_sub(pcr, val);\n}\n\nstatic const struct pcr_ops rts5261_pcr_ops = {\n\t.turn_on_led = rts5261_turn_on_led,\n\t.turn_off_led = rts5261_turn_off_led,\n\t.extra_init_hw = rts5261_extra_init_hw,\n\t.enable_auto_blink = rts5261_enable_auto_blink,\n\t.disable_auto_blink = rts5261_disable_auto_blink,\n\t.card_power_on = rts5261_card_power_on,\n\t.card_power_off = rts5261_card_power_off,\n\t.switch_output_voltage = rts5261_switch_output_voltage,\n\t.force_power_down = rts5261_force_power_down,\n\t.stop_cmd = rts5261_stop_cmd,\n\t.set_aspm = rts5261_set_aspm,\n\t.set_l1off_cfg_sub_d0 = rts5261_set_l1off_cfg_sub_d0,\n\t.enable_ocp = rts5261_enable_ocp,\n\t.disable_ocp = rts5261_disable_ocp,\n\t.init_ocp = rts5261_init_ocp,\n\t.process_ocp = rts5261_process_ocp,\n\t.clear_ocpstat = rts5261_clear_ocpstat,\n};\n\nstatic inline u8 double_ssc_depth(u8 depth)\n{\n\treturn ((depth > 1) ? (depth - 1) : depth);\n}\n\nint rts5261_pci_switch_clock(struct rtsx_pcr *pcr, unsigned int card_clock,\n\t\tu8 ssc_depth, bool initial_mode, bool double_clk, bool vpclk)\n{\n\tint err, clk;\n\tu16 n;\n\tu8 clk_divider, mcu_cnt, div;\n\tstatic const u8 depth[] = {\n\t\t[RTSX_SSC_DEPTH_4M] = RTS5261_SSC_DEPTH_4M,\n\t\t[RTSX_SSC_DEPTH_2M] = RTS5261_SSC_DEPTH_2M,\n\t\t[RTSX_SSC_DEPTH_1M] = RTS5261_SSC_DEPTH_1M,\n\t\t[RTSX_SSC_DEPTH_500K] = RTS5261_SSC_DEPTH_512K,\n\t};\n\n\tif (initial_mode) {\n\t\t \n\t\tif (is_version_higher_than(pcr, PID_5261, IC_VER_C)) {\n\t\t\tclk_divider = SD_CLK_DIVIDE_256;\n\t\t\tcard_clock = 60000000;\n\t\t} else {\n\t\t\tclk_divider = SD_CLK_DIVIDE_128;\n\t\t\tcard_clock = 30000000;\n\t\t}\n\t} else {\n\t\tclk_divider = SD_CLK_DIVIDE_0;\n\t}\n\terr = rtsx_pci_write_register(pcr, SD_CFG1,\n\t\t\tSD_CLK_DIVIDE_MASK, clk_divider);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard_clock /= 1000000;\n\tpcr_dbg(pcr, \"Switch card clock to %dMHz\\n\", card_clock);\n\n\tclk = card_clock;\n\tif (!initial_mode && double_clk)\n\t\tclk = card_clock * 2;\n\tpcr_dbg(pcr, \"Internal SSC clock: %dMHz (cur_clock = %d)\\n\",\n\t\tclk, pcr->cur_clock);\n\n\tif (clk == pcr->cur_clock)\n\t\treturn 0;\n\n\tif (pcr->ops->conv_clk_and_div_n)\n\t\tn = pcr->ops->conv_clk_and_div_n(clk, CLK_TO_DIV_N);\n\telse\n\t\tn = clk - 4;\n\tif ((clk <= 4) || (n > 396))\n\t\treturn -EINVAL;\n\n\tmcu_cnt = 125/clk + 3;\n\tif (mcu_cnt > 15)\n\t\tmcu_cnt = 15;\n\n\tdiv = CLK_DIV_1;\n\twhile ((n < MIN_DIV_N_PCR - 4) && (div < CLK_DIV_8)) {\n\t\tif (pcr->ops->conv_clk_and_div_n) {\n\t\t\tint dbl_clk = pcr->ops->conv_clk_and_div_n(n,\n\t\t\t\t\tDIV_N_TO_CLK) * 2;\n\t\t\tn = pcr->ops->conv_clk_and_div_n(dbl_clk,\n\t\t\t\t\tCLK_TO_DIV_N);\n\t\t} else {\n\t\t\tn = (n + 4) * 2 - 4;\n\t\t}\n\t\tdiv++;\n\t}\n\n\tn = (n / 2) - 1;\n\tpcr_dbg(pcr, \"n = %d, div = %d\\n\", n, div);\n\n\tssc_depth = depth[ssc_depth];\n\tif (double_clk)\n\t\tssc_depth = double_ssc_depth(ssc_depth);\n\n\tif (ssc_depth) {\n\t\tif (div == CLK_DIV_2) {\n\t\t\tif (ssc_depth > 1)\n\t\t\t\tssc_depth -= 1;\n\t\t\telse\n\t\t\t\tssc_depth = RTS5261_SSC_DEPTH_8M;\n\t\t} else if (div == CLK_DIV_4) {\n\t\t\tif (ssc_depth > 2)\n\t\t\t\tssc_depth -= 2;\n\t\t\telse\n\t\t\t\tssc_depth = RTS5261_SSC_DEPTH_8M;\n\t\t} else if (div == CLK_DIV_8) {\n\t\t\tif (ssc_depth > 3)\n\t\t\t\tssc_depth -= 3;\n\t\t\telse\n\t\t\t\tssc_depth = RTS5261_SSC_DEPTH_8M;\n\t\t}\n\t} else {\n\t\tssc_depth = 0;\n\t}\n\tpcr_dbg(pcr, \"ssc_depth = %d\\n\", ssc_depth);\n\n\trtsx_pci_init_cmd(pcr);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_CTL,\n\t\t\t\tCLK_LOW_FREQ, CLK_LOW_FREQ);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_DIV,\n\t\t\t0xFF, (div << 4) | mcu_cnt);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, 0);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL2,\n\t\t\tSSC_DEPTH_MASK, ssc_depth);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_DIV_N_0, 0xFF, n);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, SSC_RSTB);\n\tif (vpclk) {\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_VPCLK0_CTL,\n\t\t\t\tPHASE_NOT_RESET, 0);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_VPCLK1_CTL,\n\t\t\t\tPHASE_NOT_RESET, 0);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_VPCLK0_CTL,\n\t\t\t\tPHASE_NOT_RESET, PHASE_NOT_RESET);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_VPCLK1_CTL,\n\t\t\t\tPHASE_NOT_RESET, PHASE_NOT_RESET);\n\t}\n\n\terr = rtsx_pci_send_cmd(pcr, 2000);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tudelay(SSC_CLOCK_STABLE_WAIT);\n\terr = rtsx_pci_write_register(pcr, CLK_CTL, CLK_LOW_FREQ, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcr->cur_clock = clk;\n\treturn 0;\n\n}\n\nvoid rts5261_init_params(struct rtsx_pcr *pcr)\n{\n\tstruct rtsx_cr_option *option = &pcr->option;\n\tstruct rtsx_hw_param *hw_param = &pcr->hw_param;\n\tu8 val;\n\n\tpcr->extra_caps = EXTRA_CAPS_SD_SDR50 | EXTRA_CAPS_SD_SDR104;\n\trtsx_pci_read_register(pcr, RTS5261_FW_STATUS, &val);\n\tif (!(val & RTS5261_EXPRESS_LINK_FAIL_MASK))\n\t\tpcr->extra_caps |= EXTRA_CAPS_SD_EXPRESS;\n\tpcr->num_slots = 1;\n\tpcr->ops = &rts5261_pcr_ops;\n\n\tpcr->flags = 0;\n\tpcr->card_drive_sel = RTSX_CARD_DRIVE_DEFAULT;\n\tpcr->sd30_drive_sel_1v8 = 0x00;\n\tpcr->sd30_drive_sel_3v3 = 0x00;\n\tpcr->aspm_en = ASPM_L1_EN;\n\tpcr->aspm_mode = ASPM_MODE_REG;\n\tpcr->tx_initial_phase = SET_CLOCK_PHASE(27, 27, 11);\n\tpcr->rx_initial_phase = SET_CLOCK_PHASE(24, 6, 5);\n\n\tpcr->ic_version = rts5261_get_ic_version(pcr);\n\tpcr->sd_pull_ctl_enable_tbl = rts5261_sd_pull_ctl_enable_tbl;\n\tpcr->sd_pull_ctl_disable_tbl = rts5261_sd_pull_ctl_disable_tbl;\n\n\tpcr->reg_pm_ctrl3 = RTS5261_AUTOLOAD_CFG3;\n\n\toption->dev_flags = (LTR_L1SS_PWR_GATE_CHECK_CARD_EN\n\t\t\t\t| LTR_L1SS_PWR_GATE_EN);\n\toption->ltr_en = true;\n\n\t \n\toption->ltr_active_latency = LTR_ACTIVE_LATENCY_DEF;\n\toption->ltr_idle_latency = LTR_IDLE_LATENCY_DEF;\n\toption->ltr_l1off_latency = LTR_L1OFF_LATENCY_DEF;\n\toption->l1_snooze_delay = L1_SNOOZE_DELAY_DEF;\n\toption->ltr_l1off_sspwrgate = 0x7F;\n\toption->ltr_l1off_snooze_sspwrgate = 0x78;\n\n\toption->ocp_en = 1;\n\thw_param->interrupt_en |= SD_OC_INT_EN;\n\thw_param->ocp_glitch =  SD_OCP_GLITCH_800U;\n\toption->sd_800mA_ocp_thd =  RTS5261_LDO1_OCP_THD_1040;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}