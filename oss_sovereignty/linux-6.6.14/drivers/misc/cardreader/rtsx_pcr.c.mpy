{
  "module_name": "rtsx_pcr.c",
  "hash_id": "9365b808da05ba1448d319014060e52b806c1f239f0e367e93e7b3ad816ebed0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cardreader/rtsx_pcr.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/highmem.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/idr.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/core.h>\n#include <linux/rtsx_pci.h>\n#include <linux/mmc/card.h>\n#include <asm/unaligned.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n\n#include \"rtsx_pcr.h\"\n#include \"rts5261.h\"\n#include \"rts5228.h\"\n\nstatic bool msi_en = true;\nmodule_param(msi_en, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(msi_en, \"Enable MSI\");\n\nstatic DEFINE_IDR(rtsx_pci_idr);\nstatic DEFINE_SPINLOCK(rtsx_pci_lock);\n\nstatic struct mfd_cell rtsx_pcr_cells[] = {\n\t[RTSX_SD_CARD] = {\n\t\t.name = DRV_NAME_RTSX_PCI_SDMMC,\n\t},\n};\n\nstatic const struct pci_device_id rtsx_pci_ids[] = {\n\t{ PCI_DEVICE(0x10EC, 0x5209), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x5229), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x5289), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x5227), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x522A), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x5249), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x5287), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x5286), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x524A), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x525A), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x5260), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x5261), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(0x10EC, 0x5228), PCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, rtsx_pci_ids);\n\nstatic int rtsx_comm_set_ltr_latency(struct rtsx_pcr *pcr, u32 latency)\n{\n\trtsx_pci_write_register(pcr, MSGTXDATA0,\n\t\t\t\tMASK_8_BIT_DEF, (u8) (latency & 0xFF));\n\trtsx_pci_write_register(pcr, MSGTXDATA1,\n\t\t\t\tMASK_8_BIT_DEF, (u8)((latency >> 8) & 0xFF));\n\trtsx_pci_write_register(pcr, MSGTXDATA2,\n\t\t\t\tMASK_8_BIT_DEF, (u8)((latency >> 16) & 0xFF));\n\trtsx_pci_write_register(pcr, MSGTXDATA3,\n\t\t\t\tMASK_8_BIT_DEF, (u8)((latency >> 24) & 0xFF));\n\trtsx_pci_write_register(pcr, LTR_CTL, LTR_TX_EN_MASK |\n\t\tLTR_LATENCY_MODE_MASK, LTR_TX_EN_1 | LTR_LATENCY_MODE_SW);\n\n\treturn 0;\n}\n\nint rtsx_set_ltr_latency(struct rtsx_pcr *pcr, u32 latency)\n{\n\treturn rtsx_comm_set_ltr_latency(pcr, latency);\n}\n\nstatic void rtsx_comm_set_aspm(struct rtsx_pcr *pcr, bool enable)\n{\n\tif (pcr->aspm_enabled == enable)\n\t\treturn;\n\n\tif (pcr->aspm_mode == ASPM_MODE_CFG) {\n\t\tpcie_capability_clear_and_set_word(pcr->pci, PCI_EXP_LNKCTL,\n\t\t\t\t\t\tPCI_EXP_LNKCTL_ASPMC,\n\t\t\t\t\t\tenable ? pcr->aspm_en : 0);\n\t} else if (pcr->aspm_mode == ASPM_MODE_REG) {\n\t\tif (pcr->aspm_en & 0x02)\n\t\t\trtsx_pci_write_register(pcr, ASPM_FORCE_CTL, FORCE_ASPM_CTL0 |\n\t\t\t\tFORCE_ASPM_CTL1, enable ? 0 : FORCE_ASPM_CTL0 | FORCE_ASPM_CTL1);\n\t\telse\n\t\t\trtsx_pci_write_register(pcr, ASPM_FORCE_CTL, FORCE_ASPM_CTL0 |\n\t\t\t\tFORCE_ASPM_CTL1, FORCE_ASPM_CTL0 | FORCE_ASPM_CTL1);\n\t}\n\n\tif (!enable && (pcr->aspm_en & 0x02))\n\t\tmdelay(10);\n\n\tpcr->aspm_enabled = enable;\n}\n\nstatic void rtsx_disable_aspm(struct rtsx_pcr *pcr)\n{\n\tif (pcr->ops->set_aspm)\n\t\tpcr->ops->set_aspm(pcr, false);\n\telse\n\t\trtsx_comm_set_aspm(pcr, false);\n}\n\nint rtsx_set_l1off_sub(struct rtsx_pcr *pcr, u8 val)\n{\n\trtsx_pci_write_register(pcr, L1SUB_CONFIG3, 0xFF, val);\n\n\treturn 0;\n}\n\nstatic void rtsx_set_l1off_sub_cfg_d0(struct rtsx_pcr *pcr, int active)\n{\n\tif (pcr->ops->set_l1off_cfg_sub_d0)\n\t\tpcr->ops->set_l1off_cfg_sub_d0(pcr, active);\n}\n\nstatic void rtsx_comm_pm_full_on(struct rtsx_pcr *pcr)\n{\n\tstruct rtsx_cr_option *option = &pcr->option;\n\n\trtsx_disable_aspm(pcr);\n\n\t \n\tmsleep(1);\n\n\tif (option->ltr_enabled)\n\t\trtsx_set_ltr_latency(pcr, option->ltr_active_latency);\n\n\tif (rtsx_check_dev_flag(pcr, LTR_L1SS_PWR_GATE_EN))\n\t\trtsx_set_l1off_sub_cfg_d0(pcr, 1);\n}\n\nstatic void rtsx_pm_full_on(struct rtsx_pcr *pcr)\n{\n\trtsx_comm_pm_full_on(pcr);\n}\n\nvoid rtsx_pci_start_run(struct rtsx_pcr *pcr)\n{\n\t \n\tif (pcr->remove_pci)\n\t\treturn;\n\n\tif (pcr->state != PDEV_STAT_RUN) {\n\t\tpcr->state = PDEV_STAT_RUN;\n\t\tif (pcr->ops->enable_auto_blink)\n\t\t\tpcr->ops->enable_auto_blink(pcr);\n\t\trtsx_pm_full_on(pcr);\n\t}\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_start_run);\n\nint rtsx_pci_write_register(struct rtsx_pcr *pcr, u16 addr, u8 mask, u8 data)\n{\n\tint i;\n\tu32 val = HAIMR_WRITE_START;\n\n\tval |= (u32)(addr & 0x3FFF) << 16;\n\tval |= (u32)mask << 8;\n\tval |= (u32)data;\n\n\trtsx_pci_writel(pcr, RTSX_HAIMR, val);\n\n\tfor (i = 0; i < MAX_RW_REG_CNT; i++) {\n\t\tval = rtsx_pci_readl(pcr, RTSX_HAIMR);\n\t\tif ((val & HAIMR_TRANS_END) == 0) {\n\t\t\tif (data != (u8)val)\n\t\t\t\treturn -EIO;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ETIMEDOUT;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_write_register);\n\nint rtsx_pci_read_register(struct rtsx_pcr *pcr, u16 addr, u8 *data)\n{\n\tu32 val = HAIMR_READ_START;\n\tint i;\n\n\tval |= (u32)(addr & 0x3FFF) << 16;\n\trtsx_pci_writel(pcr, RTSX_HAIMR, val);\n\n\tfor (i = 0; i < MAX_RW_REG_CNT; i++) {\n\t\tval = rtsx_pci_readl(pcr, RTSX_HAIMR);\n\t\tif ((val & HAIMR_TRANS_END) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i >= MAX_RW_REG_CNT)\n\t\treturn -ETIMEDOUT;\n\n\tif (data)\n\t\t*data = (u8)(val & 0xFF);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_read_register);\n\nint __rtsx_pci_write_phy_register(struct rtsx_pcr *pcr, u8 addr, u16 val)\n{\n\tint err, i, finished = 0;\n\tu8 tmp;\n\n\trtsx_pci_write_register(pcr, PHYDATA0, 0xFF, (u8)val);\n\trtsx_pci_write_register(pcr, PHYDATA1, 0xFF, (u8)(val >> 8));\n\trtsx_pci_write_register(pcr, PHYADDR, 0xFF, addr);\n\trtsx_pci_write_register(pcr, PHYRWCTL, 0xFF, 0x81);\n\n\tfor (i = 0; i < 100000; i++) {\n\t\terr = rtsx_pci_read_register(pcr, PHYRWCTL, &tmp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!(tmp & 0x80)) {\n\t\t\tfinished = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!finished)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nint rtsx_pci_write_phy_register(struct rtsx_pcr *pcr, u8 addr, u16 val)\n{\n\tif (pcr->ops->write_phy)\n\t\treturn pcr->ops->write_phy(pcr, addr, val);\n\n\treturn __rtsx_pci_write_phy_register(pcr, addr, val);\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_write_phy_register);\n\nint __rtsx_pci_read_phy_register(struct rtsx_pcr *pcr, u8 addr, u16 *val)\n{\n\tint err, i, finished = 0;\n\tu16 data;\n\tu8 tmp, val1, val2;\n\n\trtsx_pci_write_register(pcr, PHYADDR, 0xFF, addr);\n\trtsx_pci_write_register(pcr, PHYRWCTL, 0xFF, 0x80);\n\n\tfor (i = 0; i < 100000; i++) {\n\t\terr = rtsx_pci_read_register(pcr, PHYRWCTL, &tmp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!(tmp & 0x80)) {\n\t\t\tfinished = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!finished)\n\t\treturn -ETIMEDOUT;\n\n\trtsx_pci_read_register(pcr, PHYDATA0, &val1);\n\trtsx_pci_read_register(pcr, PHYDATA1, &val2);\n\tdata = val1 | (val2 << 8);\n\n\tif (val)\n\t\t*val = data;\n\n\treturn 0;\n}\n\nint rtsx_pci_read_phy_register(struct rtsx_pcr *pcr, u8 addr, u16 *val)\n{\n\tif (pcr->ops->read_phy)\n\t\treturn pcr->ops->read_phy(pcr, addr, val);\n\n\treturn __rtsx_pci_read_phy_register(pcr, addr, val);\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_read_phy_register);\n\nvoid rtsx_pci_stop_cmd(struct rtsx_pcr *pcr)\n{\n\tif (pcr->ops->stop_cmd)\n\t\treturn pcr->ops->stop_cmd(pcr);\n\n\trtsx_pci_writel(pcr, RTSX_HCBCTLR, STOP_CMD);\n\trtsx_pci_writel(pcr, RTSX_HDBCTLR, STOP_DMA);\n\n\trtsx_pci_write_register(pcr, DMACTL, 0x80, 0x80);\n\trtsx_pci_write_register(pcr, RBCTL, 0x80, 0x80);\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_stop_cmd);\n\nvoid rtsx_pci_add_cmd(struct rtsx_pcr *pcr,\n\t\tu8 cmd_type, u16 reg_addr, u8 mask, u8 data)\n{\n\tunsigned long flags;\n\tu32 val = 0;\n\tu32 *ptr = (u32 *)(pcr->host_cmds_ptr);\n\n\tval |= (u32)(cmd_type & 0x03) << 30;\n\tval |= (u32)(reg_addr & 0x3FFF) << 16;\n\tval |= (u32)mask << 8;\n\tval |= (u32)data;\n\n\tspin_lock_irqsave(&pcr->lock, flags);\n\tptr += pcr->ci;\n\tif (pcr->ci < (HOST_CMDS_BUF_LEN / 4)) {\n\t\tput_unaligned_le32(val, ptr);\n\t\tptr++;\n\t\tpcr->ci++;\n\t}\n\tspin_unlock_irqrestore(&pcr->lock, flags);\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_add_cmd);\n\nvoid rtsx_pci_send_cmd_no_wait(struct rtsx_pcr *pcr)\n{\n\tu32 val = 1 << 31;\n\n\trtsx_pci_writel(pcr, RTSX_HCBAR, pcr->host_cmds_addr);\n\n\tval |= (u32)(pcr->ci * 4) & 0x00FFFFFF;\n\t \n\tval |= 0x40000000;\n\trtsx_pci_writel(pcr, RTSX_HCBCTLR, val);\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_send_cmd_no_wait);\n\nint rtsx_pci_send_cmd(struct rtsx_pcr *pcr, int timeout)\n{\n\tstruct completion trans_done;\n\tu32 val = 1 << 31;\n\tlong timeleft;\n\tunsigned long flags;\n\tint err = 0;\n\n\tspin_lock_irqsave(&pcr->lock, flags);\n\n\t \n\tpcr->done = &trans_done;\n\tpcr->trans_result = TRANS_NOT_READY;\n\tinit_completion(&trans_done);\n\n\trtsx_pci_writel(pcr, RTSX_HCBAR, pcr->host_cmds_addr);\n\n\tval |= (u32)(pcr->ci * 4) & 0x00FFFFFF;\n\t \n\tval |= 0x40000000;\n\trtsx_pci_writel(pcr, RTSX_HCBCTLR, val);\n\n\tspin_unlock_irqrestore(&pcr->lock, flags);\n\n\t \n\ttimeleft = wait_for_completion_interruptible_timeout(\n\t\t\t&trans_done, msecs_to_jiffies(timeout));\n\tif (timeleft <= 0) {\n\t\tpcr_dbg(pcr, \"Timeout (%s %d)\\n\", __func__, __LINE__);\n\t\terr = -ETIMEDOUT;\n\t\tgoto finish_send_cmd;\n\t}\n\n\tspin_lock_irqsave(&pcr->lock, flags);\n\tif (pcr->trans_result == TRANS_RESULT_FAIL)\n\t\terr = -EINVAL;\n\telse if (pcr->trans_result == TRANS_RESULT_OK)\n\t\terr = 0;\n\telse if (pcr->trans_result == TRANS_NO_DEVICE)\n\t\terr = -ENODEV;\n\tspin_unlock_irqrestore(&pcr->lock, flags);\n\nfinish_send_cmd:\n\tspin_lock_irqsave(&pcr->lock, flags);\n\tpcr->done = NULL;\n\tspin_unlock_irqrestore(&pcr->lock, flags);\n\n\tif ((err < 0) && (err != -ENODEV))\n\t\trtsx_pci_stop_cmd(pcr);\n\n\tif (pcr->finish_me)\n\t\tcomplete(pcr->finish_me);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_send_cmd);\n\nstatic void rtsx_pci_add_sg_tbl(struct rtsx_pcr *pcr,\n\t\tdma_addr_t addr, unsigned int len, int end)\n{\n\tu64 *ptr = (u64 *)(pcr->host_sg_tbl_ptr) + pcr->sgi;\n\tu64 val;\n\tu8 option = RTSX_SG_VALID | RTSX_SG_TRANS_DATA;\n\n\tpcr_dbg(pcr, \"DMA addr: 0x%x, Len: 0x%x\\n\", (unsigned int)addr, len);\n\n\tif (end)\n\t\toption |= RTSX_SG_END;\n\n\tif ((PCI_PID(pcr) == PID_5261) || (PCI_PID(pcr) == PID_5228)) {\n\t\tif (len > 0xFFFF)\n\t\t\tval = ((u64)addr << 32) | (((u64)len & 0xFFFF) << 16)\n\t\t\t\t| (((u64)len >> 16) << 6) | option;\n\t\telse\n\t\t\tval = ((u64)addr << 32) | ((u64)len << 16) | option;\n\t} else {\n\t\tval = ((u64)addr << 32) | ((u64)len << 12) | option;\n\t}\n\tput_unaligned_le64(val, ptr);\n\tpcr->sgi++;\n}\n\nint rtsx_pci_transfer_data(struct rtsx_pcr *pcr, struct scatterlist *sglist,\n\t\tint num_sg, bool read, int timeout)\n{\n\tint err = 0, count;\n\n\tpcr_dbg(pcr, \"--> %s: num_sg = %d\\n\", __func__, num_sg);\n\tcount = rtsx_pci_dma_map_sg(pcr, sglist, num_sg, read);\n\tif (count < 1)\n\t\treturn -EINVAL;\n\tpcr_dbg(pcr, \"DMA mapping count: %d\\n\", count);\n\n\terr = rtsx_pci_dma_transfer(pcr, sglist, count, read, timeout);\n\n\trtsx_pci_dma_unmap_sg(pcr, sglist, num_sg, read);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_transfer_data);\n\nint rtsx_pci_dma_map_sg(struct rtsx_pcr *pcr, struct scatterlist *sglist,\n\t\tint num_sg, bool read)\n{\n\tenum dma_data_direction dir = read ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\n\tif (pcr->remove_pci)\n\t\treturn -EINVAL;\n\n\tif ((sglist == NULL) || (num_sg <= 0))\n\t\treturn -EINVAL;\n\n\treturn dma_map_sg(&(pcr->pci->dev), sglist, num_sg, dir);\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_dma_map_sg);\n\nvoid rtsx_pci_dma_unmap_sg(struct rtsx_pcr *pcr, struct scatterlist *sglist,\n\t\tint num_sg, bool read)\n{\n\tenum dma_data_direction dir = read ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\n\tdma_unmap_sg(&(pcr->pci->dev), sglist, num_sg, dir);\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_dma_unmap_sg);\n\nint rtsx_pci_dma_transfer(struct rtsx_pcr *pcr, struct scatterlist *sglist,\n\t\tint count, bool read, int timeout)\n{\n\tstruct completion trans_done;\n\tstruct scatterlist *sg;\n\tdma_addr_t addr;\n\tlong timeleft;\n\tunsigned long flags;\n\tunsigned int len;\n\tint i, err = 0;\n\tu32 val;\n\tu8 dir = read ? DEVICE_TO_HOST : HOST_TO_DEVICE;\n\n\tif (pcr->remove_pci)\n\t\treturn -ENODEV;\n\n\tif ((sglist == NULL) || (count < 1))\n\t\treturn -EINVAL;\n\n\tval = ((u32)(dir & 0x01) << 29) | TRIG_DMA | ADMA_MODE;\n\tpcr->sgi = 0;\n\tfor_each_sg(sglist, sg, count, i) {\n\t\taddr = sg_dma_address(sg);\n\t\tlen = sg_dma_len(sg);\n\t\trtsx_pci_add_sg_tbl(pcr, addr, len, i == count - 1);\n\t}\n\n\tspin_lock_irqsave(&pcr->lock, flags);\n\n\tpcr->done = &trans_done;\n\tpcr->trans_result = TRANS_NOT_READY;\n\tinit_completion(&trans_done);\n\trtsx_pci_writel(pcr, RTSX_HDBAR, pcr->host_sg_tbl_addr);\n\trtsx_pci_writel(pcr, RTSX_HDBCTLR, val);\n\n\tspin_unlock_irqrestore(&pcr->lock, flags);\n\n\ttimeleft = wait_for_completion_interruptible_timeout(\n\t\t\t&trans_done, msecs_to_jiffies(timeout));\n\tif (timeleft <= 0) {\n\t\tpcr_dbg(pcr, \"Timeout (%s %d)\\n\", __func__, __LINE__);\n\t\terr = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&pcr->lock, flags);\n\tif (pcr->trans_result == TRANS_RESULT_FAIL) {\n\t\terr = -EILSEQ;\n\t\tif (pcr->dma_error_count < RTS_MAX_TIMES_FREQ_REDUCTION)\n\t\t\tpcr->dma_error_count++;\n\t}\n\n\telse if (pcr->trans_result == TRANS_NO_DEVICE)\n\t\terr = -ENODEV;\n\tspin_unlock_irqrestore(&pcr->lock, flags);\n\nout:\n\tspin_lock_irqsave(&pcr->lock, flags);\n\tpcr->done = NULL;\n\tspin_unlock_irqrestore(&pcr->lock, flags);\n\n\tif ((err < 0) && (err != -ENODEV))\n\t\trtsx_pci_stop_cmd(pcr);\n\n\tif (pcr->finish_me)\n\t\tcomplete(pcr->finish_me);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_dma_transfer);\n\nint rtsx_pci_read_ppbuf(struct rtsx_pcr *pcr, u8 *buf, int buf_len)\n{\n\tint err;\n\tint i, j;\n\tu16 reg;\n\tu8 *ptr;\n\n\tif (buf_len > 512)\n\t\tbuf_len = 512;\n\n\tptr = buf;\n\treg = PPBUF_BASE2;\n\tfor (i = 0; i < buf_len / 256; i++) {\n\t\trtsx_pci_init_cmd(pcr);\n\n\t\tfor (j = 0; j < 256; j++)\n\t\t\trtsx_pci_add_cmd(pcr, READ_REG_CMD, reg++, 0, 0);\n\n\t\terr = rtsx_pci_send_cmd(pcr, 250);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmemcpy(ptr, rtsx_pci_get_cmd_data(pcr), 256);\n\t\tptr += 256;\n\t}\n\n\tif (buf_len % 256) {\n\t\trtsx_pci_init_cmd(pcr);\n\n\t\tfor (j = 0; j < buf_len % 256; j++)\n\t\t\trtsx_pci_add_cmd(pcr, READ_REG_CMD, reg++, 0, 0);\n\n\t\terr = rtsx_pci_send_cmd(pcr, 250);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tmemcpy(ptr, rtsx_pci_get_cmd_data(pcr), buf_len % 256);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_read_ppbuf);\n\nint rtsx_pci_write_ppbuf(struct rtsx_pcr *pcr, u8 *buf, int buf_len)\n{\n\tint err;\n\tint i, j;\n\tu16 reg;\n\tu8 *ptr;\n\n\tif (buf_len > 512)\n\t\tbuf_len = 512;\n\n\tptr = buf;\n\treg = PPBUF_BASE2;\n\tfor (i = 0; i < buf_len / 256; i++) {\n\t\trtsx_pci_init_cmd(pcr);\n\n\t\tfor (j = 0; j < 256; j++) {\n\t\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\n\t\t\t\t\treg++, 0xFF, *ptr);\n\t\t\tptr++;\n\t\t}\n\n\t\terr = rtsx_pci_send_cmd(pcr, 250);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (buf_len % 256) {\n\t\trtsx_pci_init_cmd(pcr);\n\n\t\tfor (j = 0; j < buf_len % 256; j++) {\n\t\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\n\t\t\t\t\treg++, 0xFF, *ptr);\n\t\t\tptr++;\n\t\t}\n\n\t\terr = rtsx_pci_send_cmd(pcr, 250);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_write_ppbuf);\n\nstatic int rtsx_pci_set_pull_ctl(struct rtsx_pcr *pcr, const u32 *tbl)\n{\n\trtsx_pci_init_cmd(pcr);\n\n\twhile (*tbl & 0xFFFF0000) {\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\n\t\t\t\t(u16)(*tbl >> 16), 0xFF, (u8)(*tbl));\n\t\ttbl++;\n\t}\n\n\treturn rtsx_pci_send_cmd(pcr, 100);\n}\n\nint rtsx_pci_card_pull_ctl_enable(struct rtsx_pcr *pcr, int card)\n{\n\tconst u32 *tbl;\n\n\tif (card == RTSX_SD_CARD)\n\t\ttbl = pcr->sd_pull_ctl_enable_tbl;\n\telse if (card == RTSX_MS_CARD)\n\t\ttbl = pcr->ms_pull_ctl_enable_tbl;\n\telse\n\t\treturn -EINVAL;\n\n\treturn rtsx_pci_set_pull_ctl(pcr, tbl);\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_card_pull_ctl_enable);\n\nint rtsx_pci_card_pull_ctl_disable(struct rtsx_pcr *pcr, int card)\n{\n\tconst u32 *tbl;\n\n\tif (card == RTSX_SD_CARD)\n\t\ttbl = pcr->sd_pull_ctl_disable_tbl;\n\telse if (card == RTSX_MS_CARD)\n\t\ttbl = pcr->ms_pull_ctl_disable_tbl;\n\telse\n\t\treturn -EINVAL;\n\n\treturn rtsx_pci_set_pull_ctl(pcr, tbl);\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_card_pull_ctl_disable);\n\nstatic void rtsx_pci_enable_bus_int(struct rtsx_pcr *pcr)\n{\n\tstruct rtsx_hw_param *hw_param = &pcr->hw_param;\n\n\tpcr->bier = TRANS_OK_INT_EN | TRANS_FAIL_INT_EN | SD_INT_EN\n\t\t| hw_param->interrupt_en;\n\n\tif (pcr->num_slots > 1)\n\t\tpcr->bier |= MS_INT_EN;\n\n\t \n\trtsx_pci_writel(pcr, RTSX_BIER, pcr->bier);\n\n\tpcr_dbg(pcr, \"RTSX_BIER: 0x%08x\\n\", pcr->bier);\n}\n\nstatic inline u8 double_ssc_depth(u8 depth)\n{\n\treturn ((depth > 1) ? (depth - 1) : depth);\n}\n\nstatic u8 revise_ssc_depth(u8 ssc_depth, u8 div)\n{\n\tif (div > CLK_DIV_1) {\n\t\tif (ssc_depth > (div - 1))\n\t\t\tssc_depth -= (div - 1);\n\t\telse\n\t\t\tssc_depth = SSC_DEPTH_4M;\n\t}\n\n\treturn ssc_depth;\n}\n\nint rtsx_pci_switch_clock(struct rtsx_pcr *pcr, unsigned int card_clock,\n\t\tu8 ssc_depth, bool initial_mode, bool double_clk, bool vpclk)\n{\n\tint err, clk;\n\tu8 n, clk_divider, mcu_cnt, div;\n\tstatic const u8 depth[] = {\n\t\t[RTSX_SSC_DEPTH_4M] = SSC_DEPTH_4M,\n\t\t[RTSX_SSC_DEPTH_2M] = SSC_DEPTH_2M,\n\t\t[RTSX_SSC_DEPTH_1M] = SSC_DEPTH_1M,\n\t\t[RTSX_SSC_DEPTH_500K] = SSC_DEPTH_500K,\n\t\t[RTSX_SSC_DEPTH_250K] = SSC_DEPTH_250K,\n\t};\n\n\tif (PCI_PID(pcr) == PID_5261)\n\t\treturn rts5261_pci_switch_clock(pcr, card_clock,\n\t\t\t\tssc_depth, initial_mode, double_clk, vpclk);\n\tif (PCI_PID(pcr) == PID_5228)\n\t\treturn rts5228_pci_switch_clock(pcr, card_clock,\n\t\t\t\tssc_depth, initial_mode, double_clk, vpclk);\n\n\tif (initial_mode) {\n\t\t \n\t\tclk_divider = SD_CLK_DIVIDE_128;\n\t\tcard_clock = 30000000;\n\t} else {\n\t\tclk_divider = SD_CLK_DIVIDE_0;\n\t}\n\terr = rtsx_pci_write_register(pcr, SD_CFG1,\n\t\t\tSD_CLK_DIVIDE_MASK, clk_divider);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (card_clock == UHS_SDR104_MAX_DTR &&\n\t    pcr->dma_error_count &&\n\t    PCI_PID(pcr) == RTS5227_DEVICE_ID)\n\t\tcard_clock = UHS_SDR104_MAX_DTR -\n\t\t\t(pcr->dma_error_count * 20000000);\n\n\tcard_clock /= 1000000;\n\tpcr_dbg(pcr, \"Switch card clock to %dMHz\\n\", card_clock);\n\n\tclk = card_clock;\n\tif (!initial_mode && double_clk)\n\t\tclk = card_clock * 2;\n\tpcr_dbg(pcr, \"Internal SSC clock: %dMHz (cur_clock = %d)\\n\",\n\t\tclk, pcr->cur_clock);\n\n\tif (clk == pcr->cur_clock)\n\t\treturn 0;\n\n\tif (pcr->ops->conv_clk_and_div_n)\n\t\tn = (u8)pcr->ops->conv_clk_and_div_n(clk, CLK_TO_DIV_N);\n\telse\n\t\tn = (u8)(clk - 2);\n\tif ((clk <= 2) || (n > MAX_DIV_N_PCR))\n\t\treturn -EINVAL;\n\n\tmcu_cnt = (u8)(125/clk + 3);\n\tif (mcu_cnt > 15)\n\t\tmcu_cnt = 15;\n\n\t \n\tdiv = CLK_DIV_1;\n\twhile ((n < MIN_DIV_N_PCR) && (div < CLK_DIV_8)) {\n\t\tif (pcr->ops->conv_clk_and_div_n) {\n\t\t\tint dbl_clk = pcr->ops->conv_clk_and_div_n(n,\n\t\t\t\t\tDIV_N_TO_CLK) * 2;\n\t\t\tn = (u8)pcr->ops->conv_clk_and_div_n(dbl_clk,\n\t\t\t\t\tCLK_TO_DIV_N);\n\t\t} else {\n\t\t\tn = (n + 2) * 2 - 2;\n\t\t}\n\t\tdiv++;\n\t}\n\tpcr_dbg(pcr, \"n = %d, div = %d\\n\", n, div);\n\n\tssc_depth = depth[ssc_depth];\n\tif (double_clk)\n\t\tssc_depth = double_ssc_depth(ssc_depth);\n\n\tssc_depth = revise_ssc_depth(ssc_depth, div);\n\tpcr_dbg(pcr, \"ssc_depth = %d\\n\", ssc_depth);\n\n\trtsx_pci_init_cmd(pcr);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_CTL,\n\t\t\tCLK_LOW_FREQ, CLK_LOW_FREQ);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_DIV,\n\t\t\t0xFF, (div << 4) | mcu_cnt);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, 0);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL2,\n\t\t\tSSC_DEPTH_MASK, ssc_depth);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_DIV_N_0, 0xFF, n);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, SSC_RSTB);\n\tif (vpclk) {\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_VPCLK0_CTL,\n\t\t\t\tPHASE_NOT_RESET, 0);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_VPCLK0_CTL,\n\t\t\t\tPHASE_NOT_RESET, PHASE_NOT_RESET);\n\t}\n\n\terr = rtsx_pci_send_cmd(pcr, 2000);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tudelay(SSC_CLOCK_STABLE_WAIT);\n\terr = rtsx_pci_write_register(pcr, CLK_CTL, CLK_LOW_FREQ, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcr->cur_clock = clk;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_switch_clock);\n\nint rtsx_pci_card_power_on(struct rtsx_pcr *pcr, int card)\n{\n\tif (pcr->ops->card_power_on)\n\t\treturn pcr->ops->card_power_on(pcr, card);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_card_power_on);\n\nint rtsx_pci_card_power_off(struct rtsx_pcr *pcr, int card)\n{\n\tif (pcr->ops->card_power_off)\n\t\treturn pcr->ops->card_power_off(pcr, card);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_card_power_off);\n\nint rtsx_pci_card_exclusive_check(struct rtsx_pcr *pcr, int card)\n{\n\tstatic const unsigned int cd_mask[] = {\n\t\t[RTSX_SD_CARD] = SD_EXIST,\n\t\t[RTSX_MS_CARD] = MS_EXIST\n\t};\n\n\tif (!(pcr->flags & PCR_MS_PMOS)) {\n\t\t \n\t\tif (pcr->card_exist & (~cd_mask[card]))\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_card_exclusive_check);\n\nint rtsx_pci_switch_output_voltage(struct rtsx_pcr *pcr, u8 voltage)\n{\n\tif (pcr->ops->switch_output_voltage)\n\t\treturn pcr->ops->switch_output_voltage(pcr, voltage);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_switch_output_voltage);\n\nunsigned int rtsx_pci_card_exist(struct rtsx_pcr *pcr)\n{\n\tunsigned int val;\n\n\tval = rtsx_pci_readl(pcr, RTSX_BIPR);\n\tif (pcr->ops->cd_deglitch)\n\t\tval = pcr->ops->cd_deglitch(pcr);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_card_exist);\n\nvoid rtsx_pci_complete_unfinished_transfer(struct rtsx_pcr *pcr)\n{\n\tstruct completion finish;\n\n\tpcr->finish_me = &finish;\n\tinit_completion(&finish);\n\n\tif (pcr->done)\n\t\tcomplete(pcr->done);\n\n\tif (!pcr->remove_pci)\n\t\trtsx_pci_stop_cmd(pcr);\n\n\twait_for_completion_interruptible_timeout(&finish,\n\t\t\tmsecs_to_jiffies(2));\n\tpcr->finish_me = NULL;\n}\nEXPORT_SYMBOL_GPL(rtsx_pci_complete_unfinished_transfer);\n\nstatic void rtsx_pci_card_detect(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct rtsx_pcr *pcr;\n\tunsigned long flags;\n\tunsigned int card_detect = 0, card_inserted, card_removed;\n\tu32 irq_status;\n\n\tdwork = to_delayed_work(work);\n\tpcr = container_of(dwork, struct rtsx_pcr, carddet_work);\n\n\tpcr_dbg(pcr, \"--> %s\\n\", __func__);\n\n\tmutex_lock(&pcr->pcr_mutex);\n\tspin_lock_irqsave(&pcr->lock, flags);\n\n\tirq_status = rtsx_pci_readl(pcr, RTSX_BIPR);\n\tpcr_dbg(pcr, \"irq_status: 0x%08x\\n\", irq_status);\n\n\tirq_status &= CARD_EXIST;\n\tcard_inserted = pcr->card_inserted & irq_status;\n\tcard_removed = pcr->card_removed;\n\tpcr->card_inserted = 0;\n\tpcr->card_removed = 0;\n\n\tspin_unlock_irqrestore(&pcr->lock, flags);\n\n\tif (card_inserted || card_removed) {\n\t\tpcr_dbg(pcr, \"card_inserted: 0x%x, card_removed: 0x%x\\n\",\n\t\t\tcard_inserted, card_removed);\n\n\t\tif (pcr->ops->cd_deglitch)\n\t\t\tcard_inserted = pcr->ops->cd_deglitch(pcr);\n\n\t\tcard_detect = card_inserted | card_removed;\n\n\t\tpcr->card_exist |= card_inserted;\n\t\tpcr->card_exist &= ~card_removed;\n\t}\n\n\tmutex_unlock(&pcr->pcr_mutex);\n\n\tif ((card_detect & SD_EXIST) && pcr->slots[RTSX_SD_CARD].card_event)\n\t\tpcr->slots[RTSX_SD_CARD].card_event(\n\t\t\t\tpcr->slots[RTSX_SD_CARD].p_dev);\n\tif ((card_detect & MS_EXIST) && pcr->slots[RTSX_MS_CARD].card_event)\n\t\tpcr->slots[RTSX_MS_CARD].card_event(\n\t\t\t\tpcr->slots[RTSX_MS_CARD].p_dev);\n}\n\nstatic void rtsx_pci_process_ocp(struct rtsx_pcr *pcr)\n{\n\tif (pcr->ops->process_ocp) {\n\t\tpcr->ops->process_ocp(pcr);\n\t} else {\n\t\tif (!pcr->option.ocp_en)\n\t\t\treturn;\n\t\trtsx_pci_get_ocpstat(pcr, &pcr->ocp_stat);\n\t\tif (pcr->ocp_stat & (SD_OC_NOW | SD_OC_EVER)) {\n\t\t\trtsx_pci_card_power_off(pcr, RTSX_SD_CARD);\n\t\t\trtsx_pci_write_register(pcr, CARD_OE, SD_OUTPUT_EN, 0);\n\t\t\trtsx_pci_clear_ocpstat(pcr);\n\t\t\tpcr->ocp_stat = 0;\n\t\t}\n\t}\n}\n\nstatic int rtsx_pci_process_ocp_interrupt(struct rtsx_pcr *pcr)\n{\n\tif (pcr->option.ocp_en)\n\t\trtsx_pci_process_ocp(pcr);\n\n\treturn 0;\n}\n\nstatic irqreturn_t rtsx_pci_isr(int irq, void *dev_id)\n{\n\tstruct rtsx_pcr *pcr = dev_id;\n\tu32 int_reg;\n\n\tif (!pcr)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&pcr->lock);\n\n\tint_reg = rtsx_pci_readl(pcr, RTSX_BIPR);\n\t \n\trtsx_pci_writel(pcr, RTSX_BIPR, int_reg);\n\tif ((int_reg & pcr->bier) == 0) {\n\t\tspin_unlock(&pcr->lock);\n\t\treturn IRQ_NONE;\n\t}\n\tif (int_reg == 0xFFFFFFFF) {\n\t\tspin_unlock(&pcr->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tint_reg &= (pcr->bier | 0x7FFFFF);\n\n\tif (int_reg & SD_OC_INT)\n\t\trtsx_pci_process_ocp_interrupt(pcr);\n\n\tif (int_reg & SD_INT) {\n\t\tif (int_reg & SD_EXIST) {\n\t\t\tpcr->card_inserted |= SD_EXIST;\n\t\t} else {\n\t\t\tpcr->card_removed |= SD_EXIST;\n\t\t\tpcr->card_inserted &= ~SD_EXIST;\n\t\t\tif (PCI_PID(pcr) == PID_5261) {\n\t\t\t\trtsx_pci_write_register(pcr, RTS5261_FW_STATUS,\n\t\t\t\t\tRTS5261_EXPRESS_LINK_FAIL_MASK, 0);\n\t\t\t\tpcr->extra_caps |= EXTRA_CAPS_SD_EXPRESS;\n\t\t\t}\n\t\t}\n\t\tpcr->dma_error_count = 0;\n\t}\n\n\tif (int_reg & MS_INT) {\n\t\tif (int_reg & MS_EXIST) {\n\t\t\tpcr->card_inserted |= MS_EXIST;\n\t\t} else {\n\t\t\tpcr->card_removed |= MS_EXIST;\n\t\t\tpcr->card_inserted &= ~MS_EXIST;\n\t\t}\n\t}\n\n\tif (int_reg & (NEED_COMPLETE_INT | DELINK_INT)) {\n\t\tif (int_reg & (TRANS_FAIL_INT | DELINK_INT)) {\n\t\t\tpcr->trans_result = TRANS_RESULT_FAIL;\n\t\t\tif (pcr->done)\n\t\t\t\tcomplete(pcr->done);\n\t\t} else if (int_reg & TRANS_OK_INT) {\n\t\t\tpcr->trans_result = TRANS_RESULT_OK;\n\t\t\tif (pcr->done)\n\t\t\t\tcomplete(pcr->done);\n\t\t}\n\t}\n\n\tif ((pcr->card_inserted || pcr->card_removed) && !(int_reg & SD_OC_INT))\n\t\tschedule_delayed_work(&pcr->carddet_work,\n\t\t\t\tmsecs_to_jiffies(200));\n\n\tspin_unlock(&pcr->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int rtsx_pci_acquire_irq(struct rtsx_pcr *pcr)\n{\n\tpcr_dbg(pcr, \"%s: pcr->msi_en = %d, pci->irq = %d\\n\",\n\t\t\t__func__, pcr->msi_en, pcr->pci->irq);\n\n\tif (request_irq(pcr->pci->irq, rtsx_pci_isr,\n\t\t\tpcr->msi_en ? 0 : IRQF_SHARED,\n\t\t\tDRV_NAME_RTSX_PCI, pcr)) {\n\t\tdev_err(&(pcr->pci->dev),\n\t\t\t\"rtsx_sdmmc: unable to grab IRQ %d, disabling device\\n\",\n\t\t\tpcr->pci->irq);\n\t\treturn -1;\n\t}\n\n\tpcr->irq = pcr->pci->irq;\n\tpci_intx(pcr->pci, !pcr->msi_en);\n\n\treturn 0;\n}\n\nstatic void rtsx_base_force_power_down(struct rtsx_pcr *pcr)\n{\n\t \n\trtsx_pci_write_register(pcr, AUTOLOAD_CFG_BASE + 1, MASK_8_BIT_DEF, 0);\n\trtsx_pci_write_register(pcr, AUTOLOAD_CFG_BASE + 2, MASK_8_BIT_DEF, 0);\n\trtsx_pci_write_register(pcr, AUTOLOAD_CFG_BASE + 3,\n\t\t\tRELINK_TIME_MASK, 0);\n\n\trtsx_pci_write_register(pcr, pcr->reg_pm_ctrl3,\n\t\t\tD3_DELINK_MODE_EN, D3_DELINK_MODE_EN);\n\n\trtsx_pci_write_register(pcr, FPDCTL, ALL_POWER_DOWN, ALL_POWER_DOWN);\n}\n\nstatic void __maybe_unused rtsx_pci_power_off(struct rtsx_pcr *pcr, u8 pm_state, bool runtime)\n{\n\tif (pcr->ops->turn_off_led)\n\t\tpcr->ops->turn_off_led(pcr);\n\n\trtsx_pci_writel(pcr, RTSX_BIER, 0);\n\tpcr->bier = 0;\n\n\trtsx_pci_write_register(pcr, PETXCFG, 0x08, 0x08);\n\trtsx_pci_write_register(pcr, HOST_SLEEP_STATE, 0x03, pm_state);\n\n\tif (pcr->ops->force_power_down)\n\t\tpcr->ops->force_power_down(pcr, pm_state, runtime);\n\telse\n\t\trtsx_base_force_power_down(pcr);\n}\n\nvoid rtsx_pci_enable_ocp(struct rtsx_pcr *pcr)\n{\n\tu8 val = SD_OCP_INT_EN | SD_DETECT_EN;\n\n\tif (pcr->ops->enable_ocp) {\n\t\tpcr->ops->enable_ocp(pcr);\n\t} else {\n\t\trtsx_pci_write_register(pcr, FPDCTL, OC_POWER_DOWN, 0);\n\t\trtsx_pci_write_register(pcr, REG_OCPCTL, 0xFF, val);\n\t}\n\n}\n\nvoid rtsx_pci_disable_ocp(struct rtsx_pcr *pcr)\n{\n\tu8 mask = SD_OCP_INT_EN | SD_DETECT_EN;\n\n\tif (pcr->ops->disable_ocp) {\n\t\tpcr->ops->disable_ocp(pcr);\n\t} else {\n\t\trtsx_pci_write_register(pcr, REG_OCPCTL, mask, 0);\n\t\trtsx_pci_write_register(pcr, FPDCTL, OC_POWER_DOWN,\n\t\t\t\tOC_POWER_DOWN);\n\t}\n}\n\nvoid rtsx_pci_init_ocp(struct rtsx_pcr *pcr)\n{\n\tif (pcr->ops->init_ocp) {\n\t\tpcr->ops->init_ocp(pcr);\n\t} else {\n\t\tstruct rtsx_cr_option *option = &(pcr->option);\n\n\t\tif (option->ocp_en) {\n\t\t\tu8 val = option->sd_800mA_ocp_thd;\n\n\t\t\trtsx_pci_write_register(pcr, FPDCTL, OC_POWER_DOWN, 0);\n\t\t\trtsx_pci_write_register(pcr, REG_OCPPARA1,\n\t\t\t\tSD_OCP_TIME_MASK, SD_OCP_TIME_800);\n\t\t\trtsx_pci_write_register(pcr, REG_OCPPARA2,\n\t\t\t\tSD_OCP_THD_MASK, val);\n\t\t\trtsx_pci_write_register(pcr, REG_OCPGLITCH,\n\t\t\t\tSD_OCP_GLITCH_MASK, pcr->hw_param.ocp_glitch);\n\t\t\trtsx_pci_enable_ocp(pcr);\n\t\t}\n\t}\n}\n\nint rtsx_pci_get_ocpstat(struct rtsx_pcr *pcr, u8 *val)\n{\n\tif (pcr->ops->get_ocpstat)\n\t\treturn pcr->ops->get_ocpstat(pcr, val);\n\telse\n\t\treturn rtsx_pci_read_register(pcr, REG_OCPSTAT, val);\n}\n\nvoid rtsx_pci_clear_ocpstat(struct rtsx_pcr *pcr)\n{\n\tif (pcr->ops->clear_ocpstat) {\n\t\tpcr->ops->clear_ocpstat(pcr);\n\t} else {\n\t\tu8 mask = SD_OCP_INT_CLR | SD_OC_CLR;\n\t\tu8 val = SD_OCP_INT_CLR | SD_OC_CLR;\n\n\t\trtsx_pci_write_register(pcr, REG_OCPCTL, mask, val);\n\t\tudelay(100);\n\t\trtsx_pci_write_register(pcr, REG_OCPCTL, mask, 0);\n\t}\n}\n\nvoid rtsx_pci_enable_oobs_polling(struct rtsx_pcr *pcr)\n{\n\tu16 val;\n\n\tif ((PCI_PID(pcr) != PID_525A) && (PCI_PID(pcr) != PID_5260)) {\n\t\trtsx_pci_read_phy_register(pcr, 0x01, &val);\n\t\tval |= 1<<9;\n\t\trtsx_pci_write_phy_register(pcr, 0x01, val);\n\t}\n\trtsx_pci_write_register(pcr, REG_CFG_OOBS_OFF_TIMER, 0xFF, 0x32);\n\trtsx_pci_write_register(pcr, REG_CFG_OOBS_ON_TIMER, 0xFF, 0x05);\n\trtsx_pci_write_register(pcr, REG_CFG_VCM_ON_TIMER, 0xFF, 0x83);\n\trtsx_pci_write_register(pcr, REG_CFG_OOBS_POLLING, 0xFF, 0xDE);\n\n}\n\nvoid rtsx_pci_disable_oobs_polling(struct rtsx_pcr *pcr)\n{\n\tu16 val;\n\n\tif ((PCI_PID(pcr) != PID_525A) && (PCI_PID(pcr) != PID_5260)) {\n\t\trtsx_pci_read_phy_register(pcr, 0x01, &val);\n\t\tval &= ~(1<<9);\n\t\trtsx_pci_write_phy_register(pcr, 0x01, val);\n\t}\n\trtsx_pci_write_register(pcr, REG_CFG_VCM_ON_TIMER, 0xFF, 0x03);\n\trtsx_pci_write_register(pcr, REG_CFG_OOBS_POLLING, 0xFF, 0x00);\n\n}\n\nint rtsx_sd_power_off_card3v3(struct rtsx_pcr *pcr)\n{\n\trtsx_pci_write_register(pcr, CARD_CLK_EN, SD_CLK_EN |\n\t\tMS_CLK_EN | SD40_CLK_EN, 0);\n\trtsx_pci_write_register(pcr, CARD_OE, SD_OUTPUT_EN, 0);\n\trtsx_pci_card_power_off(pcr, RTSX_SD_CARD);\n\n\tmsleep(50);\n\n\trtsx_pci_card_pull_ctl_disable(pcr, RTSX_SD_CARD);\n\n\treturn 0;\n}\n\nint rtsx_ms_power_off_card3v3(struct rtsx_pcr *pcr)\n{\n\trtsx_pci_write_register(pcr, CARD_CLK_EN, SD_CLK_EN |\n\t\tMS_CLK_EN | SD40_CLK_EN, 0);\n\n\trtsx_pci_card_pull_ctl_disable(pcr, RTSX_MS_CARD);\n\n\trtsx_pci_write_register(pcr, CARD_OE, MS_OUTPUT_EN, 0);\n\trtsx_pci_card_power_off(pcr, RTSX_MS_CARD);\n\n\treturn 0;\n}\n\nstatic int rtsx_pci_init_hw(struct rtsx_pcr *pcr)\n{\n\tstruct pci_dev *pdev = pcr->pci;\n\tint err;\n\n\tif (PCI_PID(pcr) == PID_5228)\n\t\trtsx_pci_write_register(pcr, RTS5228_LDO1_CFG1, RTS5228_LDO1_SR_TIME_MASK,\n\t\t\t\tRTS5228_LDO1_SR_0_5);\n\n\trtsx_pci_writel(pcr, RTSX_HCBAR, pcr->host_cmds_addr);\n\n\trtsx_pci_enable_bus_int(pcr);\n\n\t \n\tif (PCI_PID(pcr) == PID_5261) {\n\t\t \n\t\terr = rtsx_pci_write_register(pcr, RTS5261_FW_CFG1,\n\t\t\tRTS5261_MCU_CLOCK_GATING, 0);\n\t\terr = rtsx_pci_write_register(pcr, RTS5261_REG_FPDCTL,\n\t\t\tSSC_POWER_DOWN, 0);\n\t} else {\n\t\terr = rtsx_pci_write_register(pcr, FPDCTL, SSC_POWER_DOWN, 0);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tudelay(200);\n\n\trtsx_disable_aspm(pcr);\n\tif (pcr->ops->optimize_phy) {\n\t\terr = pcr->ops->optimize_phy(pcr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\trtsx_pci_init_cmd(pcr);\n\n\t \n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_DIV, 0x07, 0x07);\n\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, HOST_SLEEP_STATE, 0x03, 0x00);\n\t \n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_EN, 0x1E, 0);\n\t \n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CHANGE_LINK_STATE, 0x0A, 0);\n\t \n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_DRIVE_SEL,\n\t\t\t0xFF, pcr->card_drive_sel);\n\t \n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL1,\n\t\t\t0xFF, SSC_8X_EN | SSC_SEL_4M);\n\tif (PCI_PID(pcr) == PID_5261)\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL2, 0xFF,\n\t\t\tRTS5261_SSC_DEPTH_2M);\n\telse if (PCI_PID(pcr) == PID_5228)\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL2, 0xFF,\n\t\t\tRTS5228_SSC_DEPTH_2M);\n\telse\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL2, 0xFF, 0x12);\n\n\t \n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CHANGE_LINK_STATE, 0x16, 0x10);\n\t \n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, IRQSTAT0,\n\t\t\tLINK_RDY_INT, LINK_RDY_INT);\n\t \n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, PERST_GLITCH_WIDTH, 0xFF, 0x80);\n\t \n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, RCCTL, 0x01, 0x00);\n\t \n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, NFTS_TX_CTRL, 0x02, 0);\n\n\terr = rtsx_pci_send_cmd(pcr, 100);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (PCI_PID(pcr)) {\n\tcase PID_5250:\n\tcase PID_524A:\n\tcase PID_525A:\n\tcase PID_5260:\n\tcase PID_5261:\n\tcase PID_5228:\n\t\trtsx_pci_write_register(pcr, PM_CLK_FORCE_CTL, 1, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\trtsx_pci_init_ocp(pcr);\n\n\t \n\tpcie_capability_clear_and_set_word(pcr->pci, PCI_EXP_LNKCTL,\n\t\t\t\t\t0, PCI_EXP_LNKCTL_CLKREQ_EN);\n\t \n\tpci_write_config_byte(pdev, 0x70F, 0x5B);\n\n\tif (pcr->ops->extra_init_hw) {\n\t\terr = pcr->ops->extra_init_hw(pcr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (pcr->aspm_mode == ASPM_MODE_REG)\n\t\trtsx_pci_write_register(pcr, ASPM_FORCE_CTL, 0x30, 0x30);\n\n\t \n\tif (pcr->ops->cd_deglitch)\n\t\tpcr->card_exist = pcr->ops->cd_deglitch(pcr);\n\telse\n\t\tpcr->card_exist = rtsx_pci_readl(pcr, RTSX_BIPR) & CARD_EXIST;\n\n\treturn 0;\n}\n\nstatic int rtsx_pci_init_chip(struct rtsx_pcr *pcr)\n{\n\tstruct rtsx_cr_option *option = &(pcr->option);\n\tint err, l1ss;\n\tu32 lval;\n\tu16 cfg_val;\n\tu8 val;\n\n\tspin_lock_init(&pcr->lock);\n\tmutex_init(&pcr->pcr_mutex);\n\n\tswitch (PCI_PID(pcr)) {\n\tdefault:\n\tcase 0x5209:\n\t\trts5209_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x5229:\n\t\trts5229_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x5289:\n\t\trtl8411_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x5227:\n\t\trts5227_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x522A:\n\t\trts522a_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x5249:\n\t\trts5249_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x524A:\n\t\trts524a_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x525A:\n\t\trts525a_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x5287:\n\t\trtl8411b_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x5286:\n\t\trtl8402_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x5260:\n\t\trts5260_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x5261:\n\t\trts5261_init_params(pcr);\n\t\tbreak;\n\n\tcase 0x5228:\n\t\trts5228_init_params(pcr);\n\t\tbreak;\n\t}\n\n\tpcr_dbg(pcr, \"PID: 0x%04x, IC version: 0x%02x\\n\",\n\t\t\tPCI_PID(pcr), pcr->ic_version);\n\n\tpcr->slots = kcalloc(pcr->num_slots, sizeof(struct rtsx_slot),\n\t\t\tGFP_KERNEL);\n\tif (!pcr->slots)\n\t\treturn -ENOMEM;\n\n\tif (pcr->aspm_mode == ASPM_MODE_CFG) {\n\t\tpcie_capability_read_word(pcr->pci, PCI_EXP_LNKCTL, &cfg_val);\n\t\tif (cfg_val & PCI_EXP_LNKCTL_ASPM_L1)\n\t\t\tpcr->aspm_enabled = true;\n\t\telse\n\t\t\tpcr->aspm_enabled = false;\n\n\t} else if (pcr->aspm_mode == ASPM_MODE_REG) {\n\t\trtsx_pci_read_register(pcr, ASPM_FORCE_CTL, &val);\n\t\tif (val & FORCE_ASPM_CTL0 && val & FORCE_ASPM_CTL1)\n\t\t\tpcr->aspm_enabled = false;\n\t\telse\n\t\t\tpcr->aspm_enabled = true;\n\t}\n\n\tl1ss = pci_find_ext_capability(pcr->pci, PCI_EXT_CAP_ID_L1SS);\n\tif (l1ss) {\n\t\tpci_read_config_dword(pcr->pci, l1ss + PCI_L1SS_CTL1, &lval);\n\n\t\tif (lval & PCI_L1SS_CTL1_ASPM_L1_1)\n\t\t\trtsx_set_dev_flag(pcr, ASPM_L1_1_EN);\n\t\telse\n\t\t\trtsx_clear_dev_flag(pcr, ASPM_L1_1_EN);\n\n\t\tif (lval & PCI_L1SS_CTL1_ASPM_L1_2)\n\t\t\trtsx_set_dev_flag(pcr, ASPM_L1_2_EN);\n\t\telse\n\t\t\trtsx_clear_dev_flag(pcr, ASPM_L1_2_EN);\n\n\t\tif (lval & PCI_L1SS_CTL1_PCIPM_L1_1)\n\t\t\trtsx_set_dev_flag(pcr, PM_L1_1_EN);\n\t\telse\n\t\t\trtsx_clear_dev_flag(pcr, PM_L1_1_EN);\n\n\t\tif (lval & PCI_L1SS_CTL1_PCIPM_L1_2)\n\t\t\trtsx_set_dev_flag(pcr, PM_L1_2_EN);\n\t\telse\n\t\t\trtsx_clear_dev_flag(pcr, PM_L1_2_EN);\n\n\t\tpcie_capability_read_word(pcr->pci, PCI_EXP_DEVCTL2, &cfg_val);\n\t\tif (cfg_val & PCI_EXP_DEVCTL2_LTR_EN) {\n\t\t\toption->ltr_enabled = true;\n\t\t\toption->ltr_active = true;\n\t\t} else {\n\t\t\toption->ltr_enabled = false;\n\t\t}\n\n\t\tif (rtsx_check_dev_flag(pcr, ASPM_L1_1_EN | ASPM_L1_2_EN\n\t\t\t\t| PM_L1_1_EN | PM_L1_2_EN))\n\t\t\toption->force_clkreq_0 = false;\n\t\telse\n\t\t\toption->force_clkreq_0 = true;\n\t} else {\n\t\toption->ltr_enabled = false;\n\t\toption->force_clkreq_0 = true;\n\t}\n\n\tif (pcr->ops->fetch_vendor_settings)\n\t\tpcr->ops->fetch_vendor_settings(pcr);\n\n\tpcr_dbg(pcr, \"pcr->aspm_en = 0x%x\\n\", pcr->aspm_en);\n\tpcr_dbg(pcr, \"pcr->sd30_drive_sel_1v8 = 0x%x\\n\",\n\t\t\tpcr->sd30_drive_sel_1v8);\n\tpcr_dbg(pcr, \"pcr->sd30_drive_sel_3v3 = 0x%x\\n\",\n\t\t\tpcr->sd30_drive_sel_3v3);\n\tpcr_dbg(pcr, \"pcr->card_drive_sel = 0x%x\\n\",\n\t\t\tpcr->card_drive_sel);\n\tpcr_dbg(pcr, \"pcr->flags = 0x%x\\n\", pcr->flags);\n\n\tpcr->state = PDEV_STAT_IDLE;\n\terr = rtsx_pci_init_hw(pcr);\n\tif (err < 0) {\n\t\tkfree(pcr->slots);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtsx_pci_probe(struct pci_dev *pcidev,\n\t\t\t  const struct pci_device_id *id)\n{\n\tstruct rtsx_pcr *pcr;\n\tstruct pcr_handle *handle;\n\tu32 base, len;\n\tint ret, i, bar = 0;\n\n\tdev_dbg(&(pcidev->dev),\n\t\t\": Realtek PCI-E Card Reader found at %s [%04x:%04x] (rev %x)\\n\",\n\t\tpci_name(pcidev), (int)pcidev->vendor, (int)pcidev->device,\n\t\t(int)pcidev->revision);\n\n\tret = dma_set_mask(&pcidev->dev, DMA_BIT_MASK(32));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pci_enable_device(pcidev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_request_regions(pcidev, DRV_NAME_RTSX_PCI);\n\tif (ret)\n\t\tgoto disable;\n\n\tpcr = kzalloc(sizeof(*pcr), GFP_KERNEL);\n\tif (!pcr) {\n\t\tret = -ENOMEM;\n\t\tgoto release_pci;\n\t}\n\n\thandle = kzalloc(sizeof(*handle), GFP_KERNEL);\n\tif (!handle) {\n\t\tret = -ENOMEM;\n\t\tgoto free_pcr;\n\t}\n\thandle->pcr = pcr;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&rtsx_pci_lock);\n\tret = idr_alloc(&rtsx_pci_idr, pcr, 0, 0, GFP_NOWAIT);\n\tif (ret >= 0)\n\t\tpcr->id = ret;\n\tspin_unlock(&rtsx_pci_lock);\n\tidr_preload_end();\n\tif (ret < 0)\n\t\tgoto free_handle;\n\n\tpcr->pci = pcidev;\n\tdev_set_drvdata(&pcidev->dev, handle);\n\n\tif (CHK_PCI_PID(pcr, 0x525A))\n\t\tbar = 1;\n\tlen = pci_resource_len(pcidev, bar);\n\tbase = pci_resource_start(pcidev, bar);\n\tpcr->remap_addr = ioremap(base, len);\n\tif (!pcr->remap_addr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_idr;\n\t}\n\n\tpcr->rtsx_resv_buf = dma_alloc_coherent(&(pcidev->dev),\n\t\t\tRTSX_RESV_BUF_LEN, &(pcr->rtsx_resv_buf_addr),\n\t\t\tGFP_KERNEL);\n\tif (pcr->rtsx_resv_buf == NULL) {\n\t\tret = -ENXIO;\n\t\tgoto unmap;\n\t}\n\tpcr->host_cmds_ptr = pcr->rtsx_resv_buf;\n\tpcr->host_cmds_addr = pcr->rtsx_resv_buf_addr;\n\tpcr->host_sg_tbl_ptr = pcr->rtsx_resv_buf + HOST_CMDS_BUF_LEN;\n\tpcr->host_sg_tbl_addr = pcr->rtsx_resv_buf_addr + HOST_CMDS_BUF_LEN;\n\tpcr->card_inserted = 0;\n\tpcr->card_removed = 0;\n\tINIT_DELAYED_WORK(&pcr->carddet_work, rtsx_pci_card_detect);\n\n\tpcr->msi_en = msi_en;\n\tif (pcr->msi_en) {\n\t\tret = pci_enable_msi(pcidev);\n\t\tif (ret)\n\t\t\tpcr->msi_en = false;\n\t}\n\n\tret = rtsx_pci_acquire_irq(pcr);\n\tif (ret < 0)\n\t\tgoto disable_msi;\n\n\tpci_set_master(pcidev);\n\tsynchronize_irq(pcr->irq);\n\n\tret = rtsx_pci_init_chip(pcr);\n\tif (ret < 0)\n\t\tgoto disable_irq;\n\n\tfor (i = 0; i < ARRAY_SIZE(rtsx_pcr_cells); i++) {\n\t\trtsx_pcr_cells[i].platform_data = handle;\n\t\trtsx_pcr_cells[i].pdata_size = sizeof(*handle);\n\t}\n\n\n\tret = mfd_add_devices(&pcidev->dev, pcr->id, rtsx_pcr_cells,\n\t\t\tARRAY_SIZE(rtsx_pcr_cells), NULL, 0, NULL);\n\tif (ret < 0)\n\t\tgoto free_slots;\n\n\tpm_runtime_allow(&pcidev->dev);\n\tpm_runtime_put(&pcidev->dev);\n\n\treturn 0;\n\nfree_slots:\n\tkfree(pcr->slots);\ndisable_irq:\n\tfree_irq(pcr->irq, (void *)pcr);\ndisable_msi:\n\tif (pcr->msi_en)\n\t\tpci_disable_msi(pcr->pci);\n\tdma_free_coherent(&(pcr->pci->dev), RTSX_RESV_BUF_LEN,\n\t\t\tpcr->rtsx_resv_buf, pcr->rtsx_resv_buf_addr);\nunmap:\n\tiounmap(pcr->remap_addr);\nfree_idr:\n\tspin_lock(&rtsx_pci_lock);\n\tidr_remove(&rtsx_pci_idr, pcr->id);\n\tspin_unlock(&rtsx_pci_lock);\nfree_handle:\n\tkfree(handle);\nfree_pcr:\n\tkfree(pcr);\nrelease_pci:\n\tpci_release_regions(pcidev);\ndisable:\n\tpci_disable_device(pcidev);\n\n\treturn ret;\n}\n\nstatic void rtsx_pci_remove(struct pci_dev *pcidev)\n{\n\tstruct pcr_handle *handle = pci_get_drvdata(pcidev);\n\tstruct rtsx_pcr *pcr = handle->pcr;\n\n\tpcr->remove_pci = true;\n\n\tpm_runtime_get_sync(&pcidev->dev);\n\tpm_runtime_forbid(&pcidev->dev);\n\n\t \n\tspin_lock_irq(&pcr->lock);\n\trtsx_pci_writel(pcr, RTSX_BIER, 0);\n\tpcr->bier = 0;\n\tspin_unlock_irq(&pcr->lock);\n\n\tcancel_delayed_work_sync(&pcr->carddet_work);\n\n\tmfd_remove_devices(&pcidev->dev);\n\n\tdma_free_coherent(&(pcr->pci->dev), RTSX_RESV_BUF_LEN,\n\t\t\tpcr->rtsx_resv_buf, pcr->rtsx_resv_buf_addr);\n\tfree_irq(pcr->irq, (void *)pcr);\n\tif (pcr->msi_en)\n\t\tpci_disable_msi(pcr->pci);\n\tiounmap(pcr->remap_addr);\n\n\tpci_release_regions(pcidev);\n\tpci_disable_device(pcidev);\n\n\tspin_lock(&rtsx_pci_lock);\n\tidr_remove(&rtsx_pci_idr, pcr->id);\n\tspin_unlock(&rtsx_pci_lock);\n\n\tkfree(pcr->slots);\n\tkfree(pcr);\n\tkfree(handle);\n\n\tdev_dbg(&(pcidev->dev),\n\t\t\": Realtek PCI-E Card Reader at %s [%04x:%04x] has been removed\\n\",\n\t\tpci_name(pcidev), (int)pcidev->vendor, (int)pcidev->device);\n}\n\nstatic int __maybe_unused rtsx_pci_suspend(struct device *dev_d)\n{\n\tstruct pci_dev *pcidev = to_pci_dev(dev_d);\n\tstruct pcr_handle *handle = pci_get_drvdata(pcidev);\n\tstruct rtsx_pcr *pcr = handle->pcr;\n\n\tdev_dbg(&(pcidev->dev), \"--> %s\\n\", __func__);\n\n\tcancel_delayed_work_sync(&pcr->carddet_work);\n\n\tmutex_lock(&pcr->pcr_mutex);\n\n\trtsx_pci_power_off(pcr, HOST_ENTER_S3, false);\n\n\tmutex_unlock(&pcr->pcr_mutex);\n\treturn 0;\n}\n\nstatic int __maybe_unused rtsx_pci_resume(struct device *dev_d)\n{\n\tstruct pci_dev *pcidev = to_pci_dev(dev_d);\n\tstruct pcr_handle *handle = pci_get_drvdata(pcidev);\n\tstruct rtsx_pcr *pcr = handle->pcr;\n\tint ret = 0;\n\n\tdev_dbg(&(pcidev->dev), \"--> %s\\n\", __func__);\n\n\tmutex_lock(&pcr->pcr_mutex);\n\n\tret = rtsx_pci_write_register(pcr, HOST_SLEEP_STATE, 0x03, 0x00);\n\tif (ret)\n\t\tgoto out;\n\n\tret = rtsx_pci_init_hw(pcr);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tmutex_unlock(&pcr->pcr_mutex);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\n\nstatic void rtsx_enable_aspm(struct rtsx_pcr *pcr)\n{\n\tif (pcr->ops->set_aspm)\n\t\tpcr->ops->set_aspm(pcr, true);\n\telse\n\t\trtsx_comm_set_aspm(pcr, true);\n}\n\nstatic void rtsx_comm_pm_power_saving(struct rtsx_pcr *pcr)\n{\n\tstruct rtsx_cr_option *option = &pcr->option;\n\n\tif (option->ltr_enabled) {\n\t\tu32 latency = option->ltr_l1off_latency;\n\n\t\tif (rtsx_check_dev_flag(pcr, L1_SNOOZE_TEST_EN))\n\t\t\tmdelay(option->l1_snooze_delay);\n\n\t\trtsx_set_ltr_latency(pcr, latency);\n\t}\n\n\tif (rtsx_check_dev_flag(pcr, LTR_L1SS_PWR_GATE_EN))\n\t\trtsx_set_l1off_sub_cfg_d0(pcr, 0);\n\n\trtsx_enable_aspm(pcr);\n}\n\nstatic void rtsx_pm_power_saving(struct rtsx_pcr *pcr)\n{\n\trtsx_comm_pm_power_saving(pcr);\n}\n\nstatic void rtsx_pci_shutdown(struct pci_dev *pcidev)\n{\n\tstruct pcr_handle *handle = pci_get_drvdata(pcidev);\n\tstruct rtsx_pcr *pcr = handle->pcr;\n\n\tdev_dbg(&(pcidev->dev), \"--> %s\\n\", __func__);\n\n\trtsx_pci_power_off(pcr, HOST_ENTER_S1, false);\n\n\tpci_disable_device(pcidev);\n\tfree_irq(pcr->irq, (void *)pcr);\n\tif (pcr->msi_en)\n\t\tpci_disable_msi(pcr->pci);\n}\n\nstatic int rtsx_pci_runtime_idle(struct device *device)\n{\n\tstruct pci_dev *pcidev = to_pci_dev(device);\n\tstruct pcr_handle *handle = pci_get_drvdata(pcidev);\n\tstruct rtsx_pcr *pcr = handle->pcr;\n\n\tdev_dbg(device, \"--> %s\\n\", __func__);\n\n\tmutex_lock(&pcr->pcr_mutex);\n\n\tpcr->state = PDEV_STAT_IDLE;\n\n\tif (pcr->ops->disable_auto_blink)\n\t\tpcr->ops->disable_auto_blink(pcr);\n\tif (pcr->ops->turn_off_led)\n\t\tpcr->ops->turn_off_led(pcr);\n\n\trtsx_pm_power_saving(pcr);\n\n\tmutex_unlock(&pcr->pcr_mutex);\n\n\tif (pcr->rtd3_en)\n\t\tpm_schedule_suspend(device, 10000);\n\n\treturn -EBUSY;\n}\n\nstatic int rtsx_pci_runtime_suspend(struct device *device)\n{\n\tstruct pci_dev *pcidev = to_pci_dev(device);\n\tstruct pcr_handle *handle = pci_get_drvdata(pcidev);\n\tstruct rtsx_pcr *pcr = handle->pcr;\n\n\tdev_dbg(device, \"--> %s\\n\", __func__);\n\n\tcancel_delayed_work_sync(&pcr->carddet_work);\n\n\tmutex_lock(&pcr->pcr_mutex);\n\trtsx_pci_power_off(pcr, HOST_ENTER_S3, true);\n\n\tmutex_unlock(&pcr->pcr_mutex);\n\n\treturn 0;\n}\n\nstatic int rtsx_pci_runtime_resume(struct device *device)\n{\n\tstruct pci_dev *pcidev = to_pci_dev(device);\n\tstruct pcr_handle *handle = pci_get_drvdata(pcidev);\n\tstruct rtsx_pcr *pcr = handle->pcr;\n\n\tdev_dbg(device, \"--> %s\\n\", __func__);\n\n\tmutex_lock(&pcr->pcr_mutex);\n\n\trtsx_pci_write_register(pcr, HOST_SLEEP_STATE, 0x03, 0x00);\n\n\trtsx_pci_init_hw(pcr);\n\n\tif (pcr->slots[RTSX_SD_CARD].p_dev != NULL) {\n\t\tpcr->slots[RTSX_SD_CARD].card_event(\n\t\t\t\tpcr->slots[RTSX_SD_CARD].p_dev);\n\t}\n\n\tmutex_unlock(&pcr->pcr_mutex);\n\treturn 0;\n}\n\n#else  \n\n#define rtsx_pci_shutdown NULL\n#define rtsx_pci_runtime_suspend NULL\n#define rtsx_pic_runtime_resume NULL\n\n#endif  \n\nstatic const struct dev_pm_ops rtsx_pci_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rtsx_pci_suspend, rtsx_pci_resume)\n\tSET_RUNTIME_PM_OPS(rtsx_pci_runtime_suspend, rtsx_pci_runtime_resume, rtsx_pci_runtime_idle)\n};\n\nstatic struct pci_driver rtsx_pci_driver = {\n\t.name = DRV_NAME_RTSX_PCI,\n\t.id_table = rtsx_pci_ids,\n\t.probe = rtsx_pci_probe,\n\t.remove = rtsx_pci_remove,\n\t.driver.pm = &rtsx_pci_pm_ops,\n\t.shutdown = rtsx_pci_shutdown,\n};\nmodule_pci_driver(rtsx_pci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Wei WANG <wei_wang@realsil.com.cn>\");\nMODULE_DESCRIPTION(\"Realtek PCI-E Card Reader Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}