{
  "module_name": "cs5535-mfgpt.c",
  "hash_id": "ff4dbf82f1c0f9ddd92aa092547cf1cd593a1cb6f297f555c223bc7ae6241110",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/cs5535-mfgpt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/cs5535.h>\n#include <linux/slab.h>\n\n#define DRV_NAME \"cs5535-mfgpt\"\n\nstatic int mfgpt_reset_timers;\nmodule_param_named(mfgptfix, mfgpt_reset_timers, int, 0644);\nMODULE_PARM_DESC(mfgptfix, \"Try to reset the MFGPT timers during init; \"\n\t\t\"required by some broken BIOSes (ie, TinyBIOS < 0.99) or kexec \"\n\t\t\"(1 = reset the MFGPT using an undocumented bit, \"\n\t\t\"2 = perform a soft reset by unconfiguring all timers); \"\n\t\t\"use what works best for you.\");\n\nstruct cs5535_mfgpt_timer {\n\tstruct cs5535_mfgpt_chip *chip;\n\tint nr;\n};\n\nstatic struct cs5535_mfgpt_chip {\n\tDECLARE_BITMAP(avail, MFGPT_MAX_TIMERS);\n\tresource_size_t base;\n\n\tstruct platform_device *pdev;\n\tspinlock_t lock;\n\tint initialized;\n} cs5535_mfgpt_chip;\n\nint cs5535_mfgpt_toggle_event(struct cs5535_mfgpt_timer *timer, int cmp,\n\t\tint event, int enable)\n{\n\tuint32_t msr, mask, value, dummy;\n\tint shift = (cmp == MFGPT_CMP1) ? 0 : 8;\n\n\tif (!timer) {\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\t \n\tswitch (event) {\n\tcase MFGPT_EVENT_RESET:\n\t\t \n\t\tmsr = MSR_MFGPT_NR;\n\t\tmask = 1 << (timer->nr + 24);\n\t\tbreak;\n\n\tcase MFGPT_EVENT_NMI:\n\t\tmsr = MSR_MFGPT_NR;\n\t\tmask = 1 << (timer->nr + shift);\n\t\tbreak;\n\n\tcase MFGPT_EVENT_IRQ:\n\t\tmsr = MSR_MFGPT_IRQ;\n\t\tmask = 1 << (timer->nr + shift);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\trdmsr(msr, value, dummy);\n\n\tif (enable)\n\t\tvalue |= mask;\n\telse\n\t\tvalue &= ~mask;\n\n\twrmsr(msr, value, dummy);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cs5535_mfgpt_toggle_event);\n\nint cs5535_mfgpt_set_irq(struct cs5535_mfgpt_timer *timer, int cmp, int *irq,\n\t\tint enable)\n{\n\tuint32_t zsel, lpc, dummy;\n\tint shift;\n\n\tif (!timer) {\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\t \n\trdmsr(MSR_PIC_ZSEL_LOW, zsel, dummy);\n\tshift = ((cmp == MFGPT_CMP1 ? 0 : 4) + timer->nr % 4) * 4;\n\tif (((zsel >> shift) & 0xF) == 2)\n\t\treturn -EIO;\n\n\t \n\tif (!*irq)\n\t\t*irq = (zsel >> shift) & 0xF;\n\tif (!*irq)\n\t\t*irq = CONFIG_CS5535_MFGPT_DEFAULT_IRQ;\n\n\t \n\tif (*irq < 1 || *irq == 2 || *irq > 15)\n\t\treturn -EIO;\n\trdmsr(MSR_PIC_IRQM_LPC, lpc, dummy);\n\tif (lpc & (1 << *irq))\n\t\treturn -EIO;\n\n\t \n\tif (cs5535_mfgpt_toggle_event(timer, cmp, MFGPT_EVENT_IRQ, enable))\n\t\treturn -EIO;\n\tif (enable) {\n\t\tzsel = (zsel & ~(0xF << shift)) | (*irq << shift);\n\t\twrmsr(MSR_PIC_ZSEL_LOW, zsel, dummy);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cs5535_mfgpt_set_irq);\n\nstruct cs5535_mfgpt_timer *cs5535_mfgpt_alloc_timer(int timer_nr, int domain)\n{\n\tstruct cs5535_mfgpt_chip *mfgpt = &cs5535_mfgpt_chip;\n\tstruct cs5535_mfgpt_timer *timer = NULL;\n\tunsigned long flags;\n\tint max;\n\n\tif (!mfgpt->initialized)\n\t\tgoto done;\n\n\t \n\tif (domain == MFGPT_DOMAIN_WORKING)\n\t\tmax = 6;\n\telse\n\t\tmax = MFGPT_MAX_TIMERS;\n\n\tif (timer_nr >= max) {\n\t\t \n\t\tWARN_ON(1);\n\t\tgoto done;\n\t}\n\n\tspin_lock_irqsave(&mfgpt->lock, flags);\n\tif (timer_nr < 0) {\n\t\tunsigned long t;\n\n\t\t \n\t\tt = find_first_bit(mfgpt->avail, max);\n\t\t \n\t\ttimer_nr = t < max ? (int) t : -1;\n\t} else {\n\t\t \n\t\tif (!test_bit(timer_nr, mfgpt->avail))\n\t\t\ttimer_nr = -1;\n\t}\n\n\tif (timer_nr >= 0)\n\t\t \n\t\t__clear_bit(timer_nr, mfgpt->avail);\n\tspin_unlock_irqrestore(&mfgpt->lock, flags);\n\n\tif (timer_nr < 0)\n\t\tgoto done;\n\n\ttimer = kmalloc(sizeof(*timer), GFP_KERNEL);\n\tif (!timer) {\n\t\t \n\t\tspin_lock_irqsave(&mfgpt->lock, flags);\n\t\t__set_bit(timer_nr, mfgpt->avail);\n\t\tspin_unlock_irqrestore(&mfgpt->lock, flags);\n\t\tgoto done;\n\t}\n\ttimer->chip = mfgpt;\n\ttimer->nr = timer_nr;\n\tdev_info(&mfgpt->pdev->dev, \"registered timer %d\\n\", timer_nr);\n\ndone:\n\treturn timer;\n}\nEXPORT_SYMBOL_GPL(cs5535_mfgpt_alloc_timer);\n\n \nvoid cs5535_mfgpt_free_timer(struct cs5535_mfgpt_timer *timer)\n{\n\tunsigned long flags;\n\tuint16_t val;\n\n\t \n\tval = cs5535_mfgpt_read(timer, MFGPT_REG_SETUP);\n\tif (!(val & MFGPT_SETUP_SETUP)) {\n\t\tspin_lock_irqsave(&timer->chip->lock, flags);\n\t\t__set_bit(timer->nr, timer->chip->avail);\n\t\tspin_unlock_irqrestore(&timer->chip->lock, flags);\n\t}\n\n\tkfree(timer);\n}\nEXPORT_SYMBOL_GPL(cs5535_mfgpt_free_timer);\n\nuint16_t cs5535_mfgpt_read(struct cs5535_mfgpt_timer *timer, uint16_t reg)\n{\n\treturn inw(timer->chip->base + reg + (timer->nr * 8));\n}\nEXPORT_SYMBOL_GPL(cs5535_mfgpt_read);\n\nvoid cs5535_mfgpt_write(struct cs5535_mfgpt_timer *timer, uint16_t reg,\n\t\tuint16_t value)\n{\n\toutw(value, timer->chip->base + reg + (timer->nr * 8));\n}\nEXPORT_SYMBOL_GPL(cs5535_mfgpt_write);\n\n \nstatic void reset_all_timers(void)\n{\n\tuint32_t val, dummy;\n\n\t \n\tval = 0xFF; dummy = 0;\n\twrmsr(MSR_MFGPT_SETUP, val, dummy);\n}\n\n \nstatic void soft_reset(void)\n{\n\tint i;\n\tstruct cs5535_mfgpt_timer t;\n\n\tfor (i = 0; i < MFGPT_MAX_TIMERS; i++) {\n\t\tt.nr = i;\n\n\t\tcs5535_mfgpt_toggle_event(&t, MFGPT_CMP1, MFGPT_EVENT_RESET, 0);\n\t\tcs5535_mfgpt_toggle_event(&t, MFGPT_CMP2, MFGPT_EVENT_RESET, 0);\n\t\tcs5535_mfgpt_toggle_event(&t, MFGPT_CMP1, MFGPT_EVENT_NMI, 0);\n\t\tcs5535_mfgpt_toggle_event(&t, MFGPT_CMP2, MFGPT_EVENT_NMI, 0);\n\t\tcs5535_mfgpt_toggle_event(&t, MFGPT_CMP1, MFGPT_EVENT_IRQ, 0);\n\t\tcs5535_mfgpt_toggle_event(&t, MFGPT_CMP2, MFGPT_EVENT_IRQ, 0);\n\t}\n}\n\n \nstatic int scan_timers(struct cs5535_mfgpt_chip *mfgpt)\n{\n\tstruct cs5535_mfgpt_timer timer = { .chip = mfgpt };\n\tunsigned long flags;\n\tint timers = 0;\n\tuint16_t val;\n\tint i;\n\n\t \n\tif (mfgpt_reset_timers == 1)\n\t\treset_all_timers();\n\telse if (mfgpt_reset_timers == 2)\n\t\tsoft_reset();\n\n\t \n\tspin_lock_irqsave(&mfgpt->lock, flags);\n\tfor (i = 0; i < MFGPT_MAX_TIMERS; i++) {\n\t\ttimer.nr = i;\n\t\tval = cs5535_mfgpt_read(&timer, MFGPT_REG_SETUP);\n\t\tif (!(val & MFGPT_SETUP_SETUP) || mfgpt_reset_timers == 2) {\n\t\t\t__set_bit(i, mfgpt->avail);\n\t\t\ttimers++;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&mfgpt->lock, flags);\n\n\treturn timers;\n}\n\nstatic int cs5535_mfgpt_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tint err = -EIO, t;\n\n\tif (mfgpt_reset_timers < 0 || mfgpt_reset_timers > 2) {\n\t\tdev_err(&pdev->dev, \"Bad mfgpt_reset_timers value: %i\\n\",\n\t\t\tmfgpt_reset_timers);\n\t\tgoto done;\n\t}\n\n\t \n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"can't fetch device resource info\\n\");\n\t\tgoto done;\n\t}\n\n\tif (!request_region(res->start, resource_size(res), pdev->name)) {\n\t\tdev_err(&pdev->dev, \"can't request region\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tcs5535_mfgpt_chip.base = res->start;\n\tcs5535_mfgpt_chip.pdev = pdev;\n\tspin_lock_init(&cs5535_mfgpt_chip.lock);\n\n\tdev_info(&pdev->dev, \"reserved resource region %pR\\n\", res);\n\n\t \n\tt = scan_timers(&cs5535_mfgpt_chip);\n\tdev_info(&pdev->dev, \"%d MFGPT timers available\\n\", t);\n\tcs5535_mfgpt_chip.initialized = 1;\n\treturn 0;\n\ndone:\n\treturn err;\n}\n\nstatic struct platform_driver cs5535_mfgpt_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.probe = cs5535_mfgpt_probe,\n};\n\n\nstatic int __init cs5535_mfgpt_init(void)\n{\n\treturn platform_driver_register(&cs5535_mfgpt_driver);\n}\n\nmodule_init(cs5535_mfgpt_init);\n\nMODULE_AUTHOR(\"Andres Salomon <dilinger@queued.net>\");\nMODULE_DESCRIPTION(\"CS5535/CS5536 MFGPT timer driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}