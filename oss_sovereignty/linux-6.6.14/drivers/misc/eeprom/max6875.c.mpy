{
  "module_name": "max6875.c",
  "hash_id": "b9ba7be274d9a4d1f88a3e9c3f3cdc960d85da09d8d1fa649f5b36d3c65236fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/eeprom/max6875.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n\n \n#define SLICE_SIZE\t\t\t16\n#define SLICE_BITS\t\t\t4\n\n \n#define USER_EEPROM_BASE\t\t0x8100\n#define USER_EEPROM_SIZE\t\t0x0200\n#define USER_EEPROM_SLICES\t\t32\n\n \n#define MAX6875_CMD_BLK_READ\t\t0x84\n\n \nstruct max6875_data {\n\tstruct i2c_client\t*fake_client;\n\tstruct mutex\t\tupdate_lock;\n\n\tu32\t\t\tvalid;\n\tu8\t\t\tdata[USER_EEPROM_SIZE];\n\tunsigned long\t\tlast_updated[USER_EEPROM_SLICES];\n};\n\nstatic void max6875_update_slice(struct i2c_client *client, int slice)\n{\n\tstruct max6875_data *data = i2c_get_clientdata(client);\n\tint i, j, addr;\n\tu8 *buf;\n\n\tif (slice >= USER_EEPROM_SLICES)\n\t\treturn;\n\n\tmutex_lock(&data->update_lock);\n\n\tbuf = &data->data[slice << SLICE_BITS];\n\n\tif (!(data->valid & (1 << slice)) ||\n\t    time_after(jiffies, data->last_updated[slice])) {\n\n\t\tdev_dbg(&client->dev, \"Starting update of slice %u\\n\", slice);\n\n\t\tdata->valid &= ~(1 << slice);\n\n\t\taddr = USER_EEPROM_BASE + (slice << SLICE_BITS);\n\n\t\t \n\t\tif (i2c_smbus_write_byte_data(client, addr >> 8, addr & 0xFF)) {\n\t\t\tdev_err(&client->dev, \"address set failed\\n\");\n\t\t\tgoto exit_up;\n\t\t}\n\n\t\tif (i2c_check_functionality(client->adapter,\n\t\t\t\t\t    I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {\n\t\t\tif (i2c_smbus_read_i2c_block_data(client,\n\t\t\t\t\t\t\t  MAX6875_CMD_BLK_READ,\n\t\t\t\t\t\t\t  SLICE_SIZE,\n\t\t\t\t\t\t\t  buf) != SLICE_SIZE) {\n\t\t\t\tgoto exit_up;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < SLICE_SIZE; i++) {\n\t\t\t\tj = i2c_smbus_read_byte(client);\n\t\t\t\tif (j < 0) {\n\t\t\t\t\tgoto exit_up;\n\t\t\t\t}\n\t\t\t\tbuf[i] = j;\n\t\t\t}\n\t\t}\n\t\tdata->last_updated[slice] = jiffies;\n\t\tdata->valid |= (1 << slice);\n\t}\nexit_up:\n\tmutex_unlock(&data->update_lock);\n}\n\nstatic ssize_t max6875_read(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *bin_attr,\n\t\t\t    char *buf, loff_t off, size_t count)\n{\n\tstruct i2c_client *client = kobj_to_i2c_client(kobj);\n\tstruct max6875_data *data = i2c_get_clientdata(client);\n\tint slice, max_slice;\n\n\t \n\tmax_slice = (off + count - 1) >> SLICE_BITS;\n\tfor (slice = (off >> SLICE_BITS); slice <= max_slice; slice++)\n\t\tmax6875_update_slice(client, slice);\n\n\tmemcpy(buf, &data->data[off], count);\n\n\treturn count;\n}\n\nstatic const struct bin_attribute user_eeprom_attr = {\n\t.attr = {\n\t\t.name = \"eeprom\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.size = USER_EEPROM_SIZE,\n\t.read = max6875_read,\n};\n\nstatic int max6875_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct max6875_data *data;\n\tint err;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_READ_BYTE))\n\t\treturn -ENODEV;\n\n\t \n\tif (client->addr & 1)\n\t\treturn -ENODEV;\n\n\tdata = kzalloc(sizeof(struct max6875_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tdata->fake_client = i2c_new_dummy_device(client->adapter, client->addr + 1);\n\tif (IS_ERR(data->fake_client)) {\n\t\terr = PTR_ERR(data->fake_client);\n\t\tgoto exit_kfree;\n\t}\n\n\t \n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\n\terr = sysfs_create_bin_file(&client->dev.kobj, &user_eeprom_attr);\n\tif (err)\n\t\tgoto exit_remove_fake;\n\n\treturn 0;\n\nexit_remove_fake:\n\ti2c_unregister_device(data->fake_client);\nexit_kfree:\n\tkfree(data);\n\treturn err;\n}\n\nstatic void max6875_remove(struct i2c_client *client)\n{\n\tstruct max6875_data *data = i2c_get_clientdata(client);\n\n\ti2c_unregister_device(data->fake_client);\n\n\tsysfs_remove_bin_file(&client->dev.kobj, &user_eeprom_attr);\n\tkfree(data);\n}\n\nstatic const struct i2c_device_id max6875_id[] = {\n\t{ \"max6875\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max6875_id);\n\nstatic struct i2c_driver max6875_driver = {\n\t.driver = {\n\t\t.name\t= \"max6875\",\n\t},\n\t.probe\t\t= max6875_probe,\n\t.remove\t\t= max6875_remove,\n\t.id_table\t= max6875_id,\n};\n\nmodule_i2c_driver(max6875_driver);\n\nMODULE_AUTHOR(\"Ben Gardner <bgardner@wabtec.com>\");\nMODULE_DESCRIPTION(\"MAX6875 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}