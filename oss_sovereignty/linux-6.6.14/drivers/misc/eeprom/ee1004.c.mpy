{
  "module_name": "ee1004.c",
  "hash_id": "37947b5f9c7fca62231b05ba26c7b48fc46c93efc33d31dcd86c3cd6e62289a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/eeprom/ee1004.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n \n\n#define EE1004_ADDR_SET_PAGE\t\t0x36\n#define EE1004_NUM_PAGES\t\t2\n#define EE1004_PAGE_SIZE\t\t256\n#define EE1004_PAGE_SHIFT\t\t8\n#define EE1004_EEPROM_SIZE\t\t(EE1004_PAGE_SIZE * EE1004_NUM_PAGES)\n\n \nstatic DEFINE_MUTEX(ee1004_bus_lock);\nstatic struct i2c_client *ee1004_set_page[EE1004_NUM_PAGES];\nstatic unsigned int ee1004_dev_count;\nstatic int ee1004_current_page;\n\nstatic const struct i2c_device_id ee1004_ids[] = {\n\t{ \"ee1004\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ee1004_ids);\n\n \n\nstatic int ee1004_get_current_page(void)\n{\n\tint err;\n\n\terr = i2c_smbus_read_byte(ee1004_set_page[0]);\n\tif (err == -ENXIO) {\n\t\t \n\t\treturn 1;\n\t}\n\tif (err < 0) {\n\t\t \n\t\treturn err;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int ee1004_set_current_page(struct device *dev, int page)\n{\n\tint ret;\n\n\tif (page == ee1004_current_page)\n\t\treturn 0;\n\n\t \n\tret = i2c_smbus_write_byte(ee1004_set_page[page], 0x00);\n\t \n\tif (ret == -ENXIO && ee1004_get_current_page() == page)\n\t\tret = 0;\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to select page %d (%d)\\n\", page, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"Selected page %d\\n\", page);\n\tee1004_current_page = page;\n\n\treturn 0;\n}\n\nstatic ssize_t ee1004_eeprom_read(struct i2c_client *client, char *buf,\n\t\t\t\t  unsigned int offset, size_t count)\n{\n\tint status, page;\n\n\tpage = offset >> EE1004_PAGE_SHIFT;\n\toffset &= (1 << EE1004_PAGE_SHIFT) - 1;\n\n\tstatus = ee1004_set_current_page(&client->dev, page);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (offset + count > EE1004_PAGE_SIZE)\n\t\tcount = EE1004_PAGE_SIZE - offset;\n\n\tif (count > I2C_SMBUS_BLOCK_MAX)\n\t\tcount = I2C_SMBUS_BLOCK_MAX;\n\n\treturn i2c_smbus_read_i2c_block_data_or_emulated(client, offset, count, buf);\n}\n\nstatic ssize_t eeprom_read(struct file *filp, struct kobject *kobj,\n\t\t\t   struct bin_attribute *bin_attr,\n\t\t\t   char *buf, loff_t off, size_t count)\n{\n\tstruct i2c_client *client = kobj_to_i2c_client(kobj);\n\tsize_t requested = count;\n\tint ret = 0;\n\n\t \n\tmutex_lock(&ee1004_bus_lock);\n\n\twhile (count) {\n\t\tret = ee1004_eeprom_read(client, buf, off, count);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tbuf += ret;\n\t\toff += ret;\n\t\tcount -= ret;\n\t}\nout:\n\tmutex_unlock(&ee1004_bus_lock);\n\n\treturn ret < 0 ? ret : requested;\n}\n\nstatic BIN_ATTR_RO(eeprom, EE1004_EEPROM_SIZE);\n\nstatic struct bin_attribute *ee1004_attrs[] = {\n\t&bin_attr_eeprom,\n\tNULL\n};\n\nBIN_ATTRIBUTE_GROUPS(ee1004);\n\nstatic void ee1004_cleanup(int idx)\n{\n\tif (--ee1004_dev_count == 0)\n\t\twhile (--idx >= 0) {\n\t\t\ti2c_unregister_device(ee1004_set_page[idx]);\n\t\t\tee1004_set_page[idx] = NULL;\n\t\t}\n}\n\nstatic int ee1004_probe(struct i2c_client *client)\n{\n\tint err, cnr = 0;\n\n\t \n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_READ_I2C_BLOCK) &&\n\t    !i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_READ_BYTE_DATA))\n\t\treturn -EPFNOSUPPORT;\n\n\t \n\tmutex_lock(&ee1004_bus_lock);\n\tif (++ee1004_dev_count == 1) {\n\t\tfor (cnr = 0; cnr < EE1004_NUM_PAGES; cnr++) {\n\t\t\tstruct i2c_client *cl;\n\n\t\t\tcl = i2c_new_dummy_device(client->adapter, EE1004_ADDR_SET_PAGE + cnr);\n\t\t\tif (IS_ERR(cl)) {\n\t\t\t\terr = PTR_ERR(cl);\n\t\t\t\tgoto err_clients;\n\t\t\t}\n\t\t\tee1004_set_page[cnr] = cl;\n\t\t}\n\n\t\t \n\t\terr = ee1004_get_current_page();\n\t\tif (err < 0)\n\t\t\tgoto err_clients;\n\t\tdev_dbg(&client->dev, \"Currently selected page: %d\\n\", err);\n\t\tee1004_current_page = err;\n\t} else if (client->adapter != ee1004_set_page[0]->adapter) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Driver only supports devices on a single I2C bus\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_clients;\n\t}\n\tmutex_unlock(&ee1004_bus_lock);\n\n\tdev_info(&client->dev,\n\t\t \"%u byte EE1004-compliant SPD EEPROM, read-only\\n\",\n\t\t EE1004_EEPROM_SIZE);\n\n\treturn 0;\n\n err_clients:\n\tee1004_cleanup(cnr);\n\tmutex_unlock(&ee1004_bus_lock);\n\n\treturn err;\n}\n\nstatic void ee1004_remove(struct i2c_client *client)\n{\n\t \n\tmutex_lock(&ee1004_bus_lock);\n\tee1004_cleanup(EE1004_NUM_PAGES);\n\tmutex_unlock(&ee1004_bus_lock);\n}\n\n \n\nstatic struct i2c_driver ee1004_driver = {\n\t.driver = {\n\t\t.name = \"ee1004\",\n\t\t.dev_groups = ee1004_groups,\n\t},\n\t.probe = ee1004_probe,\n\t.remove = ee1004_remove,\n\t.id_table = ee1004_ids,\n};\nmodule_i2c_driver(ee1004_driver);\n\nMODULE_DESCRIPTION(\"Driver for EE1004-compliant DDR4 SPD EEPROMs\");\nMODULE_AUTHOR(\"Jean Delvare\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}