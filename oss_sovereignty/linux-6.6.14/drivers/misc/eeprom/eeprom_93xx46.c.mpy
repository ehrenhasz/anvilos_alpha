{
  "module_name": "eeprom_93xx46.c",
  "hash_id": "697cf369994e1c121f9f4f7d796a5d67b4758da18f05939fb98c3d64e4b445b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/eeprom/eeprom_93xx46.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/nvmem-provider.h>\n#include <linux/eeprom_93xx46.h>\n\n#define OP_START\t0x4\n#define OP_WRITE\t(OP_START | 0x1)\n#define OP_READ\t\t(OP_START | 0x2)\n#define ADDR_EWDS\t0x00\n#define ADDR_ERAL\t0x20\n#define ADDR_EWEN\t0x30\n\nstruct eeprom_93xx46_devtype_data {\n\tunsigned int quirks;\n\tunsigned char flags;\n};\n\nstatic const struct eeprom_93xx46_devtype_data at93c46_data = {\n\t.flags = EE_SIZE1K,\n};\n\nstatic const struct eeprom_93xx46_devtype_data at93c56_data = {\n\t.flags = EE_SIZE2K,\n};\n\nstatic const struct eeprom_93xx46_devtype_data at93c66_data = {\n\t.flags = EE_SIZE4K,\n};\n\nstatic const struct eeprom_93xx46_devtype_data atmel_at93c46d_data = {\n\t.flags = EE_SIZE1K,\n\t.quirks = EEPROM_93XX46_QUIRK_SINGLE_WORD_READ |\n\t\t  EEPROM_93XX46_QUIRK_INSTRUCTION_LENGTH,\n};\n\nstatic const struct eeprom_93xx46_devtype_data microchip_93lc46b_data = {\n\t.flags = EE_SIZE1K,\n\t.quirks = EEPROM_93XX46_QUIRK_EXTRA_READ_CYCLE,\n};\n\nstruct eeprom_93xx46_dev {\n\tstruct spi_device *spi;\n\tstruct eeprom_93xx46_platform_data *pdata;\n\tstruct mutex lock;\n\tstruct nvmem_config nvmem_config;\n\tstruct nvmem_device *nvmem;\n\tint addrlen;\n\tint size;\n};\n\nstatic inline bool has_quirk_single_word_read(struct eeprom_93xx46_dev *edev)\n{\n\treturn edev->pdata->quirks & EEPROM_93XX46_QUIRK_SINGLE_WORD_READ;\n}\n\nstatic inline bool has_quirk_instruction_length(struct eeprom_93xx46_dev *edev)\n{\n\treturn edev->pdata->quirks & EEPROM_93XX46_QUIRK_INSTRUCTION_LENGTH;\n}\n\nstatic inline bool has_quirk_extra_read_cycle(struct eeprom_93xx46_dev *edev)\n{\n\treturn edev->pdata->quirks & EEPROM_93XX46_QUIRK_EXTRA_READ_CYCLE;\n}\n\nstatic int eeprom_93xx46_read(void *priv, unsigned int off,\n\t\t\t      void *val, size_t count)\n{\n\tstruct eeprom_93xx46_dev *edev = priv;\n\tchar *buf = val;\n\tint err = 0;\n\tint bits;\n\n\tif (unlikely(off >= edev->size))\n\t\treturn 0;\n\tif ((off + count) > edev->size)\n\t\tcount = edev->size - off;\n\tif (unlikely(!count))\n\t\treturn count;\n\n\tmutex_lock(&edev->lock);\n\n\tif (edev->pdata->prepare)\n\t\tedev->pdata->prepare(edev);\n\n\t \n\tbits = edev->addrlen + 3;\n\n\twhile (count) {\n\t\tstruct spi_message m;\n\t\tstruct spi_transfer t[2] = { { 0 } };\n\t\tu16 cmd_addr = OP_READ << edev->addrlen;\n\t\tsize_t nbytes = count;\n\n\t\tif (edev->pdata->flags & EE_ADDR8) {\n\t\t\tcmd_addr |= off;\n\t\t\tif (has_quirk_single_word_read(edev))\n\t\t\t\tnbytes = 1;\n\t\t} else {\n\t\t\tcmd_addr |= (off >> 1);\n\t\t\tif (has_quirk_single_word_read(edev))\n\t\t\t\tnbytes = 2;\n\t\t}\n\n\t\tdev_dbg(&edev->spi->dev, \"read cmd 0x%x, %d Hz\\n\",\n\t\t\tcmd_addr, edev->spi->max_speed_hz);\n\n\t\tif (has_quirk_extra_read_cycle(edev)) {\n\t\t\tcmd_addr <<= 1;\n\t\t\tbits += 1;\n\t\t}\n\n\t\tspi_message_init(&m);\n\n\t\tt[0].tx_buf = (char *)&cmd_addr;\n\t\tt[0].len = 2;\n\t\tt[0].bits_per_word = bits;\n\t\tspi_message_add_tail(&t[0], &m);\n\n\t\tt[1].rx_buf = buf;\n\t\tt[1].len = count;\n\t\tt[1].bits_per_word = 8;\n\t\tspi_message_add_tail(&t[1], &m);\n\n\t\terr = spi_sync(edev->spi, &m);\n\t\t \n\t\tndelay(250);\n\n\t\tif (err) {\n\t\t\tdev_err(&edev->spi->dev, \"read %zu bytes at %d: err. %d\\n\",\n\t\t\t\tnbytes, (int)off, err);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += nbytes;\n\t\toff += nbytes;\n\t\tcount -= nbytes;\n\t}\n\n\tif (edev->pdata->finish)\n\t\tedev->pdata->finish(edev);\n\n\tmutex_unlock(&edev->lock);\n\n\treturn err;\n}\n\nstatic int eeprom_93xx46_ew(struct eeprom_93xx46_dev *edev, int is_on)\n{\n\tstruct spi_message m;\n\tstruct spi_transfer t;\n\tint bits, ret;\n\tu16 cmd_addr;\n\n\t \n\tbits = edev->addrlen + 3;\n\n\tcmd_addr = OP_START << edev->addrlen;\n\tif (edev->pdata->flags & EE_ADDR8)\n\t\tcmd_addr |= (is_on ? ADDR_EWEN : ADDR_EWDS) << 1;\n\telse\n\t\tcmd_addr |= (is_on ? ADDR_EWEN : ADDR_EWDS);\n\n\tif (has_quirk_instruction_length(edev)) {\n\t\tcmd_addr <<= 2;\n\t\tbits += 2;\n\t}\n\n\tdev_dbg(&edev->spi->dev, \"ew%s cmd 0x%04x, %d bits\\n\",\n\t\t\tis_on ? \"en\" : \"ds\", cmd_addr, bits);\n\n\tspi_message_init(&m);\n\tmemset(&t, 0, sizeof(t));\n\n\tt.tx_buf = &cmd_addr;\n\tt.len = 2;\n\tt.bits_per_word = bits;\n\tspi_message_add_tail(&t, &m);\n\n\tmutex_lock(&edev->lock);\n\n\tif (edev->pdata->prepare)\n\t\tedev->pdata->prepare(edev);\n\n\tret = spi_sync(edev->spi, &m);\n\t \n\tndelay(250);\n\tif (ret)\n\t\tdev_err(&edev->spi->dev, \"erase/write %sable error %d\\n\",\n\t\t\tis_on ? \"en\" : \"dis\", ret);\n\n\tif (edev->pdata->finish)\n\t\tedev->pdata->finish(edev);\n\n\tmutex_unlock(&edev->lock);\n\treturn ret;\n}\n\nstatic ssize_t\neeprom_93xx46_write_word(struct eeprom_93xx46_dev *edev,\n\t\t\t const char *buf, unsigned off)\n{\n\tstruct spi_message m;\n\tstruct spi_transfer t[2];\n\tint bits, data_len, ret;\n\tu16 cmd_addr;\n\n\tif (unlikely(off >= edev->size))\n\t\treturn -EINVAL;\n\n\t \n\tbits = edev->addrlen + 3;\n\n\tcmd_addr = OP_WRITE << edev->addrlen;\n\n\tif (edev->pdata->flags & EE_ADDR8) {\n\t\tcmd_addr |= off;\n\t\tdata_len = 1;\n\t} else {\n\t\tcmd_addr |= (off >> 1);\n\t\tdata_len = 2;\n\t}\n\n\tdev_dbg(&edev->spi->dev, \"write cmd 0x%x\\n\", cmd_addr);\n\n\tspi_message_init(&m);\n\tmemset(t, 0, sizeof(t));\n\n\tt[0].tx_buf = (char *)&cmd_addr;\n\tt[0].len = 2;\n\tt[0].bits_per_word = bits;\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].tx_buf = buf;\n\tt[1].len = data_len;\n\tt[1].bits_per_word = 8;\n\tspi_message_add_tail(&t[1], &m);\n\n\tret = spi_sync(edev->spi, &m);\n\t \n\tmdelay(6);\n\treturn ret;\n}\n\nstatic int eeprom_93xx46_write(void *priv, unsigned int off,\n\t\t\t\t   void *val, size_t count)\n{\n\tstruct eeprom_93xx46_dev *edev = priv;\n\tchar *buf = val;\n\tint i, ret, step = 1;\n\n\tif (unlikely(off >= edev->size))\n\t\treturn -EFBIG;\n\tif ((off + count) > edev->size)\n\t\tcount = edev->size - off;\n\tif (unlikely(!count))\n\t\treturn count;\n\n\t \n\tif (edev->pdata->flags & EE_ADDR16) {\n\t\tstep = 2;\n\t\tcount &= ~1;\n\t}\n\n\t \n\tret = eeprom_93xx46_ew(edev, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&edev->lock);\n\n\tif (edev->pdata->prepare)\n\t\tedev->pdata->prepare(edev);\n\n\tfor (i = 0; i < count; i += step) {\n\t\tret = eeprom_93xx46_write_word(edev, &buf[i], off + i);\n\t\tif (ret) {\n\t\t\tdev_err(&edev->spi->dev, \"write failed at %d: %d\\n\",\n\t\t\t\t(int)off + i, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (edev->pdata->finish)\n\t\tedev->pdata->finish(edev);\n\n\tmutex_unlock(&edev->lock);\n\n\t \n\teeprom_93xx46_ew(edev, 0);\n\treturn ret;\n}\n\nstatic int eeprom_93xx46_eral(struct eeprom_93xx46_dev *edev)\n{\n\tstruct eeprom_93xx46_platform_data *pd = edev->pdata;\n\tstruct spi_message m;\n\tstruct spi_transfer t;\n\tint bits, ret;\n\tu16 cmd_addr;\n\n\t \n\tbits = edev->addrlen + 3;\n\n\tcmd_addr = OP_START << edev->addrlen;\n\tif (edev->pdata->flags & EE_ADDR8)\n\t\tcmd_addr |= ADDR_ERAL << 1;\n\telse\n\t\tcmd_addr |= ADDR_ERAL;\n\n\tif (has_quirk_instruction_length(edev)) {\n\t\tcmd_addr <<= 2;\n\t\tbits += 2;\n\t}\n\n\tdev_dbg(&edev->spi->dev, \"eral cmd 0x%04x, %d bits\\n\", cmd_addr, bits);\n\n\tspi_message_init(&m);\n\tmemset(&t, 0, sizeof(t));\n\n\tt.tx_buf = &cmd_addr;\n\tt.len = 2;\n\tt.bits_per_word = bits;\n\tspi_message_add_tail(&t, &m);\n\n\tmutex_lock(&edev->lock);\n\n\tif (edev->pdata->prepare)\n\t\tedev->pdata->prepare(edev);\n\n\tret = spi_sync(edev->spi, &m);\n\tif (ret)\n\t\tdev_err(&edev->spi->dev, \"erase error %d\\n\", ret);\n\t \n\tmdelay(6);\n\n\tif (pd->finish)\n\t\tpd->finish(edev);\n\n\tmutex_unlock(&edev->lock);\n\treturn ret;\n}\n\nstatic ssize_t eeprom_93xx46_store_erase(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct eeprom_93xx46_dev *edev = dev_get_drvdata(dev);\n\tint erase = 0, ret;\n\n\tsscanf(buf, \"%d\", &erase);\n\tif (erase) {\n\t\tret = eeprom_93xx46_ew(edev, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = eeprom_93xx46_eral(edev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = eeprom_93xx46_ew(edev, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn count;\n}\nstatic DEVICE_ATTR(erase, S_IWUSR, NULL, eeprom_93xx46_store_erase);\n\nstatic void select_assert(void *context)\n{\n\tstruct eeprom_93xx46_dev *edev = context;\n\n\tgpiod_set_value_cansleep(edev->pdata->select, 1);\n}\n\nstatic void select_deassert(void *context)\n{\n\tstruct eeprom_93xx46_dev *edev = context;\n\n\tgpiod_set_value_cansleep(edev->pdata->select, 0);\n}\n\nstatic const struct of_device_id eeprom_93xx46_of_table[] = {\n\t{ .compatible = \"eeprom-93xx46\", .data = &at93c46_data, },\n\t{ .compatible = \"atmel,at93c46\", .data = &at93c46_data, },\n\t{ .compatible = \"atmel,at93c46d\", .data = &atmel_at93c46d_data, },\n\t{ .compatible = \"atmel,at93c56\", .data = &at93c56_data, },\n\t{ .compatible = \"atmel,at93c66\", .data = &at93c66_data, },\n\t{ .compatible = \"microchip,93lc46b\", .data = &microchip_93lc46b_data, },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, eeprom_93xx46_of_table);\n\nstatic const struct spi_device_id eeprom_93xx46_spi_ids[] = {\n\t{ .name = \"eeprom-93xx46\",\n\t  .driver_data = (kernel_ulong_t)&at93c46_data, },\n\t{ .name = \"at93c46\",\n\t  .driver_data = (kernel_ulong_t)&at93c46_data, },\n\t{ .name = \"at93c46d\",\n\t  .driver_data = (kernel_ulong_t)&atmel_at93c46d_data, },\n\t{ .name = \"at93c56\",\n\t  .driver_data = (kernel_ulong_t)&at93c56_data, },\n\t{ .name = \"at93c66\",\n\t  .driver_data = (kernel_ulong_t)&at93c66_data, },\n\t{ .name = \"93lc46b\",\n\t  .driver_data = (kernel_ulong_t)&microchip_93lc46b_data, },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, eeprom_93xx46_spi_ids);\n\nstatic int eeprom_93xx46_probe_dt(struct spi_device *spi)\n{\n\tconst struct of_device_id *of_id =\n\t\tof_match_device(eeprom_93xx46_of_table, &spi->dev);\n\tstruct device_node *np = spi->dev.of_node;\n\tstruct eeprom_93xx46_platform_data *pd;\n\tu32 tmp;\n\tint ret;\n\n\tpd = devm_kzalloc(&spi->dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(np, \"data-size\", &tmp);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"data-size property not found\\n\");\n\t\treturn ret;\n\t}\n\n\tif (tmp == 8) {\n\t\tpd->flags |= EE_ADDR8;\n\t} else if (tmp == 16) {\n\t\tpd->flags |= EE_ADDR16;\n\t} else {\n\t\tdev_err(&spi->dev, \"invalid data-size (%d)\\n\", tmp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_bool(np, \"read-only\"))\n\t\tpd->flags |= EE_READONLY;\n\n\tpd->select = devm_gpiod_get_optional(&spi->dev, \"select\",\n\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(pd->select))\n\t\treturn PTR_ERR(pd->select);\n\n\tpd->prepare = select_assert;\n\tpd->finish = select_deassert;\n\tgpiod_direction_output(pd->select, 0);\n\n\tif (of_id->data) {\n\t\tconst struct eeprom_93xx46_devtype_data *data = of_id->data;\n\n\t\tpd->quirks = data->quirks;\n\t\tpd->flags |= data->flags;\n\t}\n\n\tspi->dev.platform_data = pd;\n\n\treturn 0;\n}\n\nstatic int eeprom_93xx46_probe(struct spi_device *spi)\n{\n\tstruct eeprom_93xx46_platform_data *pd;\n\tstruct eeprom_93xx46_dev *edev;\n\tint err;\n\n\tif (spi->dev.of_node) {\n\t\terr = eeprom_93xx46_probe_dt(spi);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tpd = spi->dev.platform_data;\n\tif (!pd) {\n\t\tdev_err(&spi->dev, \"missing platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tedev = devm_kzalloc(&spi->dev, sizeof(*edev), GFP_KERNEL);\n\tif (!edev)\n\t\treturn -ENOMEM;\n\n\tif (pd->flags & EE_SIZE1K)\n\t\tedev->size = 128;\n\telse if (pd->flags & EE_SIZE2K)\n\t\tedev->size = 256;\n\telse if (pd->flags & EE_SIZE4K)\n\t\tedev->size = 512;\n\telse {\n\t\tdev_err(&spi->dev, \"unspecified size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pd->flags & EE_ADDR8)\n\t\tedev->addrlen = ilog2(edev->size);\n\telse if (pd->flags & EE_ADDR16)\n\t\tedev->addrlen = ilog2(edev->size) - 1;\n\telse {\n\t\tdev_err(&spi->dev, \"unspecified address type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&edev->lock);\n\n\tedev->spi = spi;\n\tedev->pdata = pd;\n\n\tedev->nvmem_config.type = NVMEM_TYPE_EEPROM;\n\tedev->nvmem_config.name = dev_name(&spi->dev);\n\tedev->nvmem_config.dev = &spi->dev;\n\tedev->nvmem_config.read_only = pd->flags & EE_READONLY;\n\tedev->nvmem_config.root_only = true;\n\tedev->nvmem_config.owner = THIS_MODULE;\n\tedev->nvmem_config.compat = true;\n\tedev->nvmem_config.base_dev = &spi->dev;\n\tedev->nvmem_config.reg_read = eeprom_93xx46_read;\n\tedev->nvmem_config.reg_write = eeprom_93xx46_write;\n\tedev->nvmem_config.priv = edev;\n\tedev->nvmem_config.stride = 4;\n\tedev->nvmem_config.word_size = 1;\n\tedev->nvmem_config.size = edev->size;\n\n\tedev->nvmem = devm_nvmem_register(&spi->dev, &edev->nvmem_config);\n\tif (IS_ERR(edev->nvmem))\n\t\treturn PTR_ERR(edev->nvmem);\n\n\tdev_info(&spi->dev, \"%d-bit eeprom containing %d bytes %s\\n\",\n\t\t(pd->flags & EE_ADDR8) ? 8 : 16,\n\t\tedev->size,\n\t\t(pd->flags & EE_READONLY) ? \"(readonly)\" : \"\");\n\n\tif (!(pd->flags & EE_READONLY)) {\n\t\tif (device_create_file(&spi->dev, &dev_attr_erase))\n\t\t\tdev_err(&spi->dev, \"can't create erase interface\\n\");\n\t}\n\n\tspi_set_drvdata(spi, edev);\n\treturn 0;\n}\n\nstatic void eeprom_93xx46_remove(struct spi_device *spi)\n{\n\tstruct eeprom_93xx46_dev *edev = spi_get_drvdata(spi);\n\n\tif (!(edev->pdata->flags & EE_READONLY))\n\t\tdevice_remove_file(&spi->dev, &dev_attr_erase);\n}\n\nstatic struct spi_driver eeprom_93xx46_driver = {\n\t.driver = {\n\t\t.name\t= \"93xx46\",\n\t\t.of_match_table = of_match_ptr(eeprom_93xx46_of_table),\n\t},\n\t.probe\t\t= eeprom_93xx46_probe,\n\t.remove\t\t= eeprom_93xx46_remove,\n\t.id_table\t= eeprom_93xx46_spi_ids,\n};\n\nmodule_spi_driver(eeprom_93xx46_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Driver for 93xx46 EEPROMs\");\nMODULE_AUTHOR(\"Anatolij Gustschin <agust@denx.de>\");\nMODULE_ALIAS(\"spi:93xx46\");\nMODULE_ALIAS(\"spi:eeprom-93xx46\");\nMODULE_ALIAS(\"spi:93lc46b\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}