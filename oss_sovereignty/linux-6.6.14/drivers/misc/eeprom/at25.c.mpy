{
  "module_name": "at25.c",
  "hash_id": "0f421a012f2c43245cff780f180097a13d8fb65768c5f8a0847c3aacc20f681a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/eeprom/at25.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <linux/spi/eeprom.h>\n#include <linux/spi/spi.h>\n\n#include <linux/nvmem-provider.h>\n\n \n\n#define\tFM25_SN_LEN\t8\t\t \n#define EE_MAXADDRLEN\t3\t\t \n\nstruct at25_data {\n\tstruct spi_eeprom\tchip;\n\tstruct spi_device\t*spi;\n\tstruct mutex\t\tlock;\n\tunsigned\t\taddrlen;\n\tstruct nvmem_config\tnvmem_config;\n\tstruct nvmem_device\t*nvmem;\n\tu8 sernum[FM25_SN_LEN];\n\tu8 command[EE_MAXADDRLEN + 1];\n};\n\n#define\tAT25_WREN\t0x06\t\t \n#define\tAT25_WRDI\t0x04\t\t \n#define\tAT25_RDSR\t0x05\t\t \n#define\tAT25_WRSR\t0x01\t\t \n#define\tAT25_READ\t0x03\t\t \n#define\tAT25_WRITE\t0x02\t\t \n#define\tFM25_SLEEP\t0xb9\t\t \n#define\tFM25_RDID\t0x9f\t\t \n#define\tFM25_RDSN\t0xc3\t\t \n\n#define\tAT25_SR_nRDY\t0x01\t\t \n#define\tAT25_SR_WEN\t0x02\t\t \n#define\tAT25_SR_BP0\t0x04\t\t \n#define\tAT25_SR_BP1\t0x08\n#define\tAT25_SR_WPEN\t0x80\t\t \n\n#define\tAT25_INSTR_BIT3\t0x08\t\t \n\n#define\tFM25_ID_LEN\t9\t\t \n\n \n#define\tEE_TIMEOUT\t25\n\n \n\n#define\tio_limit\tPAGE_SIZE\t \n\nstatic int at25_ee_read(void *priv, unsigned int offset,\n\t\t\tvoid *val, size_t count)\n{\n\tstruct at25_data *at25 = priv;\n\tchar *buf = val;\n\tsize_t max_chunk = spi_max_transfer_size(at25->spi);\n\tunsigned int msg_offset = offset;\n\tsize_t bytes_left = count;\n\tsize_t segment;\n\tu8\t\t\t*cp;\n\tssize_t\t\t\tstatus;\n\tstruct spi_transfer\tt[2];\n\tstruct spi_message\tm;\n\tu8\t\t\tinstr;\n\n\tif (unlikely(offset >= at25->chip.byte_len))\n\t\treturn -EINVAL;\n\tif ((offset + count) > at25->chip.byte_len)\n\t\tcount = at25->chip.byte_len - offset;\n\tif (unlikely(!count))\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tsegment = min(bytes_left, max_chunk);\n\t\tcp = at25->command;\n\n\t\tinstr = AT25_READ;\n\t\tif (at25->chip.flags & EE_INSTR_BIT3_IS_ADDR)\n\t\t\tif (msg_offset >= BIT(at25->addrlen * 8))\n\t\t\t\tinstr |= AT25_INSTR_BIT3;\n\n\t\tmutex_lock(&at25->lock);\n\n\t\t*cp++ = instr;\n\n\t\t \n\t\tswitch (at25->addrlen) {\n\t\tdefault:\t \n\t\t\t*cp++ = msg_offset >> 16;\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\t*cp++ = msg_offset >> 8;\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\tcase 0:\t \n\t\t\t*cp++ = msg_offset >> 0;\n\t\t}\n\n\t\tspi_message_init(&m);\n\t\tmemset(t, 0, sizeof(t));\n\n\t\tt[0].tx_buf = at25->command;\n\t\tt[0].len = at25->addrlen + 1;\n\t\tspi_message_add_tail(&t[0], &m);\n\n\t\tt[1].rx_buf = buf;\n\t\tt[1].len = segment;\n\t\tspi_message_add_tail(&t[1], &m);\n\n\t\tstatus = spi_sync(at25->spi, &m);\n\n\t\tmutex_unlock(&at25->lock);\n\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tmsg_offset += segment;\n\t\tbuf += segment;\n\t\tbytes_left -= segment;\n\t} while (bytes_left > 0);\n\n\tdev_dbg(&at25->spi->dev, \"read %zu bytes at %d\\n\",\n\t\tcount, offset);\n\treturn 0;\n}\n\n \nstatic int fm25_aux_read(struct at25_data *at25, u8 *buf, uint8_t command,\n\t\t\t int len)\n{\n\tint status;\n\tstruct spi_transfer t[2];\n\tstruct spi_message m;\n\n\tspi_message_init(&m);\n\tmemset(t, 0, sizeof(t));\n\n\tt[0].tx_buf = at25->command;\n\tt[0].len = 1;\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].rx_buf = buf;\n\tt[1].len = len;\n\tspi_message_add_tail(&t[1], &m);\n\n\tmutex_lock(&at25->lock);\n\n\tat25->command[0] = command;\n\n\tstatus = spi_sync(at25->spi, &m);\n\tdev_dbg(&at25->spi->dev, \"read %d aux bytes --> %d\\n\", len, status);\n\n\tmutex_unlock(&at25->lock);\n\treturn status;\n}\n\nstatic ssize_t sernum_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct at25_data *at25;\n\n\tat25 = dev_get_drvdata(dev);\n\treturn sysfs_emit(buf, \"%*ph\\n\", (int)sizeof(at25->sernum), at25->sernum);\n}\nstatic DEVICE_ATTR_RO(sernum);\n\nstatic struct attribute *sernum_attrs[] = {\n\t&dev_attr_sernum.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(sernum);\n\nstatic int at25_ee_write(void *priv, unsigned int off, void *val, size_t count)\n{\n\tstruct at25_data *at25 = priv;\n\tsize_t maxsz = spi_max_transfer_size(at25->spi);\n\tconst char *buf = val;\n\tint\t\t\tstatus = 0;\n\tunsigned\t\tbuf_size;\n\tu8\t\t\t*bounce;\n\n\tif (unlikely(off >= at25->chip.byte_len))\n\t\treturn -EFBIG;\n\tif ((off + count) > at25->chip.byte_len)\n\t\tcount = at25->chip.byte_len - off;\n\tif (unlikely(!count))\n\t\treturn -EINVAL;\n\n\t \n\tbuf_size = at25->chip.page_size;\n\tif (buf_size > io_limit)\n\t\tbuf_size = io_limit;\n\tbounce = kmalloc(buf_size + at25->addrlen + 1, GFP_KERNEL);\n\tif (!bounce)\n\t\treturn -ENOMEM;\n\n\t \n\tmutex_lock(&at25->lock);\n\tdo {\n\t\tunsigned long\ttimeout, retries;\n\t\tunsigned\tsegment;\n\t\tunsigned\toffset = off;\n\t\tu8\t\t*cp = bounce;\n\t\tint\t\tsr;\n\t\tu8\t\tinstr;\n\n\t\t*cp = AT25_WREN;\n\t\tstatus = spi_write(at25->spi, cp, 1);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&at25->spi->dev, \"WREN --> %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\n\t\tinstr = AT25_WRITE;\n\t\tif (at25->chip.flags & EE_INSTR_BIT3_IS_ADDR)\n\t\t\tif (offset >= BIT(at25->addrlen * 8))\n\t\t\t\tinstr |= AT25_INSTR_BIT3;\n\t\t*cp++ = instr;\n\n\t\t \n\t\tswitch (at25->addrlen) {\n\t\tdefault:\t \n\t\t\t*cp++ = offset >> 16;\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\t*cp++ = offset >> 8;\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\tcase 0:\t \n\t\t\t*cp++ = offset >> 0;\n\t\t}\n\n\t\t \n\t\tsegment = buf_size - (offset % buf_size);\n\t\tif (segment > count)\n\t\t\tsegment = count;\n\t\tif (segment > maxsz)\n\t\t\tsegment = maxsz;\n\t\tmemcpy(cp, buf, segment);\n\t\tstatus = spi_write(at25->spi, bounce,\n\t\t\t\tsegment + at25->addrlen + 1);\n\t\tdev_dbg(&at25->spi->dev, \"write %u bytes at %u --> %d\\n\",\n\t\t\tsegment, offset, status);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\n\t\t \n\t\ttimeout = jiffies + msecs_to_jiffies(EE_TIMEOUT);\n\t\tretries = 0;\n\t\tdo {\n\n\t\t\tsr = spi_w8r8(at25->spi, AT25_RDSR);\n\t\t\tif (sr < 0 || (sr & AT25_SR_nRDY)) {\n\t\t\t\tdev_dbg(&at25->spi->dev,\n\t\t\t\t\t\"rdsr --> %d (%02x)\\n\", sr, sr);\n\t\t\t\t \n\t\t\t\tmsleep(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(sr & AT25_SR_nRDY))\n\t\t\t\tbreak;\n\t\t} while (retries++ < 3 || time_before_eq(jiffies, timeout));\n\n\t\tif ((sr < 0) || (sr & AT25_SR_nRDY)) {\n\t\t\tdev_err(&at25->spi->dev,\n\t\t\t\t\"write %u bytes offset %u, timeout after %u msecs\\n\",\n\t\t\t\tsegment, offset,\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t(timeout - EE_TIMEOUT)));\n\t\t\tstatus = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\toff += segment;\n\t\tbuf += segment;\n\t\tcount -= segment;\n\n\t} while (count > 0);\n\n\tmutex_unlock(&at25->lock);\n\n\tkfree(bounce);\n\treturn status;\n}\n\n \n\nstatic int at25_fw_to_chip(struct device *dev, struct spi_eeprom *chip)\n{\n\tu32 val;\n\tint err;\n\n\tstrscpy(chip->name, \"at25\", sizeof(chip->name));\n\n\terr = device_property_read_u32(dev, \"size\", &val);\n\tif (err)\n\t\terr = device_property_read_u32(dev, \"at25,byte-len\", &val);\n\tif (err) {\n\t\tdev_err(dev, \"Error: missing \\\"size\\\" property\\n\");\n\t\treturn err;\n\t}\n\tchip->byte_len = val;\n\n\terr = device_property_read_u32(dev, \"pagesize\", &val);\n\tif (err)\n\t\terr = device_property_read_u32(dev, \"at25,page-size\", &val);\n\tif (err) {\n\t\tdev_err(dev, \"Error: missing \\\"pagesize\\\" property\\n\");\n\t\treturn err;\n\t}\n\tchip->page_size = val;\n\n\terr = device_property_read_u32(dev, \"address-width\", &val);\n\tif (err) {\n\t\terr = device_property_read_u32(dev, \"at25,addr-mode\", &val);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Error: missing \\\"address-width\\\" property\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tchip->flags = (u16)val;\n\t} else {\n\t\tswitch (val) {\n\t\tcase 9:\n\t\t\tchip->flags |= EE_INSTR_BIT3_IS_ADDR;\n\t\t\tfallthrough;\n\t\tcase 8:\n\t\t\tchip->flags |= EE_ADDR1;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tchip->flags |= EE_ADDR2;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tchip->flags |= EE_ADDR3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev,\n\t\t\t\t\"Error: bad \\\"address-width\\\" property: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (device_property_present(dev, \"read-only\"))\n\t\t\tchip->flags |= EE_READONLY;\n\t}\n\treturn 0;\n}\n\nstatic int at25_fram_to_chip(struct device *dev, struct spi_eeprom *chip)\n{\n\tstruct at25_data *at25 = container_of(chip, struct at25_data, chip);\n\tu8 sernum[FM25_SN_LEN];\n\tu8 id[FM25_ID_LEN];\n\tint i;\n\n\tstrscpy(chip->name, \"fm25\", sizeof(chip->name));\n\n\t \n\tfm25_aux_read(at25, id, FM25_RDID, FM25_ID_LEN);\n\tif (id[6] != 0xc2) {\n\t\tdev_err(dev, \"Error: no Cypress FRAM (id %02x)\\n\", id[6]);\n\t\treturn -ENODEV;\n\t}\n\t \n\tif (id[7] < 0x21 || id[7] > 0x26) {\n\t\tdev_err(dev, \"Error: unsupported size (id %02x)\\n\", id[7]);\n\t\treturn -ENODEV;\n\t}\n\n\tchip->byte_len = BIT(id[7] - 0x21 + 4) * 1024;\n\tif (chip->byte_len > 64 * 1024)\n\t\tchip->flags |= EE_ADDR3;\n\telse\n\t\tchip->flags |= EE_ADDR2;\n\n\tif (id[8]) {\n\t\tfm25_aux_read(at25, sernum, FM25_RDSN, FM25_SN_LEN);\n\t\t \n\t\tfor (i = 0; i < FM25_SN_LEN; i++)\n\t\t\tat25->sernum[i] = sernum[FM25_SN_LEN - 1 - i];\n\t}\n\n\tchip->page_size = PAGE_SIZE;\n\treturn 0;\n}\n\nstatic const struct of_device_id at25_of_match[] = {\n\t{ .compatible = \"atmel,at25\" },\n\t{ .compatible = \"cypress,fm25\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, at25_of_match);\n\nstatic const struct spi_device_id at25_spi_ids[] = {\n\t{ .name = \"at25\" },\n\t{ .name = \"fm25\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, at25_spi_ids);\n\nstatic int at25_probe(struct spi_device *spi)\n{\n\tstruct at25_data\t*at25 = NULL;\n\tint\t\t\terr;\n\tint\t\t\tsr;\n\tstruct spi_eeprom *pdata;\n\tbool is_fram;\n\n\t \n\tsr = spi_w8r8(spi, AT25_RDSR);\n\tif (sr < 0 || sr & AT25_SR_nRDY) {\n\t\tdev_dbg(&spi->dev, \"rdsr --> %d (%02x)\\n\", sr, sr);\n\t\treturn -ENXIO;\n\t}\n\n\tat25 = devm_kzalloc(&spi->dev, sizeof(*at25), GFP_KERNEL);\n\tif (!at25)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&at25->lock);\n\tat25->spi = spi;\n\tspi_set_drvdata(spi, at25);\n\n\tis_fram = fwnode_device_is_compatible(dev_fwnode(&spi->dev), \"cypress,fm25\");\n\n\t \n\tpdata = dev_get_platdata(&spi->dev);\n\tif (pdata) {\n\t\tat25->chip = *pdata;\n\t} else {\n\t\tif (is_fram)\n\t\t\terr = at25_fram_to_chip(&spi->dev, &at25->chip);\n\t\telse\n\t\t\terr = at25_fw_to_chip(&spi->dev, &at25->chip);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (at25->chip.flags & EE_ADDR1)\n\t\tat25->addrlen = 1;\n\telse if (at25->chip.flags & EE_ADDR2)\n\t\tat25->addrlen = 2;\n\telse if (at25->chip.flags & EE_ADDR3)\n\t\tat25->addrlen = 3;\n\telse {\n\t\tdev_dbg(&spi->dev, \"unsupported address type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tat25->nvmem_config.type = is_fram ? NVMEM_TYPE_FRAM : NVMEM_TYPE_EEPROM;\n\tat25->nvmem_config.name = dev_name(&spi->dev);\n\tat25->nvmem_config.dev = &spi->dev;\n\tat25->nvmem_config.read_only = at25->chip.flags & EE_READONLY;\n\tat25->nvmem_config.root_only = true;\n\tat25->nvmem_config.owner = THIS_MODULE;\n\tat25->nvmem_config.compat = true;\n\tat25->nvmem_config.base_dev = &spi->dev;\n\tat25->nvmem_config.reg_read = at25_ee_read;\n\tat25->nvmem_config.reg_write = at25_ee_write;\n\tat25->nvmem_config.priv = at25;\n\tat25->nvmem_config.stride = 1;\n\tat25->nvmem_config.word_size = 1;\n\tat25->nvmem_config.size = at25->chip.byte_len;\n\n\tat25->nvmem = devm_nvmem_register(&spi->dev, &at25->nvmem_config);\n\tif (IS_ERR(at25->nvmem))\n\t\treturn PTR_ERR(at25->nvmem);\n\n\tdev_info(&spi->dev, \"%d %s %s %s%s, pagesize %u\\n\",\n\t\t (at25->chip.byte_len < 1024) ?\n\t\t\tat25->chip.byte_len : (at25->chip.byte_len / 1024),\n\t\t (at25->chip.byte_len < 1024) ? \"Byte\" : \"KByte\",\n\t\t at25->chip.name, is_fram ? \"fram\" : \"eeprom\",\n\t\t (at25->chip.flags & EE_READONLY) ? \" (readonly)\" : \"\",\n\t\t at25->chip.page_size);\n\treturn 0;\n}\n\n \n\nstatic struct spi_driver at25_driver = {\n\t.driver = {\n\t\t.name\t\t= \"at25\",\n\t\t.of_match_table = at25_of_match,\n\t\t.dev_groups\t= sernum_groups,\n\t},\n\t.probe\t\t= at25_probe,\n\t.id_table\t= at25_spi_ids,\n};\n\nmodule_spi_driver(at25_driver);\n\nMODULE_DESCRIPTION(\"Driver for most SPI EEPROMs\");\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:at25\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}