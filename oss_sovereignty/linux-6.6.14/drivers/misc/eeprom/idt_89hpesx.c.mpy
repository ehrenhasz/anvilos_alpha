{
  "module_name": "idt_89hpesx.c",
  "hash_id": "d1b237adf896380ab6842430e3e617085be1544ffe08451e00091e5bcc546382",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/eeprom/idt_89hpesx.c",
  "human_readable_source": "\n \n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/debugfs.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/i2c.h>\n#include <linux/pci_ids.h>\n#include <linux/delay.h>\n\n#define IDT_NAME\t\t\"89hpesx\"\n#define IDT_89HPESX_DESC\t\"IDT 89HPESx SMBus-slave interface driver\"\n#define IDT_89HPESX_VER\t\t\"1.0\"\n\nMODULE_DESCRIPTION(IDT_89HPESX_DESC);\nMODULE_VERSION(IDT_89HPESX_VER);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"T-platforms\");\n\n \nstatic struct dentry *csr_dbgdir;\n\n \nstruct idt_smb_seq;\nstruct idt_89hpesx_dev {\n\tu32 eesize;\n\tbool eero;\n\tu8 eeaddr;\n\n\tu8 inieecmd;\n\tu8 inicsrcmd;\n\tu8 iniccode;\n\n\tu16 csr;\n\n\tint (*smb_write)(struct idt_89hpesx_dev *, const struct idt_smb_seq *);\n\tint (*smb_read)(struct idt_89hpesx_dev *, struct idt_smb_seq *);\n\tstruct mutex smb_mtx;\n\n\tstruct i2c_client *client;\n\n\tstruct bin_attribute *ee_file;\n\tstruct dentry *csr_dir;\n};\n\n \nstruct idt_smb_seq {\n\tu8 ccode;\n\tu8 bytecnt;\n\tu8 *data;\n};\n\n \nstruct idt_eeprom_seq {\n\tu8 cmd;\n\tu8 eeaddr;\n\tu16 memaddr;\n\tu8 data;\n} __packed;\n\n \nstruct idt_csr_seq {\n\tu8 cmd;\n\tu16 csraddr;\n\tu32 data;\n} __packed;\n\n \n#define CCODE_END\t((u8)0x01)\n#define CCODE_START\t((u8)0x02)\n#define CCODE_CSR\t((u8)0x00)\n#define CCODE_EEPROM\t((u8)0x04)\n#define CCODE_BYTE\t((u8)0x00)\n#define CCODE_WORD\t((u8)0x20)\n#define CCODE_BLOCK\t((u8)0x40)\n#define CCODE_PEC\t((u8)0x80)\n\n \n#define EEPROM_OP_WRITE\t((u8)0x00)\n#define EEPROM_OP_READ\t((u8)0x01)\n#define EEPROM_USA\t((u8)0x02)\n#define EEPROM_NAERR\t((u8)0x08)\n#define EEPROM_LAERR    ((u8)0x10)\n#define EEPROM_MSS\t((u8)0x20)\n#define EEPROM_WR_CNT\t((u8)5)\n#define EEPROM_WRRD_CNT\t((u8)4)\n#define EEPROM_RD_CNT\t((u8)5)\n#define EEPROM_DEF_SIZE\t((u16)4096)\n#define EEPROM_DEF_ADDR\t((u8)0x50)\n#define EEPROM_TOUT\t(100)\n\n \n#define CSR_DWE\t\t\t((u8)0x0F)\n#define CSR_OP_WRITE\t\t((u8)0x00)\n#define CSR_OP_READ\t\t((u8)0x10)\n#define CSR_RERR\t\t((u8)0x40)\n#define CSR_WERR\t\t((u8)0x80)\n#define CSR_WR_CNT\t\t((u8)7)\n#define CSR_WRRD_CNT\t\t((u8)3)\n#define CSR_RD_CNT\t\t((u8)7)\n#define CSR_MAX\t\t\t((u32)0x3FFFF)\n#define CSR_DEF\t\t\t((u16)0x0000)\n#define CSR_REAL_ADDR(val)\t((unsigned int)val << 2)\n\n \n#define IDT_VIDDID_CSR\t((u32)0x0000)\n#define IDT_VID_MASK\t((u32)0xFFFF)\n\n \n#define RETRY_CNT (128)\n#define idt_smb_safe(ops, args...) ({ \\\n\tint __retry = RETRY_CNT; \\\n\ts32 __sts; \\\n\tdo { \\\n\t\t__sts = i2c_smbus_ ## ops ## _data(args); \\\n\t} while (__retry-- && __sts < 0); \\\n\t__sts; \\\n})\n\n \n\n \nstatic int idt_smb_write_byte(struct idt_89hpesx_dev *pdev,\n\t\t\t      const struct idt_smb_seq *seq)\n{\n\ts32 sts;\n\tu8 ccode;\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < seq->bytecnt; idx++) {\n\t\t \n\t\tccode = seq->ccode | CCODE_BYTE;\n\t\tif (idx == 0)\n\t\t\tccode |= CCODE_START;\n\t\tif (idx == seq->bytecnt - 1)\n\t\t\tccode |= CCODE_END;\n\n\t\t \n\t\tsts = idt_smb_safe(write_byte, pdev->client, ccode,\n\t\t\tseq->data[idx]);\n\t\tif (sts != 0)\n\t\t\treturn (int)sts;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int idt_smb_read_byte(struct idt_89hpesx_dev *pdev,\n\t\t\t     struct idt_smb_seq *seq)\n{\n\ts32 sts;\n\tu8 ccode;\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < seq->bytecnt; idx++) {\n\t\t \n\t\tccode = seq->ccode | CCODE_BYTE;\n\t\tif (idx == 0)\n\t\t\tccode |= CCODE_START;\n\t\tif (idx == seq->bytecnt - 1)\n\t\t\tccode |= CCODE_END;\n\n\t\t \n\t\tsts = idt_smb_safe(read_byte, pdev->client, ccode);\n\t\tif (sts < 0)\n\t\t\treturn (int)sts;\n\n\t\tseq->data[idx] = (u8)sts;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int idt_smb_write_word(struct idt_89hpesx_dev *pdev,\n\t\t\t      const struct idt_smb_seq *seq)\n{\n\ts32 sts;\n\tu8 ccode;\n\tint idx, evencnt;\n\n\t \n\tevencnt = seq->bytecnt - (seq->bytecnt % 2);\n\n\t \n\tfor (idx = 0; idx < evencnt; idx += 2) {\n\t\t \n\t\tccode = seq->ccode | CCODE_WORD;\n\t\tif (idx == 0)\n\t\t\tccode |= CCODE_START;\n\t\tif (idx == evencnt - 2)\n\t\t\tccode |= CCODE_END;\n\n\t\t \n\t\tsts = idt_smb_safe(write_word, pdev->client, ccode,\n\t\t\t*(u16 *)&seq->data[idx]);\n\t\tif (sts != 0)\n\t\t\treturn (int)sts;\n\t}\n\n\t \n\tif (seq->bytecnt != evencnt) {\n\t\t \n\t\tccode = seq->ccode | CCODE_BYTE | CCODE_END;\n\t\tif (idx == 0)\n\t\t\tccode |= CCODE_START;\n\n\t\t \n\t\tsts = idt_smb_safe(write_byte, pdev->client, ccode,\n\t\t\tseq->data[idx]);\n\t\tif (sts != 0)\n\t\t\treturn (int)sts;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int idt_smb_read_word(struct idt_89hpesx_dev *pdev,\n\t\t\t     struct idt_smb_seq *seq)\n{\n\ts32 sts;\n\tu8 ccode;\n\tint idx, evencnt;\n\n\t \n\tevencnt = seq->bytecnt - (seq->bytecnt % 2);\n\n\t \n\tfor (idx = 0; idx < evencnt; idx += 2) {\n\t\t \n\t\tccode = seq->ccode | CCODE_WORD;\n\t\tif (idx == 0)\n\t\t\tccode |= CCODE_START;\n\t\tif (idx == evencnt - 2)\n\t\t\tccode |= CCODE_END;\n\n\t\t \n\t\tsts = idt_smb_safe(read_word, pdev->client, ccode);\n\t\tif (sts < 0)\n\t\t\treturn (int)sts;\n\n\t\t*(u16 *)&seq->data[idx] = (u16)sts;\n\t}\n\n\t \n\tif (seq->bytecnt != evencnt) {\n\t\t \n\t\tccode = seq->ccode | CCODE_BYTE | CCODE_END;\n\t\tif (idx == 0)\n\t\t\tccode |= CCODE_START;\n\n\t\t \n\t\tsts = idt_smb_safe(read_byte, pdev->client, ccode);\n\t\tif (sts < 0)\n\t\t\treturn (int)sts;\n\n\t\tseq->data[idx] = (u8)sts;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int idt_smb_write_block(struct idt_89hpesx_dev *pdev,\n\t\t\t       const struct idt_smb_seq *seq)\n{\n\tu8 ccode;\n\n\t \n\tif (seq->bytecnt > I2C_SMBUS_BLOCK_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tccode = seq->ccode | CCODE_BLOCK | CCODE_START | CCODE_END;\n\n\t \n\treturn idt_smb_safe(write_block, pdev->client, ccode, seq->bytecnt,\n\t\tseq->data);\n}\n\n \nstatic int idt_smb_read_block(struct idt_89hpesx_dev *pdev,\n\t\t\t      struct idt_smb_seq *seq)\n{\n\ts32 sts;\n\tu8 ccode;\n\n\t \n\tif (seq->bytecnt > I2C_SMBUS_BLOCK_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tccode = seq->ccode | CCODE_BLOCK | CCODE_START | CCODE_END;\n\n\t \n\tsts = idt_smb_safe(read_block, pdev->client, ccode, seq->data);\n\tif (sts != seq->bytecnt)\n\t\treturn (sts < 0 ? sts : -ENODATA);\n\n\treturn 0;\n}\n\n \nstatic int idt_smb_write_i2c_block(struct idt_89hpesx_dev *pdev,\n\t\t\t\t   const struct idt_smb_seq *seq)\n{\n\tu8 ccode, buf[I2C_SMBUS_BLOCK_MAX + 1];\n\n\t \n\tif (seq->bytecnt > I2C_SMBUS_BLOCK_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tbuf[0] = seq->bytecnt;\n\tmemcpy(&buf[1], seq->data, seq->bytecnt);\n\n\t \n\tccode = seq->ccode | CCODE_BLOCK | CCODE_START | CCODE_END;\n\n\t \n\treturn idt_smb_safe(write_i2c_block, pdev->client, ccode,\n\t\tseq->bytecnt + 1, buf);\n}\n\n \nstatic int idt_smb_read_i2c_block(struct idt_89hpesx_dev *pdev,\n\t\t\t\t  struct idt_smb_seq *seq)\n{\n\tu8 ccode, buf[I2C_SMBUS_BLOCK_MAX + 1];\n\ts32 sts;\n\n\t \n\tif (seq->bytecnt > I2C_SMBUS_BLOCK_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tccode = seq->ccode | CCODE_BLOCK | CCODE_START | CCODE_END;\n\n\t \n\tsts = idt_smb_safe(read_i2c_block, pdev->client, ccode,\n\t\tseq->bytecnt + 1, buf);\n\tif (sts != seq->bytecnt + 1)\n\t\treturn (sts < 0 ? sts : -ENODATA);\n\tif (buf[0] != seq->bytecnt)\n\t\treturn -ENODATA;\n\n\t \n\tmemcpy(seq->data, &buf[1], seq->bytecnt);\n\n\treturn 0;\n}\n\n \n\n \nstatic int idt_eeprom_read_byte(struct idt_89hpesx_dev *pdev, u16 memaddr,\n\t\t\t\tu8 *data)\n{\n\tstruct device *dev = &pdev->client->dev;\n\tstruct idt_eeprom_seq eeseq;\n\tstruct idt_smb_seq smbseq;\n\tint ret, retry;\n\n\t \n\tsmbseq.ccode = pdev->iniccode | CCODE_EEPROM;\n\tsmbseq.data = (u8 *)&eeseq;\n\n\t \n\tretry = RETRY_CNT;\n\tdo {\n\t\t \n\t\tsmbseq.bytecnt = EEPROM_WRRD_CNT;\n\t\teeseq.cmd = pdev->inieecmd | EEPROM_OP_READ;\n\t\teeseq.eeaddr = pdev->eeaddr;\n\t\teeseq.memaddr = cpu_to_le16(memaddr);\n\t\tret = pdev->smb_write(pdev, &smbseq);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"Failed to init eeprom addr 0x%02x\",\n\t\t\t\tmemaddr);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsmbseq.bytecnt = EEPROM_RD_CNT;\n\t\tret = pdev->smb_read(pdev, &smbseq);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"Failed to read eeprom data 0x%02x\",\n\t\t\t\tmemaddr);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (retry && (eeseq.cmd & EEPROM_NAERR)) {\n\t\t\tdev_dbg(dev, \"EEPROM busy, retry reading after %d ms\",\n\t\t\t\tEEPROM_TOUT);\n\t\t\tmsleep(EEPROM_TOUT);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (eeseq.cmd & (EEPROM_NAERR | EEPROM_LAERR | EEPROM_MSS)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Communication with eeprom failed, cmd 0x%hhx\",\n\t\t\t\teeseq.cmd);\n\t\t\tret = -EREMOTEIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\t*data = eeseq.data;\n\t\tbreak;\n\t} while (retry--);\n\n\t \n\treturn ret;\n}\n\n \nstatic int idt_eeprom_write(struct idt_89hpesx_dev *pdev, u16 memaddr, u16 len,\n\t\t\t    const u8 *data)\n{\n\tstruct device *dev = &pdev->client->dev;\n\tstruct idt_eeprom_seq eeseq;\n\tstruct idt_smb_seq smbseq;\n\tint ret;\n\tu16 idx;\n\n\t \n\tsmbseq.ccode = pdev->iniccode | CCODE_EEPROM;\n\tsmbseq.data = (u8 *)&eeseq;\n\n\t \n\tfor (idx = 0; idx < len; idx++, memaddr++) {\n\t\t \n\t\tmutex_lock(&pdev->smb_mtx);\n\n\t\t \n\t\tsmbseq.bytecnt = EEPROM_WR_CNT;\n\t\teeseq.cmd = pdev->inieecmd | EEPROM_OP_WRITE;\n\t\teeseq.eeaddr = pdev->eeaddr;\n\t\teeseq.memaddr = cpu_to_le16(memaddr);\n\t\teeseq.data = data[idx];\n\t\tret = pdev->smb_write(pdev, &smbseq);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to write 0x%04hx:0x%02hhx to eeprom\",\n\t\t\t\tmemaddr, data[idx]);\n\t\t\tgoto err_mutex_unlock;\n\t\t}\n\n\t\t \n\t\teeseq.data = ~data[idx];\n\t\tret = idt_eeprom_read_byte(pdev, memaddr, &eeseq.data);\n\t\tif (ret != 0)\n\t\t\tgoto err_mutex_unlock;\n\n\t\t \n\t\tif (eeseq.data != data[idx]) {\n\t\t\tdev_err(dev, \"Values don't match 0x%02hhx != 0x%02hhx\",\n\t\t\t\teeseq.data, data[idx]);\n\t\t\tret = -EREMOTEIO;\n\t\t\tgoto err_mutex_unlock;\n\t\t}\n\n\t\t \nerr_mutex_unlock:\n\t\tmutex_unlock(&pdev->smb_mtx);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int idt_eeprom_read(struct idt_89hpesx_dev *pdev, u16 memaddr, u16 len,\n\t\t\t   u8 *buf)\n{\n\tint ret;\n\tu16 idx;\n\n\t \n\tfor (idx = 0; idx < len; idx++, memaddr++) {\n\t\t \n\t\tmutex_lock(&pdev->smb_mtx);\n\n\t\t \n\t\tret = idt_eeprom_read_byte(pdev, memaddr, &buf[idx]);\n\n\t\t \n\t\tmutex_unlock(&pdev->smb_mtx);\n\n\t\t \n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic int idt_csr_write(struct idt_89hpesx_dev *pdev, u16 csraddr,\n\t\t\t const u32 data)\n{\n\tstruct device *dev = &pdev->client->dev;\n\tstruct idt_csr_seq csrseq;\n\tstruct idt_smb_seq smbseq;\n\tint ret;\n\n\t \n\tsmbseq.ccode = pdev->iniccode | CCODE_CSR;\n\tsmbseq.data = (u8 *)&csrseq;\n\n\t \n\tmutex_lock(&pdev->smb_mtx);\n\n\t \n\tsmbseq.bytecnt = CSR_WR_CNT;\n\tcsrseq.cmd = pdev->inicsrcmd | CSR_OP_WRITE;\n\tcsrseq.csraddr = cpu_to_le16(csraddr);\n\tcsrseq.data = cpu_to_le32(data);\n\tret = pdev->smb_write(pdev, &smbseq);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to write 0x%04x: 0x%04x to csr\",\n\t\t\tCSR_REAL_ADDR(csraddr), data);\n\t\tgoto err_mutex_unlock;\n\t}\n\n\t \n\tsmbseq.bytecnt = CSR_WRRD_CNT;\n\tcsrseq.cmd = pdev->inicsrcmd | CSR_OP_READ;\n\tret = pdev->smb_write(pdev, &smbseq);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to init csr address 0x%04x\",\n\t\t\tCSR_REAL_ADDR(csraddr));\n\t\tgoto err_mutex_unlock;\n\t}\n\n\t \n\tsmbseq.bytecnt = CSR_RD_CNT;\n\tret = pdev->smb_read(pdev, &smbseq);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to read csr 0x%04x\",\n\t\t\tCSR_REAL_ADDR(csraddr));\n\t\tgoto err_mutex_unlock;\n\t}\n\n\t \n\tif (csrseq.cmd & (CSR_RERR | CSR_WERR)) {\n\t\tdev_err(dev, \"IDT failed to perform CSR r/w\");\n\t\tret = -EREMOTEIO;\n\t\tgoto err_mutex_unlock;\n\t}\n\n\t \nerr_mutex_unlock:\n\tmutex_unlock(&pdev->smb_mtx);\n\n\treturn ret;\n}\n\n \nstatic int idt_csr_read(struct idt_89hpesx_dev *pdev, u16 csraddr, u32 *data)\n{\n\tstruct device *dev = &pdev->client->dev;\n\tstruct idt_csr_seq csrseq;\n\tstruct idt_smb_seq smbseq;\n\tint ret;\n\n\t \n\tsmbseq.ccode = pdev->iniccode | CCODE_CSR;\n\tsmbseq.data = (u8 *)&csrseq;\n\n\t \n\tmutex_lock(&pdev->smb_mtx);\n\n\t \n\tsmbseq.bytecnt = CSR_WRRD_CNT;\n\tcsrseq.cmd = pdev->inicsrcmd | CSR_OP_READ;\n\tcsrseq.csraddr = cpu_to_le16(csraddr);\n\tret = pdev->smb_write(pdev, &smbseq);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to init csr address 0x%04x\",\n\t\t\tCSR_REAL_ADDR(csraddr));\n\t\tgoto err_mutex_unlock;\n\t}\n\n\t \n\tsmbseq.bytecnt = CSR_RD_CNT;\n\tret = pdev->smb_read(pdev, &smbseq);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to read csr 0x%04x\",\n\t\t\tCSR_REAL_ADDR(csraddr));\n\t\tgoto err_mutex_unlock;\n\t}\n\n\t \n\tif (csrseq.cmd & (CSR_RERR | CSR_WERR)) {\n\t\tdev_err(dev, \"IDT failed to perform CSR r/w\");\n\t\tret = -EREMOTEIO;\n\t\tgoto err_mutex_unlock;\n\t}\n\n\t \n\t*data = le32_to_cpu(csrseq.data);\n\n\t \nerr_mutex_unlock:\n\tmutex_unlock(&pdev->smb_mtx);\n\n\treturn ret;\n}\n\n \n\n \nstatic ssize_t eeprom_write(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *attr,\n\t\t\t    char *buf, loff_t off, size_t count)\n{\n\tstruct idt_89hpesx_dev *pdev;\n\tint ret;\n\n\t \n\tpdev = dev_get_drvdata(kobj_to_dev(kobj));\n\n\t \n\tret = idt_eeprom_write(pdev, (u16)off, (u16)count, (u8 *)buf);\n\treturn (ret != 0 ? ret : count);\n}\n\n \nstatic ssize_t eeprom_read(struct file *filp, struct kobject *kobj,\n\t\t\t   struct bin_attribute *attr,\n\t\t\t   char *buf, loff_t off, size_t count)\n{\n\tstruct idt_89hpesx_dev *pdev;\n\tint ret;\n\n\t \n\tpdev = dev_get_drvdata(kobj_to_dev(kobj));\n\n\t \n\tret = idt_eeprom_read(pdev, (u16)off, (u16)count, (u8 *)buf);\n\treturn (ret != 0 ? ret : count);\n}\n\n \nstatic ssize_t idt_dbgfs_csr_write(struct file *filep, const char __user *ubuf,\n\t\t\t\t   size_t count, loff_t *offp)\n{\n\tstruct idt_89hpesx_dev *pdev = filep->private_data;\n\tchar *colon_ch, *csraddr_str, *csrval_str;\n\tint ret, csraddr_len;\n\tu32 csraddr, csrval;\n\tchar *buf;\n\n\tif (*offp)\n\t\treturn 0;\n\n\t \n\tbuf = memdup_user_nul(ubuf, count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\t \n\tcolon_ch = strnchr(buf, count, ':');\n\n\t \n\tif (colon_ch != NULL) {\n\t\tcsraddr_len = colon_ch - buf;\n\t\tcsraddr_str =\n\t\t\tkmalloc(csraddr_len + 1, GFP_KERNEL);\n\t\tif (csraddr_str == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_buf;\n\t\t}\n\t\t \n\t\tstrncpy(csraddr_str, buf, csraddr_len);\n\t\tcsraddr_str[csraddr_len] = '\\0';\n\t\t \n\t\tcsrval_str = colon_ch + 1;\n\t} else   {\n\t\tcsraddr_str = (char *)buf;  \n\t\tcsraddr_len = strnlen(csraddr_str, count);\n\t\tcsrval_str = NULL;\n\t}\n\n\t \n\tret = kstrtou32(csraddr_str, 0, &csraddr);\n\tif (ret != 0)\n\t\tgoto free_csraddr_str;\n\n\t \n\tif (csraddr > CSR_MAX || !IS_ALIGNED(csraddr, SZ_4)) {\n\t\tret = -EINVAL;\n\t\tgoto free_csraddr_str;\n\t}\n\n\t \n\tpdev->csr = (csraddr >> 2);\n\n\t \n\tif (colon_ch != NULL) {\n\t\tret = kstrtou32(csrval_str, 0, &csrval);\n\t\tif (ret != 0)\n\t\t\tgoto free_csraddr_str;\n\n\t\tret = idt_csr_write(pdev, pdev->csr, csrval);\n\t\tif (ret != 0)\n\t\t\tgoto free_csraddr_str;\n\t}\n\n\t \nfree_csraddr_str:\n\tif (colon_ch != NULL)\n\t\tkfree(csraddr_str);\n\n\t \nfree_buf:\n\tkfree(buf);\n\n\treturn (ret != 0 ? ret : count);\n}\n\n \n#define CSRBUF_SIZE\t((size_t)32)\nstatic ssize_t idt_dbgfs_csr_read(struct file *filep, char __user *ubuf,\n\t\t\t\t  size_t count, loff_t *offp)\n{\n\tstruct idt_89hpesx_dev *pdev = filep->private_data;\n\tu32 csraddr, csrval;\n\tchar buf[CSRBUF_SIZE];\n\tint ret, size;\n\n\t \n\tret = idt_csr_read(pdev, pdev->csr, &csrval);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tcsraddr = ((u32)pdev->csr << 2);\n\n\t \n\tsize = snprintf(buf, CSRBUF_SIZE, \"0x%05x:0x%08x\\n\",\n\t\t(unsigned int)csraddr, (unsigned int)csrval);\n\n\t \n\treturn simple_read_from_buffer(ubuf, count, offp, buf, size);\n}\n\n \nstatic BIN_ATTR_RW(eeprom, EEPROM_DEF_SIZE);\n\n \nstatic const struct file_operations csr_dbgfs_ops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.write = idt_dbgfs_csr_write,\n\t.read = idt_dbgfs_csr_read\n};\n\n \n\n \nstatic void idt_set_defval(struct idt_89hpesx_dev *pdev)\n{\n\t \n\tpdev->eesize = 0;\n\tpdev->eero = true;\n\tpdev->inieecmd = 0;\n\tpdev->eeaddr = 0;\n}\n\nstatic const struct i2c_device_id ee_ids[];\n\n \nstatic const struct i2c_device_id *idt_ee_match_id(struct fwnode_handle *fwnode)\n{\n\tconst struct i2c_device_id *id = ee_ids;\n\tconst char *compatible, *p;\n\tchar devname[I2C_NAME_SIZE];\n\tint ret;\n\n\tret = fwnode_property_read_string(fwnode, \"compatible\", &compatible);\n\tif (ret)\n\t\treturn NULL;\n\n\tp = strchr(compatible, ',');\n\tstrscpy(devname, p ? p + 1 : compatible, sizeof(devname));\n\t \n\twhile (id->name[0]) {\n\t\tif (strcmp(devname, id->name) == 0)\n\t\t\treturn id;\n\t\tid++;\n\t}\n\treturn NULL;\n}\n\n \nstatic void idt_get_fw_data(struct idt_89hpesx_dev *pdev)\n{\n\tstruct device *dev = &pdev->client->dev;\n\tstruct fwnode_handle *fwnode;\n\tconst struct i2c_device_id *ee_id = NULL;\n\tu32 eeprom_addr;\n\tint ret;\n\n\tdevice_for_each_child_node(dev, fwnode) {\n\t\tee_id = idt_ee_match_id(fwnode);\n\t\tif (ee_id)\n\t\t\tbreak;\n\n\t\tdev_warn(dev, \"Skip unsupported EEPROM device %pfw\\n\", fwnode);\n\t}\n\n\t \n\tif (!ee_id) {\n\t\tdev_warn(dev, \"No fwnode, EEPROM access disabled\");\n\t\tidt_set_defval(pdev);\n\t\treturn;\n\t}\n\n\t \n\tpdev->eesize = (u32)ee_id->driver_data;\n\n\t \n\tret = fwnode_property_read_u32(fwnode, \"reg\", &eeprom_addr);\n\tif (ret || (eeprom_addr == 0)) {\n\t\tdev_warn(dev, \"No EEPROM reg found, use default address 0x%x\",\n\t\t\t EEPROM_DEF_ADDR);\n\t\tpdev->inieecmd = 0;\n\t\tpdev->eeaddr = EEPROM_DEF_ADDR << 1;\n\t} else {\n\t\tpdev->inieecmd = EEPROM_USA;\n\t\tpdev->eeaddr = eeprom_addr << 1;\n\t}\n\n\t \n\tif (fwnode_property_read_bool(fwnode, \"read-only\"))\n\t\tpdev->eero = true;\n\telse  \n\t\tpdev->eero = false;\n\n\tfwnode_handle_put(fwnode);\n\tdev_info(dev, \"EEPROM of %d bytes found by 0x%x\",\n\t\tpdev->eesize, pdev->eeaddr);\n}\n\n \nstatic struct idt_89hpesx_dev *idt_create_pdev(struct i2c_client *client)\n{\n\tstruct idt_89hpesx_dev *pdev;\n\n\t \n\tpdev = devm_kmalloc(&client->dev, sizeof(struct idt_89hpesx_dev),\n\t\tGFP_KERNEL);\n\tif (pdev == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tpdev->client = client;\n\ti2c_set_clientdata(client, pdev);\n\n\t \n\tidt_get_fw_data(pdev);\n\n\t \n\tpdev->inicsrcmd = CSR_DWE;\n\tpdev->csr = CSR_DEF;\n\n\t \n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_PEC)) {\n\t\tpdev->iniccode = CCODE_PEC;\n\t\tclient->flags |= I2C_CLIENT_PEC;\n\t} else   {\n\t\tpdev->iniccode = 0;\n\t}\n\n\treturn pdev;\n}\n\n \nstatic void idt_free_pdev(struct idt_89hpesx_dev *pdev)\n{\n\t \n\ti2c_set_clientdata(pdev->client, NULL);\n}\n\n \nstatic int idt_set_smbus_ops(struct idt_89hpesx_dev *pdev)\n{\n\tstruct i2c_adapter *adapter = pdev->client->adapter;\n\tstruct device *dev = &pdev->client->dev;\n\n\t \n\tif (i2c_check_functionality(adapter,\n\t\t\t\t    I2C_FUNC_SMBUS_READ_BLOCK_DATA)) {\n\t\tpdev->smb_read = idt_smb_read_block;\n\t\tdev_dbg(dev, \"SMBus block-read op chosen\");\n\t} else if (i2c_check_functionality(adapter,\n\t\t\t\t\t   I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {\n\t\tpdev->smb_read = idt_smb_read_i2c_block;\n\t\tdev_dbg(dev, \"SMBus i2c-block-read op chosen\");\n\t} else if (i2c_check_functionality(adapter,\n\t\t\t\t\t   I2C_FUNC_SMBUS_READ_WORD_DATA) &&\n\t\t   i2c_check_functionality(adapter,\n\t\t\t\t\t   I2C_FUNC_SMBUS_READ_BYTE_DATA)) {\n\t\tpdev->smb_read = idt_smb_read_word;\n\t\tdev_warn(dev, \"Use slow word/byte SMBus read ops\");\n\t} else if (i2c_check_functionality(adapter,\n\t\t\t\t\t   I2C_FUNC_SMBUS_READ_BYTE_DATA)) {\n\t\tpdev->smb_read = idt_smb_read_byte;\n\t\tdev_warn(dev, \"Use slow byte SMBus read op\");\n\t} else   {\n\t\tdev_err(dev, \"No supported SMBus read op\");\n\t\treturn -EPFNOSUPPORT;\n\t}\n\n\t \n\tif (i2c_check_functionality(adapter,\n\t\t\t\t    I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)) {\n\t\tpdev->smb_write = idt_smb_write_block;\n\t\tdev_dbg(dev, \"SMBus block-write op chosen\");\n\t} else if (i2c_check_functionality(adapter,\n\t\t\t\t\t   I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)) {\n\t\tpdev->smb_write = idt_smb_write_i2c_block;\n\t\tdev_dbg(dev, \"SMBus i2c-block-write op chosen\");\n\t} else if (i2c_check_functionality(adapter,\n\t\t\t\t\t   I2C_FUNC_SMBUS_WRITE_WORD_DATA) &&\n\t\t   i2c_check_functionality(adapter,\n\t\t\t\t\t   I2C_FUNC_SMBUS_WRITE_BYTE_DATA)) {\n\t\tpdev->smb_write = idt_smb_write_word;\n\t\tdev_warn(dev, \"Use slow word/byte SMBus write op\");\n\t} else if (i2c_check_functionality(adapter,\n\t\t\t\t\t   I2C_FUNC_SMBUS_WRITE_BYTE_DATA)) {\n\t\tpdev->smb_write = idt_smb_write_byte;\n\t\tdev_warn(dev, \"Use slow byte SMBus write op\");\n\t} else   {\n\t\tdev_err(dev, \"No supported SMBus write op\");\n\t\treturn -EPFNOSUPPORT;\n\t}\n\n\t \n\tmutex_init(&pdev->smb_mtx);\n\n\treturn 0;\n}\n\n \nstatic int idt_check_dev(struct idt_89hpesx_dev *pdev)\n{\n\tstruct device *dev = &pdev->client->dev;\n\tu32 viddid;\n\tint ret;\n\n\t \n\tret = idt_csr_read(pdev, IDT_VIDDID_CSR, &viddid);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to read VID/DID\");\n\t\treturn ret;\n\t}\n\n\t \n\tif ((viddid & IDT_VID_MASK) != PCI_VENDOR_ID_IDT) {\n\t\tdev_err(dev, \"Got unsupported VID/DID: 0x%08x\", viddid);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(dev, \"Found IDT 89HPES device VID:0x%04x, DID:0x%04x\",\n\t\t(viddid & IDT_VID_MASK), (viddid >> 16));\n\n\treturn 0;\n}\n\n \nstatic int idt_create_sysfs_files(struct idt_89hpesx_dev *pdev)\n{\n\tstruct device *dev = &pdev->client->dev;\n\tint ret;\n\n\t \n\tif (pdev->eesize == 0) {\n\t\tdev_dbg(dev, \"Skip creating sysfs-files\");\n\t\treturn 0;\n\t}\n\n\t \n\tpdev->ee_file = devm_kmemdup(dev, &bin_attr_eeprom,\n\t\t\t\t     sizeof(*pdev->ee_file), GFP_KERNEL);\n\tif (!pdev->ee_file)\n\t\treturn -ENOMEM;\n\n\t \n\tif (pdev->eero) {\n\t\tpdev->ee_file->attr.mode &= ~0200;\n\t\tpdev->ee_file->write = NULL;\n\t}\n\t \n\tpdev->ee_file->size = pdev->eesize;\n\tret = sysfs_create_bin_file(&dev->kobj, pdev->ee_file);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to create EEPROM sysfs-node\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void idt_remove_sysfs_files(struct idt_89hpesx_dev *pdev)\n{\n\tstruct device *dev = &pdev->client->dev;\n\n\t \n\tif (pdev->eesize == 0)\n\t\treturn;\n\n\t \n\tsysfs_remove_bin_file(&dev->kobj, pdev->ee_file);\n}\n\n \n#define CSRNAME_LEN\t((size_t)32)\nstatic void idt_create_dbgfs_files(struct idt_89hpesx_dev *pdev)\n{\n\tstruct i2c_client *cli = pdev->client;\n\tchar fname[CSRNAME_LEN];\n\n\t \n\tsnprintf(fname, CSRNAME_LEN, \"%d-%04hx\", cli->adapter->nr, cli->addr);\n\tpdev->csr_dir = debugfs_create_dir(fname, csr_dbgdir);\n\n\t \n\tdebugfs_create_file(cli->name, 0600, pdev->csr_dir, pdev,\n\t\t\t    &csr_dbgfs_ops);\n}\n\n \nstatic void idt_remove_dbgfs_files(struct idt_89hpesx_dev *pdev)\n{\n\t \n\tdebugfs_remove_recursive(pdev->csr_dir);\n}\n\n \nstatic int idt_probe(struct i2c_client *client)\n{\n\tstruct idt_89hpesx_dev *pdev;\n\tint ret;\n\n\t \n\tpdev = idt_create_pdev(client);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\t \n\tret = idt_set_smbus_ops(pdev);\n\tif (ret != 0)\n\t\tgoto err_free_pdev;\n\n\t \n\tret = idt_check_dev(pdev);\n\tif (ret != 0)\n\t\tgoto err_free_pdev;\n\n\t \n\tret = idt_create_sysfs_files(pdev);\n\tif (ret != 0)\n\t\tgoto err_free_pdev;\n\n\t \n\tidt_create_dbgfs_files(pdev);\n\n\treturn 0;\n\nerr_free_pdev:\n\tidt_free_pdev(pdev);\n\n\treturn ret;\n}\n\n \nstatic void idt_remove(struct i2c_client *client)\n{\n\tstruct idt_89hpesx_dev *pdev = i2c_get_clientdata(client);\n\n\t \n\tidt_remove_dbgfs_files(pdev);\n\n\t \n\tidt_remove_sysfs_files(pdev);\n\n\t \n\tidt_free_pdev(pdev);\n}\n\n \nstatic const struct i2c_device_id ee_ids[] = {\n\t{ \"24c32\",  4096},\n\t{ \"24c64\",  8192},\n\t{ \"24c128\", 16384},\n\t{ \"24c256\", 32768},\n\t{ \"24c512\", 65536},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ee_ids);\n\n \nstatic const struct i2c_device_id idt_ids[] = {\n\t{ \"89hpes8nt2\", 0 },\n\t{ \"89hpes12nt3\", 0 },\n\n\t{ \"89hpes24nt6ag2\", 0 },\n\t{ \"89hpes32nt8ag2\", 0 },\n\t{ \"89hpes32nt8bg2\", 0 },\n\t{ \"89hpes12nt12g2\", 0 },\n\t{ \"89hpes16nt16g2\", 0 },\n\t{ \"89hpes24nt24g2\", 0 },\n\t{ \"89hpes32nt24ag2\", 0 },\n\t{ \"89hpes32nt24bg2\", 0 },\n\n\t{ \"89hpes12n3\", 0 },\n\t{ \"89hpes12n3a\", 0 },\n\t{ \"89hpes24n3\", 0 },\n\t{ \"89hpes24n3a\", 0 },\n\n\t{ \"89hpes32h8\", 0 },\n\t{ \"89hpes32h8g2\", 0 },\n\t{ \"89hpes48h12\", 0 },\n\t{ \"89hpes48h12g2\", 0 },\n\t{ \"89hpes48h12ag2\", 0 },\n\t{ \"89hpes16h16\", 0 },\n\t{ \"89hpes22h16\", 0 },\n\t{ \"89hpes22h16g2\", 0 },\n\t{ \"89hpes34h16\", 0 },\n\t{ \"89hpes34h16g2\", 0 },\n\t{ \"89hpes64h16\", 0 },\n\t{ \"89hpes64h16g2\", 0 },\n\t{ \"89hpes64h16ag2\", 0 },\n\n\t \n\t{ \"89hpes12t3g2\", 0 },\n\t{ \"89hpes24t3g2\", 0 },\n\t \n\t{ \"89hpes16t4\", 0 },\n\t{ \"89hpes4t4g2\", 0 },\n\t{ \"89hpes10t4g2\", 0 },\n\t{ \"89hpes16t4g2\", 0 },\n\t{ \"89hpes16t4ag2\", 0 },\n\t{ \"89hpes5t5\", 0 },\n\t{ \"89hpes6t5\", 0 },\n\t{ \"89hpes8t5\", 0 },\n\t{ \"89hpes8t5a\", 0 },\n\t{ \"89hpes24t6\", 0 },\n\t{ \"89hpes6t6g2\", 0 },\n\t{ \"89hpes24t6g2\", 0 },\n\t{ \"89hpes16t7\", 0 },\n\t{ \"89hpes32t8\", 0 },\n\t{ \"89hpes32t8g2\", 0 },\n\t{ \"89hpes48t12\", 0 },\n\t{ \"89hpes48t12g2\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, idt_ids);\n\nstatic const struct of_device_id idt_of_match[] = {\n\t{ .compatible = \"idt,89hpes8nt2\", },\n\t{ .compatible = \"idt,89hpes12nt3\", },\n\n\t{ .compatible = \"idt,89hpes24nt6ag2\", },\n\t{ .compatible = \"idt,89hpes32nt8ag2\", },\n\t{ .compatible = \"idt,89hpes32nt8bg2\", },\n\t{ .compatible = \"idt,89hpes12nt12g2\", },\n\t{ .compatible = \"idt,89hpes16nt16g2\", },\n\t{ .compatible = \"idt,89hpes24nt24g2\", },\n\t{ .compatible = \"idt,89hpes32nt24ag2\", },\n\t{ .compatible = \"idt,89hpes32nt24bg2\", },\n\n\t{ .compatible = \"idt,89hpes12n3\", },\n\t{ .compatible = \"idt,89hpes12n3a\", },\n\t{ .compatible = \"idt,89hpes24n3\", },\n\t{ .compatible = \"idt,89hpes24n3a\", },\n\n\t{ .compatible = \"idt,89hpes32h8\", },\n\t{ .compatible = \"idt,89hpes32h8g2\", },\n\t{ .compatible = \"idt,89hpes48h12\", },\n\t{ .compatible = \"idt,89hpes48h12g2\", },\n\t{ .compatible = \"idt,89hpes48h12ag2\", },\n\t{ .compatible = \"idt,89hpes16h16\", },\n\t{ .compatible = \"idt,89hpes22h16\", },\n\t{ .compatible = \"idt,89hpes22h16g2\", },\n\t{ .compatible = \"idt,89hpes34h16\", },\n\t{ .compatible = \"idt,89hpes34h16g2\", },\n\t{ .compatible = \"idt,89hpes64h16\", },\n\t{ .compatible = \"idt,89hpes64h16g2\", },\n\t{ .compatible = \"idt,89hpes64h16ag2\", },\n\n\t{ .compatible = \"idt,89hpes12t3g2\", },\n\t{ .compatible = \"idt,89hpes24t3g2\", },\n\n\t{ .compatible = \"idt,89hpes16t4\", },\n\t{ .compatible = \"idt,89hpes4t4g2\", },\n\t{ .compatible = \"idt,89hpes10t4g2\", },\n\t{ .compatible = \"idt,89hpes16t4g2\", },\n\t{ .compatible = \"idt,89hpes16t4ag2\", },\n\t{ .compatible = \"idt,89hpes5t5\", },\n\t{ .compatible = \"idt,89hpes6t5\", },\n\t{ .compatible = \"idt,89hpes8t5\", },\n\t{ .compatible = \"idt,89hpes8t5a\", },\n\t{ .compatible = \"idt,89hpes24t6\", },\n\t{ .compatible = \"idt,89hpes6t6g2\", },\n\t{ .compatible = \"idt,89hpes24t6g2\", },\n\t{ .compatible = \"idt,89hpes16t7\", },\n\t{ .compatible = \"idt,89hpes32t8\", },\n\t{ .compatible = \"idt,89hpes32t8g2\", },\n\t{ .compatible = \"idt,89hpes48t12\", },\n\t{ .compatible = \"idt,89hpes48t12g2\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, idt_of_match);\n\n \nstatic struct i2c_driver idt_driver = {\n\t.driver = {\n\t\t.name = IDT_NAME,\n\t\t.of_match_table = idt_of_match,\n\t},\n\t.probe = idt_probe,\n\t.remove = idt_remove,\n\t.id_table = idt_ids,\n};\n\n \nstatic int __init idt_init(void)\n{\n\tint ret;\n\n\t \n\tif (debugfs_initialized())\n\t\tcsr_dbgdir = debugfs_create_dir(\"idt_csr\", NULL);\n\n\t \n\tret = i2c_add_driver(&idt_driver);\n\tif (ret) {\n\t\tdebugfs_remove_recursive(csr_dbgdir);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(idt_init);\n\n \nstatic void __exit idt_exit(void)\n{\n\t \n\tdebugfs_remove_recursive(csr_dbgdir);\n\n\t \n\ti2c_del_driver(&idt_driver);\n}\nmodule_exit(idt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}