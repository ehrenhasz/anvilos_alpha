{
  "module_name": "eeprom.c",
  "hash_id": "b1a603d04b001b911db08adff926e1a86ddd4db299c09d8cc64a9dc0ce0fdccd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/eeprom/eeprom.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/capability.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n\n \nstatic const unsigned short normal_i2c[] = { 0x50, 0x51, 0x52, 0x53, 0x54,\n\t\t\t\t\t0x55, 0x56, 0x57, I2C_CLIENT_END };\n\n\n \n#define EEPROM_SIZE\t\t256\n\n \nenum eeprom_nature {\n\tUNKNOWN,\n\tVAIO,\n};\n\n \nstruct eeprom_data {\n\tstruct mutex update_lock;\n\tu8 valid;\t\t\t \n\tunsigned long last_updated[8];\t \n\tu8 data[EEPROM_SIZE];\t\t \n\tenum eeprom_nature nature;\n};\n\n\nstatic void eeprom_update_client(struct i2c_client *client, u8 slice)\n{\n\tstruct eeprom_data *data = i2c_get_clientdata(client);\n\tint i;\n\n\tmutex_lock(&data->update_lock);\n\n\tif (!(data->valid & (1 << slice)) ||\n\t    time_after(jiffies, data->last_updated[slice] + 300 * HZ)) {\n\t\tdev_dbg(&client->dev, \"Starting eeprom update, slice %u\\n\", slice);\n\n\t\tif (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {\n\t\t\tfor (i = slice << 5; i < (slice + 1) << 5; i += 32)\n\t\t\t\tif (i2c_smbus_read_i2c_block_data(client, i,\n\t\t\t\t\t\t\t32, data->data + i)\n\t\t\t\t\t\t\t!= 32)\n\t\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tfor (i = slice << 5; i < (slice + 1) << 5; i += 2) {\n\t\t\t\tint word = i2c_smbus_read_word_data(client, i);\n\t\t\t\tif (word < 0)\n\t\t\t\t\tgoto exit;\n\t\t\t\tdata->data[i] = word & 0xff;\n\t\t\t\tdata->data[i + 1] = word >> 8;\n\t\t\t}\n\t\t}\n\t\tdata->last_updated[slice] = jiffies;\n\t\tdata->valid |= (1 << slice);\n\t}\nexit:\n\tmutex_unlock(&data->update_lock);\n}\n\nstatic ssize_t eeprom_read(struct file *filp, struct kobject *kobj,\n\t\t\t   struct bin_attribute *bin_attr,\n\t\t\t   char *buf, loff_t off, size_t count)\n{\n\tstruct i2c_client *client = kobj_to_i2c_client(kobj);\n\tstruct eeprom_data *data = i2c_get_clientdata(client);\n\tu8 slice;\n\n\t \n\tfor (slice = off >> 5; slice <= (off + count - 1) >> 5; slice++)\n\t\teeprom_update_client(client, slice);\n\n\t \n\tif (data->nature == VAIO && !capable(CAP_SYS_ADMIN)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif ((off + i <= 0x1f) ||\n\t\t\t    (off + i >= 0xc0 && off + i <= 0xdf))\n\t\t\t\tbuf[i] = 0;\n\t\t\telse\n\t\t\t\tbuf[i] = data->data[off + i];\n\t\t}\n\t} else {\n\t\tmemcpy(buf, &data->data[off], count);\n\t}\n\n\treturn count;\n}\n\nstatic const struct bin_attribute eeprom_attr = {\n\t.attr = {\n\t\t.name = \"eeprom\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.size = EEPROM_SIZE,\n\t.read = eeprom_read,\n};\n\n \nstatic int eeprom_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\n\t \n\tif (!(adapter->class & I2C_CLASS_SPD) && client->addr >= 0x51)\n\t\treturn -ENODEV;\n\n\t \n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_WORD_DATA)\n\t && !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_I2C_BLOCK))\n\t\treturn -ENODEV;\n\n\tstrscpy(info->type, \"eeprom\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int eeprom_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct eeprom_data *data;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct eeprom_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmemset(data->data, 0xff, EEPROM_SIZE);\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->update_lock);\n\tdata->nature = UNKNOWN;\n\n\t \n\tif (client->addr == 0x57\n\t && i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_BYTE_DATA)) {\n\t\tchar name[4];\n\n\t\tname[0] = i2c_smbus_read_byte_data(client, 0x80);\n\t\tname[1] = i2c_smbus_read_byte_data(client, 0x81);\n\t\tname[2] = i2c_smbus_read_byte_data(client, 0x82);\n\t\tname[3] = i2c_smbus_read_byte_data(client, 0x83);\n\n\t\tif (!memcmp(name, \"PCG-\", 4) || !memcmp(name, \"VGN-\", 4)) {\n\t\t\tdev_info(&client->dev, \"Vaio EEPROM detected, \"\n\t\t\t\t \"enabling privacy protection\\n\");\n\t\t\tdata->nature = VAIO;\n\t\t}\n\t}\n\n\t \n\tdev_notice(&client->dev,\n\t\t   \"eeprom driver is deprecated, please use at24 instead\\n\");\n\n\t \n\treturn sysfs_create_bin_file(&client->dev.kobj, &eeprom_attr);\n}\n\nstatic void eeprom_remove(struct i2c_client *client)\n{\n\tsysfs_remove_bin_file(&client->dev.kobj, &eeprom_attr);\n}\n\nstatic const struct i2c_device_id eeprom_id[] = {\n\t{ \"eeprom\", 0 },\n\t{ }\n};\n\nstatic struct i2c_driver eeprom_driver = {\n\t.driver = {\n\t\t.name\t= \"eeprom\",\n\t},\n\t.probe\t\t= eeprom_probe,\n\t.remove\t\t= eeprom_remove,\n\t.id_table\t= eeprom_id,\n\n\t.class\t\t= I2C_CLASS_DDC | I2C_CLASS_SPD,\n\t.detect\t\t= eeprom_detect,\n\t.address_list\t= normal_i2c,\n};\n\nmodule_i2c_driver(eeprom_driver);\n\nMODULE_AUTHOR(\"Frodo Looijaard <frodol@dds.nl> and \"\n\t\t\"Philip Edelbrock <phil@netroedge.com> and \"\n\t\t\"Greg Kroah-Hartman <greg@kroah.com>\");\nMODULE_DESCRIPTION(\"I2C EEPROM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}