{
  "module_name": "pci_endpoint_test.c",
  "hash_id": "5bb4fbaf3d3e1b6ce5052a5f0d0f43d3d13642b737e7b5b87e60fe650a3a4c56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/pci_endpoint_test.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n\n#include <linux/pci_regs.h>\n\n#include <uapi/linux/pcitest.h>\n\n#define DRV_MODULE_NAME\t\t\t\t\"pci-endpoint-test\"\n\n#define IRQ_TYPE_UNDEFINED\t\t\t-1\n#define IRQ_TYPE_LEGACY\t\t\t\t0\n#define IRQ_TYPE_MSI\t\t\t\t1\n#define IRQ_TYPE_MSIX\t\t\t\t2\n\n#define PCI_ENDPOINT_TEST_MAGIC\t\t\t0x0\n\n#define PCI_ENDPOINT_TEST_COMMAND\t\t0x4\n#define COMMAND_RAISE_LEGACY_IRQ\t\tBIT(0)\n#define COMMAND_RAISE_MSI_IRQ\t\t\tBIT(1)\n#define COMMAND_RAISE_MSIX_IRQ\t\t\tBIT(2)\n#define COMMAND_READ\t\t\t\tBIT(3)\n#define COMMAND_WRITE\t\t\t\tBIT(4)\n#define COMMAND_COPY\t\t\t\tBIT(5)\n\n#define PCI_ENDPOINT_TEST_STATUS\t\t0x8\n#define STATUS_READ_SUCCESS\t\t\tBIT(0)\n#define STATUS_READ_FAIL\t\t\tBIT(1)\n#define STATUS_WRITE_SUCCESS\t\t\tBIT(2)\n#define STATUS_WRITE_FAIL\t\t\tBIT(3)\n#define STATUS_COPY_SUCCESS\t\t\tBIT(4)\n#define STATUS_COPY_FAIL\t\t\tBIT(5)\n#define STATUS_IRQ_RAISED\t\t\tBIT(6)\n#define STATUS_SRC_ADDR_INVALID\t\t\tBIT(7)\n#define STATUS_DST_ADDR_INVALID\t\t\tBIT(8)\n\n#define PCI_ENDPOINT_TEST_LOWER_SRC_ADDR\t0x0c\n#define PCI_ENDPOINT_TEST_UPPER_SRC_ADDR\t0x10\n\n#define PCI_ENDPOINT_TEST_LOWER_DST_ADDR\t0x14\n#define PCI_ENDPOINT_TEST_UPPER_DST_ADDR\t0x18\n\n#define PCI_ENDPOINT_TEST_SIZE\t\t\t0x1c\n#define PCI_ENDPOINT_TEST_CHECKSUM\t\t0x20\n\n#define PCI_ENDPOINT_TEST_IRQ_TYPE\t\t0x24\n#define PCI_ENDPOINT_TEST_IRQ_NUMBER\t\t0x28\n\n#define PCI_ENDPOINT_TEST_FLAGS\t\t\t0x2c\n#define FLAG_USE_DMA\t\t\t\tBIT(0)\n\n#define PCI_DEVICE_ID_TI_AM654\t\t\t0xb00c\n#define PCI_DEVICE_ID_TI_J7200\t\t\t0xb00f\n#define PCI_DEVICE_ID_TI_AM64\t\t\t0xb010\n#define PCI_DEVICE_ID_TI_J721S2\t\t0xb013\n#define PCI_DEVICE_ID_LS1088A\t\t\t0x80c0\n#define PCI_DEVICE_ID_IMX8\t\t\t0x0808\n\n#define is_am654_pci_dev(pdev)\t\t\\\n\t\t((pdev)->device == PCI_DEVICE_ID_TI_AM654)\n\n#define PCI_DEVICE_ID_RENESAS_R8A774A1\t\t0x0028\n#define PCI_DEVICE_ID_RENESAS_R8A774B1\t\t0x002b\n#define PCI_DEVICE_ID_RENESAS_R8A774C0\t\t0x002d\n#define PCI_DEVICE_ID_RENESAS_R8A774E1\t\t0x0025\n#define PCI_DEVICE_ID_RENESAS_R8A779F0\t\t0x0031\n\nstatic DEFINE_IDA(pci_endpoint_test_ida);\n\n#define to_endpoint_test(priv) container_of((priv), struct pci_endpoint_test, \\\n\t\t\t\t\t    miscdev)\n\nstatic bool no_msi;\nmodule_param(no_msi, bool, 0444);\nMODULE_PARM_DESC(no_msi, \"Disable MSI interrupt in pci_endpoint_test\");\n\nstatic int irq_type = IRQ_TYPE_MSI;\nmodule_param(irq_type, int, 0444);\nMODULE_PARM_DESC(irq_type, \"IRQ mode selection in pci_endpoint_test (0 - Legacy, 1 - MSI, 2 - MSI-X)\");\n\nenum pci_barno {\n\tBAR_0,\n\tBAR_1,\n\tBAR_2,\n\tBAR_3,\n\tBAR_4,\n\tBAR_5,\n};\n\nstruct pci_endpoint_test {\n\tstruct pci_dev\t*pdev;\n\tvoid __iomem\t*base;\n\tvoid __iomem\t*bar[PCI_STD_NUM_BARS];\n\tstruct completion irq_raised;\n\tint\t\tlast_irq;\n\tint\t\tnum_irqs;\n\tint\t\tirq_type;\n\t \n\tstruct mutex\tmutex;\n\tstruct miscdevice miscdev;\n\tenum pci_barno test_reg_bar;\n\tsize_t alignment;\n\tconst char *name;\n};\n\nstruct pci_endpoint_test_data {\n\tenum pci_barno test_reg_bar;\n\tsize_t alignment;\n\tint irq_type;\n};\n\nstatic inline u32 pci_endpoint_test_readl(struct pci_endpoint_test *test,\n\t\t\t\t\t  u32 offset)\n{\n\treturn readl(test->base + offset);\n}\n\nstatic inline void pci_endpoint_test_writel(struct pci_endpoint_test *test,\n\t\t\t\t\t    u32 offset, u32 value)\n{\n\twritel(value, test->base + offset);\n}\n\nstatic inline u32 pci_endpoint_test_bar_readl(struct pci_endpoint_test *test,\n\t\t\t\t\t      int bar, int offset)\n{\n\treturn readl(test->bar[bar] + offset);\n}\n\nstatic inline void pci_endpoint_test_bar_writel(struct pci_endpoint_test *test,\n\t\t\t\t\t\tint bar, u32 offset, u32 value)\n{\n\twritel(value, test->bar[bar] + offset);\n}\n\nstatic irqreturn_t pci_endpoint_test_irqhandler(int irq, void *dev_id)\n{\n\tstruct pci_endpoint_test *test = dev_id;\n\tu32 reg;\n\n\treg = pci_endpoint_test_readl(test, PCI_ENDPOINT_TEST_STATUS);\n\tif (reg & STATUS_IRQ_RAISED) {\n\t\ttest->last_irq = irq;\n\t\tcomplete(&test->irq_raised);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pci_endpoint_test_free_irq_vectors(struct pci_endpoint_test *test)\n{\n\tstruct pci_dev *pdev = test->pdev;\n\n\tpci_free_irq_vectors(pdev);\n\ttest->irq_type = IRQ_TYPE_UNDEFINED;\n}\n\nstatic bool pci_endpoint_test_alloc_irq_vectors(struct pci_endpoint_test *test,\n\t\t\t\t\t\tint type)\n{\n\tint irq = -1;\n\tstruct pci_dev *pdev = test->pdev;\n\tstruct device *dev = &pdev->dev;\n\tbool res = true;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_LEGACY:\n\t\tirq = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_LEGACY);\n\t\tif (irq < 0)\n\t\t\tdev_err(dev, \"Failed to get Legacy interrupt\\n\");\n\t\tbreak;\n\tcase IRQ_TYPE_MSI:\n\t\tirq = pci_alloc_irq_vectors(pdev, 1, 32, PCI_IRQ_MSI);\n\t\tif (irq < 0)\n\t\t\tdev_err(dev, \"Failed to get MSI interrupts\\n\");\n\t\tbreak;\n\tcase IRQ_TYPE_MSIX:\n\t\tirq = pci_alloc_irq_vectors(pdev, 1, 2048, PCI_IRQ_MSIX);\n\t\tif (irq < 0)\n\t\t\tdev_err(dev, \"Failed to get MSI-X interrupts\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid IRQ type selected\\n\");\n\t}\n\n\tif (irq < 0) {\n\t\tirq = 0;\n\t\tres = false;\n\t}\n\n\ttest->irq_type = type;\n\ttest->num_irqs = irq;\n\n\treturn res;\n}\n\nstatic void pci_endpoint_test_release_irq(struct pci_endpoint_test *test)\n{\n\tint i;\n\tstruct pci_dev *pdev = test->pdev;\n\tstruct device *dev = &pdev->dev;\n\n\tfor (i = 0; i < test->num_irqs; i++)\n\t\tdevm_free_irq(dev, pci_irq_vector(pdev, i), test);\n\n\ttest->num_irqs = 0;\n}\n\nstatic bool pci_endpoint_test_request_irq(struct pci_endpoint_test *test)\n{\n\tint i;\n\tint err;\n\tstruct pci_dev *pdev = test->pdev;\n\tstruct device *dev = &pdev->dev;\n\n\tfor (i = 0; i < test->num_irqs; i++) {\n\t\terr = devm_request_irq(dev, pci_irq_vector(pdev, i),\n\t\t\t\t       pci_endpoint_test_irqhandler,\n\t\t\t\t       IRQF_SHARED, test->name, test);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\treturn true;\n\nfail:\n\tswitch (irq_type) {\n\tcase IRQ_TYPE_LEGACY:\n\t\tdev_err(dev, \"Failed to request IRQ %d for Legacy\\n\",\n\t\t\tpci_irq_vector(pdev, i));\n\t\tbreak;\n\tcase IRQ_TYPE_MSI:\n\t\tdev_err(dev, \"Failed to request IRQ %d for MSI %d\\n\",\n\t\t\tpci_irq_vector(pdev, i),\n\t\t\ti + 1);\n\t\tbreak;\n\tcase IRQ_TYPE_MSIX:\n\t\tdev_err(dev, \"Failed to request IRQ %d for MSI-X %d\\n\",\n\t\t\tpci_irq_vector(pdev, i),\n\t\t\ti + 1);\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool pci_endpoint_test_bar(struct pci_endpoint_test *test,\n\t\t\t\t  enum pci_barno barno)\n{\n\tint j;\n\tu32 val;\n\tint size;\n\tstruct pci_dev *pdev = test->pdev;\n\n\tif (!test->bar[barno])\n\t\treturn false;\n\n\tsize = pci_resource_len(pdev, barno);\n\n\tif (barno == test->test_reg_bar)\n\t\tsize = 0x4;\n\n\tfor (j = 0; j < size; j += 4)\n\t\tpci_endpoint_test_bar_writel(test, barno, j, 0xA0A0A0A0);\n\n\tfor (j = 0; j < size; j += 4) {\n\t\tval = pci_endpoint_test_bar_readl(test, barno, j);\n\t\tif (val != 0xA0A0A0A0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool pci_endpoint_test_legacy_irq(struct pci_endpoint_test *test)\n{\n\tu32 val;\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_IRQ_TYPE,\n\t\t\t\t IRQ_TYPE_LEGACY);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_IRQ_NUMBER, 0);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_COMMAND,\n\t\t\t\t COMMAND_RAISE_LEGACY_IRQ);\n\tval = wait_for_completion_timeout(&test->irq_raised,\n\t\t\t\t\t  msecs_to_jiffies(1000));\n\tif (!val)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool pci_endpoint_test_msi_irq(struct pci_endpoint_test *test,\n\t\t\t\t       u16 msi_num, bool msix)\n{\n\tu32 val;\n\tstruct pci_dev *pdev = test->pdev;\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_IRQ_TYPE,\n\t\t\t\t msix ? IRQ_TYPE_MSIX : IRQ_TYPE_MSI);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_IRQ_NUMBER, msi_num);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_COMMAND,\n\t\t\t\t msix ? COMMAND_RAISE_MSIX_IRQ :\n\t\t\t\t COMMAND_RAISE_MSI_IRQ);\n\tval = wait_for_completion_timeout(&test->irq_raised,\n\t\t\t\t\t  msecs_to_jiffies(1000));\n\tif (!val)\n\t\treturn false;\n\n\treturn pci_irq_vector(pdev, msi_num - 1) == test->last_irq;\n}\n\nstatic int pci_endpoint_test_validate_xfer_params(struct device *dev,\n\t\tstruct pci_endpoint_test_xfer_param *param, size_t alignment)\n{\n\tif (!param->size) {\n\t\tdev_dbg(dev, \"Data size is zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (param->size > SIZE_MAX - alignment) {\n\t\tdev_dbg(dev, \"Maximum transfer data size exceeded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool pci_endpoint_test_copy(struct pci_endpoint_test *test,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct pci_endpoint_test_xfer_param param;\n\tbool ret = false;\n\tvoid *src_addr;\n\tvoid *dst_addr;\n\tu32 flags = 0;\n\tbool use_dma;\n\tsize_t size;\n\tdma_addr_t src_phys_addr;\n\tdma_addr_t dst_phys_addr;\n\tstruct pci_dev *pdev = test->pdev;\n\tstruct device *dev = &pdev->dev;\n\tvoid *orig_src_addr;\n\tdma_addr_t orig_src_phys_addr;\n\tvoid *orig_dst_addr;\n\tdma_addr_t orig_dst_phys_addr;\n\tsize_t offset;\n\tsize_t alignment = test->alignment;\n\tint irq_type = test->irq_type;\n\tu32 src_crc32;\n\tu32 dst_crc32;\n\tint err;\n\n\terr = copy_from_user(&param, (void __user *)arg, sizeof(param));\n\tif (err) {\n\t\tdev_err(dev, \"Failed to get transfer param\\n\");\n\t\treturn false;\n\t}\n\n\terr = pci_endpoint_test_validate_xfer_params(dev, &param, alignment);\n\tif (err)\n\t\treturn false;\n\n\tsize = param.size;\n\n\tuse_dma = !!(param.flags & PCITEST_FLAGS_USE_DMA);\n\tif (use_dma)\n\t\tflags |= FLAG_USE_DMA;\n\n\tif (irq_type < IRQ_TYPE_LEGACY || irq_type > IRQ_TYPE_MSIX) {\n\t\tdev_err(dev, \"Invalid IRQ type option\\n\");\n\t\tgoto err;\n\t}\n\n\torig_src_addr = kzalloc(size + alignment, GFP_KERNEL);\n\tif (!orig_src_addr) {\n\t\tdev_err(dev, \"Failed to allocate source buffer\\n\");\n\t\tret = false;\n\t\tgoto err;\n\t}\n\n\tget_random_bytes(orig_src_addr, size + alignment);\n\torig_src_phys_addr = dma_map_single(dev, orig_src_addr,\n\t\t\t\t\t    size + alignment, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, orig_src_phys_addr)) {\n\t\tdev_err(dev, \"failed to map source buffer address\\n\");\n\t\tret = false;\n\t\tgoto err_src_phys_addr;\n\t}\n\n\tif (alignment && !IS_ALIGNED(orig_src_phys_addr, alignment)) {\n\t\tsrc_phys_addr = PTR_ALIGN(orig_src_phys_addr, alignment);\n\t\toffset = src_phys_addr - orig_src_phys_addr;\n\t\tsrc_addr = orig_src_addr + offset;\n\t} else {\n\t\tsrc_phys_addr = orig_src_phys_addr;\n\t\tsrc_addr = orig_src_addr;\n\t}\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_LOWER_SRC_ADDR,\n\t\t\t\t lower_32_bits(src_phys_addr));\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_UPPER_SRC_ADDR,\n\t\t\t\t upper_32_bits(src_phys_addr));\n\n\tsrc_crc32 = crc32_le(~0, src_addr, size);\n\n\torig_dst_addr = kzalloc(size + alignment, GFP_KERNEL);\n\tif (!orig_dst_addr) {\n\t\tdev_err(dev, \"Failed to allocate destination address\\n\");\n\t\tret = false;\n\t\tgoto err_dst_addr;\n\t}\n\n\torig_dst_phys_addr = dma_map_single(dev, orig_dst_addr,\n\t\t\t\t\t    size + alignment, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, orig_dst_phys_addr)) {\n\t\tdev_err(dev, \"failed to map destination buffer address\\n\");\n\t\tret = false;\n\t\tgoto err_dst_phys_addr;\n\t}\n\n\tif (alignment && !IS_ALIGNED(orig_dst_phys_addr, alignment)) {\n\t\tdst_phys_addr = PTR_ALIGN(orig_dst_phys_addr, alignment);\n\t\toffset = dst_phys_addr - orig_dst_phys_addr;\n\t\tdst_addr = orig_dst_addr + offset;\n\t} else {\n\t\tdst_phys_addr = orig_dst_phys_addr;\n\t\tdst_addr = orig_dst_addr;\n\t}\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_LOWER_DST_ADDR,\n\t\t\t\t lower_32_bits(dst_phys_addr));\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_UPPER_DST_ADDR,\n\t\t\t\t upper_32_bits(dst_phys_addr));\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_SIZE,\n\t\t\t\t size);\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_FLAGS, flags);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_IRQ_TYPE, irq_type);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_IRQ_NUMBER, 1);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_COMMAND,\n\t\t\t\t COMMAND_COPY);\n\n\twait_for_completion(&test->irq_raised);\n\n\tdma_unmap_single(dev, orig_dst_phys_addr, size + alignment,\n\t\t\t DMA_FROM_DEVICE);\n\n\tdst_crc32 = crc32_le(~0, dst_addr, size);\n\tif (dst_crc32 == src_crc32)\n\t\tret = true;\n\nerr_dst_phys_addr:\n\tkfree(orig_dst_addr);\n\nerr_dst_addr:\n\tdma_unmap_single(dev, orig_src_phys_addr, size + alignment,\n\t\t\t DMA_TO_DEVICE);\n\nerr_src_phys_addr:\n\tkfree(orig_src_addr);\n\nerr:\n\treturn ret;\n}\n\nstatic bool pci_endpoint_test_write(struct pci_endpoint_test *test,\n\t\t\t\t    unsigned long arg)\n{\n\tstruct pci_endpoint_test_xfer_param param;\n\tbool ret = false;\n\tu32 flags = 0;\n\tbool use_dma;\n\tu32 reg;\n\tvoid *addr;\n\tdma_addr_t phys_addr;\n\tstruct pci_dev *pdev = test->pdev;\n\tstruct device *dev = &pdev->dev;\n\tvoid *orig_addr;\n\tdma_addr_t orig_phys_addr;\n\tsize_t offset;\n\tsize_t alignment = test->alignment;\n\tint irq_type = test->irq_type;\n\tsize_t size;\n\tu32 crc32;\n\tint err;\n\n\terr = copy_from_user(&param, (void __user *)arg, sizeof(param));\n\tif (err != 0) {\n\t\tdev_err(dev, \"Failed to get transfer param\\n\");\n\t\treturn false;\n\t}\n\n\terr = pci_endpoint_test_validate_xfer_params(dev, &param, alignment);\n\tif (err)\n\t\treturn false;\n\n\tsize = param.size;\n\n\tuse_dma = !!(param.flags & PCITEST_FLAGS_USE_DMA);\n\tif (use_dma)\n\t\tflags |= FLAG_USE_DMA;\n\n\tif (irq_type < IRQ_TYPE_LEGACY || irq_type > IRQ_TYPE_MSIX) {\n\t\tdev_err(dev, \"Invalid IRQ type option\\n\");\n\t\tgoto err;\n\t}\n\n\torig_addr = kzalloc(size + alignment, GFP_KERNEL);\n\tif (!orig_addr) {\n\t\tdev_err(dev, \"Failed to allocate address\\n\");\n\t\tret = false;\n\t\tgoto err;\n\t}\n\n\tget_random_bytes(orig_addr, size + alignment);\n\n\torig_phys_addr = dma_map_single(dev, orig_addr, size + alignment,\n\t\t\t\t\tDMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, orig_phys_addr)) {\n\t\tdev_err(dev, \"failed to map source buffer address\\n\");\n\t\tret = false;\n\t\tgoto err_phys_addr;\n\t}\n\n\tif (alignment && !IS_ALIGNED(orig_phys_addr, alignment)) {\n\t\tphys_addr =  PTR_ALIGN(orig_phys_addr, alignment);\n\t\toffset = phys_addr - orig_phys_addr;\n\t\taddr = orig_addr + offset;\n\t} else {\n\t\tphys_addr = orig_phys_addr;\n\t\taddr = orig_addr;\n\t}\n\n\tcrc32 = crc32_le(~0, addr, size);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_CHECKSUM,\n\t\t\t\t crc32);\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_LOWER_SRC_ADDR,\n\t\t\t\t lower_32_bits(phys_addr));\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_UPPER_SRC_ADDR,\n\t\t\t\t upper_32_bits(phys_addr));\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_SIZE, size);\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_FLAGS, flags);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_IRQ_TYPE, irq_type);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_IRQ_NUMBER, 1);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_COMMAND,\n\t\t\t\t COMMAND_READ);\n\n\twait_for_completion(&test->irq_raised);\n\n\treg = pci_endpoint_test_readl(test, PCI_ENDPOINT_TEST_STATUS);\n\tif (reg & STATUS_READ_SUCCESS)\n\t\tret = true;\n\n\tdma_unmap_single(dev, orig_phys_addr, size + alignment,\n\t\t\t DMA_TO_DEVICE);\n\nerr_phys_addr:\n\tkfree(orig_addr);\n\nerr:\n\treturn ret;\n}\n\nstatic bool pci_endpoint_test_read(struct pci_endpoint_test *test,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct pci_endpoint_test_xfer_param param;\n\tbool ret = false;\n\tu32 flags = 0;\n\tbool use_dma;\n\tsize_t size;\n\tvoid *addr;\n\tdma_addr_t phys_addr;\n\tstruct pci_dev *pdev = test->pdev;\n\tstruct device *dev = &pdev->dev;\n\tvoid *orig_addr;\n\tdma_addr_t orig_phys_addr;\n\tsize_t offset;\n\tsize_t alignment = test->alignment;\n\tint irq_type = test->irq_type;\n\tu32 crc32;\n\tint err;\n\n\terr = copy_from_user(&param, (void __user *)arg, sizeof(param));\n\tif (err) {\n\t\tdev_err(dev, \"Failed to get transfer param\\n\");\n\t\treturn false;\n\t}\n\n\terr = pci_endpoint_test_validate_xfer_params(dev, &param, alignment);\n\tif (err)\n\t\treturn false;\n\n\tsize = param.size;\n\n\tuse_dma = !!(param.flags & PCITEST_FLAGS_USE_DMA);\n\tif (use_dma)\n\t\tflags |= FLAG_USE_DMA;\n\n\tif (irq_type < IRQ_TYPE_LEGACY || irq_type > IRQ_TYPE_MSIX) {\n\t\tdev_err(dev, \"Invalid IRQ type option\\n\");\n\t\tgoto err;\n\t}\n\n\torig_addr = kzalloc(size + alignment, GFP_KERNEL);\n\tif (!orig_addr) {\n\t\tdev_err(dev, \"Failed to allocate destination address\\n\");\n\t\tret = false;\n\t\tgoto err;\n\t}\n\n\torig_phys_addr = dma_map_single(dev, orig_addr, size + alignment,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, orig_phys_addr)) {\n\t\tdev_err(dev, \"failed to map source buffer address\\n\");\n\t\tret = false;\n\t\tgoto err_phys_addr;\n\t}\n\n\tif (alignment && !IS_ALIGNED(orig_phys_addr, alignment)) {\n\t\tphys_addr = PTR_ALIGN(orig_phys_addr, alignment);\n\t\toffset = phys_addr - orig_phys_addr;\n\t\taddr = orig_addr + offset;\n\t} else {\n\t\tphys_addr = orig_phys_addr;\n\t\taddr = orig_addr;\n\t}\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_LOWER_DST_ADDR,\n\t\t\t\t lower_32_bits(phys_addr));\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_UPPER_DST_ADDR,\n\t\t\t\t upper_32_bits(phys_addr));\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_SIZE, size);\n\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_FLAGS, flags);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_IRQ_TYPE, irq_type);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_IRQ_NUMBER, 1);\n\tpci_endpoint_test_writel(test, PCI_ENDPOINT_TEST_COMMAND,\n\t\t\t\t COMMAND_WRITE);\n\n\twait_for_completion(&test->irq_raised);\n\n\tdma_unmap_single(dev, orig_phys_addr, size + alignment,\n\t\t\t DMA_FROM_DEVICE);\n\n\tcrc32 = crc32_le(~0, addr, size);\n\tif (crc32 == pci_endpoint_test_readl(test, PCI_ENDPOINT_TEST_CHECKSUM))\n\t\tret = true;\n\nerr_phys_addr:\n\tkfree(orig_addr);\nerr:\n\treturn ret;\n}\n\nstatic bool pci_endpoint_test_clear_irq(struct pci_endpoint_test *test)\n{\n\tpci_endpoint_test_release_irq(test);\n\tpci_endpoint_test_free_irq_vectors(test);\n\treturn true;\n}\n\nstatic bool pci_endpoint_test_set_irq(struct pci_endpoint_test *test,\n\t\t\t\t      int req_irq_type)\n{\n\tstruct pci_dev *pdev = test->pdev;\n\tstruct device *dev = &pdev->dev;\n\n\tif (req_irq_type < IRQ_TYPE_LEGACY || req_irq_type > IRQ_TYPE_MSIX) {\n\t\tdev_err(dev, \"Invalid IRQ type option\\n\");\n\t\treturn false;\n\t}\n\n\tif (test->irq_type == req_irq_type)\n\t\treturn true;\n\n\tpci_endpoint_test_release_irq(test);\n\tpci_endpoint_test_free_irq_vectors(test);\n\n\tif (!pci_endpoint_test_alloc_irq_vectors(test, req_irq_type))\n\t\tgoto err;\n\n\tif (!pci_endpoint_test_request_irq(test))\n\t\tgoto err;\n\n\treturn true;\n\nerr:\n\tpci_endpoint_test_free_irq_vectors(test);\n\treturn false;\n}\n\nstatic long pci_endpoint_test_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t    unsigned long arg)\n{\n\tint ret = -EINVAL;\n\tenum pci_barno bar;\n\tstruct pci_endpoint_test *test = to_endpoint_test(file->private_data);\n\tstruct pci_dev *pdev = test->pdev;\n\n\tmutex_lock(&test->mutex);\n\n\treinit_completion(&test->irq_raised);\n\ttest->last_irq = -ENODATA;\n\n\tswitch (cmd) {\n\tcase PCITEST_BAR:\n\t\tbar = arg;\n\t\tif (bar > BAR_5)\n\t\t\tgoto ret;\n\t\tif (is_am654_pci_dev(pdev) && bar == BAR_0)\n\t\t\tgoto ret;\n\t\tret = pci_endpoint_test_bar(test, bar);\n\t\tbreak;\n\tcase PCITEST_LEGACY_IRQ:\n\t\tret = pci_endpoint_test_legacy_irq(test);\n\t\tbreak;\n\tcase PCITEST_MSI:\n\tcase PCITEST_MSIX:\n\t\tret = pci_endpoint_test_msi_irq(test, arg, cmd == PCITEST_MSIX);\n\t\tbreak;\n\tcase PCITEST_WRITE:\n\t\tret = pci_endpoint_test_write(test, arg);\n\t\tbreak;\n\tcase PCITEST_READ:\n\t\tret = pci_endpoint_test_read(test, arg);\n\t\tbreak;\n\tcase PCITEST_COPY:\n\t\tret = pci_endpoint_test_copy(test, arg);\n\t\tbreak;\n\tcase PCITEST_SET_IRQTYPE:\n\t\tret = pci_endpoint_test_set_irq(test, arg);\n\t\tbreak;\n\tcase PCITEST_GET_IRQTYPE:\n\t\tret = irq_type;\n\t\tbreak;\n\tcase PCITEST_CLEAR_IRQ:\n\t\tret = pci_endpoint_test_clear_irq(test);\n\t\tbreak;\n\t}\n\nret:\n\tmutex_unlock(&test->mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations pci_endpoint_test_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = pci_endpoint_test_ioctl,\n};\n\nstatic int pci_endpoint_test_probe(struct pci_dev *pdev,\n\t\t\t\t   const struct pci_device_id *ent)\n{\n\tint err;\n\tint id;\n\tchar name[24];\n\tenum pci_barno bar;\n\tvoid __iomem *base;\n\tstruct device *dev = &pdev->dev;\n\tstruct pci_endpoint_test *test;\n\tstruct pci_endpoint_test_data *data;\n\tenum pci_barno test_reg_bar = BAR_0;\n\tstruct miscdevice *misc_device;\n\n\tif (pci_is_bridge(pdev))\n\t\treturn -ENODEV;\n\n\ttest = devm_kzalloc(dev, sizeof(*test), GFP_KERNEL);\n\tif (!test)\n\t\treturn -ENOMEM;\n\n\ttest->test_reg_bar = 0;\n\ttest->alignment = 0;\n\ttest->pdev = pdev;\n\ttest->irq_type = IRQ_TYPE_UNDEFINED;\n\n\tif (no_msi)\n\t\tirq_type = IRQ_TYPE_LEGACY;\n\n\tdata = (struct pci_endpoint_test_data *)ent->driver_data;\n\tif (data) {\n\t\ttest_reg_bar = data->test_reg_bar;\n\t\ttest->test_reg_bar = test_reg_bar;\n\t\ttest->alignment = data->alignment;\n\t\tirq_type = data->irq_type;\n\t}\n\n\tinit_completion(&test->irq_raised);\n\tmutex_init(&test->mutex);\n\n\tif ((dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(48)) != 0) &&\n\t    dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)) != 0) {\n\t\tdev_err(dev, \"Cannot set DMA mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot enable PCI device\\n\");\n\t\treturn err;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_MODULE_NAME);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot obtain PCI resources\\n\");\n\t\tgoto err_disable_pdev;\n\t}\n\n\tpci_set_master(pdev);\n\n\tif (!pci_endpoint_test_alloc_irq_vectors(test, irq_type)) {\n\t\terr = -EINVAL;\n\t\tgoto err_disable_irq;\n\t}\n\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar++) {\n\t\tif (pci_resource_flags(pdev, bar) & IORESOURCE_MEM) {\n\t\t\tbase = pci_ioremap_bar(pdev, bar);\n\t\t\tif (!base) {\n\t\t\t\tdev_err(dev, \"Failed to read BAR%d\\n\", bar);\n\t\t\t\tWARN_ON(bar == test_reg_bar);\n\t\t\t}\n\t\t\ttest->bar[bar] = base;\n\t\t}\n\t}\n\n\ttest->base = test->bar[test_reg_bar];\n\tif (!test->base) {\n\t\terr = -ENOMEM;\n\t\tdev_err(dev, \"Cannot perform PCI test without BAR%d\\n\",\n\t\t\ttest_reg_bar);\n\t\tgoto err_iounmap;\n\t}\n\n\tpci_set_drvdata(pdev, test);\n\n\tid = ida_simple_get(&pci_endpoint_test_ida, 0, 0, GFP_KERNEL);\n\tif (id < 0) {\n\t\terr = id;\n\t\tdev_err(dev, \"Unable to get id\\n\");\n\t\tgoto err_iounmap;\n\t}\n\n\tsnprintf(name, sizeof(name), DRV_MODULE_NAME \".%d\", id);\n\ttest->name = kstrdup(name, GFP_KERNEL);\n\tif (!test->name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_ida_remove;\n\t}\n\n\tif (!pci_endpoint_test_request_irq(test)) {\n\t\terr = -EINVAL;\n\t\tgoto err_kfree_test_name;\n\t}\n\n\tmisc_device = &test->miscdev;\n\tmisc_device->minor = MISC_DYNAMIC_MINOR;\n\tmisc_device->name = kstrdup(name, GFP_KERNEL);\n\tif (!misc_device->name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_irq;\n\t}\n\tmisc_device->parent = &pdev->dev;\n\tmisc_device->fops = &pci_endpoint_test_fops;\n\n\terr = misc_register(misc_device);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register device\\n\");\n\t\tgoto err_kfree_name;\n\t}\n\n\treturn 0;\n\nerr_kfree_name:\n\tkfree(misc_device->name);\n\nerr_release_irq:\n\tpci_endpoint_test_release_irq(test);\n\nerr_kfree_test_name:\n\tkfree(test->name);\n\nerr_ida_remove:\n\tida_simple_remove(&pci_endpoint_test_ida, id);\n\nerr_iounmap:\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar++) {\n\t\tif (test->bar[bar])\n\t\t\tpci_iounmap(pdev, test->bar[bar]);\n\t}\n\nerr_disable_irq:\n\tpci_endpoint_test_free_irq_vectors(test);\n\tpci_release_regions(pdev);\n\nerr_disable_pdev:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void pci_endpoint_test_remove(struct pci_dev *pdev)\n{\n\tint id;\n\tenum pci_barno bar;\n\tstruct pci_endpoint_test *test = pci_get_drvdata(pdev);\n\tstruct miscdevice *misc_device = &test->miscdev;\n\n\tif (sscanf(misc_device->name, DRV_MODULE_NAME \".%d\", &id) != 1)\n\t\treturn;\n\tif (id < 0)\n\t\treturn;\n\n\tpci_endpoint_test_release_irq(test);\n\tpci_endpoint_test_free_irq_vectors(test);\n\n\tmisc_deregister(&test->miscdev);\n\tkfree(misc_device->name);\n\tkfree(test->name);\n\tida_simple_remove(&pci_endpoint_test_ida, id);\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar++) {\n\t\tif (test->bar[bar])\n\t\t\tpci_iounmap(pdev, test->bar[bar]);\n\t}\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_endpoint_test_data default_data = {\n\t.test_reg_bar = BAR_0,\n\t.alignment = SZ_4K,\n\t.irq_type = IRQ_TYPE_MSI,\n};\n\nstatic const struct pci_endpoint_test_data am654_data = {\n\t.test_reg_bar = BAR_2,\n\t.alignment = SZ_64K,\n\t.irq_type = IRQ_TYPE_MSI,\n};\n\nstatic const struct pci_endpoint_test_data j721e_data = {\n\t.alignment = 256,\n\t.irq_type = IRQ_TYPE_MSI,\n};\n\nstatic const struct pci_device_id pci_endpoint_test_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_DRA74x),\n\t  .driver_data = (kernel_ulong_t)&default_data,\n\t},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_DRA72x),\n\t  .driver_data = (kernel_ulong_t)&default_data,\n\t},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, 0x81c0),\n\t  .driver_data = (kernel_ulong_t)&default_data,\n\t},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_IMX8),},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_LS1088A),\n\t  .driver_data = (kernel_ulong_t)&default_data,\n\t},\n\t{ PCI_DEVICE_DATA(SYNOPSYS, EDDA, NULL) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_AM654),\n\t  .driver_data = (kernel_ulong_t)&am654_data\n\t},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_RENESAS, PCI_DEVICE_ID_RENESAS_R8A774A1),},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_RENESAS, PCI_DEVICE_ID_RENESAS_R8A774B1),},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_RENESAS, PCI_DEVICE_ID_RENESAS_R8A774C0),},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_RENESAS, PCI_DEVICE_ID_RENESAS_R8A774E1),},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_RENESAS, PCI_DEVICE_ID_RENESAS_R8A779F0),\n\t  .driver_data = (kernel_ulong_t)&default_data,\n\t},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_J721E),\n\t  .driver_data = (kernel_ulong_t)&j721e_data,\n\t},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_J7200),\n\t  .driver_data = (kernel_ulong_t)&j721e_data,\n\t},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_AM64),\n\t  .driver_data = (kernel_ulong_t)&j721e_data,\n\t},\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_J721S2),\n\t  .driver_data = (kernel_ulong_t)&j721e_data,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, pci_endpoint_test_tbl);\n\nstatic struct pci_driver pci_endpoint_test_driver = {\n\t.name\t\t= DRV_MODULE_NAME,\n\t.id_table\t= pci_endpoint_test_tbl,\n\t.probe\t\t= pci_endpoint_test_probe,\n\t.remove\t\t= pci_endpoint_test_remove,\n\t.sriov_configure = pci_sriov_configure_simple,\n};\nmodule_pci_driver(pci_endpoint_test_driver);\n\nMODULE_DESCRIPTION(\"PCI ENDPOINT TEST HOST DRIVER\");\nMODULE_AUTHOR(\"Kishon Vijay Abraham I <kishon@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}