{
  "module_name": "xpc_channel.c",
  "hash_id": "b149900fdbc4bc85f265116dca127439cdae1c1ee02b1481836a4a91dfa1e2d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sgi-xp/xpc_channel.c",
  "human_readable_source": " \n\n \n\n#include <linux/device.h>\n#include \"xpc.h\"\n\n \nstatic void\nxpc_process_connect(struct xpc_channel *ch, unsigned long *irq_flags)\n{\n\tenum xp_retval ret;\n\n\tlockdep_assert_held(&ch->lock);\n\n\tif (!(ch->flags & XPC_C_OPENREQUEST) ||\n\t    !(ch->flags & XPC_C_ROPENREQUEST)) {\n\t\t \n\t\treturn;\n\t}\n\tDBUG_ON(!(ch->flags & XPC_C_CONNECTING));\n\n\tif (!(ch->flags & XPC_C_SETUP)) {\n\t\tspin_unlock_irqrestore(&ch->lock, *irq_flags);\n\t\tret = xpc_arch_ops.setup_msg_structures(ch);\n\t\tspin_lock_irqsave(&ch->lock, *irq_flags);\n\n\t\tif (ret != xpSuccess)\n\t\t\tXPC_DISCONNECT_CHANNEL(ch, ret, irq_flags);\n\t\telse\n\t\t\tch->flags |= XPC_C_SETUP;\n\n\t\tif (ch->flags & XPC_C_DISCONNECTING)\n\t\t\treturn;\n\t}\n\n\tif (!(ch->flags & XPC_C_OPENREPLY)) {\n\t\tch->flags |= XPC_C_OPENREPLY;\n\t\txpc_arch_ops.send_chctl_openreply(ch, irq_flags);\n\t}\n\n\tif (!(ch->flags & XPC_C_ROPENREPLY))\n\t\treturn;\n\n\tif (!(ch->flags & XPC_C_OPENCOMPLETE)) {\n\t\tch->flags |= (XPC_C_OPENCOMPLETE | XPC_C_CONNECTED);\n\t\txpc_arch_ops.send_chctl_opencomplete(ch, irq_flags);\n\t}\n\n\tif (!(ch->flags & XPC_C_ROPENCOMPLETE))\n\t\treturn;\n\n\tdev_info(xpc_chan, \"channel %d to partition %d connected\\n\",\n\t\t ch->number, ch->partid);\n\n\tch->flags = (XPC_C_CONNECTED | XPC_C_SETUP);\t \n}\n\n \nstatic void\nxpc_process_disconnect(struct xpc_channel *ch, unsigned long *irq_flags)\n{\n\tstruct xpc_partition *part = &xpc_partitions[ch->partid];\n\tu32 channel_was_connected = (ch->flags & XPC_C_WASCONNECTED);\n\n\tlockdep_assert_held(&ch->lock);\n\n\tif (!(ch->flags & XPC_C_DISCONNECTING))\n\t\treturn;\n\n\tDBUG_ON(!(ch->flags & XPC_C_CLOSEREQUEST));\n\n\t \n\n\tif (atomic_read(&ch->kthreads_assigned) > 0 ||\n\t    atomic_read(&ch->references) > 0) {\n\t\treturn;\n\t}\n\tDBUG_ON((ch->flags & XPC_C_CONNECTEDCALLOUT_MADE) &&\n\t\t!(ch->flags & XPC_C_DISCONNECTINGCALLOUT_MADE));\n\n\tif (part->act_state == XPC_P_AS_DEACTIVATING) {\n\t\t \n\t\tif (xpc_arch_ops.partition_engaged(ch->partid))\n\t\t\treturn;\n\n\t} else {\n\n\t\t \n\n\t\tif (!(ch->flags & XPC_C_RCLOSEREQUEST))\n\t\t\treturn;\n\n\t\tif (!(ch->flags & XPC_C_CLOSEREPLY)) {\n\t\t\tch->flags |= XPC_C_CLOSEREPLY;\n\t\t\txpc_arch_ops.send_chctl_closereply(ch, irq_flags);\n\t\t}\n\n\t\tif (!(ch->flags & XPC_C_RCLOSEREPLY))\n\t\t\treturn;\n\t}\n\n\t \n\tif (atomic_read(&ch->n_to_notify) > 0) {\n\t\t \n\t\txpc_arch_ops.notify_senders_of_disconnect(ch);\n\t}\n\n\t \n\n\tif (ch->flags & XPC_C_DISCONNECTINGCALLOUT_MADE) {\n\t\tspin_unlock_irqrestore(&ch->lock, *irq_flags);\n\t\txpc_disconnect_callout(ch, xpDisconnected);\n\t\tspin_lock_irqsave(&ch->lock, *irq_flags);\n\t}\n\n\tDBUG_ON(atomic_read(&ch->n_to_notify) != 0);\n\n\t \n\txpc_arch_ops.teardown_msg_structures(ch);\n\n\tch->func = NULL;\n\tch->key = NULL;\n\tch->entry_size = 0;\n\tch->local_nentries = 0;\n\tch->remote_nentries = 0;\n\tch->kthreads_assigned_limit = 0;\n\tch->kthreads_idle_limit = 0;\n\n\t \n\tch->flags = (XPC_C_DISCONNECTED | (ch->flags & XPC_C_WDISCONNECT));\n\n\tatomic_dec(&part->nchannels_active);\n\n\tif (channel_was_connected) {\n\t\tdev_info(xpc_chan, \"channel %d to partition %d disconnected, \"\n\t\t\t \"reason=%d\\n\", ch->number, ch->partid, ch->reason);\n\t}\n\n\tif (ch->flags & XPC_C_WDISCONNECT) {\n\t\t \n\t\tcomplete(&ch->wdisconnect_wait);\n\t} else if (ch->delayed_chctl_flags) {\n\t\tif (part->act_state != XPC_P_AS_DEACTIVATING) {\n\t\t\t \n\t\t\tspin_lock(&part->chctl_lock);\n\t\t\tpart->chctl.flags[ch->number] |=\n\t\t\t    ch->delayed_chctl_flags;\n\t\t\tspin_unlock(&part->chctl_lock);\n\t\t}\n\t\tch->delayed_chctl_flags = 0;\n\t}\n}\n\n \nstatic void\nxpc_process_openclose_chctl_flags(struct xpc_partition *part, int ch_number,\n\t\t\t\t  u8 chctl_flags)\n{\n\tunsigned long irq_flags;\n\tstruct xpc_openclose_args *args =\n\t    &part->remote_openclose_args[ch_number];\n\tstruct xpc_channel *ch = &part->channels[ch_number];\n\tenum xp_retval reason;\n\tenum xp_retval ret;\n\tint create_kthread = 0;\n\n\tspin_lock_irqsave(&ch->lock, irq_flags);\n\nagain:\n\n\tif ((ch->flags & XPC_C_DISCONNECTED) &&\n\t    (ch->flags & XPC_C_WDISCONNECT)) {\n\t\t \n\t\tch->delayed_chctl_flags |= chctl_flags;\n\t\tgoto out;\n\t}\n\n\tif (chctl_flags & XPC_CHCTL_CLOSEREQUEST) {\n\n\t\tdev_dbg(xpc_chan, \"XPC_CHCTL_CLOSEREQUEST (reason=%d) received \"\n\t\t\t\"from partid=%d, channel=%d\\n\", args->reason,\n\t\t\tch->partid, ch->number);\n\n\t\t \n\n\t\tif (ch->flags & XPC_C_RCLOSEREQUEST) {\n\t\t\tDBUG_ON(!(ch->flags & XPC_C_DISCONNECTING));\n\t\t\tDBUG_ON(!(ch->flags & XPC_C_CLOSEREQUEST));\n\t\t\tDBUG_ON(!(ch->flags & XPC_C_CLOSEREPLY));\n\t\t\tDBUG_ON(ch->flags & XPC_C_RCLOSEREPLY);\n\n\t\t\tDBUG_ON(!(chctl_flags & XPC_CHCTL_CLOSEREPLY));\n\t\t\tchctl_flags &= ~XPC_CHCTL_CLOSEREPLY;\n\t\t\tch->flags |= XPC_C_RCLOSEREPLY;\n\n\t\t\t \n\t\t\txpc_process_disconnect(ch, &irq_flags);\n\t\t\tDBUG_ON(!(ch->flags & XPC_C_DISCONNECTED));\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (ch->flags & XPC_C_DISCONNECTED) {\n\t\t\tif (!(chctl_flags & XPC_CHCTL_OPENREQUEST)) {\n\t\t\t\tif (part->chctl.flags[ch_number] &\n\t\t\t\t    XPC_CHCTL_OPENREQUEST) {\n\n\t\t\t\t\tDBUG_ON(ch->delayed_chctl_flags != 0);\n\t\t\t\t\tspin_lock(&part->chctl_lock);\n\t\t\t\t\tpart->chctl.flags[ch_number] |=\n\t\t\t\t\t    XPC_CHCTL_CLOSEREQUEST;\n\t\t\t\t\tspin_unlock(&part->chctl_lock);\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tXPC_SET_REASON(ch, 0, 0);\n\t\t\tch->flags &= ~XPC_C_DISCONNECTED;\n\n\t\t\tatomic_inc(&part->nchannels_active);\n\t\t\tch->flags |= (XPC_C_CONNECTING | XPC_C_ROPENREQUEST);\n\t\t}\n\n\t\tchctl_flags &= ~(XPC_CHCTL_OPENREQUEST | XPC_CHCTL_OPENREPLY |\n\t\t    XPC_CHCTL_OPENCOMPLETE);\n\n\t\t \n\n\t\tch->flags |= XPC_C_RCLOSEREQUEST;\n\n\t\tif (!(ch->flags & XPC_C_DISCONNECTING)) {\n\t\t\treason = args->reason;\n\t\t\tif (reason <= xpSuccess || reason > xpUnknownReason)\n\t\t\t\treason = xpUnknownReason;\n\t\t\telse if (reason == xpUnregistering)\n\t\t\t\treason = xpOtherUnregistering;\n\n\t\t\tXPC_DISCONNECT_CHANNEL(ch, reason, &irq_flags);\n\n\t\t\tDBUG_ON(chctl_flags & XPC_CHCTL_CLOSEREPLY);\n\t\t\tgoto out;\n\t\t}\n\n\t\txpc_process_disconnect(ch, &irq_flags);\n\t}\n\n\tif (chctl_flags & XPC_CHCTL_CLOSEREPLY) {\n\n\t\tdev_dbg(xpc_chan, \"XPC_CHCTL_CLOSEREPLY received from partid=\"\n\t\t\t\"%d, channel=%d\\n\", ch->partid, ch->number);\n\n\t\tif (ch->flags & XPC_C_DISCONNECTED) {\n\t\t\tDBUG_ON(part->act_state != XPC_P_AS_DEACTIVATING);\n\t\t\tgoto out;\n\t\t}\n\n\t\tDBUG_ON(!(ch->flags & XPC_C_CLOSEREQUEST));\n\n\t\tif (!(ch->flags & XPC_C_RCLOSEREQUEST)) {\n\t\t\tif (part->chctl.flags[ch_number] &\n\t\t\t    XPC_CHCTL_CLOSEREQUEST) {\n\n\t\t\t\tDBUG_ON(ch->delayed_chctl_flags != 0);\n\t\t\t\tspin_lock(&part->chctl_lock);\n\t\t\t\tpart->chctl.flags[ch_number] |=\n\t\t\t\t    XPC_CHCTL_CLOSEREPLY;\n\t\t\t\tspin_unlock(&part->chctl_lock);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tch->flags |= XPC_C_RCLOSEREPLY;\n\n\t\tif (ch->flags & XPC_C_CLOSEREPLY) {\n\t\t\t \n\t\t\txpc_process_disconnect(ch, &irq_flags);\n\t\t}\n\t}\n\n\tif (chctl_flags & XPC_CHCTL_OPENREQUEST) {\n\n\t\tdev_dbg(xpc_chan, \"XPC_CHCTL_OPENREQUEST (entry_size=%d, \"\n\t\t\t\"local_nentries=%d) received from partid=%d, \"\n\t\t\t\"channel=%d\\n\", args->entry_size, args->local_nentries,\n\t\t\tch->partid, ch->number);\n\n\t\tif (part->act_state == XPC_P_AS_DEACTIVATING ||\n\t\t    (ch->flags & XPC_C_ROPENREQUEST)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ch->flags & (XPC_C_DISCONNECTING | XPC_C_WDISCONNECT)) {\n\t\t\tch->delayed_chctl_flags |= XPC_CHCTL_OPENREQUEST;\n\t\t\tgoto out;\n\t\t}\n\t\tDBUG_ON(!(ch->flags & (XPC_C_DISCONNECTED |\n\t\t\t\t       XPC_C_OPENREQUEST)));\n\t\tDBUG_ON(ch->flags & (XPC_C_ROPENREQUEST | XPC_C_ROPENREPLY |\n\t\t\t\t     XPC_C_OPENREPLY | XPC_C_CONNECTED));\n\n\t\t \n\t\tif (args->entry_size == 0 || args->local_nentries == 0) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\tch->flags |= (XPC_C_ROPENREQUEST | XPC_C_CONNECTING);\n\t\tch->remote_nentries = args->local_nentries;\n\n\t\tif (ch->flags & XPC_C_OPENREQUEST) {\n\t\t\tif (args->entry_size != ch->entry_size) {\n\t\t\t\tXPC_DISCONNECT_CHANNEL(ch, xpUnequalMsgSizes,\n\t\t\t\t\t\t       &irq_flags);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tch->entry_size = args->entry_size;\n\n\t\t\tXPC_SET_REASON(ch, 0, 0);\n\t\t\tch->flags &= ~XPC_C_DISCONNECTED;\n\n\t\t\tatomic_inc(&part->nchannels_active);\n\t\t}\n\n\t\txpc_process_connect(ch, &irq_flags);\n\t}\n\n\tif (chctl_flags & XPC_CHCTL_OPENREPLY) {\n\n\t\tdev_dbg(xpc_chan, \"XPC_CHCTL_OPENREPLY (local_msgqueue_pa=\"\n\t\t\t\"0x%lx, local_nentries=%d, remote_nentries=%d) \"\n\t\t\t\"received from partid=%d, channel=%d\\n\",\n\t\t\targs->local_msgqueue_pa, args->local_nentries,\n\t\t\targs->remote_nentries, ch->partid, ch->number);\n\n\t\tif (ch->flags & (XPC_C_DISCONNECTING | XPC_C_DISCONNECTED))\n\t\t\tgoto out;\n\n\t\tif (!(ch->flags & XPC_C_OPENREQUEST)) {\n\t\t\tXPC_DISCONNECT_CHANNEL(ch, xpOpenCloseError,\n\t\t\t\t\t       &irq_flags);\n\t\t\tgoto out;\n\t\t}\n\n\t\tDBUG_ON(!(ch->flags & XPC_C_ROPENREQUEST));\n\t\tDBUG_ON(ch->flags & XPC_C_CONNECTED);\n\n\t\t \n\t\tDBUG_ON(args->local_msgqueue_pa == 0);\n\t\tDBUG_ON(args->local_nentries == 0);\n\t\tDBUG_ON(args->remote_nentries == 0);\n\n\t\tret = xpc_arch_ops.save_remote_msgqueue_pa(ch,\n\t\t\t\t\t\t      args->local_msgqueue_pa);\n\t\tif (ret != xpSuccess) {\n\t\t\tXPC_DISCONNECT_CHANNEL(ch, ret, &irq_flags);\n\t\t\tgoto out;\n\t\t}\n\t\tch->flags |= XPC_C_ROPENREPLY;\n\n\t\tif (args->local_nentries < ch->remote_nentries) {\n\t\t\tdev_dbg(xpc_chan, \"XPC_CHCTL_OPENREPLY: new \"\n\t\t\t\t\"remote_nentries=%d, old remote_nentries=%d, \"\n\t\t\t\t\"partid=%d, channel=%d\\n\",\n\t\t\t\targs->local_nentries, ch->remote_nentries,\n\t\t\t\tch->partid, ch->number);\n\n\t\t\tch->remote_nentries = args->local_nentries;\n\t\t}\n\t\tif (args->remote_nentries < ch->local_nentries) {\n\t\t\tdev_dbg(xpc_chan, \"XPC_CHCTL_OPENREPLY: new \"\n\t\t\t\t\"local_nentries=%d, old local_nentries=%d, \"\n\t\t\t\t\"partid=%d, channel=%d\\n\",\n\t\t\t\targs->remote_nentries, ch->local_nentries,\n\t\t\t\tch->partid, ch->number);\n\n\t\t\tch->local_nentries = args->remote_nentries;\n\t\t}\n\n\t\txpc_process_connect(ch, &irq_flags);\n\t}\n\n\tif (chctl_flags & XPC_CHCTL_OPENCOMPLETE) {\n\n\t\tdev_dbg(xpc_chan, \"XPC_CHCTL_OPENCOMPLETE received from \"\n\t\t\t\"partid=%d, channel=%d\\n\", ch->partid, ch->number);\n\n\t\tif (ch->flags & (XPC_C_DISCONNECTING | XPC_C_DISCONNECTED))\n\t\t\tgoto out;\n\n\t\tif (!(ch->flags & XPC_C_OPENREQUEST) ||\n\t\t    !(ch->flags & XPC_C_OPENREPLY)) {\n\t\t\tXPC_DISCONNECT_CHANNEL(ch, xpOpenCloseError,\n\t\t\t\t\t       &irq_flags);\n\t\t\tgoto out;\n\t\t}\n\n\t\tDBUG_ON(!(ch->flags & XPC_C_ROPENREQUEST));\n\t\tDBUG_ON(!(ch->flags & XPC_C_ROPENREPLY));\n\t\tDBUG_ON(!(ch->flags & XPC_C_CONNECTED));\n\n\t\tch->flags |= XPC_C_ROPENCOMPLETE;\n\n\t\txpc_process_connect(ch, &irq_flags);\n\t\tcreate_kthread = 1;\n\t}\n\nout:\n\tspin_unlock_irqrestore(&ch->lock, irq_flags);\n\n\tif (create_kthread)\n\t\txpc_create_kthreads(ch, 1, 0);\n}\n\n \nstatic enum xp_retval\nxpc_connect_channel(struct xpc_channel *ch)\n{\n\tunsigned long irq_flags;\n\tstruct xpc_registration *registration = &xpc_registrations[ch->number];\n\n\tif (mutex_trylock(&registration->mutex) == 0)\n\t\treturn xpRetry;\n\n\tif (!XPC_CHANNEL_REGISTERED(ch->number)) {\n\t\tmutex_unlock(&registration->mutex);\n\t\treturn xpUnregistered;\n\t}\n\n\tspin_lock_irqsave(&ch->lock, irq_flags);\n\n\tDBUG_ON(ch->flags & XPC_C_CONNECTED);\n\tDBUG_ON(ch->flags & XPC_C_OPENREQUEST);\n\n\tif (ch->flags & XPC_C_DISCONNECTING) {\n\t\tspin_unlock_irqrestore(&ch->lock, irq_flags);\n\t\tmutex_unlock(&registration->mutex);\n\t\treturn ch->reason;\n\t}\n\n\t \n\n\tch->kthreads_assigned_limit = registration->assigned_limit;\n\tch->kthreads_idle_limit = registration->idle_limit;\n\tDBUG_ON(atomic_read(&ch->kthreads_assigned) != 0);\n\tDBUG_ON(atomic_read(&ch->kthreads_idle) != 0);\n\tDBUG_ON(atomic_read(&ch->kthreads_active) != 0);\n\n\tch->func = registration->func;\n\tDBUG_ON(registration->func == NULL);\n\tch->key = registration->key;\n\n\tch->local_nentries = registration->nentries;\n\n\tif (ch->flags & XPC_C_ROPENREQUEST) {\n\t\tif (registration->entry_size != ch->entry_size) {\n\t\t\t \n\n\t\t\t \n\t\t\tmutex_unlock(&registration->mutex);\n\t\t\tXPC_DISCONNECT_CHANNEL(ch, xpUnequalMsgSizes,\n\t\t\t\t\t       &irq_flags);\n\t\t\tspin_unlock_irqrestore(&ch->lock, irq_flags);\n\t\t\treturn xpUnequalMsgSizes;\n\t\t}\n\t} else {\n\t\tch->entry_size = registration->entry_size;\n\n\t\tXPC_SET_REASON(ch, 0, 0);\n\t\tch->flags &= ~XPC_C_DISCONNECTED;\n\n\t\tatomic_inc(&xpc_partitions[ch->partid].nchannels_active);\n\t}\n\n\tmutex_unlock(&registration->mutex);\n\n\t \n\n\tch->flags |= (XPC_C_OPENREQUEST | XPC_C_CONNECTING);\n\txpc_arch_ops.send_chctl_openrequest(ch, &irq_flags);\n\n\txpc_process_connect(ch, &irq_flags);\n\n\tspin_unlock_irqrestore(&ch->lock, irq_flags);\n\n\treturn xpSuccess;\n}\n\nvoid\nxpc_process_sent_chctl_flags(struct xpc_partition *part)\n{\n\tunsigned long irq_flags;\n\tunion xpc_channel_ctl_flags chctl;\n\tstruct xpc_channel *ch;\n\tint ch_number;\n\tu32 ch_flags;\n\n\tchctl.all_flags = xpc_arch_ops.get_chctl_all_flags(part);\n\n\t \n\n\tfor (ch_number = 0; ch_number < part->nchannels; ch_number++) {\n\t\tch = &part->channels[ch_number];\n\n\t\t \n\n\t\tif (chctl.flags[ch_number] & XPC_OPENCLOSE_CHCTL_FLAGS) {\n\t\t\txpc_process_openclose_chctl_flags(part, ch_number,\n\t\t\t\t\t\t\tchctl.flags[ch_number]);\n\t\t}\n\n\t\tch_flags = ch->flags;\t \n\n\t\tif (ch_flags & XPC_C_DISCONNECTING) {\n\t\t\tspin_lock_irqsave(&ch->lock, irq_flags);\n\t\t\txpc_process_disconnect(ch, &irq_flags);\n\t\t\tspin_unlock_irqrestore(&ch->lock, irq_flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (part->act_state == XPC_P_AS_DEACTIVATING)\n\t\t\tcontinue;\n\n\t\tif (!(ch_flags & XPC_C_CONNECTED)) {\n\t\t\tif (!(ch_flags & XPC_C_OPENREQUEST)) {\n\t\t\t\tDBUG_ON(ch_flags & XPC_C_SETUP);\n\t\t\t\t(void)xpc_connect_channel(ch);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tif (chctl.flags[ch_number] & XPC_MSG_CHCTL_FLAGS)\n\t\t\txpc_arch_ops.process_msg_chctl_flags(part, ch_number);\n\t}\n}\n\n \nvoid\nxpc_partition_going_down(struct xpc_partition *part, enum xp_retval reason)\n{\n\tunsigned long irq_flags;\n\tint ch_number;\n\tstruct xpc_channel *ch;\n\n\tdev_dbg(xpc_chan, \"deactivating partition %d, reason=%d\\n\",\n\t\tXPC_PARTID(part), reason);\n\n\tif (!xpc_part_ref(part)) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\n\tfor (ch_number = 0; ch_number < part->nchannels; ch_number++) {\n\t\tch = &part->channels[ch_number];\n\n\t\txpc_msgqueue_ref(ch);\n\t\tspin_lock_irqsave(&ch->lock, irq_flags);\n\n\t\tXPC_DISCONNECT_CHANNEL(ch, reason, &irq_flags);\n\n\t\tspin_unlock_irqrestore(&ch->lock, irq_flags);\n\t\txpc_msgqueue_deref(ch);\n\t}\n\n\txpc_wakeup_channel_mgr(part);\n\n\txpc_part_deref(part);\n}\n\n \nvoid\nxpc_initiate_connect(int ch_number)\n{\n\tshort partid;\n\tstruct xpc_partition *part;\n\n\tDBUG_ON(ch_number < 0 || ch_number >= XPC_MAX_NCHANNELS);\n\n\tfor (partid = 0; partid < xp_max_npartitions; partid++) {\n\t\tpart = &xpc_partitions[partid];\n\n\t\tif (xpc_part_ref(part)) {\n\t\t\t \n\t\t\txpc_wakeup_channel_mgr(part);\n\t\t\txpc_part_deref(part);\n\t\t}\n\t}\n}\n\nvoid\nxpc_connected_callout(struct xpc_channel *ch)\n{\n\t \n\n\tif (ch->func != NULL) {\n\t\tdev_dbg(xpc_chan, \"ch->func() called, reason=xpConnected, \"\n\t\t\t\"partid=%d, channel=%d\\n\", ch->partid, ch->number);\n\n\t\tch->func(xpConnected, ch->partid, ch->number,\n\t\t\t (void *)(u64)ch->local_nentries, ch->key);\n\n\t\tdev_dbg(xpc_chan, \"ch->func() returned, reason=xpConnected, \"\n\t\t\t\"partid=%d, channel=%d\\n\", ch->partid, ch->number);\n\t}\n}\n\n \nvoid\nxpc_initiate_disconnect(int ch_number)\n{\n\tunsigned long irq_flags;\n\tshort partid;\n\tstruct xpc_partition *part;\n\tstruct xpc_channel *ch;\n\n\tDBUG_ON(ch_number < 0 || ch_number >= XPC_MAX_NCHANNELS);\n\n\t \n\tfor (partid = 0; partid < xp_max_npartitions; partid++) {\n\t\tpart = &xpc_partitions[partid];\n\n\t\tif (xpc_part_ref(part)) {\n\t\t\tch = &part->channels[ch_number];\n\t\t\txpc_msgqueue_ref(ch);\n\n\t\t\tspin_lock_irqsave(&ch->lock, irq_flags);\n\n\t\t\tif (!(ch->flags & XPC_C_DISCONNECTED)) {\n\t\t\t\tch->flags |= XPC_C_WDISCONNECT;\n\n\t\t\t\tXPC_DISCONNECT_CHANNEL(ch, xpUnregistering,\n\t\t\t\t\t\t       &irq_flags);\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&ch->lock, irq_flags);\n\n\t\t\txpc_msgqueue_deref(ch);\n\t\t\txpc_part_deref(part);\n\t\t}\n\t}\n\n\txpc_disconnect_wait(ch_number);\n}\n\n \nvoid\nxpc_disconnect_channel(const int line, struct xpc_channel *ch,\n\t\t       enum xp_retval reason, unsigned long *irq_flags)\n{\n\tu32 channel_was_connected = (ch->flags & XPC_C_CONNECTED);\n\n\tlockdep_assert_held(&ch->lock);\n\n\tif (ch->flags & (XPC_C_DISCONNECTING | XPC_C_DISCONNECTED))\n\t\treturn;\n\n\tDBUG_ON(!(ch->flags & (XPC_C_CONNECTING | XPC_C_CONNECTED)));\n\n\tdev_dbg(xpc_chan, \"reason=%d, line=%d, partid=%d, channel=%d\\n\",\n\t\treason, line, ch->partid, ch->number);\n\n\tXPC_SET_REASON(ch, reason, line);\n\n\tch->flags |= (XPC_C_CLOSEREQUEST | XPC_C_DISCONNECTING);\n\t \n\tch->flags &= ~(XPC_C_OPENREQUEST | XPC_C_OPENREPLY |\n\t\t       XPC_C_ROPENREQUEST | XPC_C_ROPENREPLY |\n\t\t       XPC_C_CONNECTING | XPC_C_CONNECTED);\n\n\txpc_arch_ops.send_chctl_closerequest(ch, irq_flags);\n\n\tif (channel_was_connected)\n\t\tch->flags |= XPC_C_WASCONNECTED;\n\n\tspin_unlock_irqrestore(&ch->lock, *irq_flags);\n\n\t \n\tif (atomic_read(&ch->kthreads_idle) > 0) {\n\t\twake_up_all(&ch->idle_wq);\n\n\t} else if ((ch->flags & XPC_C_CONNECTEDCALLOUT_MADE) &&\n\t\t   !(ch->flags & XPC_C_DISCONNECTINGCALLOUT)) {\n\t\t \n\t\txpc_create_kthreads(ch, 1, 1);\n\t}\n\n\t \n\tif (atomic_read(&ch->n_on_msg_allocate_wq) > 0)\n\t\twake_up(&ch->msg_allocate_wq);\n\n\tspin_lock_irqsave(&ch->lock, *irq_flags);\n}\n\nvoid\nxpc_disconnect_callout(struct xpc_channel *ch, enum xp_retval reason)\n{\n\t \n\n\tif (ch->func != NULL) {\n\t\tdev_dbg(xpc_chan, \"ch->func() called, reason=%d, partid=%d, \"\n\t\t\t\"channel=%d\\n\", reason, ch->partid, ch->number);\n\n\t\tch->func(reason, ch->partid, ch->number, NULL, ch->key);\n\n\t\tdev_dbg(xpc_chan, \"ch->func() returned, reason=%d, partid=%d, \"\n\t\t\t\"channel=%d\\n\", reason, ch->partid, ch->number);\n\t}\n}\n\n \nenum xp_retval\nxpc_allocate_msg_wait(struct xpc_channel *ch)\n{\n\tenum xp_retval ret;\n\tDEFINE_WAIT(wait);\n\n\tif (ch->flags & XPC_C_DISCONNECTING) {\n\t\tDBUG_ON(ch->reason == xpInterrupted);\n\t\treturn ch->reason;\n\t}\n\n\tatomic_inc(&ch->n_on_msg_allocate_wq);\n\tprepare_to_wait(&ch->msg_allocate_wq, &wait, TASK_INTERRUPTIBLE);\n\tret = schedule_timeout(1);\n\tfinish_wait(&ch->msg_allocate_wq, &wait);\n\tatomic_dec(&ch->n_on_msg_allocate_wq);\n\n\tif (ch->flags & XPC_C_DISCONNECTING) {\n\t\tret = ch->reason;\n\t\tDBUG_ON(ch->reason == xpInterrupted);\n\t} else if (ret == 0) {\n\t\tret = xpTimeout;\n\t} else {\n\t\tret = xpInterrupted;\n\t}\n\n\treturn ret;\n}\n\n \nenum xp_retval\nxpc_initiate_send(short partid, int ch_number, u32 flags, void *payload,\n\t\t  u16 payload_size)\n{\n\tstruct xpc_partition *part = &xpc_partitions[partid];\n\tenum xp_retval ret = xpUnknownReason;\n\n\tdev_dbg(xpc_chan, \"payload=0x%p, partid=%d, channel=%d\\n\", payload,\n\t\tpartid, ch_number);\n\n\tDBUG_ON(partid < 0 || partid >= xp_max_npartitions);\n\tDBUG_ON(ch_number < 0 || ch_number >= part->nchannels);\n\tDBUG_ON(payload == NULL);\n\n\tif (xpc_part_ref(part)) {\n\t\tret = xpc_arch_ops.send_payload(&part->channels[ch_number],\n\t\t\t\t  flags, payload, payload_size, 0, NULL, NULL);\n\t\txpc_part_deref(part);\n\t}\n\n\treturn ret;\n}\n\n \nenum xp_retval\nxpc_initiate_send_notify(short partid, int ch_number, u32 flags, void *payload,\n\t\t\t u16 payload_size, xpc_notify_func func, void *key)\n{\n\tstruct xpc_partition *part = &xpc_partitions[partid];\n\tenum xp_retval ret = xpUnknownReason;\n\n\tdev_dbg(xpc_chan, \"payload=0x%p, partid=%d, channel=%d\\n\", payload,\n\t\tpartid, ch_number);\n\n\tDBUG_ON(partid < 0 || partid >= xp_max_npartitions);\n\tDBUG_ON(ch_number < 0 || ch_number >= part->nchannels);\n\tDBUG_ON(payload == NULL);\n\tDBUG_ON(func == NULL);\n\n\tif (xpc_part_ref(part)) {\n\t\tret = xpc_arch_ops.send_payload(&part->channels[ch_number],\n\t\t\t  flags, payload, payload_size, XPC_N_CALL, func, key);\n\t\txpc_part_deref(part);\n\t}\n\treturn ret;\n}\n\n \nvoid\nxpc_deliver_payload(struct xpc_channel *ch)\n{\n\tvoid *payload;\n\n\tpayload = xpc_arch_ops.get_deliverable_payload(ch);\n\tif (payload != NULL) {\n\n\t\t \n\t\txpc_msgqueue_ref(ch);\n\n\t\tatomic_inc(&ch->kthreads_active);\n\n\t\tif (ch->func != NULL) {\n\t\t\tdev_dbg(xpc_chan, \"ch->func() called, payload=0x%p \"\n\t\t\t\t\"partid=%d channel=%d\\n\", payload, ch->partid,\n\t\t\t\tch->number);\n\n\t\t\t \n\t\t\tch->func(xpMsgReceived, ch->partid, ch->number, payload,\n\t\t\t\t ch->key);\n\n\t\t\tdev_dbg(xpc_chan, \"ch->func() returned, payload=0x%p \"\n\t\t\t\t\"partid=%d channel=%d\\n\", payload, ch->partid,\n\t\t\t\tch->number);\n\t\t}\n\n\t\tatomic_dec(&ch->kthreads_active);\n\t}\n}\n\n \nvoid\nxpc_initiate_received(short partid, int ch_number, void *payload)\n{\n\tstruct xpc_partition *part = &xpc_partitions[partid];\n\tstruct xpc_channel *ch;\n\n\tDBUG_ON(partid < 0 || partid >= xp_max_npartitions);\n\tDBUG_ON(ch_number < 0 || ch_number >= part->nchannels);\n\n\tch = &part->channels[ch_number];\n\txpc_arch_ops.received_payload(ch, payload);\n\n\t \n\txpc_msgqueue_deref(ch);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}