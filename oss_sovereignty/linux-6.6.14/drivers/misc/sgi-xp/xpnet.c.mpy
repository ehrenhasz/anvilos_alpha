{
  "module_name": "xpnet.c",
  "hash_id": "fc39996738cb2a8e870e67eec104bac1c7dec1ff965ed96dea60df0923ece22d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sgi-xp/xpnet.c",
  "human_readable_source": " \n\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include \"xp.h\"\n\n \nstruct xpnet_message {\n\tu16 version;\t\t \n\tu16 embedded_bytes;\t \n\tu32 magic;\t\t \n\tunsigned long buf_pa;\t \n\tu32 size;\t\t \n\tu8 leadin_ignore;\t \n\tu8 tailout_ignore;\t \n\tunsigned char data;\t \n};\n\n \n#define XPNET_MSG_SIZE\t\tXPC_MSG_PAYLOAD_MAX_SIZE\n#define XPNET_MSG_DATA_MAX\t\\\n\t\t(XPNET_MSG_SIZE - offsetof(struct xpnet_message, data))\n#define XPNET_MSG_NENTRIES\t(PAGE_SIZE / XPC_MSG_MAX_SIZE)\n\n#define XPNET_MAX_KTHREADS\t(XPNET_MSG_NENTRIES + 1)\n#define XPNET_MAX_IDLE_KTHREADS\t(XPNET_MSG_NENTRIES + 1)\n\n \n#define _XPNET_VERSION(_major, _minor)\t(((_major) << 4) | (_minor))\n#define XPNET_VERSION_MAJOR(_v)\t\t((_v) >> 4)\n#define XPNET_VERSION_MINOR(_v)\t\t((_v) & 0xf)\n\n#define\tXPNET_VERSION _XPNET_VERSION(1, 0)\t \n#define\tXPNET_VERSION_EMBED _XPNET_VERSION(1, 1)\t \n#define XPNET_MAGIC\t0x88786984\t \n\n#define XPNET_VALID_MSG(_m)\t\t\t\t\t\t     \\\n   ((XPNET_VERSION_MAJOR(_m->version) == XPNET_VERSION_MAJOR(XPNET_VERSION)) \\\n    && (msg->magic == XPNET_MAGIC))\n\n#define XPNET_DEVICE_NAME\t\t\"xp0\"\n\n \nstruct xpnet_pending_msg {\n\tstruct sk_buff *skb;\n\tatomic_t use_count;\n};\n\nstatic struct net_device *xpnet_device;\n\n \nstatic unsigned long *xpnet_broadcast_partitions;\n \nstatic DEFINE_SPINLOCK(xpnet_broadcast_lock);\n\n \n#define XPNET_MAX_MTU (0x800000UL - L1_CACHE_BYTES)\n \n#define XPNET_MIN_MTU 68\n \n#define XPNET_DEF_MTU (0x8000UL)\n\n \n#define XPNET_PARTID_OCTET\t2\n\n \n\nstatic struct device_driver xpnet_dbg_name = {\n\t.name = \"xpnet\"\n};\n\nstatic struct device xpnet_dbg_subname = {\n\t.init_name = \"\",\t \n\t.driver = &xpnet_dbg_name\n};\n\nstatic struct device *xpnet = &xpnet_dbg_subname;\n\n \nstatic void\nxpnet_receive(short partid, int channel, struct xpnet_message *msg)\n{\n\tstruct sk_buff *skb;\n\tvoid *dst;\n\tenum xp_retval ret;\n\n\tif (!XPNET_VALID_MSG(msg)) {\n\t\t \n\t\txpc_received(partid, channel, (void *)msg);\n\n\t\txpnet_device->stats.rx_errors++;\n\n\t\treturn;\n\t}\n\tdev_dbg(xpnet, \"received 0x%lx, %d, %d, %d\\n\", msg->buf_pa, msg->size,\n\t\tmsg->leadin_ignore, msg->tailout_ignore);\n\n\t \n\tskb = dev_alloc_skb(msg->size + L1_CACHE_BYTES);\n\tif (!skb) {\n\t\tdev_err(xpnet, \"failed on dev_alloc_skb(%d)\\n\",\n\t\t\tmsg->size + L1_CACHE_BYTES);\n\n\t\txpc_received(partid, channel, (void *)msg);\n\n\t\txpnet_device->stats.rx_errors++;\n\n\t\treturn;\n\t}\n\n\t \n\tskb_reserve(skb, (L1_CACHE_BYTES - ((u64)skb->data &\n\t\t\t\t\t    (L1_CACHE_BYTES - 1)) +\n\t\t\t  msg->leadin_ignore));\n\n\t \n\tskb_put(skb, (msg->size - msg->leadin_ignore - msg->tailout_ignore));\n\n\t \n\tif ((XPNET_VERSION_MINOR(msg->version) == 1) &&\n\t    (msg->embedded_bytes != 0)) {\n\t\tdev_dbg(xpnet, \"copying embedded message. memcpy(0x%p, 0x%p, \"\n\t\t\t\"%lu)\\n\", skb->data, &msg->data,\n\t\t\t(size_t)msg->embedded_bytes);\n\n\t\tskb_copy_to_linear_data(skb, &msg->data,\n\t\t\t\t\t(size_t)msg->embedded_bytes);\n\t} else {\n\t\tdst = (void *)((u64)skb->data & ~(L1_CACHE_BYTES - 1));\n\t\tdev_dbg(xpnet, \"transferring buffer to the skb->data area;\\n\\t\"\n\t\t\t\"xp_remote_memcpy(0x%p, 0x%p, %u)\\n\", dst,\n\t\t\t\t\t  (void *)msg->buf_pa, msg->size);\n\n\t\tret = xp_remote_memcpy(xp_pa(dst), msg->buf_pa, msg->size);\n\t\tif (ret != xpSuccess) {\n\t\t\t \n\t\t\tdev_err(xpnet, \"xp_remote_memcpy(0x%p, 0x%p, 0x%x) \"\n\t\t\t\t\"returned error=0x%x\\n\", dst,\n\t\t\t\t(void *)msg->buf_pa, msg->size, ret);\n\n\t\t\txpc_received(partid, channel, (void *)msg);\n\n\t\t\txpnet_device->stats.rx_errors++;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdev_dbg(xpnet, \"<skb->head=0x%p skb->data=0x%p skb->tail=0x%p \"\n\t\t\"skb->end=0x%p skb->len=%d\\n\", (void *)skb->head,\n\t\t(void *)skb->data, skb_tail_pointer(skb), skb_end_pointer(skb),\n\t\tskb->len);\n\n\tskb->protocol = eth_type_trans(skb, xpnet_device);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tdev_dbg(xpnet, \"passing skb to network layer\\n\"\n\t\t\"\\tskb->head=0x%p skb->data=0x%p skb->tail=0x%p \"\n\t\t\"skb->end=0x%p skb->len=%d\\n\",\n\t\t(void *)skb->head, (void *)skb->data, skb_tail_pointer(skb),\n\t\tskb_end_pointer(skb), skb->len);\n\n\txpnet_device->stats.rx_packets++;\n\txpnet_device->stats.rx_bytes += skb->len + ETH_HLEN;\n\n\tnetif_rx(skb);\n\txpc_received(partid, channel, (void *)msg);\n}\n\n \nstatic void\nxpnet_connection_activity(enum xp_retval reason, short partid, int channel,\n\t\t\t  void *data, void *key)\n{\n\tDBUG_ON(partid < 0 || partid >= xp_max_npartitions);\n\tDBUG_ON(channel != XPC_NET_CHANNEL);\n\n\tswitch (reason) {\n\tcase xpMsgReceived:\t \n\t\tDBUG_ON(data == NULL);\n\n\t\txpnet_receive(partid, channel, (struct xpnet_message *)data);\n\t\tbreak;\n\n\tcase xpConnected:\t \n\t\tspin_lock_bh(&xpnet_broadcast_lock);\n\t\t__set_bit(partid, xpnet_broadcast_partitions);\n\t\tspin_unlock_bh(&xpnet_broadcast_lock);\n\n\t\tnetif_carrier_on(xpnet_device);\n\n\t\tdev_dbg(xpnet, \"%s connected to partition %d\\n\",\n\t\t\txpnet_device->name, partid);\n\t\tbreak;\n\n\tdefault:\n\t\tspin_lock_bh(&xpnet_broadcast_lock);\n\t\t__clear_bit(partid, xpnet_broadcast_partitions);\n\t\tspin_unlock_bh(&xpnet_broadcast_lock);\n\n\t\tif (bitmap_empty(xpnet_broadcast_partitions,\n\t\t\t\t xp_max_npartitions)) {\n\t\t\tnetif_carrier_off(xpnet_device);\n\t\t}\n\n\t\tdev_dbg(xpnet, \"%s disconnected from partition %d\\n\",\n\t\t\txpnet_device->name, partid);\n\t\tbreak;\n\t}\n}\n\nstatic int\nxpnet_dev_open(struct net_device *dev)\n{\n\tenum xp_retval ret;\n\n\tdev_dbg(xpnet, \"calling xpc_connect(%d, 0x%p, NULL, %ld, %ld, %ld, \"\n\t\t\"%ld)\\n\", XPC_NET_CHANNEL, xpnet_connection_activity,\n\t\t(unsigned long)XPNET_MSG_SIZE,\n\t\t(unsigned long)XPNET_MSG_NENTRIES,\n\t\t(unsigned long)XPNET_MAX_KTHREADS,\n\t\t(unsigned long)XPNET_MAX_IDLE_KTHREADS);\n\n\tret = xpc_connect(XPC_NET_CHANNEL, xpnet_connection_activity, NULL,\n\t\t\t  XPNET_MSG_SIZE, XPNET_MSG_NENTRIES,\n\t\t\t  XPNET_MAX_KTHREADS, XPNET_MAX_IDLE_KTHREADS);\n\tif (ret != xpSuccess) {\n\t\tdev_err(xpnet, \"ifconfig up of %s failed on XPC connect, \"\n\t\t\t\"ret=%d\\n\", dev->name, ret);\n\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(xpnet, \"ifconfig up of %s; XPC connected\\n\", dev->name);\n\n\treturn 0;\n}\n\nstatic int\nxpnet_dev_stop(struct net_device *dev)\n{\n\txpc_disconnect(XPC_NET_CHANNEL);\n\n\tdev_dbg(xpnet, \"ifconfig down of %s; XPC disconnected\\n\", dev->name);\n\n\treturn 0;\n}\n\n \nstatic void\nxpnet_send_completed(enum xp_retval reason, short partid, int channel,\n\t\t     void *__qm)\n{\n\tstruct xpnet_pending_msg *queued_msg = (struct xpnet_pending_msg *)__qm;\n\n\tDBUG_ON(queued_msg == NULL);\n\n\tdev_dbg(xpnet, \"message to %d notified with reason %d\\n\",\n\t\tpartid, reason);\n\n\tif (atomic_dec_return(&queued_msg->use_count) == 0) {\n\t\tdev_dbg(xpnet, \"all acks for skb->head=-x%p\\n\",\n\t\t\t(void *)queued_msg->skb->head);\n\n\t\tdev_kfree_skb_any(queued_msg->skb);\n\t\tkfree(queued_msg);\n\t}\n}\n\nstatic void\nxpnet_send(struct sk_buff *skb, struct xpnet_pending_msg *queued_msg,\n\t   u64 start_addr, u64 end_addr, u16 embedded_bytes, int dest_partid)\n{\n\tu8 msg_buffer[XPNET_MSG_SIZE];\n\tstruct xpnet_message *msg = (struct xpnet_message *)&msg_buffer;\n\tu16 msg_size = sizeof(struct xpnet_message);\n\tenum xp_retval ret;\n\n\tmsg->embedded_bytes = embedded_bytes;\n\tif (unlikely(embedded_bytes != 0)) {\n\t\tmsg->version = XPNET_VERSION_EMBED;\n\t\tdev_dbg(xpnet, \"calling memcpy(0x%p, 0x%p, 0x%lx)\\n\",\n\t\t\t&msg->data, skb->data, (size_t)embedded_bytes);\n\t\tskb_copy_from_linear_data(skb, &msg->data,\n\t\t\t\t\t  (size_t)embedded_bytes);\n\t\tmsg_size += embedded_bytes - 1;\n\t} else {\n\t\tmsg->version = XPNET_VERSION;\n\t}\n\tmsg->magic = XPNET_MAGIC;\n\tmsg->size = end_addr - start_addr;\n\tmsg->leadin_ignore = (u64)skb->data - start_addr;\n\tmsg->tailout_ignore = end_addr - (u64)skb_tail_pointer(skb);\n\tmsg->buf_pa = xp_pa((void *)start_addr);\n\n\tdev_dbg(xpnet, \"sending XPC message to %d:%d\\n\"\n\t\t\"msg->buf_pa=0x%lx, msg->size=%u, \"\n\t\t\"msg->leadin_ignore=%u, msg->tailout_ignore=%u\\n\",\n\t\tdest_partid, XPC_NET_CHANNEL, msg->buf_pa, msg->size,\n\t\tmsg->leadin_ignore, msg->tailout_ignore);\n\n\tatomic_inc(&queued_msg->use_count);\n\n\tret = xpc_send_notify(dest_partid, XPC_NET_CHANNEL, XPC_NOWAIT, msg,\n\t\t\t      msg_size, xpnet_send_completed, queued_msg);\n\tif (unlikely(ret != xpSuccess))\n\t\tatomic_dec(&queued_msg->use_count);\n}\n\n \nstatic netdev_tx_t\nxpnet_dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct xpnet_pending_msg *queued_msg;\n\tu64 start_addr, end_addr;\n\tshort dest_partid;\n\tu16 embedded_bytes = 0;\n\n\tdev_dbg(xpnet, \">skb->head=0x%p skb->data=0x%p skb->tail=0x%p \"\n\t\t\"skb->end=0x%p skb->len=%d\\n\", (void *)skb->head,\n\t\t(void *)skb->data, skb_tail_pointer(skb), skb_end_pointer(skb),\n\t\tskb->len);\n\n\tif (skb->data[0] == 0x33) {\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\t \n\t}\n\n\t \n\tqueued_msg = kmalloc(sizeof(struct xpnet_pending_msg), GFP_ATOMIC);\n\tif (queued_msg == NULL) {\n\t\tdev_warn(xpnet, \"failed to kmalloc %ld bytes; dropping \"\n\t\t\t \"packet\\n\", sizeof(struct xpnet_pending_msg));\n\n\t\tdev->stats.tx_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tstart_addr = ((u64)skb->data & ~(L1_CACHE_BYTES - 1));\n\tend_addr = L1_CACHE_ALIGN((u64)skb_tail_pointer(skb));\n\n\t \n\tif (unlikely(skb->len <= XPNET_MSG_DATA_MAX)) {\n\t\t \n\t\tembedded_bytes = skb->len;\n\t}\n\n\t \n\tatomic_set(&queued_msg->use_count, 1);\n\tqueued_msg->skb = skb;\n\n\tif (skb->data[0] == 0xff) {\n\t\t \n\t\tfor_each_set_bit(dest_partid, xpnet_broadcast_partitions,\n\t\t\t     xp_max_npartitions) {\n\n\t\t\txpnet_send(skb, queued_msg, start_addr, end_addr,\n\t\t\t\t   embedded_bytes, dest_partid);\n\t\t}\n\t} else {\n\t\tdest_partid = (short)skb->data[XPNET_PARTID_OCTET + 1];\n\t\tdest_partid |= (short)skb->data[XPNET_PARTID_OCTET + 0] << 8;\n\n\t\tif (dest_partid >= 0 &&\n\t\t    dest_partid < xp_max_npartitions &&\n\t\t    test_bit(dest_partid, xpnet_broadcast_partitions) != 0) {\n\n\t\t\txpnet_send(skb, queued_msg, start_addr, end_addr,\n\t\t\t\t   embedded_bytes, dest_partid);\n\t\t}\n\t}\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\tif (atomic_dec_return(&queued_msg->use_count) == 0) {\n\t\tdev_kfree_skb(skb);\n\t\tkfree(queued_msg);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void\nxpnet_dev_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tdev->stats.tx_errors++;\n}\n\nstatic const struct net_device_ops xpnet_netdev_ops = {\n\t.ndo_open\t\t= xpnet_dev_open,\n\t.ndo_stop\t\t= xpnet_dev_stop,\n\t.ndo_start_xmit\t\t= xpnet_dev_hard_start_xmit,\n\t.ndo_tx_timeout\t\t= xpnet_dev_tx_timeout,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int __init\nxpnet_init(void)\n{\n\tu8 addr[ETH_ALEN];\n\tint result;\n\n\tif (!is_uv_system())\n\t\treturn -ENODEV;\n\n\tdev_info(xpnet, \"registering network device %s\\n\", XPNET_DEVICE_NAME);\n\n\txpnet_broadcast_partitions = bitmap_zalloc(xp_max_npartitions,\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (xpnet_broadcast_partitions == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\txpnet_device = alloc_netdev(0, XPNET_DEVICE_NAME, NET_NAME_UNKNOWN,\n\t\t\t\t    ether_setup);\n\tif (xpnet_device == NULL) {\n\t\tbitmap_free(xpnet_broadcast_partitions);\n\t\treturn -ENOMEM;\n\t}\n\n\tnetif_carrier_off(xpnet_device);\n\n\txpnet_device->netdev_ops = &xpnet_netdev_ops;\n\txpnet_device->mtu = XPNET_DEF_MTU;\n\txpnet_device->min_mtu = XPNET_MIN_MTU;\n\txpnet_device->max_mtu = XPNET_MAX_MTU;\n\n\tmemset(addr, 0, sizeof(addr));\n\t \n\taddr[0] = 0x02;      \n\n\taddr[XPNET_PARTID_OCTET + 1] = xp_partition_id;\n\taddr[XPNET_PARTID_OCTET + 0] = (xp_partition_id >> 8);\n\teth_hw_addr_set(xpnet_device, addr);\n\n\t \n\txpnet_device->flags &= ~IFF_MULTICAST;\n\n\t \n\txpnet_device->features = NETIF_F_HW_CSUM;\n\n\tresult = register_netdev(xpnet_device);\n\tif (result != 0) {\n\t\tfree_netdev(xpnet_device);\n\t\tbitmap_free(xpnet_broadcast_partitions);\n\t}\n\n\treturn result;\n}\n\nmodule_init(xpnet_init);\n\nstatic void __exit\nxpnet_exit(void)\n{\n\tdev_info(xpnet, \"unregistering network device %s\\n\",\n\t\t xpnet_device[0].name);\n\n\tunregister_netdev(xpnet_device);\n\tfree_netdev(xpnet_device);\n\tbitmap_free(xpnet_broadcast_partitions);\n}\n\nmodule_exit(xpnet_exit);\n\nMODULE_AUTHOR(\"Silicon Graphics, Inc.\");\nMODULE_DESCRIPTION(\"Cross Partition Network adapter (XPNET)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}