{
  "module_name": "xp_main.c",
  "hash_id": "f6c93ff154b4dbb089642311ffdd4702041ec5ab37793111dba4644cf4a74cd6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sgi-xp/xp_main.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include \"xp.h\"\n\n \n\nstatic struct device_driver xp_dbg_name = {\n\t.name = \"xp\"\n};\n\nstatic struct device xp_dbg_subname = {\n\t.init_name = \"\",\t\t \n\t.driver = &xp_dbg_name\n};\n\nstruct device *xp = &xp_dbg_subname;\n\n \nshort xp_max_npartitions;\nEXPORT_SYMBOL_GPL(xp_max_npartitions);\n\nshort xp_partition_id;\nEXPORT_SYMBOL_GPL(xp_partition_id);\n\nu8 xp_region_size;\nEXPORT_SYMBOL_GPL(xp_region_size);\n\nunsigned long (*xp_pa) (void *addr);\nEXPORT_SYMBOL_GPL(xp_pa);\n\nunsigned long (*xp_socket_pa) (unsigned long gpa);\nEXPORT_SYMBOL_GPL(xp_socket_pa);\n\nenum xp_retval (*xp_remote_memcpy) (unsigned long dst_gpa,\n\t\t\t\t    const unsigned long src_gpa, size_t len);\nEXPORT_SYMBOL_GPL(xp_remote_memcpy);\n\nint (*xp_cpu_to_nasid) (int cpuid);\nEXPORT_SYMBOL_GPL(xp_cpu_to_nasid);\n\nenum xp_retval (*xp_expand_memprotect) (unsigned long phys_addr,\n\t\t\t\t\tunsigned long size);\nEXPORT_SYMBOL_GPL(xp_expand_memprotect);\nenum xp_retval (*xp_restrict_memprotect) (unsigned long phys_addr,\n\t\t\t\t\t  unsigned long size);\nEXPORT_SYMBOL_GPL(xp_restrict_memprotect);\n\n \nstruct xpc_registration xpc_registrations[XPC_MAX_NCHANNELS];\nEXPORT_SYMBOL_GPL(xpc_registrations);\n\n \nstruct xpc_interface xpc_interface = { };\nEXPORT_SYMBOL_GPL(xpc_interface);\n\n \nvoid\nxpc_set_interface(void (*connect) (int),\n\t\t  void (*disconnect) (int),\n\t\t  enum xp_retval (*send) (short, int, u32, void *, u16),\n\t\t  enum xp_retval (*send_notify) (short, int, u32, void *, u16,\n\t\t\t\t\t\t  xpc_notify_func, void *),\n\t\t  void (*received) (short, int, void *),\n\t\t  enum xp_retval (*partid_to_nasids) (short, void *))\n{\n\txpc_interface.connect = connect;\n\txpc_interface.disconnect = disconnect;\n\txpc_interface.send = send;\n\txpc_interface.send_notify = send_notify;\n\txpc_interface.received = received;\n\txpc_interface.partid_to_nasids = partid_to_nasids;\n}\nEXPORT_SYMBOL_GPL(xpc_set_interface);\n\n \nvoid\nxpc_clear_interface(void)\n{\n\tmemset(&xpc_interface, 0, sizeof(xpc_interface));\n}\nEXPORT_SYMBOL_GPL(xpc_clear_interface);\n\n \nenum xp_retval\nxpc_connect(int ch_number, xpc_channel_func func, void *key, u16 payload_size,\n\t    u16 nentries, u32 assigned_limit, u32 idle_limit)\n{\n\tstruct xpc_registration *registration;\n\n\tDBUG_ON(ch_number < 0 || ch_number >= XPC_MAX_NCHANNELS);\n\tDBUG_ON(payload_size == 0 || nentries == 0);\n\tDBUG_ON(func == NULL);\n\tDBUG_ON(assigned_limit == 0 || idle_limit > assigned_limit);\n\n\tif (XPC_MSG_SIZE(payload_size) > XPC_MSG_MAX_SIZE)\n\t\treturn xpPayloadTooBig;\n\n\tregistration = &xpc_registrations[ch_number];\n\n\tif (mutex_lock_interruptible(&registration->mutex) != 0)\n\t\treturn xpInterrupted;\n\n\t \n\tif (registration->func != NULL) {\n\t\tmutex_unlock(&registration->mutex);\n\t\treturn xpAlreadyRegistered;\n\t}\n\n\t \n\tregistration->entry_size = XPC_MSG_SIZE(payload_size);\n\tregistration->nentries = nentries;\n\tregistration->assigned_limit = assigned_limit;\n\tregistration->idle_limit = idle_limit;\n\tregistration->key = key;\n\tregistration->func = func;\n\n\tmutex_unlock(&registration->mutex);\n\n\tif (xpc_interface.connect)\n\t\txpc_interface.connect(ch_number);\n\n\treturn xpSuccess;\n}\nEXPORT_SYMBOL_GPL(xpc_connect);\n\n \nvoid\nxpc_disconnect(int ch_number)\n{\n\tstruct xpc_registration *registration;\n\n\tDBUG_ON(ch_number < 0 || ch_number >= XPC_MAX_NCHANNELS);\n\n\tregistration = &xpc_registrations[ch_number];\n\n\t \n\tmutex_lock(&registration->mutex);\n\n\t \n\tif (registration->func == NULL) {\n\t\tmutex_unlock(&registration->mutex);\n\t\treturn;\n\t}\n\n\t \n\tregistration->func = NULL;\n\tregistration->key = NULL;\n\tregistration->nentries = 0;\n\tregistration->entry_size = 0;\n\tregistration->assigned_limit = 0;\n\tregistration->idle_limit = 0;\n\n\tif (xpc_interface.disconnect)\n\t\txpc_interface.disconnect(ch_number);\n\n\tmutex_unlock(&registration->mutex);\n\n\treturn;\n}\nEXPORT_SYMBOL_GPL(xpc_disconnect);\n\nstatic int __init\nxp_init(void)\n{\n\tenum xp_retval ret;\n\tint ch_number;\n\n\t \n\tfor (ch_number = 0; ch_number < XPC_MAX_NCHANNELS; ch_number++)\n\t\tmutex_init(&xpc_registrations[ch_number].mutex);\n\n\tif (is_uv_system())\n\t\tret = xp_init_uv();\n\telse\n\t\tret = 0;\n\n\tif (ret != xpSuccess)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nmodule_init(xp_init);\n\nstatic void __exit\nxp_exit(void)\n{\n\tif (is_uv_system())\n\t\txp_exit_uv();\n}\n\nmodule_exit(xp_exit);\n\nMODULE_AUTHOR(\"Silicon Graphics, Inc.\");\nMODULE_DESCRIPTION(\"Cross Partition (XP) base\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}