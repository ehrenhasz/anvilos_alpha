{
  "module_name": "xp.h",
  "hash_id": "44e6730e2898603577893be56e0c9ed25094fcb65a48d215c13735b9146b6ff8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sgi-xp/xp.h",
  "human_readable_source": " \n\n \n\n#ifndef _DRIVERS_MISC_SGIXP_XP_H\n#define _DRIVERS_MISC_SGIXP_XP_H\n\n#include <linux/mutex.h>\n\n#if defined CONFIG_X86_UV || defined CONFIG_IA64_SGI_UV\n#include <asm/uv/uv.h>\n#endif\n\n#ifdef USE_DBUG_ON\n#define DBUG_ON(condition)\tBUG_ON(condition)\n#else\n#define DBUG_ON(condition)\n#endif\n\n \n#define XP_MAX_NPARTITIONS_SN2\t64\n#define XP_MAX_NPARTITIONS_UV\t256\n\n \n#define XPC_MEM_CHANNEL\t\t0\t \n#define\tXPC_NET_CHANNEL\t\t1\t \n\n#define XPC_MAX_NCHANNELS\t2\t \n\n#if XPC_MAX_NCHANNELS > 8\n#error\tXPC_MAX_NCHANNELS exceeds absolute MAXIMUM possible.\n#endif\n\n \n#define XPC_MSG_MAX_SIZE\t128\n#define XPC_MSG_HDR_MAX_SIZE\t16\n#define XPC_MSG_PAYLOAD_MAX_SIZE (XPC_MSG_MAX_SIZE - XPC_MSG_HDR_MAX_SIZE)\n\n#define XPC_MSG_SIZE(_payload_size) \\\n\t\t\t\tALIGN(XPC_MSG_HDR_MAX_SIZE + (_payload_size), \\\n\t\t\t\t      is_uv_system() ? 64 : 128)\n\n\n \nenum xp_retval {\n\txpSuccess = 0,\n\n\txpNotConnected,\t\t \n\txpConnected,\t\t \n\txpRETIRED1,\t\t \n\n\txpMsgReceived,\t\t \n\txpMsgDelivered,\t\t \n\n\txpRETIRED2,\t\t \n\n\txpNoWait,\t\t \n\txpRetry,\t\t \n\txpTimeout,\t\t \n\txpInterrupted,\t\t \n\n\txpUnequalMsgSizes,\t \n\txpInvalidAddress,\t \n\n\txpNoMemory,\t\t \n\txpLackOfResources,\t \n\txpUnregistered,\t\t \n\txpAlreadyRegistered,\t \n\n\txpPartitionDown,\t \n\txpNotLoaded,\t\t \n\txpUnloading,\t\t \n\n\txpBadMagic,\t\t \n\n\txpReactivating,\t\t \n\n\txpUnregistering,\t \n\txpOtherUnregistering,\t \n\n\txpCloneKThread,\t\t \n\txpCloneKThreadFailed,\t \n\n\txpNoHeartbeat,\t\t \n\n\txpPioReadError,\t\t \n\txpPhysAddrRegFailed,\t \n\n\txpRETIRED3,\t\t \n\txpRETIRED4,\t\t \n\txpRETIRED5,\t\t \n\txpRETIRED6,\t\t \n\txpRETIRED7,\t\t \n\txpRETIRED8,\t\t \n\txpRETIRED9,\t\t \n\txpRETIRED10,\t\t \n\txpRETIRED11,\t\t \n\txpRETIRED12,\t\t \n\n\txpBadVersion,\t\t \n\txpVarsNotSet,\t\t \n\txpNoRsvdPageAddr,\t \n\txpInvalidPartid,\t \n\txpLocalPartid,\t\t \n\n\txpOtherGoingDown,\t \n\txpSystemGoingDown,\t \n\txpSystemHalt,\t\t \n\txpSystemReboot,\t\t \n\txpSystemPoweroff,\t \n\n\txpDisconnecting,\t \n\n\txpOpenCloseError,\t \n\n\txpDisconnected,\t\t \n\n\txpBteCopyError,\t\t \n\txpSalError,\t\t \n\txpRsvdPageNotSet,\t \n\txpPayloadTooBig,\t \n\n\txpUnsupported,\t\t \n\txpNeedMoreInfo,\t\t \n\n\txpGruCopyError,\t\t \n\txpGruSendMqError,\t \n\n\txpBadChannelNumber,\t \n\txpBadMsgType,\t\t \n\txpBiosError,\t\t \n\n\txpUnknownReason\t\t \n};\n\n \ntypedef void (*xpc_channel_func) (enum xp_retval reason, short partid,\n\t\t\t\t  int ch_number, void *data, void *key);\n\n \ntypedef void (*xpc_notify_func) (enum xp_retval reason, short partid,\n\t\t\t\t int ch_number, void *key);\n\n \nstruct xpc_registration {\n\tstruct mutex mutex;\n\txpc_channel_func func;\t \n\tvoid *key;\t\t \n\tu16 nentries;\t\t \n\tu16 entry_size;\t\t \n\tu32 assigned_limit;\t \n\tu32 idle_limit;\t\t \n} ____cacheline_aligned;\n\n#define XPC_CHANNEL_REGISTERED(_c)\t(xpc_registrations[_c].func != NULL)\n\n \n#define XPC_WAIT\t0\t \n#define XPC_NOWAIT\t1\t \n\nstruct xpc_interface {\n\tvoid (*connect) (int);\n\tvoid (*disconnect) (int);\n\tenum xp_retval (*send) (short, int, u32, void *, u16);\n\tenum xp_retval (*send_notify) (short, int, u32, void *, u16,\n\t\t\t\t\txpc_notify_func, void *);\n\tvoid (*received) (short, int, void *);\n\tenum xp_retval (*partid_to_nasids) (short, void *);\n};\n\nextern struct xpc_interface xpc_interface;\n\nextern void xpc_set_interface(void (*)(int),\n\t\t\t      void (*)(int),\n\t\t\t      enum xp_retval (*)(short, int, u32, void *, u16),\n\t\t\t      enum xp_retval (*)(short, int, u32, void *, u16,\n\t\t\t\t\t\t xpc_notify_func, void *),\n\t\t\t      void (*)(short, int, void *),\n\t\t\t      enum xp_retval (*)(short, void *));\nextern void xpc_clear_interface(void);\n\nextern enum xp_retval xpc_connect(int, xpc_channel_func, void *, u16,\n\t\t\t\t   u16, u32, u32);\nextern void xpc_disconnect(int);\n\nstatic inline enum xp_retval\nxpc_send(short partid, int ch_number, u32 flags, void *payload,\n\t u16 payload_size)\n{\n\tif (!xpc_interface.send)\n\t\treturn xpNotLoaded;\n\n\treturn xpc_interface.send(partid, ch_number, flags, payload,\n\t\t\t\t  payload_size);\n}\n\nstatic inline enum xp_retval\nxpc_send_notify(short partid, int ch_number, u32 flags, void *payload,\n\t\tu16 payload_size, xpc_notify_func func, void *key)\n{\n\tif (!xpc_interface.send_notify)\n\t\treturn xpNotLoaded;\n\n\treturn xpc_interface.send_notify(partid, ch_number, flags, payload,\n\t\t\t\t\t payload_size, func, key);\n}\n\nstatic inline void\nxpc_received(short partid, int ch_number, void *payload)\n{\n\tif (xpc_interface.received)\n\t\txpc_interface.received(partid, ch_number, payload);\n}\n\nstatic inline enum xp_retval\nxpc_partid_to_nasids(short partid, void *nasids)\n{\n\tif (!xpc_interface.partid_to_nasids)\n\t\treturn xpNotLoaded;\n\n\treturn xpc_interface.partid_to_nasids(partid, nasids);\n}\n\nextern short xp_max_npartitions;\nextern short xp_partition_id;\nextern u8 xp_region_size;\n\nextern unsigned long (*xp_pa) (void *);\nextern unsigned long (*xp_socket_pa) (unsigned long);\nextern enum xp_retval (*xp_remote_memcpy) (unsigned long, const unsigned long,\n\t\t       size_t);\nextern int (*xp_cpu_to_nasid) (int);\nextern enum xp_retval (*xp_expand_memprotect) (unsigned long, unsigned long);\nextern enum xp_retval (*xp_restrict_memprotect) (unsigned long, unsigned long);\n\nextern struct device *xp;\nextern enum xp_retval xp_init_uv(void);\nextern void xp_exit_uv(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}