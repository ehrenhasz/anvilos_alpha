{
  "module_name": "xpc_partition.c",
  "hash_id": "28ec31ec827b5e7173ce8117cdc4402cc6f81887bd0defb1434ea0562bbfbfb5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sgi-xp/xpc_partition.c",
  "human_readable_source": " \n\n \n\n#include <linux/device.h>\n#include <linux/hardirq.h>\n#include <linux/slab.h>\n#include \"xpc.h\"\n#include <asm/uv/uv_hub.h>\n\n \nint xpc_exiting;\n\n \nstruct xpc_rsvd_page *xpc_rsvd_page;\nstatic unsigned long *xpc_part_nasids;\nunsigned long *xpc_mach_nasids;\n\nstatic int xpc_nasid_mask_nbytes;\t \nint xpc_nasid_mask_nlongs;\t \n\nstruct xpc_partition *xpc_partitions;\n\n \nvoid *\nxpc_kmalloc_cacheline_aligned(size_t size, gfp_t flags, void **base)\n{\n\t \n\t*base = kmalloc(size, flags);\n\tif (*base == NULL)\n\t\treturn NULL;\n\n\tif ((u64)*base == L1_CACHE_ALIGN((u64)*base))\n\t\treturn *base;\n\n\tkfree(*base);\n\n\t \n\t*base = kmalloc(size + L1_CACHE_BYTES, flags);\n\tif (*base == NULL)\n\t\treturn NULL;\n\n\treturn (void *)L1_CACHE_ALIGN((u64)*base);\n}\n\n \nstatic unsigned long\nxpc_get_rsvd_page_pa(int nasid)\n{\n\tenum xp_retval ret;\n\tu64 cookie = 0;\n\tunsigned long rp_pa = nasid;\t \n\tsize_t len = 0;\n\tsize_t buf_len = 0;\n\tvoid *buf = NULL;\n\tvoid *buf_base = NULL;\n\tenum xp_retval (*get_partition_rsvd_page_pa)\n\t\t(void *, u64 *, unsigned long *, size_t *) =\n\t\txpc_arch_ops.get_partition_rsvd_page_pa;\n\n\twhile (1) {\n\n\t\t \n\t\tret = get_partition_rsvd_page_pa(buf, &cookie, &rp_pa, &len);\n\n\t\tdev_dbg(xpc_part, \"SAL returned with ret=%d, cookie=0x%016lx, \"\n\t\t\t\"address=0x%016lx, len=0x%016lx\\n\", ret,\n\t\t\t(unsigned long)cookie, rp_pa, len);\n\n\t\tif (ret != xpNeedMoreInfo)\n\t\t\tbreak;\n\n\t\tif (len > buf_len) {\n\t\t\tkfree(buf_base);\n\t\t\tbuf_len = L1_CACHE_ALIGN(len);\n\t\t\tbuf = xpc_kmalloc_cacheline_aligned(buf_len, GFP_KERNEL,\n\t\t\t\t\t\t\t    &buf_base);\n\t\t\tif (buf_base == NULL) {\n\t\t\t\tdev_err(xpc_part, \"unable to kmalloc \"\n\t\t\t\t\t\"len=0x%016lx\\n\", buf_len);\n\t\t\t\tret = xpNoMemory;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tret = xp_remote_memcpy(xp_pa(buf), rp_pa, len);\n\t\tif (ret != xpSuccess) {\n\t\t\tdev_dbg(xpc_part, \"xp_remote_memcpy failed %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(buf_base);\n\n\tif (ret != xpSuccess)\n\t\trp_pa = 0;\n\n\tdev_dbg(xpc_part, \"reserved page at phys address 0x%016lx\\n\", rp_pa);\n\treturn rp_pa;\n}\n\n \nint\nxpc_setup_rsvd_page(void)\n{\n\tint ret;\n\tstruct xpc_rsvd_page *rp;\n\tunsigned long rp_pa;\n\tunsigned long new_ts_jiffies;\n\n\t \n\n\tpreempt_disable();\n\trp_pa = xpc_get_rsvd_page_pa(xp_cpu_to_nasid(smp_processor_id()));\n\tpreempt_enable();\n\tif (rp_pa == 0) {\n\t\tdev_err(xpc_part, \"SAL failed to locate the reserved page\\n\");\n\t\treturn -ESRCH;\n\t}\n\trp = (struct xpc_rsvd_page *)__va(xp_socket_pa(rp_pa));\n\n\tif (rp->SAL_version < 3) {\n\t\t \n\t\trp->SAL_partid &= 0xff;\n\t}\n\tBUG_ON(rp->SAL_partid != xp_partition_id);\n\n\tif (rp->SAL_partid < 0 || rp->SAL_partid >= xp_max_npartitions) {\n\t\tdev_err(xpc_part, \"the reserved page's partid of %d is outside \"\n\t\t\t\"supported range (< 0 || >= %d)\\n\", rp->SAL_partid,\n\t\t\txp_max_npartitions);\n\t\treturn -EINVAL;\n\t}\n\n\trp->version = XPC_RP_VERSION;\n\trp->max_npartitions = xp_max_npartitions;\n\n\t \n\tif (rp->SAL_version == 1) {\n\t\t \n\t\trp->SAL_nasids_size = 128;\n\t}\n\txpc_nasid_mask_nbytes = rp->SAL_nasids_size;\n\txpc_nasid_mask_nlongs = BITS_TO_LONGS(rp->SAL_nasids_size *\n\t\t\t\t\t      BITS_PER_BYTE);\n\n\t \n\txpc_part_nasids = XPC_RP_PART_NASIDS(rp);\n\txpc_mach_nasids = XPC_RP_MACH_NASIDS(rp);\n\n\tret = xpc_arch_ops.setup_rsvd_page(rp);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tnew_ts_jiffies = jiffies;\n\tif (new_ts_jiffies == 0 || new_ts_jiffies == rp->ts_jiffies)\n\t\tnew_ts_jiffies++;\n\trp->ts_jiffies = new_ts_jiffies;\n\n\txpc_rsvd_page = rp;\n\treturn 0;\n}\n\nvoid\nxpc_teardown_rsvd_page(void)\n{\n\t \n\txpc_rsvd_page->ts_jiffies = 0;\n}\n\n \nenum xp_retval\nxpc_get_remote_rp(int nasid, unsigned long *discovered_nasids,\n\t\t  struct xpc_rsvd_page *remote_rp, unsigned long *remote_rp_pa)\n{\n\tint l;\n\tenum xp_retval ret;\n\n\t \n\n\t*remote_rp_pa = xpc_get_rsvd_page_pa(nasid);\n\tif (*remote_rp_pa == 0)\n\t\treturn xpNoRsvdPageAddr;\n\n\t \n\tret = xp_remote_memcpy(xp_pa(remote_rp), *remote_rp_pa,\n\t\t\t       XPC_RP_HEADER_SIZE + xpc_nasid_mask_nbytes);\n\tif (ret != xpSuccess)\n\t\treturn ret;\n\n\tif (discovered_nasids != NULL) {\n\t\tunsigned long *remote_part_nasids =\n\t\t    XPC_RP_PART_NASIDS(remote_rp);\n\n\t\tfor (l = 0; l < xpc_nasid_mask_nlongs; l++)\n\t\t\tdiscovered_nasids[l] |= remote_part_nasids[l];\n\t}\n\n\t \n\tif (remote_rp->ts_jiffies == 0)\n\t\treturn xpRsvdPageNotSet;\n\n\tif (XPC_VERSION_MAJOR(remote_rp->version) !=\n\t    XPC_VERSION_MAJOR(XPC_RP_VERSION)) {\n\t\treturn xpBadVersion;\n\t}\n\n\t \n\tif (remote_rp->SAL_partid < 0 ||\n\t    remote_rp->SAL_partid >= xp_max_npartitions ||\n\t    remote_rp->max_npartitions <= xp_partition_id) {\n\t\treturn xpInvalidPartid;\n\t}\n\n\tif (remote_rp->SAL_partid == xp_partition_id)\n\t\treturn xpLocalPartid;\n\n\treturn xpSuccess;\n}\n\n \nstatic int __xpc_partition_disengaged(struct xpc_partition *part,\n\t\t\t\t      bool from_timer)\n{\n\tshort partid = XPC_PARTID(part);\n\tint disengaged;\n\n\tdisengaged = !xpc_arch_ops.partition_engaged(partid);\n\tif (part->disengage_timeout) {\n\t\tif (!disengaged) {\n\t\t\tif (time_is_after_jiffies(part->disengage_timeout)) {\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tdev_info(xpc_part, \"deactivate request to remote \"\n\t\t\t\t \"partition %d timed out\\n\", partid);\n\t\t\txpc_disengage_timedout = 1;\n\t\t\txpc_arch_ops.assume_partition_disengaged(partid);\n\t\t\tdisengaged = 1;\n\t\t}\n\t\tpart->disengage_timeout = 0;\n\n\t\t \n\t\tif (!from_timer)\n\t\t\tdel_timer_sync(&part->disengage_timer);\n\n\t\tDBUG_ON(part->act_state != XPC_P_AS_DEACTIVATING &&\n\t\t\tpart->act_state != XPC_P_AS_INACTIVE);\n\t\tif (part->act_state != XPC_P_AS_INACTIVE)\n\t\t\txpc_wakeup_channel_mgr(part);\n\n\t\txpc_arch_ops.cancel_partition_deactivation_request(part);\n\t}\n\treturn disengaged;\n}\n\nint xpc_partition_disengaged(struct xpc_partition *part)\n{\n\treturn __xpc_partition_disengaged(part, false);\n}\n\nint xpc_partition_disengaged_from_timer(struct xpc_partition *part)\n{\n\treturn __xpc_partition_disengaged(part, true);\n}\n\n \nenum xp_retval\nxpc_mark_partition_active(struct xpc_partition *part)\n{\n\tunsigned long irq_flags;\n\tenum xp_retval ret;\n\n\tdev_dbg(xpc_part, \"setting partition %d to ACTIVE\\n\", XPC_PARTID(part));\n\n\tspin_lock_irqsave(&part->act_lock, irq_flags);\n\tif (part->act_state == XPC_P_AS_ACTIVATING) {\n\t\tpart->act_state = XPC_P_AS_ACTIVE;\n\t\tret = xpSuccess;\n\t} else {\n\t\tDBUG_ON(part->reason == xpSuccess);\n\t\tret = part->reason;\n\t}\n\tspin_unlock_irqrestore(&part->act_lock, irq_flags);\n\n\treturn ret;\n}\n\n \nvoid\nxpc_deactivate_partition(const int line, struct xpc_partition *part,\n\t\t\t enum xp_retval reason)\n{\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(&part->act_lock, irq_flags);\n\n\tif (part->act_state == XPC_P_AS_INACTIVE) {\n\t\tXPC_SET_REASON(part, reason, line);\n\t\tspin_unlock_irqrestore(&part->act_lock, irq_flags);\n\t\tif (reason == xpReactivating) {\n\t\t\t \n\t\t\txpc_arch_ops.request_partition_reactivation(part);\n\t\t}\n\t\treturn;\n\t}\n\tif (part->act_state == XPC_P_AS_DEACTIVATING) {\n\t\tif ((part->reason == xpUnloading && reason != xpUnloading) ||\n\t\t    reason == xpReactivating) {\n\t\t\tXPC_SET_REASON(part, reason, line);\n\t\t}\n\t\tspin_unlock_irqrestore(&part->act_lock, irq_flags);\n\t\treturn;\n\t}\n\n\tpart->act_state = XPC_P_AS_DEACTIVATING;\n\tXPC_SET_REASON(part, reason, line);\n\n\tspin_unlock_irqrestore(&part->act_lock, irq_flags);\n\n\t \n\txpc_arch_ops.request_partition_deactivation(part);\n\n\t \n\tpart->disengage_timeout = jiffies + (xpc_disengage_timelimit * HZ);\n\tpart->disengage_timer.expires = part->disengage_timeout;\n\tadd_timer(&part->disengage_timer);\n\n\tdev_dbg(xpc_part, \"bringing partition %d down, reason = %d\\n\",\n\t\tXPC_PARTID(part), reason);\n\n\txpc_partition_going_down(part, reason);\n}\n\n \nvoid\nxpc_mark_partition_inactive(struct xpc_partition *part)\n{\n\tunsigned long irq_flags;\n\n\tdev_dbg(xpc_part, \"setting partition %d to INACTIVE\\n\",\n\t\tXPC_PARTID(part));\n\n\tspin_lock_irqsave(&part->act_lock, irq_flags);\n\tpart->act_state = XPC_P_AS_INACTIVE;\n\tspin_unlock_irqrestore(&part->act_lock, irq_flags);\n\tpart->remote_rp_pa = 0;\n}\n\n \nvoid\nxpc_discovery(void)\n{\n\tvoid *remote_rp_base;\n\tstruct xpc_rsvd_page *remote_rp;\n\tunsigned long remote_rp_pa;\n\tint region;\n\tint region_size;\n\tint max_regions;\n\tint nasid;\n\tunsigned long *discovered_nasids;\n\tenum xp_retval ret;\n\n\tremote_rp = xpc_kmalloc_cacheline_aligned(XPC_RP_HEADER_SIZE +\n\t\t\t\t\t\t  xpc_nasid_mask_nbytes,\n\t\t\t\t\t\t  GFP_KERNEL, &remote_rp_base);\n\tif (remote_rp == NULL)\n\t\treturn;\n\n\tdiscovered_nasids = kcalloc(xpc_nasid_mask_nlongs, sizeof(long),\n\t\t\t\t    GFP_KERNEL);\n\tif (discovered_nasids == NULL) {\n\t\tkfree(remote_rp_base);\n\t\treturn;\n\t}\n\n\t \n\tregion_size = xp_region_size;\n\n\tif (is_uv_system())\n\t\tmax_regions = 256;\n\telse {\n\t\tmax_regions = 64;\n\n\t\tswitch (region_size) {\n\t\tcase 128:\n\t\t\tmax_regions *= 2;\n\t\t\tfallthrough;\n\t\tcase 64:\n\t\t\tmax_regions *= 2;\n\t\t\tfallthrough;\n\t\tcase 32:\n\t\t\tmax_regions *= 2;\n\t\t\tregion_size = 16;\n\t\t}\n\t}\n\n\tfor (region = 0; region < max_regions; region++) {\n\n\t\tif (xpc_exiting)\n\t\t\tbreak;\n\n\t\tdev_dbg(xpc_part, \"searching region %d\\n\", region);\n\n\t\tfor (nasid = (region * region_size * 2);\n\t\t     nasid < ((region + 1) * region_size * 2); nasid += 2) {\n\n\t\t\tif (xpc_exiting)\n\t\t\t\tbreak;\n\n\t\t\tdev_dbg(xpc_part, \"checking nasid %d\\n\", nasid);\n\n\t\t\tif (test_bit(nasid / 2, xpc_part_nasids)) {\n\t\t\t\tdev_dbg(xpc_part, \"PROM indicates Nasid %d is \"\n\t\t\t\t\t\"part of the local partition; skipping \"\n\t\t\t\t\t\"region\\n\", nasid);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!(test_bit(nasid / 2, xpc_mach_nasids))) {\n\t\t\t\tdev_dbg(xpc_part, \"PROM indicates Nasid %d was \"\n\t\t\t\t\t\"not on Numa-Link network at reset\\n\",\n\t\t\t\t\tnasid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (test_bit(nasid / 2, discovered_nasids)) {\n\t\t\t\tdev_dbg(xpc_part, \"Nasid %d is part of a \"\n\t\t\t\t\t\"partition which was previously \"\n\t\t\t\t\t\"discovered\\n\", nasid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tret = xpc_get_remote_rp(nasid, discovered_nasids,\n\t\t\t\t\t\tremote_rp, &remote_rp_pa);\n\t\t\tif (ret != xpSuccess) {\n\t\t\t\tdev_dbg(xpc_part, \"unable to get reserved page \"\n\t\t\t\t\t\"from nasid %d, reason=%d\\n\", nasid,\n\t\t\t\t\tret);\n\n\t\t\t\tif (ret == xpLocalPartid)\n\t\t\t\t\tbreak;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\txpc_arch_ops.request_partition_activation(remote_rp,\n\t\t\t\t\t\t\t remote_rp_pa, nasid);\n\t\t}\n\t}\n\n\tkfree(discovered_nasids);\n\tkfree(remote_rp_base);\n}\n\n \nenum xp_retval\nxpc_initiate_partid_to_nasids(short partid, void *nasid_mask)\n{\n\tstruct xpc_partition *part;\n\tunsigned long part_nasid_pa;\n\n\tpart = &xpc_partitions[partid];\n\tif (part->remote_rp_pa == 0)\n\t\treturn xpPartitionDown;\n\n\tmemset(nasid_mask, 0, xpc_nasid_mask_nbytes);\n\n\tpart_nasid_pa = (unsigned long)XPC_RP_PART_NASIDS(part->remote_rp_pa);\n\n\treturn xp_remote_memcpy(xp_pa(nasid_mask), part_nasid_pa,\n\t\t\t\txpc_nasid_mask_nbytes);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}