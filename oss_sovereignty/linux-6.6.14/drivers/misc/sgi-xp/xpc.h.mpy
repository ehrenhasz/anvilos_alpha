{
  "module_name": "xpc.h",
  "hash_id": "f76054dcdc2382b757e7280c7199415922745212ce3dbfd4b31971118586f2dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/sgi-xp/xpc.h",
  "human_readable_source": " \n\n \n\n#ifndef _DRIVERS_MISC_SGIXP_XPC_H\n#define _DRIVERS_MISC_SGIXP_XPC_H\n\n#include <linux/wait.h>\n#include <linux/completion.h>\n#include <linux/timer.h>\n#include <linux/sched.h>\n#include \"xp.h\"\n\n \n#define _XPC_VERSION(_maj, _min)\t(((_maj) << 4) | ((_min) & 0xf))\n#define XPC_VERSION_MAJOR(_v)\t\t((_v) >> 4)\n#define XPC_VERSION_MINOR(_v)\t\t((_v) & 0xf)\n\n \n#define XPC_HB_DEFAULT_INTERVAL\t\t5\t \n#define XPC_HB_CHECK_DEFAULT_INTERVAL\t20\t \n\n \n#define XPC_HB_CHECK_THREAD_NAME\t\"xpc_hb\"\n#define XPC_HB_CHECK_CPU\t\t0\n\n \n#define XPC_DISCOVERY_THREAD_NAME\t\"xpc_discovery\"\n\n \nstruct xpc_rsvd_page {\n\tu64 SAL_signature;\t \n\tu64 SAL_version;\t \n\tshort SAL_partid;\t \n\tshort max_npartitions;\t \n\tu8 version;\n\tu8 pad1[3];\t\t \n\tunsigned long ts_jiffies;  \n\tunion {\n\t\tstruct {\n\t\t\tunsigned long heartbeat_gpa;  \n\t\t\tunsigned long activate_gru_mq_desc_gpa;  \n\t\t} uv;\n\t} sn;\n\tu64 pad2[9];\t\t \n\tu64 SAL_nasids_size;\t \n};\n\n#define XPC_RP_VERSION _XPC_VERSION(3, 0)  \n\n \n\n#define XPC_RP_HEADER_SIZE\tL1_CACHE_ALIGN(sizeof(struct xpc_rsvd_page))\n\n#define XPC_RP_PART_NASIDS(_rp) ((unsigned long *)((u8 *)(_rp) + \\\n\t\t\t\t XPC_RP_HEADER_SIZE))\n#define XPC_RP_MACH_NASIDS(_rp) (XPC_RP_PART_NASIDS(_rp) + \\\n\t\t\t\t xpc_nasid_mask_nlongs)\n\n\n \nstruct xpc_heartbeat_uv {\n\tunsigned long value;\n\tunsigned long offline;\t \n};\n\n \nstruct xpc_gru_mq_uv {\n\tvoid *address;\t\t \n\tunsigned int order;\t \n\tint irq;\t\t \n\tint mmr_blade;\t\t \n\tunsigned long mmr_offset;  \n\tunsigned long mmr_value;  \n\tint watchlist_num;\t \n\tvoid *gru_mq_desc;\t \n};\n\n \nstruct xpc_activate_mq_msghdr_uv {\n\tunsigned int gru_msg_hdr;  \n\tshort partid;\t\t \n\tu8 act_state;\t\t \n\tu8 type;\t\t \n\tunsigned long rp_ts_jiffies;  \n};\n\n \n#define XPC_ACTIVATE_MQ_MSG_SYNC_ACT_STATE_UV\t\t0\n\n#define XPC_ACTIVATE_MQ_MSG_ACTIVATE_REQ_UV\t\t1\n#define XPC_ACTIVATE_MQ_MSG_DEACTIVATE_REQ_UV\t\t2\n\n#define XPC_ACTIVATE_MQ_MSG_CHCTL_CLOSEREQUEST_UV\t3\n#define XPC_ACTIVATE_MQ_MSG_CHCTL_CLOSEREPLY_UV\t\t4\n#define XPC_ACTIVATE_MQ_MSG_CHCTL_OPENREQUEST_UV\t5\n#define XPC_ACTIVATE_MQ_MSG_CHCTL_OPENREPLY_UV\t\t6\n#define XPC_ACTIVATE_MQ_MSG_CHCTL_OPENCOMPLETE_UV\t7\n\n#define XPC_ACTIVATE_MQ_MSG_MARK_ENGAGED_UV\t\t8\n#define XPC_ACTIVATE_MQ_MSG_MARK_DISENGAGED_UV\t\t9\n\nstruct xpc_activate_mq_msg_uv {\n\tstruct xpc_activate_mq_msghdr_uv hdr;\n};\n\nstruct xpc_activate_mq_msg_activate_req_uv {\n\tstruct xpc_activate_mq_msghdr_uv hdr;\n\tunsigned long rp_gpa;\n\tunsigned long heartbeat_gpa;\n\tunsigned long activate_gru_mq_desc_gpa;\n};\n\nstruct xpc_activate_mq_msg_deactivate_req_uv {\n\tstruct xpc_activate_mq_msghdr_uv hdr;\n\tenum xp_retval reason;\n};\n\nstruct xpc_activate_mq_msg_chctl_closerequest_uv {\n\tstruct xpc_activate_mq_msghdr_uv hdr;\n\tshort ch_number;\n\tenum xp_retval reason;\n};\n\nstruct xpc_activate_mq_msg_chctl_closereply_uv {\n\tstruct xpc_activate_mq_msghdr_uv hdr;\n\tshort ch_number;\n};\n\nstruct xpc_activate_mq_msg_chctl_openrequest_uv {\n\tstruct xpc_activate_mq_msghdr_uv hdr;\n\tshort ch_number;\n\tshort entry_size;\t \n\tshort local_nentries;\t \n};\n\nstruct xpc_activate_mq_msg_chctl_openreply_uv {\n\tstruct xpc_activate_mq_msghdr_uv hdr;\n\tshort ch_number;\n\tshort remote_nentries;\t \n\tshort local_nentries;\t \n\tunsigned long notify_gru_mq_desc_gpa;\n};\n\nstruct xpc_activate_mq_msg_chctl_opencomplete_uv {\n\tstruct xpc_activate_mq_msghdr_uv hdr;\n\tshort ch_number;\n};\n\n \n#define XPC_PACK_ARGS(_arg1, _arg2) \\\n\t\t\t((((u64)_arg1) & 0xffffffff) | \\\n\t\t\t((((u64)_arg2) & 0xffffffff) << 32))\n\n#define XPC_UNPACK_ARG1(_args)\t(((u64)_args) & 0xffffffff)\n#define XPC_UNPACK_ARG2(_args)\t((((u64)_args) >> 32) & 0xffffffff)\n\n \nstruct xpc_openclose_args {\n\tu16 reason;\t\t \n\tu16 entry_size;\t\t \n\tu16 remote_nentries;\t \n\tu16 local_nentries;\t \n\tunsigned long local_msgqueue_pa;  \n};\n\n#define XPC_OPENCLOSE_ARGS_SIZE \\\n\t      L1_CACHE_ALIGN(sizeof(struct xpc_openclose_args) * \\\n\t      XPC_MAX_NCHANNELS)\n\n\n \n\nstruct xpc_fifo_entry_uv {\n\tstruct xpc_fifo_entry_uv *next;\n};\n\nstruct xpc_fifo_head_uv {\n\tstruct xpc_fifo_entry_uv *first;\n\tstruct xpc_fifo_entry_uv *last;\n\tspinlock_t lock;\n\tint n_entries;\n};\n\n \n\nstruct xpc_notify_mq_msghdr_uv {\n\tunion {\n\t\tunsigned int gru_msg_hdr;\t \n\t\tstruct xpc_fifo_entry_uv next;\t \n\t} u;\n\tshort partid;\t\t \n\tu8 ch_number;\t\t \n\tu8 size;\t\t \n\tunsigned int msg_slot_number;\t \n};\n\nstruct xpc_notify_mq_msg_uv {\n\tstruct xpc_notify_mq_msghdr_uv hdr;\n\tunsigned long payload;\n};\n\n \n\n#define\tXPC_N_CALL\t0x01\t \n\n \nstruct xpc_send_msg_slot_uv {\n\tstruct xpc_fifo_entry_uv next;\n\tunsigned int msg_slot_number;\n\txpc_notify_func func;\t \n\tvoid *key;\t\t \n};\n\n \n\nstruct xpc_channel_uv {\n\tvoid *cached_notify_gru_mq_desc;  \n\t\t\t\t\t  \n\n\tstruct xpc_send_msg_slot_uv *send_msg_slots;\n\tvoid *recv_msg_slots;\t \n\t\t\t\t \n\n\tstruct xpc_fifo_head_uv msg_slot_free_list;\n\tstruct xpc_fifo_head_uv recv_msg_list;\t \n};\n\nstruct xpc_channel {\n\tshort partid;\t\t \n\tspinlock_t lock;\t \n\tunsigned int flags;\t \n\n\tenum xp_retval reason;\t \n\tint reason_line;\t \n\n\tu16 number;\t\t \n\n\tu16 entry_size;\t\t \n\tu16 local_nentries;\t \n\tu16 remote_nentries;\t \n\n\tatomic_t references;\t \n\n\tatomic_t n_on_msg_allocate_wq;\t \n\twait_queue_head_t msg_allocate_wq;\t \n\n\tu8 delayed_chctl_flags;\t \n\t\t\t\t \n\n\tatomic_t n_to_notify;\t \n\n\txpc_channel_func func;\t \n\tvoid *key;\t\t \n\n\tstruct completion wdisconnect_wait;     \n\n\t \n\n\tatomic_t kthreads_assigned;\t \n\tu32 kthreads_assigned_limit;\t \n\tatomic_t kthreads_idle;\t \n\tu32 kthreads_idle_limit;\t \n\tatomic_t kthreads_active;\t \n\n\twait_queue_head_t idle_wq;\t \n\n\tunion {\n\t\tstruct xpc_channel_uv uv;\n\t} sn;\n\n} ____cacheline_aligned;\n\n \n\n#define\tXPC_C_WASCONNECTED\t0x00000001\t \n\n#define XPC_C_ROPENCOMPLETE\t0x00000002     \n#define XPC_C_OPENCOMPLETE\t0x00000004      \n#define\tXPC_C_ROPENREPLY\t0x00000008\t \n#define\tXPC_C_OPENREPLY\t\t0x00000010\t \n#define\tXPC_C_ROPENREQUEST\t0x00000020      \n#define\tXPC_C_OPENREQUEST\t0x00000040\t \n\n#define\tXPC_C_SETUP\t\t0x00000080  \n#define\tXPC_C_CONNECTEDCALLOUT\t0x00000100      \n#define\tXPC_C_CONNECTEDCALLOUT_MADE \\\n\t\t\t\t0x00000200      \n#define\tXPC_C_CONNECTED\t\t0x00000400\t \n#define\tXPC_C_CONNECTING\t0x00000800\t \n\n#define\tXPC_C_RCLOSEREPLY\t0x00001000\t \n#define\tXPC_C_CLOSEREPLY\t0x00002000\t \n#define\tXPC_C_RCLOSEREQUEST\t0x00004000     \n#define\tXPC_C_CLOSEREQUEST\t0x00008000      \n\n#define\tXPC_C_DISCONNECTED\t0x00010000\t \n#define\tXPC_C_DISCONNECTING\t0x00020000    \n#define\tXPC_C_DISCONNECTINGCALLOUT \\\n\t\t\t\t0x00040000  \n#define\tXPC_C_DISCONNECTINGCALLOUT_MADE \\\n\t\t\t\t0x00080000  \n#define\tXPC_C_WDISCONNECT\t0x00100000   \n\n \n\nunion xpc_channel_ctl_flags {\n\tu64 all_flags;\n\tu8 flags[XPC_MAX_NCHANNELS];\n};\n\n \n#define\tXPC_CHCTL_CLOSEREQUEST\t0x01\n#define\tXPC_CHCTL_CLOSEREPLY\t0x02\n#define\tXPC_CHCTL_OPENREQUEST\t0x04\n#define\tXPC_CHCTL_OPENREPLY\t0x08\n#define XPC_CHCTL_OPENCOMPLETE\t0x10\n#define\tXPC_CHCTL_MSGREQUEST\t0x20\n\n#define XPC_OPENCLOSE_CHCTL_FLAGS \\\n\t\t\t(XPC_CHCTL_CLOSEREQUEST | XPC_CHCTL_CLOSEREPLY | \\\n\t\t\t XPC_CHCTL_OPENREQUEST | XPC_CHCTL_OPENREPLY | \\\n\t\t\t XPC_CHCTL_OPENCOMPLETE)\n#define XPC_MSG_CHCTL_FLAGS\tXPC_CHCTL_MSGREQUEST\n\nstatic inline int\nxpc_any_openclose_chctl_flags_set(union xpc_channel_ctl_flags *chctl)\n{\n\tint ch_number;\n\n\tfor (ch_number = 0; ch_number < XPC_MAX_NCHANNELS; ch_number++) {\n\t\tif (chctl->flags[ch_number] & XPC_OPENCLOSE_CHCTL_FLAGS)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline int\nxpc_any_msg_chctl_flags_set(union xpc_channel_ctl_flags *chctl)\n{\n\tint ch_number;\n\n\tfor (ch_number = 0; ch_number < XPC_MAX_NCHANNELS; ch_number++) {\n\t\tif (chctl->flags[ch_number] & XPC_MSG_CHCTL_FLAGS)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstruct xpc_partition_uv {\n\tunsigned long heartbeat_gpa;  \n\tstruct xpc_heartbeat_uv cached_heartbeat;  \n\t\t\t\t\t\t   \n\tunsigned long activate_gru_mq_desc_gpa;\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\tvoid *cached_activate_gru_mq_desc;  \n\t\t\t\t\t    \n\tstruct mutex cached_activate_gru_mq_desc_mutex;\n\tspinlock_t flags_lock;\t \n\tunsigned int flags;\t \n\tu8 remote_act_state;\t \n\tu8 act_state_req;\t \n\tenum xp_retval reason;\t \n};\n\n \n\n#define XPC_P_CACHED_ACTIVATE_GRU_MQ_DESC_UV\t0x00000001\n#define XPC_P_ENGAGED_UV\t\t\t0x00000002\n\n \n\n#define XPC_P_ASR_ACTIVATE_UV\t\t0x01\n#define XPC_P_ASR_REACTIVATE_UV\t\t0x02\n#define XPC_P_ASR_DEACTIVATE_UV\t\t0x03\n\nstruct xpc_partition {\n\n\t \n\n\tu8 remote_rp_version;\t \n\tunsigned long remote_rp_ts_jiffies;  \n\tunsigned long remote_rp_pa;\t \n\tu64 last_heartbeat;\t \n\tu32 activate_IRQ_rcvd;\t \n\tspinlock_t act_lock;\t \n\tu8 act_state;\t\t \n\tenum xp_retval reason;\t \n\tint reason_line;\t \n\n\tunsigned long disengage_timeout;\t \n\tstruct timer_list disengage_timer;\n\n\t \n\n\tu8 setup_state;\t\t \n\twait_queue_head_t teardown_wq;\t \n\tatomic_t references;\t \n\n\tu8 nchannels;\t\t \n\tatomic_t nchannels_active;   \n\tatomic_t nchannels_engaged;   \n\tstruct xpc_channel *channels;\t \n\n\t \n\n\tunion xpc_channel_ctl_flags chctl;  \n\tspinlock_t chctl_lock;\t \n\n\tvoid *remote_openclose_args_base;   \n\tstruct xpc_openclose_args *remote_openclose_args;  \n\t\t\t\t\t\t\t   \n\n\t \n\n\tatomic_t channel_mgr_requests;\t \n\twait_queue_head_t channel_mgr_wq;\t \n\n\tunion {\n\t\tstruct xpc_partition_uv uv;\n\t} sn;\n\n} ____cacheline_aligned;\n\nstruct xpc_arch_operations {\n\tint (*setup_partitions) (void);\n\tvoid (*teardown_partitions) (void);\n\tvoid (*process_activate_IRQ_rcvd) (void);\n\tenum xp_retval (*get_partition_rsvd_page_pa)\n\t\t(void *, u64 *, unsigned long *, size_t *);\n\tint (*setup_rsvd_page) (struct xpc_rsvd_page *);\n\n\tvoid (*allow_hb) (short);\n\tvoid (*disallow_hb) (short);\n\tvoid (*disallow_all_hbs) (void);\n\tvoid (*increment_heartbeat) (void);\n\tvoid (*offline_heartbeat) (void);\n\tvoid (*online_heartbeat) (void);\n\tvoid (*heartbeat_init) (void);\n\tvoid (*heartbeat_exit) (void);\n\tenum xp_retval (*get_remote_heartbeat) (struct xpc_partition *);\n\n\tvoid (*request_partition_activation) (struct xpc_rsvd_page *,\n\t\t\t\t\t\t unsigned long, int);\n\tvoid (*request_partition_reactivation) (struct xpc_partition *);\n\tvoid (*request_partition_deactivation) (struct xpc_partition *);\n\tvoid (*cancel_partition_deactivation_request) (struct xpc_partition *);\n\tenum xp_retval (*setup_ch_structures) (struct xpc_partition *);\n\tvoid (*teardown_ch_structures) (struct xpc_partition *);\n\n\tenum xp_retval (*make_first_contact) (struct xpc_partition *);\n\n\tu64 (*get_chctl_all_flags) (struct xpc_partition *);\n\tvoid (*send_chctl_closerequest) (struct xpc_channel *, unsigned long *);\n\tvoid (*send_chctl_closereply) (struct xpc_channel *, unsigned long *);\n\tvoid (*send_chctl_openrequest) (struct xpc_channel *, unsigned long *);\n\tvoid (*send_chctl_openreply) (struct xpc_channel *, unsigned long *);\n\tvoid (*send_chctl_opencomplete) (struct xpc_channel *, unsigned long *);\n\tvoid (*process_msg_chctl_flags) (struct xpc_partition *, int);\n\n\tenum xp_retval (*save_remote_msgqueue_pa) (struct xpc_channel *,\n\t\t\t\t\t\t      unsigned long);\n\n\tenum xp_retval (*setup_msg_structures) (struct xpc_channel *);\n\tvoid (*teardown_msg_structures) (struct xpc_channel *);\n\n\tvoid (*indicate_partition_engaged) (struct xpc_partition *);\n\tvoid (*indicate_partition_disengaged) (struct xpc_partition *);\n\tvoid (*assume_partition_disengaged) (short);\n\tint (*partition_engaged) (short);\n\tint (*any_partition_engaged) (void);\n\n\tint (*n_of_deliverable_payloads) (struct xpc_channel *);\n\tenum xp_retval (*send_payload) (struct xpc_channel *, u32, void *,\n\t\t\t\t\t   u16, u8, xpc_notify_func, void *);\n\tvoid *(*get_deliverable_payload) (struct xpc_channel *);\n\tvoid (*received_payload) (struct xpc_channel *, void *);\n\tvoid (*notify_senders_of_disconnect) (struct xpc_channel *);\n};\n\n \n\n#define\tXPC_P_AS_INACTIVE\t0x00\t \n#define XPC_P_AS_ACTIVATION_REQ\t0x01\t \n#define XPC_P_AS_ACTIVATING\t0x02\t \n#define XPC_P_AS_ACTIVE\t\t0x03\t \n#define XPC_P_AS_DEACTIVATING\t0x04\t \n\n#define XPC_DEACTIVATE_PARTITION(_p, _reason) \\\n\t\t\txpc_deactivate_partition(__LINE__, (_p), (_reason))\n\n \n\n#define XPC_P_SS_UNSET\t\t0x00\t \n#define XPC_P_SS_SETUP\t\t0x01\t \n#define XPC_P_SS_WTEARDOWN\t0x02\t \n#define XPC_P_SS_TORNDOWN\t0x03\t \n\n \n#define XPC_DISENGAGE_DEFAULT_TIMELIMIT\t\t90\n\n \n#define XPC_DEACTIVATE_PRINTMSG_INTERVAL\t10\n\n#define XPC_PARTID(_p)\t((short)((_p) - &xpc_partitions[0]))\n\n \nextern struct xpc_registration xpc_registrations[];\n\n \nextern struct device *xpc_part;\nextern struct device *xpc_chan;\nextern struct xpc_arch_operations xpc_arch_ops;\nextern int xpc_disengage_timelimit;\nextern int xpc_disengage_timedout;\nextern int xpc_activate_IRQ_rcvd;\nextern spinlock_t xpc_activate_IRQ_rcvd_lock;\nextern wait_queue_head_t xpc_activate_IRQ_wq;\nextern void *xpc_kzalloc_cacheline_aligned(size_t, gfp_t, void **);\nextern void xpc_activate_partition(struct xpc_partition *);\nextern void xpc_activate_kthreads(struct xpc_channel *, int);\nextern void xpc_create_kthreads(struct xpc_channel *, int, int);\nextern void xpc_disconnect_wait(int);\n\n \nextern int xpc_init_uv(void);\nextern void xpc_exit_uv(void);\n\n \nextern int xpc_exiting;\nextern int xpc_nasid_mask_nlongs;\nextern struct xpc_rsvd_page *xpc_rsvd_page;\nextern unsigned long *xpc_mach_nasids;\nextern struct xpc_partition *xpc_partitions;\nextern void *xpc_kmalloc_cacheline_aligned(size_t, gfp_t, void **);\nextern int xpc_setup_rsvd_page(void);\nextern void xpc_teardown_rsvd_page(void);\nextern int xpc_identify_activate_IRQ_sender(void);\nextern int xpc_partition_disengaged(struct xpc_partition *);\nextern int xpc_partition_disengaged_from_timer(struct xpc_partition *part);\nextern enum xp_retval xpc_mark_partition_active(struct xpc_partition *);\nextern void xpc_mark_partition_inactive(struct xpc_partition *);\nextern void xpc_discovery(void);\nextern enum xp_retval xpc_get_remote_rp(int, unsigned long *,\n\t\t\t\t\tstruct xpc_rsvd_page *,\n\t\t\t\t\tunsigned long *);\nextern void xpc_deactivate_partition(const int, struct xpc_partition *,\n\t\t\t\t     enum xp_retval);\nextern enum xp_retval xpc_initiate_partid_to_nasids(short, void *);\n\n \nextern void xpc_initiate_connect(int);\nextern void xpc_initiate_disconnect(int);\nextern enum xp_retval xpc_allocate_msg_wait(struct xpc_channel *);\nextern enum xp_retval xpc_initiate_send(short, int, u32, void *, u16);\nextern enum xp_retval xpc_initiate_send_notify(short, int, u32, void *, u16,\n\t\t\t\t\t       xpc_notify_func, void *);\nextern void xpc_initiate_received(short, int, void *);\nextern void xpc_process_sent_chctl_flags(struct xpc_partition *);\nextern void xpc_connected_callout(struct xpc_channel *);\nextern void xpc_deliver_payload(struct xpc_channel *);\nextern void xpc_disconnect_channel(const int, struct xpc_channel *,\n\t\t\t\t   enum xp_retval, unsigned long *);\nextern void xpc_disconnect_callout(struct xpc_channel *, enum xp_retval);\nextern void xpc_partition_going_down(struct xpc_partition *, enum xp_retval);\n\nstatic inline void\nxpc_wakeup_channel_mgr(struct xpc_partition *part)\n{\n\tif (atomic_inc_return(&part->channel_mgr_requests) == 1)\n\t\twake_up(&part->channel_mgr_wq);\n}\n\n \nstatic inline void\nxpc_msgqueue_ref(struct xpc_channel *ch)\n{\n\tatomic_inc(&ch->references);\n}\n\nstatic inline void\nxpc_msgqueue_deref(struct xpc_channel *ch)\n{\n\ts32 refs = atomic_dec_return(&ch->references);\n\n\tDBUG_ON(refs < 0);\n\tif (refs == 0)\n\t\txpc_wakeup_channel_mgr(&xpc_partitions[ch->partid]);\n}\n\n#define XPC_DISCONNECT_CHANNEL(_ch, _reason, _irqflgs) \\\n\t\txpc_disconnect_channel(__LINE__, _ch, _reason, _irqflgs)\n\n \nstatic inline void\nxpc_part_deref(struct xpc_partition *part)\n{\n\ts32 refs = atomic_dec_return(&part->references);\n\n\tDBUG_ON(refs < 0);\n\tif (refs == 0 && part->setup_state == XPC_P_SS_WTEARDOWN)\n\t\twake_up(&part->teardown_wq);\n}\n\nstatic inline int\nxpc_part_ref(struct xpc_partition *part)\n{\n\tint setup;\n\n\tatomic_inc(&part->references);\n\tsetup = (part->setup_state == XPC_P_SS_SETUP);\n\tif (!setup)\n\t\txpc_part_deref(part);\n\n\treturn setup;\n}\n\n \n#define XPC_SET_REASON(_p, _reason, _line) \\\n\t{ \\\n\t\t(_p)->reason = _reason; \\\n\t\t(_p)->reason_line = _line; \\\n\t}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}