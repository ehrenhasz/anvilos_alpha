{
  "module_name": "apds990x.c",
  "hash_id": "3b1f9f2b3b1e04e62112af95e783f891fa2b20ea0d2f0811edd55801eb1ccc63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/apds990x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/delay.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/platform_data/apds990x.h>\n\n \n#define APDS990X_ENABLE\t 0x00  \n#define APDS990X_ATIME\t 0x01  \n#define APDS990X_PTIME\t 0x02  \n#define APDS990X_WTIME\t 0x03  \n#define APDS990X_AILTL\t 0x04  \n#define APDS990X_AILTH\t 0x05  \n#define APDS990X_AIHTL\t 0x06  \n#define APDS990X_AIHTH\t 0x07  \n#define APDS990X_PILTL\t 0x08  \n#define APDS990X_PILTH\t 0x09  \n#define APDS990X_PIHTL\t 0x0a  \n#define APDS990X_PIHTH\t 0x0b  \n#define APDS990X_PERS\t 0x0c  \n#define APDS990X_CONFIG\t 0x0d  \n#define APDS990X_PPCOUNT 0x0e  \n#define APDS990X_CONTROL 0x0f  \n#define APDS990X_REV\t 0x11  \n#define APDS990X_ID\t 0x12  \n#define APDS990X_STATUS\t 0x13  \n#define APDS990X_CDATAL\t 0x14  \n#define APDS990X_CDATAH\t 0x15  \n#define APDS990X_IRDATAL 0x16  \n#define APDS990X_IRDATAH 0x17  \n#define APDS990X_PDATAL\t 0x18  \n#define APDS990X_PDATAH\t 0x19  \n\n \n#define APDS990X_MAX_AGAIN\t3\n\n \n#define APDS990X_EN_PIEN\t(0x1 << 5)\n#define APDS990X_EN_AIEN\t(0x1 << 4)\n#define APDS990X_EN_WEN\t\t(0x1 << 3)\n#define APDS990X_EN_PEN\t\t(0x1 << 2)\n#define APDS990X_EN_AEN\t\t(0x1 << 1)\n#define APDS990X_EN_PON\t\t(0x1 << 0)\n#define APDS990X_EN_DISABLE_ALL 0\n\n \n#define APDS990X_ST_PINT\t(0x1 << 5)\n#define APDS990X_ST_AINT\t(0x1 << 4)\n\n \n#define APDS990x_CMD_TYPE_MASK\t(0x03 << 5)\n#define APDS990x_CMD_TYPE_RB\t(0x00 << 5)  \n#define APDS990x_CMD_TYPE_INC\t(0x01 << 5)  \n#define APDS990x_CMD_TYPE_SPE\t(0x03 << 5)  \n\n#define APDS990x_ADDR_SHIFT\t0\n#define APDS990x_CMD\t\t0x80\n\n \n#define APDS990X_INT_ACK_ALS\t0x6\n#define APDS990X_INT_ACK_PS\t0x5\n#define APDS990X_INT_ACK_BOTH\t0x7\n\n \n#define APDS990X_PTIME_DEFAULT\t0xff  \n\n \n#define APDS990X_WTIME_DEFAULT\t0xee  \n\n#define APDS990X_TIME_TO_ADC\t1024  \n\n \n#define APDS990X_APERS_SHIFT\t0\n#define APDS990X_PPERS_SHIFT\t4\n\n \n#define APDS990X_ID_0\t\t0x0\n#define APDS990X_ID_4\t\t0x4\n#define APDS990X_ID_29\t\t0x29\n\n \n#define APDS_PGAIN_1X\t       0x0\n#define APDS_PDIODE_IR\t       0x2\n\n#define APDS990X_LUX_OUTPUT_SCALE 10\n\n \nstruct reverse_factors {\n\tu32 afactor;\n\tint cf1;\n\tint irf1;\n\tint cf2;\n\tint irf2;\n};\n\nstruct apds990x_chip {\n\tstruct apds990x_platform_data\t*pdata;\n\tstruct i2c_client\t\t*client;\n\tstruct mutex\t\t\tmutex;  \n\tstruct regulator_bulk_data\tregs[2];\n\twait_queue_head_t\t\twait;\n\n\tint\tprox_en;\n\tbool\tprox_continuous_mode;\n\tbool\tlux_wait_fresh_res;\n\n\t \n\tstruct\tapds990x_chip_factors\tcf;\n\tstruct\treverse_factors\t\trcf;\n\tu16\tatime;\t\t \n\tu16\tarate;\t\t \n\tu16\ta_max_result;\t \n\tu8\tagain_meas;\t \n\tu8\tagain_next;\t \n\tu8\tpgain;\n\tu8\tpdiode;\n\tu8\tpdrive;\n\tu8\tlux_persistence;\n\tu8\tprox_persistence;\n\n\tu32\tlux_raw;\n\tu32\tlux;\n\tu16\tlux_clear;\n\tu16\tlux_ir;\n\tu16\tlux_calib;\n\tu32\tlux_thres_hi;\n\tu32\tlux_thres_lo;\n\n\tu32\tprox_thres;\n\tu16\tprox_data;\n\tu16\tprox_calib;\n\n\tchar\tchipname[10];\n\tu8\trevision;\n};\n\n#define APDS_CALIB_SCALER\t\t8192\n#define APDS_LUX_NEUTRAL_CALIB_VALUE\t(1 * APDS_CALIB_SCALER)\n#define APDS_PROX_NEUTRAL_CALIB_VALUE\t(1 * APDS_CALIB_SCALER)\n\n#define APDS_PROX_DEF_THRES\t\t600\n#define APDS_PROX_HYSTERESIS\t\t50\n#define APDS_LUX_DEF_THRES_HI\t\t101\n#define APDS_LUX_DEF_THRES_LO\t\t100\n#define APDS_DEFAULT_PROX_PERS\t\t1\n\n#define APDS_TIMEOUT\t\t\t2000\n#define APDS_STARTUP_DELAY\t\t25000  \n#define APDS_RANGE\t\t\t65535\n#define APDS_PROX_RANGE\t\t\t1023\n#define APDS_LUX_GAIN_LO_LIMIT\t\t100\n#define APDS_LUX_GAIN_LO_LIMIT_STRICT\t25\n\n#define TIMESTEP\t\t\t87  \n#define TIME_STEP_SCALER\t\t32\n\n#define APDS_LUX_AVERAGING_TIME\t\t50  \n#define APDS_LUX_DEFAULT_RATE\t\t200\n\nstatic const u8 again[]\t= {1, 8, 16, 120};  \n\n \nstatic const u16 arates_hz[] = {10, 5, 2, 1};\nstatic const u8 apersis[] = {1, 2, 4, 5};\n\n \nstatic const char reg_vcc[] = \"Vdd\";\nstatic const char reg_vled[] = \"Vled\";\n\nstatic int apds990x_read_byte(struct apds990x_chip *chip, u8 reg, u8 *data)\n{\n\tstruct i2c_client *client = chip->client;\n\ts32 ret;\n\n\treg &= ~APDS990x_CMD_TYPE_MASK;\n\treg |= APDS990x_CMD | APDS990x_CMD_TYPE_RB;\n\n\tret = i2c_smbus_read_byte_data(client, reg);\n\t*data = ret;\n\treturn (int)ret;\n}\n\nstatic int apds990x_read_word(struct apds990x_chip *chip, u8 reg, u16 *data)\n{\n\tstruct i2c_client *client = chip->client;\n\ts32 ret;\n\n\treg &= ~APDS990x_CMD_TYPE_MASK;\n\treg |= APDS990x_CMD | APDS990x_CMD_TYPE_INC;\n\n\tret = i2c_smbus_read_word_data(client, reg);\n\t*data = ret;\n\treturn (int)ret;\n}\n\nstatic int apds990x_write_byte(struct apds990x_chip *chip, u8 reg, u8 data)\n{\n\tstruct i2c_client *client = chip->client;\n\ts32 ret;\n\n\treg &= ~APDS990x_CMD_TYPE_MASK;\n\treg |= APDS990x_CMD | APDS990x_CMD_TYPE_RB;\n\n\tret = i2c_smbus_write_byte_data(client, reg, data);\n\treturn (int)ret;\n}\n\nstatic int apds990x_write_word(struct apds990x_chip *chip, u8 reg, u16 data)\n{\n\tstruct i2c_client *client = chip->client;\n\ts32 ret;\n\n\treg &= ~APDS990x_CMD_TYPE_MASK;\n\treg |= APDS990x_CMD | APDS990x_CMD_TYPE_INC;\n\n\tret = i2c_smbus_write_word_data(client, reg, data);\n\treturn (int)ret;\n}\n\nstatic int apds990x_mode_on(struct apds990x_chip *chip)\n{\n\t \n\tu8 reg = APDS990X_EN_AIEN | APDS990X_EN_PON | APDS990X_EN_AEN |\n\t\tAPDS990X_EN_WEN;\n\n\tif (chip->prox_en)\n\t\treg |= APDS990X_EN_PIEN | APDS990X_EN_PEN;\n\n\treturn apds990x_write_byte(chip, APDS990X_ENABLE, reg);\n}\n\nstatic u16 apds990x_lux_to_threshold(struct apds990x_chip *chip, u32 lux)\n{\n\tu32 thres;\n\tu32 cpl;\n\tu32 ir;\n\n\tif (lux == 0)\n\t\treturn 0;\n\telse if (lux == APDS_RANGE)\n\t\treturn APDS_RANGE;\n\n\t \n\tlux = lux * (APDS_CALIB_SCALER / 4) / (chip->lux_calib / 4);\n\n\t \n\tcpl = ((u32)chip->atime * (u32)again[chip->again_next] *\n\t\tAPDS_PARAM_SCALE * 64) / (chip->cf.ga * chip->cf.df);\n\n\tthres = lux * cpl / 64;\n\t \n\tir = (u32)chip->lux_ir * (u32)again[chip->again_next] /\n\t\t(u32)again[chip->again_meas];\n\n\t \n\tif (chip->lux_clear * APDS_PARAM_SCALE >=\n\t\tchip->rcf.afactor * chip->lux_ir)\n\t\tthres = (chip->rcf.cf1 * thres + chip->rcf.irf1 * ir) /\n\t\t\tAPDS_PARAM_SCALE;\n\telse\n\t\tthres = (chip->rcf.cf2 * thres + chip->rcf.irf2 * ir) /\n\t\t\tAPDS_PARAM_SCALE;\n\n\tif (thres >= chip->a_max_result)\n\t\tthres = chip->a_max_result - 1;\n\treturn thres;\n}\n\nstatic inline int apds990x_set_atime(struct apds990x_chip *chip, u32 time_ms)\n{\n\tu8 reg_value;\n\n\tchip->atime = time_ms;\n\t \n\treg_value = 256 - ((time_ms * TIME_STEP_SCALER) / TIMESTEP);\n\t \n\tchip->a_max_result = (u16)(256 - reg_value) * APDS990X_TIME_TO_ADC;\n\treturn apds990x_write_byte(chip, APDS990X_ATIME, reg_value);\n}\n\n \nstatic int apds990x_refresh_pthres(struct apds990x_chip *chip, int data)\n{\n\tint ret, lo, hi;\n\n\t \n\tif (pm_runtime_suspended(&chip->client->dev))\n\t\treturn 0;\n\n\tif (data < chip->prox_thres) {\n\t\tlo = 0;\n\t\thi = chip->prox_thres;\n\t} else {\n\t\tlo = chip->prox_thres - APDS_PROX_HYSTERESIS;\n\t\tif (chip->prox_continuous_mode)\n\t\t\thi = chip->prox_thres;\n\t\telse\n\t\t\thi = APDS_RANGE;\n\t}\n\n\tret = apds990x_write_word(chip, APDS990X_PILTL, lo);\n\tret |= apds990x_write_word(chip, APDS990X_PIHTL, hi);\n\treturn ret;\n}\n\n \nstatic int apds990x_refresh_athres(struct apds990x_chip *chip)\n{\n\tint ret;\n\t \n\tif (pm_runtime_suspended(&chip->client->dev))\n\t\treturn 0;\n\n\tret = apds990x_write_word(chip, APDS990X_AILTL,\n\t\t\tapds990x_lux_to_threshold(chip, chip->lux_thres_lo));\n\tret |= apds990x_write_word(chip, APDS990X_AIHTL,\n\t\t\tapds990x_lux_to_threshold(chip, chip->lux_thres_hi));\n\n\treturn ret;\n}\n\n \nstatic void apds990x_force_a_refresh(struct apds990x_chip *chip)\n{\n\t \n\tapds990x_write_word(chip, APDS990X_AILTL, APDS_LUX_DEF_THRES_LO);\n\tapds990x_write_word(chip, APDS990X_AIHTL, APDS_LUX_DEF_THRES_HI);\n}\n\n \nstatic void apds990x_force_p_refresh(struct apds990x_chip *chip)\n{\n\t \n\tapds990x_write_word(chip, APDS990X_PILTL, APDS_PROX_DEF_THRES - 1);\n\tapds990x_write_word(chip, APDS990X_PIHTL, APDS_PROX_DEF_THRES);\n}\n\n \nstatic int apds990x_calc_again(struct apds990x_chip *chip)\n{\n\tint curr_again = chip->again_meas;\n\tint next_again = chip->again_meas;\n\tint ret = 0;\n\n\t \n\tif (chip->lux_clear == chip->a_max_result)\n\t\tnext_again -= 2;  \n\telse if (chip->lux_clear > chip->a_max_result / 2)\n\t\tnext_again--;\n\telse if (chip->lux_clear < APDS_LUX_GAIN_LO_LIMIT_STRICT)\n\t\tnext_again += 2;  \n\telse if (chip->lux_clear < APDS_LUX_GAIN_LO_LIMIT)\n\t\tnext_again++;\n\n\t \n\tif (next_again < 0)\n\t\tnext_again = 0;\n\telse if (next_again > APDS990X_MAX_AGAIN)\n\t\tnext_again = APDS990X_MAX_AGAIN;\n\n\t \n\tif (chip->lux_clear == chip->a_max_result)\n\t\t \n\t\tret = -ERANGE;\n\telse if (next_again != curr_again &&\n\t\tchip->lux_clear < APDS_LUX_GAIN_LO_LIMIT_STRICT)\n\t\t \n\t\tret = -ERANGE;\n\n\tchip->again_next = next_again;\n\tapds990x_write_byte(chip, APDS990X_CONTROL,\n\t\t\t(chip->pdrive << 6) |\n\t\t\t(chip->pdiode << 4) |\n\t\t\t(chip->pgain << 2) |\n\t\t\t(chip->again_next << 0));\n\n\t \n\tif (ret < 0)\n\t\tapds990x_force_a_refresh(chip);\n\telse\n\t\tapds990x_refresh_athres(chip);\n\n\treturn ret;\n}\n\n \nstatic int apds990x_get_lux(struct apds990x_chip *chip, int clear, int ir)\n{\n\tint iac, iac1, iac2;  \n\tu32 lpc;  \n\n\t \n\tiac1 = (chip->cf.cf1 * clear - chip->cf.irf1 * ir) / APDS_PARAM_SCALE;\n\tiac2 = (chip->cf.cf2 * clear - chip->cf.irf2 * ir) / APDS_PARAM_SCALE;\n\n\tiac = max(iac1, iac2);\n\tiac = max(iac, 0);\n\n\tlpc = APDS990X_LUX_OUTPUT_SCALE * (chip->cf.df * chip->cf.ga) /\n\t\t(u32)(again[chip->again_meas] * (u32)chip->atime);\n\n\treturn (iac * lpc) / APDS_PARAM_SCALE;\n}\n\nstatic int apds990x_ack_int(struct apds990x_chip *chip, u8 mode)\n{\n\tstruct i2c_client *client = chip->client;\n\ts32 ret;\n\tu8 reg = APDS990x_CMD | APDS990x_CMD_TYPE_SPE;\n\n\tswitch (mode & (APDS990X_ST_AINT | APDS990X_ST_PINT)) {\n\tcase APDS990X_ST_AINT:\n\t\treg |= APDS990X_INT_ACK_ALS;\n\t\tbreak;\n\tcase APDS990X_ST_PINT:\n\t\treg |= APDS990X_INT_ACK_PS;\n\t\tbreak;\n\tdefault:\n\t\treg |= APDS990X_INT_ACK_BOTH;\n\t\tbreak;\n\t}\n\n\tret = i2c_smbus_read_byte_data(client, reg);\n\treturn (int)ret;\n}\n\nstatic irqreturn_t apds990x_irq(int irq, void *data)\n{\n\tstruct apds990x_chip *chip = data;\n\tu8 status;\n\n\tapds990x_read_byte(chip, APDS990X_STATUS, &status);\n\tapds990x_ack_int(chip, status);\n\n\tmutex_lock(&chip->mutex);\n\tif (!pm_runtime_suspended(&chip->client->dev)) {\n\t\tif (status & APDS990X_ST_AINT) {\n\t\t\tapds990x_read_word(chip, APDS990X_CDATAL,\n\t\t\t\t\t&chip->lux_clear);\n\t\t\tapds990x_read_word(chip, APDS990X_IRDATAL,\n\t\t\t\t\t&chip->lux_ir);\n\t\t\t \n\t\t\tchip->again_meas = chip->again_next;\n\n\t\t\tchip->lux_raw = apds990x_get_lux(chip,\n\t\t\t\t\t\t\tchip->lux_clear,\n\t\t\t\t\t\t\tchip->lux_ir);\n\n\t\t\tif (apds990x_calc_again(chip) == 0) {\n\t\t\t\t \n\t\t\t\tchip->lux = chip->lux_raw;\n\t\t\t\tchip->lux_wait_fresh_res = false;\n\t\t\t\twake_up(&chip->wait);\n\t\t\t\tsysfs_notify(&chip->client->dev.kobj,\n\t\t\t\t\tNULL, \"lux0_input\");\n\t\t\t}\n\t\t}\n\n\t\tif ((status & APDS990X_ST_PINT) && chip->prox_en) {\n\t\t\tu16 clr_ch;\n\n\t\t\tapds990x_read_word(chip, APDS990X_CDATAL, &clr_ch);\n\t\t\t \n\t\t\tif (chip->again_meas == 0 &&\n\t\t\t\tclr_ch == chip->a_max_result)\n\t\t\t\tchip->prox_data = 0;\n\t\t\telse\n\t\t\t\tapds990x_read_word(chip,\n\t\t\t\t\t\tAPDS990X_PDATAL,\n\t\t\t\t\t\t&chip->prox_data);\n\n\t\t\tapds990x_refresh_pthres(chip, chip->prox_data);\n\t\t\tif (chip->prox_data < chip->prox_thres)\n\t\t\t\tchip->prox_data = 0;\n\t\t\telse if (!chip->prox_continuous_mode)\n\t\t\t\tchip->prox_data = APDS_PROX_RANGE;\n\t\t\tsysfs_notify(&chip->client->dev.kobj,\n\t\t\t\tNULL, \"prox0_raw\");\n\t\t}\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn IRQ_HANDLED;\n}\n\nstatic int apds990x_configure(struct apds990x_chip *chip)\n{\n\t \n\tapds990x_write_byte(chip, APDS990X_ENABLE, APDS990X_EN_DISABLE_ALL);\n\n\t \n\tapds990x_write_byte(chip, APDS990X_PTIME, APDS990X_PTIME_DEFAULT);\n\tapds990x_write_byte(chip, APDS990X_WTIME, APDS990X_WTIME_DEFAULT);\n\tapds990x_set_atime(chip, APDS_LUX_AVERAGING_TIME);\n\n\tapds990x_write_byte(chip, APDS990X_CONFIG, 0);\n\n\t \n\tapds990x_write_byte(chip, APDS990X_PERS,\n\t\t\t(chip->lux_persistence << APDS990X_APERS_SHIFT) |\n\t\t\t(chip->prox_persistence << APDS990X_PPERS_SHIFT));\n\n\tapds990x_write_byte(chip, APDS990X_PPCOUNT, chip->pdata->ppcount);\n\n\t \n\tchip->again_meas = 1;\n\tchip->again_next = 1;\n\tapds990x_write_byte(chip, APDS990X_CONTROL,\n\t\t\t(chip->pdrive << 6) |\n\t\t\t(chip->pdiode << 4) |\n\t\t\t(chip->pgain << 2) |\n\t\t\t(chip->again_next << 0));\n\treturn 0;\n}\n\nstatic int apds990x_detect(struct apds990x_chip *chip)\n{\n\tstruct i2c_client *client = chip->client;\n\tint ret;\n\tu8 id;\n\n\tret = apds990x_read_byte(chip, APDS990X_ID, &id);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"ID read failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = apds990x_read_byte(chip, APDS990X_REV, &chip->revision);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"REV read failed\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (id) {\n\tcase APDS990X_ID_0:\n\tcase APDS990X_ID_4:\n\tcase APDS990X_ID_29:\n\t\tsnprintf(chip->chipname, sizeof(chip->chipname), \"APDS-990x\");\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic int apds990x_chip_on(struct apds990x_chip *chip)\n{\n\tint err\t = regulator_bulk_enable(ARRAY_SIZE(chip->regs),\n\t\t\t\t\tchip->regs);\n\tif (err < 0)\n\t\treturn err;\n\n\tusleep_range(APDS_STARTUP_DELAY, 2 * APDS_STARTUP_DELAY);\n\n\t \n\tchip->prox_data = 0;\n\tapds990x_configure(chip);\n\tapds990x_mode_on(chip);\n\treturn 0;\n}\n#endif\n\nstatic int apds990x_chip_off(struct apds990x_chip *chip)\n{\n\tapds990x_write_byte(chip, APDS990X_ENABLE, APDS990X_EN_DISABLE_ALL);\n\tregulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);\n\treturn 0;\n}\n\nstatic ssize_t apds990x_lux_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct apds990x_chip *chip = dev_get_drvdata(dev);\n\tssize_t ret;\n\tu32 result;\n\tlong timeout;\n\n\tif (pm_runtime_suspended(dev))\n\t\treturn -EIO;\n\n\ttimeout = wait_event_interruptible_timeout(chip->wait,\n\t\t\t\t\t\t!chip->lux_wait_fresh_res,\n\t\t\t\t\t\tmsecs_to_jiffies(APDS_TIMEOUT));\n\tif (!timeout)\n\t\treturn -EIO;\n\n\tmutex_lock(&chip->mutex);\n\tresult = (chip->lux * chip->lux_calib) / APDS_CALIB_SCALER;\n\tif (result > (APDS_RANGE * APDS990X_LUX_OUTPUT_SCALE))\n\t\tresult = APDS_RANGE * APDS990X_LUX_OUTPUT_SCALE;\n\n\tret = sprintf(buf, \"%d.%d\\n\",\n\t\tresult / APDS990X_LUX_OUTPUT_SCALE,\n\t\tresult % APDS990X_LUX_OUTPUT_SCALE);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(lux0_input, S_IRUGO, apds990x_lux_show, NULL);\n\nstatic ssize_t apds990x_lux_range_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", APDS_RANGE);\n}\n\nstatic DEVICE_ATTR(lux0_sensor_range, S_IRUGO, apds990x_lux_range_show, NULL);\n\nstatic ssize_t apds990x_lux_calib_format_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", APDS_CALIB_SCALER);\n}\n\nstatic DEVICE_ATTR(lux0_calibscale_default, S_IRUGO,\n\t\tapds990x_lux_calib_format_show, NULL);\n\nstatic ssize_t apds990x_lux_calib_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct apds990x_chip *chip = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", chip->lux_calib);\n}\n\nstatic ssize_t apds990x_lux_calib_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct apds990x_chip *chip = dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tchip->lux_calib = value;\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(lux0_calibscale, S_IRUGO | S_IWUSR, apds990x_lux_calib_show,\n\t\tapds990x_lux_calib_store);\n\nstatic ssize_t apds990x_rate_avail(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint i;\n\tint pos = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(arates_hz); i++)\n\t\tpos += sprintf(buf + pos, \"%d \", arates_hz[i]);\n\tsprintf(buf + pos - 1, \"\\n\");\n\treturn pos;\n}\n\nstatic ssize_t apds990x_rate_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", chip->arate);\n}\n\nstatic int apds990x_set_arate(struct apds990x_chip *chip, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(arates_hz); i++)\n\t\tif (rate >= arates_hz[i])\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(arates_hz))\n\t\treturn -EINVAL;\n\n\t \n\tchip->lux_persistence = apersis[i];\n\tchip->arate = arates_hz[i];\n\n\t \n\tif (pm_runtime_suspended(&chip->client->dev))\n\t\treturn 0;\n\n\t \n\treturn apds990x_write_byte(chip, APDS990X_PERS,\n\t\t\t(chip->lux_persistence << APDS990X_APERS_SHIFT) |\n\t\t\t(chip->prox_persistence << APDS990X_PPERS_SHIFT));\n}\n\nstatic ssize_t apds990x_rate_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&chip->mutex);\n\tret = apds990x_set_arate(chip, value);\n\tmutex_unlock(&chip->mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}\n\nstatic DEVICE_ATTR(lux0_rate_avail, S_IRUGO, apds990x_rate_avail, NULL);\n\nstatic DEVICE_ATTR(lux0_rate, S_IRUGO | S_IWUSR, apds990x_rate_show,\n\t\t\t\t\t\t apds990x_rate_store);\n\nstatic ssize_t apds990x_prox_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tssize_t ret;\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\n\tif (pm_runtime_suspended(dev) || !chip->prox_en)\n\t\treturn -EIO;\n\n\tmutex_lock(&chip->mutex);\n\tret = sprintf(buf, \"%d\\n\", chip->prox_data);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(prox0_raw, S_IRUGO, apds990x_prox_show, NULL);\n\nstatic ssize_t apds990x_prox_range_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", APDS_PROX_RANGE);\n}\n\nstatic DEVICE_ATTR(prox0_sensor_range, S_IRUGO, apds990x_prox_range_show, NULL);\n\nstatic ssize_t apds990x_prox_enable_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", chip->prox_en);\n}\n\nstatic ssize_t apds990x_prox_enable_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&chip->mutex);\n\n\tif (!chip->prox_en)\n\t\tchip->prox_data = 0;\n\n\tif (value)\n\t\tchip->prox_en++;\n\telse if (chip->prox_en > 0)\n\t\tchip->prox_en--;\n\n\tif (!pm_runtime_suspended(dev))\n\t\tapds990x_mode_on(chip);\n\tmutex_unlock(&chip->mutex);\n\treturn len;\n}\n\nstatic DEVICE_ATTR(prox0_raw_en, S_IRUGO | S_IWUSR, apds990x_prox_enable_show,\n\t\t\t\t\t\t   apds990x_prox_enable_store);\n\nstatic const char *reporting_modes[] = {\"trigger\", \"periodic\"};\n\nstatic ssize_t apds990x_prox_reporting_mode_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\",\n\t\treporting_modes[!!chip->prox_continuous_mode]);\n}\n\nstatic ssize_t apds990x_prox_reporting_mode_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\tint ret;\n\n\tret = sysfs_match_string(reporting_modes, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchip->prox_continuous_mode = ret;\n\treturn len;\n}\n\nstatic DEVICE_ATTR(prox0_reporting_mode, S_IRUGO | S_IWUSR,\n\t\tapds990x_prox_reporting_mode_show,\n\t\tapds990x_prox_reporting_mode_store);\n\nstatic ssize_t apds990x_prox_reporting_avail_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s %s\\n\", reporting_modes[0], reporting_modes[1]);\n}\n\nstatic DEVICE_ATTR(prox0_reporting_mode_avail, S_IRUGO | S_IWUSR,\n\t\tapds990x_prox_reporting_avail_show, NULL);\n\n\nstatic ssize_t apds990x_lux_thresh_above_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", chip->lux_thres_hi);\n}\n\nstatic ssize_t apds990x_lux_thresh_below_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", chip->lux_thres_lo);\n}\n\nstatic ssize_t apds990x_set_lux_thresh(struct apds990x_chip *chip, u32 *target,\n\t\t\t\tconst char *buf)\n{\n\tunsigned long thresh;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &thresh);\n\tif (ret)\n\t\treturn ret;\n\n\tif (thresh > APDS_RANGE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->mutex);\n\t*target = thresh;\n\t \n\tif (!chip->lux_wait_fresh_res)\n\t\tapds990x_refresh_athres(chip);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n\n}\n\nstatic ssize_t apds990x_lux_thresh_above_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\tint ret = apds990x_set_lux_thresh(chip, &chip->lux_thres_hi, buf);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}\n\nstatic ssize_t apds990x_lux_thresh_below_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\tint ret = apds990x_set_lux_thresh(chip, &chip->lux_thres_lo, buf);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}\n\nstatic DEVICE_ATTR(lux0_thresh_above_value, S_IRUGO | S_IWUSR,\n\t\tapds990x_lux_thresh_above_show,\n\t\tapds990x_lux_thresh_above_store);\n\nstatic DEVICE_ATTR(lux0_thresh_below_value, S_IRUGO | S_IWUSR,\n\t\tapds990x_lux_thresh_below_show,\n\t\tapds990x_lux_thresh_below_store);\n\nstatic ssize_t apds990x_prox_threshold_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", chip->prox_thres);\n}\n\nstatic ssize_t apds990x_prox_threshold_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((value > APDS_RANGE) || (value == 0) ||\n\t\t(value < APDS_PROX_HYSTERESIS))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->mutex);\n\tchip->prox_thres = value;\n\n\tapds990x_force_p_refresh(chip);\n\tmutex_unlock(&chip->mutex);\n\treturn len;\n}\n\nstatic DEVICE_ATTR(prox0_thresh_above_value, S_IRUGO | S_IWUSR,\n\t\tapds990x_prox_threshold_show,\n\t\tapds990x_prox_threshold_store);\n\nstatic ssize_t apds990x_power_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !pm_runtime_suspended(dev));\n\treturn 0;\n}\n\nstatic ssize_t apds990x_power_state_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value) {\n\t\tpm_runtime_get_sync(dev);\n\t\tmutex_lock(&chip->mutex);\n\t\tchip->lux_wait_fresh_res = true;\n\t\tapds990x_force_a_refresh(chip);\n\t\tapds990x_force_p_refresh(chip);\n\t\tmutex_unlock(&chip->mutex);\n\t} else {\n\t\tif (!pm_runtime_suspended(dev))\n\t\t\tpm_runtime_put(dev);\n\t}\n\treturn len;\n}\n\nstatic DEVICE_ATTR(power_state, S_IRUGO | S_IWUSR,\n\t\tapds990x_power_state_show,\n\t\tapds990x_power_state_store);\n\nstatic ssize_t apds990x_chip_id_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct apds990x_chip *chip =  dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s %d\\n\", chip->chipname, chip->revision);\n}\n\nstatic DEVICE_ATTR(chip_id, S_IRUGO, apds990x_chip_id_show, NULL);\n\nstatic struct attribute *sysfs_attrs_ctrl[] = {\n\t&dev_attr_lux0_calibscale.attr,\n\t&dev_attr_lux0_calibscale_default.attr,\n\t&dev_attr_lux0_input.attr,\n\t&dev_attr_lux0_sensor_range.attr,\n\t&dev_attr_lux0_rate.attr,\n\t&dev_attr_lux0_rate_avail.attr,\n\t&dev_attr_lux0_thresh_above_value.attr,\n\t&dev_attr_lux0_thresh_below_value.attr,\n\t&dev_attr_prox0_raw_en.attr,\n\t&dev_attr_prox0_raw.attr,\n\t&dev_attr_prox0_sensor_range.attr,\n\t&dev_attr_prox0_thresh_above_value.attr,\n\t&dev_attr_prox0_reporting_mode.attr,\n\t&dev_attr_prox0_reporting_mode_avail.attr,\n\t&dev_attr_chip_id.attr,\n\t&dev_attr_power_state.attr,\n\tNULL\n};\n\nstatic const struct attribute_group apds990x_attribute_group[] = {\n\t{.attrs = sysfs_attrs_ctrl },\n};\n\nstatic int apds990x_probe(struct i2c_client *client)\n{\n\tstruct apds990x_chip *chip;\n\tint err;\n\n\tchip = kzalloc(sizeof *chip, GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, chip);\n\tchip->client  = client;\n\n\tinit_waitqueue_head(&chip->wait);\n\tmutex_init(&chip->mutex);\n\tchip->pdata\t= client->dev.platform_data;\n\n\tif (chip->pdata == NULL) {\n\t\tdev_err(&client->dev, \"platform data is mandatory\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail1;\n\t}\n\n\tif (chip->pdata->cf.ga == 0) {\n\t\t \n\t\tchip->cf.ga = 1966;  \n\t\tchip->cf.cf1 = 4096;  \n\t\tchip->cf.irf1 = 9134;  \n\t\tchip->cf.cf2 = 2867;  \n\t\tchip->cf.irf2 = 5816;  \n\t\tchip->cf.df = 52;\n\t} else {\n\t\tchip->cf = chip->pdata->cf;\n\t}\n\n\t \n\tchip->rcf.afactor =\n\t\t(chip->cf.irf1 - chip->cf.irf2) * APDS_PARAM_SCALE /\n\t\t(chip->cf.cf1 - chip->cf.cf2);\n\tchip->rcf.cf1 = APDS_PARAM_SCALE * APDS_PARAM_SCALE /\n\t\tchip->cf.cf1;\n\tchip->rcf.irf1 = chip->cf.irf1 * APDS_PARAM_SCALE /\n\t\tchip->cf.cf1;\n\tchip->rcf.cf2 = APDS_PARAM_SCALE * APDS_PARAM_SCALE /\n\t\tchip->cf.cf2;\n\tchip->rcf.irf2 = chip->cf.irf2 * APDS_PARAM_SCALE /\n\t\tchip->cf.cf2;\n\n\t \n\tchip->lux_thres_hi = APDS_LUX_DEF_THRES_HI;\n\tchip->lux_thres_lo = APDS_LUX_DEF_THRES_LO;\n\tchip->lux_calib = APDS_LUX_NEUTRAL_CALIB_VALUE;\n\n\tchip->prox_thres = APDS_PROX_DEF_THRES;\n\tchip->pdrive = chip->pdata->pdrive;\n\tchip->pdiode = APDS_PDIODE_IR;\n\tchip->pgain = APDS_PGAIN_1X;\n\tchip->prox_calib = APDS_PROX_NEUTRAL_CALIB_VALUE;\n\tchip->prox_persistence = APDS_DEFAULT_PROX_PERS;\n\tchip->prox_continuous_mode = false;\n\n\tchip->regs[0].supply = reg_vcc;\n\tchip->regs[1].supply = reg_vled;\n\n\terr = regulator_bulk_get(&client->dev,\n\t\t\t\t ARRAY_SIZE(chip->regs), chip->regs);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Cannot get regulators\\n\");\n\t\tgoto fail1;\n\t}\n\n\terr = regulator_bulk_enable(ARRAY_SIZE(chip->regs), chip->regs);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Cannot enable regulators\\n\");\n\t\tgoto fail2;\n\t}\n\n\tusleep_range(APDS_STARTUP_DELAY, 2 * APDS_STARTUP_DELAY);\n\n\terr = apds990x_detect(chip);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"APDS990X not found\\n\");\n\t\tgoto fail3;\n\t}\n\n\tpm_runtime_set_active(&client->dev);\n\n\tapds990x_configure(chip);\n\tapds990x_set_arate(chip, APDS_LUX_DEFAULT_RATE);\n\tapds990x_mode_on(chip);\n\n\tpm_runtime_enable(&client->dev);\n\n\tif (chip->pdata->setup_resources) {\n\t\terr = chip->pdata->setup_resources();\n\t\tif (err) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail3;\n\t\t}\n\t}\n\n\terr = sysfs_create_group(&chip->client->dev.kobj,\n\t\t\t\tapds990x_attribute_group);\n\tif (err < 0) {\n\t\tdev_err(&chip->client->dev, \"Sysfs registration failed\\n\");\n\t\tgoto fail4;\n\t}\n\n\terr = request_threaded_irq(client->irq, NULL,\n\t\t\t\tapds990x_irq,\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_TRIGGER_LOW |\n\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\"apds990x\", chip);\n\tif (err) {\n\t\tdev_err(&client->dev, \"could not get IRQ %d\\n\",\n\t\t\tclient->irq);\n\t\tgoto fail5;\n\t}\n\treturn err;\nfail5:\n\tsysfs_remove_group(&chip->client->dev.kobj,\n\t\t\t&apds990x_attribute_group[0]);\nfail4:\n\tif (chip->pdata && chip->pdata->release_resources)\n\t\tchip->pdata->release_resources();\nfail3:\n\tregulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);\nfail2:\n\tregulator_bulk_free(ARRAY_SIZE(chip->regs), chip->regs);\nfail1:\n\tkfree(chip);\n\treturn err;\n}\n\nstatic void apds990x_remove(struct i2c_client *client)\n{\n\tstruct apds990x_chip *chip = i2c_get_clientdata(client);\n\n\tfree_irq(client->irq, chip);\n\tsysfs_remove_group(&chip->client->dev.kobj,\n\t\t\tapds990x_attribute_group);\n\n\tif (chip->pdata && chip->pdata->release_resources)\n\t\tchip->pdata->release_resources();\n\n\tif (!pm_runtime_suspended(&client->dev))\n\t\tapds990x_chip_off(chip);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tregulator_bulk_free(ARRAY_SIZE(chip->regs), chip->regs);\n\n\tkfree(chip);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int apds990x_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct apds990x_chip *chip = i2c_get_clientdata(client);\n\n\tapds990x_chip_off(chip);\n\treturn 0;\n}\n\nstatic int apds990x_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct apds990x_chip *chip = i2c_get_clientdata(client);\n\n\t \n\tapds990x_chip_on(chip);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int apds990x_runtime_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct apds990x_chip *chip = i2c_get_clientdata(client);\n\n\tapds990x_chip_off(chip);\n\treturn 0;\n}\n\nstatic int apds990x_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct apds990x_chip *chip = i2c_get_clientdata(client);\n\n\tapds990x_chip_on(chip);\n\treturn 0;\n}\n\n#endif\n\nstatic const struct i2c_device_id apds990x_id[] = {\n\t{\"apds990x\", 0 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, apds990x_id);\n\nstatic const struct dev_pm_ops apds990x_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(apds990x_suspend, apds990x_resume)\n\tSET_RUNTIME_PM_OPS(apds990x_runtime_suspend,\n\t\t\tapds990x_runtime_resume,\n\t\t\tNULL)\n};\n\nstatic struct i2c_driver apds990x_driver = {\n\t.driver\t  = {\n\t\t.name\t= \"apds990x\",\n\t\t.pm\t= &apds990x_pm_ops,\n\t},\n\t.probe    = apds990x_probe,\n\t.remove\t  = apds990x_remove,\n\t.id_table = apds990x_id,\n};\n\nmodule_i2c_driver(apds990x_driver);\n\nMODULE_DESCRIPTION(\"APDS990X combined ALS and proximity sensor\");\nMODULE_AUTHOR(\"Samu Onkalo, Nokia Corporation\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}