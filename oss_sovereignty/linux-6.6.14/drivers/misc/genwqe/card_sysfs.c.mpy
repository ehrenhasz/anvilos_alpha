{
  "module_name": "card_sysfs.c",
  "hash_id": "e44fa955201025b4a7b254d361e879d6c0ee1b508ebb7a8839da98cb7786731a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/genwqe/card_sysfs.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/sysfs.h>\n#include <linux/ctype.h>\n#include <linux/device.h>\n\n#include \"card_base.h\"\n#include \"card_ddcb.h\"\n\nstatic const char * const genwqe_types[] = {\n\t[GENWQE_TYPE_ALTERA_230] = \"GenWQE4-230\",\n\t[GENWQE_TYPE_ALTERA_530] = \"GenWQE4-530\",\n\t[GENWQE_TYPE_ALTERA_A4]  = \"GenWQE5-A4\",\n\t[GENWQE_TYPE_ALTERA_A7]  = \"GenWQE5-A7\",\n};\n\nstatic ssize_t status_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\tconst char *cs[GENWQE_CARD_STATE_MAX] = { \"unused\", \"used\", \"error\" };\n\n\treturn sprintf(buf, \"%s\\n\", cs[cd->card_state]);\n}\nstatic DEVICE_ATTR_RO(status);\n\nstatic ssize_t appid_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tchar app_name[5];\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\n\tgenwqe_read_app_id(cd, app_name, sizeof(app_name));\n\treturn sprintf(buf, \"%s\\n\", app_name);\n}\nstatic DEVICE_ATTR_RO(appid);\n\nstatic ssize_t version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tu64 slu_id, app_id;\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\n\tslu_id = __genwqe_readq(cd, IO_SLU_UNITCFG);\n\tapp_id = __genwqe_readq(cd, IO_APP_UNITCFG);\n\n\treturn sprintf(buf, \"%016llx.%016llx\\n\", slu_id, app_id);\n}\nstatic DEVICE_ATTR_RO(version);\n\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tu8 card_type;\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\n\tcard_type = genwqe_card_type(cd);\n\treturn sprintf(buf, \"%s\\n\", (card_type >= ARRAY_SIZE(genwqe_types)) ?\n\t\t       \"invalid\" : genwqe_types[card_type]);\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic ssize_t tempsens_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tu64 tempsens;\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\n\ttempsens = __genwqe_readq(cd, IO_SLU_TEMPERATURE_SENSOR);\n\treturn sprintf(buf, \"%016llx\\n\", tempsens);\n}\nstatic DEVICE_ATTR_RO(tempsens);\n\nstatic ssize_t freerunning_timer_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tu64 t;\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\n\tt = __genwqe_readq(cd, IO_SLC_FREE_RUNNING_TIMER);\n\treturn sprintf(buf, \"%016llx\\n\", t);\n}\nstatic DEVICE_ATTR_RO(freerunning_timer);\n\nstatic ssize_t queue_working_time_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tu64 t;\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\n\tt = __genwqe_readq(cd, IO_SLC_QUEUE_WTIME);\n\treturn sprintf(buf, \"%016llx\\n\", t);\n}\nstatic DEVICE_ATTR_RO(queue_working_time);\n\nstatic ssize_t base_clock_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tu64 base_clock;\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\n\tbase_clock = genwqe_base_clock_frequency(cd);\n\treturn sprintf(buf, \"%lld\\n\", base_clock);\n}\nstatic DEVICE_ATTR_RO(base_clock);\n\n \nstatic ssize_t curr_bitstream_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint curr_bitstream;\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\n\tcurr_bitstream = __genwqe_readq(cd, IO_SLU_BITSTREAM) & 0x1;\n\treturn sprintf(buf, \"%d\\n\", curr_bitstream);\n}\nstatic DEVICE_ATTR_RO(curr_bitstream);\n\n \nstatic ssize_t next_bitstream_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint next_bitstream;\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\n\tswitch ((cd->softreset & 0xc) >> 2) {\n\tcase 0x2:\n\t\tnext_bitstream =  0;\n\t\tbreak;\n\tcase 0x3:\n\t\tnext_bitstream =  1;\n\t\tbreak;\n\tdefault:\n\t\tnext_bitstream = -1;\n\t\tbreak;\t\t \n\t}\n\treturn sprintf(buf, \"%d\\n\", next_bitstream);\n}\n\nstatic ssize_t next_bitstream_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint partition;\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\n\tif (kstrtoint(buf, 0, &partition) < 0)\n\t\treturn -EINVAL;\n\n\tswitch (partition) {\n\tcase 0x0:\n\t\tcd->softreset = 0x78;\n\t\tbreak;\n\tcase 0x1:\n\t\tcd->softreset = 0x7c;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t__genwqe_writeq(cd, IO_SLC_CFGREG_SOFTRESET, cd->softreset);\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(next_bitstream);\n\nstatic ssize_t reload_bitstream_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tint reload;\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\n\tif (kstrtoint(buf, 0, &reload) < 0)\n\t\treturn -EINVAL;\n\n\tif (reload == 0x1) {\n\t\tif (cd->card_state == GENWQE_CARD_UNUSED ||\n\t\t    cd->card_state == GENWQE_CARD_USED)\n\t\t\tcd->card_state = GENWQE_CARD_RELOAD_BITSTREAM;\n\t\telse\n\t\t\treturn -EIO;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(reload_bitstream);\n\n \nstatic struct attribute *genwqe_attributes[] = {\n\t&dev_attr_tempsens.attr,\n\t&dev_attr_next_bitstream.attr,\n\t&dev_attr_curr_bitstream.attr,\n\t&dev_attr_base_clock.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_version.attr,\n\t&dev_attr_appid.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_freerunning_timer.attr,\n\t&dev_attr_queue_working_time.attr,\n\t&dev_attr_reload_bitstream.attr,\n\tNULL,\n};\n\nstatic struct attribute *genwqe_normal_attributes[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_version.attr,\n\t&dev_attr_appid.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_freerunning_timer.attr,\n\t&dev_attr_queue_working_time.attr,\n\tNULL,\n};\n\n \nstatic umode_t genwqe_is_visible(struct kobject *kobj,\n\t\t\t\t struct attribute *attr, int n)\n{\n\tunsigned int j;\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct genwqe_dev *cd = dev_get_drvdata(dev);\n\tumode_t mode = attr->mode;\n\n\tif (genwqe_is_privileged(cd))\n\t\treturn mode;\n\n\tfor (j = 0; genwqe_normal_attributes[j] != NULL;  j++)\n\t\tif (genwqe_normal_attributes[j] == attr)\n\t\t\treturn mode;\n\n\treturn 0;\n}\n\nstatic struct attribute_group genwqe_attribute_group = {\n\t.is_visible = genwqe_is_visible,\n\t.attrs      = genwqe_attributes,\n};\n\nconst struct attribute_group *genwqe_attribute_groups[] = {\n\t&genwqe_attribute_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}