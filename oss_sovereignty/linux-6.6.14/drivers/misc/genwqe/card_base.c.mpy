{
  "module_name": "card_base.c",
  "hash_id": "b0d825d5526dca2aaeefebcbb36e3eab156f55c9d4f0fc083ac5c6ea9ba9fcb2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/genwqe/card_base.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/device.h>\n#include <linux/log2.h>\n\n#include \"card_base.h\"\n#include \"card_ddcb.h\"\n\nMODULE_AUTHOR(\"Frank Haverkamp <haver@linux.vnet.ibm.com>\");\nMODULE_AUTHOR(\"Michael Ruettger <michael@ibmra.de>\");\nMODULE_AUTHOR(\"Joerg-Stephan Vogt <jsvogt@de.ibm.com>\");\nMODULE_AUTHOR(\"Michael Jung <mijung@gmx.net>\");\n\nMODULE_DESCRIPTION(\"GenWQE Card\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_LICENSE(\"GPL\");\n\nstatic char genwqe_driver_name[] = GENWQE_DEVNAME;\n\nstatic struct dentry *debugfs_genwqe;\nstatic struct genwqe_dev *genwqe_devices[GENWQE_CARD_NO_MAX];\n\n \nstatic const struct pci_device_id genwqe_device_table[] = {\n\t{ .vendor      = PCI_VENDOR_ID_IBM,\n\t  .device      = PCI_DEVICE_GENWQE,\n\t  .subvendor   = PCI_SUBVENDOR_ID_IBM,\n\t  .subdevice   = PCI_SUBSYSTEM_ID_GENWQE5,\n\t  .class       = (PCI_CLASSCODE_GENWQE5 << 8),\n\t  .class_mask  = ~0,\n\t  .driver_data = 0 },\n\n\t \n\t{ .vendor      = PCI_VENDOR_ID_IBM,\n\t  .device      = PCI_DEVICE_GENWQE,\n\t  .subvendor   = PCI_SUBVENDOR_ID_IBM_SRIOV,\n\t  .subdevice   = PCI_SUBSYSTEM_ID_GENWQE5_SRIOV,\n\t  .class       = (PCI_CLASSCODE_GENWQE5_SRIOV << 8),\n\t  .class_mask  = ~0,\n\t  .driver_data = 0 },\n\n\t{ .vendor      = PCI_VENDOR_ID_IBM,   \n\t  .device      = 0x0000,   \n\t  .subvendor   = PCI_SUBVENDOR_ID_IBM_SRIOV,\n\t  .subdevice   = PCI_SUBSYSTEM_ID_GENWQE5_SRIOV,\n\t  .class       = (PCI_CLASSCODE_GENWQE5_SRIOV << 8),\n\t  .class_mask  = ~0,\n\t  .driver_data = 0 },\n\n\t \n\t{ .vendor      = PCI_VENDOR_ID_IBM,\n\t  .device      = PCI_DEVICE_GENWQE,\n\t  .subvendor   = PCI_SUBVENDOR_ID_IBM_SRIOV,\n\t  .subdevice   = PCI_SUBSYSTEM_ID_GENWQE5,\n\t  .class       = (PCI_CLASSCODE_GENWQE5_SRIOV << 8),\n\t  .class_mask  = ~0,\n\t  .driver_data = 0 },\n\n\t{ .vendor      = PCI_VENDOR_ID_IBM,   \n\t  .device      = 0x0000,   \n\t  .subvendor   = PCI_SUBVENDOR_ID_IBM_SRIOV,\n\t  .subdevice   = PCI_SUBSYSTEM_ID_GENWQE5,\n\t  .class       = (PCI_CLASSCODE_GENWQE5_SRIOV << 8),\n\t  .class_mask  = ~0,\n\t  .driver_data = 0 },\n\n\t \n\t{ .vendor      = PCI_VENDOR_ID_IBM,\n\t  .device      = PCI_DEVICE_GENWQE,\n\t  .subvendor   = PCI_SUBVENDOR_ID_IBM,\n\t  .subdevice   = PCI_SUBSYSTEM_ID_GENWQE5_NEW,\n\t  .class       = (PCI_CLASSCODE_GENWQE5 << 8),\n\t  .class_mask  = ~0,\n\t  .driver_data = 0 },\n\n\t{ 0, }\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, genwqe_device_table);\n\n \nstatic char *genwqe_devnode(const struct device *dev, umode_t *mode)\n{\n\tif (mode)\n\t\t*mode = 0666;\n\treturn NULL;\n}\n\nstatic const struct class class_genwqe = {\n\t.name = GENWQE_DEVNAME,\n\t.devnode = genwqe_devnode,\n};\n\n \nstatic struct genwqe_dev *genwqe_dev_alloc(void)\n{\n\tunsigned int i = 0, j;\n\tstruct genwqe_dev *cd;\n\n\tfor (i = 0; i < GENWQE_CARD_NO_MAX; i++) {\n\t\tif (genwqe_devices[i] == NULL)\n\t\t\tbreak;\n\t}\n\tif (i >= GENWQE_CARD_NO_MAX)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tcd = kzalloc(sizeof(struct genwqe_dev), GFP_KERNEL);\n\tif (!cd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcd->card_idx = i;\n\tcd->class_genwqe = &class_genwqe;\n\tcd->debugfs_genwqe = debugfs_genwqe;\n\n\t \n\tcd->use_platform_recovery = CONFIG_GENWQE_PLATFORM_ERROR_RECOVERY;\n\n\tinit_waitqueue_head(&cd->queue_waitq);\n\n\tspin_lock_init(&cd->file_lock);\n\tINIT_LIST_HEAD(&cd->file_list);\n\n\tcd->card_state = GENWQE_CARD_UNUSED;\n\tspin_lock_init(&cd->print_lock);\n\n\tcd->ddcb_software_timeout = GENWQE_DDCB_SOFTWARE_TIMEOUT;\n\tcd->kill_timeout = GENWQE_KILL_TIMEOUT;\n\n\tfor (j = 0; j < GENWQE_MAX_VFS; j++)\n\t\tcd->vf_jobtimeout_msec[j] = GENWQE_VF_JOBTIMEOUT_MSEC;\n\n\tgenwqe_devices[i] = cd;\n\treturn cd;\n}\n\nstatic void genwqe_dev_free(struct genwqe_dev *cd)\n{\n\tif (!cd)\n\t\treturn;\n\n\tgenwqe_devices[cd->card_idx] = NULL;\n\tkfree(cd);\n}\n\n \nstatic int genwqe_bus_reset(struct genwqe_dev *cd)\n{\n\tint rc = 0;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tvoid __iomem *mmio;\n\n\tif (cd->err_inject & GENWQE_INJECT_BUS_RESET_FAILURE)\n\t\treturn -EIO;\n\n\tmmio = cd->mmio;\n\tcd->mmio = NULL;\n\tpci_iounmap(pci_dev, mmio);\n\n\tpci_release_mem_regions(pci_dev);\n\n\t \n\tdev_dbg(&pci_dev->dev, \"[%s] pci_reset function ...\\n\", __func__);\n\trc = pci_reset_function(pci_dev);\n\tif (rc) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: failed reset func (rc %d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\tdev_dbg(&pci_dev->dev, \"[%s] done with rc=%d\\n\", __func__, rc);\n\n\t \n\tcd->err_inject &= ~(GENWQE_INJECT_HARDWARE_FAILURE |\n\t\t\t    GENWQE_INJECT_GFIR_FATAL |\n\t\t\t    GENWQE_INJECT_GFIR_INFO);\n\n\trc = pci_request_mem_regions(pci_dev, genwqe_driver_name);\n\tif (rc) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: request bars failed (%d)\\n\", __func__, rc);\n\t\treturn -EIO;\n\t}\n\n\tcd->mmio = pci_iomap(pci_dev, 0, 0);\n\tif (cd->mmio == NULL) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: mapping BAR0 failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \n\nbool genwqe_need_err_masking(struct genwqe_dev *cd)\n{\n\treturn (cd->slu_unitcfg & 0xFFFF0ull) < 0x32170ull;\n}\n\nstatic void genwqe_tweak_hardware(struct genwqe_dev *cd)\n{\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\t \n\tif (((cd->slu_unitcfg & 0xFFFF0ull) >= 0x32000ull) &&\n\t    ((cd->slu_unitcfg & 0xFFFF0ull) <= 0x33250ull)) {\n\t\tdev_warn(&pci_dev->dev,\n\t\t\t \"FIRs masked due to bitstream %016llx.%016llx\\n\",\n\t\t\t cd->slu_unitcfg, cd->app_unitcfg);\n\n\t\t__genwqe_writeq(cd, IO_APP_SEC_LEM_DEBUG_OVR,\n\t\t\t\t0xFFFFFFFFFFFFFFFFull);\n\n\t\t__genwqe_writeq(cd, IO_APP_ERR_ACT_MASK,\n\t\t\t\t0x0000000000000000ull);\n\t}\n}\n\n \nint genwqe_recovery_on_fatal_gfir_required(struct genwqe_dev *cd)\n{\n\treturn (cd->slu_unitcfg & 0xFFFF0ull) >= 0x32170ull;\n}\n\nint genwqe_flash_readback_fails(struct genwqe_dev *cd)\n{\n\treturn (cd->slu_unitcfg & 0xFFFF0ull) < 0x32170ull;\n}\n\n \n \nstatic int genwqe_T_psec(struct genwqe_dev *cd)\n{\n\tu16 speed;\t \n\tstatic const int T[] = { 4000, 5000, 6000, 5714 };\n\n\tspeed = (u16)((cd->slu_unitcfg >> 28) & 0x0full);\n\tif (speed >= ARRAY_SIZE(T))\n\t\treturn -1;\t \n\n\treturn T[speed];\n}\n\n \nstatic bool genwqe_setup_pf_jtimer(struct genwqe_dev *cd)\n{\n\tu32 T = genwqe_T_psec(cd);\n\tu64 x;\n\n\tif (GENWQE_PF_JOBTIMEOUT_MSEC == 0)\n\t\treturn false;\n\n\t \n\tx = ilog2(GENWQE_PF_JOBTIMEOUT_MSEC *\n\t\t  16000000000uL/(T * 15)) - 10;\n\n\tgenwqe_write_vreg(cd, IO_SLC_VF_APPJOB_TIMEOUT,\n\t\t\t  0xff00 | (x & 0xff), 0);\n\treturn true;\n}\n\n \nstatic bool genwqe_setup_vf_jtimer(struct genwqe_dev *cd)\n{\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tunsigned int vf;\n\tu32 T = genwqe_T_psec(cd);\n\tu64 x;\n\tint totalvfs;\n\n\ttotalvfs = pci_sriov_get_totalvfs(pci_dev);\n\tif (totalvfs <= 0)\n\t\treturn false;\n\n\tfor (vf = 0; vf < totalvfs; vf++) {\n\n\t\tif (cd->vf_jobtimeout_msec[vf] == 0)\n\t\t\tcontinue;\n\n\t\tx = ilog2(cd->vf_jobtimeout_msec[vf] *\n\t\t\t  16000000000uL/(T * 15)) - 10;\n\n\t\tgenwqe_write_vreg(cd, IO_SLC_VF_APPJOB_TIMEOUT,\n\t\t\t\t  0xff00 | (x & 0xff), vf + 1);\n\t}\n\treturn true;\n}\n\nstatic int genwqe_ffdc_buffs_alloc(struct genwqe_dev *cd)\n{\n\tunsigned int type, e = 0;\n\n\tfor (type = 0; type < GENWQE_DBG_UNITS; type++) {\n\t\tswitch (type) {\n\t\tcase GENWQE_DBG_UNIT0:\n\t\t\te = genwqe_ffdc_buff_size(cd, 0);\n\t\t\tbreak;\n\t\tcase GENWQE_DBG_UNIT1:\n\t\t\te = genwqe_ffdc_buff_size(cd, 1);\n\t\t\tbreak;\n\t\tcase GENWQE_DBG_UNIT2:\n\t\t\te = genwqe_ffdc_buff_size(cd, 2);\n\t\t\tbreak;\n\t\tcase GENWQE_DBG_REGS:\n\t\t\te = GENWQE_FFDC_REGS;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcd->ffdc[type].entries = e;\n\t\tcd->ffdc[type].regs =\n\t\t\tkmalloc_array(e, sizeof(struct genwqe_reg),\n\t\t\t\t      GFP_KERNEL);\n\t\t \n\t}\n\treturn 0;\n}\n\nstatic void genwqe_ffdc_buffs_free(struct genwqe_dev *cd)\n{\n\tunsigned int type;\n\n\tfor (type = 0; type < GENWQE_DBG_UNITS; type++) {\n\t\tkfree(cd->ffdc[type].regs);\n\t\tcd->ffdc[type].regs = NULL;\n\t}\n}\n\nstatic int genwqe_read_ids(struct genwqe_dev *cd)\n{\n\tint err = 0;\n\tint slu_id;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tcd->slu_unitcfg = __genwqe_readq(cd, IO_SLU_UNITCFG);\n\tif (cd->slu_unitcfg == IO_ILLEGAL_VALUE) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"err: SLUID=%016llx\\n\", cd->slu_unitcfg);\n\t\terr = -EIO;\n\t\tgoto out_err;\n\t}\n\n\tslu_id = genwqe_get_slu_id(cd);\n\tif (slu_id < GENWQE_SLU_ARCH_REQ || slu_id == 0xff) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"err: incompatible SLU Architecture %u\\n\", slu_id);\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tcd->app_unitcfg = __genwqe_readq(cd, IO_APP_UNITCFG);\n\tif (cd->app_unitcfg == IO_ILLEGAL_VALUE) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"err: APPID=%016llx\\n\", cd->app_unitcfg);\n\t\terr = -EIO;\n\t\tgoto out_err;\n\t}\n\tgenwqe_read_app_id(cd, cd->app_name, sizeof(cd->app_name));\n\n\t \n\tif (pci_dev->is_virtfn)\n\t\tcd->is_privileged = 0;\n\telse\n\t\tcd->is_privileged = (__genwqe_readq(cd, IO_SLU_BITSTREAM)\n\t\t\t\t     != IO_ILLEGAL_VALUE);\n\n out_err:\n\treturn err;\n}\n\nstatic int genwqe_start(struct genwqe_dev *cd)\n{\n\tint err;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\terr = genwqe_read_ids(cd);\n\tif (err)\n\t\treturn err;\n\n\tif (genwqe_is_privileged(cd)) {\n\t\t \n\t\tgenwqe_ffdc_buffs_alloc(cd);\n\t\tgenwqe_stop_traps(cd);\n\n\t\t \n\t\tgenwqe_read_ffdc_regs(cd, cd->ffdc[GENWQE_DBG_REGS].regs,\n\t\t\t\t      cd->ffdc[GENWQE_DBG_REGS].entries, 0);\n\n\t\tgenwqe_ffdc_buff_read(cd, GENWQE_DBG_UNIT0,\n\t\t\t\t      cd->ffdc[GENWQE_DBG_UNIT0].regs,\n\t\t\t\t      cd->ffdc[GENWQE_DBG_UNIT0].entries);\n\n\t\tgenwqe_ffdc_buff_read(cd, GENWQE_DBG_UNIT1,\n\t\t\t\t      cd->ffdc[GENWQE_DBG_UNIT1].regs,\n\t\t\t\t      cd->ffdc[GENWQE_DBG_UNIT1].entries);\n\n\t\tgenwqe_ffdc_buff_read(cd, GENWQE_DBG_UNIT2,\n\t\t\t\t      cd->ffdc[GENWQE_DBG_UNIT2].regs,\n\t\t\t\t      cd->ffdc[GENWQE_DBG_UNIT2].entries);\n\n\t\tgenwqe_start_traps(cd);\n\n\t\tif (cd->card_state == GENWQE_CARD_FATAL_ERROR) {\n\t\t\tdev_warn(&pci_dev->dev,\n\t\t\t\t \"[%s] chip reload/recovery!\\n\", __func__);\n\n\t\t\t \n\t\t\tcd->softreset = 0x7Cull;\n\t\t\t__genwqe_writeq(cd, IO_SLC_CFGREG_SOFTRESET,\n\t\t\t\t       cd->softreset);\n\n\t\t\terr = genwqe_bus_reset(cd);\n\t\t\tif (err != 0) {\n\t\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\t\"[%s] err: bus reset failed!\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\terr = genwqe_read_ids(cd);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = genwqe_setup_service_layer(cd);   \n\tif (err != 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: could not setup servicelayer!\\n\", __func__);\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (genwqe_is_privileged(cd)) {\t  \n\t\tgenwqe_tweak_hardware(cd);\n\n\t\tgenwqe_setup_pf_jtimer(cd);\n\t\tgenwqe_setup_vf_jtimer(cd);\n\t}\n\n\terr = genwqe_device_create(cd);\n\tif (err < 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"err: chdev init failed! (err=%d)\\n\", err);\n\t\tgoto out_release_service_layer;\n\t}\n\treturn 0;\n\n out_release_service_layer:\n\tgenwqe_release_service_layer(cd);\n out:\n\tif (genwqe_is_privileged(cd))\n\t\tgenwqe_ffdc_buffs_free(cd);\n\treturn -EIO;\n}\n\n \nstatic int genwqe_stop(struct genwqe_dev *cd)\n{\n\tgenwqe_finish_queue(cd);\t     \n\tgenwqe_device_remove(cd);\t     \n\tgenwqe_release_service_layer(cd);    \n\n\tif (genwqe_is_privileged(cd)) {\n\t\tpci_disable_sriov(cd->pci_dev);\t \n\t\tgenwqe_ffdc_buffs_free(cd);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int genwqe_recover_card(struct genwqe_dev *cd, int fatal_err)\n{\n\tint rc;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tgenwqe_stop(cd);\n\n\t \n\tif (!fatal_err) {\n\t\tcd->softreset = 0x70ull;\n\t\t__genwqe_writeq(cd, IO_SLC_CFGREG_SOFTRESET, cd->softreset);\n\t}\n\n\trc = genwqe_bus_reset(cd);\n\tif (rc != 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: card recovery impossible!\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = genwqe_start(cd);\n\tif (rc < 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: failed to launch device!\\n\", __func__);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int genwqe_health_check_cond(struct genwqe_dev *cd, u64 *gfir)\n{\n\t*gfir = __genwqe_readq(cd, IO_SLC_CFGREG_GFIR);\n\treturn (*gfir & GFIR_ERR_TRIGGER) &&\n\t\tgenwqe_recovery_on_fatal_gfir_required(cd);\n}\n\n \nstatic u64 genwqe_fir_checking(struct genwqe_dev *cd)\n{\n\tint j, iterations = 0;\n\tu64 mask, fir, fec, uid, gfir, gfir_masked, sfir, sfec;\n\tu32 fir_addr, fir_clr_addr, fec_addr, sfir_addr, sfec_addr;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n healthMonitor:\n\titerations++;\n\tif (iterations > 16) {\n\t\tdev_err(&pci_dev->dev, \"* exit looping after %d times\\n\",\n\t\t\titerations);\n\t\tgoto fatal_error;\n\t}\n\n\tgfir = __genwqe_readq(cd, IO_SLC_CFGREG_GFIR);\n\tif (gfir != 0x0)\n\t\tdev_err(&pci_dev->dev, \"* 0x%08x 0x%016llx\\n\",\n\t\t\t\t    IO_SLC_CFGREG_GFIR, gfir);\n\tif (gfir == IO_ILLEGAL_VALUE)\n\t\tgoto fatal_error;\n\n\t \n\tif (gfir == 0)\n\t\treturn 0;\n\n\tgfir_masked = gfir & GFIR_ERR_TRIGGER;   \n\n\tfor (uid = 0; uid < GENWQE_MAX_UNITS; uid++) {  \n\n\t\t \n\t\tfir_addr = (uid << 24) + 0x08;\n\t\tfir = __genwqe_readq(cd, fir_addr);\n\t\tif (fir == 0x0)\n\t\t\tcontinue;   \n\n\t\tdev_err(&pci_dev->dev, \"* 0x%08x 0x%016llx\\n\", fir_addr, fir);\n\t\tif (fir == IO_ILLEGAL_VALUE)\n\t\t\tgoto fatal_error;\n\n\t\t \n\t\tfec_addr = (uid << 24) + 0x18;\n\t\tfec = __genwqe_readq(cd, fec_addr);\n\n\t\tdev_err(&pci_dev->dev, \"* 0x%08x 0x%016llx\\n\", fec_addr, fec);\n\t\tif (fec == IO_ILLEGAL_VALUE)\n\t\t\tgoto fatal_error;\n\n\t\tfor (j = 0, mask = 1ULL; j < 64; j++, mask <<= 1) {\n\n\t\t\t \n\t\t\tif ((fir & mask) == 0x0)\n\t\t\t\tcontinue;\n\n\t\t\tsfir_addr = (uid << 24) + 0x100 + 0x08 * j;\n\t\t\tsfir = __genwqe_readq(cd, sfir_addr);\n\n\t\t\tif (sfir == IO_ILLEGAL_VALUE)\n\t\t\t\tgoto fatal_error;\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"* 0x%08x 0x%016llx\\n\", sfir_addr, sfir);\n\n\t\t\tsfec_addr = (uid << 24) + 0x300 + 0x08 * j;\n\t\t\tsfec = __genwqe_readq(cd, sfec_addr);\n\n\t\t\tif (sfec == IO_ILLEGAL_VALUE)\n\t\t\t\tgoto fatal_error;\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"* 0x%08x 0x%016llx\\n\", sfec_addr, sfec);\n\n\t\t\tgfir = __genwqe_readq(cd, IO_SLC_CFGREG_GFIR);\n\t\t\tif (gfir == IO_ILLEGAL_VALUE)\n\t\t\t\tgoto fatal_error;\n\n\t\t\t \n\t\t\tif ((gfir_masked == 0x0) &&\n\t\t\t    (gfir & GFIR_ERR_TRIGGER)) {\n\t\t\t\tgoto healthMonitor;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (gfir_masked == 0x0) {\n\n\t\t\t\t \n\t\t\t\tsfir_addr = (uid << 24) + 0x100 + 0x08 * j;\n\t\t\t\t__genwqe_writeq(cd, sfir_addr, sfir);\n\n\t\t\t\tdev_dbg(&pci_dev->dev,\n\t\t\t\t\t\"[HM] Clearing  2ndary FIR 0x%08x with 0x%016llx\\n\",\n\t\t\t\t\tsfir_addr, sfir);\n\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tfir_clr_addr = (uid << 24) + 0x10;\n\t\t\t\t__genwqe_writeq(cd, fir_clr_addr, mask);\n\n\t\t\t\tdev_dbg(&pci_dev->dev,\n\t\t\t\t\t\"[HM] Clearing primary FIR 0x%08x with 0x%016llx\\n\",\n\t\t\t\t\tfir_clr_addr, mask);\n\t\t\t}\n\t\t}\n\t}\n\tgfir = __genwqe_readq(cd, IO_SLC_CFGREG_GFIR);\n\tif (gfir == IO_ILLEGAL_VALUE)\n\t\tgoto fatal_error;\n\n\tif ((gfir_masked == 0x0) && (gfir & GFIR_ERR_TRIGGER)) {\n\t\t \n\t\tdev_dbg(&pci_dev->dev, \"ACK! Another FIR! Recursing %d!\\n\",\n\t\t\titerations);\n\t\tgoto healthMonitor;\n\t}\n\treturn gfir_masked;\n\n fatal_error:\n\treturn IO_ILLEGAL_VALUE;\n}\n\n \nstatic int genwqe_pci_fundamental_reset(struct pci_dev *pci_dev)\n{\n\tint rc;\n\n\t \n\tpci_cfg_access_lock(pci_dev);\n\tpci_save_state(pci_dev);\n\trc = pci_set_pcie_reset_state(pci_dev, pcie_warm_reset);\n\tif (!rc) {\n\t\t \n\t\tmsleep(250);\n\t\tpci_set_pcie_reset_state(pci_dev, pcie_deassert_reset);\n\t\t \n\t\tmsleep(2000);\n\t}\n\tpci_restore_state(pci_dev);\n\tpci_cfg_access_unlock(pci_dev);\n\treturn rc;\n}\n\n\nstatic int genwqe_platform_recovery(struct genwqe_dev *cd)\n{\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tint rc;\n\n\tdev_info(&pci_dev->dev,\n\t\t \"[%s] resetting card for error recovery\\n\", __func__);\n\n\t \n\tcd->err_inject &= ~(GENWQE_INJECT_HARDWARE_FAILURE |\n\t\t\t    GENWQE_INJECT_GFIR_FATAL |\n\t\t\t    GENWQE_INJECT_GFIR_INFO);\n\n\tgenwqe_stop(cd);\n\n\t \n\trc = genwqe_pci_fundamental_reset(pci_dev);\n\tif (!rc) {\n\t\trc = genwqe_start(cd);\n\t\tif (!rc)\n\t\t\tdev_info(&pci_dev->dev,\n\t\t\t\t \"[%s] card recovered\\n\", __func__);\n\t\telse\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"[%s] err: cannot start card services! (err=%d)\\n\",\n\t\t\t\t__func__, rc);\n\t} else {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] card reset failed\\n\", __func__);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int genwqe_reload_bistream(struct genwqe_dev *cd)\n{\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tint rc;\n\n\tdev_info(&pci_dev->dev,\n\t\t \"[%s] resetting card for bitstream reload\\n\",\n\t\t __func__);\n\n\tgenwqe_stop(cd);\n\n\t \n\t__genwqe_writeq(cd, IO_SLC_CFGREG_SOFTRESET,\n\t\t\t(cd->softreset & 0xcull) | 0x70ull);\n\n\trc = genwqe_pci_fundamental_reset(pci_dev);\n\tif (rc) {\n\t\t \n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: failed to reset card for bitstream reload\\n\",\n\t\t\t__func__);\n\t}\n\n\trc = genwqe_start(cd);\n\tif (rc) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: cannot start card services! (err=%d)\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\tdev_info(&pci_dev->dev,\n\t\t \"[%s] card reloaded\\n\", __func__);\n\treturn 0;\n}\n\n\n \nstatic int genwqe_health_thread(void *data)\n{\n\tint rc, should_stop = 0;\n\tstruct genwqe_dev *cd = data;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tu64 gfir, gfir_masked, slu_unitcfg, app_unitcfg;\n\n health_thread_begin:\n\twhile (!kthread_should_stop()) {\n\t\trc = wait_event_interruptible_timeout(cd->health_waitq,\n\t\t\t (genwqe_health_check_cond(cd, &gfir) ||\n\t\t\t  (should_stop = kthread_should_stop())),\n\t\t\t\tGENWQE_HEALTH_CHECK_INTERVAL * HZ);\n\n\t\tif (should_stop)\n\t\t\tbreak;\n\n\t\tif (gfir == IO_ILLEGAL_VALUE) {\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"[%s] GFIR=%016llx\\n\", __func__, gfir);\n\t\t\tgoto fatal_error;\n\t\t}\n\n\t\tslu_unitcfg = __genwqe_readq(cd, IO_SLU_UNITCFG);\n\t\tif (slu_unitcfg == IO_ILLEGAL_VALUE) {\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"[%s] SLU_UNITCFG=%016llx\\n\",\n\t\t\t\t__func__, slu_unitcfg);\n\t\t\tgoto fatal_error;\n\t\t}\n\n\t\tapp_unitcfg = __genwqe_readq(cd, IO_APP_UNITCFG);\n\t\tif (app_unitcfg == IO_ILLEGAL_VALUE) {\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"[%s] APP_UNITCFG=%016llx\\n\",\n\t\t\t\t__func__, app_unitcfg);\n\t\t\tgoto fatal_error;\n\t\t}\n\n\t\tgfir = __genwqe_readq(cd, IO_SLC_CFGREG_GFIR);\n\t\tif (gfir == IO_ILLEGAL_VALUE) {\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"[%s] %s: GFIR=%016llx\\n\", __func__,\n\t\t\t\t(gfir & GFIR_ERR_TRIGGER) ? \"err\" : \"info\",\n\t\t\t\tgfir);\n\t\t\tgoto fatal_error;\n\t\t}\n\n\t\tgfir_masked = genwqe_fir_checking(cd);\n\t\tif (gfir_masked == IO_ILLEGAL_VALUE)\n\t\t\tgoto fatal_error;\n\n\t\t \n\t\tif ((gfir_masked) && !cd->skip_recovery &&\n\t\t    genwqe_recovery_on_fatal_gfir_required(cd)) {\n\n\t\t\tcd->card_state = GENWQE_CARD_FATAL_ERROR;\n\n\t\t\trc = genwqe_recover_card(cd, 0);\n\t\t\tif (rc < 0) {\n\t\t\t\t \n\t\t\t\tgoto fatal_error;\n\t\t\t}\n\t\t}\n\n\t\tif (cd->card_state == GENWQE_CARD_RELOAD_BITSTREAM) {\n\t\t\t \n\t\t\trc = genwqe_reload_bistream(cd);\n\t\t\tif (rc)\n\t\t\t\tgoto fatal_error;\n\t\t}\n\n\t\tcd->last_gfir = gfir;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n\n fatal_error:\n\tif (cd->use_platform_recovery) {\n\t\t \n\t\treadq(cd->mmio + IO_SLC_CFGREG_GFIR);\n\n\t\t \n\t\tif (pci_channel_offline(pci_dev))\n\t\t\treturn -EIO;\n\n\t\t \n\t\trc = genwqe_platform_recovery(cd);\n\t\tif (!rc)\n\t\t\tgoto health_thread_begin;\n\t}\n\n\tdev_err(&pci_dev->dev,\n\t\t\"[%s] card unusable. Please trigger unbind!\\n\", __func__);\n\n\t \n\tcd->card_state = GENWQE_CARD_FATAL_ERROR;\n\tgenwqe_stop(cd);\n\n\t \n\twhile (!kthread_should_stop())\n\t\tcond_resched();\n\n\treturn -EIO;\n}\n\nstatic int genwqe_health_check_start(struct genwqe_dev *cd)\n{\n\tint rc;\n\n\tif (GENWQE_HEALTH_CHECK_INTERVAL <= 0)\n\t\treturn 0;\t \n\n\t \n\t \n\n\tcd->health_thread = kthread_run(genwqe_health_thread, cd,\n\t\t\t\t\tGENWQE_DEVNAME \"%d_health\",\n\t\t\t\t\tcd->card_idx);\n\tif (IS_ERR(cd->health_thread)) {\n\t\trc = PTR_ERR(cd->health_thread);\n\t\tcd->health_thread = NULL;\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int genwqe_health_thread_running(struct genwqe_dev *cd)\n{\n\treturn cd->health_thread != NULL;\n}\n\nstatic int genwqe_health_check_stop(struct genwqe_dev *cd)\n{\n\tif (!genwqe_health_thread_running(cd))\n\t\treturn -EIO;\n\n\tkthread_stop(cd->health_thread);\n\tcd->health_thread = NULL;\n\treturn 0;\n}\n\n \nstatic int genwqe_pci_setup(struct genwqe_dev *cd)\n{\n\tint err;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\terr = pci_enable_device_mem(pci_dev);\n\tif (err) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"err: failed to enable pci memory (err=%d)\\n\", err);\n\t\tgoto err_out;\n\t}\n\n\t \n\terr = pci_request_mem_regions(pci_dev, genwqe_driver_name);\n\tif (err) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: request bars failed (%d)\\n\", __func__, err);\n\t\terr = -EIO;\n\t\tgoto err_disable_device;\n\t}\n\n\t \n\t \n\tif (dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(64)) &&\n\t    dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32))) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"err: neither DMA32 nor DMA64 supported\\n\");\n\t\terr = -EIO;\n\t\tgoto out_release_resources;\n\t}\n\n\tpci_set_master(pci_dev);\n\n\t \n\tpci_dev->needs_freset = 1;\n\n\t \n\tcd->mmio_len = pci_resource_len(pci_dev, 0);\n\tcd->mmio = pci_iomap(pci_dev, 0, 0);\n\tif (cd->mmio == NULL) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: mapping BAR0 failed\\n\", __func__);\n\t\terr = -ENOMEM;\n\t\tgoto out_release_resources;\n\t}\n\n\tcd->num_vfs = pci_sriov_get_totalvfs(pci_dev);\n\tif (cd->num_vfs < 0)\n\t\tcd->num_vfs = 0;\n\n\terr = genwqe_read_ids(cd);\n\tif (err)\n\t\tgoto out_iounmap;\n\n\treturn 0;\n\n out_iounmap:\n\tpci_iounmap(pci_dev, cd->mmio);\n out_release_resources:\n\tpci_release_mem_regions(pci_dev);\n err_disable_device:\n\tpci_disable_device(pci_dev);\n err_out:\n\treturn err;\n}\n\n \nstatic void genwqe_pci_remove(struct genwqe_dev *cd)\n{\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tif (cd->mmio)\n\t\tpci_iounmap(pci_dev, cd->mmio);\n\n\tpci_release_mem_regions(pci_dev);\n\tpci_disable_device(pci_dev);\n}\n\n \nstatic int genwqe_probe(struct pci_dev *pci_dev,\n\t\t\tconst struct pci_device_id *id)\n{\n\tint err;\n\tstruct genwqe_dev *cd;\n\n\tgenwqe_init_crc32();\n\n\tcd = genwqe_dev_alloc();\n\tif (IS_ERR(cd)) {\n\t\tdev_err(&pci_dev->dev, \"err: could not alloc mem (err=%d)!\\n\",\n\t\t\t(int)PTR_ERR(cd));\n\t\treturn PTR_ERR(cd);\n\t}\n\n\tdev_set_drvdata(&pci_dev->dev, cd);\n\tcd->pci_dev = pci_dev;\n\n\terr = genwqe_pci_setup(cd);\n\tif (err < 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"err: problems with PCI setup (err=%d)\\n\", err);\n\t\tgoto out_free_dev;\n\t}\n\n\terr = genwqe_start(cd);\n\tif (err < 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"err: cannot start card services! (err=%d)\\n\", err);\n\t\tgoto out_pci_remove;\n\t}\n\n\tif (genwqe_is_privileged(cd)) {\n\t\terr = genwqe_health_check_start(cd);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"err: cannot start health checking! (err=%d)\\n\",\n\t\t\t\terr);\n\t\t\tgoto out_stop_services;\n\t\t}\n\t}\n\treturn 0;\n\n out_stop_services:\n\tgenwqe_stop(cd);\n out_pci_remove:\n\tgenwqe_pci_remove(cd);\n out_free_dev:\n\tgenwqe_dev_free(cd);\n\treturn err;\n}\n\n \nstatic void genwqe_remove(struct pci_dev *pci_dev)\n{\n\tstruct genwqe_dev *cd = dev_get_drvdata(&pci_dev->dev);\n\n\tgenwqe_health_check_stop(cd);\n\n\t \n\tgenwqe_stop(cd);\n\tgenwqe_pci_remove(cd);\n\tgenwqe_dev_free(cd);\n}\n\n \nstatic pci_ers_result_t genwqe_err_error_detected(struct pci_dev *pci_dev,\n\t\t\t\t\t\t pci_channel_state_t state)\n{\n\tstruct genwqe_dev *cd;\n\n\tdev_err(&pci_dev->dev, \"[%s] state=%d\\n\", __func__, state);\n\n\tcd = dev_get_drvdata(&pci_dev->dev);\n\tif (cd == NULL)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\t \n\tgenwqe_health_check_stop(cd);\n\tgenwqe_stop(cd);\n\n\t \n\tif (state == pci_channel_io_perm_failure) {\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t} else {\n\t\tgenwqe_pci_remove(cd);\n\t\treturn PCI_ERS_RESULT_NEED_RESET;\n\t}\n}\n\nstatic pci_ers_result_t genwqe_err_slot_reset(struct pci_dev *pci_dev)\n{\n\tint rc;\n\tstruct genwqe_dev *cd = dev_get_drvdata(&pci_dev->dev);\n\n\trc = genwqe_pci_setup(cd);\n\tif (!rc) {\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\t} else {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"err: problems with PCI setup (err=%d)\\n\", rc);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n}\n\nstatic pci_ers_result_t genwqe_err_result_none(struct pci_dev *dev)\n{\n\treturn PCI_ERS_RESULT_NONE;\n}\n\nstatic void genwqe_err_resume(struct pci_dev *pci_dev)\n{\n\tint rc;\n\tstruct genwqe_dev *cd = dev_get_drvdata(&pci_dev->dev);\n\n\trc = genwqe_start(cd);\n\tif (!rc) {\n\t\trc = genwqe_health_check_start(cd);\n\t\tif (rc)\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"err: cannot start health checking! (err=%d)\\n\",\n\t\t\t\trc);\n\t} else {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"err: cannot start card services! (err=%d)\\n\", rc);\n\t}\n}\n\nstatic int genwqe_sriov_configure(struct pci_dev *dev, int numvfs)\n{\n\tint rc;\n\tstruct genwqe_dev *cd = dev_get_drvdata(&dev->dev);\n\n\tif (numvfs > 0) {\n\t\tgenwqe_setup_vf_jtimer(cd);\n\t\trc = pci_enable_sriov(dev, numvfs);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn numvfs;\n\t}\n\tif (numvfs == 0) {\n\t\tpci_disable_sriov(dev);\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic const struct pci_error_handlers genwqe_err_handler = {\n\t.error_detected = genwqe_err_error_detected,\n\t.mmio_enabled\t= genwqe_err_result_none,\n\t.slot_reset\t= genwqe_err_slot_reset,\n\t.resume\t\t= genwqe_err_resume,\n};\n\nstatic struct pci_driver genwqe_driver = {\n\t.name\t  = genwqe_driver_name,\n\t.id_table = genwqe_device_table,\n\t.probe\t  = genwqe_probe,\n\t.remove\t  = genwqe_remove,\n\t.sriov_configure = genwqe_sriov_configure,\n\t.err_handler = &genwqe_err_handler,\n};\n\n \nstatic int __init genwqe_init_module(void)\n{\n\tint rc;\n\n\trc = class_register(&class_genwqe);\n\tif (rc) {\n\t\tpr_err(\"[%s] create class failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdebugfs_genwqe = debugfs_create_dir(GENWQE_DEVNAME, NULL);\n\n\trc = pci_register_driver(&genwqe_driver);\n\tif (rc != 0) {\n\t\tpr_err(\"[%s] pci_reg_driver (rc=%d)\\n\", __func__, rc);\n\t\tgoto err_out0;\n\t}\n\n\treturn rc;\n\n err_out0:\n\tdebugfs_remove(debugfs_genwqe);\n\tclass_unregister(&class_genwqe);\n\treturn rc;\n}\n\n \nstatic void __exit genwqe_exit_module(void)\n{\n\tpci_unregister_driver(&genwqe_driver);\n\tdebugfs_remove(debugfs_genwqe);\n\tclass_unregister(&class_genwqe);\n}\n\nmodule_init(genwqe_init_module);\nmodule_exit(genwqe_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}