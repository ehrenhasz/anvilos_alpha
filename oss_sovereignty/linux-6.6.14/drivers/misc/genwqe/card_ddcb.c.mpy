{
  "module_name": "card_ddcb.c",
  "hash_id": "3a4ba1f83ea1a97e4eddc2bacd01e37351eed8abb42b8519910db313aa35bd4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/genwqe/card_ddcb.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/pci.h>\n#include <linux/string.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/crc-itu-t.h>\n\n#include \"card_base.h\"\n#include \"card_ddcb.h\"\n\n \n\nstatic int queue_empty(struct ddcb_queue *queue)\n{\n\treturn queue->ddcb_next == queue->ddcb_act;\n}\n\nstatic int queue_enqueued_ddcbs(struct ddcb_queue *queue)\n{\n\tif (queue->ddcb_next >= queue->ddcb_act)\n\t\treturn queue->ddcb_next - queue->ddcb_act;\n\n\treturn queue->ddcb_max - (queue->ddcb_act - queue->ddcb_next);\n}\n\nstatic int queue_free_ddcbs(struct ddcb_queue *queue)\n{\n\tint free_ddcbs = queue->ddcb_max - queue_enqueued_ddcbs(queue) - 1;\n\n\tif (WARN_ON_ONCE(free_ddcbs < 0)) {  \n\t\treturn 0;\n\t}\n\treturn free_ddcbs;\n}\n\n \n\nstatic inline void ddcb_mark_tapped(struct ddcb *pddcb)\n{\n\tpddcb->priv[7] = 0xbb;   \n}\n\nstatic inline void ddcb_mark_appended(struct ddcb *pddcb)\n{\n\tpddcb->priv[7] = 0xaa;\t \n}\n\nstatic inline void ddcb_mark_cleared(struct ddcb *pddcb)\n{\n\tpddcb->priv[6] = 0xcc;  \n}\n\nstatic inline void ddcb_mark_finished(struct ddcb *pddcb)\n{\n\tpddcb->priv[6] = 0xff;\t \n}\n\nstatic inline void ddcb_mark_unused(struct ddcb *pddcb)\n{\n\tpddcb->priv_64 = cpu_to_be64(0);  \n}\n\n \nstatic inline u16 genwqe_crc16(const u8 *buff, size_t len, u16 init)\n{\n\treturn crc_itu_t(init, buff, len);\n}\n\nstatic void print_ddcb_info(struct genwqe_dev *cd, struct ddcb_queue *queue)\n{\n\tint i;\n\tstruct ddcb *pddcb;\n\tunsigned long flags;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tspin_lock_irqsave(&cd->print_lock, flags);\n\n\tdev_info(&pci_dev->dev,\n\t\t \"DDCB list for card #%d (ddcb_act=%d / ddcb_next=%d):\\n\",\n\t\t cd->card_idx, queue->ddcb_act, queue->ddcb_next);\n\n\tpddcb = queue->ddcb_vaddr;\n\tfor (i = 0; i < queue->ddcb_max; i++) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"  %c %-3d: RETC=%03x SEQ=%04x HSI=%02X SHI=%02x PRIV=%06llx CMD=%03x\\n\",\n\t\t\ti == queue->ddcb_act ? '>' : ' ',\n\t\t\ti,\n\t\t\tbe16_to_cpu(pddcb->retc_16),\n\t\t\tbe16_to_cpu(pddcb->seqnum_16),\n\t\t\tpddcb->hsi,\n\t\t\tpddcb->shi,\n\t\t\tbe64_to_cpu(pddcb->priv_64),\n\t\t\tpddcb->cmd);\n\t\tpddcb++;\n\t}\n\tspin_unlock_irqrestore(&cd->print_lock, flags);\n}\n\nstruct genwqe_ddcb_cmd *ddcb_requ_alloc(void)\n{\n\tstruct ddcb_requ *req;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn NULL;\n\n\treturn &req->cmd;\n}\n\nvoid ddcb_requ_free(struct genwqe_ddcb_cmd *cmd)\n{\n\tstruct ddcb_requ *req = container_of(cmd, struct ddcb_requ, cmd);\n\n\tkfree(req);\n}\n\nstatic inline enum genwqe_requ_state ddcb_requ_get_state(struct ddcb_requ *req)\n{\n\treturn req->req_state;\n}\n\nstatic inline void ddcb_requ_set_state(struct ddcb_requ *req,\n\t\t\t\t       enum genwqe_requ_state new_state)\n{\n\treq->req_state = new_state;\n}\n\nstatic inline int ddcb_requ_collect_debug_data(struct ddcb_requ *req)\n{\n\treturn req->cmd.ddata_addr != 0x0;\n}\n\n \nstatic int ddcb_requ_finished(struct genwqe_dev *cd, struct ddcb_requ *req)\n{\n\treturn (ddcb_requ_get_state(req) == GENWQE_REQU_FINISHED) ||\n\t\t(cd->card_state != GENWQE_CARD_USED);\n}\n\n#define RET_DDCB_APPENDED 1\n#define RET_DDCB_TAPPED   2\n \nstatic int enqueue_ddcb(struct genwqe_dev *cd, struct ddcb_queue *queue,\n\t\t\tstruct ddcb *pddcb, int ddcb_no)\n{\n\tunsigned int try;\n\tint prev_no;\n\tstruct ddcb *prev_ddcb;\n\t__be32 old, new, icrc_hsi_shi;\n\tu64 num;\n\n\t \n\tddcb_mark_unused(pddcb);\n\n\t \n\tprev_no = (ddcb_no == 0) ? queue->ddcb_max - 1 : ddcb_no - 1;\n\tprev_ddcb = &queue->ddcb_vaddr[prev_no];\n\n\t \n\tddcb_mark_appended(pddcb);\n\tfor (try = 0; try < 2; try++) {\n\t\told = prev_ddcb->icrc_hsi_shi_32;  \n\n\t\t \n\t\tif ((old & DDCB_COMPLETED_BE32) != 0x00000000)\n\t\t\tbreak;\n\n\t\tnew = (old | DDCB_NEXT_BE32);\n\n\t\twmb();\t\t \n\t\ticrc_hsi_shi = cmpxchg(&prev_ddcb->icrc_hsi_shi_32, old, new);\n\n\t\tif (icrc_hsi_shi == old)\n\t\t\treturn RET_DDCB_APPENDED;  \n\t}\n\n\t \n\tddcb_mark_tapped(pddcb);\n\tnum = (u64)ddcb_no << 8;\n\n\twmb();\t\t\t \n\t__genwqe_writeq(cd, queue->IO_QUEUE_OFFSET, num);  \n\n\treturn RET_DDCB_TAPPED;\n}\n\n \nstatic void copy_ddcb_results(struct ddcb_requ *req, int ddcb_no)\n{\n\tstruct ddcb_queue *queue = req->queue;\n\tstruct ddcb *pddcb = &queue->ddcb_vaddr[req->num];\n\n\tmemcpy(&req->cmd.asv[0], &pddcb->asv[0], DDCB_ASV_LENGTH);\n\n\t \n\treq->cmd.vcrc     = be16_to_cpu(pddcb->vcrc_16);\n\treq->cmd.deque_ts = be64_to_cpu(pddcb->deque_ts_64);\n\treq->cmd.cmplt_ts = be64_to_cpu(pddcb->cmplt_ts_64);\n\n\treq->cmd.attn     = be16_to_cpu(pddcb->attn_16);\n\treq->cmd.progress = be32_to_cpu(pddcb->progress_32);\n\treq->cmd.retc     = be16_to_cpu(pddcb->retc_16);\n\n\tif (ddcb_requ_collect_debug_data(req)) {\n\t\tint prev_no = (ddcb_no == 0) ?\n\t\t\tqueue->ddcb_max - 1 : ddcb_no - 1;\n\t\tstruct ddcb *prev_pddcb = &queue->ddcb_vaddr[prev_no];\n\n\t\tmemcpy(&req->debug_data.ddcb_finished, pddcb,\n\t\t       sizeof(req->debug_data.ddcb_finished));\n\t\tmemcpy(&req->debug_data.ddcb_prev, prev_pddcb,\n\t\t       sizeof(req->debug_data.ddcb_prev));\n\t}\n}\n\n \nstatic int genwqe_check_ddcb_queue(struct genwqe_dev *cd,\n\t\t\t\t   struct ddcb_queue *queue)\n{\n\tunsigned long flags;\n\tint ddcbs_finished = 0;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tspin_lock_irqsave(&queue->ddcb_lock, flags);\n\n\t \n\twhile (!queue_empty(queue) && (ddcbs_finished < queue->ddcb_max)) {\n\n\t\tstruct ddcb *pddcb;\n\t\tstruct ddcb_requ *req;\n\t\tu16 vcrc, vcrc_16, retc_16;\n\n\t\tpddcb = &queue->ddcb_vaddr[queue->ddcb_act];\n\n\t\tif ((pddcb->icrc_hsi_shi_32 & DDCB_COMPLETED_BE32) ==\n\t\t    0x00000000)\n\t\t\tgoto go_home;  \n\n\t\twmb();   \n\n\t\t \n\t\treq = queue->ddcb_req[queue->ddcb_act];\n\t\tif (req == NULL) {\n\t\t\t \n\t\t\t \n\t\t\tgoto pick_next_one;\n\t\t}\n\n\t\t \n\t\tretc_16 = be16_to_cpu(pddcb->retc_16);\n\t\tif ((pddcb->hsi == 0x44) && (retc_16 <= 0x101)) {\n\t\t\tu64 errcnts, status;\n\t\t\tu64 ddcb_offs = (u64)pddcb - (u64)queue->ddcb_vaddr;\n\n\t\t\terrcnts = __genwqe_readq(cd, queue->IO_QUEUE_ERRCNTS);\n\t\t\tstatus  = __genwqe_readq(cd, queue->IO_QUEUE_STATUS);\n\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"[%s] SEQN=%04x HSI=%02x RETC=%03x Q_ERRCNTS=%016llx Q_STATUS=%016llx DDCB_DMA_ADDR=%016llx\\n\",\n\t\t\t\t__func__, be16_to_cpu(pddcb->seqnum_16),\n\t\t\t\tpddcb->hsi, retc_16, errcnts, status,\n\t\t\t\tqueue->ddcb_daddr + ddcb_offs);\n\t\t}\n\n\t\tcopy_ddcb_results(req, queue->ddcb_act);\n\t\tqueue->ddcb_req[queue->ddcb_act] = NULL;  \n\n\t\tdev_dbg(&pci_dev->dev, \"FINISHED DDCB#%d\\n\", req->num);\n\t\tgenwqe_hexdump(pci_dev, pddcb, sizeof(*pddcb));\n\n\t\tddcb_mark_finished(pddcb);\n\n\t\t \n\t\tvcrc = genwqe_crc16(pddcb->asv,\n\t\t\t\t   VCRC_LENGTH(req->cmd.asv_length),\n\t\t\t\t   0xffff);\n\t\tvcrc_16 = be16_to_cpu(pddcb->vcrc_16);\n\t\tif (vcrc != vcrc_16) {\n\t\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\t\"%s %s: err: wrong VCRC pre=%02x vcrc_len=%d bytes vcrc_data=%04x is not vcrc_card=%04x\\n\",\n\t\t\t\tGENWQE_DEVNAME, dev_name(&pci_dev->dev),\n\t\t\t\tpddcb->pre, VCRC_LENGTH(req->cmd.asv_length),\n\t\t\t\tvcrc, vcrc_16);\n\t\t}\n\n\t\tddcb_requ_set_state(req, GENWQE_REQU_FINISHED);\n\t\tqueue->ddcbs_completed++;\n\t\tqueue->ddcbs_in_flight--;\n\n\t\t \n\t\twake_up_interruptible(&queue->ddcb_waitqs[queue->ddcb_act]);\n\t\twake_up_interruptible(&queue->busy_waitq);\n\npick_next_one:\n\t\tqueue->ddcb_act = (queue->ddcb_act + 1) % queue->ddcb_max;\n\t\tddcbs_finished++;\n\t}\n\n go_home:\n\tspin_unlock_irqrestore(&queue->ddcb_lock, flags);\n\treturn ddcbs_finished;\n}\n\n \nint __genwqe_wait_ddcb(struct genwqe_dev *cd, struct ddcb_requ *req)\n{\n\tint rc;\n\tunsigned int ddcb_no;\n\tstruct ddcb_queue *queue;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tif (req == NULL)\n\t\treturn -EINVAL;\n\n\tqueue = req->queue;\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\n\tddcb_no = req->num;\n\tif (ddcb_no >= queue->ddcb_max)\n\t\treturn -EINVAL;\n\n\trc = wait_event_interruptible_timeout(queue->ddcb_waitqs[ddcb_no],\n\t\t\t\tddcb_requ_finished(cd, req),\n\t\t\t\tGENWQE_DDCB_SOFTWARE_TIMEOUT * HZ);\n\n\t \n\tif (rc == 0) {\n\t\tstruct ddcb_queue *queue = req->queue;\n\t\tstruct ddcb *pddcb;\n\n\t\t \n\t\tgenwqe_check_ddcb_queue(cd, req->queue);\n\t\tif (ddcb_requ_finished(cd, req))\n\t\t\treturn rc;\n\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: DDCB#%d timeout rc=%d state=%d req @ %p\\n\",\n\t\t\t__func__, req->num, rc,\tddcb_requ_get_state(req),\n\t\t\treq);\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s]      IO_QUEUE_STATUS=0x%016llx\\n\", __func__,\n\t\t\t__genwqe_readq(cd, queue->IO_QUEUE_STATUS));\n\n\t\tpddcb = &queue->ddcb_vaddr[req->num];\n\t\tgenwqe_hexdump(pci_dev, pddcb, sizeof(*pddcb));\n\n\t\tprint_ddcb_info(cd, req->queue);\n\t\treturn -ETIMEDOUT;\n\n\t} else if (rc == -ERESTARTSYS) {\n\t\treturn rc;\n\t\t \n\n\t} else if (rc < 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: DDCB#%d unknown result (rc=%d) %d!\\n\",\n\t\t\t__func__, req->num, rc, ddcb_requ_get_state(req));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cd->card_state != GENWQE_CARD_USED) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: DDCB#%d forced to stop (rc=%d)\\n\",\n\t\t\t__func__, req->num, rc);\n\t\treturn -EIO;\n\t}\n\treturn rc;\n}\n\n \nstatic struct ddcb *get_next_ddcb(struct genwqe_dev *cd,\n\t\t\t\t  struct ddcb_queue *queue,\n\t\t\t\t  int *num)\n{\n\tu64 *pu64;\n\tstruct ddcb *pddcb;\n\n\tif (queue_free_ddcbs(queue) == 0)  \n\t\treturn NULL;\n\n\t \n\tpddcb = &queue->ddcb_vaddr[queue->ddcb_next];\n\n\t \n\t \n\tif ((pddcb->icrc_hsi_shi_32 & DDCB_COMPLETED_BE32) == 0x00000000)\n\t\treturn NULL;\n\n\t*num = queue->ddcb_next;\t \n\tqueue->ddcb_next = (queue->ddcb_next + 1) % queue->ddcb_max;\n\n\t \n\tpu64 = (u64 *)pddcb;\n\tpu64[0] = 0ULL;\t\t \n\tpu64[1] = 0ULL;\t\t \n\n\t \n\tpu64[0x80/8] = 0ULL;\t \n\tpu64[0x88/8] = 0ULL;\t \n\tpu64[0x90/8] = 0ULL;\t \n\tpu64[0x98/8] = 0ULL;\t \n\tpu64[0xd0/8] = 0ULL;\t \n\n\tpddcb->pre = DDCB_PRESET_PRE;  \n\tpddcb->seqnum_16 = cpu_to_be16(queue->ddcb_seq++);\n\treturn pddcb;\n}\n\n \nint __genwqe_purge_ddcb(struct genwqe_dev *cd, struct ddcb_requ *req)\n{\n\tstruct ddcb *pddcb = NULL;\n\tunsigned int t;\n\tunsigned long flags;\n\tstruct ddcb_queue *queue = req->queue;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tu64 queue_status;\n\t__be32 icrc_hsi_shi = 0x0000;\n\t__be32 old, new;\n\n\t \n\tif (GENWQE_DDCB_SOFTWARE_TIMEOUT <= 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: software timeout is not set!\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tpddcb = &queue->ddcb_vaddr[req->num];\n\n\tfor (t = 0; t < GENWQE_DDCB_SOFTWARE_TIMEOUT * 10; t++) {\n\n\t\tspin_lock_irqsave(&queue->ddcb_lock, flags);\n\n\t\t \n\t\tif (ddcb_requ_get_state(req) == GENWQE_REQU_FINISHED)\n\t\t\tgoto go_home;\n\n\t\t \n\t\told = pddcb->icrc_hsi_shi_32;\t \n\t\tif ((old & DDCB_FETCHED_BE32) == 0x00000000) {\n\n\t\t\tnew = (old | DDCB_PURGE_BE32);\n\t\t\ticrc_hsi_shi = cmpxchg(&pddcb->icrc_hsi_shi_32,\n\t\t\t\t\t       old, new);\n\t\t\tif (icrc_hsi_shi == old)\n\t\t\t\tgoto finish_ddcb;\n\t\t}\n\n\t\t \n\t\tbarrier();\n\t\ticrc_hsi_shi = pddcb->icrc_hsi_shi_32;\n\t\tif (icrc_hsi_shi & DDCB_COMPLETED_BE32)\n\t\t\tgoto finish_ddcb;\n\n\t\tspin_unlock_irqrestore(&queue->ddcb_lock, flags);\n\n\t\t \n\n\t\tcopy_ddcb_results(req, req->num);  \n\t\tmsleep(100);  \n\t\tcontinue;\n\nfinish_ddcb:\n\t\tcopy_ddcb_results(req, req->num);\n\t\tddcb_requ_set_state(req, GENWQE_REQU_FINISHED);\n\t\tqueue->ddcbs_in_flight--;\n\t\tqueue->ddcb_req[req->num] = NULL;  \n\t\tddcb_mark_cleared(pddcb);\n\n\t\t \n\n\t\t \n\t\ticrc_hsi_shi = pddcb->icrc_hsi_shi_32;\n\t\tif ((icrc_hsi_shi & DDCB_COMPLETED_BE32) &&\n\t\t    (queue->ddcb_act == req->num)) {\n\t\t\tqueue->ddcb_act = ((queue->ddcb_act + 1) %\n\t\t\t\t\t   queue->ddcb_max);\n\t\t}\ngo_home:\n\t\tspin_unlock_irqrestore(&queue->ddcb_lock, flags);\n\t\treturn 0;\n\t}\n\n\t \n\tqueue_status = __genwqe_readq(cd, queue->IO_QUEUE_STATUS);\n\n\tdev_dbg(&pci_dev->dev, \"UN/FINISHED DDCB#%d\\n\", req->num);\n\tgenwqe_hexdump(pci_dev, pddcb, sizeof(*pddcb));\n\n\tdev_err(&pci_dev->dev,\n\t\t\"[%s] err: DDCB#%d not purged and not completed after %d seconds QSTAT=%016llx!!\\n\",\n\t\t__func__, req->num, GENWQE_DDCB_SOFTWARE_TIMEOUT,\n\t\tqueue_status);\n\n\tprint_ddcb_info(cd, req->queue);\n\n\treturn -EFAULT;\n}\n\nint genwqe_init_debug_data(struct genwqe_dev *cd, struct genwqe_debug_data *d)\n{\n\tint len;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tif (d == NULL) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: invalid memory for debug data!\\n\",\n\t\t\t__func__);\n\t\treturn -EFAULT;\n\t}\n\n\tlen  = sizeof(d->driver_version);\n\tsnprintf(d->driver_version, len, \"%s\", DRV_VERSION);\n\td->slu_unitcfg = cd->slu_unitcfg;\n\td->app_unitcfg = cd->app_unitcfg;\n\treturn 0;\n}\n\n \nint __genwqe_enqueue_ddcb(struct genwqe_dev *cd, struct ddcb_requ *req,\n\t\t\t  unsigned int f_flags)\n{\n\tstruct ddcb *pddcb;\n\tunsigned long flags;\n\tstruct ddcb_queue *queue;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tu16 icrc;\n\n retry:\n\tif (cd->card_state != GENWQE_CARD_USED) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"%s %s: [%s] Card is unusable/PCIe problem Req#%d\\n\",\n\t\t\tGENWQE_DEVNAME, dev_name(&pci_dev->dev),\n\t\t\t__func__, req->num);\n\t\treturn -EIO;\n\t}\n\n\tqueue = req->queue = &cd->queue;\n\n\t \n\tif (GENWQE_POLLING_ENABLED)\n\t\tgenwqe_check_ddcb_queue(cd, queue);\n\n\t \n\tspin_lock_irqsave(&queue->ddcb_lock, flags);\n\n\tpddcb = get_next_ddcb(cd, queue, &req->num);\t \n\tif (pddcb == NULL) {\n\t\tint rc;\n\n\t\tspin_unlock_irqrestore(&queue->ddcb_lock, flags);\n\n\t\tif (f_flags & O_NONBLOCK) {\n\t\t\tqueue->return_on_busy++;\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tqueue->wait_on_busy++;\n\t\trc = wait_event_interruptible(queue->busy_waitq,\n\t\t\t\t\t      queue_free_ddcbs(queue) != 0);\n\t\tdev_dbg(&pci_dev->dev, \"[%s] waiting for free DDCB: rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tif (rc == -ERESTARTSYS)\n\t\t\treturn rc;   \n\n\t\tgoto retry;\n\t}\n\n\tif (queue->ddcb_req[req->num] != NULL) {\n\t\tspin_unlock_irqrestore(&queue->ddcb_lock, flags);\n\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] picked DDCB %d with req=%p still in use!!\\n\",\n\t\t\t__func__, req->num, req);\n\t\treturn -EFAULT;\n\t}\n\tddcb_requ_set_state(req, GENWQE_REQU_ENQUEUED);\n\tqueue->ddcb_req[req->num] = req;\n\n\tpddcb->cmdopts_16 = cpu_to_be16(req->cmd.cmdopts);\n\tpddcb->cmd = req->cmd.cmd;\n\tpddcb->acfunc = req->cmd.acfunc;\t \n\n\t \n\tif ((cd->slu_unitcfg & 0xFFFF0ull) > 0x34199ull)\n\t\tpddcb->xdir = 0x1;\n\telse\n\t\tpddcb->xdir = 0x0;\n\n\n\tpddcb->psp = (((req->cmd.asiv_length / 8) << 4) |\n\t\t      ((req->cmd.asv_length  / 8)));\n\tpddcb->disp_ts_64 = cpu_to_be64(req->cmd.disp_ts);\n\n\t \n\tif (genwqe_get_slu_id(cd) <= 0x2) {\n\t\tmemcpy(&pddcb->__asiv[0],\t \n\t\t       &req->cmd.__asiv[0],\t \n\t\t       DDCB_ASIV_LENGTH);\t \n\t} else {\n\t\tpddcb->n.ats_64 = cpu_to_be64(req->cmd.ats);\n\t\tmemcpy(&pddcb->n.asiv[0],\t \n\t\t\t&req->cmd.asiv[0],\t \n\t\t\tDDCB_ASIV_LENGTH_ATS);\t \n\t}\n\n\tpddcb->icrc_hsi_shi_32 = cpu_to_be32(0x00000000);  \n\n\t \n\ticrc = genwqe_crc16((const u8 *)pddcb,\n\t\t\t   ICRC_LENGTH(req->cmd.asiv_length), 0xffff);\n\tpddcb->icrc_hsi_shi_32 = cpu_to_be32((u32)icrc << 16);\n\n\t \n\tif (!GENWQE_POLLING_ENABLED)\n\t\tpddcb->icrc_hsi_shi_32 |= DDCB_INTR_BE32;\n\n\tdev_dbg(&pci_dev->dev, \"INPUT DDCB#%d\\n\", req->num);\n\tgenwqe_hexdump(pci_dev, pddcb, sizeof(*pddcb));\n\n\tif (ddcb_requ_collect_debug_data(req)) {\n\t\t \n\n\t\tgenwqe_init_debug_data(cd, &req->debug_data);\n\t\tmemcpy(&req->debug_data.ddcb_before, pddcb,\n\t\t       sizeof(req->debug_data.ddcb_before));\n\t}\n\n\tenqueue_ddcb(cd, queue, pddcb, req->num);\n\tqueue->ddcbs_in_flight++;\n\n\tif (queue->ddcbs_in_flight > queue->ddcbs_max_in_flight)\n\t\tqueue->ddcbs_max_in_flight = queue->ddcbs_in_flight;\n\n\tddcb_requ_set_state(req, GENWQE_REQU_TAPPED);\n\tspin_unlock_irqrestore(&queue->ddcb_lock, flags);\n\twake_up_interruptible(&cd->queue_waitq);\n\n\treturn 0;\n}\n\n \nint __genwqe_execute_raw_ddcb(struct genwqe_dev *cd,\n\t\t\t      struct genwqe_ddcb_cmd *cmd,\n\t\t\t      unsigned int f_flags)\n{\n\tint rc = 0;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tstruct ddcb_requ *req = container_of(cmd, struct ddcb_requ, cmd);\n\n\tif (cmd->asiv_length > DDCB_ASIV_LENGTH) {\n\t\tdev_err(&pci_dev->dev, \"[%s] err: wrong asiv_length of %d\\n\",\n\t\t\t__func__, cmd->asiv_length);\n\t\treturn -EINVAL;\n\t}\n\tif (cmd->asv_length > DDCB_ASV_LENGTH) {\n\t\tdev_err(&pci_dev->dev, \"[%s] err: wrong asv_length of %d\\n\",\n\t\t\t__func__, cmd->asiv_length);\n\t\treturn -EINVAL;\n\t}\n\trc = __genwqe_enqueue_ddcb(cd, req, f_flags);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = __genwqe_wait_ddcb(cd, req);\n\tif (rc < 0)\t\t \n\t\tgoto err_exit;\n\n\tif (ddcb_requ_collect_debug_data(req)) {\n\t\tif (copy_to_user((struct genwqe_debug_data __user *)\n\t\t\t\t (unsigned long)cmd->ddata_addr,\n\t\t\t\t &req->debug_data,\n\t\t\t\t sizeof(struct genwqe_debug_data)))\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (cmd->retc != DDCB_RETC_COMPLETE) {\n\t\t \n\t\trc = -EBADMSG;\t \n\t}\n\n\treturn rc;\n\n err_exit:\n\t__genwqe_purge_ddcb(cd, req);\n\n\tif (ddcb_requ_collect_debug_data(req)) {\n\t\tif (copy_to_user((struct genwqe_debug_data __user *)\n\t\t\t\t (unsigned long)cmd->ddata_addr,\n\t\t\t\t &req->debug_data,\n\t\t\t\t sizeof(struct genwqe_debug_data)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn rc;\n}\n\n \nstatic int genwqe_next_ddcb_ready(struct genwqe_dev *cd)\n{\n\tunsigned long flags;\n\tstruct ddcb *pddcb;\n\tstruct ddcb_queue *queue = &cd->queue;\n\n\tspin_lock_irqsave(&queue->ddcb_lock, flags);\n\n\tif (queue_empty(queue)) {  \n\t\tspin_unlock_irqrestore(&queue->ddcb_lock, flags);\n\t\treturn 0;\n\t}\n\n\tpddcb = &queue->ddcb_vaddr[queue->ddcb_act];\n\tif (pddcb->icrc_hsi_shi_32 & DDCB_COMPLETED_BE32) {  \n\t\tspin_unlock_irqrestore(&queue->ddcb_lock, flags);\n\t\treturn 1;\n\t}\n\n\tspin_unlock_irqrestore(&queue->ddcb_lock, flags);\n\treturn 0;\n}\n\n \nint genwqe_ddcbs_in_flight(struct genwqe_dev *cd)\n{\n\tunsigned long flags;\n\tint ddcbs_in_flight = 0;\n\tstruct ddcb_queue *queue = &cd->queue;\n\n\tspin_lock_irqsave(&queue->ddcb_lock, flags);\n\tddcbs_in_flight += queue->ddcbs_in_flight;\n\tspin_unlock_irqrestore(&queue->ddcb_lock, flags);\n\n\treturn ddcbs_in_flight;\n}\n\nstatic int setup_ddcb_queue(struct genwqe_dev *cd, struct ddcb_queue *queue)\n{\n\tint rc, i;\n\tstruct ddcb *pddcb;\n\tu64 val64;\n\tunsigned int queue_size;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tif (GENWQE_DDCB_MAX < 2)\n\t\treturn -EINVAL;\n\n\tqueue_size = roundup(GENWQE_DDCB_MAX * sizeof(struct ddcb), PAGE_SIZE);\n\n\tqueue->ddcbs_in_flight = 0;   \n\tqueue->ddcbs_max_in_flight = 0;\n\tqueue->ddcbs_completed = 0;\n\tqueue->return_on_busy = 0;\n\tqueue->wait_on_busy = 0;\n\n\tqueue->ddcb_seq\t  = 0x100;  \n\tqueue->ddcb_max\t  = GENWQE_DDCB_MAX;\n\tqueue->ddcb_vaddr = __genwqe_alloc_consistent(cd, queue_size,\n\t\t\t\t\t\t&queue->ddcb_daddr);\n\tif (queue->ddcb_vaddr == NULL) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] **err: could not allocate DDCB **\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tqueue->ddcb_req = kcalloc(queue->ddcb_max, sizeof(struct ddcb_requ *),\n\t\t\t\t  GFP_KERNEL);\n\tif (!queue->ddcb_req) {\n\t\trc = -ENOMEM;\n\t\tgoto free_ddcbs;\n\t}\n\n\tqueue->ddcb_waitqs = kcalloc(queue->ddcb_max,\n\t\t\t\t     sizeof(wait_queue_head_t),\n\t\t\t\t     GFP_KERNEL);\n\tif (!queue->ddcb_waitqs) {\n\t\trc = -ENOMEM;\n\t\tgoto free_requs;\n\t}\n\n\tfor (i = 0; i < queue->ddcb_max; i++) {\n\t\tpddcb = &queue->ddcb_vaddr[i];\t\t      \n\t\tpddcb->icrc_hsi_shi_32 = DDCB_COMPLETED_BE32;\n\t\tpddcb->retc_16 = cpu_to_be16(0xfff);\n\n\t\tqueue->ddcb_req[i] = NULL;\t\t      \n\t\tinit_waitqueue_head(&queue->ddcb_waitqs[i]);  \n\t}\n\n\tqueue->ddcb_act  = 0;\n\tqueue->ddcb_next = 0;\t \n\n\tspin_lock_init(&queue->ddcb_lock);\n\tinit_waitqueue_head(&queue->busy_waitq);\n\n\tval64 = ((u64)(queue->ddcb_max - 1) <<  8);  \n\t__genwqe_writeq(cd, queue->IO_QUEUE_CONFIG,  0x07);   \n\t__genwqe_writeq(cd, queue->IO_QUEUE_SEGMENT, queue->ddcb_daddr);\n\t__genwqe_writeq(cd, queue->IO_QUEUE_INITSQN, queue->ddcb_seq);\n\t__genwqe_writeq(cd, queue->IO_QUEUE_WRAP,    val64);\n\treturn 0;\n\n free_requs:\n\tkfree(queue->ddcb_req);\n\tqueue->ddcb_req = NULL;\n free_ddcbs:\n\t__genwqe_free_consistent(cd, queue_size, queue->ddcb_vaddr,\n\t\t\t\tqueue->ddcb_daddr);\n\tqueue->ddcb_vaddr = NULL;\n\tqueue->ddcb_daddr = 0ull;\n\treturn rc;\n\n}\n\nstatic int ddcb_queue_initialized(struct ddcb_queue *queue)\n{\n\treturn queue->ddcb_vaddr != NULL;\n}\n\nstatic void free_ddcb_queue(struct genwqe_dev *cd, struct ddcb_queue *queue)\n{\n\tunsigned int queue_size;\n\n\tqueue_size = roundup(queue->ddcb_max * sizeof(struct ddcb), PAGE_SIZE);\n\n\tkfree(queue->ddcb_req);\n\tqueue->ddcb_req = NULL;\n\n\tif (queue->ddcb_vaddr) {\n\t\t__genwqe_free_consistent(cd, queue_size, queue->ddcb_vaddr,\n\t\t\t\t\tqueue->ddcb_daddr);\n\t\tqueue->ddcb_vaddr = NULL;\n\t\tqueue->ddcb_daddr = 0ull;\n\t}\n}\n\nstatic irqreturn_t genwqe_pf_isr(int irq, void *dev_id)\n{\n\tu64 gfir;\n\tstruct genwqe_dev *cd = (struct genwqe_dev *)dev_id;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\t \n\tcd->irqs_processed++;\n\twake_up_interruptible(&cd->queue_waitq);\n\n\t \n\tgfir = __genwqe_readq(cd, IO_SLC_CFGREG_GFIR);\n\tif (((gfir & GFIR_ERR_TRIGGER) != 0x0) &&\n\t    !pci_channel_offline(pci_dev)) {\n\n\t\tif (cd->use_platform_recovery) {\n\t\t\t \n\t\t\treadq(cd->mmio + IO_SLC_CFGREG_GFIR);\n\n\t\t\t \n\t\t\tif (pci_channel_offline(pci_dev))\n\t\t\t\tgoto exit;\n\t\t}\n\n\t\twake_up_interruptible(&cd->health_waitq);\n\n\t\t \n\t\tdev_err_ratelimited(&pci_dev->dev,\n\t\t\t\t    \"[%s] GFIR=%016llx\\n\",\n\t\t\t\t    __func__, gfir);\n\t}\n\n exit:\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t genwqe_vf_isr(int irq, void *dev_id)\n{\n\tstruct genwqe_dev *cd = (struct genwqe_dev *)dev_id;\n\n\tcd->irqs_processed++;\n\twake_up_interruptible(&cd->queue_waitq);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int genwqe_card_thread(void *data)\n{\n\tint should_stop = 0;\n\tstruct genwqe_dev *cd = (struct genwqe_dev *)data;\n\n\twhile (!kthread_should_stop()) {\n\n\t\tgenwqe_check_ddcb_queue(cd, &cd->queue);\n\n\t\tif (GENWQE_POLLING_ENABLED) {\n\t\t\twait_event_interruptible_timeout(\n\t\t\t\tcd->queue_waitq,\n\t\t\t\tgenwqe_ddcbs_in_flight(cd) ||\n\t\t\t\t(should_stop = kthread_should_stop()), 1);\n\t\t} else {\n\t\t\twait_event_interruptible_timeout(\n\t\t\t\tcd->queue_waitq,\n\t\t\t\tgenwqe_next_ddcb_ready(cd) ||\n\t\t\t\t(should_stop = kthread_should_stop()), HZ);\n\t\t}\n\t\tif (should_stop)\n\t\t\tbreak;\n\n\t\t \n\t\tcond_resched();\n\t}\n\treturn 0;\n}\n\n \nint genwqe_setup_service_layer(struct genwqe_dev *cd)\n{\n\tint rc;\n\tstruct ddcb_queue *queue;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tif (genwqe_is_privileged(cd)) {\n\t\trc = genwqe_card_reset(cd);\n\t\tif (rc < 0) {\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"[%s] err: reset failed.\\n\", __func__);\n\t\t\treturn rc;\n\t\t}\n\t\tgenwqe_read_softreset(cd);\n\t}\n\n\tqueue = &cd->queue;\n\tqueue->IO_QUEUE_CONFIG  = IO_SLC_QUEUE_CONFIG;\n\tqueue->IO_QUEUE_STATUS  = IO_SLC_QUEUE_STATUS;\n\tqueue->IO_QUEUE_SEGMENT = IO_SLC_QUEUE_SEGMENT;\n\tqueue->IO_QUEUE_INITSQN = IO_SLC_QUEUE_INITSQN;\n\tqueue->IO_QUEUE_OFFSET  = IO_SLC_QUEUE_OFFSET;\n\tqueue->IO_QUEUE_WRAP    = IO_SLC_QUEUE_WRAP;\n\tqueue->IO_QUEUE_WTIME   = IO_SLC_QUEUE_WTIME;\n\tqueue->IO_QUEUE_ERRCNTS = IO_SLC_QUEUE_ERRCNTS;\n\tqueue->IO_QUEUE_LRW     = IO_SLC_QUEUE_LRW;\n\n\trc = setup_ddcb_queue(cd, queue);\n\tif (rc != 0) {\n\t\trc = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\tinit_waitqueue_head(&cd->queue_waitq);\n\tcd->card_thread = kthread_run(genwqe_card_thread, cd,\n\t\t\t\t      GENWQE_DEVNAME \"%d_thread\",\n\t\t\t\t      cd->card_idx);\n\tif (IS_ERR(cd->card_thread)) {\n\t\trc = PTR_ERR(cd->card_thread);\n\t\tcd->card_thread = NULL;\n\t\tgoto stop_free_queue;\n\t}\n\n\trc = genwqe_set_interrupt_capability(cd, GENWQE_MSI_IRQS);\n\tif (rc)\n\t\tgoto stop_kthread;\n\n\t \n\tinit_waitqueue_head(&cd->health_waitq);\n\n\tif (genwqe_is_privileged(cd)) {\n\t\trc = request_irq(pci_dev->irq, genwqe_pf_isr, IRQF_SHARED,\n\t\t\t\t GENWQE_DEVNAME, cd);\n\t} else {\n\t\trc = request_irq(pci_dev->irq, genwqe_vf_isr, IRQF_SHARED,\n\t\t\t\t GENWQE_DEVNAME, cd);\n\t}\n\tif (rc < 0) {\n\t\tdev_err(&pci_dev->dev, \"irq %d not free.\\n\", pci_dev->irq);\n\t\tgoto stop_irq_cap;\n\t}\n\n\tcd->card_state = GENWQE_CARD_USED;\n\treturn 0;\n\n stop_irq_cap:\n\tgenwqe_reset_interrupt_capability(cd);\n stop_kthread:\n\tkthread_stop(cd->card_thread);\n\tcd->card_thread = NULL;\n stop_free_queue:\n\tfree_ddcb_queue(cd, queue);\n err_out:\n\treturn rc;\n}\n\n \nstatic int queue_wake_up_all(struct genwqe_dev *cd)\n{\n\tunsigned int i;\n\tunsigned long flags;\n\tstruct ddcb_queue *queue = &cd->queue;\n\n\tspin_lock_irqsave(&queue->ddcb_lock, flags);\n\n\tfor (i = 0; i < queue->ddcb_max; i++)\n\t\twake_up_interruptible(&queue->ddcb_waitqs[queue->ddcb_act]);\n\n\twake_up_interruptible(&queue->busy_waitq);\n\tspin_unlock_irqrestore(&queue->ddcb_lock, flags);\n\n\treturn 0;\n}\n\n \nint genwqe_finish_queue(struct genwqe_dev *cd)\n{\n\tint i, rc = 0, in_flight;\n\tint waitmax = GENWQE_DDCB_SOFTWARE_TIMEOUT;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tstruct ddcb_queue *queue = &cd->queue;\n\n\tif (!ddcb_queue_initialized(queue))\n\t\treturn 0;\n\n\t \n\tif (cd->card_state == GENWQE_CARD_USED)\n\t\tcd->card_state = GENWQE_CARD_UNUSED;\n\n\t \n\tqueue_wake_up_all(cd);\n\n\t \n\tfor (i = 0; i < waitmax; i++) {\n\t\tin_flight = genwqe_ddcbs_in_flight(cd);\n\n\t\tif (in_flight == 0)\n\t\t\tbreak;\n\n\t\tdev_dbg(&pci_dev->dev,\n\t\t\t\"  DEBUG [%d/%d] waiting for queue to get empty: %d requests!\\n\",\n\t\t\ti, waitmax, in_flight);\n\n\t\t \n\t\tmsleep(1000);\n\t}\n\tif (i == waitmax) {\n\t\tdev_err(&pci_dev->dev, \"  [%s] err: queue is not empty!!\\n\",\n\t\t\t__func__);\n\t\trc = -EIO;\n\t}\n\treturn rc;\n}\n\n \nint genwqe_release_service_layer(struct genwqe_dev *cd)\n{\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tif (!ddcb_queue_initialized(&cd->queue))\n\t\treturn 1;\n\n\tfree_irq(pci_dev->irq, cd);\n\tgenwqe_reset_interrupt_capability(cd);\n\n\tif (cd->card_thread != NULL) {\n\t\tkthread_stop(cd->card_thread);\n\t\tcd->card_thread = NULL;\n\t}\n\n\tfree_ddcb_queue(cd, &cd->queue);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}