{
  "module_name": "card_dev.c",
  "hash_id": "b9e8f76e39a8698b092af9fb2c0573dc633c8fd6fe2aa9ef0de872c13f0f5912",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/genwqe/card_dev.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n#include <linux/atomic.h>\n\n#include \"card_base.h\"\n#include \"card_ddcb.h\"\n\nstatic int genwqe_open_files(struct genwqe_dev *cd)\n{\n\tint rc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cd->file_lock, flags);\n\trc = list_empty(&cd->file_list);\n\tspin_unlock_irqrestore(&cd->file_lock, flags);\n\treturn !rc;\n}\n\nstatic void genwqe_add_file(struct genwqe_dev *cd, struct genwqe_file *cfile)\n{\n\tunsigned long flags;\n\n\tcfile->opener = get_pid(task_tgid(current));\n\tspin_lock_irqsave(&cd->file_lock, flags);\n\tlist_add(&cfile->list, &cd->file_list);\n\tspin_unlock_irqrestore(&cd->file_lock, flags);\n}\n\nstatic int genwqe_del_file(struct genwqe_dev *cd, struct genwqe_file *cfile)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cd->file_lock, flags);\n\tlist_del(&cfile->list);\n\tspin_unlock_irqrestore(&cd->file_lock, flags);\n\tput_pid(cfile->opener);\n\n\treturn 0;\n}\n\nstatic void genwqe_add_pin(struct genwqe_file *cfile, struct dma_mapping *m)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cfile->pin_lock, flags);\n\tlist_add(&m->pin_list, &cfile->pin_list);\n\tspin_unlock_irqrestore(&cfile->pin_lock, flags);\n}\n\nstatic int genwqe_del_pin(struct genwqe_file *cfile, struct dma_mapping *m)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cfile->pin_lock, flags);\n\tlist_del(&m->pin_list);\n\tspin_unlock_irqrestore(&cfile->pin_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic struct dma_mapping *genwqe_search_pin(struct genwqe_file *cfile,\n\t\t\t\t\t    unsigned long u_addr,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    void **virt_addr)\n{\n\tunsigned long flags;\n\tstruct dma_mapping *m;\n\n\tspin_lock_irqsave(&cfile->pin_lock, flags);\n\n\tlist_for_each_entry(m, &cfile->pin_list, pin_list) {\n\t\tif ((((u64)m->u_vaddr) <= (u_addr)) &&\n\t\t    (((u64)m->u_vaddr + m->size) >= (u_addr + size))) {\n\n\t\t\tif (virt_addr)\n\t\t\t\t*virt_addr = m->k_vaddr +\n\t\t\t\t\t(u_addr - (u64)m->u_vaddr);\n\n\t\t\tspin_unlock_irqrestore(&cfile->pin_lock, flags);\n\t\t\treturn m;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cfile->pin_lock, flags);\n\treturn NULL;\n}\n\nstatic void __genwqe_add_mapping(struct genwqe_file *cfile,\n\t\t\t      struct dma_mapping *dma_map)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cfile->map_lock, flags);\n\tlist_add(&dma_map->card_list, &cfile->map_list);\n\tspin_unlock_irqrestore(&cfile->map_lock, flags);\n}\n\nstatic void __genwqe_del_mapping(struct genwqe_file *cfile,\n\t\t\t      struct dma_mapping *dma_map)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cfile->map_lock, flags);\n\tlist_del(&dma_map->card_list);\n\tspin_unlock_irqrestore(&cfile->map_lock, flags);\n}\n\n\n \nstatic struct dma_mapping *__genwqe_search_mapping(struct genwqe_file *cfile,\n\t\t\t\t\t\t   unsigned long u_addr,\n\t\t\t\t\t\t   unsigned int size,\n\t\t\t\t\t\t   dma_addr_t *dma_addr,\n\t\t\t\t\t\t   void **virt_addr)\n{\n\tunsigned long flags;\n\tstruct dma_mapping *m;\n\tstruct pci_dev *pci_dev = cfile->cd->pci_dev;\n\n\tspin_lock_irqsave(&cfile->map_lock, flags);\n\tlist_for_each_entry(m, &cfile->map_list, card_list) {\n\n\t\tif ((((u64)m->u_vaddr) <= (u_addr)) &&\n\t\t    (((u64)m->u_vaddr + m->size) >= (u_addr + size))) {\n\n\t\t\t \n\t\t\tif (dma_addr)\n\t\t\t\t*dma_addr = m->dma_addr +\n\t\t\t\t\t(u_addr - (u64)m->u_vaddr);\n\n\t\t\tif (virt_addr)\n\t\t\t\t*virt_addr = m->k_vaddr +\n\t\t\t\t\t(u_addr - (u64)m->u_vaddr);\n\n\t\t\tspin_unlock_irqrestore(&cfile->map_lock, flags);\n\t\t\treturn m;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cfile->map_lock, flags);\n\n\tdev_err(&pci_dev->dev,\n\t\t\"[%s] Entry not found: u_addr=%lx, size=%x\\n\",\n\t\t__func__, u_addr, size);\n\n\treturn NULL;\n}\n\nstatic void genwqe_remove_mappings(struct genwqe_file *cfile)\n{\n\tint i = 0;\n\tstruct list_head *node, *next;\n\tstruct dma_mapping *dma_map;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct pci_dev *pci_dev = cfile->cd->pci_dev;\n\n\tlist_for_each_safe(node, next, &cfile->map_list) {\n\t\tdma_map = list_entry(node, struct dma_mapping, card_list);\n\n\t\tlist_del_init(&dma_map->card_list);\n\n\t\t \n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] %d. cleanup mapping: u_vaddr=%p u_kaddr=%016lx dma_addr=%lx\\n\",\n\t\t\t__func__, i++, dma_map->u_vaddr,\n\t\t\t(unsigned long)dma_map->k_vaddr,\n\t\t\t(unsigned long)dma_map->dma_addr);\n\n\t\tif (dma_map->type == GENWQE_MAPPING_RAW) {\n\t\t\t \n\t\t\t__genwqe_free_consistent(cd, dma_map->size,\n\t\t\t\t\t\tdma_map->k_vaddr,\n\t\t\t\t\t\tdma_map->dma_addr);\n\t\t\tkfree(dma_map);\n\t\t} else if (dma_map->type == GENWQE_MAPPING_SGL_TEMP) {\n\t\t\t \n\t\t\tgenwqe_user_vunmap(cd, dma_map);\n\t\t}\n\t}\n}\n\nstatic void genwqe_remove_pinnings(struct genwqe_file *cfile)\n{\n\tstruct list_head *node, *next;\n\tstruct dma_mapping *dma_map;\n\tstruct genwqe_dev *cd = cfile->cd;\n\n\tlist_for_each_safe(node, next, &cfile->pin_list) {\n\t\tdma_map = list_entry(node, struct dma_mapping, pin_list);\n\n\t\t \n\t\tlist_del_init(&dma_map->pin_list);\n\t\tgenwqe_user_vunmap(cd, dma_map);\n\t\tkfree(dma_map);\n\t}\n}\n\n \nstatic int genwqe_kill_fasync(struct genwqe_dev *cd, int sig)\n{\n\tunsigned int files = 0;\n\tunsigned long flags;\n\tstruct genwqe_file *cfile;\n\n\tspin_lock_irqsave(&cd->file_lock, flags);\n\tlist_for_each_entry(cfile, &cd->file_list, list) {\n\t\tif (cfile->async_queue)\n\t\t\tkill_fasync(&cfile->async_queue, sig, POLL_HUP);\n\t\tfiles++;\n\t}\n\tspin_unlock_irqrestore(&cd->file_lock, flags);\n\treturn files;\n}\n\nstatic int genwqe_terminate(struct genwqe_dev *cd)\n{\n\tunsigned int files = 0;\n\tunsigned long flags;\n\tstruct genwqe_file *cfile;\n\n\tspin_lock_irqsave(&cd->file_lock, flags);\n\tlist_for_each_entry(cfile, &cd->file_list, list) {\n\t\tkill_pid(cfile->opener, SIGKILL, 1);\n\t\tfiles++;\n\t}\n\tspin_unlock_irqrestore(&cd->file_lock, flags);\n\treturn files;\n}\n\n \nstatic int genwqe_open(struct inode *inode, struct file *filp)\n{\n\tstruct genwqe_dev *cd;\n\tstruct genwqe_file *cfile;\n\n\tcfile = kzalloc(sizeof(*cfile), GFP_KERNEL);\n\tif (cfile == NULL)\n\t\treturn -ENOMEM;\n\n\tcd = container_of(inode->i_cdev, struct genwqe_dev, cdev_genwqe);\n\tcfile->cd = cd;\n\tcfile->filp = filp;\n\tcfile->client = NULL;\n\n\tspin_lock_init(&cfile->map_lock);   \n\tINIT_LIST_HEAD(&cfile->map_list);\n\n\tspin_lock_init(&cfile->pin_lock);   \n\tINIT_LIST_HEAD(&cfile->pin_list);\n\n\tfilp->private_data = cfile;\n\n\tgenwqe_add_file(cd, cfile);\n\treturn 0;\n}\n\n \nstatic int genwqe_fasync(int fd, struct file *filp, int mode)\n{\n\tstruct genwqe_file *cdev = (struct genwqe_file *)filp->private_data;\n\n\treturn fasync_helper(fd, filp, mode, &cdev->async_queue);\n}\n\n\n \nstatic int genwqe_release(struct inode *inode, struct file *filp)\n{\n\tstruct genwqe_file *cfile = (struct genwqe_file *)filp->private_data;\n\tstruct genwqe_dev *cd = cfile->cd;\n\n\t \n\tgenwqe_remove_mappings(cfile);\n\tgenwqe_remove_pinnings(cfile);\n\n\t \n\tgenwqe_fasync(-1, filp, 0);\n\n\t \n\tgenwqe_del_file(cd, cfile);\n\tkfree(cfile);\n\treturn 0;\n}\n\nstatic void genwqe_vma_open(struct vm_area_struct *vma)\n{\n\t \n}\n\n \nstatic void genwqe_vma_close(struct vm_area_struct *vma)\n{\n\tunsigned long vsize = vma->vm_end - vma->vm_start;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct dma_mapping *dma_map;\n\tstruct genwqe_dev *cd = container_of(inode->i_cdev, struct genwqe_dev,\n\t\t\t\t\t    cdev_genwqe);\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tdma_addr_t d_addr = 0;\n\tstruct genwqe_file *cfile = vma->vm_private_data;\n\n\tdma_map = __genwqe_search_mapping(cfile, vma->vm_start, vsize,\n\t\t\t\t\t &d_addr, NULL);\n\tif (dma_map == NULL) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"  [%s] err: mapping not found: v=%lx, p=%lx s=%lx\\n\",\n\t\t\t__func__, vma->vm_start, vma->vm_pgoff << PAGE_SHIFT,\n\t\t\tvsize);\n\t\treturn;\n\t}\n\t__genwqe_del_mapping(cfile, dma_map);\n\t__genwqe_free_consistent(cd, dma_map->size, dma_map->k_vaddr,\n\t\t\t\t dma_map->dma_addr);\n\tkfree(dma_map);\n}\n\nstatic const struct vm_operations_struct genwqe_vma_ops = {\n\t.open   = genwqe_vma_open,\n\t.close  = genwqe_vma_close,\n};\n\n \nstatic int genwqe_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tint rc;\n\tunsigned long pfn, vsize = vma->vm_end - vma->vm_start;\n\tstruct genwqe_file *cfile = (struct genwqe_file *)filp->private_data;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct dma_mapping *dma_map;\n\n\tif (vsize == 0)\n\t\treturn -EINVAL;\n\n\tif (get_order(vsize) > MAX_ORDER)\n\t\treturn -ENOMEM;\n\n\tdma_map = kzalloc(sizeof(struct dma_mapping), GFP_KERNEL);\n\tif (dma_map == NULL)\n\t\treturn -ENOMEM;\n\n\tgenwqe_mapping_init(dma_map, GENWQE_MAPPING_RAW);\n\tdma_map->u_vaddr = (void *)vma->vm_start;\n\tdma_map->size = vsize;\n\tdma_map->nr_pages = DIV_ROUND_UP(vsize, PAGE_SIZE);\n\tdma_map->k_vaddr = __genwqe_alloc_consistent(cd, vsize,\n\t\t\t\t\t\t     &dma_map->dma_addr);\n\tif (dma_map->k_vaddr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto free_dma_map;\n\t}\n\n\tif (capable(CAP_SYS_ADMIN) && (vsize > sizeof(dma_addr_t)))\n\t\t*(dma_addr_t *)dma_map->k_vaddr = dma_map->dma_addr;\n\n\tpfn = virt_to_phys(dma_map->k_vaddr) >> PAGE_SHIFT;\n\trc = remap_pfn_range(vma,\n\t\t\t     vma->vm_start,\n\t\t\t     pfn,\n\t\t\t     vsize,\n\t\t\t     vma->vm_page_prot);\n\tif (rc != 0) {\n\t\trc = -EFAULT;\n\t\tgoto free_dma_mem;\n\t}\n\n\tvma->vm_private_data = cfile;\n\tvma->vm_ops = &genwqe_vma_ops;\n\t__genwqe_add_mapping(cfile, dma_map);\n\n\treturn 0;\n\n free_dma_mem:\n\t__genwqe_free_consistent(cd, dma_map->size,\n\t\t\t\tdma_map->k_vaddr,\n\t\t\t\tdma_map->dma_addr);\n free_dma_map:\n\tkfree(dma_map);\n\treturn rc;\n}\n\n#define\tFLASH_BLOCK\t0x40000\t \n\n \nstatic int do_flash_update(struct genwqe_file *cfile,\n\t\t\t   struct genwqe_bitstream *load)\n{\n\tint rc = 0;\n\tint blocks_to_flash;\n\tdma_addr_t dma_addr;\n\tu64 flash = 0;\n\tsize_t tocopy = 0;\n\tu8 __user *buf;\n\tu8 *xbuf;\n\tu32 crc;\n\tu8 cmdopts;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct file *filp = cfile->filp;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tif ((load->size & 0x3) != 0)\n\t\treturn -EINVAL;\n\n\tif (((unsigned long)(load->data_addr) & ~PAGE_MASK) != 0)\n\t\treturn -EINVAL;\n\n\t \n\tswitch ((char)load->partition) {\n\tcase '0':\n\t\tcmdopts = 0x14;\n\t\tbreak;\t\t \n\tcase '1':\n\t\tcmdopts = 0x1C;\n\t\tbreak;\t\t \n\tcase 'v':\n\t\tcmdopts = 0x0C;\n\t\tbreak;\t\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tbuf = (u8 __user *)load->data_addr;\n\txbuf = __genwqe_alloc_consistent(cd, FLASH_BLOCK, &dma_addr);\n\tif (xbuf == NULL)\n\t\treturn -ENOMEM;\n\n\tblocks_to_flash = load->size / FLASH_BLOCK;\n\twhile (load->size) {\n\t\tstruct genwqe_ddcb_cmd *req;\n\n\t\t \n\t\ttocopy = min_t(size_t, load->size, FLASH_BLOCK);\n\n\t\trc = copy_from_user(xbuf, buf, tocopy);\n\t\tif (rc) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto free_buffer;\n\t\t}\n\t\tcrc = genwqe_crc32(xbuf, tocopy, 0xffffffff);\n\n\t\tdev_dbg(&pci_dev->dev,\n\t\t\t\"[%s] DMA: %lx CRC: %08x SZ: %ld %d\\n\",\n\t\t\t__func__, (unsigned long)dma_addr, crc, tocopy,\n\t\t\tblocks_to_flash);\n\n\t\t \n\t\treq = ddcb_requ_alloc();\n\t\tif (req == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_buffer;\n\t\t}\n\n\t\treq->cmd = SLCMD_MOVE_FLASH;\n\t\treq->cmdopts = cmdopts;\n\n\t\t \n\t\tif (genwqe_get_slu_id(cd) <= 0x2) {\n\t\t\t*(__be64 *)&req->__asiv[0]  = cpu_to_be64(dma_addr);\n\t\t\t*(__be64 *)&req->__asiv[8]  = cpu_to_be64(tocopy);\n\t\t\t*(__be64 *)&req->__asiv[16] = cpu_to_be64(flash);\n\t\t\t*(__be32 *)&req->__asiv[24] = cpu_to_be32(0);\n\t\t\treq->__asiv[24]\t       = load->uid;\n\t\t\t*(__be32 *)&req->__asiv[28] = cpu_to_be32(crc);\n\n\t\t\t \n\t\t\t*(__be64 *)&req->__asiv[88] = cpu_to_be64(load->slu_id);\n\t\t\t*(__be64 *)&req->__asiv[96] = cpu_to_be64(load->app_id);\n\t\t\treq->asiv_length = 32;  \n\t\t} else {\t \n\t\t\t*(__be64 *)&req->asiv[0]  = cpu_to_be64(dma_addr);\n\t\t\t*(__be32 *)&req->asiv[8]  = cpu_to_be32(tocopy);\n\t\t\t*(__be32 *)&req->asiv[12] = cpu_to_be32(0);  \n\t\t\t*(__be64 *)&req->asiv[16] = cpu_to_be64(flash);\n\t\t\t*(__be32 *)&req->asiv[24] = cpu_to_be32(load->uid<<24);\n\t\t\t*(__be32 *)&req->asiv[28] = cpu_to_be32(crc);\n\n\t\t\t \n\t\t\t*(__be64 *)&req->asiv[80] = cpu_to_be64(load->slu_id);\n\t\t\t*(__be64 *)&req->asiv[88] = cpu_to_be64(load->app_id);\n\n\t\t\t \n\t\t\treq->ats = 0x4ULL << 44;\n\t\t\treq->asiv_length = 40;  \n\t\t}\n\t\treq->asv_length  = 8;\n\n\t\t \n\t\t*(u64 *)&req->asv[0] = 0ULL;\t\t\t \n\n\t\trc = __genwqe_execute_raw_ddcb(cd, req, filp->f_flags);\n\n\t\tload->retc = req->retc;\n\t\tload->attn = req->attn;\n\t\tload->progress = req->progress;\n\n\t\tif (rc < 0) {\n\t\t\tddcb_requ_free(req);\n\t\t\tgoto free_buffer;\n\t\t}\n\n\t\tif (req->retc != DDCB_RETC_COMPLETE) {\n\t\t\trc = -EIO;\n\t\t\tddcb_requ_free(req);\n\t\t\tgoto free_buffer;\n\t\t}\n\n\t\tload->size  -= tocopy;\n\t\tflash += tocopy;\n\t\tbuf += tocopy;\n\t\tblocks_to_flash--;\n\t\tddcb_requ_free(req);\n\t}\n\n free_buffer:\n\t__genwqe_free_consistent(cd, FLASH_BLOCK, xbuf, dma_addr);\n\treturn rc;\n}\n\nstatic int do_flash_read(struct genwqe_file *cfile,\n\t\t\t struct genwqe_bitstream *load)\n{\n\tint rc, blocks_to_flash;\n\tdma_addr_t dma_addr;\n\tu64 flash = 0;\n\tsize_t tocopy = 0;\n\tu8 __user *buf;\n\tu8 *xbuf;\n\tu8 cmdopts;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct file *filp = cfile->filp;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tstruct genwqe_ddcb_cmd *cmd;\n\n\tif ((load->size & 0x3) != 0)\n\t\treturn -EINVAL;\n\n\tif (((unsigned long)(load->data_addr) & ~PAGE_MASK) != 0)\n\t\treturn -EINVAL;\n\n\t \n\tswitch ((char)load->partition) {\n\tcase '0':\n\t\tcmdopts = 0x12;\n\t\tbreak;\t\t \n\tcase '1':\n\t\tcmdopts = 0x1A;\n\t\tbreak;\t\t \n\tcase 'v':\n\t\tcmdopts = 0x0A;\n\t\tbreak;\t\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tbuf = (u8 __user *)load->data_addr;\n\txbuf = __genwqe_alloc_consistent(cd, FLASH_BLOCK, &dma_addr);\n\tif (xbuf == NULL)\n\t\treturn -ENOMEM;\n\n\tblocks_to_flash = load->size / FLASH_BLOCK;\n\twhile (load->size) {\n\t\t \n\t\ttocopy = min_t(size_t, load->size, FLASH_BLOCK);\n\n\t\tdev_dbg(&pci_dev->dev,\n\t\t\t\"[%s] DMA: %lx SZ: %ld %d\\n\",\n\t\t\t__func__, (unsigned long)dma_addr, tocopy,\n\t\t\tblocks_to_flash);\n\n\t\t \n\t\tcmd = ddcb_requ_alloc();\n\t\tif (cmd == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_buffer;\n\t\t}\n\t\tcmd->cmd = SLCMD_MOVE_FLASH;\n\t\tcmd->cmdopts = cmdopts;\n\n\t\t \n\t\tif (genwqe_get_slu_id(cd) <= 0x2) {\n\t\t\t*(__be64 *)&cmd->__asiv[0]  = cpu_to_be64(dma_addr);\n\t\t\t*(__be64 *)&cmd->__asiv[8]  = cpu_to_be64(tocopy);\n\t\t\t*(__be64 *)&cmd->__asiv[16] = cpu_to_be64(flash);\n\t\t\t*(__be32 *)&cmd->__asiv[24] = cpu_to_be32(0);\n\t\t\tcmd->__asiv[24] = load->uid;\n\t\t\t*(__be32 *)&cmd->__asiv[28] = cpu_to_be32(0)  ;\n\t\t\tcmd->asiv_length = 32;  \n\t\t} else {\t \n\t\t\t*(__be64 *)&cmd->asiv[0]  = cpu_to_be64(dma_addr);\n\t\t\t*(__be32 *)&cmd->asiv[8]  = cpu_to_be32(tocopy);\n\t\t\t*(__be32 *)&cmd->asiv[12] = cpu_to_be32(0);  \n\t\t\t*(__be64 *)&cmd->asiv[16] = cpu_to_be64(flash);\n\t\t\t*(__be32 *)&cmd->asiv[24] = cpu_to_be32(load->uid<<24);\n\t\t\t*(__be32 *)&cmd->asiv[28] = cpu_to_be32(0);  \n\n\t\t\t \n\t\t\tcmd->ats = 0x5ULL << 44;\n\t\t\tcmd->asiv_length = 40;  \n\t\t}\n\t\tcmd->asv_length  = 8;\n\n\t\t \n\t\t*(u64 *)&cmd->asv[0] = 0ULL;\t \n\n\t\trc = __genwqe_execute_raw_ddcb(cd, cmd, filp->f_flags);\n\n\t\tload->retc = cmd->retc;\n\t\tload->attn = cmd->attn;\n\t\tload->progress = cmd->progress;\n\n\t\tif ((rc < 0) && (rc != -EBADMSG)) {\n\t\t\tddcb_requ_free(cmd);\n\t\t\tgoto free_buffer;\n\t\t}\n\n\t\trc = copy_to_user(buf, xbuf, tocopy);\n\t\tif (rc) {\n\t\t\trc = -EFAULT;\n\t\t\tddcb_requ_free(cmd);\n\t\t\tgoto free_buffer;\n\t\t}\n\n\t\t \n\t\tif (((cmd->retc == DDCB_RETC_FAULT) &&\n\t\t     (cmd->attn != 0x02)) ||   \n\t\t    ((cmd->retc == DDCB_RETC_COMPLETE) &&\n\t\t     (cmd->attn != 0x00))) {   \n\t\t\trc = -EIO;\n\t\t\tddcb_requ_free(cmd);\n\t\t\tgoto free_buffer;\n\t\t}\n\n\t\tload->size  -= tocopy;\n\t\tflash += tocopy;\n\t\tbuf += tocopy;\n\t\tblocks_to_flash--;\n\t\tddcb_requ_free(cmd);\n\t}\n\trc = 0;\n\n free_buffer:\n\t__genwqe_free_consistent(cd, FLASH_BLOCK, xbuf, dma_addr);\n\treturn rc;\n}\n\nstatic int genwqe_pin_mem(struct genwqe_file *cfile, struct genwqe_mem *m)\n{\n\tint rc;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct pci_dev *pci_dev = cfile->cd->pci_dev;\n\tstruct dma_mapping *dma_map;\n\tunsigned long map_addr;\n\tunsigned long map_size;\n\n\tif ((m->addr == 0x0) || (m->size == 0))\n\t\treturn -EINVAL;\n\tif (m->size > ULONG_MAX - PAGE_SIZE - (m->addr & ~PAGE_MASK))\n\t\treturn -EINVAL;\n\n\tmap_addr = (m->addr & PAGE_MASK);\n\tmap_size = round_up(m->size + (m->addr & ~PAGE_MASK), PAGE_SIZE);\n\n\tdma_map = kzalloc(sizeof(struct dma_mapping), GFP_KERNEL);\n\tif (dma_map == NULL)\n\t\treturn -ENOMEM;\n\n\tgenwqe_mapping_init(dma_map, GENWQE_MAPPING_SGL_PINNED);\n\trc = genwqe_user_vmap(cd, dma_map, (void *)map_addr, map_size);\n\tif (rc != 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] genwqe_user_vmap rc=%d\\n\", __func__, rc);\n\t\tkfree(dma_map);\n\t\treturn rc;\n\t}\n\n\tgenwqe_add_pin(cfile, dma_map);\n\treturn 0;\n}\n\nstatic int genwqe_unpin_mem(struct genwqe_file *cfile, struct genwqe_mem *m)\n{\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct dma_mapping *dma_map;\n\tunsigned long map_addr;\n\tunsigned long map_size;\n\n\tif (m->addr == 0x0)\n\t\treturn -EINVAL;\n\n\tmap_addr = (m->addr & PAGE_MASK);\n\tmap_size = round_up(m->size + (m->addr & ~PAGE_MASK), PAGE_SIZE);\n\n\tdma_map = genwqe_search_pin(cfile, map_addr, map_size, NULL);\n\tif (dma_map == NULL)\n\t\treturn -ENOENT;\n\n\tgenwqe_del_pin(cfile, dma_map);\n\tgenwqe_user_vunmap(cd, dma_map);\n\tkfree(dma_map);\n\treturn 0;\n}\n\n \nstatic int ddcb_cmd_cleanup(struct genwqe_file *cfile, struct ddcb_requ *req)\n{\n\tunsigned int i;\n\tstruct dma_mapping *dma_map;\n\tstruct genwqe_dev *cd = cfile->cd;\n\n\tfor (i = 0; i < DDCB_FIXUPS; i++) {\n\t\tdma_map = &req->dma_mappings[i];\n\n\t\tif (dma_mapping_used(dma_map)) {\n\t\t\t__genwqe_del_mapping(cfile, dma_map);\n\t\t\tgenwqe_user_vunmap(cd, dma_map);\n\t\t}\n\t\tif (req->sgls[i].sgl != NULL)\n\t\t\tgenwqe_free_sync_sgl(cd, &req->sgls[i]);\n\t}\n\treturn 0;\n}\n\n \nstatic int ddcb_cmd_fixups(struct genwqe_file *cfile, struct ddcb_requ *req)\n{\n\tint rc;\n\tunsigned int asiv_offs, i;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct genwqe_ddcb_cmd *cmd = &req->cmd;\n\tstruct dma_mapping *m;\n\n\tfor (i = 0, asiv_offs = 0x00; asiv_offs <= 0x58;\n\t     i++, asiv_offs += 0x08) {\n\n\t\tu64 u_addr;\n\t\tdma_addr_t d_addr;\n\t\tu32 u_size = 0;\n\t\tu64 ats_flags;\n\n\t\tats_flags = ATS_GET_FLAGS(cmd->ats, asiv_offs);\n\n\t\tswitch (ats_flags) {\n\n\t\tcase ATS_TYPE_DATA:\n\t\t\tbreak;\t \n\n\t\tcase ATS_TYPE_FLAT_RDWR:\n\t\tcase ATS_TYPE_FLAT_RD: {\n\t\t\tu_addr = be64_to_cpu(*((__be64 *)&cmd->\n\t\t\t\t\t       asiv[asiv_offs]));\n\t\t\tu_size = be32_to_cpu(*((__be32 *)&cmd->\n\t\t\t\t\t       asiv[asiv_offs + 0x08]));\n\n\t\t\t \n\t\t\tif (u_size == 0x0) {\n\t\t\t\t*((__be64 *)&cmd->asiv[asiv_offs]) =\n\t\t\t\t\tcpu_to_be64(0x0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tm = __genwqe_search_mapping(cfile, u_addr, u_size,\n\t\t\t\t\t\t   &d_addr, NULL);\n\t\t\tif (m == NULL) {\n\t\t\t\trc = -EFAULT;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\t*((__be64 *)&cmd->asiv[asiv_offs]) =\n\t\t\t\tcpu_to_be64(d_addr);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ATS_TYPE_SGL_RDWR:\n\t\tcase ATS_TYPE_SGL_RD: {\n\t\t\tint page_offs;\n\n\t\t\tu_addr = be64_to_cpu(*((__be64 *)\n\t\t\t\t\t       &cmd->asiv[asiv_offs]));\n\t\t\tu_size = be32_to_cpu(*((__be32 *)\n\t\t\t\t\t       &cmd->asiv[asiv_offs + 0x08]));\n\n\t\t\t \n\t\t\tif (u_size == 0x0) {\n\t\t\t\t*((__be64 *)&cmd->asiv[asiv_offs]) =\n\t\t\t\t\tcpu_to_be64(0x0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tm = genwqe_search_pin(cfile, u_addr, u_size, NULL);\n\t\t\tif (m != NULL) {\n\t\t\t\tpage_offs = (u_addr -\n\t\t\t\t\t     (u64)m->u_vaddr)/PAGE_SIZE;\n\t\t\t} else {\n\t\t\t\tm = &req->dma_mappings[i];\n\n\t\t\t\tgenwqe_mapping_init(m,\n\t\t\t\t\t\t    GENWQE_MAPPING_SGL_TEMP);\n\n\t\t\t\tif (ats_flags == ATS_TYPE_SGL_RD)\n\t\t\t\t\tm->write = 0;\n\n\t\t\t\trc = genwqe_user_vmap(cd, m, (void *)u_addr,\n\t\t\t\t\t\t      u_size);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto err_out;\n\n\t\t\t\t__genwqe_add_mapping(cfile, m);\n\t\t\t\tpage_offs = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\trc = genwqe_alloc_sync_sgl(cd, &req->sgls[i],\n\t\t\t\t\t\t   (void __user *)u_addr,\n\t\t\t\t\t\t   u_size, m->write);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto err_out;\n\n\t\t\tgenwqe_setup_sgl(cd, &req->sgls[i],\n\t\t\t\t\t &m->dma_list[page_offs]);\n\n\t\t\t*((__be64 *)&cmd->asiv[asiv_offs]) =\n\t\t\t\tcpu_to_be64(req->sgls[i].sgl_dma_addr);\n\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\treturn 0;\n\n err_out:\n\tddcb_cmd_cleanup(cfile, req);\n\treturn rc;\n}\n\n \nstatic int genwqe_execute_ddcb(struct genwqe_file *cfile,\n\t\t\t       struct genwqe_ddcb_cmd *cmd)\n{\n\tint rc;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct file *filp = cfile->filp;\n\tstruct ddcb_requ *req = container_of(cmd, struct ddcb_requ, cmd);\n\n\trc = ddcb_cmd_fixups(cfile, req);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = __genwqe_execute_raw_ddcb(cd, cmd, filp->f_flags);\n\tddcb_cmd_cleanup(cfile, req);\n\treturn rc;\n}\n\nstatic int do_execute_ddcb(struct genwqe_file *cfile,\n\t\t\t   unsigned long arg, int raw)\n{\n\tint rc;\n\tstruct genwqe_ddcb_cmd *cmd;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct file *filp = cfile->filp;\n\n\tcmd = ddcb_requ_alloc();\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(cmd, (void __user *)arg, sizeof(*cmd))) {\n\t\tddcb_requ_free(cmd);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!raw)\n\t\trc = genwqe_execute_ddcb(cfile, cmd);\n\telse\n\t\trc = __genwqe_execute_raw_ddcb(cd, cmd, filp->f_flags);\n\n\t \n\tif (copy_to_user((void __user *)arg, cmd,\n\t\t\t sizeof(*cmd) - DDCB_ASIV_LENGTH)) {\n\t\tddcb_requ_free(cmd);\n\t\treturn -EFAULT;\n\t}\n\n\tddcb_requ_free(cmd);\n\treturn rc;\n}\n\n \nstatic long genwqe_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tint rc = 0;\n\tstruct genwqe_file *cfile = (struct genwqe_file *)filp->private_data;\n\tstruct genwqe_dev *cd = cfile->cd;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\tstruct genwqe_reg_io __user *io;\n\tu64 val;\n\tu32 reg_offs;\n\n\t \n\tif (pci_channel_offline(pci_dev))\n\t\treturn -EIO;\n\n\tif (_IOC_TYPE(cmd) != GENWQE_IOC_CODE)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\n\tcase GENWQE_GET_CARD_STATE:\n\t\tput_user(cd->card_state, (enum genwqe_card_state __user *)arg);\n\t\treturn 0;\n\n\t\t \n\tcase GENWQE_READ_REG64: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x7))\n\t\t\treturn -EINVAL;\n\n\t\tval = __genwqe_readq(cd, reg_offs);\n\t\tput_user(val, &io->val64);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_WRITE_REG64: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x7))\n\t\t\treturn -EINVAL;\n\n\t\tif (get_user(val, &io->val64))\n\t\t\treturn -EFAULT;\n\n\t\t__genwqe_writeq(cd, reg_offs, val);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_READ_REG32: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x3))\n\t\t\treturn -EINVAL;\n\n\t\tval = __genwqe_readl(cd, reg_offs);\n\t\tput_user(val, &io->val64);\n\t\treturn 0;\n\t}\n\n\tcase GENWQE_WRITE_REG32: {\n\t\tio = (struct genwqe_reg_io __user *)arg;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(reg_offs, &io->num))\n\t\t\treturn -EFAULT;\n\n\t\tif ((reg_offs >= cd->mmio_len) || (reg_offs & 0x3))\n\t\t\treturn -EINVAL;\n\n\t\tif (get_user(val, &io->val64))\n\t\t\treturn -EFAULT;\n\n\t\t__genwqe_writel(cd, reg_offs, val);\n\t\treturn 0;\n\t}\n\n\t\t \n\tcase GENWQE_SLU_UPDATE: {\n\t\tstruct genwqe_bitstream load;\n\n\t\tif (!genwqe_is_privileged(cd))\n\t\t\treturn -EPERM;\n\n\t\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&load, (void __user *)arg,\n\t\t\t\t   sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\trc = do_flash_update(cfile, &load);\n\n\t\tif (copy_to_user((void __user *)arg, &load, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\treturn rc;\n\t}\n\n\tcase GENWQE_SLU_READ: {\n\t\tstruct genwqe_bitstream load;\n\n\t\tif (!genwqe_is_privileged(cd))\n\t\t\treturn -EPERM;\n\n\t\tif (genwqe_flash_readback_fails(cd))\n\t\t\treturn -ENOSPC;\t  \n\n\t\tif (copy_from_user(&load, (void __user *)arg, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\trc = do_flash_read(cfile, &load);\n\n\t\tif (copy_to_user((void __user *)arg, &load, sizeof(load)))\n\t\t\treturn -EFAULT;\n\n\t\treturn rc;\n\t}\n\n\t\t \n\tcase GENWQE_PIN_MEM: {\n\t\tstruct genwqe_mem m;\n\n\t\tif (copy_from_user(&m, (void __user *)arg, sizeof(m)))\n\t\t\treturn -EFAULT;\n\n\t\treturn genwqe_pin_mem(cfile, &m);\n\t}\n\n\tcase GENWQE_UNPIN_MEM: {\n\t\tstruct genwqe_mem m;\n\n\t\tif (copy_from_user(&m, (void __user *)arg, sizeof(m)))\n\t\t\treturn -EFAULT;\n\n\t\treturn genwqe_unpin_mem(cfile, &m);\n\t}\n\n\t\t \n\tcase GENWQE_EXECUTE_DDCB:\n\t\treturn do_execute_ddcb(cfile, arg, 0);\n\n\tcase GENWQE_EXECUTE_RAW_DDCB: {\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\treturn do_execute_ddcb(cfile, arg, 1);\n\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nstatic const struct file_operations genwqe_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= genwqe_open,\n\t.fasync\t\t= genwqe_fasync,\n\t.mmap\t\t= genwqe_mmap,\n\t.unlocked_ioctl\t= genwqe_ioctl,\n\t.compat_ioctl   = compat_ptr_ioctl,\n\t.release\t= genwqe_release,\n};\n\nstatic int genwqe_device_initialized(struct genwqe_dev *cd)\n{\n\treturn cd->dev != NULL;\n}\n\n \nint genwqe_device_create(struct genwqe_dev *cd)\n{\n\tint rc;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\t \n\trc = alloc_chrdev_region(&cd->devnum_genwqe, 0,\n\t\t\t\t GENWQE_MAX_MINOR, GENWQE_DEVNAME);\n\tif (rc < 0) {\n\t\tdev_err(&pci_dev->dev, \"err: alloc_chrdev_region failed\\n\");\n\t\tgoto err_dev;\n\t}\n\n\tcdev_init(&cd->cdev_genwqe, &genwqe_fops);\n\tcd->cdev_genwqe.owner = THIS_MODULE;\n\n\trc = cdev_add(&cd->cdev_genwqe, cd->devnum_genwqe, 1);\n\tif (rc < 0) {\n\t\tdev_err(&pci_dev->dev, \"err: cdev_add failed\\n\");\n\t\tgoto err_add;\n\t}\n\n\t \n\tcd->dev = device_create_with_groups(cd->class_genwqe,\n\t\t\t\t\t    &cd->pci_dev->dev,\n\t\t\t\t\t    cd->devnum_genwqe, cd,\n\t\t\t\t\t    genwqe_attribute_groups,\n\t\t\t\t\t    GENWQE_DEVNAME \"%u_card\",\n\t\t\t\t\t    cd->card_idx);\n\tif (IS_ERR(cd->dev)) {\n\t\trc = PTR_ERR(cd->dev);\n\t\tgoto err_cdev;\n\t}\n\n\tgenwqe_init_debugfs(cd);\n\n\treturn 0;\n\n err_cdev:\n\tcdev_del(&cd->cdev_genwqe);\n err_add:\n\tunregister_chrdev_region(cd->devnum_genwqe, GENWQE_MAX_MINOR);\n err_dev:\n\tcd->dev = NULL;\n\treturn rc;\n}\n\nstatic int genwqe_inform_and_stop_processes(struct genwqe_dev *cd)\n{\n\tint rc;\n\tunsigned int i;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tif (!genwqe_open_files(cd))\n\t\treturn 0;\n\n\tdev_warn(&pci_dev->dev, \"[%s] send SIGIO and wait ...\\n\", __func__);\n\n\trc = genwqe_kill_fasync(cd, SIGIO);\n\tif (rc > 0) {\n\t\t \n\t\tfor (i = 0; (i < GENWQE_KILL_TIMEOUT) &&\n\t\t\t     genwqe_open_files(cd); i++) {\n\t\t\tdev_info(&pci_dev->dev, \"  %d sec ...\", i);\n\n\t\t\tcond_resched();\n\t\t\tmsleep(1000);\n\t\t}\n\n\t\t \n\t\tif (!genwqe_open_files(cd))\n\t\t\treturn 0;\n\n\t\tdev_warn(&pci_dev->dev,\n\t\t\t \"[%s] send SIGKILL and wait ...\\n\", __func__);\n\n\t\trc = genwqe_terminate(cd);\n\t\tif (rc) {\n\t\t\t \n\t\t\tfor (i = 0; (i < GENWQE_KILL_TIMEOUT) &&\n\t\t\t\t     genwqe_open_files(cd); i++) {\n\t\t\t\tdev_warn(&pci_dev->dev, \"  %d sec ...\", i);\n\n\t\t\t\tcond_resched();\n\t\t\t\tmsleep(1000);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint genwqe_device_remove(struct genwqe_dev *cd)\n{\n\tint rc;\n\tstruct pci_dev *pci_dev = cd->pci_dev;\n\n\tif (!genwqe_device_initialized(cd))\n\t\treturn 1;\n\n\tgenwqe_inform_and_stop_processes(cd);\n\n\t \n\trc = kref_read(&cd->cdev_genwqe.kobj.kref);\n\tif (rc != 1) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"[%s] err: cdev_genwqe...refcount=%d\\n\", __func__, rc);\n\t\tpanic(\"Fatal err: cannot free resources with pending references!\");\n\t}\n\n\tgenqwe_exit_debugfs(cd);\n\tdevice_destroy(cd->class_genwqe, cd->devnum_genwqe);\n\tcdev_del(&cd->cdev_genwqe);\n\tunregister_chrdev_region(cd->devnum_genwqe, GENWQE_MAX_MINOR);\n\tcd->dev = NULL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}