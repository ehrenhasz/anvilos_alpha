{
  "module_name": "ibmvmc.h",
  "hash_id": "853eb8f8edec5b1e0bc88036637d52531b8a627ad0a892b13454c8b304d094a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/ibmvmc.h",
  "human_readable_source": " \n \n#ifndef IBMVMC_H\n#define IBMVMC_H\n\n#include <linux/types.h>\n#include <linux/cdev.h>\n\n#include <asm/vio.h>\n\n#define IBMVMC_PROTOCOL_VERSION    0x0101\n\n#define MIN_BUF_POOL_SIZE 16\n#define MIN_HMCS          1\n#define MIN_MTU           4096\n#define MAX_BUF_POOL_SIZE 64\n#define MAX_HMCS          2\n#define MAX_MTU           (4 * 4096)\n#define DEFAULT_BUF_POOL_SIZE 32\n#define DEFAULT_HMCS          1\n#define DEFAULT_MTU           4096\n#define HMC_ID_LEN        32\n\n#define VMC_INVALID_BUFFER_ID 0xFFFF\n\n \n#define VMC_BASE\t     0xCC\n#define VMC_IOCTL_SETHMCID   _IOW(VMC_BASE, 0x00, unsigned char *)\n#define VMC_IOCTL_QUERY      _IOR(VMC_BASE, 0x01, struct ibmvmc_query_struct)\n#define VMC_IOCTL_REQUESTVMC _IOR(VMC_BASE, 0x02, u32)\n\n#define VMC_MSG_CAP          0x01\n#define VMC_MSG_CAP_RESP     0x81\n#define VMC_MSG_OPEN         0x02\n#define VMC_MSG_OPEN_RESP    0x82\n#define VMC_MSG_CLOSE        0x03\n#define VMC_MSG_CLOSE_RESP   0x83\n#define VMC_MSG_ADD_BUF      0x04\n#define VMC_MSG_ADD_BUF_RESP 0x84\n#define VMC_MSG_REM_BUF      0x05\n#define VMC_MSG_REM_BUF_RESP 0x85\n#define VMC_MSG_SIGNAL       0x06\n\n#define VMC_MSG_SUCCESS 0\n#define VMC_MSG_INVALID_HMC_INDEX 1\n#define VMC_MSG_INVALID_BUFFER_ID 2\n#define VMC_MSG_CLOSED_HMC        3\n#define VMC_MSG_INTERFACE_FAILURE 4\n#define VMC_MSG_NO_BUFFER         5\n\n#define VMC_BUF_OWNER_ALPHA 0\n#define VMC_BUF_OWNER_HV    1\n\nenum ibmvmc_states {\n\tibmvmc_state_sched_reset  = -1,\n\tibmvmc_state_initial      = 0,\n\tibmvmc_state_crqinit      = 1,\n\tibmvmc_state_capabilities = 2,\n\tibmvmc_state_ready        = 3,\n\tibmvmc_state_failed       = 4,\n};\n\nenum ibmhmc_states {\n\t \n\tibmhmc_state_free    = 0,\n\n\t \n\tibmhmc_state_initial = 1,\n\n\t \n\tibmhmc_state_opening = 2,\n\n\t \n\tibmhmc_state_ready   = 3,\n\n\t \n\tibmhmc_state_failed  = 4,\n};\n\nstruct ibmvmc_buffer {\n\tu8 valid;\t \n\tu8 free;\t \n\tu8 owner;\n\tu16 id;\n\tu32 size;\n\tu32 msg_len;\n\tdma_addr_t dma_addr_local;\n\tdma_addr_t dma_addr_remote;\n\tvoid *real_addr_local;\n};\n\nstruct ibmvmc_admin_crq_msg {\n\tu8 valid;\t \n\tu8 type;\t \n\tu8 status;\t \n\tu8 rsvd[2];\n\tu8 max_hmc;\t \n\t__be16 pool_size;\t \n\t__be32 max_mtu;\t\t \n\t__be16 crq_size;\t \n\t__be16 version;\t \n};\n\nstruct ibmvmc_crq_msg {\n\tu8 valid;      \n\tu8 type;       \n\tu8 status;     \n\tunion {\n\t\tu8 rsvd;   \n\t\tu8 owner;\n\t} var1;\n\tu8 hmc_session;\t \n\tu8 hmc_index;\t \n\tunion {\n\t\t__be16 rsvd;\n\t\t__be16 buffer_id;\n\t} var2;\n\t__be32 rsvd;\n\tunion {\n\t\t__be32 rsvd;\n\t\t__be32 lioba;\n\t\t__be32 msg_len;\n\t} var3;\n};\n\n \nstruct crq_queue {\n\tstruct ibmvmc_crq_msg *msgs;\n\tint size, cur;\n\tdma_addr_t msg_token;\n\tspinlock_t lock;\n};\n\n \nstruct crq_server_adapter {\n\tstruct device *dev;\n\tstruct crq_queue queue;\n\tu32 liobn;\n\tu32 riobn;\n\tstruct tasklet_struct work_task;\n\twait_queue_head_t reset_wait_queue;\n\tstruct task_struct *reset_task;\n};\n\n \nstruct ibmvmc_struct {\n\tu32 state;\n\tu32 max_mtu;\n\tu32 max_buffer_pool_size;\n\tu32 max_hmc_index;\n\tstruct crq_server_adapter *adapter;\n\tstruct cdev cdev;\n\tu32 vmc_drc_index;\n};\n\nstruct ibmvmc_file_session;\n\n \nstruct ibmvmc_hmc {\n\tu8 session;\n\tu8 index;\n\tu32 state;\n\tstruct crq_server_adapter *adapter;\n\tspinlock_t lock;\n\tunsigned char hmc_id[HMC_ID_LEN];\n\tstruct ibmvmc_buffer buffer[MAX_BUF_POOL_SIZE];\n\tunsigned short queue_outbound_msgs[MAX_BUF_POOL_SIZE];\n\tint queue_head, queue_tail;\n\tstruct ibmvmc_file_session *file_session;\n};\n\nstruct ibmvmc_file_session {\n\tstruct file *file;\n\tstruct ibmvmc_hmc *hmc;\n\tbool valid;\n};\n\nstruct ibmvmc_query_struct {\n\tint have_vmc;\n\tint state;\n\tint vmc_drc_index;\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}