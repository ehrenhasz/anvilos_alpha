{
  "module_name": "pvpanic-pci.c",
  "hash_id": "52f10876e72b34128ca347294dfeda3100efd66e7d713122dbc945c1a9bad63c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/pvpanic/pvpanic-pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n\n#include <uapi/misc/pvpanic.h>\n\n#include \"pvpanic.h\"\n\n#define PCI_VENDOR_ID_REDHAT             0x1b36\n#define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011\n\nMODULE_AUTHOR(\"Mihai Carabas <mihai.carabas@oracle.com>\");\nMODULE_DESCRIPTION(\"pvpanic device driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic ssize_t capability_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct pvpanic_instance *pi = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%x\\n\", pi->capability);\n}\nstatic DEVICE_ATTR_RO(capability);\n\nstatic ssize_t events_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct pvpanic_instance *pi = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%x\\n\", pi->events);\n}\n\nstatic ssize_t events_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct pvpanic_instance *pi = dev_get_drvdata(dev);\n\tunsigned int tmp;\n\tint err;\n\n\terr = kstrtouint(buf, 16, &tmp);\n\tif (err)\n\t\treturn err;\n\n\tif ((tmp & pi->capability) != tmp)\n\t\treturn -EINVAL;\n\n\tpi->events = tmp;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(events);\n\nstatic struct attribute *pvpanic_pci_dev_attrs[] = {\n\t&dev_attr_capability.attr,\n\t&dev_attr_events.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(pvpanic_pci_dev);\n\nstatic int pvpanic_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct pvpanic_instance *pi;\n\tvoid __iomem *base;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbase = pcim_iomap(pdev, 0, 0);\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tpi = devm_kmalloc(&pdev->dev, sizeof(*pi), GFP_KERNEL);\n\tif (!pi)\n\t\treturn -ENOMEM;\n\n\tpi->base = base;\n\tpi->capability = PVPANIC_PANICKED | PVPANIC_CRASH_LOADED;\n\n\t \n\tpi->capability &= ioread8(base);\n\tpi->events = pi->capability;\n\n\treturn devm_pvpanic_probe(&pdev->dev, pi);\n}\n\nstatic const struct pci_device_id pvpanic_pci_id_tbl[]  = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_REDHAT, PCI_DEVICE_ID_REDHAT_PVPANIC)},\n\t{}\n};\nMODULE_DEVICE_TABLE(pci, pvpanic_pci_id_tbl);\n\nstatic struct pci_driver pvpanic_pci_driver = {\n\t.name =         \"pvpanic-pci\",\n\t.id_table =     pvpanic_pci_id_tbl,\n\t.probe =        pvpanic_pci_probe,\n\t.driver = {\n\t\t.dev_groups = pvpanic_pci_dev_groups,\n\t},\n};\nmodule_pci_driver(pvpanic_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}