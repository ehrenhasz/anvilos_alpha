{
  "module_name": "pvpanic.c",
  "hash_id": "bf1044cc39eb32b40ca236fd4177330c5a8a485f6068d324813bd3e85fc0020d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/pvpanic/pvpanic.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kexec.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/panic_notifier.h>\n#include <linux/types.h>\n#include <linux/cdev.h>\n#include <linux/list.h>\n\n#include <uapi/misc/pvpanic.h>\n\n#include \"pvpanic.h\"\n\nMODULE_AUTHOR(\"Mihai Carabas <mihai.carabas@oracle.com>\");\nMODULE_DESCRIPTION(\"pvpanic device driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct list_head pvpanic_list;\nstatic spinlock_t pvpanic_lock;\n\nstatic void\npvpanic_send_event(unsigned int event)\n{\n\tstruct pvpanic_instance *pi_cur;\n\n\tif (!spin_trylock(&pvpanic_lock))\n\t\treturn;\n\n\tlist_for_each_entry(pi_cur, &pvpanic_list, list) {\n\t\tif (event & pi_cur->capability & pi_cur->events)\n\t\t\tiowrite8(event, pi_cur->base);\n\t}\n\tspin_unlock(&pvpanic_lock);\n}\n\nstatic int\npvpanic_panic_notify(struct notifier_block *nb, unsigned long code, void *unused)\n{\n\tunsigned int event = PVPANIC_PANICKED;\n\n\tif (kexec_crash_loaded())\n\t\tevent = PVPANIC_CRASH_LOADED;\n\n\tpvpanic_send_event(event);\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic struct notifier_block pvpanic_panic_nb = {\n\t.notifier_call = pvpanic_panic_notify,\n\t.priority = INT_MAX,\n};\n\nstatic void pvpanic_remove(void *param)\n{\n\tstruct pvpanic_instance *pi_cur, *pi_next;\n\tstruct pvpanic_instance *pi = param;\n\n\tspin_lock(&pvpanic_lock);\n\tlist_for_each_entry_safe(pi_cur, pi_next, &pvpanic_list, list) {\n\t\tif (pi_cur == pi) {\n\t\t\tlist_del(&pi_cur->list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&pvpanic_lock);\n}\n\nint devm_pvpanic_probe(struct device *dev, struct pvpanic_instance *pi)\n{\n\tif (!pi || !pi->base)\n\t\treturn -EINVAL;\n\n\tspin_lock(&pvpanic_lock);\n\tlist_add(&pi->list, &pvpanic_list);\n\tspin_unlock(&pvpanic_lock);\n\n\tdev_set_drvdata(dev, pi);\n\n\treturn devm_add_action_or_reset(dev, pvpanic_remove, pi);\n}\nEXPORT_SYMBOL_GPL(devm_pvpanic_probe);\n\nstatic int pvpanic_init(void)\n{\n\tINIT_LIST_HEAD(&pvpanic_list);\n\tspin_lock_init(&pvpanic_lock);\n\n\tatomic_notifier_chain_register(&panic_notifier_list, &pvpanic_panic_nb);\n\n\treturn 0;\n}\nmodule_init(pvpanic_init);\n\nstatic void pvpanic_exit(void)\n{\n\tatomic_notifier_chain_unregister(&panic_notifier_list, &pvpanic_panic_nb);\n\n}\nmodule_exit(pvpanic_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}