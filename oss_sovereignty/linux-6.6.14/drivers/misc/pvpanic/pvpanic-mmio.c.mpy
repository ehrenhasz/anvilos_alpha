{
  "module_name": "pvpanic-mmio.c",
  "hash_id": "7f1cea45f1fdabdd702073ce69b00c94802944b8c984514179a6b44c2ad82e53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/pvpanic/pvpanic-mmio.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kexec.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n\n#include <uapi/misc/pvpanic.h>\n\n#include \"pvpanic.h\"\n\nMODULE_AUTHOR(\"Hu Tao <hutao@cn.fujitsu.com>\");\nMODULE_DESCRIPTION(\"pvpanic-mmio device driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic ssize_t capability_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct pvpanic_instance *pi = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%x\\n\", pi->capability);\n}\nstatic DEVICE_ATTR_RO(capability);\n\nstatic ssize_t events_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct pvpanic_instance *pi = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%x\\n\", pi->events);\n}\n\nstatic ssize_t events_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct pvpanic_instance *pi = dev_get_drvdata(dev);\n\tunsigned int tmp;\n\tint err;\n\n\terr = kstrtouint(buf, 16, &tmp);\n\tif (err)\n\t\treturn err;\n\n\tif ((tmp & pi->capability) != tmp)\n\t\treturn -EINVAL;\n\n\tpi->events = tmp;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(events);\n\nstatic struct attribute *pvpanic_mmio_dev_attrs[] = {\n\t&dev_attr_capability.attr,\n\t&dev_attr_events.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(pvpanic_mmio_dev);\n\nstatic int pvpanic_mmio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pvpanic_instance *pi;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\n\tres = platform_get_mem_or_io(pdev, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tswitch (resource_type(res)) {\n\tcase IORESOURCE_IO:\n\t\tbase = devm_ioport_map(dev, res->start, resource_size(res));\n\t\tif (!base)\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase IORESOURCE_MEM:\n\t\tbase = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(base))\n\t\t\treturn PTR_ERR(base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpi = devm_kmalloc(dev, sizeof(*pi), GFP_KERNEL);\n\tif (!pi)\n\t\treturn -ENOMEM;\n\n\tpi->base = base;\n\tpi->capability = PVPANIC_PANICKED | PVPANIC_CRASH_LOADED;\n\n\t \n\tpi->capability &= ioread8(base);\n\tpi->events = pi->capability;\n\n\treturn devm_pvpanic_probe(dev, pi);\n}\n\nstatic const struct of_device_id pvpanic_mmio_match[] = {\n\t{ .compatible = \"qemu,pvpanic-mmio\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pvpanic_mmio_match);\n\nstatic const struct acpi_device_id pvpanic_device_ids[] = {\n\t{ \"QEMU0001\", 0 },\n\t{ \"\", 0 }\n};\nMODULE_DEVICE_TABLE(acpi, pvpanic_device_ids);\n\nstatic struct platform_driver pvpanic_mmio_driver = {\n\t.driver = {\n\t\t.name = \"pvpanic-mmio\",\n\t\t.of_match_table = pvpanic_mmio_match,\n\t\t.acpi_match_table = pvpanic_device_ids,\n\t\t.dev_groups = pvpanic_mmio_dev_groups,\n\t},\n\t.probe = pvpanic_mmio_probe,\n};\nmodule_platform_driver(pvpanic_mmio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}