{
  "module_name": "qcom-coincell.c",
  "hash_id": "070eb01ac8c9e1cf871fbc0926cfae3000fb9aad79c90336a8da172001c1ff7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/qcom-coincell.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/platform_device.h>\n\nstruct qcom_coincell {\n\tstruct device\t*dev;\n\tstruct regmap\t*regmap;\n\tu32\t\tbase_addr;\n};\n\n#define QCOM_COINCELL_REG_RSET\t\t0x44\n#define QCOM_COINCELL_REG_VSET\t\t0x45\n#define QCOM_COINCELL_REG_ENABLE\t0x46\n\n#define QCOM_COINCELL_ENABLE\t\tBIT(7)\n\nstatic const int qcom_rset_map[] = { 2100, 1700, 1200, 800 };\nstatic const int qcom_vset_map[] = { 2500, 3200, 3100, 3000 };\n \n\n \nstatic int qcom_coincell_chgr_config(struct qcom_coincell *chgr, int rset,\n\t\t\t\t     int vset, bool enable)\n{\n\tint i, j, rc;\n\n\t \n\tif (!enable)\n\t\treturn regmap_write(chgr->regmap,\n\t\t\t  chgr->base_addr + QCOM_COINCELL_REG_ENABLE, 0);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(qcom_rset_map); i++)\n\t\tif (rset == qcom_rset_map[i])\n\t\t\tbreak;\n\n\tif (i >= ARRAY_SIZE(qcom_rset_map)) {\n\t\tdev_err(chgr->dev, \"invalid rset-ohms value %d\\n\", rset);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (j = 0; j < ARRAY_SIZE(qcom_vset_map); j++)\n\t\tif (vset == qcom_vset_map[j])\n\t\t\tbreak;\n\n\tif (j >= ARRAY_SIZE(qcom_vset_map)) {\n\t\tdev_err(chgr->dev, \"invalid vset-millivolts value %d\\n\", vset);\n\t\treturn -EINVAL;\n\t}\n\n\trc = regmap_write(chgr->regmap,\n\t\t\t  chgr->base_addr + QCOM_COINCELL_REG_RSET, i);\n\tif (rc) {\n\t\t \n\t\tdev_err(chgr->dev, \"could not write to RSET register\\n\");\n\t\treturn rc;\n\t}\n\n\trc = regmap_write(chgr->regmap,\n\t\tchgr->base_addr + QCOM_COINCELL_REG_VSET, j);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treturn regmap_write(chgr->regmap,\n\t\t\t    chgr->base_addr + QCOM_COINCELL_REG_ENABLE,\n\t\t\t    QCOM_COINCELL_ENABLE);\n}\n\nstatic int qcom_coincell_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct qcom_coincell chgr;\n\tu32 rset = 0;\n\tu32 vset = 0;\n\tbool enable;\n\tint rc;\n\n\tchgr.dev = &pdev->dev;\n\n\tchgr.regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!chgr.regmap) {\n\t\tdev_err(chgr.dev, \"Unable to get regmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = of_property_read_u32(node, \"reg\", &chgr.base_addr);\n\tif (rc)\n\t\treturn rc;\n\n\tenable = !of_property_read_bool(node, \"qcom,charger-disable\");\n\n\tif (enable) {\n\t\trc = of_property_read_u32(node, \"qcom,rset-ohms\", &rset);\n\t\tif (rc) {\n\t\t\tdev_err(chgr.dev,\n\t\t\t\t\"can't find 'qcom,rset-ohms' in DT block\");\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = of_property_read_u32(node, \"qcom,vset-millivolts\", &vset);\n\t\tif (rc) {\n\t\t\tdev_err(chgr.dev,\n\t\t\t    \"can't find 'qcom,vset-millivolts' in DT block\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn qcom_coincell_chgr_config(&chgr, rset, vset, enable);\n}\n\nstatic const struct of_device_id qcom_coincell_match_table[] = {\n\t{ .compatible = \"qcom,pm8941-coincell\", },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, qcom_coincell_match_table);\n\nstatic struct platform_driver qcom_coincell_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"qcom-spmi-coincell\",\n\t\t.of_match_table\t= qcom_coincell_match_table,\n\t},\n\t.probe\t\t= qcom_coincell_probe,\n};\n\nmodule_platform_driver(qcom_coincell_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm PMIC coincell charger driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}