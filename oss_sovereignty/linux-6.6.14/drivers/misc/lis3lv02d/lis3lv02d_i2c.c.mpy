{
  "module_name": "lis3lv02d_i2c.c",
  "hash_id": "9e81af801a9494d5e29ace0016d4581a198c8542096fa5b7f978ce8a7a1e1e6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/lis3lv02d/lis3lv02d_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/pm_runtime.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_device.h>\n\n#include \"lis3lv02d.h\"\n\n#define DRV_NAME\t\"lis3lv02d_i2c\"\n\nstatic const char reg_vdd[]    = \"Vdd\";\nstatic const char reg_vdd_io[] = \"Vdd_IO\";\n\nstatic int lis3_reg_ctrl(struct lis3lv02d *lis3, bool state)\n{\n\tint ret;\n\tif (state == LIS3_REG_OFF) {\n\t\tret = regulator_bulk_disable(ARRAY_SIZE(lis3->regulators),\n\t\t\t\t\tlis3->regulators);\n\t} else {\n\t\tret = regulator_bulk_enable(ARRAY_SIZE(lis3->regulators),\n\t\t\t\t\tlis3->regulators);\n\t\t \n\t\tusleep_range(10000, 20000);\n\t}\n\treturn ret;\n}\n\nstatic inline s32 lis3_i2c_write(struct lis3lv02d *lis3, int reg, u8 value)\n{\n\tstruct i2c_client *c = lis3->bus_priv;\n\treturn i2c_smbus_write_byte_data(c, reg, value);\n}\n\nstatic inline s32 lis3_i2c_read(struct lis3lv02d *lis3, int reg, u8 *v)\n{\n\tstruct i2c_client *c = lis3->bus_priv;\n\t*v = i2c_smbus_read_byte_data(c, reg);\n\treturn 0;\n}\n\nstatic inline s32 lis3_i2c_blockread(struct lis3lv02d *lis3, int reg, int len,\n\t\t\t\tu8 *v)\n{\n\tstruct i2c_client *c = lis3->bus_priv;\n\treg |= (1 << 7);  \n\treturn i2c_smbus_read_i2c_block_data(c, reg, len, v);\n}\n\nstatic int lis3_i2c_init(struct lis3lv02d *lis3)\n{\n\tu8 reg;\n\tint ret;\n\n\tlis3_reg_ctrl(lis3, LIS3_REG_ON);\n\n\tlis3->read(lis3, WHO_AM_I, &reg);\n\tif (reg != lis3->whoami)\n\t\tprintk(KERN_ERR \"lis3: power on failure\\n\");\n\n\t \n\tret = lis3->read(lis3, CTRL_REG1, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (lis3->whoami == WAI_3DLH)\n\t\treg |= CTRL1_PM0 | CTRL1_Xen | CTRL1_Yen | CTRL1_Zen;\n\telse\n\t\treg |= CTRL1_PD0 | CTRL1_Xen | CTRL1_Yen | CTRL1_Zen;\n\n\treturn lis3->write(lis3, CTRL_REG1, reg);\n}\n\n \nstatic union axis_conversion lis3lv02d_axis_map =\n\t{ .as_array = { LIS3_DEV_X, LIS3_DEV_Y, LIS3_DEV_Z } };\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id lis3lv02d_i2c_dt_ids[] = {\n\t{ .compatible = \"st,lis3lv02d\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lis3lv02d_i2c_dt_ids);\n#endif\n\nstatic int lis3lv02d_i2c_probe(struct i2c_client *client)\n{\n\tint ret = 0;\n\tstruct lis3lv02d_platform_data *pdata = client->dev.platform_data;\n\n#ifdef CONFIG_OF\n\tif (of_match_device(lis3lv02d_i2c_dt_ids, &client->dev)) {\n\t\tlis3_dev.of_node = client->dev.of_node;\n\t\tret = lis3lv02d_init_dt(&lis3_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpdata = lis3_dev.pdata;\n\t}\n#endif\n\n\tif (pdata) {\n\t\tif ((pdata->driver_features & LIS3_USE_BLOCK_READ) &&\n\t\t\t(i2c_check_functionality(client->adapter,\n\t\t\t\t\t\tI2C_FUNC_SMBUS_I2C_BLOCK)))\n\t\t\tlis3_dev.blkread  = lis3_i2c_blockread;\n\n\t\tif (pdata->axis_x)\n\t\t\tlis3lv02d_axis_map.x = pdata->axis_x;\n\n\t\tif (pdata->axis_y)\n\t\t\tlis3lv02d_axis_map.y = pdata->axis_y;\n\n\t\tif (pdata->axis_z)\n\t\t\tlis3lv02d_axis_map.z = pdata->axis_z;\n\n\t\tif (pdata->setup_resources)\n\t\t\tret = pdata->setup_resources();\n\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tlis3_dev.regulators[0].supply = reg_vdd;\n\tlis3_dev.regulators[1].supply = reg_vdd_io;\n\tret = regulator_bulk_get(&client->dev,\n\t\t\t\t ARRAY_SIZE(lis3_dev.regulators),\n\t\t\t\t lis3_dev.regulators);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tlis3_dev.pdata\t  = pdata;\n\tlis3_dev.bus_priv = client;\n\tlis3_dev.init\t  = lis3_i2c_init;\n\tlis3_dev.read\t  = lis3_i2c_read;\n\tlis3_dev.write\t  = lis3_i2c_write;\n\tlis3_dev.irq\t  = client->irq;\n\tlis3_dev.ac\t  = lis3lv02d_axis_map;\n\tlis3_dev.pm_dev\t  = &client->dev;\n\n\ti2c_set_clientdata(client, &lis3_dev);\n\n\t \n\tlis3_reg_ctrl(&lis3_dev, LIS3_REG_ON);\n\n\tret = lis3lv02d_init_device(&lis3_dev);\n\n\tlis3_reg_ctrl(&lis3_dev, LIS3_REG_OFF);\n\n\tif (ret)\n\t\tgoto fail2;\n\treturn 0;\n\nfail2:\n\tregulator_bulk_free(ARRAY_SIZE(lis3_dev.regulators),\n\t\t\t\tlis3_dev.regulators);\nfail:\n\tif (pdata && pdata->release_resources)\n\t\tpdata->release_resources();\n\treturn ret;\n}\n\nstatic void lis3lv02d_i2c_remove(struct i2c_client *client)\n{\n\tstruct lis3lv02d *lis3 = i2c_get_clientdata(client);\n\tstruct lis3lv02d_platform_data *pdata = client->dev.platform_data;\n\n\tif (pdata && pdata->release_resources)\n\t\tpdata->release_resources();\n\n\tlis3lv02d_joystick_disable(lis3);\n\tlis3lv02d_remove_fs(&lis3_dev);\n\n\tregulator_bulk_free(ARRAY_SIZE(lis3->regulators),\n\t\t\t    lis3_dev.regulators);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int lis3lv02d_i2c_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct lis3lv02d *lis3 = i2c_get_clientdata(client);\n\n\tif (!lis3->pdata || !lis3->pdata->wakeup_flags)\n\t\tlis3lv02d_poweroff(lis3);\n\treturn 0;\n}\n\nstatic int lis3lv02d_i2c_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct lis3lv02d *lis3 = i2c_get_clientdata(client);\n\n\t \n\tif (!lis3->pdata || !lis3->pdata->wakeup_flags ||\n\t\tpm_runtime_suspended(dev))\n\t\tlis3lv02d_poweron(lis3);\n\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int lis3_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct lis3lv02d *lis3 = i2c_get_clientdata(client);\n\n\tlis3lv02d_poweroff(lis3);\n\treturn 0;\n}\n\nstatic int lis3_i2c_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct lis3lv02d *lis3 = i2c_get_clientdata(client);\n\n\tlis3lv02d_poweron(lis3);\n\treturn 0;\n}\n#endif  \n\nstatic const struct i2c_device_id lis3lv02d_id[] = {\n\t{\"lis3lv02d\", LIS3LV02D},\n\t{\"lis331dlh\", LIS331DLH},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, lis3lv02d_id);\n\nstatic const struct dev_pm_ops lis3_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(lis3lv02d_i2c_suspend,\n\t\t\t\tlis3lv02d_i2c_resume)\n\tSET_RUNTIME_PM_OPS(lis3_i2c_runtime_suspend,\n\t\t\t   lis3_i2c_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct i2c_driver lis3lv02d_i2c_driver = {\n\t.driver\t = {\n\t\t.name   = DRV_NAME,\n\t\t.pm     = &lis3_pm_ops,\n\t\t.of_match_table = of_match_ptr(lis3lv02d_i2c_dt_ids),\n\t},\n\t.probe = lis3lv02d_i2c_probe,\n\t.remove\t= lis3lv02d_i2c_remove,\n\t.id_table = lis3lv02d_id,\n};\n\nmodule_i2c_driver(lis3lv02d_i2c_driver);\n\nMODULE_AUTHOR(\"Nokia Corporation\");\nMODULE_DESCRIPTION(\"lis3lv02d I2C interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}