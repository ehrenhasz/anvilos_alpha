{
  "module_name": "lis3lv02d.c",
  "hash_id": "748d019548efbef31c15cf025b311856ec8ce29a4a67aa7caea17b73732ab912",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/lis3lv02d/lis3lv02d.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/dmi.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/miscdevice.h>\n#include <linux/pm_runtime.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include \"lis3lv02d.h\"\n\n#define DRIVER_NAME     \"lis3lv02d\"\n\n \n#define MDPS_POLL_INTERVAL 50\n#define MDPS_POLL_MIN\t   0\n#define MDPS_POLL_MAX\t   2000\n\n#define LIS3_SYSFS_POWERDOWN_DELAY 5000  \n\n#define SELFTEST_OK\t       0\n#define SELFTEST_FAIL\t       -1\n#define SELFTEST_IRQ\t       -2\n\n#define IRQ_LINE0\t       0\n#define IRQ_LINE1\t       1\n\n \n\n#define LIS3_PWRON_DELAY_WAI_12B\t(5000)\n#define LIS3_PWRON_DELAY_WAI_8B\t\t(3000)\n\n \n#define LIS3_ACCURACY\t\t\t1024\n \n#define LIS3_SENSITIVITY_12B\t\t((LIS3_ACCURACY * 1000) / 1024)\n#define LIS3_SENSITIVITY_8B\t\t(18 * LIS3_ACCURACY)\n\n \n#define LIS3DLH_SENSITIVITY_2G\t\t((LIS3_ACCURACY * 1000) / 1024)\n#define SHIFT_ADJ_2G\t\t\t4\n\n#define LIS3_DEFAULT_FUZZ_12B\t\t3\n#define LIS3_DEFAULT_FLAT_12B\t\t3\n#define LIS3_DEFAULT_FUZZ_8B\t\t1\n#define LIS3_DEFAULT_FLAT_8B\t\t1\n\nstruct lis3lv02d lis3_dev = {\n\t.misc_wait   = __WAIT_QUEUE_HEAD_INITIALIZER(lis3_dev.misc_wait),\n};\nEXPORT_SYMBOL_GPL(lis3_dev);\n\n \nstatic int param_set_axis(const char *val, const struct kernel_param *kp)\n{\n\tint ret = param_set_int(val, kp);\n\tif (!ret) {\n\t\tint val = *(int *)kp->arg;\n\t\tif (val < 0)\n\t\t\tval = -val;\n\t\tif (!val || val > 3)\n\t\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic const struct kernel_param_ops param_ops_axis = {\n\t.set = param_set_axis,\n\t.get = param_get_int,\n};\n\n#define param_check_axis(name, p) param_check_int(name, p)\n\nmodule_param_array_named(axes, lis3_dev.ac.as_array, axis, NULL, 0644);\nMODULE_PARM_DESC(axes, \"Axis-mapping for x,y,z directions\");\n\nstatic s16 lis3lv02d_read_8(struct lis3lv02d *lis3, int reg)\n{\n\ts8 lo;\n\tif (lis3->read(lis3, reg, &lo) < 0)\n\t\treturn 0;\n\n\treturn lo;\n}\n\nstatic s16 lis3lv02d_read_12(struct lis3lv02d *lis3, int reg)\n{\n\tu8 lo, hi;\n\n\tlis3->read(lis3, reg - 1, &lo);\n\tlis3->read(lis3, reg, &hi);\n\t \n\treturn (s16)((hi << 8) | lo);\n}\n\n \nstatic s16 lis331dlh_read_data(struct lis3lv02d *lis3, int reg)\n{\n\tu8 lo, hi;\n\tint v;\n\n\tlis3->read(lis3, reg - 1, &lo);\n\tlis3->read(lis3, reg, &hi);\n\tv = (int) ((hi << 8) | lo);\n\n\treturn (s16) v >> lis3->shift_adj;\n}\n\n \nstatic inline int lis3lv02d_get_axis(s8 axis, int hw_values[3])\n{\n\tif (axis > 0)\n\t\treturn hw_values[axis - 1];\n\telse\n\t\treturn -hw_values[-axis - 1];\n}\n\n \nstatic void lis3lv02d_get_xyz(struct lis3lv02d *lis3, int *x, int *y, int *z)\n{\n\tint position[3];\n\tint i;\n\n\tif (lis3->blkread) {\n\t\tif (lis3->whoami == WAI_12B) {\n\t\t\tu16 data[3];\n\t\t\tlis3->blkread(lis3, OUTX_L, 6, (u8 *)data);\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tposition[i] = (s16)le16_to_cpu(data[i]);\n\t\t} else {\n\t\t\tu8 data[5];\n\t\t\t \n\t\t\tlis3->blkread(lis3, OUTX, 5, data);\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tposition[i] = (s8)data[i * 2];\n\t\t}\n\t} else {\n\t\tposition[0] = lis3->read_data(lis3, OUTX);\n\t\tposition[1] = lis3->read_data(lis3, OUTY);\n\t\tposition[2] = lis3->read_data(lis3, OUTZ);\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t\tposition[i] = (position[i] * lis3->scale) / LIS3_ACCURACY;\n\n\t*x = lis3lv02d_get_axis(lis3->ac.x, position);\n\t*y = lis3lv02d_get_axis(lis3->ac.y, position);\n\t*z = lis3lv02d_get_axis(lis3->ac.z, position);\n}\n\n \nstatic int lis3_12_rates[4] = {40, 160, 640, 2560};\nstatic int lis3_8_rates[2] = {100, 400};\nstatic int lis3_3dc_rates[16] = {0, 1, 10, 25, 50, 100, 200, 400, 1600, 5000};\nstatic int lis3_3dlh_rates[4] = {50, 100, 400, 1000};\n\n \nstatic int lis3lv02d_get_odr_index(struct lis3lv02d *lis3)\n{\n\tu8 ctrl;\n\tint shift;\n\n\tlis3->read(lis3, CTRL_REG1, &ctrl);\n\tctrl &= lis3->odr_mask;\n\tshift = ffs(lis3->odr_mask) - 1;\n\treturn (ctrl >> shift);\n}\n\nstatic int lis3lv02d_get_pwron_wait(struct lis3lv02d *lis3)\n{\n\tint odr_idx = lis3lv02d_get_odr_index(lis3);\n\tint div = lis3->odrs[odr_idx];\n\n\tif (div == 0) {\n\t\tif (odr_idx == 0) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_err(&lis3->pdev->dev, \"Error unknown odrs-index: %d\\n\", odr_idx);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tmsleep(lis3->pwron_delay / div);\n\treturn 0;\n}\n\nstatic int lis3lv02d_set_odr(struct lis3lv02d *lis3, int rate)\n{\n\tu8 ctrl;\n\tint i, len, shift;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\tlis3->read(lis3, CTRL_REG1, &ctrl);\n\tctrl &= ~lis3->odr_mask;\n\tlen = 1 << hweight_long(lis3->odr_mask);  \n\tshift = ffs(lis3->odr_mask) - 1;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (lis3->odrs[i] == rate) {\n\t\t\tlis3->write(lis3, CTRL_REG1,\n\t\t\t\t\tctrl | (i << shift));\n\t\t\treturn 0;\n\t\t}\n\treturn -EINVAL;\n}\n\nstatic int lis3lv02d_selftest(struct lis3lv02d *lis3, s16 results[3])\n{\n\tu8 ctlreg, reg;\n\ts16 x, y, z;\n\tu8 selftest;\n\tint ret;\n\tu8 ctrl_reg_data;\n\tunsigned char irq_cfg;\n\n\tmutex_lock(&lis3->mutex);\n\n\tirq_cfg = lis3->irq_cfg;\n\tif (lis3->whoami == WAI_8B) {\n\t\tlis3->data_ready_count[IRQ_LINE0] = 0;\n\t\tlis3->data_ready_count[IRQ_LINE1] = 0;\n\n\t\t \n\t\tatomic_inc(&lis3->wake_thread);\n\t\tlis3->irq_cfg = LIS3_IRQ1_DATA_READY | LIS3_IRQ2_DATA_READY;\n\t\tlis3->read(lis3, CTRL_REG3, &ctrl_reg_data);\n\t\tlis3->write(lis3, CTRL_REG3, (ctrl_reg_data &\n\t\t\t\t~(LIS3_IRQ1_MASK | LIS3_IRQ2_MASK)) |\n\t\t\t\t(LIS3_IRQ1_DATA_READY | LIS3_IRQ2_DATA_READY));\n\t}\n\n\tif ((lis3->whoami == WAI_3DC) || (lis3->whoami == WAI_3DLH)) {\n\t\tctlreg = CTRL_REG4;\n\t\tselftest = CTRL4_ST0;\n\t} else {\n\t\tctlreg = CTRL_REG1;\n\t\tif (lis3->whoami == WAI_12B)\n\t\t\tselftest = CTRL1_ST;\n\t\telse\n\t\t\tselftest = CTRL1_STP;\n\t}\n\n\tlis3->read(lis3, ctlreg, &reg);\n\tlis3->write(lis3, ctlreg, (reg | selftest));\n\tret = lis3lv02d_get_pwron_wait(lis3);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tx = lis3->read_data(lis3, OUTX);\n\ty = lis3->read_data(lis3, OUTY);\n\tz = lis3->read_data(lis3, OUTZ);\n\n\t \n\tlis3->write(lis3, ctlreg, reg);\n\tret = lis3lv02d_get_pwron_wait(lis3);\n\tif (ret)\n\t\tgoto fail;\n\n\tresults[0] = x - lis3->read_data(lis3, OUTX);\n\tresults[1] = y - lis3->read_data(lis3, OUTY);\n\tresults[2] = z - lis3->read_data(lis3, OUTZ);\n\n\tret = 0;\n\n\tif (lis3->whoami == WAI_8B) {\n\t\t \n\t\tatomic_dec(&lis3->wake_thread);\n\t\tlis3->write(lis3, CTRL_REG3, ctrl_reg_data);\n\t\tlis3->irq_cfg = irq_cfg;\n\n\t\tif ((irq_cfg & LIS3_IRQ1_MASK) &&\n\t\t\tlis3->data_ready_count[IRQ_LINE0] < 2) {\n\t\t\tret = SELFTEST_IRQ;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif ((irq_cfg & LIS3_IRQ2_MASK) &&\n\t\t\tlis3->data_ready_count[IRQ_LINE1] < 2) {\n\t\t\tret = SELFTEST_IRQ;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (lis3->pdata) {\n\t\tint i;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\t \n\t\t\tif ((results[i] < lis3->pdata->st_min_limits[i]) ||\n\t\t\t    (results[i] > lis3->pdata->st_max_limits[i])) {\n\t\t\t\tret = SELFTEST_FAIL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\t \nfail:\n\tmutex_unlock(&lis3->mutex);\n\treturn ret;\n}\n\n \nstatic u8 lis3_wai8_regs[] = { FF_WU_CFG_1, FF_WU_THS_1, FF_WU_DURATION_1,\n\t\t\t       FF_WU_CFG_2, FF_WU_THS_2, FF_WU_DURATION_2,\n\t\t\t       CLICK_CFG, CLICK_SRC, CLICK_THSY_X, CLICK_THSZ,\n\t\t\t       CLICK_TIMELIMIT, CLICK_LATENCY, CLICK_WINDOW,\n\t\t\t       CTRL_REG1, CTRL_REG2, CTRL_REG3};\n\nstatic u8 lis3_wai12_regs[] = {FF_WU_CFG, FF_WU_THS_L, FF_WU_THS_H,\n\t\t\t       FF_WU_DURATION, DD_CFG, DD_THSI_L, DD_THSI_H,\n\t\t\t       DD_THSE_L, DD_THSE_H,\n\t\t\t       CTRL_REG1, CTRL_REG3, CTRL_REG2};\n\nstatic inline void lis3_context_save(struct lis3lv02d *lis3)\n{\n\tint i;\n\tfor (i = 0; i < lis3->regs_size; i++)\n\t\tlis3->read(lis3, lis3->regs[i], &lis3->reg_cache[i]);\n\tlis3->regs_stored = true;\n}\n\nstatic inline void lis3_context_restore(struct lis3lv02d *lis3)\n{\n\tint i;\n\tif (lis3->regs_stored)\n\t\tfor (i = 0; i < lis3->regs_size; i++)\n\t\t\tlis3->write(lis3, lis3->regs[i], lis3->reg_cache[i]);\n}\n\nvoid lis3lv02d_poweroff(struct lis3lv02d *lis3)\n{\n\tif (lis3->reg_ctrl)\n\t\tlis3_context_save(lis3);\n\t \n\tlis3->write(lis3, CTRL_REG1, 0x00);\n\tif (lis3->reg_ctrl)\n\t\tlis3->reg_ctrl(lis3, LIS3_REG_OFF);\n}\nEXPORT_SYMBOL_GPL(lis3lv02d_poweroff);\n\nint lis3lv02d_poweron(struct lis3lv02d *lis3)\n{\n\tint err;\n\tu8 reg;\n\n\tlis3->init(lis3);\n\n\t \n\tif (lis3->pdata) {\n\t\tlis3->read(lis3, CTRL_REG2, &reg);\n\t\tif (lis3->whoami ==  WAI_12B)\n\t\t\treg |= CTRL2_BDU | CTRL2_BOOT;\n\t\telse if (lis3->whoami ==  WAI_3DLH)\n\t\t\treg |= CTRL2_BOOT_3DLH;\n\t\telse\n\t\t\treg |= CTRL2_BOOT_8B;\n\t\tlis3->write(lis3, CTRL_REG2, reg);\n\n\t\tif (lis3->whoami ==  WAI_3DLH) {\n\t\t\tlis3->read(lis3, CTRL_REG4, &reg);\n\t\t\treg |= CTRL4_BDU;\n\t\t\tlis3->write(lis3, CTRL_REG4, reg);\n\t\t}\n\t}\n\n\terr = lis3lv02d_get_pwron_wait(lis3);\n\tif (err)\n\t\treturn err;\n\n\tif (lis3->reg_ctrl)\n\t\tlis3_context_restore(lis3);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lis3lv02d_poweron);\n\n\nstatic void lis3lv02d_joystick_poll(struct input_dev *input)\n{\n\tstruct lis3lv02d *lis3 = input_get_drvdata(input);\n\tint x, y, z;\n\n\tmutex_lock(&lis3->mutex);\n\tlis3lv02d_get_xyz(lis3, &x, &y, &z);\n\tinput_report_abs(input, ABS_X, x);\n\tinput_report_abs(input, ABS_Y, y);\n\tinput_report_abs(input, ABS_Z, z);\n\tinput_sync(input);\n\tmutex_unlock(&lis3->mutex);\n}\n\nstatic int lis3lv02d_joystick_open(struct input_dev *input)\n{\n\tstruct lis3lv02d *lis3 = input_get_drvdata(input);\n\n\tif (lis3->pm_dev)\n\t\tpm_runtime_get_sync(lis3->pm_dev);\n\n\tif (lis3->pdata && lis3->whoami == WAI_8B && lis3->idev)\n\t\tatomic_set(&lis3->wake_thread, 1);\n\t \n\tlis3lv02d_joystick_poll(input);\n\n\treturn 0;\n}\n\nstatic void lis3lv02d_joystick_close(struct input_dev *input)\n{\n\tstruct lis3lv02d *lis3 = input_get_drvdata(input);\n\n\tatomic_set(&lis3->wake_thread, 0);\n\tif (lis3->pm_dev)\n\t\tpm_runtime_put(lis3->pm_dev);\n}\n\nstatic irqreturn_t lis302dl_interrupt(int irq, void *data)\n{\n\tstruct lis3lv02d *lis3 = data;\n\n\tif (!test_bit(0, &lis3->misc_opened))\n\t\tgoto out;\n\n\t \n\tatomic_inc(&lis3->count);\n\n\twake_up_interruptible(&lis3->misc_wait);\n\tkill_fasync(&lis3->async_queue, SIGIO, POLL_IN);\nout:\n\tif (atomic_read(&lis3->wake_thread))\n\t\treturn IRQ_WAKE_THREAD;\n\treturn IRQ_HANDLED;\n}\n\nstatic void lis302dl_interrupt_handle_click(struct lis3lv02d *lis3)\n{\n\tstruct input_dev *dev = lis3->idev;\n\tu8 click_src;\n\n\tmutex_lock(&lis3->mutex);\n\tlis3->read(lis3, CLICK_SRC, &click_src);\n\n\tif (click_src & CLICK_SINGLE_X) {\n\t\tinput_report_key(dev, lis3->mapped_btns[0], 1);\n\t\tinput_report_key(dev, lis3->mapped_btns[0], 0);\n\t}\n\n\tif (click_src & CLICK_SINGLE_Y) {\n\t\tinput_report_key(dev, lis3->mapped_btns[1], 1);\n\t\tinput_report_key(dev, lis3->mapped_btns[1], 0);\n\t}\n\n\tif (click_src & CLICK_SINGLE_Z) {\n\t\tinput_report_key(dev, lis3->mapped_btns[2], 1);\n\t\tinput_report_key(dev, lis3->mapped_btns[2], 0);\n\t}\n\tinput_sync(dev);\n\tmutex_unlock(&lis3->mutex);\n}\n\nstatic inline void lis302dl_data_ready(struct lis3lv02d *lis3, int index)\n{\n\tint dummy;\n\n\t \n\tlis3lv02d_get_xyz(lis3, &dummy, &dummy, &dummy);\n\tlis3->data_ready_count[index]++;\n}\n\nstatic irqreturn_t lis302dl_interrupt_thread1_8b(int irq, void *data)\n{\n\tstruct lis3lv02d *lis3 = data;\n\tu8 irq_cfg = lis3->irq_cfg & LIS3_IRQ1_MASK;\n\n\tif (irq_cfg == LIS3_IRQ1_CLICK)\n\t\tlis302dl_interrupt_handle_click(lis3);\n\telse if (unlikely(irq_cfg == LIS3_IRQ1_DATA_READY))\n\t\tlis302dl_data_ready(lis3, IRQ_LINE0);\n\telse\n\t\tlis3lv02d_joystick_poll(lis3->idev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t lis302dl_interrupt_thread2_8b(int irq, void *data)\n{\n\tstruct lis3lv02d *lis3 = data;\n\tu8 irq_cfg = lis3->irq_cfg & LIS3_IRQ2_MASK;\n\n\tif (irq_cfg == LIS3_IRQ2_CLICK)\n\t\tlis302dl_interrupt_handle_click(lis3);\n\telse if (unlikely(irq_cfg == LIS3_IRQ2_DATA_READY))\n\t\tlis302dl_data_ready(lis3, IRQ_LINE1);\n\telse\n\t\tlis3lv02d_joystick_poll(lis3->idev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int lis3lv02d_misc_open(struct inode *inode, struct file *file)\n{\n\tstruct lis3lv02d *lis3 = container_of(file->private_data,\n\t\t\t\t\t      struct lis3lv02d, miscdev);\n\n\tif (test_and_set_bit(0, &lis3->misc_opened))\n\t\treturn -EBUSY;  \n\n\tif (lis3->pm_dev)\n\t\tpm_runtime_get_sync(lis3->pm_dev);\n\n\tatomic_set(&lis3->count, 0);\n\treturn 0;\n}\n\nstatic int lis3lv02d_misc_release(struct inode *inode, struct file *file)\n{\n\tstruct lis3lv02d *lis3 = container_of(file->private_data,\n\t\t\t\t\t      struct lis3lv02d, miscdev);\n\n\tclear_bit(0, &lis3->misc_opened);  \n\tif (lis3->pm_dev)\n\t\tpm_runtime_put(lis3->pm_dev);\n\treturn 0;\n}\n\nstatic ssize_t lis3lv02d_misc_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *pos)\n{\n\tstruct lis3lv02d *lis3 = container_of(file->private_data,\n\t\t\t\t\t      struct lis3lv02d, miscdev);\n\n\tDECLARE_WAITQUEUE(wait, current);\n\tu32 data;\n\tunsigned char byte_data;\n\tssize_t retval = 1;\n\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\tadd_wait_queue(&lis3->misc_wait, &wait);\n\twhile (true) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tdata = atomic_xchg(&lis3->count, 0);\n\t\tif (data)\n\t\t\tbreak;\n\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tschedule();\n\t}\n\n\tif (data < 255)\n\t\tbyte_data = data;\n\telse\n\t\tbyte_data = 255;\n\n\t \n\tset_current_state(TASK_RUNNING);\n\tif (copy_to_user(buf, &byte_data, sizeof(byte_data)))\n\t\tretval = -EFAULT;\n\nout:\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&lis3->misc_wait, &wait);\n\n\treturn retval;\n}\n\nstatic __poll_t lis3lv02d_misc_poll(struct file *file, poll_table *wait)\n{\n\tstruct lis3lv02d *lis3 = container_of(file->private_data,\n\t\t\t\t\t      struct lis3lv02d, miscdev);\n\n\tpoll_wait(file, &lis3->misc_wait, wait);\n\tif (atomic_read(&lis3->count))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n\nstatic int lis3lv02d_misc_fasync(int fd, struct file *file, int on)\n{\n\tstruct lis3lv02d *lis3 = container_of(file->private_data,\n\t\t\t\t\t      struct lis3lv02d, miscdev);\n\n\treturn fasync_helper(fd, file, on, &lis3->async_queue);\n}\n\nstatic const struct file_operations lis3lv02d_misc_fops = {\n\t.owner   = THIS_MODULE,\n\t.llseek  = no_llseek,\n\t.read    = lis3lv02d_misc_read,\n\t.open    = lis3lv02d_misc_open,\n\t.release = lis3lv02d_misc_release,\n\t.poll    = lis3lv02d_misc_poll,\n\t.fasync  = lis3lv02d_misc_fasync,\n};\n\nint lis3lv02d_joystick_enable(struct lis3lv02d *lis3)\n{\n\tstruct input_dev *input_dev;\n\tint err;\n\tint max_val, fuzz, flat;\n\tint btns[] = {BTN_X, BTN_Y, BTN_Z};\n\n\tif (lis3->idev)\n\t\treturn -EINVAL;\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tinput_dev->name       = \"ST LIS3LV02DL Accelerometer\";\n\tinput_dev->phys       = DRIVER_NAME \"/input0\";\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->id.vendor  = 0;\n\tinput_dev->dev.parent = &lis3->pdev->dev;\n\n\tinput_dev->open = lis3lv02d_joystick_open;\n\tinput_dev->close = lis3lv02d_joystick_close;\n\n\tmax_val = (lis3->mdps_max_val * lis3->scale) / LIS3_ACCURACY;\n\tif (lis3->whoami == WAI_12B) {\n\t\tfuzz = LIS3_DEFAULT_FUZZ_12B;\n\t\tflat = LIS3_DEFAULT_FLAT_12B;\n\t} else {\n\t\tfuzz = LIS3_DEFAULT_FUZZ_8B;\n\t\tflat = LIS3_DEFAULT_FLAT_8B;\n\t}\n\tfuzz = (fuzz * lis3->scale) / LIS3_ACCURACY;\n\tflat = (flat * lis3->scale) / LIS3_ACCURACY;\n\n\tinput_set_abs_params(input_dev, ABS_X, -max_val, max_val, fuzz, flat);\n\tinput_set_abs_params(input_dev, ABS_Y, -max_val, max_val, fuzz, flat);\n\tinput_set_abs_params(input_dev, ABS_Z, -max_val, max_val, fuzz, flat);\n\n\tinput_set_drvdata(input_dev, lis3);\n\tlis3->idev = input_dev;\n\n\terr = input_setup_polling(input_dev, lis3lv02d_joystick_poll);\n\tif (err)\n\t\tgoto err_free_input;\n\n\tinput_set_poll_interval(input_dev, MDPS_POLL_INTERVAL);\n\tinput_set_min_poll_interval(input_dev, MDPS_POLL_MIN);\n\tinput_set_max_poll_interval(input_dev, MDPS_POLL_MAX);\n\n\tlis3->mapped_btns[0] = lis3lv02d_get_axis(abs(lis3->ac.x), btns);\n\tlis3->mapped_btns[1] = lis3lv02d_get_axis(abs(lis3->ac.y), btns);\n\tlis3->mapped_btns[2] = lis3lv02d_get_axis(abs(lis3->ac.z), btns);\n\n\terr = input_register_device(lis3->idev);\n\tif (err)\n\t\tgoto err_free_input;\n\n\treturn 0;\n\nerr_free_input:\n\tinput_free_device(input_dev);\n\tlis3->idev = NULL;\n\treturn err;\n\n}\nEXPORT_SYMBOL_GPL(lis3lv02d_joystick_enable);\n\nvoid lis3lv02d_joystick_disable(struct lis3lv02d *lis3)\n{\n\tif (lis3->irq)\n\t\tfree_irq(lis3->irq, lis3);\n\tif (lis3->pdata && lis3->pdata->irq2)\n\t\tfree_irq(lis3->pdata->irq2, lis3);\n\n\tif (!lis3->idev)\n\t\treturn;\n\n\tif (lis3->irq)\n\t\tmisc_deregister(&lis3->miscdev);\n\tinput_unregister_device(lis3->idev);\n\tlis3->idev = NULL;\n}\nEXPORT_SYMBOL_GPL(lis3lv02d_joystick_disable);\n\n \nstatic void lis3lv02d_sysfs_poweron(struct lis3lv02d *lis3)\n{\n\t \n\n\tif (lis3->pm_dev) {\n\t\tpm_runtime_get_sync(lis3->pm_dev);\n\t\tpm_runtime_put_noidle(lis3->pm_dev);\n\t\tpm_schedule_suspend(lis3->pm_dev, LIS3_SYSFS_POWERDOWN_DELAY);\n\t}\n}\n\nstatic ssize_t lis3lv02d_selftest_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lis3lv02d *lis3 = dev_get_drvdata(dev);\n\ts16 values[3];\n\n\tstatic const char ok[] = \"OK\";\n\tstatic const char fail[] = \"FAIL\";\n\tstatic const char irq[] = \"FAIL_IRQ\";\n\tconst char *res;\n\n\tlis3lv02d_sysfs_poweron(lis3);\n\tswitch (lis3lv02d_selftest(lis3, values)) {\n\tcase SELFTEST_FAIL:\n\t\tres = fail;\n\t\tbreak;\n\tcase SELFTEST_IRQ:\n\t\tres = irq;\n\t\tbreak;\n\tcase SELFTEST_OK:\n\tdefault:\n\t\tres = ok;\n\t\tbreak;\n\t}\n\treturn sprintf(buf, \"%s %d %d %d\\n\", res,\n\t\tvalues[0], values[1], values[2]);\n}\n\nstatic ssize_t lis3lv02d_position_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lis3lv02d *lis3 = dev_get_drvdata(dev);\n\tint x, y, z;\n\n\tlis3lv02d_sysfs_poweron(lis3);\n\tmutex_lock(&lis3->mutex);\n\tlis3lv02d_get_xyz(lis3, &x, &y, &z);\n\tmutex_unlock(&lis3->mutex);\n\treturn sprintf(buf, \"(%d,%d,%d)\\n\", x, y, z);\n}\n\nstatic ssize_t lis3lv02d_rate_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lis3lv02d *lis3 = dev_get_drvdata(dev);\n\tint odr_idx;\n\n\tlis3lv02d_sysfs_poweron(lis3);\n\n\todr_idx = lis3lv02d_get_odr_index(lis3);\n\treturn sprintf(buf, \"%d\\n\", lis3->odrs[odr_idx]);\n}\n\nstatic ssize_t lis3lv02d_rate_set(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct lis3lv02d *lis3 = dev_get_drvdata(dev);\n\tunsigned long rate;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &rate);\n\tif (ret)\n\t\treturn ret;\n\n\tlis3lv02d_sysfs_poweron(lis3);\n\tif (lis3lv02d_set_odr(lis3, rate))\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(selftest, S_IRUSR, lis3lv02d_selftest_show, NULL);\nstatic DEVICE_ATTR(position, S_IRUGO, lis3lv02d_position_show, NULL);\nstatic DEVICE_ATTR(rate, S_IRUGO | S_IWUSR, lis3lv02d_rate_show,\n\t\t\t\t\t    lis3lv02d_rate_set);\n\nstatic struct attribute *lis3lv02d_attributes[] = {\n\t&dev_attr_selftest.attr,\n\t&dev_attr_position.attr,\n\t&dev_attr_rate.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lis3lv02d_attribute_group = {\n\t.attrs = lis3lv02d_attributes\n};\n\n\nstatic int lis3lv02d_add_fs(struct lis3lv02d *lis3)\n{\n\tlis3->pdev = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0);\n\tif (IS_ERR(lis3->pdev))\n\t\treturn PTR_ERR(lis3->pdev);\n\n\tplatform_set_drvdata(lis3->pdev, lis3);\n\treturn sysfs_create_group(&lis3->pdev->dev.kobj, &lis3lv02d_attribute_group);\n}\n\nvoid lis3lv02d_remove_fs(struct lis3lv02d *lis3)\n{\n\tsysfs_remove_group(&lis3->pdev->dev.kobj, &lis3lv02d_attribute_group);\n\tplatform_device_unregister(lis3->pdev);\n\tif (lis3->pm_dev) {\n\t\t \n\t\tpm_runtime_barrier(lis3->pm_dev);\n\n\t\t \n\t\tif (!pm_runtime_suspended(lis3->pm_dev))\n\t\t\tlis3lv02d_poweroff(lis3);\n\n\t\tpm_runtime_disable(lis3->pm_dev);\n\t\tpm_runtime_set_suspended(lis3->pm_dev);\n\t}\n\tkfree(lis3->reg_cache);\n}\nEXPORT_SYMBOL_GPL(lis3lv02d_remove_fs);\n\nstatic void lis3lv02d_8b_configure(struct lis3lv02d *lis3,\n\t\t\t\tstruct lis3lv02d_platform_data *p)\n{\n\tint err;\n\tint ctrl2 = p->hipass_ctrl;\n\n\tif (p->click_flags) {\n\t\tlis3->write(lis3, CLICK_CFG, p->click_flags);\n\t\tlis3->write(lis3, CLICK_TIMELIMIT, p->click_time_limit);\n\t\tlis3->write(lis3, CLICK_LATENCY, p->click_latency);\n\t\tlis3->write(lis3, CLICK_WINDOW, p->click_window);\n\t\tlis3->write(lis3, CLICK_THSZ, p->click_thresh_z & 0xf);\n\t\tlis3->write(lis3, CLICK_THSY_X,\n\t\t\t(p->click_thresh_x & 0xf) |\n\t\t\t(p->click_thresh_y << 4));\n\n\t\tif (lis3->idev) {\n\t\t\tinput_set_capability(lis3->idev, EV_KEY, BTN_X);\n\t\t\tinput_set_capability(lis3->idev, EV_KEY, BTN_Y);\n\t\t\tinput_set_capability(lis3->idev, EV_KEY, BTN_Z);\n\t\t}\n\t}\n\n\tif (p->wakeup_flags) {\n\t\tlis3->write(lis3, FF_WU_CFG_1, p->wakeup_flags);\n\t\tlis3->write(lis3, FF_WU_THS_1, p->wakeup_thresh & 0x7f);\n\t\t \n\t\tlis3->write(lis3, FF_WU_DURATION_1, p->duration1 + 1);\n\t\tctrl2 ^= HP_FF_WU1;  \n\t}\n\n\tif (p->wakeup_flags2) {\n\t\tlis3->write(lis3, FF_WU_CFG_2, p->wakeup_flags2);\n\t\tlis3->write(lis3, FF_WU_THS_2, p->wakeup_thresh2 & 0x7f);\n\t\t \n\t\tlis3->write(lis3, FF_WU_DURATION_2, p->duration2 + 1);\n\t\tctrl2 ^= HP_FF_WU2;  \n\t}\n\t \n\tlis3->write(lis3, CTRL_REG2, ctrl2);\n\n\tif (p->irq2) {\n\t\terr = request_threaded_irq(p->irq2,\n\t\t\t\t\tNULL,\n\t\t\t\t\tlis302dl_interrupt_thread2_8b,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT |\n\t\t\t\t\t(p->irq_flags2 & IRQF_TRIGGER_MASK),\n\t\t\t\t\tDRIVER_NAME, lis3);\n\t\tif (err < 0)\n\t\t\tpr_err(\"No second IRQ. Limited functionality\\n\");\n\t}\n}\n\n#ifdef CONFIG_OF\nint lis3lv02d_init_dt(struct lis3lv02d *lis3)\n{\n\tstruct lis3lv02d_platform_data *pdata;\n\tstruct device_node *np = lis3->of_node;\n\tu32 val;\n\ts32 sval;\n\n\tif (!lis3->of_node)\n\t\treturn 0;\n\n\tpdata = kzalloc(sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_bool(np, \"st,click-single-x\"))\n\t\tpdata->click_flags |= LIS3_CLICK_SINGLE_X;\n\tif (of_property_read_bool(np, \"st,click-double-x\"))\n\t\tpdata->click_flags |= LIS3_CLICK_DOUBLE_X;\n\n\tif (of_property_read_bool(np, \"st,click-single-y\"))\n\t\tpdata->click_flags |= LIS3_CLICK_SINGLE_Y;\n\tif (of_property_read_bool(np, \"st,click-double-y\"))\n\t\tpdata->click_flags |= LIS3_CLICK_DOUBLE_Y;\n\n\tif (of_property_read_bool(np, \"st,click-single-z\"))\n\t\tpdata->click_flags |= LIS3_CLICK_SINGLE_Z;\n\tif (of_property_read_bool(np, \"st,click-double-z\"))\n\t\tpdata->click_flags |= LIS3_CLICK_DOUBLE_Z;\n\n\tif (!of_property_read_u32(np, \"st,click-threshold-x\", &val))\n\t\tpdata->click_thresh_x = val;\n\tif (!of_property_read_u32(np, \"st,click-threshold-y\", &val))\n\t\tpdata->click_thresh_y = val;\n\tif (!of_property_read_u32(np, \"st,click-threshold-z\", &val))\n\t\tpdata->click_thresh_z = val;\n\n\tif (!of_property_read_u32(np, \"st,click-time-limit\", &val))\n\t\tpdata->click_time_limit = val;\n\tif (!of_property_read_u32(np, \"st,click-latency\", &val))\n\t\tpdata->click_latency = val;\n\tif (!of_property_read_u32(np, \"st,click-window\", &val))\n\t\tpdata->click_window = val;\n\n\tif (of_property_read_bool(np, \"st,irq1-disable\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ1_DISABLE;\n\tif (of_property_read_bool(np, \"st,irq1-ff-wu-1\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ1_FF_WU_1;\n\tif (of_property_read_bool(np, \"st,irq1-ff-wu-2\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ1_FF_WU_2;\n\tif (of_property_read_bool(np, \"st,irq1-data-ready\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ1_DATA_READY;\n\tif (of_property_read_bool(np, \"st,irq1-click\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ1_CLICK;\n\n\tif (of_property_read_bool(np, \"st,irq2-disable\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ2_DISABLE;\n\tif (of_property_read_bool(np, \"st,irq2-ff-wu-1\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ2_FF_WU_1;\n\tif (of_property_read_bool(np, \"st,irq2-ff-wu-2\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ2_FF_WU_2;\n\tif (of_property_read_bool(np, \"st,irq2-data-ready\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ2_DATA_READY;\n\tif (of_property_read_bool(np, \"st,irq2-click\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ2_CLICK;\n\n\tif (of_property_read_bool(np, \"st,irq-open-drain\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ_OPEN_DRAIN;\n\tif (of_property_read_bool(np, \"st,irq-active-low\"))\n\t\tpdata->irq_cfg |= LIS3_IRQ_ACTIVE_LOW;\n\n\tif (!of_property_read_u32(np, \"st,wu-duration-1\", &val))\n\t\tpdata->duration1 = val;\n\tif (!of_property_read_u32(np, \"st,wu-duration-2\", &val))\n\t\tpdata->duration2 = val;\n\n\tif (of_property_read_bool(np, \"st,wakeup-x-lo\"))\n\t\tpdata->wakeup_flags |= LIS3_WAKEUP_X_LO;\n\tif (of_property_read_bool(np, \"st,wakeup-x-hi\"))\n\t\tpdata->wakeup_flags |= LIS3_WAKEUP_X_HI;\n\tif (of_property_read_bool(np, \"st,wakeup-y-lo\"))\n\t\tpdata->wakeup_flags |= LIS3_WAKEUP_Y_LO;\n\tif (of_property_read_bool(np, \"st,wakeup-y-hi\"))\n\t\tpdata->wakeup_flags |= LIS3_WAKEUP_Y_HI;\n\tif (of_property_read_bool(np, \"st,wakeup-z-lo\"))\n\t\tpdata->wakeup_flags |= LIS3_WAKEUP_Z_LO;\n\tif (of_property_read_bool(np, \"st,wakeup-z-hi\"))\n\t\tpdata->wakeup_flags |= LIS3_WAKEUP_Z_HI;\n\tif (of_get_property(np, \"st,wakeup-threshold\", &val))\n\t\tpdata->wakeup_thresh = val;\n\n\tif (of_property_read_bool(np, \"st,wakeup2-x-lo\"))\n\t\tpdata->wakeup_flags2 |= LIS3_WAKEUP_X_LO;\n\tif (of_property_read_bool(np, \"st,wakeup2-x-hi\"))\n\t\tpdata->wakeup_flags2 |= LIS3_WAKEUP_X_HI;\n\tif (of_property_read_bool(np, \"st,wakeup2-y-lo\"))\n\t\tpdata->wakeup_flags2 |= LIS3_WAKEUP_Y_LO;\n\tif (of_property_read_bool(np, \"st,wakeup2-y-hi\"))\n\t\tpdata->wakeup_flags2 |= LIS3_WAKEUP_Y_HI;\n\tif (of_property_read_bool(np, \"st,wakeup2-z-lo\"))\n\t\tpdata->wakeup_flags2 |= LIS3_WAKEUP_Z_LO;\n\tif (of_property_read_bool(np, \"st,wakeup2-z-hi\"))\n\t\tpdata->wakeup_flags2 |= LIS3_WAKEUP_Z_HI;\n\tif (of_get_property(np, \"st,wakeup2-threshold\", &val))\n\t\tpdata->wakeup_thresh2 = val;\n\n\tif (!of_property_read_u32(np, \"st,highpass-cutoff-hz\", &val)) {\n\t\tswitch (val) {\n\t\tcase 1:\n\t\t\tpdata->hipass_ctrl = LIS3_HIPASS_CUTFF_1HZ;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpdata->hipass_ctrl = LIS3_HIPASS_CUTFF_2HZ;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpdata->hipass_ctrl = LIS3_HIPASS_CUTFF_4HZ;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tpdata->hipass_ctrl = LIS3_HIPASS_CUTFF_8HZ;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (of_property_read_bool(np, \"st,hipass1-disable\"))\n\t\tpdata->hipass_ctrl |= LIS3_HIPASS1_DISABLE;\n\tif (of_property_read_bool(np, \"st,hipass2-disable\"))\n\t\tpdata->hipass_ctrl |= LIS3_HIPASS2_DISABLE;\n\n\tif (of_property_read_s32(np, \"st,axis-x\", &sval) == 0)\n\t\tpdata->axis_x = sval;\n\tif (of_property_read_s32(np, \"st,axis-y\", &sval) == 0)\n\t\tpdata->axis_y = sval;\n\tif (of_property_read_s32(np, \"st,axis-z\", &sval) == 0)\n\t\tpdata->axis_z = sval;\n\n\tif (of_property_read_u32(np, \"st,default-rate\", &val) == 0)\n\t\tpdata->default_rate = val;\n\n\tif (of_property_read_s32(np, \"st,min-limit-x\", &sval) == 0)\n\t\tpdata->st_min_limits[0] = sval;\n\tif (of_property_read_s32(np, \"st,min-limit-y\", &sval) == 0)\n\t\tpdata->st_min_limits[1] = sval;\n\tif (of_property_read_s32(np, \"st,min-limit-z\", &sval) == 0)\n\t\tpdata->st_min_limits[2] = sval;\n\n\tif (of_property_read_s32(np, \"st,max-limit-x\", &sval) == 0)\n\t\tpdata->st_max_limits[0] = sval;\n\tif (of_property_read_s32(np, \"st,max-limit-y\", &sval) == 0)\n\t\tpdata->st_max_limits[1] = sval;\n\tif (of_property_read_s32(np, \"st,max-limit-z\", &sval) == 0)\n\t\tpdata->st_max_limits[2] = sval;\n\n\n\tlis3->pdata = pdata;\n\n\treturn 0;\n}\n\n#else\nint lis3lv02d_init_dt(struct lis3lv02d *lis3)\n{\n\treturn 0;\n}\n#endif\nEXPORT_SYMBOL_GPL(lis3lv02d_init_dt);\n\n \nint lis3lv02d_init_device(struct lis3lv02d *lis3)\n{\n\tint err;\n\tirq_handler_t thread_fn;\n\tint irq_flags = 0;\n\n\tlis3->whoami = lis3lv02d_read_8(lis3, WHO_AM_I);\n\n\tswitch (lis3->whoami) {\n\tcase WAI_12B:\n\t\tpr_info(\"12 bits sensor found\\n\");\n\t\tlis3->read_data = lis3lv02d_read_12;\n\t\tlis3->mdps_max_val = 2048;\n\t\tlis3->pwron_delay = LIS3_PWRON_DELAY_WAI_12B;\n\t\tlis3->odrs = lis3_12_rates;\n\t\tlis3->odr_mask = CTRL1_DF0 | CTRL1_DF1;\n\t\tlis3->scale = LIS3_SENSITIVITY_12B;\n\t\tlis3->regs = lis3_wai12_regs;\n\t\tlis3->regs_size = ARRAY_SIZE(lis3_wai12_regs);\n\t\tbreak;\n\tcase WAI_8B:\n\t\tpr_info(\"8 bits sensor found\\n\");\n\t\tlis3->read_data = lis3lv02d_read_8;\n\t\tlis3->mdps_max_val = 128;\n\t\tlis3->pwron_delay = LIS3_PWRON_DELAY_WAI_8B;\n\t\tlis3->odrs = lis3_8_rates;\n\t\tlis3->odr_mask = CTRL1_DR;\n\t\tlis3->scale = LIS3_SENSITIVITY_8B;\n\t\tlis3->regs = lis3_wai8_regs;\n\t\tlis3->regs_size = ARRAY_SIZE(lis3_wai8_regs);\n\t\tbreak;\n\tcase WAI_3DC:\n\t\tpr_info(\"8 bits 3DC sensor found\\n\");\n\t\tlis3->read_data = lis3lv02d_read_8;\n\t\tlis3->mdps_max_val = 128;\n\t\tlis3->pwron_delay = LIS3_PWRON_DELAY_WAI_8B;\n\t\tlis3->odrs = lis3_3dc_rates;\n\t\tlis3->odr_mask = CTRL1_ODR0|CTRL1_ODR1|CTRL1_ODR2|CTRL1_ODR3;\n\t\tlis3->scale = LIS3_SENSITIVITY_8B;\n\t\tbreak;\n\tcase WAI_3DLH:\n\t\tpr_info(\"16 bits lis331dlh sensor found\\n\");\n\t\tlis3->read_data = lis331dlh_read_data;\n\t\tlis3->mdps_max_val = 2048;  \n\t\tlis3->shift_adj = SHIFT_ADJ_2G;\n\t\tlis3->pwron_delay = LIS3_PWRON_DELAY_WAI_8B;\n\t\tlis3->odrs = lis3_3dlh_rates;\n\t\tlis3->odr_mask = CTRL1_DR0 | CTRL1_DR1;\n\t\tlis3->scale = LIS3DLH_SENSITIVITY_2G;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown sensor type 0x%X\\n\", lis3->whoami);\n\t\treturn -ENODEV;\n\t}\n\n\tlis3->reg_cache = kzalloc(max(sizeof(lis3_wai8_regs),\n\t\t\t\t     sizeof(lis3_wai12_regs)), GFP_KERNEL);\n\n\tif (lis3->reg_cache == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&lis3->mutex);\n\tatomic_set(&lis3->wake_thread, 0);\n\n\tlis3lv02d_add_fs(lis3);\n\terr = lis3lv02d_poweron(lis3);\n\tif (err) {\n\t\tlis3lv02d_remove_fs(lis3);\n\t\treturn err;\n\t}\n\n\tif (lis3->pm_dev) {\n\t\tpm_runtime_set_active(lis3->pm_dev);\n\t\tpm_runtime_enable(lis3->pm_dev);\n\t}\n\n\tif (lis3lv02d_joystick_enable(lis3))\n\t\tpr_err(\"joystick initialization failed\\n\");\n\n\t \n\tif (lis3->pdata) {\n\t\tstruct lis3lv02d_platform_data *p = lis3->pdata;\n\n\t\tif (lis3->whoami == WAI_8B)\n\t\t\tlis3lv02d_8b_configure(lis3, p);\n\n\t\tirq_flags = p->irq_flags1 & IRQF_TRIGGER_MASK;\n\n\t\tlis3->irq_cfg = p->irq_cfg;\n\t\tif (p->irq_cfg)\n\t\t\tlis3->write(lis3, CTRL_REG3, p->irq_cfg);\n\n\t\tif (p->default_rate)\n\t\t\tlis3lv02d_set_odr(lis3, p->default_rate);\n\t}\n\n\t \n\tif (!lis3->irq) {\n\t\tpr_debug(\"No IRQ. Disabling /dev/freefall\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (lis3->pdata && lis3->whoami == WAI_8B)\n\t\tthread_fn = lis302dl_interrupt_thread1_8b;\n\telse\n\t\tthread_fn = NULL;\n\n\terr = request_threaded_irq(lis3->irq, lis302dl_interrupt,\n\t\t\t\tthread_fn,\n\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT |\n\t\t\t\tirq_flags,\n\t\t\t\tDRIVER_NAME, lis3);\n\n\tif (err < 0) {\n\t\tpr_err(\"Cannot get IRQ\\n\");\n\t\tgoto out;\n\t}\n\n\tlis3->miscdev.minor\t= MISC_DYNAMIC_MINOR;\n\tlis3->miscdev.name\t= \"freefall\";\n\tlis3->miscdev.fops\t= &lis3lv02d_misc_fops;\n\n\tif (misc_register(&lis3->miscdev))\n\t\tpr_err(\"misc_register failed\\n\");\nout:\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lis3lv02d_init_device);\n\nMODULE_DESCRIPTION(\"ST LIS3LV02Dx three-axis digital accelerometer driver\");\nMODULE_AUTHOR(\"Yan Burman, Eric Piel, Pavel Machek\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}