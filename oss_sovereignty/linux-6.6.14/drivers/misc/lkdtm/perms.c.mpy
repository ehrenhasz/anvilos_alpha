{
  "module_name": "perms.c",
  "hash_id": "21c8856689e7993fd7db87b9ee7ea512bfe6ec4156cb3ecbe6d590e07d8566a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/lkdtm/perms.c",
  "human_readable_source": "\n \n#include \"lkdtm.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mman.h>\n#include <linux/uaccess.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n\n \n#define CODE_WRITE\ttrue\n#define CODE_AS_IS\tfalse\n\n \n#define EXEC_SIZE 64\n\n \nstatic u8 data_area[EXEC_SIZE];\n\n \nstatic const unsigned long rodata = 0xAA55AA55;\n\n \nstatic unsigned long ro_after_init __ro_after_init = 0x55AA5500;\n\n \nstatic noinline void do_nothing(void)\n{\n\treturn;\n}\n\n \nstatic noinline void do_overwritten(void)\n{\n\tpr_info(\"do_overwritten wasn't overwritten!\\n\");\n\treturn;\n}\n\nstatic noinline void do_almost_nothing(void)\n{\n\tpr_info(\"do_nothing was hijacked!\\n\");\n}\n\nstatic void *setup_function_descriptor(func_desc_t *fdesc, void *dst)\n{\n\tif (!have_function_descriptors())\n\t\treturn dst;\n\n\tmemcpy(fdesc, do_nothing, sizeof(*fdesc));\n\tfdesc->addr = (unsigned long)dst;\n\tbarrier();\n\n\treturn fdesc;\n}\n\nstatic noinline void execute_location(void *dst, bool write)\n{\n\tvoid (*func)(void);\n\tfunc_desc_t fdesc;\n\tvoid *do_nothing_text = dereference_function_descriptor(do_nothing);\n\n\tpr_info(\"attempting ok execution at %px\\n\", do_nothing_text);\n\tdo_nothing();\n\n\tif (write == CODE_WRITE) {\n\t\tmemcpy(dst, do_nothing_text, EXEC_SIZE);\n\t\tflush_icache_range((unsigned long)dst,\n\t\t\t\t   (unsigned long)dst + EXEC_SIZE);\n\t}\n\tpr_info(\"attempting bad execution at %px\\n\", dst);\n\tfunc = setup_function_descriptor(&fdesc, dst);\n\tfunc();\n\tpr_err(\"FAIL: func returned\\n\");\n}\n\nstatic void execute_user_location(void *dst)\n{\n\tint copied;\n\n\t \n\tvoid (*func)(void);\n\tfunc_desc_t fdesc;\n\tvoid *do_nothing_text = dereference_function_descriptor(do_nothing);\n\n\tpr_info(\"attempting ok execution at %px\\n\", do_nothing_text);\n\tdo_nothing();\n\n\tcopied = access_process_vm(current, (unsigned long)dst, do_nothing_text,\n\t\t\t\t   EXEC_SIZE, FOLL_WRITE);\n\tif (copied < EXEC_SIZE)\n\t\treturn;\n\tpr_info(\"attempting bad execution at %px\\n\", dst);\n\tfunc = setup_function_descriptor(&fdesc, dst);\n\tfunc();\n\tpr_err(\"FAIL: func returned\\n\");\n}\n\nstatic void lkdtm_WRITE_RO(void)\n{\n\t \n\tvolatile unsigned long *ptr = (unsigned long *)&rodata;\n\n\tpr_info(\"attempting bad rodata write at %px\\n\", ptr);\n\t*ptr ^= 0xabcd1234;\n\tpr_err(\"FAIL: survived bad write\\n\");\n}\n\nstatic void lkdtm_WRITE_RO_AFTER_INIT(void)\n{\n\tvolatile unsigned long *ptr = &ro_after_init;\n\n\t \n\tif ((*ptr & 0xAA) != 0xAA) {\n\t\tpr_info(\"%p was NOT written during init!?\\n\", ptr);\n\t\treturn;\n\t}\n\n\tpr_info(\"attempting bad ro_after_init write at %px\\n\", ptr);\n\t*ptr ^= 0xabcd1234;\n\tpr_err(\"FAIL: survived bad write\\n\");\n}\n\nstatic void lkdtm_WRITE_KERN(void)\n{\n\tsize_t size;\n\tvolatile unsigned char *ptr;\n\n\tsize = (unsigned long)dereference_function_descriptor(do_overwritten) -\n\t       (unsigned long)dereference_function_descriptor(do_nothing);\n\tptr = dereference_function_descriptor(do_overwritten);\n\n\tpr_info(\"attempting bad %zu byte write at %px\\n\", size, ptr);\n\tmemcpy((void *)ptr, (unsigned char *)do_nothing, size);\n\tflush_icache_range((unsigned long)ptr, (unsigned long)(ptr + size));\n\tpr_err(\"FAIL: survived bad write\\n\");\n\n\tdo_overwritten();\n}\n\nstatic void lkdtm_WRITE_OPD(void)\n{\n\tsize_t size = sizeof(func_desc_t);\n\tvoid (*func)(void) = do_nothing;\n\n\tif (!have_function_descriptors()) {\n\t\tpr_info(\"XFAIL: Platform doesn't use function descriptors.\\n\");\n\t\treturn;\n\t}\n\tpr_info(\"attempting bad %zu bytes write at %px\\n\", size, do_nothing);\n\tmemcpy(do_nothing, do_almost_nothing, size);\n\tpr_err(\"FAIL: survived bad write\\n\");\n\n\tasm(\"\" : \"=m\"(func));\n\tfunc();\n}\n\nstatic void lkdtm_EXEC_DATA(void)\n{\n\texecute_location(data_area, CODE_WRITE);\n}\n\nstatic void lkdtm_EXEC_STACK(void)\n{\n\tu8 stack_area[EXEC_SIZE];\n\texecute_location(stack_area, CODE_WRITE);\n}\n\nstatic void lkdtm_EXEC_KMALLOC(void)\n{\n\tu32 *kmalloc_area = kmalloc(EXEC_SIZE, GFP_KERNEL);\n\texecute_location(kmalloc_area, CODE_WRITE);\n\tkfree(kmalloc_area);\n}\n\nstatic void lkdtm_EXEC_VMALLOC(void)\n{\n\tu32 *vmalloc_area = vmalloc(EXEC_SIZE);\n\texecute_location(vmalloc_area, CODE_WRITE);\n\tvfree(vmalloc_area);\n}\n\nstatic void lkdtm_EXEC_RODATA(void)\n{\n\texecute_location(dereference_function_descriptor(lkdtm_rodata_do_nothing),\n\t\t\t CODE_AS_IS);\n}\n\nstatic void lkdtm_EXEC_USERSPACE(void)\n{\n\tunsigned long user_addr;\n\n\tuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\n\t\t\t    PROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0);\n\tif (user_addr >= TASK_SIZE) {\n\t\tpr_warn(\"Failed to allocate user memory\\n\");\n\t\treturn;\n\t}\n\texecute_user_location((void *)user_addr);\n\tvm_munmap(user_addr, PAGE_SIZE);\n}\n\nstatic void lkdtm_EXEC_NULL(void)\n{\n\texecute_location(NULL, CODE_AS_IS);\n}\n\nstatic void lkdtm_ACCESS_USERSPACE(void)\n{\n\tunsigned long user_addr, tmp = 0;\n\tunsigned long *ptr;\n\n\tuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\n\t\t\t    PROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0);\n\tif (user_addr >= TASK_SIZE) {\n\t\tpr_warn(\"Failed to allocate user memory\\n\");\n\t\treturn;\n\t}\n\n\tif (copy_to_user((void __user *)user_addr, &tmp, sizeof(tmp))) {\n\t\tpr_warn(\"copy_to_user failed\\n\");\n\t\tvm_munmap(user_addr, PAGE_SIZE);\n\t\treturn;\n\t}\n\n\tptr = (unsigned long *)user_addr;\n\n\tpr_info(\"attempting bad read at %px\\n\", ptr);\n\ttmp = *ptr;\n\ttmp += 0xc0dec0de;\n\tpr_err(\"FAIL: survived bad read\\n\");\n\n\tpr_info(\"attempting bad write at %px\\n\", ptr);\n\t*ptr = tmp;\n\tpr_err(\"FAIL: survived bad write\\n\");\n\n\tvm_munmap(user_addr, PAGE_SIZE);\n}\n\nstatic void lkdtm_ACCESS_NULL(void)\n{\n\tunsigned long tmp;\n\tvolatile unsigned long *ptr = (unsigned long *)NULL;\n\n\tpr_info(\"attempting bad read at %px\\n\", ptr);\n\ttmp = *ptr;\n\ttmp += 0xc0dec0de;\n\tpr_err(\"FAIL: survived bad read\\n\");\n\n\tpr_info(\"attempting bad write at %px\\n\", ptr);\n\t*ptr = tmp;\n\tpr_err(\"FAIL: survived bad write\\n\");\n}\n\nvoid __init lkdtm_perms_init(void)\n{\n\t \n\tro_after_init |= 0xAA;\n}\n\nstatic struct crashtype crashtypes[] = {\n\tCRASHTYPE(WRITE_RO),\n\tCRASHTYPE(WRITE_RO_AFTER_INIT),\n\tCRASHTYPE(WRITE_KERN),\n\tCRASHTYPE(WRITE_OPD),\n\tCRASHTYPE(EXEC_DATA),\n\tCRASHTYPE(EXEC_STACK),\n\tCRASHTYPE(EXEC_KMALLOC),\n\tCRASHTYPE(EXEC_VMALLOC),\n\tCRASHTYPE(EXEC_RODATA),\n\tCRASHTYPE(EXEC_USERSPACE),\n\tCRASHTYPE(EXEC_NULL),\n\tCRASHTYPE(ACCESS_USERSPACE),\n\tCRASHTYPE(ACCESS_NULL),\n};\n\nstruct crashtype_category perms_crashtypes = {\n\t.crashtypes = crashtypes,\n\t.len\t    = ARRAY_SIZE(crashtypes),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}