{
  "module_name": "usercopy.c",
  "hash_id": "ee2315c0e5827561fdd4436181ae07562c69f31690cf963a4d7c5adf4933716c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/lkdtm/usercopy.c",
  "human_readable_source": "\n \n#include \"lkdtm.h\"\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/task_stack.h>\n#include <linux/mman.h>\n#include <linux/uaccess.h>\n#include <asm/cacheflush.h>\n\n \nstatic volatile size_t unconst;\nstatic volatile size_t cache_size = 1024;\nstatic struct kmem_cache *whitelist_cache;\n\nstatic const unsigned char test_text[] = \"This is a test.\\n\";\n\n \nstatic noinline unsigned char *trick_compiler(unsigned char *stack)\n{\n\treturn stack + unconst;\n}\n\nstatic noinline unsigned char *do_usercopy_stack_callee(int value)\n{\n\tunsigned char buf[128];\n\tint i;\n\n\t \n\tfor (i = 0; i < sizeof(buf); i++) {\n\t\tbuf[i] = value & 0xff;\n\t}\n\n\t \n\treturn trick_compiler(&buf[(128/2)-32]);\n}\n\nstatic noinline void do_usercopy_stack(bool to_user, bool bad_frame)\n{\n\tunsigned long user_addr;\n\tunsigned char good_stack[32];\n\tunsigned char *bad_stack;\n\tint i;\n\n\t \n\tfor (i = 0; i < sizeof(good_stack); i++)\n\t\tgood_stack[i] = test_text[i % sizeof(test_text)];\n\n\t \n\tif (bad_frame) {\n\t\tbad_stack = do_usercopy_stack_callee((uintptr_t)&bad_stack);\n\t} else {\n\t\t \n\t\tbad_stack = task_stack_page(current) + THREAD_SIZE;\n\t\tbad_stack -= sizeof(unsigned long);\n\t}\n\n#ifdef ARCH_HAS_CURRENT_STACK_POINTER\n\tpr_info(\"stack     : %px\\n\", (void *)current_stack_pointer);\n#endif\n\tpr_info(\"good_stack: %px-%px\\n\", good_stack, good_stack + sizeof(good_stack));\n\tpr_info(\"bad_stack : %px-%px\\n\", bad_stack, bad_stack + sizeof(good_stack));\n\n\tuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\n\t\t\t    PROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0);\n\tif (user_addr >= TASK_SIZE) {\n\t\tpr_warn(\"Failed to allocate user memory\\n\");\n\t\treturn;\n\t}\n\n\tif (to_user) {\n\t\tpr_info(\"attempting good copy_to_user of local stack\\n\");\n\t\tif (copy_to_user((void __user *)user_addr, good_stack,\n\t\t\t\t unconst + sizeof(good_stack))) {\n\t\t\tpr_warn(\"copy_to_user failed unexpectedly?!\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\n\t\tpr_info(\"attempting bad copy_to_user of distant stack\\n\");\n\t\tif (copy_to_user((void __user *)user_addr, bad_stack,\n\t\t\t\t unconst + sizeof(good_stack))) {\n\t\t\tpr_warn(\"copy_to_user failed, but lacked Oops\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!bad_frame)\n\t\t\tgoto free_user;\n\n\t\tpr_info(\"attempting good copy_from_user of local stack\\n\");\n\t\tif (copy_from_user(good_stack, (void __user *)user_addr,\n\t\t\t\t   unconst + sizeof(good_stack))) {\n\t\t\tpr_warn(\"copy_from_user failed unexpectedly?!\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\n\t\tpr_info(\"attempting bad copy_from_user of distant stack\\n\");\n\t\tif (copy_from_user(bad_stack, (void __user *)user_addr,\n\t\t\t\t   unconst + sizeof(good_stack))) {\n\t\t\tpr_warn(\"copy_from_user failed, but lacked Oops\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\t}\n\nfree_user:\n\tvm_munmap(user_addr, PAGE_SIZE);\n}\n\n \nstatic void do_usercopy_slab_size(bool to_user)\n{\n\tunsigned long user_addr;\n\tunsigned char *one, *two;\n\tvoid __user *test_user_addr;\n\tvoid *test_kern_addr;\n\tsize_t size = unconst + 1024;\n\n\tone = kmalloc(size, GFP_KERNEL);\n\ttwo = kmalloc(size, GFP_KERNEL);\n\tif (!one || !two) {\n\t\tpr_warn(\"Failed to allocate kernel memory\\n\");\n\t\tgoto free_kernel;\n\t}\n\n\tuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\n\t\t\t    PROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0);\n\tif (user_addr >= TASK_SIZE) {\n\t\tpr_warn(\"Failed to allocate user memory\\n\");\n\t\tgoto free_kernel;\n\t}\n\n\tmemset(one, 'A', size);\n\tmemset(two, 'B', size);\n\n\ttest_user_addr = (void __user *)(user_addr + 16);\n\ttest_kern_addr = one + 16;\n\n\tif (to_user) {\n\t\tpr_info(\"attempting good copy_to_user of correct size\\n\");\n\t\tif (copy_to_user(test_user_addr, test_kern_addr, size / 2)) {\n\t\t\tpr_warn(\"copy_to_user failed unexpectedly?!\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\n\t\tpr_info(\"attempting bad copy_to_user of too large size\\n\");\n\t\tif (copy_to_user(test_user_addr, test_kern_addr, size)) {\n\t\t\tpr_warn(\"copy_to_user failed, but lacked Oops\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\t} else {\n\t\tpr_info(\"attempting good copy_from_user of correct size\\n\");\n\t\tif (copy_from_user(test_kern_addr, test_user_addr, size / 2)) {\n\t\t\tpr_warn(\"copy_from_user failed unexpectedly?!\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\n\t\tpr_info(\"attempting bad copy_from_user of too large size\\n\");\n\t\tif (copy_from_user(test_kern_addr, test_user_addr, size)) {\n\t\t\tpr_warn(\"copy_from_user failed, but lacked Oops\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\t}\n\tpr_err(\"FAIL: bad usercopy not detected!\\n\");\n\tpr_expected_config_param(CONFIG_HARDENED_USERCOPY, \"hardened_usercopy\");\n\nfree_user:\n\tvm_munmap(user_addr, PAGE_SIZE);\nfree_kernel:\n\tkfree(one);\n\tkfree(two);\n}\n\n \nstatic void do_usercopy_slab_whitelist(bool to_user)\n{\n\tunsigned long user_alloc;\n\tunsigned char *buf = NULL;\n\tunsigned char __user *user_addr;\n\tsize_t offset, size;\n\n\t \n\tif (!whitelist_cache) {\n\t\tpr_warn(\"Failed to allocate kernel cache\\n\");\n\t\treturn;\n\t}\n\n\t \n\tbuf = kmem_cache_alloc(whitelist_cache, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_warn(\"Failed to allocate buffer from whitelist cache\\n\");\n\t\tgoto free_alloc;\n\t}\n\n\t \n\tuser_alloc = vm_mmap(NULL, 0, PAGE_SIZE,\n\t\t\t    PROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0);\n\tif (user_alloc >= TASK_SIZE) {\n\t\tpr_warn(\"Failed to allocate user memory\\n\");\n\t\tgoto free_alloc;\n\t}\n\tuser_addr = (void __user *)user_alloc;\n\n\tmemset(buf, 'B', cache_size);\n\n\t \n\toffset = (cache_size / 4) + unconst;\n\tsize = (cache_size / 16) + unconst;\n\n\tif (to_user) {\n\t\tpr_info(\"attempting good copy_to_user inside whitelist\\n\");\n\t\tif (copy_to_user(user_addr, buf + offset, size)) {\n\t\t\tpr_warn(\"copy_to_user failed unexpectedly?!\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\n\t\tpr_info(\"attempting bad copy_to_user outside whitelist\\n\");\n\t\tif (copy_to_user(user_addr, buf + offset - 1, size)) {\n\t\t\tpr_warn(\"copy_to_user failed, but lacked Oops\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\t} else {\n\t\tpr_info(\"attempting good copy_from_user inside whitelist\\n\");\n\t\tif (copy_from_user(buf + offset, user_addr, size)) {\n\t\t\tpr_warn(\"copy_from_user failed unexpectedly?!\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\n\t\tpr_info(\"attempting bad copy_from_user outside whitelist\\n\");\n\t\tif (copy_from_user(buf + offset - 1, user_addr, size)) {\n\t\t\tpr_warn(\"copy_from_user failed, but lacked Oops\\n\");\n\t\t\tgoto free_user;\n\t\t}\n\t}\n\tpr_err(\"FAIL: bad usercopy not detected!\\n\");\n\tpr_expected_config_param(CONFIG_HARDENED_USERCOPY, \"hardened_usercopy\");\n\nfree_user:\n\tvm_munmap(user_alloc, PAGE_SIZE);\nfree_alloc:\n\tif (buf)\n\t\tkmem_cache_free(whitelist_cache, buf);\n}\n\n \nstatic void lkdtm_USERCOPY_SLAB_SIZE_TO(void)\n{\n\tdo_usercopy_slab_size(true);\n}\n\nstatic void lkdtm_USERCOPY_SLAB_SIZE_FROM(void)\n{\n\tdo_usercopy_slab_size(false);\n}\n\nstatic void lkdtm_USERCOPY_SLAB_WHITELIST_TO(void)\n{\n\tdo_usercopy_slab_whitelist(true);\n}\n\nstatic void lkdtm_USERCOPY_SLAB_WHITELIST_FROM(void)\n{\n\tdo_usercopy_slab_whitelist(false);\n}\n\nstatic void lkdtm_USERCOPY_STACK_FRAME_TO(void)\n{\n\tdo_usercopy_stack(true, true);\n}\n\nstatic void lkdtm_USERCOPY_STACK_FRAME_FROM(void)\n{\n\tdo_usercopy_stack(false, true);\n}\n\nstatic void lkdtm_USERCOPY_STACK_BEYOND(void)\n{\n\tdo_usercopy_stack(true, false);\n}\n\nstatic void lkdtm_USERCOPY_KERNEL(void)\n{\n\tunsigned long user_addr;\n\n\tuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\n\t\t\t    PROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0);\n\tif (user_addr >= TASK_SIZE) {\n\t\tpr_warn(\"Failed to allocate user memory\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"attempting good copy_to_user from kernel rodata: %px\\n\",\n\t\ttest_text);\n\tif (copy_to_user((void __user *)user_addr, test_text,\n\t\t\t unconst + sizeof(test_text))) {\n\t\tpr_warn(\"copy_to_user failed unexpectedly?!\\n\");\n\t\tgoto free_user;\n\t}\n\n\tpr_info(\"attempting bad copy_to_user from kernel text: %px\\n\",\n\t\tvm_mmap);\n\tif (copy_to_user((void __user *)user_addr, vm_mmap,\n\t\t\t unconst + PAGE_SIZE)) {\n\t\tpr_warn(\"copy_to_user failed, but lacked Oops\\n\");\n\t\tgoto free_user;\n\t}\n\tpr_err(\"FAIL: bad copy_to_user() not detected!\\n\");\n\tpr_expected_config_param(CONFIG_HARDENED_USERCOPY, \"hardened_usercopy\");\n\nfree_user:\n\tvm_munmap(user_addr, PAGE_SIZE);\n}\n\n \nstatic void do_usercopy_page_span(const char *name, void *kaddr)\n{\n\tunsigned long uaddr;\n\n\tuaddr = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_WRITE,\n\t\t\tMAP_ANONYMOUS | MAP_PRIVATE, 0);\n\tif (uaddr >= TASK_SIZE) {\n\t\tpr_warn(\"Failed to allocate user memory\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmemset(kaddr, 0xAA, PAGE_SIZE);\n\n\t \n\tkaddr += PAGE_SIZE / 2;\n\n\tpr_info(\"attempting good copy_to_user() from kernel %s: %px\\n\",\n\t\tname, kaddr);\n\tif (copy_to_user((void __user *)uaddr, kaddr,\n\t\t\t unconst + (PAGE_SIZE / 2))) {\n\t\tpr_err(\"copy_to_user() failed unexpectedly?!\\n\");\n\t\tgoto free_user;\n\t}\n\n\tpr_info(\"attempting bad copy_to_user() from kernel %s: %px\\n\",\n\t\tname, kaddr);\n\tif (copy_to_user((void __user *)uaddr, kaddr, unconst + PAGE_SIZE)) {\n\t\tpr_warn(\"Good, copy_to_user() failed, but lacked Oops(?!)\\n\");\n\t\tgoto free_user;\n\t}\n\n\tpr_err(\"FAIL: bad copy_to_user() not detected!\\n\");\n\tpr_expected_config_param(CONFIG_HARDENED_USERCOPY, \"hardened_usercopy\");\n\nfree_user:\n\tvm_munmap(uaddr, PAGE_SIZE);\n}\n\nstatic void lkdtm_USERCOPY_VMALLOC(void)\n{\n\tvoid *addr;\n\n\taddr = vmalloc(PAGE_SIZE);\n\tif (!addr) {\n\t\tpr_err(\"vmalloc() failed!?\\n\");\n\t\treturn;\n\t}\n\tdo_usercopy_page_span(\"vmalloc\", addr);\n\tvfree(addr);\n}\n\nstatic void lkdtm_USERCOPY_FOLIO(void)\n{\n\tstruct folio *folio;\n\tvoid *addr;\n\n\t \n\tfolio = folio_alloc(GFP_KERNEL | __GFP_ZERO, 1);\n\tif (!folio) {\n\t\tpr_err(\"folio_alloc() failed!?\\n\");\n\t\treturn;\n\t}\n\taddr = folio_address(folio);\n\tif (addr)\n\t\tdo_usercopy_page_span(\"folio\", addr + PAGE_SIZE);\n\telse\n\t\tpr_err(\"folio_address() failed?!\\n\");\n\tfolio_put(folio);\n}\n\nvoid __init lkdtm_usercopy_init(void)\n{\n\t \n\twhitelist_cache =\n\t\tkmem_cache_create_usercopy(\"lkdtm-usercopy\", cache_size,\n\t\t\t\t\t   0, 0,\n\t\t\t\t\t   cache_size / 4,\n\t\t\t\t\t   cache_size / 16,\n\t\t\t\t\t   NULL);\n}\n\nvoid __exit lkdtm_usercopy_exit(void)\n{\n\tkmem_cache_destroy(whitelist_cache);\n}\n\nstatic struct crashtype crashtypes[] = {\n\tCRASHTYPE(USERCOPY_SLAB_SIZE_TO),\n\tCRASHTYPE(USERCOPY_SLAB_SIZE_FROM),\n\tCRASHTYPE(USERCOPY_SLAB_WHITELIST_TO),\n\tCRASHTYPE(USERCOPY_SLAB_WHITELIST_FROM),\n\tCRASHTYPE(USERCOPY_STACK_FRAME_TO),\n\tCRASHTYPE(USERCOPY_STACK_FRAME_FROM),\n\tCRASHTYPE(USERCOPY_STACK_BEYOND),\n\tCRASHTYPE(USERCOPY_VMALLOC),\n\tCRASHTYPE(USERCOPY_FOLIO),\n\tCRASHTYPE(USERCOPY_KERNEL),\n};\n\nstruct crashtype_category usercopy_crashtypes = {\n\t.crashtypes = crashtypes,\n\t.len\t    = ARRAY_SIZE(crashtypes),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}