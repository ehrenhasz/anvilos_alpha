{
  "module_name": "cfi.c",
  "hash_id": "9bddb2b1301fbbf0054ebf073a76b7f03f6acf5e794aa7d3c834fb08f412b8ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/lkdtm/cfi.c",
  "human_readable_source": "\n \n#include \"lkdtm.h\"\n#include <asm/page.h>\n\nstatic int called_count;\n\n \nstatic noinline void lkdtm_increment_void(int *counter)\n{\n\t(*counter)++;\n}\n\n \nstatic noinline int lkdtm_increment_int(int *counter)\n{\n\t(*counter)++;\n\n\treturn *counter;\n}\n\n \nstatic noinline void lkdtm_indirect_call(void (*func)(int *))\n{\n\tfunc(&called_count);\n}\n\n \nstatic void lkdtm_CFI_FORWARD_PROTO(void)\n{\n\t \n\tpr_info(\"Calling matched prototype ...\\n\");\n\tlkdtm_indirect_call(lkdtm_increment_void);\n\n\tpr_info(\"Calling mismatched prototype ...\\n\");\n\tlkdtm_indirect_call((void *)lkdtm_increment_int);\n\n\tpr_err(\"FAIL: survived mismatched prototype function call!\\n\");\n\tpr_expected_config(CONFIG_CFI_CLANG);\n}\n\n \n#ifdef CONFIG_ARM64_PTR_AUTH_KERNEL\n# ifdef CONFIG_ARM64_BTI_KERNEL\n#  define __no_pac             \"branch-protection=bti\"\n# else\n#  ifdef CONFIG_CC_HAS_BRANCH_PROT_PAC_RET\n#   define __no_pac            \"branch-protection=none\"\n#  else\n#   define __no_pac            \"sign-return-address=none\"\n#  endif\n# endif\n# define __no_ret_protection   __noscs __attribute__((__target__(__no_pac)))\n#else\n# define __no_ret_protection   __noscs\n#endif\n\n#define no_pac_addr(addr)      \\\n\t((__force __typeof__(addr))((uintptr_t)(addr) | PAGE_OFFSET))\n\n \nstatic noinline __no_ret_protection\nvoid set_return_addr_unchecked(unsigned long *expected, unsigned long *addr)\n{\n\t \n\tunsigned long * volatile *ret_addr = (unsigned long **)__builtin_frame_address(0) + 1;\n\n\t \n\tif (no_pac_addr(*ret_addr) == expected)\n\t\t*ret_addr = (addr);\n\telse\n\t\t \n\t\tpr_warn(\"Eek: return address mismatch! %px != %px\\n\",\n\t\t\t*ret_addr, addr);\n}\n\nstatic noinline\nvoid set_return_addr(unsigned long *expected, unsigned long *addr)\n{\n\t \n\tunsigned long * volatile *ret_addr = (unsigned long **)__builtin_frame_address(0) + 1;\n\n\t \n\tif (no_pac_addr(*ret_addr) == expected)\n\t\t*ret_addr = (addr);\n\telse\n\t\t \n\t\tpr_warn(\"Eek: return address mismatch! %px != %px\\n\",\n\t\t\t*ret_addr, addr);\n}\n\nstatic volatile int force_check;\n\nstatic void lkdtm_CFI_BACKWARD(void)\n{\n\t \n\tvoid *labels[] = { NULL, &&normal, &&redirected, &&check_normal, &&check_redirected };\n\n\tpr_info(\"Attempting unchecked stack return address redirection ...\\n\");\n\n\t \n\tif (force_check) {\n\t\t \n\t\tset_return_addr_unchecked(NULL, NULL);\n\t\tset_return_addr(NULL, NULL);\n\t\tif (force_check)\n\t\t\tgoto *labels[1];\n\t\tif (force_check)\n\t\t\tgoto *labels[2];\n\t\tif (force_check)\n\t\t\tgoto *labels[3];\n\t\tif (force_check)\n\t\t\tgoto *labels[4];\n\t\treturn;\n\t}\n\n\t \n\tswitch (force_check) {\n\tcase 0:\n\t\tset_return_addr_unchecked(&&normal, &&redirected);\n\t\tfallthrough;\n\tcase 1:\nnormal:\n\t\t \n\t\tif (!force_check) {\n\t\t\tpr_err(\"FAIL: stack return address manipulation failed!\\n\");\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\nredirected:\n\t\tpr_info(\"ok: redirected stack return address.\\n\");\n\t\tbreak;\n\t}\n\n\tpr_info(\"Attempting checked stack return address redirection ...\\n\");\n\n\tswitch (force_check) {\n\tcase 0:\n\t\tset_return_addr(&&check_normal, &&check_redirected);\n\t\tfallthrough;\n\tcase 1:\ncheck_normal:\n\t\t \n\t\tif (!force_check) {\n\t\t\tpr_info(\"ok: control flow unchanged.\\n\");\n\t\t\treturn;\n\t\t}\n\ncheck_redirected:\n\t\tpr_err(\"FAIL: stack return address was redirected!\\n\");\n\t\tbreak;\n\t}\n\n\tif (IS_ENABLED(CONFIG_ARM64_PTR_AUTH_KERNEL)) {\n\t\tpr_expected_config(CONFIG_ARM64_PTR_AUTH_KERNEL);\n\t\treturn;\n\t}\n\tif (IS_ENABLED(CONFIG_SHADOW_CALL_STACK)) {\n\t\tpr_expected_config(CONFIG_SHADOW_CALL_STACK);\n\t\treturn;\n\t}\n\tpr_warn(\"This is probably expected, since this %s was built *without* %s=y nor %s=y\\n\",\n\t\tlkdtm_kernel_info,\n\t\t\"CONFIG_ARM64_PTR_AUTH_KERNEL\", \"CONFIG_SHADOW_CALL_STACK\");\n}\n\nstatic struct crashtype crashtypes[] = {\n\tCRASHTYPE(CFI_FORWARD_PROTO),\n\tCRASHTYPE(CFI_BACKWARD),\n};\n\nstruct crashtype_category cfi_crashtypes = {\n\t.crashtypes = crashtypes,\n\t.len\t    = ARRAY_SIZE(crashtypes),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}