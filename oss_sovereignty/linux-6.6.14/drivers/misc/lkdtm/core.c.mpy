{
  "module_name": "core.c",
  "hash_id": "7f33001e18ff4dbb34906dec5745d20b5dc73da13d9736fb2f18f206e8077ffc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/lkdtm/core.c",
  "human_readable_source": "\n \n#include \"lkdtm.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/kprobes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/utsname.h>\n\n#define DEFAULT_COUNT 10\n\nstatic int lkdtm_debugfs_open(struct inode *inode, struct file *file);\nstatic ssize_t lkdtm_debugfs_read(struct file *f, char __user *user_buf,\n\t\tsize_t count, loff_t *off);\nstatic ssize_t direct_entry(struct file *f, const char __user *user_buf,\n\t\t\t    size_t count, loff_t *off);\n\n#ifdef CONFIG_KPROBES\nstatic int lkdtm_kprobe_handler(struct kprobe *kp, struct pt_regs *regs);\nstatic ssize_t lkdtm_debugfs_entry(struct file *f,\n\t\t\t\t   const char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *off);\n# define CRASHPOINT_KPROBE(_symbol)\t\t\t\t\\\n\t\t.kprobe = {\t\t\t\t\t\\\n\t\t\t.symbol_name = (_symbol),\t\t\\\n\t\t\t.pre_handler = lkdtm_kprobe_handler,\t\\\n\t\t},\n# define CRASHPOINT_WRITE(_symbol)\t\t\t\t\\\n\t\t(_symbol) ? lkdtm_debugfs_entry : direct_entry\n#else\n# define CRASHPOINT_KPROBE(_symbol)\n# define CRASHPOINT_WRITE(_symbol)\t\tdirect_entry\n#endif\n\n \nstruct crashpoint {\n\tconst char *name;\n\tconst struct file_operations fops;\n\tstruct kprobe kprobe;\n};\n\n#define CRASHPOINT(_name, _symbol)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.fops = {\t\t\t\t\t\\\n\t\t\t.read\t= lkdtm_debugfs_read,\t\t\\\n\t\t\t.llseek\t= generic_file_llseek,\t\t\\\n\t\t\t.open\t= lkdtm_debugfs_open,\t\t\\\n\t\t\t.write\t= CRASHPOINT_WRITE(_symbol)\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\tCRASHPOINT_KPROBE(_symbol)\t\t\t\\\n\t}\n\n \nstatic struct crashpoint crashpoints[] = {\n\tCRASHPOINT(\"DIRECT\",\t\t NULL),\n#ifdef CONFIG_KPROBES\n\tCRASHPOINT(\"INT_HARDWARE_ENTRY\", \"do_IRQ\"),\n\tCRASHPOINT(\"INT_HW_IRQ_EN\",\t \"handle_irq_event\"),\n\tCRASHPOINT(\"INT_TASKLET_ENTRY\",\t \"tasklet_action\"),\n\tCRASHPOINT(\"FS_SUBMIT_BH\",\t\t \"submit_bh\"),\n\tCRASHPOINT(\"MEM_SWAPOUT\",\t \"shrink_inactive_list\"),\n\tCRASHPOINT(\"TIMERADD\",\t\t \"hrtimer_start\"),\n\tCRASHPOINT(\"SCSI_QUEUE_RQ\",\t \"scsi_queue_rq\"),\n#endif\n};\n\n \nstatic const struct crashtype_category *crashtype_categories[] = {\n\t&bugs_crashtypes,\n\t&heap_crashtypes,\n\t&perms_crashtypes,\n\t&refcount_crashtypes,\n\t&usercopy_crashtypes,\n\t&stackleak_crashtypes,\n\t&cfi_crashtypes,\n\t&fortify_crashtypes,\n#ifdef CONFIG_PPC_64S_HASH_MMU\n\t&powerpc_crashtypes,\n#endif\n};\n\n \nstatic struct kprobe *lkdtm_kprobe;\nstatic struct crashpoint *lkdtm_crashpoint;\nstatic const struct crashtype *lkdtm_crashtype;\n\n \nstatic int recur_count = -1;\nmodule_param(recur_count, int, 0644);\nMODULE_PARM_DESC(recur_count, \" Recursion level for the stack overflow test\");\n\nstatic char* cpoint_name;\nmodule_param(cpoint_name, charp, 0444);\nMODULE_PARM_DESC(cpoint_name, \" Crash Point, where kernel is to be crashed\");\n\nstatic char* cpoint_type;\nmodule_param(cpoint_type, charp, 0444);\nMODULE_PARM_DESC(cpoint_type, \" Crash Point Type, action to be taken on \"\\\n\t\t\t\t\"hitting the crash point\");\n\nstatic int cpoint_count = DEFAULT_COUNT;\nmodule_param(cpoint_count, int, 0644);\nMODULE_PARM_DESC(cpoint_count, \" Crash Point Count, number of times the \"\\\n\t\t\t\t\"crash point is to be hit to trigger action\");\n\n \nchar *lkdtm_kernel_info;\n\n \nstatic const struct crashtype *find_crashtype(const char *name)\n{\n\tint cat, idx;\n\n\tfor (cat = 0; cat < ARRAY_SIZE(crashtype_categories); cat++) {\n\t\tfor (idx = 0; idx < crashtype_categories[cat]->len; idx++) {\n\t\t\tstruct crashtype *crashtype;\n\n\t\t\tcrashtype = &crashtype_categories[cat]->crashtypes[idx];\n\t\t\tif (!strcmp(name, crashtype->name))\n\t\t\t\treturn crashtype;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic noinline void lkdtm_do_action(const struct crashtype *crashtype)\n{\n\tif (WARN_ON(!crashtype || !crashtype->func))\n\t\treturn;\n\tcrashtype->func();\n}\n\nstatic int lkdtm_register_cpoint(struct crashpoint *crashpoint,\n\t\t\t\t const struct crashtype *crashtype)\n{\n\tint ret;\n\n\t \n\tif (!crashpoint->kprobe.symbol_name) {\n\t\tlkdtm_do_action(crashtype);\n\t\treturn 0;\n\t}\n\n\tif (lkdtm_kprobe != NULL)\n\t\tunregister_kprobe(lkdtm_kprobe);\n\n\tlkdtm_crashpoint = crashpoint;\n\tlkdtm_crashtype = crashtype;\n\tlkdtm_kprobe = &crashpoint->kprobe;\n\tret = register_kprobe(lkdtm_kprobe);\n\tif (ret < 0) {\n\t\tpr_info(\"Couldn't register kprobe %s\\n\",\n\t\t\tcrashpoint->kprobe.symbol_name);\n\t\tlkdtm_kprobe = NULL;\n\t\tlkdtm_crashpoint = NULL;\n\t\tlkdtm_crashtype = NULL;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_KPROBES\n \nstatic int crash_count = DEFAULT_COUNT;\nstatic DEFINE_SPINLOCK(crash_count_lock);\n\n \nstatic int lkdtm_kprobe_handler(struct kprobe *kp, struct pt_regs *regs)\n{\n\tunsigned long flags;\n\tbool do_it = false;\n\n\tif (WARN_ON(!lkdtm_crashpoint || !lkdtm_crashtype))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&crash_count_lock, flags);\n\tcrash_count--;\n\tpr_info(\"Crash point %s of type %s hit, trigger in %d rounds\\n\",\n\t\tlkdtm_crashpoint->name, lkdtm_crashtype->name, crash_count);\n\n\tif (crash_count == 0) {\n\t\tdo_it = true;\n\t\tcrash_count = cpoint_count;\n\t}\n\tspin_unlock_irqrestore(&crash_count_lock, flags);\n\n\tif (do_it)\n\t\tlkdtm_do_action(lkdtm_crashtype);\n\n\treturn 0;\n}\n\nstatic ssize_t lkdtm_debugfs_entry(struct file *f,\n\t\t\t\t   const char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *off)\n{\n\tstruct crashpoint *crashpoint = file_inode(f)->i_private;\n\tconst struct crashtype *crashtype = NULL;\n\tchar *buf;\n\tint err;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = (char *)__get_free_page(GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(buf, user_buf, count)) {\n\t\tfree_page((unsigned long) buf);\n\t\treturn -EFAULT;\n\t}\n\t \n\tbuf[count] = '\\0';\n\tstrim(buf);\n\n\tcrashtype = find_crashtype(buf);\n\tfree_page((unsigned long)buf);\n\n\tif (!crashtype)\n\t\treturn -EINVAL;\n\n\terr = lkdtm_register_cpoint(crashpoint, crashtype);\n\tif (err < 0)\n\t\treturn err;\n\n\t*off += count;\n\n\treturn count;\n}\n#endif\n\n \nstatic ssize_t lkdtm_debugfs_read(struct file *f, char __user *user_buf,\n\t\tsize_t count, loff_t *off)\n{\n\tint n, cat, idx;\n\tssize_t out;\n\tchar *buf;\n\n\tbuf = (char *)__get_free_page(GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tn = scnprintf(buf, PAGE_SIZE, \"Available crash types:\\n\");\n\n\tfor (cat = 0; cat < ARRAY_SIZE(crashtype_categories); cat++) {\n\t\tfor (idx = 0; idx < crashtype_categories[cat]->len; idx++) {\n\t\t\tstruct crashtype *crashtype;\n\n\t\t\tcrashtype = &crashtype_categories[cat]->crashtypes[idx];\n\t\t\tn += scnprintf(buf + n, PAGE_SIZE - n, \"%s\\n\",\n\t\t\t\t      crashtype->name);\n\t\t}\n\t}\n\tbuf[n] = '\\0';\n\n\tout = simple_read_from_buffer(user_buf, count, off,\n\t\t\t\t      buf, n);\n\tfree_page((unsigned long) buf);\n\n\treturn out;\n}\n\nstatic int lkdtm_debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\n \nstatic ssize_t direct_entry(struct file *f, const char __user *user_buf,\n\t\tsize_t count, loff_t *off)\n{\n\tconst struct crashtype *crashtype;\n\tchar *buf;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\tbuf = (char *)__get_free_page(GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(buf, user_buf, count)) {\n\t\tfree_page((unsigned long) buf);\n\t\treturn -EFAULT;\n\t}\n\t \n\tbuf[count] = '\\0';\n\tstrim(buf);\n\n\tcrashtype = find_crashtype(buf);\n\tfree_page((unsigned long) buf);\n\tif (!crashtype)\n\t\treturn -EINVAL;\n\n\tpr_info(\"Performing direct entry %s\\n\", crashtype->name);\n\tlkdtm_do_action(crashtype);\n\t*off += count;\n\n\treturn count;\n}\n\n#ifndef MODULE\n \nstruct check_cmdline_args {\n\tconst char *param;\n\tint value;\n};\n\nstatic int lkdtm_parse_one(char *param, char *val,\n\t\t\t   const char *unused, void *arg)\n{\n\tstruct check_cmdline_args *args = arg;\n\n\t \n\tif (args->value != -ESRCH)\n\t\treturn 0;\n\tif (strncmp(param, args->param, strlen(args->param)) == 0) {\n\t\tbool bool_result;\n\t\tint ret;\n\n\t\tret = kstrtobool(val, &bool_result);\n\t\tif (ret == 0)\n\t\t\targs->value = bool_result;\n\t}\n\treturn 0;\n}\n\nint lkdtm_check_bool_cmdline(const char *param)\n{\n\tchar *command_line;\n\tstruct check_cmdline_args args = {\n\t\t.param = param,\n\t\t.value = -ESRCH,\n\t};\n\n\tcommand_line = kstrdup(saved_command_line, GFP_KERNEL);\n\tif (!command_line)\n\t\treturn -ENOMEM;\n\n\tparse_args(\"Setting sysctl args\", command_line,\n\t\t   NULL, 0, -1, -1, &args, lkdtm_parse_one);\n\n\tkfree(command_line);\n\n\treturn args.value;\n}\n#endif\n\nstatic struct dentry *lkdtm_debugfs_root;\n\nstatic int __init lkdtm_module_init(void)\n{\n\tstruct crashpoint *crashpoint = NULL;\n\tconst struct crashtype *crashtype = NULL;\n\tint ret;\n\tint i;\n\n\t \n\tif ((cpoint_type || cpoint_name) && !(cpoint_type && cpoint_name)) {\n\t\tpr_err(\"Need both cpoint_type and cpoint_name or neither\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cpoint_type) {\n\t\tcrashtype = find_crashtype(cpoint_type);\n\t\tif (!crashtype) {\n\t\t\tpr_err(\"Unknown crashtype '%s'\\n\", cpoint_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (cpoint_name) {\n\t\tfor (i = 0; i < ARRAY_SIZE(crashpoints); i++) {\n\t\t\tif (!strcmp(cpoint_name, crashpoints[i].name))\n\t\t\t\tcrashpoint = &crashpoints[i];\n\t\t}\n\n\t\t \n\t\tif (!crashpoint) {\n\t\t\tpr_err(\"Invalid crashpoint %s\\n\", cpoint_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n#ifdef CONFIG_KPROBES\n\t \n\tcrash_count = cpoint_count;\n#endif\n\n\t \n\tlkdtm_kernel_info = kasprintf(GFP_KERNEL, \"kernel (%s %s)\",\n\t\t\t\t      init_uts_ns.name.release,\n\t\t\t\t      init_uts_ns.name.machine);\n\n\t \n\tlkdtm_bugs_init(&recur_count);\n\tlkdtm_perms_init();\n\tlkdtm_usercopy_init();\n\tlkdtm_heap_init();\n\n\t \n\tlkdtm_debugfs_root = debugfs_create_dir(\"provoke-crash\", NULL);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(crashpoints); i++) {\n\t\tstruct crashpoint *cur = &crashpoints[i];\n\n\t\tdebugfs_create_file(cur->name, 0644, lkdtm_debugfs_root, cur,\n\t\t\t\t    &cur->fops);\n\t}\n\n\t \n\tif (crashpoint) {\n\t\tret = lkdtm_register_cpoint(crashpoint, crashtype);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"Invalid crashpoint %s\\n\", crashpoint->name);\n\t\t\tgoto out_err;\n\t\t}\n\t\tpr_info(\"Crash point %s of type %s registered\\n\",\n\t\t\tcrashpoint->name, cpoint_type);\n\t} else {\n\t\tpr_info(\"No crash points registered, enable through debugfs\\n\");\n\t}\n\n\treturn 0;\n\nout_err:\n\tdebugfs_remove_recursive(lkdtm_debugfs_root);\n\treturn ret;\n}\n\nstatic void __exit lkdtm_module_exit(void)\n{\n\tdebugfs_remove_recursive(lkdtm_debugfs_root);\n\n\t \n\tlkdtm_heap_exit();\n\tlkdtm_usercopy_exit();\n\n\tif (lkdtm_kprobe != NULL)\n\t\tunregister_kprobe(lkdtm_kprobe);\n\n\tkfree(lkdtm_kernel_info);\n\n\tpr_info(\"Crash point unregistered\\n\");\n}\n\nmodule_init(lkdtm_module_init);\nmodule_exit(lkdtm_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Kernel crash testing module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}