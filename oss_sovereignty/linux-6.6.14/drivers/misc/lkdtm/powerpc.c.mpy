{
  "module_name": "powerpc.c",
  "hash_id": "cd00fd28af5d87b259454a78be6516d239414d047a46574cefe164dfc11af440",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/lkdtm/powerpc.c",
  "human_readable_source": "\n\n#include \"lkdtm.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <asm/mmu.h>\n\n \nstatic void insert_slb_entry(unsigned long p, int ssize, int page_size)\n{\n\tunsigned long flags;\n\n\tflags = SLB_VSID_KERNEL | mmu_psize_defs[page_size].sllp;\n\tpreempt_disable();\n\n\tasm volatile(\"slbmte %0,%1\" :\n\t\t     : \"r\" (mk_vsid_data(p, ssize, flags)),\n\t\t       \"r\" (mk_esid_data(p, ssize, SLB_NUM_BOLTED))\n\t\t     : \"memory\");\n\n\tasm volatile(\"slbmte %0,%1\" :\n\t\t\t: \"r\" (mk_vsid_data(p, ssize, flags)),\n\t\t\t  \"r\" (mk_esid_data(p, ssize, SLB_NUM_BOLTED + 1))\n\t\t\t: \"memory\");\n\tpreempt_enable();\n}\n\n \nstatic int inject_vmalloc_slb_multihit(void)\n{\n\tchar *p;\n\n\tp = vmalloc(PAGE_SIZE);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tinsert_slb_entry((unsigned long)p, MMU_SEGSIZE_1T, mmu_vmalloc_psize);\n\t \n\tp[0] = '!';\n\tvfree(p);\n\treturn 0;\n}\n\n \nstatic int inject_kmalloc_slb_multihit(void)\n{\n\tchar *p;\n\n\tp = kmalloc(2048, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tinsert_slb_entry((unsigned long)p, MMU_SEGSIZE_1T, mmu_linear_psize);\n\t \n\tp[0] = '!';\n\tkfree(p);\n\treturn 0;\n}\n\n \nstatic void insert_dup_slb_entry_0(void)\n{\n\tunsigned long test_address = PAGE_OFFSET, *test_ptr;\n\tunsigned long esid, vsid;\n\tunsigned long i = 0;\n\n\ttest_ptr = (unsigned long *)test_address;\n\tpreempt_disable();\n\n\tasm volatile(\"slbmfee  %0,%1\" : \"=r\" (esid) : \"r\" (i));\n\tasm volatile(\"slbmfev  %0,%1\" : \"=r\" (vsid) : \"r\" (i));\n\n\t \n\tasm volatile(\"slbmte %0,%1\" :\n\t\t\t: \"r\" (vsid),\n\t\t\t  \"r\" (esid | SLB_NUM_BOLTED)\n\t\t\t: \"memory\");\n\n\tasm volatile(\"slbmfee  %0,%1\" : \"=r\" (esid) : \"r\" (i));\n\tasm volatile(\"slbmfev  %0,%1\" : \"=r\" (vsid) : \"r\" (i));\n\n\t \n\tasm volatile(\"slbmte %0,%1\" :\n\t\t\t: \"r\" (vsid),\n\t\t\t  \"r\" (esid | (SLB_NUM_BOLTED + 1))\n\t\t\t: \"memory\");\n\n\tpr_info(\"%s accessing test address 0x%lx: 0x%lx\\n\",\n\t\t__func__, test_address, *test_ptr);\n\n\tpreempt_enable();\n}\n\nstatic void lkdtm_PPC_SLB_MULTIHIT(void)\n{\n\tif (!radix_enabled()) {\n\t\tpr_info(\"Injecting SLB multihit errors\\n\");\n\t\t \n\t\tinject_vmalloc_slb_multihit();\n\t\tinject_kmalloc_slb_multihit();\n\t\tinsert_dup_slb_entry_0();\n\t\tpr_info(\"Recovered from SLB multihit errors\\n\");\n\t} else {\n\t\tpr_err(\"XFAIL: This test is for ppc64 and with hash mode MMU only\\n\");\n\t}\n}\n\nstatic struct crashtype crashtypes[] = {\n\tCRASHTYPE(PPC_SLB_MULTIHIT),\n};\n\nstruct crashtype_category powerpc_crashtypes = {\n\t.crashtypes = crashtypes,\n\t.len\t    = ARRAY_SIZE(crashtypes),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}