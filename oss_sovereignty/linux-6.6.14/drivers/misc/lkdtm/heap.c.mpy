{
  "module_name": "heap.c",
  "hash_id": "8c1ab007c616652a734cb0669bc6debd8a8c99333e3c6a9b2a15f4fa7af40d00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/lkdtm/heap.c",
  "human_readable_source": "\n \n#include \"lkdtm.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/sched.h>\n\nstatic struct kmem_cache *double_free_cache;\nstatic struct kmem_cache *a_cache;\nstatic struct kmem_cache *b_cache;\n\n \nstatic volatile int __offset = 1;\n\n \nstatic void lkdtm_VMALLOC_LINEAR_OVERFLOW(void)\n{\n\tchar *one, *two;\n\n\tone = vzalloc(PAGE_SIZE);\n\tOPTIMIZER_HIDE_VAR(one);\n\ttwo = vzalloc(PAGE_SIZE);\n\n\tpr_info(\"Attempting vmalloc linear overflow ...\\n\");\n\tmemset(one, 0xAA, PAGE_SIZE + __offset);\n\n\tvfree(two);\n\tvfree(one);\n}\n\n \nstatic void lkdtm_SLAB_LINEAR_OVERFLOW(void)\n{\n\tsize_t len = 1020;\n\tu32 *data = kmalloc(len, GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\tpr_info(\"Attempting slab linear overflow ...\\n\");\n\tOPTIMIZER_HIDE_VAR(data);\n\tdata[1024 / sizeof(u32)] = 0x12345678;\n\tkfree(data);\n}\n\nstatic void lkdtm_WRITE_AFTER_FREE(void)\n{\n\tint *base, *again;\n\tsize_t len = 1024;\n\t \n\tsize_t offset = (len / sizeof(*base)) / 2;\n\n\tbase = kmalloc(len, GFP_KERNEL);\n\tif (!base)\n\t\treturn;\n\tpr_info(\"Allocated memory %p-%p\\n\", base, &base[offset * 2]);\n\tpr_info(\"Attempting bad write to freed memory at %p\\n\",\n\t\t&base[offset]);\n\tkfree(base);\n\tbase[offset] = 0x0abcdef0;\n\t \n\tagain = kmalloc(len, GFP_KERNEL);\n\tkfree(again);\n\tif (again != base)\n\t\tpr_info(\"Hmm, didn't get the same memory range.\\n\");\n}\n\nstatic void lkdtm_READ_AFTER_FREE(void)\n{\n\tint *base, *val, saw;\n\tsize_t len = 1024;\n\t \n\tsize_t offset = sizeof(*base);\n\n\tbase = kmalloc(len, GFP_KERNEL);\n\tif (!base) {\n\t\tpr_info(\"Unable to allocate base memory.\\n\");\n\t\treturn;\n\t}\n\n\tval = kmalloc(len, GFP_KERNEL);\n\tif (!val) {\n\t\tpr_info(\"Unable to allocate val memory.\\n\");\n\t\tkfree(base);\n\t\treturn;\n\t}\n\n\t*val = 0x12345678;\n\tbase[offset] = *val;\n\tpr_info(\"Value in memory before free: %x\\n\", base[offset]);\n\n\tkfree(base);\n\n\tpr_info(\"Attempting bad read from freed memory\\n\");\n\tsaw = base[offset];\n\tif (saw != *val) {\n\t\t \n\t\tpr_info(\"Memory correctly poisoned (%x)\\n\", saw);\n\t} else {\n\t\tpr_err(\"FAIL: Memory was not poisoned!\\n\");\n\t\tpr_expected_config_param(CONFIG_INIT_ON_FREE_DEFAULT_ON, \"init_on_free\");\n\t}\n\n\tkfree(val);\n}\n\nstatic void lkdtm_WRITE_BUDDY_AFTER_FREE(void)\n{\n\tunsigned long p = __get_free_page(GFP_KERNEL);\n\tif (!p) {\n\t\tpr_info(\"Unable to allocate free page\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"Writing to the buddy page before free\\n\");\n\tmemset((void *)p, 0x3, PAGE_SIZE);\n\tfree_page(p);\n\tschedule();\n\tpr_info(\"Attempting bad write to the buddy page after free\\n\");\n\tmemset((void *)p, 0x78, PAGE_SIZE);\n\t \n\tp = __get_free_page(GFP_KERNEL);\n\tfree_page(p);\n\tschedule();\n}\n\nstatic void lkdtm_READ_BUDDY_AFTER_FREE(void)\n{\n\tunsigned long p = __get_free_page(GFP_KERNEL);\n\tint saw, *val;\n\tint *base;\n\n\tif (!p) {\n\t\tpr_info(\"Unable to allocate free page\\n\");\n\t\treturn;\n\t}\n\n\tval = kmalloc(1024, GFP_KERNEL);\n\tif (!val) {\n\t\tpr_info(\"Unable to allocate val memory.\\n\");\n\t\tfree_page(p);\n\t\treturn;\n\t}\n\n\tbase = (int *)p;\n\n\t*val = 0x12345678;\n\tbase[0] = *val;\n\tpr_info(\"Value in memory before free: %x\\n\", base[0]);\n\tfree_page(p);\n\tpr_info(\"Attempting to read from freed memory\\n\");\n\tsaw = base[0];\n\tif (saw != *val) {\n\t\t \n\t\tpr_info(\"Memory correctly poisoned (%x)\\n\", saw);\n\t} else {\n\t\tpr_err(\"FAIL: Buddy page was not poisoned!\\n\");\n\t\tpr_expected_config_param(CONFIG_INIT_ON_FREE_DEFAULT_ON, \"init_on_free\");\n\t}\n\n\tkfree(val);\n}\n\nstatic void lkdtm_SLAB_INIT_ON_ALLOC(void)\n{\n\tu8 *first;\n\tu8 *val;\n\n\tfirst = kmalloc(512, GFP_KERNEL);\n\tif (!first) {\n\t\tpr_info(\"Unable to allocate 512 bytes the first time.\\n\");\n\t\treturn;\n\t}\n\n\tmemset(first, 0xAB, 512);\n\tkfree(first);\n\n\tval = kmalloc(512, GFP_KERNEL);\n\tif (!val) {\n\t\tpr_info(\"Unable to allocate 512 bytes the second time.\\n\");\n\t\treturn;\n\t}\n\tif (val != first) {\n\t\tpr_warn(\"Reallocation missed clobbered memory.\\n\");\n\t}\n\n\tif (memchr(val, 0xAB, 512) == NULL) {\n\t\tpr_info(\"Memory appears initialized (%x, no earlier values)\\n\", *val);\n\t} else {\n\t\tpr_err(\"FAIL: Slab was not initialized\\n\");\n\t\tpr_expected_config_param(CONFIG_INIT_ON_ALLOC_DEFAULT_ON, \"init_on_alloc\");\n\t}\n\tkfree(val);\n}\n\nstatic void lkdtm_BUDDY_INIT_ON_ALLOC(void)\n{\n\tu8 *first;\n\tu8 *val;\n\n\tfirst = (u8 *)__get_free_page(GFP_KERNEL);\n\tif (!first) {\n\t\tpr_info(\"Unable to allocate first free page\\n\");\n\t\treturn;\n\t}\n\n\tmemset(first, 0xAB, PAGE_SIZE);\n\tfree_page((unsigned long)first);\n\n\tval = (u8 *)__get_free_page(GFP_KERNEL);\n\tif (!val) {\n\t\tpr_info(\"Unable to allocate second free page\\n\");\n\t\treturn;\n\t}\n\n\tif (val != first) {\n\t\tpr_warn(\"Reallocation missed clobbered memory.\\n\");\n\t}\n\n\tif (memchr(val, 0xAB, PAGE_SIZE) == NULL) {\n\t\tpr_info(\"Memory appears initialized (%x, no earlier values)\\n\", *val);\n\t} else {\n\t\tpr_err(\"FAIL: Slab was not initialized\\n\");\n\t\tpr_expected_config_param(CONFIG_INIT_ON_ALLOC_DEFAULT_ON, \"init_on_alloc\");\n\t}\n\tfree_page((unsigned long)val);\n}\n\nstatic void lkdtm_SLAB_FREE_DOUBLE(void)\n{\n\tint *val;\n\n\tval = kmem_cache_alloc(double_free_cache, GFP_KERNEL);\n\tif (!val) {\n\t\tpr_info(\"Unable to allocate double_free_cache memory.\\n\");\n\t\treturn;\n\t}\n\n\t \n\t*val = 0x12345678;\n\tpr_info(\"Attempting double slab free ...\\n\");\n\tkmem_cache_free(double_free_cache, val);\n\tkmem_cache_free(double_free_cache, val);\n}\n\nstatic void lkdtm_SLAB_FREE_CROSS(void)\n{\n\tint *val;\n\n\tval = kmem_cache_alloc(a_cache, GFP_KERNEL);\n\tif (!val) {\n\t\tpr_info(\"Unable to allocate a_cache memory.\\n\");\n\t\treturn;\n\t}\n\n\t \n\t*val = 0x12345679;\n\tpr_info(\"Attempting cross-cache slab free ...\\n\");\n\tkmem_cache_free(b_cache, val);\n}\n\nstatic void lkdtm_SLAB_FREE_PAGE(void)\n{\n\tunsigned long p = __get_free_page(GFP_KERNEL);\n\n\tpr_info(\"Attempting non-Slab slab free ...\\n\");\n\tkmem_cache_free(NULL, (void *)p);\n\tfree_page(p);\n}\n\n \nstatic void ctor_double_free(void *region)\n{ }\nstatic void ctor_a(void *region)\n{ }\nstatic void ctor_b(void *region)\n{ }\n\nvoid __init lkdtm_heap_init(void)\n{\n\tdouble_free_cache = kmem_cache_create(\"lkdtm-heap-double_free\",\n\t\t\t\t\t      64, 0, 0, ctor_double_free);\n\ta_cache = kmem_cache_create(\"lkdtm-heap-a\", 64, 0, 0, ctor_a);\n\tb_cache = kmem_cache_create(\"lkdtm-heap-b\", 64, 0, 0, ctor_b);\n}\n\nvoid __exit lkdtm_heap_exit(void)\n{\n\tkmem_cache_destroy(double_free_cache);\n\tkmem_cache_destroy(a_cache);\n\tkmem_cache_destroy(b_cache);\n}\n\nstatic struct crashtype crashtypes[] = {\n\tCRASHTYPE(SLAB_LINEAR_OVERFLOW),\n\tCRASHTYPE(VMALLOC_LINEAR_OVERFLOW),\n\tCRASHTYPE(WRITE_AFTER_FREE),\n\tCRASHTYPE(READ_AFTER_FREE),\n\tCRASHTYPE(WRITE_BUDDY_AFTER_FREE),\n\tCRASHTYPE(READ_BUDDY_AFTER_FREE),\n\tCRASHTYPE(SLAB_INIT_ON_ALLOC),\n\tCRASHTYPE(BUDDY_INIT_ON_ALLOC),\n\tCRASHTYPE(SLAB_FREE_DOUBLE),\n\tCRASHTYPE(SLAB_FREE_CROSS),\n\tCRASHTYPE(SLAB_FREE_PAGE),\n};\n\nstruct crashtype_category heap_crashtypes = {\n\t.crashtypes = crashtypes,\n\t.len\t    = ARRAY_SIZE(crashtypes),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}