{
  "module_name": "stackleak.c",
  "hash_id": "05228284db4f07da71485bab452c2de690a1b7f92ebd9b9dfed8f1015a3dea35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/lkdtm/stackleak.c",
  "human_readable_source": "\n \n\n#include \"lkdtm.h\"\n#include <linux/stackleak.h>\n\n#if defined(CONFIG_GCC_PLUGIN_STACKLEAK)\n \nstatic void noinstr check_stackleak_irqoff(void)\n{\n\tconst unsigned long task_stack_base = (unsigned long)task_stack_page(current);\n\tconst unsigned long task_stack_low = stackleak_task_low_bound(current);\n\tconst unsigned long task_stack_high = stackleak_task_high_bound(current);\n\tconst unsigned long current_sp = current_stack_pointer;\n\tconst unsigned long lowest_sp = current->lowest_stack;\n\tunsigned long untracked_high;\n\tunsigned long poison_high, poison_low;\n\tbool test_failed = false;\n\n\t \n\tif (current_sp < task_stack_low || current_sp >= task_stack_high) {\n\t\tinstrumentation_begin();\n\t\tpr_err(\"FAIL: current_stack_pointer (0x%lx) outside of task stack bounds [0x%lx..0x%lx]\\n\",\n\t\t       current_sp, task_stack_low, task_stack_high - 1);\n\t\ttest_failed = true;\n\t\tgoto out;\n\t}\n\tif (lowest_sp < task_stack_low || lowest_sp >= task_stack_high) {\n\t\tinstrumentation_begin();\n\t\tpr_err(\"FAIL: current->lowest_stack (0x%lx) outside of task stack bounds [0x%lx..0x%lx]\\n\",\n\t\t       lowest_sp, task_stack_low, task_stack_high - 1);\n\t\ttest_failed = true;\n\t\tgoto out;\n\t}\n\n\t \n\tuntracked_high = min(current_sp, lowest_sp);\n\tuntracked_high = ALIGN_DOWN(untracked_high, sizeof(unsigned long));\n\n\t \n\tpoison_high = stackleak_find_top_of_poison(task_stack_low, untracked_high);\n\n\t \n\tpoison_low = poison_high;\n\twhile (poison_low > task_stack_low) {\n\t\tpoison_low -= sizeof(unsigned long);\n\n\t\tif (*(unsigned long *)poison_low == STACKLEAK_POISON)\n\t\t\tcontinue;\n\n\t\tinstrumentation_begin();\n\t\tpr_err(\"FAIL: non-poison value %lu bytes below poison boundary: 0x%lx\\n\",\n\t\t       poison_high - poison_low, *(unsigned long *)poison_low);\n\t\ttest_failed = true;\n\t\tgoto out;\n\t}\n\n\tinstrumentation_begin();\n\tpr_info(\"stackleak stack usage:\\n\"\n\t\t\"  high offset: %lu bytes\\n\"\n\t\t\"  current:     %lu bytes\\n\"\n\t\t\"  lowest:      %lu bytes\\n\"\n\t\t\"  tracked:     %lu bytes\\n\"\n\t\t\"  untracked:   %lu bytes\\n\"\n\t\t\"  poisoned:    %lu bytes\\n\"\n\t\t\"  low offset:  %lu bytes\\n\",\n\t\ttask_stack_base + THREAD_SIZE - task_stack_high,\n\t\ttask_stack_high - current_sp,\n\t\ttask_stack_high - lowest_sp,\n\t\ttask_stack_high - untracked_high,\n\t\tuntracked_high - poison_high,\n\t\tpoison_high - task_stack_low,\n\t\ttask_stack_low - task_stack_base);\n\nout:\n\tif (test_failed) {\n\t\tpr_err(\"FAIL: the thread stack is NOT properly erased!\\n\");\n\t} else {\n\t\tpr_info(\"OK: the rest of the thread stack is properly erased\\n\");\n\t}\n\tinstrumentation_end();\n}\n\nstatic void lkdtm_STACKLEAK_ERASING(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tcheck_stackleak_irqoff();\n\tlocal_irq_restore(flags);\n}\n#else  \nstatic void lkdtm_STACKLEAK_ERASING(void)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_ARCH_STACKLEAK)) {\n\t\tpr_err(\"XFAIL: stackleak is not enabled (CONFIG_GCC_PLUGIN_STACKLEAK=n)\\n\");\n\t} else {\n\t\tpr_err(\"XFAIL: stackleak is not supported on this arch (HAVE_ARCH_STACKLEAK=n)\\n\");\n\t}\n}\n#endif  \n\nstatic struct crashtype crashtypes[] = {\n\tCRASHTYPE(STACKLEAK_ERASING),\n};\n\nstruct crashtype_category stackleak_crashtypes = {\n\t.crashtypes = crashtypes,\n\t.len\t    = ARRAY_SIZE(crashtypes),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}