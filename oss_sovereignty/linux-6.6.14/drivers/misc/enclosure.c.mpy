{
  "module_name": "enclosure.c",
  "hash_id": "534f0d79a3a9d5483afd4c0530caa4904a33388c9b6e377e634f3f0801fba4d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/enclosure.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/enclosure.h>\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\nstatic LIST_HEAD(container_list);\nstatic DEFINE_MUTEX(container_list_lock);\nstatic struct class enclosure_class;\n\n \nstruct enclosure_device *enclosure_find(struct device *dev,\n\t\t\t\t\tstruct enclosure_device *start)\n{\n\tstruct enclosure_device *edev;\n\n\tmutex_lock(&container_list_lock);\n\tedev = list_prepare_entry(start, &container_list, node);\n\tif (start)\n\t\tput_device(&start->edev);\n\n\tlist_for_each_entry_continue(edev, &container_list, node) {\n\t\tstruct device *parent = edev->edev.parent;\n\t\t \n\t\twhile (parent) {\n\t\t\tif (parent == dev) {\n\t\t\t\tget_device(&edev->edev);\n\t\t\t\tmutex_unlock(&container_list_lock);\n\t\t\t\treturn edev;\n\t\t\t}\n\t\t\tparent = parent->parent;\n\t\t}\n\t}\n\tmutex_unlock(&container_list_lock);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(enclosure_find);\n\n \nint enclosure_for_each_device(int (*fn)(struct enclosure_device *, void *),\n\t\t\t      void *data)\n{\n\tint error = 0;\n\tstruct enclosure_device *edev;\n\n\tmutex_lock(&container_list_lock);\n\tlist_for_each_entry(edev, &container_list, node) {\n\t\terror = fn(edev, data);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&container_list_lock);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(enclosure_for_each_device);\n\n \nstruct enclosure_device *\nenclosure_register(struct device *dev, const char *name, int components,\n\t\t   struct enclosure_component_callbacks *cb)\n{\n\tstruct enclosure_device *edev =\n\t\tkzalloc(struct_size(edev, component, components), GFP_KERNEL);\n\tint err, i;\n\n\tBUG_ON(!cb);\n\n\tif (!edev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tedev->components = components;\n\n\tedev->edev.class = &enclosure_class;\n\tedev->edev.parent = get_device(dev);\n\tedev->cb = cb;\n\tdev_set_name(&edev->edev, \"%s\", name);\n\terr = device_register(&edev->edev);\n\tif (err)\n\t\tgoto err;\n\n\tfor (i = 0; i < components; i++) {\n\t\tedev->component[i].number = -1;\n\t\tedev->component[i].slot = -1;\n\t\tedev->component[i].power_status = -1;\n\t}\n\n\tmutex_lock(&container_list_lock);\n\tlist_add_tail(&edev->node, &container_list);\n\tmutex_unlock(&container_list_lock);\n\n\treturn edev;\n\n err:\n\tput_device(edev->edev.parent);\n\tkfree(edev);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(enclosure_register);\n\nstatic struct enclosure_component_callbacks enclosure_null_callbacks;\n\n \nvoid enclosure_unregister(struct enclosure_device *edev)\n{\n\tint i;\n\n\tmutex_lock(&container_list_lock);\n\tlist_del(&edev->node);\n\tmutex_unlock(&container_list_lock);\n\n\tfor (i = 0; i < edev->components; i++)\n\t\tif (edev->component[i].number != -1)\n\t\t\tdevice_unregister(&edev->component[i].cdev);\n\n\t \n\tedev->cb = &enclosure_null_callbacks;\n\tdevice_unregister(&edev->edev);\n}\nEXPORT_SYMBOL_GPL(enclosure_unregister);\n\n#define ENCLOSURE_NAME_SIZE\t64\n#define COMPONENT_NAME_SIZE\t64\n\nstatic void enclosure_link_name(struct enclosure_component *cdev, char *name)\n{\n\tstrcpy(name, \"enclosure_device:\");\n\tstrcat(name, dev_name(&cdev->cdev));\n}\n\nstatic void enclosure_remove_links(struct enclosure_component *cdev)\n{\n\tchar name[ENCLOSURE_NAME_SIZE];\n\n\tenclosure_link_name(cdev, name);\n\n\t \n\tif (cdev->dev->kobj.sd)\n\t\tsysfs_remove_link(&cdev->dev->kobj, name);\n\n\tif (cdev->cdev.kobj.sd)\n\t\tsysfs_remove_link(&cdev->cdev.kobj, \"device\");\n}\n\nstatic int enclosure_add_links(struct enclosure_component *cdev)\n{\n\tint error;\n\tchar name[ENCLOSURE_NAME_SIZE];\n\n\terror = sysfs_create_link(&cdev->cdev.kobj, &cdev->dev->kobj, \"device\");\n\tif (error)\n\t\treturn error;\n\n\tenclosure_link_name(cdev, name);\n\terror = sysfs_create_link(&cdev->dev->kobj, &cdev->cdev.kobj, name);\n\tif (error)\n\t\tsysfs_remove_link(&cdev->cdev.kobj, \"device\");\n\n\treturn error;\n}\n\nstatic void enclosure_release(struct device *cdev)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev);\n\n\tput_device(cdev->parent);\n\tkfree(edev);\n}\n\nstatic void enclosure_component_release(struct device *dev)\n{\n\tstruct enclosure_component *cdev = to_enclosure_component(dev);\n\n\tif (cdev->dev) {\n\t\tenclosure_remove_links(cdev);\n\t\tput_device(cdev->dev);\n\t}\n\tput_device(dev->parent);\n}\n\nstatic struct enclosure_component *\nenclosure_component_find_by_name(struct enclosure_device *edev,\n\t\t\t\tconst char *name)\n{\n\tint i;\n\tconst char *cname;\n\tstruct enclosure_component *ecomp;\n\n\tif (!edev || !name || !name[0])\n\t\treturn NULL;\n\n\tfor (i = 0; i < edev->components; i++) {\n\t\tecomp = &edev->component[i];\n\t\tcname = dev_name(&ecomp->cdev);\n\t\tif (ecomp->number != -1 &&\n\t\t    cname && cname[0] &&\n\t\t    !strcmp(cname, name))\n\t\t\treturn ecomp;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct attribute_group *enclosure_component_groups[];\n\n \nstruct enclosure_component *\nenclosure_component_alloc(struct enclosure_device *edev,\n\t\t\t  unsigned int number,\n\t\t\t  enum enclosure_component_type type,\n\t\t\t  const char *name)\n{\n\tstruct enclosure_component *ecomp;\n\tstruct device *cdev;\n\tint i;\n\tchar newname[COMPONENT_NAME_SIZE];\n\n\tif (number >= edev->components)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tecomp = &edev->component[number];\n\n\tif (ecomp->number != -1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tecomp->type = type;\n\tecomp->number = number;\n\tcdev = &ecomp->cdev;\n\tcdev->parent = get_device(&edev->edev);\n\n\tif (name && name[0]) {\n\t\t \n\t\ti = 1;\n\t\tsnprintf(newname, COMPONENT_NAME_SIZE,\n\t\t\t \"%s\", name);\n\t\twhile (enclosure_component_find_by_name(edev, newname))\n\t\t\tsnprintf(newname, COMPONENT_NAME_SIZE,\n\t\t\t\t \"%s-%i\", name, i++);\n\t\tdev_set_name(cdev, \"%s\", newname);\n\t} else\n\t\tdev_set_name(cdev, \"%u\", number);\n\n\tcdev->release = enclosure_component_release;\n\tcdev->groups = enclosure_component_groups;\n\n\treturn ecomp;\n}\nEXPORT_SYMBOL_GPL(enclosure_component_alloc);\n\n \nint enclosure_component_register(struct enclosure_component *ecomp)\n{\n\tstruct device *cdev;\n\tint err;\n\n\tcdev = &ecomp->cdev;\n\terr = device_register(cdev);\n\tif (err) {\n\t\tecomp->number = -1;\n\t\tput_device(cdev);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(enclosure_component_register);\n\n \nint enclosure_add_device(struct enclosure_device *edev, int component,\n\t\t\t struct device *dev)\n{\n\tstruct enclosure_component *cdev;\n\tint err;\n\n\tif (!edev || component >= edev->components)\n\t\treturn -EINVAL;\n\n\tcdev = &edev->component[component];\n\n\tif (cdev->dev == dev)\n\t\treturn -EEXIST;\n\n\tif (cdev->dev) {\n\t\tenclosure_remove_links(cdev);\n\t\tput_device(cdev->dev);\n\t}\n\tcdev->dev = get_device(dev);\n\terr = enclosure_add_links(cdev);\n\tif (err) {\n\t\tput_device(cdev->dev);\n\t\tcdev->dev = NULL;\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(enclosure_add_device);\n\n \nint enclosure_remove_device(struct enclosure_device *edev, struct device *dev)\n{\n\tstruct enclosure_component *cdev;\n\tint i;\n\n\tif (!edev || !dev)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < edev->components; i++) {\n\t\tcdev = &edev->component[i];\n\t\tif (cdev->dev == dev) {\n\t\t\tenclosure_remove_links(cdev);\n\t\t\tput_device(dev);\n\t\t\tcdev->dev = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(enclosure_remove_device);\n\n \n\nstatic ssize_t components_show(struct device *cdev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", edev->components);\n}\nstatic DEVICE_ATTR_RO(components);\n\nstatic ssize_t id_show(struct device *cdev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev);\n\n\tif (edev->cb->show_id)\n\t\treturn edev->cb->show_id(edev, buf);\n\treturn -EINVAL;\n}\nstatic DEVICE_ATTR_RO(id);\n\nstatic struct attribute *enclosure_class_attrs[] = {\n\t&dev_attr_components.attr,\n\t&dev_attr_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(enclosure_class);\n\nstatic struct class enclosure_class = {\n\t.name\t\t\t= \"enclosure\",\n\t.dev_release\t\t= enclosure_release,\n\t.dev_groups\t\t= enclosure_class_groups,\n};\n\nstatic const char *const enclosure_status[] = {\n\t[ENCLOSURE_STATUS_UNSUPPORTED] = \"unsupported\",\n\t[ENCLOSURE_STATUS_OK] = \"OK\",\n\t[ENCLOSURE_STATUS_CRITICAL] = \"critical\",\n\t[ENCLOSURE_STATUS_NON_CRITICAL] = \"non-critical\",\n\t[ENCLOSURE_STATUS_UNRECOVERABLE] = \"unrecoverable\",\n\t[ENCLOSURE_STATUS_NOT_INSTALLED] = \"not installed\",\n\t[ENCLOSURE_STATUS_UNKNOWN] = \"unknown\",\n\t[ENCLOSURE_STATUS_UNAVAILABLE] = \"unavailable\",\n\t[ENCLOSURE_STATUS_MAX] = NULL,\n};\n\nstatic const char *const enclosure_type[] = {\n\t[ENCLOSURE_COMPONENT_DEVICE] = \"device\",\n\t[ENCLOSURE_COMPONENT_ARRAY_DEVICE] = \"array device\",\n};\n\nstatic ssize_t get_component_fault(struct device *cdev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\n\tif (edev->cb->get_fault)\n\t\tedev->cb->get_fault(edev, ecomp);\n\treturn sysfs_emit(buf, \"%d\\n\", ecomp->fault);\n}\n\nstatic ssize_t set_component_fault(struct device *cdev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\tint val = simple_strtoul(buf, NULL, 0);\n\n\tif (edev->cb->set_fault)\n\t\tedev->cb->set_fault(edev, ecomp, val);\n\treturn count;\n}\n\nstatic ssize_t get_component_status(struct device *cdev,\n\t\t\t\t    struct device_attribute *attr,char *buf)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\n\tif (edev->cb->get_status)\n\t\tedev->cb->get_status(edev, ecomp);\n\treturn sysfs_emit(buf, \"%s\\n\", enclosure_status[ecomp->status]);\n}\n\nstatic ssize_t set_component_status(struct device *cdev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\tint i;\n\n\tfor (i = 0; enclosure_status[i]; i++) {\n\t\tif (strncmp(buf, enclosure_status[i],\n\t\t\t    strlen(enclosure_status[i])) == 0 &&\n\t\t    (buf[strlen(enclosure_status[i])] == '\\n' ||\n\t\t     buf[strlen(enclosure_status[i])] == '\\0'))\n\t\t\tbreak;\n\t}\n\n\tif (enclosure_status[i] && edev->cb->set_status) {\n\t\tedev->cb->set_status(edev, ecomp, i);\n\t\treturn count;\n\t} else\n\t\treturn -EINVAL;\n}\n\nstatic ssize_t get_component_active(struct device *cdev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\n\tif (edev->cb->get_active)\n\t\tedev->cb->get_active(edev, ecomp);\n\treturn sysfs_emit(buf, \"%d\\n\", ecomp->active);\n}\n\nstatic ssize_t set_component_active(struct device *cdev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\tint val = simple_strtoul(buf, NULL, 0);\n\n\tif (edev->cb->set_active)\n\t\tedev->cb->set_active(edev, ecomp, val);\n\treturn count;\n}\n\nstatic ssize_t get_component_locate(struct device *cdev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\n\tif (edev->cb->get_locate)\n\t\tedev->cb->get_locate(edev, ecomp);\n\treturn sysfs_emit(buf, \"%d\\n\", ecomp->locate);\n}\n\nstatic ssize_t set_component_locate(struct device *cdev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\tint val = simple_strtoul(buf, NULL, 0);\n\n\tif (edev->cb->set_locate)\n\t\tedev->cb->set_locate(edev, ecomp, val);\n\treturn count;\n}\n\nstatic ssize_t get_component_power_status(struct device *cdev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\n\tif (edev->cb->get_power_status)\n\t\tedev->cb->get_power_status(edev, ecomp);\n\n\t \n\tif (ecomp->power_status == -1)\n\t\treturn (edev->cb->get_power_status) ? -EIO : -ENOTTY;\n\n\treturn sysfs_emit(buf, \"%s\\n\", ecomp->power_status ? \"on\" : \"off\");\n}\n\nstatic ssize_t set_component_power_status(struct device *cdev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\tint val;\n\n\tif (strncmp(buf, \"on\", 2) == 0 &&\n\t    (buf[2] == '\\n' || buf[2] == '\\0'))\n\t\tval = 1;\n\telse if (strncmp(buf, \"off\", 3) == 0 &&\n\t    (buf[3] == '\\n' || buf[3] == '\\0'))\n\t\tval = 0;\n\telse\n\t\treturn -EINVAL;\n\n\tif (edev->cb->set_power_status)\n\t\tedev->cb->set_power_status(edev, ecomp, val);\n\treturn count;\n}\n\nstatic ssize_t get_component_type(struct device *cdev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", enclosure_type[ecomp->type]);\n}\n\nstatic ssize_t get_component_slot(struct device *cdev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct enclosure_component *ecomp = to_enclosure_component(cdev);\n\tint slot;\n\n\t \n\tif (ecomp->slot >= 0)\n\t\tslot = ecomp->slot;\n\telse\n\t\tslot = ecomp->number;\n\n\treturn sysfs_emit(buf, \"%d\\n\", slot);\n}\n\nstatic DEVICE_ATTR(fault, S_IRUGO | S_IWUSR, get_component_fault,\n\t\t    set_component_fault);\nstatic DEVICE_ATTR(status, S_IRUGO | S_IWUSR, get_component_status,\n\t\t   set_component_status);\nstatic DEVICE_ATTR(active, S_IRUGO | S_IWUSR, get_component_active,\n\t\t   set_component_active);\nstatic DEVICE_ATTR(locate, S_IRUGO | S_IWUSR, get_component_locate,\n\t\t   set_component_locate);\nstatic DEVICE_ATTR(power_status, S_IRUGO | S_IWUSR, get_component_power_status,\n\t\t   set_component_power_status);\nstatic DEVICE_ATTR(type, S_IRUGO, get_component_type, NULL);\nstatic DEVICE_ATTR(slot, S_IRUGO, get_component_slot, NULL);\n\nstatic struct attribute *enclosure_component_attrs[] = {\n\t&dev_attr_fault.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_active.attr,\n\t&dev_attr_locate.attr,\n\t&dev_attr_power_status.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_slot.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(enclosure_component);\n\nstatic int __init enclosure_init(void)\n{\n\treturn class_register(&enclosure_class);\n}\n\nstatic void __exit enclosure_exit(void)\n{\n\tclass_unregister(&enclosure_class);\n}\n\nmodule_init(enclosure_init);\nmodule_exit(enclosure_exit);\n\nMODULE_AUTHOR(\"James Bottomley\");\nMODULE_DESCRIPTION(\"Enclosure Services\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}