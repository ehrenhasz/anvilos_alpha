{
  "module_name": "isl29003.c",
  "hash_id": "ef12990ab644e97f5065143d216228341ec561bce0723c20f6791cb002c80b6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/misc/isl29003.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n\n#define ISL29003_DRV_NAME\t\"isl29003\"\n#define DRIVER_VERSION\t\t\"1.0\"\n\n#define ISL29003_REG_COMMAND\t\t0x00\n#define ISL29003_ADC_ENABLED\t\t(1 << 7)\n#define ISL29003_ADC_PD\t\t\t(1 << 6)\n#define ISL29003_TIMING_INT\t\t(1 << 5)\n#define ISL29003_MODE_SHIFT\t\t(2)\n#define ISL29003_MODE_MASK\t\t(0x3 << ISL29003_MODE_SHIFT)\n#define ISL29003_RES_SHIFT\t\t(0)\n#define ISL29003_RES_MASK\t\t(0x3 << ISL29003_RES_SHIFT)\n\n#define ISL29003_REG_CONTROL\t\t0x01\n#define ISL29003_INT_FLG\t\t(1 << 5)\n#define ISL29003_RANGE_SHIFT\t\t(2)\n#define ISL29003_RANGE_MASK\t\t(0x3 << ISL29003_RANGE_SHIFT)\n#define ISL29003_INT_PERSISTS_SHIFT\t(0)\n#define ISL29003_INT_PERSISTS_MASK\t(0xf << ISL29003_INT_PERSISTS_SHIFT)\n\n#define ISL29003_REG_IRQ_THRESH_HI\t0x02\n#define ISL29003_REG_IRQ_THRESH_LO\t0x03\n#define ISL29003_REG_LSB_SENSOR\t\t0x04\n#define ISL29003_REG_MSB_SENSOR\t\t0x05\n#define ISL29003_REG_LSB_TIMER\t\t0x06\n#define ISL29003_REG_MSB_TIMER\t\t0x07\n\n#define ISL29003_NUM_CACHABLE_REGS\t4\n\nstruct isl29003_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu8 reg_cache[ISL29003_NUM_CACHABLE_REGS];\n\tu8 power_state_before_suspend;\n};\n\nstatic int gain_range[] = {\n\t1000, 4000, 16000, 64000\n};\n\n \n\nstatic int __isl29003_read_reg(struct i2c_client *client,\n\t\t\t       u32 reg, u8 mask, u8 shift)\n{\n\tstruct isl29003_data *data = i2c_get_clientdata(client);\n\n\treturn (data->reg_cache[reg] & mask) >> shift;\n}\n\nstatic int __isl29003_write_reg(struct i2c_client *client,\n\t\t\t\tu32 reg, u8 mask, u8 shift, u8 val)\n{\n\tstruct isl29003_data *data = i2c_get_clientdata(client);\n\tint ret = 0;\n\tu8 tmp;\n\n\tif (reg >= ISL29003_NUM_CACHABLE_REGS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\n\ttmp = data->reg_cache[reg];\n\ttmp &= ~mask;\n\ttmp |= val << shift;\n\n\tret = i2c_smbus_write_byte_data(client, reg, tmp);\n\tif (!ret)\n\t\tdata->reg_cache[reg] = tmp;\n\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\n \n\n \nstatic int isl29003_get_range(struct i2c_client *client)\n{\n\treturn __isl29003_read_reg(client, ISL29003_REG_CONTROL,\n\t\tISL29003_RANGE_MASK, ISL29003_RANGE_SHIFT);\n}\n\nstatic int isl29003_set_range(struct i2c_client *client, int range)\n{\n\treturn __isl29003_write_reg(client, ISL29003_REG_CONTROL,\n\t\tISL29003_RANGE_MASK, ISL29003_RANGE_SHIFT, range);\n}\n\n \nstatic int isl29003_get_resolution(struct i2c_client *client)\n{\n\treturn __isl29003_read_reg(client, ISL29003_REG_COMMAND,\n\t\tISL29003_RES_MASK, ISL29003_RES_SHIFT);\n}\n\nstatic int isl29003_set_resolution(struct i2c_client *client, int res)\n{\n\treturn __isl29003_write_reg(client, ISL29003_REG_COMMAND,\n\t\tISL29003_RES_MASK, ISL29003_RES_SHIFT, res);\n}\n\n \nstatic int isl29003_get_mode(struct i2c_client *client)\n{\n\treturn __isl29003_read_reg(client, ISL29003_REG_COMMAND,\n\t\tISL29003_MODE_MASK, ISL29003_MODE_SHIFT);\n}\n\nstatic int isl29003_set_mode(struct i2c_client *client, int mode)\n{\n\treturn __isl29003_write_reg(client, ISL29003_REG_COMMAND,\n\t\tISL29003_MODE_MASK, ISL29003_MODE_SHIFT, mode);\n}\n\n \nstatic int isl29003_set_power_state(struct i2c_client *client, int state)\n{\n\treturn __isl29003_write_reg(client, ISL29003_REG_COMMAND,\n\t\t\t\tISL29003_ADC_ENABLED | ISL29003_ADC_PD, 0,\n\t\t\t\tstate ? ISL29003_ADC_ENABLED : ISL29003_ADC_PD);\n}\n\nstatic int isl29003_get_power_state(struct i2c_client *client)\n{\n\tstruct isl29003_data *data = i2c_get_clientdata(client);\n\tu8 cmdreg = data->reg_cache[ISL29003_REG_COMMAND];\n\n\treturn ~cmdreg & ISL29003_ADC_PD;\n}\n\nstatic int isl29003_get_adc_value(struct i2c_client *client)\n{\n\tstruct isl29003_data *data = i2c_get_clientdata(client);\n\tint lsb, msb, range, bitdepth;\n\n\tmutex_lock(&data->lock);\n\tlsb = i2c_smbus_read_byte_data(client, ISL29003_REG_LSB_SENSOR);\n\n\tif (lsb < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn lsb;\n\t}\n\n\tmsb = i2c_smbus_read_byte_data(client, ISL29003_REG_MSB_SENSOR);\n\tmutex_unlock(&data->lock);\n\n\tif (msb < 0)\n\t\treturn msb;\n\n\trange = isl29003_get_range(client);\n\tbitdepth = (4 - isl29003_get_resolution(client)) * 4;\n\treturn (((msb << 8) | lsb) * gain_range[range]) >> bitdepth;\n}\n\n \n\n \nstatic ssize_t isl29003_show_range(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn sysfs_emit(buf, \"%i\\n\", isl29003_get_range(client));\n}\n\nstatic ssize_t isl29003_store_range(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 3)\n\t\treturn -EINVAL;\n\n\tret = isl29003_set_range(client, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(range, S_IWUSR | S_IRUGO,\n\t\t   isl29003_show_range, isl29003_store_range);\n\n\n \nstatic ssize_t isl29003_show_resolution(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", isl29003_get_resolution(client));\n}\n\nstatic ssize_t isl29003_store_resolution(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 3)\n\t\treturn -EINVAL;\n\n\tret = isl29003_set_resolution(client, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(resolution, S_IWUSR | S_IRUGO,\n\t\t   isl29003_show_resolution, isl29003_store_resolution);\n\n \nstatic ssize_t isl29003_show_mode(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", isl29003_get_mode(client));\n}\n\nstatic ssize_t isl29003_store_mode(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 2)\n\t\treturn -EINVAL;\n\n\tret = isl29003_set_mode(client, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(mode, S_IWUSR | S_IRUGO,\n\t\t   isl29003_show_mode, isl29003_store_mode);\n\n\n \nstatic ssize_t isl29003_show_power_state(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", isl29003_get_power_state(client));\n}\n\nstatic ssize_t isl29003_store_power_state(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tret = isl29003_set_power_state(client, val);\n\treturn ret ? ret : count;\n}\n\nstatic DEVICE_ATTR(power_state, S_IWUSR | S_IRUGO,\n\t\t   isl29003_show_power_state, isl29003_store_power_state);\n\n\n \nstatic ssize_t isl29003_show_lux(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\t \n\tif (!isl29003_get_power_state(client))\n\t\treturn -EBUSY;\n\n\treturn sysfs_emit(buf, \"%d\\n\", isl29003_get_adc_value(client));\n}\n\nstatic DEVICE_ATTR(lux, S_IRUGO, isl29003_show_lux, NULL);\n\nstatic struct attribute *isl29003_attributes[] = {\n\t&dev_attr_range.attr,\n\t&dev_attr_resolution.attr,\n\t&dev_attr_mode.attr,\n\t&dev_attr_power_state.attr,\n\t&dev_attr_lux.attr,\n\tNULL\n};\n\nstatic const struct attribute_group isl29003_attr_group = {\n\t.attrs = isl29003_attributes,\n};\n\nstatic int isl29003_init_client(struct i2c_client *client)\n{\n\tstruct isl29003_data *data = i2c_get_clientdata(client);\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->reg_cache); i++) {\n\t\tint v = i2c_smbus_read_byte_data(client, i);\n\n\t\tif (v < 0)\n\t\t\treturn -ENODEV;\n\n\t\tdata->reg_cache[i] = v;\n\t}\n\n\t \n\tisl29003_set_range(client, 0);\n\tisl29003_set_resolution(client, 0);\n\tisl29003_set_mode(client, 0);\n\tisl29003_set_power_state(client, 0);\n\n\treturn 0;\n}\n\n \n\nstatic int isl29003_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct isl29003_data *data;\n\tint err = 0;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))\n\t\treturn -EIO;\n\n\tdata = kzalloc(sizeof(struct isl29003_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\ti2c_set_clientdata(client, data);\n\tmutex_init(&data->lock);\n\n\t \n\terr = isl29003_init_client(client);\n\tif (err)\n\t\tgoto exit_kfree;\n\n\t \n\terr = sysfs_create_group(&client->dev.kobj, &isl29003_attr_group);\n\tif (err)\n\t\tgoto exit_kfree;\n\n\tdev_info(&client->dev, \"driver version %s enabled\\n\", DRIVER_VERSION);\n\treturn 0;\n\nexit_kfree:\n\tkfree(data);\n\treturn err;\n}\n\nstatic void isl29003_remove(struct i2c_client *client)\n{\n\tsysfs_remove_group(&client->dev.kobj, &isl29003_attr_group);\n\tisl29003_set_power_state(client, 0);\n\tkfree(i2c_get_clientdata(client));\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int isl29003_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct isl29003_data *data = i2c_get_clientdata(client);\n\n\tdata->power_state_before_suspend = isl29003_get_power_state(client);\n\treturn isl29003_set_power_state(client, 0);\n}\n\nstatic int isl29003_resume(struct device *dev)\n{\n\tint i;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct isl29003_data *data = i2c_get_clientdata(client);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->reg_cache); i++)\n\t\tif (i2c_smbus_write_byte_data(client, i, data->reg_cache[i]))\n\t\t\treturn -EIO;\n\n\treturn isl29003_set_power_state(client,\n\t\tdata->power_state_before_suspend);\n}\n\nstatic SIMPLE_DEV_PM_OPS(isl29003_pm_ops, isl29003_suspend, isl29003_resume);\n#define ISL29003_PM_OPS (&isl29003_pm_ops)\n\n#else\n#define ISL29003_PM_OPS NULL\n#endif  \n\nstatic const struct i2c_device_id isl29003_id[] = {\n\t{ \"isl29003\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, isl29003_id);\n\nstatic struct i2c_driver isl29003_driver = {\n\t.driver = {\n\t\t.name\t= ISL29003_DRV_NAME,\n\t\t.pm\t= ISL29003_PM_OPS,\n\t},\n\t.probe = isl29003_probe,\n\t.remove\t= isl29003_remove,\n\t.id_table = isl29003_id,\n};\n\nmodule_i2c_driver(isl29003_driver);\n\nMODULE_AUTHOR(\"Daniel Mack <daniel@caiaq.de>\");\nMODULE_DESCRIPTION(\"ISL29003 ambient light sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DRIVER_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}