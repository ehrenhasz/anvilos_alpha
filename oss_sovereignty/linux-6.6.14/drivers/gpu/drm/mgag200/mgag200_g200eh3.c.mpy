{
  "module_name": "mgag200_g200eh3.c",
  "hash_id": "0d6a95f61ad1d3ca01259316c0adf484cdc28702340cc316c9deaaf1c0a51752",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mgag200/mgag200_g200eh3.c",
  "human_readable_source": "\n\n#include <linux/pci.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mgag200_drv.h\"\n\n \n\nstatic int mgag200_g200eh3_pixpllc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\t\tstruct drm_atomic_state *new_state)\n{\n\tstatic const unsigned int vcomax = 3000000;\n\tstatic const unsigned int vcomin = 1500000;\n\tstatic const unsigned int pllreffreq = 25000;\n\n\tstruct drm_crtc_state *new_crtc_state = drm_atomic_get_new_crtc_state(new_state, crtc);\n\tstruct mgag200_crtc_state *new_mgag200_crtc_state = to_mgag200_crtc_state(new_crtc_state);\n\tlong clock = new_crtc_state->mode.clock;\n\tstruct mgag200_pll_values *pixpllc = &new_mgag200_crtc_state->pixpllc;\n\tunsigned int delta, tmpdelta;\n\tunsigned int testp, testm, testn;\n\tunsigned int p, m, n, s;\n\tunsigned int computed;\n\n\tm = n = p = s = 0;\n\tdelta = 0xffffffff;\n\ttestp = 0;\n\n\tfor (testm = 150; testm >= 6; testm--) {\n\t\tif (clock * testm > vcomax)\n\t\t\tcontinue;\n\t\tif (clock * testm < vcomin)\n\t\t\tcontinue;\n\t\tfor (testn = 120; testn >= 60; testn--) {\n\t\t\tcomputed = (pllreffreq * testn) / testm;\n\t\t\tif (computed > clock)\n\t\t\t\ttmpdelta = computed - clock;\n\t\t\telse\n\t\t\t\ttmpdelta = clock - computed;\n\t\t\tif (tmpdelta < delta) {\n\t\t\t\tdelta = tmpdelta;\n\t\t\t\tn = testn + 1;\n\t\t\t\tm = testm + 1;\n\t\t\t\tp = testp + 1;\n\t\t\t}\n\t\t\tif (delta == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (delta == 0)\n\t\t\tbreak;\n\t}\n\n\tpixpllc->m = m;\n\tpixpllc->n = n;\n\tpixpllc->p = p;\n\tpixpllc->s = s;\n\n\treturn 0;\n}\n\n \n\nstatic const struct drm_plane_helper_funcs mgag200_g200eh3_primary_plane_helper_funcs = {\n\tMGAG200_PRIMARY_PLANE_HELPER_FUNCS,\n};\n\nstatic const struct drm_plane_funcs mgag200_g200eh3_primary_plane_funcs = {\n\tMGAG200_PRIMARY_PLANE_FUNCS,\n};\n\nstatic const struct drm_crtc_helper_funcs mgag200_g200eh3_crtc_helper_funcs = {\n\tMGAG200_CRTC_HELPER_FUNCS,\n};\n\nstatic const struct drm_crtc_funcs mgag200_g200eh3_crtc_funcs = {\n\tMGAG200_CRTC_FUNCS,\n};\n\nstatic const struct drm_encoder_funcs mgag200_g200eh3_dac_encoder_funcs = {\n\tMGAG200_DAC_ENCODER_FUNCS,\n};\n\nstatic const struct drm_connector_helper_funcs mgag200_g200eh3_vga_connector_helper_funcs = {\n\tMGAG200_VGA_CONNECTOR_HELPER_FUNCS,\n};\n\nstatic const struct drm_connector_funcs mgag200_g200eh3_vga_connector_funcs = {\n\tMGAG200_VGA_CONNECTOR_FUNCS,\n};\n\nstatic int mgag200_g200eh3_pipeline_init(struct mga_device *mdev)\n{\n\tstruct drm_device *dev = &mdev->base;\n\tstruct drm_plane *primary_plane = &mdev->primary_plane;\n\tstruct drm_crtc *crtc = &mdev->crtc;\n\tstruct drm_encoder *encoder = &mdev->encoder;\n\tstruct mga_i2c_chan *i2c = &mdev->i2c;\n\tstruct drm_connector *connector = &mdev->connector;\n\tint ret;\n\n\tret = drm_universal_plane_init(dev, primary_plane, 0,\n\t\t\t\t       &mgag200_g200eh3_primary_plane_funcs,\n\t\t\t\t       mgag200_primary_plane_formats,\n\t\t\t\t       mgag200_primary_plane_formats_size,\n\t\t\t\t       mgag200_primary_plane_fmtmods,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_universal_plane_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_plane_helper_add(primary_plane, &mgag200_g200eh3_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary_plane);\n\n\tret = drm_crtc_init_with_planes(dev, crtc, primary_plane, NULL,\n\t\t\t\t\t&mgag200_g200eh3_crtc_funcs, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_crtc_init_with_planes() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_crtc_helper_add(crtc, &mgag200_g200eh3_crtc_helper_funcs);\n\n\t \n\tdrm_mode_crtc_set_gamma_size(crtc, MGAG200_LUT_SIZE);\n\tdrm_crtc_enable_color_mgmt(crtc, 0, false, MGAG200_LUT_SIZE);\n\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\tret = drm_encoder_init(dev, encoder, &mgag200_g200eh3_dac_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_DAC, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_encoder_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mgag200_i2c_init(mdev, i2c);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to add DDC bus: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = drm_connector_init_with_ddc(dev, connector,\n\t\t\t\t\t  &mgag200_g200eh3_vga_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_VGA,\n\t\t\t\t\t  &i2c->adapter);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_connector_init_with_ddc() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_connector_helper_add(connector, &mgag200_g200eh3_vga_connector_helper_funcs);\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_connector_attach_encoder() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct mgag200_device_info mgag200_g200eh3_device_info =\n\tMGAG200_DEVICE_INFO_INIT(2048, 2048, 0, false, 1, 0, false);\n\nstatic const struct mgag200_device_funcs mgag200_g200eh3_device_funcs = {\n\t.pixpllc_atomic_check = mgag200_g200eh3_pixpllc_atomic_check,\n\t.pixpllc_atomic_update = mgag200_g200eh_pixpllc_atomic_update, \n};\n\nstruct mga_device *mgag200_g200eh3_device_create(struct pci_dev *pdev,\n\t\t\t\t\t\t const struct drm_driver *drv)\n{\n\tstruct mga_device *mdev;\n\tstruct drm_device *dev;\n\tresource_size_t vram_available;\n\tint ret;\n\n\tmdev = devm_drm_dev_alloc(&pdev->dev, drv, struct mga_device, base);\n\tif (IS_ERR(mdev))\n\t\treturn mdev;\n\tdev = &mdev->base;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tret = mgag200_init_pci_options(pdev, 0x00000120, 0x0000b000);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_device_preinit(mdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_device_init(mdev, &mgag200_g200eh3_device_info,\n\t\t\t\t  &mgag200_g200eh3_device_funcs);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmgag200_g200eh_init_registers(mdev); \n\n\tvram_available = mgag200_device_probe_vram(mdev);\n\n\tret = mgag200_mode_config_init(mdev, vram_available);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_g200eh3_pipeline_init(mdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdrm_mode_config_reset(dev);\n\n\treturn mdev;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}