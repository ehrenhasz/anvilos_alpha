{
  "module_name": "mgag200_g200er.c",
  "hash_id": "7f68d1e02803792b670097e97e26ee9c59fe396035240131692ab64c1aa08cde",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mgag200/mgag200_g200er.c",
  "human_readable_source": "\n\n#include <linux/delay.h>\n#include <linux/pci.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mgag200_drv.h\"\n\nstatic void mgag200_g200er_init_registers(struct mga_device *mdev)\n{\n\tstatic const u8 dacvalue[] = {\n\t\tMGAG200_DAC_DEFAULT(0x00, 0xc9, 0x1f, 0x00, 0x00, 0x00)\n\t};\n\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dacvalue); i++) {\n\t\tif ((i <= 0x17) ||\n\t\t    (i == 0x1b) ||\n\t\t    (i == 0x1c) ||\n\t\t    ((i >= 0x1f) && (i <= 0x29)) ||\n\t\t    ((i >= 0x30) && (i <= 0x37)))\n\t\t\tcontinue;\n\t\tWREG_DAC(i, dacvalue[i]);\n\t}\n\n\tWREG_DAC(0x90, 0);  \n\n\tmgag200_init_registers(mdev);\n\n\tWREG_ECRT(0x24, 0x5);  \n}\n\nstatic void mgag200_g200er_reset_tagfifo(struct mga_device *mdev)\n{\n\tstatic const uint32_t RESET_FLAG = 0x00200000;  \n\tu32 memctl;\n\n\tmemctl = RREG32(MGAREG_MEMCTL);\n\n\tmemctl |= RESET_FLAG;\n\tWREG32(MGAREG_MEMCTL, memctl);\n\n\tudelay(1000);\n\n\tmemctl &= ~RESET_FLAG;\n\tWREG32(MGAREG_MEMCTL, memctl);\n}\n\n \n\nstatic int mgag200_g200er_pixpllc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\t       struct drm_atomic_state *new_state)\n{\n\tstatic const unsigned int vcomax = 1488000;\n\tstatic const unsigned int vcomin = 1056000;\n\tstatic const unsigned int pllreffreq = 48000;\n\tstatic const unsigned int m_div_val[] = { 1, 2, 4, 8 };\n\n\tstruct drm_crtc_state *new_crtc_state = drm_atomic_get_new_crtc_state(new_state, crtc);\n\tstruct mgag200_crtc_state *new_mgag200_crtc_state = to_mgag200_crtc_state(new_crtc_state);\n\tlong clock = new_crtc_state->mode.clock;\n\tstruct mgag200_pll_values *pixpllc = &new_mgag200_crtc_state->pixpllc;\n\tunsigned int delta, tmpdelta;\n\tint testr, testn, testm, testo;\n\tunsigned int p, m, n, s;\n\tunsigned int computed, vco;\n\n\tm = n = p = s = 0;\n\tdelta = 0xffffffff;\n\n\tfor (testr = 0; testr < 4; testr++) {\n\t\tif (delta == 0)\n\t\t\tbreak;\n\t\tfor (testn = 5; testn < 129; testn++) {\n\t\t\tif (delta == 0)\n\t\t\t\tbreak;\n\t\t\tfor (testm = 3; testm >= 0; testm--) {\n\t\t\t\tif (delta == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (testo = 5; testo < 33; testo++) {\n\t\t\t\t\tvco = pllreffreq * (testn + 1) /\n\t\t\t\t\t\t(testr + 1);\n\t\t\t\t\tif (vco < vcomin)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (vco > vcomax)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcomputed = vco / (m_div_val[testm] * (testo + 1));\n\t\t\t\t\tif (computed > clock)\n\t\t\t\t\t\ttmpdelta = computed - clock;\n\t\t\t\t\telse\n\t\t\t\t\t\ttmpdelta = clock - computed;\n\t\t\t\t\tif (tmpdelta < delta) {\n\t\t\t\t\t\tdelta = tmpdelta;\n\t\t\t\t\t\tm = (testm | (testo << 3)) + 1;\n\t\t\t\t\t\tn = testn + 1;\n\t\t\t\t\t\tp = testr + 1;\n\t\t\t\t\t\ts = testr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpixpllc->m = m;\n\tpixpllc->n = n;\n\tpixpllc->p = p;\n\tpixpllc->s = s;\n\n\treturn 0;\n}\n\nstatic void mgag200_g200er_pixpllc_atomic_update(struct drm_crtc *crtc,\n\t\t\t\t\t\t struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct mgag200_crtc_state *mgag200_crtc_state = to_mgag200_crtc_state(crtc_state);\n\tstruct mgag200_pll_values *pixpllc = &mgag200_crtc_state->pixpllc;\n\tunsigned int pixpllcm, pixpllcn, pixpllcp, pixpllcs;\n\tu8 xpixpllcm, xpixpllcn, xpixpllcp, tmp;\n\n\tpixpllcm = pixpllc->m - 1;\n\tpixpllcn = pixpllc->n - 1;\n\tpixpllcp = pixpllc->p - 1;\n\tpixpllcs = pixpllc->s;\n\n\txpixpllcm = pixpllcm;\n\txpixpllcn = pixpllcn;\n\txpixpllcp = (pixpllcs << 3) | pixpllcp;\n\n\tWREG_MISC_MASKED(MGAREG_MISC_CLKSEL_MGA, MGAREG_MISC_CLKSEL_MASK);\n\n\tWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\n\ttmp = RREG8(DAC_DATA);\n\ttmp |= MGA1064_PIX_CLK_CTL_CLK_DIS;\n\tWREG8(DAC_DATA, tmp);\n\n\tWREG8(DAC_INDEX, MGA1064_REMHEADCTL);\n\ttmp = RREG8(DAC_DATA);\n\ttmp |= MGA1064_REMHEADCTL_CLKDIS;\n\tWREG8(DAC_DATA, tmp);\n\n\ttmp = RREG8(MGAREG_MEM_MISC_READ);\n\ttmp |= (0x3<<2) | 0xc0;\n\tWREG8(MGAREG_MEM_MISC_WRITE, tmp);\n\n\tWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\n\ttmp = RREG8(DAC_DATA);\n\ttmp &= ~MGA1064_PIX_CLK_CTL_CLK_DIS;\n\ttmp |= MGA1064_PIX_CLK_CTL_CLK_POW_DOWN;\n\tWREG8(DAC_DATA, tmp);\n\n\tudelay(500);\n\n\tWREG_DAC(MGA1064_ER_PIX_PLLC_N, xpixpllcn);\n\tWREG_DAC(MGA1064_ER_PIX_PLLC_M, xpixpllcm);\n\tWREG_DAC(MGA1064_ER_PIX_PLLC_P, xpixpllcp);\n\n\tudelay(50);\n}\n\n \n\nstatic const struct drm_plane_helper_funcs mgag200_g200er_primary_plane_helper_funcs = {\n\tMGAG200_PRIMARY_PLANE_HELPER_FUNCS,\n};\n\nstatic const struct drm_plane_funcs mgag200_g200er_primary_plane_funcs = {\n\tMGAG200_PRIMARY_PLANE_FUNCS,\n};\n\nstatic void mgag200_g200er_crtc_helper_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t\t\t     struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tconst struct mgag200_device_funcs *funcs = mdev->funcs;\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;\n\tstruct mgag200_crtc_state *mgag200_crtc_state = to_mgag200_crtc_state(crtc_state);\n\tconst struct drm_format_info *format = mgag200_crtc_state->format;\n\n\tif (funcs->disable_vidrst)\n\t\tfuncs->disable_vidrst(mdev);\n\n\tmgag200_set_format_regs(mdev, format);\n\tmgag200_set_mode_regs(mdev, adjusted_mode);\n\n\tif (funcs->pixpllc_atomic_update)\n\t\tfuncs->pixpllc_atomic_update(crtc, old_state);\n\n\tmgag200_g200er_reset_tagfifo(mdev);\n\n\tif (crtc_state->gamma_lut)\n\t\tmgag200_crtc_set_gamma(mdev, format, crtc_state->gamma_lut->data);\n\telse\n\t\tmgag200_crtc_set_gamma_linear(mdev, format);\n\n\tmgag200_enable_display(mdev);\n\n\tif (funcs->enable_vidrst)\n\t\tfuncs->enable_vidrst(mdev);\n}\n\nstatic const struct drm_crtc_helper_funcs mgag200_g200er_crtc_helper_funcs = {\n\t.mode_valid = mgag200_crtc_helper_mode_valid,\n\t.atomic_check = mgag200_crtc_helper_atomic_check,\n\t.atomic_flush = mgag200_crtc_helper_atomic_flush,\n\t.atomic_enable = mgag200_g200er_crtc_helper_atomic_enable,\n\t.atomic_disable = mgag200_crtc_helper_atomic_disable\n};\n\nstatic const struct drm_crtc_funcs mgag200_g200er_crtc_funcs = {\n\tMGAG200_CRTC_FUNCS,\n};\n\nstatic const struct drm_encoder_funcs mgag200_g200er_dac_encoder_funcs = {\n\tMGAG200_DAC_ENCODER_FUNCS,\n};\n\nstatic const struct drm_connector_helper_funcs mgag200_g200er_vga_connector_helper_funcs = {\n\tMGAG200_VGA_CONNECTOR_HELPER_FUNCS,\n};\n\nstatic const struct drm_connector_funcs mgag200_g200er_vga_connector_funcs = {\n\tMGAG200_VGA_CONNECTOR_FUNCS,\n};\n\nstatic int mgag200_g200er_pipeline_init(struct mga_device *mdev)\n{\n\tstruct drm_device *dev = &mdev->base;\n\tstruct drm_plane *primary_plane = &mdev->primary_plane;\n\tstruct drm_crtc *crtc = &mdev->crtc;\n\tstruct drm_encoder *encoder = &mdev->encoder;\n\tstruct mga_i2c_chan *i2c = &mdev->i2c;\n\tstruct drm_connector *connector = &mdev->connector;\n\tint ret;\n\n\tret = drm_universal_plane_init(dev, primary_plane, 0,\n\t\t\t\t       &mgag200_g200er_primary_plane_funcs,\n\t\t\t\t       mgag200_primary_plane_formats,\n\t\t\t\t       mgag200_primary_plane_formats_size,\n\t\t\t\t       mgag200_primary_plane_fmtmods,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_universal_plane_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_plane_helper_add(primary_plane, &mgag200_g200er_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary_plane);\n\n\tret = drm_crtc_init_with_planes(dev, crtc, primary_plane, NULL,\n\t\t\t\t\t&mgag200_g200er_crtc_funcs, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_crtc_init_with_planes() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_crtc_helper_add(crtc, &mgag200_g200er_crtc_helper_funcs);\n\n\t \n\tdrm_mode_crtc_set_gamma_size(crtc, MGAG200_LUT_SIZE);\n\tdrm_crtc_enable_color_mgmt(crtc, 0, false, MGAG200_LUT_SIZE);\n\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\tret = drm_encoder_init(dev, encoder, &mgag200_g200er_dac_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_DAC, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_encoder_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mgag200_i2c_init(mdev, i2c);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to add DDC bus: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = drm_connector_init_with_ddc(dev, connector,\n\t\t\t\t\t  &mgag200_g200er_vga_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_VGA,\n\t\t\t\t\t  &i2c->adapter);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_connector_init_with_ddc() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_connector_helper_add(connector, &mgag200_g200er_vga_connector_helper_funcs);\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_connector_attach_encoder() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct mgag200_device_info mgag200_g200er_device_info =\n\tMGAG200_DEVICE_INFO_INIT(2048, 2048, 55000, false, 1, 0, false);\n\nstatic const struct mgag200_device_funcs mgag200_g200er_device_funcs = {\n\t.pixpllc_atomic_check = mgag200_g200er_pixpllc_atomic_check,\n\t.pixpllc_atomic_update = mgag200_g200er_pixpllc_atomic_update,\n};\n\nstruct mga_device *mgag200_g200er_device_create(struct pci_dev *pdev, const struct drm_driver *drv)\n{\n\tstruct mga_device *mdev;\n\tstruct drm_device *dev;\n\tresource_size_t vram_available;\n\tint ret;\n\n\tmdev = devm_drm_dev_alloc(&pdev->dev, drv, struct mga_device, base);\n\tif (IS_ERR(mdev))\n\t\treturn mdev;\n\tdev = &mdev->base;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tret = mgag200_device_preinit(mdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_device_init(mdev, &mgag200_g200er_device_info,\n\t\t\t\t  &mgag200_g200er_device_funcs);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmgag200_g200er_init_registers(mdev);\n\n\tvram_available = mgag200_device_probe_vram(mdev);\n\n\tret = mgag200_mode_config_init(mdev, vram_available);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_g200er_pipeline_init(mdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdrm_mode_config_reset(dev);\n\n\treturn mdev;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}