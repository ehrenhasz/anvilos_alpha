{
  "module_name": "mgag200_mode.c",
  "hash_id": "c81ea193fe12110b59d2dbf7200fef1e82eea77c9bed8fb48a127c768b1e4ba5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mgag200/mgag200_mode.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/iosys-map.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mgag200_drv.h\"\n\n \n\nvoid mgag200_crtc_set_gamma_linear(struct mga_device *mdev,\n\t\t\t\t   const struct drm_format_info *format)\n{\n\tint i;\n\n\tWREG8(DAC_INDEX + MGA1064_INDEX, 0);\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_RGB565:\n\t\t \n\t\tfor (i = 0; i < MGAG200_LUT_SIZE / 8; i++) {\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, i * 8 + i / 4);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, i * 4 + i / 16);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, i * 8 + i / 4);\n\t\t}\n\t\t \n\t\tfor (i = MGAG200_LUT_SIZE / 8; i < MGAG200_LUT_SIZE / 4; i++) {\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, 0);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, i * 4 + i / 16);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, 0);\n\t\t}\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_XRGB8888:\n\t\tfor (i = 0; i < MGAG200_LUT_SIZE; i++) {\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, i);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, i);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, i);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdrm_warn_once(&mdev->base, \"Unsupported format %p4cc for gamma correction\\n\",\n\t\t\t      &format->format);\n\t\tbreak;\n\t}\n}\n\nvoid mgag200_crtc_set_gamma(struct mga_device *mdev,\n\t\t\t    const struct drm_format_info *format,\n\t\t\t    struct drm_color_lut *lut)\n{\n\tint i;\n\n\tWREG8(DAC_INDEX + MGA1064_INDEX, 0);\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_RGB565:\n\t\t \n\t\tfor (i = 0; i < MGAG200_LUT_SIZE / 8; i++) {\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, lut[i * 8 + i / 4].red >> 8);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, lut[i * 4 + i / 16].green >> 8);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, lut[i * 8 + i / 4].blue >> 8);\n\t\t}\n\t\t \n\t\tfor (i = MGAG200_LUT_SIZE / 8; i < MGAG200_LUT_SIZE / 4; i++) {\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, 0);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, lut[i * 4 + i / 16].green >> 8);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, 0);\n\t\t}\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_XRGB8888:\n\t\tfor (i = 0; i < MGAG200_LUT_SIZE; i++) {\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, lut[i].red >> 8);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, lut[i].green >> 8);\n\t\t\tWREG8(DAC_INDEX + MGA1064_COL_PAL, lut[i].blue >> 8);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdrm_warn_once(&mdev->base, \"Unsupported format %p4cc for gamma correction\\n\",\n\t\t\t      &format->format);\n\t\tbreak;\n\t}\n}\n\nstatic inline void mga_wait_vsync(struct mga_device *mdev)\n{\n\tunsigned long timeout = jiffies + HZ/10;\n\tunsigned int status = 0;\n\n\tdo {\n\t\tstatus = RREG32(MGAREG_Status);\n\t} while ((status & 0x08) && time_before(jiffies, timeout));\n\ttimeout = jiffies + HZ/10;\n\tstatus = 0;\n\tdo {\n\t\tstatus = RREG32(MGAREG_Status);\n\t} while (!(status & 0x08) && time_before(jiffies, timeout));\n}\n\nstatic inline void mga_wait_busy(struct mga_device *mdev)\n{\n\tunsigned long timeout = jiffies + HZ;\n\tunsigned int status = 0;\n\tdo {\n\t\tstatus = RREG8(MGAREG_Status + 2);\n\t} while ((status & 0x01) && time_before(jiffies, timeout));\n}\n\n \nstatic void mgag200_set_startadd(struct mga_device *mdev,\n\t\t\t\t unsigned long offset)\n{\n\tstruct drm_device *dev = &mdev->base;\n\tu32 startadd;\n\tu8 crtcc, crtcd, crtcext0;\n\n\tstartadd = offset / 8;\n\n\tif (startadd > 0)\n\t\tdrm_WARN_ON_ONCE(dev, mdev->info->bug_no_startadd);\n\n\t \n\tdrm_WARN_ON(dev, startadd > 0x1fffff);\n\n\tRREG_ECRT(0x00, crtcext0);\n\n\tcrtcc = (startadd >> 8) & 0xff;\n\tcrtcd = startadd & 0xff;\n\tcrtcext0 &= 0xb0;\n\tcrtcext0 |= ((startadd >> 14) & BIT(6)) |\n\t\t    ((startadd >> 16) & 0x0f);\n\n\tWREG_CRT(0x0c, crtcc);\n\tWREG_CRT(0x0d, crtcd);\n\tWREG_ECRT(0x00, crtcext0);\n}\n\nvoid mgag200_init_registers(struct mga_device *mdev)\n{\n\tu8 crtc11, misc;\n\n\tWREG_SEQ(2, 0x0f);\n\tWREG_SEQ(3, 0x00);\n\tWREG_SEQ(4, 0x0e);\n\n\tWREG_CRT(10, 0);\n\tWREG_CRT(11, 0);\n\tWREG_CRT(12, 0);\n\tWREG_CRT(13, 0);\n\tWREG_CRT(14, 0);\n\tWREG_CRT(15, 0);\n\n\tRREG_CRT(0x11, crtc11);\n\tcrtc11 &= ~(MGAREG_CRTC11_CRTCPROTECT |\n\t\t    MGAREG_CRTC11_VINTEN |\n\t\t    MGAREG_CRTC11_VINTCLR);\n\tWREG_CRT(0x11, crtc11);\n\n\tmisc = RREG8(MGA_MISC_IN);\n\tmisc |= MGAREG_MISC_IOADSEL;\n\tWREG8(MGA_MISC_OUT, misc);\n}\n\nvoid mgag200_set_mode_regs(struct mga_device *mdev, const struct drm_display_mode *mode)\n{\n\tconst struct mgag200_device_info *info = mdev->info;\n\tunsigned int hdisplay, hsyncstart, hsyncend, htotal;\n\tunsigned int vdisplay, vsyncstart, vsyncend, vtotal;\n\tu8 misc, crtcext1, crtcext2, crtcext5;\n\n\thdisplay = mode->hdisplay / 8 - 1;\n\thsyncstart = mode->hsync_start / 8 - 1;\n\thsyncend = mode->hsync_end / 8 - 1;\n\thtotal = mode->htotal / 8 - 1;\n\n\t \n\tif ((htotal & 0x07) == 0x06 || (htotal & 0x07) == 0x04)\n\t\thtotal++;\n\n\tvdisplay = mode->vdisplay - 1;\n\tvsyncstart = mode->vsync_start - 1;\n\tvsyncend = mode->vsync_end - 1;\n\tvtotal = mode->vtotal - 2;\n\n\tmisc = RREG8(MGA_MISC_IN);\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tmisc |= MGAREG_MISC_HSYNCPOL;\n\telse\n\t\tmisc &= ~MGAREG_MISC_HSYNCPOL;\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tmisc |= MGAREG_MISC_VSYNCPOL;\n\telse\n\t\tmisc &= ~MGAREG_MISC_VSYNCPOL;\n\n\tcrtcext1 = (((htotal - 4) & 0x100) >> 8) |\n\t\t   ((hdisplay & 0x100) >> 7) |\n\t\t   ((hsyncstart & 0x100) >> 6) |\n\t\t    (htotal & 0x40);\n\tif (info->has_vidrst)\n\t\tcrtcext1 |= MGAREG_CRTCEXT1_VRSTEN |\n\t\t\t    MGAREG_CRTCEXT1_HRSTEN;\n\n\tcrtcext2 = ((vtotal & 0xc00) >> 10) |\n\t\t   ((vdisplay & 0x400) >> 8) |\n\t\t   ((vdisplay & 0xc00) >> 7) |\n\t\t   ((vsyncstart & 0xc00) >> 5) |\n\t\t   ((vdisplay & 0x400) >> 3);\n\tcrtcext5 = 0x00;\n\n\tWREG_CRT(0, htotal - 4);\n\tWREG_CRT(1, hdisplay);\n\tWREG_CRT(2, hdisplay);\n\tWREG_CRT(3, (htotal & 0x1F) | 0x80);\n\tWREG_CRT(4, hsyncstart);\n\tWREG_CRT(5, ((htotal & 0x20) << 2) | (hsyncend & 0x1F));\n\tWREG_CRT(6, vtotal & 0xFF);\n\tWREG_CRT(7, ((vtotal & 0x100) >> 8) |\n\t\t ((vdisplay & 0x100) >> 7) |\n\t\t ((vsyncstart & 0x100) >> 6) |\n\t\t ((vdisplay & 0x100) >> 5) |\n\t\t ((vdisplay & 0x100) >> 4) |  \n\t\t ((vtotal & 0x200) >> 4) |\n\t\t ((vdisplay & 0x200) >> 3) |\n\t\t ((vsyncstart & 0x200) >> 2));\n\tWREG_CRT(9, ((vdisplay & 0x200) >> 4) |\n\t\t ((vdisplay & 0x200) >> 3));\n\tWREG_CRT(16, vsyncstart & 0xFF);\n\tWREG_CRT(17, (vsyncend & 0x0F) | 0x20);\n\tWREG_CRT(18, vdisplay & 0xFF);\n\tWREG_CRT(20, 0);\n\tWREG_CRT(21, vdisplay & 0xFF);\n\tWREG_CRT(22, (vtotal + 1) & 0xFF);\n\tWREG_CRT(23, 0xc3);\n\tWREG_CRT(24, vdisplay & 0xFF);\n\n\tWREG_ECRT(0x01, crtcext1);\n\tWREG_ECRT(0x02, crtcext2);\n\tWREG_ECRT(0x05, crtcext5);\n\n\tWREG8(MGA_MISC_OUT, misc);\n}\n\nstatic u8 mgag200_get_bpp_shift(const struct drm_format_info *format)\n{\n\tstatic const u8 bpp_shift[] = {0, 1, 0, 2};\n\n\treturn bpp_shift[format->cpp[0] - 1];\n}\n\n \nstatic u32 mgag200_calculate_offset(struct mga_device *mdev,\n\t\t\t\t    const struct drm_framebuffer *fb)\n{\n\tu32 offset = fb->pitches[0] / fb->format->cpp[0];\n\tu8 bppshift = mgag200_get_bpp_shift(fb->format);\n\n\tif (fb->format->cpp[0] * 8 == 24)\n\t\toffset = (offset * 3) >> (4 - bppshift);\n\telse\n\t\toffset = offset >> (4 - bppshift);\n\n\treturn offset;\n}\n\nstatic void mgag200_set_offset(struct mga_device *mdev,\n\t\t\t       const struct drm_framebuffer *fb)\n{\n\tu8 crtc13, crtcext0;\n\tu32 offset = mgag200_calculate_offset(mdev, fb);\n\n\tRREG_ECRT(0, crtcext0);\n\n\tcrtc13 = offset & 0xff;\n\n\tcrtcext0 &= ~MGAREG_CRTCEXT0_OFFSET_MASK;\n\tcrtcext0 |= (offset >> 4) & MGAREG_CRTCEXT0_OFFSET_MASK;\n\n\tWREG_CRT(0x13, crtc13);\n\tWREG_ECRT(0x00, crtcext0);\n}\n\nvoid mgag200_set_format_regs(struct mga_device *mdev, const struct drm_format_info *format)\n{\n\tstruct drm_device *dev = &mdev->base;\n\tunsigned int bpp, bppshift, scale;\n\tu8 crtcext3, xmulctrl;\n\n\tbpp = format->cpp[0] * 8;\n\n\tbppshift = mgag200_get_bpp_shift(format);\n\tswitch (bpp) {\n\tcase 24:\n\t\tscale = ((1 << bppshift) * 3) - 1;\n\t\tbreak;\n\tdefault:\n\t\tscale = (1 << bppshift) - 1;\n\t\tbreak;\n\t}\n\n\tRREG_ECRT(3, crtcext3);\n\n\tswitch (bpp) {\n\tcase 8:\n\t\txmulctrl = MGA1064_MUL_CTL_8bits;\n\t\tbreak;\n\tcase 16:\n\t\tif (format->depth == 15)\n\t\t\txmulctrl = MGA1064_MUL_CTL_15bits;\n\t\telse\n\t\t\txmulctrl = MGA1064_MUL_CTL_16bits;\n\t\tbreak;\n\tcase 24:\n\t\txmulctrl = MGA1064_MUL_CTL_24bits;\n\t\tbreak;\n\tcase 32:\n\t\txmulctrl = MGA1064_MUL_CTL_32_24bits;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdrm_WARN_ON(dev, \"invalid format depth\\n\");\n\t\treturn;\n\t}\n\n\tcrtcext3 &= ~GENMASK(2, 0);\n\tcrtcext3 |= scale;\n\n\tWREG_DAC(MGA1064_MUL_CTL, xmulctrl);\n\n\tWREG_GFX(0, 0x00);\n\tWREG_GFX(1, 0x00);\n\tWREG_GFX(2, 0x00);\n\tWREG_GFX(3, 0x00);\n\tWREG_GFX(4, 0x00);\n\tWREG_GFX(5, 0x40);\n\t \n\tWREG_GFX(6, 0x0d);\n\tWREG_GFX(7, 0x0f);\n\tWREG_GFX(8, 0x0f);\n\n\tWREG_ECRT(3, crtcext3);\n}\n\nvoid mgag200_enable_display(struct mga_device *mdev)\n{\n\tu8 seq0, crtcext1;\n\n\tRREG_SEQ(0x00, seq0);\n\tseq0 |= MGAREG_SEQ0_SYNCRST |\n\t\tMGAREG_SEQ0_ASYNCRST;\n\tWREG_SEQ(0x00, seq0);\n\n\t \n\tmga_wait_vsync(mdev);\n\tmga_wait_busy(mdev);\n\n\tRREG_ECRT(0x01, crtcext1);\n\tcrtcext1 &= ~MGAREG_CRTCEXT1_VSYNCOFF;\n\tcrtcext1 &= ~MGAREG_CRTCEXT1_HSYNCOFF;\n\tWREG_ECRT(0x01, crtcext1);\n}\n\nstatic void mgag200_disable_display(struct mga_device *mdev)\n{\n\tu8 seq0, crtcext1;\n\n\tRREG_SEQ(0x00, seq0);\n\tseq0 &= ~MGAREG_SEQ0_SYNCRST;\n\tWREG_SEQ(0x00, seq0);\n\n\t \n\tmga_wait_vsync(mdev);\n\tmga_wait_busy(mdev);\n\n\tRREG_ECRT(0x01, crtcext1);\n\tcrtcext1 |= MGAREG_CRTCEXT1_VSYNCOFF |\n\t\t    MGAREG_CRTCEXT1_HSYNCOFF;\n\tWREG_ECRT(0x01, crtcext1);\n}\n\nstatic void mgag200_handle_damage(struct mga_device *mdev, const struct iosys_map *vmap,\n\t\t\t\t  struct drm_framebuffer *fb, struct drm_rect *clip)\n{\n\tstruct iosys_map dst = IOSYS_MAP_INIT_VADDR_IOMEM(mdev->vram);\n\n\tiosys_map_incr(&dst, drm_fb_clip_offset(fb->pitches[0], fb->format, clip));\n\tdrm_fb_memcpy(&dst, fb->pitches, vmap, fb, clip);\n}\n\n \n\nconst uint32_t mgag200_primary_plane_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n};\n\nconst size_t mgag200_primary_plane_formats_size = ARRAY_SIZE(mgag200_primary_plane_formats);\n\nconst uint64_t mgag200_primary_plane_fmtmods[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nint mgag200_primary_plane_helper_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t      struct drm_atomic_state *new_state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(new_state, plane);\n\tstruct drm_framebuffer *new_fb = new_plane_state->fb;\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_crtc *new_crtc = new_plane_state->crtc;\n\tstruct drm_crtc_state *new_crtc_state = NULL;\n\tstruct mgag200_crtc_state *new_mgag200_crtc_state;\n\tint ret;\n\n\tif (new_crtc)\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(new_state, new_crtc);\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, new_crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  false, true);\n\tif (ret)\n\t\treturn ret;\n\telse if (!new_plane_state->visible)\n\t\treturn 0;\n\n\tif (plane->state)\n\t\tfb = plane->state->fb;\n\n\tif (!fb || (fb->format != new_fb->format))\n\t\tnew_crtc_state->mode_changed = true;  \n\n\tnew_mgag200_crtc_state = to_mgag200_crtc_state(new_crtc_state);\n\tnew_mgag200_crtc_state->format = new_fb->format;\n\n\treturn 0;\n}\n\nvoid mgag200_primary_plane_helper_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t\tstruct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tstruct drm_plane_state *plane_state = plane->state;\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(old_state, plane);\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tstruct drm_atomic_helper_damage_iter iter;\n\tstruct drm_rect damage;\n\n\tdrm_atomic_helper_damage_iter_init(&iter, old_plane_state, plane_state);\n\tdrm_atomic_for_each_plane_damage(&iter, &damage) {\n\t\tmgag200_handle_damage(mdev, shadow_plane_state->data, fb, &damage);\n\t}\n\n\t \n\tmgag200_set_startadd(mdev, (u32)0);\n\tmgag200_set_offset(mdev, fb);\n}\n\nvoid mgag200_primary_plane_helper_atomic_enable(struct drm_plane *plane,\n\t\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tu8 seq1;\n\n\tRREG_SEQ(0x01, seq1);\n\tseq1 &= ~MGAREG_SEQ1_SCROFF;\n\tWREG_SEQ(0x01, seq1);\n\tmsleep(20);\n}\n\nvoid mgag200_primary_plane_helper_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t\t struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tu8 seq1;\n\n\tRREG_SEQ(0x01, seq1);\n\tseq1 |= MGAREG_SEQ1_SCROFF;\n\tWREG_SEQ(0x01, seq1);\n\tmsleep(20);\n}\n\n \n\nenum drm_mode_status mgag200_crtc_helper_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct mga_device *mdev = to_mga_device(crtc->dev);\n\tconst struct mgag200_device_info *info = mdev->info;\n\n\t \n\tif (mode->hdisplay > info->max_hdisplay)\n\t\treturn MODE_VIRTUAL_X;\n\tif (mode->vdisplay > info->max_vdisplay)\n\t\treturn MODE_VIRTUAL_Y;\n\n\tif ((mode->hdisplay % 8) != 0 || (mode->hsync_start % 8) != 0 ||\n\t    (mode->hsync_end % 8) != 0 || (mode->htotal % 8) != 0) {\n\t\treturn MODE_H_ILLEGAL;\n\t}\n\n\tif (mode->crtc_hdisplay > 2048 || mode->crtc_hsync_start > 4096 ||\n\t    mode->crtc_hsync_end > 4096 || mode->crtc_htotal > 4096 ||\n\t    mode->crtc_vdisplay > 2048 || mode->crtc_vsync_start > 4096 ||\n\t    mode->crtc_vsync_end > 4096 || mode->crtc_vtotal > 4096) {\n\t\treturn MODE_BAD;\n\t}\n\n\treturn MODE_OK;\n}\n\nint mgag200_crtc_helper_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *new_state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tconst struct mgag200_device_funcs *funcs = mdev->funcs;\n\tstruct drm_crtc_state *new_crtc_state = drm_atomic_get_new_crtc_state(new_state, crtc);\n\tstruct drm_property_blob *new_gamma_lut = new_crtc_state->gamma_lut;\n\tint ret;\n\n\tif (!new_crtc_state->enable)\n\t\treturn 0;\n\n\tret = drm_atomic_helper_check_crtc_primary_plane(new_crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (new_crtc_state->mode_changed) {\n\t\tif (funcs->pixpllc_atomic_check) {\n\t\t\tret = funcs->pixpllc_atomic_check(crtc, new_state);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (new_crtc_state->color_mgmt_changed && new_gamma_lut) {\n\t\tif (new_gamma_lut->length != MGAG200_LUT_SIZE * sizeof(struct drm_color_lut)) {\n\t\t\tdrm_dbg(dev, \"Wrong size for gamma_lut %zu\\n\", new_gamma_lut->length);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid mgag200_crtc_helper_atomic_flush(struct drm_crtc *crtc, struct drm_atomic_state *old_state)\n{\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct mgag200_crtc_state *mgag200_crtc_state = to_mgag200_crtc_state(crtc_state);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\n\tif (crtc_state->enable && crtc_state->color_mgmt_changed) {\n\t\tconst struct drm_format_info *format = mgag200_crtc_state->format;\n\n\t\tif (crtc_state->gamma_lut)\n\t\t\tmgag200_crtc_set_gamma(mdev, format, crtc_state->gamma_lut->data);\n\t\telse\n\t\t\tmgag200_crtc_set_gamma_linear(mdev, format);\n\t}\n}\n\nvoid mgag200_crtc_helper_atomic_enable(struct drm_crtc *crtc, struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tconst struct mgag200_device_funcs *funcs = mdev->funcs;\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;\n\tstruct mgag200_crtc_state *mgag200_crtc_state = to_mgag200_crtc_state(crtc_state);\n\tconst struct drm_format_info *format = mgag200_crtc_state->format;\n\n\tif (funcs->disable_vidrst)\n\t\tfuncs->disable_vidrst(mdev);\n\n\tmgag200_set_format_regs(mdev, format);\n\tmgag200_set_mode_regs(mdev, adjusted_mode);\n\n\tif (funcs->pixpllc_atomic_update)\n\t\tfuncs->pixpllc_atomic_update(crtc, old_state);\n\n\tif (crtc_state->gamma_lut)\n\t\tmgag200_crtc_set_gamma(mdev, format, crtc_state->gamma_lut->data);\n\telse\n\t\tmgag200_crtc_set_gamma_linear(mdev, format);\n\n\tmgag200_enable_display(mdev);\n\n\tif (funcs->enable_vidrst)\n\t\tfuncs->enable_vidrst(mdev);\n}\n\nvoid mgag200_crtc_helper_atomic_disable(struct drm_crtc *crtc, struct drm_atomic_state *old_state)\n{\n\tstruct mga_device *mdev = to_mga_device(crtc->dev);\n\tconst struct mgag200_device_funcs *funcs = mdev->funcs;\n\n\tif (funcs->disable_vidrst)\n\t\tfuncs->disable_vidrst(mdev);\n\n\tmgag200_disable_display(mdev);\n\n\tif (funcs->enable_vidrst)\n\t\tfuncs->enable_vidrst(mdev);\n}\n\nvoid mgag200_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct mgag200_crtc_state *mgag200_crtc_state;\n\n\tif (crtc->state)\n\t\tcrtc->funcs->atomic_destroy_state(crtc, crtc->state);\n\n\tmgag200_crtc_state = kzalloc(sizeof(*mgag200_crtc_state), GFP_KERNEL);\n\tif (mgag200_crtc_state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &mgag200_crtc_state->base);\n\telse\n\t\t__drm_atomic_helper_crtc_reset(crtc, NULL);\n}\n\nstruct drm_crtc_state *mgag200_crtc_atomic_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct mgag200_crtc_state *mgag200_crtc_state = to_mgag200_crtc_state(crtc_state);\n\tstruct mgag200_crtc_state *new_mgag200_crtc_state;\n\n\tif (!crtc_state)\n\t\treturn NULL;\n\n\tnew_mgag200_crtc_state = kzalloc(sizeof(*new_mgag200_crtc_state), GFP_KERNEL);\n\tif (!new_mgag200_crtc_state)\n\t\treturn NULL;\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &new_mgag200_crtc_state->base);\n\n\tnew_mgag200_crtc_state->format = mgag200_crtc_state->format;\n\tmemcpy(&new_mgag200_crtc_state->pixpllc, &mgag200_crtc_state->pixpllc,\n\t       sizeof(new_mgag200_crtc_state->pixpllc));\n\n\treturn &new_mgag200_crtc_state->base;\n}\n\nvoid mgag200_crtc_atomic_destroy_state(struct drm_crtc *crtc, struct drm_crtc_state *crtc_state)\n{\n\tstruct mgag200_crtc_state *mgag200_crtc_state = to_mgag200_crtc_state(crtc_state);\n\n\t__drm_atomic_helper_crtc_destroy_state(&mgag200_crtc_state->base);\n\tkfree(mgag200_crtc_state);\n}\n\n \n\nint mgag200_vga_connector_helper_get_modes(struct drm_connector *connector)\n{\n\tstruct mga_device *mdev = to_mga_device(connector->dev);\n\tint ret;\n\n\t \n\tmutex_lock(&mdev->rmmio_lock);\n\tret = drm_connector_helper_get_modes_from_ddc(connector);\n\tmutex_unlock(&mdev->rmmio_lock);\n\n\treturn ret;\n}\n\n \n\nstatic void mgag200_mode_config_helper_atomic_commit_tail(struct drm_atomic_state *state)\n{\n\tstruct mga_device *mdev = to_mga_device(state->dev);\n\n\t \n\tmutex_lock(&mdev->rmmio_lock);\n\tdrm_atomic_helper_commit_tail(state);\n\tmutex_unlock(&mdev->rmmio_lock);\n}\n\nstatic const struct drm_mode_config_helper_funcs mgag200_mode_config_helper_funcs = {\n\t.atomic_commit_tail = mgag200_mode_config_helper_atomic_commit_tail,\n};\n\n \nstatic uint32_t mgag200_calculate_mode_bandwidth(const struct drm_display_mode *mode,\n\t\t\t\t\t\t unsigned int bits_per_pixel)\n{\n\tuint32_t total_area, divisor;\n\tuint64_t active_area, pixels_per_second, bandwidth;\n\tuint64_t bytes_per_pixel = (bits_per_pixel + 7) / 8;\n\n\tdivisor = 1024;\n\n\tif (!mode->htotal || !mode->vtotal || !mode->clock)\n\t\treturn 0;\n\n\tactive_area = mode->hdisplay * mode->vdisplay;\n\ttotal_area = mode->htotal * mode->vtotal;\n\n\tpixels_per_second = active_area * mode->clock * 1000;\n\tdo_div(pixels_per_second, total_area);\n\n\tbandwidth = pixels_per_second * bytes_per_pixel * 100;\n\tdo_div(bandwidth, divisor);\n\n\treturn (uint32_t)bandwidth;\n}\n\nstatic enum drm_mode_status mgag200_mode_config_mode_valid(struct drm_device *dev,\n\t\t\t\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tstatic const unsigned int max_bpp = 4;  \n\tstruct mga_device *mdev = to_mga_device(dev);\n\tunsigned long fbsize, fbpages, max_fbpages;\n\tconst struct mgag200_device_info *info = mdev->info;\n\n\tmax_fbpages = mdev->vram_available >> PAGE_SHIFT;\n\n\tfbsize = mode->hdisplay * mode->vdisplay * max_bpp;\n\tfbpages = DIV_ROUND_UP(fbsize, PAGE_SIZE);\n\n\tif (fbpages > max_fbpages)\n\t\treturn MODE_MEM;\n\n\t \n\tif (info->max_mem_bandwidth) {\n\t\tuint32_t mode_bandwidth = mgag200_calculate_mode_bandwidth(mode, max_bpp * 8);\n\n\t\tif (mode_bandwidth > (info->max_mem_bandwidth * 1024))\n\t\t\treturn MODE_BAD;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_mode_config_funcs mgag200_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.mode_valid = mgag200_mode_config_mode_valid,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nint mgag200_mode_config_init(struct mga_device *mdev, resource_size_t vram_available)\n{\n\tstruct drm_device *dev = &mdev->base;\n\tint ret;\n\n\tmdev->vram_available = vram_available;\n\n\tret = drmm_mode_config_init(dev);\n\tif (ret) {\n\t\tdrm_err(dev, \"drmm_mode_config_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev->mode_config.max_width = MGAG200_MAX_FB_WIDTH;\n\tdev->mode_config.max_height = MGAG200_MAX_FB_HEIGHT;\n\tdev->mode_config.preferred_depth = 24;\n\tdev->mode_config.funcs = &mgag200_mode_config_funcs;\n\tdev->mode_config.helper_private = &mgag200_mode_config_helper_funcs;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}