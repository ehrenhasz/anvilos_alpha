{
  "module_name": "mgag200_drv.h",
  "hash_id": "abe15ce1d57b559185f8c0508e6e9c1260359bcd2fb946ebbbecf3475d5af813",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mgag200/mgag200_drv.h",
  "human_readable_source": " \n \n#ifndef __MGAG200_DRV_H__\n#define __MGAG200_DRV_H__\n\n#include <linux/i2c-algo-bit.h>\n#include <linux/i2c.h>\n\n#include <video/vga.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_plane.h>\n\n#include \"mgag200_reg.h\"\n\n#define DRIVER_AUTHOR\t\t\"Matthew Garrett\"\n\n#define DRIVER_NAME\t\t\"mgag200\"\n#define DRIVER_DESC\t\t\"MGA G200 SE\"\n#define DRIVER_DATE\t\t\"20110418\"\n\n#define DRIVER_MAJOR\t\t1\n#define DRIVER_MINOR\t\t0\n#define DRIVER_PATCHLEVEL\t0\n\n#define RREG8(reg) ioread8(((void __iomem *)mdev->rmmio) + (reg))\n#define WREG8(reg, v) iowrite8(v, ((void __iomem *)mdev->rmmio) + (reg))\n#define RREG32(reg) ioread32(((void __iomem *)mdev->rmmio) + (reg))\n#define WREG32(reg, v) iowrite32(v, ((void __iomem *)mdev->rmmio) + (reg))\n\n#define MGA_BIOS_OFFSET\t\t0x7ffc\n\n#define ATTR_INDEX 0x1fc0\n#define ATTR_DATA 0x1fc1\n\n#define WREG_MISC(v)\t\t\t\t\t\t\\\n\tWREG8(MGA_MISC_OUT, v)\n\n#define RREG_MISC(v)\t\t\t\t\t\t\\\n\t((v) = RREG8(MGA_MISC_IN))\n\n#define WREG_MISC_MASKED(v, mask)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tu8 misc_;\t\t\t\t\t\\\n\t\tu8 mask_ = (mask);\t\t\t\t\\\n\t\tRREG_MISC(misc_);\t\t\t\t\\\n\t\tmisc_ &= ~mask_;\t\t\t\t\\\n\t\tmisc_ |= ((v) & mask_);\t\t\t\t\\\n\t\tWREG_MISC(misc_);\t\t\t\t\\\n\t} while (0)\n\n#define WREG_ATTR(reg, v)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tRREG8(0x1fda);\t\t\t\t\t\\\n\t\tWREG8(ATTR_INDEX, reg);\t\t\t\t\\\n\t\tWREG8(ATTR_DATA, v);\t\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define RREG_SEQ(reg, v)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tWREG8(MGAREG_SEQ_INDEX, reg);\t\t\t\\\n\t\tv = RREG8(MGAREG_SEQ_DATA);\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define WREG_SEQ(reg, v)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tWREG8(MGAREG_SEQ_INDEX, reg);\t\t\t\\\n\t\tWREG8(MGAREG_SEQ_DATA, v);\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define RREG_CRT(reg, v)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tWREG8(MGAREG_CRTC_INDEX, reg);\t\t\t\\\n\t\tv = RREG8(MGAREG_CRTC_DATA);\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define WREG_CRT(reg, v)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tWREG8(MGAREG_CRTC_INDEX, reg);\t\t\t\\\n\t\tWREG8(MGAREG_CRTC_DATA, v);\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define RREG_ECRT(reg, v)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tWREG8(MGAREG_CRTCEXT_INDEX, reg);\t\t\\\n\t\tv = RREG8(MGAREG_CRTCEXT_DATA);\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define WREG_ECRT(reg, v)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tWREG8(MGAREG_CRTCEXT_INDEX, reg);\t\t\t\t\\\n\t\tWREG8(MGAREG_CRTCEXT_DATA, v);\t\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define GFX_INDEX 0x1fce\n#define GFX_DATA 0x1fcf\n\n#define WREG_GFX(reg, v)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tWREG8(GFX_INDEX, reg);\t\t\t\t\\\n\t\tWREG8(GFX_DATA, v);\t\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define DAC_INDEX 0x3c00\n#define DAC_DATA 0x3c0a\n\n#define WREG_DAC(reg, v)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tWREG8(DAC_INDEX, reg);\t\t\t\t\\\n\t\tWREG8(DAC_DATA, v);\t\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define MGA_MISC_OUT 0x1fc2\n#define MGA_MISC_IN 0x1fcc\n\n \n#define MGAG200_DAC_DEFAULT(xvrefctrl, xpixclkctrl, xmiscctrl, xsyspllm, xsysplln, xsyspllp)\t\\\n\t         0,    0,    0,    0,    0,    0, 0x00,    0,\t\t\t\t\\\n\t         0,    0,    0,    0,    0,    0,    0,    0,\t\t\t\t\\\n\t         0,    0,    0,    0,    0,    0,    0,    0,\t\t\t\t\\\n\t      (xvrefctrl),\t\t\t\t\t\t\t\t\\\n\t         0,\t\t\t\t\t\t\t\t\t\\\n\t      (xpixclkctrl),\t\t\t\t\t\t\t\t\\\n\t      0xff, 0xbf, 0x20,\t\t\t\t\t\t\t\\\n\t \t(xmiscctrl),\t\t\t\t\t\t\t\t\\\n\t \t0x20,\t\t\t\t\t\t\t\t\t\\\n\t      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\t\t\t\t\\\n\t      0x00, 0x00, 0x00, 0x00,\t\t\t\t\t\t\t\\\n\t      (xsyspllm),\t\t\t\t\t\t\t\t\\\n\t      (xsysplln),\t\t\t\t\t\t\t\t\\\n\t      (xsyspllp),\t\t\t\t\t\t\t\t\\\n\t      0x40,\t\t\t\t\t\t\t\t\t\\\n\t      0x00, 0xb0, 0x00, 0xc2, 0x34, 0x14, 0x02, 0x83,\t\t\t\t\\\n\t      0x00, 0x93, 0x00, 0x77, 0x00, 0x00, 0x00, 0x3a,\t\t\t\t\\\n\t         0,    0,    0,    0,    0,    0,    0,    0,\t\t\t\t\\\n\t         0,    0,    0,    0,    0,    0,    0,    0\t\t\t\t\\\n\n#define MGAG200_LUT_SIZE 256\n\n#define MGAG200_MAX_FB_HEIGHT 4096\n#define MGAG200_MAX_FB_WIDTH 4096\n\nstruct mga_device;\n\n \nstruct mgag200_pll_values {\n\tunsigned int m;\n\tunsigned int n;\n\tunsigned int p;\n\tunsigned int s;\n};\n\nstruct mgag200_crtc_state {\n\tstruct drm_crtc_state base;\n\n\t \n\tconst struct drm_format_info *format;\n\n\tstruct mgag200_pll_values pixpllc;\n};\n\nstatic inline struct mgag200_crtc_state *to_mgag200_crtc_state(struct drm_crtc_state *base)\n{\n\treturn container_of(base, struct mgag200_crtc_state, base);\n}\n\nstruct mga_i2c_chan {\n\tstruct i2c_adapter adapter;\n\tstruct drm_device *dev;\n\tstruct i2c_algo_bit_data bit;\n\tint data, clock;\n};\n\nenum mga_type {\n\tG200_PCI,\n\tG200_AGP,\n\tG200_SE_A,\n\tG200_SE_B,\n\tG200_WB,\n\tG200_EV,\n\tG200_EH,\n\tG200_EH3,\n\tG200_ER,\n\tG200_EW3,\n};\n\nstruct mgag200_device_info {\n\tu16 max_hdisplay;\n\tu16 max_vdisplay;\n\n\t \n\tunsigned long max_mem_bandwidth;\n\n\t \n\tbool has_vidrst:1;\n\n\tstruct {\n\t\tunsigned data_bit:3;\n\t\tunsigned clock_bit:3;\n\t} i2c;\n\n\t \n\tbool bug_no_startadd:1;\n};\n\n#define MGAG200_DEVICE_INFO_INIT(_max_hdisplay, _max_vdisplay, _max_mem_bandwidth, \\\n\t\t\t\t _has_vidrst, _i2c_data_bit, _i2c_clock_bit, \\\n\t\t\t\t _bug_no_startadd) \\\n\t{ \\\n\t\t.max_hdisplay = (_max_hdisplay), \\\n\t\t.max_vdisplay = (_max_vdisplay), \\\n\t\t.max_mem_bandwidth = (_max_mem_bandwidth), \\\n\t\t.has_vidrst = (_has_vidrst), \\\n\t\t.i2c = { \\\n\t\t\t.data_bit = (_i2c_data_bit), \\\n\t\t\t.clock_bit = (_i2c_clock_bit), \\\n\t\t}, \\\n\t\t.bug_no_startadd = (_bug_no_startadd), \\\n\t}\n\nstruct mgag200_device_funcs {\n\t \n\tvoid (*disable_vidrst)(struct mga_device *mdev);\n\n\t \n\tvoid (*enable_vidrst)(struct mga_device *mdev);\n\n\t \n\tint (*pixpllc_atomic_check)(struct drm_crtc *crtc, struct drm_atomic_state *new_state);\n\n\t \n\tvoid (*pixpllc_atomic_update)(struct drm_crtc *crtc, struct drm_atomic_state *old_state);\n};\n\nstruct mga_device {\n\tstruct drm_device base;\n\n\tconst struct mgag200_device_info *info;\n\tconst struct mgag200_device_funcs *funcs;\n\n\tstruct resource\t\t\t*rmmio_res;\n\tvoid __iomem\t\t\t*rmmio;\n\tstruct mutex\t\t\trmmio_lock;  \n\n\tstruct resource\t\t\t*vram_res;\n\tvoid __iomem\t\t\t*vram;\n\tresource_size_t\t\t\tvram_available;\n\n\tstruct drm_plane primary_plane;\n\tstruct drm_crtc crtc;\n\tstruct drm_encoder encoder;\n\tstruct mga_i2c_chan i2c;\n\tstruct drm_connector connector;\n};\n\nstatic inline struct mga_device *to_mga_device(struct drm_device *dev)\n{\n\treturn container_of(dev, struct mga_device, base);\n}\n\nstruct mgag200_g200_device {\n\tstruct mga_device base;\n\n\t \n\tlong ref_clk;\n\tlong pclk_min;\n\tlong pclk_max;\n};\n\nstatic inline struct mgag200_g200_device *to_mgag200_g200_device(struct drm_device *dev)\n{\n\treturn container_of(to_mga_device(dev), struct mgag200_g200_device, base);\n}\n\nstruct mgag200_g200se_device {\n\tstruct mga_device base;\n\n\t \n\tu32 unique_rev_id;\n};\n\nstatic inline struct mgag200_g200se_device *to_mgag200_g200se_device(struct drm_device *dev)\n{\n\treturn container_of(to_mga_device(dev), struct mgag200_g200se_device, base);\n}\n\n\t\t\t\t \nint mgag200_init_pci_options(struct pci_dev *pdev, u32 option, u32 option2);\nresource_size_t mgag200_probe_vram(void __iomem *mem, resource_size_t size);\nresource_size_t mgag200_device_probe_vram(struct mga_device *mdev);\nint mgag200_device_preinit(struct mga_device *mdev);\nint mgag200_device_init(struct mga_device *mdev,\n\t\t\tconst struct mgag200_device_info *info,\n\t\t\tconst struct mgag200_device_funcs *funcs);\n\n\t\t\t\t \nstruct mga_device *mgag200_g200_device_create(struct pci_dev *pdev, const struct drm_driver *drv);\nstruct mga_device *mgag200_g200se_device_create(struct pci_dev *pdev, const struct drm_driver *drv,\n\t\t\t\t\t\tenum mga_type type);\nvoid mgag200_g200wb_init_registers(struct mga_device *mdev);\nvoid mgag200_g200wb_pixpllc_atomic_update(struct drm_crtc *crtc, struct drm_atomic_state *old_state);\nstruct mga_device *mgag200_g200wb_device_create(struct pci_dev *pdev, const struct drm_driver *drv);\nstruct mga_device *mgag200_g200ev_device_create(struct pci_dev *pdev, const struct drm_driver *drv);\nvoid mgag200_g200eh_init_registers(struct mga_device *mdev);\nvoid mgag200_g200eh_pixpllc_atomic_update(struct drm_crtc *crtc, struct drm_atomic_state *old_state);\nstruct mga_device *mgag200_g200eh_device_create(struct pci_dev *pdev,\n\t\t\t\t\t\tconst struct drm_driver *drv);\nstruct mga_device *mgag200_g200eh3_device_create(struct pci_dev *pdev,\n\t\t\t\t\t\t const struct drm_driver *drv);\nstruct mga_device *mgag200_g200er_device_create(struct pci_dev *pdev,\n\t\t\t\t\t\tconst struct drm_driver *drv);\nstruct mga_device *mgag200_g200ew3_device_create(struct pci_dev *pdev,\n\t\t\t\t\t\t const struct drm_driver *drv);\n\n \n\nstruct drm_crtc;\nstruct drm_crtc_state;\nstruct drm_display_mode;\nstruct drm_plane;\nstruct drm_atomic_state;\n\nextern const uint32_t mgag200_primary_plane_formats[];\nextern const size_t   mgag200_primary_plane_formats_size;\nextern const uint64_t mgag200_primary_plane_fmtmods[];\n\nint mgag200_primary_plane_helper_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t      struct drm_atomic_state *new_state);\nvoid mgag200_primary_plane_helper_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t\tstruct drm_atomic_state *old_state);\nvoid mgag200_primary_plane_helper_atomic_enable(struct drm_plane *plane,\n\t\t\t\t\t\tstruct drm_atomic_state *state);\nvoid mgag200_primary_plane_helper_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t\t struct drm_atomic_state *old_state);\n#define MGAG200_PRIMARY_PLANE_HELPER_FUNCS \\\n\tDRM_GEM_SHADOW_PLANE_HELPER_FUNCS, \\\n\t.atomic_check = mgag200_primary_plane_helper_atomic_check, \\\n\t.atomic_update = mgag200_primary_plane_helper_atomic_update, \\\n\t.atomic_enable = mgag200_primary_plane_helper_atomic_enable, \\\n\t.atomic_disable = mgag200_primary_plane_helper_atomic_disable\n\n#define MGAG200_PRIMARY_PLANE_FUNCS \\\n\t.update_plane = drm_atomic_helper_update_plane, \\\n\t.disable_plane = drm_atomic_helper_disable_plane, \\\n\t.destroy = drm_plane_cleanup, \\\n\tDRM_GEM_SHADOW_PLANE_FUNCS\n\nvoid mgag200_crtc_set_gamma_linear(struct mga_device *mdev, const struct drm_format_info *format);\nvoid mgag200_crtc_set_gamma(struct mga_device *mdev,\n\t\t\t    const struct drm_format_info *format,\n\t\t\t    struct drm_color_lut *lut);\n\nenum drm_mode_status mgag200_crtc_helper_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t\t\t    const struct drm_display_mode *mode);\nint mgag200_crtc_helper_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *new_state);\nvoid mgag200_crtc_helper_atomic_flush(struct drm_crtc *crtc, struct drm_atomic_state *old_state);\nvoid mgag200_crtc_helper_atomic_enable(struct drm_crtc *crtc, struct drm_atomic_state *old_state);\nvoid mgag200_crtc_helper_atomic_disable(struct drm_crtc *crtc, struct drm_atomic_state *old_state);\n\n#define MGAG200_CRTC_HELPER_FUNCS \\\n\t.mode_valid = mgag200_crtc_helper_mode_valid, \\\n\t.atomic_check = mgag200_crtc_helper_atomic_check, \\\n\t.atomic_flush = mgag200_crtc_helper_atomic_flush, \\\n\t.atomic_enable = mgag200_crtc_helper_atomic_enable, \\\n\t.atomic_disable = mgag200_crtc_helper_atomic_disable\n\nvoid mgag200_crtc_reset(struct drm_crtc *crtc);\nstruct drm_crtc_state *mgag200_crtc_atomic_duplicate_state(struct drm_crtc *crtc);\nvoid mgag200_crtc_atomic_destroy_state(struct drm_crtc *crtc, struct drm_crtc_state *crtc_state);\n\n#define MGAG200_CRTC_FUNCS \\\n\t.reset = mgag200_crtc_reset, \\\n\t.destroy = drm_crtc_cleanup, \\\n\t.set_config = drm_atomic_helper_set_config, \\\n\t.page_flip = drm_atomic_helper_page_flip, \\\n\t.atomic_duplicate_state = mgag200_crtc_atomic_duplicate_state, \\\n\t.atomic_destroy_state = mgag200_crtc_atomic_destroy_state\n\n#define MGAG200_DAC_ENCODER_FUNCS \\\n\t.destroy = drm_encoder_cleanup\n\nint mgag200_vga_connector_helper_get_modes(struct drm_connector *connector);\n\n#define MGAG200_VGA_CONNECTOR_HELPER_FUNCS \\\n\t.get_modes  = mgag200_vga_connector_helper_get_modes\n\n#define MGAG200_VGA_CONNECTOR_FUNCS \\\n\t.reset                  = drm_atomic_helper_connector_reset, \\\n\t.fill_modes             = drm_helper_probe_single_connector_modes, \\\n\t.destroy                = drm_connector_cleanup, \\\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state, \\\n\t.atomic_destroy_state   = drm_atomic_helper_connector_destroy_state\n\nvoid mgag200_set_mode_regs(struct mga_device *mdev, const struct drm_display_mode *mode);\nvoid mgag200_set_format_regs(struct mga_device *mdev, const struct drm_format_info *format);\nvoid mgag200_enable_display(struct mga_device *mdev);\nvoid mgag200_init_registers(struct mga_device *mdev);\nint mgag200_mode_config_init(struct mga_device *mdev, resource_size_t vram_available);\n\n\t\t\t\t \nvoid mgag200_bmc_disable_vidrst(struct mga_device *mdev);\nvoid mgag200_bmc_enable_vidrst(struct mga_device *mdev);\n\n\t\t\t\t \nint mgag200_i2c_init(struct mga_device *mdev, struct mga_i2c_chan *i2c);\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}