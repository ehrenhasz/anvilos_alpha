{
  "module_name": "mgag200_g200se.c",
  "hash_id": "ae274cbaad762533a1486450e4f3fc94aa4a413b762415bf9445c5b26cd70183",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mgag200/mgag200_g200se.c",
  "human_readable_source": "\n\n#include <linux/delay.h>\n#include <linux/pci.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mgag200_drv.h\"\n\nstatic int mgag200_g200se_init_pci_options(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tbool has_sgram;\n\tu32 option;\n\tint err;\n\n\terr = pci_read_config_dword(pdev, PCI_MGA_OPTION, &option);\n\tif (err != PCIBIOS_SUCCESSFUL) {\n\t\tdev_err(dev, \"pci_read_config_dword(PCI_MGA_OPTION) failed: %d\\n\", err);\n\t\treturn pcibios_err_to_errno(err);\n\t}\n\n\thas_sgram = !!(option & PCI_MGA_OPTION_HARDPWMSK);\n\n\toption = 0x40049120;\n\tif (has_sgram)\n\t\toption |= PCI_MGA_OPTION_HARDPWMSK;\n\n\treturn mgag200_init_pci_options(pdev, option, 0x00008000);\n}\n\nstatic void mgag200_g200se_init_registers(struct mgag200_g200se_device *g200se)\n{\n\tstatic const u8 dacvalue[] = {\n\t\tMGAG200_DAC_DEFAULT(0x03,\n\t\t\t\t    MGA1064_PIX_CLK_CTL_SEL_PLL,\n\t\t\t\t    MGA1064_MISC_CTL_DAC_EN |\n\t\t\t\t    MGA1064_MISC_CTL_VGA8 |\n\t\t\t\t    MGA1064_MISC_CTL_DAC_RAM_CS,\n\t\t\t\t    0x00, 0x00, 0x00)\n\t};\n\n\tstruct mga_device *mdev = &g200se->base;\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dacvalue); i++) {\n\t\tif ((i <= 0x17) ||\n\t\t    (i == 0x1b) ||\n\t\t    (i == 0x1c) ||\n\t\t    ((i >= 0x1f) && (i <= 0x29)) ||\n\t\t    ((i == 0x2c) || (i == 0x2d) || (i == 0x2e)) ||\n\t\t    ((i >= 0x30) && (i <= 0x37)))\n\t\t\tcontinue;\n\t\tWREG_DAC(i, dacvalue[i]);\n\t}\n\n\tmgag200_init_registers(mdev);\n}\n\nstatic void mgag200_g200se_set_hiprilvl(struct mga_device *mdev,\n\t\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\t\tconst struct drm_format_info *format)\n{\n\tstruct mgag200_g200se_device *g200se = to_mgag200_g200se_device(&mdev->base);\n\tunsigned int hiprilvl;\n\tu8 crtcext6;\n\n\tif  (g200se->unique_rev_id >= 0x04) {\n\t\thiprilvl = 0;\n\t} else if (g200se->unique_rev_id >= 0x02) {\n\t\tunsigned int bpp;\n\t\tunsigned long mb;\n\n\t\tif (format->cpp[0] * 8 > 16)\n\t\t\tbpp = 32;\n\t\telse if (format->cpp[0] * 8 > 8)\n\t\t\tbpp = 16;\n\t\telse\n\t\t\tbpp = 8;\n\n\t\tmb = (mode->clock * bpp) / 1000;\n\t\tif (mb > 3100)\n\t\t\thiprilvl = 0;\n\t\telse if (mb > 2600)\n\t\t\thiprilvl = 1;\n\t\telse if (mb > 1900)\n\t\t\thiprilvl = 2;\n\t\telse if (mb > 1160)\n\t\t\thiprilvl = 3;\n\t\telse if (mb > 440)\n\t\t\thiprilvl = 4;\n\t\telse\n\t\t\thiprilvl = 5;\n\n\t} else if (g200se->unique_rev_id >= 0x01) {\n\t\thiprilvl = 3;\n\t} else {\n\t\thiprilvl = 4;\n\t}\n\n\tcrtcext6 = hiprilvl;  \n\n\tWREG_ECRT(0x06, crtcext6);\n}\n\n \n\nstatic int mgag200_g200se_00_pixpllc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\t\t  struct drm_atomic_state *new_state)\n{\n\tstatic const unsigned int vcomax = 320000;\n\tstatic const unsigned int vcomin = 160000;\n\tstatic const unsigned int pllreffreq = 25000;\n\n\tstruct drm_crtc_state *new_crtc_state = drm_atomic_get_new_crtc_state(new_state, crtc);\n\tstruct mgag200_crtc_state *new_mgag200_crtc_state = to_mgag200_crtc_state(new_crtc_state);\n\tlong clock = new_crtc_state->mode.clock;\n\tstruct mgag200_pll_values *pixpllc = &new_mgag200_crtc_state->pixpllc;\n\tunsigned int delta, tmpdelta, permitteddelta;\n\tunsigned int testp, testm, testn;\n\tunsigned int p, m, n, s;\n\tunsigned int computed;\n\n\tm = n = p = s = 0;\n\tdelta = 0xffffffff;\n\tpermitteddelta = clock * 5 / 1000;\n\n\tfor (testp = 8; testp > 0; testp /= 2) {\n\t\tif (clock * testp > vcomax)\n\t\t\tcontinue;\n\t\tif (clock * testp < vcomin)\n\t\t\tcontinue;\n\n\t\tfor (testn = 17; testn < 256; testn++) {\n\t\t\tfor (testm = 1; testm < 32; testm++) {\n\t\t\t\tcomputed = (pllreffreq * testn) / (testm * testp);\n\t\t\t\tif (computed > clock)\n\t\t\t\t\ttmpdelta = computed - clock;\n\t\t\t\telse\n\t\t\t\t\ttmpdelta = clock - computed;\n\t\t\t\tif (tmpdelta < delta) {\n\t\t\t\t\tdelta = tmpdelta;\n\t\t\t\t\tm = testm;\n\t\t\t\t\tn = testn;\n\t\t\t\t\tp = testp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (delta > permitteddelta) {\n\t\tpr_warn(\"PLL delta too large\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpixpllc->m = m;\n\tpixpllc->n = n;\n\tpixpllc->p = p;\n\tpixpllc->s = s;\n\n\treturn 0;\n}\n\nstatic void mgag200_g200se_00_pixpllc_atomic_update(struct drm_crtc *crtc,\n\t\t\t\t\t\t    struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct mgag200_crtc_state *mgag200_crtc_state = to_mgag200_crtc_state(crtc_state);\n\tstruct mgag200_pll_values *pixpllc = &mgag200_crtc_state->pixpllc;\n\tunsigned int pixpllcm, pixpllcn, pixpllcp, pixpllcs;\n\tu8 xpixpllcm, xpixpllcn, xpixpllcp;\n\n\tpixpllcm = pixpllc->m - 1;\n\tpixpllcn = pixpllc->n - 1;\n\tpixpllcp = pixpllc->p - 1;\n\tpixpllcs = pixpllc->s;\n\n\txpixpllcm = pixpllcm | ((pixpllcn & BIT(8)) >> 1);\n\txpixpllcn = pixpllcn;\n\txpixpllcp = (pixpllcs << 3) | pixpllcp;\n\n\tWREG_MISC_MASKED(MGAREG_MISC_CLKSEL_MGA, MGAREG_MISC_CLKSEL_MASK);\n\n\tWREG_DAC(MGA1064_PIX_PLLC_M, xpixpllcm);\n\tWREG_DAC(MGA1064_PIX_PLLC_N, xpixpllcn);\n\tWREG_DAC(MGA1064_PIX_PLLC_P, xpixpllcp);\n}\n\nstatic int mgag200_g200se_04_pixpllc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\t\t  struct drm_atomic_state *new_state)\n{\n\tstatic const unsigned int vcomax = 1600000;\n\tstatic const unsigned int vcomin = 800000;\n\tstatic const unsigned int pllreffreq = 25000;\n\tstatic const unsigned int pvalues_e4[] = {16, 14, 12, 10, 8, 6, 4, 2, 1};\n\n\tstruct drm_crtc_state *new_crtc_state = drm_atomic_get_new_crtc_state(new_state, crtc);\n\tstruct mgag200_crtc_state *new_mgag200_crtc_state = to_mgag200_crtc_state(new_crtc_state);\n\tlong clock = new_crtc_state->mode.clock;\n\tstruct mgag200_pll_values *pixpllc = &new_mgag200_crtc_state->pixpllc;\n\tunsigned int delta, tmpdelta, permitteddelta;\n\tunsigned int testp, testm, testn;\n\tunsigned int p, m, n, s;\n\tunsigned int computed;\n\tunsigned int fvv;\n\tunsigned int i;\n\n\tm = n = p = s = 0;\n\tdelta = 0xffffffff;\n\n\tif (clock < 25000)\n\t\tclock = 25000;\n\tclock = clock * 2;\n\n\t \n\tpermitteddelta = clock * 5 / 1000;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(pvalues_e4); i++) {\n\t\ttestp = pvalues_e4[i];\n\n\t\tif ((clock * testp) > vcomax)\n\t\t\tcontinue;\n\t\tif ((clock * testp) < vcomin)\n\t\t\tcontinue;\n\n\t\tfor (testn = 50; testn <= 256; testn++) {\n\t\t\tfor (testm = 1; testm <= 32; testm++) {\n\t\t\t\tcomputed = (pllreffreq * testn) / (testm * testp);\n\t\t\t\tif (computed > clock)\n\t\t\t\t\ttmpdelta = computed - clock;\n\t\t\t\telse\n\t\t\t\t\ttmpdelta = clock - computed;\n\n\t\t\t\tif (tmpdelta < delta) {\n\t\t\t\t\tdelta = tmpdelta;\n\t\t\t\t\tm = testm;\n\t\t\t\t\tn = testn;\n\t\t\t\t\tp = testp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfvv = pllreffreq * n / m;\n\tfvv = (fvv - 800000) / 50000;\n\tif (fvv > 15)\n\t\tfvv = 15;\n\ts = fvv << 1;\n\n\tif (delta > permitteddelta) {\n\t\tpr_warn(\"PLL delta too large\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpixpllc->m = m;\n\tpixpllc->n = n;\n\tpixpllc->p = p;\n\tpixpllc->s = s;\n\n\treturn 0;\n}\n\nstatic void mgag200_g200se_04_pixpllc_atomic_update(struct drm_crtc *crtc,\n\t\t\t\t\t\t    struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct mgag200_crtc_state *mgag200_crtc_state = to_mgag200_crtc_state(crtc_state);\n\tstruct mgag200_pll_values *pixpllc = &mgag200_crtc_state->pixpllc;\n\tunsigned int pixpllcm, pixpllcn, pixpllcp, pixpllcs;\n\tu8 xpixpllcm, xpixpllcn, xpixpllcp;\n\n\tpixpllcm = pixpllc->m - 1;\n\tpixpllcn = pixpllc->n - 1;\n\tpixpllcp = pixpllc->p - 1;\n\tpixpllcs = pixpllc->s;\n\n\t\n\txpixpllcm = BIT(7) | pixpllcm;\n\txpixpllcn = pixpllcn;\n\txpixpllcp = (pixpllcs << 3) | pixpllcp;\n\n\tWREG_MISC_MASKED(MGAREG_MISC_CLKSEL_MGA, MGAREG_MISC_CLKSEL_MASK);\n\n\tWREG_DAC(MGA1064_PIX_PLLC_M, xpixpllcm);\n\tWREG_DAC(MGA1064_PIX_PLLC_N, xpixpllcn);\n\tWREG_DAC(MGA1064_PIX_PLLC_P, xpixpllcp);\n\n\tWREG_DAC(0x1a, 0x09);\n\tmsleep(20);\n\tWREG_DAC(0x1a, 0x01);\n}\n\n \n\nstatic const struct drm_plane_helper_funcs mgag200_g200se_primary_plane_helper_funcs = {\n\tMGAG200_PRIMARY_PLANE_HELPER_FUNCS,\n};\n\nstatic const struct drm_plane_funcs mgag200_g200se_primary_plane_funcs = {\n\tMGAG200_PRIMARY_PLANE_FUNCS,\n};\n\nstatic void mgag200_g200se_crtc_helper_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t\t\t     struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tconst struct mgag200_device_funcs *funcs = mdev->funcs;\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;\n\tstruct mgag200_crtc_state *mgag200_crtc_state = to_mgag200_crtc_state(crtc_state);\n\tconst struct drm_format_info *format = mgag200_crtc_state->format;\n\n\tif (funcs->disable_vidrst)\n\t\tfuncs->disable_vidrst(mdev);\n\n\tmgag200_set_format_regs(mdev, format);\n\tmgag200_set_mode_regs(mdev, adjusted_mode);\n\n\tif (funcs->pixpllc_atomic_update)\n\t\tfuncs->pixpllc_atomic_update(crtc, old_state);\n\n\tmgag200_g200se_set_hiprilvl(mdev, adjusted_mode, format);\n\n\tif (crtc_state->gamma_lut)\n\t\tmgag200_crtc_set_gamma(mdev, format, crtc_state->gamma_lut->data);\n\telse\n\t\tmgag200_crtc_set_gamma_linear(mdev, format);\n\n\tmgag200_enable_display(mdev);\n\n\tif (funcs->enable_vidrst)\n\t\tfuncs->enable_vidrst(mdev);\n}\n\nstatic const struct drm_crtc_helper_funcs mgag200_g200se_crtc_helper_funcs = {\n\t.mode_valid = mgag200_crtc_helper_mode_valid,\n\t.atomic_check = mgag200_crtc_helper_atomic_check,\n\t.atomic_flush = mgag200_crtc_helper_atomic_flush,\n\t.atomic_enable = mgag200_g200se_crtc_helper_atomic_enable,\n\t.atomic_disable = mgag200_crtc_helper_atomic_disable\n};\n\nstatic const struct drm_crtc_funcs mgag200_g200se_crtc_funcs = {\n\tMGAG200_CRTC_FUNCS,\n};\n\nstatic const struct drm_encoder_funcs mgag200_g200se_dac_encoder_funcs = {\n\tMGAG200_DAC_ENCODER_FUNCS,\n};\n\nstatic const struct drm_connector_helper_funcs mgag200_g200se_vga_connector_helper_funcs = {\n\tMGAG200_VGA_CONNECTOR_HELPER_FUNCS,\n};\n\nstatic const struct drm_connector_funcs mgag200_g200se_vga_connector_funcs = {\n\tMGAG200_VGA_CONNECTOR_FUNCS,\n};\n\nstatic int mgag200_g200se_pipeline_init(struct mga_device *mdev)\n{\n\tstruct drm_device *dev = &mdev->base;\n\tstruct drm_plane *primary_plane = &mdev->primary_plane;\n\tstruct drm_crtc *crtc = &mdev->crtc;\n\tstruct drm_encoder *encoder = &mdev->encoder;\n\tstruct mga_i2c_chan *i2c = &mdev->i2c;\n\tstruct drm_connector *connector = &mdev->connector;\n\tint ret;\n\n\tret = drm_universal_plane_init(dev, primary_plane, 0,\n\t\t\t\t       &mgag200_g200se_primary_plane_funcs,\n\t\t\t\t       mgag200_primary_plane_formats,\n\t\t\t\t       mgag200_primary_plane_formats_size,\n\t\t\t\t       mgag200_primary_plane_fmtmods,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_universal_plane_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_plane_helper_add(primary_plane, &mgag200_g200se_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary_plane);\n\n\tret = drm_crtc_init_with_planes(dev, crtc, primary_plane, NULL,\n\t\t\t\t\t&mgag200_g200se_crtc_funcs, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_crtc_init_with_planes() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_crtc_helper_add(crtc, &mgag200_g200se_crtc_helper_funcs);\n\n\t \n\tdrm_mode_crtc_set_gamma_size(crtc, MGAG200_LUT_SIZE);\n\tdrm_crtc_enable_color_mgmt(crtc, 0, false, MGAG200_LUT_SIZE);\n\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\tret = drm_encoder_init(dev, encoder, &mgag200_g200se_dac_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_DAC, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_encoder_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mgag200_i2c_init(mdev, i2c);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to add DDC bus: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = drm_connector_init_with_ddc(dev, connector,\n\t\t\t\t\t  &mgag200_g200se_vga_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_VGA,\n\t\t\t\t\t  &i2c->adapter);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_connector_init_with_ddc() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_connector_helper_add(connector, &mgag200_g200se_vga_connector_helper_funcs);\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_connector_attach_encoder() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct mgag200_device_info mgag200_g200se_a_01_device_info =\n\tMGAG200_DEVICE_INFO_INIT(1600, 1200, 24400, false, 0, 1, true);\n\nstatic const struct mgag200_device_info mgag200_g200se_a_02_device_info =\n\tMGAG200_DEVICE_INFO_INIT(1920, 1200, 30100, false, 0, 1, true);\n\nstatic const struct mgag200_device_info mgag200_g200se_a_03_device_info =\n\tMGAG200_DEVICE_INFO_INIT(2048, 2048, 55000, false, 0, 1, false);\n\nstatic const struct mgag200_device_info mgag200_g200se_b_01_device_info =\n\tMGAG200_DEVICE_INFO_INIT(1600, 1200, 24400, false, 0, 1, false);\n\nstatic const struct mgag200_device_info mgag200_g200se_b_02_device_info =\n\tMGAG200_DEVICE_INFO_INIT(1920, 1200, 30100, false, 0, 1, false);\n\nstatic const struct mgag200_device_info mgag200_g200se_b_03_device_info =\n\tMGAG200_DEVICE_INFO_INIT(2048, 2048, 55000, false, 0, 1, false);\n\nstatic int mgag200_g200se_init_unique_rev_id(struct mgag200_g200se_device *g200se)\n{\n\tstruct mga_device *mdev = &g200se->base;\n\tstruct drm_device *dev = &mdev->base;\n\n\t \n\tg200se->unique_rev_id = RREG32(0x1e24);\n\tif (!g200se->unique_rev_id)\n\t\treturn -ENODEV;\n\n\tdrm_dbg(dev, \"G200 SE unique revision id is 0x%x\\n\", g200se->unique_rev_id);\n\n\treturn 0;\n}\n\nstatic const struct mgag200_device_funcs mgag200_g200se_00_device_funcs = {\n\t.pixpllc_atomic_check = mgag200_g200se_00_pixpllc_atomic_check,\n\t.pixpllc_atomic_update = mgag200_g200se_00_pixpllc_atomic_update,\n};\n\nstatic const struct mgag200_device_funcs mgag200_g200se_04_device_funcs = {\n\t.pixpllc_atomic_check = mgag200_g200se_04_pixpllc_atomic_check,\n\t.pixpllc_atomic_update = mgag200_g200se_04_pixpllc_atomic_update,\n};\n\nstruct mga_device *mgag200_g200se_device_create(struct pci_dev *pdev, const struct drm_driver *drv,\n\t\t\t\t\t\tenum mga_type type)\n{\n\tstruct mgag200_g200se_device *g200se;\n\tconst struct mgag200_device_info *info;\n\tconst struct mgag200_device_funcs *funcs;\n\tstruct mga_device *mdev;\n\tstruct drm_device *dev;\n\tresource_size_t vram_available;\n\tint ret;\n\n\tg200se = devm_drm_dev_alloc(&pdev->dev, drv, struct mgag200_g200se_device, base.base);\n\tif (IS_ERR(g200se))\n\t\treturn ERR_CAST(g200se);\n\tmdev = &g200se->base;\n\tdev = &mdev->base;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tret = mgag200_g200se_init_pci_options(pdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_device_preinit(mdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_g200se_init_unique_rev_id(g200se);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tswitch (type) {\n\tcase G200_SE_A:\n\t\tif (g200se->unique_rev_id >= 0x03)\n\t\t\tinfo = &mgag200_g200se_a_03_device_info;\n\t\telse if (g200se->unique_rev_id >= 0x02)\n\t\t\tinfo = &mgag200_g200se_a_02_device_info;\n\t\telse\n\t\t\tinfo = &mgag200_g200se_a_01_device_info;\n\t\tbreak;\n\tcase G200_SE_B:\n\t\tif (g200se->unique_rev_id >= 0x03)\n\t\t\tinfo = &mgag200_g200se_b_03_device_info;\n\t\telse if (g200se->unique_rev_id >= 0x02)\n\t\t\tinfo = &mgag200_g200se_b_02_device_info;\n\t\telse\n\t\t\tinfo = &mgag200_g200se_b_01_device_info;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (g200se->unique_rev_id >= 0x04)\n\t\tfuncs = &mgag200_g200se_04_device_funcs;\n\telse\n\t\tfuncs = &mgag200_g200se_00_device_funcs;\n\n\tret = mgag200_device_init(mdev, info, funcs);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmgag200_g200se_init_registers(g200se);\n\n\tvram_available = mgag200_device_probe_vram(mdev);\n\n\tret = mgag200_mode_config_init(mdev, vram_available);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_g200se_pipeline_init(mdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdrm_mode_config_reset(dev);\n\n\treturn mdev;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}