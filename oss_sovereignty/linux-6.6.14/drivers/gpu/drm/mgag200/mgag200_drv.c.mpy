{
  "module_name": "mgag200_drv.c",
  "hash_id": "0e249e981664da34d23eee68d3571645d46d99b360b610d1ce310d583e0df2dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mgag200/mgag200_drv.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_file.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_module.h>\n#include <drm/drm_pciids.h>\n\n#include \"mgag200_drv.h\"\n\nstatic int mgag200_modeset = -1;\nMODULE_PARM_DESC(modeset, \"Disable/Enable modesetting\");\nmodule_param_named(modeset, mgag200_modeset, int, 0400);\n\nint mgag200_init_pci_options(struct pci_dev *pdev, u32 option, u32 option2)\n{\n\tstruct device *dev = &pdev->dev;\n\tint err;\n\n\terr = pci_write_config_dword(pdev, PCI_MGA_OPTION, option);\n\tif (err != PCIBIOS_SUCCESSFUL) {\n\t\tdev_err(dev, \"pci_write_config_dword(PCI_MGA_OPTION) failed: %d\\n\", err);\n\t\treturn pcibios_err_to_errno(err);\n\t}\n\n\terr = pci_write_config_dword(pdev, PCI_MGA_OPTION2, option2);\n\tif (err != PCIBIOS_SUCCESSFUL) {\n\t\tdev_err(dev, \"pci_write_config_dword(PCI_MGA_OPTION2) failed: %d\\n\", err);\n\t\treturn pcibios_err_to_errno(err);\n\t}\n\n\treturn 0;\n}\n\nresource_size_t mgag200_probe_vram(void __iomem *mem, resource_size_t size)\n{\n\tint offset;\n\tint orig;\n\tint test1, test2;\n\tint orig1, orig2;\n\tsize_t vram_size;\n\n\t \n\torig = ioread16(mem);\n\tiowrite16(0, mem);\n\n\tvram_size = size;\n\n\tfor (offset = 0x100000; offset < vram_size; offset += 0x4000) {\n\t\torig1 = ioread8(mem + offset);\n\t\torig2 = ioread8(mem + offset + 0x100);\n\n\t\tiowrite16(0xaa55, mem + offset);\n\t\tiowrite16(0xaa55, mem + offset + 0x100);\n\n\t\ttest1 = ioread16(mem + offset);\n\t\ttest2 = ioread16(mem);\n\n\t\tiowrite16(orig1, mem + offset);\n\t\tiowrite16(orig2, mem + offset + 0x100);\n\n\t\tif (test1 != 0xaa55)\n\t\t\tbreak;\n\n\t\tif (test2)\n\t\t\tbreak;\n\t}\n\n\tiowrite16(orig, mem);\n\n\treturn offset - 65536;\n}\n\n \n\nDEFINE_DRM_GEM_FOPS(mgag200_driver_fops);\n\nstatic const struct drm_driver mgag200_driver = {\n\t.driver_features = DRIVER_ATOMIC | DRIVER_GEM | DRIVER_MODESET,\n\t.fops = &mgag200_driver_fops,\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n\t.patchlevel = DRIVER_PATCHLEVEL,\n\tDRM_GEM_SHMEM_DRIVER_OPS,\n};\n\n \n\nresource_size_t mgag200_device_probe_vram(struct mga_device *mdev)\n{\n\treturn mgag200_probe_vram(mdev->vram, resource_size(mdev->vram_res));\n}\n\nint mgag200_device_preinit(struct mga_device *mdev)\n{\n\tstruct drm_device *dev = &mdev->base;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tresource_size_t start, len;\n\tstruct resource *res;\n\n\t \n\n\tstart = pci_resource_start(pdev, 1);\n\tlen = pci_resource_len(pdev, 1);\n\n\tres = devm_request_mem_region(dev->dev, start, len, \"mgadrmfb_mmio\");\n\tif (!res) {\n\t\tdrm_err(dev, \"devm_request_mem_region(MMIO) failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\tmdev->rmmio_res = res;\n\n\tmdev->rmmio = pcim_iomap(pdev, 1, 0);\n\tif (!mdev->rmmio)\n\t\treturn -ENOMEM;\n\n\t \n\n\tstart = pci_resource_start(pdev, 0);\n\tlen = pci_resource_len(pdev, 0);\n\n\tres = devm_request_mem_region(dev->dev, start, len, \"mgadrmfb_vram\");\n\tif (!res) {\n\t\tdrm_err(dev, \"devm_request_mem_region(VRAM) failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\tmdev->vram_res = res;\n\n\t \n\tdevm_arch_io_reserve_memtype_wc(dev->dev, res->start, resource_size(res));\n\tdevm_arch_phys_wc_add(dev->dev, res->start, resource_size(res));\n\n\tmdev->vram = devm_ioremap(dev->dev, res->start, resource_size(res));\n\tif (!mdev->vram)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint mgag200_device_init(struct mga_device *mdev,\n\t\t\tconst struct mgag200_device_info *info,\n\t\t\tconst struct mgag200_device_funcs *funcs)\n{\n\tstruct drm_device *dev = &mdev->base;\n\tu8 crtcext3, misc;\n\tint ret;\n\n\tmdev->info = info;\n\tmdev->funcs = funcs;\n\n\tret = drmm_mutex_init(dev, &mdev->rmmio_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&mdev->rmmio_lock);\n\n\tRREG_ECRT(0x03, crtcext3);\n\tcrtcext3 |= MGAREG_CRTCEXT3_MGAMODE;\n\tWREG_ECRT(0x03, crtcext3);\n\n\tWREG_ECRT(0x04, 0x00);\n\n\tmisc = RREG8(MGA_MISC_IN);\n\tmisc |= MGAREG_MISC_RAMMAPEN |\n\t\tMGAREG_MISC_HIGH_PG_SEL;\n\tWREG8(MGA_MISC_OUT, misc);\n\n\tmutex_unlock(&mdev->rmmio_lock);\n\n\treturn 0;\n}\n\n \n\nstatic const struct pci_device_id mgag200_pciidlist[] = {\n\t{ PCI_VENDOR_ID_MATROX, 0x520, PCI_ANY_ID, PCI_ANY_ID, 0, 0, G200_PCI },\n\t{ PCI_VENDOR_ID_MATROX, 0x521, PCI_ANY_ID, PCI_ANY_ID, 0, 0, G200_AGP },\n\t{ PCI_VENDOR_ID_MATROX, 0x522, PCI_ANY_ID, PCI_ANY_ID, 0, 0, G200_SE_A },\n\t{ PCI_VENDOR_ID_MATROX, 0x524, PCI_ANY_ID, PCI_ANY_ID, 0, 0, G200_SE_B },\n\t{ PCI_VENDOR_ID_MATROX, 0x530, PCI_ANY_ID, PCI_ANY_ID, 0, 0, G200_EV },\n\t{ PCI_VENDOR_ID_MATROX, 0x532, PCI_ANY_ID, PCI_ANY_ID, 0, 0, G200_WB },\n\t{ PCI_VENDOR_ID_MATROX, 0x533, PCI_ANY_ID, PCI_ANY_ID, 0, 0, G200_EH },\n\t{ PCI_VENDOR_ID_MATROX, 0x534, PCI_ANY_ID, PCI_ANY_ID, 0, 0, G200_ER },\n\t{ PCI_VENDOR_ID_MATROX, 0x536, PCI_ANY_ID, PCI_ANY_ID, 0, 0, G200_EW3 },\n\t{ PCI_VENDOR_ID_MATROX, 0x538, PCI_ANY_ID, PCI_ANY_ID, 0, 0, G200_EH3 },\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, mgag200_pciidlist);\n\nstatic int\nmgag200_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tenum mga_type type = (enum mga_type)ent->driver_data;\n\tstruct mga_device *mdev;\n\tstruct drm_device *dev;\n\tint ret;\n\n\tret = drm_aperture_remove_conflicting_pci_framebuffers(pdev, &mgag200_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (type) {\n\tcase G200_PCI:\n\tcase G200_AGP:\n\t\tmdev = mgag200_g200_device_create(pdev, &mgag200_driver);\n\t\tbreak;\n\tcase G200_SE_A:\n\tcase G200_SE_B:\n\t\tmdev = mgag200_g200se_device_create(pdev, &mgag200_driver, type);\n\t\tbreak;\n\tcase G200_WB:\n\t\tmdev = mgag200_g200wb_device_create(pdev, &mgag200_driver);\n\t\tbreak;\n\tcase G200_EV:\n\t\tmdev = mgag200_g200ev_device_create(pdev, &mgag200_driver);\n\t\tbreak;\n\tcase G200_EH:\n\t\tmdev = mgag200_g200eh_device_create(pdev, &mgag200_driver);\n\t\tbreak;\n\tcase G200_EH3:\n\t\tmdev = mgag200_g200eh3_device_create(pdev, &mgag200_driver);\n\t\tbreak;\n\tcase G200_ER:\n\t\tmdev = mgag200_g200er_device_create(pdev, &mgag200_driver);\n\t\tbreak;\n\tcase G200_EW3:\n\t\tmdev = mgag200_g200ew3_device_create(pdev, &mgag200_driver);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Device type %d is unsupported\\n\", type);\n\t\treturn -ENODEV;\n\t}\n\tif (IS_ERR(mdev))\n\t\treturn PTR_ERR(mdev);\n\tdev = &mdev->base;\n\n\tret = drm_dev_register(dev, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdrm_fbdev_generic_setup(dev, 32);\n\n\treturn 0;\n}\n\nstatic void mgag200_pci_remove(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\n\tdrm_dev_unregister(dev);\n\tdrm_atomic_helper_shutdown(dev);\n}\n\nstatic void mgag200_pci_shutdown(struct pci_dev *pdev)\n{\n\tdrm_atomic_helper_shutdown(pci_get_drvdata(pdev));\n}\n\nstatic struct pci_driver mgag200_pci_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = mgag200_pciidlist,\n\t.probe = mgag200_pci_probe,\n\t.remove = mgag200_pci_remove,\n\t.shutdown = mgag200_pci_shutdown,\n};\n\ndrm_module_pci_driver_if_modeset(mgag200_pci_driver, mgag200_modeset);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}