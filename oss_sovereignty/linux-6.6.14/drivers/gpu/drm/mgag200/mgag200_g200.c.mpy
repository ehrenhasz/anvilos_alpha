{
  "module_name": "mgag200_g200.c",
  "hash_id": "968a3142b4f03c7608b5826262241b5acf114ba84f2d4fa0be42a9a76a364a12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mgag200/mgag200_g200.c",
  "human_readable_source": "\n\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mgag200_drv.h\"\n\nstatic int mgag200_g200_init_pci_options(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tbool has_sgram;\n\tu32 option;\n\tint err;\n\n\terr = pci_read_config_dword(pdev, PCI_MGA_OPTION, &option);\n\tif (err != PCIBIOS_SUCCESSFUL) {\n\t\tdev_err(dev, \"pci_read_config_dword(PCI_MGA_OPTION) failed: %d\\n\", err);\n\t\treturn pcibios_err_to_errno(err);\n\t}\n\n\thas_sgram = !!(option & PCI_MGA_OPTION_HARDPWMSK);\n\n\tif (has_sgram)\n\t\toption = 0x4049cd21;\n\telse\n\t\toption = 0x40499121;\n\n\treturn mgag200_init_pci_options(pdev, option, 0x00008000);\n}\n\nstatic void mgag200_g200_init_registers(struct mgag200_g200_device *g200)\n{\n\tstatic const u8 dacvalue[] = {\n\t\tMGAG200_DAC_DEFAULT(0x00, 0xc9, 0x1f,\n\t\t\t\t    0x04, 0x2d, 0x19)\n\t};\n\n\tstruct mga_device *mdev = &g200->base;\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dacvalue); ++i) {\n\t\tif ((i <= 0x17) ||\n\t\t    (i == 0x1b) ||\n\t\t    (i == 0x1c) ||\n\t\t    ((i >= 0x1f) && (i <= 0x29)) ||\n\t\t    ((i >= 0x30) && (i <= 0x37)))\n\t\t\tcontinue;\n\t\tWREG_DAC(i, dacvalue[i]);\n\t}\n\n\tmgag200_init_registers(mdev);\n}\n\n \n\nstatic int mgag200_g200_pixpllc_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *new_state)\n{\n\tstatic const int post_div_max = 7;\n\tstatic const int in_div_min = 1;\n\tstatic const int in_div_max = 6;\n\tstatic const int feed_div_min = 7;\n\tstatic const int feed_div_max = 127;\n\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mgag200_g200_device *g200 = to_mgag200_g200_device(dev);\n\tstruct drm_crtc_state *new_crtc_state = drm_atomic_get_new_crtc_state(new_state, crtc);\n\tstruct mgag200_crtc_state *new_mgag200_crtc_state = to_mgag200_crtc_state(new_crtc_state);\n\tlong clock = new_crtc_state->mode.clock;\n\tstruct mgag200_pll_values *pixpllc = &new_mgag200_crtc_state->pixpllc;\n\tu8 testp, testm, testn;\n\tu8 n = 0, m = 0, p, s;\n\tlong f_vco;\n\tlong computed;\n\tlong delta, tmp_delta;\n\tlong ref_clk = g200->ref_clk;\n\tlong p_clk_min = g200->pclk_min;\n\tlong p_clk_max = g200->pclk_max;\n\n\tif (clock > p_clk_max) {\n\t\tdrm_err(dev, \"Pixel Clock %ld too high\\n\", clock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (clock < p_clk_min >> 3)\n\t\tclock = p_clk_min >> 3;\n\n\tf_vco = clock;\n\tfor (testp = 0;\n\t     testp <= post_div_max && f_vco < p_clk_min;\n\t     testp = (testp << 1) + 1, f_vco <<= 1)\n\t\t;\n\tp = testp + 1;\n\n\tdelta = clock;\n\n\tfor (testm = in_div_min; testm <= in_div_max; testm++) {\n\t\tfor (testn = feed_div_min; testn <= feed_div_max; testn++) {\n\t\t\tcomputed = ref_clk * (testn + 1) / (testm + 1);\n\t\t\tif (computed < f_vco)\n\t\t\t\ttmp_delta = f_vco - computed;\n\t\t\telse\n\t\t\t\ttmp_delta = computed - f_vco;\n\t\t\tif (tmp_delta < delta) {\n\t\t\t\tdelta = tmp_delta;\n\t\t\t\tm = testm + 1;\n\t\t\t\tn = testn + 1;\n\t\t\t}\n\t\t}\n\t}\n\tf_vco = ref_clk * n / m;\n\tif (f_vco < 100000)\n\t\ts = 0;\n\telse if (f_vco < 140000)\n\t\ts = 1;\n\telse if (f_vco < 180000)\n\t\ts = 2;\n\telse\n\t\ts = 3;\n\n\tdrm_dbg_kms(dev, \"clock: %ld vco: %ld m: %d n: %d p: %d s: %d\\n\",\n\t\t    clock, f_vco, m, n, p, s);\n\n\tpixpllc->m = m;\n\tpixpllc->n = n;\n\tpixpllc->p = p;\n\tpixpllc->s = s;\n\n\treturn 0;\n}\n\nstatic void mgag200_g200_pixpllc_atomic_update(struct drm_crtc *crtc,\n\t\t\t\t\t       struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct mgag200_crtc_state *mgag200_crtc_state = to_mgag200_crtc_state(crtc_state);\n\tstruct mgag200_pll_values *pixpllc = &mgag200_crtc_state->pixpllc;\n\tunsigned int pixpllcm, pixpllcn, pixpllcp, pixpllcs;\n\tu8 xpixpllcm, xpixpllcn, xpixpllcp;\n\n\tpixpllcm = pixpllc->m - 1;\n\tpixpllcn = pixpllc->n - 1;\n\tpixpllcp = pixpllc->p - 1;\n\tpixpllcs = pixpllc->s;\n\n\txpixpllcm = pixpllcm;\n\txpixpllcn = pixpllcn;\n\txpixpllcp = (pixpllcs << 3) | pixpllcp;\n\n\tWREG_MISC_MASKED(MGAREG_MISC_CLKSEL_MGA, MGAREG_MISC_CLKSEL_MASK);\n\n\tWREG_DAC(MGA1064_PIX_PLLC_M, xpixpllcm);\n\tWREG_DAC(MGA1064_PIX_PLLC_N, xpixpllcn);\n\tWREG_DAC(MGA1064_PIX_PLLC_P, xpixpllcp);\n}\n\n \n\nstatic const struct drm_plane_helper_funcs mgag200_g200_primary_plane_helper_funcs = {\n\tMGAG200_PRIMARY_PLANE_HELPER_FUNCS,\n};\n\nstatic const struct drm_plane_funcs mgag200_g200_primary_plane_funcs = {\n\tMGAG200_PRIMARY_PLANE_FUNCS,\n};\n\nstatic const struct drm_crtc_helper_funcs mgag200_g200_crtc_helper_funcs = {\n\tMGAG200_CRTC_HELPER_FUNCS,\n};\n\nstatic const struct drm_crtc_funcs mgag200_g200_crtc_funcs = {\n\tMGAG200_CRTC_FUNCS,\n};\n\nstatic const struct drm_encoder_funcs mgag200_g200_dac_encoder_funcs = {\n\tMGAG200_DAC_ENCODER_FUNCS,\n};\n\nstatic const struct drm_connector_helper_funcs mgag200_g200_vga_connector_helper_funcs = {\n\tMGAG200_VGA_CONNECTOR_HELPER_FUNCS,\n};\n\nstatic const struct drm_connector_funcs mgag200_g200_vga_connector_funcs = {\n\tMGAG200_VGA_CONNECTOR_FUNCS,\n};\n\nstatic int mgag200_g200_pipeline_init(struct mga_device *mdev)\n{\n\tstruct drm_device *dev = &mdev->base;\n\tstruct drm_plane *primary_plane = &mdev->primary_plane;\n\tstruct drm_crtc *crtc = &mdev->crtc;\n\tstruct drm_encoder *encoder = &mdev->encoder;\n\tstruct mga_i2c_chan *i2c = &mdev->i2c;\n\tstruct drm_connector *connector = &mdev->connector;\n\tint ret;\n\n\tret = drm_universal_plane_init(dev, primary_plane, 0,\n\t\t\t\t       &mgag200_g200_primary_plane_funcs,\n\t\t\t\t       mgag200_primary_plane_formats,\n\t\t\t\t       mgag200_primary_plane_formats_size,\n\t\t\t\t       mgag200_primary_plane_fmtmods,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_universal_plane_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_plane_helper_add(primary_plane, &mgag200_g200_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary_plane);\n\n\tret = drm_crtc_init_with_planes(dev, crtc, primary_plane, NULL,\n\t\t\t\t\t&mgag200_g200_crtc_funcs, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_crtc_init_with_planes() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_crtc_helper_add(crtc, &mgag200_g200_crtc_helper_funcs);\n\n\t \n\tdrm_mode_crtc_set_gamma_size(crtc, MGAG200_LUT_SIZE);\n\tdrm_crtc_enable_color_mgmt(crtc, 0, false, MGAG200_LUT_SIZE);\n\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\tret = drm_encoder_init(dev, encoder, &mgag200_g200_dac_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_DAC, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_encoder_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mgag200_i2c_init(mdev, i2c);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to add DDC bus: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = drm_connector_init_with_ddc(dev, connector,\n\t\t\t\t\t  &mgag200_g200_vga_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_VGA,\n\t\t\t\t\t  &i2c->adapter);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_connector_init_with_ddc() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_connector_helper_add(connector, &mgag200_g200_vga_connector_helper_funcs);\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_connector_attach_encoder() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct mgag200_device_info mgag200_g200_device_info =\n\tMGAG200_DEVICE_INFO_INIT(2048, 2048, 0, false, 1, 3, false);\n\nstatic void mgag200_g200_interpret_bios(struct mgag200_g200_device *g200,\n\t\t\t\t\tconst unsigned char *bios, size_t size)\n{\n\tstatic const char matrox[] = {'M', 'A', 'T', 'R', 'O', 'X'};\n\tstatic const unsigned int expected_length[6] = {\n\t\t0, 64, 64, 64, 128, 128\n\t};\n\tstruct mga_device *mdev = &g200->base;\n\tstruct drm_device *dev = &mdev->base;\n\tconst unsigned char *pins;\n\tunsigned int pins_len, version;\n\tint offset;\n\tint tmp;\n\n\t \n\tif (size < 45 + sizeof(matrox))\n\t\treturn;\n\tif (memcmp(&bios[45], matrox, sizeof(matrox)) != 0)\n\t\treturn;\n\n\t \n\tif (size < MGA_BIOS_OFFSET + 2)\n\t\treturn;\n\toffset = (bios[MGA_BIOS_OFFSET + 1] << 8) | bios[MGA_BIOS_OFFSET];\n\n\t \n\n\tif (size < offset + 6)\n\t\treturn;\n\tpins = bios + offset;\n\tif (pins[0] == 0x2e && pins[1] == 0x41) {\n\t\tversion = pins[5];\n\t\tpins_len = pins[2];\n\t} else {\n\t\tversion = 1;\n\t\tpins_len = pins[0] + (pins[1] << 8);\n\t}\n\n\tif (version < 1 || version > 5) {\n\t\tdrm_warn(dev, \"Unknown BIOS PInS version: %d\\n\", version);\n\t\treturn;\n\t}\n\tif (pins_len != expected_length[version]) {\n\t\tdrm_warn(dev, \"Unexpected BIOS PInS size: %d expected: %d\\n\",\n\t\t\t pins_len, expected_length[version]);\n\t\treturn;\n\t}\n\tif (size < offset + pins_len)\n\t\treturn;\n\n\tdrm_dbg_kms(dev, \"MATROX BIOS PInS version %d size: %d found\\n\", version, pins_len);\n\n\t \n\n\tswitch (version) {\n\tcase 1:\n\t\ttmp = pins[24] + (pins[25] << 8);\n\t\tif (tmp)\n\t\t\tg200->pclk_max = tmp * 10;\n\t\tbreak;\n\tcase 2:\n\t\tif (pins[41] != 0xff)\n\t\t\tg200->pclk_max = (pins[41] + 100) * 1000;\n\t\tbreak;\n\tcase 3:\n\t\tif (pins[36] != 0xff)\n\t\t\tg200->pclk_max = (pins[36] + 100) * 1000;\n\t\tif (pins[52] & 0x20)\n\t\t\tg200->ref_clk = 14318;\n\t\tbreak;\n\tcase 4:\n\t\tif (pins[39] != 0xff)\n\t\t\tg200->pclk_max = pins[39] * 4 * 1000;\n\t\tif (pins[92] & 0x01)\n\t\t\tg200->ref_clk = 14318;\n\t\tbreak;\n\tcase 5:\n\t\ttmp = pins[4] ? 8000 : 6000;\n\t\tif (pins[123] != 0xff)\n\t\t\tg200->pclk_min = pins[123] * tmp;\n\t\tif (pins[38] != 0xff)\n\t\t\tg200->pclk_max = pins[38] * tmp;\n\t\tif (pins[110] & 0x01)\n\t\t\tg200->ref_clk = 14318;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void mgag200_g200_init_refclk(struct mgag200_g200_device *g200)\n{\n\tstruct mga_device *mdev = &g200->base;\n\tstruct drm_device *dev = &mdev->base;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tunsigned char __iomem *rom;\n\tunsigned char *bios;\n\tsize_t size;\n\n\tg200->pclk_min = 50000;\n\tg200->pclk_max = 230000;\n\tg200->ref_clk = 27050;\n\n\trom = pci_map_rom(pdev, &size);\n\tif (!rom)\n\t\treturn;\n\n\tbios = vmalloc(size);\n\tif (!bios)\n\t\tgoto out;\n\tmemcpy_fromio(bios, rom, size);\n\n\tif (size != 0 && bios[0] == 0x55 && bios[1] == 0xaa)\n\t\tmgag200_g200_interpret_bios(g200, bios, size);\n\n\tdrm_dbg_kms(dev, \"pclk_min: %ld pclk_max: %ld ref_clk: %ld\\n\",\n\t\t    g200->pclk_min, g200->pclk_max, g200->ref_clk);\n\n\tvfree(bios);\nout:\n\tpci_unmap_rom(pdev, rom);\n}\n\nstatic const struct mgag200_device_funcs mgag200_g200_device_funcs = {\n\t.pixpllc_atomic_check = mgag200_g200_pixpllc_atomic_check,\n\t.pixpllc_atomic_update = mgag200_g200_pixpllc_atomic_update,\n};\n\nstruct mga_device *mgag200_g200_device_create(struct pci_dev *pdev, const struct drm_driver *drv)\n{\n\tstruct mgag200_g200_device *g200;\n\tstruct mga_device *mdev;\n\tstruct drm_device *dev;\n\tresource_size_t vram_available;\n\tint ret;\n\n\tg200 = devm_drm_dev_alloc(&pdev->dev, drv, struct mgag200_g200_device, base.base);\n\tif (IS_ERR(g200))\n\t\treturn ERR_CAST(g200);\n\tmdev = &g200->base;\n\tdev = &mdev->base;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tret = mgag200_g200_init_pci_options(pdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_device_preinit(mdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmgag200_g200_init_refclk(g200);\n\n\tret = mgag200_device_init(mdev, &mgag200_g200_device_info,\n\t\t\t\t  &mgag200_g200_device_funcs);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmgag200_g200_init_registers(g200);\n\n\tvram_available = mgag200_device_probe_vram(mdev);\n\n\tret = mgag200_mode_config_init(mdev, vram_available);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_g200_pipeline_init(mdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdrm_mode_config_reset(dev);\n\n\treturn mdev;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}