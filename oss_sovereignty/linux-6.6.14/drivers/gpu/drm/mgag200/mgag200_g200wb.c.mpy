{
  "module_name": "mgag200_g200wb.c",
  "hash_id": "a224807dbef9f1060126ce28d92d4bbd830b3c4da6c94dd331a79376fe45bee9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mgag200/mgag200_g200wb.c",
  "human_readable_source": "\n\n#include <linux/delay.h>\n#include <linux/pci.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mgag200_drv.h\"\n\nvoid mgag200_g200wb_init_registers(struct mga_device *mdev)\n{\n\tstatic const u8 dacvalue[] = {\n\t\tMGAG200_DAC_DEFAULT(0x07, 0xc9, 0x1f, 0x00, 0x00, 0x00)\n\t};\n\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dacvalue); i++) {\n\t\tif ((i <= 0x17) ||\n\t\t    (i == 0x1b) ||\n\t\t    (i == 0x1c) ||\n\t\t    ((i >= 0x1f) && (i <= 0x29)) ||\n\t\t    ((i >= 0x30) && (i <= 0x37)) ||\n\t\t    ((i >= 0x44) && (i <= 0x4e)))\n\t\t\tcontinue;\n\t\tWREG_DAC(i, dacvalue[i]);\n\t}\n\n\tmgag200_init_registers(mdev);\n}\n\n \n\nstatic int mgag200_g200wb_pixpllc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\t       struct drm_atomic_state *new_state)\n{\n\tstatic const unsigned int vcomax = 550000;\n\tstatic const unsigned int vcomin = 150000;\n\tstatic const unsigned int pllreffreq = 48000;\n\n\tstruct drm_crtc_state *new_crtc_state = drm_atomic_get_new_crtc_state(new_state, crtc);\n\tstruct mgag200_crtc_state *new_mgag200_crtc_state = to_mgag200_crtc_state(new_crtc_state);\n\tlong clock = new_crtc_state->mode.clock;\n\tstruct mgag200_pll_values *pixpllc = &new_mgag200_crtc_state->pixpllc;\n\tunsigned int delta, tmpdelta;\n\tunsigned int testp, testm, testn;\n\tunsigned int p, m, n, s;\n\tunsigned int computed;\n\n\tm = n = p = s = 0;\n\tdelta = 0xffffffff;\n\n\tfor (testp = 1; testp < 9; testp++) {\n\t\tif (clock * testp > vcomax)\n\t\t\tcontinue;\n\t\tif (clock * testp < vcomin)\n\t\t\tcontinue;\n\n\t\tfor (testm = 1; testm < 17; testm++) {\n\t\t\tfor (testn = 1; testn < 151; testn++) {\n\t\t\t\tcomputed = (pllreffreq * testn) / (testm * testp);\n\t\t\t\tif (computed > clock)\n\t\t\t\t\ttmpdelta = computed - clock;\n\t\t\t\telse\n\t\t\t\t\ttmpdelta = clock - computed;\n\t\t\t\tif (tmpdelta < delta) {\n\t\t\t\t\tdelta = tmpdelta;\n\t\t\t\t\tn = testn;\n\t\t\t\t\tm = testm;\n\t\t\t\t\tp = testp;\n\t\t\t\t\ts = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpixpllc->m = m;\n\tpixpllc->n = n;\n\tpixpllc->p = p;\n\tpixpllc->s = s;\n\n\treturn 0;\n}\n\nvoid mgag200_g200wb_pixpllc_atomic_update(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mga_device *mdev = to_mga_device(dev);\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct mgag200_crtc_state *mgag200_crtc_state = to_mgag200_crtc_state(crtc_state);\n\tstruct mgag200_pll_values *pixpllc = &mgag200_crtc_state->pixpllc;\n\tbool pll_locked = false;\n\tunsigned int pixpllcm, pixpllcn, pixpllcp, pixpllcs;\n\tu8 xpixpllcm, xpixpllcn, xpixpllcp, tmp;\n\tint i, j, tmpcount, vcount;\n\n\tpixpllcm = pixpllc->m - 1;\n\tpixpllcn = pixpllc->n - 1;\n\tpixpllcp = pixpllc->p - 1;\n\tpixpllcs = pixpllc->s;\n\n\txpixpllcm = ((pixpllcn & BIT(8)) >> 1) | pixpllcm;\n\txpixpllcn = pixpllcn;\n\txpixpllcp = ((pixpllcn & GENMASK(10, 9)) >> 3) | (pixpllcs << 3) | pixpllcp;\n\n\tWREG_MISC_MASKED(MGAREG_MISC_CLKSEL_MGA, MGAREG_MISC_CLKSEL_MASK);\n\n\tfor (i = 0; i <= 32 && pll_locked == false; i++) {\n\t\tif (i > 0) {\n\t\t\tWREG8(MGAREG_CRTC_INDEX, 0x1e);\n\t\t\ttmp = RREG8(MGAREG_CRTC_DATA);\n\t\t\tif (tmp < 0xff)\n\t\t\t\tWREG8(MGAREG_CRTC_DATA, tmp+1);\n\t\t}\n\n\t\t \n\t\tWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\n\t\ttmp = RREG8(DAC_DATA);\n\t\ttmp |= MGA1064_PIX_CLK_CTL_CLK_DIS;\n\t\tWREG8(DAC_DATA, tmp);\n\n\t\tWREG8(DAC_INDEX, MGA1064_REMHEADCTL);\n\t\ttmp = RREG8(DAC_DATA);\n\t\ttmp |= MGA1064_REMHEADCTL_CLKDIS;\n\t\tWREG8(DAC_DATA, tmp);\n\n\t\t \n\t\ttmp = RREG8(MGAREG_MEM_MISC_READ);\n\t\ttmp |= 0x3 << 2;\n\t\tWREG8(MGAREG_MEM_MISC_WRITE, tmp);\n\n\t\tWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\n\t\ttmp = RREG8(DAC_DATA);\n\t\ttmp |= MGA1064_PIX_CLK_CTL_CLK_POW_DOWN | 0x80;\n\t\tWREG8(DAC_DATA, tmp);\n\n\t\tudelay(500);\n\n\t\t \n\t\tWREG8(DAC_INDEX, MGA1064_VREF_CTL);\n\t\ttmp = RREG8(DAC_DATA);\n\t\ttmp &= ~0x04;\n\t\tWREG8(DAC_DATA, tmp);\n\n\t\tudelay(50);\n\n\t\t \n\t\tWREG_DAC(MGA1064_WB_PIX_PLLC_N, xpixpllcn);\n\t\tWREG_DAC(MGA1064_WB_PIX_PLLC_M, xpixpllcm);\n\t\tWREG_DAC(MGA1064_WB_PIX_PLLC_P, xpixpllcp);\n\n\t\tudelay(50);\n\n\t\t \n\t\tWREG8(DAC_INDEX, MGA1064_VREF_CTL);\n\t\ttmp = RREG8(DAC_DATA);\n\t\ttmp |= 0x04;\n\t\tWREG_DAC(MGA1064_VREF_CTL, tmp);\n\n\t\tudelay(500);\n\n\t\t \n\t\tWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\n\t\ttmp = RREG8(DAC_DATA);\n\t\ttmp &= ~MGA1064_PIX_CLK_CTL_SEL_MSK;\n\t\ttmp |= MGA1064_PIX_CLK_CTL_SEL_PLL;\n\t\tWREG8(DAC_DATA, tmp);\n\n\t\tWREG8(DAC_INDEX, MGA1064_REMHEADCTL);\n\t\ttmp = RREG8(DAC_DATA);\n\t\ttmp &= ~MGA1064_REMHEADCTL_CLKSL_MSK;\n\t\ttmp |= MGA1064_REMHEADCTL_CLKSL_PLL;\n\t\tWREG8(DAC_DATA, tmp);\n\n\t\t \n\t\tWREG8(MGAREG_SEQ_INDEX, 1);\n\t\ttmp = RREG8(MGAREG_SEQ_DATA);\n\t\ttmp &= ~0x8;\n\t\tWREG8(MGAREG_SEQ_DATA, tmp);\n\n\t\tWREG8(DAC_INDEX, MGA1064_PIX_CLK_CTL);\n\t\ttmp = RREG8(DAC_DATA);\n\t\ttmp &= ~MGA1064_PIX_CLK_CTL_CLK_DIS;\n\t\tWREG8(DAC_DATA, tmp);\n\n\t\tvcount = RREG8(MGAREG_VCOUNT);\n\n\t\tfor (j = 0; j < 30 && pll_locked == false; j++) {\n\t\t\ttmpcount = RREG8(MGAREG_VCOUNT);\n\t\t\tif (tmpcount < vcount)\n\t\t\t\tvcount = 0;\n\t\t\tif ((tmpcount - vcount) > 2)\n\t\t\t\tpll_locked = true;\n\t\t\telse\n\t\t\t\tudelay(5);\n\t\t}\n\t}\n\n\tWREG8(DAC_INDEX, MGA1064_REMHEADCTL);\n\ttmp = RREG8(DAC_DATA);\n\ttmp &= ~MGA1064_REMHEADCTL_CLKDIS;\n\tWREG_DAC(MGA1064_REMHEADCTL, tmp);\n}\n\n \n\nstatic const struct drm_plane_helper_funcs mgag200_g200wb_primary_plane_helper_funcs = {\n\tMGAG200_PRIMARY_PLANE_HELPER_FUNCS,\n};\n\nstatic const struct drm_plane_funcs mgag200_g200wb_primary_plane_funcs = {\n\tMGAG200_PRIMARY_PLANE_FUNCS,\n};\n\nstatic const struct drm_crtc_helper_funcs mgag200_g200wb_crtc_helper_funcs = {\n\tMGAG200_CRTC_HELPER_FUNCS,\n};\n\nstatic const struct drm_crtc_funcs mgag200_g200wb_crtc_funcs = {\n\tMGAG200_CRTC_FUNCS,\n};\n\nstatic const struct drm_encoder_funcs mgag200_g200wb_dac_encoder_funcs = {\n\tMGAG200_DAC_ENCODER_FUNCS,\n};\n\nstatic const struct drm_connector_helper_funcs mgag200_g200wb_vga_connector_helper_funcs = {\n\tMGAG200_VGA_CONNECTOR_HELPER_FUNCS,\n};\n\nstatic const struct drm_connector_funcs mgag200_g200wb_vga_connector_funcs = {\n\tMGAG200_VGA_CONNECTOR_FUNCS,\n};\n\nstatic int mgag200_g200wb_pipeline_init(struct mga_device *mdev)\n{\n\tstruct drm_device *dev = &mdev->base;\n\tstruct drm_plane *primary_plane = &mdev->primary_plane;\n\tstruct drm_crtc *crtc = &mdev->crtc;\n\tstruct drm_encoder *encoder = &mdev->encoder;\n\tstruct mga_i2c_chan *i2c = &mdev->i2c;\n\tstruct drm_connector *connector = &mdev->connector;\n\tint ret;\n\n\tret = drm_universal_plane_init(dev, primary_plane, 0,\n\t\t\t\t       &mgag200_g200wb_primary_plane_funcs,\n\t\t\t\t       mgag200_primary_plane_formats,\n\t\t\t\t       mgag200_primary_plane_formats_size,\n\t\t\t\t       mgag200_primary_plane_fmtmods,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_universal_plane_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_plane_helper_add(primary_plane, &mgag200_g200wb_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary_plane);\n\n\tret = drm_crtc_init_with_planes(dev, crtc, primary_plane, NULL,\n\t\t\t\t\t&mgag200_g200wb_crtc_funcs, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_crtc_init_with_planes() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_crtc_helper_add(crtc, &mgag200_g200wb_crtc_helper_funcs);\n\n\t \n\tdrm_mode_crtc_set_gamma_size(crtc, MGAG200_LUT_SIZE);\n\tdrm_crtc_enable_color_mgmt(crtc, 0, false, MGAG200_LUT_SIZE);\n\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\tret = drm_encoder_init(dev, encoder, &mgag200_g200wb_dac_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_DAC, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_encoder_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mgag200_i2c_init(mdev, i2c);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to add DDC bus: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = drm_connector_init_with_ddc(dev, connector,\n\t\t\t\t\t  &mgag200_g200wb_vga_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_VGA,\n\t\t\t\t\t  &i2c->adapter);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_connector_init_with_ddc() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_connector_helper_add(connector, &mgag200_g200wb_vga_connector_helper_funcs);\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret) {\n\t\tdrm_err(dev, \"drm_connector_attach_encoder() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct mgag200_device_info mgag200_g200wb_device_info =\n\tMGAG200_DEVICE_INFO_INIT(1280, 1024, 31877, true, 0, 1, false);\n\nstatic const struct mgag200_device_funcs mgag200_g200wb_device_funcs = {\n\t.disable_vidrst = mgag200_bmc_disable_vidrst,\n\t.enable_vidrst = mgag200_bmc_enable_vidrst,\n\t.pixpllc_atomic_check = mgag200_g200wb_pixpllc_atomic_check,\n\t.pixpllc_atomic_update = mgag200_g200wb_pixpllc_atomic_update,\n};\n\nstruct mga_device *mgag200_g200wb_device_create(struct pci_dev *pdev, const struct drm_driver *drv)\n{\n\tstruct mga_device *mdev;\n\tstruct drm_device *dev;\n\tresource_size_t vram_available;\n\tint ret;\n\n\tmdev = devm_drm_dev_alloc(&pdev->dev, drv, struct mga_device, base);\n\tif (IS_ERR(mdev))\n\t\treturn mdev;\n\tdev = &mdev->base;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tret = mgag200_init_pci_options(pdev, 0x41049120, 0x0000b000);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_device_preinit(mdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_device_init(mdev, &mgag200_g200wb_device_info,\n\t\t\t\t  &mgag200_g200wb_device_funcs);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmgag200_g200wb_init_registers(mdev);\n\n\tvram_available = mgag200_device_probe_vram(mdev);\n\n\tret = mgag200_mode_config_init(mdev, vram_available);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = mgag200_g200wb_pipeline_init(mdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdrm_mode_config_reset(dev);\n\n\treturn mdev;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}