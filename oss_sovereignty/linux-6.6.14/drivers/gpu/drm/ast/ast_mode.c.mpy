{
  "module_name": "ast_mode.c",
  "hash_id": "a010822ac1823265bb0f6de3acab27fac4a463cef085226b695c400bcf70ecce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ast/ast_mode.c",
  "human_readable_source": " \n \n\n#include <linux/export.h>\n#include <linux/pci.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"ast_drv.h\"\n#include \"ast_tables.h\"\n\n#define AST_LUT_SIZE 256\n\nstatic inline void ast_load_palette_index(struct ast_device *ast,\n\t\t\t\t     u8 index, u8 red, u8 green,\n\t\t\t\t     u8 blue)\n{\n\tast_io_write8(ast, AST_IO_DAC_INDEX_WRITE, index);\n\tast_io_read8(ast, AST_IO_SEQ_PORT);\n\tast_io_write8(ast, AST_IO_DAC_DATA, red);\n\tast_io_read8(ast, AST_IO_SEQ_PORT);\n\tast_io_write8(ast, AST_IO_DAC_DATA, green);\n\tast_io_read8(ast, AST_IO_SEQ_PORT);\n\tast_io_write8(ast, AST_IO_DAC_DATA, blue);\n\tast_io_read8(ast, AST_IO_SEQ_PORT);\n}\n\nstatic void ast_crtc_set_gamma_linear(struct ast_device *ast,\n\t\t\t\t      const struct drm_format_info *format)\n{\n\tint i;\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_C8:  \n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XRGB8888:\n\t\tfor (i = 0; i < AST_LUT_SIZE; i++)\n\t\t\tast_load_palette_index(ast, i, i, i, i);\n\t\tbreak;\n\tdefault:\n\t\tdrm_warn_once(&ast->base, \"Unsupported format %p4cc for gamma correction\\n\",\n\t\t\t      &format->format);\n\t\tbreak;\n\t}\n}\n\nstatic void ast_crtc_set_gamma(struct ast_device *ast,\n\t\t\t       const struct drm_format_info *format,\n\t\t\t       struct drm_color_lut *lut)\n{\n\tint i;\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_C8:  \n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XRGB8888:\n\t\tfor (i = 0; i < AST_LUT_SIZE; i++)\n\t\t\tast_load_palette_index(ast, i,\n\t\t\t\t\t       lut[i].red >> 8,\n\t\t\t\t\t       lut[i].green >> 8,\n\t\t\t\t\t       lut[i].blue >> 8);\n\t\tbreak;\n\tdefault:\n\t\tdrm_warn_once(&ast->base, \"Unsupported format %p4cc for gamma correction\\n\",\n\t\t\t      &format->format);\n\t\tbreak;\n\t}\n}\n\nstatic bool ast_get_vbios_mode_info(const struct drm_format_info *format,\n\t\t\t\t    const struct drm_display_mode *mode,\n\t\t\t\t    struct drm_display_mode *adjusted_mode,\n\t\t\t\t    struct ast_vbios_mode_info *vbios_mode)\n{\n\tu32 refresh_rate_index = 0, refresh_rate;\n\tconst struct ast_vbios_enhtable *best = NULL;\n\tu32 hborder, vborder;\n\tbool check_sync;\n\n\tswitch (format->cpp[0] * 8) {\n\tcase 8:\n\t\tvbios_mode->std_table = &vbios_stdtable[VGAModeIndex];\n\t\tbreak;\n\tcase 16:\n\t\tvbios_mode->std_table = &vbios_stdtable[HiCModeIndex];\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tvbios_mode->std_table = &vbios_stdtable[TrueCModeIndex];\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (mode->crtc_hdisplay) {\n\tcase 640:\n\t\tvbios_mode->enh_table = &res_640x480[refresh_rate_index];\n\t\tbreak;\n\tcase 800:\n\t\tvbios_mode->enh_table = &res_800x600[refresh_rate_index];\n\t\tbreak;\n\tcase 1024:\n\t\tvbios_mode->enh_table = &res_1024x768[refresh_rate_index];\n\t\tbreak;\n\tcase 1152:\n\t\tvbios_mode->enh_table = &res_1152x864[refresh_rate_index];\n\t\tbreak;\n\tcase 1280:\n\t\tif (mode->crtc_vdisplay == 800)\n\t\t\tvbios_mode->enh_table = &res_1280x800[refresh_rate_index];\n\t\telse\n\t\t\tvbios_mode->enh_table = &res_1280x1024[refresh_rate_index];\n\t\tbreak;\n\tcase 1360:\n\t\tvbios_mode->enh_table = &res_1360x768[refresh_rate_index];\n\t\tbreak;\n\tcase 1440:\n\t\tvbios_mode->enh_table = &res_1440x900[refresh_rate_index];\n\t\tbreak;\n\tcase 1600:\n\t\tif (mode->crtc_vdisplay == 900)\n\t\t\tvbios_mode->enh_table = &res_1600x900[refresh_rate_index];\n\t\telse\n\t\t\tvbios_mode->enh_table = &res_1600x1200[refresh_rate_index];\n\t\tbreak;\n\tcase 1680:\n\t\tvbios_mode->enh_table = &res_1680x1050[refresh_rate_index];\n\t\tbreak;\n\tcase 1920:\n\t\tif (mode->crtc_vdisplay == 1080)\n\t\t\tvbios_mode->enh_table = &res_1920x1080[refresh_rate_index];\n\t\telse\n\t\t\tvbios_mode->enh_table = &res_1920x1200[refresh_rate_index];\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\trefresh_rate = drm_mode_vrefresh(mode);\n\tcheck_sync = vbios_mode->enh_table->flags & WideScreenMode;\n\n\twhile (1) {\n\t\tconst struct ast_vbios_enhtable *loop = vbios_mode->enh_table;\n\n\t\twhile (loop->refresh_rate != 0xff) {\n\t\t\tif ((check_sync) &&\n\t\t\t    (((mode->flags & DRM_MODE_FLAG_NVSYNC)  &&\n\t\t\t      (loop->flags & PVSync))  ||\n\t\t\t     ((mode->flags & DRM_MODE_FLAG_PVSYNC)  &&\n\t\t\t      (loop->flags & NVSync))  ||\n\t\t\t     ((mode->flags & DRM_MODE_FLAG_NHSYNC)  &&\n\t\t\t      (loop->flags & PHSync))  ||\n\t\t\t     ((mode->flags & DRM_MODE_FLAG_PHSYNC)  &&\n\t\t\t      (loop->flags & NHSync)))) {\n\t\t\t\tloop++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (loop->refresh_rate <= refresh_rate\n\t\t\t    && (!best || loop->refresh_rate > best->refresh_rate))\n\t\t\t\tbest = loop;\n\t\t\tloop++;\n\t\t}\n\t\tif (best || !check_sync)\n\t\t\tbreak;\n\t\tcheck_sync = 0;\n\t}\n\n\tif (best)\n\t\tvbios_mode->enh_table = best;\n\n\thborder = (vbios_mode->enh_table->flags & HBorder) ? 8 : 0;\n\tvborder = (vbios_mode->enh_table->flags & VBorder) ? 8 : 0;\n\n\tadjusted_mode->crtc_htotal = vbios_mode->enh_table->ht;\n\tadjusted_mode->crtc_hblank_start = vbios_mode->enh_table->hde + hborder;\n\tadjusted_mode->crtc_hblank_end = vbios_mode->enh_table->ht - hborder;\n\tadjusted_mode->crtc_hsync_start = vbios_mode->enh_table->hde + hborder +\n\t\tvbios_mode->enh_table->hfp;\n\tadjusted_mode->crtc_hsync_end = (vbios_mode->enh_table->hde + hborder +\n\t\t\t\t\t vbios_mode->enh_table->hfp +\n\t\t\t\t\t vbios_mode->enh_table->hsync);\n\n\tadjusted_mode->crtc_vtotal = vbios_mode->enh_table->vt;\n\tadjusted_mode->crtc_vblank_start = vbios_mode->enh_table->vde + vborder;\n\tadjusted_mode->crtc_vblank_end = vbios_mode->enh_table->vt - vborder;\n\tadjusted_mode->crtc_vsync_start = vbios_mode->enh_table->vde + vborder +\n\t\tvbios_mode->enh_table->vfp;\n\tadjusted_mode->crtc_vsync_end = (vbios_mode->enh_table->vde + vborder +\n\t\t\t\t\t vbios_mode->enh_table->vfp +\n\t\t\t\t\t vbios_mode->enh_table->vsync);\n\n\treturn true;\n}\n\nstatic void ast_set_vbios_color_reg(struct ast_device *ast,\n\t\t\t\t    const struct drm_format_info *format,\n\t\t\t\t    const struct ast_vbios_mode_info *vbios_mode)\n{\n\tu32 color_index;\n\n\tswitch (format->cpp[0]) {\n\tcase 1:\n\t\tcolor_index = VGAModeIndex - 1;\n\t\tbreak;\n\tcase 2:\n\t\tcolor_index = HiCModeIndex;\n\t\tbreak;\n\tcase 3:\n\tcase 4:\n\t\tcolor_index = TrueCModeIndex;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x8c, (u8)((color_index & 0x0f) << 4));\n\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x91, 0x00);\n\n\tif (vbios_mode->enh_table->flags & NewModeInfo) {\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x91, 0xa8);\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x92, format->cpp[0] * 8);\n\t}\n}\n\nstatic void ast_set_vbios_mode_reg(struct ast_device *ast,\n\t\t\t\t   const struct drm_display_mode *adjusted_mode,\n\t\t\t\t   const struct ast_vbios_mode_info *vbios_mode)\n{\n\tu32 refresh_rate_index, mode_id;\n\n\trefresh_rate_index = vbios_mode->enh_table->refresh_rate_index;\n\tmode_id = vbios_mode->enh_table->mode_id;\n\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x8d, refresh_rate_index & 0xff);\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x8e, mode_id & 0xff);\n\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x91, 0x00);\n\n\tif (vbios_mode->enh_table->flags & NewModeInfo) {\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x91, 0xa8);\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x93, adjusted_mode->clock / 1000);\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x94, adjusted_mode->crtc_hdisplay);\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x95, adjusted_mode->crtc_hdisplay >> 8);\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x96, adjusted_mode->crtc_vdisplay);\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x97, adjusted_mode->crtc_vdisplay >> 8);\n\t}\n}\n\nstatic void ast_set_std_reg(struct ast_device *ast,\n\t\t\t    struct drm_display_mode *mode,\n\t\t\t    struct ast_vbios_mode_info *vbios_mode)\n{\n\tconst struct ast_vbios_stdtable *stdtable;\n\tu32 i;\n\tu8 jreg;\n\n\tstdtable = vbios_mode->std_table;\n\n\tjreg = stdtable->misc;\n\tast_io_write8(ast, AST_IO_MISC_PORT_WRITE, jreg);\n\n\t \n\tast_set_index_reg(ast, AST_IO_SEQ_PORT, 0x00, 0x03);\n\tast_set_index_reg_mask(ast, AST_IO_SEQ_PORT, 0x01, 0xdf, stdtable->seq[0]);\n\tfor (i = 1; i < 4; i++) {\n\t\tjreg = stdtable->seq[i];\n\t\tast_set_index_reg(ast, AST_IO_SEQ_PORT, (i + 1), jreg);\n\t}\n\n\t \n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x11, 0x7f, 0x00);\n\tfor (i = 0; i < 12; i++)\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, i, stdtable->crtc[i]);\n\tfor (i = 14; i < 19; i++)\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, i, stdtable->crtc[i]);\n\tfor (i = 20; i < 25; i++)\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, i, stdtable->crtc[i]);\n\n\t \n\tjreg = ast_io_read8(ast, AST_IO_INPUT_STATUS1_READ);\n\tfor (i = 0; i < 20; i++) {\n\t\tjreg = stdtable->ar[i];\n\t\tast_io_write8(ast, AST_IO_AR_PORT_WRITE, (u8)i);\n\t\tast_io_write8(ast, AST_IO_AR_PORT_WRITE, jreg);\n\t}\n\tast_io_write8(ast, AST_IO_AR_PORT_WRITE, 0x14);\n\tast_io_write8(ast, AST_IO_AR_PORT_WRITE, 0x00);\n\n\tjreg = ast_io_read8(ast, AST_IO_INPUT_STATUS1_READ);\n\tast_io_write8(ast, AST_IO_AR_PORT_WRITE, 0x20);\n\n\t \n\tfor (i = 0; i < 9; i++)\n\t\tast_set_index_reg(ast, AST_IO_GR_PORT, i, stdtable->gr[i]);\n}\n\nstatic void ast_set_crtc_reg(struct ast_device *ast,\n\t\t\t     struct drm_display_mode *mode,\n\t\t\t     struct ast_vbios_mode_info *vbios_mode)\n{\n\tu8 jreg05 = 0, jreg07 = 0, jreg09 = 0, jregAC = 0, jregAD = 0, jregAE = 0;\n\tu16 temp, precache = 0;\n\n\tif ((IS_AST_GEN6(ast) || IS_AST_GEN7(ast)) &&\n\t    (vbios_mode->enh_table->flags & AST2500PreCatchCRT))\n\t\tprecache = 40;\n\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x11, 0x7f, 0x00);\n\n\ttemp = (mode->crtc_htotal >> 3) - 5;\n\tif (temp & 0x100)\n\t\tjregAC |= 0x01;  \n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x00, 0x00, temp);\n\n\ttemp = (mode->crtc_hdisplay >> 3) - 1;\n\tif (temp & 0x100)\n\t\tjregAC |= 0x04;  \n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x01, 0x00, temp);\n\n\ttemp = (mode->crtc_hblank_start >> 3) - 1;\n\tif (temp & 0x100)\n\t\tjregAC |= 0x10;  \n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x02, 0x00, temp);\n\n\ttemp = ((mode->crtc_hblank_end >> 3) - 1) & 0x7f;\n\tif (temp & 0x20)\n\t\tjreg05 |= 0x80;   \n\tif (temp & 0x40)\n\t\tjregAD |= 0x01;   \n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x03, 0xE0, (temp & 0x1f));\n\n\ttemp = ((mode->crtc_hsync_start-precache) >> 3) - 1;\n\tif (temp & 0x100)\n\t\tjregAC |= 0x40;  \n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x04, 0x00, temp);\n\n\ttemp = (((mode->crtc_hsync_end-precache) >> 3) - 1) & 0x3f;\n\tif (temp & 0x20)\n\t\tjregAD |= 0x04;  \n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x05, 0x60, (u8)((temp & 0x1f) | jreg05));\n\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xAC, 0x00, jregAC);\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xAD, 0x00, jregAD);\n\n\t\n\tif (IS_AST_GEN7(ast) && (mode->crtc_vdisplay == 1080))\n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xFC, 0xFD, 0x02);\n\telse\n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xFC, 0xFD, 0x00);\n\n\t \n\ttemp = (mode->crtc_vtotal) - 2;\n\tif (temp & 0x100)\n\t\tjreg07 |= 0x01;\n\tif (temp & 0x200)\n\t\tjreg07 |= 0x20;\n\tif (temp & 0x400)\n\t\tjregAE |= 0x01;\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x06, 0x00, temp);\n\n\ttemp = (mode->crtc_vsync_start) - 1;\n\tif (temp & 0x100)\n\t\tjreg07 |= 0x04;\n\tif (temp & 0x200)\n\t\tjreg07 |= 0x80;\n\tif (temp & 0x400)\n\t\tjregAE |= 0x08;\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x10, 0x00, temp);\n\n\ttemp = (mode->crtc_vsync_end - 1) & 0x3f;\n\tif (temp & 0x10)\n\t\tjregAE |= 0x20;\n\tif (temp & 0x20)\n\t\tjregAE |= 0x40;\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x11, 0x70, temp & 0xf);\n\n\ttemp = mode->crtc_vdisplay - 1;\n\tif (temp & 0x100)\n\t\tjreg07 |= 0x02;\n\tif (temp & 0x200)\n\t\tjreg07 |= 0x40;\n\tif (temp & 0x400)\n\t\tjregAE |= 0x02;\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x12, 0x00, temp);\n\n\ttemp = mode->crtc_vblank_start - 1;\n\tif (temp & 0x100)\n\t\tjreg07 |= 0x08;\n\tif (temp & 0x200)\n\t\tjreg09 |= 0x20;\n\tif (temp & 0x400)\n\t\tjregAE |= 0x04;\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x15, 0x00, temp);\n\n\ttemp = mode->crtc_vblank_end - 1;\n\tif (temp & 0x100)\n\t\tjregAE |= 0x10;\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x16, 0x00, temp);\n\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x07, 0x00, jreg07);\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x09, 0xdf, jreg09);\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xAE, 0x00, (jregAE | 0x80));\n\n\tif (precache)\n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb6, 0x3f, 0x80);\n\telse\n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb6, 0x3f, 0x00);\n\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x11, 0x7f, 0x80);\n}\n\nstatic void ast_set_offset_reg(struct ast_device *ast,\n\t\t\t       struct drm_framebuffer *fb)\n{\n\tu16 offset;\n\n\toffset = fb->pitches[0] >> 3;\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x13, (offset & 0xff));\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xb0, (offset >> 8) & 0x3f);\n}\n\nstatic void ast_set_dclk_reg(struct ast_device *ast,\n\t\t\t     struct drm_display_mode *mode,\n\t\t\t     struct ast_vbios_mode_info *vbios_mode)\n{\n\tconst struct ast_vbios_dclk_info *clk_info;\n\n\tif (IS_AST_GEN6(ast) || IS_AST_GEN7(ast))\n\t\tclk_info = &dclk_table_ast2500[vbios_mode->enh_table->dclk_index];\n\telse\n\t\tclk_info = &dclk_table[vbios_mode->enh_table->dclk_index];\n\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xc0, 0x00, clk_info->param1);\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xc1, 0x00, clk_info->param2);\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xbb, 0x0f,\n\t\t\t       (clk_info->param3 & 0xc0) |\n\t\t\t       ((clk_info->param3 & 0x3) << 4));\n}\n\nstatic void ast_set_color_reg(struct ast_device *ast,\n\t\t\t      const struct drm_format_info *format)\n{\n\tu8 jregA0 = 0, jregA3 = 0, jregA8 = 0;\n\n\tswitch (format->cpp[0] * 8) {\n\tcase 8:\n\t\tjregA0 = 0x70;\n\t\tjregA3 = 0x01;\n\t\tjregA8 = 0x00;\n\t\tbreak;\n\tcase 15:\n\tcase 16:\n\t\tjregA0 = 0x70;\n\t\tjregA3 = 0x04;\n\t\tjregA8 = 0x02;\n\t\tbreak;\n\tcase 32:\n\t\tjregA0 = 0x70;\n\t\tjregA3 = 0x08;\n\t\tjregA8 = 0x02;\n\t\tbreak;\n\t}\n\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa0, 0x8f, jregA0);\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa3, 0xf0, jregA3);\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa8, 0xfd, jregA8);\n}\n\nstatic void ast_set_crtthd_reg(struct ast_device *ast)\n{\n\t \n\tif (IS_AST_GEN7(ast)) {\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa7, 0xe0);\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa6, 0xa0);\n\t} else if (IS_AST_GEN6(ast) || IS_AST_GEN5(ast) || IS_AST_GEN4(ast)) {\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa7, 0x78);\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa6, 0x60);\n\t} else if (IS_AST_GEN3(ast) || IS_AST_GEN2(ast)) {\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa7, 0x3f);\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa6, 0x2f);\n\t} else {\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa7, 0x2f);\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa6, 0x1f);\n\t}\n}\n\nstatic void ast_set_sync_reg(struct ast_device *ast,\n\t\t\t     struct drm_display_mode *mode,\n\t\t\t     struct ast_vbios_mode_info *vbios_mode)\n{\n\tu8 jreg;\n\n\tjreg  = ast_io_read8(ast, AST_IO_MISC_PORT_READ);\n\tjreg &= ~0xC0;\n\tif (vbios_mode->enh_table->flags & NVSync)\n\t\tjreg |= 0x80;\n\tif (vbios_mode->enh_table->flags & NHSync)\n\t\tjreg |= 0x40;\n\tast_io_write8(ast, AST_IO_MISC_PORT_WRITE, jreg);\n}\n\nstatic void ast_set_start_address_crt1(struct ast_device *ast,\n\t\t\t\t       unsigned int offset)\n{\n\tu32 addr;\n\n\taddr = offset >> 2;\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x0d, (u8)(addr & 0xff));\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x0c, (u8)((addr >> 8) & 0xff));\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xaf, (u8)((addr >> 16) & 0xff));\n\n}\n\nstatic void ast_wait_for_vretrace(struct ast_device *ast)\n{\n\tunsigned long timeout = jiffies + HZ;\n\tu8 vgair1;\n\n\tdo {\n\t\tvgair1 = ast_io_read8(ast, AST_IO_INPUT_STATUS1_READ);\n\t} while (!(vgair1 & AST_IO_VGAIR1_VREFRESH) && time_before(jiffies, timeout));\n}\n\n \n\nstatic int ast_plane_init(struct drm_device *dev, struct ast_plane *ast_plane,\n\t\t\t  void __iomem *vaddr, u64 offset, unsigned long size,\n\t\t\t  uint32_t possible_crtcs,\n\t\t\t  const struct drm_plane_funcs *funcs,\n\t\t\t  const uint32_t *formats, unsigned int format_count,\n\t\t\t  const uint64_t *format_modifiers,\n\t\t\t  enum drm_plane_type type)\n{\n\tstruct drm_plane *plane = &ast_plane->base;\n\n\tast_plane->vaddr = vaddr;\n\tast_plane->offset = offset;\n\tast_plane->size = size;\n\n\treturn drm_universal_plane_init(dev, plane, possible_crtcs, funcs,\n\t\t\t\t\tformats, format_count, format_modifiers,\n\t\t\t\t\ttype, NULL);\n}\n\n \n\nstatic const uint32_t ast_primary_plane_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_C8,\n};\n\nstatic int ast_primary_plane_helper_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_crtc_state *new_crtc_state = NULL;\n\tstruct ast_crtc_state *new_ast_crtc_state;\n\tint ret;\n\n\tif (new_plane_state->crtc)\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, new_plane_state->crtc);\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, new_crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  false, true);\n\tif (ret) {\n\t\treturn ret;\n\t} else if (!new_plane_state->visible) {\n\t\tif (drm_WARN_ON(dev, new_plane_state->crtc))  \n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tnew_ast_crtc_state = to_ast_crtc_state(new_crtc_state);\n\n\tnew_ast_crtc_state->format = new_plane_state->fb->format;\n\n\treturn 0;\n}\n\nstatic void ast_handle_damage(struct ast_plane *ast_plane, struct iosys_map *src,\n\t\t\t      struct drm_framebuffer *fb,\n\t\t\t      const struct drm_rect *clip)\n{\n\tstruct iosys_map dst = IOSYS_MAP_INIT_VADDR_IOMEM(ast_plane->vaddr);\n\n\tiosys_map_incr(&dst, drm_fb_clip_offset(fb->pitches[0], fb->format, clip));\n\tdrm_fb_memcpy(&dst, fb->pitches, src, fb, clip);\n}\n\nstatic void ast_primary_plane_helper_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct ast_device *ast = to_ast_device(dev);\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_framebuffer *old_fb = old_plane_state->fb;\n\tstruct ast_plane *ast_plane = to_ast_plane(plane);\n\tstruct drm_rect damage;\n\tstruct drm_atomic_helper_damage_iter iter;\n\n\tif (!old_fb || (fb->format != old_fb->format)) {\n\t\tstruct drm_crtc *crtc = plane_state->crtc;\n\t\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\t\tstruct ast_crtc_state *ast_crtc_state = to_ast_crtc_state(crtc_state);\n\t\tstruct ast_vbios_mode_info *vbios_mode_info = &ast_crtc_state->vbios_mode_info;\n\n\t\tast_set_color_reg(ast, fb->format);\n\t\tast_set_vbios_color_reg(ast, fb->format, vbios_mode_info);\n\t}\n\n\tdrm_atomic_helper_damage_iter_init(&iter, old_plane_state, plane_state);\n\tdrm_atomic_for_each_plane_damage(&iter, &damage) {\n\t\tast_handle_damage(ast_plane, shadow_plane_state->data, fb, &damage);\n\t}\n\n\t \n\tif (!old_fb || old_fb->pitches[0] != fb->pitches[0])\n\t\tast_set_offset_reg(ast, fb);\n}\n\nstatic void ast_primary_plane_helper_atomic_enable(struct drm_plane *plane,\n\t\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct ast_device *ast = to_ast_device(plane->dev);\n\tstruct ast_plane *ast_plane = to_ast_plane(plane);\n\n\t \n\tast_set_start_address_crt1(ast, (u32)ast_plane->offset);\n\tast_set_index_reg_mask(ast, AST_IO_SEQ_PORT, 0x1, 0xdf, 0x00);\n}\n\nstatic void ast_primary_plane_helper_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct ast_device *ast = to_ast_device(plane->dev);\n\n\tast_set_index_reg_mask(ast, AST_IO_SEQ_PORT, 0x1, 0xdf, 0x20);\n}\n\nstatic const struct drm_plane_helper_funcs ast_primary_plane_helper_funcs = {\n\tDRM_GEM_SHADOW_PLANE_HELPER_FUNCS,\n\t.atomic_check = ast_primary_plane_helper_atomic_check,\n\t.atomic_update = ast_primary_plane_helper_atomic_update,\n\t.atomic_enable = ast_primary_plane_helper_atomic_enable,\n\t.atomic_disable = ast_primary_plane_helper_atomic_disable,\n};\n\nstatic const struct drm_plane_funcs ast_primary_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\tDRM_GEM_SHADOW_PLANE_FUNCS,\n};\n\nstatic int ast_primary_plane_init(struct ast_device *ast)\n{\n\tstruct drm_device *dev = &ast->base;\n\tstruct ast_plane *ast_primary_plane = &ast->primary_plane;\n\tstruct drm_plane *primary_plane = &ast_primary_plane->base;\n\tvoid __iomem *vaddr = ast->vram;\n\tu64 offset = 0;  \n\tunsigned long cursor_size = roundup(AST_HWC_SIZE + AST_HWC_SIGNATURE_SIZE, PAGE_SIZE);\n\tunsigned long size = ast->vram_fb_available - cursor_size;\n\tint ret;\n\n\tret = ast_plane_init(dev, ast_primary_plane, vaddr, offset, size,\n\t\t\t     0x01, &ast_primary_plane_funcs,\n\t\t\t     ast_primary_plane_formats, ARRAY_SIZE(ast_primary_plane_formats),\n\t\t\t     NULL, DRM_PLANE_TYPE_PRIMARY);\n\tif (ret) {\n\t\tdrm_err(dev, \"ast_plane_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_plane_helper_add(primary_plane, &ast_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary_plane);\n\n\treturn 0;\n}\n\n \n\nstatic void ast_update_cursor_image(u8 __iomem *dst, const u8 *src, int width, int height)\n{\n\tunion {\n\t\tu32 ul;\n\t\tu8 b[4];\n\t} srcdata32[2], data32;\n\tunion {\n\t\tu16 us;\n\t\tu8 b[2];\n\t} data16;\n\tu32 csum = 0;\n\ts32 alpha_dst_delta, last_alpha_dst_delta;\n\tu8 __iomem *dstxor;\n\tconst u8 *srcxor;\n\tint i, j;\n\tu32 per_pixel_copy, two_pixel_copy;\n\n\talpha_dst_delta = AST_MAX_HWC_WIDTH << 1;\n\tlast_alpha_dst_delta = alpha_dst_delta - (width << 1);\n\n\tsrcxor = src;\n\tdstxor = (u8 *)dst + last_alpha_dst_delta + (AST_MAX_HWC_HEIGHT - height) * alpha_dst_delta;\n\tper_pixel_copy = width & 1;\n\ttwo_pixel_copy = width >> 1;\n\n\tfor (j = 0; j < height; j++) {\n\t\tfor (i = 0; i < two_pixel_copy; i++) {\n\t\t\tsrcdata32[0].ul = *((u32 *)srcxor) & 0xf0f0f0f0;\n\t\t\tsrcdata32[1].ul = *((u32 *)(srcxor + 4)) & 0xf0f0f0f0;\n\t\t\tdata32.b[0] = srcdata32[0].b[1] | (srcdata32[0].b[0] >> 4);\n\t\t\tdata32.b[1] = srcdata32[0].b[3] | (srcdata32[0].b[2] >> 4);\n\t\t\tdata32.b[2] = srcdata32[1].b[1] | (srcdata32[1].b[0] >> 4);\n\t\t\tdata32.b[3] = srcdata32[1].b[3] | (srcdata32[1].b[2] >> 4);\n\n\t\t\twritel(data32.ul, dstxor);\n\t\t\tcsum += data32.ul;\n\n\t\t\tdstxor += 4;\n\t\t\tsrcxor += 8;\n\n\t\t}\n\n\t\tfor (i = 0; i < per_pixel_copy; i++) {\n\t\t\tsrcdata32[0].ul = *((u32 *)srcxor) & 0xf0f0f0f0;\n\t\t\tdata16.b[0] = srcdata32[0].b[1] | (srcdata32[0].b[0] >> 4);\n\t\t\tdata16.b[1] = srcdata32[0].b[3] | (srcdata32[0].b[2] >> 4);\n\t\t\twritew(data16.us, dstxor);\n\t\t\tcsum += (u32)data16.us;\n\n\t\t\tdstxor += 2;\n\t\t\tsrcxor += 4;\n\t\t}\n\t\tdstxor += last_alpha_dst_delta;\n\t}\n\n\t \n\tdst += AST_HWC_SIZE;\n\twritel(csum, dst);\n\twritel(width, dst + AST_HWC_SIGNATURE_SizeX);\n\twritel(height, dst + AST_HWC_SIGNATURE_SizeY);\n\twritel(0, dst + AST_HWC_SIGNATURE_HOTSPOTX);\n\twritel(0, dst + AST_HWC_SIGNATURE_HOTSPOTY);\n}\n\nstatic void ast_set_cursor_base(struct ast_device *ast, u64 address)\n{\n\tu8 addr0 = (address >> 3) & 0xff;\n\tu8 addr1 = (address >> 11) & 0xff;\n\tu8 addr2 = (address >> 19) & 0xff;\n\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc8, addr0);\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc9, addr1);\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xca, addr2);\n}\n\nstatic void ast_set_cursor_location(struct ast_device *ast, u16 x, u16 y,\n\t\t\t\t    u8 x_offset, u8 y_offset)\n{\n\tu8 x0 = (x & 0x00ff);\n\tu8 x1 = (x & 0x0f00) >> 8;\n\tu8 y0 = (y & 0x00ff);\n\tu8 y1 = (y & 0x0700) >> 8;\n\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc2, x_offset);\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc3, y_offset);\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc4, x0);\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc5, x1);\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc6, y0);\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc7, y1);\n}\n\nstatic void ast_set_cursor_enabled(struct ast_device *ast, bool enabled)\n{\n\tstatic const u8 mask = (u8)~(AST_IO_VGACRCB_HWC_16BPP |\n\t\t\t\t     AST_IO_VGACRCB_HWC_ENABLED);\n\n\tu8 vgacrcb = AST_IO_VGACRCB_HWC_16BPP;\n\n\tif (enabled)\n\t\tvgacrcb |= AST_IO_VGACRCB_HWC_ENABLED;\n\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xcb, mask, vgacrcb);\n}\n\nstatic const uint32_t ast_cursor_plane_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic int ast_cursor_plane_helper_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_framebuffer *new_fb = new_plane_state->fb;\n\tstruct drm_crtc_state *new_crtc_state = NULL;\n\tint ret;\n\n\tif (new_plane_state->crtc)\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, new_plane_state->crtc);\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, new_crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  true, true);\n\tif (ret || !new_plane_state->visible)\n\t\treturn ret;\n\n\tif (new_fb->width > AST_MAX_HWC_WIDTH || new_fb->height > AST_MAX_HWC_HEIGHT)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void ast_cursor_plane_helper_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct ast_plane *ast_plane = to_ast_plane(plane);\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct ast_device *ast = to_ast_device(plane->dev);\n\tstruct iosys_map src_map = shadow_plane_state->data[0];\n\tstruct drm_rect damage;\n\tconst u8 *src = src_map.vaddr;  \n\tu64 dst_off = ast_plane->offset;\n\tu8 __iomem *dst = ast_plane->vaddr;  \n\tu8 __iomem *sig = dst + AST_HWC_SIZE;  \n\tunsigned int offset_x, offset_y;\n\tu16 x, y;\n\tu8 x_offset, y_offset;\n\n\t \n\n\tif (drm_atomic_helper_damage_merged(old_plane_state, plane_state, &damage)) {\n\t\tast_update_cursor_image(dst, src, fb->width, fb->height);\n\t\tast_set_cursor_base(ast, dst_off);\n\t}\n\n\t \n\n\twritel(plane_state->crtc_x, sig + AST_HWC_SIGNATURE_X);\n\twritel(plane_state->crtc_y, sig + AST_HWC_SIGNATURE_Y);\n\n\toffset_x = AST_MAX_HWC_WIDTH - fb->width;\n\toffset_y = AST_MAX_HWC_HEIGHT - fb->height;\n\n\tif (plane_state->crtc_x < 0) {\n\t\tx_offset = (-plane_state->crtc_x) + offset_x;\n\t\tx = 0;\n\t} else {\n\t\tx_offset = offset_x;\n\t\tx = plane_state->crtc_x;\n\t}\n\tif (plane_state->crtc_y < 0) {\n\t\ty_offset = (-plane_state->crtc_y) + offset_y;\n\t\ty = 0;\n\t} else {\n\t\ty_offset = offset_y;\n\t\ty = plane_state->crtc_y;\n\t}\n\n\tast_set_cursor_location(ast, x, y, x_offset, y_offset);\n\n\t \n\tast_set_cursor_enabled(ast, true);\n}\n\nstatic void ast_cursor_plane_helper_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct ast_device *ast = to_ast_device(plane->dev);\n\n\tast_set_cursor_enabled(ast, false);\n}\n\nstatic const struct drm_plane_helper_funcs ast_cursor_plane_helper_funcs = {\n\tDRM_GEM_SHADOW_PLANE_HELPER_FUNCS,\n\t.atomic_check = ast_cursor_plane_helper_atomic_check,\n\t.atomic_update = ast_cursor_plane_helper_atomic_update,\n\t.atomic_disable = ast_cursor_plane_helper_atomic_disable,\n};\n\nstatic const struct drm_plane_funcs ast_cursor_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\tDRM_GEM_SHADOW_PLANE_FUNCS,\n};\n\nstatic int ast_cursor_plane_init(struct ast_device *ast)\n{\n\tstruct drm_device *dev = &ast->base;\n\tstruct ast_plane *ast_cursor_plane = &ast->cursor_plane;\n\tstruct drm_plane *cursor_plane = &ast_cursor_plane->base;\n\tsize_t size;\n\tvoid __iomem *vaddr;\n\tu64 offset;\n\tint ret;\n\n\t \n\n\tsize = roundup(AST_HWC_SIZE + AST_HWC_SIGNATURE_SIZE, PAGE_SIZE);\n\n\tif (ast->vram_fb_available < size)\n\t\treturn -ENOMEM;\n\n\tvaddr = ast->vram + ast->vram_fb_available - size;\n\toffset = ast->vram_fb_available - size;\n\n\tret = ast_plane_init(dev, ast_cursor_plane, vaddr, offset, size,\n\t\t\t     0x01, &ast_cursor_plane_funcs,\n\t\t\t     ast_cursor_plane_formats, ARRAY_SIZE(ast_cursor_plane_formats),\n\t\t\t     NULL, DRM_PLANE_TYPE_CURSOR);\n\tif (ret) {\n\t\tdrm_err(dev, \"ast_plane_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_plane_helper_add(cursor_plane, &ast_cursor_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(cursor_plane);\n\n\tast->vram_fb_available -= size;\n\n\treturn 0;\n}\n\n \n\nstatic void ast_crtc_dpms(struct drm_crtc *crtc, int mode)\n{\n\tstruct ast_device *ast = to_ast_device(crtc->dev);\n\tu8 ch = AST_DPMS_VSYNC_OFF | AST_DPMS_HSYNC_OFF;\n\tstruct ast_crtc_state *ast_state;\n\tconst struct drm_format_info *format;\n\tstruct ast_vbios_mode_info *vbios_mode_info;\n\n\t \n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_ON:\n\t\tast_set_index_reg_mask(ast, AST_IO_SEQ_PORT,  0x01, 0xdf, 0);\n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb6, 0xfc, 0);\n\t\tif (ast->tx_chip_types & AST_TX_DP501_BIT)\n\t\t\tast_set_dp501_video_output(crtc->dev, 1);\n\n\t\tif (ast->tx_chip_types & AST_TX_ASTDP_BIT) {\n\t\t\tast_dp_power_on_off(crtc->dev, AST_DP_POWER_ON);\n\t\t\tast_wait_for_vretrace(ast);\n\t\t\tast_dp_set_on_off(crtc->dev, 1);\n\t\t}\n\n\t\tast_state = to_ast_crtc_state(crtc->state);\n\t\tformat = ast_state->format;\n\n\t\tif (format) {\n\t\t\tvbios_mode_info = &ast_state->vbios_mode_info;\n\n\t\t\tast_set_color_reg(ast, format);\n\t\t\tast_set_vbios_color_reg(ast, format, vbios_mode_info);\n\t\t\tif (crtc->state->gamma_lut)\n\t\t\t\tast_crtc_set_gamma(ast, format, crtc->state->gamma_lut->data);\n\t\t\telse\n\t\t\t\tast_crtc_set_gamma_linear(ast, format);\n\t\t}\n\t\tbreak;\n\tcase DRM_MODE_DPMS_STANDBY:\n\tcase DRM_MODE_DPMS_SUSPEND:\n\tcase DRM_MODE_DPMS_OFF:\n\t\tch = mode;\n\t\tif (ast->tx_chip_types & AST_TX_DP501_BIT)\n\t\t\tast_set_dp501_video_output(crtc->dev, 0);\n\n\t\tif (ast->tx_chip_types & AST_TX_ASTDP_BIT) {\n\t\t\tast_dp_set_on_off(crtc->dev, 0);\n\t\t\tast_dp_power_on_off(crtc->dev, AST_DP_POWER_OFF);\n\t\t}\n\n\t\tast_set_index_reg_mask(ast, AST_IO_SEQ_PORT,  0x01, 0xdf, 0x20);\n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb6, 0xfc, ch);\n\t\tbreak;\n\t}\n}\n\nstatic enum drm_mode_status\nast_crtc_helper_mode_valid(struct drm_crtc *crtc, const struct drm_display_mode *mode)\n{\n\tstruct ast_device *ast = to_ast_device(crtc->dev);\n\tenum drm_mode_status status;\n\tuint32_t jtemp;\n\n\tif (ast->support_wide_screen) {\n\t\tif ((mode->hdisplay == 1680) && (mode->vdisplay == 1050))\n\t\t\treturn MODE_OK;\n\t\tif ((mode->hdisplay == 1280) && (mode->vdisplay == 800))\n\t\t\treturn MODE_OK;\n\t\tif ((mode->hdisplay == 1440) && (mode->vdisplay == 900))\n\t\t\treturn MODE_OK;\n\t\tif ((mode->hdisplay == 1360) && (mode->vdisplay == 768))\n\t\t\treturn MODE_OK;\n\t\tif ((mode->hdisplay == 1600) && (mode->vdisplay == 900))\n\t\t\treturn MODE_OK;\n\t\tif ((mode->hdisplay == 1152) && (mode->vdisplay == 864))\n\t\t\treturn MODE_OK;\n\n\t\tif ((ast->chip == AST2100) || \n\t\t    (ast->chip == AST2200) || \n\t\t    IS_AST_GEN4(ast) || IS_AST_GEN5(ast) ||\n\t\t    IS_AST_GEN6(ast) || IS_AST_GEN7(ast)) {\n\t\t\tif ((mode->hdisplay == 1920) && (mode->vdisplay == 1080))\n\t\t\t\treturn MODE_OK;\n\n\t\t\tif ((mode->hdisplay == 1920) && (mode->vdisplay == 1200)) {\n\t\t\t\tjtemp = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd1, 0xff);\n\t\t\t\tif (jtemp & 0x01)\n\t\t\t\t\treturn MODE_NOMODE;\n\t\t\t\telse\n\t\t\t\t\treturn MODE_OK;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatus = MODE_NOMODE;\n\n\tswitch (mode->hdisplay) {\n\tcase 640:\n\t\tif (mode->vdisplay == 480)\n\t\t\tstatus = MODE_OK;\n\t\tbreak;\n\tcase 800:\n\t\tif (mode->vdisplay == 600)\n\t\t\tstatus = MODE_OK;\n\t\tbreak;\n\tcase 1024:\n\t\tif (mode->vdisplay == 768)\n\t\t\tstatus = MODE_OK;\n\t\tbreak;\n\tcase 1152:\n\t\tif (mode->vdisplay == 864)\n\t\t\tstatus = MODE_OK;\n\t\tbreak;\n\tcase 1280:\n\t\tif (mode->vdisplay == 1024)\n\t\t\tstatus = MODE_OK;\n\t\tbreak;\n\tcase 1600:\n\t\tif (mode->vdisplay == 1200)\n\t\t\tstatus = MODE_OK;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic int ast_crtc_helper_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_crtc_state *old_crtc_state = drm_atomic_get_old_crtc_state(state, crtc);\n\tstruct ast_crtc_state *old_ast_crtc_state = to_ast_crtc_state(old_crtc_state);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct ast_crtc_state *ast_state;\n\tconst struct drm_format_info *format;\n\tbool succ;\n\tint ret;\n\n\tif (!crtc_state->enable)\n\t\treturn 0;\n\n\tret = drm_atomic_helper_check_crtc_primary_plane(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tast_state = to_ast_crtc_state(crtc_state);\n\n\tformat = ast_state->format;\n\tif (drm_WARN_ON_ONCE(dev, !format))\n\t\treturn -EINVAL;  \n\n\t \n\tif (old_ast_crtc_state->format != format)\n\t\tcrtc_state->color_mgmt_changed = true;\n\n\tif (crtc_state->color_mgmt_changed && crtc_state->gamma_lut) {\n\t\tif (crtc_state->gamma_lut->length !=\n\t\t    AST_LUT_SIZE * sizeof(struct drm_color_lut)) {\n\t\t\tdrm_err(dev, \"Wrong size for gamma_lut %zu\\n\",\n\t\t\t\tcrtc_state->gamma_lut->length);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tsucc = ast_get_vbios_mode_info(format, &crtc_state->mode,\n\t\t\t\t       &crtc_state->adjusted_mode,\n\t\t\t\t       &ast_state->vbios_mode_info);\n\tif (!succ)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void\nast_crtc_helper_atomic_flush(struct drm_crtc *crtc,\n\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct ast_device *ast = to_ast_device(dev);\n\tstruct ast_crtc_state *ast_crtc_state = to_ast_crtc_state(crtc_state);\n\tstruct ast_vbios_mode_info *vbios_mode_info = &ast_crtc_state->vbios_mode_info;\n\n\t \n\tif (crtc_state->enable && crtc_state->color_mgmt_changed) {\n\t\tif (crtc_state->gamma_lut)\n\t\t\tast_crtc_set_gamma(ast,\n\t\t\t\t\t   ast_crtc_state->format,\n\t\t\t\t\t   crtc_state->gamma_lut->data);\n\t\telse\n\t\t\tast_crtc_set_gamma_linear(ast, ast_crtc_state->format);\n\t}\n\n\t \n\tif (ast->tx_chip_types & AST_TX_ASTDP_BIT)\n\t\tast_dp_set_mode(crtc, vbios_mode_info);\n}\n\nstatic void ast_crtc_helper_atomic_enable(struct drm_crtc *crtc, struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct ast_device *ast = to_ast_device(dev);\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tstruct ast_crtc_state *ast_crtc_state = to_ast_crtc_state(crtc_state);\n\tstruct ast_vbios_mode_info *vbios_mode_info =\n\t\t&ast_crtc_state->vbios_mode_info;\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;\n\n\tast_set_vbios_mode_reg(ast, adjusted_mode, vbios_mode_info);\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa1, 0x06);\n\tast_set_std_reg(ast, adjusted_mode, vbios_mode_info);\n\tast_set_crtc_reg(ast, adjusted_mode, vbios_mode_info);\n\tast_set_dclk_reg(ast, adjusted_mode, vbios_mode_info);\n\tast_set_crtthd_reg(ast);\n\tast_set_sync_reg(ast, adjusted_mode, vbios_mode_info);\n\n\tast_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\n}\n\nstatic void ast_crtc_helper_atomic_disable(struct drm_crtc *crtc, struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state = drm_atomic_get_old_crtc_state(state, crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct ast_device *ast = to_ast_device(dev);\n\n\tast_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\n\n\t \n\tdrm_atomic_helper_disable_planes_on_crtc(old_crtc_state, false);\n\n\t \n\tast_wait_for_vretrace(ast);\n}\n\nstatic const struct drm_crtc_helper_funcs ast_crtc_helper_funcs = {\n\t.mode_valid = ast_crtc_helper_mode_valid,\n\t.atomic_check = ast_crtc_helper_atomic_check,\n\t.atomic_flush = ast_crtc_helper_atomic_flush,\n\t.atomic_enable = ast_crtc_helper_atomic_enable,\n\t.atomic_disable = ast_crtc_helper_atomic_disable,\n};\n\nstatic void ast_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct ast_crtc_state *ast_state =\n\t\tkzalloc(sizeof(*ast_state), GFP_KERNEL);\n\n\tif (crtc->state)\n\t\tcrtc->funcs->atomic_destroy_state(crtc, crtc->state);\n\n\tif (ast_state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &ast_state->base);\n\telse\n\t\t__drm_atomic_helper_crtc_reset(crtc, NULL);\n}\n\nstatic struct drm_crtc_state *\nast_crtc_atomic_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct ast_crtc_state *new_ast_state, *ast_state;\n\tstruct drm_device *dev = crtc->dev;\n\n\tif (drm_WARN_ON(dev, !crtc->state))\n\t\treturn NULL;\n\n\tnew_ast_state = kmalloc(sizeof(*new_ast_state), GFP_KERNEL);\n\tif (!new_ast_state)\n\t\treturn NULL;\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &new_ast_state->base);\n\n\tast_state = to_ast_crtc_state(crtc->state);\n\n\tnew_ast_state->format = ast_state->format;\n\tmemcpy(&new_ast_state->vbios_mode_info, &ast_state->vbios_mode_info,\n\t       sizeof(new_ast_state->vbios_mode_info));\n\n\treturn &new_ast_state->base;\n}\n\nstatic void ast_crtc_atomic_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_crtc_state *state)\n{\n\tstruct ast_crtc_state *ast_state = to_ast_crtc_state(state);\n\n\t__drm_atomic_helper_crtc_destroy_state(&ast_state->base);\n\tkfree(ast_state);\n}\n\nstatic const struct drm_crtc_funcs ast_crtc_funcs = {\n\t.reset = ast_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = ast_crtc_atomic_duplicate_state,\n\t.atomic_destroy_state = ast_crtc_atomic_destroy_state,\n};\n\nstatic int ast_crtc_init(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tstruct drm_crtc *crtc = &ast->crtc;\n\tint ret;\n\n\tret = drm_crtc_init_with_planes(dev, crtc, &ast->primary_plane.base,\n\t\t\t\t\t&ast->cursor_plane.base, &ast_crtc_funcs,\n\t\t\t\t\tNULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_mode_crtc_set_gamma_size(crtc, AST_LUT_SIZE);\n\tdrm_crtc_enable_color_mgmt(crtc, 0, false, AST_LUT_SIZE);\n\n\tdrm_crtc_helper_add(crtc, &ast_crtc_helper_funcs);\n\n\treturn 0;\n}\n\n \n\nstatic int ast_vga_connector_helper_get_modes(struct drm_connector *connector)\n{\n\tstruct ast_vga_connector *ast_vga_connector = to_ast_vga_connector(connector);\n\tstruct drm_device *dev = connector->dev;\n\tstruct ast_device *ast = to_ast_device(dev);\n\tstruct edid *edid;\n\tint count;\n\n\tif (!ast_vga_connector->i2c)\n\t\tgoto err_drm_connector_update_edid_property;\n\n\t \n\tmutex_lock(&ast->ioregs_lock);\n\n\tedid = drm_get_edid(connector, &ast_vga_connector->i2c->adapter);\n\tif (!edid)\n\t\tgoto err_mutex_unlock;\n\n\tmutex_unlock(&ast->ioregs_lock);\n\n\tcount = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\treturn count;\n\nerr_mutex_unlock:\n\tmutex_unlock(&ast->ioregs_lock);\nerr_drm_connector_update_edid_property:\n\tdrm_connector_update_edid_property(connector, NULL);\n\treturn 0;\n}\n\nstatic const struct drm_connector_helper_funcs ast_vga_connector_helper_funcs = {\n\t.get_modes = ast_vga_connector_helper_get_modes,\n};\n\nstatic const struct drm_connector_funcs ast_vga_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int ast_vga_connector_init(struct drm_device *dev,\n\t\t\t\t  struct ast_vga_connector *ast_vga_connector)\n{\n\tstruct drm_connector *connector = &ast_vga_connector->base;\n\tint ret;\n\n\tast_vga_connector->i2c = ast_i2c_create(dev);\n\tif (!ast_vga_connector->i2c)\n\t\tdrm_err(dev, \"failed to add ddc bus for connector\\n\");\n\n\tif (ast_vga_connector->i2c)\n\t\tret = drm_connector_init_with_ddc(dev, connector, &ast_vga_connector_funcs,\n\t\t\t\t\t\t  DRM_MODE_CONNECTOR_VGA,\n\t\t\t\t\t\t  &ast_vga_connector->i2c->adapter);\n\telse\n\t\tret = drm_connector_init(dev, connector, &ast_vga_connector_funcs,\n\t\t\t\t\t DRM_MODE_CONNECTOR_VGA);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_connector_helper_add(connector, &ast_vga_connector_helper_funcs);\n\n\tconnector->interlace_allowed = 0;\n\tconnector->doublescan_allowed = 0;\n\n\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\n\n\treturn 0;\n}\n\nstatic int ast_vga_output_init(struct ast_device *ast)\n{\n\tstruct drm_device *dev = &ast->base;\n\tstruct drm_crtc *crtc = &ast->crtc;\n\tstruct drm_encoder *encoder = &ast->output.vga.encoder;\n\tstruct ast_vga_connector *ast_vga_connector = &ast->output.vga.vga_connector;\n\tstruct drm_connector *connector = &ast_vga_connector->base;\n\tint ret;\n\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_DAC);\n\tif (ret)\n\t\treturn ret;\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\tret = ast_vga_connector_init(dev, ast_vga_connector);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n\nstatic int ast_sil164_connector_helper_get_modes(struct drm_connector *connector)\n{\n\tstruct ast_sil164_connector *ast_sil164_connector = to_ast_sil164_connector(connector);\n\tstruct drm_device *dev = connector->dev;\n\tstruct ast_device *ast = to_ast_device(dev);\n\tstruct edid *edid;\n\tint count;\n\n\tif (!ast_sil164_connector->i2c)\n\t\tgoto err_drm_connector_update_edid_property;\n\n\t \n\tmutex_lock(&ast->ioregs_lock);\n\n\tedid = drm_get_edid(connector, &ast_sil164_connector->i2c->adapter);\n\tif (!edid)\n\t\tgoto err_mutex_unlock;\n\n\tmutex_unlock(&ast->ioregs_lock);\n\n\tcount = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\treturn count;\n\nerr_mutex_unlock:\n\tmutex_unlock(&ast->ioregs_lock);\nerr_drm_connector_update_edid_property:\n\tdrm_connector_update_edid_property(connector, NULL);\n\treturn 0;\n}\n\nstatic const struct drm_connector_helper_funcs ast_sil164_connector_helper_funcs = {\n\t.get_modes = ast_sil164_connector_helper_get_modes,\n};\n\nstatic const struct drm_connector_funcs ast_sil164_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int ast_sil164_connector_init(struct drm_device *dev,\n\t\t\t\t     struct ast_sil164_connector *ast_sil164_connector)\n{\n\tstruct drm_connector *connector = &ast_sil164_connector->base;\n\tint ret;\n\n\tast_sil164_connector->i2c = ast_i2c_create(dev);\n\tif (!ast_sil164_connector->i2c)\n\t\tdrm_err(dev, \"failed to add ddc bus for connector\\n\");\n\n\tif (ast_sil164_connector->i2c)\n\t\tret = drm_connector_init_with_ddc(dev, connector, &ast_sil164_connector_funcs,\n\t\t\t\t\t\t  DRM_MODE_CONNECTOR_DVII,\n\t\t\t\t\t\t  &ast_sil164_connector->i2c->adapter);\n\telse\n\t\tret = drm_connector_init(dev, connector, &ast_sil164_connector_funcs,\n\t\t\t\t\t DRM_MODE_CONNECTOR_DVII);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_connector_helper_add(connector, &ast_sil164_connector_helper_funcs);\n\n\tconnector->interlace_allowed = 0;\n\tconnector->doublescan_allowed = 0;\n\n\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\n\n\treturn 0;\n}\n\nstatic int ast_sil164_output_init(struct ast_device *ast)\n{\n\tstruct drm_device *dev = &ast->base;\n\tstruct drm_crtc *crtc = &ast->crtc;\n\tstruct drm_encoder *encoder = &ast->output.sil164.encoder;\n\tstruct ast_sil164_connector *ast_sil164_connector = &ast->output.sil164.sil164_connector;\n\tstruct drm_connector *connector = &ast_sil164_connector->base;\n\tint ret;\n\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_TMDS);\n\tif (ret)\n\t\treturn ret;\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\tret = ast_sil164_connector_init(dev, ast_sil164_connector);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n\nstatic int ast_dp501_connector_helper_get_modes(struct drm_connector *connector)\n{\n\tvoid *edid;\n\tbool succ;\n\tint count;\n\n\tedid = kmalloc(EDID_LENGTH, GFP_KERNEL);\n\tif (!edid)\n\t\tgoto err_drm_connector_update_edid_property;\n\n\tsucc = ast_dp501_read_edid(connector->dev, edid);\n\tif (!succ)\n\t\tgoto err_kfree;\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tcount = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\treturn count;\n\nerr_kfree:\n\tkfree(edid);\nerr_drm_connector_update_edid_property:\n\tdrm_connector_update_edid_property(connector, NULL);\n\treturn 0;\n}\n\nstatic int ast_dp501_connector_helper_detect_ctx(struct drm_connector *connector,\n\t\t\t\t\t\t struct drm_modeset_acquire_ctx *ctx,\n\t\t\t\t\t\t bool force)\n{\n\tstruct ast_device *ast = to_ast_device(connector->dev);\n\n\tif (ast_dp501_is_connected(ast))\n\t\treturn connector_status_connected;\n\treturn connector_status_disconnected;\n}\n\nstatic const struct drm_connector_helper_funcs ast_dp501_connector_helper_funcs = {\n\t.get_modes = ast_dp501_connector_helper_get_modes,\n\t.detect_ctx = ast_dp501_connector_helper_detect_ctx,\n};\n\nstatic const struct drm_connector_funcs ast_dp501_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int ast_dp501_connector_init(struct drm_device *dev, struct drm_connector *connector)\n{\n\tint ret;\n\n\tret = drm_connector_init(dev, connector, &ast_dp501_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_DisplayPort);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_connector_helper_add(connector, &ast_dp501_connector_helper_funcs);\n\n\tconnector->interlace_allowed = 0;\n\tconnector->doublescan_allowed = 0;\n\n\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT;\n\n\treturn 0;\n}\n\nstatic int ast_dp501_output_init(struct ast_device *ast)\n{\n\tstruct drm_device *dev = &ast->base;\n\tstruct drm_crtc *crtc = &ast->crtc;\n\tstruct drm_encoder *encoder = &ast->output.dp501.encoder;\n\tstruct drm_connector *connector = &ast->output.dp501.connector;\n\tint ret;\n\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_TMDS);\n\tif (ret)\n\t\treturn ret;\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\tret = ast_dp501_connector_init(dev, connector);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n\nstatic int ast_astdp_connector_helper_get_modes(struct drm_connector *connector)\n{\n\tvoid *edid;\n\tstruct drm_device *dev = connector->dev;\n\tstruct ast_device *ast = to_ast_device(dev);\n\n\tint succ;\n\tint count;\n\n\tedid = kmalloc(EDID_LENGTH, GFP_KERNEL);\n\tif (!edid)\n\t\tgoto err_drm_connector_update_edid_property;\n\n\t \n\tmutex_lock(&ast->ioregs_lock);\n\n\tsucc = ast_astdp_read_edid(connector->dev, edid);\n\tif (succ < 0)\n\t\tgoto err_mutex_unlock;\n\n\tmutex_unlock(&ast->ioregs_lock);\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tcount = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\treturn count;\n\nerr_mutex_unlock:\n\tmutex_unlock(&ast->ioregs_lock);\n\tkfree(edid);\nerr_drm_connector_update_edid_property:\n\tdrm_connector_update_edid_property(connector, NULL);\n\treturn 0;\n}\n\nstatic int ast_astdp_connector_helper_detect_ctx(struct drm_connector *connector,\n\t\t\t\t\t\t struct drm_modeset_acquire_ctx *ctx,\n\t\t\t\t\t\t bool force)\n{\n\tstruct ast_device *ast = to_ast_device(connector->dev);\n\n\tif (ast_astdp_is_connected(ast))\n\t\treturn connector_status_connected;\n\treturn connector_status_disconnected;\n}\n\nstatic const struct drm_connector_helper_funcs ast_astdp_connector_helper_funcs = {\n\t.get_modes = ast_astdp_connector_helper_get_modes,\n\t.detect_ctx = ast_astdp_connector_helper_detect_ctx,\n};\n\nstatic const struct drm_connector_funcs ast_astdp_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int ast_astdp_connector_init(struct drm_device *dev, struct drm_connector *connector)\n{\n\tint ret;\n\n\tret = drm_connector_init(dev, connector, &ast_astdp_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_DisplayPort);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_connector_helper_add(connector, &ast_astdp_connector_helper_funcs);\n\n\tconnector->interlace_allowed = 0;\n\tconnector->doublescan_allowed = 0;\n\n\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT;\n\n\treturn 0;\n}\n\nstatic int ast_astdp_output_init(struct ast_device *ast)\n{\n\tstruct drm_device *dev = &ast->base;\n\tstruct drm_crtc *crtc = &ast->crtc;\n\tstruct drm_encoder *encoder = &ast->output.astdp.encoder;\n\tstruct drm_connector *connector = &ast->output.astdp.connector;\n\tint ret;\n\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_TMDS);\n\tif (ret)\n\t\treturn ret;\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\tret = ast_astdp_connector_init(dev, connector);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n\nstatic const struct drm_encoder_funcs ast_bmc_encoder_funcs = {\n\t.destroy = drm_encoder_cleanup,\n};\n\nstatic int ast_bmc_connector_helper_detect_ctx(struct drm_connector *connector,\n\t\t\t\t\t       struct drm_modeset_acquire_ctx *ctx,\n\t\t\t\t\t       bool force)\n{\n\tstruct ast_bmc_connector *bmc_connector = to_ast_bmc_connector(connector);\n\tstruct drm_connector *physical_connector = bmc_connector->physical_connector;\n\n\t \n\n\tif (physical_connector && physical_connector->status == connector_status_disconnected)\n\t\treturn connector_status_connected;\n\n\treturn connector_status_disconnected;\n}\n\nstatic int ast_bmc_connector_helper_get_modes(struct drm_connector *connector)\n{\n\treturn drm_add_modes_noedid(connector, 4096, 4096);\n}\n\nstatic const struct drm_connector_helper_funcs ast_bmc_connector_helper_funcs = {\n\t.get_modes = ast_bmc_connector_helper_get_modes,\n\t.detect_ctx = ast_bmc_connector_helper_detect_ctx,\n};\n\nstatic const struct drm_connector_funcs ast_bmc_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int ast_bmc_connector_init(struct drm_device *dev,\n\t\t\t\t  struct ast_bmc_connector *bmc_connector,\n\t\t\t\t  struct drm_connector *physical_connector)\n{\n\tstruct drm_connector *connector = &bmc_connector->base;\n\tint ret;\n\n\tret = drm_connector_init(dev, connector, &ast_bmc_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_VIRTUAL);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_connector_helper_add(connector, &ast_bmc_connector_helper_funcs);\n\n\tbmc_connector->physical_connector = physical_connector;\n\n\treturn 0;\n}\n\nstatic int ast_bmc_output_init(struct ast_device *ast,\n\t\t\t       struct drm_connector *physical_connector)\n{\n\tstruct drm_device *dev = &ast->base;\n\tstruct drm_crtc *crtc = &ast->crtc;\n\tstruct drm_encoder *encoder = &ast->output.bmc.encoder;\n\tstruct ast_bmc_connector *bmc_connector = &ast->output.bmc.bmc_connector;\n\tstruct drm_connector *connector = &bmc_connector->base;\n\tint ret;\n\n\tret = drm_encoder_init(dev, encoder,\n\t\t\t       &ast_bmc_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_VIRTUAL, \"ast_bmc\");\n\tif (ret)\n\t\treturn ret;\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\tret = ast_bmc_connector_init(dev, bmc_connector, physical_connector);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n\nstatic void ast_mode_config_helper_atomic_commit_tail(struct drm_atomic_state *state)\n{\n\tstruct ast_device *ast = to_ast_device(state->dev);\n\n\t \n\tmutex_lock(&ast->ioregs_lock);\n\tdrm_atomic_helper_commit_tail_rpm(state);\n\tmutex_unlock(&ast->ioregs_lock);\n}\n\nstatic const struct drm_mode_config_helper_funcs ast_mode_config_helper_funcs = {\n\t.atomic_commit_tail = ast_mode_config_helper_atomic_commit_tail,\n};\n\nstatic enum drm_mode_status ast_mode_config_mode_valid(struct drm_device *dev,\n\t\t\t\t\t\t       const struct drm_display_mode *mode)\n{\n\tstatic const unsigned long max_bpp = 4;  \n\tstruct ast_device *ast = to_ast_device(dev);\n\tunsigned long fbsize, fbpages, max_fbpages;\n\n\tmax_fbpages = (ast->vram_fb_available) >> PAGE_SHIFT;\n\n\tfbsize = mode->hdisplay * mode->vdisplay * max_bpp;\n\tfbpages = DIV_ROUND_UP(fbsize, PAGE_SIZE);\n\n\tif (fbpages > max_fbpages)\n\t\treturn MODE_MEM;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_mode_config_funcs ast_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.mode_valid = ast_mode_config_mode_valid,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nint ast_mode_config_init(struct ast_device *ast)\n{\n\tstruct drm_device *dev = &ast->base;\n\tstruct drm_connector *physical_connector = NULL;\n\tint ret;\n\n\tret = drmm_mode_config_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mode_config.funcs = &ast_mode_config_funcs;\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tdev->mode_config.preferred_depth = 24;\n\n\tif (ast->chip == AST2100 || \n\t    ast->chip == AST2200 || \n\t    IS_AST_GEN7(ast) ||\n\t    IS_AST_GEN6(ast) ||\n\t    IS_AST_GEN5(ast) ||\n\t    IS_AST_GEN4(ast)) {\n\t\tdev->mode_config.max_width = 1920;\n\t\tdev->mode_config.max_height = 2048;\n\t} else {\n\t\tdev->mode_config.max_width = 1600;\n\t\tdev->mode_config.max_height = 1200;\n\t}\n\n\tdev->mode_config.helper_private = &ast_mode_config_helper_funcs;\n\n\tret = ast_primary_plane_init(ast);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ast_cursor_plane_init(ast);\n\tif (ret)\n\t\treturn ret;\n\n\tast_crtc_init(dev);\n\n\tif (ast->tx_chip_types & AST_TX_NONE_BIT) {\n\t\tret = ast_vga_output_init(ast);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tphysical_connector = &ast->output.vga.vga_connector.base;\n\t}\n\tif (ast->tx_chip_types & AST_TX_SIL164_BIT) {\n\t\tret = ast_sil164_output_init(ast);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tphysical_connector = &ast->output.sil164.sil164_connector.base;\n\t}\n\tif (ast->tx_chip_types & AST_TX_DP501_BIT) {\n\t\tret = ast_dp501_output_init(ast);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tphysical_connector = &ast->output.dp501.connector;\n\t}\n\tif (ast->tx_chip_types & AST_TX_ASTDP_BIT) {\n\t\tret = ast_astdp_output_init(ast);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tphysical_connector = &ast->output.astdp.connector;\n\t}\n\tret = ast_bmc_output_init(ast, physical_connector);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_mode_config_reset(dev);\n\n\tdrm_kms_helper_poll_init(dev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}