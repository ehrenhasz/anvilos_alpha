{
  "module_name": "ast_i2c.c",
  "hash_id": "11ff929fb6e9479b3a9ad9a548cc15a0be16cac707ed97caab17bf5dd1f66edd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ast/ast_i2c.c",
  "human_readable_source": "\n \n\n#include <drm/drm_managed.h>\n#include <drm/drm_print.h>\n\n#include \"ast_drv.h\"\n\nstatic void ast_i2c_setsda(void *i2c_priv, int data)\n{\n\tstruct ast_i2c_chan *i2c = i2c_priv;\n\tstruct ast_device *ast = to_ast_device(i2c->dev);\n\tint i;\n\tu8 ujcrb7, jtemp;\n\n\tfor (i = 0; i < 0x10000; i++) {\n\t\tujcrb7 = ((data & 0x01) ? 0 : 1) << 2;\n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0xf1, ujcrb7);\n\t\tjtemp = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x04);\n\t\tif (ujcrb7 == jtemp)\n\t\t\tbreak;\n\t}\n}\n\nstatic void ast_i2c_setscl(void *i2c_priv, int clock)\n{\n\tstruct ast_i2c_chan *i2c = i2c_priv;\n\tstruct ast_device *ast = to_ast_device(i2c->dev);\n\tint i;\n\tu8 ujcrb7, jtemp;\n\n\tfor (i = 0; i < 0x10000; i++) {\n\t\tujcrb7 = ((clock & 0x01) ? 0 : 1);\n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0xf4, ujcrb7);\n\t\tjtemp = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x01);\n\t\tif (ujcrb7 == jtemp)\n\t\t\tbreak;\n\t}\n}\n\nstatic int ast_i2c_getsda(void *i2c_priv)\n{\n\tstruct ast_i2c_chan *i2c = i2c_priv;\n\tstruct ast_device *ast = to_ast_device(i2c->dev);\n\tuint32_t val, val2, count, pass;\n\n\tcount = 0;\n\tpass = 0;\n\tval = (ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x20) >> 5) & 0x01;\n\tdo {\n\t\tval2 = (ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x20) >> 5) & 0x01;\n\t\tif (val == val2) {\n\t\t\tpass++;\n\t\t} else {\n\t\t\tpass = 0;\n\t\t\tval = (ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x20) >> 5) & 0x01;\n\t\t}\n\t} while ((pass < 5) && (count++ < 0x10000));\n\n\treturn val & 1 ? 1 : 0;\n}\n\nstatic int ast_i2c_getscl(void *i2c_priv)\n{\n\tstruct ast_i2c_chan *i2c = i2c_priv;\n\tstruct ast_device *ast = to_ast_device(i2c->dev);\n\tuint32_t val, val2, count, pass;\n\n\tcount = 0;\n\tpass = 0;\n\tval = (ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x10) >> 4) & 0x01;\n\tdo {\n\t\tval2 = (ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x10) >> 4) & 0x01;\n\t\tif (val == val2) {\n\t\t\tpass++;\n\t\t} else {\n\t\t\tpass = 0;\n\t\t\tval = (ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x10) >> 4) & 0x01;\n\t\t}\n\t} while ((pass < 5) && (count++ < 0x10000));\n\n\treturn val & 1 ? 1 : 0;\n}\n\nstatic void ast_i2c_release(struct drm_device *dev, void *res)\n{\n\tstruct ast_i2c_chan *i2c = res;\n\n\ti2c_del_adapter(&i2c->adapter);\n\tkfree(i2c);\n}\n\nstruct ast_i2c_chan *ast_i2c_create(struct drm_device *dev)\n{\n\tstruct ast_i2c_chan *i2c;\n\tint ret;\n\n\ti2c = kzalloc(sizeof(struct ast_i2c_chan), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn NULL;\n\n\ti2c->adapter.owner = THIS_MODULE;\n\ti2c->adapter.class = I2C_CLASS_DDC;\n\ti2c->adapter.dev.parent = dev->dev;\n\ti2c->dev = dev;\n\ti2c_set_adapdata(&i2c->adapter, i2c);\n\tsnprintf(i2c->adapter.name, sizeof(i2c->adapter.name),\n\t\t \"AST i2c bit bus\");\n\ti2c->adapter.algo_data = &i2c->bit;\n\n\ti2c->bit.udelay = 20;\n\ti2c->bit.timeout = 2;\n\ti2c->bit.data = i2c;\n\ti2c->bit.setsda = ast_i2c_setsda;\n\ti2c->bit.setscl = ast_i2c_setscl;\n\ti2c->bit.getsda = ast_i2c_getsda;\n\ti2c->bit.getscl = ast_i2c_getscl;\n\tret = i2c_bit_add_bus(&i2c->adapter);\n\tif (ret) {\n\t\tdrm_err(dev, \"Failed to register bit i2c\\n\");\n\t\tgoto out_kfree;\n\t}\n\n\tret = drmm_add_action_or_reset(dev, ast_i2c_release, i2c);\n\tif (ret)\n\t\treturn NULL;\n\treturn i2c;\n\nout_kfree:\n\tkfree(i2c);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}