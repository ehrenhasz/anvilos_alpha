{
  "module_name": "ast_dp501.c",
  "hash_id": "0abe4fc3a2d990db84d035a302fed543ed2747b223f31516c7b8b8120acf9f94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ast/ast_dp501.c",
  "human_readable_source": "\n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n\n#include \"ast_drv.h\"\n\nMODULE_FIRMWARE(\"ast_dp501_fw.bin\");\n\nstatic void ast_release_firmware(void *data)\n{\n\tstruct ast_device *ast = data;\n\n\trelease_firmware(ast->dp501_fw);\n\tast->dp501_fw = NULL;\n}\n\nstatic int ast_load_dp501_microcode(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tint ret;\n\n\tret = request_firmware(&ast->dp501_fw, \"ast_dp501_fw.bin\", dev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev->dev, ast_release_firmware, ast);\n}\n\nstatic void send_ack(struct ast_device *ast)\n{\n\tu8 sendack;\n\tsendack = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, 0xff);\n\tsendack |= 0x80;\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, 0x00, sendack);\n}\n\nstatic void send_nack(struct ast_device *ast)\n{\n\tu8 sendack;\n\tsendack = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, 0xff);\n\tsendack &= ~0x80;\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, 0x00, sendack);\n}\n\nstatic bool wait_ack(struct ast_device *ast)\n{\n\tu8 waitack;\n\tu32 retry = 0;\n\tdo {\n\t\twaitack = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd2, 0xff);\n\t\twaitack &= 0x80;\n\t\tudelay(100);\n\t} while ((!waitack) && (retry++ < 1000));\n\n\tif (retry < 1000)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool wait_nack(struct ast_device *ast)\n{\n\tu8 waitack;\n\tu32 retry = 0;\n\tdo {\n\t\twaitack = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd2, 0xff);\n\t\twaitack &= 0x80;\n\t\tudelay(100);\n\t} while ((waitack) && (retry++ < 1000));\n\n\tif (retry < 1000)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void set_cmd_trigger(struct ast_device *ast)\n{\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, ~0x40, 0x40);\n}\n\nstatic void clear_cmd_trigger(struct ast_device *ast)\n{\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, ~0x40, 0x00);\n}\n\n#if 0\nstatic bool wait_fw_ready(struct ast_device *ast)\n{\n\tu8 waitready;\n\tu32 retry = 0;\n\tdo {\n\t\twaitready = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd2, 0xff);\n\t\twaitready &= 0x40;\n\t\tudelay(100);\n\t} while ((!waitready) && (retry++ < 1000));\n\n\tif (retry < 1000)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n#endif\n\nstatic bool ast_write_cmd(struct drm_device *dev, u8 data)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tint retry = 0;\n\tif (wait_nack(ast)) {\n\t\tsend_nack(ast);\n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9a, 0x00, data);\n\t\tsend_ack(ast);\n\t\tset_cmd_trigger(ast);\n\t\tdo {\n\t\t\tif (wait_ack(ast)) {\n\t\t\t\tclear_cmd_trigger(ast);\n\t\t\t\tsend_nack(ast);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} while (retry++ < 100);\n\t}\n\tclear_cmd_trigger(ast);\n\tsend_nack(ast);\n\treturn false;\n}\n\nstatic bool ast_write_data(struct drm_device *dev, u8 data)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\n\tif (wait_nack(ast)) {\n\t\tsend_nack(ast);\n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9a, 0x00, data);\n\t\tsend_ack(ast);\n\t\tif (wait_ack(ast)) {\n\t\t\tsend_nack(ast);\n\t\t\treturn true;\n\t\t}\n\t}\n\tsend_nack(ast);\n\treturn false;\n}\n\n#if 0\nstatic bool ast_read_data(struct drm_device *dev, u8 *data)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu8 tmp;\n\n\t*data = 0;\n\n\tif (wait_ack(ast) == false)\n\t\treturn false;\n\ttmp = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd3, 0xff);\n\t*data = tmp;\n\tif (wait_nack(ast) == false) {\n\t\tsend_nack(ast);\n\t\treturn false;\n\t}\n\tsend_nack(ast);\n\treturn true;\n}\n\nstatic void clear_cmd(struct ast_device *ast)\n{\n\tsend_nack(ast);\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9a, 0x00, 0x00);\n}\n#endif\n\nvoid ast_set_dp501_video_output(struct drm_device *dev, u8 mode)\n{\n\tast_write_cmd(dev, 0x40);\n\tast_write_data(dev, mode);\n\n\tmsleep(10);\n}\n\nstatic u32 get_fw_base(struct ast_device *ast)\n{\n\treturn ast_mindwm(ast, 0x1e6e2104) & 0x7fffffff;\n}\n\nbool ast_backup_fw(struct drm_device *dev, u8 *addr, u32 size)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu32 i, data;\n\tu32 boot_address;\n\n\tif (ast->config_mode != ast_use_p2a)\n\t\treturn false;\n\n\tdata = ast_mindwm(ast, 0x1e6e2100) & 0x01;\n\tif (data) {\n\t\tboot_address = get_fw_base(ast);\n\t\tfor (i = 0; i < size; i += 4)\n\t\t\t*(u32 *)(addr + i) = ast_mindwm(ast, boot_address + i);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool ast_launch_m68k(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu32 i, data, len = 0;\n\tu32 boot_address;\n\tu8 *fw_addr = NULL;\n\tu8 jreg;\n\n\tif (ast->config_mode != ast_use_p2a)\n\t\treturn false;\n\n\tdata = ast_mindwm(ast, 0x1e6e2100) & 0x01;\n\tif (!data) {\n\n\t\tif (ast->dp501_fw_addr) {\n\t\t\tfw_addr = ast->dp501_fw_addr;\n\t\t\tlen = 32*1024;\n\t\t} else {\n\t\t\tif (!ast->dp501_fw &&\n\t\t\t    ast_load_dp501_microcode(dev) < 0)\n\t\t\t\treturn false;\n\n\t\t\tfw_addr = (u8 *)ast->dp501_fw->data;\n\t\t\tlen = ast->dp501_fw->size;\n\t\t}\n\t\t \n\t\tast_moutdwm(ast, 0x1e6e2000, 0x1688a8a8);\n\t\tdata = ast_mindwm(ast, 0x1e6e0004);\n\t\tswitch (data & 0x03) {\n\t\tcase 0:\n\t\t\tboot_address = 0x44000000;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 1:\n\t\t\tboot_address = 0x48000000;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tboot_address = 0x50000000;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tboot_address = 0x60000000;\n\t\t\tbreak;\n\t\t}\n\t\tboot_address -= 0x200000;  \n\n\t\t \n\t\tfor (i = 0; i < len; i += 4) {\n\t\t\tdata = *(u32 *)(fw_addr + i);\n\t\t\tast_moutdwm(ast, boot_address + i, data);\n\t\t}\n\n\t\t \n\t\tast_moutdwm(ast, 0x1e6e2000, 0x1688a8a8);\n\n\t\t \n\t\tast_moutdwm(ast, 0x1e6e2104, 0x80000000 + boot_address);\n\t\tast_moutdwm(ast, 0x1e6e2100, 1);\n\n\t\t \n\t\tdata = ast_mindwm(ast, 0x1e6e2040) & 0xfffff1ff;\t\t \n\t\tdata |= 0x800;\n\t\tast_moutdwm(ast, 0x1e6e2040, data);\n\n\t\tjreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x99, 0xfc);  \n\t\tjreg |= 0x02;\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x99, jreg);\n\t}\n\treturn true;\n}\n\nbool ast_dp501_is_connected(struct ast_device *ast)\n{\n\tu32 boot_address, offset, data;\n\n\tif (ast->config_mode == ast_use_p2a) {\n\t\tboot_address = get_fw_base(ast);\n\n\t\t \n\t\toffset = AST_DP501_GBL_VERSION;\n\t\tdata = ast_mindwm(ast, boot_address + offset);\n\t\tif ((data & AST_DP501_FW_VERSION_MASK) != AST_DP501_FW_VERSION_1)\n\t\t\treturn false;\n\n\t\t \n\t\toffset = AST_DP501_PNPMONITOR;\n\t\tdata = ast_mindwm(ast, boot_address + offset);\n\t\tif (!(data & AST_DP501_PNP_CONNECTED))\n\t\t\treturn false;\n\t} else {\n\t\tif (!ast->dp501_fw_buf)\n\t\t\treturn false;\n\n\t\t \n\t\toffset = 0x0000;\n\t\tdata = readl(ast->dp501_fw_buf + offset);\n\n\t\t \n\t\toffset = AST_DP501_GBL_VERSION;\n\t\tdata = readl(ast->dp501_fw_buf + offset);\n\t\tif ((data & AST_DP501_FW_VERSION_MASK) != AST_DP501_FW_VERSION_1)\n\t\t\treturn false;\n\n\t\t \n\t\toffset = AST_DP501_PNPMONITOR;\n\t\tdata = readl(ast->dp501_fw_buf + offset);\n\t\tif (!(data & AST_DP501_PNP_CONNECTED))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool ast_dp501_read_edid(struct drm_device *dev, u8 *ediddata)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu32 i, boot_address, offset, data;\n\tu32 *pEDIDidx;\n\n\tif (!ast_dp501_is_connected(ast))\n\t\treturn false;\n\n\tif (ast->config_mode == ast_use_p2a) {\n\t\tboot_address = get_fw_base(ast);\n\n\t\t \n\t\toffset = AST_DP501_EDID_DATA;\n\t\tfor (i = 0; i < 128; i += 4) {\n\t\t\tdata = ast_mindwm(ast, boot_address + offset + i);\n\t\t\tpEDIDidx = (u32 *)(ediddata + i);\n\t\t\t*pEDIDidx = data;\n\t\t}\n\t} else {\n\t\t \n\t\toffset = AST_DP501_EDID_DATA;\n\t\tfor (i = 0; i < 128; i += 4) {\n\t\t\tdata = readl(ast->dp501_fw_buf + offset + i);\n\t\t\tpEDIDidx = (u32 *)(ediddata + i);\n\t\t\t*pEDIDidx = data;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool ast_init_dvo(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu8 jreg;\n\tu32 data;\n\tast_write32(ast, 0xf004, 0x1e6e0000);\n\tast_write32(ast, 0xf000, 0x1);\n\tast_write32(ast, 0x12000, 0x1688a8a8);\n\n\tjreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\n\tif (!(jreg & 0x80)) {\n\t\t \n\t\tdata = ast_read32(ast, 0x12008);\n\t\t \n\t\tdata &= 0xfffff8ff;\n\t\tdata |= 0x00000500;\n\t\tast_write32(ast, 0x12008, data);\n\n\t\tif (IS_AST_GEN4(ast)) {\n\t\t\tdata = ast_read32(ast, 0x12084);\n\t\t\t \n\t\t\tdata |= 0xfffe0000;\n\t\t\tast_write32(ast, 0x12084, data);\n\n\t\t\tdata = ast_read32(ast, 0x12088);\n\t\t\t \n\t\t\tdata |= 0x000fffff;\n\t\t\tast_write32(ast, 0x12088, data);\n\n\t\t\tdata = ast_read32(ast, 0x12090);\n\t\t\t \n\t\t\tdata &= 0xffffffcf;\n\t\t\tdata |= 0x00000020;\n\t\t\tast_write32(ast, 0x12090, data);\n\t\t} else {  \n\t\t\tdata = ast_read32(ast, 0x12088);\n\t\t\t \n\t\t\tdata |= 0x30000000;\n\t\t\tast_write32(ast, 0x12088, data);\n\n\t\t\tdata = ast_read32(ast, 0x1208c);\n\t\t\t \n\t\t\tdata |= 0x000000cf;\n\t\t\tast_write32(ast, 0x1208c, data);\n\n\t\t\tdata = ast_read32(ast, 0x120a4);\n\t\t\t \n\t\t\tdata |= 0xffff0000;\n\t\t\tast_write32(ast, 0x120a4, data);\n\n\t\t\tdata = ast_read32(ast, 0x120a8);\n\t\t\t \n\t\t\tdata |= 0x0000000f;\n\t\t\tast_write32(ast, 0x120a8, data);\n\n\t\t\tdata = ast_read32(ast, 0x12094);\n\t\t\t \n\t\t\tdata |= 0x00000002;\n\t\t\tast_write32(ast, 0x12094, data);\n\t\t}\n\t}\n\n\t \n\tdata = ast_read32(ast, 0x1202c);\n\tdata &= 0xfffbffff;\n\tast_write32(ast, 0x1202c, data);\n\n\t \n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa3, 0xcf, 0x80);\n\treturn true;\n}\n\n\nstatic void ast_init_analog(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu32 data;\n\n\t \n\tast_write32(ast, 0xf004, 0x1e6e0000);\n\tast_write32(ast, 0xf000, 0x1);\n\n\t \n\tast_write32(ast, 0x12000, 0x1688a8a8);\n\tast_write32(ast, 0x12000, 0x1688a8a8);\n\tast_write32(ast, 0x12000, 0x1688a8a8);\n\n\t \n\tdata = ast_read32(ast, 0x1202c);\n\tdata &= 0xfffcffff;\n\tast_write32(ast, 0, data);\n\n\t \n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa3, 0xcf, 0x00);\n}\n\nvoid ast_init_3rdtx(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu8 jreg;\n\n\tif (IS_AST_GEN4(ast) || IS_AST_GEN5(ast)) {\n\t\tjreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd1, 0xff);\n\t\tswitch (jreg & 0x0e) {\n\t\tcase 0x04:\n\t\t\tast_init_dvo(dev);\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\tast_launch_m68k(dev);\n\t\t\tbreak;\n\t\tcase 0x0c:\n\t\t\tast_init_dvo(dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ast->tx_chip_types & BIT(AST_TX_SIL164))\n\t\t\t\tast_init_dvo(dev);\n\t\t\telse\n\t\t\t\tast_init_analog(dev);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}