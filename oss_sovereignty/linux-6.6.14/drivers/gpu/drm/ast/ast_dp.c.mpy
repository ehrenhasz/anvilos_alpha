{
  "module_name": "ast_dp.c",
  "hash_id": "92cd0ad8147d743d59dfda6fb947e178e9327c98230fc8ab839976389030e861",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ast/ast_dp.c",
  "human_readable_source": "\n\n\n\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <drm/drm_print.h>\n#include \"ast_drv.h\"\n\nbool ast_astdp_is_connected(struct ast_device *ast)\n{\n\tif (!ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xD1, ASTDP_MCU_FW_EXECUTING))\n\t\treturn false;\n\tif (!ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDF, ASTDP_HPD))\n\t\treturn false;\n\tif (!ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDC, ASTDP_LINK_SUCCESS))\n\t\treturn false;\n\treturn true;\n}\n\nint ast_astdp_read_edid(struct drm_device *dev, u8 *ediddata)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu8 i = 0, j = 0;\n\n\t \n\tif (!(ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xD1, ASTDP_MCU_FW_EXECUTING) &&\n\t\tast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDC, ASTDP_LINK_SUCCESS) &&\n\t\tast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDF, ASTDP_HPD) &&\n\t\tast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE5,\n\t\t\t\t\t\t\t\tASTDP_HOST_EDID_READ_DONE_MASK))) {\n\t\tgoto err_astdp_edid_not_ready;\n\t}\n\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE5, (u8) ~ASTDP_HOST_EDID_READ_DONE_MASK,\n\t\t\t\t\t\t\t0x00);\n\n\tfor (i = 0; i < 32; i++) {\n\t\t \n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE4,\n\t\t\t\t       ASTDP_AND_CLEAR_MASK, (u8)i);\n\t\tj = 0;\n\n\t\t \n\t\twhile ((ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xD7,\n\t\t\t\tASTDP_EDID_VALID_FLAG_MASK) != 0x01) ||\n\t\t\t(ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xD6,\n\t\t\t\t\t\tASTDP_EDID_READ_POINTER_MASK) != i)) {\n\t\t\t \n\t\t\tmdelay(j+1);\n\n\t\t\tif (!(ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xD1,\n\t\t\t\t\t\t\tASTDP_MCU_FW_EXECUTING) &&\n\t\t\t\tast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDC,\n\t\t\t\t\t\t\tASTDP_LINK_SUCCESS) &&\n\t\t\t\tast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDF, ASTDP_HPD))) {\n\t\t\t\tgoto err_astdp_jump_out_loop_of_edid;\n\t\t\t}\n\n\t\t\tj++;\n\t\t\tif (j > 200)\n\t\t\t\tgoto err_astdp_jump_out_loop_of_edid;\n\t\t}\n\n\t\t*(ediddata) = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT,\n\t\t\t\t\t\t\t0xD8, ASTDP_EDID_READ_DATA_MASK);\n\t\t*(ediddata + 1) = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xD9,\n\t\t\t\t\t\t\t\tASTDP_EDID_READ_DATA_MASK);\n\t\t*(ediddata + 2) = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDA,\n\t\t\t\t\t\t\t\tASTDP_EDID_READ_DATA_MASK);\n\t\t*(ediddata + 3) = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDB,\n\t\t\t\t\t\t\t\tASTDP_EDID_READ_DATA_MASK);\n\n\t\tif (i == 31) {\n\t\t\t \n\t\t\t*(ediddata + 3) = *(ediddata + 3) + *(ediddata + 2);\n\t\t\t*(ediddata + 2) = 0;\n\t\t}\n\n\t\tediddata += 4;\n\t}\n\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE5, (u8) ~ASTDP_HOST_EDID_READ_DONE_MASK,\n\t\t\t\t\t\t\tASTDP_HOST_EDID_READ_DONE);\n\n\treturn 0;\n\nerr_astdp_jump_out_loop_of_edid:\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE5,\n\t\t\t\t\t\t\t(u8) ~ASTDP_HOST_EDID_READ_DONE_MASK,\n\t\t\t\t\t\t\tASTDP_HOST_EDID_READ_DONE);\n\treturn (~(j+256) + 1);\n\nerr_astdp_edid_not_ready:\n\tif (!(ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xD1, ASTDP_MCU_FW_EXECUTING)))\n\t\treturn (~0xD1 + 1);\n\tif (!(ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDC, ASTDP_LINK_SUCCESS)))\n\t\treturn (~0xDC + 1);\n\tif (!(ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDF, ASTDP_HPD)))\n\t\treturn (~0xDF + 1);\n\tif (!(ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE5, ASTDP_HOST_EDID_READ_DONE_MASK)))\n\t\treturn (~0xE5 + 1);\n\n\treturn\t0;\n}\n\n \nvoid ast_dp_launch(struct drm_device *dev)\n{\n\tu32 i = 0;\n\tu8 bDPExecute = 1;\n\tstruct ast_device *ast = to_ast_device(dev);\n\n\t\n\twhile (ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xD1, ASTDP_MCU_FW_EXECUTING) !=\n\t\tASTDP_MCU_FW_EXECUTING) {\n\t\ti++;\n\t\t\n\t\tmsleep(100);\n\n\t\tif (i >= 10) {\n\t\t\t\n\t\t\tbDPExecute = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!bDPExecute)\n\t\tdrm_err(dev, \"Wait DPMCU executing timeout\\n\");\n\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE5,\n\t\t\t       (u8) ~ASTDP_HOST_EDID_READ_DONE_MASK,\n\t\t\t       ASTDP_HOST_EDID_READ_DONE);\n}\n\n\n\nvoid ast_dp_power_on_off(struct drm_device *dev, bool on)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\t\n\tu8 bE3 = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE3, AST_DP_VIDEO_ENABLE);\n\n\t\n\tif (!on)\n\t\tbE3 |= AST_DP_PHY_SLEEP;\n\n\t\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE3, (u8) ~AST_DP_PHY_SLEEP, bE3);\n}\n\n\n\nvoid ast_dp_set_on_off(struct drm_device *dev, bool on)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu8 video_on_off = on;\n\n\t\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE3, (u8) ~AST_DP_VIDEO_ENABLE, on);\n\n\t\n\tif (ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDC, ASTDP_LINK_SUCCESS) &&\n\t\tast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDF, ASTDP_HPD)) {\n\t\tvideo_on_off <<= 4;\n\t\twhile (ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xDF,\n\t\t\t\t\t\tASTDP_MIRROR_VIDEO_ENABLE) != video_on_off) {\n\t\t\t\n\t\t\tmdelay(1);\n\t\t}\n\t}\n}\n\nvoid ast_dp_set_mode(struct drm_crtc *crtc, struct ast_vbios_mode_info *vbios_mode)\n{\n\tstruct ast_device *ast = to_ast_device(crtc->dev);\n\n\tu32 ulRefreshRateIndex;\n\tu8 ModeIdx;\n\n\tulRefreshRateIndex = vbios_mode->enh_table->refresh_rate_index - 1;\n\n\tswitch (crtc->mode.crtc_hdisplay) {\n\tcase 320:\n\t\tModeIdx = ASTDP_320x240_60;\n\t\tbreak;\n\tcase 400:\n\t\tModeIdx = ASTDP_400x300_60;\n\t\tbreak;\n\tcase 512:\n\t\tModeIdx = ASTDP_512x384_60;\n\t\tbreak;\n\tcase 640:\n\t\tModeIdx = (ASTDP_640x480_60 + (u8) ulRefreshRateIndex);\n\t\tbreak;\n\tcase 800:\n\t\tModeIdx = (ASTDP_800x600_56 + (u8) ulRefreshRateIndex);\n\t\tbreak;\n\tcase 1024:\n\t\tModeIdx = (ASTDP_1024x768_60 + (u8) ulRefreshRateIndex);\n\t\tbreak;\n\tcase 1152:\n\t\tModeIdx = ASTDP_1152x864_75;\n\t\tbreak;\n\tcase 1280:\n\t\tif (crtc->mode.crtc_vdisplay == 800)\n\t\t\tModeIdx = (ASTDP_1280x800_60_RB - (u8) ulRefreshRateIndex);\n\t\telse\t\t\n\t\t\tModeIdx = (ASTDP_1280x1024_60 + (u8) ulRefreshRateIndex);\n\t\tbreak;\n\tcase 1360:\n\tcase 1366:\n\t\tModeIdx = ASTDP_1366x768_60;\n\t\tbreak;\n\tcase 1440:\n\t\tModeIdx = (ASTDP_1440x900_60_RB - (u8) ulRefreshRateIndex);\n\t\tbreak;\n\tcase 1600:\n\t\tif (crtc->mode.crtc_vdisplay == 900)\n\t\t\tModeIdx = (ASTDP_1600x900_60_RB - (u8) ulRefreshRateIndex);\n\t\telse\t\t\n\t\t\tModeIdx = ASTDP_1600x1200_60;\n\t\tbreak;\n\tcase 1680:\n\t\tModeIdx = (ASTDP_1680x1050_60_RB - (u8) ulRefreshRateIndex);\n\t\tbreak;\n\tcase 1920:\n\t\tif (crtc->mode.crtc_vdisplay == 1080)\n\t\t\tModeIdx = ASTDP_1920x1080_60;\n\t\telse\t\t\n\t\t\tModeIdx = ASTDP_1920x1200_60;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE0, ASTDP_AND_CLEAR_MASK,\n\t\t\t       ASTDP_MISC0_24bpp);\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE1, ASTDP_AND_CLEAR_MASK, ASTDP_MISC1);\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xE2, ASTDP_AND_CLEAR_MASK, ModeIdx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}