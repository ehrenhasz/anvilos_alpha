{
  "module_name": "ast_post.c",
  "hash_id": "b63c19fa1d11fd56dd6ccf3ab1ef806d32e3d2346b25367863d83690180d5f1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ast/ast_post.c",
  "human_readable_source": " \n \n\n#include <linux/delay.h>\n#include <linux/pci.h>\n\n#include <drm/drm_print.h>\n\n#include \"ast_dram_tables.h\"\n#include \"ast_drv.h\"\n\nstatic void ast_post_chip_2300(struct drm_device *dev);\nstatic void ast_post_chip_2500(struct drm_device *dev);\n\nstatic const u8 extreginfo[] = { 0x0f, 0x04, 0x1c, 0xff };\nstatic const u8 extreginfo_ast2300[] = { 0x0f, 0x04, 0x1f, 0xff };\n\nstatic void\nast_set_def_ext_reg(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu8 i, index, reg;\n\tconst u8 *ext_reg_info;\n\n\t \n\tfor (i = 0x81; i <= 0x9f; i++)\n\t\tast_set_index_reg(ast, AST_IO_CRTC_PORT, i, 0x00);\n\n\tif (IS_AST_GEN4(ast) || IS_AST_GEN5(ast) || IS_AST_GEN6(ast))\n\t\text_reg_info = extreginfo_ast2300;\n\telse\n\t\text_reg_info = extreginfo;\n\n\tindex = 0xa0;\n\twhile (*ext_reg_info != 0xff) {\n\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, index, 0x00, *ext_reg_info);\n\t\tindex++;\n\t\text_reg_info++;\n\t}\n\n\t \n\t \n\n\t \n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x8c, 0x00, 0x01);\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x00, 0x00);\n\n\t \n\treg = 0x04;\n\tif (IS_AST_GEN4(ast) || IS_AST_GEN5(ast) || IS_AST_GEN6(ast))\n\t\treg |= 0x20;\n\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb6, 0xff, reg);\n}\n\nu32 ast_mindwm(struct ast_device *ast, u32 r)\n{\n\tuint32_t data;\n\n\tast_write32(ast, 0xf004, r & 0xffff0000);\n\tast_write32(ast, 0xf000, 0x1);\n\n\tdo {\n\t\tdata = ast_read32(ast, 0xf004) & 0xffff0000;\n\t} while (data != (r & 0xffff0000));\n\treturn ast_read32(ast, 0x10000 + (r & 0x0000ffff));\n}\n\nvoid ast_moutdwm(struct ast_device *ast, u32 r, u32 v)\n{\n\tuint32_t data;\n\tast_write32(ast, 0xf004, r & 0xffff0000);\n\tast_write32(ast, 0xf000, 0x1);\n\tdo {\n\t\tdata = ast_read32(ast, 0xf004) & 0xffff0000;\n\t} while (data != (r & 0xffff0000));\n\tast_write32(ast, 0x10000 + (r & 0x0000ffff), v);\n}\n\n \n#define CBR_SIZE_AST2150\t     ((16 << 10) - 1)\n#define CBR_PASSNUM_AST2150          5\n#define CBR_THRESHOLD_AST2150        10\n#define CBR_THRESHOLD2_AST2150       10\n#define TIMEOUT_AST2150              5000000\n\n#define CBR_PATNUM_AST2150           8\n\nstatic const u32 pattern_AST2150[14] = {\n\t0xFF00FF00,\n\t0xCC33CC33,\n\t0xAA55AA55,\n\t0xFFFE0001,\n\t0x683501FE,\n\t0x0F1929B0,\n\t0x2D0B4346,\n\t0x60767F02,\n\t0x6FBE36A6,\n\t0x3A253035,\n\t0x3019686D,\n\t0x41C6167E,\n\t0x620152BF,\n\t0x20F050E0\n};\n\nstatic u32 mmctestburst2_ast2150(struct ast_device *ast, u32 datagen)\n{\n\tu32 data, timeout;\n\n\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\tast_moutdwm(ast, 0x1e6e0070, 0x00000001 | (datagen << 3));\n\ttimeout = 0;\n\tdo {\n\t\tdata = ast_mindwm(ast, 0x1e6e0070) & 0x40;\n\t\tif (++timeout > TIMEOUT_AST2150) {\n\t\t\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\t\t\treturn 0xffffffff;\n\t\t}\n\t} while (!data);\n\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\tast_moutdwm(ast, 0x1e6e0070, 0x00000003 | (datagen << 3));\n\ttimeout = 0;\n\tdo {\n\t\tdata = ast_mindwm(ast, 0x1e6e0070) & 0x40;\n\t\tif (++timeout > TIMEOUT_AST2150) {\n\t\t\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\t\t\treturn 0xffffffff;\n\t\t}\n\t} while (!data);\n\tdata = (ast_mindwm(ast, 0x1e6e0070) & 0x80) >> 7;\n\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\treturn data;\n}\n\n#if 0  \nstatic u32 mmctestsingle2_ast2150(struct ast_device *ast, u32 datagen)\n{\n\tu32 data, timeout;\n\n\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\tast_moutdwm(ast, 0x1e6e0070, 0x00000005 | (datagen << 3));\n\ttimeout = 0;\n\tdo {\n\t\tdata = ast_mindwm(ast, 0x1e6e0070) & 0x40;\n\t\tif (++timeout > TIMEOUT_AST2150) {\n\t\t\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\t\t\treturn 0xffffffff;\n\t\t}\n\t} while (!data);\n\tdata = (ast_mindwm(ast, 0x1e6e0070) & 0x80) >> 7;\n\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\treturn data;\n}\n#endif\n\nstatic int cbrtest_ast2150(struct ast_device *ast)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tif (mmctestburst2_ast2150(ast, i))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int cbrscan_ast2150(struct ast_device *ast, int busw)\n{\n\tu32 patcnt, loop;\n\n\tfor (patcnt = 0; patcnt < CBR_PATNUM_AST2150; patcnt++) {\n\t\tast_moutdwm(ast, 0x1e6e007c, pattern_AST2150[patcnt]);\n\t\tfor (loop = 0; loop < CBR_PASSNUM_AST2150; loop++) {\n\t\t\tif (cbrtest_ast2150(ast))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (loop == CBR_PASSNUM_AST2150)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nstatic void cbrdlli_ast2150(struct ast_device *ast, int busw)\n{\n\tu32 dll_min[4], dll_max[4], dlli, data, passcnt;\n\ncbr_start:\n\tdll_min[0] = dll_min[1] = dll_min[2] = dll_min[3] = 0xff;\n\tdll_max[0] = dll_max[1] = dll_max[2] = dll_max[3] = 0x0;\n\tpasscnt = 0;\n\n\tfor (dlli = 0; dlli < 100; dlli++) {\n\t\tast_moutdwm(ast, 0x1e6e0068, dlli | (dlli << 8) | (dlli << 16) | (dlli << 24));\n\t\tdata = cbrscan_ast2150(ast, busw);\n\t\tif (data != 0) {\n\t\t\tif (data & 0x1) {\n\t\t\t\tif (dll_min[0] > dlli)\n\t\t\t\t\tdll_min[0] = dlli;\n\t\t\t\tif (dll_max[0] < dlli)\n\t\t\t\t\tdll_max[0] = dlli;\n\t\t\t}\n\t\t\tpasscnt++;\n\t\t} else if (passcnt >= CBR_THRESHOLD_AST2150)\n\t\t\tgoto cbr_start;\n\t}\n\tif (dll_max[0] == 0 || (dll_max[0]-dll_min[0]) < CBR_THRESHOLD_AST2150)\n\t\tgoto cbr_start;\n\n\tdlli = dll_min[0] + (((dll_max[0] - dll_min[0]) * 7) >> 4);\n\tast_moutdwm(ast, 0x1e6e0068, dlli | (dlli << 8) | (dlli << 16) | (dlli << 24));\n}\n\n\n\nstatic void ast_init_dram_reg(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu8 j;\n\tu32 data, temp, i;\n\tconst struct ast_dramstruct *dram_reg_info;\n\n\tj = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\n\n\tif ((j & 0x80) == 0) {  \n\t\tif (IS_AST_GEN1(ast)) {\n\t\t\tdram_reg_info = ast2000_dram_table_data;\n\t\t\tast_write32(ast, 0xf004, 0x1e6e0000);\n\t\t\tast_write32(ast, 0xf000, 0x1);\n\t\t\tast_write32(ast, 0x10100, 0xa8);\n\n\t\t\tdo {\n\t\t\t\t;\n\t\t\t} while (ast_read32(ast, 0x10100) != 0xa8);\n\t\t} else {  \n\t\t\tif (ast->chip == AST2100 || ast->chip == AST2200)\n\t\t\t\tdram_reg_info = ast2100_dram_table_data;\n\t\t\telse\n\t\t\t\tdram_reg_info = ast1100_dram_table_data;\n\n\t\t\tast_write32(ast, 0xf004, 0x1e6e0000);\n\t\t\tast_write32(ast, 0xf000, 0x1);\n\t\t\tast_write32(ast, 0x12000, 0x1688A8A8);\n\t\t\tdo {\n\t\t\t\t;\n\t\t\t} while (ast_read32(ast, 0x12000) != 0x01);\n\n\t\t\tast_write32(ast, 0x10000, 0xfc600309);\n\t\t\tdo {\n\t\t\t\t;\n\t\t\t} while (ast_read32(ast, 0x10000) != 0x01);\n\t\t}\n\n\t\twhile (dram_reg_info->index != 0xffff) {\n\t\t\tif (dram_reg_info->index == 0xff00) { \n\t\t\t\tfor (i = 0; i < 15; i++)\n\t\t\t\t\tudelay(dram_reg_info->data);\n\t\t\t} else if (dram_reg_info->index == 0x4 && !IS_AST_GEN1(ast)) {\n\t\t\t\tdata = dram_reg_info->data;\n\t\t\t\tif (ast->dram_type == AST_DRAM_1Gx16)\n\t\t\t\t\tdata = 0x00000d89;\n\t\t\t\telse if (ast->dram_type == AST_DRAM_1Gx32)\n\t\t\t\t\tdata = 0x00000c8d;\n\n\t\t\t\ttemp = ast_read32(ast, 0x12070);\n\t\t\t\ttemp &= 0xc;\n\t\t\t\ttemp <<= 2;\n\t\t\t\tast_write32(ast, 0x10000 + dram_reg_info->index, data | temp);\n\t\t\t} else\n\t\t\t\tast_write32(ast, 0x10000 + dram_reg_info->index, dram_reg_info->data);\n\t\t\tdram_reg_info++;\n\t\t}\n\n\t\t \n\t\tdata = ast_read32(ast, 0x10120);\n\t\tif (data == 0x5061) {  \n\t\t\tdata = ast_read32(ast, 0x10004);\n\t\t\tif (data & 0x40)\n\t\t\t\tcbrdlli_ast2150(ast, 16);  \n\t\t\telse\n\t\t\t\tcbrdlli_ast2150(ast, 32);  \n\t\t}\n\n\t\tswitch (AST_GEN(ast)) {\n\t\tcase 1:\n\t\t\ttemp = ast_read32(ast, 0x10140);\n\t\t\tast_write32(ast, 0x10140, temp | 0x40);\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\t\ttemp = ast_read32(ast, 0x1200c);\n\t\t\tast_write32(ast, 0x1200c, temp & 0xfffffffd);\n\t\t\ttemp = ast_read32(ast, 0x12040);\n\t\t\tast_write32(ast, 0x12040, temp | 0x40);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tdo {\n\t\tj = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\n\t} while ((j & 0x40) == 0);\n}\n\nvoid ast_post_gpu(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\n\tast_set_def_ext_reg(dev);\n\n\tif (IS_AST_GEN7(ast)) {\n\t\tif (ast->tx_chip_types & AST_TX_ASTDP_BIT)\n\t\t\tast_dp_launch(dev);\n\t} else if (ast->config_mode == ast_use_p2a) {\n\t\tif (IS_AST_GEN6(ast))\n\t\t\tast_post_chip_2500(dev);\n\t\telse if (IS_AST_GEN5(ast) || IS_AST_GEN4(ast))\n\t\t\tast_post_chip_2300(dev);\n\t\telse\n\t\t\tast_init_dram_reg(dev);\n\n\t\tast_init_3rdtx(dev);\n\t} else {\n\t\tif (ast->tx_chip_types & AST_TX_SIL164_BIT)\n\t\t\tast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa3, 0xcf, 0x80);\t \n\t}\n}\n\n \n#define AST_DDR3 0\n#define AST_DDR2 1\n\nstruct ast2300_dram_param {\n\tu32 dram_type;\n\tu32 dram_chipid;\n\tu32 dram_freq;\n\tu32 vram_size;\n\tu32 odt;\n\tu32 wodt;\n\tu32 rodt;\n\tu32 dram_config;\n\tu32 reg_PERIOD;\n\tu32 reg_MADJ;\n\tu32 reg_SADJ;\n\tu32 reg_MRS;\n\tu32 reg_EMRS;\n\tu32 reg_AC1;\n\tu32 reg_AC2;\n\tu32 reg_DQSIC;\n\tu32 reg_DRV;\n\tu32 reg_IOZ;\n\tu32 reg_DQIDLY;\n\tu32 reg_FREQ;\n\tu32 madj_max;\n\tu32 dll2_finetune_step;\n};\n\n \n#define CBR_SIZE0            ((1  << 10) - 1)\n#define CBR_SIZE1            ((4  << 10) - 1)\n#define CBR_SIZE2            ((64 << 10) - 1)\n#define CBR_PASSNUM          5\n#define CBR_PASSNUM2         5\n#define CBR_THRESHOLD        10\n#define CBR_THRESHOLD2       10\n#define TIMEOUT              5000000\n#define CBR_PATNUM           8\n\nstatic const u32 pattern[8] = {\n\t0xFF00FF00,\n\t0xCC33CC33,\n\t0xAA55AA55,\n\t0x88778877,\n\t0x92CC4D6E,\n\t0x543D3CDE,\n\t0xF1E843C7,\n\t0x7C61D253\n};\n\nstatic bool mmc_test(struct ast_device *ast, u32 datagen, u8 test_ctl)\n{\n\tu32 data, timeout;\n\n\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\tast_moutdwm(ast, 0x1e6e0070, (datagen << 3) | test_ctl);\n\ttimeout = 0;\n\tdo {\n\t\tdata = ast_mindwm(ast, 0x1e6e0070) & 0x3000;\n\t\tif (data & 0x2000)\n\t\t\treturn false;\n\t\tif (++timeout > TIMEOUT) {\n\t\t\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\t\t\treturn false;\n\t\t}\n\t} while (!data);\n\tast_moutdwm(ast, 0x1e6e0070, 0x0);\n\treturn true;\n}\n\nstatic u32 mmc_test2(struct ast_device *ast, u32 datagen, u8 test_ctl)\n{\n\tu32 data, timeout;\n\n\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\tast_moutdwm(ast, 0x1e6e0070, (datagen << 3) | test_ctl);\n\ttimeout = 0;\n\tdo {\n\t\tdata = ast_mindwm(ast, 0x1e6e0070) & 0x1000;\n\t\tif (++timeout > TIMEOUT) {\n\t\t\tast_moutdwm(ast, 0x1e6e0070, 0x0);\n\t\t\treturn 0xffffffff;\n\t\t}\n\t} while (!data);\n\tdata = ast_mindwm(ast, 0x1e6e0078);\n\tdata = (data | (data >> 16)) & 0xffff;\n\tast_moutdwm(ast, 0x1e6e0070, 0x00000000);\n\treturn data;\n}\n\n\nstatic bool mmc_test_burst(struct ast_device *ast, u32 datagen)\n{\n\treturn mmc_test(ast, datagen, 0xc1);\n}\n\nstatic u32 mmc_test_burst2(struct ast_device *ast, u32 datagen)\n{\n\treturn mmc_test2(ast, datagen, 0x41);\n}\n\nstatic bool mmc_test_single(struct ast_device *ast, u32 datagen)\n{\n\treturn mmc_test(ast, datagen, 0xc5);\n}\n\nstatic u32 mmc_test_single2(struct ast_device *ast, u32 datagen)\n{\n\treturn mmc_test2(ast, datagen, 0x05);\n}\n\nstatic bool mmc_test_single_2500(struct ast_device *ast, u32 datagen)\n{\n\treturn mmc_test(ast, datagen, 0x85);\n}\n\nstatic int cbr_test(struct ast_device *ast)\n{\n\tu32 data;\n\tint i;\n\tdata = mmc_test_single2(ast, 0);\n\tif ((data & 0xff) && (data & 0xff00))\n\t\treturn 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tdata = mmc_test_burst2(ast, i);\n\t\tif ((data & 0xff) && (data & 0xff00))\n\t\t\treturn 0;\n\t}\n\tif (!data)\n\t\treturn 3;\n\telse if (data & 0xff)\n\t\treturn 2;\n\treturn 1;\n}\n\nstatic int cbr_scan(struct ast_device *ast)\n{\n\tu32 data, data2, patcnt, loop;\n\n\tdata2 = 3;\n\tfor (patcnt = 0; patcnt < CBR_PATNUM; patcnt++) {\n\t\tast_moutdwm(ast, 0x1e6e007c, pattern[patcnt]);\n\t\tfor (loop = 0; loop < CBR_PASSNUM2; loop++) {\n\t\t\tif ((data = cbr_test(ast)) != 0) {\n\t\t\t\tdata2 &= data;\n\t\t\t\tif (!data2)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (loop == CBR_PASSNUM2)\n\t\t\treturn 0;\n\t}\n\treturn data2;\n}\n\nstatic u32 cbr_test2(struct ast_device *ast)\n{\n\tu32 data;\n\n\tdata = mmc_test_burst2(ast, 0);\n\tif (data == 0xffff)\n\t\treturn 0;\n\tdata |= mmc_test_single2(ast, 0);\n\tif (data == 0xffff)\n\t\treturn 0;\n\n\treturn ~data & 0xffff;\n}\n\nstatic u32 cbr_scan2(struct ast_device *ast)\n{\n\tu32 data, data2, patcnt, loop;\n\n\tdata2 = 0xffff;\n\tfor (patcnt = 0; patcnt < CBR_PATNUM; patcnt++) {\n\t\tast_moutdwm(ast, 0x1e6e007c, pattern[patcnt]);\n\t\tfor (loop = 0; loop < CBR_PASSNUM2; loop++) {\n\t\t\tif ((data = cbr_test2(ast)) != 0) {\n\t\t\t\tdata2 &= data;\n\t\t\t\tif (!data2)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (loop == CBR_PASSNUM2)\n\t\t\treturn 0;\n\t}\n\treturn data2;\n}\n\nstatic bool cbr_test3(struct ast_device *ast)\n{\n\tif (!mmc_test_burst(ast, 0))\n\t\treturn false;\n\tif (!mmc_test_single(ast, 0))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool cbr_scan3(struct ast_device *ast)\n{\n\tu32 patcnt, loop;\n\n\tfor (patcnt = 0; patcnt < CBR_PATNUM; patcnt++) {\n\t\tast_moutdwm(ast, 0x1e6e007c, pattern[patcnt]);\n\t\tfor (loop = 0; loop < 2; loop++) {\n\t\t\tif (cbr_test3(ast))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (loop == 2)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool finetuneDQI_L(struct ast_device *ast, struct ast2300_dram_param *param)\n{\n\tu32 gold_sadj[2], dllmin[16], dllmax[16], dlli, data, cnt, mask, passcnt, retry = 0;\n\tbool status = false;\nFINETUNE_START:\n\tfor (cnt = 0; cnt < 16; cnt++) {\n\t\tdllmin[cnt] = 0xff;\n\t\tdllmax[cnt] = 0x0;\n\t}\n\tpasscnt = 0;\n\tfor (dlli = 0; dlli < 76; dlli++) {\n\t\tast_moutdwm(ast, 0x1E6E0068, 0x00001400 | (dlli << 16) | (dlli << 24));\n\t\tast_moutdwm(ast, 0x1E6E0074, CBR_SIZE1);\n\t\tdata = cbr_scan2(ast);\n\t\tif (data != 0) {\n\t\t\tmask = 0x00010001;\n\t\t\tfor (cnt = 0; cnt < 16; cnt++) {\n\t\t\t\tif (data & mask) {\n\t\t\t\t\tif (dllmin[cnt] > dlli) {\n\t\t\t\t\t\tdllmin[cnt] = dlli;\n\t\t\t\t\t}\n\t\t\t\t\tif (dllmax[cnt] < dlli) {\n\t\t\t\t\t\tdllmax[cnt] = dlli;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmask <<= 1;\n\t\t\t}\n\t\t\tpasscnt++;\n\t\t} else if (passcnt >= CBR_THRESHOLD2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tgold_sadj[0] = 0x0;\n\tpasscnt = 0;\n\tfor (cnt = 0; cnt < 16; cnt++) {\n\t\tif ((dllmax[cnt] > dllmin[cnt]) && ((dllmax[cnt] - dllmin[cnt]) >= CBR_THRESHOLD2)) {\n\t\t\tgold_sadj[0] += dllmin[cnt];\n\t\t\tpasscnt++;\n\t\t}\n\t}\n\tif (retry++ > 10)\n\t\tgoto FINETUNE_DONE;\n\tif (passcnt != 16) {\n\t\tgoto FINETUNE_START;\n\t}\n\tstatus = true;\nFINETUNE_DONE:\n\tgold_sadj[0] = gold_sadj[0] >> 4;\n\tgold_sadj[1] = gold_sadj[0];\n\n\tdata = 0;\n\tfor (cnt = 0; cnt < 8; cnt++) {\n\t\tdata >>= 3;\n\t\tif ((dllmax[cnt] > dllmin[cnt]) && ((dllmax[cnt] - dllmin[cnt]) >= CBR_THRESHOLD2)) {\n\t\t\tdlli = dllmin[cnt];\n\t\t\tif (gold_sadj[0] >= dlli) {\n\t\t\t\tdlli = ((gold_sadj[0] - dlli) * 19) >> 5;\n\t\t\t\tif (dlli > 3) {\n\t\t\t\t\tdlli = 3;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdlli = ((dlli - gold_sadj[0]) * 19) >> 5;\n\t\t\t\tif (dlli > 4) {\n\t\t\t\t\tdlli = 4;\n\t\t\t\t}\n\t\t\t\tdlli = (8 - dlli) & 0x7;\n\t\t\t}\n\t\t\tdata |= dlli << 21;\n\t\t}\n\t}\n\tast_moutdwm(ast, 0x1E6E0080, data);\n\n\tdata = 0;\n\tfor (cnt = 8; cnt < 16; cnt++) {\n\t\tdata >>= 3;\n\t\tif ((dllmax[cnt] > dllmin[cnt]) && ((dllmax[cnt] - dllmin[cnt]) >= CBR_THRESHOLD2)) {\n\t\t\tdlli = dllmin[cnt];\n\t\t\tif (gold_sadj[1] >= dlli) {\n\t\t\t\tdlli = ((gold_sadj[1] - dlli) * 19) >> 5;\n\t\t\t\tif (dlli > 3) {\n\t\t\t\t\tdlli = 3;\n\t\t\t\t} else {\n\t\t\t\t\tdlli = (dlli - 1) & 0x7;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdlli = ((dlli - gold_sadj[1]) * 19) >> 5;\n\t\t\t\tdlli += 1;\n\t\t\t\tif (dlli > 4) {\n\t\t\t\t\tdlli = 4;\n\t\t\t\t}\n\t\t\t\tdlli = (8 - dlli) & 0x7;\n\t\t\t}\n\t\t\tdata |= dlli << 21;\n\t\t}\n\t}\n\tast_moutdwm(ast, 0x1E6E0084, data);\n\treturn status;\n}  \n\nstatic void finetuneDQSI(struct ast_device *ast)\n{\n\tu32 dlli, dqsip, dqidly;\n\tu32 reg_mcr18, reg_mcr0c, passcnt[2], diff;\n\tu32 g_dqidly, g_dqsip, g_margin, g_side;\n\tu16 pass[32][2][2];\n\tchar tag[2][76];\n\n\t \n\treg_mcr0c  = ast_mindwm(ast, 0x1E6E000C);\n\treg_mcr18  = ast_mindwm(ast, 0x1E6E0018);\n\treg_mcr18 &= 0x0000ffff;\n\tast_moutdwm(ast, 0x1E6E0018, reg_mcr18);\n\n\tfor (dlli = 0; dlli < 76; dlli++) {\n\t\ttag[0][dlli] = 0x0;\n\t\ttag[1][dlli] = 0x0;\n\t}\n\tfor (dqidly = 0; dqidly < 32; dqidly++) {\n\t\tpass[dqidly][0][0] = 0xff;\n\t\tpass[dqidly][0][1] = 0x0;\n\t\tpass[dqidly][1][0] = 0xff;\n\t\tpass[dqidly][1][1] = 0x0;\n\t}\n\tfor (dqidly = 0; dqidly < 32; dqidly++) {\n\t\tpasscnt[0] = passcnt[1] = 0;\n\t\tfor (dqsip = 0; dqsip < 2; dqsip++) {\n\t\t\tast_moutdwm(ast, 0x1E6E000C, 0);\n\t\t\tast_moutdwm(ast, 0x1E6E0018, reg_mcr18 | (dqidly << 16) | (dqsip << 23));\n\t\t\tast_moutdwm(ast, 0x1E6E000C, reg_mcr0c);\n\t\t\tfor (dlli = 0; dlli < 76; dlli++) {\n\t\t\t\tast_moutdwm(ast, 0x1E6E0068, 0x00001300 | (dlli << 16) | (dlli << 24));\n\t\t\t\tast_moutdwm(ast, 0x1E6E0070, 0);\n\t\t\t\tast_moutdwm(ast, 0x1E6E0074, CBR_SIZE0);\n\t\t\t\tif (cbr_scan3(ast)) {\n\t\t\t\t\tif (dlli == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tpasscnt[dqsip]++;\n\t\t\t\t\ttag[dqsip][dlli] = 'P';\n\t\t\t\t\tif (dlli < pass[dqidly][dqsip][0])\n\t\t\t\t\t\tpass[dqidly][dqsip][0] = (u16) dlli;\n\t\t\t\t\tif (dlli > pass[dqidly][dqsip][1])\n\t\t\t\t\t\tpass[dqidly][dqsip][1] = (u16) dlli;\n\t\t\t\t} else if (passcnt[dqsip] >= 5)\n\t\t\t\t\tbreak;\n\t\t\t\telse {\n\t\t\t\t\tpass[dqidly][dqsip][0] = 0xff;\n\t\t\t\t\tpass[dqidly][dqsip][1] = 0x0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (passcnt[0] == 0 && passcnt[1] == 0)\n\t\t\tdqidly++;\n\t}\n\t \n\tg_dqidly = g_dqsip = g_margin = g_side = 0;\n\n\tfor (dqidly = 0; dqidly < 32; dqidly++) {\n\t\tfor (dqsip = 0; dqsip < 2; dqsip++) {\n\t\t\tif (pass[dqidly][dqsip][0] > pass[dqidly][dqsip][1])\n\t\t\t\tcontinue;\n\t\t\tdiff = pass[dqidly][dqsip][1] - pass[dqidly][dqsip][0];\n\t\t\tif ((diff+2) < g_margin)\n\t\t\t\tcontinue;\n\t\t\tpasscnt[0] = passcnt[1] = 0;\n\t\t\tfor (dlli = pass[dqidly][dqsip][0]; dlli > 0  && tag[dqsip][dlli] != 0; dlli--, passcnt[0]++);\n\t\t\tfor (dlli = pass[dqidly][dqsip][1]; dlli < 76 && tag[dqsip][dlli] != 0; dlli++, passcnt[1]++);\n\t\t\tif (passcnt[0] > passcnt[1])\n\t\t\t\tpasscnt[0] = passcnt[1];\n\t\t\tpasscnt[1] = 0;\n\t\t\tif (passcnt[0] > g_side)\n\t\t\t\tpasscnt[1] = passcnt[0] - g_side;\n\t\t\tif (diff > (g_margin+1) && (passcnt[1] > 0 || passcnt[0] > 8)) {\n\t\t\t\tg_margin = diff;\n\t\t\t\tg_dqidly = dqidly;\n\t\t\t\tg_dqsip  = dqsip;\n\t\t\t\tg_side   = passcnt[0];\n\t\t\t} else if (passcnt[1] > 1 && g_side < 8) {\n\t\t\t\tif (diff > g_margin)\n\t\t\t\t\tg_margin = diff;\n\t\t\t\tg_dqidly = dqidly;\n\t\t\t\tg_dqsip  = dqsip;\n\t\t\t\tg_side   = passcnt[0];\n\t\t\t}\n\t\t}\n\t}\n\treg_mcr18 = reg_mcr18 | (g_dqidly << 16) | (g_dqsip << 23);\n\tast_moutdwm(ast, 0x1E6E0018, reg_mcr18);\n\n}\nstatic bool cbr_dll2(struct ast_device *ast, struct ast2300_dram_param *param)\n{\n\tu32 dllmin[2], dllmax[2], dlli, data, passcnt, retry = 0;\n\tbool status = false;\n\n\tfinetuneDQSI(ast);\n\tif (finetuneDQI_L(ast, param) == false)\n\t\treturn status;\n\nCBR_START2:\n\tdllmin[0] = dllmin[1] = 0xff;\n\tdllmax[0] = dllmax[1] = 0x0;\n\tpasscnt = 0;\n\tfor (dlli = 0; dlli < 76; dlli++) {\n\t\tast_moutdwm(ast, 0x1E6E0068, 0x00001300 | (dlli << 16) | (dlli << 24));\n\t\tast_moutdwm(ast, 0x1E6E0074, CBR_SIZE2);\n\t\tdata = cbr_scan(ast);\n\t\tif (data != 0) {\n\t\t\tif (data & 0x1) {\n\t\t\t\tif (dllmin[0] > dlli) {\n\t\t\t\t\tdllmin[0] = dlli;\n\t\t\t\t}\n\t\t\t\tif (dllmax[0] < dlli) {\n\t\t\t\t\tdllmax[0] = dlli;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (data & 0x2) {\n\t\t\t\tif (dllmin[1] > dlli) {\n\t\t\t\t\tdllmin[1] = dlli;\n\t\t\t\t}\n\t\t\t\tif (dllmax[1] < dlli) {\n\t\t\t\t\tdllmax[1] = dlli;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpasscnt++;\n\t\t} else if (passcnt >= CBR_THRESHOLD) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (retry++ > 10)\n\t\tgoto CBR_DONE2;\n\tif (dllmax[0] == 0 || (dllmax[0]-dllmin[0]) < CBR_THRESHOLD) {\n\t\tgoto CBR_START2;\n\t}\n\tif (dllmax[1] == 0 || (dllmax[1]-dllmin[1]) < CBR_THRESHOLD) {\n\t\tgoto CBR_START2;\n\t}\n\tstatus = true;\nCBR_DONE2:\n\tdlli  = (dllmin[1] + dllmax[1]) >> 1;\n\tdlli <<= 8;\n\tdlli += (dllmin[0] + dllmax[0]) >> 1;\n\tast_moutdwm(ast, 0x1E6E0068, ast_mindwm(ast, 0x1E720058) | (dlli << 16));\n\treturn status;\n}  \n\nstatic void get_ddr3_info(struct ast_device *ast, struct ast2300_dram_param *param)\n{\n\tu32 trap, trap_AC2, trap_MRS;\n\n\tast_moutdwm(ast, 0x1E6E2000, 0x1688A8A8);\n\n\t \n\ttrap = (ast_mindwm(ast, 0x1E6E2070) >> 25) & 0x3;\n\ttrap_AC2  = 0x00020000 + (trap << 16);\n\ttrap_AC2 |= 0x00300000 + ((trap & 0x2) << 19);\n\ttrap_MRS  = 0x00000010 + (trap << 4);\n\ttrap_MRS |= ((trap & 0x2) << 18);\n\n\tparam->reg_MADJ       = 0x00034C4C;\n\tparam->reg_SADJ       = 0x00001800;\n\tparam->reg_DRV        = 0x000000F0;\n\tparam->reg_PERIOD     = param->dram_freq;\n\tparam->rodt           = 0;\n\n\tswitch (param->dram_freq) {\n\tcase 336:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0190);\n\t\tparam->wodt          = 0;\n\t\tparam->reg_AC1       = 0x22202725;\n\t\tparam->reg_AC2       = 0xAA007613 | trap_AC2;\n\t\tparam->reg_DQSIC     = 0x000000BA;\n\t\tparam->reg_MRS       = 0x04001400 | trap_MRS;\n\t\tparam->reg_EMRS      = 0x00000000;\n\t\tparam->reg_IOZ       = 0x00000023;\n\t\tparam->reg_DQIDLY    = 0x00000074;\n\t\tparam->reg_FREQ      = 0x00004DC0;\n\t\tparam->madj_max      = 96;\n\t\tparam->dll2_finetune_step = 3;\n\t\tswitch (param->dram_chipid) {\n\t\tdefault:\n\t\tcase AST_DRAM_512Mx16:\n\t\tcase AST_DRAM_1Gx16:\n\t\t\tparam->reg_AC2   = 0xAA007613 | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_2Gx16:\n\t\t\tparam->reg_AC2   = 0xAA00761C | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_4Gx16:\n\t\t\tparam->reg_AC2   = 0xAA007636 | trap_AC2;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase 396:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x03F1);\n\t\tparam->wodt          = 1;\n\t\tparam->reg_AC1       = 0x33302825;\n\t\tparam->reg_AC2       = 0xCC009617 | trap_AC2;\n\t\tparam->reg_DQSIC     = 0x000000E2;\n\t\tparam->reg_MRS       = 0x04001600 | trap_MRS;\n\t\tparam->reg_EMRS      = 0x00000000;\n\t\tparam->reg_IOZ       = 0x00000034;\n\t\tparam->reg_DRV       = 0x000000FA;\n\t\tparam->reg_DQIDLY    = 0x00000089;\n\t\tparam->reg_FREQ      = 0x00005040;\n\t\tparam->madj_max      = 96;\n\t\tparam->dll2_finetune_step = 4;\n\n\t\tswitch (param->dram_chipid) {\n\t\tdefault:\n\t\tcase AST_DRAM_512Mx16:\n\t\tcase AST_DRAM_1Gx16:\n\t\t\tparam->reg_AC2   = 0xCC009617 | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_2Gx16:\n\t\t\tparam->reg_AC2   = 0xCC009622 | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_4Gx16:\n\t\t\tparam->reg_AC2   = 0xCC00963F | trap_AC2;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 408:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x01F0);\n\t\tparam->wodt          = 1;\n\t\tparam->reg_AC1       = 0x33302825;\n\t\tparam->reg_AC2       = 0xCC009617 | trap_AC2;\n\t\tparam->reg_DQSIC     = 0x000000E2;\n\t\tparam->reg_MRS       = 0x04001600 | trap_MRS;\n\t\tparam->reg_EMRS      = 0x00000000;\n\t\tparam->reg_IOZ       = 0x00000023;\n\t\tparam->reg_DRV       = 0x000000FA;\n\t\tparam->reg_DQIDLY    = 0x00000089;\n\t\tparam->reg_FREQ      = 0x000050C0;\n\t\tparam->madj_max      = 96;\n\t\tparam->dll2_finetune_step = 4;\n\n\t\tswitch (param->dram_chipid) {\n\t\tdefault:\n\t\tcase AST_DRAM_512Mx16:\n\t\tcase AST_DRAM_1Gx16:\n\t\t\tparam->reg_AC2   = 0xCC009617 | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_2Gx16:\n\t\t\tparam->reg_AC2   = 0xCC009622 | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_4Gx16:\n\t\t\tparam->reg_AC2   = 0xCC00963F | trap_AC2;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase 456:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0230);\n\t\tparam->wodt          = 0;\n\t\tparam->reg_AC1       = 0x33302926;\n\t\tparam->reg_AC2       = 0xCD44961A;\n\t\tparam->reg_DQSIC     = 0x000000FC;\n\t\tparam->reg_MRS       = 0x00081830;\n\t\tparam->reg_EMRS      = 0x00000000;\n\t\tparam->reg_IOZ       = 0x00000045;\n\t\tparam->reg_DQIDLY    = 0x00000097;\n\t\tparam->reg_FREQ      = 0x000052C0;\n\t\tparam->madj_max      = 88;\n\t\tparam->dll2_finetune_step = 4;\n\t\tbreak;\n\tcase 504:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0270);\n\t\tparam->wodt          = 1;\n\t\tparam->reg_AC1       = 0x33302926;\n\t\tparam->reg_AC2       = 0xDE44A61D;\n\t\tparam->reg_DQSIC     = 0x00000117;\n\t\tparam->reg_MRS       = 0x00081A30;\n\t\tparam->reg_EMRS      = 0x00000000;\n\t\tparam->reg_IOZ       = 0x070000BB;\n\t\tparam->reg_DQIDLY    = 0x000000A0;\n\t\tparam->reg_FREQ      = 0x000054C0;\n\t\tparam->madj_max      = 79;\n\t\tparam->dll2_finetune_step = 4;\n\t\tbreak;\n\tcase 528:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0290);\n\t\tparam->wodt          = 1;\n\t\tparam->rodt          = 1;\n\t\tparam->reg_AC1       = 0x33302926;\n\t\tparam->reg_AC2       = 0xEF44B61E;\n\t\tparam->reg_DQSIC     = 0x00000125;\n\t\tparam->reg_MRS       = 0x00081A30;\n\t\tparam->reg_EMRS      = 0x00000040;\n\t\tparam->reg_DRV       = 0x000000F5;\n\t\tparam->reg_IOZ       = 0x00000023;\n\t\tparam->reg_DQIDLY    = 0x00000088;\n\t\tparam->reg_FREQ      = 0x000055C0;\n\t\tparam->madj_max      = 76;\n\t\tparam->dll2_finetune_step = 3;\n\t\tbreak;\n\tcase 576:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0140);\n\t\tparam->reg_MADJ      = 0x00136868;\n\t\tparam->reg_SADJ      = 0x00004534;\n\t\tparam->wodt          = 1;\n\t\tparam->rodt          = 1;\n\t\tparam->reg_AC1       = 0x33302A37;\n\t\tparam->reg_AC2       = 0xEF56B61E;\n\t\tparam->reg_DQSIC     = 0x0000013F;\n\t\tparam->reg_MRS       = 0x00101A50;\n\t\tparam->reg_EMRS      = 0x00000040;\n\t\tparam->reg_DRV       = 0x000000FA;\n\t\tparam->reg_IOZ       = 0x00000023;\n\t\tparam->reg_DQIDLY    = 0x00000078;\n\t\tparam->reg_FREQ      = 0x000057C0;\n\t\tparam->madj_max      = 136;\n\t\tparam->dll2_finetune_step = 3;\n\t\tbreak;\n\tcase 600:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x02E1);\n\t\tparam->reg_MADJ      = 0x00136868;\n\t\tparam->reg_SADJ      = 0x00004534;\n\t\tparam->wodt          = 1;\n\t\tparam->rodt          = 1;\n\t\tparam->reg_AC1       = 0x32302A37;\n\t\tparam->reg_AC2       = 0xDF56B61F;\n\t\tparam->reg_DQSIC     = 0x0000014D;\n\t\tparam->reg_MRS       = 0x00101A50;\n\t\tparam->reg_EMRS      = 0x00000004;\n\t\tparam->reg_DRV       = 0x000000F5;\n\t\tparam->reg_IOZ       = 0x00000023;\n\t\tparam->reg_DQIDLY    = 0x00000078;\n\t\tparam->reg_FREQ      = 0x000058C0;\n\t\tparam->madj_max      = 132;\n\t\tparam->dll2_finetune_step = 3;\n\t\tbreak;\n\tcase 624:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0160);\n\t\tparam->reg_MADJ      = 0x00136868;\n\t\tparam->reg_SADJ      = 0x00004534;\n\t\tparam->wodt          = 1;\n\t\tparam->rodt          = 1;\n\t\tparam->reg_AC1       = 0x32302A37;\n\t\tparam->reg_AC2       = 0xEF56B621;\n\t\tparam->reg_DQSIC     = 0x0000015A;\n\t\tparam->reg_MRS       = 0x02101A50;\n\t\tparam->reg_EMRS      = 0x00000004;\n\t\tparam->reg_DRV       = 0x000000F5;\n\t\tparam->reg_IOZ       = 0x00000034;\n\t\tparam->reg_DQIDLY    = 0x00000078;\n\t\tparam->reg_FREQ      = 0x000059C0;\n\t\tparam->madj_max      = 128;\n\t\tparam->dll2_finetune_step = 3;\n\t\tbreak;\n\t}  \n\n\tswitch (param->dram_chipid) {\n\tcase AST_DRAM_512Mx16:\n\t\tparam->dram_config = 0x130;\n\t\tbreak;\n\tdefault:\n\tcase AST_DRAM_1Gx16:\n\t\tparam->dram_config = 0x131;\n\t\tbreak;\n\tcase AST_DRAM_2Gx16:\n\t\tparam->dram_config = 0x132;\n\t\tbreak;\n\tcase AST_DRAM_4Gx16:\n\t\tparam->dram_config = 0x133;\n\t\tbreak;\n\t}  \n\n\tswitch (param->vram_size) {\n\tdefault:\n\tcase AST_VIDMEM_SIZE_8M:\n\t\tparam->dram_config |= 0x00;\n\t\tbreak;\n\tcase AST_VIDMEM_SIZE_16M:\n\t\tparam->dram_config |= 0x04;\n\t\tbreak;\n\tcase AST_VIDMEM_SIZE_32M:\n\t\tparam->dram_config |= 0x08;\n\t\tbreak;\n\tcase AST_VIDMEM_SIZE_64M:\n\t\tparam->dram_config |= 0x0c;\n\t\tbreak;\n\t}\n\n}\n\nstatic void ddr3_init(struct ast_device *ast, struct ast2300_dram_param *param)\n{\n\tu32 data, data2, retry = 0;\n\nddr3_init_start:\n\tast_moutdwm(ast, 0x1E6E0000, 0xFC600309);\n\tast_moutdwm(ast, 0x1E6E0018, 0x00000100);\n\tast_moutdwm(ast, 0x1E6E0024, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0034, 0x00000000);\n\tudelay(10);\n\tast_moutdwm(ast, 0x1E6E0064, param->reg_MADJ);\n\tast_moutdwm(ast, 0x1E6E0068, param->reg_SADJ);\n\tudelay(10);\n\tast_moutdwm(ast, 0x1E6E0064, param->reg_MADJ | 0xC0000);\n\tudelay(10);\n\n\tast_moutdwm(ast, 0x1E6E0004, param->dram_config);\n\tast_moutdwm(ast, 0x1E6E0008, 0x90040f);\n\tast_moutdwm(ast, 0x1E6E0010, param->reg_AC1);\n\tast_moutdwm(ast, 0x1E6E0014, param->reg_AC2);\n\tast_moutdwm(ast, 0x1E6E0020, param->reg_DQSIC);\n\tast_moutdwm(ast, 0x1E6E0080, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0084, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0088, param->reg_DQIDLY);\n\tast_moutdwm(ast, 0x1E6E0018, 0x4000A170);\n\tast_moutdwm(ast, 0x1E6E0018, 0x00002370);\n\tast_moutdwm(ast, 0x1E6E0038, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0040, 0xFF444444);\n\tast_moutdwm(ast, 0x1E6E0044, 0x22222222);\n\tast_moutdwm(ast, 0x1E6E0048, 0x22222222);\n\tast_moutdwm(ast, 0x1E6E004C, 0x00000002);\n\tast_moutdwm(ast, 0x1E6E0050, 0x80000000);\n\tast_moutdwm(ast, 0x1E6E0050, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0054, 0);\n\tast_moutdwm(ast, 0x1E6E0060, param->reg_DRV);\n\tast_moutdwm(ast, 0x1E6E006C, param->reg_IOZ);\n\tast_moutdwm(ast, 0x1E6E0070, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0074, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0078, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E007C, 0x00000000);\n\t \n\tdo {\n\t\tdata = ast_mindwm(ast, 0x1E6E001C);\n\t} while (!(data & 0x08000000));\n\tdata = ast_mindwm(ast, 0x1E6E001C);\n\tdata = (data >> 8) & 0xff;\n\twhile ((data & 0x08) || ((data & 0x7) < 2) || (data < 4)) {\n\t\tdata2 = (ast_mindwm(ast, 0x1E6E0064) & 0xfff3ffff) + 4;\n\t\tif ((data2 & 0xff) > param->madj_max) {\n\t\t\tbreak;\n\t\t}\n\t\tast_moutdwm(ast, 0x1E6E0064, data2);\n\t\tif (data2 & 0x00100000) {\n\t\t\tdata2 = ((data2 & 0xff) >> 3) + 3;\n\t\t} else {\n\t\t\tdata2 = ((data2 & 0xff) >> 2) + 5;\n\t\t}\n\t\tdata = ast_mindwm(ast, 0x1E6E0068) & 0xffff00ff;\n\t\tdata2 += data & 0xff;\n\t\tdata = data | (data2 << 8);\n\t\tast_moutdwm(ast, 0x1E6E0068, data);\n\t\tudelay(10);\n\t\tast_moutdwm(ast, 0x1E6E0064, ast_mindwm(ast, 0x1E6E0064) | 0xC0000);\n\t\tudelay(10);\n\t\tdata = ast_mindwm(ast, 0x1E6E0018) & 0xfffff1ff;\n\t\tast_moutdwm(ast, 0x1E6E0018, data);\n\t\tdata = data | 0x200;\n\t\tast_moutdwm(ast, 0x1E6E0018, data);\n\t\tdo {\n\t\t\tdata = ast_mindwm(ast, 0x1E6E001C);\n\t\t} while (!(data & 0x08000000));\n\n\t\tdata = ast_mindwm(ast, 0x1E6E001C);\n\t\tdata = (data >> 8) & 0xff;\n\t}\n\tast_moutdwm(ast, 0x1E720058, ast_mindwm(ast, 0x1E6E0068) & 0xffff);\n\tdata = ast_mindwm(ast, 0x1E6E0018) | 0xC00;\n\tast_moutdwm(ast, 0x1E6E0018, data);\n\n\tast_moutdwm(ast, 0x1E6E0034, 0x00000001);\n\tast_moutdwm(ast, 0x1E6E000C, 0x00000040);\n\tudelay(50);\n\t \n\tast_moutdwm(ast, 0x1E6E002C, param->reg_MRS | 0x100);\n\tast_moutdwm(ast, 0x1E6E0030, param->reg_EMRS);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000005);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000007);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000003);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000001);\n\tast_moutdwm(ast, 0x1E6E002C, param->reg_MRS);\n\tast_moutdwm(ast, 0x1E6E000C, 0x00005C08);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000001);\n\n\tast_moutdwm(ast, 0x1E6E000C, 0x00005C01);\n\tdata = 0;\n\tif (param->wodt) {\n\t\tdata = 0x300;\n\t}\n\tif (param->rodt) {\n\t\tdata = data | 0x3000 | ((param->reg_AC2 & 0x60000) >> 3);\n\t}\n\tast_moutdwm(ast, 0x1E6E0034, data | 0x3);\n\n\t \n\tif ((cbr_dll2(ast, param) == false) && (retry++ < 10))\n\t\tgoto ddr3_init_start;\n\n\tast_moutdwm(ast, 0x1E6E0120, param->reg_FREQ);\n\t \n#ifdef ECC\n\tast_moutdwm(ast, 0x1E6E007C, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0070, 0x221);\n\tdo {\n\t\tdata = ast_mindwm(ast, 0x1E6E0070);\n\t} while (!(data & 0x00001000));\n\tast_moutdwm(ast, 0x1E6E0070, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0050, 0x80000000);\n\tast_moutdwm(ast, 0x1E6E0050, 0x00000000);\n#endif\n\n\n}\n\nstatic void get_ddr2_info(struct ast_device *ast, struct ast2300_dram_param *param)\n{\n\tu32 trap, trap_AC2, trap_MRS;\n\n\tast_moutdwm(ast, 0x1E6E2000, 0x1688A8A8);\n\n\t \n\ttrap = (ast_mindwm(ast, 0x1E6E2070) >> 25) & 0x3;\n\ttrap_AC2  = (trap << 20) | (trap << 16);\n\ttrap_AC2 += 0x00110000;\n\ttrap_MRS  = 0x00000040 | (trap << 4);\n\n\n\tparam->reg_MADJ       = 0x00034C4C;\n\tparam->reg_SADJ       = 0x00001800;\n\tparam->reg_DRV        = 0x000000F0;\n\tparam->reg_PERIOD     = param->dram_freq;\n\tparam->rodt           = 0;\n\n\tswitch (param->dram_freq) {\n\tcase 264:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0130);\n\t\tparam->wodt          = 0;\n\t\tparam->reg_AC1       = 0x11101513;\n\t\tparam->reg_AC2       = 0x78117011;\n\t\tparam->reg_DQSIC     = 0x00000092;\n\t\tparam->reg_MRS       = 0x00000842;\n\t\tparam->reg_EMRS      = 0x00000000;\n\t\tparam->reg_DRV       = 0x000000F0;\n\t\tparam->reg_IOZ       = 0x00000034;\n\t\tparam->reg_DQIDLY    = 0x0000005A;\n\t\tparam->reg_FREQ      = 0x00004AC0;\n\t\tparam->madj_max      = 138;\n\t\tparam->dll2_finetune_step = 3;\n\t\tbreak;\n\tcase 336:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0190);\n\t\tparam->wodt          = 1;\n\t\tparam->reg_AC1       = 0x22202613;\n\t\tparam->reg_AC2       = 0xAA009016 | trap_AC2;\n\t\tparam->reg_DQSIC     = 0x000000BA;\n\t\tparam->reg_MRS       = 0x00000A02 | trap_MRS;\n\t\tparam->reg_EMRS      = 0x00000040;\n\t\tparam->reg_DRV       = 0x000000FA;\n\t\tparam->reg_IOZ       = 0x00000034;\n\t\tparam->reg_DQIDLY    = 0x00000074;\n\t\tparam->reg_FREQ      = 0x00004DC0;\n\t\tparam->madj_max      = 96;\n\t\tparam->dll2_finetune_step = 3;\n\t\tswitch (param->dram_chipid) {\n\t\tdefault:\n\t\tcase AST_DRAM_512Mx16:\n\t\t\tparam->reg_AC2   = 0xAA009012 | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_1Gx16:\n\t\t\tparam->reg_AC2   = 0xAA009016 | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_2Gx16:\n\t\t\tparam->reg_AC2   = 0xAA009023 | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_4Gx16:\n\t\t\tparam->reg_AC2   = 0xAA00903B | trap_AC2;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase 396:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x03F1);\n\t\tparam->wodt          = 1;\n\t\tparam->rodt          = 0;\n\t\tparam->reg_AC1       = 0x33302714;\n\t\tparam->reg_AC2       = 0xCC00B01B | trap_AC2;\n\t\tparam->reg_DQSIC     = 0x000000E2;\n\t\tparam->reg_MRS       = 0x00000C02 | trap_MRS;\n\t\tparam->reg_EMRS      = 0x00000040;\n\t\tparam->reg_DRV       = 0x000000FA;\n\t\tparam->reg_IOZ       = 0x00000034;\n\t\tparam->reg_DQIDLY    = 0x00000089;\n\t\tparam->reg_FREQ      = 0x00005040;\n\t\tparam->madj_max      = 96;\n\t\tparam->dll2_finetune_step = 4;\n\n\t\tswitch (param->dram_chipid) {\n\t\tcase AST_DRAM_512Mx16:\n\t\t\tparam->reg_AC2   = 0xCC00B016 | trap_AC2;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase AST_DRAM_1Gx16:\n\t\t\tparam->reg_AC2   = 0xCC00B01B | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_2Gx16:\n\t\t\tparam->reg_AC2   = 0xCC00B02B | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_4Gx16:\n\t\t\tparam->reg_AC2   = 0xCC00B03F | trap_AC2;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase 408:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x01F0);\n\t\tparam->wodt          = 1;\n\t\tparam->rodt          = 0;\n\t\tparam->reg_AC1       = 0x33302714;\n\t\tparam->reg_AC2       = 0xCC00B01B | trap_AC2;\n\t\tparam->reg_DQSIC     = 0x000000E2;\n\t\tparam->reg_MRS       = 0x00000C02 | trap_MRS;\n\t\tparam->reg_EMRS      = 0x00000040;\n\t\tparam->reg_DRV       = 0x000000FA;\n\t\tparam->reg_IOZ       = 0x00000034;\n\t\tparam->reg_DQIDLY    = 0x00000089;\n\t\tparam->reg_FREQ      = 0x000050C0;\n\t\tparam->madj_max      = 96;\n\t\tparam->dll2_finetune_step = 4;\n\n\t\tswitch (param->dram_chipid) {\n\t\tcase AST_DRAM_512Mx16:\n\t\t\tparam->reg_AC2   = 0xCC00B016 | trap_AC2;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase AST_DRAM_1Gx16:\n\t\t\tparam->reg_AC2   = 0xCC00B01B | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_2Gx16:\n\t\t\tparam->reg_AC2   = 0xCC00B02B | trap_AC2;\n\t\t\tbreak;\n\t\tcase AST_DRAM_4Gx16:\n\t\t\tparam->reg_AC2   = 0xCC00B03F | trap_AC2;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase 456:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0230);\n\t\tparam->wodt          = 0;\n\t\tparam->reg_AC1       = 0x33302815;\n\t\tparam->reg_AC2       = 0xCD44B01E;\n\t\tparam->reg_DQSIC     = 0x000000FC;\n\t\tparam->reg_MRS       = 0x00000E72;\n\t\tparam->reg_EMRS      = 0x00000000;\n\t\tparam->reg_DRV       = 0x00000000;\n\t\tparam->reg_IOZ       = 0x00000034;\n\t\tparam->reg_DQIDLY    = 0x00000097;\n\t\tparam->reg_FREQ      = 0x000052C0;\n\t\tparam->madj_max      = 88;\n\t\tparam->dll2_finetune_step = 3;\n\t\tbreak;\n\tcase 504:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0261);\n\t\tparam->wodt          = 1;\n\t\tparam->rodt          = 1;\n\t\tparam->reg_AC1       = 0x33302815;\n\t\tparam->reg_AC2       = 0xDE44C022;\n\t\tparam->reg_DQSIC     = 0x00000117;\n\t\tparam->reg_MRS       = 0x00000E72;\n\t\tparam->reg_EMRS      = 0x00000040;\n\t\tparam->reg_DRV       = 0x0000000A;\n\t\tparam->reg_IOZ       = 0x00000045;\n\t\tparam->reg_DQIDLY    = 0x000000A0;\n\t\tparam->reg_FREQ      = 0x000054C0;\n\t\tparam->madj_max      = 79;\n\t\tparam->dll2_finetune_step = 3;\n\t\tbreak;\n\tcase 528:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0120);\n\t\tparam->wodt          = 1;\n\t\tparam->rodt          = 1;\n\t\tparam->reg_AC1       = 0x33302815;\n\t\tparam->reg_AC2       = 0xEF44D024;\n\t\tparam->reg_DQSIC     = 0x00000125;\n\t\tparam->reg_MRS       = 0x00000E72;\n\t\tparam->reg_EMRS      = 0x00000004;\n\t\tparam->reg_DRV       = 0x000000F9;\n\t\tparam->reg_IOZ       = 0x00000045;\n\t\tparam->reg_DQIDLY    = 0x000000A7;\n\t\tparam->reg_FREQ      = 0x000055C0;\n\t\tparam->madj_max      = 76;\n\t\tparam->dll2_finetune_step = 3;\n\t\tbreak;\n\tcase 552:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x02A1);\n\t\tparam->wodt          = 1;\n\t\tparam->rodt          = 1;\n\t\tparam->reg_AC1       = 0x43402915;\n\t\tparam->reg_AC2       = 0xFF44E025;\n\t\tparam->reg_DQSIC     = 0x00000132;\n\t\tparam->reg_MRS       = 0x00000E72;\n\t\tparam->reg_EMRS      = 0x00000040;\n\t\tparam->reg_DRV       = 0x0000000A;\n\t\tparam->reg_IOZ       = 0x00000045;\n\t\tparam->reg_DQIDLY    = 0x000000AD;\n\t\tparam->reg_FREQ      = 0x000056C0;\n\t\tparam->madj_max      = 76;\n\t\tparam->dll2_finetune_step = 3;\n\t\tbreak;\n\tcase 576:\n\t\tast_moutdwm(ast, 0x1E6E2020, 0x0140);\n\t\tparam->wodt          = 1;\n\t\tparam->rodt          = 1;\n\t\tparam->reg_AC1       = 0x43402915;\n\t\tparam->reg_AC2       = 0xFF44E027;\n\t\tparam->reg_DQSIC     = 0x0000013F;\n\t\tparam->reg_MRS       = 0x00000E72;\n\t\tparam->reg_EMRS      = 0x00000004;\n\t\tparam->reg_DRV       = 0x000000F5;\n\t\tparam->reg_IOZ       = 0x00000045;\n\t\tparam->reg_DQIDLY    = 0x000000B3;\n\t\tparam->reg_FREQ      = 0x000057C0;\n\t\tparam->madj_max      = 76;\n\t\tparam->dll2_finetune_step = 3;\n\t\tbreak;\n\t}\n\n\tswitch (param->dram_chipid) {\n\tcase AST_DRAM_512Mx16:\n\t\tparam->dram_config = 0x100;\n\t\tbreak;\n\tdefault:\n\tcase AST_DRAM_1Gx16:\n\t\tparam->dram_config = 0x121;\n\t\tbreak;\n\tcase AST_DRAM_2Gx16:\n\t\tparam->dram_config = 0x122;\n\t\tbreak;\n\tcase AST_DRAM_4Gx16:\n\t\tparam->dram_config = 0x123;\n\t\tbreak;\n\t}  \n\n\tswitch (param->vram_size) {\n\tdefault:\n\tcase AST_VIDMEM_SIZE_8M:\n\t\tparam->dram_config |= 0x00;\n\t\tbreak;\n\tcase AST_VIDMEM_SIZE_16M:\n\t\tparam->dram_config |= 0x04;\n\t\tbreak;\n\tcase AST_VIDMEM_SIZE_32M:\n\t\tparam->dram_config |= 0x08;\n\t\tbreak;\n\tcase AST_VIDMEM_SIZE_64M:\n\t\tparam->dram_config |= 0x0c;\n\t\tbreak;\n\t}\n}\n\nstatic void ddr2_init(struct ast_device *ast, struct ast2300_dram_param *param)\n{\n\tu32 data, data2, retry = 0;\n\nddr2_init_start:\n\tast_moutdwm(ast, 0x1E6E0000, 0xFC600309);\n\tast_moutdwm(ast, 0x1E6E0018, 0x00000100);\n\tast_moutdwm(ast, 0x1E6E0024, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0064, param->reg_MADJ);\n\tast_moutdwm(ast, 0x1E6E0068, param->reg_SADJ);\n\tudelay(10);\n\tast_moutdwm(ast, 0x1E6E0064, param->reg_MADJ | 0xC0000);\n\tudelay(10);\n\n\tast_moutdwm(ast, 0x1E6E0004, param->dram_config);\n\tast_moutdwm(ast, 0x1E6E0008, 0x90040f);\n\tast_moutdwm(ast, 0x1E6E0010, param->reg_AC1);\n\tast_moutdwm(ast, 0x1E6E0014, param->reg_AC2);\n\tast_moutdwm(ast, 0x1E6E0020, param->reg_DQSIC);\n\tast_moutdwm(ast, 0x1E6E0080, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0084, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0088, param->reg_DQIDLY);\n\tast_moutdwm(ast, 0x1E6E0018, 0x4000A130);\n\tast_moutdwm(ast, 0x1E6E0018, 0x00002330);\n\tast_moutdwm(ast, 0x1E6E0038, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0040, 0xFF808000);\n\tast_moutdwm(ast, 0x1E6E0044, 0x88848466);\n\tast_moutdwm(ast, 0x1E6E0048, 0x44440008);\n\tast_moutdwm(ast, 0x1E6E004C, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0050, 0x80000000);\n\tast_moutdwm(ast, 0x1E6E0050, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0054, 0);\n\tast_moutdwm(ast, 0x1E6E0060, param->reg_DRV);\n\tast_moutdwm(ast, 0x1E6E006C, param->reg_IOZ);\n\tast_moutdwm(ast, 0x1E6E0070, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0074, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0078, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E007C, 0x00000000);\n\n\t \n\tdo {\n\t\tdata = ast_mindwm(ast, 0x1E6E001C);\n\t} while (!(data & 0x08000000));\n\tdata = ast_mindwm(ast, 0x1E6E001C);\n\tdata = (data >> 8) & 0xff;\n\twhile ((data & 0x08) || ((data & 0x7) < 2) || (data < 4)) {\n\t\tdata2 = (ast_mindwm(ast, 0x1E6E0064) & 0xfff3ffff) + 4;\n\t\tif ((data2 & 0xff) > param->madj_max) {\n\t\t\tbreak;\n\t\t}\n\t\tast_moutdwm(ast, 0x1E6E0064, data2);\n\t\tif (data2 & 0x00100000) {\n\t\t\tdata2 = ((data2 & 0xff) >> 3) + 3;\n\t\t} else {\n\t\t\tdata2 = ((data2 & 0xff) >> 2) + 5;\n\t\t}\n\t\tdata = ast_mindwm(ast, 0x1E6E0068) & 0xffff00ff;\n\t\tdata2 += data & 0xff;\n\t\tdata = data | (data2 << 8);\n\t\tast_moutdwm(ast, 0x1E6E0068, data);\n\t\tudelay(10);\n\t\tast_moutdwm(ast, 0x1E6E0064, ast_mindwm(ast, 0x1E6E0064) | 0xC0000);\n\t\tudelay(10);\n\t\tdata = ast_mindwm(ast, 0x1E6E0018) & 0xfffff1ff;\n\t\tast_moutdwm(ast, 0x1E6E0018, data);\n\t\tdata = data | 0x200;\n\t\tast_moutdwm(ast, 0x1E6E0018, data);\n\t\tdo {\n\t\t\tdata = ast_mindwm(ast, 0x1E6E001C);\n\t\t} while (!(data & 0x08000000));\n\n\t\tdata = ast_mindwm(ast, 0x1E6E001C);\n\t\tdata = (data >> 8) & 0xff;\n\t}\n\tast_moutdwm(ast, 0x1E720058, ast_mindwm(ast, 0x1E6E0008) & 0xffff);\n\tdata = ast_mindwm(ast, 0x1E6E0018) | 0xC00;\n\tast_moutdwm(ast, 0x1E6E0018, data);\n\n\tast_moutdwm(ast, 0x1E6E0034, 0x00000001);\n\tast_moutdwm(ast, 0x1E6E000C, 0x00000000);\n\tudelay(50);\n\t \n\tast_moutdwm(ast, 0x1E6E002C, param->reg_MRS | 0x100);\n\tast_moutdwm(ast, 0x1E6E0030, param->reg_EMRS);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000005);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000007);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000003);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000001);\n\n\tast_moutdwm(ast, 0x1E6E000C, 0x00005C08);\n\tast_moutdwm(ast, 0x1E6E002C, param->reg_MRS);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000001);\n\tast_moutdwm(ast, 0x1E6E0030, param->reg_EMRS | 0x380);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000003);\n\tast_moutdwm(ast, 0x1E6E0030, param->reg_EMRS);\n\tast_moutdwm(ast, 0x1E6E0028, 0x00000003);\n\n\tast_moutdwm(ast, 0x1E6E000C, 0x7FFF5C01);\n\tdata = 0;\n\tif (param->wodt) {\n\t\tdata = 0x500;\n\t}\n\tif (param->rodt) {\n\t\tdata = data | 0x3000 | ((param->reg_AC2 & 0x60000) >> 3);\n\t}\n\tast_moutdwm(ast, 0x1E6E0034, data | 0x3);\n\tast_moutdwm(ast, 0x1E6E0120, param->reg_FREQ);\n\n\t \n\tif ((cbr_dll2(ast, param) == false) && (retry++ < 10))\n\t\tgoto ddr2_init_start;\n\n\t \n#ifdef ECC\n\tast_moutdwm(ast, 0x1E6E007C, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0070, 0x221);\n\tdo {\n\t\tdata = ast_mindwm(ast, 0x1E6E0070);\n\t} while (!(data & 0x00001000));\n\tast_moutdwm(ast, 0x1E6E0070, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0050, 0x80000000);\n\tast_moutdwm(ast, 0x1E6E0050, 0x00000000);\n#endif\n\n}\n\nstatic void ast_post_chip_2300(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tstruct ast2300_dram_param param;\n\tu32 temp;\n\tu8 reg;\n\n\treg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\n\tif ((reg & 0x80) == 0) { \n\t\tast_write32(ast, 0xf004, 0x1e6e0000);\n\t\tast_write32(ast, 0xf000, 0x1);\n\t\tast_write32(ast, 0x12000, 0x1688a8a8);\n\t\tdo {\n\t\t\t;\n\t\t} while (ast_read32(ast, 0x12000) != 0x1);\n\n\t\tast_write32(ast, 0x10000, 0xfc600309);\n\t\tdo {\n\t\t\t;\n\t\t} while (ast_read32(ast, 0x10000) != 0x1);\n\n\t\t \n\t\ttemp = ast_read32(ast, 0x12008);\n\t\ttemp |= 0x73;\n\t\tast_write32(ast, 0x12008, temp);\n\n\t\tparam.dram_freq = 396;\n\t\tparam.dram_type = AST_DDR3;\n\t\ttemp = ast_mindwm(ast, 0x1e6e2070);\n\t\tif (temp & 0x01000000)\n\t\t\tparam.dram_type = AST_DDR2;\n                switch (temp & 0x18000000) {\n\t\tcase 0:\n\t\t\tparam.dram_chipid = AST_DRAM_512Mx16;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 0x08000000:\n\t\t\tparam.dram_chipid = AST_DRAM_1Gx16;\n\t\t\tbreak;\n\t\tcase 0x10000000:\n\t\t\tparam.dram_chipid = AST_DRAM_2Gx16;\n\t\t\tbreak;\n\t\tcase 0x18000000:\n\t\t\tparam.dram_chipid = AST_DRAM_4Gx16;\n\t\t\tbreak;\n\t\t}\n                switch (temp & 0x0c) {\n                default:\n\t\tcase 0x00:\n\t\t\tparam.vram_size = AST_VIDMEM_SIZE_8M;\n\t\t\tbreak;\n\n\t\tcase 0x04:\n\t\t\tparam.vram_size = AST_VIDMEM_SIZE_16M;\n\t\t\tbreak;\n\n\t\tcase 0x08:\n\t\t\tparam.vram_size = AST_VIDMEM_SIZE_32M;\n\t\t\tbreak;\n\n\t\tcase 0x0c:\n\t\t\tparam.vram_size = AST_VIDMEM_SIZE_64M;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (param.dram_type == AST_DDR3) {\n\t\t\tget_ddr3_info(ast, &param);\n\t\t\tddr3_init(ast, &param);\n\t\t} else {\n\t\t\tget_ddr2_info(ast, &param);\n\t\t\tddr2_init(ast, &param);\n\t\t}\n\n\t\ttemp = ast_mindwm(ast, 0x1e6e2040);\n\t\tast_moutdwm(ast, 0x1e6e2040, temp | 0x40);\n\t}\n\n\t \n\tdo {\n\t\treg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\n\t} while ((reg & 0x40) == 0);\n}\n\nstatic bool cbr_test_2500(struct ast_device *ast)\n{\n\tast_moutdwm(ast, 0x1E6E0074, 0x0000FFFF);\n\tast_moutdwm(ast, 0x1E6E007C, 0xFF00FF00);\n\tif (!mmc_test_burst(ast, 0))\n\t\treturn false;\n\tif (!mmc_test_single_2500(ast, 0))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool ddr_test_2500(struct ast_device *ast)\n{\n\tast_moutdwm(ast, 0x1E6E0074, 0x0000FFFF);\n\tast_moutdwm(ast, 0x1E6E007C, 0xFF00FF00);\n\tif (!mmc_test_burst(ast, 0))\n\t\treturn false;\n\tif (!mmc_test_burst(ast, 1))\n\t\treturn false;\n\tif (!mmc_test_burst(ast, 2))\n\t\treturn false;\n\tif (!mmc_test_burst(ast, 3))\n\t\treturn false;\n\tif (!mmc_test_single_2500(ast, 0))\n\t\treturn false;\n\treturn true;\n}\n\nstatic void ddr_init_common_2500(struct ast_device *ast)\n{\n\tast_moutdwm(ast, 0x1E6E0034, 0x00020080);\n\tast_moutdwm(ast, 0x1E6E0008, 0x2003000F);\n\tast_moutdwm(ast, 0x1E6E0038, 0x00000FFF);\n\tast_moutdwm(ast, 0x1E6E0040, 0x88448844);\n\tast_moutdwm(ast, 0x1E6E0044, 0x24422288);\n\tast_moutdwm(ast, 0x1E6E0048, 0x22222222);\n\tast_moutdwm(ast, 0x1E6E004C, 0x22222222);\n\tast_moutdwm(ast, 0x1E6E0050, 0x80000000);\n\tast_moutdwm(ast, 0x1E6E0208, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0218, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0220, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0228, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0230, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E02A8, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E02B0, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0240, 0x86000000);\n\tast_moutdwm(ast, 0x1E6E0244, 0x00008600);\n\tast_moutdwm(ast, 0x1E6E0248, 0x80000000);\n\tast_moutdwm(ast, 0x1E6E024C, 0x80808080);\n}\n\nstatic void ddr_phy_init_2500(struct ast_device *ast)\n{\n\tu32 data, pass, timecnt;\n\n\tpass = 0;\n\tast_moutdwm(ast, 0x1E6E0060, 0x00000005);\n\twhile (!pass) {\n\t\tfor (timecnt = 0; timecnt < TIMEOUT; timecnt++) {\n\t\t\tdata = ast_mindwm(ast, 0x1E6E0060) & 0x1;\n\t\t\tif (!data)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (timecnt != TIMEOUT) {\n\t\t\tdata = ast_mindwm(ast, 0x1E6E0300) & 0x000A0000;\n\t\t\tif (!data)\n\t\t\t\tpass = 1;\n\t\t}\n\t\tif (!pass) {\n\t\t\tast_moutdwm(ast, 0x1E6E0060, 0x00000000);\n\t\t\tudelay(10);  \n\t\t\tast_moutdwm(ast, 0x1E6E0060, 0x00000005);\n\t\t}\n\t}\n\n\tast_moutdwm(ast, 0x1E6E0060, 0x00000006);\n}\n\n \nstatic void check_dram_size_2500(struct ast_device *ast, u32 tRFC)\n{\n\tu32 reg_04, reg_14;\n\n\treg_04 = ast_mindwm(ast, 0x1E6E0004) & 0xfffffffc;\n\treg_14 = ast_mindwm(ast, 0x1E6E0014) & 0xffffff00;\n\n\tast_moutdwm(ast, 0xA0100000, 0x41424344);\n\tast_moutdwm(ast, 0x90100000, 0x35363738);\n\tast_moutdwm(ast, 0x88100000, 0x292A2B2C);\n\tast_moutdwm(ast, 0x80100000, 0x1D1E1F10);\n\n\t \n\tif (ast_mindwm(ast, 0xA0100000) == 0x41424344) {\n\t\treg_04 |= 0x03;\n\t\treg_14 |= (tRFC >> 24) & 0xFF;\n\t\t \n\t} else if (ast_mindwm(ast, 0x90100000) == 0x35363738) {\n\t\treg_04 |= 0x02;\n\t\treg_14 |= (tRFC >> 16) & 0xFF;\n\t\t \n\t} else if (ast_mindwm(ast, 0x88100000) == 0x292A2B2C) {\n\t\treg_04 |= 0x01;\n\t\treg_14 |= (tRFC >> 8) & 0xFF;\n\t} else {\n\t\treg_14 |= tRFC & 0xFF;\n\t}\n\tast_moutdwm(ast, 0x1E6E0004, reg_04);\n\tast_moutdwm(ast, 0x1E6E0014, reg_14);\n}\n\nstatic void enable_cache_2500(struct ast_device *ast)\n{\n\tu32 reg_04, data;\n\n\treg_04 = ast_mindwm(ast, 0x1E6E0004);\n\tast_moutdwm(ast, 0x1E6E0004, reg_04 | 0x1000);\n\n\tdo\n\t\tdata = ast_mindwm(ast, 0x1E6E0004);\n\twhile (!(data & 0x80000));\n\tast_moutdwm(ast, 0x1E6E0004, reg_04 | 0x400);\n}\n\nstatic void set_mpll_2500(struct ast_device *ast)\n{\n\tu32 addr, data, param;\n\n\t \n\tast_moutdwm(ast, 0x1E6E0000, 0xFC600309);\n\tast_moutdwm(ast, 0x1E6E0034, 0x00020080);\n\tfor (addr = 0x1e6e0004; addr < 0x1e6e0090;) {\n\t\tast_moutdwm(ast, addr, 0x0);\n\t\taddr += 4;\n\t}\n\tast_moutdwm(ast, 0x1E6E0034, 0x00020000);\n\n\tast_moutdwm(ast, 0x1E6E2000, 0x1688A8A8);\n\tdata = ast_mindwm(ast, 0x1E6E2070) & 0x00800000;\n\tif (data) {\n\t\t \n\t\tparam = 0x930023E0;\n\t\tast_moutdwm(ast, 0x1E6E2160, 0x00011320);\n\t} else {\n\t\t \n\t\tparam = 0x93002400;\n\t}\n\tast_moutdwm(ast, 0x1E6E2020, param);\n\tudelay(100);\n}\n\nstatic void reset_mmc_2500(struct ast_device *ast)\n{\n\tast_moutdwm(ast, 0x1E78505C, 0x00000004);\n\tast_moutdwm(ast, 0x1E785044, 0x00000001);\n\tast_moutdwm(ast, 0x1E785048, 0x00004755);\n\tast_moutdwm(ast, 0x1E78504C, 0x00000013);\n\tmdelay(100);\n\tast_moutdwm(ast, 0x1E785054, 0x00000077);\n\tast_moutdwm(ast, 0x1E6E0000, 0xFC600309);\n}\n\nstatic void ddr3_init_2500(struct ast_device *ast, const u32 *ddr_table)\n{\n\n\tast_moutdwm(ast, 0x1E6E0004, 0x00000303);\n\tast_moutdwm(ast, 0x1E6E0010, ddr_table[REGIDX_010]);\n\tast_moutdwm(ast, 0x1E6E0014, ddr_table[REGIDX_014]);\n\tast_moutdwm(ast, 0x1E6E0018, ddr_table[REGIDX_018]);\n\tast_moutdwm(ast, 0x1E6E0020, ddr_table[REGIDX_020]);\t      \n\tast_moutdwm(ast, 0x1E6E0024, ddr_table[REGIDX_024]);\t      \n\tast_moutdwm(ast, 0x1E6E002C, ddr_table[REGIDX_02C] | 0x100);  \n\tast_moutdwm(ast, 0x1E6E0030, ddr_table[REGIDX_030]);\t      \n\n\t \n\tast_moutdwm(ast, 0x1E6E0200, 0x02492AAE);\n\tast_moutdwm(ast, 0x1E6E0204, 0x00001001);\n\tast_moutdwm(ast, 0x1E6E020C, 0x55E00B0B);\n\tast_moutdwm(ast, 0x1E6E0210, 0x20000000);\n\tast_moutdwm(ast, 0x1E6E0214, ddr_table[REGIDX_214]);\n\tast_moutdwm(ast, 0x1E6E02E0, ddr_table[REGIDX_2E0]);\n\tast_moutdwm(ast, 0x1E6E02E4, ddr_table[REGIDX_2E4]);\n\tast_moutdwm(ast, 0x1E6E02E8, ddr_table[REGIDX_2E8]);\n\tast_moutdwm(ast, 0x1E6E02EC, ddr_table[REGIDX_2EC]);\n\tast_moutdwm(ast, 0x1E6E02F0, ddr_table[REGIDX_2F0]);\n\tast_moutdwm(ast, 0x1E6E02F4, ddr_table[REGIDX_2F4]);\n\tast_moutdwm(ast, 0x1E6E02F8, ddr_table[REGIDX_2F8]);\n\tast_moutdwm(ast, 0x1E6E0290, 0x00100008);\n\tast_moutdwm(ast, 0x1E6E02C0, 0x00000006);\n\n\t \n\tast_moutdwm(ast, 0x1E6E0034, 0x00020091);\n\n\t \n\tddr_phy_init_2500(ast);\n\n\tast_moutdwm(ast, 0x1E6E0120, ddr_table[REGIDX_PLL]);\n\tast_moutdwm(ast, 0x1E6E000C, 0x42AA5C81);\n\tast_moutdwm(ast, 0x1E6E0034, 0x0001AF93);\n\n\tcheck_dram_size_2500(ast, ddr_table[REGIDX_RFC]);\n\tenable_cache_2500(ast);\n\tast_moutdwm(ast, 0x1E6E001C, 0x00000008);\n\tast_moutdwm(ast, 0x1E6E0038, 0xFFFFFF00);\n}\n\nstatic void ddr4_init_2500(struct ast_device *ast, const u32 *ddr_table)\n{\n\tu32 data, data2, pass, retrycnt;\n\tu32 ddr_vref, phy_vref;\n\tu32 min_ddr_vref = 0, min_phy_vref = 0;\n\tu32 max_ddr_vref = 0, max_phy_vref = 0;\n\n\tast_moutdwm(ast, 0x1E6E0004, 0x00000313);\n\tast_moutdwm(ast, 0x1E6E0010, ddr_table[REGIDX_010]);\n\tast_moutdwm(ast, 0x1E6E0014, ddr_table[REGIDX_014]);\n\tast_moutdwm(ast, 0x1E6E0018, ddr_table[REGIDX_018]);\n\tast_moutdwm(ast, 0x1E6E0020, ddr_table[REGIDX_020]);\t      \n\tast_moutdwm(ast, 0x1E6E0024, ddr_table[REGIDX_024]);\t      \n\tast_moutdwm(ast, 0x1E6E002C, ddr_table[REGIDX_02C] | 0x100);  \n\tast_moutdwm(ast, 0x1E6E0030, ddr_table[REGIDX_030]);\t      \n\n\t \n\tast_moutdwm(ast, 0x1E6E0200, 0x42492AAE);\n\tast_moutdwm(ast, 0x1E6E0204, 0x09002000);\n\tast_moutdwm(ast, 0x1E6E020C, 0x55E00B0B);\n\tast_moutdwm(ast, 0x1E6E0210, 0x20000000);\n\tast_moutdwm(ast, 0x1E6E0214, ddr_table[REGIDX_214]);\n\tast_moutdwm(ast, 0x1E6E02E0, ddr_table[REGIDX_2E0]);\n\tast_moutdwm(ast, 0x1E6E02E4, ddr_table[REGIDX_2E4]);\n\tast_moutdwm(ast, 0x1E6E02E8, ddr_table[REGIDX_2E8]);\n\tast_moutdwm(ast, 0x1E6E02EC, ddr_table[REGIDX_2EC]);\n\tast_moutdwm(ast, 0x1E6E02F0, ddr_table[REGIDX_2F0]);\n\tast_moutdwm(ast, 0x1E6E02F4, ddr_table[REGIDX_2F4]);\n\tast_moutdwm(ast, 0x1E6E02F8, ddr_table[REGIDX_2F8]);\n\tast_moutdwm(ast, 0x1E6E0290, 0x00100008);\n\tast_moutdwm(ast, 0x1E6E02C4, 0x3C183C3C);\n\tast_moutdwm(ast, 0x1E6E02C8, 0x00631E0E);\n\n\t \n\tast_moutdwm(ast, 0x1E6E0034, 0x0001A991);\n\n\t \n\tpass = 0;\n\n\tfor (retrycnt = 0; retrycnt < 4 && pass == 0; retrycnt++) {\n\t\tmax_phy_vref = 0x0;\n\t\tpass = 0;\n\t\tast_moutdwm(ast, 0x1E6E02C0, 0x00001C06);\n\t\tfor (phy_vref = 0x40; phy_vref < 0x80; phy_vref++) {\n\t\t\tast_moutdwm(ast, 0x1E6E000C, 0x00000000);\n\t\t\tast_moutdwm(ast, 0x1E6E0060, 0x00000000);\n\t\t\tast_moutdwm(ast, 0x1E6E02CC, phy_vref | (phy_vref << 8));\n\t\t\t \n\t\t\tddr_phy_init_2500(ast);\n\t\t\tast_moutdwm(ast, 0x1E6E000C, 0x00005C01);\n\t\t\tif (cbr_test_2500(ast)) {\n\t\t\t\tpass++;\n\t\t\t\tdata = ast_mindwm(ast, 0x1E6E03D0);\n\t\t\t\tdata2 = data >> 8;\n\t\t\t\tdata  = data & 0xff;\n\t\t\t\tif (data > data2)\n\t\t\t\t\tdata = data2;\n\t\t\t\tif (max_phy_vref < data) {\n\t\t\t\t\tmax_phy_vref = data;\n\t\t\t\t\tmin_phy_vref = phy_vref;\n\t\t\t\t}\n\t\t\t} else if (pass > 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tast_moutdwm(ast, 0x1E6E02CC, min_phy_vref | (min_phy_vref << 8));\n\n\t \n\tpass = 0;\n\n\tfor (retrycnt = 0; retrycnt < 4 && pass == 0; retrycnt++) {\n\t\tmin_ddr_vref = 0xFF;\n\t\tmax_ddr_vref = 0x0;\n\t\tpass = 0;\n\t\tfor (ddr_vref = 0x00; ddr_vref < 0x40; ddr_vref++) {\n\t\t\tast_moutdwm(ast, 0x1E6E000C, 0x00000000);\n\t\t\tast_moutdwm(ast, 0x1E6E0060, 0x00000000);\n\t\t\tast_moutdwm(ast, 0x1E6E02C0, 0x00000006 | (ddr_vref << 8));\n\t\t\t \n\t\t\tddr_phy_init_2500(ast);\n\t\t\tast_moutdwm(ast, 0x1E6E000C, 0x00005C01);\n\t\t\tif (cbr_test_2500(ast)) {\n\t\t\t\tpass++;\n\t\t\t\tif (min_ddr_vref > ddr_vref)\n\t\t\t\t\tmin_ddr_vref = ddr_vref;\n\t\t\t\tif (max_ddr_vref < ddr_vref)\n\t\t\t\t\tmax_ddr_vref = ddr_vref;\n\t\t\t} else if (pass != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tast_moutdwm(ast, 0x1E6E000C, 0x00000000);\n\tast_moutdwm(ast, 0x1E6E0060, 0x00000000);\n\tddr_vref = (min_ddr_vref + max_ddr_vref + 1) >> 1;\n\tast_moutdwm(ast, 0x1E6E02C0, 0x00000006 | (ddr_vref << 8));\n\n\t \n\tddr_phy_init_2500(ast);\n\n\tast_moutdwm(ast, 0x1E6E0120, ddr_table[REGIDX_PLL]);\n\tast_moutdwm(ast, 0x1E6E000C, 0x42AA5C81);\n\tast_moutdwm(ast, 0x1E6E0034, 0x0001AF93);\n\n\tcheck_dram_size_2500(ast, ddr_table[REGIDX_RFC]);\n\tenable_cache_2500(ast);\n\tast_moutdwm(ast, 0x1E6E001C, 0x00000008);\n\tast_moutdwm(ast, 0x1E6E0038, 0xFFFFFF00);\n}\n\nstatic bool ast_dram_init_2500(struct ast_device *ast)\n{\n\tu32 data;\n\tu32 max_tries = 5;\n\n\tdo {\n\t\tif (max_tries-- == 0)\n\t\t\treturn false;\n\t\tset_mpll_2500(ast);\n\t\treset_mmc_2500(ast);\n\t\tddr_init_common_2500(ast);\n\n\t\tdata = ast_mindwm(ast, 0x1E6E2070);\n\t\tif (data & 0x01000000)\n\t\t\tddr4_init_2500(ast, ast2500_ddr4_1600_timing_table);\n\t\telse\n\t\t\tddr3_init_2500(ast, ast2500_ddr3_1600_timing_table);\n\t} while (!ddr_test_2500(ast));\n\n\tast_moutdwm(ast, 0x1E6E2040, ast_mindwm(ast, 0x1E6E2040) | 0x41);\n\n\t \n\tdata = ast_mindwm(ast, 0x1E6E200C) & 0xF9FFFFFF;\n\tast_moutdwm(ast, 0x1E6E200C, data | 0x10000000);\n\n\treturn true;\n}\n\nvoid ast_patch_ahb_2500(struct ast_device *ast)\n{\n\tu32\tdata;\n\n\t \n\tast_moutdwm(ast, 0x1e600000, 0xAEED1A03);\n\tast_moutdwm(ast, 0x1e600084, 0x00010000);\n\tast_moutdwm(ast, 0x1e600088, 0x00000000);\n\tast_moutdwm(ast, 0x1e6e2000, 0x1688A8A8);\n\tdata = ast_mindwm(ast, 0x1e6e2070);\n\tif (data & 0x08000000) {\t\t\t\t\t \n\t\t \n\t\tast_moutdwm(ast, 0x1E785004, 0x00000010);\n\t\tast_moutdwm(ast, 0x1E785008, 0x00004755);\n\t\tast_moutdwm(ast, 0x1E78500c, 0x00000033);\n\t\tudelay(1000);\n\t}\n\tdo {\n\t\tast_moutdwm(ast, 0x1e6e2000, 0x1688A8A8);\n\t\tdata = ast_mindwm(ast, 0x1e6e2000);\n\t}\twhile (data != 1);\n\tast_moutdwm(ast, 0x1e6e207c, 0x08000000);\t \n}\n\nvoid ast_post_chip_2500(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu32 temp;\n\tu8 reg;\n\n\treg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\n\tif ((reg & AST_VRAM_INIT_STATUS_MASK) == 0) { \n\t\t \n\t\tast_patch_ahb_2500(ast);\n\n\t\t \n\t\tast_moutdwm(ast, 0x1E78502C, 0x00000000);\n\t\tast_moutdwm(ast, 0x1E78504C, 0x00000000);\n\n\t\t \n\t\tast_moutdwm(ast, 0x1E6E2090, 0x20000000);\n\t\tast_moutdwm(ast, 0x1E6E2094, 0x00004000);\n\t\tif (ast_mindwm(ast, 0x1E6E2070) & 0x00800000) {\n\t\t\tast_moutdwm(ast, 0x1E6E207C, 0x00800000);\n\t\t\tmdelay(100);\n\t\t\tast_moutdwm(ast, 0x1E6E2070, 0x00800000);\n\t\t}\n\t\t \n\t\ttemp = ast_mindwm(ast, 0x1E6E2070);\n\t\tif (temp & 0x02000000)\n\t\t\tast_moutdwm(ast, 0x1E6E207C, 0x00004000);\n\n\t\t \n\t\ttemp = ast_read32(ast, 0x12008);\n\t\ttemp |= 0x73;\n\t\tast_write32(ast, 0x12008, temp);\n\n\t\tif (!ast_dram_init_2500(ast))\n\t\t\tdrm_err(dev, \"DRAM init failed !\\n\");\n\n\t\ttemp = ast_mindwm(ast, 0x1e6e2040);\n\t\tast_moutdwm(ast, 0x1e6e2040, temp | 0x40);\n\t}\n\n\t \n\tdo {\n\t\treg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\n\t} while ((reg & 0x40) == 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}