{
  "module_name": "ast_main.c",
  "hash_id": "bdb6adc7d94500450a31f62323fb0f461f25b2de3cb61a302af3903607f3a749",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ast/ast_main.c",
  "human_readable_source": " \n \n\n#include <linux/pci.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_managed.h>\n\n#include \"ast_drv.h\"\n\nstatic bool ast_is_vga_enabled(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\tu8 ch;\n\n\tch = ast_io_read8(ast, AST_IO_VGA_ENABLE_PORT);\n\n\treturn !!(ch & 0x01);\n}\n\nstatic void ast_enable_vga(struct drm_device *dev)\n{\n\tstruct ast_device *ast = to_ast_device(dev);\n\n\tast_io_write8(ast, AST_IO_VGA_ENABLE_PORT, 0x01);\n\tast_io_write8(ast, AST_IO_MISC_PORT_WRITE, 0x01);\n}\n\n \nstatic void ast_enable_mmio_release(void *data)\n{\n\tstruct ast_device *ast = data;\n\n\t \n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa1, 0x04);\n}\n\nstatic int ast_enable_mmio(struct ast_device *ast)\n{\n\tstruct drm_device *dev = &ast->base;\n\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa1, 0x06);\n\n\treturn devm_add_action_or_reset(dev->dev, ast_enable_mmio_release, ast);\n}\n\nstatic void ast_open_key(struct ast_device *ast)\n{\n\tast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x80, 0xA8);\n}\n\nstatic int ast_device_config_init(struct ast_device *ast)\n{\n\tstruct drm_device *dev = &ast->base;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct device_node *np = dev->dev->of_node;\n\tuint32_t scu_rev = 0xffffffff;\n\tu32 data;\n\tu8 jregd0, jregd1;\n\n\t \n\n\tast->config_mode = ast_use_defaults;\n\n\t \n\tif (np && !of_property_read_u32(np, \"aspeed,scu-revision-id\", &data)) {\n\t\t \n\t\tast->config_mode = ast_use_dt;\n\t\tscu_rev = data;\n\t} else if (pdev->device == PCI_CHIP_AST2000) { \n\t\t \n\t\tjregd0 = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\n\t\tjregd1 = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd1, 0xff);\n\t\tif (!(jregd0 & 0x80) || !(jregd1 & 0x10)) {\n\n\t\t\t \n\n\t\t\t \n\t\t\tif ((pdev->revision & 0xf0) == 0x40) {\n\t\t\t\tif (!(jregd0 & AST_VRAM_INIT_STATUS_MASK))\n\t\t\t\t\tast_patch_ahb_2500(ast);\n\t\t\t}\n\n\t\t\t \n\t\t\tdata = ast_read32(ast, 0xf004);\n\t\t\tif ((data != 0xffffffff) && (data != 0x00)) {\n\t\t\t\tast->config_mode = ast_use_p2a;\n\n\t\t\t\t \n\t\t\t\tast_write32(ast, 0xf004, 0x1e6e0000);\n\t\t\t\tast_write32(ast, 0xf000, 0x1);\n\t\t\t\tscu_rev = ast_read32(ast, 0x1207c);\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (ast->config_mode) {\n\tcase ast_use_defaults:\n\t\tdrm_info(dev, \"Using default configuration\\n\");\n\t\tbreak;\n\tcase ast_use_dt:\n\t\tdrm_info(dev, \"Using device-tree for configuration\\n\");\n\t\tbreak;\n\tcase ast_use_p2a:\n\t\tdrm_info(dev, \"Using P2A bridge for configuration\\n\");\n\t\tbreak;\n\t}\n\n\t \n\n\tif (pdev->revision >= 0x50) {\n\t\tast->chip = AST2600;\n\t\tdrm_info(dev, \"AST 2600 detected\\n\");\n\t} else if (pdev->revision >= 0x40) {\n\t\tswitch (scu_rev & 0x300) {\n\t\tcase 0x0100:\n\t\t\tast->chip = AST2510;\n\t\t\tdrm_info(dev, \"AST 2510 detected\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast->chip = AST2500;\n\t\t\tdrm_info(dev, \"AST 2500 detected\\n\");\n\t\t}\n\t} else if (pdev->revision >= 0x30) {\n\t\tswitch (scu_rev & 0x300) {\n\t\tcase 0x0100:\n\t\t\tast->chip = AST1400;\n\t\t\tdrm_info(dev, \"AST 1400 detected\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast->chip = AST2400;\n\t\t\tdrm_info(dev, \"AST 2400 detected\\n\");\n\t\t}\n\t} else if (pdev->revision >= 0x20) {\n\t\tswitch (scu_rev & 0x300) {\n\t\tcase 0x0000:\n\t\t\tast->chip = AST1300;\n\t\t\tdrm_info(dev, \"AST 1300 detected\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast->chip = AST2300;\n\t\t\tdrm_info(dev, \"AST 2300 detected\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else if (pdev->revision >= 0x10) {\n\t\tswitch (scu_rev & 0x0300) {\n\t\tcase 0x0200:\n\t\t\tast->chip = AST1100;\n\t\t\tdrm_info(dev, \"AST 1100 detected\\n\");\n\t\t\tbreak;\n\t\tcase 0x0100:\n\t\t\tast->chip = AST2200;\n\t\t\tdrm_info(dev, \"AST 2200 detected\\n\");\n\t\t\tbreak;\n\t\tcase 0x0000:\n\t\t\tast->chip = AST2150;\n\t\t\tdrm_info(dev, \"AST 2150 detected\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast->chip = AST2100;\n\t\t\tdrm_info(dev, \"AST 2100 detected\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tast->chip = AST2000;\n\t\tdrm_info(dev, \"AST 2000 detected\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void ast_detect_widescreen(struct ast_device *ast)\n{\n\tu8 jreg;\n\n\t \n\tswitch (AST_GEN(ast)) {\n\tcase 1:\n\t\tast->support_wide_screen = false;\n\t\tbreak;\n\tdefault:\n\t\tjreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\n\t\tif (!(jreg & 0x80))\n\t\t\tast->support_wide_screen = true;\n\t\telse if (jreg & 0x01)\n\t\t\tast->support_wide_screen = true;\n\t\telse {\n\t\t\tast->support_wide_screen = false;\n\t\t\tif (ast->chip == AST1300)\n\t\t\t\tast->support_wide_screen = true;\n\t\t\tif (ast->chip == AST1400)\n\t\t\t\tast->support_wide_screen = true;\n\t\t\tif (ast->chip == AST2510)\n\t\t\t\tast->support_wide_screen = true;\n\t\t\tif (IS_AST_GEN7(ast))\n\t\t\t\tast->support_wide_screen = true;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void ast_detect_tx_chip(struct ast_device *ast, bool need_post)\n{\n\tstruct drm_device *dev = &ast->base;\n\tu8 jreg;\n\n\t \n\tast->tx_chip_types |= AST_TX_NONE_BIT;\n\n\t \n\tif (!need_post) {\n\t\tjreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa3, 0xff);\n\t\tif (jreg & 0x80)\n\t\t\tast->tx_chip_types = AST_TX_SIL164_BIT;\n\t}\n\n\tif (IS_AST_GEN4(ast) || IS_AST_GEN5(ast) || IS_AST_GEN6(ast)) {\n\t\t \n\t\tjreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd1, 0xff);\n\t\tswitch (jreg) {\n\t\tcase 0x04:\n\t\t\tast->tx_chip_types = AST_TX_SIL164_BIT;\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\tast->dp501_fw_addr = drmm_kzalloc(dev, 32*1024, GFP_KERNEL);\n\t\t\tif (ast->dp501_fw_addr) {\n\t\t\t\t \n\t\t\t\tif (ast_backup_fw(dev, ast->dp501_fw_addr, 32*1024)) {\n\t\t\t\t\tdrmm_kfree(dev, ast->dp501_fw_addr);\n\t\t\t\t\tast->dp501_fw_addr = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 0x0c:\n\t\t\tast->tx_chip_types = AST_TX_DP501_BIT;\n\t\t}\n\t} else if (IS_AST_GEN7(ast)) {\n\t\tif (ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xD1, TX_TYPE_MASK) ==\n\t\t    ASTDP_DPMCU_TX) {\n\t\t\tast->tx_chip_types = AST_TX_ASTDP_BIT;\n\t\t\tast_dp_launch(&ast->base);\n\t\t}\n\t}\n\n\t \n\tif (ast->tx_chip_types & AST_TX_NONE_BIT)\n\t\tdrm_info(dev, \"Using analog VGA\\n\");\n\tif (ast->tx_chip_types & AST_TX_SIL164_BIT)\n\t\tdrm_info(dev, \"Using Sil164 TMDS transmitter\\n\");\n\tif (ast->tx_chip_types & AST_TX_DP501_BIT)\n\t\tdrm_info(dev, \"Using DP501 DisplayPort transmitter\\n\");\n\tif (ast->tx_chip_types & AST_TX_ASTDP_BIT)\n\t\tdrm_info(dev, \"Using ASPEED DisplayPort transmitter\\n\");\n}\n\nstatic int ast_get_dram_info(struct drm_device *dev)\n{\n\tstruct device_node *np = dev->dev->of_node;\n\tstruct ast_device *ast = to_ast_device(dev);\n\tuint32_t mcr_cfg, mcr_scu_mpll, mcr_scu_strap;\n\tuint32_t denum, num, div, ref_pll, dsel;\n\n\tswitch (ast->config_mode) {\n\tcase ast_use_dt:\n\t\t \n\t\tif (of_property_read_u32(np, \"aspeed,mcr-configuration\",\n\t\t\t\t\t &mcr_cfg))\n\t\t\tmcr_cfg = 0x00000577;\n\t\tif (of_property_read_u32(np, \"aspeed,mcr-scu-mpll\",\n\t\t\t\t\t &mcr_scu_mpll))\n\t\t\tmcr_scu_mpll = 0x000050C0;\n\t\tif (of_property_read_u32(np, \"aspeed,mcr-scu-strap\",\n\t\t\t\t\t &mcr_scu_strap))\n\t\t\tmcr_scu_strap = 0;\n\t\tbreak;\n\tcase ast_use_p2a:\n\t\tast_write32(ast, 0xf004, 0x1e6e0000);\n\t\tast_write32(ast, 0xf000, 0x1);\n\t\tmcr_cfg = ast_read32(ast, 0x10004);\n\t\tmcr_scu_mpll = ast_read32(ast, 0x10120);\n\t\tmcr_scu_strap = ast_read32(ast, 0x10170);\n\t\tbreak;\n\tcase ast_use_defaults:\n\tdefault:\n\t\tast->dram_bus_width = 16;\n\t\tast->dram_type = AST_DRAM_1Gx16;\n\t\tif (IS_AST_GEN6(ast))\n\t\t\tast->mclk = 800;\n\t\telse\n\t\t\tast->mclk = 396;\n\t\treturn 0;\n\t}\n\n\tif (mcr_cfg & 0x40)\n\t\tast->dram_bus_width = 16;\n\telse\n\t\tast->dram_bus_width = 32;\n\n\tif (IS_AST_GEN6(ast)) {\n\t\tswitch (mcr_cfg & 0x03) {\n\t\tcase 0:\n\t\t\tast->dram_type = AST_DRAM_1Gx16;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 1:\n\t\t\tast->dram_type = AST_DRAM_2Gx16;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tast->dram_type = AST_DRAM_4Gx16;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tast->dram_type = AST_DRAM_8Gx16;\n\t\t\tbreak;\n\t\t}\n\t} else if (IS_AST_GEN4(ast) || IS_AST_GEN5(ast)) {\n\t\tswitch (mcr_cfg & 0x03) {\n\t\tcase 0:\n\t\t\tast->dram_type = AST_DRAM_512Mx16;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 1:\n\t\t\tast->dram_type = AST_DRAM_1Gx16;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tast->dram_type = AST_DRAM_2Gx16;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tast->dram_type = AST_DRAM_4Gx16;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (mcr_cfg & 0x0c) {\n\t\tcase 0:\n\t\tcase 4:\n\t\t\tast->dram_type = AST_DRAM_512Mx16;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (mcr_cfg & 0x40)\n\t\t\t\tast->dram_type = AST_DRAM_1Gx16;\n\t\t\telse\n\t\t\t\tast->dram_type = AST_DRAM_512Mx32;\n\t\t\tbreak;\n\t\tcase 0xc:\n\t\t\tast->dram_type = AST_DRAM_1Gx32;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mcr_scu_strap & 0x2000)\n\t\tref_pll = 14318;\n\telse\n\t\tref_pll = 12000;\n\n\tdenum = mcr_scu_mpll & 0x1f;\n\tnum = (mcr_scu_mpll & 0x3fe0) >> 5;\n\tdsel = (mcr_scu_mpll & 0xc000) >> 14;\n\tswitch (dsel) {\n\tcase 3:\n\t\tdiv = 0x4;\n\t\tbreak;\n\tcase 2:\n\tcase 1:\n\t\tdiv = 0x2;\n\t\tbreak;\n\tdefault:\n\t\tdiv = 0x1;\n\t\tbreak;\n\t}\n\tast->mclk = ref_pll * (num + 2) / ((denum + 2) * (div * 1000));\n\treturn 0;\n}\n\nstruct ast_device *ast_device_create(const struct drm_driver *drv,\n\t\t\t\t     struct pci_dev *pdev,\n\t\t\t\t     unsigned long flags)\n{\n\tstruct drm_device *dev;\n\tstruct ast_device *ast;\n\tbool need_post = false;\n\tint ret = 0;\n\n\tast = devm_drm_dev_alloc(&pdev->dev, drv, struct ast_device, base);\n\tif (IS_ERR(ast))\n\t\treturn ast;\n\tdev = &ast->base;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tret = drmm_mutex_init(dev, &ast->ioregs_lock);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tast->regs = pcim_iomap(pdev, 1, 0);\n\tif (!ast->regs)\n\t\treturn ERR_PTR(-EIO);\n\n\t \n\tif (pdev->revision >= 0x40) {\n\t\tast->ioregs = ast->regs + AST_IO_MM_OFFSET;\n\t} else if (!(pci_resource_flags(pdev, 2) & IORESOURCE_IO)) {\n\t\tdrm_info(dev, \"platform has no IO space, trying MMIO\\n\");\n\t\tast->ioregs = ast->regs + AST_IO_MM_OFFSET;\n\t}\n\n\t \n\tif (!ast->ioregs) {\n\t\tast->ioregs = pcim_iomap(pdev, 2, 0);\n\t\tif (!ast->ioregs)\n\t\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tif (!ast_is_vga_enabled(dev)) {\n\t\tdrm_info(dev, \"VGA not enabled on entry, requesting chip POST\\n\");\n\t\tneed_post = true;\n\t}\n\n\t \n\tif (need_post)\n\t\tast_enable_vga(dev);\n\n\t \n\tast_open_key(ast);\n\tret = ast_enable_mmio(ast);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = ast_device_config_init(ast);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tast_detect_widescreen(ast);\n\tast_detect_tx_chip(ast, need_post);\n\n\tret = ast_get_dram_info(dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdrm_info(dev, \"dram MCLK=%u Mhz type=%d bus_width=%d\\n\",\n\t\t ast->mclk, ast->dram_type, ast->dram_bus_width);\n\n\tif (need_post)\n\t\tast_post_gpu(dev);\n\n\tret = ast_mm_init(ast);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tast->dp501_fw_buf = NULL;\n\tif (ast->vram_size < pci_resource_len(pdev, 0)) {\n\t\tast->dp501_fw_buf = pci_iomap_range(pdev, 0, ast->vram_size, 0);\n\t\tif (!ast->dp501_fw_buf)\n\t\t\tdrm_info(dev, \"failed to map reserved buffer!\\n\");\n\t}\n\n\tret = ast_mode_config_init(ast);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn ast;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}