{
  "module_name": "drm_blend.c",
  "hash_id": "ef0ea536a8d5c4f9309b69e757dcbeeb599189aa3797c41a6a2c8b14d34c888f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_blend.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_device.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n\n \n\n \nint drm_plane_create_alpha_property(struct drm_plane *plane)\n{\n\tstruct drm_property *prop;\n\n\tprop = drm_property_create_range(plane->dev, 0, \"alpha\",\n\t\t\t\t\t 0, DRM_BLEND_ALPHA_OPAQUE);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\n\tdrm_object_attach_property(&plane->base, prop, DRM_BLEND_ALPHA_OPAQUE);\n\tplane->alpha_property = prop;\n\n\tif (plane->state)\n\t\tplane->state->alpha = DRM_BLEND_ALPHA_OPAQUE;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_plane_create_alpha_property);\n\n \nint drm_plane_create_rotation_property(struct drm_plane *plane,\n\t\t\t\t       unsigned int rotation,\n\t\t\t\t       unsigned int supported_rotations)\n{\n\tstatic const struct drm_prop_enum_list props[] = {\n\t\t{ __builtin_ffs(DRM_MODE_ROTATE_0) - 1,   \"rotate-0\" },\n\t\t{ __builtin_ffs(DRM_MODE_ROTATE_90) - 1,  \"rotate-90\" },\n\t\t{ __builtin_ffs(DRM_MODE_ROTATE_180) - 1, \"rotate-180\" },\n\t\t{ __builtin_ffs(DRM_MODE_ROTATE_270) - 1, \"rotate-270\" },\n\t\t{ __builtin_ffs(DRM_MODE_REFLECT_X) - 1,  \"reflect-x\" },\n\t\t{ __builtin_ffs(DRM_MODE_REFLECT_Y) - 1,  \"reflect-y\" },\n\t};\n\tstruct drm_property *prop;\n\n\tWARN_ON((supported_rotations & DRM_MODE_ROTATE_MASK) == 0);\n\tWARN_ON(!is_power_of_2(rotation & DRM_MODE_ROTATE_MASK));\n\tWARN_ON(rotation & ~supported_rotations);\n\n\tprop = drm_property_create_bitmask(plane->dev, 0, \"rotation\",\n\t\t\t\t\t   props, ARRAY_SIZE(props),\n\t\t\t\t\t   supported_rotations);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\n\tdrm_object_attach_property(&plane->base, prop, rotation);\n\n\tif (plane->state)\n\t\tplane->state->rotation = rotation;\n\n\tplane->rotation_property = prop;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_plane_create_rotation_property);\n\n \nunsigned int drm_rotation_simplify(unsigned int rotation,\n\t\t\t\t   unsigned int supported_rotations)\n{\n\tif (rotation & ~supported_rotations) {\n\t\trotation ^= DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y;\n\t\trotation = (rotation & DRM_MODE_REFLECT_MASK) |\n\t\t\t    BIT((ffs(rotation & DRM_MODE_ROTATE_MASK) + 1)\n\t\t\t    % 4);\n\t}\n\n\treturn rotation;\n}\nEXPORT_SYMBOL(drm_rotation_simplify);\n\n \nint drm_plane_create_zpos_property(struct drm_plane *plane,\n\t\t\t\t   unsigned int zpos,\n\t\t\t\t   unsigned int min, unsigned int max)\n{\n\tstruct drm_property *prop;\n\n\tprop = drm_property_create_range(plane->dev, 0, \"zpos\", min, max);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\n\tdrm_object_attach_property(&plane->base, prop, zpos);\n\n\tplane->zpos_property = prop;\n\n\tif (plane->state) {\n\t\tplane->state->zpos = zpos;\n\t\tplane->state->normalized_zpos = zpos;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_plane_create_zpos_property);\n\n \nint drm_plane_create_zpos_immutable_property(struct drm_plane *plane,\n\t\t\t\t\t     unsigned int zpos)\n{\n\tstruct drm_property *prop;\n\n\tprop = drm_property_create_range(plane->dev, DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t\t \"zpos\", zpos, zpos);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\n\tdrm_object_attach_property(&plane->base, prop, zpos);\n\n\tplane->zpos_property = prop;\n\n\tif (plane->state) {\n\t\tplane->state->zpos = zpos;\n\t\tplane->state->normalized_zpos = zpos;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_plane_create_zpos_immutable_property);\n\nstatic int drm_atomic_state_zpos_cmp(const void *a, const void *b)\n{\n\tconst struct drm_plane_state *sa = *(struct drm_plane_state **)a;\n\tconst struct drm_plane_state *sb = *(struct drm_plane_state **)b;\n\n\tif (sa->zpos != sb->zpos)\n\t\treturn sa->zpos - sb->zpos;\n\telse\n\t\treturn sa->plane->base.id - sb->plane->base.id;\n}\n\nstatic int drm_atomic_helper_crtc_normalize_zpos(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_crtc_state *crtc_state)\n{\n\tstruct drm_atomic_state *state = crtc_state->state;\n\tstruct drm_device *dev = crtc->dev;\n\tint total_planes = dev->mode_config.num_total_plane;\n\tstruct drm_plane_state **states;\n\tstruct drm_plane *plane;\n\tint i, n = 0;\n\tint ret = 0;\n\n\tdrm_dbg_atomic(dev, \"[CRTC:%d:%s] calculating normalized zpos values\\n\",\n\t\t       crtc->base.id, crtc->name);\n\n\tstates = kmalloc_array(total_planes, sizeof(*states), GFP_KERNEL);\n\tif (!states)\n\t\treturn -ENOMEM;\n\n\t \n\tdrm_for_each_plane_mask(plane, dev, crtc_state->plane_mask) {\n\t\tstruct drm_plane_state *plane_state =\n\t\t\tdrm_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_state)) {\n\t\t\tret = PTR_ERR(plane_state);\n\t\t\tgoto done;\n\t\t}\n\t\tstates[n++] = plane_state;\n\t\tdrm_dbg_atomic(dev, \"[PLANE:%d:%s] processing zpos value %d\\n\",\n\t\t\t       plane->base.id, plane->name, plane_state->zpos);\n\t}\n\n\tsort(states, n, sizeof(*states), drm_atomic_state_zpos_cmp, NULL);\n\n\tfor (i = 0; i < n; i++) {\n\t\tplane = states[i]->plane;\n\n\t\tstates[i]->normalized_zpos = i;\n\t\tdrm_dbg_atomic(dev, \"[PLANE:%d:%s] normalized zpos value %d\\n\",\n\t\t\t       plane->base.id, plane->name, i);\n\t}\n\tcrtc_state->zpos_changed = true;\n\ndone:\n\tkfree(states);\n\treturn ret;\n}\n\n \nint drm_atomic_normalize_zpos(struct drm_device *dev,\n\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state, *new_plane_state;\n\tint i, ret = 0;\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\tcrtc = new_plane_state->crtc;\n\t\tif (!crtc)\n\t\t\tcontinue;\n\t\tif (old_plane_state->zpos != new_plane_state->zpos) {\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\t\t\tnew_crtc_state->zpos_changed = true;\n\t\t}\n\t}\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tif (old_crtc_state->plane_mask != new_crtc_state->plane_mask ||\n\t\t    new_crtc_state->zpos_changed) {\n\t\t\tret = drm_atomic_helper_crtc_normalize_zpos(crtc,\n\t\t\t\t\t\t\t\t    new_crtc_state);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_normalize_zpos);\n\n \nint drm_plane_create_blend_mode_property(struct drm_plane *plane,\n\t\t\t\t\t unsigned int supported_modes)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct drm_property *prop;\n\tstatic const struct drm_prop_enum_list props[] = {\n\t\t{ DRM_MODE_BLEND_PIXEL_NONE, \"None\" },\n\t\t{ DRM_MODE_BLEND_PREMULTI, \"Pre-multiplied\" },\n\t\t{ DRM_MODE_BLEND_COVERAGE, \"Coverage\" },\n\t};\n\tunsigned int valid_mode_mask = BIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\t       BIT(DRM_MODE_BLEND_PREMULTI)   |\n\t\t\t\t       BIT(DRM_MODE_BLEND_COVERAGE);\n\tint i;\n\n\tif (WARN_ON((supported_modes & ~valid_mode_mask) ||\n\t\t    ((supported_modes & BIT(DRM_MODE_BLEND_PREMULTI)) == 0)))\n\t\treturn -EINVAL;\n\n\tprop = drm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t   \"pixel blend mode\",\n\t\t\t\t   hweight32(supported_modes));\n\tif (!prop)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(props); i++) {\n\t\tint ret;\n\n\t\tif (!(BIT(props[i].type) & supported_modes))\n\t\t\tcontinue;\n\n\t\tret = drm_property_add_enum(prop, props[i].type,\n\t\t\t\t\t    props[i].name);\n\n\t\tif (ret) {\n\t\t\tdrm_property_destroy(dev, prop);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdrm_object_attach_property(&plane->base, prop, DRM_MODE_BLEND_PREMULTI);\n\tplane->blend_mode_property = prop;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_plane_create_blend_mode_property);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}