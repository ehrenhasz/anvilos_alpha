{
  "module_name": "vmwgfx_shader.c",
  "hash_id": "1826ffb0877d0d663e09c1169f1c3b64a209eaa7efa72e79f2b4cc9a82c5985b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c",
  "human_readable_source": "\n \n\n#include <drm/ttm/ttm_placement.h>\n\n#include \"vmwgfx_binding.h\"\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_resource_priv.h\"\n\nstruct vmw_shader {\n\tstruct vmw_resource res;\n\tSVGA3dShaderType type;\n\tuint32_t size;\n\tuint8_t num_input_sig;\n\tuint8_t num_output_sig;\n};\n\nstruct vmw_user_shader {\n\tstruct ttm_base_object base;\n\tstruct vmw_shader shader;\n};\n\nstruct vmw_dx_shader {\n\tstruct vmw_resource res;\n\tstruct vmw_resource *ctx;\n\tstruct vmw_resource *cotable;\n\tu32 id;\n\tbool committed;\n\tstruct list_head cotable_head;\n};\n\nstatic void vmw_user_shader_free(struct vmw_resource *res);\nstatic struct vmw_resource *\nvmw_user_shader_base_to_res(struct ttm_base_object *base);\n\nstatic int vmw_gb_shader_create(struct vmw_resource *res);\nstatic int vmw_gb_shader_bind(struct vmw_resource *res,\n\t\t\t       struct ttm_validate_buffer *val_buf);\nstatic int vmw_gb_shader_unbind(struct vmw_resource *res,\n\t\t\t\t bool readback,\n\t\t\t\t struct ttm_validate_buffer *val_buf);\nstatic int vmw_gb_shader_destroy(struct vmw_resource *res);\n\nstatic int vmw_dx_shader_create(struct vmw_resource *res);\nstatic int vmw_dx_shader_bind(struct vmw_resource *res,\n\t\t\t       struct ttm_validate_buffer *val_buf);\nstatic int vmw_dx_shader_unbind(struct vmw_resource *res,\n\t\t\t\t bool readback,\n\t\t\t\t struct ttm_validate_buffer *val_buf);\nstatic void vmw_dx_shader_commit_notify(struct vmw_resource *res,\n\t\t\t\t\tenum vmw_cmdbuf_res_state state);\nstatic bool vmw_shader_id_ok(u32 user_key, SVGA3dShaderType shader_type);\nstatic u32 vmw_shader_key(u32 user_key, SVGA3dShaderType shader_type);\n\nstatic const struct vmw_user_resource_conv user_shader_conv = {\n\t.object_type = VMW_RES_SHADER,\n\t.base_obj_to_res = vmw_user_shader_base_to_res,\n\t.res_free = vmw_user_shader_free\n};\n\nconst struct vmw_user_resource_conv *user_shader_converter =\n\t&user_shader_conv;\n\n\nstatic const struct vmw_res_func vmw_gb_shader_func = {\n\t.res_type = vmw_res_shader,\n\t.needs_guest_memory = true,\n\t.may_evict = true,\n\t.prio = 3,\n\t.dirty_prio = 3,\n\t.type_name = \"guest backed shaders\",\n\t.domain = VMW_BO_DOMAIN_MOB,\n\t.busy_domain = VMW_BO_DOMAIN_MOB,\n\t.create = vmw_gb_shader_create,\n\t.destroy = vmw_gb_shader_destroy,\n\t.bind = vmw_gb_shader_bind,\n\t.unbind = vmw_gb_shader_unbind\n};\n\nstatic const struct vmw_res_func vmw_dx_shader_func = {\n\t.res_type = vmw_res_shader,\n\t.needs_guest_memory = true,\n\t.may_evict = true,\n\t.prio = 3,\n\t.dirty_prio = 3,\n\t.type_name = \"dx shaders\",\n\t.domain = VMW_BO_DOMAIN_MOB,\n\t.busy_domain = VMW_BO_DOMAIN_MOB,\n\t.create = vmw_dx_shader_create,\n\t \n\t.destroy = NULL,\n\t.bind = vmw_dx_shader_bind,\n\t.unbind = vmw_dx_shader_unbind,\n\t.commit_notify = vmw_dx_shader_commit_notify,\n};\n\n \n\nstatic inline struct vmw_shader *\nvmw_res_to_shader(struct vmw_resource *res)\n{\n\treturn container_of(res, struct vmw_shader, res);\n}\n\n \nstatic inline struct vmw_dx_shader *\nvmw_res_to_dx_shader(struct vmw_resource *res)\n{\n\treturn container_of(res, struct vmw_dx_shader, res);\n}\n\nstatic void vmw_hw_shader_destroy(struct vmw_resource *res)\n{\n\tif (likely(res->func->destroy))\n\t\t(void) res->func->destroy(res);\n\telse\n\t\tres->id = -1;\n}\n\n\nstatic int vmw_gb_shader_init(struct vmw_private *dev_priv,\n\t\t\t      struct vmw_resource *res,\n\t\t\t      uint32_t size,\n\t\t\t      uint64_t offset,\n\t\t\t      SVGA3dShaderType type,\n\t\t\t      uint8_t num_input_sig,\n\t\t\t      uint8_t num_output_sig,\n\t\t\t      struct vmw_bo *byte_code,\n\t\t\t      void (*res_free) (struct vmw_resource *res))\n{\n\tstruct vmw_shader *shader = vmw_res_to_shader(res);\n\tint ret;\n\n\tret = vmw_resource_init(dev_priv, res, true, res_free,\n\t\t\t\t&vmw_gb_shader_func);\n\n\tif (unlikely(ret != 0)) {\n\t\tif (res_free)\n\t\t\tres_free(res);\n\t\telse\n\t\t\tkfree(res);\n\t\treturn ret;\n\t}\n\n\tres->guest_memory_size = size;\n\tif (byte_code) {\n\t\tres->guest_memory_bo = vmw_user_bo_ref(byte_code);\n\t\tres->guest_memory_offset = offset;\n\t}\n\tshader->size = size;\n\tshader->type = type;\n\tshader->num_input_sig = num_input_sig;\n\tshader->num_output_sig = num_output_sig;\n\n\tres->hw_destroy = vmw_hw_shader_destroy;\n\treturn 0;\n}\n\n \n\nstatic int vmw_gb_shader_create(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct vmw_shader *shader = vmw_res_to_shader(res);\n\tint ret;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDefineGBShader body;\n\t} *cmd;\n\n\tif (likely(res->id != -1))\n\t\treturn 0;\n\n\tret = vmw_resource_alloc_id(res);\n\tif (unlikely(ret != 0)) {\n\t\tDRM_ERROR(\"Failed to allocate a shader id.\\n\");\n\t\tgoto out_no_id;\n\t}\n\n\tif (unlikely(res->id >= VMWGFX_NUM_GB_SHADER)) {\n\t\tret = -EBUSY;\n\t\tgoto out_no_fifo;\n\t}\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_fifo;\n\t}\n\n\tcmd->header.id = SVGA_3D_CMD_DEFINE_GB_SHADER;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.shid = res->id;\n\tcmd->body.type = shader->type;\n\tcmd->body.sizeInBytes = shader->size;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\tvmw_fifo_resource_inc(dev_priv);\n\n\treturn 0;\n\nout_no_fifo:\n\tvmw_resource_release_id(res);\nout_no_id:\n\treturn ret;\n}\n\nstatic int vmw_gb_shader_bind(struct vmw_resource *res,\n\t\t\t      struct ttm_validate_buffer *val_buf)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdBindGBShader body;\n\t} *cmd;\n\tstruct ttm_buffer_object *bo = val_buf->bo;\n\n\tBUG_ON(bo->resource->mem_type != VMW_PL_MOB);\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_BIND_GB_SHADER;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.shid = res->id;\n\tcmd->body.mobid = bo->resource->start;\n\tcmd->body.offsetInBytes = res->guest_memory_offset;\n\tres->guest_memory_dirty = false;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\treturn 0;\n}\n\nstatic int vmw_gb_shader_unbind(struct vmw_resource *res,\n\t\t\t\tbool readback,\n\t\t\t\tstruct ttm_validate_buffer *val_buf)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdBindGBShader body;\n\t} *cmd;\n\tstruct vmw_fence_obj *fence;\n\n\tBUG_ON(res->guest_memory_bo->tbo.resource->mem_type != VMW_PL_MOB);\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_BIND_GB_SHADER;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.shid = res->id;\n\tcmd->body.mobid = SVGA3D_INVALID_ID;\n\tcmd->body.offsetInBytes = 0;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\t \n\n\t(void) vmw_execbuf_fence_commands(NULL, dev_priv,\n\t\t\t\t\t  &fence, NULL);\n\n\tvmw_bo_fence_single(val_buf->bo, fence);\n\n\tif (likely(fence != NULL))\n\t\tvmw_fence_obj_unreference(&fence);\n\n\treturn 0;\n}\n\nstatic int vmw_gb_shader_destroy(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDestroyGBShader body;\n\t} *cmd;\n\n\tif (likely(res->id == -1))\n\t\treturn 0;\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tvmw_binding_res_list_scrub(&res->binding_head);\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL)) {\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd->header.id = SVGA_3D_CMD_DESTROY_GB_SHADER;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.shid = res->id;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\tmutex_unlock(&dev_priv->binding_mutex);\n\tvmw_resource_release_id(res);\n\tvmw_fifo_resource_dec(dev_priv);\n\n\treturn 0;\n}\n\n \n\n \nstatic void vmw_dx_shader_commit_notify(struct vmw_resource *res,\n\t\t\t\t\tenum vmw_cmdbuf_res_state state)\n{\n\tstruct vmw_dx_shader *shader = vmw_res_to_dx_shader(res);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\n\tif (state == VMW_CMDBUF_RES_ADD) {\n\t\tmutex_lock(&dev_priv->binding_mutex);\n\t\tvmw_cotable_add_resource(shader->cotable,\n\t\t\t\t\t &shader->cotable_head);\n\t\tshader->committed = true;\n\t\tres->id = shader->id;\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t} else {\n\t\tmutex_lock(&dev_priv->binding_mutex);\n\t\tlist_del_init(&shader->cotable_head);\n\t\tshader->committed = false;\n\t\tres->id = -1;\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t}\n}\n\n \nstatic int vmw_dx_shader_unscrub(struct vmw_resource *res)\n{\n\tstruct vmw_dx_shader *shader = vmw_res_to_dx_shader(res);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXBindShader body;\n\t} *cmd;\n\n\tif (!list_empty(&shader->cotable_head) || !shader->committed)\n\t\treturn 0;\n\n\tcmd = VMW_CMD_CTX_RESERVE(dev_priv, sizeof(*cmd), shader->ctx->id);\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_DX_BIND_SHADER;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = shader->ctx->id;\n\tcmd->body.shid = shader->id;\n\tcmd->body.mobid = res->guest_memory_bo->tbo.resource->start;\n\tcmd->body.offsetInBytes = res->guest_memory_offset;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\tvmw_cotable_add_resource(shader->cotable, &shader->cotable_head);\n\n\treturn 0;\n}\n\n \nstatic int vmw_dx_shader_create(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct vmw_dx_shader *shader = vmw_res_to_dx_shader(res);\n\tint ret = 0;\n\n\tWARN_ON_ONCE(!shader->committed);\n\n\tif (vmw_resource_mob_attached(res)) {\n\t\tmutex_lock(&dev_priv->binding_mutex);\n\t\tret = vmw_dx_shader_unscrub(res);\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t}\n\n\tres->id = shader->id;\n\treturn ret;\n}\n\n \nstatic int vmw_dx_shader_bind(struct vmw_resource *res,\n\t\t\t      struct ttm_validate_buffer *val_buf)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct ttm_buffer_object *bo = val_buf->bo;\n\n\tBUG_ON(bo->resource->mem_type != VMW_PL_MOB);\n\tmutex_lock(&dev_priv->binding_mutex);\n\tvmw_dx_shader_unscrub(res);\n\tmutex_unlock(&dev_priv->binding_mutex);\n\n\treturn 0;\n}\n\n \nstatic int vmw_dx_shader_scrub(struct vmw_resource *res)\n{\n\tstruct vmw_dx_shader *shader = vmw_res_to_dx_shader(res);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXBindShader body;\n\t} *cmd;\n\n\tif (list_empty(&shader->cotable_head))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!shader->committed);\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_DX_BIND_SHADER;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = shader->ctx->id;\n\tcmd->body.shid = res->id;\n\tcmd->body.mobid = SVGA3D_INVALID_ID;\n\tcmd->body.offsetInBytes = 0;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\tres->id = -1;\n\tlist_del_init(&shader->cotable_head);\n\n\treturn 0;\n}\n\n \nstatic int vmw_dx_shader_unbind(struct vmw_resource *res,\n\t\t\t\tbool readback,\n\t\t\t\tstruct ttm_validate_buffer *val_buf)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct vmw_fence_obj *fence;\n\tint ret;\n\n\tBUG_ON(res->guest_memory_bo->tbo.resource->mem_type != VMW_PL_MOB);\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tret = vmw_dx_shader_scrub(res);\n\tmutex_unlock(&dev_priv->binding_mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\t(void) vmw_execbuf_fence_commands(NULL, dev_priv,\n\t\t\t\t\t  &fence, NULL);\n\tvmw_bo_fence_single(val_buf->bo, fence);\n\n\tif (likely(fence != NULL))\n\t\tvmw_fence_obj_unreference(&fence);\n\n\treturn 0;\n}\n\n \nvoid vmw_dx_shader_cotable_list_scrub(struct vmw_private *dev_priv,\n\t\t\t\t      struct list_head *list,\n\t\t\t\t      bool readback)\n{\n\tstruct vmw_dx_shader *entry, *next;\n\n\tlockdep_assert_held_once(&dev_priv->binding_mutex);\n\n\tlist_for_each_entry_safe(entry, next, list, cotable_head) {\n\t\tWARN_ON(vmw_dx_shader_scrub(&entry->res));\n\t\tif (!readback)\n\t\t\tentry->committed = false;\n\t}\n}\n\n \nstatic void vmw_dx_shader_res_free(struct vmw_resource *res)\n{\n\tstruct vmw_dx_shader *shader = vmw_res_to_dx_shader(res);\n\n\tvmw_resource_unreference(&shader->cotable);\n\tkfree(shader);\n}\n\n \nint vmw_dx_shader_add(struct vmw_cmdbuf_res_manager *man,\n\t\t      struct vmw_resource *ctx,\n\t\t      u32 user_key,\n\t\t      SVGA3dShaderType shader_type,\n\t\t      struct list_head *list)\n{\n\tstruct vmw_dx_shader *shader;\n\tstruct vmw_resource *res;\n\tstruct vmw_private *dev_priv = ctx->dev_priv;\n\tint ret;\n\n\tif (!vmw_shader_id_ok(user_key, shader_type))\n\t\treturn -EINVAL;\n\n\tshader = kmalloc(sizeof(*shader), GFP_KERNEL);\n\tif (!shader) {\n\t\treturn -ENOMEM;\n\t}\n\n\tres = &shader->res;\n\tshader->ctx = ctx;\n\tshader->cotable = vmw_resource_reference\n\t\t(vmw_context_cotable(ctx, SVGA_COTABLE_DXSHADER));\n\tshader->id = user_key;\n\tshader->committed = false;\n\tINIT_LIST_HEAD(&shader->cotable_head);\n\tret = vmw_resource_init(dev_priv, res, true,\n\t\t\t\tvmw_dx_shader_res_free, &vmw_dx_shader_func);\n\tif (ret)\n\t\tgoto out_resource_init;\n\n\t \n\tret = vmw_cmdbuf_res_add(man, vmw_cmdbuf_res_shader,\n\t\t\t\t vmw_shader_key(user_key, 0),\n\t\t\t\t res, list);\n\tif (ret)\n\t\tgoto out_resource_init;\n\n\tres->id = shader->id;\n\tres->hw_destroy = vmw_hw_shader_destroy;\n\nout_resource_init:\n\tvmw_resource_unreference(&res);\n\n\treturn ret;\n}\n\n\n\n \n\nstatic struct vmw_resource *\nvmw_user_shader_base_to_res(struct ttm_base_object *base)\n{\n\treturn &(container_of(base, struct vmw_user_shader, base)->\n\t\t shader.res);\n}\n\nstatic void vmw_user_shader_free(struct vmw_resource *res)\n{\n\tstruct vmw_user_shader *ushader =\n\t\tcontainer_of(res, struct vmw_user_shader, shader.res);\n\n\tttm_base_object_kfree(ushader, base);\n}\n\nstatic void vmw_shader_free(struct vmw_resource *res)\n{\n\tstruct vmw_shader *shader = vmw_res_to_shader(res);\n\n\tkfree(shader);\n}\n\n \n\nstatic void vmw_user_shader_base_release(struct ttm_base_object **p_base)\n{\n\tstruct ttm_base_object *base = *p_base;\n\tstruct vmw_resource *res = vmw_user_shader_base_to_res(base);\n\n\t*p_base = NULL;\n\tvmw_resource_unreference(&res);\n}\n\nint vmw_shader_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_vmw_shader_arg *arg = (struct drm_vmw_shader_arg *)data;\n\tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n\n\treturn ttm_ref_object_base_unref(tfile, arg->handle);\n}\n\nstatic int vmw_user_shader_alloc(struct vmw_private *dev_priv,\n\t\t\t\t struct vmw_bo *buffer,\n\t\t\t\t size_t shader_size,\n\t\t\t\t size_t offset,\n\t\t\t\t SVGA3dShaderType shader_type,\n\t\t\t\t uint8_t num_input_sig,\n\t\t\t\t uint8_t num_output_sig,\n\t\t\t\t struct ttm_object_file *tfile,\n\t\t\t\t u32 *handle)\n{\n\tstruct vmw_user_shader *ushader;\n\tstruct vmw_resource *res, *tmp;\n\tint ret;\n\n\tushader = kzalloc(sizeof(*ushader), GFP_KERNEL);\n\tif (unlikely(!ushader)) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tres = &ushader->shader.res;\n\tushader->base.shareable = false;\n\tushader->base.tfile = NULL;\n\n\t \n\n\tret = vmw_gb_shader_init(dev_priv, res, shader_size,\n\t\t\t\t offset, shader_type, num_input_sig,\n\t\t\t\t num_output_sig, buffer,\n\t\t\t\t vmw_user_shader_free);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\ttmp = vmw_resource_reference(res);\n\tret = ttm_base_object_init(tfile, &ushader->base, false,\n\t\t\t\t   VMW_RES_SHADER,\n\t\t\t\t   &vmw_user_shader_base_release);\n\n\tif (unlikely(ret != 0)) {\n\t\tvmw_resource_unreference(&tmp);\n\t\tgoto out_err;\n\t}\n\n\tif (handle)\n\t\t*handle = ushader->base.handle;\nout_err:\n\tvmw_resource_unreference(&res);\nout:\n\treturn ret;\n}\n\n\nstatic struct vmw_resource *vmw_shader_alloc(struct vmw_private *dev_priv,\n\t\t\t\t\t     struct vmw_bo *buffer,\n\t\t\t\t\t     size_t shader_size,\n\t\t\t\t\t     size_t offset,\n\t\t\t\t\t     SVGA3dShaderType shader_type)\n{\n\tstruct vmw_shader *shader;\n\tstruct vmw_resource *res;\n\tint ret;\n\n\tshader = kzalloc(sizeof(*shader), GFP_KERNEL);\n\tif (unlikely(!shader)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tres = &shader->res;\n\n\t \n\tret = vmw_gb_shader_init(dev_priv, res, shader_size,\n\t\t\t\t offset, shader_type, 0, 0, buffer,\n\t\t\t\t vmw_shader_free);\n\nout_err:\n\treturn ret ? ERR_PTR(ret) : res;\n}\n\n\nstatic int vmw_shader_define(struct drm_device *dev, struct drm_file *file_priv,\n\t\t\t     enum drm_vmw_shader_type shader_type_drm,\n\t\t\t     u32 buffer_handle, size_t size, size_t offset,\n\t\t\t     uint8_t num_input_sig, uint8_t num_output_sig,\n\t\t\t     uint32_t *shader_handle)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n\tstruct vmw_bo *buffer = NULL;\n\tSVGA3dShaderType shader_type;\n\tint ret;\n\n\tif (buffer_handle != SVGA3D_INVALID_ID) {\n\t\tret = vmw_user_bo_lookup(file_priv, buffer_handle, &buffer);\n\t\tif (unlikely(ret != 0)) {\n\t\t\tVMW_DEBUG_USER(\"Couldn't find buffer for shader creation.\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif ((u64)buffer->tbo.base.size < (u64)size + (u64)offset) {\n\t\t\tVMW_DEBUG_USER(\"Illegal buffer- or shader size.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_bad_arg;\n\t\t}\n\t}\n\n\tswitch (shader_type_drm) {\n\tcase drm_vmw_shader_type_vs:\n\t\tshader_type = SVGA3D_SHADERTYPE_VS;\n\t\tbreak;\n\tcase drm_vmw_shader_type_ps:\n\t\tshader_type = SVGA3D_SHADERTYPE_PS;\n\t\tbreak;\n\tdefault:\n\t\tVMW_DEBUG_USER(\"Illegal shader type.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_bad_arg;\n\t}\n\n\tret = vmw_user_shader_alloc(dev_priv, buffer, size, offset,\n\t\t\t\t    shader_type, num_input_sig,\n\t\t\t\t    num_output_sig, tfile, shader_handle);\nout_bad_arg:\n\tvmw_user_bo_unref(&buffer);\n\treturn ret;\n}\n\n \nstatic bool vmw_shader_id_ok(u32 user_key, SVGA3dShaderType shader_type)\n{\n\treturn user_key <= ((1 << 20) - 1) && (unsigned) shader_type < 16;\n}\n\n \nstatic u32 vmw_shader_key(u32 user_key, SVGA3dShaderType shader_type)\n{\n\treturn user_key | (shader_type << 20);\n}\n\n \nint vmw_shader_remove(struct vmw_cmdbuf_res_manager *man,\n\t\t      u32 user_key, SVGA3dShaderType shader_type,\n\t\t      struct list_head *list)\n{\n\tstruct vmw_resource *dummy;\n\n\tif (!vmw_shader_id_ok(user_key, shader_type))\n\t\treturn -EINVAL;\n\n\treturn vmw_cmdbuf_res_remove(man, vmw_cmdbuf_res_shader,\n\t\t\t\t     vmw_shader_key(user_key, shader_type),\n\t\t\t\t     list, &dummy);\n}\n\n \nint vmw_compat_shader_add(struct vmw_private *dev_priv,\n\t\t\t  struct vmw_cmdbuf_res_manager *man,\n\t\t\t  u32 user_key, const void *bytecode,\n\t\t\t  SVGA3dShaderType shader_type,\n\t\t\t  size_t size,\n\t\t\t  struct list_head *list)\n{\n\tstruct ttm_operation_ctx ctx = { false, true };\n\tstruct vmw_bo *buf;\n\tstruct ttm_bo_kmap_obj map;\n\tbool is_iomem;\n\tint ret;\n\tstruct vmw_resource *res;\n\tstruct vmw_bo_params bo_params = {\n\t\t.domain = VMW_BO_DOMAIN_SYS,\n\t\t.busy_domain = VMW_BO_DOMAIN_SYS,\n\t\t.bo_type = ttm_bo_type_device,\n\t\t.size = size,\n\t\t.pin = true\n\t};\n\n\tif (!vmw_shader_id_ok(user_key, shader_type))\n\t\treturn -EINVAL;\n\n\tret = vmw_bo_create(dev_priv, &bo_params, &buf);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tret = ttm_bo_reserve(&buf->tbo, false, true, NULL);\n\tif (unlikely(ret != 0))\n\t\tgoto no_reserve;\n\n\t \n\tret = ttm_bo_kmap(&buf->tbo, 0, PFN_UP(size), &map);\n\tif (unlikely(ret != 0)) {\n\t\tttm_bo_unreserve(&buf->tbo);\n\t\tgoto no_reserve;\n\t}\n\n\tmemcpy(ttm_kmap_obj_virtual(&map, &is_iomem), bytecode, size);\n\tWARN_ON(is_iomem);\n\n\tttm_bo_kunmap(&map);\n\tret = ttm_bo_validate(&buf->tbo, &buf->placement, &ctx);\n\tWARN_ON(ret != 0);\n\tttm_bo_unreserve(&buf->tbo);\n\n\tres = vmw_shader_alloc(dev_priv, buf, size, 0, shader_type);\n\tif (unlikely(ret != 0))\n\t\tgoto no_reserve;\n\n\tret = vmw_cmdbuf_res_add(man, vmw_cmdbuf_res_shader,\n\t\t\t\t vmw_shader_key(user_key, shader_type),\n\t\t\t\t res, list);\n\tvmw_resource_unreference(&res);\nno_reserve:\n\tvmw_bo_unreference(&buf);\nout:\n\treturn ret;\n}\n\n \nstruct vmw_resource *\nvmw_shader_lookup(struct vmw_cmdbuf_res_manager *man,\n\t\t  u32 user_key,\n\t\t  SVGA3dShaderType shader_type)\n{\n\tif (!vmw_shader_id_ok(user_key, shader_type))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn vmw_cmdbuf_res_lookup(man, vmw_cmdbuf_res_shader,\n\t\t\t\t     vmw_shader_key(user_key, shader_type));\n}\n\nint vmw_shader_define_ioctl(struct drm_device *dev, void *data,\n\t\t\t     struct drm_file *file_priv)\n{\n\tstruct drm_vmw_shader_create_arg *arg =\n\t\t(struct drm_vmw_shader_create_arg *)data;\n\n\treturn vmw_shader_define(dev, file_priv, arg->shader_type,\n\t\t\t\t arg->buffer_handle,\n\t\t\t\t arg->size, arg->offset,\n\t\t\t\t 0, 0,\n\t\t\t\t &arg->shader_handle);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}