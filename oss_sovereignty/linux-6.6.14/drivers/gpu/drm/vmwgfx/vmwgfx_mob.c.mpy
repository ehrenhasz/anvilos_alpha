{
  "module_name": "vmwgfx_mob.c",
  "hash_id": "a5bd25fd2d3a77b145f4616507b004789524302d802e069689539d6341f6e74e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_mob.c",
  "human_readable_source": "\n \n\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_drv.h\"\n\n#include <linux/highmem.h>\n\n#ifdef CONFIG_64BIT\n#define VMW_PPN_SIZE 8\n#define VMW_MOBFMT_PTDEPTH_0 SVGA3D_MOBFMT_PT64_0\n#define VMW_MOBFMT_PTDEPTH_1 SVGA3D_MOBFMT_PT64_1\n#define VMW_MOBFMT_PTDEPTH_2 SVGA3D_MOBFMT_PT64_2\n#else\n#define VMW_PPN_SIZE 4\n#define VMW_MOBFMT_PTDEPTH_0 SVGA3D_MOBFMT_PT_0\n#define VMW_MOBFMT_PTDEPTH_1 SVGA3D_MOBFMT_PT_1\n#define VMW_MOBFMT_PTDEPTH_2 SVGA3D_MOBFMT_PT_2\n#endif\n\n \nstruct vmw_mob {\n\tstruct vmw_bo *pt_bo;\n\tunsigned long num_pages;\n\tunsigned pt_level;\n\tdma_addr_t pt_root_page;\n\tuint32_t id;\n};\n\n \nstatic const struct vmw_otable pre_dx_tables[] = {\n\t{VMWGFX_NUM_MOB * sizeof(SVGAOTableMobEntry), NULL, true},\n\t{VMWGFX_NUM_GB_SURFACE * sizeof(SVGAOTableSurfaceEntry), NULL, true},\n\t{VMWGFX_NUM_GB_CONTEXT * sizeof(SVGAOTableContextEntry), NULL, true},\n\t{VMWGFX_NUM_GB_SHADER * sizeof(SVGAOTableShaderEntry), NULL, true},\n\t{VMWGFX_NUM_GB_SCREEN_TARGET * sizeof(SVGAOTableScreenTargetEntry),\n\t NULL, true}\n};\n\nstatic const struct vmw_otable dx_tables[] = {\n\t{VMWGFX_NUM_MOB * sizeof(SVGAOTableMobEntry), NULL, true},\n\t{VMWGFX_NUM_GB_SURFACE * sizeof(SVGAOTableSurfaceEntry), NULL, true},\n\t{VMWGFX_NUM_GB_CONTEXT * sizeof(SVGAOTableContextEntry), NULL, true},\n\t{VMWGFX_NUM_GB_SHADER * sizeof(SVGAOTableShaderEntry), NULL, true},\n\t{VMWGFX_NUM_GB_SCREEN_TARGET * sizeof(SVGAOTableScreenTargetEntry),\n\t NULL, true},\n\t{VMWGFX_NUM_DXCONTEXT * sizeof(SVGAOTableDXContextEntry), NULL, true},\n};\n\nstatic int vmw_mob_pt_populate(struct vmw_private *dev_priv,\n\t\t\t       struct vmw_mob *mob);\nstatic void vmw_mob_pt_setup(struct vmw_mob *mob,\n\t\t\t     struct vmw_piter data_iter,\n\t\t\t     unsigned long num_data_pages);\n\n\nstatic inline void vmw_bo_unpin_unlocked(struct ttm_buffer_object *bo)\n{\n\tint ret = ttm_bo_reserve(bo, false, true, NULL);\n\tBUG_ON(ret != 0);\n\tttm_bo_unpin(bo);\n\tttm_bo_unreserve(bo);\n}\n\n\n \nstatic int vmw_setup_otable_base(struct vmw_private *dev_priv,\n\t\t\t\t SVGAOTableType type,\n\t\t\t\t struct ttm_buffer_object *otable_bo,\n\t\t\t\t unsigned long offset,\n\t\t\t\t struct vmw_otable *otable)\n{\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdSetOTableBase64 body;\n\t} *cmd;\n\tstruct vmw_mob *mob;\n\tconst struct vmw_sg_table *vsgt;\n\tstruct vmw_piter iter;\n\tint ret;\n\n\tBUG_ON(otable->page_table != NULL);\n\n\tvsgt = vmw_bo_sg_table(otable_bo);\n\tvmw_piter_start(&iter, vsgt, offset >> PAGE_SHIFT);\n\tWARN_ON(!vmw_piter_next(&iter));\n\n\tmob = vmw_mob_create(otable->size >> PAGE_SHIFT);\n\tif (unlikely(mob == NULL)) {\n\t\tDRM_ERROR(\"Failed creating OTable page table.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (otable->size <= PAGE_SIZE) {\n\t\tmob->pt_level = VMW_MOBFMT_PTDEPTH_0;\n\t\tmob->pt_root_page = vmw_piter_dma_addr(&iter);\n\t} else {\n\t\tret = vmw_mob_pt_populate(dev_priv, mob);\n\t\tif (unlikely(ret != 0))\n\t\t\tgoto out_no_populate;\n\n\t\tvmw_mob_pt_setup(mob, iter, otable->size >> PAGE_SHIFT);\n\t\tmob->pt_level += VMW_MOBFMT_PTDEPTH_1 - SVGA3D_MOBFMT_PT_1;\n\t}\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_fifo;\n\t}\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->header.id = SVGA_3D_CMD_SET_OTABLE_BASE64;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.type = type;\n\tcmd->body.baseAddress = mob->pt_root_page >> PAGE_SHIFT;\n\tcmd->body.sizeInBytes = otable->size;\n\tcmd->body.validSizeInBytes = 0;\n\tcmd->body.ptDepth = mob->pt_level;\n\n\t \n\tBUG_ON(mob->pt_level == VMW_MOBFMT_PTDEPTH_2);\n\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\totable->page_table = mob;\n\n\treturn 0;\n\nout_no_fifo:\nout_no_populate:\n\tvmw_mob_destroy(mob);\n\treturn ret;\n}\n\n \nstatic void vmw_takedown_otable_base(struct vmw_private *dev_priv,\n\t\t\t\t     SVGAOTableType type,\n\t\t\t\t     struct vmw_otable *otable)\n{\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdSetOTableBase body;\n\t} *cmd;\n\tstruct ttm_buffer_object *bo;\n\n\tif (otable->page_table == NULL)\n\t\treturn;\n\n\tbo = &otable->page_table->pt_bo->tbo;\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->header.id = SVGA_3D_CMD_SET_OTABLE_BASE;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.type = type;\n\tcmd->body.baseAddress = 0;\n\tcmd->body.sizeInBytes = 0;\n\tcmd->body.validSizeInBytes = 0;\n\tcmd->body.ptDepth = SVGA3D_MOBFMT_INVALID;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\tif (bo) {\n\t\tint ret;\n\n\t\tret = ttm_bo_reserve(bo, false, true, NULL);\n\t\tBUG_ON(ret != 0);\n\n\t\tvmw_bo_fence_single(bo, NULL);\n\t\tttm_bo_unreserve(bo);\n\t}\n\n\tvmw_mob_destroy(otable->page_table);\n\totable->page_table = NULL;\n}\n\n\nstatic int vmw_otable_batch_setup(struct vmw_private *dev_priv,\n\t\t\t\t  struct vmw_otable_batch *batch)\n{\n\tunsigned long offset;\n\tunsigned long bo_size;\n\tstruct vmw_otable *otables = batch->otables;\n\tSVGAOTableType i;\n\tint ret;\n\n\tbo_size = 0;\n\tfor (i = 0; i < batch->num_otables; ++i) {\n\t\tif (!otables[i].enabled)\n\t\t\tcontinue;\n\n\t\totables[i].size = PFN_ALIGN(otables[i].size);\n\t\tbo_size += otables[i].size;\n\t}\n\n\tret = vmw_bo_create_and_populate(dev_priv, bo_size,\n\t\t\t\t\t VMW_BO_DOMAIN_WAITABLE_SYS,\n\t\t\t\t\t &batch->otable_bo);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\toffset = 0;\n\tfor (i = 0; i < batch->num_otables; ++i) {\n\t\tif (!batch->otables[i].enabled)\n\t\t\tcontinue;\n\n\t\tret = vmw_setup_otable_base(dev_priv, i,\n\t\t\t\t\t    &batch->otable_bo->tbo,\n\t\t\t\t\t    offset,\n\t\t\t\t\t    &otables[i]);\n\t\tif (unlikely(ret != 0))\n\t\t\tgoto out_no_setup;\n\t\toffset += otables[i].size;\n\t}\n\n\treturn 0;\n\nout_no_setup:\n\tfor (i = 0; i < batch->num_otables; ++i) {\n\t\tif (batch->otables[i].enabled)\n\t\t\tvmw_takedown_otable_base(dev_priv, i,\n\t\t\t\t\t\t &batch->otables[i]);\n\t}\n\n\tvmw_bo_unpin_unlocked(&batch->otable_bo->tbo);\n\tttm_bo_put(&batch->otable_bo->tbo);\n\tbatch->otable_bo = NULL;\n\treturn ret;\n}\n\n \nint vmw_otables_setup(struct vmw_private *dev_priv)\n{\n\tstruct vmw_otable **otables = &dev_priv->otable_batch.otables;\n\tint ret;\n\n\tif (has_sm4_context(dev_priv)) {\n\t\t*otables = kmemdup(dx_tables, sizeof(dx_tables), GFP_KERNEL);\n\t\tif (!(*otables))\n\t\t\treturn -ENOMEM;\n\n\t\tdev_priv->otable_batch.num_otables = ARRAY_SIZE(dx_tables);\n\t} else {\n\t\t*otables = kmemdup(pre_dx_tables, sizeof(pre_dx_tables),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!(*otables))\n\t\t\treturn -ENOMEM;\n\n\t\tdev_priv->otable_batch.num_otables = ARRAY_SIZE(pre_dx_tables);\n\t}\n\n\tret = vmw_otable_batch_setup(dev_priv, &dev_priv->otable_batch);\n\tif (unlikely(ret != 0))\n\t\tgoto out_setup;\n\n\treturn 0;\n\nout_setup:\n\tkfree(*otables);\n\treturn ret;\n}\n\nstatic void vmw_otable_batch_takedown(struct vmw_private *dev_priv,\n\t\t\t       struct vmw_otable_batch *batch)\n{\n\tSVGAOTableType i;\n\tstruct ttm_buffer_object *bo = &batch->otable_bo->tbo;\n\tint ret;\n\n\tfor (i = 0; i < batch->num_otables; ++i)\n\t\tif (batch->otables[i].enabled)\n\t\t\tvmw_takedown_otable_base(dev_priv, i,\n\t\t\t\t\t\t &batch->otables[i]);\n\n\tret = ttm_bo_reserve(bo, false, true, NULL);\n\tBUG_ON(ret != 0);\n\n\tvmw_bo_fence_single(bo, NULL);\n\tttm_bo_unpin(bo);\n\tttm_bo_unreserve(bo);\n\n\tvmw_bo_unreference(&batch->otable_bo);\n}\n\n \nvoid vmw_otables_takedown(struct vmw_private *dev_priv)\n{\n\tvmw_otable_batch_takedown(dev_priv, &dev_priv->otable_batch);\n\tkfree(dev_priv->otable_batch.otables);\n}\n\n \nstatic unsigned long vmw_mob_calculate_pt_pages(unsigned long data_pages)\n{\n\tunsigned long data_size = data_pages * PAGE_SIZE;\n\tunsigned long tot_size = 0;\n\n\twhile (likely(data_size > PAGE_SIZE)) {\n\t\tdata_size = DIV_ROUND_UP(data_size, PAGE_SIZE);\n\t\tdata_size *= VMW_PPN_SIZE;\n\t\ttot_size += PFN_ALIGN(data_size);\n\t}\n\n\treturn tot_size >> PAGE_SHIFT;\n}\n\n \nstruct vmw_mob *vmw_mob_create(unsigned long data_pages)\n{\n\tstruct vmw_mob *mob = kzalloc(sizeof(*mob), GFP_KERNEL);\n\n\tif (unlikely(!mob))\n\t\treturn NULL;\n\n\tmob->num_pages = vmw_mob_calculate_pt_pages(data_pages);\n\n\treturn mob;\n}\n\n \nstatic int vmw_mob_pt_populate(struct vmw_private *dev_priv,\n\t\t\t       struct vmw_mob *mob)\n{\n\tBUG_ON(mob->pt_bo != NULL);\n\n\treturn vmw_bo_create_and_populate(dev_priv, mob->num_pages * PAGE_SIZE,\n\t\t\t\t\t  VMW_BO_DOMAIN_WAITABLE_SYS,\n\t\t\t\t\t  &mob->pt_bo);\n}\n\n \n#if (VMW_PPN_SIZE == 8)\nstatic void vmw_mob_assign_ppn(u32 **addr, dma_addr_t val)\n{\n\t*((u64 *) *addr) = val >> PAGE_SHIFT;\n\t*addr += 2;\n}\n#else\nstatic void vmw_mob_assign_ppn(u32 **addr, dma_addr_t val)\n{\n\t*(*addr)++ = val >> PAGE_SHIFT;\n}\n#endif\n\n \nstatic unsigned long vmw_mob_build_pt(struct vmw_piter *data_iter,\n\t\t\t\t      unsigned long num_data_pages,\n\t\t\t\t      struct vmw_piter *pt_iter)\n{\n\tunsigned long pt_size = num_data_pages * VMW_PPN_SIZE;\n\tunsigned long num_pt_pages = DIV_ROUND_UP(pt_size, PAGE_SIZE);\n\tunsigned long pt_page;\n\tu32 *addr, *save_addr;\n\tunsigned long i;\n\tstruct page *page;\n\n\tfor (pt_page = 0; pt_page < num_pt_pages; ++pt_page) {\n\t\tpage = vmw_piter_page(pt_iter);\n\n\t\tsave_addr = addr = kmap_atomic(page);\n\n\t\tfor (i = 0; i < PAGE_SIZE / VMW_PPN_SIZE; ++i) {\n\t\t\tvmw_mob_assign_ppn(&addr,\n\t\t\t\t\t   vmw_piter_dma_addr(data_iter));\n\t\t\tif (unlikely(--num_data_pages == 0))\n\t\t\t\tbreak;\n\t\t\tWARN_ON(!vmw_piter_next(data_iter));\n\t\t}\n\t\tkunmap_atomic(save_addr);\n\t\tvmw_piter_next(pt_iter);\n\t}\n\n\treturn num_pt_pages;\n}\n\n \nstatic void vmw_mob_pt_setup(struct vmw_mob *mob,\n\t\t\t     struct vmw_piter data_iter,\n\t\t\t     unsigned long num_data_pages)\n{\n\tunsigned long num_pt_pages = 0;\n\tstruct ttm_buffer_object *bo = &mob->pt_bo->tbo;\n\tstruct vmw_piter save_pt_iter = {0};\n\tstruct vmw_piter pt_iter;\n\tconst struct vmw_sg_table *vsgt;\n\tint ret;\n\n\tBUG_ON(num_data_pages == 0);\n\n\tret = ttm_bo_reserve(bo, false, true, NULL);\n\tBUG_ON(ret != 0);\n\n\tvsgt = vmw_bo_sg_table(bo);\n\tvmw_piter_start(&pt_iter, vsgt, 0);\n\tBUG_ON(!vmw_piter_next(&pt_iter));\n\tmob->pt_level = 0;\n\twhile (likely(num_data_pages > 1)) {\n\t\t++mob->pt_level;\n\t\tBUG_ON(mob->pt_level > 2);\n\t\tsave_pt_iter = pt_iter;\n\t\tnum_pt_pages = vmw_mob_build_pt(&data_iter, num_data_pages,\n\t\t\t\t\t\t&pt_iter);\n\t\tdata_iter = save_pt_iter;\n\t\tnum_data_pages = num_pt_pages;\n\t}\n\n\tmob->pt_root_page = vmw_piter_dma_addr(&save_pt_iter);\n\tttm_bo_unreserve(bo);\n}\n\n \nvoid vmw_mob_destroy(struct vmw_mob *mob)\n{\n\tif (mob->pt_bo) {\n\t\tvmw_bo_unpin_unlocked(&mob->pt_bo->tbo);\n\t\tvmw_bo_unreference(&mob->pt_bo);\n\t}\n\tkfree(mob);\n}\n\n \nvoid vmw_mob_unbind(struct vmw_private *dev_priv,\n\t\t    struct vmw_mob *mob)\n{\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDestroyGBMob body;\n\t} *cmd;\n\tint ret;\n\tstruct ttm_buffer_object *bo = &mob->pt_bo->tbo;\n\n\tif (bo) {\n\t\tret = ttm_bo_reserve(bo, false, true, NULL);\n\t\t \n\t\tBUG_ON(ret != 0);\n\t}\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (cmd) {\n\t\tcmd->header.id = SVGA_3D_CMD_DESTROY_GB_MOB;\n\t\tcmd->header.size = sizeof(cmd->body);\n\t\tcmd->body.mobid = mob->id;\n\t\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\t}\n\n\tif (bo) {\n\t\tvmw_bo_fence_single(bo, NULL);\n\t\tttm_bo_unreserve(bo);\n\t}\n\tvmw_fifo_resource_dec(dev_priv);\n}\n\n \nint vmw_mob_bind(struct vmw_private *dev_priv,\n\t\t struct vmw_mob *mob,\n\t\t const struct vmw_sg_table *vsgt,\n\t\t unsigned long num_data_pages,\n\t\t int32_t mob_id)\n{\n\tint ret;\n\tbool pt_set_up = false;\n\tstruct vmw_piter data_iter;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDefineGBMob64 body;\n\t} *cmd;\n\n\tmob->id = mob_id;\n\tvmw_piter_start(&data_iter, vsgt, 0);\n\tif (unlikely(!vmw_piter_next(&data_iter)))\n\t\treturn 0;\n\n\tif (likely(num_data_pages == 1)) {\n\t\tmob->pt_level = VMW_MOBFMT_PTDEPTH_0;\n\t\tmob->pt_root_page = vmw_piter_dma_addr(&data_iter);\n\t} else if (unlikely(mob->pt_bo == NULL)) {\n\t\tret = vmw_mob_pt_populate(dev_priv, mob);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\n\t\tvmw_mob_pt_setup(mob, data_iter, num_data_pages);\n\t\tpt_set_up = true;\n\t\tmob->pt_level += VMW_MOBFMT_PTDEPTH_1 - SVGA3D_MOBFMT_PT_1;\n\t}\n\n\tvmw_fifo_resource_inc(dev_priv);\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\tgoto out_no_cmd_space;\n\n\tcmd->header.id = SVGA_3D_CMD_DEFINE_GB_MOB64;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.mobid = mob_id;\n\tcmd->body.ptDepth = mob->pt_level;\n\tcmd->body.base = mob->pt_root_page >> PAGE_SHIFT;\n\tcmd->body.sizeInBytes = num_data_pages * PAGE_SIZE;\n\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\treturn 0;\n\nout_no_cmd_space:\n\tvmw_fifo_resource_dec(dev_priv);\n\tif (pt_set_up) {\n\t\tvmw_bo_unpin_unlocked(&mob->pt_bo->tbo);\n\t\tvmw_bo_unreference(&mob->pt_bo);\n\t}\n\n\treturn -ENOMEM;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}