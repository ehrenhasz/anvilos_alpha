{
  "module_name": "vmwgfx_cmdbuf_res.c",
  "hash_id": "f88079aa73a8875d89b9fc469d49c6c50b7f21a5a80004d731f82fee1b71be0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c",
  "human_readable_source": "\n \n\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_resource_priv.h\"\n\n#include <linux/hashtable.h>\n\n#define VMW_CMDBUF_RES_MAN_HT_ORDER 12\n\n \nstruct vmw_cmdbuf_res {\n\tstruct vmw_resource *res;\n\tstruct vmwgfx_hash_item hash;\n\tstruct list_head head;\n\tenum vmw_cmdbuf_res_state state;\n\tstruct vmw_cmdbuf_res_manager *man;\n};\n\n \nstruct vmw_cmdbuf_res_manager {\n\tDECLARE_HASHTABLE(resources, VMW_CMDBUF_RES_MAN_HT_ORDER);\n\tstruct list_head list;\n\tstruct vmw_private *dev_priv;\n};\n\n\n \nstruct vmw_resource *\nvmw_cmdbuf_res_lookup(struct vmw_cmdbuf_res_manager *man,\n\t\t      enum vmw_cmdbuf_res_type res_type,\n\t\t      u32 user_key)\n{\n\tstruct vmwgfx_hash_item *hash;\n\tunsigned long key = user_key | (res_type << 24);\n\n\thash_for_each_possible_rcu(man->resources, hash, head, key) {\n\t\tif (hash->key == key)\n\t\t\treturn hlist_entry(hash, struct vmw_cmdbuf_res, hash)->res;\n\t}\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstatic void vmw_cmdbuf_res_free(struct vmw_cmdbuf_res_manager *man,\n\t\t\t\tstruct vmw_cmdbuf_res *entry)\n{\n\tlist_del(&entry->head);\n\thash_del_rcu(&entry->hash.head);\n\tvmw_resource_unreference(&entry->res);\n\tkfree(entry);\n}\n\n \nvoid vmw_cmdbuf_res_commit(struct list_head *list)\n{\n\tstruct vmw_cmdbuf_res *entry, *next;\n\n\tlist_for_each_entry_safe(entry, next, list, head) {\n\t\tlist_del(&entry->head);\n\t\tif (entry->res->func->commit_notify)\n\t\t\tentry->res->func->commit_notify(entry->res,\n\t\t\t\t\t\t\tentry->state);\n\t\tswitch (entry->state) {\n\t\tcase VMW_CMDBUF_RES_ADD:\n\t\t\tentry->state = VMW_CMDBUF_RES_COMMITTED;\n\t\t\tlist_add_tail(&entry->head, &entry->man->list);\n\t\t\tbreak;\n\t\tcase VMW_CMDBUF_RES_DEL:\n\t\t\tvmw_resource_unreference(&entry->res);\n\t\t\tkfree(entry);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid vmw_cmdbuf_res_revert(struct list_head *list)\n{\n\tstruct vmw_cmdbuf_res *entry, *next;\n\n\tlist_for_each_entry_safe(entry, next, list, head) {\n\t\tswitch (entry->state) {\n\t\tcase VMW_CMDBUF_RES_ADD:\n\t\t\tvmw_cmdbuf_res_free(entry->man, entry);\n\t\t\tbreak;\n\t\tcase VMW_CMDBUF_RES_DEL:\n\t\t\thash_add_rcu(entry->man->resources, &entry->hash.head,\n\t\t\t\t\t\tentry->hash.key);\n\t\t\tlist_move_tail(&entry->head, &entry->man->list);\n\t\t\tentry->state = VMW_CMDBUF_RES_COMMITTED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nint vmw_cmdbuf_res_add(struct vmw_cmdbuf_res_manager *man,\n\t\t       enum vmw_cmdbuf_res_type res_type,\n\t\t       u32 user_key,\n\t\t       struct vmw_resource *res,\n\t\t       struct list_head *list)\n{\n\tstruct vmw_cmdbuf_res *cres;\n\n\tcres = kzalloc(sizeof(*cres), GFP_KERNEL);\n\tif (unlikely(!cres))\n\t\treturn -ENOMEM;\n\n\tcres->hash.key = user_key | (res_type << 24);\n\thash_add_rcu(man->resources, &cres->hash.head, cres->hash.key);\n\n\tcres->state = VMW_CMDBUF_RES_ADD;\n\tcres->res = vmw_resource_reference(res);\n\tcres->man = man;\n\tlist_add_tail(&cres->head, list);\n\n\treturn 0;\n}\n\n \nint vmw_cmdbuf_res_remove(struct vmw_cmdbuf_res_manager *man,\n\t\t\t  enum vmw_cmdbuf_res_type res_type,\n\t\t\t  u32 user_key,\n\t\t\t  struct list_head *list,\n\t\t\t  struct vmw_resource **res_p)\n{\n\tstruct vmw_cmdbuf_res *entry = NULL;\n\tstruct vmwgfx_hash_item *hash;\n\tunsigned long key = user_key | (res_type << 24);\n\n\thash_for_each_possible_rcu(man->resources, hash, head, key) {\n\t\tif (hash->key == key) {\n\t\t\tentry = hlist_entry(hash, struct vmw_cmdbuf_res, hash);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (unlikely(!entry))\n\t\treturn -EINVAL;\n\n\tswitch (entry->state) {\n\tcase VMW_CMDBUF_RES_ADD:\n\t\tvmw_cmdbuf_res_free(man, entry);\n\t\t*res_p = NULL;\n\t\tbreak;\n\tcase VMW_CMDBUF_RES_COMMITTED:\n\t\thash_del_rcu(&entry->hash.head);\n\t\tlist_del(&entry->head);\n\t\tentry->state = VMW_CMDBUF_RES_DEL;\n\t\tlist_add_tail(&entry->head, list);\n\t\t*res_p = entry->res;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstruct vmw_cmdbuf_res_manager *\nvmw_cmdbuf_res_man_create(struct vmw_private *dev_priv)\n{\n\tstruct vmw_cmdbuf_res_manager *man;\n\n\tman = kzalloc(sizeof(*man), GFP_KERNEL);\n\tif (!man)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tman->dev_priv = dev_priv;\n\tINIT_LIST_HEAD(&man->list);\n\thash_init(man->resources);\n\treturn man;\n}\n\n \nvoid vmw_cmdbuf_res_man_destroy(struct vmw_cmdbuf_res_manager *man)\n{\n\tstruct vmw_cmdbuf_res *entry, *next;\n\n\tlist_for_each_entry_safe(entry, next, &man->list, head)\n\t\tvmw_cmdbuf_res_free(man, entry);\n\n\tkfree(man);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}