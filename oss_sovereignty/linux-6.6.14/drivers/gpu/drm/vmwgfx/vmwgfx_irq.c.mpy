{
  "module_name": "vmwgfx_irq.c",
  "hash_id": "4f77fc1a6f555f24b930295f0df6813480c8873591e40f3056fa2707fa1130e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/sched/signal.h>\n\n#include \"vmwgfx_drv.h\"\n\n#define VMW_FENCE_WRAP (1 << 24)\n\nstatic u32 vmw_irqflag_fence_goal(struct vmw_private *vmw)\n{\n\tif ((vmw->capabilities2 & SVGA_CAP2_EXTRA_REGS) != 0)\n\t\treturn SVGA_IRQFLAG_REG_FENCE_GOAL;\n\telse\n\t\treturn SVGA_IRQFLAG_FENCE_GOAL;\n}\n\n \nstatic irqreturn_t vmw_thread_fn(int irq, void *arg)\n{\n\tstruct drm_device *dev = (struct drm_device *)arg;\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (test_and_clear_bit(VMW_IRQTHREAD_FENCE,\n\t\t\t       dev_priv->irqthread_pending)) {\n\t\tvmw_fences_update(dev_priv->fman);\n\t\twake_up_all(&dev_priv->fence_queue);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (test_and_clear_bit(VMW_IRQTHREAD_CMDBUF,\n\t\t\t       dev_priv->irqthread_pending)) {\n\t\tvmw_cmdbuf_irqthread(dev_priv->cman);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\n \nstatic irqreturn_t vmw_irq_handler(int irq, void *arg)\n{\n\tstruct drm_device *dev = (struct drm_device *)arg;\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tuint32_t status, masked_status;\n\tirqreturn_t ret = IRQ_HANDLED;\n\n\tstatus = vmw_irq_status_read(dev_priv);\n\tmasked_status = status & READ_ONCE(dev_priv->irq_mask);\n\n\tif (likely(status))\n\t\tvmw_irq_status_write(dev_priv, status);\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tif (masked_status & SVGA_IRQFLAG_FIFO_PROGRESS)\n\t\twake_up_all(&dev_priv->fifo_queue);\n\n\tif ((masked_status & (SVGA_IRQFLAG_ANY_FENCE |\n\t\t\t      vmw_irqflag_fence_goal(dev_priv))) &&\n\t    !test_and_set_bit(VMW_IRQTHREAD_FENCE, dev_priv->irqthread_pending))\n\t\tret = IRQ_WAKE_THREAD;\n\n\tif ((masked_status & (SVGA_IRQFLAG_COMMAND_BUFFER |\n\t\t\t      SVGA_IRQFLAG_ERROR)) &&\n\t    !test_and_set_bit(VMW_IRQTHREAD_CMDBUF,\n\t\t\t      dev_priv->irqthread_pending))\n\t\tret = IRQ_WAKE_THREAD;\n\n\treturn ret;\n}\n\nstatic bool vmw_fifo_idle(struct vmw_private *dev_priv, uint32_t seqno)\n{\n\n\treturn (vmw_read(dev_priv, SVGA_REG_BUSY) == 0);\n}\n\nvoid vmw_update_seqno(struct vmw_private *dev_priv)\n{\n\tuint32_t seqno = vmw_fence_read(dev_priv);\n\n\tif (dev_priv->last_read_seqno != seqno) {\n\t\tdev_priv->last_read_seqno = seqno;\n\t\tvmw_fences_update(dev_priv->fman);\n\t}\n}\n\nbool vmw_seqno_passed(struct vmw_private *dev_priv,\n\t\t\t uint32_t seqno)\n{\n\tbool ret;\n\n\tif (likely(dev_priv->last_read_seqno - seqno < VMW_FENCE_WRAP))\n\t\treturn true;\n\n\tvmw_update_seqno(dev_priv);\n\tif (likely(dev_priv->last_read_seqno - seqno < VMW_FENCE_WRAP))\n\t\treturn true;\n\n\tif (!vmw_has_fences(dev_priv) && vmw_fifo_idle(dev_priv, seqno))\n\t\treturn true;\n\n\t \n\n\tret = ((atomic_read(&dev_priv->marker_seq) - seqno)\n\t       > VMW_FENCE_WRAP);\n\n\treturn ret;\n}\n\nint vmw_fallback_wait(struct vmw_private *dev_priv,\n\t\t      bool lazy,\n\t\t      bool fifo_idle,\n\t\t      uint32_t seqno,\n\t\t      bool interruptible,\n\t\t      unsigned long timeout)\n{\n\tstruct vmw_fifo_state *fifo_state = dev_priv->fifo;\n\tbool fifo_down = false;\n\n\tuint32_t count = 0;\n\tuint32_t signal_seq;\n\tint ret;\n\tunsigned long end_jiffies = jiffies + timeout;\n\tbool (*wait_condition)(struct vmw_private *, uint32_t);\n\tDEFINE_WAIT(__wait);\n\n\twait_condition = (fifo_idle) ? &vmw_fifo_idle :\n\t\t&vmw_seqno_passed;\n\n\t \n\n\tif (fifo_idle) {\n\t\tif (dev_priv->cman) {\n\t\t\tret = vmw_cmdbuf_idle(dev_priv->cman, interruptible,\n\t\t\t\t\t      10*HZ);\n\t\t\tif (ret)\n\t\t\t\tgoto out_err;\n\t\t} else if (fifo_state) {\n\t\t\tdown_read(&fifo_state->rwsem);\n\t\t\tfifo_down = true;\n\t\t}\n\t}\n\n\tsignal_seq = atomic_read(&dev_priv->marker_seq);\n\tret = 0;\n\n\tfor (;;) {\n\t\tprepare_to_wait(&dev_priv->fence_queue, &__wait,\n\t\t\t\t(interruptible) ?\n\t\t\t\tTASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\t\tif (wait_condition(dev_priv, seqno))\n\t\t\tbreak;\n\t\tif (time_after_eq(jiffies, end_jiffies)) {\n\t\t\tDRM_ERROR(\"SVGA device lockup.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (lazy)\n\t\t\tschedule_timeout(1);\n\t\telse if ((++count & 0x0F) == 0) {\n\t\t\t \n\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tschedule();\n\t\t\t__set_current_state((interruptible) ?\n\t\t\t\t\t    TASK_INTERRUPTIBLE :\n\t\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t}\n\t\tif (interruptible && signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(&dev_priv->fence_queue, &__wait);\n\tif (ret == 0 && fifo_idle && fifo_state)\n\t\tvmw_fence_write(dev_priv, signal_seq);\n\n\twake_up_all(&dev_priv->fence_queue);\nout_err:\n\tif (fifo_down)\n\t\tup_read(&fifo_state->rwsem);\n\n\treturn ret;\n}\n\nvoid vmw_generic_waiter_add(struct vmw_private *dev_priv,\n\t\t\t    u32 flag, int *waiter_count)\n{\n\tspin_lock_bh(&dev_priv->waiter_lock);\n\tif ((*waiter_count)++ == 0) {\n\t\tvmw_irq_status_write(dev_priv, flag);\n\t\tdev_priv->irq_mask |= flag;\n\t\tvmw_write(dev_priv, SVGA_REG_IRQMASK, dev_priv->irq_mask);\n\t}\n\tspin_unlock_bh(&dev_priv->waiter_lock);\n}\n\nvoid vmw_generic_waiter_remove(struct vmw_private *dev_priv,\n\t\t\t       u32 flag, int *waiter_count)\n{\n\tspin_lock_bh(&dev_priv->waiter_lock);\n\tif (--(*waiter_count) == 0) {\n\t\tdev_priv->irq_mask &= ~flag;\n\t\tvmw_write(dev_priv, SVGA_REG_IRQMASK, dev_priv->irq_mask);\n\t}\n\tspin_unlock_bh(&dev_priv->waiter_lock);\n}\n\nvoid vmw_seqno_waiter_add(struct vmw_private *dev_priv)\n{\n\tvmw_generic_waiter_add(dev_priv, SVGA_IRQFLAG_ANY_FENCE,\n\t\t\t       &dev_priv->fence_queue_waiters);\n}\n\nvoid vmw_seqno_waiter_remove(struct vmw_private *dev_priv)\n{\n\tvmw_generic_waiter_remove(dev_priv, SVGA_IRQFLAG_ANY_FENCE,\n\t\t\t\t  &dev_priv->fence_queue_waiters);\n}\n\nvoid vmw_goal_waiter_add(struct vmw_private *dev_priv)\n{\n\tvmw_generic_waiter_add(dev_priv, vmw_irqflag_fence_goal(dev_priv),\n\t\t\t       &dev_priv->goal_queue_waiters);\n}\n\nvoid vmw_goal_waiter_remove(struct vmw_private *dev_priv)\n{\n\tvmw_generic_waiter_remove(dev_priv, vmw_irqflag_fence_goal(dev_priv),\n\t\t\t\t  &dev_priv->goal_queue_waiters);\n}\n\nstatic void vmw_irq_preinstall(struct drm_device *dev)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tuint32_t status;\n\n\tstatus = vmw_irq_status_read(dev_priv);\n\tvmw_irq_status_write(dev_priv, status);\n}\n\nvoid vmw_irq_uninstall(struct drm_device *dev)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tuint32_t status;\n\tu32 i;\n\n\tif (!(dev_priv->capabilities & SVGA_CAP_IRQMASK))\n\t\treturn;\n\n\tvmw_write(dev_priv, SVGA_REG_IRQMASK, 0);\n\n\tstatus = vmw_irq_status_read(dev_priv);\n\tvmw_irq_status_write(dev_priv, status);\n\n\tfor (i = 0; i < dev_priv->num_irq_vectors; ++i)\n\t\tfree_irq(dev_priv->irqs[i], dev);\n\n\tpci_free_irq_vectors(pdev);\n\tdev_priv->num_irq_vectors = 0;\n}\n\n \nint vmw_irq_install(struct vmw_private *dev_priv)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);\n\tstruct drm_device *dev = &dev_priv->drm;\n\tint ret;\n\tint nvec;\n\tint i = 0;\n\n\tBUILD_BUG_ON((SVGA_IRQFLAG_MAX >> VMWGFX_MAX_NUM_IRQS) != 1);\n\tBUG_ON(VMWGFX_MAX_NUM_IRQS != get_count_order(SVGA_IRQFLAG_MAX));\n\n\tnvec = pci_alloc_irq_vectors(pdev, 1, VMWGFX_MAX_NUM_IRQS,\n\t\t\t\t     PCI_IRQ_ALL_TYPES);\n\n\tif (nvec <= 0) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"IRQ's are unavailable, nvec: %d\\n\", nvec);\n\t\tret = nvec;\n\t\tgoto done;\n\t}\n\n\tvmw_irq_preinstall(dev);\n\n\tfor (i = 0; i < nvec; ++i) {\n\t\tret = pci_irq_vector(pdev, i);\n\t\tif (ret < 0) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"failed getting irq vector: %d\\n\", ret);\n\t\t\tgoto done;\n\t\t}\n\t\tdev_priv->irqs[i] = ret;\n\n\t\tret = request_threaded_irq(dev_priv->irqs[i], vmw_irq_handler, vmw_thread_fn,\n\t\t\t\t\t   IRQF_SHARED, VMWGFX_DRIVER_NAME, dev);\n\t\tif (ret != 0) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Failed installing irq(%d): %d\\n\",\n\t\t\t\tdev_priv->irqs[i], ret);\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tdev_priv->num_irq_vectors = i;\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}