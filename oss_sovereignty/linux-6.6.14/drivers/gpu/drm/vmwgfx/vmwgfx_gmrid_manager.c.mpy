{
  "module_name": "vmwgfx_gmrid_manager.c",
  "hash_id": "5ad2cbe2bf7464736e0cfb54bda56a68488cc6e32686d7c7377fd2c0952b5eeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c",
  "human_readable_source": "\n \n \n\n#include \"vmwgfx_drv.h\"\n#include <drm/ttm/ttm_placement.h>\n#include <linux/idr.h>\n#include <linux/spinlock.h>\n#include <linux/kernel.h>\n\nstruct vmwgfx_gmrid_man {\n\tstruct ttm_resource_manager manager;\n\tspinlock_t lock;\n\tstruct ida gmr_ida;\n\tuint32_t max_gmr_ids;\n\tuint32_t max_gmr_pages;\n\tuint32_t used_gmr_pages;\n\tuint8_t type;\n};\n\nstatic struct vmwgfx_gmrid_man *to_gmrid_manager(struct ttm_resource_manager *man)\n{\n\treturn container_of(man, struct vmwgfx_gmrid_man, manager);\n}\n\nstatic int vmw_gmrid_man_get_node(struct ttm_resource_manager *man,\n\t\t\t\t  struct ttm_buffer_object *bo,\n\t\t\t\t  const struct ttm_place *place,\n\t\t\t\t  struct ttm_resource **res)\n{\n\tstruct vmwgfx_gmrid_man *gman = to_gmrid_manager(man);\n\tint id;\n\n\t*res = kmalloc(sizeof(**res), GFP_KERNEL);\n\tif (!*res)\n\t\treturn -ENOMEM;\n\n\tttm_resource_init(bo, place, *res);\n\n\tid = ida_alloc_max(&gman->gmr_ida, gman->max_gmr_ids - 1, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\tspin_lock(&gman->lock);\n\n\tif (gman->max_gmr_pages > 0) {\n\t\tgman->used_gmr_pages += PFN_UP((*res)->size);\n\t\t \n\t\tif (unlikely(gman->used_gmr_pages > gman->max_gmr_pages)) {\n\t\t\tconst unsigned long max_graphics_pages = totalram_pages() / 2;\n\t\t\tuint32_t new_max_pages = 0;\n\n\t\t\tDRM_WARN(\"vmwgfx: mob memory overflow. Consider increasing guest RAM and graphicsMemory.\\n\");\n\t\t\tvmw_host_printf(\"vmwgfx, warning: mob memory overflow. Consider increasing guest RAM and graphicsMemory.\\n\");\n\n\t\t\tif (gman->max_gmr_pages > (max_graphics_pages / 2)) {\n\t\t\t\tDRM_WARN(\"vmwgfx: guest requires more than half of RAM for graphics.\\n\");\n\t\t\t\tnew_max_pages = max_graphics_pages;\n\t\t\t} else\n\t\t\t\tnew_max_pages = gman->max_gmr_pages * 2;\n\t\t\tif (new_max_pages > gman->max_gmr_pages && new_max_pages >= gman->used_gmr_pages) {\n\t\t\t\tDRM_WARN(\"vmwgfx: increasing guest mob limits to %u kB.\\n\",\n\t\t\t\t\t ((new_max_pages) << (PAGE_SHIFT - 10)));\n\n\t\t\t\tgman->max_gmr_pages = new_max_pages;\n\t\t\t} else {\n\t\t\t\tchar buf[256];\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"vmwgfx, error: guest graphics is out of memory (mob limit at: %ukB).\\n\",\n\t\t\t\t\t ((gman->max_gmr_pages) << (PAGE_SHIFT - 10)));\n\t\t\t\tvmw_host_printf(buf);\n\t\t\t\tDRM_WARN(\"%s\", buf);\n\t\t\t\tgoto nospace;\n\t\t\t}\n\t\t}\n\t}\n\n\t(*res)->start = id;\n\n\tspin_unlock(&gman->lock);\n\treturn 0;\n\nnospace:\n\tgman->used_gmr_pages -= PFN_UP((*res)->size);\n\tspin_unlock(&gman->lock);\n\tida_free(&gman->gmr_ida, id);\n\tttm_resource_fini(man, *res);\n\tkfree(*res);\n\treturn -ENOSPC;\n}\n\nstatic void vmw_gmrid_man_put_node(struct ttm_resource_manager *man,\n\t\t\t\t   struct ttm_resource *res)\n{\n\tstruct vmwgfx_gmrid_man *gman = to_gmrid_manager(man);\n\n\tida_free(&gman->gmr_ida, res->start);\n\tspin_lock(&gman->lock);\n\tgman->used_gmr_pages -= PFN_UP(res->size);\n\tspin_unlock(&gman->lock);\n\tttm_resource_fini(man, res);\n\tkfree(res);\n}\n\nstatic void vmw_gmrid_man_debug(struct ttm_resource_manager *man,\n\t\t\t\tstruct drm_printer *printer)\n{\n\tstruct vmwgfx_gmrid_man *gman = to_gmrid_manager(man);\n\n\tBUG_ON(gman->type != VMW_PL_GMR && gman->type != VMW_PL_MOB);\n\n\tdrm_printf(printer, \"%s's used: %u pages, max: %u pages, %u id's\\n\",\n\t\t   (gman->type == VMW_PL_MOB) ? \"Mob\" : \"GMR\",\n\t\t   gman->used_gmr_pages, gman->max_gmr_pages, gman->max_gmr_ids);\n}\n\nstatic const struct ttm_resource_manager_func vmw_gmrid_manager_func;\n\nint vmw_gmrid_man_init(struct vmw_private *dev_priv, int type)\n{\n\tstruct ttm_resource_manager *man;\n\tstruct vmwgfx_gmrid_man *gman =\n\t\tkzalloc(sizeof(*gman), GFP_KERNEL);\n\n\tif (unlikely(!gman))\n\t\treturn -ENOMEM;\n\n\tman = &gman->manager;\n\n\tman->func = &vmw_gmrid_manager_func;\n\tman->use_tt = true;\n\tttm_resource_manager_init(man, &dev_priv->bdev, 0);\n\tspin_lock_init(&gman->lock);\n\tgman->used_gmr_pages = 0;\n\tida_init(&gman->gmr_ida);\n\tgman->type = type;\n\n\tswitch (type) {\n\tcase VMW_PL_GMR:\n\t\tgman->max_gmr_ids = dev_priv->max_gmr_ids;\n\t\tgman->max_gmr_pages = dev_priv->max_gmr_pages;\n\t\tbreak;\n\tcase VMW_PL_MOB:\n\t\tgman->max_gmr_ids = VMWGFX_NUM_MOB;\n\t\tgman->max_gmr_pages = dev_priv->max_mob_pages;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tttm_set_driver_manager(&dev_priv->bdev, type, &gman->manager);\n\tttm_resource_manager_set_used(man, true);\n\treturn 0;\n}\n\nvoid vmw_gmrid_man_fini(struct vmw_private *dev_priv, int type)\n{\n\tstruct ttm_resource_manager *man = ttm_manager_type(&dev_priv->bdev, type);\n\tstruct vmwgfx_gmrid_man *gman = to_gmrid_manager(man);\n\n\tttm_resource_manager_set_used(man, false);\n\n\tttm_resource_manager_evict_all(&dev_priv->bdev, man);\n\n\tttm_resource_manager_cleanup(man);\n\n\tttm_set_driver_manager(&dev_priv->bdev, type, NULL);\n\tida_destroy(&gman->gmr_ida);\n\tkfree(gman);\n\n}\n\nstatic const struct ttm_resource_manager_func vmw_gmrid_manager_func = {\n\t.alloc = vmw_gmrid_man_get_node,\n\t.free = vmw_gmrid_man_put_node,\n\t.debug = vmw_gmrid_man_debug\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}