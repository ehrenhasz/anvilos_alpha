{
  "module_name": "vmwgfx_kms.c",
  "hash_id": "fb1bab5e9e0b08f30faba9d63b2949b70a2ba62ed5bdf82929b096479e1c1808",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c",
  "human_readable_source": "\n \n#include \"vmwgfx_kms.h\"\n\n#include \"vmwgfx_bo.h\"\n#include \"vmw_surface_cache.h\"\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_rect.h>\n#include <drm/drm_sysfs.h>\n\nvoid vmw_du_cleanup(struct vmw_display_unit *du)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(du->primary.dev);\n\tdrm_plane_cleanup(&du->primary);\n\tif (vmw_cmd_supported(dev_priv))\n\t\tdrm_plane_cleanup(&du->cursor.base);\n\n\tdrm_connector_unregister(&du->connector);\n\tdrm_crtc_cleanup(&du->crtc);\n\tdrm_encoder_cleanup(&du->encoder);\n\tdrm_connector_cleanup(&du->connector);\n}\n\n \n\nstatic int vmw_du_cursor_plane_unmap_cm(struct vmw_plane_state *vps);\nstatic void vmw_cursor_update_mob(struct vmw_private *dev_priv,\n\t\t\t\t  struct vmw_plane_state *vps,\n\t\t\t\t  u32 *image, u32 width, u32 height,\n\t\t\t\t  u32 hotspotX, u32 hotspotY);\n\nstruct vmw_svga_fifo_cmd_define_cursor {\n\tu32 cmd;\n\tSVGAFifoCmdDefineAlphaCursor cursor;\n};\n\n \nstatic void vmw_send_define_cursor_cmd(struct vmw_private *dev_priv,\n\t\t\t\t       u32 *image, u32 width, u32 height,\n\t\t\t\t       u32 hotspotX, u32 hotspotY)\n{\n\tstruct vmw_svga_fifo_cmd_define_cursor *cmd;\n\tconst u32 image_size = width * height * sizeof(*image);\n\tconst u32 cmd_size = sizeof(*cmd) + image_size;\n\n\t \n\tcmd = VMW_CMD_RESERVE(dev_priv, cmd_size);\n\n\tif (unlikely(!cmd))\n\t\treturn;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\n\tmemcpy(&cmd[1], image, image_size);\n\n\tcmd->cmd = SVGA_CMD_DEFINE_ALPHA_CURSOR;\n\tcmd->cursor.id = 0;\n\tcmd->cursor.width = width;\n\tcmd->cursor.height = height;\n\tcmd->cursor.hotspotX = hotspotX;\n\tcmd->cursor.hotspotY = hotspotY;\n\n\tvmw_cmd_commit_flush(dev_priv, cmd_size);\n}\n\n \nstatic void vmw_cursor_update_image(struct vmw_private *dev_priv,\n\t\t\t\t    struct vmw_plane_state *vps,\n\t\t\t\t    u32 *image, u32 width, u32 height,\n\t\t\t\t    u32 hotspotX, u32 hotspotY)\n{\n\tif (vps->cursor.bo)\n\t\tvmw_cursor_update_mob(dev_priv, vps, image,\n\t\t\t\t      vps->base.crtc_w, vps->base.crtc_h,\n\t\t\t\t      hotspotX, hotspotY);\n\n\telse\n\t\tvmw_send_define_cursor_cmd(dev_priv, image, width, height,\n\t\t\t\t\t   hotspotX, hotspotY);\n}\n\n\n \nstatic void vmw_cursor_update_mob(struct vmw_private *dev_priv,\n\t\t\t\t  struct vmw_plane_state *vps,\n\t\t\t\t  u32 *image, u32 width, u32 height,\n\t\t\t\t  u32 hotspotX, u32 hotspotY)\n{\n\tSVGAGBCursorHeader *header;\n\tSVGAGBAlphaCursorHeader *alpha_header;\n\tconst u32 image_size = width * height * sizeof(*image);\n\n\theader = vmw_bo_map_and_cache(vps->cursor.bo);\n\talpha_header = &header->header.alphaHeader;\n\n\tmemset(header, 0, sizeof(*header));\n\n\theader->type = SVGA_ALPHA_CURSOR;\n\theader->sizeInBytes = image_size;\n\n\talpha_header->hotspotX = hotspotX;\n\talpha_header->hotspotY = hotspotY;\n\talpha_header->width = width;\n\talpha_header->height = height;\n\n\tmemcpy(header + 1, image, image_size);\n\tvmw_write(dev_priv, SVGA_REG_CURSOR_MOBID,\n\t\t  vps->cursor.bo->tbo.resource->start);\n}\n\n\nstatic u32 vmw_du_cursor_mob_size(u32 w, u32 h)\n{\n\treturn w * h * sizeof(u32) + sizeof(SVGAGBCursorHeader);\n}\n\n \nstatic u32 *vmw_du_cursor_plane_acquire_image(struct vmw_plane_state *vps)\n{\n\tbool is_iomem;\n\tif (vps->surf) {\n\t\tif (vps->surf_mapped)\n\t\t\treturn vmw_bo_map_and_cache(vps->surf->res.guest_memory_bo);\n\t\treturn vps->surf->snooper.image;\n\t} else if (vps->bo)\n\t\treturn ttm_kmap_obj_virtual(&vps->bo->map, &is_iomem);\n\treturn NULL;\n}\n\nstatic bool vmw_du_cursor_plane_has_changed(struct vmw_plane_state *old_vps,\n\t\t\t\t\t    struct vmw_plane_state *new_vps)\n{\n\tvoid *old_image;\n\tvoid *new_image;\n\tu32 size;\n\tbool changed;\n\n\tif (old_vps->base.crtc_w != new_vps->base.crtc_w ||\n\t    old_vps->base.crtc_h != new_vps->base.crtc_h)\n\t    return true;\n\n\tif (old_vps->cursor.hotspot_x != new_vps->cursor.hotspot_x ||\n\t    old_vps->cursor.hotspot_y != new_vps->cursor.hotspot_y)\n\t    return true;\n\n\tsize = new_vps->base.crtc_w * new_vps->base.crtc_h * sizeof(u32);\n\n\told_image = vmw_du_cursor_plane_acquire_image(old_vps);\n\tnew_image = vmw_du_cursor_plane_acquire_image(new_vps);\n\n\tchanged = false;\n\tif (old_image && new_image)\n\t\tchanged = memcmp(old_image, new_image, size) != 0;\n\n\treturn changed;\n}\n\nstatic void vmw_du_destroy_cursor_mob(struct vmw_bo **vbo)\n{\n\tif (!(*vbo))\n\t\treturn;\n\n\tttm_bo_unpin(&(*vbo)->tbo);\n\tvmw_bo_unreference(vbo);\n}\n\nstatic void vmw_du_put_cursor_mob(struct vmw_cursor_plane *vcp,\n\t\t\t\t  struct vmw_plane_state *vps)\n{\n\tu32 i;\n\n\tif (!vps->cursor.bo)\n\t\treturn;\n\n\tvmw_du_cursor_plane_unmap_cm(vps);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vcp->cursor_mobs); i++) {\n\t\tif (!vcp->cursor_mobs[i]) {\n\t\t\tvcp->cursor_mobs[i] = vps->cursor.bo;\n\t\t\tvps->cursor.bo = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vcp->cursor_mobs); i++) {\n\t\tif (vcp->cursor_mobs[i]->tbo.base.size <\n\t\t    vps->cursor.bo->tbo.base.size) {\n\t\t\tvmw_du_destroy_cursor_mob(&vcp->cursor_mobs[i]);\n\t\t\tvcp->cursor_mobs[i] = vps->cursor.bo;\n\t\t\tvps->cursor.bo = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tvmw_du_destroy_cursor_mob(&vps->cursor.bo);\n}\n\nstatic int vmw_du_get_cursor_mob(struct vmw_cursor_plane *vcp,\n\t\t\t\t struct vmw_plane_state *vps)\n{\n\tstruct vmw_private *dev_priv = vcp->base.dev->dev_private;\n\tu32 size = vmw_du_cursor_mob_size(vps->base.crtc_w, vps->base.crtc_h);\n\tu32 i;\n\tu32 cursor_max_dim, mob_max_size;\n\tint ret;\n\n\tif (!dev_priv->has_mob ||\n\t    (dev_priv->capabilities2 & SVGA_CAP2_CURSOR_MOB) == 0)\n\t\treturn -EINVAL;\n\n\tmob_max_size = vmw_read(dev_priv, SVGA_REG_MOB_MAX_SIZE);\n\tcursor_max_dim = vmw_read(dev_priv, SVGA_REG_CURSOR_MAX_DIMENSION);\n\n\tif (size > mob_max_size || vps->base.crtc_w > cursor_max_dim ||\n\t    vps->base.crtc_h > cursor_max_dim)\n\t\treturn -EINVAL;\n\n\tif (vps->cursor.bo) {\n\t\tif (vps->cursor.bo->tbo.base.size >= size)\n\t\t\treturn 0;\n\t\tvmw_du_put_cursor_mob(vcp, vps);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vcp->cursor_mobs); i++) {\n\t\tif (vcp->cursor_mobs[i] &&\n\t\t    vcp->cursor_mobs[i]->tbo.base.size >= size) {\n\t\t\tvps->cursor.bo = vcp->cursor_mobs[i];\n\t\t\tvcp->cursor_mobs[i] = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\tret = vmw_bo_create_and_populate(dev_priv, size,\n\t\t\t\t\t VMW_BO_DOMAIN_MOB,\n\t\t\t\t\t &vps->cursor.bo);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tret = ttm_bo_reserve(&vps->cursor.bo->tbo, false, false, NULL);\n\tif (ret != 0)\n\t\tgoto teardown;\n\n\tvmw_bo_fence_single(&vps->cursor.bo->tbo, NULL);\n\tttm_bo_unreserve(&vps->cursor.bo->tbo);\n\treturn 0;\n\nteardown:\n\tvmw_du_destroy_cursor_mob(&vps->cursor.bo);\n\treturn ret;\n}\n\n\nstatic void vmw_cursor_update_position(struct vmw_private *dev_priv,\n\t\t\t\t       bool show, int x, int y)\n{\n\tconst uint32_t svga_cursor_on = show ? SVGA_CURSOR_ON_SHOW\n\t\t\t\t\t     : SVGA_CURSOR_ON_HIDE;\n\tuint32_t count;\n\n\tspin_lock(&dev_priv->cursor_lock);\n\tif (dev_priv->capabilities2 & SVGA_CAP2_EXTRA_REGS) {\n\t\tvmw_write(dev_priv, SVGA_REG_CURSOR4_X, x);\n\t\tvmw_write(dev_priv, SVGA_REG_CURSOR4_Y, y);\n\t\tvmw_write(dev_priv, SVGA_REG_CURSOR4_SCREEN_ID, SVGA3D_INVALID_ID);\n\t\tvmw_write(dev_priv, SVGA_REG_CURSOR4_ON, svga_cursor_on);\n\t\tvmw_write(dev_priv, SVGA_REG_CURSOR4_SUBMIT, 1);\n\t} else if (vmw_is_cursor_bypass3_enabled(dev_priv)) {\n\t\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_CURSOR_ON, svga_cursor_on);\n\t\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_CURSOR_X, x);\n\t\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_CURSOR_Y, y);\n\t\tcount = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_CURSOR_COUNT);\n\t\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_CURSOR_COUNT, ++count);\n\t} else {\n\t\tvmw_write(dev_priv, SVGA_REG_CURSOR_X, x);\n\t\tvmw_write(dev_priv, SVGA_REG_CURSOR_Y, y);\n\t\tvmw_write(dev_priv, SVGA_REG_CURSOR_ON, svga_cursor_on);\n\t}\n\tspin_unlock(&dev_priv->cursor_lock);\n}\n\nvoid vmw_kms_cursor_snoop(struct vmw_surface *srf,\n\t\t\t  struct ttm_object_file *tfile,\n\t\t\t  struct ttm_buffer_object *bo,\n\t\t\t  SVGA3dCmdHeader *header)\n{\n\tstruct ttm_bo_kmap_obj map;\n\tunsigned long kmap_offset;\n\tunsigned long kmap_num;\n\tSVGA3dCopyBox *box;\n\tunsigned box_count;\n\tvoid *virtual;\n\tbool is_iomem;\n\tstruct vmw_dma_cmd {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdSurfaceDMA dma;\n\t} *cmd;\n\tint i, ret;\n\tconst struct SVGA3dSurfaceDesc *desc =\n\t\tvmw_surface_get_desc(VMW_CURSOR_SNOOP_FORMAT);\n\tconst u32 image_pitch = VMW_CURSOR_SNOOP_WIDTH * desc->pitchBytesPerBlock;\n\n\tcmd = container_of(header, struct vmw_dma_cmd, header);\n\n\t \n\tif (!srf->snooper.image)\n\t\treturn;\n\n\tif (cmd->dma.host.face != 0 || cmd->dma.host.mipmap != 0) {\n\t\tDRM_ERROR(\"face and mipmap for cursors should never != 0\\n\");\n\t\treturn;\n\t}\n\n\tif (cmd->header.size < 64) {\n\t\tDRM_ERROR(\"at least one full copy box must be given\\n\");\n\t\treturn;\n\t}\n\n\tbox = (SVGA3dCopyBox *)&cmd[1];\n\tbox_count = (cmd->header.size - sizeof(SVGA3dCmdSurfaceDMA)) /\n\t\t\tsizeof(SVGA3dCopyBox);\n\n\tif (cmd->dma.guest.ptr.offset % PAGE_SIZE ||\n\t    box->x != 0    || box->y != 0    || box->z != 0    ||\n\t    box->srcx != 0 || box->srcy != 0 || box->srcz != 0 ||\n\t    box->d != 1    || box_count != 1 ||\n\t    box->w > VMW_CURSOR_SNOOP_WIDTH || box->h > VMW_CURSOR_SNOOP_HEIGHT) {\n\t\t \n\t\t \n\t\t \n\t\tDRM_ERROR(\"Can't snoop dma request for cursor!\\n\");\n\t\tDRM_ERROR(\"(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\\n\",\n\t\t\t  box->srcx, box->srcy, box->srcz,\n\t\t\t  box->x, box->y, box->z,\n\t\t\t  box->w, box->h, box->d, box_count,\n\t\t\t  cmd->dma.guest.ptr.offset);\n\t\treturn;\n\t}\n\n\tkmap_offset = cmd->dma.guest.ptr.offset >> PAGE_SHIFT;\n\tkmap_num = (VMW_CURSOR_SNOOP_HEIGHT*image_pitch) >> PAGE_SHIFT;\n\n\tret = ttm_bo_reserve(bo, true, false, NULL);\n\tif (unlikely(ret != 0)) {\n\t\tDRM_ERROR(\"reserve failed\\n\");\n\t\treturn;\n\t}\n\n\tret = ttm_bo_kmap(bo, kmap_offset, kmap_num, &map);\n\tif (unlikely(ret != 0))\n\t\tgoto err_unreserve;\n\n\tvirtual = ttm_kmap_obj_virtual(&map, &is_iomem);\n\n\tif (box->w == VMW_CURSOR_SNOOP_WIDTH && cmd->dma.guest.pitch == image_pitch) {\n\t\tmemcpy(srf->snooper.image, virtual,\n\t\t       VMW_CURSOR_SNOOP_HEIGHT*image_pitch);\n\t} else {\n\t\t \n\t\tfor (i = 0; i < box->h; i++)\n\t\t\tmemcpy(srf->snooper.image + i * image_pitch,\n\t\t\t       virtual + i * cmd->dma.guest.pitch,\n\t\t\t       box->w * desc->pitchBytesPerBlock);\n\t}\n\n\tsrf->snooper.age++;\n\n\tttm_bo_kunmap(&map);\nerr_unreserve:\n\tttm_bo_unreserve(bo);\n}\n\n \nvoid vmw_kms_legacy_hotspot_clear(struct vmw_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->drm;\n\tstruct vmw_display_unit *du;\n\tstruct drm_crtc *crtc;\n\n\tdrm_modeset_lock_all(dev);\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tdu = vmw_crtc_to_du(crtc);\n\n\t\tdu->hotspot_x = 0;\n\t\tdu->hotspot_y = 0;\n\t}\n\tdrm_modeset_unlock_all(dev);\n}\n\nvoid vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->drm;\n\tstruct vmw_display_unit *du;\n\tstruct drm_crtc *crtc;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tdu = vmw_crtc_to_du(crtc);\n\t\tif (!du->cursor_surface ||\n\t\t    du->cursor_age == du->cursor_surface->snooper.age ||\n\t\t    !du->cursor_surface->snooper.image)\n\t\t\tcontinue;\n\n\t\tdu->cursor_age = du->cursor_surface->snooper.age;\n\t\tvmw_send_define_cursor_cmd(dev_priv,\n\t\t\t\t\t   du->cursor_surface->snooper.image,\n\t\t\t\t\t   VMW_CURSOR_SNOOP_WIDTH,\n\t\t\t\t\t   VMW_CURSOR_SNOOP_HEIGHT,\n\t\t\t\t\t   du->hotspot_x + du->core_hotspot_x,\n\t\t\t\t\t   du->hotspot_y + du->core_hotspot_y);\n\t}\n\n\tmutex_unlock(&dev->mode_config.mutex);\n}\n\n\nvoid vmw_du_cursor_plane_destroy(struct drm_plane *plane)\n{\n\tstruct vmw_cursor_plane *vcp = vmw_plane_to_vcp(plane);\n\tu32 i;\n\n\tvmw_cursor_update_position(plane->dev->dev_private, false, 0, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(vcp->cursor_mobs); i++)\n\t\tvmw_du_destroy_cursor_mob(&vcp->cursor_mobs[i]);\n\n\tdrm_plane_cleanup(plane);\n}\n\n\nvoid vmw_du_primary_plane_destroy(struct drm_plane *plane)\n{\n\tdrm_plane_cleanup(plane);\n\n\t \n}\n\n\n \nvoid vmw_du_plane_unpin_surf(struct vmw_plane_state *vps,\n\t\t\t     bool unreference)\n{\n\tif (vps->surf) {\n\t\tif (vps->pinned) {\n\t\t\tvmw_resource_unpin(&vps->surf->res);\n\t\t\tvps->pinned--;\n\t\t}\n\n\t\tif (unreference) {\n\t\t\tif (vps->pinned)\n\t\t\t\tDRM_ERROR(\"Surface still pinned\\n\");\n\t\t\tvmw_surface_unreference(&vps->surf);\n\t\t}\n\t}\n}\n\n\n \nvoid\nvmw_du_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\tstruct drm_plane_state *old_state)\n{\n\tstruct vmw_plane_state *vps = vmw_plane_state_to_vps(old_state);\n\n\tvmw_du_plane_unpin_surf(vps, false);\n}\n\n\n \n\nstatic int\nvmw_du_cursor_plane_map_cm(struct vmw_plane_state *vps)\n{\n\tint ret;\n\tu32 size = vmw_du_cursor_mob_size(vps->base.crtc_w, vps->base.crtc_h);\n\tstruct ttm_buffer_object *bo;\n\n\tif (!vps->cursor.bo)\n\t\treturn -EINVAL;\n\n\tbo = &vps->cursor.bo->tbo;\n\n\tif (bo->base.size < size)\n\t\treturn -EINVAL;\n\n\tif (vps->cursor.bo->map.virtual)\n\t\treturn 0;\n\n\tret = ttm_bo_reserve(bo, false, false, NULL);\n\tif (unlikely(ret != 0))\n\t\treturn -ENOMEM;\n\n\tvmw_bo_map_and_cache(vps->cursor.bo);\n\n\tttm_bo_unreserve(bo);\n\n\tif (unlikely(ret != 0))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n\n \n\nstatic int\nvmw_du_cursor_plane_unmap_cm(struct vmw_plane_state *vps)\n{\n\tint ret = 0;\n\tstruct vmw_bo *vbo = vps->cursor.bo;\n\n\tif (!vbo || !vbo->map.virtual)\n\t\treturn 0;\n\n\tret = ttm_bo_reserve(&vbo->tbo, true, false, NULL);\n\tif (likely(ret == 0)) {\n\t\tvmw_bo_unmap(vbo);\n\t\tttm_bo_unreserve(&vbo->tbo);\n\t}\n\n\treturn ret;\n}\n\n\n \nvoid\nvmw_du_cursor_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\t       struct drm_plane_state *old_state)\n{\n\tstruct vmw_cursor_plane *vcp = vmw_plane_to_vcp(plane);\n\tstruct vmw_plane_state *vps = vmw_plane_state_to_vps(old_state);\n\tbool is_iomem;\n\n\tif (vps->surf_mapped) {\n\t\tvmw_bo_unmap(vps->surf->res.guest_memory_bo);\n\t\tvps->surf_mapped = false;\n\t}\n\n\tif (vps->bo && ttm_kmap_obj_virtual(&vps->bo->map, &is_iomem)) {\n\t\tconst int ret = ttm_bo_reserve(&vps->bo->tbo, true, false, NULL);\n\n\t\tif (likely(ret == 0)) {\n\t\t\tttm_bo_kunmap(&vps->bo->map);\n\t\t\tttm_bo_unreserve(&vps->bo->tbo);\n\t\t}\n\t}\n\n\tvmw_du_cursor_plane_unmap_cm(vps);\n\tvmw_du_put_cursor_mob(vcp, vps);\n\n\tvmw_du_plane_unpin_surf(vps, false);\n\n\tif (vps->surf) {\n\t\tvmw_surface_unreference(&vps->surf);\n\t\tvps->surf = NULL;\n\t}\n\n\tif (vps->bo) {\n\t\tvmw_bo_unreference(&vps->bo);\n\t\tvps->bo = NULL;\n\t}\n}\n\n\n \nint\nvmw_du_cursor_plane_prepare_fb(struct drm_plane *plane,\n\t\t\t       struct drm_plane_state *new_state)\n{\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct vmw_cursor_plane *vcp = vmw_plane_to_vcp(plane);\n\tstruct vmw_plane_state *vps = vmw_plane_state_to_vps(new_state);\n\tint ret = 0;\n\n\tif (vps->surf) {\n\t\tvmw_surface_unreference(&vps->surf);\n\t\tvps->surf = NULL;\n\t}\n\n\tif (vps->bo) {\n\t\tvmw_bo_unreference(&vps->bo);\n\t\tvps->bo = NULL;\n\t}\n\n\tif (fb) {\n\t\tif (vmw_framebuffer_to_vfb(fb)->bo) {\n\t\t\tvps->bo = vmw_framebuffer_to_vfbd(fb)->buffer;\n\t\t\tvmw_bo_reference(vps->bo);\n\t\t} else {\n\t\t\tvps->surf = vmw_framebuffer_to_vfbs(fb)->surface;\n\t\t\tvmw_surface_reference(vps->surf);\n\t\t}\n\t}\n\n\tif (!vps->surf && vps->bo) {\n\t\tconst u32 size = new_state->crtc_w * new_state->crtc_h * sizeof(u32);\n\n\t\t \n\t\tret = ttm_bo_reserve(&vps->bo->tbo, true, false, NULL);\n\n\t\tif (unlikely(ret != 0))\n\t\t\treturn -ENOMEM;\n\n\t\tret = ttm_bo_kmap(&vps->bo->tbo, 0, PFN_UP(size), &vps->bo->map);\n\n\t\tttm_bo_unreserve(&vps->bo->tbo);\n\n\t\tif (unlikely(ret != 0))\n\t\t\treturn -ENOMEM;\n\t} else if (vps->surf && !vps->bo && vps->surf->res.guest_memory_bo) {\n\n\t\tWARN_ON(vps->surf->snooper.image);\n\t\tret = ttm_bo_reserve(&vps->surf->res.guest_memory_bo->tbo, true, false,\n\t\t\t\t     NULL);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn -ENOMEM;\n\t\tvmw_bo_map_and_cache(vps->surf->res.guest_memory_bo);\n\t\tttm_bo_unreserve(&vps->surf->res.guest_memory_bo->tbo);\n\t\tvps->surf_mapped = true;\n\t}\n\n\tif (vps->surf || vps->bo) {\n\t\tvmw_du_get_cursor_mob(vcp, vps);\n\t\tvmw_du_cursor_plane_map_cm(vps);\n\t}\n\n\treturn 0;\n}\n\n\nvoid\nvmw_du_cursor_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_crtc *crtc = new_state->crtc ?: old_state->crtc;\n\tstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\n\tstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\n\tstruct vmw_plane_state *vps = vmw_plane_state_to_vps(new_state);\n\tstruct vmw_plane_state *old_vps = vmw_plane_state_to_vps(old_state);\n\ts32 hotspot_x, hotspot_y;\n\n\thotspot_x = du->hotspot_x;\n\thotspot_y = du->hotspot_y;\n\n\tif (new_state->fb) {\n\t\thotspot_x += new_state->fb->hot_x;\n\t\thotspot_y += new_state->fb->hot_y;\n\t}\n\n\tdu->cursor_surface = vps->surf;\n\tdu->cursor_bo = vps->bo;\n\n\tif (!vps->surf && !vps->bo) {\n\t\tvmw_cursor_update_position(dev_priv, false, 0, 0);\n\t\treturn;\n\t}\n\n\tvps->cursor.hotspot_x = hotspot_x;\n\tvps->cursor.hotspot_y = hotspot_y;\n\n\tif (vps->surf) {\n\t\tdu->cursor_age = du->cursor_surface->snooper.age;\n\t}\n\n\tif (!vmw_du_cursor_plane_has_changed(old_vps, vps)) {\n\t\t \n\t\tstruct vmw_cursor_plane_state tmp = old_vps->cursor;\n\t\told_vps->cursor = vps->cursor;\n\t\tvps->cursor = tmp;\n\t} else {\n\t\tvoid *image = vmw_du_cursor_plane_acquire_image(vps);\n\t\tif (image)\n\t\t\tvmw_cursor_update_image(dev_priv, vps, image,\n\t\t\t\t\t\tnew_state->crtc_w,\n\t\t\t\t\t\tnew_state->crtc_h,\n\t\t\t\t\t\thotspot_x, hotspot_y);\n\t}\n\n\tdu->cursor_x = new_state->crtc_x + du->set_gui_x;\n\tdu->cursor_y = new_state->crtc_y + du->set_gui_y;\n\n\tvmw_cursor_update_position(dev_priv, true,\n\t\t\t\t   du->cursor_x + hotspot_x,\n\t\t\t\t   du->cursor_y + hotspot_y);\n\n\tdu->core_hotspot_x = hotspot_x - du->hotspot_x;\n\tdu->core_hotspot_y = hotspot_y - du->hotspot_y;\n}\n\n\n \nint vmw_du_primary_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_crtc_state *crtc_state = NULL;\n\tstruct drm_framebuffer *new_fb = new_state->fb;\n\tint ret;\n\n\tif (new_state->crtc)\n\t\tcrtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t   new_state->crtc);\n\n\tret = drm_atomic_helper_check_plane_state(new_state, crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  false, true);\n\n\tif (!ret && new_fb) {\n\t\tstruct drm_crtc *crtc = new_state->crtc;\n\t\tstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\n\n\t\tvmw_connector_state_to_vcs(du->connector.state);\n\t}\n\n\n\treturn ret;\n}\n\n\n \nint vmw_du_cursor_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tint ret = 0;\n\tstruct drm_crtc_state *crtc_state = NULL;\n\tstruct vmw_surface *surface = NULL;\n\tstruct drm_framebuffer *fb = new_state->fb;\n\n\tif (new_state->crtc)\n\t\tcrtc_state = drm_atomic_get_new_crtc_state(new_state->state,\n\t\t\t\t\t\t\t   new_state->crtc);\n\n\tret = drm_atomic_helper_check_plane_state(new_state, crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  true, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!fb)\n\t\treturn 0;\n\n\t \n\tif (new_state->crtc_w != 64 || new_state->crtc_h != 64) {\n\t\tDRM_ERROR(\"Invalid cursor dimensions (%d, %d)\\n\",\n\t\t\t  new_state->crtc_w, new_state->crtc_h);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vmw_framebuffer_to_vfb(fb)->bo) {\n\t\tsurface = vmw_framebuffer_to_vfbs(fb)->surface;\n\n\t\tWARN_ON(!surface);\n\n\t\tif (!surface ||\n\t\t    (!surface->snooper.image && !surface->res.guest_memory_bo)) {\n\t\t\tDRM_ERROR(\"surface not suitable for cursor\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nint vmw_du_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *new_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t crtc);\n\tstruct vmw_display_unit *du = vmw_crtc_to_du(new_state->crtc);\n\tint connector_mask = drm_connector_mask(&du->connector);\n\tbool has_primary = new_state->plane_mask &\n\t\t\t   drm_plane_mask(crtc->primary);\n\n\t \n\tif (has_primary != new_state->enable)\n\t\treturn -EINVAL;\n\n\n\tif (new_state->connector_mask != connector_mask &&\n\t    new_state->connector_mask != 0) {\n\t\tDRM_ERROR(\"Invalid connectors configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (new_state->mode.crtc_clock == 0)\n\t\tnew_state->adjusted_mode.crtc_clock = new_state->mode.clock;\n\n\treturn 0;\n}\n\n\nvoid vmw_du_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t      struct drm_atomic_state *state)\n{\n}\n\n\nvoid vmw_du_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t      struct drm_atomic_state *state)\n{\n}\n\n\n \nstruct drm_crtc_state *\nvmw_du_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct drm_crtc_state *state;\n\tstruct vmw_crtc_state *vcs;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tvcs = kmemdup(crtc->state, sizeof(*vcs), GFP_KERNEL);\n\n\tif (!vcs)\n\t\treturn NULL;\n\n\tstate = &vcs->base;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, state);\n\n\treturn state;\n}\n\n\n \nvoid vmw_du_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct vmw_crtc_state *vcs;\n\n\n\tif (crtc->state) {\n\t\t__drm_atomic_helper_crtc_destroy_state(crtc->state);\n\n\t\tkfree(vmw_crtc_state_to_vcs(crtc->state));\n\t}\n\n\tvcs = kzalloc(sizeof(*vcs), GFP_KERNEL);\n\n\tif (!vcs) {\n\t\tDRM_ERROR(\"Cannot allocate vmw_crtc_state\\n\");\n\t\treturn;\n\t}\n\n\t__drm_atomic_helper_crtc_reset(crtc, &vcs->base);\n}\n\n\n \nvoid\nvmw_du_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t  struct drm_crtc_state *state)\n{\n\tdrm_atomic_helper_crtc_destroy_state(crtc, state);\n}\n\n\n \nstruct drm_plane_state *\nvmw_du_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state;\n\tstruct vmw_plane_state *vps;\n\n\tvps = kmemdup(plane->state, sizeof(*vps), GFP_KERNEL);\n\n\tif (!vps)\n\t\treturn NULL;\n\n\tvps->pinned = 0;\n\tvps->cpp = 0;\n\n\tmemset(&vps->cursor, 0, sizeof(vps->cursor));\n\n\t \n\tif (vps->surf)\n\t\t(void) vmw_surface_reference(vps->surf);\n\n\tif (vps->bo)\n\t\t(void) vmw_bo_reference(vps->bo);\n\n\tstate = &vps->base;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, state);\n\n\treturn state;\n}\n\n\n \nvoid vmw_du_plane_reset(struct drm_plane *plane)\n{\n\tstruct vmw_plane_state *vps;\n\n\tif (plane->state)\n\t\tvmw_du_plane_destroy_state(plane, plane->state);\n\n\tvps = kzalloc(sizeof(*vps), GFP_KERNEL);\n\n\tif (!vps) {\n\t\tDRM_ERROR(\"Cannot allocate vmw_plane_state\\n\");\n\t\treturn;\n\t}\n\n\t__drm_atomic_helper_plane_reset(plane, &vps->base);\n}\n\n\n \nvoid\nvmw_du_plane_destroy_state(struct drm_plane *plane,\n\t\t\t   struct drm_plane_state *state)\n{\n\tstruct vmw_plane_state *vps = vmw_plane_state_to_vps(state);\n\n\t \n\tif (vps->surf)\n\t\tvmw_surface_unreference(&vps->surf);\n\n\tif (vps->bo)\n\t\tvmw_bo_unreference(&vps->bo);\n\n\tdrm_atomic_helper_plane_destroy_state(plane, state);\n}\n\n\n \nstruct drm_connector_state *\nvmw_du_connector_duplicate_state(struct drm_connector *connector)\n{\n\tstruct drm_connector_state *state;\n\tstruct vmw_connector_state *vcs;\n\n\tif (WARN_ON(!connector->state))\n\t\treturn NULL;\n\n\tvcs = kmemdup(connector->state, sizeof(*vcs), GFP_KERNEL);\n\n\tif (!vcs)\n\t\treturn NULL;\n\n\tstate = &vcs->base;\n\n\t__drm_atomic_helper_connector_duplicate_state(connector, state);\n\n\treturn state;\n}\n\n\n \nvoid vmw_du_connector_reset(struct drm_connector *connector)\n{\n\tstruct vmw_connector_state *vcs;\n\n\n\tif (connector->state) {\n\t\t__drm_atomic_helper_connector_destroy_state(connector->state);\n\n\t\tkfree(vmw_connector_state_to_vcs(connector->state));\n\t}\n\n\tvcs = kzalloc(sizeof(*vcs), GFP_KERNEL);\n\n\tif (!vcs) {\n\t\tDRM_ERROR(\"Cannot allocate vmw_connector_state\\n\");\n\t\treturn;\n\t}\n\n\t__drm_atomic_helper_connector_reset(connector, &vcs->base);\n}\n\n\n \nvoid\nvmw_du_connector_destroy_state(struct drm_connector *connector,\n\t\t\t  struct drm_connector_state *state)\n{\n\tdrm_atomic_helper_connector_destroy_state(connector, state);\n}\n \n\n \n\nstatic void vmw_framebuffer_surface_destroy(struct drm_framebuffer *framebuffer)\n{\n\tstruct vmw_framebuffer_surface *vfbs =\n\t\tvmw_framebuffer_to_vfbs(framebuffer);\n\n\tdrm_framebuffer_cleanup(framebuffer);\n\tvmw_surface_unreference(&vfbs->surface);\n\n\tkfree(vfbs);\n}\n\n \nint vmw_kms_readback(struct vmw_private *dev_priv,\n\t\t     struct drm_file *file_priv,\n\t\t     struct vmw_framebuffer *vfb,\n\t\t     struct drm_vmw_fence_rep __user *user_fence_rep,\n\t\t     struct drm_vmw_rect *vclips,\n\t\t     uint32_t num_clips)\n{\n\tswitch (dev_priv->active_display_unit) {\n\tcase vmw_du_screen_object:\n\t\treturn vmw_kms_sou_readback(dev_priv, file_priv, vfb,\n\t\t\t\t\t    user_fence_rep, vclips, num_clips,\n\t\t\t\t\t    NULL);\n\tcase vmw_du_screen_target:\n\t\treturn vmw_kms_stdu_readback(dev_priv, file_priv, vfb,\n\t\t\t\t\t     user_fence_rep, NULL, vclips, num_clips,\n\t\t\t\t\t     1, NULL);\n\tdefault:\n\t\tWARN_ONCE(true,\n\t\t\t  \"Readback called with invalid display system.\\n\");\n}\n\n\treturn -ENOSYS;\n}\n\n\nstatic const struct drm_framebuffer_funcs vmw_framebuffer_surface_funcs = {\n\t.destroy = vmw_framebuffer_surface_destroy,\n\t.dirty = drm_atomic_helper_dirtyfb,\n};\n\nstatic int vmw_kms_new_framebuffer_surface(struct vmw_private *dev_priv,\n\t\t\t\t\t   struct vmw_surface *surface,\n\t\t\t\t\t   struct vmw_framebuffer **out,\n\t\t\t\t\t   const struct drm_mode_fb_cmd2\n\t\t\t\t\t   *mode_cmd,\n\t\t\t\t\t   bool is_bo_proxy)\n\n{\n\tstruct drm_device *dev = &dev_priv->drm;\n\tstruct vmw_framebuffer_surface *vfbs;\n\tenum SVGA3dSurfaceFormat format;\n\tint ret;\n\n\t \n\tif (dev_priv->active_display_unit == vmw_du_legacy)\n\t\treturn -ENOSYS;\n\n\t \n\n\tif (!drm_any_plane_has_format(&dev_priv->drm,\n\t\t\t\t      mode_cmd->pixel_format,\n\t\t\t\t      mode_cmd->modifier[0])) {\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"unsupported pixel format %p4cc / modifier 0x%llx\\n\",\n\t\t\t&mode_cmd->pixel_format, mode_cmd->modifier[0]);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (unlikely(!surface->metadata.scanout))\n\t\treturn -EINVAL;\n\n\tif (unlikely(surface->metadata.mip_levels[0] != 1 ||\n\t\t     surface->metadata.num_sizes != 1 ||\n\t\t     surface->metadata.base_size.width < mode_cmd->width ||\n\t\t     surface->metadata.base_size.height < mode_cmd->height ||\n\t\t     surface->metadata.base_size.depth != 1)) {\n\t\tDRM_ERROR(\"Incompatible surface dimensions \"\n\t\t\t  \"for requested mode.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mode_cmd->pixel_format) {\n\tcase DRM_FORMAT_ARGB8888:\n\t\tformat = SVGA3D_A8R8G8B8;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tformat = SVGA3D_X8R8G8B8;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tformat = SVGA3D_R5G6B5;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\t\tformat = SVGA3D_A1R5G5B5;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Invalid pixel format: %p4cc\\n\",\n\t\t\t  &mode_cmd->pixel_format);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!has_sm4_context(dev_priv) && format != surface->metadata.format) {\n\t\tDRM_ERROR(\"Invalid surface format for requested mode.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvfbs = kzalloc(sizeof(*vfbs), GFP_KERNEL);\n\tif (!vfbs) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err1;\n\t}\n\n\tdrm_helper_mode_fill_fb_struct(dev, &vfbs->base.base, mode_cmd);\n\tvfbs->surface = vmw_surface_reference(surface);\n\tvfbs->base.user_handle = mode_cmd->handles[0];\n\tvfbs->is_bo_proxy = is_bo_proxy;\n\n\t*out = &vfbs->base;\n\n\tret = drm_framebuffer_init(dev, &vfbs->base.base,\n\t\t\t\t   &vmw_framebuffer_surface_funcs);\n\tif (ret)\n\t\tgoto out_err2;\n\n\treturn 0;\n\nout_err2:\n\tvmw_surface_unreference(&surface);\n\tkfree(vfbs);\nout_err1:\n\treturn ret;\n}\n\n \n\nstatic int vmw_framebuffer_bo_create_handle(struct drm_framebuffer *fb,\n\t\t\t\t\t    struct drm_file *file_priv,\n\t\t\t\t\t    unsigned int *handle)\n{\n\tstruct vmw_framebuffer_bo *vfbd =\n\t\t\tvmw_framebuffer_to_vfbd(fb);\n\n\treturn drm_gem_handle_create(file_priv, &vfbd->buffer->tbo.base, handle);\n}\n\nstatic void vmw_framebuffer_bo_destroy(struct drm_framebuffer *framebuffer)\n{\n\tstruct vmw_framebuffer_bo *vfbd =\n\t\tvmw_framebuffer_to_vfbd(framebuffer);\n\n\tdrm_framebuffer_cleanup(framebuffer);\n\tvmw_bo_unreference(&vfbd->buffer);\n\n\tkfree(vfbd);\n}\n\nstatic const struct drm_framebuffer_funcs vmw_framebuffer_bo_funcs = {\n\t.create_handle = vmw_framebuffer_bo_create_handle,\n\t.destroy = vmw_framebuffer_bo_destroy,\n\t.dirty = drm_atomic_helper_dirtyfb,\n};\n\n \nstatic int vmw_create_bo_proxy(struct drm_device *dev,\n\t\t\t       const struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t\t       struct vmw_bo *bo_mob,\n\t\t\t       struct vmw_surface **srf_out)\n{\n\tstruct vmw_surface_metadata metadata = {0};\n\tuint32_t format;\n\tstruct vmw_resource *res;\n\tunsigned int bytes_pp;\n\tint ret;\n\n\tswitch (mode_cmd->pixel_format) {\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XRGB8888:\n\t\tformat = SVGA3D_X8R8G8B8;\n\t\tbytes_pp = 4;\n\t\tbreak;\n\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XRGB1555:\n\t\tformat = SVGA3D_R5G6B5;\n\t\tbytes_pp = 2;\n\t\tbreak;\n\n\tcase 8:\n\t\tformat = SVGA3D_P8;\n\t\tbytes_pp = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tDRM_ERROR(\"Invalid framebuffer format %p4cc\\n\",\n\t\t\t  &mode_cmd->pixel_format);\n\t\treturn -EINVAL;\n\t}\n\n\tmetadata.format = format;\n\tmetadata.mip_levels[0] = 1;\n\tmetadata.num_sizes = 1;\n\tmetadata.base_size.width = mode_cmd->pitches[0] / bytes_pp;\n\tmetadata.base_size.height =  mode_cmd->height;\n\tmetadata.base_size.depth = 1;\n\tmetadata.scanout = true;\n\n\tret = vmw_gb_surface_define(vmw_priv(dev), &metadata, srf_out);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to allocate proxy content buffer\\n\");\n\t\treturn ret;\n\t}\n\n\tres = &(*srf_out)->res;\n\n\t \n\tmutex_lock(&res->dev_priv->cmdbuf_mutex);\n\t(void) vmw_resource_reserve(res, false, true);\n\tvmw_user_bo_unref(&res->guest_memory_bo);\n\tres->guest_memory_bo = vmw_user_bo_ref(bo_mob);\n\tres->guest_memory_offset = 0;\n\tvmw_resource_unreserve(res, false, false, false, NULL, 0);\n\tmutex_unlock(&res->dev_priv->cmdbuf_mutex);\n\n\treturn 0;\n}\n\n\n\nstatic int vmw_kms_new_framebuffer_bo(struct vmw_private *dev_priv,\n\t\t\t\t      struct vmw_bo *bo,\n\t\t\t\t      struct vmw_framebuffer **out,\n\t\t\t\t      const struct drm_mode_fb_cmd2\n\t\t\t\t      *mode_cmd)\n\n{\n\tstruct drm_device *dev = &dev_priv->drm;\n\tstruct vmw_framebuffer_bo *vfbd;\n\tunsigned int requested_size;\n\tint ret;\n\n\trequested_size = mode_cmd->height * mode_cmd->pitches[0];\n\tif (unlikely(requested_size > bo->tbo.base.size)) {\n\t\tDRM_ERROR(\"Screen buffer object size is too small \"\n\t\t\t  \"for requested mode.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!drm_any_plane_has_format(&dev_priv->drm,\n\t\t\t\t      mode_cmd->pixel_format,\n\t\t\t\t      mode_cmd->modifier[0])) {\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"unsupported pixel format %p4cc / modifier 0x%llx\\n\",\n\t\t\t&mode_cmd->pixel_format, mode_cmd->modifier[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tvfbd = kzalloc(sizeof(*vfbd), GFP_KERNEL);\n\tif (!vfbd) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err1;\n\t}\n\n\tvfbd->base.base.obj[0] = &bo->tbo.base;\n\tdrm_helper_mode_fill_fb_struct(dev, &vfbd->base.base, mode_cmd);\n\tvfbd->base.bo = true;\n\tvfbd->buffer = vmw_bo_reference(bo);\n\tvfbd->base.user_handle = mode_cmd->handles[0];\n\t*out = &vfbd->base;\n\n\tret = drm_framebuffer_init(dev, &vfbd->base.base,\n\t\t\t\t   &vmw_framebuffer_bo_funcs);\n\tif (ret)\n\t\tgoto out_err2;\n\n\treturn 0;\n\nout_err2:\n\tvmw_bo_unreference(&bo);\n\tkfree(vfbd);\nout_err1:\n\treturn ret;\n}\n\n\n \nstatic bool\nvmw_kms_srf_ok(struct vmw_private *dev_priv, uint32_t width, uint32_t height)\n{\n\tif (width  > dev_priv->texture_max_width ||\n\t    height > dev_priv->texture_max_height)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstruct vmw_framebuffer *\nvmw_kms_new_framebuffer(struct vmw_private *dev_priv,\n\t\t\tstruct vmw_bo *bo,\n\t\t\tstruct vmw_surface *surface,\n\t\t\tbool only_2d,\n\t\t\tconst struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct vmw_framebuffer *vfb = NULL;\n\tbool is_bo_proxy = false;\n\tint ret;\n\n\t \n\tif (vmw_kms_srf_ok(dev_priv, mode_cmd->width, mode_cmd->height)  &&\n\t    bo && only_2d &&\n\t    mode_cmd->width > 64 &&   \n\t    dev_priv->active_display_unit == vmw_du_screen_target) {\n\t\tret = vmw_create_bo_proxy(&dev_priv->drm, mode_cmd,\n\t\t\t\t\t  bo, &surface);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tis_bo_proxy = true;\n\t}\n\n\t \n\tif (surface) {\n\t\tret = vmw_kms_new_framebuffer_surface(dev_priv, surface, &vfb,\n\t\t\t\t\t\t      mode_cmd,\n\t\t\t\t\t\t      is_bo_proxy);\n\t\t \n\t\tif (is_bo_proxy)\n\t\t\tvmw_surface_unreference(&surface);\n\t} else if (bo) {\n\t\tret = vmw_kms_new_framebuffer_bo(dev_priv, bo, &vfb,\n\t\t\t\t\t\t mode_cmd);\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn vfb;\n}\n\n \n\nstatic struct drm_framebuffer *vmw_kms_fb_create(struct drm_device *dev,\n\t\t\t\t\t\t struct drm_file *file_priv,\n\t\t\t\t\t\t const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct vmw_framebuffer *vfb = NULL;\n\tstruct vmw_surface *surface = NULL;\n\tstruct vmw_bo *bo = NULL;\n\tint ret;\n\n\t \n\tret = vmw_user_lookup_handle(dev_priv, file_priv,\n\t\t\t\t     mode_cmd->handles[0],\n\t\t\t\t     &surface, &bo);\n\tif (ret) {\n\t\tDRM_ERROR(\"Invalid buffer object handle %u (0x%x).\\n\",\n\t\t\t  mode_cmd->handles[0], mode_cmd->handles[0]);\n\t\tgoto err_out;\n\t}\n\n\n\tif (!bo &&\n\t    !vmw_kms_srf_ok(dev_priv, mode_cmd->width, mode_cmd->height)) {\n\t\tDRM_ERROR(\"Surface size cannot exceed %dx%d\\n\",\n\t\t\tdev_priv->texture_max_width,\n\t\t\tdev_priv->texture_max_height);\n\t\tgoto err_out;\n\t}\n\n\n\tvfb = vmw_kms_new_framebuffer(dev_priv, bo, surface,\n\t\t\t\t      !(dev_priv->capabilities & SVGA_CAP_3D),\n\t\t\t\t      mode_cmd);\n\tif (IS_ERR(vfb)) {\n\t\tret = PTR_ERR(vfb);\n\t\tgoto err_out;\n\t}\n\nerr_out:\n\t \n\tif (bo)\n\t\tvmw_user_bo_unref(&bo);\n\tif (surface)\n\t\tvmw_surface_unreference(&surface);\n\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to create vmw_framebuffer: %i\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &vfb->base;\n}\n\n \nstatic int vmw_kms_check_display_memory(struct drm_device *dev,\n\t\t\t\t\tuint32_t num_rects,\n\t\t\t\t\tstruct drm_rect *rects)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct drm_rect bounding_box = {0};\n\tu64 total_pixels = 0, pixel_mem, bb_mem;\n\tint i;\n\n\tfor (i = 0; i < num_rects; i++) {\n\t\t \n\t\tif (dev_priv->active_display_unit == vmw_du_screen_target &&\n\t\t    (drm_rect_width(&rects[i]) > dev_priv->stdu_max_width ||\n\t\t     drm_rect_height(&rects[i]) > dev_priv->stdu_max_height)) {\n\t\t\tVMW_DEBUG_KMS(\"Screen size not supported.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (rects[i].x2 > bounding_box.x2)\n\t\t\tbounding_box.x2 = rects[i].x2;\n\n\t\tif (rects[i].y2 > bounding_box.y2)\n\t\t\tbounding_box.y2 = rects[i].y2;\n\n\t\ttotal_pixels += (u64) drm_rect_width(&rects[i]) *\n\t\t\t(u64) drm_rect_height(&rects[i]);\n\t}\n\n\t \n\tpixel_mem = total_pixels * 4;\n\n\t \n\tif (pixel_mem > dev_priv->max_primary_mem) {\n\t\tVMW_DEBUG_KMS(\"Combined output size too large.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (dev_priv->active_display_unit != vmw_du_screen_target ||\n\t    !(dev_priv->capabilities & SVGA_CAP_NO_BB_RESTRICTION)) {\n\t\tbb_mem = (u64) bounding_box.x2 * bounding_box.y2 * 4;\n\n\t\tif (bb_mem > dev_priv->max_primary_mem) {\n\t\t\tVMW_DEBUG_KMS(\"Topology is beyond supported limits.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct drm_crtc_state *\nvmw_crtc_state_and_lock(struct drm_atomic_state *state, struct drm_crtc *crtc)\n{\n\tstruct drm_crtc_state *crtc_state;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tif (crtc_state) {\n\t\tlockdep_assert_held(&crtc->mutex.mutex.base);\n\t} else {\n\t\tint ret = drm_modeset_lock(&crtc->mutex, state->acquire_ctx);\n\n\t\tif (ret != 0 && ret != -EALREADY)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tcrtc_state = crtc->state;\n\t}\n\n\treturn crtc_state;\n}\n\n \nstatic int vmw_kms_check_implicit(struct drm_device *dev,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_framebuffer *implicit_fb = NULL;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_plane_state *plane_state;\n\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\n\n\t\tif (!du->is_implicit)\n\t\t\tcontinue;\n\n\t\tcrtc_state = vmw_crtc_state_and_lock(state, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tif (!crtc_state || !crtc_state->enable)\n\t\t\tcontinue;\n\n\t\t \n\t\tplane_state = du->primary.state;\n\t\tif (plane_state->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tif (!implicit_fb)\n\t\t\timplicit_fb = plane_state->fb;\n\t\telse if (implicit_fb != plane_state->fb)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vmw_kms_check_topology(struct drm_device *dev,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_rect *rects;\n\tstruct drm_crtc *crtc;\n\tuint32_t i;\n\tint ret = 0;\n\n\trects = kcalloc(dev->mode_config.num_crtc, sizeof(struct drm_rect),\n\t\t\tGFP_KERNEL);\n\tif (!rects)\n\t\treturn -ENOMEM;\n\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\n\t\tstruct drm_crtc_state *crtc_state;\n\n\t\ti = drm_crtc_index(crtc);\n\n\t\tcrtc_state = vmw_crtc_state_and_lock(state, crtc);\n\t\tif (IS_ERR(crtc_state)) {\n\t\t\tret = PTR_ERR(crtc_state);\n\t\t\tgoto clean;\n\t\t}\n\n\t\tif (!crtc_state)\n\t\t\tcontinue;\n\n\t\tif (crtc_state->enable) {\n\t\t\trects[i].x1 = du->gui_x;\n\t\t\trects[i].y1 = du->gui_y;\n\t\t\trects[i].x2 = du->gui_x + crtc_state->mode.hdisplay;\n\t\t\trects[i].y2 = du->gui_y + crtc_state->mode.vdisplay;\n\t\t} else {\n\t\t\trects[i].x1 = 0;\n\t\t\trects[i].y1 = 0;\n\t\t\trects[i].x2 = 0;\n\t\t\trects[i].y2 = 0;\n\t\t}\n\t}\n\n\t \n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t      new_crtc_state, i) {\n\t\tstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\n\t\tstruct drm_connector *connector;\n\t\tstruct drm_connector_state *conn_state;\n\t\tstruct vmw_connector_state *vmw_conn_state;\n\n\t\tif (!du->pref_active && new_crtc_state->enable) {\n\t\t\tVMW_DEBUG_KMS(\"Enabling a disabled display unit\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto clean;\n\t\t}\n\n\t\t \n\t\tconnector = &du->connector;\n\t\tconn_state = drm_atomic_get_connector_state(state, connector);\n\t\tif (IS_ERR(conn_state)) {\n\t\t\tret = PTR_ERR(conn_state);\n\t\t\tgoto clean;\n\t\t}\n\n\t\tvmw_conn_state = vmw_connector_state_to_vcs(conn_state);\n\t\tvmw_conn_state->gui_x = du->gui_x;\n\t\tvmw_conn_state->gui_y = du->gui_y;\n\t}\n\n\tret = vmw_kms_check_display_memory(dev, dev->mode_config.num_crtc,\n\t\t\t\t\t   rects);\n\nclean:\n\tkfree(rects);\n\treturn ret;\n}\n\n \nstatic int\nvmw_kms_atomic_check_modeset(struct drm_device *dev,\n\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tbool need_modeset = false;\n\tint i, ret;\n\n\tret = drm_atomic_helper_check(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vmw_kms_check_implicit(dev, state);\n\tif (ret) {\n\t\tVMW_DEBUG_KMS(\"Invalid implicit state\\n\");\n\t\treturn ret;\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (drm_atomic_crtc_needs_modeset(crtc_state))\n\t\t\tneed_modeset = true;\n\t}\n\n\tif (need_modeset)\n\t\treturn vmw_kms_check_topology(dev, state);\n\n\treturn ret;\n}\n\nstatic const struct drm_mode_config_funcs vmw_kms_funcs = {\n\t.fb_create = vmw_kms_fb_create,\n\t.atomic_check = vmw_kms_atomic_check_modeset,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int vmw_kms_generic_present(struct vmw_private *dev_priv,\n\t\t\t\t   struct drm_file *file_priv,\n\t\t\t\t   struct vmw_framebuffer *vfb,\n\t\t\t\t   struct vmw_surface *surface,\n\t\t\t\t   uint32_t sid,\n\t\t\t\t   int32_t destX, int32_t destY,\n\t\t\t\t   struct drm_vmw_rect *clips,\n\t\t\t\t   uint32_t num_clips)\n{\n\treturn vmw_kms_sou_do_surface_dirty(dev_priv, vfb, NULL, clips,\n\t\t\t\t\t    &surface->res, destX, destY,\n\t\t\t\t\t    num_clips, 1, NULL, NULL);\n}\n\n\nint vmw_kms_present(struct vmw_private *dev_priv,\n\t\t    struct drm_file *file_priv,\n\t\t    struct vmw_framebuffer *vfb,\n\t\t    struct vmw_surface *surface,\n\t\t    uint32_t sid,\n\t\t    int32_t destX, int32_t destY,\n\t\t    struct drm_vmw_rect *clips,\n\t\t    uint32_t num_clips)\n{\n\tint ret;\n\n\tswitch (dev_priv->active_display_unit) {\n\tcase vmw_du_screen_target:\n\t\tret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL, clips,\n\t\t\t\t\t\t &surface->res, destX, destY,\n\t\t\t\t\t\t num_clips, 1, NULL, NULL);\n\t\tbreak;\n\tcase vmw_du_screen_object:\n\t\tret = vmw_kms_generic_present(dev_priv, file_priv, vfb, surface,\n\t\t\t\t\t      sid, destX, destY, clips,\n\t\t\t\t\t      num_clips);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(true,\n\t\t\t  \"Present called with invalid display system.\\n\");\n\t\tret = -ENOSYS;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tvmw_cmd_flush(dev_priv, false);\n\n\treturn 0;\n}\n\nstatic void\nvmw_kms_create_hotplug_mode_update_property(struct vmw_private *dev_priv)\n{\n\tif (dev_priv->hotplug_mode_update_property)\n\t\treturn;\n\n\tdev_priv->hotplug_mode_update_property =\n\t\tdrm_property_create_range(&dev_priv->drm,\n\t\t\t\t\t  DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t\t  \"hotplug_mode_update\", 0, 1);\n}\n\nint vmw_kms_init(struct vmw_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->drm;\n\tint ret;\n\tstatic const char *display_unit_names[] = {\n\t\t\"Invalid\",\n\t\t\"Legacy\",\n\t\t\"Screen Object\",\n\t\t\"Screen Target\",\n\t\t\"Invalid (max)\"\n\t};\n\n\tdrm_mode_config_init(dev);\n\tdev->mode_config.funcs = &vmw_kms_funcs;\n\tdev->mode_config.min_width = 1;\n\tdev->mode_config.min_height = 1;\n\tdev->mode_config.max_width = dev_priv->texture_max_width;\n\tdev->mode_config.max_height = dev_priv->texture_max_height;\n\tdev->mode_config.preferred_depth = dev_priv->assume_16bpp ? 16 : 32;\n\n\tdrm_mode_create_suggested_offset_properties(dev);\n\tvmw_kms_create_hotplug_mode_update_property(dev_priv);\n\n\tret = vmw_kms_stdu_init_display(dev_priv);\n\tif (ret) {\n\t\tret = vmw_kms_sou_init_display(dev_priv);\n\t\tif (ret)  \n\t\t\tret = vmw_kms_ldu_init_display(dev_priv);\n\t}\n\tBUILD_BUG_ON(ARRAY_SIZE(display_unit_names) != (vmw_du_max + 1));\n\tdrm_info(&dev_priv->drm, \"%s display unit initialized\\n\",\n\t\t display_unit_names[dev_priv->active_display_unit]);\n\n\treturn ret;\n}\n\nint vmw_kms_close(struct vmw_private *dev_priv)\n{\n\tint ret = 0;\n\n\t \n\tdrm_mode_config_cleanup(&dev_priv->drm);\n\tif (dev_priv->active_display_unit == vmw_du_legacy)\n\t\tret = vmw_kms_ldu_close_display(dev_priv);\n\n\treturn ret;\n}\n\nint vmw_kms_cursor_bypass_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_vmw_cursor_bypass_arg *arg = data;\n\tstruct vmw_display_unit *du;\n\tstruct drm_crtc *crtc;\n\tint ret = 0;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tif (arg->flags & DRM_VMW_CURSOR_BYPASS_ALL) {\n\n\t\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\t\tdu = vmw_crtc_to_du(crtc);\n\t\t\tdu->hotspot_x = arg->xhot;\n\t\t\tdu->hotspot_y = arg->yhot;\n\t\t}\n\n\t\tmutex_unlock(&dev->mode_config.mutex);\n\t\treturn 0;\n\t}\n\n\tcrtc = drm_crtc_find(dev, file_priv, arg->crtc_id);\n\tif (!crtc) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tdu = vmw_crtc_to_du(crtc);\n\n\tdu->hotspot_x = arg->xhot;\n\tdu->hotspot_y = arg->yhot;\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\treturn ret;\n}\n\nint vmw_kms_write_svga(struct vmw_private *vmw_priv,\n\t\t\tunsigned width, unsigned height, unsigned pitch,\n\t\t\tunsigned bpp, unsigned depth)\n{\n\tif (vmw_priv->capabilities & SVGA_CAP_PITCHLOCK)\n\t\tvmw_write(vmw_priv, SVGA_REG_PITCHLOCK, pitch);\n\telse if (vmw_fifo_have_pitchlock(vmw_priv))\n\t\tvmw_fifo_mem_write(vmw_priv, SVGA_FIFO_PITCHLOCK, pitch);\n\tvmw_write(vmw_priv, SVGA_REG_WIDTH, width);\n\tvmw_write(vmw_priv, SVGA_REG_HEIGHT, height);\n\tif ((vmw_priv->capabilities & SVGA_CAP_8BIT_EMULATION) != 0)\n\t\tvmw_write(vmw_priv, SVGA_REG_BITS_PER_PIXEL, bpp);\n\n\tif (vmw_read(vmw_priv, SVGA_REG_DEPTH) != depth) {\n\t\tDRM_ERROR(\"Invalid depth %u for %u bpp, host expects %u\\n\",\n\t\t\t  depth, bpp, vmw_read(vmw_priv, SVGA_REG_DEPTH));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nbool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv,\n\t\t\t\tuint32_t pitch,\n\t\t\t\tuint32_t height)\n{\n\treturn ((u64) pitch * (u64) height) < (u64)\n\t\t((dev_priv->active_display_unit == vmw_du_screen_target) ?\n\t\t dev_priv->max_primary_mem : dev_priv->vram_size);\n}\n\n \nstatic int vmw_du_update_layout(struct vmw_private *dev_priv,\n\t\t\t\tunsigned int num_rects, struct drm_rect *rects)\n{\n\tstruct drm_device *dev = &dev_priv->drm;\n\tstruct vmw_display_unit *du;\n\tstruct drm_connector *con;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_crtc *crtc;\n\tint ret;\n\n\t \n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_modeset_acquire_init(&ctx, 0);\nretry:\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tret = drm_modeset_lock(&crtc->mutex, &ctx);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EDEADLK) {\n\t\t\t\tdrm_modeset_backoff(&ctx);\n\t\t\t\tgoto retry;\n\t\t}\n\t\t\tgoto out_fini;\n\t\t}\n\t}\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(con, &conn_iter) {\n\t\tdu = vmw_connector_to_du(con);\n\t\tif (num_rects > du->unit) {\n\t\t\tdu->pref_width = drm_rect_width(&rects[du->unit]);\n\t\t\tdu->pref_height = drm_rect_height(&rects[du->unit]);\n\t\t\tdu->pref_active = true;\n\t\t\tdu->gui_x = rects[du->unit].x1;\n\t\t\tdu->gui_y = rects[du->unit].y1;\n\t\t} else {\n\t\t\tdu->pref_width  = VMWGFX_MIN_INITIAL_WIDTH;\n\t\t\tdu->pref_height = VMWGFX_MIN_INITIAL_HEIGHT;\n\t\t\tdu->pref_active = false;\n\t\t\tdu->gui_x = 0;\n\t\t\tdu->gui_y = 0;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tlist_for_each_entry(con, &dev->mode_config.connector_list, head) {\n\t\tdu = vmw_connector_to_du(con);\n\t\tif (num_rects > du->unit) {\n\t\t\tdrm_object_property_set_value\n\t\t\t  (&con->base, dev->mode_config.suggested_x_property,\n\t\t\t   du->gui_x);\n\t\t\tdrm_object_property_set_value\n\t\t\t  (&con->base, dev->mode_config.suggested_y_property,\n\t\t\t   du->gui_y);\n\t\t} else {\n\t\t\tdrm_object_property_set_value\n\t\t\t  (&con->base, dev->mode_config.suggested_x_property,\n\t\t\t   0);\n\t\t\tdrm_object_property_set_value\n\t\t\t  (&con->base, dev->mode_config.suggested_y_property,\n\t\t\t   0);\n\t\t}\n\t\tcon->status = vmw_du_connector_detect(con, true);\n\t}\nout_fini:\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tdrm_sysfs_hotplug_event(dev);\n\n\treturn 0;\n}\n\nint vmw_du_crtc_gamma_set(struct drm_crtc *crtc,\n\t\t\t  u16 *r, u16 *g, u16 *b,\n\t\t\t  uint32_t size,\n\t\t\t  struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tDRM_DEBUG(\"%d r/g/b = 0x%04x / 0x%04x / 0x%04x\\n\", i,\n\t\t\t  r[i], g[i], b[i]);\n\t\tvmw_write(dev_priv, SVGA_PALETTE_BASE + i * 3 + 0, r[i] >> 8);\n\t\tvmw_write(dev_priv, SVGA_PALETTE_BASE + i * 3 + 1, g[i] >> 8);\n\t\tvmw_write(dev_priv, SVGA_PALETTE_BASE + i * 3 + 2, b[i] >> 8);\n\t}\n\n\treturn 0;\n}\n\nint vmw_du_connector_dpms(struct drm_connector *connector, int mode)\n{\n\treturn 0;\n}\n\nenum drm_connector_status\nvmw_du_connector_detect(struct drm_connector *connector, bool force)\n{\n\tuint32_t num_displays;\n\tstruct drm_device *dev = connector->dev;\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct vmw_display_unit *du = vmw_connector_to_du(connector);\n\n\tnum_displays = vmw_read(dev_priv, SVGA_REG_NUM_DISPLAYS);\n\n\treturn ((vmw_connector_to_du(connector)->unit < num_displays &&\n\t\t du->pref_active) ?\n\t\tconnector_status_connected : connector_status_disconnected);\n}\n\nstatic struct drm_display_mode vmw_kms_connector_builtin[] = {\n\t \n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,\n\t\t   752, 800, 0, 480, 489, 492, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 40000, 800, 840,\n\t\t   968, 1056, 0, 600, 601, 605, 628, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,\n\t\t   1184, 1344, 0, 768, 771, 777, 806, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1152x864\", DRM_MODE_TYPE_DRIVER, 108000, 1152, 1216,\n\t\t   1344, 1600, 0, 864, 865, 868, 900, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74500, 1280, 1344,\n\t\t   1472, 1664, 0, 720, 723, 728, 748, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x768\", DRM_MODE_TYPE_DRIVER, 79500, 1280, 1344,\n\t\t   1472, 1664, 0, 768, 771, 778, 798, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x800\", DRM_MODE_TYPE_DRIVER, 83500, 1280, 1352,\n\t\t   1480, 1680, 0, 800, 803, 809, 831, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x960\", DRM_MODE_TYPE_DRIVER, 108000, 1280, 1376,\n\t\t   1488, 1800, 0, 960, 961, 964, 1000, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 108000, 1280, 1328,\n\t\t   1440, 1688, 0, 1024, 1025, 1028, 1066, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1360x768\", DRM_MODE_TYPE_DRIVER, 85500, 1360, 1424,\n\t\t   1536, 1792, 0, 768, 771, 777, 795, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1400x1050\", DRM_MODE_TYPE_DRIVER, 121750, 1400, 1488,\n\t\t   1632, 1864, 0, 1050, 1053, 1057, 1089, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1440x900\", DRM_MODE_TYPE_DRIVER, 106500, 1440, 1520,\n\t\t   1672, 1904, 0, 900, 903, 909, 934, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 162000, 1600, 1664,\n\t\t   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1680x1050\", DRM_MODE_TYPE_DRIVER, 146250, 1680, 1784,\n\t\t   1960, 2240, 0, 1050, 1053, 1059, 1089, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1792x1344\", DRM_MODE_TYPE_DRIVER, 204750, 1792, 1920,\n\t\t   2120, 2448, 0, 1344, 1345, 1348, 1394, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1856x1392\", DRM_MODE_TYPE_DRIVER, 218250, 1856, 1952,\n\t\t   2176, 2528, 0, 1392, 1393, 1396, 1439, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 173000, 1920, 2048,\n\t\t   2248, 2576, 0, 1080, 1083, 1088, 1120, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1200\", DRM_MODE_TYPE_DRIVER, 193250, 1920, 2056,\n\t\t   2256, 2592, 0, 1200, 1203, 1209, 1245, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"1920x1440\", DRM_MODE_TYPE_DRIVER, 234000, 1920, 2048,\n\t\t   2256, 2600, 0, 1440, 1441, 1444, 1500, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"2560x1440\", DRM_MODE_TYPE_DRIVER, 241500, 2560, 2608,\n\t\t   2640, 2720, 0, 1440, 1443, 1448, 1481, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"2560x1600\", DRM_MODE_TYPE_DRIVER, 348500, 2560, 2752,\n\t\t   3032, 3504, 0, 1600, 1603, 1609, 1658, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t \n\t{ DRM_MODE(\"2880x1800\", DRM_MODE_TYPE_DRIVER, 337500, 2880, 2928,\n\t\t   2960, 3040, 0, 1800, 1803, 1809, 1852, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 533000, 3840, 3888,\n\t\t   3920, 4000, 0, 2160, 2163, 2168, 2222, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"3840x2400\", DRM_MODE_TYPE_DRIVER, 592250, 3840, 3888,\n\t\t   3920, 4000, 0, 2400, 2403, 2409, 2469, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t \n\t{ DRM_MODE(\"\", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) },\n};\n\n \nvoid vmw_guess_mode_timing(struct drm_display_mode *mode)\n{\n\tmode->hsync_start = mode->hdisplay + 50;\n\tmode->hsync_end = mode->hsync_start + 50;\n\tmode->htotal = mode->hsync_end + 50;\n\n\tmode->vsync_start = mode->vdisplay + 50;\n\tmode->vsync_end = mode->vsync_start + 50;\n\tmode->vtotal = mode->vsync_end + 50;\n\n\tmode->clock = (u32)mode->htotal * (u32)mode->vtotal / 100 * 6;\n}\n\n\nint vmw_du_connector_fill_modes(struct drm_connector *connector,\n\t\t\t\tuint32_t max_width, uint32_t max_height)\n{\n\tstruct vmw_display_unit *du = vmw_connector_to_du(connector);\n\tstruct drm_device *dev = connector->dev;\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_display_mode *bmode;\n\tstruct drm_display_mode prefmode = { DRM_MODE(\"preferred\",\n\t\tDRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\tDRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC)\n\t};\n\tint i;\n\tu32 assumed_bpp = 4;\n\n\tif (dev_priv->assume_16bpp)\n\t\tassumed_bpp = 2;\n\n\tmax_width  = min(max_width,  dev_priv->texture_max_width);\n\tmax_height = min(max_height, dev_priv->texture_max_height);\n\n\t \n\tif (dev_priv->active_display_unit == vmw_du_screen_target) {\n\t\tmax_width  = min(max_width,  dev_priv->stdu_max_width);\n\t\tmax_height = min(max_height, dev_priv->stdu_max_height);\n\t}\n\n\t \n\tmode = drm_mode_duplicate(dev, &prefmode);\n\tif (!mode)\n\t\treturn 0;\n\tmode->hdisplay = du->pref_width;\n\tmode->vdisplay = du->pref_height;\n\tvmw_guess_mode_timing(mode);\n\tdrm_mode_set_name(mode);\n\n\tif (vmw_kms_validate_mode_vram(dev_priv,\n\t\t\t\t\tmode->hdisplay * assumed_bpp,\n\t\t\t\t\tmode->vdisplay)) {\n\t\tdrm_mode_probed_add(connector, mode);\n\t} else {\n\t\tdrm_mode_destroy(dev, mode);\n\t\tmode = NULL;\n\t}\n\n\tif (du->pref_mode) {\n\t\tlist_del_init(&du->pref_mode->head);\n\t\tdrm_mode_destroy(dev, du->pref_mode);\n\t}\n\n\t \n\tdu->pref_mode = mode;\n\n\tfor (i = 0; vmw_kms_connector_builtin[i].type != 0; i++) {\n\t\tbmode = &vmw_kms_connector_builtin[i];\n\t\tif (bmode->hdisplay > max_width ||\n\t\t    bmode->vdisplay > max_height)\n\t\t\tcontinue;\n\n\t\tif (!vmw_kms_validate_mode_vram(dev_priv,\n\t\t\t\t\t\tbmode->hdisplay * assumed_bpp,\n\t\t\t\t\t\tbmode->vdisplay))\n\t\t\tcontinue;\n\n\t\tmode = drm_mode_duplicate(dev, bmode);\n\t\tif (!mode)\n\t\t\treturn 0;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\tdrm_connector_list_update(connector);\n\t \n\tdrm_mode_sort(&connector->modes);\n\n\treturn 1;\n}\n\n \nint vmw_kms_update_layout_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct drm_mode_config *mode_config = &dev->mode_config;\n\tstruct drm_vmw_update_layout_arg *arg =\n\t\t(struct drm_vmw_update_layout_arg *)data;\n\tvoid __user *user_rects;\n\tstruct drm_vmw_rect *rects;\n\tstruct drm_rect *drm_rects;\n\tunsigned rects_size;\n\tint ret, i;\n\n\tif (!arg->num_outputs) {\n\t\tstruct drm_rect def_rect = {0, 0,\n\t\t\t\t\t    VMWGFX_MIN_INITIAL_WIDTH,\n\t\t\t\t\t    VMWGFX_MIN_INITIAL_HEIGHT};\n\t\tvmw_du_update_layout(dev_priv, 1, &def_rect);\n\t\treturn 0;\n\t}\n\n\trects_size = arg->num_outputs * sizeof(struct drm_vmw_rect);\n\trects = kcalloc(arg->num_outputs, sizeof(struct drm_vmw_rect),\n\t\t\tGFP_KERNEL);\n\tif (unlikely(!rects))\n\t\treturn -ENOMEM;\n\n\tuser_rects = (void __user *)(unsigned long)arg->rects;\n\tret = copy_from_user(rects, user_rects, rects_size);\n\tif (unlikely(ret != 0)) {\n\t\tDRM_ERROR(\"Failed to get rects.\\n\");\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tdrm_rects = (struct drm_rect *)rects;\n\n\tVMW_DEBUG_KMS(\"Layout count = %u\\n\", arg->num_outputs);\n\tfor (i = 0; i < arg->num_outputs; i++) {\n\t\tstruct drm_vmw_rect curr_rect;\n\n\t\t \n\t\tif ((rects[i].x + rects[i].w > INT_MAX) ||\n\t\t    (rects[i].y + rects[i].h > INT_MAX)) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcurr_rect = rects[i];\n\t\tdrm_rects[i].x1 = curr_rect.x;\n\t\tdrm_rects[i].y1 = curr_rect.y;\n\t\tdrm_rects[i].x2 = curr_rect.x + curr_rect.w;\n\t\tdrm_rects[i].y2 = curr_rect.y + curr_rect.h;\n\n\t\tVMW_DEBUG_KMS(\"  x1 = %d y1 = %d x2 = %d y2 = %d\\n\",\n\t\t\t      drm_rects[i].x1, drm_rects[i].y1,\n\t\t\t      drm_rects[i].x2, drm_rects[i].y2);\n\n\t\t \n\t\tif (drm_rects[i].x1 < 0 ||  drm_rects[i].y1 < 0 ||\n\t\t    drm_rects[i].x2 > mode_config->max_width ||\n\t\t    drm_rects[i].y2 > mode_config->max_height) {\n\t\t\tVMW_DEBUG_KMS(\"Invalid layout %d %d %d %d\\n\",\n\t\t\t\t      drm_rects[i].x1, drm_rects[i].y1,\n\t\t\t\t      drm_rects[i].x2, drm_rects[i].y2);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tret = vmw_kms_check_display_memory(dev, arg->num_outputs, drm_rects);\n\n\tif (ret == 0)\n\t\tvmw_du_update_layout(dev_priv, arg->num_outputs, drm_rects);\n\nout_free:\n\tkfree(rects);\n\treturn ret;\n}\n\n \nint vmw_kms_helper_dirty(struct vmw_private *dev_priv,\n\t\t\t struct vmw_framebuffer *framebuffer,\n\t\t\t const struct drm_clip_rect *clips,\n\t\t\t const struct drm_vmw_rect *vclips,\n\t\t\t s32 dest_x, s32 dest_y,\n\t\t\t int num_clips,\n\t\t\t int increment,\n\t\t\t struct vmw_kms_dirty *dirty)\n{\n\tstruct vmw_display_unit *units[VMWGFX_NUM_DISPLAY_UNITS];\n\tstruct drm_crtc *crtc;\n\tu32 num_units = 0;\n\tu32 i, k;\n\n\tdirty->dev_priv = dev_priv;\n\n\t \n\tif (dirty->crtc) {\n\t\tunits[num_units++] = vmw_crtc_to_du(dirty->crtc);\n\t} else {\n\t\tlist_for_each_entry(crtc, &dev_priv->drm.mode_config.crtc_list,\n\t\t\t\t    head) {\n\t\t\tstruct drm_plane *plane = crtc->primary;\n\n\t\t\tif (plane->state->fb == &framebuffer->base)\n\t\t\t\tunits[num_units++] = vmw_crtc_to_du(crtc);\n\t\t}\n\t}\n\n\tfor (k = 0; k < num_units; k++) {\n\t\tstruct vmw_display_unit *unit = units[k];\n\t\ts32 crtc_x = unit->crtc.x;\n\t\ts32 crtc_y = unit->crtc.y;\n\t\ts32 crtc_width = unit->crtc.mode.hdisplay;\n\t\ts32 crtc_height = unit->crtc.mode.vdisplay;\n\t\tconst struct drm_clip_rect *clips_ptr = clips;\n\t\tconst struct drm_vmw_rect *vclips_ptr = vclips;\n\n\t\tdirty->unit = unit;\n\t\tif (dirty->fifo_reserve_size > 0) {\n\t\t\tdirty->cmd = VMW_CMD_RESERVE(dev_priv,\n\t\t\t\t\t\t      dirty->fifo_reserve_size);\n\t\t\tif (!dirty->cmd)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmemset(dirty->cmd, 0, dirty->fifo_reserve_size);\n\t\t}\n\t\tdirty->num_hits = 0;\n\t\tfor (i = 0; i < num_clips; i++, clips_ptr += increment,\n\t\t       vclips_ptr += increment) {\n\t\t\ts32 clip_left;\n\t\t\ts32 clip_top;\n\n\t\t\t \n\t\t\tif (clips) {\n\t\t\t\tdirty->fb_x = (s32) clips_ptr->x1;\n\t\t\t\tdirty->fb_y = (s32) clips_ptr->y1;\n\t\t\t\tdirty->unit_x2 = (s32) clips_ptr->x2 + dest_x -\n\t\t\t\t\tcrtc_x;\n\t\t\t\tdirty->unit_y2 = (s32) clips_ptr->y2 + dest_y -\n\t\t\t\t\tcrtc_y;\n\t\t\t} else {\n\t\t\t\tdirty->fb_x = vclips_ptr->x;\n\t\t\t\tdirty->fb_y = vclips_ptr->y;\n\t\t\t\tdirty->unit_x2 = dirty->fb_x + vclips_ptr->w +\n\t\t\t\t\tdest_x - crtc_x;\n\t\t\t\tdirty->unit_y2 = dirty->fb_y + vclips_ptr->h +\n\t\t\t\t\tdest_y - crtc_y;\n\t\t\t}\n\n\t\t\tdirty->unit_x1 = dirty->fb_x + dest_x - crtc_x;\n\t\t\tdirty->unit_y1 = dirty->fb_y + dest_y - crtc_y;\n\n\t\t\t \n\t\t\tif (dirty->unit_x1 >= crtc_width ||\n\t\t\t    dirty->unit_y1 >= crtc_height ||\n\t\t\t    dirty->unit_x2 <= 0 || dirty->unit_y2 <= 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tdirty->unit_x2 = min_t(s32, dirty->unit_x2,\n\t\t\t\t\t       crtc_width);\n\t\t\tdirty->unit_y2 = min_t(s32, dirty->unit_y2,\n\t\t\t\t\t       crtc_height);\n\n\t\t\t \n\t\t\tclip_left = min_t(s32, dirty->unit_x1, 0);\n\t\t\tclip_top = min_t(s32, dirty->unit_y1, 0);\n\t\t\tdirty->unit_x1 -= clip_left;\n\t\t\tdirty->unit_y1 -= clip_top;\n\t\t\tdirty->fb_x -= clip_left;\n\t\t\tdirty->fb_y -= clip_top;\n\n\t\t\tdirty->clip(dirty);\n\t\t}\n\n\t\tdirty->fifo_commit(dirty);\n\t}\n\n\treturn 0;\n}\n\n \nvoid vmw_kms_helper_validation_finish(struct vmw_private *dev_priv,\n\t\t\t\t      struct drm_file *file_priv,\n\t\t\t\t      struct vmw_validation_context *ctx,\n\t\t\t\t      struct vmw_fence_obj **out_fence,\n\t\t\t\t      struct drm_vmw_fence_rep __user *\n\t\t\t\t      user_fence_rep)\n{\n\tstruct vmw_fence_obj *fence = NULL;\n\tuint32_t handle = 0;\n\tint ret = 0;\n\n\tif (file_priv || user_fence_rep || vmw_validation_has_bos(ctx) ||\n\t    out_fence)\n\t\tret = vmw_execbuf_fence_commands(file_priv, dev_priv, &fence,\n\t\t\t\t\t\t file_priv ? &handle : NULL);\n\tvmw_validation_done(ctx, fence);\n\tif (file_priv)\n\t\tvmw_execbuf_copy_fence_user(dev_priv, vmw_fpriv(file_priv),\n\t\t\t\t\t    ret, user_fence_rep, fence,\n\t\t\t\t\t    handle, -1);\n\tif (out_fence)\n\t\t*out_fence = fence;\n\telse\n\t\tvmw_fence_obj_unreference(&fence);\n}\n\n \nint vmw_kms_update_proxy(struct vmw_resource *res,\n\t\t\t const struct drm_clip_rect *clips,\n\t\t\t unsigned num_clips,\n\t\t\t int increment)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct drm_vmw_size *size = &vmw_res_to_srf(res)->metadata.base_size;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdUpdateGBImage body;\n\t} *cmd;\n\tSVGA3dBox *box;\n\tsize_t copy_size = 0;\n\tint i;\n\n\tif (!clips)\n\t\treturn 0;\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd) * num_clips);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_clips; ++i, clips += increment, ++cmd) {\n\t\tbox = &cmd->body.box;\n\n\t\tcmd->header.id = SVGA_3D_CMD_UPDATE_GB_IMAGE;\n\t\tcmd->header.size = sizeof(cmd->body);\n\t\tcmd->body.image.sid = res->id;\n\t\tcmd->body.image.face = 0;\n\t\tcmd->body.image.mipmap = 0;\n\n\t\tif (clips->x1 > size->width || clips->x2 > size->width ||\n\t\t    clips->y1 > size->height || clips->y2 > size->height) {\n\t\t\tDRM_ERROR(\"Invalid clips outsize of framebuffer.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbox->x = clips->x1;\n\t\tbox->y = clips->y1;\n\t\tbox->z = 0;\n\t\tbox->w = clips->x2 - clips->x1;\n\t\tbox->h = clips->y2 - clips->y1;\n\t\tbox->d = 1;\n\n\t\tcopy_size += sizeof(*cmd);\n\t}\n\n\tvmw_cmd_commit(dev_priv, copy_size);\n\n\treturn 0;\n}\n\n \nvoid\nvmw_kms_create_implicit_placement_property(struct vmw_private *dev_priv)\n{\n\tif (dev_priv->implicit_placement_property)\n\t\treturn;\n\n\tdev_priv->implicit_placement_property =\n\t\tdrm_property_create_range(&dev_priv->drm,\n\t\t\t\t\t  DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t\t  \"implicit_placement\", 0, 1);\n}\n\n \nint vmw_kms_suspend(struct drm_device *dev)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\n\tdev_priv->suspend_state = drm_atomic_helper_suspend(dev);\n\tif (IS_ERR(dev_priv->suspend_state)) {\n\t\tint ret = PTR_ERR(dev_priv->suspend_state);\n\n\t\tDRM_ERROR(\"Failed kms suspend: %d\\n\", ret);\n\t\tdev_priv->suspend_state = NULL;\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n\n \nint vmw_kms_resume(struct drm_device *dev)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tint ret;\n\n\tif (WARN_ON(!dev_priv->suspend_state))\n\t\treturn 0;\n\n\tret = drm_atomic_helper_resume(dev, dev_priv->suspend_state);\n\tdev_priv->suspend_state = NULL;\n\n\treturn ret;\n}\n\n \nvoid vmw_kms_lost_device(struct drm_device *dev)\n{\n\tdrm_atomic_helper_shutdown(dev);\n}\n\n \nint vmw_du_helper_plane_update(struct vmw_du_update_plane *update)\n{\n\tstruct drm_plane_state *state = update->plane->state;\n\tstruct drm_plane_state *old_state = update->old_state;\n\tstruct drm_atomic_helper_damage_iter iter;\n\tstruct drm_rect clip;\n\tstruct drm_rect bb;\n\tDECLARE_VAL_CONTEXT(val_ctx, NULL, 0);\n\tuint32_t reserved_size = 0;\n\tuint32_t submit_size = 0;\n\tuint32_t curr_size = 0;\n\tuint32_t num_hits = 0;\n\tvoid *cmd_start;\n\tchar *cmd_next;\n\tint ret;\n\n\t \n\tdrm_atomic_helper_damage_iter_init(&iter, old_state, state);\n\tdrm_atomic_for_each_plane_damage(&iter, &clip)\n\t\tnum_hits++;\n\n\tif (num_hits == 0)\n\t\treturn 0;\n\n\tif (update->vfb->bo) {\n\t\tstruct vmw_framebuffer_bo *vfbbo =\n\t\t\tcontainer_of(update->vfb, typeof(*vfbbo), base);\n\n\t\t \n\t\tif (update->dev_priv->active_display_unit == vmw_du_screen_target) {\n\t\t\tvmw_bo_placement_set(vfbbo->buffer,\n\t\t\t\t\t     VMW_BO_DOMAIN_SYS | VMW_BO_DOMAIN_MOB | VMW_BO_DOMAIN_GMR,\n\t\t\t\t\t     VMW_BO_DOMAIN_SYS | VMW_BO_DOMAIN_MOB | VMW_BO_DOMAIN_GMR);\n\t\t} else {\n\t\t\tWARN_ON(update->dev_priv->has_mob);\n\t\t\tvmw_bo_placement_set_default_accelerated(vfbbo->buffer);\n\t\t}\n\t\tret = vmw_validation_add_bo(&val_ctx, vfbbo->buffer);\n\t} else {\n\t\tstruct vmw_framebuffer_surface *vfbs =\n\t\t\tcontainer_of(update->vfb, typeof(*vfbs), base);\n\n\t\tret = vmw_validation_add_resource(&val_ctx, &vfbs->surface->res,\n\t\t\t\t\t\t  0, VMW_RES_DIRTY_NONE, NULL,\n\t\t\t\t\t\t  NULL);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = vmw_validation_prepare(&val_ctx, update->mutex, update->intr);\n\tif (ret)\n\t\tgoto out_unref;\n\n\treserved_size = update->calc_fifo_size(update, num_hits);\n\tcmd_start = VMW_CMD_RESERVE(update->dev_priv, reserved_size);\n\tif (!cmd_start) {\n\t\tret = -ENOMEM;\n\t\tgoto out_revert;\n\t}\n\n\tcmd_next = cmd_start;\n\n\tif (update->post_prepare) {\n\t\tcurr_size = update->post_prepare(update, cmd_next);\n\t\tcmd_next += curr_size;\n\t\tsubmit_size += curr_size;\n\t}\n\n\tif (update->pre_clip) {\n\t\tcurr_size = update->pre_clip(update, cmd_next, num_hits);\n\t\tcmd_next += curr_size;\n\t\tsubmit_size += curr_size;\n\t}\n\n\tbb.x1 = INT_MAX;\n\tbb.y1 = INT_MAX;\n\tbb.x2 = INT_MIN;\n\tbb.y2 = INT_MIN;\n\n\tdrm_atomic_helper_damage_iter_init(&iter, old_state, state);\n\tdrm_atomic_for_each_plane_damage(&iter, &clip) {\n\t\tuint32_t fb_x = clip.x1;\n\t\tuint32_t fb_y = clip.y1;\n\n\t\tvmw_du_translate_to_crtc(state, &clip);\n\t\tif (update->clip) {\n\t\t\tcurr_size = update->clip(update, cmd_next, &clip, fb_x,\n\t\t\t\t\t\t fb_y);\n\t\t\tcmd_next += curr_size;\n\t\t\tsubmit_size += curr_size;\n\t\t}\n\t\tbb.x1 = min_t(int, bb.x1, clip.x1);\n\t\tbb.y1 = min_t(int, bb.y1, clip.y1);\n\t\tbb.x2 = max_t(int, bb.x2, clip.x2);\n\t\tbb.y2 = max_t(int, bb.y2, clip.y2);\n\t}\n\n\tcurr_size = update->post_clip(update, cmd_next, &bb);\n\tsubmit_size += curr_size;\n\n\tif (reserved_size < submit_size)\n\t\tsubmit_size = 0;\n\n\tvmw_cmd_commit(update->dev_priv, submit_size);\n\n\tvmw_kms_helper_validation_finish(update->dev_priv, NULL, &val_ctx,\n\t\t\t\t\t update->out_fence, NULL);\n\treturn ret;\n\nout_revert:\n\tvmw_validation_revert(&val_ctx);\n\nout_unref:\n\tvmw_validation_unref_lists(&val_ctx);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}