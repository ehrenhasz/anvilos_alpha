{
  "module_name": "vmwgfx_va.c",
  "hash_id": "d1113368c50d5d642349c82839d25fd47978d9318ff15c8e7d85458efc0f0449",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_va.c",
  "human_readable_source": "\n \n\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_resource_priv.h\"\n\n \nstruct vmw_stream {\n\tstruct vmw_simple_resource sres;\n\tu32 stream_id;\n};\n\n \nstatic struct vmw_stream *\nvmw_stream(struct vmw_resource *res)\n{\n\treturn container_of(res, struct vmw_stream, sres.res);\n}\n\n \nstatic void vmw_stream_hw_destroy(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct vmw_stream *stream = vmw_stream(res);\n\tint ret;\n\n\tret = vmw_overlay_unref(dev_priv, stream->stream_id);\n\tWARN_ON_ONCE(ret != 0);\n}\n\nstatic int vmw_stream_init(struct vmw_resource *res, void *data)\n{\n\tstruct vmw_stream *stream = vmw_stream(res);\n\n\treturn vmw_overlay_claim(res->dev_priv, &stream->stream_id);\n}\n\nstatic void vmw_stream_set_arg_handle(void *data, u32 handle)\n{\n\tstruct drm_vmw_stream_arg *arg = (struct drm_vmw_stream_arg *)data;\n\n\targ->stream_id = handle;\n}\n\nstatic const struct vmw_simple_resource_func va_stream_func = {\n\t.res_func = {\n\t\t.res_type = vmw_res_stream,\n\t\t.needs_guest_memory = false,\n\t\t.may_evict = false,\n\t\t.type_name = \"overlay stream\",\n\t\t.domain = VMW_BO_DOMAIN_SYS,\n\t\t.busy_domain = VMW_BO_DOMAIN_SYS,\n\t\t.create = NULL,\n\t\t.destroy = NULL,\n\t\t.bind = NULL,\n\t\t.unbind = NULL\n\t},\n\t.ttm_res_type = VMW_RES_STREAM,\n\t.size = sizeof(struct vmw_stream),\n\t.init = vmw_stream_init,\n\t.hw_destroy = vmw_stream_hw_destroy,\n\t.set_arg_handle = vmw_stream_set_arg_handle,\n};\n\n \n\n \nint vmw_stream_unref_ioctl(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file_priv)\n{\n\tstruct drm_vmw_stream_arg *arg = (struct drm_vmw_stream_arg *)data;\n\n\treturn ttm_ref_object_base_unref(vmw_fpriv(file_priv)->tfile,\n\t\t\t\t\t arg->stream_id);\n}\n\n \nint vmw_stream_claim_ioctl(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file_priv)\n{\n\treturn vmw_simple_resource_create_ioctl(dev, data, file_priv,\n\t\t\t\t\t\t&va_stream_func);\n}\n\n \nint vmw_user_stream_lookup(struct vmw_private *dev_priv,\n\t\t\t   struct ttm_object_file *tfile,\n\t\t\t   uint32_t *inout_id, struct vmw_resource **out)\n{\n\tstruct vmw_stream *stream;\n\tstruct vmw_resource *res =\n\t\tvmw_simple_resource_lookup(tfile, *inout_id, &va_stream_func);\n\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\n\tstream = vmw_stream(res);\n\t*inout_id = stream->stream_id;\n\t*out = res;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}