{
  "module_name": "vmwgfx_scrn.c",
  "hash_id": "3e49c9e8d97f89e5e187700bb965701e0a1d1583abd979890e4405a0b3840c51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c",
  "human_readable_source": "\n \n\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_kms.h\"\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_fourcc.h>\n\n#define vmw_crtc_to_sou(x) \\\n\tcontainer_of(x, struct vmw_screen_object_unit, base.crtc)\n#define vmw_encoder_to_sou(x) \\\n\tcontainer_of(x, struct vmw_screen_object_unit, base.encoder)\n#define vmw_connector_to_sou(x) \\\n\tcontainer_of(x, struct vmw_screen_object_unit, base.connector)\n\n \nstruct vmw_kms_sou_surface_dirty {\n\tstruct vmw_kms_dirty base;\n\ts32 left, right, top, bottom;\n\ts32 dst_x, dst_y;\n\tu32 sid;\n};\n\n \nstruct vmw_kms_sou_readback_blit {\n\tuint32 header;\n\tSVGAFifoCmdBlitScreenToGMRFB body;\n};\n\nstruct vmw_kms_sou_bo_blit {\n\tuint32 header;\n\tSVGAFifoCmdBlitGMRFBToScreen body;\n};\n\nstruct vmw_kms_sou_dirty_cmd {\n\tSVGA3dCmdHeader header;\n\tSVGA3dCmdBlitSurfaceToScreen body;\n};\n\nstruct vmw_kms_sou_define_gmrfb {\n\tuint32_t header;\n\tSVGAFifoCmdDefineGMRFB body;\n};\n\n \nstruct vmw_screen_object_unit {\n\tstruct vmw_display_unit base;\n\n\tunsigned long buffer_size;  \n\tstruct vmw_bo *buffer;  \n\n\tbool defined;\n};\n\nstatic void vmw_sou_destroy(struct vmw_screen_object_unit *sou)\n{\n\tvmw_du_cleanup(&sou->base);\n\tkfree(sou);\n}\n\n\n \n\nstatic void vmw_sou_crtc_destroy(struct drm_crtc *crtc)\n{\n\tvmw_sou_destroy(vmw_crtc_to_sou(crtc));\n}\n\n \nstatic int vmw_sou_fifo_create(struct vmw_private *dev_priv,\n\t\t\t       struct vmw_screen_object_unit *sou,\n\t\t\t       int x, int y,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tsize_t fifo_size;\n\n\tstruct {\n\t\tstruct {\n\t\t\tuint32_t cmdType;\n\t\t} header;\n\t\tSVGAScreenObject obj;\n\t} *cmd;\n\n\tBUG_ON(!sou->buffer);\n\n\tfifo_size = sizeof(*cmd);\n\tcmd = VMW_CMD_RESERVE(dev_priv, fifo_size);\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tmemset(cmd, 0, fifo_size);\n\tcmd->header.cmdType = SVGA_CMD_DEFINE_SCREEN;\n\tcmd->obj.structSize = sizeof(SVGAScreenObject);\n\tcmd->obj.id = sou->base.unit;\n\tcmd->obj.flags = SVGA_SCREEN_HAS_ROOT |\n\t\t(sou->base.unit == 0 ? SVGA_SCREEN_IS_PRIMARY : 0);\n\tcmd->obj.size.width = mode->hdisplay;\n\tcmd->obj.size.height = mode->vdisplay;\n\tcmd->obj.root.x = x;\n\tcmd->obj.root.y = y;\n\tsou->base.set_gui_x = cmd->obj.root.x;\n\tsou->base.set_gui_y = cmd->obj.root.y;\n\n\t \n\tvmw_bo_get_guest_ptr(&sou->buffer->tbo, &cmd->obj.backingStore.ptr);\n\tcmd->obj.backingStore.pitch = mode->hdisplay * 4;\n\n\tvmw_cmd_commit(dev_priv, fifo_size);\n\n\tsou->defined = true;\n\n\treturn 0;\n}\n\n \nstatic int vmw_sou_fifo_destroy(struct vmw_private *dev_priv,\n\t\t\t\tstruct vmw_screen_object_unit *sou)\n{\n\tsize_t fifo_size;\n\tint ret;\n\n\tstruct {\n\t\tstruct {\n\t\t\tuint32_t cmdType;\n\t\t} header;\n\t\tSVGAFifoCmdDestroyScreen body;\n\t} *cmd;\n\n\t \n\tif (unlikely(!sou->defined))\n\t\treturn 0;\n\n\tfifo_size = sizeof(*cmd);\n\tcmd = VMW_CMD_RESERVE(dev_priv, fifo_size);\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tmemset(cmd, 0, fifo_size);\n\tcmd->header.cmdType = SVGA_CMD_DESTROY_SCREEN;\n\tcmd->body.screenId = sou->base.unit;\n\n\tvmw_cmd_commit(dev_priv, fifo_size);\n\n\t \n\tret = vmw_fallback_wait(dev_priv, false, true, 0, false, 3*HZ);\n\tif (unlikely(ret != 0))\n\t\tDRM_ERROR(\"Failed to sync with HW\");\n\telse\n\t\tsou->defined = false;\n\n\treturn ret;\n}\n\n \nstatic void vmw_sou_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct vmw_private *dev_priv;\n\tstruct vmw_screen_object_unit *sou;\n\tstruct vmw_framebuffer *vfb;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_plane_state *ps;\n\tstruct vmw_plane_state *vps;\n\tint ret;\n\n\tsou = vmw_crtc_to_sou(crtc);\n\tdev_priv = vmw_priv(crtc->dev);\n\tps = crtc->primary->state;\n\tfb = ps->fb;\n\tvps = vmw_plane_state_to_vps(ps);\n\n\tvfb = (fb) ? vmw_framebuffer_to_vfb(fb) : NULL;\n\n\tif (sou->defined) {\n\t\tret = vmw_sou_fifo_destroy(dev_priv, sou);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to destroy Screen Object\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (vfb) {\n\t\tstruct drm_connector_state *conn_state;\n\t\tstruct vmw_connector_state *vmw_conn_state;\n\t\tint x, y;\n\n\t\tsou->buffer = vps->bo;\n\t\tsou->buffer_size = vps->bo_size;\n\n\t\tconn_state = sou->base.connector.state;\n\t\tvmw_conn_state = vmw_connector_state_to_vcs(conn_state);\n\n\t\tx = vmw_conn_state->gui_x;\n\t\ty = vmw_conn_state->gui_y;\n\n\t\tret = vmw_sou_fifo_create(dev_priv, sou, x, y, &crtc->mode);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to define Screen Object %dx%d\\n\",\n\t\t\t\t  crtc->x, crtc->y);\n\n\t} else {\n\t\tsou->buffer = NULL;\n\t\tsou->buffer_size = 0;\n\t}\n}\n\n \nstatic void vmw_sou_crtc_helper_prepare(struct drm_crtc *crtc)\n{\n}\n\n \nstatic void vmw_sou_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n}\n\n \nstatic void vmw_sou_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct vmw_private *dev_priv;\n\tstruct vmw_screen_object_unit *sou;\n\tint ret;\n\n\n\tif (!crtc) {\n\t\tDRM_ERROR(\"CRTC is NULL\\n\");\n\t\treturn;\n\t}\n\n\tsou = vmw_crtc_to_sou(crtc);\n\tdev_priv = vmw_priv(crtc->dev);\n\n\tif (sou->defined) {\n\t\tret = vmw_sou_fifo_destroy(dev_priv, sou);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to destroy Screen Object\\n\");\n\t}\n}\n\nstatic const struct drm_crtc_funcs vmw_screen_object_crtc_funcs = {\n\t.gamma_set = vmw_du_crtc_gamma_set,\n\t.destroy = vmw_sou_crtc_destroy,\n\t.reset = vmw_du_crtc_reset,\n\t.atomic_duplicate_state = vmw_du_crtc_duplicate_state,\n\t.atomic_destroy_state = vmw_du_crtc_destroy_state,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n};\n\n \n\nstatic void vmw_sou_encoder_destroy(struct drm_encoder *encoder)\n{\n\tvmw_sou_destroy(vmw_encoder_to_sou(encoder));\n}\n\nstatic const struct drm_encoder_funcs vmw_screen_object_encoder_funcs = {\n\t.destroy = vmw_sou_encoder_destroy,\n};\n\n \n\nstatic void vmw_sou_connector_destroy(struct drm_connector *connector)\n{\n\tvmw_sou_destroy(vmw_connector_to_sou(connector));\n}\n\nstatic const struct drm_connector_funcs vmw_sou_connector_funcs = {\n\t.dpms = vmw_du_connector_dpms,\n\t.detect = vmw_du_connector_detect,\n\t.fill_modes = vmw_du_connector_fill_modes,\n\t.destroy = vmw_sou_connector_destroy,\n\t.reset = vmw_du_connector_reset,\n\t.atomic_duplicate_state = vmw_du_connector_duplicate_state,\n\t.atomic_destroy_state = vmw_du_connector_destroy_state,\n};\n\n\nstatic const struct\ndrm_connector_helper_funcs vmw_sou_connector_helper_funcs = {\n};\n\n\n\n \n\n \nstatic void\nvmw_sou_primary_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *old_state)\n{\n\tstruct vmw_plane_state *vps = vmw_plane_state_to_vps(old_state);\n\tstruct drm_crtc *crtc = plane->state->crtc ?\n\t\tplane->state->crtc : old_state->crtc;\n\n\tif (vps->bo)\n\t\tvmw_bo_unpin(vmw_priv(crtc->dev), vps->bo, false);\n\tvmw_bo_unreference(&vps->bo);\n\tvps->bo_size = 0;\n\n\tvmw_du_plane_cleanup_fb(plane, old_state);\n}\n\n\n \nstatic int\nvmw_sou_primary_plane_prepare_fb(struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *new_state)\n{\n\tstruct drm_framebuffer *new_fb = new_state->fb;\n\tstruct drm_crtc *crtc = plane->state->crtc ?: new_state->crtc;\n\tstruct vmw_plane_state *vps = vmw_plane_state_to_vps(new_state);\n\tstruct vmw_private *dev_priv;\n\tint ret;\n\tstruct vmw_bo_params bo_params = {\n\t\t.domain = VMW_BO_DOMAIN_VRAM,\n\t\t.busy_domain = VMW_BO_DOMAIN_VRAM,\n\t\t.bo_type = ttm_bo_type_device,\n\t\t.pin = true\n\t};\n\n\tif (!new_fb) {\n\t\tvmw_bo_unreference(&vps->bo);\n\t\tvps->bo_size = 0;\n\n\t\treturn 0;\n\t}\n\n\tbo_params.size = new_state->crtc_w * new_state->crtc_h * 4;\n\tdev_priv = vmw_priv(crtc->dev);\n\n\tif (vps->bo) {\n\t\tif (vps->bo_size == bo_params.size) {\n\t\t\t \n\t\t\treturn vmw_bo_pin_in_vram(dev_priv, vps->bo,\n\t\t\t\t\t\t      true);\n\t\t}\n\n\t\tvmw_bo_unreference(&vps->bo);\n\t\tvps->bo_size = 0;\n\t}\n\n\tvmw_svga_enable(dev_priv);\n\n\t \n\tvmw_overlay_pause_all(dev_priv);\n\tret = vmw_bo_create(dev_priv, &bo_params, &vps->bo);\n\tvmw_overlay_resume_all(dev_priv);\n\tif (ret)\n\t\treturn ret;\n\n\tvps->bo_size = bo_params.size;\n\n\t \n\treturn vmw_bo_pin_in_vram(dev_priv, vps->bo, true);\n}\n\nstatic uint32_t vmw_sou_bo_fifo_size(struct vmw_du_update_plane *update,\n\t\t\t\t     uint32_t num_hits)\n{\n\treturn sizeof(struct vmw_kms_sou_define_gmrfb) +\n\t\tsizeof(struct vmw_kms_sou_bo_blit) * num_hits;\n}\n\nstatic uint32_t vmw_sou_bo_define_gmrfb(struct vmw_du_update_plane *update,\n\t\t\t\t\tvoid *cmd)\n{\n\tstruct vmw_framebuffer_bo *vfbbo =\n\t\tcontainer_of(update->vfb, typeof(*vfbbo), base);\n\tstruct vmw_kms_sou_define_gmrfb *gmr = cmd;\n\tint depth = update->vfb->base.format->depth;\n\n\t \n\tif (depth == 32)\n\t\tdepth = 24;\n\n\tgmr->header = SVGA_CMD_DEFINE_GMRFB;\n\n\tgmr->body.format.bitsPerPixel = update->vfb->base.format->cpp[0] * 8;\n\tgmr->body.format.colorDepth = depth;\n\tgmr->body.format.reserved = 0;\n\tgmr->body.bytesPerLine = update->vfb->base.pitches[0];\n\tvmw_bo_get_guest_ptr(&vfbbo->buffer->tbo, &gmr->body.ptr);\n\n\treturn sizeof(*gmr);\n}\n\nstatic uint32_t vmw_sou_bo_populate_clip(struct vmw_du_update_plane  *update,\n\t\t\t\t\t void *cmd, struct drm_rect *clip,\n\t\t\t\t\t uint32_t fb_x, uint32_t fb_y)\n{\n\tstruct vmw_kms_sou_bo_blit *blit = cmd;\n\n\tblit->header = SVGA_CMD_BLIT_GMRFB_TO_SCREEN;\n\tblit->body.destScreenId = update->du->unit;\n\tblit->body.srcOrigin.x = fb_x;\n\tblit->body.srcOrigin.y = fb_y;\n\tblit->body.destRect.left = clip->x1;\n\tblit->body.destRect.top = clip->y1;\n\tblit->body.destRect.right = clip->x2;\n\tblit->body.destRect.bottom = clip->y2;\n\n\treturn sizeof(*blit);\n}\n\nstatic uint32_t vmw_stud_bo_post_clip(struct vmw_du_update_plane  *update,\n\t\t\t\t      void *cmd, struct drm_rect *bb)\n{\n\treturn 0;\n}\n\n \nstatic int vmw_sou_plane_update_bo(struct vmw_private *dev_priv,\n\t\t\t\t   struct drm_plane *plane,\n\t\t\t\t   struct drm_plane_state *old_state,\n\t\t\t\t   struct vmw_framebuffer *vfb,\n\t\t\t\t   struct vmw_fence_obj **out_fence)\n{\n\tstruct vmw_du_update_plane_buffer bo_update;\n\n\tmemset(&bo_update, 0, sizeof(struct vmw_du_update_plane_buffer));\n\tbo_update.base.plane = plane;\n\tbo_update.base.old_state = old_state;\n\tbo_update.base.dev_priv = dev_priv;\n\tbo_update.base.du = vmw_crtc_to_du(plane->state->crtc);\n\tbo_update.base.vfb = vfb;\n\tbo_update.base.out_fence = out_fence;\n\tbo_update.base.mutex = NULL;\n\tbo_update.base.intr = true;\n\n\tbo_update.base.calc_fifo_size = vmw_sou_bo_fifo_size;\n\tbo_update.base.post_prepare = vmw_sou_bo_define_gmrfb;\n\tbo_update.base.clip = vmw_sou_bo_populate_clip;\n\tbo_update.base.post_clip = vmw_stud_bo_post_clip;\n\n\treturn vmw_du_helper_plane_update(&bo_update.base);\n}\n\nstatic uint32_t vmw_sou_surface_fifo_size(struct vmw_du_update_plane *update,\n\t\t\t\t\t  uint32_t num_hits)\n{\n\treturn sizeof(struct vmw_kms_sou_dirty_cmd) + sizeof(SVGASignedRect) *\n\t\tnum_hits;\n}\n\nstatic uint32_t vmw_sou_surface_post_prepare(struct vmw_du_update_plane *update,\n\t\t\t\t\t     void *cmd)\n{\n\tstruct vmw_du_update_plane_surface *srf_update;\n\n\tsrf_update = container_of(update, typeof(*srf_update), base);\n\n\t \n\tsrf_update->cmd_start = cmd;\n\n\treturn 0;\n}\n\nstatic uint32_t vmw_sou_surface_pre_clip(struct vmw_du_update_plane *update,\n\t\t\t\t\t void *cmd, uint32_t num_hits)\n{\n\tstruct vmw_kms_sou_dirty_cmd *blit = cmd;\n\tstruct vmw_framebuffer_surface *vfbs;\n\n\tvfbs = container_of(update->vfb, typeof(*vfbs), base);\n\n\tblit->header.id = SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN;\n\tblit->header.size = sizeof(blit->body) + sizeof(SVGASignedRect) *\n\t\tnum_hits;\n\n\tblit->body.srcImage.sid = vfbs->surface->res.id;\n\tblit->body.destScreenId = update->du->unit;\n\n\t \n\tblit->body.srcRect.left = 0;\n\tblit->body.srcRect.top = 0;\n\tblit->body.srcRect.right = 0;\n\tblit->body.srcRect.bottom = 0;\n\n\tblit->body.destRect.left = 0;\n\tblit->body.destRect.top = 0;\n\tblit->body.destRect.right = 0;\n\tblit->body.destRect.bottom = 0;\n\n\treturn sizeof(*blit);\n}\n\nstatic uint32_t vmw_sou_surface_clip_rect(struct vmw_du_update_plane *update,\n\t\t\t\t\t  void *cmd, struct drm_rect *clip,\n\t\t\t\t\t  uint32_t src_x, uint32_t src_y)\n{\n\tSVGASignedRect *rect = cmd;\n\n\t \n\trect->left = clip->x1;\n\trect->top = clip->y1;\n\trect->right = clip->x2;\n\trect->bottom = clip->y2;\n\n\treturn sizeof(*rect);\n}\n\nstatic uint32_t vmw_sou_surface_post_clip(struct vmw_du_update_plane *update,\n\t\t\t\t\t  void *cmd, struct drm_rect *bb)\n{\n\tstruct vmw_du_update_plane_surface *srf_update;\n\tstruct drm_plane_state *state = update->plane->state;\n\tstruct drm_rect src_bb;\n\tstruct vmw_kms_sou_dirty_cmd *blit;\n\tSVGASignedRect *rect;\n\tuint32_t num_hits;\n\tint translate_src_x;\n\tint translate_src_y;\n\tint i;\n\n\tsrf_update = container_of(update, typeof(*srf_update), base);\n\n\tblit = srf_update->cmd_start;\n\trect = (SVGASignedRect *)&blit[1];\n\n\tnum_hits = (blit->header.size - sizeof(blit->body))/\n\t\tsizeof(SVGASignedRect);\n\n\tsrc_bb = *bb;\n\n\t \n\ttranslate_src_x = (state->src_x >> 16) - state->crtc_x;\n\ttranslate_src_y = (state->src_y >> 16) - state->crtc_y;\n\n\tdrm_rect_translate(&src_bb, translate_src_x, translate_src_y);\n\n\tblit->body.srcRect.left = src_bb.x1;\n\tblit->body.srcRect.top = src_bb.y1;\n\tblit->body.srcRect.right = src_bb.x2;\n\tblit->body.srcRect.bottom = src_bb.y2;\n\n\tblit->body.destRect.left = bb->x1;\n\tblit->body.destRect.top = bb->y1;\n\tblit->body.destRect.right = bb->x2;\n\tblit->body.destRect.bottom = bb->y2;\n\n\t \n\tfor (i = 0; i < num_hits; i++) {\n\t\trect->left -= bb->x1;\n\t\trect->top -= bb->y1;\n\t\trect->right -= bb->x1;\n\t\trect->bottom -= bb->y1;\n\t\trect++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vmw_sou_plane_update_surface(struct vmw_private *dev_priv,\n\t\t\t\t\tstruct drm_plane *plane,\n\t\t\t\t\tstruct drm_plane_state *old_state,\n\t\t\t\t\tstruct vmw_framebuffer *vfb,\n\t\t\t\t\tstruct vmw_fence_obj **out_fence)\n{\n\tstruct vmw_du_update_plane_surface srf_update;\n\n\tmemset(&srf_update, 0, sizeof(struct vmw_du_update_plane_surface));\n\tsrf_update.base.plane = plane;\n\tsrf_update.base.old_state = old_state;\n\tsrf_update.base.dev_priv = dev_priv;\n\tsrf_update.base.du = vmw_crtc_to_du(plane->state->crtc);\n\tsrf_update.base.vfb = vfb;\n\tsrf_update.base.out_fence = out_fence;\n\tsrf_update.base.mutex = &dev_priv->cmdbuf_mutex;\n\tsrf_update.base.intr = true;\n\n\tsrf_update.base.calc_fifo_size = vmw_sou_surface_fifo_size;\n\tsrf_update.base.post_prepare = vmw_sou_surface_post_prepare;\n\tsrf_update.base.pre_clip = vmw_sou_surface_pre_clip;\n\tsrf_update.base.clip = vmw_sou_surface_clip_rect;\n\tsrf_update.base.post_clip = vmw_sou_surface_post_clip;\n\n\treturn vmw_du_helper_plane_update(&srf_update.base);\n}\n\nstatic void\nvmw_sou_primary_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_crtc *crtc = new_state->crtc;\n\tstruct vmw_fence_obj *fence = NULL;\n\tint ret;\n\n\t \n\tif (crtc && new_state->fb) {\n\t\tstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\n\t\tstruct vmw_framebuffer *vfb =\n\t\t\tvmw_framebuffer_to_vfb(new_state->fb);\n\n\t\tif (vfb->bo)\n\t\t\tret = vmw_sou_plane_update_bo(dev_priv, plane,\n\t\t\t\t\t\t      old_state, vfb, &fence);\n\t\telse\n\t\t\tret = vmw_sou_plane_update_surface(dev_priv, plane,\n\t\t\t\t\t\t\t   old_state, vfb,\n\t\t\t\t\t\t\t   &fence);\n\t\tif (ret != 0)\n\t\t\tDRM_ERROR(\"Failed to update screen.\\n\");\n\t} else {\n\t\t \n\t\treturn;\n\t}\n\n\tif (fence)\n\t\tvmw_fence_obj_unreference(&fence);\n}\n\n\nstatic const struct drm_plane_funcs vmw_sou_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = vmw_du_primary_plane_destroy,\n\t.reset = vmw_du_plane_reset,\n\t.atomic_duplicate_state = vmw_du_plane_duplicate_state,\n\t.atomic_destroy_state = vmw_du_plane_destroy_state,\n};\n\nstatic const struct drm_plane_funcs vmw_sou_cursor_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = vmw_du_cursor_plane_destroy,\n\t.reset = vmw_du_plane_reset,\n\t.atomic_duplicate_state = vmw_du_plane_duplicate_state,\n\t.atomic_destroy_state = vmw_du_plane_destroy_state,\n};\n\n \nstatic const struct\ndrm_plane_helper_funcs vmw_sou_cursor_plane_helper_funcs = {\n\t.atomic_check = vmw_du_cursor_plane_atomic_check,\n\t.atomic_update = vmw_du_cursor_plane_atomic_update,\n\t.prepare_fb = vmw_du_cursor_plane_prepare_fb,\n\t.cleanup_fb = vmw_du_cursor_plane_cleanup_fb,\n};\n\nstatic const struct\ndrm_plane_helper_funcs vmw_sou_primary_plane_helper_funcs = {\n\t.atomic_check = vmw_du_primary_plane_atomic_check,\n\t.atomic_update = vmw_sou_primary_plane_atomic_update,\n\t.prepare_fb = vmw_sou_primary_plane_prepare_fb,\n\t.cleanup_fb = vmw_sou_primary_plane_cleanup_fb,\n};\n\nstatic const struct drm_crtc_helper_funcs vmw_sou_crtc_helper_funcs = {\n\t.prepare = vmw_sou_crtc_helper_prepare,\n\t.mode_set_nofb = vmw_sou_crtc_mode_set_nofb,\n\t.atomic_check = vmw_du_crtc_atomic_check,\n\t.atomic_begin = vmw_du_crtc_atomic_begin,\n\t.atomic_flush = vmw_du_crtc_atomic_flush,\n\t.atomic_enable = vmw_sou_crtc_atomic_enable,\n\t.atomic_disable = vmw_sou_crtc_atomic_disable,\n};\n\n\nstatic int vmw_sou_init(struct vmw_private *dev_priv, unsigned unit)\n{\n\tstruct vmw_screen_object_unit *sou;\n\tstruct drm_device *dev = &dev_priv->drm;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct drm_plane *primary;\n\tstruct vmw_cursor_plane *cursor;\n\tstruct drm_crtc *crtc;\n\tint ret;\n\n\tsou = kzalloc(sizeof(*sou), GFP_KERNEL);\n\tif (!sou)\n\t\treturn -ENOMEM;\n\n\tsou->base.unit = unit;\n\tcrtc = &sou->base.crtc;\n\tencoder = &sou->base.encoder;\n\tconnector = &sou->base.connector;\n\tprimary = &sou->base.primary;\n\tcursor = &sou->base.cursor;\n\n\tsou->base.pref_active = (unit == 0);\n\tsou->base.pref_width = dev_priv->initial_width;\n\tsou->base.pref_height = dev_priv->initial_height;\n\tsou->base.pref_mode = NULL;\n\n\t \n\tsou->base.is_implicit = false;\n\n\t \n\tret = drm_universal_plane_init(dev, primary,\n\t\t\t\t       0, &vmw_sou_plane_funcs,\n\t\t\t\t       vmw_primary_plane_formats,\n\t\t\t\t       ARRAY_SIZE(vmw_primary_plane_formats),\n\t\t\t\t       NULL, DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize primary plane\");\n\t\tgoto err_free;\n\t}\n\n\tdrm_plane_helper_add(primary, &vmw_sou_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary);\n\n\t \n\tret = drm_universal_plane_init(dev, &cursor->base,\n\t\t\t0, &vmw_sou_cursor_funcs,\n\t\t\tvmw_cursor_plane_formats,\n\t\t\tARRAY_SIZE(vmw_cursor_plane_formats),\n\t\t\tNULL, DRM_PLANE_TYPE_CURSOR, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize cursor plane\");\n\t\tdrm_plane_cleanup(&sou->base.primary);\n\t\tgoto err_free;\n\t}\n\n\tdrm_plane_helper_add(&cursor->base, &vmw_sou_cursor_plane_helper_funcs);\n\n\tret = drm_connector_init(dev, connector, &vmw_sou_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_VIRTUAL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize connector\\n\");\n\t\tgoto err_free;\n\t}\n\n\tdrm_connector_helper_add(connector, &vmw_sou_connector_helper_funcs);\n\tconnector->status = vmw_du_connector_detect(connector, true);\n\n\tret = drm_encoder_init(dev, encoder, &vmw_screen_object_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_VIRTUAL, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize encoder\\n\");\n\t\tgoto err_free_connector;\n\t}\n\n\t(void) drm_connector_attach_encoder(connector, encoder);\n\tencoder->possible_crtcs = (1 << unit);\n\tencoder->possible_clones = 0;\n\n\tret = drm_connector_register(connector);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to register connector\\n\");\n\t\tgoto err_free_encoder;\n\t}\n\n\tret = drm_crtc_init_with_planes(dev, crtc, primary,\n\t\t\t\t\t&cursor->base,\n\t\t\t\t\t&vmw_screen_object_crtc_funcs, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize CRTC\\n\");\n\t\tgoto err_free_unregister;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &vmw_sou_crtc_helper_funcs);\n\n\tdrm_mode_crtc_set_gamma_size(crtc, 256);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev_priv->hotplug_mode_update_property, 1);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.suggested_x_property, 0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.suggested_y_property, 0);\n\treturn 0;\n\nerr_free_unregister:\n\tdrm_connector_unregister(connector);\nerr_free_encoder:\n\tdrm_encoder_cleanup(encoder);\nerr_free_connector:\n\tdrm_connector_cleanup(connector);\nerr_free:\n\tkfree(sou);\n\treturn ret;\n}\n\nint vmw_kms_sou_init_display(struct vmw_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->drm;\n\tint i;\n\n\t \n\tif (!dev_priv->has_gmr)\n\t\treturn -ENOSYS;\n\n\tif (!(dev_priv->capabilities & SVGA_CAP_SCREEN_OBJECT_2)) {\n\t\treturn -ENOSYS;\n\t}\n\n\tfor (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i)\n\t\tvmw_sou_init(dev_priv, i);\n\n\tdev_priv->active_display_unit = vmw_du_screen_object;\n\n\tdrm_mode_config_reset(dev);\n\n\treturn 0;\n}\n\nstatic int do_bo_define_gmrfb(struct vmw_private *dev_priv,\n\t\t\t\t  struct vmw_framebuffer *framebuffer)\n{\n\tstruct vmw_bo *buf =\n\t\tcontainer_of(framebuffer, struct vmw_framebuffer_bo,\n\t\t\t     base)->buffer;\n\tint depth = framebuffer->base.format->depth;\n\tstruct {\n\t\tuint32_t header;\n\t\tSVGAFifoCmdDefineGMRFB body;\n\t} *cmd;\n\n\t \n\tif (depth == 32)\n\t\tdepth = 24;\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header = SVGA_CMD_DEFINE_GMRFB;\n\tcmd->body.format.bitsPerPixel = framebuffer->base.format->cpp[0] * 8;\n\tcmd->body.format.colorDepth = depth;\n\tcmd->body.format.reserved = 0;\n\tcmd->body.bytesPerLine = framebuffer->base.pitches[0];\n\t \n\tvmw_bo_get_guest_ptr(&buf->tbo, &cmd->body.ptr);\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\treturn 0;\n}\n\n \nstatic void vmw_sou_surface_fifo_commit(struct vmw_kms_dirty *dirty)\n{\n\tstruct vmw_kms_sou_surface_dirty *sdirty =\n\t\tcontainer_of(dirty, typeof(*sdirty), base);\n\tstruct vmw_kms_sou_dirty_cmd *cmd = dirty->cmd;\n\ts32 trans_x = dirty->unit->crtc.x - sdirty->dst_x;\n\ts32 trans_y = dirty->unit->crtc.y - sdirty->dst_y;\n\tsize_t region_size = dirty->num_hits * sizeof(SVGASignedRect);\n\tSVGASignedRect *blit = (SVGASignedRect *) &cmd[1];\n\tint i;\n\n\tif (!dirty->num_hits) {\n\t\tvmw_cmd_commit(dirty->dev_priv, 0);\n\t\treturn;\n\t}\n\n\tcmd->header.id = SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN;\n\tcmd->header.size = sizeof(cmd->body) + region_size;\n\n\t \n\tcmd->body.destRect.left = sdirty->left;\n\tcmd->body.destRect.right = sdirty->right;\n\tcmd->body.destRect.top = sdirty->top;\n\tcmd->body.destRect.bottom = sdirty->bottom;\n\n\tcmd->body.srcRect.left = sdirty->left + trans_x;\n\tcmd->body.srcRect.right = sdirty->right + trans_x;\n\tcmd->body.srcRect.top = sdirty->top + trans_y;\n\tcmd->body.srcRect.bottom = sdirty->bottom + trans_y;\n\n\tcmd->body.srcImage.sid = sdirty->sid;\n\tcmd->body.destScreenId = dirty->unit->unit;\n\n\t \n\tfor (i = 0; i < dirty->num_hits; ++i, ++blit) {\n\t\tblit->left -= sdirty->left;\n\t\tblit->right -= sdirty->left;\n\t\tblit->top -= sdirty->top;\n\t\tblit->bottom -= sdirty->top;\n\t}\n\n\tvmw_cmd_commit(dirty->dev_priv, region_size + sizeof(*cmd));\n\n\tsdirty->left = sdirty->top = S32_MAX;\n\tsdirty->right = sdirty->bottom = S32_MIN;\n}\n\n \nstatic void vmw_sou_surface_clip(struct vmw_kms_dirty *dirty)\n{\n\tstruct vmw_kms_sou_surface_dirty *sdirty =\n\t\tcontainer_of(dirty, typeof(*sdirty), base);\n\tstruct vmw_kms_sou_dirty_cmd *cmd = dirty->cmd;\n\tSVGASignedRect *blit = (SVGASignedRect *) &cmd[1];\n\n\t \n\tblit += dirty->num_hits;\n\tblit->left = dirty->unit_x1;\n\tblit->top = dirty->unit_y1;\n\tblit->right = dirty->unit_x2;\n\tblit->bottom = dirty->unit_y2;\n\n\t \n\tsdirty->left = min_t(s32, sdirty->left, dirty->unit_x1);\n\tsdirty->top = min_t(s32, sdirty->top, dirty->unit_y1);\n\tsdirty->right = max_t(s32, sdirty->right, dirty->unit_x2);\n\tsdirty->bottom = max_t(s32, sdirty->bottom, dirty->unit_y2);\n\n\tdirty->num_hits++;\n}\n\n \nint vmw_kms_sou_do_surface_dirty(struct vmw_private *dev_priv,\n\t\t\t\t struct vmw_framebuffer *framebuffer,\n\t\t\t\t struct drm_clip_rect *clips,\n\t\t\t\t struct drm_vmw_rect *vclips,\n\t\t\t\t struct vmw_resource *srf,\n\t\t\t\t s32 dest_x,\n\t\t\t\t s32 dest_y,\n\t\t\t\t unsigned num_clips, int inc,\n\t\t\t\t struct vmw_fence_obj **out_fence,\n\t\t\t\t struct drm_crtc *crtc)\n{\n\tstruct vmw_framebuffer_surface *vfbs =\n\t\tcontainer_of(framebuffer, typeof(*vfbs), base);\n\tstruct vmw_kms_sou_surface_dirty sdirty;\n\tDECLARE_VAL_CONTEXT(val_ctx, NULL, 0);\n\tint ret;\n\n\tif (!srf)\n\t\tsrf = &vfbs->surface->res;\n\n\tret = vmw_validation_add_resource(&val_ctx, srf, 0, VMW_RES_DIRTY_NONE,\n\t\t\t\t\t  NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vmw_validation_prepare(&val_ctx, &dev_priv->cmdbuf_mutex, true);\n\tif (ret)\n\t\tgoto out_unref;\n\n\tsdirty.base.fifo_commit = vmw_sou_surface_fifo_commit;\n\tsdirty.base.clip = vmw_sou_surface_clip;\n\tsdirty.base.dev_priv = dev_priv;\n\tsdirty.base.fifo_reserve_size = sizeof(struct vmw_kms_sou_dirty_cmd) +\n\t  sizeof(SVGASignedRect) * num_clips;\n\tsdirty.base.crtc = crtc;\n\n\tsdirty.sid = srf->id;\n\tsdirty.left = sdirty.top = S32_MAX;\n\tsdirty.right = sdirty.bottom = S32_MIN;\n\tsdirty.dst_x = dest_x;\n\tsdirty.dst_y = dest_y;\n\n\tret = vmw_kms_helper_dirty(dev_priv, framebuffer, clips, vclips,\n\t\t\t\t   dest_x, dest_y, num_clips, inc,\n\t\t\t\t   &sdirty.base);\n\tvmw_kms_helper_validation_finish(dev_priv, NULL, &val_ctx, out_fence,\n\t\t\t\t\t NULL);\n\n\treturn ret;\n\nout_unref:\n\tvmw_validation_unref_lists(&val_ctx);\n\treturn ret;\n}\n\n \nstatic void vmw_sou_bo_fifo_commit(struct vmw_kms_dirty *dirty)\n{\n\tif (!dirty->num_hits) {\n\t\tvmw_cmd_commit(dirty->dev_priv, 0);\n\t\treturn;\n\t}\n\n\tvmw_cmd_commit(dirty->dev_priv,\n\t\t\tsizeof(struct vmw_kms_sou_bo_blit) *\n\t\t\tdirty->num_hits);\n}\n\n \nstatic void vmw_sou_bo_clip(struct vmw_kms_dirty *dirty)\n{\n\tstruct vmw_kms_sou_bo_blit *blit = dirty->cmd;\n\n\tblit += dirty->num_hits;\n\tblit->header = SVGA_CMD_BLIT_GMRFB_TO_SCREEN;\n\tblit->body.destScreenId = dirty->unit->unit;\n\tblit->body.srcOrigin.x = dirty->fb_x;\n\tblit->body.srcOrigin.y = dirty->fb_y;\n\tblit->body.destRect.left = dirty->unit_x1;\n\tblit->body.destRect.top = dirty->unit_y1;\n\tblit->body.destRect.right = dirty->unit_x2;\n\tblit->body.destRect.bottom = dirty->unit_y2;\n\tdirty->num_hits++;\n}\n\n \nint vmw_kms_sou_do_bo_dirty(struct vmw_private *dev_priv,\n\t\t\t\tstruct vmw_framebuffer *framebuffer,\n\t\t\t\tstruct drm_clip_rect *clips,\n\t\t\t\tstruct drm_vmw_rect *vclips,\n\t\t\t\tunsigned num_clips, int increment,\n\t\t\t\tbool interruptible,\n\t\t\t\tstruct vmw_fence_obj **out_fence,\n\t\t\t\tstruct drm_crtc *crtc)\n{\n\tstruct vmw_bo *buf =\n\t\tcontainer_of(framebuffer, struct vmw_framebuffer_bo,\n\t\t\t     base)->buffer;\n\tstruct vmw_kms_dirty dirty;\n\tDECLARE_VAL_CONTEXT(val_ctx, NULL, 0);\n\tint ret;\n\n\tvmw_bo_placement_set(buf, VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM,\n\t\t\t     VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM);\n\tret = vmw_validation_add_bo(&val_ctx, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vmw_validation_prepare(&val_ctx, NULL, interruptible);\n\tif (ret)\n\t\tgoto out_unref;\n\n\tret = do_bo_define_gmrfb(dev_priv, framebuffer);\n\tif (unlikely(ret != 0))\n\t\tgoto out_revert;\n\n\tdirty.crtc = crtc;\n\tdirty.fifo_commit = vmw_sou_bo_fifo_commit;\n\tdirty.clip = vmw_sou_bo_clip;\n\tdirty.fifo_reserve_size = sizeof(struct vmw_kms_sou_bo_blit) *\n\t\tnum_clips;\n\tret = vmw_kms_helper_dirty(dev_priv, framebuffer, clips, vclips,\n\t\t\t\t   0, 0, num_clips, increment, &dirty);\n\tvmw_kms_helper_validation_finish(dev_priv, NULL, &val_ctx, out_fence,\n\t\t\t\t\t NULL);\n\n\treturn ret;\n\nout_revert:\n\tvmw_validation_revert(&val_ctx);\nout_unref:\n\tvmw_validation_unref_lists(&val_ctx);\n\n\treturn ret;\n}\n\n\n \nstatic void vmw_sou_readback_fifo_commit(struct vmw_kms_dirty *dirty)\n{\n\tif (!dirty->num_hits) {\n\t\tvmw_cmd_commit(dirty->dev_priv, 0);\n\t\treturn;\n\t}\n\n\tvmw_cmd_commit(dirty->dev_priv,\n\t\t\tsizeof(struct vmw_kms_sou_readback_blit) *\n\t\t\tdirty->num_hits);\n}\n\n \nstatic void vmw_sou_readback_clip(struct vmw_kms_dirty *dirty)\n{\n\tstruct vmw_kms_sou_readback_blit *blit = dirty->cmd;\n\n\tblit += dirty->num_hits;\n\tblit->header = SVGA_CMD_BLIT_SCREEN_TO_GMRFB;\n\tblit->body.srcScreenId = dirty->unit->unit;\n\tblit->body.destOrigin.x = dirty->fb_x;\n\tblit->body.destOrigin.y = dirty->fb_y;\n\tblit->body.srcRect.left = dirty->unit_x1;\n\tblit->body.srcRect.top = dirty->unit_y1;\n\tblit->body.srcRect.right = dirty->unit_x2;\n\tblit->body.srcRect.bottom = dirty->unit_y2;\n\tdirty->num_hits++;\n}\n\n \nint vmw_kms_sou_readback(struct vmw_private *dev_priv,\n\t\t\t struct drm_file *file_priv,\n\t\t\t struct vmw_framebuffer *vfb,\n\t\t\t struct drm_vmw_fence_rep __user *user_fence_rep,\n\t\t\t struct drm_vmw_rect *vclips,\n\t\t\t uint32_t num_clips,\n\t\t\t struct drm_crtc *crtc)\n{\n\tstruct vmw_bo *buf =\n\t\tcontainer_of(vfb, struct vmw_framebuffer_bo, base)->buffer;\n\tstruct vmw_kms_dirty dirty;\n\tDECLARE_VAL_CONTEXT(val_ctx, NULL, 0);\n\tint ret;\n\n\tvmw_bo_placement_set(buf, VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM,\n\t\t\t     VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM);\n\tret = vmw_validation_add_bo(&val_ctx, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vmw_validation_prepare(&val_ctx, NULL, true);\n\tif (ret)\n\t\tgoto out_unref;\n\n\tret = do_bo_define_gmrfb(dev_priv, vfb);\n\tif (unlikely(ret != 0))\n\t\tgoto out_revert;\n\n\tdirty.crtc = crtc;\n\tdirty.fifo_commit = vmw_sou_readback_fifo_commit;\n\tdirty.clip = vmw_sou_readback_clip;\n\tdirty.fifo_reserve_size = sizeof(struct vmw_kms_sou_readback_blit) *\n\t\tnum_clips;\n\tret = vmw_kms_helper_dirty(dev_priv, vfb, NULL, vclips,\n\t\t\t\t   0, 0, num_clips, 1, &dirty);\n\tvmw_kms_helper_validation_finish(dev_priv, file_priv, &val_ctx, NULL,\n\t\t\t\t\t user_fence_rep);\n\n\treturn ret;\n\nout_revert:\n\tvmw_validation_revert(&val_ctx);\nout_unref:\n\tvmw_validation_unref_lists(&val_ctx);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}