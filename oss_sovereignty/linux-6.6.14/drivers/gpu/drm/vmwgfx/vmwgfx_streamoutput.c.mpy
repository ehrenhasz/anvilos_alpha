{
  "module_name": "vmwgfx_streamoutput.c",
  "hash_id": "ed3868c0b126d1bdac4908cfce72d6feb97ce84058615d23cb8dfc23ff5af92c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_streamoutput.c",
  "human_readable_source": "\n \n\n#include \"vmwgfx_binding.h\"\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_resource_priv.h\"\n\n#include <drm/ttm/ttm_placement.h>\n\n \nstruct vmw_dx_streamoutput {\n\tstruct vmw_resource res;\n\tstruct vmw_resource *ctx;\n\tstruct vmw_resource *cotable;\n\tstruct list_head cotable_head;\n\tu32 id;\n\tu32 size;\n\tbool committed;\n};\n\nstatic int vmw_dx_streamoutput_create(struct vmw_resource *res);\nstatic int vmw_dx_streamoutput_bind(struct vmw_resource *res,\n\t\t\t\t    struct ttm_validate_buffer *val_buf);\nstatic int vmw_dx_streamoutput_unbind(struct vmw_resource *res, bool readback,\n\t\t\t\t      struct ttm_validate_buffer *val_buf);\nstatic void vmw_dx_streamoutput_commit_notify(struct vmw_resource *res,\n\t\t\t\t\t      enum vmw_cmdbuf_res_state state);\n\nstatic const struct vmw_res_func vmw_dx_streamoutput_func = {\n\t.res_type = vmw_res_streamoutput,\n\t.needs_guest_memory = true,\n\t.may_evict = false,\n\t.type_name = \"DX streamoutput\",\n\t.domain = VMW_BO_DOMAIN_MOB,\n\t.busy_domain = VMW_BO_DOMAIN_MOB,\n\t.create = vmw_dx_streamoutput_create,\n\t.destroy = NULL,  \n\t.bind = vmw_dx_streamoutput_bind,\n\t.unbind = vmw_dx_streamoutput_unbind,\n\t.commit_notify = vmw_dx_streamoutput_commit_notify,\n};\n\nstatic inline struct vmw_dx_streamoutput *\nvmw_res_to_dx_streamoutput(struct vmw_resource *res)\n{\n\treturn container_of(res, struct vmw_dx_streamoutput, res);\n}\n\n \nstatic int vmw_dx_streamoutput_unscrub(struct vmw_resource *res)\n{\n\tstruct vmw_dx_streamoutput *so = vmw_res_to_dx_streamoutput(res);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXBindStreamOutput body;\n\t} *cmd;\n\n\tif (!list_empty(&so->cotable_head) || !so->committed )\n\t\treturn 0;\n\n\tcmd = VMW_CMD_CTX_RESERVE(dev_priv, sizeof(*cmd), so->ctx->id);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_DX_BIND_STREAMOUTPUT;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.soid = so->id;\n\tcmd->body.mobid = res->guest_memory_bo->tbo.resource->start;\n\tcmd->body.offsetInBytes = res->guest_memory_offset;\n\tcmd->body.sizeInBytes = so->size;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\tvmw_cotable_add_resource(so->cotable, &so->cotable_head);\n\n\treturn 0;\n}\n\nstatic int vmw_dx_streamoutput_create(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct vmw_dx_streamoutput *so = vmw_res_to_dx_streamoutput(res);\n\tint ret = 0;\n\n\tWARN_ON_ONCE(!so->committed);\n\n\tif (vmw_resource_mob_attached(res)) {\n\t\tmutex_lock(&dev_priv->binding_mutex);\n\t\tret = vmw_dx_streamoutput_unscrub(res);\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t}\n\n\tres->id = so->id;\n\n\treturn ret;\n}\n\nstatic int vmw_dx_streamoutput_bind(struct vmw_resource *res,\n\t\t\t\t    struct ttm_validate_buffer *val_buf)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct ttm_buffer_object *bo = val_buf->bo;\n\tint ret;\n\n\tif (WARN_ON(bo->resource->mem_type != VMW_PL_MOB))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tret = vmw_dx_streamoutput_unscrub(res);\n\tmutex_unlock(&dev_priv->binding_mutex);\n\n\treturn ret;\n}\n\n \nstatic int vmw_dx_streamoutput_scrub(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct vmw_dx_streamoutput *so = vmw_res_to_dx_streamoutput(res);\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXBindStreamOutput body;\n\t} *cmd;\n\n\tif (list_empty(&so->cotable_head))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!so->committed);\n\n\tcmd = VMW_CMD_CTX_RESERVE(dev_priv, sizeof(*cmd), so->ctx->id);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_DX_BIND_STREAMOUTPUT;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.soid = res->id;\n\tcmd->body.mobid = SVGA3D_INVALID_ID;\n\tcmd->body.offsetInBytes = 0;\n\tcmd->body.sizeInBytes = so->size;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\tres->id = -1;\n\tlist_del_init(&so->cotable_head);\n\n\treturn 0;\n}\n\nstatic int vmw_dx_streamoutput_unbind(struct vmw_resource *res, bool readback,\n\t\t\t\t      struct ttm_validate_buffer *val_buf)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct vmw_fence_obj *fence;\n\tint ret;\n\n\tif (WARN_ON(res->guest_memory_bo->tbo.resource->mem_type != VMW_PL_MOB))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tret = vmw_dx_streamoutput_scrub(res);\n\tmutex_unlock(&dev_priv->binding_mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\t(void) vmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);\n\tvmw_bo_fence_single(val_buf->bo, fence);\n\n\tif (fence != NULL)\n\t\tvmw_fence_obj_unreference(&fence);\n\n\treturn 0;\n}\n\nstatic void vmw_dx_streamoutput_commit_notify(struct vmw_resource *res,\n\t\t\t\t\t   enum vmw_cmdbuf_res_state state)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct vmw_dx_streamoutput *so = vmw_res_to_dx_streamoutput(res);\n\n\tif (state == VMW_CMDBUF_RES_ADD) {\n\t\tmutex_lock(&dev_priv->binding_mutex);\n\t\tvmw_cotable_add_resource(so->cotable, &so->cotable_head);\n\t\tso->committed = true;\n\t\tres->id = so->id;\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t} else {\n\t\tmutex_lock(&dev_priv->binding_mutex);\n\t\tlist_del_init(&so->cotable_head);\n\t\tso->committed = false;\n\t\tres->id = -1;\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t}\n}\n\n \nstruct vmw_resource *\nvmw_dx_streamoutput_lookup(struct vmw_cmdbuf_res_manager *man,\n\t\t\t   u32 user_key)\n{\n\treturn vmw_cmdbuf_res_lookup(man, vmw_cmdbuf_res_streamoutput,\n\t\t\t\t     user_key);\n}\n\nstatic void vmw_dx_streamoutput_res_free(struct vmw_resource *res)\n{\n\tstruct vmw_dx_streamoutput *so = vmw_res_to_dx_streamoutput(res);\n\n\tvmw_resource_unreference(&so->cotable);\n\tkfree(so);\n}\n\nstatic void vmw_dx_streamoutput_hw_destroy(struct vmw_resource *res)\n{\n\t \n\tres->id = -1;\n}\n\n \nint vmw_dx_streamoutput_add(struct vmw_cmdbuf_res_manager *man,\n\t\t\t    struct vmw_resource *ctx, u32 user_key,\n\t\t\t    struct list_head *list)\n{\n\tstruct vmw_dx_streamoutput *so;\n\tstruct vmw_resource *res;\n\tstruct vmw_private *dev_priv = ctx->dev_priv;\n\tint ret;\n\n\tso = kmalloc(sizeof(*so), GFP_KERNEL);\n\tif (!so) {\n\t\treturn -ENOMEM;\n\t}\n\n\tres = &so->res;\n\tso->ctx = ctx;\n\tso->cotable = vmw_resource_reference\n\t\t(vmw_context_cotable(ctx, SVGA_COTABLE_STREAMOUTPUT));\n\tso->id = user_key;\n\tso->committed = false;\n\tINIT_LIST_HEAD(&so->cotable_head);\n\tret = vmw_resource_init(dev_priv, res, true,\n\t\t\t\tvmw_dx_streamoutput_res_free,\n\t\t\t\t&vmw_dx_streamoutput_func);\n\tif (ret)\n\t\tgoto out_resource_init;\n\n\tret = vmw_cmdbuf_res_add(man, vmw_cmdbuf_res_streamoutput, user_key,\n\t\t\t\t res, list);\n\tif (ret)\n\t\tgoto out_resource_init;\n\n\tres->id = so->id;\n\tres->hw_destroy = vmw_dx_streamoutput_hw_destroy;\n\nout_resource_init:\n\tvmw_resource_unreference(&res);\n\n\treturn ret;\n}\n\n \nvoid vmw_dx_streamoutput_set_size(struct vmw_resource *res, u32 size)\n{\n\tstruct vmw_dx_streamoutput *so = vmw_res_to_dx_streamoutput(res);\n\n\tso->size = size;\n}\n\n \nint vmw_dx_streamoutput_remove(struct vmw_cmdbuf_res_manager *man,\n\t\t\t       u32 user_key,\n\t\t\t       struct list_head *list)\n{\n\tstruct vmw_resource *r;\n\n\treturn vmw_cmdbuf_res_remove(man, vmw_cmdbuf_res_streamoutput,\n\t\t\t\t     (u32)user_key, list, &r);\n}\n\n \nvoid vmw_dx_streamoutput_cotable_list_scrub(struct vmw_private *dev_priv,\n\t\t\t\t\t    struct list_head *list,\n\t\t\t\t\t    bool readback)\n{\n\tstruct vmw_dx_streamoutput *entry, *next;\n\n\tlockdep_assert_held_once(&dev_priv->binding_mutex);\n\n\tlist_for_each_entry_safe(entry, next, list, cotable_head) {\n\t\tWARN_ON(vmw_dx_streamoutput_scrub(&entry->res));\n\t\tif (!readback)\n\t\t\tentry->committed =false;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}