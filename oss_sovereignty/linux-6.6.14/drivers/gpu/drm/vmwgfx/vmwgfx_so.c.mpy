{
  "module_name": "vmwgfx_so.c",
  "hash_id": "2022d87493cf0c5793a4d97b5ebc158ae4331b5e50f2e6bd742e28163caa7cf1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_so.c",
  "human_readable_source": "\n \n\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_resource_priv.h\"\n#include \"vmwgfx_so.h\"\n#include \"vmwgfx_binding.h\"\n\n \n\n \nstruct vmw_view {\n\tstruct rcu_head rcu;\n\tstruct vmw_resource res;\n\tstruct vmw_resource *ctx;       \n\tstruct vmw_resource *srf;       \n\tstruct vmw_resource *cotable;   \n\tstruct list_head srf_head;      \n\tstruct list_head cotable_head;  \n\tunsigned view_type;             \n\tunsigned view_id;               \n\tu32 cmd_size;                   \n\tbool committed;                 \n\tu32 cmd[];\t\t        \n};\n\nstatic int vmw_view_create(struct vmw_resource *res);\nstatic int vmw_view_destroy(struct vmw_resource *res);\nstatic void vmw_hw_view_destroy(struct vmw_resource *res);\nstatic void vmw_view_commit_notify(struct vmw_resource *res,\n\t\t\t\t   enum vmw_cmdbuf_res_state state);\n\nstatic const struct vmw_res_func vmw_view_func = {\n\t.res_type = vmw_res_view,\n\t.needs_guest_memory = false,\n\t.may_evict = false,\n\t.type_name = \"DX view\",\n\t.domain = VMW_BO_DOMAIN_SYS,\n\t.busy_domain = VMW_BO_DOMAIN_SYS,\n\t.create = vmw_view_create,\n\t.commit_notify = vmw_view_commit_notify,\n};\n\n \nstruct vmw_view_define {\n\tuint32 view_id;\n\tuint32 sid;\n};\n\n \nstatic struct vmw_view *vmw_view(struct vmw_resource *res)\n{\n\treturn container_of(res, struct vmw_view, res);\n}\n\n \nstatic void vmw_view_commit_notify(struct vmw_resource *res,\n\t\t\t\t   enum vmw_cmdbuf_res_state state)\n{\n\tstruct vmw_view *view = vmw_view(res);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tif (state == VMW_CMDBUF_RES_ADD) {\n\t\tstruct vmw_surface *srf = vmw_res_to_srf(view->srf);\n\n\t\tlist_add_tail(&view->srf_head, &srf->view_list);\n\t\tvmw_cotable_add_resource(view->cotable, &view->cotable_head);\n\t\tview->committed = true;\n\t\tres->id = view->view_id;\n\n\t} else {\n\t\tlist_del_init(&view->cotable_head);\n\t\tlist_del_init(&view->srf_head);\n\t\tview->committed = false;\n\t\tres->id = -1;\n\t}\n\tmutex_unlock(&dev_priv->binding_mutex);\n}\n\n \nstatic int vmw_view_create(struct vmw_resource *res)\n{\n\tstruct vmw_view *view = vmw_view(res);\n\tstruct vmw_surface *srf = vmw_res_to_srf(view->srf);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tstruct vmw_view_define body;\n\t} *cmd;\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tif (!view->committed) {\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t\treturn 0;\n\t}\n\n\tcmd = VMW_CMD_CTX_RESERVE(res->dev_priv, view->cmd_size, view->ctx->id);\n\tif (!cmd) {\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(cmd, &view->cmd, view->cmd_size);\n\tWARN_ON(cmd->body.view_id != view->view_id);\n\t \n\tWARN_ON(view->srf->id == SVGA3D_INVALID_ID);\n\tcmd->body.sid = view->srf->id;\n\tvmw_cmd_commit(res->dev_priv, view->cmd_size);\n\tres->id = view->view_id;\n\tlist_add_tail(&view->srf_head, &srf->view_list);\n\tvmw_cotable_add_resource(view->cotable, &view->cotable_head);\n\tmutex_unlock(&dev_priv->binding_mutex);\n\n\treturn 0;\n}\n\n \nstatic int vmw_view_destroy(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct vmw_view *view = vmw_view(res);\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tunion vmw_view_destroy body;\n\t} *cmd;\n\n\tlockdep_assert_held_once(&dev_priv->binding_mutex);\n\tvmw_binding_res_list_scrub(&res->binding_head);\n\n\tif (!view->committed || res->id == -1)\n\t\treturn 0;\n\n\tcmd = VMW_CMD_CTX_RESERVE(dev_priv, sizeof(*cmd), view->ctx->id);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = vmw_view_destroy_cmds[view->view_type];\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.view_id = view->view_id;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\tres->id = -1;\n\tlist_del_init(&view->cotable_head);\n\tlist_del_init(&view->srf_head);\n\n\treturn 0;\n}\n\n \nstatic void vmw_hw_view_destroy(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tWARN_ON(vmw_view_destroy(res));\n\tres->id = -1;\n\tmutex_unlock(&dev_priv->binding_mutex);\n}\n\n \nstatic u32 vmw_view_key(u32 user_key, enum vmw_view_type view_type)\n{\n\treturn user_key | (view_type << 20);\n}\n\n \nstatic bool vmw_view_id_ok(u32 user_key, enum vmw_view_type view_type)\n{\n\treturn (user_key < SVGA_COTABLE_MAX_IDS &&\n\t\tview_type < vmw_view_max);\n}\n\n \nstatic void vmw_view_res_free(struct vmw_resource *res)\n{\n\tstruct vmw_view *view = vmw_view(res);\n\n\tvmw_resource_unreference(&view->cotable);\n\tvmw_resource_unreference(&view->srf);\n\tkfree_rcu(view, rcu);\n}\n\n \nint vmw_view_add(struct vmw_cmdbuf_res_manager *man,\n\t\t struct vmw_resource *ctx,\n\t\t struct vmw_resource *srf,\n\t\t enum vmw_view_type view_type,\n\t\t u32 user_key,\n\t\t const void *cmd,\n\t\t size_t cmd_size,\n\t\t struct list_head *list)\n{\n\tstatic const size_t vmw_view_define_sizes[] = {\n\t\t[vmw_view_sr] = sizeof(SVGA3dCmdDXDefineShaderResourceView),\n\t\t[vmw_view_rt] = sizeof(SVGA3dCmdDXDefineRenderTargetView),\n\t\t[vmw_view_ds] = sizeof(SVGA3dCmdDXDefineDepthStencilView),\n\t\t[vmw_view_ua] = sizeof(SVGA3dCmdDXDefineUAView)\n\t};\n\n\tstruct vmw_private *dev_priv = ctx->dev_priv;\n\tstruct vmw_resource *res;\n\tstruct vmw_view *view;\n\tsize_t size;\n\tint ret;\n\n\tif (cmd_size != vmw_view_define_sizes[view_type] +\n\t    sizeof(SVGA3dCmdHeader)) {\n\t\tVMW_DEBUG_USER(\"Illegal view create command size.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vmw_view_id_ok(user_key, view_type)) {\n\t\tVMW_DEBUG_USER(\"Illegal view add view id.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsize = offsetof(struct vmw_view, cmd) + cmd_size;\n\n\tview = kmalloc(size, GFP_KERNEL);\n\tif (!view) {\n\t\treturn -ENOMEM;\n\t}\n\n\tres = &view->res;\n\tview->ctx = ctx;\n\tview->srf = vmw_resource_reference(srf);\n\tview->cotable = vmw_resource_reference\n\t\t(vmw_context_cotable(ctx, vmw_view_cotables[view_type]));\n\tview->view_type = view_type;\n\tview->view_id = user_key;\n\tview->cmd_size = cmd_size;\n\tview->committed = false;\n\tINIT_LIST_HEAD(&view->srf_head);\n\tINIT_LIST_HEAD(&view->cotable_head);\n\tmemcpy(&view->cmd, cmd, cmd_size);\n\tret = vmw_resource_init(dev_priv, res, true,\n\t\t\t\tvmw_view_res_free, &vmw_view_func);\n\tif (ret)\n\t\tgoto out_resource_init;\n\n\tret = vmw_cmdbuf_res_add(man, vmw_cmdbuf_res_view,\n\t\t\t\t vmw_view_key(user_key, view_type),\n\t\t\t\t res, list);\n\tif (ret)\n\t\tgoto out_resource_init;\n\n\tres->id = view->view_id;\n\tres->hw_destroy = vmw_hw_view_destroy;\n\nout_resource_init:\n\tvmw_resource_unreference(&res);\n\n\treturn ret;\n}\n\n \nint vmw_view_remove(struct vmw_cmdbuf_res_manager *man,\n\t\t    u32 user_key, enum vmw_view_type view_type,\n\t\t    struct list_head *list,\n\t\t    struct vmw_resource **res_p)\n{\n\tif (!vmw_view_id_ok(user_key, view_type)) {\n\t\tVMW_DEBUG_USER(\"Illegal view remove view id.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn vmw_cmdbuf_res_remove(man, vmw_cmdbuf_res_view,\n\t\t\t\t     vmw_view_key(user_key, view_type),\n\t\t\t\t     list, res_p);\n}\n\n \nvoid vmw_view_cotable_list_destroy(struct vmw_private *dev_priv,\n\t\t\t\t   struct list_head *list,\n\t\t\t\t   bool readback)\n{\n\tstruct vmw_view *entry, *next;\n\n\tlockdep_assert_held_once(&dev_priv->binding_mutex);\n\n\tlist_for_each_entry_safe(entry, next, list, cotable_head)\n\t\tWARN_ON(vmw_view_destroy(&entry->res));\n}\n\n \nvoid vmw_view_surface_list_destroy(struct vmw_private *dev_priv,\n\t\t\t\t   struct list_head *list)\n{\n\tstruct vmw_view *entry, *next;\n\n\tlockdep_assert_held_once(&dev_priv->binding_mutex);\n\n\tlist_for_each_entry_safe(entry, next, list, srf_head)\n\t\tWARN_ON(vmw_view_destroy(&entry->res));\n}\n\n \nstruct vmw_resource *vmw_view_srf(struct vmw_resource *res)\n{\n\treturn vmw_view(res)->srf;\n}\n\n \nstruct vmw_resource *vmw_view_lookup(struct vmw_cmdbuf_res_manager *man,\n\t\t\t\t     enum vmw_view_type view_type,\n\t\t\t\t     u32 user_key)\n{\n\treturn vmw_cmdbuf_res_lookup(man, vmw_cmdbuf_res_view,\n\t\t\t\t     vmw_view_key(user_key, view_type));\n}\n\n \nu32 vmw_view_dirtying(struct vmw_resource *res)\n{\n\tstatic u32 view_is_dirtying[vmw_view_max] = {\n\t\t[vmw_view_rt] = VMW_RES_DIRTY_SET,\n\t\t[vmw_view_ds] = VMW_RES_DIRTY_SET,\n\t\t[vmw_view_ua] = VMW_RES_DIRTY_SET,\n\t};\n\n\t \n\tBUILD_BUG_ON(vmw_view_max != 4);\n\treturn view_is_dirtying[vmw_view(res)->view_type];\n}\n\nconst u32 vmw_view_destroy_cmds[] = {\n\t[vmw_view_sr] = SVGA_3D_CMD_DX_DESTROY_SHADERRESOURCE_VIEW,\n\t[vmw_view_rt] = SVGA_3D_CMD_DX_DESTROY_RENDERTARGET_VIEW,\n\t[vmw_view_ds] = SVGA_3D_CMD_DX_DESTROY_DEPTHSTENCIL_VIEW,\n\t[vmw_view_ua] = SVGA_3D_CMD_DX_DESTROY_UA_VIEW,\n};\n\nconst SVGACOTableType vmw_view_cotables[] = {\n\t[vmw_view_sr] = SVGA_COTABLE_SRVIEW,\n\t[vmw_view_rt] = SVGA_COTABLE_RTVIEW,\n\t[vmw_view_ds] = SVGA_COTABLE_DSVIEW,\n\t[vmw_view_ua] = SVGA_COTABLE_UAVIEW,\n};\n\nconst SVGACOTableType vmw_so_cotables[] = {\n\t[vmw_so_el] = SVGA_COTABLE_ELEMENTLAYOUT,\n\t[vmw_so_bs] = SVGA_COTABLE_BLENDSTATE,\n\t[vmw_so_ds] = SVGA_COTABLE_DEPTHSTENCIL,\n\t[vmw_so_rs] = SVGA_COTABLE_RASTERIZERSTATE,\n\t[vmw_so_ss] = SVGA_COTABLE_SAMPLER,\n\t[vmw_so_so] = SVGA_COTABLE_STREAMOUTPUT,\n\t[vmw_so_max]= SVGA_COTABLE_MAX\n};\n\n\n \nstatic void vmw_so_build_asserts(void) __attribute__((used));\n\n\n \nstatic void vmw_so_build_asserts(void)\n{\n\t \n\tBUILD_BUG_ON(SVGA_3D_CMD_DX_DESTROY_SHADERRESOURCE_VIEW !=\n\t\t     SVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW + 1);\n\tBUILD_BUG_ON(SVGA_3D_CMD_DX_DEFINE_RENDERTARGET_VIEW !=\n\t\t     SVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW + 2);\n\tBUILD_BUG_ON(SVGA_3D_CMD_DX_DESTROY_RENDERTARGET_VIEW !=\n\t\t     SVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW + 3);\n\tBUILD_BUG_ON(SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_VIEW !=\n\t\t     SVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW + 4);\n\tBUILD_BUG_ON(SVGA_3D_CMD_DX_DESTROY_DEPTHSTENCIL_VIEW !=\n\t\t     SVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW + 5);\n\n\t \n\tBUILD_BUG_ON(sizeof(union vmw_view_destroy) != sizeof(u32));\n\n\t \n\tBUILD_BUG_ON(SVGA_COTABLE_MAX_IDS >= ((1 << 20) - 1));\n\n\t \n\tBUILD_BUG_ON(offsetof(struct vmw_view_define, sid) !=\n\t\t     offsetof(SVGA3dCmdDXDefineShaderResourceView, sid));\n\tBUILD_BUG_ON(offsetof(struct vmw_view_define, sid) !=\n\t\t     offsetof(SVGA3dCmdDXDefineRenderTargetView, sid));\n\tBUILD_BUG_ON(offsetof(struct vmw_view_define, sid) !=\n\t\t     offsetof(SVGA3dCmdDXDefineDepthStencilView, sid));\n\tBUILD_BUG_ON(offsetof(struct vmw_view_define, sid) !=\n\t\t     offsetof(SVGA3dCmdDXDefineUAView, sid));\n\tBUILD_BUG_ON(offsetof(struct vmw_view_define, sid) !=\n\t\t     offsetof(SVGA3dCmdDXDefineDepthStencilView_v2, sid));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}