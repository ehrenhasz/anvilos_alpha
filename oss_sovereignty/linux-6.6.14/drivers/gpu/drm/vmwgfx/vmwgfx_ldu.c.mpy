{
  "module_name": "vmwgfx_ldu.c",
  "hash_id": "044b5f55e796f3ba4dd7797e3287b6954711de37f925bf501ea1bba52dac3df5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c",
  "human_readable_source": "\n \n\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_kms.h\"\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_fourcc.h>\n\n\n#define vmw_crtc_to_ldu(x) \\\n\tcontainer_of(x, struct vmw_legacy_display_unit, base.crtc)\n#define vmw_encoder_to_ldu(x) \\\n\tcontainer_of(x, struct vmw_legacy_display_unit, base.encoder)\n#define vmw_connector_to_ldu(x) \\\n\tcontainer_of(x, struct vmw_legacy_display_unit, base.connector)\n\nstruct vmw_legacy_display {\n\tstruct list_head active;\n\n\tunsigned num_active;\n\tunsigned last_num_active;\n\n\tstruct vmw_framebuffer *fb;\n};\n\n \nstruct vmw_legacy_display_unit {\n\tstruct vmw_display_unit base;\n\n\tstruct list_head active;\n};\n\nstatic void vmw_ldu_destroy(struct vmw_legacy_display_unit *ldu)\n{\n\tlist_del_init(&ldu->active);\n\tvmw_du_cleanup(&ldu->base);\n\tkfree(ldu);\n}\n\n\n \n\nstatic void vmw_ldu_crtc_destroy(struct drm_crtc *crtc)\n{\n\tvmw_ldu_destroy(vmw_crtc_to_ldu(crtc));\n}\n\nstatic int vmw_ldu_commit_list(struct vmw_private *dev_priv)\n{\n\tstruct vmw_legacy_display *lds = dev_priv->ldu_priv;\n\tstruct vmw_legacy_display_unit *entry;\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_crtc *crtc = NULL;\n\tint i;\n\n\t \n\tif (!(dev_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY)) {\n\t\tint w = 0, h = 0;\n\t\tlist_for_each_entry(entry, &lds->active, active) {\n\t\t\tcrtc = &entry->base.crtc;\n\t\t\tw = max(w, crtc->x + crtc->mode.hdisplay);\n\t\t\th = max(h, crtc->y + crtc->mode.vdisplay);\n\t\t}\n\n\t\tif (crtc == NULL)\n\t\t\treturn 0;\n\t\tfb = crtc->primary->state->fb;\n\n\t\treturn vmw_kms_write_svga(dev_priv, w, h, fb->pitches[0],\n\t\t\t\t\t  fb->format->cpp[0] * 8,\n\t\t\t\t\t  fb->format->depth);\n\t}\n\n\tif (!list_empty(&lds->active)) {\n\t\tentry = list_entry(lds->active.next, typeof(*entry), active);\n\t\tfb = entry->base.crtc.primary->state->fb;\n\n\t\tvmw_kms_write_svga(dev_priv, fb->width, fb->height, fb->pitches[0],\n\t\t\t\t   fb->format->cpp[0] * 8, fb->format->depth);\n\t}\n\n\t \n\tvmw_write(dev_priv, SVGA_REG_NUM_GUEST_DISPLAYS,\n\t\t  lds->num_active ? lds->num_active : 1);\n\n\ti = 0;\n\tlist_for_each_entry(entry, &lds->active, active) {\n\t\tcrtc = &entry->base.crtc;\n\n\t\tvmw_write(dev_priv, SVGA_REG_DISPLAY_ID, i);\n\t\tvmw_write(dev_priv, SVGA_REG_DISPLAY_IS_PRIMARY, !i);\n\t\tvmw_write(dev_priv, SVGA_REG_DISPLAY_POSITION_X, crtc->x);\n\t\tvmw_write(dev_priv, SVGA_REG_DISPLAY_POSITION_Y, crtc->y);\n\t\tvmw_write(dev_priv, SVGA_REG_DISPLAY_WIDTH, crtc->mode.hdisplay);\n\t\tvmw_write(dev_priv, SVGA_REG_DISPLAY_HEIGHT, crtc->mode.vdisplay);\n\n\t\ti++;\n\t}\n\n\tBUG_ON(i != lds->num_active);\n\n\tlds->last_num_active = lds->num_active;\n\n\treturn 0;\n}\n\n \nstatic int vmw_ldu_fb_pin(struct vmw_framebuffer *vfb)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(vfb->base.dev);\n\tstruct vmw_bo *buf;\n\tint ret;\n\n\tbuf = vfb->bo ?  vmw_framebuffer_to_vfbd(&vfb->base)->buffer :\n\t\tvmw_framebuffer_to_vfbs(&vfb->base)->surface->res.guest_memory_bo;\n\n\tif (!buf)\n\t\treturn 0;\n\tWARN_ON(dev_priv->active_display_unit != vmw_du_legacy);\n\n\tif (dev_priv->active_display_unit == vmw_du_legacy) {\n\t\tvmw_overlay_pause_all(dev_priv);\n\t\tret = vmw_bo_pin_in_start_of_vram(dev_priv, buf, false);\n\t\tvmw_overlay_resume_all(dev_priv);\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int vmw_ldu_fb_unpin(struct vmw_framebuffer *vfb)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(vfb->base.dev);\n\tstruct vmw_bo *buf;\n\n\tbuf = vfb->bo ?  vmw_framebuffer_to_vfbd(&vfb->base)->buffer :\n\t\tvmw_framebuffer_to_vfbs(&vfb->base)->surface->res.guest_memory_bo;\n\n\tif (WARN_ON(!buf))\n\t\treturn 0;\n\n\treturn vmw_bo_unpin(dev_priv, buf, false);\n}\n\nstatic int vmw_ldu_del_active(struct vmw_private *vmw_priv,\n\t\t\t      struct vmw_legacy_display_unit *ldu)\n{\n\tstruct vmw_legacy_display *ld = vmw_priv->ldu_priv;\n\tif (list_empty(&ldu->active))\n\t\treturn 0;\n\n\t \n\tlist_del_init(&ldu->active);\n\tif (--(ld->num_active) == 0) {\n\t\tBUG_ON(!ld->fb);\n\t\tWARN_ON(vmw_ldu_fb_unpin(ld->fb));\n\t\tld->fb = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vmw_ldu_add_active(struct vmw_private *vmw_priv,\n\t\t\t      struct vmw_legacy_display_unit *ldu,\n\t\t\t      struct vmw_framebuffer *vfb)\n{\n\tstruct vmw_legacy_display *ld = vmw_priv->ldu_priv;\n\tstruct vmw_legacy_display_unit *entry;\n\tstruct list_head *at;\n\n\tBUG_ON(!ld->num_active && ld->fb);\n\tif (vfb != ld->fb) {\n\t\tif (ld->fb)\n\t\t\tWARN_ON(vmw_ldu_fb_unpin(ld->fb));\n\t\tvmw_svga_enable(vmw_priv);\n\t\tWARN_ON(vmw_ldu_fb_pin(vfb));\n\t\tld->fb = vfb;\n\t}\n\n\tif (!list_empty(&ldu->active))\n\t\treturn 0;\n\n\tat = &ld->active;\n\tlist_for_each_entry(entry, &ld->active, active) {\n\t\tif (entry->base.unit > ldu->base.unit)\n\t\t\tbreak;\n\n\t\tat = &entry->active;\n\t}\n\n\tlist_add(&ldu->active, at);\n\n\tld->num_active++;\n\n\treturn 0;\n}\n\n \nstatic void vmw_ldu_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n}\n\n \nstatic void vmw_ldu_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n}\n\n \nstatic void vmw_ldu_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n}\n\nstatic const struct drm_crtc_funcs vmw_legacy_crtc_funcs = {\n\t.gamma_set = vmw_du_crtc_gamma_set,\n\t.destroy = vmw_ldu_crtc_destroy,\n\t.reset = vmw_du_crtc_reset,\n\t.atomic_duplicate_state = vmw_du_crtc_duplicate_state,\n\t.atomic_destroy_state = vmw_du_crtc_destroy_state,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n};\n\n\n \n\nstatic void vmw_ldu_encoder_destroy(struct drm_encoder *encoder)\n{\n\tvmw_ldu_destroy(vmw_encoder_to_ldu(encoder));\n}\n\nstatic const struct drm_encoder_funcs vmw_legacy_encoder_funcs = {\n\t.destroy = vmw_ldu_encoder_destroy,\n};\n\n \n\nstatic void vmw_ldu_connector_destroy(struct drm_connector *connector)\n{\n\tvmw_ldu_destroy(vmw_connector_to_ldu(connector));\n}\n\nstatic const struct drm_connector_funcs vmw_legacy_connector_funcs = {\n\t.dpms = vmw_du_connector_dpms,\n\t.detect = vmw_du_connector_detect,\n\t.fill_modes = vmw_du_connector_fill_modes,\n\t.destroy = vmw_ldu_connector_destroy,\n\t.reset = vmw_du_connector_reset,\n\t.atomic_duplicate_state = vmw_du_connector_duplicate_state,\n\t.atomic_destroy_state = vmw_du_connector_destroy_state,\n};\n\nstatic const struct\ndrm_connector_helper_funcs vmw_ldu_connector_helper_funcs = {\n};\n\nstatic int vmw_kms_ldu_do_bo_dirty(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_framebuffer *framebuffer,\n\t\t\t\t   unsigned int flags, unsigned int color,\n\t\t\t\t   struct drm_mode_rect *clips,\n\t\t\t\t   unsigned int num_clips);\n\n \n\nstatic void\nvmw_ldu_primary_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct vmw_private *dev_priv;\n\tstruct vmw_legacy_display_unit *ldu;\n\tstruct vmw_framebuffer *vfb;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_crtc *crtc = new_state->crtc ?: old_state->crtc;\n\n\tldu = vmw_crtc_to_ldu(crtc);\n\tdev_priv = vmw_priv(plane->dev);\n\tfb       = new_state->fb;\n\n\tvfb = (fb) ? vmw_framebuffer_to_vfb(fb) : NULL;\n\n\tif (vfb)\n\t\tvmw_ldu_add_active(dev_priv, ldu, vfb);\n\telse\n\t\tvmw_ldu_del_active(dev_priv, ldu);\n\n\tvmw_ldu_commit_list(dev_priv);\n\n\tif (vfb && vmw_cmd_supported(dev_priv)) {\n\t\tstruct drm_mode_rect fb_rect = {\n\t\t\t.x1 = 0,\n\t\t\t.y1 = 0,\n\t\t\t.x2 = vfb->base.width,\n\t\t\t.y2 = vfb->base.height\n\t\t};\n\t\tstruct drm_mode_rect *damage_rects = drm_plane_get_damage_clips(new_state);\n\t\tu32 rect_count = drm_plane_get_damage_clips_count(new_state);\n\t\tint ret;\n\n\t\tif (!damage_rects) {\n\t\t\tdamage_rects = &fb_rect;\n\t\t\trect_count = 1;\n\t\t}\n\n\t\tret = vmw_kms_ldu_do_bo_dirty(dev_priv, vfb, 0, 0, damage_rects, rect_count);\n\n\t\tdrm_WARN_ONCE(plane->dev, ret,\n\t\t\t\"vmw_kms_ldu_do_bo_dirty failed with: ret=%d\\n\", ret);\n\n\t\tvmw_cmd_flush(dev_priv, false);\n\t}\n}\n\nstatic const struct drm_plane_funcs vmw_ldu_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = vmw_du_primary_plane_destroy,\n\t.reset = vmw_du_plane_reset,\n\t.atomic_duplicate_state = vmw_du_plane_duplicate_state,\n\t.atomic_destroy_state = vmw_du_plane_destroy_state,\n};\n\nstatic const struct drm_plane_funcs vmw_ldu_cursor_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = vmw_du_cursor_plane_destroy,\n\t.reset = vmw_du_plane_reset,\n\t.atomic_duplicate_state = vmw_du_plane_duplicate_state,\n\t.atomic_destroy_state = vmw_du_plane_destroy_state,\n};\n\n \nstatic const struct\ndrm_plane_helper_funcs vmw_ldu_cursor_plane_helper_funcs = {\n\t.atomic_check = vmw_du_cursor_plane_atomic_check,\n\t.atomic_update = vmw_du_cursor_plane_atomic_update,\n\t.prepare_fb = vmw_du_cursor_plane_prepare_fb,\n\t.cleanup_fb = vmw_du_cursor_plane_cleanup_fb,\n};\n\nstatic const struct\ndrm_plane_helper_funcs vmw_ldu_primary_plane_helper_funcs = {\n\t.atomic_check = vmw_du_primary_plane_atomic_check,\n\t.atomic_update = vmw_ldu_primary_plane_atomic_update,\n};\n\nstatic const struct drm_crtc_helper_funcs vmw_ldu_crtc_helper_funcs = {\n\t.mode_set_nofb = vmw_ldu_crtc_mode_set_nofb,\n\t.atomic_check = vmw_du_crtc_atomic_check,\n\t.atomic_begin = vmw_du_crtc_atomic_begin,\n\t.atomic_flush = vmw_du_crtc_atomic_flush,\n\t.atomic_enable = vmw_ldu_crtc_atomic_enable,\n\t.atomic_disable = vmw_ldu_crtc_atomic_disable,\n};\n\n\nstatic int vmw_ldu_init(struct vmw_private *dev_priv, unsigned unit)\n{\n\tstruct vmw_legacy_display_unit *ldu;\n\tstruct drm_device *dev = &dev_priv->drm;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct drm_plane *primary;\n\tstruct vmw_cursor_plane *cursor;\n\tstruct drm_crtc *crtc;\n\tint ret;\n\n\tldu = kzalloc(sizeof(*ldu), GFP_KERNEL);\n\tif (!ldu)\n\t\treturn -ENOMEM;\n\n\tldu->base.unit = unit;\n\tcrtc = &ldu->base.crtc;\n\tencoder = &ldu->base.encoder;\n\tconnector = &ldu->base.connector;\n\tprimary = &ldu->base.primary;\n\tcursor = &ldu->base.cursor;\n\n\tINIT_LIST_HEAD(&ldu->active);\n\n\tldu->base.pref_active = (unit == 0);\n\tldu->base.pref_width = dev_priv->initial_width;\n\tldu->base.pref_height = dev_priv->initial_height;\n\tldu->base.pref_mode = NULL;\n\n\t \n\tldu->base.is_implicit = true;\n\n\t \n\tret = drm_universal_plane_init(dev, primary,\n\t\t\t\t       0, &vmw_ldu_plane_funcs,\n\t\t\t\t       vmw_primary_plane_formats,\n\t\t\t\t       ARRAY_SIZE(vmw_primary_plane_formats),\n\t\t\t\t       NULL, DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize primary plane\");\n\t\tgoto err_free;\n\t}\n\n\tdrm_plane_helper_add(primary, &vmw_ldu_primary_plane_helper_funcs);\n\n\t \n\tif (vmw_cmd_supported(dev_priv)) {\n\t\t \n\t\tret = drm_universal_plane_init(dev, &cursor->base,\n\t\t\t\t\t       0, &vmw_ldu_cursor_funcs,\n\t\t\t\t\t       vmw_cursor_plane_formats,\n\t\t\t\t\t       ARRAY_SIZE(vmw_cursor_plane_formats),\n\t\t\t\t\t       NULL, DRM_PLANE_TYPE_CURSOR, NULL);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to initialize cursor plane\");\n\t\t\tdrm_plane_cleanup(&ldu->base.primary);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tdrm_plane_helper_add(&cursor->base, &vmw_ldu_cursor_plane_helper_funcs);\n\t}\n\n\tret = drm_connector_init(dev, connector, &vmw_legacy_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_VIRTUAL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize connector\\n\");\n\t\tgoto err_free;\n\t}\n\n\tdrm_connector_helper_add(connector, &vmw_ldu_connector_helper_funcs);\n\tconnector->status = vmw_du_connector_detect(connector, true);\n\n\tret = drm_encoder_init(dev, encoder, &vmw_legacy_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_VIRTUAL, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize encoder\\n\");\n\t\tgoto err_free_connector;\n\t}\n\n\t(void) drm_connector_attach_encoder(connector, encoder);\n\tencoder->possible_crtcs = (1 << unit);\n\tencoder->possible_clones = 0;\n\n\tret = drm_connector_register(connector);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to register connector\\n\");\n\t\tgoto err_free_encoder;\n\t}\n\n\tret = drm_crtc_init_with_planes(dev, crtc, primary,\n\t\t      vmw_cmd_supported(dev_priv) ? &cursor->base : NULL,\n\t\t      &vmw_legacy_crtc_funcs, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize CRTC\\n\");\n\t\tgoto err_free_unregister;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &vmw_ldu_crtc_helper_funcs);\n\n\tdrm_mode_crtc_set_gamma_size(crtc, 256);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev_priv->hotplug_mode_update_property, 1);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.suggested_x_property, 0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.suggested_y_property, 0);\n\tif (dev_priv->implicit_placement_property)\n\t\tdrm_object_attach_property\n\t\t\t(&connector->base,\n\t\t\t dev_priv->implicit_placement_property,\n\t\t\t 1);\n\n\treturn 0;\n\nerr_free_unregister:\n\tdrm_connector_unregister(connector);\nerr_free_encoder:\n\tdrm_encoder_cleanup(encoder);\nerr_free_connector:\n\tdrm_connector_cleanup(connector);\nerr_free:\n\tkfree(ldu);\n\treturn ret;\n}\n\nint vmw_kms_ldu_init_display(struct vmw_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->drm;\n\tint i, ret;\n\tint num_display_units = (dev_priv->capabilities & SVGA_CAP_MULTIMON) ?\n\t\t\t\t\tVMWGFX_NUM_DISPLAY_UNITS : 1;\n\n\tif (unlikely(dev_priv->ldu_priv)) {\n\t\treturn -EINVAL;\n\t}\n\n\tdev_priv->ldu_priv = kmalloc(sizeof(*dev_priv->ldu_priv), GFP_KERNEL);\n\tif (!dev_priv->ldu_priv)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dev_priv->ldu_priv->active);\n\tdev_priv->ldu_priv->num_active = 0;\n\tdev_priv->ldu_priv->last_num_active = 0;\n\tdev_priv->ldu_priv->fb = NULL;\n\n\tvmw_kms_create_implicit_placement_property(dev_priv);\n\n\tfor (i = 0; i < num_display_units; ++i) {\n\t\tret = vmw_ldu_init(dev_priv, i);\n\t\tif (ret != 0)\n\t\t\tgoto err_free;\n\t}\n\n\tdev_priv->active_display_unit = vmw_du_legacy;\n\n\tdrm_mode_config_reset(dev);\n\n\treturn 0;\n\nerr_free:\n\tkfree(dev_priv->ldu_priv);\n\tdev_priv->ldu_priv = NULL;\n\treturn ret;\n}\n\nint vmw_kms_ldu_close_display(struct vmw_private *dev_priv)\n{\n\tif (!dev_priv->ldu_priv)\n\t\treturn -ENOSYS;\n\n\tBUG_ON(!list_empty(&dev_priv->ldu_priv->active));\n\n\tkfree(dev_priv->ldu_priv);\n\n\treturn 0;\n}\n\n\nstatic int vmw_kms_ldu_do_bo_dirty(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_framebuffer *framebuffer,\n\t\t\t\t   unsigned int flags, unsigned int color,\n\t\t\t\t   struct drm_mode_rect *clips,\n\t\t\t\t   unsigned int num_clips)\n{\n\tsize_t fifo_size;\n\tint i;\n\n\tstruct {\n\t\tuint32_t header;\n\t\tSVGAFifoCmdUpdate body;\n\t} *cmd;\n\n\tfifo_size = sizeof(*cmd) * num_clips;\n\tcmd = VMW_CMD_RESERVE(dev_priv, fifo_size);\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tmemset(cmd, 0, fifo_size);\n\tfor (i = 0; i < num_clips; i++, clips++) {\n\t\tcmd[i].header = SVGA_CMD_UPDATE;\n\t\tcmd[i].body.x = clips->x1;\n\t\tcmd[i].body.y = clips->y1;\n\t\tcmd[i].body.width = clips->x2 - clips->x1;\n\t\tcmd[i].body.height = clips->y2 - clips->y1;\n\t}\n\n\tvmw_cmd_commit(dev_priv, fifo_size);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}