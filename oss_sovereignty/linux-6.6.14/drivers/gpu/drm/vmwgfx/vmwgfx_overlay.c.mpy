{
  "module_name": "vmwgfx_overlay.c",
  "hash_id": "433a2d1d0fc303588c9744a75fb412c017260bafb24e3db6517a0d3305591f69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c",
  "human_readable_source": "\n \n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_drv.h\"\n\n#include \"device_include/svga_overlay.h\"\n#include \"device_include/svga_escape.h\"\n\n#include <drm/ttm/ttm_placement.h>\n\n#define VMW_MAX_NUM_STREAMS 1\n#define VMW_OVERLAY_CAP_MASK (SVGA_FIFO_CAP_VIDEO | SVGA_FIFO_CAP_ESCAPE)\n\nstruct vmw_stream {\n\tstruct vmw_bo *buf;\n\tbool claimed;\n\tbool paused;\n\tstruct drm_vmw_control_stream_arg saved;\n};\n\n \nstruct vmw_overlay {\n\t \n\tstruct mutex mutex;\n\tstruct vmw_stream stream[VMW_MAX_NUM_STREAMS];\n};\n\nstruct vmw_escape_header {\n\tuint32_t cmd;\n\tSVGAFifoCmdEscape body;\n};\n\nstruct vmw_escape_video_flush {\n\tstruct vmw_escape_header escape;\n\tSVGAEscapeVideoFlush flush;\n};\n\nstatic inline void fill_escape(struct vmw_escape_header *header,\n\t\t\t       uint32_t size)\n{\n\theader->cmd = SVGA_CMD_ESCAPE;\n\theader->body.nsid = SVGA_ESCAPE_NSID_VMWARE;\n\theader->body.size = size;\n}\n\nstatic inline void fill_flush(struct vmw_escape_video_flush *cmd,\n\t\t\t      uint32_t stream_id)\n{\n\tfill_escape(&cmd->escape, sizeof(cmd->flush));\n\tcmd->flush.cmdType = SVGA_ESCAPE_VMWARE_VIDEO_FLUSH;\n\tcmd->flush.streamId = stream_id;\n}\n\n \nstatic int vmw_overlay_send_put(struct vmw_private *dev_priv,\n\t\t\t\tstruct vmw_bo *buf,\n\t\t\t\tstruct drm_vmw_control_stream_arg *arg,\n\t\t\t\tbool interruptible)\n{\n\tstruct vmw_escape_video_flush *flush;\n\tsize_t fifo_size;\n\tbool have_so = (dev_priv->active_display_unit == vmw_du_screen_object);\n\tint i, num_items;\n\tSVGAGuestPtr ptr;\n\n\tstruct {\n\t\tstruct vmw_escape_header escape;\n\t\tstruct {\n\t\t\tuint32_t cmdType;\n\t\t\tuint32_t streamId;\n\t\t} header;\n\t} *cmds;\n\tstruct {\n\t\tuint32_t registerId;\n\t\tuint32_t value;\n\t} *items;\n\n\t \n\tif (have_so)\n\t\tnum_items = SVGA_VIDEO_DST_SCREEN_ID + 1;\n\telse\n\t\tnum_items = SVGA_VIDEO_PITCH_3 + 1;\n\n\tfifo_size = sizeof(*cmds) + sizeof(*flush) + sizeof(*items) * num_items;\n\n\tcmds = VMW_CMD_RESERVE(dev_priv, fifo_size);\n\t \n\tif (!cmds)\n\t\treturn -ENOMEM;\n\n\titems = (typeof(items))&cmds[1];\n\tflush = (struct vmw_escape_video_flush *)&items[num_items];\n\n\t \n\tfill_escape(&cmds->escape, sizeof(*items) * (num_items + 1));\n\n\tcmds->header.cmdType = SVGA_ESCAPE_VMWARE_VIDEO_SET_REGS;\n\tcmds->header.streamId = arg->stream_id;\n\n\t \n\tfor (i = 0; i < num_items; i++)\n\t\titems[i].registerId = i;\n\n\tvmw_bo_get_guest_ptr(&buf->tbo, &ptr);\n\tptr.offset += arg->offset;\n\n\titems[SVGA_VIDEO_ENABLED].value     = true;\n\titems[SVGA_VIDEO_FLAGS].value       = arg->flags;\n\titems[SVGA_VIDEO_DATA_OFFSET].value = ptr.offset;\n\titems[SVGA_VIDEO_FORMAT].value      = arg->format;\n\titems[SVGA_VIDEO_COLORKEY].value    = arg->color_key;\n\titems[SVGA_VIDEO_SIZE].value        = arg->size;\n\titems[SVGA_VIDEO_WIDTH].value       = arg->width;\n\titems[SVGA_VIDEO_HEIGHT].value      = arg->height;\n\titems[SVGA_VIDEO_SRC_X].value       = arg->src.x;\n\titems[SVGA_VIDEO_SRC_Y].value       = arg->src.y;\n\titems[SVGA_VIDEO_SRC_WIDTH].value   = arg->src.w;\n\titems[SVGA_VIDEO_SRC_HEIGHT].value  = arg->src.h;\n\titems[SVGA_VIDEO_DST_X].value       = arg->dst.x;\n\titems[SVGA_VIDEO_DST_Y].value       = arg->dst.y;\n\titems[SVGA_VIDEO_DST_WIDTH].value   = arg->dst.w;\n\titems[SVGA_VIDEO_DST_HEIGHT].value  = arg->dst.h;\n\titems[SVGA_VIDEO_PITCH_1].value     = arg->pitch[0];\n\titems[SVGA_VIDEO_PITCH_2].value     = arg->pitch[1];\n\titems[SVGA_VIDEO_PITCH_3].value     = arg->pitch[2];\n\tif (have_so) {\n\t\titems[SVGA_VIDEO_DATA_GMRID].value    = ptr.gmrId;\n\t\titems[SVGA_VIDEO_DST_SCREEN_ID].value = SVGA_ID_INVALID;\n\t}\n\n\tfill_flush(flush, arg->stream_id);\n\n\tvmw_cmd_commit(dev_priv, fifo_size);\n\n\treturn 0;\n}\n\n \nstatic int vmw_overlay_send_stop(struct vmw_private *dev_priv,\n\t\t\t\t uint32_t stream_id,\n\t\t\t\t bool interruptible)\n{\n\tstruct {\n\t\tstruct vmw_escape_header escape;\n\t\tSVGAEscapeVideoSetRegs body;\n\t\tstruct vmw_escape_video_flush flush;\n\t} *cmds;\n\tint ret;\n\n\tfor (;;) {\n\t\tcmds = VMW_CMD_RESERVE(dev_priv, sizeof(*cmds));\n\t\tif (cmds)\n\t\t\tbreak;\n\n\t\tret = vmw_fallback_wait(dev_priv, false, true, 0,\n\t\t\t\t\tinterruptible, 3*HZ);\n\t\tif (interruptible && ret == -ERESTARTSYS)\n\t\t\treturn ret;\n\t\telse\n\t\t\tBUG_ON(ret != 0);\n\t}\n\n\tfill_escape(&cmds->escape, sizeof(cmds->body));\n\tcmds->body.header.cmdType = SVGA_ESCAPE_VMWARE_VIDEO_SET_REGS;\n\tcmds->body.header.streamId = stream_id;\n\tcmds->body.items[0].registerId = SVGA_VIDEO_ENABLED;\n\tcmds->body.items[0].value = false;\n\tfill_flush(&cmds->flush, stream_id);\n\n\tvmw_cmd_commit(dev_priv, sizeof(*cmds));\n\n\treturn 0;\n}\n\n \nstatic int vmw_overlay_move_buffer(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_bo *buf,\n\t\t\t\t   bool pin, bool inter)\n{\n\tif (!pin)\n\t\treturn vmw_bo_unpin(dev_priv, buf, inter);\n\n\tif (dev_priv->active_display_unit == vmw_du_legacy)\n\t\treturn vmw_bo_pin_in_vram(dev_priv, buf, inter);\n\n\treturn vmw_bo_pin_in_vram_or_gmr(dev_priv, buf, inter);\n}\n\n \nstatic int vmw_overlay_stop(struct vmw_private *dev_priv,\n\t\t\t    uint32_t stream_id, bool pause,\n\t\t\t    bool interruptible)\n{\n\tstruct vmw_overlay *overlay = dev_priv->overlay_priv;\n\tstruct vmw_stream *stream = &overlay->stream[stream_id];\n\tint ret;\n\n\t \n\tif (!stream->buf)\n\t\treturn 0;\n\n\t \n\tif (!stream->paused) {\n\t\tret = vmw_overlay_send_stop(dev_priv, stream_id,\n\t\t\t\t\t    interruptible);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = vmw_overlay_move_buffer(dev_priv, stream->buf, false,\n\t\t\t\t\t      interruptible);\n\t\tif (interruptible && ret == -ERESTARTSYS)\n\t\t\treturn ret;\n\t\telse\n\t\t\tBUG_ON(ret != 0);\n\t}\n\n\tif (!pause) {\n\t\tvmw_bo_unreference(&stream->buf);\n\t\tstream->paused = false;\n\t} else {\n\t\tstream->paused = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vmw_overlay_update_stream(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_bo *buf,\n\t\t\t\t     struct drm_vmw_control_stream_arg *arg,\n\t\t\t\t     bool interruptible)\n{\n\tstruct vmw_overlay *overlay = dev_priv->overlay_priv;\n\tstruct vmw_stream *stream = &overlay->stream[arg->stream_id];\n\tint ret = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tDRM_DEBUG(\"   %s: old %p, new %p, %spaused\\n\", __func__,\n\t\t  stream->buf, buf, stream->paused ? \"\" : \"not \");\n\n\tif (stream->buf != buf) {\n\t\tret = vmw_overlay_stop(dev_priv, arg->stream_id,\n\t\t\t\t       false, interruptible);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (!stream->paused) {\n\t\t \n\t\tret = vmw_overlay_send_put(dev_priv, buf, arg, interruptible);\n\t\tif (ret == 0)\n\t\t\tstream->saved = *arg;\n\t\telse\n\t\t\tBUG_ON(!interruptible);\n\n\t\treturn ret;\n\t}\n\n\t \n\tret = vmw_overlay_move_buffer(dev_priv, buf, true, interruptible);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vmw_overlay_send_put(dev_priv, buf, arg, interruptible);\n\tif (ret) {\n\t\t \n\t\tBUG_ON(vmw_overlay_move_buffer(dev_priv, buf, false, false)\n\t\t       != 0);\n\t\treturn ret;\n\t}\n\n\tif (stream->buf != buf)\n\t\tstream->buf = vmw_bo_reference(buf);\n\tstream->saved = *arg;\n\t \n\tstream->paused = false;\n\n\treturn 0;\n}\n\n \nint vmw_overlay_resume_all(struct vmw_private *dev_priv)\n{\n\tstruct vmw_overlay *overlay = dev_priv->overlay_priv;\n\tint i, ret;\n\n\tif (!overlay)\n\t\treturn 0;\n\n\tmutex_lock(&overlay->mutex);\n\n\tfor (i = 0; i < VMW_MAX_NUM_STREAMS; i++) {\n\t\tstruct vmw_stream *stream = &overlay->stream[i];\n\t\tif (!stream->paused)\n\t\t\tcontinue;\n\n\t\tret = vmw_overlay_update_stream(dev_priv, stream->buf,\n\t\t\t\t\t\t&stream->saved, false);\n\t\tif (ret != 0)\n\t\t\tDRM_INFO(\"%s: *warning* failed to resume stream %i\\n\",\n\t\t\t\t __func__, i);\n\t}\n\n\tmutex_unlock(&overlay->mutex);\n\n\treturn 0;\n}\n\n \nint vmw_overlay_pause_all(struct vmw_private *dev_priv)\n{\n\tstruct vmw_overlay *overlay = dev_priv->overlay_priv;\n\tint i, ret;\n\n\tif (!overlay)\n\t\treturn 0;\n\n\tmutex_lock(&overlay->mutex);\n\n\tfor (i = 0; i < VMW_MAX_NUM_STREAMS; i++) {\n\t\tif (overlay->stream[i].paused)\n\t\t\tDRM_INFO(\"%s: *warning* stream %i already paused\\n\",\n\t\t\t\t __func__, i);\n\t\tret = vmw_overlay_stop(dev_priv, i, true, false);\n\t\tWARN_ON(ret != 0);\n\t}\n\n\tmutex_unlock(&overlay->mutex);\n\n\treturn 0;\n}\n\n\nstatic bool vmw_overlay_available(const struct vmw_private *dev_priv)\n{\n\treturn (dev_priv->overlay_priv != NULL &&\n\t\t((vmw_fifo_caps(dev_priv) & VMW_OVERLAY_CAP_MASK) ==\n\t\t VMW_OVERLAY_CAP_MASK));\n}\n\nint vmw_overlay_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct vmw_overlay *overlay = dev_priv->overlay_priv;\n\tstruct drm_vmw_control_stream_arg *arg =\n\t    (struct drm_vmw_control_stream_arg *)data;\n\tstruct vmw_bo *buf;\n\tstruct vmw_resource *res;\n\tint ret;\n\n\tif (!vmw_overlay_available(dev_priv))\n\t\treturn -ENOSYS;\n\n\tret = vmw_user_stream_lookup(dev_priv, tfile, &arg->stream_id, &res);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&overlay->mutex);\n\n\tif (!arg->enabled) {\n\t\tret = vmw_overlay_stop(dev_priv, arg->stream_id, false, true);\n\t\tgoto out_unlock;\n\t}\n\n\tret = vmw_user_bo_lookup(file_priv, arg->handle, &buf);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = vmw_overlay_update_stream(dev_priv, buf, arg, true);\n\n\tvmw_user_bo_unref(&buf);\n\nout_unlock:\n\tmutex_unlock(&overlay->mutex);\n\tvmw_resource_unreference(&res);\n\n\treturn ret;\n}\n\nint vmw_overlay_num_overlays(struct vmw_private *dev_priv)\n{\n\tif (!vmw_overlay_available(dev_priv))\n\t\treturn 0;\n\n\treturn VMW_MAX_NUM_STREAMS;\n}\n\nint vmw_overlay_num_free_overlays(struct vmw_private *dev_priv)\n{\n\tstruct vmw_overlay *overlay = dev_priv->overlay_priv;\n\tint i, k;\n\n\tif (!vmw_overlay_available(dev_priv))\n\t\treturn 0;\n\n\tmutex_lock(&overlay->mutex);\n\n\tfor (i = 0, k = 0; i < VMW_MAX_NUM_STREAMS; i++)\n\t\tif (!overlay->stream[i].claimed)\n\t\t\tk++;\n\n\tmutex_unlock(&overlay->mutex);\n\n\treturn k;\n}\n\nint vmw_overlay_claim(struct vmw_private *dev_priv, uint32_t *out)\n{\n\tstruct vmw_overlay *overlay = dev_priv->overlay_priv;\n\tint i;\n\n\tif (!overlay)\n\t\treturn -ENOSYS;\n\n\tmutex_lock(&overlay->mutex);\n\n\tfor (i = 0; i < VMW_MAX_NUM_STREAMS; i++) {\n\n\t\tif (overlay->stream[i].claimed)\n\t\t\tcontinue;\n\n\t\toverlay->stream[i].claimed = true;\n\t\t*out = i;\n\t\tmutex_unlock(&overlay->mutex);\n\t\treturn 0;\n\t}\n\n\tmutex_unlock(&overlay->mutex);\n\treturn -ESRCH;\n}\n\nint vmw_overlay_unref(struct vmw_private *dev_priv, uint32_t stream_id)\n{\n\tstruct vmw_overlay *overlay = dev_priv->overlay_priv;\n\n\tBUG_ON(stream_id >= VMW_MAX_NUM_STREAMS);\n\n\tif (!overlay)\n\t\treturn -ENOSYS;\n\n\tmutex_lock(&overlay->mutex);\n\n\tWARN_ON(!overlay->stream[stream_id].claimed);\n\tvmw_overlay_stop(dev_priv, stream_id, false, false);\n\toverlay->stream[stream_id].claimed = false;\n\n\tmutex_unlock(&overlay->mutex);\n\treturn 0;\n}\n\nint vmw_overlay_init(struct vmw_private *dev_priv)\n{\n\tstruct vmw_overlay *overlay;\n\tint i;\n\n\tif (dev_priv->overlay_priv)\n\t\treturn -EINVAL;\n\n\toverlay = kzalloc(sizeof(*overlay), GFP_KERNEL);\n\tif (!overlay)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&overlay->mutex);\n\tfor (i = 0; i < VMW_MAX_NUM_STREAMS; i++) {\n\t\toverlay->stream[i].buf = NULL;\n\t\toverlay->stream[i].paused = false;\n\t\toverlay->stream[i].claimed = false;\n\t}\n\n\tdev_priv->overlay_priv = overlay;\n\n\treturn 0;\n}\n\nint vmw_overlay_close(struct vmw_private *dev_priv)\n{\n\tstruct vmw_overlay *overlay = dev_priv->overlay_priv;\n\tbool forgotten_buffer = false;\n\tint i;\n\n\tif (!overlay)\n\t\treturn -ENOSYS;\n\n\tfor (i = 0; i < VMW_MAX_NUM_STREAMS; i++) {\n\t\tif (overlay->stream[i].buf) {\n\t\t\tforgotten_buffer = true;\n\t\t\tvmw_overlay_stop(dev_priv, i, false, false);\n\t\t}\n\t}\n\n\tWARN_ON(forgotten_buffer);\n\n\tdev_priv->overlay_priv = NULL;\n\tkfree(overlay);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}