{
  "module_name": "vmwgfx_bo.h",
  "hash_id": "555011afc1f0bc2c232a21ace54d236a8d2287cd562082bb9be22d1aee1de5ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_bo.h",
  "human_readable_source": " \n \n\n#ifndef VMWGFX_BO_H\n#define VMWGFX_BO_H\n\n#include \"device_include/svga_reg.h\"\n\n#include <drm/ttm/ttm_bo.h>\n#include <drm/ttm/ttm_placement.h>\n\n#include <linux/rbtree_types.h>\n#include <linux/types.h>\n\nstruct vmw_bo_dirty;\nstruct vmw_fence_obj;\nstruct vmw_private;\nstruct vmw_resource;\n\nenum vmw_bo_domain {\n\tVMW_BO_DOMAIN_SYS           = BIT(0),\n\tVMW_BO_DOMAIN_WAITABLE_SYS  = BIT(1),\n\tVMW_BO_DOMAIN_VRAM          = BIT(2),\n\tVMW_BO_DOMAIN_GMR           = BIT(3),\n\tVMW_BO_DOMAIN_MOB           = BIT(4),\n};\n\nstruct vmw_bo_params {\n\tu32 domain;\n\tu32 busy_domain;\n\tenum ttm_bo_type bo_type;\n\tsize_t size;\n\tbool pin;\n};\n\n \nstruct vmw_bo {\n\tstruct ttm_buffer_object tbo;\n\n\tstruct ttm_placement placement;\n\tstruct ttm_place places[5];\n\tstruct ttm_place busy_places[5];\n\n\t \n\tstruct ttm_bo_kmap_obj map;\n\n\tstruct rb_root res_tree;\n\tu32 res_prios[TTM_MAX_BO_PRIORITY];\n\n\tatomic_t cpu_writers;\n\t \n\tstruct vmw_resource *dx_query_ctx;\n\tstruct vmw_bo_dirty *dirty;\n};\n\nvoid vmw_bo_placement_set(struct vmw_bo *bo, u32 domain, u32 busy_domain);\nvoid vmw_bo_placement_set_default_accelerated(struct vmw_bo *bo);\n\nint vmw_bo_create(struct vmw_private *dev_priv,\n\t\t  struct vmw_bo_params *params,\n\t\t  struct vmw_bo **p_bo);\n\nint vmw_bo_unref_ioctl(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file_priv);\n\nint vmw_bo_pin_in_vram(struct vmw_private *dev_priv,\n\t\t       struct vmw_bo *buf,\n\t\t       bool interruptible);\nint vmw_bo_pin_in_vram_or_gmr(struct vmw_private *dev_priv,\n\t\t\t      struct vmw_bo *buf,\n\t\t\t      bool interruptible);\nint vmw_bo_pin_in_start_of_vram(struct vmw_private *vmw_priv,\n\t\t\t\tstruct vmw_bo *bo,\n\t\t\t\tbool interruptible);\nvoid vmw_bo_pin_reserved(struct vmw_bo *bo, bool pin);\nint vmw_bo_unpin(struct vmw_private *vmw_priv,\n\t\t struct vmw_bo *bo,\n\t\t bool interruptible);\n\nvoid vmw_bo_get_guest_ptr(const struct ttm_buffer_object *buf,\n\t\t\t  SVGAGuestPtr *ptr);\nint vmw_user_bo_synccpu_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv);\nvoid vmw_bo_fence_single(struct ttm_buffer_object *bo,\n\t\t\t struct vmw_fence_obj *fence);\n\nvoid *vmw_bo_map_and_cache(struct vmw_bo *vbo);\nvoid vmw_bo_unmap(struct vmw_bo *vbo);\n\nvoid vmw_bo_move_notify(struct ttm_buffer_object *bo,\n\t\t\tstruct ttm_resource *mem);\nvoid vmw_bo_swap_notify(struct ttm_buffer_object *bo);\n\nint vmw_user_bo_lookup(struct drm_file *filp,\n\t\t       u32 handle,\n\t\t       struct vmw_bo **out);\n \nstatic inline void vmw_bo_prio_adjust(struct vmw_bo *vbo)\n{\n\tint i = ARRAY_SIZE(vbo->res_prios);\n\n\twhile (i--) {\n\t\tif (vbo->res_prios[i]) {\n\t\t\tvbo->tbo.priority = i;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvbo->tbo.priority = 3;\n}\n\n \nstatic inline void vmw_bo_prio_add(struct vmw_bo *vbo, int prio)\n{\n\tif (vbo->res_prios[prio]++ == 0)\n\t\tvmw_bo_prio_adjust(vbo);\n}\n\n \nstatic inline void vmw_bo_prio_del(struct vmw_bo *vbo, int prio)\n{\n\tif (--vbo->res_prios[prio] == 0)\n\t\tvmw_bo_prio_adjust(vbo);\n}\n\nstatic inline void vmw_bo_unreference(struct vmw_bo **buf)\n{\n\tstruct vmw_bo *tmp_buf = *buf;\n\n\t*buf = NULL;\n\tif (tmp_buf)\n\t\tttm_bo_put(&tmp_buf->tbo);\n}\n\nstatic inline struct vmw_bo *vmw_bo_reference(struct vmw_bo *buf)\n{\n\tttm_bo_get(&buf->tbo);\n\treturn buf;\n}\n\nstatic inline struct vmw_bo *vmw_user_bo_ref(struct vmw_bo *vbo)\n{\n\tdrm_gem_object_get(&vbo->tbo.base);\n\treturn vbo;\n}\n\nstatic inline void vmw_user_bo_unref(struct vmw_bo **buf)\n{\n\tstruct vmw_bo *tmp_buf = *buf;\n\n\t*buf = NULL;\n\tif (tmp_buf)\n\t\tdrm_gem_object_put(&tmp_buf->tbo.base);\n}\n\nstatic inline struct vmw_bo *to_vmw_bo(struct drm_gem_object *gobj)\n{\n\treturn container_of((gobj), struct vmw_bo, tbo.base);\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}