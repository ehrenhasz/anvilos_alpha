{
  "module_name": "vmwgfx_drv.h",
  "hash_id": "a95193a32b663f911b4356f5eaab922531d475ec54f7c1d11258cf5baffe5641",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h",
  "human_readable_source": " \n \n\n#ifndef _VMWGFX_DRV_H_\n#define _VMWGFX_DRV_H_\n\n#include <linux/suspend.h>\n#include <linux/sync_file.h>\n#include <linux/hashtable.h>\n\n#include <drm/drm_auth.h>\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n#include <drm/drm_rect.h>\n\n#include <drm/ttm/ttm_execbuf_util.h>\n#include <drm/ttm/ttm_tt.h>\n#include <drm/ttm/ttm_placement.h>\n#include <drm/ttm/ttm_bo.h>\n\n#include \"ttm_object.h\"\n\n#include \"vmwgfx_fence.h\"\n#include \"vmwgfx_reg.h\"\n#include \"vmwgfx_validation.h\"\n\n \n#include <drm/vmwgfx_drm.h>\n\n\n#define VMWGFX_DRIVER_NAME \"vmwgfx\"\n#define VMWGFX_DRIVER_DATE \"20211206\"\n#define VMWGFX_DRIVER_MAJOR 2\n#define VMWGFX_DRIVER_MINOR 20\n#define VMWGFX_DRIVER_PATCHLEVEL 0\n#define VMWGFX_FIFO_STATIC_SIZE (1024*1024)\n#define VMWGFX_MAX_DISPLAYS 16\n#define VMWGFX_CMD_BOUNCE_INIT_SIZE 32768\n\n#define VMWGFX_MIN_INITIAL_WIDTH 1280\n#define VMWGFX_MIN_INITIAL_HEIGHT 800\n\n#define VMWGFX_PCI_ID_SVGA2              0x0405\n#define VMWGFX_PCI_ID_SVGA3              0x0406\n\n \n#define VMWGFX_MAX_NUM_IRQS 6\n\n \n#define VMWGFX_NUM_GB_CONTEXT 256\n#define VMWGFX_NUM_GB_SHADER 20000\n#define VMWGFX_NUM_GB_SURFACE 32768\n#define VMWGFX_NUM_GB_SCREEN_TARGET VMWGFX_MAX_DISPLAYS\n#define VMWGFX_NUM_DXCONTEXT 256\n#define VMWGFX_NUM_DXQUERY 512\n#define VMWGFX_NUM_MOB (VMWGFX_NUM_GB_CONTEXT +\\\n\t\t\tVMWGFX_NUM_GB_SHADER +\\\n\t\t\tVMWGFX_NUM_GB_SURFACE +\\\n\t\t\tVMWGFX_NUM_GB_SCREEN_TARGET)\n\n#define VMW_PL_GMR      (TTM_PL_PRIV + 0)\n#define VMW_PL_MOB      (TTM_PL_PRIV + 1)\n#define VMW_PL_SYSTEM   (TTM_PL_PRIV + 2)\n\n#define VMW_RES_CONTEXT ttm_driver_type0\n#define VMW_RES_SURFACE ttm_driver_type1\n#define VMW_RES_STREAM ttm_driver_type2\n#define VMW_RES_FENCE ttm_driver_type3\n#define VMW_RES_SHADER ttm_driver_type4\n#define VMW_RES_HT_ORDER 12\n\n#define VMW_CURSOR_SNOOP_FORMAT SVGA3D_A8R8G8B8\n#define VMW_CURSOR_SNOOP_WIDTH 64\n#define VMW_CURSOR_SNOOP_HEIGHT 64\n\n#define MKSSTAT_CAPACITY_LOG2 5U\n#define MKSSTAT_CAPACITY (1U << MKSSTAT_CAPACITY_LOG2)\n\nstruct vmw_fpriv {\n\tstruct ttm_object_file *tfile;\n\tbool gb_aware;  \n};\n\nstruct vmwgfx_hash_item {\n\tstruct hlist_node head;\n\tunsigned long key;\n};\n\n\n \nstruct vmw_validate_buffer {\n\tstruct ttm_validate_buffer base;\n\tstruct vmwgfx_hash_item hash;\n\tbool validate_as_mob;\n};\n\nstruct vmw_res_func;\n\n\n \nstruct vmw_bo;\nstruct vmw_bo;\nstruct vmw_resource_dirty;\nstruct vmw_resource {\n\tstruct kref kref;\n\tstruct vmw_private *dev_priv;\n\tint id;\n\tu32 used_prio;\n\tunsigned long guest_memory_size;\n\tu32 res_dirty : 1;\n\tu32 guest_memory_dirty : 1;\n\tu32 coherent : 1;\n\tstruct vmw_bo *guest_memory_bo;\n\tunsigned long guest_memory_offset;\n\tunsigned long pin_count;\n\tconst struct vmw_res_func *func;\n\tstruct rb_node mob_node;\n\tstruct list_head lru_head;\n\tstruct list_head binding_head;\n\tstruct vmw_resource_dirty *dirty;\n\tvoid (*res_free) (struct vmw_resource *res);\n\tvoid (*hw_destroy) (struct vmw_resource *res);\n};\n\n\n \nenum vmw_res_type {\n\tvmw_res_context,\n\tvmw_res_surface,\n\tvmw_res_stream,\n\tvmw_res_shader,\n\tvmw_res_dx_context,\n\tvmw_res_cotable,\n\tvmw_res_view,\n\tvmw_res_streamoutput,\n\tvmw_res_max\n};\n\n \nenum vmw_cmdbuf_res_type {\n\tvmw_cmdbuf_res_shader,\n\tvmw_cmdbuf_res_view,\n\tvmw_cmdbuf_res_streamoutput\n};\n\nstruct vmw_cmdbuf_res_manager;\n\nstruct vmw_cursor_snooper {\n\tsize_t age;\n\tuint32_t *image;\n};\n\nstruct vmw_framebuffer;\nstruct vmw_surface_offset;\n\n \nstruct vmw_surface_metadata {\n\tu64 flags;\n\tu32 format;\n\tu32 mip_levels[DRM_VMW_MAX_SURFACE_FACES];\n\tu32 multisample_count;\n\tu32 multisample_pattern;\n\tu32 quality_level;\n\tu32 autogen_filter;\n\tu32 array_size;\n\tu32 num_sizes;\n\tu32 buffer_byte_stride;\n\tstruct drm_vmw_size base_size;\n\tstruct drm_vmw_size *sizes;\n\tbool scanout;\n};\n\n \nstruct vmw_surface {\n\tstruct vmw_resource res;\n\tstruct vmw_surface_metadata metadata;\n\tstruct vmw_cursor_snooper snooper;\n\tstruct vmw_surface_offset *offsets;\n\tstruct list_head view_list;\n};\n\nstruct vmw_fifo_state {\n\tunsigned long reserved_size;\n\tu32 *dynamic_buffer;\n\tu32 *static_buffer;\n\tunsigned long static_buffer_size;\n\tbool using_bounce_buffer;\n\tuint32_t capabilities;\n\tstruct mutex fifo_mutex;\n\tstruct rw_semaphore rwsem;\n};\n\n \nstruct vmw_res_cache_entry {\n\tuint32_t handle;\n\tstruct vmw_resource *res;\n\tvoid *private;\n\tunsigned short valid_handle;\n\tunsigned short valid;\n};\n\n \nenum vmw_dma_map_mode {\n\tvmw_dma_alloc_coherent,  \n\tvmw_dma_map_populate,    \n\tvmw_dma_map_bind,        \n\tvmw_dma_map_max\n};\n\n \nstruct vmw_sg_table {\n\tenum vmw_dma_map_mode mode;\n\tstruct page **pages;\n\tconst dma_addr_t *addrs;\n\tstruct sg_table *sgt;\n\tunsigned long num_pages;\n};\n\n \nstruct vmw_piter {\n\tstruct page **pages;\n\tconst dma_addr_t *addrs;\n\tstruct sg_dma_page_iter iter;\n\tunsigned long i;\n\tunsigned long num_pages;\n\tbool (*next)(struct vmw_piter *);\n\tdma_addr_t (*dma_address)(struct vmw_piter *);\n};\n\n\nstruct vmw_ttm_tt {\n\tstruct ttm_tt dma_ttm;\n\tstruct vmw_private *dev_priv;\n\tint gmr_id;\n\tstruct vmw_mob *mob;\n\tint mem_type;\n\tstruct sg_table sgt;\n\tstruct vmw_sg_table vsgt;\n\tbool mapped;\n\tbool bound;\n};\n\n \nenum vmw_display_unit_type {\n\tvmw_du_invalid = 0,\n\tvmw_du_legacy,\n\tvmw_du_screen_object,\n\tvmw_du_screen_target,\n\tvmw_du_max\n};\n\nstruct vmw_validation_context;\nstruct vmw_ctx_validation_info;\n\n \nstruct vmw_sw_context{\n\tDECLARE_HASHTABLE(res_ht, VMW_RES_HT_ORDER);\n\tbool kernel;\n\tstruct vmw_fpriv *fp;\n\tstruct drm_file *filp;\n\tuint32_t *cmd_bounce;\n\tuint32_t cmd_bounce_size;\n\tstruct vmw_bo *cur_query_bo;\n\tstruct list_head bo_relocations;\n\tstruct list_head res_relocations;\n\tuint32_t *buf_start;\n\tstruct vmw_res_cache_entry res_cache[vmw_res_max];\n\tstruct vmw_resource *last_query_ctx;\n\tbool needs_post_query_barrier;\n\tstruct vmw_ctx_binding_state *staged_bindings;\n\tbool staged_bindings_inuse;\n\tstruct list_head staged_cmd_res;\n\tstruct list_head ctx_list;\n\tstruct vmw_ctx_validation_info *dx_ctx_node;\n\tstruct vmw_bo *dx_query_mob;\n\tstruct vmw_resource *dx_query_ctx;\n\tstruct vmw_cmdbuf_res_manager *man;\n\tstruct vmw_validation_context *ctx;\n};\n\nstruct vmw_legacy_display;\nstruct vmw_overlay;\n\nstruct vmw_vga_topology_state {\n\tuint32_t width;\n\tuint32_t height;\n\tuint32_t primary;\n\tuint32_t pos_x;\n\tuint32_t pos_y;\n};\n\n\n \nstruct vmw_otable {\n\tunsigned long size;\n\tstruct vmw_mob *page_table;\n\tbool enabled;\n};\n\nstruct vmw_otable_batch {\n\tunsigned num_otables;\n\tstruct vmw_otable *otables;\n\tstruct vmw_resource *context;\n\tstruct vmw_bo *otable_bo;\n};\n\nenum {\n\tVMW_IRQTHREAD_FENCE,\n\tVMW_IRQTHREAD_CMDBUF,\n\tVMW_IRQTHREAD_MAX\n};\n\n \nenum vmw_sm_type {\n\tVMW_SM_LEGACY = 0,\n\tVMW_SM_4,\n\tVMW_SM_4_1,\n\tVMW_SM_5,\n\tVMW_SM_5_1X,\n\tVMW_SM_MAX\n};\n\nstruct vmw_private {\n\tstruct drm_device drm;\n\tstruct ttm_device bdev;\n\n\tstruct drm_vma_offset_manager vma_manager;\n\tu32 pci_id;\n\tresource_size_t io_start;\n\tresource_size_t vram_start;\n\tresource_size_t vram_size;\n\tresource_size_t max_primary_mem;\n\tu32 __iomem *rmmio;\n\tu32 *fifo_mem;\n\tresource_size_t fifo_mem_size;\n\tuint32_t fb_max_width;\n\tuint32_t fb_max_height;\n\tuint32_t texture_max_width;\n\tuint32_t texture_max_height;\n\tuint32_t stdu_max_width;\n\tuint32_t stdu_max_height;\n\tuint32_t initial_width;\n\tuint32_t initial_height;\n\tuint32_t capabilities;\n\tuint32_t capabilities2;\n\tuint32_t max_gmr_ids;\n\tuint32_t max_gmr_pages;\n\tuint32_t max_mob_pages;\n\tuint32_t max_mob_size;\n\tuint32_t memory_size;\n\tbool has_gmr;\n\tbool has_mob;\n\tspinlock_t hw_lock;\n\tbool assume_16bpp;\n\tu32 irqs[VMWGFX_MAX_NUM_IRQS];\n\tu32 num_irq_vectors;\n\n\tenum vmw_sm_type sm_type;\n\n\t \n\n\tenum vmw_display_unit_type active_display_unit;\n\tstruct vmw_legacy_display *ldu_priv;\n\tstruct vmw_overlay *overlay_priv;\n\tstruct drm_property *hotplug_mode_update_property;\n\tstruct drm_property *implicit_placement_property;\n\tspinlock_t cursor_lock;\n\tstruct drm_atomic_state *suspend_state;\n\n\t \n\n\tspinlock_t resource_lock;\n\tstruct idr res_idr[vmw_res_max];\n\n\t \n\n\tstruct ttm_object_device *tdev;\n\n\t \n\n\tatomic_t marker_seq;\n\twait_queue_head_t fence_queue;\n\twait_queue_head_t fifo_queue;\n\tspinlock_t waiter_lock;\n\tint fence_queue_waiters;  \n\tint goal_queue_waiters;  \n\tint cmdbuf_waiters;  \n\tint error_waiters;  \n\tint fifo_queue_waiters;  \n\tuint32_t last_read_seqno;\n\tstruct vmw_fence_manager *fman;\n\tuint32_t irq_mask;  \n\n\t \n\n\tuint32_t traces_state;\n\tuint32_t enable_state;\n\tuint32_t config_done_state;\n\n\t \n\t \n\n\tstruct vmw_sw_context ctx;\n\tstruct mutex cmdbuf_mutex;\n\tstruct mutex binding_mutex;\n\n\t \n\tstruct notifier_block pm_nb;\n\tbool refuse_hibernation;\n\tbool suspend_locked;\n\n\tatomic_t num_fifo_resources;\n\n\t \n\n\tstruct vmw_bo *dummy_query_bo;\n\tstruct vmw_bo *pinned_bo;\n\tuint32_t query_cid;\n\tuint32_t query_cid_valid;\n\tbool dummy_query_bo_pinned;\n\n\t \n\n\tstruct list_head res_lru[vmw_res_max];\n\tuint32_t used_memory_size;\n\n\t \n\tenum vmw_dma_map_mode map_mode;\n\n\t \n\tstruct vmw_otable_batch otable_batch;\n\n\tstruct vmw_fifo_state *fifo;\n\tstruct vmw_cmdbuf_man *cman;\n\tDECLARE_BITMAP(irqthread_pending, VMW_IRQTHREAD_MAX);\n\n\tuint32 *devcaps;\n\n\t \n\tstruct page *mksstat_user_pages[MKSSTAT_CAPACITY];\n\tatomic_t mksstat_user_pids[MKSSTAT_CAPACITY];\n\n#if IS_ENABLED(CONFIG_DRM_VMWGFX_MKSSTATS)\n\tstruct page *mksstat_kern_pages[MKSSTAT_CAPACITY];\n\tu8 mksstat_kern_top_timer[MKSSTAT_CAPACITY];\n\tatomic_t mksstat_kern_pids[MKSSTAT_CAPACITY];\n#endif\n};\n\nstatic inline struct vmw_surface *vmw_res_to_srf(struct vmw_resource *res)\n{\n\treturn container_of(res, struct vmw_surface, res);\n}\n\nstatic inline struct vmw_private *vmw_priv(struct drm_device *dev)\n{\n\treturn (struct vmw_private *)dev->dev_private;\n}\n\nstatic inline struct vmw_private *vmw_priv_from_ttm(struct ttm_device *bdev)\n{\n\treturn container_of(bdev, struct vmw_private, bdev);\n}\n\nstatic inline struct vmw_fpriv *vmw_fpriv(struct drm_file *file_priv)\n{\n\treturn (struct vmw_fpriv *)file_priv->driver_priv;\n}\n\n \nstatic inline bool vmw_is_svga_v3(const struct vmw_private *dev)\n{\n\treturn dev->pci_id == VMWGFX_PCI_ID_SVGA3;\n}\n\n \nstatic inline void vmw_write(struct vmw_private *dev_priv,\n\t\t\t     unsigned int offset, uint32_t value)\n{\n\tif (vmw_is_svga_v3(dev_priv)) {\n\t\tiowrite32(value, dev_priv->rmmio + offset);\n\t} else {\n\t\tspin_lock(&dev_priv->hw_lock);\n\t\toutl(offset, dev_priv->io_start + SVGA_INDEX_PORT);\n\t\toutl(value, dev_priv->io_start + SVGA_VALUE_PORT);\n\t\tspin_unlock(&dev_priv->hw_lock);\n\t}\n}\n\nstatic inline uint32_t vmw_read(struct vmw_private *dev_priv,\n\t\t\t\tunsigned int offset)\n{\n\tu32 val;\n\n\tif (vmw_is_svga_v3(dev_priv)) {\n\t\tval = ioread32(dev_priv->rmmio + offset);\n\t} else {\n\t\tspin_lock(&dev_priv->hw_lock);\n\t\toutl(offset, dev_priv->io_start + SVGA_INDEX_PORT);\n\t\tval = inl(dev_priv->io_start + SVGA_VALUE_PORT);\n\t\tspin_unlock(&dev_priv->hw_lock);\n\t}\n\n\treturn val;\n}\n\n \nstatic inline bool has_sm4_context(const struct vmw_private *dev_priv)\n{\n\treturn (dev_priv->sm_type >= VMW_SM_4);\n}\n\n \nstatic inline bool has_sm4_1_context(const struct vmw_private *dev_priv)\n{\n\treturn (dev_priv->sm_type >= VMW_SM_4_1);\n}\n\n \nstatic inline bool has_sm5_context(const struct vmw_private *dev_priv)\n{\n\treturn (dev_priv->sm_type >= VMW_SM_5);\n}\n\n \nstatic inline bool has_gl43_context(const struct vmw_private *dev_priv)\n{\n\treturn (dev_priv->sm_type >= VMW_SM_5_1X);\n}\n\n\nstatic inline u32 vmw_max_num_uavs(struct vmw_private *dev_priv)\n{\n\treturn (has_gl43_context(dev_priv) ?\n\t\t\tSVGA3D_DX11_1_MAX_UAVIEWS : SVGA3D_MAX_UAVIEWS);\n}\n\nextern void vmw_svga_enable(struct vmw_private *dev_priv);\nextern void vmw_svga_disable(struct vmw_private *dev_priv);\nbool vmwgfx_supported(struct vmw_private *vmw);\n\n\n \n\nextern int vmw_gmr_bind(struct vmw_private *dev_priv,\n\t\t\tconst struct vmw_sg_table *vsgt,\n\t\t\tunsigned long num_pages,\n\t\t\tint gmr_id);\nextern void vmw_gmr_unbind(struct vmw_private *dev_priv, int gmr_id);\n\n \nstruct vmw_user_resource_conv;\n\nextern void vmw_resource_unreference(struct vmw_resource **p_res);\nextern struct vmw_resource *vmw_resource_reference(struct vmw_resource *res);\nextern struct vmw_resource *\nvmw_resource_reference_unless_doomed(struct vmw_resource *res);\nextern int vmw_resource_validate(struct vmw_resource *res, bool intr,\n\t\t\t\t bool dirtying);\nextern int vmw_resource_reserve(struct vmw_resource *res, bool interruptible,\n\t\t\t\tbool no_backup);\nextern bool vmw_resource_needs_backup(const struct vmw_resource *res);\nextern int vmw_user_lookup_handle(struct vmw_private *dev_priv,\n\t\t\t\t  struct drm_file *filp,\n\t\t\t\t  uint32_t handle,\n\t\t\t\t  struct vmw_surface **out_surf,\n\t\t\t\t  struct vmw_bo **out_buf);\nextern int vmw_user_resource_lookup_handle(\n\tstruct vmw_private *dev_priv,\n\tstruct ttm_object_file *tfile,\n\tuint32_t handle,\n\tconst struct vmw_user_resource_conv *converter,\n\tstruct vmw_resource **p_res);\n\nextern int vmw_stream_claim_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t  struct drm_file *file_priv);\nextern int vmw_stream_unref_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t  struct drm_file *file_priv);\nextern int vmw_user_stream_lookup(struct vmw_private *dev_priv,\n\t\t\t\t  struct ttm_object_file *tfile,\n\t\t\t\t  uint32_t *inout_id,\n\t\t\t\t  struct vmw_resource **out);\nextern void vmw_resource_unreserve(struct vmw_resource *res,\n\t\t\t\t   bool dirty_set,\n\t\t\t\t   bool dirty,\n\t\t\t\t   bool switch_guest_memory,\n\t\t\t\t   struct vmw_bo *new_guest_memory,\n\t\t\t\t   unsigned long new_guest_memory_offset);\nextern void vmw_query_move_notify(struct ttm_buffer_object *bo,\n\t\t\t\t  struct ttm_resource *old_mem,\n\t\t\t\t  struct ttm_resource *new_mem);\nint vmw_query_readback_all(struct vmw_bo *dx_query_mob);\nvoid vmw_resource_evict_all(struct vmw_private *dev_priv);\nvoid vmw_resource_unbind_list(struct vmw_bo *vbo);\nvoid vmw_resource_mob_attach(struct vmw_resource *res);\nvoid vmw_resource_mob_detach(struct vmw_resource *res);\nvoid vmw_resource_dirty_update(struct vmw_resource *res, pgoff_t start,\n\t\t\t       pgoff_t end);\nint vmw_resources_clean(struct vmw_bo *vbo, pgoff_t start,\n\t\t\tpgoff_t end, pgoff_t *num_prefault);\n\n \nstatic inline bool vmw_resource_mob_attached(const struct vmw_resource *res)\n{\n\treturn !RB_EMPTY_NODE(&res->mob_node);\n}\n\n \nstruct vmw_bo_params;\nint vmw_gem_object_create(struct vmw_private *vmw,\n\t\t\t  struct vmw_bo_params *params,\n\t\t\t  struct vmw_bo **p_vbo);\nextern int vmw_gem_object_create_with_handle(struct vmw_private *dev_priv,\n\t\t\t\t\t     struct drm_file *filp,\n\t\t\t\t\t     uint32_t size,\n\t\t\t\t\t     uint32_t *handle,\n\t\t\t\t\t     struct vmw_bo **p_vbo);\nextern int vmw_gem_object_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t       struct drm_file *filp);\nextern void vmw_debugfs_gem_init(struct vmw_private *vdev);\n\n \n\nextern int vmw_getparam_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv);\nextern int vmw_get_cap_3d_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv);\nextern int vmw_present_ioctl(struct drm_device *dev, void *data,\n\t\t\t     struct drm_file *file_priv);\nextern int vmw_present_readback_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t      struct drm_file *file_priv);\n\n \n\nextern struct vmw_fifo_state *vmw_fifo_create(struct vmw_private *dev_priv);\nextern void vmw_fifo_destroy(struct vmw_private *dev_priv);\nextern bool vmw_cmd_supported(struct vmw_private *vmw);\nextern void *\nvmw_cmd_ctx_reserve(struct vmw_private *dev_priv, uint32_t bytes, int ctx_id);\nextern void vmw_cmd_commit(struct vmw_private *dev_priv, uint32_t bytes);\nextern void vmw_cmd_commit_flush(struct vmw_private *dev_priv, uint32_t bytes);\nextern int vmw_cmd_send_fence(struct vmw_private *dev_priv, uint32_t *seqno);\nextern bool vmw_supports_3d(struct vmw_private *dev_priv);\nextern void vmw_fifo_ping_host(struct vmw_private *dev_priv, uint32_t reason);\nextern bool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv);\nextern int vmw_cmd_emit_dummy_query(struct vmw_private *dev_priv,\n\t\t\t\t    uint32_t cid);\nextern int vmw_cmd_flush(struct vmw_private *dev_priv,\n\t\t\t bool interruptible);\n\n#define VMW_CMD_CTX_RESERVE(__priv, __bytes, __ctx_id)                        \\\n({                                                                            \\\n\tvmw_cmd_ctx_reserve(__priv, __bytes, __ctx_id) ? : ({                 \\\n\t\tDRM_ERROR(\"FIFO reserve failed at %s for %u bytes\\n\",         \\\n\t\t\t  __func__, (unsigned int) __bytes);                  \\\n\t\tNULL;                                                         \\\n\t});                                                                   \\\n})\n\n#define VMW_CMD_RESERVE(__priv, __bytes)                                     \\\n\tVMW_CMD_CTX_RESERVE(__priv, __bytes, SVGA3D_INVALID_ID)\n\n\n \nstatic inline uint32_t vmw_fifo_caps(const struct vmw_private *dev_priv)\n{\n\tif (!dev_priv->fifo_mem || !dev_priv->fifo)\n\t\treturn 0;\n\treturn dev_priv->fifo->capabilities;\n}\n\n\n \nstatic inline bool\nvmw_is_cursor_bypass3_enabled(const struct vmw_private *dev_priv)\n{\n\treturn (vmw_fifo_caps(dev_priv) & SVGA_FIFO_CAP_CURSOR_BYPASS_3) != 0;\n}\n\n \n\nextern const size_t vmw_tt_size;\nextern struct ttm_placement vmw_vram_placement;\nextern struct ttm_placement vmw_vram_gmr_placement;\nextern struct ttm_placement vmw_sys_placement;\nextern struct ttm_device_funcs vmw_bo_driver;\nextern const struct vmw_sg_table *\nvmw_bo_sg_table(struct ttm_buffer_object *bo);\nint vmw_bo_create_and_populate(struct vmw_private *dev_priv,\n\t\t\t       size_t bo_size,\n\t\t\t       u32 domain,\n\t\t\t       struct vmw_bo **bo_p);\n\nextern void vmw_piter_start(struct vmw_piter *viter,\n\t\t\t    const struct vmw_sg_table *vsgt,\n\t\t\t    unsigned long p_offs);\n\n \nstatic inline bool vmw_piter_next(struct vmw_piter *viter)\n{\n\treturn viter->next(viter);\n}\n\n \nstatic inline dma_addr_t vmw_piter_dma_addr(struct vmw_piter *viter)\n{\n\treturn viter->dma_address(viter);\n}\n\n \nstatic inline struct page *vmw_piter_page(struct vmw_piter *viter)\n{\n\treturn viter->pages[viter->i];\n}\n\n \n\nextern int vmw_execbuf_ioctl(struct drm_device *dev, void *data,\n\t\t\t     struct drm_file *file_priv);\nextern int vmw_execbuf_process(struct drm_file *file_priv,\n\t\t\t       struct vmw_private *dev_priv,\n\t\t\t       void __user *user_commands,\n\t\t\t       void *kernel_commands,\n\t\t\t       uint32_t command_size,\n\t\t\t       uint64_t throttle_us,\n\t\t\t       uint32_t dx_context_handle,\n\t\t\t       struct drm_vmw_fence_rep __user\n\t\t\t       *user_fence_rep,\n\t\t\t       struct vmw_fence_obj **out_fence,\n\t\t\t       uint32_t flags);\nextern void __vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv,\n\t\t\t\t\t    struct vmw_fence_obj *fence);\nextern void vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv);\n\nextern int vmw_execbuf_fence_commands(struct drm_file *file_priv,\n\t\t\t\t      struct vmw_private *dev_priv,\n\t\t\t\t      struct vmw_fence_obj **p_fence,\n\t\t\t\t      uint32_t *p_handle);\nextern int vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv,\n\t\t\t\t\tstruct vmw_fpriv *vmw_fp,\n\t\t\t\t\tint ret,\n\t\t\t\t\tstruct drm_vmw_fence_rep __user\n\t\t\t\t\t*user_fence_rep,\n\t\t\t\t\tstruct vmw_fence_obj *fence,\n\t\t\t\t\tuint32_t fence_handle,\n\t\t\t\t\tint32_t out_fence_fd);\nbool vmw_cmd_describe(const void *buf, u32 *size, char const **cmd);\n\n \n\nextern int vmw_irq_install(struct vmw_private *dev_priv);\nextern void vmw_irq_uninstall(struct drm_device *dev);\nextern bool vmw_seqno_passed(struct vmw_private *dev_priv,\n\t\t\t\tuint32_t seqno);\nextern int vmw_fallback_wait(struct vmw_private *dev_priv,\n\t\t\t     bool lazy,\n\t\t\t     bool fifo_idle,\n\t\t\t     uint32_t seqno,\n\t\t\t     bool interruptible,\n\t\t\t     unsigned long timeout);\nextern void vmw_update_seqno(struct vmw_private *dev_priv);\nextern void vmw_seqno_waiter_add(struct vmw_private *dev_priv);\nextern void vmw_seqno_waiter_remove(struct vmw_private *dev_priv);\nextern void vmw_goal_waiter_add(struct vmw_private *dev_priv);\nextern void vmw_goal_waiter_remove(struct vmw_private *dev_priv);\nextern void vmw_generic_waiter_add(struct vmw_private *dev_priv, u32 flag,\n\t\t\t\t   int *waiter_count);\nextern void vmw_generic_waiter_remove(struct vmw_private *dev_priv,\n\t\t\t\t      u32 flag, int *waiter_count);\n\n \n\nint vmw_kms_init(struct vmw_private *dev_priv);\nint vmw_kms_close(struct vmw_private *dev_priv);\nint vmw_kms_cursor_bypass_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv);\nvoid vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv);\nvoid vmw_kms_cursor_snoop(struct vmw_surface *srf,\n\t\t\t  struct ttm_object_file *tfile,\n\t\t\t  struct ttm_buffer_object *bo,\n\t\t\t  SVGA3dCmdHeader *header);\nint vmw_kms_write_svga(struct vmw_private *vmw_priv,\n\t\t       unsigned width, unsigned height, unsigned pitch,\n\t\t       unsigned bpp, unsigned depth);\nbool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv,\n\t\t\t\tuint32_t pitch,\n\t\t\t\tuint32_t height);\nint vmw_kms_present(struct vmw_private *dev_priv,\n\t\t    struct drm_file *file_priv,\n\t\t    struct vmw_framebuffer *vfb,\n\t\t    struct vmw_surface *surface,\n\t\t    uint32_t sid, int32_t destX, int32_t destY,\n\t\t    struct drm_vmw_rect *clips,\n\t\t    uint32_t num_clips);\nint vmw_kms_update_layout_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv);\nvoid vmw_kms_legacy_hotspot_clear(struct vmw_private *dev_priv);\nint vmw_kms_suspend(struct drm_device *dev);\nint vmw_kms_resume(struct drm_device *dev);\nvoid vmw_kms_lost_device(struct drm_device *dev);\n\nint vmw_dumb_create(struct drm_file *file_priv,\n\t\t    struct drm_device *dev,\n\t\t    struct drm_mode_create_dumb *args);\nextern int vmw_resource_pin(struct vmw_resource *res, bool interruptible);\nextern void vmw_resource_unpin(struct vmw_resource *res);\nextern enum vmw_res_type vmw_res_type(const struct vmw_resource *res);\n\n \n\nint vmw_overlay_init(struct vmw_private *dev_priv);\nint vmw_overlay_close(struct vmw_private *dev_priv);\nint vmw_overlay_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv);\nint vmw_overlay_resume_all(struct vmw_private *dev_priv);\nint vmw_overlay_pause_all(struct vmw_private *dev_priv);\nint vmw_overlay_claim(struct vmw_private *dev_priv, uint32_t *out);\nint vmw_overlay_unref(struct vmw_private *dev_priv, uint32_t stream_id);\nint vmw_overlay_num_overlays(struct vmw_private *dev_priv);\nint vmw_overlay_num_free_overlays(struct vmw_private *dev_priv);\n\n \n\nint vmw_gmrid_man_init(struct vmw_private *dev_priv, int type);\nvoid vmw_gmrid_man_fini(struct vmw_private *dev_priv, int type);\n\n \nint vmw_sys_man_init(struct vmw_private *dev_priv);\nvoid vmw_sys_man_fini(struct vmw_private *dev_priv);\n\n \n\nextern const struct dma_buf_ops vmw_prime_dmabuf_ops;\nextern int vmw_prime_fd_to_handle(struct drm_device *dev,\n\t\t\t\t  struct drm_file *file_priv,\n\t\t\t\t  int fd, u32 *handle);\nextern int vmw_prime_handle_to_fd(struct drm_device *dev,\n\t\t\t\t  struct drm_file *file_priv,\n\t\t\t\t  uint32_t handle, uint32_t flags,\n\t\t\t\t  int *prime_fd);\n\n \nstruct vmw_mob;\nextern int vmw_mob_bind(struct vmw_private *dev_priv, struct vmw_mob *mob,\n\t\t\tconst struct vmw_sg_table *vsgt,\n\t\t\tunsigned long num_data_pages, int32_t mob_id);\nextern void vmw_mob_unbind(struct vmw_private *dev_priv,\n\t\t\t   struct vmw_mob *mob);\nextern void vmw_mob_destroy(struct vmw_mob *mob);\nextern struct vmw_mob *vmw_mob_create(unsigned long data_pages);\nextern int vmw_otables_setup(struct vmw_private *dev_priv);\nextern void vmw_otables_takedown(struct vmw_private *dev_priv);\n\n \n\nextern const struct vmw_user_resource_conv *user_context_converter;\n\nextern int vmw_context_define_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t    struct drm_file *file_priv);\nextern int vmw_extended_context_define_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t\t     struct drm_file *file_priv);\nextern int vmw_context_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t     struct drm_file *file_priv);\nextern struct list_head *vmw_context_binding_list(struct vmw_resource *ctx);\nextern struct vmw_cmdbuf_res_manager *\nvmw_context_res_man(struct vmw_resource *ctx);\nextern struct vmw_resource *vmw_context_cotable(struct vmw_resource *ctx,\n\t\t\t\t\t\tSVGACOTableType cotable_type);\nstruct vmw_ctx_binding_state;\nextern struct vmw_ctx_binding_state *\nvmw_context_binding_state(struct vmw_resource *ctx);\nextern void vmw_dx_context_scrub_cotables(struct vmw_resource *ctx,\n\t\t\t\t\t  bool readback);\nextern int vmw_context_bind_dx_query(struct vmw_resource *ctx_res,\n\t\t\t\t     struct vmw_bo *mob);\nextern struct vmw_bo *\nvmw_context_get_dx_query_mob(struct vmw_resource *ctx_res);\n\n\n \n\nextern const struct vmw_user_resource_conv *user_surface_converter;\n\nextern int vmw_surface_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t     struct drm_file *file_priv);\nextern int vmw_surface_define_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t    struct drm_file *file_priv);\nextern int vmw_surface_reference_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t       struct drm_file *file_priv);\nextern int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t       struct drm_file *file_priv);\nextern int vmw_gb_surface_reference_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t\t  struct drm_file *file_priv);\nextern int vmw_gb_surface_define_ext_ioctl(struct drm_device *dev,\n\t\t\t\t\t   void *data,\n\t\t\t\t\t   struct drm_file *file_priv);\nextern int vmw_gb_surface_reference_ext_ioctl(struct drm_device *dev,\n\t\t\t\t\t      void *data,\n\t\t\t\t\t      struct drm_file *file_priv);\n\nint vmw_gb_surface_define(struct vmw_private *dev_priv,\n\t\t\t  const struct vmw_surface_metadata *req,\n\t\t\t  struct vmw_surface **srf_out);\n\n \n\nextern const struct vmw_user_resource_conv *user_shader_converter;\n\nextern int vmw_shader_define_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file_priv);\nextern int vmw_shader_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t    struct drm_file *file_priv);\nextern int vmw_compat_shader_add(struct vmw_private *dev_priv,\n\t\t\t\t struct vmw_cmdbuf_res_manager *man,\n\t\t\t\t u32 user_key, const void *bytecode,\n\t\t\t\t SVGA3dShaderType shader_type,\n\t\t\t\t size_t size,\n\t\t\t\t struct list_head *list);\nextern int vmw_shader_remove(struct vmw_cmdbuf_res_manager *man,\n\t\t\t     u32 user_key, SVGA3dShaderType shader_type,\n\t\t\t     struct list_head *list);\nextern int vmw_dx_shader_add(struct vmw_cmdbuf_res_manager *man,\n\t\t\t     struct vmw_resource *ctx,\n\t\t\t     u32 user_key,\n\t\t\t     SVGA3dShaderType shader_type,\n\t\t\t     struct list_head *list);\nextern void vmw_dx_shader_cotable_list_scrub(struct vmw_private *dev_priv,\n\t\t\t\t\t     struct list_head *list,\n\t\t\t\t\t     bool readback);\n\nextern struct vmw_resource *\nvmw_shader_lookup(struct vmw_cmdbuf_res_manager *man,\n\t\t  u32 user_key, SVGA3dShaderType shader_type);\n\n \nstruct vmw_resource *\nvmw_dx_streamoutput_lookup(struct vmw_cmdbuf_res_manager *man,\n\t\t\t   u32 user_key);\nint vmw_dx_streamoutput_add(struct vmw_cmdbuf_res_manager *man,\n\t\t\t    struct vmw_resource *ctx,\n\t\t\t    SVGA3dStreamOutputId user_key,\n\t\t\t    struct list_head *list);\nvoid vmw_dx_streamoutput_set_size(struct vmw_resource *res, u32 size);\nint vmw_dx_streamoutput_remove(struct vmw_cmdbuf_res_manager *man,\n\t\t\t       SVGA3dStreamOutputId user_key,\n\t\t\t       struct list_head *list);\nvoid vmw_dx_streamoutput_cotable_list_scrub(struct vmw_private *dev_priv,\n\t\t\t\t\t    struct list_head *list,\n\t\t\t\t\t    bool readback);\n\n \n\nextern struct vmw_cmdbuf_res_manager *\nvmw_cmdbuf_res_man_create(struct vmw_private *dev_priv);\nextern void vmw_cmdbuf_res_man_destroy(struct vmw_cmdbuf_res_manager *man);\nextern struct vmw_resource *\nvmw_cmdbuf_res_lookup(struct vmw_cmdbuf_res_manager *man,\n\t\t      enum vmw_cmdbuf_res_type res_type,\n\t\t      u32 user_key);\nextern void vmw_cmdbuf_res_revert(struct list_head *list);\nextern void vmw_cmdbuf_res_commit(struct list_head *list);\nextern int vmw_cmdbuf_res_add(struct vmw_cmdbuf_res_manager *man,\n\t\t\t      enum vmw_cmdbuf_res_type res_type,\n\t\t\t      u32 user_key,\n\t\t\t      struct vmw_resource *res,\n\t\t\t      struct list_head *list);\nextern int vmw_cmdbuf_res_remove(struct vmw_cmdbuf_res_manager *man,\n\t\t\t\t enum vmw_cmdbuf_res_type res_type,\n\t\t\t\t u32 user_key,\n\t\t\t\t struct list_head *list,\n\t\t\t\t struct vmw_resource **res);\n\n \nextern const SVGACOTableType vmw_cotable_scrub_order[];\nextern struct vmw_resource *vmw_cotable_alloc(struct vmw_private *dev_priv,\n\t\t\t\t\t      struct vmw_resource *ctx,\n\t\t\t\t\t      u32 type);\nextern int vmw_cotable_notify(struct vmw_resource *res, int id);\nextern int vmw_cotable_scrub(struct vmw_resource *res, bool readback);\nextern void vmw_cotable_add_resource(struct vmw_resource *ctx,\n\t\t\t\t     struct list_head *head);\n\n \nstruct vmw_cmdbuf_man;\nstruct vmw_cmdbuf_header;\n\nextern struct vmw_cmdbuf_man *\nvmw_cmdbuf_man_create(struct vmw_private *dev_priv);\nextern int vmw_cmdbuf_set_pool_size(struct vmw_cmdbuf_man *man, size_t size);\nextern void vmw_cmdbuf_remove_pool(struct vmw_cmdbuf_man *man);\nextern void vmw_cmdbuf_man_destroy(struct vmw_cmdbuf_man *man);\nextern int vmw_cmdbuf_idle(struct vmw_cmdbuf_man *man, bool interruptible,\n\t\t\t   unsigned long timeout);\nextern void *vmw_cmdbuf_reserve(struct vmw_cmdbuf_man *man, size_t size,\n\t\t\t\tint ctx_id, bool interruptible,\n\t\t\t\tstruct vmw_cmdbuf_header *header);\nextern void vmw_cmdbuf_commit(struct vmw_cmdbuf_man *man, size_t size,\n\t\t\t      struct vmw_cmdbuf_header *header,\n\t\t\t      bool flush);\nextern void *vmw_cmdbuf_alloc(struct vmw_cmdbuf_man *man,\n\t\t\t      size_t size, bool interruptible,\n\t\t\t      struct vmw_cmdbuf_header **p_header);\nextern void vmw_cmdbuf_header_free(struct vmw_cmdbuf_header *header);\nextern int vmw_cmdbuf_cur_flush(struct vmw_cmdbuf_man *man,\n\t\t\t\tbool interruptible);\nextern void vmw_cmdbuf_irqthread(struct vmw_cmdbuf_man *man);\n\n \n\n \nstruct vmw_diff_cpy {\n\tstruct drm_rect rect;\n\tsize_t line;\n\tsize_t line_offset;\n\tint cpp;\n\tvoid (*do_cpy)(struct vmw_diff_cpy *diff, u8 *dest, const u8 *src,\n\t\t       size_t n);\n};\n\n#define VMW_CPU_BLIT_INITIALIZER {\t\\\n\t.do_cpy = vmw_memcpy,\t\t\\\n}\n\n#define VMW_CPU_BLIT_DIFF_INITIALIZER(_cpp) {\t  \\\n\t.line = 0,\t\t\t\t  \\\n\t.line_offset = 0,\t\t\t  \\\n\t.rect = { .x1 = INT_MAX/2,\t\t  \\\n\t\t  .y1 = INT_MAX/2,\t\t  \\\n\t\t  .x2 = INT_MIN/2,\t\t  \\\n\t\t  .y2 = INT_MIN/2\t\t  \\\n\t},\t\t\t\t\t  \\\n\t.cpp = _cpp,\t\t\t\t  \\\n\t.do_cpy = vmw_diff_memcpy,\t\t  \\\n}\n\nvoid vmw_diff_memcpy(struct vmw_diff_cpy *diff, u8 *dest, const u8 *src,\n\t\t     size_t n);\n\nvoid vmw_memcpy(struct vmw_diff_cpy *diff, u8 *dest, const u8 *src, size_t n);\n\nint vmw_bo_cpu_blit(struct ttm_buffer_object *dst,\n\t\t    u32 dst_offset, u32 dst_stride,\n\t\t    struct ttm_buffer_object *src,\n\t\t    u32 src_offset, u32 src_stride,\n\t\t    u32 w, u32 h,\n\t\t    struct vmw_diff_cpy *diff);\n\n \nvoid vmw_disable_backdoor(void);\nint vmw_host_get_guestinfo(const char *guest_info_param,\n\t\t\t   char *buffer, size_t *length);\n__printf(1, 2) int vmw_host_printf(const char *fmt, ...);\nint vmw_msg_ioctl(struct drm_device *dev, void *data,\n\t\t  struct drm_file *file_priv);\n\n \nint vmw_mksstat_get_kern_slot(pid_t pid, struct vmw_private *dev_priv);\n\nint vmw_mksstat_reset_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv);\nint vmw_mksstat_add_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv);\nint vmw_mksstat_remove_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv);\nint vmw_mksstat_remove_all(struct vmw_private *dev_priv);\n\n \n\n \n#define VMW_DEBUG_USER(fmt, ...)                                              \\\n\tDRM_DEBUG_DRIVER(fmt, ##__VA_ARGS__)\n\n \nvoid vmw_bo_dirty_scan(struct vmw_bo *vbo);\nint vmw_bo_dirty_add(struct vmw_bo *vbo);\nvoid vmw_bo_dirty_transfer_to_res(struct vmw_resource *res);\nvoid vmw_bo_dirty_clear_res(struct vmw_resource *res);\nvoid vmw_bo_dirty_release(struct vmw_bo *vbo);\nvoid vmw_bo_dirty_unmap(struct vmw_bo *vbo,\n\t\t\tpgoff_t start, pgoff_t end);\nvm_fault_t vmw_bo_vm_fault(struct vm_fault *vmf);\nvm_fault_t vmw_bo_vm_mkwrite(struct vm_fault *vmf);\n\n\n \n#define VMW_DEBUG_KMS(fmt, ...)                                               \\\n\tDRM_DEBUG_DRIVER(fmt, ##__VA_ARGS__)\n\n \n\nstatic inline void vmw_surface_unreference(struct vmw_surface **srf)\n{\n\tstruct vmw_surface *tmp_srf = *srf;\n\tstruct vmw_resource *res = &tmp_srf->res;\n\t*srf = NULL;\n\n\tvmw_resource_unreference(&res);\n}\n\nstatic inline struct vmw_surface *vmw_surface_reference(struct vmw_surface *srf)\n{\n\t(void) vmw_resource_reference(&srf->res);\n\treturn srf;\n}\n\nstatic inline void vmw_fifo_resource_inc(struct vmw_private *dev_priv)\n{\n\tatomic_inc(&dev_priv->num_fifo_resources);\n}\n\nstatic inline void vmw_fifo_resource_dec(struct vmw_private *dev_priv)\n{\n\tatomic_dec(&dev_priv->num_fifo_resources);\n}\n\n \nstatic inline u32 vmw_fifo_mem_read(struct vmw_private *vmw, uint32 fifo_reg)\n{\n\tBUG_ON(vmw_is_svga_v3(vmw));\n\treturn READ_ONCE(*(vmw->fifo_mem + fifo_reg));\n}\n\n \nstatic inline void vmw_fifo_mem_write(struct vmw_private *vmw, u32 fifo_reg,\n\t\t\t\t      u32 value)\n{\n\tBUG_ON(vmw_is_svga_v3(vmw));\n\tWRITE_ONCE(*(vmw->fifo_mem + fifo_reg), value);\n}\n\nstatic inline u32 vmw_fence_read(struct vmw_private *dev_priv)\n{\n\tu32 fence;\n\tif (vmw_is_svga_v3(dev_priv))\n\t\tfence = vmw_read(dev_priv, SVGA_REG_FENCE);\n\telse\n\t\tfence = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_FENCE);\n\treturn fence;\n}\n\nstatic inline void vmw_fence_write(struct vmw_private *dev_priv,\n\t\t\t\t  u32 fence)\n{\n\tBUG_ON(vmw_is_svga_v3(dev_priv));\n\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_FENCE, fence);\n}\n\nstatic inline u32 vmw_irq_status_read(struct vmw_private *vmw)\n{\n\tu32 status;\n\tif (vmw_is_svga_v3(vmw))\n\t\tstatus = vmw_read(vmw, SVGA_REG_IRQ_STATUS);\n\telse\n\t\tstatus = inl(vmw->io_start + SVGA_IRQSTATUS_PORT);\n\treturn status;\n}\n\nstatic inline void vmw_irq_status_write(struct vmw_private *vmw,\n\t\t\t\t\tuint32 status)\n{\n\tif (vmw_is_svga_v3(vmw))\n\t\tvmw_write(vmw, SVGA_REG_IRQ_STATUS, status);\n\telse\n\t\toutl(status, vmw->io_start + SVGA_IRQSTATUS_PORT);\n}\n\nstatic inline bool vmw_has_fences(struct vmw_private *vmw)\n{\n\tif ((vmw->capabilities & (SVGA_CAP_COMMAND_BUFFERS |\n\t\t\t\t  SVGA_CAP_CMD_BUFFERS_2)) != 0)\n\t\treturn true;\n\treturn (vmw_fifo_caps(vmw) & SVGA_FIFO_CAP_FENCE) != 0;\n}\n\nstatic inline bool vmw_shadertype_is_valid(enum vmw_sm_type shader_model,\n\t\t\t\t\t   u32 shader_type)\n{\n\tSVGA3dShaderType max_allowed = SVGA3D_SHADERTYPE_PREDX_MAX;\n\n\tif (shader_model >= VMW_SM_5)\n\t\tmax_allowed = SVGA3D_SHADERTYPE_MAX;\n\telse if (shader_model >= VMW_SM_4)\n\t\tmax_allowed = SVGA3D_SHADERTYPE_DX10_MAX;\n\treturn shader_type >= SVGA3D_SHADERTYPE_MIN && shader_type < max_allowed;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}