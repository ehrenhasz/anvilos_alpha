{
  "module_name": "vmwgfx_fence.h",
  "hash_id": "b4e2080fae4fe5ea0622c688be6b23bd3d4b5df875253e899be70e419c494d5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h",
  "human_readable_source": " \n \n\n#ifndef _VMWGFX_FENCE_H_\n\n#include <linux/dma-fence.h>\n#include <linux/dma-fence-array.h>\n\n#define VMW_FENCE_WAIT_TIMEOUT (5*HZ)\n\nstruct drm_device;\nstruct drm_file;\nstruct drm_pending_event;\n\nstruct vmw_private;\nstruct vmw_fence_manager;\n\n \nenum vmw_action_type {\n\tVMW_ACTION_EVENT = 0,\n\tVMW_ACTION_MAX\n};\n\nstruct vmw_fence_action {\n\tstruct list_head head;\n\tenum vmw_action_type type;\n\tvoid (*seq_passed) (struct vmw_fence_action *action);\n\tvoid (*cleanup) (struct vmw_fence_action *action);\n};\n\nstruct vmw_fence_obj {\n\tstruct dma_fence base;\n\n\tstruct list_head head;\n\tstruct list_head seq_passed_actions;\n\tvoid (*destroy)(struct vmw_fence_obj *fence);\n};\n\nextern struct vmw_fence_manager *\nvmw_fence_manager_init(struct vmw_private *dev_priv);\n\nextern void vmw_fence_manager_takedown(struct vmw_fence_manager *fman);\n\nstatic inline void\nvmw_fence_obj_unreference(struct vmw_fence_obj **fence_p)\n{\n\tstruct vmw_fence_obj *fence = *fence_p;\n\n\t*fence_p = NULL;\n\tif (fence)\n\t\tdma_fence_put(&fence->base);\n}\n\nstatic inline struct vmw_fence_obj *\nvmw_fence_obj_reference(struct vmw_fence_obj *fence)\n{\n\tif (fence)\n\t\tdma_fence_get(&fence->base);\n\treturn fence;\n}\n\nextern void vmw_fences_update(struct vmw_fence_manager *fman);\n\nextern bool vmw_fence_obj_signaled(struct vmw_fence_obj *fence);\n\nextern int vmw_fence_obj_wait(struct vmw_fence_obj *fence,\n\t\t\t      bool lazy,\n\t\t\t      bool interruptible, unsigned long timeout);\n\nextern int vmw_fence_create(struct vmw_fence_manager *fman,\n\t\t\t    uint32_t seqno,\n\t\t\t    struct vmw_fence_obj **p_fence);\n\nextern int vmw_user_fence_create(struct drm_file *file_priv,\n\t\t\t\t struct vmw_fence_manager *fman,\n\t\t\t\t uint32_t sequence,\n\t\t\t\t struct vmw_fence_obj **p_fence,\n\t\t\t\t uint32_t *p_handle);\n\nextern void vmw_fence_fifo_up(struct vmw_fence_manager *fman);\n\nextern void vmw_fence_fifo_down(struct vmw_fence_manager *fman);\n\nextern int vmw_fence_obj_wait_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t    struct drm_file *file_priv);\n\nextern int vmw_fence_obj_signaled_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t\tstruct drm_file *file_priv);\n\nextern int vmw_fence_obj_unref_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t     struct drm_file *file_priv);\nextern int vmw_fence_event_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t struct drm_file *file_priv);\nextern int vmw_event_fence_action_queue(struct drm_file *filee_priv,\n\t\t\t\t\tstruct vmw_fence_obj *fence,\n\t\t\t\t\tstruct drm_pending_event *event,\n\t\t\t\t\tuint32_t *tv_sec,\n\t\t\t\t\tuint32_t *tv_usec,\n\t\t\t\t\tbool interruptible);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}