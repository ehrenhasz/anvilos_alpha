{
  "module_name": "vmwgfx_execbuf.c",
  "hash_id": "d5f7a4e9a91f469086a771fe513583ee2899c4ac3636a6df2c9bbb1c6d5bd8b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c",
  "human_readable_source": "\n \n#include \"vmwgfx_binding.h\"\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_mksstat.h\"\n#include \"vmwgfx_so.h\"\n\n#include <drm/ttm/ttm_bo.h>\n#include <drm/ttm/ttm_placement.h>\n\n#include <linux/sync_file.h>\n#include <linux/hashtable.h>\n\n \n#define VMW_GET_CTX_NODE(__sw_context)                                        \\\n({                                                                            \\\n\t__sw_context->dx_ctx_node ? __sw_context->dx_ctx_node : ({            \\\n\t\tVMW_DEBUG_USER(\"SM context is not set at %s\\n\", __func__);    \\\n\t\t__sw_context->dx_ctx_node;                                    \\\n\t});                                                                   \\\n})\n\n#define VMW_DECLARE_CMD_VAR(__var, __type)                                    \\\n\tstruct {                                                              \\\n\t\tSVGA3dCmdHeader header;                                       \\\n\t\t__type body;                                                  \\\n\t} __var\n\n \nstruct vmw_relocation {\n\tstruct list_head head;\n\tstruct vmw_bo *vbo;\n\tunion {\n\t\tSVGAMobId *mob_loc;\n\t\tSVGAGuestPtr *location;\n\t};\n};\n\n \nenum vmw_resource_relocation_type {\n\tvmw_res_rel_normal,\n\tvmw_res_rel_nop,\n\tvmw_res_rel_cond_nop,\n\tvmw_res_rel_max\n};\n\n \nstruct vmw_resource_relocation {\n\tstruct list_head head;\n\tconst struct vmw_resource *res;\n\tu32 offset:29;\n\tenum vmw_resource_relocation_type rel_type:3;\n};\n\n \nstruct vmw_ctx_validation_info {\n\tstruct list_head head;\n\tstruct vmw_resource *ctx;\n\tstruct vmw_ctx_binding_state *cur;\n\tstruct vmw_ctx_binding_state *staged;\n};\n\n \nstruct vmw_cmd_entry {\n\tint (*func) (struct vmw_private *, struct vmw_sw_context *,\n\t\t     SVGA3dCmdHeader *);\n\tbool user_allow;\n\tbool gb_disable;\n\tbool gb_enable;\n\tconst char *cmd_name;\n};\n\n#define VMW_CMD_DEF(_cmd, _func, _user_allow, _gb_disable, _gb_enable)\t\\\n\t[(_cmd) - SVGA_3D_CMD_BASE] = {(_func), (_user_allow),\\\n\t\t\t\t       (_gb_disable), (_gb_enable), #_cmd}\n\nstatic int vmw_resource_context_res_add(struct vmw_private *dev_priv,\n\t\t\t\t\tstruct vmw_sw_context *sw_context,\n\t\t\t\t\tstruct vmw_resource *ctx);\nstatic int vmw_translate_mob_ptr(struct vmw_private *dev_priv,\n\t\t\t\t struct vmw_sw_context *sw_context,\n\t\t\t\t SVGAMobId *id,\n\t\t\t\t struct vmw_bo **vmw_bo_p);\n \nstatic size_t vmw_ptr_diff(void *a, void *b)\n{\n\treturn (unsigned long) b - (unsigned long) a;\n}\n\n \nstatic void vmw_execbuf_bindings_commit(struct vmw_sw_context *sw_context,\n\t\t\t\t\tbool backoff)\n{\n\tstruct vmw_ctx_validation_info *entry;\n\n\tlist_for_each_entry(entry, &sw_context->ctx_list, head) {\n\t\tif (!backoff)\n\t\t\tvmw_binding_state_commit(entry->cur, entry->staged);\n\n\t\tif (entry->staged != sw_context->staged_bindings)\n\t\t\tvmw_binding_state_free(entry->staged);\n\t\telse\n\t\t\tsw_context->staged_bindings_inuse = false;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&sw_context->ctx_list);\n}\n\n \nstatic void vmw_bind_dx_query_mob(struct vmw_sw_context *sw_context)\n{\n\tif (sw_context->dx_query_mob)\n\t\tvmw_context_bind_dx_query(sw_context->dx_query_ctx,\n\t\t\t\t\t  sw_context->dx_query_mob);\n}\n\n \nstatic int vmw_cmd_ctx_first_setup(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t   struct vmw_resource *res,\n\t\t\t\t   struct vmw_ctx_validation_info *node)\n{\n\tint ret;\n\n\tret = vmw_resource_context_res_add(dev_priv, sw_context, res);\n\tif (unlikely(ret != 0))\n\t\tgoto out_err;\n\n\tif (!sw_context->staged_bindings) {\n\t\tsw_context->staged_bindings = vmw_binding_state_alloc(dev_priv);\n\t\tif (IS_ERR(sw_context->staged_bindings)) {\n\t\t\tret = PTR_ERR(sw_context->staged_bindings);\n\t\t\tsw_context->staged_bindings = NULL;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (sw_context->staged_bindings_inuse) {\n\t\tnode->staged = vmw_binding_state_alloc(dev_priv);\n\t\tif (IS_ERR(node->staged)) {\n\t\t\tret = PTR_ERR(node->staged);\n\t\t\tnode->staged = NULL;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tnode->staged = sw_context->staged_bindings;\n\t\tsw_context->staged_bindings_inuse = true;\n\t}\n\n\tnode->ctx = res;\n\tnode->cur = vmw_context_binding_state(res);\n\tlist_add_tail(&node->head, &sw_context->ctx_list);\n\n\treturn 0;\n\nout_err:\n\treturn ret;\n}\n\n \nstatic unsigned int vmw_execbuf_res_size(struct vmw_private *dev_priv,\n\t\t\t\t\t enum vmw_res_type res_type)\n{\n\treturn (res_type == vmw_res_dx_context ||\n\t\t(res_type == vmw_res_context && dev_priv->has_mob)) ?\n\t\tsizeof(struct vmw_ctx_validation_info) : 0;\n}\n\n \nstatic void vmw_execbuf_rcache_update(struct vmw_res_cache_entry *rcache,\n\t\t\t\t      struct vmw_resource *res,\n\t\t\t\t      void *private)\n{\n\trcache->res = res;\n\trcache->private = private;\n\trcache->valid = 1;\n\trcache->valid_handle = 0;\n}\n\nenum vmw_val_add_flags {\n\tvmw_val_add_flag_none  =      0,\n\tvmw_val_add_flag_noctx = 1 << 0,\n};\n\n \nstatic int vmw_execbuf_res_val_add(struct vmw_sw_context *sw_context,\n\t\t\t\t   struct vmw_resource *res,\n\t\t\t\t   u32 dirty,\n\t\t\t\t   u32 flags)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tint ret;\n\tenum vmw_res_type res_type = vmw_res_type(res);\n\tstruct vmw_res_cache_entry *rcache;\n\tstruct vmw_ctx_validation_info *ctx_info;\n\tbool first_usage;\n\tunsigned int priv_size;\n\n\trcache = &sw_context->res_cache[res_type];\n\tif (likely(rcache->valid && rcache->res == res)) {\n\t\tif (dirty)\n\t\t\tvmw_validation_res_set_dirty(sw_context->ctx,\n\t\t\t\t\t\t     rcache->private, dirty);\n\t\treturn 0;\n\t}\n\n\tif ((flags & vmw_val_add_flag_noctx) != 0) {\n\t\tret = vmw_validation_add_resource(sw_context->ctx, res, 0, dirty,\n\t\t\t\t\t\t  (void **)&ctx_info, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t} else {\n\t\tpriv_size = vmw_execbuf_res_size(dev_priv, res_type);\n\t\tret = vmw_validation_add_resource(sw_context->ctx, res, priv_size,\n\t\t\t\t\t\t  dirty, (void **)&ctx_info,\n\t\t\t\t\t\t  &first_usage);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (priv_size && first_usage) {\n\t\t\tret = vmw_cmd_ctx_first_setup(dev_priv, sw_context, res,\n\t\t\t\t\t\t      ctx_info);\n\t\t\tif (ret) {\n\t\t\t\tVMW_DEBUG_USER(\"Failed first usage context setup.\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tvmw_execbuf_rcache_update(rcache, res, ctx_info);\n\treturn 0;\n}\n\n \nstatic int vmw_view_res_val_add(struct vmw_sw_context *sw_context,\n\t\t\t\tstruct vmw_resource *view)\n{\n\tint ret;\n\n\t \n\tret = vmw_execbuf_res_val_add(sw_context, vmw_view_srf(view),\n\t\t\t\t      vmw_view_dirtying(view), vmw_val_add_flag_noctx);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vmw_execbuf_res_val_add(sw_context, view, VMW_RES_DIRTY_NONE,\n\t\t\t\t       vmw_val_add_flag_noctx);\n}\n\n \nstatic struct vmw_resource *\nvmw_view_id_val_add(struct vmw_sw_context *sw_context,\n\t\t    enum vmw_view_type view_type, u32 id)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = sw_context->dx_ctx_node;\n\tstruct vmw_resource *view;\n\tint ret;\n\n\tif (!ctx_node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tview = vmw_view_lookup(sw_context->man, view_type, id);\n\tif (IS_ERR(view))\n\t\treturn view;\n\n\tret = vmw_view_res_val_add(sw_context, view);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn view;\n}\n\n \nstatic int vmw_resource_context_res_add(struct vmw_private *dev_priv,\n\t\t\t\t\tstruct vmw_sw_context *sw_context,\n\t\t\t\t\tstruct vmw_resource *ctx)\n{\n\tstruct list_head *binding_list;\n\tstruct vmw_ctx_bindinfo *entry;\n\tint ret = 0;\n\tstruct vmw_resource *res;\n\tu32 i;\n\tu32 cotable_max = has_sm5_context(ctx->dev_priv) ?\n\t\tSVGA_COTABLE_MAX : SVGA_COTABLE_DX10_MAX;\n\n\t \n\tif (has_sm4_context(dev_priv) &&\n\t    vmw_res_type(ctx) == vmw_res_dx_context) {\n\t\tfor (i = 0; i < cotable_max; ++i) {\n\t\t\tres = vmw_context_cotable(ctx, i);\n\t\t\tif (IS_ERR(res))\n\t\t\t\tcontinue;\n\n\t\t\tret = vmw_execbuf_res_val_add(sw_context, res,\n\t\t\t\t\t\t      VMW_RES_DIRTY_SET,\n\t\t\t\t\t\t      vmw_val_add_flag_noctx);\n\t\t\tif (unlikely(ret != 0))\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tmutex_lock(&dev_priv->binding_mutex);\n\tbinding_list = vmw_context_binding_list(ctx);\n\n\tlist_for_each_entry(entry, binding_list, ctx_list) {\n\t\tif (vmw_res_type(entry->res) == vmw_res_view)\n\t\t\tret = vmw_view_res_val_add(sw_context, entry->res);\n\t\telse\n\t\t\tret = vmw_execbuf_res_val_add(sw_context, entry->res,\n\t\t\t\t\t\t      vmw_binding_dirtying(entry->bt),\n\t\t\t\t\t\t      vmw_val_add_flag_noctx);\n\t\tif (unlikely(ret != 0))\n\t\t\tbreak;\n\t}\n\n\tif (has_sm4_context(dev_priv) &&\n\t    vmw_res_type(ctx) == vmw_res_dx_context) {\n\t\tstruct vmw_bo *dx_query_mob;\n\n\t\tdx_query_mob = vmw_context_get_dx_query_mob(ctx);\n\t\tif (dx_query_mob) {\n\t\t\tvmw_bo_placement_set(dx_query_mob,\n\t\t\t\t\t     VMW_BO_DOMAIN_MOB,\n\t\t\t\t\t     VMW_BO_DOMAIN_MOB);\n\t\t\tret = vmw_validation_add_bo(sw_context->ctx,\n\t\t\t\t\t\t    dx_query_mob);\n\t\t}\n\t}\n\n\tmutex_unlock(&dev_priv->binding_mutex);\n\treturn ret;\n}\n\n \nstatic int vmw_resource_relocation_add(struct vmw_sw_context *sw_context,\n\t\t\t\t       const struct vmw_resource *res,\n\t\t\t\t       unsigned long offset,\n\t\t\t\t       enum vmw_resource_relocation_type\n\t\t\t\t       rel_type)\n{\n\tstruct vmw_resource_relocation *rel;\n\n\trel = vmw_validation_mem_alloc(sw_context->ctx, sizeof(*rel));\n\tif (unlikely(!rel)) {\n\t\tVMW_DEBUG_USER(\"Failed to allocate a resource relocation.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trel->res = res;\n\trel->offset = offset;\n\trel->rel_type = rel_type;\n\tlist_add_tail(&rel->head, &sw_context->res_relocations);\n\n\treturn 0;\n}\n\n \nstatic void vmw_resource_relocations_free(struct list_head *list)\n{\n\t \n\tINIT_LIST_HEAD(list);\n}\n\n \nstatic void vmw_resource_relocations_apply(uint32_t *cb,\n\t\t\t\t\t   struct list_head *list)\n{\n\tstruct vmw_resource_relocation *rel;\n\n\t \n\tBUILD_BUG_ON(SVGA_CB_MAX_SIZE >= (1 << 29));\n\tBUILD_BUG_ON(vmw_res_rel_max >= (1 << 3));\n\n\tlist_for_each_entry(rel, list, head) {\n\t\tu32 *addr = (u32 *)((unsigned long) cb + rel->offset);\n\t\tswitch (rel->rel_type) {\n\t\tcase vmw_res_rel_normal:\n\t\t\t*addr = rel->res->id;\n\t\t\tbreak;\n\t\tcase vmw_res_rel_nop:\n\t\t\t*addr = SVGA_3D_CMD_NOP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (rel->res->id == -1)\n\t\t\t\t*addr = SVGA_3D_CMD_NOP;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int vmw_cmd_invalid(struct vmw_private *dev_priv,\n\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t   SVGA3dCmdHeader *header)\n{\n\treturn -EINVAL;\n}\n\nstatic int vmw_cmd_ok(struct vmw_private *dev_priv,\n\t\t      struct vmw_sw_context *sw_context,\n\t\t      SVGA3dCmdHeader *header)\n{\n\treturn 0;\n}\n\n \nstatic int vmw_resources_reserve(struct vmw_sw_context *sw_context)\n{\n\tint ret;\n\n\tret = vmw_validation_res_reserve(sw_context->ctx, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sw_context->dx_query_mob) {\n\t\tstruct vmw_bo *expected_dx_query_mob;\n\n\t\texpected_dx_query_mob =\n\t\t\tvmw_context_get_dx_query_mob(sw_context->dx_query_ctx);\n\t\tif (expected_dx_query_mob &&\n\t\t    expected_dx_query_mob != sw_context->dx_query_mob) {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nvmw_cmd_res_check(struct vmw_private *dev_priv,\n\t\t  struct vmw_sw_context *sw_context,\n\t\t  enum vmw_res_type res_type,\n\t\t  u32 dirty,\n\t\t  const struct vmw_user_resource_conv *converter,\n\t\t  uint32_t *id_loc,\n\t\t  struct vmw_resource **p_res)\n{\n\tstruct vmw_res_cache_entry *rcache = &sw_context->res_cache[res_type];\n\tstruct vmw_resource *res;\n\tint ret = 0;\n\tbool needs_unref = false;\n\n\tif (p_res)\n\t\t*p_res = NULL;\n\n\tif (*id_loc == SVGA3D_INVALID_ID) {\n\t\tif (res_type == vmw_res_context) {\n\t\t\tVMW_DEBUG_USER(\"Illegal context invalid id.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (likely(rcache->valid_handle && *id_loc == rcache->handle)) {\n\t\tres = rcache->res;\n\t\tif (dirty)\n\t\t\tvmw_validation_res_set_dirty(sw_context->ctx,\n\t\t\t\t\t\t     rcache->private, dirty);\n\t} else {\n\t\tunsigned int size = vmw_execbuf_res_size(dev_priv, res_type);\n\n\t\tret = vmw_validation_preload_res(sw_context->ctx, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vmw_user_resource_lookup_handle\n\t\t\t(dev_priv, sw_context->fp->tfile, *id_loc, converter, &res);\n\t\tif (ret != 0) {\n\t\t\tVMW_DEBUG_USER(\"Could not find/use resource 0x%08x.\\n\",\n\t\t\t\t       (unsigned int) *id_loc);\n\t\t\treturn ret;\n\t\t}\n\t\tneeds_unref = true;\n\n\t\tret = vmw_execbuf_res_val_add(sw_context, res, dirty, vmw_val_add_flag_none);\n\t\tif (unlikely(ret != 0))\n\t\t\tgoto res_check_done;\n\n\t\tif (rcache->valid && rcache->res == res) {\n\t\t\trcache->valid_handle = true;\n\t\t\trcache->handle = *id_loc;\n\t\t}\n\t}\n\n\tret = vmw_resource_relocation_add(sw_context, res,\n\t\t\t\t\t  vmw_ptr_diff(sw_context->buf_start,\n\t\t\t\t\t\t       id_loc),\n\t\t\t\t\t  vmw_res_rel_normal);\n\tif (p_res)\n\t\t*p_res = res;\n\nres_check_done:\n\tif (needs_unref)\n\t\tvmw_resource_unreference(&res);\n\n\treturn ret;\n}\n\n \nstatic int vmw_rebind_all_dx_query(struct vmw_resource *ctx_res)\n{\n\tstruct vmw_private *dev_priv = ctx_res->dev_priv;\n\tstruct vmw_bo *dx_query_mob;\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXBindAllQuery);\n\n\tdx_query_mob = vmw_context_get_dx_query_mob(ctx_res);\n\n\tif (!dx_query_mob || dx_query_mob->dx_query_ctx)\n\t\treturn 0;\n\n\tcmd = VMW_CMD_CTX_RESERVE(dev_priv, sizeof(*cmd), ctx_res->id);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_DX_BIND_ALL_QUERY;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = ctx_res->id;\n\tcmd->body.mobid = dx_query_mob->tbo.resource->start;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\tvmw_context_bind_dx_query(ctx_res, dx_query_mob);\n\n\treturn 0;\n}\n\n \nstatic int vmw_rebind_contexts(struct vmw_sw_context *sw_context)\n{\n\tstruct vmw_ctx_validation_info *val;\n\tint ret;\n\n\tlist_for_each_entry(val, &sw_context->ctx_list, head) {\n\t\tret = vmw_binding_rebind_all(val->cur);\n\t\tif (unlikely(ret != 0)) {\n\t\t\tif (ret != -ERESTARTSYS)\n\t\t\t\tVMW_DEBUG_USER(\"Failed to rebind context.\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = vmw_rebind_all_dx_query(val->ctx);\n\t\tif (ret != 0) {\n\t\t\tVMW_DEBUG_USER(\"Failed to rebind queries.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vmw_view_bindings_add(struct vmw_sw_context *sw_context,\n\t\t\t\t enum vmw_view_type view_type,\n\t\t\t\t enum vmw_ctx_binding_type binding_type,\n\t\t\t\t uint32 shader_slot,\n\t\t\t\t uint32 view_ids[], u32 num_views,\n\t\t\t\t u32 first_slot)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tu32 i;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_views; ++i) {\n\t\tstruct vmw_ctx_bindinfo_view binding;\n\t\tstruct vmw_resource *view = NULL;\n\n\t\tif (view_ids[i] != SVGA3D_INVALID_ID) {\n\t\t\tview = vmw_view_id_val_add(sw_context, view_type,\n\t\t\t\t\t\t   view_ids[i]);\n\t\t\tif (IS_ERR(view)) {\n\t\t\t\tVMW_DEBUG_USER(\"View not found.\\n\");\n\t\t\t\treturn PTR_ERR(view);\n\t\t\t}\n\t\t}\n\t\tbinding.bi.ctx = ctx_node->ctx;\n\t\tbinding.bi.res = view;\n\t\tbinding.bi.bt = binding_type;\n\t\tbinding.shader_slot = shader_slot;\n\t\tbinding.slot = first_slot + i;\n\t\tvmw_binding_add(ctx_node->staged, &binding.bi,\n\t\t\t\tshader_slot, binding.slot);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_cid_check(struct vmw_private *dev_priv,\n\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t     SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, uint32_t) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\t VMW_RES_DIRTY_SET, user_context_converter,\n\t\t\t\t &cmd->body, NULL);\n}\n\n \nstatic struct vmw_ctx_validation_info *\nvmw_execbuf_info_from_res(struct vmw_sw_context *sw_context,\n\t\t\t  struct vmw_resource *res)\n{\n\tstruct vmw_res_cache_entry *rcache =\n\t\t&sw_context->res_cache[vmw_res_type(res)];\n\n\tif (rcache->valid && rcache->res == res)\n\t\treturn rcache->private;\n\n\tWARN_ON_ONCE(true);\n\treturn NULL;\n}\n\nstatic int vmw_cmd_set_render_target_check(struct vmw_private *dev_priv,\n\t\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t\t   SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdSetRenderTarget);\n\tstruct vmw_resource *ctx;\n\tstruct vmw_resource *res;\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\n\tif (cmd->body.type >= SVGA3D_RT_MAX) {\n\t\tVMW_DEBUG_USER(\"Illegal render target type %u.\\n\",\n\t\t\t       (unsigned int) cmd->body.type);\n\t\treturn -EINVAL;\n\t}\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\tVMW_RES_DIRTY_SET, user_context_converter,\n\t\t\t\t&cmd->body.cid, &ctx);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\tVMW_RES_DIRTY_SET, user_surface_converter,\n\t\t\t\t&cmd->body.target.sid, &res);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (dev_priv->has_mob) {\n\t\tstruct vmw_ctx_bindinfo_view binding;\n\t\tstruct vmw_ctx_validation_info *node;\n\n\t\tnode = vmw_execbuf_info_from_res(sw_context, ctx);\n\t\tif (!node)\n\t\t\treturn -EINVAL;\n\n\t\tbinding.bi.ctx = ctx;\n\t\tbinding.bi.res = res;\n\t\tbinding.bi.bt = vmw_ctx_binding_rt;\n\t\tbinding.slot = cmd->body.type;\n\t\tvmw_binding_add(node->staged, &binding.bi, 0, binding.slot);\n\t}\n\n\treturn 0;\n}\n\nstatic int vmw_cmd_surface_copy_check(struct vmw_private *dev_priv,\n\t\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t\t      SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdSurfaceCopy);\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\tVMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t&cmd->body.src.sid, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_SET, user_surface_converter,\n\t\t\t\t &cmd->body.dest.sid, NULL);\n}\n\nstatic int vmw_cmd_buffer_copy_check(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t\t     SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXBufferCopy);\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\tVMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t&cmd->body.src, NULL);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_SET, user_surface_converter,\n\t\t\t\t &cmd->body.dest, NULL);\n}\n\nstatic int vmw_cmd_pred_copy_check(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t   SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXPredCopyRegion);\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\tVMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t&cmd->body.srcSid, NULL);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_SET, user_surface_converter,\n\t\t\t\t &cmd->body.dstSid, NULL);\n}\n\nstatic int vmw_cmd_stretch_blt_check(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t\t     SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdSurfaceStretchBlt);\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\tVMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t&cmd->body.src.sid, NULL);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_SET, user_surface_converter,\n\t\t\t\t &cmd->body.dest.sid, NULL);\n}\n\nstatic int vmw_cmd_blt_surf_screen_check(struct vmw_private *dev_priv,\n\t\t\t\t\t struct vmw_sw_context *sw_context,\n\t\t\t\t\t SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdBlitSurfaceToScreen) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t &cmd->body.srcImage.sid, NULL);\n}\n\nstatic int vmw_cmd_present_check(struct vmw_private *dev_priv,\n\t\t\t\t struct vmw_sw_context *sw_context,\n\t\t\t\t SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdPresent) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t &cmd->body.sid, NULL);\n}\n\n \nstatic int vmw_query_bo_switch_prepare(struct vmw_private *dev_priv,\n\t\t\t\t       struct vmw_bo *new_query_bo,\n\t\t\t\t       struct vmw_sw_context *sw_context)\n{\n\tstruct vmw_res_cache_entry *ctx_entry =\n\t\t&sw_context->res_cache[vmw_res_context];\n\tint ret;\n\n\tBUG_ON(!ctx_entry->valid);\n\tsw_context->last_query_ctx = ctx_entry->res;\n\n\tif (unlikely(new_query_bo != sw_context->cur_query_bo)) {\n\n\t\tif (unlikely(PFN_UP(new_query_bo->tbo.resource->size) > 4)) {\n\t\t\tVMW_DEBUG_USER(\"Query buffer too large.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (unlikely(sw_context->cur_query_bo != NULL)) {\n\t\t\tsw_context->needs_post_query_barrier = true;\n\t\t\tvmw_bo_placement_set_default_accelerated(sw_context->cur_query_bo);\n\t\t\tret = vmw_validation_add_bo(sw_context->ctx,\n\t\t\t\t\t\t    sw_context->cur_query_bo);\n\t\t\tif (unlikely(ret != 0))\n\t\t\t\treturn ret;\n\t\t}\n\t\tsw_context->cur_query_bo = new_query_bo;\n\n\t\tvmw_bo_placement_set_default_accelerated(dev_priv->dummy_query_bo);\n\t\tret = vmw_validation_add_bo(sw_context->ctx,\n\t\t\t\t\t    dev_priv->dummy_query_bo);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void vmw_query_bo_switch_commit(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_sw_context *sw_context)\n{\n\t \n\tif (sw_context->needs_post_query_barrier) {\n\t\tstruct vmw_res_cache_entry *ctx_entry =\n\t\t\t&sw_context->res_cache[vmw_res_context];\n\t\tstruct vmw_resource *ctx;\n\t\tint ret;\n\n\t\tBUG_ON(!ctx_entry->valid);\n\t\tctx = ctx_entry->res;\n\n\t\tret = vmw_cmd_emit_dummy_query(dev_priv, ctx->id);\n\n\t\tif (unlikely(ret != 0))\n\t\t\tVMW_DEBUG_USER(\"Out of fifo space for dummy query.\\n\");\n\t}\n\n\tif (dev_priv->pinned_bo != sw_context->cur_query_bo) {\n\t\tif (dev_priv->pinned_bo) {\n\t\t\tvmw_bo_pin_reserved(dev_priv->pinned_bo, false);\n\t\t\tvmw_bo_unreference(&dev_priv->pinned_bo);\n\t\t}\n\n\t\tif (!sw_context->needs_post_query_barrier) {\n\t\t\tvmw_bo_pin_reserved(sw_context->cur_query_bo, true);\n\n\t\t\t \n\t\t\tif (!dev_priv->dummy_query_bo_pinned) {\n\t\t\t\tvmw_bo_pin_reserved(dev_priv->dummy_query_bo,\n\t\t\t\t\t\t    true);\n\t\t\t\tdev_priv->dummy_query_bo_pinned = true;\n\t\t\t}\n\n\t\t\tBUG_ON(sw_context->last_query_ctx == NULL);\n\t\t\tdev_priv->query_cid = sw_context->last_query_ctx->id;\n\t\t\tdev_priv->query_cid_valid = true;\n\t\t\tdev_priv->pinned_bo =\n\t\t\t\tvmw_bo_reference(sw_context->cur_query_bo);\n\t\t}\n\t}\n}\n\n \nstatic int vmw_translate_mob_ptr(struct vmw_private *dev_priv,\n\t\t\t\t struct vmw_sw_context *sw_context,\n\t\t\t\t SVGAMobId *id,\n\t\t\t\t struct vmw_bo **vmw_bo_p)\n{\n\tstruct vmw_bo *vmw_bo, *tmp_bo;\n\tuint32_t handle = *id;\n\tstruct vmw_relocation *reloc;\n\tint ret;\n\n\tvmw_validation_preload_bo(sw_context->ctx);\n\tret = vmw_user_bo_lookup(sw_context->filp, handle, &vmw_bo);\n\tif (ret != 0) {\n\t\tdrm_dbg(&dev_priv->drm, \"Could not find or use MOB buffer.\\n\");\n\t\treturn PTR_ERR(vmw_bo);\n\t}\n\tvmw_bo_placement_set(vmw_bo, VMW_BO_DOMAIN_MOB, VMW_BO_DOMAIN_MOB);\n\tret = vmw_validation_add_bo(sw_context->ctx, vmw_bo);\n\ttmp_bo = vmw_bo;\n\tvmw_user_bo_unref(&tmp_bo);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\treloc = vmw_validation_mem_alloc(sw_context->ctx, sizeof(*reloc));\n\tif (!reloc)\n\t\treturn -ENOMEM;\n\n\treloc->mob_loc = id;\n\treloc->vbo = vmw_bo;\n\n\t*vmw_bo_p = vmw_bo;\n\tlist_add_tail(&reloc->head, &sw_context->bo_relocations);\n\n\treturn 0;\n}\n\n \nstatic int vmw_translate_guest_ptr(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t   SVGAGuestPtr *ptr,\n\t\t\t\t   struct vmw_bo **vmw_bo_p)\n{\n\tstruct vmw_bo *vmw_bo, *tmp_bo;\n\tuint32_t handle = ptr->gmrId;\n\tstruct vmw_relocation *reloc;\n\tint ret;\n\n\tvmw_validation_preload_bo(sw_context->ctx);\n\tret = vmw_user_bo_lookup(sw_context->filp, handle, &vmw_bo);\n\tif (ret != 0) {\n\t\tdrm_dbg(&dev_priv->drm, \"Could not find or use GMR region.\\n\");\n\t\treturn PTR_ERR(vmw_bo);\n\t}\n\tvmw_bo_placement_set(vmw_bo, VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM,\n\t\t\t     VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM);\n\tret = vmw_validation_add_bo(sw_context->ctx, vmw_bo);\n\ttmp_bo = vmw_bo;\n\tvmw_user_bo_unref(&tmp_bo);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\treloc = vmw_validation_mem_alloc(sw_context->ctx, sizeof(*reloc));\n\tif (!reloc)\n\t\treturn -ENOMEM;\n\n\treloc->location = ptr;\n\treloc->vbo = vmw_bo;\n\t*vmw_bo_p = vmw_bo;\n\tlist_add_tail(&reloc->head, &sw_context->bo_relocations);\n\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_dx_define_query(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t   SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXDefineQuery);\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tstruct vmw_resource *cotable_res;\n\tint ret;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\n\tif (cmd->body.type <  SVGA3D_QUERYTYPE_MIN ||\n\t    cmd->body.type >= SVGA3D_QUERYTYPE_MAX)\n\t\treturn -EINVAL;\n\n\tcotable_res = vmw_context_cotable(ctx_node->ctx, SVGA_COTABLE_DXQUERY);\n\tret = vmw_cotable_notify(cotable_res, cmd->body.queryId);\n\n\treturn ret;\n}\n\n \nstatic int vmw_cmd_dx_bind_query(struct vmw_private *dev_priv,\n\t\t\t\t struct vmw_sw_context *sw_context,\n\t\t\t\t SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXBindQuery);\n\tstruct vmw_bo *vmw_bo;\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\n\t \n\tret = vmw_translate_mob_ptr(dev_priv, sw_context, &cmd->body.mobid,\n\t\t\t\t    &vmw_bo);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tsw_context->dx_query_mob = vmw_bo;\n\tsw_context->dx_query_ctx = sw_context->dx_ctx_node->ctx;\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_begin_gb_query(struct vmw_private *dev_priv,\n\t\t\t\t  struct vmw_sw_context *sw_context,\n\t\t\t\t  SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdBeginGBQuery) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\t VMW_RES_DIRTY_SET, user_context_converter,\n\t\t\t\t &cmd->body.cid, NULL);\n}\n\n \nstatic int vmw_cmd_begin_query(struct vmw_private *dev_priv,\n\t\t\t       struct vmw_sw_context *sw_context,\n\t\t\t       SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdBeginQuery) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\tif (unlikely(dev_priv->has_mob)) {\n\t\tVMW_DECLARE_CMD_VAR(gb_cmd, SVGA3dCmdBeginGBQuery);\n\n\t\tBUG_ON(sizeof(gb_cmd) != sizeof(*cmd));\n\n\t\tgb_cmd.header.id = SVGA_3D_CMD_BEGIN_GB_QUERY;\n\t\tgb_cmd.header.size = cmd->header.size;\n\t\tgb_cmd.body.cid = cmd->body.cid;\n\t\tgb_cmd.body.type = cmd->body.type;\n\n\t\tmemcpy(cmd, &gb_cmd, sizeof(*cmd));\n\t\treturn vmw_cmd_begin_gb_query(dev_priv, sw_context, header);\n\t}\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\t VMW_RES_DIRTY_SET, user_context_converter,\n\t\t\t\t &cmd->body.cid, NULL);\n}\n\n \nstatic int vmw_cmd_end_gb_query(struct vmw_private *dev_priv,\n\t\t\t\tstruct vmw_sw_context *sw_context,\n\t\t\t\tSVGA3dCmdHeader *header)\n{\n\tstruct vmw_bo *vmw_bo;\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdEndGBQuery);\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tret = vmw_cmd_cid_check(dev_priv, sw_context, header);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tret = vmw_translate_mob_ptr(dev_priv, sw_context, &cmd->body.mobid,\n\t\t\t\t    &vmw_bo);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tret = vmw_query_bo_switch_prepare(dev_priv, vmw_bo, sw_context);\n\n\treturn ret;\n}\n\n \nstatic int vmw_cmd_end_query(struct vmw_private *dev_priv,\n\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t     SVGA3dCmdHeader *header)\n{\n\tstruct vmw_bo *vmw_bo;\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdEndQuery);\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tif (dev_priv->has_mob) {\n\t\tVMW_DECLARE_CMD_VAR(gb_cmd, SVGA3dCmdEndGBQuery);\n\n\t\tBUG_ON(sizeof(gb_cmd) != sizeof(*cmd));\n\n\t\tgb_cmd.header.id = SVGA_3D_CMD_END_GB_QUERY;\n\t\tgb_cmd.header.size = cmd->header.size;\n\t\tgb_cmd.body.cid = cmd->body.cid;\n\t\tgb_cmd.body.type = cmd->body.type;\n\t\tgb_cmd.body.mobid = cmd->body.guestResult.gmrId;\n\t\tgb_cmd.body.offset = cmd->body.guestResult.offset;\n\n\t\tmemcpy(cmd, &gb_cmd, sizeof(*cmd));\n\t\treturn vmw_cmd_end_gb_query(dev_priv, sw_context, header);\n\t}\n\n\tret = vmw_cmd_cid_check(dev_priv, sw_context, header);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tret = vmw_translate_guest_ptr(dev_priv, sw_context,\n\t\t\t\t      &cmd->body.guestResult, &vmw_bo);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tret = vmw_query_bo_switch_prepare(dev_priv, vmw_bo, sw_context);\n\n\treturn ret;\n}\n\n \nstatic int vmw_cmd_wait_gb_query(struct vmw_private *dev_priv,\n\t\t\t\t struct vmw_sw_context *sw_context,\n\t\t\t\t SVGA3dCmdHeader *header)\n{\n\tstruct vmw_bo *vmw_bo;\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdWaitForGBQuery);\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tret = vmw_cmd_cid_check(dev_priv, sw_context, header);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tret = vmw_translate_mob_ptr(dev_priv, sw_context, &cmd->body.mobid,\n\t\t\t\t    &vmw_bo);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_wait_query(struct vmw_private *dev_priv,\n\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t      SVGA3dCmdHeader *header)\n{\n\tstruct vmw_bo *vmw_bo;\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdWaitForQuery);\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tif (dev_priv->has_mob) {\n\t\tVMW_DECLARE_CMD_VAR(gb_cmd, SVGA3dCmdWaitForGBQuery);\n\n\t\tBUG_ON(sizeof(gb_cmd) != sizeof(*cmd));\n\n\t\tgb_cmd.header.id = SVGA_3D_CMD_WAIT_FOR_GB_QUERY;\n\t\tgb_cmd.header.size = cmd->header.size;\n\t\tgb_cmd.body.cid = cmd->body.cid;\n\t\tgb_cmd.body.type = cmd->body.type;\n\t\tgb_cmd.body.mobid = cmd->body.guestResult.gmrId;\n\t\tgb_cmd.body.offset = cmd->body.guestResult.offset;\n\n\t\tmemcpy(cmd, &gb_cmd, sizeof(*cmd));\n\t\treturn vmw_cmd_wait_gb_query(dev_priv, sw_context, header);\n\t}\n\n\tret = vmw_cmd_cid_check(dev_priv, sw_context, header);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tret = vmw_translate_guest_ptr(dev_priv, sw_context,\n\t\t\t\t      &cmd->body.guestResult, &vmw_bo);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int vmw_cmd_dma(struct vmw_private *dev_priv,\n\t\t       struct vmw_sw_context *sw_context,\n\t\t       SVGA3dCmdHeader *header)\n{\n\tstruct vmw_bo *vmw_bo = NULL;\n\tstruct vmw_surface *srf = NULL;\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdSurfaceDMA);\n\tint ret;\n\tSVGA3dCmdSurfaceDMASuffix *suffix;\n\tuint32_t bo_size;\n\tbool dirty;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tsuffix = (SVGA3dCmdSurfaceDMASuffix *)((unsigned long) &cmd->body +\n\t\t\t\t\t       header->size - sizeof(*suffix));\n\n\t \n\tif (unlikely(suffix->suffixSize != sizeof(*suffix))) {\n\t\tVMW_DEBUG_USER(\"Invalid DMA suffix size.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = vmw_translate_guest_ptr(dev_priv, sw_context,\n\t\t\t\t      &cmd->body.guest.ptr, &vmw_bo);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\t \n\tbo_size = vmw_bo->tbo.base.size;\n\tif (unlikely(cmd->body.guest.ptr.offset > bo_size)) {\n\t\tVMW_DEBUG_USER(\"Invalid DMA offset.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbo_size -= cmd->body.guest.ptr.offset;\n\tif (unlikely(suffix->maximumOffset > bo_size))\n\t\tsuffix->maximumOffset = bo_size;\n\n\tdirty = (cmd->body.transfer == SVGA3D_WRITE_HOST_VRAM) ?\n\t\tVMW_RES_DIRTY_SET : 0;\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\tdirty, user_surface_converter,\n\t\t\t\t&cmd->body.host.sid, NULL);\n\tif (unlikely(ret != 0)) {\n\t\tif (unlikely(ret != -ERESTARTSYS))\n\t\t\tVMW_DEBUG_USER(\"could not find surface for DMA.\\n\");\n\t\treturn ret;\n\t}\n\n\tsrf = vmw_res_to_srf(sw_context->res_cache[vmw_res_surface].res);\n\n\tvmw_kms_cursor_snoop(srf, sw_context->fp->tfile, &vmw_bo->tbo, header);\n\n\treturn 0;\n}\n\nstatic int vmw_cmd_draw(struct vmw_private *dev_priv,\n\t\t\tstruct vmw_sw_context *sw_context,\n\t\t\tSVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDrawPrimitives);\n\tSVGA3dVertexDecl *decl = (SVGA3dVertexDecl *)(\n\t\t(unsigned long)header + sizeof(*cmd));\n\tSVGA3dPrimitiveRange *range;\n\tuint32_t i;\n\tuint32_t maxnum;\n\tint ret;\n\n\tret = vmw_cmd_cid_check(dev_priv, sw_context, header);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tmaxnum = (header->size - sizeof(cmd->body)) / sizeof(*decl);\n\n\tif (unlikely(cmd->body.numVertexDecls > maxnum)) {\n\t\tVMW_DEBUG_USER(\"Illegal number of vertex declarations.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < cmd->body.numVertexDecls; ++i, ++decl) {\n\t\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t\tVMW_RES_DIRTY_NONE,\n\t\t\t\t\tuser_surface_converter,\n\t\t\t\t\t&decl->array.surfaceId, NULL);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\t}\n\n\tmaxnum = (header->size - sizeof(cmd->body) -\n\t\t  cmd->body.numVertexDecls * sizeof(*decl)) / sizeof(*range);\n\tif (unlikely(cmd->body.numRanges > maxnum)) {\n\t\tVMW_DEBUG_USER(\"Illegal number of index ranges.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trange = (SVGA3dPrimitiveRange *) decl;\n\tfor (i = 0; i < cmd->body.numRanges; ++i, ++range) {\n\t\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t\tVMW_RES_DIRTY_NONE,\n\t\t\t\t\tuser_surface_converter,\n\t\t\t\t\t&range->indexArray.surfaceId, NULL);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int vmw_cmd_tex_state(struct vmw_private *dev_priv,\n\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t     SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdSetTextureState);\n\tSVGA3dTextureState *last_state = (SVGA3dTextureState *)\n\t  ((unsigned long) header + header->size + sizeof(*header));\n\tSVGA3dTextureState *cur_state = (SVGA3dTextureState *)\n\t\t((unsigned long) header + sizeof(*cmd));\n\tstruct vmw_resource *ctx;\n\tstruct vmw_resource *res;\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\tVMW_RES_DIRTY_SET, user_context_converter,\n\t\t\t\t&cmd->body.cid, &ctx);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tfor (; cur_state < last_state; ++cur_state) {\n\t\tif (likely(cur_state->name != SVGA3D_TS_BIND_TEXTURE))\n\t\t\tcontinue;\n\n\t\tif (cur_state->stage >= SVGA3D_NUM_TEXTURE_UNITS) {\n\t\t\tVMW_DEBUG_USER(\"Illegal texture/sampler unit %u.\\n\",\n\t\t\t\t       (unsigned int) cur_state->stage);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t\tVMW_RES_DIRTY_NONE,\n\t\t\t\t\tuser_surface_converter,\n\t\t\t\t\t&cur_state->value, &res);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\n\t\tif (dev_priv->has_mob) {\n\t\t\tstruct vmw_ctx_bindinfo_tex binding;\n\t\t\tstruct vmw_ctx_validation_info *node;\n\n\t\t\tnode = vmw_execbuf_info_from_res(sw_context, ctx);\n\t\t\tif (!node)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tbinding.bi.ctx = ctx;\n\t\t\tbinding.bi.res = res;\n\t\t\tbinding.bi.bt = vmw_ctx_binding_tex;\n\t\t\tbinding.texture_stage = cur_state->stage;\n\t\t\tvmw_binding_add(node->staged, &binding.bi, 0,\n\t\t\t\t\tbinding.texture_stage);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vmw_cmd_check_define_gmrfb(struct vmw_private *dev_priv,\n\t\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t\t      void *buf)\n{\n\tstruct vmw_bo *vmw_bo;\n\n\tstruct {\n\t\tuint32_t header;\n\t\tSVGAFifoCmdDefineGMRFB body;\n\t} *cmd = buf;\n\n\treturn vmw_translate_guest_ptr(dev_priv, sw_context, &cmd->body.ptr,\n\t\t\t\t       &vmw_bo);\n}\n\n \nstatic int vmw_cmd_res_switch_backup(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t\t     struct vmw_resource *res, uint32_t *buf_id,\n\t\t\t\t     unsigned long backup_offset)\n{\n\tstruct vmw_bo *vbo;\n\tvoid *info;\n\tint ret;\n\n\tinfo = vmw_execbuf_info_from_res(sw_context, res);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tret = vmw_translate_mob_ptr(dev_priv, sw_context, buf_id, &vbo);\n\tif (ret)\n\t\treturn ret;\n\n\tvmw_validation_res_switch_backup(sw_context->ctx, info, vbo,\n\t\t\t\t\t backup_offset);\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_switch_backup(struct vmw_private *dev_priv,\n\t\t\t\t struct vmw_sw_context *sw_context,\n\t\t\t\t enum vmw_res_type res_type,\n\t\t\t\t const struct vmw_user_resource_conv\n\t\t\t\t *converter, uint32_t *res_id, uint32_t *buf_id,\n\t\t\t\t unsigned long backup_offset)\n{\n\tstruct vmw_resource *res;\n\tint ret;\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, res_type,\n\t\t\t\tVMW_RES_DIRTY_NONE, converter, res_id, &res);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vmw_cmd_res_switch_backup(dev_priv, sw_context, res, buf_id,\n\t\t\t\t\t backup_offset);\n}\n\n \nstatic int vmw_cmd_bind_gb_surface(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t   SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdBindGBSurface) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_switch_backup(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t     user_surface_converter, &cmd->body.sid,\n\t\t\t\t     &cmd->body.mobid, 0);\n}\n\n \nstatic int vmw_cmd_update_gb_image(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t   SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdUpdateGBImage) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t &cmd->body.image.sid, NULL);\n}\n\n \nstatic int vmw_cmd_update_gb_surface(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t\t     SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdUpdateGBSurface) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_CLEAR, user_surface_converter,\n\t\t\t\t &cmd->body.sid, NULL);\n}\n\n \nstatic int vmw_cmd_readback_gb_image(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t\t     SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdReadbackGBImage) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t &cmd->body.image.sid, NULL);\n}\n\n \nstatic int vmw_cmd_readback_gb_surface(struct vmw_private *dev_priv,\n\t\t\t\t       struct vmw_sw_context *sw_context,\n\t\t\t\t       SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdReadbackGBSurface) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_CLEAR, user_surface_converter,\n\t\t\t\t &cmd->body.sid, NULL);\n}\n\n \nstatic int vmw_cmd_invalidate_gb_image(struct vmw_private *dev_priv,\n\t\t\t\t       struct vmw_sw_context *sw_context,\n\t\t\t\t       SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdInvalidateGBImage) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t &cmd->body.image.sid, NULL);\n}\n\n \nstatic int vmw_cmd_invalidate_gb_surface(struct vmw_private *dev_priv,\n\t\t\t\t\t struct vmw_sw_context *sw_context,\n\t\t\t\t\t SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdInvalidateGBSurface) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_CLEAR, user_surface_converter,\n\t\t\t\t &cmd->body.sid, NULL);\n}\n\n \nstatic int vmw_cmd_shader_define(struct vmw_private *dev_priv,\n\t\t\t\t struct vmw_sw_context *sw_context,\n\t\t\t\t SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDefineShader);\n\tint ret;\n\tsize_t size;\n\tstruct vmw_resource *ctx;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\tVMW_RES_DIRTY_SET, user_context_converter,\n\t\t\t\t&cmd->body.cid, &ctx);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tif (unlikely(!dev_priv->has_mob))\n\t\treturn 0;\n\n\tsize = cmd->header.size - sizeof(cmd->body);\n\tret = vmw_compat_shader_add(dev_priv, vmw_context_res_man(ctx),\n\t\t\t\t    cmd->body.shid, cmd + 1, cmd->body.type,\n\t\t\t\t    size, &sw_context->staged_cmd_res);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\treturn vmw_resource_relocation_add(sw_context, NULL,\n\t\t\t\t\t   vmw_ptr_diff(sw_context->buf_start,\n\t\t\t\t\t\t\t&cmd->header.id),\n\t\t\t\t\t   vmw_res_rel_nop);\n}\n\n \nstatic int vmw_cmd_shader_destroy(struct vmw_private *dev_priv,\n\t\t\t\t  struct vmw_sw_context *sw_context,\n\t\t\t\t  SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDestroyShader);\n\tint ret;\n\tstruct vmw_resource *ctx;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\tVMW_RES_DIRTY_SET, user_context_converter,\n\t\t\t\t&cmd->body.cid, &ctx);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tif (unlikely(!dev_priv->has_mob))\n\t\treturn 0;\n\n\tret = vmw_shader_remove(vmw_context_res_man(ctx), cmd->body.shid,\n\t\t\t\tcmd->body.type, &sw_context->staged_cmd_res);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\treturn vmw_resource_relocation_add(sw_context, NULL,\n\t\t\t\t\t   vmw_ptr_diff(sw_context->buf_start,\n\t\t\t\t\t\t\t&cmd->header.id),\n\t\t\t\t\t   vmw_res_rel_nop);\n}\n\n \nstatic int vmw_cmd_set_shader(struct vmw_private *dev_priv,\n\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t      SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdSetShader);\n\tstruct vmw_ctx_bindinfo_shader binding;\n\tstruct vmw_resource *ctx, *res = NULL;\n\tstruct vmw_ctx_validation_info *ctx_info;\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\n\tif (!vmw_shadertype_is_valid(VMW_SM_LEGACY, cmd->body.type)) {\n\t\tVMW_DEBUG_USER(\"Illegal shader type %u.\\n\",\n\t\t\t       (unsigned int) cmd->body.type);\n\t\treturn -EINVAL;\n\t}\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\tVMW_RES_DIRTY_SET, user_context_converter,\n\t\t\t\t&cmd->body.cid, &ctx);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tif (!dev_priv->has_mob)\n\t\treturn 0;\n\n\tif (cmd->body.shid != SVGA3D_INVALID_ID) {\n\t\t \n\t\tres = vmw_shader_lookup(vmw_context_res_man(ctx),\n\t\t\t\t\tcmd->body.shid, cmd->body.type);\n\t\tif (!IS_ERR(res)) {\n\t\t\tret = vmw_execbuf_res_val_add(sw_context, res,\n\t\t\t\t\t\t      VMW_RES_DIRTY_NONE,\n\t\t\t\t\t\t      vmw_val_add_flag_noctx);\n\t\t\tif (unlikely(ret != 0))\n\t\t\t\treturn ret;\n\n\t\t\tret = vmw_resource_relocation_add\n\t\t\t\t(sw_context, res,\n\t\t\t\t vmw_ptr_diff(sw_context->buf_start,\n\t\t\t\t\t      &cmd->body.shid),\n\t\t\t\t vmw_res_rel_normal);\n\t\t\tif (unlikely(ret != 0))\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (IS_ERR_OR_NULL(res)) {\n\t\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_shader,\n\t\t\t\t\tVMW_RES_DIRTY_NONE,\n\t\t\t\t\tuser_shader_converter, &cmd->body.shid,\n\t\t\t\t\t&res);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\t}\n\n\tctx_info = vmw_execbuf_info_from_res(sw_context, ctx);\n\tif (!ctx_info)\n\t\treturn -EINVAL;\n\n\tbinding.bi.ctx = ctx;\n\tbinding.bi.res = res;\n\tbinding.bi.bt = vmw_ctx_binding_shader;\n\tbinding.shader_slot = cmd->body.type - SVGA3D_SHADERTYPE_MIN;\n\tvmw_binding_add(ctx_info->staged, &binding.bi, binding.shader_slot, 0);\n\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_set_shader_const(struct vmw_private *dev_priv,\n\t\t\t\t    struct vmw_sw_context *sw_context,\n\t\t\t\t    SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdSetShaderConst);\n\tint ret;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\tVMW_RES_DIRTY_SET, user_context_converter,\n\t\t\t\t&cmd->body.cid, NULL);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tif (dev_priv->has_mob)\n\t\theader->id = SVGA_3D_CMD_SET_GB_SHADERCONSTS_INLINE;\n\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_bind_gb_shader(struct vmw_private *dev_priv,\n\t\t\t\t  struct vmw_sw_context *sw_context,\n\t\t\t\t  SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdBindGBShader) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\treturn vmw_cmd_switch_backup(dev_priv, sw_context, vmw_res_shader,\n\t\t\t\t     user_shader_converter, &cmd->body.shid,\n\t\t\t\t     &cmd->body.mobid, cmd->body.offsetInBytes);\n}\n\n \nstatic int\nvmw_cmd_dx_set_single_constant_buffer(struct vmw_private *dev_priv,\n\t\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t\t      SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXSetSingleConstantBuffer);\n\n\tstruct vmw_resource *res = NULL;\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tstruct vmw_ctx_bindinfo_cb binding;\n\tint ret;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\tVMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t&cmd->body.sid, &res);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tif (!vmw_shadertype_is_valid(dev_priv->sm_type, cmd->body.type) ||\n\t    cmd->body.slot >= SVGA3D_DX_MAX_CONSTBUFFERS) {\n\t\tVMW_DEBUG_USER(\"Illegal const buffer shader %u slot %u.\\n\",\n\t\t\t       (unsigned int) cmd->body.type,\n\t\t\t       (unsigned int) cmd->body.slot);\n\t\treturn -EINVAL;\n\t}\n\n\tbinding.bi.ctx = ctx_node->ctx;\n\tbinding.bi.res = res;\n\tbinding.bi.bt = vmw_ctx_binding_cb;\n\tbinding.shader_slot = cmd->body.type - SVGA3D_SHADERTYPE_MIN;\n\tbinding.offset = cmd->body.offsetInBytes;\n\tbinding.size = cmd->body.sizeInBytes;\n\tbinding.slot = cmd->body.slot;\n\n\tvmw_binding_add(ctx_node->staged, &binding.bi, binding.shader_slot,\n\t\t\tbinding.slot);\n\n\treturn 0;\n}\n\n \nstatic int\nvmw_cmd_dx_set_constant_buffer_offset(struct vmw_private *dev_priv,\n\t\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t\t      SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXSetConstantBufferOffset);\n\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tu32 shader_slot;\n\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tif (cmd->body.slot >= SVGA3D_DX_MAX_CONSTBUFFERS) {\n\t\tVMW_DEBUG_USER(\"Illegal const buffer slot %u.\\n\",\n\t\t\t       (unsigned int) cmd->body.slot);\n\t\treturn -EINVAL;\n\t}\n\n\tshader_slot = cmd->header.id - SVGA_3D_CMD_DX_SET_VS_CONSTANT_BUFFER_OFFSET;\n\tvmw_binding_cb_offset_update(ctx_node->staged, shader_slot,\n\t\t\t\t     cmd->body.slot, cmd->body.offsetInBytes);\n\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_dx_set_shader_res(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t\t     SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXSetShaderResources) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\tu32 num_sr_view = (cmd->header.size - sizeof(cmd->body)) /\n\t\tsizeof(SVGA3dShaderResourceViewId);\n\n\tif ((u64) cmd->body.startView + (u64) num_sr_view >\n\t    (u64) SVGA3D_DX_MAX_SRVIEWS ||\n\t    !vmw_shadertype_is_valid(dev_priv->sm_type, cmd->body.type)) {\n\t\tVMW_DEBUG_USER(\"Invalid shader binding.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn vmw_view_bindings_add(sw_context, vmw_view_sr,\n\t\t\t\t     vmw_ctx_binding_sr,\n\t\t\t\t     cmd->body.type - SVGA3D_SHADERTYPE_MIN,\n\t\t\t\t     (void *) &cmd[1], num_sr_view,\n\t\t\t\t     cmd->body.startView);\n}\n\n \nstatic int vmw_cmd_dx_set_shader(struct vmw_private *dev_priv,\n\t\t\t\t struct vmw_sw_context *sw_context,\n\t\t\t\t SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXSetShader);\n\tstruct vmw_resource *res = NULL;\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tstruct vmw_ctx_bindinfo_shader binding;\n\tint ret = 0;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\n\tif (!vmw_shadertype_is_valid(dev_priv->sm_type, cmd->body.type)) {\n\t\tVMW_DEBUG_USER(\"Illegal shader type %u.\\n\",\n\t\t\t       (unsigned int) cmd->body.type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->body.shaderId != SVGA3D_INVALID_ID) {\n\t\tres = vmw_shader_lookup(sw_context->man, cmd->body.shaderId, 0);\n\t\tif (IS_ERR(res)) {\n\t\t\tVMW_DEBUG_USER(\"Could not find shader for binding.\\n\");\n\t\t\treturn PTR_ERR(res);\n\t\t}\n\n\t\tret = vmw_execbuf_res_val_add(sw_context, res,\n\t\t\t\t\t      VMW_RES_DIRTY_NONE,\n\t\t\t\t\t      vmw_val_add_flag_noctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tbinding.bi.ctx = ctx_node->ctx;\n\tbinding.bi.res = res;\n\tbinding.bi.bt = vmw_ctx_binding_dx_shader;\n\tbinding.shader_slot = cmd->body.type - SVGA3D_SHADERTYPE_MIN;\n\n\tvmw_binding_add(ctx_node->staged, &binding.bi, binding.shader_slot, 0);\n\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_dx_set_vertex_buffers(struct vmw_private *dev_priv,\n\t\t\t\t\t struct vmw_sw_context *sw_context,\n\t\t\t\t\t SVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tstruct vmw_ctx_bindinfo_vb binding;\n\tstruct vmw_resource *res;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXSetVertexBuffers body;\n\t\tSVGA3dVertexBuffer buf[];\n\t} *cmd;\n\tint i, ret, num;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tnum = (cmd->header.size - sizeof(cmd->body)) /\n\t\tsizeof(SVGA3dVertexBuffer);\n\tif ((u64)num + (u64)cmd->body.startBuffer >\n\t    (u64)SVGA3D_DX_MAX_VERTEXBUFFERS) {\n\t\tVMW_DEBUG_USER(\"Invalid number of vertex buffers.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t\tVMW_RES_DIRTY_NONE,\n\t\t\t\t\tuser_surface_converter,\n\t\t\t\t\t&cmd->buf[i].sid, &res);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\n\t\tbinding.bi.ctx = ctx_node->ctx;\n\t\tbinding.bi.bt = vmw_ctx_binding_vb;\n\t\tbinding.bi.res = res;\n\t\tbinding.offset = cmd->buf[i].offset;\n\t\tbinding.stride = cmd->buf[i].stride;\n\t\tbinding.slot = i + cmd->body.startBuffer;\n\n\t\tvmw_binding_add(ctx_node->staged, &binding.bi, 0, binding.slot);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_dx_set_index_buffer(struct vmw_private *dev_priv,\n\t\t\t\t       struct vmw_sw_context *sw_context,\n\t\t\t\t       SVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tstruct vmw_ctx_bindinfo_ib binding;\n\tstruct vmw_resource *res;\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXSetIndexBuffer);\n\tint ret;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\tVMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t&cmd->body.sid, &res);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tbinding.bi.ctx = ctx_node->ctx;\n\tbinding.bi.res = res;\n\tbinding.bi.bt = vmw_ctx_binding_ib;\n\tbinding.offset = cmd->body.offset;\n\tbinding.format = cmd->body.format;\n\n\tvmw_binding_add(ctx_node->staged, &binding.bi, 0, 0);\n\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_dx_set_rendertargets(struct vmw_private *dev_priv,\n\t\t\t\t\tstruct vmw_sw_context *sw_context,\n\t\t\t\t\tSVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXSetRenderTargets) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\tu32 num_rt_view = (cmd->header.size - sizeof(cmd->body)) /\n\t\tsizeof(SVGA3dRenderTargetViewId);\n\tint ret;\n\n\tif (num_rt_view > SVGA3D_DX_MAX_RENDER_TARGETS) {\n\t\tVMW_DEBUG_USER(\"Invalid DX Rendertarget binding.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = vmw_view_bindings_add(sw_context, vmw_view_ds, vmw_ctx_binding_ds,\n\t\t\t\t    0, &cmd->body.depthStencilViewId, 1, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vmw_view_bindings_add(sw_context, vmw_view_rt,\n\t\t\t\t     vmw_ctx_binding_dx_rt, 0, (void *)&cmd[1],\n\t\t\t\t     num_rt_view, 0);\n}\n\n \nstatic int vmw_cmd_dx_clear_rendertarget_view(struct vmw_private *dev_priv,\n\t\t\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t\t\t      SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXClearRenderTargetView) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\tstruct vmw_resource *ret;\n\n\tret = vmw_view_id_val_add(sw_context, vmw_view_rt,\n\t\t\t\t  cmd->body.renderTargetViewId);\n\n\treturn PTR_ERR_OR_ZERO(ret);\n}\n\n \nstatic int vmw_cmd_dx_clear_depthstencil_view(struct vmw_private *dev_priv,\n\t\t\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t\t\t      SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXClearDepthStencilView) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\tstruct vmw_resource *ret;\n\n\tret = vmw_view_id_val_add(sw_context, vmw_view_ds,\n\t\t\t\t  cmd->body.depthStencilViewId);\n\n\treturn PTR_ERR_OR_ZERO(ret);\n}\n\nstatic int vmw_cmd_dx_view_define(struct vmw_private *dev_priv,\n\t\t\t\t  struct vmw_sw_context *sw_context,\n\t\t\t\t  SVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tstruct vmw_resource *srf;\n\tstruct vmw_resource *res;\n\tenum vmw_view_type view_type;\n\tint ret;\n\t \n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tuint32 defined_id;\n\t\tuint32 sid;\n\t} *cmd;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tview_type = vmw_view_cmd_to_type(header->id);\n\tif (view_type == vmw_view_max)\n\t\treturn -EINVAL;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tif (unlikely(cmd->sid == SVGA3D_INVALID_ID)) {\n\t\tVMW_DEBUG_USER(\"Invalid surface id.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\tVMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t&cmd->sid, &srf);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tres = vmw_context_cotable(ctx_node->ctx, vmw_view_cotables[view_type]);\n\tret = vmw_cotable_notify(res, cmd->defined_id);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\treturn vmw_view_add(sw_context->man, ctx_node->ctx, srf, view_type,\n\t\t\t    cmd->defined_id, header,\n\t\t\t    header->size + sizeof(*header),\n\t\t\t    &sw_context->staged_cmd_res);\n}\n\n \nstatic int vmw_cmd_dx_set_so_targets(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t\t     SVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tstruct vmw_ctx_bindinfo_so_target binding;\n\tstruct vmw_resource *res;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXSetSOTargets body;\n\t\tSVGA3dSoTarget targets[];\n\t} *cmd;\n\tint i, ret, num;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\tnum = (cmd->header.size - sizeof(cmd->body)) / sizeof(SVGA3dSoTarget);\n\n\tif (num > SVGA3D_DX_MAX_SOTARGETS) {\n\t\tVMW_DEBUG_USER(\"Invalid DX SO binding.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t\tVMW_RES_DIRTY_SET,\n\t\t\t\t\tuser_surface_converter,\n\t\t\t\t\t&cmd->targets[i].sid, &res);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\n\t\tbinding.bi.ctx = ctx_node->ctx;\n\t\tbinding.bi.res = res;\n\t\tbinding.bi.bt = vmw_ctx_binding_so_target;\n\t\tbinding.offset = cmd->targets[i].offset;\n\t\tbinding.size = cmd->targets[i].sizeInBytes;\n\t\tbinding.slot = i;\n\n\t\tvmw_binding_add(ctx_node->staged, &binding.bi, 0, binding.slot);\n\t}\n\n\treturn 0;\n}\n\nstatic int vmw_cmd_dx_so_define(struct vmw_private *dev_priv,\n\t\t\t\tstruct vmw_sw_context *sw_context,\n\t\t\t\tSVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tstruct vmw_resource *res;\n\t \n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tuint32 defined_id;\n\t} *cmd;\n\tenum vmw_so_type so_type;\n\tint ret;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tso_type = vmw_so_cmd_to_type(header->id);\n\tres = vmw_context_cotable(ctx_node->ctx, vmw_so_cotables[so_type]);\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\tcmd = container_of(header, typeof(*cmd), header);\n\tret = vmw_cotable_notify(res, cmd->defined_id);\n\n\treturn ret;\n}\n\n \nstatic int vmw_cmd_dx_check_subresource(struct vmw_private *dev_priv,\n\t\t\t\t\tstruct vmw_sw_context *sw_context,\n\t\t\t\t\tSVGA3dCmdHeader *header)\n{\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tunion {\n\t\t\tSVGA3dCmdDXReadbackSubResource r_body;\n\t\t\tSVGA3dCmdDXInvalidateSubResource i_body;\n\t\t\tSVGA3dCmdDXUpdateSubResource u_body;\n\t\t\tSVGA3dSurfaceId sid;\n\t\t};\n\t} *cmd;\n\n\tBUILD_BUG_ON(offsetof(typeof(*cmd), r_body.sid) !=\n\t\t     offsetof(typeof(*cmd), sid));\n\tBUILD_BUG_ON(offsetof(typeof(*cmd), i_body.sid) !=\n\t\t     offsetof(typeof(*cmd), sid));\n\tBUILD_BUG_ON(offsetof(typeof(*cmd), u_body.sid) !=\n\t\t     offsetof(typeof(*cmd), sid));\n\n\tcmd = container_of(header, typeof(*cmd), header);\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t &cmd->sid, NULL);\n}\n\nstatic int vmw_cmd_dx_cid_check(struct vmw_private *dev_priv,\n\t\t\t\tstruct vmw_sw_context *sw_context,\n\t\t\t\tSVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_dx_view_remove(struct vmw_private *dev_priv,\n\t\t\t\t  struct vmw_sw_context *sw_context,\n\t\t\t\t  SVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tunion vmw_view_destroy body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\tenum vmw_view_type view_type = vmw_view_cmd_to_type(header->id);\n\tstruct vmw_resource *view;\n\tint ret;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tret = vmw_view_remove(sw_context->man, cmd->body.view_id, view_type,\n\t\t\t      &sw_context->staged_cmd_res, &view);\n\tif (ret || !view)\n\t\treturn ret;\n\n\t \n\treturn vmw_resource_relocation_add(sw_context, view,\n\t\t\t\t\t   vmw_ptr_diff(sw_context->buf_start,\n\t\t\t\t\t\t\t&cmd->header.id),\n\t\t\t\t\t   vmw_res_rel_cond_nop);\n}\n\n \nstatic int vmw_cmd_dx_define_shader(struct vmw_private *dev_priv,\n\t\t\t\t    struct vmw_sw_context *sw_context,\n\t\t\t\t    SVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tstruct vmw_resource *res;\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXDefineShader) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\tint ret;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tres = vmw_context_cotable(ctx_node->ctx, SVGA_COTABLE_DXSHADER);\n\tret = vmw_cotable_notify(res, cmd->body.shaderId);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vmw_dx_shader_add(sw_context->man, ctx_node->ctx,\n\t\t\t\t cmd->body.shaderId, cmd->body.type,\n\t\t\t\t &sw_context->staged_cmd_res);\n}\n\n \nstatic int vmw_cmd_dx_destroy_shader(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t\t     SVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXDestroyShader) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\tint ret;\n\n\tif (!ctx_node)\n\t\treturn -EINVAL;\n\n\tret = vmw_shader_remove(sw_context->man, cmd->body.shaderId, 0,\n\t\t\t\t&sw_context->staged_cmd_res);\n\n\treturn ret;\n}\n\n \nstatic int vmw_cmd_dx_bind_shader(struct vmw_private *dev_priv,\n\t\t\t\t  struct vmw_sw_context *sw_context,\n\t\t\t\t  SVGA3dCmdHeader *header)\n{\n\tstruct vmw_resource *ctx;\n\tstruct vmw_resource *res;\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXBindShader) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\tint ret;\n\n\tif (cmd->body.cid != SVGA3D_INVALID_ID) {\n\t\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,\n\t\t\t\t\tVMW_RES_DIRTY_SET,\n\t\t\t\t\tuser_context_converter, &cmd->body.cid,\n\t\t\t\t\t&ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tstruct vmw_ctx_validation_info *ctx_node =\n\t\t\tVMW_GET_CTX_NODE(sw_context);\n\n\t\tif (!ctx_node)\n\t\t\treturn -EINVAL;\n\n\t\tctx = ctx_node->ctx;\n\t}\n\n\tres = vmw_shader_lookup(vmw_context_res_man(ctx), cmd->body.shid, 0);\n\tif (IS_ERR(res)) {\n\t\tVMW_DEBUG_USER(\"Could not find shader to bind.\\n\");\n\t\treturn PTR_ERR(res);\n\t}\n\n\tret = vmw_execbuf_res_val_add(sw_context, res, VMW_RES_DIRTY_NONE,\n\t\t\t\t      vmw_val_add_flag_noctx);\n\tif (ret) {\n\t\tVMW_DEBUG_USER(\"Error creating resource validation node.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn vmw_cmd_res_switch_backup(dev_priv, sw_context, res,\n\t\t\t\t\t &cmd->body.mobid,\n\t\t\t\t\t cmd->body.offsetInBytes);\n}\n\n \nstatic int vmw_cmd_dx_genmips(struct vmw_private *dev_priv,\n\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t      SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXGenMips) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\tstruct vmw_resource *view;\n\tstruct vmw_res_cache_entry *rcache;\n\n\tview = vmw_view_id_val_add(sw_context, vmw_view_sr,\n\t\t\t\t   cmd->body.shaderResourceViewId);\n\tif (IS_ERR(view))\n\t\treturn PTR_ERR(view);\n\n\t \n\trcache = &sw_context->res_cache[vmw_res_surface];\n\tvmw_validation_res_set_dirty(sw_context->ctx, rcache->private,\n\t\t\t\t     VMW_RES_DIRTY_SET);\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_dx_transfer_from_buffer(struct vmw_private *dev_priv,\n\t\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t\t   SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXTransferFromBuffer) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\tint ret;\n\n\tret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\tVMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t&cmd->body.srcSid, NULL);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_SET, user_surface_converter,\n\t\t\t\t &cmd->body.destSid, NULL);\n}\n\n \nstatic int vmw_cmd_intra_surface_copy(struct vmw_private *dev_priv,\n\t\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t\t   SVGA3dCmdHeader *header)\n{\n\tVMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdIntraSurfaceCopy) =\n\t\tcontainer_of(header, typeof(*cmd), header);\n\n\tif (!(dev_priv->capabilities2 & SVGA_CAP2_INTRA_SURFACE_COPY))\n\t\treturn -EINVAL;\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_SET, user_surface_converter,\n\t\t\t\t &cmd->body.surface.sid, NULL);\n}\n\nstatic int vmw_cmd_sm5(struct vmw_private *dev_priv,\n\t\t       struct vmw_sw_context *sw_context,\n\t\t       SVGA3dCmdHeader *header)\n{\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int vmw_cmd_sm5_view_define(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t   SVGA3dCmdHeader *header)\n{\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\treturn vmw_cmd_dx_view_define(dev_priv, sw_context, header);\n}\n\nstatic int vmw_cmd_sm5_view_remove(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t   SVGA3dCmdHeader *header)\n{\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\treturn vmw_cmd_dx_view_remove(dev_priv, sw_context, header);\n}\n\nstatic int vmw_cmd_clear_uav_uint(struct vmw_private *dev_priv,\n\t\t\t\t  struct vmw_sw_context *sw_context,\n\t\t\t\t  SVGA3dCmdHeader *header)\n{\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXClearUAViewUint body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\tstruct vmw_resource *ret;\n\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\tret = vmw_view_id_val_add(sw_context, vmw_view_ua,\n\t\t\t\t  cmd->body.uaViewId);\n\n\treturn PTR_ERR_OR_ZERO(ret);\n}\n\nstatic int vmw_cmd_clear_uav_float(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t   SVGA3dCmdHeader *header)\n{\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXClearUAViewFloat body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\tstruct vmw_resource *ret;\n\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\tret = vmw_view_id_val_add(sw_context, vmw_view_ua,\n\t\t\t\t  cmd->body.uaViewId);\n\n\treturn PTR_ERR_OR_ZERO(ret);\n}\n\nstatic int vmw_cmd_set_uav(struct vmw_private *dev_priv,\n\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t   SVGA3dCmdHeader *header)\n{\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXSetUAViews body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\tu32 num_uav = (cmd->header.size - sizeof(cmd->body)) /\n\t\tsizeof(SVGA3dUAViewId);\n\tint ret;\n\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\tif (num_uav > vmw_max_num_uavs(dev_priv)) {\n\t\tVMW_DEBUG_USER(\"Invalid UAV binding.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = vmw_view_bindings_add(sw_context, vmw_view_ua,\n\t\t\t\t    vmw_ctx_binding_uav, 0, (void *)&cmd[1],\n\t\t\t\t    num_uav, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tvmw_binding_add_uav_index(sw_context->dx_ctx_node->staged, 0,\n\t\t\t\t\t cmd->body.uavSpliceIndex);\n\n\treturn ret;\n}\n\nstatic int vmw_cmd_set_cs_uav(struct vmw_private *dev_priv,\n\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t      SVGA3dCmdHeader *header)\n{\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXSetCSUAViews body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\tu32 num_uav = (cmd->header.size - sizeof(cmd->body)) /\n\t\tsizeof(SVGA3dUAViewId);\n\tint ret;\n\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\tif (num_uav > vmw_max_num_uavs(dev_priv)) {\n\t\tVMW_DEBUG_USER(\"Invalid UAV binding.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = vmw_view_bindings_add(sw_context, vmw_view_ua,\n\t\t\t\t    vmw_ctx_binding_cs_uav, 0, (void *)&cmd[1],\n\t\t\t\t    num_uav, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tvmw_binding_add_uav_index(sw_context->dx_ctx_node->staged, 1,\n\t\t\t\t  cmd->body.startIndex);\n\n\treturn ret;\n}\n\nstatic int vmw_cmd_dx_define_streamoutput(struct vmw_private *dev_priv,\n\t\t\t\t\t  struct vmw_sw_context *sw_context,\n\t\t\t\t\t  SVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = sw_context->dx_ctx_node;\n\tstruct vmw_resource *res;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXDefineStreamOutputWithMob body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\tint ret;\n\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\tif (!ctx_node) {\n\t\tDRM_ERROR(\"DX Context not set.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tres = vmw_context_cotable(ctx_node->ctx, SVGA_COTABLE_STREAMOUTPUT);\n\tret = vmw_cotable_notify(res, cmd->body.soid);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vmw_dx_streamoutput_add(sw_context->man, ctx_node->ctx,\n\t\t\t\t       cmd->body.soid,\n\t\t\t\t       &sw_context->staged_cmd_res);\n}\n\nstatic int vmw_cmd_dx_destroy_streamoutput(struct vmw_private *dev_priv,\n\t\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t\t   SVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = sw_context->dx_ctx_node;\n\tstruct vmw_resource *res;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXDestroyStreamOutput body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\n\tif (!ctx_node) {\n\t\tDRM_ERROR(\"DX Context not set.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!has_sm5_context(dev_priv))\n\t\treturn 0;\n\n\t \n\tres = vmw_dx_streamoutput_lookup(vmw_context_res_man(ctx_node->ctx),\n\t\t\t\t\t cmd->body.soid);\n\tif (IS_ERR(res))\n\t\treturn 0;\n\n\treturn vmw_dx_streamoutput_remove(sw_context->man, cmd->body.soid,\n\t\t\t\t\t  &sw_context->staged_cmd_res);\n}\n\nstatic int vmw_cmd_dx_bind_streamoutput(struct vmw_private *dev_priv,\n\t\t\t\t\tstruct vmw_sw_context *sw_context,\n\t\t\t\t\tSVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = sw_context->dx_ctx_node;\n\tstruct vmw_resource *res;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXBindStreamOutput body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\tint ret;\n\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\tif (!ctx_node) {\n\t\tDRM_ERROR(\"DX Context not set.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tres = vmw_dx_streamoutput_lookup(vmw_context_res_man(ctx_node->ctx),\n\t\t\t\t\t cmd->body.soid);\n\tif (IS_ERR(res)) {\n\t\tDRM_ERROR(\"Could not find streamoutput to bind.\\n\");\n\t\treturn PTR_ERR(res);\n\t}\n\n\tvmw_dx_streamoutput_set_size(res, cmd->body.sizeInBytes);\n\n\tret = vmw_execbuf_res_val_add(sw_context, res, VMW_RES_DIRTY_NONE,\n\t\t\t\t      vmw_val_add_flag_noctx);\n\tif (ret) {\n\t\tDRM_ERROR(\"Error creating resource validation node.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn vmw_cmd_res_switch_backup(dev_priv, sw_context, res,\n\t\t\t\t\t &cmd->body.mobid,\n\t\t\t\t\t cmd->body.offsetInBytes);\n}\n\nstatic int vmw_cmd_dx_set_streamoutput(struct vmw_private *dev_priv,\n\t\t\t\t       struct vmw_sw_context *sw_context,\n\t\t\t\t       SVGA3dCmdHeader *header)\n{\n\tstruct vmw_ctx_validation_info *ctx_node = sw_context->dx_ctx_node;\n\tstruct vmw_resource *res;\n\tstruct vmw_ctx_bindinfo_so binding;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXSetStreamOutput body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\tint ret;\n\n\tif (!ctx_node) {\n\t\tDRM_ERROR(\"DX Context not set.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->body.soid == SVGA3D_INVALID_ID)\n\t\treturn 0;\n\n\t \n\tif (!has_sm5_context(dev_priv))\n\t\treturn 0;\n\n\t \n\tres = vmw_dx_streamoutput_lookup(vmw_context_res_man(ctx_node->ctx),\n\t\t\t\t\t cmd->body.soid);\n\tif (IS_ERR(res)) {\n\t\treturn 0;\n\t}\n\n\tret = vmw_execbuf_res_val_add(sw_context, res, VMW_RES_DIRTY_NONE,\n\t\t\t\t      vmw_val_add_flag_noctx);\n\tif (ret) {\n\t\tDRM_ERROR(\"Error creating resource validation node.\\n\");\n\t\treturn ret;\n\t}\n\n\tbinding.bi.ctx = ctx_node->ctx;\n\tbinding.bi.res = res;\n\tbinding.bi.bt = vmw_ctx_binding_so;\n\tbinding.slot = 0;  \n\n\tvmw_binding_add(sw_context->dx_ctx_node->staged, &binding.bi, 0,\n\t\t\tbinding.slot);\n\n\treturn ret;\n}\n\nstatic int vmw_cmd_indexed_instanced_indirect(struct vmw_private *dev_priv,\n\t\t\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t\t\t      SVGA3dCmdHeader *header)\n{\n\tstruct vmw_draw_indexed_instanced_indirect_cmd {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXDrawIndexedInstancedIndirect body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t &cmd->body.argsBufferSid, NULL);\n}\n\nstatic int vmw_cmd_instanced_indirect(struct vmw_private *dev_priv,\n\t\t\t\t      struct vmw_sw_context *sw_context,\n\t\t\t\t      SVGA3dCmdHeader *header)\n{\n\tstruct vmw_draw_instanced_indirect_cmd {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXDrawInstancedIndirect body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t &cmd->body.argsBufferSid, NULL);\n}\n\nstatic int vmw_cmd_dispatch_indirect(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_sw_context *sw_context,\n\t\t\t\t     SVGA3dCmdHeader *header)\n{\n\tstruct vmw_dispatch_indirect_cmd {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXDispatchIndirect body;\n\t} *cmd = container_of(header, typeof(*cmd), header);\n\n\tif (!has_sm5_context(dev_priv))\n\t\treturn -EINVAL;\n\n\treturn vmw_cmd_res_check(dev_priv, sw_context, vmw_res_surface,\n\t\t\t\t VMW_RES_DIRTY_NONE, user_surface_converter,\n\t\t\t\t &cmd->body.argsBufferSid, NULL);\n}\n\nstatic int vmw_cmd_check_not_3d(struct vmw_private *dev_priv,\n\t\t\t\tstruct vmw_sw_context *sw_context,\n\t\t\t\tvoid *buf, uint32_t *size)\n{\n\tuint32_t size_remaining = *size;\n\tuint32_t cmd_id;\n\n\tcmd_id = ((uint32_t *)buf)[0];\n\tswitch (cmd_id) {\n\tcase SVGA_CMD_UPDATE:\n\t\t*size = sizeof(uint32_t) + sizeof(SVGAFifoCmdUpdate);\n\t\tbreak;\n\tcase SVGA_CMD_DEFINE_GMRFB:\n\t\t*size = sizeof(uint32_t) + sizeof(SVGAFifoCmdDefineGMRFB);\n\t\tbreak;\n\tcase SVGA_CMD_BLIT_GMRFB_TO_SCREEN:\n\t\t*size = sizeof(uint32_t) + sizeof(SVGAFifoCmdBlitGMRFBToScreen);\n\t\tbreak;\n\tcase SVGA_CMD_BLIT_SCREEN_TO_GMRFB:\n\t\t*size = sizeof(uint32_t) + sizeof(SVGAFifoCmdBlitGMRFBToScreen);\n\t\tbreak;\n\tdefault:\n\t\tVMW_DEBUG_USER(\"Unsupported SVGA command: %u.\\n\", cmd_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (*size > size_remaining) {\n\t\tVMW_DEBUG_USER(\"Invalid SVGA command (size mismatch): %u.\\n\",\n\t\t\t       cmd_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(!sw_context->kernel)) {\n\t\tVMW_DEBUG_USER(\"Kernel only SVGA command: %u.\\n\", cmd_id);\n\t\treturn -EPERM;\n\t}\n\n\tif (cmd_id == SVGA_CMD_DEFINE_GMRFB)\n\t\treturn vmw_cmd_check_define_gmrfb(dev_priv, sw_context, buf);\n\n\treturn 0;\n}\n\nstatic const struct vmw_cmd_entry vmw_cmd_entries[SVGA_3D_CMD_MAX] = {\n\tVMW_CMD_DEF(SVGA_3D_CMD_SURFACE_DEFINE, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SURFACE_DESTROY, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SURFACE_COPY, &vmw_cmd_surface_copy_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SURFACE_STRETCHBLT, &vmw_cmd_stretch_blt_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SURFACE_DMA, &vmw_cmd_dma,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_CONTEXT_DEFINE, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_CONTEXT_DESTROY, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SETTRANSFORM, &vmw_cmd_cid_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SETZRANGE, &vmw_cmd_cid_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SETRENDERSTATE, &vmw_cmd_cid_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SETRENDERTARGET,\n\t\t    &vmw_cmd_set_render_target_check, true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SETTEXTURESTATE, &vmw_cmd_tex_state,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SETMATERIAL, &vmw_cmd_cid_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SETLIGHTDATA, &vmw_cmd_cid_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SETLIGHTENABLED, &vmw_cmd_cid_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SETVIEWPORT, &vmw_cmd_cid_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SETCLIPPLANE, &vmw_cmd_cid_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_CLEAR, &vmw_cmd_cid_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_PRESENT, &vmw_cmd_present_check,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SHADER_DEFINE, &vmw_cmd_shader_define,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SHADER_DESTROY, &vmw_cmd_shader_destroy,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SET_SHADER, &vmw_cmd_set_shader,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SET_SHADER_CONST, &vmw_cmd_set_shader_const,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DRAW_PRIMITIVES, &vmw_cmd_draw,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SETSCISSORRECT, &vmw_cmd_cid_check,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_BEGIN_QUERY, &vmw_cmd_begin_query,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_END_QUERY, &vmw_cmd_end_query,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_WAIT_FOR_QUERY, &vmw_cmd_wait_query,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_PRESENT_READBACK, &vmw_cmd_ok,\n\t\t    true, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN,\n\t\t    &vmw_cmd_blt_surf_screen_check, false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SURFACE_DEFINE_V2, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_GENERATE_MIPMAPS, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_ACTIVATE_SURFACE, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEACTIVATE_SURFACE, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SCREEN_DMA, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEAD1, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEAD2, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEAD12, &vmw_cmd_invalid, false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEAD13, &vmw_cmd_invalid, false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEAD14, &vmw_cmd_invalid, false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEAD15, &vmw_cmd_invalid, false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEAD16, &vmw_cmd_invalid, false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEAD17, &vmw_cmd_invalid, false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SET_OTABLE_BASE, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_READBACK_OTABLE, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEFINE_GB_MOB, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DESTROY_GB_MOB, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_REDEFINE_GB_MOB64, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_UPDATE_GB_MOB_MAPPING, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEFINE_GB_SURFACE, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DESTROY_GB_SURFACE, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_BIND_GB_SURFACE, &vmw_cmd_bind_gb_surface,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_COND_BIND_GB_SURFACE, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_UPDATE_GB_IMAGE, &vmw_cmd_update_gb_image,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_UPDATE_GB_SURFACE,\n\t\t    &vmw_cmd_update_gb_surface, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_READBACK_GB_IMAGE,\n\t\t    &vmw_cmd_readback_gb_image, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_READBACK_GB_SURFACE,\n\t\t    &vmw_cmd_readback_gb_surface, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_INVALIDATE_GB_IMAGE,\n\t\t    &vmw_cmd_invalidate_gb_image, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_INVALIDATE_GB_SURFACE,\n\t\t    &vmw_cmd_invalidate_gb_surface, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEFINE_GB_CONTEXT, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DESTROY_GB_CONTEXT, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_BIND_GB_CONTEXT, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_READBACK_GB_CONTEXT, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_INVALIDATE_GB_CONTEXT, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEFINE_GB_SHADER, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_BIND_GB_SHADER, &vmw_cmd_bind_gb_shader,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DESTROY_GB_SHADER, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SET_OTABLE_BASE64, &vmw_cmd_invalid,\n\t\t    false, false, false),\n\tVMW_CMD_DEF(SVGA_3D_CMD_BEGIN_GB_QUERY, &vmw_cmd_begin_gb_query,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_END_GB_QUERY, &vmw_cmd_end_gb_query,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_WAIT_FOR_GB_QUERY, &vmw_cmd_wait_gb_query,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_NOP, &vmw_cmd_ok,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_NOP_ERROR, &vmw_cmd_ok,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_ENABLE_GART, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DISABLE_GART, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_MAP_MOB_INTO_GART, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_UNMAP_GART_RANGE, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEFINE_GB_SCREENTARGET, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DESTROY_GB_SCREENTARGET, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_BIND_GB_SCREENTARGET, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_UPDATE_GB_SCREENTARGET, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_READBACK_GB_IMAGE_PARTIAL, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_INVALIDATE_GB_IMAGE_PARTIAL, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_SET_GB_SHADERCONSTS_INLINE, &vmw_cmd_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_GB_SCREEN_DMA, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_BIND_GB_SURFACE_WITH_PITCH, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_GB_MOB_FENCE, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DEFINE_GB_SURFACE_V2, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\n\t \n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_CONTEXT, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_CONTEXT, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_BIND_CONTEXT, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_READBACK_CONTEXT, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_INVALIDATE_CONTEXT, &vmw_cmd_invalid,\n\t\t    false, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_SINGLE_CONSTANT_BUFFER,\n\t\t    &vmw_cmd_dx_set_single_constant_buffer, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_SHADER_RESOURCES,\n\t\t    &vmw_cmd_dx_set_shader_res, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_SHADER, &vmw_cmd_dx_set_shader,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_SAMPLERS, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DRAW, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DRAW_INDEXED, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DRAW_INSTANCED, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DRAW_INDEXED_INSTANCED,\n\t\t    &vmw_cmd_dx_cid_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DRAW_AUTO, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_VERTEX_BUFFERS,\n\t\t    &vmw_cmd_dx_set_vertex_buffers, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_INDEX_BUFFER,\n\t\t    &vmw_cmd_dx_set_index_buffer, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_RENDERTARGETS,\n\t\t    &vmw_cmd_dx_set_rendertargets, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_BLEND_STATE, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_DEPTHSTENCIL_STATE,\n\t\t    &vmw_cmd_dx_cid_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_RASTERIZER_STATE,\n\t\t    &vmw_cmd_dx_cid_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_QUERY, &vmw_cmd_dx_define_query,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_QUERY, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_BIND_QUERY, &vmw_cmd_dx_bind_query,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_QUERY_OFFSET,\n\t\t    &vmw_cmd_dx_cid_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_BEGIN_QUERY, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_END_QUERY, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_READBACK_QUERY, &vmw_cmd_invalid,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_PREDICATION, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_VIEWPORTS, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_SCISSORRECTS, &vmw_cmd_dx_cid_check,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_CLEAR_RENDERTARGET_VIEW,\n\t\t    &vmw_cmd_dx_clear_rendertarget_view, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_CLEAR_DEPTHSTENCIL_VIEW,\n\t\t    &vmw_cmd_dx_clear_depthstencil_view, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_PRED_COPY, &vmw_cmd_invalid,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_GENMIPS, &vmw_cmd_dx_genmips,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_UPDATE_SUBRESOURCE,\n\t\t    &vmw_cmd_dx_check_subresource, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_READBACK_SUBRESOURCE,\n\t\t    &vmw_cmd_dx_check_subresource, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_INVALIDATE_SUBRESOURCE,\n\t\t    &vmw_cmd_dx_check_subresource, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW,\n\t\t    &vmw_cmd_dx_view_define, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_SHADERRESOURCE_VIEW,\n\t\t    &vmw_cmd_dx_view_remove, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_RENDERTARGET_VIEW,\n\t\t    &vmw_cmd_dx_view_define, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_RENDERTARGET_VIEW,\n\t\t    &vmw_cmd_dx_view_remove, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_VIEW,\n\t\t    &vmw_cmd_dx_view_define, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_DEPTHSTENCIL_VIEW,\n\t\t    &vmw_cmd_dx_view_remove, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_ELEMENTLAYOUT,\n\t\t    &vmw_cmd_dx_so_define, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_ELEMENTLAYOUT,\n\t\t    &vmw_cmd_dx_cid_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_BLEND_STATE,\n\t\t    &vmw_cmd_dx_so_define, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_BLEND_STATE,\n\t\t    &vmw_cmd_dx_cid_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_STATE,\n\t\t    &vmw_cmd_dx_so_define, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_DEPTHSTENCIL_STATE,\n\t\t    &vmw_cmd_dx_cid_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_RASTERIZER_STATE,\n\t\t    &vmw_cmd_dx_so_define, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_RASTERIZER_STATE,\n\t\t    &vmw_cmd_dx_cid_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_SAMPLER_STATE,\n\t\t    &vmw_cmd_dx_so_define, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_SAMPLER_STATE,\n\t\t    &vmw_cmd_dx_cid_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_SHADER,\n\t\t    &vmw_cmd_dx_define_shader, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_SHADER,\n\t\t    &vmw_cmd_dx_destroy_shader, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_BIND_SHADER,\n\t\t    &vmw_cmd_dx_bind_shader, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_STREAMOUTPUT,\n\t\t    &vmw_cmd_dx_so_define, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_STREAMOUTPUT,\n\t\t    &vmw_cmd_dx_destroy_streamoutput, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_STREAMOUTPUT,\n\t\t    &vmw_cmd_dx_set_streamoutput, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_SOTARGETS,\n\t\t    &vmw_cmd_dx_set_so_targets, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_INPUT_LAYOUT,\n\t\t    &vmw_cmd_dx_cid_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_TOPOLOGY,\n\t\t    &vmw_cmd_dx_cid_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_BUFFER_COPY,\n\t\t    &vmw_cmd_buffer_copy_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_PRED_COPY_REGION,\n\t\t    &vmw_cmd_pred_copy_check, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_TRANSFER_FROM_BUFFER,\n\t\t    &vmw_cmd_dx_transfer_from_buffer,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_VS_CONSTANT_BUFFER_OFFSET,\n\t\t    &vmw_cmd_dx_set_constant_buffer_offset,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_PS_CONSTANT_BUFFER_OFFSET,\n\t\t    &vmw_cmd_dx_set_constant_buffer_offset,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_GS_CONSTANT_BUFFER_OFFSET,\n\t\t    &vmw_cmd_dx_set_constant_buffer_offset,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_HS_CONSTANT_BUFFER_OFFSET,\n\t\t    &vmw_cmd_dx_set_constant_buffer_offset,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_DS_CONSTANT_BUFFER_OFFSET,\n\t\t    &vmw_cmd_dx_set_constant_buffer_offset,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_CS_CONSTANT_BUFFER_OFFSET,\n\t\t    &vmw_cmd_dx_set_constant_buffer_offset,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_INTRA_SURFACE_COPY, &vmw_cmd_intra_surface_copy,\n\t\t    true, false, true),\n\n\t \n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_UA_VIEW, &vmw_cmd_sm5_view_define,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DESTROY_UA_VIEW, &vmw_cmd_sm5_view_remove,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_CLEAR_UA_VIEW_UINT, &vmw_cmd_clear_uav_uint,\n\t\t    true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_CLEAR_UA_VIEW_FLOAT,\n\t\t    &vmw_cmd_clear_uav_float, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_COPY_STRUCTURE_COUNT, &vmw_cmd_invalid, true,\n\t\t    false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_UA_VIEWS, &vmw_cmd_set_uav, true, false,\n\t\t    true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DRAW_INDEXED_INSTANCED_INDIRECT,\n\t\t    &vmw_cmd_indexed_instanced_indirect, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DRAW_INSTANCED_INDIRECT,\n\t\t    &vmw_cmd_instanced_indirect, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DISPATCH, &vmw_cmd_sm5, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DISPATCH_INDIRECT,\n\t\t    &vmw_cmd_dispatch_indirect, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_SET_CS_UA_VIEWS, &vmw_cmd_set_cs_uav, true,\n\t\t    false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_VIEW_V2,\n\t\t    &vmw_cmd_sm5_view_define, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_STREAMOUTPUT_WITH_MOB,\n\t\t    &vmw_cmd_dx_define_streamoutput, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_BIND_STREAMOUTPUT,\n\t\t    &vmw_cmd_dx_bind_streamoutput, true, false, true),\n\tVMW_CMD_DEF(SVGA_3D_CMD_DX_DEFINE_RASTERIZER_STATE_V2,\n\t\t    &vmw_cmd_dx_so_define, true, false, true),\n};\n\nbool vmw_cmd_describe(const void *buf, u32 *size, char const **cmd)\n{\n\tu32 cmd_id = ((u32 *) buf)[0];\n\n\tif (cmd_id >= SVGA_CMD_MAX) {\n\t\tSVGA3dCmdHeader *header = (SVGA3dCmdHeader *) buf;\n\t\tconst struct vmw_cmd_entry *entry;\n\n\t\t*size = header->size + sizeof(SVGA3dCmdHeader);\n\t\tcmd_id = header->id;\n\t\tif (cmd_id >= SVGA_3D_CMD_MAX)\n\t\t\treturn false;\n\n\t\tcmd_id -= SVGA_3D_CMD_BASE;\n\t\tentry = &vmw_cmd_entries[cmd_id];\n\t\t*cmd = entry->cmd_name;\n\t\treturn true;\n\t}\n\n\tswitch (cmd_id) {\n\tcase SVGA_CMD_UPDATE:\n\t\t*cmd = \"SVGA_CMD_UPDATE\";\n\t\t*size = sizeof(u32) + sizeof(SVGAFifoCmdUpdate);\n\t\tbreak;\n\tcase SVGA_CMD_DEFINE_GMRFB:\n\t\t*cmd = \"SVGA_CMD_DEFINE_GMRFB\";\n\t\t*size = sizeof(u32) + sizeof(SVGAFifoCmdDefineGMRFB);\n\t\tbreak;\n\tcase SVGA_CMD_BLIT_GMRFB_TO_SCREEN:\n\t\t*cmd = \"SVGA_CMD_BLIT_GMRFB_TO_SCREEN\";\n\t\t*size = sizeof(u32) + sizeof(SVGAFifoCmdBlitGMRFBToScreen);\n\t\tbreak;\n\tcase SVGA_CMD_BLIT_SCREEN_TO_GMRFB:\n\t\t*cmd = \"SVGA_CMD_BLIT_SCREEN_TO_GMRFB\";\n\t\t*size = sizeof(u32) + sizeof(SVGAFifoCmdBlitGMRFBToScreen);\n\t\tbreak;\n\tdefault:\n\t\t*cmd = \"UNKNOWN\";\n\t\t*size = 0;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int vmw_cmd_check(struct vmw_private *dev_priv,\n\t\t\t struct vmw_sw_context *sw_context, void *buf,\n\t\t\t uint32_t *size)\n{\n\tuint32_t cmd_id;\n\tuint32_t size_remaining = *size;\n\tSVGA3dCmdHeader *header = (SVGA3dCmdHeader *) buf;\n\tint ret;\n\tconst struct vmw_cmd_entry *entry;\n\tbool gb = dev_priv->capabilities & SVGA_CAP_GBOBJECTS;\n\n\tcmd_id = ((uint32_t *)buf)[0];\n\t \n\tif (unlikely(cmd_id < SVGA_CMD_MAX))\n\t\treturn vmw_cmd_check_not_3d(dev_priv, sw_context, buf, size);\n\n\n\tcmd_id = header->id;\n\t*size = header->size + sizeof(SVGA3dCmdHeader);\n\n\tcmd_id -= SVGA_3D_CMD_BASE;\n\tif (unlikely(*size > size_remaining))\n\t\tgoto out_invalid;\n\n\tif (unlikely(cmd_id >= SVGA_3D_CMD_MAX - SVGA_3D_CMD_BASE))\n\t\tgoto out_invalid;\n\n\tentry = &vmw_cmd_entries[cmd_id];\n\tif (unlikely(!entry->func))\n\t\tgoto out_invalid;\n\n\tif (unlikely(!entry->user_allow && !sw_context->kernel))\n\t\tgoto out_privileged;\n\n\tif (unlikely(entry->gb_disable && gb))\n\t\tgoto out_old;\n\n\tif (unlikely(entry->gb_enable && !gb))\n\t\tgoto out_new;\n\n\tret = entry->func(dev_priv, sw_context, header);\n\tif (unlikely(ret != 0)) {\n\t\tVMW_DEBUG_USER(\"SVGA3D command: %d failed with error %d\\n\",\n\t\t\t       cmd_id + SVGA_3D_CMD_BASE, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\nout_invalid:\n\tVMW_DEBUG_USER(\"Invalid SVGA3D command: %d\\n\",\n\t\t       cmd_id + SVGA_3D_CMD_BASE);\n\treturn -EINVAL;\nout_privileged:\n\tVMW_DEBUG_USER(\"Privileged SVGA3D command: %d\\n\",\n\t\t       cmd_id + SVGA_3D_CMD_BASE);\n\treturn -EPERM;\nout_old:\n\tVMW_DEBUG_USER(\"Deprecated (disallowed) SVGA3D command: %d\\n\",\n\t\t       cmd_id + SVGA_3D_CMD_BASE);\n\treturn -EINVAL;\nout_new:\n\tVMW_DEBUG_USER(\"SVGA3D command: %d not supported by virtual device.\\n\",\n\t\t       cmd_id + SVGA_3D_CMD_BASE);\n\treturn -EINVAL;\n}\n\nstatic int vmw_cmd_check_all(struct vmw_private *dev_priv,\n\t\t\t     struct vmw_sw_context *sw_context, void *buf,\n\t\t\t     uint32_t size)\n{\n\tint32_t cur_size = size;\n\tint ret;\n\n\tsw_context->buf_start = buf;\n\n\twhile (cur_size > 0) {\n\t\tsize = cur_size;\n\t\tret = vmw_cmd_check(dev_priv, sw_context, buf, &size);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\t\tbuf = (void *)((unsigned long) buf + size);\n\t\tcur_size -= size;\n\t}\n\n\tif (unlikely(cur_size != 0)) {\n\t\tVMW_DEBUG_USER(\"Command verifier out of sync.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void vmw_free_relocations(struct vmw_sw_context *sw_context)\n{\n\t \n\tINIT_LIST_HEAD(&sw_context->bo_relocations);\n}\n\nstatic void vmw_apply_relocations(struct vmw_sw_context *sw_context)\n{\n\tstruct vmw_relocation *reloc;\n\tstruct ttm_buffer_object *bo;\n\n\tlist_for_each_entry(reloc, &sw_context->bo_relocations, head) {\n\t\tbo = &reloc->vbo->tbo;\n\t\tswitch (bo->resource->mem_type) {\n\t\tcase TTM_PL_VRAM:\n\t\t\treloc->location->offset += bo->resource->start << PAGE_SHIFT;\n\t\t\treloc->location->gmrId = SVGA_GMR_FRAMEBUFFER;\n\t\t\tbreak;\n\t\tcase VMW_PL_GMR:\n\t\t\treloc->location->gmrId = bo->resource->start;\n\t\t\tbreak;\n\t\tcase VMW_PL_MOB:\n\t\t\t*reloc->mob_loc = bo->resource->start;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\tvmw_free_relocations(sw_context);\n}\n\nstatic int vmw_resize_cmd_bounce(struct vmw_sw_context *sw_context,\n\t\t\t\t uint32_t size)\n{\n\tif (likely(sw_context->cmd_bounce_size >= size))\n\t\treturn 0;\n\n\tif (sw_context->cmd_bounce_size == 0)\n\t\tsw_context->cmd_bounce_size = VMWGFX_CMD_BOUNCE_INIT_SIZE;\n\n\twhile (sw_context->cmd_bounce_size < size) {\n\t\tsw_context->cmd_bounce_size =\n\t\t\tPAGE_ALIGN(sw_context->cmd_bounce_size +\n\t\t\t\t   (sw_context->cmd_bounce_size >> 1));\n\t}\n\n\tvfree(sw_context->cmd_bounce);\n\tsw_context->cmd_bounce = vmalloc(sw_context->cmd_bounce_size);\n\n\tif (sw_context->cmd_bounce == NULL) {\n\t\tVMW_DEBUG_USER(\"Failed to allocate command bounce buffer.\\n\");\n\t\tsw_context->cmd_bounce_size = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \n\nint vmw_execbuf_fence_commands(struct drm_file *file_priv,\n\t\t\t       struct vmw_private *dev_priv,\n\t\t\t       struct vmw_fence_obj **p_fence,\n\t\t\t       uint32_t *p_handle)\n{\n\tuint32_t sequence;\n\tint ret;\n\tbool synced = false;\n\n\t \n\tBUG_ON(p_handle != NULL && file_priv == NULL);\n\n\tret = vmw_cmd_send_fence(dev_priv, &sequence);\n\tif (unlikely(ret != 0)) {\n\t\tVMW_DEBUG_USER(\"Fence submission error. Syncing.\\n\");\n\t\tsynced = true;\n\t}\n\n\tif (p_handle != NULL)\n\t\tret = vmw_user_fence_create(file_priv, dev_priv->fman,\n\t\t\t\t\t    sequence, p_fence, p_handle);\n\telse\n\t\tret = vmw_fence_create(dev_priv->fman, sequence, p_fence);\n\n\tif (unlikely(ret != 0 && !synced)) {\n\t\t(void) vmw_fallback_wait(dev_priv, false, false, sequence,\n\t\t\t\t\t false, VMW_FENCE_WAIT_TIMEOUT);\n\t\t*p_fence = NULL;\n\t}\n\n\treturn ret;\n}\n\n \nint\nvmw_execbuf_copy_fence_user(struct vmw_private *dev_priv,\n\t\t\t    struct vmw_fpriv *vmw_fp, int ret,\n\t\t\t    struct drm_vmw_fence_rep __user *user_fence_rep,\n\t\t\t    struct vmw_fence_obj *fence, uint32_t fence_handle,\n\t\t\t    int32_t out_fence_fd)\n{\n\tstruct drm_vmw_fence_rep fence_rep;\n\n\tif (user_fence_rep == NULL)\n\t\treturn 0;\n\n\tmemset(&fence_rep, 0, sizeof(fence_rep));\n\n\tfence_rep.error = ret;\n\tfence_rep.fd = out_fence_fd;\n\tif (ret == 0) {\n\t\tBUG_ON(fence == NULL);\n\n\t\tfence_rep.handle = fence_handle;\n\t\tfence_rep.seqno = fence->base.seqno;\n\t\tvmw_update_seqno(dev_priv);\n\t\tfence_rep.passed_seqno = dev_priv->last_read_seqno;\n\t}\n\n\t \n\tret = copy_to_user(user_fence_rep, &fence_rep,\n\t\t\t   sizeof(fence_rep));\n\n\t \n\tif (unlikely(ret != 0) && (fence_rep.error == 0)) {\n\t\tttm_ref_object_base_unref(vmw_fp->tfile, fence_handle);\n\t\tVMW_DEBUG_USER(\"Fence copy error. Syncing.\\n\");\n\t\t(void) vmw_fence_obj_wait(fence, false, false,\n\t\t\t\t\t  VMW_FENCE_WAIT_TIMEOUT);\n\t}\n\n\treturn ret ? -EFAULT : 0;\n}\n\n \nstatic int vmw_execbuf_submit_fifo(struct vmw_private *dev_priv,\n\t\t\t\t   void *kernel_commands, u32 command_size,\n\t\t\t\t   struct vmw_sw_context *sw_context)\n{\n\tvoid *cmd;\n\n\tif (sw_context->dx_ctx_node)\n\t\tcmd = VMW_CMD_CTX_RESERVE(dev_priv, command_size,\n\t\t\t\t\t  sw_context->dx_ctx_node->ctx->id);\n\telse\n\t\tcmd = VMW_CMD_RESERVE(dev_priv, command_size);\n\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tvmw_apply_relocations(sw_context);\n\tmemcpy(cmd, kernel_commands, command_size);\n\tvmw_resource_relocations_apply(cmd, &sw_context->res_relocations);\n\tvmw_resource_relocations_free(&sw_context->res_relocations);\n\tvmw_cmd_commit(dev_priv, command_size);\n\n\treturn 0;\n}\n\n \nstatic int vmw_execbuf_submit_cmdbuf(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_cmdbuf_header *header,\n\t\t\t\t     u32 command_size,\n\t\t\t\t     struct vmw_sw_context *sw_context)\n{\n\tu32 id = ((sw_context->dx_ctx_node) ? sw_context->dx_ctx_node->ctx->id :\n\t\t  SVGA3D_INVALID_ID);\n\tvoid *cmd = vmw_cmdbuf_reserve(dev_priv->cman, command_size, id, false,\n\t\t\t\t       header);\n\n\tvmw_apply_relocations(sw_context);\n\tvmw_resource_relocations_apply(cmd, &sw_context->res_relocations);\n\tvmw_resource_relocations_free(&sw_context->res_relocations);\n\tvmw_cmdbuf_commit(dev_priv->cman, command_size, header, false);\n\n\treturn 0;\n}\n\n \nstatic void *vmw_execbuf_cmdbuf(struct vmw_private *dev_priv,\n\t\t\t\tvoid __user *user_commands,\n\t\t\t\tvoid *kernel_commands, u32 command_size,\n\t\t\t\tstruct vmw_cmdbuf_header **header)\n{\n\tsize_t cmdbuf_size;\n\tint ret;\n\n\t*header = NULL;\n\tif (command_size > SVGA_CB_MAX_SIZE) {\n\t\tVMW_DEBUG_USER(\"Command buffer is too large.\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!dev_priv->cman || kernel_commands)\n\t\treturn kernel_commands;\n\n\t \n\tcmdbuf_size = command_size + 512;\n\tcmdbuf_size = min_t(size_t, cmdbuf_size, SVGA_CB_MAX_SIZE);\n\tkernel_commands = vmw_cmdbuf_alloc(dev_priv->cman, cmdbuf_size, true,\n\t\t\t\t\t   header);\n\tif (IS_ERR(kernel_commands))\n\t\treturn kernel_commands;\n\n\tret = copy_from_user(kernel_commands, user_commands, command_size);\n\tif (ret) {\n\t\tVMW_DEBUG_USER(\"Failed copying commands.\\n\");\n\t\tvmw_cmdbuf_header_free(*header);\n\t\t*header = NULL;\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn kernel_commands;\n}\n\nstatic int vmw_execbuf_tie_context(struct vmw_private *dev_priv,\n\t\t\t\t   struct vmw_sw_context *sw_context,\n\t\t\t\t   uint32_t handle)\n{\n\tstruct vmw_resource *res;\n\tint ret;\n\tunsigned int size;\n\n\tif (handle == SVGA3D_INVALID_ID)\n\t\treturn 0;\n\n\tsize = vmw_execbuf_res_size(dev_priv, vmw_res_dx_context);\n\tret = vmw_validation_preload_res(sw_context->ctx, size);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vmw_user_resource_lookup_handle\n\t\t(dev_priv, sw_context->fp->tfile, handle,\n\t\t user_context_converter, &res);\n\tif (ret != 0) {\n\t\tVMW_DEBUG_USER(\"Could not find or user DX context 0x%08x.\\n\",\n\t\t\t       (unsigned int) handle);\n\t\treturn ret;\n\t}\n\n\tret = vmw_execbuf_res_val_add(sw_context, res, VMW_RES_DIRTY_SET,\n\t\t\t\t      vmw_val_add_flag_none);\n\tif (unlikely(ret != 0)) {\n\t\tvmw_resource_unreference(&res);\n\t\treturn ret;\n\t}\n\n\tsw_context->dx_ctx_node = vmw_execbuf_info_from_res(sw_context, res);\n\tsw_context->man = vmw_context_res_man(res);\n\n\tvmw_resource_unreference(&res);\n\treturn 0;\n}\n\nint vmw_execbuf_process(struct drm_file *file_priv,\n\t\t\tstruct vmw_private *dev_priv,\n\t\t\tvoid __user *user_commands, void *kernel_commands,\n\t\t\tuint32_t command_size, uint64_t throttle_us,\n\t\t\tuint32_t dx_context_handle,\n\t\t\tstruct drm_vmw_fence_rep __user *user_fence_rep,\n\t\t\tstruct vmw_fence_obj **out_fence, uint32_t flags)\n{\n\tstruct vmw_sw_context *sw_context = &dev_priv->ctx;\n\tstruct vmw_fence_obj *fence = NULL;\n\tstruct vmw_cmdbuf_header *header;\n\tuint32_t handle = 0;\n\tint ret;\n\tint32_t out_fence_fd = -1;\n\tstruct sync_file *sync_file = NULL;\n\tDECLARE_VAL_CONTEXT(val_ctx, sw_context, 1);\n\n\tif (flags & DRM_VMW_EXECBUF_FLAG_EXPORT_FENCE_FD) {\n\t\tout_fence_fd = get_unused_fd_flags(O_CLOEXEC);\n\t\tif (out_fence_fd < 0) {\n\t\t\tVMW_DEBUG_USER(\"Failed to get a fence fd.\\n\");\n\t\t\treturn out_fence_fd;\n\t\t}\n\t}\n\n\tif (throttle_us) {\n\t\tVMW_DEBUG_USER(\"Throttling is no longer supported.\\n\");\n\t}\n\n\tkernel_commands = vmw_execbuf_cmdbuf(dev_priv, user_commands,\n\t\t\t\t\t     kernel_commands, command_size,\n\t\t\t\t\t     &header);\n\tif (IS_ERR(kernel_commands)) {\n\t\tret = PTR_ERR(kernel_commands);\n\t\tgoto out_free_fence_fd;\n\t}\n\n\tret = mutex_lock_interruptible(&dev_priv->cmdbuf_mutex);\n\tif (ret) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_free_header;\n\t}\n\n\tsw_context->kernel = false;\n\tif (kernel_commands == NULL) {\n\t\tret = vmw_resize_cmd_bounce(sw_context, command_size);\n\t\tif (unlikely(ret != 0))\n\t\t\tgoto out_unlock;\n\n\t\tret = copy_from_user(sw_context->cmd_bounce, user_commands,\n\t\t\t\t     command_size);\n\t\tif (unlikely(ret != 0)) {\n\t\t\tret = -EFAULT;\n\t\t\tVMW_DEBUG_USER(\"Failed copying commands.\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tkernel_commands = sw_context->cmd_bounce;\n\t} else if (!header) {\n\t\tsw_context->kernel = true;\n\t}\n\n\tsw_context->filp = file_priv;\n\tsw_context->fp = vmw_fpriv(file_priv);\n\tINIT_LIST_HEAD(&sw_context->ctx_list);\n\tsw_context->cur_query_bo = dev_priv->pinned_bo;\n\tsw_context->last_query_ctx = NULL;\n\tsw_context->needs_post_query_barrier = false;\n\tsw_context->dx_ctx_node = NULL;\n\tsw_context->dx_query_mob = NULL;\n\tsw_context->dx_query_ctx = NULL;\n\tmemset(sw_context->res_cache, 0, sizeof(sw_context->res_cache));\n\tINIT_LIST_HEAD(&sw_context->res_relocations);\n\tINIT_LIST_HEAD(&sw_context->bo_relocations);\n\n\tif (sw_context->staged_bindings)\n\t\tvmw_binding_state_reset(sw_context->staged_bindings);\n\n\tINIT_LIST_HEAD(&sw_context->staged_cmd_res);\n\tsw_context->ctx = &val_ctx;\n\tret = vmw_execbuf_tie_context(dev_priv, sw_context, dx_context_handle);\n\tif (unlikely(ret != 0))\n\t\tgoto out_err_nores;\n\n\tret = vmw_cmd_check_all(dev_priv, sw_context, kernel_commands,\n\t\t\t\tcommand_size);\n\tif (unlikely(ret != 0))\n\t\tgoto out_err_nores;\n\n\tret = vmw_resources_reserve(sw_context);\n\tif (unlikely(ret != 0))\n\t\tgoto out_err_nores;\n\n\tret = vmw_validation_bo_reserve(&val_ctx, true);\n\tif (unlikely(ret != 0))\n\t\tgoto out_err_nores;\n\n\tret = vmw_validation_bo_validate(&val_ctx, true);\n\tif (unlikely(ret != 0))\n\t\tgoto out_err;\n\n\tret = vmw_validation_res_validate(&val_ctx, true);\n\tif (unlikely(ret != 0))\n\t\tgoto out_err;\n\n\tvmw_validation_drop_ht(&val_ctx);\n\n\tret = mutex_lock_interruptible(&dev_priv->binding_mutex);\n\tif (unlikely(ret != 0)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_err;\n\t}\n\n\tif (dev_priv->has_mob) {\n\t\tret = vmw_rebind_contexts(sw_context);\n\t\tif (unlikely(ret != 0))\n\t\t\tgoto out_unlock_binding;\n\t}\n\n\tif (!header) {\n\t\tret = vmw_execbuf_submit_fifo(dev_priv, kernel_commands,\n\t\t\t\t\t      command_size, sw_context);\n\t} else {\n\t\tret = vmw_execbuf_submit_cmdbuf(dev_priv, header, command_size,\n\t\t\t\t\t\tsw_context);\n\t\theader = NULL;\n\t}\n\tmutex_unlock(&dev_priv->binding_mutex);\n\tif (ret)\n\t\tgoto out_err;\n\n\tvmw_query_bo_switch_commit(dev_priv, sw_context);\n\tret = vmw_execbuf_fence_commands(file_priv, dev_priv, &fence,\n\t\t\t\t\t (user_fence_rep) ? &handle : NULL);\n\t \n\tif (ret != 0)\n\t\tVMW_DEBUG_USER(\"Fence submission error. Syncing.\\n\");\n\n\tvmw_execbuf_bindings_commit(sw_context, false);\n\tvmw_bind_dx_query_mob(sw_context);\n\tvmw_validation_res_unreserve(&val_ctx, false);\n\n\tvmw_validation_bo_fence(sw_context->ctx, fence);\n\n\tif (unlikely(dev_priv->pinned_bo != NULL && !dev_priv->query_cid_valid))\n\t\t__vmw_execbuf_release_pinned_bo(dev_priv, fence);\n\n\t \n\tif (flags & DRM_VMW_EXECBUF_FLAG_EXPORT_FENCE_FD) {\n\n\t\tsync_file = sync_file_create(&fence->base);\n\t\tif (!sync_file) {\n\t\t\tVMW_DEBUG_USER(\"Sync file create failed for fence\\n\");\n\t\t\tput_unused_fd(out_fence_fd);\n\t\t\tout_fence_fd = -1;\n\n\t\t\t(void) vmw_fence_obj_wait(fence, false, false,\n\t\t\t\t\t\t  VMW_FENCE_WAIT_TIMEOUT);\n\t\t}\n\t}\n\n\tret = vmw_execbuf_copy_fence_user(dev_priv, vmw_fpriv(file_priv), ret,\n\t\t\t\t    user_fence_rep, fence, handle, out_fence_fd);\n\n\tif (sync_file) {\n\t\tif (ret) {\n\t\t\t \n\t\t\tfput(sync_file->file);\n\t\t\tput_unused_fd(out_fence_fd);\n\t\t} else {\n\t\t\t \n\t\t\tfd_install(out_fence_fd, sync_file->file);\n\t\t}\n\t}\n\n\t \n\tif (unlikely(out_fence != NULL)) {\n\t\t*out_fence = fence;\n\t\tfence = NULL;\n\t} else if (likely(fence != NULL)) {\n\t\tvmw_fence_obj_unreference(&fence);\n\t}\n\n\tvmw_cmdbuf_res_commit(&sw_context->staged_cmd_res);\n\tmutex_unlock(&dev_priv->cmdbuf_mutex);\n\n\t \n\tvmw_validation_unref_lists(&val_ctx);\n\n\treturn ret;\n\nout_unlock_binding:\n\tmutex_unlock(&dev_priv->binding_mutex);\nout_err:\n\tvmw_validation_bo_backoff(&val_ctx);\nout_err_nores:\n\tvmw_execbuf_bindings_commit(sw_context, true);\n\tvmw_validation_res_unreserve(&val_ctx, true);\n\tvmw_resource_relocations_free(&sw_context->res_relocations);\n\tvmw_free_relocations(sw_context);\n\tif (unlikely(dev_priv->pinned_bo != NULL && !dev_priv->query_cid_valid))\n\t\t__vmw_execbuf_release_pinned_bo(dev_priv, NULL);\nout_unlock:\n\tvmw_cmdbuf_res_revert(&sw_context->staged_cmd_res);\n\tvmw_validation_drop_ht(&val_ctx);\n\tWARN_ON(!list_empty(&sw_context->ctx_list));\n\tmutex_unlock(&dev_priv->cmdbuf_mutex);\n\n\t \n\tvmw_validation_unref_lists(&val_ctx);\nout_free_header:\n\tif (header)\n\t\tvmw_cmdbuf_header_free(header);\nout_free_fence_fd:\n\tif (out_fence_fd >= 0)\n\t\tput_unused_fd(out_fence_fd);\n\n\treturn ret;\n}\n\n \nstatic void vmw_execbuf_unpin_panic(struct vmw_private *dev_priv)\n{\n\tVMW_DEBUG_USER(\"Can't unpin query buffer. Trying to recover.\\n\");\n\n\t(void) vmw_fallback_wait(dev_priv, false, true, 0, false, 10*HZ);\n\tvmw_bo_pin_reserved(dev_priv->pinned_bo, false);\n\tif (dev_priv->dummy_query_bo_pinned) {\n\t\tvmw_bo_pin_reserved(dev_priv->dummy_query_bo, false);\n\t\tdev_priv->dummy_query_bo_pinned = false;\n\t}\n}\n\n\n \nvoid __vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv,\n\t\t\t\t     struct vmw_fence_obj *fence)\n{\n\tint ret = 0;\n\tstruct vmw_fence_obj *lfence = NULL;\n\tDECLARE_VAL_CONTEXT(val_ctx, NULL, 0);\n\n\tif (dev_priv->pinned_bo == NULL)\n\t\tgoto out_unlock;\n\n\tvmw_bo_placement_set(dev_priv->pinned_bo,\n\t\t\t     VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM,\n\t\t\t     VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM);\n\tret = vmw_validation_add_bo(&val_ctx, dev_priv->pinned_bo);\n\tif (ret)\n\t\tgoto out_no_reserve;\n\n\tvmw_bo_placement_set(dev_priv->dummy_query_bo,\n\t\t\t     VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM,\n\t\t\t     VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM);\n\tret = vmw_validation_add_bo(&val_ctx, dev_priv->dummy_query_bo);\n\tif (ret)\n\t\tgoto out_no_reserve;\n\n\tret = vmw_validation_bo_reserve(&val_ctx, false);\n\tif (ret)\n\t\tgoto out_no_reserve;\n\n\tif (dev_priv->query_cid_valid) {\n\t\tBUG_ON(fence != NULL);\n\t\tret = vmw_cmd_emit_dummy_query(dev_priv, dev_priv->query_cid);\n\t\tif (ret)\n\t\t\tgoto out_no_emit;\n\t\tdev_priv->query_cid_valid = false;\n\t}\n\n\tvmw_bo_pin_reserved(dev_priv->pinned_bo, false);\n\tif (dev_priv->dummy_query_bo_pinned) {\n\t\tvmw_bo_pin_reserved(dev_priv->dummy_query_bo, false);\n\t\tdev_priv->dummy_query_bo_pinned = false;\n\t}\n\tif (fence == NULL) {\n\t\t(void) vmw_execbuf_fence_commands(NULL, dev_priv, &lfence,\n\t\t\t\t\t\t  NULL);\n\t\tfence = lfence;\n\t}\n\tvmw_validation_bo_fence(&val_ctx, fence);\n\tif (lfence != NULL)\n\t\tvmw_fence_obj_unreference(&lfence);\n\n\tvmw_validation_unref_lists(&val_ctx);\n\tvmw_bo_unreference(&dev_priv->pinned_bo);\n\nout_unlock:\n\treturn;\nout_no_emit:\n\tvmw_validation_bo_backoff(&val_ctx);\nout_no_reserve:\n\tvmw_validation_unref_lists(&val_ctx);\n\tvmw_execbuf_unpin_panic(dev_priv);\n\tvmw_bo_unreference(&dev_priv->pinned_bo);\n}\n\n \nvoid vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv)\n{\n\tmutex_lock(&dev_priv->cmdbuf_mutex);\n\tif (dev_priv->query_cid_valid)\n\t\t__vmw_execbuf_release_pinned_bo(dev_priv, NULL);\n\tmutex_unlock(&dev_priv->cmdbuf_mutex);\n}\n\nint vmw_execbuf_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct drm_vmw_execbuf_arg *arg = data;\n\tint ret;\n\tstruct dma_fence *in_fence = NULL;\n\n\tMKS_STAT_TIME_DECL(MKSSTAT_KERN_EXECBUF);\n\tMKS_STAT_TIME_PUSH(MKSSTAT_KERN_EXECBUF);\n\n\t \n\tif (unlikely(arg->version > DRM_VMW_EXECBUF_VERSION ||\n\t\t     arg->version == 0)) {\n\t\tVMW_DEBUG_USER(\"Incorrect execbuf version.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto mksstats_out;\n\t}\n\n\tswitch (arg->version) {\n\tcase 1:\n\t\t \n\t\targ->context_handle = (uint32_t) -1;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tif (arg->flags & DRM_VMW_EXECBUF_FLAG_IMPORT_FENCE_FD) {\n\t\tin_fence = sync_file_get_fence(arg->imported_fence_fd);\n\n\t\tif (!in_fence) {\n\t\t\tVMW_DEBUG_USER(\"Cannot get imported fence\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto mksstats_out;\n\t\t}\n\n\t\tret = dma_fence_wait(in_fence, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = vmw_execbuf_process(file_priv, dev_priv,\n\t\t\t\t  (void __user *)(unsigned long)arg->commands,\n\t\t\t\t  NULL, arg->command_size, arg->throttle_us,\n\t\t\t\t  arg->context_handle,\n\t\t\t\t  (void __user *)(unsigned long)arg->fence_rep,\n\t\t\t\t  NULL, arg->flags);\n\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tvmw_kms_cursor_post_execbuf(dev_priv);\n\nout:\n\tif (in_fence)\n\t\tdma_fence_put(in_fence);\n\nmksstats_out:\n\tMKS_STAT_TIME_POP(MKSSTAT_KERN_EXECBUF);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}