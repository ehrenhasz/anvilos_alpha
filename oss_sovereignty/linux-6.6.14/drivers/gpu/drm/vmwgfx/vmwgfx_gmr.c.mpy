{
  "module_name": "vmwgfx_gmr.c",
  "hash_id": "8007bc2a598b137e375862b299e95c31aa57eff126b6216ef7789f798b1378e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c",
  "human_readable_source": "\n \n\n\n#include \"vmwgfx_drv.h\"\n\n#define VMW_PPN_SIZE (sizeof(unsigned long))\n \n#define VMW_PPN_PER_REMAP ((31 * 1024) / VMW_PPN_SIZE)\n#define DMA_ADDR_INVALID ((dma_addr_t) 0)\n#define DMA_PAGE_INVALID 0UL\n\nstatic int vmw_gmr2_bind(struct vmw_private *dev_priv,\n\t\t\t struct vmw_piter *iter,\n\t\t\t unsigned long num_pages,\n\t\t\t int gmr_id)\n{\n\tSVGAFifoCmdDefineGMR2 define_cmd;\n\tSVGAFifoCmdRemapGMR2 remap_cmd;\n\tuint32_t *cmd;\n\tuint32_t *cmd_orig;\n\tuint32_t define_size = sizeof(define_cmd) + sizeof(*cmd);\n\tuint32_t remap_num = num_pages / VMW_PPN_PER_REMAP + ((num_pages % VMW_PPN_PER_REMAP) > 0);\n\tuint32_t remap_size = VMW_PPN_SIZE * num_pages + (sizeof(remap_cmd) + sizeof(*cmd)) * remap_num;\n\tuint32_t remap_pos = 0;\n\tuint32_t cmd_size = define_size + remap_size;\n\tuint32_t i;\n\n\tcmd_orig = cmd = VMW_CMD_RESERVE(dev_priv, cmd_size);\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tdefine_cmd.gmrId = gmr_id;\n\tdefine_cmd.numPages = num_pages;\n\n\t*cmd++ = SVGA_CMD_DEFINE_GMR2;\n\tmemcpy(cmd, &define_cmd, sizeof(define_cmd));\n\tcmd += sizeof(define_cmd) / sizeof(*cmd);\n\n\t \n\n\tremap_cmd.gmrId = gmr_id;\n\tremap_cmd.flags = (VMW_PPN_SIZE > sizeof(*cmd)) ?\n\t\tSVGA_REMAP_GMR2_PPN64 : SVGA_REMAP_GMR2_PPN32;\n\n\twhile (num_pages > 0) {\n\t\tunsigned long nr = min_t(unsigned long, num_pages, VMW_PPN_PER_REMAP);\n\n\t\tremap_cmd.offsetPages = remap_pos;\n\t\tremap_cmd.numPages = nr;\n\n\t\t*cmd++ = SVGA_CMD_REMAP_GMR2;\n\t\tmemcpy(cmd, &remap_cmd, sizeof(remap_cmd));\n\t\tcmd += sizeof(remap_cmd) / sizeof(*cmd);\n\n\t\tfor (i = 0; i < nr; ++i) {\n\t\t\tif (VMW_PPN_SIZE <= 4)\n\t\t\t\t*cmd = vmw_piter_dma_addr(iter) >> PAGE_SHIFT;\n\t\t\telse\n\t\t\t\t*((uint64_t *)cmd) = vmw_piter_dma_addr(iter) >>\n\t\t\t\t\tPAGE_SHIFT;\n\n\t\t\tcmd += VMW_PPN_SIZE / sizeof(*cmd);\n\t\t\tvmw_piter_next(iter);\n\t\t}\n\n\t\tnum_pages -= nr;\n\t\tremap_pos += nr;\n\t}\n\n\tBUG_ON(cmd != cmd_orig + cmd_size / sizeof(*cmd));\n\n\tvmw_cmd_commit(dev_priv, cmd_size);\n\n\treturn 0;\n}\n\nstatic void vmw_gmr2_unbind(struct vmw_private *dev_priv,\n\t\t\t    int gmr_id)\n{\n\tSVGAFifoCmdDefineGMR2 define_cmd;\n\tuint32_t define_size = sizeof(define_cmd) + 4;\n\tuint32_t *cmd;\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, define_size);\n\tif (unlikely(cmd == NULL))\n\t\treturn;\n\n\tdefine_cmd.gmrId = gmr_id;\n\tdefine_cmd.numPages = 0;\n\n\t*cmd++ = SVGA_CMD_DEFINE_GMR2;\n\tmemcpy(cmd, &define_cmd, sizeof(define_cmd));\n\n\tvmw_cmd_commit(dev_priv, define_size);\n}\n\n\nint vmw_gmr_bind(struct vmw_private *dev_priv,\n\t\t const struct vmw_sg_table *vsgt,\n\t\t unsigned long num_pages,\n\t\t int gmr_id)\n{\n\tstruct vmw_piter data_iter;\n\n\tvmw_piter_start(&data_iter, vsgt, 0);\n\n\tif (unlikely(!vmw_piter_next(&data_iter)))\n\t\treturn 0;\n\n\tif (unlikely(!(dev_priv->capabilities & SVGA_CAP_GMR2)))\n\t\treturn -EINVAL;\n\n\treturn vmw_gmr2_bind(dev_priv, &data_iter, num_pages, gmr_id);\n}\n\n\nvoid vmw_gmr_unbind(struct vmw_private *dev_priv, int gmr_id)\n{\n\tif (likely(dev_priv->capabilities & SVGA_CAP_GMR2))\n\t\tvmw_gmr2_unbind(dev_priv, gmr_id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}