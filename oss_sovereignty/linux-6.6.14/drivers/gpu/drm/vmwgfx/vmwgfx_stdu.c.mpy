{
  "module_name": "vmwgfx_stdu.c",
  "hash_id": "37524a8afb17666b036fc1a80e8437f83d22935b0e3f7ef34773e75347879e63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c",
  "human_readable_source": "\n \n\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_kms.h\"\n#include \"vmw_surface_cache.h\"\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_fourcc.h>\n\n#define vmw_crtc_to_stdu(x) \\\n\tcontainer_of(x, struct vmw_screen_target_display_unit, base.crtc)\n#define vmw_encoder_to_stdu(x) \\\n\tcontainer_of(x, struct vmw_screen_target_display_unit, base.encoder)\n#define vmw_connector_to_stdu(x) \\\n\tcontainer_of(x, struct vmw_screen_target_display_unit, base.connector)\n\n\n\nenum stdu_content_type {\n\tSAME_AS_DISPLAY = 0,\n\tSEPARATE_SURFACE,\n\tSEPARATE_BO\n};\n\n \nstruct vmw_stdu_dirty {\n\tstruct vmw_kms_dirty base;\n\ts32 left, right, top, bottom;\n\ts32 fb_left, fb_top;\n\tu32 pitch;\n\tunion {\n\t\tstruct vmw_bo *buf;\n\t\tu32 sid;\n\t};\n};\n\n \nstruct vmw_stdu_update {\n\tSVGA3dCmdHeader header;\n\tSVGA3dCmdUpdateGBScreenTarget body;\n};\n\nstruct vmw_stdu_dma {\n\tSVGA3dCmdHeader     header;\n\tSVGA3dCmdSurfaceDMA body;\n};\n\nstruct vmw_stdu_surface_copy {\n\tSVGA3dCmdHeader      header;\n\tSVGA3dCmdSurfaceCopy body;\n};\n\nstruct vmw_stdu_update_gb_image {\n\tSVGA3dCmdHeader header;\n\tSVGA3dCmdUpdateGBImage body;\n};\n\n \nstruct vmw_screen_target_display_unit {\n\tstruct vmw_display_unit base;\n\tstruct vmw_surface *display_srf;\n\tenum stdu_content_type content_fb_type;\n\ts32 display_width, display_height;\n\n\tbool defined;\n\n\t \n\tunsigned int cpp;\n};\n\n\n\nstatic void vmw_stdu_destroy(struct vmw_screen_target_display_unit *stdu);\n\n\n\n \n\n \nstatic void vmw_stdu_crtc_destroy(struct drm_crtc *crtc)\n{\n\tvmw_stdu_destroy(vmw_crtc_to_stdu(crtc));\n}\n\n \nstatic int vmw_stdu_define_st(struct vmw_private *dev_priv,\n\t\t\t      struct vmw_screen_target_display_unit *stdu,\n\t\t\t      struct drm_display_mode *mode,\n\t\t\t      int crtc_x, int crtc_y)\n{\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDefineGBScreenTarget body;\n\t} *cmd;\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id   = SVGA_3D_CMD_DEFINE_GB_SCREENTARGET;\n\tcmd->header.size = sizeof(cmd->body);\n\n\tcmd->body.stid   = stdu->base.unit;\n\tcmd->body.width  = mode->hdisplay;\n\tcmd->body.height = mode->vdisplay;\n\tcmd->body.flags  = (0 == cmd->body.stid) ? SVGA_STFLAG_PRIMARY : 0;\n\tcmd->body.dpi    = 0;\n\tcmd->body.xRoot  = crtc_x;\n\tcmd->body.yRoot  = crtc_y;\n\n\tstdu->base.set_gui_x = cmd->body.xRoot;\n\tstdu->base.set_gui_y = cmd->body.yRoot;\n\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\tstdu->defined = true;\n\tstdu->display_width  = mode->hdisplay;\n\tstdu->display_height = mode->vdisplay;\n\n\treturn 0;\n}\n\n\n\n \nstatic int vmw_stdu_bind_st(struct vmw_private *dev_priv,\n\t\t\t    struct vmw_screen_target_display_unit *stdu,\n\t\t\t    const struct vmw_resource *res)\n{\n\tSVGA3dSurfaceImageId image;\n\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdBindGBScreenTarget body;\n\t} *cmd;\n\n\n\tif (!stdu->defined) {\n\t\tDRM_ERROR(\"No screen target defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset(&image, 0, sizeof(image));\n\timage.sid = res ? res->id : SVGA3D_INVALID_ID;\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id   = SVGA_3D_CMD_BIND_GB_SCREENTARGET;\n\tcmd->header.size = sizeof(cmd->body);\n\n\tcmd->body.stid   = stdu->base.unit;\n\tcmd->body.image  = image;\n\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\treturn 0;\n}\n\n \nstatic void vmw_stdu_populate_update(void *cmd, int unit,\n\t\t\t\t     s32 left, s32 right, s32 top, s32 bottom)\n{\n\tstruct vmw_stdu_update *update = cmd;\n\n\tupdate->header.id   = SVGA_3D_CMD_UPDATE_GB_SCREENTARGET;\n\tupdate->header.size = sizeof(update->body);\n\n\tupdate->body.stid   = unit;\n\tupdate->body.rect.x = left;\n\tupdate->body.rect.y = top;\n\tupdate->body.rect.w = right - left;\n\tupdate->body.rect.h = bottom - top;\n}\n\n \nstatic int vmw_stdu_update_st(struct vmw_private *dev_priv,\n\t\t\t      struct vmw_screen_target_display_unit *stdu)\n{\n\tstruct vmw_stdu_update *cmd;\n\n\tif (!stdu->defined) {\n\t\tDRM_ERROR(\"No screen target defined\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tvmw_stdu_populate_update(cmd, stdu->base.unit,\n\t\t\t\t 0, stdu->display_width,\n\t\t\t\t 0, stdu->display_height);\n\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\treturn 0;\n}\n\n\n\n \nstatic int vmw_stdu_destroy_st(struct vmw_private *dev_priv,\n\t\t\t       struct vmw_screen_target_display_unit *stdu)\n{\n\tint    ret;\n\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDestroyGBScreenTarget body;\n\t} *cmd;\n\n\n\t \n\tif (unlikely(!stdu->defined))\n\t\treturn 0;\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id   = SVGA_3D_CMD_DESTROY_GB_SCREENTARGET;\n\tcmd->header.size = sizeof(cmd->body);\n\n\tcmd->body.stid   = stdu->base.unit;\n\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\t \n\tret = vmw_fallback_wait(dev_priv, false, true, 0, false, 3*HZ);\n\tif (unlikely(ret != 0))\n\t\tDRM_ERROR(\"Failed to sync with HW\");\n\n\tstdu->defined = false;\n\tstdu->display_width  = 0;\n\tstdu->display_height = 0;\n\n\treturn ret;\n}\n\n\n \nstatic void vmw_stdu_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct vmw_private *dev_priv;\n\tstruct vmw_screen_target_display_unit *stdu;\n\tstruct drm_connector_state *conn_state;\n\tstruct vmw_connector_state *vmw_conn_state;\n\tint x, y, ret;\n\n\tstdu = vmw_crtc_to_stdu(crtc);\n\tdev_priv = vmw_priv(crtc->dev);\n\tconn_state = stdu->base.connector.state;\n\tvmw_conn_state = vmw_connector_state_to_vcs(conn_state);\n\n\tif (stdu->defined) {\n\t\tret = vmw_stdu_bind_st(dev_priv, stdu, NULL);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to blank CRTC\\n\");\n\n\t\t(void) vmw_stdu_update_st(dev_priv, stdu);\n\n\t\tret = vmw_stdu_destroy_st(dev_priv, stdu);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to destroy Screen Target\\n\");\n\n\t\tstdu->content_fb_type = SAME_AS_DISPLAY;\n\t}\n\n\tif (!crtc->state->enable)\n\t\treturn;\n\n\tx = vmw_conn_state->gui_x;\n\ty = vmw_conn_state->gui_y;\n\n\tvmw_svga_enable(dev_priv);\n\tret = vmw_stdu_define_st(dev_priv, stdu, &crtc->mode, x, y);\n\n\tif (ret)\n\t\tDRM_ERROR(\"Failed to define Screen Target of size %dx%d\\n\",\n\t\t\t  crtc->x, crtc->y);\n}\n\n\nstatic void vmw_stdu_crtc_helper_prepare(struct drm_crtc *crtc)\n{\n}\n\nstatic void vmw_stdu_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n}\n\nstatic void vmw_stdu_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct vmw_private *dev_priv;\n\tstruct vmw_screen_target_display_unit *stdu;\n\tint ret;\n\n\n\tif (!crtc) {\n\t\tDRM_ERROR(\"CRTC is NULL\\n\");\n\t\treturn;\n\t}\n\n\tstdu     = vmw_crtc_to_stdu(crtc);\n\tdev_priv = vmw_priv(crtc->dev);\n\n\tif (stdu->defined) {\n\t\tret = vmw_stdu_bind_st(dev_priv, stdu, NULL);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to blank CRTC\\n\");\n\n\t\t(void) vmw_stdu_update_st(dev_priv, stdu);\n\n\t\tret = vmw_stdu_destroy_st(dev_priv, stdu);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to destroy Screen Target\\n\");\n\n\t\tstdu->content_fb_type = SAME_AS_DISPLAY;\n\t}\n}\n\n \nstatic void vmw_stdu_bo_cpu_clip(struct vmw_kms_dirty *dirty)\n{\n\tstruct vmw_stdu_dirty *ddirty =\n\t\tcontainer_of(dirty, struct vmw_stdu_dirty, base);\n\n\tdirty->num_hits = 1;\n\n\t \n\tddirty->left = min_t(s32, ddirty->left, dirty->unit_x1);\n\tddirty->top = min_t(s32, ddirty->top, dirty->unit_y1);\n\tddirty->right = max_t(s32, ddirty->right, dirty->unit_x2);\n\tddirty->bottom = max_t(s32, ddirty->bottom, dirty->unit_y2);\n\n\t \n\tddirty->fb_left = min_t(s32, ddirty->fb_left, dirty->fb_x);\n\tddirty->fb_top  = min_t(s32, ddirty->fb_top, dirty->fb_y);\n}\n\n\n \nstatic void vmw_stdu_bo_cpu_commit(struct vmw_kms_dirty *dirty)\n{\n\tstruct vmw_stdu_dirty *ddirty =\n\t\tcontainer_of(dirty, struct vmw_stdu_dirty, base);\n\tstruct vmw_screen_target_display_unit *stdu =\n\t\tcontainer_of(dirty->unit, typeof(*stdu), base);\n\ts32 width, height;\n\ts32 src_pitch, dst_pitch;\n\tstruct ttm_buffer_object *src_bo, *dst_bo;\n\tu32 src_offset, dst_offset;\n\tstruct vmw_diff_cpy diff = VMW_CPU_BLIT_DIFF_INITIALIZER(stdu->cpp);\n\n\tif (!dirty->num_hits)\n\t\treturn;\n\n\twidth = ddirty->right - ddirty->left;\n\theight = ddirty->bottom - ddirty->top;\n\n\tif (width == 0 || height == 0)\n\t\treturn;\n\n\t \n\tsrc_pitch = stdu->display_srf->metadata.base_size.width * stdu->cpp;\n\tsrc_bo = &stdu->display_srf->res.guest_memory_bo->tbo;\n\tsrc_offset = ddirty->top * src_pitch + ddirty->left * stdu->cpp;\n\n\tdst_pitch = ddirty->pitch;\n\tdst_bo = &ddirty->buf->tbo;\n\tdst_offset = ddirty->fb_top * dst_pitch + ddirty->fb_left * stdu->cpp;\n\n\t(void) vmw_bo_cpu_blit(dst_bo, dst_offset, dst_pitch,\n\t\t\t       src_bo, src_offset, src_pitch,\n\t\t\t       width * stdu->cpp, height, &diff);\n}\n\n \nint vmw_kms_stdu_readback(struct vmw_private *dev_priv,\n\t\t\t  struct drm_file *file_priv,\n\t\t\t  struct vmw_framebuffer *vfb,\n\t\t\t  struct drm_vmw_fence_rep __user *user_fence_rep,\n\t\t\t  struct drm_clip_rect *clips,\n\t\t\t  struct drm_vmw_rect *vclips,\n\t\t\t  uint32_t num_clips,\n\t\t\t  int increment,\n\t\t\t  struct drm_crtc *crtc)\n{\n\tstruct vmw_bo *buf =\n\t\tcontainer_of(vfb, struct vmw_framebuffer_bo, base)->buffer;\n\tstruct vmw_stdu_dirty ddirty;\n\tint ret;\n\tDECLARE_VAL_CONTEXT(val_ctx, NULL, 0);\n\n\t \n\tvmw_bo_placement_set(buf,\n\t\t\t     VMW_BO_DOMAIN_MOB | VMW_BO_DOMAIN_SYS | VMW_BO_DOMAIN_GMR,\n\t\t\t     VMW_BO_DOMAIN_MOB | VMW_BO_DOMAIN_SYS | VMW_BO_DOMAIN_GMR);\n\tret = vmw_validation_add_bo(&val_ctx, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vmw_validation_prepare(&val_ctx, NULL, true);\n\tif (ret)\n\t\tgoto out_unref;\n\n\tddirty.left = ddirty.top = S32_MAX;\n\tddirty.right = ddirty.bottom = S32_MIN;\n\tddirty.fb_left = ddirty.fb_top = S32_MAX;\n\tddirty.pitch = vfb->base.pitches[0];\n\tddirty.buf = buf;\n\n\tddirty.base.fifo_commit = vmw_stdu_bo_cpu_commit;\n\tddirty.base.clip = vmw_stdu_bo_cpu_clip;\n\tddirty.base.fifo_reserve_size = 0;\n\n\tddirty.base.crtc = crtc;\n\n\tret = vmw_kms_helper_dirty(dev_priv, vfb, clips, vclips,\n\t\t\t\t   0, 0, num_clips, increment, &ddirty.base);\n\n\tvmw_kms_helper_validation_finish(dev_priv, file_priv, &val_ctx, NULL,\n\t\t\t\t\t user_fence_rep);\n\treturn ret;\n\nout_unref:\n\tvmw_validation_unref_lists(&val_ctx);\n\treturn ret;\n}\n\n \nstatic void vmw_kms_stdu_surface_clip(struct vmw_kms_dirty *dirty)\n{\n\tstruct vmw_stdu_dirty *sdirty =\n\t\tcontainer_of(dirty, struct vmw_stdu_dirty, base);\n\tstruct vmw_stdu_surface_copy *cmd = dirty->cmd;\n\tstruct vmw_screen_target_display_unit *stdu =\n\t\tcontainer_of(dirty->unit, typeof(*stdu), base);\n\n\tif (sdirty->sid != stdu->display_srf->res.id) {\n\t\tstruct SVGA3dCopyBox *blit = (struct SVGA3dCopyBox *) &cmd[1];\n\n\t\tblit += dirty->num_hits;\n\t\tblit->srcx = dirty->fb_x;\n\t\tblit->srcy = dirty->fb_y;\n\t\tblit->x = dirty->unit_x1;\n\t\tblit->y = dirty->unit_y1;\n\t\tblit->d = 1;\n\t\tblit->w = dirty->unit_x2 - dirty->unit_x1;\n\t\tblit->h = dirty->unit_y2 - dirty->unit_y1;\n\t}\n\n\tdirty->num_hits++;\n\n\t \n\tsdirty->left = min_t(s32, sdirty->left, dirty->unit_x1);\n\tsdirty->top = min_t(s32, sdirty->top, dirty->unit_y1);\n\tsdirty->right = max_t(s32, sdirty->right, dirty->unit_x2);\n\tsdirty->bottom = max_t(s32, sdirty->bottom, dirty->unit_y2);\n}\n\n \nstatic void vmw_kms_stdu_surface_fifo_commit(struct vmw_kms_dirty *dirty)\n{\n\tstruct vmw_stdu_dirty *sdirty =\n\t\tcontainer_of(dirty, struct vmw_stdu_dirty, base);\n\tstruct vmw_screen_target_display_unit *stdu =\n\t\tcontainer_of(dirty->unit, typeof(*stdu), base);\n\tstruct vmw_stdu_surface_copy *cmd = dirty->cmd;\n\tstruct vmw_stdu_update *update;\n\tsize_t blit_size = sizeof(SVGA3dCopyBox) * dirty->num_hits;\n\tsize_t commit_size;\n\n\tif (!dirty->num_hits) {\n\t\tvmw_cmd_commit(dirty->dev_priv, 0);\n\t\treturn;\n\t}\n\n\tif (sdirty->sid != stdu->display_srf->res.id) {\n\t\tstruct SVGA3dCopyBox *blit = (struct SVGA3dCopyBox *) &cmd[1];\n\n\t\tcmd->header.id = SVGA_3D_CMD_SURFACE_COPY;\n\t\tcmd->header.size = sizeof(cmd->body) + blit_size;\n\t\tcmd->body.src.sid = sdirty->sid;\n\t\tcmd->body.dest.sid = stdu->display_srf->res.id;\n\t\tupdate = (struct vmw_stdu_update *) &blit[dirty->num_hits];\n\t\tcommit_size = sizeof(*cmd) + blit_size + sizeof(*update);\n\t\tstdu->display_srf->res.res_dirty = true;\n\t} else {\n\t\tupdate = dirty->cmd;\n\t\tcommit_size = sizeof(*update);\n\t}\n\n\tvmw_stdu_populate_update(update, stdu->base.unit, sdirty->left,\n\t\t\t\t sdirty->right, sdirty->top, sdirty->bottom);\n\n\tvmw_cmd_commit(dirty->dev_priv, commit_size);\n\n\tsdirty->left = sdirty->top = S32_MAX;\n\tsdirty->right = sdirty->bottom = S32_MIN;\n}\n\n \nint vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,\n\t\t\t       struct vmw_framebuffer *framebuffer,\n\t\t\t       struct drm_clip_rect *clips,\n\t\t\t       struct drm_vmw_rect *vclips,\n\t\t\t       struct vmw_resource *srf,\n\t\t\t       s32 dest_x,\n\t\t\t       s32 dest_y,\n\t\t\t       unsigned num_clips, int inc,\n\t\t\t       struct vmw_fence_obj **out_fence,\n\t\t\t       struct drm_crtc *crtc)\n{\n\tstruct vmw_framebuffer_surface *vfbs =\n\t\tcontainer_of(framebuffer, typeof(*vfbs), base);\n\tstruct vmw_stdu_dirty sdirty;\n\tDECLARE_VAL_CONTEXT(val_ctx, NULL, 0);\n\tint ret;\n\n\tif (!srf)\n\t\tsrf = &vfbs->surface->res;\n\n\tret = vmw_validation_add_resource(&val_ctx, srf, 0, VMW_RES_DIRTY_NONE,\n\t\t\t\t\t  NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vmw_validation_prepare(&val_ctx, &dev_priv->cmdbuf_mutex, true);\n\tif (ret)\n\t\tgoto out_unref;\n\n\tif (vfbs->is_bo_proxy) {\n\t\tret = vmw_kms_update_proxy(srf, clips, num_clips, inc);\n\t\tif (ret)\n\t\t\tgoto out_finish;\n\t}\n\n\tsdirty.base.fifo_commit = vmw_kms_stdu_surface_fifo_commit;\n\tsdirty.base.clip = vmw_kms_stdu_surface_clip;\n\tsdirty.base.fifo_reserve_size = sizeof(struct vmw_stdu_surface_copy) +\n\t\tsizeof(SVGA3dCopyBox) * num_clips +\n\t\tsizeof(struct vmw_stdu_update);\n\tsdirty.base.crtc = crtc;\n\tsdirty.sid = srf->id;\n\tsdirty.left = sdirty.top = S32_MAX;\n\tsdirty.right = sdirty.bottom = S32_MIN;\n\n\tret = vmw_kms_helper_dirty(dev_priv, framebuffer, clips, vclips,\n\t\t\t\t   dest_x, dest_y, num_clips, inc,\n\t\t\t\t   &sdirty.base);\nout_finish:\n\tvmw_kms_helper_validation_finish(dev_priv, NULL, &val_ctx, out_fence,\n\t\t\t\t\t NULL);\n\n\treturn ret;\n\nout_unref:\n\tvmw_validation_unref_lists(&val_ctx);\n\treturn ret;\n}\n\n\n \nstatic const struct drm_crtc_funcs vmw_stdu_crtc_funcs = {\n\t.gamma_set = vmw_du_crtc_gamma_set,\n\t.destroy = vmw_stdu_crtc_destroy,\n\t.reset = vmw_du_crtc_reset,\n\t.atomic_duplicate_state = vmw_du_crtc_duplicate_state,\n\t.atomic_destroy_state = vmw_du_crtc_destroy_state,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n};\n\n\n\n \n\n \nstatic void vmw_stdu_encoder_destroy(struct drm_encoder *encoder)\n{\n\tvmw_stdu_destroy(vmw_encoder_to_stdu(encoder));\n}\n\nstatic const struct drm_encoder_funcs vmw_stdu_encoder_funcs = {\n\t.destroy = vmw_stdu_encoder_destroy,\n};\n\n\n\n \n\n \nstatic void vmw_stdu_connector_destroy(struct drm_connector *connector)\n{\n\tvmw_stdu_destroy(vmw_connector_to_stdu(connector));\n}\n\n\n\nstatic const struct drm_connector_funcs vmw_stdu_connector_funcs = {\n\t.dpms = vmw_du_connector_dpms,\n\t.detect = vmw_du_connector_detect,\n\t.fill_modes = vmw_du_connector_fill_modes,\n\t.destroy = vmw_stdu_connector_destroy,\n\t.reset = vmw_du_connector_reset,\n\t.atomic_duplicate_state = vmw_du_connector_duplicate_state,\n\t.atomic_destroy_state = vmw_du_connector_destroy_state,\n};\n\n\nstatic const struct\ndrm_connector_helper_funcs vmw_stdu_connector_helper_funcs = {\n};\n\n\n\n \n\n\n\n \nstatic void\nvmw_stdu_primary_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t  struct drm_plane_state *old_state)\n{\n\tstruct vmw_plane_state *vps = vmw_plane_state_to_vps(old_state);\n\n\tif (vps->surf)\n\t\tWARN_ON(!vps->pinned);\n\n\tvmw_du_plane_cleanup_fb(plane, old_state);\n\n\tvps->content_fb_type = SAME_AS_DISPLAY;\n\tvps->cpp = 0;\n}\n\n\n\n \nstatic int\nvmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,\n\t\t\t\t  struct drm_plane_state *new_state)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(plane->dev);\n\tstruct drm_framebuffer *new_fb = new_state->fb;\n\tstruct vmw_framebuffer *vfb;\n\tstruct vmw_plane_state *vps = vmw_plane_state_to_vps(new_state);\n\tenum stdu_content_type new_content_type;\n\tstruct vmw_framebuffer_surface *new_vfbs;\n\tuint32_t hdisplay = new_state->crtc_w, vdisplay = new_state->crtc_h;\n\tint ret;\n\n\t \n\tif (!new_fb) {\n\t\tif (vps->surf) {\n\t\t\tWARN_ON(vps->pinned != 0);\n\t\t\tvmw_surface_unreference(&vps->surf);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tvfb = vmw_framebuffer_to_vfb(new_fb);\n\tnew_vfbs = (vfb->bo) ? NULL : vmw_framebuffer_to_vfbs(new_fb);\n\n\tif (new_vfbs &&\n\t    new_vfbs->surface->metadata.base_size.width == hdisplay &&\n\t    new_vfbs->surface->metadata.base_size.height == vdisplay)\n\t\tnew_content_type = SAME_AS_DISPLAY;\n\telse if (vfb->bo)\n\t\tnew_content_type = SEPARATE_BO;\n\telse\n\t\tnew_content_type = SEPARATE_SURFACE;\n\n\tif (new_content_type != SAME_AS_DISPLAY) {\n\t\tstruct vmw_surface_metadata metadata = {0};\n\n\t\t \n\t\tif (new_content_type == SEPARATE_BO) {\n\n\t\t\tswitch (new_fb->format->cpp[0]*8) {\n\t\t\tcase 32:\n\t\t\t\tmetadata.format = SVGA3D_X8R8G8B8;\n\t\t\t\tbreak;\n\n\t\t\tcase 16:\n\t\t\t\tmetadata.format = SVGA3D_R5G6B5;\n\t\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\t\tmetadata.format = SVGA3D_P8;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"Invalid format\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmetadata.mip_levels[0] = 1;\n\t\t\tmetadata.num_sizes = 1;\n\t\t\tmetadata.scanout = true;\n\t\t} else {\n\t\t\tmetadata = new_vfbs->surface->metadata;\n\t\t}\n\n\t\tmetadata.base_size.width = hdisplay;\n\t\tmetadata.base_size.height = vdisplay;\n\t\tmetadata.base_size.depth = 1;\n\n\t\tif (vps->surf) {\n\t\t\tstruct drm_vmw_size cur_base_size =\n\t\t\t\tvps->surf->metadata.base_size;\n\n\t\t\tif (cur_base_size.width != metadata.base_size.width ||\n\t\t\t    cur_base_size.height != metadata.base_size.height ||\n\t\t\t    vps->surf->metadata.format != metadata.format) {\n\t\t\t\tWARN_ON(vps->pinned != 0);\n\t\t\t\tvmw_surface_unreference(&vps->surf);\n\t\t\t}\n\n\t\t}\n\n\t\tif (!vps->surf) {\n\t\t\tret = vmw_gb_surface_define(dev_priv, &metadata,\n\t\t\t\t\t\t    &vps->surf);\n\t\t\tif (ret != 0) {\n\t\t\t\tDRM_ERROR(\"Couldn't allocate STDU surface.\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (vps->surf) {\n\t\t\tWARN_ON(vps->pinned != 0);\n\t\t\tvmw_surface_unreference(&vps->surf);\n\t\t}\n\n\t\tvps->surf = vmw_surface_reference(new_vfbs->surface);\n\t}\n\n\tif (vps->surf) {\n\n\t\t \n\t\tret = vmw_resource_pin(&vps->surf->res, false);\n\t\tif (ret)\n\t\t\tgoto out_srf_unref;\n\n\t\tvps->pinned++;\n\t}\n\n\tvps->content_fb_type = new_content_type;\n\n\t \n\tif (vps->content_fb_type == SEPARATE_BO)\n\t\tvps->cpp = new_fb->pitches[0] / new_fb->width;\n\n\treturn 0;\n\nout_srf_unref:\n\tvmw_surface_unreference(&vps->surf);\n\treturn ret;\n}\n\nstatic uint32_t vmw_stdu_bo_fifo_size_cpu(struct vmw_du_update_plane *update,\n\t\t\t\t\t  uint32_t num_hits)\n{\n\treturn sizeof(struct vmw_stdu_update_gb_image) +\n\t\tsizeof(struct vmw_stdu_update);\n}\n\nstatic uint32_t vmw_stdu_bo_pre_clip_cpu(struct vmw_du_update_plane  *update,\n\t\t\t\t\t void *cmd, uint32_t num_hits)\n{\n\tstruct vmw_du_update_plane_buffer *bo_update =\n\t\tcontainer_of(update, typeof(*bo_update), base);\n\n\tbo_update->fb_left = INT_MAX;\n\tbo_update->fb_top = INT_MAX;\n\n\treturn 0;\n}\n\nstatic uint32_t vmw_stdu_bo_clip_cpu(struct vmw_du_update_plane  *update,\n\t\t\t\t     void *cmd, struct drm_rect *clip,\n\t\t\t\t     uint32_t fb_x, uint32_t fb_y)\n{\n\tstruct vmw_du_update_plane_buffer *bo_update =\n\t\tcontainer_of(update, typeof(*bo_update), base);\n\n\tbo_update->fb_left = min_t(int, bo_update->fb_left, fb_x);\n\tbo_update->fb_top = min_t(int, bo_update->fb_top, fb_y);\n\n\treturn 0;\n}\n\nstatic uint32_t\nvmw_stdu_bo_populate_update_cpu(struct vmw_du_update_plane  *update, void *cmd,\n\t\t\t\tstruct drm_rect *bb)\n{\n\tstruct vmw_du_update_plane_buffer *bo_update;\n\tstruct vmw_screen_target_display_unit *stdu;\n\tstruct vmw_framebuffer_bo *vfbbo;\n\tstruct vmw_diff_cpy diff = VMW_CPU_BLIT_DIFF_INITIALIZER(0);\n\tstruct vmw_stdu_update_gb_image *cmd_img = cmd;\n\tstruct vmw_stdu_update *cmd_update;\n\tstruct ttm_buffer_object *src_bo, *dst_bo;\n\tu32 src_offset, dst_offset;\n\ts32 src_pitch, dst_pitch;\n\ts32 width, height;\n\n\tbo_update = container_of(update, typeof(*bo_update), base);\n\tstdu = container_of(update->du, typeof(*stdu), base);\n\tvfbbo = container_of(update->vfb, typeof(*vfbbo), base);\n\n\twidth = bb->x2 - bb->x1;\n\theight = bb->y2 - bb->y1;\n\n\tdiff.cpp = stdu->cpp;\n\n\tdst_bo = &stdu->display_srf->res.guest_memory_bo->tbo;\n\tdst_pitch = stdu->display_srf->metadata.base_size.width * stdu->cpp;\n\tdst_offset = bb->y1 * dst_pitch + bb->x1 * stdu->cpp;\n\n\tsrc_bo = &vfbbo->buffer->tbo;\n\tsrc_pitch = update->vfb->base.pitches[0];\n\tsrc_offset = bo_update->fb_top * src_pitch + bo_update->fb_left *\n\t\tstdu->cpp;\n\n\t(void) vmw_bo_cpu_blit(dst_bo, dst_offset, dst_pitch, src_bo,\n\t\t\t       src_offset, src_pitch, width * stdu->cpp, height,\n\t\t\t       &diff);\n\n\tif (drm_rect_visible(&diff.rect)) {\n\t\tSVGA3dBox *box = &cmd_img->body.box;\n\n\t\tcmd_img->header.id = SVGA_3D_CMD_UPDATE_GB_IMAGE;\n\t\tcmd_img->header.size = sizeof(cmd_img->body);\n\t\tcmd_img->body.image.sid = stdu->display_srf->res.id;\n\t\tcmd_img->body.image.face = 0;\n\t\tcmd_img->body.image.mipmap = 0;\n\n\t\tbox->x = diff.rect.x1;\n\t\tbox->y = diff.rect.y1;\n\t\tbox->z = 0;\n\t\tbox->w = drm_rect_width(&diff.rect);\n\t\tbox->h = drm_rect_height(&diff.rect);\n\t\tbox->d = 1;\n\n\t\tcmd_update = (struct vmw_stdu_update *)&cmd_img[1];\n\t\tvmw_stdu_populate_update(cmd_update, stdu->base.unit,\n\t\t\t\t\t diff.rect.x1, diff.rect.x2,\n\t\t\t\t\t diff.rect.y1, diff.rect.y2);\n\n\t\treturn sizeof(*cmd_img) + sizeof(*cmd_update);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vmw_stdu_plane_update_bo(struct vmw_private *dev_priv,\n\t\t\t\t    struct drm_plane *plane,\n\t\t\t\t    struct drm_plane_state *old_state,\n\t\t\t\t    struct vmw_framebuffer *vfb,\n\t\t\t\t    struct vmw_fence_obj **out_fence)\n{\n\tstruct vmw_du_update_plane_buffer bo_update;\n\n\tmemset(&bo_update, 0, sizeof(struct vmw_du_update_plane_buffer));\n\tbo_update.base.plane = plane;\n\tbo_update.base.old_state = old_state;\n\tbo_update.base.dev_priv = dev_priv;\n\tbo_update.base.du = vmw_crtc_to_du(plane->state->crtc);\n\tbo_update.base.vfb = vfb;\n\tbo_update.base.out_fence = out_fence;\n\tbo_update.base.mutex = NULL;\n\tbo_update.base.intr = false;\n\n\tbo_update.base.calc_fifo_size = vmw_stdu_bo_fifo_size_cpu;\n\tbo_update.base.pre_clip = vmw_stdu_bo_pre_clip_cpu;\n\tbo_update.base.clip = vmw_stdu_bo_clip_cpu;\n\tbo_update.base.post_clip = vmw_stdu_bo_populate_update_cpu;\n\n\treturn vmw_du_helper_plane_update(&bo_update.base);\n}\n\nstatic uint32_t\nvmw_stdu_surface_fifo_size_same_display(struct vmw_du_update_plane *update,\n\t\t\t\t\tuint32_t num_hits)\n{\n\tstruct vmw_framebuffer_surface *vfbs;\n\tuint32_t size = 0;\n\n\tvfbs = container_of(update->vfb, typeof(*vfbs), base);\n\n\tif (vfbs->is_bo_proxy)\n\t\tsize += sizeof(struct vmw_stdu_update_gb_image) * num_hits;\n\n\tsize += sizeof(struct vmw_stdu_update);\n\n\treturn size;\n}\n\nstatic uint32_t vmw_stdu_surface_fifo_size(struct vmw_du_update_plane *update,\n\t\t\t\t\t   uint32_t num_hits)\n{\n\tstruct vmw_framebuffer_surface *vfbs;\n\tuint32_t size = 0;\n\n\tvfbs = container_of(update->vfb, typeof(*vfbs), base);\n\n\tif (vfbs->is_bo_proxy)\n\t\tsize += sizeof(struct vmw_stdu_update_gb_image) * num_hits;\n\n\tsize += sizeof(struct vmw_stdu_surface_copy) + sizeof(SVGA3dCopyBox) *\n\t\tnum_hits + sizeof(struct vmw_stdu_update);\n\n\treturn size;\n}\n\nstatic uint32_t\nvmw_stdu_surface_update_proxy(struct vmw_du_update_plane *update, void *cmd)\n{\n\tstruct vmw_framebuffer_surface *vfbs;\n\tstruct drm_plane_state *state = update->plane->state;\n\tstruct drm_plane_state *old_state = update->old_state;\n\tstruct vmw_stdu_update_gb_image *cmd_update = cmd;\n\tstruct drm_atomic_helper_damage_iter iter;\n\tstruct drm_rect clip;\n\tuint32_t copy_size = 0;\n\n\tvfbs = container_of(update->vfb, typeof(*vfbs), base);\n\n\t \n\tdrm_atomic_helper_damage_iter_init(&iter, old_state, state);\n\tdrm_atomic_for_each_plane_damage(&iter, &clip) {\n\t\tSVGA3dBox *box = &cmd_update->body.box;\n\n\t\tcmd_update->header.id = SVGA_3D_CMD_UPDATE_GB_IMAGE;\n\t\tcmd_update->header.size = sizeof(cmd_update->body);\n\t\tcmd_update->body.image.sid = vfbs->surface->res.id;\n\t\tcmd_update->body.image.face = 0;\n\t\tcmd_update->body.image.mipmap = 0;\n\n\t\tbox->x = clip.x1;\n\t\tbox->y = clip.y1;\n\t\tbox->z = 0;\n\t\tbox->w = drm_rect_width(&clip);\n\t\tbox->h = drm_rect_height(&clip);\n\t\tbox->d = 1;\n\n\t\tcopy_size += sizeof(*cmd_update);\n\t\tcmd_update++;\n\t}\n\n\treturn copy_size;\n}\n\nstatic uint32_t\nvmw_stdu_surface_populate_copy(struct vmw_du_update_plane  *update, void *cmd,\n\t\t\t       uint32_t num_hits)\n{\n\tstruct vmw_screen_target_display_unit *stdu;\n\tstruct vmw_framebuffer_surface *vfbs;\n\tstruct vmw_stdu_surface_copy *cmd_copy = cmd;\n\n\tstdu = container_of(update->du, typeof(*stdu), base);\n\tvfbs = container_of(update->vfb, typeof(*vfbs), base);\n\n\tcmd_copy->header.id = SVGA_3D_CMD_SURFACE_COPY;\n\tcmd_copy->header.size = sizeof(cmd_copy->body) + sizeof(SVGA3dCopyBox) *\n\t\tnum_hits;\n\tcmd_copy->body.src.sid = vfbs->surface->res.id;\n\tcmd_copy->body.dest.sid = stdu->display_srf->res.id;\n\n\treturn sizeof(*cmd_copy);\n}\n\nstatic uint32_t\nvmw_stdu_surface_populate_clip(struct vmw_du_update_plane  *update, void *cmd,\n\t\t\t       struct drm_rect *clip, uint32_t fb_x,\n\t\t\t       uint32_t fb_y)\n{\n\tstruct SVGA3dCopyBox *box = cmd;\n\n\tbox->srcx = fb_x;\n\tbox->srcy = fb_y;\n\tbox->srcz = 0;\n\tbox->x = clip->x1;\n\tbox->y = clip->y1;\n\tbox->z = 0;\n\tbox->w = drm_rect_width(clip);\n\tbox->h = drm_rect_height(clip);\n\tbox->d = 1;\n\n\treturn sizeof(*box);\n}\n\nstatic uint32_t\nvmw_stdu_surface_populate_update(struct vmw_du_update_plane  *update, void *cmd,\n\t\t\t\t struct drm_rect *bb)\n{\n\tvmw_stdu_populate_update(cmd, update->du->unit, bb->x1, bb->x2, bb->y1,\n\t\t\t\t bb->y2);\n\n\treturn sizeof(struct vmw_stdu_update);\n}\n\n \nstatic int vmw_stdu_plane_update_surface(struct vmw_private *dev_priv,\n\t\t\t\t\t struct drm_plane *plane,\n\t\t\t\t\t struct drm_plane_state *old_state,\n\t\t\t\t\t struct vmw_framebuffer *vfb,\n\t\t\t\t\t struct vmw_fence_obj **out_fence)\n{\n\tstruct vmw_du_update_plane srf_update;\n\tstruct vmw_screen_target_display_unit *stdu;\n\tstruct vmw_framebuffer_surface *vfbs;\n\n\tstdu = vmw_crtc_to_stdu(plane->state->crtc);\n\tvfbs = container_of(vfb, typeof(*vfbs), base);\n\n\tmemset(&srf_update, 0, sizeof(struct vmw_du_update_plane));\n\tsrf_update.plane = plane;\n\tsrf_update.old_state = old_state;\n\tsrf_update.dev_priv = dev_priv;\n\tsrf_update.du = vmw_crtc_to_du(plane->state->crtc);\n\tsrf_update.vfb = vfb;\n\tsrf_update.out_fence = out_fence;\n\tsrf_update.mutex = &dev_priv->cmdbuf_mutex;\n\tsrf_update.intr = true;\n\n\tif (vfbs->is_bo_proxy)\n\t\tsrf_update.post_prepare = vmw_stdu_surface_update_proxy;\n\n\tif (vfbs->surface->res.id != stdu->display_srf->res.id) {\n\t\tsrf_update.calc_fifo_size = vmw_stdu_surface_fifo_size;\n\t\tsrf_update.pre_clip = vmw_stdu_surface_populate_copy;\n\t\tsrf_update.clip = vmw_stdu_surface_populate_clip;\n\t} else {\n\t\tsrf_update.calc_fifo_size =\n\t\t\tvmw_stdu_surface_fifo_size_same_display;\n\t}\n\n\tsrf_update.post_clip = vmw_stdu_surface_populate_update;\n\n\treturn vmw_du_helper_plane_update(&srf_update);\n}\n\n \nstatic void\nvmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct vmw_plane_state *vps = vmw_plane_state_to_vps(new_state);\n\tstruct drm_crtc *crtc = new_state->crtc;\n\tstruct vmw_screen_target_display_unit *stdu;\n\tstruct vmw_fence_obj *fence = NULL;\n\tstruct vmw_private *dev_priv;\n\tint ret;\n\n\t \n\tif (crtc && new_state->fb) {\n\t\tstruct vmw_framebuffer *vfb =\n\t\t\tvmw_framebuffer_to_vfb(new_state->fb);\n\t\tstdu = vmw_crtc_to_stdu(crtc);\n\t\tdev_priv = vmw_priv(crtc->dev);\n\n\t\tstdu->display_srf = vps->surf;\n\t\tstdu->content_fb_type = vps->content_fb_type;\n\t\tstdu->cpp = vps->cpp;\n\n\t\tret = vmw_stdu_bind_st(dev_priv, stdu, &stdu->display_srf->res);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to bind surface to STDU.\\n\");\n\n\t\tif (vfb->bo)\n\t\t\tret = vmw_stdu_plane_update_bo(dev_priv, plane,\n\t\t\t\t\t\t       old_state, vfb, &fence);\n\t\telse\n\t\t\tret = vmw_stdu_plane_update_surface(dev_priv, plane,\n\t\t\t\t\t\t\t    old_state, vfb,\n\t\t\t\t\t\t\t    &fence);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to update STDU.\\n\");\n\t} else {\n\t\tcrtc = old_state->crtc;\n\t\tstdu = vmw_crtc_to_stdu(crtc);\n\t\tdev_priv = vmw_priv(crtc->dev);\n\n\t\t \n\t\tif (!stdu->defined)\n\t\t\treturn;\n\n\t\tret = vmw_stdu_bind_st(dev_priv, stdu, NULL);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to blank STDU\\n\");\n\n\t\tret = vmw_stdu_update_st(dev_priv, stdu);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to update STDU.\\n\");\n\n\t\treturn;\n\t}\n\n\tif (fence)\n\t\tvmw_fence_obj_unreference(&fence);\n}\n\n\nstatic const struct drm_plane_funcs vmw_stdu_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = vmw_du_primary_plane_destroy,\n\t.reset = vmw_du_plane_reset,\n\t.atomic_duplicate_state = vmw_du_plane_duplicate_state,\n\t.atomic_destroy_state = vmw_du_plane_destroy_state,\n};\n\nstatic const struct drm_plane_funcs vmw_stdu_cursor_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = vmw_du_cursor_plane_destroy,\n\t.reset = vmw_du_plane_reset,\n\t.atomic_duplicate_state = vmw_du_plane_duplicate_state,\n\t.atomic_destroy_state = vmw_du_plane_destroy_state,\n};\n\n\n \nstatic const struct\ndrm_plane_helper_funcs vmw_stdu_cursor_plane_helper_funcs = {\n\t.atomic_check = vmw_du_cursor_plane_atomic_check,\n\t.atomic_update = vmw_du_cursor_plane_atomic_update,\n\t.prepare_fb = vmw_du_cursor_plane_prepare_fb,\n\t.cleanup_fb = vmw_du_cursor_plane_cleanup_fb,\n};\n\nstatic const struct\ndrm_plane_helper_funcs vmw_stdu_primary_plane_helper_funcs = {\n\t.atomic_check = vmw_du_primary_plane_atomic_check,\n\t.atomic_update = vmw_stdu_primary_plane_atomic_update,\n\t.prepare_fb = vmw_stdu_primary_plane_prepare_fb,\n\t.cleanup_fb = vmw_stdu_primary_plane_cleanup_fb,\n};\n\nstatic const struct drm_crtc_helper_funcs vmw_stdu_crtc_helper_funcs = {\n\t.prepare = vmw_stdu_crtc_helper_prepare,\n\t.mode_set_nofb = vmw_stdu_crtc_mode_set_nofb,\n\t.atomic_check = vmw_du_crtc_atomic_check,\n\t.atomic_begin = vmw_du_crtc_atomic_begin,\n\t.atomic_flush = vmw_du_crtc_atomic_flush,\n\t.atomic_enable = vmw_stdu_crtc_atomic_enable,\n\t.atomic_disable = vmw_stdu_crtc_atomic_disable,\n};\n\n\n \nstatic int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)\n{\n\tstruct vmw_screen_target_display_unit *stdu;\n\tstruct drm_device *dev = &dev_priv->drm;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct drm_plane *primary;\n\tstruct vmw_cursor_plane *cursor;\n\tstruct drm_crtc *crtc;\n\tint    ret;\n\n\tstdu = kzalloc(sizeof(*stdu), GFP_KERNEL);\n\tif (!stdu)\n\t\treturn -ENOMEM;\n\n\tstdu->base.unit = unit;\n\tcrtc = &stdu->base.crtc;\n\tencoder = &stdu->base.encoder;\n\tconnector = &stdu->base.connector;\n\tprimary = &stdu->base.primary;\n\tcursor = &stdu->base.cursor;\n\n\tstdu->base.pref_active = (unit == 0);\n\tstdu->base.pref_width  = dev_priv->initial_width;\n\tstdu->base.pref_height = dev_priv->initial_height;\n\tstdu->base.is_implicit = false;\n\n\t \n\tret = drm_universal_plane_init(dev, primary,\n\t\t\t\t       0, &vmw_stdu_plane_funcs,\n\t\t\t\t       vmw_primary_plane_formats,\n\t\t\t\t       ARRAY_SIZE(vmw_primary_plane_formats),\n\t\t\t\t       NULL, DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize primary plane\");\n\t\tgoto err_free;\n\t}\n\n\tdrm_plane_helper_add(primary, &vmw_stdu_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary);\n\n\t \n\tret = drm_universal_plane_init(dev, &cursor->base,\n\t\t\t0, &vmw_stdu_cursor_funcs,\n\t\t\tvmw_cursor_plane_formats,\n\t\t\tARRAY_SIZE(vmw_cursor_plane_formats),\n\t\t\tNULL, DRM_PLANE_TYPE_CURSOR, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize cursor plane\");\n\t\tdrm_plane_cleanup(&stdu->base.primary);\n\t\tgoto err_free;\n\t}\n\n\tdrm_plane_helper_add(&cursor->base, &vmw_stdu_cursor_plane_helper_funcs);\n\n\tret = drm_connector_init(dev, connector, &vmw_stdu_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_VIRTUAL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize connector\\n\");\n\t\tgoto err_free;\n\t}\n\n\tdrm_connector_helper_add(connector, &vmw_stdu_connector_helper_funcs);\n\tconnector->status = vmw_du_connector_detect(connector, false);\n\n\tret = drm_encoder_init(dev, encoder, &vmw_stdu_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_VIRTUAL, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize encoder\\n\");\n\t\tgoto err_free_connector;\n\t}\n\n\t(void) drm_connector_attach_encoder(connector, encoder);\n\tencoder->possible_crtcs = (1 << unit);\n\tencoder->possible_clones = 0;\n\n\tret = drm_connector_register(connector);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to register connector\\n\");\n\t\tgoto err_free_encoder;\n\t}\n\n\tret = drm_crtc_init_with_planes(dev, crtc, primary,\n\t\t\t\t\t&cursor->base,\n\t\t\t\t\t&vmw_stdu_crtc_funcs, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize CRTC\\n\");\n\t\tgoto err_free_unregister;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &vmw_stdu_crtc_helper_funcs);\n\n\tdrm_mode_crtc_set_gamma_size(crtc, 256);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev_priv->hotplug_mode_update_property, 1);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.suggested_x_property, 0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.suggested_y_property, 0);\n\treturn 0;\n\nerr_free_unregister:\n\tdrm_connector_unregister(connector);\nerr_free_encoder:\n\tdrm_encoder_cleanup(encoder);\nerr_free_connector:\n\tdrm_connector_cleanup(connector);\nerr_free:\n\tkfree(stdu);\n\treturn ret;\n}\n\n\n\n \nstatic void vmw_stdu_destroy(struct vmw_screen_target_display_unit *stdu)\n{\n\tvmw_du_cleanup(&stdu->base);\n\tkfree(stdu);\n}\n\n\n\n \n\n \nint vmw_kms_stdu_init_display(struct vmw_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->drm;\n\tint i, ret;\n\n\n\t \n\tif (!dev_priv->has_mob)\n\t\treturn -ENOSYS;\n\n\tif (!(dev_priv->capabilities & SVGA_CAP_GBOBJECTS))\n\t\treturn -ENOSYS;\n\n\tdev_priv->active_display_unit = vmw_du_screen_target;\n\n\tfor (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i) {\n\t\tret = vmw_stdu_init(dev_priv, i);\n\n\t\tif (unlikely(ret != 0)) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Failed to initialize STDU %d\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdrm_mode_config_reset(dev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}