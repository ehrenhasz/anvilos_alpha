{
  "module_name": "vmwgfx_simple_resource.c",
  "hash_id": "43112507c6b05868448fbcc343e3dd8bf3bfff66687e250eaceb962f2610f3d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c",
  "human_readable_source": "\n \n\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_resource_priv.h\"\n\n \nstruct vmw_user_simple_resource {\n\tstruct ttm_base_object base;\n\tstruct vmw_simple_resource simple;\n \n};\n\n\n \nstatic int vmw_simple_resource_init(struct vmw_private *dev_priv,\n\t\t\t\t    struct vmw_simple_resource *simple,\n\t\t\t\t    void *data,\n\t\t\t\t    void (*res_free)(struct vmw_resource *res))\n{\n\tstruct vmw_resource *res = &simple->res;\n\tint ret;\n\n\tret = vmw_resource_init(dev_priv, res, false, res_free,\n\t\t\t\t&simple->func->res_func);\n\n\tif (ret) {\n\t\tres_free(res);\n\t\treturn ret;\n\t}\n\n\tret = simple->func->init(res, data);\n\tif (ret) {\n\t\tvmw_resource_unreference(&res);\n\t\treturn ret;\n\t}\n\n\tsimple->res.hw_destroy = simple->func->hw_destroy;\n\n\treturn 0;\n}\n\n \nstatic void vmw_simple_resource_free(struct vmw_resource *res)\n{\n\tstruct vmw_user_simple_resource *usimple =\n\t\tcontainer_of(res, struct vmw_user_simple_resource,\n\t\t\t     simple.res);\n\n\tttm_base_object_kfree(usimple, base);\n}\n\n \nstatic void vmw_simple_resource_base_release(struct ttm_base_object **p_base)\n{\n\tstruct ttm_base_object *base = *p_base;\n\tstruct vmw_user_simple_resource *usimple =\n\t\tcontainer_of(base, struct vmw_user_simple_resource, base);\n\tstruct vmw_resource *res = &usimple->simple.res;\n\n\t*p_base = NULL;\n\tvmw_resource_unreference(&res);\n}\n\n \nint\nvmw_simple_resource_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t struct drm_file *file_priv,\n\t\t\t\t const struct vmw_simple_resource_func *func)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct vmw_user_simple_resource *usimple;\n\tstruct vmw_resource *res;\n\tstruct vmw_resource *tmp;\n\tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n\tsize_t alloc_size;\n\tint ret;\n\n\talloc_size = offsetof(struct vmw_user_simple_resource, simple) +\n\t  func->size;\n\n\tusimple = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!usimple) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\n\tusimple->simple.func = func;\n\tres = &usimple->simple.res;\n\tusimple->base.shareable = false;\n\tusimple->base.tfile = NULL;\n\n\t \n\tret = vmw_simple_resource_init(dev_priv, &usimple->simple,\n\t\t\t\t       data, vmw_simple_resource_free);\n\tif (ret)\n\t\tgoto out_ret;\n\n\ttmp = vmw_resource_reference(res);\n\tret = ttm_base_object_init(tfile, &usimple->base, false,\n\t\t\t\t   func->ttm_res_type,\n\t\t\t\t   &vmw_simple_resource_base_release);\n\n\tif (ret) {\n\t\tvmw_resource_unreference(&tmp);\n\t\tgoto out_err;\n\t}\n\n\tfunc->set_arg_handle(data, usimple->base.handle);\nout_err:\n\tvmw_resource_unreference(&res);\nout_ret:\n\treturn ret;\n}\n\n \nstruct vmw_resource *\nvmw_simple_resource_lookup(struct ttm_object_file *tfile,\n\t\t\t   uint32_t handle,\n\t\t\t   const struct vmw_simple_resource_func *func)\n{\n\tstruct vmw_user_simple_resource *usimple;\n\tstruct ttm_base_object *base;\n\tstruct vmw_resource *res;\n\n\tbase = ttm_base_object_lookup(tfile, handle);\n\tif (!base) {\n\t\tVMW_DEBUG_USER(\"Invalid %s handle 0x%08lx.\\n\",\n\t\t\t       func->res_func.type_name,\n\t\t\t       (unsigned long) handle);\n\t\treturn ERR_PTR(-ESRCH);\n\t}\n\n\tif (ttm_base_object_type(base) != func->ttm_res_type) {\n\t\tttm_base_object_unref(&base);\n\t\tVMW_DEBUG_USER(\"Invalid type of %s handle 0x%08lx.\\n\",\n\t\t\t       func->res_func.type_name,\n\t\t\t       (unsigned long) handle);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tusimple = container_of(base, typeof(*usimple), base);\n\tres = vmw_resource_reference(&usimple->simple.res);\n\tttm_base_object_unref(&base);\n\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}