{
  "module_name": "ttm_object.h",
  "hash_id": "9d6af3012f02e52545625f747f3ea12014ed9a3938bb4b10958d22f63bc0f041",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/ttm_object.h",
  "human_readable_source": " \n \n \n\n#ifndef _TTM_OBJECT_H_\n#define _TTM_OBJECT_H_\n\n#include <linux/dma-buf.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n\n#include <drm/ttm/ttm_bo.h>\n\n \n\nenum ttm_object_type {\n\tttm_fence_type,\n\tttm_lock_type,\n\tttm_prime_type,\n\tttm_driver_type0 = 256,\n\tttm_driver_type1,\n\tttm_driver_type2,\n\tttm_driver_type3,\n\tttm_driver_type4,\n\tttm_driver_type5\n};\n\nstruct ttm_object_file;\nstruct ttm_object_device;\n\n \n\nstruct ttm_base_object {\n\tstruct rcu_head rhead;\n\tstruct ttm_object_file *tfile;\n\tstruct kref refcount;\n\tvoid (*refcount_release) (struct ttm_base_object **base);\n\tu64 handle;\n\tenum ttm_object_type object_type;\n\tu32 shareable;\n};\n\n\n \n\nstruct ttm_prime_object {\n\tstruct ttm_base_object base;\n\tstruct mutex mutex;\n\tsize_t size;\n\tenum ttm_object_type real_type;\n\tstruct dma_buf *dma_buf;\n\tvoid (*refcount_release) (struct ttm_base_object **);\n};\n\n \n\nextern int ttm_base_object_init(struct ttm_object_file *tfile,\n\t\t\t\tstruct ttm_base_object *base,\n\t\t\t\tbool shareable,\n\t\t\t\tenum ttm_object_type type,\n\t\t\t\tvoid (*refcount_release) (struct ttm_base_object\n\t\t\t\t\t\t\t  **));\n\n \n\nextern struct ttm_base_object *ttm_base_object_lookup(struct ttm_object_file\n\t\t\t\t\t\t      *tfile, uint64_t key);\n\n \n\nextern struct ttm_base_object *\nttm_base_object_lookup_for_ref(struct ttm_object_device *tdev, uint64_t key);\n\n \n\nextern void ttm_base_object_unref(struct ttm_base_object **p_base);\n\n \nextern int ttm_ref_object_add(struct ttm_object_file *tfile,\n\t\t\t      struct ttm_base_object *base,\n\t\t\t      bool *existed,\n\t\t\t      bool require_existed);\n\n \nextern int ttm_ref_object_base_unref(struct ttm_object_file *tfile,\n\t\t\t\t     unsigned long key);\n\n \n\nextern struct ttm_object_file *ttm_object_file_init(struct ttm_object_device\n\t\t\t\t\t\t    *tdev);\n\n \n\nextern void ttm_object_file_release(struct ttm_object_file **p_tfile);\n\n \n\nextern struct ttm_object_device *\nttm_object_device_init(const struct dma_buf_ops *ops);\n\n \n\nextern void ttm_object_device_release(struct ttm_object_device **p_tdev);\n\n#define ttm_base_object_kfree(__object, __base)\\\n\tkfree_rcu(__object, __base.rhead)\n\nextern int ttm_prime_object_init(struct ttm_object_file *tfile,\n\t\t\t\t size_t size,\n\t\t\t\t struct ttm_prime_object *prime,\n\t\t\t\t bool shareable,\n\t\t\t\t enum ttm_object_type type,\n\t\t\t\t void (*refcount_release)\n\t\t\t\t (struct ttm_base_object **));\n\nstatic inline enum ttm_object_type\nttm_base_object_type(struct ttm_base_object *base)\n{\n\treturn (base->object_type == ttm_prime_type) ?\n\t\tcontainer_of(base, struct ttm_prime_object, base)->real_type :\n\t\tbase->object_type;\n}\nextern int ttm_prime_fd_to_handle(struct ttm_object_file *tfile,\n\t\t\t\t  int fd, u32 *handle);\nextern int ttm_prime_handle_to_fd(struct ttm_object_file *tfile,\n\t\t\t\t  uint32_t handle, uint32_t flags,\n\t\t\t\t  int *prime_fd);\n\n#define ttm_prime_object_kfree(__obj, __prime)\t\t\\\n\tkfree_rcu(__obj, __prime.base.rhead)\n\nstatic inline int ttm_bo_wait(struct ttm_buffer_object *bo, bool intr,\n\t\t\t      bool no_wait)\n{\n\tstruct ttm_operation_ctx ctx = { intr, no_wait };\n\n\treturn ttm_bo_wait_ctx(bo, &ctx);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}