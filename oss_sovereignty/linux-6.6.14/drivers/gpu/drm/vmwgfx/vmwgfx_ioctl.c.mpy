{
  "module_name": "vmwgfx_ioctl.c",
  "hash_id": "f8323a4dd95a289554e4c7325c9f9155564f1722a51a80fd5ecb176f7046fb01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c",
  "human_readable_source": "\n \n\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_devcaps.h\"\n#include \"vmwgfx_kms.h\"\n\n#include <drm/vmwgfx_drm.h>\n#include <linux/pci.h>\n\nint vmw_getparam_ioctl(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file_priv)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct drm_vmw_getparam_arg *param =\n\t    (struct drm_vmw_getparam_arg *)data;\n\tstruct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);\n\n\tswitch (param->param) {\n\tcase DRM_VMW_PARAM_NUM_STREAMS:\n\t\tparam->value = vmw_overlay_num_overlays(dev_priv);\n\t\tbreak;\n\tcase DRM_VMW_PARAM_NUM_FREE_STREAMS:\n\t\tparam->value = vmw_overlay_num_free_overlays(dev_priv);\n\t\tbreak;\n\tcase DRM_VMW_PARAM_3D:\n\t\tparam->value = vmw_supports_3d(dev_priv) ? 1 : 0;\n\t\tbreak;\n\tcase DRM_VMW_PARAM_HW_CAPS:\n\t\tparam->value = dev_priv->capabilities;\n\t\tbreak;\n\tcase DRM_VMW_PARAM_HW_CAPS2:\n\t\tparam->value = dev_priv->capabilities2;\n\t\tbreak;\n\tcase DRM_VMW_PARAM_FIFO_CAPS:\n\t\tparam->value = vmw_fifo_caps(dev_priv);\n\t\tbreak;\n\tcase DRM_VMW_PARAM_MAX_FB_SIZE:\n\t\tparam->value = dev_priv->max_primary_mem;\n\t\tbreak;\n\tcase DRM_VMW_PARAM_FIFO_HW_VERSION:\n\t{\n\t\tif ((dev_priv->capabilities & SVGA_CAP_GBOBJECTS))\n\t\t\tparam->value = SVGA3D_HWVERSION_WS8_B1;\n\t\telse\n\t\t\tparam->value = vmw_fifo_mem_read(\n\t\t\t\t\t       dev_priv,\n\t\t\t\t\t       ((vmw_fifo_caps(dev_priv) &\n\t\t\t\t\t\t SVGA_FIFO_CAP_3D_HWVERSION_REVISED) ?\n\t\t\t\t\t\t\tSVGA_FIFO_3D_HWVERSION_REVISED :\n\t\t\t\t\t\t\tSVGA_FIFO_3D_HWVERSION));\n\t\tbreak;\n\t}\n\tcase DRM_VMW_PARAM_MAX_SURF_MEMORY:\n\t\tif ((dev_priv->capabilities & SVGA_CAP_GBOBJECTS) &&\n\t\t    !vmw_fp->gb_aware)\n\t\t\tparam->value = dev_priv->max_mob_pages * PAGE_SIZE / 2;\n\t\telse\n\t\t\tparam->value = dev_priv->memory_size;\n\t\tbreak;\n\tcase DRM_VMW_PARAM_3D_CAPS_SIZE:\n\t\tparam->value = vmw_devcaps_size(dev_priv, vmw_fp->gb_aware);\n\t\tbreak;\n\tcase DRM_VMW_PARAM_MAX_MOB_MEMORY:\n\t\tvmw_fp->gb_aware = true;\n\t\tparam->value = dev_priv->max_mob_pages * PAGE_SIZE;\n\t\tbreak;\n\tcase DRM_VMW_PARAM_MAX_MOB_SIZE:\n\t\tparam->value = dev_priv->max_mob_size;\n\t\tbreak;\n\tcase DRM_VMW_PARAM_SCREEN_TARGET:\n\t\tparam->value =\n\t\t\t(dev_priv->active_display_unit == vmw_du_screen_target);\n\t\tbreak;\n\tcase DRM_VMW_PARAM_DX:\n\t\tparam->value = has_sm4_context(dev_priv);\n\t\tbreak;\n\tcase DRM_VMW_PARAM_SM4_1:\n\t\tparam->value = has_sm4_1_context(dev_priv);\n\t\tbreak;\n\tcase DRM_VMW_PARAM_SM5:\n\t\tparam->value = has_sm5_context(dev_priv);\n\t\tbreak;\n\tcase DRM_VMW_PARAM_GL43:\n\t\tparam->value = has_gl43_context(dev_priv);\n\t\tbreak;\n\tcase DRM_VMW_PARAM_DEVICE_ID:\n\t\tparam->value = to_pci_dev(dev_priv->drm.dev)->device;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nint vmw_get_cap_3d_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *file_priv)\n{\n\tstruct drm_vmw_get_3d_cap_arg *arg =\n\t\t(struct drm_vmw_get_3d_cap_arg *) data;\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tuint32_t size;\n\tvoid __user *buffer = (void __user *)((unsigned long)(arg->buffer));\n\tvoid *bounce = NULL;\n\tint ret;\n\tstruct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);\n\n\tif (unlikely(arg->pad64 != 0 || arg->max_size == 0)) {\n\t\tVMW_DEBUG_USER(\"Illegal GET_3D_CAP argument.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsize = vmw_devcaps_size(dev_priv, vmw_fp->gb_aware);\n\tif (unlikely(size == 0)) {\n\t\tDRM_ERROR(\"Failed to figure out the devcaps size (no 3D).\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (arg->max_size < size)\n\t\tsize = arg->max_size;\n\n\tbounce = vzalloc(size);\n\tif (unlikely(bounce == NULL)) {\n\t\tDRM_ERROR(\"Failed to allocate bounce buffer for 3D caps.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = vmw_devcaps_copy(dev_priv, vmw_fp->gb_aware, bounce, size);\n\tif (unlikely (ret != 0))\n\t\tgoto out_err;\n\n\tret = copy_to_user(buffer, bounce, size);\n\tif (ret)\n\t\tret = -EFAULT;\nout_err:\n\tvfree(bounce);\n\n\tif (unlikely(ret != 0))\n\t\tDRM_ERROR(\"Failed to report 3D caps info.\\n\");\n\n\treturn ret;\n}\n\nint vmw_present_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct drm_vmw_present_arg *arg =\n\t\t(struct drm_vmw_present_arg *)data;\n\tstruct vmw_surface *surface;\n\tstruct drm_vmw_rect __user *clips_ptr;\n\tstruct drm_vmw_rect *clips = NULL;\n\tstruct drm_framebuffer *fb;\n\tstruct vmw_framebuffer *vfb;\n\tstruct vmw_resource *res;\n\tuint32_t num_clips;\n\tint ret;\n\n\tnum_clips = arg->num_clips;\n\tclips_ptr = (struct drm_vmw_rect __user *)(unsigned long)arg->clips_ptr;\n\n\tif (unlikely(num_clips == 0))\n\t\treturn 0;\n\n\tif (clips_ptr == NULL) {\n\t\tVMW_DEBUG_USER(\"Variable clips_ptr must be specified.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_clips;\n\t}\n\n\tclips = kcalloc(num_clips, sizeof(*clips), GFP_KERNEL);\n\tif (clips == NULL) {\n\t\tDRM_ERROR(\"Failed to allocate clip rect list.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clips;\n\t}\n\n\tret = copy_from_user(clips, clips_ptr, num_clips * sizeof(*clips));\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to copy clip rects from userspace.\\n\");\n\t\tret = -EFAULT;\n\t\tgoto out_no_copy;\n\t}\n\n\tdrm_modeset_lock_all(dev);\n\n\tfb = drm_framebuffer_lookup(dev, file_priv, arg->fb_id);\n\tif (!fb) {\n\t\tVMW_DEBUG_USER(\"Invalid framebuffer id.\\n\");\n\t\tret = -ENOENT;\n\t\tgoto out_no_fb;\n\t}\n\tvfb = vmw_framebuffer_to_vfb(fb);\n\n\tret = vmw_user_resource_lookup_handle(dev_priv, tfile, arg->sid,\n\t\t\t\t\t      user_surface_converter,\n\t\t\t\t\t      &res);\n\tif (ret)\n\t\tgoto out_no_surface;\n\n\tsurface = vmw_res_to_srf(res);\n\tret = vmw_kms_present(dev_priv, file_priv,\n\t\t\t      vfb, surface, arg->sid,\n\t\t\t      arg->dest_x, arg->dest_y,\n\t\t\t      clips, num_clips);\n\n\t \n\tvmw_surface_unreference(&surface);\n\nout_no_surface:\n\tdrm_framebuffer_put(fb);\nout_no_fb:\n\tdrm_modeset_unlock_all(dev);\nout_no_copy:\n\tkfree(clips);\nout_clips:\n\treturn ret;\n}\n\nint vmw_present_readback_ioctl(struct drm_device *dev, void *data,\n\t\t\t       struct drm_file *file_priv)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct drm_vmw_present_readback_arg *arg =\n\t\t(struct drm_vmw_present_readback_arg *)data;\n\tstruct drm_vmw_fence_rep __user *user_fence_rep =\n\t\t(struct drm_vmw_fence_rep __user *)\n\t\t(unsigned long)arg->fence_rep;\n\tstruct drm_vmw_rect __user *clips_ptr;\n\tstruct drm_vmw_rect *clips = NULL;\n\tstruct drm_framebuffer *fb;\n\tstruct vmw_framebuffer *vfb;\n\tuint32_t num_clips;\n\tint ret;\n\n\tnum_clips = arg->num_clips;\n\tclips_ptr = (struct drm_vmw_rect __user *)(unsigned long)arg->clips_ptr;\n\n\tif (unlikely(num_clips == 0))\n\t\treturn 0;\n\n\tif (clips_ptr == NULL) {\n\t\tVMW_DEBUG_USER(\"Argument clips_ptr must be specified.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_clips;\n\t}\n\n\tclips = kcalloc(num_clips, sizeof(*clips), GFP_KERNEL);\n\tif (clips == NULL) {\n\t\tDRM_ERROR(\"Failed to allocate clip rect list.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clips;\n\t}\n\n\tret = copy_from_user(clips, clips_ptr, num_clips * sizeof(*clips));\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to copy clip rects from userspace.\\n\");\n\t\tret = -EFAULT;\n\t\tgoto out_no_copy;\n\t}\n\n\tdrm_modeset_lock_all(dev);\n\n\tfb = drm_framebuffer_lookup(dev, file_priv, arg->fb_id);\n\tif (!fb) {\n\t\tVMW_DEBUG_USER(\"Invalid framebuffer id.\\n\");\n\t\tret = -ENOENT;\n\t\tgoto out_no_fb;\n\t}\n\n\tvfb = vmw_framebuffer_to_vfb(fb);\n\tif (!vfb->bo) {\n\t\tVMW_DEBUG_USER(\"Framebuffer not buffer backed.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_no_ttm_lock;\n\t}\n\n\tret = vmw_kms_readback(dev_priv, file_priv,\n\t\t\t       vfb, user_fence_rep,\n\t\t\t       clips, num_clips);\n\nout_no_ttm_lock:\n\tdrm_framebuffer_put(fb);\nout_no_fb:\n\tdrm_modeset_unlock_all(dev);\nout_no_copy:\n\tkfree(clips);\nout_clips:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}