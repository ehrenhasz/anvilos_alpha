{
  "module_name": "vmwgfx_gem.c",
  "hash_id": "7ffb975fad8abb82d7ee438c43578890c777be9523e3eaa9a717817a02e07abd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_gem.c",
  "human_readable_source": " \n \n\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_drv.h\"\n\n#include \"drm/drm_prime.h\"\n#include \"drm/drm_gem_ttm_helper.h\"\n\nstatic void vmw_gem_object_free(struct drm_gem_object *gobj)\n{\n\tstruct ttm_buffer_object *bo = drm_gem_ttm_of_gem(gobj);\n\tif (bo)\n\t\tttm_bo_put(bo);\n}\n\nstatic int vmw_gem_object_open(struct drm_gem_object *obj,\n\t\t\t       struct drm_file *file_priv)\n{\n\treturn 0;\n}\n\nstatic void vmw_gem_object_close(struct drm_gem_object *obj,\n\t\t\t\t struct drm_file *file_priv)\n{\n}\n\nstatic int vmw_gem_pin_private(struct drm_gem_object *obj, bool do_pin)\n{\n\tstruct ttm_buffer_object *bo = drm_gem_ttm_of_gem(obj);\n\tstruct vmw_bo *vbo = to_vmw_bo(obj);\n\tint ret;\n\n\tret = ttm_bo_reserve(bo, false, false, NULL);\n\tif (unlikely(ret != 0))\n\t\tgoto err;\n\n\tvmw_bo_pin_reserved(vbo, do_pin);\n\n\tttm_bo_unreserve(bo);\n\nerr:\n\treturn ret;\n}\n\n\nstatic int vmw_gem_object_pin(struct drm_gem_object *obj)\n{\n\treturn vmw_gem_pin_private(obj, true);\n}\n\nstatic void vmw_gem_object_unpin(struct drm_gem_object *obj)\n{\n\tvmw_gem_pin_private(obj, false);\n}\n\nstatic struct sg_table *vmw_gem_object_get_sg_table(struct drm_gem_object *obj)\n{\n\tstruct ttm_buffer_object *bo = drm_gem_ttm_of_gem(obj);\n\tstruct vmw_ttm_tt *vmw_tt =\n\t\tcontainer_of(bo->ttm, struct vmw_ttm_tt, dma_ttm);\n\n\tif (vmw_tt->vsgt.sgt)\n\t\treturn vmw_tt->vsgt.sgt;\n\n\treturn drm_prime_pages_to_sg(obj->dev, vmw_tt->dma_ttm.pages, vmw_tt->dma_ttm.num_pages);\n}\n\nstatic const struct vm_operations_struct vmw_vm_ops = {\n\t.pfn_mkwrite = vmw_bo_vm_mkwrite,\n\t.page_mkwrite = vmw_bo_vm_mkwrite,\n\t.fault = vmw_bo_vm_fault,\n\t.open = ttm_bo_vm_open,\n\t.close = ttm_bo_vm_close,\n};\n\nstatic const struct drm_gem_object_funcs vmw_gem_object_funcs = {\n\t.free = vmw_gem_object_free,\n\t.open = vmw_gem_object_open,\n\t.close = vmw_gem_object_close,\n\t.print_info = drm_gem_ttm_print_info,\n\t.pin = vmw_gem_object_pin,\n\t.unpin = vmw_gem_object_unpin,\n\t.get_sg_table = vmw_gem_object_get_sg_table,\n\t.vmap = drm_gem_ttm_vmap,\n\t.vunmap = drm_gem_ttm_vunmap,\n\t.mmap = drm_gem_ttm_mmap,\n\t.vm_ops = &vmw_vm_ops,\n};\n\nint vmw_gem_object_create(struct vmw_private *vmw,\n\t\t\t  struct vmw_bo_params *params,\n\t\t\t  struct vmw_bo **p_vbo)\n{\n\tint ret = vmw_bo_create(vmw, params, p_vbo);\n\n\tif (ret != 0)\n\t\tgoto out_no_bo;\n\n\t(*p_vbo)->tbo.base.funcs = &vmw_gem_object_funcs;\nout_no_bo:\n\treturn ret;\n}\n\nint vmw_gem_object_create_with_handle(struct vmw_private *dev_priv,\n\t\t\t\t      struct drm_file *filp,\n\t\t\t\t      uint32_t size,\n\t\t\t\t      uint32_t *handle,\n\t\t\t\t      struct vmw_bo **p_vbo)\n{\n\tint ret;\n\tstruct vmw_bo_params params = {\n\t\t.domain = (dev_priv->has_mob) ? VMW_BO_DOMAIN_SYS : VMW_BO_DOMAIN_VRAM,\n\t\t.busy_domain = VMW_BO_DOMAIN_SYS,\n\t\t.bo_type = ttm_bo_type_device,\n\t\t.size = size,\n\t\t.pin = false\n\t};\n\n\tret = vmw_gem_object_create(dev_priv, &params, p_vbo);\n\tif (ret != 0)\n\t\tgoto out_no_bo;\n\n\tret = drm_gem_handle_create(filp, &(*p_vbo)->tbo.base, handle);\nout_no_bo:\n\treturn ret;\n}\n\n\nint vmw_gem_object_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *filp)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tunion drm_vmw_alloc_dmabuf_arg *arg =\n\t    (union drm_vmw_alloc_dmabuf_arg *)data;\n\tstruct drm_vmw_alloc_dmabuf_req *req = &arg->req;\n\tstruct drm_vmw_dmabuf_rep *rep = &arg->rep;\n\tstruct vmw_bo *vbo;\n\tuint32_t handle;\n\tint ret;\n\n\tret = vmw_gem_object_create_with_handle(dev_priv, filp,\n\t\t\t\t\t\treq->size, &handle, &vbo);\n\tif (ret)\n\t\tgoto out_no_bo;\n\n\trep->handle = handle;\n\trep->map_handle = drm_vma_node_offset_addr(&vbo->tbo.base.vma_node);\n\trep->cur_gmr_id = handle;\n\trep->cur_gmr_offset = 0;\n\t \n\tdrm_gem_object_put(&vbo->tbo.base);\nout_no_bo:\n\treturn ret;\n}\n\n#if defined(CONFIG_DEBUG_FS)\n\nstatic void vmw_bo_print_info(int id, struct vmw_bo *bo, struct seq_file *m)\n{\n\tconst char *placement;\n\tconst char *type;\n\n\tswitch (bo->tbo.resource->mem_type) {\n\tcase TTM_PL_SYSTEM:\n\t\tplacement = \" CPU\";\n\t\tbreak;\n\tcase VMW_PL_GMR:\n\t\tplacement = \" GMR\";\n\t\tbreak;\n\tcase VMW_PL_MOB:\n\t\tplacement = \" MOB\";\n\t\tbreak;\n\tcase VMW_PL_SYSTEM:\n\t\tplacement = \"VCPU\";\n\t\tbreak;\n\tcase TTM_PL_VRAM:\n\t\tplacement = \"VRAM\";\n\t\tbreak;\n\tdefault:\n\t\tplacement = \"None\";\n\t\tbreak;\n\t}\n\n\tswitch (bo->tbo.type) {\n\tcase ttm_bo_type_device:\n\t\ttype = \"device\";\n\t\tbreak;\n\tcase ttm_bo_type_kernel:\n\t\ttype = \"kernel\";\n\t\tbreak;\n\tcase ttm_bo_type_sg:\n\t\ttype = \"sg    \";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"none  \";\n\t\tbreak;\n\t}\n\n\tseq_printf(m, \"\\t\\t0x%08x: %12zu bytes %s, type = %s\",\n\t\t   id, bo->tbo.base.size, placement, type);\n\tseq_printf(m, \", priority = %u, pin_count = %u, GEM refs = %d, TTM refs = %d\",\n\t\t   bo->tbo.priority,\n\t\t   bo->tbo.pin_count,\n\t\t   kref_read(&bo->tbo.base.refcount),\n\t\t   kref_read(&bo->tbo.kref));\n\tseq_puts(m, \"\\n\");\n}\n\nstatic int vmw_debugfs_gem_info_show(struct seq_file *m, void *unused)\n{\n\tstruct vmw_private *vdev = (struct vmw_private *)m->private;\n\tstruct drm_device *dev = &vdev->drm;\n\tstruct drm_file *file;\n\tint r;\n\n\tr = mutex_lock_interruptible(&dev->filelist_mutex);\n\tif (r)\n\t\treturn r;\n\n\tlist_for_each_entry(file, &dev->filelist, lhead) {\n\t\tstruct task_struct *task;\n\t\tstruct drm_gem_object *gobj;\n\t\tstruct pid *pid;\n\t\tint id;\n\n\t\t \n\t\trcu_read_lock();\n\t\tpid = rcu_dereference(file->pid);\n\t\ttask = pid_task(pid, PIDTYPE_TGID);\n\t\tseq_printf(m, \"pid %8d command %s:\\n\", pid_nr(pid),\n\t\t\t   task ? task->comm : \"<unknown>\");\n\t\trcu_read_unlock();\n\n\t\tspin_lock(&file->table_lock);\n\t\tidr_for_each_entry(&file->object_idr, gobj, id) {\n\t\t\tstruct vmw_bo *bo = to_vmw_bo(gobj);\n\n\t\t\tvmw_bo_print_info(id, bo, m);\n\t\t}\n\t\tspin_unlock(&file->table_lock);\n\t}\n\n\tmutex_unlock(&dev->filelist_mutex);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(vmw_debugfs_gem_info);\n\n#endif\n\nvoid vmw_debugfs_gem_init(struct vmw_private *vdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct drm_minor *minor = vdev->drm.primary;\n\tstruct dentry *root = minor->debugfs_root;\n\n\tdebugfs_create_file(\"vmwgfx_gem_info\", 0444, root, vdev,\n\t\t\t    &vmw_debugfs_gem_info_fops);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}