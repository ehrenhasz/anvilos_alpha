{
  "module_name": "vmwgfx_context.c",
  "hash_id": "287883f0aad526e7fc5b36e8401396ed9a48e510f5b792b7070ee1320b30cce8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_context.c",
  "human_readable_source": "\n \n\n#include <drm/ttm/ttm_placement.h>\n\n#include \"vmwgfx_binding.h\"\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_resource_priv.h\"\n\nstruct vmw_user_context {\n\tstruct ttm_base_object base;\n\tstruct vmw_resource res;\n\tstruct vmw_ctx_binding_state *cbs;\n\tstruct vmw_cmdbuf_res_manager *man;\n\tstruct vmw_resource *cotables[SVGA_COTABLE_MAX];\n\tspinlock_t cotable_lock;\n\tstruct vmw_bo *dx_query_mob;\n};\n\nstatic void vmw_user_context_free(struct vmw_resource *res);\nstatic struct vmw_resource *\nvmw_user_context_base_to_res(struct ttm_base_object *base);\n\nstatic int vmw_gb_context_create(struct vmw_resource *res);\nstatic int vmw_gb_context_bind(struct vmw_resource *res,\n\t\t\t       struct ttm_validate_buffer *val_buf);\nstatic int vmw_gb_context_unbind(struct vmw_resource *res,\n\t\t\t\t bool readback,\n\t\t\t\t struct ttm_validate_buffer *val_buf);\nstatic int vmw_gb_context_destroy(struct vmw_resource *res);\nstatic int vmw_dx_context_create(struct vmw_resource *res);\nstatic int vmw_dx_context_bind(struct vmw_resource *res,\n\t\t\t       struct ttm_validate_buffer *val_buf);\nstatic int vmw_dx_context_unbind(struct vmw_resource *res,\n\t\t\t\t bool readback,\n\t\t\t\t struct ttm_validate_buffer *val_buf);\nstatic int vmw_dx_context_destroy(struct vmw_resource *res);\n\nstatic const struct vmw_user_resource_conv user_context_conv = {\n\t.object_type = VMW_RES_CONTEXT,\n\t.base_obj_to_res = vmw_user_context_base_to_res,\n\t.res_free = vmw_user_context_free\n};\n\nconst struct vmw_user_resource_conv *user_context_converter =\n\t&user_context_conv;\n\n\nstatic const struct vmw_res_func vmw_legacy_context_func = {\n\t.res_type = vmw_res_context,\n\t.needs_guest_memory = false,\n\t.may_evict = false,\n\t.type_name = \"legacy contexts\",\n\t.domain = VMW_BO_DOMAIN_SYS,\n\t.busy_domain = VMW_BO_DOMAIN_SYS,\n\t.create = NULL,\n\t.destroy = NULL,\n\t.bind = NULL,\n\t.unbind = NULL\n};\n\nstatic const struct vmw_res_func vmw_gb_context_func = {\n\t.res_type = vmw_res_context,\n\t.needs_guest_memory = true,\n\t.may_evict = true,\n\t.prio = 3,\n\t.dirty_prio = 3,\n\t.type_name = \"guest backed contexts\",\n\t.domain = VMW_BO_DOMAIN_MOB,\n\t.busy_domain = VMW_BO_DOMAIN_MOB,\n\t.create = vmw_gb_context_create,\n\t.destroy = vmw_gb_context_destroy,\n\t.bind = vmw_gb_context_bind,\n\t.unbind = vmw_gb_context_unbind\n};\n\nstatic const struct vmw_res_func vmw_dx_context_func = {\n\t.res_type = vmw_res_dx_context,\n\t.needs_guest_memory = true,\n\t.may_evict = true,\n\t.prio = 3,\n\t.dirty_prio = 3,\n\t.type_name = \"dx contexts\",\n\t.domain = VMW_BO_DOMAIN_MOB,\n\t.busy_domain = VMW_BO_DOMAIN_MOB,\n\t.create = vmw_dx_context_create,\n\t.destroy = vmw_dx_context_destroy,\n\t.bind = vmw_dx_context_bind,\n\t.unbind = vmw_dx_context_unbind\n};\n\n \n\nstatic void vmw_context_cotables_unref(struct vmw_private *dev_priv,\n\t\t\t\t       struct vmw_user_context *uctx)\n{\n\tstruct vmw_resource *res;\n\tint i;\n\tu32 cotable_max = has_sm5_context(dev_priv) ?\n\t\tSVGA_COTABLE_MAX : SVGA_COTABLE_DX10_MAX;\n\n\tfor (i = 0; i < cotable_max; ++i) {\n\t\tspin_lock(&uctx->cotable_lock);\n\t\tres = uctx->cotables[i];\n\t\tuctx->cotables[i] = NULL;\n\t\tspin_unlock(&uctx->cotable_lock);\n\n\t\tif (res)\n\t\t\tvmw_resource_unreference(&res);\n\t}\n}\n\nstatic void vmw_hw_context_destroy(struct vmw_resource *res)\n{\n\tstruct vmw_user_context *uctx =\n\t\tcontainer_of(res, struct vmw_user_context, res);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDestroyContext body;\n\t} *cmd;\n\n\n\tif (res->func->destroy == vmw_gb_context_destroy ||\n\t    res->func->destroy == vmw_dx_context_destroy) {\n\t\tmutex_lock(&dev_priv->cmdbuf_mutex);\n\t\tvmw_cmdbuf_res_man_destroy(uctx->man);\n\t\tmutex_lock(&dev_priv->binding_mutex);\n\t\tvmw_binding_state_kill(uctx->cbs);\n\t\t(void) res->func->destroy(res);\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t\tif (dev_priv->pinned_bo != NULL &&\n\t\t    !dev_priv->query_cid_valid)\n\t\t\t__vmw_execbuf_release_pinned_bo(dev_priv, NULL);\n\t\tmutex_unlock(&dev_priv->cmdbuf_mutex);\n\t\tvmw_context_cotables_unref(dev_priv, uctx);\n\t\treturn;\n\t}\n\n\tvmw_execbuf_release_pinned_bo(dev_priv);\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn;\n\n\tcmd->header.id = SVGA_3D_CMD_CONTEXT_DESTROY;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = res->id;\n\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\tvmw_fifo_resource_dec(dev_priv);\n}\n\nstatic int vmw_gb_context_init(struct vmw_private *dev_priv,\n\t\t\t       bool dx,\n\t\t\t       struct vmw_resource *res,\n\t\t\t       void (*res_free)(struct vmw_resource *res))\n{\n\tint ret, i;\n\tstruct vmw_user_context *uctx =\n\t\tcontainer_of(res, struct vmw_user_context, res);\n\n\tres->guest_memory_size = (dx ? sizeof(SVGADXContextMobFormat) :\n\t\t\t\t sizeof(SVGAGBContextData));\n\tret = vmw_resource_init(dev_priv, res, true,\n\t\t\t\tres_free,\n\t\t\t\tdx ? &vmw_dx_context_func :\n\t\t\t\t&vmw_gb_context_func);\n\tif (unlikely(ret != 0))\n\t\tgoto out_err;\n\n\tif (dev_priv->has_mob) {\n\t\tuctx->man = vmw_cmdbuf_res_man_create(dev_priv);\n\t\tif (IS_ERR(uctx->man)) {\n\t\t\tret = PTR_ERR(uctx->man);\n\t\t\tuctx->man = NULL;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tuctx->cbs = vmw_binding_state_alloc(dev_priv);\n\tif (IS_ERR(uctx->cbs)) {\n\t\tret = PTR_ERR(uctx->cbs);\n\t\tgoto out_err;\n\t}\n\n\tspin_lock_init(&uctx->cotable_lock);\n\n\tif (dx) {\n\t\tu32 cotable_max = has_sm5_context(dev_priv) ?\n\t\t\tSVGA_COTABLE_MAX : SVGA_COTABLE_DX10_MAX;\n\t\tfor (i = 0; i < cotable_max; ++i) {\n\t\t\tuctx->cotables[i] = vmw_cotable_alloc(dev_priv,\n\t\t\t\t\t\t\t      &uctx->res, i);\n\t\t\tif (IS_ERR(uctx->cotables[i])) {\n\t\t\t\tret = PTR_ERR(uctx->cotables[i]);\n\t\t\t\tgoto out_cotables;\n\t\t\t}\n\t\t}\n\t}\n\n\tres->hw_destroy = vmw_hw_context_destroy;\n\treturn 0;\n\nout_cotables:\n\tvmw_context_cotables_unref(dev_priv, uctx);\nout_err:\n\tif (res_free)\n\t\tres_free(res);\n\telse\n\t\tkfree(res);\n\treturn ret;\n}\n\nstatic int vmw_context_init(struct vmw_private *dev_priv,\n\t\t\t    struct vmw_resource *res,\n\t\t\t    void (*res_free)(struct vmw_resource *res),\n\t\t\t    bool dx)\n{\n\tint ret;\n\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDefineContext body;\n\t} *cmd;\n\n\tif (dev_priv->has_mob)\n\t\treturn vmw_gb_context_init(dev_priv, dx, res, res_free);\n\n\tret = vmw_resource_init(dev_priv, res, false,\n\t\t\t\tres_free, &vmw_legacy_context_func);\n\n\tif (unlikely(ret != 0)) {\n\t\tDRM_ERROR(\"Failed to allocate a resource id.\\n\");\n\t\tgoto out_early;\n\t}\n\n\tif (unlikely(res->id >= SVGA3D_HB_MAX_CONTEXT_IDS)) {\n\t\tDRM_ERROR(\"Out of hw context ids.\\n\");\n\t\tvmw_resource_unreference(&res);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL)) {\n\t\tvmw_resource_unreference(&res);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd->header.id = SVGA_3D_CMD_CONTEXT_DEFINE;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = res->id;\n\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\tvmw_fifo_resource_inc(dev_priv);\n\tres->hw_destroy = vmw_hw_context_destroy;\n\treturn 0;\n\nout_early:\n\tif (res_free == NULL)\n\t\tkfree(res);\n\telse\n\t\tres_free(res);\n\treturn ret;\n}\n\n\n \n\nstatic int vmw_gb_context_create(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tint ret;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDefineGBContext body;\n\t} *cmd;\n\n\tif (likely(res->id != -1))\n\t\treturn 0;\n\n\tret = vmw_resource_alloc_id(res);\n\tif (unlikely(ret != 0)) {\n\t\tDRM_ERROR(\"Failed to allocate a context id.\\n\");\n\t\tgoto out_no_id;\n\t}\n\n\tif (unlikely(res->id >= VMWGFX_NUM_GB_CONTEXT)) {\n\t\tret = -EBUSY;\n\t\tgoto out_no_fifo;\n\t}\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_fifo;\n\t}\n\n\tcmd->header.id = SVGA_3D_CMD_DEFINE_GB_CONTEXT;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = res->id;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\tvmw_fifo_resource_inc(dev_priv);\n\n\treturn 0;\n\nout_no_fifo:\n\tvmw_resource_release_id(res);\nout_no_id:\n\treturn ret;\n}\n\nstatic int vmw_gb_context_bind(struct vmw_resource *res,\n\t\t\t       struct ttm_validate_buffer *val_buf)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdBindGBContext body;\n\t} *cmd;\n\tstruct ttm_buffer_object *bo = val_buf->bo;\n\n\tBUG_ON(bo->resource->mem_type != VMW_PL_MOB);\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_BIND_GB_CONTEXT;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = res->id;\n\tcmd->body.mobid = bo->resource->start;\n\tcmd->body.validContents = res->guest_memory_dirty;\n\tres->guest_memory_dirty = false;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\treturn 0;\n}\n\nstatic int vmw_gb_context_unbind(struct vmw_resource *res,\n\t\t\t\t bool readback,\n\t\t\t\t struct ttm_validate_buffer *val_buf)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct ttm_buffer_object *bo = val_buf->bo;\n\tstruct vmw_fence_obj *fence;\n\tstruct vmw_user_context *uctx =\n\t\tcontainer_of(res, struct vmw_user_context, res);\n\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdReadbackGBContext body;\n\t} *cmd1;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdBindGBContext body;\n\t} *cmd2;\n\tuint32_t submit_size;\n\tuint8_t *cmd;\n\n\n\tBUG_ON(bo->resource->mem_type != VMW_PL_MOB);\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tvmw_binding_state_scrub(uctx->cbs);\n\n\tsubmit_size = sizeof(*cmd2) + (readback ? sizeof(*cmd1) : 0);\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, submit_size);\n\tif (unlikely(cmd == NULL)) {\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd2 = (void *) cmd;\n\tif (readback) {\n\t\tcmd1 = (void *) cmd;\n\t\tcmd1->header.id = SVGA_3D_CMD_READBACK_GB_CONTEXT;\n\t\tcmd1->header.size = sizeof(cmd1->body);\n\t\tcmd1->body.cid = res->id;\n\t\tcmd2 = (void *) (&cmd1[1]);\n\t}\n\tcmd2->header.id = SVGA_3D_CMD_BIND_GB_CONTEXT;\n\tcmd2->header.size = sizeof(cmd2->body);\n\tcmd2->body.cid = res->id;\n\tcmd2->body.mobid = SVGA3D_INVALID_ID;\n\n\tvmw_cmd_commit(dev_priv, submit_size);\n\tmutex_unlock(&dev_priv->binding_mutex);\n\n\t \n\n\t(void) vmw_execbuf_fence_commands(NULL, dev_priv,\n\t\t\t\t\t  &fence, NULL);\n\n\tvmw_bo_fence_single(bo, fence);\n\n\tif (likely(fence != NULL))\n\t\tvmw_fence_obj_unreference(&fence);\n\n\treturn 0;\n}\n\nstatic int vmw_gb_context_destroy(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDestroyGBContext body;\n\t} *cmd;\n\n\tif (likely(res->id == -1))\n\t\treturn 0;\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_DESTROY_GB_CONTEXT;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = res->id;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\tif (dev_priv->query_cid == res->id)\n\t\tdev_priv->query_cid_valid = false;\n\tvmw_resource_release_id(res);\n\tvmw_fifo_resource_dec(dev_priv);\n\n\treturn 0;\n}\n\n \n\nstatic int vmw_dx_context_create(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tint ret;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXDefineContext body;\n\t} *cmd;\n\n\tif (likely(res->id != -1))\n\t\treturn 0;\n\n\tret = vmw_resource_alloc_id(res);\n\tif (unlikely(ret != 0)) {\n\t\tDRM_ERROR(\"Failed to allocate a context id.\\n\");\n\t\tgoto out_no_id;\n\t}\n\n\tif (unlikely(res->id >= VMWGFX_NUM_DXCONTEXT)) {\n\t\tret = -EBUSY;\n\t\tgoto out_no_fifo;\n\t}\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_fifo;\n\t}\n\n\tcmd->header.id = SVGA_3D_CMD_DX_DEFINE_CONTEXT;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = res->id;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\tvmw_fifo_resource_inc(dev_priv);\n\n\treturn 0;\n\nout_no_fifo:\n\tvmw_resource_release_id(res);\nout_no_id:\n\treturn ret;\n}\n\nstatic int vmw_dx_context_bind(struct vmw_resource *res,\n\t\t\t       struct ttm_validate_buffer *val_buf)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXBindContext body;\n\t} *cmd;\n\tstruct ttm_buffer_object *bo = val_buf->bo;\n\n\tBUG_ON(bo->resource->mem_type != VMW_PL_MOB);\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_DX_BIND_CONTEXT;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = res->id;\n\tcmd->body.mobid = bo->resource->start;\n\tcmd->body.validContents = res->guest_memory_dirty;\n\tres->guest_memory_dirty = false;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\n\treturn 0;\n}\n\n \nvoid vmw_dx_context_scrub_cotables(struct vmw_resource *ctx,\n\t\t\t\t   bool readback)\n{\n\tstruct vmw_user_context *uctx =\n\t\tcontainer_of(ctx, struct vmw_user_context, res);\n\tu32 cotable_max = has_sm5_context(ctx->dev_priv) ?\n\t\tSVGA_COTABLE_MAX : SVGA_COTABLE_DX10_MAX;\n\tint i;\n\n\tvmw_binding_state_scrub(uctx->cbs);\n\tfor (i = 0; i < cotable_max; ++i) {\n\t\tstruct vmw_resource *res;\n\n\t\t \n\t\tspin_lock(&uctx->cotable_lock);\n\t\tres = uctx->cotables[vmw_cotable_scrub_order[i]];\n\t\tif (res)\n\t\t\tres = vmw_resource_reference_unless_doomed(res);\n\t\tspin_unlock(&uctx->cotable_lock);\n\t\tif (!res)\n\t\t\tcontinue;\n\n\t\tWARN_ON(vmw_cotable_scrub(res, readback));\n\t\tvmw_resource_unreference(&res);\n\t}\n}\n\nstatic int vmw_dx_context_unbind(struct vmw_resource *res,\n\t\t\t\t bool readback,\n\t\t\t\t struct ttm_validate_buffer *val_buf)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct ttm_buffer_object *bo = val_buf->bo;\n\tstruct vmw_fence_obj *fence;\n\tstruct vmw_user_context *uctx =\n\t\tcontainer_of(res, struct vmw_user_context, res);\n\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXReadbackContext body;\n\t} *cmd1;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXBindContext body;\n\t} *cmd2;\n\tuint32_t submit_size;\n\tuint8_t *cmd;\n\n\n\tBUG_ON(bo->resource->mem_type != VMW_PL_MOB);\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tvmw_dx_context_scrub_cotables(res, readback);\n\n\tif (uctx->dx_query_mob && uctx->dx_query_mob->dx_query_ctx &&\n\t    readback) {\n\t\tWARN_ON(uctx->dx_query_mob->dx_query_ctx != res);\n\t\tif (vmw_query_readback_all(uctx->dx_query_mob))\n\t\t\tDRM_ERROR(\"Failed to read back query states\\n\");\n\t}\n\n\tsubmit_size = sizeof(*cmd2) + (readback ? sizeof(*cmd1) : 0);\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, submit_size);\n\tif (unlikely(cmd == NULL)) {\n\t\tmutex_unlock(&dev_priv->binding_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd2 = (void *) cmd;\n\tif (readback) {\n\t\tcmd1 = (void *) cmd;\n\t\tcmd1->header.id = SVGA_3D_CMD_DX_READBACK_CONTEXT;\n\t\tcmd1->header.size = sizeof(cmd1->body);\n\t\tcmd1->body.cid = res->id;\n\t\tcmd2 = (void *) (&cmd1[1]);\n\t}\n\tcmd2->header.id = SVGA_3D_CMD_DX_BIND_CONTEXT;\n\tcmd2->header.size = sizeof(cmd2->body);\n\tcmd2->body.cid = res->id;\n\tcmd2->body.mobid = SVGA3D_INVALID_ID;\n\n\tvmw_cmd_commit(dev_priv, submit_size);\n\tmutex_unlock(&dev_priv->binding_mutex);\n\n\t \n\n\t(void) vmw_execbuf_fence_commands(NULL, dev_priv,\n\t\t\t\t\t  &fence, NULL);\n\n\tvmw_bo_fence_single(bo, fence);\n\n\tif (likely(fence != NULL))\n\t\tvmw_fence_obj_unreference(&fence);\n\n\treturn 0;\n}\n\nstatic int vmw_dx_context_destroy(struct vmw_resource *res)\n{\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXDestroyContext body;\n\t} *cmd;\n\n\tif (likely(res->id == -1))\n\t\treturn 0;\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_DX_DESTROY_CONTEXT;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = res->id;\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\tif (dev_priv->query_cid == res->id)\n\t\tdev_priv->query_cid_valid = false;\n\tvmw_resource_release_id(res);\n\tvmw_fifo_resource_dec(dev_priv);\n\n\treturn 0;\n}\n\n \n\nstatic struct vmw_resource *\nvmw_user_context_base_to_res(struct ttm_base_object *base)\n{\n\treturn &(container_of(base, struct vmw_user_context, base)->res);\n}\n\nstatic void vmw_user_context_free(struct vmw_resource *res)\n{\n\tstruct vmw_user_context *ctx =\n\t    container_of(res, struct vmw_user_context, res);\n\n\tif (ctx->cbs)\n\t\tvmw_binding_state_free(ctx->cbs);\n\n\t(void) vmw_context_bind_dx_query(res, NULL);\n\n\tttm_base_object_kfree(ctx, base);\n}\n\n \n\nstatic void vmw_user_context_base_release(struct ttm_base_object **p_base)\n{\n\tstruct ttm_base_object *base = *p_base;\n\tstruct vmw_user_context *ctx =\n\t    container_of(base, struct vmw_user_context, base);\n\tstruct vmw_resource *res = &ctx->res;\n\n\t*p_base = NULL;\n\tvmw_resource_unreference(&res);\n}\n\nint vmw_context_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_vmw_context_arg *arg = (struct drm_vmw_context_arg *)data;\n\tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n\n\treturn ttm_ref_object_base_unref(tfile, arg->cid);\n}\n\nstatic int vmw_context_define(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv, bool dx)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct vmw_user_context *ctx;\n\tstruct vmw_resource *res;\n\tstruct vmw_resource *tmp;\n\tstruct drm_vmw_context_arg *arg = (struct drm_vmw_context_arg *)data;\n\tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n\tint ret;\n\n\tif (!has_sm4_context(dev_priv) && dx) {\n\t\tVMW_DEBUG_USER(\"DX contexts not supported by device.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (unlikely(!ctx)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\n\tres = &ctx->res;\n\tctx->base.shareable = false;\n\tctx->base.tfile = NULL;\n\n\t \n\n\tret = vmw_context_init(dev_priv, res, vmw_user_context_free, dx);\n\tif (unlikely(ret != 0))\n\t\tgoto out_ret;\n\n\ttmp = vmw_resource_reference(&ctx->res);\n\tret = ttm_base_object_init(tfile, &ctx->base, false, VMW_RES_CONTEXT,\n\t\t\t\t   &vmw_user_context_base_release);\n\n\tif (unlikely(ret != 0)) {\n\t\tvmw_resource_unreference(&tmp);\n\t\tgoto out_err;\n\t}\n\n\targ->cid = ctx->base.handle;\nout_err:\n\tvmw_resource_unreference(&res);\nout_ret:\n\treturn ret;\n}\n\nint vmw_context_define_ioctl(struct drm_device *dev, void *data,\n\t\t\t     struct drm_file *file_priv)\n{\n\treturn vmw_context_define(dev, data, file_priv, false);\n}\n\nint vmw_extended_context_define_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t      struct drm_file *file_priv)\n{\n\tunion drm_vmw_extended_context_arg *arg = (typeof(arg)) data;\n\tstruct drm_vmw_context_arg *rep = &arg->rep;\n\n\tswitch (arg->req) {\n\tcase drm_vmw_context_legacy:\n\t\treturn vmw_context_define(dev, rep, file_priv, false);\n\tcase drm_vmw_context_dx:\n\t\treturn vmw_context_define(dev, rep, file_priv, true);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\n \nstruct list_head *vmw_context_binding_list(struct vmw_resource *ctx)\n{\n\tstruct vmw_user_context *uctx =\n\t\tcontainer_of(ctx, struct vmw_user_context, res);\n\n\treturn vmw_binding_state_list(uctx->cbs);\n}\n\nstruct vmw_cmdbuf_res_manager *vmw_context_res_man(struct vmw_resource *ctx)\n{\n\treturn container_of(ctx, struct vmw_user_context, res)->man;\n}\n\nstruct vmw_resource *vmw_context_cotable(struct vmw_resource *ctx,\n\t\t\t\t\t SVGACOTableType cotable_type)\n{\n\tu32 cotable_max = has_sm5_context(ctx->dev_priv) ?\n\t\tSVGA_COTABLE_MAX : SVGA_COTABLE_DX10_MAX;\n\n\tif (cotable_type >= cotable_max)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn container_of(ctx, struct vmw_user_context, res)->\n\t\tcotables[cotable_type];\n}\n\n \nstruct vmw_ctx_binding_state *\nvmw_context_binding_state(struct vmw_resource *ctx)\n{\n\treturn container_of(ctx, struct vmw_user_context, res)->cbs;\n}\n\n \nint vmw_context_bind_dx_query(struct vmw_resource *ctx_res,\n\t\t\t      struct vmw_bo *mob)\n{\n\tstruct vmw_user_context *uctx =\n\t\tcontainer_of(ctx_res, struct vmw_user_context, res);\n\n\tif (mob == NULL) {\n\t\tif (uctx->dx_query_mob) {\n\t\t\tuctx->dx_query_mob->dx_query_ctx = NULL;\n\t\t\tvmw_bo_unreference(&uctx->dx_query_mob);\n\t\t\tuctx->dx_query_mob = NULL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (uctx->dx_query_mob && uctx->dx_query_mob != mob)\n\t\treturn -EINVAL;\n\n\tmob->dx_query_ctx  = ctx_res;\n\n\tif (!uctx->dx_query_mob)\n\t\tuctx->dx_query_mob = vmw_bo_reference(mob);\n\n\treturn 0;\n}\n\n \nstruct vmw_bo *\nvmw_context_get_dx_query_mob(struct vmw_resource *ctx_res)\n{\n\tstruct vmw_user_context *uctx =\n\t\tcontainer_of(ctx_res, struct vmw_user_context, res);\n\n\treturn uctx->dx_query_mob;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}