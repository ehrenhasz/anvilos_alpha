{
  "module_name": "vmwgfx_devcaps.c",
  "hash_id": "c020b11024c3ea31b523923d0ad8db76607d62f024d38a8f54b9e2c33d63e85b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_devcaps.c",
  "human_readable_source": " \n \n\n#include \"vmwgfx_devcaps.h\"\n\n#include \"vmwgfx_drv.h\"\n\n\nstruct svga_3d_compat_cap {\n\tSVGA3dFifoCapsRecordHeader header;\n\tSVGA3dFifoCapPair pairs[SVGA3D_DEVCAP_MAX];\n};\n\n\nstatic u32 vmw_mask_legacy_multisample(unsigned int cap, u32 fmt_value)\n{\n\t \n\tif (cap == SVGA3D_DEVCAP_DEAD5)\n\t\treturn 0;\n\n\treturn fmt_value;\n}\n\nstatic int vmw_fill_compat_cap(struct vmw_private *dev_priv, void *bounce,\n\t\t\t       size_t size)\n{\n\tstruct svga_3d_compat_cap *compat_cap =\n\t\t(struct svga_3d_compat_cap *) bounce;\n\tunsigned int i;\n\tsize_t pair_offset = offsetof(struct svga_3d_compat_cap, pairs);\n\tunsigned int max_size;\n\n\tif (size < pair_offset)\n\t\treturn -EINVAL;\n\n\tmax_size = (size - pair_offset) / sizeof(SVGA3dFifoCapPair);\n\n\tif (max_size > SVGA3D_DEVCAP_MAX)\n\t\tmax_size = SVGA3D_DEVCAP_MAX;\n\n\tcompat_cap->header.length =\n\t\t(pair_offset + max_size * sizeof(SVGA3dFifoCapPair)) / sizeof(u32);\n\tcompat_cap->header.type = SVGA3D_FIFO_CAPS_RECORD_DEVCAPS;\n\n\tfor (i = 0; i < max_size; ++i) {\n\t\tcompat_cap->pairs[i][0] = i;\n\t\tcompat_cap->pairs[i][1] = vmw_mask_legacy_multisample\n\t\t\t(i, dev_priv->devcaps[i]);\n\t}\n\n\treturn 0;\n}\n\nint vmw_devcaps_create(struct vmw_private *vmw)\n{\n\tbool gb_objects = !!(vmw->capabilities & SVGA_CAP_GBOBJECTS);\n\tuint32_t i;\n\n\tif (gb_objects) {\n\t\tvmw->devcaps = vzalloc(sizeof(uint32_t) * SVGA3D_DEVCAP_MAX);\n\t\tif (!vmw->devcaps)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < SVGA3D_DEVCAP_MAX; ++i) {\n\t\t\tvmw_write(vmw, SVGA_REG_DEV_CAP, i);\n\t\t\tvmw->devcaps[i] = vmw_read(vmw, SVGA_REG_DEV_CAP);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid vmw_devcaps_destroy(struct vmw_private *vmw)\n{\n\tvfree(vmw->devcaps);\n\tvmw->devcaps = NULL;\n}\n\n\nuint32 vmw_devcaps_size(const struct vmw_private *vmw,\n\t\t\tbool gb_aware)\n{\n\tbool gb_objects = !!(vmw->capabilities & SVGA_CAP_GBOBJECTS);\n\tif (gb_objects && gb_aware)\n\t\treturn SVGA3D_DEVCAP_MAX * sizeof(uint32_t);\n\telse if (gb_objects)\n\t\treturn  sizeof(struct svga_3d_compat_cap) +\n\t\t\t\tsizeof(uint32_t);\n\telse if (vmw->fifo_mem != NULL)\n\t\treturn (SVGA_FIFO_3D_CAPS_LAST - SVGA_FIFO_3D_CAPS + 1) *\n\t\t\t\tsizeof(uint32_t);\n\telse\n\t\treturn 0;\n}\n\nint vmw_devcaps_copy(struct vmw_private *vmw, bool gb_aware,\n\t\t     void *dst, uint32_t dst_size)\n{\n\tint ret;\n\tbool gb_objects = !!(vmw->capabilities & SVGA_CAP_GBOBJECTS);\n\tif (gb_objects && gb_aware) {\n\t\tmemcpy(dst, vmw->devcaps, dst_size);\n\t} else if (gb_objects) {\n\t\tret = vmw_fill_compat_cap(vmw, dst, dst_size);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\t} else if (vmw->fifo_mem) {\n\t\tu32 *fifo_mem = vmw->fifo_mem;\n\t\tmemcpy(dst, &fifo_mem[SVGA_FIFO_3D_CAPS], dst_size);\n\t} else\n\t\treturn -EINVAL;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}