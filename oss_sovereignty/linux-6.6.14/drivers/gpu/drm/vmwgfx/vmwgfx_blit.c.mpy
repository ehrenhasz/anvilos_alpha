{
  "module_name": "vmwgfx_blit.c",
  "hash_id": "27e9fec5eec84cc989c0389162f590f316cd6f300d043430ae719c90356ec4e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_blit.c",
  "human_readable_source": "\n \n\n#include \"vmwgfx_drv.h\"\n#include <linux/highmem.h>\n\n \n#define VMW_FIND_FIRST_DIFF(_type)\t\t\t \\\nstatic size_t vmw_find_first_diff_ ## _type\t\t \\\n\t(const _type * dst, const _type * src, size_t size)\\\n{\t\t\t\t\t\t\t \\\n\tsize_t i;\t\t\t\t\t \\\n\t\t\t\t\t\t\t \\\n\tfor (i = 0; i < size; i += sizeof(_type)) {\t \\\n\t\tif (*dst++ != *src++)\t\t\t \\\n\t\t\tbreak;\t\t\t\t \\\n\t}\t\t\t\t\t\t \\\n\t\t\t\t\t\t\t \\\n\treturn i;\t\t\t\t\t \\\n}\n\n\n \n#define VMW_FIND_LAST_DIFF(_type)\t\t\t\t\t\\\nstatic ssize_t vmw_find_last_diff_ ## _type(\t\t\t\t\\\n\tconst _type * dst, const _type * src, size_t size)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\twhile (size) {\t\t\t\t\t\t\t\\\n\t\tif (*--dst != *--src)\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tsize -= sizeof(_type);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn size;\t\t\t\t\t\t\t\\\n}\n\n\n \nVMW_FIND_FIRST_DIFF(u8);\nVMW_FIND_LAST_DIFF(u8);\n\nVMW_FIND_FIRST_DIFF(u16);\nVMW_FIND_LAST_DIFF(u16);\n\nVMW_FIND_FIRST_DIFF(u32);\nVMW_FIND_LAST_DIFF(u32);\n\n#ifdef CONFIG_64BIT\nVMW_FIND_FIRST_DIFF(u64);\nVMW_FIND_LAST_DIFF(u64);\n#endif\n\n\n \n#define SPILL(_var, _type) ((unsigned long) _var & (sizeof(_type) - 1))\n\n\n \n#define VMW_TRY_FIND_FIRST_DIFF(_type)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tunsigned int spill = SPILL(dst, _type);\t\t\t\t\\\n\tsize_t diff_offs;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (spill && spill == SPILL(src, _type) &&\t\t\t\\\n\t    sizeof(_type) - spill <= size) {\t\t\t\t\\\n\t\tspill = sizeof(_type) - spill;\t\t\t\t\\\n\t\tdiff_offs = vmw_find_first_diff_u8(dst, src, spill);\t\\\n\t\tif (diff_offs < spill)\t\t\t\t\t\\\n\t\t\treturn round_down(offset + diff_offs, granularity); \\\n\t\t\t\t\t\t\t\t\t\\\n\t\tdst += spill;\t\t\t\t\t\t\\\n\t\tsrc += spill;\t\t\t\t\t\t\\\n\t\tsize -= spill;\t\t\t\t\t\t\\\n\t\toffset += spill;\t\t\t\t\t\\\n\t\tspill = 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (!spill && !SPILL(src, _type)) {\t\t\t\t\\\n\t\tsize_t to_copy = size &\t ~(sizeof(_type) - 1);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tdiff_offs = vmw_find_first_diff_ ## _type\t\t\\\n\t\t\t((_type *) dst, (_type *) src, to_copy);\t\\\n\t\tif (diff_offs >= size || granularity == sizeof(_type))\t\\\n\t\t\treturn (offset + diff_offs);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tdst += diff_offs;\t\t\t\t\t\\\n\t\tsrc += diff_offs;\t\t\t\t\t\\\n\t\tsize -= diff_offs;\t\t\t\t\t\\\n\t\toffset += diff_offs;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\t\t\t\t\t\t\t\t\\\n\n\n \nstatic size_t vmw_find_first_diff(const u8 *dst, const u8 *src, size_t size,\n\t\t\t\t  size_t granularity)\n{\n\tsize_t offset = 0;\n\n\t \n#ifdef CONFIG_64BIT\n\tVMW_TRY_FIND_FIRST_DIFF(u64);\n#endif\n\tVMW_TRY_FIND_FIRST_DIFF(u32);\n\tVMW_TRY_FIND_FIRST_DIFF(u16);\n\n\treturn round_down(offset + vmw_find_first_diff_u8(dst, src, size),\n\t\t\t  granularity);\n}\n\n\n \n#define VMW_TRY_FIND_LAST_DIFF(_type)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tunsigned int spill = SPILL(dst, _type);\t\t\t\t\\\n\tssize_t location;\t\t\t\t\t\t\\\n\tssize_t diff_offs;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (spill && spill <= size && spill == SPILL(src, _type)) {\t\\\n\t\tdiff_offs = vmw_find_last_diff_u8(dst, src, spill);\t\\\n\t\tif (diff_offs) {\t\t\t\t\t\\\n\t\t\tlocation = size - spill + diff_offs - 1;\t\\\n\t\t\treturn round_down(location, granularity);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tdst -= spill;\t\t\t\t\t\t\\\n\t\tsrc -= spill;\t\t\t\t\t\t\\\n\t\tsize -= spill;\t\t\t\t\t\t\\\n\t\tspill = 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (!spill && !SPILL(src, _type)) {\t\t\t\t\\\n\t\tsize_t to_copy = round_down(size, sizeof(_type));\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tdiff_offs = vmw_find_last_diff_ ## _type\t\t\\\n\t\t\t((_type *) dst, (_type *) src, to_copy);\t\\\n\t\tlocation = size - to_copy + diff_offs - sizeof(_type);\t\\\n\t\tif (location < 0 || granularity == sizeof(_type))\t\\\n\t\t\treturn location;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tdst -= to_copy - diff_offs;\t\t\t\t\\\n\t\tsrc -= to_copy - diff_offs;\t\t\t\t\\\n\t\tsize -= to_copy - diff_offs;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\n \nstatic ssize_t vmw_find_last_diff(const u8 *dst, const u8 *src, size_t size,\n\t\t\t\t  size_t granularity)\n{\n\tdst += size;\n\tsrc += size;\n\n#ifdef CONFIG_64BIT\n\tVMW_TRY_FIND_LAST_DIFF(u64);\n#endif\n\tVMW_TRY_FIND_LAST_DIFF(u32);\n\tVMW_TRY_FIND_LAST_DIFF(u16);\n\n\treturn round_down(vmw_find_last_diff_u8(dst, src, size) - 1,\n\t\t\t  granularity);\n}\n\n\n \nvoid vmw_memcpy(struct vmw_diff_cpy *diff, u8 *dest, const u8 *src, size_t n)\n{\n\tmemcpy(dest, src, n);\n}\n\n\n \nstatic void vmw_adjust_rect(struct vmw_diff_cpy *diff, size_t diff_offs)\n{\n\tsize_t offs = (diff_offs + diff->line_offset) / diff->cpp;\n\tstruct drm_rect *rect = &diff->rect;\n\n\trect->x1 = min_t(int, rect->x1, offs);\n\trect->x2 = max_t(int, rect->x2, offs + 1);\n\trect->y1 = min_t(int, rect->y1, diff->line);\n\trect->y2 = max_t(int, rect->y2, diff->line + 1);\n}\n\n \nvoid vmw_diff_memcpy(struct vmw_diff_cpy *diff, u8 *dest, const u8 *src,\n\t\t     size_t n)\n{\n\tssize_t csize, byte_len;\n\n\tif (WARN_ON_ONCE(round_down(n, diff->cpp) != n))\n\t\treturn;\n\n\t \n\tcsize = vmw_find_first_diff(dest, src, n, diff->cpp);\n\tif (csize < n) {\n\t\tvmw_adjust_rect(diff, csize);\n\t\tbyte_len = diff->cpp;\n\n\t\t \n\t\tdiff->line_offset += csize;\n\t\tdest += csize;\n\t\tsrc += csize;\n\t\tn -= csize;\n\t\tcsize = vmw_find_last_diff(dest, src, n, diff->cpp);\n\t\tif (csize >= 0) {\n\t\t\tbyte_len += csize;\n\t\t\tvmw_adjust_rect(diff, csize);\n\t\t}\n\t\tmemcpy(dest, src, byte_len);\n\t}\n\tdiff->line_offset += n;\n}\n\n \nstruct vmw_bo_blit_line_data {\n\tu32 mapped_dst;\n\tu8 *dst_addr;\n\tstruct page **dst_pages;\n\tu32 dst_num_pages;\n\tpgprot_t dst_prot;\n\tu32 mapped_src;\n\tu8 *src_addr;\n\tstruct page **src_pages;\n\tu32 src_num_pages;\n\tpgprot_t src_prot;\n\tstruct vmw_diff_cpy *diff;\n};\n\n \nstatic int vmw_bo_cpu_blit_line(struct vmw_bo_blit_line_data *d,\n\t\t\t\tu32 dst_offset,\n\t\t\t\tu32 src_offset,\n\t\t\t\tu32 bytes_to_copy)\n{\n\tstruct vmw_diff_cpy *diff = d->diff;\n\n\twhile (bytes_to_copy) {\n\t\tu32 copy_size = bytes_to_copy;\n\t\tu32 dst_page = dst_offset >> PAGE_SHIFT;\n\t\tu32 src_page = src_offset >> PAGE_SHIFT;\n\t\tu32 dst_page_offset = dst_offset & ~PAGE_MASK;\n\t\tu32 src_page_offset = src_offset & ~PAGE_MASK;\n\t\tbool unmap_dst = d->dst_addr && dst_page != d->mapped_dst;\n\t\tbool unmap_src = d->src_addr && (src_page != d->mapped_src ||\n\t\t\t\t\t\t unmap_dst);\n\n\t\tcopy_size = min_t(u32, copy_size, PAGE_SIZE - dst_page_offset);\n\t\tcopy_size = min_t(u32, copy_size, PAGE_SIZE - src_page_offset);\n\n\t\tif (unmap_src) {\n\t\t\tkunmap_atomic(d->src_addr);\n\t\t\td->src_addr = NULL;\n\t\t}\n\n\t\tif (unmap_dst) {\n\t\t\tkunmap_atomic(d->dst_addr);\n\t\t\td->dst_addr = NULL;\n\t\t}\n\n\t\tif (!d->dst_addr) {\n\t\t\tif (WARN_ON_ONCE(dst_page >= d->dst_num_pages))\n\t\t\t\treturn -EINVAL;\n\n\t\t\td->dst_addr =\n\t\t\t\tkmap_atomic_prot(d->dst_pages[dst_page],\n\t\t\t\t\t\t d->dst_prot);\n\t\t\tif (!d->dst_addr)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\td->mapped_dst = dst_page;\n\t\t}\n\n\t\tif (!d->src_addr) {\n\t\t\tif (WARN_ON_ONCE(src_page >= d->src_num_pages))\n\t\t\t\treturn -EINVAL;\n\n\t\t\td->src_addr =\n\t\t\t\tkmap_atomic_prot(d->src_pages[src_page],\n\t\t\t\t\t\t d->src_prot);\n\t\t\tif (!d->src_addr)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\td->mapped_src = src_page;\n\t\t}\n\t\tdiff->do_cpy(diff, d->dst_addr + dst_page_offset,\n\t\t\t     d->src_addr + src_page_offset, copy_size);\n\n\t\tbytes_to_copy -= copy_size;\n\t\tdst_offset += copy_size;\n\t\tsrc_offset += copy_size;\n\t}\n\n\treturn 0;\n}\n\n \nint vmw_bo_cpu_blit(struct ttm_buffer_object *dst,\n\t\t    u32 dst_offset, u32 dst_stride,\n\t\t    struct ttm_buffer_object *src,\n\t\t    u32 src_offset, u32 src_stride,\n\t\t    u32 w, u32 h,\n\t\t    struct vmw_diff_cpy *diff)\n{\n\tstruct ttm_operation_ctx ctx = {\n\t\t.interruptible = false,\n\t\t.no_wait_gpu = false\n\t};\n\tu32 j, initial_line = dst_offset / dst_stride;\n\tstruct vmw_bo_blit_line_data d;\n\tint ret = 0;\n\n\t \n\tif (!(dst->pin_count))\n\t\tdma_resv_assert_held(dst->base.resv);\n\tif (!(src->pin_count))\n\t\tdma_resv_assert_held(src->base.resv);\n\n\tif (!ttm_tt_is_populated(dst->ttm)) {\n\t\tret = dst->bdev->funcs->ttm_tt_populate(dst->bdev, dst->ttm, &ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!ttm_tt_is_populated(src->ttm)) {\n\t\tret = src->bdev->funcs->ttm_tt_populate(src->bdev, src->ttm, &ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\td.mapped_dst = 0;\n\td.mapped_src = 0;\n\td.dst_addr = NULL;\n\td.src_addr = NULL;\n\td.dst_pages = dst->ttm->pages;\n\td.src_pages = src->ttm->pages;\n\td.dst_num_pages = PFN_UP(dst->resource->size);\n\td.src_num_pages = PFN_UP(src->resource->size);\n\td.dst_prot = ttm_io_prot(dst, dst->resource, PAGE_KERNEL);\n\td.src_prot = ttm_io_prot(src, src->resource, PAGE_KERNEL);\n\td.diff = diff;\n\n\tfor (j = 0; j < h; ++j) {\n\t\tdiff->line = j + initial_line;\n\t\tdiff->line_offset = dst_offset % dst_stride;\n\t\tret = vmw_bo_cpu_blit_line(&d, dst_offset, src_offset, w);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tdst_offset += dst_stride;\n\t\tsrc_offset += src_stride;\n\t}\nout:\n\tif (d.src_addr)\n\t\tkunmap_atomic(d.src_addr);\n\tif (d.dst_addr)\n\t\tkunmap_atomic(d.dst_addr);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}