{
  "module_name": "vmwgfx_cotable.c",
  "hash_id": "79d2915197e6cb6c4fd6a4fbe0bbcef48d9a85c7b7f3851d973eb524fc8c724c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_cotable.c",
  "human_readable_source": "\n \n \n\n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_mksstat.h\"\n#include \"vmwgfx_resource_priv.h\"\n#include \"vmwgfx_so.h\"\n\n#include <drm/ttm/ttm_placement.h>\n\n \nstruct vmw_cotable {\n\tstruct vmw_resource res;\n\tstruct vmw_resource *ctx;\n\tsize_t size_read_back;\n\tint seen_entries;\n\tu32 type;\n\tbool scrubbed;\n\tstruct list_head resource_list;\n};\n\n \nstruct vmw_cotable_info {\n\tu32 min_initial_entries;\n\tu32 size;\n\tvoid (*unbind_func)(struct vmw_private *, struct list_head *,\n\t\t\t    bool);\n};\n\n\n \nstatic const struct vmw_cotable_info co_info[] = {\n\t{1, sizeof(SVGACOTableDXRTViewEntry), &vmw_view_cotable_list_destroy},\n\t{1, sizeof(SVGACOTableDXDSViewEntry), &vmw_view_cotable_list_destroy},\n\t{1, sizeof(SVGACOTableDXSRViewEntry), &vmw_view_cotable_list_destroy},\n\t{PAGE_SIZE/sizeof(SVGACOTableDXElementLayoutEntry) + 1, sizeof(SVGACOTableDXElementLayoutEntry), NULL},\n\t{PAGE_SIZE/sizeof(SVGACOTableDXBlendStateEntry) + 1, sizeof(SVGACOTableDXBlendStateEntry), NULL},\n\t{1, sizeof(SVGACOTableDXDepthStencilEntry), NULL},\n\t{1, sizeof(SVGACOTableDXRasterizerStateEntry), NULL},\n\t{1, sizeof(SVGACOTableDXSamplerEntry), NULL},\n\t{1, sizeof(SVGACOTableDXStreamOutputEntry), &vmw_dx_streamoutput_cotable_list_scrub},\n\t{1, sizeof(SVGACOTableDXQueryEntry), NULL},\n\t{1, sizeof(SVGACOTableDXShaderEntry), &vmw_dx_shader_cotable_list_scrub},\n\t{1, sizeof(SVGACOTableDXUAViewEntry), &vmw_view_cotable_list_destroy}\n};\n\n \nconst SVGACOTableType vmw_cotable_scrub_order[] = {\n\tSVGA_COTABLE_RTVIEW,\n\tSVGA_COTABLE_DSVIEW,\n\tSVGA_COTABLE_SRVIEW,\n\tSVGA_COTABLE_DXSHADER,\n\tSVGA_COTABLE_ELEMENTLAYOUT,\n\tSVGA_COTABLE_BLENDSTATE,\n\tSVGA_COTABLE_DEPTHSTENCIL,\n\tSVGA_COTABLE_RASTERIZERSTATE,\n\tSVGA_COTABLE_SAMPLER,\n\tSVGA_COTABLE_STREAMOUTPUT,\n\tSVGA_COTABLE_DXQUERY,\n\tSVGA_COTABLE_UAVIEW,\n};\n\nstatic int vmw_cotable_bind(struct vmw_resource *res,\n\t\t\t    struct ttm_validate_buffer *val_buf);\nstatic int vmw_cotable_unbind(struct vmw_resource *res,\n\t\t\t      bool readback,\n\t\t\t      struct ttm_validate_buffer *val_buf);\nstatic int vmw_cotable_create(struct vmw_resource *res);\nstatic int vmw_cotable_destroy(struct vmw_resource *res);\n\nstatic const struct vmw_res_func vmw_cotable_func = {\n\t.res_type = vmw_res_cotable,\n\t.needs_guest_memory = true,\n\t.may_evict = true,\n\t.prio = 3,\n\t.dirty_prio = 3,\n\t.type_name = \"context guest backed object tables\",\n\t.domain = VMW_BO_DOMAIN_MOB,\n\t.busy_domain = VMW_BO_DOMAIN_MOB,\n\t.create = vmw_cotable_create,\n\t.destroy = vmw_cotable_destroy,\n\t.bind = vmw_cotable_bind,\n\t.unbind = vmw_cotable_unbind,\n};\n\n \nstatic struct vmw_cotable *vmw_cotable(struct vmw_resource *res)\n{\n\treturn container_of(res, struct vmw_cotable, res);\n}\n\n \nstatic int vmw_cotable_destroy(struct vmw_resource *res)\n{\n\tres->id = -1;\n\treturn 0;\n}\n\n \nstatic int vmw_cotable_unscrub(struct vmw_resource *res)\n{\n\tstruct vmw_cotable *vcotbl = vmw_cotable(res);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct ttm_buffer_object *bo = &res->guest_memory_bo->tbo;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXSetCOTable body;\n\t} *cmd;\n\n\tWARN_ON_ONCE(bo->resource->mem_type != VMW_PL_MOB);\n\tdma_resv_assert_held(bo->base.resv);\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tWARN_ON(vcotbl->ctx->id == SVGA3D_INVALID_ID);\n\tWARN_ON(bo->resource->mem_type != VMW_PL_MOB);\n\tcmd->header.id = SVGA_3D_CMD_DX_SET_COTABLE;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = vcotbl->ctx->id;\n\tcmd->body.type = vcotbl->type;\n\tcmd->body.mobid = bo->resource->start;\n\tcmd->body.validSizeInBytes = vcotbl->size_read_back;\n\n\tvmw_cmd_commit_flush(dev_priv, sizeof(*cmd));\n\tvcotbl->scrubbed = false;\n\n\treturn 0;\n}\n\n \nstatic int vmw_cotable_bind(struct vmw_resource *res,\n\t\t\t    struct ttm_validate_buffer *val_buf)\n{\n\t \n\tval_buf->bo = &res->guest_memory_bo->tbo;\n\n\treturn vmw_cotable_unscrub(res);\n}\n\n \nint vmw_cotable_scrub(struct vmw_resource *res, bool readback)\n{\n\tstruct vmw_cotable *vcotbl = vmw_cotable(res);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tsize_t submit_size;\n\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXReadbackCOTable body;\n\t} *cmd0;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXSetCOTable body;\n\t} *cmd1;\n\n\tif (vcotbl->scrubbed)\n\t\treturn 0;\n\n\tif (co_info[vcotbl->type].unbind_func)\n\t\tco_info[vcotbl->type].unbind_func(dev_priv,\n\t\t\t\t\t\t  &vcotbl->resource_list,\n\t\t\t\t\t\t  readback);\n\tsubmit_size = sizeof(*cmd1);\n\tif (readback)\n\t\tsubmit_size += sizeof(*cmd0);\n\n\tcmd1 = VMW_CMD_RESERVE(dev_priv, submit_size);\n\tif (!cmd1)\n\t\treturn -ENOMEM;\n\n\tvcotbl->size_read_back = 0;\n\tif (readback) {\n\t\tcmd0 = (void *) cmd1;\n\t\tcmd0->header.id = SVGA_3D_CMD_DX_READBACK_COTABLE;\n\t\tcmd0->header.size = sizeof(cmd0->body);\n\t\tcmd0->body.cid = vcotbl->ctx->id;\n\t\tcmd0->body.type = vcotbl->type;\n\t\tcmd1 = (void *) &cmd0[1];\n\t\tvcotbl->size_read_back = res->guest_memory_size;\n\t}\n\tcmd1->header.id = SVGA_3D_CMD_DX_SET_COTABLE;\n\tcmd1->header.size = sizeof(cmd1->body);\n\tcmd1->body.cid = vcotbl->ctx->id;\n\tcmd1->body.type = vcotbl->type;\n\tcmd1->body.mobid = SVGA3D_INVALID_ID;\n\tcmd1->body.validSizeInBytes = 0;\n\tvmw_cmd_commit_flush(dev_priv, submit_size);\n\tvcotbl->scrubbed = true;\n\n\t \n\tres->id = -1;\n\n\treturn 0;\n}\n\n \nstatic int vmw_cotable_unbind(struct vmw_resource *res,\n\t\t\t      bool readback,\n\t\t\t      struct ttm_validate_buffer *val_buf)\n{\n\tstruct vmw_cotable *vcotbl = vmw_cotable(res);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct ttm_buffer_object *bo = val_buf->bo;\n\tstruct vmw_fence_obj *fence;\n\n\tif (!vmw_resource_mob_attached(res))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(bo->resource->mem_type != VMW_PL_MOB);\n\tdma_resv_assert_held(bo->base.resv);\n\n\tmutex_lock(&dev_priv->binding_mutex);\n\tif (!vcotbl->scrubbed)\n\t\tvmw_dx_context_scrub_cotables(vcotbl->ctx, readback);\n\tmutex_unlock(&dev_priv->binding_mutex);\n\t(void) vmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);\n\tvmw_bo_fence_single(bo, fence);\n\tif (likely(fence != NULL))\n\t\tvmw_fence_obj_unreference(&fence);\n\n\treturn 0;\n}\n\n \nstatic int vmw_cotable_readback(struct vmw_resource *res)\n{\n\tstruct vmw_cotable *vcotbl = vmw_cotable(res);\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdDXReadbackCOTable body;\n\t} *cmd;\n\tstruct vmw_fence_obj *fence;\n\n\tif (!vcotbl->scrubbed) {\n\t\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\t\tif (!cmd)\n\t\t\treturn -ENOMEM;\n\n\t\tcmd->header.id = SVGA_3D_CMD_DX_READBACK_COTABLE;\n\t\tcmd->header.size = sizeof(cmd->body);\n\t\tcmd->body.cid = vcotbl->ctx->id;\n\t\tcmd->body.type = vcotbl->type;\n\t\tvcotbl->size_read_back = res->guest_memory_size;\n\t\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\t}\n\n\t(void) vmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);\n\tvmw_bo_fence_single(&res->guest_memory_bo->tbo, fence);\n\tvmw_fence_obj_unreference(&fence);\n\n\treturn 0;\n}\n\n \nstatic int vmw_cotable_resize(struct vmw_resource *res, size_t new_size)\n{\n\tstruct ttm_operation_ctx ctx = { false, false };\n\tstruct vmw_private *dev_priv = res->dev_priv;\n\tstruct vmw_cotable *vcotbl = vmw_cotable(res);\n\tstruct vmw_bo *buf, *old_buf = res->guest_memory_bo;\n\tstruct ttm_buffer_object *bo, *old_bo = &res->guest_memory_bo->tbo;\n\tsize_t old_size = res->guest_memory_size;\n\tsize_t old_size_read_back = vcotbl->size_read_back;\n\tsize_t cur_size_read_back;\n\tstruct ttm_bo_kmap_obj old_map, new_map;\n\tint ret;\n\tsize_t i;\n\tstruct vmw_bo_params bo_params = {\n\t\t.domain = VMW_BO_DOMAIN_MOB,\n\t\t.busy_domain = VMW_BO_DOMAIN_MOB,\n\t\t.bo_type = ttm_bo_type_device,\n\t\t.size = new_size,\n\t\t.pin = true\n\t};\n\n\tMKS_STAT_TIME_DECL(MKSSTAT_KERN_COTABLE_RESIZE);\n\tMKS_STAT_TIME_PUSH(MKSSTAT_KERN_COTABLE_RESIZE);\n\n\tret = vmw_cotable_readback(res);\n\tif (ret)\n\t\tgoto out_done;\n\n\tcur_size_read_back = vcotbl->size_read_back;\n\tvcotbl->size_read_back = old_size_read_back;\n\n\t \n\tret = vmw_gem_object_create(dev_priv, &bo_params, &buf);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed initializing new cotable MOB.\\n\");\n\t\tgoto out_done;\n\t}\n\n\tbo = &buf->tbo;\n\tWARN_ON_ONCE(ttm_bo_reserve(bo, false, true, NULL));\n\n\tret = ttm_bo_wait(old_bo, false, false);\n\tif (unlikely(ret != 0)) {\n\t\tDRM_ERROR(\"Failed waiting for cotable unbind.\\n\");\n\t\tgoto out_wait;\n\t}\n\n\t \n\tfor (i = 0; i < PFN_UP(old_bo->resource->size); ++i) {\n\t\tbool dummy;\n\n\t\tret = ttm_bo_kmap(old_bo, i, 1, &old_map);\n\t\tif (unlikely(ret != 0)) {\n\t\t\tDRM_ERROR(\"Failed mapping old COTable on resize.\\n\");\n\t\t\tgoto out_wait;\n\t\t}\n\t\tret = ttm_bo_kmap(bo, i, 1, &new_map);\n\t\tif (unlikely(ret != 0)) {\n\t\t\tDRM_ERROR(\"Failed mapping new COTable on resize.\\n\");\n\t\t\tgoto out_map_new;\n\t\t}\n\t\tmemcpy(ttm_kmap_obj_virtual(&new_map, &dummy),\n\t\t       ttm_kmap_obj_virtual(&old_map, &dummy),\n\t\t       PAGE_SIZE);\n\t\tttm_bo_kunmap(&new_map);\n\t\tttm_bo_kunmap(&old_map);\n\t}\n\n\t \n\tvmw_bo_placement_set(buf,\n\t\t\t     VMW_BO_DOMAIN_MOB,\n\t\t\t     VMW_BO_DOMAIN_MOB);\n\tret = ttm_bo_validate(bo, &buf->placement, &ctx);\n\tif (unlikely(ret != 0)) {\n\t\tDRM_ERROR(\"Failed validating new COTable backup buffer.\\n\");\n\t\tgoto out_wait;\n\t}\n\n\tvmw_resource_mob_detach(res);\n\tres->guest_memory_bo = buf;\n\tres->guest_memory_size = new_size;\n\tvcotbl->size_read_back = cur_size_read_back;\n\n\t \n\tret = vmw_cotable_unscrub(res);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed switching COTable backup buffer.\\n\");\n\t\tres->guest_memory_bo = old_buf;\n\t\tres->guest_memory_size = old_size;\n\t\tvcotbl->size_read_back = old_size_read_back;\n\t\tvmw_resource_mob_attach(res);\n\t\tgoto out_wait;\n\t}\n\n\tvmw_resource_mob_attach(res);\n\t \n\tvmw_user_bo_unref(&old_buf);\n\tres->id = vcotbl->type;\n\n\tret = dma_resv_reserve_fences(bo->base.resv, 1);\n\tif (unlikely(ret))\n\t\tgoto out_wait;\n\n\t \n\tttm_bo_unpin(bo);\n\n\tMKS_STAT_TIME_POP(MKSSTAT_KERN_COTABLE_RESIZE);\n\n\treturn 0;\n\nout_map_new:\n\tttm_bo_kunmap(&old_map);\nout_wait:\n\tttm_bo_unpin(bo);\n\tttm_bo_unreserve(bo);\n\tvmw_user_bo_unref(&buf);\n\nout_done:\n\tMKS_STAT_TIME_POP(MKSSTAT_KERN_COTABLE_RESIZE);\n\n\treturn ret;\n}\n\n \nstatic int vmw_cotable_create(struct vmw_resource *res)\n{\n\tstruct vmw_cotable *vcotbl = vmw_cotable(res);\n\tsize_t new_size = res->guest_memory_size;\n\tsize_t needed_size;\n\tint ret;\n\n\t \n\tneeded_size = (vcotbl->seen_entries + 1) * co_info[vcotbl->type].size;\n\twhile (needed_size > new_size)\n\t\tnew_size *= 2;\n\n\tif (likely(new_size <= res->guest_memory_size)) {\n\t\tif (vcotbl->scrubbed && vmw_resource_mob_attached(res)) {\n\t\t\tret = vmw_cotable_unscrub(res);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tres->id = vcotbl->type;\n\t\treturn 0;\n\t}\n\n\treturn vmw_cotable_resize(res, new_size);\n}\n\n \nstatic void vmw_hw_cotable_destroy(struct vmw_resource *res)\n{\n\t(void) vmw_cotable_destroy(res);\n}\n\n \nstatic void vmw_cotable_free(struct vmw_resource *res)\n{\n\tkfree(res);\n}\n\n \nstruct vmw_resource *vmw_cotable_alloc(struct vmw_private *dev_priv,\n\t\t\t\t       struct vmw_resource *ctx,\n\t\t\t\t       u32 type)\n{\n\tstruct vmw_cotable *vcotbl;\n\tint ret;\n\tu32 num_entries;\n\n\tvcotbl = kzalloc(sizeof(*vcotbl), GFP_KERNEL);\n\tif (unlikely(!vcotbl)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_alloc;\n\t}\n\n\tret = vmw_resource_init(dev_priv, &vcotbl->res, true,\n\t\t\t\tvmw_cotable_free, &vmw_cotable_func);\n\tif (unlikely(ret != 0))\n\t\tgoto out_no_init;\n\n\tINIT_LIST_HEAD(&vcotbl->resource_list);\n\tvcotbl->res.id = type;\n\tvcotbl->res.guest_memory_size = PAGE_SIZE;\n\tnum_entries = PAGE_SIZE / co_info[type].size;\n\tif (num_entries < co_info[type].min_initial_entries) {\n\t\tvcotbl->res.guest_memory_size = co_info[type].min_initial_entries *\n\t\t\tco_info[type].size;\n\t\tvcotbl->res.guest_memory_size = PFN_ALIGN(vcotbl->res.guest_memory_size);\n\t}\n\n\tvcotbl->scrubbed = true;\n\tvcotbl->seen_entries = -1;\n\tvcotbl->type = type;\n\tvcotbl->ctx = ctx;\n\n\tvcotbl->res.hw_destroy = vmw_hw_cotable_destroy;\n\n\treturn &vcotbl->res;\n\nout_no_init:\n\tkfree(vcotbl);\nout_no_alloc:\n\treturn ERR_PTR(ret);\n}\n\n \nint vmw_cotable_notify(struct vmw_resource *res, int id)\n{\n\tstruct vmw_cotable *vcotbl = vmw_cotable(res);\n\n\tif (id < 0 || id >= SVGA_COTABLE_MAX_IDS) {\n\t\tDRM_ERROR(\"Illegal COTable id. Type is %u. Id is %d\\n\",\n\t\t\t  (unsigned) vcotbl->type, id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vcotbl->seen_entries < id) {\n\t\t \n\t\tres->id = -1;\n\t\tvcotbl->seen_entries = id;\n\t}\n\n\treturn 0;\n}\n\n \nvoid vmw_cotable_add_resource(struct vmw_resource *res, struct list_head *head)\n{\n\tstruct vmw_cotable *vcotbl =\n\t\tcontainer_of(res, struct vmw_cotable, res);\n\n\tlist_add_tail(head, &vcotbl->resource_list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}