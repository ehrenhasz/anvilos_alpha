{
  "module_name": "vmw_surface_cache.h",
  "hash_id": "b8a7054d32173c84de341d5c60b53e4a34dfb410be5ea8aa812dbecd66501731",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmw_surface_cache.h",
  "human_readable_source": " \n\n#ifndef VMW_SURFACE_CACHE_H\n#define VMW_SURFACE_CACHE_H\n\n#include \"device_include/svga3d_surfacedefs.h\"\n\n#include <drm/vmwgfx_drm.h>\n\nstatic inline u32 clamped_umul32(u32 a, u32 b)\n{\n\tuint64_t tmp = (uint64_t) a*b;\n\treturn (tmp > (uint64_t) ((u32) -1)) ? (u32) -1 : tmp;\n}\n\n \nstatic inline const SVGA3dSurfaceDesc *\nvmw_surface_get_desc(SVGA3dSurfaceFormat format)\n{\n\tif (format < ARRAY_SIZE(g_SVGA3dSurfaceDescs))\n\t\treturn &g_SVGA3dSurfaceDescs[format];\n\n\treturn &g_SVGA3dSurfaceDescs[SVGA3D_FORMAT_INVALID];\n}\n\n \nstatic inline struct drm_vmw_size\nvmw_surface_get_mip_size(struct drm_vmw_size base_level, u32 mip_level)\n{\n\tstruct drm_vmw_size size = {\n\t\t.width = max_t(u32, base_level.width >> mip_level, 1),\n\t\t.height = max_t(u32, base_level.height >> mip_level, 1),\n\t\t.depth = max_t(u32, base_level.depth >> mip_level, 1)\n\t};\n\n\treturn size;\n}\n\nstatic inline void\nvmw_surface_get_size_in_blocks(const SVGA3dSurfaceDesc *desc,\n\t\t\t\t const struct drm_vmw_size *pixel_size,\n\t\t\t\t SVGA3dSize *block_size)\n{\n\tblock_size->width = __KERNEL_DIV_ROUND_UP(pixel_size->width,\n\t\t\t\t\t\t  desc->blockSize.width);\n\tblock_size->height = __KERNEL_DIV_ROUND_UP(pixel_size->height,\n\t\t\t\t\t\t   desc->blockSize.height);\n\tblock_size->depth = __KERNEL_DIV_ROUND_UP(pixel_size->depth,\n\t\t\t\t\t\t  desc->blockSize.depth);\n}\n\nstatic inline bool\nvmw_surface_is_planar_surface(const SVGA3dSurfaceDesc *desc)\n{\n\treturn (desc->blockDesc & SVGA3DBLOCKDESC_PLANAR_YUV) != 0;\n}\n\nstatic inline u32\nvmw_surface_calculate_pitch(const SVGA3dSurfaceDesc *desc,\n\t\t\t      const struct drm_vmw_size *size)\n{\n\tu32 pitch;\n\tSVGA3dSize blocks;\n\n\tvmw_surface_get_size_in_blocks(desc, size, &blocks);\n\n\tpitch = blocks.width * desc->pitchBytesPerBlock;\n\n\treturn pitch;\n}\n\n \nstatic inline u32\nvmw_surface_get_image_buffer_size(const SVGA3dSurfaceDesc *desc,\n\t\t\t\t    const struct drm_vmw_size *size,\n\t\t\t\t    u32 pitch)\n{\n\tSVGA3dSize image_blocks;\n\tu32 slice_size, total_size;\n\n\tvmw_surface_get_size_in_blocks(desc, size, &image_blocks);\n\n\tif (vmw_surface_is_planar_surface(desc)) {\n\t\ttotal_size = clamped_umul32(image_blocks.width,\n\t\t\t\t\t    image_blocks.height);\n\t\ttotal_size = clamped_umul32(total_size, image_blocks.depth);\n\t\ttotal_size = clamped_umul32(total_size, desc->bytesPerBlock);\n\t\treturn total_size;\n\t}\n\n\tif (pitch == 0)\n\t\tpitch = vmw_surface_calculate_pitch(desc, size);\n\n\tslice_size = clamped_umul32(image_blocks.height, pitch);\n\ttotal_size = clamped_umul32(slice_size, image_blocks.depth);\n\n\treturn total_size;\n}\n\n \nstatic inline u32\nvmw_surface_get_serialized_size(SVGA3dSurfaceFormat format,\n\t\t\t\t  struct drm_vmw_size base_level_size,\n\t\t\t\t  u32 num_mip_levels,\n\t\t\t\t  u32 num_layers)\n{\n\tconst SVGA3dSurfaceDesc *desc = vmw_surface_get_desc(format);\n\tu32 total_size = 0;\n\tu32 mip;\n\n\tfor (mip = 0; mip < num_mip_levels; mip++) {\n\t\tstruct drm_vmw_size size =\n\t\t\tvmw_surface_get_mip_size(base_level_size, mip);\n\t\ttotal_size += vmw_surface_get_image_buffer_size(desc,\n\t\t\t\t\t\t\t\t  &size, 0);\n\t}\n\n\treturn total_size * num_layers;\n}\n\n \nstatic inline u32\nvmw_surface_get_serialized_size_extended(SVGA3dSurfaceFormat format,\n\t\t\t\t\t   struct drm_vmw_size base_level_size,\n\t\t\t\t\t   u32 num_mip_levels,\n\t\t\t\t\t   u32 num_layers,\n\t\t\t\t\t   u32 num_samples)\n{\n\tuint64_t total_size =\n\t\tvmw_surface_get_serialized_size(format,\n\t\t\t\t\t\t  base_level_size,\n\t\t\t\t\t\t  num_mip_levels,\n\t\t\t\t\t\t  num_layers);\n\ttotal_size *= max_t(u32, 1, num_samples);\n\n\treturn min_t(uint64_t, total_size, (uint64_t)U32_MAX);\n}\n\n \nstatic inline u32\nvmw_surface_get_pixel_offset(SVGA3dSurfaceFormat format,\n\t\t\t       u32 width, u32 height,\n\t\t\t       u32 x, u32 y, u32 z)\n{\n\tconst SVGA3dSurfaceDesc *desc = vmw_surface_get_desc(format);\n\tconst u32 bw = desc->blockSize.width, bh = desc->blockSize.height;\n\tconst u32 bd = desc->blockSize.depth;\n\tconst u32 rowstride = __KERNEL_DIV_ROUND_UP(width, bw) *\n\t\t\t      desc->bytesPerBlock;\n\tconst u32 imgstride = __KERNEL_DIV_ROUND_UP(height, bh) * rowstride;\n\tconst u32 offset = (z / bd * imgstride +\n\t\t\t    y / bh * rowstride +\n\t\t\t    x / bw * desc->bytesPerBlock);\n\treturn offset;\n}\n\nstatic inline u32\nvmw_surface_get_image_offset(SVGA3dSurfaceFormat format,\n\t\t\t       struct drm_vmw_size baseLevelSize,\n\t\t\t       u32 numMipLevels,\n\t\t\t       u32 face,\n\t\t\t       u32 mip)\n\n{\n\tu32 offset;\n\tu32 mipChainBytes;\n\tu32 mipChainBytesToLevel;\n\tu32 i;\n\tconst SVGA3dSurfaceDesc *desc;\n\tstruct drm_vmw_size mipSize;\n\tu32 bytes;\n\n\tdesc = vmw_surface_get_desc(format);\n\n\tmipChainBytes = 0;\n\tmipChainBytesToLevel = 0;\n\tfor (i = 0; i < numMipLevels; i++) {\n\t\tmipSize = vmw_surface_get_mip_size(baseLevelSize, i);\n\t\tbytes = vmw_surface_get_image_buffer_size(desc, &mipSize, 0);\n\t\tmipChainBytes += bytes;\n\t\tif (i < mip)\n\t\t\tmipChainBytesToLevel += bytes;\n\t}\n\n\toffset = mipChainBytes * face + mipChainBytesToLevel;\n\n\treturn offset;\n}\n\n\n \nstatic inline bool\nvmw_surface_is_gb_screen_target_format(SVGA3dSurfaceFormat format)\n{\n\treturn (format == SVGA3D_X8R8G8B8 ||\n\t\tformat == SVGA3D_A8R8G8B8 ||\n\t\tformat == SVGA3D_R5G6B5   ||\n\t\tformat == SVGA3D_X1R5G5B5 ||\n\t\tformat == SVGA3D_A1R5G5B5 ||\n\t\tformat == SVGA3D_P8);\n}\n\n\n \nstatic inline bool\nvmw_surface_is_dx_screen_target_format(SVGA3dSurfaceFormat format)\n{\n\treturn (format == SVGA3D_R8G8B8A8_UNORM ||\n\t\tformat == SVGA3D_B8G8R8A8_UNORM ||\n\t\tformat == SVGA3D_B8G8R8X8_UNORM);\n}\n\n\n \nstatic inline bool\nvmw_surface_is_screen_target_format(SVGA3dSurfaceFormat format)\n{\n\tif (vmw_surface_is_gb_screen_target_format(format)) {\n\t\treturn true;\n\t}\n\treturn vmw_surface_is_dx_screen_target_format(format);\n}\n\n \nstruct vmw_surface_mip {\n\tsize_t bytes;\n\tsize_t img_stride;\n\tsize_t row_stride;\n\tstruct drm_vmw_size size;\n\n};\n\n \nstruct vmw_surface_cache {\n\tconst SVGA3dSurfaceDesc *desc;\n\tstruct vmw_surface_mip mip[DRM_VMW_MAX_MIP_LEVELS];\n\tsize_t mip_chain_bytes;\n\tsize_t sheet_bytes;\n\tu32 num_mip_levels;\n\tu32 num_layers;\n};\n\n \nstruct vmw_surface_loc {\n\tu32 sheet;\n\tu32 sub_resource;\n\tu32 x, y, z;\n};\n\n \nstatic inline u32 vmw_surface_subres(const struct vmw_surface_cache *cache,\n\t\t\t\t       u32 mip_level, u32 layer)\n{\n\treturn cache->num_mip_levels * layer + mip_level;\n}\n\n \nstatic inline int vmw_surface_setup_cache(const struct drm_vmw_size *size,\n\t\t\t\t\t    SVGA3dSurfaceFormat format,\n\t\t\t\t\t    u32 num_mip_levels,\n\t\t\t\t\t    u32 num_layers,\n\t\t\t\t\t    u32 num_samples,\n\t\t\t\t\t    struct vmw_surface_cache *cache)\n{\n\tconst SVGA3dSurfaceDesc *desc;\n\tu32 i;\n\n\tmemset(cache, 0, sizeof(*cache));\n\tcache->desc = desc = vmw_surface_get_desc(format);\n\tcache->num_mip_levels = num_mip_levels;\n\tcache->num_layers = num_layers;\n\tfor (i = 0; i < cache->num_mip_levels; i++) {\n\t\tstruct vmw_surface_mip *mip = &cache->mip[i];\n\n\t\tmip->size = vmw_surface_get_mip_size(*size, i);\n\t\tmip->bytes = vmw_surface_get_image_buffer_size\n\t\t\t(desc, &mip->size, 0);\n\t\tmip->row_stride =\n\t\t\t__KERNEL_DIV_ROUND_UP(mip->size.width,\n\t\t\t\t\t      desc->blockSize.width) *\n\t\t\tdesc->bytesPerBlock * num_samples;\n\t\tif (!mip->row_stride)\n\t\t\tgoto invalid_dim;\n\n\t\tmip->img_stride =\n\t\t\t__KERNEL_DIV_ROUND_UP(mip->size.height,\n\t\t\t\t\t      desc->blockSize.height) *\n\t\t\tmip->row_stride;\n\t\tif (!mip->img_stride)\n\t\t\tgoto invalid_dim;\n\n\t\tcache->mip_chain_bytes += mip->bytes;\n\t}\n\tcache->sheet_bytes = cache->mip_chain_bytes * num_layers;\n\tif (!cache->sheet_bytes)\n\t\tgoto invalid_dim;\n\n\treturn 0;\n\ninvalid_dim:\n\tVMW_DEBUG_USER(\"Invalid surface layout for dirty tracking.\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic inline void\nvmw_surface_get_loc(const struct vmw_surface_cache *cache,\n\t\t      struct vmw_surface_loc *loc,\n\t\t      size_t offset)\n{\n\tconst struct vmw_surface_mip *mip = &cache->mip[0];\n\tconst SVGA3dSurfaceDesc *desc = cache->desc;\n\tu32 layer;\n\tint i;\n\n\tloc->sheet = offset / cache->sheet_bytes;\n\toffset -= loc->sheet * cache->sheet_bytes;\n\n\tlayer = offset / cache->mip_chain_bytes;\n\toffset -= layer * cache->mip_chain_bytes;\n\tfor (i = 0; i < cache->num_mip_levels; ++i, ++mip) {\n\t\tif (mip->bytes > offset)\n\t\t\tbreak;\n\t\toffset -= mip->bytes;\n\t}\n\n\tloc->sub_resource = vmw_surface_subres(cache, i, layer);\n\tloc->z = offset / mip->img_stride;\n\toffset -= loc->z * mip->img_stride;\n\tloc->z *= desc->blockSize.depth;\n\tloc->y = offset / mip->row_stride;\n\toffset -= loc->y * mip->row_stride;\n\tloc->y *= desc->blockSize.height;\n\tloc->x = offset / desc->bytesPerBlock;\n\tloc->x *= desc->blockSize.width;\n}\n\n \nstatic inline void\nvmw_surface_inc_loc(const struct vmw_surface_cache *cache,\n\t\t      struct vmw_surface_loc *loc)\n{\n\tconst SVGA3dSurfaceDesc *desc = cache->desc;\n\tu32 mip = loc->sub_resource % cache->num_mip_levels;\n\tconst struct drm_vmw_size *size = &cache->mip[mip].size;\n\n\tloc->sub_resource++;\n\tloc->x += desc->blockSize.width;\n\tif (loc->x > size->width)\n\t\tloc->x = size->width;\n\tloc->y += desc->blockSize.height;\n\tif (loc->y > size->height)\n\t\tloc->y = size->height;\n\tloc->z += desc->blockSize.depth;\n\tif (loc->z > size->depth)\n\t\tloc->z = size->depth;\n}\n\n \nstatic inline void\nvmw_surface_min_loc(const struct vmw_surface_cache *cache,\n\t\t      u32 sub_resource,\n\t\t      struct vmw_surface_loc *loc)\n{\n\tloc->sheet = 0;\n\tloc->sub_resource = sub_resource;\n\tloc->x = loc->y = loc->z = 0;\n}\n\n \nstatic inline void\nvmw_surface_max_loc(const struct vmw_surface_cache *cache,\n\t\t      u32 sub_resource,\n\t\t      struct vmw_surface_loc *loc)\n{\n\tconst struct drm_vmw_size *size;\n\tu32 mip;\n\n\tloc->sheet = 0;\n\tloc->sub_resource = sub_resource + 1;\n\tmip = sub_resource % cache->num_mip_levels;\n\tsize = &cache->mip[mip].size;\n\tloc->x = size->width;\n\tloc->y = size->height;\n\tloc->z = size->depth;\n}\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}