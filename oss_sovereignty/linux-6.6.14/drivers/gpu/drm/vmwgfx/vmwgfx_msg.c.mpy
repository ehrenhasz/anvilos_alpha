{
  "module_name": "vmwgfx_msg.c",
  "hash_id": "460a7ae53a24446e0e1859738a36334a8123b4d4e7fca4dd46157eee152563eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_msg.c",
  "human_readable_source": "\n \n\n#include <linux/objtool.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/cc_platform.h>\n\n#include <asm/hypervisor.h>\n#include <drm/drm_ioctl.h>\n\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_msg_x86.h\"\n#include \"vmwgfx_msg_arm64.h\"\n#include \"vmwgfx_mksstat.h\"\n\n#define MESSAGE_STATUS_SUCCESS  0x0001\n#define MESSAGE_STATUS_DORECV   0x0002\n#define MESSAGE_STATUS_CPT      0x0010\n#define MESSAGE_STATUS_HB       0x0080\n\n#define RPCI_PROTOCOL_NUM       0x49435052\n#define GUESTMSG_FLAG_COOKIE    0x80000000\n\n#define RETRIES                 3\n\n#define VMW_HYPERVISOR_MAGIC    0x564D5868\n\n#define VMW_PORT_CMD_MSG        30\n#define VMW_PORT_CMD_HB_MSG     0\n#define VMW_PORT_CMD_OPEN_CHANNEL  (MSG_TYPE_OPEN << 16 | VMW_PORT_CMD_MSG)\n#define VMW_PORT_CMD_CLOSE_CHANNEL (MSG_TYPE_CLOSE << 16 | VMW_PORT_CMD_MSG)\n#define VMW_PORT_CMD_SENDSIZE   (MSG_TYPE_SENDSIZE << 16 | VMW_PORT_CMD_MSG)\n#define VMW_PORT_CMD_RECVSIZE   (MSG_TYPE_RECVSIZE << 16 | VMW_PORT_CMD_MSG)\n#define VMW_PORT_CMD_RECVSTATUS (MSG_TYPE_RECVSTATUS << 16 | VMW_PORT_CMD_MSG)\n\n#define VMW_PORT_CMD_MKS_GUEST_STATS   85\n#define VMW_PORT_CMD_MKSGS_RESET       (0 << 16 | VMW_PORT_CMD_MKS_GUEST_STATS)\n#define VMW_PORT_CMD_MKSGS_ADD_PPN     (1 << 16 | VMW_PORT_CMD_MKS_GUEST_STATS)\n#define VMW_PORT_CMD_MKSGS_REMOVE_PPN  (2 << 16 | VMW_PORT_CMD_MKS_GUEST_STATS)\n\n#define HIGH_WORD(X) ((X & 0xFFFF0000) >> 16)\n\n#define MAX_USER_MSG_LENGTH\tPAGE_SIZE\n\nstatic u32 vmw_msg_enabled = 1;\n\nenum rpc_msg_type {\n\tMSG_TYPE_OPEN,\n\tMSG_TYPE_SENDSIZE,\n\tMSG_TYPE_SENDPAYLOAD,\n\tMSG_TYPE_RECVSIZE,\n\tMSG_TYPE_RECVPAYLOAD,\n\tMSG_TYPE_RECVSTATUS,\n\tMSG_TYPE_CLOSE,\n};\n\nstruct rpc_channel {\n\tu16 channel_id;\n\tu32 cookie_high;\n\tu32 cookie_low;\n};\n\n#if IS_ENABLED(CONFIG_DRM_VMWGFX_MKSSTATS)\n \nstatic const char* const mksstat_kern_name_desc[MKSSTAT_KERN_COUNT][2] =\n{\n\t{ \"vmw_execbuf_ioctl\", \"vmw_execbuf_ioctl\" },\n\t{ \"vmw_cotable_resize\", \"vmw_cotable_resize\" },\n};\n#endif\n\n \nstatic int vmw_open_channel(struct rpc_channel *channel, unsigned int protocol)\n{\n\tunsigned long eax, ebx, ecx, edx, si = 0, di = 0;\n\n\tVMW_PORT(VMW_PORT_CMD_OPEN_CHANNEL,\n\t\t(protocol | GUESTMSG_FLAG_COOKIE), si, di,\n\t\t0,\n\t\tVMW_HYPERVISOR_MAGIC,\n\t\teax, ebx, ecx, edx, si, di);\n\n\tif ((HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS) == 0)\n\t\treturn -EINVAL;\n\n\tchannel->channel_id  = HIGH_WORD(edx);\n\tchannel->cookie_high = si;\n\tchannel->cookie_low  = di;\n\n\treturn 0;\n}\n\n\n\n \nstatic int vmw_close_channel(struct rpc_channel *channel)\n{\n\tunsigned long eax, ebx, ecx, edx, si, di;\n\n\t \n\tsi  = channel->cookie_high;\n\tdi  = channel->cookie_low;\n\n\tVMW_PORT(VMW_PORT_CMD_CLOSE_CHANNEL,\n\t\t0, si, di,\n\t\tchannel->channel_id << 16,\n\t\tVMW_HYPERVISOR_MAGIC,\n\t\teax, ebx, ecx, edx, si, di);\n\n\tif ((HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS) == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic unsigned long vmw_port_hb_out(struct rpc_channel *channel,\n\t\t\t\t     const char *msg, bool hb)\n{\n\tunsigned long si, di, eax, ebx, ecx, edx;\n\tunsigned long msg_len = strlen(msg);\n\n\t \n\tif (hb && !cc_platform_has(CC_ATTR_MEM_ENCRYPT)) {\n\t\tunsigned long bp = channel->cookie_high;\n\t\tu32 channel_id = (channel->channel_id << 16);\n\n\t\tsi = (uintptr_t) msg;\n\t\tdi = channel->cookie_low;\n\n\t\tVMW_PORT_HB_OUT(\n\t\t\t(MESSAGE_STATUS_SUCCESS << 16) | VMW_PORT_CMD_HB_MSG,\n\t\t\tmsg_len, si, di,\n\t\t\tVMWARE_HYPERVISOR_HB | channel_id |\n\t\t\tVMWARE_HYPERVISOR_OUT,\n\t\t\tVMW_HYPERVISOR_MAGIC, bp,\n\t\t\teax, ebx, ecx, edx, si, di);\n\n\t\treturn ebx;\n\t}\n\n\t \n\tecx = MESSAGE_STATUS_SUCCESS << 16;\n\twhile (msg_len && (HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS)) {\n\t\tunsigned int bytes = min_t(size_t, msg_len, 4);\n\t\tunsigned long word = 0;\n\n\t\tmemcpy(&word, msg, bytes);\n\t\tmsg_len -= bytes;\n\t\tmsg += bytes;\n\t\tsi = channel->cookie_high;\n\t\tdi = channel->cookie_low;\n\n\t\tVMW_PORT(VMW_PORT_CMD_MSG | (MSG_TYPE_SENDPAYLOAD << 16),\n\t\t\t word, si, di,\n\t\t\t channel->channel_id << 16,\n\t\t\t VMW_HYPERVISOR_MAGIC,\n\t\t\t eax, ebx, ecx, edx, si, di);\n\t}\n\n\treturn ecx;\n}\n\n \nstatic unsigned long vmw_port_hb_in(struct rpc_channel *channel, char *reply,\n\t\t\t\t    unsigned long reply_len, bool hb)\n{\n\tunsigned long si, di, eax, ebx, ecx, edx;\n\n\t \n\tif (hb && !cc_platform_has(CC_ATTR_MEM_ENCRYPT)) {\n\t\tunsigned long bp = channel->cookie_low;\n\t\tu32 channel_id = (channel->channel_id << 16);\n\n\t\tsi = channel->cookie_high;\n\t\tdi = (uintptr_t) reply;\n\n\t\tVMW_PORT_HB_IN(\n\t\t\t(MESSAGE_STATUS_SUCCESS << 16) | VMW_PORT_CMD_HB_MSG,\n\t\t\treply_len, si, di,\n\t\t\tVMWARE_HYPERVISOR_HB | channel_id,\n\t\t\tVMW_HYPERVISOR_MAGIC, bp,\n\t\t\teax, ebx, ecx, edx, si, di);\n\n\t\treturn ebx;\n\t}\n\n\t \n\tecx = MESSAGE_STATUS_SUCCESS << 16;\n\twhile (reply_len) {\n\t\tunsigned int bytes = min_t(unsigned long, reply_len, 4);\n\n\t\tsi = channel->cookie_high;\n\t\tdi = channel->cookie_low;\n\n\t\tVMW_PORT(VMW_PORT_CMD_MSG | (MSG_TYPE_RECVPAYLOAD << 16),\n\t\t\t MESSAGE_STATUS_SUCCESS, si, di,\n\t\t\t channel->channel_id << 16,\n\t\t\t VMW_HYPERVISOR_MAGIC,\n\t\t\t eax, ebx, ecx, edx, si, di);\n\n\t\tif ((HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS) == 0)\n\t\t\tbreak;\n\n\t\tmemcpy(reply, &ebx, bytes);\n\t\treply_len -= bytes;\n\t\treply += bytes;\n\t}\n\n\treturn ecx;\n}\n\n\n \nstatic int vmw_send_msg(struct rpc_channel *channel, const char *msg)\n{\n\tunsigned long eax, ebx, ecx, edx, si, di;\n\tsize_t msg_len = strlen(msg);\n\tint retries = 0;\n\n\twhile (retries < RETRIES) {\n\t\tretries++;\n\n\t\t \n\t\tsi  = channel->cookie_high;\n\t\tdi  = channel->cookie_low;\n\n\t\tVMW_PORT(VMW_PORT_CMD_SENDSIZE,\n\t\t\tmsg_len, si, di,\n\t\t\tchannel->channel_id << 16,\n\t\t\tVMW_HYPERVISOR_MAGIC,\n\t\t\teax, ebx, ecx, edx, si, di);\n\n\t\tif ((HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS) == 0) {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tebx = vmw_port_hb_out(channel, msg,\n\t\t\t\t      !!(HIGH_WORD(ecx) & MESSAGE_STATUS_HB));\n\n\t\tif ((HIGH_WORD(ebx) & MESSAGE_STATUS_SUCCESS) != 0) {\n\t\t\treturn 0;\n\t\t} else if ((HIGH_WORD(ebx) & MESSAGE_STATUS_CPT) != 0) {\n\t\t\t \n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\nSTACK_FRAME_NON_STANDARD(vmw_send_msg);\n\n\n \nstatic int vmw_recv_msg(struct rpc_channel *channel, void **msg,\n\t\t\tsize_t *msg_len)\n{\n\tunsigned long eax, ebx, ecx, edx, si, di;\n\tchar *reply;\n\tsize_t reply_len;\n\tint retries = 0;\n\n\n\t*msg_len = 0;\n\t*msg = NULL;\n\n\twhile (retries < RETRIES) {\n\t\tretries++;\n\n\t\t \n\t\tsi  = channel->cookie_high;\n\t\tdi  = channel->cookie_low;\n\n\t\tVMW_PORT(VMW_PORT_CMD_RECVSIZE,\n\t\t\t0, si, di,\n\t\t\tchannel->channel_id << 16,\n\t\t\tVMW_HYPERVISOR_MAGIC,\n\t\t\teax, ebx, ecx, edx, si, di);\n\n\t\tif ((HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS) == 0) {\n\t\t\tDRM_ERROR(\"Failed to get reply size for host message.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif ((HIGH_WORD(ecx) & MESSAGE_STATUS_DORECV) == 0)\n\t\t\treturn 0;\n\n\t\treply_len = ebx;\n\t\treply     = kzalloc(reply_len + 1, GFP_KERNEL);\n\t\tif (!reply) {\n\t\t\tDRM_ERROR(\"Cannot allocate memory for host message reply.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\n\t\t \n\t\tebx = vmw_port_hb_in(channel, reply, reply_len,\n\t\t\t\t     !!(HIGH_WORD(ecx) & MESSAGE_STATUS_HB));\n\t\tif ((HIGH_WORD(ebx) & MESSAGE_STATUS_SUCCESS) == 0) {\n\t\t\tkfree(reply);\n\t\t\treply = NULL;\n\t\t\tif ((HIGH_WORD(ebx) & MESSAGE_STATUS_CPT) != 0) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treply[reply_len] = '\\0';\n\n\n\t\t \n\t\tsi  = channel->cookie_high;\n\t\tdi  = channel->cookie_low;\n\n\t\tVMW_PORT(VMW_PORT_CMD_RECVSTATUS,\n\t\t\tMESSAGE_STATUS_SUCCESS, si, di,\n\t\t\tchannel->channel_id << 16,\n\t\t\tVMW_HYPERVISOR_MAGIC,\n\t\t\teax, ebx, ecx, edx, si, di);\n\n\t\tif ((HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS) == 0) {\n\t\t\tkfree(reply);\n\t\t\treply = NULL;\n\t\t\tif ((HIGH_WORD(ecx) & MESSAGE_STATUS_CPT) != 0) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (!reply)\n\t\treturn -EINVAL;\n\n\t*msg_len = reply_len;\n\t*msg     = reply;\n\n\treturn 0;\n}\nSTACK_FRAME_NON_STANDARD(vmw_recv_msg);\n\n\n \nint vmw_host_get_guestinfo(const char *guest_info_param,\n\t\t\t   char *buffer, size_t *length)\n{\n\tstruct rpc_channel channel;\n\tchar *msg, *reply = NULL;\n\tsize_t reply_len = 0;\n\n\tif (!vmw_msg_enabled)\n\t\treturn -ENODEV;\n\n\tif (!guest_info_param || !length)\n\t\treturn -EINVAL;\n\n\tmsg = kasprintf(GFP_KERNEL, \"info-get %s\", guest_info_param);\n\tif (!msg) {\n\t\tDRM_ERROR(\"Cannot allocate memory to get guest info \\\"%s\\\".\",\n\t\t\t  guest_info_param);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (vmw_open_channel(&channel, RPCI_PROTOCOL_NUM))\n\t\tgoto out_open;\n\n\tif (vmw_send_msg(&channel, msg) ||\n\t    vmw_recv_msg(&channel, (void *) &reply, &reply_len))\n\t\tgoto out_msg;\n\n\tvmw_close_channel(&channel);\n\tif (buffer && reply && reply_len > 0) {\n\t\t \n\t\treply_len = max(reply_len - 2, (size_t) 0);\n\t\treply_len = min(reply_len, *length);\n\n\t\tif (reply_len > 0)\n\t\t\tmemcpy(buffer, reply + 2, reply_len);\n\t}\n\n\t*length = reply_len;\n\n\tkfree(reply);\n\tkfree(msg);\n\n\treturn 0;\n\nout_msg:\n\tvmw_close_channel(&channel);\n\tkfree(reply);\nout_open:\n\t*length = 0;\n\tkfree(msg);\n\tDRM_ERROR(\"Failed to get guest info \\\"%s\\\".\", guest_info_param);\n\n\treturn -EINVAL;\n}\n\n\n \n__printf(1, 2)\nint vmw_host_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tstruct rpc_channel channel;\n\tchar *msg;\n\tchar *log;\n\tint ret = 0;\n\n\tif (!vmw_msg_enabled)\n\t\treturn -ENODEV;\n\n\tif (!fmt)\n\t\treturn ret;\n\n\tva_start(ap, fmt);\n\tlog = kvasprintf(GFP_KERNEL, fmt, ap);\n\tva_end(ap);\n\tif (!log) {\n\t\tDRM_ERROR(\"Cannot allocate memory for the log message.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmsg = kasprintf(GFP_KERNEL, \"log %s\", log);\n\tif (!msg) {\n\t\tDRM_ERROR(\"Cannot allocate memory for host log message.\\n\");\n\t\tkfree(log);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (vmw_open_channel(&channel, RPCI_PROTOCOL_NUM))\n\t\tgoto out_open;\n\n\tif (vmw_send_msg(&channel, msg))\n\t\tgoto out_msg;\n\n\tvmw_close_channel(&channel);\n\tkfree(msg);\n\tkfree(log);\n\n\treturn 0;\n\nout_msg:\n\tvmw_close_channel(&channel);\nout_open:\n\tkfree(msg);\n\tkfree(log);\n\tDRM_ERROR(\"Failed to send host log message.\\n\");\n\n\treturn -EINVAL;\n}\n\n\n \n\nint vmw_msg_ioctl(struct drm_device *dev, void *data,\n\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_vmw_msg_arg *arg =\n\t\t\t(struct drm_vmw_msg_arg *)data;\n\tstruct rpc_channel channel;\n\tchar *msg;\n\tint length;\n\n\tmsg = kmalloc(MAX_USER_MSG_LENGTH, GFP_KERNEL);\n\tif (!msg) {\n\t\tDRM_ERROR(\"Cannot allocate memory for log message.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlength = strncpy_from_user(msg, (void __user *)((unsigned long)arg->send),\n\t\t\t\t   MAX_USER_MSG_LENGTH);\n\tif (length < 0 || length >= MAX_USER_MSG_LENGTH) {\n\t\tDRM_ERROR(\"Userspace message access failure.\\n\");\n\t\tkfree(msg);\n\t\treturn -EINVAL;\n\t}\n\n\n\tif (vmw_open_channel(&channel, RPCI_PROTOCOL_NUM)) {\n\t\tDRM_ERROR(\"Failed to open channel.\\n\");\n\t\tgoto out_open;\n\t}\n\n\tif (vmw_send_msg(&channel, msg)) {\n\t\tDRM_ERROR(\"Failed to send message to host.\\n\");\n\t\tgoto out_msg;\n\t}\n\n\tif (!arg->send_only) {\n\t\tchar *reply = NULL;\n\t\tsize_t reply_len = 0;\n\n\t\tif (vmw_recv_msg(&channel, (void *) &reply, &reply_len)) {\n\t\t\tDRM_ERROR(\"Failed to receive message from host.\\n\");\n\t\t\tgoto out_msg;\n\t\t}\n\t\tif (reply && reply_len > 0) {\n\t\t\tif (copy_to_user((void __user *)((unsigned long)arg->receive),\n\t\t\t\t\t reply, reply_len)) {\n\t\t\t\tDRM_ERROR(\"Failed to copy message to userspace.\\n\");\n\t\t\t\tkfree(reply);\n\t\t\t\tgoto out_msg;\n\t\t\t}\n\t\t\targ->receive_len = (__u32)reply_len;\n\t\t}\n\t\tkfree(reply);\n\t}\n\n\tvmw_close_channel(&channel);\n\tkfree(msg);\n\n\treturn 0;\n\nout_msg:\n\tvmw_close_channel(&channel);\nout_open:\n\tkfree(msg);\n\n\treturn -EINVAL;\n}\n\n \nstatic inline void reset_ppn_array(PPN64 *arr, size_t size)\n{\n\tsize_t i;\n\n\tBUG_ON(!arr || size == 0);\n\n\tfor (i = 0; i < size; ++i)\n\t\tarr[i] = INVALID_PPN64;\n}\n\n \nstatic inline void hypervisor_ppn_reset_all(void)\n{\n\tunsigned long eax, ebx, ecx, edx, si = 0, di = 0;\n\n\tVMW_PORT(VMW_PORT_CMD_MKSGS_RESET,\n\t\t0, si, di,\n\t\t0,\n\t\tVMW_HYPERVISOR_MAGIC,\n\t\teax, ebx, ecx, edx, si, di);\n}\n\n \nstatic inline void hypervisor_ppn_add(PPN64 pfn)\n{\n\tunsigned long eax, ebx, ecx, edx, si = 0, di = 0;\n\n\tVMW_PORT(VMW_PORT_CMD_MKSGS_ADD_PPN,\n\t\t(unsigned long)pfn, si, di,\n\t\t0,\n\t\tVMW_HYPERVISOR_MAGIC,\n\t\teax, ebx, ecx, edx, si, di);\n}\n\n \nstatic inline void hypervisor_ppn_remove(PPN64 pfn)\n{\n\tunsigned long eax, ebx, ecx, edx, si = 0, di = 0;\n\n\tVMW_PORT(VMW_PORT_CMD_MKSGS_REMOVE_PPN,\n\t\t(unsigned long)pfn, si, di,\n\t\t0,\n\t\tVMW_HYPERVISOR_MAGIC,\n\t\teax, ebx, ecx, edx, si, di);\n}\n\n#if IS_ENABLED(CONFIG_DRM_VMWGFX_MKSSTATS)\n\n \n#define MKSSTAT_KERNEL_PAGES_ORDER 2\n \n#define MKSSTAT_KERNEL_DESCRIPTION \"vmwgfx\"\n\n \n\nstatic inline char *mksstat_init_record_time(mksstat_kern_stats_t stat_idx,\n\tMKSGuestStatCounterTime *pstat, MKSGuestStatInfoEntry *pinfo, char *pstrs)\n{\n\tchar *const pstrd = pstrs + strlen(mksstat_kern_name_desc[stat_idx][0]) + 1;\n\tstrcpy(pstrs, mksstat_kern_name_desc[stat_idx][0]);\n\tstrcpy(pstrd, mksstat_kern_name_desc[stat_idx][1]);\n\n\tpinfo[stat_idx].name.s = pstrs;\n\tpinfo[stat_idx].description.s = pstrd;\n\tpinfo[stat_idx].flags = MKS_GUEST_STAT_FLAG_TIME;\n\tpinfo[stat_idx].stat.counterTime = &pstat[stat_idx];\n\n\treturn pstrd + strlen(mksstat_kern_name_desc[stat_idx][1]) + 1;\n}\n\n \n\nstatic int mksstat_init_kern_id(struct page **ppage)\n{\n\tMKSGuestStatInstanceDescriptor *pdesc;\n\tMKSGuestStatCounterTime *pstat;\n\tMKSGuestStatInfoEntry *pinfo;\n\tchar *pstrs, *pstrs_acc;\n\n\t \n\tstruct page *page = alloc_pages(GFP_KERNEL | __GFP_ZERO, MKSSTAT_KERNEL_PAGES_ORDER);\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tpdesc = page_address(page);\n\tpstat = vmw_mksstat_get_kern_pstat(pdesc);\n\tpinfo = vmw_mksstat_get_kern_pinfo(pdesc);\n\tpstrs = vmw_mksstat_get_kern_pstrs(pdesc);\n\n\t \n\tpstrs_acc = pstrs;\n\tpstrs_acc = mksstat_init_record_time(MKSSTAT_KERN_EXECBUF, pstat, pinfo, pstrs_acc);\n\tpstrs_acc = mksstat_init_record_time(MKSSTAT_KERN_COTABLE_RESIZE, pstat, pinfo, pstrs_acc);\n\n\t \n\n\tBUG_ON(pstrs_acc - pstrs > PAGE_SIZE);\n\n\t \n\tpdesc->reservedMBZ = 0;\n\tpdesc->statStartVA = (uintptr_t)pstat;\n\tpdesc->strsStartVA = (uintptr_t)pstrs;\n\tpdesc->statLength = sizeof(*pstat) * MKSSTAT_KERN_COUNT;\n\tpdesc->infoLength = sizeof(*pinfo) * MKSSTAT_KERN_COUNT;\n\tpdesc->strsLength = pstrs_acc - pstrs;\n\tsnprintf(pdesc->description, ARRAY_SIZE(pdesc->description) - 1, \"%s pid=%d\",\n\t\tMKSSTAT_KERNEL_DESCRIPTION, current->pid);\n\n\tpdesc->statPPNs[0] = page_to_pfn(virt_to_page(pstat));\n\treset_ppn_array(pdesc->statPPNs + 1, ARRAY_SIZE(pdesc->statPPNs) - 1);\n\n\tpdesc->infoPPNs[0] = page_to_pfn(virt_to_page(pinfo));\n\treset_ppn_array(pdesc->infoPPNs + 1, ARRAY_SIZE(pdesc->infoPPNs) - 1);\n\n\tpdesc->strsPPNs[0] = page_to_pfn(virt_to_page(pstrs));\n\treset_ppn_array(pdesc->strsPPNs + 1, ARRAY_SIZE(pdesc->strsPPNs) - 1);\n\n\t*ppage = page;\n\n\thypervisor_ppn_add((PPN64)page_to_pfn(page));\n\n\treturn 0;\n}\n\n \n\nint vmw_mksstat_get_kern_slot(pid_t pid, struct vmw_private *dev_priv)\n{\n\tconst size_t base = (u32)hash_32(pid, MKSSTAT_CAPACITY_LOG2);\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dev_priv->mksstat_kern_pids); ++i) {\n\t\tconst size_t slot = (i + base) % ARRAY_SIZE(dev_priv->mksstat_kern_pids);\n\n\t\t \n\t\tif (pid == (pid_t)atomic_read(&dev_priv->mksstat_kern_pids[slot]))\n\t\t\treturn (int)slot;\n\n\t\t \n\t\tif (!atomic_cmpxchg(&dev_priv->mksstat_kern_pids[slot], 0, MKSSTAT_PID_RESERVED)) {\n\t\t\tconst int ret = mksstat_init_kern_id(&dev_priv->mksstat_kern_pages[slot]);\n\n\t\t\tif (!ret) {\n\t\t\t\t \n\t\t\t\tdev_priv->mksstat_kern_top_timer[slot] = MKSSTAT_KERN_COUNT;\n\n\t\t\t\tatomic_set(&dev_priv->mksstat_kern_pids[slot], pid);\n\t\t\t\treturn (int)slot;\n\t\t\t}\n\n\t\t\tatomic_set(&dev_priv->mksstat_kern_pids[slot], 0);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn -ENOSPC;\n}\n\n#endif\n\n \n\nstatic void vmw_mksstat_cleanup_descriptor(struct page *page)\n{\n\tMKSGuestStatInstanceDescriptor *pdesc = page_address(page);\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pdesc->statPPNs) && pdesc->statPPNs[i] != INVALID_PPN64; ++i)\n\t\tunpin_user_page(pfn_to_page(pdesc->statPPNs[i]));\n\n\tfor (i = 0; i < ARRAY_SIZE(pdesc->infoPPNs) && pdesc->infoPPNs[i] != INVALID_PPN64; ++i)\n\t\tunpin_user_page(pfn_to_page(pdesc->infoPPNs[i]));\n\n\tfor (i = 0; i < ARRAY_SIZE(pdesc->strsPPNs) && pdesc->strsPPNs[i] != INVALID_PPN64; ++i)\n\t\tunpin_user_page(pfn_to_page(pdesc->strsPPNs[i]));\n\n\t__free_page(page);\n}\n\n \n\nint vmw_mksstat_remove_all(struct vmw_private *dev_priv)\n{\n\tint ret = 0;\n\tsize_t i;\n\n\t \n\thypervisor_ppn_reset_all();\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dev_priv->mksstat_user_pids); ++i) {\n\t\tconst pid_t pid0 = (pid_t)atomic_read(&dev_priv->mksstat_user_pids[i]);\n\n\t\tif (!pid0)\n\t\t\tcontinue;\n\n\t\tif (pid0 != MKSSTAT_PID_RESERVED) {\n\t\t\tconst pid_t pid1 = atomic_cmpxchg(&dev_priv->mksstat_user_pids[i], pid0, MKSSTAT_PID_RESERVED);\n\n\t\t\tif (!pid1)\n\t\t\t\tcontinue;\n\n\t\t\tif (pid1 == pid0) {\n\t\t\t\tstruct page *const page = dev_priv->mksstat_user_pages[i];\n\n\t\t\t\tBUG_ON(!page);\n\n\t\t\t\tdev_priv->mksstat_user_pages[i] = NULL;\n\t\t\t\tatomic_set(&dev_priv->mksstat_user_pids[i], 0);\n\n\t\t\t\tvmw_mksstat_cleanup_descriptor(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tret = -EAGAIN;\n\t}\n\n#if IS_ENABLED(CONFIG_DRM_VMWGFX_MKSSTATS)\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dev_priv->mksstat_kern_pids); ++i) {\n\t\tconst pid_t pid0 = (pid_t)atomic_read(&dev_priv->mksstat_kern_pids[i]);\n\n\t\tif (!pid0)\n\t\t\tcontinue;\n\n\t\tif (pid0 != MKSSTAT_PID_RESERVED) {\n\t\t\tconst pid_t pid1 = atomic_cmpxchg(&dev_priv->mksstat_kern_pids[i], pid0, MKSSTAT_PID_RESERVED);\n\n\t\t\tif (!pid1)\n\t\t\t\tcontinue;\n\n\t\t\tif (pid1 == pid0) {\n\t\t\t\tstruct page *const page = dev_priv->mksstat_kern_pages[i];\n\n\t\t\t\tBUG_ON(!page);\n\n\t\t\t\tdev_priv->mksstat_kern_pages[i] = NULL;\n\t\t\t\tatomic_set(&dev_priv->mksstat_kern_pids[i], 0);\n\n\t\t\t\t__free_pages(page, MKSSTAT_KERNEL_PAGES_ORDER);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tret = -EAGAIN;\n\t}\n\n#endif\n\treturn ret;\n}\n\n \n\nint vmw_mksstat_reset_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct vmw_private *const dev_priv = vmw_priv(dev);\n\treturn vmw_mksstat_remove_all(dev_priv);\n}\n\n \n\nint vmw_mksstat_add_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_vmw_mksstat_add_arg *arg =\n\t\t(struct drm_vmw_mksstat_add_arg *) data;\n\n\tstruct vmw_private *const dev_priv = vmw_priv(dev);\n\n\tconst size_t num_pages_stat = PFN_UP(arg->stat_len);\n\tconst size_t num_pages_info = PFN_UP(arg->info_len);\n\tconst size_t num_pages_strs = PFN_UP(arg->strs_len);\n\tlong desc_len;\n\tlong nr_pinned_stat;\n\tlong nr_pinned_info;\n\tlong nr_pinned_strs;\n\tMKSGuestStatInstanceDescriptor *pdesc;\n\tstruct page *page = NULL;\n\tstruct page **pages_stat = NULL;\n\tstruct page **pages_info = NULL;\n\tstruct page **pages_strs = NULL;\n\tsize_t i, slot;\n\tint ret_err = -ENOMEM;\n\n\targ->id = -1;\n\n\tif (!arg->stat || !arg->info || !arg->strs)\n\t\treturn -EINVAL;\n\n\tif (!arg->stat_len || !arg->info_len || !arg->strs_len)\n\t\treturn -EINVAL;\n\n\tif (!arg->description)\n\t\treturn -EINVAL;\n\n\tif (num_pages_stat > ARRAY_SIZE(pdesc->statPPNs) ||\n\t\tnum_pages_info > ARRAY_SIZE(pdesc->infoPPNs) ||\n\t\tnum_pages_strs > ARRAY_SIZE(pdesc->strsPPNs))\n\t\treturn -EINVAL;\n\n\t \n\tfor (slot = 0; slot < ARRAY_SIZE(dev_priv->mksstat_user_pids); ++slot)\n\t\tif (!atomic_cmpxchg(&dev_priv->mksstat_user_pids[slot], 0, MKSSTAT_PID_RESERVED))\n\t\t\tbreak;\n\n\tif (slot == ARRAY_SIZE(dev_priv->mksstat_user_pids))\n\t\treturn -ENOSPC;\n\n\tBUG_ON(dev_priv->mksstat_user_pages[slot]);\n\n\t \n\tpages_stat = (struct page **)kmalloc_array(\n\t\tARRAY_SIZE(pdesc->statPPNs) +\n\t\tARRAY_SIZE(pdesc->infoPPNs) +\n\t\tARRAY_SIZE(pdesc->strsPPNs), sizeof(*pages_stat), GFP_KERNEL);\n\n\tif (!pages_stat)\n\t\tgoto err_nomem;\n\n\tpages_info = pages_stat + ARRAY_SIZE(pdesc->statPPNs);\n\tpages_strs = pages_info + ARRAY_SIZE(pdesc->infoPPNs);\n\n\t \n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\n\tif (!page)\n\t\tgoto err_nomem;\n\n\t \n\tpdesc = page_address(page);\n\n\tpdesc->reservedMBZ = 0;\n\tpdesc->statStartVA = arg->stat;\n\tpdesc->strsStartVA = arg->strs;\n\tpdesc->statLength = arg->stat_len;\n\tpdesc->infoLength = arg->info_len;\n\tpdesc->strsLength = arg->strs_len;\n\tdesc_len = strncpy_from_user(pdesc->description, u64_to_user_ptr(arg->description),\n\t\tARRAY_SIZE(pdesc->description) - 1);\n\n\tif (desc_len < 0) {\n\t\tret_err = -EFAULT;\n\t\tgoto err_nomem;\n\t}\n\n\treset_ppn_array(pdesc->statPPNs, ARRAY_SIZE(pdesc->statPPNs));\n\treset_ppn_array(pdesc->infoPPNs, ARRAY_SIZE(pdesc->infoPPNs));\n\treset_ppn_array(pdesc->strsPPNs, ARRAY_SIZE(pdesc->strsPPNs));\n\n\t \n\tnr_pinned_stat = pin_user_pages_fast(arg->stat, num_pages_stat, FOLL_LONGTERM, pages_stat);\n\tif (num_pages_stat != nr_pinned_stat)\n\t\tgoto err_pin_stat;\n\n\tfor (i = 0; i < num_pages_stat; ++i)\n\t\tpdesc->statPPNs[i] = page_to_pfn(pages_stat[i]);\n\n\tnr_pinned_info = pin_user_pages_fast(arg->info, num_pages_info, FOLL_LONGTERM, pages_info);\n\tif (num_pages_info != nr_pinned_info)\n\t\tgoto err_pin_info;\n\n\tfor (i = 0; i < num_pages_info; ++i)\n\t\tpdesc->infoPPNs[i] = page_to_pfn(pages_info[i]);\n\n\tnr_pinned_strs = pin_user_pages_fast(arg->strs, num_pages_strs, FOLL_LONGTERM, pages_strs);\n\tif (num_pages_strs != nr_pinned_strs)\n\t\tgoto err_pin_strs;\n\n\tfor (i = 0; i < num_pages_strs; ++i)\n\t\tpdesc->strsPPNs[i] = page_to_pfn(pages_strs[i]);\n\n\t \n\thypervisor_ppn_add((PPN64)page_to_pfn(page));\n\n\tdev_priv->mksstat_user_pages[slot] = page;\n\tatomic_set(&dev_priv->mksstat_user_pids[slot], task_pgrp_vnr(current));\n\n\targ->id = slot;\n\n\tDRM_DEV_INFO(dev->dev, \"pid=%d arg.description='%.*s' id=%zu\\n\", current->pid, (int)desc_len, pdesc->description, slot);\n\n\tkfree(pages_stat);\n\treturn 0;\n\nerr_pin_strs:\n\tif (nr_pinned_strs > 0)\n\t\tunpin_user_pages(pages_strs, nr_pinned_strs);\n\nerr_pin_info:\n\tif (nr_pinned_info > 0)\n\t\tunpin_user_pages(pages_info, nr_pinned_info);\n\nerr_pin_stat:\n\tif (nr_pinned_stat > 0)\n\t\tunpin_user_pages(pages_stat, nr_pinned_stat);\n\nerr_nomem:\n\tatomic_set(&dev_priv->mksstat_user_pids[slot], 0);\n\tif (page)\n\t\t__free_page(page);\n\tkfree(pages_stat);\n\n\treturn ret_err;\n}\n\n \n\nint vmw_mksstat_remove_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_vmw_mksstat_remove_arg *arg =\n\t\t(struct drm_vmw_mksstat_remove_arg *) data;\n\n\tstruct vmw_private *const dev_priv = vmw_priv(dev);\n\n\tconst size_t slot = arg->id;\n\tpid_t pgid, pid;\n\n\tif (slot >= ARRAY_SIZE(dev_priv->mksstat_user_pids))\n\t\treturn -EINVAL;\n\n\tDRM_DEV_INFO(dev->dev, \"pid=%d arg.id=%zu\\n\", current->pid, slot);\n\n\tpgid = task_pgrp_vnr(current);\n\tpid = atomic_cmpxchg(&dev_priv->mksstat_user_pids[slot], pgid, MKSSTAT_PID_RESERVED);\n\n\tif (!pid)\n\t\treturn 0;\n\n\tif (pid == pgid) {\n\t\tstruct page *const page = dev_priv->mksstat_user_pages[slot];\n\n\t\tBUG_ON(!page);\n\n\t\tdev_priv->mksstat_user_pages[slot] = NULL;\n\t\tatomic_set(&dev_priv->mksstat_user_pids[slot], 0);\n\n\t\thypervisor_ppn_remove((PPN64)page_to_pfn(page));\n\n\t\tvmw_mksstat_cleanup_descriptor(page);\n\t\treturn 0;\n\t}\n\n\treturn -EAGAIN;\n}\n\n \nvoid vmw_disable_backdoor(void)\n{\n\tvmw_msg_enabled = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}