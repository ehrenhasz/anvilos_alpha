{
  "module_name": "vmwgfx_cmd.c",
  "hash_id": "a86f32a414d3d79dbab2eed7e54ffdf5773e39171b5a855d718631d9e1faf861",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vmwgfx/vmwgfx_cmd.c",
  "human_readable_source": "\n \n#include \"vmwgfx_bo.h\"\n#include \"vmwgfx_drv.h\"\n#include \"vmwgfx_devcaps.h\"\n\n#include <drm/ttm/ttm_placement.h>\n\n#include <linux/sched/signal.h>\n\nbool vmw_supports_3d(struct vmw_private *dev_priv)\n{\n\tuint32_t fifo_min, hwversion;\n\tconst struct vmw_fifo_state *fifo = dev_priv->fifo;\n\n\tif (!(dev_priv->capabilities & SVGA_CAP_3D))\n\t\treturn false;\n\n\tif (dev_priv->capabilities & SVGA_CAP_GBOBJECTS) {\n\t\tuint32_t result;\n\n\t\tif (!dev_priv->has_mob)\n\t\t\treturn false;\n\n\t\tresult = vmw_devcap_get(dev_priv, SVGA3D_DEVCAP_3D);\n\n\t\treturn (result != 0);\n\t}\n\n\tif (!(dev_priv->capabilities & SVGA_CAP_EXTENDED_FIFO))\n\t\treturn false;\n\n\tBUG_ON(vmw_is_svga_v3(dev_priv));\n\n\tfifo_min = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_MIN);\n\tif (fifo_min <= SVGA_FIFO_3D_HWVERSION * sizeof(unsigned int))\n\t\treturn false;\n\n\thwversion = vmw_fifo_mem_read(dev_priv,\n\t\t\t\t      ((fifo->capabilities &\n\t\t\t\t\tSVGA_FIFO_CAP_3D_HWVERSION_REVISED) ?\n\t\t\t\t\t       SVGA_FIFO_3D_HWVERSION_REVISED :\n\t\t\t\t\t       SVGA_FIFO_3D_HWVERSION));\n\n\tif (hwversion == 0)\n\t\treturn false;\n\n\tif (hwversion < SVGA3D_HWVERSION_WS8_B1)\n\t\treturn false;\n\n\t \n\tif (dev_priv->active_display_unit == vmw_du_legacy)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv)\n{\n\tuint32_t caps;\n\n\tif (!(dev_priv->capabilities & SVGA_CAP_EXTENDED_FIFO))\n\t\treturn false;\n\n\tcaps = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_CAPABILITIES);\n\tif (caps & SVGA_FIFO_CAP_PITCHLOCK)\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct vmw_fifo_state *vmw_fifo_create(struct vmw_private *dev_priv)\n{\n\tstruct vmw_fifo_state *fifo;\n\tuint32_t max;\n\tuint32_t min;\n\n\tif (!dev_priv->fifo_mem)\n\t\treturn NULL;\n\n\tfifo = kzalloc(sizeof(*fifo), GFP_KERNEL);\n\tif (!fifo)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfifo->static_buffer_size = VMWGFX_FIFO_STATIC_SIZE;\n\tfifo->static_buffer = vmalloc(fifo->static_buffer_size);\n\tif (unlikely(fifo->static_buffer == NULL)) {\n\t\tkfree(fifo);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfifo->dynamic_buffer = NULL;\n\tfifo->reserved_size = 0;\n\tfifo->using_bounce_buffer = false;\n\n\tmutex_init(&fifo->fifo_mutex);\n\tinit_rwsem(&fifo->rwsem);\n\tmin = 4;\n\tif (dev_priv->capabilities & SVGA_CAP_EXTENDED_FIFO)\n\t\tmin = vmw_read(dev_priv, SVGA_REG_MEM_REGS);\n\tmin <<= 2;\n\n\tif (min < PAGE_SIZE)\n\t\tmin = PAGE_SIZE;\n\n\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_MIN, min);\n\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_MAX, dev_priv->fifo_mem_size);\n\twmb();\n\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_NEXT_CMD, min);\n\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_STOP, min);\n\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_BUSY, 0);\n\tmb();\n\n\tvmw_write(dev_priv, SVGA_REG_CONFIG_DONE, 1);\n\n\tmax = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_MAX);\n\tmin = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_MIN);\n\tfifo->capabilities = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_CAPABILITIES);\n\n\tdrm_info(&dev_priv->drm,\n\t\t \"Fifo max 0x%08x min 0x%08x cap 0x%08x\\n\",\n\t\t (unsigned int) max,\n\t\t (unsigned int) min,\n\t\t (unsigned int) fifo->capabilities);\n\n\tif (unlikely(min >= max)) {\n\t\tdrm_warn(&dev_priv->drm,\n\t\t\t \"FIFO memory is not usable. Driver failed to initialize.\");\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\treturn fifo;\n}\n\nvoid vmw_fifo_ping_host(struct vmw_private *dev_priv, uint32_t reason)\n{\n\tu32 *fifo_mem = dev_priv->fifo_mem;\n\tif (fifo_mem && cmpxchg(fifo_mem + SVGA_FIFO_BUSY, 0, 1) == 0)\n\t\tvmw_write(dev_priv, SVGA_REG_SYNC, reason);\n\n}\n\nvoid vmw_fifo_destroy(struct vmw_private *dev_priv)\n{\n\tstruct vmw_fifo_state *fifo = dev_priv->fifo;\n\n\tif (!fifo)\n\t\treturn;\n\n\tif (likely(fifo->static_buffer != NULL)) {\n\t\tvfree(fifo->static_buffer);\n\t\tfifo->static_buffer = NULL;\n\t}\n\n\tif (likely(fifo->dynamic_buffer != NULL)) {\n\t\tvfree(fifo->dynamic_buffer);\n\t\tfifo->dynamic_buffer = NULL;\n\t}\n\tkfree(fifo);\n\tdev_priv->fifo = NULL;\n}\n\nstatic bool vmw_fifo_is_full(struct vmw_private *dev_priv, uint32_t bytes)\n{\n\tuint32_t max = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_MAX);\n\tuint32_t next_cmd = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_NEXT_CMD);\n\tuint32_t min = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_MIN);\n\tuint32_t stop = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_STOP);\n\n\treturn ((max - next_cmd) + (stop - min) <= bytes);\n}\n\nstatic int vmw_fifo_wait_noirq(struct vmw_private *dev_priv,\n\t\t\t       uint32_t bytes, bool interruptible,\n\t\t\t       unsigned long timeout)\n{\n\tint ret = 0;\n\tunsigned long end_jiffies = jiffies + timeout;\n\tDEFINE_WAIT(__wait);\n\n\tDRM_INFO(\"Fifo wait noirq.\\n\");\n\n\tfor (;;) {\n\t\tprepare_to_wait(&dev_priv->fifo_queue, &__wait,\n\t\t\t\t(interruptible) ?\n\t\t\t\tTASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\t\tif (!vmw_fifo_is_full(dev_priv, bytes))\n\t\t\tbreak;\n\t\tif (time_after_eq(jiffies, end_jiffies)) {\n\t\t\tret = -EBUSY;\n\t\t\tDRM_ERROR(\"SVGA device lockup.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tschedule_timeout(1);\n\t\tif (interruptible && signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(&dev_priv->fifo_queue, &__wait);\n\twake_up_all(&dev_priv->fifo_queue);\n\tDRM_INFO(\"Fifo noirq exit.\\n\");\n\treturn ret;\n}\n\nstatic int vmw_fifo_wait(struct vmw_private *dev_priv,\n\t\t\t uint32_t bytes, bool interruptible,\n\t\t\t unsigned long timeout)\n{\n\tlong ret = 1L;\n\n\tif (likely(!vmw_fifo_is_full(dev_priv, bytes)))\n\t\treturn 0;\n\n\tvmw_fifo_ping_host(dev_priv, SVGA_SYNC_FIFOFULL);\n\tif (!(dev_priv->capabilities & SVGA_CAP_IRQMASK))\n\t\treturn vmw_fifo_wait_noirq(dev_priv, bytes,\n\t\t\t\t\t   interruptible, timeout);\n\n\tvmw_generic_waiter_add(dev_priv, SVGA_IRQFLAG_FIFO_PROGRESS,\n\t\t\t       &dev_priv->fifo_queue_waiters);\n\n\tif (interruptible)\n\t\tret = wait_event_interruptible_timeout\n\t\t    (dev_priv->fifo_queue,\n\t\t     !vmw_fifo_is_full(dev_priv, bytes), timeout);\n\telse\n\t\tret = wait_event_timeout\n\t\t    (dev_priv->fifo_queue,\n\t\t     !vmw_fifo_is_full(dev_priv, bytes), timeout);\n\n\tif (unlikely(ret == 0))\n\t\tret = -EBUSY;\n\telse if (likely(ret > 0))\n\t\tret = 0;\n\n\tvmw_generic_waiter_remove(dev_priv, SVGA_IRQFLAG_FIFO_PROGRESS,\n\t\t\t\t  &dev_priv->fifo_queue_waiters);\n\n\treturn ret;\n}\n\n \nstatic void *vmw_local_fifo_reserve(struct vmw_private *dev_priv,\n\t\t\t\t    uint32_t bytes)\n{\n\tstruct vmw_fifo_state *fifo_state = dev_priv->fifo;\n\tu32  *fifo_mem = dev_priv->fifo_mem;\n\tuint32_t max;\n\tuint32_t min;\n\tuint32_t next_cmd;\n\tuint32_t reserveable = fifo_state->capabilities & SVGA_FIFO_CAP_RESERVE;\n\tint ret;\n\n\tmutex_lock(&fifo_state->fifo_mutex);\n\tmax = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_MAX);\n\tmin = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_MIN);\n\tnext_cmd = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_NEXT_CMD);\n\n\tif (unlikely(bytes >= (max - min)))\n\t\tgoto out_err;\n\n\tBUG_ON(fifo_state->reserved_size != 0);\n\tBUG_ON(fifo_state->dynamic_buffer != NULL);\n\n\tfifo_state->reserved_size = bytes;\n\n\twhile (1) {\n\t\tuint32_t stop = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_STOP);\n\t\tbool need_bounce = false;\n\t\tbool reserve_in_place = false;\n\n\t\tif (next_cmd >= stop) {\n\t\t\tif (likely((next_cmd + bytes < max ||\n\t\t\t\t    (next_cmd + bytes == max && stop > min))))\n\t\t\t\treserve_in_place = true;\n\n\t\t\telse if (vmw_fifo_is_full(dev_priv, bytes)) {\n\t\t\t\tret = vmw_fifo_wait(dev_priv, bytes,\n\t\t\t\t\t\t    false, 3 * HZ);\n\t\t\t\tif (unlikely(ret != 0))\n\t\t\t\t\tgoto out_err;\n\t\t\t} else\n\t\t\t\tneed_bounce = true;\n\n\t\t} else {\n\n\t\t\tif (likely((next_cmd + bytes < stop)))\n\t\t\t\treserve_in_place = true;\n\t\t\telse {\n\t\t\t\tret = vmw_fifo_wait(dev_priv, bytes,\n\t\t\t\t\t\t    false, 3 * HZ);\n\t\t\t\tif (unlikely(ret != 0))\n\t\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\tif (reserve_in_place) {\n\t\t\tif (reserveable || bytes <= sizeof(uint32_t)) {\n\t\t\t\tfifo_state->using_bounce_buffer = false;\n\n\t\t\t\tif (reserveable)\n\t\t\t\t\tvmw_fifo_mem_write(dev_priv,\n\t\t\t\t\t\t\t   SVGA_FIFO_RESERVED,\n\t\t\t\t\t\t\t   bytes);\n\t\t\t\treturn (void __force *) (fifo_mem +\n\t\t\t\t\t\t\t (next_cmd >> 2));\n\t\t\t} else {\n\t\t\t\tneed_bounce = true;\n\t\t\t}\n\t\t}\n\n\t\tif (need_bounce) {\n\t\t\tfifo_state->using_bounce_buffer = true;\n\t\t\tif (bytes < fifo_state->static_buffer_size)\n\t\t\t\treturn fifo_state->static_buffer;\n\t\t\telse {\n\t\t\t\tfifo_state->dynamic_buffer = vmalloc(bytes);\n\t\t\t\tif (!fifo_state->dynamic_buffer)\n\t\t\t\t\tgoto out_err;\n\t\t\t\treturn fifo_state->dynamic_buffer;\n\t\t\t}\n\t\t}\n\t}\nout_err:\n\tfifo_state->reserved_size = 0;\n\tmutex_unlock(&fifo_state->fifo_mutex);\n\n\treturn NULL;\n}\n\nvoid *vmw_cmd_ctx_reserve(struct vmw_private *dev_priv, uint32_t bytes,\n\t\t\t  int ctx_id)\n{\n\tvoid *ret;\n\n\tif (dev_priv->cman)\n\t\tret = vmw_cmdbuf_reserve(dev_priv->cman, bytes,\n\t\t\t\t\t ctx_id, false, NULL);\n\telse if (ctx_id == SVGA3D_INVALID_ID)\n\t\tret = vmw_local_fifo_reserve(dev_priv, bytes);\n\telse {\n\t\tWARN(1, \"Command buffer has not been allocated.\\n\");\n\t\tret = NULL;\n\t}\n\tif (IS_ERR_OR_NULL(ret))\n\t\treturn NULL;\n\n\treturn ret;\n}\n\nstatic void vmw_fifo_res_copy(struct vmw_fifo_state *fifo_state,\n\t\t\t      struct vmw_private *vmw,\n\t\t\t      uint32_t next_cmd,\n\t\t\t      uint32_t max, uint32_t min, uint32_t bytes)\n{\n\tu32 *fifo_mem = vmw->fifo_mem;\n\tuint32_t chunk_size = max - next_cmd;\n\tuint32_t rest;\n\tuint32_t *buffer = (fifo_state->dynamic_buffer != NULL) ?\n\t    fifo_state->dynamic_buffer : fifo_state->static_buffer;\n\n\tif (bytes < chunk_size)\n\t\tchunk_size = bytes;\n\n\tvmw_fifo_mem_write(vmw, SVGA_FIFO_RESERVED, bytes);\n\tmb();\n\tmemcpy(fifo_mem + (next_cmd >> 2), buffer, chunk_size);\n\trest = bytes - chunk_size;\n\tif (rest)\n\t\tmemcpy(fifo_mem + (min >> 2), buffer + (chunk_size >> 2), rest);\n}\n\nstatic void vmw_fifo_slow_copy(struct vmw_fifo_state *fifo_state,\n\t\t\t       struct vmw_private *vmw,\n\t\t\t       uint32_t next_cmd,\n\t\t\t       uint32_t max, uint32_t min, uint32_t bytes)\n{\n\tuint32_t *buffer = (fifo_state->dynamic_buffer != NULL) ?\n\t    fifo_state->dynamic_buffer : fifo_state->static_buffer;\n\n\twhile (bytes > 0) {\n\t\tvmw_fifo_mem_write(vmw, (next_cmd >> 2), *buffer++);\n\t\tnext_cmd += sizeof(uint32_t);\n\t\tif (unlikely(next_cmd == max))\n\t\t\tnext_cmd = min;\n\t\tmb();\n\t\tvmw_fifo_mem_write(vmw, SVGA_FIFO_NEXT_CMD, next_cmd);\n\t\tmb();\n\t\tbytes -= sizeof(uint32_t);\n\t}\n}\n\nstatic void vmw_local_fifo_commit(struct vmw_private *dev_priv, uint32_t bytes)\n{\n\tstruct vmw_fifo_state *fifo_state = dev_priv->fifo;\n\tuint32_t next_cmd = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_NEXT_CMD);\n\tuint32_t max = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_MAX);\n\tuint32_t min = vmw_fifo_mem_read(dev_priv, SVGA_FIFO_MIN);\n\tbool reserveable = fifo_state->capabilities & SVGA_FIFO_CAP_RESERVE;\n\n\tBUG_ON((bytes & 3) != 0);\n\tBUG_ON(bytes > fifo_state->reserved_size);\n\n\tfifo_state->reserved_size = 0;\n\n\tif (fifo_state->using_bounce_buffer) {\n\t\tif (reserveable)\n\t\t\tvmw_fifo_res_copy(fifo_state, dev_priv,\n\t\t\t\t\t  next_cmd, max, min, bytes);\n\t\telse\n\t\t\tvmw_fifo_slow_copy(fifo_state, dev_priv,\n\t\t\t\t\t   next_cmd, max, min, bytes);\n\n\t\tif (fifo_state->dynamic_buffer) {\n\t\t\tvfree(fifo_state->dynamic_buffer);\n\t\t\tfifo_state->dynamic_buffer = NULL;\n\t\t}\n\n\t}\n\n\tdown_write(&fifo_state->rwsem);\n\tif (fifo_state->using_bounce_buffer || reserveable) {\n\t\tnext_cmd += bytes;\n\t\tif (next_cmd >= max)\n\t\t\tnext_cmd -= max - min;\n\t\tmb();\n\t\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_NEXT_CMD, next_cmd);\n\t}\n\n\tif (reserveable)\n\t\tvmw_fifo_mem_write(dev_priv, SVGA_FIFO_RESERVED, 0);\n\tmb();\n\tup_write(&fifo_state->rwsem);\n\tvmw_fifo_ping_host(dev_priv, SVGA_SYNC_GENERIC);\n\tmutex_unlock(&fifo_state->fifo_mutex);\n}\n\nvoid vmw_cmd_commit(struct vmw_private *dev_priv, uint32_t bytes)\n{\n\tif (dev_priv->cman)\n\t\tvmw_cmdbuf_commit(dev_priv->cman, bytes, NULL, false);\n\telse\n\t\tvmw_local_fifo_commit(dev_priv, bytes);\n}\n\n\n \nvoid vmw_cmd_commit_flush(struct vmw_private *dev_priv, uint32_t bytes)\n{\n\tif (dev_priv->cman)\n\t\tvmw_cmdbuf_commit(dev_priv->cman, bytes, NULL, true);\n\telse\n\t\tvmw_local_fifo_commit(dev_priv, bytes);\n}\n\n \nint vmw_cmd_flush(struct vmw_private *dev_priv, bool interruptible)\n{\n\tmight_sleep();\n\n\tif (dev_priv->cman)\n\t\treturn vmw_cmdbuf_cur_flush(dev_priv->cman, interruptible);\n\telse\n\t\treturn 0;\n}\n\nint vmw_cmd_send_fence(struct vmw_private *dev_priv, uint32_t *seqno)\n{\n\tstruct svga_fifo_cmd_fence *cmd_fence;\n\tu32 *fm;\n\tint ret = 0;\n\tuint32_t bytes = sizeof(u32) + sizeof(*cmd_fence);\n\n\tfm = VMW_CMD_RESERVE(dev_priv, bytes);\n\tif (unlikely(fm == NULL)) {\n\t\t*seqno = atomic_read(&dev_priv->marker_seq);\n\t\tret = -ENOMEM;\n\t\t(void)vmw_fallback_wait(dev_priv, false, true, *seqno,\n\t\t\t\t\tfalse, 3*HZ);\n\t\tgoto out_err;\n\t}\n\n\tdo {\n\t\t*seqno = atomic_add_return(1, &dev_priv->marker_seq);\n\t} while (*seqno == 0);\n\n\tif (!vmw_has_fences(dev_priv)) {\n\n\t\t \n\n\t\tvmw_cmd_commit(dev_priv, 0);\n\t\treturn 0;\n\t}\n\n\t*fm++ = SVGA_CMD_FENCE;\n\tcmd_fence = (struct svga_fifo_cmd_fence *) fm;\n\tcmd_fence->fence = *seqno;\n\tvmw_cmd_commit_flush(dev_priv, bytes);\n\tvmw_update_seqno(dev_priv);\n\nout_err:\n\treturn ret;\n}\n\n \nstatic int vmw_cmd_emit_dummy_legacy_query(struct vmw_private *dev_priv,\n\t\t\t\t\t    uint32_t cid)\n{\n\t \n\n\tstruct ttm_buffer_object *bo = &dev_priv->dummy_query_bo->tbo;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdWaitForQuery body;\n\t} *cmd;\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_WAIT_FOR_QUERY;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = cid;\n\tcmd->body.type = SVGA3D_QUERYTYPE_OCCLUSION;\n\n\tif (bo->resource->mem_type == TTM_PL_VRAM) {\n\t\tcmd->body.guestResult.gmrId = SVGA_GMR_FRAMEBUFFER;\n\t\tcmd->body.guestResult.offset = bo->resource->start << PAGE_SHIFT;\n\t} else {\n\t\tcmd->body.guestResult.gmrId = bo->resource->start;\n\t\tcmd->body.guestResult.offset = 0;\n\t}\n\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\treturn 0;\n}\n\n \nstatic int vmw_cmd_emit_dummy_gb_query(struct vmw_private *dev_priv,\n\t\t\t\t       uint32_t cid)\n{\n\t \n\n\tstruct ttm_buffer_object *bo = &dev_priv->dummy_query_bo->tbo;\n\tstruct {\n\t\tSVGA3dCmdHeader header;\n\t\tSVGA3dCmdWaitForGBQuery body;\n\t} *cmd;\n\n\tcmd = VMW_CMD_RESERVE(dev_priv, sizeof(*cmd));\n\tif (unlikely(cmd == NULL))\n\t\treturn -ENOMEM;\n\n\tcmd->header.id = SVGA_3D_CMD_WAIT_FOR_GB_QUERY;\n\tcmd->header.size = sizeof(cmd->body);\n\tcmd->body.cid = cid;\n\tcmd->body.type = SVGA3D_QUERYTYPE_OCCLUSION;\n\tBUG_ON(bo->resource->mem_type != VMW_PL_MOB);\n\tcmd->body.mobid = bo->resource->start;\n\tcmd->body.offset = 0;\n\n\tvmw_cmd_commit(dev_priv, sizeof(*cmd));\n\n\treturn 0;\n}\n\n\n \nint vmw_cmd_emit_dummy_query(struct vmw_private *dev_priv,\n\t\t\t      uint32_t cid)\n{\n\tif (dev_priv->has_mob)\n\t\treturn vmw_cmd_emit_dummy_gb_query(dev_priv, cid);\n\n\treturn vmw_cmd_emit_dummy_legacy_query(dev_priv, cid);\n}\n\n\n \nbool vmw_cmd_supported(struct vmw_private *vmw)\n{\n\tbool has_cmdbufs =\n\t\t(vmw->capabilities & (SVGA_CAP_COMMAND_BUFFERS |\n\t\t\t\t      SVGA_CAP_CMD_BUFFERS_2)) != 0;\n\tif (vmw_is_svga_v3(vmw))\n\t\treturn (has_cmdbufs &&\n\t\t\t(vmw->capabilities & SVGA_CAP_GBOBJECTS) != 0);\n\t \n\treturn has_cmdbufs || vmw->fifo_mem != NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}