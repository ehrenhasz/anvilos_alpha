{
  "module_name": "drm_vblank_work.c",
  "hash_id": "eb21bb7b8acc5f111f01213a93b2a251adb340bbb28158bddf421636beeabc42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_vblank_work.c",
  "human_readable_source": "\n\n#include <uapi/linux/sched/types.h>\n\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_vblank_work.h>\n#include <drm/drm_crtc.h>\n\n#include \"drm_internal.h\"\n\n \n\nvoid drm_handle_vblank_works(struct drm_vblank_crtc *vblank)\n{\n\tstruct drm_vblank_work *work, *next;\n\tu64 count = atomic64_read(&vblank->count);\n\tbool wake = false;\n\n\tassert_spin_locked(&vblank->dev->event_lock);\n\n\tlist_for_each_entry_safe(work, next, &vblank->pending_work, node) {\n\t\tif (!drm_vblank_passed(count, work->count))\n\t\t\tcontinue;\n\n\t\tlist_del_init(&work->node);\n\t\tdrm_vblank_put(vblank->dev, vblank->pipe);\n\t\tkthread_queue_work(vblank->worker, &work->base);\n\t\twake = true;\n\t}\n\tif (wake)\n\t\twake_up_all(&vblank->work_wait_queue);\n}\n\n \nvoid drm_vblank_cancel_pending_works(struct drm_vblank_crtc *vblank)\n{\n\tstruct drm_vblank_work *work, *next;\n\n\tassert_spin_locked(&vblank->dev->event_lock);\n\n\tlist_for_each_entry_safe(work, next, &vblank->pending_work, node) {\n\t\tlist_del_init(&work->node);\n\t\tdrm_vblank_put(vblank->dev, vblank->pipe);\n\t}\n\n\twake_up_all(&vblank->work_wait_queue);\n}\n\n \nint drm_vblank_work_schedule(struct drm_vblank_work *work,\n\t\t\t     u64 count, bool nextonmiss)\n{\n\tstruct drm_vblank_crtc *vblank = work->vblank;\n\tstruct drm_device *dev = vblank->dev;\n\tu64 cur_vbl;\n\tunsigned long irqflags;\n\tbool passed, inmodeset, rescheduling = false, wake = false;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&dev->event_lock, irqflags);\n\tif (work->cancelling)\n\t\tgoto out;\n\n\tspin_lock(&dev->vbl_lock);\n\tinmodeset = vblank->inmodeset;\n\tspin_unlock(&dev->vbl_lock);\n\tif (inmodeset)\n\t\tgoto out;\n\n\tif (list_empty(&work->node)) {\n\t\tret = drm_vblank_get(dev, vblank->pipe);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else if (work->count == count) {\n\t\t \n\t\tgoto out;\n\t} else {\n\t\trescheduling = true;\n\t}\n\n\twork->count = count;\n\tcur_vbl = drm_vblank_count(dev, vblank->pipe);\n\tpassed = drm_vblank_passed(cur_vbl, count);\n\tif (passed)\n\t\tdrm_dbg_core(dev,\n\t\t\t     \"crtc %d vblank %llu already passed (current %llu)\\n\",\n\t\t\t     vblank->pipe, count, cur_vbl);\n\n\tif (!nextonmiss && passed) {\n\t\tdrm_vblank_put(dev, vblank->pipe);\n\t\tret = kthread_queue_work(vblank->worker, &work->base);\n\n\t\tif (rescheduling) {\n\t\t\tlist_del_init(&work->node);\n\t\t\twake = true;\n\t\t}\n\t} else {\n\t\tif (!rescheduling)\n\t\t\tlist_add_tail(&work->node, &vblank->pending_work);\n\t\tret = true;\n\t}\n\nout:\n\tspin_unlock_irqrestore(&dev->event_lock, irqflags);\n\tif (wake)\n\t\twake_up_all(&vblank->work_wait_queue);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_vblank_work_schedule);\n\n \nbool drm_vblank_work_cancel_sync(struct drm_vblank_work *work)\n{\n\tstruct drm_vblank_crtc *vblank = work->vblank;\n\tstruct drm_device *dev = vblank->dev;\n\tbool ret = false;\n\n\tspin_lock_irq(&dev->event_lock);\n\tif (!list_empty(&work->node)) {\n\t\tlist_del_init(&work->node);\n\t\tdrm_vblank_put(vblank->dev, vblank->pipe);\n\t\tret = true;\n\t}\n\n\twork->cancelling++;\n\tspin_unlock_irq(&dev->event_lock);\n\n\twake_up_all(&vblank->work_wait_queue);\n\n\tif (kthread_cancel_work_sync(&work->base))\n\t\tret = true;\n\n\tspin_lock_irq(&dev->event_lock);\n\twork->cancelling--;\n\tspin_unlock_irq(&dev->event_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_vblank_work_cancel_sync);\n\n \nvoid drm_vblank_work_flush(struct drm_vblank_work *work)\n{\n\tstruct drm_vblank_crtc *vblank = work->vblank;\n\tstruct drm_device *dev = vblank->dev;\n\n\tspin_lock_irq(&dev->event_lock);\n\twait_event_lock_irq(vblank->work_wait_queue, list_empty(&work->node),\n\t\t\t    dev->event_lock);\n\tspin_unlock_irq(&dev->event_lock);\n\n\tkthread_flush_work(&work->base);\n}\nEXPORT_SYMBOL(drm_vblank_work_flush);\n\n \nvoid drm_vblank_work_init(struct drm_vblank_work *work, struct drm_crtc *crtc,\n\t\t\t  void (*func)(struct kthread_work *work))\n{\n\tkthread_init_work(&work->base, func);\n\tINIT_LIST_HEAD(&work->node);\n\twork->vblank = &crtc->dev->vblank[drm_crtc_index(crtc)];\n}\nEXPORT_SYMBOL(drm_vblank_work_init);\n\nint drm_vblank_worker_init(struct drm_vblank_crtc *vblank)\n{\n\tstruct kthread_worker *worker;\n\n\tINIT_LIST_HEAD(&vblank->pending_work);\n\tinit_waitqueue_head(&vblank->work_wait_queue);\n\tworker = kthread_create_worker(0, \"card%d-crtc%d\",\n\t\t\t\t       vblank->dev->primary->index,\n\t\t\t\t       vblank->pipe);\n\tif (IS_ERR(worker))\n\t\treturn PTR_ERR(worker);\n\n\tvblank->worker = worker;\n\n\tsched_set_fifo(worker->task);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}