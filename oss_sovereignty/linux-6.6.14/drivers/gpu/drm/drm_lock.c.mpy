{
  "module_name": "drm_lock.c",
  "hash_id": "b33b31ce4d0e14dd2e97192dda903f8776297ffa2aaccf7ce5d1231ad9f7d7a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_lock.c",
  "human_readable_source": " \n\n \n\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n\n#include <drm/drm.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_print.h>\n\n#include \"drm_internal.h\"\n#include \"drm_legacy.h\"\n\nstatic int drm_lock_take(struct drm_lock_data *lock_data, unsigned int context);\n\n \nstatic\nint drm_lock_take(struct drm_lock_data *lock_data,\n\t\t  unsigned int context)\n{\n\tunsigned int old, new, prev;\n\tvolatile unsigned int *lock = &lock_data->hw_lock->lock;\n\n\tspin_lock_bh(&lock_data->spinlock);\n\tdo {\n\t\told = *lock;\n\t\tif (old & _DRM_LOCK_HELD)\n\t\t\tnew = old | _DRM_LOCK_CONT;\n\t\telse {\n\t\t\tnew = context | _DRM_LOCK_HELD |\n\t\t\t\t((lock_data->user_waiters + lock_data->kernel_waiters > 1) ?\n\t\t\t\t _DRM_LOCK_CONT : 0);\n\t\t}\n\t\tprev = cmpxchg(lock, old, new);\n\t} while (prev != old);\n\tspin_unlock_bh(&lock_data->spinlock);\n\n\tif (_DRM_LOCKING_CONTEXT(old) == context) {\n\t\tif (old & _DRM_LOCK_HELD) {\n\t\t\tif (context != DRM_KERNEL_CONTEXT) {\n\t\t\t\tDRM_ERROR(\"%d holds heavyweight lock\\n\",\n\t\t\t\t\t  context);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((_DRM_LOCKING_CONTEXT(new)) == context && (new & _DRM_LOCK_HELD)) {\n\t\t \n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int drm_lock_transfer(struct drm_lock_data *lock_data,\n\t\t\t     unsigned int context)\n{\n\tunsigned int old, new, prev;\n\tvolatile unsigned int *lock = &lock_data->hw_lock->lock;\n\n\tlock_data->file_priv = NULL;\n\tdo {\n\t\told = *lock;\n\t\tnew = context | _DRM_LOCK_HELD;\n\t\tprev = cmpxchg(lock, old, new);\n\t} while (prev != old);\n\treturn 1;\n}\n\nstatic int drm_legacy_lock_free(struct drm_lock_data *lock_data,\n\t\t\t\tunsigned int context)\n{\n\tunsigned int old, new, prev;\n\tvolatile unsigned int *lock = &lock_data->hw_lock->lock;\n\n\tspin_lock_bh(&lock_data->spinlock);\n\tif (lock_data->kernel_waiters != 0) {\n\t\tdrm_lock_transfer(lock_data, 0);\n\t\tlock_data->idle_has_lock = 1;\n\t\tspin_unlock_bh(&lock_data->spinlock);\n\t\treturn 1;\n\t}\n\tspin_unlock_bh(&lock_data->spinlock);\n\n\tdo {\n\t\told = *lock;\n\t\tnew = _DRM_LOCKING_CONTEXT(old);\n\t\tprev = cmpxchg(lock, old, new);\n\t} while (prev != old);\n\n\tif (_DRM_LOCK_IS_HELD(old) && _DRM_LOCKING_CONTEXT(old) != context) {\n\t\tDRM_ERROR(\"%d freed heavyweight lock held by %d\\n\",\n\t\t\t  context, _DRM_LOCKING_CONTEXT(old));\n\t\treturn 1;\n\t}\n\twake_up_interruptible(&lock_data->lock_queue);\n\treturn 0;\n}\n\n \nint drm_legacy_lock(struct drm_device *dev, void *data,\n\t\t    struct drm_file *file_priv)\n{\n\tDECLARE_WAITQUEUE(entry, current);\n\tstruct drm_lock *lock = data;\n\tstruct drm_master *master = file_priv->master;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\t++file_priv->lock_count;\n\n\tif (lock->context == DRM_KERNEL_CONTEXT) {\n\t\tDRM_ERROR(\"Process %d using kernel context %d\\n\",\n\t\t\t  task_pid_nr(current), lock->context);\n\t\treturn -EINVAL;\n\t}\n\n\tDRM_DEBUG(\"%d (pid %d) requests lock (0x%08x), flags = 0x%08x\\n\",\n\t\t  lock->context, task_pid_nr(current),\n\t\t  master->lock.hw_lock ? master->lock.hw_lock->lock : -1,\n\t\t  lock->flags);\n\n\tadd_wait_queue(&master->lock.lock_queue, &entry);\n\tspin_lock_bh(&master->lock.spinlock);\n\tmaster->lock.user_waiters++;\n\tspin_unlock_bh(&master->lock.spinlock);\n\n\tfor (;;) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!master->lock.hw_lock) {\n\t\t\t \n\t\t\tsend_sig(SIGTERM, current, 0);\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tif (drm_lock_take(&master->lock, lock->context)) {\n\t\t\tmaster->lock.file_priv = file_priv;\n\t\t\tmaster->lock.lock_time = jiffies;\n\t\t\tbreak;\t \n\t\t}\n\n\t\t \n\t\tmutex_unlock(&drm_global_mutex);\n\t\tschedule();\n\t\tmutex_lock(&drm_global_mutex);\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_lock_bh(&master->lock.spinlock);\n\tmaster->lock.user_waiters--;\n\tspin_unlock_bh(&master->lock.spinlock);\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&master->lock.lock_queue, &entry);\n\n\tDRM_DEBUG(\"%d %s\\n\", lock->context,\n\t\t  ret ? \"interrupted\" : \"has lock\");\n\tif (ret) return ret;\n\n\t \n\tif (!drm_is_current_master(file_priv)) {\n\t\tdev->sigdata.context = lock->context;\n\t\tdev->sigdata.lock = master->lock.hw_lock;\n\t}\n\n\tif (dev->driver->dma_quiescent && (lock->flags & _DRM_LOCK_QUIESCENT))\n\t{\n\t\tif (dev->driver->dma_quiescent(dev)) {\n\t\t\tDRM_DEBUG(\"%d waiting for DMA quiescent\\n\",\n\t\t\t\t  lock->context);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint drm_legacy_unlock(struct drm_device *dev, void *data, struct drm_file *file_priv)\n{\n\tstruct drm_lock *lock = data;\n\tstruct drm_master *master = file_priv->master;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\tif (lock->context == DRM_KERNEL_CONTEXT) {\n\t\tDRM_ERROR(\"Process %d using kernel context %d\\n\",\n\t\t\t  task_pid_nr(current), lock->context);\n\t\treturn -EINVAL;\n\t}\n\n\tif (drm_legacy_lock_free(&master->lock, lock->context)) {\n\t\t \n\t}\n\n\treturn 0;\n}\n\n \nvoid drm_legacy_idlelock_take(struct drm_lock_data *lock_data)\n{\n\tint ret;\n\n\tspin_lock_bh(&lock_data->spinlock);\n\tlock_data->kernel_waiters++;\n\tif (!lock_data->idle_has_lock) {\n\n\t\tspin_unlock_bh(&lock_data->spinlock);\n\t\tret = drm_lock_take(lock_data, DRM_KERNEL_CONTEXT);\n\t\tspin_lock_bh(&lock_data->spinlock);\n\n\t\tif (ret == 1)\n\t\t\tlock_data->idle_has_lock = 1;\n\t}\n\tspin_unlock_bh(&lock_data->spinlock);\n}\nEXPORT_SYMBOL(drm_legacy_idlelock_take);\n\nvoid drm_legacy_idlelock_release(struct drm_lock_data *lock_data)\n{\n\tunsigned int old, prev;\n\tvolatile unsigned int *lock = &lock_data->hw_lock->lock;\n\n\tspin_lock_bh(&lock_data->spinlock);\n\tif (--lock_data->kernel_waiters == 0) {\n\t\tif (lock_data->idle_has_lock) {\n\t\t\tdo {\n\t\t\t\told = *lock;\n\t\t\t\tprev = cmpxchg(lock, old, DRM_KERNEL_CONTEXT);\n\t\t\t} while (prev != old);\n\t\t\twake_up_interruptible(&lock_data->lock_queue);\n\t\t\tlock_data->idle_has_lock = 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&lock_data->spinlock);\n}\nEXPORT_SYMBOL(drm_legacy_idlelock_release);\n\nstatic int drm_legacy_i_have_hw_lock(struct drm_device *dev,\n\t\t\t\t     struct drm_file *file_priv)\n{\n\tstruct drm_master *master = file_priv->master;\n\n\treturn (file_priv->lock_count && master->lock.hw_lock &&\n\t\t_DRM_LOCK_IS_HELD(master->lock.hw_lock->lock) &&\n\t\tmaster->lock.file_priv == file_priv);\n}\n\nvoid drm_legacy_lock_release(struct drm_device *dev, struct file *filp)\n{\n\tstruct drm_file *file_priv = filp->private_data;\n\n\t \n\tif (!dev->master)\n\t\treturn;\n\n\tif (drm_legacy_i_have_hw_lock(dev, file_priv)) {\n\t\tDRM_DEBUG(\"File %p released, freeing lock for context %d\\n\",\n\t\t\t  filp, _DRM_LOCKING_CONTEXT(file_priv->master->lock.hw_lock->lock));\n\t\tdrm_legacy_lock_free(&file_priv->master->lock,\n\t\t\t\t     _DRM_LOCKING_CONTEXT(file_priv->master->lock.hw_lock->lock));\n\t}\n}\n\nvoid drm_legacy_lock_master_cleanup(struct drm_device *dev, struct drm_master *master)\n{\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn;\n\n\t \n\tmutex_lock(&dev->struct_mutex);\n\tif (master->lock.hw_lock) {\n\t\tif (dev->sigdata.lock == master->lock.hw_lock)\n\t\t\tdev->sigdata.lock = NULL;\n\t\tmaster->lock.hw_lock = NULL;\n\t\tmaster->lock.file_priv = NULL;\n\t\twake_up_interruptible_all(&master->lock.lock_queue);\n\t}\n\tmutex_unlock(&dev->struct_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}