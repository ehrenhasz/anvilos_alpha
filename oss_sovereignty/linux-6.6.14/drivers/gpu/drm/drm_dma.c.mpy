{
  "module_name": "drm_dma.c",
  "hash_id": "928a421db5b28a9e3a43b0e26a018362936dfe0b031a0637bacf06e0e5e34fdf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_dma.c",
  "human_readable_source": " \n\n \n\n#include <linux/export.h>\n#include <linux/pci.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_print.h>\n\n#include \"drm_legacy.h\"\n\n \nint drm_legacy_dma_setup(struct drm_device *dev)\n{\n\tint i;\n\n\tif (!drm_core_check_feature(dev, DRIVER_HAVE_DMA) ||\n\t    !drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn 0;\n\n\tdev->buf_use = 0;\n\tatomic_set(&dev->buf_alloc, 0);\n\n\tdev->dma = kzalloc(sizeof(*dev->dma), GFP_KERNEL);\n\tif (!dev->dma)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i <= DRM_MAX_ORDER; i++)\n\t\tmemset(&dev->dma->bufs[i], 0, sizeof(dev->dma->bufs[0]));\n\n\treturn 0;\n}\n\n \nvoid drm_legacy_dma_takedown(struct drm_device *dev)\n{\n\tstruct drm_device_dma *dma = dev->dma;\n\tdrm_dma_handle_t *dmah;\n\tint i, j;\n\n\tif (!drm_core_check_feature(dev, DRIVER_HAVE_DMA) ||\n\t    !drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn;\n\n\tif (!dma)\n\t\treturn;\n\n\t \n\tfor (i = 0; i <= DRM_MAX_ORDER; i++) {\n\t\tif (dma->bufs[i].seg_count) {\n\t\t\tDRM_DEBUG(\"order %d: buf_count = %d,\"\n\t\t\t\t  \" seg_count = %d\\n\",\n\t\t\t\t  i,\n\t\t\t\t  dma->bufs[i].buf_count,\n\t\t\t\t  dma->bufs[i].seg_count);\n\t\t\tfor (j = 0; j < dma->bufs[i].seg_count; j++) {\n\t\t\t\tif (dma->bufs[i].seglist[j]) {\n\t\t\t\t\tdmah = dma->bufs[i].seglist[j];\n\t\t\t\t\tdma_free_coherent(dev->dev,\n\t\t\t\t\t\t\t  dmah->size,\n\t\t\t\t\t\t\t  dmah->vaddr,\n\t\t\t\t\t\t\t  dmah->busaddr);\n\t\t\t\t\tkfree(dmah);\n\t\t\t\t}\n\t\t\t}\n\t\t\tkfree(dma->bufs[i].seglist);\n\t\t}\n\t\tif (dma->bufs[i].buf_count) {\n\t\t\tfor (j = 0; j < dma->bufs[i].buf_count; j++) {\n\t\t\t\tkfree(dma->bufs[i].buflist[j].dev_private);\n\t\t\t}\n\t\t\tkfree(dma->bufs[i].buflist);\n\t\t}\n\t}\n\n\tkfree(dma->buflist);\n\tkfree(dma->pagelist);\n\tkfree(dev->dma);\n\tdev->dma = NULL;\n}\n\n \nvoid drm_legacy_free_buffer(struct drm_device *dev, struct drm_buf * buf)\n{\n\tif (!buf)\n\t\treturn;\n\n\tbuf->waiting = 0;\n\tbuf->pending = 0;\n\tbuf->file_priv = NULL;\n\tbuf->used = 0;\n}\n\n \nvoid drm_legacy_reclaim_buffers(struct drm_device *dev,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_device_dma *dma = dev->dma;\n\tint i;\n\n\tif (!dma)\n\t\treturn;\n\tfor (i = 0; i < dma->buf_count; i++) {\n\t\tif (dma->buflist[i]->file_priv == file_priv) {\n\t\t\tswitch (dma->buflist[i]->list) {\n\t\t\tcase DRM_LIST_NONE:\n\t\t\t\tdrm_legacy_free_buffer(dev, dma->buflist[i]);\n\t\t\t\tbreak;\n\t\t\tcase DRM_LIST_WAIT:\n\t\t\t\tdma->buflist[i]->list = DRM_LIST_RECLAIM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}