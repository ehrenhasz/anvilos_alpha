{
  "module_name": "drm_mipi_dsi.c",
  "hash_id": "a9bbc5046f7f68a4046dd6e1815c9f1550f76316035499d471bfa337152b2a53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_mipi_dsi.c",
  "human_readable_source": " \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include <drm/display/drm_dsc.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_print.h>\n\n#include <video/mipi_display.h>\n\n \n\nstatic int mipi_dsi_device_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\n\n\t \n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\t \n\tif (!strcmp(dsi->name, drv->name))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int mipi_dsi_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\n\tint err;\n\n\terr = of_device_uevent_modalias(dev, env);\n\tif (err != -ENODEV)\n\t\treturn err;\n\n\tadd_uevent_var(env, \"MODALIAS=%s%s\", MIPI_DSI_MODULE_PREFIX,\n\t\t       dsi->name);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mipi_dsi_device_pm_ops = {\n\t.runtime_suspend = pm_generic_runtime_suspend,\n\t.runtime_resume = pm_generic_runtime_resume,\n\t.suspend = pm_generic_suspend,\n\t.resume = pm_generic_resume,\n\t.freeze = pm_generic_freeze,\n\t.thaw = pm_generic_thaw,\n\t.poweroff = pm_generic_poweroff,\n\t.restore = pm_generic_restore,\n};\n\nstatic struct bus_type mipi_dsi_bus_type = {\n\t.name = \"mipi-dsi\",\n\t.match = mipi_dsi_device_match,\n\t.uevent = mipi_dsi_uevent,\n\t.pm = &mipi_dsi_device_pm_ops,\n};\n\n \nstruct mipi_dsi_device *of_find_mipi_dsi_device_by_node(struct device_node *np)\n{\n\tstruct device *dev;\n\n\tdev = bus_find_device_by_of_node(&mipi_dsi_bus_type, np);\n\n\treturn dev ? to_mipi_dsi_device(dev) : NULL;\n}\nEXPORT_SYMBOL(of_find_mipi_dsi_device_by_node);\n\nstatic void mipi_dsi_dev_release(struct device *dev)\n{\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\n\n\tof_node_put(dev->of_node);\n\tkfree(dsi);\n}\n\nstatic const struct device_type mipi_dsi_device_type = {\n\t.release = mipi_dsi_dev_release,\n};\n\nstatic struct mipi_dsi_device *mipi_dsi_device_alloc(struct mipi_dsi_host *host)\n{\n\tstruct mipi_dsi_device *dsi;\n\n\tdsi = kzalloc(sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdsi->host = host;\n\tdsi->dev.bus = &mipi_dsi_bus_type;\n\tdsi->dev.parent = host->dev;\n\tdsi->dev.type = &mipi_dsi_device_type;\n\n\tdevice_initialize(&dsi->dev);\n\n\treturn dsi;\n}\n\nstatic int mipi_dsi_device_add(struct mipi_dsi_device *dsi)\n{\n\tstruct mipi_dsi_host *host = dsi->host;\n\n\tdev_set_name(&dsi->dev, \"%s.%d\", dev_name(host->dev),  dsi->channel);\n\n\treturn device_add(&dsi->dev);\n}\n\n#if IS_ENABLED(CONFIG_OF)\nstatic struct mipi_dsi_device *\nof_mipi_dsi_device_add(struct mipi_dsi_host *host, struct device_node *node)\n{\n\tstruct mipi_dsi_device_info info = { };\n\tint ret;\n\tu32 reg;\n\n\tif (of_alias_from_compatible(node, info.type, sizeof(info.type)) < 0) {\n\t\tdrm_err(host, \"modalias failure on %pOF\\n\", node);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tret = of_property_read_u32(node, \"reg\", &reg);\n\tif (ret) {\n\t\tdrm_err(host, \"device node %pOF has no valid reg property: %d\\n\",\n\t\t\tnode, ret);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinfo.channel = reg;\n\tinfo.node = of_node_get(node);\n\n\treturn mipi_dsi_device_register_full(host, &info);\n}\n#else\nstatic struct mipi_dsi_device *\nof_mipi_dsi_device_add(struct mipi_dsi_host *host, struct device_node *node)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n#endif\n\n \nstruct mipi_dsi_device *\nmipi_dsi_device_register_full(struct mipi_dsi_host *host,\n\t\t\t      const struct mipi_dsi_device_info *info)\n{\n\tstruct mipi_dsi_device *dsi;\n\tint ret;\n\n\tif (!info) {\n\t\tdrm_err(host, \"invalid mipi_dsi_device_info pointer\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (info->channel > 3) {\n\t\tdrm_err(host, \"invalid virtual channel: %u\\n\", info->channel);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdsi = mipi_dsi_device_alloc(host);\n\tif (IS_ERR(dsi)) {\n\t\tdrm_err(host, \"failed to allocate DSI device %ld\\n\",\n\t\t\tPTR_ERR(dsi));\n\t\treturn dsi;\n\t}\n\n\tdevice_set_node(&dsi->dev, of_fwnode_handle(info->node));\n\tdsi->channel = info->channel;\n\tstrscpy(dsi->name, info->type, sizeof(dsi->name));\n\n\tret = mipi_dsi_device_add(dsi);\n\tif (ret) {\n\t\tdrm_err(host, \"failed to add DSI device %d\\n\", ret);\n\t\tkfree(dsi);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn dsi;\n}\nEXPORT_SYMBOL(mipi_dsi_device_register_full);\n\n \nvoid mipi_dsi_device_unregister(struct mipi_dsi_device *dsi)\n{\n\tdevice_unregister(&dsi->dev);\n}\nEXPORT_SYMBOL(mipi_dsi_device_unregister);\n\nstatic void devm_mipi_dsi_device_unregister(void *arg)\n{\n\tstruct mipi_dsi_device *dsi = arg;\n\n\tmipi_dsi_device_unregister(dsi);\n}\n\n \nstruct mipi_dsi_device *\ndevm_mipi_dsi_device_register_full(struct device *dev,\n\t\t\t\t   struct mipi_dsi_host *host,\n\t\t\t\t   const struct mipi_dsi_device_info *info)\n{\n\tstruct mipi_dsi_device *dsi;\n\tint ret;\n\n\tdsi = mipi_dsi_device_register_full(host, info);\n\tif (IS_ERR(dsi))\n\t\treturn dsi;\n\n\tret = devm_add_action_or_reset(dev,\n\t\t\t\t       devm_mipi_dsi_device_unregister,\n\t\t\t\t       dsi);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn dsi;\n}\nEXPORT_SYMBOL_GPL(devm_mipi_dsi_device_register_full);\n\nstatic DEFINE_MUTEX(host_lock);\nstatic LIST_HEAD(host_list);\n\n \nstruct mipi_dsi_host *of_find_mipi_dsi_host_by_node(struct device_node *node)\n{\n\tstruct mipi_dsi_host *host;\n\n\tmutex_lock(&host_lock);\n\n\tlist_for_each_entry(host, &host_list, list) {\n\t\tif (host->dev->of_node == node) {\n\t\t\tmutex_unlock(&host_lock);\n\t\t\treturn host;\n\t\t}\n\t}\n\n\tmutex_unlock(&host_lock);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(of_find_mipi_dsi_host_by_node);\n\nint mipi_dsi_host_register(struct mipi_dsi_host *host)\n{\n\tstruct device_node *node;\n\n\tfor_each_available_child_of_node(host->dev->of_node, node) {\n\t\t \n\t\tif (!of_property_present(node, \"reg\"))\n\t\t\tcontinue;\n\t\tof_mipi_dsi_device_add(host, node);\n\t}\n\n\tmutex_lock(&host_lock);\n\tlist_add_tail(&host->list, &host_list);\n\tmutex_unlock(&host_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_host_register);\n\nstatic int mipi_dsi_remove_device_fn(struct device *dev, void *priv)\n{\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\n\n\tmipi_dsi_detach(dsi);\n\tmipi_dsi_device_unregister(dsi);\n\n\treturn 0;\n}\n\nvoid mipi_dsi_host_unregister(struct mipi_dsi_host *host)\n{\n\tdevice_for_each_child(host->dev, NULL, mipi_dsi_remove_device_fn);\n\n\tmutex_lock(&host_lock);\n\tlist_del_init(&host->list);\n\tmutex_unlock(&host_lock);\n}\nEXPORT_SYMBOL(mipi_dsi_host_unregister);\n\n \nint mipi_dsi_attach(struct mipi_dsi_device *dsi)\n{\n\tconst struct mipi_dsi_host_ops *ops = dsi->host->ops;\n\n\tif (!ops || !ops->attach)\n\t\treturn -ENOSYS;\n\n\treturn ops->attach(dsi->host, dsi);\n}\nEXPORT_SYMBOL(mipi_dsi_attach);\n\n \nint mipi_dsi_detach(struct mipi_dsi_device *dsi)\n{\n\tconst struct mipi_dsi_host_ops *ops = dsi->host->ops;\n\n\tif (!ops || !ops->detach)\n\t\treturn -ENOSYS;\n\n\treturn ops->detach(dsi->host, dsi);\n}\nEXPORT_SYMBOL(mipi_dsi_detach);\n\nstatic void devm_mipi_dsi_detach(void *arg)\n{\n\tstruct mipi_dsi_device *dsi = arg;\n\n\tmipi_dsi_detach(dsi);\n}\n\n \nint devm_mipi_dsi_attach(struct device *dev,\n\t\t\t struct mipi_dsi_device *dsi)\n{\n\tint ret;\n\n\tret = mipi_dsi_attach(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, devm_mipi_dsi_detach, dsi);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_mipi_dsi_attach);\n\nstatic ssize_t mipi_dsi_device_transfer(struct mipi_dsi_device *dsi,\n\t\t\t\t\tstruct mipi_dsi_msg *msg)\n{\n\tconst struct mipi_dsi_host_ops *ops = dsi->host->ops;\n\n\tif (!ops || !ops->transfer)\n\t\treturn -ENOSYS;\n\n\tif (dsi->mode_flags & MIPI_DSI_MODE_LPM)\n\t\tmsg->flags |= MIPI_DSI_MSG_USE_LPM;\n\n\treturn ops->transfer(dsi->host, msg);\n}\n\n \nbool mipi_dsi_packet_format_is_short(u8 type)\n{\n\tswitch (type) {\n\tcase MIPI_DSI_V_SYNC_START:\n\tcase MIPI_DSI_V_SYNC_END:\n\tcase MIPI_DSI_H_SYNC_START:\n\tcase MIPI_DSI_H_SYNC_END:\n\tcase MIPI_DSI_COMPRESSION_MODE:\n\tcase MIPI_DSI_END_OF_TRANSMISSION:\n\tcase MIPI_DSI_COLOR_MODE_OFF:\n\tcase MIPI_DSI_COLOR_MODE_ON:\n\tcase MIPI_DSI_SHUTDOWN_PERIPHERAL:\n\tcase MIPI_DSI_TURN_ON_PERIPHERAL:\n\tcase MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:\n\tcase MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:\n\tcase MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:\n\tcase MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:\n\tcase MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:\n\tcase MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:\n\tcase MIPI_DSI_DCS_SHORT_WRITE:\n\tcase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\n\tcase MIPI_DSI_DCS_READ:\n\tcase MIPI_DSI_EXECUTE_QUEUE:\n\tcase MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(mipi_dsi_packet_format_is_short);\n\n \nbool mipi_dsi_packet_format_is_long(u8 type)\n{\n\tswitch (type) {\n\tcase MIPI_DSI_NULL_PACKET:\n\tcase MIPI_DSI_BLANKING_PACKET:\n\tcase MIPI_DSI_GENERIC_LONG_WRITE:\n\tcase MIPI_DSI_DCS_LONG_WRITE:\n\tcase MIPI_DSI_PICTURE_PARAMETER_SET:\n\tcase MIPI_DSI_COMPRESSED_PIXEL_STREAM:\n\tcase MIPI_DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20:\n\tcase MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR24:\n\tcase MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16:\n\tcase MIPI_DSI_PACKED_PIXEL_STREAM_30:\n\tcase MIPI_DSI_PACKED_PIXEL_STREAM_36:\n\tcase MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12:\n\tcase MIPI_DSI_PACKED_PIXEL_STREAM_16:\n\tcase MIPI_DSI_PACKED_PIXEL_STREAM_18:\n\tcase MIPI_DSI_PIXEL_STREAM_3BYTE_18:\n\tcase MIPI_DSI_PACKED_PIXEL_STREAM_24:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(mipi_dsi_packet_format_is_long);\n\n \nint mipi_dsi_create_packet(struct mipi_dsi_packet *packet,\n\t\t\t   const struct mipi_dsi_msg *msg)\n{\n\tif (!packet || !msg)\n\t\treturn -EINVAL;\n\n\t \n\tif (!mipi_dsi_packet_format_is_short(msg->type) &&\n\t    !mipi_dsi_packet_format_is_long(msg->type))\n\t\treturn -EINVAL;\n\n\tif (msg->channel > 3)\n\t\treturn -EINVAL;\n\n\tmemset(packet, 0, sizeof(*packet));\n\tpacket->header[0] = ((msg->channel & 0x3) << 6) | (msg->type & 0x3f);\n\n\t \n\n\t \n\tif (mipi_dsi_packet_format_is_long(msg->type)) {\n\t\tpacket->header[1] = (msg->tx_len >> 0) & 0xff;\n\t\tpacket->header[2] = (msg->tx_len >> 8) & 0xff;\n\n\t\tpacket->payload_length = msg->tx_len;\n\t\tpacket->payload = msg->tx_buf;\n\t} else {\n\t\tconst u8 *tx = msg->tx_buf;\n\n\t\tpacket->header[1] = (msg->tx_len > 0) ? tx[0] : 0;\n\t\tpacket->header[2] = (msg->tx_len > 1) ? tx[1] : 0;\n\t}\n\n\tpacket->size = sizeof(packet->header) + packet->payload_length;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_create_packet);\n\n \nint mipi_dsi_shutdown_peripheral(struct mipi_dsi_device *dsi)\n{\n\tstruct mipi_dsi_msg msg = {\n\t\t.channel = dsi->channel,\n\t\t.type = MIPI_DSI_SHUTDOWN_PERIPHERAL,\n\t\t.tx_buf = (u8 [2]) { 0, 0 },\n\t\t.tx_len = 2,\n\t};\n\tint ret = mipi_dsi_device_transfer(dsi, &msg);\n\n\treturn (ret < 0) ? ret : 0;\n}\nEXPORT_SYMBOL(mipi_dsi_shutdown_peripheral);\n\n \nint mipi_dsi_turn_on_peripheral(struct mipi_dsi_device *dsi)\n{\n\tstruct mipi_dsi_msg msg = {\n\t\t.channel = dsi->channel,\n\t\t.type = MIPI_DSI_TURN_ON_PERIPHERAL,\n\t\t.tx_buf = (u8 [2]) { 0, 0 },\n\t\t.tx_len = 2,\n\t};\n\tint ret = mipi_dsi_device_transfer(dsi, &msg);\n\n\treturn (ret < 0) ? ret : 0;\n}\nEXPORT_SYMBOL(mipi_dsi_turn_on_peripheral);\n\n \nint mipi_dsi_set_maximum_return_packet_size(struct mipi_dsi_device *dsi,\n\t\t\t\t\t    u16 value)\n{\n\tu8 tx[2] = { value & 0xff, value >> 8 };\n\tstruct mipi_dsi_msg msg = {\n\t\t.channel = dsi->channel,\n\t\t.type = MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE,\n\t\t.tx_len = sizeof(tx),\n\t\t.tx_buf = tx,\n\t};\n\tint ret = mipi_dsi_device_transfer(dsi, &msg);\n\n\treturn (ret < 0) ? ret : 0;\n}\nEXPORT_SYMBOL(mipi_dsi_set_maximum_return_packet_size);\n\n \nssize_t mipi_dsi_compression_mode(struct mipi_dsi_device *dsi, bool enable)\n{\n\t \n\tu8 tx[2] = { enable << 0, 0 };\n\tstruct mipi_dsi_msg msg = {\n\t\t.channel = dsi->channel,\n\t\t.type = MIPI_DSI_COMPRESSION_MODE,\n\t\t.tx_len = sizeof(tx),\n\t\t.tx_buf = tx,\n\t};\n\tint ret = mipi_dsi_device_transfer(dsi, &msg);\n\n\treturn (ret < 0) ? ret : 0;\n}\nEXPORT_SYMBOL(mipi_dsi_compression_mode);\n\n \nssize_t mipi_dsi_picture_parameter_set(struct mipi_dsi_device *dsi,\n\t\t\t\t       const struct drm_dsc_picture_parameter_set *pps)\n{\n\tstruct mipi_dsi_msg msg = {\n\t\t.channel = dsi->channel,\n\t\t.type = MIPI_DSI_PICTURE_PARAMETER_SET,\n\t\t.tx_len = sizeof(*pps),\n\t\t.tx_buf = pps,\n\t};\n\tint ret = mipi_dsi_device_transfer(dsi, &msg);\n\n\treturn (ret < 0) ? ret : 0;\n}\nEXPORT_SYMBOL(mipi_dsi_picture_parameter_set);\n\n \nssize_t mipi_dsi_generic_write(struct mipi_dsi_device *dsi, const void *payload,\n\t\t\t       size_t size)\n{\n\tstruct mipi_dsi_msg msg = {\n\t\t.channel = dsi->channel,\n\t\t.tx_buf = payload,\n\t\t.tx_len = size\n\t};\n\n\tswitch (size) {\n\tcase 0:\n\t\tmsg.type = MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM;\n\t\tbreak;\n\n\tcase 1:\n\t\tmsg.type = MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM;\n\t\tbreak;\n\n\tcase 2:\n\t\tmsg.type = MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM;\n\t\tbreak;\n\n\tdefault:\n\t\tmsg.type = MIPI_DSI_GENERIC_LONG_WRITE;\n\t\tbreak;\n\t}\n\n\treturn mipi_dsi_device_transfer(dsi, &msg);\n}\nEXPORT_SYMBOL(mipi_dsi_generic_write);\n\n \nssize_t mipi_dsi_generic_read(struct mipi_dsi_device *dsi, const void *params,\n\t\t\t      size_t num_params, void *data, size_t size)\n{\n\tstruct mipi_dsi_msg msg = {\n\t\t.channel = dsi->channel,\n\t\t.tx_len = num_params,\n\t\t.tx_buf = params,\n\t\t.rx_len = size,\n\t\t.rx_buf = data\n\t};\n\n\tswitch (num_params) {\n\tcase 0:\n\t\tmsg.type = MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM;\n\t\tbreak;\n\n\tcase 1:\n\t\tmsg.type = MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM;\n\t\tbreak;\n\n\tcase 2:\n\t\tmsg.type = MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mipi_dsi_device_transfer(dsi, &msg);\n}\nEXPORT_SYMBOL(mipi_dsi_generic_read);\n\n \nssize_t mipi_dsi_dcs_write_buffer(struct mipi_dsi_device *dsi,\n\t\t\t\t  const void *data, size_t len)\n{\n\tstruct mipi_dsi_msg msg = {\n\t\t.channel = dsi->channel,\n\t\t.tx_buf = data,\n\t\t.tx_len = len\n\t};\n\n\tswitch (len) {\n\tcase 0:\n\t\treturn -EINVAL;\n\n\tcase 1:\n\t\tmsg.type = MIPI_DSI_DCS_SHORT_WRITE;\n\t\tbreak;\n\n\tcase 2:\n\t\tmsg.type = MIPI_DSI_DCS_SHORT_WRITE_PARAM;\n\t\tbreak;\n\n\tdefault:\n\t\tmsg.type = MIPI_DSI_DCS_LONG_WRITE;\n\t\tbreak;\n\t}\n\n\treturn mipi_dsi_device_transfer(dsi, &msg);\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_write_buffer);\n\n \nssize_t mipi_dsi_dcs_write(struct mipi_dsi_device *dsi, u8 cmd,\n\t\t\t   const void *data, size_t len)\n{\n\tssize_t err;\n\tsize_t size;\n\tu8 stack_tx[8];\n\tu8 *tx;\n\n\tsize = 1 + len;\n\tif (len > ARRAY_SIZE(stack_tx) - 1) {\n\t\ttx = kmalloc(size, GFP_KERNEL);\n\t\tif (!tx)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\ttx = stack_tx;\n\t}\n\n\t \n\ttx[0] = cmd;\n\tif (data)\n\t\tmemcpy(&tx[1], data, len);\n\n\terr = mipi_dsi_dcs_write_buffer(dsi, tx, size);\n\n\tif (tx != stack_tx)\n\t\tkfree(tx);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_write);\n\n \nssize_t mipi_dsi_dcs_read(struct mipi_dsi_device *dsi, u8 cmd, void *data,\n\t\t\t  size_t len)\n{\n\tstruct mipi_dsi_msg msg = {\n\t\t.channel = dsi->channel,\n\t\t.type = MIPI_DSI_DCS_READ,\n\t\t.tx_buf = &cmd,\n\t\t.tx_len = 1,\n\t\t.rx_buf = data,\n\t\t.rx_len = len\n\t};\n\n\treturn mipi_dsi_device_transfer(dsi, &msg);\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_read);\n\n \nint mipi_dsi_dcs_nop(struct mipi_dsi_device *dsi)\n{\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_NOP, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_nop);\n\n \nint mipi_dsi_dcs_soft_reset(struct mipi_dsi_device *dsi)\n{\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SOFT_RESET, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_soft_reset);\n\n \nint mipi_dsi_dcs_get_power_mode(struct mipi_dsi_device *dsi, u8 *mode)\n{\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_read(dsi, MIPI_DCS_GET_POWER_MODE, mode,\n\t\t\t\tsizeof(*mode));\n\tif (err <= 0) {\n\t\tif (err == 0)\n\t\t\terr = -ENODATA;\n\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_get_power_mode);\n\n \nint mipi_dsi_dcs_get_pixel_format(struct mipi_dsi_device *dsi, u8 *format)\n{\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_read(dsi, MIPI_DCS_GET_PIXEL_FORMAT, format,\n\t\t\t\tsizeof(*format));\n\tif (err <= 0) {\n\t\tif (err == 0)\n\t\t\terr = -ENODATA;\n\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_get_pixel_format);\n\n \nint mipi_dsi_dcs_enter_sleep_mode(struct mipi_dsi_device *dsi)\n{\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_ENTER_SLEEP_MODE, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_enter_sleep_mode);\n\n \nint mipi_dsi_dcs_exit_sleep_mode(struct mipi_dsi_device *dsi)\n{\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_EXIT_SLEEP_MODE, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_exit_sleep_mode);\n\n \nint mipi_dsi_dcs_set_display_off(struct mipi_dsi_device *dsi)\n{\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_DISPLAY_OFF, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_set_display_off);\n\n \nint mipi_dsi_dcs_set_display_on(struct mipi_dsi_device *dsi)\n{\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_DISPLAY_ON, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_set_display_on);\n\n \nint mipi_dsi_dcs_set_column_address(struct mipi_dsi_device *dsi, u16 start,\n\t\t\t\t    u16 end)\n{\n\tu8 payload[4] = { start >> 8, start & 0xff, end >> 8, end & 0xff };\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_COLUMN_ADDRESS, payload,\n\t\t\t\t sizeof(payload));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_set_column_address);\n\n \nint mipi_dsi_dcs_set_page_address(struct mipi_dsi_device *dsi, u16 start,\n\t\t\t\t  u16 end)\n{\n\tu8 payload[4] = { start >> 8, start & 0xff, end >> 8, end & 0xff };\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_PAGE_ADDRESS, payload,\n\t\t\t\t sizeof(payload));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_set_page_address);\n\n \nint mipi_dsi_dcs_set_tear_off(struct mipi_dsi_device *dsi)\n{\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_TEAR_OFF, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_set_tear_off);\n\n \nint mipi_dsi_dcs_set_tear_on(struct mipi_dsi_device *dsi,\n\t\t\t     enum mipi_dsi_dcs_tear_mode mode)\n{\n\tu8 value = mode;\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_TEAR_ON, &value,\n\t\t\t\t sizeof(value));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_set_tear_on);\n\n \nint mipi_dsi_dcs_set_pixel_format(struct mipi_dsi_device *dsi, u8 format)\n{\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_PIXEL_FORMAT, &format,\n\t\t\t\t sizeof(format));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_set_pixel_format);\n\n \nint mipi_dsi_dcs_set_tear_scanline(struct mipi_dsi_device *dsi, u16 scanline)\n{\n\tu8 payload[2] = { scanline >> 8, scanline & 0xff };\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_TEAR_SCANLINE, payload,\n\t\t\t\t sizeof(payload));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_set_tear_scanline);\n\n \nint mipi_dsi_dcs_set_display_brightness(struct mipi_dsi_device *dsi,\n\t\t\t\t\tu16 brightness)\n{\n\tu8 payload[2] = { brightness & 0xff, brightness >> 8 };\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_DISPLAY_BRIGHTNESS,\n\t\t\t\t payload, sizeof(payload));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_set_display_brightness);\n\n \nint mipi_dsi_dcs_get_display_brightness(struct mipi_dsi_device *dsi,\n\t\t\t\t\tu16 *brightness)\n{\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_read(dsi, MIPI_DCS_GET_DISPLAY_BRIGHTNESS,\n\t\t\t\tbrightness, sizeof(*brightness));\n\tif (err <= 0) {\n\t\tif (err == 0)\n\t\t\terr = -ENODATA;\n\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_get_display_brightness);\n\n \nint mipi_dsi_dcs_set_display_brightness_large(struct mipi_dsi_device *dsi,\n\t\t\t\t\t     u16 brightness)\n{\n\tu8 payload[2] = { brightness >> 8, brightness & 0xff };\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_DISPLAY_BRIGHTNESS,\n\t\t\t\t payload, sizeof(payload));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_set_display_brightness_large);\n\n \nint mipi_dsi_dcs_get_display_brightness_large(struct mipi_dsi_device *dsi,\n\t\t\t\t\t     u16 *brightness)\n{\n\tu8 brightness_be[2];\n\tssize_t err;\n\n\terr = mipi_dsi_dcs_read(dsi, MIPI_DCS_GET_DISPLAY_BRIGHTNESS,\n\t\t\t\tbrightness_be, sizeof(brightness_be));\n\tif (err <= 0) {\n\t\tif (err == 0)\n\t\t\terr = -ENODATA;\n\n\t\treturn err;\n\t}\n\n\t*brightness = (brightness_be[0] << 8) | brightness_be[1];\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mipi_dsi_dcs_get_display_brightness_large);\n\nstatic int mipi_dsi_drv_probe(struct device *dev)\n{\n\tstruct mipi_dsi_driver *drv = to_mipi_dsi_driver(dev->driver);\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\n\n\treturn drv->probe(dsi);\n}\n\nstatic int mipi_dsi_drv_remove(struct device *dev)\n{\n\tstruct mipi_dsi_driver *drv = to_mipi_dsi_driver(dev->driver);\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\n\n\tdrv->remove(dsi);\n\n\treturn 0;\n}\n\nstatic void mipi_dsi_drv_shutdown(struct device *dev)\n{\n\tstruct mipi_dsi_driver *drv = to_mipi_dsi_driver(dev->driver);\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\n\n\tdrv->shutdown(dsi);\n}\n\n \nint mipi_dsi_driver_register_full(struct mipi_dsi_driver *drv,\n\t\t\t\t  struct module *owner)\n{\n\tdrv->driver.bus = &mipi_dsi_bus_type;\n\tdrv->driver.owner = owner;\n\n\tif (drv->probe)\n\t\tdrv->driver.probe = mipi_dsi_drv_probe;\n\tif (drv->remove)\n\t\tdrv->driver.remove = mipi_dsi_drv_remove;\n\tif (drv->shutdown)\n\t\tdrv->driver.shutdown = mipi_dsi_drv_shutdown;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL(mipi_dsi_driver_register_full);\n\n \nvoid mipi_dsi_driver_unregister(struct mipi_dsi_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL(mipi_dsi_driver_unregister);\n\nstatic int __init mipi_dsi_bus_init(void)\n{\n\treturn bus_register(&mipi_dsi_bus_type);\n}\npostcore_initcall(mipi_dsi_bus_init);\n\nMODULE_AUTHOR(\"Andrzej Hajda <a.hajda@samsung.com>\");\nMODULE_DESCRIPTION(\"MIPI DSI Bus\");\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}