{
  "module_name": "drm_modeset_lock.c",
  "hash_id": "57f27855567fa333f3f74e9e6d1f913b9c9bc7a406dbad2ff9f8da1f662efa8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_modeset_lock.c",
  "human_readable_source": " \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_modeset_lock.h>\n#include <drm/drm_print.h>\n\n \n\nstatic DEFINE_WW_CLASS(crtc_ww_class);\n\n#if IS_ENABLED(CONFIG_DRM_DEBUG_MODESET_LOCK)\nstatic noinline depot_stack_handle_t __drm_stack_depot_save(void)\n{\n\tunsigned long entries[8];\n\tunsigned int n;\n\n\tn = stack_trace_save(entries, ARRAY_SIZE(entries), 1);\n\n\treturn stack_depot_save(entries, n, GFP_NOWAIT | __GFP_NOWARN);\n}\n\nstatic void __drm_stack_depot_print(depot_stack_handle_t stack_depot)\n{\n\tstruct drm_printer p = drm_debug_printer(\"drm_modeset_lock\");\n\tunsigned long *entries;\n\tunsigned int nr_entries;\n\tchar *buf;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_NOWAIT | __GFP_NOWARN);\n\tif (!buf)\n\t\treturn;\n\n\tnr_entries = stack_depot_fetch(stack_depot, &entries);\n\tstack_trace_snprint(buf, PAGE_SIZE, entries, nr_entries, 2);\n\n\tdrm_printf(&p, \"attempting to lock a contended lock without backoff:\\n%s\", buf);\n\n\tkfree(buf);\n}\n\nstatic void __drm_stack_depot_init(void)\n{\n\tstack_depot_init();\n}\n#else  \nstatic depot_stack_handle_t __drm_stack_depot_save(void)\n{\n\treturn 0;\n}\nstatic void __drm_stack_depot_print(depot_stack_handle_t stack_depot)\n{\n}\nstatic void __drm_stack_depot_init(void)\n{\n}\n#endif  \n\n \nvoid drm_modeset_lock_all(struct drm_device *dev)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_modeset_acquire_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL | __GFP_NOFAIL);\n\tif (WARN_ON(!ctx))\n\t\treturn;\n\n\tmutex_lock(&config->mutex);\n\n\tdrm_modeset_acquire_init(ctx, 0);\n\nretry:\n\tret = drm_modeset_lock_all_ctx(dev, ctx);\n\tif (ret < 0) {\n\t\tif (ret == -EDEADLK) {\n\t\t\tdrm_modeset_backoff(ctx);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tdrm_modeset_acquire_fini(ctx);\n\t\tkfree(ctx);\n\t\treturn;\n\t}\n\tww_acquire_done(&ctx->ww_ctx);\n\n\tWARN_ON(config->acquire_ctx);\n\n\t \n\tconfig->acquire_ctx = ctx;\n\n\tdrm_warn_on_modeset_not_all_locked(dev);\n}\nEXPORT_SYMBOL(drm_modeset_lock_all);\n\n \nvoid drm_modeset_unlock_all(struct drm_device *dev)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_modeset_acquire_ctx *ctx = config->acquire_ctx;\n\n\tif (WARN_ON(!ctx))\n\t\treturn;\n\n\tconfig->acquire_ctx = NULL;\n\tdrm_modeset_drop_locks(ctx);\n\tdrm_modeset_acquire_fini(ctx);\n\n\tkfree(ctx);\n\n\tmutex_unlock(&dev->mode_config.mutex);\n}\nEXPORT_SYMBOL(drm_modeset_unlock_all);\n\n \nvoid drm_warn_on_modeset_not_all_locked(struct drm_device *dev)\n{\n\tstruct drm_crtc *crtc;\n\n\t \n\tif (oops_in_progress)\n\t\treturn;\n\n\tdrm_for_each_crtc(crtc, dev)\n\t\tWARN_ON(!drm_modeset_is_locked(&crtc->mutex));\n\n\tWARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));\n\tWARN_ON(!mutex_is_locked(&dev->mode_config.mutex));\n}\nEXPORT_SYMBOL(drm_warn_on_modeset_not_all_locked);\n\n \nvoid drm_modeset_acquire_init(struct drm_modeset_acquire_ctx *ctx,\n\t\tuint32_t flags)\n{\n\tmemset(ctx, 0, sizeof(*ctx));\n\tww_acquire_init(&ctx->ww_ctx, &crtc_ww_class);\n\tINIT_LIST_HEAD(&ctx->locked);\n\n\tif (flags & DRM_MODESET_ACQUIRE_INTERRUPTIBLE)\n\t\tctx->interruptible = true;\n}\nEXPORT_SYMBOL(drm_modeset_acquire_init);\n\n \nvoid drm_modeset_acquire_fini(struct drm_modeset_acquire_ctx *ctx)\n{\n\tww_acquire_fini(&ctx->ww_ctx);\n}\nEXPORT_SYMBOL(drm_modeset_acquire_fini);\n\n \nvoid drm_modeset_drop_locks(struct drm_modeset_acquire_ctx *ctx)\n{\n\tif (WARN_ON(ctx->contended))\n\t\t__drm_stack_depot_print(ctx->stack_depot);\n\n\twhile (!list_empty(&ctx->locked)) {\n\t\tstruct drm_modeset_lock *lock;\n\n\t\tlock = list_first_entry(&ctx->locked,\n\t\t\t\tstruct drm_modeset_lock, head);\n\n\t\tdrm_modeset_unlock(lock);\n\t}\n}\nEXPORT_SYMBOL(drm_modeset_drop_locks);\n\nstatic inline int modeset_lock(struct drm_modeset_lock *lock,\n\t\tstruct drm_modeset_acquire_ctx *ctx,\n\t\tbool interruptible, bool slow)\n{\n\tint ret;\n\n\tif (WARN_ON(ctx->contended))\n\t\t__drm_stack_depot_print(ctx->stack_depot);\n\n\tif (ctx->trylock_only) {\n\t\tlockdep_assert_held(&ctx->ww_ctx);\n\n\t\tif (!ww_mutex_trylock(&lock->mutex, NULL))\n\t\t\treturn -EBUSY;\n\t\telse\n\t\t\treturn 0;\n\t} else if (interruptible && slow) {\n\t\tret = ww_mutex_lock_slow_interruptible(&lock->mutex, &ctx->ww_ctx);\n\t} else if (interruptible) {\n\t\tret = ww_mutex_lock_interruptible(&lock->mutex, &ctx->ww_ctx);\n\t} else if (slow) {\n\t\tww_mutex_lock_slow(&lock->mutex, &ctx->ww_ctx);\n\t\tret = 0;\n\t} else {\n\t\tret = ww_mutex_lock(&lock->mutex, &ctx->ww_ctx);\n\t}\n\tif (!ret) {\n\t\tWARN_ON(!list_empty(&lock->head));\n\t\tlist_add(&lock->head, &ctx->locked);\n\t} else if (ret == -EALREADY) {\n\t\t \n\t\tret = 0;\n\t} else if (ret == -EDEADLK) {\n\t\tctx->contended = lock;\n\t\tctx->stack_depot = __drm_stack_depot_save();\n\t}\n\n\treturn ret;\n}\n\n \nint drm_modeset_backoff(struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_modeset_lock *contended = ctx->contended;\n\n\tctx->contended = NULL;\n\tctx->stack_depot = 0;\n\n\tif (WARN_ON(!contended))\n\t\treturn 0;\n\n\tdrm_modeset_drop_locks(ctx);\n\n\treturn modeset_lock(contended, ctx, ctx->interruptible, true);\n}\nEXPORT_SYMBOL(drm_modeset_backoff);\n\n \nvoid drm_modeset_lock_init(struct drm_modeset_lock *lock)\n{\n\tww_mutex_init(&lock->mutex, &crtc_ww_class);\n\tINIT_LIST_HEAD(&lock->head);\n\t__drm_stack_depot_init();\n}\nEXPORT_SYMBOL(drm_modeset_lock_init);\n\n \nint drm_modeset_lock(struct drm_modeset_lock *lock,\n\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tif (ctx)\n\t\treturn modeset_lock(lock, ctx, ctx->interruptible, false);\n\n\tww_mutex_lock(&lock->mutex, NULL);\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_modeset_lock);\n\n \nint drm_modeset_lock_single_interruptible(struct drm_modeset_lock *lock)\n{\n\treturn ww_mutex_lock_interruptible(&lock->mutex, NULL);\n}\nEXPORT_SYMBOL(drm_modeset_lock_single_interruptible);\n\n \nvoid drm_modeset_unlock(struct drm_modeset_lock *lock)\n{\n\tlist_del_init(&lock->head);\n\tww_mutex_unlock(&lock->mutex);\n}\nEXPORT_SYMBOL(drm_modeset_unlock);\n\n \nint drm_modeset_lock_all_ctx(struct drm_device *dev,\n\t\t\t     struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_private_obj *privobj;\n\tstruct drm_crtc *crtc;\n\tstruct drm_plane *plane;\n\tint ret;\n\n\tret = drm_modeset_lock(&dev->mode_config.connection_mutex, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tret = drm_modeset_lock(&crtc->mutex, ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdrm_for_each_plane(plane, dev) {\n\t\tret = drm_modeset_lock(&plane->mutex, ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdrm_for_each_privobj(privobj, dev) {\n\t\tret = drm_modeset_lock(&privobj->lock, ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_modeset_lock_all_ctx);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}