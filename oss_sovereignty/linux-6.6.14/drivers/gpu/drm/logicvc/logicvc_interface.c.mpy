{
  "module_name": "logicvc_interface.c",
  "hash_id": "31dd47245f447e935d1faca8bd4eefca2dcf4dfb0727698e14d1d8909795f1b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/logicvc/logicvc_interface.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"logicvc_crtc.h\"\n#include \"logicvc_drm.h\"\n#include \"logicvc_interface.h\"\n#include \"logicvc_regs.h\"\n\n#define logicvc_interface_from_drm_encoder(c) \\\n\tcontainer_of(c, struct logicvc_interface, drm_encoder)\n#define logicvc_interface_from_drm_connector(c) \\\n\tcontainer_of(c, struct logicvc_interface, drm_connector)\n\nstatic void logicvc_encoder_enable(struct drm_encoder *drm_encoder)\n{\n\tstruct logicvc_drm *logicvc = logicvc_drm(drm_encoder->dev);\n\tstruct logicvc_interface *interface =\n\t\tlogicvc_interface_from_drm_encoder(drm_encoder);\n\n\tregmap_update_bits(logicvc->regmap, LOGICVC_POWER_CTRL_REG,\n\t\t\t   LOGICVC_POWER_CTRL_VIDEO_ENABLE,\n\t\t\t   LOGICVC_POWER_CTRL_VIDEO_ENABLE);\n\n\tif (interface->drm_panel) {\n\t\tdrm_panel_prepare(interface->drm_panel);\n\t\tdrm_panel_enable(interface->drm_panel);\n\t}\n}\n\nstatic void logicvc_encoder_disable(struct drm_encoder *drm_encoder)\n{\n\tstruct logicvc_interface *interface =\n\t\tlogicvc_interface_from_drm_encoder(drm_encoder);\n\n\tif (interface->drm_panel) {\n\t\tdrm_panel_disable(interface->drm_panel);\n\t\tdrm_panel_unprepare(interface->drm_panel);\n\t}\n}\n\nstatic const struct drm_encoder_helper_funcs logicvc_encoder_helper_funcs = {\n\t.enable\t\t\t= logicvc_encoder_enable,\n\t.disable\t\t= logicvc_encoder_disable,\n};\n\nstatic const struct drm_encoder_funcs logicvc_encoder_funcs = {\n\t.destroy\t\t= drm_encoder_cleanup,\n};\n\nstatic int logicvc_connector_get_modes(struct drm_connector *drm_connector)\n{\n\tstruct logicvc_interface *interface =\n\t\tlogicvc_interface_from_drm_connector(drm_connector);\n\n\tif (interface->drm_panel)\n\t\treturn drm_panel_get_modes(interface->drm_panel, drm_connector);\n\n\tWARN_ONCE(1, \"Retrieving modes from a native connector is not implemented.\");\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_helper_funcs logicvc_connector_helper_funcs = {\n\t.get_modes\t\t= logicvc_connector_get_modes,\n};\n\nstatic const struct drm_connector_funcs logicvc_connector_funcs = {\n\t.reset\t\t\t= drm_atomic_helper_connector_reset,\n\t.fill_modes\t\t= drm_helper_probe_single_connector_modes,\n\t.destroy\t\t= drm_connector_cleanup,\n\t.atomic_duplicate_state\t= drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int logicvc_interface_encoder_type(struct logicvc_drm *logicvc)\n{\n\tswitch (logicvc->config.display_interface) {\n\tcase LOGICVC_DISPLAY_INTERFACE_LVDS_4BITS:\n\tcase LOGICVC_DISPLAY_INTERFACE_LVDS_4BITS_CAMERA:\n\tcase LOGICVC_DISPLAY_INTERFACE_LVDS_3BITS:\n\t\treturn DRM_MODE_ENCODER_LVDS;\n\tcase LOGICVC_DISPLAY_INTERFACE_DVI:\n\t\treturn DRM_MODE_ENCODER_TMDS;\n\tcase LOGICVC_DISPLAY_INTERFACE_RGB:\n\t\treturn DRM_MODE_ENCODER_DPI;\n\tdefault:\n\t\treturn DRM_MODE_ENCODER_NONE;\n\t}\n}\n\nstatic int logicvc_interface_connector_type(struct logicvc_drm *logicvc)\n{\n\tswitch (logicvc->config.display_interface) {\n\tcase LOGICVC_DISPLAY_INTERFACE_LVDS_4BITS:\n\tcase LOGICVC_DISPLAY_INTERFACE_LVDS_4BITS_CAMERA:\n\tcase LOGICVC_DISPLAY_INTERFACE_LVDS_3BITS:\n\t\treturn DRM_MODE_CONNECTOR_LVDS;\n\tcase LOGICVC_DISPLAY_INTERFACE_DVI:\n\t\treturn DRM_MODE_CONNECTOR_DVID;\n\tcase LOGICVC_DISPLAY_INTERFACE_RGB:\n\t\treturn DRM_MODE_CONNECTOR_DPI;\n\tdefault:\n\t\treturn DRM_MODE_CONNECTOR_Unknown;\n\t}\n}\n\nstatic bool logicvc_interface_native_connector(struct logicvc_drm *logicvc)\n{\n\tswitch (logicvc->config.display_interface) {\n\tcase LOGICVC_DISPLAY_INTERFACE_DVI:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nvoid logicvc_interface_attach_crtc(struct logicvc_drm *logicvc)\n{\n\tuint32_t possible_crtcs = drm_crtc_mask(&logicvc->crtc->drm_crtc);\n\n\tlogicvc->interface->drm_encoder.possible_crtcs = possible_crtcs;\n}\n\nint logicvc_interface_init(struct logicvc_drm *logicvc)\n{\n\tstruct logicvc_interface *interface;\n\tstruct drm_device *drm_dev = &logicvc->drm_dev;\n\tstruct device *dev = drm_dev->dev;\n\tstruct device_node *of_node = dev->of_node;\n\tint encoder_type = logicvc_interface_encoder_type(logicvc);\n\tint connector_type = logicvc_interface_connector_type(logicvc);\n\tbool native_connector = logicvc_interface_native_connector(logicvc);\n\tint ret;\n\n\tinterface = devm_kzalloc(dev, sizeof(*interface), GFP_KERNEL);\n\tif (!interface) {\n\t\tret = -ENOMEM;\n\t\tgoto error_early;\n\t}\n\n\tret = drm_of_find_panel_or_bridge(of_node, 0, 0, &interface->drm_panel,\n\t\t\t\t\t  &interface->drm_bridge);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto error_early;\n\n\tret = drm_encoder_init(drm_dev, &interface->drm_encoder,\n\t\t\t       &logicvc_encoder_funcs, encoder_type, NULL);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Failed to initialize encoder\\n\");\n\t\tgoto error_early;\n\t}\n\n\tdrm_encoder_helper_add(&interface->drm_encoder,\n\t\t\t       &logicvc_encoder_helper_funcs);\n\n\tif (native_connector || interface->drm_panel) {\n\t\tret = drm_connector_init(drm_dev, &interface->drm_connector,\n\t\t\t\t\t &logicvc_connector_funcs,\n\t\t\t\t\t connector_type);\n\t\tif (ret) {\n\t\t\tdrm_err(drm_dev, \"Failed to initialize connector\\n\");\n\t\t\tgoto error_encoder;\n\t\t}\n\n\t\tdrm_connector_helper_add(&interface->drm_connector,\n\t\t\t\t\t &logicvc_connector_helper_funcs);\n\n\t\tret = drm_connector_attach_encoder(&interface->drm_connector,\n\t\t\t\t\t\t   &interface->drm_encoder);\n\t\tif (ret) {\n\t\t\tdrm_err(drm_dev,\n\t\t\t\t\"Failed to attach connector to encoder\\n\");\n\t\t\tgoto error_encoder;\n\t\t}\n\t}\n\n\tif (interface->drm_bridge) {\n\t\tret = drm_bridge_attach(&interface->drm_encoder,\n\t\t\t\t\tinterface->drm_bridge, NULL, 0);\n\t\tif (ret) {\n\t\t\tdrm_err(drm_dev,\n\t\t\t\t\"Failed to attach bridge to encoder\\n\");\n\t\t\tgoto error_encoder;\n\t\t}\n\t}\n\n\tlogicvc->interface = interface;\n\n\treturn 0;\n\nerror_encoder:\n\tdrm_encoder_cleanup(&interface->drm_encoder);\n\nerror_early:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}