{
  "module_name": "logicvc_crtc.c",
  "hash_id": "558731f74475baf5c4ad371e688bce8342d3b229b991a7bb181225e1a31ebfee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/logicvc/logicvc_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n\n#include \"logicvc_crtc.h\"\n#include \"logicvc_drm.h\"\n#include \"logicvc_interface.h\"\n#include \"logicvc_layer.h\"\n#include \"logicvc_regs.h\"\n\n#define logicvc_crtc(c) \\\n\tcontainer_of(c, struct logicvc_crtc, drm_crtc)\n\nstatic enum drm_mode_status\nlogicvc_crtc_mode_valid(struct drm_crtc *drm_crtc,\n\t\t\tconst struct drm_display_mode *mode)\n{\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void logicvc_crtc_atomic_begin(struct drm_crtc *drm_crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct logicvc_crtc *crtc = logicvc_crtc(drm_crtc);\n\tstruct drm_crtc_state *old_state =\n\t\tdrm_atomic_get_old_crtc_state(state, drm_crtc);\n\tstruct drm_device *drm_dev = drm_crtc->dev;\n\tunsigned long flags;\n\n\t \n\tif (drm_crtc->state->event && old_state->active) {\n\t\tspin_lock_irqsave(&drm_dev->event_lock, flags);\n\t\tWARN_ON(drm_crtc_vblank_get(drm_crtc) != 0);\n\n\t\tcrtc->event = drm_crtc->state->event;\n\t\tdrm_crtc->state->event = NULL;\n\n\t\tspin_unlock_irqrestore(&drm_dev->event_lock, flags);\n\t}\n}\n\nstatic void logicvc_crtc_atomic_enable(struct drm_crtc *drm_crtc,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct logicvc_crtc *crtc = logicvc_crtc(drm_crtc);\n\tstruct logicvc_drm *logicvc = logicvc_drm(drm_crtc->dev);\n\tstruct drm_crtc_state *old_state =\n\t\tdrm_atomic_get_old_crtc_state(state, drm_crtc);\n\tstruct drm_crtc_state *new_state =\n\t\tdrm_atomic_get_new_crtc_state(state, drm_crtc);\n\tstruct drm_display_mode *mode = &new_state->adjusted_mode;\n\n\tstruct drm_device *drm_dev = drm_crtc->dev;\n\tunsigned int hact, hfp, hsl, hbp;\n\tunsigned int vact, vfp, vsl, vbp;\n\tunsigned long flags;\n\tu32 ctrl;\n\n\t \n\n\thact = mode->hdisplay;\n\thfp = mode->hsync_start - mode->hdisplay;\n\thsl = mode->hsync_end - mode->hsync_start;\n\thbp = mode->htotal - mode->hsync_end;\n\n\tvact = mode->vdisplay;\n\tvfp = mode->vsync_start - mode->vdisplay;\n\tvsl = mode->vsync_end - mode->vsync_start;\n\tvbp = mode->vtotal - mode->vsync_end;\n\n\tregmap_write(logicvc->regmap, LOGICVC_HSYNC_FRONT_PORCH_REG, hfp - 1);\n\tregmap_write(logicvc->regmap, LOGICVC_HSYNC_REG, hsl - 1);\n\tregmap_write(logicvc->regmap, LOGICVC_HSYNC_BACK_PORCH_REG, hbp - 1);\n\tregmap_write(logicvc->regmap, LOGICVC_HRES_REG, hact - 1);\n\n\tregmap_write(logicvc->regmap, LOGICVC_VSYNC_FRONT_PORCH_REG, vfp - 1);\n\tregmap_write(logicvc->regmap, LOGICVC_VSYNC_REG, vsl - 1);\n\tregmap_write(logicvc->regmap, LOGICVC_VSYNC_BACK_PORCH_REG, vbp - 1);\n\tregmap_write(logicvc->regmap, LOGICVC_VRES_REG, vact - 1);\n\n\t \n\n\tctrl = LOGICVC_CTRL_HSYNC_ENABLE | LOGICVC_CTRL_VSYNC_ENABLE |\n\t       LOGICVC_CTRL_DE_ENABLE;\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tctrl |= LOGICVC_CTRL_HSYNC_INVERT;\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tctrl |= LOGICVC_CTRL_VSYNC_INVERT;\n\n\tif (logicvc->interface) {\n\t\tstruct drm_connector *connector =\n\t\t\t&logicvc->interface->drm_connector;\n\t\tstruct drm_display_info *display_info =\n\t\t\t&connector->display_info;\n\n\t\tif (display_info->bus_flags & DRM_BUS_FLAG_DE_LOW)\n\t\t\tctrl |= LOGICVC_CTRL_DE_INVERT;\n\n\t\tif (display_info->bus_flags &\n\t\t    DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\t\tctrl |= LOGICVC_CTRL_CLOCK_INVERT;\n\t}\n\n\tregmap_update_bits(logicvc->regmap, LOGICVC_CTRL_REG,\n\t\t\t   LOGICVC_CTRL_HSYNC_ENABLE |\n\t\t\t   LOGICVC_CTRL_HSYNC_INVERT |\n\t\t\t   LOGICVC_CTRL_VSYNC_ENABLE |\n\t\t\t   LOGICVC_CTRL_VSYNC_INVERT |\n\t\t\t   LOGICVC_CTRL_DE_ENABLE |\n\t\t\t   LOGICVC_CTRL_DE_INVERT |\n\t\t\t   LOGICVC_CTRL_PIXEL_INVERT |\n\t\t\t   LOGICVC_CTRL_CLOCK_INVERT, ctrl);\n\n\t \n\tregmap_write(logicvc->regmap, LOGICVC_DTYPE_REG, 0);\n\n\tdrm_crtc_vblank_on(drm_crtc);\n\n\t \n\tif (drm_crtc->state->event && !old_state->active) {\n\t\tspin_lock_irqsave(&drm_dev->event_lock, flags);\n\t\tWARN_ON(drm_crtc_vblank_get(drm_crtc) != 0);\n\n\t\tcrtc->event = drm_crtc->state->event;\n\t\tdrm_crtc->state->event = NULL;\n\t\tspin_unlock_irqrestore(&drm_dev->event_lock, flags);\n\t}\n}\n\nstatic void logicvc_crtc_atomic_disable(struct drm_crtc *drm_crtc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct logicvc_drm *logicvc = logicvc_drm(drm_crtc->dev);\n\tstruct drm_device *drm_dev = drm_crtc->dev;\n\n\tdrm_crtc_vblank_off(drm_crtc);\n\n\t \n\tregmap_update_bits(logicvc->regmap, LOGICVC_CTRL_REG,\n\t\t\t   LOGICVC_CTRL_HSYNC_ENABLE |\n\t\t\t   LOGICVC_CTRL_HSYNC_INVERT |\n\t\t\t   LOGICVC_CTRL_VSYNC_ENABLE |\n\t\t\t   LOGICVC_CTRL_VSYNC_INVERT |\n\t\t\t   LOGICVC_CTRL_DE_ENABLE |\n\t\t\t   LOGICVC_CTRL_DE_INVERT |\n\t\t\t   LOGICVC_CTRL_PIXEL_INVERT |\n\t\t\t   LOGICVC_CTRL_CLOCK_INVERT, 0);\n\n\t \n\tregmap_write(logicvc->regmap, LOGICVC_DTYPE_REG, 0);\n\n\t \n\tif (drm_crtc->state->event && !drm_crtc->state->active) {\n\t\tspin_lock_irq(&drm_dev->event_lock);\n\n\t\tdrm_crtc_send_vblank_event(drm_crtc, drm_crtc->state->event);\n\t\tdrm_crtc->state->event = NULL;\n\t\tspin_unlock_irq(&drm_dev->event_lock);\n\t}\n}\n\nstatic const struct drm_crtc_helper_funcs logicvc_crtc_helper_funcs = {\n\t.mode_valid\t\t= logicvc_crtc_mode_valid,\n\t.atomic_begin\t\t= logicvc_crtc_atomic_begin,\n\t.atomic_enable\t\t= logicvc_crtc_atomic_enable,\n\t.atomic_disable\t\t= logicvc_crtc_atomic_disable,\n};\n\nstatic int logicvc_crtc_enable_vblank(struct drm_crtc *drm_crtc)\n{\n\tstruct logicvc_drm *logicvc = logicvc_drm(drm_crtc->dev);\n\n\t \n\tregmap_write_bits(logicvc->regmap, LOGICVC_INT_STAT_REG,\n\t\t\t  LOGICVC_INT_STAT_V_SYNC, LOGICVC_INT_STAT_V_SYNC);\n\n\t \n\tregmap_write_bits(logicvc->regmap, LOGICVC_INT_MASK_REG,\n\t\t\t  LOGICVC_INT_MASK_V_SYNC, 0);\n\n\treturn 0;\n}\n\nstatic void logicvc_crtc_disable_vblank(struct drm_crtc *drm_crtc)\n{\n\tstruct logicvc_drm *logicvc = logicvc_drm(drm_crtc->dev);\n\n\t \n\tregmap_write_bits(logicvc->regmap, LOGICVC_INT_MASK_REG,\n\t\t\t  LOGICVC_INT_MASK_V_SYNC, LOGICVC_INT_MASK_V_SYNC);\n}\n\nstatic const struct drm_crtc_funcs logicvc_crtc_funcs = {\n\t.reset\t\t\t= drm_atomic_helper_crtc_reset,\n\t.destroy\t\t= drm_crtc_cleanup,\n\t.set_config\t\t= drm_atomic_helper_set_config,\n\t.page_flip\t\t= drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state\t= drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank\t\t= logicvc_crtc_enable_vblank,\n\t.disable_vblank\t\t= logicvc_crtc_disable_vblank,\n};\n\nvoid logicvc_crtc_vblank_handler(struct logicvc_drm *logicvc)\n{\n\tstruct drm_device *drm_dev = &logicvc->drm_dev;\n\tstruct logicvc_crtc *crtc = logicvc->crtc;\n\tunsigned long flags;\n\n\tif (!crtc)\n\t\treturn;\n\n\tdrm_crtc_handle_vblank(&crtc->drm_crtc);\n\n\tif (crtc->event) {\n\t\tspin_lock_irqsave(&drm_dev->event_lock, flags);\n\t\tdrm_crtc_send_vblank_event(&crtc->drm_crtc, crtc->event);\n\t\tdrm_crtc_vblank_put(&crtc->drm_crtc);\n\t\tcrtc->event = NULL;\n\t\tspin_unlock_irqrestore(&drm_dev->event_lock, flags);\n\t}\n}\n\nint logicvc_crtc_init(struct logicvc_drm *logicvc)\n{\n\tstruct drm_device *drm_dev = &logicvc->drm_dev;\n\tstruct device *dev = drm_dev->dev;\n\tstruct device_node *of_node = dev->of_node;\n\tstruct logicvc_crtc *crtc;\n\tstruct logicvc_layer *layer_primary;\n\tint ret;\n\n\tcrtc = devm_kzalloc(dev, sizeof(*crtc), GFP_KERNEL);\n\tif (!crtc)\n\t\treturn -ENOMEM;\n\n\tlayer_primary = logicvc_layer_get_primary(logicvc);\n\tif (!layer_primary) {\n\t\tdrm_err(drm_dev, \"Failed to get primary layer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = drm_crtc_init_with_planes(drm_dev, &crtc->drm_crtc,\n\t\t\t\t\t&layer_primary->drm_plane, NULL,\n\t\t\t\t\t&logicvc_crtc_funcs, NULL);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Failed to initialize CRTC\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_helper_add(&crtc->drm_crtc, &logicvc_crtc_helper_funcs);\n\n\tcrtc->drm_crtc.port = of_graph_get_port_by_id(of_node, 1);\n\n\tlogicvc->crtc = crtc;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}