{
  "module_name": "logicvc_layer.c",
  "hash_id": "597ce77df82c549b36bda9e70d0489daf43a0a9ab09eb956e991bfeee9f8698b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/logicvc/logicvc_layer.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/types.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_plane.h>\n#include <drm/drm_print.h>\n\n#include \"logicvc_crtc.h\"\n#include \"logicvc_drm.h\"\n#include \"logicvc_layer.h\"\n#include \"logicvc_of.h\"\n#include \"logicvc_regs.h\"\n\n#define logicvc_layer(p) \\\n\tcontainer_of(p, struct logicvc_layer, drm_plane)\n\nstatic uint32_t logicvc_layer_formats_rgb16[] = {\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_INVALID,\n};\n\nstatic uint32_t logicvc_layer_formats_rgb24[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_INVALID,\n};\n\n \nstatic uint32_t logicvc_layer_formats_rgb24_alpha[] = {\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_INVALID,\n};\n\nstatic struct logicvc_layer_formats logicvc_layer_formats[] = {\n\t{\n\t\t.colorspace\t= LOGICVC_LAYER_COLORSPACE_RGB,\n\t\t.depth\t\t= 16,\n\t\t.formats\t= logicvc_layer_formats_rgb16,\n\t},\n\t{\n\t\t.colorspace\t= LOGICVC_LAYER_COLORSPACE_RGB,\n\t\t.depth\t\t= 24,\n\t\t.formats\t= logicvc_layer_formats_rgb24,\n\t},\n\t{\n\t\t.colorspace\t= LOGICVC_LAYER_COLORSPACE_RGB,\n\t\t.depth\t\t= 24,\n\t\t.alpha\t\t= true,\n\t\t.formats\t= logicvc_layer_formats_rgb24_alpha,\n\t},\n\t{ }\n};\n\nstatic bool logicvc_layer_format_inverted(uint32_t format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_BGR565:\n\tcase DRM_FORMAT_BGR888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int logicvc_plane_atomic_check(struct drm_plane *drm_plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_device *drm_dev = drm_plane->dev;\n\tstruct logicvc_layer *layer = logicvc_layer(drm_plane);\n\tstruct logicvc_drm *logicvc = logicvc_drm(drm_dev);\n\tstruct drm_plane_state *new_state =\n\t\tdrm_atomic_get_new_plane_state(state, drm_plane);\n\tstruct drm_crtc_state *crtc_state;\n\tint min_scale, max_scale;\n\tbool can_position;\n\tint ret;\n\n\tif (!new_state->crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(new_state->state,\n\t\t\t\t\t\t\tnew_state->crtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn -EINVAL;\n\n\tif (new_state->crtc_x < 0 || new_state->crtc_y < 0) {\n\t\tdrm_err(drm_dev,\n\t\t\t\"Negative on-CRTC positions are not supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!logicvc->caps->layer_address) {\n\t\tret = logicvc_layer_buffer_find_setup(logicvc, layer, new_state,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret) {\n\t\t\tdrm_err(drm_dev, \"No viable setup for buffer found.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmin_scale = DRM_PLANE_NO_SCALING;\n\tmax_scale = DRM_PLANE_NO_SCALING;\n\n\tcan_position = (drm_plane->type == DRM_PLANE_TYPE_OVERLAY &&\n\t\t\tlayer->index != (logicvc->config.layers_count - 1) &&\n\t\t\tlogicvc->config.layers_configurable);\n\n\tret = drm_atomic_helper_check_plane_state(new_state, crtc_state,\n\t\t\t\t\t\t  min_scale, max_scale,\n\t\t\t\t\t\t  can_position, true);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Invalid plane state\\n\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void logicvc_plane_atomic_update(struct drm_plane *drm_plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct logicvc_layer *layer = logicvc_layer(drm_plane);\n\tstruct logicvc_drm *logicvc = logicvc_drm(drm_plane->dev);\n\tstruct drm_device *drm_dev = &logicvc->drm_dev;\n\tstruct drm_plane_state *new_state =\n\t\tdrm_atomic_get_new_plane_state(state, drm_plane);\n\tstruct drm_crtc *drm_crtc = &logicvc->crtc->drm_crtc;\n\tstruct drm_display_mode *mode = &drm_crtc->state->adjusted_mode;\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct logicvc_layer_buffer_setup setup = {};\n\tu32 index = layer->index;\n\tu32 reg;\n\n\t \n\n\tregmap_write(logicvc->regmap, LOGICVC_LAYER_WIDTH_REG(index),\n\t\t     new_state->crtc_w - 1);\n\tregmap_write(logicvc->regmap, LOGICVC_LAYER_HEIGHT_REG(index),\n\t\t     new_state->crtc_h - 1);\n\n\tif (logicvc->caps->layer_address) {\n\t\tphys_addr_t fb_addr = drm_fb_dma_get_gem_addr(fb, new_state, 0);\n\n\t\tregmap_write(logicvc->regmap, LOGICVC_LAYER_ADDRESS_REG(index),\n\t\t\t     fb_addr);\n\t} else {\n\t\t \n\n\t\tlogicvc_layer_buffer_find_setup(logicvc, layer, new_state,\n\t\t\t\t\t\t&setup);\n\n\t\t \n\n\t\tregmap_write(logicvc->regmap, LOGICVC_BUFFER_SEL_REG,\n\t\t\t     LOGICVC_BUFFER_SEL_VALUE(index, setup.buffer_sel));\n\t\tregmap_write(logicvc->regmap, LOGICVC_LAYER_HOFFSET_REG(index),\n\t\t\t     setup.hoffset);\n\t\tregmap_write(logicvc->regmap, LOGICVC_LAYER_VOFFSET_REG(index),\n\t\t\t     setup.voffset);\n\t}\n\n\t \n\n\tregmap_write(logicvc->regmap, LOGICVC_LAYER_HPOSITION_REG(index),\n\t\t     mode->hdisplay - 1 - new_state->crtc_x);\n\n\t \n\tregmap_write(logicvc->regmap, LOGICVC_LAYER_VPOSITION_REG(index),\n\t\t     mode->vdisplay - 1 - new_state->crtc_y);\n\n\t \n\n\tif (layer->config.alpha_mode == LOGICVC_LAYER_ALPHA_LAYER) {\n\t\tu32 alpha_bits;\n\t\tu32 alpha_max;\n\t\tu32 alpha;\n\n\t\tswitch (layer->config.depth) {\n\t\tcase 8:\n\t\t\talpha_bits = 3;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif (layer->config.colorspace ==\n\t\t\t    LOGICVC_LAYER_COLORSPACE_YUV)\n\t\t\t\talpha_bits = 8;\n\t\t\telse\n\t\t\t\talpha_bits = 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\talpha_bits = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\talpha_max = BIT(alpha_bits) - 1;\n\t\talpha = new_state->alpha * alpha_max / DRM_BLEND_ALPHA_OPAQUE;\n\n\t\tdrm_dbg_kms(drm_dev, \"Setting layer %d alpha to %d/%d\\n\", index,\n\t\t\t    alpha, alpha_max);\n\n\t\tregmap_write(logicvc->regmap, LOGICVC_LAYER_ALPHA_REG(index),\n\t\t\t     alpha);\n\t}\n\n\t \n\n\treg = LOGICVC_LAYER_CTRL_ENABLE;\n\n\tif (logicvc_layer_format_inverted(fb->format->format))\n\t\treg |= LOGICVC_LAYER_CTRL_PIXEL_FORMAT_INVERT;\n\n\treg |= LOGICVC_LAYER_CTRL_COLOR_KEY_DISABLE;\n\n\tregmap_write(logicvc->regmap, LOGICVC_LAYER_CTRL_REG(index), reg);\n}\n\nstatic void logicvc_plane_atomic_disable(struct drm_plane *drm_plane,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct logicvc_layer *layer = logicvc_layer(drm_plane);\n\tstruct logicvc_drm *logicvc = logicvc_drm(drm_plane->dev);\n\tu32 index = layer->index;\n\n\tregmap_write(logicvc->regmap, LOGICVC_LAYER_CTRL_REG(index), 0);\n}\n\nstatic struct drm_plane_helper_funcs logicvc_plane_helper_funcs = {\n\t.atomic_check\t\t= logicvc_plane_atomic_check,\n\t.atomic_update\t\t= logicvc_plane_atomic_update,\n\t.atomic_disable\t\t= logicvc_plane_atomic_disable,\n};\n\nstatic const struct drm_plane_funcs logicvc_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.destroy\t\t= drm_plane_cleanup,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n};\n\nint logicvc_layer_buffer_find_setup(struct logicvc_drm *logicvc,\n\t\t\t\t    struct logicvc_layer *layer,\n\t\t\t\t    struct drm_plane_state *state,\n\t\t\t\t    struct logicvc_layer_buffer_setup *setup)\n{\n\tstruct drm_device *drm_dev = &logicvc->drm_dev;\n\tstruct drm_framebuffer *fb = state->fb;\n\t \n\tu32 layer_bytespp = fb->format->cpp[0];\n\tu32 layer_stride = layer_bytespp * logicvc->config.row_stride;\n\tu32 base_offset = layer->config.base_offset * layer_stride;\n\tu32 buffer_offset = layer->config.buffer_offset * layer_stride;\n\tu8 buffer_sel = 0;\n\tu16 voffset = 0;\n\tu16 hoffset = 0;\n\tphys_addr_t fb_addr;\n\tu32 fb_offset;\n\tu32 gap;\n\n\tif (!logicvc->reserved_mem_base) {\n\t\tdrm_err(drm_dev, \"No reserved memory base was registered!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfb_addr = drm_fb_dma_get_gem_addr(fb, state, 0);\n\tif (fb_addr < logicvc->reserved_mem_base) {\n\t\tdrm_err(drm_dev,\n\t\t\t\"Framebuffer memory below reserved memory base!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfb_offset = (u32) (fb_addr - logicvc->reserved_mem_base);\n\n\tif (fb_offset < base_offset) {\n\t\tdrm_err(drm_dev,\n\t\t\t\"Framebuffer offset below layer base offset!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgap = fb_offset - base_offset;\n\n\t \n\tif (gap && buffer_offset) {\n\t\tbuffer_sel = gap / buffer_offset;\n\t\tif (buffer_sel > LOGICVC_BUFFER_SEL_MAX)\n\t\t\tbuffer_sel = LOGICVC_BUFFER_SEL_MAX;\n\n\t\tgap -= buffer_sel * buffer_offset;\n\t}\n\n\t \n\tif (gap && layer_stride && logicvc->config.layers_configurable) {\n\t\tvoffset = gap / layer_stride;\n\t\tif (voffset > LOGICVC_LAYER_VOFFSET_MAX)\n\t\t\tvoffset = LOGICVC_LAYER_VOFFSET_MAX;\n\n\t\tgap -= voffset * layer_stride;\n\t}\n\n\t \n\tif (gap && layer_bytespp && logicvc->config.layers_configurable) {\n\t\thoffset = gap / layer_bytespp;\n\t\tif (hoffset > LOGICVC_DIMENSIONS_MAX)\n\t\t\thoffset = LOGICVC_DIMENSIONS_MAX;\n\n\t\tgap -= hoffset * layer_bytespp;\n\t}\n\n\tif (gap) {\n\t\tdrm_err(drm_dev,\n\t\t\t\"Unable to find layer %d buffer setup for 0x%x byte gap\\n\",\n\t\t\tlayer->index, fb_offset - base_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_dbg_kms(drm_dev, \"Found layer %d buffer setup for 0x%x byte gap:\\n\",\n\t\t    layer->index, fb_offset - base_offset);\n\n\tdrm_dbg_kms(drm_dev, \"- buffer_sel = 0x%x chunks of 0x%x bytes\\n\",\n\t\t    buffer_sel, buffer_offset);\n\tdrm_dbg_kms(drm_dev, \"- voffset = 0x%x chunks of 0x%x bytes\\n\", voffset,\n\t\t    layer_stride);\n\tdrm_dbg_kms(drm_dev, \"- hoffset = 0x%x chunks of 0x%x bytes\\n\", hoffset,\n\t\t    layer_bytespp);\n\n\tif (setup) {\n\t\tsetup->buffer_sel = buffer_sel;\n\t\tsetup->voffset = voffset;\n\t\tsetup->hoffset = hoffset;\n\t}\n\n\treturn 0;\n}\n\nstatic struct logicvc_layer_formats *logicvc_layer_formats_lookup(struct logicvc_layer *layer)\n{\n\tbool alpha;\n\tunsigned int i = 0;\n\n\talpha = (layer->config.alpha_mode == LOGICVC_LAYER_ALPHA_PIXEL);\n\n\twhile (logicvc_layer_formats[i].formats) {\n\t\tif (logicvc_layer_formats[i].colorspace == layer->config.colorspace &&\n\t\t    logicvc_layer_formats[i].depth == layer->config.depth &&\n\t\t    logicvc_layer_formats[i].alpha == alpha)\n\t\t\treturn &logicvc_layer_formats[i];\n\n\t\ti++;\n\t}\n\n\treturn NULL;\n}\n\nstatic unsigned int logicvc_layer_formats_count(struct logicvc_layer_formats *formats)\n{\n\tunsigned int count = 0;\n\n\twhile (formats->formats[count] != DRM_FORMAT_INVALID)\n\t\tcount++;\n\n\treturn count;\n}\n\nstatic int logicvc_layer_config_parse(struct logicvc_drm *logicvc,\n\t\t\t\t      struct logicvc_layer *layer)\n{\n\tstruct device_node *of_node = layer->of_node;\n\tstruct logicvc_layer_config *config = &layer->config;\n\tint ret;\n\n\tlogicvc_of_property_parse_bool(of_node,\n\t\t\t\t       LOGICVC_OF_PROPERTY_LAYER_PRIMARY,\n\t\t\t\t       &config->primary);\n\n\tret = logicvc_of_property_parse_u32(of_node,\n\t\t\t\t\t    LOGICVC_OF_PROPERTY_LAYER_COLORSPACE,\n\t\t\t\t\t    &config->colorspace);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logicvc_of_property_parse_u32(of_node,\n\t\t\t\t\t    LOGICVC_OF_PROPERTY_LAYER_DEPTH,\n\t\t\t\t\t    &config->depth);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logicvc_of_property_parse_u32(of_node,\n\t\t\t\t\t    LOGICVC_OF_PROPERTY_LAYER_ALPHA_MODE,\n\t\t\t\t\t    &config->alpha_mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (logicvc->caps->layer_address)\n\t\treturn 0;\n\n\tret = logicvc_of_property_parse_u32(of_node,\n\t\t\t\t\t    LOGICVC_OF_PROPERTY_LAYER_BASE_OFFSET,\n\t\t\t\t\t    &config->base_offset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logicvc_of_property_parse_u32(of_node,\n\t\t\t\t\t    LOGICVC_OF_PROPERTY_LAYER_BUFFER_OFFSET,\n\t\t\t\t\t    &config->buffer_offset);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstruct logicvc_layer *logicvc_layer_get_from_index(struct logicvc_drm *logicvc,\n\t\t\t\t\t\t   u32 index)\n{\n\tstruct logicvc_layer *layer;\n\n\tlist_for_each_entry(layer, &logicvc->layers_list, list)\n\t\tif (layer->index == index)\n\t\t\treturn layer;\n\n\treturn NULL;\n}\n\nstruct logicvc_layer *logicvc_layer_get_from_type(struct logicvc_drm *logicvc,\n\t\t\t\t\t\t  enum drm_plane_type type)\n{\n\tstruct logicvc_layer *layer;\n\n\tlist_for_each_entry(layer, &logicvc->layers_list, list)\n\t\tif (layer->drm_plane.type == type)\n\t\t\treturn layer;\n\n\treturn NULL;\n}\n\nstruct logicvc_layer *logicvc_layer_get_primary(struct logicvc_drm *logicvc)\n{\n\treturn logicvc_layer_get_from_type(logicvc, DRM_PLANE_TYPE_PRIMARY);\n}\n\nstatic int logicvc_layer_init(struct logicvc_drm *logicvc,\n\t\t\t      struct device_node *of_node, u32 index)\n{\n\tstruct drm_device *drm_dev = &logicvc->drm_dev;\n\tstruct device *dev = drm_dev->dev;\n\tstruct logicvc_layer *layer = NULL;\n\tstruct logicvc_layer_formats *formats;\n\tunsigned int formats_count;\n\tenum drm_plane_type type;\n\tunsigned int zpos;\n\tint ret;\n\n\tlayer = devm_kzalloc(dev, sizeof(*layer), GFP_KERNEL);\n\tif (!layer) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tlayer->of_node = of_node;\n\tlayer->index = index;\n\n\tret = logicvc_layer_config_parse(logicvc, layer);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Failed to parse config for layer #%d\\n\",\n\t\t\tindex);\n\t\tgoto error;\n\t}\n\n\tformats = logicvc_layer_formats_lookup(layer);\n\tif (!formats) {\n\t\tdrm_err(drm_dev, \"Failed to lookup formats for layer #%d\\n\",\n\t\t\tindex);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tformats_count = logicvc_layer_formats_count(formats);\n\n\t \n\tif (logicvc->config.background_layer &&\n\t    index == (logicvc->config.layers_count - 1)) {\n\t\t \n\t\tu32 background = 0;\n\n\t\tdrm_dbg_kms(drm_dev, \"Using layer #%d as background layer\\n\",\n\t\t\t    index);\n\n\t\tregmap_write(logicvc->regmap, LOGICVC_BACKGROUND_COLOR_REG,\n\t\t\t     background);\n\n\t\tdevm_kfree(dev, layer);\n\n\t\treturn 0;\n\t}\n\n\tif (layer->config.primary)\n\t\ttype = DRM_PLANE_TYPE_PRIMARY;\n\telse\n\t\ttype = DRM_PLANE_TYPE_OVERLAY;\n\n\tret = drm_universal_plane_init(drm_dev, &layer->drm_plane, 0,\n\t\t\t\t       &logicvc_plane_funcs, formats->formats,\n\t\t\t\t       formats_count, NULL, type, NULL);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Failed to initialize layer plane\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_plane_helper_add(&layer->drm_plane, &logicvc_plane_helper_funcs);\n\n\tzpos = logicvc->config.layers_count - index - 1;\n\tdrm_dbg_kms(drm_dev, \"Giving layer #%d zpos %d\\n\", index, zpos);\n\n\tif (layer->config.alpha_mode == LOGICVC_LAYER_ALPHA_LAYER)\n\t\tdrm_plane_create_alpha_property(&layer->drm_plane);\n\n\tdrm_plane_create_zpos_immutable_property(&layer->drm_plane, zpos);\n\n\tdrm_dbg_kms(drm_dev, \"Registering layer #%d\\n\", index);\n\n\tlayer->formats = formats;\n\n\tlist_add_tail(&layer->list, &logicvc->layers_list);\n\n\treturn 0;\n\nerror:\n\tif (layer)\n\t\tdevm_kfree(dev, layer);\n\n\treturn ret;\n}\n\nstatic void logicvc_layer_fini(struct logicvc_drm *logicvc,\n\t\t\t       struct logicvc_layer *layer)\n{\n\tstruct device *dev = logicvc->drm_dev.dev;\n\n\tlist_del(&layer->list);\n\tdevm_kfree(dev, layer);\n}\n\nvoid logicvc_layers_attach_crtc(struct logicvc_drm *logicvc)\n{\n\tuint32_t possible_crtcs = drm_crtc_mask(&logicvc->crtc->drm_crtc);\n\tstruct logicvc_layer *layer;\n\n\tlist_for_each_entry(layer, &logicvc->layers_list, list) {\n\t\tif (layer->drm_plane.type != DRM_PLANE_TYPE_OVERLAY)\n\t\t\tcontinue;\n\n\t\tlayer->drm_plane.possible_crtcs = possible_crtcs;\n\t}\n}\n\nint logicvc_layers_init(struct logicvc_drm *logicvc)\n{\n\tstruct drm_device *drm_dev = &logicvc->drm_dev;\n\tstruct device *dev = drm_dev->dev;\n\tstruct device_node *of_node = dev->of_node;\n\tstruct device_node *layer_node = NULL;\n\tstruct device_node *layers_node;\n\tstruct logicvc_layer *layer;\n\tstruct logicvc_layer *next;\n\tint ret = 0;\n\n\tlayers_node = of_get_child_by_name(of_node, \"layers\");\n\tif (!layers_node) {\n\t\tdrm_err(drm_dev, \"No layers node found in the description\\n\");\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tfor_each_child_of_node(layers_node, layer_node) {\n\t\tu32 index = 0;\n\n\t\tif (!logicvc_of_node_is_layer(layer_node))\n\t\t\tcontinue;\n\n\t\tret = of_property_read_u32(layer_node, \"reg\", &index);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tlayer = logicvc_layer_get_from_index(logicvc, index);\n\t\tif (layer) {\n\t\t\tdrm_err(drm_dev, \"Duplicated entry for layer #%d\\n\",\n\t\t\t\tindex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = logicvc_layer_init(logicvc, layer_node, index);\n\t\tif (ret) {\n\t\t\tof_node_put(layers_node);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tof_node_put(layers_node);\n\n\treturn 0;\n\nerror:\n\tlist_for_each_entry_safe(layer, next, &logicvc->layers_list, list)\n\t\tlogicvc_layer_fini(logicvc, layer);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}