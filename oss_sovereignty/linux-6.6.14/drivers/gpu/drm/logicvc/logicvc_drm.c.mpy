{
  "module_name": "logicvc_drm.c",
  "hash_id": "3f35b8ba379457b9d110035b81956bfdf385892bbb3ae6b83a4022d3b2850e71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/logicvc/logicvc_drm.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_print.h>\n\n#include \"logicvc_crtc.h\"\n#include \"logicvc_drm.h\"\n#include \"logicvc_interface.h\"\n#include \"logicvc_mode.h\"\n#include \"logicvc_layer.h\"\n#include \"logicvc_of.h\"\n#include \"logicvc_regs.h\"\n\nDEFINE_DRM_GEM_DMA_FOPS(logicvc_drm_fops);\n\nstatic int logicvc_drm_gem_dma_dumb_create(struct drm_file *file_priv,\n\t\t\t\t\t   struct drm_device *drm_dev,\n\t\t\t\t\t   struct drm_mode_create_dumb *args)\n{\n\tstruct logicvc_drm *logicvc = logicvc_drm(drm_dev);\n\n\t \n\targs->pitch = logicvc->config.row_stride * DIV_ROUND_UP(args->bpp, 8);\n\n\treturn drm_gem_dma_dumb_create_internal(file_priv, drm_dev, args);\n}\n\nstatic struct drm_driver logicvc_drm_driver = {\n\t.driver_features\t\t= DRIVER_GEM | DRIVER_MODESET |\n\t\t\t\t\t  DRIVER_ATOMIC,\n\n\t.fops\t\t\t\t= &logicvc_drm_fops,\n\t.name\t\t\t\t= \"logicvc-drm\",\n\t.desc\t\t\t\t= \"Xylon LogiCVC DRM driver\",\n\t.date\t\t\t\t= \"20200403\",\n\t.major\t\t\t\t= 1,\n\t.minor\t\t\t\t= 0,\n\n\tDRM_GEM_DMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE(logicvc_drm_gem_dma_dumb_create),\n};\n\nstatic struct regmap_config logicvc_drm_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.name\t\t= \"logicvc-drm\",\n};\n\nstatic irqreturn_t logicvc_drm_irq_handler(int irq, void *data)\n{\n\tstruct logicvc_drm *logicvc = data;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 stat = 0;\n\n\t \n\tregmap_read(logicvc->regmap, LOGICVC_INT_STAT_REG, &stat);\n\n\t \n\tregmap_write(logicvc->regmap, LOGICVC_INT_STAT_REG, stat);\n\n\tif (stat & LOGICVC_INT_STAT_V_SYNC) {\n\t\tlogicvc_crtc_vblank_handler(logicvc);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic int logicvc_drm_config_parse(struct logicvc_drm *logicvc)\n{\n\tstruct drm_device *drm_dev = &logicvc->drm_dev;\n\tstruct device *dev = drm_dev->dev;\n\tstruct device_node *of_node = dev->of_node;\n\tstruct logicvc_drm_config *config = &logicvc->config;\n\tstruct device_node *layers_node;\n\tint ret;\n\n\tlogicvc_of_property_parse_bool(of_node, LOGICVC_OF_PROPERTY_DITHERING,\n\t\t\t\t       &config->dithering);\n\tlogicvc_of_property_parse_bool(of_node,\n\t\t\t\t       LOGICVC_OF_PROPERTY_BACKGROUND_LAYER,\n\t\t\t\t       &config->background_layer);\n\tlogicvc_of_property_parse_bool(of_node,\n\t\t\t\t       LOGICVC_OF_PROPERTY_LAYERS_CONFIGURABLE,\n\t\t\t\t       &config->layers_configurable);\n\n\tret = logicvc_of_property_parse_u32(of_node,\n\t\t\t\t\t    LOGICVC_OF_PROPERTY_DISPLAY_INTERFACE,\n\t\t\t\t\t    &config->display_interface);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logicvc_of_property_parse_u32(of_node,\n\t\t\t\t\t    LOGICVC_OF_PROPERTY_DISPLAY_COLORSPACE,\n\t\t\t\t\t    &config->display_colorspace);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logicvc_of_property_parse_u32(of_node,\n\t\t\t\t\t    LOGICVC_OF_PROPERTY_DISPLAY_DEPTH,\n\t\t\t\t\t    &config->display_depth);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logicvc_of_property_parse_u32(of_node,\n\t\t\t\t\t    LOGICVC_OF_PROPERTY_ROW_STRIDE,\n\t\t\t\t\t    &config->row_stride);\n\tif (ret)\n\t\treturn ret;\n\n\tlayers_node = of_get_child_by_name(of_node, \"layers\");\n\tif (!layers_node) {\n\t\tdrm_err(drm_dev, \"Missing non-optional layers node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tconfig->layers_count = of_get_child_count(layers_node);\n\tif (!config->layers_count) {\n\t\tdrm_err(drm_dev,\n\t\t\t\"Missing a non-optional layers children node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int logicvc_clocks_prepare(struct logicvc_drm *logicvc)\n{\n\tstruct drm_device *drm_dev = &logicvc->drm_dev;\n\tstruct device *dev = drm_dev->dev;\n\n\tstruct {\n\t\tstruct clk **clk;\n\t\tchar *name;\n\t\tbool optional;\n\t} clocks_map[] = {\n\t\t{\n\t\t\t.clk = &logicvc->vclk,\n\t\t\t.name = \"vclk\",\n\t\t\t.optional = false,\n\t\t},\n\t\t{\n\t\t\t.clk = &logicvc->vclk2,\n\t\t\t.name = \"vclk2\",\n\t\t\t.optional = true,\n\t\t},\n\t\t{\n\t\t\t.clk = &logicvc->lvdsclk,\n\t\t\t.name = \"lvdsclk\",\n\t\t\t.optional = true,\n\t\t},\n\t\t{\n\t\t\t.clk = &logicvc->lvdsclkn,\n\t\t\t.name = \"lvdsclkn\",\n\t\t\t.optional = true,\n\t\t},\n\t};\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(clocks_map); i++) {\n\t\tstruct clk *clk;\n\n\t\tclk = devm_clk_get(dev, clocks_map[i].name);\n\t\tif (IS_ERR(clk)) {\n\t\t\tif (PTR_ERR(clk) == -ENOENT && clocks_map[i].optional)\n\t\t\t\tcontinue;\n\n\t\t\tdrm_err(drm_dev, \"Missing non-optional clock %s\\n\",\n\t\t\t\tclocks_map[i].name);\n\n\t\t\tret = PTR_ERR(clk);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret) {\n\t\t\tdrm_err(drm_dev,\n\t\t\t\t\"Failed to prepare and enable clock %s\\n\",\n\t\t\t\tclocks_map[i].name);\n\t\t\tgoto error;\n\t\t}\n\n\t\t*clocks_map[i].clk = clk;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < ARRAY_SIZE(clocks_map); i++) {\n\t\tif (!*clocks_map[i].clk)\n\t\t\tcontinue;\n\n\t\tclk_disable_unprepare(*clocks_map[i].clk);\n\t\t*clocks_map[i].clk = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int logicvc_clocks_unprepare(struct logicvc_drm *logicvc)\n{\n\tstruct clk **clocks[] = {\n\t\t&logicvc->vclk,\n\t\t&logicvc->vclk2,\n\t\t&logicvc->lvdsclk,\n\t\t&logicvc->lvdsclkn,\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(clocks); i++) {\n\t\tif (!*clocks[i])\n\t\t\tcontinue;\n\n\t\tclk_disable_unprepare(*clocks[i]);\n\t\t*clocks[i] = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct logicvc_drm_caps logicvc_drm_caps[] = {\n\t{\n\t\t.major\t\t= 3,\n\t\t.layer_address\t= false,\n\t},\n\t{\n\t\t.major\t\t= 4,\n\t\t.layer_address\t= true,\n\t},\n\t{\n\t\t.major\t\t= 5,\n\t\t.layer_address\t= true,\n\t},\n};\n\nstatic const struct logicvc_drm_caps *\nlogicvc_drm_caps_match(struct logicvc_drm *logicvc)\n{\n\tstruct drm_device *drm_dev = &logicvc->drm_dev;\n\tconst struct logicvc_drm_caps *caps = NULL;\n\tunsigned int major, minor;\n\tchar level;\n\tunsigned int i;\n\tu32 version;\n\n\tregmap_read(logicvc->regmap, LOGICVC_IP_VERSION_REG, &version);\n\n\tmajor = FIELD_GET(LOGICVC_IP_VERSION_MAJOR_MASK, version);\n\tminor = FIELD_GET(LOGICVC_IP_VERSION_MINOR_MASK, version);\n\tlevel = FIELD_GET(LOGICVC_IP_VERSION_LEVEL_MASK, version) + 'a';\n\n\tfor (i = 0; i < ARRAY_SIZE(logicvc_drm_caps); i++) {\n\t\tif (logicvc_drm_caps[i].major &&\n\t\t    logicvc_drm_caps[i].major != major)\n\t\t\tcontinue;\n\n\t\tif (logicvc_drm_caps[i].minor &&\n\t\t    logicvc_drm_caps[i].minor != minor)\n\t\t\tcontinue;\n\n\t\tif (logicvc_drm_caps[i].level &&\n\t\t    logicvc_drm_caps[i].level != level)\n\t\t\tcontinue;\n\n\t\tcaps = &logicvc_drm_caps[i];\n\t}\n\n\tdrm_info(drm_dev, \"LogiCVC version %d.%02d.%c\\n\", major, minor, level);\n\n\treturn caps;\n}\n\nstatic int logicvc_drm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *of_node = pdev->dev.of_node;\n\tstruct device_node *reserved_mem_node;\n\tstruct reserved_mem *reserved_mem = NULL;\n\tconst struct logicvc_drm_caps *caps;\n\tstruct logicvc_drm *logicvc;\n\tstruct device *dev = &pdev->dev;\n\tstruct drm_device *drm_dev;\n\tstruct regmap *regmap = NULL;\n\tstruct resource res;\n\tvoid __iomem *base;\n\tunsigned int preferred_bpp;\n\tint irq;\n\tint ret;\n\n\tret = of_reserved_mem_device_init(dev);\n\tif (ret && ret != -ENODEV) {\n\t\tdev_err(dev, \"Failed to init memory region\\n\");\n\t\tgoto error_early;\n\t}\n\n\treserved_mem_node = of_parse_phandle(of_node, \"memory-region\", 0);\n\tif (reserved_mem_node) {\n\t\treserved_mem = of_reserved_mem_lookup(reserved_mem_node);\n\t\tof_node_put(reserved_mem_node);\n\t}\n\n\t \n\tif (of_node->parent)\n\t\tregmap = syscon_node_to_regmap(of_node->parent);\n\n\t \n\tif (IS_ERR_OR_NULL(regmap)) {\n\t\tret = of_address_to_resource(of_node, 0, &res);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to get resource from address\\n\");\n\t\t\tgoto error_reserved_mem;\n\t\t}\n\n\t\tbase = devm_ioremap_resource(dev, &res);\n\t\tif (IS_ERR(base)) {\n\t\t\tdev_err(dev, \"Failed to map I/O base\\n\");\n\t\t\tret = PTR_ERR(base);\n\t\t\tgoto error_reserved_mem;\n\t\t}\n\n\t\tlogicvc_drm_regmap_config.max_register = resource_size(&res) -\n\t\t\t\t\t\t\t 4;\n\n\t\tregmap = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t       &logicvc_drm_regmap_config);\n\t\tif (IS_ERR(regmap)) {\n\t\t\tdev_err(dev, \"Failed to create regmap for I/O\\n\");\n\t\t\tret = PTR_ERR(regmap);\n\t\t\tgoto error_reserved_mem;\n\t\t}\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = -ENODEV;\n\t\tgoto error_reserved_mem;\n\t}\n\n\tlogicvc = devm_drm_dev_alloc(dev, &logicvc_drm_driver,\n\t\t\t\t     struct logicvc_drm, drm_dev);\n\tif (IS_ERR(logicvc)) {\n\t\tret = PTR_ERR(logicvc);\n\t\tgoto error_reserved_mem;\n\t}\n\n\tplatform_set_drvdata(pdev, logicvc);\n\tdrm_dev = &logicvc->drm_dev;\n\n\tlogicvc->regmap = regmap;\n\tINIT_LIST_HEAD(&logicvc->layers_list);\n\n\tcaps = logicvc_drm_caps_match(logicvc);\n\tif (!caps) {\n\t\tret = -EINVAL;\n\t\tgoto error_reserved_mem;\n\t}\n\n\tlogicvc->caps = caps;\n\n\tif (reserved_mem)\n\t\tlogicvc->reserved_mem_base = reserved_mem->base;\n\n\tret = logicvc_clocks_prepare(logicvc);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Failed to prepare clocks\\n\");\n\t\tgoto error_reserved_mem;\n\t}\n\n\tret = devm_request_irq(dev, irq, logicvc_drm_irq_handler, 0,\n\t\t\t       dev_name(dev), logicvc);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Failed to request IRQ\\n\");\n\t\tgoto error_clocks;\n\t}\n\n\tret = logicvc_drm_config_parse(logicvc);\n\tif (ret && ret != -ENODEV) {\n\t\tdrm_err(drm_dev, \"Failed to parse config\\n\");\n\t\tgoto error_clocks;\n\t}\n\n\tret = drmm_mode_config_init(drm_dev);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Failed to init mode config\\n\");\n\t\tgoto error_clocks;\n\t}\n\n\tret = logicvc_layers_init(logicvc);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Failed to initialize layers\\n\");\n\t\tgoto error_clocks;\n\t}\n\n\tret = logicvc_crtc_init(logicvc);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Failed to initialize CRTC\\n\");\n\t\tgoto error_clocks;\n\t}\n\n\tlogicvc_layers_attach_crtc(logicvc);\n\n\tret = logicvc_interface_init(logicvc);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdrm_err(drm_dev, \"Failed to initialize interface\\n\");\n\n\t\tgoto error_clocks;\n\t}\n\n\tlogicvc_interface_attach_crtc(logicvc);\n\n\tret = logicvc_mode_init(logicvc);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Failed to initialize KMS\\n\");\n\t\tgoto error_clocks;\n\t}\n\n\tret = drm_dev_register(drm_dev, 0);\n\tif (ret) {\n\t\tdrm_err(drm_dev, \"Failed to register DRM device\\n\");\n\t\tgoto error_mode;\n\t}\n\n\tswitch (drm_dev->mode_config.preferred_depth) {\n\tcase 16:\n\t\tpreferred_bpp = 16;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\tdefault:\n\t\tpreferred_bpp = 32;\n\t\tbreak;\n\t}\n\tdrm_fbdev_dma_setup(drm_dev, preferred_bpp);\n\n\treturn 0;\n\nerror_mode:\n\tlogicvc_mode_fini(logicvc);\n\nerror_clocks:\n\tlogicvc_clocks_unprepare(logicvc);\n\nerror_reserved_mem:\n\tof_reserved_mem_device_release(dev);\n\nerror_early:\n\treturn ret;\n}\n\nstatic void logicvc_drm_remove(struct platform_device *pdev)\n{\n\tstruct logicvc_drm *logicvc = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tstruct drm_device *drm_dev = &logicvc->drm_dev;\n\n\tdrm_dev_unregister(drm_dev);\n\tdrm_atomic_helper_shutdown(drm_dev);\n\n\tlogicvc_mode_fini(logicvc);\n\n\tlogicvc_clocks_unprepare(logicvc);\n\n\tof_reserved_mem_device_release(dev);\n}\n\nstatic const struct of_device_id logicvc_drm_of_table[] = {\n\t{ .compatible = \"xylon,logicvc-3.02.a-display\" },\n\t{ .compatible = \"xylon,logicvc-4.01.a-display\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, logicvc_drm_of_table);\n\nstatic struct platform_driver logicvc_drm_platform_driver = {\n\t.probe\t\t= logicvc_drm_probe,\n\t.remove_new\t= logicvc_drm_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"logicvc-drm\",\n\t\t.of_match_table\t= logicvc_drm_of_table,\n\t},\n};\n\nmodule_platform_driver(logicvc_drm_platform_driver);\n\nMODULE_AUTHOR(\"Paul Kocialkowski <paul.kocialkowski@bootlin.com>\");\nMODULE_DESCRIPTION(\"Xylon LogiCVC DRM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}