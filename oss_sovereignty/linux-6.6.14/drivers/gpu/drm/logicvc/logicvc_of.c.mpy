{
  "module_name": "logicvc_of.c",
  "hash_id": "9536cd4d71763349ace98f81f342c1aefd62907a1f1be53306c970c60e80261a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/logicvc/logicvc_of.c",
  "human_readable_source": "\n \n\n#include <drm/drm_print.h>\n\n#include \"logicvc_drm.h\"\n#include \"logicvc_layer.h\"\n#include \"logicvc_of.h\"\n\nstatic struct logicvc_of_property_sv logicvc_of_display_interface_sv[] = {\n\t{ \"lvds-4bits\",\tLOGICVC_DISPLAY_INTERFACE_LVDS_4BITS },\n\t{ \"lvds-3bits\",\tLOGICVC_DISPLAY_INTERFACE_LVDS_3BITS },\n\t{ },\n};\n\nstatic struct logicvc_of_property_sv logicvc_of_display_colorspace_sv[] = {\n\t{ \"rgb\",\tLOGICVC_DISPLAY_COLORSPACE_RGB },\n\t{ \"yuv422\",\tLOGICVC_DISPLAY_COLORSPACE_YUV422 },\n\t{ \"yuv444\",\tLOGICVC_DISPLAY_COLORSPACE_YUV444 },\n\t{ },\n};\n\nstatic struct logicvc_of_property_sv logicvc_of_layer_colorspace_sv[] = {\n\t{ \"rgb\",\tLOGICVC_LAYER_COLORSPACE_RGB },\n\t{ \"yuv\",\tLOGICVC_LAYER_COLORSPACE_YUV },\n\t{ },\n};\n\nstatic struct logicvc_of_property_sv logicvc_of_layer_alpha_mode_sv[] = {\n\t{ \"layer\",\tLOGICVC_LAYER_ALPHA_LAYER },\n\t{ \"pixel\",\tLOGICVC_LAYER_ALPHA_PIXEL },\n\t{ },\n};\n\nstatic struct logicvc_of_property logicvc_of_properties[] = {\n\t[LOGICVC_OF_PROPERTY_DISPLAY_INTERFACE] = {\n\t\t.name\t\t= \"xylon,display-interface\",\n\t\t.sv\t\t= logicvc_of_display_interface_sv,\n\t\t.range\t\t= {\n\t\t\tLOGICVC_DISPLAY_INTERFACE_LVDS_4BITS,\n\t\t\tLOGICVC_DISPLAY_INTERFACE_LVDS_3BITS,\n\t\t},\n\t},\n\t[LOGICVC_OF_PROPERTY_DISPLAY_COLORSPACE] = {\n\t\t.name\t\t= \"xylon,display-colorspace\",\n\t\t.sv\t\t= logicvc_of_display_colorspace_sv,\n\t\t.range\t\t= {\n\t\t\tLOGICVC_DISPLAY_COLORSPACE_RGB,\n\t\t\tLOGICVC_DISPLAY_COLORSPACE_YUV444,\n\t\t},\n\t},\n\t[LOGICVC_OF_PROPERTY_DISPLAY_DEPTH] = {\n\t\t.name\t\t= \"xylon,display-depth\",\n\t\t.range\t\t= { 8, 24 },\n\t},\n\t[LOGICVC_OF_PROPERTY_ROW_STRIDE] = {\n\t\t.name\t\t= \"xylon,row-stride\",\n\t},\n\t[LOGICVC_OF_PROPERTY_DITHERING] = {\n\t\t.name\t\t= \"xylon,dithering\",\n\t\t.optional\t= true,\n\t},\n\t[LOGICVC_OF_PROPERTY_BACKGROUND_LAYER] = {\n\t\t.name\t\t= \"xylon,background-layer\",\n\t\t.optional\t= true,\n\t},\n\t[LOGICVC_OF_PROPERTY_LAYERS_CONFIGURABLE] = {\n\t\t.name\t\t= \"xylon,layers-configurable\",\n\t\t.optional\t= true,\n\t},\n\t[LOGICVC_OF_PROPERTY_LAYERS_COUNT] = {\n\t\t.name\t\t= \"xylon,layers-count\",\n\t},\n\t[LOGICVC_OF_PROPERTY_LAYER_DEPTH] = {\n\t\t.name\t\t= \"xylon,layer-depth\",\n\t\t.range\t\t= { 8, 24 },\n\t},\n\t[LOGICVC_OF_PROPERTY_LAYER_COLORSPACE] = {\n\t\t.name\t\t= \"xylon,layer-colorspace\",\n\t\t.sv\t\t= logicvc_of_layer_colorspace_sv,\n\t\t.range\t\t= {\n\t\t\tLOGICVC_LAYER_COLORSPACE_RGB,\n\t\t\tLOGICVC_LAYER_COLORSPACE_RGB,\n\t\t},\n\t},\n\t[LOGICVC_OF_PROPERTY_LAYER_ALPHA_MODE] = {\n\t\t.name\t\t= \"xylon,layer-alpha-mode\",\n\t\t.sv\t\t= logicvc_of_layer_alpha_mode_sv,\n\t\t.range\t\t= {\n\t\t\tLOGICVC_LAYER_ALPHA_LAYER,\n\t\t\tLOGICVC_LAYER_ALPHA_PIXEL,\n\t\t},\n\t},\n\t[LOGICVC_OF_PROPERTY_LAYER_BASE_OFFSET] = {\n\t\t.name\t\t= \"xylon,layer-base-offset\",\n\t},\n\t[LOGICVC_OF_PROPERTY_LAYER_BUFFER_OFFSET] = {\n\t\t.name\t\t= \"xylon,layer-buffer-offset\",\n\t},\n\t[LOGICVC_OF_PROPERTY_LAYER_PRIMARY] = {\n\t\t.name\t\t= \"xylon,layer-primary\",\n\t\t.optional\t= true,\n\t},\n};\n\nstatic int logicvc_of_property_sv_value(struct logicvc_of_property_sv *sv,\n\t\t\t\t\tconst char *string, u32 *value)\n{\n\tunsigned int i = 0;\n\n\twhile (sv[i].string) {\n\t\tif (!strcmp(sv[i].string, string)) {\n\t\t\t*value = sv[i].value;\n\t\t\treturn 0;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn -EINVAL;\n}\n\nint logicvc_of_property_parse_u32(struct device_node *of_node,\n\t\t\t\t  unsigned int index, u32 *target)\n{\n\tstruct logicvc_of_property *property;\n\tconst char *string;\n\tu32 value;\n\tint ret;\n\n\tif (index >= LOGICVC_OF_PROPERTY_MAXIMUM)\n\t\treturn -EINVAL;\n\n\tproperty = &logicvc_of_properties[index];\n\n\tif (!property->optional &&\n\t    !of_property_read_bool(of_node, property->name))\n\t\treturn -ENODEV;\n\n\tif (property->sv) {\n\t\tret = of_property_read_string(of_node, property->name, &string);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = logicvc_of_property_sv_value(property->sv, string,\n\t\t\t\t\t\t   &value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = of_property_read_u32(of_node, property->name, &value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (property->range[0] || property->range[1])\n\t\tif (value < property->range[0] || value > property->range[1])\n\t\t\treturn -ERANGE;\n\n\t*target = value;\n\n\treturn 0;\n}\n\nvoid logicvc_of_property_parse_bool(struct device_node *of_node,\n\t\t\t\t    unsigned int index, bool *target)\n{\n\tstruct logicvc_of_property *property;\n\n\tif (index >= LOGICVC_OF_PROPERTY_MAXIMUM) {\n\t\t \n\t\t*target = false;\n\t\treturn;\n\t}\n\n\tproperty = &logicvc_of_properties[index];\n\t*target = of_property_read_bool(of_node, property->name);\n}\n\nbool logicvc_of_node_is_layer(struct device_node *of_node)\n{\n\treturn !of_node_cmp(of_node->name, \"layer\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}