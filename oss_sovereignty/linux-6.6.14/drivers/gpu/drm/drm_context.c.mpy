{
  "module_name": "drm_context.c",
  "hash_id": "7fd86de255b7d260e410aa9e3422aa6deeb1631c6fdfd2c96a6ec5afa7c5e126",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_context.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_print.h>\n\n#include \"drm_legacy.h\"\n\nstruct drm_ctx_list {\n\tstruct list_head head;\n\tdrm_context_t handle;\n\tstruct drm_file *tag;\n};\n\n \n \n \n\n \nvoid drm_legacy_ctxbitmap_free(struct drm_device * dev, int ctx_handle)\n{\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn;\n\n\tmutex_lock(&dev->struct_mutex);\n\tidr_remove(&dev->ctx_idr, ctx_handle);\n\tmutex_unlock(&dev->struct_mutex);\n}\n\n \nstatic int drm_legacy_ctxbitmap_next(struct drm_device * dev)\n{\n\tint ret;\n\n\tmutex_lock(&dev->struct_mutex);\n\tret = idr_alloc(&dev->ctx_idr, NULL, DRM_RESERVED_CONTEXTS, 0,\n\t\t\tGFP_KERNEL);\n\tmutex_unlock(&dev->struct_mutex);\n\treturn ret;\n}\n\n \nvoid drm_legacy_ctxbitmap_init(struct drm_device * dev)\n{\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn;\n\n\tidr_init(&dev->ctx_idr);\n}\n\n \nvoid drm_legacy_ctxbitmap_cleanup(struct drm_device * dev)\n{\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn;\n\n\tmutex_lock(&dev->struct_mutex);\n\tidr_destroy(&dev->ctx_idr);\n\tmutex_unlock(&dev->struct_mutex);\n}\n\n \nvoid drm_legacy_ctxbitmap_flush(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct drm_ctx_list *pos, *tmp;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn;\n\n\tmutex_lock(&dev->ctxlist_mutex);\n\n\tlist_for_each_entry_safe(pos, tmp, &dev->ctxlist, head) {\n\t\tif (pos->tag == file &&\n\t\t    pos->handle != DRM_KERNEL_CONTEXT) {\n\t\t\tif (dev->driver->context_dtor)\n\t\t\t\tdev->driver->context_dtor(dev, pos->handle);\n\n\t\t\tdrm_legacy_ctxbitmap_free(dev, pos->handle);\n\t\t\tlist_del(&pos->head);\n\t\t\tkfree(pos);\n\t\t}\n\t}\n\n\tmutex_unlock(&dev->ctxlist_mutex);\n}\n\n \n\n \n \n \n\n \nint drm_legacy_getsareactx(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file_priv)\n{\n\tstruct drm_ctx_priv_map *request = data;\n\tstruct drm_local_map *map;\n\tstruct drm_map_list *_entry;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&dev->struct_mutex);\n\n\tmap = idr_find(&dev->ctx_idr, request->ctx_id);\n\tif (!map) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\trequest->handle = NULL;\n\tlist_for_each_entry(_entry, &dev->maplist, head) {\n\t\tif (_entry->map == map) {\n\t\t\trequest->handle =\n\t\t\t    (void *)(unsigned long)_entry->user_token;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&dev->struct_mutex);\n\n\tif (request->handle == NULL)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint drm_legacy_setsareactx(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file_priv)\n{\n\tstruct drm_ctx_priv_map *request = data;\n\tstruct drm_local_map *map = NULL;\n\tstruct drm_map_list *r_list = NULL;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&dev->struct_mutex);\n\tlist_for_each_entry(r_list, &dev->maplist, head) {\n\t\tif (r_list->map\n\t\t    && r_list->user_token == (unsigned long) request->handle)\n\t\t\tgoto found;\n\t}\n      bad:\n\tmutex_unlock(&dev->struct_mutex);\n\treturn -EINVAL;\n\n      found:\n\tmap = r_list->map;\n\tif (!map)\n\t\tgoto bad;\n\n\tif (IS_ERR(idr_replace(&dev->ctx_idr, map, request->ctx_id)))\n\t\tgoto bad;\n\n\tmutex_unlock(&dev->struct_mutex);\n\n\treturn 0;\n}\n\n \n\n \n \n \n\n \nstatic int drm_context_switch(struct drm_device * dev, int old, int new)\n{\n\tif (test_and_set_bit(0, &dev->context_flag)) {\n\t\tDRM_ERROR(\"Reentering -- FIXME\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tDRM_DEBUG(\"Context switch from %d to %d\\n\", old, new);\n\n\tif (new == dev->last_context) {\n\t\tclear_bit(0, &dev->context_flag);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int drm_context_switch_complete(struct drm_device *dev,\n\t\t\t\t       struct drm_file *file_priv, int new)\n{\n\tdev->last_context = new;\t \n\n\tif (!_DRM_LOCK_IS_HELD(file_priv->master->lock.hw_lock->lock)) {\n\t\tDRM_ERROR(\"Lock isn't held after context switch\\n\");\n\t}\n\n\t \n\tclear_bit(0, &dev->context_flag);\n\n\treturn 0;\n}\n\n \nint drm_legacy_resctx(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_ctx_res *res = data;\n\tstruct drm_ctx ctx;\n\tint i;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\tif (res->count >= DRM_RESERVED_CONTEXTS) {\n\t\tmemset(&ctx, 0, sizeof(ctx));\n\t\tfor (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {\n\t\t\tctx.handle = i;\n\t\t\tif (copy_to_user(&res->contexts[i], &ctx, sizeof(ctx)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tres->count = DRM_RESERVED_CONTEXTS;\n\n\treturn 0;\n}\n\n \nint drm_legacy_addctx(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_ctx_list *ctx_entry;\n\tstruct drm_ctx *ctx = data;\n\tint tmp_handle;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\ttmp_handle = drm_legacy_ctxbitmap_next(dev);\n\tif (tmp_handle == DRM_KERNEL_CONTEXT) {\n\t\t \n\t\ttmp_handle = drm_legacy_ctxbitmap_next(dev);\n\t}\n\tDRM_DEBUG(\"%d\\n\", tmp_handle);\n\tif (tmp_handle < 0) {\n\t\tDRM_DEBUG(\"Not enough free contexts.\\n\");\n\t\t \n\t\treturn tmp_handle;\n\t}\n\n\tctx->handle = tmp_handle;\n\n\tctx_entry = kmalloc(sizeof(*ctx_entry), GFP_KERNEL);\n\tif (!ctx_entry) {\n\t\tDRM_DEBUG(\"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&ctx_entry->head);\n\tctx_entry->handle = ctx->handle;\n\tctx_entry->tag = file_priv;\n\n\tmutex_lock(&dev->ctxlist_mutex);\n\tlist_add(&ctx_entry->head, &dev->ctxlist);\n\tmutex_unlock(&dev->ctxlist_mutex);\n\n\treturn 0;\n}\n\n \nint drm_legacy_getctx(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_ctx *ctx = data;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tctx->flags = 0;\n\n\treturn 0;\n}\n\n \nint drm_legacy_switchctx(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *file_priv)\n{\n\tstruct drm_ctx *ctx = data;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\tDRM_DEBUG(\"%d\\n\", ctx->handle);\n\treturn drm_context_switch(dev, dev->last_context, ctx->handle);\n}\n\n \nint drm_legacy_newctx(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_ctx *ctx = data;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\tDRM_DEBUG(\"%d\\n\", ctx->handle);\n\tdrm_context_switch_complete(dev, file_priv, ctx->handle);\n\n\treturn 0;\n}\n\n \nint drm_legacy_rmctx(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file_priv)\n{\n\tstruct drm_ctx *ctx = data;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\tDRM_DEBUG(\"%d\\n\", ctx->handle);\n\tif (ctx->handle != DRM_KERNEL_CONTEXT) {\n\t\tif (dev->driver->context_dtor)\n\t\t\tdev->driver->context_dtor(dev, ctx->handle);\n\t\tdrm_legacy_ctxbitmap_free(dev, ctx->handle);\n\t}\n\n\tmutex_lock(&dev->ctxlist_mutex);\n\tif (!list_empty(&dev->ctxlist)) {\n\t\tstruct drm_ctx_list *pos, *n;\n\n\t\tlist_for_each_entry_safe(pos, n, &dev->ctxlist, head) {\n\t\t\tif (pos->handle == ctx->handle) {\n\t\t\t\tlist_del(&pos->head);\n\t\t\t\tkfree(pos);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&dev->ctxlist_mutex);\n\n\treturn 0;\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}