{
  "module_name": "drm_gem_framebuffer_helper.c",
  "hash_id": "b74cb03ee7b1a4531b4fed2e54ae7e1793d156b78d21a524197f492cb3b0d11c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_gem_framebuffer_helper.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_modeset_helper.h>\n\n#include \"drm_internal.h\"\n\nMODULE_IMPORT_NS(DMA_BUF);\n\n#define AFBC_HEADER_SIZE\t\t16\n#define AFBC_TH_LAYOUT_ALIGNMENT\t8\n#define AFBC_HDR_ALIGN\t\t\t64\n#define AFBC_SUPERBLOCK_PIXELS\t\t256\n#define AFBC_SUPERBLOCK_ALIGNMENT\t128\n#define AFBC_TH_BODY_START_ALIGNMENT\t4096\n\n \n\n \nstruct drm_gem_object *drm_gem_fb_get_obj(struct drm_framebuffer *fb,\n\t\t\t\t\t  unsigned int plane)\n{\n\tstruct drm_device *dev = fb->dev;\n\n\tif (drm_WARN_ON_ONCE(dev, plane >= ARRAY_SIZE(fb->obj)))\n\t\treturn NULL;\n\telse if (drm_WARN_ON_ONCE(dev, !fb->obj[plane]))\n\t\treturn NULL;\n\n\treturn fb->obj[plane];\n}\nEXPORT_SYMBOL_GPL(drm_gem_fb_get_obj);\n\nstatic int\ndrm_gem_fb_init(struct drm_device *dev,\n\t\t struct drm_framebuffer *fb,\n\t\t const struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t struct drm_gem_object **obj, unsigned int num_planes,\n\t\t const struct drm_framebuffer_funcs *funcs)\n{\n\tunsigned int i;\n\tint ret;\n\n\tdrm_helper_mode_fill_fb_struct(dev, fb, mode_cmd);\n\n\tfor (i = 0; i < num_planes; i++)\n\t\tfb->obj[i] = obj[i];\n\n\tret = drm_framebuffer_init(dev, fb, funcs);\n\tif (ret)\n\t\tdrm_err(dev, \"Failed to init framebuffer: %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nvoid drm_gem_fb_destroy(struct drm_framebuffer *fb)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < fb->format->num_planes; i++)\n\t\tdrm_gem_object_put(fb->obj[i]);\n\n\tdrm_framebuffer_cleanup(fb);\n\tkfree(fb);\n}\nEXPORT_SYMBOL(drm_gem_fb_destroy);\n\n \nint drm_gem_fb_create_handle(struct drm_framebuffer *fb, struct drm_file *file,\n\t\t\t     unsigned int *handle)\n{\n\treturn drm_gem_handle_create(file, fb->obj[0], handle);\n}\nEXPORT_SYMBOL(drm_gem_fb_create_handle);\n\n \nint drm_gem_fb_init_with_funcs(struct drm_device *dev,\n\t\t\t       struct drm_framebuffer *fb,\n\t\t\t       struct drm_file *file,\n\t\t\t       const struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t\t       const struct drm_framebuffer_funcs *funcs)\n{\n\tconst struct drm_format_info *info;\n\tstruct drm_gem_object *objs[DRM_FORMAT_MAX_PLANES];\n\tunsigned int i;\n\tint ret;\n\n\tinfo = drm_get_format_info(dev, mode_cmd);\n\tif (!info) {\n\t\tdrm_dbg_kms(dev, \"Failed to get FB format info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (drm_drv_uses_atomic_modeset(dev) &&\n\t    !drm_any_plane_has_format(dev, mode_cmd->pixel_format,\n\t\t\t\t      mode_cmd->modifier[0])) {\n\t\tdrm_dbg_kms(dev, \"Unsupported pixel format %p4cc / modifier 0x%llx\\n\",\n\t\t\t    &mode_cmd->pixel_format, mode_cmd->modifier[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < info->num_planes; i++) {\n\t\tunsigned int width = mode_cmd->width / (i ? info->hsub : 1);\n\t\tunsigned int height = mode_cmd->height / (i ? info->vsub : 1);\n\t\tunsigned int min_size;\n\n\t\tobjs[i] = drm_gem_object_lookup(file, mode_cmd->handles[i]);\n\t\tif (!objs[i]) {\n\t\t\tdrm_dbg_kms(dev, \"Failed to lookup GEM object\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto err_gem_object_put;\n\t\t}\n\n\t\tmin_size = (height - 1) * mode_cmd->pitches[i]\n\t\t\t + drm_format_info_min_pitch(info, i, width)\n\t\t\t + mode_cmd->offsets[i];\n\n\t\tif (objs[i]->size < min_size) {\n\t\t\tdrm_dbg_kms(dev,\n\t\t\t\t    \"GEM object size (%zu) smaller than minimum size (%u) for plane %d\\n\",\n\t\t\t\t    objs[i]->size, min_size, i);\n\t\t\tdrm_gem_object_put(objs[i]);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_gem_object_put;\n\t\t}\n\t}\n\n\tret = drm_gem_fb_init(dev, fb, mode_cmd, objs, i, funcs);\n\tif (ret)\n\t\tgoto err_gem_object_put;\n\n\treturn 0;\n\nerr_gem_object_put:\n\twhile (i > 0) {\n\t\t--i;\n\t\tdrm_gem_object_put(objs[i]);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(drm_gem_fb_init_with_funcs);\n\n \nstruct drm_framebuffer *\ndrm_gem_fb_create_with_funcs(struct drm_device *dev, struct drm_file *file,\n\t\t\t     const struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t\t     const struct drm_framebuffer_funcs *funcs)\n{\n\tstruct drm_framebuffer *fb;\n\tint ret;\n\n\tfb = kzalloc(sizeof(*fb), GFP_KERNEL);\n\tif (!fb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = drm_gem_fb_init_with_funcs(dev, fb, file, mode_cmd, funcs);\n\tif (ret) {\n\t\tkfree(fb);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn fb;\n}\nEXPORT_SYMBOL_GPL(drm_gem_fb_create_with_funcs);\n\nstatic const struct drm_framebuffer_funcs drm_gem_fb_funcs = {\n\t.destroy\t= drm_gem_fb_destroy,\n\t.create_handle\t= drm_gem_fb_create_handle,\n};\n\n \nstruct drm_framebuffer *\ndrm_gem_fb_create(struct drm_device *dev, struct drm_file *file,\n\t\t  const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\treturn drm_gem_fb_create_with_funcs(dev, file, mode_cmd,\n\t\t\t\t\t    &drm_gem_fb_funcs);\n}\nEXPORT_SYMBOL_GPL(drm_gem_fb_create);\n\nstatic const struct drm_framebuffer_funcs drm_gem_fb_funcs_dirtyfb = {\n\t.destroy\t= drm_gem_fb_destroy,\n\t.create_handle\t= drm_gem_fb_create_handle,\n\t.dirty\t\t= drm_atomic_helper_dirtyfb,\n};\n\n \nstruct drm_framebuffer *\ndrm_gem_fb_create_with_dirty(struct drm_device *dev, struct drm_file *file,\n\t\t\t     const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\treturn drm_gem_fb_create_with_funcs(dev, file, mode_cmd,\n\t\t\t\t\t    &drm_gem_fb_funcs_dirtyfb);\n}\nEXPORT_SYMBOL_GPL(drm_gem_fb_create_with_dirty);\n\n \nint drm_gem_fb_vmap(struct drm_framebuffer *fb, struct iosys_map *map,\n\t\t    struct iosys_map *data)\n{\n\tstruct drm_gem_object *obj;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < fb->format->num_planes; ++i) {\n\t\tobj = drm_gem_fb_get_obj(fb, i);\n\t\tif (!obj) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_drm_gem_vunmap;\n\t\t}\n\t\tret = drm_gem_vmap_unlocked(obj, &map[i]);\n\t\tif (ret)\n\t\t\tgoto err_drm_gem_vunmap;\n\t}\n\n\tif (data) {\n\t\tfor (i = 0; i < fb->format->num_planes; ++i) {\n\t\t\tmemcpy(&data[i], &map[i], sizeof(data[i]));\n\t\t\tif (iosys_map_is_null(&data[i]))\n\t\t\t\tcontinue;\n\t\t\tiosys_map_incr(&data[i], fb->offsets[i]);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_drm_gem_vunmap:\n\twhile (i) {\n\t\t--i;\n\t\tobj = drm_gem_fb_get_obj(fb, i);\n\t\tif (!obj)\n\t\t\tcontinue;\n\t\tdrm_gem_vunmap_unlocked(obj, &map[i]);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_gem_fb_vmap);\n\n \nvoid drm_gem_fb_vunmap(struct drm_framebuffer *fb, struct iosys_map *map)\n{\n\tunsigned int i = fb->format->num_planes;\n\tstruct drm_gem_object *obj;\n\n\twhile (i) {\n\t\t--i;\n\t\tobj = drm_gem_fb_get_obj(fb, i);\n\t\tif (!obj)\n\t\t\tcontinue;\n\t\tif (iosys_map_is_null(&map[i]))\n\t\t\tcontinue;\n\t\tdrm_gem_vunmap_unlocked(obj, &map[i]);\n\t}\n}\nEXPORT_SYMBOL(drm_gem_fb_vunmap);\n\nstatic void __drm_gem_fb_end_cpu_access(struct drm_framebuffer *fb, enum dma_data_direction dir,\n\t\t\t\t\tunsigned int num_planes)\n{\n\tstruct dma_buf_attachment *import_attach;\n\tstruct drm_gem_object *obj;\n\tint ret;\n\n\twhile (num_planes) {\n\t\t--num_planes;\n\t\tobj = drm_gem_fb_get_obj(fb, num_planes);\n\t\tif (!obj)\n\t\t\tcontinue;\n\t\timport_attach = obj->import_attach;\n\t\tif (!import_attach)\n\t\t\tcontinue;\n\t\tret = dma_buf_end_cpu_access(import_attach->dmabuf, dir);\n\t\tif (ret)\n\t\t\tdrm_err(fb->dev, \"dma_buf_end_cpu_access(%u, %d) failed: %d\\n\",\n\t\t\t\tret, num_planes, dir);\n\t}\n}\n\n \nint drm_gem_fb_begin_cpu_access(struct drm_framebuffer *fb, enum dma_data_direction dir)\n{\n\tstruct dma_buf_attachment *import_attach;\n\tstruct drm_gem_object *obj;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < fb->format->num_planes; ++i) {\n\t\tobj = drm_gem_fb_get_obj(fb, i);\n\t\tif (!obj) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err___drm_gem_fb_end_cpu_access;\n\t\t}\n\t\timport_attach = obj->import_attach;\n\t\tif (!import_attach)\n\t\t\tcontinue;\n\t\tret = dma_buf_begin_cpu_access(import_attach->dmabuf, dir);\n\t\tif (ret)\n\t\t\tgoto err___drm_gem_fb_end_cpu_access;\n\t}\n\n\treturn 0;\n\nerr___drm_gem_fb_end_cpu_access:\n\t__drm_gem_fb_end_cpu_access(fb, dir, i);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_gem_fb_begin_cpu_access);\n\n \nvoid drm_gem_fb_end_cpu_access(struct drm_framebuffer *fb, enum dma_data_direction dir)\n{\n\t__drm_gem_fb_end_cpu_access(fb, dir, fb->format->num_planes);\n}\nEXPORT_SYMBOL(drm_gem_fb_end_cpu_access);\n\n \n \nstatic __u32 drm_gem_afbc_get_bpp(struct drm_device *dev,\n\t\t\t\t  const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tconst struct drm_format_info *info;\n\n\tinfo = drm_get_format_info(dev, mode_cmd);\n\n\tswitch (info->format) {\n\tcase DRM_FORMAT_YUV420_8BIT:\n\t\treturn 12;\n\tcase DRM_FORMAT_YUV420_10BIT:\n\t\treturn 15;\n\tcase DRM_FORMAT_VUY101010:\n\t\treturn 30;\n\tdefault:\n\t\treturn drm_format_info_bpp(info, 0);\n\t}\n}\n\nstatic int drm_gem_afbc_min_size(struct drm_device *dev,\n\t\t\t\t const struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t\t\t struct drm_afbc_framebuffer *afbc_fb)\n{\n\t__u32 n_blocks, w_alignment, h_alignment, hdr_alignment;\n\t \n\t__u32 bpp;\n\n\tswitch (mode_cmd->modifier[0] & AFBC_FORMAT_MOD_BLOCK_SIZE_MASK) {\n\tcase AFBC_FORMAT_MOD_BLOCK_SIZE_16x16:\n\t\tafbc_fb->block_width = 16;\n\t\tafbc_fb->block_height = 16;\n\t\tbreak;\n\tcase AFBC_FORMAT_MOD_BLOCK_SIZE_32x8:\n\t\tafbc_fb->block_width = 32;\n\t\tafbc_fb->block_height = 8;\n\t\tbreak;\n\t \n\tcase AFBC_FORMAT_MOD_BLOCK_SIZE_64x4:\n\tcase AFBC_FORMAT_MOD_BLOCK_SIZE_32x8_64x4:\n\tdefault:\n\t\tdrm_dbg_kms(dev, \"Invalid AFBC_FORMAT_MOD_BLOCK_SIZE: %lld.\\n\",\n\t\t\t    mode_cmd->modifier[0]\n\t\t\t    & AFBC_FORMAT_MOD_BLOCK_SIZE_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tw_alignment = afbc_fb->block_width;\n\th_alignment = afbc_fb->block_height;\n\thdr_alignment = AFBC_HDR_ALIGN;\n\tif (mode_cmd->modifier[0] & AFBC_FORMAT_MOD_TILED) {\n\t\tw_alignment *= AFBC_TH_LAYOUT_ALIGNMENT;\n\t\th_alignment *= AFBC_TH_LAYOUT_ALIGNMENT;\n\t\thdr_alignment = AFBC_TH_BODY_START_ALIGNMENT;\n\t}\n\n\tafbc_fb->aligned_width = ALIGN(mode_cmd->width, w_alignment);\n\tafbc_fb->aligned_height = ALIGN(mode_cmd->height, h_alignment);\n\tafbc_fb->offset = mode_cmd->offsets[0];\n\n\tbpp = drm_gem_afbc_get_bpp(dev, mode_cmd);\n\tif (!bpp) {\n\t\tdrm_dbg_kms(dev, \"Invalid AFBC bpp value: %d\\n\", bpp);\n\t\treturn -EINVAL;\n\t}\n\n\tn_blocks = (afbc_fb->aligned_width * afbc_fb->aligned_height)\n\t\t   / AFBC_SUPERBLOCK_PIXELS;\n\tafbc_fb->afbc_size = ALIGN(n_blocks * AFBC_HEADER_SIZE, hdr_alignment);\n\tafbc_fb->afbc_size += n_blocks * ALIGN(bpp * AFBC_SUPERBLOCK_PIXELS / 8,\n\t\t\t\t\t       AFBC_SUPERBLOCK_ALIGNMENT);\n\n\treturn 0;\n}\n\n \nint drm_gem_fb_afbc_init(struct drm_device *dev,\n\t\t\t const struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t\t struct drm_afbc_framebuffer *afbc_fb)\n{\n\tconst struct drm_format_info *info;\n\tstruct drm_gem_object **objs;\n\tint ret;\n\n\tobjs = afbc_fb->base.obj;\n\tinfo = drm_get_format_info(dev, mode_cmd);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tret = drm_gem_afbc_min_size(dev, mode_cmd, afbc_fb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (objs[0]->size < afbc_fb->afbc_size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(drm_gem_fb_afbc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}