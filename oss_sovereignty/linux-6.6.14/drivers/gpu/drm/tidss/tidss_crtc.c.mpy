{
  "module_name": "tidss_crtc.c",
  "hash_id": "0aaf1e83d3992c9d43b44376d8fa82ad9018c9dc842864b3babe73e6a477aeb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tidss/tidss_crtc.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"tidss_crtc.h\"\n#include \"tidss_dispc.h\"\n#include \"tidss_drv.h\"\n#include \"tidss_irq.h\"\n#include \"tidss_plane.h\"\n\n \n\nstatic void tidss_crtc_finish_page_flip(struct tidss_crtc *tcrtc)\n{\n\tstruct drm_device *ddev = tcrtc->crtc.dev;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\tstruct drm_pending_vblank_event *event;\n\tunsigned long flags;\n\tbool busy;\n\n\tspin_lock_irqsave(&ddev->event_lock, flags);\n\n\t \n\tbusy = dispc_vp_go_busy(tidss->dispc, tcrtc->hw_videoport);\n\tif (busy) {\n\t\tspin_unlock_irqrestore(&ddev->event_lock, flags);\n\t\treturn;\n\t}\n\n\tevent = tcrtc->event;\n\ttcrtc->event = NULL;\n\n\tif (!event) {\n\t\tspin_unlock_irqrestore(&ddev->event_lock, flags);\n\t\treturn;\n\t}\n\n\tdrm_crtc_send_vblank_event(&tcrtc->crtc, event);\n\n\tspin_unlock_irqrestore(&ddev->event_lock, flags);\n\n\tdrm_crtc_vblank_put(&tcrtc->crtc);\n}\n\nvoid tidss_crtc_vblank_irq(struct drm_crtc *crtc)\n{\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\n\tdrm_crtc_handle_vblank(crtc);\n\n\ttidss_crtc_finish_page_flip(tcrtc);\n}\n\nvoid tidss_crtc_framedone_irq(struct drm_crtc *crtc)\n{\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\n\tcomplete(&tcrtc->framedone_completion);\n}\n\nvoid tidss_crtc_error_irq(struct drm_crtc *crtc, u64 irqstatus)\n{\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\n\tdev_err_ratelimited(crtc->dev->dev, \"CRTC%u SYNC LOST: (irq %llx)\\n\",\n\t\t\t    tcrtc->hw_videoport, irqstatus);\n}\n\n \n\nstatic int tidss_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\tstruct dispc_device *dispc = tidss->dispc;\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\tu32 hw_videoport = tcrtc->hw_videoport;\n\tconst struct drm_display_mode *mode;\n\tenum drm_mode_status ok;\n\n\tdev_dbg(ddev->dev, \"%s\\n\", __func__);\n\n\tif (!crtc_state->enable)\n\t\treturn 0;\n\n\tmode = &crtc_state->adjusted_mode;\n\n\tok = dispc_vp_mode_valid(dispc, hw_videoport, mode);\n\tif (ok != MODE_OK) {\n\t\tdev_dbg(ddev->dev, \"%s: bad mode: %ux%u pclk %u kHz\\n\",\n\t\t\t__func__, mode->hdisplay, mode->vdisplay, mode->clock);\n\t\treturn -EINVAL;\n\t}\n\n\treturn dispc_vp_bus_check(dispc, hw_videoport, crtc_state);\n}\n\n \nstatic void tidss_crtc_position_planes(struct tidss_device *tidss,\n\t\t\t\t       struct drm_crtc *crtc,\n\t\t\t\t       struct drm_crtc_state *old_state,\n\t\t\t\t       bool newmodeset)\n{\n\tstruct drm_atomic_state *ostate = old_state->state;\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\tstruct drm_crtc_state *cstate = crtc->state;\n\tint layer;\n\n\tif (!newmodeset && !cstate->zpos_changed &&\n\t    !to_tidss_crtc_state(cstate)->plane_pos_changed)\n\t\treturn;\n\n\tfor (layer = 0; layer < tidss->feat->num_planes; layer++) {\n\t\tstruct drm_plane_state *pstate;\n\t\tstruct drm_plane *plane;\n\t\tbool layer_active = false;\n\t\tint i;\n\n\t\tfor_each_new_plane_in_state(ostate, plane, pstate, i) {\n\t\t\tif (pstate->crtc != crtc || !pstate->visible)\n\t\t\t\tcontinue;\n\n\t\t\tif (pstate->normalized_zpos == layer) {\n\t\t\t\tlayer_active = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (layer_active) {\n\t\t\tstruct tidss_plane *tplane = to_tidss_plane(plane);\n\n\t\t\tdispc_ovr_set_plane(tidss->dispc, tplane->hw_plane_id,\n\t\t\t\t\t    tcrtc->hw_videoport,\n\t\t\t\t\t    pstate->crtc_x, pstate->crtc_y,\n\t\t\t\t\t    layer);\n\t\t}\n\t\tdispc_ovr_enable_layer(tidss->dispc, tcrtc->hw_videoport, layer,\n\t\t\t\t       layer_active);\n\t}\n}\n\nstatic void tidss_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t      crtc);\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\tunsigned long flags;\n\n\tdev_dbg(ddev->dev,\n\t\t\"%s: %s enabled %d, needs modeset %d, event %p\\n\", __func__,\n\t\tcrtc->name, drm_atomic_crtc_needs_modeset(crtc->state),\n\t\tcrtc->state->enable, crtc->state->event);\n\n\t \n\tif (!crtc->state->enable)\n\t\treturn;\n\n\t \n\tif (drm_atomic_crtc_needs_modeset(crtc->state))\n\t\treturn;\n\n\t \n\tif (WARN_ON(dispc_vp_go_busy(tidss->dispc, tcrtc->hw_videoport)))\n\t\treturn;\n\n\t \n\tif (WARN_ON(!crtc->state->event))\n\t\treturn;\n\n\t \n\tdispc_vp_setup(tidss->dispc, tcrtc->hw_videoport, crtc->state, false);\n\n\t \n\ttidss_crtc_position_planes(tidss, crtc, old_crtc_state, false);\n\n\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\n\tspin_lock_irqsave(&ddev->event_lock, flags);\n\tdispc_vp_go(tidss->dispc, tcrtc->hw_videoport);\n\n\tWARN_ON(tcrtc->event);\n\n\ttcrtc->event = crtc->state->event;\n\tcrtc->state->event = NULL;\n\n\tspin_unlock_irqrestore(&ddev->event_lock, flags);\n}\n\nstatic void tidss_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t crtc);\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\tconst struct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tunsigned long flags;\n\tint r;\n\n\tdev_dbg(ddev->dev, \"%s, event %p\\n\", __func__, crtc->state->event);\n\n\ttidss_runtime_get(tidss);\n\n\tr = dispc_vp_set_clk_rate(tidss->dispc, tcrtc->hw_videoport,\n\t\t\t\t  mode->clock * 1000);\n\tif (r != 0)\n\t\treturn;\n\n\tr = dispc_vp_enable_clk(tidss->dispc, tcrtc->hw_videoport);\n\tif (r != 0)\n\t\treturn;\n\n\tdispc_vp_setup(tidss->dispc, tcrtc->hw_videoport, crtc->state, true);\n\ttidss_crtc_position_planes(tidss, crtc, old_state, true);\n\n\t \n\tdrm_crtc_vblank_on(crtc);\n\n\tdispc_vp_prepare(tidss->dispc, tcrtc->hw_videoport, crtc->state);\n\n\tdispc_vp_enable(tidss->dispc, tcrtc->hw_videoport, crtc->state);\n\n\tspin_lock_irqsave(&ddev->event_lock, flags);\n\n\tif (crtc->state->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&ddev->event_lock, flags);\n}\n\nstatic void tidss_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\tunsigned long flags;\n\n\tdev_dbg(ddev->dev, \"%s, event %p\\n\", __func__, crtc->state->event);\n\n\treinit_completion(&tcrtc->framedone_completion);\n\n\tdispc_vp_disable(tidss->dispc, tcrtc->hw_videoport);\n\n\tif (!wait_for_completion_timeout(&tcrtc->framedone_completion,\n\t\t\t\t\t msecs_to_jiffies(500)))\n\t\tdev_err(tidss->dev, \"Timeout waiting for framedone on crtc %d\",\n\t\t\ttcrtc->hw_videoport);\n\n\tdispc_vp_unprepare(tidss->dispc, tcrtc->hw_videoport);\n\n\tspin_lock_irqsave(&ddev->event_lock, flags);\n\tif (crtc->state->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irqrestore(&ddev->event_lock, flags);\n\n\tdrm_crtc_vblank_off(crtc);\n\n\tdispc_vp_disable_clk(tidss->dispc, tcrtc->hw_videoport);\n\n\ttidss_runtime_put(tidss);\n}\n\nstatic\nenum drm_mode_status tidss_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\n\treturn dispc_vp_mode_valid(tidss->dispc, tcrtc->hw_videoport, mode);\n}\n\nstatic const struct drm_crtc_helper_funcs tidss_crtc_helper_funcs = {\n\t.atomic_check = tidss_crtc_atomic_check,\n\t.atomic_flush = tidss_crtc_atomic_flush,\n\t.atomic_enable = tidss_crtc_atomic_enable,\n\t.atomic_disable = tidss_crtc_atomic_disable,\n\n\t.mode_valid = tidss_crtc_mode_valid,\n};\n\n \n\nstatic int tidss_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\n\tdev_dbg(ddev->dev, \"%s\\n\", __func__);\n\n\ttidss_runtime_get(tidss);\n\n\ttidss_irq_enable_vblank(crtc);\n\n\treturn 0;\n}\n\nstatic void tidss_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\n\tdev_dbg(ddev->dev, \"%s\\n\", __func__);\n\n\ttidss_irq_disable_vblank(crtc);\n\n\ttidss_runtime_put(tidss);\n}\n\nstatic void tidss_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct tidss_crtc_state *tcrtc;\n\n\tif (crtc->state)\n\t\t__drm_atomic_helper_crtc_destroy_state(crtc->state);\n\n\tkfree(crtc->state);\n\n\ttcrtc = kzalloc(sizeof(*tcrtc), GFP_KERNEL);\n\tif (!tcrtc) {\n\t\tcrtc->state = NULL;\n\t\treturn;\n\t}\n\n\t__drm_atomic_helper_crtc_reset(crtc, &tcrtc->base);\n}\n\nstatic struct drm_crtc_state *tidss_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct tidss_crtc_state *state, *current_state;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tcurrent_state = to_tidss_crtc_state(crtc->state);\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);\n\n\tstate->plane_pos_changed = false;\n\n\tstate->bus_format = current_state->bus_format;\n\tstate->bus_flags = current_state->bus_flags;\n\n\treturn &state->base;\n}\n\nstatic void tidss_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\n\tdrm_crtc_cleanup(crtc);\n\tkfree(tcrtc);\n}\n\nstatic const struct drm_crtc_funcs tidss_crtc_funcs = {\n\t.reset = tidss_crtc_reset,\n\t.destroy = tidss_crtc_destroy,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = tidss_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank = tidss_crtc_enable_vblank,\n\t.disable_vblank = tidss_crtc_disable_vblank,\n};\n\nstruct tidss_crtc *tidss_crtc_create(struct tidss_device *tidss,\n\t\t\t\t     u32 hw_videoport,\n\t\t\t\t     struct drm_plane *primary)\n{\n\tstruct tidss_crtc *tcrtc;\n\tstruct drm_crtc *crtc;\n\tunsigned int gamma_lut_size = 0;\n\tbool has_ctm = tidss->feat->vp_feat.color.has_ctm;\n\tint ret;\n\n\ttcrtc = kzalloc(sizeof(*tcrtc), GFP_KERNEL);\n\tif (!tcrtc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttcrtc->hw_videoport = hw_videoport;\n\tinit_completion(&tcrtc->framedone_completion);\n\n\tcrtc =  &tcrtc->crtc;\n\n\tret = drm_crtc_init_with_planes(&tidss->ddev, crtc, primary,\n\t\t\t\t\tNULL, &tidss_crtc_funcs, NULL);\n\tif (ret < 0) {\n\t\tkfree(tcrtc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrm_crtc_helper_add(crtc, &tidss_crtc_helper_funcs);\n\n\t \n\tif (tidss->feat->vp_feat.color.gamma_size)\n\t\tgamma_lut_size = 256;\n\n\tdrm_crtc_enable_color_mgmt(crtc, 0, has_ctm, gamma_lut_size);\n\tif (gamma_lut_size)\n\t\tdrm_mode_crtc_set_gamma_size(crtc, gamma_lut_size);\n\n\treturn tcrtc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}