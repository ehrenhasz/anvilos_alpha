{
  "module_name": "tidss_dispc.c",
  "hash_id": "97315f79476f27c09a8e2604430422cce31a1dba2d63a33d89cb8521714de848",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tidss/tidss_dispc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/sys_soc.h>\n\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_panel.h>\n\n#include \"tidss_crtc.h\"\n#include \"tidss_dispc.h\"\n#include \"tidss_drv.h\"\n#include \"tidss_irq.h\"\n#include \"tidss_plane.h\"\n\n#include \"tidss_dispc_regs.h\"\n#include \"tidss_scale_coefs.h\"\n\nstatic const u16 tidss_k2g_common_regs[DISPC_COMMON_REG_TABLE_LEN] = {\n\t[DSS_REVISION_OFF] =                    0x00,\n\t[DSS_SYSCONFIG_OFF] =                   0x04,\n\t[DSS_SYSSTATUS_OFF] =                   0x08,\n\t[DISPC_IRQ_EOI_OFF] =                   0x20,\n\t[DISPC_IRQSTATUS_RAW_OFF] =             0x24,\n\t[DISPC_IRQSTATUS_OFF] =                 0x28,\n\t[DISPC_IRQENABLE_SET_OFF] =             0x2c,\n\t[DISPC_IRQENABLE_CLR_OFF] =             0x30,\n\n\t[DISPC_GLOBAL_MFLAG_ATTRIBUTE_OFF] =    0x40,\n\t[DISPC_GLOBAL_BUFFER_OFF] =             0x44,\n\n\t[DISPC_DBG_CONTROL_OFF] =               0x4c,\n\t[DISPC_DBG_STATUS_OFF] =                0x50,\n\n\t[DISPC_CLKGATING_DISABLE_OFF] =         0x54,\n};\n\nconst struct dispc_features dispc_k2g_feats = {\n\t.min_pclk_khz = 4375,\n\n\t.max_pclk_khz = {\n\t\t[DISPC_VP_DPI] = 150000,\n\t},\n\n\t \n\t.scaling = {\n\t\t.in_width_max_5tap_rgb = 1280,\n\t\t.in_width_max_3tap_rgb = 1280,\n\t\t.in_width_max_5tap_yuv = 2560,\n\t\t.in_width_max_3tap_yuv = 2560,\n\t\t.upscale_limit = 16,\n\t\t.downscale_limit_5tap = 4,\n\t\t.downscale_limit_3tap = 2,\n\t\t \n\t\t.xinc_max = 32,\n\t},\n\n\t.subrev = DISPC_K2G,\n\n\t.common = \"common\",\n\n\t.common_regs = tidss_k2g_common_regs,\n\n\t.num_vps = 1,\n\t.vp_name = { \"vp1\" },\n\t.ovr_name = { \"ovr1\" },\n\t.vpclk_name =  { \"vp1\" },\n\t.vp_bus_type = { DISPC_VP_DPI },\n\n\t.vp_feat = { .color = {\n\t\t\t.has_ctm = true,\n\t\t\t.gamma_size = 256,\n\t\t\t.gamma_type = TIDSS_GAMMA_8BIT,\n\t\t},\n\t},\n\n\t.num_planes = 1,\n\t.vid_name = { \"vid1\" },\n\t.vid_lite = { false },\n\t.vid_order = { 0 },\n};\n\nstatic const u16 tidss_am65x_common_regs[DISPC_COMMON_REG_TABLE_LEN] = {\n\t[DSS_REVISION_OFF] =\t\t\t0x4,\n\t[DSS_SYSCONFIG_OFF] =\t\t\t0x8,\n\t[DSS_SYSSTATUS_OFF] =\t\t\t0x20,\n\t[DISPC_IRQ_EOI_OFF] =\t\t\t0x24,\n\t[DISPC_IRQSTATUS_RAW_OFF] =\t\t0x28,\n\t[DISPC_IRQSTATUS_OFF] =\t\t\t0x2c,\n\t[DISPC_IRQENABLE_SET_OFF] =\t\t0x30,\n\t[DISPC_IRQENABLE_CLR_OFF] =\t\t0x40,\n\t[DISPC_VID_IRQENABLE_OFF] =\t\t0x44,\n\t[DISPC_VID_IRQSTATUS_OFF] =\t\t0x58,\n\t[DISPC_VP_IRQENABLE_OFF] =\t\t0x70,\n\t[DISPC_VP_IRQSTATUS_OFF] =\t\t0x7c,\n\n\t[WB_IRQENABLE_OFF] =\t\t\t0x88,\n\t[WB_IRQSTATUS_OFF] =\t\t\t0x8c,\n\n\t[DISPC_GLOBAL_MFLAG_ATTRIBUTE_OFF] =\t0x90,\n\t[DISPC_GLOBAL_OUTPUT_ENABLE_OFF] =\t0x94,\n\t[DISPC_GLOBAL_BUFFER_OFF] =\t\t0x98,\n\t[DSS_CBA_CFG_OFF] =\t\t\t0x9c,\n\t[DISPC_DBG_CONTROL_OFF] =\t\t0xa0,\n\t[DISPC_DBG_STATUS_OFF] =\t\t0xa4,\n\t[DISPC_CLKGATING_DISABLE_OFF] =\t\t0xa8,\n\t[DISPC_SECURE_DISABLE_OFF] =\t\t0xac,\n};\n\nconst struct dispc_features dispc_am65x_feats = {\n\t.max_pclk_khz = {\n\t\t[DISPC_VP_DPI] = 165000,\n\t\t[DISPC_VP_OLDI] = 165000,\n\t},\n\n\t.scaling = {\n\t\t.in_width_max_5tap_rgb = 1280,\n\t\t.in_width_max_3tap_rgb = 2560,\n\t\t.in_width_max_5tap_yuv = 2560,\n\t\t.in_width_max_3tap_yuv = 4096,\n\t\t.upscale_limit = 16,\n\t\t.downscale_limit_5tap = 4,\n\t\t.downscale_limit_3tap = 2,\n\t\t \n\t\t.xinc_max = 32,\n\t},\n\n\t.subrev = DISPC_AM65X,\n\n\t.common = \"common\",\n\t.common_regs = tidss_am65x_common_regs,\n\n\t.num_vps = 2,\n\t.vp_name = { \"vp1\", \"vp2\" },\n\t.ovr_name = { \"ovr1\", \"ovr2\" },\n\t.vpclk_name =  { \"vp1\", \"vp2\" },\n\t.vp_bus_type = { DISPC_VP_OLDI, DISPC_VP_DPI },\n\n\t.vp_feat = { .color = {\n\t\t\t.has_ctm = true,\n\t\t\t.gamma_size = 256,\n\t\t\t.gamma_type = TIDSS_GAMMA_8BIT,\n\t\t},\n\t},\n\n\t.num_planes = 2,\n\t \n\t.vid_name = { \"vid\", \"vidl1\" },\n\t.vid_lite = { false, true, },\n\t.vid_order = { 1, 0 },\n};\n\nstatic const u16 tidss_j721e_common_regs[DISPC_COMMON_REG_TABLE_LEN] = {\n\t[DSS_REVISION_OFF] =\t\t\t0x4,\n\t[DSS_SYSCONFIG_OFF] =\t\t\t0x8,\n\t[DSS_SYSSTATUS_OFF] =\t\t\t0x20,\n\t[DISPC_IRQ_EOI_OFF] =\t\t\t0x80,\n\t[DISPC_IRQSTATUS_RAW_OFF] =\t\t0x28,\n\t[DISPC_IRQSTATUS_OFF] =\t\t\t0x2c,\n\t[DISPC_IRQENABLE_SET_OFF] =\t\t0x30,\n\t[DISPC_IRQENABLE_CLR_OFF] =\t\t0x34,\n\t[DISPC_VID_IRQENABLE_OFF] =\t\t0x38,\n\t[DISPC_VID_IRQSTATUS_OFF] =\t\t0x48,\n\t[DISPC_VP_IRQENABLE_OFF] =\t\t0x58,\n\t[DISPC_VP_IRQSTATUS_OFF] =\t\t0x68,\n\n\t[WB_IRQENABLE_OFF] =\t\t\t0x78,\n\t[WB_IRQSTATUS_OFF] =\t\t\t0x7c,\n\n\t[DISPC_GLOBAL_MFLAG_ATTRIBUTE_OFF] =\t0x98,\n\t[DISPC_GLOBAL_OUTPUT_ENABLE_OFF] =\t0x9c,\n\t[DISPC_GLOBAL_BUFFER_OFF] =\t\t0xa0,\n\t[DSS_CBA_CFG_OFF] =\t\t\t0xa4,\n\t[DISPC_DBG_CONTROL_OFF] =\t\t0xa8,\n\t[DISPC_DBG_STATUS_OFF] =\t\t0xac,\n\t[DISPC_CLKGATING_DISABLE_OFF] =\t\t0xb0,\n\t[DISPC_SECURE_DISABLE_OFF] =\t\t0x90,\n\n\t[FBDC_REVISION_1_OFF] =\t\t\t0xb8,\n\t[FBDC_REVISION_2_OFF] =\t\t\t0xbc,\n\t[FBDC_REVISION_3_OFF] =\t\t\t0xc0,\n\t[FBDC_REVISION_4_OFF] =\t\t\t0xc4,\n\t[FBDC_REVISION_5_OFF] =\t\t\t0xc8,\n\t[FBDC_REVISION_6_OFF] =\t\t\t0xcc,\n\t[FBDC_COMMON_CONTROL_OFF] =\t\t0xd0,\n\t[FBDC_CONSTANT_COLOR_0_OFF] =\t\t0xd4,\n\t[FBDC_CONSTANT_COLOR_1_OFF] =\t\t0xd8,\n\t[DISPC_CONNECTIONS_OFF] =\t\t0xe4,\n\t[DISPC_MSS_VP1_OFF] =\t\t\t0xe8,\n\t[DISPC_MSS_VP3_OFF] =\t\t\t0xec,\n};\n\nconst struct dispc_features dispc_j721e_feats = {\n\t.max_pclk_khz = {\n\t\t[DISPC_VP_DPI] = 170000,\n\t\t[DISPC_VP_INTERNAL] = 600000,\n\t},\n\n\t.scaling = {\n\t\t.in_width_max_5tap_rgb = 2048,\n\t\t.in_width_max_3tap_rgb = 4096,\n\t\t.in_width_max_5tap_yuv = 4096,\n\t\t.in_width_max_3tap_yuv = 4096,\n\t\t.upscale_limit = 16,\n\t\t.downscale_limit_5tap = 4,\n\t\t.downscale_limit_3tap = 2,\n\t\t \n\t\t.xinc_max = 32,\n\t},\n\n\t.subrev = DISPC_J721E,\n\n\t.common = \"common_m\",\n\t.common_regs = tidss_j721e_common_regs,\n\n\t.num_vps = 4,\n\t.vp_name = { \"vp1\", \"vp2\", \"vp3\", \"vp4\" },\n\t.ovr_name = { \"ovr1\", \"ovr2\", \"ovr3\", \"ovr4\" },\n\t.vpclk_name = { \"vp1\", \"vp2\", \"vp3\", \"vp4\" },\n\t \n\t.vp_bus_type =\t{ DISPC_VP_INTERNAL, DISPC_VP_DPI,\n\t\t\t  DISPC_VP_INTERNAL, DISPC_VP_DPI, },\n\t.vp_feat = { .color = {\n\t\t\t.has_ctm = true,\n\t\t\t.gamma_size = 1024,\n\t\t\t.gamma_type = TIDSS_GAMMA_10BIT,\n\t\t},\n\t},\n\t.num_planes = 4,\n\t.vid_name = { \"vid1\", \"vidl1\", \"vid2\", \"vidl2\" },\n\t.vid_lite = { 0, 1, 0, 1, },\n\t.vid_order = { 1, 3, 0, 2 },\n};\n\nconst struct dispc_features dispc_am625_feats = {\n\t.max_pclk_khz = {\n\t\t[DISPC_VP_DPI] = 165000,\n\t\t[DISPC_VP_INTERNAL] = 170000,\n\t},\n\n\t.scaling = {\n\t\t.in_width_max_5tap_rgb = 1280,\n\t\t.in_width_max_3tap_rgb = 2560,\n\t\t.in_width_max_5tap_yuv = 2560,\n\t\t.in_width_max_3tap_yuv = 4096,\n\t\t.upscale_limit = 16,\n\t\t.downscale_limit_5tap = 4,\n\t\t.downscale_limit_3tap = 2,\n\t\t \n\t\t.xinc_max = 32,\n\t},\n\n\t.subrev = DISPC_AM625,\n\n\t.common = \"common\",\n\t.common_regs = tidss_am65x_common_regs,\n\n\t.num_vps = 2,\n\t.vp_name = { \"vp1\", \"vp2\" },\n\t.ovr_name = { \"ovr1\", \"ovr2\" },\n\t.vpclk_name =  { \"vp1\", \"vp2\" },\n\t.vp_bus_type = { DISPC_VP_INTERNAL, DISPC_VP_DPI },\n\n\t.vp_feat = { .color = {\n\t\t\t.has_ctm = true,\n\t\t\t.gamma_size = 256,\n\t\t\t.gamma_type = TIDSS_GAMMA_8BIT,\n\t\t},\n\t},\n\n\t.num_planes = 2,\n\t \n\t.vid_name = { \"vid\", \"vidl1\" },\n\t.vid_lite = { false, true, },\n\t.vid_order = { 1, 0 },\n};\n\nstatic const u16 *dispc_common_regmap;\n\nstruct dss_vp_data {\n\tu32 *gamma_table;\n};\n\nstruct dispc_device {\n\tstruct tidss_device *tidss;\n\tstruct device *dev;\n\n\tvoid __iomem *base_common;\n\tvoid __iomem *base_vid[TIDSS_MAX_PLANES];\n\tvoid __iomem *base_ovr[TIDSS_MAX_PORTS];\n\tvoid __iomem *base_vp[TIDSS_MAX_PORTS];\n\n\tstruct regmap *oldi_io_ctrl;\n\n\tstruct clk *vp_clk[TIDSS_MAX_PORTS];\n\n\tconst struct dispc_features *feat;\n\n\tstruct clk *fclk;\n\n\tbool is_enabled;\n\n\tstruct dss_vp_data vp_data[TIDSS_MAX_PORTS];\n\n\tu32 *fourccs;\n\tu32 num_fourccs;\n\n\tu32 memory_bandwidth_limit;\n\n\tstruct dispc_errata errata;\n};\n\nstatic void dispc_write(struct dispc_device *dispc, u16 reg, u32 val)\n{\n\tiowrite32(val, dispc->base_common + reg);\n}\n\nstatic u32 dispc_read(struct dispc_device *dispc, u16 reg)\n{\n\treturn ioread32(dispc->base_common + reg);\n}\n\nstatic\nvoid dispc_vid_write(struct dispc_device *dispc, u32 hw_plane, u16 reg, u32 val)\n{\n\tvoid __iomem *base = dispc->base_vid[hw_plane];\n\n\tiowrite32(val, base + reg);\n}\n\nstatic u32 dispc_vid_read(struct dispc_device *dispc, u32 hw_plane, u16 reg)\n{\n\tvoid __iomem *base = dispc->base_vid[hw_plane];\n\n\treturn ioread32(base + reg);\n}\n\nstatic void dispc_ovr_write(struct dispc_device *dispc, u32 hw_videoport,\n\t\t\t    u16 reg, u32 val)\n{\n\tvoid __iomem *base = dispc->base_ovr[hw_videoport];\n\n\tiowrite32(val, base + reg);\n}\n\nstatic u32 dispc_ovr_read(struct dispc_device *dispc, u32 hw_videoport, u16 reg)\n{\n\tvoid __iomem *base = dispc->base_ovr[hw_videoport];\n\n\treturn ioread32(base + reg);\n}\n\nstatic void dispc_vp_write(struct dispc_device *dispc, u32 hw_videoport,\n\t\t\t   u16 reg, u32 val)\n{\n\tvoid __iomem *base = dispc->base_vp[hw_videoport];\n\n\tiowrite32(val, base + reg);\n}\n\nstatic u32 dispc_vp_read(struct dispc_device *dispc, u32 hw_videoport, u16 reg)\n{\n\tvoid __iomem *base = dispc->base_vp[hw_videoport];\n\n\treturn ioread32(base + reg);\n}\n\n \n\nstatic u32 FLD_MASK(u32 start, u32 end)\n{\n\treturn ((1 << (start - end + 1)) - 1) << end;\n}\n\nstatic u32 FLD_VAL(u32 val, u32 start, u32 end)\n{\n\treturn (val << end) & FLD_MASK(start, end);\n}\n\nstatic u32 FLD_GET(u32 val, u32 start, u32 end)\n{\n\treturn (val & FLD_MASK(start, end)) >> end;\n}\n\nstatic u32 FLD_MOD(u32 orig, u32 val, u32 start, u32 end)\n{\n\treturn (orig & ~FLD_MASK(start, end)) | FLD_VAL(val, start, end);\n}\n\nstatic u32 REG_GET(struct dispc_device *dispc, u32 idx, u32 start, u32 end)\n{\n\treturn FLD_GET(dispc_read(dispc, idx), start, end);\n}\n\nstatic void REG_FLD_MOD(struct dispc_device *dispc, u32 idx, u32 val,\n\t\t\tu32 start, u32 end)\n{\n\tdispc_write(dispc, idx, FLD_MOD(dispc_read(dispc, idx), val,\n\t\t\t\t\tstart, end));\n}\n\nstatic u32 VID_REG_GET(struct dispc_device *dispc, u32 hw_plane, u32 idx,\n\t\t       u32 start, u32 end)\n{\n\treturn FLD_GET(dispc_vid_read(dispc, hw_plane, idx), start, end);\n}\n\nstatic void VID_REG_FLD_MOD(struct dispc_device *dispc, u32 hw_plane, u32 idx,\n\t\t\t    u32 val, u32 start, u32 end)\n{\n\tdispc_vid_write(dispc, hw_plane, idx,\n\t\t\tFLD_MOD(dispc_vid_read(dispc, hw_plane, idx),\n\t\t\t\tval, start, end));\n}\n\nstatic u32 VP_REG_GET(struct dispc_device *dispc, u32 vp, u32 idx,\n\t\t      u32 start, u32 end)\n{\n\treturn FLD_GET(dispc_vp_read(dispc, vp, idx), start, end);\n}\n\nstatic void VP_REG_FLD_MOD(struct dispc_device *dispc, u32 vp, u32 idx, u32 val,\n\t\t\t   u32 start, u32 end)\n{\n\tdispc_vp_write(dispc, vp, idx, FLD_MOD(dispc_vp_read(dispc, vp, idx),\n\t\t\t\t\t       val, start, end));\n}\n\n__maybe_unused\nstatic u32 OVR_REG_GET(struct dispc_device *dispc, u32 ovr, u32 idx,\n\t\t       u32 start, u32 end)\n{\n\treturn FLD_GET(dispc_ovr_read(dispc, ovr, idx), start, end);\n}\n\nstatic void OVR_REG_FLD_MOD(struct dispc_device *dispc, u32 ovr, u32 idx,\n\t\t\t    u32 val, u32 start, u32 end)\n{\n\tdispc_ovr_write(dispc, ovr, idx,\n\t\t\tFLD_MOD(dispc_ovr_read(dispc, ovr, idx),\n\t\t\t\tval, start, end));\n}\n\nstatic dispc_irq_t dispc_vp_irq_from_raw(u32 stat, u32 hw_videoport)\n{\n\tdispc_irq_t vp_stat = 0;\n\n\tif (stat & BIT(0))\n\t\tvp_stat |= DSS_IRQ_VP_FRAME_DONE(hw_videoport);\n\tif (stat & BIT(1))\n\t\tvp_stat |= DSS_IRQ_VP_VSYNC_EVEN(hw_videoport);\n\tif (stat & BIT(2))\n\t\tvp_stat |= DSS_IRQ_VP_VSYNC_ODD(hw_videoport);\n\tif (stat & BIT(4))\n\t\tvp_stat |= DSS_IRQ_VP_SYNC_LOST(hw_videoport);\n\n\treturn vp_stat;\n}\n\nstatic u32 dispc_vp_irq_to_raw(dispc_irq_t vpstat, u32 hw_videoport)\n{\n\tu32 stat = 0;\n\n\tif (vpstat & DSS_IRQ_VP_FRAME_DONE(hw_videoport))\n\t\tstat |= BIT(0);\n\tif (vpstat & DSS_IRQ_VP_VSYNC_EVEN(hw_videoport))\n\t\tstat |= BIT(1);\n\tif (vpstat & DSS_IRQ_VP_VSYNC_ODD(hw_videoport))\n\t\tstat |= BIT(2);\n\tif (vpstat & DSS_IRQ_VP_SYNC_LOST(hw_videoport))\n\t\tstat |= BIT(4);\n\n\treturn stat;\n}\n\nstatic dispc_irq_t dispc_vid_irq_from_raw(u32 stat, u32 hw_plane)\n{\n\tdispc_irq_t vid_stat = 0;\n\n\tif (stat & BIT(0))\n\t\tvid_stat |= DSS_IRQ_PLANE_FIFO_UNDERFLOW(hw_plane);\n\n\treturn vid_stat;\n}\n\nstatic u32 dispc_vid_irq_to_raw(dispc_irq_t vidstat, u32 hw_plane)\n{\n\tu32 stat = 0;\n\n\tif (vidstat & DSS_IRQ_PLANE_FIFO_UNDERFLOW(hw_plane))\n\t\tstat |= BIT(0);\n\n\treturn stat;\n}\n\nstatic dispc_irq_t dispc_k2g_vp_read_irqstatus(struct dispc_device *dispc,\n\t\t\t\t\t       u32 hw_videoport)\n{\n\tu32 stat = dispc_vp_read(dispc, hw_videoport, DISPC_VP_K2G_IRQSTATUS);\n\n\treturn dispc_vp_irq_from_raw(stat, hw_videoport);\n}\n\nstatic void dispc_k2g_vp_write_irqstatus(struct dispc_device *dispc,\n\t\t\t\t\t u32 hw_videoport, dispc_irq_t vpstat)\n{\n\tu32 stat = dispc_vp_irq_to_raw(vpstat, hw_videoport);\n\n\tdispc_vp_write(dispc, hw_videoport, DISPC_VP_K2G_IRQSTATUS, stat);\n}\n\nstatic dispc_irq_t dispc_k2g_vid_read_irqstatus(struct dispc_device *dispc,\n\t\t\t\t\t\tu32 hw_plane)\n{\n\tu32 stat = dispc_vid_read(dispc, hw_plane, DISPC_VID_K2G_IRQSTATUS);\n\n\treturn dispc_vid_irq_from_raw(stat, hw_plane);\n}\n\nstatic void dispc_k2g_vid_write_irqstatus(struct dispc_device *dispc,\n\t\t\t\t\t  u32 hw_plane, dispc_irq_t vidstat)\n{\n\tu32 stat = dispc_vid_irq_to_raw(vidstat, hw_plane);\n\n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_K2G_IRQSTATUS, stat);\n}\n\nstatic dispc_irq_t dispc_k2g_vp_read_irqenable(struct dispc_device *dispc,\n\t\t\t\t\t       u32 hw_videoport)\n{\n\tu32 stat = dispc_vp_read(dispc, hw_videoport, DISPC_VP_K2G_IRQENABLE);\n\n\treturn dispc_vp_irq_from_raw(stat, hw_videoport);\n}\n\nstatic void dispc_k2g_vp_set_irqenable(struct dispc_device *dispc,\n\t\t\t\t       u32 hw_videoport, dispc_irq_t vpstat)\n{\n\tu32 stat = dispc_vp_irq_to_raw(vpstat, hw_videoport);\n\n\tdispc_vp_write(dispc, hw_videoport, DISPC_VP_K2G_IRQENABLE, stat);\n}\n\nstatic dispc_irq_t dispc_k2g_vid_read_irqenable(struct dispc_device *dispc,\n\t\t\t\t\t\tu32 hw_plane)\n{\n\tu32 stat = dispc_vid_read(dispc, hw_plane, DISPC_VID_K2G_IRQENABLE);\n\n\treturn dispc_vid_irq_from_raw(stat, hw_plane);\n}\n\nstatic void dispc_k2g_vid_set_irqenable(struct dispc_device *dispc,\n\t\t\t\t\tu32 hw_plane, dispc_irq_t vidstat)\n{\n\tu32 stat = dispc_vid_irq_to_raw(vidstat, hw_plane);\n\n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_K2G_IRQENABLE, stat);\n}\n\nstatic void dispc_k2g_clear_irqstatus(struct dispc_device *dispc,\n\t\t\t\t      dispc_irq_t mask)\n{\n\tdispc_k2g_vp_write_irqstatus(dispc, 0, mask);\n\tdispc_k2g_vid_write_irqstatus(dispc, 0, mask);\n}\n\nstatic\ndispc_irq_t dispc_k2g_read_and_clear_irqstatus(struct dispc_device *dispc)\n{\n\tdispc_irq_t stat = 0;\n\n\t \n\tdispc_write(dispc, DISPC_IRQSTATUS,\n\t\t    dispc_read(dispc, DISPC_IRQSTATUS));\n\n\tstat |= dispc_k2g_vp_read_irqstatus(dispc, 0);\n\tstat |= dispc_k2g_vid_read_irqstatus(dispc, 0);\n\n\tdispc_k2g_clear_irqstatus(dispc, stat);\n\n\treturn stat;\n}\n\nstatic dispc_irq_t dispc_k2g_read_irqenable(struct dispc_device *dispc)\n{\n\tdispc_irq_t stat = 0;\n\n\tstat |= dispc_k2g_vp_read_irqenable(dispc, 0);\n\tstat |= dispc_k2g_vid_read_irqenable(dispc, 0);\n\n\treturn stat;\n}\n\nstatic\nvoid dispc_k2g_set_irqenable(struct dispc_device *dispc, dispc_irq_t mask)\n{\n\tdispc_irq_t old_mask = dispc_k2g_read_irqenable(dispc);\n\n\t \n\tdispc_k2g_clear_irqstatus(dispc, (mask ^ old_mask) & mask);\n\n\tdispc_k2g_vp_set_irqenable(dispc, 0, mask);\n\tdispc_k2g_vid_set_irqenable(dispc, 0, mask);\n\n\tdispc_write(dispc, DISPC_IRQENABLE_SET, (1 << 0) | (1 << 7));\n\n\t \n\tdispc_k2g_read_irqenable(dispc);\n}\n\nstatic dispc_irq_t dispc_k3_vp_read_irqstatus(struct dispc_device *dispc,\n\t\t\t\t\t      u32 hw_videoport)\n{\n\tu32 stat = dispc_read(dispc, DISPC_VP_IRQSTATUS(hw_videoport));\n\n\treturn dispc_vp_irq_from_raw(stat, hw_videoport);\n}\n\nstatic void dispc_k3_vp_write_irqstatus(struct dispc_device *dispc,\n\t\t\t\t\tu32 hw_videoport, dispc_irq_t vpstat)\n{\n\tu32 stat = dispc_vp_irq_to_raw(vpstat, hw_videoport);\n\n\tdispc_write(dispc, DISPC_VP_IRQSTATUS(hw_videoport), stat);\n}\n\nstatic dispc_irq_t dispc_k3_vid_read_irqstatus(struct dispc_device *dispc,\n\t\t\t\t\t       u32 hw_plane)\n{\n\tu32 stat = dispc_read(dispc, DISPC_VID_IRQSTATUS(hw_plane));\n\n\treturn dispc_vid_irq_from_raw(stat, hw_plane);\n}\n\nstatic void dispc_k3_vid_write_irqstatus(struct dispc_device *dispc,\n\t\t\t\t\t u32 hw_plane, dispc_irq_t vidstat)\n{\n\tu32 stat = dispc_vid_irq_to_raw(vidstat, hw_plane);\n\n\tdispc_write(dispc, DISPC_VID_IRQSTATUS(hw_plane), stat);\n}\n\nstatic dispc_irq_t dispc_k3_vp_read_irqenable(struct dispc_device *dispc,\n\t\t\t\t\t      u32 hw_videoport)\n{\n\tu32 stat = dispc_read(dispc, DISPC_VP_IRQENABLE(hw_videoport));\n\n\treturn dispc_vp_irq_from_raw(stat, hw_videoport);\n}\n\nstatic void dispc_k3_vp_set_irqenable(struct dispc_device *dispc,\n\t\t\t\t      u32 hw_videoport, dispc_irq_t vpstat)\n{\n\tu32 stat = dispc_vp_irq_to_raw(vpstat, hw_videoport);\n\n\tdispc_write(dispc, DISPC_VP_IRQENABLE(hw_videoport), stat);\n}\n\nstatic dispc_irq_t dispc_k3_vid_read_irqenable(struct dispc_device *dispc,\n\t\t\t\t\t       u32 hw_plane)\n{\n\tu32 stat = dispc_read(dispc, DISPC_VID_IRQENABLE(hw_plane));\n\n\treturn dispc_vid_irq_from_raw(stat, hw_plane);\n}\n\nstatic void dispc_k3_vid_set_irqenable(struct dispc_device *dispc,\n\t\t\t\t       u32 hw_plane, dispc_irq_t vidstat)\n{\n\tu32 stat = dispc_vid_irq_to_raw(vidstat, hw_plane);\n\n\tdispc_write(dispc, DISPC_VID_IRQENABLE(hw_plane), stat);\n}\n\nstatic\nvoid dispc_k3_clear_irqstatus(struct dispc_device *dispc, dispc_irq_t clearmask)\n{\n\tunsigned int i;\n\tu32 top_clear = 0;\n\n\tfor (i = 0; i < dispc->feat->num_vps; ++i) {\n\t\tif (clearmask & DSS_IRQ_VP_MASK(i)) {\n\t\t\tdispc_k3_vp_write_irqstatus(dispc, i, clearmask);\n\t\t\ttop_clear |= BIT(i);\n\t\t}\n\t}\n\tfor (i = 0; i < dispc->feat->num_planes; ++i) {\n\t\tif (clearmask & DSS_IRQ_PLANE_MASK(i)) {\n\t\t\tdispc_k3_vid_write_irqstatus(dispc, i, clearmask);\n\t\t\ttop_clear |= BIT(4 + i);\n\t\t}\n\t}\n\tif (dispc->feat->subrev == DISPC_K2G)\n\t\treturn;\n\n\tdispc_write(dispc, DISPC_IRQSTATUS, top_clear);\n\n\t \n\tdispc_read(dispc, DISPC_IRQSTATUS);\n}\n\nstatic\ndispc_irq_t dispc_k3_read_and_clear_irqstatus(struct dispc_device *dispc)\n{\n\tdispc_irq_t status = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < dispc->feat->num_vps; ++i)\n\t\tstatus |= dispc_k3_vp_read_irqstatus(dispc, i);\n\n\tfor (i = 0; i < dispc->feat->num_planes; ++i)\n\t\tstatus |= dispc_k3_vid_read_irqstatus(dispc, i);\n\n\tdispc_k3_clear_irqstatus(dispc, status);\n\n\treturn status;\n}\n\nstatic dispc_irq_t dispc_k3_read_irqenable(struct dispc_device *dispc)\n{\n\tdispc_irq_t enable = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < dispc->feat->num_vps; ++i)\n\t\tenable |= dispc_k3_vp_read_irqenable(dispc, i);\n\n\tfor (i = 0; i < dispc->feat->num_planes; ++i)\n\t\tenable |= dispc_k3_vid_read_irqenable(dispc, i);\n\n\treturn enable;\n}\n\nstatic void dispc_k3_set_irqenable(struct dispc_device *dispc,\n\t\t\t\t   dispc_irq_t mask)\n{\n\tunsigned int i;\n\tu32 main_enable = 0, main_disable = 0;\n\tdispc_irq_t old_mask;\n\n\told_mask = dispc_k3_read_irqenable(dispc);\n\n\t \n\tdispc_k3_clear_irqstatus(dispc, (old_mask ^ mask) & mask);\n\n\tfor (i = 0; i < dispc->feat->num_vps; ++i) {\n\t\tdispc_k3_vp_set_irqenable(dispc, i, mask);\n\t\tif (mask & DSS_IRQ_VP_MASK(i))\n\t\t\tmain_enable |= BIT(i);\t\t \n\t\telse\n\t\t\tmain_disable |= BIT(i);\t\t \n\t}\n\n\tfor (i = 0; i < dispc->feat->num_planes; ++i) {\n\t\tdispc_k3_vid_set_irqenable(dispc, i, mask);\n\t\tif (mask & DSS_IRQ_PLANE_MASK(i))\n\t\t\tmain_enable |= BIT(i + 4);\t \n\t\telse\n\t\t\tmain_disable |= BIT(i + 4);\t \n\t}\n\n\tif (main_enable)\n\t\tdispc_write(dispc, DISPC_IRQENABLE_SET, main_enable);\n\n\tif (main_disable)\n\t\tdispc_write(dispc, DISPC_IRQENABLE_CLR, main_disable);\n\n\t \n\tdispc_read(dispc, DISPC_IRQENABLE_SET);\n}\n\ndispc_irq_t dispc_read_and_clear_irqstatus(struct dispc_device *dispc)\n{\n\tswitch (dispc->feat->subrev) {\n\tcase DISPC_K2G:\n\t\treturn dispc_k2g_read_and_clear_irqstatus(dispc);\n\tcase DISPC_AM625:\n\tcase DISPC_AM65X:\n\tcase DISPC_J721E:\n\t\treturn dispc_k3_read_and_clear_irqstatus(dispc);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n}\n\nvoid dispc_set_irqenable(struct dispc_device *dispc, dispc_irq_t mask)\n{\n\tswitch (dispc->feat->subrev) {\n\tcase DISPC_K2G:\n\t\tdispc_k2g_set_irqenable(dispc, mask);\n\t\tbreak;\n\tcase DISPC_AM625:\n\tcase DISPC_AM65X:\n\tcase DISPC_J721E:\n\t\tdispc_k3_set_irqenable(dispc, mask);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nenum dispc_oldi_mode_reg_val { SPWG_18 = 0, JEIDA_24 = 1, SPWG_24 = 2 };\n\nstruct dispc_bus_format {\n\tu32 bus_fmt;\n\tu32 data_width;\n\tbool is_oldi_fmt;\n\tenum dispc_oldi_mode_reg_val oldi_mode_reg_val;\n};\n\nstatic const struct dispc_bus_format dispc_bus_formats[] = {\n\t{ MEDIA_BUS_FMT_RGB444_1X12,\t\t12, false, 0 },\n\t{ MEDIA_BUS_FMT_RGB565_1X16,\t\t16, false, 0 },\n\t{ MEDIA_BUS_FMT_RGB666_1X18,\t\t18, false, 0 },\n\t{ MEDIA_BUS_FMT_RGB888_1X24,\t\t24, false, 0 },\n\t{ MEDIA_BUS_FMT_RGB101010_1X30,\t\t30, false, 0 },\n\t{ MEDIA_BUS_FMT_RGB121212_1X36,\t\t36, false, 0 },\n\t{ MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,\t18, true, SPWG_18 },\n\t{ MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,\t24, true, SPWG_24 },\n\t{ MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA,\t24, true, JEIDA_24 },\n};\n\nstatic const\nstruct dispc_bus_format *dispc_vp_find_bus_fmt(struct dispc_device *dispc,\n\t\t\t\t\t       u32 hw_videoport,\n\t\t\t\t\t       u32 bus_fmt, u32 bus_flags)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dispc_bus_formats); ++i) {\n\t\tif (dispc_bus_formats[i].bus_fmt == bus_fmt)\n\t\t\treturn &dispc_bus_formats[i];\n\t}\n\n\treturn NULL;\n}\n\nint dispc_vp_bus_check(struct dispc_device *dispc, u32 hw_videoport,\n\t\t       const struct drm_crtc_state *state)\n{\n\tconst struct tidss_crtc_state *tstate = to_tidss_crtc_state(state);\n\tconst struct dispc_bus_format *fmt;\n\n\tfmt = dispc_vp_find_bus_fmt(dispc, hw_videoport, tstate->bus_format,\n\t\t\t\t    tstate->bus_flags);\n\tif (!fmt) {\n\t\tdev_dbg(dispc->dev, \"%s: Unsupported bus format: %u\\n\",\n\t\t\t__func__, tstate->bus_format);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dispc->feat->vp_bus_type[hw_videoport] != DISPC_VP_OLDI &&\n\t    fmt->is_oldi_fmt) {\n\t\tdev_dbg(dispc->dev, \"%s: %s is not OLDI-port\\n\",\n\t\t\t__func__, dispc->feat->vp_name[hw_videoport]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void dispc_oldi_tx_power(struct dispc_device *dispc, bool power)\n{\n\tu32 val = power ? 0 : OLDI_PWRDN_TX;\n\n\tif (WARN_ON(!dispc->oldi_io_ctrl))\n\t\treturn;\n\n\tregmap_update_bits(dispc->oldi_io_ctrl, OLDI_DAT0_IO_CTRL,\n\t\t\t   OLDI_PWRDN_TX, val);\n\tregmap_update_bits(dispc->oldi_io_ctrl, OLDI_DAT1_IO_CTRL,\n\t\t\t   OLDI_PWRDN_TX, val);\n\tregmap_update_bits(dispc->oldi_io_ctrl, OLDI_DAT2_IO_CTRL,\n\t\t\t   OLDI_PWRDN_TX, val);\n\tregmap_update_bits(dispc->oldi_io_ctrl, OLDI_DAT3_IO_CTRL,\n\t\t\t   OLDI_PWRDN_TX, val);\n\tregmap_update_bits(dispc->oldi_io_ctrl, OLDI_CLK_IO_CTRL,\n\t\t\t   OLDI_PWRDN_TX, val);\n}\n\nstatic void dispc_set_num_datalines(struct dispc_device *dispc,\n\t\t\t\t    u32 hw_videoport, int num_lines)\n{\n\tint v;\n\n\tswitch (num_lines) {\n\tcase 12:\n\t\tv = 0; break;\n\tcase 16:\n\t\tv = 1; break;\n\tcase 18:\n\t\tv = 2; break;\n\tcase 24:\n\t\tv = 3; break;\n\tcase 30:\n\t\tv = 4; break;\n\tcase 36:\n\t\tv = 5; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tv = 3;\n\t}\n\n\tVP_REG_FLD_MOD(dispc, hw_videoport, DISPC_VP_CONTROL, v, 10, 8);\n}\n\nstatic void dispc_enable_oldi(struct dispc_device *dispc, u32 hw_videoport,\n\t\t\t      const struct dispc_bus_format *fmt)\n{\n\tu32 oldi_cfg = 0;\n\tu32 oldi_reset_bit = BIT(5 + hw_videoport);\n\tint count = 0;\n\n\t \n\n\tif (fmt->data_width == 24)\n\t\toldi_cfg |= BIT(8);  \n\telse if (fmt->data_width != 18)\n\t\tdev_warn(dispc->dev, \"%s: %d port width not supported\\n\",\n\t\t\t __func__, fmt->data_width);\n\n\toldi_cfg |= BIT(7);  \n\n\toldi_cfg = FLD_MOD(oldi_cfg, fmt->oldi_mode_reg_val, 3, 1);\n\n\toldi_cfg |= BIT(12);  \n\n\toldi_cfg |= BIT(0);  \n\n\tdispc_vp_write(dispc, hw_videoport, DISPC_VP_DSS_OLDI_CFG, oldi_cfg);\n\n\twhile (!(oldi_reset_bit & dispc_read(dispc, DSS_SYSSTATUS)) &&\n\t       count < 10000)\n\t\tcount++;\n\n\tif (!(oldi_reset_bit & dispc_read(dispc, DSS_SYSSTATUS)))\n\t\tdev_warn(dispc->dev, \"%s: timeout waiting OLDI reset done\\n\",\n\t\t\t __func__);\n}\n\nvoid dispc_vp_prepare(struct dispc_device *dispc, u32 hw_videoport,\n\t\t      const struct drm_crtc_state *state)\n{\n\tconst struct tidss_crtc_state *tstate = to_tidss_crtc_state(state);\n\tconst struct dispc_bus_format *fmt;\n\n\tfmt = dispc_vp_find_bus_fmt(dispc, hw_videoport, tstate->bus_format,\n\t\t\t\t    tstate->bus_flags);\n\n\tif (WARN_ON(!fmt))\n\t\treturn;\n\n\tif (dispc->feat->vp_bus_type[hw_videoport] == DISPC_VP_OLDI) {\n\t\tdispc_oldi_tx_power(dispc, true);\n\n\t\tdispc_enable_oldi(dispc, hw_videoport, fmt);\n\t}\n}\n\nvoid dispc_vp_enable(struct dispc_device *dispc, u32 hw_videoport,\n\t\t     const struct drm_crtc_state *state)\n{\n\tconst struct drm_display_mode *mode = &state->adjusted_mode;\n\tconst struct tidss_crtc_state *tstate = to_tidss_crtc_state(state);\n\tbool align, onoff, rf, ieo, ipc, ihs, ivs;\n\tconst struct dispc_bus_format *fmt;\n\tu32 hsw, hfp, hbp, vsw, vfp, vbp;\n\n\tfmt = dispc_vp_find_bus_fmt(dispc, hw_videoport, tstate->bus_format,\n\t\t\t\t    tstate->bus_flags);\n\n\tif (WARN_ON(!fmt))\n\t\treturn;\n\n\tdispc_set_num_datalines(dispc, hw_videoport, fmt->data_width);\n\n\thfp = mode->hsync_start - mode->hdisplay;\n\thsw = mode->hsync_end - mode->hsync_start;\n\thbp = mode->htotal - mode->hsync_end;\n\n\tvfp = mode->vsync_start - mode->vdisplay;\n\tvsw = mode->vsync_end - mode->vsync_start;\n\tvbp = mode->vtotal - mode->vsync_end;\n\n\tdispc_vp_write(dispc, hw_videoport, DISPC_VP_TIMING_H,\n\t\t       FLD_VAL(hsw - 1, 7, 0) |\n\t\t       FLD_VAL(hfp - 1, 19, 8) |\n\t\t       FLD_VAL(hbp - 1, 31, 20));\n\n\tdispc_vp_write(dispc, hw_videoport, DISPC_VP_TIMING_V,\n\t\t       FLD_VAL(vsw - 1, 7, 0) |\n\t\t       FLD_VAL(vfp, 19, 8) |\n\t\t       FLD_VAL(vbp, 31, 20));\n\n\tivs = !!(mode->flags & DRM_MODE_FLAG_NVSYNC);\n\n\tihs = !!(mode->flags & DRM_MODE_FLAG_NHSYNC);\n\n\tieo = !!(tstate->bus_flags & DRM_BUS_FLAG_DE_LOW);\n\n\tipc = !!(tstate->bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE);\n\n\t \n\tonoff = true;\n\n\trf = !!(tstate->bus_flags & DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE);\n\n\t \n\talign = true;\n\n\t \n\tif (dispc->feat->vp_bus_type[hw_videoport] == DISPC_VP_OLDI)\n\t\tieo = false;\n\n\tdispc_vp_write(dispc, hw_videoport, DISPC_VP_POL_FREQ,\n\t\t       FLD_VAL(align, 18, 18) |\n\t\t       FLD_VAL(onoff, 17, 17) |\n\t\t       FLD_VAL(rf, 16, 16) |\n\t\t       FLD_VAL(ieo, 15, 15) |\n\t\t       FLD_VAL(ipc, 14, 14) |\n\t\t       FLD_VAL(ihs, 13, 13) |\n\t\t       FLD_VAL(ivs, 12, 12));\n\n\tdispc_vp_write(dispc, hw_videoport, DISPC_VP_SIZE_SCREEN,\n\t\t       FLD_VAL(mode->hdisplay - 1, 11, 0) |\n\t\t       FLD_VAL(mode->vdisplay - 1, 27, 16));\n\n\tVP_REG_FLD_MOD(dispc, hw_videoport, DISPC_VP_CONTROL, 1, 0, 0);\n}\n\nvoid dispc_vp_disable(struct dispc_device *dispc, u32 hw_videoport)\n{\n\tVP_REG_FLD_MOD(dispc, hw_videoport, DISPC_VP_CONTROL, 0, 0, 0);\n}\n\nvoid dispc_vp_unprepare(struct dispc_device *dispc, u32 hw_videoport)\n{\n\tif (dispc->feat->vp_bus_type[hw_videoport] == DISPC_VP_OLDI) {\n\t\tdispc_vp_write(dispc, hw_videoport, DISPC_VP_DSS_OLDI_CFG, 0);\n\n\t\tdispc_oldi_tx_power(dispc, false);\n\t}\n}\n\nbool dispc_vp_go_busy(struct dispc_device *dispc, u32 hw_videoport)\n{\n\treturn VP_REG_GET(dispc, hw_videoport, DISPC_VP_CONTROL, 5, 5);\n}\n\nvoid dispc_vp_go(struct dispc_device *dispc, u32 hw_videoport)\n{\n\tWARN_ON(VP_REG_GET(dispc, hw_videoport, DISPC_VP_CONTROL, 5, 5));\n\tVP_REG_FLD_MOD(dispc, hw_videoport, DISPC_VP_CONTROL, 1, 5, 5);\n}\n\nenum c8_to_c12_mode { C8_TO_C12_REPLICATE, C8_TO_C12_MAX, C8_TO_C12_MIN };\n\nstatic u16 c8_to_c12(u8 c8, enum c8_to_c12_mode mode)\n{\n\tu16 c12;\n\n\tc12 = c8 << 4;\n\n\tswitch (mode) {\n\tcase C8_TO_C12_REPLICATE:\n\t\t \n\t\tc12 |= c8 >> 4;\n\t\tbreak;\n\tcase C8_TO_C12_MAX:\n\t\tc12 |= 0xF;\n\t\tbreak;\n\tdefault:\n\tcase C8_TO_C12_MIN:\n\t\tbreak;\n\t}\n\n\treturn c12;\n}\n\nstatic u64 argb8888_to_argb12121212(u32 argb8888, enum c8_to_c12_mode m)\n{\n\tu8 a, r, g, b;\n\tu64 v;\n\n\ta = (argb8888 >> 24) & 0xff;\n\tr = (argb8888 >> 16) & 0xff;\n\tg = (argb8888 >> 8) & 0xff;\n\tb = (argb8888 >> 0) & 0xff;\n\n\tv = ((u64)c8_to_c12(a, m) << 36) | ((u64)c8_to_c12(r, m) << 24) |\n\t\t((u64)c8_to_c12(g, m) << 12) | (u64)c8_to_c12(b, m);\n\n\treturn v;\n}\n\nstatic void dispc_vp_set_default_color(struct dispc_device *dispc,\n\t\t\t\t       u32 hw_videoport, u32 default_color)\n{\n\tu64 v;\n\n\tv = argb8888_to_argb12121212(default_color, C8_TO_C12_REPLICATE);\n\n\tdispc_ovr_write(dispc, hw_videoport,\n\t\t\tDISPC_OVR_DEFAULT_COLOR, v & 0xffffffff);\n\tdispc_ovr_write(dispc, hw_videoport,\n\t\t\tDISPC_OVR_DEFAULT_COLOR2, (v >> 32) & 0xffff);\n}\n\nenum drm_mode_status dispc_vp_mode_valid(struct dispc_device *dispc,\n\t\t\t\t\t u32 hw_videoport,\n\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tu32 hsw, hfp, hbp, vsw, vfp, vbp;\n\tenum dispc_vp_bus_type bus_type;\n\tint max_pclk;\n\n\tbus_type = dispc->feat->vp_bus_type[hw_videoport];\n\n\tmax_pclk = dispc->feat->max_pclk_khz[bus_type];\n\n\tif (WARN_ON(max_pclk == 0))\n\t\treturn MODE_BAD;\n\n\tif (mode->clock < dispc->feat->min_pclk_khz)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (mode->clock > max_pclk)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode->hdisplay > 4096)\n\t\treturn MODE_BAD;\n\n\tif (mode->vdisplay > 4096)\n\t\treturn MODE_BAD;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn MODE_NO_INTERLACE;\n\n\t \n\tif ((mode->hdisplay % 2) != 0)\n\t\treturn MODE_BAD_HVALUE;\n\n\thfp = mode->hsync_start - mode->hdisplay;\n\thsw = mode->hsync_end - mode->hsync_start;\n\thbp = mode->htotal - mode->hsync_end;\n\n\tvfp = mode->vsync_start - mode->vdisplay;\n\tvsw = mode->vsync_end - mode->vsync_start;\n\tvbp = mode->vtotal - mode->vsync_end;\n\n\tif (hsw < 1 || hsw > 256 ||\n\t    hfp < 1 || hfp > 4096 ||\n\t    hbp < 1 || hbp > 4096)\n\t\treturn MODE_BAD_HVALUE;\n\n\tif (vsw < 1 || vsw > 256 ||\n\t    vfp > 4095 || vbp > 4095)\n\t\treturn MODE_BAD_VVALUE;\n\n\tif (dispc->memory_bandwidth_limit) {\n\t\tconst unsigned int bpp = 4;\n\t\tu64 bandwidth;\n\n\t\tbandwidth = 1000 * mode->clock;\n\t\tbandwidth = bandwidth * mode->hdisplay * mode->vdisplay * bpp;\n\t\tbandwidth = div_u64(bandwidth, mode->htotal * mode->vtotal);\n\n\t\tif (dispc->memory_bandwidth_limit < bandwidth)\n\t\t\treturn MODE_BAD;\n\t}\n\n\treturn MODE_OK;\n}\n\nint dispc_vp_enable_clk(struct dispc_device *dispc, u32 hw_videoport)\n{\n\tint ret = clk_prepare_enable(dispc->vp_clk[hw_videoport]);\n\n\tif (ret)\n\t\tdev_err(dispc->dev, \"%s: enabling clk failed: %d\\n\", __func__,\n\t\t\tret);\n\n\treturn ret;\n}\n\nvoid dispc_vp_disable_clk(struct dispc_device *dispc, u32 hw_videoport)\n{\n\tclk_disable_unprepare(dispc->vp_clk[hw_videoport]);\n}\n\n \nstatic\nunsigned int dispc_pclk_diff(unsigned long rate, unsigned long real_rate)\n{\n\tint r = rate / 100, rr = real_rate / 100;\n\n\treturn (unsigned int)(abs(((rr - r) * 100) / r));\n}\n\nint dispc_vp_set_clk_rate(struct dispc_device *dispc, u32 hw_videoport,\n\t\t\t  unsigned long rate)\n{\n\tint r;\n\tunsigned long new_rate;\n\n\tr = clk_set_rate(dispc->vp_clk[hw_videoport], rate);\n\tif (r) {\n\t\tdev_err(dispc->dev, \"vp%d: failed to set clk rate to %lu\\n\",\n\t\t\thw_videoport, rate);\n\t\treturn r;\n\t}\n\n\tnew_rate = clk_get_rate(dispc->vp_clk[hw_videoport]);\n\n\tif (dispc_pclk_diff(rate, new_rate) > 5)\n\t\tdev_warn(dispc->dev,\n\t\t\t \"vp%d: Clock rate %lu differs over 5%% from requested %lu\\n\",\n\t\t\t hw_videoport, new_rate, rate);\n\n\tdev_dbg(dispc->dev, \"vp%d: new rate %lu Hz (requested %lu Hz)\\n\",\n\t\thw_videoport, clk_get_rate(dispc->vp_clk[hw_videoport]), rate);\n\n\treturn 0;\n}\n\n \nstatic void dispc_k2g_ovr_set_plane(struct dispc_device *dispc,\n\t\t\t\t    u32 hw_plane, u32 hw_videoport,\n\t\t\t\t    u32 x, u32 y, u32 layer)\n{\n\t \n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_K2G_POSITION,\n\t\t\tx | (y << 16));\n}\n\nstatic void dispc_am65x_ovr_set_plane(struct dispc_device *dispc,\n\t\t\t\t      u32 hw_plane, u32 hw_videoport,\n\t\t\t\t      u32 x, u32 y, u32 layer)\n{\n\tOVR_REG_FLD_MOD(dispc, hw_videoport, DISPC_OVR_ATTRIBUTES(layer),\n\t\t\thw_plane, 4, 1);\n\tOVR_REG_FLD_MOD(dispc, hw_videoport, DISPC_OVR_ATTRIBUTES(layer),\n\t\t\tx, 17, 6);\n\tOVR_REG_FLD_MOD(dispc, hw_videoport, DISPC_OVR_ATTRIBUTES(layer),\n\t\t\ty, 30, 19);\n}\n\nstatic void dispc_j721e_ovr_set_plane(struct dispc_device *dispc,\n\t\t\t\t      u32 hw_plane, u32 hw_videoport,\n\t\t\t\t      u32 x, u32 y, u32 layer)\n{\n\tOVR_REG_FLD_MOD(dispc, hw_videoport, DISPC_OVR_ATTRIBUTES(layer),\n\t\t\thw_plane, 4, 1);\n\tOVR_REG_FLD_MOD(dispc, hw_videoport, DISPC_OVR_ATTRIBUTES2(layer),\n\t\t\tx, 13, 0);\n\tOVR_REG_FLD_MOD(dispc, hw_videoport, DISPC_OVR_ATTRIBUTES2(layer),\n\t\t\ty, 29, 16);\n}\n\nvoid dispc_ovr_set_plane(struct dispc_device *dispc, u32 hw_plane,\n\t\t\t u32 hw_videoport, u32 x, u32 y, u32 layer)\n{\n\tswitch (dispc->feat->subrev) {\n\tcase DISPC_K2G:\n\t\tdispc_k2g_ovr_set_plane(dispc, hw_plane, hw_videoport,\n\t\t\t\t\tx, y, layer);\n\t\tbreak;\n\tcase DISPC_AM625:\n\tcase DISPC_AM65X:\n\t\tdispc_am65x_ovr_set_plane(dispc, hw_plane, hw_videoport,\n\t\t\t\t\t  x, y, layer);\n\t\tbreak;\n\tcase DISPC_J721E:\n\t\tdispc_j721e_ovr_set_plane(dispc, hw_plane, hw_videoport,\n\t\t\t\t\t  x, y, layer);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nvoid dispc_ovr_enable_layer(struct dispc_device *dispc,\n\t\t\t    u32 hw_videoport, u32 layer, bool enable)\n{\n\tif (dispc->feat->subrev == DISPC_K2G)\n\t\treturn;\n\n\tOVR_REG_FLD_MOD(dispc, hw_videoport, DISPC_OVR_ATTRIBUTES(layer),\n\t\t\t!!enable, 0, 0);\n}\n\n \nenum csc_ctm {\n\tCSC_RR, CSC_RG, CSC_RB,\n\tCSC_GR, CSC_GG, CSC_GB,\n\tCSC_BR, CSC_BG, CSC_BB,\n};\n\nenum csc_yuv2rgb {\n\tCSC_RY, CSC_RCB, CSC_RCR,\n\tCSC_GY, CSC_GCB, CSC_GCR,\n\tCSC_BY, CSC_BCB, CSC_BCR,\n};\n\nenum csc_rgb2yuv {\n\tCSC_YR,  CSC_YG,  CSC_YB,\n\tCSC_CBR, CSC_CBG, CSC_CBB,\n\tCSC_CRR, CSC_CRG, CSC_CRB,\n};\n\nstruct dispc_csc_coef {\n\tvoid (*to_regval)(const struct dispc_csc_coef *csc, u32 *regval);\n\tint m[9];\n\tint preoffset[3];\n\tint postoffset[3];\n\tenum { CLIP_LIMITED_RANGE = 0, CLIP_FULL_RANGE = 1, } cliping;\n\tconst char *name;\n};\n\n#define DISPC_CSC_REGVAL_LEN 8\n\nstatic\nvoid dispc_csc_offset_regval(const struct dispc_csc_coef *csc, u32 *regval)\n{\n#define OVAL(x, y) (FLD_VAL(x, 15, 3) | FLD_VAL(y, 31, 19))\n\tregval[5] = OVAL(csc->preoffset[0], csc->preoffset[1]);\n\tregval[6] = OVAL(csc->preoffset[2], csc->postoffset[0]);\n\tregval[7] = OVAL(csc->postoffset[1], csc->postoffset[2]);\n#undef OVAL\n}\n\n#define CVAL(x, y) (FLD_VAL(x, 10, 0) | FLD_VAL(y, 26, 16))\nstatic\nvoid dispc_csc_yuv2rgb_regval(const struct dispc_csc_coef *csc, u32 *regval)\n{\n\tregval[0] = CVAL(csc->m[CSC_RY], csc->m[CSC_RCR]);\n\tregval[1] = CVAL(csc->m[CSC_RCB], csc->m[CSC_GY]);\n\tregval[2] = CVAL(csc->m[CSC_GCR], csc->m[CSC_GCB]);\n\tregval[3] = CVAL(csc->m[CSC_BY], csc->m[CSC_BCR]);\n\tregval[4] = CVAL(csc->m[CSC_BCB], 0);\n\n\tdispc_csc_offset_regval(csc, regval);\n}\n\n__maybe_unused static\nvoid dispc_csc_rgb2yuv_regval(const struct dispc_csc_coef *csc, u32 *regval)\n{\n\tregval[0] = CVAL(csc->m[CSC_YR], csc->m[CSC_YG]);\n\tregval[1] = CVAL(csc->m[CSC_YB], csc->m[CSC_CRR]);\n\tregval[2] = CVAL(csc->m[CSC_CRG], csc->m[CSC_CRB]);\n\tregval[3] = CVAL(csc->m[CSC_CBR], csc->m[CSC_CBG]);\n\tregval[4] = CVAL(csc->m[CSC_CBB], 0);\n\n\tdispc_csc_offset_regval(csc, regval);\n}\n\nstatic void dispc_csc_cpr_regval(const struct dispc_csc_coef *csc,\n\t\t\t\t u32 *regval)\n{\n\tregval[0] = CVAL(csc->m[CSC_RR], csc->m[CSC_RG]);\n\tregval[1] = CVAL(csc->m[CSC_RB], csc->m[CSC_GR]);\n\tregval[2] = CVAL(csc->m[CSC_GG], csc->m[CSC_GB]);\n\tregval[3] = CVAL(csc->m[CSC_BR], csc->m[CSC_BG]);\n\tregval[4] = CVAL(csc->m[CSC_BB], 0);\n\n\tdispc_csc_offset_regval(csc, regval);\n}\n\n#undef CVAL\n\nstatic void dispc_k2g_vid_write_csc(struct dispc_device *dispc, u32 hw_plane,\n\t\t\t\t    const struct dispc_csc_coef *csc)\n{\n\tstatic const u16 dispc_vid_csc_coef_reg[] = {\n\t\tDISPC_VID_CSC_COEF(0), DISPC_VID_CSC_COEF(1),\n\t\tDISPC_VID_CSC_COEF(2), DISPC_VID_CSC_COEF(3),\n\t\tDISPC_VID_CSC_COEF(4), DISPC_VID_CSC_COEF(5),\n\t\tDISPC_VID_CSC_COEF(6),  \n\t};\n\tu32 regval[DISPC_CSC_REGVAL_LEN];\n\tunsigned int i;\n\n\tcsc->to_regval(csc, regval);\n\n\tif (regval[7] != 0)\n\t\tdev_warn(dispc->dev, \"%s: No post offset support for %s\\n\",\n\t\t\t __func__, csc->name);\n\n\tfor (i = 0; i < ARRAY_SIZE(dispc_vid_csc_coef_reg); i++)\n\t\tdispc_vid_write(dispc, hw_plane, dispc_vid_csc_coef_reg[i],\n\t\t\t\tregval[i]);\n}\n\nstatic void dispc_k3_vid_write_csc(struct dispc_device *dispc, u32 hw_plane,\n\t\t\t\t   const struct dispc_csc_coef *csc)\n{\n\tstatic const u16 dispc_vid_csc_coef_reg[DISPC_CSC_REGVAL_LEN] = {\n\t\tDISPC_VID_CSC_COEF(0), DISPC_VID_CSC_COEF(1),\n\t\tDISPC_VID_CSC_COEF(2), DISPC_VID_CSC_COEF(3),\n\t\tDISPC_VID_CSC_COEF(4), DISPC_VID_CSC_COEF(5),\n\t\tDISPC_VID_CSC_COEF(6), DISPC_VID_CSC_COEF7,\n\t};\n\tu32 regval[DISPC_CSC_REGVAL_LEN];\n\tunsigned int i;\n\n\tcsc->to_regval(csc, regval);\n\n\tfor (i = 0; i < ARRAY_SIZE(dispc_vid_csc_coef_reg); i++)\n\t\tdispc_vid_write(dispc, hw_plane, dispc_vid_csc_coef_reg[i],\n\t\t\t\tregval[i]);\n}\n\n \nstatic const struct dispc_csc_coef csc_yuv2rgb_bt601_full = {\n\tdispc_csc_yuv2rgb_regval,\n\t{ 256,   0,  358,\t \n\t  256, -88, -182,\t \n\t  256, 452,    0, },\t \n\t{    0, -2048, -2048, },\t \n\t{    0,     0,     0, },\n\tCLIP_FULL_RANGE,\n\t\"BT.601 Full\",\n};\n\n \nstatic const struct dispc_csc_coef csc_yuv2rgb_bt601_lim = {\n\tdispc_csc_yuv2rgb_regval,\n\t{ 298,    0,  409,\t \n\t  298, -100, -208,\t \n\t  298,  516,    0, },\t \n\t{ -256, -2048, -2048, },\t \n\t{    0,     0,     0, },\n\tCLIP_FULL_RANGE,\n\t\"BT.601 Limited\",\n};\n\n \nstatic const struct dispc_csc_coef csc_yuv2rgb_bt709_full = {\n\tdispc_csc_yuv2rgb_regval,\n\t{ 256,\t  0,  402,\t \n\t  256,  -48, -120,\t \n\t  256,  475,    0, },\t \n\t{    0, -2048, -2048, },\t \n\t{    0,     0,     0, },\n\tCLIP_FULL_RANGE,\n\t\"BT.709 Full\",\n};\n\n \nstatic const struct dispc_csc_coef csc_yuv2rgb_bt709_lim = {\n\tdispc_csc_yuv2rgb_regval,\n\t{ 298,    0,  459,\t \n\t  298,  -55, -136,\t \n\t  298,  541,    0, },\t \n\t{ -256, -2048, -2048, },\t \n\t{    0,     0,     0, },\n\tCLIP_FULL_RANGE,\n\t\"BT.709 Limited\",\n};\n\nstatic const struct {\n\tenum drm_color_encoding encoding;\n\tenum drm_color_range range;\n\tconst struct dispc_csc_coef *csc;\n} dispc_csc_table[] = {\n\t{ DRM_COLOR_YCBCR_BT601, DRM_COLOR_YCBCR_FULL_RANGE,\n\t  &csc_yuv2rgb_bt601_full, },\n\t{ DRM_COLOR_YCBCR_BT601, DRM_COLOR_YCBCR_LIMITED_RANGE,\n\t  &csc_yuv2rgb_bt601_lim, },\n\t{ DRM_COLOR_YCBCR_BT709, DRM_COLOR_YCBCR_FULL_RANGE,\n\t  &csc_yuv2rgb_bt709_full, },\n\t{ DRM_COLOR_YCBCR_BT709, DRM_COLOR_YCBCR_LIMITED_RANGE,\n\t  &csc_yuv2rgb_bt709_lim, },\n};\n\nstatic const\nstruct dispc_csc_coef *dispc_find_csc(enum drm_color_encoding encoding,\n\t\t\t\t      enum drm_color_range range)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dispc_csc_table); i++) {\n\t\tif (dispc_csc_table[i].encoding == encoding &&\n\t\t    dispc_csc_table[i].range == range) {\n\t\t\treturn dispc_csc_table[i].csc;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void dispc_vid_csc_setup(struct dispc_device *dispc, u32 hw_plane,\n\t\t\t\tconst struct drm_plane_state *state)\n{\n\tconst struct dispc_csc_coef *coef;\n\n\tcoef = dispc_find_csc(state->color_encoding, state->color_range);\n\tif (!coef) {\n\t\tdev_err(dispc->dev, \"%s: CSC (%u,%u) not found\\n\",\n\t\t\t__func__, state->color_encoding, state->color_range);\n\t\treturn;\n\t}\n\n\tif (dispc->feat->subrev == DISPC_K2G)\n\t\tdispc_k2g_vid_write_csc(dispc, hw_plane, coef);\n\telse\n\t\tdispc_k3_vid_write_csc(dispc, hw_plane, coef);\n}\n\nstatic void dispc_vid_csc_enable(struct dispc_device *dispc, u32 hw_plane,\n\t\t\t\t bool enable)\n{\n\tVID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES, !!enable, 9, 9);\n}\n\n \n\nstatic u32 dispc_calc_fir_inc(u32 in, u32 out)\n{\n\treturn (u32)div_u64(0x200000ull * in, out);\n}\n\nenum dispc_vid_fir_coef_set {\n\tDISPC_VID_FIR_COEF_HORIZ,\n\tDISPC_VID_FIR_COEF_HORIZ_UV,\n\tDISPC_VID_FIR_COEF_VERT,\n\tDISPC_VID_FIR_COEF_VERT_UV,\n};\n\nstatic void dispc_vid_write_fir_coefs(struct dispc_device *dispc,\n\t\t\t\t      u32 hw_plane,\n\t\t\t\t      enum dispc_vid_fir_coef_set coef_set,\n\t\t\t\t      const struct tidss_scale_coefs *coefs)\n{\n\tstatic const u16 c0_regs[] = {\n\t\t[DISPC_VID_FIR_COEF_HORIZ] = DISPC_VID_FIR_COEFS_H0,\n\t\t[DISPC_VID_FIR_COEF_HORIZ_UV] = DISPC_VID_FIR_COEFS_H0_C,\n\t\t[DISPC_VID_FIR_COEF_VERT] = DISPC_VID_FIR_COEFS_V0,\n\t\t[DISPC_VID_FIR_COEF_VERT_UV] = DISPC_VID_FIR_COEFS_V0_C,\n\t};\n\n\tstatic const u16 c12_regs[] = {\n\t\t[DISPC_VID_FIR_COEF_HORIZ] = DISPC_VID_FIR_COEFS_H12,\n\t\t[DISPC_VID_FIR_COEF_HORIZ_UV] = DISPC_VID_FIR_COEFS_H12_C,\n\t\t[DISPC_VID_FIR_COEF_VERT] = DISPC_VID_FIR_COEFS_V12,\n\t\t[DISPC_VID_FIR_COEF_VERT_UV] = DISPC_VID_FIR_COEFS_V12_C,\n\t};\n\n\tconst u16 c0_base = c0_regs[coef_set];\n\tconst u16 c12_base = c12_regs[coef_set];\n\tint phase;\n\n\tif (!coefs) {\n\t\tdev_err(dispc->dev, \"%s: No coefficients given.\\n\", __func__);\n\t\treturn;\n\t}\n\n\tfor (phase = 0; phase <= 8; ++phase) {\n\t\tu16 reg = c0_base + phase * 4;\n\t\tu16 c0 = coefs->c0[phase];\n\n\t\tdispc_vid_write(dispc, hw_plane, reg, c0);\n\t}\n\n\tfor (phase = 0; phase <= 15; ++phase) {\n\t\tu16 reg = c12_base + phase * 4;\n\t\ts16 c1, c2;\n\t\tu32 c12;\n\n\t\tc1 = coefs->c1[phase];\n\t\tc2 = coefs->c2[phase];\n\t\tc12 = FLD_VAL(c1, 19, 10) | FLD_VAL(c2, 29, 20);\n\n\t\tdispc_vid_write(dispc, hw_plane, reg, c12);\n\t}\n}\n\nstatic bool dispc_fourcc_is_yuv(u32 fourcc)\n{\n\tswitch (fourcc) {\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_NV12:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstruct dispc_scaling_params {\n\tint xinc, yinc;\n\tu32 in_w, in_h, in_w_uv, in_h_uv;\n\tu32 fir_xinc, fir_yinc, fir_xinc_uv, fir_yinc_uv;\n\tbool scale_x, scale_y;\n\tconst struct tidss_scale_coefs *xcoef, *ycoef, *xcoef_uv, *ycoef_uv;\n\tbool five_taps;\n};\n\nstatic int dispc_vid_calc_scaling(struct dispc_device *dispc,\n\t\t\t\t  const struct drm_plane_state *state,\n\t\t\t\t  struct dispc_scaling_params *sp,\n\t\t\t\t  bool lite_plane)\n{\n\tconst struct dispc_features_scaling *f = &dispc->feat->scaling;\n\tu32 fourcc = state->fb->format->format;\n\tu32 in_width_max_5tap = f->in_width_max_5tap_rgb;\n\tu32 in_width_max_3tap = f->in_width_max_3tap_rgb;\n\tu32 downscale_limit;\n\tu32 in_width_max;\n\n\tmemset(sp, 0, sizeof(*sp));\n\tsp->xinc = 1;\n\tsp->yinc = 1;\n\tsp->in_w = state->src_w >> 16;\n\tsp->in_w_uv = sp->in_w;\n\tsp->in_h = state->src_h >> 16;\n\tsp->in_h_uv = sp->in_h;\n\n\tsp->scale_x = sp->in_w != state->crtc_w;\n\tsp->scale_y = sp->in_h != state->crtc_h;\n\n\tif (dispc_fourcc_is_yuv(fourcc)) {\n\t\tin_width_max_5tap = f->in_width_max_5tap_yuv;\n\t\tin_width_max_3tap = f->in_width_max_3tap_yuv;\n\n\t\tsp->in_w_uv >>= 1;\n\t\tsp->scale_x = true;\n\n\t\tif (fourcc == DRM_FORMAT_NV12) {\n\t\t\tsp->in_h_uv >>= 1;\n\t\t\tsp->scale_y = true;\n\t\t}\n\t}\n\n\t \n\tif ((!sp->scale_x && !sp->scale_y) || lite_plane)\n\t\treturn 0;\n\n\tif (sp->in_w > in_width_max_5tap) {\n\t\tsp->five_taps = false;\n\t\tin_width_max = in_width_max_3tap;\n\t\tdownscale_limit = f->downscale_limit_3tap;\n\t} else {\n\t\tsp->five_taps = true;\n\t\tin_width_max = in_width_max_5tap;\n\t\tdownscale_limit = f->downscale_limit_5tap;\n\t}\n\n\tif (sp->scale_x) {\n\t\tsp->fir_xinc = dispc_calc_fir_inc(sp->in_w, state->crtc_w);\n\n\t\tif (sp->fir_xinc < dispc_calc_fir_inc(1, f->upscale_limit)) {\n\t\t\tdev_dbg(dispc->dev,\n\t\t\t\t\"%s: X-scaling factor %u/%u > %u\\n\",\n\t\t\t\t__func__, state->crtc_w, state->src_w >> 16,\n\t\t\t\tf->upscale_limit);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sp->fir_xinc >= dispc_calc_fir_inc(downscale_limit, 1)) {\n\t\t\tsp->xinc = DIV_ROUND_UP(DIV_ROUND_UP(sp->in_w,\n\t\t\t\t\t\t\t     state->crtc_w),\n\t\t\t\t\t\tdownscale_limit);\n\n\t\t\tif (sp->xinc > f->xinc_max) {\n\t\t\t\tdev_dbg(dispc->dev,\n\t\t\t\t\t\"%s: X-scaling factor %u/%u < 1/%u\\n\",\n\t\t\t\t\t__func__, state->crtc_w,\n\t\t\t\t\tstate->src_w >> 16,\n\t\t\t\t\tdownscale_limit * f->xinc_max);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tsp->in_w = (state->src_w >> 16) / sp->xinc;\n\t\t}\n\n\t\twhile (sp->in_w > in_width_max) {\n\t\t\tsp->xinc++;\n\t\t\tsp->in_w = (state->src_w >> 16) / sp->xinc;\n\t\t}\n\n\t\tif (sp->xinc > f->xinc_max) {\n\t\t\tdev_dbg(dispc->dev,\n\t\t\t\t\"%s: Too wide input buffer %u > %u\\n\", __func__,\n\t\t\t\tstate->src_w >> 16, in_width_max * f->xinc_max);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (dispc_fourcc_is_yuv(fourcc))\n\t\t\tsp->in_w &= ~1;\n\n\t\tsp->fir_xinc = dispc_calc_fir_inc(sp->in_w, state->crtc_w);\n\t}\n\n\tif (sp->scale_y) {\n\t\tsp->fir_yinc = dispc_calc_fir_inc(sp->in_h, state->crtc_h);\n\n\t\tif (sp->fir_yinc < dispc_calc_fir_inc(1, f->upscale_limit)) {\n\t\t\tdev_dbg(dispc->dev,\n\t\t\t\t\"%s: Y-scaling factor %u/%u > %u\\n\",\n\t\t\t\t__func__, state->crtc_h, state->src_h >> 16,\n\t\t\t\tf->upscale_limit);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sp->fir_yinc >= dispc_calc_fir_inc(downscale_limit, 1)) {\n\t\t\tsp->yinc = DIV_ROUND_UP(DIV_ROUND_UP(sp->in_h,\n\t\t\t\t\t\t\t     state->crtc_h),\n\t\t\t\t\t\tdownscale_limit);\n\n\t\t\tsp->in_h /= sp->yinc;\n\t\t\tsp->fir_yinc = dispc_calc_fir_inc(sp->in_h,\n\t\t\t\t\t\t\t  state->crtc_h);\n\t\t}\n\t}\n\n\tdev_dbg(dispc->dev,\n\t\t\"%s: %ux%u decim %ux%u -> %ux%u firinc %u.%03ux%u.%03u taps %u -> %ux%u\\n\",\n\t\t__func__, state->src_w >> 16, state->src_h >> 16,\n\t\tsp->xinc, sp->yinc, sp->in_w, sp->in_h,\n\t\tsp->fir_xinc / 0x200000u,\n\t\t((sp->fir_xinc & 0x1FFFFFu) * 999u) / 0x1FFFFFu,\n\t\tsp->fir_yinc / 0x200000u,\n\t\t((sp->fir_yinc & 0x1FFFFFu) * 999u) / 0x1FFFFFu,\n\t\tsp->five_taps ? 5 : 3,\n\t\tstate->crtc_w, state->crtc_h);\n\n\tif (dispc_fourcc_is_yuv(fourcc)) {\n\t\tif (sp->scale_x) {\n\t\t\tsp->in_w_uv /= sp->xinc;\n\t\t\tsp->fir_xinc_uv = dispc_calc_fir_inc(sp->in_w_uv,\n\t\t\t\t\t\t\t     state->crtc_w);\n\t\t\tsp->xcoef_uv = tidss_get_scale_coefs(dispc->dev,\n\t\t\t\t\t\t\t     sp->fir_xinc_uv,\n\t\t\t\t\t\t\t     true);\n\t\t}\n\t\tif (sp->scale_y) {\n\t\t\tsp->in_h_uv /= sp->yinc;\n\t\t\tsp->fir_yinc_uv = dispc_calc_fir_inc(sp->in_h_uv,\n\t\t\t\t\t\t\t     state->crtc_h);\n\t\t\tsp->ycoef_uv = tidss_get_scale_coefs(dispc->dev,\n\t\t\t\t\t\t\t     sp->fir_yinc_uv,\n\t\t\t\t\t\t\t     sp->five_taps);\n\t\t}\n\t}\n\n\tif (sp->scale_x)\n\t\tsp->xcoef = tidss_get_scale_coefs(dispc->dev, sp->fir_xinc,\n\t\t\t\t\t\t  true);\n\n\tif (sp->scale_y)\n\t\tsp->ycoef = tidss_get_scale_coefs(dispc->dev, sp->fir_yinc,\n\t\t\t\t\t\t  sp->five_taps);\n\n\treturn 0;\n}\n\nstatic void dispc_vid_set_scaling(struct dispc_device *dispc,\n\t\t\t\t  u32 hw_plane,\n\t\t\t\t  struct dispc_scaling_params *sp,\n\t\t\t\t  u32 fourcc)\n{\n\t \n\tVID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES,\n\t\t\tsp->scale_x, 7, 7);\n\n\t \n\tVID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES,\n\t\t\tsp->scale_y, 8, 8);\n\n\t \n\tif (!sp->scale_x && !sp->scale_y)\n\t\treturn;\n\n\t \n\tVID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES,\n\t\t\tsp->five_taps, 21, 21);\n\n\tif (dispc_fourcc_is_yuv(fourcc)) {\n\t\tif (sp->scale_x) {\n\t\t\tdispc_vid_write(dispc, hw_plane, DISPC_VID_FIRH2,\n\t\t\t\t\tsp->fir_xinc_uv);\n\t\t\tdispc_vid_write_fir_coefs(dispc, hw_plane,\n\t\t\t\t\t\t  DISPC_VID_FIR_COEF_HORIZ_UV,\n\t\t\t\t\t\t  sp->xcoef_uv);\n\t\t}\n\t\tif (sp->scale_y) {\n\t\t\tdispc_vid_write(dispc, hw_plane, DISPC_VID_FIRV2,\n\t\t\t\t\tsp->fir_yinc_uv);\n\t\t\tdispc_vid_write_fir_coefs(dispc, hw_plane,\n\t\t\t\t\t\t  DISPC_VID_FIR_COEF_VERT_UV,\n\t\t\t\t\t\t  sp->ycoef_uv);\n\t\t}\n\t}\n\n\tif (sp->scale_x) {\n\t\tdispc_vid_write(dispc, hw_plane, DISPC_VID_FIRH, sp->fir_xinc);\n\t\tdispc_vid_write_fir_coefs(dispc, hw_plane,\n\t\t\t\t\t  DISPC_VID_FIR_COEF_HORIZ,\n\t\t\t\t\t  sp->xcoef);\n\t}\n\n\tif (sp->scale_y) {\n\t\tdispc_vid_write(dispc, hw_plane, DISPC_VID_FIRV, sp->fir_yinc);\n\t\tdispc_vid_write_fir_coefs(dispc, hw_plane,\n\t\t\t\t\t  DISPC_VID_FIR_COEF_VERT, sp->ycoef);\n\t}\n}\n\n \n\nstatic const struct {\n\tu32 fourcc;\n\tu8 dss_code;\n} dispc_color_formats[] = {\n\t{ DRM_FORMAT_ARGB4444, 0x0, },\n\t{ DRM_FORMAT_ABGR4444, 0x1, },\n\t{ DRM_FORMAT_RGBA4444, 0x2, },\n\n\t{ DRM_FORMAT_RGB565, 0x3, },\n\t{ DRM_FORMAT_BGR565, 0x4, },\n\n\t{ DRM_FORMAT_ARGB1555, 0x5, },\n\t{ DRM_FORMAT_ABGR1555, 0x6, },\n\n\t{ DRM_FORMAT_ARGB8888, 0x7, },\n\t{ DRM_FORMAT_ABGR8888, 0x8, },\n\t{ DRM_FORMAT_RGBA8888, 0x9, },\n\t{ DRM_FORMAT_BGRA8888, 0xa, },\n\n\t{ DRM_FORMAT_RGB888, 0xb, },\n\t{ DRM_FORMAT_BGR888, 0xc, },\n\n\t{ DRM_FORMAT_ARGB2101010, 0xe, },\n\t{ DRM_FORMAT_ABGR2101010, 0xf, },\n\n\t{ DRM_FORMAT_XRGB4444, 0x20, },\n\t{ DRM_FORMAT_XBGR4444, 0x21, },\n\t{ DRM_FORMAT_RGBX4444, 0x22, },\n\n\t{ DRM_FORMAT_XRGB1555, 0x25, },\n\t{ DRM_FORMAT_XBGR1555, 0x26, },\n\n\t{ DRM_FORMAT_XRGB8888, 0x27, },\n\t{ DRM_FORMAT_XBGR8888, 0x28, },\n\t{ DRM_FORMAT_RGBX8888, 0x29, },\n\t{ DRM_FORMAT_BGRX8888, 0x2a, },\n\n\t{ DRM_FORMAT_XRGB2101010, 0x2e, },\n\t{ DRM_FORMAT_XBGR2101010, 0x2f, },\n\n\t{ DRM_FORMAT_YUYV, 0x3e, },\n\t{ DRM_FORMAT_UYVY, 0x3f, },\n\n\t{ DRM_FORMAT_NV12, 0x3d, },\n};\n\nstatic void dispc_plane_set_pixel_format(struct dispc_device *dispc,\n\t\t\t\t\t u32 hw_plane, u32 fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dispc_color_formats); ++i) {\n\t\tif (dispc_color_formats[i].fourcc == fourcc) {\n\t\t\tVID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES,\n\t\t\t\t\tdispc_color_formats[i].dss_code,\n\t\t\t\t\t6, 1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN_ON(1);\n}\n\nconst u32 *dispc_plane_formats(struct dispc_device *dispc, unsigned int *len)\n{\n\tWARN_ON(!dispc->fourccs);\n\n\t*len = dispc->num_fourccs;\n\n\treturn dispc->fourccs;\n}\n\nstatic s32 pixinc(int pixels, u8 ps)\n{\n\tif (pixels == 1)\n\t\treturn 1;\n\telse if (pixels > 1)\n\t\treturn 1 + (pixels - 1) * ps;\n\telse if (pixels < 0)\n\t\treturn 1 - (-pixels + 1) * ps;\n\n\tWARN_ON(1);\n\treturn 0;\n}\n\nint dispc_plane_check(struct dispc_device *dispc, u32 hw_plane,\n\t\t      const struct drm_plane_state *state,\n\t\t      u32 hw_videoport)\n{\n\tbool lite = dispc->feat->vid_lite[hw_plane];\n\tu32 fourcc = state->fb->format->format;\n\tbool need_scaling = state->src_w >> 16 != state->crtc_w ||\n\t\tstate->src_h >> 16 != state->crtc_h;\n\tstruct dispc_scaling_params scaling;\n\tint ret;\n\n\tif (dispc_fourcc_is_yuv(fourcc)) {\n\t\tif (!dispc_find_csc(state->color_encoding,\n\t\t\t\t    state->color_range)) {\n\t\t\tdev_dbg(dispc->dev,\n\t\t\t\t\"%s: Unsupported CSC (%u,%u) for HW plane %u\\n\",\n\t\t\t\t__func__, state->color_encoding,\n\t\t\t\tstate->color_range, hw_plane);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (need_scaling) {\n\t\tif (lite) {\n\t\t\tdev_dbg(dispc->dev,\n\t\t\t\t\"%s: Lite plane %u can't scale %ux%u!=%ux%u\\n\",\n\t\t\t\t__func__, hw_plane,\n\t\t\t\tstate->src_w >> 16, state->src_h >> 16,\n\t\t\t\tstate->crtc_w, state->crtc_h);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = dispc_vid_calc_scaling(dispc, state, &scaling, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic\ndma_addr_t dispc_plane_state_dma_addr(const struct drm_plane_state *state)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_gem_dma_object *gem;\n\tu32 x = state->src_x >> 16;\n\tu32 y = state->src_y >> 16;\n\n\tgem = drm_fb_dma_get_gem_obj(state->fb, 0);\n\n\treturn gem->dma_addr + fb->offsets[0] + x * fb->format->cpp[0] +\n\t\ty * fb->pitches[0];\n}\n\nstatic\ndma_addr_t dispc_plane_state_p_uv_addr(const struct drm_plane_state *state)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_gem_dma_object *gem;\n\tu32 x = state->src_x >> 16;\n\tu32 y = state->src_y >> 16;\n\n\tif (WARN_ON(state->fb->format->num_planes != 2))\n\t\treturn 0;\n\n\tgem = drm_fb_dma_get_gem_obj(fb, 1);\n\n\treturn gem->dma_addr + fb->offsets[1] +\n\t\t(x * fb->format->cpp[1] / fb->format->hsub) +\n\t\t(y * fb->pitches[1] / fb->format->vsub);\n}\n\nvoid dispc_plane_setup(struct dispc_device *dispc, u32 hw_plane,\n\t\t       const struct drm_plane_state *state,\n\t\t       u32 hw_videoport)\n{\n\tbool lite = dispc->feat->vid_lite[hw_plane];\n\tu32 fourcc = state->fb->format->format;\n\tu16 cpp = state->fb->format->cpp[0];\n\tu32 fb_width = state->fb->pitches[0] / cpp;\n\tdma_addr_t dma_addr = dispc_plane_state_dma_addr(state);\n\tstruct dispc_scaling_params scale;\n\n\tdispc_vid_calc_scaling(dispc, state, &scale, lite);\n\n\tdispc_plane_set_pixel_format(dispc, hw_plane, fourcc);\n\n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_BA_0, dma_addr & 0xffffffff);\n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_BA_EXT_0, (u64)dma_addr >> 32);\n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_BA_1, dma_addr & 0xffffffff);\n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_BA_EXT_1, (u64)dma_addr >> 32);\n\n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_PICTURE_SIZE,\n\t\t\t(scale.in_w - 1) | ((scale.in_h - 1) << 16));\n\n\t \n\tif (fourcc == DRM_FORMAT_YUYV || fourcc == DRM_FORMAT_UYVY)\n\t\tdispc_vid_write(dispc, hw_plane, DISPC_VID_PIXEL_INC,\n\t\t\t\tpixinc(scale.xinc, cpp * 2));\n\telse\n\t\tdispc_vid_write(dispc, hw_plane, DISPC_VID_PIXEL_INC,\n\t\t\t\tpixinc(scale.xinc, cpp));\n\n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_ROW_INC,\n\t\t\tpixinc(1 + (scale.yinc * fb_width -\n\t\t\t\t    scale.xinc * scale.in_w),\n\t\t\t       cpp));\n\n\tif (state->fb->format->num_planes == 2) {\n\t\tu16 cpp_uv = state->fb->format->cpp[1];\n\t\tu32 fb_width_uv = state->fb->pitches[1] / cpp_uv;\n\t\tdma_addr_t p_uv_addr = dispc_plane_state_p_uv_addr(state);\n\n\t\tdispc_vid_write(dispc, hw_plane,\n\t\t\t\tDISPC_VID_BA_UV_0, p_uv_addr & 0xffffffff);\n\t\tdispc_vid_write(dispc, hw_plane,\n\t\t\t\tDISPC_VID_BA_UV_EXT_0, (u64)p_uv_addr >> 32);\n\t\tdispc_vid_write(dispc, hw_plane,\n\t\t\t\tDISPC_VID_BA_UV_1, p_uv_addr & 0xffffffff);\n\t\tdispc_vid_write(dispc, hw_plane,\n\t\t\t\tDISPC_VID_BA_UV_EXT_1, (u64)p_uv_addr >> 32);\n\n\t\tdispc_vid_write(dispc, hw_plane, DISPC_VID_ROW_INC_UV,\n\t\t\t\tpixinc(1 + (scale.yinc * fb_width_uv -\n\t\t\t\t\t    scale.xinc * scale.in_w_uv),\n\t\t\t\t       cpp_uv));\n\t}\n\n\tif (!lite) {\n\t\tdispc_vid_write(dispc, hw_plane, DISPC_VID_SIZE,\n\t\t\t\t(state->crtc_w - 1) |\n\t\t\t\t((state->crtc_h - 1) << 16));\n\n\t\tdispc_vid_set_scaling(dispc, hw_plane, &scale, fourcc);\n\t}\n\n\t \n\tif (dispc_fourcc_is_yuv(fourcc)) {\n\t\tdispc_vid_csc_setup(dispc, hw_plane, state);\n\t\tdispc_vid_csc_enable(dispc, hw_plane, true);\n\t} else {\n\t\tdispc_vid_csc_enable(dispc, hw_plane, false);\n\t}\n\n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_GLOBAL_ALPHA,\n\t\t\t0xFF & (state->alpha >> 8));\n\n\tif (state->pixel_blend_mode == DRM_MODE_BLEND_PREMULTI)\n\t\tVID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES, 1,\n\t\t\t\t28, 28);\n\telse\n\t\tVID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES, 0,\n\t\t\t\t28, 28);\n}\n\nvoid dispc_plane_enable(struct dispc_device *dispc, u32 hw_plane, bool enable)\n{\n\tVID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES, !!enable, 0, 0);\n}\n\nstatic u32 dispc_vid_get_fifo_size(struct dispc_device *dispc, u32 hw_plane)\n{\n\treturn VID_REG_GET(dispc, hw_plane, DISPC_VID_BUF_SIZE_STATUS, 15, 0);\n}\n\nstatic void dispc_vid_set_mflag_threshold(struct dispc_device *dispc,\n\t\t\t\t\t  u32 hw_plane, u32 low, u32 high)\n{\n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_MFLAG_THRESHOLD,\n\t\t\tFLD_VAL(high, 31, 16) | FLD_VAL(low, 15, 0));\n}\n\nstatic void dispc_vid_set_buf_threshold(struct dispc_device *dispc,\n\t\t\t\t\tu32 hw_plane, u32 low, u32 high)\n{\n\tdispc_vid_write(dispc, hw_plane, DISPC_VID_BUF_THRESHOLD,\n\t\t\tFLD_VAL(high, 31, 16) | FLD_VAL(low, 15, 0));\n}\n\nstatic void dispc_k2g_plane_init(struct dispc_device *dispc)\n{\n\tunsigned int hw_plane;\n\n\tdev_dbg(dispc->dev, \"%s()\\n\", __func__);\n\n\t \n\tREG_FLD_MOD(dispc, DISPC_GLOBAL_MFLAG_ATTRIBUTE, 2, 1, 0);\n\t \n\tREG_FLD_MOD(dispc, DISPC_GLOBAL_MFLAG_ATTRIBUTE, 0, 6, 6);\n\n\tfor (hw_plane = 0; hw_plane < dispc->feat->num_planes; hw_plane++) {\n\t\tu32 size = dispc_vid_get_fifo_size(dispc, hw_plane);\n\t\tu32 thr_low, thr_high;\n\t\tu32 mflag_low, mflag_high;\n\t\tu32 preload;\n\n\t\tthr_high = size - 1;\n\t\tthr_low = size / 2;\n\n\t\tmflag_high = size * 2 / 3;\n\t\tmflag_low = size / 3;\n\n\t\tpreload = thr_low;\n\n\t\tdev_dbg(dispc->dev,\n\t\t\t\"%s: bufsize %u, buf_threshold %u/%u, mflag threshold %u/%u preload %u\\n\",\n\t\t\tdispc->feat->vid_name[hw_plane],\n\t\t\tsize,\n\t\t\tthr_high, thr_low,\n\t\t\tmflag_high, mflag_low,\n\t\t\tpreload);\n\n\t\tdispc_vid_set_buf_threshold(dispc, hw_plane,\n\t\t\t\t\t    thr_low, thr_high);\n\t\tdispc_vid_set_mflag_threshold(dispc, hw_plane,\n\t\t\t\t\t      mflag_low, mflag_high);\n\n\t\tdispc_vid_write(dispc, hw_plane, DISPC_VID_PRELOAD, preload);\n\n\t\t \n\t\tVID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES, 1,\n\t\t\t\t19, 19);\n\t}\n}\n\nstatic void dispc_k3_plane_init(struct dispc_device *dispc)\n{\n\tunsigned int hw_plane;\n\tu32 cba_lo_pri = 1;\n\tu32 cba_hi_pri = 0;\n\n\tdev_dbg(dispc->dev, \"%s()\\n\", __func__);\n\n\tREG_FLD_MOD(dispc, DSS_CBA_CFG, cba_lo_pri, 2, 0);\n\tREG_FLD_MOD(dispc, DSS_CBA_CFG, cba_hi_pri, 5, 3);\n\n\t \n\tREG_FLD_MOD(dispc, DISPC_GLOBAL_MFLAG_ATTRIBUTE, 2, 1, 0);\n\t \n\tREG_FLD_MOD(dispc, DISPC_GLOBAL_MFLAG_ATTRIBUTE, 0, 6, 6);\n\n\tfor (hw_plane = 0; hw_plane < dispc->feat->num_planes; hw_plane++) {\n\t\tu32 size = dispc_vid_get_fifo_size(dispc, hw_plane);\n\t\tu32 thr_low, thr_high;\n\t\tu32 mflag_low, mflag_high;\n\t\tu32 preload;\n\n\t\tthr_high = size - 1;\n\t\tthr_low = size / 2;\n\n\t\tmflag_high = size * 2 / 3;\n\t\tmflag_low = size / 3;\n\n\t\tpreload = thr_low;\n\n\t\tdev_dbg(dispc->dev,\n\t\t\t\"%s: bufsize %u, buf_threshold %u/%u, mflag threshold %u/%u preload %u\\n\",\n\t\t\tdispc->feat->vid_name[hw_plane],\n\t\t\tsize,\n\t\t\tthr_high, thr_low,\n\t\t\tmflag_high, mflag_low,\n\t\t\tpreload);\n\n\t\tdispc_vid_set_buf_threshold(dispc, hw_plane,\n\t\t\t\t\t    thr_low, thr_high);\n\t\tdispc_vid_set_mflag_threshold(dispc, hw_plane,\n\t\t\t\t\t      mflag_low, mflag_high);\n\n\t\tdispc_vid_write(dispc, hw_plane, DISPC_VID_PRELOAD, preload);\n\n\t\t \n\t\tVID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES, 0,\n\t\t\t\t19, 19);\n\t}\n}\n\nstatic void dispc_plane_init(struct dispc_device *dispc)\n{\n\tswitch (dispc->feat->subrev) {\n\tcase DISPC_K2G:\n\t\tdispc_k2g_plane_init(dispc);\n\t\tbreak;\n\tcase DISPC_AM625:\n\tcase DISPC_AM65X:\n\tcase DISPC_J721E:\n\t\tdispc_k3_plane_init(dispc);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\nstatic void dispc_vp_init(struct dispc_device *dispc)\n{\n\tunsigned int i;\n\n\tdev_dbg(dispc->dev, \"%s()\\n\", __func__);\n\n\t \n\tfor (i = 0; i < dispc->feat->num_vps; i++)\n\t\tVP_REG_FLD_MOD(dispc, i, DISPC_VP_CONFIG, 1, 2, 2);\n}\n\nstatic void dispc_initial_config(struct dispc_device *dispc)\n{\n\tdispc_plane_init(dispc);\n\tdispc_vp_init(dispc);\n\n\t \n\tif (dispc->feat->subrev == DISPC_J721E) {\n\t\tdispc_write(dispc, DISPC_CONNECTIONS,\n\t\t\t    FLD_VAL(2, 3, 0) |\t\t \n\t\t\t    FLD_VAL(8, 7, 4)\t\t \n\t\t\t);\n\t}\n}\n\nstatic void dispc_k2g_vp_write_gamma_table(struct dispc_device *dispc,\n\t\t\t\t\t   u32 hw_videoport)\n{\n\tu32 *table = dispc->vp_data[hw_videoport].gamma_table;\n\tu32 hwlen = dispc->feat->vp_feat.color.gamma_size;\n\tunsigned int i;\n\n\tdev_dbg(dispc->dev, \"%s: hw_videoport %d\\n\", __func__, hw_videoport);\n\n\tif (WARN_ON(dispc->feat->vp_feat.color.gamma_type != TIDSS_GAMMA_8BIT))\n\t\treturn;\n\n\tfor (i = 0; i < hwlen; ++i) {\n\t\tu32 v = table[i];\n\n\t\tv |= i << 24;\n\n\t\tdispc_vp_write(dispc, hw_videoport, DISPC_VP_K2G_GAMMA_TABLE,\n\t\t\t       v);\n\t}\n}\n\nstatic void dispc_am65x_vp_write_gamma_table(struct dispc_device *dispc,\n\t\t\t\t\t     u32 hw_videoport)\n{\n\tu32 *table = dispc->vp_data[hw_videoport].gamma_table;\n\tu32 hwlen = dispc->feat->vp_feat.color.gamma_size;\n\tunsigned int i;\n\n\tdev_dbg(dispc->dev, \"%s: hw_videoport %d\\n\", __func__, hw_videoport);\n\n\tif (WARN_ON(dispc->feat->vp_feat.color.gamma_type != TIDSS_GAMMA_8BIT))\n\t\treturn;\n\n\tfor (i = 0; i < hwlen; ++i) {\n\t\tu32 v = table[i];\n\n\t\tv |= i << 24;\n\n\t\tdispc_vp_write(dispc, hw_videoport, DISPC_VP_GAMMA_TABLE, v);\n\t}\n}\n\nstatic void dispc_j721e_vp_write_gamma_table(struct dispc_device *dispc,\n\t\t\t\t\t     u32 hw_videoport)\n{\n\tu32 *table = dispc->vp_data[hw_videoport].gamma_table;\n\tu32 hwlen = dispc->feat->vp_feat.color.gamma_size;\n\tunsigned int i;\n\n\tdev_dbg(dispc->dev, \"%s: hw_videoport %d\\n\", __func__, hw_videoport);\n\n\tif (WARN_ON(dispc->feat->vp_feat.color.gamma_type != TIDSS_GAMMA_10BIT))\n\t\treturn;\n\n\tfor (i = 0; i < hwlen; ++i) {\n\t\tu32 v = table[i];\n\n\t\tif (i == 0)\n\t\t\tv |= 1 << 31;\n\n\t\tdispc_vp_write(dispc, hw_videoport, DISPC_VP_GAMMA_TABLE, v);\n\t}\n}\n\nstatic void dispc_vp_write_gamma_table(struct dispc_device *dispc,\n\t\t\t\t       u32 hw_videoport)\n{\n\tswitch (dispc->feat->subrev) {\n\tcase DISPC_K2G:\n\t\tdispc_k2g_vp_write_gamma_table(dispc, hw_videoport);\n\t\tbreak;\n\tcase DISPC_AM625:\n\tcase DISPC_AM65X:\n\t\tdispc_am65x_vp_write_gamma_table(dispc, hw_videoport);\n\t\tbreak;\n\tcase DISPC_J721E:\n\t\tdispc_j721e_vp_write_gamma_table(dispc, hw_videoport);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nstatic const struct drm_color_lut dispc_vp_gamma_default_lut[] = {\n\t{ .red = 0, .green = 0, .blue = 0, },\n\t{ .red = U16_MAX, .green = U16_MAX, .blue = U16_MAX, },\n};\n\nstatic void dispc_vp_set_gamma(struct dispc_device *dispc,\n\t\t\t       u32 hw_videoport,\n\t\t\t       const struct drm_color_lut *lut,\n\t\t\t       unsigned int length)\n{\n\tu32 *table = dispc->vp_data[hw_videoport].gamma_table;\n\tu32 hwlen = dispc->feat->vp_feat.color.gamma_size;\n\tu32 hwbits;\n\tunsigned int i;\n\n\tdev_dbg(dispc->dev, \"%s: hw_videoport %d, lut len %u, hw len %u\\n\",\n\t\t__func__, hw_videoport, length, hwlen);\n\n\tif (dispc->feat->vp_feat.color.gamma_type == TIDSS_GAMMA_10BIT)\n\t\thwbits = 10;\n\telse\n\t\thwbits = 8;\n\n\tif (!lut || length < 2) {\n\t\tlut = dispc_vp_gamma_default_lut;\n\t\tlength = ARRAY_SIZE(dispc_vp_gamma_default_lut);\n\t}\n\n\tfor (i = 0; i < length - 1; ++i) {\n\t\tunsigned int first = i * (hwlen - 1) / (length - 1);\n\t\tunsigned int last = (i + 1) * (hwlen - 1) / (length - 1);\n\t\tunsigned int w = last - first;\n\t\tu16 r, g, b;\n\t\tunsigned int j;\n\n\t\tif (w == 0)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j <= w; j++) {\n\t\t\tr = (lut[i].red * (w - j) + lut[i + 1].red * j) / w;\n\t\t\tg = (lut[i].green * (w - j) + lut[i + 1].green * j) / w;\n\t\t\tb = (lut[i].blue * (w - j) + lut[i + 1].blue * j) / w;\n\n\t\t\tr >>= 16 - hwbits;\n\t\t\tg >>= 16 - hwbits;\n\t\t\tb >>= 16 - hwbits;\n\n\t\t\ttable[first + j] = (r << (hwbits * 2)) |\n\t\t\t\t(g << hwbits) | b;\n\t\t}\n\t}\n\n\tdispc_vp_write_gamma_table(dispc, hw_videoport);\n}\n\nstatic s16 dispc_S31_32_to_s2_8(s64 coef)\n{\n\tu64 sign_bit = 1ULL << 63;\n\tu64 cbits = (u64)coef;\n\ts16 ret;\n\n\tif (cbits & sign_bit)\n\t\tret = -clamp_val(((cbits & ~sign_bit) >> 24), 0, 0x200);\n\telse\n\t\tret = clamp_val(((cbits & ~sign_bit) >> 24), 0, 0x1FF);\n\n\treturn ret;\n}\n\nstatic void dispc_k2g_cpr_from_ctm(const struct drm_color_ctm *ctm,\n\t\t\t\t   struct dispc_csc_coef *cpr)\n{\n\tmemset(cpr, 0, sizeof(*cpr));\n\n\tcpr->to_regval = dispc_csc_cpr_regval;\n\tcpr->m[CSC_RR] = dispc_S31_32_to_s2_8(ctm->matrix[0]);\n\tcpr->m[CSC_RG] = dispc_S31_32_to_s2_8(ctm->matrix[1]);\n\tcpr->m[CSC_RB] = dispc_S31_32_to_s2_8(ctm->matrix[2]);\n\tcpr->m[CSC_GR] = dispc_S31_32_to_s2_8(ctm->matrix[3]);\n\tcpr->m[CSC_GG] = dispc_S31_32_to_s2_8(ctm->matrix[4]);\n\tcpr->m[CSC_GB] = dispc_S31_32_to_s2_8(ctm->matrix[5]);\n\tcpr->m[CSC_BR] = dispc_S31_32_to_s2_8(ctm->matrix[6]);\n\tcpr->m[CSC_BG] = dispc_S31_32_to_s2_8(ctm->matrix[7]);\n\tcpr->m[CSC_BB] = dispc_S31_32_to_s2_8(ctm->matrix[8]);\n}\n\n#define CVAL(xR, xG, xB) (FLD_VAL(xR, 9, 0) | FLD_VAL(xG, 20, 11) |\t\\\n\t\t\t  FLD_VAL(xB, 31, 22))\n\nstatic void dispc_k2g_vp_csc_cpr_regval(const struct dispc_csc_coef *csc,\n\t\t\t\t\tu32 *regval)\n{\n\tregval[0] = CVAL(csc->m[CSC_BB], csc->m[CSC_BG], csc->m[CSC_BR]);\n\tregval[1] = CVAL(csc->m[CSC_GB], csc->m[CSC_GG], csc->m[CSC_GR]);\n\tregval[2] = CVAL(csc->m[CSC_RB], csc->m[CSC_RG], csc->m[CSC_RR]);\n}\n\n#undef CVAL\n\nstatic void dispc_k2g_vp_write_csc(struct dispc_device *dispc, u32 hw_videoport,\n\t\t\t\t   const struct dispc_csc_coef *csc)\n{\n\tstatic const u16 dispc_vp_cpr_coef_reg[] = {\n\t\tDISPC_VP_CSC_COEF0, DISPC_VP_CSC_COEF1, DISPC_VP_CSC_COEF2,\n\t\t \n\t};\n\tu32 regval[DISPC_CSC_REGVAL_LEN];\n\tunsigned int i;\n\n\tdispc_k2g_vp_csc_cpr_regval(csc, regval);\n\n\tfor (i = 0; i < ARRAY_SIZE(dispc_vp_cpr_coef_reg); i++)\n\t\tdispc_vp_write(dispc, hw_videoport, dispc_vp_cpr_coef_reg[i],\n\t\t\t       regval[i]);\n}\n\nstatic void dispc_k2g_vp_set_ctm(struct dispc_device *dispc, u32 hw_videoport,\n\t\t\t\t struct drm_color_ctm *ctm)\n{\n\tu32 cprenable = 0;\n\n\tif (ctm) {\n\t\tstruct dispc_csc_coef cpr;\n\n\t\tdispc_k2g_cpr_from_ctm(ctm, &cpr);\n\t\tdispc_k2g_vp_write_csc(dispc, hw_videoport, &cpr);\n\t\tcprenable = 1;\n\t}\n\n\tVP_REG_FLD_MOD(dispc, hw_videoport, DISPC_VP_CONFIG,\n\t\t       cprenable, 15, 15);\n}\n\nstatic s16 dispc_S31_32_to_s3_8(s64 coef)\n{\n\tu64 sign_bit = 1ULL << 63;\n\tu64 cbits = (u64)coef;\n\ts16 ret;\n\n\tif (cbits & sign_bit)\n\t\tret = -clamp_val(((cbits & ~sign_bit) >> 24), 0, 0x400);\n\telse\n\t\tret = clamp_val(((cbits & ~sign_bit) >> 24), 0, 0x3FF);\n\n\treturn ret;\n}\n\nstatic void dispc_csc_from_ctm(const struct drm_color_ctm *ctm,\n\t\t\t       struct dispc_csc_coef *cpr)\n{\n\tmemset(cpr, 0, sizeof(*cpr));\n\n\tcpr->to_regval = dispc_csc_cpr_regval;\n\tcpr->m[CSC_RR] = dispc_S31_32_to_s3_8(ctm->matrix[0]);\n\tcpr->m[CSC_RG] = dispc_S31_32_to_s3_8(ctm->matrix[1]);\n\tcpr->m[CSC_RB] = dispc_S31_32_to_s3_8(ctm->matrix[2]);\n\tcpr->m[CSC_GR] = dispc_S31_32_to_s3_8(ctm->matrix[3]);\n\tcpr->m[CSC_GG] = dispc_S31_32_to_s3_8(ctm->matrix[4]);\n\tcpr->m[CSC_GB] = dispc_S31_32_to_s3_8(ctm->matrix[5]);\n\tcpr->m[CSC_BR] = dispc_S31_32_to_s3_8(ctm->matrix[6]);\n\tcpr->m[CSC_BG] = dispc_S31_32_to_s3_8(ctm->matrix[7]);\n\tcpr->m[CSC_BB] = dispc_S31_32_to_s3_8(ctm->matrix[8]);\n}\n\nstatic void dispc_k3_vp_write_csc(struct dispc_device *dispc, u32 hw_videoport,\n\t\t\t\t  const struct dispc_csc_coef *csc)\n{\n\tstatic const u16 dispc_vp_csc_coef_reg[DISPC_CSC_REGVAL_LEN] = {\n\t\tDISPC_VP_CSC_COEF0, DISPC_VP_CSC_COEF1, DISPC_VP_CSC_COEF2,\n\t\tDISPC_VP_CSC_COEF3, DISPC_VP_CSC_COEF4, DISPC_VP_CSC_COEF5,\n\t\tDISPC_VP_CSC_COEF6, DISPC_VP_CSC_COEF7,\n\t};\n\tu32 regval[DISPC_CSC_REGVAL_LEN];\n\tunsigned int i;\n\n\tcsc->to_regval(csc, regval);\n\n\tfor (i = 0; i < ARRAY_SIZE(regval); i++)\n\t\tdispc_vp_write(dispc, hw_videoport, dispc_vp_csc_coef_reg[i],\n\t\t\t       regval[i]);\n}\n\nstatic void dispc_k3_vp_set_ctm(struct dispc_device *dispc, u32 hw_videoport,\n\t\t\t\tstruct drm_color_ctm *ctm)\n{\n\tu32 colorconvenable = 0;\n\n\tif (ctm) {\n\t\tstruct dispc_csc_coef csc;\n\n\t\tdispc_csc_from_ctm(ctm, &csc);\n\t\tdispc_k3_vp_write_csc(dispc, hw_videoport, &csc);\n\t\tcolorconvenable = 1;\n\t}\n\n\tVP_REG_FLD_MOD(dispc, hw_videoport, DISPC_VP_CONFIG,\n\t\t       colorconvenable, 24, 24);\n}\n\nstatic void dispc_vp_set_color_mgmt(struct dispc_device *dispc,\n\t\t\t\t    u32 hw_videoport,\n\t\t\t\t    const struct drm_crtc_state *state,\n\t\t\t\t    bool newmodeset)\n{\n\tstruct drm_color_lut *lut = NULL;\n\tstruct drm_color_ctm *ctm = NULL;\n\tunsigned int length = 0;\n\n\tif (!(state->color_mgmt_changed || newmodeset))\n\t\treturn;\n\n\tif (state->gamma_lut) {\n\t\tlut = (struct drm_color_lut *)state->gamma_lut->data;\n\t\tlength = state->gamma_lut->length / sizeof(*lut);\n\t}\n\n\tdispc_vp_set_gamma(dispc, hw_videoport, lut, length);\n\n\tif (state->ctm)\n\t\tctm = (struct drm_color_ctm *)state->ctm->data;\n\n\tif (dispc->feat->subrev == DISPC_K2G)\n\t\tdispc_k2g_vp_set_ctm(dispc, hw_videoport, ctm);\n\telse\n\t\tdispc_k3_vp_set_ctm(dispc, hw_videoport, ctm);\n}\n\nvoid dispc_vp_setup(struct dispc_device *dispc, u32 hw_videoport,\n\t\t    const struct drm_crtc_state *state, bool newmodeset)\n{\n\tdispc_vp_set_default_color(dispc, hw_videoport, 0);\n\tdispc_vp_set_color_mgmt(dispc, hw_videoport, state, newmodeset);\n}\n\nint dispc_runtime_suspend(struct dispc_device *dispc)\n{\n\tdev_dbg(dispc->dev, \"suspend\\n\");\n\n\tdispc->is_enabled = false;\n\n\tclk_disable_unprepare(dispc->fclk);\n\n\treturn 0;\n}\n\nint dispc_runtime_resume(struct dispc_device *dispc)\n{\n\tdev_dbg(dispc->dev, \"resume\\n\");\n\n\tclk_prepare_enable(dispc->fclk);\n\n\tif (REG_GET(dispc, DSS_SYSSTATUS, 0, 0) == 0)\n\t\tdev_warn(dispc->dev, \"DSS FUNC RESET not done!\\n\");\n\n\tdev_dbg(dispc->dev, \"OMAP DSS7 rev 0x%x\\n\",\n\t\tdispc_read(dispc, DSS_REVISION));\n\n\tdev_dbg(dispc->dev, \"VP RESETDONE %d,%d,%d\\n\",\n\t\tREG_GET(dispc, DSS_SYSSTATUS, 1, 1),\n\t\tREG_GET(dispc, DSS_SYSSTATUS, 2, 2),\n\t\tREG_GET(dispc, DSS_SYSSTATUS, 3, 3));\n\n\tif (dispc->feat->subrev == DISPC_AM625 ||\n\t    dispc->feat->subrev == DISPC_AM65X)\n\t\tdev_dbg(dispc->dev, \"OLDI RESETDONE %d,%d,%d\\n\",\n\t\t\tREG_GET(dispc, DSS_SYSSTATUS, 5, 5),\n\t\t\tREG_GET(dispc, DSS_SYSSTATUS, 6, 6),\n\t\t\tREG_GET(dispc, DSS_SYSSTATUS, 7, 7));\n\n\tdev_dbg(dispc->dev, \"DISPC IDLE %d\\n\",\n\t\tREG_GET(dispc, DSS_SYSSTATUS, 9, 9));\n\n\tdispc_initial_config(dispc);\n\n\tdispc->is_enabled = true;\n\n\ttidss_irq_resume(dispc->tidss);\n\n\treturn 0;\n}\n\nvoid dispc_remove(struct tidss_device *tidss)\n{\n\tdev_dbg(tidss->dev, \"%s\\n\", __func__);\n\n\ttidss->dispc = NULL;\n}\n\nstatic int dispc_iomap_resource(struct platform_device *pdev, const char *name,\n\t\t\t\tvoid __iomem **base)\n{\n\tvoid __iomem *b;\n\n\tb = devm_platform_ioremap_resource_byname(pdev, name);\n\tif (IS_ERR(b)) {\n\t\tdev_err(&pdev->dev, \"cannot ioremap resource '%s'\\n\", name);\n\t\treturn PTR_ERR(b);\n\t}\n\n\t*base = b;\n\n\treturn 0;\n}\n\nstatic int dispc_init_am65x_oldi_io_ctrl(struct device *dev,\n\t\t\t\t\t struct dispc_device *dispc)\n{\n\tdispc->oldi_io_ctrl =\n\t\tsyscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\"ti,am65x-oldi-io-ctrl\");\n\tif (PTR_ERR(dispc->oldi_io_ctrl) == -ENODEV) {\n\t\tdispc->oldi_io_ctrl = NULL;\n\t} else if (IS_ERR(dispc->oldi_io_ctrl)) {\n\t\tdev_err(dev, \"%s: syscon_regmap_lookup_by_phandle failed %ld\\n\",\n\t\t\t__func__, PTR_ERR(dispc->oldi_io_ctrl));\n\t\treturn PTR_ERR(dispc->oldi_io_ctrl);\n\t}\n\treturn 0;\n}\n\nstatic void dispc_init_errata(struct dispc_device *dispc)\n{\n\tstatic const struct soc_device_attribute am65x_sr10_soc_devices[] = {\n\t\t{ .family = \"AM65X\", .revision = \"SR1.0\" },\n\t\t{   }\n\t};\n\n\tif (soc_device_match(am65x_sr10_soc_devices)) {\n\t\tdispc->errata.i2000 = true;\n\t\tdev_info(dispc->dev, \"WA for erratum i2000: YUV formats disabled\\n\");\n\t}\n}\n\nstatic int dispc_softreset(struct dispc_device *dispc)\n{\n\tu32 val;\n\tint ret = 0;\n\n\t \n\tif (dispc->feat->subrev == DISPC_K2G)\n\t\treturn 0;\n\n\t \n\tREG_FLD_MOD(dispc, DSS_SYSCONFIG, 1, 1, 1);\n\t \n\tret = readl_poll_timeout(dispc->base_common + DSS_SYSSTATUS,\n\t\t\t\t val, val & 1, 100, 5000);\n\tif (ret) {\n\t\tdev_err(dispc->dev, \"failed to reset dispc\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dispc_init_hw(struct dispc_device *dispc)\n{\n\tstruct device *dev = dispc->dev;\n\tint ret;\n\n\tret = pm_runtime_set_active(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set DSS PM to active\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(dispc->fclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable DSS fclk\\n\");\n\t\tgoto err_runtime_suspend;\n\t}\n\n\tret = dispc_softreset(dispc);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\tclk_disable_unprepare(dispc->fclk);\n\tret = pm_runtime_set_suspended(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set DSS PM to suspended\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(dispc->fclk);\n\nerr_runtime_suspend:\n\tret = pm_runtime_set_suspended(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set DSS PM to suspended\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint dispc_init(struct tidss_device *tidss)\n{\n\tstruct device *dev = tidss->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct dispc_device *dispc;\n\tconst struct dispc_features *feat;\n\tunsigned int i, num_fourccs;\n\tint r = 0;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tfeat = tidss->feat;\n\n\tif (feat->subrev != DISPC_K2G) {\n\t\tr = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(48));\n\t\tif (r)\n\t\t\tdev_warn(dev, \"cannot set DMA masks to 48-bit\\n\");\n\t}\n\n\tdma_set_max_seg_size(dev, UINT_MAX);\n\n\tdispc = devm_kzalloc(dev, sizeof(*dispc), GFP_KERNEL);\n\tif (!dispc)\n\t\treturn -ENOMEM;\n\n\tdispc->tidss = tidss;\n\tdispc->dev = dev;\n\tdispc->feat = feat;\n\n\tdispc_init_errata(dispc);\n\n\tdispc->fourccs = devm_kcalloc(dev, ARRAY_SIZE(dispc_color_formats),\n\t\t\t\t      sizeof(*dispc->fourccs), GFP_KERNEL);\n\tif (!dispc->fourccs)\n\t\treturn -ENOMEM;\n\n\tnum_fourccs = 0;\n\tfor (i = 0; i < ARRAY_SIZE(dispc_color_formats); ++i) {\n\t\tif (dispc->errata.i2000 &&\n\t\t    dispc_fourcc_is_yuv(dispc_color_formats[i].fourcc)) {\n\t\t\tcontinue;\n\t\t}\n\t\tdispc->fourccs[num_fourccs++] = dispc_color_formats[i].fourcc;\n\t}\n\n\tdispc->num_fourccs = num_fourccs;\n\n\tdispc_common_regmap = dispc->feat->common_regs;\n\n\tr = dispc_iomap_resource(pdev, dispc->feat->common,\n\t\t\t\t &dispc->base_common);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < dispc->feat->num_planes; i++) {\n\t\tr = dispc_iomap_resource(pdev, dispc->feat->vid_name[i],\n\t\t\t\t\t &dispc->base_vid[i]);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tfor (i = 0; i < dispc->feat->num_vps; i++) {\n\t\tu32 gamma_size = dispc->feat->vp_feat.color.gamma_size;\n\t\tu32 *gamma_table;\n\t\tstruct clk *clk;\n\n\t\tr = dispc_iomap_resource(pdev, dispc->feat->ovr_name[i],\n\t\t\t\t\t &dispc->base_ovr[i]);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = dispc_iomap_resource(pdev, dispc->feat->vp_name[i],\n\t\t\t\t\t &dispc->base_vp[i]);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tclk = devm_clk_get(dev, dispc->feat->vpclk_name[i]);\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_err(dev, \"%s: Failed to get clk %s:%ld\\n\", __func__,\n\t\t\t\tdispc->feat->vpclk_name[i], PTR_ERR(clk));\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\t\tdispc->vp_clk[i] = clk;\n\n\t\tgamma_table = devm_kmalloc_array(dev, gamma_size,\n\t\t\t\t\t\t sizeof(*gamma_table),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!gamma_table)\n\t\t\treturn -ENOMEM;\n\t\tdispc->vp_data[i].gamma_table = gamma_table;\n\t}\n\n\tif (feat->subrev == DISPC_AM65X) {\n\t\tr = dispc_init_am65x_oldi_io_ctrl(dev, dispc);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tdispc->fclk = devm_clk_get(dev, \"fck\");\n\tif (IS_ERR(dispc->fclk)) {\n\t\tdev_err(dev, \"%s: Failed to get fclk: %ld\\n\",\n\t\t\t__func__, PTR_ERR(dispc->fclk));\n\t\treturn PTR_ERR(dispc->fclk);\n\t}\n\tdev_dbg(dev, \"DSS fclk %lu Hz\\n\", clk_get_rate(dispc->fclk));\n\n\tof_property_read_u32(dispc->dev->of_node, \"max-memory-bandwidth\",\n\t\t\t     &dispc->memory_bandwidth_limit);\n\n\tr = dispc_init_hw(dispc);\n\tif (r)\n\t\treturn r;\n\n\ttidss->dispc = dispc;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}