{
  "module_name": "tidss_kms.c",
  "hash_id": "835f8ce76ce0c1700682ab7c7b7115f0575389ea9b31c5cb603bdd6f82cbf4a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tidss/tidss_kms.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_vblank.h>\n\n#include \"tidss_crtc.h\"\n#include \"tidss_dispc.h\"\n#include \"tidss_drv.h\"\n#include \"tidss_encoder.h\"\n#include \"tidss_kms.h\"\n#include \"tidss_plane.h\"\n\nstatic void tidss_atomic_commit_tail(struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *ddev = old_state->dev;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\n\tdev_dbg(ddev->dev, \"%s\\n\", __func__);\n\n\ttidss_runtime_get(tidss);\n\n\tdrm_atomic_helper_commit_modeset_disables(ddev, old_state);\n\tdrm_atomic_helper_commit_planes(ddev, old_state, 0);\n\tdrm_atomic_helper_commit_modeset_enables(ddev, old_state);\n\n\tdrm_atomic_helper_commit_hw_done(old_state);\n\tdrm_atomic_helper_wait_for_flip_done(ddev, old_state);\n\n\tdrm_atomic_helper_cleanup_planes(ddev, old_state);\n\n\ttidss_runtime_put(tidss);\n}\n\nstatic const struct drm_mode_config_helper_funcs mode_config_helper_funcs = {\n\t.atomic_commit_tail = tidss_atomic_commit_tail,\n};\n\nstatic int tidss_atomic_check(struct drm_device *ddev,\n\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *opstate;\n\tstruct drm_plane_state *npstate;\n\tstruct drm_plane *plane;\n\tstruct drm_crtc_state *cstate;\n\tstruct drm_crtc *crtc;\n\tint ret, i;\n\n\tret = drm_atomic_helper_check(ddev, state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor_each_oldnew_plane_in_state(state, plane, opstate, npstate, i) {\n\t\tif (!npstate->crtc || !npstate->visible)\n\t\t\tcontinue;\n\n\t\tif (!opstate->crtc || opstate->crtc_x != npstate->crtc_x ||\n\t\t    opstate->crtc_y != npstate->crtc_y) {\n\t\t\tcstate = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t\t\t   npstate->crtc);\n\t\t\tif (IS_ERR(cstate))\n\t\t\t\treturn PTR_ERR(cstate);\n\t\t\tto_tidss_crtc_state(cstate)->plane_pos_changed = true;\n\t\t}\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, cstate, i) {\n\t\tif (to_tidss_crtc_state(cstate)->plane_pos_changed ||\n\t\t    cstate->zpos_changed) {\n\t\t\tret = drm_atomic_add_affected_planes(state, crtc);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_mode_config_funcs mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = tidss_atomic_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int tidss_dispc_modeset_init(struct tidss_device *tidss)\n{\n\tstruct device *dev = tidss->dev;\n\tunsigned int fourccs_len;\n\tconst u32 *fourccs = dispc_plane_formats(tidss->dispc, &fourccs_len);\n\tunsigned int i;\n\n\tstruct pipe {\n\t\tu32 hw_videoport;\n\t\tstruct drm_bridge *bridge;\n\t\tu32 enc_type;\n\t};\n\n\tconst struct dispc_features *feat = tidss->feat;\n\tu32 max_vps = feat->num_vps;\n\tu32 max_planes = feat->num_planes;\n\n\tstruct pipe pipes[TIDSS_MAX_PORTS];\n\tu32 num_pipes = 0;\n\tu32 crtc_mask;\n\n\t \n\n\tfor (i = 0; i < max_vps; i++) {\n\t\tstruct drm_panel *panel;\n\t\tstruct drm_bridge *bridge;\n\t\tu32 enc_type = DRM_MODE_ENCODER_NONE;\n\t\tint ret;\n\n\t\tret = drm_of_find_panel_or_bridge(dev->of_node, i, 0,\n\t\t\t\t\t\t  &panel, &bridge);\n\t\tif (ret == -ENODEV) {\n\t\t\tdev_dbg(dev, \"no panel/bridge for port %d\\n\", i);\n\t\t\tcontinue;\n\t\t} else if (ret) {\n\t\t\tdev_dbg(dev, \"port %d probe returned %d\\n\", i, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (panel) {\n\t\t\tu32 conn_type;\n\n\t\t\tdev_dbg(dev, \"Setting up panel for port %d\\n\", i);\n\n\t\t\tswitch (feat->vp_bus_type[i]) {\n\t\t\tcase DISPC_VP_OLDI:\n\t\t\t\tenc_type = DRM_MODE_ENCODER_LVDS;\n\t\t\t\tconn_type = DRM_MODE_CONNECTOR_LVDS;\n\t\t\t\tbreak;\n\t\t\tcase DISPC_VP_DPI:\n\t\t\t\tenc_type = DRM_MODE_ENCODER_DPI;\n\t\t\t\tconn_type = DRM_MODE_CONNECTOR_DPI;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON(1);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (panel->connector_type != conn_type) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"%s: Panel %s has incompatible connector type for vp%d (%d != %d)\\n\",\n\t\t\t\t\t __func__, dev_name(panel->dev), i,\n\t\t\t\t\t panel->connector_type, conn_type);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tbridge = devm_drm_panel_bridge_add(dev, panel);\n\t\t\tif (IS_ERR(bridge)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"failed to set up panel bridge for port %d\\n\",\n\t\t\t\t\ti);\n\t\t\t\treturn PTR_ERR(bridge);\n\t\t\t}\n\t\t}\n\n\t\tpipes[num_pipes].hw_videoport = i;\n\t\tpipes[num_pipes].bridge = bridge;\n\t\tpipes[num_pipes].enc_type = enc_type;\n\t\tnum_pipes++;\n\t}\n\n\t \n\tcrtc_mask = (1 << num_pipes) - 1;\n\n\t \n\n\tfor (i = 0; i < num_pipes; ++i) {\n\t\tstruct tidss_plane *tplane;\n\t\tstruct tidss_crtc *tcrtc;\n\t\tu32 hw_plane_id = feat->vid_order[tidss->num_planes];\n\t\tint ret;\n\n\t\ttplane = tidss_plane_create(tidss, hw_plane_id,\n\t\t\t\t\t    DRM_PLANE_TYPE_PRIMARY, crtc_mask,\n\t\t\t\t\t    fourccs, fourccs_len);\n\t\tif (IS_ERR(tplane)) {\n\t\t\tdev_err(tidss->dev, \"plane create failed\\n\");\n\t\t\treturn PTR_ERR(tplane);\n\t\t}\n\n\t\ttidss->planes[tidss->num_planes++] = &tplane->plane;\n\n\t\ttcrtc = tidss_crtc_create(tidss, pipes[i].hw_videoport,\n\t\t\t\t\t  &tplane->plane);\n\t\tif (IS_ERR(tcrtc)) {\n\t\t\tdev_err(tidss->dev, \"crtc create failed\\n\");\n\t\t\treturn PTR_ERR(tcrtc);\n\t\t}\n\n\t\ttidss->crtcs[tidss->num_crtcs++] = &tcrtc->crtc;\n\n\t\tret = tidss_encoder_create(tidss, pipes[i].bridge,\n\t\t\t\t\t   pipes[i].enc_type,\n\t\t\t\t\t   1 << tcrtc->crtc.index);\n\t\tif (ret) {\n\t\t\tdev_err(tidss->dev, \"encoder create failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\n\twhile (tidss->num_planes < max_planes) {\n\t\tstruct tidss_plane *tplane;\n\t\tu32 hw_plane_id = feat->vid_order[tidss->num_planes];\n\n\t\ttplane = tidss_plane_create(tidss, hw_plane_id,\n\t\t\t\t\t    DRM_PLANE_TYPE_OVERLAY, crtc_mask,\n\t\t\t\t\t    fourccs, fourccs_len);\n\n\t\tif (IS_ERR(tplane)) {\n\t\t\tdev_err(tidss->dev, \"plane create failed\\n\");\n\t\t\treturn PTR_ERR(tplane);\n\t\t}\n\n\t\ttidss->planes[tidss->num_planes++] = &tplane->plane;\n\t}\n\n\treturn 0;\n}\n\nint tidss_modeset_init(struct tidss_device *tidss)\n{\n\tstruct drm_device *ddev = &tidss->ddev;\n\tint ret;\n\n\tdev_dbg(tidss->dev, \"%s\\n\", __func__);\n\n\tret = drmm_mode_config_init(ddev);\n\tif (ret)\n\t\treturn ret;\n\n\tddev->mode_config.min_width = 8;\n\tddev->mode_config.min_height = 8;\n\tddev->mode_config.max_width = 8096;\n\tddev->mode_config.max_height = 8096;\n\tddev->mode_config.normalize_zpos = true;\n\tddev->mode_config.funcs = &mode_config_funcs;\n\tddev->mode_config.helper_private = &mode_config_helper_funcs;\n\n\tret = tidss_dispc_modeset_init(tidss);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_vblank_init(ddev, tidss->num_crtcs);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_mode_config_reset(ddev);\n\n\tdev_dbg(tidss->dev, \"%s done\\n\", __func__);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}