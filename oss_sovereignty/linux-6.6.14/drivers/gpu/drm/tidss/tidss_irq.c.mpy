{
  "module_name": "tidss_irq.c",
  "hash_id": "49d18e923baa198ab37d926e0aebad2e60e84c220c7625c22949f346618ad43a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tidss/tidss_irq.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_print.h>\n\n#include \"tidss_crtc.h\"\n#include \"tidss_dispc.h\"\n#include \"tidss_drv.h\"\n#include \"tidss_irq.h\"\n#include \"tidss_plane.h\"\n\n \nstatic void tidss_irq_update(struct tidss_device *tidss)\n{\n\tassert_spin_locked(&tidss->wait_lock);\n\n\tdispc_set_irqenable(tidss->dispc, tidss->irq_mask);\n}\n\nvoid tidss_irq_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\tu32 hw_videoport = tcrtc->hw_videoport;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tidss->wait_lock, flags);\n\ttidss->irq_mask |= DSS_IRQ_VP_VSYNC_EVEN(hw_videoport) |\n\t\t\t   DSS_IRQ_VP_VSYNC_ODD(hw_videoport);\n\ttidss_irq_update(tidss);\n\tspin_unlock_irqrestore(&tidss->wait_lock, flags);\n}\n\nvoid tidss_irq_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\tu32 hw_videoport = tcrtc->hw_videoport;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tidss->wait_lock, flags);\n\ttidss->irq_mask &= ~(DSS_IRQ_VP_VSYNC_EVEN(hw_videoport) |\n\t\t\t     DSS_IRQ_VP_VSYNC_ODD(hw_videoport));\n\ttidss_irq_update(tidss);\n\tspin_unlock_irqrestore(&tidss->wait_lock, flags);\n}\n\nstatic irqreturn_t tidss_irq_handler(int irq, void *arg)\n{\n\tstruct drm_device *ddev = (struct drm_device *)arg;\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\tunsigned int id;\n\tdispc_irq_t irqstatus;\n\n\tirqstatus = dispc_read_and_clear_irqstatus(tidss->dispc);\n\n\tfor (id = 0; id < tidss->num_crtcs; id++) {\n\t\tstruct drm_crtc *crtc = tidss->crtcs[id];\n\t\tstruct tidss_crtc *tcrtc = to_tidss_crtc(crtc);\n\t\tu32 hw_videoport = tcrtc->hw_videoport;\n\n\t\tif (irqstatus & (DSS_IRQ_VP_VSYNC_EVEN(hw_videoport) |\n\t\t\t\t DSS_IRQ_VP_VSYNC_ODD(hw_videoport)))\n\t\t\ttidss_crtc_vblank_irq(crtc);\n\n\t\tif (irqstatus & (DSS_IRQ_VP_FRAME_DONE(hw_videoport)))\n\t\t\ttidss_crtc_framedone_irq(crtc);\n\n\t\tif (irqstatus & DSS_IRQ_VP_SYNC_LOST(hw_videoport))\n\t\t\ttidss_crtc_error_irq(crtc, irqstatus);\n\t}\n\n\tif (irqstatus & DSS_IRQ_DEVICE_OCP_ERR)\n\t\tdev_err_ratelimited(tidss->dev, \"OCP error\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nvoid tidss_irq_resume(struct tidss_device *tidss)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tidss->wait_lock, flags);\n\ttidss_irq_update(tidss);\n\tspin_unlock_irqrestore(&tidss->wait_lock, flags);\n}\n\nstatic void tidss_irq_preinstall(struct drm_device *ddev)\n{\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\n\tspin_lock_init(&tidss->wait_lock);\n\n\ttidss_runtime_get(tidss);\n\n\tdispc_set_irqenable(tidss->dispc, 0);\n\tdispc_read_and_clear_irqstatus(tidss->dispc);\n\n\ttidss_runtime_put(tidss);\n}\n\nstatic void tidss_irq_postinstall(struct drm_device *ddev)\n{\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\tunsigned long flags;\n\tunsigned int i;\n\n\ttidss_runtime_get(tidss);\n\n\tspin_lock_irqsave(&tidss->wait_lock, flags);\n\n\ttidss->irq_mask = DSS_IRQ_DEVICE_OCP_ERR;\n\n\tfor (i = 0; i < tidss->num_crtcs; ++i) {\n\t\tstruct tidss_crtc *tcrtc = to_tidss_crtc(tidss->crtcs[i]);\n\n\t\ttidss->irq_mask |= DSS_IRQ_VP_SYNC_LOST(tcrtc->hw_videoport);\n\n\t\ttidss->irq_mask |= DSS_IRQ_VP_FRAME_DONE(tcrtc->hw_videoport);\n\t}\n\n\ttidss_irq_update(tidss);\n\n\tspin_unlock_irqrestore(&tidss->wait_lock, flags);\n\n\ttidss_runtime_put(tidss);\n}\n\nint tidss_irq_install(struct drm_device *ddev, unsigned int irq)\n{\n\tint ret;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\ttidss_irq_preinstall(ddev);\n\n\tret = request_irq(irq, tidss_irq_handler, 0, ddev->driver->name, ddev);\n\tif (ret)\n\t\treturn ret;\n\n\ttidss_irq_postinstall(ddev);\n\n\treturn 0;\n}\n\nvoid tidss_irq_uninstall(struct drm_device *ddev)\n{\n\tstruct tidss_device *tidss = to_tidss(ddev);\n\n\ttidss_runtime_get(tidss);\n\tdispc_set_irqenable(tidss->dispc, 0);\n\ttidss_runtime_put(tidss);\n\n\tfree_irq(tidss->irq, ddev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}