{
  "module_name": "tidss_encoder.c",
  "hash_id": "616608cc617b100e4f9b0c3a7a5d72fe192b7053ca41324bffe08135d86aa549",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tidss/tidss_encoder.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_of.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"tidss_crtc.h\"\n#include \"tidss_drv.h\"\n#include \"tidss_encoder.h\"\n\nstruct tidss_encoder {\n\tstruct drm_bridge bridge;\n\tstruct drm_encoder encoder;\n\tstruct drm_connector *connector;\n\tstruct drm_bridge *next_bridge;\n\tstruct tidss_device *tidss;\n};\n\nstatic inline struct tidss_encoder\n*bridge_to_tidss_encoder(struct drm_bridge *b)\n{\n\treturn container_of(b, struct tidss_encoder, bridge);\n}\n\nstatic int tidss_bridge_attach(struct drm_bridge *bridge,\n\t\t\t       enum drm_bridge_attach_flags flags)\n{\n\tstruct tidss_encoder *t_enc = bridge_to_tidss_encoder(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, t_enc->next_bridge,\n\t\t\t\t bridge, flags);\n}\n\nstatic int tidss_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct tidss_encoder *t_enc = bridge_to_tidss_encoder(bridge);\n\tstruct tidss_device *tidss = t_enc->tidss;\n\tstruct tidss_crtc_state *tcrtc_state = to_tidss_crtc_state(crtc_state);\n\tstruct drm_display_info *di = &conn_state->connector->display_info;\n\tstruct drm_bridge_state *next_bridge_state = NULL;\n\n\tif (t_enc->next_bridge)\n\t\tnext_bridge_state = drm_atomic_get_new_bridge_state(crtc_state->state,\n\t\t\t\t\t\t\t\t    t_enc->next_bridge);\n\n\tif (next_bridge_state) {\n\t\ttcrtc_state->bus_flags = next_bridge_state->input_bus_cfg.flags;\n\t\ttcrtc_state->bus_format = next_bridge_state->input_bus_cfg.format;\n\t} else if (di->num_bus_formats) {\n\t\ttcrtc_state->bus_format = di->bus_formats[0];\n\t\ttcrtc_state->bus_flags = di->bus_flags;\n\t} else {\n\t\tdev_err(tidss->dev, \"%s: No bus_formats in connected display\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_bridge_funcs tidss_bridge_funcs = {\n\t.attach\t\t\t\t= tidss_bridge_attach,\n\t.atomic_check\t\t\t= tidss_bridge_atomic_check,\n\t.atomic_reset\t\t\t= drm_atomic_helper_bridge_reset,\n\t.atomic_duplicate_state\t\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t\t= drm_atomic_helper_bridge_destroy_state,\n};\n\nint tidss_encoder_create(struct tidss_device *tidss,\n\t\t\t struct drm_bridge *next_bridge,\n\t\t\t u32 encoder_type, u32 possible_crtcs)\n{\n\tstruct tidss_encoder *t_enc;\n\tstruct drm_encoder *enc;\n\tstruct drm_connector *connector;\n\tint ret;\n\n\tt_enc = drmm_simple_encoder_alloc(&tidss->ddev, struct tidss_encoder,\n\t\t\t\t\t  encoder, encoder_type);\n\tif (IS_ERR(t_enc))\n\t\treturn PTR_ERR(t_enc);\n\n\tt_enc->tidss = tidss;\n\tt_enc->next_bridge = next_bridge;\n\tt_enc->bridge.funcs = &tidss_bridge_funcs;\n\n\tenc = &t_enc->encoder;\n\tenc->possible_crtcs = possible_crtcs;\n\n\t \n\tret = drm_bridge_attach(enc, &t_enc->bridge, NULL,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret) {\n\t\tdev_err(tidss->dev, \"bridge attach failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tconnector = drm_bridge_connector_init(&tidss->ddev, enc);\n\tif (IS_ERR(connector)) {\n\t\tdev_err(tidss->dev, \"bridge_connector create failed\\n\");\n\t\treturn PTR_ERR(connector);\n\t}\n\n\tret = drm_connector_attach_encoder(connector, enc);\n\tif (ret) {\n\t\tdev_err(tidss->dev, \"attaching encoder to connector failed\\n\");\n\t\treturn ret;\n\t}\n\n\tt_enc->connector = connector;\n\n\tdev_dbg(tidss->dev, \"Encoder create done\\n\");\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}