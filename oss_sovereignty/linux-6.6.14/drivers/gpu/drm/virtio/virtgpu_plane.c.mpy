{
  "module_name": "virtgpu_plane.c",
  "hash_id": "81244748c7c99b63b617706d47ac953e673e46cae6fa9136eb6b8d82c78faa14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/virtio/virtgpu_plane.c",
  "human_readable_source": " \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_fourcc.h>\n\n#include \"virtgpu_drv.h\"\n\nstatic const uint32_t virtio_gpu_formats[] = {\n\tDRM_FORMAT_HOST_XRGB8888,\n};\n\nstatic const uint32_t virtio_gpu_cursor_formats[] = {\n\tDRM_FORMAT_HOST_ARGB8888,\n};\n\nuint32_t virtio_gpu_translate_format(uint32_t drm_fourcc)\n{\n\tuint32_t format;\n\n\tswitch (drm_fourcc) {\n\tcase DRM_FORMAT_XRGB8888:\n\t\tformat = VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\t\tformat = VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM;\n\t\tbreak;\n\tcase DRM_FORMAT_BGRX8888:\n\t\tformat = VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM;\n\t\tbreak;\n\tcase DRM_FORMAT_BGRA8888:\n\t\tformat = VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tformat = 0;\n\t\tbreak;\n\t}\n\tWARN_ON(format == 0);\n\treturn format;\n}\n\nstatic const struct drm_plane_funcs virtio_gpu_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n};\n\nstatic int virtio_gpu_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tbool is_cursor = plane->type == DRM_PLANE_TYPE_CURSOR;\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\n\tif (!new_plane_state->fb || WARN_ON(!new_plane_state->crtc))\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t       new_plane_state->crtc);\n\tif (IS_ERR(crtc_state))\n                return PTR_ERR(crtc_state);\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  is_cursor, true);\n\treturn ret;\n}\n\nstatic void virtio_gpu_update_dumb_bo(struct virtio_gpu_device *vgdev,\n\t\t\t\t      struct drm_plane_state *state,\n\t\t\t\t      struct drm_rect *rect)\n{\n\tstruct virtio_gpu_object *bo =\n\t\tgem_to_virtio_gpu_obj(state->fb->obj[0]);\n\tstruct virtio_gpu_object_array *objs;\n\tuint32_t w = rect->x2 - rect->x1;\n\tuint32_t h = rect->y2 - rect->y1;\n\tuint32_t x = rect->x1;\n\tuint32_t y = rect->y1;\n\tuint32_t off = x * state->fb->format->cpp[0] +\n\t\ty * state->fb->pitches[0];\n\n\tobjs = virtio_gpu_array_alloc(1);\n\tif (!objs)\n\t\treturn;\n\tvirtio_gpu_array_add_obj(objs, &bo->base.base);\n\n\tvirtio_gpu_cmd_transfer_to_host_2d(vgdev, off, w, h, x, y,\n\t\t\t\t\t   objs, NULL);\n}\n\nstatic void virtio_gpu_resource_flush(struct drm_plane *plane,\n\t\t\t\t      uint32_t x, uint32_t y,\n\t\t\t\t      uint32_t width, uint32_t height)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\tstruct virtio_gpu_framebuffer *vgfb;\n\tstruct virtio_gpu_object *bo;\n\n\tvgfb = to_virtio_gpu_framebuffer(plane->state->fb);\n\tbo = gem_to_virtio_gpu_obj(vgfb->base.obj[0]);\n\tif (vgfb->fence) {\n\t\tstruct virtio_gpu_object_array *objs;\n\n\t\tobjs = virtio_gpu_array_alloc(1);\n\t\tif (!objs)\n\t\t\treturn;\n\t\tvirtio_gpu_array_add_obj(objs, vgfb->base.obj[0]);\n\t\tvirtio_gpu_array_lock_resv(objs);\n\t\tvirtio_gpu_cmd_resource_flush(vgdev, bo->hw_res_handle, x, y,\n\t\t\t\t\t      width, height, objs, vgfb->fence);\n\t\tvirtio_gpu_notify(vgdev);\n\n\t\tdma_fence_wait_timeout(&vgfb->fence->f, true,\n\t\t\t\t       msecs_to_jiffies(50));\n\t\tdma_fence_put(&vgfb->fence->f);\n\t\tvgfb->fence = NULL;\n\t} else {\n\t\tvirtio_gpu_cmd_resource_flush(vgdev, bo->hw_res_handle, x, y,\n\t\t\t\t\t      width, height, NULL, NULL);\n\t\tvirtio_gpu_notify(vgdev);\n\t}\n}\n\nstatic void virtio_gpu_primary_plane_update(struct drm_plane *plane,\n\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_device *dev = plane->dev;\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\tstruct virtio_gpu_output *output = NULL;\n\tstruct virtio_gpu_object *bo;\n\tstruct drm_rect rect;\n\n\tif (plane->state->crtc)\n\t\toutput = drm_crtc_to_virtio_gpu_output(plane->state->crtc);\n\tif (old_state->crtc)\n\t\toutput = drm_crtc_to_virtio_gpu_output(old_state->crtc);\n\tif (WARN_ON(!output))\n\t\treturn;\n\n\tif (!plane->state->fb || !output->crtc.state->active) {\n\t\tDRM_DEBUG(\"nofb\\n\");\n\t\tvirtio_gpu_cmd_set_scanout(vgdev, output->index, 0,\n\t\t\t\t\t   plane->state->src_w >> 16,\n\t\t\t\t\t   plane->state->src_h >> 16,\n\t\t\t\t\t   0, 0);\n\t\tvirtio_gpu_notify(vgdev);\n\t\treturn;\n\t}\n\n\tif (!drm_atomic_helper_damage_merged(old_state, plane->state, &rect))\n\t\treturn;\n\n\tbo = gem_to_virtio_gpu_obj(plane->state->fb->obj[0]);\n\tif (bo->dumb)\n\t\tvirtio_gpu_update_dumb_bo(vgdev, plane->state, &rect);\n\n\tif (plane->state->fb != old_state->fb ||\n\t    plane->state->src_w != old_state->src_w ||\n\t    plane->state->src_h != old_state->src_h ||\n\t    plane->state->src_x != old_state->src_x ||\n\t    plane->state->src_y != old_state->src_y ||\n\t    output->needs_modeset) {\n\t\toutput->needs_modeset = false;\n\t\tDRM_DEBUG(\"handle 0x%x, crtc %dx%d+%d+%d, src %dx%d+%d+%d\\n\",\n\t\t\t  bo->hw_res_handle,\n\t\t\t  plane->state->crtc_w, plane->state->crtc_h,\n\t\t\t  plane->state->crtc_x, plane->state->crtc_y,\n\t\t\t  plane->state->src_w >> 16,\n\t\t\t  plane->state->src_h >> 16,\n\t\t\t  plane->state->src_x >> 16,\n\t\t\t  plane->state->src_y >> 16);\n\n\t\tif (bo->host3d_blob || bo->guest_blob) {\n\t\t\tvirtio_gpu_cmd_set_scanout_blob\n\t\t\t\t\t\t(vgdev, output->index, bo,\n\t\t\t\t\t\t plane->state->fb,\n\t\t\t\t\t\t plane->state->src_w >> 16,\n\t\t\t\t\t\t plane->state->src_h >> 16,\n\t\t\t\t\t\t plane->state->src_x >> 16,\n\t\t\t\t\t\t plane->state->src_y >> 16);\n\t\t} else {\n\t\t\tvirtio_gpu_cmd_set_scanout(vgdev, output->index,\n\t\t\t\t\t\t   bo->hw_res_handle,\n\t\t\t\t\t\t   plane->state->src_w >> 16,\n\t\t\t\t\t\t   plane->state->src_h >> 16,\n\t\t\t\t\t\t   plane->state->src_x >> 16,\n\t\t\t\t\t\t   plane->state->src_y >> 16);\n\t\t}\n\t}\n\n\tvirtio_gpu_resource_flush(plane,\n\t\t\t\t  rect.x1,\n\t\t\t\t  rect.y1,\n\t\t\t\t  rect.x2 - rect.x1,\n\t\t\t\t  rect.y2 - rect.y1);\n}\n\nstatic int virtio_gpu_plane_prepare_fb(struct drm_plane *plane,\n\t\t\t\t       struct drm_plane_state *new_state)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\tstruct virtio_gpu_framebuffer *vgfb;\n\tstruct virtio_gpu_object *bo;\n\n\tif (!new_state->fb)\n\t\treturn 0;\n\n\tvgfb = to_virtio_gpu_framebuffer(new_state->fb);\n\tbo = gem_to_virtio_gpu_obj(vgfb->base.obj[0]);\n\tif (!bo || (plane->type == DRM_PLANE_TYPE_PRIMARY && !bo->guest_blob))\n\t\treturn 0;\n\n\tif (bo->dumb && (plane->state->fb != new_state->fb)) {\n\t\tvgfb->fence = virtio_gpu_fence_alloc(vgdev, vgdev->fence_drv.context,\n\t\t\t\t\t\t     0);\n\t\tif (!vgfb->fence)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void virtio_gpu_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_plane_state *state)\n{\n\tstruct virtio_gpu_framebuffer *vgfb;\n\n\tif (!state->fb)\n\t\treturn;\n\n\tvgfb = to_virtio_gpu_framebuffer(state->fb);\n\tif (vgfb->fence) {\n\t\tdma_fence_put(&vgfb->fence->f);\n\t\tvgfb->fence = NULL;\n\t}\n}\n\nstatic void virtio_gpu_cursor_plane_update(struct drm_plane *plane,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_device *dev = plane->dev;\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\tstruct virtio_gpu_output *output = NULL;\n\tstruct virtio_gpu_framebuffer *vgfb;\n\tstruct virtio_gpu_object *bo = NULL;\n\tuint32_t handle;\n\n\tif (plane->state->crtc)\n\t\toutput = drm_crtc_to_virtio_gpu_output(plane->state->crtc);\n\tif (old_state->crtc)\n\t\toutput = drm_crtc_to_virtio_gpu_output(old_state->crtc);\n\tif (WARN_ON(!output))\n\t\treturn;\n\n\tif (plane->state->fb) {\n\t\tvgfb = to_virtio_gpu_framebuffer(plane->state->fb);\n\t\tbo = gem_to_virtio_gpu_obj(vgfb->base.obj[0]);\n\t\thandle = bo->hw_res_handle;\n\t} else {\n\t\thandle = 0;\n\t}\n\n\tif (bo && bo->dumb && (plane->state->fb != old_state->fb)) {\n\t\t \n\t\tstruct virtio_gpu_object_array *objs;\n\n\t\tobjs = virtio_gpu_array_alloc(1);\n\t\tif (!objs)\n\t\t\treturn;\n\t\tvirtio_gpu_array_add_obj(objs, vgfb->base.obj[0]);\n\t\tvirtio_gpu_array_lock_resv(objs);\n\t\tvirtio_gpu_cmd_transfer_to_host_2d\n\t\t\t(vgdev, 0,\n\t\t\t plane->state->crtc_w,\n\t\t\t plane->state->crtc_h,\n\t\t\t 0, 0, objs, vgfb->fence);\n\t\tvirtio_gpu_notify(vgdev);\n\t\tdma_fence_wait(&vgfb->fence->f, true);\n\t\tdma_fence_put(&vgfb->fence->f);\n\t\tvgfb->fence = NULL;\n\t}\n\n\tif (plane->state->fb != old_state->fb) {\n\t\tDRM_DEBUG(\"update, handle %d, pos +%d+%d, hot %d,%d\\n\", handle,\n\t\t\t  plane->state->crtc_x,\n\t\t\t  plane->state->crtc_y,\n\t\t\t  plane->state->fb ? plane->state->fb->hot_x : 0,\n\t\t\t  plane->state->fb ? plane->state->fb->hot_y : 0);\n\t\toutput->cursor.hdr.type =\n\t\t\tcpu_to_le32(VIRTIO_GPU_CMD_UPDATE_CURSOR);\n\t\toutput->cursor.resource_id = cpu_to_le32(handle);\n\t\tif (plane->state->fb) {\n\t\t\toutput->cursor.hot_x =\n\t\t\t\tcpu_to_le32(plane->state->fb->hot_x);\n\t\t\toutput->cursor.hot_y =\n\t\t\t\tcpu_to_le32(plane->state->fb->hot_y);\n\t\t} else {\n\t\t\toutput->cursor.hot_x = cpu_to_le32(0);\n\t\t\toutput->cursor.hot_y = cpu_to_le32(0);\n\t\t}\n\t} else {\n\t\tDRM_DEBUG(\"move +%d+%d\\n\",\n\t\t\t  plane->state->crtc_x,\n\t\t\t  plane->state->crtc_y);\n\t\toutput->cursor.hdr.type =\n\t\t\tcpu_to_le32(VIRTIO_GPU_CMD_MOVE_CURSOR);\n\t}\n\toutput->cursor.pos.x = cpu_to_le32(plane->state->crtc_x);\n\toutput->cursor.pos.y = cpu_to_le32(plane->state->crtc_y);\n\tvirtio_gpu_cursor_ping(vgdev, output);\n}\n\nstatic const struct drm_plane_helper_funcs virtio_gpu_primary_helper_funcs = {\n\t.prepare_fb\t\t= virtio_gpu_plane_prepare_fb,\n\t.cleanup_fb\t\t= virtio_gpu_plane_cleanup_fb,\n\t.atomic_check\t\t= virtio_gpu_plane_atomic_check,\n\t.atomic_update\t\t= virtio_gpu_primary_plane_update,\n};\n\nstatic const struct drm_plane_helper_funcs virtio_gpu_cursor_helper_funcs = {\n\t.prepare_fb\t\t= virtio_gpu_plane_prepare_fb,\n\t.cleanup_fb\t\t= virtio_gpu_plane_cleanup_fb,\n\t.atomic_check\t\t= virtio_gpu_plane_atomic_check,\n\t.atomic_update\t\t= virtio_gpu_cursor_plane_update,\n};\n\nstruct drm_plane *virtio_gpu_plane_init(struct virtio_gpu_device *vgdev,\n\t\t\t\t\tenum drm_plane_type type,\n\t\t\t\t\tint index)\n{\n\tstruct drm_device *dev = vgdev->ddev;\n\tconst struct drm_plane_helper_funcs *funcs;\n\tstruct drm_plane *plane;\n\tconst uint32_t *formats;\n\tint nformats;\n\n\tif (type == DRM_PLANE_TYPE_CURSOR) {\n\t\tformats = virtio_gpu_cursor_formats;\n\t\tnformats = ARRAY_SIZE(virtio_gpu_cursor_formats);\n\t\tfuncs = &virtio_gpu_cursor_helper_funcs;\n\t} else {\n\t\tformats = virtio_gpu_formats;\n\t\tnformats = ARRAY_SIZE(virtio_gpu_formats);\n\t\tfuncs = &virtio_gpu_primary_helper_funcs;\n\t}\n\n\tplane = drmm_universal_plane_alloc(dev, struct drm_plane, dev,\n\t\t\t\t\t   1 << index, &virtio_gpu_plane_funcs,\n\t\t\t\t\t   formats, nformats, NULL, type, NULL);\n\tif (IS_ERR(plane))\n\t\treturn plane;\n\n\tdrm_plane_helper_add(plane, funcs);\n\n\tif (type == DRM_PLANE_TYPE_PRIMARY)\n\t\tdrm_plane_enable_fb_damage_clips(plane);\n\n\treturn plane;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}