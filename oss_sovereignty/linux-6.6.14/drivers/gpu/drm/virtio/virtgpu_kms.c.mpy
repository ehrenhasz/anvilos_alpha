{
  "module_name": "virtgpu_kms.c",
  "hash_id": "e6c9d42198748abefd1b1235a40d9563a9dc11d3f3dffc30b8dadf157b9d05ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/virtio/virtgpu_kms.c",
  "human_readable_source": " \n\n#include <linux/virtio.h>\n#include <linux/virtio_config.h>\n#include <linux/virtio_ring.h>\n\n#include <drm/drm_file.h>\n#include <drm/drm_managed.h>\n\n#include \"virtgpu_drv.h\"\n\nstatic void virtio_gpu_config_changed_work_func(struct work_struct *work)\n{\n\tstruct virtio_gpu_device *vgdev =\n\t\tcontainer_of(work, struct virtio_gpu_device,\n\t\t\t     config_changed_work);\n\tu32 events_read, events_clear = 0;\n\n\t \n\tvirtio_cread_le(vgdev->vdev, struct virtio_gpu_config,\n\t\t\tevents_read, &events_read);\n\tif (events_read & VIRTIO_GPU_EVENT_DISPLAY) {\n\t\tif (vgdev->num_scanouts) {\n\t\t\tif (vgdev->has_edid)\n\t\t\t\tvirtio_gpu_cmd_get_edids(vgdev);\n\t\t\tvirtio_gpu_cmd_get_display_info(vgdev);\n\t\t\tvirtio_gpu_notify(vgdev);\n\t\t\tdrm_helper_hpd_irq_event(vgdev->ddev);\n\t\t}\n\t\tevents_clear |= VIRTIO_GPU_EVENT_DISPLAY;\n\t}\n\tvirtio_cwrite_le(vgdev->vdev, struct virtio_gpu_config,\n\t\t\t events_clear, &events_clear);\n}\n\nstatic void virtio_gpu_init_vq(struct virtio_gpu_queue *vgvq,\n\t\t\t       void (*work_func)(struct work_struct *work))\n{\n\tspin_lock_init(&vgvq->qlock);\n\tinit_waitqueue_head(&vgvq->ack_queue);\n\tINIT_WORK(&vgvq->dequeue_work, work_func);\n}\n\nstatic void virtio_gpu_get_capsets(struct virtio_gpu_device *vgdev,\n\t\t\t\t   int num_capsets)\n{\n\tint i, ret;\n\tbool invalid_capset_id = false;\n\tstruct drm_device *drm = vgdev->ddev;\n\n\tvgdev->capsets = drmm_kcalloc(drm, num_capsets,\n\t\t\t\t      sizeof(struct virtio_gpu_drv_capset),\n\t\t\t\t      GFP_KERNEL);\n\tif (!vgdev->capsets) {\n\t\tDRM_ERROR(\"failed to allocate cap sets\\n\");\n\t\treturn;\n\t}\n\tfor (i = 0; i < num_capsets; i++) {\n\t\tvirtio_gpu_cmd_get_capset_info(vgdev, i);\n\t\tvirtio_gpu_notify(vgdev);\n\t\tret = wait_event_timeout(vgdev->resp_wq,\n\t\t\t\t\t vgdev->capsets[i].id > 0, 5 * HZ);\n\t\t \n\t\tif (!vgdev->capsets[i].id ||\n\t\t    vgdev->capsets[i].id > MAX_CAPSET_ID)\n\t\t\tinvalid_capset_id = true;\n\n\t\tif (ret == 0)\n\t\t\tDRM_ERROR(\"timed out waiting for cap set %d\\n\", i);\n\t\telse if (invalid_capset_id)\n\t\t\tDRM_ERROR(\"invalid capset id %u\", vgdev->capsets[i].id);\n\n\t\tif (ret == 0 || invalid_capset_id) {\n\t\t\tspin_lock(&vgdev->display_info_lock);\n\t\t\tdrmm_kfree(drm, vgdev->capsets);\n\t\t\tvgdev->capsets = NULL;\n\t\t\tspin_unlock(&vgdev->display_info_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tvgdev->capset_id_mask |= 1 << vgdev->capsets[i].id;\n\t\tDRM_INFO(\"cap set %d: id %d, max-version %d, max-size %d\\n\",\n\t\t\t i, vgdev->capsets[i].id,\n\t\t\t vgdev->capsets[i].max_version,\n\t\t\t vgdev->capsets[i].max_size);\n\t}\n\n\tvgdev->num_capsets = num_capsets;\n}\n\nint virtio_gpu_init(struct virtio_device *vdev, struct drm_device *dev)\n{\n\tstatic vq_callback_t *callbacks[] = {\n\t\tvirtio_gpu_ctrl_ack, virtio_gpu_cursor_ack\n\t};\n\tstatic const char * const names[] = { \"control\", \"cursor\" };\n\n\tstruct virtio_gpu_device *vgdev;\n\t \n\tstruct virtqueue *vqs[2];\n\tu32 num_scanouts, num_capsets;\n\tint ret = 0;\n\n\tif (!virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\treturn -ENODEV;\n\n\tvgdev = drmm_kzalloc(dev, sizeof(struct virtio_gpu_device), GFP_KERNEL);\n\tif (!vgdev)\n\t\treturn -ENOMEM;\n\n\tvgdev->ddev = dev;\n\tdev->dev_private = vgdev;\n\tvgdev->vdev = vdev;\n\n\tspin_lock_init(&vgdev->display_info_lock);\n\tspin_lock_init(&vgdev->resource_export_lock);\n\tspin_lock_init(&vgdev->host_visible_lock);\n\tida_init(&vgdev->ctx_id_ida);\n\tida_init(&vgdev->resource_ida);\n\tinit_waitqueue_head(&vgdev->resp_wq);\n\tvirtio_gpu_init_vq(&vgdev->ctrlq, virtio_gpu_dequeue_ctrl_func);\n\tvirtio_gpu_init_vq(&vgdev->cursorq, virtio_gpu_dequeue_cursor_func);\n\n\tvgdev->fence_drv.context = dma_fence_context_alloc(1);\n\tspin_lock_init(&vgdev->fence_drv.lock);\n\tINIT_LIST_HEAD(&vgdev->fence_drv.fences);\n\tINIT_LIST_HEAD(&vgdev->cap_cache);\n\tINIT_WORK(&vgdev->config_changed_work,\n\t\t  virtio_gpu_config_changed_work_func);\n\n\tINIT_WORK(&vgdev->obj_free_work,\n\t\t  virtio_gpu_array_put_free_work);\n\tINIT_LIST_HEAD(&vgdev->obj_free_list);\n\tspin_lock_init(&vgdev->obj_free_lock);\n\n#ifdef __LITTLE_ENDIAN\n\tif (virtio_has_feature(vgdev->vdev, VIRTIO_GPU_F_VIRGL))\n\t\tvgdev->has_virgl_3d = true;\n#endif\n\tif (virtio_has_feature(vgdev->vdev, VIRTIO_GPU_F_EDID)) {\n\t\tvgdev->has_edid = true;\n\t}\n\tif (virtio_has_feature(vgdev->vdev, VIRTIO_RING_F_INDIRECT_DESC)) {\n\t\tvgdev->has_indirect = true;\n\t}\n\tif (virtio_has_feature(vgdev->vdev, VIRTIO_GPU_F_RESOURCE_UUID)) {\n\t\tvgdev->has_resource_assign_uuid = true;\n\t}\n\tif (virtio_has_feature(vgdev->vdev, VIRTIO_GPU_F_RESOURCE_BLOB)) {\n\t\tvgdev->has_resource_blob = true;\n\t}\n\tif (virtio_get_shm_region(vgdev->vdev, &vgdev->host_visible_region,\n\t\t\t\t  VIRTIO_GPU_SHM_ID_HOST_VISIBLE)) {\n\t\tif (!devm_request_mem_region(&vgdev->vdev->dev,\n\t\t\t\t\t     vgdev->host_visible_region.addr,\n\t\t\t\t\t     vgdev->host_visible_region.len,\n\t\t\t\t\t     dev_name(&vgdev->vdev->dev))) {\n\t\t\tDRM_ERROR(\"Could not reserve host visible region\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_vqs;\n\t\t}\n\n\t\tDRM_INFO(\"Host memory window: 0x%lx +0x%lx\\n\",\n\t\t\t (unsigned long)vgdev->host_visible_region.addr,\n\t\t\t (unsigned long)vgdev->host_visible_region.len);\n\t\tvgdev->has_host_visible = true;\n\t\tdrm_mm_init(&vgdev->host_visible_mm,\n\t\t\t    (unsigned long)vgdev->host_visible_region.addr,\n\t\t\t    (unsigned long)vgdev->host_visible_region.len);\n\t}\n\tif (virtio_has_feature(vgdev->vdev, VIRTIO_GPU_F_CONTEXT_INIT)) {\n\t\tvgdev->has_context_init = true;\n\t}\n\n\tDRM_INFO(\"features: %cvirgl %cedid %cresource_blob %chost_visible\",\n\t\t vgdev->has_virgl_3d    ? '+' : '-',\n\t\t vgdev->has_edid        ? '+' : '-',\n\t\t vgdev->has_resource_blob ? '+' : '-',\n\t\t vgdev->has_host_visible ? '+' : '-');\n\n\tDRM_INFO(\"features: %ccontext_init\\n\",\n\t\t vgdev->has_context_init ? '+' : '-');\n\n\tret = virtio_find_vqs(vgdev->vdev, 2, vqs, callbacks, names, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to find virt queues\\n\");\n\t\tgoto err_vqs;\n\t}\n\tvgdev->ctrlq.vq = vqs[0];\n\tvgdev->cursorq.vq = vqs[1];\n\tret = virtio_gpu_alloc_vbufs(vgdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to alloc vbufs\\n\");\n\t\tgoto err_vbufs;\n\t}\n\n\t \n\tvirtio_cread_le(vgdev->vdev, struct virtio_gpu_config,\n\t\t\tnum_scanouts, &num_scanouts);\n\tvgdev->num_scanouts = min_t(uint32_t, num_scanouts,\n\t\t\t\t    VIRTIO_GPU_MAX_SCANOUTS);\n\n\tif (!IS_ENABLED(CONFIG_DRM_VIRTIO_GPU_KMS) || !vgdev->num_scanouts) {\n\t\tDRM_INFO(\"KMS disabled\\n\");\n\t\tvgdev->num_scanouts = 0;\n\t\tvgdev->has_edid = false;\n\t\tdev->driver_features &= ~(DRIVER_MODESET | DRIVER_ATOMIC);\n\t} else {\n\t\tDRM_INFO(\"number of scanouts: %d\\n\", num_scanouts);\n\t}\n\n\tvirtio_cread_le(vgdev->vdev, struct virtio_gpu_config,\n\t\t\tnum_capsets, &num_capsets);\n\tDRM_INFO(\"number of cap sets: %d\\n\", num_capsets);\n\n\tret = virtio_gpu_modeset_init(vgdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"modeset init failed\\n\");\n\t\tgoto err_scanouts;\n\t}\n\n\tvirtio_device_ready(vgdev->vdev);\n\n\tif (num_capsets)\n\t\tvirtio_gpu_get_capsets(vgdev, num_capsets);\n\tif (vgdev->num_scanouts) {\n\t\tif (vgdev->has_edid)\n\t\t\tvirtio_gpu_cmd_get_edids(vgdev);\n\t\tvirtio_gpu_cmd_get_display_info(vgdev);\n\t\tvirtio_gpu_notify(vgdev);\n\t\twait_event_timeout(vgdev->resp_wq, !vgdev->display_info_pending,\n\t\t\t\t   5 * HZ);\n\t}\n\treturn 0;\n\nerr_scanouts:\n\tvirtio_gpu_free_vbufs(vgdev);\nerr_vbufs:\n\tvgdev->vdev->config->del_vqs(vgdev->vdev);\nerr_vqs:\n\tdev->dev_private = NULL;\n\treturn ret;\n}\n\nstatic void virtio_gpu_cleanup_cap_cache(struct virtio_gpu_device *vgdev)\n{\n\tstruct virtio_gpu_drv_cap_cache *cache_ent, *tmp;\n\n\tlist_for_each_entry_safe(cache_ent, tmp, &vgdev->cap_cache, head) {\n\t\tkfree(cache_ent->caps_cache);\n\t\tkfree(cache_ent);\n\t}\n}\n\nvoid virtio_gpu_deinit(struct drm_device *dev)\n{\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\n\tflush_work(&vgdev->obj_free_work);\n\tflush_work(&vgdev->ctrlq.dequeue_work);\n\tflush_work(&vgdev->cursorq.dequeue_work);\n\tflush_work(&vgdev->config_changed_work);\n\tvirtio_reset_device(vgdev->vdev);\n\tvgdev->vdev->config->del_vqs(vgdev->vdev);\n}\n\nvoid virtio_gpu_release(struct drm_device *dev)\n{\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\n\tif (!vgdev)\n\t\treturn;\n\n\tvirtio_gpu_modeset_fini(vgdev);\n\tvirtio_gpu_free_vbufs(vgdev);\n\tvirtio_gpu_cleanup_cap_cache(vgdev);\n\n\tif (vgdev->has_host_visible)\n\t\tdrm_mm_takedown(&vgdev->host_visible_mm);\n}\n\nint virtio_gpu_driver_open(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\tstruct virtio_gpu_fpriv *vfpriv;\n\tint handle;\n\n\t \n\tif (!vgdev->has_virgl_3d)\n\t\treturn 0;\n\n\t \n\tvfpriv = kzalloc(sizeof(*vfpriv), GFP_KERNEL);\n\tif (!vfpriv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&vfpriv->context_lock);\n\n\thandle = ida_alloc(&vgdev->ctx_id_ida, GFP_KERNEL);\n\tif (handle < 0) {\n\t\tkfree(vfpriv);\n\t\treturn handle;\n\t}\n\n\tvfpriv->ctx_id = handle + 1;\n\tfile->driver_priv = vfpriv;\n\treturn 0;\n}\n\nvoid virtio_gpu_driver_postclose(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\tstruct virtio_gpu_fpriv *vfpriv = file->driver_priv;\n\n\tif (!vgdev->has_virgl_3d)\n\t\treturn;\n\n\tif (vfpriv->context_created) {\n\t\tvirtio_gpu_cmd_context_destroy(vgdev, vfpriv->ctx_id);\n\t\tvirtio_gpu_notify(vgdev);\n\t}\n\n\tida_free(&vgdev->ctx_id_ida, vfpriv->ctx_id - 1);\n\tmutex_destroy(&vfpriv->context_lock);\n\tkfree(vfpriv);\n\tfile->driver_priv = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}