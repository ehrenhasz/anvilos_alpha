{
  "module_name": "virtgpu_display.c",
  "hash_id": "732a2f5a304209e43fbb268da70008f28688fcbc1c0dd3285fac1f64f12383a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/virtio/virtgpu_display.c",
  "human_readable_source": " \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"virtgpu_drv.h\"\n\n#define XRES_MIN    32\n#define YRES_MIN    32\n\n#define XRES_DEF  1024\n#define YRES_DEF   768\n\n#define XRES_MAX  8192\n#define YRES_MAX  8192\n\n#define drm_connector_to_virtio_gpu_output(x) \\\n\tcontainer_of(x, struct virtio_gpu_output, conn)\n\nstatic const struct drm_crtc_funcs virtio_gpu_crtc_funcs = {\n\t.set_config             = drm_atomic_helper_set_config,\n\t.destroy                = drm_crtc_cleanup,\n\n\t.page_flip              = drm_atomic_helper_page_flip,\n\t.reset                  = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state   = drm_atomic_helper_crtc_destroy_state,\n};\n\nstatic const struct drm_framebuffer_funcs virtio_gpu_fb_funcs = {\n\t.create_handle = drm_gem_fb_create_handle,\n\t.destroy = drm_gem_fb_destroy,\n\t.dirty = drm_atomic_helper_dirtyfb,\n};\n\nstatic int\nvirtio_gpu_framebuffer_init(struct drm_device *dev,\n\t\t\t    struct virtio_gpu_framebuffer *vgfb,\n\t\t\t    const struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t\t    struct drm_gem_object *obj)\n{\n\tint ret;\n\n\tvgfb->base.obj[0] = obj;\n\n\tdrm_helper_mode_fill_fb_struct(dev, &vgfb->base, mode_cmd);\n\n\tret = drm_framebuffer_init(dev, &vgfb->base, &virtio_gpu_fb_funcs);\n\tif (ret) {\n\t\tvgfb->base.obj[0] = NULL;\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void virtio_gpu_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\tstruct virtio_gpu_output *output = drm_crtc_to_virtio_gpu_output(crtc);\n\n\tvirtio_gpu_cmd_set_scanout(vgdev, output->index, 0,\n\t\t\t\t   crtc->mode.hdisplay,\n\t\t\t\t   crtc->mode.vdisplay, 0, 0);\n\tvirtio_gpu_notify(vgdev);\n}\n\nstatic void virtio_gpu_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n}\n\nstatic void virtio_gpu_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\tstruct virtio_gpu_output *output = drm_crtc_to_virtio_gpu_output(crtc);\n\n\tvirtio_gpu_cmd_set_scanout(vgdev, output->index, 0, 0, 0, 0, 0);\n\tvirtio_gpu_notify(vgdev);\n}\n\nstatic int virtio_gpu_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\treturn 0;\n}\n\nstatic void virtio_gpu_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct virtio_gpu_output *output = drm_crtc_to_virtio_gpu_output(crtc);\n\n\t \n\tif (drm_atomic_crtc_needs_modeset(crtc_state)) {\n\t\toutput->needs_modeset = true;\n\t}\n}\n\nstatic const struct drm_crtc_helper_funcs virtio_gpu_crtc_helper_funcs = {\n\t.mode_set_nofb = virtio_gpu_crtc_mode_set_nofb,\n\t.atomic_check  = virtio_gpu_crtc_atomic_check,\n\t.atomic_flush  = virtio_gpu_crtc_atomic_flush,\n\t.atomic_enable = virtio_gpu_crtc_atomic_enable,\n\t.atomic_disable = virtio_gpu_crtc_atomic_disable,\n};\n\nstatic void virtio_gpu_enc_mode_set(struct drm_encoder *encoder,\n\t\t\t\t    struct drm_display_mode *mode,\n\t\t\t\t    struct drm_display_mode *adjusted_mode)\n{\n}\n\nstatic void virtio_gpu_enc_enable(struct drm_encoder *encoder)\n{\n}\n\nstatic void virtio_gpu_enc_disable(struct drm_encoder *encoder)\n{\n}\n\nstatic int virtio_gpu_conn_get_modes(struct drm_connector *connector)\n{\n\tstruct virtio_gpu_output *output =\n\t\tdrm_connector_to_virtio_gpu_output(connector);\n\tstruct drm_display_mode *mode = NULL;\n\tint count, width, height;\n\n\tif (output->edid) {\n\t\tcount = drm_add_edid_modes(connector, output->edid);\n\t\tif (count)\n\t\t\treturn count;\n\t}\n\n\twidth  = le32_to_cpu(output->info.r.width);\n\theight = le32_to_cpu(output->info.r.height);\n\tcount = drm_add_modes_noedid(connector, XRES_MAX, YRES_MAX);\n\n\tif (width == 0 || height == 0) {\n\t\tdrm_set_preferred_mode(connector, XRES_DEF, YRES_DEF);\n\t} else {\n\t\tDRM_DEBUG(\"add mode: %dx%d\\n\", width, height);\n\t\tmode = drm_cvt_mode(connector->dev, width, height, 60,\n\t\t\t\t    false, false, false);\n\t\tif (!mode)\n\t\t\treturn count;\n\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic enum drm_mode_status virtio_gpu_conn_mode_valid(struct drm_connector *connector,\n\t\t\t\t      struct drm_display_mode *mode)\n{\n\tstruct virtio_gpu_output *output =\n\t\tdrm_connector_to_virtio_gpu_output(connector);\n\tint width, height;\n\n\twidth  = le32_to_cpu(output->info.r.width);\n\theight = le32_to_cpu(output->info.r.height);\n\n\tif (!(mode->type & DRM_MODE_TYPE_PREFERRED))\n\t\treturn MODE_OK;\n\tif (mode->hdisplay == XRES_DEF && mode->vdisplay == YRES_DEF)\n\t\treturn MODE_OK;\n\tif (mode->hdisplay <= width  && mode->hdisplay >= width - 16 &&\n\t    mode->vdisplay <= height && mode->vdisplay >= height - 16)\n\t\treturn MODE_OK;\n\n\tDRM_DEBUG(\"del mode: %dx%d\\n\", mode->hdisplay, mode->vdisplay);\n\treturn MODE_BAD;\n}\n\nstatic const struct drm_encoder_helper_funcs virtio_gpu_enc_helper_funcs = {\n\t.mode_set   = virtio_gpu_enc_mode_set,\n\t.enable     = virtio_gpu_enc_enable,\n\t.disable    = virtio_gpu_enc_disable,\n};\n\nstatic const struct drm_connector_helper_funcs virtio_gpu_conn_helper_funcs = {\n\t.get_modes    = virtio_gpu_conn_get_modes,\n\t.mode_valid   = virtio_gpu_conn_mode_valid,\n};\n\nstatic enum drm_connector_status virtio_gpu_conn_detect(\n\t\t\tstruct drm_connector *connector,\n\t\t\tbool force)\n{\n\tstruct virtio_gpu_output *output =\n\t\tdrm_connector_to_virtio_gpu_output(connector);\n\n\tif (output->info.enabled)\n\t\treturn connector_status_connected;\n\telse\n\t\treturn connector_status_disconnected;\n}\n\nstatic void virtio_gpu_conn_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_funcs virtio_gpu_connector_funcs = {\n\t.detect = virtio_gpu_conn_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = virtio_gpu_conn_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int vgdev_output_init(struct virtio_gpu_device *vgdev, int index)\n{\n\tstruct drm_device *dev = vgdev->ddev;\n\tstruct virtio_gpu_output *output = vgdev->outputs + index;\n\tstruct drm_connector *connector = &output->conn;\n\tstruct drm_encoder *encoder = &output->enc;\n\tstruct drm_crtc *crtc = &output->crtc;\n\tstruct drm_plane *primary, *cursor;\n\n\toutput->index = index;\n\tif (index == 0) {\n\t\toutput->info.enabled = cpu_to_le32(true);\n\t\toutput->info.r.width = cpu_to_le32(XRES_DEF);\n\t\toutput->info.r.height = cpu_to_le32(YRES_DEF);\n\t}\n\n\tprimary = virtio_gpu_plane_init(vgdev, DRM_PLANE_TYPE_PRIMARY, index);\n\tif (IS_ERR(primary))\n\t\treturn PTR_ERR(primary);\n\tcursor = virtio_gpu_plane_init(vgdev, DRM_PLANE_TYPE_CURSOR, index);\n\tif (IS_ERR(cursor))\n\t\treturn PTR_ERR(cursor);\n\tdrm_crtc_init_with_planes(dev, crtc, primary, cursor,\n\t\t\t\t  &virtio_gpu_crtc_funcs, NULL);\n\tdrm_crtc_helper_add(crtc, &virtio_gpu_crtc_helper_funcs);\n\n\tdrm_connector_init(dev, connector, &virtio_gpu_connector_funcs,\n\t\t\t   DRM_MODE_CONNECTOR_VIRTUAL);\n\tdrm_connector_helper_add(connector, &virtio_gpu_conn_helper_funcs);\n\tif (vgdev->has_edid)\n\t\tdrm_connector_attach_edid_property(connector);\n\n\tdrm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_VIRTUAL);\n\tdrm_encoder_helper_add(encoder, &virtio_gpu_enc_helper_funcs);\n\tencoder->possible_crtcs = 1 << index;\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\tdrm_connector_register(connector);\n\treturn 0;\n}\n\nstatic struct drm_framebuffer *\nvirtio_gpu_user_framebuffer_create(struct drm_device *dev,\n\t\t\t\t   struct drm_file *file_priv,\n\t\t\t\t   const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct drm_gem_object *obj = NULL;\n\tstruct virtio_gpu_framebuffer *virtio_gpu_fb;\n\tint ret;\n\n\tif (mode_cmd->pixel_format != DRM_FORMAT_HOST_XRGB8888 &&\n\t    mode_cmd->pixel_format != DRM_FORMAT_HOST_ARGB8888)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t \n\tobj = drm_gem_object_lookup(file_priv, mode_cmd->handles[0]);\n\tif (!obj)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tvirtio_gpu_fb = kzalloc(sizeof(*virtio_gpu_fb), GFP_KERNEL);\n\tif (virtio_gpu_fb == NULL) {\n\t\tdrm_gem_object_put(obj);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tret = virtio_gpu_framebuffer_init(dev, virtio_gpu_fb, mode_cmd, obj);\n\tif (ret) {\n\t\tkfree(virtio_gpu_fb);\n\t\tdrm_gem_object_put(obj);\n\t\treturn NULL;\n\t}\n\n\treturn &virtio_gpu_fb->base;\n}\n\nstatic const struct drm_mode_config_funcs virtio_gpu_mode_funcs = {\n\t.fb_create = virtio_gpu_user_framebuffer_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nint virtio_gpu_modeset_init(struct virtio_gpu_device *vgdev)\n{\n\tint i, ret;\n\n\tif (!vgdev->num_scanouts)\n\t\treturn 0;\n\n\tret = drmm_mode_config_init(vgdev->ddev);\n\tif (ret)\n\t\treturn ret;\n\n\tvgdev->ddev->mode_config.quirk_addfb_prefer_host_byte_order = true;\n\tvgdev->ddev->mode_config.funcs = &virtio_gpu_mode_funcs;\n\n\t \n\tvgdev->ddev->mode_config.min_width = XRES_MIN;\n\tvgdev->ddev->mode_config.min_height = YRES_MIN;\n\tvgdev->ddev->mode_config.max_width = XRES_MAX;\n\tvgdev->ddev->mode_config.max_height = YRES_MAX;\n\n\tvgdev->ddev->mode_config.fb_modifiers_not_supported = true;\n\n\tfor (i = 0 ; i < vgdev->num_scanouts; ++i)\n\t\tvgdev_output_init(vgdev, i);\n\n\tdrm_mode_config_reset(vgdev->ddev);\n\treturn 0;\n}\n\nvoid virtio_gpu_modeset_fini(struct virtio_gpu_device *vgdev)\n{\n\tint i;\n\n\tif (!vgdev->num_scanouts)\n\t\treturn;\n\n\tfor (i = 0 ; i < vgdev->num_scanouts; ++i)\n\t\tkfree(vgdev->outputs[i].edid);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}