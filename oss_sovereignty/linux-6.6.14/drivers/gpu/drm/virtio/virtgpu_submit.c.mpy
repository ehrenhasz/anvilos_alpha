{
  "module_name": "virtgpu_submit.c",
  "hash_id": "070761cc049f9277ba5279a53f58b7197fa6d27fc31bcaad6d287c5abc358c5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/virtio/virtgpu_submit.c",
  "human_readable_source": "\n \n\n#include <linux/dma-fence-unwrap.h>\n#include <linux/file.h>\n#include <linux/sync_file.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_file.h>\n#include <drm/drm_syncobj.h>\n#include <drm/virtgpu_drm.h>\n\n#include \"virtgpu_drv.h\"\n\nstruct virtio_gpu_submit_post_dep {\n\tstruct drm_syncobj *syncobj;\n\tstruct dma_fence_chain *chain;\n\tu64 point;\n};\n\nstruct virtio_gpu_submit {\n\tstruct virtio_gpu_submit_post_dep *post_deps;\n\tunsigned int num_out_syncobjs;\n\n\tstruct drm_syncobj **in_syncobjs;\n\tunsigned int num_in_syncobjs;\n\n\tstruct virtio_gpu_object_array *buflist;\n\tstruct drm_virtgpu_execbuffer *exbuf;\n\tstruct virtio_gpu_fence *out_fence;\n\tstruct virtio_gpu_fpriv *vfpriv;\n\tstruct virtio_gpu_device *vgdev;\n\tstruct sync_file *sync_file;\n\tstruct drm_file *file;\n\tint out_fence_fd;\n\tu64 fence_ctx;\n\tu32 ring_idx;\n\tvoid *buf;\n};\n\nstatic int virtio_gpu_do_fence_wait(struct virtio_gpu_submit *submit,\n\t\t\t\t    struct dma_fence *in_fence)\n{\n\tu32 context = submit->fence_ctx + submit->ring_idx;\n\n\tif (dma_fence_match_context(in_fence, context))\n\t\treturn 0;\n\n\treturn dma_fence_wait(in_fence, true);\n}\n\nstatic int virtio_gpu_dma_fence_wait(struct virtio_gpu_submit *submit,\n\t\t\t\t     struct dma_fence *fence)\n{\n\tstruct dma_fence_unwrap itr;\n\tstruct dma_fence *f;\n\tint err;\n\n\tdma_fence_unwrap_for_each(f, &itr, fence) {\n\t\terr = virtio_gpu_do_fence_wait(submit, f);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void virtio_gpu_free_syncobjs(struct drm_syncobj **syncobjs,\n\t\t\t\t     u32 nr_syncobjs)\n{\n\tu32 i = nr_syncobjs;\n\n\twhile (i--) {\n\t\tif (syncobjs[i])\n\t\t\tdrm_syncobj_put(syncobjs[i]);\n\t}\n\n\tkvfree(syncobjs);\n}\n\nstatic int\nvirtio_gpu_parse_deps(struct virtio_gpu_submit *submit)\n{\n\tstruct drm_virtgpu_execbuffer *exbuf = submit->exbuf;\n\tstruct drm_virtgpu_execbuffer_syncobj syncobj_desc;\n\tsize_t syncobj_stride = exbuf->syncobj_stride;\n\tu32 num_in_syncobjs = exbuf->num_in_syncobjs;\n\tstruct drm_syncobj **syncobjs;\n\tint ret = 0, i;\n\n\tif (!num_in_syncobjs)\n\t\treturn 0;\n\n\t \n\tsyncobjs = kvcalloc(num_in_syncobjs, sizeof(*syncobjs), GFP_KERNEL);\n\tif (!syncobjs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_in_syncobjs; i++) {\n\t\tu64 address = exbuf->in_syncobjs + i * syncobj_stride;\n\t\tstruct dma_fence *fence;\n\n\t\tmemset(&syncobj_desc, 0, sizeof(syncobj_desc));\n\n\t\tif (copy_from_user(&syncobj_desc,\n\t\t\t\t   u64_to_user_ptr(address),\n\t\t\t\t   min(syncobj_stride, sizeof(syncobj_desc)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (syncobj_desc.flags & ~VIRTGPU_EXECBUF_SYNCOBJ_FLAGS) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = drm_syncobj_find_fence(submit->file, syncobj_desc.handle,\n\t\t\t\t\t     syncobj_desc.point, 0, &fence);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = virtio_gpu_dma_fence_wait(submit, fence);\n\n\t\tdma_fence_put(fence);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (syncobj_desc.flags & VIRTGPU_EXECBUF_SYNCOBJ_RESET) {\n\t\t\tsyncobjs[i] = drm_syncobj_find(submit->file,\n\t\t\t\t\t\t       syncobj_desc.handle);\n\t\t\tif (!syncobjs[i]) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tvirtio_gpu_free_syncobjs(syncobjs, i);\n\t\treturn ret;\n\t}\n\n\tsubmit->num_in_syncobjs = num_in_syncobjs;\n\tsubmit->in_syncobjs = syncobjs;\n\n\treturn ret;\n}\n\nstatic void virtio_gpu_reset_syncobjs(struct drm_syncobj **syncobjs,\n\t\t\t\t      u32 nr_syncobjs)\n{\n\tu32 i;\n\n\tfor (i = 0; i < nr_syncobjs; i++) {\n\t\tif (syncobjs[i])\n\t\t\tdrm_syncobj_replace_fence(syncobjs[i], NULL);\n\t}\n}\n\nstatic void\nvirtio_gpu_free_post_deps(struct virtio_gpu_submit_post_dep *post_deps,\n\t\t\t  u32 nr_syncobjs)\n{\n\tu32 i = nr_syncobjs;\n\n\twhile (i--) {\n\t\tkfree(post_deps[i].chain);\n\t\tdrm_syncobj_put(post_deps[i].syncobj);\n\t}\n\n\tkvfree(post_deps);\n}\n\nstatic int virtio_gpu_parse_post_deps(struct virtio_gpu_submit *submit)\n{\n\tstruct drm_virtgpu_execbuffer *exbuf = submit->exbuf;\n\tstruct drm_virtgpu_execbuffer_syncobj syncobj_desc;\n\tstruct virtio_gpu_submit_post_dep *post_deps;\n\tu32 num_out_syncobjs = exbuf->num_out_syncobjs;\n\tsize_t syncobj_stride = exbuf->syncobj_stride;\n\tint ret = 0, i;\n\n\tif (!num_out_syncobjs)\n\t\treturn 0;\n\n\tpost_deps = kvcalloc(num_out_syncobjs, sizeof(*post_deps), GFP_KERNEL);\n\tif (!post_deps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_out_syncobjs; i++) {\n\t\tu64 address = exbuf->out_syncobjs + i * syncobj_stride;\n\n\t\tmemset(&syncobj_desc, 0, sizeof(syncobj_desc));\n\n\t\tif (copy_from_user(&syncobj_desc,\n\t\t\t\t   u64_to_user_ptr(address),\n\t\t\t\t   min(syncobj_stride, sizeof(syncobj_desc)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tpost_deps[i].point = syncobj_desc.point;\n\n\t\tif (syncobj_desc.flags) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (syncobj_desc.point) {\n\t\t\tpost_deps[i].chain = dma_fence_chain_alloc();\n\t\t\tif (!post_deps[i].chain) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpost_deps[i].syncobj = drm_syncobj_find(submit->file,\n\t\t\t\t\t\t\tsyncobj_desc.handle);\n\t\tif (!post_deps[i].syncobj) {\n\t\t\tkfree(post_deps[i].chain);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tvirtio_gpu_free_post_deps(post_deps, i);\n\t\treturn ret;\n\t}\n\n\tsubmit->num_out_syncobjs = num_out_syncobjs;\n\tsubmit->post_deps = post_deps;\n\n\treturn 0;\n}\n\nstatic void\nvirtio_gpu_process_post_deps(struct virtio_gpu_submit *submit)\n{\n\tstruct virtio_gpu_submit_post_dep *post_deps = submit->post_deps;\n\n\tif (post_deps) {\n\t\tstruct dma_fence *fence = &submit->out_fence->f;\n\t\tu32 i;\n\n\t\tfor (i = 0; i < submit->num_out_syncobjs; i++) {\n\t\t\tif (post_deps[i].chain) {\n\t\t\t\tdrm_syncobj_add_point(post_deps[i].syncobj,\n\t\t\t\t\t\t      post_deps[i].chain,\n\t\t\t\t\t\t      fence, post_deps[i].point);\n\t\t\t\tpost_deps[i].chain = NULL;\n\t\t\t} else {\n\t\t\t\tdrm_syncobj_replace_fence(post_deps[i].syncobj,\n\t\t\t\t\t\t\t  fence);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int virtio_gpu_fence_event_create(struct drm_device *dev,\n\t\t\t\t\t struct drm_file *file,\n\t\t\t\t\t struct virtio_gpu_fence *fence,\n\t\t\t\t\t u32 ring_idx)\n{\n\tstruct virtio_gpu_fence_event *e = NULL;\n\tint ret;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->event.type = VIRTGPU_EVENT_FENCE_SIGNALED;\n\te->event.length = sizeof(e->event);\n\n\tret = drm_event_reserve_init(dev, file, &e->base, &e->event);\n\tif (ret) {\n\t\tkfree(e);\n\t\treturn ret;\n\t}\n\n\tfence->e = e;\n\n\treturn 0;\n}\n\nstatic int virtio_gpu_init_submit_buflist(struct virtio_gpu_submit *submit)\n{\n\tstruct drm_virtgpu_execbuffer *exbuf = submit->exbuf;\n\tu32 *bo_handles;\n\n\tif (!exbuf->num_bo_handles)\n\t\treturn 0;\n\n\tbo_handles = kvmalloc_array(exbuf->num_bo_handles, sizeof(*bo_handles),\n\t\t\t\t    GFP_KERNEL);\n\tif (!bo_handles)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(bo_handles, u64_to_user_ptr(exbuf->bo_handles),\n\t\t\t   exbuf->num_bo_handles * sizeof(*bo_handles))) {\n\t\tkvfree(bo_handles);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit->buflist = virtio_gpu_array_from_handles(submit->file, bo_handles,\n\t\t\t\t\t\t\texbuf->num_bo_handles);\n\tif (!submit->buflist) {\n\t\tkvfree(bo_handles);\n\t\treturn -ENOENT;\n\t}\n\n\tkvfree(bo_handles);\n\n\treturn 0;\n}\n\nstatic void virtio_gpu_cleanup_submit(struct virtio_gpu_submit *submit)\n{\n\tvirtio_gpu_reset_syncobjs(submit->in_syncobjs, submit->num_in_syncobjs);\n\tvirtio_gpu_free_syncobjs(submit->in_syncobjs, submit->num_in_syncobjs);\n\tvirtio_gpu_free_post_deps(submit->post_deps, submit->num_out_syncobjs);\n\n\tif (!IS_ERR(submit->buf))\n\t\tkvfree(submit->buf);\n\n\tif (submit->buflist)\n\t\tvirtio_gpu_array_put_free(submit->buflist);\n\n\tif (submit->out_fence_fd >= 0)\n\t\tput_unused_fd(submit->out_fence_fd);\n\n\tif (submit->out_fence)\n\t\tdma_fence_put(&submit->out_fence->f);\n\n\tif (submit->sync_file)\n\t\tfput(submit->sync_file->file);\n}\n\nstatic void virtio_gpu_submit(struct virtio_gpu_submit *submit)\n{\n\tvirtio_gpu_cmd_submit(submit->vgdev, submit->buf, submit->exbuf->size,\n\t\t\t      submit->vfpriv->ctx_id, submit->buflist,\n\t\t\t      submit->out_fence);\n\tvirtio_gpu_notify(submit->vgdev);\n}\n\nstatic void virtio_gpu_complete_submit(struct virtio_gpu_submit *submit)\n{\n\tsubmit->buf = NULL;\n\tsubmit->buflist = NULL;\n\tsubmit->sync_file = NULL;\n\tsubmit->out_fence_fd = -1;\n}\n\nstatic int virtio_gpu_init_submit(struct virtio_gpu_submit *submit,\n\t\t\t\t  struct drm_virtgpu_execbuffer *exbuf,\n\t\t\t\t  struct drm_device *dev,\n\t\t\t\t  struct drm_file *file,\n\t\t\t\t  u64 fence_ctx, u32 ring_idx)\n{\n\tstruct virtio_gpu_fpriv *vfpriv = file->driver_priv;\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\tstruct virtio_gpu_fence *out_fence;\n\tbool drm_fence_event;\n\tint err;\n\n\tmemset(submit, 0, sizeof(*submit));\n\n\tif ((exbuf->flags & VIRTGPU_EXECBUF_RING_IDX) &&\n\t    (vfpriv->ring_idx_mask & BIT_ULL(ring_idx)))\n\t\tdrm_fence_event = true;\n\telse\n\t\tdrm_fence_event = false;\n\n\tif ((exbuf->flags & VIRTGPU_EXECBUF_FENCE_FD_OUT) ||\n\t    exbuf->num_out_syncobjs ||\n\t    exbuf->num_bo_handles ||\n\t    drm_fence_event)\n\t\tout_fence = virtio_gpu_fence_alloc(vgdev, fence_ctx, ring_idx);\n\telse\n\t\tout_fence = NULL;\n\n\tif (drm_fence_event) {\n\t\terr = virtio_gpu_fence_event_create(dev, file, out_fence, ring_idx);\n\t\tif (err) {\n\t\t\tdma_fence_put(&out_fence->f);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tsubmit->out_fence = out_fence;\n\tsubmit->fence_ctx = fence_ctx;\n\tsubmit->ring_idx = ring_idx;\n\tsubmit->out_fence_fd = -1;\n\tsubmit->vfpriv = vfpriv;\n\tsubmit->vgdev = vgdev;\n\tsubmit->exbuf = exbuf;\n\tsubmit->file = file;\n\n\terr = virtio_gpu_init_submit_buflist(submit);\n\tif (err)\n\t\treturn err;\n\n\tsubmit->buf = vmemdup_user(u64_to_user_ptr(exbuf->command), exbuf->size);\n\tif (IS_ERR(submit->buf))\n\t\treturn PTR_ERR(submit->buf);\n\n\tif (exbuf->flags & VIRTGPU_EXECBUF_FENCE_FD_OUT) {\n\t\terr = get_unused_fd_flags(O_CLOEXEC);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tsubmit->out_fence_fd = err;\n\n\t\tsubmit->sync_file = sync_file_create(&out_fence->f);\n\t\tif (!submit->sync_file)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int virtio_gpu_wait_in_fence(struct virtio_gpu_submit *submit)\n{\n\tint ret = 0;\n\n\tif (submit->exbuf->flags & VIRTGPU_EXECBUF_FENCE_FD_IN) {\n\t\tstruct dma_fence *in_fence =\n\t\t\t\tsync_file_get_fence(submit->exbuf->fence_fd);\n\t\tif (!in_fence)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tret = virtio_gpu_dma_fence_wait(submit, in_fence);\n\n\t\tdma_fence_put(in_fence);\n\t}\n\n\treturn ret;\n}\n\nstatic void virtio_gpu_install_out_fence_fd(struct virtio_gpu_submit *submit)\n{\n\tif (submit->sync_file) {\n\t\tsubmit->exbuf->fence_fd = submit->out_fence_fd;\n\t\tfd_install(submit->out_fence_fd, submit->sync_file->file);\n\t}\n}\n\nstatic int virtio_gpu_lock_buflist(struct virtio_gpu_submit *submit)\n{\n\tif (submit->buflist)\n\t\treturn virtio_gpu_array_lock_resv(submit->buflist);\n\n\treturn 0;\n}\n\nint virtio_gpu_execbuffer_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file)\n{\n\tstruct virtio_gpu_device *vgdev = dev->dev_private;\n\tstruct virtio_gpu_fpriv *vfpriv = file->driver_priv;\n\tu64 fence_ctx = vgdev->fence_drv.context;\n\tstruct drm_virtgpu_execbuffer *exbuf = data;\n\tstruct virtio_gpu_submit submit;\n\tu32 ring_idx = 0;\n\tint ret = -EINVAL;\n\n\tif (!vgdev->has_virgl_3d)\n\t\treturn -ENOSYS;\n\n\tif (exbuf->flags & ~VIRTGPU_EXECBUF_FLAGS)\n\t\treturn ret;\n\n\tif (exbuf->flags & VIRTGPU_EXECBUF_RING_IDX) {\n\t\tif (exbuf->ring_idx >= vfpriv->num_rings)\n\t\t\treturn ret;\n\n\t\tif (!vfpriv->base_fence_ctx)\n\t\t\treturn ret;\n\n\t\tfence_ctx = vfpriv->base_fence_ctx;\n\t\tring_idx = exbuf->ring_idx;\n\t}\n\n\tvirtio_gpu_create_context(dev, file);\n\n\tret = virtio_gpu_init_submit(&submit, exbuf, dev, file,\n\t\t\t\t     fence_ctx, ring_idx);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tret = virtio_gpu_parse_post_deps(&submit);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tret = virtio_gpu_parse_deps(&submit);\n\tif (ret)\n\t\tgoto cleanup;\n\n\t \n\tret = virtio_gpu_wait_in_fence(&submit);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tret = virtio_gpu_lock_buflist(&submit);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tvirtio_gpu_submit(&submit);\n\n\t \n\tvirtio_gpu_install_out_fence_fd(&submit);\n\tvirtio_gpu_process_post_deps(&submit);\n\tvirtio_gpu_complete_submit(&submit);\ncleanup:\n\tvirtio_gpu_cleanup_submit(&submit);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}