{
  "module_name": "virtgpu_vram.c",
  "hash_id": "6ada41a7f3b6164561b4963e59fab2deba041e795c424af930616b35bee23a18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/virtio/virtgpu_vram.c",
  "human_readable_source": "\n#include \"virtgpu_drv.h\"\n\n#include <linux/dma-mapping.h>\n\nstatic void virtio_gpu_vram_free(struct drm_gem_object *obj)\n{\n\tstruct virtio_gpu_object *bo = gem_to_virtio_gpu_obj(obj);\n\tstruct virtio_gpu_device *vgdev = obj->dev->dev_private;\n\tstruct virtio_gpu_object_vram *vram = to_virtio_gpu_vram(bo);\n\tbool unmap;\n\n\tif (bo->created) {\n\t\tspin_lock(&vgdev->host_visible_lock);\n\t\tunmap = drm_mm_node_allocated(&vram->vram_node);\n\t\tspin_unlock(&vgdev->host_visible_lock);\n\n\t\tif (unmap)\n\t\t\tvirtio_gpu_cmd_unmap(vgdev, bo);\n\n\t\tvirtio_gpu_cmd_unref_resource(vgdev, bo);\n\t\tvirtio_gpu_notify(vgdev);\n\t\treturn;\n\t}\n}\n\nstatic const struct vm_operations_struct virtio_gpu_vram_vm_ops = {\n\t.open = drm_gem_vm_open,\n\t.close = drm_gem_vm_close,\n};\n\nstatic int virtio_gpu_vram_mmap(struct drm_gem_object *obj,\n\t\t\t\tstruct vm_area_struct *vma)\n{\n\tint ret;\n\tstruct virtio_gpu_device *vgdev = obj->dev->dev_private;\n\tstruct virtio_gpu_object *bo = gem_to_virtio_gpu_obj(obj);\n\tstruct virtio_gpu_object_vram *vram = to_virtio_gpu_vram(bo);\n\tunsigned long vm_size = vma->vm_end - vma->vm_start;\n\n\tif (!(bo->blob_flags & VIRTGPU_BLOB_FLAG_USE_MAPPABLE))\n\t\treturn -EINVAL;\n\n\twait_event(vgdev->resp_wq, vram->map_state != STATE_INITIALIZING);\n\tif (vram->map_state != STATE_OK)\n\t\treturn -EINVAL;\n\n\tvma->vm_pgoff -= drm_vma_node_start(&obj->vma_node);\n\tvm_flags_set(vma, VM_MIXEDMAP | VM_DONTEXPAND);\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tvma->vm_page_prot = pgprot_decrypted(vma->vm_page_prot);\n\tvma->vm_ops = &virtio_gpu_vram_vm_ops;\n\n\tif (vram->map_info == VIRTIO_GPU_MAP_CACHE_WC)\n\t\tvma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);\n\telse if (vram->map_info == VIRTIO_GPU_MAP_CACHE_UNCACHED)\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t \n\tif (vm_size != vram->vram_node.size)\n\t\treturn -EINVAL;\n\n\tret = io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t vram->vram_node.start >> PAGE_SHIFT,\n\t\t\t\t vm_size, vma->vm_page_prot);\n\treturn ret;\n}\n\nstruct sg_table *virtio_gpu_vram_map_dma_buf(struct virtio_gpu_object *bo,\n\t\t\t\t\t     struct device *dev,\n\t\t\t\t\t     enum dma_data_direction dir)\n{\n\tstruct virtio_gpu_device *vgdev = bo->base.base.dev->dev_private;\n\tstruct virtio_gpu_object_vram *vram = to_virtio_gpu_vram(bo);\n\tstruct sg_table *sgt;\n\tdma_addr_t addr;\n\tint ret;\n\n\tsgt = kzalloc(sizeof(*sgt), GFP_KERNEL);\n\tif (!sgt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(bo->blob_flags & VIRTGPU_BLOB_FLAG_USE_MAPPABLE)) {\n\t\t\n\t\t\n\t\tif (!is_virtio_device(dev) || !vgdev->has_resource_assign_uuid) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\treturn sgt;\n\t}\n\n\tret = sg_alloc_table(sgt, 1, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\n\taddr = dma_map_resource(dev, vram->vram_node.start,\n\t\t\t\tvram->vram_node.size, dir,\n\t\t\t\tDMA_ATTR_SKIP_CPU_SYNC);\n\tret = dma_mapping_error(dev, addr);\n\tif (ret)\n\t\tgoto out;\n\n\tsg_set_page(sgt->sgl, NULL, vram->vram_node.size, 0);\n\tsg_dma_address(sgt->sgl) = addr;\n\tsg_dma_len(sgt->sgl) = vram->vram_node.size;\n\n\treturn sgt;\nout:\n\tsg_free_table(sgt);\n\tkfree(sgt);\n\treturn ERR_PTR(ret);\n}\n\nvoid virtio_gpu_vram_unmap_dma_buf(struct device *dev,\n\t\t\t\t   struct sg_table *sgt,\n\t\t\t\t   enum dma_data_direction dir)\n{\n\tif (sgt->nents) {\n\t\tdma_unmap_resource(dev, sg_dma_address(sgt->sgl),\n\t\t\t\t   sg_dma_len(sgt->sgl), dir,\n\t\t\t\t   DMA_ATTR_SKIP_CPU_SYNC);\n\t}\n\tsg_free_table(sgt);\n\tkfree(sgt);\n}\n\nstatic const struct drm_gem_object_funcs virtio_gpu_vram_funcs = {\n\t.open = virtio_gpu_gem_object_open,\n\t.close = virtio_gpu_gem_object_close,\n\t.free = virtio_gpu_vram_free,\n\t.mmap = virtio_gpu_vram_mmap,\n\t.export = virtgpu_gem_prime_export,\n};\n\nbool virtio_gpu_is_vram(struct virtio_gpu_object *bo)\n{\n\treturn bo->base.base.funcs == &virtio_gpu_vram_funcs;\n}\n\nstatic int virtio_gpu_vram_map(struct virtio_gpu_object *bo)\n{\n\tint ret;\n\tuint64_t offset;\n\tstruct virtio_gpu_object_array *objs;\n\tstruct virtio_gpu_device *vgdev = bo->base.base.dev->dev_private;\n\tstruct virtio_gpu_object_vram *vram = to_virtio_gpu_vram(bo);\n\n\tif (!vgdev->has_host_visible)\n\t\treturn -EINVAL;\n\n\tspin_lock(&vgdev->host_visible_lock);\n\tret = drm_mm_insert_node(&vgdev->host_visible_mm, &vram->vram_node,\n\t\t\t\t bo->base.base.size);\n\tspin_unlock(&vgdev->host_visible_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tobjs = virtio_gpu_array_alloc(1);\n\tif (!objs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_remove_node;\n\t}\n\n\tvirtio_gpu_array_add_obj(objs, &bo->base.base);\n\t \n\toffset = vram->vram_node.start - vgdev->host_visible_region.addr;\n\n\tret = virtio_gpu_cmd_map(vgdev, objs, offset);\n\tif (ret) {\n\t\tvirtio_gpu_array_put_free(objs);\n\t\tgoto err_remove_node;\n\t}\n\n\treturn 0;\n\nerr_remove_node:\n\tspin_lock(&vgdev->host_visible_lock);\n\tdrm_mm_remove_node(&vram->vram_node);\n\tspin_unlock(&vgdev->host_visible_lock);\n\treturn ret;\n}\n\nint virtio_gpu_vram_create(struct virtio_gpu_device *vgdev,\n\t\t\t   struct virtio_gpu_object_params *params,\n\t\t\t   struct virtio_gpu_object **bo_ptr)\n{\n\tstruct drm_gem_object *obj;\n\tstruct virtio_gpu_object_vram *vram;\n\tint ret;\n\n\tvram = kzalloc(sizeof(*vram), GFP_KERNEL);\n\tif (!vram)\n\t\treturn -ENOMEM;\n\n\tobj = &vram->base.base.base;\n\tobj->funcs = &virtio_gpu_vram_funcs;\n\n\tparams->size = PAGE_ALIGN(params->size);\n\tdrm_gem_private_object_init(vgdev->ddev, obj, params->size);\n\n\t \n\tret = drm_gem_create_mmap_offset(obj);\n\tif (ret) {\n\t\tkfree(vram);\n\t\treturn ret;\n\t}\n\n\tret = virtio_gpu_resource_id_get(vgdev, &vram->base.hw_res_handle);\n\tif (ret) {\n\t\tkfree(vram);\n\t\treturn ret;\n\t}\n\n\tvirtio_gpu_cmd_resource_create_blob(vgdev, &vram->base, params, NULL,\n\t\t\t\t\t    0);\n\tif (params->blob_flags & VIRTGPU_BLOB_FLAG_USE_MAPPABLE) {\n\t\tret = virtio_gpu_vram_map(&vram->base);\n\t\tif (ret) {\n\t\t\tvirtio_gpu_vram_free(obj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t*bo_ptr = &vram->base;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}