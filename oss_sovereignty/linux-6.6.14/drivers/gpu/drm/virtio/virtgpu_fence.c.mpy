{
  "module_name": "virtgpu_fence.c",
  "hash_id": "981e1b1b5b772c36578b003d222e1b8786d17bd7ea4e4cff6fa99dd30c9ed811",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/virtio/virtgpu_fence.c",
  "human_readable_source": " \n\n#include <trace/events/dma_fence.h>\n\n#include \"virtgpu_drv.h\"\n\n#define to_virtio_gpu_fence(x) \\\n\tcontainer_of(x, struct virtio_gpu_fence, f)\n\nstatic const char *virtio_gpu_get_driver_name(struct dma_fence *f)\n{\n\treturn \"virtio_gpu\";\n}\n\nstatic const char *virtio_gpu_get_timeline_name(struct dma_fence *f)\n{\n\treturn \"controlq\";\n}\n\nstatic bool virtio_gpu_fence_signaled(struct dma_fence *f)\n{\n\t \n\tWARN_ON_ONCE(f->seqno == 0);\n\treturn false;\n}\n\nstatic void virtio_gpu_fence_value_str(struct dma_fence *f, char *str, int size)\n{\n\tsnprintf(str, size, \"[%llu, %llu]\", f->context, f->seqno);\n}\n\nstatic void virtio_gpu_timeline_value_str(struct dma_fence *f, char *str,\n\t\t\t\t\t  int size)\n{\n\tstruct virtio_gpu_fence *fence = to_virtio_gpu_fence(f);\n\n\tsnprintf(str, size, \"%llu\",\n\t\t (u64)atomic64_read(&fence->drv->last_fence_id));\n}\n\nstatic const struct dma_fence_ops virtio_gpu_fence_ops = {\n\t.get_driver_name     = virtio_gpu_get_driver_name,\n\t.get_timeline_name   = virtio_gpu_get_timeline_name,\n\t.signaled            = virtio_gpu_fence_signaled,\n\t.fence_value_str     = virtio_gpu_fence_value_str,\n\t.timeline_value_str  = virtio_gpu_timeline_value_str,\n};\n\nstruct virtio_gpu_fence *virtio_gpu_fence_alloc(struct virtio_gpu_device *vgdev,\n\t\t\t\t\t\tuint64_t base_fence_ctx,\n\t\t\t\t\t\tuint32_t ring_idx)\n{\n\tuint64_t fence_context = base_fence_ctx + ring_idx;\n\tstruct virtio_gpu_fence_driver *drv = &vgdev->fence_drv;\n\tstruct virtio_gpu_fence *fence = kzalloc(sizeof(struct virtio_gpu_fence),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (!fence)\n\t\treturn fence;\n\n\tfence->drv = drv;\n\tfence->ring_idx = ring_idx;\n\tfence->emit_fence_info = !(base_fence_ctx == drv->context);\n\n\t \n\n\tdma_fence_init(&fence->f, &virtio_gpu_fence_ops, &drv->lock,\n\t\t       fence_context, 0);\n\n\treturn fence;\n}\n\nvoid virtio_gpu_fence_emit(struct virtio_gpu_device *vgdev,\n\t\t\t  struct virtio_gpu_ctrl_hdr *cmd_hdr,\n\t\t\t  struct virtio_gpu_fence *fence)\n{\n\tstruct virtio_gpu_fence_driver *drv = &vgdev->fence_drv;\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(&drv->lock, irq_flags);\n\tfence->fence_id = fence->f.seqno = ++drv->current_fence_id;\n\tdma_fence_get(&fence->f);\n\tlist_add_tail(&fence->node, &drv->fences);\n\tspin_unlock_irqrestore(&drv->lock, irq_flags);\n\n\ttrace_dma_fence_emit(&fence->f);\n\n\tcmd_hdr->flags |= cpu_to_le32(VIRTIO_GPU_FLAG_FENCE);\n\tcmd_hdr->fence_id = cpu_to_le64(fence->fence_id);\n\n\t \n\tif (fence->emit_fence_info) {\n\t\tcmd_hdr->flags |=\n\t\t\tcpu_to_le32(VIRTIO_GPU_FLAG_INFO_RING_IDX);\n\t\tcmd_hdr->ring_idx = (u8)fence->ring_idx;\n\t}\n}\n\nvoid virtio_gpu_fence_event_process(struct virtio_gpu_device *vgdev,\n\t\t\t\t    u64 fence_id)\n{\n\tstruct virtio_gpu_fence_driver *drv = &vgdev->fence_drv;\n\tstruct virtio_gpu_fence *signaled, *curr, *tmp;\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(&drv->lock, irq_flags);\n\tatomic64_set(&vgdev->fence_drv.last_fence_id, fence_id);\n\tlist_for_each_entry_safe(curr, tmp, &drv->fences, node) {\n\t\tif (fence_id != curr->fence_id)\n\t\t\tcontinue;\n\n\t\tsignaled = curr;\n\n\t\t \n\t\tlist_for_each_entry_safe(curr, tmp, &drv->fences, node) {\n\t\t\t \n\t\t\tif (signaled->f.context != curr->f.context)\n\t\t\t\tcontinue;\n\n\t\t\tif (!dma_fence_is_later(&signaled->f, &curr->f))\n\t\t\t\tcontinue;\n\n\t\t\tdma_fence_signal_locked(&curr->f);\n\t\t\tif (curr->e) {\n\t\t\t\tdrm_send_event(vgdev->ddev, &curr->e->base);\n\t\t\t\tcurr->e = NULL;\n\t\t\t}\n\n\t\t\tlist_del(&curr->node);\n\t\t\tdma_fence_put(&curr->f);\n\t\t}\n\n\t\tdma_fence_signal_locked(&signaled->f);\n\t\tif (signaled->e) {\n\t\t\tdrm_send_event(vgdev->ddev, &signaled->e->base);\n\t\t\tsignaled->e = NULL;\n\t\t}\n\n\t\tlist_del(&signaled->node);\n\t\tdma_fence_put(&signaled->f);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&drv->lock, irq_flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}