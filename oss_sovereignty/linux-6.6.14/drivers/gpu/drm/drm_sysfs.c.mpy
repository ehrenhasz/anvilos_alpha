{
  "module_name": "drm_sysfs.c",
  "hash_id": "5ceb3196011a8ab87561877eb2ee2105bad65f516ba84fba56cad534440421fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_sysfs.c",
  "human_readable_source": "\n\n \n\n#include <linux/acpi.h>\n#include <linux/component.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/i2c.h>\n#include <linux/kdev_t.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include <drm/drm_accel.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_print.h>\n#include <drm/drm_property.h>\n#include <drm/drm_sysfs.h>\n\n#include \"drm_internal.h\"\n#include \"drm_crtc_internal.h\"\n\n#define to_drm_minor(d) dev_get_drvdata(d)\n#define to_drm_connector(d) dev_get_drvdata(d)\n\n \n\nstatic struct device_type drm_sysfs_device_minor = {\n\t.name = \"drm_minor\"\n};\n\nstatic struct device_type drm_sysfs_device_connector = {\n\t.name = \"drm_connector\",\n};\n\nstruct class *drm_class;\n\n#ifdef CONFIG_ACPI\nstatic bool drm_connector_acpi_bus_match(struct device *dev)\n{\n\treturn dev->type == &drm_sysfs_device_connector;\n}\n\nstatic struct acpi_device *drm_connector_acpi_find_companion(struct device *dev)\n{\n\tstruct drm_connector *connector = to_drm_connector(dev);\n\n\treturn to_acpi_device_node(connector->fwnode);\n}\n\nstatic struct acpi_bus_type drm_connector_acpi_bus = {\n\t.name = \"drm_connector\",\n\t.match = drm_connector_acpi_bus_match,\n\t.find_companion = drm_connector_acpi_find_companion,\n};\n\nstatic void drm_sysfs_acpi_register(void)\n{\n\tregister_acpi_bus_type(&drm_connector_acpi_bus);\n}\n\nstatic void drm_sysfs_acpi_unregister(void)\n{\n\tunregister_acpi_bus_type(&drm_connector_acpi_bus);\n}\n#else\nstatic void drm_sysfs_acpi_register(void) { }\nstatic void drm_sysfs_acpi_unregister(void) { }\n#endif\n\nstatic char *drm_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"dri/%s\", dev_name(dev));\n}\n\nstatic int typec_connector_bind(struct device *dev,\n\t\t\t\tstruct device *typec_connector, void *data)\n{\n\tint ret;\n\n\tret = sysfs_create_link(&dev->kobj, &typec_connector->kobj, \"typec_connector\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_create_link(&typec_connector->kobj, &dev->kobj, \"drm_connector\");\n\tif (ret)\n\t\tsysfs_remove_link(&dev->kobj, \"typec_connector\");\n\n\treturn ret;\n}\n\nstatic void typec_connector_unbind(struct device *dev,\n\t\t\t\t   struct device *typec_connector, void *data)\n{\n\tsysfs_remove_link(&typec_connector->kobj, \"drm_connector\");\n\tsysfs_remove_link(&dev->kobj, \"typec_connector\");\n}\n\nstatic const struct component_ops typec_connector_ops = {\n\t.bind = typec_connector_bind,\n\t.unbind = typec_connector_unbind,\n};\n\nstatic CLASS_ATTR_STRING(version, S_IRUGO, \"drm 1.1.0 20060810\");\n\n \nint drm_sysfs_init(void)\n{\n\tint err;\n\n\tdrm_class = class_create(\"drm\");\n\tif (IS_ERR(drm_class))\n\t\treturn PTR_ERR(drm_class);\n\n\terr = class_create_file(drm_class, &class_attr_version.attr);\n\tif (err) {\n\t\tclass_destroy(drm_class);\n\t\tdrm_class = NULL;\n\t\treturn err;\n\t}\n\n\tdrm_class->devnode = drm_devnode;\n\n\tdrm_sysfs_acpi_register();\n\treturn 0;\n}\n\n \nvoid drm_sysfs_destroy(void)\n{\n\tif (IS_ERR_OR_NULL(drm_class))\n\t\treturn;\n\tdrm_sysfs_acpi_unregister();\n\tclass_remove_file(drm_class, &class_attr_version.attr);\n\tclass_destroy(drm_class);\n\tdrm_class = NULL;\n}\n\nstatic void drm_sysfs_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\n \nstatic ssize_t status_store(struct device *device,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct drm_connector *connector = to_drm_connector(device);\n\tstruct drm_device *dev = connector->dev;\n\tenum drm_connector_force old_force;\n\tint ret;\n\n\tret = mutex_lock_interruptible(&dev->mode_config.mutex);\n\tif (ret)\n\t\treturn ret;\n\n\told_force = connector->force;\n\n\tif (sysfs_streq(buf, \"detect\"))\n\t\tconnector->force = 0;\n\telse if (sysfs_streq(buf, \"on\"))\n\t\tconnector->force = DRM_FORCE_ON;\n\telse if (sysfs_streq(buf, \"on-digital\"))\n\t\tconnector->force = DRM_FORCE_ON_DIGITAL;\n\telse if (sysfs_streq(buf, \"off\"))\n\t\tconnector->force = DRM_FORCE_OFF;\n\telse\n\t\tret = -EINVAL;\n\n\tif (old_force != connector->force || !connector->force) {\n\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s] force updated from %d to %d or reprobing\\n\",\n\t\t\t      connector->base.id,\n\t\t\t      connector->name,\n\t\t\t      old_force, connector->force);\n\n\t\tconnector->funcs->fill_modes(connector,\n\t\t\t\t\t     dev->mode_config.max_width,\n\t\t\t\t\t     dev->mode_config.max_height);\n\t}\n\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t status_show(struct device *device,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct drm_connector *connector = to_drm_connector(device);\n\tenum drm_connector_status status;\n\n\tstatus = READ_ONCE(connector->status);\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t  drm_get_connector_status_name(status));\n}\n\nstatic ssize_t dpms_show(struct device *device,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct drm_connector *connector = to_drm_connector(device);\n\tint dpms;\n\n\tdpms = READ_ONCE(connector->dpms);\n\n\treturn sysfs_emit(buf, \"%s\\n\", drm_get_dpms_name(dpms));\n}\n\nstatic ssize_t enabled_show(struct device *device,\n\t\t\t    struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct drm_connector *connector = to_drm_connector(device);\n\tbool enabled;\n\n\tenabled = READ_ONCE(connector->encoder);\n\n\treturn sysfs_emit(buf, enabled ? \"enabled\\n\" : \"disabled\\n\");\n}\n\nstatic ssize_t edid_show(struct file *filp, struct kobject *kobj,\n\t\t\t struct bin_attribute *attr, char *buf, loff_t off,\n\t\t\t size_t count)\n{\n\tstruct device *connector_dev = kobj_to_dev(kobj);\n\tstruct drm_connector *connector = to_drm_connector(connector_dev);\n\tunsigned char *edid;\n\tsize_t size;\n\tssize_t ret = 0;\n\n\tmutex_lock(&connector->dev->mode_config.mutex);\n\tif (!connector->edid_blob_ptr)\n\t\tgoto unlock;\n\n\tedid = connector->edid_blob_ptr->data;\n\tsize = connector->edid_blob_ptr->length;\n\tif (!edid)\n\t\tgoto unlock;\n\n\tif (off >= size)\n\t\tgoto unlock;\n\n\tif (off + count > size)\n\t\tcount = size - off;\n\tmemcpy(buf, edid + off, count);\n\n\tret = count;\nunlock:\n\tmutex_unlock(&connector->dev->mode_config.mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t modes_show(struct device *device,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct drm_connector *connector = to_drm_connector(device);\n\tstruct drm_display_mode *mode;\n\tint written = 0;\n\n\tmutex_lock(&connector->dev->mode_config.mutex);\n\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\twritten += scnprintf(buf + written, PAGE_SIZE - written, \"%s\\n\",\n\t\t\t\t    mode->name);\n\t}\n\tmutex_unlock(&connector->dev->mode_config.mutex);\n\n\treturn written;\n}\n\nstatic ssize_t connector_id_show(struct device *device,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct drm_connector *connector = to_drm_connector(device);\n\n\treturn sysfs_emit(buf, \"%d\\n\", connector->base.id);\n}\n\nstatic DEVICE_ATTR_RW(status);\nstatic DEVICE_ATTR_RO(enabled);\nstatic DEVICE_ATTR_RO(dpms);\nstatic DEVICE_ATTR_RO(modes);\nstatic DEVICE_ATTR_RO(connector_id);\n\nstatic struct attribute *connector_dev_attrs[] = {\n\t&dev_attr_status.attr,\n\t&dev_attr_enabled.attr,\n\t&dev_attr_dpms.attr,\n\t&dev_attr_modes.attr,\n\t&dev_attr_connector_id.attr,\n\tNULL\n};\n\nstatic struct bin_attribute edid_attr = {\n\t.attr.name = \"edid\",\n\t.attr.mode = 0444,\n\t.size = 0,\n\t.read = edid_show,\n};\n\nstatic struct bin_attribute *connector_bin_attrs[] = {\n\t&edid_attr,\n\tNULL\n};\n\nstatic const struct attribute_group connector_dev_group = {\n\t.attrs = connector_dev_attrs,\n\t.bin_attrs = connector_bin_attrs,\n};\n\nstatic const struct attribute_group *connector_dev_groups[] = {\n\t&connector_dev_group,\n\tNULL\n};\n\nint drm_sysfs_connector_add(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct device *kdev;\n\tint r;\n\n\tif (connector->kdev)\n\t\treturn 0;\n\n\tkdev = kzalloc(sizeof(*kdev), GFP_KERNEL);\n\tif (!kdev)\n\t\treturn -ENOMEM;\n\n\tdevice_initialize(kdev);\n\tkdev->class = drm_class;\n\tkdev->type = &drm_sysfs_device_connector;\n\tkdev->parent = dev->primary->kdev;\n\tkdev->groups = connector_dev_groups;\n\tkdev->release = drm_sysfs_release;\n\tdev_set_drvdata(kdev, connector);\n\n\tr = dev_set_name(kdev, \"card%d-%s\", dev->primary->index, connector->name);\n\tif (r)\n\t\tgoto err_free;\n\n\tDRM_DEBUG(\"adding \\\"%s\\\" to sysfs\\n\",\n\t\t  connector->name);\n\n\tr = device_add(kdev);\n\tif (r) {\n\t\tdrm_err(dev, \"failed to register connector device: %d\\n\", r);\n\t\tgoto err_free;\n\t}\n\n\tconnector->kdev = kdev;\n\n\tif (dev_fwnode(kdev)) {\n\t\tr = component_add(kdev, &typec_connector_ops);\n\t\tif (r)\n\t\t\tdrm_err(dev, \"failed to add component to create link to typec connector\\n\");\n\t}\n\n\tif (connector->ddc)\n\t\treturn sysfs_create_link(&connector->kdev->kobj,\n\t\t\t\t &connector->ddc->dev.kobj, \"ddc\");\n\n\treturn 0;\n\nerr_free:\n\tput_device(kdev);\n\treturn r;\n}\n\nvoid drm_sysfs_connector_remove(struct drm_connector *connector)\n{\n\tif (!connector->kdev)\n\t\treturn;\n\n\tif (connector->ddc)\n\t\tsysfs_remove_link(&connector->kdev->kobj, \"ddc\");\n\n\tif (dev_fwnode(connector->kdev))\n\t\tcomponent_del(connector->kdev, &typec_connector_ops);\n\n\tDRM_DEBUG(\"removing \\\"%s\\\" from sysfs\\n\",\n\t\t  connector->name);\n\n\tdevice_unregister(connector->kdev);\n\tconnector->kdev = NULL;\n}\n\nvoid drm_sysfs_lease_event(struct drm_device *dev)\n{\n\tchar *event_string = \"LEASE=1\";\n\tchar *envp[] = { event_string, NULL };\n\n\tDRM_DEBUG(\"generating lease event\\n\");\n\n\tkobject_uevent_env(&dev->primary->kdev->kobj, KOBJ_CHANGE, envp);\n}\n\n \nvoid drm_sysfs_hotplug_event(struct drm_device *dev)\n{\n\tchar *event_string = \"HOTPLUG=1\";\n\tchar *envp[] = { event_string, NULL };\n\n\tDRM_DEBUG(\"generating hotplug event\\n\");\n\n\tkobject_uevent_env(&dev->primary->kdev->kobj, KOBJ_CHANGE, envp);\n}\nEXPORT_SYMBOL(drm_sysfs_hotplug_event);\n\n \nvoid drm_sysfs_connector_hotplug_event(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tchar hotplug_str[] = \"HOTPLUG=1\", conn_id[21];\n\tchar *envp[] = { hotplug_str, conn_id, NULL };\n\n\tsnprintf(conn_id, sizeof(conn_id),\n\t\t \"CONNECTOR=%u\", connector->base.id);\n\n\tdrm_dbg_kms(connector->dev,\n\t\t    \"[CONNECTOR:%d:%s] generating connector hotplug event\\n\",\n\t\t    connector->base.id, connector->name);\n\n\tkobject_uevent_env(&dev->primary->kdev->kobj, KOBJ_CHANGE, envp);\n}\nEXPORT_SYMBOL(drm_sysfs_connector_hotplug_event);\n\n \nvoid drm_sysfs_connector_property_event(struct drm_connector *connector,\n\t\t\t\t\tstruct drm_property *property)\n{\n\tstruct drm_device *dev = connector->dev;\n\tchar hotplug_str[] = \"HOTPLUG=1\", conn_id[21], prop_id[21];\n\tchar *envp[4] = { hotplug_str, conn_id, prop_id, NULL };\n\n\tWARN_ON(!drm_mode_obj_find_prop_id(&connector->base,\n\t\t\t\t\t   property->base.id));\n\n\tsnprintf(conn_id, ARRAY_SIZE(conn_id),\n\t\t \"CONNECTOR=%u\", connector->base.id);\n\tsnprintf(prop_id, ARRAY_SIZE(prop_id),\n\t\t \"PROPERTY=%u\", property->base.id);\n\n\tdrm_dbg_kms(connector->dev,\n\t\t    \"[CONNECTOR:%d:%s] generating connector property event for [PROP:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    property->base.id, property->name);\n\n\tkobject_uevent_env(&dev->primary->kdev->kobj, KOBJ_CHANGE, envp);\n}\nEXPORT_SYMBOL(drm_sysfs_connector_property_event);\n\nstruct device *drm_sysfs_minor_alloc(struct drm_minor *minor)\n{\n\tconst char *minor_str;\n\tstruct device *kdev;\n\tint r;\n\n\tkdev = kzalloc(sizeof(*kdev), GFP_KERNEL);\n\tif (!kdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdevice_initialize(kdev);\n\n\tif (minor->type == DRM_MINOR_ACCEL) {\n\t\tminor_str = \"accel%d\";\n\t\taccel_set_device_instance_params(kdev, minor->index);\n\t} else {\n\t\tif (minor->type == DRM_MINOR_RENDER)\n\t\t\tminor_str = \"renderD%d\";\n\t\telse\n\t\t\tminor_str = \"card%d\";\n\n\t\tkdev->devt = MKDEV(DRM_MAJOR, minor->index);\n\t\tkdev->class = drm_class;\n\t\tkdev->type = &drm_sysfs_device_minor;\n\t}\n\n\tkdev->parent = minor->dev->dev;\n\tkdev->release = drm_sysfs_release;\n\tdev_set_drvdata(kdev, minor);\n\n\tr = dev_set_name(kdev, minor_str, minor->index);\n\tif (r < 0)\n\t\tgoto err_free;\n\n\treturn kdev;\n\nerr_free:\n\tput_device(kdev);\n\treturn ERR_PTR(r);\n}\n\n \nint drm_class_device_register(struct device *dev)\n{\n\tif (!drm_class || IS_ERR(drm_class))\n\t\treturn -ENOENT;\n\n\tdev->class = drm_class;\n\treturn device_register(dev);\n}\nEXPORT_SYMBOL_GPL(drm_class_device_register);\n\n \nvoid drm_class_device_unregister(struct device *dev)\n{\n\treturn device_unregister(dev);\n}\nEXPORT_SYMBOL_GPL(drm_class_device_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}