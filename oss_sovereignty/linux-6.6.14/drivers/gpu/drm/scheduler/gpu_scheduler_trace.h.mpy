{
  "module_name": "gpu_scheduler_trace.h",
  "hash_id": "9961ae2a8133b883199035dafb574da9552576c67f6e3df10d7602562ccc1a75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/scheduler/gpu_scheduler_trace.h",
  "human_readable_source": " \n\n#if !defined(_GPU_SCHED_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _GPU_SCHED_TRACE_H_\n\n#include <linux/stringify.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM gpu_scheduler\n#define TRACE_INCLUDE_FILE gpu_scheduler_trace\n\nDECLARE_EVENT_CLASS(drm_sched_job,\n\t    TP_PROTO(struct drm_sched_job *sched_job, struct drm_sched_entity *entity),\n\t    TP_ARGS(sched_job, entity),\n\t    TP_STRUCT__entry(\n\t\t\t     __field(struct drm_sched_entity *, entity)\n\t\t\t     __field(struct dma_fence *, fence)\n\t\t\t     __string(name, sched_job->sched->name)\n\t\t\t     __field(uint64_t, id)\n\t\t\t     __field(u32, job_count)\n\t\t\t     __field(int, hw_job_count)\n\t\t\t     ),\n\n\t    TP_fast_assign(\n\t\t\t   __entry->entity = entity;\n\t\t\t   __entry->id = sched_job->id;\n\t\t\t   __entry->fence = &sched_job->s_fence->finished;\n\t\t\t   __assign_str(name, sched_job->sched->name);\n\t\t\t   __entry->job_count = spsc_queue_count(&entity->job_queue);\n\t\t\t   __entry->hw_job_count = atomic_read(\n\t\t\t\t   &sched_job->sched->hw_rq_count);\n\t\t\t   ),\n\t    TP_printk(\"entity=%p, id=%llu, fence=%p, ring=%s, job count:%u, hw job count:%d\",\n\t\t      __entry->entity, __entry->id,\n\t\t      __entry->fence, __get_str(name),\n\t\t      __entry->job_count, __entry->hw_job_count)\n);\n\nDEFINE_EVENT(drm_sched_job, drm_sched_job,\n\t    TP_PROTO(struct drm_sched_job *sched_job, struct drm_sched_entity *entity),\n\t    TP_ARGS(sched_job, entity)\n);\n\nDEFINE_EVENT(drm_sched_job, drm_run_job,\n\t    TP_PROTO(struct drm_sched_job *sched_job, struct drm_sched_entity *entity),\n\t    TP_ARGS(sched_job, entity)\n);\n\nTRACE_EVENT(drm_sched_process_job,\n\t    TP_PROTO(struct drm_sched_fence *fence),\n\t    TP_ARGS(fence),\n\t    TP_STRUCT__entry(\n\t\t    __field(struct dma_fence *, fence)\n\t\t    ),\n\n\t    TP_fast_assign(\n\t\t    __entry->fence = &fence->finished;\n\t\t    ),\n\t    TP_printk(\"fence=%p signaled\", __entry->fence)\n);\n\nTRACE_EVENT(drm_sched_job_wait_dep,\n\t    TP_PROTO(struct drm_sched_job *sched_job, struct dma_fence *fence),\n\t    TP_ARGS(sched_job, fence),\n\t    TP_STRUCT__entry(\n\t\t\t     __string(name, sched_job->sched->name)\n\t\t\t     __field(uint64_t, id)\n\t\t\t     __field(struct dma_fence *, fence)\n\t\t\t     __field(uint64_t, ctx)\n\t\t\t     __field(unsigned, seqno)\n\t\t\t     ),\n\n\t    TP_fast_assign(\n\t\t\t   __assign_str(name, sched_job->sched->name);\n\t\t\t   __entry->id = sched_job->id;\n\t\t\t   __entry->fence = fence;\n\t\t\t   __entry->ctx = fence->context;\n\t\t\t   __entry->seqno = fence->seqno;\n\t\t\t   ),\n\t    TP_printk(\"job ring=%s, id=%llu, depends fence=%p, context=%llu, seq=%u\",\n\t\t      __get_str(name), __entry->id,\n\t\t      __entry->fence, __entry->ctx,\n\t\t      __entry->seqno)\n);\n\n#endif\n\n \n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH ../../drivers/gpu/drm/scheduler\n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}