{
  "module_name": "xen_drm_front_evtchnl.c",
  "hash_id": "aa2ddb2cdfe00fac24159d0a93dc027e59c580601b121013cf74e80464718e3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/xen/xen_drm_front_evtchnl.c",
  "human_readable_source": "\n\n \n\n#include <linux/errno.h>\n#include <linux/irq.h>\n\n#include <drm/drm_print.h>\n\n#include <xen/xenbus.h>\n#include <xen/events.h>\n#include <xen/grant_table.h>\n\n#include \"xen_drm_front.h\"\n#include \"xen_drm_front_evtchnl.h\"\n\nstatic irqreturn_t evtchnl_interrupt_ctrl(int irq, void *dev_id)\n{\n\tstruct xen_drm_front_evtchnl *evtchnl = dev_id;\n\tstruct xen_drm_front_info *front_info = evtchnl->front_info;\n\tstruct xendispl_resp *resp;\n\tRING_IDX i, rp;\n\tunsigned long flags;\n\n\tif (unlikely(evtchnl->state != EVTCHNL_STATE_CONNECTED))\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock_irqsave(&front_info->io_lock, flags);\n\nagain:\n\trp = evtchnl->u.req.ring.sring->rsp_prod;\n\t \n\tvirt_rmb();\n\n\tfor (i = evtchnl->u.req.ring.rsp_cons; i != rp; i++) {\n\t\tresp = RING_GET_RESPONSE(&evtchnl->u.req.ring, i);\n\t\tif (unlikely(resp->id != evtchnl->evt_id))\n\t\t\tcontinue;\n\n\t\tswitch (resp->operation) {\n\t\tcase XENDISPL_OP_PG_FLIP:\n\t\tcase XENDISPL_OP_FB_ATTACH:\n\t\tcase XENDISPL_OP_FB_DETACH:\n\t\tcase XENDISPL_OP_DBUF_CREATE:\n\t\tcase XENDISPL_OP_DBUF_DESTROY:\n\t\tcase XENDISPL_OP_SET_CONFIG:\n\t\t\tevtchnl->u.req.resp_status = resp->status;\n\t\t\tcomplete(&evtchnl->u.req.completion);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Operation %d is not supported\\n\",\n\t\t\t\t  resp->operation);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tevtchnl->u.req.ring.rsp_cons = i;\n\n\tif (i != evtchnl->u.req.ring.req_prod_pvt) {\n\t\tint more_to_do;\n\n\t\tRING_FINAL_CHECK_FOR_RESPONSES(&evtchnl->u.req.ring,\n\t\t\t\t\t       more_to_do);\n\t\tif (more_to_do)\n\t\t\tgoto again;\n\t} else {\n\t\tevtchnl->u.req.ring.sring->rsp_event = i + 1;\n\t}\n\n\tspin_unlock_irqrestore(&front_info->io_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t evtchnl_interrupt_evt(int irq, void *dev_id)\n{\n\tstruct xen_drm_front_evtchnl *evtchnl = dev_id;\n\tstruct xen_drm_front_info *front_info = evtchnl->front_info;\n\tstruct xendispl_event_page *page = evtchnl->u.evt.page;\n\tu32 cons, prod;\n\tunsigned long flags;\n\n\tif (unlikely(evtchnl->state != EVTCHNL_STATE_CONNECTED))\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock_irqsave(&front_info->io_lock, flags);\n\n\tprod = page->in_prod;\n\t \n\tvirt_rmb();\n\tif (prod == page->in_cons)\n\t\tgoto out;\n\n\tfor (cons = page->in_cons; cons != prod; cons++) {\n\t\tstruct xendispl_evt *event;\n\n\t\tevent = &XENDISPL_IN_RING_REF(page, cons);\n\t\tif (unlikely(event->id != evtchnl->evt_id++))\n\t\t\tcontinue;\n\n\t\tswitch (event->type) {\n\t\tcase XENDISPL_EVT_PG_FLIP:\n\t\t\txen_drm_front_on_frame_done(front_info, evtchnl->index,\n\t\t\t\t\t\t    event->op.pg_flip.fb_cookie);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpage->in_cons = cons;\n\t \n\tvirt_wmb();\n\nout:\n\tspin_unlock_irqrestore(&front_info->io_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic void evtchnl_free(struct xen_drm_front_info *front_info,\n\t\t\t struct xen_drm_front_evtchnl *evtchnl)\n{\n\tvoid *page = NULL;\n\n\tif (evtchnl->type == EVTCHNL_TYPE_REQ)\n\t\tpage = evtchnl->u.req.ring.sring;\n\telse if (evtchnl->type == EVTCHNL_TYPE_EVT)\n\t\tpage = evtchnl->u.evt.page;\n\tif (!page)\n\t\treturn;\n\n\tevtchnl->state = EVTCHNL_STATE_DISCONNECTED;\n\n\tif (evtchnl->type == EVTCHNL_TYPE_REQ) {\n\t\t \n\t\tevtchnl->u.req.resp_status = -EIO;\n\t\tcomplete_all(&evtchnl->u.req.completion);\n\t}\n\n\tif (evtchnl->irq)\n\t\tunbind_from_irqhandler(evtchnl->irq, evtchnl);\n\n\tif (evtchnl->port)\n\t\txenbus_free_evtchn(front_info->xb_dev, evtchnl->port);\n\n\t \n\txenbus_teardown_ring(&page, 1, &evtchnl->gref);\n\n\tmemset(evtchnl, 0, sizeof(*evtchnl));\n}\n\nstatic int evtchnl_alloc(struct xen_drm_front_info *front_info, int index,\n\t\t\t struct xen_drm_front_evtchnl *evtchnl,\n\t\t\t enum xen_drm_front_evtchnl_type type)\n{\n\tstruct xenbus_device *xb_dev = front_info->xb_dev;\n\tvoid *page;\n\tirq_handler_t handler;\n\tint ret;\n\n\tmemset(evtchnl, 0, sizeof(*evtchnl));\n\tevtchnl->type = type;\n\tevtchnl->index = index;\n\tevtchnl->front_info = front_info;\n\tevtchnl->state = EVTCHNL_STATE_DISCONNECTED;\n\n\tret = xenbus_setup_ring(xb_dev, GFP_NOIO | __GFP_HIGH, &page,\n\t\t\t\t1, &evtchnl->gref);\n\tif (ret)\n\t\tgoto fail;\n\n\tif (type == EVTCHNL_TYPE_REQ) {\n\t\tstruct xen_displif_sring *sring;\n\n\t\tinit_completion(&evtchnl->u.req.completion);\n\t\tmutex_init(&evtchnl->u.req.req_io_lock);\n\t\tsring = page;\n\t\tXEN_FRONT_RING_INIT(&evtchnl->u.req.ring, sring, XEN_PAGE_SIZE);\n\n\t\thandler = evtchnl_interrupt_ctrl;\n\t} else {\n\t\tevtchnl->u.evt.page = page;\n\t\thandler = evtchnl_interrupt_evt;\n\t}\n\n\tret = xenbus_alloc_evtchn(xb_dev, &evtchnl->port);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = bind_evtchn_to_irqhandler(evtchnl->port,\n\t\t\t\t\thandler, 0, xb_dev->devicetype,\n\t\t\t\t\tevtchnl);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tevtchnl->irq = ret;\n\treturn 0;\n\nfail:\n\tDRM_ERROR(\"Failed to allocate ring: %d\\n\", ret);\n\treturn ret;\n}\n\nint xen_drm_front_evtchnl_create_all(struct xen_drm_front_info *front_info)\n{\n\tstruct xen_drm_front_cfg *cfg;\n\tint ret, conn;\n\n\tcfg = &front_info->cfg;\n\n\tfront_info->evt_pairs =\n\t\t\tkcalloc(cfg->num_connectors,\n\t\t\t\tsizeof(struct xen_drm_front_evtchnl_pair),\n\t\t\t\tGFP_KERNEL);\n\tif (!front_info->evt_pairs) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tfor (conn = 0; conn < cfg->num_connectors; conn++) {\n\t\tret = evtchnl_alloc(front_info, conn,\n\t\t\t\t    &front_info->evt_pairs[conn].req,\n\t\t\t\t    EVTCHNL_TYPE_REQ);\n\t\tif (ret < 0) {\n\t\t\tDRM_ERROR(\"Error allocating control channel\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tret = evtchnl_alloc(front_info, conn,\n\t\t\t\t    &front_info->evt_pairs[conn].evt,\n\t\t\t\t    EVTCHNL_TYPE_EVT);\n\t\tif (ret < 0) {\n\t\t\tDRM_ERROR(\"Error allocating in-event channel\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tfront_info->num_evt_pairs = cfg->num_connectors;\n\treturn 0;\n\nfail:\n\txen_drm_front_evtchnl_free_all(front_info);\n\treturn ret;\n}\n\nstatic int evtchnl_publish(struct xenbus_transaction xbt,\n\t\t\t   struct xen_drm_front_evtchnl *evtchnl,\n\t\t\t   const char *path, const char *node_ring,\n\t\t\t   const char *node_chnl)\n{\n\tstruct xenbus_device *xb_dev = evtchnl->front_info->xb_dev;\n\tint ret;\n\n\t \n\tret = xenbus_printf(xbt, path, node_ring, \"%u\", evtchnl->gref);\n\tif (ret < 0) {\n\t\txenbus_dev_error(xb_dev, ret, \"writing ring-ref\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = xenbus_printf(xbt, path, node_chnl, \"%u\", evtchnl->port);\n\tif (ret < 0) {\n\t\txenbus_dev_error(xb_dev, ret, \"writing event channel\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint xen_drm_front_evtchnl_publish_all(struct xen_drm_front_info *front_info)\n{\n\tstruct xenbus_transaction xbt;\n\tstruct xen_drm_front_cfg *plat_data;\n\tint ret, conn;\n\n\tplat_data = &front_info->cfg;\n\nagain:\n\tret = xenbus_transaction_start(&xbt);\n\tif (ret < 0) {\n\t\txenbus_dev_fatal(front_info->xb_dev, ret,\n\t\t\t\t \"starting transaction\");\n\t\treturn ret;\n\t}\n\n\tfor (conn = 0; conn < plat_data->num_connectors; conn++) {\n\t\tret = evtchnl_publish(xbt, &front_info->evt_pairs[conn].req,\n\t\t\t\t      plat_data->connectors[conn].xenstore_path,\n\t\t\t\t      XENDISPL_FIELD_REQ_RING_REF,\n\t\t\t\t      XENDISPL_FIELD_REQ_CHANNEL);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\n\t\tret = evtchnl_publish(xbt, &front_info->evt_pairs[conn].evt,\n\t\t\t\t      plat_data->connectors[conn].xenstore_path,\n\t\t\t\t      XENDISPL_FIELD_EVT_RING_REF,\n\t\t\t\t      XENDISPL_FIELD_EVT_CHANNEL);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\tret = xenbus_transaction_end(xbt, 0);\n\tif (ret < 0) {\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\txenbus_dev_fatal(front_info->xb_dev, ret,\n\t\t\t\t \"completing transaction\");\n\t\tgoto fail_to_end;\n\t}\n\n\treturn 0;\n\nfail:\n\txenbus_transaction_end(xbt, 1);\n\nfail_to_end:\n\txenbus_dev_fatal(front_info->xb_dev, ret, \"writing Xen store\");\n\treturn ret;\n}\n\nvoid xen_drm_front_evtchnl_flush(struct xen_drm_front_evtchnl *evtchnl)\n{\n\tint notify;\n\n\tevtchnl->u.req.ring.req_prod_pvt++;\n\tRING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&evtchnl->u.req.ring, notify);\n\tif (notify)\n\t\tnotify_remote_via_irq(evtchnl->irq);\n}\n\nvoid xen_drm_front_evtchnl_set_state(struct xen_drm_front_info *front_info,\n\t\t\t\t     enum xen_drm_front_evtchnl_state state)\n{\n\tunsigned long flags;\n\tint i;\n\n\tif (!front_info->evt_pairs)\n\t\treturn;\n\n\tspin_lock_irqsave(&front_info->io_lock, flags);\n\tfor (i = 0; i < front_info->num_evt_pairs; i++) {\n\t\tfront_info->evt_pairs[i].req.state = state;\n\t\tfront_info->evt_pairs[i].evt.state = state;\n\t}\n\tspin_unlock_irqrestore(&front_info->io_lock, flags);\n}\n\nvoid xen_drm_front_evtchnl_free_all(struct xen_drm_front_info *front_info)\n{\n\tint i;\n\n\tif (!front_info->evt_pairs)\n\t\treturn;\n\n\tfor (i = 0; i < front_info->num_evt_pairs; i++) {\n\t\tevtchnl_free(front_info, &front_info->evt_pairs[i].req);\n\t\tevtchnl_free(front_info, &front_info->evt_pairs[i].evt);\n\t}\n\n\tkfree(front_info->evt_pairs);\n\tfront_info->evt_pairs = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}