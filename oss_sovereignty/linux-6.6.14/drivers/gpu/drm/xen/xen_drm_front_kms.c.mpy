{
  "module_name": "xen_drm_front_kms.c",
  "hash_id": "fa839cfa8c69cbd3044bc2896e77b1308fabddfa428f756226ecbdffe5747d18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/xen/xen_drm_front_kms.c",
  "human_readable_source": "\n\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"xen_drm_front.h\"\n#include \"xen_drm_front_conn.h\"\n#include \"xen_drm_front_kms.h\"\n\n \n#define FRAME_DONE_TO_MS\t(XEN_DRM_FRONT_WAIT_BACK_MS + 100)\n\nstatic struct xen_drm_front_drm_pipeline *\nto_xen_drm_pipeline(struct drm_simple_display_pipe *pipe)\n{\n\treturn container_of(pipe, struct xen_drm_front_drm_pipeline, pipe);\n}\n\nstatic void fb_destroy(struct drm_framebuffer *fb)\n{\n\tstruct xen_drm_front_drm_info *drm_info = fb->dev->dev_private;\n\tint idx;\n\n\tif (drm_dev_enter(fb->dev, &idx)) {\n\t\txen_drm_front_fb_detach(drm_info->front_info,\n\t\t\t\t\txen_drm_front_fb_to_cookie(fb));\n\t\tdrm_dev_exit(idx);\n\t}\n\tdrm_gem_fb_destroy(fb);\n}\n\nstatic const struct drm_framebuffer_funcs fb_funcs = {\n\t.destroy = fb_destroy,\n};\n\nstatic struct drm_framebuffer *\nfb_create(struct drm_device *dev, struct drm_file *filp,\n\t  const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct xen_drm_front_drm_info *drm_info = dev->dev_private;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_gem_object *gem_obj;\n\tint ret;\n\n\tfb = drm_gem_fb_create_with_funcs(dev, filp, mode_cmd, &fb_funcs);\n\tif (IS_ERR(fb))\n\t\treturn fb;\n\n\tgem_obj = fb->obj[0];\n\n\tret = xen_drm_front_fb_attach(drm_info->front_info,\n\t\t\t\t      xen_drm_front_dbuf_to_cookie(gem_obj),\n\t\t\t\t      xen_drm_front_fb_to_cookie(fb),\n\t\t\t\t      fb->width, fb->height,\n\t\t\t\t      fb->format->format);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Back failed to attach FB %p: %d\\n\", fb, ret);\n\t\tgoto fail;\n\t}\n\n\treturn fb;\n\nfail:\n\tdrm_gem_fb_destroy(fb);\n\treturn ERR_PTR(ret);\n}\n\nstatic const struct drm_mode_config_funcs mode_config_funcs = {\n\t.fb_create = fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic void send_pending_event(struct xen_drm_front_drm_pipeline *pipeline)\n{\n\tstruct drm_crtc *crtc = &pipeline->pipe.crtc;\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tif (pipeline->pending_event)\n\t\tdrm_crtc_send_vblank_event(crtc, pipeline->pending_event);\n\tpipeline->pending_event = NULL;\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\nstatic void display_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t   struct drm_plane_state *plane_state)\n{\n\tstruct xen_drm_front_drm_pipeline *pipeline =\n\t\t\tto_xen_drm_pipeline(pipe);\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tint ret, idx;\n\n\tif (!drm_dev_enter(pipe->crtc.dev, &idx))\n\t\treturn;\n\n\tret = xen_drm_front_mode_set(pipeline, crtc->x, crtc->y,\n\t\t\t\t     fb->width, fb->height,\n\t\t\t\t     fb->format->cpp[0] * 8,\n\t\t\t\t     xen_drm_front_fb_to_cookie(fb));\n\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to enable display: %d\\n\", ret);\n\t\tpipeline->conn_connected = false;\n\t}\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void display_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct xen_drm_front_drm_pipeline *pipeline =\n\t\t\tto_xen_drm_pipeline(pipe);\n\tint ret = 0, idx;\n\n\tif (drm_dev_enter(pipe->crtc.dev, &idx)) {\n\t\tret = xen_drm_front_mode_set(pipeline, 0, 0, 0, 0, 0,\n\t\t\t\t\t     xen_drm_front_fb_to_cookie(NULL));\n\t\tdrm_dev_exit(idx);\n\t}\n\tif (ret)\n\t\tDRM_ERROR(\"Failed to disable display: %d\\n\", ret);\n\n\t \n\tpipeline->conn_connected = true;\n\n\t \n\tsend_pending_event(pipeline);\n}\n\nvoid xen_drm_front_kms_on_frame_done(struct xen_drm_front_drm_pipeline *pipeline,\n\t\t\t\t     u64 fb_cookie)\n{\n\t \n\tcancel_delayed_work(&pipeline->pflip_to_worker);\n\n\tsend_pending_event(pipeline);\n}\n\nstatic void pflip_to_worker(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct xen_drm_front_drm_pipeline *pipeline =\n\t\t\tcontainer_of(delayed_work,\n\t\t\t\t     struct xen_drm_front_drm_pipeline,\n\t\t\t\t     pflip_to_worker);\n\n\tDRM_ERROR(\"Frame done timed-out, releasing\");\n\tsend_pending_event(pipeline);\n}\n\nstatic bool display_send_page_flip(struct drm_simple_display_pipe *pipe,\n\t\t\t\t   struct drm_plane_state *old_plane_state)\n{\n\tstruct drm_plane_state *plane_state =\n\t\t\tdrm_atomic_get_new_plane_state(old_plane_state->state,\n\t\t\t\t\t\t       &pipe->plane);\n\n\t \n\tif (old_plane_state->fb && plane_state->fb) {\n\t\tstruct xen_drm_front_drm_pipeline *pipeline =\n\t\t\t\tto_xen_drm_pipeline(pipe);\n\t\tstruct xen_drm_front_drm_info *drm_info = pipeline->drm_info;\n\t\tint ret;\n\n\t\tschedule_delayed_work(&pipeline->pflip_to_worker,\n\t\t\t\t      msecs_to_jiffies(FRAME_DONE_TO_MS));\n\n\t\tret = xen_drm_front_page_flip(drm_info->front_info,\n\t\t\t\t\t      pipeline->index,\n\t\t\t\t\t      xen_drm_front_fb_to_cookie(plane_state->fb));\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to send page flip request to backend: %d\\n\", ret);\n\n\t\t\tpipeline->conn_connected = false;\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t\t \n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int display_check(struct drm_simple_display_pipe *pipe,\n\t\t\t struct drm_plane_state *plane_state,\n\t\t\t struct drm_crtc_state *crtc_state)\n{\n\t \n\tcrtc_state->no_vblank = false;\n\n\treturn 0;\n}\n\nstatic void display_update(struct drm_simple_display_pipe *pipe,\n\t\t\t   struct drm_plane_state *old_plane_state)\n{\n\tstruct xen_drm_front_drm_pipeline *pipeline =\n\t\t\tto_xen_drm_pipeline(pipe);\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_pending_vblank_event *event;\n\tint idx;\n\n\tevent = crtc->state->event;\n\tif (event) {\n\t\tstruct drm_device *dev = crtc->dev;\n\t\tunsigned long flags;\n\n\t\tWARN_ON(pipeline->pending_event);\n\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tcrtc->state->event = NULL;\n\n\t\tpipeline->pending_event = event;\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n\n\tif (!drm_dev_enter(pipe->crtc.dev, &idx)) {\n\t\tsend_pending_event(pipeline);\n\t\treturn;\n\t}\n\n\t \n\tif (!display_send_page_flip(pipe, old_plane_state))\n\t\tsend_pending_event(pipeline);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic enum drm_mode_status\ndisplay_mode_valid(struct drm_simple_display_pipe *pipe,\n\t\t   const struct drm_display_mode *mode)\n{\n\tstruct xen_drm_front_drm_pipeline *pipeline =\n\t\t\tcontainer_of(pipe, struct xen_drm_front_drm_pipeline,\n\t\t\t\t     pipe);\n\n\tif (mode->hdisplay != pipeline->width)\n\t\treturn MODE_ERROR;\n\n\tif (mode->vdisplay != pipeline->height)\n\t\treturn MODE_ERROR;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_simple_display_pipe_funcs display_funcs = {\n\t.mode_valid = display_mode_valid,\n\t.enable = display_enable,\n\t.disable = display_disable,\n\t.check = display_check,\n\t.update = display_update,\n};\n\nstatic int display_pipe_init(struct xen_drm_front_drm_info *drm_info,\n\t\t\t     int index, struct xen_drm_front_cfg_connector *cfg,\n\t\t\t     struct xen_drm_front_drm_pipeline *pipeline)\n{\n\tstruct drm_device *dev = drm_info->drm_dev;\n\tconst u32 *formats;\n\tint format_count;\n\tint ret;\n\n\tpipeline->drm_info = drm_info;\n\tpipeline->index = index;\n\tpipeline->height = cfg->height;\n\tpipeline->width = cfg->width;\n\n\tINIT_DELAYED_WORK(&pipeline->pflip_to_worker, pflip_to_worker);\n\n\tret = xen_drm_front_conn_init(drm_info, &pipeline->conn);\n\tif (ret)\n\t\treturn ret;\n\n\tformats = xen_drm_front_conn_get_formats(&format_count);\n\n\treturn drm_simple_display_pipe_init(dev, &pipeline->pipe,\n\t\t\t\t\t    &display_funcs, formats,\n\t\t\t\t\t    format_count, NULL,\n\t\t\t\t\t    &pipeline->conn);\n}\n\nint xen_drm_front_kms_init(struct xen_drm_front_drm_info *drm_info)\n{\n\tstruct drm_device *dev = drm_info->drm_dev;\n\tint i, ret;\n\n\tdrm_mode_config_init(dev);\n\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tdev->mode_config.max_width = 4095;\n\tdev->mode_config.max_height = 2047;\n\tdev->mode_config.funcs = &mode_config_funcs;\n\n\tfor (i = 0; i < drm_info->front_info->cfg.num_connectors; i++) {\n\t\tstruct xen_drm_front_cfg_connector *cfg =\n\t\t\t\t&drm_info->front_info->cfg.connectors[i];\n\t\tstruct xen_drm_front_drm_pipeline *pipeline =\n\t\t\t\t&drm_info->pipeline[i];\n\n\t\tret = display_pipe_init(drm_info, i, cfg, pipeline);\n\t\tif (ret) {\n\t\t\tdrm_mode_config_cleanup(dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdrm_mode_config_reset(dev);\n\tdrm_kms_helper_poll_init(dev);\n\treturn 0;\n}\n\nvoid xen_drm_front_kms_fini(struct xen_drm_front_drm_info *drm_info)\n{\n\tint i;\n\n\tfor (i = 0; i < drm_info->front_info->cfg.num_connectors; i++) {\n\t\tstruct xen_drm_front_drm_pipeline *pipeline =\n\t\t\t\t&drm_info->pipeline[i];\n\n\t\tcancel_delayed_work_sync(&pipeline->pflip_to_worker);\n\n\t\tsend_pending_event(pipeline);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}