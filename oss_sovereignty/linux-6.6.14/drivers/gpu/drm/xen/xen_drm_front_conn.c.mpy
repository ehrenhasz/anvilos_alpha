{
  "module_name": "xen_drm_front_conn.c",
  "hash_id": "a0a94866aeebd158a0012e9ffd48968f881605e5a928acc8a8c69452d3b95936",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/xen/xen_drm_front_conn.c",
  "human_readable_source": "\n\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_probe_helper.h>\n\n#include <video/videomode.h>\n\n#include \"xen_drm_front.h\"\n#include \"xen_drm_front_conn.h\"\n#include \"xen_drm_front_kms.h\"\n\nstatic struct xen_drm_front_drm_pipeline *\nto_xen_drm_pipeline(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct xen_drm_front_drm_pipeline, conn);\n}\n\nstatic const u32 plane_formats[] = {\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_YUYV,\n};\n\nconst u32 *xen_drm_front_conn_get_formats(int *format_count)\n{\n\t*format_count = ARRAY_SIZE(plane_formats);\n\treturn plane_formats;\n}\n\nstatic int connector_detect(struct drm_connector *connector,\n\t\t\t    struct drm_modeset_acquire_ctx *ctx,\n\t\t\t    bool force)\n{\n\tstruct xen_drm_front_drm_pipeline *pipeline =\n\t\t\tto_xen_drm_pipeline(connector);\n\n\tif (drm_dev_is_unplugged(connector->dev))\n\t\tpipeline->conn_connected = false;\n\n\treturn pipeline->conn_connected ? connector_status_connected :\n\t\t\tconnector_status_disconnected;\n}\n\n#define XEN_DRM_CRTC_VREFRESH_HZ\t60\n\nstatic int connector_get_modes(struct drm_connector *connector)\n{\n\tstruct xen_drm_front_drm_pipeline *pipeline =\n\t\t\tto_xen_drm_pipeline(connector);\n\tstruct drm_display_mode *mode;\n\tstruct videomode videomode;\n\tint width, height;\n\n\tmode = drm_mode_create(connector->dev);\n\tif (!mode)\n\t\treturn 0;\n\n\tmemset(&videomode, 0, sizeof(videomode));\n\tvideomode.hactive = pipeline->width;\n\tvideomode.vactive = pipeline->height;\n\twidth = videomode.hactive + videomode.hfront_porch +\n\t\t\tvideomode.hback_porch + videomode.hsync_len;\n\theight = videomode.vactive + videomode.vfront_porch +\n\t\t\tvideomode.vback_porch + videomode.vsync_len;\n\tvideomode.pixelclock = width * height * XEN_DRM_CRTC_VREFRESH_HZ;\n\tmode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\n\n\tdrm_display_mode_from_videomode(&videomode, mode);\n\tdrm_mode_probed_add(connector, mode);\n\treturn 1;\n}\n\nstatic const struct drm_connector_helper_funcs connector_helper_funcs = {\n\t.get_modes = connector_get_modes,\n\t.detect_ctx = connector_detect,\n};\n\nstatic const struct drm_connector_funcs connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nint xen_drm_front_conn_init(struct xen_drm_front_drm_info *drm_info,\n\t\t\t    struct drm_connector *connector)\n{\n\tstruct xen_drm_front_drm_pipeline *pipeline =\n\t\t\tto_xen_drm_pipeline(connector);\n\n\tdrm_connector_helper_add(connector, &connector_helper_funcs);\n\n\tpipeline->conn_connected = true;\n\n\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\tDRM_CONNECTOR_POLL_DISCONNECT;\n\n\treturn drm_connector_init(drm_info->drm_dev, connector,\n\t\t\t\t  &connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}