{
  "module_name": "drm_simple_kms_helper.c",
  "hash_id": "31f582fd8765477822875fac91e42e74f9bc4f3b15d6491fd712f8461fd4ad55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_simple_kms_helper.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n \n\nstatic const struct drm_encoder_funcs drm_simple_encoder_funcs_cleanup = {\n\t.destroy = drm_encoder_cleanup,\n};\n\n \nint drm_simple_encoder_init(struct drm_device *dev,\n\t\t\t    struct drm_encoder *encoder,\n\t\t\t    int encoder_type)\n{\n\treturn drm_encoder_init(dev, encoder,\n\t\t\t\t&drm_simple_encoder_funcs_cleanup,\n\t\t\t\tencoder_type, NULL);\n}\nEXPORT_SYMBOL(drm_simple_encoder_init);\n\nvoid *__drmm_simple_encoder_alloc(struct drm_device *dev, size_t size,\n\t\t\t\t  size_t offset, int encoder_type)\n{\n\treturn __drmm_encoder_alloc(dev, size, offset, NULL, encoder_type,\n\t\t\t\t    NULL);\n}\nEXPORT_SYMBOL(__drmm_simple_encoder_alloc);\n\nstatic enum drm_mode_status\ndrm_simple_kms_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t\t       const struct drm_display_mode *mode)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(crtc, struct drm_simple_display_pipe, crtc);\n\tif (!pipe->funcs || !pipe->funcs->mode_valid)\n\t\t \n\t\treturn MODE_OK;\n\n\treturn pipe->funcs->mode_valid(pipe, mode);\n}\n\nstatic int drm_simple_kms_crtc_check(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tint ret;\n\n\tif (!crtc_state->enable)\n\t\tgoto out;\n\n\tret = drm_atomic_helper_check_crtc_primary_plane(crtc_state);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\treturn drm_atomic_add_affected_planes(state, crtc);\n}\n\nstatic void drm_simple_kms_crtc_enable(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane *plane;\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(crtc, struct drm_simple_display_pipe, crtc);\n\tif (!pipe->funcs || !pipe->funcs->enable)\n\t\treturn;\n\n\tplane = &pipe->plane;\n\tpipe->funcs->enable(pipe, crtc->state, plane->state);\n}\n\nstatic void drm_simple_kms_crtc_disable(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(crtc, struct drm_simple_display_pipe, crtc);\n\tif (!pipe->funcs || !pipe->funcs->disable)\n\t\treturn;\n\n\tpipe->funcs->disable(pipe);\n}\n\nstatic const struct drm_crtc_helper_funcs drm_simple_kms_crtc_helper_funcs = {\n\t.mode_valid = drm_simple_kms_crtc_mode_valid,\n\t.atomic_check = drm_simple_kms_crtc_check,\n\t.atomic_enable = drm_simple_kms_crtc_enable,\n\t.atomic_disable = drm_simple_kms_crtc_disable,\n};\n\nstatic void drm_simple_kms_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(crtc, struct drm_simple_display_pipe, crtc);\n\tif (!pipe->funcs || !pipe->funcs->reset_crtc)\n\t\treturn drm_atomic_helper_crtc_reset(crtc);\n\n\treturn pipe->funcs->reset_crtc(pipe);\n}\n\nstatic struct drm_crtc_state *drm_simple_kms_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(crtc, struct drm_simple_display_pipe, crtc);\n\tif (!pipe->funcs || !pipe->funcs->duplicate_crtc_state)\n\t\treturn drm_atomic_helper_crtc_duplicate_state(crtc);\n\n\treturn pipe->funcs->duplicate_crtc_state(pipe);\n}\n\nstatic void drm_simple_kms_crtc_destroy_state(struct drm_crtc *crtc, struct drm_crtc_state *state)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(crtc, struct drm_simple_display_pipe, crtc);\n\tif (!pipe->funcs || !pipe->funcs->destroy_crtc_state)\n\t\tdrm_atomic_helper_crtc_destroy_state(crtc, state);\n\telse\n\t\tpipe->funcs->destroy_crtc_state(pipe, state);\n}\n\nstatic int drm_simple_kms_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(crtc, struct drm_simple_display_pipe, crtc);\n\tif (!pipe->funcs || !pipe->funcs->enable_vblank)\n\t\treturn 0;\n\n\treturn pipe->funcs->enable_vblank(pipe);\n}\n\nstatic void drm_simple_kms_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(crtc, struct drm_simple_display_pipe, crtc);\n\tif (!pipe->funcs || !pipe->funcs->disable_vblank)\n\t\treturn;\n\n\tpipe->funcs->disable_vblank(pipe);\n}\n\nstatic const struct drm_crtc_funcs drm_simple_kms_crtc_funcs = {\n\t.reset = drm_simple_kms_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = drm_simple_kms_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_simple_kms_crtc_destroy_state,\n\t.enable_vblank = drm_simple_kms_crtc_enable_vblank,\n\t.disable_vblank = drm_simple_kms_crtc_disable_vblank,\n};\n\nstatic int drm_simple_kms_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t     plane);\n\tstruct drm_simple_display_pipe *pipe;\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\n\tpipe = container_of(plane, struct drm_simple_display_pipe, plane);\n\tcrtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t   &pipe->crtc);\n\n\tret = drm_atomic_helper_check_plane_state(plane_state, crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  false, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->visible)\n\t\treturn 0;\n\n\tif (!pipe->funcs || !pipe->funcs->check)\n\t\treturn 0;\n\n\treturn pipe->funcs->check(pipe, plane_state, crtc_state);\n}\n\nstatic void drm_simple_kms_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_pstate = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t    plane);\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(plane, struct drm_simple_display_pipe, plane);\n\tif (!pipe->funcs || !pipe->funcs->update)\n\t\treturn;\n\n\tpipe->funcs->update(pipe, old_pstate);\n}\n\nstatic int drm_simple_kms_plane_prepare_fb(struct drm_plane *plane,\n\t\t\t\t\t   struct drm_plane_state *state)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(plane, struct drm_simple_display_pipe, plane);\n\tif (!pipe->funcs || !pipe->funcs->prepare_fb) {\n\t\tif (WARN_ON_ONCE(!drm_core_check_feature(plane->dev, DRIVER_GEM)))\n\t\t\treturn 0;\n\n\t\tWARN_ON_ONCE(pipe->funcs && pipe->funcs->cleanup_fb);\n\n\t\treturn drm_gem_plane_helper_prepare_fb(plane, state);\n\t}\n\n\treturn pipe->funcs->prepare_fb(pipe, state);\n}\n\nstatic void drm_simple_kms_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t\t    struct drm_plane_state *state)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(plane, struct drm_simple_display_pipe, plane);\n\tif (!pipe->funcs || !pipe->funcs->cleanup_fb)\n\t\treturn;\n\n\tpipe->funcs->cleanup_fb(pipe, state);\n}\n\nstatic int drm_simple_kms_plane_begin_fb_access(struct drm_plane *plane,\n\t\t\t\t\t\tstruct drm_plane_state *new_plane_state)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(plane, struct drm_simple_display_pipe, plane);\n\tif (!pipe->funcs || !pipe->funcs->begin_fb_access)\n\t\treturn 0;\n\n\treturn pipe->funcs->begin_fb_access(pipe, new_plane_state);\n}\n\nstatic void drm_simple_kms_plane_end_fb_access(struct drm_plane *plane,\n\t\t\t\t\t       struct drm_plane_state *new_plane_state)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(plane, struct drm_simple_display_pipe, plane);\n\tif (!pipe->funcs || !pipe->funcs->end_fb_access)\n\t\treturn;\n\n\tpipe->funcs->end_fb_access(pipe, new_plane_state);\n}\n\nstatic bool drm_simple_kms_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t\t\tuint32_t format,\n\t\t\t\t\t\tuint64_t modifier)\n{\n\treturn modifier == DRM_FORMAT_MOD_LINEAR;\n}\n\nstatic const struct drm_plane_helper_funcs drm_simple_kms_plane_helper_funcs = {\n\t.prepare_fb = drm_simple_kms_plane_prepare_fb,\n\t.cleanup_fb = drm_simple_kms_plane_cleanup_fb,\n\t.begin_fb_access = drm_simple_kms_plane_begin_fb_access,\n\t.end_fb_access = drm_simple_kms_plane_end_fb_access,\n\t.atomic_check = drm_simple_kms_plane_atomic_check,\n\t.atomic_update = drm_simple_kms_plane_atomic_update,\n};\n\nstatic void drm_simple_kms_plane_reset(struct drm_plane *plane)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(plane, struct drm_simple_display_pipe, plane);\n\tif (!pipe->funcs || !pipe->funcs->reset_plane)\n\t\treturn drm_atomic_helper_plane_reset(plane);\n\n\treturn pipe->funcs->reset_plane(pipe);\n}\n\nstatic struct drm_plane_state *drm_simple_kms_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(plane, struct drm_simple_display_pipe, plane);\n\tif (!pipe->funcs || !pipe->funcs->duplicate_plane_state)\n\t\treturn drm_atomic_helper_plane_duplicate_state(plane);\n\n\treturn pipe->funcs->duplicate_plane_state(pipe);\n}\n\nstatic void drm_simple_kms_plane_destroy_state(struct drm_plane *plane,\n\t\t\t\t\t       struct drm_plane_state *state)\n{\n\tstruct drm_simple_display_pipe *pipe;\n\n\tpipe = container_of(plane, struct drm_simple_display_pipe, plane);\n\tif (!pipe->funcs || !pipe->funcs->destroy_plane_state)\n\t\tdrm_atomic_helper_plane_destroy_state(plane, state);\n\telse\n\t\tpipe->funcs->destroy_plane_state(pipe, state);\n}\n\nstatic const struct drm_plane_funcs drm_simple_kms_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.destroy\t\t= drm_plane_cleanup,\n\t.reset\t\t\t= drm_simple_kms_plane_reset,\n\t.atomic_duplicate_state\t= drm_simple_kms_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_simple_kms_plane_destroy_state,\n\t.format_mod_supported   = drm_simple_kms_format_mod_supported,\n};\n\n \nint drm_simple_display_pipe_attach_bridge(struct drm_simple_display_pipe *pipe,\n\t\t\t\t\t  struct drm_bridge *bridge)\n{\n\treturn drm_bridge_attach(&pipe->encoder, bridge, NULL, 0);\n}\nEXPORT_SYMBOL(drm_simple_display_pipe_attach_bridge);\n\n \nint drm_simple_display_pipe_init(struct drm_device *dev,\n\t\t\tstruct drm_simple_display_pipe *pipe,\n\t\t\tconst struct drm_simple_display_pipe_funcs *funcs,\n\t\t\tconst uint32_t *formats, unsigned int format_count,\n\t\t\tconst uint64_t *format_modifiers,\n\t\t\tstruct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder = &pipe->encoder;\n\tstruct drm_plane *plane = &pipe->plane;\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tint ret;\n\n\tpipe->connector = connector;\n\tpipe->funcs = funcs;\n\n\tdrm_plane_helper_add(plane, &drm_simple_kms_plane_helper_funcs);\n\tret = drm_universal_plane_init(dev, plane, 0,\n\t\t\t\t       &drm_simple_kms_plane_funcs,\n\t\t\t\t       formats, format_count,\n\t\t\t\t       format_modifiers,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_crtc_helper_add(crtc, &drm_simple_kms_crtc_helper_funcs);\n\tret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,\n\t\t\t\t\t&drm_simple_kms_crtc_funcs, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_NONE);\n\tif (ret || !connector)\n\t\treturn ret;\n\n\treturn drm_connector_attach_encoder(connector, encoder);\n}\nEXPORT_SYMBOL(drm_simple_display_pipe_init);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}