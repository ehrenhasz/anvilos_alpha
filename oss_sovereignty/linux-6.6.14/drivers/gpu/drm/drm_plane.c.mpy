{
  "module_name": "drm_plane.c",
  "hash_id": "3be6f9417dc7babffa90ab2ea69af7a15ea553b7dc1a57583fe5e296775cc0d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_plane.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_plane.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_print.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_file.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_vblank.h>\n\n#include \"drm_crtc_internal.h\"\n\n \n\n \n\nstatic unsigned int drm_num_planes(struct drm_device *dev)\n{\n\tunsigned int num = 0;\n\tstruct drm_plane *tmp;\n\n\tdrm_for_each_plane(tmp, dev) {\n\t\tnum++;\n\t}\n\n\treturn num;\n}\n\nstatic inline u32 *\nformats_ptr(struct drm_format_modifier_blob *blob)\n{\n\treturn (u32 *)(((char *)blob) + blob->formats_offset);\n}\n\nstatic inline struct drm_format_modifier *\nmodifiers_ptr(struct drm_format_modifier_blob *blob)\n{\n\treturn (struct drm_format_modifier *)(((char *)blob) + blob->modifiers_offset);\n}\n\nstatic int create_in_format_blob(struct drm_device *dev, struct drm_plane *plane)\n{\n\tconst struct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_property_blob *blob;\n\tstruct drm_format_modifier *mod;\n\tsize_t blob_size, formats_size, modifiers_size;\n\tstruct drm_format_modifier_blob *blob_data;\n\tunsigned int i, j;\n\n\tformats_size = sizeof(__u32) * plane->format_count;\n\tif (WARN_ON(!formats_size)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tmodifiers_size =\n\t\tsizeof(struct drm_format_modifier) * plane->modifier_count;\n\n\tblob_size = sizeof(struct drm_format_modifier_blob);\n\t \n\tBUILD_BUG_ON(sizeof(struct drm_format_modifier_blob) % 8);\n\tblob_size += ALIGN(formats_size, 8);\n\tblob_size += modifiers_size;\n\n\tblob = drm_property_create_blob(dev, blob_size, NULL);\n\tif (IS_ERR(blob))\n\t\treturn -1;\n\n\tblob_data = blob->data;\n\tblob_data->version = FORMAT_BLOB_CURRENT;\n\tblob_data->count_formats = plane->format_count;\n\tblob_data->formats_offset = sizeof(struct drm_format_modifier_blob);\n\tblob_data->count_modifiers = plane->modifier_count;\n\n\tblob_data->modifiers_offset =\n\t\tALIGN(blob_data->formats_offset + formats_size, 8);\n\n\tmemcpy(formats_ptr(blob_data), plane->format_types, formats_size);\n\n\tmod = modifiers_ptr(blob_data);\n\tfor (i = 0; i < plane->modifier_count; i++) {\n\t\tfor (j = 0; j < plane->format_count; j++) {\n\t\t\tif (!plane->funcs->format_mod_supported ||\n\t\t\t    plane->funcs->format_mod_supported(plane,\n\t\t\t\t\t\t\t       plane->format_types[j],\n\t\t\t\t\t\t\t       plane->modifiers[i])) {\n\t\t\t\tmod->formats |= 1ULL << j;\n\t\t\t}\n\t\t}\n\n\t\tmod->modifier = plane->modifiers[i];\n\t\tmod->offset = 0;\n\t\tmod->pad = 0;\n\t\tmod++;\n\t}\n\n\tdrm_object_attach_property(&plane->base, config->modifiers_property,\n\t\t\t\t   blob->base.id);\n\n\treturn 0;\n}\n\n__printf(9, 0)\nstatic int __drm_universal_plane_init(struct drm_device *dev,\n\t\t\t\t      struct drm_plane *plane,\n\t\t\t\t      uint32_t possible_crtcs,\n\t\t\t\t      const struct drm_plane_funcs *funcs,\n\t\t\t\t      const uint32_t *formats,\n\t\t\t\t      unsigned int format_count,\n\t\t\t\t      const uint64_t *format_modifiers,\n\t\t\t\t      enum drm_plane_type type,\n\t\t\t\t      const char *name, va_list ap)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstatic const uint64_t default_modifiers[] = {\n\t\tDRM_FORMAT_MOD_LINEAR,\n\t};\n\tunsigned int format_modifier_count = 0;\n\tint ret;\n\n\t \n\tif (WARN_ON(config->num_total_plane >= 32))\n\t\treturn -EINVAL;\n\n\t \n\tif (WARN_ON(format_count > 64))\n\t\treturn -EINVAL;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(dev) &&\n\t\t(!funcs->atomic_destroy_state ||\n\t\t !funcs->atomic_duplicate_state));\n\n\tret = drm_mode_object_add(dev, &plane->base, DRM_MODE_OBJECT_PLANE);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_modeset_lock_init(&plane->mutex);\n\n\tplane->base.properties = &plane->properties;\n\tplane->dev = dev;\n\tplane->funcs = funcs;\n\tplane->format_types = kmalloc_array(format_count, sizeof(uint32_t),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!plane->format_types) {\n\t\tDRM_DEBUG_KMS(\"out of memory when allocating plane\\n\");\n\t\tdrm_mode_object_unregister(dev, &plane->base);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (format_modifiers) {\n\t\tconst uint64_t *temp_modifiers = format_modifiers;\n\n\t\twhile (*temp_modifiers++ != DRM_FORMAT_MOD_INVALID)\n\t\t\tformat_modifier_count++;\n\t} else {\n\t\tif (!dev->mode_config.fb_modifiers_not_supported) {\n\t\t\tformat_modifiers = default_modifiers;\n\t\t\tformat_modifier_count = ARRAY_SIZE(default_modifiers);\n\t\t}\n\t}\n\n\t \n\tdrm_WARN_ON(dev, config->fb_modifiers_not_supported &&\n\t\t\t\tformat_modifier_count);\n\n\tplane->modifier_count = format_modifier_count;\n\tplane->modifiers = kmalloc_array(format_modifier_count,\n\t\t\t\t\t sizeof(format_modifiers[0]),\n\t\t\t\t\t GFP_KERNEL);\n\n\tif (format_modifier_count && !plane->modifiers) {\n\t\tDRM_DEBUG_KMS(\"out of memory when allocating plane\\n\");\n\t\tkfree(plane->format_types);\n\t\tdrm_mode_object_unregister(dev, &plane->base);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (name) {\n\t\tplane->name = kvasprintf(GFP_KERNEL, name, ap);\n\t} else {\n\t\tplane->name = kasprintf(GFP_KERNEL, \"plane-%d\",\n\t\t\t\t\tdrm_num_planes(dev));\n\t}\n\tif (!plane->name) {\n\t\tkfree(plane->format_types);\n\t\tkfree(plane->modifiers);\n\t\tdrm_mode_object_unregister(dev, &plane->base);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(plane->format_types, formats, format_count * sizeof(uint32_t));\n\tplane->format_count = format_count;\n\tmemcpy(plane->modifiers, format_modifiers,\n\t       format_modifier_count * sizeof(format_modifiers[0]));\n\tplane->possible_crtcs = possible_crtcs;\n\tplane->type = type;\n\n\tlist_add_tail(&plane->head, &config->plane_list);\n\tplane->index = config->num_total_plane++;\n\n\tdrm_object_attach_property(&plane->base,\n\t\t\t\t   config->plane_type_property,\n\t\t\t\t   plane->type);\n\n\tif (drm_core_check_feature(dev, DRIVER_ATOMIC)) {\n\t\tdrm_object_attach_property(&plane->base, config->prop_fb_id, 0);\n\t\tdrm_object_attach_property(&plane->base, config->prop_in_fence_fd, -1);\n\t\tdrm_object_attach_property(&plane->base, config->prop_crtc_id, 0);\n\t\tdrm_object_attach_property(&plane->base, config->prop_crtc_x, 0);\n\t\tdrm_object_attach_property(&plane->base, config->prop_crtc_y, 0);\n\t\tdrm_object_attach_property(&plane->base, config->prop_crtc_w, 0);\n\t\tdrm_object_attach_property(&plane->base, config->prop_crtc_h, 0);\n\t\tdrm_object_attach_property(&plane->base, config->prop_src_x, 0);\n\t\tdrm_object_attach_property(&plane->base, config->prop_src_y, 0);\n\t\tdrm_object_attach_property(&plane->base, config->prop_src_w, 0);\n\t\tdrm_object_attach_property(&plane->base, config->prop_src_h, 0);\n\t}\n\n\tif (format_modifier_count)\n\t\tcreate_in_format_blob(dev, plane);\n\n\treturn 0;\n}\n\n \nint drm_universal_plane_init(struct drm_device *dev, struct drm_plane *plane,\n\t\t\t     uint32_t possible_crtcs,\n\t\t\t     const struct drm_plane_funcs *funcs,\n\t\t\t     const uint32_t *formats, unsigned int format_count,\n\t\t\t     const uint64_t *format_modifiers,\n\t\t\t     enum drm_plane_type type,\n\t\t\t     const char *name, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tWARN_ON(!funcs->destroy);\n\n\tva_start(ap, name);\n\tret = __drm_universal_plane_init(dev, plane, possible_crtcs, funcs,\n\t\t\t\t\t formats, format_count, format_modifiers,\n\t\t\t\t\t type, name, ap);\n\tva_end(ap);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_universal_plane_init);\n\nstatic void drmm_universal_plane_alloc_release(struct drm_device *dev, void *ptr)\n{\n\tstruct drm_plane *plane = ptr;\n\n\tif (WARN_ON(!plane->dev))\n\t\treturn;\n\n\tdrm_plane_cleanup(plane);\n}\n\nvoid *__drmm_universal_plane_alloc(struct drm_device *dev, size_t size,\n\t\t\t\t   size_t offset, uint32_t possible_crtcs,\n\t\t\t\t   const struct drm_plane_funcs *funcs,\n\t\t\t\t   const uint32_t *formats, unsigned int format_count,\n\t\t\t\t   const uint64_t *format_modifiers,\n\t\t\t\t   enum drm_plane_type type,\n\t\t\t\t   const char *name, ...)\n{\n\tvoid *container;\n\tstruct drm_plane *plane;\n\tva_list ap;\n\tint ret;\n\n\tif (WARN_ON(!funcs || funcs->destroy))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcontainer = drmm_kzalloc(dev, size, GFP_KERNEL);\n\tif (!container)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tplane = container + offset;\n\n\tva_start(ap, name);\n\tret = __drm_universal_plane_init(dev, plane, possible_crtcs, funcs,\n\t\t\t\t\t formats, format_count, format_modifiers,\n\t\t\t\t\t type, name, ap);\n\tva_end(ap);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = drmm_add_action_or_reset(dev, drmm_universal_plane_alloc_release,\n\t\t\t\t       plane);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn container;\n}\nEXPORT_SYMBOL(__drmm_universal_plane_alloc);\n\nvoid *__drm_universal_plane_alloc(struct drm_device *dev, size_t size,\n\t\t\t\t  size_t offset, uint32_t possible_crtcs,\n\t\t\t\t  const struct drm_plane_funcs *funcs,\n\t\t\t\t  const uint32_t *formats, unsigned int format_count,\n\t\t\t\t  const uint64_t *format_modifiers,\n\t\t\t\t  enum drm_plane_type type,\n\t\t\t\t  const char *name, ...)\n{\n\tvoid *container;\n\tstruct drm_plane *plane;\n\tva_list ap;\n\tint ret;\n\n\tif (drm_WARN_ON(dev, !funcs))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcontainer = kzalloc(size, GFP_KERNEL);\n\tif (!container)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tplane = container + offset;\n\n\tva_start(ap, name);\n\tret = __drm_universal_plane_init(dev, plane, possible_crtcs, funcs,\n\t\t\t\t\t formats, format_count, format_modifiers,\n\t\t\t\t\t type, name, ap);\n\tva_end(ap);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\treturn container;\n\nerr_kfree:\n\tkfree(container);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(__drm_universal_plane_alloc);\n\nint drm_plane_register_all(struct drm_device *dev)\n{\n\tunsigned int num_planes = 0;\n\tunsigned int num_zpos = 0;\n\tstruct drm_plane *plane;\n\tint ret = 0;\n\n\tdrm_for_each_plane(plane, dev) {\n\t\tif (plane->funcs->late_register)\n\t\t\tret = plane->funcs->late_register(plane);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (plane->zpos_property)\n\t\t\tnum_zpos++;\n\t\tnum_planes++;\n\t}\n\n\tdrm_WARN(dev, num_zpos && num_planes != num_zpos,\n\t\t \"Mixing planes with and without zpos property is invalid\\n\");\n\n\treturn 0;\n}\n\nvoid drm_plane_unregister_all(struct drm_device *dev)\n{\n\tstruct drm_plane *plane;\n\n\tdrm_for_each_plane(plane, dev) {\n\t\tif (plane->funcs->early_unregister)\n\t\t\tplane->funcs->early_unregister(plane);\n\t}\n}\n\n \nvoid drm_plane_cleanup(struct drm_plane *plane)\n{\n\tstruct drm_device *dev = plane->dev;\n\n\tdrm_modeset_lock_fini(&plane->mutex);\n\n\tkfree(plane->format_types);\n\tkfree(plane->modifiers);\n\tdrm_mode_object_unregister(dev, &plane->base);\n\n\tBUG_ON(list_empty(&plane->head));\n\n\t \n\n\tlist_del(&plane->head);\n\tdev->mode_config.num_total_plane--;\n\n\tWARN_ON(plane->state && !plane->funcs->atomic_destroy_state);\n\tif (plane->state && plane->funcs->atomic_destroy_state)\n\t\tplane->funcs->atomic_destroy_state(plane, plane->state);\n\n\tkfree(plane->name);\n\n\tmemset(plane, 0, sizeof(*plane));\n}\nEXPORT_SYMBOL(drm_plane_cleanup);\n\n \nstruct drm_plane *\ndrm_plane_from_index(struct drm_device *dev, int idx)\n{\n\tstruct drm_plane *plane;\n\n\tdrm_for_each_plane(plane, dev)\n\t\tif (idx == plane->index)\n\t\t\treturn plane;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_plane_from_index);\n\n \nvoid drm_plane_force_disable(struct drm_plane *plane)\n{\n\tint ret;\n\n\tif (!plane->fb)\n\t\treturn;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(plane->dev));\n\n\tplane->old_fb = plane->fb;\n\tret = plane->funcs->disable_plane(plane, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to disable plane with busy fb\\n\");\n\t\tplane->old_fb = NULL;\n\t\treturn;\n\t}\n\t \n\tdrm_framebuffer_put(plane->old_fb);\n\tplane->old_fb = NULL;\n\tplane->fb = NULL;\n\tplane->crtc = NULL;\n}\nEXPORT_SYMBOL(drm_plane_force_disable);\n\n \nint drm_mode_plane_set_obj_prop(struct drm_plane *plane,\n\t\t\t\tstruct drm_property *property,\n\t\t\t\tuint64_t value)\n{\n\tint ret = -EINVAL;\n\tstruct drm_mode_object *obj = &plane->base;\n\n\tif (plane->funcs->set_property)\n\t\tret = plane->funcs->set_property(plane, property, value);\n\tif (!ret)\n\t\tdrm_object_property_set_value(obj, property, value);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_mode_plane_set_obj_prop);\n\nint drm_mode_getplane_res(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_mode_get_plane_res *plane_resp = data;\n\tstruct drm_plane *plane;\n\tuint32_t __user *plane_ptr;\n\tint count = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tplane_ptr = u64_to_user_ptr(plane_resp->plane_id_ptr);\n\n\t \n\tdrm_for_each_plane(plane, dev) {\n\t\t \n\t\tif (plane->type != DRM_PLANE_TYPE_OVERLAY &&\n\t\t    !file_priv->universal_planes)\n\t\t\tcontinue;\n\n\t\tif (drm_lease_held(file_priv, plane->base.id)) {\n\t\t\tif (count < plane_resp->count_planes &&\n\t\t\t    put_user(plane->base.id, plane_ptr + count))\n\t\t\t\treturn -EFAULT;\n\t\t\tcount++;\n\t\t}\n\t}\n\tplane_resp->count_planes = count;\n\n\treturn 0;\n}\n\nint drm_mode_getplane(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_mode_get_plane *plane_resp = data;\n\tstruct drm_plane *plane;\n\tuint32_t __user *format_ptr;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tplane = drm_plane_find(dev, file_priv, plane_resp->plane_id);\n\tif (!plane)\n\t\treturn -ENOENT;\n\n\tdrm_modeset_lock(&plane->mutex, NULL);\n\tif (plane->state && plane->state->crtc && drm_lease_held(file_priv, plane->state->crtc->base.id))\n\t\tplane_resp->crtc_id = plane->state->crtc->base.id;\n\telse if (!plane->state && plane->crtc && drm_lease_held(file_priv, plane->crtc->base.id))\n\t\tplane_resp->crtc_id = plane->crtc->base.id;\n\telse\n\t\tplane_resp->crtc_id = 0;\n\n\tif (plane->state && plane->state->fb)\n\t\tplane_resp->fb_id = plane->state->fb->base.id;\n\telse if (!plane->state && plane->fb)\n\t\tplane_resp->fb_id = plane->fb->base.id;\n\telse\n\t\tplane_resp->fb_id = 0;\n\tdrm_modeset_unlock(&plane->mutex);\n\n\tplane_resp->plane_id = plane->base.id;\n\tplane_resp->possible_crtcs = drm_lease_filter_crtcs(file_priv,\n\t\t\t\t\t\t\t    plane->possible_crtcs);\n\n\tplane_resp->gamma_size = 0;\n\n\t \n\tif (plane->format_count &&\n\t    (plane_resp->count_format_types >= plane->format_count)) {\n\t\tformat_ptr = (uint32_t __user *)(unsigned long)plane_resp->format_type_ptr;\n\t\tif (copy_to_user(format_ptr,\n\t\t\t\t plane->format_types,\n\t\t\t\t sizeof(uint32_t) * plane->format_count)) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tplane_resp->count_format_types = plane->format_count;\n\n\treturn 0;\n}\n\nint drm_plane_check_pixel_format(struct drm_plane *plane,\n\t\t\t\t u32 format, u64 modifier)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < plane->format_count; i++) {\n\t\tif (format == plane->format_types[i])\n\t\t\tbreak;\n\t}\n\tif (i == plane->format_count)\n\t\treturn -EINVAL;\n\n\tif (plane->funcs->format_mod_supported) {\n\t\tif (!plane->funcs->format_mod_supported(plane, format, modifier))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!plane->modifier_count)\n\t\t\treturn 0;\n\n\t\tfor (i = 0; i < plane->modifier_count; i++) {\n\t\t\tif (modifier == plane->modifiers[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == plane->modifier_count)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __setplane_check(struct drm_plane *plane,\n\t\t\t    struct drm_crtc *crtc,\n\t\t\t    struct drm_framebuffer *fb,\n\t\t\t    int32_t crtc_x, int32_t crtc_y,\n\t\t\t    uint32_t crtc_w, uint32_t crtc_h,\n\t\t\t    uint32_t src_x, uint32_t src_y,\n\t\t\t    uint32_t src_w, uint32_t src_h)\n{\n\tint ret;\n\n\t \n\tif (!(plane->possible_crtcs & drm_crtc_mask(crtc))) {\n\t\tDRM_DEBUG_KMS(\"Invalid crtc for plane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = drm_plane_check_pixel_format(plane, fb->format->format,\n\t\t\t\t\t   fb->modifier);\n\tif (ret) {\n\t\tDRM_DEBUG_KMS(\"Invalid pixel format %p4cc, modifier 0x%llx\\n\",\n\t\t\t      &fb->format->format, fb->modifier);\n\t\treturn ret;\n\t}\n\n\t \n\tif (crtc_w > INT_MAX ||\n\t    crtc_x > INT_MAX - (int32_t) crtc_w ||\n\t    crtc_h > INT_MAX ||\n\t    crtc_y > INT_MAX - (int32_t) crtc_h) {\n\t\tDRM_DEBUG_KMS(\"Invalid CRTC coordinates %ux%u+%d+%d\\n\",\n\t\t\t      crtc_w, crtc_h, crtc_x, crtc_y);\n\t\treturn -ERANGE;\n\t}\n\n\tret = drm_framebuffer_check_src_coords(src_x, src_y, src_w, src_h, fb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nbool drm_any_plane_has_format(struct drm_device *dev,\n\t\t\t      u32 format, u64 modifier)\n{\n\tstruct drm_plane *plane;\n\n\tdrm_for_each_plane(plane, dev) {\n\t\tif (drm_plane_check_pixel_format(plane, format, modifier) == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(drm_any_plane_has_format);\n\n \nstatic int __setplane_internal(struct drm_plane *plane,\n\t\t\t       struct drm_crtc *crtc,\n\t\t\t       struct drm_framebuffer *fb,\n\t\t\t       int32_t crtc_x, int32_t crtc_y,\n\t\t\t       uint32_t crtc_w, uint32_t crtc_h,\n\t\t\t        \n\t\t\t       uint32_t src_x, uint32_t src_y,\n\t\t\t       uint32_t src_w, uint32_t src_h,\n\t\t\t       struct drm_modeset_acquire_ctx *ctx)\n{\n\tint ret = 0;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(plane->dev));\n\n\t \n\tif (!fb) {\n\t\tplane->old_fb = plane->fb;\n\t\tret = plane->funcs->disable_plane(plane, ctx);\n\t\tif (!ret) {\n\t\t\tplane->crtc = NULL;\n\t\t\tplane->fb = NULL;\n\t\t} else {\n\t\t\tplane->old_fb = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = __setplane_check(plane, crtc, fb,\n\t\t\t       crtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t       src_x, src_y, src_w, src_h);\n\tif (ret)\n\t\tgoto out;\n\n\tplane->old_fb = plane->fb;\n\tret = plane->funcs->update_plane(plane, crtc, fb,\n\t\t\t\t\t crtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t\t\t src_x, src_y, src_w, src_h, ctx);\n\tif (!ret) {\n\t\tplane->crtc = crtc;\n\t\tplane->fb = fb;\n\t\tdrm_framebuffer_get(plane->fb);\n\t} else {\n\t\tplane->old_fb = NULL;\n\t}\n\nout:\n\tif (plane->old_fb)\n\t\tdrm_framebuffer_put(plane->old_fb);\n\tplane->old_fb = NULL;\n\n\treturn ret;\n}\n\nstatic int __setplane_atomic(struct drm_plane *plane,\n\t\t\t     struct drm_crtc *crtc,\n\t\t\t     struct drm_framebuffer *fb,\n\t\t\t     int32_t crtc_x, int32_t crtc_y,\n\t\t\t     uint32_t crtc_w, uint32_t crtc_h,\n\t\t\t     uint32_t src_x, uint32_t src_y,\n\t\t\t     uint32_t src_w, uint32_t src_h,\n\t\t\t     struct drm_modeset_acquire_ctx *ctx)\n{\n\tint ret;\n\n\tWARN_ON(!drm_drv_uses_atomic_modeset(plane->dev));\n\n\t \n\tif (!fb)\n\t\treturn plane->funcs->disable_plane(plane, ctx);\n\n\t \n\tret = __setplane_check(plane, crtc, fb,\n\t\t\t       crtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t       src_x, src_y, src_w, src_h);\n\tif (ret)\n\t\treturn ret;\n\n\treturn plane->funcs->update_plane(plane, crtc, fb,\n\t\t\t\t\t  crtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t\t\t  src_x, src_y, src_w, src_h, ctx);\n}\n\nstatic int setplane_internal(struct drm_plane *plane,\n\t\t\t     struct drm_crtc *crtc,\n\t\t\t     struct drm_framebuffer *fb,\n\t\t\t     int32_t crtc_x, int32_t crtc_y,\n\t\t\t     uint32_t crtc_w, uint32_t crtc_h,\n\t\t\t      \n\t\t\t     uint32_t src_x, uint32_t src_y,\n\t\t\t     uint32_t src_w, uint32_t src_h)\n{\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret;\n\n\tDRM_MODESET_LOCK_ALL_BEGIN(plane->dev, ctx,\n\t\t\t\t   DRM_MODESET_ACQUIRE_INTERRUPTIBLE, ret);\n\n\tif (drm_drv_uses_atomic_modeset(plane->dev))\n\t\tret = __setplane_atomic(plane, crtc, fb,\n\t\t\t\t\tcrtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t\t\tsrc_x, src_y, src_w, src_h, &ctx);\n\telse\n\t\tret = __setplane_internal(plane, crtc, fb,\n\t\t\t\t\t  crtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t\t\t  src_x, src_y, src_w, src_h, &ctx);\n\n\tDRM_MODESET_LOCK_ALL_END(plane->dev, ctx, ret);\n\n\treturn ret;\n}\n\nint drm_mode_setplane(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_mode_set_plane *plane_req = data;\n\tstruct drm_plane *plane;\n\tstruct drm_crtc *crtc = NULL;\n\tstruct drm_framebuffer *fb = NULL;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tplane = drm_plane_find(dev, file_priv, plane_req->plane_id);\n\tif (!plane) {\n\t\tDRM_DEBUG_KMS(\"Unknown plane ID %d\\n\",\n\t\t\t      plane_req->plane_id);\n\t\treturn -ENOENT;\n\t}\n\n\tif (plane_req->fb_id) {\n\t\tfb = drm_framebuffer_lookup(dev, file_priv, plane_req->fb_id);\n\t\tif (!fb) {\n\t\t\tDRM_DEBUG_KMS(\"Unknown framebuffer ID %d\\n\",\n\t\t\t\t      plane_req->fb_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tcrtc = drm_crtc_find(dev, file_priv, plane_req->crtc_id);\n\t\tif (!crtc) {\n\t\t\tdrm_framebuffer_put(fb);\n\t\t\tDRM_DEBUG_KMS(\"Unknown crtc ID %d\\n\",\n\t\t\t\t      plane_req->crtc_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tret = setplane_internal(plane, crtc, fb,\n\t\t\t\tplane_req->crtc_x, plane_req->crtc_y,\n\t\t\t\tplane_req->crtc_w, plane_req->crtc_h,\n\t\t\t\tplane_req->src_x, plane_req->src_y,\n\t\t\t\tplane_req->src_w, plane_req->src_h);\n\n\tif (fb)\n\t\tdrm_framebuffer_put(fb);\n\n\treturn ret;\n}\n\nstatic int drm_mode_cursor_universal(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_mode_cursor2 *req,\n\t\t\t\t     struct drm_file *file_priv,\n\t\t\t\t     struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_plane *plane = crtc->cursor;\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_mode_fb_cmd2 fbreq = {\n\t\t.width = req->width,\n\t\t.height = req->height,\n\t\t.pixel_format = DRM_FORMAT_ARGB8888,\n\t\t.pitches = { req->width * 4 },\n\t\t.handles = { req->handle },\n\t};\n\tint32_t crtc_x, crtc_y;\n\tuint32_t crtc_w = 0, crtc_h = 0;\n\tuint32_t src_w = 0, src_h = 0;\n\tint ret = 0;\n\n\tBUG_ON(!plane);\n\tWARN_ON(plane->crtc != crtc && plane->crtc != NULL);\n\n\t \n\tif (req->flags & DRM_MODE_CURSOR_BO) {\n\t\tif (req->handle) {\n\t\t\tfb = drm_internal_framebuffer_create(dev, &fbreq, file_priv);\n\t\t\tif (IS_ERR(fb)) {\n\t\t\t\tDRM_DEBUG_KMS(\"failed to wrap cursor buffer in drm framebuffer\\n\");\n\t\t\t\treturn PTR_ERR(fb);\n\t\t\t}\n\n\t\t\tfb->hot_x = req->hot_x;\n\t\t\tfb->hot_y = req->hot_y;\n\t\t} else {\n\t\t\tfb = NULL;\n\t\t}\n\t} else {\n\t\tif (plane->state)\n\t\t\tfb = plane->state->fb;\n\t\telse\n\t\t\tfb = plane->fb;\n\n\t\tif (fb)\n\t\t\tdrm_framebuffer_get(fb);\n\t}\n\n\tif (req->flags & DRM_MODE_CURSOR_MOVE) {\n\t\tcrtc_x = req->x;\n\t\tcrtc_y = req->y;\n\t} else {\n\t\tcrtc_x = crtc->cursor_x;\n\t\tcrtc_y = crtc->cursor_y;\n\t}\n\n\tif (fb) {\n\t\tcrtc_w = fb->width;\n\t\tcrtc_h = fb->height;\n\t\tsrc_w = fb->width << 16;\n\t\tsrc_h = fb->height << 16;\n\t}\n\n\tif (drm_drv_uses_atomic_modeset(dev))\n\t\tret = __setplane_atomic(plane, crtc, fb,\n\t\t\t\t\tcrtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t\t\t0, 0, src_w, src_h, ctx);\n\telse\n\t\tret = __setplane_internal(plane, crtc, fb,\n\t\t\t\t\t  crtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t\t\t  0, 0, src_w, src_h, ctx);\n\n\tif (fb)\n\t\tdrm_framebuffer_put(fb);\n\n\t \n\tif (ret == 0 && req->flags & DRM_MODE_CURSOR_MOVE) {\n\t\tcrtc->cursor_x = req->x;\n\t\tcrtc->cursor_y = req->y;\n\t}\n\n\treturn ret;\n}\n\nstatic int drm_mode_cursor_common(struct drm_device *dev,\n\t\t\t\t  struct drm_mode_cursor2 *req,\n\t\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!req->flags || (~DRM_MODE_CURSOR_FLAGS & req->flags))\n\t\treturn -EINVAL;\n\n\tcrtc = drm_crtc_find(dev, file_priv, req->crtc_id);\n\tif (!crtc) {\n\t\tDRM_DEBUG_KMS(\"Unknown CRTC ID %d\\n\", req->crtc_id);\n\t\treturn -ENOENT;\n\t}\n\n\tdrm_modeset_acquire_init(&ctx, DRM_MODESET_ACQUIRE_INTERRUPTIBLE);\nretry:\n\tret = drm_modeset_lock(&crtc->mutex, &ctx);\n\tif (ret)\n\t\tgoto out;\n\t \n\tif (crtc->cursor) {\n\t\tret = drm_modeset_lock(&crtc->cursor->mutex, &ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!drm_lease_held(file_priv, crtc->cursor->base.id)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = drm_mode_cursor_universal(crtc, req, file_priv, &ctx);\n\t\tgoto out;\n\t}\n\n\tif (req->flags & DRM_MODE_CURSOR_BO) {\n\t\tif (!crtc->funcs->cursor_set && !crtc->funcs->cursor_set2) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (crtc->funcs->cursor_set2)\n\t\t\tret = crtc->funcs->cursor_set2(crtc, file_priv, req->handle,\n\t\t\t\t\t\t      req->width, req->height, req->hot_x, req->hot_y);\n\t\telse\n\t\t\tret = crtc->funcs->cursor_set(crtc, file_priv, req->handle,\n\t\t\t\t\t\t      req->width, req->height);\n\t}\n\n\tif (req->flags & DRM_MODE_CURSOR_MOVE) {\n\t\tif (crtc->funcs->cursor_move) {\n\t\t\tret = crtc->funcs->cursor_move(crtc, req->x, req->y);\n\t\t} else {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tif (ret == -EDEADLK) {\n\t\tret = drm_modeset_backoff(&ctx);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\treturn ret;\n\n}\n\n\nint drm_mode_cursor_ioctl(struct drm_device *dev,\n\t\t\t  void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_cursor *req = data;\n\tstruct drm_mode_cursor2 new_req;\n\n\tmemcpy(&new_req, req, sizeof(struct drm_mode_cursor));\n\tnew_req.hot_x = new_req.hot_y = 0;\n\n\treturn drm_mode_cursor_common(dev, &new_req, file_priv);\n}\n\n \nint drm_mode_cursor2_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_cursor2 *req = data;\n\n\treturn drm_mode_cursor_common(dev, req, file_priv);\n}\n\nint drm_mode_page_flip_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc_page_flip_target *page_flip = data;\n\tstruct drm_crtc *crtc;\n\tstruct drm_plane *plane;\n\tstruct drm_framebuffer *fb = NULL, *old_fb;\n\tstruct drm_pending_vblank_event *e = NULL;\n\tu32 target_vblank = page_flip->sequence;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret = -EINVAL;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tif (page_flip->flags & ~DRM_MODE_PAGE_FLIP_FLAGS)\n\t\treturn -EINVAL;\n\n\tif (page_flip->sequence != 0 && !(page_flip->flags & DRM_MODE_PAGE_FLIP_TARGET))\n\t\treturn -EINVAL;\n\n\t \n\tif ((page_flip->flags & DRM_MODE_PAGE_FLIP_TARGET) == DRM_MODE_PAGE_FLIP_TARGET)\n\t\treturn -EINVAL;\n\n\tif ((page_flip->flags & DRM_MODE_PAGE_FLIP_ASYNC) && !dev->mode_config.async_page_flip)\n\t\treturn -EINVAL;\n\n\tcrtc = drm_crtc_find(dev, file_priv, page_flip->crtc_id);\n\tif (!crtc)\n\t\treturn -ENOENT;\n\n\tplane = crtc->primary;\n\n\tif (!drm_lease_held(file_priv, plane->base.id))\n\t\treturn -EACCES;\n\n\tif (crtc->funcs->page_flip_target) {\n\t\tu32 current_vblank;\n\t\tint r;\n\n\t\tr = drm_crtc_vblank_get(crtc);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tcurrent_vblank = (u32)drm_crtc_vblank_count(crtc);\n\n\t\tswitch (page_flip->flags & DRM_MODE_PAGE_FLIP_TARGET) {\n\t\tcase DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE:\n\t\t\tif ((int)(target_vblank - current_vblank) > 1) {\n\t\t\t\tDRM_DEBUG(\"Invalid absolute flip target %u, \"\n\t\t\t\t\t  \"must be <= %u\\n\", target_vblank,\n\t\t\t\t\t  current_vblank + 1);\n\t\t\t\tdrm_crtc_vblank_put(crtc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DRM_MODE_PAGE_FLIP_TARGET_RELATIVE:\n\t\t\tif (target_vblank != 0 && target_vblank != 1) {\n\t\t\t\tDRM_DEBUG(\"Invalid relative flip target %u, \"\n\t\t\t\t\t  \"must be 0 or 1\\n\", target_vblank);\n\t\t\t\tdrm_crtc_vblank_put(crtc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttarget_vblank += current_vblank;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttarget_vblank = current_vblank +\n\t\t\t\t!(page_flip->flags & DRM_MODE_PAGE_FLIP_ASYNC);\n\t\t\tbreak;\n\t\t}\n\t} else if (crtc->funcs->page_flip == NULL ||\n\t\t   (page_flip->flags & DRM_MODE_PAGE_FLIP_TARGET)) {\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_modeset_acquire_init(&ctx, DRM_MODESET_ACQUIRE_INTERRUPTIBLE);\nretry:\n\tret = drm_modeset_lock(&crtc->mutex, &ctx);\n\tif (ret)\n\t\tgoto out;\n\tret = drm_modeset_lock(&plane->mutex, &ctx);\n\tif (ret)\n\t\tgoto out;\n\n\tif (plane->state)\n\t\told_fb = plane->state->fb;\n\telse\n\t\told_fb = plane->fb;\n\n\tif (old_fb == NULL) {\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tfb = drm_framebuffer_lookup(dev, file_priv, page_flip->fb_id);\n\tif (!fb) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (plane->state) {\n\t\tconst struct drm_plane_state *state = plane->state;\n\n\t\tret = drm_framebuffer_check_src_coords(state->src_x,\n\t\t\t\t\t\t       state->src_y,\n\t\t\t\t\t\t       state->src_w,\n\t\t\t\t\t\t       state->src_h,\n\t\t\t\t\t\t       fb);\n\t} else {\n\t\tret = drm_crtc_check_viewport(crtc, crtc->x, crtc->y,\n\t\t\t\t\t      &crtc->mode, fb);\n\t}\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (old_fb->format->format != fb->format->format) {\n\t\tDRM_DEBUG_KMS(\"Page flip is not allowed to change frame buffer format.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (page_flip->flags & DRM_MODE_PAGE_FLIP_EVENT) {\n\t\te = kzalloc(sizeof *e, GFP_KERNEL);\n\t\tif (!e) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\te->event.base.type = DRM_EVENT_FLIP_COMPLETE;\n\t\te->event.base.length = sizeof(e->event);\n\t\te->event.vbl.user_data = page_flip->user_data;\n\t\te->event.vbl.crtc_id = crtc->base.id;\n\n\t\tret = drm_event_reserve_init(dev, file_priv, &e->base, &e->event.base);\n\t\tif (ret) {\n\t\t\tkfree(e);\n\t\t\te = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tplane->old_fb = plane->fb;\n\tif (crtc->funcs->page_flip_target)\n\t\tret = crtc->funcs->page_flip_target(crtc, fb, e,\n\t\t\t\t\t\t    page_flip->flags,\n\t\t\t\t\t\t    target_vblank,\n\t\t\t\t\t\t    &ctx);\n\telse\n\t\tret = crtc->funcs->page_flip(crtc, fb, e, page_flip->flags,\n\t\t\t\t\t     &ctx);\n\tif (ret) {\n\t\tif (page_flip->flags & DRM_MODE_PAGE_FLIP_EVENT)\n\t\t\tdrm_event_cancel_free(dev, &e->base);\n\t\t \n\t\tplane->old_fb = NULL;\n\t} else {\n\t\tif (!plane->state) {\n\t\t\tplane->fb = fb;\n\t\t\tdrm_framebuffer_get(fb);\n\t\t}\n\t}\n\nout:\n\tif (fb)\n\t\tdrm_framebuffer_put(fb);\n\tif (plane->old_fb)\n\t\tdrm_framebuffer_put(plane->old_fb);\n\tplane->old_fb = NULL;\n\n\tif (ret == -EDEADLK) {\n\t\tret = drm_modeset_backoff(&ctx);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\tif (ret && crtc->funcs->page_flip_target)\n\t\tdrm_crtc_vblank_put(crtc);\n\n\treturn ret;\n}\n\n \n\n \nvoid drm_plane_enable_fb_damage_clips(struct drm_plane *plane)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\n\tdrm_object_attach_property(&plane->base, config->prop_fb_damage_clips,\n\t\t\t\t   0);\n}\nEXPORT_SYMBOL(drm_plane_enable_fb_damage_clips);\n\n \nunsigned int\ndrm_plane_get_damage_clips_count(const struct drm_plane_state *state)\n{\n\treturn (state && state->fb_damage_clips) ?\n\t\tstate->fb_damage_clips->length/sizeof(struct drm_mode_rect) : 0;\n}\nEXPORT_SYMBOL(drm_plane_get_damage_clips_count);\n\nstruct drm_mode_rect *\n__drm_plane_get_damage_clips(const struct drm_plane_state *state)\n{\n\treturn (struct drm_mode_rect *)((state && state->fb_damage_clips) ?\n\t\t\t\t\tstate->fb_damage_clips->data : NULL);\n}\n\n \nstruct drm_mode_rect *\ndrm_plane_get_damage_clips(const struct drm_plane_state *state)\n{\n\tstruct drm_device *dev = state->plane->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\n\t \n\tif (!drm_mode_obj_find_prop_id(&state->plane->base,\n\t\t\t\t       config->prop_fb_damage_clips->base.id))\n\t\tdrm_warn_once(dev, \"drm_plane_enable_fb_damage_clips() not called\\n\");\n\n\treturn __drm_plane_get_damage_clips(state);\n}\nEXPORT_SYMBOL(drm_plane_get_damage_clips);\n\nstruct drm_property *\ndrm_create_scaling_filter_prop(struct drm_device *dev,\n\t\t\t       unsigned int supported_filters)\n{\n\tstruct drm_property *prop;\n\tstatic const struct drm_prop_enum_list props[] = {\n\t\t{ DRM_SCALING_FILTER_DEFAULT, \"Default\" },\n\t\t{ DRM_SCALING_FILTER_NEAREST_NEIGHBOR, \"Nearest Neighbor\" },\n\t};\n\tunsigned int valid_mode_mask = BIT(DRM_SCALING_FILTER_DEFAULT) |\n\t\t\t\t       BIT(DRM_SCALING_FILTER_NEAREST_NEIGHBOR);\n\tint i;\n\n\tif (WARN_ON((supported_filters & ~valid_mode_mask) ||\n\t\t    ((supported_filters & BIT(DRM_SCALING_FILTER_DEFAULT)) == 0)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tprop = drm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t   \"SCALING_FILTER\",\n\t\t\t\t   hweight32(supported_filters));\n\tif (!prop)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < ARRAY_SIZE(props); i++) {\n\t\tint ret;\n\n\t\tif (!(BIT(props[i].type) & supported_filters))\n\t\t\tcontinue;\n\n\t\tret = drm_property_add_enum(prop, props[i].type,\n\t\t\t\t\t    props[i].name);\n\n\t\tif (ret) {\n\t\t\tdrm_property_destroy(dev, prop);\n\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn prop;\n}\n\n \nint drm_plane_create_scaling_filter_property(struct drm_plane *plane,\n\t\t\t\t\t     unsigned int supported_filters)\n{\n\tstruct drm_property *prop =\n\t\tdrm_create_scaling_filter_prop(plane->dev, supported_filters);\n\n\tif (IS_ERR(prop))\n\t\treturn PTR_ERR(prop);\n\n\tdrm_object_attach_property(&plane->base, prop,\n\t\t\t\t   DRM_SCALING_FILTER_DEFAULT);\n\tplane->scaling_filter_property = prop;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_plane_create_scaling_filter_property);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}