{
  "module_name": "vgem_fence.c",
  "hash_id": "19af9a67101c7c709157060107ec44805d8298e0e8426c792493b70f90b6478b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vgem/vgem_fence.c",
  "human_readable_source": " \n\n#include <linux/dma-buf.h>\n#include <linux/dma-resv.h>\n\n#include <drm/drm_file.h>\n\n#include \"vgem_drv.h\"\n\n#define VGEM_FENCE_TIMEOUT (10*HZ)\n\nstruct vgem_fence {\n\tstruct dma_fence base;\n\tstruct spinlock lock;\n\tstruct timer_list timer;\n};\n\nstatic const char *vgem_fence_get_driver_name(struct dma_fence *fence)\n{\n\treturn \"vgem\";\n}\n\nstatic const char *vgem_fence_get_timeline_name(struct dma_fence *fence)\n{\n\treturn \"unbound\";\n}\n\nstatic void vgem_fence_release(struct dma_fence *base)\n{\n\tstruct vgem_fence *fence = container_of(base, typeof(*fence), base);\n\n\tdel_timer_sync(&fence->timer);\n\tdma_fence_free(&fence->base);\n}\n\nstatic void vgem_fence_value_str(struct dma_fence *fence, char *str, int size)\n{\n\tsnprintf(str, size, \"%llu\", fence->seqno);\n}\n\nstatic void vgem_fence_timeline_value_str(struct dma_fence *fence, char *str,\n\t\t\t\t\t  int size)\n{\n\tsnprintf(str, size, \"%llu\",\n\t\t dma_fence_is_signaled(fence) ? fence->seqno : 0);\n}\n\nstatic const struct dma_fence_ops vgem_fence_ops = {\n\t.get_driver_name = vgem_fence_get_driver_name,\n\t.get_timeline_name = vgem_fence_get_timeline_name,\n\t.release = vgem_fence_release,\n\n\t.fence_value_str = vgem_fence_value_str,\n\t.timeline_value_str = vgem_fence_timeline_value_str,\n};\n\nstatic void vgem_fence_timeout(struct timer_list *t)\n{\n\tstruct vgem_fence *fence = from_timer(fence, t, timer);\n\n\tdma_fence_signal(&fence->base);\n}\n\nstatic struct dma_fence *vgem_fence_create(struct vgem_file *vfile,\n\t\t\t\t\t   unsigned int flags)\n{\n\tstruct vgem_fence *fence;\n\n\tfence = kzalloc(sizeof(*fence), GFP_KERNEL);\n\tif (!fence)\n\t\treturn NULL;\n\n\tspin_lock_init(&fence->lock);\n\tdma_fence_init(&fence->base, &vgem_fence_ops, &fence->lock,\n\t\t       dma_fence_context_alloc(1), 1);\n\n\ttimer_setup(&fence->timer, vgem_fence_timeout, 0);\n\n\t \n\tmod_timer(&fence->timer, jiffies + VGEM_FENCE_TIMEOUT);\n\n\treturn &fence->base;\n}\n\n \nint vgem_fence_attach_ioctl(struct drm_device *dev,\n\t\t\t    void *data,\n\t\t\t    struct drm_file *file)\n{\n\tstruct drm_vgem_fence_attach *arg = data;\n\tstruct vgem_file *vfile = file->driver_priv;\n\tstruct dma_resv *resv;\n\tstruct drm_gem_object *obj;\n\tenum dma_resv_usage usage;\n\tstruct dma_fence *fence;\n\tint ret;\n\n\tif (arg->flags & ~VGEM_FENCE_WRITE)\n\t\treturn -EINVAL;\n\n\tif (arg->pad)\n\t\treturn -EINVAL;\n\n\tobj = drm_gem_object_lookup(file, arg->handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tfence = vgem_fence_create(vfile, arg->flags);\n\tif (!fence) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tresv = obj->resv;\n\tusage = dma_resv_usage_rw(arg->flags & VGEM_FENCE_WRITE);\n\tif (!dma_resv_test_signaled(resv, usage)) {\n\t\tret = -EBUSY;\n\t\tgoto err_fence;\n\t}\n\n\t \n\tdma_resv_lock(resv, NULL);\n\tret = dma_resv_reserve_fences(resv, 1);\n\tif (!ret)\n\t\tdma_resv_add_fence(resv, fence, arg->flags & VGEM_FENCE_WRITE ?\n\t\t\t\t   DMA_RESV_USAGE_WRITE : DMA_RESV_USAGE_READ);\n\tdma_resv_unlock(resv);\n\n\t \n\tif (ret == 0) {\n\t\tmutex_lock(&vfile->fence_mutex);\n\t\tret = idr_alloc(&vfile->fence_idr, fence, 1, 0, GFP_KERNEL);\n\t\tmutex_unlock(&vfile->fence_mutex);\n\t\tif (ret > 0) {\n\t\t\targ->out_fence = ret;\n\t\t\tret = 0;\n\t\t}\n\t}\nerr_fence:\n\tif (ret) {\n\t\tdma_fence_signal(fence);\n\t\tdma_fence_put(fence);\n\t}\nerr:\n\tdrm_gem_object_put(obj);\n\treturn ret;\n}\n\n \nint vgem_fence_signal_ioctl(struct drm_device *dev,\n\t\t\t    void *data,\n\t\t\t    struct drm_file *file)\n{\n\tstruct vgem_file *vfile = file->driver_priv;\n\tstruct drm_vgem_fence_signal *arg = data;\n\tstruct dma_fence *fence;\n\tint ret = 0;\n\n\tif (arg->flags)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&vfile->fence_mutex);\n\tfence = idr_replace(&vfile->fence_idr, NULL, arg->fence);\n\tmutex_unlock(&vfile->fence_mutex);\n\tif (!fence)\n\t\treturn -ENOENT;\n\tif (IS_ERR(fence))\n\t\treturn PTR_ERR(fence);\n\n\tif (dma_fence_is_signaled(fence))\n\t\tret = -ETIMEDOUT;\n\n\tdma_fence_signal(fence);\n\tdma_fence_put(fence);\n\treturn ret;\n}\n\nint vgem_fence_open(struct vgem_file *vfile)\n{\n\tmutex_init(&vfile->fence_mutex);\n\tidr_init_base(&vfile->fence_idr, 1);\n\n\treturn 0;\n}\n\nstatic int __vgem_fence_idr_fini(int id, void *p, void *data)\n{\n\tdma_fence_signal(p);\n\tdma_fence_put(p);\n\treturn 0;\n}\n\nvoid vgem_fence_close(struct vgem_file *vfile)\n{\n\tidr_for_each(&vfile->fence_idr, __vgem_fence_idr_fini, vfile);\n\tidr_destroy(&vfile->fence_idr);\n\tmutex_destroy(&vfile->fence_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}