{
  "module_name": "vgem_drv.c",
  "hash_id": "dbf722cd5ef7cd157ac5327b8d7479e779c2736fed56527f2408868606261696",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vgem/vgem_drv.c",
  "human_readable_source": " \n\n \n\n#include <linux/dma-buf.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/shmem_fs.h>\n#include <linux/vmalloc.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_prime.h>\n\n#include \"vgem_drv.h\"\n\n#define DRIVER_NAME\t\"vgem\"\n#define DRIVER_DESC\t\"Virtual GEM provider\"\n#define DRIVER_DATE\t\"20120112\"\n#define DRIVER_MAJOR\t1\n#define DRIVER_MINOR\t0\n\nstatic struct vgem_device {\n\tstruct drm_device drm;\n\tstruct platform_device *platform;\n} *vgem_device;\n\nstatic int vgem_open(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct vgem_file *vfile;\n\tint ret;\n\n\tvfile = kzalloc(sizeof(*vfile), GFP_KERNEL);\n\tif (!vfile)\n\t\treturn -ENOMEM;\n\n\tfile->driver_priv = vfile;\n\n\tret = vgem_fence_open(vfile);\n\tif (ret) {\n\t\tkfree(vfile);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void vgem_postclose(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct vgem_file *vfile = file->driver_priv;\n\n\tvgem_fence_close(vfile);\n\tkfree(vfile);\n}\n\nstatic struct drm_ioctl_desc vgem_ioctls[] = {\n\tDRM_IOCTL_DEF_DRV(VGEM_FENCE_ATTACH, vgem_fence_attach_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VGEM_FENCE_SIGNAL, vgem_fence_signal_ioctl, DRM_RENDER_ALLOW),\n};\n\nDEFINE_DRM_GEM_FOPS(vgem_driver_fops);\n\nstatic struct drm_gem_object *vgem_gem_create_object(struct drm_device *dev, size_t size)\n{\n\tstruct drm_gem_shmem_object *obj;\n\n\tobj = kzalloc(sizeof(*obj), GFP_KERNEL);\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tobj->map_wc = true;\n\n\treturn &obj->base;\n}\n\nstatic const struct drm_driver vgem_driver = {\n\t.driver_features\t\t= DRIVER_GEM | DRIVER_RENDER,\n\t.open\t\t\t\t= vgem_open,\n\t.postclose\t\t\t= vgem_postclose,\n\t.ioctls\t\t\t\t= vgem_ioctls,\n\t.num_ioctls \t\t\t= ARRAY_SIZE(vgem_ioctls),\n\t.fops\t\t\t\t= &vgem_driver_fops,\n\n\tDRM_GEM_SHMEM_DRIVER_OPS,\n\t.gem_create_object\t\t= vgem_gem_create_object,\n\n\t.name\t= DRIVER_NAME,\n\t.desc\t= DRIVER_DESC,\n\t.date\t= DRIVER_DATE,\n\t.major\t= DRIVER_MAJOR,\n\t.minor\t= DRIVER_MINOR,\n};\n\nstatic int __init vgem_init(void)\n{\n\tint ret;\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_register_simple(\"vgem\", -1, NULL, 0);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\tif (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tdma_coerce_mask_and_coherent(&pdev->dev,\n\t\t\t\t     DMA_BIT_MASK(64));\n\n\tvgem_device = devm_drm_dev_alloc(&pdev->dev, &vgem_driver,\n\t\t\t\t\t struct vgem_device, drm);\n\tif (IS_ERR(vgem_device)) {\n\t\tret = PTR_ERR(vgem_device);\n\t\tgoto out_devres;\n\t}\n\tvgem_device->platform = pdev;\n\n\t \n\tret = drm_dev_register(&vgem_device->drm, 0);\n\tif (ret)\n\t\tgoto out_devres;\n\n\treturn 0;\n\nout_devres:\n\tdevres_release_group(&pdev->dev, NULL);\nout_unregister:\n\tplatform_device_unregister(pdev);\n\treturn ret;\n}\n\nstatic void __exit vgem_exit(void)\n{\n\tstruct platform_device *pdev = vgem_device->platform;\n\n\tdrm_dev_unregister(&vgem_device->drm);\n\tdevres_release_group(&pdev->dev, NULL);\n\tplatform_device_unregister(pdev);\n}\n\nmodule_init(vgem_init);\nmodule_exit(vgem_exit);\n\nMODULE_AUTHOR(\"Red Hat, Inc.\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}