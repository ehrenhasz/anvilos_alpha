{
  "module_name": "drm_pci.c",
  "hash_id": "359b316ec9b9a5e254ba54f24d472a67ec2686dfc51a53d59f7c0a16d419a096",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_pci.c",
  "human_readable_source": " \n\n#include <linux/dma-mapping.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <drm/drm.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_print.h>\n\n#include \"drm_internal.h\"\n#include \"drm_legacy.h\"\n\n#ifdef CONFIG_DRM_LEGACY\n \nstatic LIST_HEAD(legacy_dev_list);\nstatic DEFINE_MUTEX(legacy_dev_list_lock);\n#endif\n\nstatic int drm_get_pci_domain(struct drm_device *dev)\n{\n#ifndef __alpha__\n\t \n\tif (dev->if_version < 0x10004)\n\t\treturn 0;\n#endif  \n\n\treturn pci_domain_nr(to_pci_dev(dev->dev)->bus);\n}\n\nint drm_pci_set_busid(struct drm_device *dev, struct drm_master *master)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tmaster->unique = kasprintf(GFP_KERNEL, \"pci:%04x:%02x:%02x.%d\",\n\t\t\t\t\tdrm_get_pci_domain(dev),\n\t\t\t\t\tpdev->bus->number,\n\t\t\t\t\tPCI_SLOT(pdev->devfn),\n\t\t\t\t\tPCI_FUNC(pdev->devfn));\n\tif (!master->unique)\n\t\treturn -ENOMEM;\n\n\tmaster->unique_len = strlen(master->unique);\n\treturn 0;\n}\n\n#ifdef CONFIG_DRM_LEGACY\n\nstatic int drm_legacy_pci_irq_by_busid(struct drm_device *dev, struct drm_irq_busid *p)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tif ((p->busnum >> 8) != drm_get_pci_domain(dev) ||\n\t    (p->busnum & 0xff) != pdev->bus->number ||\n\t    p->devnum != PCI_SLOT(pdev->devfn) || p->funcnum != PCI_FUNC(pdev->devfn))\n\t\treturn -EINVAL;\n\n\tp->irq = pdev->irq;\n\n\tDRM_DEBUG(\"%d:%d:%d => IRQ %d\\n\", p->busnum, p->devnum, p->funcnum,\n\t\t  p->irq);\n\treturn 0;\n}\n\n \nint drm_legacy_irq_by_busid(struct drm_device *dev, void *data,\n\t\t\t    struct drm_file *file_priv)\n{\n\tstruct drm_irq_busid *p = data;\n\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (WARN_ON(!dev_is_pci(dev->dev)))\n\t\treturn -EINVAL;\n\n\tif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\n\t\treturn -EOPNOTSUPP;\n\n\treturn drm_legacy_pci_irq_by_busid(dev, p);\n}\n\nvoid drm_legacy_pci_agp_destroy(struct drm_device *dev)\n{\n\tif (dev->agp) {\n\t\tarch_phys_wc_del(dev->agp->agp_mtrr);\n\t\tdrm_legacy_agp_clear(dev);\n\t\tkfree(dev->agp);\n\t\tdev->agp = NULL;\n\t}\n}\n\nstatic void drm_legacy_pci_agp_init(struct drm_device *dev)\n{\n\tif (drm_core_check_feature(dev, DRIVER_USE_AGP)) {\n\t\tif (pci_find_capability(to_pci_dev(dev->dev), PCI_CAP_ID_AGP))\n\t\t\tdev->agp = drm_legacy_agp_init(dev);\n\t\tif (dev->agp) {\n\t\t\tdev->agp->agp_mtrr = arch_phys_wc_add(\n\t\t\t\tdev->agp->agp_info.aper_base,\n\t\t\t\tdev->agp->agp_info.aper_size *\n\t\t\t\t1024 * 1024);\n\t\t}\n\t}\n}\n\nstatic int drm_legacy_get_pci_dev(struct pci_dev *pdev,\n\t\t\t\t  const struct pci_device_id *ent,\n\t\t\t\t  const struct drm_driver *driver)\n{\n\tstruct drm_device *dev;\n\tint ret;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tdev = drm_dev_alloc(driver, &pdev->dev);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\tgoto err_free;\n\n#ifdef __alpha__\n\tdev->hose = pdev->sysdata;\n#endif\n\n\tdrm_legacy_pci_agp_init(dev);\n\n\tret = drm_dev_register(dev, ent->driver_data);\n\tif (ret)\n\t\tgoto err_agp;\n\n\tif (drm_core_check_feature(dev, DRIVER_LEGACY)) {\n\t\tmutex_lock(&legacy_dev_list_lock);\n\t\tlist_add_tail(&dev->legacy_dev_list, &legacy_dev_list);\n\t\tmutex_unlock(&legacy_dev_list_lock);\n\t}\n\n\treturn 0;\n\nerr_agp:\n\tdrm_legacy_pci_agp_destroy(dev);\n\tpci_disable_device(pdev);\nerr_free:\n\tdrm_dev_put(dev);\n\treturn ret;\n}\n\n \nint drm_legacy_pci_init(const struct drm_driver *driver,\n\t\t\tstruct pci_driver *pdriver)\n{\n\tstruct pci_dev *pdev = NULL;\n\tconst struct pci_device_id *pid;\n\tint i;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tif (WARN_ON(!(driver->driver_features & DRIVER_LEGACY)))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; pdriver->id_table[i].vendor != 0; i++) {\n\t\tpid = &pdriver->id_table[i];\n\n\t\t \n\t\tpdev = NULL;\n\t\twhile ((pdev =\n\t\t\tpci_get_subsys(pid->vendor, pid->device, pid->subvendor,\n\t\t\t\t       pid->subdevice, pdev)) != NULL) {\n\t\t\tif ((pdev->class & pid->class_mask) != pid->class)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tpci_dev_get(pdev);\n\t\t\tdrm_legacy_get_pci_dev(pdev, pid, driver);\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_legacy_pci_init);\n\n \nvoid drm_legacy_pci_exit(const struct drm_driver *driver,\n\t\t\t struct pci_driver *pdriver)\n{\n\tstruct drm_device *dev, *tmp;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tif (!(driver->driver_features & DRIVER_LEGACY)) {\n\t\tWARN_ON(1);\n\t} else {\n\t\tmutex_lock(&legacy_dev_list_lock);\n\t\tlist_for_each_entry_safe(dev, tmp, &legacy_dev_list,\n\t\t\t\t\t legacy_dev_list) {\n\t\t\tif (dev->driver == driver) {\n\t\t\t\tlist_del(&dev->legacy_dev_list);\n\t\t\t\tdrm_put_dev(dev);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&legacy_dev_list_lock);\n\t}\n\tDRM_INFO(\"Module unloaded\\n\");\n}\nEXPORT_SYMBOL(drm_legacy_pci_exit);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}