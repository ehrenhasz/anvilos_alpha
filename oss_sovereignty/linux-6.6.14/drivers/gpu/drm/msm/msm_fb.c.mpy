{
  "module_name": "msm_fb.c",
  "hash_id": "f84a2c33c89c9690f54fe53e746988d91e50a812f7889578a55cb42fe08e1c19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_fb.c",
  "human_readable_source": "\n \n\n#include <drm/drm_crtc.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_file.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"msm_drv.h\"\n#include \"msm_kms.h\"\n#include \"msm_gem.h\"\n\nstruct msm_framebuffer {\n\tstruct drm_framebuffer base;\n\tconst struct msm_format *format;\n\n\t \n\trefcount_t dirtyfb;\n\n\t \n\tuint64_t iova[DRM_FORMAT_MAX_PLANES];\n\tatomic_t prepare_count;\n};\n#define to_msm_framebuffer(x) container_of(x, struct msm_framebuffer, base)\n\nstatic struct drm_framebuffer *msm_framebuffer_init(struct drm_device *dev,\n\t\tconst struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos);\n\nstatic int msm_framebuffer_dirtyfb(struct drm_framebuffer *fb,\n\t\t\t\t   struct drm_file *file_priv, unsigned int flags,\n\t\t\t\t   unsigned int color, struct drm_clip_rect *clips,\n\t\t\t\t   unsigned int num_clips)\n{\n\tstruct msm_framebuffer *msm_fb = to_msm_framebuffer(fb);\n\n\t \n\tif (refcount_read(&msm_fb->dirtyfb) == 1)\n\t\treturn 0;\n\n\treturn drm_atomic_helper_dirtyfb(fb, file_priv, flags, color,\n\t\t\t\t\t clips, num_clips);\n}\n\nstatic const struct drm_framebuffer_funcs msm_framebuffer_funcs = {\n\t.create_handle = drm_gem_fb_create_handle,\n\t.destroy = drm_gem_fb_destroy,\n\t.dirty = msm_framebuffer_dirtyfb,\n};\n\n#ifdef CONFIG_DEBUG_FS\nvoid msm_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)\n{\n\tstruct msm_gem_stats stats = {};\n\tint i, n = fb->format->num_planes;\n\n\tseq_printf(m, \"fb: %dx%d@%4.4s (%2d, ID:%d)\\n\",\n\t\t\tfb->width, fb->height, (char *)&fb->format->format,\n\t\t\tdrm_framebuffer_read_refcount(fb), fb->base.id);\n\n\tfor (i = 0; i < n; i++) {\n\t\tseq_printf(m, \"   %d: offset=%d pitch=%d, obj: \",\n\t\t\t\ti, fb->offsets[i], fb->pitches[i]);\n\t\tmsm_gem_describe(fb->obj[i], m, &stats);\n\t}\n}\n#endif\n\n \nint msm_framebuffer_prepare(struct drm_framebuffer *fb,\n\t\tstruct msm_gem_address_space *aspace,\n\t\tbool needs_dirtyfb)\n{\n\tstruct msm_framebuffer *msm_fb = to_msm_framebuffer(fb);\n\tint ret, i, n = fb->format->num_planes;\n\n\tif (needs_dirtyfb)\n\t\trefcount_inc(&msm_fb->dirtyfb);\n\n\tatomic_inc(&msm_fb->prepare_count);\n\n\tfor (i = 0; i < n; i++) {\n\t\tret = msm_gem_get_and_pin_iova(fb->obj[i], aspace, &msm_fb->iova[i]);\n\t\tdrm_dbg_state(fb->dev, \"FB[%u]: iova[%d]: %08llx (%d)\",\n\t\t\t      fb->base.id, i, msm_fb->iova[i], ret);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid msm_framebuffer_cleanup(struct drm_framebuffer *fb,\n\t\tstruct msm_gem_address_space *aspace,\n\t\tbool needed_dirtyfb)\n{\n\tstruct msm_framebuffer *msm_fb = to_msm_framebuffer(fb);\n\tint i, n = fb->format->num_planes;\n\n\tif (needed_dirtyfb)\n\t\trefcount_dec(&msm_fb->dirtyfb);\n\n\tfor (i = 0; i < n; i++)\n\t\tmsm_gem_unpin_iova(fb->obj[i], aspace);\n\n\tif (!atomic_dec_return(&msm_fb->prepare_count))\n\t\tmemset(msm_fb->iova, 0, sizeof(msm_fb->iova));\n}\n\nuint32_t msm_framebuffer_iova(struct drm_framebuffer *fb,\n\t\tstruct msm_gem_address_space *aspace, int plane)\n{\n\tstruct msm_framebuffer *msm_fb = to_msm_framebuffer(fb);\n\treturn msm_fb->iova[plane] + fb->offsets[plane];\n}\n\nstruct drm_gem_object *msm_framebuffer_bo(struct drm_framebuffer *fb, int plane)\n{\n\treturn drm_gem_fb_get_obj(fb, plane);\n}\n\nconst struct msm_format *msm_framebuffer_format(struct drm_framebuffer *fb)\n{\n\tstruct msm_framebuffer *msm_fb = to_msm_framebuffer(fb);\n\treturn msm_fb->format;\n}\n\nstruct drm_framebuffer *msm_framebuffer_create(struct drm_device *dev,\n\t\tstruct drm_file *file, const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tconst struct drm_format_info *info = drm_get_format_info(dev,\n\t\t\t\t\t\t\t\t mode_cmd);\n\tstruct drm_gem_object *bos[4] = {0};\n\tstruct drm_framebuffer *fb;\n\tint ret, i, n = info->num_planes;\n\n\tfor (i = 0; i < n; i++) {\n\t\tbos[i] = drm_gem_object_lookup(file, mode_cmd->handles[i]);\n\t\tif (!bos[i]) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto out_unref;\n\t\t}\n\t}\n\n\tfb = msm_framebuffer_init(dev, mode_cmd, bos);\n\tif (IS_ERR(fb)) {\n\t\tret = PTR_ERR(fb);\n\t\tgoto out_unref;\n\t}\n\n\treturn fb;\n\nout_unref:\n\tfor (i = 0; i < n; i++)\n\t\tdrm_gem_object_put(bos[i]);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct drm_framebuffer *msm_framebuffer_init(struct drm_device *dev,\n\t\tconst struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)\n{\n\tconst struct drm_format_info *info = drm_get_format_info(dev,\n\t\t\t\t\t\t\t\t mode_cmd);\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct msm_kms *kms = priv->kms;\n\tstruct msm_framebuffer *msm_fb = NULL;\n\tstruct drm_framebuffer *fb;\n\tconst struct msm_format *format;\n\tint ret, i, n;\n\n\tdrm_dbg_state(dev, \"create framebuffer: mode_cmd=%p (%dx%d@%4.4s)\",\n\t\t\tmode_cmd, mode_cmd->width, mode_cmd->height,\n\t\t\t(char *)&mode_cmd->pixel_format);\n\n\tn = info->num_planes;\n\tformat = kms->funcs->get_format(kms, mode_cmd->pixel_format,\n\t\t\tmode_cmd->modifier[0]);\n\tif (!format) {\n\t\tDRM_DEV_ERROR(dev->dev, \"unsupported pixel format: %4.4s\\n\",\n\t\t\t\t(char *)&mode_cmd->pixel_format);\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tmsm_fb = kzalloc(sizeof(*msm_fb), GFP_KERNEL);\n\tif (!msm_fb) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tfb = &msm_fb->base;\n\n\tmsm_fb->format = format;\n\n\tif (n > ARRAY_SIZE(fb->obj)) {\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned int width = mode_cmd->width / (i ? info->hsub : 1);\n\t\tunsigned int height = mode_cmd->height / (i ? info->vsub : 1);\n\t\tunsigned int min_size;\n\n\t\tmin_size = (height - 1) * mode_cmd->pitches[i]\n\t\t\t + width * info->cpp[i]\n\t\t\t + mode_cmd->offsets[i];\n\n\t\tif (bos[i]->size < min_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tmsm_fb->base.obj[i] = bos[i];\n\t}\n\n\tdrm_helper_mode_fill_fb_struct(dev, fb, mode_cmd);\n\n\tret = drm_framebuffer_init(dev, fb, &msm_framebuffer_funcs);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev->dev, \"framebuffer init failed: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\trefcount_set(&msm_fb->dirtyfb, 1);\n\n\tdrm_dbg_state(dev, \"create: FB ID: %d (%p)\", fb->base.id, fb);\n\n\treturn fb;\n\nfail:\n\tkfree(msm_fb);\n\n\treturn ERR_PTR(ret);\n}\n\nstruct drm_framebuffer *\nmsm_alloc_stolen_fb(struct drm_device *dev, int w, int h, int p, uint32_t format)\n{\n\tstruct drm_mode_fb_cmd2 mode_cmd = {\n\t\t.pixel_format = format,\n\t\t.width = w,\n\t\t.height = h,\n\t\t.pitches = { p },\n\t};\n\tstruct drm_gem_object *bo;\n\tstruct drm_framebuffer *fb;\n\tint size;\n\n\t \n\tsize = mode_cmd.pitches[0] * mode_cmd.height;\n\tDBG(\"allocating %d bytes for fb %d\", size, dev->primary->index);\n\tbo = msm_gem_new(dev, size, MSM_BO_SCANOUT | MSM_BO_WC | MSM_BO_STOLEN);\n\tif (IS_ERR(bo)) {\n\t\tdev_warn(dev->dev, \"could not allocate stolen bo\\n\");\n\t\t \n\t\tbo = msm_gem_new(dev, size, MSM_BO_SCANOUT | MSM_BO_WC);\n\t}\n\tif (IS_ERR(bo)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to allocate buffer object\\n\");\n\t\treturn ERR_CAST(bo);\n\t}\n\n\tmsm_gem_object_set_name(bo, \"stolenfb\");\n\n\tfb = msm_framebuffer_init(dev, &mode_cmd, &bo);\n\tif (IS_ERR(fb)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to allocate fb\\n\");\n\t\t \n\t\tdrm_gem_object_put(bo);\n\t\treturn ERR_CAST(fb);\n\t}\n\n\treturn fb;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}