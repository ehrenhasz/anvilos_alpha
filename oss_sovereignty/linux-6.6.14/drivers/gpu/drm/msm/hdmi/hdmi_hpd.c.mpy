{
  "module_name": "hdmi_hpd.c",
  "hash_id": "7a8d20e0b3a6012e511bdd06ed1be4804cc9d4057f292321922dae48d64675d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/hdmi/hdmi_hpd.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/pinctrl/consumer.h>\n\n#include \"msm_kms.h\"\n#include \"hdmi.h\"\n\nstatic void msm_hdmi_phy_reset(struct hdmi *hdmi)\n{\n\tunsigned int val;\n\n\tval = hdmi_read(hdmi, REG_HDMI_PHY_CTRL);\n\n\tif (val & HDMI_PHY_CTRL_SW_RESET_LOW) {\n\t\t \n\t\thdmi_write(hdmi, REG_HDMI_PHY_CTRL,\n\t\t\t\tval & ~HDMI_PHY_CTRL_SW_RESET);\n\t} else {\n\t\t \n\t\thdmi_write(hdmi, REG_HDMI_PHY_CTRL,\n\t\t\t\tval | HDMI_PHY_CTRL_SW_RESET);\n\t}\n\n\tif (val & HDMI_PHY_CTRL_SW_RESET_PLL_LOW) {\n\t\t \n\t\thdmi_write(hdmi, REG_HDMI_PHY_CTRL,\n\t\t\t\tval & ~HDMI_PHY_CTRL_SW_RESET_PLL);\n\t} else {\n\t\t \n\t\thdmi_write(hdmi, REG_HDMI_PHY_CTRL,\n\t\t\t\tval | HDMI_PHY_CTRL_SW_RESET_PLL);\n\t}\n\n\tmsleep(100);\n\n\tif (val & HDMI_PHY_CTRL_SW_RESET_LOW) {\n\t\t \n\t\thdmi_write(hdmi, REG_HDMI_PHY_CTRL,\n\t\t\t\tval | HDMI_PHY_CTRL_SW_RESET);\n\t} else {\n\t\t \n\t\thdmi_write(hdmi, REG_HDMI_PHY_CTRL,\n\t\t\t\tval & ~HDMI_PHY_CTRL_SW_RESET);\n\t}\n\n\tif (val & HDMI_PHY_CTRL_SW_RESET_PLL_LOW) {\n\t\t \n\t\thdmi_write(hdmi, REG_HDMI_PHY_CTRL,\n\t\t\t\tval | HDMI_PHY_CTRL_SW_RESET_PLL);\n\t} else {\n\t\t \n\t\thdmi_write(hdmi, REG_HDMI_PHY_CTRL,\n\t\t\t\tval & ~HDMI_PHY_CTRL_SW_RESET_PLL);\n\t}\n}\n\nstatic void enable_hpd_clocks(struct hdmi *hdmi, bool enable)\n{\n\tconst struct hdmi_platform_config *config = hdmi->config;\n\tstruct device *dev = &hdmi->pdev->dev;\n\tint i, ret;\n\n\tif (enable) {\n\t\tfor (i = 0; i < config->hpd_clk_cnt; i++) {\n\t\t\tif (config->hpd_freq && config->hpd_freq[i]) {\n\t\t\t\tret = clk_set_rate(hdmi->hpd_clks[i],\n\t\t\t\t\t\t   config->hpd_freq[i]);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_warn(dev,\n\t\t\t\t\t\t \"failed to set clk %s (%d)\\n\",\n\t\t\t\t\t\t config->hpd_clk_names[i], ret);\n\t\t\t}\n\n\t\t\tret = clk_prepare_enable(hdmi->hpd_clks[i]);\n\t\t\tif (ret) {\n\t\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t\t\"failed to enable hpd clk: %s (%d)\\n\",\n\t\t\t\t\tconfig->hpd_clk_names[i], ret);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = config->hpd_clk_cnt - 1; i >= 0; i--)\n\t\t\tclk_disable_unprepare(hdmi->hpd_clks[i]);\n\t}\n}\n\nint msm_hdmi_hpd_enable(struct drm_bridge *bridge)\n{\n\tstruct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);\n\tstruct hdmi *hdmi = hdmi_bridge->hdmi;\n\tconst struct hdmi_platform_config *config = hdmi->config;\n\tstruct device *dev = &hdmi->pdev->dev;\n\tuint32_t hpd_ctrl;\n\tint ret;\n\tunsigned long flags;\n\n\tret = regulator_bulk_enable(config->hpd_reg_cnt, hdmi->hpd_regs);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to enable hpd regulators: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tret = pinctrl_pm_select_default_state(dev);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"pinctrl state chg failed: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tif (hdmi->hpd_gpiod)\n\t\tgpiod_set_value_cansleep(hdmi->hpd_gpiod, 1);\n\n\tpm_runtime_get_sync(dev);\n\tenable_hpd_clocks(hdmi, true);\n\n\tmsm_hdmi_set_mode(hdmi, false);\n\tmsm_hdmi_phy_reset(hdmi);\n\tmsm_hdmi_set_mode(hdmi, true);\n\n\thdmi_write(hdmi, REG_HDMI_USEC_REFTIMER, 0x0001001b);\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL,\n\t\t\tHDMI_HPD_INT_CTRL_INT_CONNECT |\n\t\t\tHDMI_HPD_INT_CTRL_INT_EN);\n\n\t \n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\thpd_ctrl = hdmi_read(hdmi, REG_HDMI_HPD_CTRL);\n\thpd_ctrl |= HDMI_HPD_CTRL_TIMEOUT(0x1fff);\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HPD_CTRL,\n\t\t\t~HDMI_HPD_CTRL_ENABLE & hpd_ctrl);\n\thdmi_write(hdmi, REG_HDMI_HPD_CTRL,\n\t\t\tHDMI_HPD_CTRL_ENABLE | hpd_ctrl);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\treturn 0;\n\nfail:\n\treturn ret;\n}\n\nvoid msm_hdmi_hpd_disable(struct hdmi_bridge *hdmi_bridge)\n{\n\tstruct hdmi *hdmi = hdmi_bridge->hdmi;\n\tconst struct hdmi_platform_config *config = hdmi->config;\n\tstruct device *dev = &hdmi->pdev->dev;\n\tint ret;\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL, 0);\n\n\tmsm_hdmi_set_mode(hdmi, false);\n\n\tenable_hpd_clocks(hdmi, false);\n\tpm_runtime_put(dev);\n\n\tret = pinctrl_pm_select_sleep_state(dev);\n\tif (ret)\n\t\tdev_warn(dev, \"pinctrl state chg failed: %d\\n\", ret);\n\n\tret = regulator_bulk_disable(config->hpd_reg_cnt, hdmi->hpd_regs);\n\tif (ret)\n\t\tdev_warn(dev, \"failed to disable hpd regulator: %d\\n\", ret);\n}\n\nvoid msm_hdmi_hpd_irq(struct drm_bridge *bridge)\n{\n\tstruct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);\n\tstruct hdmi *hdmi = hdmi_bridge->hdmi;\n\tuint32_t hpd_int_status, hpd_int_ctrl;\n\n\t \n\thpd_int_status = hdmi_read(hdmi, REG_HDMI_HPD_INT_STATUS);\n\thpd_int_ctrl   = hdmi_read(hdmi, REG_HDMI_HPD_INT_CTRL);\n\n\tif ((hpd_int_ctrl & HDMI_HPD_INT_CTRL_INT_EN) &&\n\t\t\t(hpd_int_status & HDMI_HPD_INT_STATUS_INT)) {\n\t\tbool detected = !!(hpd_int_status & HDMI_HPD_INT_STATUS_CABLE_DETECTED);\n\n\t\t \n\t\thdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL,\n\t\t\tHDMI_HPD_INT_CTRL_INT_ACK);\n\n\t\tDBG(\"status=%04x, ctrl=%04x\", hpd_int_status, hpd_int_ctrl);\n\n\t\t \n\t\thpd_int_ctrl = HDMI_HPD_INT_CTRL_INT_EN;\n\t\tif (!detected)\n\t\t\thpd_int_ctrl |= HDMI_HPD_INT_CTRL_INT_CONNECT;\n\t\thdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL, hpd_int_ctrl);\n\n\t\tqueue_work(hdmi->workq, &hdmi_bridge->hpd_work);\n\t}\n}\n\nstatic enum drm_connector_status detect_reg(struct hdmi *hdmi)\n{\n\tuint32_t hpd_int_status;\n\n\tpm_runtime_get_sync(&hdmi->pdev->dev);\n\tenable_hpd_clocks(hdmi, true);\n\n\thpd_int_status = hdmi_read(hdmi, REG_HDMI_HPD_INT_STATUS);\n\n\tenable_hpd_clocks(hdmi, false);\n\tpm_runtime_put(&hdmi->pdev->dev);\n\n\treturn (hpd_int_status & HDMI_HPD_INT_STATUS_CABLE_DETECTED) ?\n\t\t\tconnector_status_connected : connector_status_disconnected;\n}\n\n#define HPD_GPIO_INDEX\t2\nstatic enum drm_connector_status detect_gpio(struct hdmi *hdmi)\n{\n\treturn gpiod_get_value(hdmi->hpd_gpiod) ?\n\t\t\tconnector_status_connected :\n\t\t\tconnector_status_disconnected;\n}\n\nenum drm_connector_status msm_hdmi_bridge_detect(\n\t\tstruct drm_bridge *bridge)\n{\n\tstruct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);\n\tstruct hdmi *hdmi = hdmi_bridge->hdmi;\n\tenum drm_connector_status stat_gpio, stat_reg;\n\tint retry = 20;\n\n\t \n\tif (!hdmi->hpd_gpiod)\n\t\treturn detect_reg(hdmi);\n\n\tdo {\n\t\tstat_gpio = detect_gpio(hdmi);\n\t\tstat_reg  = detect_reg(hdmi);\n\n\t\tif (stat_gpio == stat_reg)\n\t\t\tbreak;\n\n\t\tmdelay(10);\n\t} while (--retry);\n\n\t \n\tif (stat_gpio != stat_reg) {\n\t\tDBG(\"HDMI_HPD_INT_STATUS tells us: %d\", stat_reg);\n\t\tDBG(\"hpd gpio tells us: %d\", stat_gpio);\n\t}\n\n\treturn stat_gpio;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}