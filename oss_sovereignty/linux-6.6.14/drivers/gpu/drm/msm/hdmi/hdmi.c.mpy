{
  "module_name": "hdmi.c",
  "hash_id": "b6f1b868bc4e5dbedf64ec3b03232be760435ee2d1b029b912d995384547c1b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/hdmi/hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/of_irq.h>\n#include <linux/of_gpio.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_of.h>\n\n#include <sound/hdmi-codec.h>\n#include \"hdmi.h\"\n\nvoid msm_hdmi_set_mode(struct hdmi *hdmi, bool power_on)\n{\n\tuint32_t ctrl = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\tif (power_on) {\n\t\tctrl |= HDMI_CTRL_ENABLE;\n\t\tif (!hdmi->hdmi_mode) {\n\t\t\tctrl |= HDMI_CTRL_HDMI;\n\t\t\thdmi_write(hdmi, REG_HDMI_CTRL, ctrl);\n\t\t\tctrl &= ~HDMI_CTRL_HDMI;\n\t\t} else {\n\t\t\tctrl |= HDMI_CTRL_HDMI;\n\t\t}\n\t} else {\n\t\tctrl = HDMI_CTRL_HDMI;\n\t}\n\n\thdmi_write(hdmi, REG_HDMI_CTRL, ctrl);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\tDBG(\"HDMI Core: %s, HDMI_CTRL=0x%08x\",\n\t\t\tpower_on ? \"Enable\" : \"Disable\", ctrl);\n}\n\nstatic irqreturn_t msm_hdmi_irq(int irq, void *dev_id)\n{\n\tstruct hdmi *hdmi = dev_id;\n\n\t \n\tmsm_hdmi_hpd_irq(hdmi->bridge);\n\n\t \n\tmsm_hdmi_i2c_irq(hdmi->i2c);\n\n\t \n\tif (hdmi->hdcp_ctrl)\n\t\tmsm_hdmi_hdcp_irq(hdmi->hdcp_ctrl);\n\n\t \n\n\treturn IRQ_HANDLED;\n}\n\nstatic void msm_hdmi_destroy(struct hdmi *hdmi)\n{\n\t \n\tif (hdmi->workq)\n\t\tdestroy_workqueue(hdmi->workq);\n\tmsm_hdmi_hdcp_destroy(hdmi);\n\n\tif (hdmi->i2c)\n\t\tmsm_hdmi_i2c_destroy(hdmi->i2c);\n}\n\nstatic void msm_hdmi_put_phy(struct hdmi *hdmi)\n{\n\tif (hdmi->phy_dev) {\n\t\tput_device(hdmi->phy_dev);\n\t\thdmi->phy = NULL;\n\t\thdmi->phy_dev = NULL;\n\t}\n}\n\nstatic int msm_hdmi_get_phy(struct hdmi *hdmi)\n{\n\tstruct platform_device *pdev = hdmi->pdev;\n\tstruct platform_device *phy_pdev;\n\tstruct device_node *phy_node;\n\n\tphy_node = of_parse_phandle(pdev->dev.of_node, \"phys\", 0);\n\tif (!phy_node) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"cannot find phy device\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tphy_pdev = of_find_device_by_node(phy_node);\n\tof_node_put(phy_node);\n\n\tif (!phy_pdev)\n\t\treturn dev_err_probe(&pdev->dev, -EPROBE_DEFER, \"phy driver is not ready\\n\");\n\n\thdmi->phy = platform_get_drvdata(phy_pdev);\n\tif (!hdmi->phy) {\n\t\tput_device(&phy_pdev->dev);\n\t\treturn dev_err_probe(&pdev->dev, -EPROBE_DEFER, \"phy driver is not ready\\n\");\n\t}\n\n\thdmi->phy_dev = &phy_pdev->dev;\n\n\treturn 0;\n}\n\n \nstatic int msm_hdmi_init(struct hdmi *hdmi)\n{\n\tstruct platform_device *pdev = hdmi->pdev;\n\tint ret;\n\n\thdmi->workq = alloc_ordered_workqueue(\"msm_hdmi\", 0);\n\tif (!hdmi->workq) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\thdmi->i2c = msm_hdmi_i2c_init(hdmi);\n\tif (IS_ERR(hdmi->i2c)) {\n\t\tret = PTR_ERR(hdmi->i2c);\n\t\tDRM_DEV_ERROR(&pdev->dev, \"failed to get i2c: %d\\n\", ret);\n\t\thdmi->i2c = NULL;\n\t\tgoto fail;\n\t}\n\n\thdmi->hdcp_ctrl = msm_hdmi_hdcp_init(hdmi);\n\tif (IS_ERR(hdmi->hdcp_ctrl)) {\n\t\tdev_warn(&pdev->dev, \"failed to init hdcp: disabled\\n\");\n\t\thdmi->hdcp_ctrl = NULL;\n\t}\n\n\treturn 0;\n\nfail:\n\tmsm_hdmi_destroy(hdmi);\n\n\treturn ret;\n}\n\n \nint msm_hdmi_modeset_init(struct hdmi *hdmi,\n\t\tstruct drm_device *dev, struct drm_encoder *encoder)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tint ret;\n\n\tif (priv->num_bridges == ARRAY_SIZE(priv->bridges)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"too many bridges\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\thdmi->dev = dev;\n\thdmi->encoder = encoder;\n\n\thdmi_audio_infoframe_init(&hdmi->audio.infoframe);\n\n\thdmi->bridge = msm_hdmi_bridge_init(hdmi);\n\tif (IS_ERR(hdmi->bridge)) {\n\t\tret = PTR_ERR(hdmi->bridge);\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to create HDMI bridge: %d\\n\", ret);\n\t\thdmi->bridge = NULL;\n\t\tgoto fail;\n\t}\n\n\tif (hdmi->next_bridge) {\n\t\tret = drm_bridge_attach(hdmi->encoder, hdmi->next_bridge, hdmi->bridge,\n\t\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to attach next HDMI bridge: %d\\n\", ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\thdmi->connector = drm_bridge_connector_init(hdmi->dev, encoder);\n\tif (IS_ERR(hdmi->connector)) {\n\t\tret = PTR_ERR(hdmi->connector);\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to create HDMI connector: %d\\n\", ret);\n\t\thdmi->connector = NULL;\n\t\tgoto fail;\n\t}\n\n\tdrm_connector_attach_encoder(hdmi->connector, hdmi->encoder);\n\n\tret = devm_request_irq(dev->dev, hdmi->irq,\n\t\t\tmsm_hdmi_irq, IRQF_TRIGGER_HIGH,\n\t\t\t\"hdmi_isr\", hdmi);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to request IRQ%u: %d\\n\",\n\t\t\t\thdmi->irq, ret);\n\t\tgoto fail;\n\t}\n\n\tret = msm_hdmi_hpd_enable(hdmi->bridge);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(&hdmi->pdev->dev, \"failed to enable HPD: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tpriv->bridges[priv->num_bridges++]       = hdmi->bridge;\n\n\treturn 0;\n\nfail:\n\t \n\tif (hdmi->bridge) {\n\t\tmsm_hdmi_bridge_destroy(hdmi->bridge);\n\t\thdmi->bridge = NULL;\n\t}\n\tif (hdmi->connector) {\n\t\thdmi->connector->funcs->destroy(hdmi->connector);\n\t\thdmi->connector = NULL;\n\t}\n\n\treturn ret;\n}\n\n \n\n#define HDMI_CFG(item, entry) \\\n\t.item ## _names = item ##_names_ ## entry, \\\n\t.item ## _cnt   = ARRAY_SIZE(item ## _names_ ## entry)\n\nstatic const char *hpd_reg_names_8960[] = {\"core-vdda\"};\nstatic const char *hpd_clk_names_8960[] = {\"core\", \"master_iface\", \"slave_iface\"};\n\nstatic const struct hdmi_platform_config hdmi_tx_8960_config = {\n\t\tHDMI_CFG(hpd_reg, 8960),\n\t\tHDMI_CFG(hpd_clk, 8960),\n};\n\nstatic const char *pwr_reg_names_8x74[] = {\"core-vdda\", \"core-vcc\"};\nstatic const char *pwr_clk_names_8x74[] = {\"extp\", \"alt_iface\"};\nstatic const char *hpd_clk_names_8x74[] = {\"iface\", \"core\", \"mdp_core\"};\nstatic unsigned long hpd_clk_freq_8x74[] = {0, 19200000, 0};\n\nstatic const struct hdmi_platform_config hdmi_tx_8974_config = {\n\t\tHDMI_CFG(pwr_reg, 8x74),\n\t\tHDMI_CFG(pwr_clk, 8x74),\n\t\tHDMI_CFG(hpd_clk, 8x74),\n\t\t.hpd_freq      = hpd_clk_freq_8x74,\n};\n\n \nstatic int msm_hdmi_audio_hw_params(struct device *dev, void *data,\n\t\t\t\t    struct hdmi_codec_daifmt *daifmt,\n\t\t\t\t    struct hdmi_codec_params *params)\n{\n\tstruct hdmi *hdmi = dev_get_drvdata(dev);\n\tunsigned int chan;\n\tunsigned int channel_allocation = 0;\n\tunsigned int rate;\n\tunsigned int level_shift  = 0;  \n\tbool down_mix = false;\n\n\tDRM_DEV_DEBUG(dev, \"%u Hz, %d bit, %d channels\\n\", params->sample_rate,\n\t\t params->sample_width, params->cea.channels);\n\n\tswitch (params->cea.channels) {\n\tcase 2:\n\t\t \n\t\tchannel_allocation  = 0;\n\t\tchan = MSM_HDMI_AUDIO_CHANNEL_2;\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\tchannel_allocation  = 0x3;\n\t\tchan = MSM_HDMI_AUDIO_CHANNEL_4;\n\t\tbreak;\n\tcase 6:\n\t\t \n\t\tchannel_allocation  = 0x0B;\n\t\tchan = MSM_HDMI_AUDIO_CHANNEL_6;\n\t\tbreak;\n\tcase 8:\n\t\t \n\t\tchannel_allocation  = 0x1F;\n\t\tchan = MSM_HDMI_AUDIO_CHANNEL_8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params->sample_rate) {\n\tcase 32000:\n\t\trate = HDMI_SAMPLE_RATE_32KHZ;\n\t\tbreak;\n\tcase 44100:\n\t\trate = HDMI_SAMPLE_RATE_44_1KHZ;\n\t\tbreak;\n\tcase 48000:\n\t\trate = HDMI_SAMPLE_RATE_48KHZ;\n\t\tbreak;\n\tcase 88200:\n\t\trate = HDMI_SAMPLE_RATE_88_2KHZ;\n\t\tbreak;\n\tcase 96000:\n\t\trate = HDMI_SAMPLE_RATE_96KHZ;\n\t\tbreak;\n\tcase 176400:\n\t\trate = HDMI_SAMPLE_RATE_176_4KHZ;\n\t\tbreak;\n\tcase 192000:\n\t\trate = HDMI_SAMPLE_RATE_192KHZ;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEV_ERROR(dev, \"rate[%d] not supported!\\n\",\n\t\t\tparams->sample_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tmsm_hdmi_audio_set_sample_rate(hdmi, rate);\n\tmsm_hdmi_audio_info_setup(hdmi, 1, chan, channel_allocation,\n\t\t\t      level_shift, down_mix);\n\n\treturn 0;\n}\n\nstatic void msm_hdmi_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct hdmi *hdmi = dev_get_drvdata(dev);\n\n\tmsm_hdmi_audio_info_setup(hdmi, 0, 0, 0, 0, 0);\n}\n\nstatic const struct hdmi_codec_ops msm_hdmi_audio_codec_ops = {\n\t.hw_params = msm_hdmi_audio_hw_params,\n\t.audio_shutdown = msm_hdmi_audio_shutdown,\n};\n\nstatic struct hdmi_codec_pdata codec_data = {\n\t.ops = &msm_hdmi_audio_codec_ops,\n\t.max_i2s_channels = 8,\n\t.i2s = 1,\n};\n\nstatic int msm_hdmi_register_audio_driver(struct hdmi *hdmi, struct device *dev)\n{\n\thdmi->audio_pdev = platform_device_register_data(dev,\n\t\t\t\t\t\t\t HDMI_CODEC_DRV_NAME,\n\t\t\t\t\t\t\t PLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t\t &codec_data,\n\t\t\t\t\t\t\t sizeof(codec_data));\n\treturn PTR_ERR_OR_ZERO(hdmi->audio_pdev);\n}\n\nstatic int msm_hdmi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct msm_drm_private *priv = dev_get_drvdata(master);\n\tstruct hdmi *hdmi = dev_get_drvdata(dev);\n\tint err;\n\n\terr = msm_hdmi_init(hdmi);\n\tif (err)\n\t\treturn err;\n\tpriv->hdmi = hdmi;\n\n\terr = msm_hdmi_register_audio_driver(hdmi, dev);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to attach an audio codec %d\\n\", err);\n\t\thdmi->audio_pdev = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void msm_hdmi_unbind(struct device *dev, struct device *master,\n\t\tvoid *data)\n{\n\tstruct msm_drm_private *priv = dev_get_drvdata(master);\n\n\tif (priv->hdmi) {\n\t\tif (priv->hdmi->audio_pdev)\n\t\t\tplatform_device_unregister(priv->hdmi->audio_pdev);\n\n\t\tmsm_hdmi_destroy(priv->hdmi);\n\t\tpriv->hdmi = NULL;\n\t}\n}\n\nstatic const struct component_ops msm_hdmi_ops = {\n\t\t.bind   = msm_hdmi_bind,\n\t\t.unbind = msm_hdmi_unbind,\n};\n\nstatic int msm_hdmi_dev_probe(struct platform_device *pdev)\n{\n\tconst struct hdmi_platform_config *config;\n\tstruct device *dev = &pdev->dev;\n\tstruct hdmi *hdmi;\n\tstruct resource *res;\n\tint i, ret;\n\n\tconfig = of_device_get_match_data(dev);\n\tif (!config)\n\t\treturn -EINVAL;\n\n\thdmi = devm_kzalloc(&pdev->dev, sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn -ENOMEM;\n\n\thdmi->pdev = pdev;\n\thdmi->config = config;\n\tspin_lock_init(&hdmi->reg_lock);\n\n\tret = drm_of_find_panel_or_bridge(pdev->dev.of_node, 1, 0, NULL, &hdmi->next_bridge);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\n\thdmi->mmio = msm_ioremap(pdev, \"core_physical\");\n\tif (IS_ERR(hdmi->mmio))\n\t\treturn PTR_ERR(hdmi->mmio);\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\"core_physical\");\n\tif (!res)\n\t\treturn -EINVAL;\n\thdmi->mmio_phy_addr = res->start;\n\n\thdmi->qfprom_mmio = msm_ioremap(pdev, \"qfprom_physical\");\n\tif (IS_ERR(hdmi->qfprom_mmio)) {\n\t\tDRM_DEV_INFO(&pdev->dev, \"can't find qfprom resource\\n\");\n\t\thdmi->qfprom_mmio = NULL;\n\t}\n\n\thdmi->irq = platform_get_irq(pdev, 0);\n\tif (hdmi->irq < 0)\n\t\treturn hdmi->irq;\n\n\thdmi->hpd_regs = devm_kcalloc(&pdev->dev,\n\t\t\t\t      config->hpd_reg_cnt,\n\t\t\t\t      sizeof(hdmi->hpd_regs[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (!hdmi->hpd_regs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < config->hpd_reg_cnt; i++)\n\t\thdmi->hpd_regs[i].supply = config->hpd_reg_names[i];\n\n\tret = devm_regulator_bulk_get(&pdev->dev, config->hpd_reg_cnt, hdmi->hpd_regs);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get hpd regulators\\n\");\n\n\thdmi->pwr_regs = devm_kcalloc(&pdev->dev,\n\t\t\t\t      config->pwr_reg_cnt,\n\t\t\t\t      sizeof(hdmi->pwr_regs[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (!hdmi->pwr_regs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < config->pwr_reg_cnt; i++)\n\t\thdmi->pwr_regs[i].supply = config->pwr_reg_names[i];\n\n\tret = devm_regulator_bulk_get(&pdev->dev, config->pwr_reg_cnt, hdmi->pwr_regs);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get pwr regulators\\n\");\n\n\thdmi->hpd_clks = devm_kcalloc(&pdev->dev,\n\t\t\t\t      config->hpd_clk_cnt,\n\t\t\t\t      sizeof(hdmi->hpd_clks[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (!hdmi->hpd_clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < config->hpd_clk_cnt; i++) {\n\t\tstruct clk *clk;\n\n\t\tclk = msm_clk_get(pdev, config->hpd_clk_names[i]);\n\t\tif (IS_ERR(clk))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(clk),\n\t\t\t\t\t     \"failed to get hpd clk: %s\\n\",\n\t\t\t\t\t     config->hpd_clk_names[i]);\n\n\t\thdmi->hpd_clks[i] = clk;\n\t}\n\n\thdmi->pwr_clks = devm_kcalloc(&pdev->dev,\n\t\t\t\t      config->pwr_clk_cnt,\n\t\t\t\t      sizeof(hdmi->pwr_clks[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (!hdmi->pwr_clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < config->pwr_clk_cnt; i++) {\n\t\tstruct clk *clk;\n\n\t\tclk = msm_clk_get(pdev, config->pwr_clk_names[i]);\n\t\tif (IS_ERR(clk))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(clk),\n\t\t\t\t\t     \"failed to get pwr clk: %s\\n\",\n\t\t\t\t\t     config->pwr_clk_names[i]);\n\n\t\thdmi->pwr_clks[i] = clk;\n\t}\n\n\thdmi->hpd_gpiod = devm_gpiod_get_optional(&pdev->dev, \"hpd\", GPIOD_IN);\n\t \n\tif (IS_ERR(hdmi->hpd_gpiod))\n\t\treturn dev_err_probe(dev, PTR_ERR(hdmi->hpd_gpiod),\n\t\t\t\t     \"failed to get hpd gpio\\n\");\n\n\tif (!hdmi->hpd_gpiod)\n\t\tDBG(\"failed to get HPD gpio\");\n\n\tif (hdmi->hpd_gpiod)\n\t\tgpiod_set_consumer_name(hdmi->hpd_gpiod, \"HDMI_HPD\");\n\n\tret = msm_hdmi_get_phy(hdmi);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"failed to get phy\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_pm_runtime_enable(&pdev->dev);\n\tif (ret)\n\t\tgoto err_put_phy;\n\n\tplatform_set_drvdata(pdev, hdmi);\n\n\tret = component_add(&pdev->dev, &msm_hdmi_ops);\n\tif (ret)\n\t\tgoto err_put_phy;\n\n\treturn 0;\n\nerr_put_phy:\n\tmsm_hdmi_put_phy(hdmi);\n\treturn ret;\n}\n\nstatic int msm_hdmi_dev_remove(struct platform_device *pdev)\n{\n\tstruct hdmi *hdmi = dev_get_drvdata(&pdev->dev);\n\n\tcomponent_del(&pdev->dev, &msm_hdmi_ops);\n\n\tmsm_hdmi_put_phy(hdmi);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id msm_hdmi_dt_match[] = {\n\t{ .compatible = \"qcom,hdmi-tx-8996\", .data = &hdmi_tx_8974_config },\n\t{ .compatible = \"qcom,hdmi-tx-8994\", .data = &hdmi_tx_8974_config },\n\t{ .compatible = \"qcom,hdmi-tx-8084\", .data = &hdmi_tx_8974_config },\n\t{ .compatible = \"qcom,hdmi-tx-8974\", .data = &hdmi_tx_8974_config },\n\t{ .compatible = \"qcom,hdmi-tx-8960\", .data = &hdmi_tx_8960_config },\n\t{ .compatible = \"qcom,hdmi-tx-8660\", .data = &hdmi_tx_8960_config },\n\t{}\n};\n\nstatic struct platform_driver msm_hdmi_driver = {\n\t.probe = msm_hdmi_dev_probe,\n\t.remove = msm_hdmi_dev_remove,\n\t.driver = {\n\t\t.name = \"hdmi_msm\",\n\t\t.of_match_table = msm_hdmi_dt_match,\n\t},\n};\n\nvoid __init msm_hdmi_register(void)\n{\n\tmsm_hdmi_phy_driver_register();\n\tplatform_driver_register(&msm_hdmi_driver);\n}\n\nvoid __exit msm_hdmi_unregister(void)\n{\n\tplatform_driver_unregister(&msm_hdmi_driver);\n\tmsm_hdmi_phy_driver_unregister();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}