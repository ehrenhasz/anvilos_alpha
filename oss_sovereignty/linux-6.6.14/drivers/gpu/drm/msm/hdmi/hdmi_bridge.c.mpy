{
  "module_name": "hdmi_bridge.c",
  "hash_id": "f0a5196695d2fa9a6fbf5387517caedf6915d92403f5e024c5c5c265aabaca2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_edid.h>\n\n#include \"msm_kms.h\"\n#include \"hdmi.h\"\n\nvoid msm_hdmi_bridge_destroy(struct drm_bridge *bridge)\n{\n\tstruct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);\n\n\tmsm_hdmi_hpd_disable(hdmi_bridge);\n\tdrm_bridge_remove(bridge);\n}\n\nstatic void msm_hdmi_power_on(struct drm_bridge *bridge)\n{\n\tstruct drm_device *dev = bridge->dev;\n\tstruct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);\n\tstruct hdmi *hdmi = hdmi_bridge->hdmi;\n\tconst struct hdmi_platform_config *config = hdmi->config;\n\tint i, ret;\n\n\tpm_runtime_get_sync(&hdmi->pdev->dev);\n\n\tret = regulator_bulk_enable(config->pwr_reg_cnt, hdmi->pwr_regs);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to enable pwr regulator: %d\\n\", ret);\n\n\tif (config->pwr_clk_cnt > 0) {\n\t\tDBG(\"pixclock: %lu\", hdmi->pixclock);\n\t\tret = clk_set_rate(hdmi->pwr_clks[0], hdmi->pixclock);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to set pixel clk: %s (%d)\\n\",\n\t\t\t\t\tconfig->pwr_clk_names[0], ret);\n\t\t}\n\t}\n\n\tfor (i = 0; i < config->pwr_clk_cnt; i++) {\n\t\tret = clk_prepare_enable(hdmi->pwr_clks[i]);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to enable pwr clk: %s (%d)\\n\",\n\t\t\t\t\tconfig->pwr_clk_names[i], ret);\n\t\t}\n\t}\n}\n\nstatic void power_off(struct drm_bridge *bridge)\n{\n\tstruct drm_device *dev = bridge->dev;\n\tstruct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);\n\tstruct hdmi *hdmi = hdmi_bridge->hdmi;\n\tconst struct hdmi_platform_config *config = hdmi->config;\n\tint i, ret;\n\n\t \n\tmdelay(16 + 4);\n\n\tfor (i = 0; i < config->pwr_clk_cnt; i++)\n\t\tclk_disable_unprepare(hdmi->pwr_clks[i]);\n\n\tret = regulator_bulk_disable(config->pwr_reg_cnt, hdmi->pwr_regs);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to disable pwr regulator: %d\\n\", ret);\n\n\tpm_runtime_put(&hdmi->pdev->dev);\n}\n\n#define AVI_IFRAME_LINE_NUMBER 1\n\nstatic void msm_hdmi_config_avi_infoframe(struct hdmi *hdmi)\n{\n\tstruct drm_crtc *crtc = hdmi->encoder->crtc;\n\tconst struct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tunion hdmi_infoframe frame;\n\tu8 buffer[HDMI_INFOFRAME_SIZE(AVI)];\n\tu32 val;\n\tint len;\n\n\tdrm_hdmi_avi_infoframe_from_display_mode(&frame.avi,\n\t\t\t\t\t\t hdmi->connector, mode);\n\n\tlen = hdmi_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (len < 0) {\n\t\tDRM_DEV_ERROR(&hdmi->pdev->dev,\n\t\t\t\"failed to configure avi infoframe\\n\");\n\t\treturn;\n\t}\n\n\t \n\thdmi_write(hdmi, REG_HDMI_AVI_INFO(0),\n\t\t   buffer[3] |\n\t\t   buffer[4] << 8 |\n\t\t   buffer[5] << 16 |\n\t\t   buffer[6] << 24);\n\n\thdmi_write(hdmi, REG_HDMI_AVI_INFO(1),\n\t\t   buffer[7] |\n\t\t   buffer[8] << 8 |\n\t\t   buffer[9] << 16 |\n\t\t   buffer[10] << 24);\n\n\thdmi_write(hdmi, REG_HDMI_AVI_INFO(2),\n\t\t   buffer[11] |\n\t\t   buffer[12] << 8 |\n\t\t   buffer[13] << 16 |\n\t\t   buffer[14] << 24);\n\n\thdmi_write(hdmi, REG_HDMI_AVI_INFO(3),\n\t\t   buffer[15] |\n\t\t   buffer[16] << 8 |\n\t\t   buffer[1] << 24);\n\n\thdmi_write(hdmi, REG_HDMI_INFOFRAME_CTRL0,\n\t\t   HDMI_INFOFRAME_CTRL0_AVI_SEND |\n\t\t   HDMI_INFOFRAME_CTRL0_AVI_CONT);\n\n\tval = hdmi_read(hdmi, REG_HDMI_INFOFRAME_CTRL1);\n\tval &= ~HDMI_INFOFRAME_CTRL1_AVI_INFO_LINE__MASK;\n\tval |= HDMI_INFOFRAME_CTRL1_AVI_INFO_LINE(AVI_IFRAME_LINE_NUMBER);\n\thdmi_write(hdmi, REG_HDMI_INFOFRAME_CTRL1, val);\n}\n\nstatic void msm_hdmi_bridge_pre_enable(struct drm_bridge *bridge)\n{\n\tstruct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);\n\tstruct hdmi *hdmi = hdmi_bridge->hdmi;\n\tstruct hdmi_phy *phy = hdmi->phy;\n\n\tDBG(\"power up\");\n\n\tif (!hdmi->power_on) {\n\t\tmsm_hdmi_phy_resource_enable(phy);\n\t\tmsm_hdmi_power_on(bridge);\n\t\thdmi->power_on = true;\n\t\tif (hdmi->hdmi_mode) {\n\t\t\tmsm_hdmi_config_avi_infoframe(hdmi);\n\t\t\tmsm_hdmi_audio_update(hdmi);\n\t\t}\n\t}\n\n\tmsm_hdmi_phy_powerup(phy, hdmi->pixclock);\n\n\tmsm_hdmi_set_mode(hdmi, true);\n\n\tif (hdmi->hdcp_ctrl)\n\t\tmsm_hdmi_hdcp_on(hdmi->hdcp_ctrl);\n}\n\nstatic void msm_hdmi_bridge_post_disable(struct drm_bridge *bridge)\n{\n\tstruct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);\n\tstruct hdmi *hdmi = hdmi_bridge->hdmi;\n\tstruct hdmi_phy *phy = hdmi->phy;\n\n\tif (hdmi->hdcp_ctrl)\n\t\tmsm_hdmi_hdcp_off(hdmi->hdcp_ctrl);\n\n\tDBG(\"power down\");\n\tmsm_hdmi_set_mode(hdmi, false);\n\n\tmsm_hdmi_phy_powerdown(phy);\n\n\tif (hdmi->power_on) {\n\t\tpower_off(bridge);\n\t\thdmi->power_on = false;\n\t\tif (hdmi->hdmi_mode)\n\t\t\tmsm_hdmi_audio_update(hdmi);\n\t\tmsm_hdmi_phy_resource_disable(phy);\n\t}\n}\n\nstatic void msm_hdmi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t const struct drm_display_mode *mode,\n\t\t const struct drm_display_mode *adjusted_mode)\n{\n\tstruct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);\n\tstruct hdmi *hdmi = hdmi_bridge->hdmi;\n\tint hstart, hend, vstart, vend;\n\tuint32_t frame_ctrl;\n\n\tmode = adjusted_mode;\n\n\thdmi->pixclock = mode->clock * 1000;\n\n\thstart = mode->htotal - mode->hsync_start;\n\thend   = mode->htotal - mode->hsync_start + mode->hdisplay;\n\n\tvstart = mode->vtotal - mode->vsync_start - 1;\n\tvend   = mode->vtotal - mode->vsync_start + mode->vdisplay - 1;\n\n\tDBG(\"htotal=%d, vtotal=%d, hstart=%d, hend=%d, vstart=%d, vend=%d\",\n\t\t\tmode->htotal, mode->vtotal, hstart, hend, vstart, vend);\n\n\thdmi_write(hdmi, REG_HDMI_TOTAL,\n\t\t\tHDMI_TOTAL_H_TOTAL(mode->htotal - 1) |\n\t\t\tHDMI_TOTAL_V_TOTAL(mode->vtotal - 1));\n\n\thdmi_write(hdmi, REG_HDMI_ACTIVE_HSYNC,\n\t\t\tHDMI_ACTIVE_HSYNC_START(hstart) |\n\t\t\tHDMI_ACTIVE_HSYNC_END(hend));\n\thdmi_write(hdmi, REG_HDMI_ACTIVE_VSYNC,\n\t\t\tHDMI_ACTIVE_VSYNC_START(vstart) |\n\t\t\tHDMI_ACTIVE_VSYNC_END(vend));\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\thdmi_write(hdmi, REG_HDMI_VSYNC_TOTAL_F2,\n\t\t\t\tHDMI_VSYNC_TOTAL_F2_V_TOTAL(mode->vtotal));\n\t\thdmi_write(hdmi, REG_HDMI_VSYNC_ACTIVE_F2,\n\t\t\t\tHDMI_VSYNC_ACTIVE_F2_START(vstart + 1) |\n\t\t\t\tHDMI_VSYNC_ACTIVE_F2_END(vend + 1));\n\t} else {\n\t\thdmi_write(hdmi, REG_HDMI_VSYNC_TOTAL_F2,\n\t\t\t\tHDMI_VSYNC_TOTAL_F2_V_TOTAL(0));\n\t\thdmi_write(hdmi, REG_HDMI_VSYNC_ACTIVE_F2,\n\t\t\t\tHDMI_VSYNC_ACTIVE_F2_START(0) |\n\t\t\t\tHDMI_VSYNC_ACTIVE_F2_END(0));\n\t}\n\n\tframe_ctrl = 0;\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tframe_ctrl |= HDMI_FRAME_CTRL_HSYNC_LOW;\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tframe_ctrl |= HDMI_FRAME_CTRL_VSYNC_LOW;\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tframe_ctrl |= HDMI_FRAME_CTRL_INTERLACED_EN;\n\tDBG(\"frame_ctrl=%08x\", frame_ctrl);\n\thdmi_write(hdmi, REG_HDMI_FRAME_CTRL, frame_ctrl);\n\n\tif (hdmi->hdmi_mode)\n\t\tmsm_hdmi_audio_update(hdmi);\n}\n\nstatic struct edid *msm_hdmi_bridge_get_edid(struct drm_bridge *bridge,\n\t\tstruct drm_connector *connector)\n{\n\tstruct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);\n\tstruct hdmi *hdmi = hdmi_bridge->hdmi;\n\tstruct edid *edid;\n\tuint32_t hdmi_ctrl;\n\n\thdmi_ctrl = hdmi_read(hdmi, REG_HDMI_CTRL);\n\thdmi_write(hdmi, REG_HDMI_CTRL, hdmi_ctrl | HDMI_CTRL_ENABLE);\n\n\tedid = drm_get_edid(connector, hdmi->i2c);\n\n\thdmi_write(hdmi, REG_HDMI_CTRL, hdmi_ctrl);\n\n\thdmi->hdmi_mode = drm_detect_hdmi_monitor(edid);\n\n\treturn edid;\n}\n\nstatic enum drm_mode_status msm_hdmi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\tconst struct drm_display_info *info,\n\t\tconst struct drm_display_mode *mode)\n{\n\tstruct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);\n\tstruct hdmi *hdmi = hdmi_bridge->hdmi;\n\tconst struct hdmi_platform_config *config = hdmi->config;\n\tstruct msm_drm_private *priv = bridge->dev->dev_private;\n\tstruct msm_kms *kms = priv->kms;\n\tlong actual, requested;\n\n\trequested = 1000 * mode->clock;\n\n\t \n\tif (kms->funcs->round_pixclk)\n\t\tactual = kms->funcs->round_pixclk(kms,\n\t\t\trequested, hdmi_bridge->hdmi->encoder);\n\telse if (config->pwr_clk_cnt > 0)\n\t\tactual = clk_round_rate(hdmi->pwr_clks[0], requested);\n\telse\n\t\tactual = requested;\n\n\tDBG(\"requested=%ld, actual=%ld\", requested, actual);\n\n\tif (actual != requested)\n\t\treturn MODE_CLOCK_RANGE;\n\n\treturn 0;\n}\n\nstatic const struct drm_bridge_funcs msm_hdmi_bridge_funcs = {\n\t\t.pre_enable = msm_hdmi_bridge_pre_enable,\n\t\t.post_disable = msm_hdmi_bridge_post_disable,\n\t\t.mode_set = msm_hdmi_bridge_mode_set,\n\t\t.mode_valid = msm_hdmi_bridge_mode_valid,\n\t\t.get_edid = msm_hdmi_bridge_get_edid,\n\t\t.detect = msm_hdmi_bridge_detect,\n};\n\nstatic void\nmsm_hdmi_hotplug_work(struct work_struct *work)\n{\n\tstruct hdmi_bridge *hdmi_bridge =\n\t\tcontainer_of(work, struct hdmi_bridge, hpd_work);\n\tstruct drm_bridge *bridge = &hdmi_bridge->base;\n\n\tdrm_bridge_hpd_notify(bridge, drm_bridge_detect(bridge));\n}\n\n \nstruct drm_bridge *msm_hdmi_bridge_init(struct hdmi *hdmi)\n{\n\tstruct drm_bridge *bridge = NULL;\n\tstruct hdmi_bridge *hdmi_bridge;\n\tint ret;\n\n\thdmi_bridge = devm_kzalloc(hdmi->dev->dev,\n\t\t\tsizeof(*hdmi_bridge), GFP_KERNEL);\n\tif (!hdmi_bridge) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\thdmi_bridge->hdmi = hdmi;\n\tINIT_WORK(&hdmi_bridge->hpd_work, msm_hdmi_hotplug_work);\n\n\tbridge = &hdmi_bridge->base;\n\tbridge->funcs = &msm_hdmi_bridge_funcs;\n\tbridge->ddc = hdmi->i2c;\n\tbridge->type = DRM_MODE_CONNECTOR_HDMIA;\n\tbridge->ops = DRM_BRIDGE_OP_HPD |\n\t\tDRM_BRIDGE_OP_DETECT |\n\t\tDRM_BRIDGE_OP_EDID;\n\n\tdrm_bridge_add(bridge);\n\n\tret = drm_bridge_attach(hdmi->encoder, bridge, NULL, DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret)\n\t\tgoto fail;\n\n\treturn bridge;\n\nfail:\n\tif (bridge)\n\t\tmsm_hdmi_bridge_destroy(bridge);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}