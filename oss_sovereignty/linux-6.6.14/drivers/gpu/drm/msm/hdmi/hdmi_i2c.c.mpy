{
  "module_name": "hdmi_i2c.c",
  "hash_id": "df9723b0a89197b27214e59eba958fc83f95496bcce4c71b52cfcfc0718e5963",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/hdmi/hdmi_i2c.c",
  "human_readable_source": "\n \n\n#include \"hdmi.h\"\n\nstruct hdmi_i2c_adapter {\n\tstruct i2c_adapter base;\n\tstruct hdmi *hdmi;\n\tbool sw_done;\n\twait_queue_head_t ddc_event;\n};\n#define to_hdmi_i2c_adapter(x) container_of(x, struct hdmi_i2c_adapter, base)\n\nstatic void init_ddc(struct hdmi_i2c_adapter *hdmi_i2c)\n{\n\tstruct hdmi *hdmi = hdmi_i2c->hdmi;\n\n\thdmi_write(hdmi, REG_HDMI_DDC_CTRL,\n\t\t\tHDMI_DDC_CTRL_SW_STATUS_RESET);\n\thdmi_write(hdmi, REG_HDMI_DDC_CTRL,\n\t\t\tHDMI_DDC_CTRL_SOFT_RESET);\n\n\thdmi_write(hdmi, REG_HDMI_DDC_SPEED,\n\t\t\tHDMI_DDC_SPEED_THRESHOLD(2) |\n\t\t\tHDMI_DDC_SPEED_PRESCALE(10));\n\n\thdmi_write(hdmi, REG_HDMI_DDC_SETUP,\n\t\t\tHDMI_DDC_SETUP_TIMEOUT(0xff));\n\n\t \n\thdmi_write(hdmi, REG_HDMI_DDC_REF,\n\t\t\tHDMI_DDC_REF_REFTIMER_ENABLE |\n\t\t\tHDMI_DDC_REF_REFTIMER(27));\n}\n\nstatic int ddc_clear_irq(struct hdmi_i2c_adapter *hdmi_i2c)\n{\n\tstruct hdmi *hdmi = hdmi_i2c->hdmi;\n\tstruct drm_device *dev = hdmi->dev;\n\tuint32_t retry = 0xffff;\n\tuint32_t ddc_int_ctrl;\n\n\tdo {\n\t\t--retry;\n\n\t\thdmi_write(hdmi, REG_HDMI_DDC_INT_CTRL,\n\t\t\t\tHDMI_DDC_INT_CTRL_SW_DONE_ACK |\n\t\t\t\tHDMI_DDC_INT_CTRL_SW_DONE_MASK);\n\n\t\tddc_int_ctrl = hdmi_read(hdmi, REG_HDMI_DDC_INT_CTRL);\n\n\t} while ((ddc_int_ctrl & HDMI_DDC_INT_CTRL_SW_DONE_INT) && retry);\n\n\tif (!retry) {\n\t\tDRM_DEV_ERROR(dev->dev, \"timeout waiting for DDC\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\thdmi_i2c->sw_done = false;\n\n\treturn 0;\n}\n\n#define MAX_TRANSACTIONS 4\n\nstatic bool sw_done(struct hdmi_i2c_adapter *hdmi_i2c)\n{\n\tstruct hdmi *hdmi = hdmi_i2c->hdmi;\n\n\tif (!hdmi_i2c->sw_done) {\n\t\tuint32_t ddc_int_ctrl;\n\n\t\tddc_int_ctrl = hdmi_read(hdmi, REG_HDMI_DDC_INT_CTRL);\n\n\t\tif ((ddc_int_ctrl & HDMI_DDC_INT_CTRL_SW_DONE_MASK) &&\n\t\t\t\t(ddc_int_ctrl & HDMI_DDC_INT_CTRL_SW_DONE_INT)) {\n\t\t\thdmi_i2c->sw_done = true;\n\t\t\thdmi_write(hdmi, REG_HDMI_DDC_INT_CTRL,\n\t\t\t\t\tHDMI_DDC_INT_CTRL_SW_DONE_ACK);\n\t\t}\n\t}\n\n\treturn hdmi_i2c->sw_done;\n}\n\nstatic int msm_hdmi_i2c_xfer(struct i2c_adapter *i2c,\n\t\tstruct i2c_msg *msgs, int num)\n{\n\tstruct hdmi_i2c_adapter *hdmi_i2c = to_hdmi_i2c_adapter(i2c);\n\tstruct hdmi *hdmi = hdmi_i2c->hdmi;\n\tstruct drm_device *dev = hdmi->dev;\n\tstatic const uint32_t nack[] = {\n\t\t\tHDMI_DDC_SW_STATUS_NACK0, HDMI_DDC_SW_STATUS_NACK1,\n\t\t\tHDMI_DDC_SW_STATUS_NACK2, HDMI_DDC_SW_STATUS_NACK3,\n\t};\n\tint indices[MAX_TRANSACTIONS];\n\tint ret, i, j, index = 0;\n\tuint32_t ddc_status, ddc_data, i2c_trans;\n\n\tnum = min(num, MAX_TRANSACTIONS);\n\n\tWARN_ON(!(hdmi_read(hdmi, REG_HDMI_CTRL) & HDMI_CTRL_ENABLE));\n\n\tif (num == 0)\n\t\treturn num;\n\n\tinit_ddc(hdmi_i2c);\n\n\tret = ddc_clear_irq(hdmi_i2c);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct i2c_msg *p = &msgs[i];\n\t\tuint32_t raw_addr = p->addr << 1;\n\n\t\tif (p->flags & I2C_M_RD)\n\t\t\traw_addr |= 1;\n\n\t\tddc_data = HDMI_DDC_DATA_DATA(raw_addr) |\n\t\t\t\tHDMI_DDC_DATA_DATA_RW(DDC_WRITE);\n\n\t\tif (i == 0) {\n\t\t\tddc_data |= HDMI_DDC_DATA_INDEX(0) |\n\t\t\t\t\tHDMI_DDC_DATA_INDEX_WRITE;\n\t\t}\n\n\t\thdmi_write(hdmi, REG_HDMI_DDC_DATA, ddc_data);\n\t\tindex++;\n\n\t\tindices[i] = index;\n\n\t\tif (p->flags & I2C_M_RD) {\n\t\t\tindex += p->len;\n\t\t} else {\n\t\t\tfor (j = 0; j < p->len; j++) {\n\t\t\t\tddc_data = HDMI_DDC_DATA_DATA(p->buf[j]) |\n\t\t\t\t\t\tHDMI_DDC_DATA_DATA_RW(DDC_WRITE);\n\t\t\t\thdmi_write(hdmi, REG_HDMI_DDC_DATA, ddc_data);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\n\t\ti2c_trans = HDMI_I2C_TRANSACTION_REG_CNT(p->len) |\n\t\t\t\tHDMI_I2C_TRANSACTION_REG_RW(\n\t\t\t\t\t\t(p->flags & I2C_M_RD) ? DDC_READ : DDC_WRITE) |\n\t\t\t\tHDMI_I2C_TRANSACTION_REG_START;\n\n\t\tif (i == (num - 1))\n\t\t\ti2c_trans |= HDMI_I2C_TRANSACTION_REG_STOP;\n\n\t\thdmi_write(hdmi, REG_HDMI_I2C_TRANSACTION(i), i2c_trans);\n\t}\n\n\t \n\thdmi_write(hdmi, REG_HDMI_DDC_CTRL,\n\t\t\tHDMI_DDC_CTRL_TRANSACTION_CNT(num - 1) |\n\t\t\tHDMI_DDC_CTRL_GO);\n\n\tret = wait_event_timeout(hdmi_i2c->ddc_event, sw_done(hdmi_i2c), HZ/4);\n\tif (ret <= 0) {\n\t\tif (ret == 0)\n\t\t\tret = -ETIMEDOUT;\n\t\tdev_warn(dev->dev, \"DDC timeout: %d\\n\", ret);\n\t\tDBG(\"sw_status=%08x, hw_status=%08x, int_ctrl=%08x\",\n\t\t\t\thdmi_read(hdmi, REG_HDMI_DDC_SW_STATUS),\n\t\t\t\thdmi_read(hdmi, REG_HDMI_DDC_HW_STATUS),\n\t\t\t\thdmi_read(hdmi, REG_HDMI_DDC_INT_CTRL));\n\t\treturn ret;\n\t}\n\n\tddc_status = hdmi_read(hdmi, REG_HDMI_DDC_SW_STATUS);\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tstruct i2c_msg *p = &msgs[i];\n\n\t\tif (!(p->flags & I2C_M_RD))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ddc_status & nack[i]) {\n\t\t\tDBG(\"ddc_status=%08x\", ddc_status);\n\t\t\tbreak;\n\t\t}\n\n\t\tddc_data = HDMI_DDC_DATA_DATA_RW(DDC_READ) |\n\t\t\t\tHDMI_DDC_DATA_INDEX(indices[i]) |\n\t\t\t\tHDMI_DDC_DATA_INDEX_WRITE;\n\n\t\thdmi_write(hdmi, REG_HDMI_DDC_DATA, ddc_data);\n\n\t\t \n\t\thdmi_read(hdmi, REG_HDMI_DDC_DATA);\n\n\t\tfor (j = 0; j < p->len; j++) {\n\t\t\tddc_data = hdmi_read(hdmi, REG_HDMI_DDC_DATA);\n\t\t\tp->buf[j] = FIELD(ddc_data, HDMI_DDC_DATA_DATA);\n\t\t}\n\t}\n\n\treturn i;\n}\n\nstatic u32 msm_hdmi_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm msm_hdmi_i2c_algorithm = {\n\t.master_xfer\t= msm_hdmi_i2c_xfer,\n\t.functionality\t= msm_hdmi_i2c_func,\n};\n\nvoid msm_hdmi_i2c_irq(struct i2c_adapter *i2c)\n{\n\tstruct hdmi_i2c_adapter *hdmi_i2c = to_hdmi_i2c_adapter(i2c);\n\n\tif (sw_done(hdmi_i2c))\n\t\twake_up_all(&hdmi_i2c->ddc_event);\n}\n\nvoid msm_hdmi_i2c_destroy(struct i2c_adapter *i2c)\n{\n\tstruct hdmi_i2c_adapter *hdmi_i2c = to_hdmi_i2c_adapter(i2c);\n\ti2c_del_adapter(i2c);\n\tkfree(hdmi_i2c);\n}\n\nstruct i2c_adapter *msm_hdmi_i2c_init(struct hdmi *hdmi)\n{\n\tstruct hdmi_i2c_adapter *hdmi_i2c;\n\tstruct i2c_adapter *i2c = NULL;\n\tint ret;\n\n\thdmi_i2c = kzalloc(sizeof(*hdmi_i2c), GFP_KERNEL);\n\tif (!hdmi_i2c) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\ti2c = &hdmi_i2c->base;\n\n\thdmi_i2c->hdmi = hdmi;\n\tinit_waitqueue_head(&hdmi_i2c->ddc_event);\n\n\n\ti2c->owner = THIS_MODULE;\n\ti2c->class = I2C_CLASS_DDC;\n\tsnprintf(i2c->name, sizeof(i2c->name), \"msm hdmi i2c\");\n\ti2c->dev.parent = &hdmi->pdev->dev;\n\ti2c->algo = &msm_hdmi_i2c_algorithm;\n\n\tret = i2c_add_adapter(i2c);\n\tif (ret)\n\t\tgoto fail;\n\n\treturn i2c;\n\nfail:\n\tif (i2c)\n\t\tmsm_hdmi_i2c_destroy(i2c);\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}