{
  "module_name": "hdmi_hdcp.c",
  "hash_id": "f19b9351e1bea91b7fb72ed8546a38b0e5fdfd26528d577478341118f824656b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/hdmi/hdmi_hdcp.c",
  "human_readable_source": "\n \n\n#include \"hdmi.h\"\n#include <linux/firmware/qcom/qcom_scm.h>\n\n#define HDCP_REG_ENABLE 0x01\n#define HDCP_REG_DISABLE 0x00\n#define HDCP_PORT_ADDR 0x74\n\n#define HDCP_INT_STATUS_MASK ( \\\n\t\tHDMI_HDCP_INT_CTRL_AUTH_SUCCESS_INT | \\\n\t\tHDMI_HDCP_INT_CTRL_AUTH_FAIL_INT | \\\n\t\tHDMI_HDCP_INT_CTRL_AUTH_XFER_REQ_INT | \\\n\t\tHDMI_HDCP_INT_CTRL_AUTH_XFER_DONE_INT)\n\n#define AUTH_WORK_RETRIES_TIME 100\n#define AUTH_RETRIES_TIME 30\n\n \n#define QFPROM_RAW_FEAT_CONFIG_ROW0_LSB  0x000000F8\n#define QFPROM_RAW_FEAT_CONFIG_ROW0_MSB  0x000000FC\n#define HDCP_KSV_LSB                     0x000060D8\n#define HDCP_KSV_MSB                     0x000060DC\n\nenum DS_TYPE {   \n\tDS_UNKNOWN,\n\tDS_RECEIVER,\n\tDS_REPEATER,\n};\n\nenum hdmi_hdcp_state {\n\tHDCP_STATE_NO_AKSV,\n\tHDCP_STATE_INACTIVE,\n\tHDCP_STATE_AUTHENTICATING,\n\tHDCP_STATE_AUTHENTICATED,\n\tHDCP_STATE_AUTH_FAILED\n};\n\nstruct hdmi_hdcp_reg_data {\n\tu32 reg_id;\n\tu32 off;\n\tchar *name;\n\tu32 reg_val;\n};\n\nstruct hdmi_hdcp_ctrl {\n\tstruct hdmi *hdmi;\n\tu32 auth_retries;\n\tbool tz_hdcp;\n\tenum hdmi_hdcp_state hdcp_state;\n\tstruct work_struct hdcp_auth_work;\n\tstruct work_struct hdcp_reauth_work;\n\n#define AUTH_ABORT_EV 1\n#define AUTH_RESULT_RDY_EV 2\n\tunsigned long auth_event;\n\twait_queue_head_t auth_event_queue;\n\n\tu32 ksv_fifo_w_index;\n\t \n\tu32 aksv_lsb;\n\tu32 aksv_msb;\n\tbool aksv_valid;\n\tu32 ds_type;\n\tu32 bksv_lsb;\n\tu32 bksv_msb;\n\tu8 dev_count;\n\tu8 depth;\n\tu8 ksv_list[5 * 127];\n\tbool max_cascade_exceeded;\n\tbool max_dev_exceeded;\n};\n\nstatic int msm_hdmi_ddc_read(struct hdmi *hdmi, u16 addr, u8 offset,\n\tu8 *data, u16 data_len)\n{\n\tint rc;\n\tint retry = 5;\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= addr >> 1,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= 1,\n\t\t\t.buf\t= &offset,\n\t\t}, {\n\t\t\t.addr\t= addr >> 1,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= data_len,\n\t\t\t.buf\t= data,\n\t\t}\n\t};\n\n\tDBG(\"Start DDC read\");\nretry:\n\trc = i2c_transfer(hdmi->i2c, msgs, 2);\n\n\tretry--;\n\tif (rc == 2)\n\t\trc = 0;\n\telse if (retry > 0)\n\t\tgoto retry;\n\telse\n\t\trc = -EIO;\n\n\tDBG(\"End DDC read %d\", rc);\n\n\treturn rc;\n}\n\n#define HDCP_DDC_WRITE_MAX_BYTE_NUM 32\n\nstatic int msm_hdmi_ddc_write(struct hdmi *hdmi, u16 addr, u8 offset,\n\tu8 *data, u16 data_len)\n{\n\tint rc;\n\tint retry = 10;\n\tu8 buf[HDCP_DDC_WRITE_MAX_BYTE_NUM];\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= addr >> 1,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= 1,\n\t\t}\n\t};\n\n\tDBG(\"Start DDC write\");\n\tif (data_len > (HDCP_DDC_WRITE_MAX_BYTE_NUM - 1)) {\n\t\tpr_err(\"%s: write size too big\\n\", __func__);\n\t\treturn -ERANGE;\n\t}\n\n\tbuf[0] = offset;\n\tmemcpy(&buf[1], data, data_len);\n\tmsgs[0].buf = buf;\n\tmsgs[0].len = data_len + 1;\nretry:\n\trc = i2c_transfer(hdmi->i2c, msgs, 1);\n\n\tretry--;\n\tif (rc == 1)\n\t\trc = 0;\n\telse if (retry > 0)\n\t\tgoto retry;\n\telse\n\t\trc = -EIO;\n\n\tDBG(\"End DDC write %d\", rc);\n\n\treturn rc;\n}\n\nstatic int msm_hdmi_hdcp_scm_wr(struct hdmi_hdcp_ctrl *hdcp_ctrl, u32 *preg,\n\tu32 *pdata, u32 count)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tstruct qcom_scm_hdcp_req scm_buf[QCOM_SCM_HDCP_MAX_REQ_CNT];\n\tu32 resp, phy_addr, idx = 0;\n\tint i, ret = 0;\n\n\tWARN_ON(!pdata || !preg || (count == 0));\n\n\tif (hdcp_ctrl->tz_hdcp) {\n\t\tphy_addr = (u32)hdmi->mmio_phy_addr;\n\n\t\twhile (count) {\n\t\t\tmemset(scm_buf, 0, sizeof(scm_buf));\n\t\t\tfor (i = 0; i < count && i < QCOM_SCM_HDCP_MAX_REQ_CNT;\n\t\t\t\ti++) {\n\t\t\t\tscm_buf[i].addr = phy_addr + preg[idx];\n\t\t\t\tscm_buf[i].val  = pdata[idx];\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tret = qcom_scm_hdcp_req(scm_buf, i, &resp);\n\n\t\t\tif (ret || resp) {\n\t\t\t\tpr_err(\"%s: error: scm_call ret=%d resp=%u\\n\",\n\t\t\t\t\t__func__, ret, resp);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcount -= i;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < count; i++)\n\t\t\thdmi_write(hdmi, preg[i], pdata[i]);\n\t}\n\n\treturn ret;\n}\n\nvoid msm_hdmi_hdcp_irq(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 reg_val, hdcp_int_status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\treg_val = hdmi_read(hdmi, REG_HDMI_HDCP_INT_CTRL);\n\thdcp_int_status = reg_val & HDCP_INT_STATUS_MASK;\n\tif (!hdcp_int_status) {\n\t\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\t\treturn;\n\t}\n\t \n\treg_val |= hdcp_int_status << 1;\n\t \n\tif (hdcp_int_status & HDMI_HDCP_INT_CTRL_AUTH_FAIL_INT)\n\t\treg_val |= HDMI_HDCP_INT_CTRL_AUTH_FAIL_INFO_ACK;\n\thdmi_write(hdmi, REG_HDMI_HDCP_INT_CTRL, reg_val);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\tDBG(\"hdcp irq %x\", hdcp_int_status);\n\n\tif (hdcp_int_status & HDMI_HDCP_INT_CTRL_AUTH_SUCCESS_INT) {\n\t\tpr_info(\"%s:AUTH_SUCCESS_INT received\\n\", __func__);\n\t\tif (HDCP_STATE_AUTHENTICATING == hdcp_ctrl->hdcp_state) {\n\t\t\tset_bit(AUTH_RESULT_RDY_EV, &hdcp_ctrl->auth_event);\n\t\t\twake_up_all(&hdcp_ctrl->auth_event_queue);\n\t\t}\n\t}\n\n\tif (hdcp_int_status & HDMI_HDCP_INT_CTRL_AUTH_FAIL_INT) {\n\t\treg_val = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\n\t\tpr_info(\"%s: AUTH_FAIL_INT rcvd, LINK0_STATUS=0x%08x\\n\",\n\t\t\t__func__, reg_val);\n\t\tif (HDCP_STATE_AUTHENTICATED == hdcp_ctrl->hdcp_state)\n\t\t\tqueue_work(hdmi->workq, &hdcp_ctrl->hdcp_reauth_work);\n\t\telse if (HDCP_STATE_AUTHENTICATING ==\n\t\t\t\thdcp_ctrl->hdcp_state) {\n\t\t\tset_bit(AUTH_RESULT_RDY_EV, &hdcp_ctrl->auth_event);\n\t\t\twake_up_all(&hdcp_ctrl->auth_event_queue);\n\t\t}\n\t}\n}\n\nstatic int msm_hdmi_hdcp_msleep(struct hdmi_hdcp_ctrl *hdcp_ctrl, u32 ms, u32 ev)\n{\n\tint rc;\n\n\trc = wait_event_timeout(hdcp_ctrl->auth_event_queue,\n\t\t!!test_bit(ev, &hdcp_ctrl->auth_event),\n\t\tmsecs_to_jiffies(ms));\n\tif (rc) {\n\t\tpr_info(\"%s: msleep is canceled by event %d\\n\",\n\t\t\t\t__func__, ev);\n\t\tclear_bit(ev, &hdcp_ctrl->auth_event);\n\t\treturn -ECANCELED;\n\t}\n\n\treturn 0;\n}\n\nstatic int msm_hdmi_hdcp_read_validate_aksv(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\n\t \n\thdcp_ctrl->aksv_lsb = hdmi_qfprom_read(hdmi, HDCP_KSV_LSB);\n\thdcp_ctrl->aksv_msb = hdmi_qfprom_read(hdmi, HDCP_KSV_MSB);\n\n\t \n\tif ((hweight32(hdcp_ctrl->aksv_lsb) + hweight32(hdcp_ctrl->aksv_msb))\n\t\t\t!= 20) {\n\t\tpr_err(\"%s: AKSV QFPROM doesn't have 20 1's, 20 0's\\n\",\n\t\t\t__func__);\n\t\tpr_err(\"%s: QFPROM AKSV chk failed (AKSV=%02x%08x)\\n\",\n\t\t\t__func__, hdcp_ctrl->aksv_msb,\n\t\t\thdcp_ctrl->aksv_lsb);\n\t\treturn -EINVAL;\n\t}\n\tDBG(\"AKSV=%02x%08x\", hdcp_ctrl->aksv_msb, hdcp_ctrl->aksv_lsb);\n\n\treturn 0;\n}\n\nstatic int msm_reset_hdcp_ddc_failures(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 reg_val, failure, nack0;\n\tint rc = 0;\n\n\t \n\treg_val = hdmi_read(hdmi, REG_HDMI_HDCP_DDC_STATUS);\n\tfailure = reg_val & HDMI_HDCP_DDC_STATUS_FAILED;\n\tnack0 = reg_val & HDMI_HDCP_DDC_STATUS_NACK0;\n\tDBG(\"HDCP_DDC_STATUS=0x%x, FAIL=%d, NACK0=%d\",\n\t\treg_val, failure, nack0);\n\n\tif (failure) {\n\t\t \n\t\tDBG(\"DDC failure detected\");\n\n\t\t \n\t\thdmi_write(hdmi, REG_HDMI_HDCP_DDC_CTRL_0,\n\t\t\tHDMI_HDCP_DDC_CTRL_0_DISABLE);\n\n\t\t \n\t\treg_val = hdmi_read(hdmi, REG_HDMI_HDCP_DDC_CTRL_1);\n\t\treg_val |= HDMI_HDCP_DDC_CTRL_1_FAILED_ACK;\n\t\thdmi_write(hdmi, REG_HDMI_HDCP_DDC_CTRL_1, reg_val);\n\n\t\t \n\t\treg_val = hdmi_read(hdmi, REG_HDMI_HDCP_DDC_STATUS);\n\t\tif (reg_val & HDMI_HDCP_DDC_STATUS_FAILED)\n\t\t\tpr_info(\"%s: Unable to clear HDCP DDC Failure\\n\",\n\t\t\t\t__func__);\n\n\t\t \n\t\thdmi_write(hdmi, REG_HDMI_HDCP_DDC_CTRL_0, 0);\n\t}\n\n\tif (nack0) {\n\t\tDBG(\"Before: HDMI_DDC_SW_STATUS=0x%08x\",\n\t\t\thdmi_read(hdmi, REG_HDMI_DDC_SW_STATUS));\n\t\t \n\t\treg_val = hdmi_read(hdmi, REG_HDMI_DDC_CTRL);\n\t\treg_val |= HDMI_DDC_CTRL_SW_STATUS_RESET;\n\t\thdmi_write(hdmi, REG_HDMI_DDC_CTRL, reg_val);\n\n\t\trc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\n\n\t\treg_val = hdmi_read(hdmi, REG_HDMI_DDC_CTRL);\n\t\treg_val &= ~HDMI_DDC_CTRL_SW_STATUS_RESET;\n\t\thdmi_write(hdmi, REG_HDMI_DDC_CTRL, reg_val);\n\n\t\t \n\t\treg_val = hdmi_read(hdmi, REG_HDMI_DDC_CTRL);\n\t\treg_val |= HDMI_DDC_CTRL_SOFT_RESET;\n\t\thdmi_write(hdmi, REG_HDMI_DDC_CTRL, reg_val);\n\n\t\t \n\t\tif (!rc)\n\t\t\trc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\n\n\t\treg_val = hdmi_read(hdmi, REG_HDMI_DDC_CTRL);\n\t\treg_val &= ~HDMI_DDC_CTRL_SOFT_RESET;\n\t\thdmi_write(hdmi, REG_HDMI_DDC_CTRL, reg_val);\n\t\tDBG(\"After: HDMI_DDC_SW_STATUS=0x%08x\",\n\t\t\thdmi_read(hdmi, REG_HDMI_DDC_SW_STATUS));\n\t}\n\n\treturn rc;\n}\n\nstatic int msm_hdmi_hdcp_hw_ddc_clean(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tint rc;\n\tu32 hdcp_ddc_status, ddc_hw_status;\n\tu32 xfer_done, xfer_req, hw_done;\n\tbool hw_not_ready;\n\tu32 timeout_count;\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\n\tif (hdmi_read(hdmi, REG_HDMI_DDC_HW_STATUS) == 0)\n\t\treturn 0;\n\n\t \n\ttimeout_count = 100;\n\tdo {\n\t\thdcp_ddc_status = hdmi_read(hdmi, REG_HDMI_HDCP_DDC_STATUS);\n\t\tddc_hw_status = hdmi_read(hdmi, REG_HDMI_DDC_HW_STATUS);\n\n\t\txfer_done = hdcp_ddc_status & HDMI_HDCP_DDC_STATUS_XFER_DONE;\n\t\txfer_req = hdcp_ddc_status & HDMI_HDCP_DDC_STATUS_XFER_REQ;\n\t\thw_done = ddc_hw_status & HDMI_DDC_HW_STATUS_DONE;\n\t\thw_not_ready = !xfer_done || xfer_req || !hw_done;\n\n\t\tif (hw_not_ready)\n\t\t\tbreak;\n\n\t\ttimeout_count--;\n\t\tif (!timeout_count) {\n\t\t\tpr_warn(\"%s: hw_ddc_clean failed\\n\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\trc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic void msm_hdmi_hdcp_reauth_work(struct work_struct *work)\n{\n\tstruct hdmi_hdcp_ctrl *hdcp_ctrl = container_of(work,\n\t\tstruct hdmi_hdcp_ctrl, hdcp_reauth_work);\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tunsigned long flags;\n\tu32 reg_val;\n\n\tDBG(\"HDCP REAUTH WORK\");\n\t \n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\treg_val = hdmi_read(hdmi, REG_HDMI_HPD_CTRL);\n\treg_val &= ~HDMI_HPD_CTRL_ENABLE;\n\thdmi_write(hdmi, REG_HDMI_HPD_CTRL, reg_val);\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HDCP_INT_CTRL, 0);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\thdmi_write(hdmi, REG_HDMI_HDCP_RESET,\n\t\tHDMI_HDCP_RESET_LINK0_DEAUTHENTICATE);\n\n\t \n\tif (msm_hdmi_hdcp_hw_ddc_clean(hdcp_ctrl)) {\n\t\tpr_info(\"%s: reauth work aborted\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HDCP_CTRL, 0);\n\n\t \n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\treg_val = hdmi_read(hdmi, REG_HDMI_HPD_CTRL);\n\treg_val |= HDMI_HPD_CTRL_ENABLE;\n\thdmi_write(hdmi, REG_HDMI_HPD_CTRL, reg_val);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\t \n\tif (++hdcp_ctrl->auth_retries == AUTH_RETRIES_TIME) {\n\t\thdcp_ctrl->hdcp_state = HDCP_STATE_INACTIVE;\n\t\thdcp_ctrl->auth_retries = 0;\n\t\tpr_info(\"%s: abort reauthentication!\\n\", __func__);\n\n\t\treturn;\n\t}\n\n\tDBG(\"Queue AUTH WORK\");\n\thdcp_ctrl->hdcp_state = HDCP_STATE_AUTHENTICATING;\n\tqueue_work(hdmi->workq, &hdcp_ctrl->hdcp_auth_work);\n}\n\nstatic int msm_hdmi_hdcp_auth_prepare(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 link0_status;\n\tu32 reg_val;\n\tunsigned long flags;\n\tint rc;\n\n\tif (!hdcp_ctrl->aksv_valid) {\n\t\trc = msm_hdmi_hdcp_read_validate_aksv(hdcp_ctrl);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: ASKV validation failed\\n\", __func__);\n\t\t\thdcp_ctrl->hdcp_state = HDCP_STATE_NO_AKSV;\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\thdcp_ctrl->aksv_valid = true;\n\t}\n\n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\t \n\treg_val = hdmi_read(hdmi, REG_HDMI_CTRL);\n\treg_val &= ~HDMI_CTRL_ENCRYPTED;\n\thdmi_write(hdmi, REG_HDMI_CTRL, reg_val);\n\n\t \n\treg_val = hdmi_read(hdmi, REG_HDMI_DDC_ARBITRATION);\n\treg_val &= ~HDMI_DDC_ARBITRATION_HW_ARBITRATION;\n\thdmi_write(hdmi, REG_HDMI_DDC_ARBITRATION, reg_val);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HDCP_SW_LOWER_AKSV, hdcp_ctrl->aksv_lsb);\n\thdmi_write(hdmi, REG_HDMI_HDCP_SW_UPPER_AKSV, hdcp_ctrl->aksv_msb);\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HDCP_ENTROPY_CTRL0, 0xB1FFB0FF);\n\thdmi_write(hdmi, REG_HDMI_HDCP_ENTROPY_CTRL1, 0xF00DFACE);\n\n\t \n\treg_val = hdmi_read(hdmi, REG_HDMI_HDCP_DEBUG_CTRL);\n\treg_val &= ~HDMI_HDCP_DEBUG_CTRL_RNG_CIPHER;\n\thdmi_write(hdmi, REG_HDMI_HDCP_DEBUG_CTRL, reg_val);\n\tDBG(\"HDCP_DEBUG_CTRL=0x%08x\",\n\t\thdmi_read(hdmi, REG_HDMI_HDCP_DEBUG_CTRL));\n\n\t \n\twmb();\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HDCP_CTRL, HDMI_HDCP_CTRL_ENABLE);\n\n\t \n\tlink0_status = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\n\tDBG(\"After enabling HDCP Link0_Status=0x%08x\", link0_status);\n\tif (!(link0_status &\n\t\t(HDMI_HDCP_LINK0_STATUS_AN_0_READY |\n\t\tHDMI_HDCP_LINK0_STATUS_AN_1_READY)))\n\t\tDBG(\"An not ready after enabling HDCP\");\n\n\t \n\trc = msm_reset_hdcp_ddc_failures(hdcp_ctrl);\n\n\treturn rc;\n}\n\nstatic void msm_hdmi_hdcp_auth_fail(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 reg_val;\n\tunsigned long flags;\n\n\tDBG(\"hdcp auth failed, queue reauth work\");\n\t \n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\treg_val = hdmi_read(hdmi, REG_HDMI_CTRL);\n\treg_val &= ~HDMI_CTRL_ENCRYPTED;\n\thdmi_write(hdmi, REG_HDMI_CTRL, reg_val);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\thdcp_ctrl->hdcp_state = HDCP_STATE_AUTH_FAILED;\n\tqueue_work(hdmi->workq, &hdcp_ctrl->hdcp_reauth_work);\n}\n\nstatic void msm_hdmi_hdcp_auth_done(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 reg_val;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\treg_val = hdmi_read(hdmi, REG_HDMI_DDC_ARBITRATION);\n\treg_val |= HDMI_DDC_ARBITRATION_HW_ARBITRATION;\n\thdmi_write(hdmi, REG_HDMI_DDC_ARBITRATION, reg_val);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\t \n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\treg_val = hdmi_read(hdmi, REG_HDMI_CTRL);\n\treg_val |= HDMI_CTRL_ENCRYPTED;\n\thdmi_write(hdmi, REG_HDMI_CTRL, reg_val);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\thdcp_ctrl->hdcp_state = HDCP_STATE_AUTHENTICATED;\n\thdcp_ctrl->auth_retries = 0;\n}\n\n \nstatic int msm_hdmi_hdcp_wait_key_an_ready(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tint rc;\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 link0_status, keys_state;\n\tu32 timeout_count;\n\tbool an_ready;\n\n\t \n\ttimeout_count = 100;\n\tdo {\n\t\tlink0_status = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\n\t\tkeys_state = (link0_status >> 28) & 0x7;\n\t\tif (keys_state == HDCP_KEYS_STATE_VALID)\n\t\t\tbreak;\n\n\t\tDBG(\"Keys not ready(%d). s=%d, l0=%0x08x\",\n\t\t\ttimeout_count, keys_state, link0_status);\n\n\t\ttimeout_count--;\n\t\tif (!timeout_count) {\n\t\t\tpr_err(\"%s: Wait key state timedout\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\trc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} while (1);\n\n\ttimeout_count = 100;\n\tdo {\n\t\tlink0_status = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\n\t\tan_ready = (link0_status & HDMI_HDCP_LINK0_STATUS_AN_0_READY)\n\t\t\t&& (link0_status & HDMI_HDCP_LINK0_STATUS_AN_1_READY);\n\t\tif (an_ready)\n\t\t\tbreak;\n\n\t\tDBG(\"An not ready(%d). l0_status=0x%08x\",\n\t\t\ttimeout_count, link0_status);\n\n\t\ttimeout_count--;\n\t\tif (!timeout_count) {\n\t\t\tpr_err(\"%s: Wait An timedout\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\trc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic int msm_hdmi_hdcp_send_aksv_an(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tint rc = 0;\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 link0_aksv_0, link0_aksv_1;\n\tu32 link0_an[2];\n\tu8 aksv[5];\n\n\t \n\tlink0_an[0] = hdmi_read(hdmi, REG_HDMI_HDCP_RCVPORT_DATA5);\n\tlink0_an[1] = hdmi_read(hdmi, REG_HDMI_HDCP_RCVPORT_DATA6);\n\n\t \n\tlink0_aksv_0 = hdmi_read(hdmi, REG_HDMI_HDCP_RCVPORT_DATA3);\n\tlink0_aksv_1 = hdmi_read(hdmi, REG_HDMI_HDCP_RCVPORT_DATA4);\n\n\tDBG(\"Link ASKV=%08x%08x\", link0_aksv_0, link0_aksv_1);\n\t \n\taksv[0] =  link0_aksv_0        & 0xFF;\n\taksv[1] = (link0_aksv_0 >> 8)  & 0xFF;\n\taksv[2] = (link0_aksv_0 >> 16) & 0xFF;\n\taksv[3] = (link0_aksv_0 >> 24) & 0xFF;\n\taksv[4] =  link0_aksv_1        & 0xFF;\n\n\t \n\trc = msm_hdmi_ddc_write(hdmi, HDCP_PORT_ADDR, 0x18, (u8 *)link0_an,\n\t\t(u16)sizeof(link0_an));\n\tif (rc) {\n\t\tpr_err(\"%s:An write failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\tDBG(\"Link0-An=%08x%08x\", link0_an[0], link0_an[1]);\n\n\t \n\trc = msm_hdmi_ddc_write(hdmi, HDCP_PORT_ADDR, 0x10, aksv, 5);\n\tif (rc) {\n\t\tpr_err(\"%s:AKSV write failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\tDBG(\"Link0-AKSV=%02x%08x\", link0_aksv_1 & 0xFF, link0_aksv_0);\n\n\treturn 0;\n}\n\nstatic int msm_hdmi_hdcp_recv_bksv(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tint rc = 0;\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu8 bksv[5];\n\tu32 reg[2], data[2];\n\n\t \n\trc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x00, bksv, 5);\n\tif (rc) {\n\t\tpr_err(\"%s:BKSV read failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\thdcp_ctrl->bksv_lsb = bksv[0] | (bksv[1] << 8) |\n\t\t(bksv[2] << 16) | (bksv[3] << 24);\n\thdcp_ctrl->bksv_msb = bksv[4];\n\tDBG(\":BKSV=%02x%08x\", hdcp_ctrl->bksv_msb, hdcp_ctrl->bksv_lsb);\n\n\t \n\tif ((hweight32(hdcp_ctrl->bksv_lsb) + hweight32(hdcp_ctrl->bksv_msb))\n\t\t\t!= 20) {\n\t\tpr_err(\": BKSV doesn't have 20 1's and 20 0's\\n\");\n\t\tpr_err(\": BKSV chk fail. BKSV=%02x%02x%02x%02x%02x\\n\",\n\t\t\tbksv[4], bksv[3], bksv[2], bksv[1], bksv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treg[0] = REG_HDMI_HDCP_RCVPORT_DATA0;\n\tdata[0] = hdcp_ctrl->bksv_lsb;\n\treg[1] = REG_HDMI_HDCP_RCVPORT_DATA1;\n\tdata[1] = hdcp_ctrl->bksv_msb;\n\trc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, reg, data, 2);\n\n\treturn rc;\n}\n\nstatic int msm_hdmi_hdcp_recv_bcaps(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tint rc = 0;\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 reg, data;\n\tu8 bcaps;\n\n\trc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x40, &bcaps, 1);\n\tif (rc) {\n\t\tpr_err(\"%s:BCAPS read failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\tDBG(\"BCAPS=%02x\", bcaps);\n\n\t \n\thdcp_ctrl->ds_type = (bcaps & BIT(6)) ? DS_REPEATER : DS_RECEIVER;\n\n\t \n\treg = REG_HDMI_HDCP_RCVPORT_DATA12;\n\tdata = (u32)bcaps;\n\trc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, &reg, &data, 1);\n\n\treturn rc;\n}\n\nstatic int msm_hdmi_hdcp_auth_part1_key_exchange(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tunsigned long flags;\n\tint rc;\n\n\t \n\trc = msm_hdmi_hdcp_wait_key_an_ready(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s: wait key and an ready failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t \n\trc = msm_hdmi_hdcp_recv_bcaps(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s: read bcaps error, abort\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HDCP_RCVPORT_DATA4, 0);\n\n\t \n\trc = msm_hdmi_hdcp_send_aksv_an(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s:An/Aksv write failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t \n\trc = msm_hdmi_hdcp_recv_bksv(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s:BKSV Process failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t \n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\thdmi_write(hdmi, REG_HDMI_HDCP_INT_CTRL,\n\t\tHDMI_HDCP_INT_CTRL_AUTH_SUCCESS_ACK |\n\t\tHDMI_HDCP_INT_CTRL_AUTH_SUCCESS_MASK |\n\t\tHDMI_HDCP_INT_CTRL_AUTH_FAIL_ACK |\n\t\tHDMI_HDCP_INT_CTRL_AUTH_FAIL_MASK |\n\t\tHDMI_HDCP_INT_CTRL_AUTH_FAIL_INFO_ACK);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int msm_hdmi_hdcp_auth_part1_recv_r0(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tint rc = 0;\n\tu8 buf[2];\n\n\t \n\trc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 125, AUTH_ABORT_EV);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x08, buf, 2);\n\tif (rc) {\n\t\tpr_err(\"%s:R0' read failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\tDBG(\"R0'=%02x%02x\", buf[1], buf[0]);\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HDCP_RCVPORT_DATA2_0,\n\t\t(((u32)buf[1]) << 8) | buf[0]);\n\n\treturn 0;\n}\n\n \nstatic int msm_hdmi_hdcp_auth_part1_verify_r0(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 link0_status;\n\tint rc;\n\n\t \n\trc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 10000, AUTH_RESULT_RDY_EV);\n\tif (!rc) {\n\t\tpr_err(\"%s: Wait Auth IRQ timeout\\n\", __func__);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tlink0_status = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\n\tif (!(link0_status & HDMI_HDCP_LINK0_STATUS_RI_MATCHES)) {\n\t\tpr_err(\"%s: Authentication Part I failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HDCP_CTRL,\n\t\tHDMI_HDCP_CTRL_ENABLE |\n\t\tHDMI_HDCP_CTRL_ENCRYPTION_ENABLE);\n\n\treturn 0;\n}\n\nstatic int msm_hdmi_hdcp_recv_check_bstatus(struct hdmi_hdcp_ctrl *hdcp_ctrl,\n\tu16 *pbstatus)\n{\n\tint rc;\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tbool max_devs_exceeded = false, max_cascade_exceeded = false;\n\tu32 repeater_cascade_depth = 0, down_stream_devices = 0;\n\tu16 bstatus;\n\tu8 buf[2];\n\n\t \n\trc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x41, buf, 2);\n\tif (rc) {\n\t\tpr_err(\"%s: BSTATUS read failed\\n\", __func__);\n\t\tgoto error;\n\t}\n\t*pbstatus = bstatus = (buf[1] << 8) | buf[0];\n\n\n\tdown_stream_devices = bstatus & 0x7F;\n\trepeater_cascade_depth = (bstatus >> 8) & 0x7;\n\tmax_devs_exceeded = (bstatus & BIT(7)) ? true : false;\n\tmax_cascade_exceeded = (bstatus & BIT(11)) ? true : false;\n\n\tif (down_stream_devices == 0) {\n\t\t \n\t\tpr_err(\"%s: No downstream devices\\n\", __func__);\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tif (max_devs_exceeded) {\n\t\tpr_err(\"%s: no. of devs connected exceeds max allowed\",\n\t\t\t__func__);\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tif (max_cascade_exceeded) {\n\t\tpr_err(\"%s: no. of cascade conn exceeds max allowed\",\n\t\t\t__func__);\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\nerror:\n\thdcp_ctrl->dev_count = down_stream_devices;\n\thdcp_ctrl->max_cascade_exceeded = max_cascade_exceeded;\n\thdcp_ctrl->max_dev_exceeded = max_devs_exceeded;\n\thdcp_ctrl->depth = repeater_cascade_depth;\n\treturn rc;\n}\n\nstatic int msm_hdmi_hdcp_auth_part2_wait_ksv_fifo_ready(\n\tstruct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tint rc;\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 reg, data;\n\tu32 timeout_count;\n\tu16 bstatus;\n\tu8 bcaps;\n\n\t \n\ttimeout_count = 100;\n\tdo {\n\t\t \n\t\trc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x40, &bcaps, 1);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: BCAPS read failed\\n\", __func__);\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (bcaps & BIT(5))\n\t\t\tbreak;\n\n\t\ttimeout_count--;\n\t\tif (!timeout_count) {\n\t\t\tpr_err(\"%s: Wait KSV fifo ready timedout\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\trc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} while (1);\n\n\trc = msm_hdmi_hdcp_recv_check_bstatus(hdcp_ctrl, &bstatus);\n\tif (rc) {\n\t\tpr_err(\"%s: bstatus error\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t \n\treg = REG_HDMI_HDCP_RCVPORT_DATA12;\n\tdata = bcaps | (bstatus << 8);\n\trc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, &reg, &data, 1);\n\tif (rc) {\n\t\tpr_err(\"%s: BSTATUS write failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int msm_hdmi_hdcp_transfer_v_h(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tint rc = 0;\n\tstruct hdmi_hdcp_reg_data reg_data[]  = {\n\t\t{REG_HDMI_HDCP_RCVPORT_DATA7,  0x20, \"V' H0\"},\n\t\t{REG_HDMI_HDCP_RCVPORT_DATA8,  0x24, \"V' H1\"},\n\t\t{REG_HDMI_HDCP_RCVPORT_DATA9,  0x28, \"V' H2\"},\n\t\t{REG_HDMI_HDCP_RCVPORT_DATA10, 0x2C, \"V' H3\"},\n\t\t{REG_HDMI_HDCP_RCVPORT_DATA11, 0x30, \"V' H4\"},\n\t};\n\tstruct hdmi_hdcp_reg_data *rd;\n\tu32 size = ARRAY_SIZE(reg_data);\n\tu32 reg[ARRAY_SIZE(reg_data)];\n\tu32 data[ARRAY_SIZE(reg_data)];\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\trd = &reg_data[i];\n\t\trc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR,\n\t\t\trd->off, (u8 *)&data[i], (u16)sizeof(data[i]));\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Read %s failed\\n\", __func__, rd->name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tDBG(\"%s =%x\", rd->name, data[i]);\n\t\treg[i] = reg_data[i].reg_id;\n\t}\n\n\trc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, reg, data, size);\n\nerror:\n\treturn rc;\n}\n\nstatic int msm_hdmi_hdcp_recv_ksv_fifo(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tint rc;\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 ksv_bytes;\n\n\tksv_bytes = 5 * hdcp_ctrl->dev_count;\n\n\trc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x43,\n\t\thdcp_ctrl->ksv_list, ksv_bytes);\n\tif (rc)\n\t\tpr_err(\"%s: KSV FIFO read failed\\n\", __func__);\n\n\treturn rc;\n}\n\nstatic int msm_hdmi_hdcp_reset_sha_engine(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tu32 reg[2], data[2];\n\tu32 rc  = 0;\n\n\treg[0] = REG_HDMI_HDCP_SHA_CTRL;\n\tdata[0] = HDCP_REG_ENABLE;\n\treg[1] = REG_HDMI_HDCP_SHA_CTRL;\n\tdata[1] = HDCP_REG_DISABLE;\n\n\trc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, reg, data, 2);\n\n\treturn rc;\n}\n\nstatic int msm_hdmi_hdcp_auth_part2_recv_ksv_fifo(\n\tstruct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tint rc;\n\tu32 timeout_count;\n\n\t \n\ttimeout_count = 100;\n\tdo {\n\t\trc = msm_hdmi_hdcp_recv_ksv_fifo(hdcp_ctrl);\n\t\tif (!rc)\n\t\t\tbreak;\n\n\t\ttimeout_count--;\n\t\tif (!timeout_count) {\n\t\t\tpr_err(\"%s: Recv ksv fifo timedout\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\trc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 25, AUTH_ABORT_EV);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} while (1);\n\n\trc = msm_hdmi_hdcp_transfer_v_h(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s: transfer V failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t \n\trc = msm_hdmi_hdcp_reset_sha_engine(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s: fail to reset sha engine\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int msm_hdmi_hdcp_write_ksv_fifo(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tint i;\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 ksv_bytes, last_byte = 0;\n\tu8 *ksv_fifo = NULL;\n\tu32 reg_val, data, reg;\n\tu32 rc  = 0;\n\n\tksv_bytes  = 5 * hdcp_ctrl->dev_count;\n\n\t \n\tif (hdcp_ctrl->ksv_fifo_w_index) {\n\t\treg_val = hdmi_read(hdmi, REG_HDMI_HDCP_SHA_STATUS);\n\t\tDBG(\"HDCP_SHA_STATUS=%08x\", reg_val);\n\t\tif (hdcp_ctrl->ksv_fifo_w_index == ksv_bytes) {\n\t\t\t \n\t\t\tif (reg_val & HDMI_HDCP_SHA_STATUS_COMP_DONE) {\n\t\t\t\tDBG(\"COMP_DONE\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (!(reg_val & HDMI_HDCP_SHA_STATUS_BLOCK_DONE))\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tDBG(\"BLOCK_DONE\");\n\t\t}\n\t}\n\n\tksv_bytes  -= hdcp_ctrl->ksv_fifo_w_index;\n\tif (ksv_bytes <= 64)\n\t\tlast_byte = 1;\n\telse\n\t\tksv_bytes = 64;\n\n\tksv_fifo = hdcp_ctrl->ksv_list;\n\tksv_fifo += hdcp_ctrl->ksv_fifo_w_index;\n\n\tfor (i = 0; i < ksv_bytes; i++) {\n\t\t \n\t\treg_val = ksv_fifo[i] << 16;\n\t\tif ((i == (ksv_bytes - 1)) && last_byte)\n\t\t\treg_val |= HDMI_HDCP_SHA_DATA_DONE;\n\n\t\treg = REG_HDMI_HDCP_SHA_DATA;\n\t\tdata = reg_val;\n\t\trc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, &reg, &data, 1);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\thdcp_ctrl->ksv_fifo_w_index += ksv_bytes;\n\n\t \n\treturn -EAGAIN;\n}\n\n \nstatic int msm_hdmi_hdcp_auth_part2_write_ksv_fifo(\n\tstruct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tint rc;\n\tu32 timeout_count;\n\n\thdcp_ctrl->ksv_fifo_w_index = 0;\n\ttimeout_count = 100;\n\tdo {\n\t\trc = msm_hdmi_hdcp_write_ksv_fifo(hdcp_ctrl);\n\t\tif (!rc)\n\t\t\tbreak;\n\n\t\tif (rc != -EAGAIN)\n\t\t\treturn rc;\n\n\t\ttimeout_count--;\n\t\tif (!timeout_count) {\n\t\t\tpr_err(\"%s: Write KSV fifo timedout\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\trc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic int msm_hdmi_hdcp_auth_part2_check_v_match(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tint rc = 0;\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 link0_status;\n\tu32 timeout_count = 100;\n\n\tdo {\n\t\tlink0_status = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\n\t\tif (link0_status & HDMI_HDCP_LINK0_STATUS_V_MATCHES)\n\t\t\tbreak;\n\n\t\ttimeout_count--;\n\t\tif (!timeout_count) {\n\t\t\t\tpr_err(\"%s: HDCP V Match timedout\", __func__);\n\t\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\trc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic void msm_hdmi_hdcp_auth_work(struct work_struct *work)\n{\n\tstruct hdmi_hdcp_ctrl *hdcp_ctrl = container_of(work,\n\t\tstruct hdmi_hdcp_ctrl, hdcp_auth_work);\n\tint rc;\n\n\trc = msm_hdmi_hdcp_auth_prepare(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s: auth prepare failed %d\\n\", __func__, rc);\n\t\tgoto end;\n\t}\n\n\t \n\trc = msm_hdmi_hdcp_auth_part1_key_exchange(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s: key exchange failed %d\\n\", __func__, rc);\n\t\tgoto end;\n\t}\n\n\trc = msm_hdmi_hdcp_auth_part1_recv_r0(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s: receive r0 failed %d\\n\", __func__, rc);\n\t\tgoto end;\n\t}\n\n\trc = msm_hdmi_hdcp_auth_part1_verify_r0(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s: verify r0 failed %d\\n\", __func__, rc);\n\t\tgoto end;\n\t}\n\tpr_info(\"%s: Authentication Part I successful\\n\", __func__);\n\tif (hdcp_ctrl->ds_type == DS_RECEIVER)\n\t\tgoto end;\n\n\t \n\trc = msm_hdmi_hdcp_auth_part2_wait_ksv_fifo_ready(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s: wait ksv fifo ready failed %d\\n\", __func__, rc);\n\t\tgoto end;\n\t}\n\n\trc = msm_hdmi_hdcp_auth_part2_recv_ksv_fifo(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s: recv ksv fifo failed %d\\n\", __func__, rc);\n\t\tgoto end;\n\t}\n\n\trc = msm_hdmi_hdcp_auth_part2_write_ksv_fifo(hdcp_ctrl);\n\tif (rc) {\n\t\tpr_err(\"%s: write ksv fifo failed %d\\n\", __func__, rc);\n\t\tgoto end;\n\t}\n\n\trc = msm_hdmi_hdcp_auth_part2_check_v_match(hdcp_ctrl);\n\tif (rc)\n\t\tpr_err(\"%s: check v match failed %d\\n\", __func__, rc);\n\nend:\n\tif (rc == -ECANCELED) {\n\t\tpr_info(\"%s: hdcp authentication canceled\\n\", __func__);\n\t} else if (rc == -ENOTSUPP) {\n\t\tpr_info(\"%s: hdcp is not supported\\n\", __func__);\n\t} else if (rc) {\n\t\tpr_err(\"%s: hdcp authentication failed\\n\", __func__);\n\t\tmsm_hdmi_hdcp_auth_fail(hdcp_ctrl);\n\t} else {\n\t\tmsm_hdmi_hdcp_auth_done(hdcp_ctrl);\n\t}\n}\n\nvoid msm_hdmi_hdcp_on(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tu32 reg_val;\n\tunsigned long flags;\n\n\tif ((HDCP_STATE_INACTIVE != hdcp_ctrl->hdcp_state) ||\n\t\t(HDCP_STATE_NO_AKSV == hdcp_ctrl->hdcp_state)) {\n\t\tDBG(\"still active or activating or no askv. returning\");\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\treg_val = hdmi_read(hdmi, REG_HDMI_CTRL);\n\treg_val &= ~HDMI_CTRL_ENCRYPTED;\n\thdmi_write(hdmi, REG_HDMI_CTRL, reg_val);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\thdcp_ctrl->auth_event = 0;\n\thdcp_ctrl->hdcp_state = HDCP_STATE_AUTHENTICATING;\n\thdcp_ctrl->auth_retries = 0;\n\tqueue_work(hdmi->workq, &hdcp_ctrl->hdcp_auth_work);\n}\n\nvoid msm_hdmi_hdcp_off(struct hdmi_hdcp_ctrl *hdcp_ctrl)\n{\n\tstruct hdmi *hdmi = hdcp_ctrl->hdmi;\n\tunsigned long flags;\n\tu32 reg_val;\n\n\tif ((HDCP_STATE_INACTIVE == hdcp_ctrl->hdcp_state) ||\n\t\t(HDCP_STATE_NO_AKSV == hdcp_ctrl->hdcp_state)) {\n\t\tDBG(\"hdcp inactive or no aksv. returning\");\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\treg_val = hdmi_read(hdmi, REG_HDMI_HPD_CTRL);\n\treg_val &= ~HDMI_HPD_CTRL_ENABLE;\n\thdmi_write(hdmi, REG_HDMI_HPD_CTRL, reg_val);\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HDCP_INT_CTRL, 0);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\t \n\tset_bit(AUTH_ABORT_EV, &hdcp_ctrl->auth_event);\n\twake_up_all(&hdcp_ctrl->auth_event_queue);\n\tcancel_work_sync(&hdcp_ctrl->hdcp_auth_work);\n\tcancel_work_sync(&hdcp_ctrl->hdcp_reauth_work);\n\n\thdmi_write(hdmi, REG_HDMI_HDCP_RESET,\n\t\tHDMI_HDCP_RESET_LINK0_DEAUTHENTICATE);\n\n\t \n\thdmi_write(hdmi, REG_HDMI_HDCP_CTRL, 0);\n\n\tspin_lock_irqsave(&hdmi->reg_lock, flags);\n\treg_val = hdmi_read(hdmi, REG_HDMI_CTRL);\n\treg_val &= ~HDMI_CTRL_ENCRYPTED;\n\thdmi_write(hdmi, REG_HDMI_CTRL, reg_val);\n\n\t \n\treg_val = hdmi_read(hdmi, REG_HDMI_HPD_CTRL);\n\treg_val |= HDMI_HPD_CTRL_ENABLE;\n\thdmi_write(hdmi, REG_HDMI_HPD_CTRL, reg_val);\n\tspin_unlock_irqrestore(&hdmi->reg_lock, flags);\n\n\thdcp_ctrl->hdcp_state = HDCP_STATE_INACTIVE;\n\n\tDBG(\"HDCP: Off\");\n}\n\nstruct hdmi_hdcp_ctrl *msm_hdmi_hdcp_init(struct hdmi *hdmi)\n{\n\tstruct hdmi_hdcp_ctrl *hdcp_ctrl = NULL;\n\n\tif (!hdmi->qfprom_mmio) {\n\t\tpr_err(\"%s: HDCP is not supported without qfprom\\n\",\n\t\t\t__func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\thdcp_ctrl = kzalloc(sizeof(*hdcp_ctrl), GFP_KERNEL);\n\tif (!hdcp_ctrl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_WORK(&hdcp_ctrl->hdcp_auth_work, msm_hdmi_hdcp_auth_work);\n\tINIT_WORK(&hdcp_ctrl->hdcp_reauth_work, msm_hdmi_hdcp_reauth_work);\n\tinit_waitqueue_head(&hdcp_ctrl->auth_event_queue);\n\thdcp_ctrl->hdmi = hdmi;\n\thdcp_ctrl->hdcp_state = HDCP_STATE_INACTIVE;\n\thdcp_ctrl->aksv_valid = false;\n\n\tif (qcom_scm_hdcp_available())\n\t\thdcp_ctrl->tz_hdcp = true;\n\telse\n\t\thdcp_ctrl->tz_hdcp = false;\n\n\treturn hdcp_ctrl;\n}\n\nvoid msm_hdmi_hdcp_destroy(struct hdmi *hdmi)\n{\n\tif (hdmi) {\n\t\tkfree(hdmi->hdcp_ctrl);\n\t\thdmi->hdcp_ctrl = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}