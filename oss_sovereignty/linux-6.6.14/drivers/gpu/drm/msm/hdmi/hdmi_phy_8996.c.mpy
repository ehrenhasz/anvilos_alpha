{
  "module_name": "hdmi_phy_8996.c",
  "hash_id": "f5c4707c2fb18cfc6c308f4e05c94d1fef8f650491ec78791300f405bd3726dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/hdmi/hdmi_phy_8996.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n\n#include \"hdmi.h\"\n\n#define HDMI_VCO_MAX_FREQ\t\t\t12000000000UL\n#define HDMI_VCO_MIN_FREQ\t\t\t8000000000UL\n\n#define HDMI_PCLK_MAX_FREQ\t\t\t600000000\n#define HDMI_PCLK_MIN_FREQ\t\t\t25000000\n\n#define HDMI_HIGH_FREQ_BIT_CLK_THRESHOLD\t3400000000UL\n#define HDMI_DIG_FREQ_BIT_CLK_THRESHOLD\t\t1500000000UL\n#define HDMI_MID_FREQ_BIT_CLK_THRESHOLD\t\t750000000UL\n#define HDMI_CORECLK_DIV\t\t\t5\n#define HDMI_DEFAULT_REF_CLOCK\t\t\t19200000\n#define HDMI_PLL_CMP_CNT\t\t\t1024\n\n#define HDMI_PLL_POLL_MAX_READS\t\t\t100\n#define HDMI_PLL_POLL_TIMEOUT_US\t\t150\n\n#define HDMI_NUM_TX_CHANNEL\t\t\t4\n\nstruct hdmi_pll_8996 {\n\tstruct platform_device *pdev;\n\tstruct clk_hw clk_hw;\n\n\t \n\tvoid __iomem *mmio_qserdes_com;\n\t \n\tvoid __iomem *mmio_qserdes_tx[HDMI_NUM_TX_CHANNEL];\n};\n\n#define hw_clk_to_pll(x) container_of(x, struct hdmi_pll_8996, clk_hw)\n\nstruct hdmi_8996_phy_pll_reg_cfg {\n\tu32 tx_lx_lane_mode[HDMI_NUM_TX_CHANNEL];\n\tu32 tx_lx_tx_band[HDMI_NUM_TX_CHANNEL];\n\tu32 com_svs_mode_clk_sel;\n\tu32 com_hsclk_sel;\n\tu32 com_pll_cctrl_mode0;\n\tu32 com_pll_rctrl_mode0;\n\tu32 com_cp_ctrl_mode0;\n\tu32 com_dec_start_mode0;\n\tu32 com_div_frac_start1_mode0;\n\tu32 com_div_frac_start2_mode0;\n\tu32 com_div_frac_start3_mode0;\n\tu32 com_integloop_gain0_mode0;\n\tu32 com_integloop_gain1_mode0;\n\tu32 com_lock_cmp_en;\n\tu32 com_lock_cmp1_mode0;\n\tu32 com_lock_cmp2_mode0;\n\tu32 com_lock_cmp3_mode0;\n\tu32 com_core_clk_en;\n\tu32 com_coreclk_div;\n\tu32 com_vco_tune_ctrl;\n\n\tu32 tx_lx_tx_drv_lvl[HDMI_NUM_TX_CHANNEL];\n\tu32 tx_lx_tx_emp_post1_lvl[HDMI_NUM_TX_CHANNEL];\n\tu32 tx_lx_vmode_ctrl1[HDMI_NUM_TX_CHANNEL];\n\tu32 tx_lx_vmode_ctrl2[HDMI_NUM_TX_CHANNEL];\n\tu32 tx_lx_res_code_lane_tx[HDMI_NUM_TX_CHANNEL];\n\tu32 tx_lx_hp_pd_enables[HDMI_NUM_TX_CHANNEL];\n\n\tu32 phy_mode;\n};\n\nstruct hdmi_8996_post_divider {\n\tu64 vco_freq;\n\tint hsclk_divsel;\n\tint vco_ratio;\n\tint tx_band_sel;\n\tint half_rate_mode;\n};\n\nstatic inline struct hdmi_phy *pll_get_phy(struct hdmi_pll_8996 *pll)\n{\n\treturn platform_get_drvdata(pll->pdev);\n}\n\nstatic inline void hdmi_pll_write(struct hdmi_pll_8996 *pll, int offset,\n\t\t\t\t  u32 data)\n{\n\tmsm_writel(data, pll->mmio_qserdes_com + offset);\n}\n\nstatic inline u32 hdmi_pll_read(struct hdmi_pll_8996 *pll, int offset)\n{\n\treturn msm_readl(pll->mmio_qserdes_com + offset);\n}\n\nstatic inline void hdmi_tx_chan_write(struct hdmi_pll_8996 *pll, int channel,\n\t\t\t\t      int offset, int data)\n{\n\t msm_writel(data, pll->mmio_qserdes_tx[channel] + offset);\n}\n\nstatic inline u32 pll_get_cpctrl(u64 frac_start, unsigned long ref_clk,\n\t\t\t\t bool gen_ssc)\n{\n\tif ((frac_start != 0) || gen_ssc)\n\t\treturn (11000000 / (ref_clk / 20));\n\n\treturn 0x23;\n}\n\nstatic inline u32 pll_get_rctrl(u64 frac_start, bool gen_ssc)\n{\n\tif ((frac_start != 0) || gen_ssc)\n\t\treturn 0x16;\n\n\treturn 0x10;\n}\n\nstatic inline u32 pll_get_cctrl(u64 frac_start, bool gen_ssc)\n{\n\tif ((frac_start != 0) || gen_ssc)\n\t\treturn 0x28;\n\n\treturn 0x1;\n}\n\nstatic inline u32 pll_get_integloop_gain(u64 frac_start, u64 bclk, u32 ref_clk,\n\t\t\t\t\t bool gen_ssc)\n{\n\tint digclk_divsel = bclk >= HDMI_DIG_FREQ_BIT_CLK_THRESHOLD ? 1 : 2;\n\tu64 base;\n\n\tif ((frac_start != 0) || gen_ssc)\n\t\tbase = (64 * ref_clk) / HDMI_DEFAULT_REF_CLOCK;\n\telse\n\t\tbase = (1022 * ref_clk) / 100;\n\n\tbase <<= digclk_divsel;\n\n\treturn (base <= 2046 ? base : 2046);\n}\n\nstatic inline u32 pll_get_pll_cmp(u64 fdata, unsigned long ref_clk)\n{\n\tu64 dividend = HDMI_PLL_CMP_CNT * fdata;\n\tu32 divisor = ref_clk * 10;\n\tu32 rem;\n\n\trem = do_div(dividend, divisor);\n\tif (rem > (divisor >> 1))\n\t\tdividend++;\n\n\treturn dividend - 1;\n}\n\nstatic inline u64 pll_cmp_to_fdata(u32 pll_cmp, unsigned long ref_clk)\n{\n\tu64 fdata = ((u64)pll_cmp) * ref_clk * 10;\n\n\tdo_div(fdata, HDMI_PLL_CMP_CNT);\n\n\treturn fdata;\n}\n\nstatic int pll_get_post_div(struct hdmi_8996_post_divider *pd, u64 bclk)\n{\n\tint ratio[] = { 2, 3, 4, 5, 6, 9, 10, 12, 14, 15, 20, 21, 25, 28, 35 };\n\tint hs_divsel[] = { 0, 4, 8, 12, 1, 5, 2, 9, 3, 13, 10, 7, 14, 11, 15 };\n\tint tx_band_sel[] = { 0, 1, 2, 3 };\n\tu64 vco_freq[60];\n\tu64 vco, vco_optimal;\n\tint half_rate_mode = 0;\n\tint vco_optimal_index, vco_freq_index;\n\tint i, j;\n\nretry:\n\tvco_optimal = HDMI_VCO_MAX_FREQ;\n\tvco_optimal_index = -1;\n\tvco_freq_index = 0;\n\tfor (i = 0; i < 15; i++) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tu32 ratio_mult = ratio[i] << tx_band_sel[j];\n\n\t\t\tvco = bclk >> half_rate_mode;\n\t\t\tvco *= ratio_mult;\n\t\t\tvco_freq[vco_freq_index++] = vco;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 60; i++) {\n\t\tu64 vco_tmp = vco_freq[i];\n\n\t\tif ((vco_tmp >= HDMI_VCO_MIN_FREQ) &&\n\t\t    (vco_tmp <= vco_optimal)) {\n\t\t\tvco_optimal = vco_tmp;\n\t\t\tvco_optimal_index = i;\n\t\t}\n\t}\n\n\tif (vco_optimal_index == -1) {\n\t\tif (!half_rate_mode) {\n\t\t\thalf_rate_mode = 1;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\tpd->vco_freq = vco_optimal;\n\t\tpd->tx_band_sel = tx_band_sel[vco_optimal_index % 4];\n\t\tpd->vco_ratio = ratio[vco_optimal_index / 4];\n\t\tpd->hsclk_divsel = hs_divsel[vco_optimal_index / 4];\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int pll_calculate(unsigned long pix_clk, unsigned long ref_clk,\n\t\t\t struct hdmi_8996_phy_pll_reg_cfg *cfg)\n{\n\tstruct hdmi_8996_post_divider pd;\n\tu64 bclk;\n\tu64 tmds_clk;\n\tu64 dec_start;\n\tu64 frac_start;\n\tu64 fdata;\n\tu32 pll_divisor;\n\tu32 rem;\n\tu32 cpctrl;\n\tu32 rctrl;\n\tu32 cctrl;\n\tu32 integloop_gain;\n\tu32 pll_cmp;\n\tint i, ret;\n\n\t \n\tbclk = ((u64)pix_clk) * 10;\n\n\tif (bclk > HDMI_HIGH_FREQ_BIT_CLK_THRESHOLD)\n\t\ttmds_clk = pix_clk >> 2;\n\telse\n\t\ttmds_clk = pix_clk;\n\n\tret = pll_get_post_div(&pd, bclk);\n\tif (ret)\n\t\treturn ret;\n\n\tdec_start = pd.vco_freq;\n\tpll_divisor = 4 * ref_clk;\n\tdo_div(dec_start, pll_divisor);\n\n\tfrac_start = pd.vco_freq * (1 << 20);\n\n\trem = do_div(frac_start, pll_divisor);\n\tfrac_start -= dec_start * (1 << 20);\n\tif (rem > (pll_divisor >> 1))\n\t\tfrac_start++;\n\n\tcpctrl = pll_get_cpctrl(frac_start, ref_clk, false);\n\trctrl = pll_get_rctrl(frac_start, false);\n\tcctrl = pll_get_cctrl(frac_start, false);\n\tintegloop_gain = pll_get_integloop_gain(frac_start, bclk,\n\t\t\t\t\t\tref_clk, false);\n\n\tfdata = pd.vco_freq;\n\tdo_div(fdata, pd.vco_ratio);\n\n\tpll_cmp = pll_get_pll_cmp(fdata, ref_clk);\n\n\tDBG(\"VCO freq: %llu\", pd.vco_freq);\n\tDBG(\"fdata: %llu\", fdata);\n\tDBG(\"pix_clk: %lu\", pix_clk);\n\tDBG(\"tmds clk: %llu\", tmds_clk);\n\tDBG(\"HSCLK_SEL: %d\", pd.hsclk_divsel);\n\tDBG(\"DEC_START: %llu\", dec_start);\n\tDBG(\"DIV_FRAC_START: %llu\", frac_start);\n\tDBG(\"PLL_CPCTRL: %u\", cpctrl);\n\tDBG(\"PLL_RCTRL: %u\", rctrl);\n\tDBG(\"PLL_CCTRL: %u\", cctrl);\n\tDBG(\"INTEGLOOP_GAIN: %u\", integloop_gain);\n\tDBG(\"TX_BAND: %d\", pd.tx_band_sel);\n\tDBG(\"PLL_CMP: %u\", pll_cmp);\n\n\t \n\tif (bclk > HDMI_DIG_FREQ_BIT_CLK_THRESHOLD)\n\t\tcfg->com_svs_mode_clk_sel = 1;\n\telse\n\t\tcfg->com_svs_mode_clk_sel = 2;\n\n\tcfg->com_hsclk_sel = (0x20 | pd.hsclk_divsel);\n\tcfg->com_pll_cctrl_mode0 = cctrl;\n\tcfg->com_pll_rctrl_mode0 = rctrl;\n\tcfg->com_cp_ctrl_mode0 = cpctrl;\n\tcfg->com_dec_start_mode0 = dec_start;\n\tcfg->com_div_frac_start1_mode0 = (frac_start & 0xff);\n\tcfg->com_div_frac_start2_mode0 = ((frac_start & 0xff00) >> 8);\n\tcfg->com_div_frac_start3_mode0 = ((frac_start & 0xf0000) >> 16);\n\tcfg->com_integloop_gain0_mode0 = (integloop_gain & 0xff);\n\tcfg->com_integloop_gain1_mode0 = ((integloop_gain & 0xf00) >> 8);\n\tcfg->com_lock_cmp1_mode0 = (pll_cmp & 0xff);\n\tcfg->com_lock_cmp2_mode0 = ((pll_cmp & 0xff00) >> 8);\n\tcfg->com_lock_cmp3_mode0 = ((pll_cmp & 0x30000) >> 16);\n\tcfg->com_lock_cmp_en = 0x0;\n\tcfg->com_core_clk_en = 0x2c;\n\tcfg->com_coreclk_div = HDMI_CORECLK_DIV;\n\tcfg->phy_mode = (bclk > HDMI_HIGH_FREQ_BIT_CLK_THRESHOLD) ? 0x10 : 0x0;\n\tcfg->com_vco_tune_ctrl = 0x0;\n\n\tcfg->tx_lx_lane_mode[0] =\n\t\tcfg->tx_lx_lane_mode[2] = 0x43;\n\n\tcfg->tx_lx_hp_pd_enables[0] =\n\t\tcfg->tx_lx_hp_pd_enables[1] =\n\t\tcfg->tx_lx_hp_pd_enables[2] = 0x0c;\n\tcfg->tx_lx_hp_pd_enables[3] = 0x3;\n\n\tfor (i = 0; i < HDMI_NUM_TX_CHANNEL; i++)\n\t\tcfg->tx_lx_tx_band[i] = pd.tx_band_sel + 4;\n\n\tif (bclk > HDMI_HIGH_FREQ_BIT_CLK_THRESHOLD) {\n\t\tcfg->tx_lx_tx_drv_lvl[0] =\n\t\t\tcfg->tx_lx_tx_drv_lvl[1] =\n\t\t\tcfg->tx_lx_tx_drv_lvl[2] = 0x25;\n\t\tcfg->tx_lx_tx_drv_lvl[3] = 0x22;\n\n\t\tcfg->tx_lx_tx_emp_post1_lvl[0] =\n\t\t\tcfg->tx_lx_tx_emp_post1_lvl[1] =\n\t\t\tcfg->tx_lx_tx_emp_post1_lvl[2] = 0x23;\n\t\tcfg->tx_lx_tx_emp_post1_lvl[3] = 0x27;\n\n\t\tcfg->tx_lx_vmode_ctrl1[0] =\n\t\t\tcfg->tx_lx_vmode_ctrl1[1] =\n\t\t\tcfg->tx_lx_vmode_ctrl1[2] =\n\t\t\tcfg->tx_lx_vmode_ctrl1[3] = 0x00;\n\n\t\tcfg->tx_lx_vmode_ctrl2[0] =\n\t\t\tcfg->tx_lx_vmode_ctrl2[1] =\n\t\t\tcfg->tx_lx_vmode_ctrl2[2] = 0x0D;\n\n\t\tcfg->tx_lx_vmode_ctrl2[3] = 0x00;\n\t} else if (bclk > HDMI_MID_FREQ_BIT_CLK_THRESHOLD) {\n\t\tfor (i = 0; i < HDMI_NUM_TX_CHANNEL; i++) {\n\t\t\tcfg->tx_lx_tx_drv_lvl[i] = 0x25;\n\t\t\tcfg->tx_lx_tx_emp_post1_lvl[i] = 0x23;\n\t\t\tcfg->tx_lx_vmode_ctrl1[i] = 0x00;\n\t\t}\n\n\t\tcfg->tx_lx_vmode_ctrl2[0] =\n\t\t\tcfg->tx_lx_vmode_ctrl2[1] =\n\t\t\tcfg->tx_lx_vmode_ctrl2[2] = 0x0D;\n\t\tcfg->tx_lx_vmode_ctrl2[3] = 0x00;\n\t} else {\n\t\tfor (i = 0; i < HDMI_NUM_TX_CHANNEL; i++) {\n\t\t\tcfg->tx_lx_tx_drv_lvl[i] = 0x20;\n\t\t\tcfg->tx_lx_tx_emp_post1_lvl[i] = 0x20;\n\t\t\tcfg->tx_lx_vmode_ctrl1[i] = 0x00;\n\t\t\tcfg->tx_lx_vmode_ctrl2[i] = 0x0E;\n\t\t}\n\t}\n\n\tDBG(\"com_svs_mode_clk_sel = 0x%x\", cfg->com_svs_mode_clk_sel);\n\tDBG(\"com_hsclk_sel = 0x%x\", cfg->com_hsclk_sel);\n\tDBG(\"com_lock_cmp_en = 0x%x\", cfg->com_lock_cmp_en);\n\tDBG(\"com_pll_cctrl_mode0 = 0x%x\", cfg->com_pll_cctrl_mode0);\n\tDBG(\"com_pll_rctrl_mode0 = 0x%x\", cfg->com_pll_rctrl_mode0);\n\tDBG(\"com_cp_ctrl_mode0 = 0x%x\", cfg->com_cp_ctrl_mode0);\n\tDBG(\"com_dec_start_mode0 = 0x%x\", cfg->com_dec_start_mode0);\n\tDBG(\"com_div_frac_start1_mode0 = 0x%x\", cfg->com_div_frac_start1_mode0);\n\tDBG(\"com_div_frac_start2_mode0 = 0x%x\", cfg->com_div_frac_start2_mode0);\n\tDBG(\"com_div_frac_start3_mode0 = 0x%x\", cfg->com_div_frac_start3_mode0);\n\tDBG(\"com_integloop_gain0_mode0 = 0x%x\", cfg->com_integloop_gain0_mode0);\n\tDBG(\"com_integloop_gain1_mode0 = 0x%x\", cfg->com_integloop_gain1_mode0);\n\tDBG(\"com_lock_cmp1_mode0 = 0x%x\", cfg->com_lock_cmp1_mode0);\n\tDBG(\"com_lock_cmp2_mode0 = 0x%x\", cfg->com_lock_cmp2_mode0);\n\tDBG(\"com_lock_cmp3_mode0 = 0x%x\", cfg->com_lock_cmp3_mode0);\n\tDBG(\"com_core_clk_en = 0x%x\", cfg->com_core_clk_en);\n\tDBG(\"com_coreclk_div = 0x%x\", cfg->com_coreclk_div);\n\tDBG(\"phy_mode = 0x%x\", cfg->phy_mode);\n\n\tDBG(\"tx_l0_lane_mode = 0x%x\", cfg->tx_lx_lane_mode[0]);\n\tDBG(\"tx_l2_lane_mode = 0x%x\", cfg->tx_lx_lane_mode[2]);\n\n\tfor (i = 0; i < HDMI_NUM_TX_CHANNEL; i++) {\n\t\tDBG(\"tx_l%d_tx_band = 0x%x\", i, cfg->tx_lx_tx_band[i]);\n\t\tDBG(\"tx_l%d_tx_drv_lvl = 0x%x\", i, cfg->tx_lx_tx_drv_lvl[i]);\n\t\tDBG(\"tx_l%d_tx_emp_post1_lvl = 0x%x\", i,\n\t\t    cfg->tx_lx_tx_emp_post1_lvl[i]);\n\t\tDBG(\"tx_l%d_vmode_ctrl1 = 0x%x\", i, cfg->tx_lx_vmode_ctrl1[i]);\n\t\tDBG(\"tx_l%d_vmode_ctrl2 = 0x%x\", i, cfg->tx_lx_vmode_ctrl2[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int hdmi_8996_pll_set_clk_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct hdmi_pll_8996 *pll = hw_clk_to_pll(hw);\n\tstruct hdmi_phy *phy = pll_get_phy(pll);\n\tstruct hdmi_8996_phy_pll_reg_cfg cfg;\n\tint i, ret;\n\n\tmemset(&cfg, 0x00, sizeof(cfg));\n\n\tret = pll_calculate(rate, parent_rate, &cfg);\n\tif (ret) {\n\t\tDRM_ERROR(\"PLL calculation failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tDBG(\"Disabling PHY\");\n\thdmi_phy_write(phy, REG_HDMI_8996_PHY_PD_CTL, 0x0);\n\tudelay(500);\n\n\t \n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_BG_CTRL, 0x04);\n\n\thdmi_phy_write(phy, REG_HDMI_8996_PHY_PD_CTL, 0x1);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_RESETSM_CNTRL, 0x20);\n\thdmi_phy_write(phy, REG_HDMI_8996_PHY_TX0_TX1_LANE_CTL, 0x0F);\n\thdmi_phy_write(phy, REG_HDMI_8996_PHY_TX2_TX3_LANE_CTL, 0x0F);\n\n\tfor (i = 0; i < HDMI_NUM_TX_CHANNEL; i++) {\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\t\t   REG_HDMI_PHY_QSERDES_TX_LX_CLKBUF_ENABLE,\n\t\t\t\t   0x03);\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\t\t   REG_HDMI_PHY_QSERDES_TX_LX_TX_BAND,\n\t\t\t\t   cfg.tx_lx_tx_band[i]);\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\t\t   REG_HDMI_PHY_QSERDES_TX_LX_RESET_TSYNC_EN,\n\t\t\t\t   0x03);\n\t}\n\n\thdmi_tx_chan_write(pll, 0, REG_HDMI_PHY_QSERDES_TX_LX_LANE_MODE,\n\t\t\t   cfg.tx_lx_lane_mode[0]);\n\thdmi_tx_chan_write(pll, 2, REG_HDMI_PHY_QSERDES_TX_LX_LANE_MODE,\n\t\t\t   cfg.tx_lx_lane_mode[2]);\n\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_SYSCLK_BUF_ENABLE, 0x1E);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_BIAS_EN_CLKBUFLR_EN, 0x07);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_SYSCLK_EN_SEL, 0x37);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_SYS_CLK_CTRL, 0x02);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_CLK_ENABLE1, 0x0E);\n\n\t \n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_SVS_MODE_CLK_SEL,\n\t\t       cfg.com_svs_mode_clk_sel);\n\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_BG_TRIM, 0x0F);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_PLL_IVCO, 0x0F);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_VCO_TUNE_CTRL,\n\t\t       cfg.com_vco_tune_ctrl);\n\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_BG_CTRL, 0x06);\n\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_CLK_SELECT, 0x30);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_HSCLK_SEL,\n\t\t       cfg.com_hsclk_sel);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_LOCK_CMP_EN,\n\t\t       cfg.com_lock_cmp_en);\n\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_PLL_CCTRL_MODE0,\n\t\t       cfg.com_pll_cctrl_mode0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_PLL_RCTRL_MODE0,\n\t\t       cfg.com_pll_rctrl_mode0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_CP_CTRL_MODE0,\n\t\t       cfg.com_cp_ctrl_mode0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_DEC_START_MODE0,\n\t\t       cfg.com_dec_start_mode0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_DIV_FRAC_START1_MODE0,\n\t\t       cfg.com_div_frac_start1_mode0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_DIV_FRAC_START2_MODE0,\n\t\t       cfg.com_div_frac_start2_mode0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_DIV_FRAC_START3_MODE0,\n\t\t       cfg.com_div_frac_start3_mode0);\n\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_INTEGLOOP_GAIN0_MODE0,\n\t\t       cfg.com_integloop_gain0_mode0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_INTEGLOOP_GAIN1_MODE0,\n\t\t       cfg.com_integloop_gain1_mode0);\n\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_LOCK_CMP1_MODE0,\n\t\t       cfg.com_lock_cmp1_mode0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_LOCK_CMP2_MODE0,\n\t\t       cfg.com_lock_cmp2_mode0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_LOCK_CMP3_MODE0,\n\t\t       cfg.com_lock_cmp3_mode0);\n\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_VCO_TUNE_MAP, 0x00);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_CORE_CLK_EN,\n\t\t       cfg.com_core_clk_en);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_CORECLK_DIV,\n\t\t       cfg.com_coreclk_div);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_CMN_CONFIG, 0x02);\n\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_RESCODE_DIV_NUM, 0x15);\n\n\t \n\tfor (i = 0; i < HDMI_NUM_TX_CHANNEL; i++) {\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\t\t   REG_HDMI_PHY_QSERDES_TX_LX_TX_DRV_LVL,\n\t\t\t\t   cfg.tx_lx_tx_drv_lvl[i]);\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\t\t   REG_HDMI_PHY_QSERDES_TX_LX_TX_EMP_POST1_LVL,\n\t\t\t\t   cfg.tx_lx_tx_emp_post1_lvl[i]);\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\t\t   REG_HDMI_PHY_QSERDES_TX_LX_VMODE_CTRL1,\n\t\t\t\t   cfg.tx_lx_vmode_ctrl1[i]);\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\t\t   REG_HDMI_PHY_QSERDES_TX_LX_VMODE_CTRL2,\n\t\t\t\t   cfg.tx_lx_vmode_ctrl2[i]);\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\t\t   REG_HDMI_PHY_QSERDES_TX_LX_TX_DRV_LVL_OFFSET,\n\t\t\t\t   0x00);\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\tREG_HDMI_PHY_QSERDES_TX_LX_RES_CODE_LANE_OFFSET,\n\t\t\t0x00);\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\tREG_HDMI_PHY_QSERDES_TX_LX_TRAN_DRVR_EMP_EN,\n\t\t\t0x03);\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\tREG_HDMI_PHY_QSERDES_TX_LX_PARRATE_REC_DETECT_IDLE_EN,\n\t\t\t0x40);\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\t\t   REG_HDMI_PHY_QSERDES_TX_LX_HP_PD_ENABLES,\n\t\t\t\t   cfg.tx_lx_hp_pd_enables[i]);\n\t}\n\n\thdmi_phy_write(phy, REG_HDMI_8996_PHY_MODE, cfg.phy_mode);\n\thdmi_phy_write(phy, REG_HDMI_8996_PHY_PD_CTL, 0x1F);\n\n\t \n\twmb();\n\n\treturn 0;\n}\n\nstatic int hdmi_8996_phy_ready_status(struct hdmi_phy *phy)\n{\n\tu32 nb_tries = HDMI_PLL_POLL_MAX_READS;\n\tunsigned long timeout = HDMI_PLL_POLL_TIMEOUT_US;\n\tu32 status;\n\tint phy_ready = 0;\n\n\tDBG(\"Waiting for PHY ready\");\n\n\twhile (nb_tries--) {\n\t\tstatus = hdmi_phy_read(phy, REG_HDMI_8996_PHY_STATUS);\n\t\tphy_ready = status & BIT(0);\n\n\t\tif (phy_ready)\n\t\t\tbreak;\n\n\t\tudelay(timeout);\n\t}\n\n\tDBG(\"PHY is %sready\", phy_ready ? \"\" : \"*not* \");\n\n\treturn phy_ready;\n}\n\nstatic int hdmi_8996_pll_lock_status(struct hdmi_pll_8996 *pll)\n{\n\tu32 status;\n\tint nb_tries = HDMI_PLL_POLL_MAX_READS;\n\tunsigned long timeout = HDMI_PLL_POLL_TIMEOUT_US;\n\tint pll_locked = 0;\n\n\tDBG(\"Waiting for PLL lock\");\n\n\twhile (nb_tries--) {\n\t\tstatus = hdmi_pll_read(pll,\n\t\t\t\t       REG_HDMI_PHY_QSERDES_COM_C_READY_STATUS);\n\t\tpll_locked = status & BIT(0);\n\n\t\tif (pll_locked)\n\t\t\tbreak;\n\n\t\tudelay(timeout);\n\t}\n\n\tDBG(\"HDMI PLL is %slocked\", pll_locked ? \"\" : \"*not* \");\n\n\treturn pll_locked;\n}\n\nstatic int hdmi_8996_pll_prepare(struct clk_hw *hw)\n{\n\tstruct hdmi_pll_8996 *pll = hw_clk_to_pll(hw);\n\tstruct hdmi_phy *phy = pll_get_phy(pll);\n\tint i, ret = 0;\n\n\thdmi_phy_write(phy, REG_HDMI_8996_PHY_CFG, 0x1);\n\tudelay(100);\n\n\thdmi_phy_write(phy, REG_HDMI_8996_PHY_CFG, 0x19);\n\tudelay(100);\n\n\tret = hdmi_8996_pll_lock_status(pll);\n\tif (!ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < HDMI_NUM_TX_CHANNEL; i++)\n\t\thdmi_tx_chan_write(pll, i,\n\t\t\tREG_HDMI_PHY_QSERDES_TX_LX_HIGHZ_TRANSCEIVEREN_BIAS_DRVR_EN,\n\t\t\t0x6F);\n\n\t \n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_SSC_PER1, 0x0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_SSC_PER2, 0x0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_SSC_STEP_SIZE1, 0x0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_SSC_STEP_SIZE2, 0x0);\n\thdmi_pll_write(pll, REG_HDMI_PHY_QSERDES_COM_SSC_EN_CENTER, 0x2);\n\n\tret = hdmi_8996_phy_ready_status(phy);\n\tif (!ret)\n\t\treturn ret;\n\n\t \n\thdmi_phy_write(phy, REG_HDMI_8996_PHY_CFG, 0x18);\n\tudelay(1);\n\thdmi_phy_write(phy, REG_HDMI_8996_PHY_CFG, 0x19);\n\n\treturn 0;\n}\n\nstatic long hdmi_8996_pll_round_rate(struct clk_hw *hw,\n\t\t\t\t     unsigned long rate,\n\t\t\t\t     unsigned long *parent_rate)\n{\n\tif (rate < HDMI_PCLK_MIN_FREQ)\n\t\treturn HDMI_PCLK_MIN_FREQ;\n\telse if (rate > HDMI_PCLK_MAX_FREQ)\n\t\treturn HDMI_PCLK_MAX_FREQ;\n\telse\n\t\treturn rate;\n}\n\nstatic unsigned long hdmi_8996_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct hdmi_pll_8996 *pll = hw_clk_to_pll(hw);\n\tu64 fdata;\n\tu32 cmp1, cmp2, cmp3, pll_cmp;\n\n\tcmp1 = hdmi_pll_read(pll, REG_HDMI_PHY_QSERDES_COM_LOCK_CMP1_MODE0);\n\tcmp2 = hdmi_pll_read(pll, REG_HDMI_PHY_QSERDES_COM_LOCK_CMP2_MODE0);\n\tcmp3 = hdmi_pll_read(pll, REG_HDMI_PHY_QSERDES_COM_LOCK_CMP3_MODE0);\n\n\tpll_cmp = cmp1 | (cmp2 << 8) | (cmp3 << 16);\n\n\tfdata = pll_cmp_to_fdata(pll_cmp + 1, parent_rate);\n\n\tdo_div(fdata, 10);\n\n\treturn fdata;\n}\n\nstatic void hdmi_8996_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct hdmi_pll_8996 *pll = hw_clk_to_pll(hw);\n\tstruct hdmi_phy *phy = pll_get_phy(pll);\n\n\thdmi_phy_write(phy, REG_HDMI_8996_PHY_CFG, 0x6);\n\tusleep_range(100, 150);\n}\n\nstatic int hdmi_8996_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct hdmi_pll_8996 *pll = hw_clk_to_pll(hw);\n\tu32 status;\n\tint pll_locked;\n\n\tstatus = hdmi_pll_read(pll, REG_HDMI_PHY_QSERDES_COM_C_READY_STATUS);\n\tpll_locked = status & BIT(0);\n\n\treturn pll_locked;\n}\n\nstatic const struct clk_ops hdmi_8996_pll_ops = {\n\t.set_rate = hdmi_8996_pll_set_clk_rate,\n\t.round_rate = hdmi_8996_pll_round_rate,\n\t.recalc_rate = hdmi_8996_pll_recalc_rate,\n\t.prepare = hdmi_8996_pll_prepare,\n\t.unprepare = hdmi_8996_pll_unprepare,\n\t.is_enabled = hdmi_8996_pll_is_enabled,\n};\n\nstatic const struct clk_init_data pll_init = {\n\t.name = \"hdmipll\",\n\t.ops = &hdmi_8996_pll_ops,\n\t.parent_data = (const struct clk_parent_data[]){\n\t\t{ .fw_name = \"xo\", .name = \"xo_board\" },\n\t},\n\t.num_parents = 1,\n\t.flags = CLK_IGNORE_UNUSED,\n};\n\nint msm_hdmi_pll_8996_init(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hdmi_pll_8996 *pll;\n\tint i, ret;\n\n\tpll = devm_kzalloc(dev, sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn -ENOMEM;\n\n\tpll->pdev = pdev;\n\n\tpll->mmio_qserdes_com = msm_ioremap(pdev, \"hdmi_pll\");\n\tif (IS_ERR(pll->mmio_qserdes_com)) {\n\t\tDRM_DEV_ERROR(dev, \"failed to map pll base\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < HDMI_NUM_TX_CHANNEL; i++) {\n\t\tchar name[32];\n\n\t\tsnprintf(name, sizeof(name), \"hdmi_tx_l%d\", i);\n\n\t\tpll->mmio_qserdes_tx[i] = msm_ioremap(pdev, name);\n\t\tif (IS_ERR(pll->mmio_qserdes_tx[i])) {\n\t\t\tDRM_DEV_ERROR(dev, \"failed to map pll base\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tpll->clk_hw.init = &pll_init;\n\n\tret = devm_clk_hw_register(dev, &pll->clk_hw);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to register pll clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get, &pll->clk_hw);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"%s: failed to register clk provider: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const hdmi_phy_8996_reg_names[] = {\n\t\"vddio\",\n\t\"vcca\",\n};\n\nstatic const char * const hdmi_phy_8996_clk_names[] = {\n\t\"iface\", \"ref\",\n};\n\nconst struct hdmi_phy_cfg msm_hdmi_phy_8996_cfg = {\n\t.type = MSM_HDMI_PHY_8996,\n\t.reg_names = hdmi_phy_8996_reg_names,\n\t.num_regs = ARRAY_SIZE(hdmi_phy_8996_reg_names),\n\t.clk_names = hdmi_phy_8996_clk_names,\n\t.num_clks = ARRAY_SIZE(hdmi_phy_8996_clk_names),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}