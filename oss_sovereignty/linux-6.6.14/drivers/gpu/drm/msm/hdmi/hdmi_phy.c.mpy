{
  "module_name": "hdmi_phy.c",
  "hash_id": "cccaaf4c54e3c655c4cbfcdd491985b4f1863793abe8d0cd42b9bb81344c0552",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/hdmi/hdmi_phy.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include \"hdmi.h\"\n\nstatic int msm_hdmi_phy_resource_init(struct hdmi_phy *phy)\n{\n\tstruct hdmi_phy_cfg *cfg = phy->cfg;\n\tstruct device *dev = &phy->pdev->dev;\n\tint i, ret;\n\n\tphy->regs = devm_kcalloc(dev, cfg->num_regs, sizeof(phy->regs[0]),\n\t\t\t\t GFP_KERNEL);\n\tif (!phy->regs)\n\t\treturn -ENOMEM;\n\n\tphy->clks = devm_kcalloc(dev, cfg->num_clks, sizeof(phy->clks[0]),\n\t\t\t\t GFP_KERNEL);\n\tif (!phy->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cfg->num_regs; i++)\n\t\tphy->regs[i].supply = cfg->reg_names[i];\n\n\tret = devm_regulator_bulk_get(dev, cfg->num_regs, phy->regs);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to get phy regulators: %d\\n\", ret);\n\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < cfg->num_clks; i++) {\n\t\tstruct clk *clk;\n\n\t\tclk = msm_clk_get(phy->pdev, cfg->clk_names[i]);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tDRM_DEV_ERROR(dev, \"failed to get phy clock: %s (%d)\\n\",\n\t\t\t\tcfg->clk_names[i], ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tphy->clks[i] = clk;\n\t}\n\n\treturn 0;\n}\n\nint msm_hdmi_phy_resource_enable(struct hdmi_phy *phy)\n{\n\tstruct hdmi_phy_cfg *cfg = phy->cfg;\n\tstruct device *dev = &phy->pdev->dev;\n\tint i, ret = 0;\n\n\tpm_runtime_get_sync(dev);\n\n\tret = regulator_bulk_enable(cfg->num_regs, phy->regs);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to enable regulators: (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < cfg->num_clks; i++) {\n\t\tret = clk_prepare_enable(phy->clks[i]);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to enable clock: %s (%d)\\n\",\n\t\t\t\tcfg->clk_names[i], ret);\n\t}\n\n\treturn ret;\n}\n\nvoid msm_hdmi_phy_resource_disable(struct hdmi_phy *phy)\n{\n\tstruct hdmi_phy_cfg *cfg = phy->cfg;\n\tstruct device *dev = &phy->pdev->dev;\n\tint i;\n\n\tfor (i = cfg->num_clks - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(phy->clks[i]);\n\n\tregulator_bulk_disable(cfg->num_regs, phy->regs);\n\n\tpm_runtime_put_sync(dev);\n}\n\nvoid msm_hdmi_phy_powerup(struct hdmi_phy *phy, unsigned long int pixclock)\n{\n\tif (!phy || !phy->cfg->powerup)\n\t\treturn;\n\n\tphy->cfg->powerup(phy, pixclock);\n}\n\nvoid msm_hdmi_phy_powerdown(struct hdmi_phy *phy)\n{\n\tif (!phy || !phy->cfg->powerdown)\n\t\treturn;\n\n\tphy->cfg->powerdown(phy);\n}\n\nstatic int msm_hdmi_phy_pll_init(struct platform_device *pdev,\n\t\t\t     enum hdmi_phy_type type)\n{\n\tint ret;\n\n\tswitch (type) {\n\tcase MSM_HDMI_PHY_8960:\n\t\tret = msm_hdmi_pll_8960_init(pdev);\n\t\tbreak;\n\tcase MSM_HDMI_PHY_8996:\n\t\tret = msm_hdmi_pll_8996_init(pdev);\n\t\tbreak;\n\t \n\tcase MSM_HDMI_PHY_8x60:\n\tcase MSM_HDMI_PHY_8x74:\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int msm_hdmi_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hdmi_phy *phy;\n\tint ret;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENODEV;\n\n\tphy->cfg = (struct hdmi_phy_cfg *)of_device_get_match_data(dev);\n\tif (!phy->cfg)\n\t\treturn -ENODEV;\n\n\tphy->mmio = msm_ioremap(pdev, \"hdmi_phy\");\n\tif (IS_ERR(phy->mmio)) {\n\t\tDRM_DEV_ERROR(dev, \"%s: failed to map phy base\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tphy->pdev = pdev;\n\n\tret = msm_hdmi_phy_resource_init(phy);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = msm_hdmi_phy_resource_enable(phy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = msm_hdmi_phy_pll_init(pdev, phy->cfg->type);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"couldn't init PLL\\n\");\n\t\tmsm_hdmi_phy_resource_disable(phy);\n\t\treturn ret;\n\t}\n\n\tmsm_hdmi_phy_resource_disable(phy);\n\n\tplatform_set_drvdata(pdev, phy);\n\n\treturn 0;\n}\n\nstatic int msm_hdmi_phy_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id msm_hdmi_phy_dt_match[] = {\n\t{ .compatible = \"qcom,hdmi-phy-8660\",\n\t  .data = &msm_hdmi_phy_8x60_cfg },\n\t{ .compatible = \"qcom,hdmi-phy-8960\",\n\t  .data = &msm_hdmi_phy_8960_cfg },\n\t{ .compatible = \"qcom,hdmi-phy-8974\",\n\t  .data = &msm_hdmi_phy_8x74_cfg },\n\t{ .compatible = \"qcom,hdmi-phy-8084\",\n\t  .data = &msm_hdmi_phy_8x74_cfg },\n\t{ .compatible = \"qcom,hdmi-phy-8996\",\n\t  .data = &msm_hdmi_phy_8996_cfg },\n\t{}\n};\n\nstatic struct platform_driver msm_hdmi_phy_platform_driver = {\n\t.probe      = msm_hdmi_phy_probe,\n\t.remove     = msm_hdmi_phy_remove,\n\t.driver     = {\n\t\t.name   = \"msm_hdmi_phy\",\n\t\t.of_match_table = msm_hdmi_phy_dt_match,\n\t},\n};\n\nvoid __init msm_hdmi_phy_driver_register(void)\n{\n\tplatform_driver_register(&msm_hdmi_phy_platform_driver);\n}\n\nvoid __exit msm_hdmi_phy_driver_unregister(void)\n{\n\tplatform_driver_unregister(&msm_hdmi_phy_platform_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}