{
  "module_name": "msm_fence.c",
  "hash_id": "4fcc0dd485614313f22b2a10cd2fe3c9011d522662599ded16fc23de9b2a4013",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_fence.c",
  "human_readable_source": "\n \n\n#include <linux/dma-fence.h>\n\n#include \"msm_drv.h\"\n#include \"msm_fence.h\"\n#include \"msm_gpu.h\"\n\nstatic struct msm_gpu *fctx2gpu(struct msm_fence_context *fctx)\n{\n\tstruct msm_drm_private *priv = fctx->dev->dev_private;\n\treturn priv->gpu;\n}\n\nstatic enum hrtimer_restart deadline_timer(struct hrtimer *t)\n{\n\tstruct msm_fence_context *fctx = container_of(t,\n\t\t\tstruct msm_fence_context, deadline_timer);\n\n\tkthread_queue_work(fctx2gpu(fctx)->worker, &fctx->deadline_work);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void deadline_work(struct kthread_work *work)\n{\n\tstruct msm_fence_context *fctx = container_of(work,\n\t\t\tstruct msm_fence_context, deadline_work);\n\n\t \n\tif (msm_fence_completed(fctx, fctx->next_deadline_fence))\n\t\treturn;\n\n\tmsm_devfreq_boost(fctx2gpu(fctx), 2);\n}\n\n\nstruct msm_fence_context *\nmsm_fence_context_alloc(struct drm_device *dev, volatile uint32_t *fenceptr,\n\t\tconst char *name)\n{\n\tstruct msm_fence_context *fctx;\n\tstatic int index = 0;\n\n\tfctx = kzalloc(sizeof(*fctx), GFP_KERNEL);\n\tif (!fctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfctx->dev = dev;\n\tstrscpy(fctx->name, name, sizeof(fctx->name));\n\tfctx->context = dma_fence_context_alloc(1);\n\tfctx->index = index++;\n\tfctx->fenceptr = fenceptr;\n\tspin_lock_init(&fctx->spinlock);\n\n\t \n\tfctx->last_fence = 0xffffff00;\n\tfctx->completed_fence = fctx->last_fence;\n\t*fctx->fenceptr = fctx->last_fence;\n\n\thrtimer_init(&fctx->deadline_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tfctx->deadline_timer.function = deadline_timer;\n\n\tkthread_init_work(&fctx->deadline_work, deadline_work);\n\n\tfctx->next_deadline = ktime_get();\n\n\treturn fctx;\n}\n\nvoid msm_fence_context_free(struct msm_fence_context *fctx)\n{\n\tkfree(fctx);\n}\n\nbool msm_fence_completed(struct msm_fence_context *fctx, uint32_t fence)\n{\n\t \n\treturn (int32_t)(fctx->completed_fence - fence) >= 0 ||\n\t\t(int32_t)(*fctx->fenceptr - fence) >= 0;\n}\n\n \nvoid msm_update_fence(struct msm_fence_context *fctx, uint32_t fence)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fctx->spinlock, flags);\n\tif (fence_after(fence, fctx->completed_fence))\n\t\tfctx->completed_fence = fence;\n\tif (msm_fence_completed(fctx, fctx->next_deadline_fence))\n\t\thrtimer_cancel(&fctx->deadline_timer);\n\tspin_unlock_irqrestore(&fctx->spinlock, flags);\n}\n\nstruct msm_fence {\n\tstruct dma_fence base;\n\tstruct msm_fence_context *fctx;\n};\n\nstatic inline struct msm_fence *to_msm_fence(struct dma_fence *fence)\n{\n\treturn container_of(fence, struct msm_fence, base);\n}\n\nstatic const char *msm_fence_get_driver_name(struct dma_fence *fence)\n{\n\treturn \"msm\";\n}\n\nstatic const char *msm_fence_get_timeline_name(struct dma_fence *fence)\n{\n\tstruct msm_fence *f = to_msm_fence(fence);\n\treturn f->fctx->name;\n}\n\nstatic bool msm_fence_signaled(struct dma_fence *fence)\n{\n\tstruct msm_fence *f = to_msm_fence(fence);\n\treturn msm_fence_completed(f->fctx, f->base.seqno);\n}\n\nstatic void msm_fence_set_deadline(struct dma_fence *fence, ktime_t deadline)\n{\n\tstruct msm_fence *f = to_msm_fence(fence);\n\tstruct msm_fence_context *fctx = f->fctx;\n\tunsigned long flags;\n\tktime_t now;\n\n\tspin_lock_irqsave(&fctx->spinlock, flags);\n\tnow = ktime_get();\n\n\tif (ktime_after(now, fctx->next_deadline) ||\n\t\t\tktime_before(deadline, fctx->next_deadline)) {\n\t\tfctx->next_deadline = deadline;\n\t\tfctx->next_deadline_fence =\n\t\t\tmax(fctx->next_deadline_fence, (uint32_t)fence->seqno);\n\n\t\t \n\t\tdeadline = ktime_sub(deadline, ms_to_ktime(3));\n\n\t\tif (ktime_after(now, deadline)) {\n\t\t\tkthread_queue_work(fctx2gpu(fctx)->worker,\n\t\t\t\t\t&fctx->deadline_work);\n\t\t} else {\n\t\t\thrtimer_start(&fctx->deadline_timer, deadline,\n\t\t\t\t\tHRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&fctx->spinlock, flags);\n}\n\nstatic const struct dma_fence_ops msm_fence_ops = {\n\t.get_driver_name = msm_fence_get_driver_name,\n\t.get_timeline_name = msm_fence_get_timeline_name,\n\t.signaled = msm_fence_signaled,\n\t.set_deadline = msm_fence_set_deadline,\n};\n\nstruct dma_fence *\nmsm_fence_alloc(void)\n{\n\tstruct msm_fence *f;\n\n\tf = kzalloc(sizeof(*f), GFP_KERNEL);\n\tif (!f)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn &f->base;\n}\n\nvoid\nmsm_fence_init(struct dma_fence *fence, struct msm_fence_context *fctx)\n{\n\tstruct msm_fence *f = to_msm_fence(fence);\n\n\tf->fctx = fctx;\n\n\t \n\tWARN_ON(kref_read(&fence->refcount));\n\n\tdma_fence_init(&f->base, &msm_fence_ops, &fctx->spinlock,\n\t\t       fctx->context, ++fctx->last_fence);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}