{
  "module_name": "msm_gpu.c",
  "hash_id": "92733291ba1c7bb3d730697f72eec43cff049be3ce5078236ff9ce6826d83e8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_gpu.c",
  "human_readable_source": "\n \n\n#include \"drm/drm_drv.h\"\n\n#include \"msm_gpu.h\"\n#include \"msm_gem.h\"\n#include \"msm_mmu.h\"\n#include \"msm_fence.h\"\n#include \"msm_gpu_trace.h\"\n#include \"adreno/adreno_gpu.h\"\n\n#include <generated/utsrelease.h>\n#include <linux/string_helpers.h>\n#include <linux/devcoredump.h>\n#include <linux/sched/task.h>\n\n \n\nstatic int enable_pwrrail(struct msm_gpu *gpu)\n{\n\tstruct drm_device *dev = gpu->dev;\n\tint ret = 0;\n\n\tif (gpu->gpu_reg) {\n\t\tret = regulator_enable(gpu->gpu_reg);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to enable 'gpu_reg': %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (gpu->gpu_cx) {\n\t\tret = regulator_enable(gpu->gpu_cx);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to enable 'gpu_cx': %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int disable_pwrrail(struct msm_gpu *gpu)\n{\n\tif (gpu->gpu_cx)\n\t\tregulator_disable(gpu->gpu_cx);\n\tif (gpu->gpu_reg)\n\t\tregulator_disable(gpu->gpu_reg);\n\treturn 0;\n}\n\nstatic int enable_clk(struct msm_gpu *gpu)\n{\n\tif (gpu->core_clk && gpu->fast_rate)\n\t\tdev_pm_opp_set_rate(&gpu->pdev->dev, gpu->fast_rate);\n\n\t \n\tif (gpu->rbbmtimer_clk)\n\t\tclk_set_rate(gpu->rbbmtimer_clk, 19200000);\n\n\treturn clk_bulk_prepare_enable(gpu->nr_clocks, gpu->grp_clks);\n}\n\nstatic int disable_clk(struct msm_gpu *gpu)\n{\n\tclk_bulk_disable_unprepare(gpu->nr_clocks, gpu->grp_clks);\n\n\t \n\tif (gpu->core_clk)\n\t\tdev_pm_opp_set_rate(&gpu->pdev->dev, 27000000);\n\n\tif (gpu->rbbmtimer_clk)\n\t\tclk_set_rate(gpu->rbbmtimer_clk, 0);\n\n\treturn 0;\n}\n\nstatic int enable_axi(struct msm_gpu *gpu)\n{\n\treturn clk_prepare_enable(gpu->ebi1_clk);\n}\n\nstatic int disable_axi(struct msm_gpu *gpu)\n{\n\tclk_disable_unprepare(gpu->ebi1_clk);\n\treturn 0;\n}\n\nint msm_gpu_pm_resume(struct msm_gpu *gpu)\n{\n\tint ret;\n\n\tDBG(\"%s\", gpu->name);\n\ttrace_msm_gpu_resume(0);\n\n\tret = enable_pwrrail(gpu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = enable_clk(gpu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = enable_axi(gpu);\n\tif (ret)\n\t\treturn ret;\n\n\tmsm_devfreq_resume(gpu);\n\n\tgpu->needs_hw_init = true;\n\n\treturn 0;\n}\n\nint msm_gpu_pm_suspend(struct msm_gpu *gpu)\n{\n\tint ret;\n\n\tDBG(\"%s\", gpu->name);\n\ttrace_msm_gpu_suspend(0);\n\n\tmsm_devfreq_suspend(gpu);\n\n\tret = disable_axi(gpu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = disable_clk(gpu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = disable_pwrrail(gpu);\n\tif (ret)\n\t\treturn ret;\n\n\tgpu->suspend_count++;\n\n\treturn 0;\n}\n\nvoid msm_gpu_show_fdinfo(struct msm_gpu *gpu, struct msm_file_private *ctx,\n\t\t\t struct drm_printer *p)\n{\n\tdrm_printf(p, \"drm-engine-gpu:\\t%llu ns\\n\", ctx->elapsed_ns);\n\tdrm_printf(p, \"drm-cycles-gpu:\\t%llu\\n\", ctx->cycles);\n\tdrm_printf(p, \"drm-maxfreq-gpu:\\t%u Hz\\n\", gpu->fast_rate);\n}\n\nint msm_gpu_hw_init(struct msm_gpu *gpu)\n{\n\tint ret;\n\n\tWARN_ON(!mutex_is_locked(&gpu->lock));\n\n\tif (!gpu->needs_hw_init)\n\t\treturn 0;\n\n\tdisable_irq(gpu->irq);\n\tret = gpu->funcs->hw_init(gpu);\n\tif (!ret)\n\t\tgpu->needs_hw_init = false;\n\tenable_irq(gpu->irq);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_DEV_COREDUMP\nstatic ssize_t msm_gpu_devcoredump_read(char *buffer, loff_t offset,\n\t\tsize_t count, void *data, size_t datalen)\n{\n\tstruct msm_gpu *gpu = data;\n\tstruct drm_print_iterator iter;\n\tstruct drm_printer p;\n\tstruct msm_gpu_state *state;\n\n\tstate = msm_gpu_crashstate_get(gpu);\n\tif (!state)\n\t\treturn 0;\n\n\titer.data = buffer;\n\titer.offset = 0;\n\titer.start = offset;\n\titer.remain = count;\n\n\tp = drm_coredump_printer(&iter);\n\n\tdrm_printf(&p, \"---\\n\");\n\tdrm_printf(&p, \"kernel: \" UTS_RELEASE \"\\n\");\n\tdrm_printf(&p, \"module: \" KBUILD_MODNAME \"\\n\");\n\tdrm_printf(&p, \"time: %lld.%09ld\\n\",\n\t\tstate->time.tv_sec, state->time.tv_nsec);\n\tif (state->comm)\n\t\tdrm_printf(&p, \"comm: %s\\n\", state->comm);\n\tif (state->cmd)\n\t\tdrm_printf(&p, \"cmdline: %s\\n\", state->cmd);\n\n\tgpu->funcs->show(gpu, state, &p);\n\n\tmsm_gpu_crashstate_put(gpu);\n\n\treturn count - iter.remain;\n}\n\nstatic void msm_gpu_devcoredump_free(void *data)\n{\n\tstruct msm_gpu *gpu = data;\n\n\tmsm_gpu_crashstate_put(gpu);\n}\n\nstatic void msm_gpu_crashstate_get_bo(struct msm_gpu_state *state,\n\t\tstruct drm_gem_object *obj, u64 iova, bool full)\n{\n\tstruct msm_gpu_state_bo *state_bo = &state->bos[state->nr_bos];\n\n\t \n\tstate_bo->size = obj->size;\n\tstate_bo->iova = iova;\n\n\tBUILD_BUG_ON(sizeof(state_bo->name) != sizeof(to_msm_bo(obj)->name));\n\n\tmemcpy(state_bo->name, to_msm_bo(obj)->name, sizeof(state_bo->name));\n\n\tif (full) {\n\t\tvoid *ptr;\n\n\t\tstate_bo->data = kvmalloc(obj->size, GFP_KERNEL);\n\t\tif (!state_bo->data)\n\t\t\tgoto out;\n\n\t\tmsm_gem_lock(obj);\n\t\tptr = msm_gem_get_vaddr_active(obj);\n\t\tmsm_gem_unlock(obj);\n\t\tif (IS_ERR(ptr)) {\n\t\t\tkvfree(state_bo->data);\n\t\t\tstate_bo->data = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(state_bo->data, ptr, obj->size);\n\t\tmsm_gem_put_vaddr(obj);\n\t}\nout:\n\tstate->nr_bos++;\n}\n\nstatic void msm_gpu_crashstate_capture(struct msm_gpu *gpu,\n\t\tstruct msm_gem_submit *submit, char *comm, char *cmd)\n{\n\tstruct msm_gpu_state *state;\n\n\t \n\tif (!gpu->funcs->gpu_state_get)\n\t\treturn;\n\n\t \n\tif (gpu->crashstate)\n\t\treturn;\n\n\tstate = gpu->funcs->gpu_state_get(gpu);\n\tif (IS_ERR_OR_NULL(state))\n\t\treturn;\n\n\t \n\tstate->comm = kstrdup(comm, GFP_KERNEL);\n\tstate->cmd = kstrdup(cmd, GFP_KERNEL);\n\tstate->fault_info = gpu->fault_info;\n\n\tif (submit) {\n\t\tint i;\n\n\t\tstate->bos = kcalloc(submit->nr_bos,\n\t\t\tsizeof(struct msm_gpu_state_bo), GFP_KERNEL);\n\n\t\tfor (i = 0; state->bos && i < submit->nr_bos; i++) {\n\t\t\tmsm_gpu_crashstate_get_bo(state, submit->bos[i].obj,\n\t\t\t\t\t\t  submit->bos[i].iova,\n\t\t\t\t\t\t  should_dump(submit, i));\n\t\t}\n\t}\n\n\t \n\tgpu->crashstate = state;\n\n\t \n\tdev_coredumpm(gpu->dev->dev, THIS_MODULE, gpu, 0, GFP_KERNEL,\n\t\tmsm_gpu_devcoredump_read, msm_gpu_devcoredump_free);\n}\n#else\nstatic void msm_gpu_crashstate_capture(struct msm_gpu *gpu,\n\t\tstruct msm_gem_submit *submit, char *comm, char *cmd)\n{\n}\n#endif\n\n \n\nstatic struct msm_gem_submit *\nfind_submit(struct msm_ringbuffer *ring, uint32_t fence)\n{\n\tstruct msm_gem_submit *submit;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->submit_lock, flags);\n\tlist_for_each_entry(submit, &ring->submits, node) {\n\t\tif (submit->seqno == fence) {\n\t\t\tspin_unlock_irqrestore(&ring->submit_lock, flags);\n\t\t\treturn submit;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ring->submit_lock, flags);\n\n\treturn NULL;\n}\n\nstatic void retire_submits(struct msm_gpu *gpu);\n\nstatic void get_comm_cmdline(struct msm_gem_submit *submit, char **comm, char **cmd)\n{\n\tstruct msm_file_private *ctx = submit->queue->ctx;\n\tstruct task_struct *task;\n\n\tWARN_ON(!mutex_is_locked(&submit->gpu->lock));\n\n\t \n\t*comm = kstrdup(ctx->comm, GFP_KERNEL);\n\t*cmd  = kstrdup(ctx->cmdline, GFP_KERNEL);\n\n\ttask = get_pid_task(submit->pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn;\n\n\tif (!*comm)\n\t\t*comm = kstrdup(task->comm, GFP_KERNEL);\n\n\tif (!*cmd)\n\t\t*cmd = kstrdup_quotable_cmdline(task, GFP_KERNEL);\n\n\tput_task_struct(task);\n}\n\nstatic void recover_worker(struct kthread_work *work)\n{\n\tstruct msm_gpu *gpu = container_of(work, struct msm_gpu, recover_work);\n\tstruct drm_device *dev = gpu->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct msm_gem_submit *submit;\n\tstruct msm_ringbuffer *cur_ring = gpu->funcs->active_ring(gpu);\n\tchar *comm = NULL, *cmd = NULL;\n\tint i;\n\n\tmutex_lock(&gpu->lock);\n\n\tDRM_DEV_ERROR(dev->dev, \"%s: hangcheck recover!\\n\", gpu->name);\n\n\tsubmit = find_submit(cur_ring, cur_ring->memptrs->fence + 1);\n\tif (submit) {\n\t\t \n\t\tsubmit->queue->faults++;\n\t\tif (submit->aspace)\n\t\t\tsubmit->aspace->faults++;\n\n\t\tget_comm_cmdline(submit, &comm, &cmd);\n\n\t\tif (comm && cmd) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"%s: offending task: %s (%s)\\n\",\n\t\t\t\tgpu->name, comm, cmd);\n\n\t\t\tmsm_rd_dump_submit(priv->hangrd, submit,\n\t\t\t\t\"offending task: %s (%s)\", comm, cmd);\n\t\t} else {\n\t\t\tmsm_rd_dump_submit(priv->hangrd, submit, NULL);\n\t\t}\n\t} else {\n\t\t \n\t\tgpu->global_faults++;\n\t}\n\n\t \n\tpm_runtime_get_sync(&gpu->pdev->dev);\n\tmsm_gpu_crashstate_capture(gpu, submit, comm, cmd);\n\n\tkfree(cmd);\n\tkfree(comm);\n\n\t \n\tfor (i = 0; i < gpu->nr_rings; i++) {\n\t\tstruct msm_ringbuffer *ring = gpu->rb[i];\n\n\t\tuint32_t fence = ring->memptrs->fence;\n\n\t\t \n\t\tif (ring == cur_ring)\n\t\t\tring->memptrs->fence = ++fence;\n\n\t\tmsm_update_fence(ring->fctx, fence);\n\t}\n\n\tif (msm_gpu_active(gpu)) {\n\t\t \n\t\tretire_submits(gpu);\n\n\t\tgpu->funcs->recover(gpu);\n\n\t\t \n\t\tfor (i = 0; i < gpu->nr_rings; i++) {\n\t\t\tstruct msm_ringbuffer *ring = gpu->rb[i];\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&ring->submit_lock, flags);\n\t\t\tlist_for_each_entry(submit, &ring->submits, node)\n\t\t\t\tgpu->funcs->submit(gpu, submit);\n\t\t\tspin_unlock_irqrestore(&ring->submit_lock, flags);\n\t\t}\n\t}\n\n\tpm_runtime_put(&gpu->pdev->dev);\n\n\tmutex_unlock(&gpu->lock);\n\n\tmsm_gpu_retire(gpu);\n}\n\nstatic void fault_worker(struct kthread_work *work)\n{\n\tstruct msm_gpu *gpu = container_of(work, struct msm_gpu, fault_work);\n\tstruct msm_gem_submit *submit;\n\tstruct msm_ringbuffer *cur_ring = gpu->funcs->active_ring(gpu);\n\tchar *comm = NULL, *cmd = NULL;\n\n\tmutex_lock(&gpu->lock);\n\n\tsubmit = find_submit(cur_ring, cur_ring->memptrs->fence + 1);\n\tif (submit && submit->fault_dumped)\n\t\tgoto resume_smmu;\n\n\tif (submit) {\n\t\tget_comm_cmdline(submit, &comm, &cmd);\n\n\t\t \n\t\tsubmit->fault_dumped = true;\n\t}\n\n\t \n\tpm_runtime_get_sync(&gpu->pdev->dev);\n\tmsm_gpu_crashstate_capture(gpu, submit, comm, cmd);\n\tpm_runtime_put_sync(&gpu->pdev->dev);\n\n\tkfree(cmd);\n\tkfree(comm);\n\nresume_smmu:\n\tmemset(&gpu->fault_info, 0, sizeof(gpu->fault_info));\n\tgpu->aspace->mmu->funcs->resume_translation(gpu->aspace->mmu);\n\n\tmutex_unlock(&gpu->lock);\n}\n\nstatic void hangcheck_timer_reset(struct msm_gpu *gpu)\n{\n\tstruct msm_drm_private *priv = gpu->dev->dev_private;\n\tmod_timer(&gpu->hangcheck_timer,\n\t\t\tround_jiffies_up(jiffies + msecs_to_jiffies(priv->hangcheck_period)));\n}\n\nstatic bool made_progress(struct msm_gpu *gpu, struct msm_ringbuffer *ring)\n{\n\tif (ring->hangcheck_progress_retries >= DRM_MSM_HANGCHECK_PROGRESS_RETRIES)\n\t\treturn false;\n\n\tif (!gpu->funcs->progress)\n\t\treturn false;\n\n\tif (!gpu->funcs->progress(gpu, ring))\n\t\treturn false;\n\n\tring->hangcheck_progress_retries++;\n\treturn true;\n}\n\nstatic void hangcheck_handler(struct timer_list *t)\n{\n\tstruct msm_gpu *gpu = from_timer(gpu, t, hangcheck_timer);\n\tstruct drm_device *dev = gpu->dev;\n\tstruct msm_ringbuffer *ring = gpu->funcs->active_ring(gpu);\n\tuint32_t fence = ring->memptrs->fence;\n\n\tif (fence != ring->hangcheck_fence) {\n\t\t \n\t\tring->hangcheck_fence = fence;\n\t\tring->hangcheck_progress_retries = 0;\n\t} else if (fence_before(fence, ring->fctx->last_fence) &&\n\t\t\t!made_progress(gpu, ring)) {\n\t\t \n\t\tring->hangcheck_fence = fence;\n\t\tring->hangcheck_progress_retries = 0;\n\t\tDRM_DEV_ERROR(dev->dev, \"%s: hangcheck detected gpu lockup rb %d!\\n\",\n\t\t\t\tgpu->name, ring->id);\n\t\tDRM_DEV_ERROR(dev->dev, \"%s:     completed fence: %u\\n\",\n\t\t\t\tgpu->name, fence);\n\t\tDRM_DEV_ERROR(dev->dev, \"%s:     submitted fence: %u\\n\",\n\t\t\t\tgpu->name, ring->fctx->last_fence);\n\n\t\tkthread_queue_work(gpu->worker, &gpu->recover_work);\n\t}\n\n\t \n\tif (fence_after(ring->fctx->last_fence, ring->hangcheck_fence))\n\t\thangcheck_timer_reset(gpu);\n\n\t \n\tmsm_gpu_retire(gpu);\n}\n\n \n\n \nstatic int update_hw_cntrs(struct msm_gpu *gpu, uint32_t ncntrs, uint32_t *cntrs)\n{\n\tuint32_t current_cntrs[ARRAY_SIZE(gpu->last_cntrs)];\n\tint i, n = min(ncntrs, gpu->num_perfcntrs);\n\n\t \n\tfor (i = 0; i < gpu->num_perfcntrs; i++)\n\t\tcurrent_cntrs[i] = gpu_read(gpu, gpu->perfcntrs[i].sample_reg);\n\n\t \n\tfor (i = 0; i < n; i++)\n\t\tcntrs[i] = current_cntrs[i] - gpu->last_cntrs[i];\n\n\t \n\tfor (i = 0; i < gpu->num_perfcntrs; i++)\n\t\tgpu->last_cntrs[i] = current_cntrs[i];\n\n\treturn n;\n}\n\nstatic void update_sw_cntrs(struct msm_gpu *gpu)\n{\n\tktime_t time;\n\tuint32_t elapsed;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gpu->perf_lock, flags);\n\tif (!gpu->perfcntr_active)\n\t\tgoto out;\n\n\ttime = ktime_get();\n\telapsed = ktime_to_us(ktime_sub(time, gpu->last_sample.time));\n\n\tgpu->totaltime += elapsed;\n\tif (gpu->last_sample.active)\n\t\tgpu->activetime += elapsed;\n\n\tgpu->last_sample.active = msm_gpu_active(gpu);\n\tgpu->last_sample.time = time;\n\nout:\n\tspin_unlock_irqrestore(&gpu->perf_lock, flags);\n}\n\nvoid msm_gpu_perfcntr_start(struct msm_gpu *gpu)\n{\n\tunsigned long flags;\n\n\tpm_runtime_get_sync(&gpu->pdev->dev);\n\n\tspin_lock_irqsave(&gpu->perf_lock, flags);\n\t \n\tgpu->last_sample.active = msm_gpu_active(gpu);\n\tgpu->last_sample.time = ktime_get();\n\tgpu->activetime = gpu->totaltime = 0;\n\tgpu->perfcntr_active = true;\n\tupdate_hw_cntrs(gpu, 0, NULL);\n\tspin_unlock_irqrestore(&gpu->perf_lock, flags);\n}\n\nvoid msm_gpu_perfcntr_stop(struct msm_gpu *gpu)\n{\n\tgpu->perfcntr_active = false;\n\tpm_runtime_put_sync(&gpu->pdev->dev);\n}\n\n \nint msm_gpu_perfcntr_sample(struct msm_gpu *gpu, uint32_t *activetime,\n\t\tuint32_t *totaltime, uint32_t ncntrs, uint32_t *cntrs)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&gpu->perf_lock, flags);\n\n\tif (!gpu->perfcntr_active) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*activetime = gpu->activetime;\n\t*totaltime = gpu->totaltime;\n\n\tgpu->activetime = gpu->totaltime = 0;\n\n\tret = update_hw_cntrs(gpu, ncntrs, cntrs);\n\nout:\n\tspin_unlock_irqrestore(&gpu->perf_lock, flags);\n\n\treturn ret;\n}\n\n \n\nstatic void retire_submit(struct msm_gpu *gpu, struct msm_ringbuffer *ring,\n\t\tstruct msm_gem_submit *submit)\n{\n\tint index = submit->seqno % MSM_GPU_SUBMIT_STATS_COUNT;\n\tvolatile struct msm_gpu_submit_stats *stats;\n\tu64 elapsed, clock = 0, cycles;\n\tunsigned long flags;\n\n\tstats = &ring->memptrs->stats[index];\n\t \n\telapsed = (stats->alwayson_end - stats->alwayson_start) * 10000;\n\tdo_div(elapsed, 192);\n\n\tcycles = stats->cpcycles_end - stats->cpcycles_start;\n\n\t \n\tif (elapsed) {\n\t\tclock = cycles * 1000;\n\t\tdo_div(clock, elapsed);\n\t}\n\n\tsubmit->queue->ctx->elapsed_ns += elapsed;\n\tsubmit->queue->ctx->cycles     += cycles;\n\n\ttrace_msm_gpu_submit_retired(submit, elapsed, clock,\n\t\tstats->alwayson_start, stats->alwayson_end);\n\n\tmsm_submit_retire(submit);\n\n\tpm_runtime_mark_last_busy(&gpu->pdev->dev);\n\n\tspin_lock_irqsave(&ring->submit_lock, flags);\n\tlist_del(&submit->node);\n\tspin_unlock_irqrestore(&ring->submit_lock, flags);\n\n\t \n\tmutex_lock(&gpu->active_lock);\n\tgpu->active_submits--;\n\tWARN_ON(gpu->active_submits < 0);\n\tif (!gpu->active_submits) {\n\t\tmsm_devfreq_idle(gpu);\n\t\tpm_runtime_put_autosuspend(&gpu->pdev->dev);\n\t}\n\n\tmutex_unlock(&gpu->active_lock);\n\n\tmsm_gem_submit_put(submit);\n}\n\nstatic void retire_submits(struct msm_gpu *gpu)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < gpu->nr_rings; i++) {\n\t\tstruct msm_ringbuffer *ring = gpu->rb[i];\n\n\t\twhile (true) {\n\t\t\tstruct msm_gem_submit *submit = NULL;\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&ring->submit_lock, flags);\n\t\t\tsubmit = list_first_entry_or_null(&ring->submits,\n\t\t\t\t\tstruct msm_gem_submit, node);\n\t\t\tspin_unlock_irqrestore(&ring->submit_lock, flags);\n\n\t\t\t \n\t\t\tif (submit && dma_fence_is_signaled(submit->hw_fence)) {\n\t\t\t\tretire_submit(gpu, ring, submit);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\twake_up_all(&gpu->retire_event);\n}\n\nstatic void retire_worker(struct kthread_work *work)\n{\n\tstruct msm_gpu *gpu = container_of(work, struct msm_gpu, retire_work);\n\n\tretire_submits(gpu);\n}\n\n \nvoid msm_gpu_retire(struct msm_gpu *gpu)\n{\n\tint i;\n\n\tfor (i = 0; i < gpu->nr_rings; i++)\n\t\tmsm_update_fence(gpu->rb[i]->fctx, gpu->rb[i]->memptrs->fence);\n\n\tkthread_queue_work(gpu->worker, &gpu->retire_work);\n\tupdate_sw_cntrs(gpu);\n}\n\n \nvoid msm_gpu_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit)\n{\n\tstruct msm_ringbuffer *ring = submit->ring;\n\tunsigned long flags;\n\n\tpm_runtime_get_sync(&gpu->pdev->dev);\n\n\tmutex_lock(&gpu->lock);\n\n\tmsm_gpu_hw_init(gpu);\n\n\tupdate_sw_cntrs(gpu);\n\n\t \n\tmsm_gem_submit_get(submit);\n\n\tspin_lock_irqsave(&ring->submit_lock, flags);\n\tlist_add_tail(&submit->node, &ring->submits);\n\tspin_unlock_irqrestore(&ring->submit_lock, flags);\n\n\t \n\tmutex_lock(&gpu->active_lock);\n\tif (!gpu->active_submits) {\n\t\tpm_runtime_get(&gpu->pdev->dev);\n\t\tmsm_devfreq_active(gpu);\n\t}\n\tgpu->active_submits++;\n\tmutex_unlock(&gpu->active_lock);\n\n\tgpu->funcs->submit(gpu, submit);\n\tgpu->cur_ctx_seqno = submit->queue->ctx->seqno;\n\n\thangcheck_timer_reset(gpu);\n\n\tmutex_unlock(&gpu->lock);\n\n\tpm_runtime_put(&gpu->pdev->dev);\n}\n\n \n\nstatic irqreturn_t irq_handler(int irq, void *data)\n{\n\tstruct msm_gpu *gpu = data;\n\treturn gpu->funcs->irq(gpu);\n}\n\nstatic int get_clocks(struct platform_device *pdev, struct msm_gpu *gpu)\n{\n\tint ret = devm_clk_bulk_get_all(&pdev->dev, &gpu->grp_clks);\n\n\tif (ret < 1) {\n\t\tgpu->nr_clocks = 0;\n\t\treturn ret;\n\t}\n\n\tgpu->nr_clocks = ret;\n\n\tgpu->core_clk = msm_clk_bulk_get_clock(gpu->grp_clks,\n\t\tgpu->nr_clocks, \"core\");\n\n\tgpu->rbbmtimer_clk = msm_clk_bulk_get_clock(gpu->grp_clks,\n\t\tgpu->nr_clocks, \"rbbmtimer\");\n\n\treturn 0;\n}\n\n \nstruct msm_gem_address_space *\nmsm_gpu_create_private_address_space(struct msm_gpu *gpu, struct task_struct *task)\n{\n\tstruct msm_gem_address_space *aspace = NULL;\n\tif (!gpu)\n\t\treturn NULL;\n\n\t \n\tif (gpu->funcs->create_private_address_space) {\n\t\taspace = gpu->funcs->create_private_address_space(gpu);\n\t\tif (!IS_ERR(aspace))\n\t\t\taspace->pid = get_pid(task_pid(task));\n\t}\n\n\tif (IS_ERR_OR_NULL(aspace))\n\t\taspace = msm_gem_address_space_get(gpu->aspace);\n\n\treturn aspace;\n}\n\nint msm_gpu_init(struct drm_device *drm, struct platform_device *pdev,\n\t\tstruct msm_gpu *gpu, const struct msm_gpu_funcs *funcs,\n\t\tconst char *name, struct msm_gpu_config *config)\n{\n\tstruct msm_drm_private *priv = drm->dev_private;\n\tint i, ret, nr_rings = config->nr_rings;\n\tvoid *memptrs;\n\tuint64_t memptrs_iova;\n\n\tif (WARN_ON(gpu->num_perfcntrs > ARRAY_SIZE(gpu->last_cntrs)))\n\t\tgpu->num_perfcntrs = ARRAY_SIZE(gpu->last_cntrs);\n\n\tgpu->dev = drm;\n\tgpu->funcs = funcs;\n\tgpu->name = name;\n\n\tgpu->worker = kthread_create_worker(0, \"gpu-worker\");\n\tif (IS_ERR(gpu->worker)) {\n\t\tret = PTR_ERR(gpu->worker);\n\t\tgpu->worker = NULL;\n\t\tgoto fail;\n\t}\n\n\tsched_set_fifo_low(gpu->worker->task);\n\n\tmutex_init(&gpu->active_lock);\n\tmutex_init(&gpu->lock);\n\tinit_waitqueue_head(&gpu->retire_event);\n\tkthread_init_work(&gpu->retire_work, retire_worker);\n\tkthread_init_work(&gpu->recover_work, recover_worker);\n\tkthread_init_work(&gpu->fault_work, fault_worker);\n\n\tpriv->hangcheck_period = DRM_MSM_HANGCHECK_DEFAULT_PERIOD;\n\n\t \n\tif (funcs->progress)\n\t\tpriv->hangcheck_period /= 2;\n\n\ttimer_setup(&gpu->hangcheck_timer, hangcheck_handler, 0);\n\n\tspin_lock_init(&gpu->perf_lock);\n\n\n\t \n\tgpu->mmio = msm_ioremap(pdev, config->ioname);\n\tif (IS_ERR(gpu->mmio)) {\n\t\tret = PTR_ERR(gpu->mmio);\n\t\tgoto fail;\n\t}\n\n\t \n\tgpu->irq = platform_get_irq(pdev, 0);\n\tif (gpu->irq < 0) {\n\t\tret = gpu->irq;\n\t\tgoto fail;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, gpu->irq, irq_handler,\n\t\t\tIRQF_TRIGGER_HIGH, \"gpu-irq\", gpu);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(drm->dev, \"failed to request IRQ%u: %d\\n\", gpu->irq, ret);\n\t\tgoto fail;\n\t}\n\n\tret = get_clocks(pdev, gpu);\n\tif (ret)\n\t\tgoto fail;\n\n\tgpu->ebi1_clk = msm_clk_get(pdev, \"bus\");\n\tDBG(\"ebi1_clk: %p\", gpu->ebi1_clk);\n\tif (IS_ERR(gpu->ebi1_clk))\n\t\tgpu->ebi1_clk = NULL;\n\n\t \n\tgpu->gpu_reg = devm_regulator_get(&pdev->dev, \"vdd\");\n\tDBG(\"gpu_reg: %p\", gpu->gpu_reg);\n\tif (IS_ERR(gpu->gpu_reg))\n\t\tgpu->gpu_reg = NULL;\n\n\tgpu->gpu_cx = devm_regulator_get(&pdev->dev, \"vddcx\");\n\tDBG(\"gpu_cx: %p\", gpu->gpu_cx);\n\tif (IS_ERR(gpu->gpu_cx))\n\t\tgpu->gpu_cx = NULL;\n\n\tgpu->pdev = pdev;\n\tplatform_set_drvdata(pdev, &gpu->adreno_smmu);\n\n\tmsm_devfreq_init(gpu);\n\n\n\tgpu->aspace = gpu->funcs->create_address_space(gpu, pdev);\n\n\tif (gpu->aspace == NULL)\n\t\tDRM_DEV_INFO(drm->dev, \"%s: no IOMMU, fallback to VRAM carveout!\\n\", name);\n\telse if (IS_ERR(gpu->aspace)) {\n\t\tret = PTR_ERR(gpu->aspace);\n\t\tgoto fail;\n\t}\n\n\tmemptrs = msm_gem_kernel_new(drm,\n\t\tsizeof(struct msm_rbmemptrs) * nr_rings,\n\t\tcheck_apriv(gpu, MSM_BO_WC), gpu->aspace, &gpu->memptrs_bo,\n\t\t&memptrs_iova);\n\n\tif (IS_ERR(memptrs)) {\n\t\tret = PTR_ERR(memptrs);\n\t\tDRM_DEV_ERROR(drm->dev, \"could not allocate memptrs: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tmsm_gem_object_set_name(gpu->memptrs_bo, \"memptrs\");\n\n\tif (nr_rings > ARRAY_SIZE(gpu->rb)) {\n\t\tDRM_DEV_INFO_ONCE(drm->dev, \"Only creating %zu ringbuffers\\n\",\n\t\t\tARRAY_SIZE(gpu->rb));\n\t\tnr_rings = ARRAY_SIZE(gpu->rb);\n\t}\n\n\t \n\tfor (i = 0; i < nr_rings; i++) {\n\t\tgpu->rb[i] = msm_ringbuffer_new(gpu, i, memptrs, memptrs_iova);\n\n\t\tif (IS_ERR(gpu->rb[i])) {\n\t\t\tret = PTR_ERR(gpu->rb[i]);\n\t\t\tDRM_DEV_ERROR(drm->dev,\n\t\t\t\t\"could not create ringbuffer %d: %d\\n\", i, ret);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tmemptrs += sizeof(struct msm_rbmemptrs);\n\t\tmemptrs_iova += sizeof(struct msm_rbmemptrs);\n\t}\n\n\tgpu->nr_rings = nr_rings;\n\n\trefcount_set(&gpu->sysprof_active, 1);\n\n\treturn 0;\n\nfail:\n\tfor (i = 0; i < ARRAY_SIZE(gpu->rb); i++)  {\n\t\tmsm_ringbuffer_destroy(gpu->rb[i]);\n\t\tgpu->rb[i] = NULL;\n\t}\n\n\tmsm_gem_kernel_put(gpu->memptrs_bo, gpu->aspace);\n\n\tplatform_set_drvdata(pdev, NULL);\n\treturn ret;\n}\n\nvoid msm_gpu_cleanup(struct msm_gpu *gpu)\n{\n\tint i;\n\n\tDBG(\"%s\", gpu->name);\n\n\tfor (i = 0; i < ARRAY_SIZE(gpu->rb); i++) {\n\t\tmsm_ringbuffer_destroy(gpu->rb[i]);\n\t\tgpu->rb[i] = NULL;\n\t}\n\n\tmsm_gem_kernel_put(gpu->memptrs_bo, gpu->aspace);\n\n\tif (!IS_ERR_OR_NULL(gpu->aspace)) {\n\t\tgpu->aspace->mmu->funcs->detach(gpu->aspace->mmu);\n\t\tmsm_gem_address_space_put(gpu->aspace);\n\t}\n\n\tif (gpu->worker) {\n\t\tkthread_destroy_worker(gpu->worker);\n\t}\n\n\tmsm_devfreq_cleanup(gpu);\n\n\tplatform_set_drvdata(gpu->pdev, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}