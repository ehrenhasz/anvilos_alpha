{
  "module_name": "dp_display.c",
  "hash_id": "06cdb2b63870f7dfc69616c4a5658561e699699f10982a1f6190cb77ead91994",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dp/dp_display.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/component.h>\n#include <linux/of_irq.h>\n#include <linux/delay.h>\n#include <drm/display/drm_dp_aux_bus.h>\n\n#include \"msm_drv.h\"\n#include \"msm_kms.h\"\n#include \"dp_parser.h\"\n#include \"dp_power.h\"\n#include \"dp_catalog.h\"\n#include \"dp_aux.h\"\n#include \"dp_reg.h\"\n#include \"dp_link.h\"\n#include \"dp_panel.h\"\n#include \"dp_ctrl.h\"\n#include \"dp_display.h\"\n#include \"dp_drm.h\"\n#include \"dp_audio.h\"\n#include \"dp_debug.h\"\n\nstatic bool psr_enabled = false;\nmodule_param(psr_enabled, bool, 0);\nMODULE_PARM_DESC(psr_enabled, \"enable PSR for eDP and DP displays\");\n\n#define HPD_STRING_SIZE 30\n\nenum {\n\tISR_DISCONNECTED,\n\tISR_CONNECT_PENDING,\n\tISR_CONNECTED,\n\tISR_HPD_REPLUG_COUNT,\n\tISR_IRQ_HPD_PULSE_COUNT,\n\tISR_HPD_LO_GLITH_COUNT,\n};\n\n \nenum {\n\tST_DISCONNECTED,\n\tST_MAINLINK_READY,\n\tST_CONNECTED,\n\tST_DISCONNECT_PENDING,\n\tST_DISPLAY_OFF,\n\tST_SUSPENDED,\n};\n\nenum {\n\tEV_NO_EVENT,\n\t \n\tEV_HPD_INIT_SETUP,\n\tEV_HPD_PLUG_INT,\n\tEV_IRQ_HPD_INT,\n\tEV_HPD_UNPLUG_INT,\n\tEV_USER_NOTIFICATION,\n};\n\n#define EVENT_TIMEOUT\t(HZ/10)\t \n#define DP_EVENT_Q_MAX\t8\n\n#define DP_TIMEOUT_NONE\t\t0\n\n#define WAIT_FOR_RESUME_TIMEOUT_JIFFIES (HZ / 2)\n\nstruct dp_event {\n\tu32 event_id;\n\tu32 data;\n\tu32 delay;\n};\n\nstruct dp_display_private {\n\tchar *name;\n\tint irq;\n\n\tunsigned int id;\n\n\t \n\tbool core_initialized;\n\tbool phy_initialized;\n\tbool hpd_irq_on;\n\tbool audio_supported;\n\n\tstruct drm_device *drm_dev;\n\tstruct platform_device *pdev;\n\tstruct dentry *root;\n\n\tstruct dp_parser  *parser;\n\tstruct dp_power   *power;\n\tstruct dp_catalog *catalog;\n\tstruct drm_dp_aux *aux;\n\tstruct dp_link    *link;\n\tstruct dp_panel   *panel;\n\tstruct dp_ctrl    *ctrl;\n\tstruct dp_debug   *debug;\n\n\tstruct dp_display_mode dp_mode;\n\tstruct msm_dp dp_display;\n\n\t \n\tstruct completion audio_comp;\n\n\t \n\tstruct mutex event_mutex;\n\twait_queue_head_t event_q;\n\tu32 hpd_state;\n\tu32 event_pndx;\n\tu32 event_gndx;\n\tstruct task_struct *ev_tsk;\n\tstruct dp_event event_list[DP_EVENT_Q_MAX];\n\tspinlock_t event_lock;\n\n\tbool wide_bus_en;\n\n\tstruct dp_audio *audio;\n};\n\nstruct msm_dp_desc {\n\tphys_addr_t io_start;\n\tunsigned int id;\n\tunsigned int connector_type;\n\tbool wide_bus_en;\n};\n\nstatic const struct msm_dp_desc sc7180_dp_descs[] = {\n\t{ .io_start = 0x0ae90000, .id = MSM_DP_CONTROLLER_0, .connector_type = DRM_MODE_CONNECTOR_DisplayPort },\n\t{}\n};\n\nstatic const struct msm_dp_desc sc7280_dp_descs[] = {\n\t{ .io_start = 0x0ae90000, .id = MSM_DP_CONTROLLER_0, .connector_type = DRM_MODE_CONNECTOR_DisplayPort, .wide_bus_en = true },\n\t{ .io_start = 0x0aea0000, .id = MSM_DP_CONTROLLER_1, .connector_type = DRM_MODE_CONNECTOR_eDP, .wide_bus_en = true },\n\t{}\n};\n\nstatic const struct msm_dp_desc sc8180x_dp_descs[] = {\n\t{ .io_start = 0x0ae90000, .id = MSM_DP_CONTROLLER_0, .connector_type = DRM_MODE_CONNECTOR_DisplayPort },\n\t{ .io_start = 0x0ae98000, .id = MSM_DP_CONTROLLER_1, .connector_type = DRM_MODE_CONNECTOR_DisplayPort },\n\t{ .io_start = 0x0ae9a000, .id = MSM_DP_CONTROLLER_2, .connector_type = DRM_MODE_CONNECTOR_eDP },\n\t{}\n};\n\nstatic const struct msm_dp_desc sc8280xp_dp_descs[] = {\n\t{ .io_start = 0x0ae90000, .id = MSM_DP_CONTROLLER_0, .connector_type = DRM_MODE_CONNECTOR_DisplayPort, .wide_bus_en = true },\n\t{ .io_start = 0x0ae98000, .id = MSM_DP_CONTROLLER_1, .connector_type = DRM_MODE_CONNECTOR_DisplayPort, .wide_bus_en = true },\n\t{ .io_start = 0x0ae9a000, .id = MSM_DP_CONTROLLER_2, .connector_type = DRM_MODE_CONNECTOR_DisplayPort, .wide_bus_en = true },\n\t{ .io_start = 0x0aea0000, .id = MSM_DP_CONTROLLER_3, .connector_type = DRM_MODE_CONNECTOR_DisplayPort, .wide_bus_en = true },\n\t{ .io_start = 0x22090000, .id = MSM_DP_CONTROLLER_0, .connector_type = DRM_MODE_CONNECTOR_DisplayPort, .wide_bus_en = true },\n\t{ .io_start = 0x22098000, .id = MSM_DP_CONTROLLER_1, .connector_type = DRM_MODE_CONNECTOR_DisplayPort, .wide_bus_en = true },\n\t{ .io_start = 0x2209a000, .id = MSM_DP_CONTROLLER_2, .connector_type = DRM_MODE_CONNECTOR_DisplayPort, .wide_bus_en = true },\n\t{ .io_start = 0x220a0000, .id = MSM_DP_CONTROLLER_3, .connector_type = DRM_MODE_CONNECTOR_DisplayPort, .wide_bus_en = true },\n\t{}\n};\n\nstatic const struct msm_dp_desc sc8280xp_edp_descs[] = {\n\t{ .io_start = 0x0ae9a000, .id = MSM_DP_CONTROLLER_2, .connector_type = DRM_MODE_CONNECTOR_eDP, .wide_bus_en = true },\n\t{ .io_start = 0x0aea0000, .id = MSM_DP_CONTROLLER_3, .connector_type = DRM_MODE_CONNECTOR_eDP, .wide_bus_en = true },\n\t{ .io_start = 0x2209a000, .id = MSM_DP_CONTROLLER_2, .connector_type = DRM_MODE_CONNECTOR_eDP, .wide_bus_en = true },\n\t{ .io_start = 0x220a0000, .id = MSM_DP_CONTROLLER_3, .connector_type = DRM_MODE_CONNECTOR_eDP, .wide_bus_en = true },\n\t{}\n};\n\nstatic const struct msm_dp_desc sm8350_dp_descs[] = {\n\t{ .io_start = 0x0ae90000, .id = MSM_DP_CONTROLLER_0, .connector_type = DRM_MODE_CONNECTOR_DisplayPort },\n\t{}\n};\n\nstatic const struct of_device_id dp_dt_match[] = {\n\t{ .compatible = \"qcom,sc7180-dp\", .data = &sc7180_dp_descs },\n\t{ .compatible = \"qcom,sc7280-dp\", .data = &sc7280_dp_descs },\n\t{ .compatible = \"qcom,sc7280-edp\", .data = &sc7280_dp_descs },\n\t{ .compatible = \"qcom,sc8180x-dp\", .data = &sc8180x_dp_descs },\n\t{ .compatible = \"qcom,sc8180x-edp\", .data = &sc8180x_dp_descs },\n\t{ .compatible = \"qcom,sc8280xp-dp\", .data = &sc8280xp_dp_descs },\n\t{ .compatible = \"qcom,sc8280xp-edp\", .data = &sc8280xp_edp_descs },\n\t{ .compatible = \"qcom,sdm845-dp\", .data = &sc7180_dp_descs },\n\t{ .compatible = \"qcom,sm8350-dp\", .data = &sm8350_dp_descs },\n\t{}\n};\n\nstatic struct dp_display_private *dev_get_dp_display_private(struct device *dev)\n{\n\tstruct msm_dp *dp = dev_get_drvdata(dev);\n\n\treturn container_of(dp, struct dp_display_private, dp_display);\n}\n\nstatic int dp_add_event(struct dp_display_private *dp_priv, u32 event,\n\t\t\t\t\t\tu32 data, u32 delay)\n{\n\tunsigned long flag;\n\tstruct dp_event *todo;\n\tint pndx;\n\n\tspin_lock_irqsave(&dp_priv->event_lock, flag);\n\tpndx = dp_priv->event_pndx + 1;\n\tpndx %= DP_EVENT_Q_MAX;\n\tif (pndx == dp_priv->event_gndx) {\n\t\tpr_err(\"event_q is full: pndx=%d gndx=%d\\n\",\n\t\t\tdp_priv->event_pndx, dp_priv->event_gndx);\n\t\tspin_unlock_irqrestore(&dp_priv->event_lock, flag);\n\t\treturn -EPERM;\n\t}\n\ttodo = &dp_priv->event_list[dp_priv->event_pndx++];\n\tdp_priv->event_pndx %= DP_EVENT_Q_MAX;\n\ttodo->event_id = event;\n\ttodo->data = data;\n\ttodo->delay = delay;\n\twake_up(&dp_priv->event_q);\n\tspin_unlock_irqrestore(&dp_priv->event_lock, flag);\n\n\treturn 0;\n}\n\nstatic int dp_del_event(struct dp_display_private *dp_priv, u32 event)\n{\n\tunsigned long flag;\n\tstruct dp_event *todo;\n\tu32\tgndx;\n\n\tspin_lock_irqsave(&dp_priv->event_lock, flag);\n\tif (dp_priv->event_pndx == dp_priv->event_gndx) {\n\t\tspin_unlock_irqrestore(&dp_priv->event_lock, flag);\n\t\treturn -ENOENT;\n\t}\n\n\tgndx = dp_priv->event_gndx;\n\twhile (dp_priv->event_pndx != gndx) {\n\t\ttodo = &dp_priv->event_list[gndx];\n\t\tif (todo->event_id == event) {\n\t\t\ttodo->event_id = EV_NO_EVENT;\t \n\t\t\ttodo->delay = 0;\n\t\t}\n\t\tgndx++;\n\t\tgndx %= DP_EVENT_Q_MAX;\n\t}\n\tspin_unlock_irqrestore(&dp_priv->event_lock, flag);\n\n\treturn 0;\n}\n\nvoid dp_display_signal_audio_start(struct msm_dp *dp_display)\n{\n\tstruct dp_display_private *dp;\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\treinit_completion(&dp->audio_comp);\n}\n\nvoid dp_display_signal_audio_complete(struct msm_dp *dp_display)\n{\n\tstruct dp_display_private *dp;\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\tcomplete_all(&dp->audio_comp);\n}\n\nstatic int dp_hpd_event_thread_start(struct dp_display_private *dp_priv);\n\nstatic int dp_display_bind(struct device *dev, struct device *master,\n\t\t\t   void *data)\n{\n\tint rc = 0;\n\tstruct dp_display_private *dp = dev_get_dp_display_private(dev);\n\tstruct msm_drm_private *priv = dev_get_drvdata(master);\n\tstruct drm_device *drm = priv->dev;\n\n\tdp->dp_display.drm_dev = drm;\n\tpriv->dp[dp->id] = &dp->dp_display;\n\n\trc = dp->parser->parse(dp->parser);\n\tif (rc) {\n\t\tDRM_ERROR(\"device tree parsing failed\\n\");\n\t\tgoto end;\n\t}\n\n\n\tdp->drm_dev = drm;\n\tdp->aux->drm_dev = drm;\n\trc = dp_aux_register(dp->aux);\n\tif (rc) {\n\t\tDRM_ERROR(\"DRM DP AUX register failed\\n\");\n\t\tgoto end;\n\t}\n\n\trc = dp_power_client_init(dp->power);\n\tif (rc) {\n\t\tDRM_ERROR(\"Power client create failed\\n\");\n\t\tgoto end;\n\t}\n\n\trc = dp_register_audio_driver(dev, dp->audio);\n\tif (rc) {\n\t\tDRM_ERROR(\"Audio registration Dp failed\\n\");\n\t\tgoto end;\n\t}\n\n\trc = dp_hpd_event_thread_start(dp);\n\tif (rc) {\n\t\tDRM_ERROR(\"Event thread create failed\\n\");\n\t\tgoto end;\n\t}\n\n\treturn 0;\nend:\n\treturn rc;\n}\n\nstatic void dp_display_unbind(struct device *dev, struct device *master,\n\t\t\t      void *data)\n{\n\tstruct dp_display_private *dp = dev_get_dp_display_private(dev);\n\tstruct msm_drm_private *priv = dev_get_drvdata(master);\n\n\t \n\tif (dp->core_initialized)\n\t\tdp_catalog_hpd_config_intr(dp->catalog, DP_DP_HPD_INT_MASK, false);\n\n\tkthread_stop(dp->ev_tsk);\n\n\tof_dp_aux_depopulate_bus(dp->aux);\n\n\tdp_power_client_deinit(dp->power);\n\tdp_unregister_audio_driver(dev, dp->audio);\n\tdp_aux_unregister(dp->aux);\n\tdp->drm_dev = NULL;\n\tdp->aux->drm_dev = NULL;\n\tpriv->dp[dp->id] = NULL;\n}\n\nstatic const struct component_ops dp_display_comp_ops = {\n\t.bind = dp_display_bind,\n\t.unbind = dp_display_unbind,\n};\n\nstatic bool dp_display_is_ds_bridge(struct dp_panel *panel)\n{\n\treturn (panel->dpcd[DP_DOWNSTREAMPORT_PRESENT] &\n\t\tDP_DWN_STRM_PORT_PRESENT);\n}\n\nstatic bool dp_display_is_sink_count_zero(struct dp_display_private *dp)\n{\n\tdrm_dbg_dp(dp->drm_dev, \"present=%#x sink_count=%d\\n\",\n\t\t\tdp->panel->dpcd[DP_DOWNSTREAMPORT_PRESENT],\n\t\tdp->link->sink_count);\n\treturn dp_display_is_ds_bridge(dp->panel) &&\n\t\t(dp->link->sink_count == 0);\n}\n\nstatic void dp_display_send_hpd_event(struct msm_dp *dp_display)\n{\n\tstruct dp_display_private *dp;\n\tstruct drm_connector *connector;\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\tconnector = dp->dp_display.connector;\n\tdrm_helper_hpd_irq_event(connector->dev);\n}\n\n\nstatic int dp_display_send_hpd_notification(struct dp_display_private *dp,\n\t\t\t\t\t    bool hpd)\n{\n\tif ((hpd && dp->dp_display.is_connected) ||\n\t\t\t(!hpd && !dp->dp_display.is_connected)) {\n\t\tdrm_dbg_dp(dp->drm_dev, \"HPD already %s\\n\",\n\t\t\t\t(hpd ? \"on\" : \"off\"));\n\t\treturn 0;\n\t}\n\n\t \n\tif (!hpd)\n\t\tdp->panel->video_test = false;\n\n\tdp->dp_display.is_connected = hpd;\n\n\tdrm_dbg_dp(dp->drm_dev, \"type=%d hpd=%d\\n\",\n\t\t\tdp->dp_display.connector_type, hpd);\n\tdp_display_send_hpd_event(&dp->dp_display);\n\n\treturn 0;\n}\n\nstatic int dp_display_process_hpd_high(struct dp_display_private *dp)\n{\n\tint rc = 0;\n\tstruct edid *edid;\n\n\tdp->panel->max_dp_lanes = dp->parser->max_dp_lanes;\n\tdp->panel->max_dp_link_rate = dp->parser->max_dp_link_rate;\n\n\tdrm_dbg_dp(dp->drm_dev, \"max_lanes=%d max_link_rate=%d\\n\",\n\t\tdp->panel->max_dp_lanes, dp->panel->max_dp_link_rate);\n\n\trc = dp_panel_read_sink_caps(dp->panel, dp->dp_display.connector);\n\tif (rc)\n\t\tgoto end;\n\n\tdp_link_process_request(dp->link);\n\n\tedid = dp->panel->edid;\n\n\tdp->dp_display.psr_supported = dp->panel->psr_cap.version && psr_enabled;\n\n\tdp->audio_supported = drm_detect_monitor_audio(edid);\n\tdp_panel_handle_sink_request(dp->panel);\n\n\tdp->dp_display.max_dp_lanes = dp->parser->max_dp_lanes;\n\n\t \n\tdp_link_psm_config(dp->link, &dp->panel->link_info, false);\n\n\tdp_link_reset_phy_params_vx_px(dp->link);\n\trc = dp_ctrl_on_link(dp->ctrl);\n\tif (rc) {\n\t\tDRM_ERROR(\"failed to complete DP link training\\n\");\n\t\tgoto end;\n\t}\n\n\tdp_add_event(dp, EV_USER_NOTIFICATION, true, 0);\n\nend:\n\treturn rc;\n}\n\nstatic void dp_display_host_phy_init(struct dp_display_private *dp)\n{\n\tdrm_dbg_dp(dp->drm_dev, \"type=%d core_init=%d phy_init=%d\\n\",\n\t\tdp->dp_display.connector_type, dp->core_initialized,\n\t\tdp->phy_initialized);\n\n\tif (!dp->phy_initialized) {\n\t\tdp_ctrl_phy_init(dp->ctrl);\n\t\tdp->phy_initialized = true;\n\t}\n}\n\nstatic void dp_display_host_phy_exit(struct dp_display_private *dp)\n{\n\tdrm_dbg_dp(dp->drm_dev, \"type=%d core_init=%d phy_init=%d\\n\",\n\t\tdp->dp_display.connector_type, dp->core_initialized,\n\t\tdp->phy_initialized);\n\n\tif (dp->phy_initialized) {\n\t\tdp_ctrl_phy_exit(dp->ctrl);\n\t\tdp->phy_initialized = false;\n\t}\n}\n\nstatic void dp_display_host_init(struct dp_display_private *dp)\n{\n\tdrm_dbg_dp(dp->drm_dev, \"type=%d core_init=%d phy_init=%d\\n\",\n\t\tdp->dp_display.connector_type, dp->core_initialized,\n\t\tdp->phy_initialized);\n\n\tdp_power_init(dp->power);\n\tdp_ctrl_reset_irq_ctrl(dp->ctrl, true);\n\tdp_aux_init(dp->aux);\n\tdp->core_initialized = true;\n}\n\nstatic void dp_display_host_deinit(struct dp_display_private *dp)\n{\n\tdrm_dbg_dp(dp->drm_dev, \"type=%d core_init=%d phy_init=%d\\n\",\n\t\tdp->dp_display.connector_type, dp->core_initialized,\n\t\tdp->phy_initialized);\n\n\tdp_ctrl_reset_irq_ctrl(dp->ctrl, false);\n\tdp_aux_deinit(dp->aux);\n\tdp_power_deinit(dp->power);\n\tdp->core_initialized = false;\n}\n\nstatic int dp_display_usbpd_configure_cb(struct device *dev)\n{\n\tstruct dp_display_private *dp = dev_get_dp_display_private(dev);\n\n\tdp_display_host_phy_init(dp);\n\n\treturn dp_display_process_hpd_high(dp);\n}\n\nstatic int dp_display_notify_disconnect(struct device *dev)\n{\n\tstruct dp_display_private *dp = dev_get_dp_display_private(dev);\n\n\tdp_add_event(dp, EV_USER_NOTIFICATION, false, 0);\n\n\treturn 0;\n}\n\nstatic void dp_display_handle_video_request(struct dp_display_private *dp)\n{\n\tif (dp->link->sink_request & DP_TEST_LINK_VIDEO_PATTERN) {\n\t\tdp->panel->video_test = true;\n\t\tdp_link_send_test_response(dp->link);\n\t}\n}\n\nstatic int dp_display_handle_port_ststus_changed(struct dp_display_private *dp)\n{\n\tint rc = 0;\n\n\tif (dp_display_is_sink_count_zero(dp)) {\n\t\tdrm_dbg_dp(dp->drm_dev, \"sink count is zero, nothing to do\\n\");\n\t\tif (dp->hpd_state != ST_DISCONNECTED) {\n\t\t\tdp->hpd_state = ST_DISCONNECT_PENDING;\n\t\t\tdp_add_event(dp, EV_USER_NOTIFICATION, false, 0);\n\t\t}\n\t} else {\n\t\tif (dp->hpd_state == ST_DISCONNECTED) {\n\t\t\tdp->hpd_state = ST_MAINLINK_READY;\n\t\t\trc = dp_display_process_hpd_high(dp);\n\t\t\tif (rc)\n\t\t\t\tdp->hpd_state = ST_DISCONNECTED;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int dp_display_handle_irq_hpd(struct dp_display_private *dp)\n{\n\tu32 sink_request = dp->link->sink_request;\n\n\tdrm_dbg_dp(dp->drm_dev, \"%d\\n\", sink_request);\n\tif (dp->hpd_state == ST_DISCONNECTED) {\n\t\tif (sink_request & DP_LINK_STATUS_UPDATED) {\n\t\t\tdrm_dbg_dp(dp->drm_dev, \"Disconnected sink_request: %d\\n\",\n\t\t\t\t\t\t\tsink_request);\n\t\t\tDRM_ERROR(\"Disconnected, no DP_LINK_STATUS_UPDATED\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdp_ctrl_handle_sink_request(dp->ctrl);\n\n\tif (sink_request & DP_TEST_LINK_VIDEO_PATTERN)\n\t\tdp_display_handle_video_request(dp);\n\n\treturn 0;\n}\n\nstatic int dp_display_usbpd_attention_cb(struct device *dev)\n{\n\tint rc = 0;\n\tu32 sink_request;\n\tstruct dp_display_private *dp = dev_get_dp_display_private(dev);\n\n\t \n\trc = dp_link_process_request(dp->link);\n\tif (!rc) {\n\t\tsink_request = dp->link->sink_request;\n\t\tdrm_dbg_dp(dp->drm_dev, \"hpd_state=%d sink_request=%d\\n\",\n\t\t\t\t\tdp->hpd_state, sink_request);\n\t\tif (sink_request & DS_PORT_STATUS_CHANGED)\n\t\t\trc = dp_display_handle_port_ststus_changed(dp);\n\t\telse\n\t\t\trc = dp_display_handle_irq_hpd(dp);\n\t}\n\n\treturn rc;\n}\n\nstatic int dp_hpd_plug_handle(struct dp_display_private *dp, u32 data)\n{\n\tu32 state;\n\tint ret;\n\n\tmutex_lock(&dp->event_mutex);\n\n\tstate =  dp->hpd_state;\n\tdrm_dbg_dp(dp->drm_dev, \"Before, type=%d hpd_state=%d\\n\",\n\t\t\tdp->dp_display.connector_type, state);\n\n\tif (state == ST_DISPLAY_OFF || state == ST_SUSPENDED) {\n\t\tmutex_unlock(&dp->event_mutex);\n\t\treturn 0;\n\t}\n\n\tif (state == ST_MAINLINK_READY || state == ST_CONNECTED) {\n\t\tmutex_unlock(&dp->event_mutex);\n\t\treturn 0;\n\t}\n\n\tif (state == ST_DISCONNECT_PENDING) {\n\t\t \n\t\tdp_add_event(dp, EV_HPD_PLUG_INT, 0, 1);  \n\t\tmutex_unlock(&dp->event_mutex);\n\t\treturn 0;\n\t}\n\n\tret = dp_display_usbpd_configure_cb(&dp->pdev->dev);\n\tif (ret) {\t \n\t\tdp->hpd_state = ST_DISCONNECTED;\n\t} else {\n\t\tdp->hpd_state = ST_MAINLINK_READY;\n\t}\n\n\tdrm_dbg_dp(dp->drm_dev, \"After, type=%d hpd_state=%d\\n\",\n\t\t\tdp->dp_display.connector_type, state);\n\tmutex_unlock(&dp->event_mutex);\n\n\t \n\treturn 0;\n};\n\nstatic void dp_display_handle_plugged_change(struct msm_dp *dp_display,\n\t\tbool plugged)\n{\n\tstruct dp_display_private *dp;\n\n\tdp = container_of(dp_display,\n\t\t\tstruct dp_display_private, dp_display);\n\n\t \n\tif (dp_display->plugged_cb && dp_display->codec_dev &&\n\t\t\tdp->audio_supported)\n\t\tdp_display->plugged_cb(dp_display->codec_dev, plugged);\n}\n\nstatic int dp_hpd_unplug_handle(struct dp_display_private *dp, u32 data)\n{\n\tu32 state;\n\n\tmutex_lock(&dp->event_mutex);\n\n\tstate = dp->hpd_state;\n\n\tdrm_dbg_dp(dp->drm_dev, \"Before, type=%d hpd_state=%d\\n\",\n\t\t\tdp->dp_display.connector_type, state);\n\n\t \n\tdp_del_event(dp, EV_IRQ_HPD_INT);\n\n\tif (state == ST_DISCONNECTED) {\n\t\t \n\t\tif (dp->link->sink_count == 0) {\n\t\t\tdp_display_host_phy_exit(dp);\n\t\t}\n\t\tdp_display_notify_disconnect(&dp->pdev->dev);\n\t\tmutex_unlock(&dp->event_mutex);\n\t\treturn 0;\n\t} else if (state == ST_DISCONNECT_PENDING) {\n\t\tmutex_unlock(&dp->event_mutex);\n\t\treturn 0;\n\t} else if (state == ST_MAINLINK_READY) {\n\t\tdp_ctrl_off_link(dp->ctrl);\n\t\tdp_display_host_phy_exit(dp);\n\t\tdp->hpd_state = ST_DISCONNECTED;\n\t\tdp_display_notify_disconnect(&dp->pdev->dev);\n\t\tmutex_unlock(&dp->event_mutex);\n\t\treturn 0;\n\t}\n\n\t \n\tdp_display_notify_disconnect(&dp->pdev->dev);\n\n\tif (state == ST_DISPLAY_OFF) {\n\t\tdp->hpd_state = ST_DISCONNECTED;\n\t} else {\n\t\tdp->hpd_state = ST_DISCONNECT_PENDING;\n\t}\n\n\t \n\tdp_display_handle_plugged_change(&dp->dp_display, false);\n\n\tdrm_dbg_dp(dp->drm_dev, \"After, type=%d hpd_state=%d\\n\",\n\t\t\tdp->dp_display.connector_type, state);\n\n\t \n\tmutex_unlock(&dp->event_mutex);\n\treturn 0;\n}\n\nstatic int dp_irq_hpd_handle(struct dp_display_private *dp, u32 data)\n{\n\tu32 state;\n\n\tmutex_lock(&dp->event_mutex);\n\n\t \n\tstate =  dp->hpd_state;\n\tdrm_dbg_dp(dp->drm_dev, \"Before, type=%d hpd_state=%d\\n\",\n\t\t\tdp->dp_display.connector_type, state);\n\n\tif (state == ST_DISPLAY_OFF || state == ST_SUSPENDED) {\n\t\tmutex_unlock(&dp->event_mutex);\n\t\treturn 0;\n\t}\n\n\tif (state == ST_MAINLINK_READY || state == ST_DISCONNECT_PENDING) {\n\t\t \n\t\tdp_add_event(dp, EV_IRQ_HPD_INT, 0, 1);  \n\t\tmutex_unlock(&dp->event_mutex);\n\t\treturn 0;\n\t}\n\n\tdp_display_usbpd_attention_cb(&dp->pdev->dev);\n\n\tdrm_dbg_dp(dp->drm_dev, \"After, type=%d hpd_state=%d\\n\",\n\t\t\tdp->dp_display.connector_type, state);\n\n\tmutex_unlock(&dp->event_mutex);\n\n\treturn 0;\n}\n\nstatic void dp_display_deinit_sub_modules(struct dp_display_private *dp)\n{\n\tdp_debug_put(dp->debug);\n\tdp_audio_put(dp->audio);\n\tdp_panel_put(dp->panel);\n\tdp_aux_put(dp->aux);\n}\n\nstatic int dp_init_sub_modules(struct dp_display_private *dp)\n{\n\tint rc = 0;\n\tstruct device *dev = &dp->pdev->dev;\n\tstruct dp_panel_in panel_in = {\n\t\t.dev = dev,\n\t};\n\n\tdp->parser = dp_parser_get(dp->pdev);\n\tif (IS_ERR(dp->parser)) {\n\t\trc = PTR_ERR(dp->parser);\n\t\tDRM_ERROR(\"failed to initialize parser, rc = %d\\n\", rc);\n\t\tdp->parser = NULL;\n\t\tgoto error;\n\t}\n\n\tdp->catalog = dp_catalog_get(dev, &dp->parser->io);\n\tif (IS_ERR(dp->catalog)) {\n\t\trc = PTR_ERR(dp->catalog);\n\t\tDRM_ERROR(\"failed to initialize catalog, rc = %d\\n\", rc);\n\t\tdp->catalog = NULL;\n\t\tgoto error;\n\t}\n\n\tdp->power = dp_power_get(dev, dp->parser);\n\tif (IS_ERR(dp->power)) {\n\t\trc = PTR_ERR(dp->power);\n\t\tDRM_ERROR(\"failed to initialize power, rc = %d\\n\", rc);\n\t\tdp->power = NULL;\n\t\tgoto error;\n\t}\n\n\tdp->aux = dp_aux_get(dev, dp->catalog, dp->dp_display.is_edp);\n\tif (IS_ERR(dp->aux)) {\n\t\trc = PTR_ERR(dp->aux);\n\t\tDRM_ERROR(\"failed to initialize aux, rc = %d\\n\", rc);\n\t\tdp->aux = NULL;\n\t\tgoto error;\n\t}\n\n\tdp->link = dp_link_get(dev, dp->aux);\n\tif (IS_ERR(dp->link)) {\n\t\trc = PTR_ERR(dp->link);\n\t\tDRM_ERROR(\"failed to initialize link, rc = %d\\n\", rc);\n\t\tdp->link = NULL;\n\t\tgoto error_link;\n\t}\n\n\tpanel_in.aux = dp->aux;\n\tpanel_in.catalog = dp->catalog;\n\tpanel_in.link = dp->link;\n\n\tdp->panel = dp_panel_get(&panel_in);\n\tif (IS_ERR(dp->panel)) {\n\t\trc = PTR_ERR(dp->panel);\n\t\tDRM_ERROR(\"failed to initialize panel, rc = %d\\n\", rc);\n\t\tdp->panel = NULL;\n\t\tgoto error_link;\n\t}\n\n\tdp->ctrl = dp_ctrl_get(dev, dp->link, dp->panel, dp->aux,\n\t\t\t       dp->power, dp->catalog, dp->parser);\n\tif (IS_ERR(dp->ctrl)) {\n\t\trc = PTR_ERR(dp->ctrl);\n\t\tDRM_ERROR(\"failed to initialize ctrl, rc = %d\\n\", rc);\n\t\tdp->ctrl = NULL;\n\t\tgoto error_ctrl;\n\t}\n\n\tdp->audio = dp_audio_get(dp->pdev, dp->panel, dp->catalog);\n\tif (IS_ERR(dp->audio)) {\n\t\trc = PTR_ERR(dp->audio);\n\t\tpr_err(\"failed to initialize audio, rc = %d\\n\", rc);\n\t\tdp->audio = NULL;\n\t\tgoto error_ctrl;\n\t}\n\n\t \n\tdp->ctrl->wide_bus_en = dp->wide_bus_en;\n\tdp->catalog->wide_bus_en = dp->wide_bus_en;\n\n\treturn rc;\n\nerror_ctrl:\n\tdp_panel_put(dp->panel);\nerror_link:\n\tdp_aux_put(dp->aux);\nerror:\n\treturn rc;\n}\n\nstatic int dp_display_set_mode(struct msm_dp *dp_display,\n\t\t\t       struct dp_display_mode *mode)\n{\n\tstruct dp_display_private *dp;\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\tdrm_mode_copy(&dp->panel->dp_mode.drm_mode, &mode->drm_mode);\n\tdp->panel->dp_mode.bpp = mode->bpp;\n\tdp->panel->dp_mode.capabilities = mode->capabilities;\n\tdp_panel_init_panel_info(dp->panel);\n\treturn 0;\n}\n\nstatic int dp_display_enable(struct dp_display_private *dp, bool force_link_train)\n{\n\tint rc = 0;\n\tstruct msm_dp *dp_display = &dp->dp_display;\n\n\tdrm_dbg_dp(dp->drm_dev, \"sink_count=%d\\n\", dp->link->sink_count);\n\tif (dp_display->power_on) {\n\t\tdrm_dbg_dp(dp->drm_dev, \"Link already setup, return\\n\");\n\t\treturn 0;\n\t}\n\n\trc = dp_ctrl_on_stream(dp->ctrl, force_link_train);\n\tif (!rc)\n\t\tdp_display->power_on = true;\n\n\treturn rc;\n}\n\nstatic int dp_display_post_enable(struct msm_dp *dp_display)\n{\n\tstruct dp_display_private *dp;\n\tu32 rate;\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\trate = dp->link->link_params.rate;\n\n\tif (dp->audio_supported) {\n\t\tdp->audio->bw_code = drm_dp_link_rate_to_bw_code(rate);\n\t\tdp->audio->lane_count = dp->link->link_params.num_lanes;\n\t}\n\n\t \n\tdp_display_handle_plugged_change(dp_display, true);\n\n\tif (dp_display->psr_supported)\n\t\tdp_ctrl_config_psr(dp->ctrl);\n\n\treturn 0;\n}\n\nstatic int dp_display_disable(struct dp_display_private *dp)\n{\n\tstruct msm_dp *dp_display = &dp->dp_display;\n\n\tif (!dp_display->power_on)\n\t\treturn 0;\n\n\t \n\tif (dp_display->audio_enabled) {\n\t\t \n\t\tdp_display_handle_plugged_change(dp_display, false);\n\t\tif (!wait_for_completion_timeout(&dp->audio_comp,\n\t\t\t\tHZ * 5))\n\t\t\tDRM_ERROR(\"audio comp timeout\\n\");\n\t}\n\n\tdp_display->audio_enabled = false;\n\n\tif (dp->link->sink_count == 0) {\n\t\t \n\t\tdp_ctrl_off_link_stream(dp->ctrl);\n\t} else {\n\t\t \n\t\tdp_ctrl_off(dp->ctrl);\n\t\tdp_display_host_phy_exit(dp);\n\t}\n\n\tdp_display->power_on = false;\n\n\tdrm_dbg_dp(dp->drm_dev, \"sink count: %d\\n\", dp->link->sink_count);\n\treturn 0;\n}\n\nint dp_display_set_plugged_cb(struct msm_dp *dp_display,\n\t\thdmi_codec_plugged_cb fn, struct device *codec_dev)\n{\n\tbool plugged;\n\n\tdp_display->plugged_cb = fn;\n\tdp_display->codec_dev = codec_dev;\n\tplugged = dp_display->is_connected;\n\tdp_display_handle_plugged_change(dp_display, plugged);\n\n\treturn 0;\n}\n\n \nenum drm_mode_status dp_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t\t  const struct drm_display_info *info,\n\t\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tconst u32 num_components = 3, default_bpp = 24;\n\tstruct dp_display_private *dp_display;\n\tstruct dp_link_info *link_info;\n\tu32 mode_rate_khz = 0, supported_rate_khz = 0, mode_bpp = 0;\n\tstruct msm_dp *dp;\n\tint mode_pclk_khz = mode->clock;\n\n\tdp = to_dp_bridge(bridge)->dp_display;\n\n\tif (!dp || !mode_pclk_khz || !dp->connector) {\n\t\tDRM_ERROR(\"invalid params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode->clock > DP_MAX_PIXEL_CLK_KHZ)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tdp_display = container_of(dp, struct dp_display_private, dp_display);\n\tlink_info = &dp_display->panel->link_info;\n\n\tmode_bpp = dp->connector->display_info.bpc * num_components;\n\tif (!mode_bpp)\n\t\tmode_bpp = default_bpp;\n\n\tmode_bpp = dp_panel_get_mode_bpp(dp_display->panel,\n\t\t\tmode_bpp, mode_pclk_khz);\n\n\tmode_rate_khz = mode_pclk_khz * mode_bpp;\n\tsupported_rate_khz = link_info->num_lanes * link_info->rate * 8;\n\n\tif (mode_rate_khz > supported_rate_khz)\n\t\treturn MODE_BAD;\n\n\treturn MODE_OK;\n}\n\nint dp_display_get_modes(struct msm_dp *dp)\n{\n\tstruct dp_display_private *dp_display;\n\n\tif (!dp) {\n\t\tDRM_ERROR(\"invalid params\\n\");\n\t\treturn 0;\n\t}\n\n\tdp_display = container_of(dp, struct dp_display_private, dp_display);\n\n\treturn dp_panel_get_modes(dp_display->panel,\n\t\tdp->connector);\n}\n\nbool dp_display_check_video_test(struct msm_dp *dp)\n{\n\tstruct dp_display_private *dp_display;\n\n\tdp_display = container_of(dp, struct dp_display_private, dp_display);\n\n\treturn dp_display->panel->video_test;\n}\n\nint dp_display_get_test_bpp(struct msm_dp *dp)\n{\n\tstruct dp_display_private *dp_display;\n\n\tif (!dp) {\n\t\tDRM_ERROR(\"invalid params\\n\");\n\t\treturn 0;\n\t}\n\n\tdp_display = container_of(dp, struct dp_display_private, dp_display);\n\n\treturn dp_link_bit_depth_to_bpp(\n\t\tdp_display->link->test_video.test_bit_depth);\n}\n\nvoid msm_dp_snapshot(struct msm_disp_state *disp_state, struct msm_dp *dp)\n{\n\tstruct dp_display_private *dp_display;\n\n\tdp_display = container_of(dp, struct dp_display_private, dp_display);\n\n\t \n\tmutex_lock(&dp_display->event_mutex);\n\n\tif (!dp->power_on) {\n\t\tmutex_unlock(&dp_display->event_mutex);\n\t\treturn;\n\t}\n\n\tdp_catalog_snapshot(dp_display->catalog, disp_state);\n\n\tmutex_unlock(&dp_display->event_mutex);\n}\n\nvoid dp_display_set_psr(struct msm_dp *dp_display, bool enter)\n{\n\tstruct dp_display_private *dp;\n\n\tif (!dp_display) {\n\t\tDRM_ERROR(\"invalid params\\n\");\n\t\treturn;\n\t}\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\tdp_ctrl_set_psr(dp->ctrl, enter);\n}\n\nstatic int hpd_event_thread(void *data)\n{\n\tstruct dp_display_private *dp_priv;\n\tunsigned long flag;\n\tstruct dp_event *todo;\n\tint timeout_mode = 0;\n\n\tdp_priv = (struct dp_display_private *)data;\n\n\twhile (1) {\n\t\tif (timeout_mode) {\n\t\t\twait_event_timeout(dp_priv->event_q,\n\t\t\t\t(dp_priv->event_pndx == dp_priv->event_gndx) ||\n\t\t\t\t\tkthread_should_stop(), EVENT_TIMEOUT);\n\t\t} else {\n\t\t\twait_event_interruptible(dp_priv->event_q,\n\t\t\t\t(dp_priv->event_pndx != dp_priv->event_gndx) ||\n\t\t\t\t\tkthread_should_stop());\n\t\t}\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tspin_lock_irqsave(&dp_priv->event_lock, flag);\n\t\ttodo = &dp_priv->event_list[dp_priv->event_gndx];\n\t\tif (todo->delay) {\n\t\t\tstruct dp_event *todo_next;\n\n\t\t\tdp_priv->event_gndx++;\n\t\t\tdp_priv->event_gndx %= DP_EVENT_Q_MAX;\n\n\t\t\t \n\t\t\ttodo_next = &dp_priv->event_list[dp_priv->event_pndx++];\n\t\t\tdp_priv->event_pndx %= DP_EVENT_Q_MAX;\n\t\t\ttodo_next->event_id = todo->event_id;\n\t\t\ttodo_next->data = todo->data;\n\t\t\ttodo_next->delay = todo->delay - 1;\n\n\t\t\t \n\t\t\ttodo->event_id = EV_NO_EVENT;\n\t\t\ttodo->delay = 0;\n\n\t\t\t \n\t\t\ttimeout_mode = 1;\n\t\t\tspin_unlock_irqrestore(&dp_priv->event_lock, flag);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (dp_priv->event_pndx == dp_priv->event_gndx) {\n\t\t\tspin_unlock_irqrestore(&dp_priv->event_lock, flag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp_priv->event_gndx++;\n\t\tdp_priv->event_gndx %= DP_EVENT_Q_MAX;\n\t\ttimeout_mode = 0;\n\t\tspin_unlock_irqrestore(&dp_priv->event_lock, flag);\n\n\t\tswitch (todo->event_id) {\n\t\tcase EV_HPD_INIT_SETUP:\n\t\t\tdp_display_host_init(dp_priv);\n\t\t\tbreak;\n\t\tcase EV_HPD_PLUG_INT:\n\t\t\tdp_hpd_plug_handle(dp_priv, todo->data);\n\t\t\tbreak;\n\t\tcase EV_HPD_UNPLUG_INT:\n\t\t\tdp_hpd_unplug_handle(dp_priv, todo->data);\n\t\t\tbreak;\n\t\tcase EV_IRQ_HPD_INT:\n\t\t\tdp_irq_hpd_handle(dp_priv, todo->data);\n\t\t\tbreak;\n\t\tcase EV_USER_NOTIFICATION:\n\t\t\tdp_display_send_hpd_notification(dp_priv,\n\t\t\t\t\t\ttodo->data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dp_hpd_event_thread_start(struct dp_display_private *dp_priv)\n{\n\t \n\tdp_priv->event_gndx = 0;\n\tdp_priv->event_pndx = 0;\n\n\tdp_priv->ev_tsk = kthread_run(hpd_event_thread, dp_priv, \"dp_hpd_handler\");\n\tif (IS_ERR(dp_priv->ev_tsk))\n\t\treturn PTR_ERR(dp_priv->ev_tsk);\n\n\treturn 0;\n}\n\nstatic irqreturn_t dp_display_irq_handler(int irq, void *dev_id)\n{\n\tstruct dp_display_private *dp = dev_id;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 hpd_isr_status;\n\n\tif (!dp) {\n\t\tDRM_ERROR(\"invalid data\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\thpd_isr_status = dp_catalog_hpd_get_intr_status(dp->catalog);\n\n\tif (hpd_isr_status & 0x0F) {\n\t\tdrm_dbg_dp(dp->drm_dev, \"type=%d isr=0x%x\\n\",\n\t\t\tdp->dp_display.connector_type, hpd_isr_status);\n\t\t \n\t\tif (hpd_isr_status & DP_DP_HPD_PLUG_INT_MASK)\n\t\t\tdp_add_event(dp, EV_HPD_PLUG_INT, 0, 0);\n\n\t\tif (hpd_isr_status & DP_DP_IRQ_HPD_INT_MASK) {\n\t\t\tdp_add_event(dp, EV_IRQ_HPD_INT, 0, 0);\n\t\t}\n\n\t\tif (hpd_isr_status & DP_DP_HPD_REPLUG_INT_MASK) {\n\t\t\tdp_add_event(dp, EV_HPD_UNPLUG_INT, 0, 0);\n\t\t\tdp_add_event(dp, EV_HPD_PLUG_INT, 0, 3);\n\t\t}\n\n\t\tif (hpd_isr_status & DP_DP_HPD_UNPLUG_INT_MASK)\n\t\t\tdp_add_event(dp, EV_HPD_UNPLUG_INT, 0, 0);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tret |= dp_ctrl_isr(dp->ctrl);\n\n\t \n\tret |= dp_aux_isr(dp->aux);\n\n\treturn ret;\n}\n\nint dp_display_request_irq(struct msm_dp *dp_display)\n{\n\tint rc = 0;\n\tstruct dp_display_private *dp;\n\n\tif (!dp_display) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\tdp->irq = irq_of_parse_and_map(dp->pdev->dev.of_node, 0);\n\tif (!dp->irq) {\n\t\tDRM_ERROR(\"failed to get irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = devm_request_irq(dp_display->drm_dev->dev, dp->irq,\n\t\t\tdp_display_irq_handler,\n\t\t\tIRQF_TRIGGER_HIGH, \"dp_display_isr\", dp);\n\tif (rc < 0) {\n\t\tDRM_ERROR(\"failed to request IRQ%u: %d\\n\",\n\t\t\t\tdp->irq, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct msm_dp_desc *dp_display_get_desc(struct platform_device *pdev)\n{\n\tconst struct msm_dp_desc *descs = of_device_get_match_data(&pdev->dev);\n\tstruct resource *res;\n\tint i;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn NULL;\n\n\tfor (i = 0; i < descs[i].io_start; i++) {\n\t\tif (descs[i].io_start == res->start)\n\t\t\treturn &descs[i];\n\t}\n\n\tdev_err(&pdev->dev, \"unknown displayport instance\\n\");\n\treturn NULL;\n}\n\nstatic int dp_display_probe(struct platform_device *pdev)\n{\n\tint rc = 0;\n\tstruct dp_display_private *dp;\n\tconst struct msm_dp_desc *desc;\n\n\tif (!pdev || !pdev->dev.of_node) {\n\t\tDRM_ERROR(\"pdev not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdp = devm_kzalloc(&pdev->dev, sizeof(*dp), GFP_KERNEL);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tdesc = dp_display_get_desc(pdev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tdp->pdev = pdev;\n\tdp->name = \"drm_dp\";\n\tdp->id = desc->id;\n\tdp->dp_display.connector_type = desc->connector_type;\n\tdp->wide_bus_en = desc->wide_bus_en;\n\tdp->dp_display.is_edp =\n\t\t(dp->dp_display.connector_type == DRM_MODE_CONNECTOR_eDP);\n\n\trc = dp_init_sub_modules(dp);\n\tif (rc) {\n\t\tDRM_ERROR(\"init sub module failed\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\t \n\tmutex_init(&dp->event_mutex);\n\tinit_waitqueue_head(&dp->event_q);\n\tspin_lock_init(&dp->event_lock);\n\n\t \n\tdp->dp_display.dp_audio = dp->audio;\n\n\tinit_completion(&dp->audio_comp);\n\n\tplatform_set_drvdata(pdev, &dp->dp_display);\n\n\trc = component_add(&pdev->dev, &dp_display_comp_ops);\n\tif (rc) {\n\t\tDRM_ERROR(\"component add failed, rc=%d\\n\", rc);\n\t\tdp_display_deinit_sub_modules(dp);\n\t}\n\n\treturn rc;\n}\n\nstatic int dp_display_remove(struct platform_device *pdev)\n{\n\tstruct dp_display_private *dp = dev_get_dp_display_private(&pdev->dev);\n\n\tcomponent_del(&pdev->dev, &dp_display_comp_ops);\n\tdp_display_deinit_sub_modules(dp);\n\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}\n\nstatic int dp_pm_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct msm_dp *dp_display = platform_get_drvdata(pdev);\n\tstruct dp_display_private *dp;\n\tint sink_count = 0;\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\tmutex_lock(&dp->event_mutex);\n\n\tdrm_dbg_dp(dp->drm_dev,\n\t\t\"Before, type=%d core_inited=%d phy_inited=%d power_on=%d\\n\",\n\t\tdp->dp_display.connector_type, dp->core_initialized,\n\t\tdp->phy_initialized, dp_display->power_on);\n\n\t \n\tdp->hpd_state = ST_DISCONNECTED;\n\n\t \n\tdp_display_host_init(dp);\n\n\tif (dp_display->is_edp)\n\t\tdp_catalog_ctrl_hpd_enable(dp->catalog);\n\n\tif (dp_catalog_link_is_connected(dp->catalog)) {\n\t\t \n\t\tdp_display_host_phy_init(dp);\n\t\tdp_link_psm_config(dp->link, &dp->panel->link_info, false);\n\t\tsink_count = drm_dp_read_sink_count(dp->aux);\n\t\tif (sink_count < 0)\n\t\t\tsink_count = 0;\n\n\t\tdp_display_host_phy_exit(dp);\n\t}\n\n\tdp->link->sink_count = sink_count;\n\t \n\tif (dp->link->sink_count) {\n\t\tdp->dp_display.is_connected = true;\n\t} else {\n\t\tdp->dp_display.is_connected = false;\n\t\tdp_display_handle_plugged_change(dp_display, false);\n\t}\n\n\tdrm_dbg_dp(dp->drm_dev,\n\t\t\"After, type=%d sink=%d conn=%d core_init=%d phy_init=%d power=%d\\n\",\n\t\tdp->dp_display.connector_type, dp->link->sink_count,\n\t\tdp->dp_display.is_connected, dp->core_initialized,\n\t\tdp->phy_initialized, dp_display->power_on);\n\n\tmutex_unlock(&dp->event_mutex);\n\n\treturn 0;\n}\n\nstatic int dp_pm_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct msm_dp *dp_display = platform_get_drvdata(pdev);\n\tstruct dp_display_private *dp;\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\tmutex_lock(&dp->event_mutex);\n\n\tdrm_dbg_dp(dp->drm_dev,\n\t\t\"Before, type=%d core_inited=%d  phy_inited=%d power_on=%d\\n\",\n\t\tdp->dp_display.connector_type, dp->core_initialized,\n\t\tdp->phy_initialized, dp_display->power_on);\n\n\t \n\tif (dp_power_clk_status(dp->power, DP_CTRL_PM))\n\t\tdp_ctrl_off_link_stream(dp->ctrl);\n\n\tdp_display_host_phy_exit(dp);\n\n\t \n\tdp_display_host_deinit(dp);\n\n\tdp->hpd_state = ST_SUSPENDED;\n\n\tdrm_dbg_dp(dp->drm_dev,\n\t\t\"After, type=%d core_inited=%d phy_inited=%d power_on=%d\\n\",\n\t\tdp->dp_display.connector_type, dp->core_initialized,\n\t\tdp->phy_initialized, dp_display->power_on);\n\n\tmutex_unlock(&dp->event_mutex);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dp_pm_ops = {\n\t.suspend = dp_pm_suspend,\n\t.resume =  dp_pm_resume,\n};\n\nstatic struct platform_driver dp_display_driver = {\n\t.probe  = dp_display_probe,\n\t.remove = dp_display_remove,\n\t.driver = {\n\t\t.name = \"msm-dp-display\",\n\t\t.of_match_table = dp_dt_match,\n\t\t.suppress_bind_attrs = true,\n\t\t.pm = &dp_pm_ops,\n\t},\n};\n\nint __init msm_dp_register(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&dp_display_driver);\n\tif (ret)\n\t\tDRM_ERROR(\"Dp display driver register failed\");\n\n\treturn ret;\n}\n\nvoid __exit msm_dp_unregister(void)\n{\n\tplatform_driver_unregister(&dp_display_driver);\n}\n\nvoid msm_dp_irq_postinstall(struct msm_dp *dp_display)\n{\n\tstruct dp_display_private *dp;\n\n\tif (!dp_display)\n\t\treturn;\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\tif (!dp_display->is_edp)\n\t\tdp_add_event(dp, EV_HPD_INIT_SETUP, 0, 0);\n}\n\nbool msm_dp_wide_bus_available(const struct msm_dp *dp_display)\n{\n\tstruct dp_display_private *dp;\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\treturn dp->wide_bus_en;\n}\n\nvoid msm_dp_debugfs_init(struct msm_dp *dp_display, struct drm_minor *minor)\n{\n\tstruct dp_display_private *dp;\n\tstruct device *dev;\n\tint rc;\n\n\tdp = container_of(dp_display, struct dp_display_private, dp_display);\n\tdev = &dp->pdev->dev;\n\n\tdp->debug = dp_debug_get(dev, dp->panel,\n\t\t\t\t\tdp->link, dp->dp_display.connector,\n\t\t\t\t\tminor);\n\tif (IS_ERR(dp->debug)) {\n\t\trc = PTR_ERR(dp->debug);\n\t\tDRM_ERROR(\"failed to initialize debug, rc = %d\\n\", rc);\n\t\tdp->debug = NULL;\n\t}\n}\n\nstatic int dp_display_get_next_bridge(struct msm_dp *dp)\n{\n\tint rc;\n\tstruct dp_display_private *dp_priv;\n\tstruct device_node *aux_bus;\n\tstruct device *dev;\n\n\tdp_priv = container_of(dp, struct dp_display_private, dp_display);\n\tdev = &dp_priv->pdev->dev;\n\taux_bus = of_get_child_by_name(dev->of_node, \"aux-bus\");\n\n\tif (aux_bus && dp->is_edp) {\n\t\tdp_display_host_init(dp_priv);\n\t\tdp_catalog_ctrl_hpd_enable(dp_priv->catalog);\n\t\tdp_display_host_phy_init(dp_priv);\n\n\t\t \n\t\trc = of_dp_aux_populate_bus(dp_priv->aux, NULL);\n\t\tof_node_put(aux_bus);\n\t\tif (rc)\n\t\t\tgoto error;\n\t} else if (dp->is_edp) {\n\t\tDRM_ERROR(\"eDP aux_bus not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\trc = devm_dp_parser_find_next_bridge(dp->drm_dev->dev, dp_priv->parser);\n\tif (!dp->is_edp && rc == -ENODEV)\n\t\treturn 0;\n\n\tif (!rc) {\n\t\tdp->next_bridge = dp_priv->parser->next_bridge;\n\t\treturn 0;\n\t}\n\nerror:\n\tif (dp->is_edp) {\n\t\tof_dp_aux_depopulate_bus(dp_priv->aux);\n\t\tdp_display_host_phy_exit(dp_priv);\n\t\tdp_display_host_deinit(dp_priv);\n\t}\n\treturn rc;\n}\n\nint msm_dp_modeset_init(struct msm_dp *dp_display, struct drm_device *dev,\n\t\t\tstruct drm_encoder *encoder)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct dp_display_private *dp_priv;\n\tint ret;\n\n\tdp_display->drm_dev = dev;\n\n\tdp_priv = container_of(dp_display, struct dp_display_private, dp_display);\n\n\tret = dp_display_request_irq(dp_display);\n\tif (ret) {\n\t\tDRM_ERROR(\"request_irq failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = dp_display_get_next_bridge(dp_display);\n\tif (ret)\n\t\treturn ret;\n\n\tdp_display->bridge = dp_bridge_init(dp_display, dev, encoder);\n\tif (IS_ERR(dp_display->bridge)) {\n\t\tret = PTR_ERR(dp_display->bridge);\n\t\tDRM_DEV_ERROR(dev->dev,\n\t\t\t\"failed to create dp bridge: %d\\n\", ret);\n\t\tdp_display->bridge = NULL;\n\t\treturn ret;\n\t}\n\n\tpriv->bridges[priv->num_bridges++] = dp_display->bridge;\n\n\tdp_display->connector = dp_drm_connector_init(dp_display, encoder);\n\tif (IS_ERR(dp_display->connector)) {\n\t\tret = PTR_ERR(dp_display->connector);\n\t\tDRM_DEV_ERROR(dev->dev,\n\t\t\t\"failed to create dp connector: %d\\n\", ret);\n\t\tdp_display->connector = NULL;\n\t\treturn ret;\n\t}\n\n\tdp_priv->panel->connector = dp_display->connector;\n\n\treturn 0;\n}\n\nvoid dp_bridge_atomic_enable(struct drm_bridge *drm_bridge,\n\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct msm_dp_bridge *dp_bridge = to_dp_bridge(drm_bridge);\n\tstruct msm_dp *dp = dp_bridge->dp_display;\n\tint rc = 0;\n\tstruct dp_display_private *dp_display;\n\tu32 state;\n\tbool force_link_train = false;\n\n\tdp_display = container_of(dp, struct dp_display_private, dp_display);\n\tif (!dp_display->dp_mode.drm_mode.clock) {\n\t\tDRM_ERROR(\"invalid params\\n\");\n\t\treturn;\n\t}\n\n\tif (dp->is_edp)\n\t\tdp_hpd_plug_handle(dp_display, 0);\n\n\tmutex_lock(&dp_display->event_mutex);\n\n\tstate = dp_display->hpd_state;\n\tif (state != ST_DISPLAY_OFF && state != ST_MAINLINK_READY) {\n\t\tmutex_unlock(&dp_display->event_mutex);\n\t\treturn;\n\t}\n\n\trc = dp_display_set_mode(dp, &dp_display->dp_mode);\n\tif (rc) {\n\t\tDRM_ERROR(\"Failed to perform a mode set, rc=%d\\n\", rc);\n\t\tmutex_unlock(&dp_display->event_mutex);\n\t\treturn;\n\t}\n\n\tstate =  dp_display->hpd_state;\n\n\tif (state == ST_DISPLAY_OFF) {\n\t\tdp_display_host_phy_init(dp_display);\n\t\tforce_link_train = true;\n\t}\n\n\tdp_display_enable(dp_display, force_link_train);\n\n\trc = dp_display_post_enable(dp);\n\tif (rc) {\n\t\tDRM_ERROR(\"DP display post enable failed, rc=%d\\n\", rc);\n\t\tdp_display_disable(dp_display);\n\t}\n\n\t \n\tdp_display->hpd_state = ST_CONNECTED;\n\n\tdrm_dbg_dp(dp->drm_dev, \"type=%d Done\\n\", dp->connector_type);\n\tmutex_unlock(&dp_display->event_mutex);\n}\n\nvoid dp_bridge_atomic_disable(struct drm_bridge *drm_bridge,\n\t\t\t      struct drm_bridge_state *old_bridge_state)\n{\n\tstruct msm_dp_bridge *dp_bridge = to_dp_bridge(drm_bridge);\n\tstruct msm_dp *dp = dp_bridge->dp_display;\n\tstruct dp_display_private *dp_display;\n\n\tdp_display = container_of(dp, struct dp_display_private, dp_display);\n\n\tdp_ctrl_push_idle(dp_display->ctrl);\n}\n\nvoid dp_bridge_atomic_post_disable(struct drm_bridge *drm_bridge,\n\t\t\t\t   struct drm_bridge_state *old_bridge_state)\n{\n\tstruct msm_dp_bridge *dp_bridge = to_dp_bridge(drm_bridge);\n\tstruct msm_dp *dp = dp_bridge->dp_display;\n\tu32 state;\n\tstruct dp_display_private *dp_display;\n\n\tdp_display = container_of(dp, struct dp_display_private, dp_display);\n\n\tif (dp->is_edp)\n\t\tdp_hpd_unplug_handle(dp_display, 0);\n\n\tmutex_lock(&dp_display->event_mutex);\n\n\tstate = dp_display->hpd_state;\n\tif (state != ST_DISCONNECT_PENDING && state != ST_CONNECTED) {\n\t\tmutex_unlock(&dp_display->event_mutex);\n\t\treturn;\n\t}\n\n\tdp_display_disable(dp_display);\n\n\tstate =  dp_display->hpd_state;\n\tif (state == ST_DISCONNECT_PENDING) {\n\t\t \n\t\tdp_display->hpd_state = ST_DISCONNECTED;\n\t} else {\n\t\tdp_display->hpd_state = ST_DISPLAY_OFF;\n\t}\n\n\tdrm_dbg_dp(dp->drm_dev, \"type=%d Done\\n\", dp->connector_type);\n\tmutex_unlock(&dp_display->event_mutex);\n}\n\nvoid dp_bridge_mode_set(struct drm_bridge *drm_bridge,\n\t\t\tconst struct drm_display_mode *mode,\n\t\t\tconst struct drm_display_mode *adjusted_mode)\n{\n\tstruct msm_dp_bridge *dp_bridge = to_dp_bridge(drm_bridge);\n\tstruct msm_dp *dp = dp_bridge->dp_display;\n\tstruct dp_display_private *dp_display;\n\n\tdp_display = container_of(dp, struct dp_display_private, dp_display);\n\n\tmemset(&dp_display->dp_mode, 0x0, sizeof(struct dp_display_mode));\n\n\tif (dp_display_check_video_test(dp))\n\t\tdp_display->dp_mode.bpp = dp_display_get_test_bpp(dp);\n\telse  \n\t\tdp_display->dp_mode.bpp = dp->connector->display_info.bpc * 3;\n\n\tif (!dp_display->dp_mode.bpp)\n\t\tdp_display->dp_mode.bpp = 24;  \n\n\tdrm_mode_copy(&dp_display->dp_mode.drm_mode, adjusted_mode);\n\n\tdp_display->dp_mode.v_active_low =\n\t\t!!(dp_display->dp_mode.drm_mode.flags & DRM_MODE_FLAG_NVSYNC);\n\n\tdp_display->dp_mode.h_active_low =\n\t\t!!(dp_display->dp_mode.drm_mode.flags & DRM_MODE_FLAG_NHSYNC);\n}\n\nvoid dp_bridge_hpd_enable(struct drm_bridge *bridge)\n{\n\tstruct msm_dp_bridge *dp_bridge = to_dp_bridge(bridge);\n\tstruct msm_dp *dp_display = dp_bridge->dp_display;\n\tstruct dp_display_private *dp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\tmutex_lock(&dp->event_mutex);\n\tdp_catalog_ctrl_hpd_enable(dp->catalog);\n\n\t \n\tdp_catalog_hpd_config_intr(dp->catalog, DP_DP_HPD_INT_MASK, true);\n\n\tdp_display->internal_hpd = true;\n\tmutex_unlock(&dp->event_mutex);\n}\n\nvoid dp_bridge_hpd_disable(struct drm_bridge *bridge)\n{\n\tstruct msm_dp_bridge *dp_bridge = to_dp_bridge(bridge);\n\tstruct msm_dp *dp_display = dp_bridge->dp_display;\n\tstruct dp_display_private *dp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\tmutex_lock(&dp->event_mutex);\n\t \n\tdp_catalog_hpd_config_intr(dp->catalog, DP_DP_HPD_INT_MASK, false);\n\tdp_catalog_ctrl_hpd_disable(dp->catalog);\n\n\tdp_display->internal_hpd = false;\n\tmutex_unlock(&dp->event_mutex);\n}\n\nvoid dp_bridge_hpd_notify(struct drm_bridge *bridge,\n\t\t\t  enum drm_connector_status status)\n{\n\tstruct msm_dp_bridge *dp_bridge = to_dp_bridge(bridge);\n\tstruct msm_dp *dp_display = dp_bridge->dp_display;\n\tstruct dp_display_private *dp = container_of(dp_display, struct dp_display_private, dp_display);\n\n\t \n\tif (dp_display->internal_hpd)\n\t\treturn;\n\n\tif (!dp->core_initialized) {\n\t\tdrm_dbg_dp(dp->drm_dev, \"not initialized\\n\");\n\t\treturn;\n\t}\n\n\tif (!dp_display->is_connected && status == connector_status_connected)\n\t\tdp_add_event(dp, EV_HPD_PLUG_INT, 0, 0);\n\telse if (dp_display->is_connected && status == connector_status_disconnected)\n\t\tdp_add_event(dp, EV_HPD_UNPLUG_INT, 0, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}