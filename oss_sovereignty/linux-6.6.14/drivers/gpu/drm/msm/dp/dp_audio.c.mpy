{
  "module_name": "dp_audio.c",
  "hash_id": "85bbf523ffdbb9389aab9a6a36b4f3f0cf6492bd1a2ff724b06d841013578837",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dp/dp_audio.c",
  "human_readable_source": "\n \n\n\n#define pr_fmt(fmt)\t\"[drm-dp] %s: \" fmt, __func__\n\n#include <linux/platform_device.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_edid.h>\n\n#include \"dp_catalog.h\"\n#include \"dp_audio.h\"\n#include \"dp_panel.h\"\n#include \"dp_display.h\"\n\n#define HEADER_BYTE_2_BIT\t 0\n#define PARITY_BYTE_2_BIT\t 8\n#define HEADER_BYTE_1_BIT\t16\n#define PARITY_BYTE_1_BIT\t24\n#define HEADER_BYTE_3_BIT\t16\n#define PARITY_BYTE_3_BIT\t24\n\nstruct dp_audio_private {\n\tstruct platform_device *audio_pdev;\n\tstruct platform_device *pdev;\n\tstruct drm_device *drm_dev;\n\tstruct dp_catalog *catalog;\n\tstruct dp_panel *panel;\n\n\tbool engine_on;\n\tu32 channels;\n\n\tstruct dp_audio dp_audio;\n};\n\nstatic u8 dp_audio_get_g0_value(u8 data)\n{\n\tu8 c[4];\n\tu8 g[4];\n\tu8 ret_data = 0;\n\tu8 i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tc[i] = (data >> i) & 0x01;\n\n\tg[0] = c[3];\n\tg[1] = c[0] ^ c[3];\n\tg[2] = c[1];\n\tg[3] = c[2];\n\n\tfor (i = 0; i < 4; i++)\n\t\tret_data = ((g[i] & 0x01) << i) | ret_data;\n\n\treturn ret_data;\n}\n\nstatic u8 dp_audio_get_g1_value(u8 data)\n{\n\tu8 c[4];\n\tu8 g[4];\n\tu8 ret_data = 0;\n\tu8 i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tc[i] = (data >> i) & 0x01;\n\n\tg[0] = c[0] ^ c[3];\n\tg[1] = c[0] ^ c[1] ^ c[3];\n\tg[2] = c[1] ^ c[2];\n\tg[3] = c[2] ^ c[3];\n\n\tfor (i = 0; i < 4; i++)\n\t\tret_data = ((g[i] & 0x01) << i) | ret_data;\n\n\treturn ret_data;\n}\n\nstatic u8 dp_audio_calculate_parity(u32 data)\n{\n\tu8 x0 = 0;\n\tu8 x1 = 0;\n\tu8 ci = 0;\n\tu8 iData = 0;\n\tu8 i = 0;\n\tu8 parity_byte;\n\tu8 num_byte = (data & 0xFF00) > 0 ? 8 : 2;\n\n\tfor (i = 0; i < num_byte; i++) {\n\t\tiData = (data >> i*4) & 0xF;\n\n\t\tci = iData ^ x1;\n\t\tx1 = x0 ^ dp_audio_get_g1_value(ci);\n\t\tx0 = dp_audio_get_g0_value(ci);\n\t}\n\n\tparity_byte = x1 | (x0 << 4);\n\n\treturn parity_byte;\n}\n\nstatic u32 dp_audio_get_header(struct dp_catalog *catalog,\n\t\tenum dp_catalog_audio_sdp_type sdp,\n\t\tenum dp_catalog_audio_header_type header)\n{\n\tcatalog->sdp_type = sdp;\n\tcatalog->sdp_header = header;\n\tdp_catalog_audio_get_header(catalog);\n\n\treturn catalog->audio_data;\n}\n\nstatic void dp_audio_set_header(struct dp_catalog *catalog,\n\t\tu32 data,\n\t\tenum dp_catalog_audio_sdp_type sdp,\n\t\tenum dp_catalog_audio_header_type header)\n{\n\tcatalog->sdp_type = sdp;\n\tcatalog->sdp_header = header;\n\tcatalog->audio_data = data;\n\tdp_catalog_audio_set_header(catalog);\n}\n\nstatic void dp_audio_stream_sdp(struct dp_audio_private *audio)\n{\n\tstruct dp_catalog *catalog = audio->catalog;\n\tu32 value, new_value;\n\tu8 parity_byte;\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_STREAM, DP_AUDIO_SDP_HEADER_1);\n\n\tnew_value = 0x02;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_1_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_1_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 1: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_STREAM, DP_AUDIO_SDP_HEADER_1);\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_STREAM, DP_AUDIO_SDP_HEADER_2);\n\tnew_value = value;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_2_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_2_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 2: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_STREAM, DP_AUDIO_SDP_HEADER_2);\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_STREAM, DP_AUDIO_SDP_HEADER_3);\n\n\tnew_value = audio->channels - 1;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_3_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_3_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 3: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\tvalue, parity_byte);\n\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_STREAM, DP_AUDIO_SDP_HEADER_3);\n}\n\nstatic void dp_audio_timestamp_sdp(struct dp_audio_private *audio)\n{\n\tstruct dp_catalog *catalog = audio->catalog;\n\tu32 value, new_value;\n\tu8 parity_byte;\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_TIMESTAMP, DP_AUDIO_SDP_HEADER_1);\n\n\tnew_value = 0x1;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_1_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_1_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 1: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_TIMESTAMP, DP_AUDIO_SDP_HEADER_1);\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_TIMESTAMP, DP_AUDIO_SDP_HEADER_2);\n\n\tnew_value = 0x17;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_2_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_2_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 2: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_TIMESTAMP, DP_AUDIO_SDP_HEADER_2);\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_TIMESTAMP, DP_AUDIO_SDP_HEADER_3);\n\n\tnew_value = (0x0 | (0x11 << 2));\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_3_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_3_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 3: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_TIMESTAMP, DP_AUDIO_SDP_HEADER_3);\n}\n\nstatic void dp_audio_infoframe_sdp(struct dp_audio_private *audio)\n{\n\tstruct dp_catalog *catalog = audio->catalog;\n\tu32 value, new_value;\n\tu8 parity_byte;\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_INFOFRAME, DP_AUDIO_SDP_HEADER_1);\n\n\tnew_value = 0x84;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_1_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_1_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 1: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_INFOFRAME, DP_AUDIO_SDP_HEADER_1);\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_INFOFRAME, DP_AUDIO_SDP_HEADER_2);\n\n\tnew_value = 0x1b;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_2_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_2_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 2: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_INFOFRAME, DP_AUDIO_SDP_HEADER_2);\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_INFOFRAME, DP_AUDIO_SDP_HEADER_3);\n\n\tnew_value = (0x0 | (0x11 << 2));\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_3_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_3_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 3: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tnew_value, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_INFOFRAME, DP_AUDIO_SDP_HEADER_3);\n}\n\nstatic void dp_audio_copy_management_sdp(struct dp_audio_private *audio)\n{\n\tstruct dp_catalog *catalog = audio->catalog;\n\tu32 value, new_value;\n\tu8 parity_byte;\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_COPYMANAGEMENT, DP_AUDIO_SDP_HEADER_1);\n\n\tnew_value = 0x05;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_1_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_1_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 1: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_COPYMANAGEMENT, DP_AUDIO_SDP_HEADER_1);\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_COPYMANAGEMENT, DP_AUDIO_SDP_HEADER_2);\n\n\tnew_value = 0x0F;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_2_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_2_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 2: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_COPYMANAGEMENT, DP_AUDIO_SDP_HEADER_2);\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_COPYMANAGEMENT, DP_AUDIO_SDP_HEADER_3);\n\n\tnew_value = 0x0;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_3_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_3_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 3: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_COPYMANAGEMENT, DP_AUDIO_SDP_HEADER_3);\n}\n\nstatic void dp_audio_isrc_sdp(struct dp_audio_private *audio)\n{\n\tstruct dp_catalog *catalog = audio->catalog;\n\tu32 value, new_value;\n\tu8 parity_byte;\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_ISRC, DP_AUDIO_SDP_HEADER_1);\n\n\tnew_value = 0x06;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_1_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_1_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 1: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_ISRC, DP_AUDIO_SDP_HEADER_1);\n\n\t \n\tvalue = dp_audio_get_header(catalog,\n\t\t\tDP_AUDIO_SDP_ISRC, DP_AUDIO_SDP_HEADER_2);\n\n\tnew_value = 0x0F;\n\tparity_byte = dp_audio_calculate_parity(new_value);\n\tvalue |= ((new_value << HEADER_BYTE_2_BIT)\n\t\t\t| (parity_byte << PARITY_BYTE_2_BIT));\n\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\"Header Byte 2: value = 0x%x, parity_byte = 0x%x\\n\",\n\t\t\tvalue, parity_byte);\n\tdp_audio_set_header(catalog, value,\n\t\tDP_AUDIO_SDP_ISRC, DP_AUDIO_SDP_HEADER_2);\n}\n\nstatic void dp_audio_setup_sdp(struct dp_audio_private *audio)\n{\n\tdp_catalog_audio_config_sdp(audio->catalog);\n\n\tdp_audio_stream_sdp(audio);\n\tdp_audio_timestamp_sdp(audio);\n\tdp_audio_infoframe_sdp(audio);\n\tdp_audio_copy_management_sdp(audio);\n\tdp_audio_isrc_sdp(audio);\n}\n\nstatic void dp_audio_setup_acr(struct dp_audio_private *audio)\n{\n\tu32 select = 0;\n\tstruct dp_catalog *catalog = audio->catalog;\n\n\tswitch (audio->dp_audio.bw_code) {\n\tcase DP_LINK_BW_1_62:\n\t\tselect = 0;\n\t\tbreak;\n\tcase DP_LINK_BW_2_7:\n\t\tselect = 1;\n\t\tbreak;\n\tcase DP_LINK_BW_5_4:\n\t\tselect = 2;\n\t\tbreak;\n\tcase DP_LINK_BW_8_1:\n\t\tselect = 3;\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg_dp(audio->drm_dev, \"Unknown link rate\\n\");\n\t\tselect = 0;\n\t\tbreak;\n\t}\n\n\tcatalog->audio_data = select;\n\tdp_catalog_audio_config_acr(catalog);\n}\n\nstatic void dp_audio_safe_to_exit_level(struct dp_audio_private *audio)\n{\n\tstruct dp_catalog *catalog = audio->catalog;\n\tu32 safe_to_exit_level = 0;\n\n\tswitch (audio->dp_audio.lane_count) {\n\tcase 1:\n\t\tsafe_to_exit_level = 14;\n\t\tbreak;\n\tcase 2:\n\t\tsafe_to_exit_level = 8;\n\t\tbreak;\n\tcase 4:\n\t\tsafe_to_exit_level = 5;\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg_dp(audio->drm_dev,\n\t\t\t\t\"setting the default safe_to_exit_level = %u\\n\",\n\t\t\t\tsafe_to_exit_level);\n\t\tsafe_to_exit_level = 14;\n\t\tbreak;\n\t}\n\n\tcatalog->audio_data = safe_to_exit_level;\n\tdp_catalog_audio_sfe_level(catalog);\n}\n\nstatic void dp_audio_enable(struct dp_audio_private *audio, bool enable)\n{\n\tstruct dp_catalog *catalog = audio->catalog;\n\n\tcatalog->audio_data = enable;\n\tdp_catalog_audio_enable(catalog);\n\n\taudio->engine_on = enable;\n}\n\nstatic struct dp_audio_private *dp_audio_get_data(struct platform_device *pdev)\n{\n\tstruct dp_audio *dp_audio;\n\tstruct msm_dp *dp_display;\n\n\tif (!pdev) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tdp_display = platform_get_drvdata(pdev);\n\tif (!dp_display) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tdp_audio = dp_display->dp_audio;\n\n\tif (!dp_audio) {\n\t\tDRM_ERROR(\"invalid dp_audio data\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn container_of(dp_audio, struct dp_audio_private, dp_audio);\n}\n\nstatic int dp_audio_hook_plugged_cb(struct device *dev, void *data,\n\t\thdmi_codec_plugged_cb fn,\n\t\tstruct device *codec_dev)\n{\n\n\tstruct platform_device *pdev;\n\tstruct msm_dp *dp_display;\n\n\tpdev = to_platform_device(dev);\n\tif (!pdev) {\n\t\tpr_err(\"invalid input\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdp_display = platform_get_drvdata(pdev);\n\tif (!dp_display) {\n\t\tpr_err(\"invalid input\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn dp_display_set_plugged_cb(dp_display, fn, codec_dev);\n}\n\nstatic int dp_audio_get_eld(struct device *dev,\n\tvoid *data, uint8_t *buf, size_t len)\n{\n\tstruct platform_device *pdev;\n\tstruct msm_dp *dp_display;\n\n\tpdev = to_platform_device(dev);\n\n\tif (!pdev) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdp_display = platform_get_drvdata(pdev);\n\tif (!dp_display) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmemcpy(buf, dp_display->connector->eld,\n\t\tmin(sizeof(dp_display->connector->eld), len));\n\n\treturn 0;\n}\n\nint dp_audio_hw_params(struct device *dev,\n\tvoid *data,\n\tstruct hdmi_codec_daifmt *daifmt,\n\tstruct hdmi_codec_params *params)\n{\n\tint rc = 0;\n\tstruct dp_audio_private *audio;\n\tstruct platform_device *pdev;\n\tstruct msm_dp *dp_display;\n\n\tpdev = to_platform_device(dev);\n\tdp_display = platform_get_drvdata(pdev);\n\n\t \n\tif (!dp_display->power_on) {\n\t\trc = -EINVAL;\n\t\tgoto end;\n\t}\n\n\taudio = dp_audio_get_data(pdev);\n\tif (IS_ERR(audio)) {\n\t\trc = PTR_ERR(audio);\n\t\tgoto end;\n\t}\n\n\taudio->channels = params->channels;\n\n\tdp_audio_setup_sdp(audio);\n\tdp_audio_setup_acr(audio);\n\tdp_audio_safe_to_exit_level(audio);\n\tdp_audio_enable(audio, true);\n\tdp_display_signal_audio_start(dp_display);\n\tdp_display->audio_enabled = true;\n\nend:\n\treturn rc;\n}\n\nstatic void dp_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct dp_audio_private *audio;\n\tstruct platform_device *pdev;\n\tstruct msm_dp *dp_display;\n\n\tpdev = to_platform_device(dev);\n\tdp_display = platform_get_drvdata(pdev);\n\taudio = dp_audio_get_data(pdev);\n\tif (IS_ERR(audio)) {\n\t\tDRM_ERROR(\"failed to get audio data\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!dp_display->audio_enabled)\n\t\treturn;\n\n\tdp_audio_enable(audio, false);\n\t \n\tdp_display_signal_audio_complete(dp_display);\n}\n\nstatic const struct hdmi_codec_ops dp_audio_codec_ops = {\n\t.hw_params = dp_audio_hw_params,\n\t.audio_shutdown = dp_audio_shutdown,\n\t.get_eld = dp_audio_get_eld,\n\t.hook_plugged_cb = dp_audio_hook_plugged_cb,\n};\n\nstatic struct hdmi_codec_pdata codec_data = {\n\t.ops = &dp_audio_codec_ops,\n\t.max_i2s_channels = 8,\n\t.i2s = 1,\n};\n\nvoid dp_unregister_audio_driver(struct device *dev, struct dp_audio *dp_audio)\n{\n\tstruct dp_audio_private *audio_priv;\n\n\taudio_priv = container_of(dp_audio, struct dp_audio_private, dp_audio);\n\n\tif (audio_priv->audio_pdev) {\n\t\tplatform_device_unregister(audio_priv->audio_pdev);\n\t\taudio_priv->audio_pdev = NULL;\n\t}\n}\n\nint dp_register_audio_driver(struct device *dev,\n\t\tstruct dp_audio *dp_audio)\n{\n\tstruct dp_audio_private *audio_priv;\n\n\taudio_priv = container_of(dp_audio,\n\t\t\tstruct dp_audio_private, dp_audio);\n\n\taudio_priv->audio_pdev = platform_device_register_data(dev,\n\t\t\t\t\t\tHDMI_CODEC_DRV_NAME,\n\t\t\t\t\t\tPLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t&codec_data,\n\t\t\t\t\t\tsizeof(codec_data));\n\treturn PTR_ERR_OR_ZERO(audio_priv->audio_pdev);\n}\n\nstruct dp_audio *dp_audio_get(struct platform_device *pdev,\n\t\t\tstruct dp_panel *panel,\n\t\t\tstruct dp_catalog *catalog)\n{\n\tint rc = 0;\n\tstruct dp_audio_private *audio;\n\tstruct dp_audio *dp_audio;\n\n\tif (!pdev || !panel || !catalog) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\taudio = devm_kzalloc(&pdev->dev, sizeof(*audio), GFP_KERNEL);\n\tif (!audio) {\n\t\trc = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\taudio->pdev = pdev;\n\taudio->panel = panel;\n\taudio->catalog = catalog;\n\n\tdp_audio = &audio->dp_audio;\n\n\tdp_catalog_audio_init(catalog);\n\n\treturn dp_audio;\nerror:\n\treturn ERR_PTR(rc);\n}\n\nvoid dp_audio_put(struct dp_audio *dp_audio)\n{\n\tstruct dp_audio_private *audio;\n\n\tif (!dp_audio)\n\t\treturn;\n\n\taudio = container_of(dp_audio, struct dp_audio_private, dp_audio);\n\n\tdevm_kfree(&audio->pdev->dev, audio);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}