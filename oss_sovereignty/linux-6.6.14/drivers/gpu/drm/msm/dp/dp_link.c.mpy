{
  "module_name": "dp_link.c",
  "hash_id": "d66ddf78468899be68e42c920e778547a452f63f39a4dbcc7840bd5068f05080",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dp/dp_link.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm-dp] %s: \" fmt, __func__\n\n#include <drm/drm_print.h>\n\n#include \"dp_link.h\"\n#include \"dp_panel.h\"\n\n#define DP_TEST_REQUEST_MASK\t\t0x7F\n\nenum audio_sample_rate {\n\tAUDIO_SAMPLE_RATE_32_KHZ\t= 0x00,\n\tAUDIO_SAMPLE_RATE_44_1_KHZ\t= 0x01,\n\tAUDIO_SAMPLE_RATE_48_KHZ\t= 0x02,\n\tAUDIO_SAMPLE_RATE_88_2_KHZ\t= 0x03,\n\tAUDIO_SAMPLE_RATE_96_KHZ\t= 0x04,\n\tAUDIO_SAMPLE_RATE_176_4_KHZ\t= 0x05,\n\tAUDIO_SAMPLE_RATE_192_KHZ\t= 0x06,\n};\n\nenum audio_pattern_type {\n\tAUDIO_TEST_PATTERN_OPERATOR_DEFINED\t= 0x00,\n\tAUDIO_TEST_PATTERN_SAWTOOTH\t\t= 0x01,\n};\n\nstruct dp_link_request {\n\tu32 test_requested;\n\tu32 test_link_rate;\n\tu32 test_lane_count;\n};\n\nstruct dp_link_private {\n\tu32 prev_sink_count;\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\tstruct drm_dp_aux *aux;\n\tstruct dp_link dp_link;\n\n\tstruct dp_link_request request;\n\tstruct mutex psm_mutex;\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n};\n\nstatic int dp_aux_link_power_up(struct drm_dp_aux *aux,\n\t\t\t\t\tstruct dp_link_info *link)\n{\n\tu8 value;\n\tssize_t len;\n\tint i;\n\n\tif (link->revision < 0x11)\n\t\treturn 0;\n\n\tlen = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);\n\tif (len < 0)\n\t\treturn len;\n\n\tvalue &= ~DP_SET_POWER_MASK;\n\tvalue |= DP_SET_POWER_D0;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tlen = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);\n\t\tusleep_range(1000, 2000);\n\t\tif (len == 1)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int dp_aux_link_power_down(struct drm_dp_aux *aux,\n\t\t\t\t\tstruct dp_link_info *link)\n{\n\tu8 value;\n\tint err;\n\n\tif (link->revision < 0x11)\n\t\treturn 0;\n\n\terr = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue &= ~DP_SET_POWER_MASK;\n\tvalue |= DP_SET_POWER_D3;\n\n\terr = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int dp_link_get_period(struct dp_link_private *link, int const addr)\n{\n\tint ret = 0;\n\tu8 data;\n\tu32 const max_audio_period = 0xA;\n\n\t \n\tif (drm_dp_dpcd_readb(link->aux, addr, &data) < 0) {\n\t\tDRM_ERROR(\"failed to read test_audio_period (0x%x)\\n\", addr);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tdata = data & 0xF;\n\tif ((int)data > max_audio_period) {\n\t\tDRM_ERROR(\"invalid test_audio_period_ch_1 = 0x%x\\n\", data);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tret = data;\nexit:\n\treturn ret;\n}\n\nstatic int dp_link_parse_audio_channel_period(struct dp_link_private *link)\n{\n\tint ret = 0;\n\tstruct dp_link_test_audio *req = &link->dp_link.test_audio;\n\n\tret = dp_link_get_period(link, DP_TEST_AUDIO_PERIOD_CH1);\n\tif (ret == -EINVAL)\n\t\tgoto exit;\n\n\treq->test_audio_period_ch_1 = ret;\n\tdrm_dbg_dp(link->drm_dev, \"test_audio_period_ch_1 = 0x%x\\n\", ret);\n\n\tret = dp_link_get_period(link, DP_TEST_AUDIO_PERIOD_CH2);\n\tif (ret == -EINVAL)\n\t\tgoto exit;\n\n\treq->test_audio_period_ch_2 = ret;\n\tdrm_dbg_dp(link->drm_dev, \"test_audio_period_ch_2 = 0x%x\\n\", ret);\n\n\t \n\tret = dp_link_get_period(link, DP_TEST_AUDIO_PERIOD_CH3);\n\tif (ret == -EINVAL)\n\t\tgoto exit;\n\n\treq->test_audio_period_ch_3 = ret;\n\tdrm_dbg_dp(link->drm_dev, \"test_audio_period_ch_3 = 0x%x\\n\", ret);\n\n\tret = dp_link_get_period(link, DP_TEST_AUDIO_PERIOD_CH4);\n\tif (ret == -EINVAL)\n\t\tgoto exit;\n\n\treq->test_audio_period_ch_4 = ret;\n\tdrm_dbg_dp(link->drm_dev, \"test_audio_period_ch_4 = 0x%x\\n\", ret);\n\n\tret = dp_link_get_period(link, DP_TEST_AUDIO_PERIOD_CH5);\n\tif (ret == -EINVAL)\n\t\tgoto exit;\n\n\treq->test_audio_period_ch_5 = ret;\n\tdrm_dbg_dp(link->drm_dev, \"test_audio_period_ch_5 = 0x%x\\n\", ret);\n\n\tret = dp_link_get_period(link, DP_TEST_AUDIO_PERIOD_CH6);\n\tif (ret == -EINVAL)\n\t\tgoto exit;\n\n\treq->test_audio_period_ch_6 = ret;\n\tdrm_dbg_dp(link->drm_dev, \"test_audio_period_ch_6 = 0x%x\\n\", ret);\n\n\tret = dp_link_get_period(link, DP_TEST_AUDIO_PERIOD_CH7);\n\tif (ret == -EINVAL)\n\t\tgoto exit;\n\n\treq->test_audio_period_ch_7 = ret;\n\tdrm_dbg_dp(link->drm_dev, \"test_audio_period_ch_7 = 0x%x\\n\", ret);\n\n\tret = dp_link_get_period(link, DP_TEST_AUDIO_PERIOD_CH8);\n\tif (ret == -EINVAL)\n\t\tgoto exit;\n\n\treq->test_audio_period_ch_8 = ret;\n\tdrm_dbg_dp(link->drm_dev, \"test_audio_period_ch_8 = 0x%x\\n\", ret);\nexit:\n\treturn ret;\n}\n\nstatic int dp_link_parse_audio_pattern_type(struct dp_link_private *link)\n{\n\tint ret = 0;\n\tu8 data;\n\tssize_t rlen;\n\tint const max_audio_pattern_type = 0x1;\n\n\trlen = drm_dp_dpcd_readb(link->aux,\n\t\t\t\tDP_TEST_AUDIO_PATTERN_TYPE, &data);\n\tif (rlen < 0) {\n\t\tDRM_ERROR(\"failed to read link audio mode. rlen=%zd\\n\", rlen);\n\t\treturn rlen;\n\t}\n\n\t \n\tif ((int)data > max_audio_pattern_type) {\n\t\tDRM_ERROR(\"invalid audio pattern type = 0x%x\\n\", data);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tlink->dp_link.test_audio.test_audio_pattern_type = data;\n\tdrm_dbg_dp(link->drm_dev, \"audio pattern type = 0x%x\\n\", data);\nexit:\n\treturn ret;\n}\n\nstatic int dp_link_parse_audio_mode(struct dp_link_private *link)\n{\n\tint ret = 0;\n\tu8 data;\n\tssize_t rlen;\n\tint const max_audio_sampling_rate = 0x6;\n\tint const max_audio_channel_count = 0x8;\n\tint sampling_rate = 0x0;\n\tint channel_count = 0x0;\n\n\trlen = drm_dp_dpcd_readb(link->aux, DP_TEST_AUDIO_MODE, &data);\n\tif (rlen < 0) {\n\t\tDRM_ERROR(\"failed to read link audio mode. rlen=%zd\\n\", rlen);\n\t\treturn rlen;\n\t}\n\n\t \n\tsampling_rate = data & 0xF;\n\tif (sampling_rate > max_audio_sampling_rate) {\n\t\tDRM_ERROR(\"sampling rate (0x%x) greater than max (0x%x)\\n\",\n\t\t\t\tsampling_rate, max_audio_sampling_rate);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tchannel_count = ((data & 0xF0) >> 4) + 1;\n\tif (channel_count > max_audio_channel_count) {\n\t\tDRM_ERROR(\"channel_count (0x%x) greater than max (0x%x)\\n\",\n\t\t\t\tchannel_count, max_audio_channel_count);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tlink->dp_link.test_audio.test_audio_sampling_rate = sampling_rate;\n\tlink->dp_link.test_audio.test_audio_channel_count = channel_count;\n\tdrm_dbg_dp(link->drm_dev,\n\t\t\t\"sampling_rate = 0x%x, channel_count = 0x%x\\n\",\n\t\t\tsampling_rate, channel_count);\nexit:\n\treturn ret;\n}\n\nstatic int dp_link_parse_audio_pattern_params(struct dp_link_private *link)\n{\n\tint ret = 0;\n\n\tret = dp_link_parse_audio_mode(link);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = dp_link_parse_audio_pattern_type(link);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = dp_link_parse_audio_channel_period(link);\n\nexit:\n\treturn ret;\n}\n\nstatic bool dp_link_is_video_pattern_valid(u32 pattern)\n{\n\tswitch (pattern) {\n\tcase DP_NO_TEST_PATTERN:\n\tcase DP_COLOR_RAMP:\n\tcase DP_BLACK_AND_WHITE_VERTICAL_LINES:\n\tcase DP_COLOR_SQUARE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic bool dp_link_is_bit_depth_valid(u32 tbd)\n{\n\t \n\tswitch (tbd) {\n\tcase DP_TEST_BIT_DEPTH_6:\n\tcase DP_TEST_BIT_DEPTH_8:\n\tcase DP_TEST_BIT_DEPTH_10:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int dp_link_parse_timing_params1(struct dp_link_private *link,\n\t\t\t\t\tint addr, int len, u32 *val)\n{\n\tu8 bp[2];\n\tint rlen;\n\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\t \n\trlen = drm_dp_dpcd_read(link->aux, addr, bp, len);\n\tif (rlen < len) {\n\t\tDRM_ERROR(\"failed to read 0x%x\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\t*val = bp[1] | (bp[0] << 8);\n\n\treturn 0;\n}\n\nstatic int dp_link_parse_timing_params2(struct dp_link_private *link,\n\t\t\t\t\tint addr, int len,\n\t\t\t\t\tu32 *val1, u32 *val2)\n{\n\tu8 bp[2];\n\tint rlen;\n\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\t \n\trlen = drm_dp_dpcd_read(link->aux, addr, bp, len);\n\tif (rlen < len) {\n\t\tDRM_ERROR(\"failed to read 0x%x\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\t*val1 = (bp[0] & BIT(7)) >> 7;\n\t*val2 = bp[1] | ((bp[0] & 0x7F) << 8);\n\n\treturn 0;\n}\n\nstatic int dp_link_parse_timing_params3(struct dp_link_private *link,\n\t\t\t\t\tint addr, u32 *val)\n{\n\tu8 bp;\n\tu32 len = 1;\n\tint rlen;\n\n\trlen = drm_dp_dpcd_read(link->aux, addr, &bp, len);\n\tif (rlen < 1) {\n\t\tDRM_ERROR(\"failed to read 0x%x\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\t*val = bp;\n\n\treturn 0;\n}\n\n \nstatic int dp_link_parse_video_pattern_params(struct dp_link_private *link)\n{\n\tint ret = 0;\n\tssize_t rlen;\n\tu8 bp;\n\n\trlen = drm_dp_dpcd_readb(link->aux, DP_TEST_PATTERN, &bp);\n\tif (rlen < 0) {\n\t\tDRM_ERROR(\"failed to read link video pattern. rlen=%zd\\n\",\n\t\t\trlen);\n\t\treturn rlen;\n\t}\n\n\tif (!dp_link_is_video_pattern_valid(bp)) {\n\t\tDRM_ERROR(\"invalid link video pattern = 0x%x\\n\", bp);\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tlink->dp_link.test_video.test_video_pattern = bp;\n\n\t \n\trlen = drm_dp_dpcd_readb(link->aux, DP_TEST_MISC0, &bp);\n\tif (rlen < 0) {\n\t\tDRM_ERROR(\"failed to read link bit depth. rlen=%zd\\n\", rlen);\n\t\treturn rlen;\n\t}\n\n\t \n\tlink->dp_link.test_video.test_dyn_range =\n\t\t\t(bp & DP_TEST_DYNAMIC_RANGE_CEA);\n\n\t \n\tbp &= DP_TEST_BIT_DEPTH_MASK;\n\tif (!dp_link_is_bit_depth_valid(bp)) {\n\t\tDRM_ERROR(\"invalid link bit depth = 0x%x\\n\", bp);\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tlink->dp_link.test_video.test_bit_depth = bp;\n\n\t \n\tret = dp_link_parse_timing_params1(link, DP_TEST_H_TOTAL_HI, 2,\n\t\t\t&link->dp_link.test_video.test_h_total);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to parse test_htotal(DP_TEST_H_TOTAL_HI)\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dp_link_parse_timing_params1(link, DP_TEST_V_TOTAL_HI, 2,\n\t\t\t&link->dp_link.test_video.test_v_total);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to parse test_v_total(DP_TEST_V_TOTAL_HI)\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dp_link_parse_timing_params1(link, DP_TEST_H_START_HI, 2,\n\t\t\t&link->dp_link.test_video.test_h_start);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to parse test_h_start(DP_TEST_H_START_HI)\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dp_link_parse_timing_params1(link, DP_TEST_V_START_HI, 2,\n\t\t\t&link->dp_link.test_video.test_v_start);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to parse test_v_start(DP_TEST_V_START_HI)\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dp_link_parse_timing_params2(link, DP_TEST_HSYNC_HI, 2,\n\t\t\t&link->dp_link.test_video.test_hsync_pol,\n\t\t\t&link->dp_link.test_video.test_hsync_width);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to parse (DP_TEST_HSYNC_HI)\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dp_link_parse_timing_params2(link, DP_TEST_VSYNC_HI, 2,\n\t\t\t&link->dp_link.test_video.test_vsync_pol,\n\t\t\t&link->dp_link.test_video.test_vsync_width);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to parse (DP_TEST_VSYNC_HI)\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dp_link_parse_timing_params1(link, DP_TEST_H_WIDTH_HI, 2,\n\t\t\t&link->dp_link.test_video.test_h_width);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to parse test_h_width(DP_TEST_H_WIDTH_HI)\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dp_link_parse_timing_params1(link, DP_TEST_V_HEIGHT_HI, 2,\n\t\t\t&link->dp_link.test_video.test_v_height);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to parse test_v_height\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dp_link_parse_timing_params3(link, DP_TEST_MISC1,\n\t\t&link->dp_link.test_video.test_rr_d);\n\tlink->dp_link.test_video.test_rr_d &= DP_TEST_REFRESH_DENOMINATOR;\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to parse test_rr_d (DP_TEST_MISC1)\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dp_link_parse_timing_params3(link, DP_TEST_REFRESH_RATE_NUMERATOR,\n\t\t&link->dp_link.test_video.test_rr_n);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to parse test_rr_n\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_dbg_dp(link->drm_dev,\n\t\t\"link video pattern = 0x%x\\n\"\n\t\t\"link dynamic range = 0x%x\\n\"\n\t\t\"link bit depth = 0x%x\\n\"\n\t\t\"TEST_H_TOTAL = %d, TEST_V_TOTAL = %d\\n\"\n\t\t\"TEST_H_START = %d, TEST_V_START = %d\\n\"\n\t\t\"TEST_HSYNC_POL = %d\\n\"\n\t\t\"TEST_HSYNC_WIDTH = %d\\n\"\n\t\t\"TEST_VSYNC_POL = %d\\n\"\n\t\t\"TEST_VSYNC_WIDTH = %d\\n\"\n\t\t\"TEST_H_WIDTH = %d\\n\"\n\t\t\"TEST_V_HEIGHT = %d\\n\"\n\t\t\"TEST_REFRESH_DENOMINATOR = %d\\n\"\n\t\t \"TEST_REFRESH_NUMERATOR = %d\\n\",\n\t\tlink->dp_link.test_video.test_video_pattern,\n\t\tlink->dp_link.test_video.test_dyn_range,\n\t\tlink->dp_link.test_video.test_bit_depth,\n\t\tlink->dp_link.test_video.test_h_total,\n\t\tlink->dp_link.test_video.test_v_total,\n\t\tlink->dp_link.test_video.test_h_start,\n\t\tlink->dp_link.test_video.test_v_start,\n\t\tlink->dp_link.test_video.test_hsync_pol,\n\t\tlink->dp_link.test_video.test_hsync_width,\n\t\tlink->dp_link.test_video.test_vsync_pol,\n\t\tlink->dp_link.test_video.test_vsync_width,\n\t\tlink->dp_link.test_video.test_h_width,\n\t\tlink->dp_link.test_video.test_v_height,\n\t\tlink->dp_link.test_video.test_rr_d,\n\t\tlink->dp_link.test_video.test_rr_n);\n\n\treturn ret;\n}\n\n \nstatic int dp_link_parse_link_training_params(struct dp_link_private *link)\n{\n\tu8 bp;\n\tssize_t rlen;\n\n\trlen = drm_dp_dpcd_readb(link->aux, DP_TEST_LINK_RATE,\t&bp);\n\tif (rlen < 0) {\n\t\tDRM_ERROR(\"failed to read link rate. rlen=%zd\\n\", rlen);\n\t\treturn rlen;\n\t}\n\n\tif (!is_link_rate_valid(bp)) {\n\t\tDRM_ERROR(\"invalid link rate = 0x%x\\n\", bp);\n\t\treturn -EINVAL;\n\t}\n\n\tlink->request.test_link_rate = bp;\n\tdrm_dbg_dp(link->drm_dev, \"link rate = 0x%x\\n\",\n\t\t\t\tlink->request.test_link_rate);\n\n\trlen = drm_dp_dpcd_readb(link->aux, DP_TEST_LANE_COUNT, &bp);\n\tif (rlen < 0) {\n\t\tDRM_ERROR(\"failed to read lane count. rlen=%zd\\n\", rlen);\n\t\treturn rlen;\n\t}\n\tbp &= DP_MAX_LANE_COUNT_MASK;\n\n\tif (!is_lane_count_valid(bp)) {\n\t\tDRM_ERROR(\"invalid lane count = 0x%x\\n\", bp);\n\t\treturn -EINVAL;\n\t}\n\n\tlink->request.test_lane_count = bp;\n\tdrm_dbg_dp(link->drm_dev, \"lane count = 0x%x\\n\",\n\t\t\t\tlink->request.test_lane_count);\n\treturn 0;\n}\n\n \nstatic int dp_link_parse_phy_test_params(struct dp_link_private *link)\n{\n\tu8 data;\n\tssize_t rlen;\n\n\trlen = drm_dp_dpcd_readb(link->aux, DP_PHY_TEST_PATTERN,\n\t\t\t\t\t&data);\n\tif (rlen < 0) {\n\t\tDRM_ERROR(\"failed to read phy link pattern. rlen=%zd\\n\", rlen);\n\t\treturn rlen;\n\t}\n\n\tlink->dp_link.phy_params.phy_test_pattern_sel = data & 0x07;\n\n\tdrm_dbg_dp(link->drm_dev, \"phy_test_pattern_sel = 0x%x\\n\", data);\n\n\tswitch (data) {\n\tcase DP_PHY_TEST_PATTERN_SEL_MASK:\n\tcase DP_PHY_TEST_PATTERN_NONE:\n\tcase DP_PHY_TEST_PATTERN_D10_2:\n\tcase DP_PHY_TEST_PATTERN_ERROR_COUNT:\n\tcase DP_PHY_TEST_PATTERN_PRBS7:\n\tcase DP_PHY_TEST_PATTERN_80BIT_CUSTOM:\n\tcase DP_PHY_TEST_PATTERN_CP2520:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic bool dp_link_is_video_audio_test_requested(u32 link)\n{\n\tu8 video_audio_test = (DP_TEST_LINK_VIDEO_PATTERN |\n\t\t\t\tDP_TEST_LINK_AUDIO_PATTERN |\n\t\t\t\tDP_TEST_LINK_AUDIO_DISABLED_VIDEO);\n\n\treturn ((link & video_audio_test) &&\n\t\t!(link & ~video_audio_test));\n}\n\n \nstatic int dp_link_parse_request(struct dp_link_private *link)\n{\n\tint ret = 0;\n\tu8 data;\n\tssize_t rlen;\n\n\t \n\trlen = drm_dp_dpcd_readb(link->aux,\n\t\t\t\tDP_DEVICE_SERVICE_IRQ_VECTOR, &data);\n\tif (rlen < 0) {\n\t\tDRM_ERROR(\"aux read failed. rlen=%zd\\n\", rlen);\n\t\treturn rlen;\n\t}\n\n\tdrm_dbg_dp(link->drm_dev, \"device service irq vector = 0x%x\\n\", data);\n\n\tif (!(data & DP_AUTOMATED_TEST_REQUEST)) {\n\t\tdrm_dbg_dp(link->drm_dev, \"no test requested\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\trlen = drm_dp_dpcd_readb(link->aux, DP_TEST_REQUEST, &data);\n\tif (rlen < 0) {\n\t\tDRM_ERROR(\"aux read failed. rlen=%zd\\n\", rlen);\n\t\treturn rlen;\n\t}\n\n\tif (!data || (data == DP_TEST_LINK_FAUX_PATTERN)) {\n\t\tdrm_dbg_dp(link->drm_dev, \"link 0x%x not supported\\n\", data);\n\t\tgoto end;\n\t}\n\n\tdrm_dbg_dp(link->drm_dev, \"Test:(0x%x) requested\\n\", data);\n\tlink->request.test_requested = data;\n\tif (link->request.test_requested == DP_TEST_LINK_PHY_TEST_PATTERN) {\n\t\tret = dp_link_parse_phy_test_params(link);\n\t\tif (ret)\n\t\t\tgoto end;\n\t\tret = dp_link_parse_link_training_params(link);\n\t\tif (ret)\n\t\t\tgoto end;\n\t}\n\n\tif (link->request.test_requested == DP_TEST_LINK_TRAINING) {\n\t\tret = dp_link_parse_link_training_params(link);\n\t\tif (ret)\n\t\t\tgoto end;\n\t}\n\n\tif (dp_link_is_video_audio_test_requested(\n\t\t\tlink->request.test_requested)) {\n\t\tret = dp_link_parse_video_pattern_params(link);\n\t\tif (ret)\n\t\t\tgoto end;\n\n\t\tret = dp_link_parse_audio_pattern_params(link);\n\t}\nend:\n\t \n\tif (ret) {\n\t\tlink->dp_link.test_response = DP_TEST_NAK;\n\t} else {\n\t\tif (link->request.test_requested != DP_TEST_LINK_EDID_READ)\n\t\t\tlink->dp_link.test_response = DP_TEST_ACK;\n\t\telse\n\t\t\tlink->dp_link.test_response =\n\t\t\t\tDP_TEST_EDID_CHECKSUM_WRITE;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int dp_link_parse_sink_count(struct dp_link *dp_link)\n{\n\tssize_t rlen;\n\tbool cp_ready;\n\n\tstruct dp_link_private *link = container_of(dp_link,\n\t\t\tstruct dp_link_private, dp_link);\n\n\trlen = drm_dp_dpcd_readb(link->aux, DP_SINK_COUNT,\n\t\t\t\t &link->dp_link.sink_count);\n\tif (rlen < 0) {\n\t\tDRM_ERROR(\"sink count read failed. rlen=%zd\\n\", rlen);\n\t\treturn rlen;\n\t}\n\n\tcp_ready = link->dp_link.sink_count & DP_SINK_CP_READY;\n\n\tlink->dp_link.sink_count =\n\t\tDP_GET_SINK_COUNT(link->dp_link.sink_count);\n\n\tdrm_dbg_dp(link->drm_dev, \"sink_count = 0x%x, cp_ready = 0x%x\\n\",\n\t\t\t\tlink->dp_link.sink_count, cp_ready);\n\treturn 0;\n}\n\nstatic int dp_link_parse_sink_status_field(struct dp_link_private *link)\n{\n\tint len = 0;\n\n\tlink->prev_sink_count = link->dp_link.sink_count;\n\tlen = dp_link_parse_sink_count(&link->dp_link);\n\tif (len < 0) {\n\t\tDRM_ERROR(\"DP parse sink count failed\\n\");\n\t\treturn len;\n\t}\n\n\tlen = drm_dp_dpcd_read_link_status(link->aux,\n\t\tlink->link_status);\n\tif (len < DP_LINK_STATUS_SIZE) {\n\t\tDRM_ERROR(\"DP link status read failed\\n\");\n\t\treturn len;\n\t}\n\n\treturn dp_link_parse_request(link);\n}\n\n \nstatic int dp_link_process_link_training_request(struct dp_link_private *link)\n{\n\tif (link->request.test_requested != DP_TEST_LINK_TRAINING)\n\t\treturn -EINVAL;\n\n\tdrm_dbg_dp(link->drm_dev,\n\t\t\t\"Test:0x%x link rate = 0x%x, lane count = 0x%x\\n\",\n\t\t\tDP_TEST_LINK_TRAINING,\n\t\t\tlink->request.test_link_rate,\n\t\t\tlink->request.test_lane_count);\n\n\tlink->dp_link.link_params.num_lanes = link->request.test_lane_count;\n\tlink->dp_link.link_params.rate =\n\t\tdrm_dp_bw_code_to_link_rate(link->request.test_link_rate);\n\n\treturn 0;\n}\n\nbool dp_link_send_test_response(struct dp_link *dp_link)\n{\n\tstruct dp_link_private *link = NULL;\n\tint ret = 0;\n\n\tif (!dp_link) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn false;\n\t}\n\n\tlink = container_of(dp_link, struct dp_link_private, dp_link);\n\n\tret = drm_dp_dpcd_writeb(link->aux, DP_TEST_RESPONSE,\n\t\t\tdp_link->test_response);\n\n\treturn ret == 1;\n}\n\nint dp_link_psm_config(struct dp_link *dp_link,\n\t\t\t      struct dp_link_info *link_info, bool enable)\n{\n\tstruct dp_link_private *link = NULL;\n\tint ret = 0;\n\n\tif (!dp_link) {\n\t\tDRM_ERROR(\"invalid params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlink = container_of(dp_link, struct dp_link_private, dp_link);\n\n\tmutex_lock(&link->psm_mutex);\n\tif (enable)\n\t\tret = dp_aux_link_power_down(link->aux, link_info);\n\telse\n\t\tret = dp_aux_link_power_up(link->aux, link_info);\n\n\tif (ret)\n\t\tDRM_ERROR(\"Failed to %s low power mode\\n\", enable ?\n\t\t\t\t\t\t\t\"enter\" : \"exit\");\n\telse\n\t\tdp_link->psm_enabled = enable;\n\n\tmutex_unlock(&link->psm_mutex);\n\treturn ret;\n}\n\nbool dp_link_send_edid_checksum(struct dp_link *dp_link, u8 checksum)\n{\n\tstruct dp_link_private *link = NULL;\n\tint ret = 0;\n\n\tif (!dp_link) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn false;\n\t}\n\n\tlink = container_of(dp_link, struct dp_link_private, dp_link);\n\n\tret = drm_dp_dpcd_writeb(link->aux, DP_TEST_EDID_CHECKSUM,\n\t\t\t\t\t\tchecksum);\n\treturn ret == 1;\n}\n\nstatic void dp_link_parse_vx_px(struct dp_link_private *link)\n{\n\tdrm_dbg_dp(link->drm_dev, \"vx: 0=%d, 1=%d, 2=%d, 3=%d\\n\",\n\t\tdrm_dp_get_adjust_request_voltage(link->link_status, 0),\n\t\tdrm_dp_get_adjust_request_voltage(link->link_status, 1),\n\t\tdrm_dp_get_adjust_request_voltage(link->link_status, 2),\n\t\tdrm_dp_get_adjust_request_voltage(link->link_status, 3));\n\n\tdrm_dbg_dp(link->drm_dev, \"px: 0=%d, 1=%d, 2=%d, 3=%d\\n\",\n\t\tdrm_dp_get_adjust_request_pre_emphasis(link->link_status, 0),\n\t\tdrm_dp_get_adjust_request_pre_emphasis(link->link_status, 1),\n\t\tdrm_dp_get_adjust_request_pre_emphasis(link->link_status, 2),\n\t\tdrm_dp_get_adjust_request_pre_emphasis(link->link_status, 3));\n\n\t \n\tdrm_dbg_dp(link->drm_dev,\n\t\t\t \"Current: v_level = 0x%x, p_level = 0x%x\\n\",\n\t\t\tlink->dp_link.phy_params.v_level,\n\t\t\tlink->dp_link.phy_params.p_level);\n\tlink->dp_link.phy_params.v_level =\n\t\tdrm_dp_get_adjust_request_voltage(link->link_status, 0);\n\tlink->dp_link.phy_params.p_level =\n\t\tdrm_dp_get_adjust_request_pre_emphasis(link->link_status, 0);\n\n\tlink->dp_link.phy_params.p_level >>= DP_TRAIN_PRE_EMPHASIS_SHIFT;\n\n\tdrm_dbg_dp(link->drm_dev,\n\t\t\t\"Requested: v_level = 0x%x, p_level = 0x%x\\n\",\n\t\t\tlink->dp_link.phy_params.v_level,\n\t\t\tlink->dp_link.phy_params.p_level);\n}\n\n \nstatic int dp_link_process_phy_test_pattern_request(\n\t\tstruct dp_link_private *link)\n{\n\tif (!(link->request.test_requested & DP_TEST_LINK_PHY_TEST_PATTERN)) {\n\t\tdrm_dbg_dp(link->drm_dev, \"no phy test\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_link_rate_valid(link->request.test_link_rate) ||\n\t\t!is_lane_count_valid(link->request.test_lane_count)) {\n\t\tDRM_ERROR(\"Invalid: link rate = 0x%x,lane count = 0x%x\\n\",\n\t\t\t\tlink->request.test_link_rate,\n\t\t\t\tlink->request.test_lane_count);\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_dbg_dp(link->drm_dev,\n\t\t\t\"Current: rate = 0x%x, lane count = 0x%x\\n\",\n\t\t\tlink->dp_link.link_params.rate,\n\t\t\tlink->dp_link.link_params.num_lanes);\n\n\tdrm_dbg_dp(link->drm_dev,\n\t\t\t\"Requested: rate = 0x%x, lane count = 0x%x\\n\",\n\t\t\tlink->request.test_link_rate,\n\t\t\tlink->request.test_lane_count);\n\n\tlink->dp_link.link_params.num_lanes = link->request.test_lane_count;\n\tlink->dp_link.link_params.rate =\n\t\tdrm_dp_bw_code_to_link_rate(link->request.test_link_rate);\n\n\tdp_link_parse_vx_px(link);\n\n\treturn 0;\n}\n\nstatic bool dp_link_read_psr_error_status(struct dp_link_private *link)\n{\n\tu8 status;\n\n\tdrm_dp_dpcd_read(link->aux, DP_PSR_ERROR_STATUS, &status, 1);\n\n\tif (status & DP_PSR_LINK_CRC_ERROR)\n\t\tDRM_ERROR(\"PSR LINK CRC ERROR\\n\");\n\telse if (status & DP_PSR_RFB_STORAGE_ERROR)\n\t\tDRM_ERROR(\"PSR RFB STORAGE ERROR\\n\");\n\telse if (status & DP_PSR_VSC_SDP_UNCORRECTABLE_ERROR)\n\t\tDRM_ERROR(\"PSR VSC SDP UNCORRECTABLE ERROR\\n\");\n\telse\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool dp_link_psr_capability_changed(struct dp_link_private *link)\n{\n\tu8 status;\n\n\tdrm_dp_dpcd_read(link->aux, DP_PSR_ESI, &status, 1);\n\n\tif (status & DP_PSR_CAPS_CHANGE) {\n\t\tdrm_dbg_dp(link->drm_dev, \"PSR Capability Change\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u8 get_link_status(const u8 link_status[DP_LINK_STATUS_SIZE], int r)\n{\n\treturn link_status[r - DP_LANE0_1_STATUS];\n}\n\n \nstatic int dp_link_process_link_status_update(struct dp_link_private *link)\n{\n\tbool channel_eq_done = drm_dp_channel_eq_ok(link->link_status,\n\t\t\tlink->dp_link.link_params.num_lanes);\n\n\tbool clock_recovery_done = drm_dp_clock_recovery_ok(link->link_status,\n\t\t\tlink->dp_link.link_params.num_lanes);\n\n\tdrm_dbg_dp(link->drm_dev,\n\t\t       \"channel_eq_done = %d, clock_recovery_done = %d\\n\",\n                        channel_eq_done, clock_recovery_done);\n\n\tif (channel_eq_done && clock_recovery_done)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int dp_link_process_ds_port_status_change(struct dp_link_private *link)\n{\n\tif (get_link_status(link->link_status, DP_LANE_ALIGN_STATUS_UPDATED) &\n\t\t\t\t\tDP_DOWNSTREAM_PORT_STATUS_CHANGED)\n\t\tgoto reset;\n\n\tif (link->prev_sink_count == link->dp_link.sink_count)\n\t\treturn -EINVAL;\n\nreset:\n\t \n\tlink->prev_sink_count = link->dp_link.sink_count;\n\n\treturn 0;\n}\n\nstatic bool dp_link_is_video_pattern_requested(struct dp_link_private *link)\n{\n\treturn (link->request.test_requested & DP_TEST_LINK_VIDEO_PATTERN)\n\t\t&& !(link->request.test_requested &\n\t\tDP_TEST_LINK_AUDIO_DISABLED_VIDEO);\n}\n\nstatic bool dp_link_is_audio_pattern_requested(struct dp_link_private *link)\n{\n\treturn (link->request.test_requested & DP_TEST_LINK_AUDIO_PATTERN);\n}\n\nstatic void dp_link_reset_data(struct dp_link_private *link)\n{\n\tlink->request = (const struct dp_link_request){ 0 };\n\tlink->dp_link.test_video = (const struct dp_link_test_video){ 0 };\n\tlink->dp_link.test_video.test_bit_depth = DP_TEST_BIT_DEPTH_UNKNOWN;\n\tlink->dp_link.test_audio = (const struct dp_link_test_audio){ 0 };\n\tlink->dp_link.phy_params.phy_test_pattern_sel = 0;\n\tlink->dp_link.sink_request = 0;\n\tlink->dp_link.test_response = 0;\n}\n\n \nint dp_link_process_request(struct dp_link *dp_link)\n{\n\tint ret = 0;\n\tstruct dp_link_private *link;\n\n\tif (!dp_link) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlink = container_of(dp_link, struct dp_link_private, dp_link);\n\n\tdp_link_reset_data(link);\n\n\tret = dp_link_parse_sink_status_field(link);\n\tif (ret)\n\t\treturn ret;\n\n\tif (link->request.test_requested == DP_TEST_LINK_EDID_READ) {\n\t\tdp_link->sink_request |= DP_TEST_LINK_EDID_READ;\n\t} else if (!dp_link_process_ds_port_status_change(link)) {\n\t\tdp_link->sink_request |= DS_PORT_STATUS_CHANGED;\n\t} else if (!dp_link_process_link_training_request(link)) {\n\t\tdp_link->sink_request |= DP_TEST_LINK_TRAINING;\n\t} else if (!dp_link_process_phy_test_pattern_request(link)) {\n\t\tdp_link->sink_request |= DP_TEST_LINK_PHY_TEST_PATTERN;\n\t} else if (dp_link_read_psr_error_status(link)) {\n\t\tDRM_ERROR(\"PSR IRQ_HPD received\\n\");\n\t} else if (dp_link_psr_capability_changed(link)) {\n\t\tdrm_dbg_dp(link->drm_dev, \"PSR Capability changed\\n\");\n\t} else {\n\t\tret = dp_link_process_link_status_update(link);\n\t\tif (!ret) {\n\t\t\tdp_link->sink_request |= DP_LINK_STATUS_UPDATED;\n\t\t} else {\n\t\t\tif (dp_link_is_video_pattern_requested(link)) {\n\t\t\t\tret = 0;\n\t\t\t\tdp_link->sink_request |= DP_TEST_LINK_VIDEO_PATTERN;\n\t\t\t}\n\t\t\tif (dp_link_is_audio_pattern_requested(link)) {\n\t\t\t\tdp_link->sink_request |= DP_TEST_LINK_AUDIO_PATTERN;\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tdrm_dbg_dp(link->drm_dev, \"sink request=%#x\\n\",\n\t\t\t\tdp_link->sink_request);\n\treturn ret;\n}\n\nint dp_link_get_colorimetry_config(struct dp_link *dp_link)\n{\n\tu32 cc;\n\tstruct dp_link_private *link;\n\n\tif (!dp_link) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlink = container_of(dp_link, struct dp_link_private, dp_link);\n\n\t \n\tif (dp_link_is_video_pattern_requested(link))\n\t\tcc = link->dp_link.test_video.test_dyn_range;\n\telse\n\t\tcc = DP_TEST_DYNAMIC_RANGE_VESA;\n\n\treturn cc;\n}\n\nint dp_link_adjust_levels(struct dp_link *dp_link, u8 *link_status)\n{\n\tint i;\n\tint v_max = 0, p_max = 0;\n\tstruct dp_link_private *link;\n\n\tif (!dp_link) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlink = container_of(dp_link, struct dp_link_private, dp_link);\n\n\t \n\tfor (i = 0; i < dp_link->link_params.num_lanes; i++) {\n\t\tu8 data_v = drm_dp_get_adjust_request_voltage(link_status, i);\n\t\tu8 data_p = drm_dp_get_adjust_request_pre_emphasis(link_status,\n\t\t\t\t\t\t\t\t\t i);\n\t\tdrm_dbg_dp(link->drm_dev,\n\t\t\t\t\"lane=%d req_vol_swing=%d req_pre_emphasis=%d\\n\",\n\t\t\t\ti, data_v, data_p);\n\t\tif (v_max < data_v)\n\t\t\tv_max = data_v;\n\t\tif (p_max < data_p)\n\t\t\tp_max = data_p;\n\t}\n\n\tdp_link->phy_params.v_level = v_max >> DP_TRAIN_VOLTAGE_SWING_SHIFT;\n\tdp_link->phy_params.p_level = p_max >> DP_TRAIN_PRE_EMPHASIS_SHIFT;\n\n\t \n\tif (dp_link->phy_params.v_level > DP_TRAIN_VOLTAGE_SWING_MAX) {\n\t\tdrm_dbg_dp(link->drm_dev,\n\t\t\t\"Requested vSwingLevel=%d, change to %d\\n\",\n\t\t\tdp_link->phy_params.v_level,\n\t\t\tDP_TRAIN_VOLTAGE_SWING_MAX);\n\t\tdp_link->phy_params.v_level = DP_TRAIN_VOLTAGE_SWING_MAX;\n\t}\n\n\tif (dp_link->phy_params.p_level > DP_TRAIN_PRE_EMPHASIS_MAX) {\n\t\tdrm_dbg_dp(link->drm_dev,\n\t\t\t\"Requested preEmphasisLevel=%d, change to %d\\n\",\n\t\t\tdp_link->phy_params.p_level,\n\t\t\tDP_TRAIN_PRE_EMPHASIS_MAX);\n\t\tdp_link->phy_params.p_level = DP_TRAIN_PRE_EMPHASIS_MAX;\n\t}\n\n\tif ((dp_link->phy_params.p_level > DP_TRAIN_PRE_EMPHASIS_LVL_1)\n\t\t&& (dp_link->phy_params.v_level ==\n\t\t\tDP_TRAIN_VOLTAGE_SWING_LVL_2)) {\n\t\tdrm_dbg_dp(link->drm_dev,\n\t\t\t\"Requested preEmphasisLevel=%d, change to %d\\n\",\n\t\t\tdp_link->phy_params.p_level,\n\t\t\tDP_TRAIN_PRE_EMPHASIS_LVL_1);\n\t\tdp_link->phy_params.p_level = DP_TRAIN_PRE_EMPHASIS_LVL_1;\n\t}\n\n\tdrm_dbg_dp(link->drm_dev, \"adjusted: v_level=%d, p_level=%d\\n\",\n\t\tdp_link->phy_params.v_level, dp_link->phy_params.p_level);\n\n\treturn 0;\n}\n\nvoid dp_link_reset_phy_params_vx_px(struct dp_link *dp_link)\n{\n\tdp_link->phy_params.v_level = 0;\n\tdp_link->phy_params.p_level = 0;\n}\n\nu32 dp_link_get_test_bits_depth(struct dp_link *dp_link, u32 bpp)\n{\n\tu32 tbd;\n\n\t \n\tswitch (bpp) {\n\tcase 18:\n\t\ttbd = DP_TEST_BIT_DEPTH_6;\n\t\tbreak;\n\tcase 24:\n\t\ttbd = DP_TEST_BIT_DEPTH_8;\n\t\tbreak;\n\tcase 30:\n\t\ttbd = DP_TEST_BIT_DEPTH_10;\n\t\tbreak;\n\tdefault:\n\t\ttbd = DP_TEST_BIT_DEPTH_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tif (tbd != DP_TEST_BIT_DEPTH_UNKNOWN)\n\t\ttbd = (tbd >> DP_TEST_BIT_DEPTH_SHIFT);\n\n\treturn tbd;\n}\n\nstruct dp_link *dp_link_get(struct device *dev, struct drm_dp_aux *aux)\n{\n\tstruct dp_link_private *link;\n\tstruct dp_link *dp_link;\n\n\tif (!dev || !aux) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = devm_kzalloc(dev, sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlink->dev   = dev;\n\tlink->aux   = aux;\n\n\tmutex_init(&link->psm_mutex);\n\tdp_link = &link->dp_link;\n\n\treturn dp_link;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}