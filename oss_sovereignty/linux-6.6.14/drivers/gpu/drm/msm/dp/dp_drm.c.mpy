{
  "module_name": "dp_drm.c",
  "hash_id": "0502896d6ef90bbd43649247c4fd60c00d74f0685a11470f2cfff20862abd79a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dp/dp_drm.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_crtc.h>\n\n#include \"msm_drv.h\"\n#include \"msm_kms.h\"\n#include \"dp_drm.h\"\n\n \nstatic enum drm_connector_status dp_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct msm_dp *dp;\n\n\tdp = to_dp_bridge(bridge)->dp_display;\n\n\tdrm_dbg_dp(dp->drm_dev, \"is_connected = %s\\n\",\n\t\t(dp->is_connected) ? \"true\" : \"false\");\n\n\treturn (dp->is_connected) ? connector_status_connected :\n\t\t\t\t\tconnector_status_disconnected;\n}\n\nstatic int dp_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t    struct drm_bridge_state *bridge_state,\n\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t    struct drm_connector_state *conn_state)\n{\n\tstruct msm_dp *dp;\n\n\tdp = to_dp_bridge(bridge)->dp_display;\n\n\tdrm_dbg_dp(dp->drm_dev, \"is_connected = %s\\n\",\n\t\t(dp->is_connected) ? \"true\" : \"false\");\n\n\t \n\tif (bridge->ops & DRM_BRIDGE_OP_HPD)\n\t\treturn (dp->is_connected) ? 0 : -ENOTCONN;\n\n\treturn 0;\n}\n\n\n \nstatic int dp_bridge_get_modes(struct drm_bridge *bridge, struct drm_connector *connector)\n{\n\tint rc = 0;\n\tstruct msm_dp *dp;\n\n\tif (!connector)\n\t\treturn 0;\n\n\tdp = to_dp_bridge(bridge)->dp_display;\n\n\t \n\tif (dp->is_connected) {\n\t\trc = dp_display_get_modes(dp);\n\t\tif (rc <= 0) {\n\t\t\tDRM_ERROR(\"failed to get DP sink modes, rc=%d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tdrm_dbg_dp(connector->dev, \"No sink connected\\n\");\n\t}\n\treturn rc;\n}\n\nstatic const struct drm_bridge_funcs dp_bridge_ops = {\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state   = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset           = drm_atomic_helper_bridge_reset,\n\t.atomic_enable          = dp_bridge_atomic_enable,\n\t.atomic_disable         = dp_bridge_atomic_disable,\n\t.atomic_post_disable    = dp_bridge_atomic_post_disable,\n\t.mode_set     = dp_bridge_mode_set,\n\t.mode_valid   = dp_bridge_mode_valid,\n\t.get_modes    = dp_bridge_get_modes,\n\t.detect       = dp_bridge_detect,\n\t.atomic_check = dp_bridge_atomic_check,\n\t.hpd_enable   = dp_bridge_hpd_enable,\n\t.hpd_disable  = dp_bridge_hpd_disable,\n\t.hpd_notify   = dp_bridge_hpd_notify,\n};\n\nstatic int edp_bridge_atomic_check(struct drm_bridge *drm_bridge,\n\t\t\t\t   struct drm_bridge_state *bridge_state,\n\t\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t\t   struct drm_connector_state *conn_state)\n{\n\tstruct msm_dp *dp = to_dp_bridge(drm_bridge)->dp_display;\n\n\tif (WARN_ON(!conn_state))\n\t\treturn -ENODEV;\n\n\tconn_state->self_refresh_aware = dp->psr_supported;\n\n\tif (!conn_state->crtc || !crtc_state)\n\t\treturn 0;\n\n\tif (crtc_state->self_refresh_active && !dp->psr_supported)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void edp_bridge_atomic_enable(struct drm_bridge *drm_bridge,\n\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct drm_atomic_state *atomic_state = old_bridge_state->base.state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\tstruct msm_dp_bridge *dp_bridge = to_dp_bridge(drm_bridge);\n\tstruct msm_dp *dp = dp_bridge->dp_display;\n\n\t \n\tcrtc = drm_atomic_get_new_crtc_for_encoder(atomic_state,\n\t\t\t\t\t\t   drm_bridge->encoder);\n\tif (!crtc)\n\t\treturn;\n\n\told_crtc_state = drm_atomic_get_old_crtc_state(atomic_state, crtc);\n\n\tif (old_crtc_state && old_crtc_state->self_refresh_active) {\n\t\tdp_display_set_psr(dp, false);\n\t\treturn;\n\t}\n\n\tdp_bridge_atomic_enable(drm_bridge, old_bridge_state);\n}\n\nstatic void edp_bridge_atomic_disable(struct drm_bridge *drm_bridge,\n\t\t\t\t      struct drm_bridge_state *old_bridge_state)\n{\n\tstruct drm_atomic_state *atomic_state = old_bridge_state->base.state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state = NULL, *old_crtc_state = NULL;\n\tstruct msm_dp_bridge *dp_bridge = to_dp_bridge(drm_bridge);\n\tstruct msm_dp *dp = dp_bridge->dp_display;\n\n\tcrtc = drm_atomic_get_old_crtc_for_encoder(atomic_state,\n\t\t\t\t\t\t   drm_bridge->encoder);\n\tif (!crtc)\n\t\tgoto out;\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(atomic_state, crtc);\n\tif (!new_crtc_state)\n\t\tgoto out;\n\n\told_crtc_state = drm_atomic_get_old_crtc_state(atomic_state, crtc);\n\tif (!old_crtc_state)\n\t\tgoto out;\n\n\t \n\tif (new_crtc_state->self_refresh_active) {\n\t\tdp_display_set_psr(dp, true);\n\t\treturn;\n\t} else if (old_crtc_state->self_refresh_active) {\n\t\tdp_display_set_psr(dp, false);\n\t\treturn;\n\t}\n\nout:\n\tdp_bridge_atomic_disable(drm_bridge, old_bridge_state);\n}\n\nstatic void edp_bridge_atomic_post_disable(struct drm_bridge *drm_bridge,\n\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct drm_atomic_state *atomic_state = old_bridge_state->base.state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state = NULL;\n\n\tcrtc = drm_atomic_get_old_crtc_for_encoder(atomic_state,\n\t\t\t\t\t\t   drm_bridge->encoder);\n\tif (!crtc)\n\t\treturn;\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(atomic_state, crtc);\n\tif (!new_crtc_state)\n\t\treturn;\n\n\t \n\tif (new_crtc_state->self_refresh_active)\n\t\treturn;\n\n\tdp_bridge_atomic_post_disable(drm_bridge, old_bridge_state);\n}\n\n \nstatic enum drm_mode_status edp_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t\t  const struct drm_display_info *info,\n\t\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tstruct msm_dp *dp;\n\tint mode_pclk_khz = mode->clock;\n\n\tdp = to_dp_bridge(bridge)->dp_display;\n\n\tif (!dp || !mode_pclk_khz || !dp->connector) {\n\t\tDRM_ERROR(\"invalid params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode->clock > DP_MAX_PIXEL_CLK_KHZ)\n\t\treturn MODE_CLOCK_HIGH;\n\n\t \n\treturn MODE_OK;\n}\n\nstatic const struct drm_bridge_funcs edp_bridge_ops = {\n\t.atomic_enable = edp_bridge_atomic_enable,\n\t.atomic_disable = edp_bridge_atomic_disable,\n\t.atomic_post_disable = edp_bridge_atomic_post_disable,\n\t.mode_set = dp_bridge_mode_set,\n\t.mode_valid = edp_bridge_mode_valid,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_check = edp_bridge_atomic_check,\n};\n\nstruct drm_bridge *dp_bridge_init(struct msm_dp *dp_display, struct drm_device *dev,\n\t\t\tstruct drm_encoder *encoder)\n{\n\tint rc;\n\tstruct msm_dp_bridge *dp_bridge;\n\tstruct drm_bridge *bridge;\n\n\tdp_bridge = devm_kzalloc(dev->dev, sizeof(*dp_bridge), GFP_KERNEL);\n\tif (!dp_bridge)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdp_bridge->dp_display = dp_display;\n\n\tbridge = &dp_bridge->bridge;\n\tbridge->funcs = dp_display->is_edp ? &edp_bridge_ops : &dp_bridge_ops;\n\tbridge->type = dp_display->connector_type;\n\n\t \n\tif (!dp_display->is_edp) {\n\t\tbridge->ops =\n\t\t\tDRM_BRIDGE_OP_DETECT |\n\t\t\tDRM_BRIDGE_OP_HPD |\n\t\t\tDRM_BRIDGE_OP_MODES;\n\t}\n\n\tdrm_bridge_add(bridge);\n\n\trc = drm_bridge_attach(encoder, bridge, NULL, DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (rc) {\n\t\tDRM_ERROR(\"failed to attach bridge, rc=%d\\n\", rc);\n\t\tdrm_bridge_remove(bridge);\n\n\t\treturn ERR_PTR(rc);\n\t}\n\n\tif (dp_display->next_bridge) {\n\t\trc = drm_bridge_attach(encoder,\n\t\t\t\t\tdp_display->next_bridge, bridge,\n\t\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\t\tif (rc < 0) {\n\t\t\tDRM_ERROR(\"failed to attach panel bridge: %d\\n\", rc);\n\t\t\tdrm_bridge_remove(bridge);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t}\n\n\treturn bridge;\n}\n\n \nstruct drm_connector *dp_drm_connector_init(struct msm_dp *dp_display, struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector = NULL;\n\n\tconnector = drm_bridge_connector_init(dp_display->drm_dev, encoder);\n\tif (IS_ERR(connector))\n\t\treturn connector;\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\treturn connector;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}