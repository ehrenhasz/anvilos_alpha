{
  "module_name": "dp_catalog.c",
  "hash_id": "68bcea03ffbf07bf872988d01668857e05ebec346773a55a8623aca69f715942",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dp/dp_catalog.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm-dp] %s: \" fmt, __func__\n\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/phy-dp.h>\n#include <linux/rational.h>\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_print.h>\n\n#include \"dp_catalog.h\"\n#include \"dp_reg.h\"\n\n#define POLLING_SLEEP_US\t\t\t1000\n#define POLLING_TIMEOUT_US\t\t\t10000\n\n#define SCRAMBLER_RESET_COUNT_VALUE\t\t0xFC\n\n#define DP_INTERRUPT_STATUS_ACK_SHIFT\t1\n#define DP_INTERRUPT_STATUS_MASK_SHIFT\t2\n\n#define DP_INTF_CONFIG_DATABUS_WIDEN     BIT(4)\n\n#define DP_INTERRUPT_STATUS1 \\\n\t(DP_INTR_AUX_XFER_DONE| \\\n\tDP_INTR_WRONG_ADDR | DP_INTR_TIMEOUT | \\\n\tDP_INTR_NACK_DEFER | DP_INTR_WRONG_DATA_CNT | \\\n\tDP_INTR_I2C_NACK | DP_INTR_I2C_DEFER | \\\n\tDP_INTR_PLL_UNLOCKED | DP_INTR_AUX_ERROR)\n\n#define DP_INTERRUPT_STATUS1_ACK \\\n\t(DP_INTERRUPT_STATUS1 << DP_INTERRUPT_STATUS_ACK_SHIFT)\n#define DP_INTERRUPT_STATUS1_MASK \\\n\t(DP_INTERRUPT_STATUS1 << DP_INTERRUPT_STATUS_MASK_SHIFT)\n\n#define DP_INTERRUPT_STATUS2 \\\n\t(DP_INTR_READY_FOR_VIDEO | DP_INTR_IDLE_PATTERN_SENT | \\\n\tDP_INTR_FRAME_END | DP_INTR_CRC_UPDATED)\n\n#define DP_INTERRUPT_STATUS2_ACK \\\n\t(DP_INTERRUPT_STATUS2 << DP_INTERRUPT_STATUS_ACK_SHIFT)\n#define DP_INTERRUPT_STATUS2_MASK \\\n\t(DP_INTERRUPT_STATUS2 << DP_INTERRUPT_STATUS_MASK_SHIFT)\n\n#define DP_INTERRUPT_STATUS4 \\\n\t(PSR_UPDATE_INT | PSR_CAPTURE_INT | PSR_EXIT_INT | \\\n\tPSR_UPDATE_ERROR_INT | PSR_WAKE_ERROR_INT)\n\n#define DP_INTERRUPT_MASK4 \\\n\t(PSR_UPDATE_MASK | PSR_CAPTURE_MASK | PSR_EXIT_MASK | \\\n\tPSR_UPDATE_ERROR_MASK | PSR_WAKE_ERROR_MASK)\n\nstruct dp_catalog_private {\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\tstruct dp_io *io;\n\tu32 (*audio_map)[DP_AUDIO_SDP_HEADER_MAX];\n\tstruct dp_catalog dp_catalog;\n\tu8 aux_lut_cfg_index[PHY_AUX_CFG_MAX];\n};\n\nvoid dp_catalog_snapshot(struct dp_catalog *dp_catalog, struct msm_disp_state *disp_state)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\tstruct dp_catalog_private, dp_catalog);\n\tstruct dss_io_data *dss = &catalog->io->dp_controller;\n\n\tmsm_disp_snapshot_add_block(disp_state, dss->ahb.len, dss->ahb.base, \"dp_ahb\");\n\tmsm_disp_snapshot_add_block(disp_state, dss->aux.len, dss->aux.base, \"dp_aux\");\n\tmsm_disp_snapshot_add_block(disp_state, dss->link.len, dss->link.base, \"dp_link\");\n\tmsm_disp_snapshot_add_block(disp_state, dss->p0.len, dss->p0.base, \"dp_p0\");\n}\n\nstatic inline u32 dp_read_aux(struct dp_catalog_private *catalog, u32 offset)\n{\n\treturn readl_relaxed(catalog->io->dp_controller.aux.base + offset);\n}\n\nstatic inline void dp_write_aux(struct dp_catalog_private *catalog,\n\t\t\t       u32 offset, u32 data)\n{\n\t \n\twritel(data, catalog->io->dp_controller.aux.base + offset);\n}\n\nstatic inline u32 dp_read_ahb(const struct dp_catalog_private *catalog, u32 offset)\n{\n\treturn readl_relaxed(catalog->io->dp_controller.ahb.base + offset);\n}\n\nstatic inline void dp_write_ahb(struct dp_catalog_private *catalog,\n\t\t\t       u32 offset, u32 data)\n{\n\t \n\twritel(data, catalog->io->dp_controller.ahb.base + offset);\n}\n\nstatic inline void dp_write_p0(struct dp_catalog_private *catalog,\n\t\t\t       u32 offset, u32 data)\n{\n\t \n\twritel(data, catalog->io->dp_controller.p0.base + offset);\n}\n\nstatic inline u32 dp_read_p0(struct dp_catalog_private *catalog,\n\t\t\t       u32 offset)\n{\n\t \n\treturn readl_relaxed(catalog->io->dp_controller.p0.base + offset);\n}\n\nstatic inline u32 dp_read_link(struct dp_catalog_private *catalog, u32 offset)\n{\n\treturn readl_relaxed(catalog->io->dp_controller.link.base + offset);\n}\n\nstatic inline void dp_write_link(struct dp_catalog_private *catalog,\n\t\t\t       u32 offset, u32 data)\n{\n\t \n\twritel(data, catalog->io->dp_controller.link.base + offset);\n}\n\n \nu32 dp_catalog_aux_read_data(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\treturn dp_read_aux(catalog, REG_DP_AUX_DATA);\n}\n\nint dp_catalog_aux_write_data(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tdp_write_aux(catalog, REG_DP_AUX_DATA, dp_catalog->aux_data);\n\treturn 0;\n}\n\nint dp_catalog_aux_write_trans(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tdp_write_aux(catalog, REG_DP_AUX_TRANS_CTRL, dp_catalog->aux_data);\n\treturn 0;\n}\n\nint dp_catalog_aux_clear_trans(struct dp_catalog *dp_catalog, bool read)\n{\n\tu32 data;\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tif (read) {\n\t\tdata = dp_read_aux(catalog, REG_DP_AUX_TRANS_CTRL);\n\t\tdata &= ~DP_AUX_TRANS_CTRL_GO;\n\t\tdp_write_aux(catalog, REG_DP_AUX_TRANS_CTRL, data);\n\t} else {\n\t\tdp_write_aux(catalog, REG_DP_AUX_TRANS_CTRL, 0);\n\t}\n\treturn 0;\n}\n\nint dp_catalog_aux_clear_hw_interrupts(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tdp_read_aux(catalog, REG_DP_PHY_AUX_INTERRUPT_STATUS);\n\tdp_write_aux(catalog, REG_DP_PHY_AUX_INTERRUPT_CLEAR, 0x1f);\n\tdp_write_aux(catalog, REG_DP_PHY_AUX_INTERRUPT_CLEAR, 0x9f);\n\tdp_write_aux(catalog, REG_DP_PHY_AUX_INTERRUPT_CLEAR, 0);\n\treturn 0;\n}\n\n \nvoid dp_catalog_aux_reset(struct dp_catalog *dp_catalog)\n{\n\tu32 aux_ctrl;\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\taux_ctrl = dp_read_aux(catalog, REG_DP_AUX_CTRL);\n\n\taux_ctrl |= DP_AUX_CTRL_RESET;\n\tdp_write_aux(catalog, REG_DP_AUX_CTRL, aux_ctrl);\n\tusleep_range(1000, 1100);  \n\n\taux_ctrl &= ~DP_AUX_CTRL_RESET;\n\tdp_write_aux(catalog, REG_DP_AUX_CTRL, aux_ctrl);\n}\n\nvoid dp_catalog_aux_enable(struct dp_catalog *dp_catalog, bool enable)\n{\n\tu32 aux_ctrl;\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\taux_ctrl = dp_read_aux(catalog, REG_DP_AUX_CTRL);\n\n\tif (enable) {\n\t\tdp_write_aux(catalog, REG_DP_TIMEOUT_COUNT, 0xffff);\n\t\tdp_write_aux(catalog, REG_DP_AUX_LIMITS, 0xffff);\n\t\taux_ctrl |= DP_AUX_CTRL_ENABLE;\n\t} else {\n\t\taux_ctrl &= ~DP_AUX_CTRL_ENABLE;\n\t}\n\n\tdp_write_aux(catalog, REG_DP_AUX_CTRL, aux_ctrl);\n}\n\nvoid dp_catalog_aux_update_cfg(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tstruct dp_io *dp_io = catalog->io;\n\tstruct phy *phy = dp_io->phy;\n\n\tphy_calibrate(phy);\n}\n\nint dp_catalog_aux_wait_for_hpd_connect_state(struct dp_catalog *dp_catalog)\n{\n\tu32 state;\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\t \n\treturn readl_poll_timeout(catalog->io->dp_controller.aux.base +\n\t\t\t\tREG_DP_DP_HPD_INT_STATUS,\n\t\t\t\tstate, state & DP_DP_HPD_STATE_STATUS_CONNECTED,\n\t\t\t\t2000, 500000);\n}\n\nstatic void dump_regs(void __iomem *base, int len)\n{\n\tint i;\n\tu32 x0, x4, x8, xc;\n\tu32 addr_off = 0;\n\n\tlen = DIV_ROUND_UP(len, 16);\n\tfor (i = 0; i < len; i++) {\n\t\tx0 = readl_relaxed(base + addr_off);\n\t\tx4 = readl_relaxed(base + addr_off + 0x04);\n\t\tx8 = readl_relaxed(base + addr_off + 0x08);\n\t\txc = readl_relaxed(base + addr_off + 0x0c);\n\n\t\tpr_info(\"%08x: %08x %08x %08x %08x\", addr_off, x0, x4, x8, xc);\n\t\taddr_off += 16;\n\t}\n}\n\nvoid dp_catalog_dump_regs(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\tstruct dp_catalog_private, dp_catalog);\n\tstruct dss_io_data *io = &catalog->io->dp_controller;\n\n\tpr_info(\"AHB regs\\n\");\n\tdump_regs(io->ahb.base, io->ahb.len);\n\n\tpr_info(\"AUXCLK regs\\n\");\n\tdump_regs(io->aux.base, io->aux.len);\n\n\tpr_info(\"LCLK regs\\n\");\n\tdump_regs(io->link.base, io->link.len);\n\n\tpr_info(\"P0CLK regs\\n\");\n\tdump_regs(io->p0.base, io->p0.len);\n}\n\nu32 dp_catalog_aux_get_irq(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tu32 intr, intr_ack;\n\n\tintr = dp_read_ahb(catalog, REG_DP_INTR_STATUS);\n\tintr &= ~DP_INTERRUPT_STATUS1_MASK;\n\tintr_ack = (intr & DP_INTERRUPT_STATUS1)\n\t\t\t<< DP_INTERRUPT_STATUS_ACK_SHIFT;\n\tdp_write_ahb(catalog, REG_DP_INTR_STATUS, intr_ack |\n\t\t\tDP_INTERRUPT_STATUS1_MASK);\n\n\treturn intr;\n\n}\n\n \nvoid dp_catalog_ctrl_update_transfer_unit(struct dp_catalog *dp_catalog,\n\t\t\t\tu32 dp_tu, u32 valid_boundary,\n\t\t\t\tu32 valid_boundary2)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tdp_write_link(catalog, REG_DP_VALID_BOUNDARY, valid_boundary);\n\tdp_write_link(catalog, REG_DP_TU, dp_tu);\n\tdp_write_link(catalog, REG_DP_VALID_BOUNDARY_2, valid_boundary2);\n}\n\nvoid dp_catalog_ctrl_state_ctrl(struct dp_catalog *dp_catalog, u32 state)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tdp_write_link(catalog, REG_DP_STATE_CTRL, state);\n}\n\nvoid dp_catalog_ctrl_config_ctrl(struct dp_catalog *dp_catalog, u32 cfg)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tdrm_dbg_dp(catalog->drm_dev, \"DP_CONFIGURATION_CTRL=0x%x\\n\", cfg);\n\n\tdp_write_link(catalog, REG_DP_CONFIGURATION_CTRL, cfg);\n}\n\nvoid dp_catalog_ctrl_lane_mapping(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tu32 ln_0 = 0, ln_1 = 1, ln_2 = 2, ln_3 = 3;  \n\tu32 ln_mapping;\n\n\tln_mapping = ln_0 << LANE0_MAPPING_SHIFT;\n\tln_mapping |= ln_1 << LANE1_MAPPING_SHIFT;\n\tln_mapping |= ln_2 << LANE2_MAPPING_SHIFT;\n\tln_mapping |= ln_3 << LANE3_MAPPING_SHIFT;\n\n\tdp_write_link(catalog, REG_DP_LOGICAL2PHYSICAL_LANE_MAPPING,\n\t\t\tln_mapping);\n}\n\nvoid dp_catalog_ctrl_psr_mainlink_enable(struct dp_catalog *dp_catalog,\n\t\t\t\t\t\tbool enable)\n{\n\tu32 val;\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tval = dp_read_link(catalog, REG_DP_MAINLINK_CTRL);\n\n\tif (enable)\n\t\tval |= DP_MAINLINK_CTRL_ENABLE;\n\telse\n\t\tval &= ~DP_MAINLINK_CTRL_ENABLE;\n\n\tdp_write_link(catalog, REG_DP_MAINLINK_CTRL, val);\n}\n\nvoid dp_catalog_ctrl_mainlink_ctrl(struct dp_catalog *dp_catalog,\n\t\t\t\t\t\tbool enable)\n{\n\tu32 mainlink_ctrl;\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tdrm_dbg_dp(catalog->drm_dev, \"enable=%d\\n\", enable);\n\tif (enable) {\n\t\t \n\t\tmainlink_ctrl = dp_read_link(catalog, REG_DP_MAINLINK_CTRL);\n\n\t\tmainlink_ctrl &= ~(DP_MAINLINK_CTRL_RESET |\n\t\t\t\t\t\tDP_MAINLINK_CTRL_ENABLE);\n\t\tdp_write_link(catalog, REG_DP_MAINLINK_CTRL, mainlink_ctrl);\n\n\t\tmainlink_ctrl |= DP_MAINLINK_CTRL_RESET;\n\t\tdp_write_link(catalog, REG_DP_MAINLINK_CTRL, mainlink_ctrl);\n\n\t\tmainlink_ctrl &= ~DP_MAINLINK_CTRL_RESET;\n\t\tdp_write_link(catalog, REG_DP_MAINLINK_CTRL, mainlink_ctrl);\n\n\t\tmainlink_ctrl |= (DP_MAINLINK_CTRL_ENABLE |\n\t\t\t\t\tDP_MAINLINK_FB_BOUNDARY_SEL);\n\t\tdp_write_link(catalog, REG_DP_MAINLINK_CTRL, mainlink_ctrl);\n\t} else {\n\t\tmainlink_ctrl = dp_read_link(catalog, REG_DP_MAINLINK_CTRL);\n\t\tmainlink_ctrl &= ~DP_MAINLINK_CTRL_ENABLE;\n\t\tdp_write_link(catalog, REG_DP_MAINLINK_CTRL, mainlink_ctrl);\n\t}\n}\n\nvoid dp_catalog_ctrl_config_misc(struct dp_catalog *dp_catalog,\n\t\t\t\t\tu32 colorimetry_cfg,\n\t\t\t\t\tu32 test_bits_depth)\n{\n\tu32 misc_val;\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tmisc_val = dp_read_link(catalog, REG_DP_MISC1_MISC0);\n\n\t \n\tmisc_val &= ~(0x07 << DP_MISC0_TEST_BITS_DEPTH_SHIFT);\n\tmisc_val |= colorimetry_cfg << DP_MISC0_COLORIMETRY_CFG_SHIFT;\n\tmisc_val |= test_bits_depth << DP_MISC0_TEST_BITS_DEPTH_SHIFT;\n\t \n\tmisc_val |= DP_MISC0_SYNCHRONOUS_CLK;\n\n\tdrm_dbg_dp(catalog->drm_dev, \"misc settings = 0x%x\\n\", misc_val);\n\tdp_write_link(catalog, REG_DP_MISC1_MISC0, misc_val);\n}\n\nvoid dp_catalog_ctrl_config_msa(struct dp_catalog *dp_catalog,\n\t\t\t\t\tu32 rate, u32 stream_rate_khz,\n\t\t\t\t\tbool fixed_nvid)\n{\n\tu32 pixel_m, pixel_n;\n\tu32 mvid, nvid, pixel_div = 0, dispcc_input_rate;\n\tu32 const nvid_fixed = DP_LINK_CONSTANT_N_VALUE;\n\tu32 const link_rate_hbr2 = 540000;\n\tu32 const link_rate_hbr3 = 810000;\n\tunsigned long den, num;\n\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tif (rate == link_rate_hbr3)\n\t\tpixel_div = 6;\n\telse if (rate == 162000 || rate == 270000)\n\t\tpixel_div = 2;\n\telse if (rate == link_rate_hbr2)\n\t\tpixel_div = 4;\n\telse\n\t\tDRM_ERROR(\"Invalid pixel mux divider\\n\");\n\n\tdispcc_input_rate = (rate * 10) / pixel_div;\n\n\trational_best_approximation(dispcc_input_rate, stream_rate_khz,\n\t\t\t(unsigned long)(1 << 16) - 1,\n\t\t\t(unsigned long)(1 << 16) - 1, &den, &num);\n\n\tden = ~(den - num);\n\tden = den & 0xFFFF;\n\tpixel_m = num;\n\tpixel_n = den;\n\n\tmvid = (pixel_m & 0xFFFF) * 5;\n\tnvid = (0xFFFF & (~pixel_n)) + (pixel_m & 0xFFFF);\n\n\tif (nvid < nvid_fixed) {\n\t\tu32 temp;\n\n\t\ttemp = (nvid_fixed / nvid) * nvid;\n\t\tmvid = (nvid_fixed / nvid) * mvid;\n\t\tnvid = temp;\n\t}\n\n\tif (link_rate_hbr2 == rate)\n\t\tnvid *= 2;\n\n\tif (link_rate_hbr3 == rate)\n\t\tnvid *= 3;\n\n\tdrm_dbg_dp(catalog->drm_dev, \"mvid=0x%x, nvid=0x%x\\n\", mvid, nvid);\n\tdp_write_link(catalog, REG_DP_SOFTWARE_MVID, mvid);\n\tdp_write_link(catalog, REG_DP_SOFTWARE_NVID, nvid);\n\tdp_write_p0(catalog, MMSS_DP_DSC_DTO, 0x0);\n}\n\nint dp_catalog_ctrl_set_pattern_state_bit(struct dp_catalog *dp_catalog,\n\t\t\t\t\tu32 state_bit)\n{\n\tint bit, ret;\n\tu32 data;\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tbit = BIT(state_bit - 1);\n\tdrm_dbg_dp(catalog->drm_dev, \"hw: bit=%d train=%d\\n\", bit, state_bit);\n\tdp_catalog_ctrl_state_ctrl(dp_catalog, bit);\n\n\tbit = BIT(state_bit - 1) << DP_MAINLINK_READY_LINK_TRAINING_SHIFT;\n\n\t \n\tret = readx_poll_timeout(readl, catalog->io->dp_controller.link.base +\n\t\t\t\t\tREG_DP_MAINLINK_READY,\n\t\t\t\t\tdata, data & bit,\n\t\t\t\t\tPOLLING_SLEEP_US, POLLING_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"set state_bit for link_train=%d failed\\n\", state_bit);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nu32 dp_catalog_hw_revision(const struct dp_catalog *dp_catalog)\n{\n\tconst struct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\treturn dp_read_ahb(catalog, REG_DP_HW_VERSION);\n}\n\n \nvoid dp_catalog_ctrl_reset(struct dp_catalog *dp_catalog)\n{\n\tu32 sw_reset;\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tsw_reset = dp_read_ahb(catalog, REG_DP_SW_RESET);\n\n\tsw_reset |= DP_SW_RESET;\n\tdp_write_ahb(catalog, REG_DP_SW_RESET, sw_reset);\n\tusleep_range(1000, 1100);  \n\n\tsw_reset &= ~DP_SW_RESET;\n\tdp_write_ahb(catalog, REG_DP_SW_RESET, sw_reset);\n}\n\nbool dp_catalog_ctrl_mainlink_ready(struct dp_catalog *dp_catalog)\n{\n\tu32 data;\n\tint ret;\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\t \n\tret = readl_poll_timeout(catalog->io->dp_controller.link.base +\n\t\t\t\tREG_DP_MAINLINK_READY,\n\t\t\t\tdata, data & DP_MAINLINK_READY_FOR_VIDEO,\n\t\t\t\tPOLLING_SLEEP_US, POLLING_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"mainlink not ready\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid dp_catalog_ctrl_enable_irq(struct dp_catalog *dp_catalog,\n\t\t\t\t\t\tbool enable)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tif (enable) {\n\t\tdp_write_ahb(catalog, REG_DP_INTR_STATUS,\n\t\t\t\tDP_INTERRUPT_STATUS1_MASK);\n\t\tdp_write_ahb(catalog, REG_DP_INTR_STATUS2,\n\t\t\t\tDP_INTERRUPT_STATUS2_MASK);\n\t} else {\n\t\tdp_write_ahb(catalog, REG_DP_INTR_STATUS, 0x00);\n\t\tdp_write_ahb(catalog, REG_DP_INTR_STATUS2, 0x00);\n\t}\n}\n\nvoid dp_catalog_hpd_config_intr(struct dp_catalog *dp_catalog,\n\t\t\tu32 intr_mask, bool en)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tu32 config = dp_read_aux(catalog, REG_DP_DP_HPD_INT_MASK);\n\n\tconfig = (en ? config | intr_mask : config & ~intr_mask);\n\n\tdrm_dbg_dp(catalog->drm_dev, \"intr_mask=%#x config=%#x\\n\",\n\t\t\t\t\tintr_mask, config);\n\tdp_write_aux(catalog, REG_DP_DP_HPD_INT_MASK,\n\t\t\t\tconfig & DP_DP_HPD_INT_MASK);\n}\n\nvoid dp_catalog_ctrl_hpd_enable(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tu32 reftimer = dp_read_aux(catalog, REG_DP_DP_HPD_REFTIMER);\n\n\t \n\treftimer |= DP_DP_HPD_REFTIMER_ENABLE;\n\tdp_write_aux(catalog, REG_DP_DP_HPD_REFTIMER, reftimer);\n\n\t \n\tdp_write_aux(catalog, REG_DP_DP_HPD_CTRL, DP_DP_HPD_CTRL_HPD_EN);\n}\n\nvoid dp_catalog_ctrl_hpd_disable(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tu32 reftimer = dp_read_aux(catalog, REG_DP_DP_HPD_REFTIMER);\n\n\treftimer &= ~DP_DP_HPD_REFTIMER_ENABLE;\n\tdp_write_aux(catalog, REG_DP_DP_HPD_REFTIMER, reftimer);\n\n\tdp_write_aux(catalog, REG_DP_DP_HPD_CTRL, 0);\n}\n\nstatic void dp_catalog_enable_sdp(struct dp_catalog_private *catalog)\n{\n\t \n\tdp_write_link(catalog, MMSS_DP_SDP_CFG3, UPDATE_SDP);\n\tdp_write_link(catalog, MMSS_DP_SDP_CFG3, 0x0);\n}\n\nvoid dp_catalog_ctrl_config_psr(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tu32 config;\n\n\t \n\tconfig = dp_read_link(catalog, REG_PSR_CONFIG);\n\tconfig |= PSR1_SUPPORTED;\n\tdp_write_link(catalog, REG_PSR_CONFIG, config);\n\n\tdp_write_ahb(catalog, REG_DP_INTR_MASK4, DP_INTERRUPT_MASK4);\n\tdp_catalog_enable_sdp(catalog);\n}\n\nvoid dp_catalog_ctrl_set_psr(struct dp_catalog *dp_catalog, bool enter)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\tstruct dp_catalog_private, dp_catalog);\n\tu32 cmd;\n\n\tcmd = dp_read_link(catalog, REG_PSR_CMD);\n\n\tcmd &= ~(PSR_ENTER | PSR_EXIT);\n\n\tif (enter)\n\t\tcmd |= PSR_ENTER;\n\telse\n\t\tcmd |= PSR_EXIT;\n\n\tdp_catalog_enable_sdp(catalog);\n\tdp_write_link(catalog, REG_PSR_CMD, cmd);\n}\n\nu32 dp_catalog_link_is_connected(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tu32 status;\n\n\tstatus = dp_read_aux(catalog, REG_DP_DP_HPD_INT_STATUS);\n\tdrm_dbg_dp(catalog->drm_dev, \"aux status: %#x\\n\", status);\n\tstatus >>= DP_DP_HPD_STATE_STATUS_BITS_SHIFT;\n\tstatus &= DP_DP_HPD_STATE_STATUS_BITS_MASK;\n\n\treturn status;\n}\n\nu32 dp_catalog_hpd_get_intr_status(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tint isr, mask;\n\n\tisr = dp_read_aux(catalog, REG_DP_DP_HPD_INT_STATUS);\n\tdp_write_aux(catalog, REG_DP_DP_HPD_INT_ACK,\n\t\t\t\t (isr & DP_DP_HPD_INT_MASK));\n\tmask = dp_read_aux(catalog, REG_DP_DP_HPD_INT_MASK);\n\n\t \n\treturn isr & (mask | ~DP_DP_HPD_INT_MASK);\n}\n\nu32 dp_catalog_ctrl_read_psr_interrupt_status(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tu32 intr, intr_ack;\n\n\tintr = dp_read_ahb(catalog, REG_DP_INTR_STATUS4);\n\tintr_ack = (intr & DP_INTERRUPT_STATUS4)\n\t\t\t<< DP_INTERRUPT_STATUS_ACK_SHIFT;\n\tdp_write_ahb(catalog, REG_DP_INTR_STATUS4, intr_ack);\n\n\treturn intr;\n}\n\nint dp_catalog_ctrl_get_interrupt(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tu32 intr, intr_ack;\n\n\tintr = dp_read_ahb(catalog, REG_DP_INTR_STATUS2);\n\tintr &= ~DP_INTERRUPT_STATUS2_MASK;\n\tintr_ack = (intr & DP_INTERRUPT_STATUS2)\n\t\t\t<< DP_INTERRUPT_STATUS_ACK_SHIFT;\n\tdp_write_ahb(catalog, REG_DP_INTR_STATUS2,\n\t\t\tintr_ack | DP_INTERRUPT_STATUS2_MASK);\n\n\treturn intr;\n}\n\nvoid dp_catalog_ctrl_phy_reset(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tdp_write_ahb(catalog, REG_DP_PHY_CTRL,\n\t\t\tDP_PHY_CTRL_SW_RESET | DP_PHY_CTRL_SW_RESET_PLL);\n\tusleep_range(1000, 1100);  \n\tdp_write_ahb(catalog, REG_DP_PHY_CTRL, 0x0);\n}\n\nint dp_catalog_ctrl_update_vx_px(struct dp_catalog *dp_catalog,\n\t\tu8 v_level, u8 p_level)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tstruct dp_io *dp_io = catalog->io;\n\tstruct phy *phy = dp_io->phy;\n\tstruct phy_configure_opts_dp *opts_dp = &dp_io->phy_opts.dp;\n\n\t \n\topts_dp->voltage[0] = v_level;\n\topts_dp->pre[0] = p_level;\n\topts_dp->set_voltages = 1;\n\tphy_configure(phy, &dp_io->phy_opts);\n\topts_dp->set_voltages = 0;\n\n\treturn 0;\n}\n\nvoid dp_catalog_ctrl_send_phy_pattern(struct dp_catalog *dp_catalog,\n\t\t\tu32 pattern)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tu32 value = 0x0;\n\n\t \n\tdp_write_link(catalog, REG_DP_STATE_CTRL, 0x0);\n\n\tdrm_dbg_dp(catalog->drm_dev, \"pattern: %#x\\n\", pattern);\n\tswitch (pattern) {\n\tcase DP_PHY_TEST_PATTERN_D10_2:\n\t\tdp_write_link(catalog, REG_DP_STATE_CTRL,\n\t\t\t\tDP_STATE_CTRL_LINK_TRAINING_PATTERN1);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_ERROR_COUNT:\n\t\tvalue &= ~(1 << 16);\n\t\tdp_write_link(catalog, REG_DP_HBR2_COMPLIANCE_SCRAMBLER_RESET,\n\t\t\t\t\tvalue);\n\t\tvalue |= SCRAMBLER_RESET_COUNT_VALUE;\n\t\tdp_write_link(catalog, REG_DP_HBR2_COMPLIANCE_SCRAMBLER_RESET,\n\t\t\t\t\tvalue);\n\t\tdp_write_link(catalog, REG_DP_MAINLINK_LEVELS,\n\t\t\t\t\tDP_MAINLINK_SAFE_TO_EXIT_LEVEL_2);\n\t\tdp_write_link(catalog, REG_DP_STATE_CTRL,\n\t\t\t\t\tDP_STATE_CTRL_LINK_SYMBOL_ERR_MEASURE);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_PRBS7:\n\t\tdp_write_link(catalog, REG_DP_STATE_CTRL,\n\t\t\t\tDP_STATE_CTRL_LINK_PRBS7);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_80BIT_CUSTOM:\n\t\tdp_write_link(catalog, REG_DP_STATE_CTRL,\n\t\t\t\tDP_STATE_CTRL_LINK_TEST_CUSTOM_PATTERN);\n\t\t \n\t\tdp_write_link(catalog, REG_DP_TEST_80BIT_CUSTOM_PATTERN_REG0,\n\t\t\t\t0x3E0F83E0);\n\t\t \n\t\tdp_write_link(catalog, REG_DP_TEST_80BIT_CUSTOM_PATTERN_REG1,\n\t\t\t\t0x0F83E0F8);\n\t\t \n\t\tdp_write_link(catalog, REG_DP_TEST_80BIT_CUSTOM_PATTERN_REG2,\n\t\t\t\t0x0000F83E);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_CP2520:\n\t\tvalue = dp_read_link(catalog, REG_DP_MAINLINK_CTRL);\n\t\tvalue &= ~DP_MAINLINK_CTRL_SW_BYPASS_SCRAMBLER;\n\t\tdp_write_link(catalog, REG_DP_MAINLINK_CTRL, value);\n\n\t\tvalue = DP_HBR2_ERM_PATTERN;\n\t\tdp_write_link(catalog, REG_DP_HBR2_COMPLIANCE_SCRAMBLER_RESET,\n\t\t\t\tvalue);\n\t\tvalue |= SCRAMBLER_RESET_COUNT_VALUE;\n\t\tdp_write_link(catalog, REG_DP_HBR2_COMPLIANCE_SCRAMBLER_RESET,\n\t\t\t\t\tvalue);\n\t\tdp_write_link(catalog, REG_DP_MAINLINK_LEVELS,\n\t\t\t\t\tDP_MAINLINK_SAFE_TO_EXIT_LEVEL_2);\n\t\tdp_write_link(catalog, REG_DP_STATE_CTRL,\n\t\t\t\t\tDP_STATE_CTRL_LINK_SYMBOL_ERR_MEASURE);\n\t\tvalue = dp_read_link(catalog, REG_DP_MAINLINK_CTRL);\n\t\tvalue |= DP_MAINLINK_CTRL_ENABLE;\n\t\tdp_write_link(catalog, REG_DP_MAINLINK_CTRL, value);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_SEL_MASK:\n\t\tdp_write_link(catalog, REG_DP_MAINLINK_CTRL,\n\t\t\t\tDP_MAINLINK_CTRL_ENABLE);\n\t\tdp_write_link(catalog, REG_DP_STATE_CTRL,\n\t\t\t\tDP_STATE_CTRL_LINK_TRAINING_PATTERN4);\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg_dp(catalog->drm_dev,\n\t\t\t\t\"No valid test pattern requested: %#x\\n\", pattern);\n\t\tbreak;\n\t}\n}\n\nu32 dp_catalog_ctrl_read_phy_pattern(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\treturn dp_read_link(catalog, REG_DP_MAINLINK_READY);\n}\n\n \nint dp_catalog_panel_timing_cfg(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tu32 reg;\n\n\tdp_write_link(catalog, REG_DP_TOTAL_HOR_VER,\n\t\t\t\tdp_catalog->total);\n\tdp_write_link(catalog, REG_DP_START_HOR_VER_FROM_SYNC,\n\t\t\t\tdp_catalog->sync_start);\n\tdp_write_link(catalog, REG_DP_HSYNC_VSYNC_WIDTH_POLARITY,\n\t\t\t\tdp_catalog->width_blanking);\n\tdp_write_link(catalog, REG_DP_ACTIVE_HOR_VER, dp_catalog->dp_active);\n\n\treg = dp_read_p0(catalog, MMSS_DP_INTF_CONFIG);\n\n\tif (dp_catalog->wide_bus_en)\n\t\treg |= DP_INTF_CONFIG_DATABUS_WIDEN;\n\telse\n\t\treg &= ~DP_INTF_CONFIG_DATABUS_WIDEN;\n\n\n\tDRM_DEBUG_DP(\"wide_bus_en=%d reg=%#x\\n\", dp_catalog->wide_bus_en, reg);\n\n\tdp_write_p0(catalog, MMSS_DP_INTF_CONFIG, reg);\n\treturn 0;\n}\n\nvoid dp_catalog_panel_tpg_enable(struct dp_catalog *dp_catalog,\n\t\t\t\tstruct drm_display_mode *drm_mode)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\tu32 hsync_period, vsync_period;\n\tu32 display_v_start, display_v_end;\n\tu32 hsync_start_x, hsync_end_x;\n\tu32 v_sync_width;\n\tu32 hsync_ctl;\n\tu32 display_hctl;\n\n\t \n\thsync_period = drm_mode->htotal;\n\tvsync_period = drm_mode->vtotal;\n\n\tdisplay_v_start = ((drm_mode->vtotal - drm_mode->vsync_start) *\n\t\t\t\t\thsync_period);\n\tdisplay_v_end = ((vsync_period - (drm_mode->vsync_start -\n\t\t\t\t\tdrm_mode->vdisplay))\n\t\t\t\t\t* hsync_period) - 1;\n\n\tdisplay_v_start += drm_mode->htotal - drm_mode->hsync_start;\n\tdisplay_v_end -= (drm_mode->hsync_start - drm_mode->hdisplay);\n\n\thsync_start_x = drm_mode->htotal - drm_mode->hsync_start;\n\thsync_end_x = hsync_period - (drm_mode->hsync_start -\n\t\t\t\t\tdrm_mode->hdisplay) - 1;\n\n\tv_sync_width = drm_mode->vsync_end - drm_mode->vsync_start;\n\n\thsync_ctl = (hsync_period << 16) |\n\t\t\t(drm_mode->hsync_end - drm_mode->hsync_start);\n\tdisplay_hctl = (hsync_end_x << 16) | hsync_start_x;\n\n\n\tdp_write_p0(catalog, MMSS_DP_INTF_CONFIG, 0x0);\n\tdp_write_p0(catalog, MMSS_DP_INTF_HSYNC_CTL, hsync_ctl);\n\tdp_write_p0(catalog, MMSS_DP_INTF_VSYNC_PERIOD_F0, vsync_period *\n\t\t\thsync_period);\n\tdp_write_p0(catalog, MMSS_DP_INTF_VSYNC_PULSE_WIDTH_F0, v_sync_width *\n\t\t\thsync_period);\n\tdp_write_p0(catalog, MMSS_DP_INTF_VSYNC_PERIOD_F1, 0);\n\tdp_write_p0(catalog, MMSS_DP_INTF_VSYNC_PULSE_WIDTH_F1, 0);\n\tdp_write_p0(catalog, MMSS_DP_INTF_DISPLAY_HCTL, display_hctl);\n\tdp_write_p0(catalog, MMSS_DP_INTF_ACTIVE_HCTL, 0);\n\tdp_write_p0(catalog, MMSS_INTF_DISPLAY_V_START_F0, display_v_start);\n\tdp_write_p0(catalog, MMSS_DP_INTF_DISPLAY_V_END_F0, display_v_end);\n\tdp_write_p0(catalog, MMSS_INTF_DISPLAY_V_START_F1, 0);\n\tdp_write_p0(catalog, MMSS_DP_INTF_DISPLAY_V_END_F1, 0);\n\tdp_write_p0(catalog, MMSS_DP_INTF_ACTIVE_V_START_F0, 0);\n\tdp_write_p0(catalog, MMSS_DP_INTF_ACTIVE_V_END_F0, 0);\n\tdp_write_p0(catalog, MMSS_DP_INTF_ACTIVE_V_START_F1, 0);\n\tdp_write_p0(catalog, MMSS_DP_INTF_ACTIVE_V_END_F1, 0);\n\tdp_write_p0(catalog, MMSS_DP_INTF_POLARITY_CTL, 0);\n\n\tdp_write_p0(catalog, MMSS_DP_TPG_MAIN_CONTROL,\n\t\t\t\tDP_TPG_CHECKERED_RECT_PATTERN);\n\tdp_write_p0(catalog, MMSS_DP_TPG_VIDEO_CONFIG,\n\t\t\t\tDP_TPG_VIDEO_CONFIG_BPP_8BIT |\n\t\t\t\tDP_TPG_VIDEO_CONFIG_RGB);\n\tdp_write_p0(catalog, MMSS_DP_BIST_ENABLE,\n\t\t\t\tDP_BIST_ENABLE_DPBIST_EN);\n\tdp_write_p0(catalog, MMSS_DP_TIMING_ENGINE_EN,\n\t\t\t\tDP_TIMING_ENGINE_EN_EN);\n\tdrm_dbg_dp(catalog->drm_dev, \"%s: enabled tpg\\n\", __func__);\n}\n\nvoid dp_catalog_panel_tpg_disable(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog = container_of(dp_catalog,\n\t\t\t\tstruct dp_catalog_private, dp_catalog);\n\n\tdp_write_p0(catalog, MMSS_DP_TPG_MAIN_CONTROL, 0x0);\n\tdp_write_p0(catalog, MMSS_DP_BIST_ENABLE, 0x0);\n\tdp_write_p0(catalog, MMSS_DP_TIMING_ENGINE_EN, 0x0);\n}\n\nstruct dp_catalog *dp_catalog_get(struct device *dev, struct dp_io *io)\n{\n\tstruct dp_catalog_private *catalog;\n\n\tif (!io) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcatalog  = devm_kzalloc(dev, sizeof(*catalog), GFP_KERNEL);\n\tif (!catalog)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcatalog->dev = dev;\n\tcatalog->io = io;\n\n\treturn &catalog->dp_catalog;\n}\n\nvoid dp_catalog_audio_get_header(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog;\n\tu32 (*sdp_map)[DP_AUDIO_SDP_HEADER_MAX];\n\tenum dp_catalog_audio_sdp_type sdp;\n\tenum dp_catalog_audio_header_type header;\n\n\tif (!dp_catalog)\n\t\treturn;\n\n\tcatalog = container_of(dp_catalog,\n\t\tstruct dp_catalog_private, dp_catalog);\n\n\tsdp_map = catalog->audio_map;\n\tsdp     = dp_catalog->sdp_type;\n\theader  = dp_catalog->sdp_header;\n\n\tdp_catalog->audio_data = dp_read_link(catalog,\n\t\t\tsdp_map[sdp][header]);\n}\n\nvoid dp_catalog_audio_set_header(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog;\n\tu32 (*sdp_map)[DP_AUDIO_SDP_HEADER_MAX];\n\tenum dp_catalog_audio_sdp_type sdp;\n\tenum dp_catalog_audio_header_type header;\n\tu32 data;\n\n\tif (!dp_catalog)\n\t\treturn;\n\n\tcatalog = container_of(dp_catalog,\n\t\tstruct dp_catalog_private, dp_catalog);\n\n\tsdp_map = catalog->audio_map;\n\tsdp     = dp_catalog->sdp_type;\n\theader  = dp_catalog->sdp_header;\n\tdata    = dp_catalog->audio_data;\n\n\tdp_write_link(catalog, sdp_map[sdp][header], data);\n}\n\nvoid dp_catalog_audio_config_acr(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog;\n\tu32 acr_ctrl, select;\n\n\tif (!dp_catalog)\n\t\treturn;\n\n\tcatalog = container_of(dp_catalog,\n\t\tstruct dp_catalog_private, dp_catalog);\n\n\tselect = dp_catalog->audio_data;\n\tacr_ctrl = select << 4 | BIT(31) | BIT(8) | BIT(14);\n\n\tdrm_dbg_dp(catalog->drm_dev, \"select: %#x, acr_ctrl: %#x\\n\",\n\t\t\t\t\tselect, acr_ctrl);\n\n\tdp_write_link(catalog, MMSS_DP_AUDIO_ACR_CTRL, acr_ctrl);\n}\n\nvoid dp_catalog_audio_enable(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog;\n\tbool enable;\n\tu32 audio_ctrl;\n\n\tif (!dp_catalog)\n\t\treturn;\n\n\tcatalog = container_of(dp_catalog,\n\t\tstruct dp_catalog_private, dp_catalog);\n\n\tenable = !!dp_catalog->audio_data;\n\taudio_ctrl = dp_read_link(catalog, MMSS_DP_AUDIO_CFG);\n\n\tif (enable)\n\t\taudio_ctrl |= BIT(0);\n\telse\n\t\taudio_ctrl &= ~BIT(0);\n\n\tdrm_dbg_dp(catalog->drm_dev, \"dp_audio_cfg = 0x%x\\n\", audio_ctrl);\n\n\tdp_write_link(catalog, MMSS_DP_AUDIO_CFG, audio_ctrl);\n\t \n\twmb();\n}\n\nvoid dp_catalog_audio_config_sdp(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog;\n\tu32 sdp_cfg = 0;\n\tu32 sdp_cfg2 = 0;\n\n\tif (!dp_catalog)\n\t\treturn;\n\n\tcatalog = container_of(dp_catalog,\n\t\tstruct dp_catalog_private, dp_catalog);\n\n\tsdp_cfg = dp_read_link(catalog, MMSS_DP_SDP_CFG);\n\t \n\tsdp_cfg |= BIT(1);\n\t \n\tsdp_cfg |= BIT(2);\n\t \n\tsdp_cfg |= BIT(5);\n\t \n\tsdp_cfg |= BIT(6);\n\t \n\tsdp_cfg |= BIT(20);\n\n\tdrm_dbg_dp(catalog->drm_dev, \"sdp_cfg = 0x%x\\n\", sdp_cfg);\n\n\tdp_write_link(catalog, MMSS_DP_SDP_CFG, sdp_cfg);\n\n\tsdp_cfg2 = dp_read_link(catalog, MMSS_DP_SDP_CFG2);\n\t \n\tsdp_cfg2 &= ~BIT(0);\n\t \n\tsdp_cfg2 &= ~BIT(1);\n\n\tdrm_dbg_dp(catalog->drm_dev, \"sdp_cfg2 = 0x%x\\n\", sdp_cfg2);\n\n\tdp_write_link(catalog, MMSS_DP_SDP_CFG2, sdp_cfg2);\n}\n\nvoid dp_catalog_audio_init(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog;\n\n\tstatic u32 sdp_map[][DP_AUDIO_SDP_HEADER_MAX] = {\n\t\t{\n\t\t\tMMSS_DP_AUDIO_STREAM_0,\n\t\t\tMMSS_DP_AUDIO_STREAM_1,\n\t\t\tMMSS_DP_AUDIO_STREAM_1,\n\t\t},\n\t\t{\n\t\t\tMMSS_DP_AUDIO_TIMESTAMP_0,\n\t\t\tMMSS_DP_AUDIO_TIMESTAMP_1,\n\t\t\tMMSS_DP_AUDIO_TIMESTAMP_1,\n\t\t},\n\t\t{\n\t\t\tMMSS_DP_AUDIO_INFOFRAME_0,\n\t\t\tMMSS_DP_AUDIO_INFOFRAME_1,\n\t\t\tMMSS_DP_AUDIO_INFOFRAME_1,\n\t\t},\n\t\t{\n\t\t\tMMSS_DP_AUDIO_COPYMANAGEMENT_0,\n\t\t\tMMSS_DP_AUDIO_COPYMANAGEMENT_1,\n\t\t\tMMSS_DP_AUDIO_COPYMANAGEMENT_1,\n\t\t},\n\t\t{\n\t\t\tMMSS_DP_AUDIO_ISRC_0,\n\t\t\tMMSS_DP_AUDIO_ISRC_1,\n\t\t\tMMSS_DP_AUDIO_ISRC_1,\n\t\t},\n\t};\n\n\tif (!dp_catalog)\n\t\treturn;\n\n\tcatalog = container_of(dp_catalog,\n\t\tstruct dp_catalog_private, dp_catalog);\n\n\tcatalog->audio_map = sdp_map;\n}\n\nvoid dp_catalog_audio_sfe_level(struct dp_catalog *dp_catalog)\n{\n\tstruct dp_catalog_private *catalog;\n\tu32 mainlink_levels, safe_to_exit_level;\n\n\tif (!dp_catalog)\n\t\treturn;\n\n\tcatalog = container_of(dp_catalog,\n\t\tstruct dp_catalog_private, dp_catalog);\n\n\tsafe_to_exit_level = dp_catalog->audio_data;\n\tmainlink_levels = dp_read_link(catalog, REG_DP_MAINLINK_LEVELS);\n\tmainlink_levels &= 0xFE0;\n\tmainlink_levels |= safe_to_exit_level;\n\n\tdrm_dbg_dp(catalog->drm_dev,\n\t\t\t\"mainlink_level = 0x%x, safe_to_exit_level = 0x%x\\n\",\n\t\t\t mainlink_levels, safe_to_exit_level);\n\n\tdp_write_link(catalog, REG_DP_MAINLINK_LEVELS, mainlink_levels);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}