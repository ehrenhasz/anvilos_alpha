{
  "module_name": "dp_panel.c",
  "hash_id": "3ed5dbf5eb16cea468563ea46f894a595557293b758c9140e52d96dab991df58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dp/dp_panel.c",
  "human_readable_source": "\n \n\n#include \"dp_panel.h\"\n\n#include <drm/drm_connector.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n\nstruct dp_panel_private {\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\tstruct dp_panel dp_panel;\n\tstruct drm_dp_aux *aux;\n\tstruct dp_link *link;\n\tstruct dp_catalog *catalog;\n\tbool panel_on;\n\tbool aux_cfg_update_done;\n};\n\nstatic void dp_panel_read_psr_cap(struct dp_panel_private *panel)\n{\n\tssize_t rlen;\n\tstruct dp_panel *dp_panel;\n\n\tdp_panel = &panel->dp_panel;\n\n\t \n\tif (dp_panel->dpcd[DP_EDP_CONFIGURATION_CAP]) {\n\t\trlen = drm_dp_dpcd_read(panel->aux, DP_PSR_SUPPORT,\n\t\t\t\t&dp_panel->psr_cap, sizeof(dp_panel->psr_cap));\n\t\tif (rlen == sizeof(dp_panel->psr_cap)) {\n\t\t\tdrm_dbg_dp(panel->drm_dev,\n\t\t\t\t\"psr version: 0x%x, psr_cap: 0x%x\\n\",\n\t\t\t\tdp_panel->psr_cap.version,\n\t\t\t\tdp_panel->psr_cap.capabilities);\n\t\t} else\n\t\t\tDRM_ERROR(\"failed to read psr info, rlen=%zd\\n\", rlen);\n\t}\n}\n\nstatic int dp_panel_read_dpcd(struct dp_panel *dp_panel)\n{\n\tint rc = 0;\n\tsize_t len;\n\tssize_t rlen;\n\tstruct dp_panel_private *panel;\n\tstruct dp_link_info *link_info;\n\tu8 *dpcd, major = 0, minor = 0, temp;\n\tu32 offset = DP_DPCD_REV;\n\n\tdpcd = dp_panel->dpcd;\n\n\tpanel = container_of(dp_panel, struct dp_panel_private, dp_panel);\n\tlink_info = &dp_panel->link_info;\n\n\trlen = drm_dp_dpcd_read(panel->aux, offset,\n\t\t\tdpcd, (DP_RECEIVER_CAP_SIZE + 1));\n\tif (rlen < (DP_RECEIVER_CAP_SIZE + 1)) {\n\t\tDRM_ERROR(\"dpcd read failed, rlen=%zd\\n\", rlen);\n\t\tif (rlen == -ETIMEDOUT)\n\t\t\trc = rlen;\n\t\telse\n\t\t\trc = -EINVAL;\n\n\t\tgoto end;\n\t}\n\n\ttemp = dpcd[DP_TRAINING_AUX_RD_INTERVAL];\n\n\t \n\tif (temp & BIT(7)) {\n\t\tdrm_dbg_dp(panel->drm_dev,\n\t\t\t\t\"using EXTENDED_RECEIVER_CAPABILITY_FIELD\\n\");\n\t\toffset = DPRX_EXTENDED_DPCD_FIELD;\n\t}\n\n\trlen = drm_dp_dpcd_read(panel->aux, offset,\n\t\tdpcd, (DP_RECEIVER_CAP_SIZE + 1));\n\tif (rlen < (DP_RECEIVER_CAP_SIZE + 1)) {\n\t\tDRM_ERROR(\"dpcd read failed, rlen=%zd\\n\", rlen);\n\t\tif (rlen == -ETIMEDOUT)\n\t\t\trc = rlen;\n\t\telse\n\t\t\trc = -EINVAL;\n\n\t\tgoto end;\n\t}\n\n\tlink_info->revision = dpcd[DP_DPCD_REV];\n\tmajor = (link_info->revision >> 4) & 0x0f;\n\tminor = link_info->revision & 0x0f;\n\n\tlink_info->rate = drm_dp_bw_code_to_link_rate(dpcd[DP_MAX_LINK_RATE]);\n\tlink_info->num_lanes = dpcd[DP_MAX_LANE_COUNT] & DP_MAX_LANE_COUNT_MASK;\n\n\t \n\tif (link_info->num_lanes > dp_panel->max_dp_lanes)\n\t\tlink_info->num_lanes = dp_panel->max_dp_lanes;\n\n\t \n\tif (link_info->rate > dp_panel->max_dp_link_rate)\n\t\tlink_info->rate = dp_panel->max_dp_link_rate;\n\n\tdrm_dbg_dp(panel->drm_dev, \"version: %d.%d\\n\", major, minor);\n\tdrm_dbg_dp(panel->drm_dev, \"link_rate=%d\\n\", link_info->rate);\n\tdrm_dbg_dp(panel->drm_dev, \"lane_count=%d\\n\", link_info->num_lanes);\n\n\tif (drm_dp_enhanced_frame_cap(dpcd))\n\t\tlink_info->capabilities |= DP_LINK_CAP_ENHANCED_FRAMING;\n\n\tdp_panel->dfp_present = dpcd[DP_DOWNSTREAMPORT_PRESENT];\n\tdp_panel->dfp_present &= DP_DWN_STRM_PORT_PRESENT;\n\n\tif (dp_panel->dfp_present && (dpcd[DP_DPCD_REV] > 0x10)) {\n\t\tdp_panel->ds_port_cnt = dpcd[DP_DOWN_STREAM_PORT_COUNT];\n\t\tdp_panel->ds_port_cnt &= DP_PORT_COUNT_MASK;\n\t\tlen = DP_DOWNSTREAM_PORTS * DP_DOWNSTREAM_CAP_SIZE;\n\n\t\trlen = drm_dp_dpcd_read(panel->aux,\n\t\t\tDP_DOWNSTREAM_PORT_0, dp_panel->ds_cap_info, len);\n\t\tif (rlen < len) {\n\t\t\tDRM_ERROR(\"ds port status failed, rlen=%zd\\n\", rlen);\n\t\t\trc = -EINVAL;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tdp_panel_read_psr_cap(panel);\nend:\n\treturn rc;\n}\n\nstatic u32 dp_panel_get_supported_bpp(struct dp_panel *dp_panel,\n\t\tu32 mode_edid_bpp, u32 mode_pclk_khz)\n{\n\tstruct dp_link_info *link_info;\n\tconst u32 max_supported_bpp = 30, min_supported_bpp = 18;\n\tu32 bpp = 0, data_rate_khz = 0;\n\n\tbpp = min_t(u32, mode_edid_bpp, max_supported_bpp);\n\n\tlink_info = &dp_panel->link_info;\n\tdata_rate_khz = link_info->num_lanes * link_info->rate * 8;\n\n\twhile (bpp > min_supported_bpp) {\n\t\tif (mode_pclk_khz * bpp <= data_rate_khz)\n\t\t\tbreak;\n\t\tbpp -= 6;\n\t}\n\n\treturn bpp;\n}\n\nstatic int dp_panel_update_modes(struct drm_connector *connector,\n\tstruct edid *edid)\n{\n\tint rc = 0;\n\n\tif (edid) {\n\t\trc = drm_connector_update_edid_property(connector, edid);\n\t\tif (rc) {\n\t\t\tDRM_ERROR(\"failed to update edid property %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\trc = drm_add_edid_modes(connector, edid);\n\t\treturn rc;\n\t}\n\n\trc = drm_connector_update_edid_property(connector, NULL);\n\tif (rc)\n\t\tDRM_ERROR(\"failed to update edid property %d\\n\", rc);\n\n\treturn rc;\n}\n\nint dp_panel_read_sink_caps(struct dp_panel *dp_panel,\n\tstruct drm_connector *connector)\n{\n\tint rc = 0, bw_code;\n\tint rlen, count;\n\tstruct dp_panel_private *panel;\n\n\tif (!dp_panel || !connector) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpanel = container_of(dp_panel, struct dp_panel_private, dp_panel);\n\n\trc = dp_panel_read_dpcd(dp_panel);\n\tif (rc) {\n\t\tDRM_ERROR(\"read dpcd failed %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tbw_code = drm_dp_link_rate_to_bw_code(dp_panel->link_info.rate);\n\tif (!is_link_rate_valid(bw_code) ||\n\t\t\t!is_lane_count_valid(dp_panel->link_info.num_lanes) ||\n\t\t\t(bw_code > dp_panel->max_bw_code)) {\n\t\tDRM_ERROR(\"Illegal link rate=%d lane=%d\\n\", dp_panel->link_info.rate,\n\t\t\t\tdp_panel->link_info.num_lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dp_panel->dfp_present) {\n\t\trlen = drm_dp_dpcd_read(panel->aux, DP_SINK_COUNT,\n\t\t\t\t&count, 1);\n\t\tif (rlen == 1) {\n\t\t\tcount = DP_GET_SINK_COUNT(count);\n\t\t\tif (!count) {\n\t\t\t\tDRM_ERROR(\"no downstream ports connected\\n\");\n\t\t\t\tpanel->link->sink_count = 0;\n\t\t\t\trc = -ENOTCONN;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(dp_panel->edid);\n\tdp_panel->edid = NULL;\n\n\tdp_panel->edid = drm_get_edid(connector,\n\t\t\t\t\t      &panel->aux->ddc);\n\tif (!dp_panel->edid) {\n\t\tDRM_ERROR(\"panel edid read failed\\n\");\n\t\t \n\t\tif (!dp_catalog_link_is_connected(panel->catalog)) {\n\t\t\trc = -ETIMEDOUT;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (panel->aux_cfg_update_done) {\n\t\tdrm_dbg_dp(panel->drm_dev,\n\t\t\t\t\"read DPCD with updated AUX config\\n\");\n\t\trc = dp_panel_read_dpcd(dp_panel);\n\t\tbw_code = drm_dp_link_rate_to_bw_code(dp_panel->link_info.rate);\n\t\tif (rc || !is_link_rate_valid(bw_code) ||\n\t\t\t!is_lane_count_valid(dp_panel->link_info.num_lanes)\n\t\t\t|| (bw_code > dp_panel->max_bw_code)) {\n\t\t\tDRM_ERROR(\"read dpcd failed %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\tpanel->aux_cfg_update_done = false;\n\t}\nend:\n\treturn rc;\n}\n\nu32 dp_panel_get_mode_bpp(struct dp_panel *dp_panel,\n\t\tu32 mode_edid_bpp, u32 mode_pclk_khz)\n{\n\tstruct dp_panel_private *panel;\n\tu32 bpp;\n\n\tif (!dp_panel || !mode_edid_bpp || !mode_pclk_khz) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn 0;\n\t}\n\n\tpanel = container_of(dp_panel, struct dp_panel_private, dp_panel);\n\n\tif (dp_panel->video_test)\n\t\tbpp = dp_link_bit_depth_to_bpp(\n\t\t\t\tpanel->link->test_video.test_bit_depth);\n\telse\n\t\tbpp = dp_panel_get_supported_bpp(dp_panel, mode_edid_bpp,\n\t\t\t\tmode_pclk_khz);\n\n\treturn bpp;\n}\n\nint dp_panel_get_modes(struct dp_panel *dp_panel,\n\tstruct drm_connector *connector)\n{\n\tif (!dp_panel) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dp_panel->edid)\n\t\treturn dp_panel_update_modes(connector, dp_panel->edid);\n\n\treturn 0;\n}\n\nstatic u8 dp_panel_get_edid_checksum(struct edid *edid)\n{\n\tedid += edid->extensions;\n\n\treturn edid->checksum;\n}\n\nvoid dp_panel_handle_sink_request(struct dp_panel *dp_panel)\n{\n\tstruct dp_panel_private *panel;\n\n\tif (!dp_panel) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn;\n\t}\n\n\tpanel = container_of(dp_panel, struct dp_panel_private, dp_panel);\n\n\tif (panel->link->sink_request & DP_TEST_LINK_EDID_READ) {\n\t\tu8 checksum;\n\n\t\tif (dp_panel->edid)\n\t\t\tchecksum = dp_panel_get_edid_checksum(dp_panel->edid);\n\t\telse\n\t\t\tchecksum = dp_panel->connector->real_edid_checksum;\n\n\t\tdp_link_send_edid_checksum(panel->link, checksum);\n\t\tdp_link_send_test_response(panel->link);\n\t}\n}\n\nvoid dp_panel_tpg_config(struct dp_panel *dp_panel, bool enable)\n{\n\tstruct dp_catalog *catalog;\n\tstruct dp_panel_private *panel;\n\n\tif (!dp_panel) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn;\n\t}\n\n\tpanel = container_of(dp_panel, struct dp_panel_private, dp_panel);\n\tcatalog = panel->catalog;\n\n\tif (!panel->panel_on) {\n\t\tdrm_dbg_dp(panel->drm_dev,\n\t\t\t\t\"DP panel not enabled, handle TPG on next on\\n\");\n\t\treturn;\n\t}\n\n\tif (!enable) {\n\t\tdp_catalog_panel_tpg_disable(catalog);\n\t\treturn;\n\t}\n\n\tdrm_dbg_dp(panel->drm_dev, \"calling catalog tpg_enable\\n\");\n\tdp_catalog_panel_tpg_enable(catalog, &panel->dp_panel.dp_mode.drm_mode);\n}\n\nvoid dp_panel_dump_regs(struct dp_panel *dp_panel)\n{\n\tstruct dp_catalog *catalog;\n\tstruct dp_panel_private *panel;\n\n\tpanel = container_of(dp_panel, struct dp_panel_private, dp_panel);\n\tcatalog = panel->catalog;\n\n\tdp_catalog_dump_regs(catalog);\n}\n\nint dp_panel_timing_cfg(struct dp_panel *dp_panel)\n{\n\tu32 data, total_ver, total_hor;\n\tstruct dp_catalog *catalog;\n\tstruct dp_panel_private *panel;\n\tstruct drm_display_mode *drm_mode;\n\n\tpanel = container_of(dp_panel, struct dp_panel_private, dp_panel);\n\tcatalog = panel->catalog;\n\tdrm_mode = &panel->dp_panel.dp_mode.drm_mode;\n\n\tdrm_dbg_dp(panel->drm_dev, \"width=%d hporch= %d %d %d\\n\",\n\t\tdrm_mode->hdisplay, drm_mode->htotal - drm_mode->hsync_end,\n\t\tdrm_mode->hsync_start - drm_mode->hdisplay,\n\t\tdrm_mode->hsync_end - drm_mode->hsync_start);\n\n\tdrm_dbg_dp(panel->drm_dev, \"height=%d vporch= %d %d %d\\n\",\n\t\tdrm_mode->vdisplay, drm_mode->vtotal - drm_mode->vsync_end,\n\t\tdrm_mode->vsync_start - drm_mode->vdisplay,\n\t\tdrm_mode->vsync_end - drm_mode->vsync_start);\n\n\ttotal_hor = drm_mode->htotal;\n\n\ttotal_ver = drm_mode->vtotal;\n\n\tdata = total_ver;\n\tdata <<= 16;\n\tdata |= total_hor;\n\n\tcatalog->total = data;\n\n\tdata = (drm_mode->vtotal - drm_mode->vsync_start);\n\tdata <<= 16;\n\tdata |= (drm_mode->htotal - drm_mode->hsync_start);\n\n\tcatalog->sync_start = data;\n\n\tdata = drm_mode->vsync_end - drm_mode->vsync_start;\n\tdata <<= 16;\n\tdata |= (panel->dp_panel.dp_mode.v_active_low << 31);\n\tdata |= drm_mode->hsync_end - drm_mode->hsync_start;\n\tdata |= (panel->dp_panel.dp_mode.h_active_low << 15);\n\n\tcatalog->width_blanking = data;\n\n\tdata = drm_mode->vdisplay;\n\tdata <<= 16;\n\tdata |= drm_mode->hdisplay;\n\n\tcatalog->dp_active = data;\n\n\tdp_catalog_panel_timing_cfg(catalog);\n\tpanel->panel_on = true;\n\n\treturn 0;\n}\n\nint dp_panel_init_panel_info(struct dp_panel *dp_panel)\n{\n\tstruct drm_display_mode *drm_mode;\n\tstruct dp_panel_private *panel;\n\n\tdrm_mode = &dp_panel->dp_mode.drm_mode;\n\n\tpanel = container_of(dp_panel, struct dp_panel_private, dp_panel);\n\n\t \n\tdrm_dbg_dp(panel->drm_dev, \"SET NEW RESOLUTION:\\n\");\n\tdrm_dbg_dp(panel->drm_dev, \"%dx%d@%dfps\\n\",\n\t\tdrm_mode->hdisplay, drm_mode->vdisplay, drm_mode_vrefresh(drm_mode));\n\tdrm_dbg_dp(panel->drm_dev,\n\t\t\t\"h_porches(back|front|width) = (%d|%d|%d)\\n\",\n\t\t\tdrm_mode->htotal - drm_mode->hsync_end,\n\t\t\tdrm_mode->hsync_start - drm_mode->hdisplay,\n\t\t\tdrm_mode->hsync_end - drm_mode->hsync_start);\n\tdrm_dbg_dp(panel->drm_dev,\n\t\t\t\"v_porches(back|front|width) = (%d|%d|%d)\\n\",\n\t\t\tdrm_mode->vtotal - drm_mode->vsync_end,\n\t\t\tdrm_mode->vsync_start - drm_mode->vdisplay,\n\t\t\tdrm_mode->vsync_end - drm_mode->vsync_start);\n\tdrm_dbg_dp(panel->drm_dev, \"pixel clock (KHz)=(%d)\\n\",\n\t\t\t\tdrm_mode->clock);\n\tdrm_dbg_dp(panel->drm_dev, \"bpp = %d\\n\", dp_panel->dp_mode.bpp);\n\n\tdp_panel->dp_mode.bpp = max_t(u32, 18,\n\t\t\t\tmin_t(u32, dp_panel->dp_mode.bpp, 30));\n\tdrm_dbg_dp(panel->drm_dev, \"updated bpp = %d\\n\",\n\t\t\t\tdp_panel->dp_mode.bpp);\n\n\treturn 0;\n}\n\nstruct dp_panel *dp_panel_get(struct dp_panel_in *in)\n{\n\tstruct dp_panel_private *panel;\n\tstruct dp_panel *dp_panel;\n\n\tif (!in->dev || !in->catalog || !in->aux || !in->link) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpanel = devm_kzalloc(in->dev, sizeof(*panel), GFP_KERNEL);\n\tif (!panel)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpanel->dev = in->dev;\n\tpanel->aux = in->aux;\n\tpanel->catalog = in->catalog;\n\tpanel->link = in->link;\n\n\tdp_panel = &panel->dp_panel;\n\tdp_panel->max_bw_code = DP_LINK_BW_8_1;\n\tpanel->aux_cfg_update_done = false;\n\n\treturn dp_panel;\n}\n\nvoid dp_panel_put(struct dp_panel *dp_panel)\n{\n\tif (!dp_panel)\n\t\treturn;\n\n\tkfree(dp_panel->edid);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}