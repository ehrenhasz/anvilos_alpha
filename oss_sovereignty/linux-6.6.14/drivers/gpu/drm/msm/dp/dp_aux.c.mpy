{
  "module_name": "dp_aux.c",
  "hash_id": "eef3e7f13192da4c96d43a2803b84c9db8c254a1173d3431cf835af615a3415d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dp/dp_aux.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <drm/drm_print.h>\n\n#include \"dp_reg.h\"\n#include \"dp_aux.h\"\n\nenum msm_dp_aux_err {\n\tDP_AUX_ERR_NONE,\n\tDP_AUX_ERR_ADDR,\n\tDP_AUX_ERR_TOUT,\n\tDP_AUX_ERR_NACK,\n\tDP_AUX_ERR_DEFER,\n\tDP_AUX_ERR_NACK_DEFER,\n\tDP_AUX_ERR_PHY,\n};\n\nstruct dp_aux_private {\n\tstruct device *dev;\n\tstruct dp_catalog *catalog;\n\n\tstruct mutex mutex;\n\tstruct completion comp;\n\n\tenum msm_dp_aux_err aux_error_num;\n\tu32 retry_cnt;\n\tbool cmd_busy;\n\tbool native;\n\tbool read;\n\tbool no_send_addr;\n\tbool no_send_stop;\n\tbool initted;\n\tbool is_edp;\n\tu32 offset;\n\tu32 segment;\n\n\tstruct drm_dp_aux dp_aux;\n};\n\n#define MAX_AUX_RETRIES\t\t\t5\n\nstatic ssize_t dp_aux_write(struct dp_aux_private *aux,\n\t\t\tstruct drm_dp_aux_msg *msg)\n{\n\tu8 data[4];\n\tu32 reg;\n\tssize_t len;\n\tu8 *msgdata = msg->buffer;\n\tint const AUX_CMD_FIFO_LEN = 128;\n\tint i = 0;\n\n\tif (aux->read)\n\t\tlen = 0;\n\telse\n\t\tlen = msg->size;\n\n\t \n\tif (len > AUX_CMD_FIFO_LEN - 4) {\n\t\tDRM_ERROR(\"buf size greater than allowed size of 128 bytes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdata[0] = (msg->address >> 16) & 0xf;\t \n\tif (aux->read)\n\t\tdata[0] |=  BIT(4);\t\t \n\n\tdata[1] = msg->address >> 8;\t\t \n\tdata[2] = msg->address;\t\t\t \n\tdata[3] = msg->size - 1;\t\t \n\n\tfor (i = 0; i < len + 4; i++) {\n\t\treg = (i < 4) ? data[i] : msgdata[i - 4];\n\t\treg <<= DP_AUX_DATA_OFFSET;\n\t\treg &= DP_AUX_DATA_MASK;\n\t\treg |= DP_AUX_DATA_WRITE;\n\t\t \n\t\tif (i == 0)\n\t\t\treg |= DP_AUX_DATA_INDEX_WRITE;\n\t\taux->catalog->aux_data = reg;\n\t\tdp_catalog_aux_write_data(aux->catalog);\n\t}\n\n\tdp_catalog_aux_clear_trans(aux->catalog, false);\n\tdp_catalog_aux_clear_hw_interrupts(aux->catalog);\n\n\treg = 0;  \n\tif (!aux->native) {  \n\t\treg |= DP_AUX_TRANS_CTRL_I2C;\n\n\t\tif (aux->no_send_addr)\n\t\t\treg |= DP_AUX_TRANS_CTRL_NO_SEND_ADDR;\n\n\t\tif (aux->no_send_stop)\n\t\t\treg |= DP_AUX_TRANS_CTRL_NO_SEND_STOP;\n\t}\n\n\treg |= DP_AUX_TRANS_CTRL_GO;\n\taux->catalog->aux_data = reg;\n\tdp_catalog_aux_write_trans(aux->catalog);\n\n\treturn len;\n}\n\nstatic ssize_t dp_aux_cmd_fifo_tx(struct dp_aux_private *aux,\n\t\t\t      struct drm_dp_aux_msg *msg)\n{\n\tssize_t ret;\n\tunsigned long time_left;\n\n\treinit_completion(&aux->comp);\n\n\tret = dp_aux_write(aux, msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttime_left = wait_for_completion_timeout(&aux->comp,\n\t\t\t\t\t\tmsecs_to_jiffies(250));\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\treturn ret;\n}\n\nstatic ssize_t dp_aux_cmd_fifo_rx(struct dp_aux_private *aux,\n\t\tstruct drm_dp_aux_msg *msg)\n{\n\tu32 data;\n\tu8 *dp;\n\tu32 i, actual_i;\n\tu32 len = msg->size;\n\n\tdp_catalog_aux_clear_trans(aux->catalog, true);\n\n\tdata = DP_AUX_DATA_INDEX_WRITE;  \n\tdata |= DP_AUX_DATA_READ;   \n\n\taux->catalog->aux_data = data;\n\tdp_catalog_aux_write_data(aux->catalog);\n\n\tdp = msg->buffer;\n\n\t \n\tdata = dp_catalog_aux_read_data(aux->catalog);\n\n\tfor (i = 0; i < len; i++) {\n\t\tdata = dp_catalog_aux_read_data(aux->catalog);\n\t\t*dp++ = (u8)((data >> DP_AUX_DATA_OFFSET) & 0xff);\n\n\t\tactual_i = (data >> DP_AUX_DATA_INDEX_OFFSET) & 0xFF;\n\t\tif (i != actual_i)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic void dp_aux_update_offset_and_segment(struct dp_aux_private *aux,\n\t\t\t\t\t     struct drm_dp_aux_msg *input_msg)\n{\n\tu32 edid_address = 0x50;\n\tu32 segment_address = 0x30;\n\tbool i2c_read = input_msg->request &\n\t\t(DP_AUX_I2C_READ & DP_AUX_NATIVE_READ);\n\tu8 *data;\n\n\tif (aux->native || i2c_read || ((input_msg->address != edid_address) &&\n\t\t(input_msg->address != segment_address)))\n\t\treturn;\n\n\n\tdata = input_msg->buffer;\n\tif (input_msg->address == segment_address)\n\t\taux->segment = *data;\n\telse\n\t\taux->offset = *data;\n}\n\n \nstatic void dp_aux_transfer_helper(struct dp_aux_private *aux,\n\t\t\t\t   struct drm_dp_aux_msg *input_msg,\n\t\t\t\t   bool send_seg)\n{\n\tstruct drm_dp_aux_msg helper_msg;\n\tu32 message_size = 0x10;\n\tu32 segment_address = 0x30;\n\tu32 const edid_block_length = 0x80;\n\tbool i2c_mot = input_msg->request & DP_AUX_I2C_MOT;\n\tbool i2c_read = input_msg->request &\n\t\t(DP_AUX_I2C_READ & DP_AUX_NATIVE_READ);\n\n\tif (!i2c_mot || !i2c_read || (input_msg->size == 0))\n\t\treturn;\n\n\t \n\tif (!(aux->offset % edid_block_length) || !send_seg)\n\t\tgoto end;\n\n\taux->read = false;\n\taux->cmd_busy = true;\n\taux->no_send_addr = true;\n\taux->no_send_stop = true;\n\n\t \n\n\tif (aux->segment) {\n\t\tmemset(&helper_msg, 0, sizeof(helper_msg));\n\t\thelper_msg.address = segment_address;\n\t\thelper_msg.buffer = &aux->segment;\n\t\thelper_msg.size = 1;\n\t\tdp_aux_cmd_fifo_tx(aux, &helper_msg);\n\t}\n\n\t \n\tmemset(&helper_msg, 0, sizeof(helper_msg));\n\thelper_msg.address = input_msg->address;\n\thelper_msg.buffer = &aux->offset;\n\thelper_msg.size = 1;\n\tdp_aux_cmd_fifo_tx(aux, &helper_msg);\n\nend:\n\taux->offset += message_size;\n\tif (aux->offset == 0x80 || aux->offset == 0x100)\n\t\taux->segment = 0x0;  \n}\n\n \nstatic ssize_t dp_aux_transfer(struct drm_dp_aux *dp_aux,\n\t\t\t       struct drm_dp_aux_msg *msg)\n{\n\tssize_t ret;\n\tint const aux_cmd_native_max = 16;\n\tint const aux_cmd_i2c_max = 128;\n\tstruct dp_aux_private *aux;\n\n\taux = container_of(dp_aux, struct dp_aux_private, dp_aux);\n\n\taux->native = msg->request & (DP_AUX_NATIVE_WRITE & DP_AUX_NATIVE_READ);\n\n\t \n\tif (msg->size == 0 || !msg->buffer) {\n\t\tmsg->reply = aux->native ?\n\t\t\tDP_AUX_NATIVE_REPLY_ACK : DP_AUX_I2C_REPLY_ACK;\n\t\treturn msg->size;\n\t}\n\n\t \n\tif ((aux->native && msg->size > aux_cmd_native_max) ||\n\t    msg->size > aux_cmd_i2c_max) {\n\t\tDRM_ERROR(\"%s: invalid msg: size(%zu), request(%x)\\n\",\n\t\t\t__func__, msg->size, msg->request);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&aux->mutex);\n\tif (!aux->initted) {\n\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (aux->is_edp) {\n\t\tret = dp_catalog_aux_wait_for_hpd_connect_state(aux->catalog);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG_DP(\"Panel not ready for aux transactions\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tdp_aux_update_offset_and_segment(aux, msg);\n\tdp_aux_transfer_helper(aux, msg, true);\n\n\taux->read = msg->request & (DP_AUX_I2C_READ & DP_AUX_NATIVE_READ);\n\taux->cmd_busy = true;\n\n\tif (aux->read) {\n\t\taux->no_send_addr = true;\n\t\taux->no_send_stop = false;\n\t} else {\n\t\taux->no_send_addr = true;\n\t\taux->no_send_stop = true;\n\t}\n\n\tret = dp_aux_cmd_fifo_tx(aux, msg);\n\tif (ret < 0) {\n\t\tif (aux->native) {\n\t\t\taux->retry_cnt++;\n\t\t\tif (!(aux->retry_cnt % MAX_AUX_RETRIES))\n\t\t\t\tdp_catalog_aux_update_cfg(aux->catalog);\n\t\t}\n\t\t \n\t\tif (dp_catalog_link_is_connected(aux->catalog))\n\t\t\tdp_catalog_aux_reset(aux->catalog);\n\t} else {\n\t\taux->retry_cnt = 0;\n\t\tswitch (aux->aux_error_num) {\n\t\tcase DP_AUX_ERR_NONE:\n\t\t\tif (aux->read)\n\t\t\t\tret = dp_aux_cmd_fifo_rx(aux, msg);\n\t\t\tmsg->reply = aux->native ? DP_AUX_NATIVE_REPLY_ACK : DP_AUX_I2C_REPLY_ACK;\n\t\t\tbreak;\n\t\tcase DP_AUX_ERR_DEFER:\n\t\t\tmsg->reply = aux->native ? DP_AUX_NATIVE_REPLY_DEFER : DP_AUX_I2C_REPLY_DEFER;\n\t\t\tbreak;\n\t\tcase DP_AUX_ERR_PHY:\n\t\tcase DP_AUX_ERR_ADDR:\n\t\tcase DP_AUX_ERR_NACK:\n\t\tcase DP_AUX_ERR_NACK_DEFER:\n\t\t\tmsg->reply = aux->native ? DP_AUX_NATIVE_REPLY_NACK : DP_AUX_I2C_REPLY_NACK;\n\t\t\tbreak;\n\t\tcase DP_AUX_ERR_TOUT:\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\taux->cmd_busy = false;\n\nexit:\n\tmutex_unlock(&aux->mutex);\n\n\treturn ret;\n}\n\nirqreturn_t dp_aux_isr(struct drm_dp_aux *dp_aux)\n{\n\tu32 isr;\n\tstruct dp_aux_private *aux;\n\n\tif (!dp_aux) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\taux = container_of(dp_aux, struct dp_aux_private, dp_aux);\n\n\tisr = dp_catalog_aux_get_irq(aux->catalog);\n\n\t \n\tif (!isr)\n\t\treturn IRQ_NONE;\n\n\tif (!aux->cmd_busy) {\n\t\tDRM_ERROR(\"Unexpected DP AUX IRQ %#010x when not busy\\n\", isr);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (hweight32(isr & ~DP_INTR_AUX_XFER_DONE) > 1)\n\t\tDRM_WARN(\"Some DP AUX interrupts unhandled: %#010x\\n\", isr);\n\n\tif (isr & DP_INTR_AUX_ERROR) {\n\t\taux->aux_error_num = DP_AUX_ERR_PHY;\n\t\tdp_catalog_aux_clear_hw_interrupts(aux->catalog);\n\t} else if (isr & DP_INTR_NACK_DEFER) {\n\t\taux->aux_error_num = DP_AUX_ERR_NACK_DEFER;\n\t} else if (isr & DP_INTR_WRONG_ADDR) {\n\t\taux->aux_error_num = DP_AUX_ERR_ADDR;\n\t} else if (isr & DP_INTR_TIMEOUT) {\n\t\taux->aux_error_num = DP_AUX_ERR_TOUT;\n\t} else if (!aux->native && (isr & DP_INTR_I2C_NACK)) {\n\t\taux->aux_error_num = DP_AUX_ERR_NACK;\n\t} else if (!aux->native && (isr & DP_INTR_I2C_DEFER)) {\n\t\tif (isr & DP_INTR_AUX_XFER_DONE)\n\t\t\taux->aux_error_num = DP_AUX_ERR_NACK;\n\t\telse\n\t\t\taux->aux_error_num = DP_AUX_ERR_DEFER;\n\t} else if (isr & DP_INTR_AUX_XFER_DONE) {\n\t\taux->aux_error_num = DP_AUX_ERR_NONE;\n\t} else {\n\t\tDRM_WARN(\"Unexpected interrupt: %#010x\\n\", isr);\n\t\treturn IRQ_NONE;\n\t}\n\n\tcomplete(&aux->comp);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid dp_aux_reconfig(struct drm_dp_aux *dp_aux)\n{\n\tstruct dp_aux_private *aux;\n\n\taux = container_of(dp_aux, struct dp_aux_private, dp_aux);\n\n\tdp_catalog_aux_update_cfg(aux->catalog);\n\tdp_catalog_aux_reset(aux->catalog);\n}\n\nvoid dp_aux_init(struct drm_dp_aux *dp_aux)\n{\n\tstruct dp_aux_private *aux;\n\n\tif (!dp_aux) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn;\n\t}\n\n\taux = container_of(dp_aux, struct dp_aux_private, dp_aux);\n\n\tmutex_lock(&aux->mutex);\n\n\tdp_catalog_aux_enable(aux->catalog, true);\n\taux->retry_cnt = 0;\n\taux->initted = true;\n\n\tmutex_unlock(&aux->mutex);\n}\n\nvoid dp_aux_deinit(struct drm_dp_aux *dp_aux)\n{\n\tstruct dp_aux_private *aux;\n\n\taux = container_of(dp_aux, struct dp_aux_private, dp_aux);\n\n\tmutex_lock(&aux->mutex);\n\n\taux->initted = false;\n\tdp_catalog_aux_enable(aux->catalog, false);\n\n\tmutex_unlock(&aux->mutex);\n}\n\nint dp_aux_register(struct drm_dp_aux *dp_aux)\n{\n\tstruct dp_aux_private *aux;\n\tint ret;\n\n\tif (!dp_aux) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taux = container_of(dp_aux, struct dp_aux_private, dp_aux);\n\n\taux->dp_aux.name = \"dpu_dp_aux\";\n\taux->dp_aux.dev = aux->dev;\n\taux->dp_aux.transfer = dp_aux_transfer;\n\tret = drm_dp_aux_register(&aux->dp_aux);\n\tif (ret) {\n\t\tDRM_ERROR(\"%s: failed to register drm aux: %d\\n\", __func__,\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid dp_aux_unregister(struct drm_dp_aux *dp_aux)\n{\n\tdrm_dp_aux_unregister(dp_aux);\n}\n\nstruct drm_dp_aux *dp_aux_get(struct device *dev, struct dp_catalog *catalog,\n\t\t\t      bool is_edp)\n{\n\tstruct dp_aux_private *aux;\n\n\tif (!catalog) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\taux = devm_kzalloc(dev, sizeof(*aux), GFP_KERNEL);\n\tif (!aux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit_completion(&aux->comp);\n\taux->cmd_busy = false;\n\taux->is_edp = is_edp;\n\tmutex_init(&aux->mutex);\n\n\taux->dev = dev;\n\taux->catalog = catalog;\n\taux->retry_cnt = 0;\n\n\treturn &aux->dp_aux;\n}\n\nvoid dp_aux_put(struct drm_dp_aux *dp_aux)\n{\n\tstruct dp_aux_private *aux;\n\n\tif (!dp_aux)\n\t\treturn;\n\n\taux = container_of(dp_aux, struct dp_aux_private, dp_aux);\n\n\tmutex_destroy(&aux->mutex);\n\n\tdevm_kfree(aux->dev, aux);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}