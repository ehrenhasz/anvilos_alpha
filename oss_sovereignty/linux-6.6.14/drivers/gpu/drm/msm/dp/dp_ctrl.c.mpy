{
  "module_name": "dp_ctrl.c",
  "hash_id": "885ec3f5c831df25f7384802ce03f236bde062598b8a93e2ac3f3ee4547f6561",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dp/dp_ctrl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm-dp] %s: \" fmt, __func__\n\n#include <linux/types.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/phy-dp.h>\n#include <linux/pm_opp.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_fixed.h>\n#include <drm/drm_print.h>\n\n#include \"dp_reg.h\"\n#include \"dp_ctrl.h\"\n#include \"dp_link.h\"\n\n#define DP_KHZ_TO_HZ 1000\n#define IDLE_PATTERN_COMPLETION_TIMEOUT_JIFFIES\t(30 * HZ / 1000)  \n#define PSR_OPERATION_COMPLETION_TIMEOUT_JIFFIES       (300 * HZ / 1000)  \n#define WAIT_FOR_VIDEO_READY_TIMEOUT_JIFFIES (HZ / 2)\n\n#define DP_CTRL_INTR_READY_FOR_VIDEO     BIT(0)\n#define DP_CTRL_INTR_IDLE_PATTERN_SENT  BIT(3)\n\n#define MR_LINK_TRAINING1  0x8\n#define MR_LINK_SYMBOL_ERM 0x80\n#define MR_LINK_PRBS7 0x100\n#define MR_LINK_CUSTOM80 0x200\n#define MR_LINK_TRAINING4  0x40\n\nenum {\n\tDP_TRAINING_NONE,\n\tDP_TRAINING_1,\n\tDP_TRAINING_2,\n};\n\nstruct dp_tu_calc_input {\n\tu64 lclk;         \n\tu64 pclk_khz;     \n\tu64 hactive;      \n\tu64 hporch;       \n\tint nlanes;       \n\tint bpp;          \n\tint pixel_enc;    \n\tint dsc_en;      \n\tint async_en;    \n\tint fec_en;      \n\tint compress_ratio;  \n\tint num_of_dsc_slices;  \n};\n\nstruct dp_vc_tu_mapping_table {\n\tu32 vic;\n\tu8 lanes;\n\tu8 lrate;  \n\tu8 bpp;\n\tu8 valid_boundary_link;\n\tu16 delay_start_link;\n\tbool boundary_moderation_en;\n\tu8 valid_lower_boundary_link;\n\tu8 upper_boundary_count;\n\tu8 lower_boundary_count;\n\tu8 tu_size_minus1;\n};\n\nstruct dp_ctrl_private {\n\tstruct dp_ctrl dp_ctrl;\n\tstruct drm_device *drm_dev;\n\tstruct device *dev;\n\tstruct drm_dp_aux *aux;\n\tstruct dp_panel *panel;\n\tstruct dp_link *link;\n\tstruct dp_power *power;\n\tstruct dp_parser *parser;\n\tstruct dp_catalog *catalog;\n\n\tstruct completion idle_comp;\n\tstruct completion psr_op_comp;\n\tstruct completion video_comp;\n};\n\nstatic int dp_aux_link_configure(struct drm_dp_aux *aux,\n\t\t\t\t\tstruct dp_link_info *link)\n{\n\tu8 values[2];\n\tint err;\n\n\tvalues[0] = drm_dp_link_rate_to_bw_code(link->rate);\n\tvalues[1] = link->num_lanes;\n\n\tif (link->capabilities & DP_LINK_CAP_ENHANCED_FRAMING)\n\t\tvalues[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\n\terr = drm_dp_dpcd_write(aux, DP_LINK_BW_SET, values, sizeof(values));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nvoid dp_ctrl_push_idle(struct dp_ctrl *dp_ctrl)\n{\n\tstruct dp_ctrl_private *ctrl;\n\n\tctrl = container_of(dp_ctrl, struct dp_ctrl_private, dp_ctrl);\n\n\treinit_completion(&ctrl->idle_comp);\n\tdp_catalog_ctrl_state_ctrl(ctrl->catalog, DP_STATE_CTRL_PUSH_IDLE);\n\n\tif (!wait_for_completion_timeout(&ctrl->idle_comp,\n\t\t\tIDLE_PATTERN_COMPLETION_TIMEOUT_JIFFIES))\n\t\tpr_warn(\"PUSH_IDLE pattern timedout\\n\");\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"mainlink off\\n\");\n}\n\nstatic void dp_ctrl_config_ctrl(struct dp_ctrl_private *ctrl)\n{\n\tu32 config = 0, tbd;\n\tconst u8 *dpcd = ctrl->panel->dpcd;\n\n\t \n\tconfig |= (2 << DP_CONFIGURATION_CTRL_LSCLK_DIV_SHIFT);\n\n\t \n\tif (drm_dp_alternate_scrambler_reset_cap(dpcd))\n\t\tconfig |= DP_CONFIGURATION_CTRL_ASSR;\n\n\ttbd = dp_link_get_test_bits_depth(ctrl->link,\n\t\t\tctrl->panel->dp_mode.bpp);\n\n\tif (tbd == DP_TEST_BIT_DEPTH_UNKNOWN) {\n\t\tpr_debug(\"BIT_DEPTH not set. Configure default\\n\");\n\t\ttbd = DP_TEST_BIT_DEPTH_8;\n\t}\n\n\tconfig |= tbd << DP_CONFIGURATION_CTRL_BPC_SHIFT;\n\n\t \n\tconfig |= ((ctrl->link->link_params.num_lanes - 1)\n\t\t\t<< DP_CONFIGURATION_CTRL_NUM_OF_LANES_SHIFT);\n\n\tif (drm_dp_enhanced_frame_cap(dpcd))\n\t\tconfig |= DP_CONFIGURATION_CTRL_ENHANCED_FRAMING;\n\n\tconfig |= DP_CONFIGURATION_CTRL_P_INTERLACED;  \n\n\t \n\tconfig |= DP_CONFIGURATION_CTRL_STATIC_DYNAMIC_CN;\n\tconfig |= DP_CONFIGURATION_CTRL_SYNC_ASYNC_CLK;\n\n\tif (ctrl->panel->psr_cap.version)\n\t\tconfig |= DP_CONFIGURATION_CTRL_SEND_VSC;\n\n\tdp_catalog_ctrl_config_ctrl(ctrl->catalog, config);\n}\n\nstatic void dp_ctrl_configure_source_params(struct dp_ctrl_private *ctrl)\n{\n\tu32 cc, tb;\n\n\tdp_catalog_ctrl_lane_mapping(ctrl->catalog);\n\tdp_catalog_ctrl_mainlink_ctrl(ctrl->catalog, true);\n\n\tdp_ctrl_config_ctrl(ctrl);\n\n\ttb = dp_link_get_test_bits_depth(ctrl->link,\n\t\tctrl->panel->dp_mode.bpp);\n\tcc = dp_link_get_colorimetry_config(ctrl->link);\n\tdp_catalog_ctrl_config_misc(ctrl->catalog, cc, tb);\n\tdp_panel_timing_cfg(ctrl->panel);\n}\n\n \nstruct tu_algo_data {\n\ts64 lclk_fp;\n\ts64 pclk_fp;\n\ts64 lwidth;\n\ts64 lwidth_fp;\n\ts64 hbp_relative_to_pclk;\n\ts64 hbp_relative_to_pclk_fp;\n\tint nlanes;\n\tint bpp;\n\tint pixelEnc;\n\tint dsc_en;\n\tint async_en;\n\tint bpc;\n\n\tuint delay_start_link_extra_pixclk;\n\tint extra_buffer_margin;\n\ts64 ratio_fp;\n\ts64 original_ratio_fp;\n\n\ts64 err_fp;\n\ts64 n_err_fp;\n\ts64 n_n_err_fp;\n\tint tu_size;\n\tint tu_size_desired;\n\tint tu_size_minus1;\n\n\tint valid_boundary_link;\n\ts64 resulting_valid_fp;\n\ts64 total_valid_fp;\n\ts64 effective_valid_fp;\n\ts64 effective_valid_recorded_fp;\n\tint n_tus;\n\tint n_tus_per_lane;\n\tint paired_tus;\n\tint remainder_tus;\n\tint remainder_tus_upper;\n\tint remainder_tus_lower;\n\tint extra_bytes;\n\tint filler_size;\n\tint delay_start_link;\n\n\tint extra_pclk_cycles;\n\tint extra_pclk_cycles_in_link_clk;\n\ts64 ratio_by_tu_fp;\n\ts64 average_valid2_fp;\n\tint new_valid_boundary_link;\n\tint remainder_symbols_exist;\n\tint n_symbols;\n\ts64 n_remainder_symbols_per_lane_fp;\n\ts64 last_partial_tu_fp;\n\ts64 TU_ratio_err_fp;\n\n\tint n_tus_incl_last_incomplete_tu;\n\tint extra_pclk_cycles_tmp;\n\tint extra_pclk_cycles_in_link_clk_tmp;\n\tint extra_required_bytes_new_tmp;\n\tint filler_size_tmp;\n\tint lower_filler_size_tmp;\n\tint delay_start_link_tmp;\n\n\tbool boundary_moderation_en;\n\tint boundary_mod_lower_err;\n\tint upper_boundary_count;\n\tint lower_boundary_count;\n\tint i_upper_boundary_count;\n\tint i_lower_boundary_count;\n\tint valid_lower_boundary_link;\n\tint even_distribution_BF;\n\tint even_distribution_legacy;\n\tint even_distribution;\n\tint min_hblank_violated;\n\ts64 delay_start_time_fp;\n\ts64 hbp_time_fp;\n\ts64 hactive_time_fp;\n\ts64 diff_abs_fp;\n\n\ts64 ratio;\n};\n\nstatic int _tu_param_compare(s64 a, s64 b)\n{\n\tu32 a_sign;\n\tu32 b_sign;\n\ts64 a_temp, b_temp, minus_1;\n\n\tif (a == b)\n\t\treturn 0;\n\n\tminus_1 = drm_fixp_from_fraction(-1, 1);\n\n\ta_sign = (a >> 32) & 0x80000000 ? 1 : 0;\n\n\tb_sign = (b >> 32) & 0x80000000 ? 1 : 0;\n\n\tif (a_sign > b_sign)\n\t\treturn 2;\n\telse if (b_sign > a_sign)\n\t\treturn 1;\n\n\tif (!a_sign && !b_sign) {  \n\t\tif (a > b)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 2;\n\t} else {  \n\t\ta_temp = drm_fixp_mul(a, minus_1);\n\t\tb_temp = drm_fixp_mul(b, minus_1);\n\n\t\tif (a_temp > b_temp)\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t}\n}\n\nstatic void dp_panel_update_tu_timings(struct dp_tu_calc_input *in,\n\t\t\t\t\tstruct tu_algo_data *tu)\n{\n\tint nlanes = in->nlanes;\n\tint dsc_num_slices = in->num_of_dsc_slices;\n\tint dsc_num_bytes  = 0;\n\tint numerator;\n\ts64 pclk_dsc_fp;\n\ts64 dwidth_dsc_fp;\n\ts64 hbp_dsc_fp;\n\n\tint tot_num_eoc_symbols = 0;\n\tint tot_num_hor_bytes   = 0;\n\tint tot_num_dummy_bytes = 0;\n\tint dwidth_dsc_bytes    = 0;\n\tint  eoc_bytes           = 0;\n\n\ts64 temp1_fp, temp2_fp, temp3_fp;\n\n\ttu->lclk_fp              = drm_fixp_from_fraction(in->lclk, 1);\n\ttu->pclk_fp              = drm_fixp_from_fraction(in->pclk_khz, 1000);\n\ttu->lwidth               = in->hactive;\n\ttu->hbp_relative_to_pclk = in->hporch;\n\ttu->nlanes               = in->nlanes;\n\ttu->bpp                  = in->bpp;\n\ttu->pixelEnc             = in->pixel_enc;\n\ttu->dsc_en               = in->dsc_en;\n\ttu->async_en             = in->async_en;\n\ttu->lwidth_fp            = drm_fixp_from_fraction(in->hactive, 1);\n\ttu->hbp_relative_to_pclk_fp = drm_fixp_from_fraction(in->hporch, 1);\n\n\tif (tu->pixelEnc == 420) {\n\t\ttemp1_fp = drm_fixp_from_fraction(2, 1);\n\t\ttu->pclk_fp = drm_fixp_div(tu->pclk_fp, temp1_fp);\n\t\ttu->lwidth_fp = drm_fixp_div(tu->lwidth_fp, temp1_fp);\n\t\ttu->hbp_relative_to_pclk_fp =\n\t\t\t\tdrm_fixp_div(tu->hbp_relative_to_pclk_fp, 2);\n\t}\n\n\tif (tu->pixelEnc == 422) {\n\t\tswitch (tu->bpp) {\n\t\tcase 24:\n\t\t\ttu->bpp = 16;\n\t\t\ttu->bpc = 8;\n\t\t\tbreak;\n\t\tcase 30:\n\t\t\ttu->bpp = 20;\n\t\t\ttu->bpc = 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttu->bpp = 16;\n\t\t\ttu->bpc = 8;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ttu->bpc = tu->bpp/3;\n\t}\n\n\tif (!in->dsc_en)\n\t\tgoto fec_check;\n\n\ttemp1_fp = drm_fixp_from_fraction(in->compress_ratio, 100);\n\ttemp2_fp = drm_fixp_from_fraction(in->bpp, 1);\n\ttemp3_fp = drm_fixp_div(temp2_fp, temp1_fp);\n\ttemp2_fp = drm_fixp_mul(tu->lwidth_fp, temp3_fp);\n\n\ttemp1_fp = drm_fixp_from_fraction(8, 1);\n\ttemp3_fp = drm_fixp_div(temp2_fp, temp1_fp);\n\n\tnumerator = drm_fixp2int(temp3_fp);\n\n\tdsc_num_bytes  = numerator / dsc_num_slices;\n\teoc_bytes           = dsc_num_bytes % nlanes;\n\ttot_num_eoc_symbols = nlanes * dsc_num_slices;\n\ttot_num_hor_bytes   = dsc_num_bytes * dsc_num_slices;\n\ttot_num_dummy_bytes = (nlanes - eoc_bytes) * dsc_num_slices;\n\n\tif (dsc_num_bytes == 0)\n\t\tpr_info(\"incorrect no of bytes per slice=%d\\n\", dsc_num_bytes);\n\n\tdwidth_dsc_bytes = (tot_num_hor_bytes +\n\t\t\t\ttot_num_eoc_symbols +\n\t\t\t\t(eoc_bytes == 0 ? 0 : tot_num_dummy_bytes));\n\n\tdwidth_dsc_fp = drm_fixp_from_fraction(dwidth_dsc_bytes, 3);\n\n\ttemp2_fp = drm_fixp_mul(tu->pclk_fp, dwidth_dsc_fp);\n\ttemp1_fp = drm_fixp_div(temp2_fp, tu->lwidth_fp);\n\tpclk_dsc_fp = temp1_fp;\n\n\ttemp1_fp = drm_fixp_div(pclk_dsc_fp, tu->pclk_fp);\n\ttemp2_fp = drm_fixp_mul(tu->hbp_relative_to_pclk_fp, temp1_fp);\n\thbp_dsc_fp = temp2_fp;\n\n\t \n\ttu->pclk_fp = pclk_dsc_fp;\n\ttu->lwidth_fp = dwidth_dsc_fp;\n\ttu->hbp_relative_to_pclk_fp = hbp_dsc_fp;\n\nfec_check:\n\tif (in->fec_en) {\n\t\ttemp1_fp = drm_fixp_from_fraction(976, 1000);  \n\t\ttu->lclk_fp = drm_fixp_mul(tu->lclk_fp, temp1_fp);\n\t}\n}\n\nstatic void _tu_valid_boundary_calc(struct tu_algo_data *tu)\n{\n\ts64 temp1_fp, temp2_fp, temp, temp1, temp2;\n\tint compare_result_1, compare_result_2, compare_result_3;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->tu_size, 1);\n\ttemp2_fp = drm_fixp_mul(tu->ratio_fp, temp1_fp);\n\n\ttu->new_valid_boundary_link = drm_fixp2int_ceil(temp2_fp);\n\n\ttemp = (tu->i_upper_boundary_count *\n\t\t\t\ttu->new_valid_boundary_link +\n\t\t\t\ttu->i_lower_boundary_count *\n\t\t\t\t(tu->new_valid_boundary_link-1));\n\ttu->average_valid2_fp = drm_fixp_from_fraction(temp,\n\t\t\t\t\t(tu->i_upper_boundary_count +\n\t\t\t\t\ttu->i_lower_boundary_count));\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->bpp, 8);\n\ttemp2_fp = tu->lwidth_fp;\n\ttemp1_fp = drm_fixp_mul(temp2_fp, temp1_fp);\n\ttemp2_fp = drm_fixp_div(temp1_fp, tu->average_valid2_fp);\n\ttu->n_tus = drm_fixp2int(temp2_fp);\n\tif ((temp2_fp & 0xFFFFFFFF) > 0xFFFFF000)\n\t\ttu->n_tus += 1;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->n_tus, 1);\n\ttemp2_fp = drm_fixp_mul(temp1_fp, tu->average_valid2_fp);\n\ttemp1_fp = drm_fixp_from_fraction(tu->n_symbols, 1);\n\ttemp2_fp = temp1_fp - temp2_fp;\n\ttemp1_fp = drm_fixp_from_fraction(tu->nlanes, 1);\n\ttemp2_fp = drm_fixp_div(temp2_fp, temp1_fp);\n\ttu->n_remainder_symbols_per_lane_fp = temp2_fp;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->tu_size, 1);\n\ttu->last_partial_tu_fp =\n\t\t\tdrm_fixp_div(tu->n_remainder_symbols_per_lane_fp,\n\t\t\t\t\ttemp1_fp);\n\n\tif (tu->n_remainder_symbols_per_lane_fp != 0)\n\t\ttu->remainder_symbols_exist = 1;\n\telse\n\t\ttu->remainder_symbols_exist = 0;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->n_tus, tu->nlanes);\n\ttu->n_tus_per_lane = drm_fixp2int(temp1_fp);\n\n\ttu->paired_tus = (int)((tu->n_tus_per_lane) /\n\t\t\t\t\t(tu->i_upper_boundary_count +\n\t\t\t\t\t tu->i_lower_boundary_count));\n\n\ttu->remainder_tus = tu->n_tus_per_lane - tu->paired_tus *\n\t\t\t\t\t\t(tu->i_upper_boundary_count +\n\t\t\t\t\t\ttu->i_lower_boundary_count);\n\n\tif ((tu->remainder_tus - tu->i_upper_boundary_count) > 0) {\n\t\ttu->remainder_tus_upper = tu->i_upper_boundary_count;\n\t\ttu->remainder_tus_lower = tu->remainder_tus -\n\t\t\t\t\t\ttu->i_upper_boundary_count;\n\t} else {\n\t\ttu->remainder_tus_upper = tu->remainder_tus;\n\t\ttu->remainder_tus_lower = 0;\n\t}\n\n\ttemp = tu->paired_tus * (tu->i_upper_boundary_count *\n\t\t\t\ttu->new_valid_boundary_link +\n\t\t\t\ttu->i_lower_boundary_count *\n\t\t\t\t(tu->new_valid_boundary_link - 1)) +\n\t\t\t\t(tu->remainder_tus_upper *\n\t\t\t\t tu->new_valid_boundary_link) +\n\t\t\t\t(tu->remainder_tus_lower *\n\t\t\t\t(tu->new_valid_boundary_link - 1));\n\ttu->total_valid_fp = drm_fixp_from_fraction(temp, 1);\n\n\tif (tu->remainder_symbols_exist) {\n\t\ttemp1_fp = tu->total_valid_fp +\n\t\t\t\ttu->n_remainder_symbols_per_lane_fp;\n\t\ttemp2_fp = drm_fixp_from_fraction(tu->n_tus_per_lane, 1);\n\t\ttemp2_fp = temp2_fp + tu->last_partial_tu_fp;\n\t\ttemp1_fp = drm_fixp_div(temp1_fp, temp2_fp);\n\t} else {\n\t\ttemp2_fp = drm_fixp_from_fraction(tu->n_tus_per_lane, 1);\n\t\ttemp1_fp = drm_fixp_div(tu->total_valid_fp, temp2_fp);\n\t}\n\ttu->effective_valid_fp = temp1_fp;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->tu_size, 1);\n\ttemp2_fp = drm_fixp_mul(tu->ratio_fp, temp1_fp);\n\ttu->n_n_err_fp = tu->effective_valid_fp - temp2_fp;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->tu_size, 1);\n\ttemp2_fp = drm_fixp_mul(tu->ratio_fp, temp1_fp);\n\ttu->n_err_fp = tu->average_valid2_fp - temp2_fp;\n\n\ttu->even_distribution = tu->n_tus % tu->nlanes == 0 ? 1 : 0;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->bpp, 8);\n\ttemp2_fp = tu->lwidth_fp;\n\ttemp1_fp = drm_fixp_mul(temp2_fp, temp1_fp);\n\ttemp2_fp = drm_fixp_div(temp1_fp, tu->average_valid2_fp);\n\n\tif (temp2_fp)\n\t\ttu->n_tus_incl_last_incomplete_tu = drm_fixp2int_ceil(temp2_fp);\n\telse\n\t\ttu->n_tus_incl_last_incomplete_tu = 0;\n\n\ttemp1 = 0;\n\ttemp1_fp = drm_fixp_from_fraction(tu->tu_size, 1);\n\ttemp2_fp = drm_fixp_mul(tu->original_ratio_fp, temp1_fp);\n\ttemp1_fp = tu->average_valid2_fp - temp2_fp;\n\ttemp2_fp = drm_fixp_from_fraction(tu->n_tus_incl_last_incomplete_tu, 1);\n\ttemp1_fp = drm_fixp_mul(temp2_fp, temp1_fp);\n\n\tif (temp1_fp)\n\t\ttemp1 = drm_fixp2int_ceil(temp1_fp);\n\n\ttemp = tu->i_upper_boundary_count * tu->nlanes;\n\ttemp1_fp = drm_fixp_from_fraction(tu->tu_size, 1);\n\ttemp2_fp = drm_fixp_mul(tu->original_ratio_fp, temp1_fp);\n\ttemp1_fp = drm_fixp_from_fraction(tu->new_valid_boundary_link, 1);\n\ttemp2_fp = temp1_fp - temp2_fp;\n\ttemp1_fp = drm_fixp_from_fraction(temp, 1);\n\ttemp2_fp = drm_fixp_mul(temp1_fp, temp2_fp);\n\n\tif (temp2_fp)\n\t\ttemp2 = drm_fixp2int_ceil(temp2_fp);\n\telse\n\t\ttemp2 = 0;\n\ttu->extra_required_bytes_new_tmp = (int)(temp1 + temp2);\n\n\ttemp1_fp = drm_fixp_from_fraction(8, tu->bpp);\n\ttemp2_fp = drm_fixp_from_fraction(\n\ttu->extra_required_bytes_new_tmp, 1);\n\ttemp1_fp = drm_fixp_mul(temp2_fp, temp1_fp);\n\n\tif (temp1_fp)\n\t\ttu->extra_pclk_cycles_tmp = drm_fixp2int_ceil(temp1_fp);\n\telse\n\t\ttu->extra_pclk_cycles_tmp = 0;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->extra_pclk_cycles_tmp, 1);\n\ttemp2_fp = drm_fixp_div(tu->lclk_fp, tu->pclk_fp);\n\ttemp1_fp = drm_fixp_mul(temp1_fp, temp2_fp);\n\n\tif (temp1_fp)\n\t\ttu->extra_pclk_cycles_in_link_clk_tmp =\n\t\t\t\t\t\tdrm_fixp2int_ceil(temp1_fp);\n\telse\n\t\ttu->extra_pclk_cycles_in_link_clk_tmp = 0;\n\n\ttu->filler_size_tmp = tu->tu_size - tu->new_valid_boundary_link;\n\n\ttu->lower_filler_size_tmp = tu->filler_size_tmp + 1;\n\n\ttu->delay_start_link_tmp = tu->extra_pclk_cycles_in_link_clk_tmp +\n\t\t\t\t\ttu->lower_filler_size_tmp +\n\t\t\t\t\ttu->extra_buffer_margin;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->delay_start_link_tmp, 1);\n\ttu->delay_start_time_fp = drm_fixp_div(temp1_fp, tu->lclk_fp);\n\n\tcompare_result_1 = _tu_param_compare(tu->n_n_err_fp, tu->diff_abs_fp);\n\tif (compare_result_1 == 2)\n\t\tcompare_result_1 = 1;\n\telse\n\t\tcompare_result_1 = 0;\n\n\tcompare_result_2 = _tu_param_compare(tu->n_n_err_fp, tu->err_fp);\n\tif (compare_result_2 == 2)\n\t\tcompare_result_2 = 1;\n\telse\n\t\tcompare_result_2 = 0;\n\n\tcompare_result_3 = _tu_param_compare(tu->hbp_time_fp,\n\t\t\t\t\ttu->delay_start_time_fp);\n\tif (compare_result_3 == 2)\n\t\tcompare_result_3 = 0;\n\telse\n\t\tcompare_result_3 = 1;\n\n\tif (((tu->even_distribution == 1) ||\n\t\t\t((tu->even_distribution_BF == 0) &&\n\t\t\t(tu->even_distribution_legacy == 0))) &&\n\t\t\ttu->n_err_fp >= 0 && tu->n_n_err_fp >= 0 &&\n\t\t\tcompare_result_2 &&\n\t\t\t(compare_result_1 || (tu->min_hblank_violated == 1)) &&\n\t\t\t(tu->new_valid_boundary_link - 1) > 0 &&\n\t\t\tcompare_result_3 &&\n\t\t\t(tu->delay_start_link_tmp <= 1023)) {\n\t\ttu->upper_boundary_count = tu->i_upper_boundary_count;\n\t\ttu->lower_boundary_count = tu->i_lower_boundary_count;\n\t\ttu->err_fp = tu->n_n_err_fp;\n\t\ttu->boundary_moderation_en = true;\n\t\ttu->tu_size_desired = tu->tu_size;\n\t\ttu->valid_boundary_link = tu->new_valid_boundary_link;\n\t\ttu->effective_valid_recorded_fp = tu->effective_valid_fp;\n\t\ttu->even_distribution_BF = 1;\n\t\ttu->delay_start_link = tu->delay_start_link_tmp;\n\t} else if (tu->boundary_mod_lower_err == 0) {\n\t\tcompare_result_1 = _tu_param_compare(tu->n_n_err_fp,\n\t\t\t\t\t\t\ttu->diff_abs_fp);\n\t\tif (compare_result_1 == 2)\n\t\t\ttu->boundary_mod_lower_err = 1;\n\t}\n}\n\nstatic void _dp_ctrl_calc_tu(struct dp_ctrl_private *ctrl,\n\t\t\t\tstruct dp_tu_calc_input *in,\n\t\t\t\tstruct dp_vc_tu_mapping_table *tu_table)\n{\n\tstruct tu_algo_data *tu;\n\tint compare_result_1, compare_result_2;\n\tu64 temp = 0;\n\ts64 temp_fp = 0, temp1_fp = 0, temp2_fp = 0;\n\n\ts64 LCLK_FAST_SKEW_fp = drm_fixp_from_fraction(6, 10000);  \n\ts64 const_p49_fp = drm_fixp_from_fraction(49, 100);  \n\ts64 const_p56_fp = drm_fixp_from_fraction(56, 100);  \n\ts64 RATIO_SCALE_fp = drm_fixp_from_fraction(1001, 1000);\n\n\tu8 DP_BRUTE_FORCE = 1;\n\ts64 BRUTE_FORCE_THRESHOLD_fp = drm_fixp_from_fraction(1, 10);  \n\tuint EXTRA_PIXCLK_CYCLE_DELAY = 4;\n\tuint HBLANK_MARGIN = 4;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (!tu)\n\t\treturn;\n\n\tdp_panel_update_tu_timings(in, tu);\n\n\ttu->err_fp = drm_fixp_from_fraction(1000, 1);  \n\n\ttemp1_fp = drm_fixp_from_fraction(4, 1);\n\ttemp2_fp = drm_fixp_mul(temp1_fp, tu->lclk_fp);\n\ttemp_fp = drm_fixp_div(temp2_fp, tu->pclk_fp);\n\ttu->extra_buffer_margin = drm_fixp2int_ceil(temp_fp);\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->bpp, 8);\n\ttemp2_fp = drm_fixp_mul(tu->pclk_fp, temp1_fp);\n\ttemp1_fp = drm_fixp_from_fraction(tu->nlanes, 1);\n\ttemp2_fp = drm_fixp_div(temp2_fp, temp1_fp);\n\ttu->ratio_fp = drm_fixp_div(temp2_fp, tu->lclk_fp);\n\n\ttu->original_ratio_fp = tu->ratio_fp;\n\ttu->boundary_moderation_en = false;\n\ttu->upper_boundary_count = 0;\n\ttu->lower_boundary_count = 0;\n\ttu->i_upper_boundary_count = 0;\n\ttu->i_lower_boundary_count = 0;\n\ttu->valid_lower_boundary_link = 0;\n\ttu->even_distribution_BF = 0;\n\ttu->even_distribution_legacy = 0;\n\ttu->even_distribution = 0;\n\ttu->delay_start_time_fp = 0;\n\n\ttu->err_fp = drm_fixp_from_fraction(1000, 1);\n\ttu->n_err_fp = 0;\n\ttu->n_n_err_fp = 0;\n\n\ttu->ratio = drm_fixp2int(tu->ratio_fp);\n\ttemp1_fp = drm_fixp_from_fraction(tu->nlanes, 1);\n\tdiv64_u64_rem(tu->lwidth_fp, temp1_fp, &temp2_fp);\n\tif (temp2_fp != 0 &&\n\t\t\t!tu->ratio && tu->dsc_en == 0) {\n\t\ttu->ratio_fp = drm_fixp_mul(tu->ratio_fp, RATIO_SCALE_fp);\n\t\ttu->ratio = drm_fixp2int(tu->ratio_fp);\n\t\tif (tu->ratio)\n\t\t\ttu->ratio_fp = drm_fixp_from_fraction(1, 1);\n\t}\n\n\tif (tu->ratio > 1)\n\t\ttu->ratio = 1;\n\n\tif (tu->ratio == 1)\n\t\tgoto tu_size_calc;\n\n\tcompare_result_1 = _tu_param_compare(tu->ratio_fp, const_p49_fp);\n\tif (!compare_result_1 || compare_result_1 == 1)\n\t\tcompare_result_1 = 1;\n\telse\n\t\tcompare_result_1 = 0;\n\n\tcompare_result_2 = _tu_param_compare(tu->ratio_fp, const_p56_fp);\n\tif (!compare_result_2 || compare_result_2 == 2)\n\t\tcompare_result_2 = 1;\n\telse\n\t\tcompare_result_2 = 0;\n\n\tif (tu->dsc_en && compare_result_1 && compare_result_2) {\n\t\tHBLANK_MARGIN += 4;\n\t\tdrm_dbg_dp(ctrl->drm_dev,\n\t\t\t\"increase HBLANK_MARGIN to %d\\n\", HBLANK_MARGIN);\n\t}\n\ntu_size_calc:\n\tfor (tu->tu_size = 32; tu->tu_size <= 64; tu->tu_size++) {\n\t\ttemp1_fp = drm_fixp_from_fraction(tu->tu_size, 1);\n\t\ttemp2_fp = drm_fixp_mul(tu->ratio_fp, temp1_fp);\n\t\ttemp = drm_fixp2int_ceil(temp2_fp);\n\t\ttemp1_fp = drm_fixp_from_fraction(temp, 1);\n\t\ttu->n_err_fp = temp1_fp - temp2_fp;\n\n\t\tif (tu->n_err_fp < tu->err_fp) {\n\t\t\ttu->err_fp = tu->n_err_fp;\n\t\t\ttu->tu_size_desired = tu->tu_size;\n\t\t}\n\t}\n\n\ttu->tu_size_minus1 = tu->tu_size_desired - 1;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->tu_size_desired, 1);\n\ttemp2_fp = drm_fixp_mul(tu->ratio_fp, temp1_fp);\n\ttu->valid_boundary_link = drm_fixp2int_ceil(temp2_fp);\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->bpp, 8);\n\ttemp2_fp = tu->lwidth_fp;\n\ttemp2_fp = drm_fixp_mul(temp2_fp, temp1_fp);\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->valid_boundary_link, 1);\n\ttemp2_fp = drm_fixp_div(temp2_fp, temp1_fp);\n\ttu->n_tus = drm_fixp2int(temp2_fp);\n\tif ((temp2_fp & 0xFFFFFFFF) > 0xFFFFF000)\n\t\ttu->n_tus += 1;\n\n\ttu->even_distribution_legacy = tu->n_tus % tu->nlanes == 0 ? 1 : 0;\n\n\tdrm_dbg_dp(ctrl->drm_dev,\n\t\t\t\"n_sym = %d, num_of_tus = %d\\n\",\n\t\t\ttu->valid_boundary_link, tu->n_tus);\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->tu_size_desired, 1);\n\ttemp2_fp = drm_fixp_mul(tu->original_ratio_fp, temp1_fp);\n\ttemp1_fp = drm_fixp_from_fraction(tu->valid_boundary_link, 1);\n\ttemp2_fp = temp1_fp - temp2_fp;\n\ttemp1_fp = drm_fixp_from_fraction(tu->n_tus + 1, 1);\n\ttemp2_fp = drm_fixp_mul(temp1_fp, temp2_fp);\n\n\ttemp = drm_fixp2int(temp2_fp);\n\tif (temp && temp2_fp)\n\t\ttu->extra_bytes = drm_fixp2int_ceil(temp2_fp);\n\telse\n\t\ttu->extra_bytes = 0;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->extra_bytes, 1);\n\ttemp2_fp = drm_fixp_from_fraction(8, tu->bpp);\n\ttemp1_fp = drm_fixp_mul(temp1_fp, temp2_fp);\n\n\tif (temp && temp1_fp)\n\t\ttu->extra_pclk_cycles = drm_fixp2int_ceil(temp1_fp);\n\telse\n\t\ttu->extra_pclk_cycles = drm_fixp2int(temp1_fp);\n\n\ttemp1_fp = drm_fixp_div(tu->lclk_fp, tu->pclk_fp);\n\ttemp2_fp = drm_fixp_from_fraction(tu->extra_pclk_cycles, 1);\n\ttemp1_fp = drm_fixp_mul(temp2_fp, temp1_fp);\n\n\tif (temp1_fp)\n\t\ttu->extra_pclk_cycles_in_link_clk = drm_fixp2int_ceil(temp1_fp);\n\telse\n\t\ttu->extra_pclk_cycles_in_link_clk = drm_fixp2int(temp1_fp);\n\n\ttu->filler_size = tu->tu_size_desired - tu->valid_boundary_link;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->tu_size_desired, 1);\n\ttu->ratio_by_tu_fp = drm_fixp_mul(tu->ratio_fp, temp1_fp);\n\n\ttu->delay_start_link = tu->extra_pclk_cycles_in_link_clk +\n\t\t\t\ttu->filler_size + tu->extra_buffer_margin;\n\n\ttu->resulting_valid_fp =\n\t\t\tdrm_fixp_from_fraction(tu->valid_boundary_link, 1);\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->tu_size_desired, 1);\n\ttemp2_fp = drm_fixp_div(tu->resulting_valid_fp, temp1_fp);\n\ttu->TU_ratio_err_fp = temp2_fp - tu->original_ratio_fp;\n\n\ttemp1_fp = drm_fixp_from_fraction(HBLANK_MARGIN, 1);\n\ttemp1_fp = tu->hbp_relative_to_pclk_fp - temp1_fp;\n\ttu->hbp_time_fp = drm_fixp_div(temp1_fp, tu->pclk_fp);\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->delay_start_link, 1);\n\ttu->delay_start_time_fp = drm_fixp_div(temp1_fp, tu->lclk_fp);\n\n\tcompare_result_1 = _tu_param_compare(tu->hbp_time_fp,\n\t\t\t\t\ttu->delay_start_time_fp);\n\tif (compare_result_1 == 2)  \n\t\ttu->min_hblank_violated = 1;\n\n\ttu->hactive_time_fp = drm_fixp_div(tu->lwidth_fp, tu->pclk_fp);\n\n\tcompare_result_2 = _tu_param_compare(tu->hactive_time_fp,\n\t\t\t\t\t\ttu->delay_start_time_fp);\n\tif (compare_result_2 == 2)\n\t\ttu->min_hblank_violated = 1;\n\n\ttu->delay_start_time_fp = 0;\n\n\t \n\n\ttu->delay_start_link_extra_pixclk = EXTRA_PIXCLK_CYCLE_DELAY;\n\ttu->diff_abs_fp = tu->resulting_valid_fp - tu->ratio_by_tu_fp;\n\n\ttemp = drm_fixp2int(tu->diff_abs_fp);\n\tif (!temp && tu->diff_abs_fp <= 0xffff)\n\t\ttu->diff_abs_fp = 0;\n\n\t \n\tif (tu->diff_abs_fp < 0)\n\t\ttu->diff_abs_fp = drm_fixp_mul(tu->diff_abs_fp, -1);\n\n\ttu->boundary_mod_lower_err = 0;\n\tif ((tu->diff_abs_fp != 0 &&\n\t\t\t((tu->diff_abs_fp > BRUTE_FORCE_THRESHOLD_fp) ||\n\t\t\t (tu->even_distribution_legacy == 0) ||\n\t\t\t (DP_BRUTE_FORCE == 1))) ||\n\t\t\t(tu->min_hblank_violated == 1)) {\n\t\tdo {\n\t\t\ttu->err_fp = drm_fixp_from_fraction(1000, 1);\n\n\t\t\ttemp1_fp = drm_fixp_div(tu->lclk_fp, tu->pclk_fp);\n\t\t\ttemp2_fp = drm_fixp_from_fraction(\n\t\t\t\t\ttu->delay_start_link_extra_pixclk, 1);\n\t\t\ttemp1_fp = drm_fixp_mul(temp2_fp, temp1_fp);\n\n\t\t\tif (temp1_fp)\n\t\t\t\ttu->extra_buffer_margin =\n\t\t\t\t\tdrm_fixp2int_ceil(temp1_fp);\n\t\t\telse\n\t\t\t\ttu->extra_buffer_margin = 0;\n\n\t\t\ttemp1_fp = drm_fixp_from_fraction(tu->bpp, 8);\n\t\t\ttemp1_fp = drm_fixp_mul(tu->lwidth_fp, temp1_fp);\n\n\t\t\tif (temp1_fp)\n\t\t\t\ttu->n_symbols = drm_fixp2int_ceil(temp1_fp);\n\t\t\telse\n\t\t\t\ttu->n_symbols = 0;\n\n\t\t\tfor (tu->tu_size = 32; tu->tu_size <= 64; tu->tu_size++) {\n\t\t\t\tfor (tu->i_upper_boundary_count = 1;\n\t\t\t\t\ttu->i_upper_boundary_count <= 15;\n\t\t\t\t\ttu->i_upper_boundary_count++) {\n\t\t\t\t\tfor (tu->i_lower_boundary_count = 1;\n\t\t\t\t\t\ttu->i_lower_boundary_count <= 15;\n\t\t\t\t\t\ttu->i_lower_boundary_count++) {\n\t\t\t\t\t\t_tu_valid_boundary_calc(tu);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttu->delay_start_link_extra_pixclk--;\n\t\t} while (tu->boundary_moderation_en != true &&\n\t\t\ttu->boundary_mod_lower_err == 1 &&\n\t\t\ttu->delay_start_link_extra_pixclk != 0);\n\n\t\tif (tu->boundary_moderation_en == true) {\n\t\t\ttemp1_fp = drm_fixp_from_fraction(\n\t\t\t\t\t(tu->upper_boundary_count *\n\t\t\t\t\ttu->valid_boundary_link +\n\t\t\t\t\ttu->lower_boundary_count *\n\t\t\t\t\t(tu->valid_boundary_link - 1)), 1);\n\t\t\ttemp2_fp = drm_fixp_from_fraction(\n\t\t\t\t\t(tu->upper_boundary_count +\n\t\t\t\t\ttu->lower_boundary_count), 1);\n\t\t\ttu->resulting_valid_fp =\n\t\t\t\t\tdrm_fixp_div(temp1_fp, temp2_fp);\n\n\t\t\ttemp1_fp = drm_fixp_from_fraction(\n\t\t\t\t\ttu->tu_size_desired, 1);\n\t\t\ttu->ratio_by_tu_fp =\n\t\t\t\tdrm_fixp_mul(tu->original_ratio_fp, temp1_fp);\n\n\t\t\ttu->valid_lower_boundary_link =\n\t\t\t\ttu->valid_boundary_link - 1;\n\n\t\t\ttemp1_fp = drm_fixp_from_fraction(tu->bpp, 8);\n\t\t\ttemp1_fp = drm_fixp_mul(tu->lwidth_fp, temp1_fp);\n\t\t\ttemp2_fp = drm_fixp_div(temp1_fp,\n\t\t\t\t\t\ttu->resulting_valid_fp);\n\t\t\ttu->n_tus = drm_fixp2int(temp2_fp);\n\n\t\t\ttu->tu_size_minus1 = tu->tu_size_desired - 1;\n\t\t\ttu->even_distribution_BF = 1;\n\n\t\t\ttemp1_fp =\n\t\t\t\tdrm_fixp_from_fraction(tu->tu_size_desired, 1);\n\t\t\ttemp2_fp =\n\t\t\t\tdrm_fixp_div(tu->resulting_valid_fp, temp1_fp);\n\t\t\ttu->TU_ratio_err_fp = temp2_fp - tu->original_ratio_fp;\n\t\t}\n\t}\n\n\ttemp2_fp = drm_fixp_mul(LCLK_FAST_SKEW_fp, tu->lwidth_fp);\n\n\tif (temp2_fp)\n\t\ttemp = drm_fixp2int_ceil(temp2_fp);\n\telse\n\t\ttemp = 0;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->nlanes, 1);\n\ttemp2_fp = drm_fixp_mul(tu->original_ratio_fp, temp1_fp);\n\ttemp1_fp = drm_fixp_from_fraction(tu->bpp, 8);\n\ttemp2_fp = drm_fixp_div(temp1_fp, temp2_fp);\n\ttemp1_fp = drm_fixp_from_fraction(temp, 1);\n\ttemp2_fp = drm_fixp_mul(temp1_fp, temp2_fp);\n\ttemp = drm_fixp2int(temp2_fp);\n\n\tif (tu->async_en)\n\t\ttu->delay_start_link += (int)temp;\n\n\ttemp1_fp = drm_fixp_from_fraction(tu->delay_start_link, 1);\n\ttu->delay_start_time_fp = drm_fixp_div(temp1_fp, tu->lclk_fp);\n\n\t \n\ttu_table->valid_boundary_link       = tu->valid_boundary_link;\n\ttu_table->delay_start_link          = tu->delay_start_link;\n\ttu_table->boundary_moderation_en    = tu->boundary_moderation_en;\n\ttu_table->valid_lower_boundary_link = tu->valid_lower_boundary_link;\n\ttu_table->upper_boundary_count      = tu->upper_boundary_count;\n\ttu_table->lower_boundary_count      = tu->lower_boundary_count;\n\ttu_table->tu_size_minus1            = tu->tu_size_minus1;\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"TU: valid_boundary_link: %d\\n\",\n\t\t\t\ttu_table->valid_boundary_link);\n\tdrm_dbg_dp(ctrl->drm_dev, \"TU: delay_start_link: %d\\n\",\n\t\t\t\ttu_table->delay_start_link);\n\tdrm_dbg_dp(ctrl->drm_dev, \"TU: boundary_moderation_en: %d\\n\",\n\t\t\ttu_table->boundary_moderation_en);\n\tdrm_dbg_dp(ctrl->drm_dev, \"TU: valid_lower_boundary_link: %d\\n\",\n\t\t\ttu_table->valid_lower_boundary_link);\n\tdrm_dbg_dp(ctrl->drm_dev, \"TU: upper_boundary_count: %d\\n\",\n\t\t\ttu_table->upper_boundary_count);\n\tdrm_dbg_dp(ctrl->drm_dev, \"TU: lower_boundary_count: %d\\n\",\n\t\t\ttu_table->lower_boundary_count);\n\tdrm_dbg_dp(ctrl->drm_dev, \"TU: tu_size_minus1: %d\\n\",\n\t\t\ttu_table->tu_size_minus1);\n\n\tkfree(tu);\n}\n\nstatic void dp_ctrl_calc_tu_parameters(struct dp_ctrl_private *ctrl,\n\t\tstruct dp_vc_tu_mapping_table *tu_table)\n{\n\tstruct dp_tu_calc_input in;\n\tstruct drm_display_mode *drm_mode;\n\n\tdrm_mode = &ctrl->panel->dp_mode.drm_mode;\n\n\tin.lclk = ctrl->link->link_params.rate / 1000;\n\tin.pclk_khz = drm_mode->clock;\n\tin.hactive = drm_mode->hdisplay;\n\tin.hporch = drm_mode->htotal - drm_mode->hdisplay;\n\tin.nlanes = ctrl->link->link_params.num_lanes;\n\tin.bpp = ctrl->panel->dp_mode.bpp;\n\tin.pixel_enc = 444;\n\tin.dsc_en = 0;\n\tin.async_en = 0;\n\tin.fec_en = 0;\n\tin.num_of_dsc_slices = 0;\n\tin.compress_ratio = 100;\n\n\t_dp_ctrl_calc_tu(ctrl, &in, tu_table);\n}\n\nstatic void dp_ctrl_setup_tr_unit(struct dp_ctrl_private *ctrl)\n{\n\tu32 dp_tu = 0x0;\n\tu32 valid_boundary = 0x0;\n\tu32 valid_boundary2 = 0x0;\n\tstruct dp_vc_tu_mapping_table tu_calc_table;\n\n\tdp_ctrl_calc_tu_parameters(ctrl, &tu_calc_table);\n\n\tdp_tu |= tu_calc_table.tu_size_minus1;\n\tvalid_boundary |= tu_calc_table.valid_boundary_link;\n\tvalid_boundary |= (tu_calc_table.delay_start_link << 16);\n\n\tvalid_boundary2 |= (tu_calc_table.valid_lower_boundary_link << 1);\n\tvalid_boundary2 |= (tu_calc_table.upper_boundary_count << 16);\n\tvalid_boundary2 |= (tu_calc_table.lower_boundary_count << 20);\n\n\tif (tu_calc_table.boundary_moderation_en)\n\t\tvalid_boundary2 |= BIT(0);\n\n\tpr_debug(\"dp_tu=0x%x, valid_boundary=0x%x, valid_boundary2=0x%x\\n\",\n\t\t\tdp_tu, valid_boundary, valid_boundary2);\n\n\tdp_catalog_ctrl_update_transfer_unit(ctrl->catalog,\n\t\t\t\tdp_tu, valid_boundary, valid_boundary2);\n}\n\nstatic int dp_ctrl_wait4video_ready(struct dp_ctrl_private *ctrl)\n{\n\tint ret = 0;\n\n\tif (!wait_for_completion_timeout(&ctrl->video_comp,\n\t\t\t\tWAIT_FOR_VIDEO_READY_TIMEOUT_JIFFIES)) {\n\t\tDRM_ERROR(\"wait4video timedout\\n\");\n\t\tret = -ETIMEDOUT;\n\t}\n\treturn ret;\n}\n\nstatic int dp_ctrl_update_vx_px(struct dp_ctrl_private *ctrl)\n{\n\tstruct dp_link *link = ctrl->link;\n\tint ret = 0, lane, lane_cnt;\n\tu8 buf[4];\n\tu32 max_level_reached = 0;\n\tu32 voltage_swing_level = link->phy_params.v_level;\n\tu32 pre_emphasis_level = link->phy_params.p_level;\n\n\tdrm_dbg_dp(ctrl->drm_dev,\n\t\t\"voltage level: %d emphasis level: %d\\n\",\n\t\t\tvoltage_swing_level, pre_emphasis_level);\n\tret = dp_catalog_ctrl_update_vx_px(ctrl->catalog,\n\t\tvoltage_swing_level, pre_emphasis_level);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (voltage_swing_level >= DP_TRAIN_VOLTAGE_SWING_MAX) {\n\t\tdrm_dbg_dp(ctrl->drm_dev,\n\t\t\t\t\"max. voltage swing level reached %d\\n\",\n\t\t\t\tvoltage_swing_level);\n\t\tmax_level_reached |= DP_TRAIN_MAX_SWING_REACHED;\n\t}\n\n\tif (pre_emphasis_level >= DP_TRAIN_PRE_EMPHASIS_MAX) {\n\t\tdrm_dbg_dp(ctrl->drm_dev,\n\t\t\t\t\"max. pre-emphasis level reached %d\\n\",\n\t\t\t\tpre_emphasis_level);\n\t\tmax_level_reached  |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\n\t}\n\n\tpre_emphasis_level <<= DP_TRAIN_PRE_EMPHASIS_SHIFT;\n\n\tlane_cnt = ctrl->link->link_params.num_lanes;\n\tfor (lane = 0; lane < lane_cnt; lane++)\n\t\tbuf[lane] = voltage_swing_level | pre_emphasis_level\n\t\t\t\t| max_level_reached;\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"sink: p|v=0x%x\\n\",\n\t\t\tvoltage_swing_level | pre_emphasis_level);\n\tret = drm_dp_dpcd_write(ctrl->aux, DP_TRAINING_LANE0_SET,\n\t\t\t\t\tbuf, lane_cnt);\n\tif (ret == lane_cnt)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic bool dp_ctrl_train_pattern_set(struct dp_ctrl_private *ctrl,\n\t\tu8 pattern)\n{\n\tu8 buf;\n\tint ret = 0;\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"sink: pattern=%x\\n\", pattern);\n\n\tbuf = pattern;\n\n\tif (pattern && pattern != DP_TRAINING_PATTERN_4)\n\t\tbuf |= DP_LINK_SCRAMBLING_DISABLE;\n\n\tret = drm_dp_dpcd_writeb(ctrl->aux, DP_TRAINING_PATTERN_SET, buf);\n\treturn ret == 1;\n}\n\nstatic int dp_ctrl_read_link_status(struct dp_ctrl_private *ctrl,\n\t\t\t\t    u8 *link_status)\n{\n\tint ret = 0, len;\n\n\tlen = drm_dp_dpcd_read_link_status(ctrl->aux, link_status);\n\tif (len != DP_LINK_STATUS_SIZE) {\n\t\tDRM_ERROR(\"DP link status read failed, err: %d\\n\", len);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int dp_ctrl_link_train_1(struct dp_ctrl_private *ctrl,\n\t\t\tint *training_step)\n{\n\tint tries, old_v_level, ret = 0;\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tint const maximum_retries = 4;\n\n\tdp_catalog_ctrl_state_ctrl(ctrl->catalog, 0);\n\n\t*training_step = DP_TRAINING_1;\n\n\tret = dp_catalog_ctrl_set_pattern_state_bit(ctrl->catalog, 1);\n\tif (ret)\n\t\treturn ret;\n\tdp_ctrl_train_pattern_set(ctrl, DP_TRAINING_PATTERN_1 |\n\t\tDP_LINK_SCRAMBLING_DISABLE);\n\n\tret = dp_ctrl_update_vx_px(ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\ttries = 0;\n\told_v_level = ctrl->link->phy_params.v_level;\n\tfor (tries = 0; tries < maximum_retries; tries++) {\n\t\tdrm_dp_link_train_clock_recovery_delay(ctrl->aux, ctrl->panel->dpcd);\n\n\t\tret = dp_ctrl_read_link_status(ctrl, link_status);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (drm_dp_clock_recovery_ok(link_status,\n\t\t\tctrl->link->link_params.num_lanes)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ctrl->link->phy_params.v_level >=\n\t\t\tDP_TRAIN_VOLTAGE_SWING_MAX) {\n\t\t\tDRM_ERROR_RATELIMITED(\"max v_level reached\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (old_v_level != ctrl->link->phy_params.v_level) {\n\t\t\ttries = 0;\n\t\t\told_v_level = ctrl->link->phy_params.v_level;\n\t\t}\n\n\t\tdp_link_adjust_levels(ctrl->link, link_status);\n\t\tret = dp_ctrl_update_vx_px(ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tDRM_ERROR(\"max tries reached\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int dp_ctrl_link_rate_down_shift(struct dp_ctrl_private *ctrl)\n{\n\tint ret = 0;\n\n\tswitch (ctrl->link->link_params.rate) {\n\tcase 810000:\n\t\tctrl->link->link_params.rate = 540000;\n\t\tbreak;\n\tcase 540000:\n\t\tctrl->link->link_params.rate = 270000;\n\t\tbreak;\n\tcase 270000:\n\t\tctrl->link->link_params.rate = 162000;\n\t\tbreak;\n\tcase 162000:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tdrm_dbg_dp(ctrl->drm_dev, \"new rate=0x%x\\n\",\n\t\t\t\tctrl->link->link_params.rate);\n\t}\n\n\treturn ret;\n}\n\nstatic int dp_ctrl_link_lane_down_shift(struct dp_ctrl_private *ctrl)\n{\n\n\tif (ctrl->link->link_params.num_lanes == 1)\n\t\treturn -1;\n\n\tctrl->link->link_params.num_lanes /= 2;\n\tctrl->link->link_params.rate = ctrl->panel->link_info.rate;\n\n\tctrl->link->phy_params.p_level = 0;\n\tctrl->link->phy_params.v_level = 0;\n\n\treturn 0;\n}\n\nstatic void dp_ctrl_clear_training_pattern(struct dp_ctrl_private *ctrl)\n{\n\tdp_ctrl_train_pattern_set(ctrl, DP_TRAINING_PATTERN_DISABLE);\n\tdrm_dp_link_train_channel_eq_delay(ctrl->aux, ctrl->panel->dpcd);\n}\n\nstatic int dp_ctrl_link_train_2(struct dp_ctrl_private *ctrl,\n\t\t\tint *training_step)\n{\n\tint tries = 0, ret = 0;\n\tu8 pattern;\n\tu32 state_ctrl_bit;\n\tint const maximum_retries = 5;\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\n\tdp_catalog_ctrl_state_ctrl(ctrl->catalog, 0);\n\n\t*training_step = DP_TRAINING_2;\n\n\tif (drm_dp_tps4_supported(ctrl->panel->dpcd)) {\n\t\tpattern = DP_TRAINING_PATTERN_4;\n\t\tstate_ctrl_bit = 4;\n\t} else if (drm_dp_tps3_supported(ctrl->panel->dpcd)) {\n\t\tpattern = DP_TRAINING_PATTERN_3;\n\t\tstate_ctrl_bit = 3;\n\t} else {\n\t\tpattern = DP_TRAINING_PATTERN_2;\n\t\tstate_ctrl_bit = 2;\n\t}\n\n\tret = dp_catalog_ctrl_set_pattern_state_bit(ctrl->catalog, state_ctrl_bit);\n\tif (ret)\n\t\treturn ret;\n\n\tdp_ctrl_train_pattern_set(ctrl, pattern);\n\n\tfor (tries = 0; tries <= maximum_retries; tries++) {\n\t\tdrm_dp_link_train_channel_eq_delay(ctrl->aux, ctrl->panel->dpcd);\n\n\t\tret = dp_ctrl_read_link_status(ctrl, link_status);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (drm_dp_channel_eq_ok(link_status,\n\t\t\tctrl->link->link_params.num_lanes)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tdp_link_adjust_levels(ctrl->link, link_status);\n\t\tret = dp_ctrl_update_vx_px(ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int dp_ctrl_link_train(struct dp_ctrl_private *ctrl,\n\t\t\tint *training_step)\n{\n\tint ret = 0;\n\tconst u8 *dpcd = ctrl->panel->dpcd;\n\tu8 encoding[] = { 0, DP_SET_ANSI_8B10B };\n\tu8 assr;\n\tstruct dp_link_info link_info = {0};\n\n\tdp_ctrl_config_ctrl(ctrl);\n\n\tlink_info.num_lanes = ctrl->link->link_params.num_lanes;\n\tlink_info.rate = ctrl->link->link_params.rate;\n\tlink_info.capabilities = DP_LINK_CAP_ENHANCED_FRAMING;\n\n\tdp_aux_link_configure(ctrl->aux, &link_info);\n\n\tif (drm_dp_max_downspread(dpcd))\n\t\tencoding[0] |= DP_SPREAD_AMP_0_5;\n\n\t \n\tdrm_dp_dpcd_write(ctrl->aux, DP_DOWNSPREAD_CTRL, encoding, 2);\n\n\tif (drm_dp_alternate_scrambler_reset_cap(dpcd)) {\n\t\tassr = DP_ALTERNATE_SCRAMBLER_RESET_ENABLE;\n\t\tdrm_dp_dpcd_write(ctrl->aux, DP_EDP_CONFIGURATION_SET,\n\t\t\t\t&assr, 1);\n\t}\n\n\tret = dp_ctrl_link_train_1(ctrl, training_step);\n\tif (ret) {\n\t\tDRM_ERROR(\"link training #1 failed. ret=%d\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t \n\tdrm_dbg_dp(ctrl->drm_dev, \"link training #1 successful\\n\");\n\n\tret = dp_ctrl_link_train_2(ctrl, training_step);\n\tif (ret) {\n\t\tDRM_ERROR(\"link training #2 failed. ret=%d\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t \n\tdrm_dbg_dp(ctrl->drm_dev, \"link training #2 successful\\n\");\n\nend:\n\tdp_catalog_ctrl_state_ctrl(ctrl->catalog, 0);\n\n\treturn ret;\n}\n\nstatic int dp_ctrl_setup_main_link(struct dp_ctrl_private *ctrl,\n\t\t\tint *training_step)\n{\n\tint ret = 0;\n\n\tdp_catalog_ctrl_mainlink_ctrl(ctrl->catalog, true);\n\n\tif (ctrl->link->sink_request & DP_TEST_LINK_PHY_TEST_PATTERN)\n\t\treturn ret;\n\n\t \n\n\tret = dp_ctrl_link_train(ctrl, training_step);\n\n\treturn ret;\n}\n\nstatic void dp_ctrl_set_clock_rate(struct dp_ctrl_private *ctrl,\n\t\t\tenum dp_pm_type module, char *name, unsigned long rate)\n{\n\tu32 num = ctrl->parser->mp[module].num_clk;\n\tstruct clk_bulk_data *cfg = ctrl->parser->mp[module].clocks;\n\n\twhile (num && strcmp(cfg->id, name)) {\n\t\tnum--;\n\t\tcfg++;\n\t}\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"setting rate=%lu on clk=%s\\n\",\n\t\t\t\t\t\trate, name);\n\n\tif (num)\n\t\tclk_set_rate(cfg->clk, rate);\n\telse\n\t\tDRM_ERROR(\"%s clock doesn't exit to set rate %lu\\n\",\n\t\t\t\tname, rate);\n}\n\nstatic int dp_ctrl_enable_mainlink_clocks(struct dp_ctrl_private *ctrl)\n{\n\tint ret = 0;\n\tstruct dp_io *dp_io = &ctrl->parser->io;\n\tstruct phy *phy = dp_io->phy;\n\tstruct phy_configure_opts_dp *opts_dp = &dp_io->phy_opts.dp;\n\tconst u8 *dpcd = ctrl->panel->dpcd;\n\n\topts_dp->lanes = ctrl->link->link_params.num_lanes;\n\topts_dp->link_rate = ctrl->link->link_params.rate / 100;\n\topts_dp->ssc = drm_dp_max_downspread(dpcd);\n\n\tphy_configure(phy, &dp_io->phy_opts);\n\tphy_power_on(phy);\n\n\tdev_pm_opp_set_rate(ctrl->dev, ctrl->link->link_params.rate * 1000);\n\tret = dp_power_clk_enable(ctrl->power, DP_CTRL_PM, true);\n\tif (ret)\n\t\tDRM_ERROR(\"Unable to start link clocks. ret=%d\\n\", ret);\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"link rate=%d\\n\", ctrl->link->link_params.rate);\n\n\treturn ret;\n}\n\nvoid dp_ctrl_reset_irq_ctrl(struct dp_ctrl *dp_ctrl, bool enable)\n{\n\tstruct dp_ctrl_private *ctrl;\n\n\tctrl = container_of(dp_ctrl, struct dp_ctrl_private, dp_ctrl);\n\n\tdp_catalog_ctrl_reset(ctrl->catalog);\n\n\t \n\tdp_catalog_ctrl_enable_irq(ctrl->catalog, enable);\n}\n\nvoid dp_ctrl_config_psr(struct dp_ctrl *dp_ctrl)\n{\n\tu8 cfg;\n\tstruct dp_ctrl_private *ctrl = container_of(dp_ctrl,\n\t\t\tstruct dp_ctrl_private, dp_ctrl);\n\n\tif (!ctrl->panel->psr_cap.version)\n\t\treturn;\n\n\tdp_catalog_ctrl_config_psr(ctrl->catalog);\n\n\tcfg = DP_PSR_ENABLE;\n\tdrm_dp_dpcd_write(ctrl->aux, DP_PSR_EN_CFG, &cfg, 1);\n}\n\nvoid dp_ctrl_set_psr(struct dp_ctrl *dp_ctrl, bool enter)\n{\n\tstruct dp_ctrl_private *ctrl = container_of(dp_ctrl,\n\t\t\tstruct dp_ctrl_private, dp_ctrl);\n\n\tif (!ctrl->panel->psr_cap.version)\n\t\treturn;\n\n\t \n\tif (enter) {\n\t\treinit_completion(&ctrl->psr_op_comp);\n\t\tdp_catalog_ctrl_set_psr(ctrl->catalog, true);\n\n\t\tif (!wait_for_completion_timeout(&ctrl->psr_op_comp,\n\t\t\tPSR_OPERATION_COMPLETION_TIMEOUT_JIFFIES)) {\n\t\t\tDRM_ERROR(\"PSR_ENTRY timedout\\n\");\n\t\t\tdp_catalog_ctrl_set_psr(ctrl->catalog, false);\n\t\t\treturn;\n\t\t}\n\n\t\tdp_ctrl_push_idle(dp_ctrl);\n\t\tdp_catalog_ctrl_state_ctrl(ctrl->catalog, 0);\n\n\t\tdp_catalog_ctrl_psr_mainlink_enable(ctrl->catalog, false);\n\t} else {\n\t\tdp_catalog_ctrl_psr_mainlink_enable(ctrl->catalog, true);\n\n\t\tdp_catalog_ctrl_set_psr(ctrl->catalog, false);\n\t\tdp_catalog_ctrl_state_ctrl(ctrl->catalog, DP_STATE_CTRL_SEND_VIDEO);\n\t\tdp_ctrl_wait4video_ready(ctrl);\n\t\tdp_catalog_ctrl_state_ctrl(ctrl->catalog, 0);\n\t}\n}\n\nvoid dp_ctrl_phy_init(struct dp_ctrl *dp_ctrl)\n{\n\tstruct dp_ctrl_private *ctrl;\n\tstruct dp_io *dp_io;\n\tstruct phy *phy;\n\n\tctrl = container_of(dp_ctrl, struct dp_ctrl_private, dp_ctrl);\n\tdp_io = &ctrl->parser->io;\n\tphy = dp_io->phy;\n\n\tdp_catalog_ctrl_phy_reset(ctrl->catalog);\n\tphy_init(phy);\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"phy=%p init=%d power_on=%d\\n\",\n\t\t\tphy, phy->init_count, phy->power_count);\n}\n\nvoid dp_ctrl_phy_exit(struct dp_ctrl *dp_ctrl)\n{\n\tstruct dp_ctrl_private *ctrl;\n\tstruct dp_io *dp_io;\n\tstruct phy *phy;\n\n\tctrl = container_of(dp_ctrl, struct dp_ctrl_private, dp_ctrl);\n\tdp_io = &ctrl->parser->io;\n\tphy = dp_io->phy;\n\n\tdp_catalog_ctrl_phy_reset(ctrl->catalog);\n\tphy_exit(phy);\n\tdrm_dbg_dp(ctrl->drm_dev, \"phy=%p init=%d power_on=%d\\n\",\n\t\t\tphy, phy->init_count, phy->power_count);\n}\n\nstatic bool dp_ctrl_use_fixed_nvid(struct dp_ctrl_private *ctrl)\n{\n\tconst u8 *dpcd = ctrl->panel->dpcd;\n\n\t \n\tif (drm_dp_is_branch(dpcd))\n\t\treturn (drm_dp_has_quirk(&ctrl->panel->desc,\n\t\t\t\t\t DP_DPCD_QUIRK_CONSTANT_N));\n\n\treturn false;\n}\n\nstatic int dp_ctrl_reinitialize_mainlink(struct dp_ctrl_private *ctrl)\n{\n\tint ret = 0;\n\tstruct dp_io *dp_io = &ctrl->parser->io;\n\tstruct phy *phy = dp_io->phy;\n\tstruct phy_configure_opts_dp *opts_dp = &dp_io->phy_opts.dp;\n\n\tdp_catalog_ctrl_mainlink_ctrl(ctrl->catalog, false);\n\topts_dp->lanes = ctrl->link->link_params.num_lanes;\n\tphy_configure(phy, &dp_io->phy_opts);\n\t \n\tdev_pm_opp_set_rate(ctrl->dev, 0);\n\tret = dp_power_clk_enable(ctrl->power, DP_CTRL_PM, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to disable clocks. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\tphy_power_off(phy);\n\t \n\tmsleep(20);\n\n\tret = dp_ctrl_enable_mainlink_clocks(ctrl);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to enable mainlink clks. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int dp_ctrl_deinitialize_mainlink(struct dp_ctrl_private *ctrl)\n{\n\tstruct dp_io *dp_io;\n\tstruct phy *phy;\n\tint ret;\n\n\tdp_io = &ctrl->parser->io;\n\tphy = dp_io->phy;\n\n\tdp_catalog_ctrl_mainlink_ctrl(ctrl->catalog, false);\n\n\tdp_catalog_ctrl_reset(ctrl->catalog);\n\n\tdev_pm_opp_set_rate(ctrl->dev, 0);\n\tret = dp_power_clk_enable(ctrl->power, DP_CTRL_PM, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to disable link clocks. ret=%d\\n\", ret);\n\t}\n\n\tphy_power_off(phy);\n\n\t \n\tphy_exit(phy);\n\tphy_init(phy);\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"phy=%p init=%d power_on=%d\\n\",\n\t\t\tphy, phy->init_count, phy->power_count);\n\treturn 0;\n}\n\nstatic int dp_ctrl_link_maintenance(struct dp_ctrl_private *ctrl)\n{\n\tint ret = 0;\n\tint training_step = DP_TRAINING_NONE;\n\n\tdp_ctrl_push_idle(&ctrl->dp_ctrl);\n\n\tctrl->link->phy_params.p_level = 0;\n\tctrl->link->phy_params.v_level = 0;\n\n\tret = dp_ctrl_setup_main_link(ctrl, &training_step);\n\tif (ret)\n\t\tgoto end;\n\n\tdp_ctrl_clear_training_pattern(ctrl);\n\n\tdp_catalog_ctrl_state_ctrl(ctrl->catalog, DP_STATE_CTRL_SEND_VIDEO);\n\n\tret = dp_ctrl_wait4video_ready(ctrl);\nend:\n\treturn ret;\n}\n\nstatic bool dp_ctrl_send_phy_test_pattern(struct dp_ctrl_private *ctrl)\n{\n\tbool success = false;\n\tu32 pattern_sent = 0x0;\n\tu32 pattern_requested = ctrl->link->phy_params.phy_test_pattern_sel;\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"request: 0x%x\\n\", pattern_requested);\n\n\tif (dp_catalog_ctrl_update_vx_px(ctrl->catalog,\n\t\t\tctrl->link->phy_params.v_level,\n\t\t\tctrl->link->phy_params.p_level)) {\n\t\tDRM_ERROR(\"Failed to set v/p levels\\n\");\n\t\treturn false;\n\t}\n\tdp_catalog_ctrl_send_phy_pattern(ctrl->catalog, pattern_requested);\n\tdp_ctrl_update_vx_px(ctrl);\n\tdp_link_send_test_response(ctrl->link);\n\n\tpattern_sent = dp_catalog_ctrl_read_phy_pattern(ctrl->catalog);\n\n\tswitch (pattern_sent) {\n\tcase MR_LINK_TRAINING1:\n\t\tsuccess = (pattern_requested ==\n\t\t\t\tDP_PHY_TEST_PATTERN_D10_2);\n\t\tbreak;\n\tcase MR_LINK_SYMBOL_ERM:\n\t\tsuccess = ((pattern_requested ==\n\t\t\tDP_PHY_TEST_PATTERN_ERROR_COUNT) ||\n\t\t\t\t(pattern_requested ==\n\t\t\t\tDP_PHY_TEST_PATTERN_CP2520));\n\t\tbreak;\n\tcase MR_LINK_PRBS7:\n\t\tsuccess = (pattern_requested ==\n\t\t\t\tDP_PHY_TEST_PATTERN_PRBS7);\n\t\tbreak;\n\tcase MR_LINK_CUSTOM80:\n\t\tsuccess = (pattern_requested ==\n\t\t\t\tDP_PHY_TEST_PATTERN_80BIT_CUSTOM);\n\t\tbreak;\n\tcase MR_LINK_TRAINING4:\n\t\tsuccess = (pattern_requested ==\n\t\t\t\tDP_PHY_TEST_PATTERN_SEL_MASK);\n\t\tbreak;\n\tdefault:\n\t\tsuccess = false;\n\t}\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"%s: test->0x%x\\n\",\n\t\tsuccess ? \"success\" : \"failed\", pattern_requested);\n\treturn success;\n}\n\nstatic int dp_ctrl_process_phy_test_request(struct dp_ctrl_private *ctrl)\n{\n\tint ret;\n\tunsigned long pixel_rate;\n\n\tif (!ctrl->link->phy_params.phy_test_pattern_sel) {\n\t\tdrm_dbg_dp(ctrl->drm_dev,\n\t\t\t\"no test pattern selected by sink\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tret = dp_ctrl_off(&ctrl->dp_ctrl);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to disable DP controller\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dp_ctrl_on_link(&ctrl->dp_ctrl);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to enable DP link controller\\n\");\n\t\treturn ret;\n\t}\n\n\tpixel_rate = ctrl->panel->dp_mode.drm_mode.clock;\n\tdp_ctrl_set_clock_rate(ctrl, DP_STREAM_PM, \"stream_pixel\", pixel_rate * 1000);\n\n\tret = dp_power_clk_enable(ctrl->power, DP_STREAM_PM, true);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to start pixel clocks. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdp_ctrl_send_phy_test_pattern(ctrl);\n\n\treturn 0;\n}\n\nvoid dp_ctrl_handle_sink_request(struct dp_ctrl *dp_ctrl)\n{\n\tstruct dp_ctrl_private *ctrl;\n\tu32 sink_request = 0x0;\n\n\tif (!dp_ctrl) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn;\n\t}\n\n\tctrl = container_of(dp_ctrl, struct dp_ctrl_private, dp_ctrl);\n\tsink_request = ctrl->link->sink_request;\n\n\tif (sink_request & DP_TEST_LINK_PHY_TEST_PATTERN) {\n\t\tdrm_dbg_dp(ctrl->drm_dev, \"PHY_TEST_PATTERN request\\n\");\n\t\tif (dp_ctrl_process_phy_test_request(ctrl)) {\n\t\t\tDRM_ERROR(\"process phy_test_req failed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sink_request & DP_LINK_STATUS_UPDATED) {\n\t\tif (dp_ctrl_link_maintenance(ctrl)) {\n\t\t\tDRM_ERROR(\"LM failed: TEST_LINK_TRAINING\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sink_request & DP_TEST_LINK_TRAINING) {\n\t\tdp_link_send_test_response(ctrl->link);\n\t\tif (dp_ctrl_link_maintenance(ctrl)) {\n\t\t\tDRM_ERROR(\"LM failed: TEST_LINK_TRAINING\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic bool dp_ctrl_clock_recovery_any_ok(\n\t\t\tconst u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\tint lane_count)\n{\n\tint reduced_cnt;\n\n\tif (lane_count <= 1)\n\t\treturn false;\n\n\t \n\treduced_cnt = lane_count >> 1;\n\n\treturn drm_dp_clock_recovery_ok(link_status, reduced_cnt);\n}\n\nstatic bool dp_ctrl_channel_eq_ok(struct dp_ctrl_private *ctrl)\n{\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tint num_lanes = ctrl->link->link_params.num_lanes;\n\n\tdp_ctrl_read_link_status(ctrl, link_status);\n\n\treturn drm_dp_channel_eq_ok(link_status, num_lanes);\n}\n\nint dp_ctrl_on_link(struct dp_ctrl *dp_ctrl)\n{\n\tint rc = 0;\n\tstruct dp_ctrl_private *ctrl;\n\tu32 rate;\n\tint link_train_max_retries = 5;\n\tu32 const phy_cts_pixel_clk_khz = 148500;\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tunsigned int training_step;\n\tunsigned long pixel_rate;\n\n\tif (!dp_ctrl)\n\t\treturn -EINVAL;\n\n\tctrl = container_of(dp_ctrl, struct dp_ctrl_private, dp_ctrl);\n\n\trate = ctrl->panel->link_info.rate;\n\tpixel_rate = ctrl->panel->dp_mode.drm_mode.clock;\n\n\tdp_power_clk_enable(ctrl->power, DP_CORE_PM, true);\n\n\tif (ctrl->link->sink_request & DP_TEST_LINK_PHY_TEST_PATTERN) {\n\t\tdrm_dbg_dp(ctrl->drm_dev,\n\t\t\t\t\"using phy test link parameters\\n\");\n\t\tif (!pixel_rate)\n\t\t\tpixel_rate = phy_cts_pixel_clk_khz;\n\t} else {\n\t\tctrl->link->link_params.rate = rate;\n\t\tctrl->link->link_params.num_lanes =\n\t\t\tctrl->panel->link_info.num_lanes;\n\t}\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"rate=%d, num_lanes=%d, pixel_rate=%lu\\n\",\n\t\tctrl->link->link_params.rate, ctrl->link->link_params.num_lanes,\n\t\tpixel_rate);\n\n\trc = dp_ctrl_enable_mainlink_clocks(ctrl);\n\tif (rc)\n\t\treturn rc;\n\n\twhile (--link_train_max_retries) {\n\t\ttraining_step = DP_TRAINING_NONE;\n\t\trc = dp_ctrl_setup_main_link(ctrl, &training_step);\n\t\tif (rc == 0) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else if (training_step == DP_TRAINING_1) {\n\t\t\t \n\t\t\tif (!dp_catalog_link_is_connected(ctrl->catalog))\n\t\t\t\tbreak;\n\n\t\t\tdp_ctrl_read_link_status(ctrl, link_status);\n\n\t\t\trc = dp_ctrl_link_rate_down_shift(ctrl);\n\t\t\tif (rc < 0) {  \n\t\t\t\tif (dp_ctrl_clock_recovery_any_ok(link_status,\n\t\t\t\t\tctrl->link->link_params.num_lanes)) {\n\t\t\t\t\t \n\t\t\t\t\trc = dp_ctrl_link_lane_down_shift(ctrl);\n\t\t\t\t\tif (rc < 0) {  \n\t\t\t\t\t\t \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tbreak;  \n\t\t\t\t}\n\t\t\t}\n\t\t} else if (training_step == DP_TRAINING_2) {\n\t\t\t \n\t\t\tif (!dp_catalog_link_is_connected(ctrl->catalog))\n\t\t\t\tbreak;\n\n\t\t\tdp_ctrl_read_link_status(ctrl, link_status);\n\n\t\t\tif (!drm_dp_clock_recovery_ok(link_status,\n\t\t\t\t\tctrl->link->link_params.num_lanes))\n\t\t\t\trc = dp_ctrl_link_rate_down_shift(ctrl);\n\t\t\telse\n\t\t\t\trc = dp_ctrl_link_lane_down_shift(ctrl);\n\n\t\t\tif (rc < 0) {\n\t\t\t\t \n\t\t\t\tbreak;  \n\t\t\t}\n\n\t\t\t \n\t\t\tdp_ctrl_clear_training_pattern(ctrl);\n\t\t}\n\n\t\trc = dp_ctrl_reinitialize_mainlink(ctrl);\n\t\tif (rc) {\n\t\t\tDRM_ERROR(\"Failed to reinitialize mainlink. rc=%d\\n\", rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctrl->link->sink_request & DP_TEST_LINK_PHY_TEST_PATTERN)\n\t\treturn rc;\n\n\tif (rc == 0) {   \n\t\t \n\t} else  {\n\t\t \n\t\tdp_ctrl_clear_training_pattern(ctrl);\n\n\t\tdp_ctrl_deinitialize_mainlink(ctrl);\n\t\trc = -ECONNRESET;\n\t}\n\n\treturn rc;\n}\n\nstatic int dp_ctrl_link_retrain(struct dp_ctrl_private *ctrl)\n{\n\tint training_step = DP_TRAINING_NONE;\n\n\treturn dp_ctrl_setup_main_link(ctrl, &training_step);\n}\n\nint dp_ctrl_on_stream(struct dp_ctrl *dp_ctrl, bool force_link_train)\n{\n\tint ret = 0;\n\tbool mainlink_ready = false;\n\tstruct dp_ctrl_private *ctrl;\n\tunsigned long pixel_rate;\n\tunsigned long pixel_rate_orig;\n\n\tif (!dp_ctrl)\n\t\treturn -EINVAL;\n\n\tctrl = container_of(dp_ctrl, struct dp_ctrl_private, dp_ctrl);\n\n\tpixel_rate = pixel_rate_orig = ctrl->panel->dp_mode.drm_mode.clock;\n\n\tif (dp_ctrl->wide_bus_en)\n\t\tpixel_rate >>= 1;\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"rate=%d, num_lanes=%d, pixel_rate=%lu\\n\",\n\t\tctrl->link->link_params.rate,\n\t\tctrl->link->link_params.num_lanes, pixel_rate);\n\n\tif (!dp_power_clk_status(ctrl->power, DP_CTRL_PM)) {  \n\t\tret = dp_ctrl_enable_mainlink_clocks(ctrl);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to start link clocks. ret=%d\\n\", ret);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tdp_ctrl_set_clock_rate(ctrl, DP_STREAM_PM, \"stream_pixel\", pixel_rate * 1000);\n\n\tret = dp_power_clk_enable(ctrl->power, DP_STREAM_PM, true);\n\tif (ret) {\n\t\tDRM_ERROR(\"Unable to start pixel clocks. ret=%d\\n\", ret);\n\t\tgoto end;\n\t}\n\n\tif (force_link_train || !dp_ctrl_channel_eq_ok(ctrl))\n\t\tdp_ctrl_link_retrain(ctrl);\n\n\t \n\tdp_ctrl_clear_training_pattern(ctrl);\n\n\t \n\treinit_completion(&ctrl->video_comp);\n\n\tdp_ctrl_configure_source_params(ctrl);\n\n\tdp_catalog_ctrl_config_msa(ctrl->catalog,\n\t\tctrl->link->link_params.rate,\n\t\tpixel_rate_orig, dp_ctrl_use_fixed_nvid(ctrl));\n\n\tdp_ctrl_setup_tr_unit(ctrl);\n\n\tdp_catalog_ctrl_state_ctrl(ctrl->catalog, DP_STATE_CTRL_SEND_VIDEO);\n\n\tret = dp_ctrl_wait4video_ready(ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tmainlink_ready = dp_catalog_ctrl_mainlink_ready(ctrl->catalog);\n\tdrm_dbg_dp(ctrl->drm_dev,\n\t\t\"mainlink %s\\n\", mainlink_ready ? \"READY\" : \"NOT READY\");\n\nend:\n\treturn ret;\n}\n\nint dp_ctrl_off_link_stream(struct dp_ctrl *dp_ctrl)\n{\n\tstruct dp_ctrl_private *ctrl;\n\tstruct dp_io *dp_io;\n\tstruct phy *phy;\n\tint ret;\n\n\tctrl = container_of(dp_ctrl, struct dp_ctrl_private, dp_ctrl);\n\tdp_io = &ctrl->parser->io;\n\tphy = dp_io->phy;\n\n\t \n\tdp_link_psm_config(ctrl->link, &ctrl->panel->link_info, true);\n\n\tdp_catalog_ctrl_mainlink_ctrl(ctrl->catalog, false);\n\n\tif (dp_power_clk_status(ctrl->power, DP_STREAM_PM)) {\n\t\tret = dp_power_clk_enable(ctrl->power, DP_STREAM_PM, false);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to disable pclk. ret=%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_pm_opp_set_rate(ctrl->dev, 0);\n\tret = dp_power_clk_enable(ctrl->power, DP_CTRL_PM, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to disable link clocks. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphy_power_off(phy);\n\n\t \n\tphy_exit(phy);\n\tphy_init(phy);\n\n\tdrm_dbg_dp(ctrl->drm_dev, \"phy=%p init=%d power_on=%d\\n\",\n\t\t\tphy, phy->init_count, phy->power_count);\n\treturn ret;\n}\n\nint dp_ctrl_off_link(struct dp_ctrl *dp_ctrl)\n{\n\tstruct dp_ctrl_private *ctrl;\n\tstruct dp_io *dp_io;\n\tstruct phy *phy;\n\tint ret;\n\n\tctrl = container_of(dp_ctrl, struct dp_ctrl_private, dp_ctrl);\n\tdp_io = &ctrl->parser->io;\n\tphy = dp_io->phy;\n\n\tdp_catalog_ctrl_mainlink_ctrl(ctrl->catalog, false);\n\n\tret = dp_power_clk_enable(ctrl->power, DP_CTRL_PM, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to disable link clocks. ret=%d\\n\", ret);\n\t}\n\n\tDRM_DEBUG_DP(\"Before, phy=%p init_count=%d power_on=%d\\n\",\n\t\tphy, phy->init_count, phy->power_count);\n\n\tphy_power_off(phy);\n\n\tDRM_DEBUG_DP(\"After, phy=%p init_count=%d power_on=%d\\n\",\n\t\tphy, phy->init_count, phy->power_count);\n\n\treturn ret;\n}\n\nint dp_ctrl_off(struct dp_ctrl *dp_ctrl)\n{\n\tstruct dp_ctrl_private *ctrl;\n\tstruct dp_io *dp_io;\n\tstruct phy *phy;\n\tint ret = 0;\n\n\tif (!dp_ctrl)\n\t\treturn -EINVAL;\n\n\tctrl = container_of(dp_ctrl, struct dp_ctrl_private, dp_ctrl);\n\tdp_io = &ctrl->parser->io;\n\tphy = dp_io->phy;\n\n\tdp_catalog_ctrl_mainlink_ctrl(ctrl->catalog, false);\n\n\tdp_catalog_ctrl_reset(ctrl->catalog);\n\n\tret = dp_power_clk_enable(ctrl->power, DP_STREAM_PM, false);\n\tif (ret)\n\t\tDRM_ERROR(\"Failed to disable pixel clocks. ret=%d\\n\", ret);\n\n\tdev_pm_opp_set_rate(ctrl->dev, 0);\n\tret = dp_power_clk_enable(ctrl->power, DP_CTRL_PM, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to disable link clocks. ret=%d\\n\", ret);\n\t}\n\n\tphy_power_off(phy);\n\tdrm_dbg_dp(ctrl->drm_dev, \"phy=%p init=%d power_on=%d\\n\",\n\t\t\tphy, phy->init_count, phy->power_count);\n\n\treturn ret;\n}\n\nirqreturn_t dp_ctrl_isr(struct dp_ctrl *dp_ctrl)\n{\n\tstruct dp_ctrl_private *ctrl;\n\tu32 isr;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (!dp_ctrl)\n\t\treturn IRQ_NONE;\n\n\tctrl = container_of(dp_ctrl, struct dp_ctrl_private, dp_ctrl);\n\n\tif (ctrl->panel->psr_cap.version) {\n\t\tisr = dp_catalog_ctrl_read_psr_interrupt_status(ctrl->catalog);\n\n\t\tif (isr)\n\t\t\tcomplete(&ctrl->psr_op_comp);\n\n\t\tif (isr & PSR_EXIT_INT)\n\t\t\tdrm_dbg_dp(ctrl->drm_dev, \"PSR exit done\\n\");\n\n\t\tif (isr & PSR_UPDATE_INT)\n\t\t\tdrm_dbg_dp(ctrl->drm_dev, \"PSR frame update done\\n\");\n\n\t\tif (isr & PSR_CAPTURE_INT)\n\t\t\tdrm_dbg_dp(ctrl->drm_dev, \"PSR frame capture done\\n\");\n\t}\n\n\tisr = dp_catalog_ctrl_get_interrupt(ctrl->catalog);\n\n\n\tif (isr & DP_CTRL_INTR_READY_FOR_VIDEO) {\n\t\tdrm_dbg_dp(ctrl->drm_dev, \"dp_video_ready\\n\");\n\t\tcomplete(&ctrl->video_comp);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (isr & DP_CTRL_INTR_IDLE_PATTERN_SENT) {\n\t\tdrm_dbg_dp(ctrl->drm_dev, \"idle_patterns_sent\\n\");\n\t\tcomplete(&ctrl->idle_comp);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstruct dp_ctrl *dp_ctrl_get(struct device *dev, struct dp_link *link,\n\t\t\tstruct dp_panel *panel,\tstruct drm_dp_aux *aux,\n\t\t\tstruct dp_power *power, struct dp_catalog *catalog,\n\t\t\tstruct dp_parser *parser)\n{\n\tstruct dp_ctrl_private *ctrl;\n\tint ret;\n\n\tif (!dev || !panel || !aux ||\n\t    !link || !catalog) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tctrl = devm_kzalloc(dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl) {\n\t\tDRM_ERROR(\"Mem allocation failure\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tret = devm_pm_opp_set_clkname(dev, \"ctrl_link\");\n\tif (ret) {\n\t\tdev_err(dev, \"invalid DP OPP table in device tree\\n\");\n\t\t \n\t\treturn (struct dp_ctrl *)ERR_PTR(ret);\n\t}\n\n\t \n\tret = devm_pm_opp_of_add_table(dev);\n\tif (ret)\n\t\tdev_err(dev, \"failed to add DP OPP table\\n\");\n\n\tinit_completion(&ctrl->idle_comp);\n\tinit_completion(&ctrl->psr_op_comp);\n\tinit_completion(&ctrl->video_comp);\n\n\t \n\tctrl->parser   = parser;\n\tctrl->panel    = panel;\n\tctrl->power    = power;\n\tctrl->aux      = aux;\n\tctrl->link     = link;\n\tctrl->catalog  = catalog;\n\tctrl->dev      = dev;\n\n\treturn &ctrl->dp_ctrl;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}