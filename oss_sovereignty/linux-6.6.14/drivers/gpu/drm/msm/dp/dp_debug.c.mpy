{
  "module_name": "dp_debug.c",
  "hash_id": "ee9b9ede85625298ec34d639af476df6d49d8d6a949ddcfb194f6d965e13db1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dp/dp_debug.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\"[drm-dp] %s: \" fmt, __func__\n\n#include <linux/debugfs.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_file.h>\n\n#include \"dp_parser.h\"\n#include \"dp_catalog.h\"\n#include \"dp_aux.h\"\n#include \"dp_ctrl.h\"\n#include \"dp_debug.h\"\n#include \"dp_display.h\"\n\n#define DEBUG_NAME \"msm_dp\"\n\nstruct dp_debug_private {\n\tstruct dentry *root;\n\n\tstruct dp_link *link;\n\tstruct dp_panel *panel;\n\tstruct drm_connector *connector;\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\n\tstruct dp_debug dp_debug;\n};\n\nstatic int dp_debug_show(struct seq_file *seq, void *p)\n{\n\tstruct dp_debug_private *debug = seq->private;\n\tu64 lclk = 0;\n\tu32 link_params_rate;\n\tconst struct drm_display_mode *drm_mode;\n\n\tif (!debug)\n\t\treturn -ENODEV;\n\n\tdrm_mode = &debug->panel->dp_mode.drm_mode;\n\n\tseq_printf(seq, \"\\tname = %s\\n\", DEBUG_NAME);\n\tseq_printf(seq, \"\\tdrm_dp_link\\n\\t\\trate = %u\\n\",\n\t\t\tdebug->panel->link_info.rate);\n\tseq_printf(seq, \"\\t\\tnum_lanes = %u\\n\",\n\t\t\tdebug->panel->link_info.num_lanes);\n\tseq_printf(seq, \"\\t\\tcapabilities = %lu\\n\",\n\t\t\tdebug->panel->link_info.capabilities);\n\tseq_printf(seq, \"\\tdp_panel_info:\\n\\t\\tactive = %dx%d\\n\",\n\t\t\tdrm_mode->hdisplay,\n\t\t\tdrm_mode->vdisplay);\n\tseq_printf(seq, \"\\t\\tback_porch = %dx%d\\n\",\n\t\t\tdrm_mode->htotal - drm_mode->hsync_end,\n\t\t\tdrm_mode->vtotal - drm_mode->vsync_end);\n\tseq_printf(seq, \"\\t\\tfront_porch = %dx%d\\n\",\n\t\t\tdrm_mode->hsync_start - drm_mode->hdisplay,\n\t\t\tdrm_mode->vsync_start - drm_mode->vdisplay);\n\tseq_printf(seq, \"\\t\\tsync_width = %dx%d\\n\",\n\t\t\tdrm_mode->hsync_end - drm_mode->hsync_start,\n\t\t\tdrm_mode->vsync_end - drm_mode->vsync_start);\n\tseq_printf(seq, \"\\t\\tactive_low = %dx%d\\n\",\n\t\t\tdebug->panel->dp_mode.h_active_low,\n\t\t\tdebug->panel->dp_mode.v_active_low);\n\tseq_printf(seq, \"\\t\\th_skew = %d\\n\",\n\t\t\tdrm_mode->hskew);\n\tseq_printf(seq, \"\\t\\trefresh rate = %d\\n\",\n\t\t\tdrm_mode_vrefresh(drm_mode));\n\tseq_printf(seq, \"\\t\\tpixel clock khz = %d\\n\",\n\t\t\tdrm_mode->clock);\n\tseq_printf(seq, \"\\t\\tbpp = %d\\n\",\n\t\t\tdebug->panel->dp_mode.bpp);\n\n\t \n\tseq_printf(seq, \"\\tdp_link:\\n\\t\\ttest_requested = %d\\n\",\n\t\t\tdebug->link->sink_request);\n\tseq_printf(seq, \"\\t\\tnum_lanes = %d\\n\",\n\t\t\tdebug->link->link_params.num_lanes);\n\tlink_params_rate = debug->link->link_params.rate;\n\tseq_printf(seq, \"\\t\\tbw_code = %d\\n\",\n\t\t\tdrm_dp_link_rate_to_bw_code(link_params_rate));\n\tlclk = debug->link->link_params.rate * 1000;\n\tseq_printf(seq, \"\\t\\tlclk = %lld\\n\", lclk);\n\tseq_printf(seq, \"\\t\\tv_level = %d\\n\",\n\t\t\tdebug->link->phy_params.v_level);\n\tseq_printf(seq, \"\\t\\tp_level = %d\\n\",\n\t\t\tdebug->link->phy_params.p_level);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dp_debug);\n\nstatic int dp_test_data_show(struct seq_file *m, void *data)\n{\n\tconst struct dp_debug_private *debug = m->private;\n\tconst struct drm_connector *connector = debug->connector;\n\tu32 bpc;\n\n\tif (connector->status == connector_status_connected) {\n\t\tbpc = debug->link->test_video.test_bit_depth;\n\t\tseq_printf(m, \"hdisplay: %d\\n\",\n\t\t\t\tdebug->link->test_video.test_h_width);\n\t\tseq_printf(m, \"vdisplay: %d\\n\",\n\t\t\t\tdebug->link->test_video.test_v_height);\n\t\tseq_printf(m, \"bpc: %u\\n\",\n\t\t\t\tdp_link_bit_depth_to_bpc(bpc));\n\t} else {\n\t\tseq_puts(m, \"0\");\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dp_test_data);\n\nstatic int dp_test_type_show(struct seq_file *m, void *data)\n{\n\tconst struct dp_debug_private *debug = m->private;\n\tconst struct drm_connector *connector = debug->connector;\n\n\tif (connector->status == connector_status_connected)\n\t\tseq_printf(m, \"%02x\", DP_TEST_LINK_VIDEO_PATTERN);\n\telse\n\t\tseq_puts(m, \"0\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dp_test_type);\n\nstatic ssize_t dp_test_active_write(struct file *file,\n\t\tconst char __user *ubuf,\n\t\tsize_t len, loff_t *offp)\n{\n\tchar *input_buffer;\n\tint status = 0;\n\tconst struct dp_debug_private *debug;\n\tconst struct drm_connector *connector;\n\tint val = 0;\n\n\tdebug = ((struct seq_file *)file->private_data)->private;\n\tconnector = debug->connector;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tinput_buffer = memdup_user_nul(ubuf, len);\n\tif (IS_ERR(input_buffer))\n\t\treturn PTR_ERR(input_buffer);\n\n\tDRM_DEBUG_DRIVER(\"Copied %d bytes from user\\n\", (unsigned int)len);\n\n\tif (connector->status == connector_status_connected) {\n\t\tstatus = kstrtoint(input_buffer, 10, &val);\n\t\tif (status < 0) {\n\t\t\tkfree(input_buffer);\n\t\t\treturn status;\n\t\t}\n\t\tDRM_DEBUG_DRIVER(\"Got %d for test active\\n\", val);\n\t\t \n\t\tif (val == 1)\n\t\t\tdebug->panel->video_test = true;\n\t\telse\n\t\t\tdebug->panel->video_test = false;\n\t}\n\tkfree(input_buffer);\n\n\t*offp += len;\n\treturn len;\n}\n\nstatic int dp_test_active_show(struct seq_file *m, void *data)\n{\n\tstruct dp_debug_private *debug = m->private;\n\tstruct drm_connector *connector = debug->connector;\n\n\tif (connector->status == connector_status_connected) {\n\t\tif (debug->panel->video_test)\n\t\t\tseq_puts(m, \"1\");\n\t\telse\n\t\t\tseq_puts(m, \"0\");\n\t} else {\n\t\tseq_puts(m, \"0\");\n\t}\n\n\treturn 0;\n}\n\nstatic int dp_test_active_open(struct inode *inode,\n\t\tstruct file *file)\n{\n\treturn single_open(file, dp_test_active_show,\n\t\t\tinode->i_private);\n}\n\nstatic const struct file_operations test_active_fops = {\n\t.owner = THIS_MODULE,\n\t.open = dp_test_active_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = dp_test_active_write\n};\n\nstatic void dp_debug_init(struct dp_debug *dp_debug, struct drm_minor *minor)\n{\n\tchar path[64];\n\tstruct dp_debug_private *debug = container_of(dp_debug,\n\t\t\tstruct dp_debug_private, dp_debug);\n\n\tsnprintf(path, sizeof(path), \"msm_dp-%s\", debug->connector->name);\n\n\tdebug->root = debugfs_create_dir(path, minor->debugfs_root);\n\n\tdebugfs_create_file(\"dp_debug\", 0444, debug->root,\n\t\t\tdebug, &dp_debug_fops);\n\n\tdebugfs_create_file(\"msm_dp_test_active\", 0444,\n\t\t\tdebug->root,\n\t\t\tdebug, &test_active_fops);\n\n\tdebugfs_create_file(\"msm_dp_test_data\", 0444,\n\t\t\tdebug->root,\n\t\t\tdebug, &dp_test_data_fops);\n\n\tdebugfs_create_file(\"msm_dp_test_type\", 0444,\n\t\t\tdebug->root,\n\t\t\tdebug, &dp_test_type_fops);\n}\n\nstruct dp_debug *dp_debug_get(struct device *dev, struct dp_panel *panel,\n\t\tstruct dp_link *link,\n\t\tstruct drm_connector *connector, struct drm_minor *minor)\n{\n\tstruct dp_debug_private *debug;\n\tstruct dp_debug *dp_debug;\n\tint rc;\n\n\tif (!dev || !panel || !link) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tdebug = devm_kzalloc(dev, sizeof(*debug), GFP_KERNEL);\n\tif (!debug) {\n\t\trc = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tdebug->dp_debug.debug_en = false;\n\tdebug->link = link;\n\tdebug->panel = panel;\n\tdebug->dev = dev;\n\tdebug->drm_dev = minor->dev;\n\tdebug->connector = connector;\n\n\tdp_debug = &debug->dp_debug;\n\tdp_debug->vdisplay = 0;\n\tdp_debug->hdisplay = 0;\n\tdp_debug->vrefresh = 0;\n\n\tdp_debug_init(dp_debug, minor);\n\n\treturn dp_debug;\n error:\n\treturn ERR_PTR(rc);\n}\n\nstatic int dp_debug_deinit(struct dp_debug *dp_debug)\n{\n\tstruct dp_debug_private *debug;\n\n\tif (!dp_debug)\n\t\treturn -EINVAL;\n\n\tdebug = container_of(dp_debug, struct dp_debug_private, dp_debug);\n\n\tdebugfs_remove_recursive(debug->root);\n\n\treturn 0;\n}\n\nvoid dp_debug_put(struct dp_debug *dp_debug)\n{\n\tstruct dp_debug_private *debug;\n\n\tif (!dp_debug)\n\t\treturn;\n\n\tdebug = container_of(dp_debug, struct dp_debug_private, dp_debug);\n\n\tdp_debug_deinit(dp_debug);\n\n\tdevm_kfree(debug->dev, debug);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}