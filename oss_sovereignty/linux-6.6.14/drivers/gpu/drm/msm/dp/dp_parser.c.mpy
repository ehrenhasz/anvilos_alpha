{
  "module_name": "dp_parser.c",
  "hash_id": "3460f94ec89968c95bf63aef3baedea2444f9dfc1250581c3a3bbffa68fadc3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dp/dp_parser.c",
  "human_readable_source": "\n \n\n#include <linux/of_gpio.h>\n#include <linux/phy/phy.h>\n\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n#include <drm/drm_bridge.h>\n\n#include \"dp_parser.h\"\n#include \"dp_reg.h\"\n\n#define DP_DEFAULT_AHB_OFFSET\t0x0000\n#define DP_DEFAULT_AHB_SIZE\t0x0200\n#define DP_DEFAULT_AUX_OFFSET\t0x0200\n#define DP_DEFAULT_AUX_SIZE\t0x0200\n#define DP_DEFAULT_LINK_OFFSET\t0x0400\n#define DP_DEFAULT_LINK_SIZE\t0x0C00\n#define DP_DEFAULT_P0_OFFSET\t0x1000\n#define DP_DEFAULT_P0_SIZE\t0x0400\n\nstatic void __iomem *dp_ioremap(struct platform_device *pdev, int idx, size_t *len)\n{\n\tstruct resource *res;\n\tvoid __iomem *base;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, idx, &res);\n\tif (!IS_ERR(base))\n\t\t*len = resource_size(res);\n\n\treturn base;\n}\n\nstatic int dp_parser_ctrl_res(struct dp_parser *parser)\n{\n\tstruct platform_device *pdev = parser->pdev;\n\tstruct dp_io *io = &parser->io;\n\tstruct dss_io_data *dss = &io->dp_controller;\n\n\tdss->ahb.base = dp_ioremap(pdev, 0, &dss->ahb.len);\n\tif (IS_ERR(dss->ahb.base))\n\t\treturn PTR_ERR(dss->ahb.base);\n\n\tdss->aux.base = dp_ioremap(pdev, 1, &dss->aux.len);\n\tif (IS_ERR(dss->aux.base)) {\n\t\t \n\t\tif (PTR_ERR(dss->aux.base) == -EINVAL) {\n\t\t\tif (dss->ahb.len < DP_DEFAULT_P0_OFFSET + DP_DEFAULT_P0_SIZE) {\n\t\t\t\tDRM_ERROR(\"legacy memory region not large enough\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tdss->ahb.len = DP_DEFAULT_AHB_SIZE;\n\t\t\tdss->aux.base = dss->ahb.base + DP_DEFAULT_AUX_OFFSET;\n\t\t\tdss->aux.len = DP_DEFAULT_AUX_SIZE;\n\t\t\tdss->link.base = dss->ahb.base + DP_DEFAULT_LINK_OFFSET;\n\t\t\tdss->link.len = DP_DEFAULT_LINK_SIZE;\n\t\t\tdss->p0.base = dss->ahb.base + DP_DEFAULT_P0_OFFSET;\n\t\t\tdss->p0.len = DP_DEFAULT_P0_SIZE;\n\t\t} else {\n\t\t\tDRM_ERROR(\"unable to remap aux region: %pe\\n\", dss->aux.base);\n\t\t\treturn PTR_ERR(dss->aux.base);\n\t\t}\n\t} else {\n\t\tdss->link.base = dp_ioremap(pdev, 2, &dss->link.len);\n\t\tif (IS_ERR(dss->link.base)) {\n\t\t\tDRM_ERROR(\"unable to remap link region: %pe\\n\", dss->link.base);\n\t\t\treturn PTR_ERR(dss->link.base);\n\t\t}\n\n\t\tdss->p0.base = dp_ioremap(pdev, 3, &dss->p0.len);\n\t\tif (IS_ERR(dss->p0.base)) {\n\t\t\tDRM_ERROR(\"unable to remap p0 region: %pe\\n\", dss->p0.base);\n\t\t\treturn PTR_ERR(dss->p0.base);\n\t\t}\n\t}\n\n\tio->phy = devm_phy_get(&pdev->dev, \"dp\");\n\tif (IS_ERR(io->phy))\n\t\treturn PTR_ERR(io->phy);\n\n\treturn 0;\n}\n\nstatic u32 dp_parser_link_frequencies(struct device_node *of_node)\n{\n\tstruct device_node *endpoint;\n\tu64 frequency = 0;\n\tint cnt;\n\n\tendpoint = of_graph_get_endpoint_by_regs(of_node, 1, 0);  \n\tif (!endpoint)\n\t\treturn 0;\n\n\tcnt = of_property_count_u64_elems(endpoint, \"link-frequencies\");\n\n\tif (cnt > 0)\n\t\tof_property_read_u64_index(endpoint, \"link-frequencies\",\n\t\t\t\t\t\tcnt - 1, &frequency);\n\tof_node_put(endpoint);\n\n\tdo_div(frequency,\n\t\t10 *  \n\t\t1000);  \n\n\treturn frequency;\n}\n\nstatic int dp_parser_misc(struct dp_parser *parser)\n{\n\tstruct device_node *of_node = parser->pdev->dev.of_node;\n\tint cnt;\n\n\t \n\tcnt = drm_of_get_data_lanes_count_ep(of_node, 1, 0, 1, DP_MAX_NUM_DP_LANES);\n\tif (cnt < 0) {\n\t\t \n\t\tcnt = drm_of_get_data_lanes_count(of_node, 1, DP_MAX_NUM_DP_LANES);\n\t}\n\n\tif (cnt > 0)\n\t\tparser->max_dp_lanes = cnt;\n\telse\n\t\tparser->max_dp_lanes = DP_MAX_NUM_DP_LANES;  \n\n\tparser->max_dp_link_rate = dp_parser_link_frequencies(of_node);\n\tif (!parser->max_dp_link_rate)\n\t\tparser->max_dp_link_rate = DP_LINK_RATE_HBR2;\n\n\treturn 0;\n}\n\nstatic inline bool dp_parser_check_prefix(const char *clk_prefix,\n\t\t\t\t\t\tconst char *clk_name)\n{\n\treturn !strncmp(clk_prefix, clk_name, strlen(clk_prefix));\n}\n\nstatic int dp_parser_init_clk_data(struct dp_parser *parser)\n{\n\tint num_clk, i, rc;\n\tint core_clk_count = 0, ctrl_clk_count = 0, stream_clk_count = 0;\n\tconst char *clk_name;\n\tstruct device *dev = &parser->pdev->dev;\n\tstruct dss_module_power *core_power = &parser->mp[DP_CORE_PM];\n\tstruct dss_module_power *ctrl_power = &parser->mp[DP_CTRL_PM];\n\tstruct dss_module_power *stream_power = &parser->mp[DP_STREAM_PM];\n\n\tnum_clk = of_property_count_strings(dev->of_node, \"clock-names\");\n\tif (num_clk <= 0) {\n\t\tDRM_ERROR(\"no clocks are defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_clk; i++) {\n\t\trc = of_property_read_string_index(dev->of_node,\n\t\t\t\t\"clock-names\", i, &clk_name);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (dp_parser_check_prefix(\"core\", clk_name))\n\t\t\tcore_clk_count++;\n\n\t\tif (dp_parser_check_prefix(\"ctrl\", clk_name))\n\t\t\tctrl_clk_count++;\n\n\t\tif (dp_parser_check_prefix(\"stream\", clk_name))\n\t\t\tstream_clk_count++;\n\t}\n\n\t \n\tif (core_clk_count == 0) {\n\t\tDRM_ERROR(\"no core clocks are defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcore_power->num_clk = core_clk_count;\n\tcore_power->clocks = devm_kcalloc(dev,\n\t\t\tcore_power->num_clk, sizeof(struct clk_bulk_data),\n\t\t\tGFP_KERNEL);\n\tif (!core_power->clocks)\n\t\treturn -ENOMEM;\n\n\t \n\tif (ctrl_clk_count == 0) {\n\t\tDRM_ERROR(\"no ctrl clocks are defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctrl_power->num_clk = ctrl_clk_count;\n\tctrl_power->clocks = devm_kcalloc(dev,\n\t\t\tctrl_power->num_clk, sizeof(struct clk_bulk_data),\n\t\t\tGFP_KERNEL);\n\tif (!ctrl_power->clocks) {\n\t\tctrl_power->num_clk = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (stream_clk_count == 0) {\n\t\tDRM_ERROR(\"no stream (pixel) clocks are defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstream_power->num_clk = stream_clk_count;\n\tstream_power->clocks = devm_kcalloc(dev,\n\t\t\tstream_power->num_clk, sizeof(struct clk_bulk_data),\n\t\t\tGFP_KERNEL);\n\tif (!stream_power->clocks) {\n\t\tstream_power->num_clk = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int dp_parser_clock(struct dp_parser *parser)\n{\n\tint rc = 0, i = 0;\n\tint num_clk = 0;\n\tint core_clk_index = 0, ctrl_clk_index = 0, stream_clk_index = 0;\n\tint core_clk_count = 0, ctrl_clk_count = 0, stream_clk_count = 0;\n\tconst char *clk_name;\n\tstruct device *dev = &parser->pdev->dev;\n\tstruct dss_module_power *core_power = &parser->mp[DP_CORE_PM];\n\tstruct dss_module_power *ctrl_power = &parser->mp[DP_CTRL_PM];\n\tstruct dss_module_power *stream_power = &parser->mp[DP_STREAM_PM];\n\n\trc =  dp_parser_init_clk_data(parser);\n\tif (rc) {\n\t\tDRM_ERROR(\"failed to initialize power data %d\\n\", rc);\n\t\treturn -EINVAL;\n\t}\n\n\tcore_clk_count = core_power->num_clk;\n\tctrl_clk_count = ctrl_power->num_clk;\n\tstream_clk_count = stream_power->num_clk;\n\n\tnum_clk = core_clk_count + ctrl_clk_count + stream_clk_count;\n\n\tfor (i = 0; i < num_clk; i++) {\n\t\trc = of_property_read_string_index(dev->of_node, \"clock-names\",\n\t\t\t\ti, &clk_name);\n\t\tif (rc) {\n\t\t\tDRM_ERROR(\"error reading clock-names %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\tif (dp_parser_check_prefix(\"core\", clk_name) &&\n\t\t\t\tcore_clk_index < core_clk_count) {\n\t\t\tcore_power->clocks[core_clk_index].id = devm_kstrdup(dev, clk_name, GFP_KERNEL);\n\t\t\tcore_clk_index++;\n\t\t} else if (dp_parser_check_prefix(\"stream\", clk_name) &&\n\t\t\t\tstream_clk_index < stream_clk_count) {\n\t\t\tstream_power->clocks[stream_clk_index].id = devm_kstrdup(dev, clk_name, GFP_KERNEL);\n\t\t\tstream_clk_index++;\n\t\t} else if (dp_parser_check_prefix(\"ctrl\", clk_name) &&\n\t\t\t   ctrl_clk_index < ctrl_clk_count) {\n\t\t\tctrl_power->clocks[ctrl_clk_index].id = devm_kstrdup(dev, clk_name, GFP_KERNEL);\n\t\t\tctrl_clk_index++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint devm_dp_parser_find_next_bridge(struct device *dev, struct dp_parser *parser)\n{\n\tstruct platform_device *pdev = parser->pdev;\n\tstruct drm_bridge *bridge;\n\n\tbridge = devm_drm_of_get_bridge(dev, pdev->dev.of_node, 1, 0);\n\tif (IS_ERR(bridge))\n\t\treturn PTR_ERR(bridge);\n\n\tparser->next_bridge = bridge;\n\n\treturn 0;\n}\n\nstatic int dp_parser_parse(struct dp_parser *parser)\n{\n\tint rc = 0;\n\n\tif (!parser) {\n\t\tDRM_ERROR(\"invalid input\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = dp_parser_ctrl_res(parser);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dp_parser_misc(parser);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dp_parser_clock(parser);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstruct dp_parser *dp_parser_get(struct platform_device *pdev)\n{\n\tstruct dp_parser *parser;\n\n\tparser = devm_kzalloc(&pdev->dev, sizeof(*parser), GFP_KERNEL);\n\tif (!parser)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tparser->parse = dp_parser_parse;\n\tparser->pdev = pdev;\n\n\treturn parser;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}