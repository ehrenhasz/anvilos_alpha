{
  "module_name": "dp_power.c",
  "hash_id": "d5a9d480a27c3feff33b70911d75a8a3c28de3b9194473e63a327fe8da9a6553",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dp/dp_power.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm-dp] %s: \" fmt, __func__\n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_opp.h>\n#include \"dp_power.h\"\n#include \"msm_drv.h\"\n\nstruct dp_power_private {\n\tstruct dp_parser *parser;\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\tstruct clk *link_clk_src;\n\tstruct clk *pixel_provider;\n\tstruct clk *link_provider;\n\n\tstruct dp_power dp_power;\n};\n\nstatic int dp_power_clk_init(struct dp_power_private *power)\n{\n\tint rc = 0;\n\tstruct dss_module_power *core, *ctrl, *stream;\n\tstruct device *dev = power->dev;\n\n\tcore = &power->parser->mp[DP_CORE_PM];\n\tctrl = &power->parser->mp[DP_CTRL_PM];\n\tstream = &power->parser->mp[DP_STREAM_PM];\n\n\trc = devm_clk_bulk_get(dev, core->num_clk, core->clocks);\n\tif (rc)\n\t\treturn rc;\n\n\trc = devm_clk_bulk_get(dev, ctrl->num_clk, ctrl->clocks);\n\tif (rc)\n\t\treturn -ENODEV;\n\n\trc = devm_clk_bulk_get(dev, stream->num_clk, stream->clocks);\n\tif (rc)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nint dp_power_clk_status(struct dp_power *dp_power, enum dp_pm_type pm_type)\n{\n\tstruct dp_power_private *power;\n\n\tpower = container_of(dp_power, struct dp_power_private, dp_power);\n\n\tdrm_dbg_dp(power->drm_dev,\n\t\t\"core_clk_on=%d link_clk_on=%d stream_clk_on=%d\\n\",\n\t\tdp_power->core_clks_on, dp_power->link_clks_on, dp_power->stream_clks_on);\n\n\tif (pm_type == DP_CORE_PM)\n\t\treturn dp_power->core_clks_on;\n\n\tif (pm_type == DP_CTRL_PM)\n\t\treturn dp_power->link_clks_on;\n\n\tif (pm_type == DP_STREAM_PM)\n\t\treturn dp_power->stream_clks_on;\n\n\treturn 0;\n}\n\nint dp_power_clk_enable(struct dp_power *dp_power,\n\t\tenum dp_pm_type pm_type, bool enable)\n{\n\tint rc = 0;\n\tstruct dp_power_private *power;\n\tstruct dss_module_power *mp;\n\n\tpower = container_of(dp_power, struct dp_power_private, dp_power);\n\n\tif (pm_type != DP_CORE_PM && pm_type != DP_CTRL_PM &&\n\t\t\tpm_type != DP_STREAM_PM) {\n\t\tDRM_ERROR(\"unsupported power module: %s\\n\",\n\t\t\t\tdp_parser_pm_name(pm_type));\n\t\treturn -EINVAL;\n\t}\n\n\tif (enable) {\n\t\tif (pm_type == DP_CORE_PM && dp_power->core_clks_on) {\n\t\t\tdrm_dbg_dp(power->drm_dev,\n\t\t\t\t\t\"core clks already enabled\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (pm_type == DP_CTRL_PM && dp_power->link_clks_on) {\n\t\t\tdrm_dbg_dp(power->drm_dev,\n\t\t\t\t\t\"links clks already enabled\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (pm_type == DP_STREAM_PM && dp_power->stream_clks_on) {\n\t\t\tdrm_dbg_dp(power->drm_dev,\n\t\t\t\t\t\"pixel clks already enabled\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((pm_type == DP_CTRL_PM) && (!dp_power->core_clks_on)) {\n\t\t\tdrm_dbg_dp(power->drm_dev,\n\t\t\t\t\t\"Enable core clks before link clks\\n\");\n\t\t\tmp = &power->parser->mp[DP_CORE_PM];\n\n\t\t\trc = clk_bulk_prepare_enable(mp->num_clk, mp->clocks);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tdp_power->core_clks_on = true;\n\t\t}\n\t}\n\n\tmp = &power->parser->mp[pm_type];\n\tif (enable) {\n\t\trc = clk_bulk_prepare_enable(mp->num_clk, mp->clocks);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tclk_bulk_disable_unprepare(mp->num_clk, mp->clocks);\n\t}\n\n\tif (pm_type == DP_CORE_PM)\n\t\tdp_power->core_clks_on = enable;\n\telse if (pm_type == DP_STREAM_PM)\n\t\tdp_power->stream_clks_on = enable;\n\telse\n\t\tdp_power->link_clks_on = enable;\n\n\tdrm_dbg_dp(power->drm_dev, \"%s clocks for %s\\n\",\n\t\t\tenable ? \"enable\" : \"disable\",\n\t\t\tdp_parser_pm_name(pm_type));\n\tdrm_dbg_dp(power->drm_dev,\n\t\t\"strem_clks:%s link_clks:%s core_clks:%s\\n\",\n\t\tdp_power->stream_clks_on ? \"on\" : \"off\",\n\t\tdp_power->link_clks_on ? \"on\" : \"off\",\n\t\tdp_power->core_clks_on ? \"on\" : \"off\");\n\n\treturn 0;\n}\n\nint dp_power_client_init(struct dp_power *dp_power)\n{\n\tstruct dp_power_private *power;\n\n\tpower = container_of(dp_power, struct dp_power_private, dp_power);\n\n\tpm_runtime_enable(power->dev);\n\n\treturn dp_power_clk_init(power);\n}\n\nvoid dp_power_client_deinit(struct dp_power *dp_power)\n{\n\tstruct dp_power_private *power;\n\n\tpower = container_of(dp_power, struct dp_power_private, dp_power);\n\n\tpm_runtime_disable(power->dev);\n}\n\nint dp_power_init(struct dp_power *dp_power)\n{\n\tint rc = 0;\n\tstruct dp_power_private *power = NULL;\n\n\tpower = container_of(dp_power, struct dp_power_private, dp_power);\n\n\tpm_runtime_get_sync(power->dev);\n\n\trc = dp_power_clk_enable(dp_power, DP_CORE_PM, true);\n\tif (rc)\n\t\tpm_runtime_put_sync(power->dev);\n\n\treturn rc;\n}\n\nint dp_power_deinit(struct dp_power *dp_power)\n{\n\tstruct dp_power_private *power;\n\n\tpower = container_of(dp_power, struct dp_power_private, dp_power);\n\n\tdp_power_clk_enable(dp_power, DP_CORE_PM, false);\n\tpm_runtime_put_sync(power->dev);\n\treturn 0;\n}\n\nstruct dp_power *dp_power_get(struct device *dev, struct dp_parser *parser)\n{\n\tstruct dp_power_private *power;\n\tstruct dp_power *dp_power;\n\n\tpower = devm_kzalloc(dev, sizeof(*power), GFP_KERNEL);\n\tif (!power)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpower->parser = parser;\n\tpower->dev = dev;\n\n\tdp_power = &power->dp_power;\n\n\treturn dp_power;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}