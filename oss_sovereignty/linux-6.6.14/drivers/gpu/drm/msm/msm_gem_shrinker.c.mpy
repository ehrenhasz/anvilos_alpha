{
  "module_name": "msm_gem_shrinker.c",
  "hash_id": "d50cbc2136e19d556888e5e18672e117ab30c829def42002b88f7bdb65626436",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_gem_shrinker.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include <linux/sched/mm.h>\n\n#include \"msm_drv.h\"\n#include \"msm_gem.h\"\n#include \"msm_gpu.h\"\n#include \"msm_gpu_trace.h\"\n\n \nstatic bool enable_eviction = true;\nMODULE_PARM_DESC(enable_eviction, \"Enable swappable GEM buffers\");\nmodule_param(enable_eviction, bool, 0600);\n\nstatic bool can_swap(void)\n{\n\treturn enable_eviction && get_nr_swap_pages() > 0;\n}\n\nstatic bool can_block(struct shrink_control *sc)\n{\n\tif (!(sc->gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\treturn false;\n\treturn current_is_kswapd() || (sc->gfp_mask & __GFP_RECLAIM);\n}\n\nstatic unsigned long\nmsm_gem_shrinker_count(struct shrinker *shrinker, struct shrink_control *sc)\n{\n\tstruct msm_drm_private *priv =\n\t\tcontainer_of(shrinker, struct msm_drm_private, shrinker);\n\tunsigned count = priv->lru.dontneed.count;\n\n\tif (can_swap())\n\t\tcount += priv->lru.willneed.count;\n\n\treturn count;\n}\n\nstatic bool\npurge(struct drm_gem_object *obj)\n{\n\tif (!is_purgeable(to_msm_bo(obj)))\n\t\treturn false;\n\n\tif (msm_gem_active(obj))\n\t\treturn false;\n\n\tmsm_gem_purge(obj);\n\n\treturn true;\n}\n\nstatic bool\nevict(struct drm_gem_object *obj)\n{\n\tif (is_unevictable(to_msm_bo(obj)))\n\t\treturn false;\n\n\tif (msm_gem_active(obj))\n\t\treturn false;\n\n\tmsm_gem_evict(obj);\n\n\treturn true;\n}\n\nstatic bool\nwait_for_idle(struct drm_gem_object *obj)\n{\n\tenum dma_resv_usage usage = dma_resv_usage_rw(true);\n\treturn dma_resv_wait_timeout(obj->resv, usage, false, 1000) > 0;\n}\n\nstatic bool\nactive_purge(struct drm_gem_object *obj)\n{\n\tif (!wait_for_idle(obj))\n\t\treturn false;\n\n\treturn purge(obj);\n}\n\nstatic bool\nactive_evict(struct drm_gem_object *obj)\n{\n\tif (!wait_for_idle(obj))\n\t\treturn false;\n\n\treturn evict(obj);\n}\n\nstatic unsigned long\nmsm_gem_shrinker_scan(struct shrinker *shrinker, struct shrink_control *sc)\n{\n\tstruct msm_drm_private *priv =\n\t\tcontainer_of(shrinker, struct msm_drm_private, shrinker);\n\tstruct {\n\t\tstruct drm_gem_lru *lru;\n\t\tbool (*shrink)(struct drm_gem_object *obj);\n\t\tbool cond;\n\t\tunsigned long freed;\n\t\tunsigned long remaining;\n\t} stages[] = {\n\t\t \n\t\t{ &priv->lru.dontneed, purge,        true },\n\t\t{ &priv->lru.willneed, evict,        can_swap() },\n\t\t{ &priv->lru.dontneed, active_purge, can_block(sc) },\n\t\t{ &priv->lru.willneed, active_evict, can_swap() && can_block(sc) },\n\t};\n\tlong nr = sc->nr_to_scan;\n\tunsigned long freed = 0;\n\tunsigned long remaining = 0;\n\n\tfor (unsigned i = 0; (nr > 0) && (i < ARRAY_SIZE(stages)); i++) {\n\t\tif (!stages[i].cond)\n\t\t\tcontinue;\n\t\tstages[i].freed =\n\t\t\tdrm_gem_lru_scan(stages[i].lru, nr,\n\t\t\t\t\t&stages[i].remaining,\n\t\t\t\t\t stages[i].shrink);\n\t\tnr -= stages[i].freed;\n\t\tfreed += stages[i].freed;\n\t\tremaining += stages[i].remaining;\n\t}\n\n\tif (freed) {\n\t\ttrace_msm_gem_shrink(sc->nr_to_scan, stages[0].freed,\n\t\t\t\t     stages[1].freed, stages[2].freed,\n\t\t\t\t     stages[3].freed);\n\t}\n\n\treturn (freed > 0 && remaining > 0) ? freed : SHRINK_STOP;\n}\n\n#ifdef CONFIG_DEBUG_FS\nunsigned long\nmsm_gem_shrinker_shrink(struct drm_device *dev, unsigned long nr_to_scan)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct shrink_control sc = {\n\t\t.nr_to_scan = nr_to_scan,\n\t};\n\tint ret;\n\n\tfs_reclaim_acquire(GFP_KERNEL);\n\tret = msm_gem_shrinker_scan(&priv->shrinker, &sc);\n\tfs_reclaim_release(GFP_KERNEL);\n\n\treturn ret;\n}\n#endif\n\n \nstatic const int vmap_shrink_limit = 15;\n\nstatic bool\nvmap_shrink(struct drm_gem_object *obj)\n{\n\tif (!is_vunmapable(to_msm_bo(obj)))\n\t\treturn false;\n\n\tmsm_gem_vunmap(obj);\n\n\treturn true;\n}\n\nstatic int\nmsm_gem_shrinker_vmap(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct msm_drm_private *priv =\n\t\tcontainer_of(nb, struct msm_drm_private, vmap_notifier);\n\tstruct drm_gem_lru *lrus[] = {\n\t\t&priv->lru.dontneed,\n\t\t&priv->lru.willneed,\n\t\t&priv->lru.pinned,\n\t\tNULL,\n\t};\n\tunsigned idx, unmapped = 0;\n\tunsigned long remaining = 0;\n\n\tfor (idx = 0; lrus[idx] && unmapped < vmap_shrink_limit; idx++) {\n\t\tunmapped += drm_gem_lru_scan(lrus[idx],\n\t\t\t\t\t     vmap_shrink_limit - unmapped,\n\t\t\t\t\t     &remaining,\n\t\t\t\t\t     vmap_shrink);\n\t}\n\n\t*(unsigned long *)ptr += unmapped;\n\n\tif (unmapped > 0)\n\t\ttrace_msm_gem_purge_vmaps(unmapped);\n\n\treturn NOTIFY_DONE;\n}\n\n \nvoid msm_gem_shrinker_init(struct drm_device *dev)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tpriv->shrinker.count_objects = msm_gem_shrinker_count;\n\tpriv->shrinker.scan_objects = msm_gem_shrinker_scan;\n\tpriv->shrinker.seeks = DEFAULT_SEEKS;\n\tWARN_ON(register_shrinker(&priv->shrinker, \"drm-msm_gem\"));\n\n\tpriv->vmap_notifier.notifier_call = msm_gem_shrinker_vmap;\n\tWARN_ON(register_vmap_purge_notifier(&priv->vmap_notifier));\n}\n\n \nvoid msm_gem_shrinker_cleanup(struct drm_device *dev)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\n\tif (priv->shrinker.nr_deferred) {\n\t\tWARN_ON(unregister_vmap_purge_notifier(&priv->vmap_notifier));\n\t\tunregister_shrinker(&priv->shrinker);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}