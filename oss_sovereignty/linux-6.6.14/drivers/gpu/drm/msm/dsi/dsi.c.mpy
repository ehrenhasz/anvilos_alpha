{
  "module_name": "dsi.c",
  "hash_id": "efc7c11a8e3c76ee8e7c8bdad93f456656e34d7bd5bd64913d99e3b12163a991",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dsi/dsi.c",
  "human_readable_source": "\n \n\n#include \"dsi.h\"\n\nbool msm_dsi_is_cmd_mode(struct msm_dsi *msm_dsi)\n{\n\tunsigned long host_flags = msm_dsi_host_get_mode_flags(msm_dsi->host);\n\n\treturn !(host_flags & MIPI_DSI_MODE_VIDEO);\n}\n\nstruct drm_dsc_config *msm_dsi_get_dsc_config(struct msm_dsi *msm_dsi)\n{\n\treturn msm_dsi_host_get_dsc_config(msm_dsi->host);\n}\n\nstatic int dsi_get_phy(struct msm_dsi *msm_dsi)\n{\n\tstruct platform_device *pdev = msm_dsi->pdev;\n\tstruct platform_device *phy_pdev;\n\tstruct device_node *phy_node;\n\n\tphy_node = of_parse_phandle(pdev->dev.of_node, \"phys\", 0);\n\tif (!phy_node) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"cannot find phy device\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tphy_pdev = of_find_device_by_node(phy_node);\n\tif (phy_pdev) {\n\t\tmsm_dsi->phy = platform_get_drvdata(phy_pdev);\n\t\tmsm_dsi->phy_dev = &phy_pdev->dev;\n\t}\n\n\tof_node_put(phy_node);\n\n\tif (!phy_pdev) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"%s: phy driver is not ready\\n\", __func__);\n\t\treturn -EPROBE_DEFER;\n\t}\n\tif (!msm_dsi->phy) {\n\t\tput_device(&phy_pdev->dev);\n\t\tDRM_DEV_ERROR(&pdev->dev, \"%s: phy driver is not ready\\n\", __func__);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\treturn 0;\n}\n\nstatic void dsi_destroy(struct msm_dsi *msm_dsi)\n{\n\tif (!msm_dsi)\n\t\treturn;\n\n\tmsm_dsi_manager_unregister(msm_dsi);\n\n\tif (msm_dsi->phy_dev) {\n\t\tput_device(msm_dsi->phy_dev);\n\t\tmsm_dsi->phy = NULL;\n\t\tmsm_dsi->phy_dev = NULL;\n\t}\n\n\tif (msm_dsi->host) {\n\t\tmsm_dsi_host_destroy(msm_dsi->host);\n\t\tmsm_dsi->host = NULL;\n\t}\n\n\tplatform_set_drvdata(msm_dsi->pdev, NULL);\n}\n\nstatic struct msm_dsi *dsi_init(struct platform_device *pdev)\n{\n\tstruct msm_dsi *msm_dsi;\n\tint ret;\n\n\tif (!pdev)\n\t\treturn ERR_PTR(-ENXIO);\n\n\tmsm_dsi = devm_kzalloc(&pdev->dev, sizeof(*msm_dsi), GFP_KERNEL);\n\tif (!msm_dsi)\n\t\treturn ERR_PTR(-ENOMEM);\n\tDBG(\"dsi probed=%p\", msm_dsi);\n\n\tmsm_dsi->id = -1;\n\tmsm_dsi->pdev = pdev;\n\tplatform_set_drvdata(pdev, msm_dsi);\n\n\t \n\tret = msm_dsi_host_init(msm_dsi);\n\tif (ret)\n\t\tgoto destroy_dsi;\n\n\t \n\tret = dsi_get_phy(msm_dsi);\n\tif (ret)\n\t\tgoto destroy_dsi;\n\n\t \n\tret = msm_dsi_manager_register(msm_dsi);\n\tif (ret)\n\t\tgoto destroy_dsi;\n\n\treturn msm_dsi;\n\ndestroy_dsi:\n\tdsi_destroy(msm_dsi);\n\treturn ERR_PTR(ret);\n}\n\nstatic int dsi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct msm_drm_private *priv = dev_get_drvdata(master);\n\tstruct msm_dsi *msm_dsi = dev_get_drvdata(dev);\n\n\tpriv->dsi[msm_dsi->id] = msm_dsi;\n\n\treturn 0;\n}\n\nstatic void dsi_unbind(struct device *dev, struct device *master,\n\t\tvoid *data)\n{\n\tstruct msm_drm_private *priv = dev_get_drvdata(master);\n\tstruct msm_dsi *msm_dsi = dev_get_drvdata(dev);\n\n\tmsm_dsi_tx_buf_free(msm_dsi->host);\n\tpriv->dsi[msm_dsi->id] = NULL;\n}\n\nstatic const struct component_ops dsi_ops = {\n\t.bind   = dsi_bind,\n\t.unbind = dsi_unbind,\n};\n\nint dsi_dev_attach(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &dsi_ops);\n}\n\nvoid dsi_dev_detach(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &dsi_ops);\n}\n\nstatic int dsi_dev_probe(struct platform_device *pdev)\n{\n\tstruct msm_dsi *msm_dsi;\n\n\tDBG(\"\");\n\tmsm_dsi = dsi_init(pdev);\n\tif (IS_ERR(msm_dsi)) {\n\t\t \n\t\tif (PTR_ERR(msm_dsi) == -ENODEV)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn PTR_ERR(msm_dsi);\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_dev_remove(struct platform_device *pdev)\n{\n\tstruct msm_dsi *msm_dsi = platform_get_drvdata(pdev);\n\n\tDBG(\"\");\n\tdsi_destroy(msm_dsi);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id dt_match[] = {\n\t{ .compatible = \"qcom,mdss-dsi-ctrl\" },\n\n\t \n\t{ .compatible = \"qcom,dsi-ctrl-6g-qcm2290\" },\n\t{}\n};\n\nstatic const struct dev_pm_ops dsi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(msm_dsi_runtime_suspend, msm_dsi_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver dsi_driver = {\n\t.probe = dsi_dev_probe,\n\t.remove = dsi_dev_remove,\n\t.driver = {\n\t\t.name = \"msm_dsi\",\n\t\t.of_match_table = dt_match,\n\t\t.pm = &dsi_pm_ops,\n\t},\n};\n\nvoid __init msm_dsi_register(void)\n{\n\tDBG(\"\");\n\tmsm_dsi_phy_driver_register();\n\tplatform_driver_register(&dsi_driver);\n}\n\nvoid __exit msm_dsi_unregister(void)\n{\n\tDBG(\"\");\n\tmsm_dsi_phy_driver_unregister();\n\tplatform_driver_unregister(&dsi_driver);\n}\n\nint msm_dsi_modeset_init(struct msm_dsi *msm_dsi, struct drm_device *dev,\n\t\t\t struct drm_encoder *encoder)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tint ret;\n\n\tif (priv->num_bridges == ARRAY_SIZE(priv->bridges)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"too many bridges\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tmsm_dsi->dev = dev;\n\n\tret = msm_dsi_host_modeset_init(msm_dsi->host, dev);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to modeset init host: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tif (msm_dsi_is_bonded_dsi(msm_dsi) &&\n\t    !msm_dsi_is_master_dsi(msm_dsi)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tmsm_dsi->encoder = encoder;\n\n\tmsm_dsi->bridge = msm_dsi_manager_bridge_init(msm_dsi->id);\n\tif (IS_ERR(msm_dsi->bridge)) {\n\t\tret = PTR_ERR(msm_dsi->bridge);\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to create dsi bridge: %d\\n\", ret);\n\t\tmsm_dsi->bridge = NULL;\n\t\tgoto fail;\n\t}\n\n\tret = msm_dsi_manager_ext_bridge_init(msm_dsi->id);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev->dev,\n\t\t\t\"failed to create dsi connector: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tpriv->bridges[priv->num_bridges++]       = msm_dsi->bridge;\n\n\treturn 0;\nfail:\n\t \n\tif (msm_dsi->bridge) {\n\t\tmsm_dsi_manager_bridge_destroy(msm_dsi->bridge);\n\t\tmsm_dsi->bridge = NULL;\n\t}\n\n\treturn ret;\n}\n\nvoid msm_dsi_snapshot(struct msm_disp_state *disp_state, struct msm_dsi *msm_dsi)\n{\n\tmsm_dsi_host_snapshot(disp_state, msm_dsi->host);\n\tmsm_dsi_phy_snapshot(disp_state, msm_dsi->phy);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}