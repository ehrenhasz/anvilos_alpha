{
  "module_name": "dsi_manager.c",
  "hash_id": "d6674e930dc88cc4d50882decea375d9f0be5d2e04b61fdd1af1030d67e66f22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dsi/dsi_manager.c",
  "human_readable_source": "\n \n\n#include \"drm/drm_bridge_connector.h\"\n\n#include \"msm_kms.h\"\n#include \"dsi.h\"\n\n#define DSI_CLOCK_MASTER\tDSI_0\n#define DSI_CLOCK_SLAVE\t\tDSI_1\n\n#define DSI_LEFT\t\tDSI_0\n#define DSI_RIGHT\t\tDSI_1\n\n \n#define DSI_ENCODER_MASTER\tDSI_1\n#define DSI_ENCODER_SLAVE\tDSI_0\n\nstruct msm_dsi_manager {\n\tstruct msm_dsi *dsi[DSI_MAX];\n\n\tbool is_bonded_dsi;\n\tbool is_sync_needed;\n\tint master_dsi_link_id;\n};\n\nstatic struct msm_dsi_manager msm_dsim_glb;\n\n#define IS_BONDED_DSI()\t\t(msm_dsim_glb.is_bonded_dsi)\n#define IS_SYNC_NEEDED()\t(msm_dsim_glb.is_sync_needed)\n#define IS_MASTER_DSI_LINK(id)\t(msm_dsim_glb.master_dsi_link_id == id)\n\nstatic inline struct msm_dsi *dsi_mgr_get_dsi(int id)\n{\n\treturn msm_dsim_glb.dsi[id];\n}\n\nstatic inline struct msm_dsi *dsi_mgr_get_other_dsi(int id)\n{\n\treturn msm_dsim_glb.dsi[(id + 1) % DSI_MAX];\n}\n\nstatic int dsi_mgr_parse_of(struct device_node *np, int id)\n{\n\tstruct msm_dsi_manager *msm_dsim = &msm_dsim_glb;\n\n\t \n\tif (!msm_dsim->is_bonded_dsi)\n\t\tmsm_dsim->is_bonded_dsi = of_property_read_bool(np, \"qcom,dual-dsi-mode\");\n\n\tif (msm_dsim->is_bonded_dsi) {\n\t\tif (of_property_read_bool(np, \"qcom,master-dsi\"))\n\t\t\tmsm_dsim->master_dsi_link_id = id;\n\t\tif (!msm_dsim->is_sync_needed)\n\t\t\tmsm_dsim->is_sync_needed = of_property_read_bool(\n\t\t\t\t\tnp, \"qcom,sync-dual-dsi\");\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_mgr_setup_components(int id)\n{\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct msm_dsi *other_dsi = dsi_mgr_get_other_dsi(id);\n\tstruct msm_dsi *clk_master_dsi = dsi_mgr_get_dsi(DSI_CLOCK_MASTER);\n\tstruct msm_dsi *clk_slave_dsi = dsi_mgr_get_dsi(DSI_CLOCK_SLAVE);\n\tint ret;\n\n\tif (!IS_BONDED_DSI()) {\n\t\tret = msm_dsi_host_register(msm_dsi->host);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmsm_dsi_phy_set_usecase(msm_dsi->phy, MSM_DSI_PHY_STANDALONE);\n\t\tmsm_dsi_host_set_phy_mode(msm_dsi->host, msm_dsi->phy);\n\t} else if (other_dsi) {\n\t\tstruct msm_dsi *master_link_dsi = IS_MASTER_DSI_LINK(id) ?\n\t\t\t\t\t\t\tmsm_dsi : other_dsi;\n\t\tstruct msm_dsi *slave_link_dsi = IS_MASTER_DSI_LINK(id) ?\n\t\t\t\t\t\t\tother_dsi : msm_dsi;\n\t\t \n\t\tret = msm_dsi_host_register(slave_link_dsi->host);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = msm_dsi_host_register(master_link_dsi->host);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tmsm_dsi_phy_set_usecase(clk_master_dsi->phy,\n\t\t\t\t\tMSM_DSI_PHY_MASTER);\n\t\tmsm_dsi_phy_set_usecase(clk_slave_dsi->phy,\n\t\t\t\t\tMSM_DSI_PHY_SLAVE);\n\t\tmsm_dsi_host_set_phy_mode(msm_dsi->host, msm_dsi->phy);\n\t\tmsm_dsi_host_set_phy_mode(other_dsi->host, other_dsi->phy);\n\t}\n\n\treturn 0;\n}\n\nstatic int enable_phy(struct msm_dsi *msm_dsi,\n\t\t      struct msm_dsi_phy_shared_timings *shared_timings)\n{\n\tstruct msm_dsi_phy_clk_request clk_req;\n\tbool is_bonded_dsi = IS_BONDED_DSI();\n\n\tmsm_dsi_host_get_phy_clk_req(msm_dsi->host, &clk_req, is_bonded_dsi);\n\n\treturn msm_dsi_phy_enable(msm_dsi->phy, &clk_req, shared_timings);\n}\n\nstatic int\ndsi_mgr_phy_enable(int id,\n\t\t   struct msm_dsi_phy_shared_timings shared_timings[DSI_MAX])\n{\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct msm_dsi *mdsi = dsi_mgr_get_dsi(DSI_CLOCK_MASTER);\n\tstruct msm_dsi *sdsi = dsi_mgr_get_dsi(DSI_CLOCK_SLAVE);\n\tint ret;\n\n\t \n\tif (IS_BONDED_DSI() && mdsi && sdsi) {\n\t\tif (!mdsi->phy_enabled && !sdsi->phy_enabled) {\n\t\t\tmsm_dsi_host_reset_phy(mdsi->host);\n\t\t\tmsm_dsi_host_reset_phy(sdsi->host);\n\n\t\t\tret = enable_phy(mdsi,\n\t\t\t\t\t &shared_timings[DSI_CLOCK_MASTER]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = enable_phy(sdsi,\n\t\t\t\t\t &shared_timings[DSI_CLOCK_SLAVE]);\n\t\t\tif (ret) {\n\t\t\t\tmsm_dsi_phy_disable(mdsi->phy);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmsm_dsi_host_reset_phy(msm_dsi->host);\n\t\tret = enable_phy(msm_dsi, &shared_timings[id]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmsm_dsi->phy_enabled = true;\n\n\treturn 0;\n}\n\nstatic void dsi_mgr_phy_disable(int id)\n{\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct msm_dsi *mdsi = dsi_mgr_get_dsi(DSI_CLOCK_MASTER);\n\tstruct msm_dsi *sdsi = dsi_mgr_get_dsi(DSI_CLOCK_SLAVE);\n\n\t \n\tmsm_dsi->phy_enabled = false;\n\tif (IS_BONDED_DSI() && mdsi && sdsi) {\n\t\tif (!mdsi->phy_enabled && !sdsi->phy_enabled) {\n\t\t\tmsm_dsi_phy_disable(sdsi->phy);\n\t\t\tmsm_dsi_phy_disable(mdsi->phy);\n\t\t}\n\t} else {\n\t\tmsm_dsi_phy_disable(msm_dsi->phy);\n\t}\n}\n\nstruct dsi_bridge {\n\tstruct drm_bridge base;\n\tint id;\n};\n\n#define to_dsi_bridge(x) container_of(x, struct dsi_bridge, base)\n\nstatic int dsi_mgr_bridge_get_id(struct drm_bridge *bridge)\n{\n\tstruct dsi_bridge *dsi_bridge = to_dsi_bridge(bridge);\n\treturn dsi_bridge->id;\n}\n\nstatic void msm_dsi_manager_set_split_display(u8 id)\n{\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct msm_dsi *other_dsi = dsi_mgr_get_other_dsi(id);\n\tstruct msm_drm_private *priv = msm_dsi->dev->dev_private;\n\tstruct msm_kms *kms = priv->kms;\n\tstruct msm_dsi *master_dsi, *slave_dsi;\n\n\tif (IS_BONDED_DSI() && !IS_MASTER_DSI_LINK(id)) {\n\t\tmaster_dsi = other_dsi;\n\t\tslave_dsi = msm_dsi;\n\t} else {\n\t\tmaster_dsi = msm_dsi;\n\t\tslave_dsi = other_dsi;\n\t}\n\n\tif (!msm_dsi->external_bridge || !IS_BONDED_DSI())\n\t\treturn;\n\n\t \n\tif (other_dsi && other_dsi->external_bridge && kms->funcs->set_split_display) {\n\t\tkms->funcs->set_split_display(kms, master_dsi->encoder,\n\t\t\t\t\t      slave_dsi->encoder,\n\t\t\t\t\t      msm_dsi_is_cmd_mode(msm_dsi));\n\t}\n}\n\nstatic int dsi_mgr_bridge_power_on(struct drm_bridge *bridge)\n{\n\tint id = dsi_mgr_bridge_get_id(bridge);\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct msm_dsi *msm_dsi1 = dsi_mgr_get_dsi(DSI_1);\n\tstruct mipi_dsi_host *host = msm_dsi->host;\n\tstruct msm_dsi_phy_shared_timings phy_shared_timings[DSI_MAX];\n\tbool is_bonded_dsi = IS_BONDED_DSI();\n\tint ret;\n\n\tDBG(\"id=%d\", id);\n\n\tret = dsi_mgr_phy_enable(id, phy_shared_timings);\n\tif (ret)\n\t\tgoto phy_en_fail;\n\n\tret = msm_dsi_host_power_on(host, &phy_shared_timings[id], is_bonded_dsi, msm_dsi->phy);\n\tif (ret) {\n\t\tpr_err(\"%s: power on host %d failed, %d\\n\", __func__, id, ret);\n\t\tgoto host_on_fail;\n\t}\n\n\tif (is_bonded_dsi && msm_dsi1) {\n\t\tret = msm_dsi_host_power_on(msm_dsi1->host,\n\t\t\t\t&phy_shared_timings[DSI_1], is_bonded_dsi, msm_dsi1->phy);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: power on host1 failed, %d\\n\",\n\t\t\t\t\t\t\t__func__, ret);\n\t\t\tgoto host1_on_fail;\n\t\t}\n\t}\n\n\t \n\tmsm_dsi_host_enable_irq(host);\n\tif (is_bonded_dsi && msm_dsi1)\n\t\tmsm_dsi_host_enable_irq(msm_dsi1->host);\n\n\treturn 0;\n\nhost1_on_fail:\n\tmsm_dsi_host_power_off(host);\nhost_on_fail:\n\tdsi_mgr_phy_disable(id);\nphy_en_fail:\n\treturn ret;\n}\n\nstatic void dsi_mgr_bridge_power_off(struct drm_bridge *bridge)\n{\n\tint id = dsi_mgr_bridge_get_id(bridge);\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct msm_dsi *msm_dsi1 = dsi_mgr_get_dsi(DSI_1);\n\tstruct mipi_dsi_host *host = msm_dsi->host;\n\tbool is_bonded_dsi = IS_BONDED_DSI();\n\n\tmsm_dsi_host_disable_irq(host);\n\tif (is_bonded_dsi && msm_dsi1) {\n\t\tmsm_dsi_host_disable_irq(msm_dsi1->host);\n\t\tmsm_dsi_host_power_off(msm_dsi1->host);\n\t}\n\tmsm_dsi_host_power_off(host);\n\tdsi_mgr_phy_disable(id);\n}\n\nstatic void dsi_mgr_bridge_pre_enable(struct drm_bridge *bridge)\n{\n\tint id = dsi_mgr_bridge_get_id(bridge);\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct msm_dsi *msm_dsi1 = dsi_mgr_get_dsi(DSI_1);\n\tstruct mipi_dsi_host *host = msm_dsi->host;\n\tbool is_bonded_dsi = IS_BONDED_DSI();\n\tint ret;\n\n\tDBG(\"id=%d\", id);\n\tif (!msm_dsi_device_connected(msm_dsi))\n\t\treturn;\n\n\t \n\tif (is_bonded_dsi && !IS_MASTER_DSI_LINK(id))\n\t\treturn;\n\n\tret = dsi_mgr_bridge_power_on(bridge);\n\tif (ret) {\n\t\tdev_err(&msm_dsi->pdev->dev, \"Power on failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = msm_dsi_host_enable(host);\n\tif (ret) {\n\t\tpr_err(\"%s: enable host %d failed, %d\\n\", __func__, id, ret);\n\t\tgoto host_en_fail;\n\t}\n\n\tif (is_bonded_dsi && msm_dsi1) {\n\t\tret = msm_dsi_host_enable(msm_dsi1->host);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: enable host1 failed, %d\\n\", __func__, ret);\n\t\t\tgoto host1_en_fail;\n\t\t}\n\t}\n\n\treturn;\n\nhost1_en_fail:\n\tmsm_dsi_host_disable(host);\nhost_en_fail:\n\tdsi_mgr_bridge_power_off(bridge);\n}\n\nvoid msm_dsi_manager_tpg_enable(void)\n{\n\tstruct msm_dsi *m_dsi = dsi_mgr_get_dsi(DSI_0);\n\tstruct msm_dsi *s_dsi = dsi_mgr_get_dsi(DSI_1);\n\n\t \n\tif (m_dsi) {\n\t\tmsm_dsi_host_test_pattern_en(m_dsi->host);\n\t\tif (IS_BONDED_DSI() && s_dsi)\n\t\t\tmsm_dsi_host_test_pattern_en(s_dsi->host);\n\t}\n}\n\nstatic void dsi_mgr_bridge_post_disable(struct drm_bridge *bridge)\n{\n\tint id = dsi_mgr_bridge_get_id(bridge);\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct msm_dsi *msm_dsi1 = dsi_mgr_get_dsi(DSI_1);\n\tstruct mipi_dsi_host *host = msm_dsi->host;\n\tbool is_bonded_dsi = IS_BONDED_DSI();\n\tint ret;\n\n\tDBG(\"id=%d\", id);\n\n\tif (!msm_dsi_device_connected(msm_dsi))\n\t\treturn;\n\n\t \n\tif (is_bonded_dsi && !IS_MASTER_DSI_LINK(id))\n\t\tgoto disable_phy;\n\n\tret = msm_dsi_host_disable(host);\n\tif (ret)\n\t\tpr_err(\"%s: host %d disable failed, %d\\n\", __func__, id, ret);\n\n\tif (is_bonded_dsi && msm_dsi1) {\n\t\tret = msm_dsi_host_disable(msm_dsi1->host);\n\t\tif (ret)\n\t\t\tpr_err(\"%s: host1 disable failed, %d\\n\", __func__, ret);\n\t}\n\n\tmsm_dsi_host_disable_irq(host);\n\tif (is_bonded_dsi && msm_dsi1)\n\t\tmsm_dsi_host_disable_irq(msm_dsi1->host);\n\n\t \n\tmsm_dsi_phy_pll_save_state(msm_dsi->phy);\n\n\tret = msm_dsi_host_power_off(host);\n\tif (ret)\n\t\tpr_err(\"%s: host %d power off failed,%d\\n\", __func__, id, ret);\n\n\tif (is_bonded_dsi && msm_dsi1) {\n\t\tret = msm_dsi_host_power_off(msm_dsi1->host);\n\t\tif (ret)\n\t\t\tpr_err(\"%s: host1 power off failed, %d\\n\",\n\t\t\t\t\t\t\t\t__func__, ret);\n\t}\n\ndisable_phy:\n\tdsi_mgr_phy_disable(id);\n}\n\nstatic void dsi_mgr_bridge_mode_set(struct drm_bridge *bridge,\n\t\tconst struct drm_display_mode *mode,\n\t\tconst struct drm_display_mode *adjusted_mode)\n{\n\tint id = dsi_mgr_bridge_get_id(bridge);\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct msm_dsi *other_dsi = dsi_mgr_get_other_dsi(id);\n\tstruct mipi_dsi_host *host = msm_dsi->host;\n\tbool is_bonded_dsi = IS_BONDED_DSI();\n\n\tDBG(\"set mode: \" DRM_MODE_FMT, DRM_MODE_ARG(mode));\n\n\tif (is_bonded_dsi && !IS_MASTER_DSI_LINK(id))\n\t\treturn;\n\n\tmsm_dsi_host_set_display_mode(host, adjusted_mode);\n\tif (is_bonded_dsi && other_dsi)\n\t\tmsm_dsi_host_set_display_mode(other_dsi->host, adjusted_mode);\n}\n\nstatic enum drm_mode_status dsi_mgr_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t\t\t      const struct drm_display_info *info,\n\t\t\t\t\t\t      const struct drm_display_mode *mode)\n{\n\tint id = dsi_mgr_bridge_get_id(bridge);\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct mipi_dsi_host *host = msm_dsi->host;\n\tstruct platform_device *pdev = msm_dsi->pdev;\n\tstruct dev_pm_opp *opp;\n\tunsigned long byte_clk_rate;\n\n\tbyte_clk_rate = dsi_byte_clk_get_rate(host, IS_BONDED_DSI(), mode);\n\n\topp = dev_pm_opp_find_freq_ceil(&pdev->dev, &byte_clk_rate);\n\tif (!IS_ERR(opp)) {\n\t\tdev_pm_opp_put(opp);\n\t} else if (PTR_ERR(opp) == -ERANGE) {\n\t\t \n\t\tif (dev_pm_opp_get_opp_count(&pdev->dev) != 0)\n\t\t\treturn MODE_CLOCK_RANGE;\n\t} else {\n\t\t\treturn MODE_ERROR;\n\t}\n\n\treturn msm_dsi_host_check_dsc(host, mode);\n}\n\nstatic const struct drm_bridge_funcs dsi_mgr_bridge_funcs = {\n\t.pre_enable = dsi_mgr_bridge_pre_enable,\n\t.post_disable = dsi_mgr_bridge_post_disable,\n\t.mode_set = dsi_mgr_bridge_mode_set,\n\t.mode_valid = dsi_mgr_bridge_mode_valid,\n};\n\n \nstruct drm_bridge *msm_dsi_manager_bridge_init(u8 id)\n{\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct drm_bridge *bridge = NULL;\n\tstruct dsi_bridge *dsi_bridge;\n\tstruct drm_encoder *encoder;\n\tint ret;\n\n\tdsi_bridge = devm_kzalloc(msm_dsi->dev->dev,\n\t\t\t\tsizeof(*dsi_bridge), GFP_KERNEL);\n\tif (!dsi_bridge) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tdsi_bridge->id = id;\n\n\tencoder = msm_dsi->encoder;\n\n\tbridge = &dsi_bridge->base;\n\tbridge->funcs = &dsi_mgr_bridge_funcs;\n\n\tdrm_bridge_add(bridge);\n\n\tret = drm_bridge_attach(encoder, bridge, NULL, 0);\n\tif (ret)\n\t\tgoto fail;\n\n\treturn bridge;\n\nfail:\n\tif (bridge)\n\t\tmsm_dsi_manager_bridge_destroy(bridge);\n\n\treturn ERR_PTR(ret);\n}\n\nint msm_dsi_manager_ext_bridge_init(u8 id)\n{\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct drm_device *dev = msm_dsi->dev;\n\tstruct drm_encoder *encoder;\n\tstruct drm_bridge *int_bridge, *ext_bridge;\n\tint ret;\n\n\tint_bridge = msm_dsi->bridge;\n\text_bridge = devm_drm_of_get_bridge(&msm_dsi->pdev->dev,\n\t\t\t\t\t    msm_dsi->pdev->dev.of_node, 1, 0);\n\tif (IS_ERR(ext_bridge))\n\t\treturn PTR_ERR(ext_bridge);\n\n\tmsm_dsi->external_bridge = ext_bridge;\n\n\tencoder = msm_dsi->encoder;\n\n\t \n\tret = drm_bridge_attach(encoder, ext_bridge, int_bridge,\n\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret == -EINVAL) {\n\t\t \n\t\tret = drm_bridge_attach(encoder, ext_bridge, int_bridge, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tstruct drm_connector *connector;\n\n\t\t \n\t\tconnector = drm_bridge_connector_init(dev, encoder);\n\t\tif (IS_ERR(connector)) {\n\t\t\tDRM_ERROR(\"Unable to create bridge connector\\n\");\n\t\t\treturn PTR_ERR(connector);\n\t\t}\n\n\t\tret = drm_connector_attach_encoder(connector, encoder);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmsm_dsi_manager_set_split_display(id);\n\n\treturn 0;\n}\n\nvoid msm_dsi_manager_bridge_destroy(struct drm_bridge *bridge)\n{\n\tdrm_bridge_remove(bridge);\n}\n\nint msm_dsi_manager_cmd_xfer(int id, const struct mipi_dsi_msg *msg)\n{\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct msm_dsi *msm_dsi0 = dsi_mgr_get_dsi(DSI_0);\n\tstruct mipi_dsi_host *host = msm_dsi->host;\n\tbool is_read = (msg->rx_buf && msg->rx_len);\n\tbool need_sync = (IS_SYNC_NEEDED() && !is_read);\n\tint ret;\n\n\tif (!msg->tx_buf || !msg->tx_len)\n\t\treturn 0;\n\n\t \n\tif (need_sync && (id == DSI_0))\n\t\treturn is_read ? msg->rx_len : msg->tx_len;\n\n\tif (need_sync && msm_dsi0) {\n\t\tret = msm_dsi_host_xfer_prepare(msm_dsi0->host, msg);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: failed to prepare non-trigger host, %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = msm_dsi_host_xfer_prepare(host, msg);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to prepare host, %d\\n\", __func__, ret);\n\t\tgoto restore_host0;\n\t}\n\n\tret = is_read ? msm_dsi_host_cmd_rx(host, msg) :\n\t\t\tmsm_dsi_host_cmd_tx(host, msg);\n\n\tmsm_dsi_host_xfer_restore(host, msg);\n\nrestore_host0:\n\tif (need_sync && msm_dsi0)\n\t\tmsm_dsi_host_xfer_restore(msm_dsi0->host, msg);\n\n\treturn ret;\n}\n\nbool msm_dsi_manager_cmd_xfer_trigger(int id, u32 dma_base, u32 len)\n{\n\tstruct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);\n\tstruct msm_dsi *msm_dsi0 = dsi_mgr_get_dsi(DSI_0);\n\tstruct mipi_dsi_host *host = msm_dsi->host;\n\n\tif (IS_SYNC_NEEDED() && (id == DSI_0))\n\t\treturn false;\n\n\tif (IS_SYNC_NEEDED() && msm_dsi0)\n\t\tmsm_dsi_host_cmd_xfer_commit(msm_dsi0->host, dma_base, len);\n\n\tmsm_dsi_host_cmd_xfer_commit(host, dma_base, len);\n\n\treturn true;\n}\n\nint msm_dsi_manager_register(struct msm_dsi *msm_dsi)\n{\n\tstruct msm_dsi_manager *msm_dsim = &msm_dsim_glb;\n\tint id = msm_dsi->id;\n\tint ret;\n\n\tif (id >= DSI_MAX) {\n\t\tpr_err(\"%s: invalid id %d\\n\", __func__, id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (msm_dsim->dsi[id]) {\n\t\tpr_err(\"%s: dsi%d already registered\\n\", __func__, id);\n\t\treturn -EBUSY;\n\t}\n\n\tmsm_dsim->dsi[id] = msm_dsi;\n\n\tret = dsi_mgr_parse_of(msm_dsi->pdev->dev.of_node, id);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to parse OF DSI info\\n\", __func__);\n\t\tgoto fail;\n\t}\n\n\tret = dsi_mgr_setup_components(id);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to register mipi dsi host for DSI %d: %d\\n\",\n\t\t\t__func__, id, ret);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tmsm_dsim->dsi[id] = NULL;\n\treturn ret;\n}\n\nvoid msm_dsi_manager_unregister(struct msm_dsi *msm_dsi)\n{\n\tstruct msm_dsi_manager *msm_dsim = &msm_dsim_glb;\n\n\tif (msm_dsi->host)\n\t\tmsm_dsi_host_unregister(msm_dsi->host);\n\n\tif (msm_dsi->id >= 0)\n\t\tmsm_dsim->dsi[msm_dsi->id] = NULL;\n}\n\nbool msm_dsi_is_bonded_dsi(struct msm_dsi *msm_dsi)\n{\n\treturn IS_BONDED_DSI();\n}\n\nbool msm_dsi_is_master_dsi(struct msm_dsi *msm_dsi)\n{\n\treturn IS_MASTER_DSI_LINK(msm_dsi->id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}