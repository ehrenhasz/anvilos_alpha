{
  "module_name": "dsi_phy_20nm.c",
  "hash_id": "a86826e827493b5f9af5839ebcd0b5bb0ed1ef2462628ea28ceef1acb9786865",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dsi/phy/dsi_phy_20nm.c",
  "human_readable_source": "\n \n\n#include \"dsi_phy.h\"\n#include \"dsi.xml.h\"\n#include \"dsi_phy_20nm.xml.h\"\n\nstatic void dsi_20nm_dphy_set_timing(struct msm_dsi_phy *phy,\n\t\tstruct msm_dsi_dphy_timing *timing)\n{\n\tvoid __iomem *base = phy->base;\n\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_0,\n\t\tDSI_20nm_PHY_TIMING_CTRL_0_CLK_ZERO(timing->clk_zero));\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_1,\n\t\tDSI_20nm_PHY_TIMING_CTRL_1_CLK_TRAIL(timing->clk_trail));\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_2,\n\t\tDSI_20nm_PHY_TIMING_CTRL_2_CLK_PREPARE(timing->clk_prepare));\n\tif (timing->clk_zero & BIT(8))\n\t\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_3,\n\t\t\tDSI_20nm_PHY_TIMING_CTRL_3_CLK_ZERO_8);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_4,\n\t\tDSI_20nm_PHY_TIMING_CTRL_4_HS_EXIT(timing->hs_exit));\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_5,\n\t\tDSI_20nm_PHY_TIMING_CTRL_5_HS_ZERO(timing->hs_zero));\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_6,\n\t\tDSI_20nm_PHY_TIMING_CTRL_6_HS_PREPARE(timing->hs_prepare));\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_7,\n\t\tDSI_20nm_PHY_TIMING_CTRL_7_HS_TRAIL(timing->hs_trail));\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_8,\n\t\tDSI_20nm_PHY_TIMING_CTRL_8_HS_RQST(timing->hs_rqst));\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_9,\n\t\tDSI_20nm_PHY_TIMING_CTRL_9_TA_GO(timing->ta_go) |\n\t\tDSI_20nm_PHY_TIMING_CTRL_9_TA_SURE(timing->ta_sure));\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_10,\n\t\tDSI_20nm_PHY_TIMING_CTRL_10_TA_GET(timing->ta_get));\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_TIMING_CTRL_11,\n\t\tDSI_20nm_PHY_TIMING_CTRL_11_TRIG3_CMD(0));\n}\n\nstatic void dsi_20nm_phy_regulator_ctrl(struct msm_dsi_phy *phy, bool enable)\n{\n\tvoid __iomem *base = phy->reg_base;\n\n\tif (!enable) {\n\t\tdsi_phy_write(base + REG_DSI_20nm_PHY_REGULATOR_CAL_PWR_CFG, 0);\n\t\treturn;\n\t}\n\n\tif (phy->regulator_ldo_mode) {\n\t\tdsi_phy_write(phy->base + REG_DSI_20nm_PHY_LDO_CNTRL, 0x1d);\n\t\treturn;\n\t}\n\n\t \n\tdsi_phy_write(base + REG_DSI_20nm_PHY_REGULATOR_CTRL_1, 0x03);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_REGULATOR_CTRL_2, 0x03);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_REGULATOR_CTRL_3, 0x00);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_REGULATOR_CTRL_4, 0x20);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_REGULATOR_CAL_PWR_CFG, 0x01);\n\tdsi_phy_write(phy->base + REG_DSI_20nm_PHY_LDO_CNTRL, 0x00);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_REGULATOR_CTRL_0, 0x03);\n}\n\nstatic int dsi_20nm_phy_enable(struct msm_dsi_phy *phy,\n\t\t\t\tstruct msm_dsi_phy_clk_request *clk_req)\n{\n\tstruct msm_dsi_dphy_timing *timing = &phy->timing;\n\tint i;\n\tvoid __iomem *base = phy->base;\n\tu32 cfg_4[4] = {0x20, 0x40, 0x20, 0x00};\n\tu32 val;\n\n\tDBG(\"\");\n\n\tif (msm_dsi_dphy_timing_calc(timing, clk_req)) {\n\t\tDRM_DEV_ERROR(&phy->pdev->dev,\n\t\t\t\"%s: D-PHY timing calculation failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdsi_20nm_phy_regulator_ctrl(phy, true);\n\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_STRENGTH_0, 0xff);\n\n\tval = dsi_phy_read(base + REG_DSI_20nm_PHY_GLBL_TEST_CTRL);\n\tif (phy->id == DSI_1 && phy->usecase == MSM_DSI_PHY_STANDALONE)\n\t\tval |= DSI_20nm_PHY_GLBL_TEST_CTRL_BITCLK_HS_SEL;\n\telse\n\t\tval &= ~DSI_20nm_PHY_GLBL_TEST_CTRL_BITCLK_HS_SEL;\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_GLBL_TEST_CTRL, val);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tdsi_phy_write(base + REG_DSI_20nm_PHY_LN_CFG_3(i),\n\t\t\t\t\t\t\t(i >> 1) * 0x40);\n\t\tdsi_phy_write(base + REG_DSI_20nm_PHY_LN_TEST_STR_0(i), 0x01);\n\t\tdsi_phy_write(base + REG_DSI_20nm_PHY_LN_TEST_STR_1(i), 0x46);\n\t\tdsi_phy_write(base + REG_DSI_20nm_PHY_LN_CFG_0(i), 0x02);\n\t\tdsi_phy_write(base + REG_DSI_20nm_PHY_LN_CFG_1(i), 0xa0);\n\t\tdsi_phy_write(base + REG_DSI_20nm_PHY_LN_CFG_4(i), cfg_4[i]);\n\t}\n\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_LNCK_CFG_3, 0x80);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_LNCK_TEST_STR0, 0x01);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_LNCK_TEST_STR1, 0x46);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_LNCK_CFG_0, 0x00);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_LNCK_CFG_1, 0xa0);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_LNCK_CFG_2, 0x00);\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_LNCK_CFG_4, 0x00);\n\n\tdsi_20nm_dphy_set_timing(phy, timing);\n\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_CTRL_1, 0x00);\n\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_STRENGTH_1, 0x06);\n\n\t \n\twmb();\n\tdsi_phy_write(base + REG_DSI_20nm_PHY_CTRL_0, 0x7f);\n\n\treturn 0;\n}\n\nstatic void dsi_20nm_phy_disable(struct msm_dsi_phy *phy)\n{\n\tdsi_phy_write(phy->base + REG_DSI_20nm_PHY_CTRL_0, 0);\n\tdsi_20nm_phy_regulator_ctrl(phy, false);\n}\n\nstatic const struct regulator_bulk_data dsi_phy_20nm_regulators[] = {\n\t{ .supply = \"vddio\", .init_load_uA = 100000 },\t \n\t{ .supply = \"vcca\", .init_load_uA = 10000 },\t \n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_20nm_cfgs = {\n\t.has_phy_regulator = true,\n\t.regulator_data = dsi_phy_20nm_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_20nm_regulators),\n\t.ops = {\n\t\t.enable = dsi_20nm_phy_enable,\n\t\t.disable = dsi_20nm_phy_disable,\n\t},\n\t.io_start = { 0xfd998500, 0xfd9a0500 },\n\t.num_dsi_phy = 2,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}