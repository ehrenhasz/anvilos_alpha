{
  "module_name": "dsi_phy_28nm_8960.c",
  "hash_id": "8ea2d09fa6355120771bf82d8b67fe969c6ae3810be96a7c4e5e7d1f0f8da9de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n\n#include \"dsi_phy.h\"\n#include \"dsi.xml.h\"\n#include \"dsi_phy_28nm_8960.xml.h\"\n\n \n\n#define POLL_MAX_READS\t\t8000\n#define POLL_TIMEOUT_US\t\t1\n\n#define VCO_REF_CLK_RATE\t27000000\n#define VCO_MIN_RATE\t\t600000000\n#define VCO_MAX_RATE\t\t1200000000\n\n#define VCO_PREF_DIV_RATIO\t27\n\nstruct pll_28nm_cached_state {\n\tunsigned long vco_rate;\n\tu8 postdiv3;\n\tu8 postdiv2;\n\tu8 postdiv1;\n};\n\nstruct clk_bytediv {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n};\n\nstruct dsi_pll_28nm {\n\tstruct clk_hw clk_hw;\n\n\tstruct msm_dsi_phy *phy;\n\n\tstruct pll_28nm_cached_state cached_state;\n};\n\n#define to_pll_28nm(x)\tcontainer_of(x, struct dsi_pll_28nm, clk_hw)\n\nstatic bool pll_28nm_poll_for_ready(struct dsi_pll_28nm *pll_28nm,\n\t\t\t\t    int nb_tries, int timeout_us)\n{\n\tbool pll_locked = false;\n\tu32 val;\n\n\twhile (nb_tries--) {\n\t\tval = dsi_phy_read(pll_28nm->phy->pll_base + REG_DSI_28nm_8960_PHY_PLL_RDY);\n\t\tpll_locked = !!(val & DSI_28nm_8960_PHY_PLL_RDY_PLL_RDY);\n\n\t\tif (pll_locked)\n\t\t\tbreak;\n\n\t\tudelay(timeout_us);\n\t}\n\tDBG(\"DSI PLL is %slocked\", pll_locked ? \"\" : \"*not* \");\n\n\treturn pll_locked;\n}\n\n \nstatic int dsi_pll_28nm_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\tu32 val, temp, fb_divider;\n\n\tDBG(\"rate=%lu, parent's=%lu\", rate, parent_rate);\n\n\ttemp = rate / 10;\n\tval = VCO_REF_CLK_RATE / 10;\n\tfb_divider = (temp * VCO_PREF_DIV_RATIO) / val;\n\tfb_divider = fb_divider / 2 - 1;\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_1,\n\t\t      fb_divider & 0xff);\n\n\tval = dsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_2);\n\n\tval |= (fb_divider >> 8) & 0x07;\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_2,\n\t\t      val);\n\n\tval = dsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_3);\n\n\tval |= (VCO_PREF_DIV_RATIO - 1) & 0x3f;\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_3,\n\t\t      val);\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_6,\n\t\t      0xf);\n\n\tval = dsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8);\n\tval |= 0x7 << 4;\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8,\n\t\t      val);\n\n\treturn 0;\n}\n\nstatic int dsi_pll_28nm_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\n\treturn pll_28nm_poll_for_ready(pll_28nm, POLL_MAX_READS,\n\t\t\t\t\tPOLL_TIMEOUT_US);\n}\n\nstatic unsigned long dsi_pll_28nm_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\tunsigned long vco_rate;\n\tu32 status, fb_divider, temp, ref_divider;\n\n\tVERB(\"parent_rate=%lu\", parent_rate);\n\n\tstatus = dsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_0);\n\n\tif (status & DSI_28nm_8960_PHY_PLL_CTRL_0_ENABLE) {\n\t\tfb_divider = dsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_1);\n\t\tfb_divider &= 0xff;\n\t\ttemp = dsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_2) & 0x07;\n\t\tfb_divider = (temp << 8) | fb_divider;\n\t\tfb_divider += 1;\n\n\t\tref_divider = dsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_3);\n\t\tref_divider &= 0x3f;\n\t\tref_divider += 1;\n\n\t\t \n\t\tvco_rate = (parent_rate / ref_divider) * fb_divider * 2;\n\t} else {\n\t\tvco_rate = 0;\n\t}\n\n\tDBG(\"returning vco rate = %lu\", vco_rate);\n\n\treturn vco_rate;\n}\n\nstatic int dsi_pll_28nm_vco_prepare(struct clk_hw *hw)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\tstruct device *dev = &pll_28nm->phy->pdev->dev;\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\tbool locked;\n\tunsigned int bit_div, byte_div;\n\tint max_reads = 1000, timeout_us = 100;\n\tu32 val;\n\n\tDBG(\"id=%d\", pll_28nm->phy->id);\n\n\tif (unlikely(pll_28nm->phy->pll_on))\n\t\treturn 0;\n\n\t \n\tval = dsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_9);\n\tbyte_div = val + 1;\n\tbit_div = byte_div / 8;\n\n\tval = dsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8);\n\tval &= ~0xf;\n\tval |= (bit_div - 1);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8, val);\n\n\t \n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_0,\n\t\t      DSI_28nm_8960_PHY_PLL_CTRL_0_ENABLE);\n\n\tlocked = pll_28nm_poll_for_ready(pll_28nm, max_reads, timeout_us);\n\n\tif (unlikely(!locked)) {\n\t\tDRM_DEV_ERROR(dev, \"DSI PLL lock failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDBG(\"DSI PLL lock success\");\n\tpll_28nm->phy->pll_on = true;\n\n\treturn 0;\n}\n\nstatic void dsi_pll_28nm_vco_unprepare(struct clk_hw *hw)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\n\tDBG(\"id=%d\", pll_28nm->phy->id);\n\n\tif (unlikely(!pll_28nm->phy->pll_on))\n\t\treturn;\n\n\tdsi_phy_write(pll_28nm->phy->pll_base + REG_DSI_28nm_8960_PHY_PLL_CTRL_0, 0x00);\n\n\tpll_28nm->phy->pll_on = false;\n}\n\nstatic long dsi_pll_28nm_clk_round_rate(struct clk_hw *hw,\n\t\tunsigned long rate, unsigned long *parent_rate)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\n\tif      (rate < pll_28nm->phy->cfg->min_pll_rate)\n\t\treturn  pll_28nm->phy->cfg->min_pll_rate;\n\telse if (rate > pll_28nm->phy->cfg->max_pll_rate)\n\t\treturn  pll_28nm->phy->cfg->max_pll_rate;\n\telse\n\t\treturn rate;\n}\n\nstatic const struct clk_ops clk_ops_dsi_pll_28nm_vco = {\n\t.round_rate = dsi_pll_28nm_clk_round_rate,\n\t.set_rate = dsi_pll_28nm_clk_set_rate,\n\t.recalc_rate = dsi_pll_28nm_clk_recalc_rate,\n\t.prepare = dsi_pll_28nm_vco_prepare,\n\t.unprepare = dsi_pll_28nm_vco_unprepare,\n\t.is_enabled = dsi_pll_28nm_clk_is_enabled,\n};\n\n \n#define to_clk_bytediv(_hw) container_of(_hw, struct clk_bytediv, hw)\n\nstatic unsigned long clk_bytediv_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_bytediv *bytediv = to_clk_bytediv(hw);\n\tunsigned int div;\n\n\tdiv = dsi_phy_read(bytediv->reg) & 0xff;\n\n\treturn parent_rate / (div + 1);\n}\n\n \nstatic unsigned int get_vco_mul_factor(unsigned long byte_clk_rate)\n{\n\tunsigned long bit_mhz;\n\n\t \n\tbit_mhz = (byte_clk_rate * 8) / 1000000;\n\n\tif (bit_mhz < 125)\n\t\treturn 64;\n\telse if (bit_mhz < 250)\n\t\treturn 32;\n\telse if (bit_mhz < 600)\n\t\treturn 16;\n\telse\n\t\treturn 8;\n}\n\nstatic long clk_bytediv_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *prate)\n{\n\tunsigned long best_parent;\n\tunsigned int factor;\n\n\tfactor = get_vco_mul_factor(rate);\n\n\tbest_parent = rate * factor;\n\t*prate = clk_hw_round_rate(clk_hw_get_parent(hw), best_parent);\n\n\treturn *prate / factor;\n}\n\nstatic int clk_bytediv_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_bytediv *bytediv = to_clk_bytediv(hw);\n\tu32 val;\n\tunsigned int factor;\n\n\tfactor = get_vco_mul_factor(rate);\n\n\tval = dsi_phy_read(bytediv->reg);\n\tval |= (factor - 1) & 0xff;\n\tdsi_phy_write(bytediv->reg, val);\n\n\treturn 0;\n}\n\n \nstatic const struct clk_ops clk_bytediv_ops = {\n\t.round_rate = clk_bytediv_round_rate,\n\t.set_rate = clk_bytediv_set_rate,\n\t.recalc_rate = clk_bytediv_recalc_rate,\n};\n\n \nstatic void dsi_28nm_pll_save_state(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(phy->vco_hw);\n\tstruct pll_28nm_cached_state *cached_state = &pll_28nm->cached_state;\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\n\tcached_state->postdiv3 =\n\t\t\tdsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_10);\n\tcached_state->postdiv2 =\n\t\t\tdsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_9);\n\tcached_state->postdiv1 =\n\t\t\tdsi_phy_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8);\n\n\tcached_state->vco_rate = clk_hw_get_rate(phy->vco_hw);\n}\n\nstatic int dsi_28nm_pll_restore_state(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(phy->vco_hw);\n\tstruct pll_28nm_cached_state *cached_state = &pll_28nm->cached_state;\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\tint ret;\n\n\tret = dsi_pll_28nm_clk_set_rate(phy->vco_hw,\n\t\t\t\t\tcached_state->vco_rate, 0);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pll_28nm->phy->pdev->dev,\n\t\t\t      \"restore vco rate failed. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_10,\n\t\t      cached_state->postdiv3);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_9,\n\t\t      cached_state->postdiv2);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8,\n\t\t      cached_state->postdiv1);\n\n\treturn 0;\n}\n\nstatic int pll_28nm_register(struct dsi_pll_28nm *pll_28nm, struct clk_hw **provided_clocks)\n{\n\tchar clk_name[32];\n\tstruct clk_init_data vco_init = {\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"ref\",\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_IGNORE_UNUSED,\n\t\t.ops = &clk_ops_dsi_pll_28nm_vco,\n\t};\n\tstruct device *dev = &pll_28nm->phy->pdev->dev;\n\tstruct clk_hw *hw;\n\tstruct clk_bytediv *bytediv;\n\tstruct clk_init_data bytediv_init = { };\n\tint ret;\n\n\tDBG(\"%d\", pll_28nm->phy->id);\n\n\tbytediv = devm_kzalloc(dev, sizeof(*bytediv), GFP_KERNEL);\n\tif (!bytediv)\n\t\treturn -ENOMEM;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dvco_clk\", pll_28nm->phy->id);\n\tvco_init.name = clk_name;\n\n\tpll_28nm->clk_hw.init = &vco_init;\n\n\tret = devm_clk_hw_register(dev, &pll_28nm->clk_hw);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbytediv->hw.init = &bytediv_init;\n\tbytediv->reg = pll_28nm->phy->pll_base + REG_DSI_28nm_8960_PHY_PLL_CTRL_9;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dpllbyte\", pll_28nm->phy->id + 1);\n\n\tbytediv_init.name = clk_name;\n\tbytediv_init.ops = &clk_bytediv_ops;\n\tbytediv_init.flags = CLK_SET_RATE_PARENT;\n\tbytediv_init.parent_hws = (const struct clk_hw*[]){\n\t\t&pll_28nm->clk_hw,\n\t};\n\tbytediv_init.num_parents = 1;\n\n\t \n\tret = devm_clk_hw_register(dev, &bytediv->hw);\n\tif (ret)\n\t\treturn ret;\n\tprovided_clocks[DSI_BYTE_PLL_CLK] = &bytediv->hw;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dpll\", pll_28nm->phy->id + 1);\n\t \n\thw = devm_clk_hw_register_divider_parent_hw(dev, clk_name,\n\t\t\t&pll_28nm->clk_hw, 0, pll_28nm->phy->pll_base +\n\t\t\t\tREG_DSI_28nm_8960_PHY_PLL_CTRL_10,\n\t\t\t0, 8, 0, NULL);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\tprovided_clocks[DSI_PIXEL_PLL_CLK] = hw;\n\n\treturn 0;\n}\n\nstatic int dsi_pll_28nm_8960_init(struct msm_dsi_phy *phy)\n{\n\tstruct platform_device *pdev = phy->pdev;\n\tstruct dsi_pll_28nm *pll_28nm;\n\tint ret;\n\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tpll_28nm = devm_kzalloc(&pdev->dev, sizeof(*pll_28nm), GFP_KERNEL);\n\tif (!pll_28nm)\n\t\treturn -ENOMEM;\n\n\tpll_28nm->phy = phy;\n\n\tret = pll_28nm_register(pll_28nm, phy->provided_clocks->hws);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"failed to register PLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphy->vco_hw = &pll_28nm->clk_hw;\n\n\treturn 0;\n}\n\nstatic void dsi_28nm_dphy_set_timing(struct msm_dsi_phy *phy,\n\t\tstruct msm_dsi_dphy_timing *timing)\n{\n\tvoid __iomem *base = phy->base;\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_0,\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_0_CLK_ZERO(timing->clk_zero));\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_1,\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_1_CLK_TRAIL(timing->clk_trail));\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_2,\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_2_CLK_PREPARE(timing->clk_prepare));\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_3, 0x0);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_4,\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_4_HS_EXIT(timing->hs_exit));\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_5,\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_5_HS_ZERO(timing->hs_zero));\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_6,\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_6_HS_PREPARE(timing->hs_prepare));\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_7,\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_7_HS_TRAIL(timing->hs_trail));\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_8,\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_8_HS_RQST(timing->hs_rqst));\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_9,\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_9_TA_GO(timing->ta_go) |\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_9_TA_SURE(timing->ta_sure));\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_10,\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_10_TA_GET(timing->ta_get));\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_TIMING_CTRL_11,\n\t\t      DSI_28nm_8960_PHY_TIMING_CTRL_11_TRIG3_CMD(0));\n}\n\nstatic void dsi_28nm_phy_regulator_init(struct msm_dsi_phy *phy)\n{\n\tvoid __iomem *base = phy->reg_base;\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_REGULATOR_CTRL_0, 0x3);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_REGULATOR_CTRL_1, 1);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_REGULATOR_CTRL_2, 1);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_REGULATOR_CTRL_3, 0);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_REGULATOR_CTRL_4,\n\t\t      0x100);\n}\n\nstatic void dsi_28nm_phy_regulator_ctrl(struct msm_dsi_phy *phy)\n{\n\tvoid __iomem *base = phy->reg_base;\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_REGULATOR_CTRL_0, 0x3);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_REGULATOR_CTRL_1, 0xa);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_REGULATOR_CTRL_2, 0x4);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_REGULATOR_CTRL_3, 0x0);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_REGULATOR_CTRL_4, 0x20);\n}\n\nstatic void dsi_28nm_phy_calibration(struct msm_dsi_phy *phy)\n{\n\tvoid __iomem *base = phy->reg_base;\n\tu32 status;\n\tint i = 5000;\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_REGULATOR_CAL_PWR_CFG,\n\t\t      0x3);\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_CAL_SW_CFG_2, 0x0);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_CAL_HW_CFG_1, 0x5a);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_CAL_HW_CFG_3, 0x10);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_CAL_HW_CFG_4, 0x1);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_CAL_HW_CFG_0, 0x1);\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_CAL_HW_TRIGGER, 0x1);\n\tusleep_range(5000, 6000);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_MISC_CAL_HW_TRIGGER, 0x0);\n\n\tdo {\n\t\tstatus = dsi_phy_read(base +\n\t\t\t\tREG_DSI_28nm_8960_PHY_MISC_CAL_STATUS);\n\n\t\tif (!(status & DSI_28nm_8960_PHY_MISC_CAL_STATUS_CAL_BUSY))\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t} while (--i > 0);\n}\n\nstatic void dsi_28nm_phy_lane_config(struct msm_dsi_phy *phy)\n{\n\tvoid __iomem *base = phy->base;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LN_CFG_0(i), 0x80);\n\t\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LN_CFG_1(i), 0x45);\n\t\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LN_CFG_2(i), 0x00);\n\t\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LN_TEST_DATAPATH(i),\n\t\t\t      0x00);\n\t\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LN_TEST_STR_0(i),\n\t\t\t      0x01);\n\t\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LN_TEST_STR_1(i),\n\t\t\t      0x66);\n\t}\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LNCK_CFG_0, 0x40);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LNCK_CFG_1, 0x67);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LNCK_CFG_2, 0x0);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LNCK_TEST_DATAPATH, 0x0);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LNCK_TEST_STR0, 0x1);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LNCK_TEST_STR1, 0x88);\n}\n\nstatic int dsi_28nm_phy_enable(struct msm_dsi_phy *phy,\n\t\t\t\tstruct msm_dsi_phy_clk_request *clk_req)\n{\n\tstruct msm_dsi_dphy_timing *timing = &phy->timing;\n\tvoid __iomem *base = phy->base;\n\n\tDBG(\"\");\n\n\tif (msm_dsi_dphy_timing_calc(timing, clk_req)) {\n\t\tDRM_DEV_ERROR(&phy->pdev->dev,\n\t\t\t      \"%s: D-PHY timing calculation failed\\n\",\n\t\t\t      __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdsi_28nm_phy_regulator_init(phy);\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_LDO_CTRL, 0x04);\n\n\t \n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_STRENGTH_0, 0xff);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_STRENGTH_1, 0x00);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_STRENGTH_2, 0x06);\n\n\t \n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_CTRL_0, 0x5f);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_CTRL_1, 0x00);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_CTRL_2, 0x00);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_CTRL_3, 0x10);\n\n\tdsi_28nm_phy_regulator_ctrl(phy);\n\n\tdsi_28nm_phy_calibration(phy);\n\n\tdsi_28nm_phy_lane_config(phy);\n\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_BIST_CTRL_4, 0x0f);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_BIST_CTRL_1, 0x03);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_BIST_CTRL_0, 0x03);\n\tdsi_phy_write(base + REG_DSI_28nm_8960_PHY_BIST_CTRL_4, 0x0);\n\n\tdsi_28nm_dphy_set_timing(phy, timing);\n\n\treturn 0;\n}\n\nstatic void dsi_28nm_phy_disable(struct msm_dsi_phy *phy)\n{\n\tdsi_phy_write(phy->base + REG_DSI_28nm_8960_PHY_CTRL_0, 0x0);\n\n\t \n\twmb();\n}\n\nstatic const struct regulator_bulk_data dsi_phy_28nm_8960_regulators[] = {\n\t{ .supply = \"vddio\", .init_load_uA = 100000 },\t \n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_28nm_8960_cfgs = {\n\t.has_phy_regulator = true,\n\t.regulator_data = dsi_phy_28nm_8960_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_28nm_8960_regulators),\n\t.ops = {\n\t\t.enable = dsi_28nm_phy_enable,\n\t\t.disable = dsi_28nm_phy_disable,\n\t\t.pll_init = dsi_pll_28nm_8960_init,\n\t\t.save_pll_state = dsi_28nm_pll_save_state,\n\t\t.restore_pll_state = dsi_28nm_pll_restore_state,\n\t},\n\t.min_pll_rate = VCO_MIN_RATE,\n\t.max_pll_rate = VCO_MAX_RATE,\n\t.io_start = { 0x4700300, 0x5800300 },\n\t.num_dsi_phy = 2,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}