{
  "module_name": "dsi_phy.c",
  "hash_id": "414909a9986843a552e789aa08f609c7154be5887b0a421c230b824fa4e49860",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dsi/phy/dsi_phy.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/platform_device.h>\n#include <dt-bindings/phy/phy.h>\n\n#include \"dsi_phy.h\"\n\n#define S_DIV_ROUND_UP(n, d)\t\\\n\t(((n) >= 0) ? (((n) + (d) - 1) / (d)) : (((n) - (d) + 1) / (d)))\n\nstatic inline s32 linear_inter(s32 tmax, s32 tmin, s32 percent,\n\t\t\t\ts32 min_result, bool even)\n{\n\ts32 v;\n\n\tv = (tmax - tmin) * percent;\n\tv = S_DIV_ROUND_UP(v, 100) + tmin;\n\tif (even && (v & 0x1))\n\t\treturn max_t(s32, min_result, v - 1);\n\telse\n\t\treturn max_t(s32, min_result, v);\n}\n\nstatic void dsi_dphy_timing_calc_clk_zero(struct msm_dsi_dphy_timing *timing,\n\t\t\t\t\ts32 ui, s32 coeff, s32 pcnt)\n{\n\ts32 tmax, tmin, clk_z;\n\ts32 temp;\n\n\t \n\ttemp = 300 * coeff - ((timing->clk_prepare >> 1) + 1) * 2 * ui;\n\ttmin = S_DIV_ROUND_UP(temp, ui) - 2;\n\tif (tmin > 255) {\n\t\ttmax = 511;\n\t\tclk_z = linear_inter(2 * tmin, tmin, pcnt, 0, true);\n\t} else {\n\t\ttmax = 255;\n\t\tclk_z = linear_inter(tmax, tmin, pcnt, 0, true);\n\t}\n\n\t \n\ttemp = (timing->hs_rqst + timing->clk_prepare + clk_z) & 0x7;\n\ttiming->clk_zero = clk_z + 8 - temp;\n}\n\nint msm_dsi_dphy_timing_calc(struct msm_dsi_dphy_timing *timing,\n\t\t\t     struct msm_dsi_phy_clk_request *clk_req)\n{\n\tconst unsigned long bit_rate = clk_req->bitclk_rate;\n\tconst unsigned long esc_rate = clk_req->escclk_rate;\n\ts32 ui, lpx;\n\ts32 tmax, tmin;\n\ts32 pcnt0 = 10;\n\ts32 pcnt1 = (bit_rate > 1200000000) ? 15 : 10;\n\ts32 pcnt2 = 10;\n\ts32 pcnt3 = (bit_rate > 180000000) ? 10 : 40;\n\ts32 coeff = 1000;  \n\ts32 temp;\n\n\tif (!bit_rate || !esc_rate)\n\t\treturn -EINVAL;\n\n\tui = mult_frac(NSEC_PER_MSEC, coeff, bit_rate / 1000);\n\tlpx = mult_frac(NSEC_PER_MSEC, coeff, esc_rate / 1000);\n\n\ttmax = S_DIV_ROUND_UP(95 * coeff, ui) - 2;\n\ttmin = S_DIV_ROUND_UP(38 * coeff, ui) - 2;\n\ttiming->clk_prepare = linear_inter(tmax, tmin, pcnt0, 0, true);\n\n\ttemp = lpx / ui;\n\tif (temp & 0x1)\n\t\ttiming->hs_rqst = temp;\n\telse\n\t\ttiming->hs_rqst = max_t(s32, 0, temp - 2);\n\n\t \n\tdsi_dphy_timing_calc_clk_zero(timing, ui, coeff, pcnt2);\n\n\ttemp = 105 * coeff + 12 * ui - 20 * coeff;\n\ttmax = S_DIV_ROUND_UP(temp, ui) - 2;\n\ttmin = S_DIV_ROUND_UP(60 * coeff, ui) - 2;\n\ttiming->clk_trail = linear_inter(tmax, tmin, pcnt3, 0, true);\n\n\ttemp = 85 * coeff + 6 * ui;\n\ttmax = S_DIV_ROUND_UP(temp, ui) - 2;\n\ttemp = 40 * coeff + 4 * ui;\n\ttmin = S_DIV_ROUND_UP(temp, ui) - 2;\n\ttiming->hs_prepare = linear_inter(tmax, tmin, pcnt1, 0, true);\n\n\ttmax = 255;\n\ttemp = ((timing->hs_prepare >> 1) + 1) * 2 * ui + 2 * ui;\n\ttemp = 145 * coeff + 10 * ui - temp;\n\ttmin = S_DIV_ROUND_UP(temp, ui) - 2;\n\ttiming->hs_zero = linear_inter(tmax, tmin, pcnt2, 24, true);\n\n\ttemp = 105 * coeff + 12 * ui - 20 * coeff;\n\ttmax = S_DIV_ROUND_UP(temp, ui) - 2;\n\ttemp = 60 * coeff + 4 * ui;\n\ttmin = DIV_ROUND_UP(temp, ui) - 2;\n\ttiming->hs_trail = linear_inter(tmax, tmin, pcnt3, 0, true);\n\n\ttmax = 255;\n\ttmin = S_DIV_ROUND_UP(100 * coeff, ui) - 2;\n\ttiming->hs_exit = linear_inter(tmax, tmin, pcnt2, 0, true);\n\n\ttmax = 63;\n\ttemp = ((timing->hs_exit >> 1) + 1) * 2 * ui;\n\ttemp = 60 * coeff + 52 * ui - 24 * ui - temp;\n\ttmin = S_DIV_ROUND_UP(temp, 8 * ui) - 1;\n\ttiming->shared_timings.clk_post = linear_inter(tmax, tmin, pcnt2, 0,\n\t\t\t\t\t\t       false);\n\ttmax = 63;\n\ttemp = ((timing->clk_prepare >> 1) + 1) * 2 * ui;\n\ttemp += ((timing->clk_zero >> 1) + 1) * 2 * ui;\n\ttemp += 8 * ui + lpx;\n\ttmin = S_DIV_ROUND_UP(temp, 8 * ui) - 1;\n\tif (tmin > tmax) {\n\t\ttemp = linear_inter(2 * tmax, tmin, pcnt2, 0, false);\n\t\ttiming->shared_timings.clk_pre = temp >> 1;\n\t\ttiming->shared_timings.clk_pre_inc_by_2 = true;\n\t} else {\n\t\ttiming->shared_timings.clk_pre =\n\t\t\t\tlinear_inter(tmax, tmin, pcnt2, 0, false);\n\t\ttiming->shared_timings.clk_pre_inc_by_2 = false;\n\t}\n\n\ttiming->ta_go = 3;\n\ttiming->ta_sure = 0;\n\ttiming->ta_get = 4;\n\n\tDBG(\"PHY timings: %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\",\n\t\ttiming->shared_timings.clk_pre, timing->shared_timings.clk_post,\n\t\ttiming->shared_timings.clk_pre_inc_by_2, timing->clk_zero,\n\t\ttiming->clk_trail, timing->clk_prepare, timing->hs_exit,\n\t\ttiming->hs_zero, timing->hs_prepare, timing->hs_trail,\n\t\ttiming->hs_rqst);\n\n\treturn 0;\n}\n\nint msm_dsi_dphy_timing_calc_v2(struct msm_dsi_dphy_timing *timing,\n\t\t\t\tstruct msm_dsi_phy_clk_request *clk_req)\n{\n\tconst unsigned long bit_rate = clk_req->bitclk_rate;\n\tconst unsigned long esc_rate = clk_req->escclk_rate;\n\ts32 ui, ui_x8;\n\ts32 tmax, tmin;\n\ts32 pcnt0 = 50;\n\ts32 pcnt1 = 50;\n\ts32 pcnt2 = 10;\n\ts32 pcnt3 = 30;\n\ts32 pcnt4 = 10;\n\ts32 pcnt5 = 2;\n\ts32 coeff = 1000;  \n\ts32 hb_en, hb_en_ckln, pd_ckln, pd;\n\ts32 val, val_ckln;\n\ts32 temp;\n\n\tif (!bit_rate || !esc_rate)\n\t\treturn -EINVAL;\n\n\ttiming->hs_halfbyte_en = 0;\n\thb_en = 0;\n\ttiming->hs_halfbyte_en_ckln = 0;\n\thb_en_ckln = 0;\n\ttiming->hs_prep_dly_ckln = (bit_rate > 100000000) ? 0 : 3;\n\tpd_ckln = timing->hs_prep_dly_ckln;\n\ttiming->hs_prep_dly = (bit_rate > 120000000) ? 0 : 1;\n\tpd = timing->hs_prep_dly;\n\n\tval = (hb_en << 2) + (pd << 1);\n\tval_ckln = (hb_en_ckln << 2) + (pd_ckln << 1);\n\n\tui = mult_frac(NSEC_PER_MSEC, coeff, bit_rate / 1000);\n\tui_x8 = ui << 3;\n\n\ttemp = S_DIV_ROUND_UP(38 * coeff - val_ckln * ui, ui_x8);\n\ttmin = max_t(s32, temp, 0);\n\ttemp = (95 * coeff - val_ckln * ui) / ui_x8;\n\ttmax = max_t(s32, temp, 0);\n\ttiming->clk_prepare = linear_inter(tmax, tmin, pcnt0, 0, false);\n\n\ttemp = 300 * coeff - ((timing->clk_prepare << 3) + val_ckln) * ui;\n\ttmin = S_DIV_ROUND_UP(temp - 11 * ui, ui_x8) - 3;\n\ttmax = (tmin > 255) ? 511 : 255;\n\ttiming->clk_zero = linear_inter(tmax, tmin, pcnt5, 0, false);\n\n\ttmin = DIV_ROUND_UP(60 * coeff + 3 * ui, ui_x8);\n\ttemp = 105 * coeff + 12 * ui - 20 * coeff;\n\ttmax = (temp + 3 * ui) / ui_x8;\n\ttiming->clk_trail = linear_inter(tmax, tmin, pcnt3, 0, false);\n\n\ttemp = S_DIV_ROUND_UP(40 * coeff + 4 * ui - val * ui, ui_x8);\n\ttmin = max_t(s32, temp, 0);\n\ttemp = (85 * coeff + 6 * ui - val * ui) / ui_x8;\n\ttmax = max_t(s32, temp, 0);\n\ttiming->hs_prepare = linear_inter(tmax, tmin, pcnt1, 0, false);\n\n\ttemp = 145 * coeff + 10 * ui - ((timing->hs_prepare << 3) + val) * ui;\n\ttmin = S_DIV_ROUND_UP(temp - 11 * ui, ui_x8) - 3;\n\ttmax = 255;\n\ttiming->hs_zero = linear_inter(tmax, tmin, pcnt4, 0, false);\n\n\ttmin = DIV_ROUND_UP(60 * coeff + 4 * ui + 3 * ui, ui_x8);\n\ttemp = 105 * coeff + 12 * ui - 20 * coeff;\n\ttmax = (temp + 3 * ui) / ui_x8;\n\ttiming->hs_trail = linear_inter(tmax, tmin, pcnt3, 0, false);\n\n\ttemp = 50 * coeff + ((hb_en << 2) - 8) * ui;\n\ttiming->hs_rqst = S_DIV_ROUND_UP(temp, ui_x8);\n\n\ttmin = DIV_ROUND_UP(100 * coeff, ui_x8) - 1;\n\ttmax = 255;\n\ttiming->hs_exit = linear_inter(tmax, tmin, pcnt2, 0, false);\n\n\ttemp = 50 * coeff + ((hb_en_ckln << 2) - 8) * ui;\n\ttiming->hs_rqst_ckln = S_DIV_ROUND_UP(temp, ui_x8);\n\n\ttemp = 60 * coeff + 52 * ui - 43 * ui;\n\ttmin = DIV_ROUND_UP(temp, ui_x8) - 1;\n\ttmax = 63;\n\ttiming->shared_timings.clk_post =\n\t\t\t\tlinear_inter(tmax, tmin, pcnt2, 0, false);\n\n\ttemp = 8 * ui + ((timing->clk_prepare << 3) + val_ckln) * ui;\n\ttemp += (((timing->clk_zero + 3) << 3) + 11 - (pd_ckln << 1)) * ui;\n\ttemp += hb_en_ckln ? (((timing->hs_rqst_ckln << 3) + 4) * ui) :\n\t\t\t\t(((timing->hs_rqst_ckln << 3) + 8) * ui);\n\ttmin = S_DIV_ROUND_UP(temp, ui_x8) - 1;\n\ttmax = 63;\n\tif (tmin > tmax) {\n\t\ttemp = linear_inter(tmax << 1, tmin, pcnt2, 0, false);\n\t\ttiming->shared_timings.clk_pre = temp >> 1;\n\t\ttiming->shared_timings.clk_pre_inc_by_2 = 1;\n\t} else {\n\t\ttiming->shared_timings.clk_pre =\n\t\t\t\tlinear_inter(tmax, tmin, pcnt2, 0, false);\n\t\ttiming->shared_timings.clk_pre_inc_by_2 = 0;\n\t}\n\n\ttiming->ta_go = 3;\n\ttiming->ta_sure = 0;\n\ttiming->ta_get = 4;\n\n\tDBG(\"%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\",\n\t    timing->shared_timings.clk_pre, timing->shared_timings.clk_post,\n\t    timing->shared_timings.clk_pre_inc_by_2, timing->clk_zero,\n\t    timing->clk_trail, timing->clk_prepare, timing->hs_exit,\n\t    timing->hs_zero, timing->hs_prepare, timing->hs_trail,\n\t    timing->hs_rqst, timing->hs_rqst_ckln, timing->hs_halfbyte_en,\n\t    timing->hs_halfbyte_en_ckln, timing->hs_prep_dly,\n\t    timing->hs_prep_dly_ckln);\n\n\treturn 0;\n}\n\nint msm_dsi_dphy_timing_calc_v3(struct msm_dsi_dphy_timing *timing,\n\tstruct msm_dsi_phy_clk_request *clk_req)\n{\n\tconst unsigned long bit_rate = clk_req->bitclk_rate;\n\tconst unsigned long esc_rate = clk_req->escclk_rate;\n\ts32 ui, ui_x8;\n\ts32 tmax, tmin;\n\ts32 pcnt0 = 50;\n\ts32 pcnt1 = 50;\n\ts32 pcnt2 = 10;\n\ts32 pcnt3 = 30;\n\ts32 pcnt4 = 10;\n\ts32 pcnt5 = 2;\n\ts32 coeff = 1000;  \n\ts32 hb_en, hb_en_ckln;\n\ts32 temp;\n\n\tif (!bit_rate || !esc_rate)\n\t\treturn -EINVAL;\n\n\ttiming->hs_halfbyte_en = 0;\n\thb_en = 0;\n\ttiming->hs_halfbyte_en_ckln = 0;\n\thb_en_ckln = 0;\n\n\tui = mult_frac(NSEC_PER_MSEC, coeff, bit_rate / 1000);\n\tui_x8 = ui << 3;\n\n\ttemp = S_DIV_ROUND_UP(38 * coeff, ui_x8);\n\ttmin = max_t(s32, temp, 0);\n\ttemp = (95 * coeff) / ui_x8;\n\ttmax = max_t(s32, temp, 0);\n\ttiming->clk_prepare = linear_inter(tmax, tmin, pcnt0, 0, false);\n\n\ttemp = 300 * coeff - (timing->clk_prepare << 3) * ui;\n\ttmin = S_DIV_ROUND_UP(temp, ui_x8) - 1;\n\ttmax = (tmin > 255) ? 511 : 255;\n\ttiming->clk_zero = linear_inter(tmax, tmin, pcnt5, 0, false);\n\n\ttmin = DIV_ROUND_UP(60 * coeff + 3 * ui, ui_x8);\n\ttemp = 105 * coeff + 12 * ui - 20 * coeff;\n\ttmax = (temp + 3 * ui) / ui_x8;\n\ttiming->clk_trail = linear_inter(tmax, tmin, pcnt3, 0, false);\n\n\ttemp = S_DIV_ROUND_UP(40 * coeff + 4 * ui, ui_x8);\n\ttmin = max_t(s32, temp, 0);\n\ttemp = (85 * coeff + 6 * ui) / ui_x8;\n\ttmax = max_t(s32, temp, 0);\n\ttiming->hs_prepare = linear_inter(tmax, tmin, pcnt1, 0, false);\n\n\ttemp = 145 * coeff + 10 * ui - (timing->hs_prepare << 3) * ui;\n\ttmin = S_DIV_ROUND_UP(temp, ui_x8) - 1;\n\ttmax = 255;\n\ttiming->hs_zero = linear_inter(tmax, tmin, pcnt4, 0, false);\n\n\ttmin = DIV_ROUND_UP(60 * coeff + 4 * ui, ui_x8) - 1;\n\ttemp = 105 * coeff + 12 * ui - 20 * coeff;\n\ttmax = (temp / ui_x8) - 1;\n\ttiming->hs_trail = linear_inter(tmax, tmin, pcnt3, 0, false);\n\n\ttemp = 50 * coeff + ((hb_en << 2) - 8) * ui;\n\ttiming->hs_rqst = S_DIV_ROUND_UP(temp, ui_x8);\n\n\ttmin = DIV_ROUND_UP(100 * coeff, ui_x8) - 1;\n\ttmax = 255;\n\ttiming->hs_exit = linear_inter(tmax, tmin, pcnt2, 0, false);\n\n\ttemp = 50 * coeff + ((hb_en_ckln << 2) - 8) * ui;\n\ttiming->hs_rqst_ckln = S_DIV_ROUND_UP(temp, ui_x8);\n\n\ttemp = 60 * coeff + 52 * ui - 43 * ui;\n\ttmin = DIV_ROUND_UP(temp, ui_x8) - 1;\n\ttmax = 63;\n\ttiming->shared_timings.clk_post =\n\t\tlinear_inter(tmax, tmin, pcnt2, 0, false);\n\n\ttemp = 8 * ui + (timing->clk_prepare << 3) * ui;\n\ttemp += (((timing->clk_zero + 3) << 3) + 11) * ui;\n\ttemp += hb_en_ckln ? (((timing->hs_rqst_ckln << 3) + 4) * ui) :\n\t\t(((timing->hs_rqst_ckln << 3) + 8) * ui);\n\ttmin = S_DIV_ROUND_UP(temp, ui_x8) - 1;\n\ttmax = 63;\n\tif (tmin > tmax) {\n\t\ttemp = linear_inter(tmax << 1, tmin, pcnt2, 0, false);\n\t\ttiming->shared_timings.clk_pre = temp >> 1;\n\t\ttiming->shared_timings.clk_pre_inc_by_2 = 1;\n\t} else {\n\t\ttiming->shared_timings.clk_pre =\n\t\t\tlinear_inter(tmax, tmin, pcnt2, 0, false);\n\t\ttiming->shared_timings.clk_pre_inc_by_2 = 0;\n\t}\n\n\ttiming->shared_timings.byte_intf_clk_div_2 = true;\n\n\ttiming->ta_go = 3;\n\ttiming->ta_sure = 0;\n\ttiming->ta_get = 4;\n\n\tDBG(\"%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\",\n\t\ttiming->shared_timings.clk_pre, timing->shared_timings.clk_post,\n\t\ttiming->shared_timings.clk_pre_inc_by_2, timing->clk_zero,\n\t\ttiming->clk_trail, timing->clk_prepare, timing->hs_exit,\n\t\ttiming->hs_zero, timing->hs_prepare, timing->hs_trail,\n\t\ttiming->hs_rqst, timing->hs_rqst_ckln, timing->hs_halfbyte_en,\n\t\ttiming->hs_halfbyte_en_ckln, timing->hs_prep_dly,\n\t\ttiming->hs_prep_dly_ckln);\n\n\treturn 0;\n}\n\nint msm_dsi_dphy_timing_calc_v4(struct msm_dsi_dphy_timing *timing,\n\tstruct msm_dsi_phy_clk_request *clk_req)\n{\n\tconst unsigned long bit_rate = clk_req->bitclk_rate;\n\tconst unsigned long esc_rate = clk_req->escclk_rate;\n\ts32 ui, ui_x8;\n\ts32 tmax, tmin;\n\ts32 pcnt_clk_prep = 50;\n\ts32 pcnt_clk_zero = 2;\n\ts32 pcnt_clk_trail = 30;\n\ts32 pcnt_hs_prep = 50;\n\ts32 pcnt_hs_zero = 10;\n\ts32 pcnt_hs_trail = 30;\n\ts32 pcnt_hs_exit = 10;\n\ts32 coeff = 1000;  \n\ts32 hb_en;\n\ts32 temp;\n\n\tif (!bit_rate || !esc_rate)\n\t\treturn -EINVAL;\n\n\thb_en = 0;\n\n\tui = mult_frac(NSEC_PER_MSEC, coeff, bit_rate / 1000);\n\tui_x8 = ui << 3;\n\n\t \n\n\ttemp = S_DIV_ROUND_UP(38 * coeff, ui_x8);\n\ttmin = max_t(s32, temp, 0);\n\ttemp = (95 * coeff) / ui_x8;\n\ttmax = max_t(s32, temp, 0);\n\ttiming->clk_prepare = linear_inter(tmax, tmin, pcnt_clk_prep, 0, false);\n\n\ttemp = 300 * coeff - (timing->clk_prepare << 3) * ui;\n\ttmin = S_DIV_ROUND_UP(temp, ui_x8) - 1;\n\ttmax = (tmin > 255) ? 511 : 255;\n\ttiming->clk_zero = linear_inter(tmax, tmin, pcnt_clk_zero, 0, false);\n\n\ttmin = DIV_ROUND_UP(60 * coeff + 3 * ui, ui_x8);\n\ttemp = 105 * coeff + 12 * ui - 20 * coeff;\n\ttmax = (temp + 3 * ui) / ui_x8;\n\ttiming->clk_trail = linear_inter(tmax, tmin, pcnt_clk_trail, 0, false);\n\n\ttemp = S_DIV_ROUND_UP(40 * coeff + 4 * ui, ui_x8);\n\ttmin = max_t(s32, temp, 0);\n\ttemp = (85 * coeff + 6 * ui) / ui_x8;\n\ttmax = max_t(s32, temp, 0);\n\ttiming->hs_prepare = linear_inter(tmax, tmin, pcnt_hs_prep, 0, false);\n\n\ttemp = 145 * coeff + 10 * ui - (timing->hs_prepare << 3) * ui;\n\ttmin = S_DIV_ROUND_UP(temp, ui_x8) - 1;\n\ttmax = 255;\n\ttiming->hs_zero = linear_inter(tmax, tmin, pcnt_hs_zero, 0, false);\n\n\ttmin = DIV_ROUND_UP(60 * coeff + 4 * ui, ui_x8) - 1;\n\ttemp = 105 * coeff + 12 * ui - 20 * coeff;\n\ttmax = (temp / ui_x8) - 1;\n\ttiming->hs_trail = linear_inter(tmax, tmin, pcnt_hs_trail, 0, false);\n\n\ttemp = 50 * coeff + ((hb_en << 2) - 8) * ui;\n\ttiming->hs_rqst = S_DIV_ROUND_UP(temp, ui_x8);\n\n\ttmin = DIV_ROUND_UP(100 * coeff, ui_x8) - 1;\n\ttmax = 255;\n\ttiming->hs_exit = linear_inter(tmax, tmin, pcnt_hs_exit, 0, false);\n\n\t \n\ttemp = 60 * coeff + 52 * ui + + (timing->hs_trail + 1) * ui_x8;\n\ttmin = DIV_ROUND_UP(temp, 16 * ui) - 1;\n\ttmax = 255;\n\ttiming->shared_timings.clk_post = linear_inter(tmax, tmin, 5, 0, false);\n\n\t \n\ttemp = 52 * coeff + (timing->clk_prepare + timing->clk_zero + 1) * ui_x8 + 54 * coeff;\n\ttmin = DIV_ROUND_UP(temp, 16 * ui) - 1;\n\ttmax = 255;\n\ttiming->shared_timings.clk_pre = DIV_ROUND_UP((tmax - tmin) * 125, 10000) + tmin;\n\n\ttiming->shared_timings.byte_intf_clk_div_2 = true;\n\n\tDBG(\"%d, %d, %d, %d, %d, %d, %d, %d, %d, %d\",\n\t\ttiming->shared_timings.clk_pre, timing->shared_timings.clk_post,\n\t\ttiming->clk_zero, timing->clk_trail, timing->clk_prepare, timing->hs_exit,\n\t\ttiming->hs_zero, timing->hs_prepare, timing->hs_trail, timing->hs_rqst);\n\n\treturn 0;\n}\n\nint msm_dsi_cphy_timing_calc_v4(struct msm_dsi_dphy_timing *timing,\n\tstruct msm_dsi_phy_clk_request *clk_req)\n{\n\tconst unsigned long bit_rate = clk_req->bitclk_rate;\n\tconst unsigned long esc_rate = clk_req->escclk_rate;\n\ts32 ui, ui_x7;\n\ts32 tmax, tmin;\n\ts32 coeff = 1000;  \n\ts32 temp;\n\n\tif (!bit_rate || !esc_rate)\n\t\treturn -EINVAL;\n\n\tui = mult_frac(NSEC_PER_MSEC, coeff, bit_rate / 1000);\n\tui_x7 = ui * 7;\n\n\ttemp = S_DIV_ROUND_UP(38 * coeff, ui_x7);\n\ttmin = max_t(s32, temp, 0);\n\ttemp = (95 * coeff) / ui_x7;\n\ttmax = max_t(s32, temp, 0);\n\ttiming->clk_prepare = linear_inter(tmax, tmin, 50, 0, false);\n\n\ttmin = DIV_ROUND_UP(50 * coeff, ui_x7);\n\ttmax = 255;\n\ttiming->hs_rqst = linear_inter(tmax, tmin, 1, 0, false);\n\n\ttmin = DIV_ROUND_UP(100 * coeff, ui_x7) - 1;\n\ttmax = 255;\n\ttiming->hs_exit = linear_inter(tmax, tmin, 10, 0, false);\n\n\ttmin = 1;\n\ttmax = 32;\n\ttiming->shared_timings.clk_post = linear_inter(tmax, tmin, 80, 0, false);\n\n\ttmin = min_t(s32, 64, S_DIV_ROUND_UP(262 * coeff, ui_x7) - 1);\n\ttmax = 64;\n\ttiming->shared_timings.clk_pre = linear_inter(tmax, tmin, 20, 0, false);\n\n\tDBG(\"%d, %d, %d, %d, %d\",\n\t\ttiming->shared_timings.clk_pre, timing->shared_timings.clk_post,\n\t\ttiming->clk_prepare, timing->hs_exit, timing->hs_rqst);\n\n\treturn 0;\n}\n\nstatic int dsi_phy_enable_resource(struct msm_dsi_phy *phy)\n{\n\tstruct device *dev = &phy->pdev->dev;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(phy->ahb_clk);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"%s: can't enable ahb clk, %d\\n\", __func__, ret);\n\t\tpm_runtime_put_sync(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void dsi_phy_disable_resource(struct msm_dsi_phy *phy)\n{\n\tclk_disable_unprepare(phy->ahb_clk);\n\tpm_runtime_put(&phy->pdev->dev);\n}\n\nstatic const struct of_device_id dsi_phy_dt_match[] = {\n#ifdef CONFIG_DRM_MSM_DSI_28NM_PHY\n\t{ .compatible = \"qcom,dsi-phy-28nm-hpm\",\n\t  .data = &dsi_phy_28nm_hpm_cfgs },\n\t{ .compatible = \"qcom,dsi-phy-28nm-hpm-fam-b\",\n\t  .data = &dsi_phy_28nm_hpm_famb_cfgs },\n\t{ .compatible = \"qcom,dsi-phy-28nm-lp\",\n\t  .data = &dsi_phy_28nm_lp_cfgs },\n\t{ .compatible = \"qcom,dsi-phy-28nm-8226\",\n\t  .data = &dsi_phy_28nm_8226_cfgs },\n#endif\n#ifdef CONFIG_DRM_MSM_DSI_20NM_PHY\n\t{ .compatible = \"qcom,dsi-phy-20nm\",\n\t  .data = &dsi_phy_20nm_cfgs },\n#endif\n#ifdef CONFIG_DRM_MSM_DSI_28NM_8960_PHY\n\t{ .compatible = \"qcom,dsi-phy-28nm-8960\",\n\t  .data = &dsi_phy_28nm_8960_cfgs },\n#endif\n#ifdef CONFIG_DRM_MSM_DSI_14NM_PHY\n\t{ .compatible = \"qcom,dsi-phy-14nm\",\n\t  .data = &dsi_phy_14nm_cfgs },\n\t{ .compatible = \"qcom,dsi-phy-14nm-2290\",\n\t  .data = &dsi_phy_14nm_2290_cfgs },\n\t{ .compatible = \"qcom,dsi-phy-14nm-660\",\n\t  .data = &dsi_phy_14nm_660_cfgs },\n\t{ .compatible = \"qcom,dsi-phy-14nm-8953\",\n\t  .data = &dsi_phy_14nm_8953_cfgs },\n\t{ .compatible = \"qcom,sm6125-dsi-phy-14nm\",\n\t  .data = &dsi_phy_14nm_2290_cfgs },\n#endif\n#ifdef CONFIG_DRM_MSM_DSI_10NM_PHY\n\t{ .compatible = \"qcom,dsi-phy-10nm\",\n\t  .data = &dsi_phy_10nm_cfgs },\n\t{ .compatible = \"qcom,dsi-phy-10nm-8998\",\n\t  .data = &dsi_phy_10nm_8998_cfgs },\n#endif\n#ifdef CONFIG_DRM_MSM_DSI_7NM_PHY\n\t{ .compatible = \"qcom,dsi-phy-7nm\",\n\t  .data = &dsi_phy_7nm_cfgs },\n\t{ .compatible = \"qcom,dsi-phy-7nm-8150\",\n\t  .data = &dsi_phy_7nm_8150_cfgs },\n\t{ .compatible = \"qcom,sc7280-dsi-phy-7nm\",\n\t  .data = &dsi_phy_7nm_7280_cfgs },\n\t{ .compatible = \"qcom,sm6375-dsi-phy-7nm\",\n\t  .data = &dsi_phy_7nm_6375_cfgs },\n\t{ .compatible = \"qcom,sm8350-dsi-phy-5nm\",\n\t  .data = &dsi_phy_5nm_8350_cfgs },\n\t{ .compatible = \"qcom,sm8450-dsi-phy-5nm\",\n\t  .data = &dsi_phy_5nm_8450_cfgs },\n\t{ .compatible = \"qcom,sm8550-dsi-phy-4nm\",\n\t  .data = &dsi_phy_4nm_8550_cfgs },\n#endif\n\t{}\n};\n\n \nstatic int dsi_phy_get_id(struct msm_dsi_phy *phy)\n{\n\tstruct platform_device *pdev = phy->pdev;\n\tconst struct msm_dsi_phy_cfg *cfg = phy->cfg;\n\tstruct resource *res;\n\tint i;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dsi_phy\");\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < cfg->num_dsi_phy; i++) {\n\t\tif (cfg->io_start[i] == res->start)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int dsi_phy_driver_probe(struct platform_device *pdev)\n{\n\tstruct msm_dsi_phy *phy;\n\tstruct device *dev = &pdev->dev;\n\tu32 phy_type;\n\tint ret;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->provided_clocks = devm_kzalloc(dev,\n\t\t\tstruct_size(phy->provided_clocks, hws, NUM_PROVIDED_CLKS),\n\t\t\tGFP_KERNEL);\n\tif (!phy->provided_clocks)\n\t\treturn -ENOMEM;\n\n\tphy->provided_clocks->num = NUM_PROVIDED_CLKS;\n\n\tphy->cfg = of_device_get_match_data(&pdev->dev);\n\tif (!phy->cfg)\n\t\treturn -ENODEV;\n\n\tphy->pdev = pdev;\n\n\tphy->id = dsi_phy_get_id(phy);\n\tif (phy->id < 0)\n\t\treturn dev_err_probe(dev, phy->id,\n\t\t\t\t     \"Couldn't identify PHY index\\n\");\n\n\tphy->regulator_ldo_mode = of_property_read_bool(dev->of_node,\n\t\t\t\t\"qcom,dsi-phy-regulator-ldo-mode\");\n\tif (!of_property_read_u32(dev->of_node, \"phy-type\", &phy_type))\n\t\tphy->cphy_mode = (phy_type == PHY_TYPE_CPHY);\n\n\tphy->base = msm_ioremap_size(pdev, \"dsi_phy\", &phy->base_size);\n\tif (IS_ERR(phy->base))\n\t\treturn dev_err_probe(dev, PTR_ERR(phy->base),\n\t\t\t\t     \"Failed to map phy base\\n\");\n\n\tphy->pll_base = msm_ioremap_size(pdev, \"dsi_pll\", &phy->pll_size);\n\tif (IS_ERR(phy->pll_base))\n\t\treturn dev_err_probe(dev, PTR_ERR(phy->pll_base),\n\t\t\t\t     \"Failed to map pll base\\n\");\n\n\tif (phy->cfg->has_phy_lane) {\n\t\tphy->lane_base = msm_ioremap_size(pdev, \"dsi_phy_lane\", &phy->lane_size);\n\t\tif (IS_ERR(phy->lane_base))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(phy->lane_base),\n\t\t\t\t\t     \"Failed to map phy lane base\\n\");\n\t}\n\n\tif (phy->cfg->has_phy_regulator) {\n\t\tphy->reg_base = msm_ioremap_size(pdev, \"dsi_phy_regulator\", &phy->reg_size);\n\t\tif (IS_ERR(phy->reg_base))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(phy->reg_base),\n\t\t\t\t\t     \"Failed to map phy regulator base\\n\");\n\t}\n\n\tif (phy->cfg->ops.parse_dt_properties) {\n\t\tret = phy->cfg->ops.parse_dt_properties(phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_regulator_bulk_get_const(dev, phy->cfg->num_regulators,\n\t\t\t\t\t    phy->cfg->regulator_data,\n\t\t\t\t\t    &phy->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tphy->ahb_clk = msm_clk_get(pdev, \"iface\");\n\tif (IS_ERR(phy->ahb_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(phy->ahb_clk),\n\t\t\t\t     \"Unable to get ahb clk\\n\");\n\n\t \n\tret = dsi_phy_enable_resource(phy);\n\tif (ret)\n\t\treturn ret;\n\n\tif (phy->cfg->ops.pll_init) {\n\t\tret = phy->cfg->ops.pll_init(phy);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"PLL init failed; need separate clk driver\\n\");\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get,\n\t\t\t\t     phy->provided_clocks);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to register clk provider\\n\");\n\n\tdsi_phy_disable_resource(phy);\n\n\tplatform_set_drvdata(pdev, phy);\n\n\treturn 0;\n}\n\nstatic struct platform_driver dsi_phy_platform_driver = {\n\t.probe      = dsi_phy_driver_probe,\n\t.driver     = {\n\t\t.name   = \"msm_dsi_phy\",\n\t\t.of_match_table = dsi_phy_dt_match,\n\t},\n};\n\nvoid __init msm_dsi_phy_driver_register(void)\n{\n\tplatform_driver_register(&dsi_phy_platform_driver);\n}\n\nvoid __exit msm_dsi_phy_driver_unregister(void)\n{\n\tplatform_driver_unregister(&dsi_phy_platform_driver);\n}\n\nint msm_dsi_phy_enable(struct msm_dsi_phy *phy,\n\t\t\tstruct msm_dsi_phy_clk_request *clk_req,\n\t\t\tstruct msm_dsi_phy_shared_timings *shared_timings)\n{\n\tstruct device *dev;\n\tint ret;\n\n\tif (!phy || !phy->cfg->ops.enable)\n\t\treturn -EINVAL;\n\n\tdev = &phy->pdev->dev;\n\n\tret = dsi_phy_enable_resource(phy);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"%s: resource enable failed, %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto res_en_fail;\n\t}\n\n\tret = regulator_bulk_enable(phy->cfg->num_regulators, phy->supplies);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"%s: regulator enable failed, %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto reg_en_fail;\n\t}\n\n\tret = phy->cfg->ops.enable(phy, clk_req);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"%s: phy enable failed, %d\\n\", __func__, ret);\n\t\tgoto phy_en_fail;\n\t}\n\n\tmemcpy(shared_timings, &phy->timing.shared_timings,\n\t       sizeof(*shared_timings));\n\n\t \n\tif (phy->usecase != MSM_DSI_PHY_SLAVE) {\n\t\tret = msm_dsi_phy_pll_restore_state(phy);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev, \"%s: failed to restore phy state, %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto pll_restor_fail;\n\t\t}\n\t}\n\n\treturn 0;\n\npll_restor_fail:\n\tif (phy->cfg->ops.disable)\n\t\tphy->cfg->ops.disable(phy);\nphy_en_fail:\n\tregulator_bulk_disable(phy->cfg->num_regulators, phy->supplies);\nreg_en_fail:\n\tdsi_phy_disable_resource(phy);\nres_en_fail:\n\treturn ret;\n}\n\nvoid msm_dsi_phy_disable(struct msm_dsi_phy *phy)\n{\n\tif (!phy || !phy->cfg->ops.disable)\n\t\treturn;\n\n\tphy->cfg->ops.disable(phy);\n\n\tregulator_bulk_disable(phy->cfg->num_regulators, phy->supplies);\n\tdsi_phy_disable_resource(phy);\n}\n\nvoid msm_dsi_phy_set_usecase(struct msm_dsi_phy *phy,\n\t\t\t     enum msm_dsi_phy_usecase uc)\n{\n\tif (phy)\n\t\tphy->usecase = uc;\n}\n\n \nbool msm_dsi_phy_set_continuous_clock(struct msm_dsi_phy *phy, bool enable)\n{\n\tif (!phy || !phy->cfg->ops.set_continuous_clock)\n\t\treturn false;\n\n\treturn phy->cfg->ops.set_continuous_clock(phy, enable);\n}\n\nvoid msm_dsi_phy_pll_save_state(struct msm_dsi_phy *phy)\n{\n\tif (phy->cfg->ops.save_pll_state) {\n\t\tphy->cfg->ops.save_pll_state(phy);\n\t\tphy->state_saved = true;\n\t}\n}\n\nint msm_dsi_phy_pll_restore_state(struct msm_dsi_phy *phy)\n{\n\tint ret;\n\n\tif (phy->cfg->ops.restore_pll_state && phy->state_saved) {\n\t\tret = phy->cfg->ops.restore_pll_state(phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tphy->state_saved = false;\n\t}\n\n\treturn 0;\n}\n\nvoid msm_dsi_phy_snapshot(struct msm_disp_state *disp_state, struct msm_dsi_phy *phy)\n{\n\tmsm_disp_snapshot_add_block(disp_state,\n\t\t\tphy->base_size, phy->base,\n\t\t\t\"dsi%d_phy\", phy->id);\n\n\t \n\tif (phy->pll_on)\n\t\tmsm_disp_snapshot_add_block(disp_state,\n\t\t\tphy->pll_size, phy->pll_base,\n\t\t\t\"dsi%d_pll\", phy->id);\n\n\tif (phy->lane_base)\n\t\tmsm_disp_snapshot_add_block(disp_state,\n\t\t\tphy->lane_size, phy->lane_base,\n\t\t\t\"dsi%d_lane\", phy->id);\n\n\tif (phy->reg_base)\n\t\tmsm_disp_snapshot_add_block(disp_state,\n\t\t\tphy->reg_size, phy->reg_base,\n\t\t\t\"dsi%d_reg\", phy->id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}