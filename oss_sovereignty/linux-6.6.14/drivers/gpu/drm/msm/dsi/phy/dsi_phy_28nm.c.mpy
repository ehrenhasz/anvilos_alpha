{
  "module_name": "dsi_phy_28nm.c",
  "hash_id": "6bda6a1f2efe47d9af4f7d4f1eee9ad168ec631f6cdf5ecbe82deea74704f32c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dsi/phy/dsi_phy_28nm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n\n#include \"dsi_phy.h\"\n#include \"dsi.xml.h\"\n#include \"dsi_phy_28nm.xml.h\"\n\n \n\n#define POLL_MAX_READS\t\t\t10\n#define POLL_TIMEOUT_US\t\t50\n\n#define VCO_REF_CLK_RATE\t\t19200000\n#define VCO_MIN_RATE\t\t\t350000000\n#define VCO_MAX_RATE\t\t\t750000000\n\n \n#define DSI_PHY_28NM_QUIRK_PHY_LP\tBIT(0)\n#define DSI_PHY_28NM_QUIRK_PHY_8226\tBIT(1)\n\n#define LPFR_LUT_SIZE\t\t\t10\nstruct lpfr_cfg {\n\tunsigned long vco_rate;\n\tu32 resistance;\n};\n\n \nstatic const struct lpfr_cfg lpfr_lut[LPFR_LUT_SIZE] = {\n\t{ 479500000,  8 },\n\t{ 480000000, 11 },\n\t{ 575500000,  8 },\n\t{ 576000000, 12 },\n\t{ 610500000,  8 },\n\t{ 659500000,  9 },\n\t{ 671500000, 10 },\n\t{ 672000000, 14 },\n\t{ 708500000, 10 },\n\t{ 750000000, 11 },\n};\n\nstruct pll_28nm_cached_state {\n\tunsigned long vco_rate;\n\tu8 postdiv3;\n\tu8 postdiv1;\n\tu8 byte_mux;\n};\n\nstruct dsi_pll_28nm {\n\tstruct clk_hw clk_hw;\n\n\tstruct msm_dsi_phy *phy;\n\n\tstruct pll_28nm_cached_state cached_state;\n};\n\n#define to_pll_28nm(x)\tcontainer_of(x, struct dsi_pll_28nm, clk_hw)\n\nstatic bool pll_28nm_poll_for_ready(struct dsi_pll_28nm *pll_28nm,\n\t\t\t\tu32 nb_tries, u32 timeout_us)\n{\n\tbool pll_locked = false;\n\tu32 val;\n\n\twhile (nb_tries--) {\n\t\tval = dsi_phy_read(pll_28nm->phy->pll_base + REG_DSI_28nm_PHY_PLL_STATUS);\n\t\tpll_locked = !!(val & DSI_28nm_PHY_PLL_STATUS_PLL_RDY);\n\n\t\tif (pll_locked)\n\t\t\tbreak;\n\n\t\tudelay(timeout_us);\n\t}\n\tDBG(\"DSI PLL is %slocked\", pll_locked ? \"\" : \"*not* \");\n\n\treturn pll_locked;\n}\n\nstatic void pll_28nm_software_reset(struct dsi_pll_28nm *pll_28nm)\n{\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\n\t \n\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_TEST_CFG,\n\t\t\t     DSI_28nm_PHY_PLL_TEST_CFG_PLL_SW_RESET, 1);\n\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_TEST_CFG, 0x00, 1);\n}\n\n \nstatic int dsi_pll_28nm_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\tstruct device *dev = &pll_28nm->phy->pdev->dev;\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\tunsigned long div_fbx1000, gen_vco_clk;\n\tu32 refclk_cfg, frac_n_mode, frac_n_value;\n\tu32 sdm_cfg0, sdm_cfg1, sdm_cfg2, sdm_cfg3;\n\tu32 cal_cfg10, cal_cfg11;\n\tu32 rem;\n\tint i;\n\n\tVERB(\"rate=%lu, parent's=%lu\", rate, parent_rate);\n\n\t \n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_POSTDIV2_CFG, 3);\n\n\t \n\tfor (i = 0; i < LPFR_LUT_SIZE; i++)\n\t\tif (rate <= lpfr_lut[i].vco_rate)\n\t\t\tbreak;\n\tif (i == LPFR_LUT_SIZE) {\n\t\tDRM_DEV_ERROR(dev, \"unable to get loop filter resistance. vco=%lu\\n\",\n\t\t\t\trate);\n\t\treturn -EINVAL;\n\t}\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_LPFR_CFG, lpfr_lut[i].resistance);\n\n\t \n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_LPFC1_CFG, 0x70);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_LPFC2_CFG, 0x15);\n\n\trem = rate % VCO_REF_CLK_RATE;\n\tif (rem) {\n\t\trefclk_cfg = DSI_28nm_PHY_PLL_REFCLK_CFG_DBLR;\n\t\tfrac_n_mode = 1;\n\t\tdiv_fbx1000 = rate / (VCO_REF_CLK_RATE / 500);\n\t\tgen_vco_clk = div_fbx1000 * (VCO_REF_CLK_RATE / 500);\n\t} else {\n\t\trefclk_cfg = 0x0;\n\t\tfrac_n_mode = 0;\n\t\tdiv_fbx1000 = rate / (VCO_REF_CLK_RATE / 1000);\n\t\tgen_vco_clk = div_fbx1000 * (VCO_REF_CLK_RATE / 1000);\n\t}\n\n\tDBG(\"refclk_cfg = %d\", refclk_cfg);\n\n\trem = div_fbx1000 % 1000;\n\tfrac_n_value = (rem << 16) / 1000;\n\n\tDBG(\"div_fb = %lu\", div_fbx1000);\n\tDBG(\"frac_n_value = %d\", frac_n_value);\n\n\tDBG(\"Generated VCO Clock: %lu\", gen_vco_clk);\n\trem = 0;\n\tsdm_cfg1 = dsi_phy_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG1);\n\tsdm_cfg1 &= ~DSI_28nm_PHY_PLL_SDM_CFG1_DC_OFFSET__MASK;\n\tif (frac_n_mode) {\n\t\tsdm_cfg0 = 0x0;\n\t\tsdm_cfg0 |= DSI_28nm_PHY_PLL_SDM_CFG0_BYP_DIV(0);\n\t\tsdm_cfg1 |= DSI_28nm_PHY_PLL_SDM_CFG1_DC_OFFSET(\n\t\t\t\t(u32)(((div_fbx1000 / 1000) & 0x3f) - 1));\n\t\tsdm_cfg3 = frac_n_value >> 8;\n\t\tsdm_cfg2 = frac_n_value & 0xff;\n\t} else {\n\t\tsdm_cfg0 = DSI_28nm_PHY_PLL_SDM_CFG0_BYP;\n\t\tsdm_cfg0 |= DSI_28nm_PHY_PLL_SDM_CFG0_BYP_DIV(\n\t\t\t\t(u32)(((div_fbx1000 / 1000) & 0x3f) - 1));\n\t\tsdm_cfg1 |= DSI_28nm_PHY_PLL_SDM_CFG1_DC_OFFSET(0);\n\t\tsdm_cfg2 = 0;\n\t\tsdm_cfg3 = 0;\n\t}\n\n\tDBG(\"sdm_cfg0=%d\", sdm_cfg0);\n\tDBG(\"sdm_cfg1=%d\", sdm_cfg1);\n\tDBG(\"sdm_cfg2=%d\", sdm_cfg2);\n\tDBG(\"sdm_cfg3=%d\", sdm_cfg3);\n\n\tcal_cfg11 = (u32)(gen_vco_clk / (256 * 1000000));\n\tcal_cfg10 = (u32)((gen_vco_clk % (256 * 1000000)) / 1000000);\n\tDBG(\"cal_cfg10=%d, cal_cfg11=%d\", cal_cfg10, cal_cfg11);\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_CHGPUMP_CFG, 0x02);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG3,    0x2b);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG4,    0x06);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2,  0x0d);\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_SDM_CFG1, sdm_cfg1);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_SDM_CFG2,\n\t\t      DSI_28nm_PHY_PLL_SDM_CFG2_FREQ_SEED_7_0(sdm_cfg2));\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_SDM_CFG3,\n\t\t      DSI_28nm_PHY_PLL_SDM_CFG3_FREQ_SEED_15_8(sdm_cfg3));\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_SDM_CFG4, 0x00);\n\n\t \n\tif (pll_28nm->phy->cfg->quirks & DSI_PHY_28NM_QUIRK_PHY_LP)\n\t\tudelay(1000);\n\telse\n\t\tudelay(1);\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_REFCLK_CFG, refclk_cfg);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_PWRGEN_CFG, 0x00);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_VCOLPF_CFG, 0x31);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_SDM_CFG0,   sdm_cfg0);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG0,   0x12);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG6,   0x30);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG7,   0x00);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG8,   0x60);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG9,   0x00);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG10,  cal_cfg10 & 0xff);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG11,  cal_cfg11 & 0xff);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_EFUSE_CFG,  0x20);\n\n\treturn 0;\n}\n\nstatic int dsi_pll_28nm_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\n\treturn pll_28nm_poll_for_ready(pll_28nm, POLL_MAX_READS,\n\t\t\t\t\tPOLL_TIMEOUT_US);\n}\n\nstatic unsigned long dsi_pll_28nm_clk_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\tu32 sdm0, doubler, sdm_byp_div;\n\tu32 sdm_dc_off, sdm_freq_seed, sdm2, sdm3;\n\tu32 ref_clk = VCO_REF_CLK_RATE;\n\tunsigned long vco_rate;\n\n\tVERB(\"parent_rate=%lu\", parent_rate);\n\n\t \n\tdoubler = dsi_phy_read(base + REG_DSI_28nm_PHY_PLL_REFCLK_CFG) &\n\t\t\tDSI_28nm_PHY_PLL_REFCLK_CFG_DBLR;\n\tref_clk += (doubler * VCO_REF_CLK_RATE);\n\n\t \n\tsdm0 = dsi_phy_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG0);\n\tif (sdm0 & DSI_28nm_PHY_PLL_SDM_CFG0_BYP) {\n\t\t \n\t\tsdm_byp_div = FIELD(\n\t\t\t\tdsi_phy_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG0),\n\t\t\t\tDSI_28nm_PHY_PLL_SDM_CFG0_BYP_DIV) + 1;\n\t\tvco_rate = ref_clk * sdm_byp_div;\n\t} else {\n\t\t \n\t\tsdm_dc_off = FIELD(\n\t\t\t\tdsi_phy_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG1),\n\t\t\t\tDSI_28nm_PHY_PLL_SDM_CFG1_DC_OFFSET);\n\t\tDBG(\"sdm_dc_off = %d\", sdm_dc_off);\n\t\tsdm2 = FIELD(dsi_phy_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG2),\n\t\t\t\tDSI_28nm_PHY_PLL_SDM_CFG2_FREQ_SEED_7_0);\n\t\tsdm3 = FIELD(dsi_phy_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG3),\n\t\t\t\tDSI_28nm_PHY_PLL_SDM_CFG3_FREQ_SEED_15_8);\n\t\tsdm_freq_seed = (sdm3 << 8) | sdm2;\n\t\tDBG(\"sdm_freq_seed = %d\", sdm_freq_seed);\n\n\t\tvco_rate = (ref_clk * (sdm_dc_off + 1)) +\n\t\t\tmult_frac(ref_clk, sdm_freq_seed, BIT(16));\n\t\tDBG(\"vco rate = %lu\", vco_rate);\n\t}\n\n\tDBG(\"returning vco rate = %lu\", vco_rate);\n\n\treturn vco_rate;\n}\n\nstatic int _dsi_pll_28nm_vco_prepare_hpm(struct dsi_pll_28nm *pll_28nm)\n{\n\tstruct device *dev = &pll_28nm->phy->pdev->dev;\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\tu32 max_reads = 5, timeout_us = 100;\n\tbool locked;\n\tu32 val;\n\tint i;\n\n\tDBG(\"id=%d\", pll_28nm->phy->id);\n\n\tpll_28nm_software_reset(pll_28nm);\n\n\t \n\tval = DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRDN_B;\n\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 1);\n\n\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRGEN_PWRDN_B;\n\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 200);\n\n\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B;\n\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 500);\n\n\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_ENABLE;\n\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 600);\n\n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2,\n\t\t\t\t     0x0c, 100);\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2, 0x0d);\n\n\t\t \n\t\tlocked = pll_28nm_poll_for_ready(pll_28nm, max_reads,\n\t\t\t\t\t\t timeout_us);\n\t\tif (locked)\n\t\t\tbreak;\n\n\t\tpll_28nm_software_reset(pll_28nm);\n\n\t\t \n\t\tval = DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRDN_B;\n\t\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 1);\n\n\t\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRGEN_PWRDN_B;\n\t\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 200);\n\n\t\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B;\n\t\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 250);\n\n\t\tval &= ~DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B;\n\t\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 200);\n\n\t\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B;\n\t\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 500);\n\n\t\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_ENABLE;\n\t\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 600);\n\t}\n\n\tif (unlikely(!locked))\n\t\tDRM_DEV_ERROR(dev, \"DSI PLL lock failed\\n\");\n\telse\n\t\tDBG(\"DSI PLL Lock success\");\n\n\treturn locked ? 0 : -EINVAL;\n}\n\nstatic int dsi_pll_28nm_vco_prepare_hpm(struct clk_hw *hw)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\tint i, ret;\n\n\tif (unlikely(pll_28nm->phy->pll_on))\n\t\treturn 0;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = _dsi_pll_28nm_vco_prepare_hpm(pll_28nm);\n\t\tif (!ret) {\n\t\t\tpll_28nm->phy->pll_on = true;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int dsi_pll_28nm_vco_prepare_8226(struct clk_hw *hw)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\tstruct device *dev = &pll_28nm->phy->pdev->dev;\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\tu32 max_reads = 5, timeout_us = 100;\n\tbool locked;\n\tu32 val;\n\tint i;\n\n\tDBG(\"id=%d\", pll_28nm->phy->id);\n\n\tpll_28nm_software_reset(pll_28nm);\n\n\t \n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG1, 0x34);\n\n\tval = DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRDN_B;\n\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 200);\n\n\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRGEN_PWRDN_B;\n\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 200);\n\n\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B;\n\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_ENABLE;\n\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 600);\n\n\tfor (i = 0; i < 7; i++) {\n\t\t \n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2, 0x0d);\n\t\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2,\n\t\t\t\t0x0c, 100);\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2, 0x0d);\n\n\t\t \n\t\tlocked = pll_28nm_poll_for_ready(pll_28nm,\n\t\t\t\t\t\tmax_reads, timeout_us);\n\t\tif (locked)\n\t\t\tbreak;\n\n\t\tpll_28nm_software_reset(pll_28nm);\n\n\t\t \n\t\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_PWRGEN_CFG, 0x00, 50);\n\n\t\tval = DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRDN_B;\n\t\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRGEN_PWRDN_B;\n\t\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 100);\n\n\t\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B;\n\t\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_ENABLE;\n\t\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 600);\n\t}\n\n\tif (unlikely(!locked))\n\t\tDRM_DEV_ERROR(dev, \"DSI PLL lock failed\\n\");\n\telse\n\t\tDBG(\"DSI PLL Lock success\");\n\n\treturn locked ? 0 : -EINVAL;\n}\n\nstatic int dsi_pll_28nm_vco_prepare_lp(struct clk_hw *hw)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\tstruct device *dev = &pll_28nm->phy->pdev->dev;\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\tbool locked;\n\tu32 max_reads = 10, timeout_us = 50;\n\tu32 val;\n\n\tDBG(\"id=%d\", pll_28nm->phy->id);\n\n\tif (unlikely(pll_28nm->phy->pll_on))\n\t\treturn 0;\n\n\tpll_28nm_software_reset(pll_28nm);\n\n\t \n\tdsi_phy_write_ndelay(base + REG_DSI_28nm_PHY_PLL_CAL_CFG1, 0x34, 500);\n\n\tval = DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRDN_B;\n\tdsi_phy_write_ndelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 500);\n\n\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRGEN_PWRDN_B;\n\tdsi_phy_write_ndelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 500);\n\n\tval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B |\n\t\tDSI_28nm_PHY_PLL_GLB_CFG_PLL_ENABLE;\n\tdsi_phy_write_ndelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 500);\n\n\t \n\tdsi_phy_write_ndelay(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2, 0x04, 500);\n\tdsi_phy_write_udelay(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2, 0x05, 512);\n\n\tlocked = pll_28nm_poll_for_ready(pll_28nm, max_reads, timeout_us);\n\n\tif (unlikely(!locked)) {\n\t\tDRM_DEV_ERROR(dev, \"DSI PLL lock failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDBG(\"DSI PLL lock success\");\n\tpll_28nm->phy->pll_on = true;\n\n\treturn 0;\n}\n\nstatic void dsi_pll_28nm_vco_unprepare(struct clk_hw *hw)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\n\tDBG(\"id=%d\", pll_28nm->phy->id);\n\n\tif (unlikely(!pll_28nm->phy->pll_on))\n\t\treturn;\n\n\tdsi_phy_write(pll_28nm->phy->pll_base + REG_DSI_28nm_PHY_PLL_GLB_CFG, 0x00);\n\n\tpll_28nm->phy->pll_on = false;\n}\n\nstatic long dsi_pll_28nm_clk_round_rate(struct clk_hw *hw,\n\t\tunsigned long rate, unsigned long *parent_rate)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(hw);\n\n\tif      (rate < pll_28nm->phy->cfg->min_pll_rate)\n\t\treturn  pll_28nm->phy->cfg->min_pll_rate;\n\telse if (rate > pll_28nm->phy->cfg->max_pll_rate)\n\t\treturn  pll_28nm->phy->cfg->max_pll_rate;\n\telse\n\t\treturn rate;\n}\n\nstatic const struct clk_ops clk_ops_dsi_pll_28nm_vco_hpm = {\n\t.round_rate = dsi_pll_28nm_clk_round_rate,\n\t.set_rate = dsi_pll_28nm_clk_set_rate,\n\t.recalc_rate = dsi_pll_28nm_clk_recalc_rate,\n\t.prepare = dsi_pll_28nm_vco_prepare_hpm,\n\t.unprepare = dsi_pll_28nm_vco_unprepare,\n\t.is_enabled = dsi_pll_28nm_clk_is_enabled,\n};\n\nstatic const struct clk_ops clk_ops_dsi_pll_28nm_vco_lp = {\n\t.round_rate = dsi_pll_28nm_clk_round_rate,\n\t.set_rate = dsi_pll_28nm_clk_set_rate,\n\t.recalc_rate = dsi_pll_28nm_clk_recalc_rate,\n\t.prepare = dsi_pll_28nm_vco_prepare_lp,\n\t.unprepare = dsi_pll_28nm_vco_unprepare,\n\t.is_enabled = dsi_pll_28nm_clk_is_enabled,\n};\n\nstatic const struct clk_ops clk_ops_dsi_pll_28nm_vco_8226 = {\n\t.round_rate = dsi_pll_28nm_clk_round_rate,\n\t.set_rate = dsi_pll_28nm_clk_set_rate,\n\t.recalc_rate = dsi_pll_28nm_clk_recalc_rate,\n\t.prepare = dsi_pll_28nm_vco_prepare_8226,\n\t.unprepare = dsi_pll_28nm_vco_unprepare,\n\t.is_enabled = dsi_pll_28nm_clk_is_enabled,\n};\n\n \n\nstatic void dsi_28nm_pll_save_state(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(phy->vco_hw);\n\tstruct pll_28nm_cached_state *cached_state = &pll_28nm->cached_state;\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\n\tcached_state->postdiv3 =\n\t\t\tdsi_phy_read(base + REG_DSI_28nm_PHY_PLL_POSTDIV3_CFG);\n\tcached_state->postdiv1 =\n\t\t\tdsi_phy_read(base + REG_DSI_28nm_PHY_PLL_POSTDIV1_CFG);\n\tcached_state->byte_mux = dsi_phy_read(base + REG_DSI_28nm_PHY_PLL_VREG_CFG);\n\tif (dsi_pll_28nm_clk_is_enabled(phy->vco_hw))\n\t\tcached_state->vco_rate = clk_hw_get_rate(phy->vco_hw);\n\telse\n\t\tcached_state->vco_rate = 0;\n}\n\nstatic int dsi_28nm_pll_restore_state(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(phy->vco_hw);\n\tstruct pll_28nm_cached_state *cached_state = &pll_28nm->cached_state;\n\tvoid __iomem *base = pll_28nm->phy->pll_base;\n\tint ret;\n\n\tret = dsi_pll_28nm_clk_set_rate(phy->vco_hw,\n\t\t\t\t\tcached_state->vco_rate, 0);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pll_28nm->phy->pdev->dev,\n\t\t\t\"restore vco rate failed. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_POSTDIV3_CFG,\n\t\t      cached_state->postdiv3);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_POSTDIV1_CFG,\n\t\t      cached_state->postdiv1);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_PLL_VREG_CFG,\n\t\t      cached_state->byte_mux);\n\n\treturn 0;\n}\n\nstatic int pll_28nm_register(struct dsi_pll_28nm *pll_28nm, struct clk_hw **provided_clocks)\n{\n\tchar clk_name[32];\n\tstruct clk_init_data vco_init = {\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"ref\", .name = \"xo\",\n\t\t},\n\t\t.num_parents = 1,\n\t\t.name = clk_name,\n\t\t.flags = CLK_IGNORE_UNUSED,\n\t};\n\tstruct device *dev = &pll_28nm->phy->pdev->dev;\n\tstruct clk_hw *hw, *analog_postdiv, *indirect_path_div2, *byte_mux;\n\tint ret;\n\n\tDBG(\"%d\", pll_28nm->phy->id);\n\n\tif (pll_28nm->phy->cfg->quirks & DSI_PHY_28NM_QUIRK_PHY_LP)\n\t\tvco_init.ops = &clk_ops_dsi_pll_28nm_vco_lp;\n\telse if (pll_28nm->phy->cfg->quirks & DSI_PHY_28NM_QUIRK_PHY_8226)\n\t\tvco_init.ops = &clk_ops_dsi_pll_28nm_vco_8226;\n\telse\n\t\tvco_init.ops = &clk_ops_dsi_pll_28nm_vco_hpm;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dvco_clk\", pll_28nm->phy->id);\n\tpll_28nm->clk_hw.init = &vco_init;\n\tret = devm_clk_hw_register(dev, &pll_28nm->clk_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%danalog_postdiv_clk\", pll_28nm->phy->id);\n\tanalog_postdiv = devm_clk_hw_register_divider_parent_hw(dev, clk_name,\n\t\t\t&pll_28nm->clk_hw, CLK_SET_RATE_PARENT,\n\t\t\tpll_28nm->phy->pll_base +\n\t\t\t\tREG_DSI_28nm_PHY_PLL_POSTDIV1_CFG,\n\t\t\t0, 4, 0, NULL);\n\tif (IS_ERR(analog_postdiv))\n\t\treturn PTR_ERR(analog_postdiv);\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dindirect_path_div2_clk\", pll_28nm->phy->id);\n\tindirect_path_div2 = devm_clk_hw_register_fixed_factor_parent_hw(dev,\n\t\t\tclk_name, analog_postdiv, CLK_SET_RATE_PARENT, 1, 2);\n\tif (IS_ERR(indirect_path_div2))\n\t\treturn PTR_ERR(indirect_path_div2);\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dpll\", pll_28nm->phy->id);\n\thw = devm_clk_hw_register_divider_parent_hw(dev, clk_name,\n\t\t\t&pll_28nm->clk_hw, 0, pll_28nm->phy->pll_base +\n\t\t\t\tREG_DSI_28nm_PHY_PLL_POSTDIV3_CFG,\n\t\t\t0, 8, 0, NULL);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\tprovided_clocks[DSI_PIXEL_PLL_CLK] = hw;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dbyte_mux\", pll_28nm->phy->id);\n\tbyte_mux = devm_clk_hw_register_mux_parent_hws(dev, clk_name,\n\t\t\t((const struct clk_hw *[]){\n\t\t\t\t&pll_28nm->clk_hw,\n\t\t\t\tindirect_path_div2,\n\t\t\t}), 2, CLK_SET_RATE_PARENT, pll_28nm->phy->pll_base +\n\t\t\t\tREG_DSI_28nm_PHY_PLL_VREG_CFG, 1, 1, 0, NULL);\n\tif (IS_ERR(byte_mux))\n\t\treturn PTR_ERR(byte_mux);\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dpllbyte\", pll_28nm->phy->id);\n\thw = devm_clk_hw_register_fixed_factor_parent_hw(dev, clk_name,\n\t\t\tbyte_mux, CLK_SET_RATE_PARENT, 1, 4);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\tprovided_clocks[DSI_BYTE_PLL_CLK] = hw;\n\n\treturn 0;\n}\n\nstatic int dsi_pll_28nm_init(struct msm_dsi_phy *phy)\n{\n\tstruct platform_device *pdev = phy->pdev;\n\tstruct dsi_pll_28nm *pll_28nm;\n\tint ret;\n\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tpll_28nm = devm_kzalloc(&pdev->dev, sizeof(*pll_28nm), GFP_KERNEL);\n\tif (!pll_28nm)\n\t\treturn -ENOMEM;\n\n\tpll_28nm->phy = phy;\n\n\tret = pll_28nm_register(pll_28nm, phy->provided_clocks->hws);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"failed to register PLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphy->vco_hw = &pll_28nm->clk_hw;\n\n\treturn 0;\n}\n\nstatic void dsi_28nm_dphy_set_timing(struct msm_dsi_phy *phy,\n\t\tstruct msm_dsi_dphy_timing *timing)\n{\n\tvoid __iomem *base = phy->base;\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_0,\n\t\t      DSI_28nm_PHY_TIMING_CTRL_0_CLK_ZERO(timing->clk_zero));\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_1,\n\t\t      DSI_28nm_PHY_TIMING_CTRL_1_CLK_TRAIL(timing->clk_trail));\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_2,\n\t\t      DSI_28nm_PHY_TIMING_CTRL_2_CLK_PREPARE(timing->clk_prepare));\n\tif (timing->clk_zero & BIT(8))\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_3,\n\t\t\t      DSI_28nm_PHY_TIMING_CTRL_3_CLK_ZERO_8);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_4,\n\t\t      DSI_28nm_PHY_TIMING_CTRL_4_HS_EXIT(timing->hs_exit));\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_5,\n\t\t      DSI_28nm_PHY_TIMING_CTRL_5_HS_ZERO(timing->hs_zero));\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_6,\n\t\t      DSI_28nm_PHY_TIMING_CTRL_6_HS_PREPARE(timing->hs_prepare));\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_7,\n\t\t      DSI_28nm_PHY_TIMING_CTRL_7_HS_TRAIL(timing->hs_trail));\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_8,\n\t\t      DSI_28nm_PHY_TIMING_CTRL_8_HS_RQST(timing->hs_rqst));\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_9,\n\t\t      DSI_28nm_PHY_TIMING_CTRL_9_TA_GO(timing->ta_go) |\n\t\t      DSI_28nm_PHY_TIMING_CTRL_9_TA_SURE(timing->ta_sure));\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_10,\n\t\t      DSI_28nm_PHY_TIMING_CTRL_10_TA_GET(timing->ta_get));\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_TIMING_CTRL_11,\n\t\t      DSI_28nm_PHY_TIMING_CTRL_11_TRIG3_CMD(0));\n}\n\nstatic void dsi_28nm_phy_regulator_enable_dcdc(struct msm_dsi_phy *phy)\n{\n\tvoid __iomem *base = phy->reg_base;\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_0, 0x0);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CAL_PWR_CFG, 1);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_5, 0);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_3, 0);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_2, 0x3);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_1, 0x9);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_0, 0x7);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_4, 0x20);\n\tdsi_phy_write(phy->base + REG_DSI_28nm_PHY_LDO_CNTRL, 0x00);\n}\n\nstatic void dsi_28nm_phy_regulator_enable_ldo(struct msm_dsi_phy *phy)\n{\n\tvoid __iomem *base = phy->reg_base;\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_0, 0x0);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CAL_PWR_CFG, 0);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_5, 0x7);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_3, 0);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_2, 0x1);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_1, 0x1);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_REGULATOR_CTRL_4, 0x20);\n\n\tif (phy->cfg->quirks & DSI_PHY_28NM_QUIRK_PHY_LP)\n\t\tdsi_phy_write(phy->base + REG_DSI_28nm_PHY_LDO_CNTRL, 0x05);\n\telse\n\t\tdsi_phy_write(phy->base + REG_DSI_28nm_PHY_LDO_CNTRL, 0x0d);\n}\n\nstatic void dsi_28nm_phy_regulator_ctrl(struct msm_dsi_phy *phy, bool enable)\n{\n\tif (!enable) {\n\t\tdsi_phy_write(phy->reg_base +\n\t\t\t      REG_DSI_28nm_PHY_REGULATOR_CAL_PWR_CFG, 0);\n\t\treturn;\n\t}\n\n\tif (phy->regulator_ldo_mode)\n\t\tdsi_28nm_phy_regulator_enable_ldo(phy);\n\telse\n\t\tdsi_28nm_phy_regulator_enable_dcdc(phy);\n}\n\nstatic int dsi_28nm_phy_enable(struct msm_dsi_phy *phy,\n\t\t\t\tstruct msm_dsi_phy_clk_request *clk_req)\n{\n\tstruct msm_dsi_dphy_timing *timing = &phy->timing;\n\tint i;\n\tvoid __iomem *base = phy->base;\n\tu32 val;\n\n\tDBG(\"\");\n\n\tif (msm_dsi_dphy_timing_calc(timing, clk_req)) {\n\t\tDRM_DEV_ERROR(&phy->pdev->dev,\n\t\t\t      \"%s: D-PHY timing calculation failed\\n\",\n\t\t\t      __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_STRENGTH_0, 0xff);\n\n\tdsi_28nm_phy_regulator_ctrl(phy, true);\n\n\tdsi_28nm_dphy_set_timing(phy, timing);\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_CTRL_1, 0x00);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_CTRL_0, 0x5f);\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_STRENGTH_1, 0x6);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_LN_CFG_0(i), 0);\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_LN_CFG_1(i), 0);\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_LN_CFG_2(i), 0);\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_LN_CFG_3(i), 0);\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_LN_CFG_4(i), 0);\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_LN_TEST_DATAPATH(i), 0);\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_LN_DEBUG_SEL(i), 0);\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_LN_TEST_STR_0(i), 0x1);\n\t\tdsi_phy_write(base + REG_DSI_28nm_PHY_LN_TEST_STR_1(i), 0x97);\n\t}\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_LNCK_CFG_4, 0);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_LNCK_CFG_1, 0xc0);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_LNCK_TEST_STR0, 0x1);\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_LNCK_TEST_STR1, 0xbb);\n\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_CTRL_0, 0x5f);\n\n\tval = dsi_phy_read(base + REG_DSI_28nm_PHY_GLBL_TEST_CTRL);\n\tif (phy->id == DSI_1 && phy->usecase == MSM_DSI_PHY_SLAVE)\n\t\tval &= ~DSI_28nm_PHY_GLBL_TEST_CTRL_BITCLK_HS_SEL;\n\telse\n\t\tval |= DSI_28nm_PHY_GLBL_TEST_CTRL_BITCLK_HS_SEL;\n\tdsi_phy_write(base + REG_DSI_28nm_PHY_GLBL_TEST_CTRL, val);\n\n\treturn 0;\n}\n\nstatic void dsi_28nm_phy_disable(struct msm_dsi_phy *phy)\n{\n\tdsi_phy_write(phy->base + REG_DSI_28nm_PHY_CTRL_0, 0);\n\tdsi_28nm_phy_regulator_ctrl(phy, false);\n\n\t \n\twmb();\n}\n\nstatic const struct regulator_bulk_data dsi_phy_28nm_regulators[] = {\n\t{ .supply = \"vddio\", .init_load_uA = 100000 },\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_28nm_hpm_cfgs = {\n\t.has_phy_regulator = true,\n\t.regulator_data = dsi_phy_28nm_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_28nm_regulators),\n\t.ops = {\n\t\t.enable = dsi_28nm_phy_enable,\n\t\t.disable = dsi_28nm_phy_disable,\n\t\t.pll_init = dsi_pll_28nm_init,\n\t\t.save_pll_state = dsi_28nm_pll_save_state,\n\t\t.restore_pll_state = dsi_28nm_pll_restore_state,\n\t},\n\t.min_pll_rate = VCO_MIN_RATE,\n\t.max_pll_rate = VCO_MAX_RATE,\n\t.io_start = { 0xfd922b00, 0xfd923100 },\n\t.num_dsi_phy = 2,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_28nm_hpm_famb_cfgs = {\n\t.has_phy_regulator = true,\n\t.regulator_data = dsi_phy_28nm_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_28nm_regulators),\n\t.ops = {\n\t\t.enable = dsi_28nm_phy_enable,\n\t\t.disable = dsi_28nm_phy_disable,\n\t\t.pll_init = dsi_pll_28nm_init,\n\t\t.save_pll_state = dsi_28nm_pll_save_state,\n\t\t.restore_pll_state = dsi_28nm_pll_restore_state,\n\t},\n\t.min_pll_rate = VCO_MIN_RATE,\n\t.max_pll_rate = VCO_MAX_RATE,\n\t.io_start = { 0x1a94400, 0x1a96400 },\n\t.num_dsi_phy = 2,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_28nm_lp_cfgs = {\n\t.has_phy_regulator = true,\n\t.regulator_data = dsi_phy_28nm_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_28nm_regulators),\n\t.ops = {\n\t\t.enable = dsi_28nm_phy_enable,\n\t\t.disable = dsi_28nm_phy_disable,\n\t\t.pll_init = dsi_pll_28nm_init,\n\t\t.save_pll_state = dsi_28nm_pll_save_state,\n\t\t.restore_pll_state = dsi_28nm_pll_restore_state,\n\t},\n\t.min_pll_rate = VCO_MIN_RATE,\n\t.max_pll_rate = VCO_MAX_RATE,\n\t.io_start = { 0x1a98500 },\n\t.num_dsi_phy = 1,\n\t.quirks = DSI_PHY_28NM_QUIRK_PHY_LP,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_28nm_8226_cfgs = {\n\t.has_phy_regulator = true,\n\t.regulator_data = dsi_phy_28nm_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_28nm_regulators),\n\t.ops = {\n\t\t.enable = dsi_28nm_phy_enable,\n\t\t.disable = dsi_28nm_phy_disable,\n\t\t.pll_init = dsi_pll_28nm_init,\n\t\t.save_pll_state = dsi_28nm_pll_save_state,\n\t\t.restore_pll_state = dsi_28nm_pll_restore_state,\n\t},\n\t.min_pll_rate = VCO_MIN_RATE,\n\t.max_pll_rate = VCO_MAX_RATE,\n\t.io_start = { 0xfd922b00 },\n\t.num_dsi_phy = 1,\n\t.quirks = DSI_PHY_28NM_QUIRK_PHY_8226,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}