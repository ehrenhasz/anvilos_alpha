{
  "module_name": "dsi_phy_7nm.c",
  "hash_id": "62f5173665b0728c57c18668312fd4fb54f9bd2b65800de04324216957050923",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dsi/phy/dsi_phy_7nm.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/iopoll.h>\n\n#include \"dsi_phy.h\"\n#include \"dsi.xml.h\"\n#include \"dsi_phy_7nm.xml.h\"\n\n \n\n#define VCO_REF_CLK_RATE\t\t19200000\n#define FRAC_BITS 18\n\n \n#define DSI_PHY_7NM_QUIRK_PRE_V4_1\tBIT(0)\n \n#define DSI_PHY_7NM_QUIRK_V4_1\t\tBIT(1)\n \n#define DSI_PHY_7NM_QUIRK_V4_2\t\tBIT(2)\n \n#define DSI_PHY_7NM_QUIRK_V4_3\t\tBIT(3)\n \n#define DSI_PHY_7NM_QUIRK_V5_2\t\tBIT(4)\n\nstruct dsi_pll_config {\n\tbool enable_ssc;\n\tbool ssc_center;\n\tu32 ssc_freq;\n\tu32 ssc_offset;\n\tu32 ssc_adj_per;\n\n\t \n\tu32 decimal_div_start;\n\tu32 frac_div_start;\n\tu32 pll_clock_inverters;\n\tu32 ssc_stepsize;\n\tu32 ssc_div_per;\n};\n\nstruct pll_7nm_cached_state {\n\tunsigned long vco_rate;\n\tu8 bit_clk_div;\n\tu8 pix_clk_div;\n\tu8 pll_out_div;\n\tu8 pll_mux;\n};\n\nstruct dsi_pll_7nm {\n\tstruct clk_hw clk_hw;\n\n\tstruct msm_dsi_phy *phy;\n\n\tu64 vco_current_rate;\n\n\t \n\tspinlock_t postdiv_lock;\n\n\tstruct pll_7nm_cached_state cached_state;\n\n\tstruct dsi_pll_7nm *slave;\n};\n\n#define to_pll_7nm(x)\tcontainer_of(x, struct dsi_pll_7nm, clk_hw)\n\n \nstatic struct dsi_pll_7nm *pll_7nm_list[DSI_MAX];\n\nstatic void dsi_pll_setup_config(struct dsi_pll_config *config)\n{\n\tconfig->ssc_freq = 31500;\n\tconfig->ssc_offset = 4800;\n\tconfig->ssc_adj_per = 2;\n\n\t \n\tconfig->enable_ssc = false;\n\tconfig->ssc_center = 0;\n}\n\nstatic void dsi_pll_calc_dec_frac(struct dsi_pll_7nm *pll, struct dsi_pll_config *config)\n{\n\tu64 fref = VCO_REF_CLK_RATE;\n\tu64 pll_freq;\n\tu64 divider;\n\tu64 dec, dec_multiple;\n\tu32 frac;\n\tu64 multiplier;\n\n\tpll_freq = pll->vco_current_rate;\n\n\tdivider = fref * 2;\n\n\tmultiplier = 1 << FRAC_BITS;\n\tdec_multiple = div_u64(pll_freq * multiplier, divider);\n\tdec = div_u64_rem(dec_multiple, multiplier, &frac);\n\n\tif (pll->phy->cfg->quirks & DSI_PHY_7NM_QUIRK_PRE_V4_1)\n\t\tconfig->pll_clock_inverters = 0x28;\n\telse if ((pll->phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V5_2)) {\n\t\tif (pll_freq <= 1300000000ULL)\n\t\t\tconfig->pll_clock_inverters = 0xa0;\n\t\telse if (pll_freq <= 2500000000ULL)\n\t\t\tconfig->pll_clock_inverters = 0x20;\n\t\telse if (pll_freq <= 4000000000ULL)\n\t\t\tconfig->pll_clock_inverters = 0x00;\n\t\telse\n\t\t\tconfig->pll_clock_inverters = 0x40;\n\t} else {\n\t\tif (pll_freq <= 1000000000ULL)\n\t\t\tconfig->pll_clock_inverters = 0xa0;\n\t\telse if (pll_freq <= 2500000000ULL)\n\t\t\tconfig->pll_clock_inverters = 0x20;\n\t\telse if (pll_freq <= 3020000000ULL)\n\t\t\tconfig->pll_clock_inverters = 0x00;\n\t\telse\n\t\t\tconfig->pll_clock_inverters = 0x40;\n\t}\n\n\tconfig->decimal_div_start = dec;\n\tconfig->frac_div_start = frac;\n}\n\n#define SSC_CENTER\t\tBIT(0)\n#define SSC_EN\t\t\tBIT(1)\n\nstatic void dsi_pll_calc_ssc(struct dsi_pll_7nm *pll, struct dsi_pll_config *config)\n{\n\tu32 ssc_per;\n\tu32 ssc_mod;\n\tu64 ssc_step_size;\n\tu64 frac;\n\n\tif (!config->enable_ssc) {\n\t\tDBG(\"SSC not enabled\\n\");\n\t\treturn;\n\t}\n\n\tssc_per = DIV_ROUND_CLOSEST(VCO_REF_CLK_RATE, config->ssc_freq) / 2 - 1;\n\tssc_mod = (ssc_per + 1) % (config->ssc_adj_per + 1);\n\tssc_per -= ssc_mod;\n\n\tfrac = config->frac_div_start;\n\tssc_step_size = config->decimal_div_start;\n\tssc_step_size *= (1 << FRAC_BITS);\n\tssc_step_size += frac;\n\tssc_step_size *= config->ssc_offset;\n\tssc_step_size *= (config->ssc_adj_per + 1);\n\tssc_step_size = div_u64(ssc_step_size, (ssc_per + 1));\n\tssc_step_size = DIV_ROUND_CLOSEST_ULL(ssc_step_size, 1000000);\n\n\tconfig->ssc_div_per = ssc_per;\n\tconfig->ssc_stepsize = ssc_step_size;\n\n\tpr_debug(\"SCC: Dec:%d, frac:%llu, frac_bits:%d\\n\",\n\t\t config->decimal_div_start, frac, FRAC_BITS);\n\tpr_debug(\"SSC: div_per:0x%X, stepsize:0x%X, adjper:0x%X\\n\",\n\t\t ssc_per, (u32)ssc_step_size, config->ssc_adj_per);\n}\n\nstatic void dsi_pll_ssc_commit(struct dsi_pll_7nm *pll, struct dsi_pll_config *config)\n{\n\tvoid __iomem *base = pll->phy->pll_base;\n\n\tif (config->enable_ssc) {\n\t\tpr_debug(\"SSC is enabled\\n\");\n\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_SSC_STEPSIZE_LOW_1,\n\t\t\t      config->ssc_stepsize & 0xff);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_SSC_STEPSIZE_HIGH_1,\n\t\t\t      config->ssc_stepsize >> 8);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_SSC_DIV_PER_LOW_1,\n\t\t\t      config->ssc_div_per & 0xff);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_SSC_DIV_PER_HIGH_1,\n\t\t\t      config->ssc_div_per >> 8);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_SSC_ADJPER_LOW_1,\n\t\t\t      config->ssc_adj_per & 0xff);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_SSC_ADJPER_HIGH_1,\n\t\t\t      config->ssc_adj_per >> 8);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_SSC_CONTROL,\n\t\t\t      SSC_EN | (config->ssc_center ? SSC_CENTER : 0));\n\t}\n}\n\nstatic void dsi_pll_config_hzindep_reg(struct dsi_pll_7nm *pll)\n{\n\tvoid __iomem *base = pll->phy->pll_base;\n\tu8 analog_controls_five_1 = 0x01, vco_config_1 = 0x00;\n\n\tif (!(pll->phy->cfg->quirks & DSI_PHY_7NM_QUIRK_PRE_V4_1))\n\t\tif (pll->vco_current_rate >= 3100000000ULL)\n\t\t\tanalog_controls_five_1 = 0x03;\n\n\tif (pll->phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V4_1) {\n\t\tif (pll->vco_current_rate < 1520000000ULL)\n\t\t\tvco_config_1 = 0x08;\n\t\telse if (pll->vco_current_rate < 2990000000ULL)\n\t\t\tvco_config_1 = 0x01;\n\t}\n\n\tif ((pll->phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V4_2) ||\n\t    (pll->phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V4_3)) {\n\t\tif (pll->vco_current_rate < 1520000000ULL)\n\t\t\tvco_config_1 = 0x08;\n\t\telse if (pll->vco_current_rate >= 2990000000ULL)\n\t\t\tvco_config_1 = 0x01;\n\t}\n\n\tif ((pll->phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V5_2)) {\n\t\tif (pll->vco_current_rate < 1557000000ULL)\n\t\t\tvco_config_1 = 0x08;\n\t\telse\n\t\t\tvco_config_1 = 0x01;\n\t}\n\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_ANALOG_CONTROLS_FIVE_1,\n\t\t      analog_controls_five_1);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_VCO_CONFIG_1, vco_config_1);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_ANALOG_CONTROLS_FIVE, 0x01);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_ANALOG_CONTROLS_TWO, 0x03);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_ANALOG_CONTROLS_THREE, 0x00);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_DSM_DIVIDER, 0x00);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_FEEDBACK_DIVIDER, 0x4e);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_CALIBRATION_SETTINGS, 0x40);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_BAND_SEL_CAL_SETTINGS_THREE, 0xba);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_FREQ_DETECT_SETTINGS_ONE, 0x0c);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_OUTDIV, 0x00);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_CORE_OVERRIDE, 0x00);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PLL_DIGITAL_TIMERS_TWO, 0x08);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PLL_PROP_GAIN_RATE_1, 0x0a);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PLL_BAND_SEL_RATE_1, 0xc0);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PLL_INT_GAIN_IFILT_BAND_1, 0x84);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PLL_INT_GAIN_IFILT_BAND_1, 0x82);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PLL_FL_INT_GAIN_PFILT_BAND_1, 0x4c);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PLL_LOCK_OVERRIDE, 0x80);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PFILT, 0x29);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PFILT, 0x2f);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_IFILT, 0x2a);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_IFILT,\n\t\t  !(pll->phy->cfg->quirks & DSI_PHY_7NM_QUIRK_PRE_V4_1) ? 0x3f : 0x22);\n\n\tif (!(pll->phy->cfg->quirks & DSI_PHY_7NM_QUIRK_PRE_V4_1)) {\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PERF_OPTIMIZE, 0x22);\n\t\tif (pll->slave)\n\t\t\tdsi_phy_write(pll->slave->phy->pll_base + REG_DSI_7nm_PHY_PLL_PERF_OPTIMIZE, 0x22);\n\t}\n}\n\nstatic void dsi_pll_commit(struct dsi_pll_7nm *pll, struct dsi_pll_config *config)\n{\n\tvoid __iomem *base = pll->phy->pll_base;\n\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_CORE_INPUT_OVERRIDE, 0x12);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_DECIMAL_DIV_START_1,\n\t\t      config->decimal_div_start);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_FRAC_DIV_START_LOW_1,\n\t\t      config->frac_div_start & 0xff);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_FRAC_DIV_START_MID_1,\n\t\t      (config->frac_div_start & 0xff00) >> 8);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_FRAC_DIV_START_HIGH_1,\n\t\t      (config->frac_div_start & 0x30000) >> 16);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PLL_LOCKDET_RATE_1, 0x40);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_PLL_LOCK_DELAY, 0x06);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_CMODE_1,\n\t\t      pll->phy->cphy_mode ? 0x00 : 0x10);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_PLL_CLOCK_INVERTERS,\n\t\t      config->pll_clock_inverters);\n}\n\nstatic int dsi_pll_7nm_vco_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct dsi_pll_7nm *pll_7nm = to_pll_7nm(hw);\n\tstruct dsi_pll_config config;\n\n\tDBG(\"DSI PLL%d rate=%lu, parent's=%lu\", pll_7nm->phy->id, rate,\n\t    parent_rate);\n\n\tpll_7nm->vco_current_rate = rate;\n\n\tdsi_pll_setup_config(&config);\n\n\tdsi_pll_calc_dec_frac(pll_7nm, &config);\n\n\tdsi_pll_calc_ssc(pll_7nm, &config);\n\n\tdsi_pll_commit(pll_7nm, &config);\n\n\tdsi_pll_config_hzindep_reg(pll_7nm);\n\n\tdsi_pll_ssc_commit(pll_7nm, &config);\n\n\t \n\twmb();\n\n\treturn 0;\n}\n\nstatic int dsi_pll_7nm_lock_status(struct dsi_pll_7nm *pll)\n{\n\tint rc;\n\tu32 status = 0;\n\tu32 const delay_us = 100;\n\tu32 const timeout_us = 5000;\n\n\trc = readl_poll_timeout_atomic(pll->phy->pll_base +\n\t\t\t\t       REG_DSI_7nm_PHY_PLL_COMMON_STATUS_ONE,\n\t\t\t\t       status,\n\t\t\t\t       ((status & BIT(0)) > 0),\n\t\t\t\t       delay_us,\n\t\t\t\t       timeout_us);\n\tif (rc)\n\t\tpr_err(\"DSI PLL(%d) lock failed, status=0x%08x\\n\",\n\t\t       pll->phy->id, status);\n\n\treturn rc;\n}\n\nstatic void dsi_pll_disable_pll_bias(struct dsi_pll_7nm *pll)\n{\n\tu32 data = dsi_phy_read(pll->phy->base + REG_DSI_7nm_PHY_CMN_CTRL_0);\n\n\tdsi_phy_write(pll->phy->pll_base + REG_DSI_7nm_PHY_PLL_SYSTEM_MUXES, 0);\n\tdsi_phy_write(pll->phy->base + REG_DSI_7nm_PHY_CMN_CTRL_0, data & ~BIT(5));\n\tndelay(250);\n}\n\nstatic void dsi_pll_enable_pll_bias(struct dsi_pll_7nm *pll)\n{\n\tu32 data = dsi_phy_read(pll->phy->base + REG_DSI_7nm_PHY_CMN_CTRL_0);\n\n\tdsi_phy_write(pll->phy->base + REG_DSI_7nm_PHY_CMN_CTRL_0, data | BIT(5));\n\tdsi_phy_write(pll->phy->pll_base + REG_DSI_7nm_PHY_PLL_SYSTEM_MUXES, 0xc0);\n\tndelay(250);\n}\n\nstatic void dsi_pll_disable_global_clk(struct dsi_pll_7nm *pll)\n{\n\tu32 data;\n\n\tdata = dsi_phy_read(pll->phy->base + REG_DSI_7nm_PHY_CMN_CLK_CFG1);\n\tdsi_phy_write(pll->phy->base + REG_DSI_7nm_PHY_CMN_CLK_CFG1, data & ~BIT(5));\n}\n\nstatic void dsi_pll_enable_global_clk(struct dsi_pll_7nm *pll)\n{\n\tu32 data;\n\n\tdsi_phy_write(pll->phy->base + REG_DSI_7nm_PHY_CMN_CTRL_3, 0x04);\n\n\tdata = dsi_phy_read(pll->phy->base + REG_DSI_7nm_PHY_CMN_CLK_CFG1);\n\tdsi_phy_write(pll->phy->base + REG_DSI_7nm_PHY_CMN_CLK_CFG1,\n\t\t      data | BIT(5) | BIT(4));\n}\n\nstatic void dsi_pll_phy_dig_reset(struct dsi_pll_7nm *pll)\n{\n\t \n\tdsi_phy_write(pll->phy->base + REG_DSI_7nm_PHY_CMN_GLBL_DIGTOP_SPARE4, BIT(0));\n\twmb();  \n\tdsi_phy_write(pll->phy->base + REG_DSI_7nm_PHY_CMN_GLBL_DIGTOP_SPARE4, 0x0);\n\twmb();  \n}\n\nstatic int dsi_pll_7nm_vco_prepare(struct clk_hw *hw)\n{\n\tstruct dsi_pll_7nm *pll_7nm = to_pll_7nm(hw);\n\tint rc;\n\n\tdsi_pll_enable_pll_bias(pll_7nm);\n\tif (pll_7nm->slave)\n\t\tdsi_pll_enable_pll_bias(pll_7nm->slave);\n\n\t \n\tdsi_phy_write(pll_7nm->phy->base + REG_DSI_7nm_PHY_CMN_PLL_CNTRL, 0x01);\n\n\t \n\twmb();\n\n\t \n\trc = dsi_pll_7nm_lock_status(pll_7nm);\n\tif (rc) {\n\t\tpr_err(\"PLL(%d) lock failed\\n\", pll_7nm->phy->id);\n\t\tgoto error;\n\t}\n\n\tpll_7nm->phy->pll_on = true;\n\n\t \n\tdsi_pll_phy_dig_reset(pll_7nm);\n\tif (pll_7nm->slave)\n\t\tdsi_pll_phy_dig_reset(pll_7nm->slave);\n\n\tdsi_pll_enable_global_clk(pll_7nm);\n\tif (pll_7nm->slave)\n\t\tdsi_pll_enable_global_clk(pll_7nm->slave);\n\nerror:\n\treturn rc;\n}\n\nstatic void dsi_pll_disable_sub(struct dsi_pll_7nm *pll)\n{\n\tdsi_phy_write(pll->phy->base + REG_DSI_7nm_PHY_CMN_RBUF_CTRL, 0);\n\tdsi_pll_disable_pll_bias(pll);\n}\n\nstatic void dsi_pll_7nm_vco_unprepare(struct clk_hw *hw)\n{\n\tstruct dsi_pll_7nm *pll_7nm = to_pll_7nm(hw);\n\n\t \n\tdsi_pll_disable_global_clk(pll_7nm);\n\tdsi_phy_write(pll_7nm->phy->base + REG_DSI_7nm_PHY_CMN_PLL_CNTRL, 0);\n\tdsi_pll_disable_sub(pll_7nm);\n\tif (pll_7nm->slave) {\n\t\tdsi_pll_disable_global_clk(pll_7nm->slave);\n\t\tdsi_pll_disable_sub(pll_7nm->slave);\n\t}\n\t \n\twmb();\n\tpll_7nm->phy->pll_on = false;\n}\n\nstatic unsigned long dsi_pll_7nm_vco_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct dsi_pll_7nm *pll_7nm = to_pll_7nm(hw);\n\tvoid __iomem *base = pll_7nm->phy->pll_base;\n\tu64 ref_clk = VCO_REF_CLK_RATE;\n\tu64 vco_rate = 0x0;\n\tu64 multiplier;\n\tu32 frac;\n\tu32 dec;\n\tu64 pll_freq, tmp64;\n\n\tdec = dsi_phy_read(base + REG_DSI_7nm_PHY_PLL_DECIMAL_DIV_START_1);\n\tdec &= 0xff;\n\n\tfrac = dsi_phy_read(base + REG_DSI_7nm_PHY_PLL_FRAC_DIV_START_LOW_1);\n\tfrac |= ((dsi_phy_read(base + REG_DSI_7nm_PHY_PLL_FRAC_DIV_START_MID_1) &\n\t\t  0xff) << 8);\n\tfrac |= ((dsi_phy_read(base + REG_DSI_7nm_PHY_PLL_FRAC_DIV_START_HIGH_1) &\n\t\t  0x3) << 16);\n\n\t \n\tmultiplier = 1 << FRAC_BITS;\n\tpll_freq = dec * (ref_clk * 2);\n\ttmp64 = (ref_clk * 2 * frac);\n\tpll_freq += div_u64(tmp64, multiplier);\n\n\tvco_rate = pll_freq;\n\tpll_7nm->vco_current_rate = vco_rate;\n\n\tDBG(\"DSI PLL%d returning vco rate = %lu, dec = %x, frac = %x\",\n\t    pll_7nm->phy->id, (unsigned long)vco_rate, dec, frac);\n\n\treturn (unsigned long)vco_rate;\n}\n\nstatic long dsi_pll_7nm_clk_round_rate(struct clk_hw *hw,\n\t\tunsigned long rate, unsigned long *parent_rate)\n{\n\tstruct dsi_pll_7nm *pll_7nm = to_pll_7nm(hw);\n\n\tif      (rate < pll_7nm->phy->cfg->min_pll_rate)\n\t\treturn  pll_7nm->phy->cfg->min_pll_rate;\n\telse if (rate > pll_7nm->phy->cfg->max_pll_rate)\n\t\treturn  pll_7nm->phy->cfg->max_pll_rate;\n\telse\n\t\treturn rate;\n}\n\nstatic const struct clk_ops clk_ops_dsi_pll_7nm_vco = {\n\t.round_rate = dsi_pll_7nm_clk_round_rate,\n\t.set_rate = dsi_pll_7nm_vco_set_rate,\n\t.recalc_rate = dsi_pll_7nm_vco_recalc_rate,\n\t.prepare = dsi_pll_7nm_vco_prepare,\n\t.unprepare = dsi_pll_7nm_vco_unprepare,\n};\n\n \n\nstatic void dsi_7nm_pll_save_state(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_7nm *pll_7nm = to_pll_7nm(phy->vco_hw);\n\tstruct pll_7nm_cached_state *cached = &pll_7nm->cached_state;\n\tvoid __iomem *phy_base = pll_7nm->phy->base;\n\tu32 cmn_clk_cfg0, cmn_clk_cfg1;\n\n\tcached->pll_out_div = dsi_phy_read(pll_7nm->phy->pll_base +\n\t\t\tREG_DSI_7nm_PHY_PLL_PLL_OUTDIV_RATE);\n\tcached->pll_out_div &= 0x3;\n\n\tcmn_clk_cfg0 = dsi_phy_read(phy_base + REG_DSI_7nm_PHY_CMN_CLK_CFG0);\n\tcached->bit_clk_div = cmn_clk_cfg0 & 0xf;\n\tcached->pix_clk_div = (cmn_clk_cfg0 & 0xf0) >> 4;\n\n\tcmn_clk_cfg1 = dsi_phy_read(phy_base + REG_DSI_7nm_PHY_CMN_CLK_CFG1);\n\tcached->pll_mux = cmn_clk_cfg1 & 0x3;\n\n\tDBG(\"DSI PLL%d outdiv %x bit_clk_div %x pix_clk_div %x pll_mux %x\",\n\t    pll_7nm->phy->id, cached->pll_out_div, cached->bit_clk_div,\n\t    cached->pix_clk_div, cached->pll_mux);\n}\n\nstatic int dsi_7nm_pll_restore_state(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_7nm *pll_7nm = to_pll_7nm(phy->vco_hw);\n\tstruct pll_7nm_cached_state *cached = &pll_7nm->cached_state;\n\tvoid __iomem *phy_base = pll_7nm->phy->base;\n\tu32 val;\n\tint ret;\n\n\tval = dsi_phy_read(pll_7nm->phy->pll_base + REG_DSI_7nm_PHY_PLL_PLL_OUTDIV_RATE);\n\tval &= ~0x3;\n\tval |= cached->pll_out_div;\n\tdsi_phy_write(pll_7nm->phy->pll_base + REG_DSI_7nm_PHY_PLL_PLL_OUTDIV_RATE, val);\n\n\tdsi_phy_write(phy_base + REG_DSI_7nm_PHY_CMN_CLK_CFG0,\n\t\t      cached->bit_clk_div | (cached->pix_clk_div << 4));\n\n\tval = dsi_phy_read(phy_base + REG_DSI_7nm_PHY_CMN_CLK_CFG1);\n\tval &= ~0x3;\n\tval |= cached->pll_mux;\n\tdsi_phy_write(phy_base + REG_DSI_7nm_PHY_CMN_CLK_CFG1, val);\n\n\tret = dsi_pll_7nm_vco_set_rate(phy->vco_hw,\n\t\t\tpll_7nm->vco_current_rate,\n\t\t\tVCO_REF_CLK_RATE);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pll_7nm->phy->pdev->dev,\n\t\t\t\"restore vco rate failed. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tDBG(\"DSI PLL%d\", pll_7nm->phy->id);\n\n\treturn 0;\n}\n\nstatic int dsi_7nm_set_usecase(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_7nm *pll_7nm = to_pll_7nm(phy->vco_hw);\n\tvoid __iomem *base = phy->base;\n\tu32 data = 0x0;\t \n\n\tDBG(\"DSI PLL%d\", pll_7nm->phy->id);\n\n\tswitch (phy->usecase) {\n\tcase MSM_DSI_PHY_STANDALONE:\n\t\tbreak;\n\tcase MSM_DSI_PHY_MASTER:\n\t\tpll_7nm->slave = pll_7nm_list[(pll_7nm->phy->id + 1) % DSI_MAX];\n\t\tbreak;\n\tcase MSM_DSI_PHY_SLAVE:\n\t\tdata = 0x1;  \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_CLK_CFG1, (data << 2));\n\n\treturn 0;\n}\n\n \nstatic int pll_7nm_register(struct dsi_pll_7nm *pll_7nm, struct clk_hw **provided_clocks)\n{\n\tchar clk_name[32];\n\tstruct clk_init_data vco_init = {\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"ref\",\n\t\t},\n\t\t.num_parents = 1,\n\t\t.name = clk_name,\n\t\t.flags = CLK_IGNORE_UNUSED,\n\t\t.ops = &clk_ops_dsi_pll_7nm_vco,\n\t};\n\tstruct device *dev = &pll_7nm->phy->pdev->dev;\n\tstruct clk_hw *hw, *pll_out_div, *pll_bit, *pll_by_2_bit;\n\tstruct clk_hw *pll_post_out_div, *phy_pll_out_dsi_parent;\n\tint ret;\n\n\tDBG(\"DSI%d\", pll_7nm->phy->id);\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dvco_clk\", pll_7nm->phy->id);\n\tpll_7nm->clk_hw.init = &vco_init;\n\n\tret = devm_clk_hw_register(dev, &pll_7nm->clk_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_pll_out_div_clk\", pll_7nm->phy->id);\n\n\tpll_out_div = devm_clk_hw_register_divider_parent_hw(dev, clk_name,\n\t\t\t&pll_7nm->clk_hw, CLK_SET_RATE_PARENT,\n\t\t\tpll_7nm->phy->pll_base +\n\t\t\t\tREG_DSI_7nm_PHY_PLL_PLL_OUTDIV_RATE,\n\t\t\t0, 2, CLK_DIVIDER_POWER_OF_TWO, NULL);\n\tif (IS_ERR(pll_out_div)) {\n\t\tret = PTR_ERR(pll_out_div);\n\t\tgoto fail;\n\t}\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_pll_bit_clk\", pll_7nm->phy->id);\n\n\t \n\tpll_bit = devm_clk_hw_register_divider_parent_hw(dev, clk_name,\n\t\t\tpll_out_div, CLK_SET_RATE_PARENT,\n\t\t\tpll_7nm->phy->base + REG_DSI_7nm_PHY_CMN_CLK_CFG0,\n\t\t\t0, 4, CLK_DIVIDER_ONE_BASED, &pll_7nm->postdiv_lock);\n\tif (IS_ERR(pll_bit)) {\n\t\tret = PTR_ERR(pll_bit);\n\t\tgoto fail;\n\t}\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_phy_pll_out_byteclk\", pll_7nm->phy->id);\n\n\t \n\thw = devm_clk_hw_register_fixed_factor_parent_hw(dev, clk_name,\n\t\t\tpll_bit, CLK_SET_RATE_PARENT, 1,\n\t\t\tpll_7nm->phy->cphy_mode ? 7 : 8);\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto fail;\n\t}\n\n\tprovided_clocks[DSI_BYTE_PLL_CLK] = hw;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_pll_by_2_bit_clk\", pll_7nm->phy->id);\n\n\tpll_by_2_bit = devm_clk_hw_register_fixed_factor_parent_hw(dev,\n\t\t\tclk_name, pll_bit, 0, 1, 2);\n\tif (IS_ERR(pll_by_2_bit)) {\n\t\tret = PTR_ERR(pll_by_2_bit);\n\t\tgoto fail;\n\t}\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_pll_post_out_div_clk\", pll_7nm->phy->id);\n\n\tif (pll_7nm->phy->cphy_mode)\n\t\tpll_post_out_div = devm_clk_hw_register_fixed_factor_parent_hw(\n\t\t\t\tdev, clk_name, pll_out_div, 0, 2, 7);\n\telse\n\t\tpll_post_out_div = devm_clk_hw_register_fixed_factor_parent_hw(\n\t\t\t\tdev, clk_name, pll_out_div, 0, 1, 4);\n\tif (IS_ERR(pll_post_out_div)) {\n\t\tret = PTR_ERR(pll_post_out_div);\n\t\tgoto fail;\n\t}\n\n\t \n\tif (pll_7nm->phy->cphy_mode) {\n\t\tu32 data;\n\n\t\tdata = dsi_phy_read(pll_7nm->phy->base + REG_DSI_7nm_PHY_CMN_CLK_CFG1);\n\t\tdsi_phy_write(pll_7nm->phy->base + REG_DSI_7nm_PHY_CMN_CLK_CFG1, data | 3);\n\n\t\tphy_pll_out_dsi_parent = pll_post_out_div;\n\t} else {\n\t\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_pclk_mux\", pll_7nm->phy->id);\n\n\t\thw = devm_clk_hw_register_mux_parent_hws(dev, clk_name,\n\t\t\t\t((const struct clk_hw *[]){\n\t\t\t\t\tpll_bit,\n\t\t\t\t\tpll_by_2_bit,\n\t\t\t\t}), 2, 0, pll_7nm->phy->base +\n\t\t\t\t\tREG_DSI_7nm_PHY_CMN_CLK_CFG1,\n\t\t\t\t0, 1, 0, NULL);\n\t\tif (IS_ERR(hw)) {\n\t\t\tret = PTR_ERR(hw);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tphy_pll_out_dsi_parent = hw;\n\t}\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_phy_pll_out_dsiclk\", pll_7nm->phy->id);\n\n\t \n\thw = devm_clk_hw_register_divider_parent_hw(dev, clk_name,\n\t\t\tphy_pll_out_dsi_parent, 0,\n\t\t\tpll_7nm->phy->base + REG_DSI_7nm_PHY_CMN_CLK_CFG0,\n\t\t\t4, 4, CLK_DIVIDER_ONE_BASED, &pll_7nm->postdiv_lock);\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto fail;\n\t}\n\n\tprovided_clocks[DSI_PIXEL_PLL_CLK] = hw;\n\n\treturn 0;\n\nfail:\n\n\treturn ret;\n}\n\nstatic int dsi_pll_7nm_init(struct msm_dsi_phy *phy)\n{\n\tstruct platform_device *pdev = phy->pdev;\n\tstruct dsi_pll_7nm *pll_7nm;\n\tint ret;\n\n\tpll_7nm = devm_kzalloc(&pdev->dev, sizeof(*pll_7nm), GFP_KERNEL);\n\tif (!pll_7nm)\n\t\treturn -ENOMEM;\n\n\tDBG(\"DSI PLL%d\", phy->id);\n\n\tpll_7nm_list[phy->id] = pll_7nm;\n\n\tspin_lock_init(&pll_7nm->postdiv_lock);\n\n\tpll_7nm->phy = phy;\n\n\tret = pll_7nm_register(pll_7nm, phy->provided_clocks->hws);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"failed to register PLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphy->vco_hw = &pll_7nm->clk_hw;\n\n\t \n\tmsm_dsi_phy_pll_save_state(phy);\n\n\treturn 0;\n}\n\nstatic int dsi_phy_hw_v4_0_is_pll_on(struct msm_dsi_phy *phy)\n{\n\tvoid __iomem *base = phy->base;\n\tu32 data = 0;\n\n\tdata = dsi_phy_read(base + REG_DSI_7nm_PHY_CMN_PLL_CNTRL);\n\tmb();  \n\n\treturn (data & BIT(0));\n}\n\nstatic void dsi_phy_hw_v4_0_config_lpcdrx(struct msm_dsi_phy *phy, bool enable)\n{\n\tvoid __iomem *lane_base = phy->lane_base;\n\tint phy_lane_0 = 0;\t \n\n\t \n\tif (enable)\n\t\tdsi_phy_write(lane_base +\n\t\t\t      REG_DSI_7nm_PHY_LN_LPRX_CTRL(phy_lane_0), 0x3);\n\telse\n\t\tdsi_phy_write(lane_base +\n\t\t\t      REG_DSI_7nm_PHY_LN_LPRX_CTRL(phy_lane_0), 0);\n}\n\nstatic void dsi_phy_hw_v4_0_lane_settings(struct msm_dsi_phy *phy)\n{\n\tint i;\n\tconst u8 tx_dctrl_0[] = { 0x00, 0x00, 0x00, 0x04, 0x01 };\n\tconst u8 tx_dctrl_1[] = { 0x40, 0x40, 0x40, 0x46, 0x41 };\n\tconst u8 *tx_dctrl = tx_dctrl_0;\n\tvoid __iomem *lane_base = phy->lane_base;\n\n\tif (!(phy->cfg->quirks & DSI_PHY_7NM_QUIRK_PRE_V4_1))\n\t\ttx_dctrl = tx_dctrl_1;\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\t \n\t\tdsi_phy_write(lane_base + REG_DSI_7nm_PHY_LN_LPRX_CTRL(i), 0);\n\t\tdsi_phy_write(lane_base + REG_DSI_7nm_PHY_LN_PIN_SWAP(i), 0x0);\n\t}\n\n\tdsi_phy_hw_v4_0_config_lpcdrx(phy, true);\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tdsi_phy_write(lane_base + REG_DSI_7nm_PHY_LN_CFG0(i), 0x0);\n\t\tdsi_phy_write(lane_base + REG_DSI_7nm_PHY_LN_CFG1(i), 0x0);\n\t\tdsi_phy_write(lane_base + REG_DSI_7nm_PHY_LN_CFG2(i), i == 4 ? 0x8a : 0xa);\n\t\tdsi_phy_write(lane_base + REG_DSI_7nm_PHY_LN_TX_DCTRL(i), tx_dctrl[i]);\n\t}\n}\n\nstatic int dsi_7nm_phy_enable(struct msm_dsi_phy *phy,\n\t\t\t      struct msm_dsi_phy_clk_request *clk_req)\n{\n\tint ret;\n\tu32 status;\n\tu32 const delay_us = 5;\n\tu32 const timeout_us = 1000;\n\tstruct msm_dsi_dphy_timing *timing = &phy->timing;\n\tvoid __iomem *base = phy->base;\n\tbool less_than_1500_mhz;\n\tu32 vreg_ctrl_0, vreg_ctrl_1, lane_ctrl0;\n\tu32 glbl_pemph_ctrl_0;\n\tu32 glbl_str_swi_cal_sel_ctrl, glbl_hstx_str_ctrl_0;\n\tu32 glbl_rescode_top_ctrl, glbl_rescode_bot_ctrl;\n\tu32 data;\n\n\tDBG(\"\");\n\n\tif (phy->cphy_mode)\n\t\tret = msm_dsi_cphy_timing_calc_v4(timing, clk_req);\n\telse\n\t\tret = msm_dsi_dphy_timing_calc_v4(timing, clk_req);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&phy->pdev->dev,\n\t\t\t      \"%s: PHY timing calculation failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dsi_phy_hw_v4_0_is_pll_on(phy))\n\t\tpr_warn(\"PLL turned on before configuring PHY\\n\");\n\n\t \n\tif ((phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V4_3) ||\n\t    (phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V5_2)) {\n\t\tdsi_phy_write(phy->base + REG_DSI_7nm_PHY_CMN_GLBL_DIGTOP_SPARE10, 0x1);\n\t\tudelay(500);\n\t}\n\n\t \n\tret = readl_poll_timeout_atomic(base + REG_DSI_7nm_PHY_CMN_PHY_STATUS,\n\t\t\t\t\tstatus, (status & BIT(0)),\n\t\t\t\t\tdelay_us, timeout_us);\n\tif (ret) {\n\t\tpr_err(\"Ref gen not ready. Aborting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\t \n\tless_than_1500_mhz = (clk_req->bitclk_rate <= 1500000000);\n\n\tglbl_str_swi_cal_sel_ctrl = 0x00;\n\tif (phy->cphy_mode) {\n\t\tvreg_ctrl_0 = 0x51;\n\t\tvreg_ctrl_1 = 0x55;\n\t\tglbl_hstx_str_ctrl_0 = 0x00;\n\t\tglbl_pemph_ctrl_0 = 0x11;\n\t\tlane_ctrl0 = 0x17;\n\t} else {\n\t\tvreg_ctrl_0 = less_than_1500_mhz ? 0x53 : 0x52;\n\t\tvreg_ctrl_1 = 0x5c;\n\t\tglbl_hstx_str_ctrl_0 = 0x88;\n\t\tglbl_pemph_ctrl_0 = 0x00;\n\t\tlane_ctrl0 = 0x1f;\n\t}\n\n\tif ((phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V5_2)) {\n\t\tif (phy->cphy_mode) {\n\t\t\tvreg_ctrl_0 = 0x45;\n\t\t\tvreg_ctrl_1 = 0x41;\n\t\t\tglbl_rescode_top_ctrl = 0x00;\n\t\t\tglbl_rescode_bot_ctrl = 0x00;\n\t\t} else {\n\t\t\tvreg_ctrl_0 = 0x44;\n\t\t\tvreg_ctrl_1 = 0x19;\n\t\t\tglbl_rescode_top_ctrl = less_than_1500_mhz ? 0x3c :  0x03;\n\t\t\tglbl_rescode_bot_ctrl = less_than_1500_mhz ? 0x38 :  0x3c;\n\t\t}\n\t} else if ((phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V4_3)) {\n\t\tif (phy->cphy_mode) {\n\t\t\tglbl_rescode_top_ctrl = less_than_1500_mhz ? 0x3d :  0x01;\n\t\t\tglbl_rescode_bot_ctrl = less_than_1500_mhz ? 0x38 :  0x3b;\n\t\t} else {\n\t\t\tglbl_rescode_top_ctrl = less_than_1500_mhz ? 0x3d :  0x01;\n\t\t\tglbl_rescode_bot_ctrl = less_than_1500_mhz ? 0x38 :  0x39;\n\t\t}\n\t} else if (phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V4_2) {\n\t\tif (phy->cphy_mode) {\n\t\t\tglbl_rescode_top_ctrl = less_than_1500_mhz ? 0x3d :  0x01;\n\t\t\tglbl_rescode_bot_ctrl = less_than_1500_mhz ? 0x38 :  0x3b;\n\t\t} else {\n\t\t\tglbl_rescode_top_ctrl = less_than_1500_mhz ? 0x3c :  0x00;\n\t\t\tglbl_rescode_bot_ctrl = less_than_1500_mhz ? 0x38 :  0x39;\n\t\t}\n\t} else if (phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V4_1) {\n\t\tif (phy->cphy_mode) {\n\t\t\tglbl_hstx_str_ctrl_0 = 0x88;\n\t\t\tglbl_rescode_top_ctrl = 0x00;\n\t\t\tglbl_rescode_bot_ctrl = 0x3c;\n\t\t} else {\n\t\t\tglbl_rescode_top_ctrl = less_than_1500_mhz ? 0x3d :  0x00;\n\t\t\tglbl_rescode_bot_ctrl = less_than_1500_mhz ? 0x39 :  0x3c;\n\t\t}\n\t} else {\n\t\tif (phy->cphy_mode) {\n\t\t\tglbl_str_swi_cal_sel_ctrl = 0x03;\n\t\t\tglbl_hstx_str_ctrl_0 = 0x66;\n\t\t} else {\n\t\t\tvreg_ctrl_0 = less_than_1500_mhz ? 0x5B : 0x59;\n\t\t\tglbl_str_swi_cal_sel_ctrl = less_than_1500_mhz ? 0x03 : 0x00;\n\t\t\tglbl_hstx_str_ctrl_0 = less_than_1500_mhz ? 0x66 : 0x88;\n\t\t}\n\t\tglbl_rescode_top_ctrl = 0x03;\n\t\tglbl_rescode_bot_ctrl = 0x3c;\n\t}\n\n\t \n\tdata = BIT(6) | BIT(5);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_CTRL_0, data);\n\n\t \n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_PLL_CNTRL, 0x00);\n\n\t \n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_RBUF_CTRL, 0x00);\n\n\t \n\tif ((phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V5_2) ||\n\t    (dsi_phy_read(base + REG_DSI_7nm_PHY_CMN_REVISION_ID0) & (0xf0)) == 0x20)\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_CTRL_4, 0x04);\n\n\t \n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_LANE_CFG0, 0x21);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_LANE_CFG1, 0x84);\n\n\tif (phy->cphy_mode)\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_GLBL_CTRL, BIT(6));\n\n\t \n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_VREG_CTRL_0, vreg_ctrl_0);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_VREG_CTRL_1, vreg_ctrl_1);\n\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_CTRL_3, 0x00);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_GLBL_STR_SWI_CAL_SEL_CTRL,\n\t\t      glbl_str_swi_cal_sel_ctrl);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_GLBL_HSTX_STR_CTRL_0,\n\t\t      glbl_hstx_str_ctrl_0);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_GLBL_PEMPH_CTRL_0,\n\t\t      glbl_pemph_ctrl_0);\n\tif (phy->cphy_mode)\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_GLBL_PEMPH_CTRL_1, 0x01);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_GLBL_RESCODE_OFFSET_TOP_CTRL,\n\t\t      glbl_rescode_top_ctrl);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_GLBL_RESCODE_OFFSET_BOT_CTRL,\n\t\t      glbl_rescode_bot_ctrl);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_GLBL_LPTX_STR_CTRL, 0x55);\n\n\t \n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_CTRL_0, 0x7f);\n\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_LANE_CTRL0, lane_ctrl0);\n\n\t \n\tif (!phy->cphy_mode)\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_CTRL_2, 0x40);\n\n\tret = dsi_7nm_set_usecase(phy);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&phy->pdev->dev, \"%s: set pll usecase failed, %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (phy->cphy_mode) {\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_0, 0x00);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_4, timing->hs_exit);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_5,\n\t\t\t      timing->shared_timings.clk_pre);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_6, timing->clk_prepare);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_7,\n\t\t\t      timing->shared_timings.clk_post);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_8, timing->hs_rqst);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_9, 0x02);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_10, 0x04);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_11, 0x00);\n\t} else {\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_0, 0x00);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_1, timing->clk_zero);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_2, timing->clk_prepare);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_3, timing->clk_trail);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_4, timing->hs_exit);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_5, timing->hs_zero);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_6, timing->hs_prepare);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_7, timing->hs_trail);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_8, timing->hs_rqst);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_9, 0x02);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_10, 0x04);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_11, 0x00);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_12,\n\t\t\t      timing->shared_timings.clk_pre);\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_TIMING_CTRL_13,\n\t\t\t      timing->shared_timings.clk_post);\n\t}\n\n\t \n\tdsi_phy_hw_v4_0_lane_settings(phy);\n\n\tDBG(\"DSI%d PHY enabled\", phy->id);\n\n\treturn 0;\n}\n\nstatic bool dsi_7nm_set_continuous_clock(struct msm_dsi_phy *phy, bool enable)\n{\n\tvoid __iomem *base = phy->base;\n\tu32 data;\n\n\tdata = dsi_phy_read(base + REG_DSI_7nm_PHY_CMN_LANE_CTRL1);\n\tif (enable)\n\t\tdata |= BIT(5) | BIT(6);\n\telse\n\t\tdata &= ~(BIT(5) | BIT(6));\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_LANE_CTRL1, data);\n\n\treturn enable;\n}\n\nstatic void dsi_7nm_phy_disable(struct msm_dsi_phy *phy)\n{\n\tvoid __iomem *base = phy->base;\n\tu32 data;\n\n\tDBG(\"\");\n\n\tif (dsi_phy_hw_v4_0_is_pll_on(phy))\n\t\tpr_warn(\"Turning OFF PHY while PLL is on\\n\");\n\n\tdsi_phy_hw_v4_0_config_lpcdrx(phy, false);\n\n\t \n\tif ((phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V4_3) ||\n\t    (phy->cfg->quirks & DSI_PHY_7NM_QUIRK_V5_2)) {\n\t\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_GLBL_DIGTOP_SPARE10, 0x0);\n\t\twmb();\n\t\t \n\t\tudelay(2);\n\t}\n\n\tdata = dsi_phy_read(base + REG_DSI_7nm_PHY_CMN_CTRL_0);\n\n\t \n\tdata &= ~0x1F;\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_CTRL_0, data);\n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_LANE_CTRL0, 0);\n\n\t \n\tdsi_phy_write(base + REG_DSI_7nm_PHY_CMN_CTRL_0, 0x00);\n\t \n\twmb();\n\n\tDBG(\"DSI%d PHY disabled\", phy->id);\n}\n\nstatic const struct regulator_bulk_data dsi_phy_7nm_36mA_regulators[] = {\n\t{ .supply = \"vdds\", .init_load_uA = 36000 },\n};\n\nstatic const struct regulator_bulk_data dsi_phy_7nm_37750uA_regulators[] = {\n\t{ .supply = \"vdds\", .init_load_uA = 37550 },\n};\n\nstatic const struct regulator_bulk_data dsi_phy_7nm_97800uA_regulators[] = {\n\t{ .supply = \"vdds\", .init_load_uA = 97800 },\n};\n\nstatic const struct regulator_bulk_data dsi_phy_7nm_98400uA_regulators[] = {\n\t{ .supply = \"vdds\", .init_load_uA = 98400 },\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_7nm_cfgs = {\n\t.has_phy_lane = true,\n\t.regulator_data = dsi_phy_7nm_36mA_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_7nm_36mA_regulators),\n\t.ops = {\n\t\t.enable = dsi_7nm_phy_enable,\n\t\t.disable = dsi_7nm_phy_disable,\n\t\t.pll_init = dsi_pll_7nm_init,\n\t\t.save_pll_state = dsi_7nm_pll_save_state,\n\t\t.restore_pll_state = dsi_7nm_pll_restore_state,\n\t\t.set_continuous_clock = dsi_7nm_set_continuous_clock,\n\t},\n\t.min_pll_rate = 600000000UL,\n#ifdef CONFIG_64BIT\n\t.max_pll_rate = 5000000000UL,\n#else\n\t.max_pll_rate = ULONG_MAX,\n#endif\n\t.io_start = { 0xae94400, 0xae96400 },\n\t.num_dsi_phy = 2,\n\t.quirks = DSI_PHY_7NM_QUIRK_V4_1,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_7nm_6375_cfgs = {\n\t.has_phy_lane = true,\n\t.ops = {\n\t\t.enable = dsi_7nm_phy_enable,\n\t\t.disable = dsi_7nm_phy_disable,\n\t\t.pll_init = dsi_pll_7nm_init,\n\t\t.save_pll_state = dsi_7nm_pll_save_state,\n\t\t.restore_pll_state = dsi_7nm_pll_restore_state,\n\t},\n\t.min_pll_rate = 600000000UL,\n#ifdef CONFIG_64BIT\n\t.max_pll_rate = 5000000000ULL,\n#else\n\t.max_pll_rate = ULONG_MAX,\n#endif\n\t.io_start = { 0x5e94400 },\n\t.num_dsi_phy = 1,\n\t.quirks = DSI_PHY_7NM_QUIRK_V4_1,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_7nm_8150_cfgs = {\n\t.has_phy_lane = true,\n\t.regulator_data = dsi_phy_7nm_36mA_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_7nm_36mA_regulators),\n\t.ops = {\n\t\t.enable = dsi_7nm_phy_enable,\n\t\t.disable = dsi_7nm_phy_disable,\n\t\t.pll_init = dsi_pll_7nm_init,\n\t\t.save_pll_state = dsi_7nm_pll_save_state,\n\t\t.restore_pll_state = dsi_7nm_pll_restore_state,\n\t\t.set_continuous_clock = dsi_7nm_set_continuous_clock,\n\t},\n\t.min_pll_rate = 1000000000UL,\n\t.max_pll_rate = 3500000000UL,\n\t.io_start = { 0xae94400, 0xae96400 },\n\t.num_dsi_phy = 2,\n\t.quirks = DSI_PHY_7NM_QUIRK_PRE_V4_1,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_7nm_7280_cfgs = {\n\t.has_phy_lane = true,\n\t.regulator_data = dsi_phy_7nm_37750uA_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_7nm_37750uA_regulators),\n\t.ops = {\n\t\t.enable = dsi_7nm_phy_enable,\n\t\t.disable = dsi_7nm_phy_disable,\n\t\t.pll_init = dsi_pll_7nm_init,\n\t\t.save_pll_state = dsi_7nm_pll_save_state,\n\t\t.restore_pll_state = dsi_7nm_pll_restore_state,\n\t},\n\t.min_pll_rate = 600000000UL,\n#ifdef CONFIG_64BIT\n\t.max_pll_rate = 5000000000ULL,\n#else\n\t.max_pll_rate = ULONG_MAX,\n#endif\n\t.io_start = { 0xae94400 },\n\t.num_dsi_phy = 1,\n\t.quirks = DSI_PHY_7NM_QUIRK_V4_1,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_5nm_8350_cfgs = {\n\t.has_phy_lane = true,\n\t.regulator_data = dsi_phy_7nm_37750uA_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_7nm_37750uA_regulators),\n\t.ops = {\n\t\t.enable = dsi_7nm_phy_enable,\n\t\t.disable = dsi_7nm_phy_disable,\n\t\t.pll_init = dsi_pll_7nm_init,\n\t\t.save_pll_state = dsi_7nm_pll_save_state,\n\t\t.restore_pll_state = dsi_7nm_pll_restore_state,\n\t\t.set_continuous_clock = dsi_7nm_set_continuous_clock,\n\t},\n\t.min_pll_rate = 600000000UL,\n#ifdef CONFIG_64BIT\n\t.max_pll_rate = 5000000000UL,\n#else\n\t.max_pll_rate = ULONG_MAX,\n#endif\n\t.io_start = { 0xae94400, 0xae96400 },\n\t.num_dsi_phy = 2,\n\t.quirks = DSI_PHY_7NM_QUIRK_V4_2,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_5nm_8450_cfgs = {\n\t.has_phy_lane = true,\n\t.regulator_data = dsi_phy_7nm_97800uA_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_7nm_97800uA_regulators),\n\t.ops = {\n\t\t.enable = dsi_7nm_phy_enable,\n\t\t.disable = dsi_7nm_phy_disable,\n\t\t.pll_init = dsi_pll_7nm_init,\n\t\t.save_pll_state = dsi_7nm_pll_save_state,\n\t\t.restore_pll_state = dsi_7nm_pll_restore_state,\n\t\t.set_continuous_clock = dsi_7nm_set_continuous_clock,\n\t},\n\t.min_pll_rate = 600000000UL,\n#ifdef CONFIG_64BIT\n\t.max_pll_rate = 5000000000UL,\n#else\n\t.max_pll_rate = ULONG_MAX,\n#endif\n\t.io_start = { 0xae94400, 0xae96400 },\n\t.num_dsi_phy = 2,\n\t.quirks = DSI_PHY_7NM_QUIRK_V4_3,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_4nm_8550_cfgs = {\n\t.has_phy_lane = true,\n\t.regulator_data = dsi_phy_7nm_98400uA_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_7nm_98400uA_regulators),\n\t.ops = {\n\t\t.enable = dsi_7nm_phy_enable,\n\t\t.disable = dsi_7nm_phy_disable,\n\t\t.pll_init = dsi_pll_7nm_init,\n\t\t.save_pll_state = dsi_7nm_pll_save_state,\n\t\t.restore_pll_state = dsi_7nm_pll_restore_state,\n\t\t.set_continuous_clock = dsi_7nm_set_continuous_clock,\n\t},\n\t.min_pll_rate = 600000000UL,\n#ifdef CONFIG_64BIT\n\t.max_pll_rate = 5000000000UL,\n#else\n\t.max_pll_rate = ULONG_MAX,\n#endif\n\t.io_start = { 0xae95000, 0xae97000 },\n\t.num_dsi_phy = 2,\n\t.quirks = DSI_PHY_7NM_QUIRK_V5_2,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}