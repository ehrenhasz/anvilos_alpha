{
  "module_name": "dsi_phy_14nm.c",
  "hash_id": "283e03e93e36b0fb7cead30fa52b57486974b61c1f23197bcd9e2a10c78a65df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dsi/phy/dsi_phy_14nm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n\n#include \"dsi_phy.h\"\n#include \"dsi.xml.h\"\n#include \"dsi_phy_14nm.xml.h\"\n\n#define PHY_14NM_CKLN_IDX\t4\n\n \n\n#define POLL_MAX_READS\t\t\t15\n#define POLL_TIMEOUT_US\t\t\t1000\n\n#define VCO_REF_CLK_RATE\t\t19200000\n#define VCO_MIN_RATE\t\t\t1300000000UL\n#define VCO_MAX_RATE\t\t\t2600000000UL\n\nstruct dsi_pll_config {\n\tu64 vco_current_rate;\n\n\tu32 ssc_en;\t \n\n\t \n\tu32 plllock_cnt;\n\tu32 ssc_center;\n\tu32 ssc_adj_period;\n\tu32 ssc_spread;\n\tu32 ssc_freq;\n\n\t \n\tu32 dec_start;\n\tu32 div_frac_start;\n\tu32 ssc_period;\n\tu32 ssc_step_size;\n\tu32 plllock_cmp;\n\tu32 pll_vco_div_ref;\n\tu32 pll_vco_count;\n\tu32 pll_kvco_div_ref;\n\tu32 pll_kvco_count;\n};\n\nstruct pll_14nm_cached_state {\n\tunsigned long vco_rate;\n\tu8 n2postdiv;\n\tu8 n1postdiv;\n};\n\nstruct dsi_pll_14nm {\n\tstruct clk_hw clk_hw;\n\n\tstruct msm_dsi_phy *phy;\n\n\t \n\tspinlock_t postdiv_lock;\n\n\tstruct pll_14nm_cached_state cached_state;\n\n\tstruct dsi_pll_14nm *slave;\n};\n\n#define to_pll_14nm(x)\tcontainer_of(x, struct dsi_pll_14nm, clk_hw)\n\n \nstruct dsi_pll_14nm_postdiv {\n\tstruct clk_hw hw;\n\n\t \n\tu8 shift;\n\tu8 width;\n\tu8 flags;  \n\n\tstruct dsi_pll_14nm *pll;\n};\n\n#define to_pll_14nm_postdiv(_hw) container_of(_hw, struct dsi_pll_14nm_postdiv, hw)\n\n \nstatic struct dsi_pll_14nm *pll_14nm_list[DSI_MAX];\n\nstatic bool pll_14nm_poll_for_ready(struct dsi_pll_14nm *pll_14nm,\n\t\t\t\t    u32 nb_tries, u32 timeout_us)\n{\n\tbool pll_locked = false, pll_ready = false;\n\tvoid __iomem *base = pll_14nm->phy->pll_base;\n\tu32 tries, val;\n\n\ttries = nb_tries;\n\twhile (tries--) {\n\t\tval = dsi_phy_read(base + REG_DSI_14nm_PHY_PLL_RESET_SM_READY_STATUS);\n\t\tpll_locked = !!(val & BIT(5));\n\n\t\tif (pll_locked)\n\t\t\tbreak;\n\n\t\tudelay(timeout_us);\n\t}\n\n\tif (!pll_locked)\n\t\tgoto out;\n\n\ttries = nb_tries;\n\twhile (tries--) {\n\t\tval = dsi_phy_read(base + REG_DSI_14nm_PHY_PLL_RESET_SM_READY_STATUS);\n\t\tpll_ready = !!(val & BIT(0));\n\n\t\tif (pll_ready)\n\t\t\tbreak;\n\n\t\tudelay(timeout_us);\n\t}\n\nout:\n\tDBG(\"DSI PLL is %slocked, %sready\", pll_locked ? \"\" : \"*not* \", pll_ready ? \"\" : \"*not* \");\n\n\treturn pll_locked && pll_ready;\n}\n\nstatic void dsi_pll_14nm_config_init(struct dsi_pll_config *pconf)\n{\n\t \n\tpconf->plllock_cnt = 1;\n\n\t \n\tpconf->ssc_en = 1;\n\tpconf->ssc_center = 0;\t\t \n\tpconf->ssc_spread = 5;\t\t \n\tpconf->ssc_freq = 31500;\t \n\tpconf->ssc_adj_period = 37;\n}\n\n#define CEIL(x, y)\t\t(((x) + ((y) - 1)) / (y))\n\nstatic void pll_14nm_ssc_calc(struct dsi_pll_14nm *pll, struct dsi_pll_config *pconf)\n{\n\tu32 period, ssc_period;\n\tu32 ref, rem;\n\tu64 step_size;\n\n\tDBG(\"vco=%lld ref=%d\", pconf->vco_current_rate, VCO_REF_CLK_RATE);\n\n\tssc_period = pconf->ssc_freq / 500;\n\tperiod = (u32)VCO_REF_CLK_RATE / 1000;\n\tssc_period  = CEIL(period, ssc_period);\n\tssc_period -= 1;\n\tpconf->ssc_period = ssc_period;\n\n\tDBG(\"ssc freq=%d spread=%d period=%d\", pconf->ssc_freq,\n\t    pconf->ssc_spread, pconf->ssc_period);\n\n\tstep_size = (u32)pconf->vco_current_rate;\n\tref = VCO_REF_CLK_RATE;\n\tref /= 1000;\n\tstep_size = div_u64(step_size, ref);\n\tstep_size <<= 20;\n\tstep_size = div_u64(step_size, 1000);\n\tstep_size *= pconf->ssc_spread;\n\tstep_size = div_u64(step_size, 1000);\n\tstep_size *= (pconf->ssc_adj_period + 1);\n\n\trem = 0;\n\tstep_size = div_u64_rem(step_size, ssc_period + 1, &rem);\n\tif (rem)\n\t\tstep_size++;\n\n\tDBG(\"step_size=%lld\", step_size);\n\n\tstep_size &= 0x0ffff;\t \n\n\tpconf->ssc_step_size = step_size;\n}\n\nstatic void pll_14nm_dec_frac_calc(struct dsi_pll_14nm *pll, struct dsi_pll_config *pconf)\n{\n\tu64 multiplier = BIT(20);\n\tu64 dec_start_multiple, dec_start, pll_comp_val;\n\tu32 duration, div_frac_start;\n\tu64 vco_clk_rate = pconf->vco_current_rate;\n\tu64 fref = VCO_REF_CLK_RATE;\n\n\tDBG(\"vco_clk_rate=%lld ref_clk_rate=%lld\", vco_clk_rate, fref);\n\n\tdec_start_multiple = div_u64(vco_clk_rate * multiplier, fref);\n\tdec_start = div_u64_rem(dec_start_multiple, multiplier, &div_frac_start);\n\n\tpconf->dec_start = (u32)dec_start;\n\tpconf->div_frac_start = div_frac_start;\n\n\tif (pconf->plllock_cnt == 0)\n\t\tduration = 1024;\n\telse if (pconf->plllock_cnt == 1)\n\t\tduration = 256;\n\telse if (pconf->plllock_cnt == 2)\n\t\tduration = 128;\n\telse\n\t\tduration = 32;\n\n\tpll_comp_val = duration * dec_start_multiple;\n\tpll_comp_val = div_u64(pll_comp_val, multiplier);\n\tdo_div(pll_comp_val, 10);\n\n\tpconf->plllock_cmp = (u32)pll_comp_val;\n}\n\nstatic u32 pll_14nm_kvco_slop(u32 vrate)\n{\n\tu32 slop = 0;\n\n\tif (vrate > VCO_MIN_RATE && vrate <= 1800000000UL)\n\t\tslop =  600;\n\telse if (vrate > 1800000000UL && vrate < 2300000000UL)\n\t\tslop = 400;\n\telse if (vrate > 2300000000UL && vrate < VCO_MAX_RATE)\n\t\tslop = 280;\n\n\treturn slop;\n}\n\nstatic void pll_14nm_calc_vco_count(struct dsi_pll_14nm *pll, struct dsi_pll_config *pconf)\n{\n\tu64 vco_clk_rate = pconf->vco_current_rate;\n\tu64 fref = VCO_REF_CLK_RATE;\n\tu32 vco_measure_time = 5;\n\tu32 kvco_measure_time = 5;\n\tu64 data;\n\tu32 cnt;\n\n\tdata = fref * vco_measure_time;\n\tdo_div(data, 1000000);\n\tdata &= 0x03ff;\t \n\tdata -= 2;\n\tpconf->pll_vco_div_ref = data;\n\n\tdata = div_u64(vco_clk_rate, 1000000);\t \n\tdata *= vco_measure_time;\n\tdo_div(data, 10);\n\tpconf->pll_vco_count = data;\n\n\tdata = fref * kvco_measure_time;\n\tdo_div(data, 1000000);\n\tdata &= 0x03ff;\t \n\tdata -= 1;\n\tpconf->pll_kvco_div_ref = data;\n\n\tcnt = pll_14nm_kvco_slop(vco_clk_rate);\n\tcnt *= 2;\n\tcnt /= 100;\n\tcnt *= kvco_measure_time;\n\tpconf->pll_kvco_count = cnt;\n}\n\nstatic void pll_db_commit_ssc(struct dsi_pll_14nm *pll, struct dsi_pll_config *pconf)\n{\n\tvoid __iomem *base = pll->phy->pll_base;\n\tu8 data;\n\n\tdata = pconf->ssc_adj_period;\n\tdata &= 0x0ff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_SSC_ADJ_PER1, data);\n\tdata = (pconf->ssc_adj_period >> 8);\n\tdata &= 0x03;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_SSC_ADJ_PER2, data);\n\n\tdata = pconf->ssc_period;\n\tdata &= 0x0ff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_SSC_PER1, data);\n\tdata = (pconf->ssc_period >> 8);\n\tdata &= 0x0ff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_SSC_PER2, data);\n\n\tdata = pconf->ssc_step_size;\n\tdata &= 0x0ff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_SSC_STEP_SIZE1, data);\n\tdata = (pconf->ssc_step_size >> 8);\n\tdata &= 0x0ff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_SSC_STEP_SIZE2, data);\n\n\tdata = (pconf->ssc_center & 0x01);\n\tdata <<= 1;\n\tdata |= 0x01;  \n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_SSC_EN_CENTER, data);\n\n\twmb();\t \n}\n\nstatic void pll_db_commit_common(struct dsi_pll_14nm *pll,\n\t\t\t\t struct dsi_pll_config *pconf)\n{\n\tvoid __iomem *base = pll->phy->pll_base;\n\tu8 data;\n\n\t \n\tdata = 0;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_SYSCLK_EN_RESET, data);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_TXCLK_EN, 1);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_RESETSM_CNTRL, 48);\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_RESETSM_CNTRL2, 4 << 3);  \n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_RESETSM_CNTRL5, 5);  \n\n\tdata = pconf->pll_vco_div_ref & 0xff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_VCO_DIV_REF1, data);\n\tdata = (pconf->pll_vco_div_ref >> 8) & 0x3;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_VCO_DIV_REF2, data);\n\n\tdata = pconf->pll_kvco_div_ref & 0xff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_KVCO_DIV_REF1, data);\n\tdata = (pconf->pll_kvco_div_ref >> 8) & 0x3;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_KVCO_DIV_REF2, data);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLL_MISC1, 16);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_IE_TRIM, 4);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_IP_TRIM, 4);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_CP_SET_CUR, 1 << 3 | 1);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLL_ICPCSET, 0 << 3 | 0);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLL_ICPMSET, 0 << 3 | 0);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLL_ICP_SET, 4 << 3 | 4);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLL_LPF1, 1 << 4 | 11);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_IPTAT_TRIM, 7);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLL_CRCTRL, 1 << 4 | 2);\n}\n\nstatic void pll_14nm_software_reset(struct dsi_pll_14nm *pll_14nm)\n{\n\tvoid __iomem *cmn_base = pll_14nm->phy->base;\n\n\t \n\n\t \n\tdsi_phy_write(cmn_base + REG_DSI_14nm_PHY_CMN_PLL_CNTRL, 0);\n\n\t \n\tdsi_phy_write_udelay(cmn_base + REG_DSI_14nm_PHY_CMN_CTRL_1, 0x20, 10);\n\twmb();\t \n\n\tdsi_phy_write(cmn_base + REG_DSI_14nm_PHY_CMN_CTRL_1, 0);\n\twmb();\t \n}\n\nstatic void pll_db_commit_14nm(struct dsi_pll_14nm *pll,\n\t\t\t       struct dsi_pll_config *pconf)\n{\n\tvoid __iomem *base = pll->phy->pll_base;\n\tvoid __iomem *cmn_base = pll->phy->base;\n\tu8 data;\n\n\tDBG(\"DSI%d PLL\", pll->phy->id);\n\n\tdsi_phy_write(cmn_base + REG_DSI_14nm_PHY_CMN_LDO_CNTRL, 0x3c);\n\n\tpll_db_commit_common(pll, pconf);\n\n\tpll_14nm_software_reset(pll);\n\n\t \n\tdsi_phy_write(cmn_base + REG_DSI_14nm_PHY_CMN_CLK_CFG1, 1);\n\n\tdata = 0xff;  \n\tdsi_phy_write(cmn_base + REG_DSI_14nm_PHY_CMN_CTRL_0, data);\n\n\t \n\tdata = pconf->dec_start;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_DEC_START, data);\n\n\tdata = pconf->div_frac_start & 0xff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_DIV_FRAC_START1, data);\n\tdata = (pconf->div_frac_start >> 8) & 0xff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_DIV_FRAC_START2, data);\n\tdata = (pconf->div_frac_start >> 16) & 0xf;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_DIV_FRAC_START3, data);\n\n\tdata = pconf->plllock_cmp & 0xff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLLLOCK_CMP1, data);\n\n\tdata = (pconf->plllock_cmp >> 8) & 0xff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLLLOCK_CMP2, data);\n\n\tdata = (pconf->plllock_cmp >> 16) & 0x3;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLLLOCK_CMP3, data);\n\n\tdata = pconf->plllock_cnt << 1 | 0 << 3;  \n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLLLOCK_CMP_EN, data);\n\n\tdata = pconf->pll_vco_count & 0xff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_VCO_COUNT1, data);\n\tdata = (pconf->pll_vco_count >> 8) & 0xff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_VCO_COUNT2, data);\n\n\tdata = pconf->pll_kvco_count & 0xff;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_KVCO_COUNT1, data);\n\tdata = (pconf->pll_kvco_count >> 8) & 0x3;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_KVCO_COUNT2, data);\n\n\t \n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLL_LPF2_POSTDIV, 0 << 4 | 3);\n\n\tif (pconf->ssc_en)\n\t\tpll_db_commit_ssc(pll, pconf);\n\n\twmb();\t \n}\n\n \nstatic int dsi_pll_14nm_vco_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct dsi_pll_14nm *pll_14nm = to_pll_14nm(hw);\n\tstruct dsi_pll_config conf;\n\n\tDBG(\"DSI PLL%d rate=%lu, parent's=%lu\", pll_14nm->phy->id, rate,\n\t    parent_rate);\n\n\tdsi_pll_14nm_config_init(&conf);\n\tconf.vco_current_rate = rate;\n\n\tpll_14nm_dec_frac_calc(pll_14nm, &conf);\n\n\tif (conf.ssc_en)\n\t\tpll_14nm_ssc_calc(pll_14nm, &conf);\n\n\tpll_14nm_calc_vco_count(pll_14nm, &conf);\n\n\t \n\tif (pll_14nm->phy->usecase == MSM_DSI_PHY_MASTER) {\n\t\tstruct dsi_pll_14nm *pll_14nm_slave = pll_14nm->slave;\n\n\t\tpll_db_commit_14nm(pll_14nm_slave, &conf);\n\t}\n\n\tpll_db_commit_14nm(pll_14nm, &conf);\n\n\treturn 0;\n}\n\nstatic unsigned long dsi_pll_14nm_vco_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct dsi_pll_14nm *pll_14nm = to_pll_14nm(hw);\n\tvoid __iomem *base = pll_14nm->phy->pll_base;\n\tu64 vco_rate, multiplier = BIT(20);\n\tu32 div_frac_start;\n\tu32 dec_start;\n\tu64 ref_clk = parent_rate;\n\n\tdec_start = dsi_phy_read(base + REG_DSI_14nm_PHY_PLL_DEC_START);\n\tdec_start &= 0x0ff;\n\n\tDBG(\"dec_start = %x\", dec_start);\n\n\tdiv_frac_start = (dsi_phy_read(base + REG_DSI_14nm_PHY_PLL_DIV_FRAC_START3)\n\t\t\t\t& 0xf) << 16;\n\tdiv_frac_start |= (dsi_phy_read(base + REG_DSI_14nm_PHY_PLL_DIV_FRAC_START2)\n\t\t\t\t& 0xff) << 8;\n\tdiv_frac_start |= dsi_phy_read(base + REG_DSI_14nm_PHY_PLL_DIV_FRAC_START1)\n\t\t\t\t& 0xff;\n\n\tDBG(\"div_frac_start = %x\", div_frac_start);\n\n\tvco_rate = ref_clk * dec_start;\n\n\tvco_rate += ((ref_clk * div_frac_start) / multiplier);\n\n\t \n\tvco_rate = DIV_ROUND_UP_ULL(vco_rate, 1000) * 1000;\n\n\tDBG(\"returning vco rate = %lu\", (unsigned long)vco_rate);\n\n\treturn (unsigned long)vco_rate;\n}\n\nstatic int dsi_pll_14nm_vco_prepare(struct clk_hw *hw)\n{\n\tstruct dsi_pll_14nm *pll_14nm = to_pll_14nm(hw);\n\tvoid __iomem *base = pll_14nm->phy->pll_base;\n\tvoid __iomem *cmn_base = pll_14nm->phy->base;\n\tbool locked;\n\n\tDBG(\"\");\n\n\tif (unlikely(pll_14nm->phy->pll_on))\n\t\treturn 0;\n\n\tif (dsi_pll_14nm_vco_recalc_rate(hw, VCO_REF_CLK_RATE) == 0)\n\t\tdsi_pll_14nm_vco_set_rate(hw, pll_14nm->phy->cfg->min_pll_rate, VCO_REF_CLK_RATE);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_VREF_CFG1, 0x10);\n\tdsi_phy_write(cmn_base + REG_DSI_14nm_PHY_CMN_PLL_CNTRL, 1);\n\n\tlocked = pll_14nm_poll_for_ready(pll_14nm, POLL_MAX_READS,\n\t\t\t\t\t POLL_TIMEOUT_US);\n\n\tif (unlikely(!locked)) {\n\t\tDRM_DEV_ERROR(&pll_14nm->phy->pdev->dev, \"DSI PLL lock failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDBG(\"DSI PLL lock success\");\n\tpll_14nm->phy->pll_on = true;\n\n\treturn 0;\n}\n\nstatic void dsi_pll_14nm_vco_unprepare(struct clk_hw *hw)\n{\n\tstruct dsi_pll_14nm *pll_14nm = to_pll_14nm(hw);\n\tvoid __iomem *cmn_base = pll_14nm->phy->base;\n\n\tDBG(\"\");\n\n\tif (unlikely(!pll_14nm->phy->pll_on))\n\t\treturn;\n\n\tdsi_phy_write(cmn_base + REG_DSI_14nm_PHY_CMN_PLL_CNTRL, 0);\n\n\tpll_14nm->phy->pll_on = false;\n}\n\nstatic long dsi_pll_14nm_clk_round_rate(struct clk_hw *hw,\n\t\tunsigned long rate, unsigned long *parent_rate)\n{\n\tstruct dsi_pll_14nm *pll_14nm = to_pll_14nm(hw);\n\n\tif      (rate < pll_14nm->phy->cfg->min_pll_rate)\n\t\treturn  pll_14nm->phy->cfg->min_pll_rate;\n\telse if (rate > pll_14nm->phy->cfg->max_pll_rate)\n\t\treturn  pll_14nm->phy->cfg->max_pll_rate;\n\telse\n\t\treturn rate;\n}\n\nstatic const struct clk_ops clk_ops_dsi_pll_14nm_vco = {\n\t.round_rate = dsi_pll_14nm_clk_round_rate,\n\t.set_rate = dsi_pll_14nm_vco_set_rate,\n\t.recalc_rate = dsi_pll_14nm_vco_recalc_rate,\n\t.prepare = dsi_pll_14nm_vco_prepare,\n\t.unprepare = dsi_pll_14nm_vco_unprepare,\n};\n\n \n#define div_mask(width)\t((1 << (width)) - 1)\nstatic unsigned long dsi_pll_14nm_postdiv_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct dsi_pll_14nm_postdiv *postdiv = to_pll_14nm_postdiv(hw);\n\tstruct dsi_pll_14nm *pll_14nm = postdiv->pll;\n\tvoid __iomem *base = pll_14nm->phy->base;\n\tu8 shift = postdiv->shift;\n\tu8 width = postdiv->width;\n\tu32 val;\n\n\tDBG(\"DSI%d PLL parent rate=%lu\", pll_14nm->phy->id, parent_rate);\n\n\tval = dsi_phy_read(base + REG_DSI_14nm_PHY_CMN_CLK_CFG0) >> shift;\n\tval &= div_mask(width);\n\n\treturn divider_recalc_rate(hw, parent_rate, val, NULL,\n\t\t\t\t   postdiv->flags, width);\n}\n\nstatic long dsi_pll_14nm_postdiv_round_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long rate,\n\t\t\t\t\t    unsigned long *prate)\n{\n\tstruct dsi_pll_14nm_postdiv *postdiv = to_pll_14nm_postdiv(hw);\n\tstruct dsi_pll_14nm *pll_14nm = postdiv->pll;\n\n\tDBG(\"DSI%d PLL parent rate=%lu\", pll_14nm->phy->id, rate);\n\n\treturn divider_round_rate(hw, rate, prate, NULL,\n\t\t\t\t  postdiv->width,\n\t\t\t\t  postdiv->flags);\n}\n\nstatic int dsi_pll_14nm_postdiv_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct dsi_pll_14nm_postdiv *postdiv = to_pll_14nm_postdiv(hw);\n\tstruct dsi_pll_14nm *pll_14nm = postdiv->pll;\n\tvoid __iomem *base = pll_14nm->phy->base;\n\tspinlock_t *lock = &pll_14nm->postdiv_lock;\n\tu8 shift = postdiv->shift;\n\tu8 width = postdiv->width;\n\tunsigned int value;\n\tunsigned long flags = 0;\n\tu32 val;\n\n\tDBG(\"DSI%d PLL parent rate=%lu parent rate %lu\", pll_14nm->phy->id, rate,\n\t    parent_rate);\n\n\tvalue = divider_get_val(rate, parent_rate, NULL, postdiv->width,\n\t\t\t\tpostdiv->flags);\n\n\tspin_lock_irqsave(lock, flags);\n\n\tval = dsi_phy_read(base + REG_DSI_14nm_PHY_CMN_CLK_CFG0);\n\tval &= ~(div_mask(width) << shift);\n\n\tval |= value << shift;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_CMN_CLK_CFG0, val);\n\n\t \n\tif (pll_14nm->phy->usecase == MSM_DSI_PHY_MASTER) {\n\t\tstruct dsi_pll_14nm *pll_14nm_slave = pll_14nm->slave;\n\t\tvoid __iomem *slave_base = pll_14nm_slave->phy->base;\n\n\t\tdsi_phy_write(slave_base + REG_DSI_14nm_PHY_CMN_CLK_CFG0, val);\n\t}\n\n\tspin_unlock_irqrestore(lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_ops_dsi_pll_14nm_postdiv = {\n\t.recalc_rate = dsi_pll_14nm_postdiv_recalc_rate,\n\t.round_rate = dsi_pll_14nm_postdiv_round_rate,\n\t.set_rate = dsi_pll_14nm_postdiv_set_rate,\n};\n\n \n\nstatic void dsi_14nm_pll_save_state(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_14nm *pll_14nm = to_pll_14nm(phy->vco_hw);\n\tstruct pll_14nm_cached_state *cached_state = &pll_14nm->cached_state;\n\tvoid __iomem *cmn_base = pll_14nm->phy->base;\n\tu32 data;\n\n\tdata = dsi_phy_read(cmn_base + REG_DSI_14nm_PHY_CMN_CLK_CFG0);\n\n\tcached_state->n1postdiv = data & 0xf;\n\tcached_state->n2postdiv = (data >> 4) & 0xf;\n\n\tDBG(\"DSI%d PLL save state %x %x\", pll_14nm->phy->id,\n\t    cached_state->n1postdiv, cached_state->n2postdiv);\n\n\tcached_state->vco_rate = clk_hw_get_rate(phy->vco_hw);\n}\n\nstatic int dsi_14nm_pll_restore_state(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_14nm *pll_14nm = to_pll_14nm(phy->vco_hw);\n\tstruct pll_14nm_cached_state *cached_state = &pll_14nm->cached_state;\n\tvoid __iomem *cmn_base = pll_14nm->phy->base;\n\tu32 data;\n\tint ret;\n\n\tret = dsi_pll_14nm_vco_set_rate(phy->vco_hw,\n\t\t\t\t\tcached_state->vco_rate, 0);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pll_14nm->phy->pdev->dev,\n\t\t\t      \"restore vco rate failed. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata = cached_state->n1postdiv | (cached_state->n2postdiv << 4);\n\n\tDBG(\"DSI%d PLL restore state %x %x\", pll_14nm->phy->id,\n\t    cached_state->n1postdiv, cached_state->n2postdiv);\n\n\tdsi_phy_write(cmn_base + REG_DSI_14nm_PHY_CMN_CLK_CFG0, data);\n\n\t \n\tif (phy->usecase == MSM_DSI_PHY_MASTER) {\n\t\tstruct dsi_pll_14nm *pll_14nm_slave = pll_14nm->slave;\n\t\tvoid __iomem *slave_base = pll_14nm_slave->phy->base;\n\n\t\tdsi_phy_write(slave_base + REG_DSI_14nm_PHY_CMN_CLK_CFG0, data);\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_14nm_set_usecase(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_14nm *pll_14nm = to_pll_14nm(phy->vco_hw);\n\tvoid __iomem *base = phy->pll_base;\n\tu32 clkbuflr_en, bandgap = 0;\n\n\tswitch (phy->usecase) {\n\tcase MSM_DSI_PHY_STANDALONE:\n\t\tclkbuflr_en = 0x1;\n\t\tbreak;\n\tcase MSM_DSI_PHY_MASTER:\n\t\tclkbuflr_en = 0x3;\n\t\tpll_14nm->slave = pll_14nm_list[(pll_14nm->phy->id + 1) % DSI_MAX];\n\t\tbreak;\n\tcase MSM_DSI_PHY_SLAVE:\n\t\tclkbuflr_en = 0x0;\n\t\tbandgap = 0x3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_CLKBUFLR_EN, clkbuflr_en);\n\tif (bandgap)\n\t\tdsi_phy_write(base + REG_DSI_14nm_PHY_PLL_PLL_BANDGAP, bandgap);\n\n\treturn 0;\n}\n\nstatic struct clk_hw *pll_14nm_postdiv_register(struct dsi_pll_14nm *pll_14nm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tconst struct clk_hw *parent_hw,\n\t\t\t\t\t\tunsigned long flags,\n\t\t\t\t\t\tu8 shift)\n{\n\tstruct dsi_pll_14nm_postdiv *pll_postdiv;\n\tstruct device *dev = &pll_14nm->phy->pdev->dev;\n\tstruct clk_init_data postdiv_init = {\n\t\t.parent_hws = (const struct clk_hw *[]) { parent_hw },\n\t\t.num_parents = 1,\n\t\t.name = name,\n\t\t.flags = flags,\n\t\t.ops = &clk_ops_dsi_pll_14nm_postdiv,\n\t};\n\tint ret;\n\n\tpll_postdiv = devm_kzalloc(dev, sizeof(*pll_postdiv), GFP_KERNEL);\n\tif (!pll_postdiv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll_postdiv->pll = pll_14nm;\n\tpll_postdiv->shift = shift;\n\t \n\tpll_postdiv->width = 4;\n\t \n\tpll_postdiv->flags = CLK_DIVIDER_ONE_BASED;\n\tpll_postdiv->hw.init = &postdiv_init;\n\n\tret = devm_clk_hw_register(dev, &pll_postdiv->hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn &pll_postdiv->hw;\n}\n\nstatic int pll_14nm_register(struct dsi_pll_14nm *pll_14nm, struct clk_hw **provided_clocks)\n{\n\tchar clk_name[32];\n\tstruct clk_init_data vco_init = {\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"ref\",\n\t\t},\n\t\t.num_parents = 1,\n\t\t.name = clk_name,\n\t\t.flags = CLK_IGNORE_UNUSED,\n\t\t.ops = &clk_ops_dsi_pll_14nm_vco,\n\t};\n\tstruct device *dev = &pll_14nm->phy->pdev->dev;\n\tstruct clk_hw *hw, *n1_postdiv, *n1_postdivby2;\n\tint ret;\n\n\tDBG(\"DSI%d\", pll_14nm->phy->id);\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dvco_clk\", pll_14nm->phy->id);\n\tpll_14nm->clk_hw.init = &vco_init;\n\n\tret = devm_clk_hw_register(dev, &pll_14nm->clk_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dn1_postdiv_clk\", pll_14nm->phy->id);\n\n\t \n\tn1_postdiv = pll_14nm_postdiv_register(pll_14nm, clk_name,\n\t\t\t&pll_14nm->clk_hw, CLK_SET_RATE_PARENT, 0);\n\tif (IS_ERR(n1_postdiv))\n\t\treturn PTR_ERR(n1_postdiv);\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dpllbyte\", pll_14nm->phy->id);\n\n\t \n\thw = devm_clk_hw_register_fixed_factor_parent_hw(dev, clk_name,\n\t\t\tn1_postdiv, CLK_SET_RATE_PARENT, 1, 8);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\tprovided_clocks[DSI_BYTE_PLL_CLK] = hw;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dn1_postdivby2_clk\", pll_14nm->phy->id);\n\n\t \n\tn1_postdivby2 = devm_clk_hw_register_fixed_factor_parent_hw(dev,\n\t\t\tclk_name, n1_postdiv, 0, 1, 2);\n\tif (IS_ERR(n1_postdivby2))\n\t\treturn PTR_ERR(n1_postdivby2);\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dpll\", pll_14nm->phy->id);\n\n\t \n\thw = pll_14nm_postdiv_register(pll_14nm, clk_name, n1_postdivby2,\n\t\t\t0, 4);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\tprovided_clocks[DSI_PIXEL_PLL_CLK] = hw;\n\n\treturn 0;\n}\n\nstatic int dsi_pll_14nm_init(struct msm_dsi_phy *phy)\n{\n\tstruct platform_device *pdev = phy->pdev;\n\tstruct dsi_pll_14nm *pll_14nm;\n\tint ret;\n\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tpll_14nm = devm_kzalloc(&pdev->dev, sizeof(*pll_14nm), GFP_KERNEL);\n\tif (!pll_14nm)\n\t\treturn -ENOMEM;\n\n\tDBG(\"PLL%d\", phy->id);\n\n\tpll_14nm_list[phy->id] = pll_14nm;\n\n\tspin_lock_init(&pll_14nm->postdiv_lock);\n\n\tpll_14nm->phy = phy;\n\n\tret = pll_14nm_register(pll_14nm, phy->provided_clocks->hws);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"failed to register PLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphy->vco_hw = &pll_14nm->clk_hw;\n\n\treturn 0;\n}\n\nstatic void dsi_14nm_dphy_set_timing(struct msm_dsi_phy *phy,\n\t\t\t\t     struct msm_dsi_dphy_timing *timing,\n\t\t\t\t     int lane_idx)\n{\n\tvoid __iomem *base = phy->lane_base;\n\tbool clk_ln = (lane_idx == PHY_14NM_CKLN_IDX);\n\tu32 zero = clk_ln ? timing->clk_zero : timing->hs_zero;\n\tu32 prepare = clk_ln ? timing->clk_prepare : timing->hs_prepare;\n\tu32 trail = clk_ln ? timing->clk_trail : timing->hs_trail;\n\tu32 rqst = clk_ln ? timing->hs_rqst_ckln : timing->hs_rqst;\n\tu32 prep_dly = clk_ln ? timing->hs_prep_dly_ckln : timing->hs_prep_dly;\n\tu32 halfbyte_en = clk_ln ? timing->hs_halfbyte_en_ckln :\n\t\t\t\t   timing->hs_halfbyte_en;\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_LN_TIMING_CTRL_4(lane_idx),\n\t\t      DSI_14nm_PHY_LN_TIMING_CTRL_4_HS_EXIT(timing->hs_exit));\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_LN_TIMING_CTRL_5(lane_idx),\n\t\t      DSI_14nm_PHY_LN_TIMING_CTRL_5_HS_ZERO(zero));\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_LN_TIMING_CTRL_6(lane_idx),\n\t\t      DSI_14nm_PHY_LN_TIMING_CTRL_6_HS_PREPARE(prepare));\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_LN_TIMING_CTRL_7(lane_idx),\n\t\t      DSI_14nm_PHY_LN_TIMING_CTRL_7_HS_TRAIL(trail));\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_LN_TIMING_CTRL_8(lane_idx),\n\t\t      DSI_14nm_PHY_LN_TIMING_CTRL_8_HS_RQST(rqst));\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_LN_CFG0(lane_idx),\n\t\t      DSI_14nm_PHY_LN_CFG0_PREPARE_DLY(prep_dly));\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_LN_CFG1(lane_idx),\n\t\t      halfbyte_en ? DSI_14nm_PHY_LN_CFG1_HALFBYTECLK_EN : 0);\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_LN_TIMING_CTRL_9(lane_idx),\n\t\t      DSI_14nm_PHY_LN_TIMING_CTRL_9_TA_GO(timing->ta_go) |\n\t\t      DSI_14nm_PHY_LN_TIMING_CTRL_9_TA_SURE(timing->ta_sure));\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_LN_TIMING_CTRL_10(lane_idx),\n\t\t      DSI_14nm_PHY_LN_TIMING_CTRL_10_TA_GET(timing->ta_get));\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_LN_TIMING_CTRL_11(lane_idx),\n\t\t      DSI_14nm_PHY_LN_TIMING_CTRL_11_TRIG3_CMD(0xa0));\n}\n\nstatic int dsi_14nm_phy_enable(struct msm_dsi_phy *phy,\n\t\t\t       struct msm_dsi_phy_clk_request *clk_req)\n{\n\tstruct msm_dsi_dphy_timing *timing = &phy->timing;\n\tu32 data;\n\tint i;\n\tint ret;\n\tvoid __iomem *base = phy->base;\n\tvoid __iomem *lane_base = phy->lane_base;\n\tu32 glbl_test_ctrl;\n\n\tif (msm_dsi_dphy_timing_calc_v2(timing, clk_req)) {\n\t\tDRM_DEV_ERROR(&phy->pdev->dev,\n\t\t\t      \"%s: D-PHY timing calculation failed\\n\",\n\t\t\t      __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = 0x1c;\n\tif (phy->usecase != MSM_DSI_PHY_STANDALONE)\n\t\tdata |= DSI_14nm_PHY_CMN_LDO_CNTRL_VREG_CTRL(32);\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_CMN_LDO_CNTRL, data);\n\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_CMN_GLBL_TEST_CTRL, 0x1);\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tdsi_phy_write(lane_base + REG_DSI_14nm_PHY_LN_VREG_CNTRL(i),\n\t\t\t      0x1d);\n\n\t\tdsi_phy_write(lane_base +\n\t\t\t      REG_DSI_14nm_PHY_LN_STRENGTH_CTRL_0(i), 0xff);\n\t\tdsi_phy_write(lane_base +\n\t\t\t      REG_DSI_14nm_PHY_LN_STRENGTH_CTRL_1(i),\n\t\t\t      (i == PHY_14NM_CKLN_IDX) ? 0x00 : 0x06);\n\n\t\tdsi_phy_write(lane_base + REG_DSI_14nm_PHY_LN_CFG3(i),\n\t\t\t      (i == PHY_14NM_CKLN_IDX) ? 0x8f : 0x0f);\n\t\tdsi_phy_write(lane_base + REG_DSI_14nm_PHY_LN_CFG2(i), 0x10);\n\t\tdsi_phy_write(lane_base + REG_DSI_14nm_PHY_LN_TEST_DATAPATH(i),\n\t\t\t      0);\n\t\tdsi_phy_write(lane_base + REG_DSI_14nm_PHY_LN_TEST_STR(i),\n\t\t\t      0x88);\n\n\t\tdsi_14nm_dphy_set_timing(phy, timing, i);\n\t}\n\n\t \n\tdsi_phy_write(base + REG_DSI_14nm_PHY_CMN_PLL_CNTRL, 0x00);\n\n\twmb();  \n\n\t \n\tdsi_phy_write(base + REG_DSI_14nm_PHY_CMN_CTRL_1, 0x80);\n\twmb();  \n\tudelay(100);\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_CMN_CTRL_1, 0x00);\n\n\tglbl_test_ctrl = dsi_phy_read(base + REG_DSI_14nm_PHY_CMN_GLBL_TEST_CTRL);\n\tif (phy->id == DSI_1 && phy->usecase == MSM_DSI_PHY_SLAVE)\n\t\tglbl_test_ctrl |= DSI_14nm_PHY_CMN_GLBL_TEST_CTRL_BITCLK_HS_SEL;\n\telse\n\t\tglbl_test_ctrl &= ~DSI_14nm_PHY_CMN_GLBL_TEST_CTRL_BITCLK_HS_SEL;\n\tdsi_phy_write(base + REG_DSI_14nm_PHY_CMN_GLBL_TEST_CTRL, glbl_test_ctrl);\n\tret = dsi_14nm_set_usecase(phy);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&phy->pdev->dev, \"%s: set pll usecase failed, %d\\n\",\n\t\t\t      __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdsi_phy_write(base + REG_DSI_14nm_PHY_CMN_CTRL_0, 0xff);\n\n\treturn 0;\n}\n\nstatic void dsi_14nm_phy_disable(struct msm_dsi_phy *phy)\n{\n\tdsi_phy_write(phy->base + REG_DSI_14nm_PHY_CMN_GLBL_TEST_CTRL, 0);\n\tdsi_phy_write(phy->base + REG_DSI_14nm_PHY_CMN_CTRL_0, 0);\n\n\t \n\twmb();\n}\n\nstatic const struct regulator_bulk_data dsi_phy_14nm_17mA_regulators[] = {\n\t{ .supply = \"vcca\", .init_load_uA = 17000 },\n};\n\nstatic const struct regulator_bulk_data dsi_phy_14nm_73p4mA_regulators[] = {\n\t{ .supply = \"vcca\", .init_load_uA = 73400 },\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_14nm_cfgs = {\n\t.has_phy_lane = true,\n\t.regulator_data = dsi_phy_14nm_17mA_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_14nm_17mA_regulators),\n\t.ops = {\n\t\t.enable = dsi_14nm_phy_enable,\n\t\t.disable = dsi_14nm_phy_disable,\n\t\t.pll_init = dsi_pll_14nm_init,\n\t\t.save_pll_state = dsi_14nm_pll_save_state,\n\t\t.restore_pll_state = dsi_14nm_pll_restore_state,\n\t},\n\t.min_pll_rate = VCO_MIN_RATE,\n\t.max_pll_rate = VCO_MAX_RATE,\n\t.io_start = { 0x994400, 0x996400 },\n\t.num_dsi_phy = 2,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_14nm_660_cfgs = {\n\t.has_phy_lane = true,\n\t.regulator_data = dsi_phy_14nm_73p4mA_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_14nm_73p4mA_regulators),\n\t.ops = {\n\t\t.enable = dsi_14nm_phy_enable,\n\t\t.disable = dsi_14nm_phy_disable,\n\t\t.pll_init = dsi_pll_14nm_init,\n\t\t.save_pll_state = dsi_14nm_pll_save_state,\n\t\t.restore_pll_state = dsi_14nm_pll_restore_state,\n\t},\n\t.min_pll_rate = VCO_MIN_RATE,\n\t.max_pll_rate = VCO_MAX_RATE,\n\t.io_start = { 0xc994400, 0xc996400 },\n\t.num_dsi_phy = 2,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_14nm_8953_cfgs = {\n\t.has_phy_lane = true,\n\t.regulator_data = dsi_phy_14nm_17mA_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_14nm_17mA_regulators),\n\t.ops = {\n\t\t.enable = dsi_14nm_phy_enable,\n\t\t.disable = dsi_14nm_phy_disable,\n\t\t.pll_init = dsi_pll_14nm_init,\n\t\t.save_pll_state = dsi_14nm_pll_save_state,\n\t\t.restore_pll_state = dsi_14nm_pll_restore_state,\n\t},\n\t.min_pll_rate = VCO_MIN_RATE,\n\t.max_pll_rate = VCO_MAX_RATE,\n\t.io_start = { 0x1a94400, 0x1a96400 },\n\t.num_dsi_phy = 2,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_14nm_2290_cfgs = {\n\t.has_phy_lane = true,\n\t.ops = {\n\t\t.enable = dsi_14nm_phy_enable,\n\t\t.disable = dsi_14nm_phy_disable,\n\t\t.pll_init = dsi_pll_14nm_init,\n\t\t.save_pll_state = dsi_14nm_pll_save_state,\n\t\t.restore_pll_state = dsi_14nm_pll_restore_state,\n\t},\n\t.min_pll_rate = VCO_MIN_RATE,\n\t.max_pll_rate = VCO_MAX_RATE,\n\t.io_start = { 0x5e94400 },\n\t.num_dsi_phy = 1,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}