{
  "module_name": "dsi_phy_10nm.c",
  "hash_id": "f66bf93449699c8ec0e0001a9103ae0551075786d9321e36665611b7cb02fcb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dsi/phy/dsi_phy_10nm.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/iopoll.h>\n\n#include \"dsi_phy.h\"\n#include \"dsi.xml.h\"\n#include \"dsi_phy_10nm.xml.h\"\n\n \n\n#define VCO_REF_CLK_RATE\t\t19200000\n#define FRAC_BITS 18\n\n \n#define DSI_PHY_10NM_QUIRK_OLD_TIMINGS\tBIT(0)\n\nstruct dsi_pll_config {\n\tbool enable_ssc;\n\tbool ssc_center;\n\tu32 ssc_freq;\n\tu32 ssc_offset;\n\tu32 ssc_adj_per;\n\n\t \n\tu32 pll_prop_gain_rate;\n\tu32 decimal_div_start;\n\tu32 frac_div_start;\n\tu32 pll_clock_inverters;\n\tu32 ssc_stepsize;\n\tu32 ssc_div_per;\n};\n\nstruct pll_10nm_cached_state {\n\tunsigned long vco_rate;\n\tu8 bit_clk_div;\n\tu8 pix_clk_div;\n\tu8 pll_out_div;\n\tu8 pll_mux;\n};\n\nstruct dsi_pll_10nm {\n\tstruct clk_hw clk_hw;\n\n\tstruct msm_dsi_phy *phy;\n\n\tu64 vco_current_rate;\n\n\t \n\tspinlock_t postdiv_lock;\n\n\tstruct pll_10nm_cached_state cached_state;\n\n\tstruct dsi_pll_10nm *slave;\n};\n\n#define to_pll_10nm(x)\tcontainer_of(x, struct dsi_pll_10nm, clk_hw)\n\n \nstruct dsi_phy_10nm_tuning_cfg {\n\tu8 rescode_offset_top[DSI_LANE_MAX];\n\tu8 rescode_offset_bot[DSI_LANE_MAX];\n\tu8 vreg_ctrl;\n};\n\n \nstatic struct dsi_pll_10nm *pll_10nm_list[DSI_MAX];\n\nstatic void dsi_pll_setup_config(struct dsi_pll_config *config)\n{\n\tconfig->ssc_freq = 31500;\n\tconfig->ssc_offset = 5000;\n\tconfig->ssc_adj_per = 2;\n\n\tconfig->enable_ssc = false;\n\tconfig->ssc_center = false;\n}\n\nstatic void dsi_pll_calc_dec_frac(struct dsi_pll_10nm *pll, struct dsi_pll_config *config)\n{\n\tu64 fref = VCO_REF_CLK_RATE;\n\tu64 pll_freq;\n\tu64 divider;\n\tu64 dec, dec_multiple;\n\tu32 frac;\n\tu64 multiplier;\n\n\tpll_freq = pll->vco_current_rate;\n\n\tdivider = fref * 2;\n\n\tmultiplier = 1 << FRAC_BITS;\n\tdec_multiple = div_u64(pll_freq * multiplier, divider);\n\tdec = div_u64_rem(dec_multiple, multiplier, &frac);\n\n\tif (pll_freq <= 1900000000UL)\n\t\tconfig->pll_prop_gain_rate = 8;\n\telse if (pll_freq <= 3000000000UL)\n\t\tconfig->pll_prop_gain_rate = 10;\n\telse\n\t\tconfig->pll_prop_gain_rate = 12;\n\tif (pll_freq < 1100000000UL)\n\t\tconfig->pll_clock_inverters = 8;\n\telse\n\t\tconfig->pll_clock_inverters = 0;\n\n\tconfig->decimal_div_start = dec;\n\tconfig->frac_div_start = frac;\n}\n\n#define SSC_CENTER\t\tBIT(0)\n#define SSC_EN\t\t\tBIT(1)\n\nstatic void dsi_pll_calc_ssc(struct dsi_pll_10nm *pll, struct dsi_pll_config *config)\n{\n\tu32 ssc_per;\n\tu32 ssc_mod;\n\tu64 ssc_step_size;\n\tu64 frac;\n\n\tif (!config->enable_ssc) {\n\t\tDBG(\"SSC not enabled\\n\");\n\t\treturn;\n\t}\n\n\tssc_per = DIV_ROUND_CLOSEST(VCO_REF_CLK_RATE, config->ssc_freq) / 2 - 1;\n\tssc_mod = (ssc_per + 1) % (config->ssc_adj_per + 1);\n\tssc_per -= ssc_mod;\n\n\tfrac = config->frac_div_start;\n\tssc_step_size = config->decimal_div_start;\n\tssc_step_size *= (1 << FRAC_BITS);\n\tssc_step_size += frac;\n\tssc_step_size *= config->ssc_offset;\n\tssc_step_size *= (config->ssc_adj_per + 1);\n\tssc_step_size = div_u64(ssc_step_size, (ssc_per + 1));\n\tssc_step_size = DIV_ROUND_CLOSEST_ULL(ssc_step_size, 1000000);\n\n\tconfig->ssc_div_per = ssc_per;\n\tconfig->ssc_stepsize = ssc_step_size;\n\n\tpr_debug(\"SCC: Dec:%d, frac:%llu, frac_bits:%d\\n\",\n\t\t config->decimal_div_start, frac, FRAC_BITS);\n\tpr_debug(\"SSC: div_per:0x%X, stepsize:0x%X, adjper:0x%X\\n\",\n\t\t ssc_per, (u32)ssc_step_size, config->ssc_adj_per);\n}\n\nstatic void dsi_pll_ssc_commit(struct dsi_pll_10nm *pll, struct dsi_pll_config *config)\n{\n\tvoid __iomem *base = pll->phy->pll_base;\n\n\tif (config->enable_ssc) {\n\t\tpr_debug(\"SSC is enabled\\n\");\n\n\t\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_SSC_STEPSIZE_LOW_1,\n\t\t\t      config->ssc_stepsize & 0xff);\n\t\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_SSC_STEPSIZE_HIGH_1,\n\t\t\t      config->ssc_stepsize >> 8);\n\t\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_SSC_DIV_PER_LOW_1,\n\t\t\t      config->ssc_div_per & 0xff);\n\t\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_SSC_DIV_PER_HIGH_1,\n\t\t\t      config->ssc_div_per >> 8);\n\t\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_SSC_DIV_ADJPER_LOW_1,\n\t\t\t      config->ssc_adj_per & 0xff);\n\t\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_SSC_DIV_ADJPER_HIGH_1,\n\t\t\t      config->ssc_adj_per >> 8);\n\t\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_SSC_CONTROL,\n\t\t\t      SSC_EN | (config->ssc_center ? SSC_CENTER : 0));\n\t}\n}\n\nstatic void dsi_pll_config_hzindep_reg(struct dsi_pll_10nm *pll)\n{\n\tvoid __iomem *base = pll->phy->pll_base;\n\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_ANALOG_CONTROLS_ONE, 0x80);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_ANALOG_CONTROLS_TWO, 0x03);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_ANALOG_CONTROLS_THREE, 0x00);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_DSM_DIVIDER, 0x00);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_FEEDBACK_DIVIDER, 0x4e);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_CALIBRATION_SETTINGS, 0x40);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_BAND_SEL_CAL_SETTINGS_THREE,\n\t\t      0xba);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_FREQ_DETECT_SETTINGS_ONE,\n\t\t      0x0c);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_OUTDIV, 0x00);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_CORE_OVERRIDE, 0x00);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_PLL_DIGITAL_TIMERS_TWO,\n\t\t      0x08);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_PLL_PROP_GAIN_RATE_1, 0x08);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_PLL_BAND_SET_RATE_1, 0xc0);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_PLL_INT_GAIN_IFILT_BAND_1,\n\t\t      0xfa);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_PLL_FL_INT_GAIN_PFILT_BAND_1,\n\t\t      0x4c);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_PLL_LOCK_OVERRIDE, 0x80);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_PFILT, 0x29);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_IFILT, 0x3f);\n}\n\nstatic void dsi_pll_commit(struct dsi_pll_10nm *pll, struct dsi_pll_config *config)\n{\n\tvoid __iomem *base = pll->phy->pll_base;\n\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_CORE_INPUT_OVERRIDE, 0x12);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_DECIMAL_DIV_START_1,\n\t\t      config->decimal_div_start);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_FRAC_DIV_START_LOW_1,\n\t\t      config->frac_div_start & 0xff);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_FRAC_DIV_START_MID_1,\n\t\t      (config->frac_div_start & 0xff00) >> 8);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_FRAC_DIV_START_HIGH_1,\n\t\t      (config->frac_div_start & 0x30000) >> 16);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_PLL_LOCKDET_RATE_1, 64);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_PLL_LOCK_DELAY, 0x06);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_CMODE, 0x10);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_PLL_CLOCK_INVERTERS,\n\t\t      config->pll_clock_inverters);\n}\n\nstatic int dsi_pll_10nm_vco_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct dsi_pll_10nm *pll_10nm = to_pll_10nm(hw);\n\tstruct dsi_pll_config config;\n\n\tDBG(\"DSI PLL%d rate=%lu, parent's=%lu\", pll_10nm->phy->id, rate,\n\t    parent_rate);\n\n\tpll_10nm->vco_current_rate = rate;\n\n\tdsi_pll_setup_config(&config);\n\n\tdsi_pll_calc_dec_frac(pll_10nm, &config);\n\n\tdsi_pll_calc_ssc(pll_10nm, &config);\n\n\tdsi_pll_commit(pll_10nm, &config);\n\n\tdsi_pll_config_hzindep_reg(pll_10nm);\n\n\tdsi_pll_ssc_commit(pll_10nm, &config);\n\n\t \n\twmb();\n\n\treturn 0;\n}\n\nstatic int dsi_pll_10nm_lock_status(struct dsi_pll_10nm *pll)\n{\n\tstruct device *dev = &pll->phy->pdev->dev;\n\tint rc;\n\tu32 status = 0;\n\tu32 const delay_us = 100;\n\tu32 const timeout_us = 5000;\n\n\trc = readl_poll_timeout_atomic(pll->phy->pll_base +\n\t\t\t\t       REG_DSI_10nm_PHY_PLL_COMMON_STATUS_ONE,\n\t\t\t\t       status,\n\t\t\t\t       ((status & BIT(0)) > 0),\n\t\t\t\t       delay_us,\n\t\t\t\t       timeout_us);\n\tif (rc)\n\t\tDRM_DEV_ERROR(dev, \"DSI PLL(%d) lock failed, status=0x%08x\\n\",\n\t\t\t      pll->phy->id, status);\n\n\treturn rc;\n}\n\nstatic void dsi_pll_disable_pll_bias(struct dsi_pll_10nm *pll)\n{\n\tu32 data = dsi_phy_read(pll->phy->base + REG_DSI_10nm_PHY_CMN_CTRL_0);\n\n\tdsi_phy_write(pll->phy->pll_base + REG_DSI_10nm_PHY_PLL_SYSTEM_MUXES, 0);\n\tdsi_phy_write(pll->phy->base + REG_DSI_10nm_PHY_CMN_CTRL_0,\n\t\t      data & ~BIT(5));\n\tndelay(250);\n}\n\nstatic void dsi_pll_enable_pll_bias(struct dsi_pll_10nm *pll)\n{\n\tu32 data = dsi_phy_read(pll->phy->base + REG_DSI_10nm_PHY_CMN_CTRL_0);\n\n\tdsi_phy_write(pll->phy->base + REG_DSI_10nm_PHY_CMN_CTRL_0,\n\t\t      data | BIT(5));\n\tdsi_phy_write(pll->phy->pll_base + REG_DSI_10nm_PHY_PLL_SYSTEM_MUXES, 0xc0);\n\tndelay(250);\n}\n\nstatic void dsi_pll_disable_global_clk(struct dsi_pll_10nm *pll)\n{\n\tu32 data;\n\n\tdata = dsi_phy_read(pll->phy->base + REG_DSI_10nm_PHY_CMN_CLK_CFG1);\n\tdsi_phy_write(pll->phy->base + REG_DSI_10nm_PHY_CMN_CLK_CFG1,\n\t\t      data & ~BIT(5));\n}\n\nstatic void dsi_pll_enable_global_clk(struct dsi_pll_10nm *pll)\n{\n\tu32 data;\n\n\tdata = dsi_phy_read(pll->phy->base + REG_DSI_10nm_PHY_CMN_CLK_CFG1);\n\tdsi_phy_write(pll->phy->base + REG_DSI_10nm_PHY_CMN_CLK_CFG1,\n\t\t      data | BIT(5));\n}\n\nstatic int dsi_pll_10nm_vco_prepare(struct clk_hw *hw)\n{\n\tstruct dsi_pll_10nm *pll_10nm = to_pll_10nm(hw);\n\tstruct device *dev = &pll_10nm->phy->pdev->dev;\n\tint rc;\n\n\tdsi_pll_enable_pll_bias(pll_10nm);\n\tif (pll_10nm->slave)\n\t\tdsi_pll_enable_pll_bias(pll_10nm->slave);\n\n\trc = dsi_pll_10nm_vco_set_rate(hw,pll_10nm->vco_current_rate, 0);\n\tif (rc) {\n\t\tDRM_DEV_ERROR(dev, \"vco_set_rate failed, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tdsi_phy_write(pll_10nm->phy->base + REG_DSI_10nm_PHY_CMN_PLL_CNTRL,\n\t\t      0x01);\n\n\t \n\twmb();\n\n\t \n\trc = dsi_pll_10nm_lock_status(pll_10nm);\n\tif (rc) {\n\t\tDRM_DEV_ERROR(dev, \"PLL(%d) lock failed\\n\", pll_10nm->phy->id);\n\t\tgoto error;\n\t}\n\n\tpll_10nm->phy->pll_on = true;\n\n\tdsi_pll_enable_global_clk(pll_10nm);\n\tif (pll_10nm->slave)\n\t\tdsi_pll_enable_global_clk(pll_10nm->slave);\n\n\tdsi_phy_write(pll_10nm->phy->base + REG_DSI_10nm_PHY_CMN_RBUF_CTRL,\n\t\t      0x01);\n\tif (pll_10nm->slave)\n\t\tdsi_phy_write(pll_10nm->slave->phy->base +\n\t\t\t      REG_DSI_10nm_PHY_CMN_RBUF_CTRL, 0x01);\n\nerror:\n\treturn rc;\n}\n\nstatic void dsi_pll_disable_sub(struct dsi_pll_10nm *pll)\n{\n\tdsi_phy_write(pll->phy->base + REG_DSI_10nm_PHY_CMN_RBUF_CTRL, 0);\n\tdsi_pll_disable_pll_bias(pll);\n}\n\nstatic void dsi_pll_10nm_vco_unprepare(struct clk_hw *hw)\n{\n\tstruct dsi_pll_10nm *pll_10nm = to_pll_10nm(hw);\n\n\t \n\tdsi_pll_disable_global_clk(pll_10nm);\n\tdsi_phy_write(pll_10nm->phy->base + REG_DSI_10nm_PHY_CMN_PLL_CNTRL, 0);\n\tdsi_pll_disable_sub(pll_10nm);\n\tif (pll_10nm->slave) {\n\t\tdsi_pll_disable_global_clk(pll_10nm->slave);\n\t\tdsi_pll_disable_sub(pll_10nm->slave);\n\t}\n\t \n\twmb();\n\tpll_10nm->phy->pll_on = false;\n}\n\nstatic unsigned long dsi_pll_10nm_vco_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct dsi_pll_10nm *pll_10nm = to_pll_10nm(hw);\n\tvoid __iomem *base = pll_10nm->phy->pll_base;\n\tu64 ref_clk = VCO_REF_CLK_RATE;\n\tu64 vco_rate = 0x0;\n\tu64 multiplier;\n\tu32 frac;\n\tu32 dec;\n\tu64 pll_freq, tmp64;\n\n\tdec = dsi_phy_read(base + REG_DSI_10nm_PHY_PLL_DECIMAL_DIV_START_1);\n\tdec &= 0xff;\n\n\tfrac = dsi_phy_read(base + REG_DSI_10nm_PHY_PLL_FRAC_DIV_START_LOW_1);\n\tfrac |= ((dsi_phy_read(base + REG_DSI_10nm_PHY_PLL_FRAC_DIV_START_MID_1) &\n\t\t  0xff) << 8);\n\tfrac |= ((dsi_phy_read(base + REG_DSI_10nm_PHY_PLL_FRAC_DIV_START_HIGH_1) &\n\t\t  0x3) << 16);\n\n\t \n\tmultiplier = 1 << FRAC_BITS;\n\tpll_freq = dec * (ref_clk * 2);\n\ttmp64 = (ref_clk * 2 * frac);\n\tpll_freq += div_u64(tmp64, multiplier);\n\n\tvco_rate = pll_freq;\n\tpll_10nm->vco_current_rate = vco_rate;\n\n\tDBG(\"DSI PLL%d returning vco rate = %lu, dec = %x, frac = %x\",\n\t    pll_10nm->phy->id, (unsigned long)vco_rate, dec, frac);\n\n\treturn (unsigned long)vco_rate;\n}\n\nstatic long dsi_pll_10nm_clk_round_rate(struct clk_hw *hw,\n\t\tunsigned long rate, unsigned long *parent_rate)\n{\n\tstruct dsi_pll_10nm *pll_10nm = to_pll_10nm(hw);\n\n\tif      (rate < pll_10nm->phy->cfg->min_pll_rate)\n\t\treturn  pll_10nm->phy->cfg->min_pll_rate;\n\telse if (rate > pll_10nm->phy->cfg->max_pll_rate)\n\t\treturn  pll_10nm->phy->cfg->max_pll_rate;\n\telse\n\t\treturn rate;\n}\n\nstatic const struct clk_ops clk_ops_dsi_pll_10nm_vco = {\n\t.round_rate = dsi_pll_10nm_clk_round_rate,\n\t.set_rate = dsi_pll_10nm_vco_set_rate,\n\t.recalc_rate = dsi_pll_10nm_vco_recalc_rate,\n\t.prepare = dsi_pll_10nm_vco_prepare,\n\t.unprepare = dsi_pll_10nm_vco_unprepare,\n};\n\n \n\nstatic void dsi_10nm_pll_save_state(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_10nm *pll_10nm = to_pll_10nm(phy->vco_hw);\n\tstruct pll_10nm_cached_state *cached = &pll_10nm->cached_state;\n\tvoid __iomem *phy_base = pll_10nm->phy->base;\n\tu32 cmn_clk_cfg0, cmn_clk_cfg1;\n\n\tcached->pll_out_div = dsi_phy_read(pll_10nm->phy->pll_base +\n\t\t\tREG_DSI_10nm_PHY_PLL_PLL_OUTDIV_RATE);\n\tcached->pll_out_div &= 0x3;\n\n\tcmn_clk_cfg0 = dsi_phy_read(phy_base + REG_DSI_10nm_PHY_CMN_CLK_CFG0);\n\tcached->bit_clk_div = cmn_clk_cfg0 & 0xf;\n\tcached->pix_clk_div = (cmn_clk_cfg0 & 0xf0) >> 4;\n\n\tcmn_clk_cfg1 = dsi_phy_read(phy_base + REG_DSI_10nm_PHY_CMN_CLK_CFG1);\n\tcached->pll_mux = cmn_clk_cfg1 & 0x3;\n\n\tDBG(\"DSI PLL%d outdiv %x bit_clk_div %x pix_clk_div %x pll_mux %x\",\n\t    pll_10nm->phy->id, cached->pll_out_div, cached->bit_clk_div,\n\t    cached->pix_clk_div, cached->pll_mux);\n}\n\nstatic int dsi_10nm_pll_restore_state(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_10nm *pll_10nm = to_pll_10nm(phy->vco_hw);\n\tstruct pll_10nm_cached_state *cached = &pll_10nm->cached_state;\n\tvoid __iomem *phy_base = pll_10nm->phy->base;\n\tu32 val;\n\tint ret;\n\n\tval = dsi_phy_read(pll_10nm->phy->pll_base + REG_DSI_10nm_PHY_PLL_PLL_OUTDIV_RATE);\n\tval &= ~0x3;\n\tval |= cached->pll_out_div;\n\tdsi_phy_write(pll_10nm->phy->pll_base + REG_DSI_10nm_PHY_PLL_PLL_OUTDIV_RATE, val);\n\n\tdsi_phy_write(phy_base + REG_DSI_10nm_PHY_CMN_CLK_CFG0,\n\t\t      cached->bit_clk_div | (cached->pix_clk_div << 4));\n\n\tval = dsi_phy_read(phy_base + REG_DSI_10nm_PHY_CMN_CLK_CFG1);\n\tval &= ~0x3;\n\tval |= cached->pll_mux;\n\tdsi_phy_write(phy_base + REG_DSI_10nm_PHY_CMN_CLK_CFG1, val);\n\n\tret = dsi_pll_10nm_vco_set_rate(phy->vco_hw,\n\t\t\tpll_10nm->vco_current_rate,\n\t\t\tVCO_REF_CLK_RATE);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pll_10nm->phy->pdev->dev,\n\t\t\t\"restore vco rate failed. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tDBG(\"DSI PLL%d\", pll_10nm->phy->id);\n\n\treturn 0;\n}\n\nstatic int dsi_10nm_set_usecase(struct msm_dsi_phy *phy)\n{\n\tstruct dsi_pll_10nm *pll_10nm = to_pll_10nm(phy->vco_hw);\n\tvoid __iomem *base = phy->base;\n\tu32 data = 0x0;\t \n\n\tDBG(\"DSI PLL%d\", pll_10nm->phy->id);\n\n\tswitch (phy->usecase) {\n\tcase MSM_DSI_PHY_STANDALONE:\n\t\tbreak;\n\tcase MSM_DSI_PHY_MASTER:\n\t\tpll_10nm->slave = pll_10nm_list[(pll_10nm->phy->id + 1) % DSI_MAX];\n\t\tbreak;\n\tcase MSM_DSI_PHY_SLAVE:\n\t\tdata = 0x1;  \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_CLK_CFG1, (data << 2));\n\n\treturn 0;\n}\n\n \nstatic int pll_10nm_register(struct dsi_pll_10nm *pll_10nm, struct clk_hw **provided_clocks)\n{\n\tchar clk_name[32];\n\tstruct clk_init_data vco_init = {\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"ref\",\n\t\t},\n\t\t.num_parents = 1,\n\t\t.name = clk_name,\n\t\t.flags = CLK_IGNORE_UNUSED,\n\t\t.ops = &clk_ops_dsi_pll_10nm_vco,\n\t};\n\tstruct device *dev = &pll_10nm->phy->pdev->dev;\n\tstruct clk_hw *hw, *pll_out_div, *pll_bit, *pll_by_2_bit;\n\tstruct clk_hw *pll_post_out_div, *pclk_mux;\n\tint ret;\n\n\tDBG(\"DSI%d\", pll_10nm->phy->id);\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%dvco_clk\", pll_10nm->phy->id);\n\tpll_10nm->clk_hw.init = &vco_init;\n\n\tret = devm_clk_hw_register(dev, &pll_10nm->clk_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_pll_out_div_clk\", pll_10nm->phy->id);\n\n\tpll_out_div = devm_clk_hw_register_divider_parent_hw(dev, clk_name,\n\t\t\t&pll_10nm->clk_hw, CLK_SET_RATE_PARENT,\n\t\t\tpll_10nm->phy->pll_base +\n\t\t\t\tREG_DSI_10nm_PHY_PLL_PLL_OUTDIV_RATE,\n\t\t\t0, 2, CLK_DIVIDER_POWER_OF_TWO, NULL);\n\tif (IS_ERR(pll_out_div)) {\n\t\tret = PTR_ERR(pll_out_div);\n\t\tgoto fail;\n\t}\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_pll_bit_clk\", pll_10nm->phy->id);\n\n\t \n\tpll_bit = devm_clk_hw_register_divider_parent_hw(dev, clk_name,\n\t\t\tpll_out_div, CLK_SET_RATE_PARENT,\n\t\t\tpll_10nm->phy->base + REG_DSI_10nm_PHY_CMN_CLK_CFG0,\n\t\t\t0, 4, CLK_DIVIDER_ONE_BASED, &pll_10nm->postdiv_lock);\n\tif (IS_ERR(pll_bit)) {\n\t\tret = PTR_ERR(pll_bit);\n\t\tgoto fail;\n\t}\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_phy_pll_out_byteclk\", pll_10nm->phy->id);\n\n\t \n\thw = devm_clk_hw_register_fixed_factor_parent_hw(dev, clk_name,\n\t\t\tpll_bit, CLK_SET_RATE_PARENT, 1, 8);\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto fail;\n\t}\n\n\tprovided_clocks[DSI_BYTE_PLL_CLK] = hw;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_pll_by_2_bit_clk\", pll_10nm->phy->id);\n\n\tpll_by_2_bit = devm_clk_hw_register_fixed_factor_parent_hw(dev,\n\t\t\tclk_name, pll_bit, 0, 1, 2);\n\tif (IS_ERR(pll_by_2_bit)) {\n\t\tret = PTR_ERR(pll_by_2_bit);\n\t\tgoto fail;\n\t}\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_pll_post_out_div_clk\", pll_10nm->phy->id);\n\n\tpll_post_out_div = devm_clk_hw_register_fixed_factor_parent_hw(dev,\n\t\t\tclk_name, pll_out_div, 0, 1, 4);\n\tif (IS_ERR(pll_post_out_div)) {\n\t\tret = PTR_ERR(pll_post_out_div);\n\t\tgoto fail;\n\t}\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_pclk_mux\", pll_10nm->phy->id);\n\n\tpclk_mux = devm_clk_hw_register_mux_parent_hws(dev, clk_name,\n\t\t\t((const struct clk_hw *[]){\n\t\t\t\tpll_bit,\n\t\t\t\tpll_by_2_bit,\n\t\t\t\tpll_out_div,\n\t\t\t\tpll_post_out_div,\n\t\t\t}), 4, 0, pll_10nm->phy->base +\n\t\t\t\tREG_DSI_10nm_PHY_CMN_CLK_CFG1, 0, 2, 0, NULL);\n\tif (IS_ERR(pclk_mux)) {\n\t\tret = PTR_ERR(pclk_mux);\n\t\tgoto fail;\n\t}\n\n\tsnprintf(clk_name, sizeof(clk_name), \"dsi%d_phy_pll_out_dsiclk\", pll_10nm->phy->id);\n\n\t \n\thw = devm_clk_hw_register_divider_parent_hw(dev, clk_name, pclk_mux,\n\t\t\t0, pll_10nm->phy->base + REG_DSI_10nm_PHY_CMN_CLK_CFG0,\n\t\t\t4, 4, CLK_DIVIDER_ONE_BASED, &pll_10nm->postdiv_lock);\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto fail;\n\t}\n\n\tprovided_clocks[DSI_PIXEL_PLL_CLK] = hw;\n\n\treturn 0;\n\nfail:\n\n\treturn ret;\n}\n\nstatic int dsi_pll_10nm_init(struct msm_dsi_phy *phy)\n{\n\tstruct platform_device *pdev = phy->pdev;\n\tstruct dsi_pll_10nm *pll_10nm;\n\tint ret;\n\n\tpll_10nm = devm_kzalloc(&pdev->dev, sizeof(*pll_10nm), GFP_KERNEL);\n\tif (!pll_10nm)\n\t\treturn -ENOMEM;\n\n\tDBG(\"DSI PLL%d\", phy->id);\n\n\tpll_10nm_list[phy->id] = pll_10nm;\n\n\tspin_lock_init(&pll_10nm->postdiv_lock);\n\n\tpll_10nm->phy = phy;\n\n\tret = pll_10nm_register(pll_10nm, phy->provided_clocks->hws);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"failed to register PLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphy->vco_hw = &pll_10nm->clk_hw;\n\n\t \n\tmsm_dsi_phy_pll_save_state(phy);\n\n\treturn 0;\n}\n\nstatic int dsi_phy_hw_v3_0_is_pll_on(struct msm_dsi_phy *phy)\n{\n\tvoid __iomem *base = phy->base;\n\tu32 data = 0;\n\n\tdata = dsi_phy_read(base + REG_DSI_10nm_PHY_CMN_PLL_CNTRL);\n\tmb();  \n\n\treturn (data & BIT(0));\n}\n\nstatic void dsi_phy_hw_v3_0_config_lpcdrx(struct msm_dsi_phy *phy, bool enable)\n{\n\tvoid __iomem *lane_base = phy->lane_base;\n\tint phy_lane_0 = 0;\t \n\n\t \n\tif (enable)\n\t\tdsi_phy_write(lane_base +\n\t\t\t      REG_DSI_10nm_PHY_LN_LPRX_CTRL(phy_lane_0), 0x3);\n\telse\n\t\tdsi_phy_write(lane_base +\n\t\t\t      REG_DSI_10nm_PHY_LN_LPRX_CTRL(phy_lane_0), 0);\n}\n\nstatic void dsi_phy_hw_v3_0_lane_settings(struct msm_dsi_phy *phy)\n{\n\tint i;\n\tu8 tx_dctrl[] = { 0x00, 0x00, 0x00, 0x04, 0x01 };\n\tvoid __iomem *lane_base = phy->lane_base;\n\tstruct dsi_phy_10nm_tuning_cfg *tuning_cfg = phy->tuning_cfg;\n\n\tif (phy->cfg->quirks & DSI_PHY_10NM_QUIRK_OLD_TIMINGS)\n\t\ttx_dctrl[3] = 0x02;\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_LPTX_STR_CTRL(i),\n\t\t\t      0x55);\n\t\t \n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_LPRX_CTRL(i), 0);\n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_PIN_SWAP(i), 0x0);\n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_HSTX_STR_CTRL(i),\n\t\t\t      0x88);\n\t}\n\n\tdsi_phy_hw_v3_0_config_lpcdrx(phy, true);\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_CFG0(i), 0x0);\n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_CFG1(i), 0x0);\n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_CFG2(i), 0x0);\n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_CFG3(i),\n\t\t\t      i == 4 ? 0x80 : 0x0);\n\n\t\t \n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_OFFSET_TOP_CTRL(i),\n\t\t\t\ttuning_cfg->rescode_offset_top[i]);\n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_OFFSET_BOT_CTRL(i),\n\t\t\t\ttuning_cfg->rescode_offset_bot[i]);\n\n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_TX_DCTRL(i),\n\t\t\t      tx_dctrl[i]);\n\t}\n\n\tif (!(phy->cfg->quirks & DSI_PHY_10NM_QUIRK_OLD_TIMINGS)) {\n\t\t \n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_TX_DCTRL(3), 0x05);\n\t\tdsi_phy_write(lane_base + REG_DSI_10nm_PHY_LN_TX_DCTRL(3), 0x04);\n\t}\n}\n\nstatic int dsi_10nm_phy_enable(struct msm_dsi_phy *phy,\n\t\t\t       struct msm_dsi_phy_clk_request *clk_req)\n{\n\tint ret;\n\tu32 status;\n\tu32 const delay_us = 5;\n\tu32 const timeout_us = 1000;\n\tstruct msm_dsi_dphy_timing *timing = &phy->timing;\n\tvoid __iomem *base = phy->base;\n\tstruct dsi_phy_10nm_tuning_cfg *tuning_cfg = phy->tuning_cfg;\n\tu32 data;\n\n\tDBG(\"\");\n\n\tif (msm_dsi_dphy_timing_calc_v3(timing, clk_req)) {\n\t\tDRM_DEV_ERROR(&phy->pdev->dev,\n\t\t\t\"%s: D-PHY timing calculation failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dsi_phy_hw_v3_0_is_pll_on(phy))\n\t\tpr_warn(\"PLL turned on before configuring PHY\\n\");\n\n\t \n\tret = readl_poll_timeout_atomic(base + REG_DSI_10nm_PHY_CMN_PHY_STATUS,\n\t\t\t\t\tstatus, (status & BIT(0)),\n\t\t\t\t\tdelay_us, timeout_us);\n\tif (ret) {\n\t\tpr_err(\"Ref gen not ready. Aborting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdata = BIT(6) | BIT(5);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_CTRL_0, data);\n\n\t \n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_PLL_CNTRL, 0x00);\n\n\t \n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_RBUF_CTRL, 0x00);\n\n\t \n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_GLBL_CTRL, 0x10);\n\n\t \n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_VREG_CTRL,\n\t\t      tuning_cfg->vreg_ctrl);\n\n\t \n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_LANE_CFG0, 0x21);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_LANE_CFG1, 0x84);\n\n\t \n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_0,\n\t\t      timing->hs_halfbyte_en);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_1,\n\t\t      timing->clk_zero);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_2,\n\t\t      timing->clk_prepare);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_3,\n\t\t      timing->clk_trail);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_4,\n\t\t      timing->hs_exit);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_5,\n\t\t      timing->hs_zero);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_6,\n\t\t      timing->hs_prepare);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_7,\n\t\t      timing->hs_trail);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_8,\n\t\t      timing->hs_rqst);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_9,\n\t\t      timing->ta_go | (timing->ta_sure << 3));\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_10,\n\t\t      timing->ta_get);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_TIMING_CTRL_11,\n\t\t      0x00);\n\n\t \n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_CTRL_0, 0x7f);\n\n\t \n\tdata = dsi_phy_read(base + REG_DSI_10nm_PHY_CMN_CTRL_0);\n\n\t \n\tdata |= 0x1F;\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_CTRL_0, data);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_LANE_CTRL0, 0x1F);\n\n\t \n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_CTRL_2, 0x40);\n\n\tret = dsi_10nm_set_usecase(phy);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&phy->pdev->dev, \"%s: set pll usecase failed, %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdsi_phy_hw_v3_0_lane_settings(phy);\n\n\tDBG(\"DSI%d PHY enabled\", phy->id);\n\n\treturn 0;\n}\n\nstatic void dsi_10nm_phy_disable(struct msm_dsi_phy *phy)\n{\n\tvoid __iomem *base = phy->base;\n\tu32 data;\n\n\tDBG(\"\");\n\n\tif (dsi_phy_hw_v3_0_is_pll_on(phy))\n\t\tpr_warn(\"Turning OFF PHY while PLL is on\\n\");\n\n\tdsi_phy_hw_v3_0_config_lpcdrx(phy, false);\n\tdata = dsi_phy_read(base + REG_DSI_10nm_PHY_CMN_CTRL_0);\n\n\t \n\tdata &= ~0x1F;\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_CTRL_0, data);\n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_LANE_CTRL0, 0);\n\n\t \n\tdsi_phy_write(base + REG_DSI_10nm_PHY_CMN_CTRL_0, 0x00);\n\t \n\twmb();\n\n\tDBG(\"DSI%d PHY disabled\", phy->id);\n}\n\nstatic int dsi_10nm_phy_parse_dt(struct msm_dsi_phy *phy)\n{\n\tstruct device *dev = &phy->pdev->dev;\n\tstruct dsi_phy_10nm_tuning_cfg *tuning_cfg;\n\ts8 offset_top[DSI_LANE_MAX] = { 0 };  \n\ts8 offset_bot[DSI_LANE_MAX] = { 0 };  \n\tu32 ldo_level = 400;  \n\tu8 level;\n\tint ret, i;\n\n\ttuning_cfg = devm_kzalloc(dev, sizeof(*tuning_cfg), GFP_KERNEL);\n\tif (!tuning_cfg)\n\t\treturn -ENOMEM;\n\n\t \n\tret = of_property_read_u8_array(dev->of_node, \"qcom,phy-rescode-offset-top\",\n\t\t\t\t\toffset_top, DSI_LANE_MAX);\n\tif (ret && ret != -EINVAL) {\n\t\tDRM_DEV_ERROR(dev, \"failed to parse qcom,phy-rescode-offset-top, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < DSI_LANE_MAX; i++) {\n\t\tif (offset_top[i] < -32 || offset_top[i] > 31) {\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t\"qcom,phy-rescode-offset-top value %d is not in range [-32..31]\\n\",\n\t\t\t\toffset_top[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttuning_cfg->rescode_offset_top[i] = 0x3f & offset_top[i];\n\t}\n\n\tret = of_property_read_u8_array(dev->of_node, \"qcom,phy-rescode-offset-bot\",\n\t\t\t\t\toffset_bot, DSI_LANE_MAX);\n\tif (ret && ret != -EINVAL) {\n\t\tDRM_DEV_ERROR(dev, \"failed to parse qcom,phy-rescode-offset-bot, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < DSI_LANE_MAX; i++) {\n\t\tif (offset_bot[i] < -32 || offset_bot[i] > 31) {\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t\"qcom,phy-rescode-offset-bot value %d is not in range [-32..31]\\n\",\n\t\t\t\toffset_bot[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttuning_cfg->rescode_offset_bot[i] = 0x3f & offset_bot[i];\n\t}\n\n\t \n\tret = of_property_read_u32(dev->of_node, \"qcom,phy-drive-ldo-level\", &ldo_level);\n\tif (ret && ret != -EINVAL) {\n\t\tDRM_DEV_ERROR(dev, \"failed to parse qcom,phy-drive-ldo-level, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (ldo_level) {\n\tcase 375:\n\t\tlevel = 0;\n\t\tbreak;\n\tcase 400:\n\t\tlevel = 1;\n\t\tbreak;\n\tcase 425:\n\t\tlevel = 2;\n\t\tbreak;\n\tcase 450:\n\t\tlevel = 3;\n\t\tbreak;\n\tcase 475:\n\t\tlevel = 4;\n\t\tbreak;\n\tcase 500:\n\t\tlevel = 5;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEV_ERROR(dev, \"qcom,phy-drive-ldo-level %d is not supported\\n\", ldo_level);\n\t\treturn -EINVAL;\n\t}\n\ttuning_cfg->vreg_ctrl = 0x58 | (0x7 & level);\n\n\tphy->tuning_cfg = tuning_cfg;\n\n\treturn 0;\n}\n\nstatic const struct regulator_bulk_data dsi_phy_10nm_regulators[] = {\n\t{ .supply = \"vdds\", .init_load_uA = 36000 },\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_10nm_cfgs = {\n\t.has_phy_lane = true,\n\t.regulator_data = dsi_phy_10nm_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_10nm_regulators),\n\t.ops = {\n\t\t.enable = dsi_10nm_phy_enable,\n\t\t.disable = dsi_10nm_phy_disable,\n\t\t.pll_init = dsi_pll_10nm_init,\n\t\t.save_pll_state = dsi_10nm_pll_save_state,\n\t\t.restore_pll_state = dsi_10nm_pll_restore_state,\n\t\t.parse_dt_properties = dsi_10nm_phy_parse_dt,\n\t},\n\t.min_pll_rate = 1000000000UL,\n\t.max_pll_rate = 3500000000UL,\n\t.io_start = { 0xae94400, 0xae96400 },\n\t.num_dsi_phy = 2,\n};\n\nconst struct msm_dsi_phy_cfg dsi_phy_10nm_8998_cfgs = {\n\t.has_phy_lane = true,\n\t.regulator_data = dsi_phy_10nm_regulators,\n\t.num_regulators = ARRAY_SIZE(dsi_phy_10nm_regulators),\n\t.ops = {\n\t\t.enable = dsi_10nm_phy_enable,\n\t\t.disable = dsi_10nm_phy_disable,\n\t\t.pll_init = dsi_pll_10nm_init,\n\t\t.save_pll_state = dsi_10nm_pll_save_state,\n\t\t.restore_pll_state = dsi_10nm_pll_restore_state,\n\t\t.parse_dt_properties = dsi_10nm_phy_parse_dt,\n\t},\n\t.min_pll_rate = 1000000000UL,\n\t.max_pll_rate = 3500000000UL,\n\t.io_start = { 0xc994400, 0xc996400 },\n\t.num_dsi_phy = 2,\n\t.quirks = DSI_PHY_10NM_QUIRK_OLD_TIMINGS,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}