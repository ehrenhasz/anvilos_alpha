{
  "module_name": "dsi_host.c",
  "hash_id": "ce94852a119f9be4965858e398142d76cf61967d6ae4896cf51a697bd852607a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/dsi/dsi_host.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/of_irq.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_opp.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spinlock.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/display/drm_dsc_helper.h>\n#include <drm/drm_of.h>\n\n#include \"dsi.h\"\n#include \"dsi.xml.h\"\n#include \"sfpb.xml.h\"\n#include \"dsi_cfg.h\"\n#include \"msm_dsc_helper.h\"\n#include \"msm_kms.h\"\n#include \"msm_gem.h\"\n#include \"phy/dsi_phy.h\"\n\n#define DSI_RESET_TOGGLE_DELAY_MS 20\n\nstatic int dsi_populate_dsc_params(struct msm_dsi_host *msm_host, struct drm_dsc_config *dsc);\n\nstatic int dsi_get_version(const void __iomem *base, u32 *major, u32 *minor)\n{\n\tu32 ver;\n\n\tif (!major || !minor)\n\t\treturn -EINVAL;\n\n\t \n\n\tver = msm_readl(base + REG_DSI_VERSION);\n\tif (ver) {\n\t\t \n\t\tver = FIELD(ver, DSI_VERSION_MAJOR);\n\t\tif (ver <= MSM_DSI_VER_MAJOR_V2) {\n\t\t\t \n\t\t\t*major = ver;\n\t\t\t*minor = 0;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tver = msm_readl(base + DSI_6G_REG_SHIFT + REG_DSI_VERSION);\n\t\tver = FIELD(ver, DSI_VERSION_MAJOR);\n\t\tif (ver == MSM_DSI_VER_MAJOR_6G) {\n\t\t\t \n\t\t\t*major = ver;\n\t\t\t*minor = msm_readl(base + REG_DSI_6G_HW_VERSION);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n}\n\n#define DSI_ERR_STATE_ACK\t\t\t0x0000\n#define DSI_ERR_STATE_TIMEOUT\t\t\t0x0001\n#define DSI_ERR_STATE_DLN0_PHY\t\t\t0x0002\n#define DSI_ERR_STATE_FIFO\t\t\t0x0004\n#define DSI_ERR_STATE_MDP_FIFO_UNDERFLOW\t0x0008\n#define DSI_ERR_STATE_INTERLEAVE_OP_CONTENTION\t0x0010\n#define DSI_ERR_STATE_PLL_UNLOCKED\t\t0x0020\n\n#define DSI_CLK_CTRL_ENABLE_CLKS\t\\\n\t\t(DSI_CLK_CTRL_AHBS_HCLK_ON | DSI_CLK_CTRL_AHBM_SCLK_ON | \\\n\t\tDSI_CLK_CTRL_PCLK_ON | DSI_CLK_CTRL_DSICLK_ON | \\\n\t\tDSI_CLK_CTRL_BYTECLK_ON | DSI_CLK_CTRL_ESCCLK_ON | \\\n\t\tDSI_CLK_CTRL_FORCE_ON_DYN_AHBM_HCLK)\n\nstruct msm_dsi_host {\n\tstruct mipi_dsi_host base;\n\n\tstruct platform_device *pdev;\n\tstruct drm_device *dev;\n\n\tint id;\n\n\tvoid __iomem *ctrl_base;\n\tphys_addr_t ctrl_size;\n\tstruct regulator_bulk_data *supplies;\n\n\tint num_bus_clks;\n\tstruct clk_bulk_data bus_clks[DSI_BUS_CLK_MAX];\n\n\tstruct clk *byte_clk;\n\tstruct clk *esc_clk;\n\tstruct clk *pixel_clk;\n\tstruct clk *byte_intf_clk;\n\n\tunsigned long byte_clk_rate;\n\tunsigned long byte_intf_clk_rate;\n\tunsigned long pixel_clk_rate;\n\tunsigned long esc_clk_rate;\n\n\t \n\tstruct clk *src_clk;\n\n\tunsigned long src_clk_rate;\n\n\tstruct gpio_desc *disp_en_gpio;\n\tstruct gpio_desc *te_gpio;\n\n\tconst struct msm_dsi_cfg_handler *cfg_hnd;\n\n\tstruct completion dma_comp;\n\tstruct completion video_comp;\n\tstruct mutex dev_mutex;\n\tstruct mutex cmd_mutex;\n\tspinlock_t intr_lock;  \n\n\tu32 err_work_state;\n\tstruct work_struct err_work;\n\tstruct workqueue_struct *workqueue;\n\n\t \n\tstruct drm_gem_object *tx_gem_obj;\n\tstruct msm_gem_address_space *aspace;\n\n\t \n\tvoid *tx_buf;\n\tdma_addr_t tx_buf_paddr;\n\n\tint tx_size;\n\n\tu8 *rx_buf;\n\n\tstruct regmap *sfpb;\n\n\tstruct drm_display_mode *mode;\n\tstruct drm_dsc_config *dsc;\n\n\t \n\tunsigned int channel;\n\tunsigned int lanes;\n\tenum mipi_dsi_pixel_format format;\n\tunsigned long mode_flags;\n\n\t \n\tint dlane_swap;\n\tint num_data_lanes;\n\n\t \n\tbool cphy_mode;\n\n\tu32 dma_cmd_ctrl_restore;\n\n\tbool registered;\n\tbool power_on;\n\tbool enabled;\n\tint irq;\n};\n\nstatic u32 dsi_get_bpp(const enum mipi_dsi_pixel_format fmt)\n{\n\tswitch (fmt) {\n\tcase MIPI_DSI_FMT_RGB565:\t\treturn 16;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\treturn 18;\n\tcase MIPI_DSI_FMT_RGB666:\n\tcase MIPI_DSI_FMT_RGB888:\n\tdefault:\t\t\t\treturn 24;\n\t}\n}\n\nstatic inline u32 dsi_read(struct msm_dsi_host *msm_host, u32 reg)\n{\n\treturn msm_readl(msm_host->ctrl_base + reg);\n}\nstatic inline void dsi_write(struct msm_dsi_host *msm_host, u32 reg, u32 data)\n{\n\tmsm_writel(data, msm_host->ctrl_base + reg);\n}\n\nstatic const struct msm_dsi_cfg_handler *dsi_get_config(\n\t\t\t\t\t\tstruct msm_dsi_host *msm_host)\n{\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = NULL;\n\tstruct device *dev = &msm_host->pdev->dev;\n\tstruct clk *ahb_clk;\n\tint ret;\n\tu32 major = 0, minor = 0;\n\n\tahb_clk = msm_clk_get(msm_host->pdev, \"iface\");\n\tif (IS_ERR(ahb_clk)) {\n\t\tpr_err(\"%s: cannot get interface clock\\n\", __func__);\n\t\tgoto exit;\n\t}\n\n\tpm_runtime_get_sync(dev);\n\n\tret = clk_prepare_enable(ahb_clk);\n\tif (ret) {\n\t\tpr_err(\"%s: unable to enable ahb_clk\\n\", __func__);\n\t\tgoto runtime_put;\n\t}\n\n\tret = dsi_get_version(msm_host->ctrl_base, &major, &minor);\n\tif (ret) {\n\t\tpr_err(\"%s: Invalid version\\n\", __func__);\n\t\tgoto disable_clks;\n\t}\n\n\tcfg_hnd = msm_dsi_cfg_get(major, minor);\n\n\tDBG(\"%s: Version %x:%x\\n\", __func__, major, minor);\n\ndisable_clks:\n\tclk_disable_unprepare(ahb_clk);\nruntime_put:\n\tpm_runtime_put_sync(dev);\nexit:\n\treturn cfg_hnd;\n}\n\nstatic inline struct msm_dsi_host *to_msm_dsi_host(struct mipi_dsi_host *host)\n{\n\treturn container_of(host, struct msm_dsi_host, base);\n}\n\nint dsi_clk_init_v2(struct msm_dsi_host *msm_host)\n{\n\tstruct platform_device *pdev = msm_host->pdev;\n\tint ret = 0;\n\n\tmsm_host->src_clk = msm_clk_get(pdev, \"src\");\n\n\tif (IS_ERR(msm_host->src_clk)) {\n\t\tret = PTR_ERR(msm_host->src_clk);\n\t\tpr_err(\"%s: can't find src clock. ret=%d\\n\",\n\t\t\t__func__, ret);\n\t\tmsm_host->src_clk = NULL;\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint dsi_clk_init_6g_v2(struct msm_dsi_host *msm_host)\n{\n\tstruct platform_device *pdev = msm_host->pdev;\n\tint ret = 0;\n\n\tmsm_host->byte_intf_clk = msm_clk_get(pdev, \"byte_intf\");\n\tif (IS_ERR(msm_host->byte_intf_clk)) {\n\t\tret = PTR_ERR(msm_host->byte_intf_clk);\n\t\tpr_err(\"%s: can't find byte_intf clock. ret=%d\\n\",\n\t\t\t__func__, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int dsi_clk_init(struct msm_dsi_host *msm_host)\n{\n\tstruct platform_device *pdev = msm_host->pdev;\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;\n\tconst struct msm_dsi_config *cfg = cfg_hnd->cfg;\n\tint i, ret = 0;\n\n\t \n\tfor (i = 0; i < cfg->num_bus_clks; i++)\n\t\tmsm_host->bus_clks[i].id = cfg->bus_clk_names[i];\n\tmsm_host->num_bus_clks = cfg->num_bus_clks;\n\n\tret = devm_clk_bulk_get(&pdev->dev, msm_host->num_bus_clks, msm_host->bus_clks);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Unable to get clocks, ret = %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\t \n\tmsm_host->byte_clk = msm_clk_get(pdev, \"byte\");\n\tif (IS_ERR(msm_host->byte_clk)) {\n\t\tret = PTR_ERR(msm_host->byte_clk);\n\t\tpr_err(\"%s: can't find dsi_byte clock. ret=%d\\n\",\n\t\t\t__func__, ret);\n\t\tmsm_host->byte_clk = NULL;\n\t\tgoto exit;\n\t}\n\n\tmsm_host->pixel_clk = msm_clk_get(pdev, \"pixel\");\n\tif (IS_ERR(msm_host->pixel_clk)) {\n\t\tret = PTR_ERR(msm_host->pixel_clk);\n\t\tpr_err(\"%s: can't find dsi_pixel clock. ret=%d\\n\",\n\t\t\t__func__, ret);\n\t\tmsm_host->pixel_clk = NULL;\n\t\tgoto exit;\n\t}\n\n\tmsm_host->esc_clk = msm_clk_get(pdev, \"core\");\n\tif (IS_ERR(msm_host->esc_clk)) {\n\t\tret = PTR_ERR(msm_host->esc_clk);\n\t\tpr_err(\"%s: can't find dsi_esc clock. ret=%d\\n\",\n\t\t\t__func__, ret);\n\t\tmsm_host->esc_clk = NULL;\n\t\tgoto exit;\n\t}\n\n\tif (cfg_hnd->ops->clk_init_ver)\n\t\tret = cfg_hnd->ops->clk_init_ver(msm_host);\nexit:\n\treturn ret;\n}\n\nint msm_dsi_runtime_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct msm_dsi *msm_dsi = platform_get_drvdata(pdev);\n\tstruct mipi_dsi_host *host = msm_dsi->host;\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tif (!msm_host->cfg_hnd)\n\t\treturn 0;\n\n\tclk_bulk_disable_unprepare(msm_host->num_bus_clks, msm_host->bus_clks);\n\n\treturn 0;\n}\n\nint msm_dsi_runtime_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct msm_dsi *msm_dsi = platform_get_drvdata(pdev);\n\tstruct mipi_dsi_host *host = msm_dsi->host;\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tif (!msm_host->cfg_hnd)\n\t\treturn 0;\n\n\treturn clk_bulk_prepare_enable(msm_host->num_bus_clks, msm_host->bus_clks);\n}\n\nint dsi_link_clk_set_rate_6g(struct msm_dsi_host *msm_host)\n{\n\tint ret;\n\n\tDBG(\"Set clk rates: pclk=%d, byteclk=%lu\",\n\t\tmsm_host->mode->clock, msm_host->byte_clk_rate);\n\n\tret = dev_pm_opp_set_rate(&msm_host->pdev->dev,\n\t\t\t\t  msm_host->byte_clk_rate);\n\tif (ret) {\n\t\tpr_err(\"%s: dev_pm_opp_set_rate failed %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_set_rate(msm_host->pixel_clk, msm_host->pixel_clk_rate);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to set rate pixel clk, %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tif (msm_host->byte_intf_clk) {\n\t\tret = clk_set_rate(msm_host->byte_intf_clk, msm_host->byte_intf_clk_rate);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: Failed to set rate byte intf clk, %d\\n\",\n\t\t\t       __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nint dsi_link_clk_enable_6g(struct msm_dsi_host *msm_host)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(msm_host->esc_clk);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to enable dsi esc clk\\n\", __func__);\n\t\tgoto error;\n\t}\n\n\tret = clk_prepare_enable(msm_host->byte_clk);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to enable dsi byte clk\\n\", __func__);\n\t\tgoto byte_clk_err;\n\t}\n\n\tret = clk_prepare_enable(msm_host->pixel_clk);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to enable dsi pixel clk\\n\", __func__);\n\t\tgoto pixel_clk_err;\n\t}\n\n\tret = clk_prepare_enable(msm_host->byte_intf_clk);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to enable byte intf clk\\n\",\n\t\t\t   __func__);\n\t\tgoto byte_intf_clk_err;\n\t}\n\n\treturn 0;\n\nbyte_intf_clk_err:\n\tclk_disable_unprepare(msm_host->pixel_clk);\npixel_clk_err:\n\tclk_disable_unprepare(msm_host->byte_clk);\nbyte_clk_err:\n\tclk_disable_unprepare(msm_host->esc_clk);\nerror:\n\treturn ret;\n}\n\nint dsi_link_clk_set_rate_v2(struct msm_dsi_host *msm_host)\n{\n\tint ret;\n\n\tDBG(\"Set clk rates: pclk=%d, byteclk=%lu, esc_clk=%lu, dsi_src_clk=%lu\",\n\t\tmsm_host->mode->clock, msm_host->byte_clk_rate,\n\t\tmsm_host->esc_clk_rate, msm_host->src_clk_rate);\n\n\tret = clk_set_rate(msm_host->byte_clk, msm_host->byte_clk_rate);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to set rate byte clk, %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_set_rate(msm_host->esc_clk, msm_host->esc_clk_rate);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to set rate esc clk, %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_set_rate(msm_host->src_clk, msm_host->src_clk_rate);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to set rate src clk, %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_set_rate(msm_host->pixel_clk, msm_host->pixel_clk_rate);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to set rate pixel clk, %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint dsi_link_clk_enable_v2(struct msm_dsi_host *msm_host)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(msm_host->byte_clk);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to enable dsi byte clk\\n\", __func__);\n\t\tgoto error;\n\t}\n\n\tret = clk_prepare_enable(msm_host->esc_clk);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to enable dsi esc clk\\n\", __func__);\n\t\tgoto esc_clk_err;\n\t}\n\n\tret = clk_prepare_enable(msm_host->src_clk);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to enable dsi src clk\\n\", __func__);\n\t\tgoto src_clk_err;\n\t}\n\n\tret = clk_prepare_enable(msm_host->pixel_clk);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to enable dsi pixel clk\\n\", __func__);\n\t\tgoto pixel_clk_err;\n\t}\n\n\treturn 0;\n\npixel_clk_err:\n\tclk_disable_unprepare(msm_host->src_clk);\nsrc_clk_err:\n\tclk_disable_unprepare(msm_host->esc_clk);\nesc_clk_err:\n\tclk_disable_unprepare(msm_host->byte_clk);\nerror:\n\treturn ret;\n}\n\nvoid dsi_link_clk_disable_6g(struct msm_dsi_host *msm_host)\n{\n\t \n\tdev_pm_opp_set_rate(&msm_host->pdev->dev, 0);\n\tclk_disable_unprepare(msm_host->esc_clk);\n\tclk_disable_unprepare(msm_host->pixel_clk);\n\tclk_disable_unprepare(msm_host->byte_intf_clk);\n\tclk_disable_unprepare(msm_host->byte_clk);\n}\n\nvoid dsi_link_clk_disable_v2(struct msm_dsi_host *msm_host)\n{\n\tclk_disable_unprepare(msm_host->pixel_clk);\n\tclk_disable_unprepare(msm_host->src_clk);\n\tclk_disable_unprepare(msm_host->esc_clk);\n\tclk_disable_unprepare(msm_host->byte_clk);\n}\n\nstatic unsigned long dsi_adjust_pclk_for_compression(const struct drm_display_mode *mode,\n\t\tconst struct drm_dsc_config *dsc)\n{\n\tint new_hdisplay = DIV_ROUND_UP(mode->hdisplay * drm_dsc_get_bpp_int(dsc),\n\t\t\tdsc->bits_per_component * 3);\n\n\tint new_htotal = mode->htotal - mode->hdisplay + new_hdisplay;\n\n\treturn new_htotal * mode->vtotal * drm_mode_vrefresh(mode);\n}\n\nstatic unsigned long dsi_get_pclk_rate(const struct drm_display_mode *mode,\n\t\tconst struct drm_dsc_config *dsc, bool is_bonded_dsi)\n{\n\tunsigned long pclk_rate;\n\n\tpclk_rate = mode->clock * 1000;\n\n\tif (dsc)\n\t\tpclk_rate = dsi_adjust_pclk_for_compression(mode, dsc);\n\n\t \n\tif (is_bonded_dsi)\n\t\tpclk_rate /= 2;\n\n\treturn pclk_rate;\n}\n\nunsigned long dsi_byte_clk_get_rate(struct mipi_dsi_host *host, bool is_bonded_dsi,\n\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tu8 lanes = msm_host->lanes;\n\tu32 bpp = dsi_get_bpp(msm_host->format);\n\tunsigned long pclk_rate = dsi_get_pclk_rate(mode, msm_host->dsc, is_bonded_dsi);\n\tunsigned long pclk_bpp;\n\n\tif (lanes == 0) {\n\t\tpr_err(\"%s: forcing mdss_dsi lanes to 1\\n\", __func__);\n\t\tlanes = 1;\n\t}\n\n\t \n\tif (msm_host->cphy_mode)\n\t\tpclk_bpp = mult_frac(pclk_rate, bpp, 16 * lanes);\n\telse\n\t\tpclk_bpp = mult_frac(pclk_rate, bpp, 8 * lanes);\n\n\treturn pclk_bpp;\n}\n\nstatic void dsi_calc_pclk(struct msm_dsi_host *msm_host, bool is_bonded_dsi)\n{\n\tmsm_host->pixel_clk_rate = dsi_get_pclk_rate(msm_host->mode, msm_host->dsc, is_bonded_dsi);\n\tmsm_host->byte_clk_rate = dsi_byte_clk_get_rate(&msm_host->base, is_bonded_dsi,\n\t\t\t\t\t\t\tmsm_host->mode);\n\n\tDBG(\"pclk=%lu, bclk=%lu\", msm_host->pixel_clk_rate,\n\t\t\t\tmsm_host->byte_clk_rate);\n\n}\n\nint dsi_calc_clk_rate_6g(struct msm_dsi_host *msm_host, bool is_bonded_dsi)\n{\n\tif (!msm_host->mode) {\n\t\tpr_err(\"%s: mode not set\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdsi_calc_pclk(msm_host, is_bonded_dsi);\n\tmsm_host->esc_clk_rate = clk_get_rate(msm_host->esc_clk);\n\treturn 0;\n}\n\nint dsi_calc_clk_rate_v2(struct msm_dsi_host *msm_host, bool is_bonded_dsi)\n{\n\tu32 bpp = dsi_get_bpp(msm_host->format);\n\tunsigned int esc_mhz, esc_div;\n\tunsigned long byte_mhz;\n\n\tdsi_calc_pclk(msm_host, is_bonded_dsi);\n\n\tmsm_host->src_clk_rate = mult_frac(msm_host->pixel_clk_rate, bpp, 8);\n\n\t \n\n\tbyte_mhz = msm_host->byte_clk_rate / 1000000;\n\n\tfor (esc_mhz = 20; esc_mhz >= 5; esc_mhz--) {\n\t\tesc_div = DIV_ROUND_UP(byte_mhz, esc_mhz);\n\n\t\t \n\t\tif (esc_div >= 1 && esc_div <= 16)\n\t\t\tbreak;\n\t}\n\n\tif (esc_mhz < 5)\n\t\treturn -EINVAL;\n\n\tmsm_host->esc_clk_rate = msm_host->byte_clk_rate / esc_div;\n\n\tDBG(\"esc=%lu, src=%lu\", msm_host->esc_clk_rate,\n\t\tmsm_host->src_clk_rate);\n\n\treturn 0;\n}\n\nstatic void dsi_intr_ctrl(struct msm_dsi_host *msm_host, u32 mask, int enable)\n{\n\tu32 intr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&msm_host->intr_lock, flags);\n\tintr = dsi_read(msm_host, REG_DSI_INTR_CTRL);\n\n\tif (enable)\n\t\tintr |= mask;\n\telse\n\t\tintr &= ~mask;\n\n\tDBG(\"intr=%x enable=%d\", intr, enable);\n\n\tdsi_write(msm_host, REG_DSI_INTR_CTRL, intr);\n\tspin_unlock_irqrestore(&msm_host->intr_lock, flags);\n}\n\nstatic inline enum dsi_traffic_mode dsi_get_traffic_mode(const u32 mode_flags)\n{\n\tif (mode_flags & MIPI_DSI_MODE_VIDEO_BURST)\n\t\treturn BURST_MODE;\n\telse if (mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\treturn NON_BURST_SYNCH_PULSE;\n\n\treturn NON_BURST_SYNCH_EVENT;\n}\n\nstatic inline enum dsi_vid_dst_format dsi_get_vid_fmt(\n\t\t\t\tconst enum mipi_dsi_pixel_format mipi_fmt)\n{\n\tswitch (mipi_fmt) {\n\tcase MIPI_DSI_FMT_RGB888:\treturn VID_DST_FORMAT_RGB888;\n\tcase MIPI_DSI_FMT_RGB666:\treturn VID_DST_FORMAT_RGB666_LOOSE;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\treturn VID_DST_FORMAT_RGB666;\n\tcase MIPI_DSI_FMT_RGB565:\treturn VID_DST_FORMAT_RGB565;\n\tdefault:\t\t\treturn VID_DST_FORMAT_RGB888;\n\t}\n}\n\nstatic inline enum dsi_cmd_dst_format dsi_get_cmd_fmt(\n\t\t\t\tconst enum mipi_dsi_pixel_format mipi_fmt)\n{\n\tswitch (mipi_fmt) {\n\tcase MIPI_DSI_FMT_RGB888:\treturn CMD_DST_FORMAT_RGB888;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\tcase MIPI_DSI_FMT_RGB666:\treturn CMD_DST_FORMAT_RGB666;\n\tcase MIPI_DSI_FMT_RGB565:\treturn CMD_DST_FORMAT_RGB565;\n\tdefault:\t\t\treturn CMD_DST_FORMAT_RGB888;\n\t}\n}\n\nstatic void dsi_ctrl_disable(struct msm_dsi_host *msm_host)\n{\n\tdsi_write(msm_host, REG_DSI_CTRL, 0);\n}\n\nstatic void dsi_ctrl_enable(struct msm_dsi_host *msm_host,\n\t\t\tstruct msm_dsi_phy_shared_timings *phy_shared_timings, struct msm_dsi_phy *phy)\n{\n\tu32 flags = msm_host->mode_flags;\n\tenum mipi_dsi_pixel_format mipi_fmt = msm_host->format;\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;\n\tu32 data = 0, lane_ctrl = 0;\n\n\tif (flags & MIPI_DSI_MODE_VIDEO) {\n\t\tif (flags & MIPI_DSI_MODE_VIDEO_HSE)\n\t\t\tdata |= DSI_VID_CFG0_PULSE_MODE_HSA_HE;\n\t\tif (flags & MIPI_DSI_MODE_VIDEO_NO_HFP)\n\t\t\tdata |= DSI_VID_CFG0_HFP_POWER_STOP;\n\t\tif (flags & MIPI_DSI_MODE_VIDEO_NO_HBP)\n\t\t\tdata |= DSI_VID_CFG0_HBP_POWER_STOP;\n\t\tif (flags & MIPI_DSI_MODE_VIDEO_NO_HSA)\n\t\t\tdata |= DSI_VID_CFG0_HSA_POWER_STOP;\n\t\t \n\t\tdata |= DSI_VID_CFG0_EOF_BLLP_POWER_STOP |\n\t\t\tDSI_VID_CFG0_BLLP_POWER_STOP;\n\t\tdata |= DSI_VID_CFG0_TRAFFIC_MODE(dsi_get_traffic_mode(flags));\n\t\tdata |= DSI_VID_CFG0_DST_FORMAT(dsi_get_vid_fmt(mipi_fmt));\n\t\tdata |= DSI_VID_CFG0_VIRT_CHANNEL(msm_host->channel);\n\t\tdsi_write(msm_host, REG_DSI_VID_CFG0, data);\n\n\t\t \n\t\tdata = DSI_VID_CFG1_RGB_SWAP(SWAP_RGB);\n\t\tdsi_write(msm_host, REG_DSI_VID_CFG1, 0);\n\t} else {\n\t\t \n\t\tdata = DSI_CMD_CFG0_RGB_SWAP(SWAP_RGB);\n\t\tdata |= DSI_CMD_CFG0_DST_FORMAT(dsi_get_cmd_fmt(mipi_fmt));\n\t\tdsi_write(msm_host, REG_DSI_CMD_CFG0, data);\n\n\t\tdata = DSI_CMD_CFG1_WR_MEM_START(MIPI_DCS_WRITE_MEMORY_START) |\n\t\t\tDSI_CMD_CFG1_WR_MEM_CONTINUE(\n\t\t\t\t\tMIPI_DCS_WRITE_MEMORY_CONTINUE);\n\t\t \n\t\tdata |= DSI_CMD_CFG1_INSERT_DCS_COMMAND;\n\t\tdsi_write(msm_host, REG_DSI_CMD_CFG1, data);\n\n\t\tif (msm_host->cfg_hnd->major == MSM_DSI_VER_MAJOR_6G &&\n\t\t    msm_host->cfg_hnd->minor >= MSM_DSI_6G_VER_MINOR_V1_3) {\n\t\t\tdata = dsi_read(msm_host, REG_DSI_CMD_MODE_MDP_CTRL2);\n\t\t\tdata |= DSI_CMD_MODE_MDP_CTRL2_BURST_MODE;\n\t\t\tdsi_write(msm_host, REG_DSI_CMD_MODE_MDP_CTRL2, data);\n\t\t}\n\t}\n\n\tdsi_write(msm_host, REG_DSI_CMD_DMA_CTRL,\n\t\t\tDSI_CMD_DMA_CTRL_FROM_FRAME_BUFFER |\n\t\t\tDSI_CMD_DMA_CTRL_LOW_POWER);\n\n\tdata = 0;\n\t \n\tdata |= DSI_TRIG_CTRL_TE;\n\tdata |= DSI_TRIG_CTRL_MDP_TRIGGER(TRIGGER_NONE);\n\tdata |= DSI_TRIG_CTRL_DMA_TRIGGER(TRIGGER_SW);\n\tdata |= DSI_TRIG_CTRL_STREAM(msm_host->channel);\n\tif ((cfg_hnd->major == MSM_DSI_VER_MAJOR_6G) &&\n\t\t(cfg_hnd->minor >= MSM_DSI_6G_VER_MINOR_V1_2))\n\t\tdata |= DSI_TRIG_CTRL_BLOCK_DMA_WITHIN_FRAME;\n\tdsi_write(msm_host, REG_DSI_TRIG_CTRL, data);\n\n\tdata = DSI_CLKOUT_TIMING_CTRL_T_CLK_POST(phy_shared_timings->clk_post) |\n\t\tDSI_CLKOUT_TIMING_CTRL_T_CLK_PRE(phy_shared_timings->clk_pre);\n\tdsi_write(msm_host, REG_DSI_CLKOUT_TIMING_CTRL, data);\n\n\tif ((cfg_hnd->major == MSM_DSI_VER_MAJOR_6G) &&\n\t    (cfg_hnd->minor > MSM_DSI_6G_VER_MINOR_V1_0) &&\n\t    phy_shared_timings->clk_pre_inc_by_2)\n\t\tdsi_write(msm_host, REG_DSI_T_CLK_PRE_EXTEND,\n\t\t\t  DSI_T_CLK_PRE_EXTEND_INC_BY_2_BYTECLK);\n\n\tdata = 0;\n\tif (!(flags & MIPI_DSI_MODE_NO_EOT_PACKET))\n\t\tdata |= DSI_EOT_PACKET_CTRL_TX_EOT_APPEND;\n\tdsi_write(msm_host, REG_DSI_EOT_PACKET_CTRL, data);\n\n\t \n\tdsi_write(msm_host, REG_DSI_ERR_INT_MASK0, 0x13ff3fe0);\n\n\tdsi_intr_ctrl(msm_host, DSI_IRQ_MASK_ERROR, 1);\n\n\tdsi_write(msm_host, REG_DSI_CLK_CTRL, DSI_CLK_CTRL_ENABLE_CLKS);\n\n\tdata = DSI_CTRL_CLK_EN;\n\n\tDBG(\"lane number=%d\", msm_host->lanes);\n\tdata |= ((DSI_CTRL_LANE0 << msm_host->lanes) - DSI_CTRL_LANE0);\n\n\tdsi_write(msm_host, REG_DSI_LANE_SWAP_CTRL,\n\t\t  DSI_LANE_SWAP_CTRL_DLN_SWAP_SEL(msm_host->dlane_swap));\n\n\tif (!(flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)) {\n\t\tlane_ctrl = dsi_read(msm_host, REG_DSI_LANE_CTRL);\n\n\t\tif (msm_dsi_phy_set_continuous_clock(phy, true))\n\t\t\tlane_ctrl &= ~DSI_LANE_CTRL_HS_REQ_SEL_PHY;\n\n\t\tdsi_write(msm_host, REG_DSI_LANE_CTRL,\n\t\t\tlane_ctrl | DSI_LANE_CTRL_CLKLN_HS_FORCE_REQUEST);\n\t}\n\n\tdata |= DSI_CTRL_ENABLE;\n\n\tdsi_write(msm_host, REG_DSI_CTRL, data);\n\n\tif (msm_host->cphy_mode)\n\t\tdsi_write(msm_host, REG_DSI_CPHY_MODE_CTRL, BIT(0));\n}\n\nstatic void dsi_update_dsc_timing(struct msm_dsi_host *msm_host, bool is_cmd_mode, u32 hdisplay)\n{\n\tstruct drm_dsc_config *dsc = msm_host->dsc;\n\tu32 reg, reg_ctrl, reg_ctrl2;\n\tu32 slice_per_intf, total_bytes_per_intf;\n\tu32 pkt_per_line;\n\tu32 eol_byte_num;\n\n\t \n\tslice_per_intf = msm_dsc_get_slices_per_intf(dsc, hdisplay);\n\n\ttotal_bytes_per_intf = dsc->slice_chunk_size * slice_per_intf;\n\n\teol_byte_num = total_bytes_per_intf % 3;\n\n\t \n\tpkt_per_line = slice_per_intf;\n\n\tif (is_cmd_mode)  \n\t\treg = DSI_COMMAND_COMPRESSION_MODE_CTRL_STREAM0_DATATYPE(MIPI_DSI_DCS_LONG_WRITE);\n\telse\n\t\treg = DSI_VIDEO_COMPRESSION_MODE_CTRL_DATATYPE(MIPI_DSI_COMPRESSED_PIXEL_STREAM);\n\n\t \n\treg |= DSI_VIDEO_COMPRESSION_MODE_CTRL_PKT_PER_LINE(pkt_per_line >> 1);\n\treg |= DSI_VIDEO_COMPRESSION_MODE_CTRL_EOL_BYTE_NUM(eol_byte_num);\n\treg |= DSI_VIDEO_COMPRESSION_MODE_CTRL_EN;\n\n\tif (is_cmd_mode) {\n\t\treg_ctrl = dsi_read(msm_host, REG_DSI_COMMAND_COMPRESSION_MODE_CTRL);\n\t\treg_ctrl2 = dsi_read(msm_host, REG_DSI_COMMAND_COMPRESSION_MODE_CTRL2);\n\n\t\treg_ctrl &= ~0xffff;\n\t\treg_ctrl |= reg;\n\n\t\treg_ctrl2 &= ~DSI_COMMAND_COMPRESSION_MODE_CTRL2_STREAM0_SLICE_WIDTH__MASK;\n\t\treg_ctrl2 |= DSI_COMMAND_COMPRESSION_MODE_CTRL2_STREAM0_SLICE_WIDTH(dsc->slice_chunk_size);\n\n\t\tdsi_write(msm_host, REG_DSI_COMMAND_COMPRESSION_MODE_CTRL, reg_ctrl);\n\t\tdsi_write(msm_host, REG_DSI_COMMAND_COMPRESSION_MODE_CTRL2, reg_ctrl2);\n\t} else {\n\t\tdsi_write(msm_host, REG_DSI_VIDEO_COMPRESSION_MODE_CTRL, reg);\n\t}\n}\n\nstatic void dsi_timing_setup(struct msm_dsi_host *msm_host, bool is_bonded_dsi)\n{\n\tstruct drm_display_mode *mode = msm_host->mode;\n\tu32 hs_start = 0, vs_start = 0;  \n\tu32 h_total = mode->htotal;\n\tu32 v_total = mode->vtotal;\n\tu32 hs_end = mode->hsync_end - mode->hsync_start;\n\tu32 vs_end = mode->vsync_end - mode->vsync_start;\n\tu32 ha_start = h_total - mode->hsync_start;\n\tu32 ha_end = ha_start + mode->hdisplay;\n\tu32 va_start = v_total - mode->vsync_start;\n\tu32 va_end = va_start + mode->vdisplay;\n\tu32 hdisplay = mode->hdisplay;\n\tu32 wc;\n\tint ret;\n\n\tDBG(\"\");\n\n\t \n\tif (is_bonded_dsi) {\n\t\th_total /= 2;\n\t\ths_end /= 2;\n\t\tha_start /= 2;\n\t\tha_end /= 2;\n\t\thdisplay /= 2;\n\t}\n\n\tif (msm_host->dsc) {\n\t\tstruct drm_dsc_config *dsc = msm_host->dsc;\n\n\t\t \n\t\tif (!dsc || !mode->hdisplay || !mode->vdisplay) {\n\t\t\tpr_err(\"DSI: invalid input: pic_width: %d pic_height: %d\\n\",\n\t\t\t       mode->hdisplay, mode->vdisplay);\n\t\t\treturn;\n\t\t}\n\n\t\tdsc->pic_width = mode->hdisplay;\n\t\tdsc->pic_height = mode->vdisplay;\n\t\tDBG(\"Mode %dx%d\\n\", dsc->pic_width, dsc->pic_height);\n\n\t\t \n\t\tret = dsi_populate_dsc_params(msm_host, dsc);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\t \n\t\th_total -= hdisplay;\n\t\thdisplay = DIV_ROUND_UP(msm_dsc_get_bytes_per_line(msm_host->dsc), 3);\n\t\th_total += hdisplay;\n\t\tha_end = ha_start + hdisplay;\n\t}\n\n\tif (msm_host->mode_flags & MIPI_DSI_MODE_VIDEO) {\n\t\tif (msm_host->dsc)\n\t\t\tdsi_update_dsc_timing(msm_host, false, mode->hdisplay);\n\n\t\tdsi_write(msm_host, REG_DSI_ACTIVE_H,\n\t\t\tDSI_ACTIVE_H_START(ha_start) |\n\t\t\tDSI_ACTIVE_H_END(ha_end));\n\t\tdsi_write(msm_host, REG_DSI_ACTIVE_V,\n\t\t\tDSI_ACTIVE_V_START(va_start) |\n\t\t\tDSI_ACTIVE_V_END(va_end));\n\t\tdsi_write(msm_host, REG_DSI_TOTAL,\n\t\t\tDSI_TOTAL_H_TOTAL(h_total - 1) |\n\t\t\tDSI_TOTAL_V_TOTAL(v_total - 1));\n\n\t\tdsi_write(msm_host, REG_DSI_ACTIVE_HSYNC,\n\t\t\tDSI_ACTIVE_HSYNC_START(hs_start) |\n\t\t\tDSI_ACTIVE_HSYNC_END(hs_end));\n\t\tdsi_write(msm_host, REG_DSI_ACTIVE_VSYNC_HPOS, 0);\n\t\tdsi_write(msm_host, REG_DSI_ACTIVE_VSYNC_VPOS,\n\t\t\tDSI_ACTIVE_VSYNC_VPOS_START(vs_start) |\n\t\t\tDSI_ACTIVE_VSYNC_VPOS_END(vs_end));\n\t} else {\t\t \n\t\tif (msm_host->dsc)\n\t\t\tdsi_update_dsc_timing(msm_host, true, mode->hdisplay);\n\n\t\t \n\t\tif (!msm_host->dsc)\n\t\t\twc = hdisplay * dsi_get_bpp(msm_host->format) / 8 + 1;\n\t\telse\n\t\t\t \n\t\t\twc = msm_host->dsc->slice_chunk_size + 1;\n\n\t\tdsi_write(msm_host, REG_DSI_CMD_MDP_STREAM0_CTRL,\n\t\t\tDSI_CMD_MDP_STREAM0_CTRL_WORD_COUNT(wc) |\n\t\t\tDSI_CMD_MDP_STREAM0_CTRL_VIRTUAL_CHANNEL(\n\t\t\t\t\tmsm_host->channel) |\n\t\t\tDSI_CMD_MDP_STREAM0_CTRL_DATA_TYPE(\n\t\t\t\t\tMIPI_DSI_DCS_LONG_WRITE));\n\n\t\tdsi_write(msm_host, REG_DSI_CMD_MDP_STREAM0_TOTAL,\n\t\t\tDSI_CMD_MDP_STREAM0_TOTAL_H_TOTAL(hdisplay) |\n\t\t\tDSI_CMD_MDP_STREAM0_TOTAL_V_TOTAL(mode->vdisplay));\n\t}\n}\n\nstatic void dsi_sw_reset(struct msm_dsi_host *msm_host)\n{\n\tu32 ctrl;\n\n\tctrl = dsi_read(msm_host, REG_DSI_CTRL);\n\n\tif (ctrl & DSI_CTRL_ENABLE) {\n\t\tdsi_write(msm_host, REG_DSI_CTRL, ctrl & ~DSI_CTRL_ENABLE);\n\t\t \n\t\twmb();\n\t}\n\n\tdsi_write(msm_host, REG_DSI_CLK_CTRL, DSI_CLK_CTRL_ENABLE_CLKS);\n\twmb();  \n\n\t \n\tdsi_write(msm_host, REG_DSI_RESET, 1);\n\tmsleep(DSI_RESET_TOGGLE_DELAY_MS);  \n\tdsi_write(msm_host, REG_DSI_RESET, 0);\n\twmb();  \n\n\tif (ctrl & DSI_CTRL_ENABLE) {\n\t\tdsi_write(msm_host, REG_DSI_CTRL, ctrl);\n\t\twmb();\t \n\t}\n}\n\nstatic void dsi_op_mode_config(struct msm_dsi_host *msm_host,\n\t\t\t\t\tbool video_mode, bool enable)\n{\n\tu32 dsi_ctrl;\n\n\tdsi_ctrl = dsi_read(msm_host, REG_DSI_CTRL);\n\n\tif (!enable) {\n\t\tdsi_ctrl &= ~(DSI_CTRL_ENABLE | DSI_CTRL_VID_MODE_EN |\n\t\t\t\tDSI_CTRL_CMD_MODE_EN);\n\t\tdsi_intr_ctrl(msm_host, DSI_IRQ_MASK_CMD_MDP_DONE |\n\t\t\t\t\tDSI_IRQ_MASK_VIDEO_DONE, 0);\n\t} else {\n\t\tif (video_mode) {\n\t\t\tdsi_ctrl |= DSI_CTRL_VID_MODE_EN;\n\t\t} else {\t\t \n\t\t\tdsi_ctrl |= DSI_CTRL_CMD_MODE_EN;\n\t\t\tdsi_intr_ctrl(msm_host, DSI_IRQ_MASK_CMD_MDP_DONE, 1);\n\t\t}\n\t\tdsi_ctrl |= DSI_CTRL_ENABLE;\n\t}\n\n\tdsi_write(msm_host, REG_DSI_CTRL, dsi_ctrl);\n}\n\nstatic void dsi_set_tx_power_mode(int mode, struct msm_dsi_host *msm_host)\n{\n\tu32 data;\n\n\tdata = dsi_read(msm_host, REG_DSI_CMD_DMA_CTRL);\n\n\tif (mode == 0)\n\t\tdata &= ~DSI_CMD_DMA_CTRL_LOW_POWER;\n\telse\n\t\tdata |= DSI_CMD_DMA_CTRL_LOW_POWER;\n\n\tdsi_write(msm_host, REG_DSI_CMD_DMA_CTRL, data);\n}\n\nstatic void dsi_wait4video_done(struct msm_dsi_host *msm_host)\n{\n\tu32 ret = 0;\n\tstruct device *dev = &msm_host->pdev->dev;\n\n\tdsi_intr_ctrl(msm_host, DSI_IRQ_MASK_VIDEO_DONE, 1);\n\n\treinit_completion(&msm_host->video_comp);\n\n\tret = wait_for_completion_timeout(&msm_host->video_comp,\n\t\t\tmsecs_to_jiffies(70));\n\n\tif (ret == 0)\n\t\tDRM_DEV_ERROR(dev, \"wait for video done timed out\\n\");\n\n\tdsi_intr_ctrl(msm_host, DSI_IRQ_MASK_VIDEO_DONE, 0);\n}\n\nstatic void dsi_wait4video_eng_busy(struct msm_dsi_host *msm_host)\n{\n\tu32 data;\n\n\tif (!(msm_host->mode_flags & MIPI_DSI_MODE_VIDEO))\n\t\treturn;\n\n\tdata = dsi_read(msm_host, REG_DSI_STATUS0);\n\n\t \n\tif (!(data & DSI_STATUS0_VIDEO_MODE_ENGINE_BUSY))\n\t\treturn;\n\n\tif (msm_host->power_on && msm_host->enabled) {\n\t\tdsi_wait4video_done(msm_host);\n\t\t \n\t\tusleep_range(2000, 4000);\n\t}\n}\n\nint dsi_tx_buf_alloc_6g(struct msm_dsi_host *msm_host, int size)\n{\n\tstruct drm_device *dev = msm_host->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tuint64_t iova;\n\tu8 *data;\n\n\tmsm_host->aspace = msm_gem_address_space_get(priv->kms->aspace);\n\n\tdata = msm_gem_kernel_new(dev, size, MSM_BO_WC,\n\t\t\t\t\tmsm_host->aspace,\n\t\t\t\t\t&msm_host->tx_gem_obj, &iova);\n\n\tif (IS_ERR(data)) {\n\t\tmsm_host->tx_gem_obj = NULL;\n\t\treturn PTR_ERR(data);\n\t}\n\n\tmsm_gem_object_set_name(msm_host->tx_gem_obj, \"tx_gem\");\n\n\tmsm_host->tx_size = msm_host->tx_gem_obj->size;\n\n\treturn 0;\n}\n\nint dsi_tx_buf_alloc_v2(struct msm_dsi_host *msm_host, int size)\n{\n\tstruct drm_device *dev = msm_host->dev;\n\n\tmsm_host->tx_buf = dma_alloc_coherent(dev->dev, size,\n\t\t\t\t\t&msm_host->tx_buf_paddr, GFP_KERNEL);\n\tif (!msm_host->tx_buf)\n\t\treturn -ENOMEM;\n\n\tmsm_host->tx_size = size;\n\n\treturn 0;\n}\n\nvoid msm_dsi_tx_buf_free(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tstruct drm_device *dev = msm_host->dev;\n\n\t \n\tif (!dev)\n\t\treturn;\n\n\tif (msm_host->tx_gem_obj) {\n\t\tmsm_gem_kernel_put(msm_host->tx_gem_obj, msm_host->aspace);\n\t\tmsm_gem_address_space_put(msm_host->aspace);\n\t\tmsm_host->tx_gem_obj = NULL;\n\t\tmsm_host->aspace = NULL;\n\t}\n\n\tif (msm_host->tx_buf)\n\t\tdma_free_coherent(dev->dev, msm_host->tx_size, msm_host->tx_buf,\n\t\t\tmsm_host->tx_buf_paddr);\n}\n\nvoid *dsi_tx_buf_get_6g(struct msm_dsi_host *msm_host)\n{\n\treturn msm_gem_get_vaddr(msm_host->tx_gem_obj);\n}\n\nvoid *dsi_tx_buf_get_v2(struct msm_dsi_host *msm_host)\n{\n\treturn msm_host->tx_buf;\n}\n\nvoid dsi_tx_buf_put_6g(struct msm_dsi_host *msm_host)\n{\n\tmsm_gem_put_vaddr(msm_host->tx_gem_obj);\n}\n\n \nstatic int dsi_cmd_dma_add(struct msm_dsi_host *msm_host,\n\t\t\t   const struct mipi_dsi_msg *msg)\n{\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;\n\tstruct mipi_dsi_packet packet;\n\tint len;\n\tint ret;\n\tu8 *data;\n\n\tret = mipi_dsi_create_packet(&packet, msg);\n\tif (ret) {\n\t\tpr_err(\"%s: create packet failed, %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\tlen = (packet.size + 3) & (~0x3);\n\n\tif (len > msm_host->tx_size) {\n\t\tpr_err(\"%s: packet size is too big\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = cfg_hnd->ops->tx_buf_get(msm_host);\n\tif (IS_ERR(data)) {\n\t\tret = PTR_ERR(data);\n\t\tpr_err(\"%s: get vaddr failed, %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdata[0] = packet.header[1];\n\tdata[1] = packet.header[2];\n\tdata[2] = packet.header[0];\n\tdata[3] = BIT(7);  \n\tif (mipi_dsi_packet_format_is_long(msg->type))\n\t\tdata[3] |= BIT(6);\n\tif (msg->rx_buf && msg->rx_len)\n\t\tdata[3] |= BIT(5);\n\n\t \n\tif (packet.payload && packet.payload_length)\n\t\tmemcpy(data + 4, packet.payload, packet.payload_length);\n\n\t \n\tif (packet.size < len)\n\t\tmemset(data + packet.size, 0xff, len - packet.size);\n\n\tif (cfg_hnd->ops->tx_buf_put)\n\t\tcfg_hnd->ops->tx_buf_put(msm_host);\n\n\treturn len;\n}\n\n \nstatic int dsi_short_read1_resp(u8 *buf, const struct mipi_dsi_msg *msg)\n{\n\tu8 *data = msg->rx_buf;\n\tif (data && (msg->rx_len >= 1)) {\n\t\t*data = buf[1];  \n\t\treturn 1;\n\t} else {\n\t\tpr_err(\"%s: read data does not match with rx_buf len %zu\\n\",\n\t\t\t__func__, msg->rx_len);\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int dsi_short_read2_resp(u8 *buf, const struct mipi_dsi_msg *msg)\n{\n\tu8 *data = msg->rx_buf;\n\tif (data && (msg->rx_len >= 2)) {\n\t\tdata[0] = buf[1];  \n\t\tdata[1] = buf[2];\n\t\treturn 2;\n\t} else {\n\t\tpr_err(\"%s: read data does not match with rx_buf len %zu\\n\",\n\t\t\t__func__, msg->rx_len);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int dsi_long_read_resp(u8 *buf, const struct mipi_dsi_msg *msg)\n{\n\t \n\tif (msg->rx_buf && msg->rx_len)\n\t\tmemcpy(msg->rx_buf, buf + 4, msg->rx_len);\n\n\treturn msg->rx_len;\n}\n\nint dsi_dma_base_get_6g(struct msm_dsi_host *msm_host, uint64_t *dma_base)\n{\n\tstruct drm_device *dev = msm_host->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\n\tif (!dma_base)\n\t\treturn -EINVAL;\n\n\treturn msm_gem_get_and_pin_iova(msm_host->tx_gem_obj,\n\t\t\t\tpriv->kms->aspace, dma_base);\n}\n\nint dsi_dma_base_get_v2(struct msm_dsi_host *msm_host, uint64_t *dma_base)\n{\n\tif (!dma_base)\n\t\treturn -EINVAL;\n\n\t*dma_base = msm_host->tx_buf_paddr;\n\treturn 0;\n}\n\nstatic int dsi_cmd_dma_tx(struct msm_dsi_host *msm_host, int len)\n{\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;\n\tint ret;\n\tuint64_t dma_base;\n\tbool triggered;\n\n\tret = cfg_hnd->ops->dma_base_get(msm_host, &dma_base);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to get iova: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treinit_completion(&msm_host->dma_comp);\n\n\tdsi_wait4video_eng_busy(msm_host);\n\n\ttriggered = msm_dsi_manager_cmd_xfer_trigger(\n\t\t\t\t\t\tmsm_host->id, dma_base, len);\n\tif (triggered) {\n\t\tret = wait_for_completion_timeout(&msm_host->dma_comp,\n\t\t\t\t\tmsecs_to_jiffies(200));\n\t\tDBG(\"ret=%d\", ret);\n\t\tif (ret == 0)\n\t\t\tret = -ETIMEDOUT;\n\t\telse\n\t\t\tret = len;\n\t} else\n\t\tret = len;\n\n\treturn ret;\n}\n\nstatic int dsi_cmd_dma_rx(struct msm_dsi_host *msm_host,\n\t\t\tu8 *buf, int rx_byte, int pkt_size)\n{\n\tu32 *temp, data;\n\tint i, j = 0, cnt;\n\tu32 read_cnt;\n\tu8 reg[16];\n\tint repeated_bytes = 0;\n\tint buf_offset = buf - msm_host->rx_buf;\n\n\ttemp = (u32 *)reg;\n\tcnt = (rx_byte + 3) >> 2;\n\tif (cnt > 4)\n\t\tcnt = 4;  \n\n\tif (rx_byte == 4)\n\t\tread_cnt = 4;\n\telse\n\t\tread_cnt = pkt_size + 6;\n\n\t \n\tif (read_cnt > 16) {\n\t\tint bytes_shifted;\n\t\t \n\t\tbytes_shifted = read_cnt - 16;\n\t\trepeated_bytes = buf_offset - bytes_shifted;\n\t}\n\n\tfor (i = cnt - 1; i >= 0; i--) {\n\t\tdata = dsi_read(msm_host, REG_DSI_RDBK_DATA(i));\n\t\t*temp++ = ntohl(data);  \n\t\tDBG(\"data = 0x%x and ntohl(data) = 0x%x\", data, ntohl(data));\n\t}\n\n\tfor (i = repeated_bytes; i < 16; i++)\n\t\tbuf[j++] = reg[i];\n\n\treturn j;\n}\n\nstatic int dsi_cmds2buf_tx(struct msm_dsi_host *msm_host,\n\t\t\t\tconst struct mipi_dsi_msg *msg)\n{\n\tint len, ret;\n\tint bllp_len = msm_host->mode->hdisplay *\n\t\t\tdsi_get_bpp(msm_host->format) / 8;\n\n\tlen = dsi_cmd_dma_add(msm_host, msg);\n\tif (len < 0) {\n\t\tpr_err(\"%s: failed to add cmd type = 0x%x\\n\",\n\t\t\t__func__,  msg->type);\n\t\treturn len;\n\t}\n\n\t \n\t \n\tif ((msm_host->mode_flags & MIPI_DSI_MODE_VIDEO) && (len > bllp_len)) {\n\t\tpr_err(\"%s: cmd cannot fit into BLLP period, len=%d\\n\",\n\t\t\t__func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tret = dsi_cmd_dma_tx(msm_host, len);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: cmd dma tx failed, type=0x%x, data0=0x%x, len=%d, ret=%d\\n\",\n\t\t\t__func__, msg->type, (*(u8 *)(msg->tx_buf)), len, ret);\n\t\treturn ret;\n\t} else if (ret < len) {\n\t\tpr_err(\"%s: cmd dma tx failed, type=0x%x, data0=0x%x, ret=%d len=%d\\n\",\n\t\t\t__func__, msg->type, (*(u8 *)(msg->tx_buf)), ret, len);\n\t\treturn -EIO;\n\t}\n\n\treturn len;\n}\n\nstatic void dsi_err_worker(struct work_struct *work)\n{\n\tstruct msm_dsi_host *msm_host =\n\t\tcontainer_of(work, struct msm_dsi_host, err_work);\n\tu32 status = msm_host->err_work_state;\n\n\tpr_err_ratelimited(\"%s: status=%x\\n\", __func__, status);\n\tif (status & DSI_ERR_STATE_MDP_FIFO_UNDERFLOW)\n\t\tdsi_sw_reset(msm_host);\n\n\t \n\tmsm_host->err_work_state = 0;\n\n\t \n\tdsi_intr_ctrl(msm_host, DSI_IRQ_MASK_ERROR, 1);\n}\n\nstatic void dsi_ack_err_status(struct msm_dsi_host *msm_host)\n{\n\tu32 status;\n\n\tstatus = dsi_read(msm_host, REG_DSI_ACK_ERR_STATUS);\n\n\tif (status) {\n\t\tdsi_write(msm_host, REG_DSI_ACK_ERR_STATUS, status);\n\t\t \n\t\tdsi_write(msm_host, REG_DSI_ACK_ERR_STATUS, 0);\n\t\tmsm_host->err_work_state |= DSI_ERR_STATE_ACK;\n\t}\n}\n\nstatic void dsi_timeout_status(struct msm_dsi_host *msm_host)\n{\n\tu32 status;\n\n\tstatus = dsi_read(msm_host, REG_DSI_TIMEOUT_STATUS);\n\n\tif (status) {\n\t\tdsi_write(msm_host, REG_DSI_TIMEOUT_STATUS, status);\n\t\tmsm_host->err_work_state |= DSI_ERR_STATE_TIMEOUT;\n\t}\n}\n\nstatic void dsi_dln0_phy_err(struct msm_dsi_host *msm_host)\n{\n\tu32 status;\n\n\tstatus = dsi_read(msm_host, REG_DSI_DLN0_PHY_ERR);\n\n\tif (status & (DSI_DLN0_PHY_ERR_DLN0_ERR_ESC |\n\t\t\tDSI_DLN0_PHY_ERR_DLN0_ERR_SYNC_ESC |\n\t\t\tDSI_DLN0_PHY_ERR_DLN0_ERR_CONTROL |\n\t\t\tDSI_DLN0_PHY_ERR_DLN0_ERR_CONTENTION_LP0 |\n\t\t\tDSI_DLN0_PHY_ERR_DLN0_ERR_CONTENTION_LP1)) {\n\t\tdsi_write(msm_host, REG_DSI_DLN0_PHY_ERR, status);\n\t\tmsm_host->err_work_state |= DSI_ERR_STATE_DLN0_PHY;\n\t}\n}\n\nstatic void dsi_fifo_status(struct msm_dsi_host *msm_host)\n{\n\tu32 status;\n\n\tstatus = dsi_read(msm_host, REG_DSI_FIFO_STATUS);\n\n\t \n\tif (status) {\n\t\tdsi_write(msm_host, REG_DSI_FIFO_STATUS, status);\n\t\tmsm_host->err_work_state |= DSI_ERR_STATE_FIFO;\n\t\tif (status & DSI_FIFO_STATUS_CMD_MDP_FIFO_UNDERFLOW)\n\t\t\tmsm_host->err_work_state |=\n\t\t\t\t\tDSI_ERR_STATE_MDP_FIFO_UNDERFLOW;\n\t}\n}\n\nstatic void dsi_status(struct msm_dsi_host *msm_host)\n{\n\tu32 status;\n\n\tstatus = dsi_read(msm_host, REG_DSI_STATUS0);\n\n\tif (status & DSI_STATUS0_INTERLEAVE_OP_CONTENTION) {\n\t\tdsi_write(msm_host, REG_DSI_STATUS0, status);\n\t\tmsm_host->err_work_state |=\n\t\t\tDSI_ERR_STATE_INTERLEAVE_OP_CONTENTION;\n\t}\n}\n\nstatic void dsi_clk_status(struct msm_dsi_host *msm_host)\n{\n\tu32 status;\n\n\tstatus = dsi_read(msm_host, REG_DSI_CLK_STATUS);\n\n\tif (status & DSI_CLK_STATUS_PLL_UNLOCKED) {\n\t\tdsi_write(msm_host, REG_DSI_CLK_STATUS, status);\n\t\tmsm_host->err_work_state |= DSI_ERR_STATE_PLL_UNLOCKED;\n\t}\n}\n\nstatic void dsi_error(struct msm_dsi_host *msm_host)\n{\n\t \n\tdsi_intr_ctrl(msm_host, DSI_IRQ_MASK_ERROR, 0);\n\n\tdsi_clk_status(msm_host);\n\tdsi_fifo_status(msm_host);\n\tdsi_ack_err_status(msm_host);\n\tdsi_timeout_status(msm_host);\n\tdsi_status(msm_host);\n\tdsi_dln0_phy_err(msm_host);\n\n\tqueue_work(msm_host->workqueue, &msm_host->err_work);\n}\n\nstatic irqreturn_t dsi_host_irq(int irq, void *ptr)\n{\n\tstruct msm_dsi_host *msm_host = ptr;\n\tu32 isr;\n\tunsigned long flags;\n\n\tif (!msm_host->ctrl_base)\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock_irqsave(&msm_host->intr_lock, flags);\n\tisr = dsi_read(msm_host, REG_DSI_INTR_CTRL);\n\tdsi_write(msm_host, REG_DSI_INTR_CTRL, isr);\n\tspin_unlock_irqrestore(&msm_host->intr_lock, flags);\n\n\tDBG(\"isr=0x%x, id=%d\", isr, msm_host->id);\n\n\tif (isr & DSI_IRQ_ERROR)\n\t\tdsi_error(msm_host);\n\n\tif (isr & DSI_IRQ_VIDEO_DONE)\n\t\tcomplete(&msm_host->video_comp);\n\n\tif (isr & DSI_IRQ_CMD_DMA_DONE)\n\t\tcomplete(&msm_host->dma_comp);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dsi_host_init_panel_gpios(struct msm_dsi_host *msm_host,\n\t\t\tstruct device *panel_device)\n{\n\tmsm_host->disp_en_gpio = devm_gpiod_get_optional(panel_device,\n\t\t\t\t\t\t\t \"disp-enable\",\n\t\t\t\t\t\t\t GPIOD_OUT_LOW);\n\tif (IS_ERR(msm_host->disp_en_gpio)) {\n\t\tDBG(\"cannot get disp-enable-gpios %ld\",\n\t\t\t\tPTR_ERR(msm_host->disp_en_gpio));\n\t\treturn PTR_ERR(msm_host->disp_en_gpio);\n\t}\n\n\tmsm_host->te_gpio = devm_gpiod_get_optional(panel_device, \"disp-te\",\n\t\t\t\t\t\t\t\tGPIOD_IN);\n\tif (IS_ERR(msm_host->te_gpio)) {\n\t\tDBG(\"cannot get disp-te-gpios %ld\", PTR_ERR(msm_host->te_gpio));\n\t\treturn PTR_ERR(msm_host->te_gpio);\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t\t\tstruct mipi_dsi_device *dsi)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tint ret;\n\n\tif (dsi->lanes > msm_host->num_data_lanes)\n\t\treturn -EINVAL;\n\n\tmsm_host->channel = dsi->channel;\n\tmsm_host->lanes = dsi->lanes;\n\tmsm_host->format = dsi->format;\n\tmsm_host->mode_flags = dsi->mode_flags;\n\tif (dsi->dsc)\n\t\tmsm_host->dsc = dsi->dsc;\n\n\t \n\tret = dsi_host_init_panel_gpios(msm_host, &dsi->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dsi_dev_attach(msm_host->pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tDBG(\"id=%d\", msm_host->id);\n\n\treturn 0;\n}\n\nstatic int dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t\t\tstruct mipi_dsi_device *dsi)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tdsi_dev_detach(msm_host->pdev);\n\n\tDBG(\"id=%d\", msm_host->id);\n\n\treturn 0;\n}\n\nstatic ssize_t dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t\tconst struct mipi_dsi_msg *msg)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tint ret;\n\n\tif (!msg || !msm_host->power_on)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&msm_host->cmd_mutex);\n\tret = msm_dsi_manager_cmd_xfer(msm_host->id, msg);\n\tmutex_unlock(&msm_host->cmd_mutex);\n\n\treturn ret;\n}\n\nstatic const struct mipi_dsi_host_ops dsi_host_ops = {\n\t.attach = dsi_host_attach,\n\t.detach = dsi_host_detach,\n\t.transfer = dsi_host_transfer,\n};\n\n \nstatic const int supported_data_lane_swaps[][4] = {\n\t{ 0, 1, 2, 3 },\n\t{ 3, 0, 1, 2 },\n\t{ 2, 3, 0, 1 },\n\t{ 1, 2, 3, 0 },\n\t{ 0, 3, 2, 1 },\n\t{ 1, 0, 3, 2 },\n\t{ 2, 1, 0, 3 },\n\t{ 3, 2, 1, 0 },\n};\n\nstatic int dsi_host_parse_lane_data(struct msm_dsi_host *msm_host,\n\t\t\t\t    struct device_node *ep)\n{\n\tstruct device *dev = &msm_host->pdev->dev;\n\tstruct property *prop;\n\tu32 lane_map[4];\n\tint ret, i, len, num_lanes;\n\n\tprop = of_find_property(ep, \"data-lanes\", &len);\n\tif (!prop) {\n\t\tDRM_DEV_DEBUG(dev,\n\t\t\t\"failed to find data lane mapping, using default\\n\");\n\t\t \n\t\tmsm_host->num_data_lanes = 4;\n\t\treturn 0;\n\t}\n\n\tnum_lanes = drm_of_get_data_lanes_count(ep, 1, 4);\n\tif (num_lanes < 0) {\n\t\tDRM_DEV_ERROR(dev, \"bad number of data lanes\\n\");\n\t\treturn num_lanes;\n\t}\n\n\tmsm_host->num_data_lanes = num_lanes;\n\n\tret = of_property_read_u32_array(ep, \"data-lanes\", lane_map,\n\t\t\t\t\t num_lanes);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to read lane data\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(supported_data_lane_swaps); i++) {\n\t\tconst int *swap = supported_data_lane_swaps[i];\n\t\tint j;\n\n\t\t \n\t\tfor (j = 0; j < num_lanes; j++) {\n\t\t\tif (lane_map[j] < 0 || lane_map[j] > 3)\n\t\t\t\tDRM_DEV_ERROR(dev, \"bad physical lane entry %u\\n\",\n\t\t\t\t\tlane_map[j]);\n\n\t\t\tif (swap[lane_map[j]] != j)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j == num_lanes) {\n\t\t\tmsm_host->dlane_swap = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int dsi_populate_dsc_params(struct msm_dsi_host *msm_host, struct drm_dsc_config *dsc)\n{\n\tint ret;\n\n\tif (dsc->bits_per_pixel & 0xf) {\n\t\tDRM_DEV_ERROR(&msm_host->pdev->dev, \"DSI does not support fractional bits_per_pixel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dsc->bits_per_component != 8) {\n\t\tDRM_DEV_ERROR(&msm_host->pdev->dev, \"DSI does not support bits_per_component != 8 yet\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdsc->simple_422 = 0;\n\tdsc->convert_rgb = 1;\n\tdsc->vbr_enable = 0;\n\n\tdrm_dsc_set_const_params(dsc);\n\tdrm_dsc_set_rc_buf_thresh(dsc);\n\n\t \n\tret = drm_dsc_setup_rc_params(dsc, DRM_DSC_1_1_PRE_SCR);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&msm_host->pdev->dev, \"could not find DSC RC parameters\\n\");\n\t\treturn ret;\n\t}\n\n\tdsc->initial_scale_value = drm_dsc_initial_scale_value(dsc);\n\tdsc->line_buf_depth = dsc->bits_per_component + 1;\n\n\treturn drm_dsc_compute_rc_parameters(dsc);\n}\n\nstatic int dsi_host_parse_dt(struct msm_dsi_host *msm_host)\n{\n\tstruct device *dev = &msm_host->pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *endpoint;\n\tint ret = 0;\n\n\t \n\tendpoint = of_graph_get_endpoint_by_regs(np, 1, -1);\n\tif (!endpoint) {\n\t\tDRM_DEV_DEBUG(dev, \"%s: no endpoint\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tret = dsi_host_parse_lane_data(msm_host, endpoint);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"%s: invalid lane configuration %d\\n\",\n\t\t\t__func__, ret);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (of_property_read_bool(np, \"syscon-sfpb\")) {\n\t\tmsm_host->sfpb = syscon_regmap_lookup_by_phandle(np,\n\t\t\t\t\t\"syscon-sfpb\");\n\t\tif (IS_ERR(msm_host->sfpb)) {\n\t\t\tDRM_DEV_ERROR(dev, \"%s: failed to get sfpb regmap\\n\",\n\t\t\t\t__func__);\n\t\t\tret = PTR_ERR(msm_host->sfpb);\n\t\t}\n\t}\n\nerr:\n\tof_node_put(endpoint);\n\n\treturn ret;\n}\n\nstatic int dsi_host_get_id(struct msm_dsi_host *msm_host)\n{\n\tstruct platform_device *pdev = msm_host->pdev;\n\tconst struct msm_dsi_config *cfg = msm_host->cfg_hnd->cfg;\n\tstruct resource *res;\n\tint i, j;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dsi_ctrl\");\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < VARIANTS_MAX; i++)\n\t\tfor (j = 0; j < DSI_MAX; j++)\n\t\t\tif (cfg->io_start[i][j] == res->start)\n\t\t\t\treturn j;\n\n\treturn -EINVAL;\n}\n\nint msm_dsi_host_init(struct msm_dsi *msm_dsi)\n{\n\tstruct msm_dsi_host *msm_host = NULL;\n\tstruct platform_device *pdev = msm_dsi->pdev;\n\tconst struct msm_dsi_config *cfg;\n\tint ret;\n\n\tmsm_host = devm_kzalloc(&pdev->dev, sizeof(*msm_host), GFP_KERNEL);\n\tif (!msm_host) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmsm_host->pdev = pdev;\n\tmsm_dsi->host = &msm_host->base;\n\n\tret = dsi_host_parse_dt(msm_host);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to parse dt\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tmsm_host->ctrl_base = msm_ioremap_size(pdev, \"dsi_ctrl\", &msm_host->ctrl_size);\n\tif (IS_ERR(msm_host->ctrl_base)) {\n\t\tpr_err(\"%s: unable to map Dsi ctrl base\\n\", __func__);\n\t\treturn PTR_ERR(msm_host->ctrl_base);\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tmsm_host->cfg_hnd = dsi_get_config(msm_host);\n\tif (!msm_host->cfg_hnd) {\n\t\tpr_err(\"%s: get config failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tcfg = msm_host->cfg_hnd->cfg;\n\n\tmsm_host->id = dsi_host_get_id(msm_host);\n\tif (msm_host->id < 0) {\n\t\tpr_err(\"%s: unable to identify DSI host index\\n\", __func__);\n\t\treturn msm_host->id;\n\t}\n\n\t \n\tmsm_host->ctrl_base += cfg->io_offset;\n\n\tret = devm_regulator_bulk_get_const(&pdev->dev, cfg->num_regulators,\n\t\t\t\t\t    cfg->regulator_data,\n\t\t\t\t\t    &msm_host->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dsi_clk_init(msm_host);\n\tif (ret) {\n\t\tpr_err(\"%s: unable to initialize dsi clks\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tmsm_host->rx_buf = devm_kzalloc(&pdev->dev, SZ_4K, GFP_KERNEL);\n\tif (!msm_host->rx_buf) {\n\t\tpr_err(\"%s: alloc rx temp buf failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = devm_pm_opp_set_clkname(&pdev->dev, \"byte\");\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = devm_pm_opp_of_add_table(&pdev->dev);\n\tif (ret && ret != -ENODEV) {\n\t\tdev_err(&pdev->dev, \"invalid OPP table in device tree\\n\");\n\t\treturn ret;\n\t}\n\n\tmsm_host->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);\n\tif (!msm_host->irq) {\n\t\tdev_err(&pdev->dev, \"failed to get irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = devm_request_irq(&pdev->dev, msm_host->irq, dsi_host_irq,\n\t\t\tIRQF_TRIGGER_HIGH | IRQF_NO_AUTOEN,\n\t\t\t\"dsi_isr\", msm_host);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ%u: %d\\n\",\n\t\t\t\tmsm_host->irq, ret);\n\t\treturn ret;\n\t}\n\n\tinit_completion(&msm_host->dma_comp);\n\tinit_completion(&msm_host->video_comp);\n\tmutex_init(&msm_host->dev_mutex);\n\tmutex_init(&msm_host->cmd_mutex);\n\tspin_lock_init(&msm_host->intr_lock);\n\n\t \n\tmsm_host->workqueue = alloc_ordered_workqueue(\"dsi_drm_work\", 0);\n\tif (!msm_host->workqueue)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&msm_host->err_work, dsi_err_worker);\n\n\tmsm_dsi->id = msm_host->id;\n\n\tDBG(\"Dsi Host %d initialized\", msm_host->id);\n\treturn 0;\n}\n\nvoid msm_dsi_host_destroy(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tDBG(\"\");\n\tif (msm_host->workqueue) {\n\t\tdestroy_workqueue(msm_host->workqueue);\n\t\tmsm_host->workqueue = NULL;\n\t}\n\n\tmutex_destroy(&msm_host->cmd_mutex);\n\tmutex_destroy(&msm_host->dev_mutex);\n\n\tpm_runtime_disable(&msm_host->pdev->dev);\n}\n\nint msm_dsi_host_modeset_init(struct mipi_dsi_host *host,\n\t\t\t\t\tstruct drm_device *dev)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;\n\tint ret;\n\n\tmsm_host->dev = dev;\n\n\tret = cfg_hnd->ops->tx_buf_alloc(msm_host, SZ_4K);\n\tif (ret) {\n\t\tpr_err(\"%s: alloc tx gem obj failed, %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint msm_dsi_host_register(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tint ret;\n\n\t \n\tif (!msm_host->registered) {\n\t\thost->dev = &msm_host->pdev->dev;\n\t\thost->ops = &dsi_host_ops;\n\t\tret = mipi_dsi_host_register(host);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmsm_host->registered = true;\n\t}\n\n\treturn 0;\n}\n\nvoid msm_dsi_host_unregister(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tif (msm_host->registered) {\n\t\tmipi_dsi_host_unregister(host);\n\t\thost->dev = NULL;\n\t\thost->ops = NULL;\n\t\tmsm_host->registered = false;\n\t}\n}\n\nint msm_dsi_host_xfer_prepare(struct mipi_dsi_host *host,\n\t\t\t\tconst struct mipi_dsi_msg *msg)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;\n\n\t \n\n\t \n\tpm_runtime_get_sync(&msm_host->pdev->dev);\n\tcfg_hnd->ops->link_clk_set_rate(msm_host);\n\tcfg_hnd->ops->link_clk_enable(msm_host);\n\n\t \n\n\tif (!(msg->flags & MIPI_DSI_MSG_USE_LPM))\n\t\tdsi_set_tx_power_mode(0, msm_host);\n\n\tmsm_host->dma_cmd_ctrl_restore = dsi_read(msm_host, REG_DSI_CTRL);\n\tdsi_write(msm_host, REG_DSI_CTRL,\n\t\tmsm_host->dma_cmd_ctrl_restore |\n\t\tDSI_CTRL_CMD_MODE_EN |\n\t\tDSI_CTRL_ENABLE);\n\tdsi_intr_ctrl(msm_host, DSI_IRQ_MASK_CMD_DMA_DONE, 1);\n\n\treturn 0;\n}\n\nvoid msm_dsi_host_xfer_restore(struct mipi_dsi_host *host,\n\t\t\t\tconst struct mipi_dsi_msg *msg)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;\n\n\tdsi_intr_ctrl(msm_host, DSI_IRQ_MASK_CMD_DMA_DONE, 0);\n\tdsi_write(msm_host, REG_DSI_CTRL, msm_host->dma_cmd_ctrl_restore);\n\n\tif (!(msg->flags & MIPI_DSI_MSG_USE_LPM))\n\t\tdsi_set_tx_power_mode(1, msm_host);\n\n\t \n\n\tcfg_hnd->ops->link_clk_disable(msm_host);\n\tpm_runtime_put(&msm_host->pdev->dev);\n}\n\nint msm_dsi_host_cmd_tx(struct mipi_dsi_host *host,\n\t\t\t\tconst struct mipi_dsi_msg *msg)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\treturn dsi_cmds2buf_tx(msm_host, msg);\n}\n\nint msm_dsi_host_cmd_rx(struct mipi_dsi_host *host,\n\t\t\t\tconst struct mipi_dsi_msg *msg)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;\n\tint data_byte, rx_byte, dlen, end;\n\tint short_response, diff, pkt_size, ret = 0;\n\tchar cmd;\n\tint rlen = msg->rx_len;\n\tu8 *buf;\n\n\tif (rlen <= 2) {\n\t\tshort_response = 1;\n\t\tpkt_size = rlen;\n\t\trx_byte = 4;\n\t} else {\n\t\tshort_response = 0;\n\t\tdata_byte = 10;\t \n\t\tif (rlen < data_byte)\n\t\t\tpkt_size = rlen;\n\t\telse\n\t\t\tpkt_size = data_byte;\n\t\trx_byte = data_byte + 6;  \n\t}\n\n\tbuf = msm_host->rx_buf;\n\tend = 0;\n\twhile (!end) {\n\t\tu8 tx[2] = {pkt_size & 0xff, pkt_size >> 8};\n\t\tstruct mipi_dsi_msg max_pkt_size_msg = {\n\t\t\t.channel = msg->channel,\n\t\t\t.type = MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE,\n\t\t\t.tx_len = 2,\n\t\t\t.tx_buf = tx,\n\t\t};\n\n\t\tDBG(\"rlen=%d pkt_size=%d rx_byte=%d\",\n\t\t\trlen, pkt_size, rx_byte);\n\n\t\tret = dsi_cmds2buf_tx(msm_host, &max_pkt_size_msg);\n\t\tif (ret < 2) {\n\t\t\tpr_err(\"%s: Set max pkt size failed, %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((cfg_hnd->major == MSM_DSI_VER_MAJOR_6G) &&\n\t\t\t(cfg_hnd->minor >= MSM_DSI_6G_VER_MINOR_V1_1)) {\n\t\t\t \n\t\t\tdsi_write(msm_host, REG_DSI_RDBK_DATA_CTRL,\n\t\t\t\t\tDSI_RDBK_DATA_CTRL_CLR);\n\t\t\twmb();  \n\t\t\tdsi_write(msm_host, REG_DSI_RDBK_DATA_CTRL, 0);\n\t\t\twmb();  \n\t\t}\n\n\t\tret = dsi_cmds2buf_tx(msm_host, msg);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: Read cmd Tx failed, %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t} else if (ret < msg->tx_len) {\n\t\t\tpr_err(\"%s: Read cmd Tx failed, too short: %d\\n\", __func__, ret);\n\t\t\treturn -ECOMM;\n\t\t}\n\n\t\t \n\t\tdlen = dsi_cmd_dma_rx(msm_host, buf, rx_byte, pkt_size);\n\n\t\tif (dlen <= 0)\n\t\t\treturn 0;\n\n\t\tif (short_response)\n\t\t\tbreak;\n\n\t\tif (rlen <= data_byte) {\n\t\t\tdiff = data_byte - rlen;\n\t\t\tend = 1;\n\t\t} else {\n\t\t\tdiff = 0;\n\t\t\trlen -= data_byte;\n\t\t}\n\n\t\tif (!end) {\n\t\t\tdlen -= 2;  \n\t\t\tdlen -= diff;\n\t\t\tbuf += dlen;\t \n\t\t\tdata_byte = 14;\t \n\t\t\tif (rlen < data_byte)\n\t\t\t\tpkt_size += rlen;\n\t\t\telse\n\t\t\t\tpkt_size += data_byte;\n\t\t\tDBG(\"buf=%p dlen=%d diff=%d\", buf, dlen, diff);\n\t\t}\n\t}\n\n\t \n\tif (pkt_size < 10 && !short_response)\n\t\tbuf = msm_host->rx_buf + (10 - rlen);\n\telse\n\t\tbuf = msm_host->rx_buf;\n\n\tcmd = buf[0];\n\tswitch (cmd) {\n\tcase MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT:\n\t\tpr_err(\"%s: rx ACK_ERR_PACLAGE\\n\", __func__);\n\t\tret = 0;\n\t\tbreak;\n\tcase MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE:\n\tcase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE:\n\t\tret = dsi_short_read1_resp(buf, msg);\n\t\tbreak;\n\tcase MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE:\n\tcase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE:\n\t\tret = dsi_short_read2_resp(buf, msg);\n\t\tbreak;\n\tcase MIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE:\n\tcase MIPI_DSI_RX_DCS_LONG_READ_RESPONSE:\n\t\tret = dsi_long_read_resp(buf, msg);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s:Invalid response cmd\\n\", __func__);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nvoid msm_dsi_host_cmd_xfer_commit(struct mipi_dsi_host *host, u32 dma_base,\n\t\t\t\t  u32 len)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tdsi_write(msm_host, REG_DSI_DMA_BASE, dma_base);\n\tdsi_write(msm_host, REG_DSI_DMA_LEN, len);\n\tdsi_write(msm_host, REG_DSI_TRIG_DMA, 1);\n\n\t \n\twmb();\n}\n\nvoid msm_dsi_host_set_phy_mode(struct mipi_dsi_host *host,\n\tstruct msm_dsi_phy *src_phy)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tmsm_host->cphy_mode = src_phy->cphy_mode;\n}\n\nvoid msm_dsi_host_reset_phy(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tDBG(\"\");\n\tdsi_write(msm_host, REG_DSI_PHY_RESET, DSI_PHY_RESET_RESET);\n\t \n\twmb();\n\tudelay(1000);\n\tdsi_write(msm_host, REG_DSI_PHY_RESET, 0);\n\tudelay(100);\n}\n\nvoid msm_dsi_host_get_phy_clk_req(struct mipi_dsi_host *host,\n\t\t\tstruct msm_dsi_phy_clk_request *clk_req,\n\t\t\tbool is_bonded_dsi)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;\n\tint ret;\n\n\tret = cfg_hnd->ops->calc_clk_rate(msm_host, is_bonded_dsi);\n\tif (ret) {\n\t\tpr_err(\"%s: unable to calc clk rate, %d\\n\", __func__, ret);\n\t\treturn;\n\t}\n\n\t \n\tif (msm_host->cphy_mode)\n\t\tclk_req->bitclk_rate = msm_host->byte_clk_rate * 7;\n\telse\n\t\tclk_req->bitclk_rate = msm_host->byte_clk_rate * 8;\n\tclk_req->escclk_rate = msm_host->esc_clk_rate;\n}\n\nvoid msm_dsi_host_enable_irq(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tenable_irq(msm_host->irq);\n}\n\nvoid msm_dsi_host_disable_irq(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tdisable_irq(msm_host->irq);\n}\n\nint msm_dsi_host_enable(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tdsi_op_mode_config(msm_host,\n\t\t!!(msm_host->mode_flags & MIPI_DSI_MODE_VIDEO), true);\n\n\t \n\t \n\tmsm_host->enabled = true;\n\treturn 0;\n}\n\nint msm_dsi_host_disable(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tmsm_host->enabled = false;\n\tdsi_op_mode_config(msm_host,\n\t\t!!(msm_host->mode_flags & MIPI_DSI_MODE_VIDEO), false);\n\n\t \n\tdsi_sw_reset(msm_host);\n\n\treturn 0;\n}\n\nstatic void msm_dsi_sfpb_config(struct msm_dsi_host *msm_host, bool enable)\n{\n\tenum sfpb_ahb_arb_master_port_en en;\n\n\tif (!msm_host->sfpb)\n\t\treturn;\n\n\ten = enable ? SFPB_MASTER_PORT_ENABLE : SFPB_MASTER_PORT_DISABLE;\n\n\tregmap_update_bits(msm_host->sfpb, REG_SFPB_GPREG,\n\t\t\tSFPB_GPREG_MASTER_PORT_EN__MASK,\n\t\t\tSFPB_GPREG_MASTER_PORT_EN(en));\n}\n\nint msm_dsi_host_power_on(struct mipi_dsi_host *host,\n\t\t\tstruct msm_dsi_phy_shared_timings *phy_shared_timings,\n\t\t\tbool is_bonded_dsi, struct msm_dsi_phy *phy)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;\n\tint ret = 0;\n\n\tmutex_lock(&msm_host->dev_mutex);\n\tif (msm_host->power_on) {\n\t\tDBG(\"dsi host already on\");\n\t\tgoto unlock_ret;\n\t}\n\n\tmsm_host->byte_intf_clk_rate = msm_host->byte_clk_rate;\n\tif (phy_shared_timings->byte_intf_clk_div_2)\n\t\tmsm_host->byte_intf_clk_rate /= 2;\n\n\tmsm_dsi_sfpb_config(msm_host, true);\n\n\tret = regulator_bulk_enable(msm_host->cfg_hnd->cfg->num_regulators,\n\t\t\t\t    msm_host->supplies);\n\tif (ret) {\n\t\tpr_err(\"%s:Failed to enable vregs.ret=%d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto unlock_ret;\n\t}\n\n\tpm_runtime_get_sync(&msm_host->pdev->dev);\n\tret = cfg_hnd->ops->link_clk_set_rate(msm_host);\n\tif (!ret)\n\t\tret = cfg_hnd->ops->link_clk_enable(msm_host);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to enable link clocks. ret=%d\\n\",\n\t\t       __func__, ret);\n\t\tgoto fail_disable_reg;\n\t}\n\n\tret = pinctrl_pm_select_default_state(&msm_host->pdev->dev);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to set pinctrl default state, %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto fail_disable_clk;\n\t}\n\n\tdsi_timing_setup(msm_host, is_bonded_dsi);\n\tdsi_sw_reset(msm_host);\n\tdsi_ctrl_enable(msm_host, phy_shared_timings, phy);\n\n\tif (msm_host->disp_en_gpio)\n\t\tgpiod_set_value(msm_host->disp_en_gpio, 1);\n\n\tmsm_host->power_on = true;\n\tmutex_unlock(&msm_host->dev_mutex);\n\n\treturn 0;\n\nfail_disable_clk:\n\tcfg_hnd->ops->link_clk_disable(msm_host);\n\tpm_runtime_put(&msm_host->pdev->dev);\nfail_disable_reg:\n\tregulator_bulk_disable(msm_host->cfg_hnd->cfg->num_regulators,\n\t\t\t       msm_host->supplies);\nunlock_ret:\n\tmutex_unlock(&msm_host->dev_mutex);\n\treturn ret;\n}\n\nint msm_dsi_host_power_off(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tconst struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;\n\n\tmutex_lock(&msm_host->dev_mutex);\n\tif (!msm_host->power_on) {\n\t\tDBG(\"dsi host already off\");\n\t\tgoto unlock_ret;\n\t}\n\n\tdsi_ctrl_disable(msm_host);\n\n\tif (msm_host->disp_en_gpio)\n\t\tgpiod_set_value(msm_host->disp_en_gpio, 0);\n\n\tpinctrl_pm_select_sleep_state(&msm_host->pdev->dev);\n\n\tcfg_hnd->ops->link_clk_disable(msm_host);\n\tpm_runtime_put(&msm_host->pdev->dev);\n\n\tregulator_bulk_disable(msm_host->cfg_hnd->cfg->num_regulators,\n\t\t\t       msm_host->supplies);\n\n\tmsm_dsi_sfpb_config(msm_host, false);\n\n\tDBG(\"-\");\n\n\tmsm_host->power_on = false;\n\nunlock_ret:\n\tmutex_unlock(&msm_host->dev_mutex);\n\treturn 0;\n}\n\nint msm_dsi_host_set_display_mode(struct mipi_dsi_host *host,\n\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tif (msm_host->mode) {\n\t\tdrm_mode_destroy(msm_host->dev, msm_host->mode);\n\t\tmsm_host->mode = NULL;\n\t}\n\n\tmsm_host->mode = drm_mode_duplicate(msm_host->dev, mode);\n\tif (!msm_host->mode) {\n\t\tpr_err(\"%s: cannot duplicate mode\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nenum drm_mode_status msm_dsi_host_check_dsc(struct mipi_dsi_host *host,\n\t\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tstruct drm_dsc_config *dsc = msm_host->dsc;\n\tint pic_width = mode->hdisplay;\n\tint pic_height = mode->vdisplay;\n\n\tif (!msm_host->dsc)\n\t\treturn MODE_OK;\n\n\tif (pic_width % dsc->slice_width) {\n\t\tpr_err(\"DSI: pic_width %d has to be multiple of slice %d\\n\",\n\t\t       pic_width, dsc->slice_width);\n\t\treturn MODE_H_ILLEGAL;\n\t}\n\n\tif (pic_height % dsc->slice_height) {\n\t\tpr_err(\"DSI: pic_height %d has to be multiple of slice %d\\n\",\n\t\t       pic_height, dsc->slice_height);\n\t\treturn MODE_V_ILLEGAL;\n\t}\n\n\treturn MODE_OK;\n}\n\nunsigned long msm_dsi_host_get_mode_flags(struct mipi_dsi_host *host)\n{\n\treturn to_msm_dsi_host(host)->mode_flags;\n}\n\nvoid msm_dsi_host_snapshot(struct msm_disp_state *disp_state, struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\tpm_runtime_get_sync(&msm_host->pdev->dev);\n\n\tmsm_disp_snapshot_add_block(disp_state, msm_host->ctrl_size,\n\t\t\tmsm_host->ctrl_base, \"dsi%d_ctrl\", msm_host->id);\n\n\tpm_runtime_put_sync(&msm_host->pdev->dev);\n}\n\nstatic void msm_dsi_host_video_test_pattern_setup(struct msm_dsi_host *msm_host)\n{\n\tu32 reg;\n\n\treg = dsi_read(msm_host, REG_DSI_TEST_PATTERN_GEN_CTRL);\n\n\tdsi_write(msm_host, REG_DSI_TEST_PATTERN_GEN_VIDEO_INIT_VAL, 0xff);\n\t \n\tdsi_write(msm_host, REG_DSI_TPG_MAIN_CONTROL,\n\t\t\tDSI_TPG_MAIN_CONTROL_CHECKERED_RECTANGLE_PATTERN);\n\t \n\tdsi_write(msm_host, REG_DSI_TPG_VIDEO_CONFIG,\n\t\t\tDSI_TPG_VIDEO_CONFIG_BPP(VIDEO_CONFIG_24BPP) |\n\t\t\tDSI_TPG_VIDEO_CONFIG_RGB);\n\n\treg |= DSI_TEST_PATTERN_GEN_CTRL_VIDEO_PATTERN_SEL(VID_MDSS_GENERAL_PATTERN);\n\tdsi_write(msm_host, REG_DSI_TEST_PATTERN_GEN_CTRL, reg);\n\n\tDBG(\"Video test pattern setup done\\n\");\n}\n\nstatic void msm_dsi_host_cmd_test_pattern_setup(struct msm_dsi_host *msm_host)\n{\n\tu32 reg;\n\n\treg = dsi_read(msm_host, REG_DSI_TEST_PATTERN_GEN_CTRL);\n\n\t \n\tdsi_write(msm_host, REG_DSI_TEST_PATTERN_GEN_CMD_MDP_INIT_VAL0, 0xff);\n\n\treg |= DSI_TEST_PATTERN_GEN_CTRL_CMD_MDP_STREAM0_PATTERN_SEL(CMD_MDP_MDSS_GENERAL_PATTERN);\n\n\tdsi_write(msm_host, REG_DSI_TEST_PATTERN_GEN_CTRL, reg);\n\t \n\tdsi_write(msm_host, REG_DSI_TPG_MAIN_CONTROL2,\n\t\t\tDSI_TPG_MAIN_CONTROL2_CMD_MDP0_CHECKERED_RECTANGLE_PATTERN);\n\n\tDBG(\"Cmd test pattern setup done\\n\");\n}\n\nvoid msm_dsi_host_test_pattern_en(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\tbool is_video_mode = !!(msm_host->mode_flags & MIPI_DSI_MODE_VIDEO);\n\tu32 reg;\n\n\tif (is_video_mode)\n\t\tmsm_dsi_host_video_test_pattern_setup(msm_host);\n\telse\n\t\tmsm_dsi_host_cmd_test_pattern_setup(msm_host);\n\n\treg = dsi_read(msm_host, REG_DSI_TEST_PATTERN_GEN_CTRL);\n\t \n\tdsi_write(msm_host, REG_DSI_TEST_PATTERN_GEN_CTRL, (reg | DSI_TEST_PATTERN_GEN_CTRL_EN));\n\n\t \n\tif (!is_video_mode)\n\t\tdsi_write(msm_host, REG_DSI_TEST_PATTERN_GEN_CMD_STREAM0_TRIGGER,\n\t\t\t\tDSI_TEST_PATTERN_GEN_CMD_STREAM0_TRIGGER_SW_TRIGGER);\n}\n\nstruct drm_dsc_config *msm_dsi_host_get_dsc_config(struct mipi_dsi_host *host)\n{\n\tstruct msm_dsi_host *msm_host = to_msm_dsi_host(host);\n\n\treturn msm_host->dsc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}