{
  "module_name": "msm_ringbuffer.c",
  "hash_id": "2597323ae96e3d3bc8deb6d82671460dcaa86765ca718920abb7a9c6f384e3d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_ringbuffer.c",
  "human_readable_source": "\n \n\n#include \"msm_ringbuffer.h\"\n#include \"msm_gpu.h\"\n\nstatic uint num_hw_submissions = 8;\nMODULE_PARM_DESC(num_hw_submissions, \"The max # of jobs to write into ringbuffer (default 8)\");\nmodule_param(num_hw_submissions, uint, 0600);\n\nstatic struct dma_fence *msm_job_run(struct drm_sched_job *job)\n{\n\tstruct msm_gem_submit *submit = to_msm_submit(job);\n\tstruct msm_fence_context *fctx = submit->ring->fctx;\n\tstruct msm_gpu *gpu = submit->gpu;\n\tstruct msm_drm_private *priv = gpu->dev->dev_private;\n\tint i;\n\n\tmsm_fence_init(submit->hw_fence, fctx);\n\n\tsubmit->seqno = submit->hw_fence->seqno;\n\n\tmutex_lock(&priv->lru.lock);\n\n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\tstruct drm_gem_object *obj = submit->bos[i].obj;\n\n\t\tmsm_gem_unpin_active(obj);\n\t\tsubmit->bos[i].flags &= ~BO_PINNED;\n\t}\n\n\tmutex_unlock(&priv->lru.lock);\n\n\tmsm_gpu_submit(gpu, submit);\n\n\treturn dma_fence_get(submit->hw_fence);\n}\n\nstatic void msm_job_free(struct drm_sched_job *job)\n{\n\tstruct msm_gem_submit *submit = to_msm_submit(job);\n\n\tdrm_sched_job_cleanup(job);\n\tmsm_gem_submit_put(submit);\n}\n\nstatic const struct drm_sched_backend_ops msm_sched_ops = {\n\t.run_job = msm_job_run,\n\t.free_job = msm_job_free\n};\n\nstruct msm_ringbuffer *msm_ringbuffer_new(struct msm_gpu *gpu, int id,\n\t\tvoid *memptrs, uint64_t memptrs_iova)\n{\n\tstruct msm_ringbuffer *ring;\n\tlong sched_timeout;\n\tchar name[32];\n\tint ret;\n\n\t \n\tBUILD_BUG_ON(!is_power_of_2(MSM_GPU_RINGBUFFER_SZ));\n\n\tring = kzalloc(sizeof(*ring), GFP_KERNEL);\n\tif (!ring) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tring->gpu = gpu;\n\tring->id = id;\n\n\tring->start = msm_gem_kernel_new(gpu->dev, MSM_GPU_RINGBUFFER_SZ,\n\t\tcheck_apriv(gpu, MSM_BO_WC | MSM_BO_GPU_READONLY),\n\t\tgpu->aspace, &ring->bo, &ring->iova);\n\n\tif (IS_ERR(ring->start)) {\n\t\tret = PTR_ERR(ring->start);\n\t\tring->start = NULL;\n\t\tgoto fail;\n\t}\n\n\tmsm_gem_object_set_name(ring->bo, \"ring%d\", id);\n\n\tring->end   = ring->start + (MSM_GPU_RINGBUFFER_SZ >> 2);\n\tring->next  = ring->start;\n\tring->cur   = ring->start;\n\n\tring->memptrs = memptrs;\n\tring->memptrs_iova = memptrs_iova;\n\n\t  \n\tsched_timeout = MAX_SCHEDULE_TIMEOUT;\n\n\tret = drm_sched_init(&ring->sched, &msm_sched_ops,\n\t\t\tnum_hw_submissions, 0, sched_timeout,\n\t\t\tNULL, NULL, to_msm_bo(ring->bo)->name, gpu->dev->dev);\n\tif (ret) {\n\t\tgoto fail;\n\t}\n\n\tINIT_LIST_HEAD(&ring->submits);\n\tspin_lock_init(&ring->submit_lock);\n\tspin_lock_init(&ring->preempt_lock);\n\n\tsnprintf(name, sizeof(name), \"gpu-ring-%d\", ring->id);\n\n\tring->fctx = msm_fence_context_alloc(gpu->dev, &ring->memptrs->fence, name);\n\n\treturn ring;\n\nfail:\n\tmsm_ringbuffer_destroy(ring);\n\treturn ERR_PTR(ret);\n}\n\nvoid msm_ringbuffer_destroy(struct msm_ringbuffer *ring)\n{\n\tif (IS_ERR_OR_NULL(ring))\n\t\treturn;\n\n\tdrm_sched_fini(&ring->sched);\n\n\tmsm_fence_context_free(ring->fctx);\n\n\tmsm_gem_kernel_put(ring->bo, ring->gpu->aspace);\n\n\tkfree(ring);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}