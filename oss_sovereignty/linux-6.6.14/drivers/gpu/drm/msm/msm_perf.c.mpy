{
  "module_name": "msm_perf.c",
  "hash_id": "b96b548ea02af4f0994d5ab6c34c9e393a44f9671492a57fa41c4d008b0e856d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_perf.c",
  "human_readable_source": "\n \n\n \n\n#ifdef CONFIG_DEBUG_FS\n\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_file.h>\n\n#include \"msm_drv.h\"\n#include \"msm_gpu.h\"\n\nstruct msm_perf_state {\n\tstruct drm_device *dev;\n\n\tbool open;\n\tint cnt;\n\tstruct mutex read_lock;\n\n\tchar buf[256];\n\tint buftot, bufpos;\n\n\tunsigned long next_jiffies;\n};\n\n#define SAMPLE_TIME (HZ/4)\n\n \nstatic int wait_sample(struct msm_perf_state *perf)\n{\n\tunsigned long start_jiffies = jiffies;\n\n\tif (time_after(perf->next_jiffies, start_jiffies)) {\n\t\tunsigned long remaining_jiffies =\n\t\t\tperf->next_jiffies - start_jiffies;\n\t\tint ret = schedule_timeout_interruptible(remaining_jiffies);\n\t\tif (ret > 0) {\n\t\t\t \n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t}\n\tperf->next_jiffies += SAMPLE_TIME;\n\treturn 0;\n}\n\nstatic int refill_buf(struct msm_perf_state *perf)\n{\n\tstruct msm_drm_private *priv = perf->dev->dev_private;\n\tstruct msm_gpu *gpu = priv->gpu;\n\tchar *ptr = perf->buf;\n\tint rem = sizeof(perf->buf);\n\tint i, n;\n\n\tif ((perf->cnt++ % 32) == 0) {\n\t\t \n\t\tn = snprintf(ptr, rem, \"%%BUSY\");\n\t\tptr += n;\n\t\trem -= n;\n\n\t\tfor (i = 0; i < gpu->num_perfcntrs; i++) {\n\t\t\tconst struct msm_gpu_perfcntr *perfcntr = &gpu->perfcntrs[i];\n\t\t\tn = snprintf(ptr, rem, \"\\t%s\", perfcntr->name);\n\t\t\tptr += n;\n\t\t\trem -= n;\n\t\t}\n\t} else {\n\t\t \n\t\tuint32_t activetime = 0, totaltime = 0;\n\t\tuint32_t cntrs[5];\n\t\tuint32_t val;\n\t\tint ret;\n\n\t\t \n\t\tret = wait_sample(perf);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = msm_gpu_perfcntr_sample(gpu, &activetime, &totaltime,\n\t\t\t\tARRAY_SIZE(cntrs), cntrs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval = totaltime ? 1000 * activetime / totaltime : 0;\n\t\tn = snprintf(ptr, rem, \"%3d.%d%%\", val / 10, val % 10);\n\t\tptr += n;\n\t\trem -= n;\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\t \n\t\t\tval = cntrs[i] / 10000;\n\t\t\tn = snprintf(ptr, rem, \"\\t%5d.%02d\",\n\t\t\t\t\tval / 100, val % 100);\n\t\t\tptr += n;\n\t\t\trem -= n;\n\t\t}\n\t}\n\n\tn = snprintf(ptr, rem, \"\\n\");\n\tptr += n;\n\trem -= n;\n\n\tperf->bufpos = 0;\n\tperf->buftot = ptr - perf->buf;\n\n\treturn 0;\n}\n\nstatic ssize_t perf_read(struct file *file, char __user *buf,\n\t\tsize_t sz, loff_t *ppos)\n{\n\tstruct msm_perf_state *perf = file->private_data;\n\tint n = 0, ret = 0;\n\n\tmutex_lock(&perf->read_lock);\n\n\tif (perf->bufpos >= perf->buftot) {\n\t\tret = refill_buf(perf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tn = min((int)sz, perf->buftot - perf->bufpos);\n\tif (copy_to_user(buf, &perf->buf[perf->bufpos], n)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tperf->bufpos += n;\n\t*ppos += n;\n\nout:\n\tmutex_unlock(&perf->read_lock);\n\tif (ret)\n\t\treturn ret;\n\treturn n;\n}\n\nstatic int perf_open(struct inode *inode, struct file *file)\n{\n\tstruct msm_perf_state *perf = inode->i_private;\n\tstruct drm_device *dev = perf->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct msm_gpu *gpu = priv->gpu;\n\tint ret = 0;\n\n\tif (!gpu)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&gpu->lock);\n\n\tif (perf->open) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tfile->private_data = perf;\n\tperf->open = true;\n\tperf->cnt = 0;\n\tperf->buftot = 0;\n\tperf->bufpos = 0;\n\tmsm_gpu_perfcntr_start(gpu);\n\tperf->next_jiffies = jiffies + SAMPLE_TIME;\n\nout:\n\tmutex_unlock(&gpu->lock);\n\treturn ret;\n}\n\nstatic int perf_release(struct inode *inode, struct file *file)\n{\n\tstruct msm_perf_state *perf = inode->i_private;\n\tstruct msm_drm_private *priv = perf->dev->dev_private;\n\tmsm_gpu_perfcntr_stop(priv->gpu);\n\tperf->open = false;\n\treturn 0;\n}\n\n\nstatic const struct file_operations perf_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.open = perf_open,\n\t.read = perf_read,\n\t.llseek = no_llseek,\n\t.release = perf_release,\n};\n\nint msm_perf_debugfs_init(struct drm_minor *minor)\n{\n\tstruct msm_drm_private *priv = minor->dev->dev_private;\n\tstruct msm_perf_state *perf;\n\n\t \n\tif (priv->perf)\n\t\treturn 0;\n\n\tperf = kzalloc(sizeof(*perf), GFP_KERNEL);\n\tif (!perf)\n\t\treturn -ENOMEM;\n\n\tperf->dev = minor->dev;\n\n\tmutex_init(&perf->read_lock);\n\tpriv->perf = perf;\n\n\tdebugfs_create_file(\"perf\", S_IFREG | S_IRUGO, minor->debugfs_root,\n\t\t\t    perf, &perf_debugfs_fops);\n\treturn 0;\n}\n\nvoid msm_perf_debugfs_cleanup(struct msm_drm_private *priv)\n{\n\tstruct msm_perf_state *perf = priv->perf;\n\n\tif (!perf)\n\t\treturn;\n\n\tpriv->perf = NULL;\n\n\tmutex_destroy(&perf->read_lock);\n\n\tkfree(perf);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}