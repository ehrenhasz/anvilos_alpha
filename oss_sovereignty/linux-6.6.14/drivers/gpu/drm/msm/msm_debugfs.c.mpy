{
  "module_name": "msm_debugfs.c",
  "hash_id": "7325948520d543652bae520cd57909ad83be5441e26bbcda22857babade9944f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_debugfs.c",
  "human_readable_source": "\n \n\n#ifdef CONFIG_DEBUG_FS\n\n#include <linux/debugfs.h>\n#include <linux/fault-inject.h>\n\n#include <drm/drm_debugfs.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_file.h>\n#include <drm/drm_framebuffer.h>\n\n#include \"msm_drv.h\"\n#include \"msm_gpu.h\"\n#include \"msm_kms.h\"\n#include \"msm_debugfs.h\"\n#include \"disp/msm_disp_snapshot.h\"\n\n \n\nstruct msm_gpu_show_priv {\n\tstruct msm_gpu_state *state;\n\tstruct drm_device *dev;\n};\n\nstatic int msm_gpu_show(struct seq_file *m, void *arg)\n{\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\tstruct msm_gpu_show_priv *show_priv = m->private;\n\tstruct msm_drm_private *priv = show_priv->dev->dev_private;\n\tstruct msm_gpu *gpu = priv->gpu;\n\tint ret;\n\n\tret = mutex_lock_interruptible(&gpu->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_printf(&p, \"%s Status:\\n\", gpu->name);\n\tgpu->funcs->show(gpu, show_priv->state, &p);\n\n\tmutex_unlock(&gpu->lock);\n\n\treturn 0;\n}\n\nstatic int msm_gpu_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct msm_gpu_show_priv *show_priv = m->private;\n\tstruct msm_drm_private *priv = show_priv->dev->dev_private;\n\tstruct msm_gpu *gpu = priv->gpu;\n\n\tmutex_lock(&gpu->lock);\n\tgpu->funcs->gpu_state_put(show_priv->state);\n\tmutex_unlock(&gpu->lock);\n\n\tkfree(show_priv);\n\n\treturn single_release(inode, file);\n}\n\nstatic int msm_gpu_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_device *dev = inode->i_private;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct msm_gpu *gpu = priv->gpu;\n\tstruct msm_gpu_show_priv *show_priv;\n\tint ret;\n\n\tif (!gpu || !gpu->funcs->gpu_state_get)\n\t\treturn -ENODEV;\n\n\tshow_priv = kmalloc(sizeof(*show_priv), GFP_KERNEL);\n\tif (!show_priv)\n\t\treturn -ENOMEM;\n\n\tret = mutex_lock_interruptible(&gpu->lock);\n\tif (ret)\n\t\tgoto free_priv;\n\n\tpm_runtime_get_sync(&gpu->pdev->dev);\n\tmsm_gpu_hw_init(gpu);\n\tshow_priv->state = gpu->funcs->gpu_state_get(gpu);\n\tpm_runtime_put_sync(&gpu->pdev->dev);\n\n\tmutex_unlock(&gpu->lock);\n\n\tif (IS_ERR(show_priv->state)) {\n\t\tret = PTR_ERR(show_priv->state);\n\t\tgoto free_priv;\n\t}\n\n\tshow_priv->dev = dev;\n\n\tret = single_open(file, msm_gpu_show, show_priv);\n\tif (ret)\n\t\tgoto free_priv;\n\n\treturn 0;\n\nfree_priv:\n\tkfree(show_priv);\n\treturn ret;\n}\n\nstatic const struct file_operations msm_gpu_fops = {\n\t.owner = THIS_MODULE,\n\t.open = msm_gpu_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = msm_gpu_release,\n};\n\n \n\nstatic int msm_kms_show(struct seq_file *m, void *arg)\n{\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\tstruct msm_disp_state *state = m->private;\n\n\tmsm_disp_state_print(state, &p);\n\n\treturn 0;\n}\n\nstatic int msm_kms_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct msm_disp_state *state = m->private;\n\n\tmsm_disp_state_free(state);\n\n\treturn single_release(inode, file);\n}\n\nstatic int msm_kms_open(struct inode *inode, struct file *file)\n{\n\tstruct drm_device *dev = inode->i_private;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct msm_disp_state *state;\n\tint ret;\n\n\tif (!priv->kms)\n\t\treturn -ENODEV;\n\n\tret = mutex_lock_interruptible(&priv->kms->dump_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tstate = msm_disp_snapshot_state_sync(priv->kms);\n\n\tmutex_unlock(&priv->kms->dump_mutex);\n\n\tif (IS_ERR(state)) {\n\t\treturn PTR_ERR(state);\n\t}\n\n\tret = single_open(file, msm_kms_show, state);\n\tif (ret) {\n\t\tmsm_disp_state_free(state);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct file_operations msm_kms_fops = {\n\t.owner = THIS_MODULE,\n\t.open = msm_kms_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = msm_kms_release,\n};\n\n \n\nstatic unsigned long last_shrink_freed;\n\nstatic int\nshrink_get(void *data, u64 *val)\n{\n\t*val = last_shrink_freed;\n\n\treturn 0;\n}\n\nstatic int\nshrink_set(void *data, u64 val)\n{\n\tstruct drm_device *dev = data;\n\n\tlast_shrink_freed = msm_gem_shrinker_shrink(dev, val);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(shrink_fops,\n\t\t\t shrink_get, shrink_set,\n\t\t\t \"0x%08llx\\n\");\n\n\nstatic int msm_gem_show(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tint ret;\n\n\tret = mutex_lock_interruptible(&priv->obj_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tmsm_gem_describe_objects(&priv->objects, m);\n\n\tmutex_unlock(&priv->obj_lock);\n\n\treturn 0;\n}\n\nstatic int msm_mm_show(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tdrm_mm_print(&dev->vma_offset_manager->vm_addr_space_mm, &p);\n\n\treturn 0;\n}\n\nstatic int msm_fb_show(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tstruct drm_framebuffer *fb, *fbdev_fb = NULL;\n\n\tif (dev->fb_helper && dev->fb_helper->fb) {\n\t\tseq_printf(m, \"fbcon \");\n\t\tfbdev_fb = dev->fb_helper->fb;\n\t\tmsm_framebuffer_describe(fbdev_fb, m);\n\t}\n\n\tmutex_lock(&dev->mode_config.fb_lock);\n\tlist_for_each_entry(fb, &dev->mode_config.fb_list, head) {\n\t\tif (fb == fbdev_fb)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"user \");\n\t\tmsm_framebuffer_describe(fb, m);\n\t}\n\tmutex_unlock(&dev->mode_config.fb_lock);\n\n\treturn 0;\n}\n\nstatic struct drm_info_list msm_debugfs_list[] = {\n\t\t{\"gem\", msm_gem_show},\n\t\t{ \"mm\", msm_mm_show },\n\t\t{ \"fb\", msm_fb_show },\n};\n\nstatic int late_init_minor(struct drm_minor *minor)\n{\n\tint ret;\n\n\tif (!minor)\n\t\treturn 0;\n\n\tret = msm_rd_debugfs_init(minor);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(minor->dev->dev, \"could not install rd debugfs\\n\");\n\t\treturn ret;\n\t}\n\n\tret = msm_perf_debugfs_init(minor);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(minor->dev->dev, \"could not install perf debugfs\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint msm_debugfs_late_init(struct drm_device *dev)\n{\n\tint ret;\n\tret = late_init_minor(dev->primary);\n\tif (ret)\n\t\treturn ret;\n\tret = late_init_minor(dev->render);\n\treturn ret;\n}\n\nvoid msm_debugfs_init(struct drm_minor *minor)\n{\n\tstruct drm_device *dev = minor->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct dentry *gpu_devfreq;\n\n\tdrm_debugfs_create_files(msm_debugfs_list,\n\t\t\t\t ARRAY_SIZE(msm_debugfs_list),\n\t\t\t\t minor->debugfs_root, minor);\n\n\tdebugfs_create_file(\"gpu\", S_IRUSR, minor->debugfs_root,\n\t\tdev, &msm_gpu_fops);\n\n\tdebugfs_create_file(\"kms\", S_IRUSR, minor->debugfs_root,\n\t\tdev, &msm_kms_fops);\n\n\tdebugfs_create_u32(\"hangcheck_period_ms\", 0600, minor->debugfs_root,\n\t\t&priv->hangcheck_period);\n\n\tdebugfs_create_bool(\"disable_err_irq\", 0600, minor->debugfs_root,\n\t\t&priv->disable_err_irq);\n\n\tdebugfs_create_file(\"shrink\", S_IRWXU, minor->debugfs_root,\n\t\tdev, &shrink_fops);\n\n\tgpu_devfreq = debugfs_create_dir(\"devfreq\", minor->debugfs_root);\n\n\tdebugfs_create_bool(\"idle_clamp\",0600, gpu_devfreq,\n\t\t\t    &priv->gpu_clamp_to_idle);\n\n\tdebugfs_create_u32(\"upthreshold\",0600, gpu_devfreq,\n\t\t\t   &priv->gpu_devfreq_config.upthreshold);\n\n\tdebugfs_create_u32(\"downdifferential\",0600, gpu_devfreq,\n\t\t\t   &priv->gpu_devfreq_config.downdifferential);\n\n\tif (priv->kms && priv->kms->funcs->debugfs_init)\n\t\tpriv->kms->funcs->debugfs_init(priv->kms, minor);\n\n#ifdef CONFIG_FAULT_INJECTION\n\tfault_create_debugfs_attr(\"fail_gem_alloc\", minor->debugfs_root,\n\t\t\t\t  &fail_gem_alloc);\n\tfault_create_debugfs_attr(\"fail_gem_iova\", minor->debugfs_root,\n\t\t\t\t  &fail_gem_iova);\n#endif\n}\n#endif\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}