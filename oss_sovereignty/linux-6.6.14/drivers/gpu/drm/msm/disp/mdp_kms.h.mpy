{
  "module_name": "mdp_kms.h",
  "hash_id": "802341e7b8a2bbb2a9910a3c664496c54a9074d9c22d46f124406967b276a238",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp_kms.h",
  "human_readable_source": " \n \n\n#ifndef __MDP_KMS_H__\n#define __MDP_KMS_H__\n\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#include \"msm_drv.h\"\n#include \"msm_kms.h\"\n#include \"mdp_common.xml.h\"\n\nstruct mdp_kms;\n\nstruct mdp_kms_funcs {\n\tstruct msm_kms_funcs base;\n\tvoid (*set_irqmask)(struct mdp_kms *mdp_kms, uint32_t irqmask,\n\t\tuint32_t old_irqmask);\n};\n\nstruct mdp_kms {\n\tstruct msm_kms base;\n\n\tconst struct mdp_kms_funcs *funcs;\n\n\t \n\tbool in_irq;\n\tstruct list_head irq_list;     \n\tuint32_t vblank_mask;          \n\tuint32_t cur_irq_mask;         \n};\n#define to_mdp_kms(x) container_of(x, struct mdp_kms, base)\n\nstatic inline int mdp_kms_init(struct mdp_kms *mdp_kms,\n\t\tconst struct mdp_kms_funcs *funcs)\n{\n\tmdp_kms->funcs = funcs;\n\tINIT_LIST_HEAD(&mdp_kms->irq_list);\n\treturn msm_kms_init(&mdp_kms->base, &funcs->base);\n}\n\nstatic inline void mdp_kms_destroy(struct mdp_kms *mdp_kms)\n{\n\tmsm_kms_destroy(&mdp_kms->base);\n}\n\n \n\n \nstruct mdp_irq {\n\tstruct list_head node;\n\tuint32_t irqmask;\n\tbool registered;\n\tvoid (*irq)(struct mdp_irq *irq, uint32_t irqstatus);\n};\n\nvoid mdp_dispatch_irqs(struct mdp_kms *mdp_kms, uint32_t status);\nvoid mdp_update_vblank_mask(struct mdp_kms *mdp_kms, uint32_t mask, bool enable);\nvoid mdp_irq_wait(struct mdp_kms *mdp_kms, uint32_t irqmask);\nvoid mdp_irq_register(struct mdp_kms *mdp_kms, struct mdp_irq *irq);\nvoid mdp_irq_unregister(struct mdp_kms *mdp_kms, struct mdp_irq *irq);\nvoid mdp_irq_update(struct mdp_kms *mdp_kms);\n\n \n\nstruct mdp_format {\n\tstruct msm_format base;\n\tenum mdp_bpc bpc_r, bpc_g, bpc_b;\n\tenum mdp_bpc_alpha bpc_a;\n\tuint8_t unpack[4];\n\tbool alpha_enable, unpack_tight;\n\tuint8_t cpp, unpack_count;\n\tenum mdp_fetch_type fetch_type;\n\tenum mdp_chroma_samp_type chroma_sample;\n\tbool is_yuv;\n};\n#define to_mdp_format(x) container_of(x, struct mdp_format, base)\n#define MDP_FORMAT_IS_YUV(mdp_format) ((mdp_format)->is_yuv)\n\nuint32_t mdp_get_formats(uint32_t *formats, uint32_t max_formats, bool rgb_only);\nconst struct msm_format *mdp_get_format(struct msm_kms *kms, uint32_t format, uint64_t modifier);\n\n \n#define MDP_CAP_SMP\t\tBIT(0)\t \n#define MDP_CAP_DSC\t\tBIT(1)\t \n#define MDP_CAP_CDM\t\tBIT(2)\t \n#define MDP_CAP_SRC_SPLIT\tBIT(3)\t \n\n \n#define MDP_PIPE_CAP_HFLIP\t\t\tBIT(0)\n#define MDP_PIPE_CAP_VFLIP\t\t\tBIT(1)\n#define MDP_PIPE_CAP_SCALE\t\t\tBIT(2)\n#define MDP_PIPE_CAP_CSC\t\t\tBIT(3)\n#define MDP_PIPE_CAP_DECIMATION\t\t\tBIT(4)\n#define MDP_PIPE_CAP_SW_PIX_EXT\t\t\tBIT(5)\n#define MDP_PIPE_CAP_CURSOR\t\t\tBIT(6)\n\n \n#define MDP_LM_CAP_DISPLAY\t\t\tBIT(0)\n#define MDP_LM_CAP_WB\t\t\t\tBIT(1)\n#define MDP_LM_CAP_PAIR\t\t\t\tBIT(2)\n\nstatic inline bool pipe_supports_yuv(uint32_t pipe_caps)\n{\n\treturn (pipe_caps & MDP_PIPE_CAP_SCALE) &&\n\t\t(pipe_caps & MDP_PIPE_CAP_CSC);\n}\n\nenum csc_type {\n\tCSC_RGB2RGB = 0,\n\tCSC_YUV2RGB,\n\tCSC_RGB2YUV,\n\tCSC_YUV2YUV,\n\tCSC_MAX\n};\n\nstruct csc_cfg {\n\tenum csc_type type;\n\tuint32_t matrix[9];\n\tuint32_t pre_bias[3];\n\tuint32_t post_bias[3];\n\tuint32_t pre_clamp[6];\n\tuint32_t post_clamp[6];\n};\n\nstruct csc_cfg *mdp_get_default_csc_cfg(enum csc_type);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}