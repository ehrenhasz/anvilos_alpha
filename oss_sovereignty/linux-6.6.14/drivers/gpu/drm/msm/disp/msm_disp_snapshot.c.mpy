{
  "module_name": "msm_disp_snapshot.c",
  "hash_id": "cb1b7805d60127474a3f754c838f0a12034dc7d12a3f170642be6e5685642a59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/msm_disp_snapshot.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm:%s:%d] \" fmt, __func__, __LINE__\n\n#include \"msm_disp_snapshot.h\"\n\nstatic ssize_t __maybe_unused disp_devcoredump_read(char *buffer, loff_t offset,\n\t\tsize_t count, void *data, size_t datalen)\n{\n\tstruct drm_print_iterator iter;\n\tstruct drm_printer p;\n\tstruct msm_disp_state *disp_state;\n\n\tdisp_state = data;\n\n\titer.data = buffer;\n\titer.offset = 0;\n\titer.start = offset;\n\titer.remain = count;\n\n\tp = drm_coredump_printer(&iter);\n\n\tmsm_disp_state_print(disp_state, &p);\n\n\treturn count - iter.remain;\n}\n\nstruct msm_disp_state *\nmsm_disp_snapshot_state_sync(struct msm_kms *kms)\n{\n\tstruct drm_device *drm_dev = kms->dev;\n\tstruct msm_disp_state *disp_state;\n\n\tWARN_ON(!mutex_is_locked(&kms->dump_mutex));\n\n\tdisp_state = kzalloc(sizeof(struct msm_disp_state), GFP_KERNEL);\n\tif (!disp_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdisp_state->dev = drm_dev->dev;\n\tdisp_state->drm_dev = drm_dev;\n\n\tINIT_LIST_HEAD(&disp_state->blocks);\n\n\tmsm_disp_snapshot_capture_state(disp_state);\n\n\treturn disp_state;\n}\n\nstatic void _msm_disp_snapshot_work(struct kthread_work *work)\n{\n\tstruct msm_kms *kms = container_of(work, struct msm_kms, dump_work);\n\tstruct msm_disp_state *disp_state;\n\tstruct drm_printer p;\n\n\t \n\tmutex_lock(&kms->dump_mutex);\n\tdisp_state = msm_disp_snapshot_state_sync(kms);\n\tmutex_unlock(&kms->dump_mutex);\n\n\tif (IS_ERR(disp_state))\n\t\treturn;\n\n\tif (MSM_DISP_SNAPSHOT_DUMP_IN_CONSOLE) {\n\t\tp = drm_info_printer(disp_state->drm_dev->dev);\n\t\tmsm_disp_state_print(disp_state, &p);\n\t}\n\n\t \n\tdev_coredumpm(disp_state->dev, THIS_MODULE, disp_state, 0, GFP_KERNEL,\n\t\t\tdisp_devcoredump_read, msm_disp_state_free);\n}\n\nvoid msm_disp_snapshot_state(struct drm_device *drm_dev)\n{\n\tstruct msm_drm_private *priv;\n\tstruct msm_kms *kms;\n\n\tif (!drm_dev) {\n\t\tDRM_ERROR(\"invalid params\\n\");\n\t\treturn;\n\t}\n\n\tpriv = drm_dev->dev_private;\n\tkms = priv->kms;\n\n\tkthread_queue_work(kms->dump_worker, &kms->dump_work);\n}\n\nint msm_disp_snapshot_init(struct drm_device *drm_dev)\n{\n\tstruct msm_drm_private *priv;\n\tstruct msm_kms *kms;\n\n\tif (!drm_dev) {\n\t\tDRM_ERROR(\"invalid params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = drm_dev->dev_private;\n\tkms = priv->kms;\n\n\tmutex_init(&kms->dump_mutex);\n\n\tkms->dump_worker = kthread_create_worker(0, \"%s\", \"disp_snapshot\");\n\tif (IS_ERR(kms->dump_worker))\n\t\tDRM_ERROR(\"failed to create disp state task\\n\");\n\n\tkthread_init_work(&kms->dump_work, _msm_disp_snapshot_work);\n\n\treturn 0;\n}\n\nvoid msm_disp_snapshot_destroy(struct drm_device *drm_dev)\n{\n\tstruct msm_kms *kms;\n\tstruct msm_drm_private *priv;\n\n\tif (!drm_dev) {\n\t\tDRM_ERROR(\"invalid params\\n\");\n\t\treturn;\n\t}\n\n\tpriv = drm_dev->dev_private;\n\tkms = priv->kms;\n\n\tif (kms->dump_worker)\n\t\tkthread_destroy_worker(kms->dump_worker);\n\n\tmutex_destroy(&kms->dump_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}