{
  "module_name": "dpu_rm.c",
  "hash_id": "c10af8603ac47b8d0924f5779c7a2798b213fdbebc71d5d5322054a41aff4436",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_rm.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm:%s] \" fmt, __func__\n#include \"dpu_kms.h\"\n#include \"dpu_hw_lm.h\"\n#include \"dpu_hw_ctl.h\"\n#include \"dpu_hw_pingpong.h\"\n#include \"dpu_hw_sspp.h\"\n#include \"dpu_hw_intf.h\"\n#include \"dpu_hw_wb.h\"\n#include \"dpu_hw_dspp.h\"\n#include \"dpu_hw_merge3d.h\"\n#include \"dpu_hw_dsc.h\"\n#include \"dpu_encoder.h\"\n#include \"dpu_trace.h\"\n\n\nstatic inline bool reserved_by_other(uint32_t *res_map, int idx,\n\t\t\t\t     uint32_t enc_id)\n{\n\treturn res_map[idx] && res_map[idx] != enc_id;\n}\n\n \nstruct dpu_rm_requirements {\n\tstruct msm_display_topology topology;\n};\n\nint dpu_rm_destroy(struct dpu_rm *rm)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rm->dspp_blks); i++) {\n\t\tstruct dpu_hw_dspp *hw;\n\n\t\tif (rm->dspp_blks[i]) {\n\t\t\thw = to_dpu_hw_dspp(rm->dspp_blks[i]);\n\t\t\tdpu_hw_dspp_destroy(hw);\n\t\t}\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(rm->pingpong_blks); i++) {\n\t\tstruct dpu_hw_pingpong *hw;\n\n\t\tif (rm->pingpong_blks[i]) {\n\t\t\thw = to_dpu_hw_pingpong(rm->pingpong_blks[i]);\n\t\t\tdpu_hw_pingpong_destroy(hw);\n\t\t}\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(rm->merge_3d_blks); i++) {\n\t\tstruct dpu_hw_merge_3d *hw;\n\n\t\tif (rm->merge_3d_blks[i]) {\n\t\t\thw = to_dpu_hw_merge_3d(rm->merge_3d_blks[i]);\n\t\t\tdpu_hw_merge_3d_destroy(hw);\n\t\t}\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(rm->mixer_blks); i++) {\n\t\tstruct dpu_hw_mixer *hw;\n\n\t\tif (rm->mixer_blks[i]) {\n\t\t\thw = to_dpu_hw_mixer(rm->mixer_blks[i]);\n\t\t\tdpu_hw_lm_destroy(hw);\n\t\t}\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(rm->ctl_blks); i++) {\n\t\tstruct dpu_hw_ctl *hw;\n\n\t\tif (rm->ctl_blks[i]) {\n\t\t\thw = to_dpu_hw_ctl(rm->ctl_blks[i]);\n\t\t\tdpu_hw_ctl_destroy(hw);\n\t\t}\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(rm->hw_intf); i++)\n\t\tdpu_hw_intf_destroy(rm->hw_intf[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(rm->dsc_blks); i++) {\n\t\tstruct dpu_hw_dsc *hw;\n\n\t\tif (rm->dsc_blks[i]) {\n\t\t\thw = to_dpu_hw_dsc(rm->dsc_blks[i]);\n\t\t\tdpu_hw_dsc_destroy(hw);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rm->hw_wb); i++)\n\t\tdpu_hw_wb_destroy(rm->hw_wb[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(rm->hw_sspp); i++)\n\t\tdpu_hw_sspp_destroy(rm->hw_sspp[i]);\n\n\treturn 0;\n}\n\nint dpu_rm_init(struct dpu_rm *rm,\n\t\tconst struct dpu_mdss_cfg *cat,\n\t\tconst struct msm_mdss_data *mdss_data,\n\t\tvoid __iomem *mmio)\n{\n\tint rc, i;\n\n\tif (!rm || !cat || !mmio) {\n\t\tDPU_ERROR(\"invalid kms\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset(rm, 0, sizeof(*rm));\n\n\t \n\tfor (i = 0; i < cat->mixer_count; i++) {\n\t\tstruct dpu_hw_mixer *hw;\n\t\tconst struct dpu_lm_cfg *lm = &cat->mixer[i];\n\n\t\thw = dpu_hw_lm_init(lm, mmio);\n\t\tif (IS_ERR(hw)) {\n\t\t\trc = PTR_ERR(hw);\n\t\t\tDPU_ERROR(\"failed lm object creation: err %d\\n\", rc);\n\t\t\tgoto fail;\n\t\t}\n\t\trm->mixer_blks[lm->id - LM_0] = &hw->base;\n\t}\n\n\tfor (i = 0; i < cat->merge_3d_count; i++) {\n\t\tstruct dpu_hw_merge_3d *hw;\n\t\tconst struct dpu_merge_3d_cfg *merge_3d = &cat->merge_3d[i];\n\n\t\thw = dpu_hw_merge_3d_init(merge_3d, mmio);\n\t\tif (IS_ERR(hw)) {\n\t\t\trc = PTR_ERR(hw);\n\t\t\tDPU_ERROR(\"failed merge_3d object creation: err %d\\n\",\n\t\t\t\trc);\n\t\t\tgoto fail;\n\t\t}\n\t\trm->merge_3d_blks[merge_3d->id - MERGE_3D_0] = &hw->base;\n\t}\n\n\tfor (i = 0; i < cat->pingpong_count; i++) {\n\t\tstruct dpu_hw_pingpong *hw;\n\t\tconst struct dpu_pingpong_cfg *pp = &cat->pingpong[i];\n\n\t\thw = dpu_hw_pingpong_init(pp, mmio);\n\t\tif (IS_ERR(hw)) {\n\t\t\trc = PTR_ERR(hw);\n\t\t\tDPU_ERROR(\"failed pingpong object creation: err %d\\n\",\n\t\t\t\trc);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (pp->merge_3d && pp->merge_3d < MERGE_3D_MAX)\n\t\t\thw->merge_3d = to_dpu_hw_merge_3d(rm->merge_3d_blks[pp->merge_3d - MERGE_3D_0]);\n\t\trm->pingpong_blks[pp->id - PINGPONG_0] = &hw->base;\n\t}\n\n\tfor (i = 0; i < cat->intf_count; i++) {\n\t\tstruct dpu_hw_intf *hw;\n\t\tconst struct dpu_intf_cfg *intf = &cat->intf[i];\n\n\t\thw = dpu_hw_intf_init(intf, mmio, cat->mdss_ver);\n\t\tif (IS_ERR(hw)) {\n\t\t\trc = PTR_ERR(hw);\n\t\t\tDPU_ERROR(\"failed intf object creation: err %d\\n\", rc);\n\t\t\tgoto fail;\n\t\t}\n\t\trm->hw_intf[intf->id - INTF_0] = hw;\n\t}\n\n\tfor (i = 0; i < cat->wb_count; i++) {\n\t\tstruct dpu_hw_wb *hw;\n\t\tconst struct dpu_wb_cfg *wb = &cat->wb[i];\n\n\t\thw = dpu_hw_wb_init(wb, mmio);\n\t\tif (IS_ERR(hw)) {\n\t\t\trc = PTR_ERR(hw);\n\t\t\tDPU_ERROR(\"failed wb object creation: err %d\\n\", rc);\n\t\t\tgoto fail;\n\t\t}\n\t\trm->hw_wb[wb->id - WB_0] = hw;\n\t}\n\n\tfor (i = 0; i < cat->ctl_count; i++) {\n\t\tstruct dpu_hw_ctl *hw;\n\t\tconst struct dpu_ctl_cfg *ctl = &cat->ctl[i];\n\n\t\thw = dpu_hw_ctl_init(ctl, mmio, cat->mixer_count, cat->mixer);\n\t\tif (IS_ERR(hw)) {\n\t\t\trc = PTR_ERR(hw);\n\t\t\tDPU_ERROR(\"failed ctl object creation: err %d\\n\", rc);\n\t\t\tgoto fail;\n\t\t}\n\t\trm->ctl_blks[ctl->id - CTL_0] = &hw->base;\n\t}\n\n\tfor (i = 0; i < cat->dspp_count; i++) {\n\t\tstruct dpu_hw_dspp *hw;\n\t\tconst struct dpu_dspp_cfg *dspp = &cat->dspp[i];\n\n\t\thw = dpu_hw_dspp_init(dspp, mmio);\n\t\tif (IS_ERR(hw)) {\n\t\t\trc = PTR_ERR(hw);\n\t\t\tDPU_ERROR(\"failed dspp object creation: err %d\\n\", rc);\n\t\t\tgoto fail;\n\t\t}\n\t\trm->dspp_blks[dspp->id - DSPP_0] = &hw->base;\n\t}\n\n\tfor (i = 0; i < cat->dsc_count; i++) {\n\t\tstruct dpu_hw_dsc *hw;\n\t\tconst struct dpu_dsc_cfg *dsc = &cat->dsc[i];\n\n\t\tif (test_bit(DPU_DSC_HW_REV_1_2, &dsc->features))\n\t\t\thw = dpu_hw_dsc_init_1_2(dsc, mmio);\n\t\telse\n\t\t\thw = dpu_hw_dsc_init(dsc, mmio);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\trc = PTR_ERR(hw);\n\t\t\tDPU_ERROR(\"failed dsc object creation: err %d\\n\", rc);\n\t\t\tgoto fail;\n\t\t}\n\t\trm->dsc_blks[dsc->id - DSC_0] = &hw->base;\n\t}\n\n\tfor (i = 0; i < cat->sspp_count; i++) {\n\t\tstruct dpu_hw_sspp *hw;\n\t\tconst struct dpu_sspp_cfg *sspp = &cat->sspp[i];\n\n\t\thw = dpu_hw_sspp_init(sspp, mmio, mdss_data);\n\t\tif (IS_ERR(hw)) {\n\t\t\trc = PTR_ERR(hw);\n\t\t\tDPU_ERROR(\"failed sspp object creation: err %d\\n\", rc);\n\t\t\tgoto fail;\n\t\t}\n\t\trm->hw_sspp[sspp->id - SSPP_NONE] = hw;\n\t}\n\n\treturn 0;\n\nfail:\n\tdpu_rm_destroy(rm);\n\n\treturn rc ? rc : -EFAULT;\n}\n\nstatic bool _dpu_rm_needs_split_display(const struct msm_display_topology *top)\n{\n\treturn top->num_intf > 1;\n}\n\n \nstatic int _dpu_rm_get_lm_peer(struct dpu_rm *rm, int primary_idx)\n{\n\tconst struct dpu_lm_cfg *prim_lm_cfg;\n\n\tprim_lm_cfg = to_dpu_hw_mixer(rm->mixer_blks[primary_idx])->cap;\n\n\tif (prim_lm_cfg->lm_pair >= LM_0 && prim_lm_cfg->lm_pair < LM_MAX)\n\t\treturn prim_lm_cfg->lm_pair - LM_0;\n\treturn -EINVAL;\n}\n\n \nstatic bool _dpu_rm_check_lm_and_get_connected_blks(struct dpu_rm *rm,\n\t\tstruct dpu_global_state *global_state,\n\t\tuint32_t enc_id, int lm_idx, int *pp_idx, int *dspp_idx,\n\t\tstruct dpu_rm_requirements *reqs)\n{\n\tconst struct dpu_lm_cfg *lm_cfg;\n\tint idx;\n\n\t \n\tif (reserved_by_other(global_state->mixer_to_enc_id, lm_idx, enc_id)) {\n\t\tDPU_DEBUG(\"lm %d already reserved\\n\", lm_idx + LM_0);\n\t\treturn false;\n\t}\n\n\tlm_cfg = to_dpu_hw_mixer(rm->mixer_blks[lm_idx])->cap;\n\tidx = lm_cfg->pingpong - PINGPONG_0;\n\tif (idx < 0 || idx >= ARRAY_SIZE(rm->pingpong_blks)) {\n\t\tDPU_ERROR(\"failed to get pp on lm %d\\n\", lm_cfg->pingpong);\n\t\treturn false;\n\t}\n\n\tif (reserved_by_other(global_state->pingpong_to_enc_id, idx, enc_id)) {\n\t\tDPU_DEBUG(\"lm %d pp %d already reserved\\n\", lm_cfg->id,\n\t\t\t\tlm_cfg->pingpong);\n\t\treturn false;\n\t}\n\t*pp_idx = idx;\n\n\tif (!reqs->topology.num_dspp)\n\t\treturn true;\n\n\tidx = lm_cfg->dspp - DSPP_0;\n\tif (idx < 0 || idx >= ARRAY_SIZE(rm->dspp_blks)) {\n\t\tDPU_ERROR(\"failed to get dspp on lm %d\\n\", lm_cfg->dspp);\n\t\treturn false;\n\t}\n\n\tif (reserved_by_other(global_state->dspp_to_enc_id, idx, enc_id)) {\n\t\tDPU_DEBUG(\"lm %d dspp %d already reserved\\n\", lm_cfg->id,\n\t\t\t\tlm_cfg->dspp);\n\t\treturn false;\n\t}\n\t*dspp_idx = idx;\n\n\treturn true;\n}\n\nstatic int _dpu_rm_reserve_lms(struct dpu_rm *rm,\n\t\t\t       struct dpu_global_state *global_state,\n\t\t\t       uint32_t enc_id,\n\t\t\t       struct dpu_rm_requirements *reqs)\n\n{\n\tint lm_idx[MAX_BLOCKS];\n\tint pp_idx[MAX_BLOCKS];\n\tint dspp_idx[MAX_BLOCKS] = {0};\n\tint i, lm_count = 0;\n\n\tif (!reqs->topology.num_lm) {\n\t\tDPU_ERROR(\"invalid number of lm: %d\\n\", reqs->topology.num_lm);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rm->mixer_blks) &&\n\t\t\tlm_count < reqs->topology.num_lm; i++) {\n\t\tif (!rm->mixer_blks[i])\n\t\t\tcontinue;\n\n\t\tlm_count = 0;\n\t\tlm_idx[lm_count] = i;\n\n\t\tif (!_dpu_rm_check_lm_and_get_connected_blks(rm, global_state,\n\t\t\t\tenc_id, i, &pp_idx[lm_count],\n\t\t\t\t&dspp_idx[lm_count], reqs)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t++lm_count;\n\n\t\t \n\t\tif (lm_count < reqs->topology.num_lm) {\n\t\t\tint j = _dpu_rm_get_lm_peer(rm, i);\n\n\t\t\t \n\t\t\tif (j < 0 || j < i)\n\t\t\t\tcontinue;\n\n\t\t\tif (!rm->mixer_blks[j])\n\t\t\t\tcontinue;\n\n\t\t\tif (!_dpu_rm_check_lm_and_get_connected_blks(rm,\n\t\t\t\t\tglobal_state, enc_id, j,\n\t\t\t\t\t&pp_idx[lm_count], &dspp_idx[lm_count],\n\t\t\t\t\treqs)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlm_idx[lm_count] = j;\n\t\t\t++lm_count;\n\t\t}\n\t}\n\n\tif (lm_count != reqs->topology.num_lm) {\n\t\tDPU_DEBUG(\"unable to find appropriate mixers\\n\");\n\t\treturn -ENAVAIL;\n\t}\n\n\tfor (i = 0; i < lm_count; i++) {\n\t\tglobal_state->mixer_to_enc_id[lm_idx[i]] = enc_id;\n\t\tglobal_state->pingpong_to_enc_id[pp_idx[i]] = enc_id;\n\t\tglobal_state->dspp_to_enc_id[dspp_idx[i]] =\n\t\t\treqs->topology.num_dspp ? enc_id : 0;\n\n\t\ttrace_dpu_rm_reserve_lms(lm_idx[i] + LM_0, enc_id,\n\t\t\t\t\t pp_idx[i] + PINGPONG_0);\n\t}\n\n\treturn 0;\n}\n\nstatic int _dpu_rm_reserve_ctls(\n\t\tstruct dpu_rm *rm,\n\t\tstruct dpu_global_state *global_state,\n\t\tuint32_t enc_id,\n\t\tconst struct msm_display_topology *top)\n{\n\tint ctl_idx[MAX_BLOCKS];\n\tint i = 0, j, num_ctls;\n\tbool needs_split_display;\n\n\t \n\tnum_ctls = top->num_intf;\n\n\tneeds_split_display = _dpu_rm_needs_split_display(top);\n\n\tfor (j = 0; j < ARRAY_SIZE(rm->ctl_blks); j++) {\n\t\tconst struct dpu_hw_ctl *ctl;\n\t\tunsigned long features;\n\t\tbool has_split_display;\n\n\t\tif (!rm->ctl_blks[j])\n\t\t\tcontinue;\n\t\tif (reserved_by_other(global_state->ctl_to_enc_id, j, enc_id))\n\t\t\tcontinue;\n\n\t\tctl = to_dpu_hw_ctl(rm->ctl_blks[j]);\n\t\tfeatures = ctl->caps->features;\n\t\thas_split_display = BIT(DPU_CTL_SPLIT_DISPLAY) & features;\n\n\t\tDPU_DEBUG(\"ctl %d caps 0x%lX\\n\", j + CTL_0, features);\n\n\t\tif (needs_split_display != has_split_display)\n\t\t\tcontinue;\n\n\t\tctl_idx[i] = j;\n\t\tDPU_DEBUG(\"ctl %d match\\n\", j + CTL_0);\n\n\t\tif (++i == num_ctls)\n\t\t\tbreak;\n\n\t}\n\n\tif (i != num_ctls)\n\t\treturn -ENAVAIL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctl_idx) && i < num_ctls; i++) {\n\t\tglobal_state->ctl_to_enc_id[ctl_idx[i]] = enc_id;\n\t\ttrace_dpu_rm_reserve_ctls(i + CTL_0, enc_id);\n\t}\n\n\treturn 0;\n}\n\nstatic int _dpu_rm_reserve_dsc(struct dpu_rm *rm,\n\t\t\t       struct dpu_global_state *global_state,\n\t\t\t       struct drm_encoder *enc,\n\t\t\t       const struct msm_display_topology *top)\n{\n\tint num_dsc = top->num_dsc;\n\tint i;\n\n\t \n\tfor (i = 0; i < num_dsc; i++) {\n\t\tif (!rm->dsc_blks[i]) {\n\t\t\tDPU_ERROR(\"DSC %d does not exist\\n\", i);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (global_state->dsc_to_enc_id[i]) {\n\t\t\tDPU_ERROR(\"DSC %d is already allocated\\n\", i);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_dsc; i++)\n\t\tglobal_state->dsc_to_enc_id[i] = enc->base.id;\n\n\treturn 0;\n}\n\nstatic int _dpu_rm_make_reservation(\n\t\tstruct dpu_rm *rm,\n\t\tstruct dpu_global_state *global_state,\n\t\tstruct drm_encoder *enc,\n\t\tstruct dpu_rm_requirements *reqs)\n{\n\tint ret;\n\n\tret = _dpu_rm_reserve_lms(rm, global_state, enc->base.id, reqs);\n\tif (ret) {\n\t\tDPU_ERROR(\"unable to find appropriate mixers\\n\");\n\t\treturn ret;\n\t}\n\n\tret = _dpu_rm_reserve_ctls(rm, global_state, enc->base.id,\n\t\t\t\t&reqs->topology);\n\tif (ret) {\n\t\tDPU_ERROR(\"unable to find appropriate CTL\\n\");\n\t\treturn ret;\n\t}\n\n\tret  = _dpu_rm_reserve_dsc(rm, global_state, enc, &reqs->topology);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int _dpu_rm_populate_requirements(\n\t\tstruct drm_encoder *enc,\n\t\tstruct dpu_rm_requirements *reqs,\n\t\tstruct msm_display_topology req_topology)\n{\n\treqs->topology = req_topology;\n\n\tDRM_DEBUG_KMS(\"num_lm: %d num_dsc: %d num_intf: %d\\n\",\n\t\t      reqs->topology.num_lm, reqs->topology.num_dsc,\n\t\t      reqs->topology.num_intf);\n\n\treturn 0;\n}\n\nstatic void _dpu_rm_clear_mapping(uint32_t *res_mapping, int cnt,\n\t\t\t\t  uint32_t enc_id)\n{\n\tint i;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (res_mapping[i] == enc_id)\n\t\t\tres_mapping[i] = 0;\n\t}\n}\n\nvoid dpu_rm_release(struct dpu_global_state *global_state,\n\t\t    struct drm_encoder *enc)\n{\n\t_dpu_rm_clear_mapping(global_state->pingpong_to_enc_id,\n\t\tARRAY_SIZE(global_state->pingpong_to_enc_id), enc->base.id);\n\t_dpu_rm_clear_mapping(global_state->mixer_to_enc_id,\n\t\tARRAY_SIZE(global_state->mixer_to_enc_id), enc->base.id);\n\t_dpu_rm_clear_mapping(global_state->ctl_to_enc_id,\n\t\tARRAY_SIZE(global_state->ctl_to_enc_id), enc->base.id);\n\t_dpu_rm_clear_mapping(global_state->dsc_to_enc_id,\n\t\tARRAY_SIZE(global_state->dsc_to_enc_id), enc->base.id);\n\t_dpu_rm_clear_mapping(global_state->dspp_to_enc_id,\n\t\tARRAY_SIZE(global_state->dspp_to_enc_id), enc->base.id);\n}\n\nint dpu_rm_reserve(\n\t\tstruct dpu_rm *rm,\n\t\tstruct dpu_global_state *global_state,\n\t\tstruct drm_encoder *enc,\n\t\tstruct drm_crtc_state *crtc_state,\n\t\tstruct msm_display_topology topology)\n{\n\tstruct dpu_rm_requirements reqs;\n\tint ret;\n\n\t \n\tif (!drm_atomic_crtc_needs_modeset(crtc_state))\n\t\treturn 0;\n\n\tif (IS_ERR(global_state)) {\n\t\tDPU_ERROR(\"failed to global state\\n\");\n\t\treturn PTR_ERR(global_state);\n\t}\n\n\tDRM_DEBUG_KMS(\"reserving hw for enc %d crtc %d\\n\",\n\t\t      enc->base.id, crtc_state->crtc->base.id);\n\n\tret = _dpu_rm_populate_requirements(enc, &reqs, topology);\n\tif (ret) {\n\t\tDPU_ERROR(\"failed to populate hw requirements\\n\");\n\t\treturn ret;\n\t}\n\n\tret = _dpu_rm_make_reservation(rm, global_state, enc, &reqs);\n\tif (ret)\n\t\tDPU_ERROR(\"failed to reserve hw resources: %d\\n\", ret);\n\n\n\n\treturn ret;\n}\n\nint dpu_rm_get_assigned_resources(struct dpu_rm *rm,\n\tstruct dpu_global_state *global_state, uint32_t enc_id,\n\tenum dpu_hw_blk_type type, struct dpu_hw_blk **blks, int blks_size)\n{\n\tstruct dpu_hw_blk **hw_blks;\n\tuint32_t *hw_to_enc_id;\n\tint i, num_blks, max_blks;\n\n\tswitch (type) {\n\tcase DPU_HW_BLK_PINGPONG:\n\t\thw_blks = rm->pingpong_blks;\n\t\thw_to_enc_id = global_state->pingpong_to_enc_id;\n\t\tmax_blks = ARRAY_SIZE(rm->pingpong_blks);\n\t\tbreak;\n\tcase DPU_HW_BLK_LM:\n\t\thw_blks = rm->mixer_blks;\n\t\thw_to_enc_id = global_state->mixer_to_enc_id;\n\t\tmax_blks = ARRAY_SIZE(rm->mixer_blks);\n\t\tbreak;\n\tcase DPU_HW_BLK_CTL:\n\t\thw_blks = rm->ctl_blks;\n\t\thw_to_enc_id = global_state->ctl_to_enc_id;\n\t\tmax_blks = ARRAY_SIZE(rm->ctl_blks);\n\t\tbreak;\n\tcase DPU_HW_BLK_DSPP:\n\t\thw_blks = rm->dspp_blks;\n\t\thw_to_enc_id = global_state->dspp_to_enc_id;\n\t\tmax_blks = ARRAY_SIZE(rm->dspp_blks);\n\t\tbreak;\n\tcase DPU_HW_BLK_DSC:\n\t\thw_blks = rm->dsc_blks;\n\t\thw_to_enc_id = global_state->dsc_to_enc_id;\n\t\tmax_blks = ARRAY_SIZE(rm->dsc_blks);\n\t\tbreak;\n\tdefault:\n\t\tDPU_ERROR(\"blk type %d not managed by rm\\n\", type);\n\t\treturn 0;\n\t}\n\n\tnum_blks = 0;\n\tfor (i = 0; i < max_blks; i++) {\n\t\tif (hw_to_enc_id[i] != enc_id)\n\t\t\tcontinue;\n\n\t\tif (num_blks == blks_size) {\n\t\t\tDPU_ERROR(\"More than %d resources assigned to enc %d\\n\",\n\t\t\t\t  blks_size, enc_id);\n\t\t\tbreak;\n\t\t}\n\t\tif (!hw_blks[i]) {\n\t\t\tDPU_ERROR(\"Allocated resource %d unavailable to assign to enc %d\\n\",\n\t\t\t\t  type, enc_id);\n\t\t\tbreak;\n\t\t}\n\t\tblks[num_blks++] = hw_blks[i];\n\t}\n\n\treturn num_blks;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}