{
  "module_name": "dpu_encoder_phys_vid.c",
  "hash_id": "7a028a1f6cab2a44b3b9d9e85a1166854f9fad2a3674ac0de43845d46591bfbb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_vid.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm:%s:%d] \" fmt, __func__, __LINE__\n#include \"dpu_encoder_phys.h\"\n#include \"dpu_hw_interrupts.h\"\n#include \"dpu_hw_merge3d.h\"\n#include \"dpu_core_irq.h\"\n#include \"dpu_formats.h\"\n#include \"dpu_trace.h\"\n#include \"disp/msm_disp_snapshot.h\"\n\n#define DPU_DEBUG_VIDENC(e, fmt, ...) DPU_DEBUG(\"enc%d intf%d \" fmt, \\\n\t\t(e) && (e)->parent ? \\\n\t\t(e)->parent->base.id : -1, \\\n\t\t(e) && (e)->hw_intf ? \\\n\t\t(e)->hw_intf->idx - INTF_0 : -1, ##__VA_ARGS__)\n\n#define DPU_ERROR_VIDENC(e, fmt, ...) DPU_ERROR(\"enc%d intf%d \" fmt, \\\n\t\t(e) && (e)->parent ? \\\n\t\t(e)->parent->base.id : -1, \\\n\t\t(e) && (e)->hw_intf ? \\\n\t\t(e)->hw_intf->idx - INTF_0 : -1, ##__VA_ARGS__)\n\n#define to_dpu_encoder_phys_vid(x) \\\n\tcontainer_of(x, struct dpu_encoder_phys_vid, base)\n\nstatic bool dpu_encoder_phys_vid_is_master(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tbool ret = false;\n\n\tif (phys_enc->split_role != ENC_ROLE_SLAVE)\n\t\tret = true;\n\n\treturn ret;\n}\n\nstatic void drm_mode_to_intf_timing_params(\n\t\tconst struct dpu_encoder_phys *phys_enc,\n\t\tconst struct drm_display_mode *mode,\n\t\tstruct dpu_hw_intf_timing_params *timing)\n{\n\tmemset(timing, 0, sizeof(*timing));\n\n\tif ((mode->htotal < mode->hsync_end)\n\t\t\t|| (mode->hsync_start < mode->hdisplay)\n\t\t\t|| (mode->vtotal < mode->vsync_end)\n\t\t\t|| (mode->vsync_start < mode->vdisplay)\n\t\t\t|| (mode->hsync_end < mode->hsync_start)\n\t\t\t|| (mode->vsync_end < mode->vsync_start)) {\n\t\tDPU_ERROR(\n\t\t    \"invalid params - hstart:%d,hend:%d,htot:%d,hdisplay:%d\\n\",\n\t\t\t\tmode->hsync_start, mode->hsync_end,\n\t\t\t\tmode->htotal, mode->hdisplay);\n\t\tDPU_ERROR(\"vstart:%d,vend:%d,vtot:%d,vdisplay:%d\\n\",\n\t\t\t\tmode->vsync_start, mode->vsync_end,\n\t\t\t\tmode->vtotal, mode->vdisplay);\n\t\treturn;\n\t}\n\n\t \n\ttiming->width = mode->hdisplay;\t \n\ttiming->height = mode->vdisplay;\t \n\ttiming->xres = timing->width;\n\ttiming->yres = timing->height;\n\ttiming->h_back_porch = mode->htotal - mode->hsync_end;\n\ttiming->h_front_porch = mode->hsync_start - mode->hdisplay;\n\ttiming->v_back_porch = mode->vtotal - mode->vsync_end;\n\ttiming->v_front_porch = mode->vsync_start - mode->vdisplay;\n\ttiming->hsync_pulse_width = mode->hsync_end - mode->hsync_start;\n\ttiming->vsync_pulse_width = mode->vsync_end - mode->vsync_start;\n\ttiming->hsync_polarity = (mode->flags & DRM_MODE_FLAG_NHSYNC) ? 1 : 0;\n\ttiming->vsync_polarity = (mode->flags & DRM_MODE_FLAG_NVSYNC) ? 1 : 0;\n\ttiming->border_clr = 0;\n\ttiming->underflow_clr = 0xff;\n\ttiming->hsync_skew = mode->hskew;\n\n\t \n\tif (phys_enc->hw_intf->cap->type == INTF_DSI) {\n\t\ttiming->hsync_polarity = 0;\n\t\ttiming->vsync_polarity = 0;\n\t}\n\n\t \n\tif (phys_enc->hw_intf->cap->type == INTF_DP) {\n\t\ttiming->h_back_porch += timing->h_front_porch;\n\t\ttiming->h_front_porch = 0;\n\t\ttiming->v_back_porch += timing->v_front_porch;\n\t\ttiming->v_front_porch = 0;\n\t}\n\n\ttiming->wide_bus_en = dpu_encoder_is_widebus_enabled(phys_enc->parent);\n\n\t \n\tif (phys_enc->hw_intf->cap->type == INTF_DP && timing->wide_bus_en) {\n\t\ttiming->width = timing->width >> 1;\n\t\ttiming->xres = timing->xres >> 1;\n\t\ttiming->h_back_porch = timing->h_back_porch >> 1;\n\t\ttiming->h_front_porch = timing->h_front_porch >> 1;\n\t\ttiming->hsync_pulse_width = timing->hsync_pulse_width >> 1;\n\t}\n}\n\nstatic u32 get_horizontal_total(const struct dpu_hw_intf_timing_params *timing)\n{\n\tu32 active = timing->xres;\n\tu32 inactive =\n\t    timing->h_back_porch + timing->h_front_porch +\n\t    timing->hsync_pulse_width;\n\treturn active + inactive;\n}\n\nstatic u32 get_vertical_total(const struct dpu_hw_intf_timing_params *timing)\n{\n\tu32 active = timing->yres;\n\tu32 inactive =\n\t    timing->v_back_porch + timing->v_front_porch +\n\t    timing->vsync_pulse_width;\n\treturn active + inactive;\n}\n\n \nstatic u32 programmable_fetch_get_num_lines(\n\t\tstruct dpu_encoder_phys *phys_enc,\n\t\tconst struct dpu_hw_intf_timing_params *timing)\n{\n\tu32 worst_case_needed_lines =\n\t    phys_enc->hw_intf->cap->prog_fetch_lines_worst_case;\n\tu32 start_of_frame_lines =\n\t    timing->v_back_porch + timing->vsync_pulse_width;\n\tu32 needed_vfp_lines = worst_case_needed_lines - start_of_frame_lines;\n\tu32 actual_vfp_lines = 0;\n\n\t \n\tif (start_of_frame_lines >= worst_case_needed_lines) {\n\t\tDPU_DEBUG_VIDENC(phys_enc,\n\t\t\t\t\"prog fetch is not needed, large vbp+vsw\\n\");\n\t\tactual_vfp_lines = 0;\n\t} else if (timing->v_front_porch < needed_vfp_lines) {\n\t\t \n\t\tpr_warn_once\n\t\t\t(\"low vbp+vfp may lead to perf issues in some cases\\n\");\n\t\tDPU_DEBUG_VIDENC(phys_enc,\n\t\t\t\t\"less vfp than fetch req, using entire vfp\\n\");\n\t\tactual_vfp_lines = timing->v_front_porch;\n\t} else {\n\t\tDPU_DEBUG_VIDENC(phys_enc, \"room in vfp for needed prefetch\\n\");\n\t\tactual_vfp_lines = needed_vfp_lines;\n\t}\n\n\tDPU_DEBUG_VIDENC(phys_enc,\n\t\t\"v_front_porch %u v_back_porch %u vsync_pulse_width %u\\n\",\n\t\ttiming->v_front_porch, timing->v_back_porch,\n\t\ttiming->vsync_pulse_width);\n\tDPU_DEBUG_VIDENC(phys_enc,\n\t\t\"wc_lines %u needed_vfp_lines %u actual_vfp_lines %u\\n\",\n\t\tworst_case_needed_lines, needed_vfp_lines, actual_vfp_lines);\n\n\treturn actual_vfp_lines;\n}\n\n \nstatic void programmable_fetch_config(struct dpu_encoder_phys *phys_enc,\n\t\t\t\t      const struct dpu_hw_intf_timing_params *timing)\n{\n\tstruct dpu_hw_intf_prog_fetch f = { 0 };\n\tu32 vfp_fetch_lines = 0;\n\tu32 horiz_total = 0;\n\tu32 vert_total = 0;\n\tu32 vfp_fetch_start_vsync_counter = 0;\n\tunsigned long lock_flags;\n\n\tif (WARN_ON_ONCE(!phys_enc->hw_intf->ops.setup_prg_fetch))\n\t\treturn;\n\n\tvfp_fetch_lines = programmable_fetch_get_num_lines(phys_enc, timing);\n\tif (vfp_fetch_lines) {\n\t\tvert_total = get_vertical_total(timing);\n\t\thoriz_total = get_horizontal_total(timing);\n\t\tvfp_fetch_start_vsync_counter =\n\t\t    (vert_total - vfp_fetch_lines) * horiz_total + 1;\n\t\tf.enable = 1;\n\t\tf.fetch_start = vfp_fetch_start_vsync_counter;\n\t}\n\n\tDPU_DEBUG_VIDENC(phys_enc,\n\t\t\"vfp_fetch_lines %u vfp_fetch_start_vsync_counter %u\\n\",\n\t\tvfp_fetch_lines, vfp_fetch_start_vsync_counter);\n\n\tspin_lock_irqsave(phys_enc->enc_spinlock, lock_flags);\n\tphys_enc->hw_intf->ops.setup_prg_fetch(phys_enc->hw_intf, &f);\n\tspin_unlock_irqrestore(phys_enc->enc_spinlock, lock_flags);\n}\n\nstatic void dpu_encoder_phys_vid_setup_timing_engine(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct drm_display_mode mode;\n\tstruct dpu_hw_intf_timing_params timing_params = { 0 };\n\tconst struct dpu_format *fmt = NULL;\n\tu32 fmt_fourcc = DRM_FORMAT_RGB888;\n\tunsigned long lock_flags;\n\tstruct dpu_hw_intf_cfg intf_cfg = { 0 };\n\n\tdrm_mode_init(&mode, &phys_enc->cached_mode);\n\n\tif (!phys_enc->hw_ctl->ops.setup_intf_cfg) {\n\t\tDPU_ERROR(\"invalid encoder %d\\n\", phys_enc != NULL);\n\t\treturn;\n\t}\n\n\tif (!phys_enc->hw_intf->ops.setup_timing_gen) {\n\t\tDPU_ERROR(\"timing engine setup is not supported\\n\");\n\t\treturn;\n\t}\n\n\tDPU_DEBUG_VIDENC(phys_enc, \"enabling mode:\\n\");\n\tdrm_mode_debug_printmodeline(&mode);\n\n\tif (phys_enc->split_role != ENC_ROLE_SOLO) {\n\t\tmode.hdisplay >>= 1;\n\t\tmode.htotal >>= 1;\n\t\tmode.hsync_start >>= 1;\n\t\tmode.hsync_end >>= 1;\n\n\t\tDPU_DEBUG_VIDENC(phys_enc,\n\t\t\t\"split_role %d, halve horizontal %d %d %d %d\\n\",\n\t\t\tphys_enc->split_role,\n\t\t\tmode.hdisplay, mode.htotal,\n\t\t\tmode.hsync_start, mode.hsync_end);\n\t}\n\n\tdrm_mode_to_intf_timing_params(phys_enc, &mode, &timing_params);\n\n\tfmt = dpu_get_dpu_format(fmt_fourcc);\n\tDPU_DEBUG_VIDENC(phys_enc, \"fmt_fourcc 0x%X\\n\", fmt_fourcc);\n\n\tintf_cfg.intf = phys_enc->hw_intf->idx;\n\tintf_cfg.intf_mode_sel = DPU_CTL_MODE_SEL_VID;\n\tintf_cfg.stream_sel = 0;  \n\tintf_cfg.mode_3d = dpu_encoder_helper_get_3d_blend_mode(phys_enc);\n\tintf_cfg.dsc = dpu_encoder_helper_get_dsc(phys_enc);\n\tif (phys_enc->hw_pp->merge_3d)\n\t\tintf_cfg.merge_3d = phys_enc->hw_pp->merge_3d->idx;\n\n\tspin_lock_irqsave(phys_enc->enc_spinlock, lock_flags);\n\tphys_enc->hw_intf->ops.setup_timing_gen(phys_enc->hw_intf,\n\t\t\t&timing_params, fmt);\n\tphys_enc->hw_ctl->ops.setup_intf_cfg(phys_enc->hw_ctl, &intf_cfg);\n\n\t \n\tif (phys_enc->hw_intf->ops.bind_pingpong_blk)\n\t\tphys_enc->hw_intf->ops.bind_pingpong_blk(\n\t\t\t\tphys_enc->hw_intf,\n\t\t\t\tphys_enc->hw_pp->idx);\n\n\tif (phys_enc->hw_pp->merge_3d)\n\t\tphys_enc->hw_pp->merge_3d->ops.setup_3d_mode(phys_enc->hw_pp->merge_3d, intf_cfg.mode_3d);\n\n\tspin_unlock_irqrestore(phys_enc->enc_spinlock, lock_flags);\n\n\tprogrammable_fetch_config(phys_enc, &timing_params);\n}\n\nstatic void dpu_encoder_phys_vid_vblank_irq(void *arg, int irq_idx)\n{\n\tstruct dpu_encoder_phys *phys_enc = arg;\n\tstruct dpu_hw_ctl *hw_ctl;\n\tunsigned long lock_flags;\n\tu32 flush_register = 0;\n\n\thw_ctl = phys_enc->hw_ctl;\n\n\tDPU_ATRACE_BEGIN(\"vblank_irq\");\n\n\tdpu_encoder_vblank_callback(phys_enc->parent, phys_enc);\n\n\tatomic_read(&phys_enc->pending_kickoff_cnt);\n\n\t \n\tspin_lock_irqsave(phys_enc->enc_spinlock, lock_flags);\n\tif (hw_ctl->ops.get_flush_register)\n\t\tflush_register = hw_ctl->ops.get_flush_register(hw_ctl);\n\n\tif (!(flush_register & hw_ctl->ops.get_pending_flush(hw_ctl)))\n\t\tatomic_add_unless(&phys_enc->pending_kickoff_cnt, -1, 0);\n\tspin_unlock_irqrestore(phys_enc->enc_spinlock, lock_flags);\n\n\t \n\twake_up_all(&phys_enc->pending_kickoff_wq);\n\n\tdpu_encoder_frame_done_callback(phys_enc->parent, phys_enc,\n\t\t\tDPU_ENCODER_FRAME_EVENT_DONE);\n\n\tDPU_ATRACE_END(\"vblank_irq\");\n}\n\nstatic void dpu_encoder_phys_vid_underrun_irq(void *arg, int irq_idx)\n{\n\tstruct dpu_encoder_phys *phys_enc = arg;\n\n\tdpu_encoder_underrun_callback(phys_enc->parent, phys_enc);\n}\n\nstatic bool dpu_encoder_phys_vid_needs_single_flush(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\treturn phys_enc->split_role != ENC_ROLE_SOLO;\n}\n\nstatic void dpu_encoder_phys_vid_atomic_mode_set(\n\t\tstruct dpu_encoder_phys *phys_enc,\n\t\tstruct drm_crtc_state *crtc_state,\n\t\tstruct drm_connector_state *conn_state)\n{\n\tphys_enc->irq[INTR_IDX_VSYNC] = phys_enc->hw_intf->cap->intr_vsync;\n\n\tphys_enc->irq[INTR_IDX_UNDERRUN] = phys_enc->hw_intf->cap->intr_underrun;\n}\n\nstatic int dpu_encoder_phys_vid_control_vblank_irq(\n\t\tstruct dpu_encoder_phys *phys_enc,\n\t\tbool enable)\n{\n\tint ret = 0;\n\tint refcount;\n\n\trefcount = atomic_read(&phys_enc->vblank_refcount);\n\n\t \n\tif (!dpu_encoder_phys_vid_is_master(phys_enc))\n\t\tgoto end;\n\n\t \n\tif (!enable && refcount == 0) {\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tDRM_DEBUG_VBL(\"id:%u enable=%d/%d\\n\", DRMID(phys_enc->parent), enable,\n\t\t      atomic_read(&phys_enc->vblank_refcount));\n\n\tif (enable && atomic_inc_return(&phys_enc->vblank_refcount) == 1)\n\t\tret = dpu_core_irq_register_callback(phys_enc->dpu_kms,\n\t\t\t\tphys_enc->irq[INTR_IDX_VSYNC],\n\t\t\t\tdpu_encoder_phys_vid_vblank_irq,\n\t\t\t\tphys_enc);\n\telse if (!enable && atomic_dec_return(&phys_enc->vblank_refcount) == 0)\n\t\tret = dpu_core_irq_unregister_callback(phys_enc->dpu_kms,\n\t\t\t\tphys_enc->irq[INTR_IDX_VSYNC]);\n\nend:\n\tif (ret) {\n\t\tDRM_ERROR(\"failed: id:%u intf:%d ret:%d enable:%d refcnt:%d\\n\",\n\t\t\t  DRMID(phys_enc->parent),\n\t\t\t  phys_enc->hw_intf->idx - INTF_0, ret, enable,\n\t\t\t  refcount);\n\t}\n\treturn ret;\n}\n\nstatic void dpu_encoder_phys_vid_enable(struct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_ctl *ctl;\n\n\tctl = phys_enc->hw_ctl;\n\n\tDPU_DEBUG_VIDENC(phys_enc, \"\\n\");\n\n\tif (WARN_ON(!phys_enc->hw_intf->ops.enable_timing))\n\t\treturn;\n\n\tdpu_encoder_helper_split_config(phys_enc, phys_enc->hw_intf->idx);\n\n\tdpu_encoder_phys_vid_setup_timing_engine(phys_enc);\n\n\t \n\tif (dpu_encoder_phys_vid_needs_single_flush(phys_enc) &&\n\t\t!dpu_encoder_phys_vid_is_master(phys_enc))\n\t\tgoto skip_flush;\n\n\tctl->ops.update_pending_flush_intf(ctl, phys_enc->hw_intf->idx);\n\tif (ctl->ops.update_pending_flush_merge_3d && phys_enc->hw_pp->merge_3d)\n\t\tctl->ops.update_pending_flush_merge_3d(ctl, phys_enc->hw_pp->merge_3d->idx);\n\nskip_flush:\n\tDPU_DEBUG_VIDENC(phys_enc,\n\t\t\"update pending flush ctl %d intf %d\\n\",\n\t\tctl->idx - CTL_0, phys_enc->hw_intf->idx);\n\n\tatomic_set(&phys_enc->underrun_cnt, 0);\n\n\t \n\tif (phys_enc->enable_state == DPU_ENC_DISABLED)\n\t\tphys_enc->enable_state = DPU_ENC_ENABLING;\n}\n\nstatic void dpu_encoder_phys_vid_destroy(struct dpu_encoder_phys *phys_enc)\n{\n\tDPU_DEBUG_VIDENC(phys_enc, \"\\n\");\n\tkfree(phys_enc);\n}\n\nstatic int dpu_encoder_phys_vid_wait_for_vblank(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_encoder_wait_info wait_info;\n\tint ret;\n\n\twait_info.wq = &phys_enc->pending_kickoff_wq;\n\twait_info.atomic_cnt = &phys_enc->pending_kickoff_cnt;\n\twait_info.timeout_ms = KICKOFF_TIMEOUT_MS;\n\n\tif (!dpu_encoder_phys_vid_is_master(phys_enc)) {\n\t\treturn 0;\n\t}\n\n\t \n\tret = dpu_encoder_helper_wait_for_irq(phys_enc,\n\t\t\tphys_enc->irq[INTR_IDX_VSYNC],\n\t\t\tdpu_encoder_phys_vid_vblank_irq,\n\t\t\t&wait_info);\n\n\tif (ret == -ETIMEDOUT) {\n\t\tdpu_encoder_helper_report_irq_timeout(phys_enc, INTR_IDX_VSYNC);\n\t}\n\n\treturn ret;\n}\n\nstatic int dpu_encoder_phys_vid_wait_for_commit_done(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_ctl *hw_ctl = phys_enc->hw_ctl;\n\tint ret;\n\n\tif (!hw_ctl)\n\t\treturn 0;\n\n\tret = wait_event_timeout(phys_enc->pending_kickoff_wq,\n\t\t(hw_ctl->ops.get_flush_register(hw_ctl) == 0),\n\t\tmsecs_to_jiffies(50));\n\tif (ret <= 0) {\n\t\tDPU_ERROR(\"vblank timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void dpu_encoder_phys_vid_prepare_for_kickoff(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_ctl *ctl;\n\tint rc;\n\tstruct drm_encoder *drm_enc;\n\n\tdrm_enc = phys_enc->parent;\n\n\tctl = phys_enc->hw_ctl;\n\tif (!ctl->ops.wait_reset_status)\n\t\treturn;\n\n\t \n\trc = ctl->ops.wait_reset_status(ctl);\n\tif (rc) {\n\t\tDPU_ERROR_VIDENC(phys_enc, \"ctl %d reset failure: %d\\n\",\n\t\t\t\tctl->idx, rc);\n\t\tmsm_disp_snapshot_state(drm_enc->dev);\n\t\tdpu_core_irq_unregister_callback(phys_enc->dpu_kms,\n\t\t\t\tphys_enc->irq[INTR_IDX_VSYNC]);\n\t}\n}\n\nstatic void dpu_encoder_phys_vid_disable(struct dpu_encoder_phys *phys_enc)\n{\n\tunsigned long lock_flags;\n\tint ret;\n\tstruct dpu_hw_intf_status intf_status = {0};\n\n\tif (!phys_enc->parent || !phys_enc->parent->dev) {\n\t\tDPU_ERROR(\"invalid encoder/device\\n\");\n\t\treturn;\n\t}\n\n\tif (!phys_enc->hw_intf) {\n\t\tDPU_ERROR(\"invalid hw_intf %d hw_ctl %d\\n\",\n\t\t\t\tphys_enc->hw_intf != NULL, phys_enc->hw_ctl != NULL);\n\t\treturn;\n\t}\n\n\tif (WARN_ON(!phys_enc->hw_intf->ops.enable_timing))\n\t\treturn;\n\n\tif (phys_enc->enable_state == DPU_ENC_DISABLED) {\n\t\tDPU_ERROR(\"already disabled\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(phys_enc->enc_spinlock, lock_flags);\n\tphys_enc->hw_intf->ops.enable_timing(phys_enc->hw_intf, 0);\n\tif (dpu_encoder_phys_vid_is_master(phys_enc))\n\t\tdpu_encoder_phys_inc_pending(phys_enc);\n\tspin_unlock_irqrestore(phys_enc->enc_spinlock, lock_flags);\n\n\t \n\tif (dpu_encoder_phys_vid_is_master(phys_enc)) {\n\t\tret = dpu_encoder_phys_vid_wait_for_vblank(phys_enc);\n\t\tif (ret) {\n\t\t\tatomic_set(&phys_enc->pending_kickoff_cnt, 0);\n\t\t\tDRM_ERROR(\"wait disable failed: id:%u intf:%d ret:%d\\n\",\n\t\t\t\t  DRMID(phys_enc->parent),\n\t\t\t\t  phys_enc->hw_intf->idx - INTF_0, ret);\n\t\t}\n\t}\n\n\tif (phys_enc->hw_intf && phys_enc->hw_intf->ops.get_status)\n\t\tphys_enc->hw_intf->ops.get_status(phys_enc->hw_intf, &intf_status);\n\n\t \n\tif (intf_status.is_en && dpu_encoder_phys_vid_is_master(phys_enc)) {\n\t\tspin_lock_irqsave(phys_enc->enc_spinlock, lock_flags);\n\t\tdpu_encoder_phys_inc_pending(phys_enc);\n\t\tspin_unlock_irqrestore(phys_enc->enc_spinlock, lock_flags);\n\t\tret = dpu_encoder_phys_vid_wait_for_vblank(phys_enc);\n\t\tif (ret) {\n\t\t\tatomic_set(&phys_enc->pending_kickoff_cnt, 0);\n\t\t\tDRM_ERROR(\"wait disable failed: id:%u intf:%d ret:%d\\n\",\n\t\t\t\t  DRMID(phys_enc->parent),\n\t\t\t\t  phys_enc->hw_intf->idx - INTF_0, ret);\n\t\t}\n\t}\n\n\tdpu_encoder_helper_phys_cleanup(phys_enc);\n\tphys_enc->enable_state = DPU_ENC_DISABLED;\n}\n\nstatic void dpu_encoder_phys_vid_handle_post_kickoff(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tunsigned long lock_flags;\n\n\t \n\tif (phys_enc->enable_state == DPU_ENC_ENABLING) {\n\t\ttrace_dpu_enc_phys_vid_post_kickoff(DRMID(phys_enc->parent),\n\t\t\t\t    phys_enc->hw_intf->idx - INTF_0);\n\t\tspin_lock_irqsave(phys_enc->enc_spinlock, lock_flags);\n\t\tphys_enc->hw_intf->ops.enable_timing(phys_enc->hw_intf, 1);\n\t\tspin_unlock_irqrestore(phys_enc->enc_spinlock, lock_flags);\n\t\tphys_enc->enable_state = DPU_ENC_ENABLED;\n\t}\n}\n\nstatic void dpu_encoder_phys_vid_irq_control(struct dpu_encoder_phys *phys_enc,\n\t\tbool enable)\n{\n\tint ret;\n\n\ttrace_dpu_enc_phys_vid_irq_ctrl(DRMID(phys_enc->parent),\n\t\t\t    phys_enc->hw_intf->idx - INTF_0,\n\t\t\t    enable,\n\t\t\t    atomic_read(&phys_enc->vblank_refcount));\n\n\tif (enable) {\n\t\tret = dpu_encoder_phys_vid_control_vblank_irq(phys_enc, true);\n\t\tif (WARN_ON(ret))\n\t\t\treturn;\n\n\t\tdpu_core_irq_register_callback(phys_enc->dpu_kms,\n\t\t\t\tphys_enc->irq[INTR_IDX_UNDERRUN],\n\t\t\t\tdpu_encoder_phys_vid_underrun_irq,\n\t\t\t\tphys_enc);\n\t} else {\n\t\tdpu_encoder_phys_vid_control_vblank_irq(phys_enc, false);\n\t\tdpu_core_irq_unregister_callback(phys_enc->dpu_kms,\n\t\t\t\tphys_enc->irq[INTR_IDX_UNDERRUN]);\n\t}\n}\n\nstatic int dpu_encoder_phys_vid_get_line_count(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tif (!dpu_encoder_phys_vid_is_master(phys_enc))\n\t\treturn -EINVAL;\n\n\tif (!phys_enc->hw_intf || !phys_enc->hw_intf->ops.get_line_count)\n\t\treturn -EINVAL;\n\n\treturn phys_enc->hw_intf->ops.get_line_count(phys_enc->hw_intf);\n}\n\nstatic int dpu_encoder_phys_vid_get_frame_count(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_intf_status s = {0};\n\tu32 fetch_start = 0;\n\tstruct drm_display_mode mode;\n\n\tdrm_mode_init(&mode, &phys_enc->cached_mode);\n\n\tif (!dpu_encoder_phys_vid_is_master(phys_enc))\n\t\treturn -EINVAL;\n\n\tif (!phys_enc->hw_intf || !phys_enc->hw_intf->ops.get_status)\n\t\treturn -EINVAL;\n\n\tphys_enc->hw_intf->ops.get_status(phys_enc->hw_intf, &s);\n\n\tif (s.is_prog_fetch_en && s.is_en) {\n\t\tfetch_start = mode.vtotal - (mode.vsync_start - mode.vdisplay);\n\t\tif ((s.line_count > fetch_start) &&\n\t\t\t(s.line_count <= mode.vtotal))\n\t\t\treturn s.frame_count + 1;\n\t}\n\n\treturn s.frame_count;\n}\n\nstatic void dpu_encoder_phys_vid_init_ops(struct dpu_encoder_phys_ops *ops)\n{\n\tops->is_master = dpu_encoder_phys_vid_is_master;\n\tops->atomic_mode_set = dpu_encoder_phys_vid_atomic_mode_set;\n\tops->enable = dpu_encoder_phys_vid_enable;\n\tops->disable = dpu_encoder_phys_vid_disable;\n\tops->destroy = dpu_encoder_phys_vid_destroy;\n\tops->control_vblank_irq = dpu_encoder_phys_vid_control_vblank_irq;\n\tops->wait_for_commit_done = dpu_encoder_phys_vid_wait_for_commit_done;\n\tops->wait_for_vblank = dpu_encoder_phys_vid_wait_for_vblank;\n\tops->wait_for_tx_complete = dpu_encoder_phys_vid_wait_for_vblank;\n\tops->irq_control = dpu_encoder_phys_vid_irq_control;\n\tops->prepare_for_kickoff = dpu_encoder_phys_vid_prepare_for_kickoff;\n\tops->handle_post_kickoff = dpu_encoder_phys_vid_handle_post_kickoff;\n\tops->needs_single_flush = dpu_encoder_phys_vid_needs_single_flush;\n\tops->get_line_count = dpu_encoder_phys_vid_get_line_count;\n\tops->get_frame_count = dpu_encoder_phys_vid_get_frame_count;\n}\n\nstruct dpu_encoder_phys *dpu_encoder_phys_vid_init(\n\t\tstruct dpu_enc_phys_init_params *p)\n{\n\tstruct dpu_encoder_phys *phys_enc = NULL;\n\n\tif (!p) {\n\t\tDPU_ERROR(\"failed to create encoder due to invalid parameter\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tphys_enc = kzalloc(sizeof(*phys_enc), GFP_KERNEL);\n\tif (!phys_enc) {\n\t\tDPU_ERROR(\"failed to create encoder due to memory allocation error\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tDPU_DEBUG_VIDENC(phys_enc, \"\\n\");\n\n\tdpu_encoder_phys_init(phys_enc, p);\n\n\tdpu_encoder_phys_vid_init_ops(&phys_enc->ops);\n\tphys_enc->intf_mode = INTF_MODE_VIDEO;\n\n\tDPU_DEBUG_VIDENC(phys_enc, \"created intf idx:%d\\n\", p->hw_intf->idx);\n\n\treturn phys_enc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}