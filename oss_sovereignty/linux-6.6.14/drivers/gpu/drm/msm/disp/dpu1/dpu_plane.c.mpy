{
  "module_name": "dpu_plane.c",
  "hash_id": "276bda2ff3be9d607a7d431f45a467deb7503ce41c41331ab312ba78376b7bab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm:%s:%d] \" fmt, __func__, __LINE__\n\n#include <linux/debugfs.h>\n#include <linux/dma-buf.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n\n#include \"msm_drv.h\"\n#include \"dpu_kms.h\"\n#include \"dpu_formats.h\"\n#include \"dpu_hw_sspp.h\"\n#include \"dpu_trace.h\"\n#include \"dpu_crtc.h\"\n#include \"dpu_vbif.h\"\n#include \"dpu_plane.h\"\n\n#define DPU_DEBUG_PLANE(pl, fmt, ...) DRM_DEBUG_ATOMIC(\"plane%d \" fmt,\\\n\t\t(pl) ? (pl)->base.base.id : -1, ##__VA_ARGS__)\n\n#define DPU_ERROR_PLANE(pl, fmt, ...) DPU_ERROR(\"plane%d \" fmt,\\\n\t\t(pl) ? (pl)->base.base.id : -1, ##__VA_ARGS__)\n\n#define DECIMATED_DIMENSION(dim, deci) (((dim) + ((1 << (deci)) - 1)) >> (deci))\n#define PHASE_STEP_SHIFT\t21\n#define PHASE_STEP_UNIT_SCALE   ((int) (1 << PHASE_STEP_SHIFT))\n#define PHASE_RESIDUAL\t\t15\n\n#define SHARP_STRENGTH_DEFAULT\t32\n#define SHARP_EDGE_THR_DEFAULT\t112\n#define SHARP_SMOOTH_THR_DEFAULT\t8\n#define SHARP_NOISE_THR_DEFAULT\t2\n\n#define DPU_PLANE_COLOR_FILL_FLAG\tBIT(31)\n#define DPU_ZPOS_MAX 255\n\n \n#define DPU_QSEED3_DEFAULT_PRELOAD_H 0x4\n#define DPU_QSEED3_DEFAULT_PRELOAD_V 0x3\n#define DPU_QSEED4_DEFAULT_PRELOAD_V 0x2\n#define DPU_QSEED4_DEFAULT_PRELOAD_H 0x4\n\n#define DEFAULT_REFRESH_RATE\t60\n\nstatic const uint32_t qcom_compressed_supported_formats[] = {\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_BGR565,\n\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_P010,\n};\n\n \nstruct dpu_plane {\n\tstruct drm_plane base;\n\n\tstruct mutex lock;\n\n\tenum dpu_sspp pipe;\n\n\tuint32_t color_fill;\n\tbool is_error;\n\tbool is_rt_pipe;\n\tconst struct dpu_mdss_cfg *catalog;\n};\n\nstatic const uint64_t supported_format_modifiers[] = {\n\tDRM_FORMAT_MOD_QCOM_COMPRESSED,\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\n#define to_dpu_plane(x) container_of(x, struct dpu_plane, base)\n\nstatic struct dpu_kms *_dpu_plane_get_kms(struct drm_plane *plane)\n{\n\tstruct msm_drm_private *priv = plane->dev->dev_private;\n\n\treturn to_dpu_kms(priv->kms);\n}\n\n \nstatic u64 _dpu_plane_calc_bw(const struct dpu_mdss_cfg *catalog,\n\tconst struct dpu_format *fmt,\n\tconst struct drm_display_mode *mode,\n\tstruct dpu_sw_pipe_cfg *pipe_cfg)\n{\n\tint src_width, src_height, dst_height, fps;\n\tu64 plane_pixel_rate, plane_bit_rate;\n\tu64 plane_prefill_bw;\n\tu64 plane_bw;\n\tu32 hw_latency_lines;\n\tu64 scale_factor;\n\tint vbp, vpw, vfp;\n\n\tsrc_width = drm_rect_width(&pipe_cfg->src_rect);\n\tsrc_height = drm_rect_height(&pipe_cfg->src_rect);\n\tdst_height = drm_rect_height(&pipe_cfg->dst_rect);\n\tfps = drm_mode_vrefresh(mode);\n\tvbp = mode->vtotal - mode->vsync_end;\n\tvpw = mode->vsync_end - mode->vsync_start;\n\tvfp = mode->vsync_start - mode->vdisplay;\n\thw_latency_lines =  catalog->perf->min_prefill_lines;\n\tscale_factor = src_height > dst_height ?\n\t\tmult_frac(src_height, 1, dst_height) : 1;\n\n\tplane_pixel_rate = src_width * mode->vtotal * fps;\n\tplane_bit_rate = plane_pixel_rate * fmt->bpp;\n\n\tplane_bw = plane_bit_rate * scale_factor;\n\n\tplane_prefill_bw = plane_bw * hw_latency_lines;\n\n\tif ((vbp+vpw) > hw_latency_lines)\n\t\tdo_div(plane_prefill_bw, (vbp+vpw));\n\telse if ((vbp+vpw+vfp) < hw_latency_lines)\n\t\tdo_div(plane_prefill_bw, (vbp+vpw+vfp));\n\telse\n\t\tdo_div(plane_prefill_bw, hw_latency_lines);\n\n\n\treturn max(plane_bw, plane_prefill_bw);\n}\n\n \nstatic u64 _dpu_plane_calc_clk(const struct drm_display_mode *mode,\n\t\tstruct dpu_sw_pipe_cfg *pipe_cfg)\n{\n\tint dst_width, src_height, dst_height, fps;\n\tu64 plane_clk;\n\n\tsrc_height = drm_rect_height(&pipe_cfg->src_rect);\n\tdst_width = drm_rect_width(&pipe_cfg->dst_rect);\n\tdst_height = drm_rect_height(&pipe_cfg->dst_rect);\n\tfps = drm_mode_vrefresh(mode);\n\n\tplane_clk =\n\t\tdst_width * mode->vtotal * fps;\n\n\tif (src_height > dst_height) {\n\t\tplane_clk *= src_height;\n\t\tdo_div(plane_clk, dst_height);\n\t}\n\n\treturn plane_clk;\n}\n\n \nstatic int _dpu_plane_calc_fill_level(struct drm_plane *plane,\n\t\tstruct dpu_sw_pipe *pipe,\n\t\tenum dpu_qos_lut_usage lut_usage,\n\t\tconst struct dpu_format *fmt, u32 src_width)\n{\n\tstruct dpu_plane *pdpu;\n\tu32 fixed_buff_size;\n\tu32 total_fl;\n\n\tif (!fmt || !pipe || !src_width || !fmt->bpp) {\n\t\tDPU_ERROR(\"invalid arguments\\n\");\n\t\treturn 0;\n\t}\n\n\tif (lut_usage == DPU_QOS_LUT_USAGE_NRT)\n\t\treturn 0;\n\n\tpdpu = to_dpu_plane(plane);\n\tfixed_buff_size = pdpu->catalog->caps->pixel_ram_size;\n\n\t \n\n\tif (fmt->fetch_planes == DPU_PLANE_PSEUDO_PLANAR) {\n\t\tif (fmt->chroma_sample == DPU_CHROMA_420) {\n\t\t\t \n\t\t\ttotal_fl = (fixed_buff_size / 2) /\n\t\t\t\t((src_width + 32) * fmt->bpp);\n\t\t} else {\n\t\t\t \n\t\t\ttotal_fl = (fixed_buff_size / 2) * 2 /\n\t\t\t\t((src_width + 32) * fmt->bpp);\n\t\t}\n\t} else {\n\t\tif (pipe->multirect_mode == DPU_SSPP_MULTIRECT_PARALLEL) {\n\t\t\ttotal_fl = (fixed_buff_size / 2) * 2 /\n\t\t\t\t((src_width + 32) * fmt->bpp);\n\t\t} else {\n\t\t\ttotal_fl = (fixed_buff_size) * 2 /\n\t\t\t\t((src_width + 32) * fmt->bpp);\n\t\t}\n\t}\n\n\tDPU_DEBUG_PLANE(pdpu, \"pnum:%d fmt: %4.4s w:%u fl:%u\\n\",\n\t\t\tpipe->sspp->idx - SSPP_VIG0,\n\t\t\t(char *)&fmt->base.pixel_format,\n\t\t\tsrc_width, total_fl);\n\n\treturn total_fl;\n}\n\n \nstatic void _dpu_plane_set_qos_lut(struct drm_plane *plane,\n\t\tstruct dpu_sw_pipe *pipe,\n\t\tconst struct dpu_format *fmt, struct dpu_sw_pipe_cfg *pipe_cfg)\n{\n\tstruct dpu_plane *pdpu = to_dpu_plane(plane);\n\tstruct dpu_hw_qos_cfg cfg;\n\tu32 total_fl, lut_usage;\n\n\tif (!pdpu->is_rt_pipe) {\n\t\tlut_usage = DPU_QOS_LUT_USAGE_NRT;\n\t} else {\n\t\tif (fmt && DPU_FORMAT_IS_LINEAR(fmt))\n\t\t\tlut_usage = DPU_QOS_LUT_USAGE_LINEAR;\n\t\telse\n\t\t\tlut_usage = DPU_QOS_LUT_USAGE_MACROTILE;\n\t}\n\n\ttotal_fl = _dpu_plane_calc_fill_level(plane, pipe, lut_usage, fmt,\n\t\t\t\tdrm_rect_width(&pipe_cfg->src_rect));\n\n\tcfg.creq_lut = _dpu_hw_get_qos_lut(&pdpu->catalog->perf->qos_lut_tbl[lut_usage], total_fl);\n\tcfg.danger_lut = pdpu->catalog->perf->danger_lut_tbl[lut_usage];\n\tcfg.safe_lut = pdpu->catalog->perf->safe_lut_tbl[lut_usage];\n\n\tif (pipe->sspp->idx != SSPP_CURSOR0 &&\n\t    pipe->sspp->idx != SSPP_CURSOR1 &&\n\t    pdpu->is_rt_pipe)\n\t\tcfg.danger_safe_en = true;\n\n\tDPU_DEBUG_PLANE(pdpu, \"pnum:%d ds:%d is_rt:%d\\n\",\n\t\tpdpu->pipe - SSPP_VIG0,\n\t\tcfg.danger_safe_en,\n\t\tpdpu->is_rt_pipe);\n\n\ttrace_dpu_perf_set_qos_luts(pipe->sspp->idx - SSPP_VIG0,\n\t\t\t(fmt) ? fmt->base.pixel_format : 0,\n\t\t\tpdpu->is_rt_pipe, total_fl, cfg.creq_lut, lut_usage);\n\n\tDPU_DEBUG_PLANE(pdpu, \"pnum:%d fmt: %4.4s rt:%d fl:%u lut:0x%llx\\n\",\n\t\t\tpdpu->pipe - SSPP_VIG0,\n\t\t\tfmt ? (char *)&fmt->base.pixel_format : NULL,\n\t\t\tpdpu->is_rt_pipe, total_fl, cfg.creq_lut);\n\n\ttrace_dpu_perf_set_danger_luts(pdpu->pipe - SSPP_VIG0,\n\t\t\t(fmt) ? fmt->base.pixel_format : 0,\n\t\t\t(fmt) ? fmt->fetch_mode : 0,\n\t\t\tcfg.danger_lut,\n\t\t\tcfg.safe_lut);\n\n\tDPU_DEBUG_PLANE(pdpu, \"pnum:%d fmt: %4.4s mode:%d luts[0x%x, 0x%x]\\n\",\n\t\tpdpu->pipe - SSPP_VIG0,\n\t\tfmt ? (char *)&fmt->base.pixel_format : NULL,\n\t\tfmt ? fmt->fetch_mode : -1,\n\t\tcfg.danger_lut,\n\t\tcfg.safe_lut);\n\n\tpipe->sspp->ops.setup_qos_lut(pipe->sspp, &cfg);\n}\n\n \nstatic void _dpu_plane_set_qos_ctrl(struct drm_plane *plane,\n\tstruct dpu_sw_pipe *pipe,\n\tbool enable)\n{\n\tstruct dpu_plane *pdpu = to_dpu_plane(plane);\n\n\tif (!pdpu->is_rt_pipe)\n\t\tenable = false;\n\n\tDPU_DEBUG_PLANE(pdpu, \"pnum:%d ds:%d is_rt:%d\\n\",\n\t\tpdpu->pipe - SSPP_VIG0,\n\t\tenable,\n\t\tpdpu->is_rt_pipe);\n\n\tpipe->sspp->ops.setup_qos_ctrl(pipe->sspp,\n\t\t\t\t       enable);\n}\n\n \nstatic void _dpu_plane_set_ot_limit(struct drm_plane *plane,\n\t\tstruct dpu_sw_pipe *pipe,\n\t\tstruct dpu_sw_pipe_cfg *pipe_cfg,\n\t\tint frame_rate)\n{\n\tstruct dpu_plane *pdpu = to_dpu_plane(plane);\n\tstruct dpu_vbif_set_ot_params ot_params;\n\tstruct dpu_kms *dpu_kms = _dpu_plane_get_kms(plane);\n\n\tmemset(&ot_params, 0, sizeof(ot_params));\n\tot_params.xin_id = pipe->sspp->cap->xin_id;\n\tot_params.num = pipe->sspp->idx - SSPP_NONE;\n\tot_params.width = drm_rect_width(&pipe_cfg->src_rect);\n\tot_params.height = drm_rect_height(&pipe_cfg->src_rect);\n\tot_params.is_wfd = !pdpu->is_rt_pipe;\n\tot_params.frame_rate = frame_rate;\n\tot_params.vbif_idx = VBIF_RT;\n\tot_params.clk_ctrl = pipe->sspp->cap->clk_ctrl;\n\tot_params.rd = true;\n\n\tdpu_vbif_set_ot_limit(dpu_kms, &ot_params);\n}\n\n \nstatic void _dpu_plane_set_qos_remap(struct drm_plane *plane,\n\t\tstruct dpu_sw_pipe *pipe)\n{\n\tstruct dpu_plane *pdpu = to_dpu_plane(plane);\n\tstruct dpu_vbif_set_qos_params qos_params;\n\tstruct dpu_kms *dpu_kms = _dpu_plane_get_kms(plane);\n\n\tmemset(&qos_params, 0, sizeof(qos_params));\n\tqos_params.vbif_idx = VBIF_RT;\n\tqos_params.clk_ctrl = pipe->sspp->cap->clk_ctrl;\n\tqos_params.xin_id = pipe->sspp->cap->xin_id;\n\tqos_params.num = pipe->sspp->idx - SSPP_VIG0;\n\tqos_params.is_rt = pdpu->is_rt_pipe;\n\n\tDPU_DEBUG_PLANE(pdpu, \"pipe:%d vbif:%d xin:%d rt:%d, clk_ctrl:%d\\n\",\n\t\t\tqos_params.num,\n\t\t\tqos_params.vbif_idx,\n\t\t\tqos_params.xin_id, qos_params.is_rt,\n\t\t\tqos_params.clk_ctrl);\n\n\tdpu_vbif_set_qos_remap(dpu_kms, &qos_params);\n}\n\nstatic void _dpu_plane_setup_scaler3(struct dpu_hw_sspp *pipe_hw,\n\t\tuint32_t src_w, uint32_t src_h, uint32_t dst_w, uint32_t dst_h,\n\t\tstruct dpu_hw_scaler3_cfg *scale_cfg,\n\t\tconst struct dpu_format *fmt,\n\t\tuint32_t chroma_subsmpl_h, uint32_t chroma_subsmpl_v,\n\t\tunsigned int rotation)\n{\n\tuint32_t i;\n\tbool inline_rotation = rotation & DRM_MODE_ROTATE_90;\n\n\t \n\tif (inline_rotation)\n\t\tswap(src_w, src_h);\n\n\tscale_cfg->phase_step_x[DPU_SSPP_COMP_0] =\n\t\tmult_frac((1 << PHASE_STEP_SHIFT), src_w, dst_w);\n\tscale_cfg->phase_step_y[DPU_SSPP_COMP_0] =\n\t\tmult_frac((1 << PHASE_STEP_SHIFT), src_h, dst_h);\n\n\n\tscale_cfg->phase_step_y[DPU_SSPP_COMP_1_2] =\n\t\tscale_cfg->phase_step_y[DPU_SSPP_COMP_0] / chroma_subsmpl_v;\n\tscale_cfg->phase_step_x[DPU_SSPP_COMP_1_2] =\n\t\tscale_cfg->phase_step_x[DPU_SSPP_COMP_0] / chroma_subsmpl_h;\n\n\tscale_cfg->phase_step_x[DPU_SSPP_COMP_2] =\n\t\tscale_cfg->phase_step_x[DPU_SSPP_COMP_1_2];\n\tscale_cfg->phase_step_y[DPU_SSPP_COMP_2] =\n\t\tscale_cfg->phase_step_y[DPU_SSPP_COMP_1_2];\n\n\tscale_cfg->phase_step_x[DPU_SSPP_COMP_3] =\n\t\tscale_cfg->phase_step_x[DPU_SSPP_COMP_0];\n\tscale_cfg->phase_step_y[DPU_SSPP_COMP_3] =\n\t\tscale_cfg->phase_step_y[DPU_SSPP_COMP_0];\n\n\tfor (i = 0; i < DPU_MAX_PLANES; i++) {\n\t\tscale_cfg->src_width[i] = src_w;\n\t\tscale_cfg->src_height[i] = src_h;\n\t\tif (i == DPU_SSPP_COMP_1_2 || i == DPU_SSPP_COMP_2) {\n\t\t\tscale_cfg->src_width[i] /= chroma_subsmpl_h;\n\t\t\tscale_cfg->src_height[i] /= chroma_subsmpl_v;\n\t\t}\n\n\t\tif (pipe_hw->cap->features &\n\t\t\tBIT(DPU_SSPP_SCALER_QSEED4)) {\n\t\t\tscale_cfg->preload_x[i] = DPU_QSEED4_DEFAULT_PRELOAD_H;\n\t\t\tscale_cfg->preload_y[i] = DPU_QSEED4_DEFAULT_PRELOAD_V;\n\t\t} else {\n\t\t\tscale_cfg->preload_x[i] = DPU_QSEED3_DEFAULT_PRELOAD_H;\n\t\t\tscale_cfg->preload_y[i] = DPU_QSEED3_DEFAULT_PRELOAD_V;\n\t\t}\n\t}\n\tif (!(DPU_FORMAT_IS_YUV(fmt)) && (src_h == dst_h)\n\t\t&& (src_w == dst_w))\n\t\treturn;\n\n\tscale_cfg->dst_width = dst_w;\n\tscale_cfg->dst_height = dst_h;\n\tscale_cfg->y_rgb_filter_cfg = DPU_SCALE_BIL;\n\tscale_cfg->uv_filter_cfg = DPU_SCALE_BIL;\n\tscale_cfg->alpha_filter_cfg = DPU_SCALE_ALPHA_BIL;\n\tscale_cfg->lut_flag = 0;\n\tscale_cfg->blend_cfg = 1;\n\tscale_cfg->enable = 1;\n}\n\nstatic void _dpu_plane_setup_pixel_ext(struct dpu_hw_scaler3_cfg *scale_cfg,\n\t\t\t\tstruct dpu_hw_pixel_ext *pixel_ext,\n\t\t\t\tuint32_t src_w, uint32_t src_h,\n\t\t\t\tuint32_t chroma_subsmpl_h, uint32_t chroma_subsmpl_v)\n{\n\tint i;\n\n\tfor (i = 0; i < DPU_MAX_PLANES; i++) {\n\t\tif (i == DPU_SSPP_COMP_1_2 || i == DPU_SSPP_COMP_2) {\n\t\t\tsrc_w /= chroma_subsmpl_h;\n\t\t\tsrc_h /= chroma_subsmpl_v;\n\t\t}\n\n\t\tpixel_ext->num_ext_pxls_top[i] = src_h;\n\t\tpixel_ext->num_ext_pxls_left[i] = src_w;\n\t}\n}\n\nstatic const struct dpu_csc_cfg dpu_csc_YUV2RGB_601L = {\n\t{\n\t\t \n\t\t0x00012A00, 0x00000000, 0x00019880,\n\t\t0x00012A00, 0xFFFF9B80, 0xFFFF3000,\n\t\t0x00012A00, 0x00020480, 0x00000000,\n\t},\n\t \n\t{ 0xfff0, 0xff80, 0xff80,},\n\t{ 0x0, 0x0, 0x0,},\n\t \n\t{ 0x10, 0xeb, 0x10, 0xf0, 0x10, 0xf0,},\n\t{ 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,},\n};\n\nstatic const struct dpu_csc_cfg dpu_csc10_YUV2RGB_601L = {\n\t{\n\t\t \n\t\t0x00012A00, 0x00000000, 0x00019880,\n\t\t0x00012A00, 0xFFFF9B80, 0xFFFF3000,\n\t\t0x00012A00, 0x00020480, 0x00000000,\n\t\t},\n\t \n\t{ 0xffc0, 0xfe00, 0xfe00,},\n\t{ 0x0, 0x0, 0x0,},\n\t \n\t{ 0x40, 0x3ac, 0x40, 0x3c0, 0x40, 0x3c0,},\n\t{ 0x00, 0x3ff, 0x00, 0x3ff, 0x00, 0x3ff,},\n};\n\nstatic const struct dpu_csc_cfg *_dpu_plane_get_csc(struct dpu_sw_pipe *pipe,\n\t\t\t\t\t\t    const struct dpu_format *fmt)\n{\n\tconst struct dpu_csc_cfg *csc_ptr;\n\n\tif (!DPU_FORMAT_IS_YUV(fmt))\n\t\treturn NULL;\n\n\tif (BIT(DPU_SSPP_CSC_10BIT) & pipe->sspp->cap->features)\n\t\tcsc_ptr = &dpu_csc10_YUV2RGB_601L;\n\telse\n\t\tcsc_ptr = &dpu_csc_YUV2RGB_601L;\n\n\treturn csc_ptr;\n}\n\nstatic void _dpu_plane_setup_scaler(struct dpu_sw_pipe *pipe,\n\t\tconst struct dpu_format *fmt, bool color_fill,\n\t\tstruct dpu_sw_pipe_cfg *pipe_cfg,\n\t\tunsigned int rotation)\n{\n\tstruct dpu_hw_sspp *pipe_hw = pipe->sspp;\n\tconst struct drm_format_info *info = drm_format_info(fmt->base.pixel_format);\n\tstruct dpu_hw_scaler3_cfg scaler3_cfg;\n\tstruct dpu_hw_pixel_ext pixel_ext;\n\tu32 src_width = drm_rect_width(&pipe_cfg->src_rect);\n\tu32 src_height = drm_rect_height(&pipe_cfg->src_rect);\n\tu32 dst_width = drm_rect_width(&pipe_cfg->dst_rect);\n\tu32 dst_height = drm_rect_height(&pipe_cfg->dst_rect);\n\n\tmemset(&scaler3_cfg, 0, sizeof(scaler3_cfg));\n\tmemset(&pixel_ext, 0, sizeof(pixel_ext));\n\n\t \n\t \n\t_dpu_plane_setup_scaler3(pipe_hw,\n\t\t\tsrc_width,\n\t\t\tsrc_height,\n\t\t\tdst_width,\n\t\t\tdst_height,\n\t\t\t&scaler3_cfg, fmt,\n\t\t\tinfo->hsub, info->vsub,\n\t\t\trotation);\n\n\t \n\t_dpu_plane_setup_pixel_ext(&scaler3_cfg, &pixel_ext,\n\t\t\tsrc_width, src_height, info->hsub, info->vsub);\n\n\tif (pipe_hw->ops.setup_pe)\n\t\tpipe_hw->ops.setup_pe(pipe_hw,\n\t\t\t\t&pixel_ext);\n\n\t \n\tif (pipe_hw->ops.setup_scaler &&\n\t\t\tpipe->multirect_index != DPU_SSPP_RECT_1)\n\t\tpipe_hw->ops.setup_scaler(pipe_hw,\n\t\t\t\t&scaler3_cfg,\n\t\t\t\tfmt);\n}\n\nstatic void _dpu_plane_color_fill_pipe(struct dpu_plane_state *pstate,\n\t\t\t\t       struct dpu_sw_pipe *pipe,\n\t\t\t\t       struct drm_rect *dst_rect,\n\t\t\t\t       u32 fill_color,\n\t\t\t\t       const struct dpu_format *fmt)\n{\n\tstruct dpu_sw_pipe_cfg pipe_cfg;\n\n\t \n\tif (!pipe->sspp->ops.setup_solidfill)\n\t\treturn;\n\n\tpipe->sspp->ops.setup_solidfill(pipe, fill_color);\n\n\t \n\tpipe_cfg.dst_rect = *dst_rect;\n\n\tpipe_cfg.src_rect.x1 = 0;\n\tpipe_cfg.src_rect.y1 = 0;\n\tpipe_cfg.src_rect.x2 =\n\t\tdrm_rect_width(&pipe_cfg.dst_rect);\n\tpipe_cfg.src_rect.y2 =\n\t\tdrm_rect_height(&pipe_cfg.dst_rect);\n\n\tif (pipe->sspp->ops.setup_format)\n\t\tpipe->sspp->ops.setup_format(pipe, fmt, DPU_SSPP_SOLID_FILL);\n\n\tif (pipe->sspp->ops.setup_rects)\n\t\tpipe->sspp->ops.setup_rects(pipe, &pipe_cfg);\n\n\t_dpu_plane_setup_scaler(pipe, fmt, true, &pipe_cfg, pstate->rotation);\n}\n\n \nstatic void _dpu_plane_color_fill(struct dpu_plane *pdpu,\n\t\tuint32_t color, uint32_t alpha)\n{\n\tconst struct dpu_format *fmt;\n\tconst struct drm_plane *plane = &pdpu->base;\n\tstruct dpu_plane_state *pstate = to_dpu_plane_state(plane->state);\n\tu32 fill_color = (color & 0xFFFFFF) | ((alpha & 0xFF) << 24);\n\n\tDPU_DEBUG_PLANE(pdpu, \"\\n\");\n\n\t \n\tfmt = dpu_get_dpu_format(DRM_FORMAT_ABGR8888);\n\t \n\tif (!fmt)\n\t\treturn;\n\n\t \n\t_dpu_plane_color_fill_pipe(pstate, &pstate->pipe, &pstate->pipe_cfg.dst_rect,\n\t\t\t\t   fill_color, fmt);\n\n\tif (pstate->r_pipe.sspp)\n\t\t_dpu_plane_color_fill_pipe(pstate, &pstate->r_pipe, &pstate->r_pipe_cfg.dst_rect,\n\t\t\t\t\t   fill_color, fmt);\n}\n\nstatic int dpu_plane_prepare_fb(struct drm_plane *plane,\n\t\tstruct drm_plane_state *new_state)\n{\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct dpu_plane *pdpu = to_dpu_plane(plane);\n\tstruct dpu_plane_state *pstate = to_dpu_plane_state(new_state);\n\tstruct dpu_hw_fmt_layout layout;\n\tstruct dpu_kms *kms = _dpu_plane_get_kms(&pdpu->base);\n\tint ret;\n\n\tif (!new_state->fb)\n\t\treturn 0;\n\n\tDPU_DEBUG_PLANE(pdpu, \"FB[%u]\\n\", fb->base.id);\n\n\t \n\tpstate->aspace = kms->base.aspace;\n\n\t \n\tdrm_gem_plane_helper_prepare_fb(plane, new_state);\n\n\tif (pstate->aspace) {\n\t\tret = msm_framebuffer_prepare(new_state->fb,\n\t\t\t\tpstate->aspace, pstate->needs_dirtyfb);\n\t\tif (ret) {\n\t\t\tDPU_ERROR(\"failed to prepare framebuffer\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = dpu_format_populate_layout(pstate->aspace,\n\t\t\tnew_state->fb, &layout);\n\tif (ret) {\n\t\tDPU_ERROR_PLANE(pdpu, \"failed to get format layout, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dpu_plane_cleanup_fb(struct drm_plane *plane,\n\t\tstruct drm_plane_state *old_state)\n{\n\tstruct dpu_plane *pdpu = to_dpu_plane(plane);\n\tstruct dpu_plane_state *old_pstate;\n\n\tif (!old_state || !old_state->fb)\n\t\treturn;\n\n\told_pstate = to_dpu_plane_state(old_state);\n\n\tDPU_DEBUG_PLANE(pdpu, \"FB[%u]\\n\", old_state->fb->base.id);\n\n\tmsm_framebuffer_cleanup(old_state->fb, old_pstate->aspace,\n\t\t\t\told_pstate->needs_dirtyfb);\n}\n\nstatic int dpu_plane_check_inline_rotation(struct dpu_plane *pdpu,\n\t\t\t\t\t\tconst struct dpu_sspp_sub_blks *sblk,\n\t\t\t\t\t\tstruct drm_rect src, const struct dpu_format *fmt)\n{\n\tsize_t num_formats;\n\tconst u32 *supported_formats;\n\n\tif (!sblk->rotation_cfg) {\n\t\tDPU_ERROR(\"invalid rotation cfg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (drm_rect_width(&src) > sblk->rotation_cfg->rot_maxheight) {\n\t\tDPU_DEBUG_PLANE(pdpu, \"invalid height for inline rot:%d max:%d\\n\",\n\t\t\t\tsrc.y2, sblk->rotation_cfg->rot_maxheight);\n\t\treturn -EINVAL;\n\t}\n\n\tsupported_formats = sblk->rotation_cfg->rot_format_list;\n\tnum_formats = sblk->rotation_cfg->rot_num_formats;\n\n\tif (!DPU_FORMAT_IS_UBWC(fmt) ||\n\t\t!dpu_find_format(fmt->base.pixel_format, supported_formats, num_formats))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int dpu_plane_atomic_check_pipe(struct dpu_plane *pdpu,\n\t\tstruct dpu_sw_pipe *pipe,\n\t\tstruct dpu_sw_pipe_cfg *pipe_cfg,\n\t\tconst struct dpu_format *fmt,\n\t\tconst struct drm_display_mode *mode)\n{\n\tuint32_t min_src_size;\n\tstruct dpu_kms *kms = _dpu_plane_get_kms(&pdpu->base);\n\n\tmin_src_size = DPU_FORMAT_IS_YUV(fmt) ? 2 : 1;\n\n\tif (DPU_FORMAT_IS_YUV(fmt) &&\n\t    (!(pipe->sspp->cap->features & DPU_SSPP_SCALER) ||\n\t     !(pipe->sspp->cap->features & DPU_SSPP_CSC_ANY))) {\n\t\tDPU_DEBUG_PLANE(pdpu,\n\t\t\t\t\"plane doesn't have scaler/csc for yuv\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (drm_rect_width(&pipe_cfg->src_rect) < min_src_size ||\n\t    drm_rect_height(&pipe_cfg->src_rect) < min_src_size) {\n\t\tDPU_DEBUG_PLANE(pdpu, \"invalid source \" DRM_RECT_FMT \"\\n\",\n\t\t\t\tDRM_RECT_ARG(&pipe_cfg->src_rect));\n\t\treturn -E2BIG;\n\t}\n\n\t \n\tif (DPU_FORMAT_IS_YUV(fmt) &&\n\t    (pipe_cfg->src_rect.x1 & 0x1 ||\n\t     pipe_cfg->src_rect.y1 & 0x1 ||\n\t     drm_rect_width(&pipe_cfg->src_rect) & 0x1 ||\n\t     drm_rect_height(&pipe_cfg->src_rect) & 0x1)) {\n\t\tDPU_DEBUG_PLANE(pdpu, \"invalid yuv source \" DRM_RECT_FMT \"\\n\",\n\t\t\t\tDRM_RECT_ARG(&pipe_cfg->src_rect));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (drm_rect_width(&pipe_cfg->dst_rect) < 0x1 ||\n\t    drm_rect_height(&pipe_cfg->dst_rect) < 0x1) {\n\t\tDPU_DEBUG_PLANE(pdpu, \"invalid dest rect \" DRM_RECT_FMT \"\\n\",\n\t\t\t\tDRM_RECT_ARG(&pipe_cfg->dst_rect));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (_dpu_plane_calc_clk(mode, pipe_cfg) > kms->perf.max_core_clk_rate) {\n\t\tDPU_DEBUG_PLANE(pdpu, \"plane exceeds max mdp core clk limits\\n\");\n\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}\n\nstatic int dpu_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tint ret = 0, min_scale;\n\tstruct dpu_plane *pdpu = to_dpu_plane(plane);\n\tstruct dpu_plane_state *pstate = to_dpu_plane_state(new_plane_state);\n\tstruct dpu_sw_pipe *pipe = &pstate->pipe;\n\tstruct dpu_sw_pipe *r_pipe = &pstate->r_pipe;\n\tconst struct drm_crtc_state *crtc_state = NULL;\n\tconst struct dpu_format *fmt;\n\tstruct dpu_sw_pipe_cfg *pipe_cfg = &pstate->pipe_cfg;\n\tstruct dpu_sw_pipe_cfg *r_pipe_cfg = &pstate->r_pipe_cfg;\n\tstruct drm_rect fb_rect = { 0 };\n\tuint32_t max_linewidth;\n\tunsigned int rotation;\n\tuint32_t supported_rotations;\n\tconst struct dpu_sspp_cfg *pipe_hw_caps = pstate->pipe.sspp->cap;\n\tconst struct dpu_sspp_sub_blks *sblk = pstate->pipe.sspp->cap->sblk;\n\n\tif (new_plane_state->crtc)\n\t\tcrtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t   new_plane_state->crtc);\n\n\tmin_scale = FRAC_16_16(1, sblk->maxupscale);\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,\n\t\t\t\t\t\t  min_scale,\n\t\t\t\t\t\t  sblk->maxdwnscale << 16,\n\t\t\t\t\t\t  true, true);\n\tif (ret) {\n\t\tDPU_DEBUG_PLANE(pdpu, \"Check plane state failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (!new_plane_state->visible)\n\t\treturn 0;\n\n\tpipe->multirect_index = DPU_SSPP_RECT_SOLO;\n\tpipe->multirect_mode = DPU_SSPP_MULTIRECT_NONE;\n\tr_pipe->multirect_index = DPU_SSPP_RECT_SOLO;\n\tr_pipe->multirect_mode = DPU_SSPP_MULTIRECT_NONE;\n\tr_pipe->sspp = NULL;\n\n\tpstate->stage = DPU_STAGE_0 + pstate->base.normalized_zpos;\n\tif (pstate->stage >= pdpu->catalog->caps->max_mixer_blendstages) {\n\t\tDPU_ERROR(\"> %d plane stages assigned\\n\",\n\t\t\t  pdpu->catalog->caps->max_mixer_blendstages - DPU_STAGE_0);\n\t\treturn -EINVAL;\n\t}\n\n\tpipe_cfg->src_rect = new_plane_state->src;\n\n\t \n\tpipe_cfg->src_rect.x1 >>= 16;\n\tpipe_cfg->src_rect.x2 >>= 16;\n\tpipe_cfg->src_rect.y1 >>= 16;\n\tpipe_cfg->src_rect.y2 >>= 16;\n\n\tpipe_cfg->dst_rect = new_plane_state->dst;\n\n\tfb_rect.x2 = new_plane_state->fb->width;\n\tfb_rect.y2 = new_plane_state->fb->height;\n\n\t \n\tif (drm_rect_width(&fb_rect) > MAX_IMG_WIDTH ||\n\t    drm_rect_height(&fb_rect) > MAX_IMG_HEIGHT) {\n\t\tDPU_DEBUG_PLANE(pdpu, \"invalid framebuffer \" DRM_RECT_FMT \"\\n\",\n\t\t\t\tDRM_RECT_ARG(&fb_rect));\n\t\treturn -E2BIG;\n\t}\n\n\tfmt = to_dpu_format(msm_framebuffer_format(new_plane_state->fb));\n\n\tmax_linewidth = pdpu->catalog->caps->max_linewidth;\n\n\tif (drm_rect_width(&pipe_cfg->src_rect) > max_linewidth) {\n\t\t \n\t\tif (DPU_FORMAT_IS_UBWC(fmt)) {\n\t\t\tDPU_DEBUG_PLANE(pdpu, \"invalid src \" DRM_RECT_FMT \" line:%u, tiled format\\n\",\n\t\t\t\t\tDRM_RECT_ARG(&pipe_cfg->src_rect), max_linewidth);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\tif (drm_rect_width(&pipe_cfg->src_rect) > 2 * max_linewidth) {\n\t\t\tDPU_DEBUG_PLANE(pdpu, \"invalid src \" DRM_RECT_FMT \" line:%u\\n\",\n\t\t\t\t\tDRM_RECT_ARG(&pipe_cfg->src_rect), max_linewidth);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\tif (drm_rect_width(&pipe_cfg->src_rect) != drm_rect_width(&pipe_cfg->dst_rect) ||\n\t\t    drm_rect_height(&pipe_cfg->src_rect) != drm_rect_height(&pipe_cfg->dst_rect) ||\n\t\t    (!test_bit(DPU_SSPP_SMART_DMA_V1, &pipe->sspp->cap->features) &&\n\t\t     !test_bit(DPU_SSPP_SMART_DMA_V2, &pipe->sspp->cap->features)) ||\n\t\t    DPU_FORMAT_IS_YUV(fmt)) {\n\t\t\tDPU_DEBUG_PLANE(pdpu, \"invalid src \" DRM_RECT_FMT \" line:%u, can't use split source\\n\",\n\t\t\t\t\tDRM_RECT_ARG(&pipe_cfg->src_rect), max_linewidth);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\t \n\t\tpipe->multirect_index = DPU_SSPP_RECT_0;\n\t\tpipe->multirect_mode = DPU_SSPP_MULTIRECT_PARALLEL;\n\n\t\tr_pipe->sspp = pipe->sspp;\n\t\tr_pipe->multirect_index = DPU_SSPP_RECT_1;\n\t\tr_pipe->multirect_mode = DPU_SSPP_MULTIRECT_PARALLEL;\n\n\t\t*r_pipe_cfg = *pipe_cfg;\n\t\tpipe_cfg->src_rect.x2 = (pipe_cfg->src_rect.x1 + pipe_cfg->src_rect.x2) >> 1;\n\t\tpipe_cfg->dst_rect.x2 = (pipe_cfg->dst_rect.x1 + pipe_cfg->dst_rect.x2) >> 1;\n\t\tr_pipe_cfg->src_rect.x1 = pipe_cfg->src_rect.x2;\n\t\tr_pipe_cfg->dst_rect.x1 = pipe_cfg->dst_rect.x2;\n\t}\n\n\tret = dpu_plane_atomic_check_pipe(pdpu, pipe, pipe_cfg, fmt, &crtc_state->adjusted_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tif (r_pipe->sspp) {\n\t\tret = dpu_plane_atomic_check_pipe(pdpu, r_pipe, r_pipe_cfg, fmt,\n\t\t\t\t\t\t  &crtc_state->adjusted_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsupported_rotations = DRM_MODE_REFLECT_MASK | DRM_MODE_ROTATE_0;\n\n\tif (pipe_hw_caps->features & BIT(DPU_SSPP_INLINE_ROTATION))\n\t\tsupported_rotations |= DRM_MODE_ROTATE_90;\n\n\trotation = drm_rotation_simplify(new_plane_state->rotation,\n\t\t\t\t\tsupported_rotations);\n\n\tif ((pipe_hw_caps->features & BIT(DPU_SSPP_INLINE_ROTATION)) &&\n\t\t(rotation & DRM_MODE_ROTATE_90)) {\n\t\tret = dpu_plane_check_inline_rotation(pdpu, sblk, pipe_cfg->src_rect, fmt);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpstate->rotation = rotation;\n\tpstate->needs_qos_remap = drm_atomic_crtc_needs_modeset(crtc_state);\n\n\treturn 0;\n}\n\nstatic void dpu_plane_flush_csc(struct dpu_plane *pdpu, struct dpu_sw_pipe *pipe)\n{\n\tconst struct dpu_format *format =\n\t\tto_dpu_format(msm_framebuffer_format(pdpu->base.state->fb));\n\tconst struct dpu_csc_cfg *csc_ptr;\n\n\tif (!pipe->sspp || !pipe->sspp->ops.setup_csc)\n\t\treturn;\n\n\tcsc_ptr = _dpu_plane_get_csc(pipe, format);\n\tif (!csc_ptr)\n\t\treturn;\n\n\tDPU_DEBUG_PLANE(pdpu, \"using 0x%X 0x%X 0x%X...\\n\",\n\t\t\tcsc_ptr->csc_mv[0],\n\t\t\tcsc_ptr->csc_mv[1],\n\t\t\tcsc_ptr->csc_mv[2]);\n\n\tpipe->sspp->ops.setup_csc(pipe->sspp, csc_ptr);\n\n}\n\nvoid dpu_plane_flush(struct drm_plane *plane)\n{\n\tstruct dpu_plane *pdpu;\n\tstruct dpu_plane_state *pstate;\n\n\tif (!plane || !plane->state) {\n\t\tDPU_ERROR(\"invalid plane\\n\");\n\t\treturn;\n\t}\n\n\tpdpu = to_dpu_plane(plane);\n\tpstate = to_dpu_plane_state(plane->state);\n\n\t \n\tif (pdpu->is_error)\n\t\t \n\t\t_dpu_plane_color_fill(pdpu, 0xFFFFFF, 0xFF);\n\telse if (pdpu->color_fill & DPU_PLANE_COLOR_FILL_FLAG)\n\t\t \n\t\t_dpu_plane_color_fill(pdpu, pdpu->color_fill, 0xFF);\n\telse {\n\t\tdpu_plane_flush_csc(pdpu, &pstate->pipe);\n\t\tdpu_plane_flush_csc(pdpu, &pstate->r_pipe);\n\t}\n\n\t \n\tif (plane->state)\n\t\tpstate->pending = false;\n}\n\n \nvoid dpu_plane_set_error(struct drm_plane *plane, bool error)\n{\n\tstruct dpu_plane *pdpu;\n\n\tif (!plane)\n\t\treturn;\n\n\tpdpu = to_dpu_plane(plane);\n\tpdpu->is_error = error;\n}\n\nstatic void dpu_plane_sspp_update_pipe(struct drm_plane *plane,\n\t\t\t\t       struct dpu_sw_pipe *pipe,\n\t\t\t\t       struct dpu_sw_pipe_cfg *pipe_cfg,\n\t\t\t\t       const struct dpu_format *fmt,\n\t\t\t\t       int frame_rate,\n\t\t\t\t       struct dpu_hw_fmt_layout *layout)\n{\n\tuint32_t src_flags;\n\tstruct dpu_plane *pdpu = to_dpu_plane(plane);\n\tstruct drm_plane_state *state = plane->state;\n\tstruct dpu_plane_state *pstate = to_dpu_plane_state(state);\n\n\tif (layout && pipe->sspp->ops.setup_sourceaddress) {\n\t\ttrace_dpu_plane_set_scanout(pipe, layout);\n\t\tpipe->sspp->ops.setup_sourceaddress(pipe, layout);\n\t}\n\n\t \n\tif (pdpu->color_fill & DPU_PLANE_COLOR_FILL_FLAG) {\n\t\t_dpu_plane_set_qos_ctrl(plane, pipe, false);\n\n\t\t \n\t\treturn;\n\t}\n\n\tif (pipe->sspp->ops.setup_rects) {\n\t\tpipe->sspp->ops.setup_rects(pipe,\n\t\t\t\tpipe_cfg);\n\t}\n\n\t_dpu_plane_setup_scaler(pipe, fmt, false, pipe_cfg, pstate->rotation);\n\n\tif (pipe->sspp->ops.setup_multirect)\n\t\tpipe->sspp->ops.setup_multirect(\n\t\t\t\tpipe);\n\n\tif (pipe->sspp->ops.setup_format) {\n\t\tunsigned int rotation = pstate->rotation;\n\n\t\tsrc_flags = 0x0;\n\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tsrc_flags |= DPU_SSPP_FLIP_LR;\n\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tsrc_flags |= DPU_SSPP_FLIP_UD;\n\n\t\tif (rotation & DRM_MODE_ROTATE_90)\n\t\t\tsrc_flags |= DPU_SSPP_ROT_90;\n\n\t\t \n\t\tpipe->sspp->ops.setup_format(pipe, fmt, src_flags);\n\n\t\tif (pipe->sspp->ops.setup_cdp) {\n\t\t\tconst struct dpu_perf_cfg *perf = pdpu->catalog->perf;\n\n\t\t\tpipe->sspp->ops.setup_cdp(pipe, fmt,\n\t\t\t\t\t\t  perf->cdp_cfg[DPU_PERF_CDP_USAGE_RT].rd_enable);\n\t\t}\n\t}\n\n\t_dpu_plane_set_qos_lut(plane, pipe, fmt, pipe_cfg);\n\n\tif (pipe->sspp->idx != SSPP_CURSOR0 &&\n\t    pipe->sspp->idx != SSPP_CURSOR1)\n\t\t_dpu_plane_set_ot_limit(plane, pipe, pipe_cfg, frame_rate);\n\n\tif (pstate->needs_qos_remap)\n\t\t_dpu_plane_set_qos_remap(plane, pipe);\n}\n\nstatic void dpu_plane_sspp_atomic_update(struct drm_plane *plane)\n{\n\tstruct dpu_plane *pdpu = to_dpu_plane(plane);\n\tstruct drm_plane_state *state = plane->state;\n\tstruct dpu_plane_state *pstate = to_dpu_plane_state(state);\n\tstruct dpu_sw_pipe *pipe = &pstate->pipe;\n\tstruct dpu_sw_pipe *r_pipe = &pstate->r_pipe;\n\tstruct drm_crtc *crtc = state->crtc;\n\tstruct drm_framebuffer *fb = state->fb;\n\tbool is_rt_pipe;\n\tconst struct dpu_format *fmt =\n\t\tto_dpu_format(msm_framebuffer_format(fb));\n\tstruct dpu_sw_pipe_cfg *pipe_cfg = &pstate->pipe_cfg;\n\tstruct dpu_sw_pipe_cfg *r_pipe_cfg = &pstate->r_pipe_cfg;\n\tstruct dpu_kms *kms = _dpu_plane_get_kms(&pdpu->base);\n\tstruct msm_gem_address_space *aspace = kms->base.aspace;\n\tstruct dpu_hw_fmt_layout layout;\n\tbool layout_valid = false;\n\tint ret;\n\n\tret = dpu_format_populate_layout(aspace, fb, &layout);\n\tif (ret)\n\t\tDPU_ERROR_PLANE(pdpu, \"failed to get format layout, %d\\n\", ret);\n\telse\n\t\tlayout_valid = true;\n\n\tpstate->pending = true;\n\n\tis_rt_pipe = (dpu_crtc_get_client_type(crtc) != NRT_CLIENT);\n\tpstate->needs_qos_remap |= (is_rt_pipe != pdpu->is_rt_pipe);\n\tpdpu->is_rt_pipe = is_rt_pipe;\n\n\tDPU_DEBUG_PLANE(pdpu, \"FB[%u] \" DRM_RECT_FP_FMT \"->crtc%u \" DRM_RECT_FMT\n\t\t\t\", %4.4s ubwc %d\\n\", fb->base.id, DRM_RECT_FP_ARG(&state->src),\n\t\t\tcrtc->base.id, DRM_RECT_ARG(&state->dst),\n\t\t\t(char *)&fmt->base.pixel_format, DPU_FORMAT_IS_UBWC(fmt));\n\n\tdpu_plane_sspp_update_pipe(plane, pipe, pipe_cfg, fmt,\n\t\t\t\t   drm_mode_vrefresh(&crtc->mode),\n\t\t\t\t   layout_valid ? &layout : NULL);\n\n\tif (r_pipe->sspp) {\n\t\tdpu_plane_sspp_update_pipe(plane, r_pipe, r_pipe_cfg, fmt,\n\t\t\t\t\t   drm_mode_vrefresh(&crtc->mode),\n\t\t\t\t\t   layout_valid ? &layout : NULL);\n\t}\n\n\tif (pstate->needs_qos_remap)\n\t\tpstate->needs_qos_remap = false;\n\n\tpstate->plane_fetch_bw = _dpu_plane_calc_bw(pdpu->catalog, fmt,\n\t\t\t\t\t\t    &crtc->mode, pipe_cfg);\n\n\tpstate->plane_clk = _dpu_plane_calc_clk(&crtc->mode, pipe_cfg);\n\n\tif (r_pipe->sspp) {\n\t\tpstate->plane_fetch_bw += _dpu_plane_calc_bw(pdpu->catalog, fmt, &crtc->mode, r_pipe_cfg);\n\n\t\tpstate->plane_clk = max(pstate->plane_clk, _dpu_plane_calc_clk(&crtc->mode, r_pipe_cfg));\n\t}\n}\n\nstatic void _dpu_plane_atomic_disable(struct drm_plane *plane)\n{\n\tstruct drm_plane_state *state = plane->state;\n\tstruct dpu_plane_state *pstate = to_dpu_plane_state(state);\n\tstruct dpu_sw_pipe *r_pipe = &pstate->r_pipe;\n\n\ttrace_dpu_plane_disable(DRMID(plane), false,\n\t\t\t\tpstate->pipe.multirect_mode);\n\n\tif (r_pipe->sspp) {\n\t\tr_pipe->multirect_index = DPU_SSPP_RECT_SOLO;\n\t\tr_pipe->multirect_mode = DPU_SSPP_MULTIRECT_NONE;\n\n\t\tif (r_pipe->sspp->ops.setup_multirect)\n\t\t\tr_pipe->sspp->ops.setup_multirect(r_pipe);\n\t}\n\n\tpstate->pending = true;\n}\n\nstatic void dpu_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct dpu_plane *pdpu = to_dpu_plane(plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\n\tpdpu->is_error = false;\n\n\tDPU_DEBUG_PLANE(pdpu, \"\\n\");\n\n\tif (!new_state->visible) {\n\t\t_dpu_plane_atomic_disable(plane);\n\t} else {\n\t\tdpu_plane_sspp_atomic_update(plane);\n\t}\n}\n\nstatic void dpu_plane_destroy(struct drm_plane *plane)\n{\n\tstruct dpu_plane *pdpu = plane ? to_dpu_plane(plane) : NULL;\n\tstruct dpu_plane_state *pstate;\n\n\tDPU_DEBUG_PLANE(pdpu, \"\\n\");\n\n\tif (pdpu) {\n\t\tpstate = to_dpu_plane_state(plane->state);\n\t\t_dpu_plane_set_qos_ctrl(plane, &pstate->pipe, false);\n\n\t\tif (pstate->r_pipe.sspp)\n\t\t\t_dpu_plane_set_qos_ctrl(plane, &pstate->r_pipe, false);\n\n\t\tmutex_destroy(&pdpu->lock);\n\n\t\t \n\t\tdrm_plane_cleanup(plane);\n\n\t\tkfree(pdpu);\n\t}\n}\n\nstatic void dpu_plane_destroy_state(struct drm_plane *plane,\n\t\tstruct drm_plane_state *state)\n{\n\t__drm_atomic_helper_plane_destroy_state(state);\n\tkfree(to_dpu_plane_state(state));\n}\n\nstatic struct drm_plane_state *\ndpu_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct dpu_plane *pdpu;\n\tstruct dpu_plane_state *pstate;\n\tstruct dpu_plane_state *old_state;\n\n\tif (!plane) {\n\t\tDPU_ERROR(\"invalid plane\\n\");\n\t\treturn NULL;\n\t} else if (!plane->state) {\n\t\tDPU_ERROR(\"invalid plane state\\n\");\n\t\treturn NULL;\n\t}\n\n\told_state = to_dpu_plane_state(plane->state);\n\tpdpu = to_dpu_plane(plane);\n\tpstate = kmemdup(old_state, sizeof(*old_state), GFP_KERNEL);\n\tif (!pstate) {\n\t\tDPU_ERROR_PLANE(pdpu, \"failed to allocate state\\n\");\n\t\treturn NULL;\n\t}\n\n\tDPU_DEBUG_PLANE(pdpu, \"\\n\");\n\n\tpstate->pending = false;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &pstate->base);\n\n\treturn &pstate->base;\n}\n\nstatic const char * const multirect_mode_name[] = {\n\t[DPU_SSPP_MULTIRECT_NONE] = \"none\",\n\t[DPU_SSPP_MULTIRECT_PARALLEL] = \"parallel\",\n\t[DPU_SSPP_MULTIRECT_TIME_MX] = \"time_mx\",\n};\n\nstatic const char * const multirect_index_name[] = {\n\t[DPU_SSPP_RECT_SOLO] = \"solo\",\n\t[DPU_SSPP_RECT_0] = \"rect_0\",\n\t[DPU_SSPP_RECT_1] = \"rect_1\",\n};\n\nstatic const char *dpu_get_multirect_mode(enum dpu_sspp_multirect_mode mode)\n{\n\tif (WARN_ON(mode >= ARRAY_SIZE(multirect_mode_name)))\n\t\treturn \"unknown\";\n\n\treturn multirect_mode_name[mode];\n}\n\nstatic const char *dpu_get_multirect_index(enum dpu_sspp_multirect_index index)\n{\n\tif (WARN_ON(index >= ARRAY_SIZE(multirect_index_name)))\n\t\treturn \"unknown\";\n\n\treturn multirect_index_name[index];\n}\n\nstatic void dpu_plane_atomic_print_state(struct drm_printer *p,\n\t\tconst struct drm_plane_state *state)\n{\n\tconst struct dpu_plane_state *pstate = to_dpu_plane_state(state);\n\tconst struct dpu_sw_pipe *pipe = &pstate->pipe;\n\tconst struct dpu_sw_pipe_cfg *pipe_cfg = &pstate->pipe_cfg;\n\tconst struct dpu_sw_pipe *r_pipe = &pstate->r_pipe;\n\tconst struct dpu_sw_pipe_cfg *r_pipe_cfg = &pstate->r_pipe_cfg;\n\n\tdrm_printf(p, \"\\tstage=%d\\n\", pstate->stage);\n\n\tdrm_printf(p, \"\\tsspp[0]=%s\\n\", pipe->sspp->cap->name);\n\tdrm_printf(p, \"\\tmultirect_mode[0]=%s\\n\", dpu_get_multirect_mode(pipe->multirect_mode));\n\tdrm_printf(p, \"\\tmultirect_index[0]=%s\\n\",\n\t\t   dpu_get_multirect_index(pipe->multirect_index));\n\tdrm_printf(p, \"\\tsrc[0]=\" DRM_RECT_FMT \"\\n\", DRM_RECT_ARG(&pipe_cfg->src_rect));\n\tdrm_printf(p, \"\\tdst[0]=\" DRM_RECT_FMT \"\\n\", DRM_RECT_ARG(&pipe_cfg->dst_rect));\n\n\tif (r_pipe->sspp) {\n\t\tdrm_printf(p, \"\\tsspp[1]=%s\\n\", r_pipe->sspp->cap->name);\n\t\tdrm_printf(p, \"\\tmultirect_mode[1]=%s\\n\",\n\t\t\t   dpu_get_multirect_mode(r_pipe->multirect_mode));\n\t\tdrm_printf(p, \"\\tmultirect_index[1]=%s\\n\",\n\t\t\t   dpu_get_multirect_index(r_pipe->multirect_index));\n\t\tdrm_printf(p, \"\\tsrc[1]=\" DRM_RECT_FMT \"\\n\", DRM_RECT_ARG(&r_pipe_cfg->src_rect));\n\t\tdrm_printf(p, \"\\tdst[1]=\" DRM_RECT_FMT \"\\n\", DRM_RECT_ARG(&r_pipe_cfg->dst_rect));\n\t}\n}\n\nstatic void dpu_plane_reset(struct drm_plane *plane)\n{\n\tstruct dpu_plane *pdpu;\n\tstruct dpu_plane_state *pstate;\n\tstruct dpu_kms *dpu_kms = _dpu_plane_get_kms(plane);\n\n\tif (!plane) {\n\t\tDPU_ERROR(\"invalid plane\\n\");\n\t\treturn;\n\t}\n\n\tpdpu = to_dpu_plane(plane);\n\tDPU_DEBUG_PLANE(pdpu, \"\\n\");\n\n\t \n\tif (plane->state) {\n\t\tdpu_plane_destroy_state(plane, plane->state);\n\t\tplane->state = NULL;\n\t}\n\n\tpstate = kzalloc(sizeof(*pstate), GFP_KERNEL);\n\tif (!pstate) {\n\t\tDPU_ERROR_PLANE(pdpu, \"failed to allocate state\\n\");\n\t\treturn;\n\t}\n\n\t \n\tpstate->pipe.sspp = dpu_rm_get_sspp(&dpu_kms->rm, pdpu->pipe);\n\tpstate->pipe.multirect_index = DPU_SSPP_RECT_SOLO;\n\tpstate->pipe.multirect_mode = DPU_SSPP_MULTIRECT_NONE;\n\n\tpstate->r_pipe.sspp = NULL;\n\n\t__drm_atomic_helper_plane_reset(plane, &pstate->base);\n}\n\n#ifdef CONFIG_DEBUG_FS\nvoid dpu_plane_danger_signal_ctrl(struct drm_plane *plane, bool enable)\n{\n\tstruct dpu_plane *pdpu = to_dpu_plane(plane);\n\tstruct dpu_plane_state *pstate = to_dpu_plane_state(plane->state);\n\tstruct dpu_kms *dpu_kms = _dpu_plane_get_kms(plane);\n\n\tif (!pdpu->is_rt_pipe)\n\t\treturn;\n\n\tpm_runtime_get_sync(&dpu_kms->pdev->dev);\n\t_dpu_plane_set_qos_ctrl(plane, &pstate->pipe, enable);\n\tif (pstate->r_pipe.sspp)\n\t\t_dpu_plane_set_qos_ctrl(plane, &pstate->r_pipe, enable);\n\tpm_runtime_put_sync(&dpu_kms->pdev->dev);\n}\n#endif\n\nstatic bool dpu_plane_format_mod_supported(struct drm_plane *plane,\n\t\tuint32_t format, uint64_t modifier)\n{\n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\treturn true;\n\n\tif (modifier == DRM_FORMAT_MOD_QCOM_COMPRESSED)\n\t\treturn dpu_find_format(format, qcom_compressed_supported_formats,\n\t\t\t\tARRAY_SIZE(qcom_compressed_supported_formats));\n\n\treturn false;\n}\n\nstatic const struct drm_plane_funcs dpu_plane_funcs = {\n\t\t.update_plane = drm_atomic_helper_update_plane,\n\t\t.disable_plane = drm_atomic_helper_disable_plane,\n\t\t.destroy = dpu_plane_destroy,\n\t\t.reset = dpu_plane_reset,\n\t\t.atomic_duplicate_state = dpu_plane_duplicate_state,\n\t\t.atomic_destroy_state = dpu_plane_destroy_state,\n\t\t.atomic_print_state = dpu_plane_atomic_print_state,\n\t\t.format_mod_supported = dpu_plane_format_mod_supported,\n};\n\nstatic const struct drm_plane_helper_funcs dpu_plane_helper_funcs = {\n\t\t.prepare_fb = dpu_plane_prepare_fb,\n\t\t.cleanup_fb = dpu_plane_cleanup_fb,\n\t\t.atomic_check = dpu_plane_atomic_check,\n\t\t.atomic_update = dpu_plane_atomic_update,\n};\n\n \nstruct drm_plane *dpu_plane_init(struct drm_device *dev,\n\t\tuint32_t pipe, enum drm_plane_type type,\n\t\tunsigned long possible_crtcs)\n{\n\tstruct drm_plane *plane = NULL;\n\tconst uint32_t *format_list;\n\tstruct dpu_plane *pdpu;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct dpu_kms *kms = to_dpu_kms(priv->kms);\n\tstruct dpu_hw_sspp *pipe_hw;\n\tuint32_t num_formats;\n\tuint32_t supported_rotations;\n\tint ret = -EINVAL;\n\n\t \n\tpdpu = kzalloc(sizeof(*pdpu), GFP_KERNEL);\n\tif (!pdpu) {\n\t\tDPU_ERROR(\"[%u]failed to allocate local plane struct\\n\", pipe);\n\t\tret = -ENOMEM;\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tplane = &pdpu->base;\n\tpdpu->pipe = pipe;\n\n\t \n\tpipe_hw = dpu_rm_get_sspp(&kms->rm, pipe);\n\tif (!pipe_hw || !pipe_hw->cap || !pipe_hw->cap->sblk) {\n\t\tDPU_ERROR(\"[%u]SSPP is invalid\\n\", pipe);\n\t\tgoto clean_plane;\n\t}\n\n\tformat_list = pipe_hw->cap->sblk->format_list;\n\tnum_formats = pipe_hw->cap->sblk->num_formats;\n\n\tret = drm_universal_plane_init(dev, plane, 0xff, &dpu_plane_funcs,\n\t\t\t\tformat_list, num_formats,\n\t\t\t\tsupported_format_modifiers, type, NULL);\n\tif (ret)\n\t\tgoto clean_plane;\n\n\tpdpu->catalog = kms->catalog;\n\n\tret = drm_plane_create_zpos_property(plane, 0, 0, DPU_ZPOS_MAX);\n\tif (ret)\n\t\tDPU_ERROR(\"failed to install zpos property, rc = %d\\n\", ret);\n\n\tdrm_plane_create_alpha_property(plane);\n\tdrm_plane_create_blend_mode_property(plane,\n\t\t\tBIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\tBIT(DRM_MODE_BLEND_PREMULTI) |\n\t\t\tBIT(DRM_MODE_BLEND_COVERAGE));\n\n\tsupported_rotations = DRM_MODE_REFLECT_MASK | DRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180;\n\n\tif (pipe_hw->cap->features & BIT(DPU_SSPP_INLINE_ROTATION))\n\t\tsupported_rotations |= DRM_MODE_ROTATE_MASK;\n\n\tdrm_plane_create_rotation_property(plane,\n\t\t    DRM_MODE_ROTATE_0, supported_rotations);\n\n\tdrm_plane_enable_fb_damage_clips(plane);\n\n\t \n\tdrm_plane_helper_add(plane, &dpu_plane_helper_funcs);\n\n\tmutex_init(&pdpu->lock);\n\n\tDPU_DEBUG(\"%s created for pipe:%u id:%u\\n\", plane->name,\n\t\t\t\t\tpipe, plane->base.id);\n\treturn plane;\n\nclean_plane:\n\tkfree(pdpu);\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}