{
  "module_name": "dpu_kms.h",
  "hash_id": "1d06a4dc9b1c445f9391aa4d3aebd9c91030e73b09228b18367c64927cbaac11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.h",
  "human_readable_source": " \n \n\n#ifndef __DPU_KMS_H__\n#define __DPU_KMS_H__\n\n#include <linux/interconnect.h>\n\n#include <drm/drm_drv.h>\n\n#include \"msm_drv.h\"\n#include \"msm_kms.h\"\n#include \"msm_mmu.h\"\n#include \"msm_gem.h\"\n#include \"dpu_hw_catalog.h\"\n#include \"dpu_hw_ctl.h\"\n#include \"dpu_hw_lm.h\"\n#include \"dpu_hw_interrupts.h\"\n#include \"dpu_hw_top.h\"\n#include \"dpu_rm.h\"\n#include \"dpu_core_perf.h\"\n\n#define DRMID(x) ((x) ? (x)->base.id : -1)\n\n \n#define DPU_DEBUG(fmt, ...)                                                \\\n\tdo {                                                               \\\n\t\tif (drm_debug_enabled(DRM_UT_KMS))                         \\\n\t\t\tDRM_DEBUG(fmt, ##__VA_ARGS__); \\\n\t\telse                                                       \\\n\t\t\tpr_debug(fmt, ##__VA_ARGS__);                      \\\n\t} while (0)\n\n \n#define DPU_DEBUG_DRIVER(fmt, ...)                                         \\\n\tdo {                                                               \\\n\t\tif (drm_debug_enabled(DRM_UT_DRIVER))                      \\\n\t\t\tDRM_ERROR(fmt, ##__VA_ARGS__); \\\n\t\telse                                                       \\\n\t\t\tpr_debug(fmt, ##__VA_ARGS__);                      \\\n\t} while (0)\n\n#define DPU_ERROR(fmt, ...) pr_err(\"[dpu error]\" fmt, ##__VA_ARGS__)\n\n \n#define ktime_compare_safe(A, B) \\\n\tktime_compare(ktime_sub((A), (B)), ktime_set(0, 0))\n\nstruct dpu_kms {\n\tstruct msm_kms base;\n\tstruct drm_device *dev;\n\tconst struct dpu_mdss_cfg *catalog;\n\tconst struct msm_mdss_data *mdss;\n\n\t \n\tvoid __iomem *mmio, *vbif[VBIF_MAX];\n\n\tstruct regulator *vdd;\n\tstruct regulator *mmagic;\n\tstruct regulator *venus;\n\n\tstruct dpu_hw_intr *hw_intr;\n\n\tstruct dpu_core_perf perf;\n\n\t \n\tstruct drm_modeset_lock global_state_lock;\n\tstruct drm_private_obj global_state;\n\n\tstruct dpu_rm rm;\n\tbool rm_init;\n\n\tstruct dpu_hw_vbif *hw_vbif[VBIF_MAX];\n\tstruct dpu_hw_mdp *hw_mdp;\n\n\tbool has_danger_ctrl;\n\n\tstruct platform_device *pdev;\n\tbool rpm_enabled;\n\n\tstruct clk_bulk_data *clocks;\n\tsize_t num_clocks;\n\n\t \n\tatomic_t bandwidth_ref;\n\tstruct icc_path *path[2];\n\tu32 num_paths;\n};\n\nstruct vsync_info {\n\tu32 frame_count;\n\tu32 line_count;\n};\n\n#define DPU_ENC_WR_PTR_START_TIMEOUT_US 20000\n\n#define DPU_ENC_MAX_POLL_TIMEOUT_US\t2000\n\n#define to_dpu_kms(x) container_of(x, struct dpu_kms, base)\n\n#define to_dpu_global_state(x) container_of(x, struct dpu_global_state, base)\n\n \nstruct dpu_global_state {\n\tstruct drm_private_state base;\n\n\tuint32_t pingpong_to_enc_id[PINGPONG_MAX - PINGPONG_0];\n\tuint32_t mixer_to_enc_id[LM_MAX - LM_0];\n\tuint32_t ctl_to_enc_id[CTL_MAX - CTL_0];\n\tuint32_t dspp_to_enc_id[DSPP_MAX - DSPP_0];\n\tuint32_t dsc_to_enc_id[DSC_MAX - DSC_0];\n};\n\nstruct dpu_global_state\n\t*dpu_kms_get_existing_global_state(struct dpu_kms *dpu_kms);\nstruct dpu_global_state\n\t*__must_check dpu_kms_get_global_state(struct drm_atomic_state *s);\n\n \n\n \nvoid dpu_debugfs_create_regset32(const char *name, umode_t mode,\n\t\tvoid *parent,\n\t\tuint32_t offset, uint32_t length, struct dpu_kms *dpu_kms);\n\n \nvoid *dpu_debugfs_get_root(struct dpu_kms *dpu_kms);\n\n \n#define DPU_KMS_INFO_MAX_SIZE\t4096\n\n \nint dpu_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);\nvoid dpu_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);\n\n \nunsigned long dpu_kms_get_clk_rate(struct dpu_kms *dpu_kms, char *clock_name);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}