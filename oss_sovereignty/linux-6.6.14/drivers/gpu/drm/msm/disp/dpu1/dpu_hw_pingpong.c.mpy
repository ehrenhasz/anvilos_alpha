{
  "module_name": "dpu_hw_pingpong.c",
  "hash_id": "3f0c7fbce7b0dbc93337c04b18a5af4a082a71012d2d850696cd506f63fd5861",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_hw_pingpong.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n\n#include \"dpu_hw_mdss.h\"\n#include \"dpu_hwio.h\"\n#include \"dpu_hw_catalog.h\"\n#include \"dpu_hw_pingpong.h\"\n#include \"dpu_kms.h\"\n#include \"dpu_trace.h\"\n\n#define PP_TEAR_CHECK_EN                0x000\n#define PP_SYNC_CONFIG_VSYNC            0x004\n#define PP_SYNC_CONFIG_HEIGHT           0x008\n#define PP_SYNC_WRCOUNT                 0x00C\n#define PP_VSYNC_INIT_VAL               0x010\n#define PP_INT_COUNT_VAL                0x014\n#define PP_SYNC_THRESH                  0x018\n#define PP_START_POS                    0x01C\n#define PP_RD_PTR_IRQ                   0x020\n#define PP_WR_PTR_IRQ                   0x024\n#define PP_OUT_LINE_COUNT               0x028\n#define PP_LINE_COUNT                   0x02C\n#define PP_AUTOREFRESH_CONFIG           0x030\n\n#define PP_FBC_MODE                     0x034\n#define PP_FBC_BUDGET_CTL               0x038\n#define PP_FBC_LOSSY_MODE               0x03C\n#define PP_DSC_MODE                     0x0a0\n#define PP_DCE_DATA_IN_SWAP             0x0ac\n#define PP_DCE_DATA_OUT_SWAP            0x0c8\n\n#define PP_DITHER_EN\t\t\t0x000\n#define PP_DITHER_BITDEPTH\t\t0x004\n#define PP_DITHER_MATRIX\t\t0x008\n\n#define DITHER_DEPTH_MAP_INDEX 9\n\nstatic u32 dither_depth_map[DITHER_DEPTH_MAP_INDEX] = {\n\t0, 0, 0, 0, 0, 0, 0, 1, 2\n};\n\nstatic void dpu_hw_pp_setup_dither(struct dpu_hw_pingpong *pp,\n\t\t\t\t    struct dpu_hw_dither_cfg *cfg)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 i, base, data = 0;\n\n\tc = &pp->hw;\n\tbase = pp->caps->sblk->dither.base;\n\tif (!cfg) {\n\t\tDPU_REG_WRITE(c, base + PP_DITHER_EN, 0);\n\t\treturn;\n\t}\n\n\tdata = dither_depth_map[cfg->c0_bitdepth] & REG_MASK(2);\n\tdata |= (dither_depth_map[cfg->c1_bitdepth] & REG_MASK(2)) << 2;\n\tdata |= (dither_depth_map[cfg->c2_bitdepth] & REG_MASK(2)) << 4;\n\tdata |= (dither_depth_map[cfg->c3_bitdepth] & REG_MASK(2)) << 6;\n\tdata |= (cfg->temporal_en) ? (1 << 8) : 0;\n\n\tDPU_REG_WRITE(c, base + PP_DITHER_BITDEPTH, data);\n\n\tfor (i = 0; i < DITHER_MATRIX_SZ - 3; i += 4) {\n\t\tdata = (cfg->matrix[i] & REG_MASK(4)) |\n\t\t\t((cfg->matrix[i + 1] & REG_MASK(4)) << 4) |\n\t\t\t((cfg->matrix[i + 2] & REG_MASK(4)) << 8) |\n\t\t\t((cfg->matrix[i + 3] & REG_MASK(4)) << 12);\n\t\tDPU_REG_WRITE(c, base + PP_DITHER_MATRIX + i, data);\n\t}\n\tDPU_REG_WRITE(c, base + PP_DITHER_EN, 1);\n}\n\nstatic int dpu_hw_pp_enable_te(struct dpu_hw_pingpong *pp,\n\t\tstruct dpu_hw_tear_check *te)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tint cfg;\n\n\tif (!pp || !te)\n\t\treturn -EINVAL;\n\tc = &pp->hw;\n\n\tcfg = BIT(19);  \n\tif (te->hw_vsync_mode)\n\t\tcfg |= BIT(20);\n\n\tcfg |= te->vsync_count;\n\n\tDPU_REG_WRITE(c, PP_SYNC_CONFIG_VSYNC, cfg);\n\tDPU_REG_WRITE(c, PP_SYNC_CONFIG_HEIGHT, te->sync_cfg_height);\n\tDPU_REG_WRITE(c, PP_VSYNC_INIT_VAL, te->vsync_init_val);\n\tDPU_REG_WRITE(c, PP_RD_PTR_IRQ, te->rd_ptr_irq);\n\tDPU_REG_WRITE(c, PP_START_POS, te->start_pos);\n\tDPU_REG_WRITE(c, PP_SYNC_THRESH,\n\t\t\t((te->sync_threshold_continue << 16) |\n\t\t\t te->sync_threshold_start));\n\tDPU_REG_WRITE(c, PP_SYNC_WRCOUNT,\n\t\t\t(te->start_pos + te->sync_threshold_start + 1));\n\n\tDPU_REG_WRITE(c, PP_TEAR_CHECK_EN, 1);\n\n\treturn 0;\n}\n\nstatic void dpu_hw_pp_setup_autorefresh_config(struct dpu_hw_pingpong *pp,\n\t\t\t\t\t       u32 frame_count, bool enable)\n{\n\tDPU_REG_WRITE(&pp->hw, PP_AUTOREFRESH_CONFIG,\n\t\t      enable ? (BIT(31) | frame_count) : 0);\n}\n\n \nstatic bool dpu_hw_pp_get_autorefresh_config(struct dpu_hw_pingpong *pp,\n\t\t\t\t\t     u32 *frame_count)\n{\n\tu32 val = DPU_REG_READ(&pp->hw, PP_AUTOREFRESH_CONFIG);\n\tif (frame_count != NULL)\n\t\t*frame_count = val & 0xffff;\n\treturn !!((val & BIT(31)) >> 31);\n}\n\nstatic int dpu_hw_pp_disable_te(struct dpu_hw_pingpong *pp)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\n\tif (!pp)\n\t\treturn -EINVAL;\n\tc = &pp->hw;\n\n\tDPU_REG_WRITE(c, PP_TEAR_CHECK_EN, 0);\n\treturn 0;\n}\n\nstatic int dpu_hw_pp_connect_external_te(struct dpu_hw_pingpong *pp,\n\t\tbool enable_external_te)\n{\n\tstruct dpu_hw_blk_reg_map *c = &pp->hw;\n\tu32 cfg;\n\tint orig;\n\n\tif (!pp)\n\t\treturn -EINVAL;\n\n\tc = &pp->hw;\n\tcfg = DPU_REG_READ(c, PP_SYNC_CONFIG_VSYNC);\n\torig = (bool)(cfg & BIT(20));\n\tif (enable_external_te)\n\t\tcfg |= BIT(20);\n\telse\n\t\tcfg &= ~BIT(20);\n\tDPU_REG_WRITE(c, PP_SYNC_CONFIG_VSYNC, cfg);\n\ttrace_dpu_pp_connect_ext_te(pp->idx - PINGPONG_0, cfg);\n\n\treturn orig;\n}\n\nstatic int dpu_hw_pp_get_vsync_info(struct dpu_hw_pingpong *pp,\n\t\tstruct dpu_hw_pp_vsync_info *info)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 val;\n\n\tif (!pp || !info)\n\t\treturn -EINVAL;\n\tc = &pp->hw;\n\n\tval = DPU_REG_READ(c, PP_VSYNC_INIT_VAL);\n\tinfo->rd_ptr_init_val = val & 0xffff;\n\n\tval = DPU_REG_READ(c, PP_INT_COUNT_VAL);\n\tinfo->rd_ptr_frame_count = (val & 0xffff0000) >> 16;\n\tinfo->rd_ptr_line_count = val & 0xffff;\n\n\tval = DPU_REG_READ(c, PP_LINE_COUNT);\n\tinfo->wr_ptr_line_count = val & 0xffff;\n\n\treturn 0;\n}\n\nstatic u32 dpu_hw_pp_get_line_count(struct dpu_hw_pingpong *pp)\n{\n\tstruct dpu_hw_blk_reg_map *c = &pp->hw;\n\tu32 height, init;\n\tu32 line = 0xFFFF;\n\n\tif (!pp)\n\t\treturn 0;\n\tc = &pp->hw;\n\n\tinit = DPU_REG_READ(c, PP_VSYNC_INIT_VAL) & 0xFFFF;\n\theight = DPU_REG_READ(c, PP_SYNC_CONFIG_HEIGHT) & 0xFFFF;\n\n\tif (height < init)\n\t\treturn line;\n\n\tline = DPU_REG_READ(c, PP_INT_COUNT_VAL) & 0xFFFF;\n\n\tif (line < init)\n\t\tline += (0xFFFF - init);\n\telse\n\t\tline -= init;\n\n\treturn line;\n}\n\nstatic void dpu_hw_pp_disable_autorefresh(struct dpu_hw_pingpong *pp,\n\t\t\t\t\t  uint32_t encoder_id, u16 vdisplay)\n{\n\tstruct dpu_hw_pp_vsync_info info;\n\tint trial = 0;\n\n\t \n\tif (!dpu_hw_pp_get_autorefresh_config(pp, NULL))\n\t\treturn;\n\n\t \n\n\tdpu_hw_pp_connect_external_te(pp, false);\n\tdpu_hw_pp_setup_autorefresh_config(pp, 0, false);\n\n\tdo {\n\t\tudelay(DPU_ENC_MAX_POLL_TIMEOUT_US);\n\t\tif ((trial * DPU_ENC_MAX_POLL_TIMEOUT_US)\n\t\t\t\t> (KICKOFF_TIMEOUT_MS * USEC_PER_MSEC)) {\n\t\t\tDPU_ERROR(\"enc%d pp%d disable autorefresh failed\\n\",\n\t\t\t\t  encoder_id, pp->idx - PINGPONG_0);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrial++;\n\n\t\tdpu_hw_pp_get_vsync_info(pp, &info);\n\t} while (info.wr_ptr_line_count > 0 &&\n\t\t info.wr_ptr_line_count < vdisplay);\n\n\tdpu_hw_pp_connect_external_te(pp, true);\n\n\tDPU_DEBUG(\"enc%d pp%d disabled autorefresh\\n\",\n\t\t  encoder_id, pp->idx - PINGPONG_0);\n}\n\nstatic int dpu_hw_pp_dsc_enable(struct dpu_hw_pingpong *pp)\n{\n\tstruct dpu_hw_blk_reg_map *c = &pp->hw;\n\n\tDPU_REG_WRITE(c, PP_DSC_MODE, 1);\n\treturn 0;\n}\n\nstatic void dpu_hw_pp_dsc_disable(struct dpu_hw_pingpong *pp)\n{\n\tstruct dpu_hw_blk_reg_map *c = &pp->hw;\n\n\tDPU_REG_WRITE(c, PP_DSC_MODE, 0);\n}\n\nstatic int dpu_hw_pp_setup_dsc(struct dpu_hw_pingpong *pp)\n{\n\tstruct dpu_hw_blk_reg_map *pp_c = &pp->hw;\n\tint data;\n\n\tdata = DPU_REG_READ(pp_c, PP_DCE_DATA_OUT_SWAP);\n\tdata |= BIT(18);  \n\tDPU_REG_WRITE(pp_c, PP_DCE_DATA_OUT_SWAP, data);\n\treturn 0;\n}\n\nstatic void _setup_pingpong_ops(struct dpu_hw_pingpong *c,\n\t\t\t\tunsigned long features)\n{\n\tif (test_bit(DPU_PINGPONG_TE, &features)) {\n\t\tc->ops.enable_tearcheck = dpu_hw_pp_enable_te;\n\t\tc->ops.disable_tearcheck = dpu_hw_pp_disable_te;\n\t\tc->ops.connect_external_te = dpu_hw_pp_connect_external_te;\n\t\tc->ops.get_line_count = dpu_hw_pp_get_line_count;\n\t\tc->ops.disable_autorefresh = dpu_hw_pp_disable_autorefresh;\n\t}\n\n\tif (test_bit(DPU_PINGPONG_DSC, &features)) {\n\t\tc->ops.setup_dsc = dpu_hw_pp_setup_dsc;\n\t\tc->ops.enable_dsc = dpu_hw_pp_dsc_enable;\n\t\tc->ops.disable_dsc = dpu_hw_pp_dsc_disable;\n\t}\n\n\tif (test_bit(DPU_PINGPONG_DITHER, &features))\n\t\tc->ops.setup_dither = dpu_hw_pp_setup_dither;\n};\n\nstruct dpu_hw_pingpong *dpu_hw_pingpong_init(const struct dpu_pingpong_cfg *cfg,\n\t\tvoid __iomem *addr)\n{\n\tstruct dpu_hw_pingpong *c;\n\n\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tc->hw.blk_addr = addr + cfg->base;\n\tc->hw.log_mask = DPU_DBG_MASK_PINGPONG;\n\n\tc->idx = cfg->id;\n\tc->caps = cfg;\n\t_setup_pingpong_ops(c, c->caps->features);\n\n\treturn c;\n}\n\nvoid dpu_hw_pingpong_destroy(struct dpu_hw_pingpong *pp)\n{\n\tkfree(pp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}