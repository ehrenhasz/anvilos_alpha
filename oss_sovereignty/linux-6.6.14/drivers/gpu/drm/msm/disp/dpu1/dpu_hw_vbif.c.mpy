{
  "module_name": "dpu_hw_vbif.c",
  "hash_id": "4d1a5895065b26ee62bcc0413c599c3bc187a4cb387181d2e9e3f6b4c10483a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_hw_vbif.c",
  "human_readable_source": "\n \n\n#include \"dpu_hwio.h\"\n#include \"dpu_hw_catalog.h\"\n#include \"dpu_hw_vbif.h\"\n\n#define VBIF_VERSION\t\t\t0x0000\n#define VBIF_CLK_FORCE_CTRL0\t\t0x0008\n#define VBIF_CLK_FORCE_CTRL1\t\t0x000C\n#define VBIF_QOS_REMAP_00\t\t0x0020\n#define VBIF_QOS_REMAP_01\t\t0x0024\n#define VBIF_QOS_REMAP_10\t\t0x0028\n#define VBIF_QOS_REMAP_11\t\t0x002C\n#define VBIF_WRITE_GATHER_EN\t\t0x00AC\n#define VBIF_IN_RD_LIM_CONF0\t\t0x00B0\n#define VBIF_IN_RD_LIM_CONF1\t\t0x00B4\n#define VBIF_IN_RD_LIM_CONF2\t\t0x00B8\n#define VBIF_IN_WR_LIM_CONF0\t\t0x00C0\n#define VBIF_IN_WR_LIM_CONF1\t\t0x00C4\n#define VBIF_IN_WR_LIM_CONF2\t\t0x00C8\n#define VBIF_OUT_RD_LIM_CONF0\t\t0x00D0\n#define VBIF_OUT_WR_LIM_CONF0\t\t0x00D4\n#define VBIF_OUT_AXI_AMEMTYPE_CONF0\t0x0160\n#define VBIF_OUT_AXI_AMEMTYPE_CONF1\t0x0164\n#define VBIF_XIN_PND_ERR\t\t0x0190\n#define VBIF_XIN_SRC_ERR\t\t0x0194\n#define VBIF_XIN_CLR_ERR\t\t0x019C\n#define VBIF_XIN_HALT_CTRL0\t\t0x0200\n#define VBIF_XIN_HALT_CTRL1\t\t0x0204\n#define VBIF_XINL_QOS_RP_REMAP_000\t0x0550\n#define VBIF_XINL_QOS_LVL_REMAP_000(vbif)\t(VBIF_XINL_QOS_RP_REMAP_000 + (vbif)->cap->qos_rp_remap_size)\n\nstatic void dpu_hw_clear_errors(struct dpu_hw_vbif *vbif,\n\t\tu32 *pnd_errors, u32 *src_errors)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 pnd, src;\n\n\tif (!vbif)\n\t\treturn;\n\tc = &vbif->hw;\n\tpnd = DPU_REG_READ(c, VBIF_XIN_PND_ERR);\n\tsrc = DPU_REG_READ(c, VBIF_XIN_SRC_ERR);\n\n\tif (pnd_errors)\n\t\t*pnd_errors = pnd;\n\tif (src_errors)\n\t\t*src_errors = src;\n\n\tDPU_REG_WRITE(c, VBIF_XIN_CLR_ERR, pnd | src);\n}\n\nstatic void dpu_hw_set_mem_type(struct dpu_hw_vbif *vbif,\n\t\tu32 xin_id, u32 value)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 reg_off;\n\tu32 bit_off;\n\tu32 reg_val;\n\n\t \n\tif (!vbif || xin_id >= MAX_XIN_COUNT || xin_id >= 16)\n\t\treturn;\n\n\tc = &vbif->hw;\n\n\tif (xin_id >= 8) {\n\t\txin_id -= 8;\n\t\treg_off = VBIF_OUT_AXI_AMEMTYPE_CONF1;\n\t} else {\n\t\treg_off = VBIF_OUT_AXI_AMEMTYPE_CONF0;\n\t}\n\tbit_off = (xin_id & 0x7) * 4;\n\treg_val = DPU_REG_READ(c, reg_off);\n\treg_val &= ~(0x7 << bit_off);\n\treg_val |= (value & 0x7) << bit_off;\n\tDPU_REG_WRITE(c, reg_off, reg_val);\n}\n\nstatic void dpu_hw_set_limit_conf(struct dpu_hw_vbif *vbif,\n\t\tu32 xin_id, bool rd, u32 limit)\n{\n\tstruct dpu_hw_blk_reg_map *c = &vbif->hw;\n\tu32 reg_val;\n\tu32 reg_off;\n\tu32 bit_off;\n\n\tif (rd)\n\t\treg_off = VBIF_IN_RD_LIM_CONF0;\n\telse\n\t\treg_off = VBIF_IN_WR_LIM_CONF0;\n\n\treg_off += (xin_id / 4) * 4;\n\tbit_off = (xin_id % 4) * 8;\n\treg_val = DPU_REG_READ(c, reg_off);\n\treg_val &= ~(0xFF << bit_off);\n\treg_val |= (limit) << bit_off;\n\tDPU_REG_WRITE(c, reg_off, reg_val);\n}\n\nstatic u32 dpu_hw_get_limit_conf(struct dpu_hw_vbif *vbif,\n\t\tu32 xin_id, bool rd)\n{\n\tstruct dpu_hw_blk_reg_map *c = &vbif->hw;\n\tu32 reg_val;\n\tu32 reg_off;\n\tu32 bit_off;\n\tu32 limit;\n\n\tif (rd)\n\t\treg_off = VBIF_IN_RD_LIM_CONF0;\n\telse\n\t\treg_off = VBIF_IN_WR_LIM_CONF0;\n\n\treg_off += (xin_id / 4) * 4;\n\tbit_off = (xin_id % 4) * 8;\n\treg_val = DPU_REG_READ(c, reg_off);\n\tlimit = (reg_val >> bit_off) & 0xFF;\n\n\treturn limit;\n}\n\nstatic void dpu_hw_set_halt_ctrl(struct dpu_hw_vbif *vbif,\n\t\tu32 xin_id, bool enable)\n{\n\tstruct dpu_hw_blk_reg_map *c = &vbif->hw;\n\tu32 reg_val;\n\n\treg_val = DPU_REG_READ(c, VBIF_XIN_HALT_CTRL0);\n\n\tif (enable)\n\t\treg_val |= BIT(xin_id);\n\telse\n\t\treg_val &= ~BIT(xin_id);\n\n\tDPU_REG_WRITE(c, VBIF_XIN_HALT_CTRL0, reg_val);\n}\n\nstatic bool dpu_hw_get_halt_ctrl(struct dpu_hw_vbif *vbif,\n\t\tu32 xin_id)\n{\n\tstruct dpu_hw_blk_reg_map *c = &vbif->hw;\n\tu32 reg_val;\n\n\treg_val = DPU_REG_READ(c, VBIF_XIN_HALT_CTRL1);\n\n\treturn (reg_val & BIT(xin_id)) ? true : false;\n}\n\nstatic void dpu_hw_set_qos_remap(struct dpu_hw_vbif *vbif,\n\t\tu32 xin_id, u32 level, u32 remap_level)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 reg_lvl, reg_val, reg_val_lvl, mask, reg_high, reg_shift;\n\n\tif (!vbif)\n\t\treturn;\n\n\tc = &vbif->hw;\n\n\treg_lvl = VBIF_XINL_QOS_LVL_REMAP_000(vbif);\n\treg_high = ((xin_id & 0x8) >> 3) * 4 + (level * 8);\n\treg_shift = (xin_id & 0x7) * 4;\n\n\treg_val = DPU_REG_READ(c, VBIF_XINL_QOS_RP_REMAP_000 + reg_high);\n\treg_val_lvl = DPU_REG_READ(c, reg_lvl + reg_high);\n\n\tmask = 0x7 << reg_shift;\n\n\treg_val &= ~mask;\n\treg_val |= (remap_level << reg_shift) & mask;\n\n\treg_val_lvl &= ~mask;\n\treg_val_lvl |= (remap_level << reg_shift) & mask;\n\n\tDPU_REG_WRITE(c, VBIF_XINL_QOS_RP_REMAP_000 + reg_high, reg_val);\n\tDPU_REG_WRITE(c, reg_lvl + reg_high, reg_val_lvl);\n}\n\nstatic void dpu_hw_set_write_gather_en(struct dpu_hw_vbif *vbif, u32 xin_id)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 reg_val;\n\n\tif (!vbif || xin_id >= MAX_XIN_COUNT)\n\t\treturn;\n\n\tc = &vbif->hw;\n\n\treg_val = DPU_REG_READ(c, VBIF_WRITE_GATHER_EN);\n\treg_val |= BIT(xin_id);\n\tDPU_REG_WRITE(c, VBIF_WRITE_GATHER_EN, reg_val);\n}\n\nstatic void _setup_vbif_ops(struct dpu_hw_vbif_ops *ops,\n\t\tunsigned long cap)\n{\n\tops->set_limit_conf = dpu_hw_set_limit_conf;\n\tops->get_limit_conf = dpu_hw_get_limit_conf;\n\tops->set_halt_ctrl = dpu_hw_set_halt_ctrl;\n\tops->get_halt_ctrl = dpu_hw_get_halt_ctrl;\n\tif (test_bit(DPU_VBIF_QOS_REMAP, &cap))\n\t\tops->set_qos_remap = dpu_hw_set_qos_remap;\n\tops->set_mem_type = dpu_hw_set_mem_type;\n\tops->clear_errors = dpu_hw_clear_errors;\n\tops->set_write_gather_en = dpu_hw_set_write_gather_en;\n}\n\nstruct dpu_hw_vbif *dpu_hw_vbif_init(const struct dpu_vbif_cfg *cfg,\n\t\tvoid __iomem *addr)\n{\n\tstruct dpu_hw_vbif *c;\n\n\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tc->hw.blk_addr = addr + cfg->base;\n\tc->hw.log_mask = DPU_DBG_MASK_VBIF;\n\n\t \n\tc->idx = cfg->id;\n\tc->cap = cfg;\n\t_setup_vbif_ops(&c->ops, c->cap->features);\n\n\t \n\n\treturn c;\n}\n\nvoid dpu_hw_vbif_destroy(struct dpu_hw_vbif *vbif)\n{\n\tkfree(vbif);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}