{
  "module_name": "dpu_hw_util.c",
  "hash_id": "1091ba07bfaec87de5b14f3f4d8f82b4edbd5c22b81ad8c144aebeb5526e6fff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_hw_util.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt)\t\"[drm:%s:%d] \" fmt, __func__, __LINE__\n\n#include \"msm_drv.h\"\n#include \"dpu_kms.h\"\n#include \"dpu_hw_mdss.h\"\n#include \"dpu_hw_util.h\"\n\n \nstatic u32 dpu_hw_util_log_mask = DPU_DBG_MASK_NONE;\n\n \n#define QSEED3_HW_VERSION                  0x00\n#define QSEED3_OP_MODE                     0x04\n#define QSEED3_RGB2Y_COEFF                 0x08\n#define QSEED3_PHASE_INIT                  0x0C\n#define QSEED3_PHASE_STEP_Y_H              0x10\n#define QSEED3_PHASE_STEP_Y_V              0x14\n#define QSEED3_PHASE_STEP_UV_H             0x18\n#define QSEED3_PHASE_STEP_UV_V             0x1C\n#define QSEED3_PRELOAD                     0x20\n#define QSEED3_DE_SHARPEN                  0x24\n#define QSEED3_DE_SHARPEN_CTL              0x28\n#define QSEED3_DE_SHAPE_CTL                0x2C\n#define QSEED3_DE_THRESHOLD                0x30\n#define QSEED3_DE_ADJUST_DATA_0            0x34\n#define QSEED3_DE_ADJUST_DATA_1            0x38\n#define QSEED3_DE_ADJUST_DATA_2            0x3C\n#define QSEED3_SRC_SIZE_Y_RGB_A            0x40\n#define QSEED3_SRC_SIZE_UV                 0x44\n#define QSEED3_DST_SIZE                    0x48\n#define QSEED3_COEF_LUT_CTRL               0x4C\n#define QSEED3_COEF_LUT_SWAP_BIT           0\n#define QSEED3_COEF_LUT_DIR_BIT            1\n#define QSEED3_COEF_LUT_Y_CIR_BIT          2\n#define QSEED3_COEF_LUT_UV_CIR_BIT         3\n#define QSEED3_COEF_LUT_Y_SEP_BIT          4\n#define QSEED3_COEF_LUT_UV_SEP_BIT         5\n#define QSEED3_BUFFER_CTRL                 0x50\n#define QSEED3_CLK_CTRL0                   0x54\n#define QSEED3_CLK_CTRL1                   0x58\n#define QSEED3_CLK_STATUS                  0x5C\n#define QSEED3_PHASE_INIT_Y_H              0x90\n#define QSEED3_PHASE_INIT_Y_V              0x94\n#define QSEED3_PHASE_INIT_UV_H             0x98\n#define QSEED3_PHASE_INIT_UV_V             0x9C\n#define QSEED3_COEF_LUT                    0x100\n#define QSEED3_FILTERS                     5\n#define QSEED3_LUT_REGIONS                 4\n#define QSEED3_CIRCULAR_LUTS               9\n#define QSEED3_SEPARABLE_LUTS              10\n#define QSEED3_LUT_SIZE                    60\n#define QSEED3_ENABLE                      2\n#define QSEED3_DIR_LUT_SIZE                (200 * sizeof(u32))\n#define QSEED3_CIR_LUT_SIZE \\\n\t(QSEED3_LUT_SIZE * QSEED3_CIRCULAR_LUTS * sizeof(u32))\n#define QSEED3_SEP_LUT_SIZE \\\n\t(QSEED3_LUT_SIZE * QSEED3_SEPARABLE_LUTS * sizeof(u32))\n\n \n#define QSEED3LITE_COEF_LUT_Y_SEP_BIT         4\n#define QSEED3LITE_COEF_LUT_UV_SEP_BIT        5\n#define QSEED3LITE_COEF_LUT_CTRL              0x4C\n#define QSEED3LITE_COEF_LUT_SWAP_BIT          0\n#define QSEED3LITE_DIR_FILTER_WEIGHT          0x60\n#define QSEED3LITE_FILTERS                 2\n#define QSEED3LITE_SEPARABLE_LUTS             10\n#define QSEED3LITE_LUT_SIZE                   33\n#define QSEED3LITE_SEP_LUT_SIZE \\\n\t        (QSEED3LITE_LUT_SIZE * QSEED3LITE_SEPARABLE_LUTS * sizeof(u32))\n\n \n#define QOS_DANGER_LUT                    0x00\n#define QOS_SAFE_LUT                      0x04\n#define QOS_CREQ_LUT                      0x08\n#define QOS_QOS_CTRL                      0x0C\n#define QOS_CREQ_LUT_0                    0x14\n#define QOS_CREQ_LUT_1                    0x18\n\n \n#define QOS_QOS_CTRL_DANGER_SAFE_EN       BIT(0)\n#define QOS_QOS_CTRL_DANGER_VBLANK_MASK   GENMASK(5, 4)\n#define QOS_QOS_CTRL_VBLANK_EN            BIT(16)\n#define QOS_QOS_CTRL_CREQ_VBLANK_MASK     GENMASK(21, 20)\n\nvoid dpu_reg_write(struct dpu_hw_blk_reg_map *c,\n\t\tu32 reg_off,\n\t\tu32 val,\n\t\tconst char *name)\n{\n\t \n\tif (c->log_mask & dpu_hw_util_log_mask)\n\t\tDPU_DEBUG_DRIVER(\"[%s:0x%X] <= 0x%X\\n\",\n\t\t\t\tname, reg_off, val);\n\twritel_relaxed(val, c->blk_addr + reg_off);\n}\n\nint dpu_reg_read(struct dpu_hw_blk_reg_map *c, u32 reg_off)\n{\n\treturn readl_relaxed(c->blk_addr + reg_off);\n}\n\nu32 *dpu_hw_util_get_log_mask_ptr(void)\n{\n\treturn &dpu_hw_util_log_mask;\n}\n\nstatic void _dpu_hw_setup_scaler3_lut(struct dpu_hw_blk_reg_map *c,\n\t\tstruct dpu_hw_scaler3_cfg *scaler3_cfg, u32 offset)\n{\n\tint i, j, filter;\n\tint config_lut = 0x0;\n\tunsigned long lut_flags;\n\tu32 lut_addr, lut_offset, lut_len;\n\tu32 *lut[QSEED3_FILTERS] = {NULL, NULL, NULL, NULL, NULL};\n\tstatic const uint32_t off_tbl[QSEED3_FILTERS][QSEED3_LUT_REGIONS][2] = {\n\t\t{{18, 0x000}, {12, 0x120}, {12, 0x1E0}, {8, 0x2A0} },\n\t\t{{6, 0x320}, {3, 0x3E0}, {3, 0x440}, {3, 0x4A0} },\n\t\t{{6, 0x500}, {3, 0x5c0}, {3, 0x620}, {3, 0x680} },\n\t\t{{6, 0x380}, {3, 0x410}, {3, 0x470}, {3, 0x4d0} },\n\t\t{{6, 0x560}, {3, 0x5f0}, {3, 0x650}, {3, 0x6b0} },\n\t};\n\n\tlut_flags = (unsigned long) scaler3_cfg->lut_flag;\n\tif (test_bit(QSEED3_COEF_LUT_DIR_BIT, &lut_flags) &&\n\t\t(scaler3_cfg->dir_len == QSEED3_DIR_LUT_SIZE)) {\n\t\tlut[0] = scaler3_cfg->dir_lut;\n\t\tconfig_lut = 1;\n\t}\n\tif (test_bit(QSEED3_COEF_LUT_Y_CIR_BIT, &lut_flags) &&\n\t\t(scaler3_cfg->y_rgb_cir_lut_idx < QSEED3_CIRCULAR_LUTS) &&\n\t\t(scaler3_cfg->cir_len == QSEED3_CIR_LUT_SIZE)) {\n\t\tlut[1] = scaler3_cfg->cir_lut +\n\t\t\tscaler3_cfg->y_rgb_cir_lut_idx * QSEED3_LUT_SIZE;\n\t\tconfig_lut = 1;\n\t}\n\tif (test_bit(QSEED3_COEF_LUT_UV_CIR_BIT, &lut_flags) &&\n\t\t(scaler3_cfg->uv_cir_lut_idx < QSEED3_CIRCULAR_LUTS) &&\n\t\t(scaler3_cfg->cir_len == QSEED3_CIR_LUT_SIZE)) {\n\t\tlut[2] = scaler3_cfg->cir_lut +\n\t\t\tscaler3_cfg->uv_cir_lut_idx * QSEED3_LUT_SIZE;\n\t\tconfig_lut = 1;\n\t}\n\tif (test_bit(QSEED3_COEF_LUT_Y_SEP_BIT, &lut_flags) &&\n\t\t(scaler3_cfg->y_rgb_sep_lut_idx < QSEED3_SEPARABLE_LUTS) &&\n\t\t(scaler3_cfg->sep_len == QSEED3_SEP_LUT_SIZE)) {\n\t\tlut[3] = scaler3_cfg->sep_lut +\n\t\t\tscaler3_cfg->y_rgb_sep_lut_idx * QSEED3_LUT_SIZE;\n\t\tconfig_lut = 1;\n\t}\n\tif (test_bit(QSEED3_COEF_LUT_UV_SEP_BIT, &lut_flags) &&\n\t\t(scaler3_cfg->uv_sep_lut_idx < QSEED3_SEPARABLE_LUTS) &&\n\t\t(scaler3_cfg->sep_len == QSEED3_SEP_LUT_SIZE)) {\n\t\tlut[4] = scaler3_cfg->sep_lut +\n\t\t\tscaler3_cfg->uv_sep_lut_idx * QSEED3_LUT_SIZE;\n\t\tconfig_lut = 1;\n\t}\n\n\tif (config_lut) {\n\t\tfor (filter = 0; filter < QSEED3_FILTERS; filter++) {\n\t\t\tif (!lut[filter])\n\t\t\t\tcontinue;\n\t\t\tlut_offset = 0;\n\t\t\tfor (i = 0; i < QSEED3_LUT_REGIONS; i++) {\n\t\t\t\tlut_addr = QSEED3_COEF_LUT + offset\n\t\t\t\t\t+ off_tbl[filter][i][1];\n\t\t\t\tlut_len = off_tbl[filter][i][0] << 2;\n\t\t\t\tfor (j = 0; j < lut_len; j++) {\n\t\t\t\t\tDPU_REG_WRITE(c,\n\t\t\t\t\t\tlut_addr,\n\t\t\t\t\t\t(lut[filter])[lut_offset++]);\n\t\t\t\t\tlut_addr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (test_bit(QSEED3_COEF_LUT_SWAP_BIT, &lut_flags))\n\t\tDPU_REG_WRITE(c, QSEED3_COEF_LUT_CTRL + offset, BIT(0));\n\n}\n\nstatic void _dpu_hw_setup_scaler3lite_lut(struct dpu_hw_blk_reg_map *c,\n\t\tstruct dpu_hw_scaler3_cfg *scaler3_cfg, u32 offset)\n{\n\tint j, filter;\n\tint config_lut = 0x0;\n\tunsigned long lut_flags;\n\tu32 lut_addr, lut_offset;\n\tu32 *lut[QSEED3LITE_FILTERS] = {NULL, NULL};\n\tstatic const uint32_t off_tbl[QSEED3_FILTERS] = { 0x000, 0x200 };\n\n\tDPU_REG_WRITE(c, QSEED3LITE_DIR_FILTER_WEIGHT + offset, scaler3_cfg->dir_weight);\n\n\tif (!scaler3_cfg->sep_lut)\n\t\treturn;\n\n\tlut_flags = (unsigned long) scaler3_cfg->lut_flag;\n\tif (test_bit(QSEED3_COEF_LUT_Y_SEP_BIT, &lut_flags) &&\n\t\t(scaler3_cfg->y_rgb_sep_lut_idx < QSEED3LITE_SEPARABLE_LUTS) &&\n\t\t(scaler3_cfg->sep_len == QSEED3LITE_SEP_LUT_SIZE)) {\n\t\tlut[0] = scaler3_cfg->sep_lut +\n\t\t\tscaler3_cfg->y_rgb_sep_lut_idx * QSEED3LITE_LUT_SIZE;\n\t\tconfig_lut = 1;\n\t}\n\tif (test_bit(QSEED3_COEF_LUT_UV_SEP_BIT, &lut_flags) &&\n\t\t(scaler3_cfg->uv_sep_lut_idx < QSEED3LITE_SEPARABLE_LUTS) &&\n\t\t(scaler3_cfg->sep_len == QSEED3LITE_SEP_LUT_SIZE)) {\n\t\tlut[1] = scaler3_cfg->sep_lut +\n\t\t\tscaler3_cfg->uv_sep_lut_idx * QSEED3LITE_LUT_SIZE;\n\t\tconfig_lut = 1;\n\t}\n\n\tif (config_lut) {\n\t\tfor (filter = 0; filter < QSEED3LITE_FILTERS; filter++) {\n\t\t\tif (!lut[filter])\n\t\t\t\tcontinue;\n\t\t\tlut_offset = 0;\n\t\t\tlut_addr = QSEED3_COEF_LUT + offset + off_tbl[filter];\n\t\t\tfor (j = 0; j < QSEED3LITE_LUT_SIZE; j++) {\n\t\t\t\tDPU_REG_WRITE(c,\n\t\t\t\t\tlut_addr,\n\t\t\t\t\t(lut[filter])[lut_offset++]);\n\t\t\t\tlut_addr += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (test_bit(QSEED3_COEF_LUT_SWAP_BIT, &lut_flags))\n\t\tDPU_REG_WRITE(c, QSEED3_COEF_LUT_CTRL + offset, BIT(0));\n\n}\n\nstatic void _dpu_hw_setup_scaler3_de(struct dpu_hw_blk_reg_map *c,\n\t\tstruct dpu_hw_scaler3_de_cfg *de_cfg, u32 offset)\n{\n\tu32 sharp_lvl, sharp_ctl, shape_ctl, de_thr;\n\tu32 adjust_a, adjust_b, adjust_c;\n\n\tif (!de_cfg->enable)\n\t\treturn;\n\n\tsharp_lvl = (de_cfg->sharpen_level1 & 0x1FF) |\n\t\t((de_cfg->sharpen_level2 & 0x1FF) << 16);\n\n\tsharp_ctl = ((de_cfg->limit & 0xF) << 9) |\n\t\t((de_cfg->prec_shift & 0x7) << 13) |\n\t\t((de_cfg->clip & 0x7) << 16);\n\n\tshape_ctl = (de_cfg->thr_quiet & 0xFF) |\n\t\t((de_cfg->thr_dieout & 0x3FF) << 16);\n\n\tde_thr = (de_cfg->thr_low & 0x3FF) |\n\t\t((de_cfg->thr_high & 0x3FF) << 16);\n\n\tadjust_a = (de_cfg->adjust_a[0] & 0x3FF) |\n\t\t((de_cfg->adjust_a[1] & 0x3FF) << 10) |\n\t\t((de_cfg->adjust_a[2] & 0x3FF) << 20);\n\n\tadjust_b = (de_cfg->adjust_b[0] & 0x3FF) |\n\t\t((de_cfg->adjust_b[1] & 0x3FF) << 10) |\n\t\t((de_cfg->adjust_b[2] & 0x3FF) << 20);\n\n\tadjust_c = (de_cfg->adjust_c[0] & 0x3FF) |\n\t\t((de_cfg->adjust_c[1] & 0x3FF) << 10) |\n\t\t((de_cfg->adjust_c[2] & 0x3FF) << 20);\n\n\tDPU_REG_WRITE(c, QSEED3_DE_SHARPEN + offset, sharp_lvl);\n\tDPU_REG_WRITE(c, QSEED3_DE_SHARPEN_CTL + offset, sharp_ctl);\n\tDPU_REG_WRITE(c, QSEED3_DE_SHAPE_CTL + offset, shape_ctl);\n\tDPU_REG_WRITE(c, QSEED3_DE_THRESHOLD + offset, de_thr);\n\tDPU_REG_WRITE(c, QSEED3_DE_ADJUST_DATA_0 + offset, adjust_a);\n\tDPU_REG_WRITE(c, QSEED3_DE_ADJUST_DATA_1 + offset, adjust_b);\n\tDPU_REG_WRITE(c, QSEED3_DE_ADJUST_DATA_2 + offset, adjust_c);\n\n}\n\nvoid dpu_hw_setup_scaler3(struct dpu_hw_blk_reg_map *c,\n\t\tstruct dpu_hw_scaler3_cfg *scaler3_cfg,\n\t\tu32 scaler_offset, u32 scaler_version,\n\t\tconst struct dpu_format *format)\n{\n\tu32 op_mode = 0;\n\tu32 phase_init, preload, src_y_rgb, src_uv, dst;\n\n\tif (!scaler3_cfg->enable)\n\t\tgoto end;\n\n\top_mode |= BIT(0);\n\top_mode |= (scaler3_cfg->y_rgb_filter_cfg & 0x3) << 16;\n\n\tif (format && DPU_FORMAT_IS_YUV(format)) {\n\t\top_mode |= BIT(12);\n\t\top_mode |= (scaler3_cfg->uv_filter_cfg & 0x3) << 24;\n\t}\n\n\top_mode |= (scaler3_cfg->blend_cfg & 1) << 31;\n\top_mode |= (scaler3_cfg->dir_en) ? BIT(4) : 0;\n\n\tpreload =\n\t\t((scaler3_cfg->preload_x[0] & 0x7F) << 0) |\n\t\t((scaler3_cfg->preload_y[0] & 0x7F) << 8) |\n\t\t((scaler3_cfg->preload_x[1] & 0x7F) << 16) |\n\t\t((scaler3_cfg->preload_y[1] & 0x7F) << 24);\n\n\tsrc_y_rgb = (scaler3_cfg->src_width[0] & 0x1FFFF) |\n\t\t((scaler3_cfg->src_height[0] & 0x1FFFF) << 16);\n\n\tsrc_uv = (scaler3_cfg->src_width[1] & 0x1FFFF) |\n\t\t((scaler3_cfg->src_height[1] & 0x1FFFF) << 16);\n\n\tdst = (scaler3_cfg->dst_width & 0x1FFFF) |\n\t\t((scaler3_cfg->dst_height & 0x1FFFF) << 16);\n\n\tif (scaler3_cfg->de.enable) {\n\t\t_dpu_hw_setup_scaler3_de(c, &scaler3_cfg->de, scaler_offset);\n\t\top_mode |= BIT(8);\n\t}\n\n\tif (scaler3_cfg->lut_flag) {\n\t\tif (scaler_version < 0x2004)\n\t\t\t_dpu_hw_setup_scaler3_lut(c, scaler3_cfg, scaler_offset);\n\t\telse\n\t\t\t_dpu_hw_setup_scaler3lite_lut(c, scaler3_cfg, scaler_offset);\n\t}\n\n\tif (scaler_version == 0x1002) {\n\t\tphase_init =\n\t\t\t((scaler3_cfg->init_phase_x[0] & 0x3F) << 0) |\n\t\t\t((scaler3_cfg->init_phase_y[0] & 0x3F) << 8) |\n\t\t\t((scaler3_cfg->init_phase_x[1] & 0x3F) << 16) |\n\t\t\t((scaler3_cfg->init_phase_y[1] & 0x3F) << 24);\n\t\tDPU_REG_WRITE(c, QSEED3_PHASE_INIT + scaler_offset, phase_init);\n\t} else {\n\t\tDPU_REG_WRITE(c, QSEED3_PHASE_INIT_Y_H + scaler_offset,\n\t\t\tscaler3_cfg->init_phase_x[0] & 0x1FFFFF);\n\t\tDPU_REG_WRITE(c, QSEED3_PHASE_INIT_Y_V + scaler_offset,\n\t\t\tscaler3_cfg->init_phase_y[0] & 0x1FFFFF);\n\t\tDPU_REG_WRITE(c, QSEED3_PHASE_INIT_UV_H + scaler_offset,\n\t\t\tscaler3_cfg->init_phase_x[1] & 0x1FFFFF);\n\t\tDPU_REG_WRITE(c, QSEED3_PHASE_INIT_UV_V + scaler_offset,\n\t\t\tscaler3_cfg->init_phase_y[1] & 0x1FFFFF);\n\t}\n\n\tDPU_REG_WRITE(c, QSEED3_PHASE_STEP_Y_H + scaler_offset,\n\t\tscaler3_cfg->phase_step_x[0] & 0xFFFFFF);\n\n\tDPU_REG_WRITE(c, QSEED3_PHASE_STEP_Y_V + scaler_offset,\n\t\tscaler3_cfg->phase_step_y[0] & 0xFFFFFF);\n\n\tDPU_REG_WRITE(c, QSEED3_PHASE_STEP_UV_H + scaler_offset,\n\t\tscaler3_cfg->phase_step_x[1] & 0xFFFFFF);\n\n\tDPU_REG_WRITE(c, QSEED3_PHASE_STEP_UV_V + scaler_offset,\n\t\tscaler3_cfg->phase_step_y[1] & 0xFFFFFF);\n\n\tDPU_REG_WRITE(c, QSEED3_PRELOAD + scaler_offset, preload);\n\n\tDPU_REG_WRITE(c, QSEED3_SRC_SIZE_Y_RGB_A + scaler_offset, src_y_rgb);\n\n\tDPU_REG_WRITE(c, QSEED3_SRC_SIZE_UV + scaler_offset, src_uv);\n\n\tDPU_REG_WRITE(c, QSEED3_DST_SIZE + scaler_offset, dst);\n\nend:\n\tif (format && !DPU_FORMAT_IS_DX(format))\n\t\top_mode |= BIT(14);\n\n\tif (format && format->alpha_enable) {\n\t\top_mode |= BIT(10);\n\t\tif (scaler_version == 0x1002)\n\t\t\top_mode |= (scaler3_cfg->alpha_filter_cfg & 0x1) << 30;\n\t\telse\n\t\t\top_mode |= (scaler3_cfg->alpha_filter_cfg & 0x3) << 29;\n\t}\n\n\tDPU_REG_WRITE(c, QSEED3_OP_MODE + scaler_offset, op_mode);\n}\n\nu32 dpu_hw_get_scaler3_ver(struct dpu_hw_blk_reg_map *c,\n\t\t\tu32 scaler_offset)\n{\n\treturn DPU_REG_READ(c, QSEED3_HW_VERSION + scaler_offset);\n}\n\nvoid dpu_hw_csc_setup(struct dpu_hw_blk_reg_map *c,\n\t\tu32 csc_reg_off,\n\t\tconst struct dpu_csc_cfg *data, bool csc10)\n{\n\tstatic const u32 matrix_shift = 7;\n\tu32 clamp_shift = csc10 ? 16 : 8;\n\tu32 val;\n\n\t \n\tval = ((data->csc_mv[0] >> matrix_shift) & 0x1FFF) |\n\t\t(((data->csc_mv[1] >> matrix_shift) & 0x1FFF) << 16);\n\tDPU_REG_WRITE(c, csc_reg_off, val);\n\tval = ((data->csc_mv[2] >> matrix_shift) & 0x1FFF) |\n\t\t(((data->csc_mv[3] >> matrix_shift) & 0x1FFF) << 16);\n\tDPU_REG_WRITE(c, csc_reg_off + 0x4, val);\n\tval = ((data->csc_mv[4] >> matrix_shift) & 0x1FFF) |\n\t\t(((data->csc_mv[5] >> matrix_shift) & 0x1FFF) << 16);\n\tDPU_REG_WRITE(c, csc_reg_off + 0x8, val);\n\tval = ((data->csc_mv[6] >> matrix_shift) & 0x1FFF) |\n\t\t(((data->csc_mv[7] >> matrix_shift) & 0x1FFF) << 16);\n\tDPU_REG_WRITE(c, csc_reg_off + 0xc, val);\n\tval = (data->csc_mv[8] >> matrix_shift) & 0x1FFF;\n\tDPU_REG_WRITE(c, csc_reg_off + 0x10, val);\n\n\t \n\tval = (data->csc_pre_lv[0] << clamp_shift) | data->csc_pre_lv[1];\n\tDPU_REG_WRITE(c, csc_reg_off + 0x14, val);\n\tval = (data->csc_pre_lv[2] << clamp_shift) | data->csc_pre_lv[3];\n\tDPU_REG_WRITE(c, csc_reg_off + 0x18, val);\n\tval = (data->csc_pre_lv[4] << clamp_shift) | data->csc_pre_lv[5];\n\tDPU_REG_WRITE(c, csc_reg_off + 0x1c, val);\n\n\t \n\tval = (data->csc_post_lv[0] << clamp_shift) | data->csc_post_lv[1];\n\tDPU_REG_WRITE(c, csc_reg_off + 0x20, val);\n\tval = (data->csc_post_lv[2] << clamp_shift) | data->csc_post_lv[3];\n\tDPU_REG_WRITE(c, csc_reg_off + 0x24, val);\n\tval = (data->csc_post_lv[4] << clamp_shift) | data->csc_post_lv[5];\n\tDPU_REG_WRITE(c, csc_reg_off + 0x28, val);\n\n\t \n\tDPU_REG_WRITE(c, csc_reg_off + 0x2c, data->csc_pre_bv[0]);\n\tDPU_REG_WRITE(c, csc_reg_off + 0x30, data->csc_pre_bv[1]);\n\tDPU_REG_WRITE(c, csc_reg_off + 0x34, data->csc_pre_bv[2]);\n\n\t \n\tDPU_REG_WRITE(c, csc_reg_off + 0x38, data->csc_post_bv[0]);\n\tDPU_REG_WRITE(c, csc_reg_off + 0x3c, data->csc_post_bv[1]);\n\tDPU_REG_WRITE(c, csc_reg_off + 0x40, data->csc_post_bv[2]);\n}\n\n \nu64 _dpu_hw_get_qos_lut(const struct dpu_qos_lut_tbl *tbl,\n\t\tu32 total_fl)\n{\n\tint i;\n\n\tif (!tbl || !tbl->nentry || !tbl->entries)\n\t\treturn 0;\n\n\tfor (i = 0; i < tbl->nentry; i++)\n\t\tif (total_fl <= tbl->entries[i].fl)\n\t\t\treturn tbl->entries[i].lut;\n\n\t \n\tif (!tbl->entries[i-1].fl)\n\t\treturn tbl->entries[i-1].lut;\n\n\treturn 0;\n}\n\nvoid _dpu_hw_setup_qos_lut(struct dpu_hw_blk_reg_map *c, u32 offset,\n\t\t\t   bool qos_8lvl,\n\t\t\t   const struct dpu_hw_qos_cfg *cfg)\n{\n\tDPU_REG_WRITE(c, offset + QOS_DANGER_LUT, cfg->danger_lut);\n\tDPU_REG_WRITE(c, offset + QOS_SAFE_LUT, cfg->safe_lut);\n\n\tif (qos_8lvl) {\n\t\tDPU_REG_WRITE(c, offset + QOS_CREQ_LUT_0, cfg->creq_lut);\n\t\tDPU_REG_WRITE(c, offset + QOS_CREQ_LUT_1, cfg->creq_lut >> 32);\n\t} else {\n\t\tDPU_REG_WRITE(c, offset + QOS_CREQ_LUT, cfg->creq_lut);\n\t}\n\n\tDPU_REG_WRITE(c, offset + QOS_QOS_CTRL,\n\t\t      cfg->danger_safe_en ? QOS_QOS_CTRL_DANGER_SAFE_EN : 0);\n}\n\n \nvoid dpu_hw_setup_misr(struct dpu_hw_blk_reg_map *c,\n\t\tu32 misr_ctrl_offset, u8 input_sel)\n{\n\tu32 config = 0;\n\n\tDPU_REG_WRITE(c, misr_ctrl_offset, MISR_CTRL_STATUS_CLEAR);\n\n\t \n\twmb();\n\n\tconfig = MISR_FRAME_COUNT | MISR_CTRL_ENABLE | MISR_CTRL_FREE_RUN_MASK |\n\t\t((input_sel & 0xF) << 24);\n\tDPU_REG_WRITE(c, misr_ctrl_offset, config);\n}\n\nint dpu_hw_collect_misr(struct dpu_hw_blk_reg_map *c,\n\t\tu32 misr_ctrl_offset,\n\t\tu32 misr_signature_offset,\n\t\tu32 *misr_value)\n{\n\tu32 ctrl = 0;\n\n\tif (!misr_value)\n\t\treturn -EINVAL;\n\n\tctrl = DPU_REG_READ(c, misr_ctrl_offset);\n\n\tif (!(ctrl & MISR_CTRL_ENABLE))\n\t\treturn -ENODATA;\n\n\tif (!(ctrl & MISR_CTRL_STATUS))\n\t\treturn -EINVAL;\n\n\t*misr_value = DPU_REG_READ(c, misr_signature_offset);\n\n\treturn 0;\n}\n\n#define CDP_ENABLE\t\tBIT(0)\n#define CDP_UBWC_META_ENABLE\tBIT(1)\n#define CDP_TILE_AMORTIZE_ENABLE BIT(2)\n#define CDP_PRELOAD_AHEAD_64\tBIT(3)\n\nvoid dpu_setup_cdp(struct dpu_hw_blk_reg_map *c, u32 offset,\n\t\t   const struct dpu_format *fmt, bool enable)\n{\n\tu32 cdp_cntl = CDP_PRELOAD_AHEAD_64;\n\n\tif (enable)\n\t\tcdp_cntl |= CDP_ENABLE;\n\tif (DPU_FORMAT_IS_UBWC(fmt))\n\t\tcdp_cntl |= CDP_UBWC_META_ENABLE;\n\tif (DPU_FORMAT_IS_UBWC(fmt) ||\n\t    DPU_FORMAT_IS_TILE(fmt))\n\t\tcdp_cntl |= CDP_TILE_AMORTIZE_ENABLE;\n\n\tDPU_REG_WRITE(c, offset, cdp_cntl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}