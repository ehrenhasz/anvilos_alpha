{
  "module_name": "dpu_hw_interrupts.c",
  "hash_id": "f11e2d9b5d3a5feb796c7752206108071491eacd46b927375ff64d9deefff87b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_hw_interrupts.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n\n#include \"dpu_core_irq.h\"\n#include \"dpu_kms.h\"\n#include \"dpu_hw_interrupts.h\"\n#include \"dpu_hw_util.h\"\n#include \"dpu_hw_mdss.h\"\n#include \"dpu_trace.h\"\n\n \n#define MDP_INTF_OFF(intf)\t\t\t\t(0x6A000 + 0x800 * (intf))\n#define MDP_INTF_INTR_EN(intf)\t\t\t\t(MDP_INTF_OFF(intf) + 0x1c0)\n#define MDP_INTF_INTR_STATUS(intf)\t\t\t(MDP_INTF_OFF(intf) + 0x1c4)\n#define MDP_INTF_INTR_CLEAR(intf)\t\t\t(MDP_INTF_OFF(intf) + 0x1c8)\n#define MDP_INTF_TEAR_OFF(intf)\t\t\t\t(0x6D700 + 0x100 * (intf))\n#define MDP_INTF_INTR_TEAR_EN(intf)\t\t\t(MDP_INTF_TEAR_OFF(intf) + 0x000)\n#define MDP_INTF_INTR_TEAR_STATUS(intf)\t\t\t(MDP_INTF_TEAR_OFF(intf) + 0x004)\n#define MDP_INTF_INTR_TEAR_CLEAR(intf)\t\t\t(MDP_INTF_TEAR_OFF(intf) + 0x008)\n#define MDP_AD4_OFF(ad4)\t\t\t\t(0x7C000 + 0x1000 * (ad4))\n#define MDP_AD4_INTR_EN_OFF(ad4)\t\t\t(MDP_AD4_OFF(ad4) + 0x41c)\n#define MDP_AD4_INTR_CLEAR_OFF(ad4)\t\t\t(MDP_AD4_OFF(ad4) + 0x424)\n#define MDP_AD4_INTR_STATUS_OFF(ad4)\t\t\t(MDP_AD4_OFF(ad4) + 0x420)\n#define MDP_INTF_REV_7xxx_OFF(intf)\t\t\t(0x34000 + 0x1000 * (intf))\n#define MDP_INTF_REV_7xxx_INTR_EN(intf)\t\t\t(MDP_INTF_REV_7xxx_OFF(intf) + 0x1c0)\n#define MDP_INTF_REV_7xxx_INTR_STATUS(intf)\t\t(MDP_INTF_REV_7xxx_OFF(intf) + 0x1c4)\n#define MDP_INTF_REV_7xxx_INTR_CLEAR(intf)\t\t(MDP_INTF_REV_7xxx_OFF(intf) + 0x1c8)\n#define MDP_INTF_REV_7xxx_TEAR_OFF(intf)\t\t(0x34800 + 0x1000 * (intf))\n#define MDP_INTF_REV_7xxx_INTR_TEAR_EN(intf)\t\t(MDP_INTF_REV_7xxx_TEAR_OFF(intf) + 0x000)\n#define MDP_INTF_REV_7xxx_INTR_TEAR_STATUS(intf)\t(MDP_INTF_REV_7xxx_TEAR_OFF(intf) + 0x004)\n#define MDP_INTF_REV_7xxx_INTR_TEAR_CLEAR(intf)\t\t(MDP_INTF_REV_7xxx_TEAR_OFF(intf) + 0x008)\n\n \nstruct dpu_intr_reg {\n\tu32 clr_off;\n\tu32 en_off;\n\tu32 status_off;\n};\n\n \nstatic const struct dpu_intr_reg dpu_intr_set_legacy[] = {\n\t[MDP_SSPP_TOP0_INTR] = {\n\t\tINTR_CLEAR,\n\t\tINTR_EN,\n\t\tINTR_STATUS\n\t},\n\t[MDP_SSPP_TOP0_INTR2] = {\n\t\tINTR2_CLEAR,\n\t\tINTR2_EN,\n\t\tINTR2_STATUS\n\t},\n\t[MDP_SSPP_TOP0_HIST_INTR] = {\n\t\tHIST_INTR_CLEAR,\n\t\tHIST_INTR_EN,\n\t\tHIST_INTR_STATUS\n\t},\n\t[MDP_INTF0_INTR] = {\n\t\tMDP_INTF_INTR_CLEAR(0),\n\t\tMDP_INTF_INTR_EN(0),\n\t\tMDP_INTF_INTR_STATUS(0)\n\t},\n\t[MDP_INTF1_INTR] = {\n\t\tMDP_INTF_INTR_CLEAR(1),\n\t\tMDP_INTF_INTR_EN(1),\n\t\tMDP_INTF_INTR_STATUS(1)\n\t},\n\t[MDP_INTF2_INTR] = {\n\t\tMDP_INTF_INTR_CLEAR(2),\n\t\tMDP_INTF_INTR_EN(2),\n\t\tMDP_INTF_INTR_STATUS(2)\n\t},\n\t[MDP_INTF3_INTR] = {\n\t\tMDP_INTF_INTR_CLEAR(3),\n\t\tMDP_INTF_INTR_EN(3),\n\t\tMDP_INTF_INTR_STATUS(3)\n\t},\n\t[MDP_INTF4_INTR] = {\n\t\tMDP_INTF_INTR_CLEAR(4),\n\t\tMDP_INTF_INTR_EN(4),\n\t\tMDP_INTF_INTR_STATUS(4)\n\t},\n\t[MDP_INTF5_INTR] = {\n\t\tMDP_INTF_INTR_CLEAR(5),\n\t\tMDP_INTF_INTR_EN(5),\n\t\tMDP_INTF_INTR_STATUS(5)\n\t},\n\t[MDP_INTF1_TEAR_INTR] = {\n\t\tMDP_INTF_INTR_TEAR_CLEAR(1),\n\t\tMDP_INTF_INTR_TEAR_EN(1),\n\t\tMDP_INTF_INTR_TEAR_STATUS(1)\n\t},\n\t[MDP_INTF2_TEAR_INTR] = {\n\t\tMDP_INTF_INTR_TEAR_CLEAR(2),\n\t\tMDP_INTF_INTR_TEAR_EN(2),\n\t\tMDP_INTF_INTR_TEAR_STATUS(2)\n\t},\n\t[MDP_AD4_0_INTR] = {\n\t\tMDP_AD4_INTR_CLEAR_OFF(0),\n\t\tMDP_AD4_INTR_EN_OFF(0),\n\t\tMDP_AD4_INTR_STATUS_OFF(0),\n\t},\n\t[MDP_AD4_1_INTR] = {\n\t\tMDP_AD4_INTR_CLEAR_OFF(1),\n\t\tMDP_AD4_INTR_EN_OFF(1),\n\t\tMDP_AD4_INTR_STATUS_OFF(1),\n\t},\n};\n\n \nstatic const struct dpu_intr_reg dpu_intr_set_7xxx[] = {\n\t[MDP_SSPP_TOP0_INTR] = {\n\t\tINTR_CLEAR,\n\t\tINTR_EN,\n\t\tINTR_STATUS\n\t},\n\t[MDP_SSPP_TOP0_INTR2] = {\n\t\tINTR2_CLEAR,\n\t\tINTR2_EN,\n\t\tINTR2_STATUS\n\t},\n\t[MDP_SSPP_TOP0_HIST_INTR] = {\n\t\tHIST_INTR_CLEAR,\n\t\tHIST_INTR_EN,\n\t\tHIST_INTR_STATUS\n\t},\n\t[MDP_INTF0_INTR] = {\n\t\tMDP_INTF_REV_7xxx_INTR_CLEAR(0),\n\t\tMDP_INTF_REV_7xxx_INTR_EN(0),\n\t\tMDP_INTF_REV_7xxx_INTR_STATUS(0)\n\t},\n\t[MDP_INTF1_INTR] = {\n\t\tMDP_INTF_REV_7xxx_INTR_CLEAR(1),\n\t\tMDP_INTF_REV_7xxx_INTR_EN(1),\n\t\tMDP_INTF_REV_7xxx_INTR_STATUS(1)\n\t},\n\t[MDP_INTF1_TEAR_INTR] = {\n\t\tMDP_INTF_REV_7xxx_INTR_TEAR_CLEAR(1),\n\t\tMDP_INTF_REV_7xxx_INTR_TEAR_EN(1),\n\t\tMDP_INTF_REV_7xxx_INTR_TEAR_STATUS(1)\n\t},\n\t[MDP_INTF2_INTR] = {\n\t\tMDP_INTF_REV_7xxx_INTR_CLEAR(2),\n\t\tMDP_INTF_REV_7xxx_INTR_EN(2),\n\t\tMDP_INTF_REV_7xxx_INTR_STATUS(2)\n\t},\n\t[MDP_INTF2_TEAR_INTR] = {\n\t\tMDP_INTF_REV_7xxx_INTR_TEAR_CLEAR(2),\n\t\tMDP_INTF_REV_7xxx_INTR_TEAR_EN(2),\n\t\tMDP_INTF_REV_7xxx_INTR_TEAR_STATUS(2)\n\t},\n\t[MDP_INTF3_INTR] = {\n\t\tMDP_INTF_REV_7xxx_INTR_CLEAR(3),\n\t\tMDP_INTF_REV_7xxx_INTR_EN(3),\n\t\tMDP_INTF_REV_7xxx_INTR_STATUS(3)\n\t},\n\t[MDP_INTF4_INTR] = {\n\t\tMDP_INTF_REV_7xxx_INTR_CLEAR(4),\n\t\tMDP_INTF_REV_7xxx_INTR_EN(4),\n\t\tMDP_INTF_REV_7xxx_INTR_STATUS(4)\n\t},\n\t[MDP_INTF5_INTR] = {\n\t\tMDP_INTF_REV_7xxx_INTR_CLEAR(5),\n\t\tMDP_INTF_REV_7xxx_INTR_EN(5),\n\t\tMDP_INTF_REV_7xxx_INTR_STATUS(5)\n\t},\n\t[MDP_INTF6_INTR] = {\n\t\tMDP_INTF_REV_7xxx_INTR_CLEAR(6),\n\t\tMDP_INTF_REV_7xxx_INTR_EN(6),\n\t\tMDP_INTF_REV_7xxx_INTR_STATUS(6)\n\t},\n\t[MDP_INTF7_INTR] = {\n\t\tMDP_INTF_REV_7xxx_INTR_CLEAR(7),\n\t\tMDP_INTF_REV_7xxx_INTR_EN(7),\n\t\tMDP_INTF_REV_7xxx_INTR_STATUS(7)\n\t},\n\t[MDP_INTF8_INTR] = {\n\t\tMDP_INTF_REV_7xxx_INTR_CLEAR(8),\n\t\tMDP_INTF_REV_7xxx_INTR_EN(8),\n\t\tMDP_INTF_REV_7xxx_INTR_STATUS(8)\n\t},\n};\n\n#define DPU_IRQ_REG(irq_idx)\t(irq_idx / 32)\n#define DPU_IRQ_MASK(irq_idx)\t(BIT(irq_idx % 32))\n\n \nstatic void dpu_core_irq_callback_handler(struct dpu_kms *dpu_kms, int irq_idx)\n{\n\tVERB(\"irq_idx=%d\\n\", irq_idx);\n\n\tif (!dpu_kms->hw_intr->irq_tbl[irq_idx].cb)\n\t\tDRM_ERROR(\"no registered cb, idx:%d\\n\", irq_idx);\n\n\tatomic_inc(&dpu_kms->hw_intr->irq_tbl[irq_idx].count);\n\n\t \n\tdpu_kms->hw_intr->irq_tbl[irq_idx].cb(dpu_kms->hw_intr->irq_tbl[irq_idx].arg, irq_idx);\n}\n\nirqreturn_t dpu_core_irq(struct msm_kms *kms)\n{\n\tstruct dpu_kms *dpu_kms = to_dpu_kms(kms);\n\tstruct dpu_hw_intr *intr = dpu_kms->hw_intr;\n\tint reg_idx;\n\tint irq_idx;\n\tu32 irq_status;\n\tu32 enable_mask;\n\tint bit;\n\tunsigned long irq_flags;\n\n\tif (!intr)\n\t\treturn IRQ_NONE;\n\n\tspin_lock_irqsave(&intr->irq_lock, irq_flags);\n\tfor (reg_idx = 0; reg_idx < MDP_INTR_MAX; reg_idx++) {\n\t\tif (!test_bit(reg_idx, &intr->irq_mask))\n\t\t\tcontinue;\n\n\t\t \n\t\tirq_status = DPU_REG_READ(&intr->hw, intr->intr_set[reg_idx].status_off);\n\n\t\t \n\t\tenable_mask = DPU_REG_READ(&intr->hw, intr->intr_set[reg_idx].en_off);\n\n\t\t \n\t\tif (irq_status)\n\t\t\tDPU_REG_WRITE(&intr->hw, intr->intr_set[reg_idx].clr_off,\n\t\t\t\t     irq_status);\n\n\t\t \n\t\tirq_status &= enable_mask;\n\n\t\tif (!irq_status)\n\t\t\tcontinue;\n\n\t\t \n\t\twhile ((bit = ffs(irq_status)) != 0) {\n\t\t\tirq_idx = DPU_IRQ_IDX(reg_idx, bit - 1);\n\n\t\t\tdpu_core_irq_callback_handler(dpu_kms, irq_idx);\n\n\t\t\t \n\t\t\tirq_status &= ~BIT(bit - 1);\n\t\t}\n\t}\n\n\t \n\twmb();\n\n\tspin_unlock_irqrestore(&intr->irq_lock, irq_flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dpu_hw_intr_enable_irq_locked(struct dpu_hw_intr *intr, int irq_idx)\n{\n\tint reg_idx;\n\tconst struct dpu_intr_reg *reg;\n\tconst char *dbgstr = NULL;\n\tuint32_t cache_irq_mask;\n\n\tif (!intr)\n\t\treturn -EINVAL;\n\n\tif (irq_idx < 0 || irq_idx >= intr->total_irqs) {\n\t\tpr_err(\"invalid IRQ index: [%d]\\n\", irq_idx);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tassert_spin_locked(&intr->irq_lock);\n\n\treg_idx = DPU_IRQ_REG(irq_idx);\n\treg = &intr->intr_set[reg_idx];\n\n\t \n\tif (WARN_ON(!reg->en_off))\n\t\treturn -EINVAL;\n\n\tcache_irq_mask = intr->cache_irq_mask[reg_idx];\n\tif (cache_irq_mask & DPU_IRQ_MASK(irq_idx)) {\n\t\tdbgstr = \"already \";\n\t} else {\n\t\tdbgstr = \"\";\n\n\t\tcache_irq_mask |= DPU_IRQ_MASK(irq_idx);\n\t\t \n\t\tDPU_REG_WRITE(&intr->hw, reg->clr_off, DPU_IRQ_MASK(irq_idx));\n\t\t \n\t\tDPU_REG_WRITE(&intr->hw, reg->en_off, cache_irq_mask);\n\n\t\t \n\t\twmb();\n\n\t\tintr->cache_irq_mask[reg_idx] = cache_irq_mask;\n\t}\n\n\tpr_debug(\"DPU IRQ %d %senabled: MASK:0x%.8lx, CACHE-MASK:0x%.8x\\n\", irq_idx, dbgstr,\n\t\t\tDPU_IRQ_MASK(irq_idx), cache_irq_mask);\n\n\treturn 0;\n}\n\nstatic int dpu_hw_intr_disable_irq_locked(struct dpu_hw_intr *intr, int irq_idx)\n{\n\tint reg_idx;\n\tconst struct dpu_intr_reg *reg;\n\tconst char *dbgstr = NULL;\n\tuint32_t cache_irq_mask;\n\n\tif (!intr)\n\t\treturn -EINVAL;\n\n\tif (irq_idx < 0 || irq_idx >= intr->total_irqs) {\n\t\tpr_err(\"invalid IRQ index: [%d]\\n\", irq_idx);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tassert_spin_locked(&intr->irq_lock);\n\n\treg_idx = DPU_IRQ_REG(irq_idx);\n\treg = &intr->intr_set[reg_idx];\n\n\tcache_irq_mask = intr->cache_irq_mask[reg_idx];\n\tif ((cache_irq_mask & DPU_IRQ_MASK(irq_idx)) == 0) {\n\t\tdbgstr = \"already \";\n\t} else {\n\t\tdbgstr = \"\";\n\n\t\tcache_irq_mask &= ~DPU_IRQ_MASK(irq_idx);\n\t\t \n\t\tDPU_REG_WRITE(&intr->hw, reg->en_off, cache_irq_mask);\n\t\t \n\t\tDPU_REG_WRITE(&intr->hw, reg->clr_off, DPU_IRQ_MASK(irq_idx));\n\n\t\t \n\t\twmb();\n\n\t\tintr->cache_irq_mask[reg_idx] = cache_irq_mask;\n\t}\n\n\tpr_debug(\"DPU IRQ %d %sdisabled: MASK:0x%.8lx, CACHE-MASK:0x%.8x\\n\", irq_idx, dbgstr,\n\t\t\tDPU_IRQ_MASK(irq_idx), cache_irq_mask);\n\n\treturn 0;\n}\n\nstatic void dpu_clear_irqs(struct dpu_kms *dpu_kms)\n{\n\tstruct dpu_hw_intr *intr = dpu_kms->hw_intr;\n\tint i;\n\n\tif (!intr)\n\t\treturn;\n\n\tfor (i = 0; i < MDP_INTR_MAX; i++) {\n\t\tif (test_bit(i, &intr->irq_mask))\n\t\t\tDPU_REG_WRITE(&intr->hw,\n\t\t\t\t\tintr->intr_set[i].clr_off, 0xffffffff);\n\t}\n\n\t \n\twmb();\n}\n\nstatic void dpu_disable_all_irqs(struct dpu_kms *dpu_kms)\n{\n\tstruct dpu_hw_intr *intr = dpu_kms->hw_intr;\n\tint i;\n\n\tif (!intr)\n\t\treturn;\n\n\tfor (i = 0; i < MDP_INTR_MAX; i++) {\n\t\tif (test_bit(i, &intr->irq_mask))\n\t\t\tDPU_REG_WRITE(&intr->hw,\n\t\t\t\t\tintr->intr_set[i].en_off, 0x00000000);\n\t}\n\n\t \n\twmb();\n}\n\nu32 dpu_core_irq_read(struct dpu_kms *dpu_kms, int irq_idx)\n{\n\tstruct dpu_hw_intr *intr = dpu_kms->hw_intr;\n\tint reg_idx;\n\tunsigned long irq_flags;\n\tu32 intr_status;\n\n\tif (!intr)\n\t\treturn 0;\n\n\tif (irq_idx < 0) {\n\t\tDPU_ERROR(\"[%pS] invalid irq_idx=%d\\n\",\n\t\t\t\t__builtin_return_address(0), irq_idx);\n\t\treturn 0;\n\t}\n\n\tif (irq_idx < 0 || irq_idx >= intr->total_irqs) {\n\t\tpr_err(\"invalid IRQ index: [%d]\\n\", irq_idx);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&intr->irq_lock, irq_flags);\n\n\treg_idx = DPU_IRQ_REG(irq_idx);\n\tintr_status = DPU_REG_READ(&intr->hw,\n\t\t\tintr->intr_set[reg_idx].status_off) &\n\t\tDPU_IRQ_MASK(irq_idx);\n\tif (intr_status)\n\t\tDPU_REG_WRITE(&intr->hw, intr->intr_set[reg_idx].clr_off,\n\t\t\t\tintr_status);\n\n\t \n\twmb();\n\n\tspin_unlock_irqrestore(&intr->irq_lock, irq_flags);\n\n\treturn intr_status;\n}\n\nstruct dpu_hw_intr *dpu_hw_intr_init(void __iomem *addr,\n\t\tconst struct dpu_mdss_cfg *m)\n{\n\tstruct dpu_hw_intr *intr;\n\tint nirq = MDP_INTR_MAX * 32;\n\tunsigned int i;\n\n\tif (!addr || !m)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tintr = kzalloc(struct_size(intr, irq_tbl, nirq), GFP_KERNEL);\n\tif (!intr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (m->mdss_ver->core_major_ver >= 7)\n\t\tintr->intr_set = dpu_intr_set_7xxx;\n\telse\n\t\tintr->intr_set = dpu_intr_set_legacy;\n\n\tintr->hw.blk_addr = addr + m->mdp[0].base;\n\n\tintr->total_irqs = nirq;\n\n\tintr->irq_mask = BIT(MDP_SSPP_TOP0_INTR) |\n\t\t\t BIT(MDP_SSPP_TOP0_INTR2) |\n\t\t\t BIT(MDP_SSPP_TOP0_HIST_INTR);\n\tfor (i = 0; i < m->intf_count; i++) {\n\t\tconst struct dpu_intf_cfg *intf = &m->intf[i];\n\n\t\tif (intf->type == INTF_NONE)\n\t\t\tcontinue;\n\n\t\tintr->irq_mask |= BIT(MDP_INTFn_INTR(intf->id));\n\n\t\tif (intf->intr_tear_rd_ptr != -1)\n\t\t\tintr->irq_mask |= BIT(DPU_IRQ_REG(intf->intr_tear_rd_ptr));\n\t}\n\n\tspin_lock_init(&intr->irq_lock);\n\n\treturn intr;\n}\n\nvoid dpu_hw_intr_destroy(struct dpu_hw_intr *intr)\n{\n\tkfree(intr);\n}\n\nint dpu_core_irq_register_callback(struct dpu_kms *dpu_kms, int irq_idx,\n\t\tvoid (*irq_cb)(void *arg, int irq_idx),\n\t\tvoid *irq_arg)\n{\n\tunsigned long irq_flags;\n\tint ret;\n\n\tif (!irq_cb) {\n\t\tDPU_ERROR(\"invalid ird_idx:%d irq_cb:%ps\\n\", irq_idx, irq_cb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (irq_idx < 0 || irq_idx >= dpu_kms->hw_intr->total_irqs) {\n\t\tDPU_ERROR(\"invalid IRQ index: [%d]\\n\", irq_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tVERB(\"[%pS] irq_idx=%d\\n\", __builtin_return_address(0), irq_idx);\n\n\tspin_lock_irqsave(&dpu_kms->hw_intr->irq_lock, irq_flags);\n\n\tif (unlikely(WARN_ON(dpu_kms->hw_intr->irq_tbl[irq_idx].cb))) {\n\t\tspin_unlock_irqrestore(&dpu_kms->hw_intr->irq_lock, irq_flags);\n\n\t\treturn -EBUSY;\n\t}\n\n\ttrace_dpu_core_irq_register_callback(irq_idx, irq_cb);\n\tdpu_kms->hw_intr->irq_tbl[irq_idx].arg = irq_arg;\n\tdpu_kms->hw_intr->irq_tbl[irq_idx].cb = irq_cb;\n\n\tret = dpu_hw_intr_enable_irq_locked(\n\t\t\t\tdpu_kms->hw_intr,\n\t\t\t\tirq_idx);\n\tif (ret)\n\t\tDPU_ERROR(\"Fail to enable IRQ for irq_idx:%d\\n\",\n\t\t\t\t\tirq_idx);\n\tspin_unlock_irqrestore(&dpu_kms->hw_intr->irq_lock, irq_flags);\n\n\ttrace_dpu_irq_register_success(irq_idx);\n\n\treturn 0;\n}\n\nint dpu_core_irq_unregister_callback(struct dpu_kms *dpu_kms, int irq_idx)\n{\n\tunsigned long irq_flags;\n\tint ret;\n\n\tif (irq_idx < 0 || irq_idx >= dpu_kms->hw_intr->total_irqs) {\n\t\tDPU_ERROR(\"invalid IRQ index: [%d]\\n\", irq_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tVERB(\"[%pS] irq_idx=%d\\n\", __builtin_return_address(0), irq_idx);\n\n\tspin_lock_irqsave(&dpu_kms->hw_intr->irq_lock, irq_flags);\n\ttrace_dpu_core_irq_unregister_callback(irq_idx);\n\n\tret = dpu_hw_intr_disable_irq_locked(dpu_kms->hw_intr, irq_idx);\n\tif (ret)\n\t\tDPU_ERROR(\"Fail to disable IRQ for irq_idx:%d: %d\\n\",\n\t\t\t\t\tirq_idx, ret);\n\n\tdpu_kms->hw_intr->irq_tbl[irq_idx].cb = NULL;\n\tdpu_kms->hw_intr->irq_tbl[irq_idx].arg = NULL;\n\n\tspin_unlock_irqrestore(&dpu_kms->hw_intr->irq_lock, irq_flags);\n\n\ttrace_dpu_irq_unregister_success(irq_idx);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int dpu_debugfs_core_irq_show(struct seq_file *s, void *v)\n{\n\tstruct dpu_kms *dpu_kms = s->private;\n\tunsigned long irq_flags;\n\tint i, irq_count;\n\tvoid *cb;\n\n\tfor (i = 0; i < dpu_kms->hw_intr->total_irqs; i++) {\n\t\tspin_lock_irqsave(&dpu_kms->hw_intr->irq_lock, irq_flags);\n\t\tirq_count = atomic_read(&dpu_kms->hw_intr->irq_tbl[i].count);\n\t\tcb = dpu_kms->hw_intr->irq_tbl[i].cb;\n\t\tspin_unlock_irqrestore(&dpu_kms->hw_intr->irq_lock, irq_flags);\n\n\t\tif (irq_count || cb)\n\t\t\tseq_printf(s, \"idx:%d irq:%d cb:%ps\\n\", i, irq_count, cb);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(dpu_debugfs_core_irq);\n\nvoid dpu_debugfs_core_irq_init(struct dpu_kms *dpu_kms,\n\t\tstruct dentry *parent)\n{\n\tdebugfs_create_file(\"core_irq\", 0600, parent, dpu_kms,\n\t\t&dpu_debugfs_core_irq_fops);\n}\n#endif\n\nvoid dpu_core_irq_preinstall(struct msm_kms *kms)\n{\n\tstruct dpu_kms *dpu_kms = to_dpu_kms(kms);\n\tint i;\n\n\tpm_runtime_get_sync(&dpu_kms->pdev->dev);\n\tdpu_clear_irqs(dpu_kms);\n\tdpu_disable_all_irqs(dpu_kms);\n\tpm_runtime_put_sync(&dpu_kms->pdev->dev);\n\n\tfor (i = 0; i < dpu_kms->hw_intr->total_irqs; i++)\n\t\tatomic_set(&dpu_kms->hw_intr->irq_tbl[i].count, 0);\n}\n\nvoid dpu_core_irq_uninstall(struct msm_kms *kms)\n{\n\tstruct dpu_kms *dpu_kms = to_dpu_kms(kms);\n\tint i;\n\n\tif (!dpu_kms->hw_intr)\n\t\treturn;\n\n\tpm_runtime_get_sync(&dpu_kms->pdev->dev);\n\tfor (i = 0; i < dpu_kms->hw_intr->total_irqs; i++)\n\t\tif (dpu_kms->hw_intr->irq_tbl[i].cb)\n\t\t\tDPU_ERROR(\"irq_idx=%d still enabled/registered\\n\", i);\n\n\tdpu_clear_irqs(dpu_kms);\n\tdpu_disable_all_irqs(dpu_kms);\n\tpm_runtime_put_sync(&dpu_kms->pdev->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}