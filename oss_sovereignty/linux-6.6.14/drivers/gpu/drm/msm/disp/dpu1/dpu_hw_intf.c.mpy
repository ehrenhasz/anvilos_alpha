{
  "module_name": "dpu_hw_intf.c",
  "hash_id": "df4b005cc9af88d8164a2eb15b60025765f3ea69e7f999a911349e2bb52b8aad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_hw_intf.c",
  "human_readable_source": "\n \n\n#include \"dpu_hwio.h\"\n#include \"dpu_hw_catalog.h\"\n#include \"dpu_hw_intf.h\"\n#include \"dpu_kms.h\"\n#include \"dpu_trace.h\"\n\n#include <linux/iopoll.h>\n\n#define INTF_TIMING_ENGINE_EN           0x000\n#define INTF_CONFIG                     0x004\n#define INTF_HSYNC_CTL                  0x008\n#define INTF_VSYNC_PERIOD_F0            0x00C\n#define INTF_VSYNC_PERIOD_F1            0x010\n#define INTF_VSYNC_PULSE_WIDTH_F0       0x014\n#define INTF_VSYNC_PULSE_WIDTH_F1       0x018\n#define INTF_DISPLAY_V_START_F0         0x01C\n#define INTF_DISPLAY_V_START_F1         0x020\n#define INTF_DISPLAY_V_END_F0           0x024\n#define INTF_DISPLAY_V_END_F1           0x028\n#define INTF_ACTIVE_V_START_F0          0x02C\n#define INTF_ACTIVE_V_START_F1          0x030\n#define INTF_ACTIVE_V_END_F0            0x034\n#define INTF_ACTIVE_V_END_F1            0x038\n#define INTF_DISPLAY_HCTL               0x03C\n#define INTF_ACTIVE_HCTL                0x040\n#define INTF_BORDER_COLOR               0x044\n#define INTF_UNDERFLOW_COLOR            0x048\n#define INTF_HSYNC_SKEW                 0x04C\n#define INTF_POLARITY_CTL               0x050\n#define INTF_TEST_CTL                   0x054\n#define INTF_TP_COLOR0                  0x058\n#define INTF_TP_COLOR1                  0x05C\n#define INTF_CONFIG2                    0x060\n#define INTF_DISPLAY_DATA_HCTL          0x064\n#define INTF_ACTIVE_DATA_HCTL           0x068\n\n#define INTF_DSI_CMD_MODE_TRIGGER_EN    0x084\n#define INTF_PANEL_FORMAT               0x090\n\n#define INTF_FRAME_LINE_COUNT_EN        0x0A8\n#define INTF_FRAME_COUNT                0x0AC\n#define INTF_LINE_COUNT                 0x0B0\n\n#define INTF_DEFLICKER_CONFIG           0x0F0\n#define INTF_DEFLICKER_STRNG_COEFF      0x0F4\n#define INTF_DEFLICKER_WEAK_COEFF       0x0F8\n\n#define INTF_TPG_ENABLE                 0x100\n#define INTF_TPG_MAIN_CONTROL           0x104\n#define INTF_TPG_VIDEO_CONFIG           0x108\n#define INTF_TPG_COMPONENT_LIMITS       0x10C\n#define INTF_TPG_RECTANGLE              0x110\n#define INTF_TPG_INITIAL_VALUE          0x114\n#define INTF_TPG_BLK_WHITE_PATTERN_FRAMES 0x118\n#define INTF_TPG_RGB_MAPPING            0x11C\n#define INTF_PROG_FETCH_START           0x170\n#define INTF_PROG_ROT_START             0x174\n\n#define INTF_MISR_CTRL                  0x180\n#define INTF_MISR_SIGNATURE             0x184\n\n#define INTF_MUX                        0x25C\n#define INTF_STATUS                     0x26C\n#define INTF_AVR_CONTROL                0x270\n#define INTF_AVR_MODE                   0x274\n#define INTF_AVR_TRIGGER                0x278\n#define INTF_AVR_VTOTAL                 0x27C\n#define INTF_TEAR_MDP_VSYNC_SEL         0x280\n#define INTF_TEAR_TEAR_CHECK_EN         0x284\n#define INTF_TEAR_SYNC_CONFIG_VSYNC     0x288\n#define INTF_TEAR_SYNC_CONFIG_HEIGHT    0x28C\n#define INTF_TEAR_SYNC_WRCOUNT          0x290\n#define INTF_TEAR_VSYNC_INIT_VAL        0x294\n#define INTF_TEAR_INT_COUNT_VAL         0x298\n#define INTF_TEAR_SYNC_THRESH           0x29C\n#define INTF_TEAR_START_POS             0x2A0\n#define INTF_TEAR_RD_PTR_IRQ            0x2A4\n#define INTF_TEAR_WR_PTR_IRQ            0x2A8\n#define INTF_TEAR_OUT_LINE_COUNT        0x2AC\n#define INTF_TEAR_LINE_COUNT            0x2B0\n#define INTF_TEAR_AUTOREFRESH_CONFIG    0x2B4\n\n#define INTF_CFG_ACTIVE_H_EN\tBIT(29)\n#define INTF_CFG_ACTIVE_V_EN\tBIT(30)\n\n#define INTF_CFG2_DATABUS_WIDEN\tBIT(0)\n#define INTF_CFG2_DATA_HCTL_EN\tBIT(4)\n#define INTF_CFG2_DCE_DATA_COMPRESS     BIT(12)\n\n\nstatic void dpu_hw_intf_setup_timing_engine(struct dpu_hw_intf *ctx,\n\t\tconst struct dpu_hw_intf_timing_params *p,\n\t\tconst struct dpu_format *fmt)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tu32 hsync_period, vsync_period;\n\tu32 display_v_start, display_v_end;\n\tu32 hsync_start_x, hsync_end_x;\n\tu32 hsync_data_start_x, hsync_data_end_x;\n\tu32 active_h_start, active_h_end;\n\tu32 active_v_start, active_v_end;\n\tu32 active_hctl, display_hctl, hsync_ctl;\n\tu32 polarity_ctl, den_polarity;\n\tu32 panel_format;\n\tu32 intf_cfg, intf_cfg2 = 0;\n\tu32 display_data_hctl = 0, active_data_hctl = 0;\n\tu32 data_width;\n\tbool dp_intf = false;\n\n\t \n\tintf_cfg = DPU_REG_READ(c, INTF_CONFIG);\n\n\tif (ctx->cap->type == INTF_DP)\n\t\tdp_intf = true;\n\n\thsync_period = p->hsync_pulse_width + p->h_back_porch + p->width +\n\tp->h_front_porch;\n\tvsync_period = p->vsync_pulse_width + p->v_back_porch + p->height +\n\tp->v_front_porch;\n\n\tdisplay_v_start = ((p->vsync_pulse_width + p->v_back_porch) *\n\thsync_period) + p->hsync_skew;\n\tdisplay_v_end = ((vsync_period - p->v_front_porch) * hsync_period) +\n\tp->hsync_skew - 1;\n\n\thsync_start_x = p->h_back_porch + p->hsync_pulse_width;\n\thsync_end_x = hsync_period - p->h_front_porch - 1;\n\n\tif (p->width != p->xres) {  \n\t\tactive_h_start = hsync_start_x;\n\t\tactive_h_end = active_h_start + p->xres - 1;\n\t} else {\n\t\tactive_h_start = 0;\n\t\tactive_h_end = 0;\n\t}\n\n\tif (p->height != p->yres) {  \n\t\tactive_v_start = display_v_start;\n\t\tactive_v_end = active_v_start + (p->yres * hsync_period) - 1;\n\t} else {\n\t\tactive_v_start = 0;\n\t\tactive_v_end = 0;\n\t}\n\n\tif (active_h_end) {\n\t\tactive_hctl = (active_h_end << 16) | active_h_start;\n\t\tintf_cfg |= INTF_CFG_ACTIVE_H_EN;\n\t} else {\n\t\tactive_hctl = 0;\n\t}\n\n\tif (active_v_end)\n\t\tintf_cfg |= INTF_CFG_ACTIVE_V_EN;\n\n\thsync_ctl = (hsync_period << 16) | p->hsync_pulse_width;\n\tdisplay_hctl = (hsync_end_x << 16) | hsync_start_x;\n\n\t \n\tif (p->wide_bus_en)\n\t\tintf_cfg2 |= INTF_CFG2_DATABUS_WIDEN | INTF_CFG2_DATA_HCTL_EN;\n\n\tdata_width = p->width;\n\n\thsync_data_start_x = hsync_start_x;\n\thsync_data_end_x =  hsync_start_x + data_width - 1;\n\n\tdisplay_data_hctl = (hsync_data_end_x << 16) | hsync_data_start_x;\n\n\tif (dp_intf) {\n\t\t \n\t\tdisplay_v_start += p->hsync_pulse_width + p->h_back_porch;\n\t\tdisplay_v_end   -= p->h_front_porch;\n\n\t\tactive_h_start = hsync_start_x;\n\t\tactive_h_end = active_h_start + p->xres - 1;\n\t\tactive_v_start = display_v_start;\n\t\tactive_v_end = active_v_start + (p->yres * hsync_period) - 1;\n\n\t\tactive_hctl = (active_h_end << 16) | active_h_start;\n\t\tdisplay_hctl = active_hctl;\n\n\t\tintf_cfg |= INTF_CFG_ACTIVE_H_EN | INTF_CFG_ACTIVE_V_EN;\n\t}\n\n\tden_polarity = 0;\n\tpolarity_ctl = (den_polarity << 2) |  \n\t\t(p->vsync_polarity << 1) |  \n\t\t(p->hsync_polarity << 0);   \n\n\tif (!DPU_FORMAT_IS_YUV(fmt))\n\t\tpanel_format = (fmt->bits[C0_G_Y] |\n\t\t\t\t(fmt->bits[C1_B_Cb] << 2) |\n\t\t\t\t(fmt->bits[C2_R_Cr] << 4) |\n\t\t\t\t(0x21 << 8));\n\telse\n\t\t \n\t\tpanel_format = (COLOR_8BIT |\n\t\t\t\t(COLOR_8BIT << 2) |\n\t\t\t\t(COLOR_8BIT << 4) |\n\t\t\t\t(0x21 << 8));\n\n\tDPU_REG_WRITE(c, INTF_HSYNC_CTL, hsync_ctl);\n\tDPU_REG_WRITE(c, INTF_VSYNC_PERIOD_F0, vsync_period * hsync_period);\n\tDPU_REG_WRITE(c, INTF_VSYNC_PULSE_WIDTH_F0,\n\t\t\tp->vsync_pulse_width * hsync_period);\n\tDPU_REG_WRITE(c, INTF_DISPLAY_HCTL, display_hctl);\n\tDPU_REG_WRITE(c, INTF_DISPLAY_V_START_F0, display_v_start);\n\tDPU_REG_WRITE(c, INTF_DISPLAY_V_END_F0, display_v_end);\n\tDPU_REG_WRITE(c, INTF_ACTIVE_HCTL,  active_hctl);\n\tDPU_REG_WRITE(c, INTF_ACTIVE_V_START_F0, active_v_start);\n\tDPU_REG_WRITE(c, INTF_ACTIVE_V_END_F0, active_v_end);\n\tDPU_REG_WRITE(c, INTF_BORDER_COLOR, p->border_clr);\n\tDPU_REG_WRITE(c, INTF_UNDERFLOW_COLOR, p->underflow_clr);\n\tDPU_REG_WRITE(c, INTF_HSYNC_SKEW, p->hsync_skew);\n\tDPU_REG_WRITE(c, INTF_POLARITY_CTL, polarity_ctl);\n\tDPU_REG_WRITE(c, INTF_FRAME_LINE_COUNT_EN, 0x3);\n\tDPU_REG_WRITE(c, INTF_CONFIG, intf_cfg);\n\tDPU_REG_WRITE(c, INTF_PANEL_FORMAT, panel_format);\n\tif (ctx->cap->features & BIT(DPU_DATA_HCTL_EN)) {\n\t\tDPU_REG_WRITE(c, INTF_CONFIG2, intf_cfg2);\n\t\tDPU_REG_WRITE(c, INTF_DISPLAY_DATA_HCTL, display_data_hctl);\n\t\tDPU_REG_WRITE(c, INTF_ACTIVE_DATA_HCTL, active_data_hctl);\n\t}\n}\n\nstatic void dpu_hw_intf_enable_timing_engine(\n\t\tstruct dpu_hw_intf *intf,\n\t\tu8 enable)\n{\n\tstruct dpu_hw_blk_reg_map *c = &intf->hw;\n\t \n\tDPU_REG_WRITE(c, INTF_TIMING_ENGINE_EN, enable != 0);\n}\n\nstatic void dpu_hw_intf_setup_prg_fetch(\n\t\tstruct dpu_hw_intf *intf,\n\t\tconst struct dpu_hw_intf_prog_fetch *fetch)\n{\n\tstruct dpu_hw_blk_reg_map *c = &intf->hw;\n\tint fetch_enable;\n\n\t \n\n\tfetch_enable = DPU_REG_READ(c, INTF_CONFIG);\n\tif (fetch->enable) {\n\t\tfetch_enable |= BIT(31);\n\t\tDPU_REG_WRITE(c, INTF_PROG_FETCH_START,\n\t\t\t\tfetch->fetch_start);\n\t} else {\n\t\tfetch_enable &= ~BIT(31);\n\t}\n\n\tDPU_REG_WRITE(c, INTF_CONFIG, fetch_enable);\n}\n\nstatic void dpu_hw_intf_bind_pingpong_blk(\n\t\tstruct dpu_hw_intf *intf,\n\t\tconst enum dpu_pingpong pp)\n{\n\tstruct dpu_hw_blk_reg_map *c = &intf->hw;\n\tu32 mux_cfg;\n\n\tmux_cfg = DPU_REG_READ(c, INTF_MUX);\n\tmux_cfg &= ~0xf;\n\n\tif (pp)\n\t\tmux_cfg |= (pp - PINGPONG_0) & 0x7;\n\telse\n\t\tmux_cfg |= 0xf;\n\n\tDPU_REG_WRITE(c, INTF_MUX, mux_cfg);\n}\n\nstatic void dpu_hw_intf_get_status(\n\t\tstruct dpu_hw_intf *intf,\n\t\tstruct dpu_hw_intf_status *s)\n{\n\tstruct dpu_hw_blk_reg_map *c = &intf->hw;\n\tunsigned long cap = intf->cap->features;\n\n\tif (cap & BIT(DPU_INTF_STATUS_SUPPORTED))\n\t\ts->is_en = DPU_REG_READ(c, INTF_STATUS) & BIT(0);\n\telse\n\t\ts->is_en = DPU_REG_READ(c, INTF_TIMING_ENGINE_EN);\n\n\ts->is_prog_fetch_en = !!(DPU_REG_READ(c, INTF_CONFIG) & BIT(31));\n\tif (s->is_en) {\n\t\ts->frame_count = DPU_REG_READ(c, INTF_FRAME_COUNT);\n\t\ts->line_count = DPU_REG_READ(c, INTF_LINE_COUNT);\n\t} else {\n\t\ts->line_count = 0;\n\t\ts->frame_count = 0;\n\t}\n}\n\nstatic u32 dpu_hw_intf_get_line_count(struct dpu_hw_intf *intf)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\n\tif (!intf)\n\t\treturn 0;\n\n\tc = &intf->hw;\n\n\treturn DPU_REG_READ(c, INTF_LINE_COUNT);\n}\n\nstatic void dpu_hw_intf_setup_misr(struct dpu_hw_intf *intf)\n{\n\tdpu_hw_setup_misr(&intf->hw, INTF_MISR_CTRL, 0x1);\n}\n\nstatic int dpu_hw_intf_collect_misr(struct dpu_hw_intf *intf, u32 *misr_value)\n{\n\treturn dpu_hw_collect_misr(&intf->hw, INTF_MISR_CTRL, INTF_MISR_SIGNATURE, misr_value);\n}\n\nstatic int dpu_hw_intf_enable_te(struct dpu_hw_intf *intf,\n\t\tstruct dpu_hw_tear_check *te)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tint cfg;\n\n\tif (!intf)\n\t\treturn -EINVAL;\n\n\tc = &intf->hw;\n\n\tcfg = BIT(19);  \n\tif (te->hw_vsync_mode)\n\t\tcfg |= BIT(20);\n\n\tcfg |= te->vsync_count;\n\n\tDPU_REG_WRITE(c, INTF_TEAR_SYNC_CONFIG_VSYNC, cfg);\n\tDPU_REG_WRITE(c, INTF_TEAR_SYNC_CONFIG_HEIGHT, te->sync_cfg_height);\n\tDPU_REG_WRITE(c, INTF_TEAR_VSYNC_INIT_VAL, te->vsync_init_val);\n\tDPU_REG_WRITE(c, INTF_TEAR_RD_PTR_IRQ, te->rd_ptr_irq);\n\tDPU_REG_WRITE(c, INTF_TEAR_START_POS, te->start_pos);\n\tDPU_REG_WRITE(c, INTF_TEAR_SYNC_THRESH,\n\t\t\t((te->sync_threshold_continue << 16) |\n\t\t\t te->sync_threshold_start));\n\tDPU_REG_WRITE(c, INTF_TEAR_SYNC_WRCOUNT,\n\t\t\t(te->start_pos + te->sync_threshold_start + 1));\n\n\tDPU_REG_WRITE(c, INTF_TEAR_TEAR_CHECK_EN, 1);\n\n\treturn 0;\n}\n\nstatic void dpu_hw_intf_setup_autorefresh_config(struct dpu_hw_intf *intf,\n\t\tu32 frame_count, bool enable)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 refresh_cfg;\n\n\tc = &intf->hw;\n\trefresh_cfg = DPU_REG_READ(c, INTF_TEAR_AUTOREFRESH_CONFIG);\n\tif (enable)\n\t\trefresh_cfg = BIT(31) | frame_count;\n\telse\n\t\trefresh_cfg &= ~BIT(31);\n\n\tDPU_REG_WRITE(c, INTF_TEAR_AUTOREFRESH_CONFIG, refresh_cfg);\n}\n\n \nstatic bool dpu_hw_intf_get_autorefresh_config(struct dpu_hw_intf *intf,\n\t\tu32 *frame_count)\n{\n\tu32 val = DPU_REG_READ(&intf->hw, INTF_TEAR_AUTOREFRESH_CONFIG);\n\n\tif (frame_count != NULL)\n\t\t*frame_count = val & 0xffff;\n\treturn !!((val & BIT(31)) >> 31);\n}\n\nstatic int dpu_hw_intf_disable_te(struct dpu_hw_intf *intf)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\n\tif (!intf)\n\t\treturn -EINVAL;\n\n\tc = &intf->hw;\n\tDPU_REG_WRITE(c, INTF_TEAR_TEAR_CHECK_EN, 0);\n\treturn 0;\n}\n\nstatic int dpu_hw_intf_connect_external_te(struct dpu_hw_intf *intf,\n\t\tbool enable_external_te)\n{\n\tstruct dpu_hw_blk_reg_map *c = &intf->hw;\n\tu32 cfg;\n\tint orig;\n\n\tif (!intf)\n\t\treturn -EINVAL;\n\n\tc = &intf->hw;\n\tcfg = DPU_REG_READ(c, INTF_TEAR_SYNC_CONFIG_VSYNC);\n\torig = (bool)(cfg & BIT(20));\n\tif (enable_external_te)\n\t\tcfg |= BIT(20);\n\telse\n\t\tcfg &= ~BIT(20);\n\tDPU_REG_WRITE(c, INTF_TEAR_SYNC_CONFIG_VSYNC, cfg);\n\ttrace_dpu_intf_connect_ext_te(intf->idx - INTF_0, cfg);\n\n\treturn orig;\n}\n\nstatic int dpu_hw_intf_get_vsync_info(struct dpu_hw_intf *intf,\n\t\tstruct dpu_hw_pp_vsync_info *info)\n{\n\tstruct dpu_hw_blk_reg_map *c = &intf->hw;\n\tu32 val;\n\n\tif (!intf || !info)\n\t\treturn -EINVAL;\n\n\tc = &intf->hw;\n\n\tval = DPU_REG_READ(c, INTF_TEAR_VSYNC_INIT_VAL);\n\tinfo->rd_ptr_init_val = val & 0xffff;\n\n\tval = DPU_REG_READ(c, INTF_TEAR_INT_COUNT_VAL);\n\tinfo->rd_ptr_frame_count = (val & 0xffff0000) >> 16;\n\tinfo->rd_ptr_line_count = val & 0xffff;\n\n\tval = DPU_REG_READ(c, INTF_TEAR_LINE_COUNT);\n\tinfo->wr_ptr_line_count = val & 0xffff;\n\n\tval = DPU_REG_READ(c, INTF_FRAME_COUNT);\n\tinfo->intf_frame_count = val;\n\n\treturn 0;\n}\n\nstatic void dpu_hw_intf_vsync_sel(struct dpu_hw_intf *intf,\n\t\tu32 vsync_source)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\n\tif (!intf)\n\t\treturn;\n\n\tc = &intf->hw;\n\n\tDPU_REG_WRITE(c, INTF_TEAR_MDP_VSYNC_SEL, (vsync_source & 0xf));\n}\n\nstatic void dpu_hw_intf_disable_autorefresh(struct dpu_hw_intf *intf,\n\t\t\t\t\t    uint32_t encoder_id, u16 vdisplay)\n{\n\tstruct dpu_hw_pp_vsync_info info;\n\tint trial = 0;\n\n\t \n\tif (!dpu_hw_intf_get_autorefresh_config(intf, NULL))\n\t\treturn;\n\n\t \n\n\tdpu_hw_intf_connect_external_te(intf, false);\n\tdpu_hw_intf_setup_autorefresh_config(intf, 0, false);\n\n\tdo {\n\t\tudelay(DPU_ENC_MAX_POLL_TIMEOUT_US);\n\t\tif ((trial * DPU_ENC_MAX_POLL_TIMEOUT_US)\n\t\t\t\t> (KICKOFF_TIMEOUT_MS * USEC_PER_MSEC)) {\n\t\t\tDPU_ERROR(\"enc%d intf%d disable autorefresh failed\\n\",\n\t\t\t\t  encoder_id, intf->idx - INTF_0);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrial++;\n\n\t\tdpu_hw_intf_get_vsync_info(intf, &info);\n\t} while (info.wr_ptr_line_count > 0 &&\n\t\t info.wr_ptr_line_count < vdisplay);\n\n\tdpu_hw_intf_connect_external_te(intf, true);\n\n\tDPU_DEBUG(\"enc%d intf%d disabled autorefresh\\n\",\n\t\t  encoder_id, intf->idx - INTF_0);\n\n}\n\nstatic void dpu_hw_intf_program_intf_cmd_cfg(struct dpu_hw_intf *ctx,\n\t\t\t\t\t     struct dpu_hw_intf_cmd_mode_cfg *cmd_mode_cfg)\n{\n\tu32 intf_cfg2 = DPU_REG_READ(&ctx->hw, INTF_CONFIG2);\n\n\tif (cmd_mode_cfg->data_compress)\n\t\tintf_cfg2 |= INTF_CFG2_DCE_DATA_COMPRESS;\n\n\tDPU_REG_WRITE(&ctx->hw, INTF_CONFIG2, intf_cfg2);\n}\n\nstatic void _setup_intf_ops(struct dpu_hw_intf_ops *ops,\n\t\tunsigned long cap, const struct dpu_mdss_version *mdss_rev)\n{\n\tops->setup_timing_gen = dpu_hw_intf_setup_timing_engine;\n\tops->setup_prg_fetch  = dpu_hw_intf_setup_prg_fetch;\n\tops->get_status = dpu_hw_intf_get_status;\n\tops->enable_timing = dpu_hw_intf_enable_timing_engine;\n\tops->get_line_count = dpu_hw_intf_get_line_count;\n\tif (cap & BIT(DPU_INTF_INPUT_CTRL))\n\t\tops->bind_pingpong_blk = dpu_hw_intf_bind_pingpong_blk;\n\tops->setup_misr = dpu_hw_intf_setup_misr;\n\tops->collect_misr = dpu_hw_intf_collect_misr;\n\n\tif (cap & BIT(DPU_INTF_TE)) {\n\t\tops->enable_tearcheck = dpu_hw_intf_enable_te;\n\t\tops->disable_tearcheck = dpu_hw_intf_disable_te;\n\t\tops->connect_external_te = dpu_hw_intf_connect_external_te;\n\t\tops->vsync_sel = dpu_hw_intf_vsync_sel;\n\t\tops->disable_autorefresh = dpu_hw_intf_disable_autorefresh;\n\t}\n\n\tif (mdss_rev->core_major_ver >= 7)\n\t\tops->program_intf_cmd_cfg = dpu_hw_intf_program_intf_cmd_cfg;\n}\n\nstruct dpu_hw_intf *dpu_hw_intf_init(const struct dpu_intf_cfg *cfg,\n\t\tvoid __iomem *addr, const struct dpu_mdss_version *mdss_rev)\n{\n\tstruct dpu_hw_intf *c;\n\n\tif (cfg->type == INTF_NONE) {\n\t\tDPU_DEBUG(\"Skip intf %d with type NONE\\n\", cfg->id - INTF_0);\n\t\treturn NULL;\n\t}\n\n\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tc->hw.blk_addr = addr + cfg->base;\n\tc->hw.log_mask = DPU_DBG_MASK_INTF;\n\n\t \n\tc->idx = cfg->id;\n\tc->cap = cfg;\n\t_setup_intf_ops(&c->ops, c->cap->features, mdss_rev);\n\n\treturn c;\n}\n\nvoid dpu_hw_intf_destroy(struct dpu_hw_intf *intf)\n{\n\tkfree(intf);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}