{
  "module_name": "dpu_formats.c",
  "hash_id": "af1058c912147ba386294a0760a202c30810b725980c4473a25db6cd57d4a9bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_formats.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm:%s:%d] \" fmt, __func__, __LINE__\n\n#include <uapi/drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n\n#include \"msm_media_info.h\"\n#include \"dpu_kms.h\"\n#include \"dpu_formats.h\"\n\n#define DPU_UBWC_META_MACRO_W_H\t\t16\n#define DPU_UBWC_META_BLOCK_SIZE\t256\n#define DPU_UBWC_PLANE_SIZE_ALIGNMENT\t4096\n\n#define DPU_TILE_HEIGHT_DEFAULT\t1\n#define DPU_TILE_HEIGHT_TILED\t4\n#define DPU_TILE_HEIGHT_UBWC\t4\n#define DPU_TILE_HEIGHT_NV12\t8\n\n#define DPU_MAX_IMG_WIDTH\t\t0x3FFF\n#define DPU_MAX_IMG_HEIGHT\t\t0x3FFF\n\n \n\n#define INTERLEAVED_RGB_FMT(fmt, a, r, g, b, e0, e1, e2, e3, uc, alpha,   \\\nbp, flg, fm, np)                                                          \\\n{                                                                         \\\n\t.base.pixel_format = DRM_FORMAT_ ## fmt,                          \\\n\t.fetch_planes = DPU_PLANE_INTERLEAVED,                            \\\n\t.alpha_enable = alpha,                                            \\\n\t.element = { (e0), (e1), (e2), (e3) },                            \\\n\t.bits = { g, b, r, a },                                           \\\n\t.chroma_sample = DPU_CHROMA_RGB,                                  \\\n\t.unpack_align_msb = 0,                                            \\\n\t.unpack_tight = 1,                                                \\\n\t.unpack_count = uc,                                               \\\n\t.bpp = bp,                                                        \\\n\t.fetch_mode = fm,                                                 \\\n\t.flag = {(flg)},                                                  \\\n\t.num_planes = np,                                                 \\\n\t.tile_height = DPU_TILE_HEIGHT_DEFAULT                            \\\n}\n\n#define INTERLEAVED_RGB_FMT_TILED(fmt, a, r, g, b, e0, e1, e2, e3, uc,    \\\nalpha, bp, flg, fm, np, th)                                               \\\n{                                                                         \\\n\t.base.pixel_format = DRM_FORMAT_ ## fmt,                          \\\n\t.fetch_planes = DPU_PLANE_INTERLEAVED,                            \\\n\t.alpha_enable = alpha,                                            \\\n\t.element = { (e0), (e1), (e2), (e3) },                            \\\n\t.bits = { g, b, r, a },                                           \\\n\t.chroma_sample = DPU_CHROMA_RGB,                                  \\\n\t.unpack_align_msb = 0,                                            \\\n\t.unpack_tight = 1,                                                \\\n\t.unpack_count = uc,                                               \\\n\t.bpp = bp,                                                        \\\n\t.fetch_mode = fm,                                                 \\\n\t.flag = {(flg)},                                                  \\\n\t.num_planes = np,                                                 \\\n\t.tile_height = th                                                 \\\n}\n\n\n#define INTERLEAVED_YUV_FMT(fmt, a, r, g, b, e0, e1, e2, e3,              \\\nalpha, chroma, count, bp, flg, fm, np)                                    \\\n{                                                                         \\\n\t.base.pixel_format = DRM_FORMAT_ ## fmt,                          \\\n\t.fetch_planes = DPU_PLANE_INTERLEAVED,                            \\\n\t.alpha_enable = alpha,                                            \\\n\t.element = { (e0), (e1), (e2), (e3)},                             \\\n\t.bits = { g, b, r, a },                                           \\\n\t.chroma_sample = chroma,                                          \\\n\t.unpack_align_msb = 0,                                            \\\n\t.unpack_tight = 1,                                                \\\n\t.unpack_count = count,                                            \\\n\t.bpp = bp,                                                        \\\n\t.fetch_mode = fm,                                                 \\\n\t.flag = {(flg)},                                                  \\\n\t.num_planes = np,                                                 \\\n\t.tile_height = DPU_TILE_HEIGHT_DEFAULT                            \\\n}\n\n#define PSEUDO_YUV_FMT(fmt, a, r, g, b, e0, e1, chroma, flg, fm, np)      \\\n{                                                                         \\\n\t.base.pixel_format = DRM_FORMAT_ ## fmt,                          \\\n\t.fetch_planes = DPU_PLANE_PSEUDO_PLANAR,                          \\\n\t.alpha_enable = false,                                            \\\n\t.element = { (e0), (e1), 0, 0 },                                  \\\n\t.bits = { g, b, r, a },                                           \\\n\t.chroma_sample = chroma,                                          \\\n\t.unpack_align_msb = 0,                                            \\\n\t.unpack_tight = 1,                                                \\\n\t.unpack_count = 2,                                                \\\n\t.bpp = 2,                                                         \\\n\t.fetch_mode = fm,                                                 \\\n\t.flag = {(flg)},                                                  \\\n\t.num_planes = np,                                                 \\\n\t.tile_height = DPU_TILE_HEIGHT_DEFAULT                            \\\n}\n\n#define PSEUDO_YUV_FMT_TILED(fmt, a, r, g, b, e0, e1, chroma,             \\\nflg, fm, np, th)                                                          \\\n{                                                                         \\\n\t.base.pixel_format = DRM_FORMAT_ ## fmt,                          \\\n\t.fetch_planes = DPU_PLANE_PSEUDO_PLANAR,                          \\\n\t.alpha_enable = false,                                            \\\n\t.element = { (e0), (e1), 0, 0 },                                  \\\n\t.bits = { g, b, r, a },                                           \\\n\t.chroma_sample = chroma,                                          \\\n\t.unpack_align_msb = 0,                                            \\\n\t.unpack_tight = 1,                                                \\\n\t.unpack_count = 2,                                                \\\n\t.bpp = 2,                                                         \\\n\t.fetch_mode = fm,                                                 \\\n\t.flag = {(flg)},                                                  \\\n\t.num_planes = np,                                                 \\\n\t.tile_height = th                                                 \\\n}\n\n#define PSEUDO_YUV_FMT_LOOSE(fmt, a, r, g, b, e0, e1, chroma, flg, fm, np)\\\n{                                                                         \\\n\t.base.pixel_format = DRM_FORMAT_ ## fmt,                          \\\n\t.fetch_planes = DPU_PLANE_PSEUDO_PLANAR,                          \\\n\t.alpha_enable = false,                                            \\\n\t.element = { (e0), (e1), 0, 0 },                                  \\\n\t.bits = { g, b, r, a },                                           \\\n\t.chroma_sample = chroma,                                          \\\n\t.unpack_align_msb = 1,                                            \\\n\t.unpack_tight = 0,                                                \\\n\t.unpack_count = 2,                                                \\\n\t.bpp = 2,                                                         \\\n\t.fetch_mode = fm,                                                 \\\n\t.flag = {(flg)},                                                  \\\n\t.num_planes = np,                                                 \\\n\t.tile_height = DPU_TILE_HEIGHT_DEFAULT                            \\\n}\n\n#define PSEUDO_YUV_FMT_LOOSE_TILED(fmt, a, r, g, b, e0, e1, chroma,       \\\nflg, fm, np, th)                                                          \\\n{                                                                         \\\n\t.base.pixel_format = DRM_FORMAT_ ## fmt,                          \\\n\t.fetch_planes = DPU_PLANE_PSEUDO_PLANAR,                          \\\n\t.alpha_enable = false,                                            \\\n\t.element = { (e0), (e1), 0, 0 },                                  \\\n\t.bits = { g, b, r, a },                                           \\\n\t.chroma_sample = chroma,                                          \\\n\t.unpack_align_msb = 1,                                            \\\n\t.unpack_tight = 0,                                                \\\n\t.unpack_count = 2,                                                \\\n\t.bpp = 2,                                                         \\\n\t.fetch_mode = fm,                                                 \\\n\t.flag = {(flg)},                                                  \\\n\t.num_planes = np,                                                 \\\n\t.tile_height = th                                                 \\\n}\n\n\n#define PLANAR_YUV_FMT(fmt, a, r, g, b, e0, e1, e2, alpha, chroma, bp,    \\\nflg, fm, np)                                                      \\\n{                                                                         \\\n\t.base.pixel_format = DRM_FORMAT_ ## fmt,                          \\\n\t.fetch_planes = DPU_PLANE_PLANAR,                                 \\\n\t.alpha_enable = alpha,                                            \\\n\t.element = { (e0), (e1), (e2), 0 },                               \\\n\t.bits = { g, b, r, a },                                           \\\n\t.chroma_sample = chroma,                                          \\\n\t.unpack_align_msb = 0,                                            \\\n\t.unpack_tight = 1,                                                \\\n\t.unpack_count = 1,                                                \\\n\t.bpp = bp,                                                        \\\n\t.fetch_mode = fm,                                                 \\\n\t.flag = {(flg)},                                                  \\\n\t.num_planes = np,                                                 \\\n\t.tile_height = DPU_TILE_HEIGHT_DEFAULT                            \\\n}\n\n \nstruct dpu_media_color_map {\n\tuint32_t format;\n\tuint32_t color;\n};\n\nstatic const struct dpu_format dpu_format_map[] = {\n\tINTERLEAVED_RGB_FMT(ARGB8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C0_G_Y, C2_R_Cr, C3_ALPHA, 4,\n\t\ttrue, 4, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(ABGR8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\ttrue, 4, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(XBGR8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\tfalse, 4, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(RGBA8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC3_ALPHA, C1_B_Cb, C0_G_Y, C2_R_Cr, 4,\n\t\ttrue, 4, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(BGRA8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC3_ALPHA, C2_R_Cr, C0_G_Y, C1_B_Cb, 4,\n\t\ttrue, 4, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(BGRX8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC3_ALPHA, C2_R_Cr, C0_G_Y, C1_B_Cb, 4,\n\t\tfalse, 4, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(XRGB8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C0_G_Y, C2_R_Cr, C3_ALPHA, 4,\n\t\tfalse, 4, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(RGBX8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC3_ALPHA, C1_B_Cb, C0_G_Y, C2_R_Cr, 4,\n\t\tfalse, 4, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(RGB888,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C0_G_Y, C2_R_Cr, 0, 3,\n\t\tfalse, 3, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(BGR888,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, 0, 3,\n\t\tfalse, 3, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(RGB565,\n\t\t0, COLOR_5BIT, COLOR_6BIT, COLOR_5BIT,\n\t\tC1_B_Cb, C0_G_Y, C2_R_Cr, 0, 3,\n\t\tfalse, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(BGR565,\n\t\t0, COLOR_5BIT, COLOR_6BIT, COLOR_5BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, 0, 3,\n\t\tfalse, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(ARGB1555,\n\t\tCOLOR_ALPHA_1BIT, COLOR_5BIT, COLOR_5BIT, COLOR_5BIT,\n\t\tC1_B_Cb, C0_G_Y, C2_R_Cr, C3_ALPHA, 4,\n\t\ttrue, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(ABGR1555,\n\t\tCOLOR_ALPHA_1BIT, COLOR_5BIT, COLOR_5BIT, COLOR_5BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\ttrue, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(RGBA5551,\n\t\tCOLOR_ALPHA_1BIT, COLOR_5BIT, COLOR_5BIT, COLOR_5BIT,\n\t\tC3_ALPHA, C1_B_Cb, C0_G_Y, C2_R_Cr, 4,\n\t\ttrue, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(BGRA5551,\n\t\tCOLOR_ALPHA_1BIT, COLOR_5BIT, COLOR_5BIT, COLOR_5BIT,\n\t\tC3_ALPHA, C2_R_Cr, C0_G_Y, C1_B_Cb, 4,\n\t\ttrue, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(XRGB1555,\n\t\tCOLOR_ALPHA_1BIT, COLOR_5BIT, COLOR_5BIT, COLOR_5BIT,\n\t\tC1_B_Cb, C0_G_Y, C2_R_Cr, C3_ALPHA, 4,\n\t\tfalse, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(XBGR1555,\n\t\tCOLOR_ALPHA_1BIT, COLOR_5BIT, COLOR_5BIT, COLOR_5BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\tfalse, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(RGBX5551,\n\t\tCOLOR_ALPHA_1BIT, COLOR_5BIT, COLOR_5BIT, COLOR_5BIT,\n\t\tC3_ALPHA, C1_B_Cb, C0_G_Y, C2_R_Cr, 4,\n\t\tfalse, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(BGRX5551,\n\t\tCOLOR_ALPHA_1BIT, COLOR_5BIT, COLOR_5BIT, COLOR_5BIT,\n\t\tC3_ALPHA, C2_R_Cr, C0_G_Y, C1_B_Cb, 4,\n\t\tfalse, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(ARGB4444,\n\t\tCOLOR_ALPHA_4BIT, COLOR_4BIT, COLOR_4BIT, COLOR_4BIT,\n\t\tC1_B_Cb, C0_G_Y, C2_R_Cr, C3_ALPHA, 4,\n\t\ttrue, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(ABGR4444,\n\t\tCOLOR_ALPHA_4BIT, COLOR_4BIT, COLOR_4BIT, COLOR_4BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\ttrue, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(RGBA4444,\n\t\tCOLOR_ALPHA_4BIT, COLOR_4BIT, COLOR_4BIT, COLOR_4BIT,\n\t\tC3_ALPHA, C1_B_Cb, C0_G_Y, C2_R_Cr, 4,\n\t\ttrue, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(BGRA4444,\n\t\tCOLOR_ALPHA_4BIT, COLOR_4BIT, COLOR_4BIT, COLOR_4BIT,\n\t\tC3_ALPHA, C2_R_Cr, C0_G_Y, C1_B_Cb, 4,\n\t\ttrue, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(XRGB4444,\n\t\tCOLOR_ALPHA_4BIT, COLOR_4BIT, COLOR_4BIT, COLOR_4BIT,\n\t\tC1_B_Cb, C0_G_Y, C2_R_Cr, C3_ALPHA, 4,\n\t\tfalse, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(XBGR4444,\n\t\tCOLOR_ALPHA_4BIT, COLOR_4BIT, COLOR_4BIT, COLOR_4BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\tfalse, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(RGBX4444,\n\t\tCOLOR_ALPHA_4BIT, COLOR_4BIT, COLOR_4BIT, COLOR_4BIT,\n\t\tC3_ALPHA, C1_B_Cb, C0_G_Y, C2_R_Cr, 4,\n\t\tfalse, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(BGRX4444,\n\t\tCOLOR_ALPHA_4BIT, COLOR_4BIT, COLOR_4BIT, COLOR_4BIT,\n\t\tC3_ALPHA, C2_R_Cr, C0_G_Y, C1_B_Cb, 4,\n\t\tfalse, 2, 0,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(BGRA1010102,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC3_ALPHA, C2_R_Cr, C0_G_Y, C1_B_Cb, 4,\n\t\ttrue, 4, DPU_FORMAT_FLAG_DX,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(RGBA1010102,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC3_ALPHA, C1_B_Cb, C0_G_Y, C2_R_Cr, 4,\n\t\ttrue, 4, DPU_FORMAT_FLAG_DX,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(ABGR2101010,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\ttrue, 4, DPU_FORMAT_FLAG_DX,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(ARGB2101010,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C0_G_Y, C2_R_Cr, C3_ALPHA, 4,\n\t\ttrue, 4, DPU_FORMAT_FLAG_DX,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(XRGB2101010,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C0_G_Y, C2_R_Cr, C3_ALPHA, 4,\n\t\tfalse, 4, DPU_FORMAT_FLAG_DX,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(BGRX1010102,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC3_ALPHA, C2_R_Cr, C0_G_Y, C1_B_Cb, 4,\n\t\tfalse, 4, DPU_FORMAT_FLAG_DX,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(XBGR2101010,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\tfalse, 4, DPU_FORMAT_FLAG_DX,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tINTERLEAVED_RGB_FMT(RGBX1010102,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC3_ALPHA, C1_B_Cb, C0_G_Y, C2_R_Cr, 4,\n\t\tfalse, 4, DPU_FORMAT_FLAG_DX,\n\t\tDPU_FETCH_LINEAR, 1),\n\n\tPSEUDO_YUV_FMT(NV12,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C2_R_Cr,\n\t\tDPU_CHROMA_420, DPU_FORMAT_FLAG_YUV,\n\t\tDPU_FETCH_LINEAR, 2),\n\n\tPSEUDO_YUV_FMT(NV21,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C1_B_Cb,\n\t\tDPU_CHROMA_420, DPU_FORMAT_FLAG_YUV,\n\t\tDPU_FETCH_LINEAR, 2),\n\n\tPSEUDO_YUV_FMT(NV16,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C2_R_Cr,\n\t\tDPU_CHROMA_H2V1, DPU_FORMAT_FLAG_YUV,\n\t\tDPU_FETCH_LINEAR, 2),\n\n\tPSEUDO_YUV_FMT(NV61,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C1_B_Cb,\n\t\tDPU_CHROMA_H2V1, DPU_FORMAT_FLAG_YUV,\n\t\tDPU_FETCH_LINEAR, 2),\n\n\tPSEUDO_YUV_FMT_LOOSE(P010,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C2_R_Cr,\n\t\tDPU_CHROMA_420, DPU_FORMAT_FLAG_DX | DPU_FORMAT_FLAG_YUV,\n\t\tDPU_FETCH_LINEAR, 2),\n\n\tINTERLEAVED_YUV_FMT(VYUY,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C0_G_Y,\n\t\tfalse, DPU_CHROMA_H2V1, 4, 2, DPU_FORMAT_FLAG_YUV,\n\t\tDPU_FETCH_LINEAR, 2),\n\n\tINTERLEAVED_YUV_FMT(UYVY,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C0_G_Y, C2_R_Cr, C0_G_Y,\n\t\tfalse, DPU_CHROMA_H2V1, 4, 2, DPU_FORMAT_FLAG_YUV,\n\t\tDPU_FETCH_LINEAR, 2),\n\n\tINTERLEAVED_YUV_FMT(YUYV,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC0_G_Y, C1_B_Cb, C0_G_Y, C2_R_Cr,\n\t\tfalse, DPU_CHROMA_H2V1, 4, 2, DPU_FORMAT_FLAG_YUV,\n\t\tDPU_FETCH_LINEAR, 2),\n\n\tINTERLEAVED_YUV_FMT(YVYU,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC0_G_Y, C2_R_Cr, C0_G_Y, C1_B_Cb,\n\t\tfalse, DPU_CHROMA_H2V1, 4, 2, DPU_FORMAT_FLAG_YUV,\n\t\tDPU_FETCH_LINEAR, 2),\n\n\tPLANAR_YUV_FMT(YUV420,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C1_B_Cb, C0_G_Y,\n\t\tfalse, DPU_CHROMA_420, 1, DPU_FORMAT_FLAG_YUV,\n\t\tDPU_FETCH_LINEAR, 3),\n\n\tPLANAR_YUV_FMT(YVU420,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C2_R_Cr, C0_G_Y,\n\t\tfalse, DPU_CHROMA_420, 1, DPU_FORMAT_FLAG_YUV,\n\t\tDPU_FETCH_LINEAR, 3),\n};\n\n \nstatic const struct dpu_format dpu_format_map_ubwc[] = {\n\tINTERLEAVED_RGB_FMT_TILED(BGR565,\n\t\t0, COLOR_5BIT, COLOR_6BIT, COLOR_5BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, 0, 3,\n\t\tfalse, 2, DPU_FORMAT_FLAG_COMPRESSED,\n\t\tDPU_FETCH_UBWC, 2, DPU_TILE_HEIGHT_UBWC),\n\n\tINTERLEAVED_RGB_FMT_TILED(ABGR8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\ttrue, 4, DPU_FORMAT_FLAG_COMPRESSED,\n\t\tDPU_FETCH_UBWC, 2, DPU_TILE_HEIGHT_UBWC),\n\n\t \n\tINTERLEAVED_RGB_FMT_TILED(ARGB8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\ttrue, 4, DPU_FORMAT_FLAG_COMPRESSED,\n\t\tDPU_FETCH_UBWC, 2, DPU_TILE_HEIGHT_UBWC),\n\n\tINTERLEAVED_RGB_FMT_TILED(XBGR8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\tfalse, 4, DPU_FORMAT_FLAG_COMPRESSED,\n\t\tDPU_FETCH_UBWC, 2, DPU_TILE_HEIGHT_UBWC),\n\n\tINTERLEAVED_RGB_FMT_TILED(XRGB8888,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\tfalse, 4, DPU_FORMAT_FLAG_COMPRESSED,\n\t\tDPU_FETCH_UBWC, 2, DPU_TILE_HEIGHT_UBWC),\n\n\tINTERLEAVED_RGB_FMT_TILED(ABGR2101010,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\ttrue, 4, DPU_FORMAT_FLAG_DX | DPU_FORMAT_FLAG_COMPRESSED,\n\t\tDPU_FETCH_UBWC, 2, DPU_TILE_HEIGHT_UBWC),\n\n\tINTERLEAVED_RGB_FMT_TILED(XBGR2101010,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\ttrue, 4, DPU_FORMAT_FLAG_DX | DPU_FORMAT_FLAG_COMPRESSED,\n\t\tDPU_FETCH_UBWC, 2, DPU_TILE_HEIGHT_UBWC),\n\n\tINTERLEAVED_RGB_FMT_TILED(XRGB2101010,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\ttrue, 4, DPU_FORMAT_FLAG_DX | DPU_FORMAT_FLAG_COMPRESSED,\n\t\tDPU_FETCH_UBWC, 2, DPU_TILE_HEIGHT_UBWC),\n\n\t \n\tINTERLEAVED_RGB_FMT_TILED(ARGB2101010,\n\t\tCOLOR_8BIT, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC2_R_Cr, C0_G_Y, C1_B_Cb, C3_ALPHA, 4,\n\t\ttrue, 4, DPU_FORMAT_FLAG_DX | DPU_FORMAT_FLAG_COMPRESSED,\n\t\tDPU_FETCH_UBWC, 2, DPU_TILE_HEIGHT_UBWC),\n\n\tPSEUDO_YUV_FMT_TILED(NV12,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C2_R_Cr,\n\t\tDPU_CHROMA_420, DPU_FORMAT_FLAG_YUV |\n\t\t\t\tDPU_FORMAT_FLAG_COMPRESSED,\n\t\tDPU_FETCH_UBWC, 4, DPU_TILE_HEIGHT_NV12),\n\n\tPSEUDO_YUV_FMT_TILED(P010,\n\t\t0, COLOR_8BIT, COLOR_8BIT, COLOR_8BIT,\n\t\tC1_B_Cb, C2_R_Cr,\n\t\tDPU_CHROMA_420, DPU_FORMAT_FLAG_DX |\n\t\t\t\tDPU_FORMAT_FLAG_YUV |\n\t\t\t\tDPU_FORMAT_FLAG_COMPRESSED,\n\t\tDPU_FETCH_UBWC, 4, DPU_TILE_HEIGHT_UBWC),\n};\n\n \nstatic void _dpu_get_v_h_subsample_rate(\n\tenum dpu_chroma_samp_type chroma_sample,\n\tuint32_t *v_sample,\n\tuint32_t *h_sample)\n{\n\tif (!v_sample || !h_sample)\n\t\treturn;\n\n\tswitch (chroma_sample) {\n\tcase DPU_CHROMA_H2V1:\n\t\t*v_sample = 1;\n\t\t*h_sample = 2;\n\t\tbreak;\n\tcase DPU_CHROMA_H1V2:\n\t\t*v_sample = 2;\n\t\t*h_sample = 1;\n\t\tbreak;\n\tcase DPU_CHROMA_420:\n\t\t*v_sample = 2;\n\t\t*h_sample = 2;\n\t\tbreak;\n\tdefault:\n\t\t*v_sample = 1;\n\t\t*h_sample = 1;\n\t\tbreak;\n\t}\n}\n\nstatic int _dpu_format_get_media_color_ubwc(const struct dpu_format *fmt)\n{\n\tstatic const struct dpu_media_color_map dpu_media_ubwc_map[] = {\n\t\t{DRM_FORMAT_ABGR8888, COLOR_FMT_RGBA8888_UBWC},\n\t\t{DRM_FORMAT_ARGB8888, COLOR_FMT_RGBA8888_UBWC},\n\t\t{DRM_FORMAT_XBGR8888, COLOR_FMT_RGBA8888_UBWC},\n\t\t{DRM_FORMAT_XRGB8888, COLOR_FMT_RGBA8888_UBWC},\n\t\t{DRM_FORMAT_ABGR2101010, COLOR_FMT_RGBA1010102_UBWC},\n\t\t{DRM_FORMAT_ARGB2101010, COLOR_FMT_RGBA1010102_UBWC},\n\t\t{DRM_FORMAT_XRGB2101010, COLOR_FMT_RGBA1010102_UBWC},\n\t\t{DRM_FORMAT_XBGR2101010, COLOR_FMT_RGBA1010102_UBWC},\n\t\t{DRM_FORMAT_BGR565, COLOR_FMT_RGB565_UBWC},\n\t};\n\tint color_fmt = -1;\n\tint i;\n\n\tif (fmt->base.pixel_format == DRM_FORMAT_NV12 ||\n\t    fmt->base.pixel_format == DRM_FORMAT_P010) {\n\t\tif (DPU_FORMAT_IS_DX(fmt)) {\n\t\t\tif (fmt->unpack_tight)\n\t\t\t\tcolor_fmt = COLOR_FMT_NV12_BPP10_UBWC;\n\t\t\telse\n\t\t\t\tcolor_fmt = COLOR_FMT_P010_UBWC;\n\t\t} else\n\t\t\tcolor_fmt = COLOR_FMT_NV12_UBWC;\n\t\treturn color_fmt;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(dpu_media_ubwc_map); ++i)\n\t\tif (fmt->base.pixel_format == dpu_media_ubwc_map[i].format) {\n\t\t\tcolor_fmt = dpu_media_ubwc_map[i].color;\n\t\t\tbreak;\n\t\t}\n\treturn color_fmt;\n}\n\nstatic int _dpu_format_get_plane_sizes_ubwc(\n\t\tconst struct dpu_format *fmt,\n\t\tconst uint32_t width,\n\t\tconst uint32_t height,\n\t\tstruct dpu_hw_fmt_layout *layout)\n{\n\tint i;\n\tint color;\n\tbool meta = DPU_FORMAT_IS_UBWC(fmt);\n\n\tmemset(layout, 0, sizeof(struct dpu_hw_fmt_layout));\n\tlayout->format = fmt;\n\tlayout->width = width;\n\tlayout->height = height;\n\tlayout->num_planes = fmt->num_planes;\n\n\tcolor = _dpu_format_get_media_color_ubwc(fmt);\n\tif (color < 0) {\n\t\tDRM_ERROR(\"UBWC format not supported for fmt: %4.4s\\n\",\n\t\t\t(char *)&fmt->base.pixel_format);\n\t\treturn -EINVAL;\n\t}\n\n\tif (DPU_FORMAT_IS_YUV(layout->format)) {\n\t\tuint32_t y_sclines, uv_sclines;\n\t\tuint32_t y_meta_scanlines = 0;\n\t\tuint32_t uv_meta_scanlines = 0;\n\n\t\tlayout->num_planes = 2;\n\t\tlayout->plane_pitch[0] = VENUS_Y_STRIDE(color, width);\n\t\ty_sclines = VENUS_Y_SCANLINES(color, height);\n\t\tlayout->plane_size[0] = MSM_MEDIA_ALIGN(layout->plane_pitch[0] *\n\t\t\ty_sclines, DPU_UBWC_PLANE_SIZE_ALIGNMENT);\n\n\t\tlayout->plane_pitch[1] = VENUS_UV_STRIDE(color, width);\n\t\tuv_sclines = VENUS_UV_SCANLINES(color, height);\n\t\tlayout->plane_size[1] = MSM_MEDIA_ALIGN(layout->plane_pitch[1] *\n\t\t\tuv_sclines, DPU_UBWC_PLANE_SIZE_ALIGNMENT);\n\n\t\tif (!meta)\n\t\t\tgoto done;\n\n\t\tlayout->num_planes += 2;\n\t\tlayout->plane_pitch[2] = VENUS_Y_META_STRIDE(color, width);\n\t\ty_meta_scanlines = VENUS_Y_META_SCANLINES(color, height);\n\t\tlayout->plane_size[2] = MSM_MEDIA_ALIGN(layout->plane_pitch[2] *\n\t\t\ty_meta_scanlines, DPU_UBWC_PLANE_SIZE_ALIGNMENT);\n\n\t\tlayout->plane_pitch[3] = VENUS_UV_META_STRIDE(color, width);\n\t\tuv_meta_scanlines = VENUS_UV_META_SCANLINES(color, height);\n\t\tlayout->plane_size[3] = MSM_MEDIA_ALIGN(layout->plane_pitch[3] *\n\t\t\tuv_meta_scanlines, DPU_UBWC_PLANE_SIZE_ALIGNMENT);\n\n\t} else {\n\t\tuint32_t rgb_scanlines, rgb_meta_scanlines;\n\n\t\tlayout->num_planes = 1;\n\n\t\tlayout->plane_pitch[0] = VENUS_RGB_STRIDE(color, width);\n\t\trgb_scanlines = VENUS_RGB_SCANLINES(color, height);\n\t\tlayout->plane_size[0] = MSM_MEDIA_ALIGN(layout->plane_pitch[0] *\n\t\t\trgb_scanlines, DPU_UBWC_PLANE_SIZE_ALIGNMENT);\n\n\t\tif (!meta)\n\t\t\tgoto done;\n\t\tlayout->num_planes += 2;\n\t\tlayout->plane_pitch[2] = VENUS_RGB_META_STRIDE(color, width);\n\t\trgb_meta_scanlines = VENUS_RGB_META_SCANLINES(color, height);\n\t\tlayout->plane_size[2] = MSM_MEDIA_ALIGN(layout->plane_pitch[2] *\n\t\t\trgb_meta_scanlines, DPU_UBWC_PLANE_SIZE_ALIGNMENT);\n\t}\n\ndone:\n\tfor (i = 0; i < DPU_MAX_PLANES; i++)\n\t\tlayout->total_size += layout->plane_size[i];\n\n\treturn 0;\n}\n\nstatic int _dpu_format_get_plane_sizes_linear(\n\t\tconst struct dpu_format *fmt,\n\t\tconst uint32_t width,\n\t\tconst uint32_t height,\n\t\tstruct dpu_hw_fmt_layout *layout,\n\t\tconst uint32_t *pitches)\n{\n\tint i;\n\n\tmemset(layout, 0, sizeof(struct dpu_hw_fmt_layout));\n\tlayout->format = fmt;\n\tlayout->width = width;\n\tlayout->height = height;\n\tlayout->num_planes = fmt->num_planes;\n\n\t \n\tif (fmt->fetch_planes == DPU_PLANE_INTERLEAVED) {\n\t\tlayout->num_planes = 1;\n\t\tlayout->plane_size[0] = width * height * layout->format->bpp;\n\t\tlayout->plane_pitch[0] = width * layout->format->bpp;\n\t} else {\n\t\tuint32_t v_subsample, h_subsample;\n\t\tuint32_t chroma_samp;\n\t\tuint32_t bpp = 1;\n\n\t\tchroma_samp = fmt->chroma_sample;\n\t\t_dpu_get_v_h_subsample_rate(chroma_samp, &v_subsample,\n\t\t\t\t&h_subsample);\n\n\t\tif (width % h_subsample || height % v_subsample) {\n\t\t\tDRM_ERROR(\"mismatch in subsample vs dimensions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((fmt->base.pixel_format == DRM_FORMAT_NV12) &&\n\t\t\t(DPU_FORMAT_IS_DX(fmt)))\n\t\t\tbpp = 2;\n\t\tlayout->plane_pitch[0] = width * bpp;\n\t\tlayout->plane_pitch[1] = layout->plane_pitch[0] / h_subsample;\n\t\tlayout->plane_size[0] = layout->plane_pitch[0] * height;\n\t\tlayout->plane_size[1] = layout->plane_pitch[1] *\n\t\t\t\t(height / v_subsample);\n\n\t\tif (fmt->fetch_planes == DPU_PLANE_PSEUDO_PLANAR) {\n\t\t\tlayout->num_planes = 2;\n\t\t\tlayout->plane_size[1] *= 2;\n\t\t\tlayout->plane_pitch[1] *= 2;\n\t\t} else {\n\t\t\t \n\t\t\tlayout->num_planes = 3;\n\t\t\tlayout->plane_size[2] = layout->plane_size[1];\n\t\t\tlayout->plane_pitch[2] = layout->plane_pitch[1];\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < layout->num_planes && i < DPU_MAX_PLANES; ++i) {\n\t\tif (pitches && layout->plane_pitch[i] < pitches[i])\n\t\t\tlayout->plane_pitch[i] = pitches[i];\n\t}\n\n\tfor (i = 0; i < DPU_MAX_PLANES; i++)\n\t\tlayout->total_size += layout->plane_size[i];\n\n\treturn 0;\n}\n\nstatic int dpu_format_get_plane_sizes(\n\t\tconst struct dpu_format *fmt,\n\t\tconst uint32_t w,\n\t\tconst uint32_t h,\n\t\tstruct dpu_hw_fmt_layout *layout,\n\t\tconst uint32_t *pitches)\n{\n\tif (!layout || !fmt) {\n\t\tDRM_ERROR(\"invalid pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((w > DPU_MAX_IMG_WIDTH) || (h > DPU_MAX_IMG_HEIGHT)) {\n\t\tDRM_ERROR(\"image dimensions outside max range\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tif (DPU_FORMAT_IS_UBWC(fmt) || DPU_FORMAT_IS_TILE(fmt))\n\t\treturn _dpu_format_get_plane_sizes_ubwc(fmt, w, h, layout);\n\n\treturn _dpu_format_get_plane_sizes_linear(fmt, w, h, layout, pitches);\n}\n\nstatic int _dpu_format_populate_addrs_ubwc(\n\t\tstruct msm_gem_address_space *aspace,\n\t\tstruct drm_framebuffer *fb,\n\t\tstruct dpu_hw_fmt_layout *layout)\n{\n\tuint32_t base_addr = 0;\n\tbool meta;\n\n\tif (!fb || !layout) {\n\t\tDRM_ERROR(\"invalid pointers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (aspace)\n\t\tbase_addr = msm_framebuffer_iova(fb, aspace, 0);\n\tif (!base_addr) {\n\t\tDRM_ERROR(\"failed to retrieve base addr\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tmeta = DPU_FORMAT_IS_UBWC(layout->format);\n\n\t \n\tif (DPU_FORMAT_IS_YUV(layout->format)) {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\tlayout->plane_addr[0] = base_addr + layout->plane_size[2];\n\n\t\t \n\t\tlayout->plane_addr[1] = base_addr + layout->plane_size[0]\n\t\t\t+ layout->plane_size[2] + layout->plane_size[3];\n\n\t\tif (!meta)\n\t\t\treturn 0;\n\n\t\t \n\t\tlayout->plane_addr[2] = base_addr;\n\n\t\t \n\t\tlayout->plane_addr[3] = base_addr + layout->plane_size[0]\n\t\t\t+ layout->plane_size[2];\n\n\t} else {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\n\t\tlayout->plane_addr[0] = base_addr + layout->plane_size[2];\n\t\tlayout->plane_addr[1] = 0;\n\n\t\tif (!meta)\n\t\t\treturn 0;\n\n\t\tlayout->plane_addr[2] = base_addr;\n\t\tlayout->plane_addr[3] = 0;\n\t}\n\treturn 0;\n}\n\nstatic int _dpu_format_populate_addrs_linear(\n\t\tstruct msm_gem_address_space *aspace,\n\t\tstruct drm_framebuffer *fb,\n\t\tstruct dpu_hw_fmt_layout *layout)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < layout->num_planes; ++i) {\n\t\tif (layout->plane_pitch[i] > fb->pitches[i]) {\n\t\t\tDRM_ERROR(\"plane %u expected pitch %u, fb %u\\n\",\n\t\t\t\ti, layout->plane_pitch[i], fb->pitches[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < layout->num_planes; ++i) {\n\t\tif (aspace)\n\t\t\tlayout->plane_addr[i] =\n\t\t\t\tmsm_framebuffer_iova(fb, aspace, i);\n\t\tif (!layout->plane_addr[i]) {\n\t\t\tDRM_ERROR(\"failed to retrieve base addr\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint dpu_format_populate_layout(\n\t\tstruct msm_gem_address_space *aspace,\n\t\tstruct drm_framebuffer *fb,\n\t\tstruct dpu_hw_fmt_layout *layout)\n{\n\tint ret;\n\n\tif (!fb || !layout) {\n\t\tDRM_ERROR(\"invalid arguments\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((fb->width > DPU_MAX_IMG_WIDTH) ||\n\t\t\t(fb->height > DPU_MAX_IMG_HEIGHT)) {\n\t\tDRM_ERROR(\"image dimensions outside max range\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tlayout->format = to_dpu_format(msm_framebuffer_format(fb));\n\n\t \n\tret = dpu_format_get_plane_sizes(layout->format, fb->width, fb->height,\n\t\t\tlayout, fb->pitches);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (DPU_FORMAT_IS_UBWC(layout->format) ||\n\t\t\tDPU_FORMAT_IS_TILE(layout->format))\n\t\tret = _dpu_format_populate_addrs_ubwc(aspace, fb, layout);\n\telse\n\t\tret = _dpu_format_populate_addrs_linear(aspace, fb, layout);\n\n\treturn ret;\n}\n\nint dpu_format_check_modified_format(\n\t\tconst struct msm_kms *kms,\n\t\tconst struct msm_format *msm_fmt,\n\t\tconst struct drm_mode_fb_cmd2 *cmd,\n\t\tstruct drm_gem_object **bos)\n{\n\tconst struct drm_format_info *info;\n\tconst struct dpu_format *fmt;\n\tstruct dpu_hw_fmt_layout layout;\n\tuint32_t bos_total_size = 0;\n\tint ret, i;\n\n\tif (!msm_fmt || !cmd || !bos) {\n\t\tDRM_ERROR(\"invalid arguments\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfmt = to_dpu_format(msm_fmt);\n\tinfo = drm_format_info(fmt->base.pixel_format);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tret = dpu_format_get_plane_sizes(fmt, cmd->width, cmd->height,\n\t\t\t&layout, cmd->pitches);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < info->num_planes; i++) {\n\t\tif (!bos[i]) {\n\t\t\tDRM_ERROR(\"invalid handle for plane %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((i == 0) || (bos[i] != bos[0]))\n\t\t\tbos_total_size += bos[i]->size;\n\t}\n\n\tif (bos_total_size < layout.total_size) {\n\t\tDRM_ERROR(\"buffers total size too small %u expected %u\\n\",\n\t\t\t\tbos_total_size, layout.total_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nconst struct dpu_format *dpu_get_dpu_format_ext(\n\t\tconst uint32_t format,\n\t\tconst uint64_t modifier)\n{\n\tuint32_t i = 0;\n\tconst struct dpu_format *fmt = NULL;\n\tconst struct dpu_format *map = NULL;\n\tssize_t map_size = 0;\n\n\t \n\tDRM_DEBUG_ATOMIC(\"plane format modifier 0x%llX\\n\", modifier);\n\n\tswitch (modifier) {\n\tcase 0:\n\t\tmap = dpu_format_map;\n\t\tmap_size = ARRAY_SIZE(dpu_format_map);\n\t\tbreak;\n\tcase DRM_FORMAT_MOD_QCOM_COMPRESSED:\n\t\tmap = dpu_format_map_ubwc;\n\t\tmap_size = ARRAY_SIZE(dpu_format_map_ubwc);\n\t\tDRM_DEBUG_ATOMIC(\"found fmt: %4.4s  DRM_FORMAT_MOD_QCOM_COMPRESSED\\n\",\n\t\t\t\t(char *)&format);\n\t\tbreak;\n\tdefault:\n\t\tDPU_ERROR(\"unsupported format modifier %llX\\n\", modifier);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < map_size; i++) {\n\t\tif (format == map[i].base.pixel_format) {\n\t\t\tfmt = &map[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fmt == NULL)\n\t\tDPU_ERROR(\"unsupported fmt: %4.4s modifier 0x%llX\\n\",\n\t\t\t(char *)&format, modifier);\n\telse\n\t\tDRM_DEBUG_ATOMIC(\"fmt %4.4s mod 0x%llX ubwc %d yuv %d\\n\",\n\t\t\t\t(char *)&format, modifier,\n\t\t\t\tDPU_FORMAT_IS_UBWC(fmt),\n\t\t\t\tDPU_FORMAT_IS_YUV(fmt));\n\n\treturn fmt;\n}\n\nconst struct msm_format *dpu_get_msm_format(\n\t\tstruct msm_kms *kms,\n\t\tconst uint32_t format,\n\t\tconst uint64_t modifiers)\n{\n\tconst struct dpu_format *fmt = dpu_get_dpu_format_ext(format,\n\t\t\tmodifiers);\n\tif (fmt)\n\t\treturn &fmt->base;\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}