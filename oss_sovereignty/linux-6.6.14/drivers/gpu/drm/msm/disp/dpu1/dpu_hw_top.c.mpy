{
  "module_name": "dpu_hw_top.c",
  "hash_id": "f1297ebb39a61913b727baea1ecf2600fbbce5ab899fc60073d3ace3a87dc559",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_hw_top.c",
  "human_readable_source": "\n \n\n#include \"dpu_hwio.h\"\n#include \"dpu_hw_catalog.h\"\n#include \"dpu_hw_top.h\"\n#include \"dpu_kms.h\"\n\n#define FLD_SPLIT_DISPLAY_CMD             BIT(1)\n#define FLD_SMART_PANEL_FREE_RUN          BIT(2)\n#define FLD_INTF_1_SW_TRG_MUX             BIT(4)\n#define FLD_INTF_2_SW_TRG_MUX             BIT(8)\n#define FLD_TE_LINE_INTER_WATERLEVEL_MASK 0xFFFF\n\n#define TRAFFIC_SHAPER_EN                 BIT(31)\n#define TRAFFIC_SHAPER_RD_CLIENT(num)     (0x030 + (num * 4))\n#define TRAFFIC_SHAPER_WR_CLIENT(num)     (0x060 + (num * 4))\n#define TRAFFIC_SHAPER_FIXPOINT_FACTOR    4\n\n#define MDP_TICK_COUNT                    16\n#define XO_CLK_RATE                       19200\n#define MS_TICKS_IN_SEC                   1000\n\n#define CALCULATE_WD_LOAD_VALUE(fps) \\\n\t((uint32_t)((MS_TICKS_IN_SEC * XO_CLK_RATE)/(MDP_TICK_COUNT * fps)))\n\nstatic void dpu_hw_setup_split_pipe(struct dpu_hw_mdp *mdp,\n\t\tstruct split_pipe_cfg *cfg)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 upper_pipe = 0;\n\tu32 lower_pipe = 0;\n\n\tif (!mdp || !cfg)\n\t\treturn;\n\n\tc = &mdp->hw;\n\n\tif (cfg->en) {\n\t\tif (cfg->mode == INTF_MODE_CMD) {\n\t\t\tlower_pipe = FLD_SPLIT_DISPLAY_CMD;\n\t\t\t \n\t\t\tif (cfg->intf == INTF_2)\n\t\t\t\tlower_pipe |= FLD_INTF_1_SW_TRG_MUX;\n\t\t\telse\n\t\t\t\tlower_pipe |= FLD_INTF_2_SW_TRG_MUX;\n\t\t\tupper_pipe = lower_pipe;\n\t\t} else {\n\t\t\tif (cfg->intf == INTF_2) {\n\t\t\t\tlower_pipe = FLD_INTF_1_SW_TRG_MUX;\n\t\t\t\tupper_pipe = FLD_INTF_2_SW_TRG_MUX;\n\t\t\t} else {\n\t\t\t\tlower_pipe = FLD_INTF_2_SW_TRG_MUX;\n\t\t\t\tupper_pipe = FLD_INTF_1_SW_TRG_MUX;\n\t\t\t}\n\t\t}\n\t}\n\n\tDPU_REG_WRITE(c, SSPP_SPARE, cfg->split_flush_en ? 0x1 : 0x0);\n\tDPU_REG_WRITE(c, SPLIT_DISPLAY_LOWER_PIPE_CTRL, lower_pipe);\n\tDPU_REG_WRITE(c, SPLIT_DISPLAY_UPPER_PIPE_CTRL, upper_pipe);\n\tDPU_REG_WRITE(c, SPLIT_DISPLAY_EN, cfg->en & 0x1);\n}\n\nstatic bool dpu_hw_setup_clk_force_ctrl(struct dpu_hw_mdp *mdp,\n\t\tenum dpu_clk_ctrl_type clk_ctrl, bool enable)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 reg_off, bit_off;\n\tu32 reg_val, new_val;\n\tbool clk_forced_on;\n\n\tif (!mdp)\n\t\treturn false;\n\n\tc = &mdp->hw;\n\n\tif (clk_ctrl <= DPU_CLK_CTRL_NONE || clk_ctrl >= DPU_CLK_CTRL_MAX)\n\t\treturn false;\n\n\treg_off = mdp->caps->clk_ctrls[clk_ctrl].reg_off;\n\tbit_off = mdp->caps->clk_ctrls[clk_ctrl].bit_off;\n\n\treg_val = DPU_REG_READ(c, reg_off);\n\n\tif (enable)\n\t\tnew_val = reg_val | BIT(bit_off);\n\telse\n\t\tnew_val = reg_val & ~BIT(bit_off);\n\n\tDPU_REG_WRITE(c, reg_off, new_val);\n\n\tclk_forced_on = !(reg_val & BIT(bit_off));\n\n\treturn clk_forced_on;\n}\n\n\nstatic void dpu_hw_get_danger_status(struct dpu_hw_mdp *mdp,\n\t\tstruct dpu_danger_safe_status *status)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 value;\n\n\tif (!mdp || !status)\n\t\treturn;\n\n\tc = &mdp->hw;\n\n\tvalue = DPU_REG_READ(c, DANGER_STATUS);\n\tstatus->mdp = (value >> 0) & 0x3;\n\tstatus->sspp[SSPP_VIG0] = (value >> 4) & 0x3;\n\tstatus->sspp[SSPP_VIG1] = (value >> 6) & 0x3;\n\tstatus->sspp[SSPP_VIG2] = (value >> 8) & 0x3;\n\tstatus->sspp[SSPP_VIG3] = (value >> 10) & 0x3;\n\tstatus->sspp[SSPP_RGB0] = (value >> 12) & 0x3;\n\tstatus->sspp[SSPP_RGB1] = (value >> 14) & 0x3;\n\tstatus->sspp[SSPP_RGB2] = (value >> 16) & 0x3;\n\tstatus->sspp[SSPP_RGB3] = (value >> 18) & 0x3;\n\tstatus->sspp[SSPP_DMA0] = (value >> 20) & 0x3;\n\tstatus->sspp[SSPP_DMA1] = (value >> 22) & 0x3;\n\tstatus->sspp[SSPP_DMA2] = (value >> 28) & 0x3;\n\tstatus->sspp[SSPP_DMA3] = (value >> 30) & 0x3;\n\tstatus->sspp[SSPP_CURSOR0] = (value >> 24) & 0x3;\n\tstatus->sspp[SSPP_CURSOR1] = (value >> 26) & 0x3;\n}\n\nstatic void dpu_hw_setup_vsync_source(struct dpu_hw_mdp *mdp,\n\t\tstruct dpu_vsync_source_cfg *cfg)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 reg, wd_load_value, wd_ctl, wd_ctl2;\n\n\tif (!mdp || !cfg)\n\t\treturn;\n\n\tc = &mdp->hw;\n\n\tif (cfg->vsync_source >= DPU_VSYNC_SOURCE_WD_TIMER_4 &&\n\t\t\tcfg->vsync_source <= DPU_VSYNC_SOURCE_WD_TIMER_0) {\n\t\tswitch (cfg->vsync_source) {\n\t\tcase DPU_VSYNC_SOURCE_WD_TIMER_4:\n\t\t\twd_load_value = MDP_WD_TIMER_4_LOAD_VALUE;\n\t\t\twd_ctl = MDP_WD_TIMER_4_CTL;\n\t\t\twd_ctl2 = MDP_WD_TIMER_4_CTL2;\n\t\t\tbreak;\n\t\tcase DPU_VSYNC_SOURCE_WD_TIMER_3:\n\t\t\twd_load_value = MDP_WD_TIMER_3_LOAD_VALUE;\n\t\t\twd_ctl = MDP_WD_TIMER_3_CTL;\n\t\t\twd_ctl2 = MDP_WD_TIMER_3_CTL2;\n\t\t\tbreak;\n\t\tcase DPU_VSYNC_SOURCE_WD_TIMER_2:\n\t\t\twd_load_value = MDP_WD_TIMER_2_LOAD_VALUE;\n\t\t\twd_ctl = MDP_WD_TIMER_2_CTL;\n\t\t\twd_ctl2 = MDP_WD_TIMER_2_CTL2;\n\t\t\tbreak;\n\t\tcase DPU_VSYNC_SOURCE_WD_TIMER_1:\n\t\t\twd_load_value = MDP_WD_TIMER_1_LOAD_VALUE;\n\t\t\twd_ctl = MDP_WD_TIMER_1_CTL;\n\t\t\twd_ctl2 = MDP_WD_TIMER_1_CTL2;\n\t\t\tbreak;\n\t\tcase DPU_VSYNC_SOURCE_WD_TIMER_0:\n\t\tdefault:\n\t\t\twd_load_value = MDP_WD_TIMER_0_LOAD_VALUE;\n\t\t\twd_ctl = MDP_WD_TIMER_0_CTL;\n\t\t\twd_ctl2 = MDP_WD_TIMER_0_CTL2;\n\t\t\tbreak;\n\t\t}\n\n\t\tDPU_REG_WRITE(c, wd_load_value,\n\t\t\tCALCULATE_WD_LOAD_VALUE(cfg->frame_rate));\n\n\t\tDPU_REG_WRITE(c, wd_ctl, BIT(0));  \n\t\treg = DPU_REG_READ(c, wd_ctl2);\n\t\treg |= BIT(8);\t\t \n\t\treg |= BIT(0);\t\t \n\t\tDPU_REG_WRITE(c, wd_ctl2, reg);\n\n\t\t \n\t\twmb();\n\t}\n}\n\nstatic void dpu_hw_setup_vsync_source_and_vsync_sel(struct dpu_hw_mdp *mdp,\n\t\tstruct dpu_vsync_source_cfg *cfg)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 reg, i;\n\tstatic const u32 pp_offset[PINGPONG_MAX] = {0xC, 0x8, 0x4, 0x13, 0x18};\n\n\tif (!mdp || !cfg || (cfg->pp_count > ARRAY_SIZE(cfg->ppnumber)))\n\t\treturn;\n\n\tc = &mdp->hw;\n\n\treg = DPU_REG_READ(c, MDP_VSYNC_SEL);\n\tfor (i = 0; i < cfg->pp_count; i++) {\n\t\tint pp_idx = cfg->ppnumber[i] - PINGPONG_0;\n\n\t\tif (pp_idx >= ARRAY_SIZE(pp_offset))\n\t\t\tcontinue;\n\n\t\treg &= ~(0xf << pp_offset[pp_idx]);\n\t\treg |= (cfg->vsync_source & 0xf) << pp_offset[pp_idx];\n\t}\n\tDPU_REG_WRITE(c, MDP_VSYNC_SEL, reg);\n\n\tdpu_hw_setup_vsync_source(mdp, cfg);\n}\n\nstatic void dpu_hw_get_safe_status(struct dpu_hw_mdp *mdp,\n\t\tstruct dpu_danger_safe_status *status)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 value;\n\n\tif (!mdp || !status)\n\t\treturn;\n\n\tc = &mdp->hw;\n\n\tvalue = DPU_REG_READ(c, SAFE_STATUS);\n\tstatus->mdp = (value >> 0) & 0x1;\n\tstatus->sspp[SSPP_VIG0] = (value >> 4) & 0x1;\n\tstatus->sspp[SSPP_VIG1] = (value >> 6) & 0x1;\n\tstatus->sspp[SSPP_VIG2] = (value >> 8) & 0x1;\n\tstatus->sspp[SSPP_VIG3] = (value >> 10) & 0x1;\n\tstatus->sspp[SSPP_RGB0] = (value >> 12) & 0x1;\n\tstatus->sspp[SSPP_RGB1] = (value >> 14) & 0x1;\n\tstatus->sspp[SSPP_RGB2] = (value >> 16) & 0x1;\n\tstatus->sspp[SSPP_RGB3] = (value >> 18) & 0x1;\n\tstatus->sspp[SSPP_DMA0] = (value >> 20) & 0x1;\n\tstatus->sspp[SSPP_DMA1] = (value >> 22) & 0x1;\n\tstatus->sspp[SSPP_DMA2] = (value >> 28) & 0x1;\n\tstatus->sspp[SSPP_DMA3] = (value >> 30) & 0x1;\n\tstatus->sspp[SSPP_CURSOR0] = (value >> 24) & 0x1;\n\tstatus->sspp[SSPP_CURSOR1] = (value >> 26) & 0x1;\n}\n\nstatic void dpu_hw_intf_audio_select(struct dpu_hw_mdp *mdp)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\n\tif (!mdp)\n\t\treturn;\n\n\tc = &mdp->hw;\n\n\tDPU_REG_WRITE(c, HDMI_DP_CORE_SELECT, 0x1);\n}\n\nstatic void _setup_mdp_ops(struct dpu_hw_mdp_ops *ops,\n\t\tunsigned long cap)\n{\n\tops->setup_split_pipe = dpu_hw_setup_split_pipe;\n\tops->setup_clk_force_ctrl = dpu_hw_setup_clk_force_ctrl;\n\tops->get_danger_status = dpu_hw_get_danger_status;\n\n\tif (cap & BIT(DPU_MDP_VSYNC_SEL))\n\t\tops->setup_vsync_source = dpu_hw_setup_vsync_source_and_vsync_sel;\n\telse\n\t\tops->setup_vsync_source = dpu_hw_setup_vsync_source;\n\n\tops->get_safe_status = dpu_hw_get_safe_status;\n\n\tif (cap & BIT(DPU_MDP_AUDIO_SELECT))\n\t\tops->intf_audio_select = dpu_hw_intf_audio_select;\n}\n\nstruct dpu_hw_mdp *dpu_hw_mdptop_init(const struct dpu_mdp_cfg *cfg,\n\t\tvoid __iomem *addr,\n\t\tconst struct dpu_mdss_cfg *m)\n{\n\tstruct dpu_hw_mdp *mdp;\n\n\tif (!addr)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmdp = kzalloc(sizeof(*mdp), GFP_KERNEL);\n\tif (!mdp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmdp->hw.blk_addr = addr + cfg->base;\n\tmdp->hw.log_mask = DPU_DBG_MASK_TOP;\n\n\t \n\tmdp->caps = cfg;\n\t_setup_mdp_ops(&mdp->ops, mdp->caps->features);\n\n\treturn mdp;\n}\n\nvoid dpu_hw_mdp_destroy(struct dpu_hw_mdp *mdp)\n{\n\tkfree(mdp);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}