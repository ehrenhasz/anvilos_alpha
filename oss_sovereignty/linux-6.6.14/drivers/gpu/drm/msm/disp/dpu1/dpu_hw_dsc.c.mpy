{
  "module_name": "dpu_hw_dsc.c",
  "hash_id": "21c1a886bdeec092539dd6d8f276ac4a7ed88d374decd49f1608670c2e83e7e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_hw_dsc.c",
  "human_readable_source": "\n \n\n#include <drm/display/drm_dsc_helper.h>\n\n#include \"dpu_kms.h\"\n#include \"dpu_hw_catalog.h\"\n#include \"dpu_hwio.h\"\n#include \"dpu_hw_mdss.h\"\n#include \"dpu_hw_dsc.h\"\n\n#define DSC_COMMON_MODE                 0x000\n#define DSC_ENC                         0x004\n#define DSC_PICTURE                     0x008\n#define DSC_SLICE                       0x00C\n#define DSC_CHUNK_SIZE                  0x010\n#define DSC_DELAY                       0x014\n#define DSC_SCALE_INITIAL               0x018\n#define DSC_SCALE_DEC_INTERVAL          0x01C\n#define DSC_SCALE_INC_INTERVAL          0x020\n#define DSC_FIRST_LINE_BPG_OFFSET       0x024\n#define DSC_BPG_OFFSET                  0x028\n#define DSC_DSC_OFFSET                  0x02C\n#define DSC_FLATNESS                    0x030\n#define DSC_RC_MODEL_SIZE               0x034\n#define DSC_RC                          0x038\n#define DSC_RC_BUF_THRESH               0x03C\n#define DSC_RANGE_MIN_QP                0x074\n#define DSC_RANGE_MAX_QP                0x0B0\n#define DSC_RANGE_BPG_OFFSET            0x0EC\n\n#define DSC_CTL(m) (0x1800 - 0x3FC * (m - DSC_0))\n\nstatic void dpu_hw_dsc_disable(struct dpu_hw_dsc *dsc)\n{\n\tstruct dpu_hw_blk_reg_map *c = &dsc->hw;\n\n\tDPU_REG_WRITE(c, DSC_COMMON_MODE, 0);\n}\n\nstatic void dpu_hw_dsc_config(struct dpu_hw_dsc *hw_dsc,\n\t\t\t      struct drm_dsc_config *dsc,\n\t\t\t      u32 mode,\n\t\t\t      u32 initial_lines)\n{\n\tstruct dpu_hw_blk_reg_map *c = &hw_dsc->hw;\n\tu32 data;\n\tu32 slice_last_group_size;\n\tu32 det_thresh_flatness;\n\tbool is_cmd_mode = !(mode & DSC_MODE_VIDEO);\n\n\tDPU_REG_WRITE(c, DSC_COMMON_MODE, mode);\n\n\tif (is_cmd_mode)\n\t\tinitial_lines += 1;\n\n\tslice_last_group_size = (dsc->slice_width + 2) % 3;\n\n\tdata = (initial_lines << 20);\n\tdata |= (slice_last_group_size << 18);\n\t \n\tdata |= (dsc->bits_per_pixel << 8);\n\tdata |= (dsc->block_pred_enable << 7);\n\tdata |= (dsc->line_buf_depth << 3);\n\tdata |= (dsc->simple_422 << 2);\n\tdata |= (dsc->convert_rgb << 1);\n\tdata |= dsc->bits_per_component;\n\n\tDPU_REG_WRITE(c, DSC_ENC, data);\n\n\tdata = dsc->pic_width << 16;\n\tdata |= dsc->pic_height;\n\tDPU_REG_WRITE(c, DSC_PICTURE, data);\n\n\tdata = dsc->slice_width << 16;\n\tdata |= dsc->slice_height;\n\tDPU_REG_WRITE(c, DSC_SLICE, data);\n\n\tdata = dsc->slice_chunk_size << 16;\n\tDPU_REG_WRITE(c, DSC_CHUNK_SIZE, data);\n\n\tdata = dsc->initial_dec_delay << 16;\n\tdata |= dsc->initial_xmit_delay;\n\tDPU_REG_WRITE(c, DSC_DELAY, data);\n\n\tdata = dsc->initial_scale_value;\n\tDPU_REG_WRITE(c, DSC_SCALE_INITIAL, data);\n\n\tdata = dsc->scale_decrement_interval;\n\tDPU_REG_WRITE(c, DSC_SCALE_DEC_INTERVAL, data);\n\n\tdata = dsc->scale_increment_interval;\n\tDPU_REG_WRITE(c, DSC_SCALE_INC_INTERVAL, data);\n\n\tdata = dsc->first_line_bpg_offset;\n\tDPU_REG_WRITE(c, DSC_FIRST_LINE_BPG_OFFSET, data);\n\n\tdata = dsc->nfl_bpg_offset << 16;\n\tdata |= dsc->slice_bpg_offset;\n\tDPU_REG_WRITE(c, DSC_BPG_OFFSET, data);\n\n\tdata = dsc->initial_offset << 16;\n\tdata |= dsc->final_offset;\n\tDPU_REG_WRITE(c, DSC_DSC_OFFSET, data);\n\n\tdet_thresh_flatness = drm_dsc_flatness_det_thresh(dsc);\n\tdata = det_thresh_flatness << 10;\n\tdata |= dsc->flatness_max_qp << 5;\n\tdata |= dsc->flatness_min_qp;\n\tDPU_REG_WRITE(c, DSC_FLATNESS, data);\n\n\tdata = dsc->rc_model_size;\n\tDPU_REG_WRITE(c, DSC_RC_MODEL_SIZE, data);\n\n\tdata = dsc->rc_tgt_offset_low << 18;\n\tdata |= dsc->rc_tgt_offset_high << 14;\n\tdata |= dsc->rc_quant_incr_limit1 << 9;\n\tdata |= dsc->rc_quant_incr_limit0 << 4;\n\tdata |= dsc->rc_edge_factor;\n\tDPU_REG_WRITE(c, DSC_RC, data);\n}\n\nstatic void dpu_hw_dsc_config_thresh(struct dpu_hw_dsc *hw_dsc,\n\t\t\t\t     struct drm_dsc_config *dsc)\n{\n\tstruct drm_dsc_rc_range_parameters *rc = dsc->rc_range_params;\n\tstruct dpu_hw_blk_reg_map *c = &hw_dsc->hw;\n\tu32 off;\n\tint i;\n\n\toff = DSC_RC_BUF_THRESH;\n\tfor (i = 0; i < DSC_NUM_BUF_RANGES - 1 ; i++) {\n\t\tDPU_REG_WRITE(c, off, dsc->rc_buf_thresh[i]);\n\t\toff += 4;\n\t}\n\n\toff = DSC_RANGE_MIN_QP;\n\tfor (i = 0; i < DSC_NUM_BUF_RANGES; i++) {\n\t\tDPU_REG_WRITE(c, off, rc[i].range_min_qp);\n\t\toff += 4;\n\t}\n\n\toff = DSC_RANGE_MAX_QP;\n\tfor (i = 0; i < 15; i++) {\n\t\tDPU_REG_WRITE(c, off, rc[i].range_max_qp);\n\t\toff += 4;\n\t}\n\n\toff = DSC_RANGE_BPG_OFFSET;\n\tfor (i = 0; i < 15; i++) {\n\t\tDPU_REG_WRITE(c, off, rc[i].range_bpg_offset);\n\t\toff += 4;\n\t}\n}\n\nstatic void dpu_hw_dsc_bind_pingpong_blk(\n\t\tstruct dpu_hw_dsc *hw_dsc,\n\t\tconst enum dpu_pingpong pp)\n{\n\tstruct dpu_hw_blk_reg_map *c = &hw_dsc->hw;\n\tint mux_cfg = 0xF;\n\tu32 dsc_ctl_offset;\n\n\tdsc_ctl_offset = DSC_CTL(hw_dsc->idx);\n\n\tif (pp)\n\t\tmux_cfg = (pp - PINGPONG_0) & 0x7;\n\n\tif (pp)\n\t\tDRM_DEBUG_KMS(\"Binding dsc:%d to pp:%d\\n\",\n\t\t\t      hw_dsc->idx - DSC_0, pp - PINGPONG_0);\n\telse\n\t\tDRM_DEBUG_KMS(\"Unbinding dsc:%d from any pp\\n\",\n\t\t\t      hw_dsc->idx - DSC_0);\n\n\tDPU_REG_WRITE(c, dsc_ctl_offset, mux_cfg);\n}\n\nstatic void _setup_dsc_ops(struct dpu_hw_dsc_ops *ops,\n\t\t\t   unsigned long cap)\n{\n\tops->dsc_disable = dpu_hw_dsc_disable;\n\tops->dsc_config = dpu_hw_dsc_config;\n\tops->dsc_config_thresh = dpu_hw_dsc_config_thresh;\n\tif (cap & BIT(DPU_DSC_OUTPUT_CTRL))\n\t\tops->dsc_bind_pingpong_blk = dpu_hw_dsc_bind_pingpong_blk;\n};\n\nstruct dpu_hw_dsc *dpu_hw_dsc_init(const struct dpu_dsc_cfg *cfg,\n\t\t\t\t   void __iomem *addr)\n{\n\tstruct dpu_hw_dsc *c;\n\n\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tc->hw.blk_addr = addr + cfg->base;\n\tc->hw.log_mask = DPU_DBG_MASK_DSC;\n\n\tc->idx = cfg->id;\n\tc->caps = cfg;\n\t_setup_dsc_ops(&c->ops, c->caps->features);\n\n\treturn c;\n}\n\nvoid dpu_hw_dsc_destroy(struct dpu_hw_dsc *dsc)\n{\n\tkfree(dsc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}