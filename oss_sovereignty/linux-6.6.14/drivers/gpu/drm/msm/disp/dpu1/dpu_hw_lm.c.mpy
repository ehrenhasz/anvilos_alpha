{
  "module_name": "dpu_hw_lm.c",
  "hash_id": "b2abc1006a7129b99e5c7c5f23a175f938536d8b5eaef14ef022a36a9bb240ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_hw_lm.c",
  "human_readable_source": "\n \n\n#include \"dpu_kms.h\"\n#include \"dpu_hw_catalog.h\"\n#include \"dpu_hwio.h\"\n#include \"dpu_hw_lm.h\"\n#include \"dpu_hw_mdss.h\"\n\n#define LM_OP_MODE                        0x00\n#define LM_OUT_SIZE                       0x04\n#define LM_BORDER_COLOR_0                 0x08\n#define LM_BORDER_COLOR_1                 0x010\n\n \n#define LM_BLEND0_OP                     0x00\n#define LM_BLEND0_CONST_ALPHA            0x04\n#define LM_FG_COLOR_FILL_COLOR_0         0x08\n#define LM_FG_COLOR_FILL_COLOR_1         0x0C\n#define LM_FG_COLOR_FILL_SIZE            0x10\n#define LM_FG_COLOR_FILL_XY              0x14\n\n#define LM_BLEND0_FG_ALPHA               0x04\n#define LM_BLEND0_BG_ALPHA               0x08\n\n#define LM_MISR_CTRL                     0x310\n#define LM_MISR_SIGNATURE                0x314\n\n\n \nstatic inline int _stage_offset(struct dpu_hw_mixer *ctx, enum dpu_stage stage)\n{\n\tconst struct dpu_lm_sub_blks *sblk = ctx->cap->sblk;\n\tif (stage != DPU_STAGE_BASE && stage <= sblk->maxblendstages)\n\t\treturn sblk->blendstage_base[stage - DPU_STAGE_0];\n\n\treturn -EINVAL;\n}\n\nstatic void dpu_hw_lm_setup_out(struct dpu_hw_mixer *ctx,\n\t\tstruct dpu_hw_mixer_cfg *mixer)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tu32 outsize;\n\tu32 op_mode;\n\n\top_mode = DPU_REG_READ(c, LM_OP_MODE);\n\n\toutsize = mixer->out_height << 16 | mixer->out_width;\n\tDPU_REG_WRITE(c, LM_OUT_SIZE, outsize);\n\n\t \n\tif (mixer->right_mixer)\n\t\top_mode |= BIT(31);\n\telse\n\t\top_mode &= ~BIT(31);\n\tDPU_REG_WRITE(c, LM_OP_MODE, op_mode);\n}\n\nstatic void dpu_hw_lm_setup_border_color(struct dpu_hw_mixer *ctx,\n\t\tstruct dpu_mdss_color *color,\n\t\tu8 border_en)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\n\tif (border_en) {\n\t\tDPU_REG_WRITE(c, LM_BORDER_COLOR_0,\n\t\t\t(color->color_0 & 0xFFF) |\n\t\t\t((color->color_1 & 0xFFF) << 0x10));\n\t\tDPU_REG_WRITE(c, LM_BORDER_COLOR_1,\n\t\t\t(color->color_2 & 0xFFF) |\n\t\t\t((color->color_3 & 0xFFF) << 0x10));\n\t}\n}\n\nstatic void dpu_hw_lm_setup_misr(struct dpu_hw_mixer *ctx)\n{\n\tdpu_hw_setup_misr(&ctx->hw, LM_MISR_CTRL, 0x0);\n}\n\nstatic int dpu_hw_lm_collect_misr(struct dpu_hw_mixer *ctx, u32 *misr_value)\n{\n\treturn dpu_hw_collect_misr(&ctx->hw, LM_MISR_CTRL, LM_MISR_SIGNATURE, misr_value);\n}\n\nstatic void dpu_hw_lm_setup_blend_config_combined_alpha(struct dpu_hw_mixer *ctx,\n\tu32 stage, u32 fg_alpha, u32 bg_alpha, u32 blend_op)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tint stage_off;\n\tu32 const_alpha;\n\n\tif (stage == DPU_STAGE_BASE)\n\t\treturn;\n\n\tstage_off = _stage_offset(ctx, stage);\n\tif (WARN_ON(stage_off < 0))\n\t\treturn;\n\n\tconst_alpha = (bg_alpha & 0xFF) | ((fg_alpha & 0xFF) << 16);\n\tDPU_REG_WRITE(c, LM_BLEND0_CONST_ALPHA + stage_off, const_alpha);\n\tDPU_REG_WRITE(c, LM_BLEND0_OP + stage_off, blend_op);\n}\n\nstatic void dpu_hw_lm_setup_blend_config(struct dpu_hw_mixer *ctx,\n\tu32 stage, u32 fg_alpha, u32 bg_alpha, u32 blend_op)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tint stage_off;\n\n\tif (stage == DPU_STAGE_BASE)\n\t\treturn;\n\n\tstage_off = _stage_offset(ctx, stage);\n\tif (WARN_ON(stage_off < 0))\n\t\treturn;\n\n\tDPU_REG_WRITE(c, LM_BLEND0_FG_ALPHA + stage_off, fg_alpha);\n\tDPU_REG_WRITE(c, LM_BLEND0_BG_ALPHA + stage_off, bg_alpha);\n\tDPU_REG_WRITE(c, LM_BLEND0_OP + stage_off, blend_op);\n}\n\nstatic void dpu_hw_lm_setup_color3(struct dpu_hw_mixer *ctx,\n\tuint32_t mixer_op_mode)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tint op_mode;\n\n\t \n\top_mode = DPU_REG_READ(c, LM_OP_MODE);\n\n\top_mode = (op_mode & (BIT(31) | BIT(30))) | mixer_op_mode;\n\n\tDPU_REG_WRITE(c, LM_OP_MODE, op_mode);\n}\n\nstatic void _setup_mixer_ops(struct dpu_hw_lm_ops *ops,\n\t\tunsigned long features)\n{\n\tops->setup_mixer_out = dpu_hw_lm_setup_out;\n\tif (test_bit(DPU_MIXER_COMBINED_ALPHA, &features))\n\t\tops->setup_blend_config = dpu_hw_lm_setup_blend_config_combined_alpha;\n\telse\n\t\tops->setup_blend_config = dpu_hw_lm_setup_blend_config;\n\tops->setup_alpha_out = dpu_hw_lm_setup_color3;\n\tops->setup_border_color = dpu_hw_lm_setup_border_color;\n\tops->setup_misr = dpu_hw_lm_setup_misr;\n\tops->collect_misr = dpu_hw_lm_collect_misr;\n}\n\nstruct dpu_hw_mixer *dpu_hw_lm_init(const struct dpu_lm_cfg *cfg,\n\t\tvoid __iomem *addr)\n{\n\tstruct dpu_hw_mixer *c;\n\n\tif (cfg->pingpong == PINGPONG_NONE) {\n\t\tDPU_DEBUG(\"skip mixer %d without pingpong\\n\", cfg->id);\n\t\treturn NULL;\n\t}\n\n\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tc->hw.blk_addr = addr + cfg->base;\n\tc->hw.log_mask = DPU_DBG_MASK_LM;\n\n\t \n\tc->idx = cfg->id;\n\tc->cap = cfg;\n\t_setup_mixer_ops(&c->ops, c->cap->features);\n\n\treturn c;\n}\n\nvoid dpu_hw_lm_destroy(struct dpu_hw_mixer *lm)\n{\n\tkfree(lm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}