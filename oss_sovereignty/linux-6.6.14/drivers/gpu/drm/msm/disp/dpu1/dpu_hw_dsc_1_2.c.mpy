{
  "module_name": "dpu_hw_dsc_1_2.c",
  "hash_id": "753df50d96c0e34988778e3648d7a80ad8069b59fb1b22cfb2583d6317ef681e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_hw_dsc_1_2.c",
  "human_readable_source": "\n \n\n#include <drm/display/drm_dsc_helper.h>\n\n#include \"dpu_kms.h\"\n#include \"dpu_hw_catalog.h\"\n#include \"dpu_hwio.h\"\n#include \"dpu_hw_mdss.h\"\n#include \"dpu_hw_dsc.h\"\n\n#define DSC_CMN_MAIN_CNF           0x00\n\n \n#define ENC_DF_CTRL                0x00\n#define ENC_GENERAL_STATUS         0x04\n#define ENC_HSLICE_STATUS          0x08\n#define ENC_OUT_STATUS             0x0C\n#define ENC_INT_STAT               0x10\n#define ENC_INT_CLR                0x14\n#define ENC_INT_MASK               0x18\n#define DSC_MAIN_CONF              0x30\n#define DSC_PICTURE_SIZE           0x34\n#define DSC_SLICE_SIZE             0x38\n#define DSC_MISC_SIZE              0x3C\n#define DSC_HRD_DELAYS             0x40\n#define DSC_RC_SCALE               0x44\n#define DSC_RC_SCALE_INC_DEC       0x48\n#define DSC_RC_OFFSETS_1           0x4C\n#define DSC_RC_OFFSETS_2           0x50\n#define DSC_RC_OFFSETS_3           0x54\n#define DSC_RC_OFFSETS_4           0x58\n#define DSC_FLATNESS_QP            0x5C\n#define DSC_RC_MODEL_SIZE          0x60\n#define DSC_RC_CONFIG              0x64\n#define DSC_RC_BUF_THRESH_0        0x68\n#define DSC_RC_BUF_THRESH_1        0x6C\n#define DSC_RC_BUF_THRESH_2        0x70\n#define DSC_RC_BUF_THRESH_3        0x74\n#define DSC_RC_MIN_QP_0            0x78\n#define DSC_RC_MIN_QP_1            0x7C\n#define DSC_RC_MIN_QP_2            0x80\n#define DSC_RC_MAX_QP_0            0x84\n#define DSC_RC_MAX_QP_1            0x88\n#define DSC_RC_MAX_QP_2            0x8C\n#define DSC_RC_RANGE_BPG_OFFSETS_0 0x90\n#define DSC_RC_RANGE_BPG_OFFSETS_1 0x94\n#define DSC_RC_RANGE_BPG_OFFSETS_2 0x98\n\n \n#define DSC_CTL                    0x00\n#define DSC_CFG                    0x04\n#define DSC_DATA_IN_SWAP           0x08\n#define DSC_CLK_CTRL               0x0C\n\nstatic int _dsc_calc_output_buf_max_addr(struct dpu_hw_dsc *hw_dsc, int num_softslice)\n{\n\tint max_addr = 2400 / num_softslice;\n\n\tif (hw_dsc->caps->features & BIT(DPU_DSC_NATIVE_42x_EN))\n\t\tmax_addr /= 2;\n\n\treturn max_addr - 1;\n};\n\nstatic void dpu_hw_dsc_disable_1_2(struct dpu_hw_dsc *hw_dsc)\n{\n\tstruct dpu_hw_blk_reg_map *hw;\n\tconst struct dpu_dsc_sub_blks *sblk;\n\n\tif (!hw_dsc)\n\t\treturn;\n\n\thw = &hw_dsc->hw;\n\tsblk = hw_dsc->caps->sblk;\n\tDPU_REG_WRITE(hw, sblk->ctl.base + DSC_CFG, 0);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + ENC_DF_CTRL, 0);\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_MAIN_CONF, 0);\n}\n\nstatic void dpu_hw_dsc_config_1_2(struct dpu_hw_dsc *hw_dsc,\n\t\t\t\t  struct drm_dsc_config *dsc,\n\t\t\t\t  u32 mode,\n\t\t\t\t  u32 initial_lines)\n{\n\tstruct dpu_hw_blk_reg_map *hw;\n\tconst struct dpu_dsc_sub_blks *sblk;\n\tu32 data = 0;\n\tu32 det_thresh_flatness;\n\tu32 num_active_slice_per_enc;\n\tu32 bpp;\n\n\tif (!hw_dsc || !dsc)\n\t\treturn;\n\n\thw = &hw_dsc->hw;\n\n\tsblk = hw_dsc->caps->sblk;\n\n\tif (mode & DSC_MODE_SPLIT_PANEL)\n\t\tdata |= BIT(0);\n\n\tif (mode & DSC_MODE_MULTIPLEX)\n\t\tdata |= BIT(1);\n\n\tnum_active_slice_per_enc = dsc->slice_count;\n\tif (mode & DSC_MODE_MULTIPLEX)\n\t\tnum_active_slice_per_enc = dsc->slice_count / 2;\n\n\tdata |= (num_active_slice_per_enc & 0x3) << 7;\n\n\tDPU_REG_WRITE(hw, DSC_CMN_MAIN_CNF, data);\n\n\tdata = (initial_lines & 0xff);\n\n\tif (mode & DSC_MODE_VIDEO)\n\t\tdata |= BIT(9);\n\n\tdata |= (_dsc_calc_output_buf_max_addr(hw_dsc, num_active_slice_per_enc) << 18);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + ENC_DF_CTRL, data);\n\n\tdata = (dsc->dsc_version_minor & 0xf) << 28;\n\tif (dsc->dsc_version_minor == 0x2) {\n\t\tif (dsc->native_422)\n\t\t\tdata |= BIT(22);\n\t\tif (dsc->native_420)\n\t\t\tdata |= BIT(21);\n\t}\n\n\tbpp = dsc->bits_per_pixel;\n\t \n\tif (dsc->native_422 || dsc->native_420)\n\t\tbpp = 2 * bpp;\n\n\tdata |= bpp << 10;\n\n\tif (dsc->block_pred_enable)\n\t\tdata |= BIT(20);\n\n\tif (dsc->convert_rgb)\n\t\tdata |= BIT(4);\n\n\tdata |= (dsc->line_buf_depth & 0xf) << 6;\n\tdata |= dsc->bits_per_component & 0xf;\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_MAIN_CONF, data);\n\n\tdata = (dsc->pic_width & 0xffff) |\n\t\t((dsc->pic_height & 0xffff) << 16);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_PICTURE_SIZE, data);\n\n\tdata = (dsc->slice_width & 0xffff) |\n\t\t((dsc->slice_height & 0xffff) << 16);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_SLICE_SIZE, data);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_MISC_SIZE,\n\t\t      (dsc->slice_chunk_size) & 0xffff);\n\n\tdata = (dsc->initial_xmit_delay & 0xffff) |\n\t\t((dsc->initial_dec_delay & 0xffff) << 16);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_HRD_DELAYS, data);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_SCALE,\n\t\t      dsc->initial_scale_value & 0x3f);\n\n\tdata = (dsc->scale_increment_interval & 0xffff) |\n\t\t((dsc->scale_decrement_interval & 0x7ff) << 16);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_SCALE_INC_DEC, data);\n\n\tdata = (dsc->first_line_bpg_offset & 0x1f) |\n\t\t((dsc->second_line_bpg_offset & 0x1f) << 5);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_OFFSETS_1, data);\n\n\tdata = (dsc->nfl_bpg_offset & 0xffff) |\n\t\t((dsc->slice_bpg_offset & 0xffff) << 16);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_OFFSETS_2, data);\n\n\tdata = (dsc->initial_offset & 0xffff) |\n\t\t((dsc->final_offset & 0xffff) << 16);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_OFFSETS_3, data);\n\n\tdata = (dsc->nsl_bpg_offset & 0xffff) |\n\t\t((dsc->second_line_offset_adj & 0xffff) << 16);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_OFFSETS_4, data);\n\n\tdet_thresh_flatness = drm_dsc_flatness_det_thresh(dsc);\n\tdata = (dsc->flatness_min_qp & 0x1f) |\n\t\t((dsc->flatness_max_qp & 0x1f) << 5) |\n\t\t((det_thresh_flatness & 0xff) << 10);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_FLATNESS_QP, data);\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_MODEL_SIZE,\n\t\t      (dsc->rc_model_size) & 0xffff);\n\n\tdata = dsc->rc_edge_factor & 0xf;\n\tdata |= (dsc->rc_quant_incr_limit0 & 0x1f) << 8;\n\tdata |= (dsc->rc_quant_incr_limit1 & 0x1f) << 13;\n\tdata |= (dsc->rc_tgt_offset_high & 0xf) << 20;\n\tdata |= (dsc->rc_tgt_offset_low & 0xf) << 24;\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_CONFIG, data);\n\n\t \n\tdata = BIT(0);  \n\tif (dsc->native_422)\n\t\tdata |= BIT(8);\n\telse if (dsc->native_420)\n\t\tdata |= BIT(9);\n\tif (!dsc->convert_rgb)\n\t\tdata |= BIT(10);\n\tif (dsc->bits_per_component == 8)\n\t\tdata |= BIT(11);\n\tif (mode & DSC_MODE_SPLIT_PANEL)\n\t\tdata |= BIT(12);\n\tif (mode & DSC_MODE_MULTIPLEX)\n\t\tdata |= BIT(13);\n\tif (!(mode & DSC_MODE_VIDEO))\n\t\tdata |= BIT(17);\n\n\tDPU_REG_WRITE(hw, sblk->ctl.base + DSC_CFG, data);\n}\n\nstatic void dpu_hw_dsc_config_thresh_1_2(struct dpu_hw_dsc *hw_dsc,\n\t\t\t\t\t struct drm_dsc_config *dsc)\n{\n\tstruct dpu_hw_blk_reg_map *hw;\n\tconst struct dpu_dsc_sub_blks *sblk;\n\tstruct drm_dsc_rc_range_parameters *rc;\n\n\tif (!hw_dsc || !dsc)\n\t\treturn;\n\n\thw = &hw_dsc->hw;\n\n\tsblk = hw_dsc->caps->sblk;\n\n\trc = dsc->rc_range_params;\n\n\t \n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_BUF_THRESH_0,\n\t\t      (dsc->rc_buf_thresh[0] << 0) |\n\t\t      (dsc->rc_buf_thresh[1] << 8) |\n\t\t      (dsc->rc_buf_thresh[2] << 16) |\n\t\t      (dsc->rc_buf_thresh[3] << 24));\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_BUF_THRESH_1,\n\t\t      (dsc->rc_buf_thresh[4] << 0) |\n\t\t      (dsc->rc_buf_thresh[5] << 8) |\n\t\t      (dsc->rc_buf_thresh[6] << 16) |\n\t\t      (dsc->rc_buf_thresh[7] << 24));\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_BUF_THRESH_2,\n\t\t      (dsc->rc_buf_thresh[8] << 0) |\n\t\t      (dsc->rc_buf_thresh[9] << 8) |\n\t\t      (dsc->rc_buf_thresh[10] << 16) |\n\t\t      (dsc->rc_buf_thresh[11] << 24));\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_BUF_THRESH_3,\n\t\t      (dsc->rc_buf_thresh[12] << 0) |\n\t\t      (dsc->rc_buf_thresh[13] << 8));\n\n\t \n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_MIN_QP_0,\n\t\t      (rc[0].range_min_qp << 0) |\n\t\t      (rc[1].range_min_qp << 5) |\n\t\t      (rc[2].range_min_qp << 10) |\n\t\t      (rc[3].range_min_qp << 15) |\n\t\t      (rc[4].range_min_qp << 20));\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_MAX_QP_0,\n\t\t      (rc[0].range_max_qp << 0) |\n\t\t      (rc[1].range_max_qp << 5) |\n\t\t      (rc[2].range_max_qp << 10) |\n\t\t      (rc[3].range_max_qp << 15) |\n\t\t      (rc[4].range_max_qp << 20));\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_RANGE_BPG_OFFSETS_0,\n\t\t      (rc[0].range_bpg_offset << 0) |\n\t\t      (rc[1].range_bpg_offset << 6) |\n\t\t      (rc[2].range_bpg_offset << 12) |\n\t\t      (rc[3].range_bpg_offset << 18) |\n\t\t      (rc[4].range_bpg_offset << 24));\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_MIN_QP_1,\n\t\t      (rc[5].range_min_qp << 0) |\n\t\t      (rc[6].range_min_qp << 5) |\n\t\t      (rc[7].range_min_qp << 10) |\n\t\t      (rc[8].range_min_qp << 15) |\n\t\t      (rc[9].range_min_qp << 20));\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_MAX_QP_1,\n\t\t      (rc[5].range_max_qp << 0) |\n\t\t      (rc[6].range_max_qp << 5) |\n\t\t      (rc[7].range_max_qp << 10) |\n\t\t      (rc[8].range_max_qp << 15) |\n\t\t      (rc[9].range_max_qp << 20));\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_RANGE_BPG_OFFSETS_1,\n\t\t      (rc[5].range_bpg_offset << 0) |\n\t\t      (rc[6].range_bpg_offset << 6) |\n\t\t      (rc[7].range_bpg_offset << 12) |\n\t\t      (rc[8].range_bpg_offset << 18) |\n\t\t      (rc[9].range_bpg_offset << 24));\n\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_MIN_QP_2,\n\t\t      (rc[10].range_min_qp << 0) |\n\t\t      (rc[11].range_min_qp << 5) |\n\t\t      (rc[12].range_min_qp << 10) |\n\t\t      (rc[13].range_min_qp << 15) |\n\t\t      (rc[14].range_min_qp << 20));\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_MAX_QP_2,\n\t\t      (rc[10].range_max_qp << 0) |\n\t\t      (rc[11].range_max_qp << 5) |\n\t\t      (rc[12].range_max_qp << 10) |\n\t\t      (rc[13].range_max_qp << 15) |\n\t\t      (rc[14].range_max_qp << 20));\n\tDPU_REG_WRITE(hw, sblk->enc.base + DSC_RC_RANGE_BPG_OFFSETS_2,\n\t\t      (rc[10].range_bpg_offset << 0) |\n\t\t      (rc[11].range_bpg_offset << 6) |\n\t\t      (rc[12].range_bpg_offset << 12) |\n\t\t      (rc[13].range_bpg_offset << 18) |\n\t\t      (rc[14].range_bpg_offset << 24));\n}\n\nstatic void dpu_hw_dsc_bind_pingpong_blk_1_2(struct dpu_hw_dsc *hw_dsc,\n\t\t\t\t\t     const enum dpu_pingpong pp)\n{\n\tstruct dpu_hw_blk_reg_map *hw;\n\tconst struct dpu_dsc_sub_blks *sblk;\n\tint mux_cfg = 0xf;  \n\n\thw = &hw_dsc->hw;\n\n\tsblk = hw_dsc->caps->sblk;\n\n\tif (pp)\n\t\tmux_cfg = (pp - PINGPONG_0) & 0x7;\n\n\tDPU_REG_WRITE(hw, sblk->ctl.base + DSC_CTL, mux_cfg);\n}\n\nstatic void _setup_dcs_ops_1_2(struct dpu_hw_dsc_ops *ops,\n\t\t\t       const unsigned long features)\n{\n\tops->dsc_disable = dpu_hw_dsc_disable_1_2;\n\tops->dsc_config = dpu_hw_dsc_config_1_2;\n\tops->dsc_config_thresh = dpu_hw_dsc_config_thresh_1_2;\n\tops->dsc_bind_pingpong_blk = dpu_hw_dsc_bind_pingpong_blk_1_2;\n}\n\nstruct dpu_hw_dsc *dpu_hw_dsc_init_1_2(const struct dpu_dsc_cfg *cfg,\n\t\t\t\t       void __iomem *addr)\n{\n\tstruct dpu_hw_dsc *c;\n\n\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tc->hw.blk_addr = addr + cfg->base;\n\tc->hw.log_mask = DPU_DBG_MASK_DSC;\n\n\tc->idx = cfg->id;\n\tc->caps = cfg;\n\t_setup_dcs_ops_1_2(&c->ops, c->caps->features);\n\n\treturn c;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}