{
  "module_name": "dpu_encoder_phys_wb.c",
  "hash_id": "62a6adbd91dd02fd262aa9b388eccc0776eab5350359697b312ab2adb23970dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_wb.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm:%s:%d] \" fmt, __func__, __LINE__\n\n#include <linux/debugfs.h>\n\n#include <drm/drm_framebuffer.h>\n\n#include \"dpu_encoder_phys.h\"\n#include \"dpu_formats.h\"\n#include \"dpu_hw_top.h\"\n#include \"dpu_hw_wb.h\"\n#include \"dpu_hw_lm.h\"\n#include \"dpu_hw_merge3d.h\"\n#include \"dpu_hw_interrupts.h\"\n#include \"dpu_core_irq.h\"\n#include \"dpu_vbif.h\"\n#include \"dpu_crtc.h\"\n#include \"disp/msm_disp_snapshot.h\"\n\n#define to_dpu_encoder_phys_wb(x) \\\n\tcontainer_of(x, struct dpu_encoder_phys_wb, base)\n\n \nstatic bool dpu_encoder_phys_wb_is_master(struct dpu_encoder_phys *phys_enc)\n{\n\t \n\treturn true;\n}\n\n \nstatic void dpu_encoder_phys_wb_set_ot_limit(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_wb *hw_wb = phys_enc->hw_wb;\n\tstruct dpu_vbif_set_ot_params ot_params;\n\n\tmemset(&ot_params, 0, sizeof(ot_params));\n\tot_params.xin_id = hw_wb->caps->xin_id;\n\tot_params.num = hw_wb->idx - WB_0;\n\tot_params.width = phys_enc->cached_mode.hdisplay;\n\tot_params.height = phys_enc->cached_mode.vdisplay;\n\tot_params.is_wfd = true;\n\tot_params.frame_rate = drm_mode_vrefresh(&phys_enc->cached_mode);\n\tot_params.vbif_idx = hw_wb->caps->vbif_idx;\n\tot_params.clk_ctrl = hw_wb->caps->clk_ctrl;\n\tot_params.rd = false;\n\n\tdpu_vbif_set_ot_limit(phys_enc->dpu_kms, &ot_params);\n}\n\n \nstatic void dpu_encoder_phys_wb_set_qos_remap(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_wb *hw_wb;\n\tstruct dpu_vbif_set_qos_params qos_params;\n\n\tif (!phys_enc || !phys_enc->parent || !phys_enc->parent->crtc) {\n\t\tDPU_ERROR(\"invalid arguments\\n\");\n\t\treturn;\n\t}\n\n\tif (!phys_enc->hw_wb || !phys_enc->hw_wb->caps) {\n\t\tDPU_ERROR(\"invalid writeback hardware\\n\");\n\t\treturn;\n\t}\n\n\thw_wb = phys_enc->hw_wb;\n\n\tmemset(&qos_params, 0, sizeof(qos_params));\n\tqos_params.vbif_idx = hw_wb->caps->vbif_idx;\n\tqos_params.xin_id = hw_wb->caps->xin_id;\n\tqos_params.clk_ctrl = hw_wb->caps->clk_ctrl;\n\tqos_params.num = hw_wb->idx - WB_0;\n\tqos_params.is_rt = false;\n\n\tDPU_DEBUG(\"[qos_remap] wb:%d vbif:%d xin:%d is_rt:%d\\n\",\n\t\t\tqos_params.num,\n\t\t\tqos_params.vbif_idx,\n\t\t\tqos_params.xin_id, qos_params.is_rt);\n\n\tdpu_vbif_set_qos_remap(phys_enc->dpu_kms, &qos_params);\n}\n\n \nstatic void dpu_encoder_phys_wb_set_qos(struct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_wb *hw_wb;\n\tstruct dpu_hw_qos_cfg qos_cfg;\n\tconst struct dpu_mdss_cfg *catalog;\n\tconst struct dpu_qos_lut_tbl *qos_lut_tb;\n\n\tif (!phys_enc || !phys_enc->dpu_kms || !phys_enc->dpu_kms->catalog) {\n\t\tDPU_ERROR(\"invalid parameter(s)\\n\");\n\t\treturn;\n\t}\n\n\tcatalog = phys_enc->dpu_kms->catalog;\n\n\thw_wb = phys_enc->hw_wb;\n\n\tmemset(&qos_cfg, 0, sizeof(struct dpu_hw_qos_cfg));\n\tqos_cfg.danger_safe_en = true;\n\tqos_cfg.danger_lut =\n\t\tcatalog->perf->danger_lut_tbl[DPU_QOS_LUT_USAGE_NRT];\n\n\tqos_cfg.safe_lut = catalog->perf->safe_lut_tbl[DPU_QOS_LUT_USAGE_NRT];\n\n\tqos_lut_tb = &catalog->perf->qos_lut_tbl[DPU_QOS_LUT_USAGE_NRT];\n\tqos_cfg.creq_lut = _dpu_hw_get_qos_lut(qos_lut_tb, 0);\n\n\tif (hw_wb->ops.setup_qos_lut)\n\t\thw_wb->ops.setup_qos_lut(hw_wb, &qos_cfg);\n}\n\n \nstatic void dpu_encoder_phys_wb_setup_fb(struct dpu_encoder_phys *phys_enc,\n\t\tstruct drm_framebuffer *fb)\n{\n\tstruct dpu_encoder_phys_wb *wb_enc = to_dpu_encoder_phys_wb(phys_enc);\n\tstruct dpu_hw_wb *hw_wb;\n\tstruct dpu_hw_wb_cfg *wb_cfg;\n\n\tif (!phys_enc || !phys_enc->dpu_kms || !phys_enc->dpu_kms->catalog) {\n\t\tDPU_ERROR(\"invalid encoder\\n\");\n\t\treturn;\n\t}\n\n\thw_wb = phys_enc->hw_wb;\n\twb_cfg = &wb_enc->wb_cfg;\n\n\twb_cfg->intf_mode = phys_enc->intf_mode;\n\twb_cfg->roi.x1 = 0;\n\twb_cfg->roi.x2 = phys_enc->cached_mode.hdisplay;\n\twb_cfg->roi.y1 = 0;\n\twb_cfg->roi.y2 = phys_enc->cached_mode.vdisplay;\n\n\tif (hw_wb->ops.setup_roi)\n\t\thw_wb->ops.setup_roi(hw_wb, wb_cfg);\n\n\tif (hw_wb->ops.setup_outformat)\n\t\thw_wb->ops.setup_outformat(hw_wb, wb_cfg);\n\n\tif (hw_wb->ops.setup_cdp) {\n\t\tconst struct dpu_perf_cfg *perf = phys_enc->dpu_kms->catalog->perf;\n\n\t\thw_wb->ops.setup_cdp(hw_wb, wb_cfg->dest.format,\n\t\t\t\t     perf->cdp_cfg[DPU_PERF_CDP_USAGE_NRT].wr_enable);\n\t}\n\n\tif (hw_wb->ops.setup_outaddress)\n\t\thw_wb->ops.setup_outaddress(hw_wb, wb_cfg);\n}\n\n \nstatic void dpu_encoder_phys_wb_setup_cdp(struct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_wb *hw_wb;\n\tstruct dpu_hw_ctl *ctl;\n\n\tif (!phys_enc) {\n\t\tDPU_ERROR(\"invalid encoder\\n\");\n\t\treturn;\n\t}\n\n\thw_wb = phys_enc->hw_wb;\n\tctl = phys_enc->hw_ctl;\n\n\tif (test_bit(DPU_CTL_ACTIVE_CFG, &ctl->caps->features) &&\n\t\t(phys_enc->hw_ctl &&\n\t\t phys_enc->hw_ctl->ops.setup_intf_cfg)) {\n\t\tstruct dpu_hw_intf_cfg intf_cfg = {0};\n\t\tstruct dpu_hw_pingpong *hw_pp = phys_enc->hw_pp;\n\t\tenum dpu_3d_blend_mode mode_3d;\n\n\t\tmode_3d = dpu_encoder_helper_get_3d_blend_mode(phys_enc);\n\n\t\tintf_cfg.intf = DPU_NONE;\n\t\tintf_cfg.wb = hw_wb->idx;\n\n\t\tif (mode_3d && hw_pp && hw_pp->merge_3d)\n\t\t\tintf_cfg.merge_3d = hw_pp->merge_3d->idx;\n\n\t\tif (phys_enc->hw_pp->merge_3d && phys_enc->hw_pp->merge_3d->ops.setup_3d_mode)\n\t\t\tphys_enc->hw_pp->merge_3d->ops.setup_3d_mode(phys_enc->hw_pp->merge_3d,\n\t\t\t\t\tmode_3d);\n\n\t\t \n\t\tif (hw_pp && phys_enc->hw_wb->ops.bind_pingpong_blk)\n\t\t\tphys_enc->hw_wb->ops.bind_pingpong_blk(phys_enc->hw_wb,\n\t\t\t\t\tphys_enc->hw_pp->idx);\n\n\t\tphys_enc->hw_ctl->ops.setup_intf_cfg(phys_enc->hw_ctl, &intf_cfg);\n\t} else if (phys_enc->hw_ctl && phys_enc->hw_ctl->ops.setup_intf_cfg) {\n\t\tstruct dpu_hw_intf_cfg intf_cfg = {0};\n\n\t\tintf_cfg.intf = DPU_NONE;\n\t\tintf_cfg.wb = hw_wb->idx;\n\t\tintf_cfg.mode_3d =\n\t\t\tdpu_encoder_helper_get_3d_blend_mode(phys_enc);\n\t\tphys_enc->hw_ctl->ops.setup_intf_cfg(phys_enc->hw_ctl, &intf_cfg);\n\t}\n}\n\n \nstatic int dpu_encoder_phys_wb_atomic_check(\n\t\tstruct dpu_encoder_phys *phys_enc,\n\t\tstruct drm_crtc_state *crtc_state,\n\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct drm_framebuffer *fb;\n\tconst struct drm_display_mode *mode = &crtc_state->mode;\n\n\tDPU_DEBUG(\"[atomic_check:%d, \\\"%s\\\",%d,%d]\\n\",\n\t\t\tphys_enc->hw_wb->idx, mode->name, mode->hdisplay, mode->vdisplay);\n\n\tif (!conn_state || !conn_state->connector) {\n\t\tDPU_ERROR(\"invalid connector state\\n\");\n\t\treturn -EINVAL;\n\t} else if (conn_state->connector->status !=\n\t\t\tconnector_status_connected) {\n\t\tDPU_ERROR(\"connector not connected %d\\n\",\n\t\t\t\tconn_state->connector->status);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!conn_state->writeback_job || !conn_state->writeback_job->fb)\n\t\treturn 0;\n\n\tfb = conn_state->writeback_job->fb;\n\n\tDPU_DEBUG(\"[fb_id:%u][fb:%u,%u]\\n\", fb->base.id,\n\t\t\tfb->width, fb->height);\n\n\tif (fb->width != mode->hdisplay) {\n\t\tDPU_ERROR(\"invalid fb w=%d, mode w=%d\\n\", fb->width,\n\t\t\t\tmode->hdisplay);\n\t\treturn -EINVAL;\n\t} else if (fb->height != mode->vdisplay) {\n\t\tDPU_ERROR(\"invalid fb h=%d, mode h=%d\\n\", fb->height,\n\t\t\t\t  mode->vdisplay);\n\t\treturn -EINVAL;\n\t} else if (fb->width > phys_enc->hw_wb->caps->maxlinewidth) {\n\t\tDPU_ERROR(\"invalid fb w=%d, maxlinewidth=%u\\n\",\n\t\t\t\t  fb->width, phys_enc->hw_wb->caps->maxlinewidth);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic void _dpu_encoder_phys_wb_update_flush(struct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_wb *hw_wb;\n\tstruct dpu_hw_ctl *hw_ctl;\n\tstruct dpu_hw_pingpong *hw_pp;\n\tu32 pending_flush = 0;\n\n\tif (!phys_enc)\n\t\treturn;\n\n\thw_wb = phys_enc->hw_wb;\n\thw_pp = phys_enc->hw_pp;\n\thw_ctl = phys_enc->hw_ctl;\n\n\tDPU_DEBUG(\"[wb:%d]\\n\", hw_wb->idx - WB_0);\n\n\tif (!hw_ctl) {\n\t\tDPU_DEBUG(\"[wb:%d] no ctl assigned\\n\", hw_wb->idx - WB_0);\n\t\treturn;\n\t}\n\n\tif (hw_ctl->ops.update_pending_flush_wb)\n\t\thw_ctl->ops.update_pending_flush_wb(hw_ctl, hw_wb->idx);\n\n\tif (hw_ctl->ops.update_pending_flush_merge_3d && hw_pp && hw_pp->merge_3d)\n\t\thw_ctl->ops.update_pending_flush_merge_3d(hw_ctl,\n\t\t\t\thw_pp->merge_3d->idx);\n\n\tif (hw_ctl->ops.get_pending_flush)\n\t\tpending_flush = hw_ctl->ops.get_pending_flush(hw_ctl);\n\n\tDPU_DEBUG(\"Pending flush mask for CTL_%d is 0x%x, WB %d\\n\",\n\t\t\thw_ctl->idx - CTL_0, pending_flush,\n\t\t\thw_wb->idx - WB_0);\n}\n\n \nstatic void dpu_encoder_phys_wb_setup(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_wb *hw_wb = phys_enc->hw_wb;\n\tstruct drm_display_mode mode = phys_enc->cached_mode;\n\tstruct drm_framebuffer *fb = NULL;\n\n\tDPU_DEBUG(\"[mode_set:%d, \\\"%s\\\",%d,%d]\\n\",\n\t\t\thw_wb->idx - WB_0, mode.name,\n\t\t\tmode.hdisplay, mode.vdisplay);\n\n\tdpu_encoder_phys_wb_set_ot_limit(phys_enc);\n\n\tdpu_encoder_phys_wb_set_qos_remap(phys_enc);\n\n\tdpu_encoder_phys_wb_set_qos(phys_enc);\n\n\tdpu_encoder_phys_wb_setup_fb(phys_enc, fb);\n\n\tdpu_encoder_phys_wb_setup_cdp(phys_enc);\n\n}\n\nstatic void _dpu_encoder_phys_wb_frame_done_helper(void *arg)\n{\n\tstruct dpu_encoder_phys *phys_enc = arg;\n\tstruct dpu_encoder_phys_wb *wb_enc = to_dpu_encoder_phys_wb(phys_enc);\n\n\tstruct dpu_hw_wb *hw_wb = phys_enc->hw_wb;\n\tunsigned long lock_flags;\n\tu32 event = DPU_ENCODER_FRAME_EVENT_DONE;\n\n\tDPU_DEBUG(\"[wb:%d]\\n\", hw_wb->idx - WB_0);\n\n\tdpu_encoder_frame_done_callback(phys_enc->parent, phys_enc, event);\n\n\tdpu_encoder_vblank_callback(phys_enc->parent, phys_enc);\n\n\tspin_lock_irqsave(phys_enc->enc_spinlock, lock_flags);\n\tatomic_add_unless(&phys_enc->pending_kickoff_cnt, -1, 0);\n\tspin_unlock_irqrestore(phys_enc->enc_spinlock, lock_flags);\n\n\tif (wb_enc->wb_conn)\n\t\tdrm_writeback_signal_completion(wb_enc->wb_conn, 0);\n\n\t \n\twake_up_all(&phys_enc->pending_kickoff_wq);\n}\n\n \nstatic void dpu_encoder_phys_wb_done_irq(void *arg, int irq_idx)\n{\n\t_dpu_encoder_phys_wb_frame_done_helper(arg);\n}\n\n \nstatic void dpu_encoder_phys_wb_irq_ctrl(\n\t\tstruct dpu_encoder_phys *phys, bool enable)\n{\n\n\tstruct dpu_encoder_phys_wb *wb_enc = to_dpu_encoder_phys_wb(phys);\n\n\tif (enable && atomic_inc_return(&wb_enc->wbirq_refcount) == 1)\n\t\tdpu_core_irq_register_callback(phys->dpu_kms,\n\t\t\t\tphys->irq[INTR_IDX_WB_DONE], dpu_encoder_phys_wb_done_irq, phys);\n\telse if (!enable &&\n\t\t\tatomic_dec_return(&wb_enc->wbirq_refcount) == 0)\n\t\tdpu_core_irq_unregister_callback(phys->dpu_kms, phys->irq[INTR_IDX_WB_DONE]);\n}\n\nstatic void dpu_encoder_phys_wb_atomic_mode_set(\n\t\tstruct dpu_encoder_phys *phys_enc,\n\t\tstruct drm_crtc_state *crtc_state,\n\t\tstruct drm_connector_state *conn_state)\n{\n\n\tphys_enc->irq[INTR_IDX_WB_DONE] = phys_enc->hw_wb->caps->intr_wb_done;\n}\n\nstatic void _dpu_encoder_phys_wb_handle_wbdone_timeout(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_encoder_phys_wb *wb_enc = to_dpu_encoder_phys_wb(phys_enc);\n\tu32 frame_event = DPU_ENCODER_FRAME_EVENT_ERROR;\n\n\twb_enc->wb_done_timeout_cnt++;\n\n\tif (wb_enc->wb_done_timeout_cnt == 1)\n\t\tmsm_disp_snapshot_state(phys_enc->parent->dev);\n\n\tatomic_add_unless(&phys_enc->pending_kickoff_cnt, -1, 0);\n\n\t \n\tphys_enc->enable_state = DPU_ENC_ERR_NEEDS_HW_RESET;\n\n\tif (wb_enc->wb_conn)\n\t\tdrm_writeback_signal_completion(wb_enc->wb_conn, 0);\n\n\tdpu_encoder_frame_done_callback(phys_enc->parent, phys_enc, frame_event);\n}\n\n \nstatic int dpu_encoder_phys_wb_wait_for_commit_done(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tunsigned long ret;\n\tstruct dpu_encoder_wait_info wait_info;\n\tstruct dpu_encoder_phys_wb *wb_enc = to_dpu_encoder_phys_wb(phys_enc);\n\n\twait_info.wq = &phys_enc->pending_kickoff_wq;\n\twait_info.atomic_cnt = &phys_enc->pending_kickoff_cnt;\n\twait_info.timeout_ms = KICKOFF_TIMEOUT_MS;\n\n\tret = dpu_encoder_helper_wait_for_irq(phys_enc,\n\t\t\tphys_enc->irq[INTR_IDX_WB_DONE],\n\t\t\tdpu_encoder_phys_wb_done_irq, &wait_info);\n\tif (ret == -ETIMEDOUT)\n\t\t_dpu_encoder_phys_wb_handle_wbdone_timeout(phys_enc);\n\telse if (!ret)\n\t\twb_enc->wb_done_timeout_cnt = 0;\n\n\treturn ret;\n}\n\n \nstatic void dpu_encoder_phys_wb_prepare_for_kickoff(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_encoder_phys_wb *wb_enc = to_dpu_encoder_phys_wb(phys_enc);\n\tstruct drm_connector *drm_conn;\n\tstruct drm_connector_state *state;\n\n\tDPU_DEBUG(\"[wb:%d]\\n\", phys_enc->hw_wb->idx - WB_0);\n\n\tif (!wb_enc->wb_conn || !wb_enc->wb_job) {\n\t\tDPU_ERROR(\"invalid wb_conn or wb_job\\n\");\n\t\treturn;\n\t}\n\n\tdrm_conn = &wb_enc->wb_conn->base;\n\tstate = drm_conn->state;\n\n\tif (wb_enc->wb_conn && wb_enc->wb_job)\n\t\tdrm_writeback_queue_job(wb_enc->wb_conn, state);\n\n\tdpu_encoder_phys_wb_setup(phys_enc);\n\n\t_dpu_encoder_phys_wb_update_flush(phys_enc);\n}\n\n \nstatic bool dpu_encoder_phys_wb_needs_single_flush(struct dpu_encoder_phys *phys_enc)\n{\n\tDPU_DEBUG(\"[wb:%d]\\n\", phys_enc->hw_wb->idx - WB_0);\n\treturn false;\n}\n\n \nstatic void dpu_encoder_phys_wb_handle_post_kickoff(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tDPU_DEBUG(\"[wb:%d]\\n\", phys_enc->hw_wb->idx - WB_0);\n\n}\n\n \nstatic void dpu_encoder_phys_wb_enable(struct dpu_encoder_phys *phys_enc)\n{\n\tDPU_DEBUG(\"[wb:%d]\\n\", phys_enc->hw_wb->idx - WB_0);\n\tphys_enc->enable_state = DPU_ENC_ENABLED;\n}\n \nstatic void dpu_encoder_phys_wb_disable(struct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_wb *hw_wb = phys_enc->hw_wb;\n\tstruct dpu_hw_ctl *hw_ctl = phys_enc->hw_ctl;\n\n\tDPU_DEBUG(\"[wb:%d]\\n\", hw_wb->idx - WB_0);\n\n\tif (phys_enc->enable_state == DPU_ENC_DISABLED) {\n\t\tDPU_ERROR(\"encoder is already disabled\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (phys_enc->hw_ctl->ops.clear_pending_flush)\n\t\tphys_enc->hw_ctl->ops.clear_pending_flush(phys_enc->hw_ctl);\n\n\t \n\tif (hw_ctl->caps->features & BIT(DPU_CTL_ACTIVE_CFG))\n\t\tdpu_encoder_helper_phys_cleanup(phys_enc);\n\n\tphys_enc->enable_state = DPU_ENC_DISABLED;\n}\n\n \nstatic void dpu_encoder_phys_wb_destroy(struct dpu_encoder_phys *phys_enc)\n{\n\tif (!phys_enc)\n\t\treturn;\n\n\tDPU_DEBUG(\"[wb:%d]\\n\", phys_enc->hw_wb->idx - WB_0);\n\n\tkfree(phys_enc);\n}\n\nstatic void dpu_encoder_phys_wb_prepare_wb_job(struct dpu_encoder_phys *phys_enc,\n\t\tstruct drm_writeback_job *job)\n{\n\tconst struct msm_format *format;\n\tstruct msm_gem_address_space *aspace;\n\tstruct dpu_hw_wb_cfg *wb_cfg;\n\tint ret;\n\tstruct dpu_encoder_phys_wb *wb_enc = to_dpu_encoder_phys_wb(phys_enc);\n\n\tif (!job->fb)\n\t\treturn;\n\n\twb_enc->wb_job = job;\n\twb_enc->wb_conn = job->connector;\n\taspace = phys_enc->dpu_kms->base.aspace;\n\n\twb_cfg = &wb_enc->wb_cfg;\n\n\tmemset(wb_cfg, 0, sizeof(struct dpu_hw_wb_cfg));\n\n\tret = msm_framebuffer_prepare(job->fb, aspace, false);\n\tif (ret) {\n\t\tDPU_ERROR(\"prep fb failed, %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tformat = msm_framebuffer_format(job->fb);\n\n\twb_cfg->dest.format = dpu_get_dpu_format_ext(\n\t\t\tformat->pixel_format, job->fb->modifier);\n\tif (!wb_cfg->dest.format) {\n\t\t \n\t\tDPU_ERROR(\"failed to get format %x\\n\", format->pixel_format);\n\t\treturn;\n\t}\n\n\tret = dpu_format_populate_layout(aspace, job->fb, &wb_cfg->dest);\n\tif (ret) {\n\t\tDPU_DEBUG(\"failed to populate layout %d\\n\", ret);\n\t\treturn;\n\t}\n\n\twb_cfg->dest.width = job->fb->width;\n\twb_cfg->dest.height = job->fb->height;\n\twb_cfg->dest.num_planes = wb_cfg->dest.format->num_planes;\n\n\tif ((wb_cfg->dest.format->fetch_planes == DPU_PLANE_PLANAR) &&\n\t\t\t(wb_cfg->dest.format->element[0] == C1_B_Cb))\n\t\tswap(wb_cfg->dest.plane_addr[1], wb_cfg->dest.plane_addr[2]);\n\n\tDPU_DEBUG(\"[fb_offset:%8.8x,%8.8x,%8.8x,%8.8x]\\n\",\n\t\t\twb_cfg->dest.plane_addr[0], wb_cfg->dest.plane_addr[1],\n\t\t\twb_cfg->dest.plane_addr[2], wb_cfg->dest.plane_addr[3]);\n\n\tDPU_DEBUG(\"[fb_stride:%8.8x,%8.8x,%8.8x,%8.8x]\\n\",\n\t\t\twb_cfg->dest.plane_pitch[0], wb_cfg->dest.plane_pitch[1],\n\t\t\twb_cfg->dest.plane_pitch[2], wb_cfg->dest.plane_pitch[3]);\n}\n\nstatic void dpu_encoder_phys_wb_cleanup_wb_job(struct dpu_encoder_phys *phys_enc,\n\t\tstruct drm_writeback_job *job)\n{\n\tstruct dpu_encoder_phys_wb *wb_enc = to_dpu_encoder_phys_wb(phys_enc);\n\tstruct msm_gem_address_space *aspace;\n\n\tif (!job->fb)\n\t\treturn;\n\n\taspace = phys_enc->dpu_kms->base.aspace;\n\n\tmsm_framebuffer_cleanup(job->fb, aspace, false);\n\twb_enc->wb_job = NULL;\n\twb_enc->wb_conn = NULL;\n}\n\nstatic bool dpu_encoder_phys_wb_is_valid_for_commit(struct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_encoder_phys_wb *wb_enc = to_dpu_encoder_phys_wb(phys_enc);\n\n\tif (wb_enc->wb_job)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nstatic void dpu_encoder_phys_wb_init_ops(struct dpu_encoder_phys_ops *ops)\n{\n\tops->is_master = dpu_encoder_phys_wb_is_master;\n\tops->atomic_mode_set = dpu_encoder_phys_wb_atomic_mode_set;\n\tops->enable = dpu_encoder_phys_wb_enable;\n\tops->disable = dpu_encoder_phys_wb_disable;\n\tops->destroy = dpu_encoder_phys_wb_destroy;\n\tops->atomic_check = dpu_encoder_phys_wb_atomic_check;\n\tops->wait_for_commit_done = dpu_encoder_phys_wb_wait_for_commit_done;\n\tops->prepare_for_kickoff = dpu_encoder_phys_wb_prepare_for_kickoff;\n\tops->handle_post_kickoff = dpu_encoder_phys_wb_handle_post_kickoff;\n\tops->needs_single_flush = dpu_encoder_phys_wb_needs_single_flush;\n\tops->trigger_start = dpu_encoder_helper_trigger_start;\n\tops->prepare_wb_job = dpu_encoder_phys_wb_prepare_wb_job;\n\tops->cleanup_wb_job = dpu_encoder_phys_wb_cleanup_wb_job;\n\tops->irq_control = dpu_encoder_phys_wb_irq_ctrl;\n\tops->is_valid_for_commit = dpu_encoder_phys_wb_is_valid_for_commit;\n\n}\n\n \nstruct dpu_encoder_phys *dpu_encoder_phys_wb_init(\n\t\tstruct dpu_enc_phys_init_params *p)\n{\n\tstruct dpu_encoder_phys *phys_enc = NULL;\n\tstruct dpu_encoder_phys_wb *wb_enc = NULL;\n\n\tDPU_DEBUG(\"\\n\");\n\n\tif (!p || !p->parent) {\n\t\tDPU_ERROR(\"invalid params\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\twb_enc = kzalloc(sizeof(*wb_enc), GFP_KERNEL);\n\tif (!wb_enc) {\n\t\tDPU_ERROR(\"failed to allocate wb phys_enc enc\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tphys_enc = &wb_enc->base;\n\n\tdpu_encoder_phys_init(phys_enc, p);\n\n\tdpu_encoder_phys_wb_init_ops(&phys_enc->ops);\n\tphys_enc->intf_mode = INTF_MODE_WB_LINE;\n\n\tatomic_set(&wb_enc->wbirq_refcount, 0);\n\n\twb_enc->wb_done_timeout_cnt = 0;\n\n\tDPU_DEBUG(\"Created dpu_encoder_phys for wb %d\\n\", phys_enc->hw_wb->idx);\n\n\treturn phys_enc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}