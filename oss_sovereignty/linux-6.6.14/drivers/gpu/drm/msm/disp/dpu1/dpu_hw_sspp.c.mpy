{
  "module_name": "dpu_hw_sspp.c",
  "hash_id": "a16b0adc4cb4937f06c082db13fdacfa04659556e7d161764b2fa1ef98b7ceea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_hw_sspp.c",
  "human_readable_source": "\n \n\n#include \"dpu_hwio.h\"\n#include \"dpu_hw_catalog.h\"\n#include \"dpu_hw_lm.h\"\n#include \"dpu_hw_sspp.h\"\n#include \"dpu_kms.h\"\n\n#include \"msm_mdss.h\"\n\n#include <drm/drm_file.h>\n\n#define DPU_FETCH_CONFIG_RESET_VALUE   0x00000087\n\n \n#define SSPP_SRC_SIZE                      0x00\n#define SSPP_SRC_XY                        0x08\n#define SSPP_OUT_SIZE                      0x0c\n#define SSPP_OUT_XY                        0x10\n#define SSPP_SRC0_ADDR                     0x14\n#define SSPP_SRC1_ADDR                     0x18\n#define SSPP_SRC2_ADDR                     0x1C\n#define SSPP_SRC3_ADDR                     0x20\n#define SSPP_SRC_YSTRIDE0                  0x24\n#define SSPP_SRC_YSTRIDE1                  0x28\n#define SSPP_SRC_FORMAT                    0x30\n#define SSPP_SRC_UNPACK_PATTERN            0x34\n#define SSPP_SRC_OP_MODE                   0x38\n#define SSPP_SRC_CONSTANT_COLOR            0x3c\n#define SSPP_EXCL_REC_CTL                  0x40\n#define SSPP_UBWC_STATIC_CTRL              0x44\n#define SSPP_FETCH_CONFIG                  0x48\n#define SSPP_DANGER_LUT                    0x60\n#define SSPP_SAFE_LUT                      0x64\n#define SSPP_CREQ_LUT                      0x68\n#define SSPP_QOS_CTRL                      0x6C\n#define SSPP_SRC_ADDR_SW_STATUS            0x70\n#define SSPP_CREQ_LUT_0                    0x74\n#define SSPP_CREQ_LUT_1                    0x78\n#define SSPP_DECIMATION_CONFIG             0xB4\n#define SSPP_SW_PIX_EXT_C0_LR              0x100\n#define SSPP_SW_PIX_EXT_C0_TB              0x104\n#define SSPP_SW_PIX_EXT_C0_REQ_PIXELS      0x108\n#define SSPP_SW_PIX_EXT_C1C2_LR            0x110\n#define SSPP_SW_PIX_EXT_C1C2_TB            0x114\n#define SSPP_SW_PIX_EXT_C1C2_REQ_PIXELS    0x118\n#define SSPP_SW_PIX_EXT_C3_LR              0x120\n#define SSPP_SW_PIX_EXT_C3_TB              0x124\n#define SSPP_SW_PIX_EXT_C3_REQ_PIXELS      0x128\n#define SSPP_TRAFFIC_SHAPER                0x130\n#define SSPP_CDP_CNTL                      0x134\n#define SSPP_UBWC_ERROR_STATUS             0x138\n#define SSPP_CDP_CNTL_REC1                 0x13c\n#define SSPP_TRAFFIC_SHAPER_PREFILL        0x150\n#define SSPP_TRAFFIC_SHAPER_REC1_PREFILL   0x154\n#define SSPP_TRAFFIC_SHAPER_REC1           0x158\n#define SSPP_OUT_SIZE_REC1                 0x160\n#define SSPP_OUT_XY_REC1                   0x164\n#define SSPP_SRC_XY_REC1                   0x168\n#define SSPP_SRC_SIZE_REC1                 0x16C\n#define SSPP_MULTIRECT_OPMODE              0x170\n#define SSPP_SRC_FORMAT_REC1               0x174\n#define SSPP_SRC_UNPACK_PATTERN_REC1       0x178\n#define SSPP_SRC_OP_MODE_REC1              0x17C\n#define SSPP_SRC_CONSTANT_COLOR_REC1       0x180\n#define SSPP_EXCL_REC_SIZE_REC1            0x184\n#define SSPP_EXCL_REC_XY_REC1              0x188\n#define SSPP_EXCL_REC_SIZE                 0x1B4\n#define SSPP_EXCL_REC_XY                   0x1B8\n\n \n#define MDSS_MDP_OP_DEINTERLACE            BIT(22)\n#define MDSS_MDP_OP_DEINTERLACE_ODD        BIT(23)\n#define MDSS_MDP_OP_IGC_ROM_1              BIT(18)\n#define MDSS_MDP_OP_IGC_ROM_0              BIT(17)\n#define MDSS_MDP_OP_IGC_EN                 BIT(16)\n#define MDSS_MDP_OP_FLIP_UD                BIT(14)\n#define MDSS_MDP_OP_FLIP_LR                BIT(13)\n#define MDSS_MDP_OP_BWC_EN                 BIT(0)\n#define MDSS_MDP_OP_PE_OVERRIDE            BIT(31)\n#define MDSS_MDP_OP_BWC_LOSSLESS           (0 << 1)\n#define MDSS_MDP_OP_BWC_Q_HIGH             (1 << 1)\n#define MDSS_MDP_OP_BWC_Q_MED              (2 << 1)\n\n \n#define SSPP_QOS_CTRL_VBLANK_EN            BIT(16)\n#define SSPP_QOS_CTRL_DANGER_SAFE_EN       BIT(0)\n#define SSPP_QOS_CTRL_DANGER_VBLANK_MASK   0x3\n#define SSPP_QOS_CTRL_DANGER_VBLANK_OFF    4\n#define SSPP_QOS_CTRL_CREQ_VBLANK_MASK     0x3\n#define SSPP_QOS_CTRL_CREQ_VBLANK_OFF      20\n\n \n#define SSPP_VIG_OP_MODE                   0x0\n#define SCALE_CONFIG                       0x04\n#define COMP0_3_PHASE_STEP_X               0x10\n#define COMP0_3_PHASE_STEP_Y               0x14\n#define COMP1_2_PHASE_STEP_X               0x18\n#define COMP1_2_PHASE_STEP_Y               0x1c\n#define COMP0_3_INIT_PHASE_X               0x20\n#define COMP0_3_INIT_PHASE_Y               0x24\n#define COMP1_2_INIT_PHASE_X               0x28\n#define COMP1_2_INIT_PHASE_Y               0x2C\n#define VIG_0_QSEED2_SHARP                 0x30\n\n \n#define SSPP_TRAFFIC_SHAPER_BPC_MAX        0xFF\n\n \n#define VIG_OP_CSC_DST_DATAFMT BIT(19)\n#define VIG_OP_CSC_SRC_DATAFMT BIT(18)\n#define VIG_OP_CSC_EN          BIT(17)\n#define VIG_OP_MEM_PROT_CONT   BIT(15)\n#define VIG_OP_MEM_PROT_VAL    BIT(14)\n#define VIG_OP_MEM_PROT_SAT    BIT(13)\n#define VIG_OP_MEM_PROT_HUE    BIT(12)\n#define VIG_OP_HIST            BIT(8)\n#define VIG_OP_SKY_COL         BIT(7)\n#define VIG_OP_FOIL            BIT(6)\n#define VIG_OP_SKIN_COL        BIT(5)\n#define VIG_OP_PA_EN           BIT(4)\n#define VIG_OP_PA_SAT_ZERO_EXP BIT(2)\n#define VIG_OP_MEM_PROT_BLEND  BIT(1)\n\n \n#define SSPP_VIG_CSC_10_OP_MODE            0x0\n#define VIG_CSC_10_SRC_DATAFMT BIT(1)\n#define VIG_CSC_10_EN          BIT(0)\n#define CSC_10BIT_OFFSET       4\n\n \n#define TS_CLK\t\t\t19200000\n\n\nstatic void dpu_hw_sspp_setup_multirect(struct dpu_sw_pipe *pipe)\n{\n\tstruct dpu_hw_sspp *ctx = pipe->sspp;\n\tu32 mode_mask;\n\n\tif (!ctx)\n\t\treturn;\n\n\tif (pipe->multirect_index == DPU_SSPP_RECT_SOLO) {\n\t\t \n\t\tmode_mask = 0;\n\t} else {\n\t\tmode_mask = DPU_REG_READ(&ctx->hw, SSPP_MULTIRECT_OPMODE);\n\t\tmode_mask |= pipe->multirect_index;\n\t\tif (pipe->multirect_mode == DPU_SSPP_MULTIRECT_TIME_MX)\n\t\t\tmode_mask |= BIT(2);\n\t\telse\n\t\t\tmode_mask &= ~BIT(2);\n\t}\n\n\tDPU_REG_WRITE(&ctx->hw, SSPP_MULTIRECT_OPMODE, mode_mask);\n}\n\nstatic void _sspp_setup_opmode(struct dpu_hw_sspp *ctx,\n\t\tu32 mask, u8 en)\n{\n\tconst struct dpu_sspp_sub_blks *sblk = ctx->cap->sblk;\n\tu32 opmode;\n\n\tif (!test_bit(DPU_SSPP_SCALER_QSEED2, &ctx->cap->features) ||\n\t\t!test_bit(DPU_SSPP_CSC, &ctx->cap->features))\n\t\treturn;\n\n\topmode = DPU_REG_READ(&ctx->hw, sblk->scaler_blk.base + SSPP_VIG_OP_MODE);\n\n\tif (en)\n\t\topmode |= mask;\n\telse\n\t\topmode &= ~mask;\n\n\tDPU_REG_WRITE(&ctx->hw, sblk->scaler_blk.base + SSPP_VIG_OP_MODE, opmode);\n}\n\nstatic void _sspp_setup_csc10_opmode(struct dpu_hw_sspp *ctx,\n\t\tu32 mask, u8 en)\n{\n\tconst struct dpu_sspp_sub_blks *sblk = ctx->cap->sblk;\n\tu32 opmode;\n\n\topmode = DPU_REG_READ(&ctx->hw, sblk->csc_blk.base + SSPP_VIG_CSC_10_OP_MODE);\n\tif (en)\n\t\topmode |= mask;\n\telse\n\t\topmode &= ~mask;\n\n\tDPU_REG_WRITE(&ctx->hw, sblk->csc_blk.base + SSPP_VIG_CSC_10_OP_MODE, opmode);\n}\n\n \nstatic void dpu_hw_sspp_setup_format(struct dpu_sw_pipe *pipe,\n\t\tconst struct dpu_format *fmt, u32 flags)\n{\n\tstruct dpu_hw_sspp *ctx = pipe->sspp;\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 chroma_samp, unpack, src_format;\n\tu32 opmode = 0;\n\tu32 fast_clear = 0;\n\tu32 op_mode_off, unpack_pat_off, format_off;\n\n\tif (!ctx || !fmt)\n\t\treturn;\n\n\tif (pipe->multirect_index == DPU_SSPP_RECT_SOLO ||\n\t    pipe->multirect_index == DPU_SSPP_RECT_0) {\n\t\top_mode_off = SSPP_SRC_OP_MODE;\n\t\tunpack_pat_off = SSPP_SRC_UNPACK_PATTERN;\n\t\tformat_off = SSPP_SRC_FORMAT;\n\t} else {\n\t\top_mode_off = SSPP_SRC_OP_MODE_REC1;\n\t\tunpack_pat_off = SSPP_SRC_UNPACK_PATTERN_REC1;\n\t\tformat_off = SSPP_SRC_FORMAT_REC1;\n\t}\n\n\tc = &ctx->hw;\n\topmode = DPU_REG_READ(c, op_mode_off);\n\topmode &= ~(MDSS_MDP_OP_FLIP_LR | MDSS_MDP_OP_FLIP_UD |\n\t\t\tMDSS_MDP_OP_BWC_EN | MDSS_MDP_OP_PE_OVERRIDE);\n\n\tif (flags & DPU_SSPP_FLIP_LR)\n\t\topmode |= MDSS_MDP_OP_FLIP_LR;\n\tif (flags & DPU_SSPP_FLIP_UD)\n\t\topmode |= MDSS_MDP_OP_FLIP_UD;\n\n\tchroma_samp = fmt->chroma_sample;\n\tif (flags & DPU_SSPP_SOURCE_ROTATED_90) {\n\t\tif (chroma_samp == DPU_CHROMA_H2V1)\n\t\t\tchroma_samp = DPU_CHROMA_H1V2;\n\t\telse if (chroma_samp == DPU_CHROMA_H1V2)\n\t\t\tchroma_samp = DPU_CHROMA_H2V1;\n\t}\n\n\tsrc_format = (chroma_samp << 23) | (fmt->fetch_planes << 19) |\n\t\t(fmt->bits[C3_ALPHA] << 6) | (fmt->bits[C2_R_Cr] << 4) |\n\t\t(fmt->bits[C1_B_Cb] << 2) | (fmt->bits[C0_G_Y] << 0);\n\n\tif (flags & DPU_SSPP_ROT_90)\n\t\tsrc_format |= BIT(11);  \n\n\tif (fmt->alpha_enable && fmt->fetch_planes == DPU_PLANE_INTERLEAVED)\n\t\tsrc_format |= BIT(8);  \n\n\tif (flags & DPU_SSPP_SOLID_FILL)\n\t\tsrc_format |= BIT(22);\n\n\tunpack = (fmt->element[3] << 24) | (fmt->element[2] << 16) |\n\t\t(fmt->element[1] << 8) | (fmt->element[0] << 0);\n\tsrc_format |= ((fmt->unpack_count - 1) << 12) |\n\t\t(fmt->unpack_tight << 17) |\n\t\t(fmt->unpack_align_msb << 18) |\n\t\t((fmt->bpp - 1) << 9);\n\n\tif (fmt->fetch_mode != DPU_FETCH_LINEAR) {\n\t\tif (DPU_FORMAT_IS_UBWC(fmt))\n\t\t\topmode |= MDSS_MDP_OP_BWC_EN;\n\t\tsrc_format |= (fmt->fetch_mode & 3) << 30;  \n\t\tDPU_REG_WRITE(c, SSPP_FETCH_CONFIG,\n\t\t\tDPU_FETCH_CONFIG_RESET_VALUE |\n\t\t\tctx->ubwc->highest_bank_bit << 18);\n\t\tswitch (ctx->ubwc->ubwc_enc_version) {\n\t\tcase UBWC_1_0:\n\t\t\tfast_clear = fmt->alpha_enable ? BIT(31) : 0;\n\t\t\tDPU_REG_WRITE(c, SSPP_UBWC_STATIC_CTRL,\n\t\t\t\t\tfast_clear | (ctx->ubwc->ubwc_swizzle & 0x1) |\n\t\t\t\t\tBIT(8) |\n\t\t\t\t\t(ctx->ubwc->highest_bank_bit << 4));\n\t\t\tbreak;\n\t\tcase UBWC_2_0:\n\t\t\tfast_clear = fmt->alpha_enable ? BIT(31) : 0;\n\t\t\tDPU_REG_WRITE(c, SSPP_UBWC_STATIC_CTRL,\n\t\t\t\t\tfast_clear | (ctx->ubwc->ubwc_swizzle) |\n\t\t\t\t\t(ctx->ubwc->highest_bank_bit << 4));\n\t\t\tbreak;\n\t\tcase UBWC_3_0:\n\t\t\tDPU_REG_WRITE(c, SSPP_UBWC_STATIC_CTRL,\n\t\t\t\t\tBIT(30) | (ctx->ubwc->ubwc_swizzle) |\n\t\t\t\t\t(ctx->ubwc->highest_bank_bit << 4));\n\t\t\tbreak;\n\t\tcase UBWC_4_0:\n\t\t\tDPU_REG_WRITE(c, SSPP_UBWC_STATIC_CTRL,\n\t\t\t\t\tDPU_FORMAT_IS_YUV(fmt) ? 0 : BIT(30));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\topmode |= MDSS_MDP_OP_PE_OVERRIDE;\n\n\t \n\tif (DPU_FORMAT_IS_YUV(fmt))\n\t\tsrc_format |= BIT(15);\n\n\tif (DPU_FORMAT_IS_DX(fmt))\n\t\tsrc_format |= BIT(14);\n\n\t \n\tif (test_bit(DPU_SSPP_CSC, &ctx->cap->features))\n\t\t_sspp_setup_opmode(ctx, VIG_OP_CSC_EN | VIG_OP_CSC_SRC_DATAFMT,\n\t\t\tDPU_FORMAT_IS_YUV(fmt));\n\telse if (test_bit(DPU_SSPP_CSC_10BIT, &ctx->cap->features))\n\t\t_sspp_setup_csc10_opmode(ctx,\n\t\t\tVIG_CSC_10_EN | VIG_CSC_10_SRC_DATAFMT,\n\t\t\tDPU_FORMAT_IS_YUV(fmt));\n\n\tDPU_REG_WRITE(c, format_off, src_format);\n\tDPU_REG_WRITE(c, unpack_pat_off, unpack);\n\tDPU_REG_WRITE(c, op_mode_off, opmode);\n\n\t \n\tDPU_REG_WRITE(c, SSPP_UBWC_ERROR_STATUS, BIT(31));\n}\n\nstatic void dpu_hw_sspp_setup_pe_config(struct dpu_hw_sspp *ctx,\n\t\tstruct dpu_hw_pixel_ext *pe_ext)\n{\n\tstruct dpu_hw_blk_reg_map *c;\n\tu8 color;\n\tu32 lr_pe[4], tb_pe[4], tot_req_pixels[4];\n\tconst u32 bytemask = 0xff;\n\tconst u32 shortmask = 0xffff;\n\n\tif (!ctx || !pe_ext)\n\t\treturn;\n\n\tc = &ctx->hw;\n\n\t \n\tfor (color = 0; color < DPU_MAX_PLANES; color++) {\n\t\t \n\t\tif (color == 2)\n\t\t\tcontinue;\n\n\t\tlr_pe[color] = ((pe_ext->right_ftch[color] & bytemask) << 24)|\n\t\t\t((pe_ext->right_rpt[color] & bytemask) << 16)|\n\t\t\t((pe_ext->left_ftch[color] & bytemask) << 8)|\n\t\t\t(pe_ext->left_rpt[color] & bytemask);\n\n\t\ttb_pe[color] = ((pe_ext->btm_ftch[color] & bytemask) << 24)|\n\t\t\t((pe_ext->btm_rpt[color] & bytemask) << 16)|\n\t\t\t((pe_ext->top_ftch[color] & bytemask) << 8)|\n\t\t\t(pe_ext->top_rpt[color] & bytemask);\n\n\t\ttot_req_pixels[color] = (((pe_ext->roi_h[color] +\n\t\t\tpe_ext->num_ext_pxls_top[color] +\n\t\t\tpe_ext->num_ext_pxls_btm[color]) & shortmask) << 16) |\n\t\t\t((pe_ext->roi_w[color] +\n\t\t\tpe_ext->num_ext_pxls_left[color] +\n\t\t\tpe_ext->num_ext_pxls_right[color]) & shortmask);\n\t}\n\n\t \n\tDPU_REG_WRITE(c, SSPP_SW_PIX_EXT_C0_LR, lr_pe[0]);\n\tDPU_REG_WRITE(c, SSPP_SW_PIX_EXT_C0_TB, tb_pe[0]);\n\tDPU_REG_WRITE(c, SSPP_SW_PIX_EXT_C0_REQ_PIXELS,\n\t\t\ttot_req_pixels[0]);\n\n\t \n\tDPU_REG_WRITE(c, SSPP_SW_PIX_EXT_C1C2_LR, lr_pe[1]);\n\tDPU_REG_WRITE(c, SSPP_SW_PIX_EXT_C1C2_TB, tb_pe[1]);\n\tDPU_REG_WRITE(c, SSPP_SW_PIX_EXT_C1C2_REQ_PIXELS,\n\t\t\ttot_req_pixels[1]);\n\n\t \n\tDPU_REG_WRITE(c, SSPP_SW_PIX_EXT_C3_LR, lr_pe[3]);\n\tDPU_REG_WRITE(c, SSPP_SW_PIX_EXT_C3_TB, lr_pe[3]);\n\tDPU_REG_WRITE(c, SSPP_SW_PIX_EXT_C3_REQ_PIXELS,\n\t\t\ttot_req_pixels[3]);\n}\n\nstatic void _dpu_hw_sspp_setup_scaler3(struct dpu_hw_sspp *ctx,\n\t\tstruct dpu_hw_scaler3_cfg *scaler3_cfg,\n\t\tconst struct dpu_format *format)\n{\n\tif (!ctx || !scaler3_cfg)\n\t\treturn;\n\n\tdpu_hw_setup_scaler3(&ctx->hw, scaler3_cfg,\n\t\t\tctx->cap->sblk->scaler_blk.base,\n\t\t\tctx->cap->sblk->scaler_blk.version,\n\t\t\tformat);\n}\n\nstatic u32 _dpu_hw_sspp_get_scaler3_ver(struct dpu_hw_sspp *ctx)\n{\n\tif (!ctx)\n\t\treturn 0;\n\n\treturn dpu_hw_get_scaler3_ver(&ctx->hw,\n\t\t\t\t      ctx->cap->sblk->scaler_blk.base);\n}\n\n \nstatic void dpu_hw_sspp_setup_rects(struct dpu_sw_pipe *pipe,\n\t\tstruct dpu_sw_pipe_cfg *cfg)\n{\n\tstruct dpu_hw_sspp *ctx = pipe->sspp;\n\tstruct dpu_hw_blk_reg_map *c;\n\tu32 src_size, src_xy, dst_size, dst_xy;\n\tu32 src_size_off, src_xy_off, out_size_off, out_xy_off;\n\n\tif (!ctx || !cfg)\n\t\treturn;\n\n\tc = &ctx->hw;\n\n\tif (pipe->multirect_index == DPU_SSPP_RECT_SOLO ||\n\t    pipe->multirect_index == DPU_SSPP_RECT_0) {\n\t\tsrc_size_off = SSPP_SRC_SIZE;\n\t\tsrc_xy_off = SSPP_SRC_XY;\n\t\tout_size_off = SSPP_OUT_SIZE;\n\t\tout_xy_off = SSPP_OUT_XY;\n\t} else {\n\t\tsrc_size_off = SSPP_SRC_SIZE_REC1;\n\t\tsrc_xy_off = SSPP_SRC_XY_REC1;\n\t\tout_size_off = SSPP_OUT_SIZE_REC1;\n\t\tout_xy_off = SSPP_OUT_XY_REC1;\n\t}\n\n\n\t \n\tsrc_xy = (cfg->src_rect.y1 << 16) | cfg->src_rect.x1;\n\tsrc_size = (drm_rect_height(&cfg->src_rect) << 16) |\n\t\t   drm_rect_width(&cfg->src_rect);\n\tdst_xy = (cfg->dst_rect.y1 << 16) | cfg->dst_rect.x1;\n\tdst_size = (drm_rect_height(&cfg->dst_rect) << 16) |\n\t\tdrm_rect_width(&cfg->dst_rect);\n\n\t \n\tDPU_REG_WRITE(c, src_size_off, src_size);\n\tDPU_REG_WRITE(c, src_xy_off, src_xy);\n\tDPU_REG_WRITE(c, out_size_off, dst_size);\n\tDPU_REG_WRITE(c, out_xy_off, dst_xy);\n}\n\nstatic void dpu_hw_sspp_setup_sourceaddress(struct dpu_sw_pipe *pipe,\n\t\tstruct dpu_hw_fmt_layout *layout)\n{\n\tstruct dpu_hw_sspp *ctx = pipe->sspp;\n\tu32 ystride0, ystride1;\n\tint i;\n\n\tif (!ctx)\n\t\treturn;\n\n\tif (pipe->multirect_index == DPU_SSPP_RECT_SOLO) {\n\t\tfor (i = 0; i < ARRAY_SIZE(layout->plane_addr); i++)\n\t\t\tDPU_REG_WRITE(&ctx->hw, SSPP_SRC0_ADDR + i * 0x4,\n\t\t\t\t\tlayout->plane_addr[i]);\n\t} else if (pipe->multirect_index == DPU_SSPP_RECT_0) {\n\t\tDPU_REG_WRITE(&ctx->hw, SSPP_SRC0_ADDR,\n\t\t\t\tlayout->plane_addr[0]);\n\t\tDPU_REG_WRITE(&ctx->hw, SSPP_SRC2_ADDR,\n\t\t\t\tlayout->plane_addr[2]);\n\t} else {\n\t\tDPU_REG_WRITE(&ctx->hw, SSPP_SRC1_ADDR,\n\t\t\t\tlayout->plane_addr[0]);\n\t\tDPU_REG_WRITE(&ctx->hw, SSPP_SRC3_ADDR,\n\t\t\t\tlayout->plane_addr[2]);\n\t}\n\n\tif (pipe->multirect_index == DPU_SSPP_RECT_SOLO) {\n\t\tystride0 = (layout->plane_pitch[0]) |\n\t\t\t(layout->plane_pitch[1] << 16);\n\t\tystride1 = (layout->plane_pitch[2]) |\n\t\t\t(layout->plane_pitch[3] << 16);\n\t} else {\n\t\tystride0 = DPU_REG_READ(&ctx->hw, SSPP_SRC_YSTRIDE0);\n\t\tystride1 = DPU_REG_READ(&ctx->hw, SSPP_SRC_YSTRIDE1);\n\n\t\tif (pipe->multirect_index == DPU_SSPP_RECT_0) {\n\t\t\tystride0 = (ystride0 & 0xFFFF0000) |\n\t\t\t\t(layout->plane_pitch[0] & 0x0000FFFF);\n\t\t\tystride1 = (ystride1 & 0xFFFF0000)|\n\t\t\t\t(layout->plane_pitch[2] & 0x0000FFFF);\n\t\t} else {\n\t\t\tystride0 = (ystride0 & 0x0000FFFF) |\n\t\t\t\t((layout->plane_pitch[0] << 16) &\n\t\t\t\t 0xFFFF0000);\n\t\t\tystride1 = (ystride1 & 0x0000FFFF) |\n\t\t\t\t((layout->plane_pitch[2] << 16) &\n\t\t\t\t 0xFFFF0000);\n\t\t}\n\t}\n\n\tDPU_REG_WRITE(&ctx->hw, SSPP_SRC_YSTRIDE0, ystride0);\n\tDPU_REG_WRITE(&ctx->hw, SSPP_SRC_YSTRIDE1, ystride1);\n}\n\nstatic void dpu_hw_sspp_setup_csc(struct dpu_hw_sspp *ctx,\n\t\tconst struct dpu_csc_cfg *data)\n{\n\tu32 offset;\n\tbool csc10 = false;\n\n\tif (!ctx || !data)\n\t\treturn;\n\n\toffset = ctx->cap->sblk->csc_blk.base;\n\n\tif (test_bit(DPU_SSPP_CSC_10BIT, &ctx->cap->features)) {\n\t\toffset += CSC_10BIT_OFFSET;\n\t\tcsc10 = true;\n\t}\n\n\tdpu_hw_csc_setup(&ctx->hw, offset, data, csc10);\n}\n\nstatic void dpu_hw_sspp_setup_solidfill(struct dpu_sw_pipe *pipe, u32 color)\n{\n\tstruct dpu_hw_sspp *ctx = pipe->sspp;\n\tstruct dpu_hw_fmt_layout cfg;\n\n\tif (!ctx)\n\t\treturn;\n\n\t \n\tmemset(&cfg, 0, sizeof(cfg));\n\tctx->ops.setup_sourceaddress(pipe, &cfg);\n\n\tif (pipe->multirect_index == DPU_SSPP_RECT_SOLO ||\n\t    pipe->multirect_index == DPU_SSPP_RECT_0)\n\t\tDPU_REG_WRITE(&ctx->hw, SSPP_SRC_CONSTANT_COLOR, color);\n\telse\n\t\tDPU_REG_WRITE(&ctx->hw, SSPP_SRC_CONSTANT_COLOR_REC1,\n\t\t\t\tcolor);\n}\n\nstatic void dpu_hw_sspp_setup_qos_lut(struct dpu_hw_sspp *ctx,\n\t\t\t\t      struct dpu_hw_qos_cfg *cfg)\n{\n\tif (!ctx || !cfg)\n\t\treturn;\n\n\t_dpu_hw_setup_qos_lut(&ctx->hw, SSPP_DANGER_LUT,\n\t\t\t      test_bit(DPU_SSPP_QOS_8LVL, &ctx->cap->features),\n\t\t\t      cfg);\n}\n\nstatic void dpu_hw_sspp_setup_qos_ctrl(struct dpu_hw_sspp *ctx,\n\t\t\t\t       bool danger_safe_en)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tDPU_REG_WRITE(&ctx->hw, SSPP_QOS_CTRL,\n\t\t      danger_safe_en ? SSPP_QOS_CTRL_DANGER_SAFE_EN : 0);\n}\n\nstatic void dpu_hw_sspp_setup_cdp(struct dpu_sw_pipe *pipe,\n\t\t\t\t  const struct dpu_format *fmt,\n\t\t\t\t  bool enable)\n{\n\tstruct dpu_hw_sspp *ctx = pipe->sspp;\n\tu32 cdp_cntl_offset = 0;\n\n\tif (!ctx)\n\t\treturn;\n\n\tif (pipe->multirect_index == DPU_SSPP_RECT_SOLO ||\n\t    pipe->multirect_index == DPU_SSPP_RECT_0)\n\t\tcdp_cntl_offset = SSPP_CDP_CNTL;\n\telse\n\t\tcdp_cntl_offset = SSPP_CDP_CNTL_REC1;\n\n\tdpu_setup_cdp(&ctx->hw, cdp_cntl_offset, fmt, enable);\n}\n\nstatic void _setup_layer_ops(struct dpu_hw_sspp *c,\n\t\tunsigned long features)\n{\n\tc->ops.setup_format = dpu_hw_sspp_setup_format;\n\tc->ops.setup_rects = dpu_hw_sspp_setup_rects;\n\tc->ops.setup_sourceaddress = dpu_hw_sspp_setup_sourceaddress;\n\tc->ops.setup_solidfill = dpu_hw_sspp_setup_solidfill;\n\tc->ops.setup_pe = dpu_hw_sspp_setup_pe_config;\n\n\tif (test_bit(DPU_SSPP_QOS, &features)) {\n\t\tc->ops.setup_qos_lut = dpu_hw_sspp_setup_qos_lut;\n\t\tc->ops.setup_qos_ctrl = dpu_hw_sspp_setup_qos_ctrl;\n\t}\n\n\tif (test_bit(DPU_SSPP_CSC, &features) ||\n\t\ttest_bit(DPU_SSPP_CSC_10BIT, &features))\n\t\tc->ops.setup_csc = dpu_hw_sspp_setup_csc;\n\n\tif (test_bit(DPU_SSPP_SMART_DMA_V1, &c->cap->features) ||\n\t\ttest_bit(DPU_SSPP_SMART_DMA_V2, &c->cap->features))\n\t\tc->ops.setup_multirect = dpu_hw_sspp_setup_multirect;\n\n\tif (test_bit(DPU_SSPP_SCALER_QSEED3, &features) ||\n\t\t\ttest_bit(DPU_SSPP_SCALER_QSEED3LITE, &features) ||\n\t\t\ttest_bit(DPU_SSPP_SCALER_QSEED4, &features)) {\n\t\tc->ops.setup_scaler = _dpu_hw_sspp_setup_scaler3;\n\t\tc->ops.get_scaler_ver = _dpu_hw_sspp_get_scaler3_ver;\n\t}\n\n\tif (test_bit(DPU_SSPP_CDP, &features))\n\t\tc->ops.setup_cdp = dpu_hw_sspp_setup_cdp;\n}\n\n#ifdef CONFIG_DEBUG_FS\nint _dpu_hw_sspp_init_debugfs(struct dpu_hw_sspp *hw_pipe, struct dpu_kms *kms,\n\t\t\t      struct dentry *entry)\n{\n\tconst struct dpu_sspp_cfg *cfg = hw_pipe->cap;\n\tconst struct dpu_sspp_sub_blks *sblk = cfg->sblk;\n\tstruct dentry *debugfs_root;\n\tchar sspp_name[32];\n\n\tsnprintf(sspp_name, sizeof(sspp_name), \"%d\", hw_pipe->idx);\n\n\t \n\tdebugfs_root =\n\t\tdebugfs_create_dir(sspp_name, entry);\n\n\t \n\tdebugfs_create_xul(\"features\", 0600,\n\t\t\tdebugfs_root, (unsigned long *)&hw_pipe->cap->features);\n\n\t \n\tdpu_debugfs_create_regset32(\"src_blk\", 0400,\n\t\t\tdebugfs_root,\n\t\t\tcfg->base,\n\t\t\tcfg->len,\n\t\t\tkms);\n\n\tif (cfg->features & BIT(DPU_SSPP_SCALER_QSEED3) ||\n\t\t\tcfg->features & BIT(DPU_SSPP_SCALER_QSEED3LITE) ||\n\t\t\tcfg->features & BIT(DPU_SSPP_SCALER_QSEED2) ||\n\t\t\tcfg->features & BIT(DPU_SSPP_SCALER_QSEED4))\n\t\tdpu_debugfs_create_regset32(\"scaler_blk\", 0400,\n\t\t\t\tdebugfs_root,\n\t\t\t\tsblk->scaler_blk.base + cfg->base,\n\t\t\t\tsblk->scaler_blk.len,\n\t\t\t\tkms);\n\n\tif (cfg->features & BIT(DPU_SSPP_CSC) ||\n\t\t\tcfg->features & BIT(DPU_SSPP_CSC_10BIT))\n\t\tdpu_debugfs_create_regset32(\"csc_blk\", 0400,\n\t\t\t\tdebugfs_root,\n\t\t\t\tsblk->csc_blk.base + cfg->base,\n\t\t\t\tsblk->csc_blk.len,\n\t\t\t\tkms);\n\n\tdebugfs_create_u32(\"xin_id\",\n\t\t\t0400,\n\t\t\tdebugfs_root,\n\t\t\t(u32 *) &cfg->xin_id);\n\tdebugfs_create_u32(\"clk_ctrl\",\n\t\t\t0400,\n\t\t\tdebugfs_root,\n\t\t\t(u32 *) &cfg->clk_ctrl);\n\n\treturn 0;\n}\n#endif\n\nstruct dpu_hw_sspp *dpu_hw_sspp_init(const struct dpu_sspp_cfg *cfg,\n\t\tvoid __iomem *addr, const struct msm_mdss_data *mdss_data)\n{\n\tstruct dpu_hw_sspp *hw_pipe;\n\n\tif (!addr)\n\t\treturn ERR_PTR(-EINVAL);\n\n\thw_pipe = kzalloc(sizeof(*hw_pipe), GFP_KERNEL);\n\tif (!hw_pipe)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thw_pipe->hw.blk_addr = addr + cfg->base;\n\thw_pipe->hw.log_mask = DPU_DBG_MASK_SSPP;\n\n\t \n\thw_pipe->ubwc = mdss_data;\n\thw_pipe->idx = cfg->id;\n\thw_pipe->cap = cfg;\n\t_setup_layer_ops(hw_pipe, hw_pipe->cap->features);\n\n\treturn hw_pipe;\n}\n\nvoid dpu_hw_sspp_destroy(struct dpu_hw_sspp *ctx)\n{\n\tkfree(ctx);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}