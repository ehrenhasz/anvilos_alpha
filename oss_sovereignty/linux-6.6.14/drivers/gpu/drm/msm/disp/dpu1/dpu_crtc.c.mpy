{
  "module_name": "dpu_crtc.c",
  "hash_id": "4820e14c0a164d27efa4801a5330849ebccbab1955e30a1c762131917524c79a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_crtc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm:%s:%d] \" fmt, __func__, __LINE__\n#include <linux/sort.h>\n#include <linux/debugfs.h>\n#include <linux/ktime.h>\n#include <linux/bits.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_flip_work.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_mode.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_rect.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_self_refresh_helper.h>\n\n#include \"dpu_kms.h\"\n#include \"dpu_hw_lm.h\"\n#include \"dpu_hw_ctl.h\"\n#include \"dpu_hw_dspp.h\"\n#include \"dpu_crtc.h\"\n#include \"dpu_plane.h\"\n#include \"dpu_encoder.h\"\n#include \"dpu_vbif.h\"\n#include \"dpu_core_perf.h\"\n#include \"dpu_trace.h\"\n\n \n#define LEFT_MIXER 0\n#define RIGHT_MIXER 1\n\n \n#define DPU_CRTC_FRAME_DONE_TIMEOUT_MS\t60\n\n#define\tCONVERT_S3_15(val) \\\n\t(((((u64)val) & ~BIT_ULL(63)) >> 17) & GENMASK_ULL(17, 0))\n\nstatic struct dpu_kms *_dpu_crtc_get_kms(struct drm_crtc *crtc)\n{\n\tstruct msm_drm_private *priv = crtc->dev->dev_private;\n\n\treturn to_dpu_kms(priv->kms);\n}\n\nstatic void dpu_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\n\tif (!crtc)\n\t\treturn;\n\n\tdrm_crtc_cleanup(crtc);\n\tkfree(dpu_crtc);\n}\n\nstatic struct drm_encoder *get_encoder_from_crtc(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_encoder *encoder;\n\n\tdrm_for_each_encoder(encoder, dev)\n\t\tif (encoder->crtc == crtc)\n\t\t\treturn encoder;\n\n\treturn NULL;\n}\n\nstatic enum dpu_crtc_crc_source dpu_crtc_parse_crc_source(const char *src_name)\n{\n\tif (!src_name ||\n\t    !strcmp(src_name, \"none\"))\n\t\treturn DPU_CRTC_CRC_SOURCE_NONE;\n\tif (!strcmp(src_name, \"auto\") ||\n\t    !strcmp(src_name, \"lm\"))\n\t\treturn DPU_CRTC_CRC_SOURCE_LAYER_MIXER;\n\tif (!strcmp(src_name, \"encoder\"))\n\t\treturn DPU_CRTC_CRC_SOURCE_ENCODER;\n\n\treturn DPU_CRTC_CRC_SOURCE_INVALID;\n}\n\nstatic int dpu_crtc_verify_crc_source(struct drm_crtc *crtc,\n\t\tconst char *src_name, size_t *values_cnt)\n{\n\tenum dpu_crtc_crc_source source = dpu_crtc_parse_crc_source(src_name);\n\tstruct dpu_crtc_state *crtc_state = to_dpu_crtc_state(crtc->state);\n\n\tif (source < 0) {\n\t\tDRM_DEBUG_DRIVER(\"Invalid source %s for CRTC%d\\n\", src_name, crtc->index);\n\t\treturn -EINVAL;\n\t}\n\n\tif (source == DPU_CRTC_CRC_SOURCE_LAYER_MIXER) {\n\t\t*values_cnt = crtc_state->num_mixers;\n\t} else if (source == DPU_CRTC_CRC_SOURCE_ENCODER) {\n\t\tstruct drm_encoder *drm_enc;\n\n\t\t*values_cnt = 0;\n\n\t\tdrm_for_each_encoder_mask(drm_enc, crtc->dev, crtc->state->encoder_mask)\n\t\t\t*values_cnt += dpu_encoder_get_crc_values_cnt(drm_enc);\n\t}\n\n\treturn 0;\n}\n\nstatic void dpu_crtc_setup_lm_misr(struct dpu_crtc_state *crtc_state)\n{\n\tstruct dpu_crtc_mixer *m;\n\tint i;\n\n\tfor (i = 0; i < crtc_state->num_mixers; ++i) {\n\t\tm = &crtc_state->mixers[i];\n\n\t\tif (!m->hw_lm || !m->hw_lm->ops.setup_misr)\n\t\t\tcontinue;\n\n\t\t \n\t\tm->hw_lm->ops.setup_misr(m->hw_lm);\n\t}\n}\n\nstatic void dpu_crtc_setup_encoder_misr(struct drm_crtc *crtc)\n{\n\tstruct drm_encoder *drm_enc;\n\n\tdrm_for_each_encoder_mask(drm_enc, crtc->dev, crtc->state->encoder_mask)\n\t\tdpu_encoder_setup_misr(drm_enc);\n}\n\nstatic int dpu_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)\n{\n\tenum dpu_crtc_crc_source source = dpu_crtc_parse_crc_source(src_name);\n\tenum dpu_crtc_crc_source current_source;\n\tstruct dpu_crtc_state *crtc_state;\n\tstruct drm_device *drm_dev = crtc->dev;\n\n\tbool was_enabled;\n\tbool enable = false;\n\tint ret = 0;\n\n\tif (source < 0) {\n\t\tDRM_DEBUG_DRIVER(\"Invalid CRC source %s for CRTC%d\\n\", src_name, crtc->index);\n\t\treturn -EINVAL;\n\t}\n\n\tret = drm_modeset_lock(&crtc->mutex, NULL);\n\n\tif (ret)\n\t\treturn ret;\n\n\tenable = (source != DPU_CRTC_CRC_SOURCE_NONE);\n\tcrtc_state = to_dpu_crtc_state(crtc->state);\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\tcurrent_source = crtc_state->crc_source;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\twas_enabled = (current_source != DPU_CRTC_CRC_SOURCE_NONE);\n\n\tif (!was_enabled && enable) {\n\t\tret = drm_crtc_vblank_get(crtc);\n\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\n\t} else if (was_enabled && !enable) {\n\t\tdrm_crtc_vblank_put(crtc);\n\t}\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\tcrtc_state->crc_source = source;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\tcrtc_state->crc_frame_skip_count = 0;\n\n\tif (source == DPU_CRTC_CRC_SOURCE_LAYER_MIXER)\n\t\tdpu_crtc_setup_lm_misr(crtc_state);\n\telse if (source == DPU_CRTC_CRC_SOURCE_ENCODER)\n\t\tdpu_crtc_setup_encoder_misr(crtc);\n\telse\n\t\tret = -EINVAL;\n\ncleanup:\n\tdrm_modeset_unlock(&crtc->mutex);\n\n\treturn ret;\n}\n\nstatic u32 dpu_crtc_get_vblank_counter(struct drm_crtc *crtc)\n{\n\tstruct drm_encoder *encoder = get_encoder_from_crtc(crtc);\n\tif (!encoder) {\n\t\tDRM_ERROR(\"no encoder found for crtc %d\\n\", crtc->index);\n\t\treturn 0;\n\t}\n\n\treturn dpu_encoder_get_vsync_count(encoder);\n}\n\nstatic int dpu_crtc_get_lm_crc(struct drm_crtc *crtc,\n\t\tstruct dpu_crtc_state *crtc_state)\n{\n\tstruct dpu_crtc_mixer *m;\n\tu32 crcs[CRTC_DUAL_MIXERS];\n\n\tint rc = 0;\n\tint i;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(crcs) != ARRAY_SIZE(crtc_state->mixers));\n\n\tfor (i = 0; i < crtc_state->num_mixers; ++i) {\n\n\t\tm = &crtc_state->mixers[i];\n\n\t\tif (!m->hw_lm || !m->hw_lm->ops.collect_misr)\n\t\t\tcontinue;\n\n\t\trc = m->hw_lm->ops.collect_misr(m->hw_lm, &crcs[i]);\n\n\t\tif (rc) {\n\t\t\tif (rc != -ENODATA)\n\t\t\t\tDRM_DEBUG_DRIVER(\"MISR read failed\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn drm_crtc_add_crc_entry(crtc, true,\n\t\t\tdrm_crtc_accurate_vblank_count(crtc), crcs);\n}\n\nstatic int dpu_crtc_get_encoder_crc(struct drm_crtc *crtc)\n{\n\tstruct drm_encoder *drm_enc;\n\tint rc, pos = 0;\n\tu32 crcs[INTF_MAX];\n\n\tdrm_for_each_encoder_mask(drm_enc, crtc->dev, crtc->state->encoder_mask) {\n\t\trc = dpu_encoder_get_crc(drm_enc, crcs, pos);\n\t\tif (rc < 0) {\n\t\t\tif (rc != -ENODATA)\n\t\t\t\tDRM_DEBUG_DRIVER(\"MISR read failed\\n\");\n\n\t\t\treturn rc;\n\t\t}\n\n\t\tpos += rc;\n\t}\n\n\treturn drm_crtc_add_crc_entry(crtc, true,\n\t\t\tdrm_crtc_accurate_vblank_count(crtc), crcs);\n}\n\nstatic int dpu_crtc_get_crc(struct drm_crtc *crtc)\n{\n\tstruct dpu_crtc_state *crtc_state = to_dpu_crtc_state(crtc->state);\n\n\t \n\tif (crtc_state->crc_frame_skip_count < 2) {\n\t\tcrtc_state->crc_frame_skip_count++;\n\t\treturn 0;\n\t}\n\n\tif (crtc_state->crc_source == DPU_CRTC_CRC_SOURCE_LAYER_MIXER)\n\t\treturn dpu_crtc_get_lm_crc(crtc, crtc_state);\n\telse if (crtc_state->crc_source == DPU_CRTC_CRC_SOURCE_ENCODER)\n\t\treturn dpu_crtc_get_encoder_crc(crtc);\n\n\treturn -EINVAL;\n}\n\nstatic bool dpu_crtc_get_scanout_position(struct drm_crtc *crtc,\n\t\t\t\t\t   bool in_vblank_irq,\n\t\t\t\t\t   int *vpos, int *hpos,\n\t\t\t\t\t   ktime_t *stime, ktime_t *etime,\n\t\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tunsigned int pipe = crtc->index;\n\tstruct drm_encoder *encoder;\n\tint line, vsw, vbp, vactive_start, vactive_end, vfp_end;\n\n\tencoder = get_encoder_from_crtc(crtc);\n\tif (!encoder) {\n\t\tDRM_ERROR(\"no encoder found for crtc %d\\n\", pipe);\n\t\treturn false;\n\t}\n\n\tvsw = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\tvbp = mode->crtc_vtotal - mode->crtc_vsync_end;\n\n\t \n\n\tvactive_start = vsw + vbp + 1;\n\tvactive_end = vactive_start + mode->crtc_vdisplay;\n\n\t \n\tvfp_end = mode->crtc_vtotal;\n\n\tif (stime)\n\t\t*stime = ktime_get();\n\n\tline = dpu_encoder_get_linecount(encoder);\n\n\tif (line < vactive_start)\n\t\tline -= vactive_start;\n\telse if (line > vactive_end)\n\t\tline = line - vfp_end - vactive_start;\n\telse\n\t\tline -= vactive_start;\n\n\t*vpos = line;\n\t*hpos = 0;\n\n\tif (etime)\n\t\t*etime = ktime_get();\n\n\treturn true;\n}\n\nstatic void _dpu_crtc_setup_blend_cfg(struct dpu_crtc_mixer *mixer,\n\t\tstruct dpu_plane_state *pstate, struct dpu_format *format)\n{\n\tstruct dpu_hw_mixer *lm = mixer->hw_lm;\n\tuint32_t blend_op;\n\tuint32_t fg_alpha, bg_alpha;\n\n\tfg_alpha = pstate->base.alpha >> 8;\n\tbg_alpha = 0xff - fg_alpha;\n\n\t \n\tif (pstate->base.pixel_blend_mode == DRM_MODE_BLEND_PIXEL_NONE ||\n\t    !format->alpha_enable) {\n\t\tblend_op = DPU_BLEND_FG_ALPHA_FG_CONST |\n\t\t\tDPU_BLEND_BG_ALPHA_BG_CONST;\n\t} else if (pstate->base.pixel_blend_mode == DRM_MODE_BLEND_PREMULTI) {\n\t\tblend_op = DPU_BLEND_FG_ALPHA_FG_CONST |\n\t\t\tDPU_BLEND_BG_ALPHA_FG_PIXEL;\n\t\tif (fg_alpha != 0xff) {\n\t\t\tbg_alpha = fg_alpha;\n\t\t\tblend_op |= DPU_BLEND_BG_MOD_ALPHA |\n\t\t\t\t    DPU_BLEND_BG_INV_MOD_ALPHA;\n\t\t} else {\n\t\t\tblend_op |= DPU_BLEND_BG_INV_ALPHA;\n\t\t}\n\t} else {\n\t\t \n\t\tblend_op = DPU_BLEND_FG_ALPHA_FG_PIXEL |\n\t\t\tDPU_BLEND_BG_ALPHA_FG_PIXEL;\n\t\tif (fg_alpha != 0xff) {\n\t\t\tbg_alpha = fg_alpha;\n\t\t\tblend_op |= DPU_BLEND_FG_MOD_ALPHA |\n\t\t\t\t    DPU_BLEND_FG_INV_MOD_ALPHA |\n\t\t\t\t    DPU_BLEND_BG_MOD_ALPHA |\n\t\t\t\t    DPU_BLEND_BG_INV_MOD_ALPHA;\n\t\t} else {\n\t\t\tblend_op |= DPU_BLEND_BG_INV_ALPHA;\n\t\t}\n\t}\n\n\tlm->ops.setup_blend_config(lm, pstate->stage,\n\t\t\t\tfg_alpha, bg_alpha, blend_op);\n\n\tDRM_DEBUG_ATOMIC(\"format:%p4cc, alpha_en:%u blend_op:0x%x\\n\",\n\t\t  &format->base.pixel_format, format->alpha_enable, blend_op);\n}\n\nstatic void _dpu_crtc_program_lm_output_roi(struct drm_crtc *crtc)\n{\n\tstruct dpu_crtc_state *crtc_state;\n\tint lm_idx, lm_horiz_position;\n\n\tcrtc_state = to_dpu_crtc_state(crtc->state);\n\n\tlm_horiz_position = 0;\n\tfor (lm_idx = 0; lm_idx < crtc_state->num_mixers; lm_idx++) {\n\t\tconst struct drm_rect *lm_roi = &crtc_state->lm_bounds[lm_idx];\n\t\tstruct dpu_hw_mixer *hw_lm = crtc_state->mixers[lm_idx].hw_lm;\n\t\tstruct dpu_hw_mixer_cfg cfg;\n\n\t\tif (!lm_roi || !drm_rect_visible(lm_roi))\n\t\t\tcontinue;\n\n\t\tcfg.out_width = drm_rect_width(lm_roi);\n\t\tcfg.out_height = drm_rect_height(lm_roi);\n\t\tcfg.right_mixer = lm_horiz_position++;\n\t\tcfg.flags = 0;\n\t\thw_lm->ops.setup_mixer_out(hw_lm, &cfg);\n\t}\n}\n\nstatic void _dpu_crtc_blend_setup_pipe(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_plane *plane,\n\t\t\t\t       struct dpu_crtc_mixer *mixer,\n\t\t\t\t       u32 num_mixers,\n\t\t\t\t       enum dpu_stage stage,\n\t\t\t\t       struct dpu_format *format,\n\t\t\t\t       uint64_t modifier,\n\t\t\t\t       struct dpu_sw_pipe *pipe,\n\t\t\t\t       unsigned int stage_idx,\n\t\t\t\t       struct dpu_hw_stage_cfg *stage_cfg\n\t\t\t\t      )\n{\n\tuint32_t lm_idx;\n\tenum dpu_sspp sspp_idx;\n\tstruct drm_plane_state *state;\n\n\tsspp_idx = pipe->sspp->idx;\n\n\tstate = plane->state;\n\n\ttrace_dpu_crtc_setup_mixer(DRMID(crtc), DRMID(plane),\n\t\t\t\t   state, to_dpu_plane_state(state), stage_idx,\n\t\t\t\t   format->base.pixel_format,\n\t\t\t\t   modifier);\n\n\tDRM_DEBUG_ATOMIC(\"crtc %d stage:%d - plane %d sspp %d fb %d multirect_idx %d\\n\",\n\t\t\t crtc->base.id,\n\t\t\t stage,\n\t\t\t plane->base.id,\n\t\t\t sspp_idx - SSPP_NONE,\n\t\t\t state->fb ? state->fb->base.id : -1,\n\t\t\t pipe->multirect_index);\n\n\tstage_cfg->stage[stage][stage_idx] = sspp_idx;\n\tstage_cfg->multirect_index[stage][stage_idx] = pipe->multirect_index;\n\n\t \n\tfor (lm_idx = 0; lm_idx < num_mixers; lm_idx++)\n\t\tmixer[lm_idx].lm_ctl->ops.update_pending_flush_sspp(mixer[lm_idx].lm_ctl, sspp_idx);\n}\n\nstatic void _dpu_crtc_blend_setup_mixer(struct drm_crtc *crtc,\n\tstruct dpu_crtc *dpu_crtc, struct dpu_crtc_mixer *mixer,\n\tstruct dpu_hw_stage_cfg *stage_cfg)\n{\n\tstruct drm_plane *plane;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_plane_state *state;\n\tstruct dpu_crtc_state *cstate = to_dpu_crtc_state(crtc->state);\n\tstruct dpu_plane_state *pstate = NULL;\n\tstruct dpu_format *format;\n\tstruct dpu_hw_ctl *ctl = mixer->lm_ctl;\n\n\tuint32_t lm_idx;\n\tbool bg_alpha_enable = false;\n\tDECLARE_BITMAP(fetch_active, SSPP_MAX);\n\n\tmemset(fetch_active, 0, sizeof(fetch_active));\n\tdrm_atomic_crtc_for_each_plane(plane, crtc) {\n\t\tstate = plane->state;\n\t\tif (!state)\n\t\t\tcontinue;\n\n\t\tif (!state->visible)\n\t\t\tcontinue;\n\n\t\tpstate = to_dpu_plane_state(state);\n\t\tfb = state->fb;\n\n\t\tformat = to_dpu_format(msm_framebuffer_format(pstate->base.fb));\n\n\t\tif (pstate->stage == DPU_STAGE_BASE && format->alpha_enable)\n\t\t\tbg_alpha_enable = true;\n\n\t\tset_bit(pstate->pipe.sspp->idx, fetch_active);\n\t\t_dpu_crtc_blend_setup_pipe(crtc, plane,\n\t\t\t\t\t   mixer, cstate->num_mixers,\n\t\t\t\t\t   pstate->stage,\n\t\t\t\t\t   format, fb ? fb->modifier : 0,\n\t\t\t\t\t   &pstate->pipe, 0, stage_cfg);\n\n\t\tif (pstate->r_pipe.sspp) {\n\t\t\tset_bit(pstate->r_pipe.sspp->idx, fetch_active);\n\t\t\t_dpu_crtc_blend_setup_pipe(crtc, plane,\n\t\t\t\t\t\t   mixer, cstate->num_mixers,\n\t\t\t\t\t\t   pstate->stage,\n\t\t\t\t\t\t   format, fb ? fb->modifier : 0,\n\t\t\t\t\t\t   &pstate->r_pipe, 1, stage_cfg);\n\t\t}\n\n\t\t \n\t\tfor (lm_idx = 0; lm_idx < cstate->num_mixers; lm_idx++) {\n\t\t\t_dpu_crtc_setup_blend_cfg(mixer + lm_idx, pstate, format);\n\n\t\t\tif (bg_alpha_enable && !format->alpha_enable)\n\t\t\t\tmixer[lm_idx].mixer_op_mode = 0;\n\t\t\telse\n\t\t\t\tmixer[lm_idx].mixer_op_mode |=\n\t\t\t\t\t\t1 << pstate->stage;\n\t\t}\n\t}\n\n\tif (ctl->ops.set_active_pipes)\n\t\tctl->ops.set_active_pipes(ctl, fetch_active);\n\n\t_dpu_crtc_program_lm_output_roi(crtc);\n}\n\n \nstatic void _dpu_crtc_blend_setup(struct drm_crtc *crtc)\n{\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\tstruct dpu_crtc_state *cstate = to_dpu_crtc_state(crtc->state);\n\tstruct dpu_crtc_mixer *mixer = cstate->mixers;\n\tstruct dpu_hw_ctl *ctl;\n\tstruct dpu_hw_mixer *lm;\n\tstruct dpu_hw_stage_cfg stage_cfg;\n\tint i;\n\n\tDRM_DEBUG_ATOMIC(\"%s\\n\", dpu_crtc->name);\n\n\tfor (i = 0; i < cstate->num_mixers; i++) {\n\t\tmixer[i].mixer_op_mode = 0;\n\t\tif (mixer[i].lm_ctl->ops.clear_all_blendstages)\n\t\t\tmixer[i].lm_ctl->ops.clear_all_blendstages(\n\t\t\t\t\tmixer[i].lm_ctl);\n\t}\n\n\t \n\tmemset(&stage_cfg, 0, sizeof(struct dpu_hw_stage_cfg));\n\n\t_dpu_crtc_blend_setup_mixer(crtc, dpu_crtc, mixer, &stage_cfg);\n\n\tfor (i = 0; i < cstate->num_mixers; i++) {\n\t\tctl = mixer[i].lm_ctl;\n\t\tlm = mixer[i].hw_lm;\n\n\t\tlm->ops.setup_alpha_out(lm, mixer[i].mixer_op_mode);\n\n\t\t \n\t\tctl->ops.update_pending_flush_mixer(ctl,\n\t\t\tmixer[i].hw_lm->idx);\n\n\t\tDRM_DEBUG_ATOMIC(\"lm %d, op_mode 0x%X, ctl %d\\n\",\n\t\t\tmixer[i].hw_lm->idx - LM_0,\n\t\t\tmixer[i].mixer_op_mode,\n\t\t\tctl->idx - CTL_0);\n\n\t\tctl->ops.setup_blendstage(ctl, mixer[i].hw_lm->idx,\n\t\t\t&stage_cfg);\n\t}\n}\n\n \nstatic void _dpu_crtc_complete_flip(struct drm_crtc *crtc)\n{\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tif (dpu_crtc->event) {\n\t\tDRM_DEBUG_VBL(\"%s: send event: %pK\\n\", dpu_crtc->name,\n\t\t\t      dpu_crtc->event);\n\t\ttrace_dpu_crtc_complete_flip(DRMID(crtc));\n\t\tdrm_crtc_send_vblank_event(crtc, dpu_crtc->event);\n\t\tdpu_crtc->event = NULL;\n\t}\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\nenum dpu_intf_mode dpu_crtc_get_intf_mode(struct drm_crtc *crtc)\n{\n\tstruct drm_encoder *encoder;\n\n\t \n\tWARN_ON(!drm_modeset_is_locked(&crtc->mutex));\n\n\t \n\tdrm_for_each_encoder_mask(encoder, crtc->dev, crtc->state->encoder_mask)\n\t\treturn dpu_encoder_get_intf_mode(encoder);\n\n\treturn INTF_MODE_NONE;\n}\n\nvoid dpu_crtc_vblank_callback(struct drm_crtc *crtc)\n{\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\n\t \n\tif (ktime_compare(dpu_crtc->vblank_cb_time, ktime_set(0, 0)) == 0)\n\t\tdpu_crtc->vblank_cb_time = ktime_get();\n\telse\n\t\tdpu_crtc->vblank_cb_count++;\n\n\tdpu_crtc_get_crc(crtc);\n\n\tdrm_crtc_handle_vblank(crtc);\n\ttrace_dpu_crtc_vblank_cb(DRMID(crtc));\n}\n\nstatic void dpu_crtc_frame_event_work(struct kthread_work *work)\n{\n\tstruct dpu_crtc_frame_event *fevent = container_of(work,\n\t\t\tstruct dpu_crtc_frame_event, work);\n\tstruct drm_crtc *crtc = fevent->crtc;\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\tunsigned long flags;\n\tbool frame_done = false;\n\n\tDPU_ATRACE_BEGIN(\"crtc_frame_event\");\n\n\tDRM_DEBUG_ATOMIC(\"crtc%d event:%u ts:%lld\\n\", crtc->base.id, fevent->event,\n\t\t\tktime_to_ns(fevent->ts));\n\n\tif (fevent->event & (DPU_ENCODER_FRAME_EVENT_DONE\n\t\t\t\t| DPU_ENCODER_FRAME_EVENT_ERROR\n\t\t\t\t| DPU_ENCODER_FRAME_EVENT_PANEL_DEAD)) {\n\n\t\tif (atomic_read(&dpu_crtc->frame_pending) < 1) {\n\t\t\t \n\t\t} else if (atomic_dec_return(&dpu_crtc->frame_pending) == 0) {\n\t\t\t \n\t\t\ttrace_dpu_crtc_frame_event_done(DRMID(crtc),\n\t\t\t\t\t\t\tfevent->event);\n\t\t\tdpu_core_perf_crtc_release_bw(crtc);\n\t\t} else {\n\t\t\ttrace_dpu_crtc_frame_event_more_pending(DRMID(crtc),\n\t\t\t\t\t\t\t\tfevent->event);\n\t\t}\n\n\t\tif (fevent->event & (DPU_ENCODER_FRAME_EVENT_DONE\n\t\t\t\t\t| DPU_ENCODER_FRAME_EVENT_ERROR))\n\t\t\tframe_done = true;\n\t}\n\n\tif (fevent->event & DPU_ENCODER_FRAME_EVENT_PANEL_DEAD)\n\t\tDPU_ERROR(\"crtc%d ts:%lld received panel dead event\\n\",\n\t\t\t\tcrtc->base.id, ktime_to_ns(fevent->ts));\n\n\tif (frame_done)\n\t\tcomplete_all(&dpu_crtc->frame_done_comp);\n\n\tspin_lock_irqsave(&dpu_crtc->spin_lock, flags);\n\tlist_add_tail(&fevent->list, &dpu_crtc->frame_event_list);\n\tspin_unlock_irqrestore(&dpu_crtc->spin_lock, flags);\n\tDPU_ATRACE_END(\"crtc_frame_event\");\n}\n\n \nstatic void dpu_crtc_frame_event_cb(void *data, u32 event)\n{\n\tstruct drm_crtc *crtc = (struct drm_crtc *)data;\n\tstruct dpu_crtc *dpu_crtc;\n\tstruct msm_drm_private *priv;\n\tstruct dpu_crtc_frame_event *fevent;\n\tunsigned long flags;\n\tu32 crtc_id;\n\n\t \n\tif (event & DPU_ENCODER_FRAME_EVENT_IDLE)\n\t\treturn;\n\n\tdpu_crtc = to_dpu_crtc(crtc);\n\tpriv = crtc->dev->dev_private;\n\tcrtc_id = drm_crtc_index(crtc);\n\n\ttrace_dpu_crtc_frame_event_cb(DRMID(crtc), event);\n\n\tspin_lock_irqsave(&dpu_crtc->spin_lock, flags);\n\tfevent = list_first_entry_or_null(&dpu_crtc->frame_event_list,\n\t\t\tstruct dpu_crtc_frame_event, list);\n\tif (fevent)\n\t\tlist_del_init(&fevent->list);\n\tspin_unlock_irqrestore(&dpu_crtc->spin_lock, flags);\n\n\tif (!fevent) {\n\t\tDRM_ERROR_RATELIMITED(\"crtc%d event %d overflow\\n\", crtc->base.id, event);\n\t\treturn;\n\t}\n\n\tfevent->event = event;\n\tfevent->crtc = crtc;\n\tfevent->ts = ktime_get();\n\tkthread_queue_work(priv->event_thread[crtc_id].worker, &fevent->work);\n}\n\nvoid dpu_crtc_complete_commit(struct drm_crtc *crtc)\n{\n\ttrace_dpu_crtc_complete_commit(DRMID(crtc));\n\tdpu_core_perf_crtc_update(crtc, 0);\n\t_dpu_crtc_complete_flip(crtc);\n}\n\nstatic void _dpu_crtc_setup_lm_bounds(struct drm_crtc *crtc,\n\t\tstruct drm_crtc_state *state)\n{\n\tstruct dpu_crtc_state *cstate = to_dpu_crtc_state(state);\n\tstruct drm_display_mode *adj_mode = &state->adjusted_mode;\n\tu32 crtc_split_width = adj_mode->hdisplay / cstate->num_mixers;\n\tint i;\n\n\tfor (i = 0; i < cstate->num_mixers; i++) {\n\t\tstruct drm_rect *r = &cstate->lm_bounds[i];\n\t\tr->x1 = crtc_split_width * i;\n\t\tr->y1 = 0;\n\t\tr->x2 = r->x1 + crtc_split_width;\n\t\tr->y2 = adj_mode->vdisplay;\n\n\t\ttrace_dpu_crtc_setup_lm_bounds(DRMID(crtc), i, r);\n\t}\n}\n\nstatic void _dpu_crtc_get_pcc_coeff(struct drm_crtc_state *state,\n\t\tstruct dpu_hw_pcc_cfg *cfg)\n{\n\tstruct drm_color_ctm *ctm;\n\n\tmemset(cfg, 0, sizeof(struct dpu_hw_pcc_cfg));\n\n\tctm = (struct drm_color_ctm *)state->ctm->data;\n\n\tif (!ctm)\n\t\treturn;\n\n\tcfg->r.r = CONVERT_S3_15(ctm->matrix[0]);\n\tcfg->g.r = CONVERT_S3_15(ctm->matrix[1]);\n\tcfg->b.r = CONVERT_S3_15(ctm->matrix[2]);\n\n\tcfg->r.g = CONVERT_S3_15(ctm->matrix[3]);\n\tcfg->g.g = CONVERT_S3_15(ctm->matrix[4]);\n\tcfg->b.g = CONVERT_S3_15(ctm->matrix[5]);\n\n\tcfg->r.b = CONVERT_S3_15(ctm->matrix[6]);\n\tcfg->g.b = CONVERT_S3_15(ctm->matrix[7]);\n\tcfg->b.b = CONVERT_S3_15(ctm->matrix[8]);\n}\n\nstatic void _dpu_crtc_setup_cp_blocks(struct drm_crtc *crtc)\n{\n\tstruct drm_crtc_state *state = crtc->state;\n\tstruct dpu_crtc_state *cstate = to_dpu_crtc_state(crtc->state);\n\tstruct dpu_crtc_mixer *mixer = cstate->mixers;\n\tstruct dpu_hw_pcc_cfg cfg;\n\tstruct dpu_hw_ctl *ctl;\n\tstruct dpu_hw_dspp *dspp;\n\tint i;\n\n\n\tif (!state->color_mgmt_changed && !drm_atomic_crtc_needs_modeset(state))\n\t\treturn;\n\n\tfor (i = 0; i < cstate->num_mixers; i++) {\n\t\tctl = mixer[i].lm_ctl;\n\t\tdspp = mixer[i].hw_dspp;\n\n\t\tif (!dspp || !dspp->ops.setup_pcc)\n\t\t\tcontinue;\n\n\t\tif (!state->ctm) {\n\t\t\tdspp->ops.setup_pcc(dspp, NULL);\n\t\t} else {\n\t\t\t_dpu_crtc_get_pcc_coeff(state, &cfg);\n\t\t\tdspp->ops.setup_pcc(dspp, &cfg);\n\t\t}\n\n\t\t \n\t\tctl->ops.update_pending_flush_dspp(ctl,\n\t\t\tmixer[i].hw_dspp->idx, DPU_DSPP_PCC);\n\t}\n}\n\nstatic void dpu_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\tstruct drm_atomic_state *state)\n{\n\tstruct dpu_crtc_state *cstate = to_dpu_crtc_state(crtc->state);\n\tstruct drm_encoder *encoder;\n\n\tif (!crtc->state->enable) {\n\t\tDRM_DEBUG_ATOMIC(\"crtc%d -> enable %d, skip atomic_begin\\n\",\n\t\t\t\tcrtc->base.id, crtc->state->enable);\n\t\treturn;\n\t}\n\n\tDRM_DEBUG_ATOMIC(\"crtc%d\\n\", crtc->base.id);\n\n\t_dpu_crtc_setup_lm_bounds(crtc, crtc->state);\n\n\t \n\tdrm_for_each_encoder_mask(encoder, crtc->dev, crtc->state->encoder_mask)\n\t\tdpu_encoder_trigger_kickoff_pending(encoder);\n\n\t \n\tif (unlikely(!cstate->num_mixers))\n\t\treturn;\n\n\t_dpu_crtc_blend_setup(crtc);\n\n\t_dpu_crtc_setup_cp_blocks(crtc);\n\n\t \n}\n\nstatic void dpu_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\tstruct drm_atomic_state *state)\n{\n\tstruct dpu_crtc *dpu_crtc;\n\tstruct drm_device *dev;\n\tstruct drm_plane *plane;\n\tstruct msm_drm_private *priv;\n\tunsigned long flags;\n\tstruct dpu_crtc_state *cstate;\n\n\tif (!crtc->state->enable) {\n\t\tDRM_DEBUG_ATOMIC(\"crtc%d -> enable %d, skip atomic_flush\\n\",\n\t\t\t\tcrtc->base.id, crtc->state->enable);\n\t\treturn;\n\t}\n\n\tDRM_DEBUG_ATOMIC(\"crtc%d\\n\", crtc->base.id);\n\n\tdpu_crtc = to_dpu_crtc(crtc);\n\tcstate = to_dpu_crtc_state(crtc->state);\n\tdev = crtc->dev;\n\tpriv = dev->dev_private;\n\n\tif (crtc->index >= ARRAY_SIZE(priv->event_thread)) {\n\t\tDPU_ERROR(\"invalid crtc index[%d]\\n\", crtc->index);\n\t\treturn;\n\t}\n\n\tWARN_ON(dpu_crtc->event);\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tdpu_crtc->event = crtc->state->event;\n\tcrtc->state->event = NULL;\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\t \n\tif (unlikely(!cstate->num_mixers))\n\t\treturn;\n\n\t \n\tdpu_core_perf_crtc_update(crtc, 1);\n\n\t \n\tdrm_atomic_crtc_for_each_plane(plane, crtc) {\n\t\tif (dpu_crtc->smmu_state.transition_error)\n\t\t\tdpu_plane_set_error(plane, true);\n\t\tdpu_plane_flush(plane);\n\t}\n\n\t \n}\n\n \nstatic void dpu_crtc_destroy_state(struct drm_crtc *crtc,\n\t\tstruct drm_crtc_state *state)\n{\n\tstruct dpu_crtc_state *cstate = to_dpu_crtc_state(state);\n\n\tDRM_DEBUG_ATOMIC(\"crtc%d\\n\", crtc->base.id);\n\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\n\tkfree(cstate);\n}\n\nstatic int _dpu_crtc_wait_for_frame_done(struct drm_crtc *crtc)\n{\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\tint ret, rc = 0;\n\n\tif (!atomic_read(&dpu_crtc->frame_pending)) {\n\t\tDRM_DEBUG_ATOMIC(\"no frames pending\\n\");\n\t\treturn 0;\n\t}\n\n\tDPU_ATRACE_BEGIN(\"frame done completion wait\");\n\tret = wait_for_completion_timeout(&dpu_crtc->frame_done_comp,\n\t\t\tmsecs_to_jiffies(DPU_CRTC_FRAME_DONE_TIMEOUT_MS));\n\tif (!ret) {\n\t\tDRM_ERROR(\"frame done wait timed out, ret:%d\\n\", ret);\n\t\trc = -ETIMEDOUT;\n\t}\n\tDPU_ATRACE_END(\"frame done completion wait\");\n\n\treturn rc;\n}\n\nvoid dpu_crtc_commit_kickoff(struct drm_crtc *crtc)\n{\n\tstruct drm_encoder *encoder;\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\tstruct dpu_kms *dpu_kms = _dpu_crtc_get_kms(crtc);\n\tstruct dpu_crtc_state *cstate = to_dpu_crtc_state(crtc->state);\n\n\t \n\tif (unlikely(!cstate->num_mixers))\n\t\treturn;\n\n\tDPU_ATRACE_BEGIN(\"crtc_commit\");\n\n\tdrm_for_each_encoder_mask(encoder, crtc->dev,\n\t\t\tcrtc->state->encoder_mask) {\n\t\tif (!dpu_encoder_is_valid_for_commit(encoder)) {\n\t\t\tDRM_DEBUG_ATOMIC(\"invalid FB not kicking off crtc\\n\");\n\t\t\tgoto end;\n\t\t}\n\t}\n\t \n\tdrm_for_each_encoder_mask(encoder, crtc->dev,\n\t\t\t\t  crtc->state->encoder_mask)\n\t\tdpu_encoder_prepare_for_kickoff(encoder);\n\n\tif (atomic_inc_return(&dpu_crtc->frame_pending) == 1) {\n\t\t \n\t\tDRM_DEBUG_ATOMIC(\"crtc%d first commit\\n\", crtc->base.id);\n\t} else\n\t\tDRM_DEBUG_ATOMIC(\"crtc%d commit\\n\", crtc->base.id);\n\n\tdpu_crtc->play_count++;\n\n\tdpu_vbif_clear_errors(dpu_kms);\n\n\tdrm_for_each_encoder_mask(encoder, crtc->dev, crtc->state->encoder_mask)\n\t\tdpu_encoder_kickoff(encoder);\n\n\treinit_completion(&dpu_crtc->frame_done_comp);\n\nend:\n\tDPU_ATRACE_END(\"crtc_commit\");\n}\n\nstatic void dpu_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct dpu_crtc_state *cstate = kzalloc(sizeof(*cstate), GFP_KERNEL);\n\n\tif (crtc->state)\n\t\tdpu_crtc_destroy_state(crtc, crtc->state);\n\n\tif (cstate)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &cstate->base);\n\telse\n\t\t__drm_atomic_helper_crtc_reset(crtc, NULL);\n}\n\n \nstatic struct drm_crtc_state *dpu_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct dpu_crtc_state *cstate, *old_cstate = to_dpu_crtc_state(crtc->state);\n\n\tcstate = kmemdup(old_cstate, sizeof(*old_cstate), GFP_KERNEL);\n\tif (!cstate) {\n\t\tDPU_ERROR(\"failed to allocate state\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &cstate->base);\n\n\treturn &cstate->base;\n}\n\nstatic void dpu_crtc_atomic_print_state(struct drm_printer *p,\n\t\t\t\t\tconst struct drm_crtc_state *state)\n{\n\tconst struct dpu_crtc_state *cstate = to_dpu_crtc_state(state);\n\tint i;\n\n\tfor (i = 0; i < cstate->num_mixers; i++) {\n\t\tdrm_printf(p, \"\\tlm[%d]=%d\\n\", i, cstate->mixers[i].hw_lm->idx - LM_0);\n\t\tdrm_printf(p, \"\\tctl[%d]=%d\\n\", i, cstate->mixers[i].lm_ctl->idx - CTL_0);\n\t\tif (cstate->mixers[i].hw_dspp)\n\t\t\tdrm_printf(p, \"\\tdspp[%d]=%d\\n\", i, cstate->mixers[i].hw_dspp->idx - DSPP_0);\n\t}\n}\n\nstatic void dpu_crtc_disable(struct drm_crtc *crtc,\n\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t      crtc);\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\tstruct dpu_crtc_state *cstate = to_dpu_crtc_state(crtc->state);\n\tstruct drm_encoder *encoder;\n\tunsigned long flags;\n\tbool release_bandwidth = false;\n\n\tDRM_DEBUG_KMS(\"crtc%d\\n\", crtc->base.id);\n\n\t \n\tif (old_crtc_state->self_refresh_active) {\n\t\tdrm_for_each_encoder_mask(encoder, crtc->dev,\n\t\t\t\t\told_crtc_state->encoder_mask) {\n\t\t\tdpu_encoder_assign_crtc(encoder, NULL);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tdrm_crtc_vblank_off(crtc);\n\n\tdrm_for_each_encoder_mask(encoder, crtc->dev,\n\t\t\t\t  old_crtc_state->encoder_mask) {\n\t\t \n\t\tif (dpu_encoder_get_intf_mode(encoder) == INTF_MODE_VIDEO)\n\t\t\trelease_bandwidth = true;\n\n\t\t \n\t\tif (!crtc->state->self_refresh_active)\n\t\t\tdpu_encoder_assign_crtc(encoder, NULL);\n\t}\n\n\t \n\tif (_dpu_crtc_wait_for_frame_done(crtc))\n\t\tDPU_ERROR(\"crtc%d wait for frame done failed;frame_pending%d\\n\",\n\t\t\t\tcrtc->base.id,\n\t\t\t\tatomic_read(&dpu_crtc->frame_pending));\n\n\ttrace_dpu_crtc_disable(DRMID(crtc), false, dpu_crtc);\n\tdpu_crtc->enabled = false;\n\n\tif (atomic_read(&dpu_crtc->frame_pending)) {\n\t\ttrace_dpu_crtc_disable_frame_pending(DRMID(crtc),\n\t\t\t\t     atomic_read(&dpu_crtc->frame_pending));\n\t\tif (release_bandwidth)\n\t\t\tdpu_core_perf_crtc_release_bw(crtc);\n\t\tatomic_set(&dpu_crtc->frame_pending, 0);\n\t}\n\n\tdpu_core_perf_crtc_update(crtc, 0);\n\n\tdrm_for_each_encoder_mask(encoder, crtc->dev, crtc->state->encoder_mask)\n\t\tdpu_encoder_register_frame_event_callback(encoder, NULL, NULL);\n\n\tmemset(cstate->mixers, 0, sizeof(cstate->mixers));\n\tcstate->num_mixers = 0;\n\n\t \n\tcstate->bw_control = false;\n\tcstate->bw_split_vote = false;\n\n\tif (crtc->state->event && !crtc->state->active) {\n\t\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\t}\n\n\tpm_runtime_put_sync(crtc->dev->dev);\n}\n\nstatic void dpu_crtc_enable(struct drm_crtc *crtc,\n\t\tstruct drm_atomic_state *state)\n{\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\tstruct drm_encoder *encoder;\n\tbool request_bandwidth = false;\n\tstruct drm_crtc_state *old_crtc_state;\n\n\told_crtc_state = drm_atomic_get_old_crtc_state(state, crtc);\n\n\tpm_runtime_get_sync(crtc->dev->dev);\n\n\tDRM_DEBUG_KMS(\"crtc%d\\n\", crtc->base.id);\n\n\tdrm_for_each_encoder_mask(encoder, crtc->dev, crtc->state->encoder_mask) {\n\t\t \n\t\tif (dpu_encoder_get_intf_mode(encoder) == INTF_MODE_VIDEO)\n\t\t\trequest_bandwidth = true;\n\t\tdpu_encoder_register_frame_event_callback(encoder,\n\t\t\t\tdpu_crtc_frame_event_cb, (void *)crtc);\n\t}\n\n\tif (request_bandwidth)\n\t\tatomic_inc(&_dpu_crtc_get_kms(crtc)->bandwidth_ref);\n\n\ttrace_dpu_crtc_enable(DRMID(crtc), true, dpu_crtc);\n\tdpu_crtc->enabled = true;\n\n\tif (!old_crtc_state->self_refresh_active) {\n\t\tdrm_for_each_encoder_mask(encoder, crtc->dev, crtc->state->encoder_mask)\n\t\t\tdpu_encoder_assign_crtc(encoder, crtc);\n\t}\n\n\t \n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic bool dpu_crtc_needs_dirtyfb(struct drm_crtc_state *cstate)\n{\n\tstruct drm_crtc *crtc = cstate->crtc;\n\tstruct drm_encoder *encoder;\n\n\tif (cstate->self_refresh_active)\n\t\treturn true;\n\n\tdrm_for_each_encoder_mask (encoder, crtc->dev, cstate->encoder_mask) {\n\t\tif (dpu_encoder_get_intf_mode(encoder) == INTF_MODE_CMD) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int dpu_crtc_atomic_check(struct drm_crtc *crtc,\n\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\tstruct dpu_crtc_state *cstate = to_dpu_crtc_state(crtc_state);\n\n\tconst struct drm_plane_state *pstate;\n\tstruct drm_plane *plane;\n\n\tint rc = 0;\n\n\tbool needs_dirtyfb = dpu_crtc_needs_dirtyfb(crtc_state);\n\n\tif (!crtc_state->enable || !drm_atomic_crtc_effectively_active(crtc_state)) {\n\t\tDRM_DEBUG_ATOMIC(\"crtc%d -> enable %d, active %d, skip atomic_check\\n\",\n\t\t\t\tcrtc->base.id, crtc_state->enable,\n\t\t\t\tcrtc_state->active);\n\t\tmemset(&cstate->new_perf, 0, sizeof(cstate->new_perf));\n\t\treturn 0;\n\t}\n\n\tDRM_DEBUG_ATOMIC(\"%s: check\\n\", dpu_crtc->name);\n\n\t \n\tif (crtc_state->active_changed)\n\t\tcrtc_state->mode_changed = true;\n\n\tif (cstate->num_mixers)\n\t\t_dpu_crtc_setup_lm_bounds(crtc, crtc_state);\n\n\t \n\tdrm_atomic_crtc_state_for_each_plane_state(plane, pstate, crtc_state) {\n\t\tstruct dpu_plane_state *dpu_pstate = to_dpu_plane_state(pstate);\n\n\t\tif (IS_ERR_OR_NULL(pstate)) {\n\t\t\trc = PTR_ERR(pstate);\n\t\t\tDPU_ERROR(\"%s: failed to get plane%d state, %d\\n\",\n\t\t\t\t\tdpu_crtc->name, plane->base.id, rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (!pstate->visible)\n\t\t\tcontinue;\n\n\t\tdpu_pstate->needs_dirtyfb = needs_dirtyfb;\n\t}\n\n\tatomic_inc(&_dpu_crtc_get_kms(crtc)->bandwidth_ref);\n\n\trc = dpu_core_perf_crtc_check(crtc, crtc_state);\n\tif (rc) {\n\t\tDPU_ERROR(\"crtc%d failed performance check %d\\n\",\n\t\t\t\tcrtc->base.id, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nint dpu_crtc_vblank(struct drm_crtc *crtc, bool en)\n{\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\tstruct drm_encoder *enc;\n\n\ttrace_dpu_crtc_vblank(DRMID(&dpu_crtc->base), en, dpu_crtc);\n\n\t \n\tlist_for_each_entry(enc, &crtc->dev->mode_config.encoder_list, head) {\n\t\ttrace_dpu_crtc_vblank_enable(DRMID(crtc), DRMID(enc), en,\n\t\t\t\t\t     dpu_crtc);\n\n\t\tdpu_encoder_toggle_vblank_for_crtc(enc, crtc, en);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int _dpu_debugfs_status_show(struct seq_file *s, void *data)\n{\n\tstruct dpu_crtc *dpu_crtc;\n\tstruct dpu_plane_state *pstate = NULL;\n\tstruct dpu_crtc_mixer *m;\n\n\tstruct drm_crtc *crtc;\n\tstruct drm_plane *plane;\n\tstruct drm_display_mode *mode;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_plane_state *state;\n\tstruct dpu_crtc_state *cstate;\n\n\tint i, out_width;\n\n\tdpu_crtc = s->private;\n\tcrtc = &dpu_crtc->base;\n\n\tdrm_modeset_lock_all(crtc->dev);\n\tcstate = to_dpu_crtc_state(crtc->state);\n\n\tmode = &crtc->state->adjusted_mode;\n\tout_width = mode->hdisplay / cstate->num_mixers;\n\n\tseq_printf(s, \"crtc:%d width:%d height:%d\\n\", crtc->base.id,\n\t\t\t\tmode->hdisplay, mode->vdisplay);\n\n\tseq_puts(s, \"\\n\");\n\n\tfor (i = 0; i < cstate->num_mixers; ++i) {\n\t\tm = &cstate->mixers[i];\n\t\tseq_printf(s, \"\\tmixer:%d ctl:%d width:%d height:%d\\n\",\n\t\t\tm->hw_lm->idx - LM_0, m->lm_ctl->idx - CTL_0,\n\t\t\tout_width, mode->vdisplay);\n\t}\n\n\tseq_puts(s, \"\\n\");\n\n\tdrm_atomic_crtc_for_each_plane(plane, crtc) {\n\t\tpstate = to_dpu_plane_state(plane->state);\n\t\tstate = plane->state;\n\n\t\tif (!pstate || !state)\n\t\t\tcontinue;\n\n\t\tseq_printf(s, \"\\tplane:%u stage:%d\\n\", plane->base.id,\n\t\t\tpstate->stage);\n\n\t\tif (plane->state->fb) {\n\t\t\tfb = plane->state->fb;\n\n\t\t\tseq_printf(s, \"\\tfb:%d image format:%4.4s wxh:%ux%u \",\n\t\t\t\tfb->base.id, (char *) &fb->format->format,\n\t\t\t\tfb->width, fb->height);\n\t\t\tfor (i = 0; i < ARRAY_SIZE(fb->format->cpp); ++i)\n\t\t\t\tseq_printf(s, \"cpp[%d]:%u \",\n\t\t\t\t\t\ti, fb->format->cpp[i]);\n\t\t\tseq_puts(s, \"\\n\\t\");\n\n\t\t\tseq_printf(s, \"modifier:%8llu \", fb->modifier);\n\t\t\tseq_puts(s, \"\\n\");\n\n\t\t\tseq_puts(s, \"\\t\");\n\t\t\tfor (i = 0; i < ARRAY_SIZE(fb->pitches); i++)\n\t\t\t\tseq_printf(s, \"pitches[%d]:%8u \", i,\n\t\t\t\t\t\t\tfb->pitches[i]);\n\t\t\tseq_puts(s, \"\\n\");\n\n\t\t\tseq_puts(s, \"\\t\");\n\t\t\tfor (i = 0; i < ARRAY_SIZE(fb->offsets); i++)\n\t\t\t\tseq_printf(s, \"offsets[%d]:%8u \", i,\n\t\t\t\t\t\t\tfb->offsets[i]);\n\t\t\tseq_puts(s, \"\\n\");\n\t\t}\n\n\t\tseq_printf(s, \"\\tsrc_x:%4d src_y:%4d src_w:%4d src_h:%4d\\n\",\n\t\t\tstate->src_x, state->src_y, state->src_w, state->src_h);\n\n\t\tseq_printf(s, \"\\tdst x:%4d dst_y:%4d dst_w:%4d dst_h:%4d\\n\",\n\t\t\tstate->crtc_x, state->crtc_y, state->crtc_w,\n\t\t\tstate->crtc_h);\n\t\tseq_printf(s, \"\\tsspp[0]:%s\\n\",\n\t\t\t   pstate->pipe.sspp->cap->name);\n\t\tseq_printf(s, \"\\tmultirect[0]: mode: %d index: %d\\n\",\n\t\t\tpstate->pipe.multirect_mode, pstate->pipe.multirect_index);\n\t\tif (pstate->r_pipe.sspp) {\n\t\t\tseq_printf(s, \"\\tsspp[1]:%s\\n\",\n\t\t\t\t   pstate->r_pipe.sspp->cap->name);\n\t\t\tseq_printf(s, \"\\tmultirect[1]: mode: %d index: %d\\n\",\n\t\t\t\t   pstate->r_pipe.multirect_mode, pstate->r_pipe.multirect_index);\n\t\t}\n\n\t\tseq_puts(s, \"\\n\");\n\t}\n\tif (dpu_crtc->vblank_cb_count) {\n\t\tktime_t diff = ktime_sub(ktime_get(), dpu_crtc->vblank_cb_time);\n\t\ts64 diff_ms = ktime_to_ms(diff);\n\t\ts64 fps = diff_ms ? div_s64(\n\t\t\t\tdpu_crtc->vblank_cb_count * 1000, diff_ms) : 0;\n\n\t\tseq_printf(s,\n\t\t\t\"vblank fps:%lld count:%u total:%llums total_framecount:%llu\\n\",\n\t\t\t\tfps, dpu_crtc->vblank_cb_count,\n\t\t\t\tktime_to_ms(diff), dpu_crtc->play_count);\n\n\t\t \n\t\tdpu_crtc->vblank_cb_count = 0;\n\t\tdpu_crtc->vblank_cb_time = ktime_set(0, 0);\n\t}\n\n\tdrm_modeset_unlock_all(crtc->dev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(_dpu_debugfs_status);\n\nstatic int dpu_crtc_debugfs_state_show(struct seq_file *s, void *v)\n{\n\tstruct drm_crtc *crtc = s->private;\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\n\tseq_printf(s, \"client type: %d\\n\", dpu_crtc_get_client_type(crtc));\n\tseq_printf(s, \"intf_mode: %d\\n\", dpu_crtc_get_intf_mode(crtc));\n\tseq_printf(s, \"core_clk_rate: %llu\\n\",\n\t\t\tdpu_crtc->cur_perf.core_clk_rate);\n\tseq_printf(s, \"bw_ctl: %llu\\n\", dpu_crtc->cur_perf.bw_ctl);\n\tseq_printf(s, \"max_per_pipe_ib: %llu\\n\",\n\t\t\t\tdpu_crtc->cur_perf.max_per_pipe_ib);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dpu_crtc_debugfs_state);\n\nstatic int _dpu_crtc_init_debugfs(struct drm_crtc *crtc)\n{\n\tstruct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);\n\n\tdebugfs_create_file(\"status\", 0400,\n\t\t\tcrtc->debugfs_entry,\n\t\t\tdpu_crtc, &_dpu_debugfs_status_fops);\n\tdebugfs_create_file(\"state\", 0600,\n\t\t\tcrtc->debugfs_entry,\n\t\t\t&dpu_crtc->base,\n\t\t\t&dpu_crtc_debugfs_state_fops);\n\n\treturn 0;\n}\n#else\nstatic int _dpu_crtc_init_debugfs(struct drm_crtc *crtc)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int dpu_crtc_late_register(struct drm_crtc *crtc)\n{\n\treturn _dpu_crtc_init_debugfs(crtc);\n}\n\nstatic const struct drm_crtc_funcs dpu_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.destroy = dpu_crtc_destroy,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = dpu_crtc_reset,\n\t.atomic_duplicate_state = dpu_crtc_duplicate_state,\n\t.atomic_destroy_state = dpu_crtc_destroy_state,\n\t.atomic_print_state = dpu_crtc_atomic_print_state,\n\t.late_register = dpu_crtc_late_register,\n\t.verify_crc_source = dpu_crtc_verify_crc_source,\n\t.set_crc_source = dpu_crtc_set_crc_source,\n\t.enable_vblank  = msm_crtc_enable_vblank,\n\t.disable_vblank = msm_crtc_disable_vblank,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n\t.get_vblank_counter = dpu_crtc_get_vblank_counter,\n};\n\nstatic const struct drm_crtc_helper_funcs dpu_crtc_helper_funcs = {\n\t.atomic_disable = dpu_crtc_disable,\n\t.atomic_enable = dpu_crtc_enable,\n\t.atomic_check = dpu_crtc_atomic_check,\n\t.atomic_begin = dpu_crtc_atomic_begin,\n\t.atomic_flush = dpu_crtc_atomic_flush,\n\t.get_scanout_position = dpu_crtc_get_scanout_position,\n};\n\n \nstruct drm_crtc *dpu_crtc_init(struct drm_device *dev, struct drm_plane *plane,\n\t\t\t\tstruct drm_plane *cursor)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct dpu_kms *dpu_kms = to_dpu_kms(priv->kms);\n\tstruct drm_crtc *crtc = NULL;\n\tstruct dpu_crtc *dpu_crtc = NULL;\n\tint i, ret;\n\n\tdpu_crtc = kzalloc(sizeof(*dpu_crtc), GFP_KERNEL);\n\tif (!dpu_crtc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcrtc = &dpu_crtc->base;\n\tcrtc->dev = dev;\n\n\tspin_lock_init(&dpu_crtc->spin_lock);\n\tatomic_set(&dpu_crtc->frame_pending, 0);\n\n\tinit_completion(&dpu_crtc->frame_done_comp);\n\n\tINIT_LIST_HEAD(&dpu_crtc->frame_event_list);\n\n\tfor (i = 0; i < ARRAY_SIZE(dpu_crtc->frame_events); i++) {\n\t\tINIT_LIST_HEAD(&dpu_crtc->frame_events[i].list);\n\t\tlist_add(&dpu_crtc->frame_events[i].list,\n\t\t\t\t&dpu_crtc->frame_event_list);\n\t\tkthread_init_work(&dpu_crtc->frame_events[i].work,\n\t\t\t\tdpu_crtc_frame_event_work);\n\t}\n\n\tdrm_crtc_init_with_planes(dev, crtc, plane, cursor, &dpu_crtc_funcs,\n\t\t\t\tNULL);\n\n\tdrm_crtc_helper_add(crtc, &dpu_crtc_helper_funcs);\n\n\tif (dpu_kms->catalog->dspp_count)\n\t\tdrm_crtc_enable_color_mgmt(crtc, 0, true, 0);\n\n\t \n\tsnprintf(dpu_crtc->name, DPU_CRTC_NAME_SIZE, \"crtc%u\", crtc->base.id);\n\n\t \n\tspin_lock_init(&dpu_crtc->event_lock);\n\n\tret = drm_self_refresh_helper_init(crtc);\n\tif (ret) {\n\t\tDPU_ERROR(\"Failed to initialize %s with self-refresh helpers %d\\n\",\n\t\t\tcrtc->name, ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tDRM_DEBUG_KMS(\"%s: successfully initialized crtc\\n\", dpu_crtc->name);\n\treturn crtc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}