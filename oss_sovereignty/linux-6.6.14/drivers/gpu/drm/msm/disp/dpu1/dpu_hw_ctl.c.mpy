{
  "module_name": "dpu_hw_ctl.c",
  "hash_id": "d6a4686fdced6b1253c43d6824ac93bdcceff39d4713e338537fecfd5397cb00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_hw_ctl.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include \"dpu_hwio.h\"\n#include \"dpu_hw_ctl.h\"\n#include \"dpu_kms.h\"\n#include \"dpu_trace.h\"\n\n#define   CTL_LAYER(lm)                 \\\n\t(((lm) == LM_5) ? (0x024) : (((lm) - LM_0) * 0x004))\n#define   CTL_LAYER_EXT(lm)             \\\n\t(0x40 + (((lm) - LM_0) * 0x004))\n#define   CTL_LAYER_EXT2(lm)             \\\n\t(0x70 + (((lm) - LM_0) * 0x004))\n#define   CTL_LAYER_EXT3(lm)             \\\n\t(0xA0 + (((lm) - LM_0) * 0x004))\n#define CTL_LAYER_EXT4(lm)             \\\n\t(0xB8 + (((lm) - LM_0) * 0x004))\n#define   CTL_TOP                       0x014\n#define   CTL_FLUSH                     0x018\n#define   CTL_START                     0x01C\n#define   CTL_PREPARE                   0x0d0\n#define   CTL_SW_RESET                  0x030\n#define   CTL_LAYER_EXTN_OFFSET         0x40\n#define   CTL_MERGE_3D_ACTIVE           0x0E4\n#define   CTL_DSC_ACTIVE                0x0E8\n#define   CTL_WB_ACTIVE                 0x0EC\n#define   CTL_INTF_ACTIVE               0x0F4\n#define   CTL_FETCH_PIPE_ACTIVE         0x0FC\n#define   CTL_MERGE_3D_FLUSH            0x100\n#define   CTL_DSC_FLUSH                0x104\n#define   CTL_WB_FLUSH                  0x108\n#define   CTL_INTF_FLUSH                0x110\n#define   CTL_INTF_MASTER               0x134\n#define   CTL_DSPP_n_FLUSH(n)           ((0x13C) + ((n) * 4))\n\n#define CTL_MIXER_BORDER_OUT            BIT(24)\n#define CTL_FLUSH_MASK_CTL              BIT(17)\n\n#define DPU_REG_RESET_TIMEOUT_US        2000\n#define  MERGE_3D_IDX   23\n#define  DSC_IDX        22\n#define  INTF_IDX       31\n#define WB_IDX          16\n#define  DSPP_IDX       29   \n#define CTL_INVALID_BIT                 0xffff\n#define CTL_DEFAULT_GROUP_ID\t\t0xf\n\nstatic const u32 fetch_tbl[SSPP_MAX] = {CTL_INVALID_BIT, 16, 17, 18, 19,\n\tCTL_INVALID_BIT, CTL_INVALID_BIT, CTL_INVALID_BIT, CTL_INVALID_BIT, 0,\n\t1, 2, 3, 4, 5};\n\nstatic int _mixer_stages(const struct dpu_lm_cfg *mixer, int count,\n\t\tenum dpu_lm lm)\n{\n\tint i;\n\tint stages = -EINVAL;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (lm == mixer[i].id) {\n\t\t\tstages = mixer[i].sblk->maxblendstages;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn stages;\n}\n\nstatic inline u32 dpu_hw_ctl_get_flush_register(struct dpu_hw_ctl *ctx)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\n\treturn DPU_REG_READ(c, CTL_FLUSH);\n}\n\nstatic inline void dpu_hw_ctl_trigger_start(struct dpu_hw_ctl *ctx)\n{\n\ttrace_dpu_hw_ctl_trigger_start(ctx->pending_flush_mask,\n\t\t\t\t       dpu_hw_ctl_get_flush_register(ctx));\n\tDPU_REG_WRITE(&ctx->hw, CTL_START, 0x1);\n}\n\nstatic inline bool dpu_hw_ctl_is_started(struct dpu_hw_ctl *ctx)\n{\n\treturn !!(DPU_REG_READ(&ctx->hw, CTL_START) & BIT(0));\n}\n\nstatic inline void dpu_hw_ctl_trigger_pending(struct dpu_hw_ctl *ctx)\n{\n\ttrace_dpu_hw_ctl_trigger_prepare(ctx->pending_flush_mask,\n\t\t\t\t\t dpu_hw_ctl_get_flush_register(ctx));\n\tDPU_REG_WRITE(&ctx->hw, CTL_PREPARE, 0x1);\n}\n\nstatic inline void dpu_hw_ctl_clear_pending_flush(struct dpu_hw_ctl *ctx)\n{\n\ttrace_dpu_hw_ctl_clear_pending_flush(ctx->pending_flush_mask,\n\t\t\t\t     dpu_hw_ctl_get_flush_register(ctx));\n\tctx->pending_flush_mask = 0x0;\n\tctx->pending_intf_flush_mask = 0;\n\tctx->pending_wb_flush_mask = 0;\n\tctx->pending_merge_3d_flush_mask = 0;\n\tctx->pending_dsc_flush_mask = 0;\n\n\tmemset(ctx->pending_dspp_flush_mask, 0,\n\t\tsizeof(ctx->pending_dspp_flush_mask));\n}\n\nstatic inline void dpu_hw_ctl_update_pending_flush(struct dpu_hw_ctl *ctx,\n\t\tu32 flushbits)\n{\n\ttrace_dpu_hw_ctl_update_pending_flush(flushbits,\n\t\t\t\t\t      ctx->pending_flush_mask);\n\tctx->pending_flush_mask |= flushbits;\n}\n\nstatic u32 dpu_hw_ctl_get_pending_flush(struct dpu_hw_ctl *ctx)\n{\n\treturn ctx->pending_flush_mask;\n}\n\nstatic inline void dpu_hw_ctl_trigger_flush_v1(struct dpu_hw_ctl *ctx)\n{\n\tint dspp;\n\n\tif (ctx->pending_flush_mask & BIT(MERGE_3D_IDX))\n\t\tDPU_REG_WRITE(&ctx->hw, CTL_MERGE_3D_FLUSH,\n\t\t\t\tctx->pending_merge_3d_flush_mask);\n\tif (ctx->pending_flush_mask & BIT(INTF_IDX))\n\t\tDPU_REG_WRITE(&ctx->hw, CTL_INTF_FLUSH,\n\t\t\t\tctx->pending_intf_flush_mask);\n\tif (ctx->pending_flush_mask & BIT(WB_IDX))\n\t\tDPU_REG_WRITE(&ctx->hw, CTL_WB_FLUSH,\n\t\t\t\tctx->pending_wb_flush_mask);\n\n\tif (ctx->pending_flush_mask & BIT(DSPP_IDX))\n\t\tfor (dspp = DSPP_0; dspp < DSPP_MAX; dspp++) {\n\t\t\tif (ctx->pending_dspp_flush_mask[dspp - DSPP_0])\n\t\t\t\tDPU_REG_WRITE(&ctx->hw,\n\t\t\t\tCTL_DSPP_n_FLUSH(dspp - DSPP_0),\n\t\t\t\tctx->pending_dspp_flush_mask[dspp - DSPP_0]);\n\t\t}\n\n\tif (ctx->pending_flush_mask & BIT(DSC_IDX))\n\t\tDPU_REG_WRITE(&ctx->hw, CTL_DSC_FLUSH,\n\t\t\t      ctx->pending_dsc_flush_mask);\n\n\tDPU_REG_WRITE(&ctx->hw, CTL_FLUSH, ctx->pending_flush_mask);\n}\n\nstatic inline void dpu_hw_ctl_trigger_flush(struct dpu_hw_ctl *ctx)\n{\n\ttrace_dpu_hw_ctl_trigger_pending_flush(ctx->pending_flush_mask,\n\t\t\t\t     dpu_hw_ctl_get_flush_register(ctx));\n\tDPU_REG_WRITE(&ctx->hw, CTL_FLUSH, ctx->pending_flush_mask);\n}\n\nstatic void dpu_hw_ctl_update_pending_flush_sspp(struct dpu_hw_ctl *ctx,\n\tenum dpu_sspp sspp)\n{\n\tswitch (sspp) {\n\tcase SSPP_VIG0:\n\t\tctx->pending_flush_mask |=  BIT(0);\n\t\tbreak;\n\tcase SSPP_VIG1:\n\t\tctx->pending_flush_mask |= BIT(1);\n\t\tbreak;\n\tcase SSPP_VIG2:\n\t\tctx->pending_flush_mask |= BIT(2);\n\t\tbreak;\n\tcase SSPP_VIG3:\n\t\tctx->pending_flush_mask |= BIT(18);\n\t\tbreak;\n\tcase SSPP_RGB0:\n\t\tctx->pending_flush_mask |= BIT(3);\n\t\tbreak;\n\tcase SSPP_RGB1:\n\t\tctx->pending_flush_mask |= BIT(4);\n\t\tbreak;\n\tcase SSPP_RGB2:\n\t\tctx->pending_flush_mask |= BIT(5);\n\t\tbreak;\n\tcase SSPP_RGB3:\n\t\tctx->pending_flush_mask |= BIT(19);\n\t\tbreak;\n\tcase SSPP_DMA0:\n\t\tctx->pending_flush_mask |= BIT(11);\n\t\tbreak;\n\tcase SSPP_DMA1:\n\t\tctx->pending_flush_mask |= BIT(12);\n\t\tbreak;\n\tcase SSPP_DMA2:\n\t\tctx->pending_flush_mask |= BIT(24);\n\t\tbreak;\n\tcase SSPP_DMA3:\n\t\tctx->pending_flush_mask |= BIT(25);\n\t\tbreak;\n\tcase SSPP_DMA4:\n\t\tctx->pending_flush_mask |= BIT(13);\n\t\tbreak;\n\tcase SSPP_DMA5:\n\t\tctx->pending_flush_mask |= BIT(14);\n\t\tbreak;\n\tcase SSPP_CURSOR0:\n\t\tctx->pending_flush_mask |= BIT(22);\n\t\tbreak;\n\tcase SSPP_CURSOR1:\n\t\tctx->pending_flush_mask |= BIT(23);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void dpu_hw_ctl_update_pending_flush_mixer(struct dpu_hw_ctl *ctx,\n\tenum dpu_lm lm)\n{\n\tswitch (lm) {\n\tcase LM_0:\n\t\tctx->pending_flush_mask |= BIT(6);\n\t\tbreak;\n\tcase LM_1:\n\t\tctx->pending_flush_mask |= BIT(7);\n\t\tbreak;\n\tcase LM_2:\n\t\tctx->pending_flush_mask |= BIT(8);\n\t\tbreak;\n\tcase LM_3:\n\t\tctx->pending_flush_mask |= BIT(9);\n\t\tbreak;\n\tcase LM_4:\n\t\tctx->pending_flush_mask |= BIT(10);\n\t\tbreak;\n\tcase LM_5:\n\t\tctx->pending_flush_mask |= BIT(20);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tctx->pending_flush_mask |= CTL_FLUSH_MASK_CTL;\n}\n\nstatic void dpu_hw_ctl_update_pending_flush_intf(struct dpu_hw_ctl *ctx,\n\t\tenum dpu_intf intf)\n{\n\tswitch (intf) {\n\tcase INTF_0:\n\t\tctx->pending_flush_mask |= BIT(31);\n\t\tbreak;\n\tcase INTF_1:\n\t\tctx->pending_flush_mask |= BIT(30);\n\t\tbreak;\n\tcase INTF_2:\n\t\tctx->pending_flush_mask |= BIT(29);\n\t\tbreak;\n\tcase INTF_3:\n\t\tctx->pending_flush_mask |= BIT(28);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void dpu_hw_ctl_update_pending_flush_wb(struct dpu_hw_ctl *ctx,\n\t\tenum dpu_wb wb)\n{\n\tswitch (wb) {\n\tcase WB_0:\n\tcase WB_1:\n\tcase WB_2:\n\t\tctx->pending_flush_mask |= BIT(WB_IDX);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void dpu_hw_ctl_update_pending_flush_wb_v1(struct dpu_hw_ctl *ctx,\n\t\tenum dpu_wb wb)\n{\n\tctx->pending_wb_flush_mask |= BIT(wb - WB_0);\n\tctx->pending_flush_mask |= BIT(WB_IDX);\n}\n\nstatic void dpu_hw_ctl_update_pending_flush_intf_v1(struct dpu_hw_ctl *ctx,\n\t\tenum dpu_intf intf)\n{\n\tctx->pending_intf_flush_mask |= BIT(intf - INTF_0);\n\tctx->pending_flush_mask |= BIT(INTF_IDX);\n}\n\nstatic void dpu_hw_ctl_update_pending_flush_merge_3d_v1(struct dpu_hw_ctl *ctx,\n\t\tenum dpu_merge_3d merge_3d)\n{\n\tctx->pending_merge_3d_flush_mask |= BIT(merge_3d - MERGE_3D_0);\n\tctx->pending_flush_mask |= BIT(MERGE_3D_IDX);\n}\n\nstatic void dpu_hw_ctl_update_pending_flush_dsc_v1(struct dpu_hw_ctl *ctx,\n\t\t\t\t\t\t   enum dpu_dsc dsc_num)\n{\n\tctx->pending_dsc_flush_mask |= BIT(dsc_num - DSC_0);\n\tctx->pending_flush_mask |= BIT(DSC_IDX);\n}\n\nstatic void dpu_hw_ctl_update_pending_flush_dspp(struct dpu_hw_ctl *ctx,\n\tenum dpu_dspp dspp, u32 dspp_sub_blk)\n{\n\tswitch (dspp) {\n\tcase DSPP_0:\n\t\tctx->pending_flush_mask |= BIT(13);\n\t\tbreak;\n\tcase DSPP_1:\n\t\tctx->pending_flush_mask |= BIT(14);\n\t\tbreak;\n\tcase DSPP_2:\n\t\tctx->pending_flush_mask |= BIT(15);\n\t\tbreak;\n\tcase DSPP_3:\n\t\tctx->pending_flush_mask |= BIT(21);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void dpu_hw_ctl_update_pending_flush_dspp_sub_blocks(\n\tstruct dpu_hw_ctl *ctx,\tenum dpu_dspp dspp, u32 dspp_sub_blk)\n{\n\tif (dspp >= DSPP_MAX)\n\t\treturn;\n\n\tswitch (dspp_sub_blk) {\n\tcase DPU_DSPP_PCC:\n\t\tctx->pending_dspp_flush_mask[dspp - DSPP_0] |= BIT(4);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tctx->pending_flush_mask |= BIT(DSPP_IDX);\n}\n\nstatic u32 dpu_hw_ctl_poll_reset_status(struct dpu_hw_ctl *ctx, u32 timeout_us)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tktime_t timeout;\n\tu32 status;\n\n\ttimeout = ktime_add_us(ktime_get(), timeout_us);\n\n\t \n\tdo {\n\t\tstatus = DPU_REG_READ(c, CTL_SW_RESET);\n\t\tstatus &= 0x1;\n\t\tif (status)\n\t\t\tusleep_range(20, 50);\n\t} while (status && ktime_compare_safe(ktime_get(), timeout) < 0);\n\n\treturn status;\n}\n\nstatic int dpu_hw_ctl_reset_control(struct dpu_hw_ctl *ctx)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\n\tpr_debug(\"issuing hw ctl reset for ctl:%d\\n\", ctx->idx);\n\tDPU_REG_WRITE(c, CTL_SW_RESET, 0x1);\n\tif (dpu_hw_ctl_poll_reset_status(ctx, DPU_REG_RESET_TIMEOUT_US))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int dpu_hw_ctl_wait_reset_status(struct dpu_hw_ctl *ctx)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tu32 status;\n\n\tstatus = DPU_REG_READ(c, CTL_SW_RESET);\n\tstatus &= 0x01;\n\tif (!status)\n\t\treturn 0;\n\n\tpr_debug(\"hw ctl reset is set for ctl:%d\\n\", ctx->idx);\n\tif (dpu_hw_ctl_poll_reset_status(ctx, DPU_REG_RESET_TIMEOUT_US)) {\n\t\tpr_err(\"hw recovery is not complete for ctl:%d\\n\", ctx->idx);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void dpu_hw_ctl_clear_all_blendstages(struct dpu_hw_ctl *ctx)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tint i;\n\n\tfor (i = 0; i < ctx->mixer_count; i++) {\n\t\tenum dpu_lm mixer_id = ctx->mixer_hw_caps[i].id;\n\n\t\tDPU_REG_WRITE(c, CTL_LAYER(mixer_id), 0);\n\t\tDPU_REG_WRITE(c, CTL_LAYER_EXT(mixer_id), 0);\n\t\tDPU_REG_WRITE(c, CTL_LAYER_EXT2(mixer_id), 0);\n\t\tDPU_REG_WRITE(c, CTL_LAYER_EXT3(mixer_id), 0);\n\t}\n\n\tDPU_REG_WRITE(c, CTL_FETCH_PIPE_ACTIVE, 0);\n}\n\nstruct ctl_blend_config {\n\tint idx, shift, ext_shift;\n};\n\nstatic const struct ctl_blend_config ctl_blend_config[][2] = {\n\t[SSPP_NONE] = { { -1 }, { -1 } },\n\t[SSPP_MAX] =  { { -1 }, { -1 } },\n\t[SSPP_VIG0] = { { 0, 0,  0  }, { 3, 0 } },\n\t[SSPP_VIG1] = { { 0, 3,  2  }, { 3, 4 } },\n\t[SSPP_VIG2] = { { 0, 6,  4  }, { 3, 8 } },\n\t[SSPP_VIG3] = { { 0, 26, 6  }, { 3, 12 } },\n\t[SSPP_RGB0] = { { 0, 9,  8  }, { -1 } },\n\t[SSPP_RGB1] = { { 0, 12, 10 }, { -1 } },\n\t[SSPP_RGB2] = { { 0, 15, 12 }, { -1 } },\n\t[SSPP_RGB3] = { { 0, 29, 14 }, { -1 } },\n\t[SSPP_DMA0] = { { 0, 18, 16 }, { 2, 8 } },\n\t[SSPP_DMA1] = { { 0, 21, 18 }, { 2, 12 } },\n\t[SSPP_DMA2] = { { 2, 0      }, { 2, 16 } },\n\t[SSPP_DMA3] = { { 2, 4      }, { 2, 20 } },\n\t[SSPP_DMA4] = { { 4, 0      }, { 4, 8 } },\n\t[SSPP_DMA5] = { { 4, 4      }, { 4, 12 } },\n\t[SSPP_CURSOR0] =  { { 1, 20 }, { -1 } },\n\t[SSPP_CURSOR1] =  { { 1, 26 }, { -1 } },\n};\n\nstatic void dpu_hw_ctl_setup_blendstage(struct dpu_hw_ctl *ctx,\n\tenum dpu_lm lm, struct dpu_hw_stage_cfg *stage_cfg)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tu32 mix, ext, mix_ext;\n\tu32 mixercfg[5] = { 0 };\n\tint i, j;\n\tint stages;\n\tint pipes_per_stage;\n\n\tstages = _mixer_stages(ctx->mixer_hw_caps, ctx->mixer_count, lm);\n\tif (stages < 0)\n\t\treturn;\n\n\tif (test_bit(DPU_MIXER_SOURCESPLIT,\n\t\t&ctx->mixer_hw_caps->features))\n\t\tpipes_per_stage = PIPES_PER_STAGE;\n\telse\n\t\tpipes_per_stage = 1;\n\n\tmixercfg[0] = CTL_MIXER_BORDER_OUT;  \n\n\tif (!stage_cfg)\n\t\tgoto exit;\n\n\tfor (i = 0; i <= stages; i++) {\n\t\t \n\t\tmix = (i + 1) & 0x7;\n\t\text = i >= 7;\n\t\tmix_ext = (i + 1) & 0xf;\n\n\t\tfor (j = 0 ; j < pipes_per_stage; j++) {\n\t\t\tenum dpu_sspp_multirect_index rect_index =\n\t\t\t\tstage_cfg->multirect_index[i][j];\n\t\t\tenum dpu_sspp pipe = stage_cfg->stage[i][j];\n\t\t\tconst struct ctl_blend_config *cfg =\n\t\t\t\t&ctl_blend_config[pipe][rect_index == DPU_SSPP_RECT_1];\n\n\t\t\t \n\t\t\tif (cfg->idx == -1) {\n\t\t\t\tcontinue;\n\t\t\t} else if (cfg->idx == 0) {\n\t\t\t\tmixercfg[0] |= mix << cfg->shift;\n\t\t\t\tmixercfg[1] |= ext << cfg->ext_shift;\n\t\t\t} else {\n\t\t\t\tmixercfg[cfg->idx] |= mix_ext << cfg->shift;\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\tDPU_REG_WRITE(c, CTL_LAYER(lm), mixercfg[0]);\n\tDPU_REG_WRITE(c, CTL_LAYER_EXT(lm), mixercfg[1]);\n\tDPU_REG_WRITE(c, CTL_LAYER_EXT2(lm), mixercfg[2]);\n\tDPU_REG_WRITE(c, CTL_LAYER_EXT3(lm), mixercfg[3]);\n\tif ((test_bit(DPU_CTL_HAS_LAYER_EXT4, &ctx->caps->features)))\n\t\tDPU_REG_WRITE(c, CTL_LAYER_EXT4(lm), mixercfg[4]);\n}\n\n\nstatic void dpu_hw_ctl_intf_cfg_v1(struct dpu_hw_ctl *ctx,\n\t\tstruct dpu_hw_intf_cfg *cfg)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tu32 intf_active = 0;\n\tu32 wb_active = 0;\n\tu32 mode_sel = 0;\n\n\t \n\tif ((test_bit(DPU_CTL_VM_CFG, &ctx->caps->features)))\n\t\tmode_sel = CTL_DEFAULT_GROUP_ID  << 28;\n\n\tif (cfg->intf_mode_sel == DPU_CTL_MODE_SEL_CMD)\n\t\tmode_sel |= BIT(17);\n\n\tintf_active = DPU_REG_READ(c, CTL_INTF_ACTIVE);\n\twb_active = DPU_REG_READ(c, CTL_WB_ACTIVE);\n\n\tif (cfg->intf)\n\t\tintf_active |= BIT(cfg->intf - INTF_0);\n\n\tif (cfg->wb)\n\t\twb_active |= BIT(cfg->wb - WB_0);\n\n\tDPU_REG_WRITE(c, CTL_TOP, mode_sel);\n\tDPU_REG_WRITE(c, CTL_INTF_ACTIVE, intf_active);\n\tDPU_REG_WRITE(c, CTL_WB_ACTIVE, wb_active);\n\n\tif (cfg->merge_3d)\n\t\tDPU_REG_WRITE(c, CTL_MERGE_3D_ACTIVE,\n\t\t\t      BIT(cfg->merge_3d - MERGE_3D_0));\n\n\tif (cfg->dsc)\n\t\tDPU_REG_WRITE(c, CTL_DSC_ACTIVE, cfg->dsc);\n}\n\nstatic void dpu_hw_ctl_intf_cfg(struct dpu_hw_ctl *ctx,\n\t\tstruct dpu_hw_intf_cfg *cfg)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tu32 intf_cfg = 0;\n\n\tintf_cfg |= (cfg->intf & 0xF) << 4;\n\n\tif (cfg->mode_3d) {\n\t\tintf_cfg |= BIT(19);\n\t\tintf_cfg |= (cfg->mode_3d - 0x1) << 20;\n\t}\n\n\tif (cfg->wb)\n\t\tintf_cfg |= (cfg->wb & 0x3) + 2;\n\n\tswitch (cfg->intf_mode_sel) {\n\tcase DPU_CTL_MODE_SEL_VID:\n\t\tintf_cfg &= ~BIT(17);\n\t\tintf_cfg &= ~(0x3 << 15);\n\t\tbreak;\n\tcase DPU_CTL_MODE_SEL_CMD:\n\t\tintf_cfg |= BIT(17);\n\t\tintf_cfg |= ((cfg->stream_sel & 0x3) << 15);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown interface type %d\\n\", cfg->intf_mode_sel);\n\t\treturn;\n\t}\n\n\tDPU_REG_WRITE(c, CTL_TOP, intf_cfg);\n}\n\nstatic void dpu_hw_ctl_reset_intf_cfg_v1(struct dpu_hw_ctl *ctx,\n\t\tstruct dpu_hw_intf_cfg *cfg)\n{\n\tstruct dpu_hw_blk_reg_map *c = &ctx->hw;\n\tu32 intf_active = 0;\n\tu32 wb_active = 0;\n\tu32 merge3d_active = 0;\n\tu32 dsc_active;\n\n\t \n\tif (cfg->merge_3d) {\n\t\tmerge3d_active = DPU_REG_READ(c, CTL_MERGE_3D_ACTIVE);\n\t\tmerge3d_active &= ~BIT(cfg->merge_3d - MERGE_3D_0);\n\t\tDPU_REG_WRITE(c, CTL_MERGE_3D_ACTIVE,\n\t\t\t\tmerge3d_active);\n\t}\n\n\tdpu_hw_ctl_clear_all_blendstages(ctx);\n\n\tif (cfg->intf) {\n\t\tintf_active = DPU_REG_READ(c, CTL_INTF_ACTIVE);\n\t\tintf_active &= ~BIT(cfg->intf - INTF_0);\n\t\tDPU_REG_WRITE(c, CTL_INTF_ACTIVE, intf_active);\n\t}\n\n\tif (cfg->wb) {\n\t\twb_active = DPU_REG_READ(c, CTL_WB_ACTIVE);\n\t\twb_active &= ~BIT(cfg->wb - WB_0);\n\t\tDPU_REG_WRITE(c, CTL_WB_ACTIVE, wb_active);\n\t}\n\n\tif (cfg->dsc) {\n\t\tdsc_active = DPU_REG_READ(c, CTL_DSC_ACTIVE);\n\t\tdsc_active &= ~cfg->dsc;\n\t\tDPU_REG_WRITE(c, CTL_DSC_ACTIVE, dsc_active);\n\t}\n}\n\nstatic void dpu_hw_ctl_set_fetch_pipe_active(struct dpu_hw_ctl *ctx,\n\tunsigned long *fetch_active)\n{\n\tint i;\n\tu32 val = 0;\n\n\tif (fetch_active) {\n\t\tfor (i = 0; i < SSPP_MAX; i++) {\n\t\t\tif (test_bit(i, fetch_active) &&\n\t\t\t\tfetch_tbl[i] != CTL_INVALID_BIT)\n\t\t\t\tval |= BIT(fetch_tbl[i]);\n\t\t}\n\t}\n\n\tDPU_REG_WRITE(&ctx->hw, CTL_FETCH_PIPE_ACTIVE, val);\n}\n\nstatic void _setup_ctl_ops(struct dpu_hw_ctl_ops *ops,\n\t\tunsigned long cap)\n{\n\tif (cap & BIT(DPU_CTL_ACTIVE_CFG)) {\n\t\tops->trigger_flush = dpu_hw_ctl_trigger_flush_v1;\n\t\tops->setup_intf_cfg = dpu_hw_ctl_intf_cfg_v1;\n\t\tops->reset_intf_cfg = dpu_hw_ctl_reset_intf_cfg_v1;\n\t\tops->update_pending_flush_intf =\n\t\t\tdpu_hw_ctl_update_pending_flush_intf_v1;\n\t\tops->update_pending_flush_merge_3d =\n\t\t\tdpu_hw_ctl_update_pending_flush_merge_3d_v1;\n\t\tops->update_pending_flush_wb = dpu_hw_ctl_update_pending_flush_wb_v1;\n\t\tops->update_pending_flush_dsc =\n\t\t\tdpu_hw_ctl_update_pending_flush_dsc_v1;\n\t} else {\n\t\tops->trigger_flush = dpu_hw_ctl_trigger_flush;\n\t\tops->setup_intf_cfg = dpu_hw_ctl_intf_cfg;\n\t\tops->update_pending_flush_intf =\n\t\t\tdpu_hw_ctl_update_pending_flush_intf;\n\t\tops->update_pending_flush_wb = dpu_hw_ctl_update_pending_flush_wb;\n\t}\n\tops->clear_pending_flush = dpu_hw_ctl_clear_pending_flush;\n\tops->update_pending_flush = dpu_hw_ctl_update_pending_flush;\n\tops->get_pending_flush = dpu_hw_ctl_get_pending_flush;\n\tops->get_flush_register = dpu_hw_ctl_get_flush_register;\n\tops->trigger_start = dpu_hw_ctl_trigger_start;\n\tops->is_started = dpu_hw_ctl_is_started;\n\tops->trigger_pending = dpu_hw_ctl_trigger_pending;\n\tops->reset = dpu_hw_ctl_reset_control;\n\tops->wait_reset_status = dpu_hw_ctl_wait_reset_status;\n\tops->clear_all_blendstages = dpu_hw_ctl_clear_all_blendstages;\n\tops->setup_blendstage = dpu_hw_ctl_setup_blendstage;\n\tops->update_pending_flush_sspp = dpu_hw_ctl_update_pending_flush_sspp;\n\tops->update_pending_flush_mixer = dpu_hw_ctl_update_pending_flush_mixer;\n\tif (cap & BIT(DPU_CTL_DSPP_SUB_BLOCK_FLUSH))\n\t\tops->update_pending_flush_dspp = dpu_hw_ctl_update_pending_flush_dspp_sub_blocks;\n\telse\n\t\tops->update_pending_flush_dspp = dpu_hw_ctl_update_pending_flush_dspp;\n\n\tif (cap & BIT(DPU_CTL_FETCH_ACTIVE))\n\t\tops->set_active_pipes = dpu_hw_ctl_set_fetch_pipe_active;\n};\n\nstruct dpu_hw_ctl *dpu_hw_ctl_init(const struct dpu_ctl_cfg *cfg,\n\t\tvoid __iomem *addr,\n\t\tu32 mixer_count,\n\t\tconst struct dpu_lm_cfg *mixer)\n{\n\tstruct dpu_hw_ctl *c;\n\n\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tc->hw.blk_addr = addr + cfg->base;\n\tc->hw.log_mask = DPU_DBG_MASK_CTL;\n\n\tc->caps = cfg;\n\t_setup_ctl_ops(&c->ops, c->caps->features);\n\tc->idx = cfg->id;\n\tc->mixer_count = mixer_count;\n\tc->mixer_hw_caps = mixer;\n\n\treturn c;\n}\n\nvoid dpu_hw_ctl_destroy(struct dpu_hw_ctl *ctx)\n{\n\tkfree(ctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}