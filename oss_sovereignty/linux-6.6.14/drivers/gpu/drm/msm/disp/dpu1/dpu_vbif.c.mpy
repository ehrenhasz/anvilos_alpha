{
  "module_name": "dpu_vbif.c",
  "hash_id": "24c33ef9aeb0f787c4da838c02b8c594110f754313c02f95eee37f548d640808",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/dpu1/dpu_vbif.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm:%s:%d] \" fmt, __func__, __LINE__\n\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#include \"dpu_vbif.h\"\n#include \"dpu_hw_vbif.h\"\n#include \"dpu_trace.h\"\n\nstatic struct dpu_hw_vbif *dpu_get_vbif(struct dpu_kms *dpu_kms, enum dpu_vbif vbif_idx)\n{\n\tif (vbif_idx < ARRAY_SIZE(dpu_kms->hw_vbif))\n\t\treturn dpu_kms->hw_vbif[vbif_idx];\n\n\treturn NULL;\n}\n\nstatic const char *dpu_vbif_name(enum dpu_vbif idx)\n{\n\tswitch (idx) {\n\tcase VBIF_RT:\n\t\treturn \"VBIF_RT\";\n\tcase VBIF_NRT:\n\t\treturn \"VBIF_NRT\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}\n\n \nstatic int _dpu_vbif_wait_for_xin_halt(struct dpu_hw_vbif *vbif, u32 xin_id)\n{\n\tktime_t timeout;\n\tbool status;\n\tint rc;\n\n\tif (!vbif || !vbif->cap || !vbif->ops.get_halt_ctrl) {\n\t\tDPU_ERROR(\"invalid arguments vbif %d\\n\", vbif != NULL);\n\t\treturn -EINVAL;\n\t}\n\n\ttimeout = ktime_add_us(ktime_get(), vbif->cap->xin_halt_timeout);\n\tfor (;;) {\n\t\tstatus = vbif->ops.get_halt_ctrl(vbif, xin_id);\n\t\tif (status)\n\t\t\tbreak;\n\t\tif (ktime_compare_safe(ktime_get(), timeout) > 0) {\n\t\t\tstatus = vbif->ops.get_halt_ctrl(vbif, xin_id);\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(501, 1000);\n\t}\n\n\tif (!status) {\n\t\trc = -ETIMEDOUT;\n\t\tDPU_ERROR(\"%s client %d not halting. TIMEDOUT.\\n\",\n\t\t\t\tdpu_vbif_name(vbif->idx), xin_id);\n\t} else {\n\t\trc = 0;\n\t\tDRM_DEBUG_ATOMIC(\"%s client %d is halted\\n\",\n\t\t\t\tdpu_vbif_name(vbif->idx), xin_id);\n\t}\n\n\treturn rc;\n}\n\n \nstatic void _dpu_vbif_apply_dynamic_ot_limit(struct dpu_hw_vbif *vbif,\n\t\tu32 *ot_lim, struct dpu_vbif_set_ot_params *params)\n{\n\tu64 pps;\n\tconst struct dpu_vbif_dynamic_ot_tbl *tbl;\n\tu32 i;\n\n\tif (!vbif || !(vbif->cap->features & BIT(DPU_VBIF_QOS_OTLIM)))\n\t\treturn;\n\n\t \n\tif (!params->is_wfd)\n\t\treturn;\n\n\tpps = params->frame_rate;\n\tpps *= params->width;\n\tpps *= params->height;\n\n\ttbl = params->rd ? &vbif->cap->dynamic_ot_rd_tbl :\n\t\t\t&vbif->cap->dynamic_ot_wr_tbl;\n\n\tfor (i = 0; i < tbl->count; i++) {\n\t\tif (pps <= tbl->cfg[i].pps) {\n\t\t\t*ot_lim = tbl->cfg[i].ot_limit;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tDRM_DEBUG_ATOMIC(\"%s xin:%d w:%d h:%d fps:%d pps:%llu ot:%u\\n\",\n\t\t\tdpu_vbif_name(vbif->idx), params->xin_id,\n\t\t\tparams->width, params->height, params->frame_rate,\n\t\t\tpps, *ot_lim);\n}\n\n \nstatic u32 _dpu_vbif_get_ot_limit(struct dpu_hw_vbif *vbif,\n\tstruct dpu_vbif_set_ot_params *params)\n{\n\tu32 ot_lim = 0;\n\tu32 val;\n\n\tif (!vbif || !vbif->cap) {\n\t\tDPU_ERROR(\"invalid arguments vbif %d\\n\", vbif != NULL);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vbif->cap->default_ot_wr_limit && !params->rd)\n\t\tot_lim = vbif->cap->default_ot_wr_limit;\n\telse if (vbif->cap->default_ot_rd_limit && params->rd)\n\t\tot_lim = vbif->cap->default_ot_rd_limit;\n\n\t \n\tif (ot_lim == 0)\n\t\tgoto exit;\n\n\t \n\t_dpu_vbif_apply_dynamic_ot_limit(vbif, &ot_lim, params);\n\n\tif (vbif && vbif->ops.get_limit_conf) {\n\t\tval = vbif->ops.get_limit_conf(vbif,\n\t\t\t\tparams->xin_id, params->rd);\n\t\tif (val == ot_lim)\n\t\t\tot_lim = 0;\n\t}\n\nexit:\n\tDRM_DEBUG_ATOMIC(\"%s xin:%d ot_lim:%d\\n\",\n\t\t\tdpu_vbif_name(vbif->idx), params->xin_id, ot_lim);\n\treturn ot_lim;\n}\n\n \nvoid dpu_vbif_set_ot_limit(struct dpu_kms *dpu_kms,\n\t\tstruct dpu_vbif_set_ot_params *params)\n{\n\tstruct dpu_hw_vbif *vbif;\n\tstruct dpu_hw_mdp *mdp;\n\tbool forced_on = false;\n\tu32 ot_lim;\n\tint ret;\n\n\tmdp = dpu_kms->hw_mdp;\n\n\tvbif = dpu_get_vbif(dpu_kms, params->vbif_idx);\n\tif (!vbif || !mdp) {\n\t\tDRM_DEBUG_ATOMIC(\"invalid arguments vbif %d mdp %d\\n\",\n\t\t\t\tvbif != NULL, mdp != NULL);\n\t\treturn;\n\t}\n\n\tif (!mdp->ops.setup_clk_force_ctrl ||\n\t\t\t!vbif->ops.set_limit_conf ||\n\t\t\t!vbif->ops.set_halt_ctrl)\n\t\treturn;\n\n\t \n\tif (vbif->ops.set_write_gather_en && !params->rd)\n\t\tvbif->ops.set_write_gather_en(vbif, params->xin_id);\n\n\tot_lim = _dpu_vbif_get_ot_limit(vbif, params) & 0xFF;\n\n\tif (ot_lim == 0)\n\t\treturn;\n\n\ttrace_dpu_perf_set_ot(params->num, params->xin_id, ot_lim,\n\t\tparams->vbif_idx);\n\n\tforced_on = mdp->ops.setup_clk_force_ctrl(mdp, params->clk_ctrl, true);\n\n\tvbif->ops.set_limit_conf(vbif, params->xin_id, params->rd, ot_lim);\n\n\tvbif->ops.set_halt_ctrl(vbif, params->xin_id, true);\n\n\tret = _dpu_vbif_wait_for_xin_halt(vbif, params->xin_id);\n\tif (ret)\n\t\ttrace_dpu_vbif_wait_xin_halt_fail(vbif->idx, params->xin_id);\n\n\tvbif->ops.set_halt_ctrl(vbif, params->xin_id, false);\n\n\tif (forced_on)\n\t\tmdp->ops.setup_clk_force_ctrl(mdp, params->clk_ctrl, false);\n}\n\nvoid dpu_vbif_set_qos_remap(struct dpu_kms *dpu_kms,\n\t\tstruct dpu_vbif_set_qos_params *params)\n{\n\tstruct dpu_hw_vbif *vbif;\n\tstruct dpu_hw_mdp *mdp;\n\tbool forced_on = false;\n\tconst struct dpu_vbif_qos_tbl *qos_tbl;\n\tint i;\n\n\tif (!params || !dpu_kms->hw_mdp) {\n\t\tDPU_ERROR(\"invalid arguments\\n\");\n\t\treturn;\n\t}\n\tmdp = dpu_kms->hw_mdp;\n\n\tvbif = dpu_get_vbif(dpu_kms, params->vbif_idx);\n\n\tif (!vbif || !vbif->cap) {\n\t\tDPU_ERROR(\"invalid vbif %d\\n\", params->vbif_idx);\n\t\treturn;\n\t}\n\n\tif (!vbif->ops.set_qos_remap || !mdp->ops.setup_clk_force_ctrl) {\n\t\tDRM_DEBUG_ATOMIC(\"qos remap not supported\\n\");\n\t\treturn;\n\t}\n\n\tqos_tbl = params->is_rt ? &vbif->cap->qos_rt_tbl :\n\t\t\t&vbif->cap->qos_nrt_tbl;\n\n\tif (!qos_tbl->npriority_lvl || !qos_tbl->priority_lvl) {\n\t\tDRM_DEBUG_ATOMIC(\"qos tbl not defined\\n\");\n\t\treturn;\n\t}\n\n\tforced_on = mdp->ops.setup_clk_force_ctrl(mdp, params->clk_ctrl, true);\n\n\tfor (i = 0; i < qos_tbl->npriority_lvl; i++) {\n\t\tDRM_DEBUG_ATOMIC(\"%s xin:%d lvl:%d/%d\\n\",\n\t\t\t\tdpu_vbif_name(params->vbif_idx), params->xin_id, i,\n\t\t\t\tqos_tbl->priority_lvl[i]);\n\t\tvbif->ops.set_qos_remap(vbif, params->xin_id, i,\n\t\t\t\tqos_tbl->priority_lvl[i]);\n\t}\n\n\tif (forced_on)\n\t\tmdp->ops.setup_clk_force_ctrl(mdp, params->clk_ctrl, false);\n}\n\nvoid dpu_vbif_clear_errors(struct dpu_kms *dpu_kms)\n{\n\tstruct dpu_hw_vbif *vbif;\n\tu32 i, pnd, src;\n\n\tfor (i = 0; i < ARRAY_SIZE(dpu_kms->hw_vbif); i++) {\n\t\tvbif = dpu_kms->hw_vbif[i];\n\t\tif (vbif && vbif->ops.clear_errors) {\n\t\t\tvbif->ops.clear_errors(vbif, &pnd, &src);\n\t\t\tif (pnd || src) {\n\t\t\t\tDRM_DEBUG_KMS(\"%s: pnd 0x%X, src 0x%X\\n\",\n\t\t\t\t\t      dpu_vbif_name(vbif->idx), pnd, src);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dpu_vbif_init_memtypes(struct dpu_kms *dpu_kms)\n{\n\tstruct dpu_hw_vbif *vbif;\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(dpu_kms->hw_vbif); i++) {\n\t\tvbif = dpu_kms->hw_vbif[i];\n\t\tif (vbif && vbif->cap && vbif->ops.set_mem_type) {\n\t\t\tfor (j = 0; j < vbif->cap->memtype_count; j++)\n\t\t\t\tvbif->ops.set_mem_type(\n\t\t\t\t\t\tvbif, j, vbif->cap->memtype[j]);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_DEBUG_FS\n\nvoid dpu_debugfs_vbif_init(struct dpu_kms *dpu_kms, struct dentry *debugfs_root)\n{\n\tchar vbif_name[32];\n\tstruct dentry *entry, *debugfs_vbif;\n\tint i, j;\n\n\tentry = debugfs_create_dir(\"vbif\", debugfs_root);\n\n\tfor (i = 0; i < dpu_kms->catalog->vbif_count; i++) {\n\t\tconst struct dpu_vbif_cfg *vbif = &dpu_kms->catalog->vbif[i];\n\n\t\tsnprintf(vbif_name, sizeof(vbif_name), \"%d\", vbif->id);\n\n\t\tdebugfs_vbif = debugfs_create_dir(vbif_name, entry);\n\n\t\tdebugfs_create_u32(\"features\", 0600, debugfs_vbif,\n\t\t\t(u32 *)&vbif->features);\n\n\t\tdebugfs_create_u32(\"xin_halt_timeout\", 0400, debugfs_vbif,\n\t\t\t(u32 *)&vbif->xin_halt_timeout);\n\n\t\tdebugfs_create_u32(\"default_rd_ot_limit\", 0400, debugfs_vbif,\n\t\t\t(u32 *)&vbif->default_ot_rd_limit);\n\n\t\tdebugfs_create_u32(\"default_wr_ot_limit\", 0400, debugfs_vbif,\n\t\t\t(u32 *)&vbif->default_ot_wr_limit);\n\n\t\tfor (j = 0; j < vbif->dynamic_ot_rd_tbl.count; j++) {\n\t\t\tconst struct dpu_vbif_dynamic_ot_cfg *cfg =\n\t\t\t\t\t&vbif->dynamic_ot_rd_tbl.cfg[j];\n\n\t\t\tsnprintf(vbif_name, sizeof(vbif_name),\n\t\t\t\t\t\"dynamic_ot_rd_%d_pps\", j);\n\t\t\tdebugfs_create_u64(vbif_name, 0400, debugfs_vbif,\n\t\t\t\t\t(u64 *)&cfg->pps);\n\t\t\tsnprintf(vbif_name, sizeof(vbif_name),\n\t\t\t\t\t\"dynamic_ot_rd_%d_ot_limit\", j);\n\t\t\tdebugfs_create_u32(vbif_name, 0400, debugfs_vbif,\n\t\t\t\t\t(u32 *)&cfg->ot_limit);\n\t\t}\n\n\t\tfor (j = 0; j < vbif->dynamic_ot_wr_tbl.count; j++) {\n\t\t\tconst struct dpu_vbif_dynamic_ot_cfg *cfg =\n\t\t\t\t\t&vbif->dynamic_ot_wr_tbl.cfg[j];\n\n\t\t\tsnprintf(vbif_name, sizeof(vbif_name),\n\t\t\t\t\t\"dynamic_ot_wr_%d_pps\", j);\n\t\t\tdebugfs_create_u64(vbif_name, 0400, debugfs_vbif,\n\t\t\t\t\t(u64 *)&cfg->pps);\n\t\t\tsnprintf(vbif_name, sizeof(vbif_name),\n\t\t\t\t\t\"dynamic_ot_wr_%d_ot_limit\", j);\n\t\t\tdebugfs_create_u32(vbif_name, 0400, debugfs_vbif,\n\t\t\t\t\t(u32 *)&cfg->ot_limit);\n\t\t}\n\t}\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}