{
  "module_name": "mdp5_plane.c",
  "hash_id": "98f940d8acc4fbba64f51da516ce92e431ed16499fe54b2d54e891994091eb96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp5/mdp5_plane.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_print.h>\n\n#include \"mdp5_kms.h\"\n\nstruct mdp5_plane {\n\tstruct drm_plane base;\n\n\tuint32_t nformats;\n\tuint32_t formats[32];\n};\n#define to_mdp5_plane(x) container_of(x, struct mdp5_plane, base)\n\nstatic int mdp5_plane_mode_set(struct drm_plane *plane,\n\t\tstruct drm_crtc *crtc, struct drm_framebuffer *fb,\n\t\tstruct drm_rect *src, struct drm_rect *dest);\n\nstatic struct mdp5_kms *get_kms(struct drm_plane *plane)\n{\n\tstruct msm_drm_private *priv = plane->dev->dev_private;\n\treturn to_mdp5_kms(to_mdp_kms(priv->kms));\n}\n\nstatic bool plane_enabled(struct drm_plane_state *state)\n{\n\treturn state->visible;\n}\n\nstatic void mdp5_plane_destroy(struct drm_plane *plane)\n{\n\tstruct mdp5_plane *mdp5_plane = to_mdp5_plane(plane);\n\n\tdrm_plane_cleanup(plane);\n\n\tkfree(mdp5_plane);\n}\n\n \nstatic void mdp5_plane_install_properties(struct drm_plane *plane,\n\t\tstruct drm_mode_object *obj)\n{\n\tunsigned int zpos;\n\n\tdrm_plane_create_rotation_property(plane,\n\t\t\t\t\t   DRM_MODE_ROTATE_0,\n\t\t\t\t\t   DRM_MODE_ROTATE_0 |\n\t\t\t\t\t   DRM_MODE_ROTATE_180 |\n\t\t\t\t\t   DRM_MODE_REFLECT_X |\n\t\t\t\t\t   DRM_MODE_REFLECT_Y);\n\tdrm_plane_create_alpha_property(plane);\n\tdrm_plane_create_blend_mode_property(plane,\n\t\t\tBIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\tBIT(DRM_MODE_BLEND_PREMULTI) |\n\t\t\tBIT(DRM_MODE_BLEND_COVERAGE));\n\n\tif (plane->type == DRM_PLANE_TYPE_PRIMARY)\n\t\tzpos = STAGE_BASE;\n\telse\n\t\tzpos = STAGE0 + drm_plane_index(plane);\n\tdrm_plane_create_zpos_property(plane, zpos, 1, 255);\n}\n\nstatic void\nmdp5_plane_atomic_print_state(struct drm_printer *p,\n\t\tconst struct drm_plane_state *state)\n{\n\tstruct mdp5_plane_state *pstate = to_mdp5_plane_state(state);\n\tstruct mdp5_kms *mdp5_kms = get_kms(state->plane);\n\n\tdrm_printf(p, \"\\thwpipe=%s\\n\", pstate->hwpipe ?\n\t\t\tpstate->hwpipe->name : \"(null)\");\n\tif (mdp5_kms->caps & MDP_CAP_SRC_SPLIT)\n\t\tdrm_printf(p, \"\\tright-hwpipe=%s\\n\",\n\t\t\t   pstate->r_hwpipe ? pstate->r_hwpipe->name :\n\t\t\t\t\t      \"(null)\");\n\tdrm_printf(p, \"\\tblend_mode=%u\\n\", pstate->base.pixel_blend_mode);\n\tdrm_printf(p, \"\\tzpos=%u\\n\", pstate->base.zpos);\n\tdrm_printf(p, \"\\tnormalized_zpos=%u\\n\", pstate->base.normalized_zpos);\n\tdrm_printf(p, \"\\talpha=%u\\n\", pstate->base.alpha);\n\tdrm_printf(p, \"\\tstage=%s\\n\", stage2name(pstate->stage));\n}\n\nstatic void mdp5_plane_reset(struct drm_plane *plane)\n{\n\tstruct mdp5_plane_state *mdp5_state;\n\n\tif (plane->state)\n\t\t__drm_atomic_helper_plane_destroy_state(plane->state);\n\n\tkfree(to_mdp5_plane_state(plane->state));\n\tplane->state = NULL;\n\tmdp5_state = kzalloc(sizeof(*mdp5_state), GFP_KERNEL);\n\tif (!mdp5_state)\n\t\treturn;\n\t__drm_atomic_helper_plane_reset(plane, &mdp5_state->base);\n}\n\nstatic struct drm_plane_state *\nmdp5_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct mdp5_plane_state *mdp5_state;\n\n\tif (WARN_ON(!plane->state))\n\t\treturn NULL;\n\n\tmdp5_state = kmemdup(to_mdp5_plane_state(plane->state),\n\t\t\tsizeof(*mdp5_state), GFP_KERNEL);\n\tif (!mdp5_state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &mdp5_state->base);\n\n\treturn &mdp5_state->base;\n}\n\nstatic void mdp5_plane_destroy_state(struct drm_plane *plane,\n\t\tstruct drm_plane_state *state)\n{\n\tstruct mdp5_plane_state *pstate = to_mdp5_plane_state(state);\n\n\t__drm_atomic_helper_plane_destroy_state(state);\n\n\tkfree(pstate);\n}\n\nstatic const struct drm_plane_funcs mdp5_plane_funcs = {\n\t\t.update_plane = drm_atomic_helper_update_plane,\n\t\t.disable_plane = drm_atomic_helper_disable_plane,\n\t\t.destroy = mdp5_plane_destroy,\n\t\t.reset = mdp5_plane_reset,\n\t\t.atomic_duplicate_state = mdp5_plane_duplicate_state,\n\t\t.atomic_destroy_state = mdp5_plane_destroy_state,\n\t\t.atomic_print_state = mdp5_plane_atomic_print_state,\n};\n\nstatic int mdp5_plane_prepare_fb(struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *new_state)\n{\n\tstruct msm_drm_private *priv = plane->dev->dev_private;\n\tstruct msm_kms *kms = priv->kms;\n\tbool needs_dirtyfb = to_mdp5_plane_state(new_state)->needs_dirtyfb;\n\n\tif (!new_state->fb)\n\t\treturn 0;\n\n\tdrm_gem_plane_helper_prepare_fb(plane, new_state);\n\n\treturn msm_framebuffer_prepare(new_state->fb, kms->aspace, needs_dirtyfb);\n}\n\nstatic void mdp5_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t  struct drm_plane_state *old_state)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(plane);\n\tstruct msm_kms *kms = &mdp5_kms->base.base;\n\tstruct drm_framebuffer *fb = old_state->fb;\n\tbool needed_dirtyfb = to_mdp5_plane_state(old_state)->needs_dirtyfb;\n\n\tif (!fb)\n\t\treturn;\n\n\tDBG(\"%s: cleanup: FB[%u]\", plane->name, fb->base.id);\n\tmsm_framebuffer_cleanup(fb, kms->aspace, needed_dirtyfb);\n}\n\nstatic int mdp5_plane_atomic_check_with_state(struct drm_crtc_state *crtc_state,\n\t\t\t\t\t      struct drm_plane_state *state)\n{\n\tstruct mdp5_plane_state *mdp5_state = to_mdp5_plane_state(state);\n\tstruct drm_plane *plane = state->plane;\n\tstruct drm_plane_state *old_state = plane->state;\n\tstruct mdp5_cfg *config = mdp5_cfg_get_config(get_kms(plane)->cfg);\n\tbool new_hwpipe = false;\n\tbool need_right_hwpipe = false;\n\tuint32_t max_width, max_height;\n\tbool out_of_bounds = false;\n\tuint32_t caps = 0;\n\tint min_scale, max_scale;\n\tint ret;\n\n\tDBG(\"%s: check (%d -> %d)\", plane->name,\n\t\t\tplane_enabled(old_state), plane_enabled(state));\n\n\tmax_width = config->hw->lm.max_width << 16;\n\tmax_height = config->hw->lm.max_height << 16;\n\n\t \n\tif (state->src_h > max_height)\n\t\tout_of_bounds = true;\n\n\tif (state->src_w > max_width) {\n\t\t \n\t\tif (config->hw->mdp.caps & MDP_CAP_SRC_SPLIT &&\n\t\t    (state->src_w <= 2 * max_width))\n\t\t\tneed_right_hwpipe = true;\n\t\telse\n\t\t\tout_of_bounds = true;\n\t}\n\n\tif (out_of_bounds) {\n\t\tstruct drm_rect src = drm_plane_state_src(state);\n\t\tDBG(\"Invalid source size \"DRM_RECT_FP_FMT,\n\t\t\t\tDRM_RECT_FP_ARG(&src));\n\t\treturn -ERANGE;\n\t}\n\n\tmin_scale = FRAC_16_16(1, 8);\n\tmax_scale = FRAC_16_16(8, 1);\n\n\tret = drm_atomic_helper_check_plane_state(state, crtc_state,\n\t\t\t\t\t\t  min_scale, max_scale,\n\t\t\t\t\t\t  true, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (plane_enabled(state)) {\n\t\tunsigned int rotation;\n\t\tconst struct mdp_format *format;\n\t\tstruct mdp5_kms *mdp5_kms = get_kms(plane);\n\t\tuint32_t blkcfg = 0;\n\n\t\tformat = to_mdp_format(msm_framebuffer_format(state->fb));\n\t\tif (MDP_FORMAT_IS_YUV(format))\n\t\t\tcaps |= MDP_PIPE_CAP_SCALE | MDP_PIPE_CAP_CSC;\n\n\t\tif (((state->src_w >> 16) != state->crtc_w) ||\n\t\t\t\t((state->src_h >> 16) != state->crtc_h))\n\t\t\tcaps |= MDP_PIPE_CAP_SCALE;\n\n\t\trotation = drm_rotation_simplify(state->rotation,\n\t\t\t\t\t\t DRM_MODE_ROTATE_0 |\n\t\t\t\t\t\t DRM_MODE_REFLECT_X |\n\t\t\t\t\t\t DRM_MODE_REFLECT_Y);\n\n\t\tif (rotation & DRM_MODE_REFLECT_X)\n\t\t\tcaps |= MDP_PIPE_CAP_HFLIP;\n\n\t\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\t\tcaps |= MDP_PIPE_CAP_VFLIP;\n\n\t\tif (plane->type == DRM_PLANE_TYPE_CURSOR)\n\t\t\tcaps |= MDP_PIPE_CAP_CURSOR;\n\n\t\t \n\t\tif (!mdp5_state->hwpipe || (caps & ~mdp5_state->hwpipe->caps))\n\t\t\tnew_hwpipe = true;\n\n\t\t \n\t\tif ((need_right_hwpipe && !mdp5_state->r_hwpipe) ||\n\t\t    (!need_right_hwpipe && mdp5_state->r_hwpipe))\n\t\t\tnew_hwpipe = true;\n\n\t\tif (mdp5_kms->smp) {\n\t\t\tconst struct mdp_format *format =\n\t\t\t\tto_mdp_format(msm_framebuffer_format(state->fb));\n\n\t\t\tblkcfg = mdp5_smp_calculate(mdp5_kms->smp, format,\n\t\t\t\t\tstate->src_w >> 16, false);\n\n\t\t\tif (mdp5_state->hwpipe && (mdp5_state->hwpipe->blkcfg != blkcfg))\n\t\t\t\tnew_hwpipe = true;\n\t\t}\n\n\t\t \n\t\tif (new_hwpipe) {\n\t\t\t \n\t\t\tstruct mdp5_hw_pipe *old_hwpipe = mdp5_state->hwpipe;\n\t\t\tstruct mdp5_hw_pipe *old_right_hwpipe =\n\t\t\t\t\t\t\t  mdp5_state->r_hwpipe;\n\t\t\tstruct mdp5_hw_pipe *new_hwpipe = NULL;\n\t\t\tstruct mdp5_hw_pipe *new_right_hwpipe = NULL;\n\n\t\t\tret = mdp5_pipe_assign(state->state, plane, caps,\n\t\t\t\t\t       blkcfg, &new_hwpipe,\n\t\t\t\t\t       need_right_hwpipe ?\n\t\t\t\t\t       &new_right_hwpipe : NULL);\n\t\t\tif (ret) {\n\t\t\t\tDBG(\"%s: failed to assign hwpipe(s)!\",\n\t\t\t\t    plane->name);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tmdp5_state->hwpipe = new_hwpipe;\n\t\t\tif (need_right_hwpipe)\n\t\t\t\tmdp5_state->r_hwpipe = new_right_hwpipe;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tmdp5_state->r_hwpipe = NULL;\n\n\n\t\t\tret = mdp5_pipe_release(state->state, old_hwpipe);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = mdp5_pipe_release(state->state, old_right_hwpipe);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t}\n\t} else {\n\t\tret = mdp5_pipe_release(state->state, mdp5_state->hwpipe);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mdp5_pipe_release(state->state, mdp5_state->r_hwpipe);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmdp5_state->hwpipe = mdp5_state->r_hwpipe = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mdp5_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\n\tcrtc = new_plane_state->crtc ? new_plane_state->crtc : old_plane_state->crtc;\n\tif (!crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t\tcrtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn -EINVAL;\n\n\treturn mdp5_plane_atomic_check_with_state(crtc_state, new_plane_state);\n}\n\nstatic void mdp5_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\n\tDBG(\"%s: update\", plane->name);\n\n\tif (plane_enabled(new_state)) {\n\t\tint ret;\n\n\t\tret = mdp5_plane_mode_set(plane,\n\t\t\t\tnew_state->crtc, new_state->fb,\n\t\t\t\t&new_state->src, &new_state->dst);\n\t\t \n\t\tWARN_ON(ret < 0);\n\t}\n}\n\nstatic int mdp5_plane_atomic_async_check(struct drm_plane *plane,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct mdp5_plane_state *mdp5_state = to_mdp5_plane_state(new_plane_state);\n\tstruct drm_crtc_state *crtc_state;\n\tint min_scale, max_scale;\n\tint ret;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t\tnew_plane_state->crtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn -EINVAL;\n\n\tif (!crtc_state->active)\n\t\treturn -EINVAL;\n\n\t \n\tif (!mdp5_state->hwpipe)\n\t\treturn -EINVAL;\n\n\t \n\tif (plane->state->crtc != new_plane_state->crtc ||\n\t    plane->state->src_w != new_plane_state->src_w ||\n\t    plane->state->src_h != new_plane_state->src_h ||\n\t    plane->state->crtc_w != new_plane_state->crtc_w ||\n\t    plane->state->crtc_h != new_plane_state->crtc_h ||\n\t    !plane->state->fb ||\n\t    plane->state->fb != new_plane_state->fb)\n\t\treturn -EINVAL;\n\n\tmin_scale = FRAC_16_16(1, 8);\n\tmax_scale = FRAC_16_16(8, 1);\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,\n\t\t\t\t\t\t  min_scale, max_scale,\n\t\t\t\t\t\t  true, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (new_plane_state->visible != plane->state->visible)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void mdp5_plane_atomic_async_update(struct drm_plane *plane,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_framebuffer *old_fb = plane->state->fb;\n\n\tplane->state->src_x = new_state->src_x;\n\tplane->state->src_y = new_state->src_y;\n\tplane->state->crtc_x = new_state->crtc_x;\n\tplane->state->crtc_y = new_state->crtc_y;\n\n\tif (plane_enabled(new_state)) {\n\t\tstruct mdp5_ctl *ctl;\n\t\tstruct mdp5_pipeline *pipeline =\n\t\t\t\t\tmdp5_crtc_get_pipeline(new_state->crtc);\n\t\tint ret;\n\n\t\tret = mdp5_plane_mode_set(plane, new_state->crtc, new_state->fb,\n\t\t\t\t&new_state->src, &new_state->dst);\n\t\tWARN_ON(ret < 0);\n\n\t\tctl = mdp5_crtc_get_ctl(new_state->crtc);\n\n\t\tmdp5_ctl_commit(ctl, pipeline, mdp5_plane_get_flush(plane), true);\n\t}\n\n\t*to_mdp5_plane_state(plane->state) =\n\t\t*to_mdp5_plane_state(new_state);\n\n\tnew_state->fb = old_fb;\n}\n\nstatic const struct drm_plane_helper_funcs mdp5_plane_helper_funcs = {\n\t\t.prepare_fb = mdp5_plane_prepare_fb,\n\t\t.cleanup_fb = mdp5_plane_cleanup_fb,\n\t\t.atomic_check = mdp5_plane_atomic_check,\n\t\t.atomic_update = mdp5_plane_atomic_update,\n\t\t.atomic_async_check = mdp5_plane_atomic_async_check,\n\t\t.atomic_async_update = mdp5_plane_atomic_async_update,\n};\n\nstatic void set_scanout_locked(struct mdp5_kms *mdp5_kms,\n\t\t\t       enum mdp5_pipe pipe,\n\t\t\t       struct drm_framebuffer *fb)\n{\n\tstruct msm_kms *kms = &mdp5_kms->base.base;\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC_STRIDE_A(pipe),\n\t\t\tMDP5_PIPE_SRC_STRIDE_A_P0(fb->pitches[0]) |\n\t\t\tMDP5_PIPE_SRC_STRIDE_A_P1(fb->pitches[1]));\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC_STRIDE_B(pipe),\n\t\t\tMDP5_PIPE_SRC_STRIDE_B_P2(fb->pitches[2]) |\n\t\t\tMDP5_PIPE_SRC_STRIDE_B_P3(fb->pitches[3]));\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC0_ADDR(pipe),\n\t\t\tmsm_framebuffer_iova(fb, kms->aspace, 0));\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC1_ADDR(pipe),\n\t\t\tmsm_framebuffer_iova(fb, kms->aspace, 1));\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC2_ADDR(pipe),\n\t\t\tmsm_framebuffer_iova(fb, kms->aspace, 2));\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC3_ADDR(pipe),\n\t\t\tmsm_framebuffer_iova(fb, kms->aspace, 3));\n}\n\n \nstatic void csc_disable(struct mdp5_kms *mdp5_kms, enum mdp5_pipe pipe)\n{\n\tuint32_t value = mdp5_read(mdp5_kms, REG_MDP5_PIPE_OP_MODE(pipe)) &\n\t\t\t ~MDP5_PIPE_OP_MODE_CSC_1_EN;\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_OP_MODE(pipe), value);\n}\n\n \nstatic void csc_enable(struct mdp5_kms *mdp5_kms, enum mdp5_pipe pipe,\n\t\tstruct csc_cfg *csc)\n{\n\tuint32_t  i, mode = 0;  \n\tuint32_t *matrix;\n\n\tif (unlikely(!csc))\n\t\treturn;\n\n\tif ((csc->type == CSC_YUV2RGB) || (CSC_YUV2YUV == csc->type))\n\t\tmode |= MDP5_PIPE_OP_MODE_CSC_SRC_DATA_FORMAT(DATA_FORMAT_YUV);\n\tif ((csc->type == CSC_RGB2YUV) || (CSC_YUV2YUV == csc->type))\n\t\tmode |= MDP5_PIPE_OP_MODE_CSC_DST_DATA_FORMAT(DATA_FORMAT_YUV);\n\tmode |= MDP5_PIPE_OP_MODE_CSC_1_EN;\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_OP_MODE(pipe), mode);\n\n\tmatrix = csc->matrix;\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_CSC_1_MATRIX_COEFF_0(pipe),\n\t\t\tMDP5_PIPE_CSC_1_MATRIX_COEFF_0_COEFF_11(matrix[0]) |\n\t\t\tMDP5_PIPE_CSC_1_MATRIX_COEFF_0_COEFF_12(matrix[1]));\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_CSC_1_MATRIX_COEFF_1(pipe),\n\t\t\tMDP5_PIPE_CSC_1_MATRIX_COEFF_1_COEFF_13(matrix[2]) |\n\t\t\tMDP5_PIPE_CSC_1_MATRIX_COEFF_1_COEFF_21(matrix[3]));\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_CSC_1_MATRIX_COEFF_2(pipe),\n\t\t\tMDP5_PIPE_CSC_1_MATRIX_COEFF_2_COEFF_22(matrix[4]) |\n\t\t\tMDP5_PIPE_CSC_1_MATRIX_COEFF_2_COEFF_23(matrix[5]));\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_CSC_1_MATRIX_COEFF_3(pipe),\n\t\t\tMDP5_PIPE_CSC_1_MATRIX_COEFF_3_COEFF_31(matrix[6]) |\n\t\t\tMDP5_PIPE_CSC_1_MATRIX_COEFF_3_COEFF_32(matrix[7]));\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_CSC_1_MATRIX_COEFF_4(pipe),\n\t\t\tMDP5_PIPE_CSC_1_MATRIX_COEFF_4_COEFF_33(matrix[8]));\n\n\tfor (i = 0; i < ARRAY_SIZE(csc->pre_bias); i++) {\n\t\tuint32_t *pre_clamp = csc->pre_clamp;\n\t\tuint32_t *post_clamp = csc->post_clamp;\n\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_CSC_1_PRE_CLAMP(pipe, i),\n\t\t\tMDP5_PIPE_CSC_1_PRE_CLAMP_REG_HIGH(pre_clamp[2*i+1]) |\n\t\t\tMDP5_PIPE_CSC_1_PRE_CLAMP_REG_LOW(pre_clamp[2*i]));\n\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_CSC_1_POST_CLAMP(pipe, i),\n\t\t\tMDP5_PIPE_CSC_1_POST_CLAMP_REG_HIGH(post_clamp[2*i+1]) |\n\t\t\tMDP5_PIPE_CSC_1_POST_CLAMP_REG_LOW(post_clamp[2*i]));\n\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_CSC_1_PRE_BIAS(pipe, i),\n\t\t\tMDP5_PIPE_CSC_1_PRE_BIAS_REG_VALUE(csc->pre_bias[i]));\n\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_CSC_1_POST_BIAS(pipe, i),\n\t\t\tMDP5_PIPE_CSC_1_POST_BIAS_REG_VALUE(csc->post_bias[i]));\n\t}\n}\n\n#define PHASE_STEP_SHIFT\t21\n#define DOWN_SCALE_RATIO_MAX\t32\t \n\nstatic int calc_phase_step(uint32_t src, uint32_t dst, uint32_t *out_phase)\n{\n\tuint32_t unit;\n\n\tif (src == 0 || dst == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (src > (dst * DOWN_SCALE_RATIO_MAX))\n\t\treturn -EOVERFLOW;\n\n\tunit = 1 << PHASE_STEP_SHIFT;\n\t*out_phase = mult_frac(unit, src, dst);\n\n\treturn 0;\n}\n\nstatic int calc_scalex_steps(struct drm_plane *plane,\n\t\tuint32_t pixel_format, uint32_t src, uint32_t dest,\n\t\tuint32_t phasex_steps[COMP_MAX])\n{\n\tconst struct drm_format_info *info = drm_format_info(pixel_format);\n\tstruct mdp5_kms *mdp5_kms = get_kms(plane);\n\tstruct device *dev = mdp5_kms->dev->dev;\n\tuint32_t phasex_step;\n\tint ret;\n\n\tret = calc_phase_step(src, dest, &phasex_step);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"X scaling (%d->%d) failed: %d\\n\", src, dest, ret);\n\t\treturn ret;\n\t}\n\n\tphasex_steps[COMP_0]   = phasex_step;\n\tphasex_steps[COMP_3]   = phasex_step;\n\tphasex_steps[COMP_1_2] = phasex_step / info->hsub;\n\n\treturn 0;\n}\n\nstatic int calc_scaley_steps(struct drm_plane *plane,\n\t\tuint32_t pixel_format, uint32_t src, uint32_t dest,\n\t\tuint32_t phasey_steps[COMP_MAX])\n{\n\tconst struct drm_format_info *info = drm_format_info(pixel_format);\n\tstruct mdp5_kms *mdp5_kms = get_kms(plane);\n\tstruct device *dev = mdp5_kms->dev->dev;\n\tuint32_t phasey_step;\n\tint ret;\n\n\tret = calc_phase_step(src, dest, &phasey_step);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"Y scaling (%d->%d) failed: %d\\n\", src, dest, ret);\n\t\treturn ret;\n\t}\n\n\tphasey_steps[COMP_0]   = phasey_step;\n\tphasey_steps[COMP_3]   = phasey_step;\n\tphasey_steps[COMP_1_2] = phasey_step / info->vsub;\n\n\treturn 0;\n}\n\nstatic uint32_t get_scale_config(const struct mdp_format *format,\n\t\tuint32_t src, uint32_t dst, bool horz)\n{\n\tconst struct drm_format_info *info = drm_format_info(format->base.pixel_format);\n\tbool scaling = format->is_yuv ? true : (src != dst);\n\tuint32_t sub;\n\tuint32_t ya_filter, uv_filter;\n\tbool yuv = format->is_yuv;\n\n\tif (!scaling)\n\t\treturn 0;\n\n\tif (yuv) {\n\t\tsub = horz ? info->hsub : info->vsub;\n\t\tuv_filter = ((src / sub) <= dst) ?\n\t\t\t\t   SCALE_FILTER_BIL : SCALE_FILTER_PCMN;\n\t}\n\tya_filter = (src <= dst) ? SCALE_FILTER_BIL : SCALE_FILTER_PCMN;\n\n\tif (horz)\n\t\treturn  MDP5_PIPE_SCALE_CONFIG_SCALEX_EN |\n\t\t\tMDP5_PIPE_SCALE_CONFIG_SCALEX_FILTER_COMP_0(ya_filter) |\n\t\t\tMDP5_PIPE_SCALE_CONFIG_SCALEX_FILTER_COMP_3(ya_filter) |\n\t\t\tCOND(yuv, MDP5_PIPE_SCALE_CONFIG_SCALEX_FILTER_COMP_1_2(uv_filter));\n\telse\n\t\treturn  MDP5_PIPE_SCALE_CONFIG_SCALEY_EN |\n\t\t\tMDP5_PIPE_SCALE_CONFIG_SCALEY_FILTER_COMP_0(ya_filter) |\n\t\t\tMDP5_PIPE_SCALE_CONFIG_SCALEY_FILTER_COMP_3(ya_filter) |\n\t\t\tCOND(yuv, MDP5_PIPE_SCALE_CONFIG_SCALEY_FILTER_COMP_1_2(uv_filter));\n}\n\nstatic void calc_pixel_ext(const struct mdp_format *format,\n\t\tuint32_t src, uint32_t dst, uint32_t phase_step[2],\n\t\tint pix_ext_edge1[COMP_MAX], int pix_ext_edge2[COMP_MAX],\n\t\tbool horz)\n{\n\tbool scaling = format->is_yuv ? true : (src != dst);\n\tint i;\n\n\t \n\n\tfor (i = 0; i < COMP_MAX; i++) {\n\t\tpix_ext_edge1[i] = 0;\n\t\tpix_ext_edge2[i] = scaling ? 1 : 0;\n\t}\n}\n\nstatic void mdp5_write_pixel_ext(struct mdp5_kms *mdp5_kms, enum mdp5_pipe pipe,\n\tconst struct mdp_format *format,\n\tuint32_t src_w, int pe_left[COMP_MAX], int pe_right[COMP_MAX],\n\tuint32_t src_h, int pe_top[COMP_MAX], int pe_bottom[COMP_MAX])\n{\n\tconst struct drm_format_info *info = drm_format_info(format->base.pixel_format);\n\tuint32_t lr, tb, req;\n\tint i;\n\n\tfor (i = 0; i < COMP_MAX; i++) {\n\t\tuint32_t roi_w = src_w;\n\t\tuint32_t roi_h = src_h;\n\n\t\tif (format->is_yuv && i == COMP_1_2) {\n\t\t\troi_w /= info->hsub;\n\t\t\troi_h /= info->vsub;\n\t\t}\n\n\t\tlr  = (pe_left[i] >= 0) ?\n\t\t\tMDP5_PIPE_SW_PIX_EXT_LR_LEFT_RPT(pe_left[i]) :\n\t\t\tMDP5_PIPE_SW_PIX_EXT_LR_LEFT_OVF(pe_left[i]);\n\n\t\tlr |= (pe_right[i] >= 0) ?\n\t\t\tMDP5_PIPE_SW_PIX_EXT_LR_RIGHT_RPT(pe_right[i]) :\n\t\t\tMDP5_PIPE_SW_PIX_EXT_LR_RIGHT_OVF(pe_right[i]);\n\n\t\ttb  = (pe_top[i] >= 0) ?\n\t\t\tMDP5_PIPE_SW_PIX_EXT_TB_TOP_RPT(pe_top[i]) :\n\t\t\tMDP5_PIPE_SW_PIX_EXT_TB_TOP_OVF(pe_top[i]);\n\n\t\ttb |= (pe_bottom[i] >= 0) ?\n\t\t\tMDP5_PIPE_SW_PIX_EXT_TB_BOTTOM_RPT(pe_bottom[i]) :\n\t\t\tMDP5_PIPE_SW_PIX_EXT_TB_BOTTOM_OVF(pe_bottom[i]);\n\n\t\treq  = MDP5_PIPE_SW_PIX_EXT_REQ_PIXELS_LEFT_RIGHT(roi_w +\n\t\t\t\tpe_left[i] + pe_right[i]);\n\n\t\treq |= MDP5_PIPE_SW_PIX_EXT_REQ_PIXELS_TOP_BOTTOM(roi_h +\n\t\t\t\tpe_top[i] + pe_bottom[i]);\n\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SW_PIX_EXT_LR(pipe, i), lr);\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SW_PIX_EXT_TB(pipe, i), tb);\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SW_PIX_EXT_REQ_PIXELS(pipe, i), req);\n\n\t\tDBG(\"comp-%d (L/R): rpt=%d/%d, ovf=%d/%d, req=%d\", i,\n\t\t\tFIELD(lr,  MDP5_PIPE_SW_PIX_EXT_LR_LEFT_RPT),\n\t\t\tFIELD(lr,  MDP5_PIPE_SW_PIX_EXT_LR_RIGHT_RPT),\n\t\t\tFIELD(lr,  MDP5_PIPE_SW_PIX_EXT_LR_LEFT_OVF),\n\t\t\tFIELD(lr,  MDP5_PIPE_SW_PIX_EXT_LR_RIGHT_OVF),\n\t\t\tFIELD(req, MDP5_PIPE_SW_PIX_EXT_REQ_PIXELS_LEFT_RIGHT));\n\n\t\tDBG(\"comp-%d (T/B): rpt=%d/%d, ovf=%d/%d, req=%d\", i,\n\t\t\tFIELD(tb,  MDP5_PIPE_SW_PIX_EXT_TB_TOP_RPT),\n\t\t\tFIELD(tb,  MDP5_PIPE_SW_PIX_EXT_TB_BOTTOM_RPT),\n\t\t\tFIELD(tb,  MDP5_PIPE_SW_PIX_EXT_TB_TOP_OVF),\n\t\t\tFIELD(tb,  MDP5_PIPE_SW_PIX_EXT_TB_BOTTOM_OVF),\n\t\t\tFIELD(req, MDP5_PIPE_SW_PIX_EXT_REQ_PIXELS_TOP_BOTTOM));\n\t}\n}\n\nstruct pixel_ext {\n\tint left[COMP_MAX];\n\tint right[COMP_MAX];\n\tint top[COMP_MAX];\n\tint bottom[COMP_MAX];\n};\n\nstruct phase_step {\n\tu32 x[COMP_MAX];\n\tu32 y[COMP_MAX];\n};\n\nstatic void mdp5_hwpipe_mode_set(struct mdp5_kms *mdp5_kms,\n\t\t\t\t struct mdp5_hw_pipe *hwpipe,\n\t\t\t\t struct drm_framebuffer *fb,\n\t\t\t\t struct phase_step *step,\n\t\t\t\t struct pixel_ext *pe,\n\t\t\t\t u32 scale_config, u32 hdecm, u32 vdecm,\n\t\t\t\t bool hflip, bool vflip,\n\t\t\t\t int crtc_x, int crtc_y,\n\t\t\t\t unsigned int crtc_w, unsigned int crtc_h,\n\t\t\t\t u32 src_img_w, u32 src_img_h,\n\t\t\t\t u32 src_x, u32 src_y,\n\t\t\t\t u32 src_w, u32 src_h)\n{\n\tenum mdp5_pipe pipe = hwpipe->pipe;\n\tbool has_pe = hwpipe->caps & MDP_PIPE_CAP_SW_PIX_EXT;\n\tconst struct mdp_format *format =\n\t\t\tto_mdp_format(msm_framebuffer_format(fb));\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC_IMG_SIZE(pipe),\n\t\t\tMDP5_PIPE_SRC_IMG_SIZE_WIDTH(src_img_w) |\n\t\t\tMDP5_PIPE_SRC_IMG_SIZE_HEIGHT(src_img_h));\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC_SIZE(pipe),\n\t\t\tMDP5_PIPE_SRC_SIZE_WIDTH(src_w) |\n\t\t\tMDP5_PIPE_SRC_SIZE_HEIGHT(src_h));\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC_XY(pipe),\n\t\t\tMDP5_PIPE_SRC_XY_X(src_x) |\n\t\t\tMDP5_PIPE_SRC_XY_Y(src_y));\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_OUT_SIZE(pipe),\n\t\t\tMDP5_PIPE_OUT_SIZE_WIDTH(crtc_w) |\n\t\t\tMDP5_PIPE_OUT_SIZE_HEIGHT(crtc_h));\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_OUT_XY(pipe),\n\t\t\tMDP5_PIPE_OUT_XY_X(crtc_x) |\n\t\t\tMDP5_PIPE_OUT_XY_Y(crtc_y));\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC_FORMAT(pipe),\n\t\t\tMDP5_PIPE_SRC_FORMAT_A_BPC(format->bpc_a) |\n\t\t\tMDP5_PIPE_SRC_FORMAT_R_BPC(format->bpc_r) |\n\t\t\tMDP5_PIPE_SRC_FORMAT_G_BPC(format->bpc_g) |\n\t\t\tMDP5_PIPE_SRC_FORMAT_B_BPC(format->bpc_b) |\n\t\t\tCOND(format->alpha_enable, MDP5_PIPE_SRC_FORMAT_ALPHA_ENABLE) |\n\t\t\tMDP5_PIPE_SRC_FORMAT_CPP(format->cpp - 1) |\n\t\t\tMDP5_PIPE_SRC_FORMAT_UNPACK_COUNT(format->unpack_count - 1) |\n\t\t\tCOND(format->unpack_tight, MDP5_PIPE_SRC_FORMAT_UNPACK_TIGHT) |\n\t\t\tMDP5_PIPE_SRC_FORMAT_FETCH_TYPE(format->fetch_type) |\n\t\t\tMDP5_PIPE_SRC_FORMAT_CHROMA_SAMP(format->chroma_sample));\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC_UNPACK(pipe),\n\t\t\tMDP5_PIPE_SRC_UNPACK_ELEM0(format->unpack[0]) |\n\t\t\tMDP5_PIPE_SRC_UNPACK_ELEM1(format->unpack[1]) |\n\t\t\tMDP5_PIPE_SRC_UNPACK_ELEM2(format->unpack[2]) |\n\t\t\tMDP5_PIPE_SRC_UNPACK_ELEM3(format->unpack[3]));\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC_OP_MODE(pipe),\n\t\t\t(hflip ? MDP5_PIPE_SRC_OP_MODE_FLIP_LR : 0) |\n\t\t\t(vflip ? MDP5_PIPE_SRC_OP_MODE_FLIP_UD : 0) |\n\t\t\tCOND(has_pe, MDP5_PIPE_SRC_OP_MODE_SW_PIX_EXT_OVERRIDE) |\n\t\t\tMDP5_PIPE_SRC_OP_MODE_BWC(BWC_LOSSLESS));\n\n\t \n\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SRC_ADDR_SW_STATUS(pipe), 0);\n\n\tif (hwpipe->caps & MDP_PIPE_CAP_SW_PIX_EXT)\n\t\tmdp5_write_pixel_ext(mdp5_kms, pipe, format,\n\t\t\t\tsrc_w, pe->left, pe->right,\n\t\t\t\tsrc_h, pe->top, pe->bottom);\n\n\tif (hwpipe->caps & MDP_PIPE_CAP_SCALE) {\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SCALE_PHASE_STEP_X(pipe),\n\t\t\t\tstep->x[COMP_0]);\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SCALE_PHASE_STEP_Y(pipe),\n\t\t\t\tstep->y[COMP_0]);\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SCALE_CR_PHASE_STEP_X(pipe),\n\t\t\t\tstep->x[COMP_1_2]);\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SCALE_CR_PHASE_STEP_Y(pipe),\n\t\t\t\tstep->y[COMP_1_2]);\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_DECIMATION(pipe),\n\t\t\t\tMDP5_PIPE_DECIMATION_VERT(vdecm) |\n\t\t\t\tMDP5_PIPE_DECIMATION_HORZ(hdecm));\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_SCALE_CONFIG(pipe),\n\t\t\t   scale_config);\n\t}\n\n\tif (hwpipe->caps & MDP_PIPE_CAP_CSC) {\n\t\tif (MDP_FORMAT_IS_YUV(format))\n\t\t\tcsc_enable(mdp5_kms, pipe,\n\t\t\t\t\tmdp_get_default_csc_cfg(CSC_YUV2RGB));\n\t\telse\n\t\t\tcsc_disable(mdp5_kms, pipe);\n\t}\n\n\tset_scanout_locked(mdp5_kms, pipe, fb);\n}\n\nstatic int mdp5_plane_mode_set(struct drm_plane *plane,\n\t\tstruct drm_crtc *crtc, struct drm_framebuffer *fb,\n\t\tstruct drm_rect *src, struct drm_rect *dest)\n{\n\tstruct drm_plane_state *pstate = plane->state;\n\tstruct mdp5_hw_pipe *hwpipe = to_mdp5_plane_state(pstate)->hwpipe;\n\tstruct mdp5_kms *mdp5_kms = get_kms(plane);\n\tenum mdp5_pipe pipe = hwpipe->pipe;\n\tstruct mdp5_hw_pipe *right_hwpipe;\n\tconst struct mdp_format *format;\n\tuint32_t nplanes, config = 0;\n\tstruct phase_step step = { { 0 } };\n\tstruct pixel_ext pe = { { 0 } };\n\tuint32_t hdecm = 0, vdecm = 0;\n\tuint32_t pix_format;\n\tunsigned int rotation;\n\tbool vflip, hflip;\n\tint crtc_x, crtc_y;\n\tunsigned int crtc_w, crtc_h;\n\tuint32_t src_x, src_y;\n\tuint32_t src_w, src_h;\n\tuint32_t src_img_w, src_img_h;\n\tint ret;\n\n\tnplanes = fb->format->num_planes;\n\n\t \n\tif (WARN_ON(nplanes > pipe2nclients(pipe)))\n\t\treturn -EINVAL;\n\n\tformat = to_mdp_format(msm_framebuffer_format(fb));\n\tpix_format = format->base.pixel_format;\n\n\tsrc_x = src->x1;\n\tsrc_y = src->y1;\n\tsrc_w = drm_rect_width(src);\n\tsrc_h = drm_rect_height(src);\n\n\tcrtc_x = dest->x1;\n\tcrtc_y = dest->y1;\n\tcrtc_w = drm_rect_width(dest);\n\tcrtc_h = drm_rect_height(dest);\n\n\t \n\tsrc_x = src_x >> 16;\n\tsrc_y = src_y >> 16;\n\tsrc_w = src_w >> 16;\n\tsrc_h = src_h >> 16;\n\n\tsrc_img_w = min(fb->width, src_w);\n\tsrc_img_h = min(fb->height, src_h);\n\n\tDBG(\"%s: FB[%u] %u,%u,%u,%u -> CRTC[%u] %d,%d,%u,%u\", plane->name,\n\t\t\tfb->base.id, src_x, src_y, src_w, src_h,\n\t\t\tcrtc->base.id, crtc_x, crtc_y, crtc_w, crtc_h);\n\n\tright_hwpipe = to_mdp5_plane_state(pstate)->r_hwpipe;\n\tif (right_hwpipe) {\n\t\t \n\t\tcrtc_w /= 2;\n\t\tsrc_w /= 2;\n\t\tsrc_img_w /= 2;\n\t}\n\n\tret = calc_scalex_steps(plane, pix_format, src_w, crtc_w, step.x);\n\tif (ret)\n\t\treturn ret;\n\n\tret = calc_scaley_steps(plane, pix_format, src_h, crtc_h, step.y);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hwpipe->caps & MDP_PIPE_CAP_SW_PIX_EXT) {\n\t\tcalc_pixel_ext(format, src_w, crtc_w, step.x,\n\t\t\t       pe.left, pe.right, true);\n\t\tcalc_pixel_ext(format, src_h, crtc_h, step.y,\n\t\t\t       pe.top, pe.bottom, false);\n\t}\n\n\t \n\n\t \n\tconfig |= get_scale_config(format, src_w, crtc_w, true);\n\tconfig |= get_scale_config(format, src_h, crtc_h, false);\n\tDBG(\"scale config = %x\", config);\n\n\trotation = drm_rotation_simplify(pstate->rotation,\n\t\t\t\t\t DRM_MODE_ROTATE_0 |\n\t\t\t\t\t DRM_MODE_REFLECT_X |\n\t\t\t\t\t DRM_MODE_REFLECT_Y);\n\thflip = !!(rotation & DRM_MODE_REFLECT_X);\n\tvflip = !!(rotation & DRM_MODE_REFLECT_Y);\n\n\tmdp5_hwpipe_mode_set(mdp5_kms, hwpipe, fb, &step, &pe,\n\t\t\t     config, hdecm, vdecm, hflip, vflip,\n\t\t\t     crtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t     src_img_w, src_img_h,\n\t\t\t     src_x, src_y, src_w, src_h);\n\tif (right_hwpipe)\n\t\tmdp5_hwpipe_mode_set(mdp5_kms, right_hwpipe, fb, &step, &pe,\n\t\t\t\t     config, hdecm, vdecm, hflip, vflip,\n\t\t\t\t     crtc_x + crtc_w, crtc_y, crtc_w, crtc_h,\n\t\t\t\t     src_img_w, src_img_h,\n\t\t\t\t     src_x + src_w, src_y, src_w, src_h);\n\n\treturn ret;\n}\n\n \nenum mdp5_pipe mdp5_plane_pipe(struct drm_plane *plane)\n{\n\tstruct mdp5_plane_state *pstate = to_mdp5_plane_state(plane->state);\n\n\tif (WARN_ON(!pstate->hwpipe))\n\t\treturn SSPP_NONE;\n\n\treturn pstate->hwpipe->pipe;\n}\n\nenum mdp5_pipe mdp5_plane_right_pipe(struct drm_plane *plane)\n{\n\tstruct mdp5_plane_state *pstate = to_mdp5_plane_state(plane->state);\n\n\tif (!pstate->r_hwpipe)\n\t\treturn SSPP_NONE;\n\n\treturn pstate->r_hwpipe->pipe;\n}\n\nuint32_t mdp5_plane_get_flush(struct drm_plane *plane)\n{\n\tstruct mdp5_plane_state *pstate = to_mdp5_plane_state(plane->state);\n\tu32 mask;\n\n\tif (WARN_ON(!pstate->hwpipe))\n\t\treturn 0;\n\n\tmask = pstate->hwpipe->flush_mask;\n\n\tif (pstate->r_hwpipe)\n\t\tmask |= pstate->r_hwpipe->flush_mask;\n\n\treturn mask;\n}\n\n \nstruct drm_plane *mdp5_plane_init(struct drm_device *dev,\n\t\t\t\t  enum drm_plane_type type)\n{\n\tstruct drm_plane *plane = NULL;\n\tstruct mdp5_plane *mdp5_plane;\n\tint ret;\n\n\tmdp5_plane = kzalloc(sizeof(*mdp5_plane), GFP_KERNEL);\n\tif (!mdp5_plane) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tplane = &mdp5_plane->base;\n\n\tmdp5_plane->nformats = mdp_get_formats(mdp5_plane->formats,\n\t\tARRAY_SIZE(mdp5_plane->formats), false);\n\n\tret = drm_universal_plane_init(dev, plane, 0xff, &mdp5_plane_funcs,\n\t\t\tmdp5_plane->formats, mdp5_plane->nformats,\n\t\t\tNULL, type, NULL);\n\tif (ret)\n\t\tgoto fail;\n\n\tdrm_plane_helper_add(plane, &mdp5_plane_helper_funcs);\n\n\tmdp5_plane_install_properties(plane, &plane->base);\n\n\tdrm_plane_enable_fb_damage_clips(plane);\n\n\treturn plane;\n\nfail:\n\tif (plane)\n\t\tmdp5_plane_destroy(plane);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}