{
  "module_name": "mdp5_smp.c",
  "hash_id": "3e62405818d9bbee142217b1f624ed9d10b91bf4a2952e1452370f3e6c0a16c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp5/mdp5_smp.c",
  "human_readable_source": "\n \n\n#include <drm/drm_fourcc.h>\n#include <drm/drm_util.h>\n\n#include \"mdp5_kms.h\"\n#include \"mdp5_smp.h\"\n\n\nstruct mdp5_smp {\n\tstruct drm_device *dev;\n\n\tuint8_t reserved[MAX_CLIENTS];  \n\n\tint blk_cnt;\n\tint blk_size;\n\n\t \n\tu32 alloc_w[22];\n\tu32 alloc_r[22];\n\tu32 pipe_reqprio_fifo_wm0[SSPP_MAX];\n\tu32 pipe_reqprio_fifo_wm1[SSPP_MAX];\n\tu32 pipe_reqprio_fifo_wm2[SSPP_MAX];\n};\n\nstatic inline\nstruct mdp5_kms *get_kms(struct mdp5_smp *smp)\n{\n\tstruct msm_drm_private *priv = smp->dev->dev_private;\n\n\treturn to_mdp5_kms(to_mdp_kms(priv->kms));\n}\n\nstatic inline u32 pipe2client(enum mdp5_pipe pipe, int plane)\n{\n#define CID_UNUSED\t0\n\n\tif (WARN_ON(plane >= pipe2nclients(pipe)))\n\t\treturn CID_UNUSED;\n\n\t \n\n\treturn mdp5_cfg->smp.clients[pipe] + plane;\n}\n\n \nstatic int smp_request_block(struct mdp5_smp *smp,\n\t\tstruct mdp5_smp_state *state,\n\t\tu32 cid, int nblks)\n{\n\tvoid *cs = state->client_state[cid];\n\tint i, avail, cnt = smp->blk_cnt;\n\tuint8_t reserved;\n\n\t \n\tWARN_ON(!bitmap_empty(cs, cnt));\n\n\treserved = smp->reserved[cid];\n\n\tif (reserved) {\n\t\tnblks = max(0, nblks - reserved);\n\t\tDBG(\"%d MMBs allocated (%d reserved)\", nblks, reserved);\n\t}\n\n\tavail = cnt - bitmap_weight(state->state, cnt);\n\tif (nblks > avail) {\n\t\tDRM_DEV_ERROR(smp->dev->dev, \"out of blks (req=%d > avail=%d)\\n\",\n\t\t\t\tnblks, avail);\n\t\treturn -ENOSPC;\n\t}\n\n\tfor (i = 0; i < nblks; i++) {\n\t\tint blk = find_first_zero_bit(state->state, cnt);\n\t\tset_bit(blk, cs);\n\t\tset_bit(blk, state->state);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_fifo_thresholds(struct mdp5_smp *smp,\n\t\tenum mdp5_pipe pipe, int nblks)\n{\n\tu32 smp_entries_per_blk = smp->blk_size / (128 / BITS_PER_BYTE);\n\tu32 val;\n\n\t \n\tval = (nblks * smp_entries_per_blk) / 4;\n\n\tsmp->pipe_reqprio_fifo_wm0[pipe] = val * 1;\n\tsmp->pipe_reqprio_fifo_wm1[pipe] = val * 2;\n\tsmp->pipe_reqprio_fifo_wm2[pipe] = val * 3;\n}\n\n \nuint32_t mdp5_smp_calculate(struct mdp5_smp *smp,\n\t\tconst struct mdp_format *format,\n\t\tu32 width, bool hdecim)\n{\n\tconst struct drm_format_info *info = drm_format_info(format->base.pixel_format);\n\tstruct mdp5_kms *mdp5_kms = get_kms(smp);\n\tint rev = mdp5_cfg_get_hw_rev(mdp5_kms->cfg);\n\tint i, hsub, nplanes, nlines;\n\tuint32_t blkcfg = 0;\n\n\tnplanes = info->num_planes;\n\thsub = info->hsub;\n\n\t \n\tnlines = 2;\n\n\t \n\tif ((rev > 0) && (format->chroma_sample > CHROMA_FULL)) {\n\t\tnplanes = 2;\n\n\t\t \n\t\tif (hdecim && (hsub > 1))\n\t\t\thsub = 1;\n\t}\n\n\tfor (i = 0; i < nplanes; i++) {\n\t\tint n, fetch_stride, cpp;\n\n\t\tcpp = info->cpp[i];\n\t\tfetch_stride = width * cpp / (i ? hsub : 1);\n\n\t\tn = DIV_ROUND_UP(fetch_stride * nlines, smp->blk_size);\n\n\t\t \n\t\tif (rev == 0)\n\t\t\tn = roundup_pow_of_two(n);\n\n\t\tblkcfg |= (n << (8 * i));\n\t}\n\n\treturn blkcfg;\n}\n\nint mdp5_smp_assign(struct mdp5_smp *smp, struct mdp5_smp_state *state,\n\t\tenum mdp5_pipe pipe, uint32_t blkcfg)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(smp);\n\tstruct drm_device *dev = mdp5_kms->dev;\n\tint i, ret;\n\n\tfor (i = 0; i < pipe2nclients(pipe); i++) {\n\t\tu32 cid = pipe2client(pipe, i);\n\t\tint n = blkcfg & 0xff;\n\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tDBG(\"%s[%d]: request %d SMP blocks\", pipe2name(pipe), i, n);\n\t\tret = smp_request_block(smp, state, cid, n);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"Cannot allocate %d SMP blocks: %d\\n\",\n\t\t\t\t\tn, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tblkcfg >>= 8;\n\t}\n\n\tstate->assigned |= (1 << pipe);\n\n\treturn 0;\n}\n\n \nvoid mdp5_smp_release(struct mdp5_smp *smp, struct mdp5_smp_state *state,\n\t\tenum mdp5_pipe pipe)\n{\n\tint i;\n\tint cnt = smp->blk_cnt;\n\n\tfor (i = 0; i < pipe2nclients(pipe); i++) {\n\t\tu32 cid = pipe2client(pipe, i);\n\t\tvoid *cs = state->client_state[cid];\n\n\t\t \n\t\tbitmap_andnot(state->state, state->state, cs, cnt);\n\n\t\t \n\t\tbitmap_zero(cs, cnt);\n\t}\n\n\tstate->released |= (1 << pipe);\n}\n\n \nstatic unsigned update_smp_state(struct mdp5_smp *smp,\n\t\tu32 cid, mdp5_smp_state_t *assigned)\n{\n\tint cnt = smp->blk_cnt;\n\tunsigned nblks = 0;\n\tu32 blk, val;\n\n\tfor_each_set_bit(blk, *assigned, cnt) {\n\t\tint idx = blk / 3;\n\t\tint fld = blk % 3;\n\n\t\tval = smp->alloc_w[idx];\n\n\t\tswitch (fld) {\n\t\tcase 0:\n\t\t\tval &= ~MDP5_SMP_ALLOC_W_REG_CLIENT0__MASK;\n\t\t\tval |= MDP5_SMP_ALLOC_W_REG_CLIENT0(cid);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tval &= ~MDP5_SMP_ALLOC_W_REG_CLIENT1__MASK;\n\t\t\tval |= MDP5_SMP_ALLOC_W_REG_CLIENT1(cid);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval &= ~MDP5_SMP_ALLOC_W_REG_CLIENT2__MASK;\n\t\t\tval |= MDP5_SMP_ALLOC_W_REG_CLIENT2(cid);\n\t\t\tbreak;\n\t\t}\n\n\t\tsmp->alloc_w[idx] = val;\n\t\tsmp->alloc_r[idx] = val;\n\n\t\tnblks++;\n\t}\n\n\treturn nblks;\n}\n\nstatic void write_smp_alloc_regs(struct mdp5_smp *smp)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(smp);\n\tint i, num_regs;\n\n\tnum_regs = smp->blk_cnt / 3 + 1;\n\n\tfor (i = 0; i < num_regs; i++) {\n\t\tmdp5_write(mdp5_kms, REG_MDP5_SMP_ALLOC_W_REG(i),\n\t\t\t   smp->alloc_w[i]);\n\t\tmdp5_write(mdp5_kms, REG_MDP5_SMP_ALLOC_R_REG(i),\n\t\t\t   smp->alloc_r[i]);\n\t}\n}\n\nstatic void write_smp_fifo_regs(struct mdp5_smp *smp)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(smp);\n\tint i;\n\n\tfor (i = 0; i < mdp5_kms->num_hwpipes; i++) {\n\t\tstruct mdp5_hw_pipe *hwpipe = mdp5_kms->hwpipes[i];\n\t\tenum mdp5_pipe pipe = hwpipe->pipe;\n\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_REQPRIO_FIFO_WM_0(pipe),\n\t\t\t   smp->pipe_reqprio_fifo_wm0[pipe]);\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_REQPRIO_FIFO_WM_1(pipe),\n\t\t\t   smp->pipe_reqprio_fifo_wm1[pipe]);\n\t\tmdp5_write(mdp5_kms, REG_MDP5_PIPE_REQPRIO_FIFO_WM_2(pipe),\n\t\t\t   smp->pipe_reqprio_fifo_wm2[pipe]);\n\t}\n}\n\nvoid mdp5_smp_prepare_commit(struct mdp5_smp *smp, struct mdp5_smp_state *state)\n{\n\tenum mdp5_pipe pipe;\n\n\tfor_each_set_bit(pipe, &state->assigned, sizeof(state->assigned) * 8) {\n\t\tunsigned i, nblks = 0;\n\n\t\tfor (i = 0; i < pipe2nclients(pipe); i++) {\n\t\t\tu32 cid = pipe2client(pipe, i);\n\t\t\tvoid *cs = state->client_state[cid];\n\n\t\t\tnblks += update_smp_state(smp, cid, cs);\n\n\t\t\tDBG(\"assign %s:%u, %u blks\",\n\t\t\t\tpipe2name(pipe), i, nblks);\n\t\t}\n\n\t\tset_fifo_thresholds(smp, pipe, nblks);\n\t}\n\n\twrite_smp_alloc_regs(smp);\n\twrite_smp_fifo_regs(smp);\n\n\tstate->assigned = 0;\n}\n\nvoid mdp5_smp_complete_commit(struct mdp5_smp *smp, struct mdp5_smp_state *state)\n{\n\tenum mdp5_pipe pipe;\n\n\tfor_each_set_bit(pipe, &state->released, sizeof(state->released) * 8) {\n\t\tDBG(\"release %s\", pipe2name(pipe));\n\t\tset_fifo_thresholds(smp, pipe, 0);\n\t}\n\n\twrite_smp_fifo_regs(smp);\n\n\tstate->released = 0;\n}\n\nvoid mdp5_smp_dump(struct mdp5_smp *smp, struct drm_printer *p)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(smp);\n\tstruct mdp5_hw_pipe_state *hwpstate;\n\tstruct mdp5_smp_state *state;\n\tstruct mdp5_global_state *global_state;\n\tint total = 0, i, j;\n\n\tdrm_printf(p, \"name\\tinuse\\tplane\\n\");\n\tdrm_printf(p, \"----\\t-----\\t-----\\n\");\n\n\tif (drm_can_sleep())\n\t\tdrm_modeset_lock(&mdp5_kms->glob_state_lock, NULL);\n\n\tglobal_state = mdp5_get_existing_global_state(mdp5_kms);\n\n\t \n\thwpstate = &global_state->hwpipe;\n\tstate = &global_state->smp;\n\n\tfor (i = 0; i < mdp5_kms->num_hwpipes; i++) {\n\t\tstruct mdp5_hw_pipe *hwpipe = mdp5_kms->hwpipes[i];\n\t\tstruct drm_plane *plane = hwpstate->hwpipe_to_plane[hwpipe->idx];\n\t\tenum mdp5_pipe pipe = hwpipe->pipe;\n\t\tfor (j = 0; j < pipe2nclients(pipe); j++) {\n\t\t\tu32 cid = pipe2client(pipe, j);\n\t\t\tvoid *cs = state->client_state[cid];\n\t\t\tint inuse = bitmap_weight(cs, smp->blk_cnt);\n\n\t\t\tdrm_printf(p, \"%s:%d\\t%d\\t%s\\n\",\n\t\t\t\tpipe2name(pipe), j, inuse,\n\t\t\t\tplane ? plane->name : NULL);\n\n\t\t\ttotal += inuse;\n\t\t}\n\t}\n\n\tdrm_printf(p, \"TOTAL:\\t%d\\t(of %d)\\n\", total, smp->blk_cnt);\n\tdrm_printf(p, \"AVAIL:\\t%d\\n\", smp->blk_cnt -\n\t\t\tbitmap_weight(state->state, smp->blk_cnt));\n\n\tif (drm_can_sleep())\n\t\tdrm_modeset_unlock(&mdp5_kms->glob_state_lock);\n}\n\nvoid mdp5_smp_destroy(struct mdp5_smp *smp)\n{\n\tkfree(smp);\n}\n\nstruct mdp5_smp *mdp5_smp_init(struct mdp5_kms *mdp5_kms, const struct mdp5_smp_block *cfg)\n{\n\tstruct mdp5_smp_state *state;\n\tstruct mdp5_global_state *global_state;\n\tstruct mdp5_smp *smp = NULL;\n\tint ret;\n\n\tsmp = kzalloc(sizeof(*smp), GFP_KERNEL);\n\tif (unlikely(!smp)) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tsmp->dev = mdp5_kms->dev;\n\tsmp->blk_cnt = cfg->mmb_count;\n\tsmp->blk_size = cfg->mmb_size;\n\n\tglobal_state = mdp5_get_existing_global_state(mdp5_kms);\n\tstate = &global_state->smp;\n\n\t \n\tbitmap_copy(state->state, cfg->reserved_state, smp->blk_cnt);\n\tmemcpy(smp->reserved, cfg->reserved, sizeof(smp->reserved));\n\n\treturn smp;\nfail:\n\tif (smp)\n\t\tmdp5_smp_destroy(smp);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}