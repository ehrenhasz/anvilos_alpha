{
  "module_name": "mdp5_crtc.c",
  "hash_id": "f0c40deb4b652f70c43bc6459d6daae10d76dea2ab4a7b21ec1460adead4c518",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp5/mdp5_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/sort.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_mode.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_flip_work.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"mdp5_kms.h\"\n#include \"msm_gem.h\"\n\n#define CURSOR_WIDTH\t64\n#define CURSOR_HEIGHT\t64\n\nstruct mdp5_crtc {\n\tstruct drm_crtc base;\n\tint id;\n\tbool enabled;\n\n\tspinlock_t lm_lock;      \n\n\t \n\tstruct drm_pending_vblank_event *event;\n\n\t \n\tu32 flushed_mask;\n\n#define PENDING_CURSOR 0x1\n#define PENDING_FLIP   0x2\n\tatomic_t pending;\n\n\t \n\tstruct drm_flip_work unref_cursor_work;\n\n\tstruct mdp_irq vblank;\n\tstruct mdp_irq err;\n\tstruct mdp_irq pp_done;\n\n\tstruct completion pp_completion;\n\n\tbool lm_cursor_enabled;\n\n\tstruct {\n\t\t \n\t\tspinlock_t lock;\n\n\t\t \n\t\tstruct drm_gem_object *scanout_bo;\n\t\tuint64_t iova;\n\t\tuint32_t width, height;\n\t\tint x, y;\n\t} cursor;\n};\n#define to_mdp5_crtc(x) container_of(x, struct mdp5_crtc, base)\n\nstatic void mdp5_crtc_restore_cursor(struct drm_crtc *crtc);\n\nstatic struct mdp5_kms *get_kms(struct drm_crtc *crtc)\n{\n\tstruct msm_drm_private *priv = crtc->dev->dev_private;\n\treturn to_mdp5_kms(to_mdp_kms(priv->kms));\n}\n\nstatic void request_pending(struct drm_crtc *crtc, uint32_t pending)\n{\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\n\tatomic_or(pending, &mdp5_crtc->pending);\n\tmdp_irq_register(&get_kms(crtc)->base, &mdp5_crtc->vblank);\n}\n\nstatic void request_pp_done_pending(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\treinit_completion(&mdp5_crtc->pp_completion);\n}\n\nstatic u32 crtc_flush(struct drm_crtc *crtc, u32 flush_mask)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_ctl *ctl = mdp5_cstate->ctl;\n\tstruct mdp5_pipeline *pipeline = &mdp5_cstate->pipeline;\n\tbool start = !mdp5_cstate->defer_start;\n\n\tmdp5_cstate->defer_start = false;\n\n\tDBG(\"%s: flush=%08x\", crtc->name, flush_mask);\n\n\treturn mdp5_ctl_commit(ctl, pipeline, flush_mask, start);\n}\n\n \nstatic u32 crtc_flush_all(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_hw_mixer *mixer, *r_mixer;\n\tstruct drm_plane *plane;\n\tuint32_t flush_mask = 0;\n\n\t \n\tif (WARN_ON(!mdp5_cstate->ctl))\n\t\treturn 0;\n\n\tdrm_atomic_crtc_for_each_plane(plane, crtc) {\n\t\tif (!plane->state->visible)\n\t\t\tcontinue;\n\t\tflush_mask |= mdp5_plane_get_flush(plane);\n\t}\n\n\tmixer = mdp5_cstate->pipeline.mixer;\n\tflush_mask |= mdp_ctl_flush_mask_lm(mixer->lm);\n\n\tr_mixer = mdp5_cstate->pipeline.r_mixer;\n\tif (r_mixer)\n\t\tflush_mask |= mdp_ctl_flush_mask_lm(r_mixer->lm);\n\n\treturn crtc_flush(crtc, flush_mask);\n}\n\n \nstatic void complete_flip(struct drm_crtc *crtc, struct drm_file *file)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_pipeline *pipeline = &mdp5_cstate->pipeline;\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tstruct mdp5_ctl *ctl = mdp5_cstate->ctl;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_pending_vblank_event *event;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tevent = mdp5_crtc->event;\n\tif (event) {\n\t\tmdp5_crtc->event = NULL;\n\t\tDBG(\"%s: send event: %p\", crtc->name, event);\n\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t}\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\tif (ctl && !crtc->state->enable) {\n\t\t \n\t\tmdp5_ctl_blend(ctl, pipeline, NULL, NULL, 0, 0);\n\t\t \n\t\t \n\t}\n}\n\nstatic void unref_cursor_worker(struct drm_flip_work *work, void *val)\n{\n\tstruct mdp5_crtc *mdp5_crtc =\n\t\tcontainer_of(work, struct mdp5_crtc, unref_cursor_work);\n\tstruct mdp5_kms *mdp5_kms = get_kms(&mdp5_crtc->base);\n\tstruct msm_kms *kms = &mdp5_kms->base.base;\n\n\tmsm_gem_unpin_iova(val, kms->aspace);\n\tdrm_gem_object_put(val);\n}\n\nstatic void mdp5_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\n\tdrm_crtc_cleanup(crtc);\n\tdrm_flip_work_cleanup(&mdp5_crtc->unref_cursor_work);\n\n\tkfree(mdp5_crtc);\n}\n\nstatic inline u32 mdp5_lm_use_fg_alpha_mask(enum mdp_mixer_stage_id stage)\n{\n\tswitch (stage) {\n\tcase STAGE0: return MDP5_LM_BLEND_COLOR_OUT_STAGE0_FG_ALPHA;\n\tcase STAGE1: return MDP5_LM_BLEND_COLOR_OUT_STAGE1_FG_ALPHA;\n\tcase STAGE2: return MDP5_LM_BLEND_COLOR_OUT_STAGE2_FG_ALPHA;\n\tcase STAGE3: return MDP5_LM_BLEND_COLOR_OUT_STAGE3_FG_ALPHA;\n\tcase STAGE4: return MDP5_LM_BLEND_COLOR_OUT_STAGE4_FG_ALPHA;\n\tcase STAGE5: return MDP5_LM_BLEND_COLOR_OUT_STAGE5_FG_ALPHA;\n\tcase STAGE6: return MDP5_LM_BLEND_COLOR_OUT_STAGE6_FG_ALPHA;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \n#define PIPE_LEFT\t0\n#define PIPE_RIGHT\t1\n\n \nstatic void blend_setup(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_pipeline *pipeline = &mdp5_cstate->pipeline;\n\tstruct mdp5_kms *mdp5_kms = get_kms(crtc);\n\tstruct drm_plane *plane;\n\tstruct mdp5_plane_state *pstate, *pstates[STAGE_MAX + 1] = {NULL};\n\tconst struct mdp_format *format;\n\tstruct mdp5_hw_mixer *mixer = pipeline->mixer;\n\tuint32_t lm = mixer->lm;\n\tstruct mdp5_hw_mixer *r_mixer = pipeline->r_mixer;\n\tuint32_t r_lm = r_mixer ? r_mixer->lm : 0;\n\tstruct mdp5_ctl *ctl = mdp5_cstate->ctl;\n\tuint32_t blend_op, fg_alpha, bg_alpha, ctl_blend_flags = 0;\n\tunsigned long flags;\n\tenum mdp5_pipe stage[STAGE_MAX + 1][MAX_PIPE_STAGE] = { { SSPP_NONE } };\n\tenum mdp5_pipe r_stage[STAGE_MAX + 1][MAX_PIPE_STAGE] = { { SSPP_NONE } };\n\tint i, plane_cnt = 0;\n\tbool bg_alpha_enabled = false;\n\tu32 mixer_op_mode = 0;\n\tu32 val;\n#define blender(stage)\t((stage) - STAGE0)\n\n\tspin_lock_irqsave(&mdp5_crtc->lm_lock, flags);\n\n\t \n\t \n\tif (!ctl)\n\t\tgoto out;\n\n\t \n\tdrm_atomic_crtc_for_each_plane(plane, crtc) {\n\t\tenum mdp5_pipe right_pipe;\n\n\t\tif (!plane->state->visible)\n\t\t\tcontinue;\n\n\t\tpstate = to_mdp5_plane_state(plane->state);\n\t\tpstates[pstate->stage] = pstate;\n\t\tstage[pstate->stage][PIPE_LEFT] = mdp5_plane_pipe(plane);\n\t\t \n\t\tif (r_mixer)\n\t\t\tr_stage[pstate->stage][PIPE_LEFT] =\n\t\t\t\t\t\tmdp5_plane_pipe(plane);\n\t\t \n\t\tright_pipe = mdp5_plane_right_pipe(plane);\n\t\tif (right_pipe) {\n\t\t\tstage[pstate->stage][PIPE_RIGHT] = right_pipe;\n\t\t\tr_stage[pstate->stage][PIPE_RIGHT] = right_pipe;\n\t\t}\n\n\t\tplane_cnt++;\n\t}\n\n\tif (!pstates[STAGE_BASE]) {\n\t\tctl_blend_flags |= MDP5_CTL_BLEND_OP_FLAG_BORDER_OUT;\n\t\tDBG(\"Border Color is enabled\");\n\t} else if (plane_cnt) {\n\t\tformat = to_mdp_format(msm_framebuffer_format(pstates[STAGE_BASE]->base.fb));\n\n\t\tif (format->alpha_enable)\n\t\t\tbg_alpha_enabled = true;\n\t}\n\n\t \n\tfor (i = STAGE0; i <= STAGE_MAX; i++) {\n\t\tif (!pstates[i])\n\t\t\tcontinue;\n\n\t\tformat = to_mdp_format(\n\t\t\tmsm_framebuffer_format(pstates[i]->base.fb));\n\t\tplane = pstates[i]->base.plane;\n\t\tblend_op = MDP5_LM_BLEND_OP_MODE_FG_ALPHA(FG_CONST) |\n\t\t\tMDP5_LM_BLEND_OP_MODE_BG_ALPHA(BG_CONST);\n\t\tfg_alpha = pstates[i]->base.alpha >> 8;\n\t\tbg_alpha = 0xFF - fg_alpha;\n\n\t\tif (!format->alpha_enable && bg_alpha_enabled)\n\t\t\tmixer_op_mode = 0;\n\t\telse\n\t\t\tmixer_op_mode |= mdp5_lm_use_fg_alpha_mask(i);\n\n\t\tDBG(\"Stage %d fg_alpha %x bg_alpha %x\", i, fg_alpha, bg_alpha);\n\n\t\tif (format->alpha_enable &&\n\t\t    pstates[i]->base.pixel_blend_mode == DRM_MODE_BLEND_PREMULTI) {\n\t\t\tblend_op = MDP5_LM_BLEND_OP_MODE_FG_ALPHA(FG_CONST) |\n\t\t\t\tMDP5_LM_BLEND_OP_MODE_BG_ALPHA(FG_PIXEL);\n\t\t\tif (fg_alpha != 0xff) {\n\t\t\t\tbg_alpha = fg_alpha;\n\t\t\t\tblend_op |=\n\t\t\t\t\tMDP5_LM_BLEND_OP_MODE_BG_MOD_ALPHA |\n\t\t\t\t\tMDP5_LM_BLEND_OP_MODE_BG_INV_MOD_ALPHA;\n\t\t\t} else {\n\t\t\t\tblend_op |= MDP5_LM_BLEND_OP_MODE_BG_INV_ALPHA;\n\t\t\t}\n\t\t} else if (format->alpha_enable &&\n\t\t\t   pstates[i]->base.pixel_blend_mode == DRM_MODE_BLEND_COVERAGE) {\n\t\t\tblend_op = MDP5_LM_BLEND_OP_MODE_FG_ALPHA(FG_PIXEL) |\n\t\t\t\tMDP5_LM_BLEND_OP_MODE_BG_ALPHA(FG_PIXEL);\n\t\t\tif (fg_alpha != 0xff) {\n\t\t\t\tbg_alpha = fg_alpha;\n\t\t\t\tblend_op |=\n\t\t\t\t       MDP5_LM_BLEND_OP_MODE_FG_MOD_ALPHA |\n\t\t\t\t       MDP5_LM_BLEND_OP_MODE_FG_INV_MOD_ALPHA |\n\t\t\t\t       MDP5_LM_BLEND_OP_MODE_BG_MOD_ALPHA |\n\t\t\t\t       MDP5_LM_BLEND_OP_MODE_BG_INV_MOD_ALPHA;\n\t\t\t} else {\n\t\t\t\tblend_op |= MDP5_LM_BLEND_OP_MODE_BG_INV_ALPHA;\n\t\t\t}\n\t\t}\n\n\t\tmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_OP_MODE(lm,\n\t\t\t\tblender(i)), blend_op);\n\t\tmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_FG_ALPHA(lm,\n\t\t\t\tblender(i)), fg_alpha);\n\t\tmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_BG_ALPHA(lm,\n\t\t\t\tblender(i)), bg_alpha);\n\t\tif (r_mixer) {\n\t\t\tmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_OP_MODE(r_lm,\n\t\t\t\t\tblender(i)), blend_op);\n\t\t\tmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_FG_ALPHA(r_lm,\n\t\t\t\t\tblender(i)), fg_alpha);\n\t\t\tmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_BG_ALPHA(r_lm,\n\t\t\t\t\tblender(i)), bg_alpha);\n\t\t}\n\t}\n\n\tval = mdp5_read(mdp5_kms, REG_MDP5_LM_BLEND_COLOR_OUT(lm));\n\tmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_COLOR_OUT(lm),\n\t\t   val | mixer_op_mode);\n\tif (r_mixer) {\n\t\tval = mdp5_read(mdp5_kms, REG_MDP5_LM_BLEND_COLOR_OUT(r_lm));\n\t\tmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_COLOR_OUT(r_lm),\n\t\t\t   val | mixer_op_mode);\n\t}\n\n\tmdp5_ctl_blend(ctl, pipeline, stage, r_stage, plane_cnt,\n\t\t       ctl_blend_flags);\nout:\n\tspin_unlock_irqrestore(&mdp5_crtc->lm_lock, flags);\n}\n\nstatic void mdp5_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_kms *mdp5_kms = get_kms(crtc);\n\tstruct mdp5_hw_mixer *mixer = mdp5_cstate->pipeline.mixer;\n\tstruct mdp5_hw_mixer *r_mixer = mdp5_cstate->pipeline.r_mixer;\n\tuint32_t lm = mixer->lm;\n\tu32 mixer_width, val;\n\tunsigned long flags;\n\tstruct drm_display_mode *mode;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn;\n\n\tmode = &crtc->state->adjusted_mode;\n\n\tDBG(\"%s: set mode: \" DRM_MODE_FMT, crtc->name, DRM_MODE_ARG(mode));\n\n\tmixer_width = mode->hdisplay;\n\tif (r_mixer)\n\t\tmixer_width /= 2;\n\n\tspin_lock_irqsave(&mdp5_crtc->lm_lock, flags);\n\tmdp5_write(mdp5_kms, REG_MDP5_LM_OUT_SIZE(lm),\n\t\t\tMDP5_LM_OUT_SIZE_WIDTH(mixer_width) |\n\t\t\tMDP5_LM_OUT_SIZE_HEIGHT(mode->vdisplay));\n\n\t \n\tval = mdp5_read(mdp5_kms, REG_MDP5_LM_BLEND_COLOR_OUT(lm));\n\tval &= ~MDP5_LM_BLEND_COLOR_OUT_SPLIT_LEFT_RIGHT;\n\tmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_COLOR_OUT(lm), val);\n\n\tif (r_mixer) {\n\t\tu32 r_lm = r_mixer->lm;\n\n\t\tmdp5_write(mdp5_kms, REG_MDP5_LM_OUT_SIZE(r_lm),\n\t\t\t   MDP5_LM_OUT_SIZE_WIDTH(mixer_width) |\n\t\t\t   MDP5_LM_OUT_SIZE_HEIGHT(mode->vdisplay));\n\n\t\t \n\t\tval = mdp5_read(mdp5_kms, REG_MDP5_LM_BLEND_COLOR_OUT(r_lm));\n\t\tval |= MDP5_LM_BLEND_COLOR_OUT_SPLIT_LEFT_RIGHT;\n\t\tmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_COLOR_OUT(r_lm), val);\n\t}\n\n\tspin_unlock_irqrestore(&mdp5_crtc->lm_lock, flags);\n}\n\nstatic struct drm_encoder *get_encoder_from_crtc(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_encoder *encoder;\n\n\tdrm_for_each_encoder(encoder, dev)\n\t\tif (encoder->crtc == crtc)\n\t\t\treturn encoder;\n\n\treturn NULL;\n}\n\nstatic bool mdp5_crtc_get_scanout_position(struct drm_crtc *crtc,\n\t\t\t\t\t   bool in_vblank_irq,\n\t\t\t\t\t   int *vpos, int *hpos,\n\t\t\t\t\t   ktime_t *stime, ktime_t *etime,\n\t\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tunsigned int pipe = crtc->index;\n\tstruct drm_encoder *encoder;\n\tint line, vsw, vbp, vactive_start, vactive_end, vfp_end;\n\n\n\tencoder = get_encoder_from_crtc(crtc);\n\tif (!encoder) {\n\t\tDRM_ERROR(\"no encoder found for crtc %d\\n\", pipe);\n\t\treturn false;\n\t}\n\n\tvsw = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\tvbp = mode->crtc_vtotal - mode->crtc_vsync_end;\n\n\t \n\n\tvactive_start = vsw + vbp + 1;\n\n\tvactive_end = vactive_start + mode->crtc_vdisplay;\n\n\t \n\tvfp_end = mode->crtc_vtotal;\n\n\tif (stime)\n\t\t*stime = ktime_get();\n\n\tline = mdp5_encoder_get_linecount(encoder);\n\n\tif (line < vactive_start)\n\t\tline -= vactive_start;\n\telse if (line > vactive_end)\n\t\tline = line - vfp_end - vactive_start;\n\telse\n\t\tline -= vactive_start;\n\n\t*vpos = line;\n\t*hpos = 0;\n\n\tif (etime)\n\t\t*etime = ktime_get();\n\n\treturn true;\n}\n\nstatic u32 mdp5_crtc_get_vblank_counter(struct drm_crtc *crtc)\n{\n\tstruct drm_encoder *encoder;\n\n\tencoder = get_encoder_from_crtc(crtc);\n\tif (!encoder)\n\t\treturn 0;\n\n\treturn mdp5_encoder_get_framecount(encoder);\n}\n\nstatic void mdp5_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_kms *mdp5_kms = get_kms(crtc);\n\tstruct device *dev = &mdp5_kms->pdev->dev;\n\tunsigned long flags;\n\n\tDBG(\"%s\", crtc->name);\n\n\tif (WARN_ON(!mdp5_crtc->enabled))\n\t\treturn;\n\n\t \n\tdrm_crtc_vblank_off(crtc);\n\n\tif (mdp5_cstate->cmd_mode)\n\t\tmdp_irq_unregister(&mdp5_kms->base, &mdp5_crtc->pp_done);\n\n\tmdp_irq_unregister(&mdp5_kms->base, &mdp5_crtc->err);\n\tpm_runtime_put_sync(dev);\n\n\tif (crtc->state->event && !crtc->state->active) {\n\t\tWARN_ON(mdp5_crtc->event);\n\t\tspin_lock_irqsave(&mdp5_kms->dev->event_lock, flags);\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t\tspin_unlock_irqrestore(&mdp5_kms->dev->event_lock, flags);\n\t}\n\n\tmdp5_crtc->enabled = false;\n}\n\nstatic void mdp5_crtc_vblank_on(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_interface *intf = mdp5_cstate->pipeline.intf;\n\tu32 count;\n\n\tcount = intf->mode == MDP5_INTF_DSI_MODE_COMMAND ? 0 : 0xffffffff;\n\tdrm_crtc_set_max_vblank_count(crtc, count);\n\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void mdp5_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_kms *mdp5_kms = get_kms(crtc);\n\tstruct device *dev = &mdp5_kms->pdev->dev;\n\n\tDBG(\"%s\", crtc->name);\n\n\tif (WARN_ON(mdp5_crtc->enabled))\n\t\treturn;\n\n\tpm_runtime_get_sync(dev);\n\n\tif (mdp5_crtc->lm_cursor_enabled) {\n\t\t \n\t\tif (mdp5_crtc->cursor.iova) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&mdp5_crtc->cursor.lock, flags);\n\t\t\tmdp5_crtc_restore_cursor(crtc);\n\t\t\tspin_unlock_irqrestore(&mdp5_crtc->cursor.lock, flags);\n\n\t\t\tmdp5_ctl_set_cursor(mdp5_cstate->ctl,\n\t\t\t\t\t    &mdp5_cstate->pipeline, 0, true);\n\t\t} else {\n\t\t\tmdp5_ctl_set_cursor(mdp5_cstate->ctl,\n\t\t\t\t\t    &mdp5_cstate->pipeline, 0, false);\n\t\t}\n\t}\n\n\t \n\tmdp5_crtc_vblank_on(crtc);\n\n\tmdp5_crtc_mode_set_nofb(crtc);\n\n\tmdp_irq_register(&mdp5_kms->base, &mdp5_crtc->err);\n\n\tif (mdp5_cstate->cmd_mode)\n\t\tmdp_irq_register(&mdp5_kms->base, &mdp5_crtc->pp_done);\n\n\tmdp5_crtc->enabled = true;\n}\n\nstatic int mdp5_crtc_setup_pipeline(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_crtc_state *new_crtc_state,\n\t\t\t\t    bool need_right_mixer)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate =\n\t\t\tto_mdp5_crtc_state(new_crtc_state);\n\tstruct mdp5_pipeline *pipeline = &mdp5_cstate->pipeline;\n\tstruct mdp5_interface *intf;\n\tbool new_mixer = false;\n\n\tnew_mixer = !pipeline->mixer;\n\n\tif ((need_right_mixer && !pipeline->r_mixer) ||\n\t    (!need_right_mixer && pipeline->r_mixer))\n\t\tnew_mixer = true;\n\n\tif (new_mixer) {\n\t\tstruct mdp5_hw_mixer *old_mixer = pipeline->mixer;\n\t\tstruct mdp5_hw_mixer *old_r_mixer = pipeline->r_mixer;\n\t\tu32 caps;\n\t\tint ret;\n\n\t\tcaps = MDP_LM_CAP_DISPLAY;\n\t\tif (need_right_mixer)\n\t\t\tcaps |= MDP_LM_CAP_PAIR;\n\n\t\tret = mdp5_mixer_assign(new_crtc_state->state, crtc, caps,\n\t\t\t\t\t&pipeline->mixer, need_right_mixer ?\n\t\t\t\t\t&pipeline->r_mixer : NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mdp5_mixer_release(new_crtc_state->state, old_mixer);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (old_r_mixer) {\n\t\t\tret = mdp5_mixer_release(new_crtc_state->state, old_r_mixer);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (!need_right_mixer)\n\t\t\t\tpipeline->r_mixer = NULL;\n\t\t}\n\t}\n\n\t \n\tintf = pipeline->intf;\n\n\tmdp5_cstate->err_irqmask = intf2err(intf->num);\n\tmdp5_cstate->vblank_irqmask = intf2vblank(pipeline->mixer, intf);\n\n\tif ((intf->type == INTF_DSI) &&\n\t    (intf->mode == MDP5_INTF_DSI_MODE_COMMAND)) {\n\t\tmdp5_cstate->pp_done_irqmask = lm2ppdone(pipeline->mixer);\n\t\tmdp5_cstate->cmd_mode = true;\n\t} else {\n\t\tmdp5_cstate->pp_done_irqmask = 0;\n\t\tmdp5_cstate->cmd_mode = false;\n\t}\n\n\treturn 0;\n}\n\nstruct plane_state {\n\tstruct drm_plane *plane;\n\tstruct mdp5_plane_state *state;\n};\n\nstatic int pstate_cmp(const void *a, const void *b)\n{\n\tstruct plane_state *pa = (struct plane_state *)a;\n\tstruct plane_state *pb = (struct plane_state *)b;\n\treturn pa->state->base.normalized_zpos - pb->state->base.normalized_zpos;\n}\n\n \nstatic bool is_fullscreen(struct drm_crtc_state *cstate,\n\t\tstruct drm_plane_state *pstate)\n{\n\treturn (pstate->crtc_x <= 0) && (pstate->crtc_y <= 0) &&\n\t\t((pstate->crtc_x + pstate->crtc_w) >= cstate->mode.hdisplay) &&\n\t\t((pstate->crtc_y + pstate->crtc_h) >= cstate->mode.vdisplay);\n}\n\nstatic enum mdp_mixer_stage_id get_start_stage(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_crtc_state *new_crtc_state,\n\t\t\t\t\tstruct drm_plane_state *bpstate)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate =\n\t\t\tto_mdp5_crtc_state(new_crtc_state);\n\n\t \n\tif (mdp5_cstate->pipeline.r_mixer)\n\t\treturn STAGE0;\n\n\t \n\tif (!is_fullscreen(new_crtc_state, bpstate))\n\t\treturn STAGE0;\n\n\treturn STAGE_BASE;\n}\n\nstatic int mdp5_crtc_atomic_check(struct drm_crtc *crtc,\n\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc_state);\n\tstruct mdp5_interface *intf = mdp5_cstate->pipeline.intf;\n\tstruct mdp5_kms *mdp5_kms = get_kms(crtc);\n\tstruct drm_plane *plane;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct plane_state pstates[STAGE_MAX + 1];\n\tconst struct mdp5_cfg_hw *hw_cfg;\n\tconst struct drm_plane_state *pstate;\n\tconst struct drm_display_mode *mode = &crtc_state->adjusted_mode;\n\tbool cursor_plane = false;\n\tbool need_right_mixer = false;\n\tint cnt = 0, i;\n\tint ret;\n\tenum mdp_mixer_stage_id start;\n\n\tDBG(\"%s: check\", crtc->name);\n\n\tdrm_atomic_crtc_state_for_each_plane_state(plane, pstate, crtc_state) {\n\t\tstruct mdp5_plane_state *mdp5_pstate =\n\t\t\t\tto_mdp5_plane_state(pstate);\n\n\t\tif (!pstate->visible)\n\t\t\tcontinue;\n\n\t\tpstates[cnt].plane = plane;\n\t\tpstates[cnt].state = to_mdp5_plane_state(pstate);\n\n\t\tmdp5_pstate->needs_dirtyfb =\n\t\t\tintf->mode == MDP5_INTF_DSI_MODE_COMMAND;\n\n\t\t \n\t\tif (pstates[cnt].state->r_hwpipe)\n\t\t\tneed_right_mixer = true;\n\t\tcnt++;\n\n\t\tif (plane->type == DRM_PLANE_TYPE_CURSOR)\n\t\t\tcursor_plane = true;\n\t}\n\n\t \n\tif (!cnt)\n\t\treturn 0;\n\n\thw_cfg = mdp5_cfg_get_hw_config(mdp5_kms->cfg);\n\n\t \n\tif (mode->hdisplay > hw_cfg->lm.max_width)\n\t\tneed_right_mixer = true;\n\n\tret = mdp5_crtc_setup_pipeline(crtc, crtc_state, need_right_mixer);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev->dev, \"couldn't assign mixers %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tsort(pstates, cnt, sizeof(pstates[0]), pstate_cmp, NULL);\n\n\t \n\tWARN_ON(cursor_plane &&\n\t\t(pstates[cnt - 1].plane->type != DRM_PLANE_TYPE_CURSOR));\n\n\tstart = get_start_stage(crtc, crtc_state, &pstates[0].state->base);\n\n\t \n\tif ((cnt + start - 1) >= hw_cfg->lm.nb_stages) {\n\t\tDRM_DEV_ERROR(dev->dev, \"too many planes! cnt=%d, start stage=%d\\n\",\n\t\t\tcnt, start);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (cursor_plane && (i == (cnt - 1)))\n\t\t\tpstates[i].state->stage = hw_cfg->lm.nb_stages;\n\t\telse\n\t\t\tpstates[i].state->stage = start + i;\n\t\tDBG(\"%s: assign pipe %s on stage=%d\", crtc->name,\n\t\t\t\tpstates[i].plane->name,\n\t\t\t\tpstates[i].state->stage);\n\t}\n\n\treturn 0;\n}\n\nstatic void mdp5_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tDBG(\"%s: begin\", crtc->name);\n}\n\nstatic void mdp5_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned long flags;\n\n\tDBG(\"%s: event: %p\", crtc->name, crtc->state->event);\n\n\tWARN_ON(mdp5_crtc->event);\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tmdp5_crtc->event = crtc->state->event;\n\tcrtc->state->event = NULL;\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\t \n\t \n\tif (unlikely(!mdp5_cstate->ctl))\n\t\treturn;\n\n\tblend_setup(crtc);\n\n\t \n\tif (mdp5_cstate->cmd_mode)\n\t\trequest_pp_done_pending(crtc);\n\n\tmdp5_crtc->flushed_mask = crtc_flush_all(crtc);\n\n\t \n\tmdp5_crtc->vblank.irqmask = mdp5_cstate->vblank_irqmask;\n\tmdp5_crtc->err.irqmask = mdp5_cstate->err_irqmask;\n\tmdp5_crtc->pp_done.irqmask = mdp5_cstate->pp_done_irqmask;\n\n\trequest_pending(crtc, PENDING_FLIP);\n}\n\nstatic void get_roi(struct drm_crtc *crtc, uint32_t *roi_w, uint32_t *roi_h)\n{\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tuint32_t xres = crtc->mode.hdisplay;\n\tuint32_t yres = crtc->mode.vdisplay;\n\n\t \n\tif (mdp5_crtc->cursor.x >= 0)\n\t\t*roi_w = min(mdp5_crtc->cursor.width, xres -\n\t\t\tmdp5_crtc->cursor.x);\n\telse\n\t\t*roi_w = mdp5_crtc->cursor.width - abs(mdp5_crtc->cursor.x);\n\tif (mdp5_crtc->cursor.y >= 0)\n\t\t*roi_h = min(mdp5_crtc->cursor.height, yres -\n\t\t\tmdp5_crtc->cursor.y);\n\telse\n\t\t*roi_h = mdp5_crtc->cursor.height - abs(mdp5_crtc->cursor.y);\n}\n\nstatic void mdp5_crtc_restore_cursor(struct drm_crtc *crtc)\n{\n\tconst struct drm_format_info *info = drm_format_info(DRM_FORMAT_ARGB8888);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tstruct mdp5_kms *mdp5_kms = get_kms(crtc);\n\tconst enum mdp5_cursor_alpha cur_alpha = CURSOR_ALPHA_PER_PIXEL;\n\tuint32_t blendcfg, stride;\n\tuint32_t x, y, src_x, src_y, width, height;\n\tuint32_t roi_w, roi_h;\n\tint lm;\n\n\tassert_spin_locked(&mdp5_crtc->cursor.lock);\n\n\tlm = mdp5_cstate->pipeline.mixer->lm;\n\n\tx = mdp5_crtc->cursor.x;\n\ty = mdp5_crtc->cursor.y;\n\twidth = mdp5_crtc->cursor.width;\n\theight = mdp5_crtc->cursor.height;\n\n\tstride = width * info->cpp[0];\n\n\tget_roi(crtc, &roi_w, &roi_h);\n\n\t \n\tif (mdp5_crtc->cursor.x < 0) {\n\t\tsrc_x = abs(mdp5_crtc->cursor.x);\n\t\tx = 0;\n\t} else {\n\t\tsrc_x = 0;\n\t}\n\tif (mdp5_crtc->cursor.y < 0) {\n\t\tsrc_y = abs(mdp5_crtc->cursor.y);\n\t\ty = 0;\n\t} else {\n\t\tsrc_y = 0;\n\t}\n\tDBG(\"%s: x=%d, y=%d roi_w=%d roi_h=%d src_x=%d src_y=%d\",\n\t\tcrtc->name, x, y, roi_w, roi_h, src_x, src_y);\n\n\tmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_STRIDE(lm), stride);\n\tmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_FORMAT(lm),\n\t\t\tMDP5_LM_CURSOR_FORMAT_FORMAT(CURSOR_FMT_ARGB8888));\n\tmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_IMG_SIZE(lm),\n\t\t\tMDP5_LM_CURSOR_IMG_SIZE_SRC_H(height) |\n\t\t\tMDP5_LM_CURSOR_IMG_SIZE_SRC_W(width));\n\tmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_SIZE(lm),\n\t\t\tMDP5_LM_CURSOR_SIZE_ROI_H(roi_h) |\n\t\t\tMDP5_LM_CURSOR_SIZE_ROI_W(roi_w));\n\tmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_START_XY(lm),\n\t\t\tMDP5_LM_CURSOR_START_XY_Y_START(y) |\n\t\t\tMDP5_LM_CURSOR_START_XY_X_START(x));\n\tmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_XY(lm),\n\t\t\tMDP5_LM_CURSOR_XY_SRC_Y(src_y) |\n\t\t\tMDP5_LM_CURSOR_XY_SRC_X(src_x));\n\tmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_BASE_ADDR(lm),\n\t\t\tmdp5_crtc->cursor.iova);\n\n\tblendcfg = MDP5_LM_CURSOR_BLEND_CONFIG_BLEND_EN;\n\tblendcfg |= MDP5_LM_CURSOR_BLEND_CONFIG_BLEND_ALPHA_SEL(cur_alpha);\n\tmdp5_write(mdp5_kms, REG_MDP5_LM_CURSOR_BLEND_CONFIG(lm), blendcfg);\n}\n\nstatic int mdp5_crtc_cursor_set(struct drm_crtc *crtc,\n\t\tstruct drm_file *file, uint32_t handle,\n\t\tuint32_t width, uint32_t height)\n{\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_pipeline *pipeline = &mdp5_cstate->pipeline;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mdp5_kms *mdp5_kms = get_kms(crtc);\n\tstruct platform_device *pdev = mdp5_kms->pdev;\n\tstruct msm_kms *kms = &mdp5_kms->base.base;\n\tstruct drm_gem_object *cursor_bo, *old_bo = NULL;\n\tstruct mdp5_ctl *ctl;\n\tint ret;\n\tuint32_t flush_mask = mdp_ctl_flush_mask_cursor(0);\n\tbool cursor_enable = true;\n\tunsigned long flags;\n\n\tif (!mdp5_crtc->lm_cursor_enabled) {\n\t\tdev_warn(dev->dev,\n\t\t\t \"cursor_set is deprecated with cursor planes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((width > CURSOR_WIDTH) || (height > CURSOR_HEIGHT)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"bad cursor size: %dx%d\\n\", width, height);\n\t\treturn -EINVAL;\n\t}\n\n\tctl = mdp5_cstate->ctl;\n\tif (!ctl)\n\t\treturn -EINVAL;\n\n\t \n\tif (mdp5_cstate->pipeline.r_mixer)\n\t\treturn -EINVAL;\n\n\tif (!handle) {\n\t\tDBG(\"Cursor off\");\n\t\tcursor_enable = false;\n\t\tmdp5_crtc->cursor.iova = 0;\n\t\tpm_runtime_get_sync(&pdev->dev);\n\t\tgoto set_cursor;\n\t}\n\n\tcursor_bo = drm_gem_object_lookup(file, handle);\n\tif (!cursor_bo)\n\t\treturn -ENOENT;\n\n\tret = msm_gem_get_and_pin_iova(cursor_bo, kms->aspace,\n\t\t\t&mdp5_crtc->cursor.iova);\n\tif (ret) {\n\t\tdrm_gem_object_put(cursor_bo);\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tspin_lock_irqsave(&mdp5_crtc->cursor.lock, flags);\n\told_bo = mdp5_crtc->cursor.scanout_bo;\n\n\tmdp5_crtc->cursor.scanout_bo = cursor_bo;\n\tmdp5_crtc->cursor.width = width;\n\tmdp5_crtc->cursor.height = height;\n\n\tmdp5_crtc_restore_cursor(crtc);\n\n\tspin_unlock_irqrestore(&mdp5_crtc->cursor.lock, flags);\n\nset_cursor:\n\tret = mdp5_ctl_set_cursor(ctl, pipeline, 0, cursor_enable);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to %sable cursor: %d\\n\",\n\t\t\t\tcursor_enable ? \"en\" : \"dis\", ret);\n\t\tgoto end;\n\t}\n\n\tcrtc_flush(crtc, flush_mask);\n\nend:\n\tpm_runtime_put_sync(&pdev->dev);\n\tif (old_bo) {\n\t\tdrm_flip_work_queue(&mdp5_crtc->unref_cursor_work, old_bo);\n\t\t \n\t\trequest_pending(crtc, PENDING_CURSOR);\n\t}\n\treturn ret;\n}\n\nstatic int mdp5_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(crtc);\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tuint32_t flush_mask = mdp_ctl_flush_mask_cursor(0);\n\tstruct drm_device *dev = crtc->dev;\n\tuint32_t roi_w;\n\tuint32_t roi_h;\n\tunsigned long flags;\n\n\tif (!mdp5_crtc->lm_cursor_enabled) {\n\t\tdev_warn(dev->dev,\n\t\t\t \"cursor_move is deprecated with cursor planes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mdp5_cstate->pipeline.r_mixer)\n\t\treturn -EINVAL;\n\n\t \n\tif (unlikely(!crtc->state->enable))\n\t\treturn 0;\n\n\t \n\tmdp5_crtc->cursor.x = x = max(x, -(int)mdp5_crtc->cursor.width);\n\tmdp5_crtc->cursor.y = y = max(y, -(int)mdp5_crtc->cursor.height);\n\n\tget_roi(crtc, &roi_w, &roi_h);\n\n\tpm_runtime_get_sync(&mdp5_kms->pdev->dev);\n\n\tspin_lock_irqsave(&mdp5_crtc->cursor.lock, flags);\n\tmdp5_crtc_restore_cursor(crtc);\n\tspin_unlock_irqrestore(&mdp5_crtc->cursor.lock, flags);\n\n\tcrtc_flush(crtc, flush_mask);\n\n\tpm_runtime_put_sync(&mdp5_kms->pdev->dev);\n\n\treturn 0;\n}\n\nstatic void\nmdp5_crtc_atomic_print_state(struct drm_printer *p,\n\t\t\t     const struct drm_crtc_state *state)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(state);\n\tstruct mdp5_pipeline *pipeline = &mdp5_cstate->pipeline;\n\tstruct mdp5_kms *mdp5_kms = get_kms(state->crtc);\n\n\tif (WARN_ON(!pipeline))\n\t\treturn;\n\n\tif (mdp5_cstate->ctl)\n\t\tdrm_printf(p, \"\\tctl=%d\\n\", mdp5_ctl_get_ctl_id(mdp5_cstate->ctl));\n\n\tdrm_printf(p, \"\\thwmixer=%s\\n\", pipeline->mixer ?\n\t\t\tpipeline->mixer->name : \"(null)\");\n\n\tif (mdp5_kms->caps & MDP_CAP_SRC_SPLIT)\n\t\tdrm_printf(p, \"\\tright hwmixer=%s\\n\", pipeline->r_mixer ?\n\t\t\t   pipeline->r_mixer->name : \"(null)\");\n\n\tdrm_printf(p, \"\\tcmd_mode=%d\\n\", mdp5_cstate->cmd_mode);\n}\n\nstatic struct drm_crtc_state *\nmdp5_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tmdp5_cstate = kmemdup(to_mdp5_crtc_state(crtc->state),\n\t\t\t      sizeof(*mdp5_cstate), GFP_KERNEL);\n\tif (!mdp5_cstate)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &mdp5_cstate->base);\n\n\treturn &mdp5_cstate->base;\n}\n\nstatic void mdp5_crtc_destroy_state(struct drm_crtc *crtc, struct drm_crtc_state *state)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(state);\n\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\n\tkfree(mdp5_cstate);\n}\n\nstatic void mdp5_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate =\n\t\tkzalloc(sizeof(*mdp5_cstate), GFP_KERNEL);\n\n\tif (crtc->state)\n\t\tmdp5_crtc_destroy_state(crtc, crtc->state);\n\n\tif (mdp5_cstate)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &mdp5_cstate->base);\n\telse\n\t\t__drm_atomic_helper_crtc_reset(crtc, NULL);\n}\n\nstatic const struct drm_crtc_funcs mdp5_crtc_no_lm_cursor_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.destroy = mdp5_crtc_destroy,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = mdp5_crtc_reset,\n\t.atomic_duplicate_state = mdp5_crtc_duplicate_state,\n\t.atomic_destroy_state = mdp5_crtc_destroy_state,\n\t.atomic_print_state = mdp5_crtc_atomic_print_state,\n\t.get_vblank_counter = mdp5_crtc_get_vblank_counter,\n\t.enable_vblank  = msm_crtc_enable_vblank,\n\t.disable_vblank = msm_crtc_disable_vblank,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs mdp5_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.destroy = mdp5_crtc_destroy,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = mdp5_crtc_reset,\n\t.atomic_duplicate_state = mdp5_crtc_duplicate_state,\n\t.atomic_destroy_state = mdp5_crtc_destroy_state,\n\t.cursor_set = mdp5_crtc_cursor_set,\n\t.cursor_move = mdp5_crtc_cursor_move,\n\t.atomic_print_state = mdp5_crtc_atomic_print_state,\n\t.get_vblank_counter = mdp5_crtc_get_vblank_counter,\n\t.enable_vblank  = msm_crtc_enable_vblank,\n\t.disable_vblank = msm_crtc_disable_vblank,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_helper_funcs mdp5_crtc_helper_funcs = {\n\t.mode_set_nofb = mdp5_crtc_mode_set_nofb,\n\t.atomic_check = mdp5_crtc_atomic_check,\n\t.atomic_begin = mdp5_crtc_atomic_begin,\n\t.atomic_flush = mdp5_crtc_atomic_flush,\n\t.atomic_enable = mdp5_crtc_atomic_enable,\n\t.atomic_disable = mdp5_crtc_atomic_disable,\n\t.get_scanout_position = mdp5_crtc_get_scanout_position,\n};\n\nstatic void mdp5_crtc_vblank_irq(struct mdp_irq *irq, uint32_t irqstatus)\n{\n\tstruct mdp5_crtc *mdp5_crtc = container_of(irq, struct mdp5_crtc, vblank);\n\tstruct drm_crtc *crtc = &mdp5_crtc->base;\n\tstruct msm_drm_private *priv = crtc->dev->dev_private;\n\tunsigned pending;\n\n\tmdp_irq_unregister(&get_kms(crtc)->base, &mdp5_crtc->vblank);\n\n\tpending = atomic_xchg(&mdp5_crtc->pending, 0);\n\n\tif (pending & PENDING_FLIP) {\n\t\tcomplete_flip(crtc, NULL);\n\t}\n\n\tif (pending & PENDING_CURSOR)\n\t\tdrm_flip_work_commit(&mdp5_crtc->unref_cursor_work, priv->wq);\n}\n\nstatic void mdp5_crtc_err_irq(struct mdp_irq *irq, uint32_t irqstatus)\n{\n\tstruct mdp5_crtc *mdp5_crtc = container_of(irq, struct mdp5_crtc, err);\n\n\tDBG(\"%s: error: %08x\", mdp5_crtc->base.name, irqstatus);\n}\n\nstatic void mdp5_crtc_pp_done_irq(struct mdp_irq *irq, uint32_t irqstatus)\n{\n\tstruct mdp5_crtc *mdp5_crtc = container_of(irq, struct mdp5_crtc,\n\t\t\t\t\t\t\t\tpp_done);\n\n\tcomplete_all(&mdp5_crtc->pp_completion);\n}\n\nstatic void mdp5_crtc_wait_for_pp_done(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tint ret;\n\n\tret = wait_for_completion_timeout(&mdp5_crtc->pp_completion,\n\t\t\t\t\t\tmsecs_to_jiffies(50));\n\tif (ret == 0)\n\t\tdev_warn_ratelimited(dev->dev, \"pp done time out, lm=%d\\n\",\n\t\t\t\t     mdp5_cstate->pipeline.mixer->lm);\n}\n\nstatic void mdp5_crtc_wait_for_flush_done(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_ctl *ctl = mdp5_cstate->ctl;\n\tint ret;\n\n\t \n\tif (!ctl)\n\t\treturn;\n\n\tret = drm_crtc_vblank_get(crtc);\n\tif (ret)\n\t\treturn;\n\n\tret = wait_event_timeout(dev->vblank[drm_crtc_index(crtc)].queue,\n\t\t((mdp5_ctl_get_commit_status(ctl) &\n\t\tmdp5_crtc->flushed_mask) == 0),\n\t\tmsecs_to_jiffies(50));\n\tif (ret <= 0)\n\t\tdev_warn(dev->dev, \"vblank time out, crtc=%d\\n\", mdp5_crtc->id);\n\n\tmdp5_crtc->flushed_mask = 0;\n\n\tdrm_crtc_vblank_put(crtc);\n}\n\nuint32_t mdp5_crtc_vblank(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\n\treturn mdp5_crtc->vblank.irqmask;\n}\n\nvoid mdp5_crtc_set_pipeline(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\tstruct mdp5_kms *mdp5_kms = get_kms(crtc);\n\n\t \n\tmdp_irq_update(&mdp5_kms->base);\n\n\tmdp5_ctl_set_pipeline(mdp5_cstate->ctl, &mdp5_cstate->pipeline);\n}\n\nstruct mdp5_ctl *mdp5_crtc_get_ctl(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\n\treturn mdp5_cstate->ctl;\n}\n\nstruct mdp5_hw_mixer *mdp5_crtc_get_mixer(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate;\n\n\tif (WARN_ON(!crtc))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\n\treturn WARN_ON(!mdp5_cstate->pipeline.mixer) ?\n\t\tERR_PTR(-EINVAL) : mdp5_cstate->pipeline.mixer;\n}\n\nstruct mdp5_pipeline *mdp5_crtc_get_pipeline(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate;\n\n\tif (WARN_ON(!crtc))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\n\treturn &mdp5_cstate->pipeline;\n}\n\nvoid mdp5_crtc_wait_for_commit_done(struct drm_crtc *crtc)\n{\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc->state);\n\n\tif (mdp5_cstate->cmd_mode)\n\t\tmdp5_crtc_wait_for_pp_done(crtc);\n\telse\n\t\tmdp5_crtc_wait_for_flush_done(crtc);\n}\n\n \nstruct drm_crtc *mdp5_crtc_init(struct drm_device *dev,\n\t\t\t\tstruct drm_plane *plane,\n\t\t\t\tstruct drm_plane *cursor_plane, int id)\n{\n\tstruct drm_crtc *crtc = NULL;\n\tstruct mdp5_crtc *mdp5_crtc;\n\n\tmdp5_crtc = kzalloc(sizeof(*mdp5_crtc), GFP_KERNEL);\n\tif (!mdp5_crtc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcrtc = &mdp5_crtc->base;\n\n\tmdp5_crtc->id = id;\n\n\tspin_lock_init(&mdp5_crtc->lm_lock);\n\tspin_lock_init(&mdp5_crtc->cursor.lock);\n\tinit_completion(&mdp5_crtc->pp_completion);\n\n\tmdp5_crtc->vblank.irq = mdp5_crtc_vblank_irq;\n\tmdp5_crtc->err.irq = mdp5_crtc_err_irq;\n\tmdp5_crtc->pp_done.irq = mdp5_crtc_pp_done_irq;\n\n\tmdp5_crtc->lm_cursor_enabled = cursor_plane ? false : true;\n\n\tdrm_crtc_init_with_planes(dev, crtc, plane, cursor_plane,\n\t\t\t\t  cursor_plane ?\n\t\t\t\t  &mdp5_crtc_no_lm_cursor_funcs :\n\t\t\t\t  &mdp5_crtc_funcs, NULL);\n\n\tdrm_flip_work_init(&mdp5_crtc->unref_cursor_work,\n\t\t\t\"unref cursor\", unref_cursor_worker);\n\n\tdrm_crtc_helper_add(crtc, &mdp5_crtc_helper_funcs);\n\n\treturn crtc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}