{
  "module_name": "mdp5_kms.h",
  "hash_id": "e924b4b9bb5c648433b167f8cbc10264bf134926c37f632a85870e3ab44a64fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp5/mdp5_kms.h",
  "human_readable_source": " \n \n\n#ifndef __MDP5_KMS_H__\n#define __MDP5_KMS_H__\n\n#include \"msm_drv.h\"\n#include \"msm_kms.h\"\n#include \"disp/mdp_kms.h\"\n#include \"mdp5_cfg.h\"\t \n#include \"mdp5.xml.h\"\n#include \"mdp5_pipe.h\"\n#include \"mdp5_mixer.h\"\n#include \"mdp5_ctl.h\"\n#include \"mdp5_smp.h\"\n\nstruct mdp5_kms {\n\tstruct mdp_kms base;\n\n\tstruct drm_device *dev;\n\n\tstruct platform_device *pdev;\n\n\tunsigned num_hwpipes;\n\tstruct mdp5_hw_pipe *hwpipes[SSPP_MAX];\n\n\tunsigned num_hwmixers;\n\tstruct mdp5_hw_mixer *hwmixers[8];\n\n\tunsigned num_intfs;\n\tstruct mdp5_interface *intfs[5];\n\n\tstruct mdp5_cfg_handler *cfg;\n\tuint32_t caps;\t \n\n\t \n\tstruct drm_modeset_lock glob_state_lock;\n\tstruct drm_private_obj glob_state;\n\n\tstruct mdp5_smp *smp;\n\tstruct mdp5_ctl_manager *ctlm;\n\n\t \n\tvoid __iomem *mmio;\n\n\tstruct clk *axi_clk;\n\tstruct clk *ahb_clk;\n\tstruct clk *core_clk;\n\tstruct clk *lut_clk;\n\tstruct clk *tbu_clk;\n\tstruct clk *tbu_rt_clk;\n\tstruct clk *vsync_clk;\n\n\t \n\tspinlock_t resource_lock;\n\n\tbool rpm_enabled;\n\n\tstruct mdp_irq error_handler;\n\n\tint enable_count;\n};\n#define to_mdp5_kms(x) container_of(x, struct mdp5_kms, base)\n\n \n#define to_mdp5_global_state(x) container_of(x, struct mdp5_global_state, base)\nstruct mdp5_global_state {\n\tstruct drm_private_state base;\n\n\tstruct drm_atomic_state *state;\n\tstruct mdp5_kms *mdp5_kms;\n\n\tstruct mdp5_hw_pipe_state hwpipe;\n\tstruct mdp5_hw_mixer_state hwmixer;\n\tstruct mdp5_smp_state smp;\n};\n\nstruct mdp5_global_state * mdp5_get_existing_global_state(struct mdp5_kms *mdp5_kms);\nstruct mdp5_global_state *__must_check mdp5_get_global_state(struct drm_atomic_state *s);\n\n \nstruct mdp5_plane_state {\n\tstruct drm_plane_state base;\n\n\tstruct mdp5_hw_pipe *hwpipe;\n\tstruct mdp5_hw_pipe *r_hwpipe;\t \n\n\t \n\tenum mdp_mixer_stage_id stage;\n\n\t \n\tbool needs_dirtyfb;\n};\n#define to_mdp5_plane_state(x) \\\n\t\tcontainer_of(x, struct mdp5_plane_state, base)\n\nstruct mdp5_pipeline {\n\tstruct mdp5_interface *intf;\n\tstruct mdp5_hw_mixer *mixer;\n\tstruct mdp5_hw_mixer *r_mixer;\t \n};\n\nstruct mdp5_crtc_state {\n\tstruct drm_crtc_state base;\n\n\tstruct mdp5_ctl *ctl;\n\tstruct mdp5_pipeline pipeline;\n\n\t \n\tu32 vblank_irqmask;\n\tu32 err_irqmask;\n\tu32 pp_done_irqmask;\n\n\tbool cmd_mode;\n\n\t \n\tbool defer_start;\n};\n#define to_mdp5_crtc_state(x) \\\n\t\tcontainer_of(x, struct mdp5_crtc_state, base)\n\nenum mdp5_intf_mode {\n\tMDP5_INTF_MODE_NONE = 0,\n\n\t \n\tMDP5_INTF_DSI_MODE_VIDEO,\n\tMDP5_INTF_DSI_MODE_COMMAND,\n\n\t \n\tMDP5_INTF_WB_MODE_BLOCK,\n\tMDP5_INTF_WB_MODE_LINE,\n};\n\nstruct mdp5_interface {\n\tint idx;\n\tint num;  \n\tenum mdp5_intf_type type;\n\tenum mdp5_intf_mode mode;\n};\n\nstruct mdp5_encoder {\n\tstruct drm_encoder base;\n\tspinlock_t intf_lock;\t \n\tbool enabled;\n\tuint32_t bsc;\n\n\tstruct mdp5_interface *intf;\n\tstruct mdp5_ctl *ctl;\n};\n#define to_mdp5_encoder(x) container_of(x, struct mdp5_encoder, base)\n\nstatic inline void mdp5_write(struct mdp5_kms *mdp5_kms, u32 reg, u32 data)\n{\n\tWARN_ON(mdp5_kms->enable_count <= 0);\n\tmsm_writel(data, mdp5_kms->mmio + reg);\n}\n\nstatic inline u32 mdp5_read(struct mdp5_kms *mdp5_kms, u32 reg)\n{\n\tWARN_ON(mdp5_kms->enable_count <= 0);\n\treturn msm_readl(mdp5_kms->mmio + reg);\n}\n\nstatic inline const char *stage2name(enum mdp_mixer_stage_id stage)\n{\n\tstatic const char *names[] = {\n#define NAME(n) [n] = #n\n\t\tNAME(STAGE_UNUSED), NAME(STAGE_BASE),\n\t\tNAME(STAGE0), NAME(STAGE1), NAME(STAGE2),\n\t\tNAME(STAGE3), NAME(STAGE4), NAME(STAGE6),\n#undef NAME\n\t};\n\treturn names[stage];\n}\n\nstatic inline const char *pipe2name(enum mdp5_pipe pipe)\n{\n\tstatic const char *names[] = {\n#define NAME(n) [SSPP_ ## n] = #n\n\t\tNAME(VIG0), NAME(VIG1), NAME(VIG2),\n\t\tNAME(RGB0), NAME(RGB1), NAME(RGB2),\n\t\tNAME(DMA0), NAME(DMA1),\n\t\tNAME(VIG3), NAME(RGB3),\n\t\tNAME(CURSOR0), NAME(CURSOR1),\n#undef NAME\n\t};\n\treturn names[pipe];\n}\n\nstatic inline int pipe2nclients(enum mdp5_pipe pipe)\n{\n\tswitch (pipe) {\n\tcase SSPP_RGB0:\n\tcase SSPP_RGB1:\n\tcase SSPP_RGB2:\n\tcase SSPP_RGB3:\n\t\treturn 1;\n\tdefault:\n\t\treturn 3;\n\t}\n}\n\nstatic inline uint32_t intf2err(int intf_num)\n{\n\tswitch (intf_num) {\n\tcase 0:  return MDP5_IRQ_INTF0_UNDER_RUN;\n\tcase 1:  return MDP5_IRQ_INTF1_UNDER_RUN;\n\tcase 2:  return MDP5_IRQ_INTF2_UNDER_RUN;\n\tcase 3:  return MDP5_IRQ_INTF3_UNDER_RUN;\n\tdefault: return 0;\n\t}\n}\n\nstatic inline uint32_t intf2vblank(struct mdp5_hw_mixer *mixer,\n\t\t\t\t   struct mdp5_interface *intf)\n{\n\t \n\n\tif ((intf->type == INTF_DSI) &&\n\t\t\t(intf->mode == MDP5_INTF_DSI_MODE_COMMAND))\n\t\treturn MDP5_IRQ_PING_PONG_0_RD_PTR << mixer->pp;\n\n\tif (intf->type == INTF_WB)\n\t\treturn MDP5_IRQ_WB_2_DONE;\n\n\tswitch (intf->num) {\n\tcase 0:  return MDP5_IRQ_INTF0_VSYNC;\n\tcase 1:  return MDP5_IRQ_INTF1_VSYNC;\n\tcase 2:  return MDP5_IRQ_INTF2_VSYNC;\n\tcase 3:  return MDP5_IRQ_INTF3_VSYNC;\n\tdefault: return 0;\n\t}\n}\n\nstatic inline uint32_t lm2ppdone(struct mdp5_hw_mixer *mixer)\n{\n\treturn MDP5_IRQ_PING_PONG_0_DONE << mixer->pp;\n}\n\nvoid mdp5_set_irqmask(struct mdp_kms *mdp_kms, uint32_t irqmask,\n\t\tuint32_t old_irqmask);\nvoid mdp5_irq_preinstall(struct msm_kms *kms);\nint mdp5_irq_postinstall(struct msm_kms *kms);\nvoid mdp5_irq_uninstall(struct msm_kms *kms);\nirqreturn_t mdp5_irq(struct msm_kms *kms);\nint mdp5_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);\nvoid mdp5_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);\nint mdp5_irq_domain_init(struct mdp5_kms *mdp5_kms);\nvoid mdp5_irq_domain_fini(struct mdp5_kms *mdp5_kms);\n\nuint32_t mdp5_plane_get_flush(struct drm_plane *plane);\nenum mdp5_pipe mdp5_plane_pipe(struct drm_plane *plane);\nenum mdp5_pipe mdp5_plane_right_pipe(struct drm_plane *plane);\nstruct drm_plane *mdp5_plane_init(struct drm_device *dev,\n\t\t\t\t  enum drm_plane_type type);\n\nstruct mdp5_ctl *mdp5_crtc_get_ctl(struct drm_crtc *crtc);\nuint32_t mdp5_crtc_vblank(struct drm_crtc *crtc);\n\nstruct mdp5_hw_mixer *mdp5_crtc_get_mixer(struct drm_crtc *crtc);\nstruct mdp5_pipeline *mdp5_crtc_get_pipeline(struct drm_crtc *crtc);\nvoid mdp5_crtc_set_pipeline(struct drm_crtc *crtc);\nvoid mdp5_crtc_wait_for_commit_done(struct drm_crtc *crtc);\nstruct drm_crtc *mdp5_crtc_init(struct drm_device *dev,\n\t\t\t\tstruct drm_plane *plane,\n\t\t\t\tstruct drm_plane *cursor_plane, int id);\n\nstruct drm_encoder *mdp5_encoder_init(struct drm_device *dev,\n\t\tstruct mdp5_interface *intf, struct mdp5_ctl *ctl);\nint mdp5_vid_encoder_set_split_display(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_encoder *slave_encoder);\nvoid mdp5_encoder_set_intf_mode(struct drm_encoder *encoder, bool cmd_mode);\nint mdp5_encoder_get_linecount(struct drm_encoder *encoder);\nu32 mdp5_encoder_get_framecount(struct drm_encoder *encoder);\n\n#ifdef CONFIG_DRM_MSM_DSI\nvoid mdp5_cmd_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t       struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode);\nvoid mdp5_cmd_encoder_disable(struct drm_encoder *encoder);\nvoid mdp5_cmd_encoder_enable(struct drm_encoder *encoder);\nint mdp5_cmd_encoder_set_split_display(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_encoder *slave_encoder);\n#else\nstatic inline void mdp5_cmd_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t\t     struct drm_display_mode *mode,\n\t\t\t\t\t     struct drm_display_mode *adjusted_mode)\n{\n}\nstatic inline void mdp5_cmd_encoder_disable(struct drm_encoder *encoder)\n{\n}\nstatic inline void mdp5_cmd_encoder_enable(struct drm_encoder *encoder)\n{\n}\nstatic inline int mdp5_cmd_encoder_set_split_display(\n\tstruct drm_encoder *encoder, struct drm_encoder *slave_encoder)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}