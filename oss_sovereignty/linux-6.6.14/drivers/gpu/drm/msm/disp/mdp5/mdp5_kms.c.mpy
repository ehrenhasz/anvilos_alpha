{
  "module_name": "mdp5_kms.c",
  "hash_id": "d146f1a9f9ecc83bbb3a9e12347b6bc3543ca5afe69a7a006b1af22d36d5e053",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp5/mdp5_kms.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interconnect.h>\n#include <linux/of_irq.h>\n\n#include <drm/drm_debugfs.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_vblank.h>\n\n#include \"msm_drv.h\"\n#include \"msm_gem.h\"\n#include \"msm_mmu.h\"\n#include \"mdp5_kms.h\"\n\nstatic int mdp5_hw_init(struct msm_kms *kms)\n{\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tstruct device *dev = &mdp5_kms->pdev->dev;\n\tunsigned long flags;\n\n\tpm_runtime_get_sync(dev);\n\n\t \n\n\tspin_lock_irqsave(&mdp5_kms->resource_lock, flags);\n\tmdp5_write(mdp5_kms, REG_MDP5_DISP_INTF_SEL, 0);\n\tspin_unlock_irqrestore(&mdp5_kms->resource_lock, flags);\n\n\tmdp5_ctlm_hw_reset(mdp5_kms->ctlm);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\n \n\n \nstruct mdp5_global_state *\nmdp5_get_existing_global_state(struct mdp5_kms *mdp5_kms)\n{\n\treturn to_mdp5_global_state(mdp5_kms->glob_state.state);\n}\n\n \nstruct mdp5_global_state *mdp5_get_global_state(struct drm_atomic_state *s)\n{\n\tstruct msm_drm_private *priv = s->dev->dev_private;\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(priv->kms));\n\tstruct drm_private_state *priv_state;\n\tint ret;\n\n\tret = drm_modeset_lock(&mdp5_kms->glob_state_lock, s->acquire_ctx);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tpriv_state = drm_atomic_get_private_obj_state(s, &mdp5_kms->glob_state);\n\tif (IS_ERR(priv_state))\n\t\treturn ERR_CAST(priv_state);\n\n\treturn to_mdp5_global_state(priv_state);\n}\n\nstatic struct drm_private_state *\nmdp5_global_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct mdp5_global_state *state;\n\n\tstate = kmemdup(obj->state, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &state->base);\n\n\treturn &state->base;\n}\n\nstatic void mdp5_global_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t      struct drm_private_state *state)\n{\n\tstruct mdp5_global_state *mdp5_state = to_mdp5_global_state(state);\n\n\tkfree(mdp5_state);\n}\n\nstatic const struct drm_private_state_funcs mdp5_global_state_funcs = {\n\t.atomic_duplicate_state = mdp5_global_duplicate_state,\n\t.atomic_destroy_state = mdp5_global_destroy_state,\n};\n\nstatic int mdp5_global_obj_init(struct mdp5_kms *mdp5_kms)\n{\n\tstruct mdp5_global_state *state;\n\n\tdrm_modeset_lock_init(&mdp5_kms->glob_state_lock);\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->mdp5_kms = mdp5_kms;\n\n\tdrm_atomic_private_obj_init(mdp5_kms->dev, &mdp5_kms->glob_state,\n\t\t\t\t    &state->base,\n\t\t\t\t    &mdp5_global_state_funcs);\n\treturn 0;\n}\n\nstatic void mdp5_enable_commit(struct msm_kms *kms)\n{\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tpm_runtime_get_sync(&mdp5_kms->pdev->dev);\n}\n\nstatic void mdp5_disable_commit(struct msm_kms *kms)\n{\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tpm_runtime_put_sync(&mdp5_kms->pdev->dev);\n}\n\nstatic void mdp5_prepare_commit(struct msm_kms *kms, struct drm_atomic_state *state)\n{\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tstruct mdp5_global_state *global_state;\n\n\tglobal_state = mdp5_get_existing_global_state(mdp5_kms);\n\n\tif (mdp5_kms->smp)\n\t\tmdp5_smp_prepare_commit(mdp5_kms->smp, &global_state->smp);\n}\n\nstatic void mdp5_flush_commit(struct msm_kms *kms, unsigned crtc_mask)\n{\n\t \n}\n\nstatic void mdp5_wait_flush(struct msm_kms *kms, unsigned crtc_mask)\n{\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tstruct drm_crtc *crtc;\n\n\tfor_each_crtc_mask(mdp5_kms->dev, crtc, crtc_mask)\n\t\tmdp5_crtc_wait_for_commit_done(crtc);\n}\n\nstatic void mdp5_complete_commit(struct msm_kms *kms, unsigned crtc_mask)\n{\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tstruct mdp5_global_state *global_state;\n\n\tglobal_state = mdp5_get_existing_global_state(mdp5_kms);\n\n\tif (mdp5_kms->smp)\n\t\tmdp5_smp_complete_commit(mdp5_kms->smp, &global_state->smp);\n}\n\nstatic int mdp5_set_split_display(struct msm_kms *kms,\n\t\tstruct drm_encoder *encoder,\n\t\tstruct drm_encoder *slave_encoder,\n\t\tbool is_cmd_mode)\n{\n\tif (is_cmd_mode)\n\t\treturn mdp5_cmd_encoder_set_split_display(encoder,\n\t\t\t\t\t\t\tslave_encoder);\n\telse\n\t\treturn mdp5_vid_encoder_set_split_display(encoder,\n\t\t\t\t\t\t\t  slave_encoder);\n}\n\nstatic void mdp5_destroy(struct mdp5_kms *mdp5_kms);\n\nstatic void mdp5_kms_destroy(struct msm_kms *kms)\n{\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tstruct msm_gem_address_space *aspace = kms->aspace;\n\tint i;\n\n\tfor (i = 0; i < mdp5_kms->num_hwmixers; i++)\n\t\tmdp5_mixer_destroy(mdp5_kms->hwmixers[i]);\n\n\tfor (i = 0; i < mdp5_kms->num_hwpipes; i++)\n\t\tmdp5_pipe_destroy(mdp5_kms->hwpipes[i]);\n\n\tif (aspace) {\n\t\taspace->mmu->funcs->detach(aspace->mmu);\n\t\tmsm_gem_address_space_put(aspace);\n\t}\n\n\tmdp_kms_destroy(&mdp5_kms->base);\n\tmdp5_destroy(mdp5_kms);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int smp_show(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(priv->kms));\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tif (!mdp5_kms->smp) {\n\t\tdrm_printf(&p, \"no SMP pool\\n\");\n\t\treturn 0;\n\t}\n\n\tmdp5_smp_dump(mdp5_kms->smp, &p);\n\n\treturn 0;\n}\n\nstatic struct drm_info_list mdp5_debugfs_list[] = {\n\t\t{\"smp\", smp_show },\n};\n\nstatic int mdp5_kms_debugfs_init(struct msm_kms *kms, struct drm_minor *minor)\n{\n\tdrm_debugfs_create_files(mdp5_debugfs_list,\n\t\t\t\t ARRAY_SIZE(mdp5_debugfs_list),\n\t\t\t\t minor->debugfs_root, minor);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct mdp_kms_funcs kms_funcs = {\n\t.base = {\n\t\t.hw_init         = mdp5_hw_init,\n\t\t.irq_preinstall  = mdp5_irq_preinstall,\n\t\t.irq_postinstall = mdp5_irq_postinstall,\n\t\t.irq_uninstall   = mdp5_irq_uninstall,\n\t\t.irq             = mdp5_irq,\n\t\t.enable_vblank   = mdp5_enable_vblank,\n\t\t.disable_vblank  = mdp5_disable_vblank,\n\t\t.flush_commit    = mdp5_flush_commit,\n\t\t.enable_commit   = mdp5_enable_commit,\n\t\t.disable_commit  = mdp5_disable_commit,\n\t\t.prepare_commit  = mdp5_prepare_commit,\n\t\t.wait_flush      = mdp5_wait_flush,\n\t\t.complete_commit = mdp5_complete_commit,\n\t\t.get_format      = mdp_get_format,\n\t\t.set_split_display = mdp5_set_split_display,\n\t\t.destroy         = mdp5_kms_destroy,\n#ifdef CONFIG_DEBUG_FS\n\t\t.debugfs_init    = mdp5_kms_debugfs_init,\n#endif\n\t},\n\t.set_irqmask         = mdp5_set_irqmask,\n};\n\nstatic int mdp5_disable(struct mdp5_kms *mdp5_kms)\n{\n\tDBG(\"\");\n\n\tmdp5_kms->enable_count--;\n\tWARN_ON(mdp5_kms->enable_count < 0);\n\n\tclk_disable_unprepare(mdp5_kms->tbu_rt_clk);\n\tclk_disable_unprepare(mdp5_kms->tbu_clk);\n\tclk_disable_unprepare(mdp5_kms->ahb_clk);\n\tclk_disable_unprepare(mdp5_kms->axi_clk);\n\tclk_disable_unprepare(mdp5_kms->core_clk);\n\tclk_disable_unprepare(mdp5_kms->lut_clk);\n\n\treturn 0;\n}\n\nstatic int mdp5_enable(struct mdp5_kms *mdp5_kms)\n{\n\tDBG(\"\");\n\n\tmdp5_kms->enable_count++;\n\n\tclk_prepare_enable(mdp5_kms->ahb_clk);\n\tclk_prepare_enable(mdp5_kms->axi_clk);\n\tclk_prepare_enable(mdp5_kms->core_clk);\n\tclk_prepare_enable(mdp5_kms->lut_clk);\n\tclk_prepare_enable(mdp5_kms->tbu_clk);\n\tclk_prepare_enable(mdp5_kms->tbu_rt_clk);\n\n\treturn 0;\n}\n\nstatic struct drm_encoder *construct_encoder(struct mdp5_kms *mdp5_kms,\n\t\t\t\t\t     struct mdp5_interface *intf,\n\t\t\t\t\t     struct mdp5_ctl *ctl)\n{\n\tstruct drm_device *dev = mdp5_kms->dev;\n\tstruct drm_encoder *encoder;\n\n\tencoder = mdp5_encoder_init(dev, intf, ctl);\n\tif (IS_ERR(encoder)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to construct encoder\\n\");\n\t\treturn encoder;\n\t}\n\n\treturn encoder;\n}\n\nstatic int get_dsi_id_from_intf(const struct mdp5_cfg_hw *hw_cfg, int intf_num)\n{\n\tconst enum mdp5_intf_type *intfs = hw_cfg->intf.connect;\n\tconst int intf_cnt = ARRAY_SIZE(hw_cfg->intf.connect);\n\tint id = 0, i;\n\n\tfor (i = 0; i < intf_cnt; i++) {\n\t\tif (intfs[i] == INTF_DSI) {\n\t\t\tif (intf_num == i)\n\t\t\t\treturn id;\n\n\t\t\tid++;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int modeset_init_intf(struct mdp5_kms *mdp5_kms,\n\t\t\t     struct mdp5_interface *intf)\n{\n\tstruct drm_device *dev = mdp5_kms->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct mdp5_ctl_manager *ctlm = mdp5_kms->ctlm;\n\tstruct mdp5_ctl *ctl;\n\tstruct drm_encoder *encoder;\n\tint ret = 0;\n\n\tswitch (intf->type) {\n\tcase INTF_eDP:\n\t\tDRM_DEV_INFO(dev->dev, \"Skipping eDP interface %d\\n\", intf->num);\n\t\tbreak;\n\tcase INTF_HDMI:\n\t\tif (!priv->hdmi)\n\t\t\tbreak;\n\n\t\tctl = mdp5_ctlm_request(ctlm, intf->num);\n\t\tif (!ctl) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tencoder = construct_encoder(mdp5_kms, intf, ctl);\n\t\tif (IS_ERR(encoder)) {\n\t\t\tret = PTR_ERR(encoder);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = msm_hdmi_modeset_init(priv->hdmi, dev, encoder);\n\t\tbreak;\n\tcase INTF_DSI:\n\t{\n\t\tconst struct mdp5_cfg_hw *hw_cfg =\n\t\t\t\t\tmdp5_cfg_get_hw_config(mdp5_kms->cfg);\n\t\tint dsi_id = get_dsi_id_from_intf(hw_cfg, intf->num);\n\n\t\tif ((dsi_id >= ARRAY_SIZE(priv->dsi)) || (dsi_id < 0)) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to find dsi from intf %d\\n\",\n\t\t\t\tintf->num);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!priv->dsi[dsi_id])\n\t\t\tbreak;\n\n\t\tctl = mdp5_ctlm_request(ctlm, intf->num);\n\t\tif (!ctl) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tencoder = construct_encoder(mdp5_kms, intf, ctl);\n\t\tif (IS_ERR(encoder)) {\n\t\t\tret = PTR_ERR(encoder);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = msm_dsi_modeset_init(priv->dsi[dsi_id], dev, encoder);\n\t\tif (!ret)\n\t\t\tmdp5_encoder_set_intf_mode(encoder, msm_dsi_is_cmd_mode(priv->dsi[dsi_id]));\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tDRM_DEV_ERROR(dev->dev, \"unknown intf: %d\\n\", intf->type);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int modeset_init(struct mdp5_kms *mdp5_kms)\n{\n\tstruct drm_device *dev = mdp5_kms->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tunsigned int num_crtcs;\n\tint i, ret, pi = 0, ci = 0;\n\tstruct drm_plane *primary[MAX_BASES] = { NULL };\n\tstruct drm_plane *cursor[MAX_BASES] = { NULL };\n\tstruct drm_encoder *encoder;\n\tunsigned int num_encoders;\n\n\t \n\tfor (i = 0; i < mdp5_kms->num_intfs; i++) {\n\t\tret = modeset_init_intf(mdp5_kms, mdp5_kms->intfs[i]);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tnum_encoders = 0;\n\tdrm_for_each_encoder(encoder, dev)\n\t\tnum_encoders++;\n\n\t \n\tnum_crtcs = min(num_encoders, mdp5_kms->num_hwmixers);\n\n\t \n\tfor (i = 0; i < mdp5_kms->num_hwpipes; i++) {\n\t\tstruct mdp5_hw_pipe *hwpipe = mdp5_kms->hwpipes[i];\n\t\tstruct drm_plane *plane;\n\t\tenum drm_plane_type type;\n\n\t\tif (i < num_crtcs)\n\t\t\ttype = DRM_PLANE_TYPE_PRIMARY;\n\t\telse if (hwpipe->caps & MDP_PIPE_CAP_CURSOR)\n\t\t\ttype = DRM_PLANE_TYPE_CURSOR;\n\t\telse\n\t\t\ttype = DRM_PLANE_TYPE_OVERLAY;\n\n\t\tplane = mdp5_plane_init(dev, type);\n\t\tif (IS_ERR(plane)) {\n\t\t\tret = PTR_ERR(plane);\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to construct plane %d (%d)\\n\", i, ret);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (type == DRM_PLANE_TYPE_PRIMARY)\n\t\t\tprimary[pi++] = plane;\n\t\tif (type == DRM_PLANE_TYPE_CURSOR)\n\t\t\tcursor[ci++] = plane;\n\t}\n\n\tfor (i = 0; i < num_crtcs; i++) {\n\t\tstruct drm_crtc *crtc;\n\n\t\tcrtc  = mdp5_crtc_init(dev, primary[i], cursor[i], i);\n\t\tif (IS_ERR(crtc)) {\n\t\t\tret = PTR_ERR(crtc);\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to construct crtc %d (%d)\\n\", i, ret);\n\t\t\tgoto fail;\n\t\t}\n\t\tpriv->num_crtcs++;\n\t}\n\n\t \n\tdrm_for_each_encoder(encoder, dev)\n\t\tencoder->possible_crtcs = (1 << priv->num_crtcs) - 1;\n\n\treturn 0;\n\nfail:\n\treturn ret;\n}\n\nstatic void read_mdp_hw_revision(struct mdp5_kms *mdp5_kms,\n\t\t\t\t u32 *major, u32 *minor)\n{\n\tstruct device *dev = &mdp5_kms->pdev->dev;\n\tu32 version;\n\n\tpm_runtime_get_sync(dev);\n\tversion = mdp5_read(mdp5_kms, REG_MDP5_HW_VERSION);\n\tpm_runtime_put_sync(dev);\n\n\t*major = FIELD(version, MDP5_HW_VERSION_MAJOR);\n\t*minor = FIELD(version, MDP5_HW_VERSION_MINOR);\n\n\tDRM_DEV_INFO(dev, \"MDP5 version v%d.%d\", *major, *minor);\n}\n\nstatic int get_clk(struct platform_device *pdev, struct clk **clkp,\n\t\tconst char *name, bool mandatory)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct clk *clk = msm_clk_get(pdev, name);\n\tif (IS_ERR(clk) && mandatory) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get %s (%ld)\\n\", name, PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\tif (IS_ERR(clk))\n\t\tDBG(\"skipping %s\", name);\n\telse\n\t\t*clkp = clk;\n\n\treturn 0;\n}\n\nstatic int mdp5_init(struct platform_device *pdev, struct drm_device *dev);\n\nstatic int mdp5_kms_init(struct drm_device *dev)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct platform_device *pdev;\n\tstruct mdp5_kms *mdp5_kms;\n\tstruct mdp5_cfg *config;\n\tstruct msm_kms *kms;\n\tstruct msm_gem_address_space *aspace;\n\tint irq, i, ret;\n\n\tret = mdp5_init(to_platform_device(dev->dev), dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tkms = priv->kms;\n\tif (!kms)\n\t\treturn -ENOMEM;\n\n\tmdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tpdev = mdp5_kms->pdev;\n\n\tret = mdp_kms_init(&mdp5_kms->base, &kms_funcs);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"failed to init kms\\n\");\n\t\tgoto fail;\n\t}\n\n\tirq = irq_of_parse_and_map(pdev->dev.of_node, 0);\n\tif (!irq) {\n\t\tret = -EINVAL;\n\t\tDRM_DEV_ERROR(&pdev->dev, \"failed to get irq\\n\");\n\t\tgoto fail;\n\t}\n\n\tkms->irq = irq;\n\n\tconfig = mdp5_cfg_get_config(mdp5_kms->cfg);\n\n\t \n\tpm_runtime_get_sync(&pdev->dev);\n\tfor (i = 0; i < MDP5_INTF_NUM_MAX; i++) {\n\t\tif (mdp5_cfg_intf_is_virtual(config->hw->intf.connect[i]) ||\n\t\t    !config->hw->intf.base[i])\n\t\t\tcontinue;\n\t\tmdp5_write(mdp5_kms, REG_MDP5_INTF_TIMING_ENGINE_EN(i), 0);\n\n\t\tmdp5_write(mdp5_kms, REG_MDP5_INTF_FRAME_LINE_COUNT_EN(i), 0x3);\n\t}\n\tmdelay(16);\n\n\taspace = msm_kms_init_aspace(mdp5_kms->dev);\n\tif (IS_ERR(aspace)) {\n\t\tret = PTR_ERR(aspace);\n\t\tgoto fail;\n\t}\n\n\tkms->aspace = aspace;\n\n\tpm_runtime_put_sync(&pdev->dev);\n\n\tret = modeset_init(mdp5_kms);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"modeset_init failed: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tdev->mode_config.max_width = 0xffff;\n\tdev->mode_config.max_height = 0xffff;\n\n\tdev->max_vblank_count = 0;  \n\tdev->vblank_disable_immediate = true;\n\n\treturn 0;\nfail:\n\tif (kms)\n\t\tmdp5_kms_destroy(kms);\n\n\treturn ret;\n}\n\nstatic void mdp5_destroy(struct mdp5_kms *mdp5_kms)\n{\n\tint i;\n\n\tif (mdp5_kms->ctlm)\n\t\tmdp5_ctlm_destroy(mdp5_kms->ctlm);\n\tif (mdp5_kms->smp)\n\t\tmdp5_smp_destroy(mdp5_kms->smp);\n\tif (mdp5_kms->cfg)\n\t\tmdp5_cfg_destroy(mdp5_kms->cfg);\n\n\tfor (i = 0; i < mdp5_kms->num_intfs; i++)\n\t\tkfree(mdp5_kms->intfs[i]);\n\n\tif (mdp5_kms->rpm_enabled)\n\t\tpm_runtime_disable(&mdp5_kms->pdev->dev);\n\n\tdrm_atomic_private_obj_fini(&mdp5_kms->glob_state);\n\tdrm_modeset_lock_fini(&mdp5_kms->glob_state_lock);\n}\n\nstatic int construct_pipes(struct mdp5_kms *mdp5_kms, int cnt,\n\t\tconst enum mdp5_pipe *pipes, const uint32_t *offsets,\n\t\tuint32_t caps)\n{\n\tstruct drm_device *dev = mdp5_kms->dev;\n\tint i, ret;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct mdp5_hw_pipe *hwpipe;\n\n\t\thwpipe = mdp5_pipe_init(pipes[i], offsets[i], caps);\n\t\tif (IS_ERR(hwpipe)) {\n\t\t\tret = PTR_ERR(hwpipe);\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to construct pipe for %s (%d)\\n\",\n\t\t\t\t\tpipe2name(pipes[i]), ret);\n\t\t\treturn ret;\n\t\t}\n\t\thwpipe->idx = mdp5_kms->num_hwpipes;\n\t\tmdp5_kms->hwpipes[mdp5_kms->num_hwpipes++] = hwpipe;\n\t}\n\n\treturn 0;\n}\n\nstatic int hwpipe_init(struct mdp5_kms *mdp5_kms)\n{\n\tstatic const enum mdp5_pipe rgb_planes[] = {\n\t\t\tSSPP_RGB0, SSPP_RGB1, SSPP_RGB2, SSPP_RGB3,\n\t};\n\tstatic const enum mdp5_pipe vig_planes[] = {\n\t\t\tSSPP_VIG0, SSPP_VIG1, SSPP_VIG2, SSPP_VIG3,\n\t};\n\tstatic const enum mdp5_pipe dma_planes[] = {\n\t\t\tSSPP_DMA0, SSPP_DMA1,\n\t};\n\tstatic const enum mdp5_pipe cursor_planes[] = {\n\t\t\tSSPP_CURSOR0, SSPP_CURSOR1,\n\t};\n\tconst struct mdp5_cfg_hw *hw_cfg;\n\tint ret;\n\n\thw_cfg = mdp5_cfg_get_hw_config(mdp5_kms->cfg);\n\n\t \n\tret = construct_pipes(mdp5_kms, hw_cfg->pipe_rgb.count, rgb_planes,\n\t\t\thw_cfg->pipe_rgb.base, hw_cfg->pipe_rgb.caps);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = construct_pipes(mdp5_kms, hw_cfg->pipe_vig.count, vig_planes,\n\t\t\thw_cfg->pipe_vig.base, hw_cfg->pipe_vig.caps);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = construct_pipes(mdp5_kms, hw_cfg->pipe_dma.count, dma_planes,\n\t\t\thw_cfg->pipe_dma.base, hw_cfg->pipe_dma.caps);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = construct_pipes(mdp5_kms, hw_cfg->pipe_cursor.count,\n\t\t\tcursor_planes, hw_cfg->pipe_cursor.base,\n\t\t\thw_cfg->pipe_cursor.caps);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int hwmixer_init(struct mdp5_kms *mdp5_kms)\n{\n\tstruct drm_device *dev = mdp5_kms->dev;\n\tconst struct mdp5_cfg_hw *hw_cfg;\n\tint i, ret;\n\n\thw_cfg = mdp5_cfg_get_hw_config(mdp5_kms->cfg);\n\n\tfor (i = 0; i < hw_cfg->lm.count; i++) {\n\t\tstruct mdp5_hw_mixer *mixer;\n\n\t\tmixer = mdp5_mixer_init(&hw_cfg->lm.instances[i]);\n\t\tif (IS_ERR(mixer)) {\n\t\t\tret = PTR_ERR(mixer);\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to construct LM%d (%d)\\n\",\n\t\t\t\ti, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmixer->idx = mdp5_kms->num_hwmixers;\n\t\tmdp5_kms->hwmixers[mdp5_kms->num_hwmixers++] = mixer;\n\t}\n\n\treturn 0;\n}\n\nstatic int interface_init(struct mdp5_kms *mdp5_kms)\n{\n\tstruct drm_device *dev = mdp5_kms->dev;\n\tconst struct mdp5_cfg_hw *hw_cfg;\n\tconst enum mdp5_intf_type *intf_types;\n\tint i;\n\n\thw_cfg = mdp5_cfg_get_hw_config(mdp5_kms->cfg);\n\tintf_types = hw_cfg->intf.connect;\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_cfg->intf.connect); i++) {\n\t\tstruct mdp5_interface *intf;\n\n\t\tif (intf_types[i] == INTF_DISABLED)\n\t\t\tcontinue;\n\n\t\tintf = kzalloc(sizeof(*intf), GFP_KERNEL);\n\t\tif (!intf) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to construct INTF%d\\n\", i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tintf->num = i;\n\t\tintf->type = intf_types[i];\n\t\tintf->mode = MDP5_INTF_MODE_NONE;\n\t\tintf->idx = mdp5_kms->num_intfs;\n\t\tmdp5_kms->intfs[mdp5_kms->num_intfs++] = intf;\n\t}\n\n\treturn 0;\n}\n\nstatic int mdp5_init(struct platform_device *pdev, struct drm_device *dev)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct mdp5_kms *mdp5_kms;\n\tstruct mdp5_cfg *config;\n\tu32 major, minor;\n\tint ret;\n\n\tmdp5_kms = devm_kzalloc(&pdev->dev, sizeof(*mdp5_kms), GFP_KERNEL);\n\tif (!mdp5_kms) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tspin_lock_init(&mdp5_kms->resource_lock);\n\n\tmdp5_kms->dev = dev;\n\tmdp5_kms->pdev = pdev;\n\n\tret = mdp5_global_obj_init(mdp5_kms);\n\tif (ret)\n\t\tgoto fail;\n\n\tmdp5_kms->mmio = msm_ioremap(pdev, \"mdp_phys\");\n\tif (IS_ERR(mdp5_kms->mmio)) {\n\t\tret = PTR_ERR(mdp5_kms->mmio);\n\t\tgoto fail;\n\t}\n\n\t \n\tret = get_clk(pdev, &mdp5_kms->axi_clk, \"bus\", true);\n\tif (ret)\n\t\tgoto fail;\n\tret = get_clk(pdev, &mdp5_kms->ahb_clk, \"iface\", true);\n\tif (ret)\n\t\tgoto fail;\n\tret = get_clk(pdev, &mdp5_kms->core_clk, \"core\", true);\n\tif (ret)\n\t\tgoto fail;\n\tret = get_clk(pdev, &mdp5_kms->vsync_clk, \"vsync\", true);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tget_clk(pdev, &mdp5_kms->lut_clk, \"lut\", false);\n\tget_clk(pdev, &mdp5_kms->tbu_clk, \"tbu\", false);\n\tget_clk(pdev, &mdp5_kms->tbu_rt_clk, \"tbu_rt\", false);\n\n\t \n\tclk_set_rate(mdp5_kms->core_clk, 200000000);\n\n\t \n\tpriv->kms = &mdp5_kms->base.base;\n\n\tpm_runtime_enable(&pdev->dev);\n\tmdp5_kms->rpm_enabled = true;\n\n\tread_mdp_hw_revision(mdp5_kms, &major, &minor);\n\n\tmdp5_kms->cfg = mdp5_cfg_init(mdp5_kms, major, minor);\n\tif (IS_ERR(mdp5_kms->cfg)) {\n\t\tret = PTR_ERR(mdp5_kms->cfg);\n\t\tmdp5_kms->cfg = NULL;\n\t\tgoto fail;\n\t}\n\n\tconfig = mdp5_cfg_get_config(mdp5_kms->cfg);\n\tmdp5_kms->caps = config->hw->mdp.caps;\n\n\t \n\tclk_set_rate(mdp5_kms->core_clk, config->hw->max_clk);\n\n\t \n\tif (mdp5_kms->caps & MDP_CAP_SMP) {\n\t\tmdp5_kms->smp = mdp5_smp_init(mdp5_kms, &config->hw->smp);\n\t\tif (IS_ERR(mdp5_kms->smp)) {\n\t\t\tret = PTR_ERR(mdp5_kms->smp);\n\t\t\tmdp5_kms->smp = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tmdp5_kms->ctlm = mdp5_ctlm_init(dev, mdp5_kms->mmio, mdp5_kms->cfg);\n\tif (IS_ERR(mdp5_kms->ctlm)) {\n\t\tret = PTR_ERR(mdp5_kms->ctlm);\n\t\tmdp5_kms->ctlm = NULL;\n\t\tgoto fail;\n\t}\n\n\tret = hwpipe_init(mdp5_kms);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = hwmixer_init(mdp5_kms);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = interface_init(mdp5_kms);\n\tif (ret)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tif (mdp5_kms)\n\t\tmdp5_destroy(mdp5_kms);\n\treturn ret;\n}\n\nstatic int mdp5_setup_interconnect(struct platform_device *pdev)\n{\n\tstruct icc_path *path0 = msm_icc_get(&pdev->dev, \"mdp0-mem\");\n\tstruct icc_path *path1 = msm_icc_get(&pdev->dev, \"mdp1-mem\");\n\tstruct icc_path *path_rot = msm_icc_get(&pdev->dev, \"rotator-mem\");\n\n\tif (IS_ERR(path0))\n\t\treturn PTR_ERR(path0);\n\n\tif (!path0) {\n\t\t \n\t\tdev_warn(&pdev->dev, \"No interconnect support may cause display underflows!\\n\");\n\t\treturn 0;\n\t}\n\n\ticc_set_bw(path0, 0, MBps_to_icc(6400));\n\n\tif (!IS_ERR_OR_NULL(path1))\n\t\ticc_set_bw(path1, 0, MBps_to_icc(6400));\n\tif (!IS_ERR_OR_NULL(path_rot))\n\t\ticc_set_bw(path_rot, 0, MBps_to_icc(6400));\n\n\treturn 0;\n}\n\nstatic int mdp5_dev_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tDBG(\"\");\n\n\tret = mdp5_setup_interconnect(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn msm_drv_probe(&pdev->dev, mdp5_kms_init);\n}\n\nstatic int mdp5_dev_remove(struct platform_device *pdev)\n{\n\tDBG(\"\");\n\tcomponent_master_del(&pdev->dev, &msm_drm_ops);\n\treturn 0;\n}\n\nstatic __maybe_unused int mdp5_runtime_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct msm_drm_private *priv = platform_get_drvdata(pdev);\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(priv->kms));\n\n\tDBG(\"\");\n\n\treturn mdp5_disable(mdp5_kms);\n}\n\nstatic __maybe_unused int mdp5_runtime_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct msm_drm_private *priv = platform_get_drvdata(pdev);\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(priv->kms));\n\n\tDBG(\"\");\n\n\treturn mdp5_enable(mdp5_kms);\n}\n\nstatic const struct dev_pm_ops mdp5_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mdp5_runtime_suspend, mdp5_runtime_resume, NULL)\n\t.prepare = msm_pm_prepare,\n\t.complete = msm_pm_complete,\n};\n\nstatic const struct of_device_id mdp5_dt_match[] = {\n\t{ .compatible = \"qcom,mdp5\", },\n\t \n\t{ .compatible = \"qcom,mdss_mdp\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mdp5_dt_match);\n\nstatic struct platform_driver mdp5_driver = {\n\t.probe = mdp5_dev_probe,\n\t.remove = mdp5_dev_remove,\n\t.shutdown = msm_drv_shutdown,\n\t.driver = {\n\t\t.name = \"msm_mdp\",\n\t\t.of_match_table = mdp5_dt_match,\n\t\t.pm = &mdp5_pm_ops,\n\t},\n};\n\nvoid __init msm_mdp_register(void)\n{\n\tDBG(\"\");\n\tplatform_driver_register(&mdp5_driver);\n}\n\nvoid __exit msm_mdp_unregister(void)\n{\n\tDBG(\"\");\n\tplatform_driver_unregister(&mdp5_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}