{
  "module_name": "mdp5_mixer.c",
  "hash_id": "4d70daf1d816d9d629495c5997e0aa955c970bc5c81db600fc2fed2f18ef885e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp5/mdp5_mixer.c",
  "human_readable_source": "\n \n\n#include \"mdp5_kms.h\"\n\n \nstatic int lm_right_pair[] = { 1, -1, 5, -1, -1, -1 };\n\nstatic int get_right_pair_idx(struct mdp5_kms *mdp5_kms, int lm)\n{\n\tint i;\n\tint pair_lm;\n\n\tpair_lm = lm_right_pair[lm];\n\tif (pair_lm < 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < mdp5_kms->num_hwmixers; i++) {\n\t\tstruct mdp5_hw_mixer *mixer = mdp5_kms->hwmixers[i];\n\n\t\tif (mixer->lm == pair_lm)\n\t\t\treturn mixer->idx;\n\t}\n\n\treturn -1;\n}\n\nint mdp5_mixer_assign(struct drm_atomic_state *s, struct drm_crtc *crtc,\n\t\t      uint32_t caps, struct mdp5_hw_mixer **mixer,\n\t\t      struct mdp5_hw_mixer **r_mixer)\n{\n\tstruct msm_drm_private *priv = s->dev->dev_private;\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(priv->kms));\n\tstruct mdp5_global_state *global_state = mdp5_get_global_state(s);\n\tstruct mdp5_hw_mixer_state *new_state;\n\tint i;\n\n\tif (IS_ERR(global_state))\n\t\treturn PTR_ERR(global_state);\n\n\tnew_state = &global_state->hwmixer;\n\n\tfor (i = 0; i < mdp5_kms->num_hwmixers; i++) {\n\t\tstruct mdp5_hw_mixer *cur = mdp5_kms->hwmixers[i];\n\n\t\t \n\t\tif (new_state->hwmixer_to_crtc[cur->idx] &&\n\t\t    new_state->hwmixer_to_crtc[cur->idx] != crtc)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (caps & ~cur->caps)\n\t\t\tcontinue;\n\n\t\tif (r_mixer) {\n\t\t\tint pair_idx;\n\n\t\t\tpair_idx = get_right_pair_idx(mdp5_kms, cur->lm);\n\t\t\tif (pair_idx < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (new_state->hwmixer_to_crtc[pair_idx])\n\t\t\t\tcontinue;\n\n\t\t\t*r_mixer = mdp5_kms->hwmixers[pair_idx];\n\t\t}\n\n\t\t \n\t\tif (!(*mixer) || cur->caps & MDP_LM_CAP_PAIR)\n\t\t\t*mixer = cur;\n\t}\n\n\tif (!(*mixer))\n\t\treturn -ENOMEM;\n\n\tif (r_mixer && !(*r_mixer))\n\t\treturn -ENOMEM;\n\n\tDBG(\"assigning Layer Mixer %d to crtc %s\", (*mixer)->lm, crtc->name);\n\n\tnew_state->hwmixer_to_crtc[(*mixer)->idx] = crtc;\n\tif (r_mixer) {\n\t\tDBG(\"assigning Right Layer Mixer %d to crtc %s\", (*r_mixer)->lm,\n\t\t    crtc->name);\n\t\tnew_state->hwmixer_to_crtc[(*r_mixer)->idx] = crtc;\n\t}\n\n\treturn 0;\n}\n\nint mdp5_mixer_release(struct drm_atomic_state *s, struct mdp5_hw_mixer *mixer)\n{\n\tstruct mdp5_global_state *global_state = mdp5_get_global_state(s);\n\tstruct mdp5_hw_mixer_state *new_state;\n\n\tif (!mixer)\n\t\treturn 0;\n\n\tif (IS_ERR(global_state))\n\t\treturn PTR_ERR(global_state);\n\n\tnew_state = &global_state->hwmixer;\n\n\tif (WARN_ON(!new_state->hwmixer_to_crtc[mixer->idx]))\n\t\treturn -EINVAL;\n\n\tDBG(\"%s: release from crtc %s\", mixer->name,\n\t    new_state->hwmixer_to_crtc[mixer->idx]->name);\n\n\tnew_state->hwmixer_to_crtc[mixer->idx] = NULL;\n\n\treturn 0;\n}\n\nvoid mdp5_mixer_destroy(struct mdp5_hw_mixer *mixer)\n{\n\tkfree(mixer);\n}\n\nstatic const char * const mixer_names[] = {\n\t\"LM0\", \"LM1\", \"LM2\", \"LM3\", \"LM4\", \"LM5\",\n};\n\nstruct mdp5_hw_mixer *mdp5_mixer_init(const struct mdp5_lm_instance *lm)\n{\n\tstruct mdp5_hw_mixer *mixer;\n\n\tmixer = kzalloc(sizeof(*mixer), GFP_KERNEL);\n\tif (!mixer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmixer->name = mixer_names[lm->id];\n\tmixer->lm = lm->id;\n\tmixer->caps = lm->caps;\n\tmixer->pp = lm->pp;\n\tmixer->dspp = lm->dspp;\n\tmixer->flush_mask = mdp_ctl_flush_mask_lm(lm->id);\n\n\treturn mixer;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}