{
  "module_name": "mdp5_ctl.c",
  "hash_id": "8b422968d62c8e6dec822056e981d3ba838c12de05a69e554869077a88837e89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp5/mdp5_ctl.c",
  "human_readable_source": "\n \n\n#include \"mdp5_kms.h\"\n#include \"mdp5_ctl.h\"\n\n \n\n#define CTL_STAT_BUSY\t\t0x1\n#define CTL_STAT_BOOKED\t0x2\n\nstruct mdp5_ctl {\n\tstruct mdp5_ctl_manager *ctlm;\n\n\tu32 id;\n\n\t \n\tu32 status;\n\n\tbool encoder_enabled;\n\n\t \n\tu32 flush_mask;\n\n\t \n\tspinlock_t hw_lock;\n\tu32 reg_offset;\n\n\t \n\tu32 pending_ctl_trigger;\n\n\tbool cursor_on;\n\n\t \n\tbool flush_pending;\n\n\tstruct mdp5_ctl *pair;  \n};\n\nstruct mdp5_ctl_manager {\n\tstruct drm_device *dev;\n\n\t \n\tu32 nlm;\n\tu32 nctl;\n\n\t \n\tu32 flush_hw_mask;\n\n\t \n\tbool single_flush_supported;\n\tu32 single_flush_pending_mask;\n\n\t \n\tspinlock_t pool_lock;\n\tstruct mdp5_ctl ctls[MAX_CTL];\n};\n\nstatic inline\nstruct mdp5_kms *get_kms(struct mdp5_ctl_manager *ctl_mgr)\n{\n\tstruct msm_drm_private *priv = ctl_mgr->dev->dev_private;\n\n\treturn to_mdp5_kms(to_mdp_kms(priv->kms));\n}\n\nstatic inline\nvoid ctl_write(struct mdp5_ctl *ctl, u32 reg, u32 data)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(ctl->ctlm);\n\n\t(void)ctl->reg_offset;  \n\tmdp5_write(mdp5_kms, reg, data);\n}\n\nstatic inline\nu32 ctl_read(struct mdp5_ctl *ctl, u32 reg)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(ctl->ctlm);\n\n\t(void)ctl->reg_offset;  \n\treturn mdp5_read(mdp5_kms, reg);\n}\n\nstatic void set_display_intf(struct mdp5_kms *mdp5_kms,\n\t\tstruct mdp5_interface *intf)\n{\n\tunsigned long flags;\n\tu32 intf_sel;\n\n\tspin_lock_irqsave(&mdp5_kms->resource_lock, flags);\n\tintf_sel = mdp5_read(mdp5_kms, REG_MDP5_DISP_INTF_SEL);\n\n\tswitch (intf->num) {\n\tcase 0:\n\t\tintf_sel &= ~MDP5_DISP_INTF_SEL_INTF0__MASK;\n\t\tintf_sel |= MDP5_DISP_INTF_SEL_INTF0(intf->type);\n\t\tbreak;\n\tcase 1:\n\t\tintf_sel &= ~MDP5_DISP_INTF_SEL_INTF1__MASK;\n\t\tintf_sel |= MDP5_DISP_INTF_SEL_INTF1(intf->type);\n\t\tbreak;\n\tcase 2:\n\t\tintf_sel &= ~MDP5_DISP_INTF_SEL_INTF2__MASK;\n\t\tintf_sel |= MDP5_DISP_INTF_SEL_INTF2(intf->type);\n\t\tbreak;\n\tcase 3:\n\t\tintf_sel &= ~MDP5_DISP_INTF_SEL_INTF3__MASK;\n\t\tintf_sel |= MDP5_DISP_INTF_SEL_INTF3(intf->type);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tmdp5_write(mdp5_kms, REG_MDP5_DISP_INTF_SEL, intf_sel);\n\tspin_unlock_irqrestore(&mdp5_kms->resource_lock, flags);\n}\n\nstatic void set_ctl_op(struct mdp5_ctl *ctl, struct mdp5_pipeline *pipeline)\n{\n\tunsigned long flags;\n\tstruct mdp5_interface *intf = pipeline->intf;\n\tu32 ctl_op = 0;\n\n\tif (!mdp5_cfg_intf_is_virtual(intf->type))\n\t\tctl_op |= MDP5_CTL_OP_INTF_NUM(INTF0 + intf->num);\n\n\tswitch (intf->type) {\n\tcase INTF_DSI:\n\t\tif (intf->mode == MDP5_INTF_DSI_MODE_COMMAND)\n\t\t\tctl_op |= MDP5_CTL_OP_CMD_MODE;\n\t\tbreak;\n\n\tcase INTF_WB:\n\t\tif (intf->mode == MDP5_INTF_WB_MODE_LINE)\n\t\t\tctl_op |= MDP5_CTL_OP_MODE(MODE_WB_2_LINE);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (pipeline->r_mixer)\n\t\tctl_op |= MDP5_CTL_OP_PACK_3D_ENABLE |\n\t\t\t  MDP5_CTL_OP_PACK_3D(1);\n\n\tspin_lock_irqsave(&ctl->hw_lock, flags);\n\tctl_write(ctl, REG_MDP5_CTL_OP(ctl->id), ctl_op);\n\tspin_unlock_irqrestore(&ctl->hw_lock, flags);\n}\n\nint mdp5_ctl_set_pipeline(struct mdp5_ctl *ctl, struct mdp5_pipeline *pipeline)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(ctl->ctlm);\n\tstruct mdp5_interface *intf = pipeline->intf;\n\n\t \n\tif (!mdp5_cfg_intf_is_virtual(intf->type))\n\t\tset_display_intf(mdp5_kms, intf);\n\n\tset_ctl_op(ctl, pipeline);\n\n\treturn 0;\n}\n\nstatic bool start_signal_needed(struct mdp5_ctl *ctl,\n\t\t\t\tstruct mdp5_pipeline *pipeline)\n{\n\tstruct mdp5_interface *intf = pipeline->intf;\n\n\tif (!ctl->encoder_enabled)\n\t\treturn false;\n\n\tswitch (intf->type) {\n\tcase INTF_WB:\n\t\treturn true;\n\tcase INTF_DSI:\n\t\treturn intf->mode == MDP5_INTF_DSI_MODE_COMMAND;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic void send_start_signal(struct mdp5_ctl *ctl)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctl->hw_lock, flags);\n\tctl_write(ctl, REG_MDP5_CTL_START(ctl->id), 1);\n\tspin_unlock_irqrestore(&ctl->hw_lock, flags);\n}\n\n \nint mdp5_ctl_set_encoder_state(struct mdp5_ctl *ctl,\n\t\t\t       struct mdp5_pipeline *pipeline,\n\t\t\t       bool enabled)\n{\n\tstruct mdp5_interface *intf = pipeline->intf;\n\n\tif (WARN_ON(!ctl))\n\t\treturn -EINVAL;\n\n\tctl->encoder_enabled = enabled;\n\tDBG(\"intf_%d: %s\", intf->num, enabled ? \"on\" : \"off\");\n\n\tif (start_signal_needed(ctl, pipeline)) {\n\t\tsend_start_signal(ctl);\n\t}\n\n\treturn 0;\n}\n\n \nint mdp5_ctl_set_cursor(struct mdp5_ctl *ctl, struct mdp5_pipeline *pipeline,\n\t\t\tint cursor_id, bool enable)\n{\n\tstruct mdp5_ctl_manager *ctl_mgr = ctl->ctlm;\n\tunsigned long flags;\n\tu32 blend_cfg;\n\tstruct mdp5_hw_mixer *mixer = pipeline->mixer;\n\n\tif (WARN_ON(!mixer)) {\n\t\tDRM_DEV_ERROR(ctl_mgr->dev->dev, \"CTL %d cannot find LM\",\n\t\t\tctl->id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pipeline->r_mixer) {\n\t\tDRM_DEV_ERROR(ctl_mgr->dev->dev, \"unsupported configuration\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&ctl->hw_lock, flags);\n\n\tblend_cfg = ctl_read(ctl, REG_MDP5_CTL_LAYER_REG(ctl->id, mixer->lm));\n\n\tif (enable)\n\t\tblend_cfg |=  MDP5_CTL_LAYER_REG_CURSOR_OUT;\n\telse\n\t\tblend_cfg &= ~MDP5_CTL_LAYER_REG_CURSOR_OUT;\n\n\tctl_write(ctl, REG_MDP5_CTL_LAYER_REG(ctl->id, mixer->lm), blend_cfg);\n\tctl->cursor_on = enable;\n\n\tspin_unlock_irqrestore(&ctl->hw_lock, flags);\n\n\tctl->pending_ctl_trigger = mdp_ctl_flush_mask_cursor(cursor_id);\n\n\treturn 0;\n}\n\nstatic u32 mdp_ctl_blend_mask(enum mdp5_pipe pipe,\n\t\tenum mdp_mixer_stage_id stage)\n{\n\tswitch (pipe) {\n\tcase SSPP_VIG0: return MDP5_CTL_LAYER_REG_VIG0(stage);\n\tcase SSPP_VIG1: return MDP5_CTL_LAYER_REG_VIG1(stage);\n\tcase SSPP_VIG2: return MDP5_CTL_LAYER_REG_VIG2(stage);\n\tcase SSPP_RGB0: return MDP5_CTL_LAYER_REG_RGB0(stage);\n\tcase SSPP_RGB1: return MDP5_CTL_LAYER_REG_RGB1(stage);\n\tcase SSPP_RGB2: return MDP5_CTL_LAYER_REG_RGB2(stage);\n\tcase SSPP_DMA0: return MDP5_CTL_LAYER_REG_DMA0(stage);\n\tcase SSPP_DMA1: return MDP5_CTL_LAYER_REG_DMA1(stage);\n\tcase SSPP_VIG3: return MDP5_CTL_LAYER_REG_VIG3(stage);\n\tcase SSPP_RGB3: return MDP5_CTL_LAYER_REG_RGB3(stage);\n\tcase SSPP_CURSOR0:\n\tcase SSPP_CURSOR1:\n\tdefault:\treturn 0;\n\t}\n}\n\nstatic u32 mdp_ctl_blend_ext_mask(enum mdp5_pipe pipe,\n\t\tenum mdp_mixer_stage_id stage)\n{\n\tif (stage < STAGE6 && (pipe != SSPP_CURSOR0 && pipe != SSPP_CURSOR1))\n\t\treturn 0;\n\n\tswitch (pipe) {\n\tcase SSPP_VIG0: return MDP5_CTL_LAYER_EXT_REG_VIG0_BIT3;\n\tcase SSPP_VIG1: return MDP5_CTL_LAYER_EXT_REG_VIG1_BIT3;\n\tcase SSPP_VIG2: return MDP5_CTL_LAYER_EXT_REG_VIG2_BIT3;\n\tcase SSPP_RGB0: return MDP5_CTL_LAYER_EXT_REG_RGB0_BIT3;\n\tcase SSPP_RGB1: return MDP5_CTL_LAYER_EXT_REG_RGB1_BIT3;\n\tcase SSPP_RGB2: return MDP5_CTL_LAYER_EXT_REG_RGB2_BIT3;\n\tcase SSPP_DMA0: return MDP5_CTL_LAYER_EXT_REG_DMA0_BIT3;\n\tcase SSPP_DMA1: return MDP5_CTL_LAYER_EXT_REG_DMA1_BIT3;\n\tcase SSPP_VIG3: return MDP5_CTL_LAYER_EXT_REG_VIG3_BIT3;\n\tcase SSPP_RGB3: return MDP5_CTL_LAYER_EXT_REG_RGB3_BIT3;\n\tcase SSPP_CURSOR0: return MDP5_CTL_LAYER_EXT_REG_CURSOR0(stage);\n\tcase SSPP_CURSOR1: return MDP5_CTL_LAYER_EXT_REG_CURSOR1(stage);\n\tdefault:\treturn 0;\n\t}\n}\n\nstatic void mdp5_ctl_reset_blend_regs(struct mdp5_ctl *ctl)\n{\n\tunsigned long flags;\n\tstruct mdp5_ctl_manager *ctl_mgr = ctl->ctlm;\n\tint i;\n\n\tspin_lock_irqsave(&ctl->hw_lock, flags);\n\n\tfor (i = 0; i < ctl_mgr->nlm; i++) {\n\t\tctl_write(ctl, REG_MDP5_CTL_LAYER_REG(ctl->id, i), 0x0);\n\t\tctl_write(ctl, REG_MDP5_CTL_LAYER_EXT_REG(ctl->id, i), 0x0);\n\t}\n\n\tspin_unlock_irqrestore(&ctl->hw_lock, flags);\n}\n\n#define PIPE_LEFT\t0\n#define PIPE_RIGHT\t1\nint mdp5_ctl_blend(struct mdp5_ctl *ctl, struct mdp5_pipeline *pipeline,\n\t\t   enum mdp5_pipe stage[][MAX_PIPE_STAGE],\n\t\t   enum mdp5_pipe r_stage[][MAX_PIPE_STAGE],\n\t\t   u32 stage_cnt, u32 ctl_blend_op_flags)\n{\n\tstruct mdp5_hw_mixer *mixer = pipeline->mixer;\n\tstruct mdp5_hw_mixer *r_mixer = pipeline->r_mixer;\n\tunsigned long flags;\n\tu32 blend_cfg = 0, blend_ext_cfg = 0;\n\tu32 r_blend_cfg = 0, r_blend_ext_cfg = 0;\n\tint i, start_stage;\n\n\tmdp5_ctl_reset_blend_regs(ctl);\n\n\tif (ctl_blend_op_flags & MDP5_CTL_BLEND_OP_FLAG_BORDER_OUT) {\n\t\tstart_stage = STAGE0;\n\t\tblend_cfg |= MDP5_CTL_LAYER_REG_BORDER_COLOR;\n\t\tif (r_mixer)\n\t\t\tr_blend_cfg |= MDP5_CTL_LAYER_REG_BORDER_COLOR;\n\t} else {\n\t\tstart_stage = STAGE_BASE;\n\t}\n\n\tfor (i = start_stage; stage_cnt && i <= STAGE_MAX; i++) {\n\t\tblend_cfg |=\n\t\t\tmdp_ctl_blend_mask(stage[i][PIPE_LEFT], i) |\n\t\t\tmdp_ctl_blend_mask(stage[i][PIPE_RIGHT], i);\n\t\tblend_ext_cfg |=\n\t\t\tmdp_ctl_blend_ext_mask(stage[i][PIPE_LEFT], i) |\n\t\t\tmdp_ctl_blend_ext_mask(stage[i][PIPE_RIGHT], i);\n\t\tif (r_mixer) {\n\t\t\tr_blend_cfg |=\n\t\t\t\tmdp_ctl_blend_mask(r_stage[i][PIPE_LEFT], i) |\n\t\t\t\tmdp_ctl_blend_mask(r_stage[i][PIPE_RIGHT], i);\n\t\t\tr_blend_ext_cfg |=\n\t\t\t     mdp_ctl_blend_ext_mask(r_stage[i][PIPE_LEFT], i) |\n\t\t\t     mdp_ctl_blend_ext_mask(r_stage[i][PIPE_RIGHT], i);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&ctl->hw_lock, flags);\n\tif (ctl->cursor_on)\n\t\tblend_cfg |=  MDP5_CTL_LAYER_REG_CURSOR_OUT;\n\n\tctl_write(ctl, REG_MDP5_CTL_LAYER_REG(ctl->id, mixer->lm), blend_cfg);\n\tctl_write(ctl, REG_MDP5_CTL_LAYER_EXT_REG(ctl->id, mixer->lm),\n\t\t  blend_ext_cfg);\n\tif (r_mixer) {\n\t\tctl_write(ctl, REG_MDP5_CTL_LAYER_REG(ctl->id, r_mixer->lm),\n\t\t\t  r_blend_cfg);\n\t\tctl_write(ctl, REG_MDP5_CTL_LAYER_EXT_REG(ctl->id, r_mixer->lm),\n\t\t\t  r_blend_ext_cfg);\n\t}\n\tspin_unlock_irqrestore(&ctl->hw_lock, flags);\n\n\tctl->pending_ctl_trigger = mdp_ctl_flush_mask_lm(mixer->lm);\n\tif (r_mixer)\n\t\tctl->pending_ctl_trigger |= mdp_ctl_flush_mask_lm(r_mixer->lm);\n\n\tDBG(\"lm%d: blend config = 0x%08x. ext_cfg = 0x%08x\", mixer->lm,\n\t\tblend_cfg, blend_ext_cfg);\n\tif (r_mixer)\n\t\tDBG(\"lm%d: blend config = 0x%08x. ext_cfg = 0x%08x\",\n\t\t    r_mixer->lm, r_blend_cfg, r_blend_ext_cfg);\n\n\treturn 0;\n}\n\nu32 mdp_ctl_flush_mask_encoder(struct mdp5_interface *intf)\n{\n\tif (intf->type == INTF_WB)\n\t\treturn MDP5_CTL_FLUSH_WB;\n\n\tswitch (intf->num) {\n\tcase 0: return MDP5_CTL_FLUSH_TIMING_0;\n\tcase 1: return MDP5_CTL_FLUSH_TIMING_1;\n\tcase 2: return MDP5_CTL_FLUSH_TIMING_2;\n\tcase 3: return MDP5_CTL_FLUSH_TIMING_3;\n\tdefault: return 0;\n\t}\n}\n\nu32 mdp_ctl_flush_mask_cursor(int cursor_id)\n{\n\tswitch (cursor_id) {\n\tcase 0: return MDP5_CTL_FLUSH_CURSOR_0;\n\tcase 1: return MDP5_CTL_FLUSH_CURSOR_1;\n\tdefault: return 0;\n\t}\n}\n\nu32 mdp_ctl_flush_mask_pipe(enum mdp5_pipe pipe)\n{\n\tswitch (pipe) {\n\tcase SSPP_VIG0: return MDP5_CTL_FLUSH_VIG0;\n\tcase SSPP_VIG1: return MDP5_CTL_FLUSH_VIG1;\n\tcase SSPP_VIG2: return MDP5_CTL_FLUSH_VIG2;\n\tcase SSPP_RGB0: return MDP5_CTL_FLUSH_RGB0;\n\tcase SSPP_RGB1: return MDP5_CTL_FLUSH_RGB1;\n\tcase SSPP_RGB2: return MDP5_CTL_FLUSH_RGB2;\n\tcase SSPP_DMA0: return MDP5_CTL_FLUSH_DMA0;\n\tcase SSPP_DMA1: return MDP5_CTL_FLUSH_DMA1;\n\tcase SSPP_VIG3: return MDP5_CTL_FLUSH_VIG3;\n\tcase SSPP_RGB3: return MDP5_CTL_FLUSH_RGB3;\n\tcase SSPP_CURSOR0: return MDP5_CTL_FLUSH_CURSOR_0;\n\tcase SSPP_CURSOR1: return MDP5_CTL_FLUSH_CURSOR_1;\n\tdefault:        return 0;\n\t}\n}\n\nu32 mdp_ctl_flush_mask_lm(int lm)\n{\n\tswitch (lm) {\n\tcase 0:  return MDP5_CTL_FLUSH_LM0;\n\tcase 1:  return MDP5_CTL_FLUSH_LM1;\n\tcase 2:  return MDP5_CTL_FLUSH_LM2;\n\tcase 3:  return MDP5_CTL_FLUSH_LM3;\n\tcase 4:  return MDP5_CTL_FLUSH_LM4;\n\tcase 5:  return MDP5_CTL_FLUSH_LM5;\n\tdefault: return 0;\n\t}\n}\n\nstatic u32 fix_sw_flush(struct mdp5_ctl *ctl, struct mdp5_pipeline *pipeline,\n\t\t\tu32 flush_mask)\n{\n\tstruct mdp5_ctl_manager *ctl_mgr = ctl->ctlm;\n\tu32 sw_mask = 0;\n#define BIT_NEEDS_SW_FIX(bit) \\\n\t(!(ctl_mgr->flush_hw_mask & bit) && (flush_mask & bit))\n\n\t \n\tif (BIT_NEEDS_SW_FIX(MDP5_CTL_FLUSH_CURSOR_0))\n\t\tsw_mask |= mdp_ctl_flush_mask_lm(pipeline->mixer->lm);\n\n\treturn sw_mask;\n}\n\nstatic void fix_for_single_flush(struct mdp5_ctl *ctl, u32 *flush_mask,\n\t\tu32 *flush_id)\n{\n\tstruct mdp5_ctl_manager *ctl_mgr = ctl->ctlm;\n\n\tif (ctl->pair) {\n\t\tDBG(\"CTL %d FLUSH pending mask %x\", ctl->id, *flush_mask);\n\t\tctl->flush_pending = true;\n\t\tctl_mgr->single_flush_pending_mask |= (*flush_mask);\n\t\t*flush_mask = 0;\n\n\t\tif (ctl->pair->flush_pending) {\n\t\t\t*flush_id = min_t(u32, ctl->id, ctl->pair->id);\n\t\t\t*flush_mask = ctl_mgr->single_flush_pending_mask;\n\n\t\t\tctl->flush_pending = false;\n\t\t\tctl->pair->flush_pending = false;\n\t\t\tctl_mgr->single_flush_pending_mask = 0;\n\n\t\t\tDBG(\"Single FLUSH mask %x,ID %d\", *flush_mask,\n\t\t\t\t*flush_id);\n\t\t}\n\t}\n}\n\n \nu32 mdp5_ctl_commit(struct mdp5_ctl *ctl,\n\t\t    struct mdp5_pipeline *pipeline,\n\t\t    u32 flush_mask, bool start)\n{\n\tstruct mdp5_ctl_manager *ctl_mgr = ctl->ctlm;\n\tunsigned long flags;\n\tu32 flush_id = ctl->id;\n\tu32 curr_ctl_flush_mask;\n\n\tVERB(\"flush_mask=%x, trigger=%x\", flush_mask, ctl->pending_ctl_trigger);\n\n\tif (ctl->pending_ctl_trigger & flush_mask) {\n\t\tflush_mask |= MDP5_CTL_FLUSH_CTL;\n\t\tctl->pending_ctl_trigger = 0;\n\t}\n\n\tflush_mask |= fix_sw_flush(ctl, pipeline, flush_mask);\n\n\tflush_mask &= ctl_mgr->flush_hw_mask;\n\n\tcurr_ctl_flush_mask = flush_mask;\n\n\tfix_for_single_flush(ctl, &flush_mask, &flush_id);\n\n\tif (!start) {\n\t\tctl->flush_mask |= flush_mask;\n\t\treturn curr_ctl_flush_mask;\n\t} else {\n\t\tflush_mask |= ctl->flush_mask;\n\t\tctl->flush_mask = 0;\n\t}\n\n\tif (flush_mask) {\n\t\tspin_lock_irqsave(&ctl->hw_lock, flags);\n\t\tctl_write(ctl, REG_MDP5_CTL_FLUSH(flush_id), flush_mask);\n\t\tspin_unlock_irqrestore(&ctl->hw_lock, flags);\n\t}\n\n\tif (start_signal_needed(ctl, pipeline)) {\n\t\tsend_start_signal(ctl);\n\t}\n\n\treturn curr_ctl_flush_mask;\n}\n\nu32 mdp5_ctl_get_commit_status(struct mdp5_ctl *ctl)\n{\n\treturn ctl_read(ctl, REG_MDP5_CTL_FLUSH(ctl->id));\n}\n\nint mdp5_ctl_get_ctl_id(struct mdp5_ctl *ctl)\n{\n\treturn WARN_ON(!ctl) ? -EINVAL : ctl->id;\n}\n\n \nint mdp5_ctl_pair(struct mdp5_ctl *ctlx, struct mdp5_ctl *ctly, bool enable)\n{\n\tstruct mdp5_ctl_manager *ctl_mgr = ctlx->ctlm;\n\tstruct mdp5_kms *mdp5_kms = get_kms(ctl_mgr);\n\n\t \n\tif (!ctl_mgr->single_flush_supported)\n\t\treturn 0;\n\n\tif (!enable) {\n\t\tctlx->pair = NULL;\n\t\tctly->pair = NULL;\n\t\tmdp5_write(mdp5_kms, REG_MDP5_SPARE_0, 0);\n\t\treturn 0;\n\t} else if ((ctlx->pair != NULL) || (ctly->pair != NULL)) {\n\t\tDRM_DEV_ERROR(ctl_mgr->dev->dev, \"CTLs already paired\\n\");\n\t\treturn -EINVAL;\n\t} else if (!(ctlx->status & ctly->status & CTL_STAT_BOOKED)) {\n\t\tDRM_DEV_ERROR(ctl_mgr->dev->dev, \"Only pair booked CTLs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctlx->pair = ctly;\n\tctly->pair = ctlx;\n\n\tmdp5_write(mdp5_kms, REG_MDP5_SPARE_0,\n\t\t   MDP5_SPARE_0_SPLIT_DPL_SINGLE_FLUSH_EN);\n\n\treturn 0;\n}\n\n \nstruct mdp5_ctl *mdp5_ctlm_request(struct mdp5_ctl_manager *ctl_mgr,\n\t\tint intf_num)\n{\n\tstruct mdp5_ctl *ctl = NULL;\n\tconst u32 checkm = CTL_STAT_BUSY | CTL_STAT_BOOKED;\n\tu32 match = ((intf_num == 1) || (intf_num == 2)) ? CTL_STAT_BOOKED : 0;\n\tunsigned long flags;\n\tint c;\n\n\tspin_lock_irqsave(&ctl_mgr->pool_lock, flags);\n\n\t \n\tfor (c = 0; c < ctl_mgr->nctl; c++)\n\t\tif ((ctl_mgr->ctls[c].status & checkm) == match)\n\t\t\tgoto found;\n\n\tdev_warn(ctl_mgr->dev->dev,\n\t\t\"fall back to the other CTL category for INTF %d!\\n\", intf_num);\n\n\tmatch ^= CTL_STAT_BOOKED;\n\tfor (c = 0; c < ctl_mgr->nctl; c++)\n\t\tif ((ctl_mgr->ctls[c].status & checkm) == match)\n\t\t\tgoto found;\n\n\tDRM_DEV_ERROR(ctl_mgr->dev->dev, \"No more CTL available!\");\n\tgoto unlock;\n\nfound:\n\tctl = &ctl_mgr->ctls[c];\n\tctl->status |= CTL_STAT_BUSY;\n\tctl->pending_ctl_trigger = 0;\n\tDBG(\"CTL %d allocated\", ctl->id);\n\nunlock:\n\tspin_unlock_irqrestore(&ctl_mgr->pool_lock, flags);\n\treturn ctl;\n}\n\nvoid mdp5_ctlm_hw_reset(struct mdp5_ctl_manager *ctl_mgr)\n{\n\tunsigned long flags;\n\tint c;\n\n\tfor (c = 0; c < ctl_mgr->nctl; c++) {\n\t\tstruct mdp5_ctl *ctl = &ctl_mgr->ctls[c];\n\n\t\tspin_lock_irqsave(&ctl->hw_lock, flags);\n\t\tctl_write(ctl, REG_MDP5_CTL_OP(ctl->id), 0);\n\t\tspin_unlock_irqrestore(&ctl->hw_lock, flags);\n\t}\n}\n\nvoid mdp5_ctlm_destroy(struct mdp5_ctl_manager *ctl_mgr)\n{\n\tkfree(ctl_mgr);\n}\n\nstruct mdp5_ctl_manager *mdp5_ctlm_init(struct drm_device *dev,\n\t\tvoid __iomem *mmio_base, struct mdp5_cfg_handler *cfg_hnd)\n{\n\tstruct mdp5_ctl_manager *ctl_mgr;\n\tconst struct mdp5_cfg_hw *hw_cfg = mdp5_cfg_get_hw_config(cfg_hnd);\n\tint rev = mdp5_cfg_get_hw_rev(cfg_hnd);\n\tunsigned dsi_cnt = 0;\n\tconst struct mdp5_ctl_block *ctl_cfg = &hw_cfg->ctl;\n\tunsigned long flags;\n\tint c, ret;\n\n\tctl_mgr = kzalloc(sizeof(*ctl_mgr), GFP_KERNEL);\n\tif (!ctl_mgr) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to allocate CTL manager\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tif (WARN_ON(ctl_cfg->count > MAX_CTL)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"Increase static pool size to at least %d\\n\",\n\t\t\t\tctl_cfg->count);\n\t\tret = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\t \n\tctl_mgr->dev = dev;\n\tctl_mgr->nlm = hw_cfg->lm.count;\n\tctl_mgr->nctl = ctl_cfg->count;\n\tctl_mgr->flush_hw_mask = ctl_cfg->flush_hw_mask;\n\tspin_lock_init(&ctl_mgr->pool_lock);\n\n\t \n\tspin_lock_irqsave(&ctl_mgr->pool_lock, flags);\n\tfor (c = 0; c < ctl_mgr->nctl; c++) {\n\t\tstruct mdp5_ctl *ctl = &ctl_mgr->ctls[c];\n\n\t\tif (WARN_ON(!ctl_cfg->base[c])) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"CTL_%d: base is null!\\n\", c);\n\t\t\tret = -EINVAL;\n\t\t\tspin_unlock_irqrestore(&ctl_mgr->pool_lock, flags);\n\t\t\tgoto fail;\n\t\t}\n\t\tctl->ctlm = ctl_mgr;\n\t\tctl->id = c;\n\t\tctl->reg_offset = ctl_cfg->base[c];\n\t\tctl->status = 0;\n\t\tspin_lock_init(&ctl->hw_lock);\n\t}\n\n\t \n\tfor (c = 0; c < ARRAY_SIZE(hw_cfg->intf.connect); c++)\n\t\tif (hw_cfg->intf.connect[c] == INTF_DSI)\n\t\t\tdsi_cnt++;\n\tif ((rev >= 3) && (dsi_cnt > 1)) {\n\t\tctl_mgr->single_flush_supported = true;\n\t\t \n\t\tctl_mgr->ctls[0].status |= CTL_STAT_BOOKED;\n\t\tctl_mgr->ctls[1].status |= CTL_STAT_BOOKED;\n\t}\n\tspin_unlock_irqrestore(&ctl_mgr->pool_lock, flags);\n\tDBG(\"Pool of %d CTLs created.\", ctl_mgr->nctl);\n\n\treturn ctl_mgr;\n\nfail:\n\tif (ctl_mgr)\n\t\tmdp5_ctlm_destroy(ctl_mgr);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}