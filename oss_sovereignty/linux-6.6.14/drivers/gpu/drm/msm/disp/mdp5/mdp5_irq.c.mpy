{
  "module_name": "mdp5_irq.c",
  "hash_id": "60edc8a8a802dedaf7be19e8771c584ba96f046449f4c653b83990c6d9682ac4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp5/mdp5_irq.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n\n#include \"msm_drv.h\"\n#include \"mdp5_kms.h\"\n\nvoid mdp5_set_irqmask(struct mdp_kms *mdp_kms, uint32_t irqmask,\n\t\tuint32_t old_irqmask)\n{\n\tmdp5_write(to_mdp5_kms(mdp_kms), REG_MDP5_INTR_CLEAR,\n\t\t   irqmask ^ (irqmask & old_irqmask));\n\tmdp5_write(to_mdp5_kms(mdp_kms), REG_MDP5_INTR_EN, irqmask);\n}\n\nstatic void mdp5_irq_error_handler(struct mdp_irq *irq, uint32_t irqstatus)\n{\n\tstruct mdp5_kms *mdp5_kms = container_of(irq, struct mdp5_kms, error_handler);\n\tstatic DEFINE_RATELIMIT_STATE(rs, 5*HZ, 1);\n\textern bool dumpstate;\n\n\tDRM_ERROR_RATELIMITED(\"errors: %08x\\n\", irqstatus);\n\n\tif (dumpstate && __ratelimit(&rs)) {\n\t\tstruct drm_printer p = drm_info_printer(mdp5_kms->dev->dev);\n\t\tdrm_state_dump(mdp5_kms->dev, &p);\n\t\tif (mdp5_kms->smp)\n\t\t\tmdp5_smp_dump(mdp5_kms->smp, &p);\n\t}\n}\n\nvoid mdp5_irq_preinstall(struct msm_kms *kms)\n{\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tstruct device *dev = &mdp5_kms->pdev->dev;\n\n\tpm_runtime_get_sync(dev);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTR_CLEAR, 0xffffffff);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTR_EN, 0x00000000);\n\tpm_runtime_put_sync(dev);\n}\n\nint mdp5_irq_postinstall(struct msm_kms *kms)\n{\n\tstruct mdp_kms *mdp_kms = to_mdp_kms(kms);\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(mdp_kms);\n\tstruct device *dev = &mdp5_kms->pdev->dev;\n\tstruct mdp_irq *error_handler = &mdp5_kms->error_handler;\n\n\terror_handler->irq = mdp5_irq_error_handler;\n\terror_handler->irqmask = MDP5_IRQ_INTF0_UNDER_RUN |\n\t\t\tMDP5_IRQ_INTF1_UNDER_RUN |\n\t\t\tMDP5_IRQ_INTF2_UNDER_RUN |\n\t\t\tMDP5_IRQ_INTF3_UNDER_RUN;\n\n\tpm_runtime_get_sync(dev);\n\tmdp_irq_register(mdp_kms, error_handler);\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nvoid mdp5_irq_uninstall(struct msm_kms *kms)\n{\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tstruct device *dev = &mdp5_kms->pdev->dev;\n\n\tpm_runtime_get_sync(dev);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTR_EN, 0x00000000);\n\tpm_runtime_put_sync(dev);\n}\n\nirqreturn_t mdp5_irq(struct msm_kms *kms)\n{\n\tstruct mdp_kms *mdp_kms = to_mdp_kms(kms);\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(mdp_kms);\n\tstruct drm_device *dev = mdp5_kms->dev;\n\tstruct drm_crtc *crtc;\n\tuint32_t status, enable;\n\n\tenable = mdp5_read(mdp5_kms, REG_MDP5_INTR_EN);\n\tstatus = mdp5_read(mdp5_kms, REG_MDP5_INTR_STATUS) & enable;\n\tmdp5_write(mdp5_kms, REG_MDP5_INTR_CLEAR, status);\n\n\tVERB(\"status=%08x\", status);\n\n\tmdp_dispatch_irqs(mdp_kms, status);\n\n\tdrm_for_each_crtc(crtc, dev)\n\t\tif (status & mdp5_crtc_vblank(crtc))\n\t\t\tdrm_crtc_handle_vblank(crtc);\n\n\treturn IRQ_HANDLED;\n}\n\nint mdp5_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)\n{\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tstruct device *dev = &mdp5_kms->pdev->dev;\n\n\tpm_runtime_get_sync(dev);\n\tmdp_update_vblank_mask(to_mdp_kms(kms),\n\t\t\tmdp5_crtc_vblank(crtc), true);\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nvoid mdp5_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)\n{\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\n\tstruct device *dev = &mdp5_kms->pdev->dev;\n\n\tpm_runtime_get_sync(dev);\n\tmdp_update_vblank_mask(to_mdp_kms(kms),\n\t\t\tmdp5_crtc_vblank(crtc), false);\n\tpm_runtime_put_sync(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}