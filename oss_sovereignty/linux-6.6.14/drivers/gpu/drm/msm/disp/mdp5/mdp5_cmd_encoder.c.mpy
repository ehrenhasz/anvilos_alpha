{
  "module_name": "mdp5_cmd_encoder.c",
  "hash_id": "40d40bcfe18bdd270189dc0853f84aaef8573a4a18451e59aa2fe74e0b016eb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp5/mdp5_cmd_encoder.c",
  "human_readable_source": "\n \n\n#include <drm/drm_crtc.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mdp5_kms.h\"\n\n#ifdef CONFIG_DRM_MSM_DSI\n\nstatic struct mdp5_kms *get_kms(struct drm_encoder *encoder)\n{\n\tstruct msm_drm_private *priv = encoder->dev->dev_private;\n\treturn to_mdp5_kms(to_mdp_kms(priv->kms));\n}\n\n#define VSYNC_CLK_RATE 19200000\nstatic int pingpong_tearcheck_setup(struct drm_encoder *encoder,\n\t\t\t\t    struct drm_display_mode *mode)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(encoder);\n\tstruct device *dev = encoder->dev->dev;\n\tu32 total_lines, vclks_line, cfg;\n\tlong vsync_clk_speed;\n\tstruct mdp5_hw_mixer *mixer = mdp5_crtc_get_mixer(encoder->crtc);\n\tint pp_id = mixer->pp;\n\n\tif (IS_ERR_OR_NULL(mdp5_kms->vsync_clk)) {\n\t\tDRM_DEV_ERROR(dev, \"vsync_clk is not initialized\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttotal_lines = mode->vtotal * drm_mode_vrefresh(mode);\n\tif (!total_lines) {\n\t\tDRM_DEV_ERROR(dev, \"%s: vtotal(%d) or vrefresh(%d) is 0\\n\",\n\t\t\t      __func__, mode->vtotal, drm_mode_vrefresh(mode));\n\t\treturn -EINVAL;\n\t}\n\n\tvsync_clk_speed = clk_round_rate(mdp5_kms->vsync_clk, VSYNC_CLK_RATE);\n\tif (vsync_clk_speed <= 0) {\n\t\tDRM_DEV_ERROR(dev, \"vsync_clk round rate failed %ld\\n\",\n\t\t\t\t\t\t\tvsync_clk_speed);\n\t\treturn -EINVAL;\n\t}\n\tvclks_line = vsync_clk_speed / total_lines;\n\n\tcfg = MDP5_PP_SYNC_CONFIG_VSYNC_COUNTER_EN\n\t\t| MDP5_PP_SYNC_CONFIG_VSYNC_IN_EN;\n\tcfg |= MDP5_PP_SYNC_CONFIG_VSYNC_COUNT(vclks_line);\n\n\t \n\tmdp5_write(mdp5_kms, REG_MDP5_PP_SYNC_CONFIG_VSYNC(pp_id), cfg);\n\tmdp5_write(mdp5_kms,\n\t\tREG_MDP5_PP_SYNC_CONFIG_HEIGHT(pp_id), (2 * mode->vtotal));\n\n\tmdp5_write(mdp5_kms,\n\t\tREG_MDP5_PP_VSYNC_INIT_VAL(pp_id), mode->vdisplay);\n\tmdp5_write(mdp5_kms, REG_MDP5_PP_RD_PTR_IRQ(pp_id), mode->vdisplay + 1);\n\tmdp5_write(mdp5_kms, REG_MDP5_PP_START_POS(pp_id), mode->vdisplay);\n\tmdp5_write(mdp5_kms, REG_MDP5_PP_SYNC_THRESH(pp_id),\n\t\t\tMDP5_PP_SYNC_THRESH_START(4) |\n\t\t\tMDP5_PP_SYNC_THRESH_CONTINUE(4));\n\tmdp5_write(mdp5_kms, REG_MDP5_PP_AUTOREFRESH_CONFIG(pp_id), 0x0);\n\n\treturn 0;\n}\n\nstatic int pingpong_tearcheck_enable(struct drm_encoder *encoder)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(encoder);\n\tstruct mdp5_hw_mixer *mixer = mdp5_crtc_get_mixer(encoder->crtc);\n\tint pp_id = mixer->pp;\n\tint ret;\n\n\tret = clk_set_rate(mdp5_kms->vsync_clk,\n\t\tclk_round_rate(mdp5_kms->vsync_clk, VSYNC_CLK_RATE));\n\tif (ret) {\n\t\tDRM_DEV_ERROR(encoder->dev->dev,\n\t\t\t\"vsync_clk clk_set_rate failed, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = clk_prepare_enable(mdp5_kms->vsync_clk);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(encoder->dev->dev,\n\t\t\t\"vsync_clk clk_prepare_enable failed, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PP_TEAR_CHECK_EN(pp_id), 1);\n\n\treturn 0;\n}\n\nstatic void pingpong_tearcheck_disable(struct drm_encoder *encoder)\n{\n\tstruct mdp5_kms *mdp5_kms = get_kms(encoder);\n\tstruct mdp5_hw_mixer *mixer = mdp5_crtc_get_mixer(encoder->crtc);\n\tint pp_id = mixer->pp;\n\n\tmdp5_write(mdp5_kms, REG_MDP5_PP_TEAR_CHECK_EN(pp_id), 0);\n\tclk_disable_unprepare(mdp5_kms->vsync_clk);\n}\n\nvoid mdp5_cmd_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t       struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n\tmode = adjusted_mode;\n\n\tDBG(\"set mode: \" DRM_MODE_FMT, DRM_MODE_ARG(mode));\n\tpingpong_tearcheck_setup(encoder, mode);\n\tmdp5_crtc_set_pipeline(encoder->crtc);\n}\n\nvoid mdp5_cmd_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct mdp5_encoder *mdp5_cmd_enc = to_mdp5_encoder(encoder);\n\tstruct mdp5_ctl *ctl = mdp5_cmd_enc->ctl;\n\tstruct mdp5_interface *intf = mdp5_cmd_enc->intf;\n\tstruct mdp5_pipeline *pipeline = mdp5_crtc_get_pipeline(encoder->crtc);\n\n\tif (WARN_ON(!mdp5_cmd_enc->enabled))\n\t\treturn;\n\n\tpingpong_tearcheck_disable(encoder);\n\n\tmdp5_ctl_set_encoder_state(ctl, pipeline, false);\n\tmdp5_ctl_commit(ctl, pipeline, mdp_ctl_flush_mask_encoder(intf), true);\n\n\tmdp5_cmd_enc->enabled = false;\n}\n\nvoid mdp5_cmd_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct mdp5_encoder *mdp5_cmd_enc = to_mdp5_encoder(encoder);\n\tstruct mdp5_ctl *ctl = mdp5_cmd_enc->ctl;\n\tstruct mdp5_interface *intf = mdp5_cmd_enc->intf;\n\tstruct mdp5_pipeline *pipeline = mdp5_crtc_get_pipeline(encoder->crtc);\n\n\tif (WARN_ON(mdp5_cmd_enc->enabled))\n\t\treturn;\n\n\tif (pingpong_tearcheck_enable(encoder))\n\t\treturn;\n\n\tmdp5_ctl_commit(ctl, pipeline, mdp_ctl_flush_mask_encoder(intf), true);\n\n\tmdp5_ctl_set_encoder_state(ctl, pipeline, true);\n\n\tmdp5_cmd_enc->enabled = true;\n}\n\nint mdp5_cmd_encoder_set_split_display(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_encoder *slave_encoder)\n{\n\tstruct mdp5_encoder *mdp5_cmd_enc = to_mdp5_encoder(encoder);\n\tstruct mdp5_kms *mdp5_kms;\n\tstruct device *dev;\n\tint intf_num;\n\tu32 data = 0;\n\n\tif (!encoder || !slave_encoder)\n\t\treturn -EINVAL;\n\n\tmdp5_kms = get_kms(encoder);\n\tintf_num = mdp5_cmd_enc->intf->num;\n\n\t \n\tif (intf_num == 1)\n\t\tdata |= MDP5_SPLIT_DPL_UPPER_INTF2_SW_TRG_MUX;\n\telse if (intf_num == 2)\n\t\tdata |= MDP5_SPLIT_DPL_UPPER_INTF1_SW_TRG_MUX;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tdata |= MDP5_SPLIT_DPL_UPPER_SMART_PANEL;\n\n\tdev = &mdp5_kms->pdev->dev;\n\n\t \n\tpm_runtime_get_sync(dev);\n\tmdp5_write(mdp5_kms, REG_MDP5_SPLIT_DPL_UPPER, data);\n\n\tmdp5_write(mdp5_kms, REG_MDP5_SPLIT_DPL_LOWER,\n\t\t   MDP5_SPLIT_DPL_LOWER_SMART_PANEL);\n\tmdp5_write(mdp5_kms, REG_MDP5_SPLIT_DPL_EN, 1);\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}