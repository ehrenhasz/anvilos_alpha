{
  "module_name": "mdp5_encoder.c",
  "hash_id": "0450998f080e890bb79b7fbad83871cea6c2639ef39544691b69f1d2bb0623b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp5/mdp5_encoder.c",
  "human_readable_source": "\n \n\n#include <drm/drm_crtc.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mdp5_kms.h\"\n\nstatic struct mdp5_kms *get_kms(struct drm_encoder *encoder)\n{\n\tstruct msm_drm_private *priv = encoder->dev->dev_private;\n\treturn to_mdp5_kms(to_mdp_kms(priv->kms));\n}\n\nstatic void mdp5_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tdrm_encoder_cleanup(encoder);\n\tkfree(mdp5_encoder);\n}\n\nstatic const struct drm_encoder_funcs mdp5_encoder_funcs = {\n\t.destroy = mdp5_encoder_destroy,\n};\n\nstatic void mdp5_vid_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t      struct drm_display_mode *mode,\n\t\t\t\t      struct drm_display_mode *adjusted_mode)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tstruct mdp5_kms *mdp5_kms = get_kms(encoder);\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_connector *connector;\n\tint intf = mdp5_encoder->intf->num;\n\tuint32_t dtv_hsync_skew, vsync_period, vsync_len, ctrl_pol;\n\tuint32_t display_v_start, display_v_end;\n\tuint32_t hsync_start_x, hsync_end_x;\n\tuint32_t format = 0x2100;\n\tunsigned long flags;\n\n\tmode = adjusted_mode;\n\n\tDBG(\"set mode: \" DRM_MODE_FMT, DRM_MODE_ARG(mode));\n\n\tctrl_pol = 0;\n\n\t \n\tif (mdp5_encoder->intf->type != INTF_DSI) {\n\t\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\t\tctrl_pol |= MDP5_INTF_POLARITY_CTL_HSYNC_LOW;\n\t\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\t\tctrl_pol |= MDP5_INTF_POLARITY_CTL_VSYNC_LOW;\n\t}\n\t \n\n\tdtv_hsync_skew = 0;   \n\n\t \n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tif (connector->encoder == encoder) {\n\t\t\tswitch (connector->display_info.bpc) {\n\t\t\tcase 4:\n\t\t\t\tformat |= 0;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tformat |= 0x15;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tformat |= 0x2A;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\tdefault:\n\t\t\t\tformat |= 0x3F;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thsync_start_x = (mode->htotal - mode->hsync_start);\n\thsync_end_x = mode->htotal - (mode->hsync_start - mode->hdisplay) - 1;\n\n\tvsync_period = mode->vtotal * mode->htotal;\n\tvsync_len = (mode->vsync_end - mode->vsync_start) * mode->htotal;\n\tdisplay_v_start = (mode->vtotal - mode->vsync_start) * mode->htotal + dtv_hsync_skew;\n\tdisplay_v_end = vsync_period - ((mode->vsync_start - mode->vdisplay) * mode->htotal) + dtv_hsync_skew - 1;\n\n\t \n\tif (mdp5_encoder->intf->type == INTF_eDP) {\n\t\tdisplay_v_start += mode->htotal - mode->hsync_start;\n\t\tdisplay_v_end -= mode->hsync_start - mode->hdisplay;\n\t}\n\n\tspin_lock_irqsave(&mdp5_encoder->intf_lock, flags);\n\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_HSYNC_CTL(intf),\n\t\t\tMDP5_INTF_HSYNC_CTL_PULSEW(mode->hsync_end - mode->hsync_start) |\n\t\t\tMDP5_INTF_HSYNC_CTL_PERIOD(mode->htotal));\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_VSYNC_PERIOD_F0(intf), vsync_period);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_VSYNC_LEN_F0(intf), vsync_len);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_DISPLAY_HCTL(intf),\n\t\t\tMDP5_INTF_DISPLAY_HCTL_START(hsync_start_x) |\n\t\t\tMDP5_INTF_DISPLAY_HCTL_END(hsync_end_x));\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_DISPLAY_VSTART_F0(intf), display_v_start);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_DISPLAY_VEND_F0(intf), display_v_end);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_BORDER_COLOR(intf), 0);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_UNDERFLOW_COLOR(intf), 0xff);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_HSYNC_SKEW(intf), dtv_hsync_skew);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_POLARITY_CTL(intf), ctrl_pol);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_ACTIVE_HCTL(intf),\n\t\t\tMDP5_INTF_ACTIVE_HCTL_START(0) |\n\t\t\tMDP5_INTF_ACTIVE_HCTL_END(0));\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_ACTIVE_VSTART_F0(intf), 0);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_ACTIVE_VEND_F0(intf), 0);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_PANEL_FORMAT(intf), format);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_FRAME_LINE_COUNT_EN(intf), 0x3);   \n\n\tspin_unlock_irqrestore(&mdp5_encoder->intf_lock, flags);\n\n\tmdp5_crtc_set_pipeline(encoder->crtc);\n}\n\nstatic void mdp5_vid_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tstruct mdp5_kms *mdp5_kms = get_kms(encoder);\n\tstruct mdp5_ctl *ctl = mdp5_encoder->ctl;\n\tstruct mdp5_pipeline *pipeline = mdp5_crtc_get_pipeline(encoder->crtc);\n\tstruct mdp5_hw_mixer *mixer = mdp5_crtc_get_mixer(encoder->crtc);\n\tstruct mdp5_interface *intf = mdp5_encoder->intf;\n\tint intfn = mdp5_encoder->intf->num;\n\tunsigned long flags;\n\n\tif (WARN_ON(!mdp5_encoder->enabled))\n\t\treturn;\n\n\tmdp5_ctl_set_encoder_state(ctl, pipeline, false);\n\n\tspin_lock_irqsave(&mdp5_encoder->intf_lock, flags);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_TIMING_ENGINE_EN(intfn), 0);\n\tspin_unlock_irqrestore(&mdp5_encoder->intf_lock, flags);\n\tmdp5_ctl_commit(ctl, pipeline, mdp_ctl_flush_mask_encoder(intf), true);\n\n\t \n\tmdp_irq_wait(&mdp5_kms->base, intf2vblank(mixer, intf));\n\n\tmdp5_encoder->enabled = false;\n}\n\nstatic void mdp5_vid_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tstruct mdp5_kms *mdp5_kms = get_kms(encoder);\n\tstruct mdp5_ctl *ctl = mdp5_encoder->ctl;\n\tstruct mdp5_interface *intf = mdp5_encoder->intf;\n\tstruct mdp5_pipeline *pipeline = mdp5_crtc_get_pipeline(encoder->crtc);\n\tint intfn = intf->num;\n\tunsigned long flags;\n\n\tif (WARN_ON(mdp5_encoder->enabled))\n\t\treturn;\n\n\tspin_lock_irqsave(&mdp5_encoder->intf_lock, flags);\n\tmdp5_write(mdp5_kms, REG_MDP5_INTF_TIMING_ENGINE_EN(intfn), 1);\n\tspin_unlock_irqrestore(&mdp5_encoder->intf_lock, flags);\n\tmdp5_ctl_commit(ctl, pipeline, mdp_ctl_flush_mask_encoder(intf), true);\n\n\tmdp5_ctl_set_encoder_state(ctl, pipeline, true);\n\n\tmdp5_encoder->enabled = true;\n}\n\nstatic void mdp5_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t  struct drm_display_mode *mode,\n\t\t\t\t  struct drm_display_mode *adjusted_mode)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tstruct mdp5_interface *intf = mdp5_encoder->intf;\n\n\tif (intf->mode == MDP5_INTF_DSI_MODE_COMMAND)\n\t\tmdp5_cmd_encoder_mode_set(encoder, mode, adjusted_mode);\n\telse\n\t\tmdp5_vid_encoder_mode_set(encoder, mode, adjusted_mode);\n}\n\nstatic void mdp5_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tstruct mdp5_interface *intf = mdp5_encoder->intf;\n\n\tif (intf->mode == MDP5_INTF_DSI_MODE_COMMAND)\n\t\tmdp5_cmd_encoder_disable(encoder);\n\telse\n\t\tmdp5_vid_encoder_disable(encoder);\n}\n\nstatic void mdp5_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tstruct mdp5_interface *intf = mdp5_encoder->intf;\n\t \n\tstruct drm_crtc_state *cstate = encoder->crtc->state;\n\n\tmdp5_encoder_mode_set(encoder, &cstate->mode, &cstate->adjusted_mode);\n\n\tif (intf->mode == MDP5_INTF_DSI_MODE_COMMAND)\n\t\tmdp5_cmd_encoder_enable(encoder);\n\telse\n\t\tmdp5_vid_encoder_enable(encoder);\n}\n\nstatic int mdp5_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tstruct mdp5_crtc_state *mdp5_cstate = to_mdp5_crtc_state(crtc_state);\n\tstruct mdp5_interface *intf = mdp5_encoder->intf;\n\tstruct mdp5_ctl *ctl = mdp5_encoder->ctl;\n\n\tmdp5_cstate->ctl = ctl;\n\tmdp5_cstate->pipeline.intf = intf;\n\n\t \n\tif (drm_atomic_crtc_needs_modeset(crtc_state))\n\t\tmdp5_cstate->defer_start = true;\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_helper_funcs mdp5_encoder_helper_funcs = {\n\t.disable = mdp5_encoder_disable,\n\t.enable = mdp5_encoder_enable,\n\t.atomic_check = mdp5_encoder_atomic_check,\n};\n\nint mdp5_encoder_get_linecount(struct drm_encoder *encoder)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tstruct mdp5_kms *mdp5_kms = get_kms(encoder);\n\tint intf = mdp5_encoder->intf->num;\n\n\treturn mdp5_read(mdp5_kms, REG_MDP5_INTF_LINE_COUNT(intf));\n}\n\nu32 mdp5_encoder_get_framecount(struct drm_encoder *encoder)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tstruct mdp5_kms *mdp5_kms = get_kms(encoder);\n\tint intf = mdp5_encoder->intf->num;\n\n\treturn mdp5_read(mdp5_kms, REG_MDP5_INTF_FRAME_COUNT(intf));\n}\n\nint mdp5_vid_encoder_set_split_display(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_encoder *slave_encoder)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tstruct mdp5_encoder *mdp5_slave_enc = to_mdp5_encoder(slave_encoder);\n\tstruct mdp5_kms *mdp5_kms;\n\tstruct device *dev;\n\tint intf_num;\n\tu32 data = 0;\n\n\tif (!encoder || !slave_encoder)\n\t\treturn -EINVAL;\n\n\tmdp5_kms = get_kms(encoder);\n\tintf_num = mdp5_encoder->intf->num;\n\n\t \n\tif (intf_num == 1)\n\t\tdata |= MDP5_SPLIT_DPL_LOWER_INTF2_TG_SYNC;\n\telse if (intf_num == 2)\n\t\tdata |= MDP5_SPLIT_DPL_LOWER_INTF1_TG_SYNC;\n\telse\n\t\treturn -EINVAL;\n\n\tdev = &mdp5_kms->pdev->dev;\n\t \n\tpm_runtime_get_sync(dev);\n\n\t \n\tmdp5_write(mdp5_kms, REG_MDP5_SPLIT_DPL_UPPER, 0);\n\tmdp5_write(mdp5_kms, REG_MDP5_SPLIT_DPL_LOWER, data);\n\tmdp5_write(mdp5_kms, REG_MDP5_SPLIT_DPL_EN, 1);\n\n\tmdp5_ctl_pair(mdp5_encoder->ctl, mdp5_slave_enc->ctl, true);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nvoid mdp5_encoder_set_intf_mode(struct drm_encoder *encoder, bool cmd_mode)\n{\n\tstruct mdp5_encoder *mdp5_encoder = to_mdp5_encoder(encoder);\n\tstruct mdp5_interface *intf = mdp5_encoder->intf;\n\n\t \n\tif (cmd_mode) {\n\t\tWARN_ON(intf->type != INTF_DSI);\n\t\tintf->mode = MDP5_INTF_DSI_MODE_COMMAND;\n\t} else {\n\t\tif (intf->type == INTF_DSI)\n\t\t\tintf->mode = MDP5_INTF_DSI_MODE_VIDEO;\n\t\telse\n\t\t\tintf->mode = MDP5_INTF_MODE_NONE;\n\t}\n}\n\n \nstruct drm_encoder *mdp5_encoder_init(struct drm_device *dev,\n\t\t\t\t      struct mdp5_interface *intf,\n\t\t\t\t      struct mdp5_ctl *ctl)\n{\n\tstruct drm_encoder *encoder = NULL;\n\tstruct mdp5_encoder *mdp5_encoder;\n\tint enc_type = (intf->type == INTF_DSI) ?\n\t\tDRM_MODE_ENCODER_DSI : DRM_MODE_ENCODER_TMDS;\n\tint ret;\n\n\tmdp5_encoder = kzalloc(sizeof(*mdp5_encoder), GFP_KERNEL);\n\tif (!mdp5_encoder) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tencoder = &mdp5_encoder->base;\n\tmdp5_encoder->ctl = ctl;\n\tmdp5_encoder->intf = intf;\n\n\tspin_lock_init(&mdp5_encoder->intf_lock);\n\n\tdrm_encoder_init(dev, encoder, &mdp5_encoder_funcs, enc_type, NULL);\n\n\tdrm_encoder_helper_add(encoder, &mdp5_encoder_helper_funcs);\n\n\treturn encoder;\n\nfail:\n\tif (encoder)\n\t\tmdp5_encoder_destroy(encoder);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}