{
  "module_name": "mdp5_pipe.c",
  "hash_id": "bfd41f0d4b0f11d1fe7ae53e1060067f391a449a7c77ca285bd800bd7d12505e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp5/mdp5_pipe.c",
  "human_readable_source": "\n \n\n#include \"mdp5_kms.h\"\n\nint mdp5_pipe_assign(struct drm_atomic_state *s, struct drm_plane *plane,\n\t\t     uint32_t caps, uint32_t blkcfg,\n\t\t     struct mdp5_hw_pipe **hwpipe,\n\t\t     struct mdp5_hw_pipe **r_hwpipe)\n{\n\tstruct msm_drm_private *priv = s->dev->dev_private;\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(priv->kms));\n\tstruct mdp5_global_state *new_global_state, *old_global_state;\n\tstruct mdp5_hw_pipe_state *old_state, *new_state;\n\tint i, j;\n\n\tnew_global_state = mdp5_get_global_state(s);\n\tif (IS_ERR(new_global_state))\n\t\treturn PTR_ERR(new_global_state);\n\n\t \n\told_global_state = mdp5_get_existing_global_state(mdp5_kms);\n\n\told_state = &old_global_state->hwpipe;\n\tnew_state = &new_global_state->hwpipe;\n\n\tfor (i = 0; i < mdp5_kms->num_hwpipes; i++) {\n\t\tstruct mdp5_hw_pipe *cur = mdp5_kms->hwpipes[i];\n\n\t\t \n\t\tif (new_state->hwpipe_to_plane[cur->idx] ||\n\t\t\t\told_state->hwpipe_to_plane[cur->idx])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (caps & ~cur->caps)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (cur->caps & MDP_PIPE_CAP_CURSOR &&\n\t\t\t\tplane->type != DRM_PLANE_TYPE_CURSOR)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(*hwpipe) || (hweight_long(cur->caps & ~caps) <\n\t\t\t\t   hweight_long((*hwpipe)->caps & ~caps))) {\n\t\t\tbool r_found = false;\n\n\t\t\tif (r_hwpipe) {\n\t\t\t\tfor (j = i + 1; j < mdp5_kms->num_hwpipes;\n\t\t\t\t     j++) {\n\t\t\t\t\tstruct mdp5_hw_pipe *r_cur =\n\t\t\t\t\t\t\tmdp5_kms->hwpipes[j];\n\n\t\t\t\t\t \n\t\t\t\t\tif (r_cur->caps != cur->caps)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t \n\t\t\t\t\tif (cur->pipe > r_cur->pipe)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t*r_hwpipe = r_cur;\n\t\t\t\t\tr_found = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!r_hwpipe || r_found)\n\t\t\t\t*hwpipe = cur;\n\t\t}\n\t}\n\n\tif (!(*hwpipe))\n\t\treturn -ENOMEM;\n\n\tif (r_hwpipe && !(*r_hwpipe))\n\t\treturn -ENOMEM;\n\n\tif (mdp5_kms->smp) {\n\t\tint ret;\n\n\t\t \n\t\tWARN_ON(r_hwpipe);\n\n\t\tDBG(\"%s: alloc SMP blocks\", (*hwpipe)->name);\n\t\tret = mdp5_smp_assign(mdp5_kms->smp, &new_global_state->smp,\n\t\t\t\t(*hwpipe)->pipe, blkcfg);\n\t\tif (ret)\n\t\t\treturn -ENOMEM;\n\n\t\t(*hwpipe)->blkcfg = blkcfg;\n\t}\n\n\tDBG(\"%s: assign to plane %s for caps %x\",\n\t\t\t(*hwpipe)->name, plane->name, caps);\n\tnew_state->hwpipe_to_plane[(*hwpipe)->idx] = plane;\n\n\tif (r_hwpipe) {\n\t\tDBG(\"%s: assign to right of plane %s for caps %x\",\n\t\t    (*r_hwpipe)->name, plane->name, caps);\n\t\tnew_state->hwpipe_to_plane[(*r_hwpipe)->idx] = plane;\n\t}\n\n\treturn 0;\n}\n\nint mdp5_pipe_release(struct drm_atomic_state *s, struct mdp5_hw_pipe *hwpipe)\n{\n\tstruct msm_drm_private *priv = s->dev->dev_private;\n\tstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(priv->kms));\n\tstruct mdp5_global_state *state;\n\tstruct mdp5_hw_pipe_state *new_state;\n\n\tif (!hwpipe)\n\t\treturn 0;\n\n\tstate = mdp5_get_global_state(s);\n\tif (IS_ERR(state))\n\t\treturn PTR_ERR(state);\n\n\tnew_state = &state->hwpipe;\n\n\tif (WARN_ON(!new_state->hwpipe_to_plane[hwpipe->idx]))\n\t\treturn -EINVAL;\n\n\tDBG(\"%s: release from plane %s\", hwpipe->name,\n\t\tnew_state->hwpipe_to_plane[hwpipe->idx]->name);\n\n\tif (mdp5_kms->smp) {\n\t\tDBG(\"%s: free SMP blocks\", hwpipe->name);\n\t\tmdp5_smp_release(mdp5_kms->smp, &state->smp, hwpipe->pipe);\n\t}\n\n\tnew_state->hwpipe_to_plane[hwpipe->idx] = NULL;\n\n\treturn 0;\n}\n\nvoid mdp5_pipe_destroy(struct mdp5_hw_pipe *hwpipe)\n{\n\tkfree(hwpipe);\n}\n\nstruct mdp5_hw_pipe *mdp5_pipe_init(enum mdp5_pipe pipe,\n\t\tuint32_t reg_offset, uint32_t caps)\n{\n\tstruct mdp5_hw_pipe *hwpipe;\n\n\thwpipe = kzalloc(sizeof(*hwpipe), GFP_KERNEL);\n\tif (!hwpipe)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thwpipe->name = pipe2name(pipe);\n\thwpipe->pipe = pipe;\n\thwpipe->reg_offset = reg_offset;\n\thwpipe->caps = caps;\n\thwpipe->flush_mask = mdp_ctl_flush_mask_pipe(pipe);\n\n\treturn hwpipe;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}