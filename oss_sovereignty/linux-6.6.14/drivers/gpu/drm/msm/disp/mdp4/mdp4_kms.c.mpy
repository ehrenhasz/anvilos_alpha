{
  "module_name": "mdp4_kms.c",
  "hash_id": "ba1e722fa3e380c04fb9ec96f2f479922d1d8e8bad1492ebe574fe918270db6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp4/mdp4_kms.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include <drm/drm_vblank.h>\n\n#include \"msm_drv.h\"\n#include \"msm_gem.h\"\n#include \"msm_mmu.h\"\n#include \"mdp4_kms.h\"\n\nstatic int mdp4_hw_init(struct msm_kms *kms)\n{\n\tstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\n\tstruct drm_device *dev = mdp4_kms->dev;\n\tu32 dmap_cfg, vg_cfg;\n\tunsigned long clk;\n\n\tpm_runtime_get_sync(dev->dev);\n\n\tif (mdp4_kms->rev > 1) {\n\t\tmdp4_write(mdp4_kms, REG_MDP4_CS_CONTROLLER0, 0x0707ffff);\n\t\tmdp4_write(mdp4_kms, REG_MDP4_CS_CONTROLLER1, 0x03073f3f);\n\t}\n\n\tmdp4_write(mdp4_kms, REG_MDP4_PORTMAP_MODE, 0x3);\n\n\t \n\tmdp4_write(mdp4_kms, REG_MDP4_READ_CNFG, 0x02222);\n\n\tclk = clk_get_rate(mdp4_kms->clk);\n\n\tif ((mdp4_kms->rev >= 1) || (clk >= 90000000)) {\n\t\tdmap_cfg = 0x47;      \n\t\tvg_cfg = 0x47;        \n\t} else {\n\t\tdmap_cfg = 0x27;      \n\t\tvg_cfg = 0x43;        \n\t}\n\n\tDBG(\"fetch config: dmap=%02x, vg=%02x\", dmap_cfg, vg_cfg);\n\n\tmdp4_write(mdp4_kms, REG_MDP4_DMA_FETCH_CONFIG(DMA_P), dmap_cfg);\n\tmdp4_write(mdp4_kms, REG_MDP4_DMA_FETCH_CONFIG(DMA_E), dmap_cfg);\n\n\tmdp4_write(mdp4_kms, REG_MDP4_PIPE_FETCH_CONFIG(VG1), vg_cfg);\n\tmdp4_write(mdp4_kms, REG_MDP4_PIPE_FETCH_CONFIG(VG2), vg_cfg);\n\tmdp4_write(mdp4_kms, REG_MDP4_PIPE_FETCH_CONFIG(RGB1), vg_cfg);\n\tmdp4_write(mdp4_kms, REG_MDP4_PIPE_FETCH_CONFIG(RGB2), vg_cfg);\n\n\tif (mdp4_kms->rev >= 2)\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LAYERMIXER_IN_CFG_UPDATE_METHOD, 1);\n\tmdp4_write(mdp4_kms, REG_MDP4_LAYERMIXER_IN_CFG, 0);\n\n\t \n\tmdp4_write(mdp4_kms, REG_MDP4_PIPE_OP_MODE(VG1), 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_PIPE_OP_MODE(VG2), 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_DMA_P_OP_MODE, 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_DMA_S_OP_MODE, 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_CSC_CONFIG(1), 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_CSC_CONFIG(2), 0);\n\n\tif (mdp4_kms->rev > 1)\n\t\tmdp4_write(mdp4_kms, REG_MDP4_RESET_STATUS, 1);\n\n\tpm_runtime_put_sync(dev->dev);\n\n\treturn 0;\n}\n\nstatic void mdp4_enable_commit(struct msm_kms *kms)\n{\n\tstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\n\tmdp4_enable(mdp4_kms);\n}\n\nstatic void mdp4_disable_commit(struct msm_kms *kms)\n{\n\tstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\n\tmdp4_disable(mdp4_kms);\n}\n\nstatic void mdp4_flush_commit(struct msm_kms *kms, unsigned crtc_mask)\n{\n\t \n}\n\nstatic void mdp4_wait_flush(struct msm_kms *kms, unsigned crtc_mask)\n{\n\tstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\n\tstruct drm_crtc *crtc;\n\n\tfor_each_crtc_mask(mdp4_kms->dev, crtc, crtc_mask)\n\t\tmdp4_crtc_wait_for_commit_done(crtc);\n}\n\nstatic void mdp4_complete_commit(struct msm_kms *kms, unsigned crtc_mask)\n{\n}\n\nstatic long mdp4_round_pixclk(struct msm_kms *kms, unsigned long rate,\n\t\tstruct drm_encoder *encoder)\n{\n\t \n\tswitch (encoder->encoder_type) {\n\tcase DRM_MODE_ENCODER_TMDS:\n\t\treturn mdp4_dtv_round_pixclk(encoder, rate);\n\tcase DRM_MODE_ENCODER_LVDS:\n\tcase DRM_MODE_ENCODER_DSI:\n\tdefault:\n\t\treturn rate;\n\t}\n}\n\nstatic void mdp4_destroy(struct msm_kms *kms)\n{\n\tstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\n\tstruct device *dev = mdp4_kms->dev->dev;\n\tstruct msm_gem_address_space *aspace = kms->aspace;\n\n\tif (mdp4_kms->blank_cursor_iova)\n\t\tmsm_gem_unpin_iova(mdp4_kms->blank_cursor_bo, kms->aspace);\n\tdrm_gem_object_put(mdp4_kms->blank_cursor_bo);\n\n\tif (aspace) {\n\t\taspace->mmu->funcs->detach(aspace->mmu);\n\t\tmsm_gem_address_space_put(aspace);\n\t}\n\n\tif (mdp4_kms->rpm_enabled)\n\t\tpm_runtime_disable(dev);\n\n\tmdp_kms_destroy(&mdp4_kms->base);\n\n\tkfree(mdp4_kms);\n}\n\nstatic const struct mdp_kms_funcs kms_funcs = {\n\t.base = {\n\t\t.hw_init         = mdp4_hw_init,\n\t\t.irq_preinstall  = mdp4_irq_preinstall,\n\t\t.irq_postinstall = mdp4_irq_postinstall,\n\t\t.irq_uninstall   = mdp4_irq_uninstall,\n\t\t.irq             = mdp4_irq,\n\t\t.enable_vblank   = mdp4_enable_vblank,\n\t\t.disable_vblank  = mdp4_disable_vblank,\n\t\t.enable_commit   = mdp4_enable_commit,\n\t\t.disable_commit  = mdp4_disable_commit,\n\t\t.flush_commit    = mdp4_flush_commit,\n\t\t.wait_flush      = mdp4_wait_flush,\n\t\t.complete_commit = mdp4_complete_commit,\n\t\t.get_format      = mdp_get_format,\n\t\t.round_pixclk    = mdp4_round_pixclk,\n\t\t.destroy         = mdp4_destroy,\n\t},\n\t.set_irqmask         = mdp4_set_irqmask,\n};\n\nint mdp4_disable(struct mdp4_kms *mdp4_kms)\n{\n\tDBG(\"\");\n\n\tclk_disable_unprepare(mdp4_kms->clk);\n\tclk_disable_unprepare(mdp4_kms->pclk);\n\tclk_disable_unprepare(mdp4_kms->lut_clk);\n\tclk_disable_unprepare(mdp4_kms->axi_clk);\n\n\treturn 0;\n}\n\nint mdp4_enable(struct mdp4_kms *mdp4_kms)\n{\n\tDBG(\"\");\n\n\tclk_prepare_enable(mdp4_kms->clk);\n\tclk_prepare_enable(mdp4_kms->pclk);\n\tclk_prepare_enable(mdp4_kms->lut_clk);\n\tclk_prepare_enable(mdp4_kms->axi_clk);\n\n\treturn 0;\n}\n\n\nstatic int mdp4_modeset_init_intf(struct mdp4_kms *mdp4_kms,\n\t\t\t\t  int intf_type)\n{\n\tstruct drm_device *dev = mdp4_kms->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tstruct device_node *panel_node;\n\tint dsi_id;\n\tint ret;\n\n\tswitch (intf_type) {\n\tcase DRM_MODE_ENCODER_LVDS:\n\t\t \n\t\tpanel_node = of_graph_get_remote_node(dev->dev->of_node, 0, 0);\n\t\tif (!panel_node)\n\t\t\treturn 0;\n\n\t\tencoder = mdp4_lcdc_encoder_init(dev, panel_node);\n\t\tif (IS_ERR(encoder)) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to construct LCDC encoder\\n\");\n\t\t\tof_node_put(panel_node);\n\t\t\treturn PTR_ERR(encoder);\n\t\t}\n\n\t\t \n\t\tencoder->possible_crtcs = 1 << DMA_P;\n\n\t\tconnector = mdp4_lvds_connector_init(dev, panel_node, encoder);\n\t\tif (IS_ERR(connector)) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to initialize LVDS connector\\n\");\n\t\t\tof_node_put(panel_node);\n\t\t\treturn PTR_ERR(connector);\n\t\t}\n\n\t\tbreak;\n\tcase DRM_MODE_ENCODER_TMDS:\n\t\tencoder = mdp4_dtv_encoder_init(dev);\n\t\tif (IS_ERR(encoder)) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to construct DTV encoder\\n\");\n\t\t\treturn PTR_ERR(encoder);\n\t\t}\n\n\t\t \n\t\tencoder->possible_crtcs = 1 << 1;\n\n\t\tif (priv->hdmi) {\n\t\t\t \n\t\t\tret = msm_hdmi_modeset_init(priv->hdmi, dev, encoder);\n\t\t\tif (ret) {\n\t\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to initialize HDMI: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tcase DRM_MODE_ENCODER_DSI:\n\t\t \n\t\tdsi_id = 0;\n\n\t\tif (!priv->dsi[dsi_id])\n\t\t\tbreak;\n\n\t\tencoder = mdp4_dsi_encoder_init(dev);\n\t\tif (IS_ERR(encoder)) {\n\t\t\tret = PTR_ERR(encoder);\n\t\t\tDRM_DEV_ERROR(dev->dev,\n\t\t\t\t\"failed to construct DSI encoder: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tencoder->possible_crtcs = 1 << DMA_P;\n\n\t\tret = msm_dsi_modeset_init(priv->dsi[dsi_id], dev, encoder);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to initialize DSI: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEV_ERROR(dev->dev, \"Invalid or unsupported interface\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int modeset_init(struct mdp4_kms *mdp4_kms)\n{\n\tstruct drm_device *dev = mdp4_kms->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct drm_plane *plane;\n\tstruct drm_crtc *crtc;\n\tint i, ret;\n\tstatic const enum mdp4_pipe rgb_planes[] = {\n\t\tRGB1, RGB2,\n\t};\n\tstatic const enum mdp4_pipe vg_planes[] = {\n\t\tVG1, VG2,\n\t};\n\tstatic const enum mdp4_dma mdp4_crtcs[] = {\n\t\tDMA_P, DMA_E,\n\t};\n\tstatic const char * const mdp4_crtc_names[] = {\n\t\t\"DMA_P\", \"DMA_E\",\n\t};\n\tstatic const int mdp4_intfs[] = {\n\t\tDRM_MODE_ENCODER_LVDS,\n\t\tDRM_MODE_ENCODER_DSI,\n\t\tDRM_MODE_ENCODER_TMDS,\n\t};\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vg_planes); i++) {\n\t\tplane = mdp4_plane_init(dev, vg_planes[i], false);\n\t\tif (IS_ERR(plane)) {\n\t\t\tDRM_DEV_ERROR(dev->dev,\n\t\t\t\t\"failed to construct plane for VG%d\\n\", i + 1);\n\t\t\tret = PTR_ERR(plane);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mdp4_crtcs); i++) {\n\t\tplane = mdp4_plane_init(dev, rgb_planes[i], true);\n\t\tif (IS_ERR(plane)) {\n\t\t\tDRM_DEV_ERROR(dev->dev,\n\t\t\t\t\"failed to construct plane for RGB%d\\n\", i + 1);\n\t\t\tret = PTR_ERR(plane);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tcrtc  = mdp4_crtc_init(dev, plane, priv->num_crtcs, i,\n\t\t\t\tmdp4_crtcs[i]);\n\t\tif (IS_ERR(crtc)) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to construct crtc for %s\\n\",\n\t\t\t\tmdp4_crtc_names[i]);\n\t\t\tret = PTR_ERR(crtc);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpriv->num_crtcs++;\n\t}\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(mdp4_intfs); i++) {\n\t\tret = mdp4_modeset_init_intf(mdp4_kms, mdp4_intfs[i]);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to initialize intf: %d, %d\\n\",\n\t\t\t\ti, ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail:\n\treturn ret;\n}\n\nstatic void read_mdp_hw_revision(struct mdp4_kms *mdp4_kms,\n\t\t\t\t u32 *major, u32 *minor)\n{\n\tstruct drm_device *dev = mdp4_kms->dev;\n\tu32 version;\n\n\tmdp4_enable(mdp4_kms);\n\tversion = mdp4_read(mdp4_kms, REG_MDP4_VERSION);\n\tmdp4_disable(mdp4_kms);\n\n\t*major = FIELD(version, MDP4_VERSION_MAJOR);\n\t*minor = FIELD(version, MDP4_VERSION_MINOR);\n\n\tDRM_DEV_INFO(dev->dev, \"MDP4 version v%d.%d\", *major, *minor);\n}\n\nstatic int mdp4_kms_init(struct drm_device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev->dev);\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct mdp4_kms *mdp4_kms;\n\tstruct msm_kms *kms = NULL;\n\tstruct msm_mmu *mmu;\n\tstruct msm_gem_address_space *aspace;\n\tint irq, ret;\n\tu32 major, minor;\n\tunsigned long max_clk;\n\n\t \n\tmax_clk = 266667000;\n\n\tmdp4_kms = kzalloc(sizeof(*mdp4_kms), GFP_KERNEL);\n\tif (!mdp4_kms) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to allocate kms\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = mdp_kms_init(&mdp4_kms->base, &kms_funcs);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to init kms\\n\");\n\t\tgoto fail;\n\t}\n\n\tpriv->kms = &mdp4_kms->base.base;\n\tkms = priv->kms;\n\n\tmdp4_kms->dev = dev;\n\n\tmdp4_kms->mmio = msm_ioremap(pdev, NULL);\n\tif (IS_ERR(mdp4_kms->mmio)) {\n\t\tret = PTR_ERR(mdp4_kms->mmio);\n\t\tgoto fail;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto fail;\n\t}\n\n\tkms->irq = irq;\n\n\t \n\tmdp4_kms->vdd = devm_regulator_get_exclusive(&pdev->dev, \"vdd\");\n\tif (IS_ERR(mdp4_kms->vdd))\n\t\tmdp4_kms->vdd = NULL;\n\n\tif (mdp4_kms->vdd) {\n\t\tret = regulator_enable(mdp4_kms->vdd);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to enable regulator vdd: %d\\n\", ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tmdp4_kms->clk = devm_clk_get(&pdev->dev, \"core_clk\");\n\tif (IS_ERR(mdp4_kms->clk)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to get core_clk\\n\");\n\t\tret = PTR_ERR(mdp4_kms->clk);\n\t\tgoto fail;\n\t}\n\n\tmdp4_kms->pclk = devm_clk_get(&pdev->dev, \"iface_clk\");\n\tif (IS_ERR(mdp4_kms->pclk))\n\t\tmdp4_kms->pclk = NULL;\n\n\tmdp4_kms->axi_clk = devm_clk_get(&pdev->dev, \"bus_clk\");\n\tif (IS_ERR(mdp4_kms->axi_clk)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to get axi_clk\\n\");\n\t\tret = PTR_ERR(mdp4_kms->axi_clk);\n\t\tgoto fail;\n\t}\n\n\tclk_set_rate(mdp4_kms->clk, max_clk);\n\n\tread_mdp_hw_revision(mdp4_kms, &major, &minor);\n\n\tif (major != 4) {\n\t\tDRM_DEV_ERROR(dev->dev, \"unexpected MDP version: v%d.%d\\n\",\n\t\t\t      major, minor);\n\t\tret = -ENXIO;\n\t\tgoto fail;\n\t}\n\n\tmdp4_kms->rev = minor;\n\n\tif (mdp4_kms->rev >= 2) {\n\t\tmdp4_kms->lut_clk = devm_clk_get(&pdev->dev, \"lut_clk\");\n\t\tif (IS_ERR(mdp4_kms->lut_clk)) {\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to get lut_clk\\n\");\n\t\t\tret = PTR_ERR(mdp4_kms->lut_clk);\n\t\t\tgoto fail;\n\t\t}\n\t\tclk_set_rate(mdp4_kms->lut_clk, max_clk);\n\t}\n\n\tpm_runtime_enable(dev->dev);\n\tmdp4_kms->rpm_enabled = true;\n\n\t \n\tmdp4_enable(mdp4_kms);\n\tmdp4_write(mdp4_kms, REG_MDP4_DTV_ENABLE, 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_ENABLE, 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_ENABLE, 0);\n\tmdp4_disable(mdp4_kms);\n\tmdelay(16);\n\n\tmmu = msm_iommu_new(&pdev->dev, 0);\n\tif (IS_ERR(mmu)) {\n\t\tret = PTR_ERR(mmu);\n\t\tgoto fail;\n\t} else if (!mmu) {\n\t\tDRM_DEV_INFO(dev->dev, \"no iommu, fallback to phys \"\n\t\t\t\t\"contig buffers for scanout\\n\");\n\t\taspace = NULL;\n\t} else {\n\t\taspace  = msm_gem_address_space_create(mmu,\n\t\t\t\"mdp4\", 0x1000, 0x100000000 - 0x1000);\n\n\t\tif (IS_ERR(aspace)) {\n\t\t\tif (!IS_ERR(mmu))\n\t\t\t\tmmu->funcs->destroy(mmu);\n\t\t\tret = PTR_ERR(aspace);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tkms->aspace = aspace;\n\t}\n\n\tret = modeset_init(mdp4_kms);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev->dev, \"modeset_init failed: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tmdp4_kms->blank_cursor_bo = msm_gem_new(dev, SZ_16K, MSM_BO_WC | MSM_BO_SCANOUT);\n\tif (IS_ERR(mdp4_kms->blank_cursor_bo)) {\n\t\tret = PTR_ERR(mdp4_kms->blank_cursor_bo);\n\t\tDRM_DEV_ERROR(dev->dev, \"could not allocate blank-cursor bo: %d\\n\", ret);\n\t\tmdp4_kms->blank_cursor_bo = NULL;\n\t\tgoto fail;\n\t}\n\n\tret = msm_gem_get_and_pin_iova(mdp4_kms->blank_cursor_bo, kms->aspace,\n\t\t\t&mdp4_kms->blank_cursor_iova);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev->dev, \"could not pin blank-cursor bo: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tdev->mode_config.max_width = 2048;\n\tdev->mode_config.max_height = 2048;\n\n\treturn 0;\n\nfail:\n\tif (kms)\n\t\tmdp4_destroy(kms);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops mdp4_pm_ops = {\n\t.prepare = msm_pm_prepare,\n\t.complete = msm_pm_complete,\n};\n\nstatic int mdp4_probe(struct platform_device *pdev)\n{\n\treturn msm_drv_probe(&pdev->dev, mdp4_kms_init);\n}\n\nstatic int mdp4_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &msm_drm_ops);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mdp4_dt_match[] = {\n\t{ .compatible = \"qcom,mdp4\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mdp4_dt_match);\n\nstatic struct platform_driver mdp4_platform_driver = {\n\t.probe      = mdp4_probe,\n\t.remove     = mdp4_remove,\n\t.shutdown   = msm_drv_shutdown,\n\t.driver     = {\n\t\t.name   = \"mdp4\",\n\t\t.of_match_table = mdp4_dt_match,\n\t\t.pm     = &mdp4_pm_ops,\n\t},\n};\n\nvoid __init msm_mdp4_register(void)\n{\n\tplatform_driver_register(&mdp4_platform_driver);\n}\n\nvoid __exit msm_mdp4_unregister(void)\n{\n\tplatform_driver_unregister(&mdp4_platform_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}