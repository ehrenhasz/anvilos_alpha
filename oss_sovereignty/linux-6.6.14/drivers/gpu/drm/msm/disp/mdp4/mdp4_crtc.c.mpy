{
  "module_name": "mdp4_crtc.c",
  "hash_id": "6312789c9dc25ece8333f89aa8e8662b3f7ff18346b11eef8b5f472ba65a406f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp4/mdp4_crtc.c",
  "human_readable_source": "\n \n\n#include <drm/drm_crtc.h>\n#include <drm/drm_flip_work.h>\n#include <drm/drm_mode.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"mdp4_kms.h\"\n#include \"msm_gem.h\"\n\nstruct mdp4_crtc {\n\tstruct drm_crtc base;\n\tchar name[8];\n\tint id;\n\tint ovlp;\n\tenum mdp4_dma dma;\n\tbool enabled;\n\n\t \n\tint mixer;\n\n\tstruct {\n\t\tspinlock_t lock;\n\t\tbool stale;\n\t\tuint32_t width, height;\n\t\tuint32_t x, y;\n\n\t\t \n\t\tuint32_t next_iova;\n\t\tstruct drm_gem_object *next_bo;\n\n\t\t \n\t\tstruct drm_gem_object *scanout_bo;\n\t} cursor;\n\n\n\t \n\tstruct drm_pending_vblank_event *event;\n\n\t \n\tu32 flushed_mask;\n\n#define PENDING_CURSOR 0x1\n#define PENDING_FLIP   0x2\n\tatomic_t pending;\n\n\t \n\tstruct drm_flip_work unref_cursor_work;\n\n\tstruct mdp_irq vblank;\n\tstruct mdp_irq err;\n};\n#define to_mdp4_crtc(x) container_of(x, struct mdp4_crtc, base)\n\nstatic struct mdp4_kms *get_kms(struct drm_crtc *crtc)\n{\n\tstruct msm_drm_private *priv = crtc->dev->dev_private;\n\treturn to_mdp4_kms(to_mdp_kms(priv->kms));\n}\n\nstatic void request_pending(struct drm_crtc *crtc, uint32_t pending)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\n\tatomic_or(pending, &mdp4_crtc->pending);\n\tmdp_irq_register(&get_kms(crtc)->base, &mdp4_crtc->vblank);\n}\n\nstatic void crtc_flush(struct drm_crtc *crtc)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct mdp4_kms *mdp4_kms = get_kms(crtc);\n\tstruct drm_plane *plane;\n\tuint32_t flush = 0;\n\n\tdrm_atomic_crtc_for_each_plane(plane, crtc) {\n\t\tenum mdp4_pipe pipe_id = mdp4_plane_pipe(plane);\n\t\tflush |= pipe2flush(pipe_id);\n\t}\n\n\tflush |= ovlp2flush(mdp4_crtc->ovlp);\n\n\tDBG(\"%s: flush=%08x\", mdp4_crtc->name, flush);\n\n\tmdp4_crtc->flushed_mask = flush;\n\n\tmdp4_write(mdp4_kms, REG_MDP4_OVERLAY_FLUSH, flush);\n}\n\n \nstatic void complete_flip(struct drm_crtc *crtc, struct drm_file *file)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_pending_vblank_event *event;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tevent = mdp4_crtc->event;\n\tif (event) {\n\t\tmdp4_crtc->event = NULL;\n\t\tDBG(\"%s: send event: %p\", mdp4_crtc->name, event);\n\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t}\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\nstatic void unref_cursor_worker(struct drm_flip_work *work, void *val)\n{\n\tstruct mdp4_crtc *mdp4_crtc =\n\t\tcontainer_of(work, struct mdp4_crtc, unref_cursor_work);\n\tstruct mdp4_kms *mdp4_kms = get_kms(&mdp4_crtc->base);\n\tstruct msm_kms *kms = &mdp4_kms->base.base;\n\n\tmsm_gem_unpin_iova(val, kms->aspace);\n\tdrm_gem_object_put(val);\n}\n\nstatic void mdp4_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\n\tdrm_crtc_cleanup(crtc);\n\tdrm_flip_work_cleanup(&mdp4_crtc->unref_cursor_work);\n\n\tkfree(mdp4_crtc);\n}\n\n \nstatic const int idxs[] = {\n\t\t[VG1]  = 1,\n\t\t[VG2]  = 2,\n\t\t[RGB1] = 0,\n\t\t[RGB2] = 0,\n\t\t[RGB3] = 0,\n\t\t[VG3]  = 3,\n\t\t[VG4]  = 4,\n\n};\n\n \nstatic void setup_mixer(struct mdp4_kms *mdp4_kms)\n{\n\tstruct drm_mode_config *config = &mdp4_kms->dev->mode_config;\n\tstruct drm_crtc *crtc;\n\tuint32_t mixer_cfg = 0;\n\tstatic const enum mdp_mixer_stage_id stages[] = {\n\t\t\tSTAGE_BASE, STAGE0, STAGE1, STAGE2, STAGE3,\n\t};\n\n\tlist_for_each_entry(crtc, &config->crtc_list, head) {\n\t\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\t\tstruct drm_plane *plane;\n\n\t\tdrm_atomic_crtc_for_each_plane(plane, crtc) {\n\t\t\tenum mdp4_pipe pipe_id = mdp4_plane_pipe(plane);\n\t\t\tint idx = idxs[pipe_id];\n\t\t\tmixer_cfg = mixercfg(mixer_cfg, mdp4_crtc->mixer,\n\t\t\t\t\tpipe_id, stages[idx]);\n\t\t}\n\t}\n\n\tmdp4_write(mdp4_kms, REG_MDP4_LAYERMIXER_IN_CFG, mixer_cfg);\n}\n\nstatic void blend_setup(struct drm_crtc *crtc)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct mdp4_kms *mdp4_kms = get_kms(crtc);\n\tstruct drm_plane *plane;\n\tint i, ovlp = mdp4_crtc->ovlp;\n\tbool alpha[4]= { false, false, false, false };\n\n\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_TRANSP_LOW0(ovlp), 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_TRANSP_LOW1(ovlp), 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_TRANSP_HIGH0(ovlp), 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_TRANSP_HIGH1(ovlp), 0);\n\n\tdrm_atomic_crtc_for_each_plane(plane, crtc) {\n\t\tenum mdp4_pipe pipe_id = mdp4_plane_pipe(plane);\n\t\tint idx = idxs[pipe_id];\n\t\tif (idx > 0) {\n\t\t\tconst struct mdp_format *format =\n\t\t\t\t\tto_mdp_format(msm_framebuffer_format(plane->state->fb));\n\t\t\talpha[idx-1] = format->alpha_enable;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tuint32_t op;\n\n\t\tif (alpha[i]) {\n\t\t\top = MDP4_OVLP_STAGE_OP_FG_ALPHA(FG_PIXEL) |\n\t\t\t\t\tMDP4_OVLP_STAGE_OP_BG_ALPHA(FG_PIXEL) |\n\t\t\t\t\tMDP4_OVLP_STAGE_OP_BG_INV_ALPHA;\n\t\t} else {\n\t\t\top = MDP4_OVLP_STAGE_OP_FG_ALPHA(FG_CONST) |\n\t\t\t\t\tMDP4_OVLP_STAGE_OP_BG_ALPHA(BG_CONST);\n\t\t}\n\n\t\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_STAGE_FG_ALPHA(ovlp, i), 0xff);\n\t\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_STAGE_BG_ALPHA(ovlp, i), 0x00);\n\t\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_STAGE_OP(ovlp, i), op);\n\t\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_STAGE_CO3(ovlp, i), 1);\n\t\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_STAGE_TRANSP_LOW0(ovlp, i), 0);\n\t\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_STAGE_TRANSP_LOW1(ovlp, i), 0);\n\t\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_STAGE_TRANSP_HIGH0(ovlp, i), 0);\n\t\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_STAGE_TRANSP_HIGH1(ovlp, i), 0);\n\t}\n\n\tsetup_mixer(mdp4_kms);\n}\n\nstatic void mdp4_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct mdp4_kms *mdp4_kms = get_kms(crtc);\n\tenum mdp4_dma dma = mdp4_crtc->dma;\n\tint ovlp = mdp4_crtc->ovlp;\n\tstruct drm_display_mode *mode;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn;\n\n\tmode = &crtc->state->adjusted_mode;\n\n\tDBG(\"%s: set mode: \" DRM_MODE_FMT,\n\t\t\tmdp4_crtc->name, DRM_MODE_ARG(mode));\n\n\tmdp4_write(mdp4_kms, REG_MDP4_DMA_SRC_SIZE(dma),\n\t\t\tMDP4_DMA_SRC_SIZE_WIDTH(mode->hdisplay) |\n\t\t\tMDP4_DMA_SRC_SIZE_HEIGHT(mode->vdisplay));\n\n\t \n\tmdp4_write(mdp4_kms, REG_MDP4_DMA_SRC_BASE(dma), 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_DMA_SRC_STRIDE(dma), 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_DMA_DST_SIZE(dma),\n\t\t\tMDP4_DMA_DST_SIZE_WIDTH(0) |\n\t\t\tMDP4_DMA_DST_SIZE_HEIGHT(0));\n\n\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_BASE(ovlp), 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_SIZE(ovlp),\n\t\t\tMDP4_OVLP_SIZE_WIDTH(mode->hdisplay) |\n\t\t\tMDP4_OVLP_SIZE_HEIGHT(mode->vdisplay));\n\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_STRIDE(ovlp), 0);\n\n\tmdp4_write(mdp4_kms, REG_MDP4_OVLP_CFG(ovlp), 1);\n\n\tif (dma == DMA_E) {\n\t\tmdp4_write(mdp4_kms, REG_MDP4_DMA_E_QUANT(0), 0x00ff0000);\n\t\tmdp4_write(mdp4_kms, REG_MDP4_DMA_E_QUANT(1), 0x00ff0000);\n\t\tmdp4_write(mdp4_kms, REG_MDP4_DMA_E_QUANT(2), 0x00ff0000);\n\t}\n}\n\nstatic void mdp4_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct mdp4_kms *mdp4_kms = get_kms(crtc);\n\tunsigned long flags;\n\n\tDBG(\"%s\", mdp4_crtc->name);\n\n\tif (WARN_ON(!mdp4_crtc->enabled))\n\t\treturn;\n\n\t \n\tdrm_crtc_vblank_off(crtc);\n\n\tmdp_irq_unregister(&mdp4_kms->base, &mdp4_crtc->err);\n\tmdp4_disable(mdp4_kms);\n\n\tif (crtc->state->event && !crtc->state->active) {\n\t\tWARN_ON(mdp4_crtc->event);\n\t\tspin_lock_irqsave(&mdp4_kms->dev->event_lock, flags);\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t\tspin_unlock_irqrestore(&mdp4_kms->dev->event_lock, flags);\n\t}\n\n\tmdp4_crtc->enabled = false;\n}\n\nstatic void mdp4_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct mdp4_kms *mdp4_kms = get_kms(crtc);\n\n\tDBG(\"%s\", mdp4_crtc->name);\n\n\tif (WARN_ON(mdp4_crtc->enabled))\n\t\treturn;\n\n\tmdp4_enable(mdp4_kms);\n\n\t \n\tdrm_crtc_vblank_on(crtc);\n\n\tmdp_irq_register(&mdp4_kms->base, &mdp4_crtc->err);\n\n\tcrtc_flush(crtc);\n\n\tmdp4_crtc->enabled = true;\n}\n\nstatic int mdp4_crtc_atomic_check(struct drm_crtc *crtc,\n\t\tstruct drm_atomic_state *state)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tDBG(\"%s: check\", mdp4_crtc->name);\n\t\n\treturn 0;\n}\n\nstatic void mdp4_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tDBG(\"%s: begin\", mdp4_crtc->name);\n}\n\nstatic void mdp4_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned long flags;\n\n\tDBG(\"%s: event: %p\", mdp4_crtc->name, crtc->state->event);\n\n\tWARN_ON(mdp4_crtc->event);\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tmdp4_crtc->event = crtc->state->event;\n\tcrtc->state->event = NULL;\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\tblend_setup(crtc);\n\tcrtc_flush(crtc);\n\trequest_pending(crtc, PENDING_FLIP);\n}\n\n#define CURSOR_WIDTH 64\n#define CURSOR_HEIGHT 64\n\n \nstatic void update_cursor(struct drm_crtc *crtc)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct mdp4_kms *mdp4_kms = get_kms(crtc);\n\tstruct msm_kms *kms = &mdp4_kms->base.base;\n\tenum mdp4_dma dma = mdp4_crtc->dma;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mdp4_crtc->cursor.lock, flags);\n\tif (mdp4_crtc->cursor.stale) {\n\t\tstruct drm_gem_object *next_bo = mdp4_crtc->cursor.next_bo;\n\t\tstruct drm_gem_object *prev_bo = mdp4_crtc->cursor.scanout_bo;\n\t\tuint64_t iova = mdp4_crtc->cursor.next_iova;\n\n\t\tif (next_bo) {\n\t\t\t \n\t\t\tdrm_gem_object_get(next_bo);\n\t\t\tmsm_gem_get_and_pin_iova(next_bo, kms->aspace, &iova);\n\n\t\t\t \n\t\t\tmdp4_write(mdp4_kms, REG_MDP4_DMA_CURSOR_SIZE(dma),\n\t\t\t\t\tMDP4_DMA_CURSOR_SIZE_WIDTH(mdp4_crtc->cursor.width) |\n\t\t\t\t\tMDP4_DMA_CURSOR_SIZE_HEIGHT(mdp4_crtc->cursor.height));\n\t\t\tmdp4_write(mdp4_kms, REG_MDP4_DMA_CURSOR_BASE(dma), iova);\n\t\t\tmdp4_write(mdp4_kms, REG_MDP4_DMA_CURSOR_BLEND_CONFIG(dma),\n\t\t\t\t\tMDP4_DMA_CURSOR_BLEND_CONFIG_FORMAT(CURSOR_ARGB) |\n\t\t\t\t\tMDP4_DMA_CURSOR_BLEND_CONFIG_CURSOR_EN);\n\t\t} else {\n\t\t\t \n\t\t\tmdp4_write(mdp4_kms, REG_MDP4_DMA_CURSOR_BASE(dma),\n\t\t\t\t\tmdp4_kms->blank_cursor_iova);\n\t\t}\n\n\t\t \n\t\tif (prev_bo)\n\t\t\tdrm_flip_work_queue(&mdp4_crtc->unref_cursor_work, prev_bo);\n\n\t\tmdp4_crtc->cursor.scanout_bo = next_bo;\n\t\tmdp4_crtc->cursor.stale = false;\n\t}\n\n\tmdp4_write(mdp4_kms, REG_MDP4_DMA_CURSOR_POS(dma),\n\t\t\tMDP4_DMA_CURSOR_POS_X(mdp4_crtc->cursor.x) |\n\t\t\tMDP4_DMA_CURSOR_POS_Y(mdp4_crtc->cursor.y));\n\n\tspin_unlock_irqrestore(&mdp4_crtc->cursor.lock, flags);\n}\n\nstatic int mdp4_crtc_cursor_set(struct drm_crtc *crtc,\n\t\tstruct drm_file *file_priv, uint32_t handle,\n\t\tuint32_t width, uint32_t height)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct mdp4_kms *mdp4_kms = get_kms(crtc);\n\tstruct msm_kms *kms = &mdp4_kms->base.base;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_gem_object *cursor_bo, *old_bo;\n\tunsigned long flags;\n\tuint64_t iova;\n\tint ret;\n\n\tif ((width > CURSOR_WIDTH) || (height > CURSOR_HEIGHT)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"bad cursor size: %dx%d\\n\", width, height);\n\t\treturn -EINVAL;\n\t}\n\n\tif (handle) {\n\t\tcursor_bo = drm_gem_object_lookup(file_priv, handle);\n\t\tif (!cursor_bo)\n\t\t\treturn -ENOENT;\n\t} else {\n\t\tcursor_bo = NULL;\n\t}\n\n\tif (cursor_bo) {\n\t\tret = msm_gem_get_and_pin_iova(cursor_bo, kms->aspace, &iova);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t} else {\n\t\tiova = 0;\n\t}\n\n\tspin_lock_irqsave(&mdp4_crtc->cursor.lock, flags);\n\told_bo = mdp4_crtc->cursor.next_bo;\n\tmdp4_crtc->cursor.next_bo   = cursor_bo;\n\tmdp4_crtc->cursor.next_iova = iova;\n\tmdp4_crtc->cursor.width     = width;\n\tmdp4_crtc->cursor.height    = height;\n\tmdp4_crtc->cursor.stale     = true;\n\tspin_unlock_irqrestore(&mdp4_crtc->cursor.lock, flags);\n\n\tif (old_bo) {\n\t\t \n\t\tdrm_flip_work_queue(&mdp4_crtc->unref_cursor_work, old_bo);\n\t}\n\n\trequest_pending(crtc, PENDING_CURSOR);\n\n\treturn 0;\n\nfail:\n\tdrm_gem_object_put(cursor_bo);\n\treturn ret;\n}\n\nstatic int mdp4_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mdp4_crtc->cursor.lock, flags);\n\tmdp4_crtc->cursor.x = x;\n\tmdp4_crtc->cursor.y = y;\n\tspin_unlock_irqrestore(&mdp4_crtc->cursor.lock, flags);\n\n\tcrtc_flush(crtc);\n\trequest_pending(crtc, PENDING_CURSOR);\n\n\treturn 0;\n}\n\nstatic const struct drm_crtc_funcs mdp4_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.destroy = mdp4_crtc_destroy,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.cursor_set = mdp4_crtc_cursor_set,\n\t.cursor_move = mdp4_crtc_cursor_move,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank  = msm_crtc_enable_vblank,\n\t.disable_vblank = msm_crtc_disable_vblank,\n};\n\nstatic const struct drm_crtc_helper_funcs mdp4_crtc_helper_funcs = {\n\t.mode_set_nofb = mdp4_crtc_mode_set_nofb,\n\t.atomic_check = mdp4_crtc_atomic_check,\n\t.atomic_begin = mdp4_crtc_atomic_begin,\n\t.atomic_flush = mdp4_crtc_atomic_flush,\n\t.atomic_enable = mdp4_crtc_atomic_enable,\n\t.atomic_disable = mdp4_crtc_atomic_disable,\n};\n\nstatic void mdp4_crtc_vblank_irq(struct mdp_irq *irq, uint32_t irqstatus)\n{\n\tstruct mdp4_crtc *mdp4_crtc = container_of(irq, struct mdp4_crtc, vblank);\n\tstruct drm_crtc *crtc = &mdp4_crtc->base;\n\tstruct msm_drm_private *priv = crtc->dev->dev_private;\n\tunsigned pending;\n\n\tmdp_irq_unregister(&get_kms(crtc)->base, &mdp4_crtc->vblank);\n\n\tpending = atomic_xchg(&mdp4_crtc->pending, 0);\n\n\tif (pending & PENDING_FLIP) {\n\t\tcomplete_flip(crtc, NULL);\n\t}\n\n\tif (pending & PENDING_CURSOR) {\n\t\tupdate_cursor(crtc);\n\t\tdrm_flip_work_commit(&mdp4_crtc->unref_cursor_work, priv->wq);\n\t}\n}\n\nstatic void mdp4_crtc_err_irq(struct mdp_irq *irq, uint32_t irqstatus)\n{\n\tstruct mdp4_crtc *mdp4_crtc = container_of(irq, struct mdp4_crtc, err);\n\tstruct drm_crtc *crtc = &mdp4_crtc->base;\n\tDBG(\"%s: error: %08x\", mdp4_crtc->name, irqstatus);\n\tcrtc_flush(crtc);\n}\n\nstatic void mdp4_crtc_wait_for_flush_done(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct mdp4_kms *mdp4_kms = get_kms(crtc);\n\tint ret;\n\n\tret = drm_crtc_vblank_get(crtc);\n\tif (ret)\n\t\treturn;\n\n\tret = wait_event_timeout(dev->vblank[drm_crtc_index(crtc)].queue,\n\t\t!(mdp4_read(mdp4_kms, REG_MDP4_OVERLAY_FLUSH) &\n\t\t\tmdp4_crtc->flushed_mask),\n\t\tmsecs_to_jiffies(50));\n\tif (ret <= 0)\n\t\tdev_warn(dev->dev, \"vblank time out, crtc=%d\\n\", mdp4_crtc->id);\n\n\tmdp4_crtc->flushed_mask = 0;\n\n\tdrm_crtc_vblank_put(crtc);\n}\n\nuint32_t mdp4_crtc_vblank(struct drm_crtc *crtc)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\treturn mdp4_crtc->vblank.irqmask;\n}\n\n \nvoid mdp4_crtc_set_config(struct drm_crtc *crtc, uint32_t config)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct mdp4_kms *mdp4_kms = get_kms(crtc);\n\n\tmdp4_write(mdp4_kms, REG_MDP4_DMA_CONFIG(mdp4_crtc->dma), config);\n}\n\n \nvoid mdp4_crtc_set_intf(struct drm_crtc *crtc, enum mdp4_intf intf, int mixer)\n{\n\tstruct mdp4_crtc *mdp4_crtc = to_mdp4_crtc(crtc);\n\tstruct mdp4_kms *mdp4_kms = get_kms(crtc);\n\tuint32_t intf_sel;\n\n\tintf_sel = mdp4_read(mdp4_kms, REG_MDP4_DISP_INTF_SEL);\n\n\tswitch (mdp4_crtc->dma) {\n\tcase DMA_P:\n\t\tintf_sel &= ~MDP4_DISP_INTF_SEL_PRIM__MASK;\n\t\tintf_sel |= MDP4_DISP_INTF_SEL_PRIM(intf);\n\t\tbreak;\n\tcase DMA_S:\n\t\tintf_sel &= ~MDP4_DISP_INTF_SEL_SEC__MASK;\n\t\tintf_sel |= MDP4_DISP_INTF_SEL_SEC(intf);\n\t\tbreak;\n\tcase DMA_E:\n\t\tintf_sel &= ~MDP4_DISP_INTF_SEL_EXT__MASK;\n\t\tintf_sel |= MDP4_DISP_INTF_SEL_EXT(intf);\n\t\tbreak;\n\t}\n\n\tif (intf == INTF_DSI_VIDEO) {\n\t\tintf_sel &= ~MDP4_DISP_INTF_SEL_DSI_CMD;\n\t\tintf_sel |= MDP4_DISP_INTF_SEL_DSI_VIDEO;\n\t} else if (intf == INTF_DSI_CMD) {\n\t\tintf_sel &= ~MDP4_DISP_INTF_SEL_DSI_VIDEO;\n\t\tintf_sel |= MDP4_DISP_INTF_SEL_DSI_CMD;\n\t}\n\n\tmdp4_crtc->mixer = mixer;\n\n\tblend_setup(crtc);\n\n\tDBG(\"%s: intf_sel=%08x\", mdp4_crtc->name, intf_sel);\n\n\tmdp4_write(mdp4_kms, REG_MDP4_DISP_INTF_SEL, intf_sel);\n}\n\nvoid mdp4_crtc_wait_for_commit_done(struct drm_crtc *crtc)\n{\n\t \n\tmdp4_crtc_wait_for_flush_done(crtc);\n}\n\nstatic const char *dma_names[] = {\n\t\t\"DMA_P\", \"DMA_S\", \"DMA_E\",\n};\n\n \nstruct drm_crtc *mdp4_crtc_init(struct drm_device *dev,\n\t\tstruct drm_plane *plane, int id, int ovlp_id,\n\t\tenum mdp4_dma dma_id)\n{\n\tstruct drm_crtc *crtc = NULL;\n\tstruct mdp4_crtc *mdp4_crtc;\n\n\tmdp4_crtc = kzalloc(sizeof(*mdp4_crtc), GFP_KERNEL);\n\tif (!mdp4_crtc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcrtc = &mdp4_crtc->base;\n\n\tmdp4_crtc->id = id;\n\n\tmdp4_crtc->ovlp = ovlp_id;\n\tmdp4_crtc->dma = dma_id;\n\n\tmdp4_crtc->vblank.irqmask = dma2irq(mdp4_crtc->dma);\n\tmdp4_crtc->vblank.irq = mdp4_crtc_vblank_irq;\n\n\tmdp4_crtc->err.irqmask = dma2err(mdp4_crtc->dma);\n\tmdp4_crtc->err.irq = mdp4_crtc_err_irq;\n\n\tsnprintf(mdp4_crtc->name, sizeof(mdp4_crtc->name), \"%s:%d\",\n\t\t\tdma_names[dma_id], ovlp_id);\n\n\tspin_lock_init(&mdp4_crtc->cursor.lock);\n\n\tdrm_flip_work_init(&mdp4_crtc->unref_cursor_work,\n\t\t\t\"unref cursor\", unref_cursor_worker);\n\n\tdrm_crtc_init_with_planes(dev, crtc, plane, NULL, &mdp4_crtc_funcs,\n\t\t\t\t  NULL);\n\tdrm_crtc_helper_add(crtc, &mdp4_crtc_helper_funcs);\n\n\treturn crtc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}