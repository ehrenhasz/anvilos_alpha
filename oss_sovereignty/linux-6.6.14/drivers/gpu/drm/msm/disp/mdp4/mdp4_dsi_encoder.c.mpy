{
  "module_name": "mdp4_dsi_encoder.c",
  "hash_id": "af075791fba59f1d2c46a56ca3b142efa5c6d6f3d7411ee3bc9a8487df1f744b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp4/mdp4_dsi_encoder.c",
  "human_readable_source": "\n \n\n#include <drm/drm_crtc.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mdp4_kms.h\"\n\n#ifdef CONFIG_DRM_MSM_DSI\n\nstruct mdp4_dsi_encoder {\n\tstruct drm_encoder base;\n\tstruct drm_panel *panel;\n\tbool enabled;\n};\n#define to_mdp4_dsi_encoder(x) container_of(x, struct mdp4_dsi_encoder, base)\n\nstatic struct mdp4_kms *get_kms(struct drm_encoder *encoder)\n{\n\tstruct msm_drm_private *priv = encoder->dev->dev_private;\n\treturn to_mdp4_kms(to_mdp_kms(priv->kms));\n}\n\nstatic void mdp4_dsi_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct mdp4_dsi_encoder *mdp4_dsi_encoder = to_mdp4_dsi_encoder(encoder);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(mdp4_dsi_encoder);\n}\n\nstatic const struct drm_encoder_funcs mdp4_dsi_encoder_funcs = {\n\t.destroy = mdp4_dsi_encoder_destroy,\n};\n\nstatic void mdp4_dsi_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t      struct drm_display_mode *mode,\n\t\t\t\t      struct drm_display_mode *adjusted_mode)\n{\n\tstruct mdp4_kms *mdp4_kms = get_kms(encoder);\n\tuint32_t dsi_hsync_skew, vsync_period, vsync_len, ctrl_pol;\n\tuint32_t display_v_start, display_v_end;\n\tuint32_t hsync_start_x, hsync_end_x;\n\n\tmode = adjusted_mode;\n\n\tDBG(\"set mode: \" DRM_MODE_FMT, DRM_MODE_ARG(mode));\n\n\tctrl_pol = 0;\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tctrl_pol |= MDP4_DSI_CTRL_POLARITY_HSYNC_LOW;\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tctrl_pol |= MDP4_DSI_CTRL_POLARITY_VSYNC_LOW;\n\t \n\n\tdsi_hsync_skew = 0;   \n\n\thsync_start_x = (mode->htotal - mode->hsync_start);\n\thsync_end_x = mode->htotal - (mode->hsync_start - mode->hdisplay) - 1;\n\n\tvsync_period = mode->vtotal * mode->htotal;\n\tvsync_len = (mode->vsync_end - mode->vsync_start) * mode->htotal;\n\tdisplay_v_start = (mode->vtotal - mode->vsync_start) * mode->htotal + dsi_hsync_skew;\n\tdisplay_v_end = vsync_period - ((mode->vsync_start - mode->vdisplay) * mode->htotal) + dsi_hsync_skew - 1;\n\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_HSYNC_CTRL,\n\t\t\tMDP4_DSI_HSYNC_CTRL_PULSEW(mode->hsync_end - mode->hsync_start) |\n\t\t\tMDP4_DSI_HSYNC_CTRL_PERIOD(mode->htotal));\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_VSYNC_PERIOD, vsync_period);\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_VSYNC_LEN, vsync_len);\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_DISPLAY_HCTRL,\n\t\t\tMDP4_DSI_DISPLAY_HCTRL_START(hsync_start_x) |\n\t\t\tMDP4_DSI_DISPLAY_HCTRL_END(hsync_end_x));\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_DISPLAY_VSTART, display_v_start);\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_DISPLAY_VEND, display_v_end);\n\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_CTRL_POLARITY, ctrl_pol);\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_UNDERFLOW_CLR,\n\t\t\tMDP4_DSI_UNDERFLOW_CLR_ENABLE_RECOVERY |\n\t\t\tMDP4_DSI_UNDERFLOW_CLR_COLOR(0xff));\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_ACTIVE_HCTL,\n\t\t\tMDP4_DSI_ACTIVE_HCTL_START(0) |\n\t\t\tMDP4_DSI_ACTIVE_HCTL_END(0));\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_HSYNC_SKEW, dsi_hsync_skew);\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_BORDER_CLR, 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_ACTIVE_VSTART, 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_ACTIVE_VEND, 0);\n}\n\nstatic void mdp4_dsi_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct mdp4_dsi_encoder *mdp4_dsi_encoder = to_mdp4_dsi_encoder(encoder);\n\tstruct mdp4_kms *mdp4_kms = get_kms(encoder);\n\n\tif (!mdp4_dsi_encoder->enabled)\n\t\treturn;\n\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_ENABLE, 0);\n\n\t \n\tmdp_irq_wait(&mdp4_kms->base, MDP4_IRQ_PRIMARY_VSYNC);\n\n\tmdp4_dsi_encoder->enabled = false;\n}\n\nstatic void mdp4_dsi_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct mdp4_dsi_encoder *mdp4_dsi_encoder = to_mdp4_dsi_encoder(encoder);\n\tstruct mdp4_kms *mdp4_kms = get_kms(encoder);\n\n\tif (mdp4_dsi_encoder->enabled)\n\t\treturn;\n\n\tmdp4_crtc_set_config(encoder->crtc,\n\t\t\tMDP4_DMA_CONFIG_PACK_ALIGN_MSB |\n\t\t\tMDP4_DMA_CONFIG_DEFLKR_EN |\n\t\t\tMDP4_DMA_CONFIG_DITHER_EN |\n\t\t\tMDP4_DMA_CONFIG_R_BPC(BPC8) |\n\t\t\tMDP4_DMA_CONFIG_G_BPC(BPC8) |\n\t\t\tMDP4_DMA_CONFIG_B_BPC(BPC8) |\n\t\t\tMDP4_DMA_CONFIG_PACK(0x21));\n\n\tmdp4_crtc_set_intf(encoder->crtc, INTF_DSI_VIDEO, 0);\n\n\tmdp4_write(mdp4_kms, REG_MDP4_DSI_ENABLE, 1);\n\n\tmdp4_dsi_encoder->enabled = true;\n}\n\nstatic const struct drm_encoder_helper_funcs mdp4_dsi_encoder_helper_funcs = {\n\t.mode_set = mdp4_dsi_encoder_mode_set,\n\t.disable = mdp4_dsi_encoder_disable,\n\t.enable = mdp4_dsi_encoder_enable,\n};\n\n \nstruct drm_encoder *mdp4_dsi_encoder_init(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder = NULL;\n\tstruct mdp4_dsi_encoder *mdp4_dsi_encoder;\n\tint ret;\n\n\tmdp4_dsi_encoder = kzalloc(sizeof(*mdp4_dsi_encoder), GFP_KERNEL);\n\tif (!mdp4_dsi_encoder) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tencoder = &mdp4_dsi_encoder->base;\n\n\tdrm_encoder_init(dev, encoder, &mdp4_dsi_encoder_funcs,\n\t\t\t DRM_MODE_ENCODER_DSI, NULL);\n\tdrm_encoder_helper_add(encoder, &mdp4_dsi_encoder_helper_funcs);\n\n\treturn encoder;\n\nfail:\n\tif (encoder)\n\t\tmdp4_dsi_encoder_destroy(encoder);\n\n\treturn ERR_PTR(ret);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}