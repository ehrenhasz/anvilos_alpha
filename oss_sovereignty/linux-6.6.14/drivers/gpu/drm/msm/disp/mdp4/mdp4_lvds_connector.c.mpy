{
  "module_name": "mdp4_lvds_connector.c",
  "hash_id": "06a3271c3e1d3480ac3eb6cc62955926c428b79f4dc6d6f7ae8d8fdc75416ae2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp4/mdp4_lvds_connector.c",
  "human_readable_source": "\n \n\n#include \"mdp4_kms.h\"\n\nstruct mdp4_lvds_connector {\n\tstruct drm_connector base;\n\tstruct drm_encoder *encoder;\n\tstruct device_node *panel_node;\n\tstruct drm_panel *panel;\n};\n#define to_mdp4_lvds_connector(x) container_of(x, struct mdp4_lvds_connector, base)\n\nstatic enum drm_connector_status mdp4_lvds_connector_detect(\n\t\tstruct drm_connector *connector, bool force)\n{\n\tstruct mdp4_lvds_connector *mdp4_lvds_connector =\n\t\t\tto_mdp4_lvds_connector(connector);\n\n\tif (!mdp4_lvds_connector->panel) {\n\t\tmdp4_lvds_connector->panel =\n\t\t\tof_drm_find_panel(mdp4_lvds_connector->panel_node);\n\t\tif (IS_ERR(mdp4_lvds_connector->panel))\n\t\t\tmdp4_lvds_connector->panel = NULL;\n\t}\n\n\treturn mdp4_lvds_connector->panel ?\n\t\t\tconnector_status_connected :\n\t\t\tconnector_status_disconnected;\n}\n\nstatic void mdp4_lvds_connector_destroy(struct drm_connector *connector)\n{\n\tstruct mdp4_lvds_connector *mdp4_lvds_connector =\n\t\t\tto_mdp4_lvds_connector(connector);\n\n\tdrm_connector_cleanup(connector);\n\n\tkfree(mdp4_lvds_connector);\n}\n\nstatic int mdp4_lvds_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct mdp4_lvds_connector *mdp4_lvds_connector =\n\t\t\tto_mdp4_lvds_connector(connector);\n\tstruct drm_panel *panel = mdp4_lvds_connector->panel;\n\tint ret = 0;\n\n\tif (panel)\n\t\tret = drm_panel_get_modes(panel, connector);\n\n\treturn ret;\n}\n\nstatic enum drm_mode_status\nmdp4_lvds_connector_mode_valid(struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tstruct mdp4_lvds_connector *mdp4_lvds_connector =\n\t\t\tto_mdp4_lvds_connector(connector);\n\tstruct drm_encoder *encoder = mdp4_lvds_connector->encoder;\n\tlong actual, requested;\n\n\trequested = 1000 * mode->clock;\n\tactual = mdp4_lcdc_round_pixclk(encoder, requested);\n\n\tDBG(\"requested=%ld, actual=%ld\", requested, actual);\n\n\tif (actual != requested)\n\t\treturn MODE_CLOCK_RANGE;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_funcs mdp4_lvds_connector_funcs = {\n\t.detect = mdp4_lvds_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = mdp4_lvds_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_connector_helper_funcs mdp4_lvds_connector_helper_funcs = {\n\t.get_modes = mdp4_lvds_connector_get_modes,\n\t.mode_valid = mdp4_lvds_connector_mode_valid,\n};\n\n \nstruct drm_connector *mdp4_lvds_connector_init(struct drm_device *dev,\n\t\tstruct device_node *panel_node, struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector = NULL;\n\tstruct mdp4_lvds_connector *mdp4_lvds_connector;\n\n\tmdp4_lvds_connector = kzalloc(sizeof(*mdp4_lvds_connector), GFP_KERNEL);\n\tif (!mdp4_lvds_connector)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmdp4_lvds_connector->encoder = encoder;\n\tmdp4_lvds_connector->panel_node = panel_node;\n\n\tconnector = &mdp4_lvds_connector->base;\n\n\tdrm_connector_init(dev, connector, &mdp4_lvds_connector_funcs,\n\t\t\tDRM_MODE_CONNECTOR_LVDS);\n\tdrm_connector_helper_add(connector, &mdp4_lvds_connector_helper_funcs);\n\n\tconnector->polled = 0;\n\n\tconnector->interlace_allowed = 0;\n\tconnector->doublescan_allowed = 0;\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\treturn connector;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}