{
  "module_name": "mdp4_irq.c",
  "hash_id": "66236c859258cb7ec118184d4f725f74c8dd2eb890fe03296eefd746d7a78614",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp4/mdp4_irq.c",
  "human_readable_source": "\n \n\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n\n#include \"msm_drv.h\"\n#include \"mdp4_kms.h\"\n\nvoid mdp4_set_irqmask(struct mdp_kms *mdp_kms, uint32_t irqmask,\n\t\tuint32_t old_irqmask)\n{\n\tmdp4_write(to_mdp4_kms(mdp_kms), REG_MDP4_INTR_CLEAR,\n\t\tirqmask ^ (irqmask & old_irqmask));\n\tmdp4_write(to_mdp4_kms(mdp_kms), REG_MDP4_INTR_ENABLE, irqmask);\n}\n\nstatic void mdp4_irq_error_handler(struct mdp_irq *irq, uint32_t irqstatus)\n{\n\tstruct mdp4_kms *mdp4_kms = container_of(irq, struct mdp4_kms, error_handler);\n\tstatic DEFINE_RATELIMIT_STATE(rs, 5*HZ, 1);\n\textern bool dumpstate;\n\n\tDRM_ERROR_RATELIMITED(\"errors: %08x\\n\", irqstatus);\n\n\tif (dumpstate && __ratelimit(&rs)) {\n\t\tstruct drm_printer p = drm_info_printer(mdp4_kms->dev->dev);\n\t\tdrm_state_dump(mdp4_kms->dev, &p);\n\t}\n}\n\nvoid mdp4_irq_preinstall(struct msm_kms *kms)\n{\n\tstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\n\tmdp4_enable(mdp4_kms);\n\tmdp4_write(mdp4_kms, REG_MDP4_INTR_CLEAR, 0xffffffff);\n\tmdp4_write(mdp4_kms, REG_MDP4_INTR_ENABLE, 0x00000000);\n\tmdp4_disable(mdp4_kms);\n}\n\nint mdp4_irq_postinstall(struct msm_kms *kms)\n{\n\tstruct mdp_kms *mdp_kms = to_mdp_kms(kms);\n\tstruct mdp4_kms *mdp4_kms = to_mdp4_kms(mdp_kms);\n\tstruct mdp_irq *error_handler = &mdp4_kms->error_handler;\n\n\terror_handler->irq = mdp4_irq_error_handler;\n\terror_handler->irqmask = MDP4_IRQ_PRIMARY_INTF_UDERRUN |\n\t\t\tMDP4_IRQ_EXTERNAL_INTF_UDERRUN;\n\n\tmdp_irq_register(mdp_kms, error_handler);\n\n\treturn 0;\n}\n\nvoid mdp4_irq_uninstall(struct msm_kms *kms)\n{\n\tstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\n\tmdp4_enable(mdp4_kms);\n\tmdp4_write(mdp4_kms, REG_MDP4_INTR_ENABLE, 0x00000000);\n\tmdp4_disable(mdp4_kms);\n}\n\nirqreturn_t mdp4_irq(struct msm_kms *kms)\n{\n\tstruct mdp_kms *mdp_kms = to_mdp_kms(kms);\n\tstruct mdp4_kms *mdp4_kms = to_mdp4_kms(mdp_kms);\n\tstruct drm_device *dev = mdp4_kms->dev;\n\tstruct drm_crtc *crtc;\n\tuint32_t status, enable;\n\n\tenable = mdp4_read(mdp4_kms, REG_MDP4_INTR_ENABLE);\n\tstatus = mdp4_read(mdp4_kms, REG_MDP4_INTR_STATUS) & enable;\n\tmdp4_write(mdp4_kms, REG_MDP4_INTR_CLEAR, status);\n\n\tVERB(\"status=%08x\", status);\n\n\tmdp_dispatch_irqs(mdp_kms, status);\n\n\tdrm_for_each_crtc(crtc, dev)\n\t\tif (status & mdp4_crtc_vblank(crtc))\n\t\t\tdrm_crtc_handle_vblank(crtc);\n\n\treturn IRQ_HANDLED;\n}\n\nint mdp4_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)\n{\n\tstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\n\n\tmdp4_enable(mdp4_kms);\n\tmdp_update_vblank_mask(to_mdp_kms(kms),\n\t\t\tmdp4_crtc_vblank(crtc), true);\n\tmdp4_disable(mdp4_kms);\n\n\treturn 0;\n}\n\nvoid mdp4_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)\n{\n\tstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\n\n\tmdp4_enable(mdp4_kms);\n\tmdp_update_vblank_mask(to_mdp_kms(kms),\n\t\t\tmdp4_crtc_vblank(crtc), false);\n\tmdp4_disable(mdp4_kms);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}