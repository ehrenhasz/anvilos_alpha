{
  "module_name": "mdp4_kms.h",
  "hash_id": "e85dd510e295ef3e9ffe6592fc9798e70ffdd22cd26dfc0ef4b4b083d31cbed8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp4/mdp4_kms.h",
  "human_readable_source": " \n \n\n#ifndef __MDP4_KMS_H__\n#define __MDP4_KMS_H__\n\n#include <drm/drm_panel.h>\n\n#include \"msm_drv.h\"\n#include \"msm_kms.h\"\n#include \"disp/mdp_kms.h\"\n#include \"mdp4.xml.h\"\n\nstruct device_node;\n\nstruct mdp4_kms {\n\tstruct mdp_kms base;\n\n\tstruct drm_device *dev;\n\n\tint rev;\n\n\tvoid __iomem *mmio;\n\n\tstruct regulator *vdd;\n\n\tstruct clk *clk;\n\tstruct clk *pclk;\n\tstruct clk *lut_clk;\n\tstruct clk *axi_clk;\n\n\tstruct mdp_irq error_handler;\n\n\tbool rpm_enabled;\n\n\t \n\tstruct drm_gem_object *blank_cursor_bo;\n\tuint64_t blank_cursor_iova;\n};\n#define to_mdp4_kms(x) container_of(x, struct mdp4_kms, base)\n\nstatic inline void mdp4_write(struct mdp4_kms *mdp4_kms, u32 reg, u32 data)\n{\n\tmsm_writel(data, mdp4_kms->mmio + reg);\n}\n\nstatic inline u32 mdp4_read(struct mdp4_kms *mdp4_kms, u32 reg)\n{\n\treturn msm_readl(mdp4_kms->mmio + reg);\n}\n\nstatic inline uint32_t pipe2flush(enum mdp4_pipe pipe)\n{\n\tswitch (pipe) {\n\tcase VG1:      return MDP4_OVERLAY_FLUSH_VG1;\n\tcase VG2:      return MDP4_OVERLAY_FLUSH_VG2;\n\tcase RGB1:     return MDP4_OVERLAY_FLUSH_RGB1;\n\tcase RGB2:     return MDP4_OVERLAY_FLUSH_RGB2;\n\tdefault:       return 0;\n\t}\n}\n\nstatic inline uint32_t ovlp2flush(int ovlp)\n{\n\tswitch (ovlp) {\n\tcase 0:        return MDP4_OVERLAY_FLUSH_OVLP0;\n\tcase 1:        return MDP4_OVERLAY_FLUSH_OVLP1;\n\tdefault:       return 0;\n\t}\n}\n\nstatic inline uint32_t dma2irq(enum mdp4_dma dma)\n{\n\tswitch (dma) {\n\tcase DMA_P:    return MDP4_IRQ_DMA_P_DONE;\n\tcase DMA_S:    return MDP4_IRQ_DMA_S_DONE;\n\tcase DMA_E:    return MDP4_IRQ_DMA_E_DONE;\n\tdefault:       return 0;\n\t}\n}\n\nstatic inline uint32_t dma2err(enum mdp4_dma dma)\n{\n\tswitch (dma) {\n\tcase DMA_P:    return MDP4_IRQ_PRIMARY_INTF_UDERRUN;\n\tcase DMA_S:    return 0;  \n\tcase DMA_E:    return MDP4_IRQ_EXTERNAL_INTF_UDERRUN;\n\tdefault:       return 0;\n\t}\n}\n\nstatic inline uint32_t mixercfg(uint32_t mixer_cfg, int mixer,\n\t\tenum mdp4_pipe pipe, enum mdp_mixer_stage_id stage)\n{\n\tswitch (pipe) {\n\tcase VG1:\n\t\tmixer_cfg &= ~(MDP4_LAYERMIXER_IN_CFG_PIPE0__MASK |\n\t\t\t\tMDP4_LAYERMIXER_IN_CFG_PIPE0_MIXER1);\n\t\tmixer_cfg |= MDP4_LAYERMIXER_IN_CFG_PIPE0(stage) |\n\t\t\tCOND(mixer == 1, MDP4_LAYERMIXER_IN_CFG_PIPE0_MIXER1);\n\t\tbreak;\n\tcase VG2:\n\t\tmixer_cfg &= ~(MDP4_LAYERMIXER_IN_CFG_PIPE1__MASK |\n\t\t\t\tMDP4_LAYERMIXER_IN_CFG_PIPE1_MIXER1);\n\t\tmixer_cfg |= MDP4_LAYERMIXER_IN_CFG_PIPE1(stage) |\n\t\t\tCOND(mixer == 1, MDP4_LAYERMIXER_IN_CFG_PIPE1_MIXER1);\n\t\tbreak;\n\tcase RGB1:\n\t\tmixer_cfg &= ~(MDP4_LAYERMIXER_IN_CFG_PIPE2__MASK |\n\t\t\t\tMDP4_LAYERMIXER_IN_CFG_PIPE2_MIXER1);\n\t\tmixer_cfg |= MDP4_LAYERMIXER_IN_CFG_PIPE2(stage) |\n\t\t\tCOND(mixer == 1, MDP4_LAYERMIXER_IN_CFG_PIPE2_MIXER1);\n\t\tbreak;\n\tcase RGB2:\n\t\tmixer_cfg &= ~(MDP4_LAYERMIXER_IN_CFG_PIPE3__MASK |\n\t\t\t\tMDP4_LAYERMIXER_IN_CFG_PIPE3_MIXER1);\n\t\tmixer_cfg |= MDP4_LAYERMIXER_IN_CFG_PIPE3(stage) |\n\t\t\tCOND(mixer == 1, MDP4_LAYERMIXER_IN_CFG_PIPE3_MIXER1);\n\t\tbreak;\n\tcase RGB3:\n\t\tmixer_cfg &= ~(MDP4_LAYERMIXER_IN_CFG_PIPE4__MASK |\n\t\t\t\tMDP4_LAYERMIXER_IN_CFG_PIPE4_MIXER1);\n\t\tmixer_cfg |= MDP4_LAYERMIXER_IN_CFG_PIPE4(stage) |\n\t\t\tCOND(mixer == 1, MDP4_LAYERMIXER_IN_CFG_PIPE4_MIXER1);\n\t\tbreak;\n\tcase VG3:\n\t\tmixer_cfg &= ~(MDP4_LAYERMIXER_IN_CFG_PIPE5__MASK |\n\t\t\t\tMDP4_LAYERMIXER_IN_CFG_PIPE5_MIXER1);\n\t\tmixer_cfg |= MDP4_LAYERMIXER_IN_CFG_PIPE5(stage) |\n\t\t\tCOND(mixer == 1, MDP4_LAYERMIXER_IN_CFG_PIPE5_MIXER1);\n\t\tbreak;\n\tcase VG4:\n\t\tmixer_cfg &= ~(MDP4_LAYERMIXER_IN_CFG_PIPE6__MASK |\n\t\t\t\tMDP4_LAYERMIXER_IN_CFG_PIPE6_MIXER1);\n\t\tmixer_cfg |= MDP4_LAYERMIXER_IN_CFG_PIPE6(stage) |\n\t\t\tCOND(mixer == 1, MDP4_LAYERMIXER_IN_CFG_PIPE6_MIXER1);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid pipe\");\n\t\tbreak;\n\t}\n\n\treturn mixer_cfg;\n}\n\nint mdp4_disable(struct mdp4_kms *mdp4_kms);\nint mdp4_enable(struct mdp4_kms *mdp4_kms);\n\nvoid mdp4_set_irqmask(struct mdp_kms *mdp_kms, uint32_t irqmask,\n\t\tuint32_t old_irqmask);\nvoid mdp4_irq_preinstall(struct msm_kms *kms);\nint mdp4_irq_postinstall(struct msm_kms *kms);\nvoid mdp4_irq_uninstall(struct msm_kms *kms);\nirqreturn_t mdp4_irq(struct msm_kms *kms);\nint mdp4_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);\nvoid mdp4_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);\n\nstatic inline uint32_t mdp4_pipe_caps(enum mdp4_pipe pipe)\n{\n\tswitch (pipe) {\n\tcase VG1:\n\tcase VG2:\n\tcase VG3:\n\tcase VG4:\n\t\treturn MDP_PIPE_CAP_HFLIP | MDP_PIPE_CAP_VFLIP |\n\t\t\t\tMDP_PIPE_CAP_SCALE | MDP_PIPE_CAP_CSC;\n\tcase RGB1:\n\tcase RGB2:\n\tcase RGB3:\n\t\treturn MDP_PIPE_CAP_SCALE;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nenum mdp4_pipe mdp4_plane_pipe(struct drm_plane *plane);\nstruct drm_plane *mdp4_plane_init(struct drm_device *dev,\n\t\tenum mdp4_pipe pipe_id, bool private_plane);\n\nuint32_t mdp4_crtc_vblank(struct drm_crtc *crtc);\nvoid mdp4_crtc_set_config(struct drm_crtc *crtc, uint32_t config);\nvoid mdp4_crtc_set_intf(struct drm_crtc *crtc, enum mdp4_intf intf, int mixer);\nvoid mdp4_crtc_wait_for_commit_done(struct drm_crtc *crtc);\nstruct drm_crtc *mdp4_crtc_init(struct drm_device *dev,\n\t\tstruct drm_plane *plane, int id, int ovlp_id,\n\t\tenum mdp4_dma dma_id);\n\nlong mdp4_dtv_round_pixclk(struct drm_encoder *encoder, unsigned long rate);\nstruct drm_encoder *mdp4_dtv_encoder_init(struct drm_device *dev);\n\nlong mdp4_lcdc_round_pixclk(struct drm_encoder *encoder, unsigned long rate);\nstruct drm_encoder *mdp4_lcdc_encoder_init(struct drm_device *dev,\n\t\tstruct device_node *panel_node);\n\nstruct drm_connector *mdp4_lvds_connector_init(struct drm_device *dev,\n\t\tstruct device_node *panel_node, struct drm_encoder *encoder);\n\n#ifdef CONFIG_DRM_MSM_DSI\nstruct drm_encoder *mdp4_dsi_encoder_init(struct drm_device *dev);\n#else\nstatic inline struct drm_encoder *mdp4_dsi_encoder_init(struct drm_device *dev)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n#endif\n\n#ifdef CONFIG_COMMON_CLK\nstruct clk *mpd4_lvds_pll_init(struct drm_device *dev);\n#else\nstatic inline struct clk *mpd4_lvds_pll_init(struct drm_device *dev)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}