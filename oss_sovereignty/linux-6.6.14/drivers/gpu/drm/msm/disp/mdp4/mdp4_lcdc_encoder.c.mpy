{
  "module_name": "mdp4_lcdc_encoder.c",
  "hash_id": "d842e2844dcbc7afa1611451b2e8fe9b04cc88f827e4697b8d3409167abc19b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp4/mdp4_lcdc_encoder.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mdp4_kms.h\"\n\nstruct mdp4_lcdc_encoder {\n\tstruct drm_encoder base;\n\tstruct device_node *panel_node;\n\tstruct drm_panel *panel;\n\tstruct clk *lcdc_clk;\n\tunsigned long int pixclock;\n\tstruct regulator *regs[3];\n\tbool enabled;\n\tuint32_t bsc;\n};\n#define to_mdp4_lcdc_encoder(x) container_of(x, struct mdp4_lcdc_encoder, base)\n\nstatic struct mdp4_kms *get_kms(struct drm_encoder *encoder)\n{\n\tstruct msm_drm_private *priv = encoder->dev->dev_private;\n\treturn to_mdp4_kms(to_mdp_kms(priv->kms));\n}\n\nstatic void mdp4_lcdc_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct mdp4_lcdc_encoder *mdp4_lcdc_encoder =\n\t\t\tto_mdp4_lcdc_encoder(encoder);\n\tdrm_encoder_cleanup(encoder);\n\tkfree(mdp4_lcdc_encoder);\n}\n\nstatic const struct drm_encoder_funcs mdp4_lcdc_encoder_funcs = {\n\t.destroy = mdp4_lcdc_encoder_destroy,\n};\n\n \nstatic struct drm_connector *get_connector(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_connector *connector;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\n\t\tif (connector->encoder == encoder)\n\t\t\treturn connector;\n\n\treturn NULL;\n}\n\nstatic void setup_phy(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_connector *connector = get_connector(encoder);\n\tstruct mdp4_kms *mdp4_kms = get_kms(encoder);\n\tuint32_t lvds_intf = 0, lvds_phy_cfg0 = 0;\n\tint bpp, nchan, swap;\n\n\tif (!connector)\n\t\treturn;\n\n\tbpp = 3 * connector->display_info.bpc;\n\n\tif (!bpp)\n\t\tbpp = 18;\n\n\t \n\tnchan = 1;\n\tswap = 0;\n\n\tswitch (bpp) {\n\tcase 24:\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_3_TO_0(0),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT0(0x08) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT1(0x05) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT2(0x04) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT3(0x03));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_6_TO_4(0),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT4(0x02) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT5(0x01) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT6(0x00));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_3_TO_0(1),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT0(0x11) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT1(0x10) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT2(0x0d) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT3(0x0c));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_6_TO_4(1),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT4(0x0b) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT5(0x0a) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT6(0x09));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_3_TO_0(2),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT0(0x1a) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT1(0x19) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT2(0x18) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT3(0x15));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_6_TO_4(2),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT4(0x14) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT5(0x13) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT6(0x12));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_3_TO_0(3),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT0(0x1b) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT1(0x17) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT2(0x16) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT3(0x0f));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_6_TO_4(3),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT4(0x0e) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT5(0x07) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT6(0x06));\n\t\tif (nchan == 2) {\n\t\t\tlvds_intf |= MDP4_LCDC_LVDS_INTF_CTL_CH2_DATA_LANE3_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH2_DATA_LANE2_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH2_DATA_LANE1_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH2_DATA_LANE0_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE3_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE2_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE1_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE0_EN;\n\t\t} else {\n\t\t\tlvds_intf |= MDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE3_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE2_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE1_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE0_EN;\n\t\t}\n\t\tbreak;\n\n\tcase 18:\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_3_TO_0(0),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT0(0x0a) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT1(0x07) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT2(0x06) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT3(0x05));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_6_TO_4(0),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT4(0x04) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT5(0x03) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT6(0x02));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_3_TO_0(1),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT0(0x13) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT1(0x12) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT2(0x0f) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT3(0x0e));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_6_TO_4(1),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT4(0x0d) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT5(0x0c) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT6(0x0b));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_3_TO_0(2),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT0(0x1a) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT1(0x19) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT2(0x18) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_3_TO_0_BIT3(0x17));\n\t\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_MUX_CTL_6_TO_4(2),\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT4(0x16) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT5(0x15) |\n\t\t\t\tMDP4_LCDC_LVDS_MUX_CTL_6_TO_4_BIT6(0x14));\n\t\tif (nchan == 2) {\n\t\t\tlvds_intf |= MDP4_LCDC_LVDS_INTF_CTL_CH2_DATA_LANE2_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH2_DATA_LANE1_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH2_DATA_LANE0_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE2_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE1_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE0_EN;\n\t\t} else {\n\t\t\tlvds_intf |= MDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE2_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE1_EN |\n\t\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_DATA_LANE0_EN;\n\t\t}\n\t\tlvds_intf |= MDP4_LCDC_LVDS_INTF_CTL_RGB_OUT;\n\t\tbreak;\n\n\tdefault:\n\t\tDRM_DEV_ERROR(dev->dev, \"unknown bpp: %d\\n\", bpp);\n\t\treturn;\n\t}\n\n\tswitch (nchan) {\n\tcase 1:\n\t\tlvds_phy_cfg0 = MDP4_LVDS_PHY_CFG0_CHANNEL0;\n\t\tlvds_intf |= MDP4_LCDC_LVDS_INTF_CTL_CH1_CLK_LANE_EN |\n\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_MODE_SEL;\n\t\tbreak;\n\tcase 2:\n\t\tlvds_phy_cfg0 = MDP4_LVDS_PHY_CFG0_CHANNEL0 |\n\t\t\t\tMDP4_LVDS_PHY_CFG0_CHANNEL1;\n\t\tlvds_intf |= MDP4_LCDC_LVDS_INTF_CTL_CH2_CLK_LANE_EN |\n\t\t\t\tMDP4_LCDC_LVDS_INTF_CTL_CH1_CLK_LANE_EN;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEV_ERROR(dev->dev, \"unknown # of channels: %d\\n\", nchan);\n\t\treturn;\n\t}\n\n\tif (swap)\n\t\tlvds_intf |= MDP4_LCDC_LVDS_INTF_CTL_CH_SWAP;\n\n\tlvds_intf |= MDP4_LCDC_LVDS_INTF_CTL_ENABLE;\n\n\tmdp4_write(mdp4_kms, REG_MDP4_LVDS_PHY_CFG0, lvds_phy_cfg0);\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_INTF_CTL, lvds_intf);\n\tmdp4_write(mdp4_kms, REG_MDP4_LVDS_PHY_CFG2, 0x30);\n\n\tmb();\n\tudelay(1);\n\tlvds_phy_cfg0 |= MDP4_LVDS_PHY_CFG0_SERIALIZATION_ENBLE;\n\tmdp4_write(mdp4_kms, REG_MDP4_LVDS_PHY_CFG0, lvds_phy_cfg0);\n}\n\nstatic void mdp4_lcdc_encoder_mode_set(struct drm_encoder *encoder,\n\t\tstruct drm_display_mode *mode,\n\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct mdp4_lcdc_encoder *mdp4_lcdc_encoder =\n\t\t\tto_mdp4_lcdc_encoder(encoder);\n\tstruct mdp4_kms *mdp4_kms = get_kms(encoder);\n\tuint32_t lcdc_hsync_skew, vsync_period, vsync_len, ctrl_pol;\n\tuint32_t display_v_start, display_v_end;\n\tuint32_t hsync_start_x, hsync_end_x;\n\n\tmode = adjusted_mode;\n\n\tDBG(\"set mode: \" DRM_MODE_FMT, DRM_MODE_ARG(mode));\n\n\tmdp4_lcdc_encoder->pixclock = mode->clock * 1000;\n\n\tDBG(\"pixclock=%lu\", mdp4_lcdc_encoder->pixclock);\n\n\tctrl_pol = 0;\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tctrl_pol |= MDP4_LCDC_CTRL_POLARITY_HSYNC_LOW;\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tctrl_pol |= MDP4_LCDC_CTRL_POLARITY_VSYNC_LOW;\n\t \n\n\tlcdc_hsync_skew = 0;   \n\n\thsync_start_x = (mode->htotal - mode->hsync_start);\n\thsync_end_x = mode->htotal - (mode->hsync_start - mode->hdisplay) - 1;\n\n\tvsync_period = mode->vtotal * mode->htotal;\n\tvsync_len = (mode->vsync_end - mode->vsync_start) * mode->htotal;\n\tdisplay_v_start = (mode->vtotal - mode->vsync_start) * mode->htotal + lcdc_hsync_skew;\n\tdisplay_v_end = vsync_period - ((mode->vsync_start - mode->vdisplay) * mode->htotal) + lcdc_hsync_skew - 1;\n\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_HSYNC_CTRL,\n\t\t\tMDP4_LCDC_HSYNC_CTRL_PULSEW(mode->hsync_end - mode->hsync_start) |\n\t\t\tMDP4_LCDC_HSYNC_CTRL_PERIOD(mode->htotal));\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_VSYNC_PERIOD, vsync_period);\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_VSYNC_LEN, vsync_len);\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_DISPLAY_HCTRL,\n\t\t\tMDP4_LCDC_DISPLAY_HCTRL_START(hsync_start_x) |\n\t\t\tMDP4_LCDC_DISPLAY_HCTRL_END(hsync_end_x));\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_DISPLAY_VSTART, display_v_start);\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_DISPLAY_VEND, display_v_end);\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_BORDER_CLR, 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_UNDERFLOW_CLR,\n\t\t\tMDP4_LCDC_UNDERFLOW_CLR_ENABLE_RECOVERY |\n\t\t\tMDP4_LCDC_UNDERFLOW_CLR_COLOR(0xff));\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_HSYNC_SKEW, lcdc_hsync_skew);\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_CTRL_POLARITY, ctrl_pol);\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_ACTIVE_HCTL,\n\t\t\tMDP4_LCDC_ACTIVE_HCTL_START(0) |\n\t\t\tMDP4_LCDC_ACTIVE_HCTL_END(0));\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_ACTIVE_VSTART, 0);\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_ACTIVE_VEND, 0);\n}\n\nstatic void mdp4_lcdc_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct mdp4_lcdc_encoder *mdp4_lcdc_encoder =\n\t\t\tto_mdp4_lcdc_encoder(encoder);\n\tstruct mdp4_kms *mdp4_kms = get_kms(encoder);\n\tstruct drm_panel *panel;\n\tint i, ret;\n\n\tif (WARN_ON(!mdp4_lcdc_encoder->enabled))\n\t\treturn;\n\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_ENABLE, 0);\n\n\tpanel = of_drm_find_panel(mdp4_lcdc_encoder->panel_node);\n\tif (!IS_ERR(panel)) {\n\t\tdrm_panel_disable(panel);\n\t\tdrm_panel_unprepare(panel);\n\t}\n\n\t \n\tmdp_irq_wait(&mdp4_kms->base, MDP4_IRQ_PRIMARY_VSYNC);\n\n\tclk_disable_unprepare(mdp4_lcdc_encoder->lcdc_clk);\n\n\tfor (i = 0; i < ARRAY_SIZE(mdp4_lcdc_encoder->regs); i++) {\n\t\tret = regulator_disable(mdp4_lcdc_encoder->regs[i]);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to disable regulator: %d\\n\", ret);\n\t}\n\n\tmdp4_lcdc_encoder->enabled = false;\n}\n\nstatic void mdp4_lcdc_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct mdp4_lcdc_encoder *mdp4_lcdc_encoder =\n\t\t\tto_mdp4_lcdc_encoder(encoder);\n\tunsigned long pc = mdp4_lcdc_encoder->pixclock;\n\tstruct mdp4_kms *mdp4_kms = get_kms(encoder);\n\tstruct drm_panel *panel;\n\tuint32_t config;\n\tint i, ret;\n\n\tif (WARN_ON(mdp4_lcdc_encoder->enabled))\n\t\treturn;\n\n\t \n\tconfig =\n\t\tMDP4_DMA_CONFIG_R_BPC(BPC6) |\n\t\tMDP4_DMA_CONFIG_G_BPC(BPC6) |\n\t\tMDP4_DMA_CONFIG_B_BPC(BPC6) |\n\t\tMDP4_DMA_CONFIG_PACK(0x21) |\n\t\tMDP4_DMA_CONFIG_DEFLKR_EN |\n\t\tMDP4_DMA_CONFIG_DITHER_EN;\n\n\tif (!of_property_read_bool(dev->dev->of_node, \"qcom,lcdc-align-lsb\"))\n\t\tconfig |= MDP4_DMA_CONFIG_PACK_ALIGN_MSB;\n\n\tmdp4_crtc_set_config(encoder->crtc, config);\n\tmdp4_crtc_set_intf(encoder->crtc, INTF_LCDC_DTV, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(mdp4_lcdc_encoder->regs); i++) {\n\t\tret = regulator_enable(mdp4_lcdc_encoder->regs[i]);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(dev->dev, \"failed to enable regulator: %d\\n\", ret);\n\t}\n\n\tDBG(\"setting lcdc_clk=%lu\", pc);\n\tret = clk_set_rate(mdp4_lcdc_encoder->lcdc_clk, pc);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to configure lcdc_clk: %d\\n\", ret);\n\tret = clk_prepare_enable(mdp4_lcdc_encoder->lcdc_clk);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to enable lcdc_clk: %d\\n\", ret);\n\n\tpanel = of_drm_find_panel(mdp4_lcdc_encoder->panel_node);\n\tif (!IS_ERR(panel)) {\n\t\tdrm_panel_prepare(panel);\n\t\tdrm_panel_enable(panel);\n\t}\n\n\tsetup_phy(encoder);\n\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_ENABLE, 1);\n\n\tmdp4_lcdc_encoder->enabled = true;\n}\n\nstatic const struct drm_encoder_helper_funcs mdp4_lcdc_encoder_helper_funcs = {\n\t.mode_set = mdp4_lcdc_encoder_mode_set,\n\t.disable = mdp4_lcdc_encoder_disable,\n\t.enable = mdp4_lcdc_encoder_enable,\n};\n\nlong mdp4_lcdc_round_pixclk(struct drm_encoder *encoder, unsigned long rate)\n{\n\tstruct mdp4_lcdc_encoder *mdp4_lcdc_encoder =\n\t\t\tto_mdp4_lcdc_encoder(encoder);\n\treturn clk_round_rate(mdp4_lcdc_encoder->lcdc_clk, rate);\n}\n\n \nstruct drm_encoder *mdp4_lcdc_encoder_init(struct drm_device *dev,\n\t\tstruct device_node *panel_node)\n{\n\tstruct drm_encoder *encoder = NULL;\n\tstruct mdp4_lcdc_encoder *mdp4_lcdc_encoder;\n\tstruct regulator *reg;\n\tint ret;\n\n\tmdp4_lcdc_encoder = kzalloc(sizeof(*mdp4_lcdc_encoder), GFP_KERNEL);\n\tif (!mdp4_lcdc_encoder) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tmdp4_lcdc_encoder->panel_node = panel_node;\n\n\tencoder = &mdp4_lcdc_encoder->base;\n\n\tdrm_encoder_init(dev, encoder, &mdp4_lcdc_encoder_funcs,\n\t\t\t DRM_MODE_ENCODER_LVDS, NULL);\n\tdrm_encoder_helper_add(encoder, &mdp4_lcdc_encoder_helper_funcs);\n\n\t \n\tmdp4_lcdc_encoder->lcdc_clk = mpd4_lvds_pll_init(dev);\n\tif (IS_ERR(mdp4_lcdc_encoder->lcdc_clk)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to get lvds_clk\\n\");\n\t\tret = PTR_ERR(mdp4_lcdc_encoder->lcdc_clk);\n\t\tgoto fail;\n\t}\n\n\t \n\treg = devm_regulator_get(dev->dev, \"lvds-vccs-3p3v\");\n\tif (IS_ERR(reg)) {\n\t\tret = PTR_ERR(reg);\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to get lvds-vccs-3p3v: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\tmdp4_lcdc_encoder->regs[0] = reg;\n\n\treg = devm_regulator_get(dev->dev, \"lvds-pll-vdda\");\n\tif (IS_ERR(reg)) {\n\t\tret = PTR_ERR(reg);\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to get lvds-pll-vdda: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\tmdp4_lcdc_encoder->regs[1] = reg;\n\n\treg = devm_regulator_get(dev->dev, \"lvds-vdda\");\n\tif (IS_ERR(reg)) {\n\t\tret = PTR_ERR(reg);\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to get lvds-vdda: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\tmdp4_lcdc_encoder->regs[2] = reg;\n\n\treturn encoder;\n\nfail:\n\tif (encoder)\n\t\tmdp4_lcdc_encoder_destroy(encoder);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}