{
  "module_name": "mdp_kms.c",
  "hash_id": "47bb000a7ed34c8c1fa028fec9b36cc3af85d237c388fe5847d32131eec745cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp_kms.c",
  "human_readable_source": "\n \n\n\n#include \"msm_drv.h\"\n#include \"mdp_kms.h\"\n\n\nstruct mdp_irq_wait {\n\tstruct mdp_irq irq;\n\tint count;\n};\n\nstatic DECLARE_WAIT_QUEUE_HEAD(wait_event);\n\nstatic DEFINE_SPINLOCK(list_lock);\n\nstatic void update_irq(struct mdp_kms *mdp_kms)\n{\n\tstruct mdp_irq *irq;\n\tuint32_t irqmask = mdp_kms->vblank_mask;\n\n\tassert_spin_locked(&list_lock);\n\n\tlist_for_each_entry(irq, &mdp_kms->irq_list, node)\n\t\tirqmask |= irq->irqmask;\n\n\tmdp_kms->funcs->set_irqmask(mdp_kms, irqmask, mdp_kms->cur_irq_mask);\n\tmdp_kms->cur_irq_mask = irqmask;\n}\n\n \nvoid mdp_irq_update(struct mdp_kms *mdp_kms)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&list_lock, flags);\n\tupdate_irq(mdp_kms);\n\tspin_unlock_irqrestore(&list_lock, flags);\n}\n\nvoid mdp_dispatch_irqs(struct mdp_kms *mdp_kms, uint32_t status)\n{\n\tstruct mdp_irq *handler, *n;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&list_lock, flags);\n\tmdp_kms->in_irq = true;\n\tlist_for_each_entry_safe(handler, n, &mdp_kms->irq_list, node) {\n\t\tif (handler->irqmask & status) {\n\t\t\tspin_unlock_irqrestore(&list_lock, flags);\n\t\t\thandler->irq(handler, handler->irqmask & status);\n\t\t\tspin_lock_irqsave(&list_lock, flags);\n\t\t}\n\t}\n\tmdp_kms->in_irq = false;\n\tupdate_irq(mdp_kms);\n\tspin_unlock_irqrestore(&list_lock, flags);\n\n}\n\nvoid mdp_update_vblank_mask(struct mdp_kms *mdp_kms, uint32_t mask, bool enable)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&list_lock, flags);\n\tif (enable)\n\t\tmdp_kms->vblank_mask |= mask;\n\telse\n\t\tmdp_kms->vblank_mask &= ~mask;\n\tupdate_irq(mdp_kms);\n\tspin_unlock_irqrestore(&list_lock, flags);\n}\n\nstatic void wait_irq(struct mdp_irq *irq, uint32_t irqstatus)\n{\n\tstruct mdp_irq_wait *wait =\n\t\t\tcontainer_of(irq, struct mdp_irq_wait, irq);\n\twait->count--;\n\twake_up_all(&wait_event);\n}\n\nvoid mdp_irq_wait(struct mdp_kms *mdp_kms, uint32_t irqmask)\n{\n\tstruct mdp_irq_wait wait = {\n\t\t.irq = {\n\t\t\t.irq = wait_irq,\n\t\t\t.irqmask = irqmask,\n\t\t},\n\t\t.count = 1,\n\t};\n\tmdp_irq_register(mdp_kms, &wait.irq);\n\twait_event_timeout(wait_event, (wait.count <= 0),\n\t\t\tmsecs_to_jiffies(100));\n\tmdp_irq_unregister(mdp_kms, &wait.irq);\n}\n\nvoid mdp_irq_register(struct mdp_kms *mdp_kms, struct mdp_irq *irq)\n{\n\tunsigned long flags;\n\tbool needs_update = false;\n\n\tspin_lock_irqsave(&list_lock, flags);\n\n\tif (!irq->registered) {\n\t\tirq->registered = true;\n\t\tlist_add(&irq->node, &mdp_kms->irq_list);\n\t\tneeds_update = !mdp_kms->in_irq;\n\t}\n\n\tspin_unlock_irqrestore(&list_lock, flags);\n\n\tif (needs_update)\n\t\tmdp_irq_update(mdp_kms);\n}\n\nvoid mdp_irq_unregister(struct mdp_kms *mdp_kms, struct mdp_irq *irq)\n{\n\tunsigned long flags;\n\tbool needs_update = false;\n\n\tspin_lock_irqsave(&list_lock, flags);\n\n\tif (irq->registered) {\n\t\tirq->registered = false;\n\t\tlist_del(&irq->node);\n\t\tneeds_update = !mdp_kms->in_irq;\n\t}\n\n\tspin_unlock_irqrestore(&list_lock, flags);\n\n\tif (needs_update)\n\t\tmdp_irq_update(mdp_kms);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}