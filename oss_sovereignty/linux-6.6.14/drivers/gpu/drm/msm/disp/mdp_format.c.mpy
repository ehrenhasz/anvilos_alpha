{
  "module_name": "mdp_format.c",
  "hash_id": "ad0104c9d8faa45afca4b3f23e6e714cd1d5eef01d104b89e67c0779d38664f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/mdp_format.c",
  "human_readable_source": "\n \n\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n\n#include \"msm_drv.h\"\n#include \"mdp_kms.h\"\n\nstatic struct csc_cfg csc_convert[CSC_MAX] = {\n\t[CSC_RGB2RGB] = {\n\t\t.type = CSC_RGB2RGB,\n\t\t.matrix = {\n\t\t\t0x0200, 0x0000, 0x0000,\n\t\t\t0x0000, 0x0200, 0x0000,\n\t\t\t0x0000, 0x0000, 0x0200\n\t\t},\n\t\t.pre_bias =\t{ 0x0, 0x0, 0x0 },\n\t\t.post_bias =\t{ 0x0, 0x0, 0x0 },\n\t\t.pre_clamp =\t{ 0x0, 0xff, 0x0, 0xff, 0x0, 0xff },\n\t\t.post_clamp =\t{ 0x0, 0xff, 0x0, 0xff, 0x0, 0xff },\n\t},\n\t[CSC_YUV2RGB] = {\n\t\t.type = CSC_YUV2RGB,\n\t\t.matrix = {\n\t\t\t0x0254, 0x0000, 0x0331,\n\t\t\t0x0254, 0xff37, 0xfe60,\n\t\t\t0x0254, 0x0409, 0x0000\n\t\t},\n\t\t.pre_bias =\t{ 0xfff0, 0xff80, 0xff80 },\n\t\t.post_bias =\t{ 0x00, 0x00, 0x00 },\n\t\t.pre_clamp =\t{ 0x00, 0xff, 0x00, 0xff, 0x00, 0xff },\n\t\t.post_clamp =\t{ 0x00, 0xff, 0x00, 0xff, 0x00, 0xff },\n\t},\n\t[CSC_RGB2YUV] = {\n\t\t.type = CSC_RGB2YUV,\n\t\t.matrix = {\n\t\t\t0x0083, 0x0102, 0x0032,\n\t\t\t0x1fb5, 0x1f6c, 0x00e1,\n\t\t\t0x00e1, 0x1f45, 0x1fdc\n\t\t},\n\t\t.pre_bias =\t{ 0x00, 0x00, 0x00 },\n\t\t.post_bias =\t{ 0x10, 0x80, 0x80 },\n\t\t.pre_clamp =\t{ 0x00, 0xff, 0x00, 0xff, 0x00, 0xff },\n\t\t.post_clamp =\t{ 0x10, 0xeb, 0x10, 0xf0, 0x10, 0xf0 },\n\t},\n\t[CSC_YUV2YUV] = {\n\t\t.type = CSC_YUV2YUV,\n\t\t.matrix = {\n\t\t\t0x0200, 0x0000, 0x0000,\n\t\t\t0x0000, 0x0200, 0x0000,\n\t\t\t0x0000, 0x0000, 0x0200\n\t\t},\n\t\t.pre_bias =\t{ 0x00, 0x00, 0x00 },\n\t\t.post_bias =\t{ 0x00, 0x00, 0x00 },\n\t\t.pre_clamp =\t{ 0x00, 0xff, 0x00, 0xff, 0x00, 0xff },\n\t\t.post_clamp =\t{ 0x00, 0xff, 0x00, 0xff, 0x00, 0xff },\n\t},\n};\n\n#define FMT(name, a, r, g, b, e0, e1, e2, e3, alpha, tight, c, cnt, fp, cs, yuv) { \\\n\t\t.base = { .pixel_format = DRM_FORMAT_ ## name }, \\\n\t\t.bpc_a = BPC ## a ## A,                          \\\n\t\t.bpc_r = BPC ## r,                               \\\n\t\t.bpc_g = BPC ## g,                               \\\n\t\t.bpc_b = BPC ## b,                               \\\n\t\t.unpack = { e0, e1, e2, e3 },                    \\\n\t\t.alpha_enable = alpha,                           \\\n\t\t.unpack_tight = tight,                           \\\n\t\t.cpp = c,                                        \\\n\t\t.unpack_count = cnt,                             \\\n\t\t.fetch_type = fp,                                \\\n\t\t.chroma_sample = cs,                             \\\n\t\t.is_yuv = yuv,                                   \\\n}\n\n#define BPC0A 0\n\n \nstatic const struct mdp_format formats[] = {\n\t \n\tFMT(ARGB8888, 8, 8, 8, 8,  1, 0, 2, 3,  true,   true,  4,  4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\tFMT(ABGR8888, 8, 8, 8, 8,  2, 0, 1, 3,  true,   true,  4,  4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\tFMT(RGBA8888, 8, 8, 8, 8,  3, 1, 0, 2,  true,   true,  4,  4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\tFMT(BGRA8888, 8, 8, 8, 8,  3, 2, 0, 1,  true,   true,  4,  4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\tFMT(XRGB8888, 8, 8, 8, 8,  1, 0, 2, 3,  false,  true,  4,  4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\tFMT(XBGR8888, 8, 8, 8, 8,  2, 0, 1, 3,  false,   true,  4,  4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\tFMT(RGBX8888, 8, 8, 8, 8,  3, 1, 0, 2,  false,   true,  4,  4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\tFMT(BGRX8888, 8, 8, 8, 8,  3, 2, 0, 1,  false,   true,  4,  4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\tFMT(RGB888,   0, 8, 8, 8,  1, 0, 2, 0,  false,  true,  3,  3,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\tFMT(BGR888,   0, 8, 8, 8,  2, 0, 1, 0,  false,  true,  3,  3,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\tFMT(RGB565,   0, 5, 6, 5,  1, 0, 2, 0,  false,  true,  2,  3,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\tFMT(BGR565,   0, 5, 6, 5,  2, 0, 1, 0,  false,  true,  2,  3,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_FULL, false),\n\n\t \n\n\t \n\tFMT(NV12,     0, 8, 8, 8,  1, 2, 0, 0,  false,  true,  2, 2,\n\t\t\tMDP_PLANE_PSEUDO_PLANAR, CHROMA_420, true),\n\tFMT(NV21,     0, 8, 8, 8,  2, 1, 0, 0,  false,  true,  2, 2,\n\t\t\tMDP_PLANE_PSEUDO_PLANAR, CHROMA_420, true),\n\tFMT(NV16,     0, 8, 8, 8,  1, 2, 0, 0,  false,  true,  2, 2,\n\t\t\tMDP_PLANE_PSEUDO_PLANAR, CHROMA_H2V1, true),\n\tFMT(NV61,     0, 8, 8, 8,  2, 1, 0, 0,  false,  true,  2, 2,\n\t\t\tMDP_PLANE_PSEUDO_PLANAR, CHROMA_H2V1, true),\n\t \n\tFMT(VYUY,     0, 8, 8, 8,  2, 0, 1, 0,  false,  true,  2, 4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_H2V1, true),\n\tFMT(UYVY,     0, 8, 8, 8,  1, 0, 2, 0,  false,  true,  2, 4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_H2V1, true),\n\tFMT(YUYV,     0, 8, 8, 8,  0, 1, 0, 2,  false,  true,  2, 4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_H2V1, true),\n\tFMT(YVYU,     0, 8, 8, 8,  0, 2, 0, 1,  false,  true,  2, 4,\n\t\t\tMDP_PLANE_INTERLEAVED, CHROMA_H2V1, true),\n\t \n\tFMT(YUV420,   0, 8, 8, 8,  2, 1, 0, 0,  false,  true,  1, 1,\n\t\t\tMDP_PLANE_PLANAR, CHROMA_420, true),\n\tFMT(YVU420,   0, 8, 8, 8,  1, 2, 0, 0,  false,  true,  1, 1,\n\t\t\tMDP_PLANE_PLANAR, CHROMA_420, true),\n};\n\n \nuint32_t mdp_get_formats(uint32_t *pixel_formats, uint32_t max_formats,\n\t\tbool rgb_only)\n{\n\tuint32_t i;\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tconst struct mdp_format *f = &formats[i];\n\n\t\tif (i == max_formats)\n\t\t\tbreak;\n\n\t\tif (rgb_only && MDP_FORMAT_IS_YUV(f))\n\t\t\tbreak;\n\n\t\tpixel_formats[i] = f->base.pixel_format;\n\t}\n\n\treturn i;\n}\n\nconst struct msm_format *mdp_get_format(struct msm_kms *kms, uint32_t format,\n\t\tuint64_t modifier)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tconst struct mdp_format *f = &formats[i];\n\t\tif (f->base.pixel_format == format)\n\t\t\treturn &f->base;\n\t}\n\treturn NULL;\n}\n\nstruct csc_cfg *mdp_get_default_csc_cfg(enum csc_type type)\n{\n\tif (WARN_ON(type >= CSC_MAX))\n\t\treturn NULL;\n\n\treturn &csc_convert[type];\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}