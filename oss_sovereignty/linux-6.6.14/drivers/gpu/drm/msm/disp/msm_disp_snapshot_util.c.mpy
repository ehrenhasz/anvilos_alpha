{
  "module_name": "msm_disp_snapshot_util.c",
  "hash_id": "0e233e656e19298d8d2fe430e9b86532420c9fd9e8038ad5e656e304240b0cd6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/disp/msm_disp_snapshot_util.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"[drm:%s:%d] \" fmt, __func__, __LINE__\n\n#include <generated/utsrelease.h>\n\n#include \"msm_disp_snapshot.h\"\n\nstatic void msm_disp_state_dump_regs(u32 **reg, u32 aligned_len, void __iomem *base_addr)\n{\n\tu32 len_padded;\n\tu32 num_rows;\n\tu32 x0, x4, x8, xc;\n\tvoid __iomem *addr;\n\tu32 *dump_addr = NULL;\n\tvoid __iomem *end_addr;\n\tint i;\n\n\tlen_padded = aligned_len * REG_DUMP_ALIGN;\n\tnum_rows = aligned_len / REG_DUMP_ALIGN;\n\n\taddr = base_addr;\n\tend_addr = base_addr + aligned_len;\n\n\tif (!(*reg))\n\t\t*reg = kzalloc(len_padded, GFP_KERNEL);\n\n\tif (*reg)\n\t\tdump_addr = *reg;\n\n\tfor (i = 0; i < num_rows; i++) {\n\t\tx0 = (addr < end_addr) ? readl_relaxed(addr + 0x0) : 0;\n\t\tx4 = (addr + 0x4 < end_addr) ? readl_relaxed(addr + 0x4) : 0;\n\t\tx8 = (addr + 0x8 < end_addr) ? readl_relaxed(addr + 0x8) : 0;\n\t\txc = (addr + 0xc < end_addr) ? readl_relaxed(addr + 0xc) : 0;\n\n\t\tif (dump_addr) {\n\t\t\tdump_addr[i * 4] = x0;\n\t\t\tdump_addr[i * 4 + 1] = x4;\n\t\t\tdump_addr[i * 4 + 2] = x8;\n\t\t\tdump_addr[i * 4 + 3] = xc;\n\t\t}\n\n\t\taddr += REG_DUMP_ALIGN;\n\t}\n}\n\nstatic void msm_disp_state_print_regs(u32 **reg, u32 len, void __iomem *base_addr,\n\t\tstruct drm_printer *p)\n{\n\tint i;\n\tu32 *dump_addr = NULL;\n\tvoid __iomem *addr;\n\tu32 num_rows;\n\n\taddr = base_addr;\n\tnum_rows = len / REG_DUMP_ALIGN;\n\n\tif (*reg)\n\t\tdump_addr = *reg;\n\n\tfor (i = 0; i < num_rows; i++) {\n\t\tdrm_printf(p, \"0x%lx : %08x %08x %08x %08x\\n\",\n\t\t\t\t(unsigned long)(addr - base_addr),\n\t\t\t\tdump_addr[i * 4], dump_addr[i * 4 + 1],\n\t\t\t\tdump_addr[i * 4 + 2], dump_addr[i * 4 + 3]);\n\t\taddr += REG_DUMP_ALIGN;\n\t}\n}\n\nvoid msm_disp_state_print(struct msm_disp_state *state, struct drm_printer *p)\n{\n\tstruct msm_disp_state_block *block, *tmp;\n\n\tif (!p) {\n\t\tDRM_ERROR(\"invalid drm printer\\n\");\n\t\treturn;\n\t}\n\n\tdrm_printf(p, \"---\\n\");\n\tdrm_printf(p, \"kernel: \" UTS_RELEASE \"\\n\");\n\tdrm_printf(p, \"module: \" KBUILD_MODNAME \"\\n\");\n\tdrm_printf(p, \"dpu devcoredump\\n\");\n\tdrm_printf(p, \"time: %lld.%09ld\\n\",\n\t\tstate->time.tv_sec, state->time.tv_nsec);\n\n\tlist_for_each_entry_safe(block, tmp, &state->blocks, node) {\n\t\tdrm_printf(p, \"====================%s================\\n\", block->name);\n\t\tmsm_disp_state_print_regs(&block->state, block->size, block->base_addr, p);\n\t}\n\n\tdrm_printf(p, \"===================dpu drm state================\\n\");\n\n\tif (state->atomic_state)\n\t\tdrm_atomic_print_new_state(state->atomic_state, p);\n}\n\nstatic void msm_disp_capture_atomic_state(struct msm_disp_state *disp_state)\n{\n\tstruct drm_device *ddev;\n\tstruct drm_modeset_acquire_ctx ctx;\n\n\tktime_get_real_ts64(&disp_state->time);\n\n\tddev = disp_state->drm_dev;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\twhile (drm_modeset_lock_all_ctx(ddev, &ctx) != 0)\n\t\tdrm_modeset_backoff(&ctx);\n\n\tdisp_state->atomic_state = drm_atomic_helper_duplicate_state(ddev,\n\t\t\t&ctx);\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n}\n\nvoid msm_disp_snapshot_capture_state(struct msm_disp_state *disp_state)\n{\n\tstruct msm_drm_private *priv;\n\tstruct drm_device *drm_dev;\n\tstruct msm_kms *kms;\n\tint i;\n\n\tdrm_dev = disp_state->drm_dev;\n\tpriv = drm_dev->dev_private;\n\tkms = priv->kms;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->dp); i++) {\n\t\tif (!priv->dp[i])\n\t\t\tcontinue;\n\n\t\tmsm_dp_snapshot(disp_state, priv->dp[i]);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->dsi); i++) {\n\t\tif (!priv->dsi[i])\n\t\t\tcontinue;\n\n\t\tmsm_dsi_snapshot(disp_state, priv->dsi[i]);\n\t}\n\n\tif (kms->funcs->snapshot)\n\t\tkms->funcs->snapshot(disp_state, kms);\n\n\tmsm_disp_capture_atomic_state(disp_state);\n}\n\nvoid msm_disp_state_free(void *data)\n{\n\tstruct msm_disp_state *disp_state = data;\n\tstruct msm_disp_state_block *block, *tmp;\n\n\tif (disp_state->atomic_state) {\n\t\tdrm_atomic_state_put(disp_state->atomic_state);\n\t\tdisp_state->atomic_state = NULL;\n\t}\n\n\tlist_for_each_entry_safe(block, tmp, &disp_state->blocks, node) {\n\t\tlist_del(&block->node);\n\t\tkfree(block->state);\n\t\tkfree(block);\n\t}\n\n\tkfree(disp_state);\n}\n\nvoid msm_disp_snapshot_add_block(struct msm_disp_state *disp_state, u32 len,\n\t\tvoid __iomem *base_addr, const char *fmt, ...)\n{\n\tstruct msm_disp_state_block *new_blk;\n\tstruct va_format vaf;\n\tva_list va;\n\n\tnew_blk = kzalloc(sizeof(struct msm_disp_state_block), GFP_KERNEL);\n\tif (!new_blk)\n\t\treturn;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tsnprintf(new_blk->name, sizeof(new_blk->name), \"%pV\", &vaf);\n\n\tva_end(va);\n\n\tINIT_LIST_HEAD(&new_blk->node);\n\tnew_blk->size = ALIGN(len, REG_DUMP_ALIGN);\n\tnew_blk->base_addr = base_addr;\n\n\tmsm_disp_state_dump_regs(&new_blk->state, new_blk->size, base_addr);\n\tlist_add_tail(&new_blk->node, &disp_state->blocks);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}