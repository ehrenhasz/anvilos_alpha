{
  "module_name": "msm_mdss.c",
  "hash_id": "58a5f903a82abc34b70080eb349821d25c7a247a7ed53d2ae1671536c1653f9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_mdss.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interconnect.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqdesc.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include \"msm_mdss.h\"\n#include \"msm_kms.h\"\n\n#define HW_REV\t\t\t\t0x0\n#define HW_INTR_STATUS\t\t\t0x0010\n\n#define UBWC_DEC_HW_VERSION\t\t0x58\n#define UBWC_STATIC\t\t\t0x144\n#define UBWC_CTRL_2\t\t\t0x150\n#define UBWC_PREDICTION_MODE\t\t0x154\n\n#define MIN_IB_BW\t400000000UL  \n\nstruct msm_mdss {\n\tstruct device *dev;\n\n\tvoid __iomem *mmio;\n\tstruct clk_bulk_data *clocks;\n\tsize_t num_clocks;\n\tbool is_mdp5;\n\tstruct {\n\t\tunsigned long enabled_mask;\n\t\tstruct irq_domain *domain;\n\t} irq_controller;\n\tconst struct msm_mdss_data *mdss_data;\n\tstruct icc_path *path[2];\n\tu32 num_paths;\n};\n\nstatic int msm_mdss_parse_data_bus_icc_path(struct device *dev,\n\t\t\t\t\t    struct msm_mdss *msm_mdss)\n{\n\tstruct icc_path *path0;\n\tstruct icc_path *path1;\n\n\tpath0 = of_icc_get(dev, \"mdp0-mem\");\n\tif (IS_ERR_OR_NULL(path0))\n\t\treturn PTR_ERR_OR_ZERO(path0);\n\n\tmsm_mdss->path[0] = path0;\n\tmsm_mdss->num_paths = 1;\n\n\tpath1 = of_icc_get(dev, \"mdp1-mem\");\n\tif (!IS_ERR_OR_NULL(path1)) {\n\t\tmsm_mdss->path[1] = path1;\n\t\tmsm_mdss->num_paths++;\n\t}\n\n\treturn 0;\n}\n\nstatic void msm_mdss_put_icc_path(void *data)\n{\n\tstruct msm_mdss *msm_mdss = data;\n\tint i;\n\n\tfor (i = 0; i < msm_mdss->num_paths; i++)\n\t\ticc_put(msm_mdss->path[i]);\n}\n\nstatic void msm_mdss_icc_request_bw(struct msm_mdss *msm_mdss, unsigned long bw)\n{\n\tint i;\n\n\tfor (i = 0; i < msm_mdss->num_paths; i++)\n\t\ticc_set_bw(msm_mdss->path[i], 0, Bps_to_icc(bw));\n}\n\nstatic void msm_mdss_irq(struct irq_desc *desc)\n{\n\tstruct msm_mdss *msm_mdss = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tu32 interrupts;\n\n\tchained_irq_enter(chip, desc);\n\n\tinterrupts = readl_relaxed(msm_mdss->mmio + HW_INTR_STATUS);\n\n\twhile (interrupts) {\n\t\tirq_hw_number_t hwirq = fls(interrupts) - 1;\n\t\tint rc;\n\n\t\trc = generic_handle_domain_irq(msm_mdss->irq_controller.domain,\n\t\t\t\t\t       hwirq);\n\t\tif (rc < 0) {\n\t\t\tdev_err(msm_mdss->dev, \"handle irq fail: irq=%lu rc=%d\\n\",\n\t\t\t\t  hwirq, rc);\n\t\t\tbreak;\n\t\t}\n\n\t\tinterrupts &= ~(1 << hwirq);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void msm_mdss_irq_mask(struct irq_data *irqd)\n{\n\tstruct msm_mdss *msm_mdss = irq_data_get_irq_chip_data(irqd);\n\n\t \n\tsmp_mb__before_atomic();\n\tclear_bit(irqd->hwirq, &msm_mdss->irq_controller.enabled_mask);\n\t \n\tsmp_mb__after_atomic();\n}\n\nstatic void msm_mdss_irq_unmask(struct irq_data *irqd)\n{\n\tstruct msm_mdss *msm_mdss = irq_data_get_irq_chip_data(irqd);\n\n\t \n\tsmp_mb__before_atomic();\n\tset_bit(irqd->hwirq, &msm_mdss->irq_controller.enabled_mask);\n\t \n\tsmp_mb__after_atomic();\n}\n\nstatic struct irq_chip msm_mdss_irq_chip = {\n\t.name = \"msm_mdss\",\n\t.irq_mask = msm_mdss_irq_mask,\n\t.irq_unmask = msm_mdss_irq_unmask,\n};\n\nstatic struct lock_class_key msm_mdss_lock_key, msm_mdss_request_key;\n\nstatic int msm_mdss_irqdomain_map(struct irq_domain *domain,\n\t\tunsigned int irq, irq_hw_number_t hwirq)\n{\n\tstruct msm_mdss *msm_mdss = domain->host_data;\n\n\tirq_set_lockdep_class(irq, &msm_mdss_lock_key, &msm_mdss_request_key);\n\tirq_set_chip_and_handler(irq, &msm_mdss_irq_chip, handle_level_irq);\n\n\treturn irq_set_chip_data(irq, msm_mdss);\n}\n\nstatic const struct irq_domain_ops msm_mdss_irqdomain_ops = {\n\t.map = msm_mdss_irqdomain_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic int _msm_mdss_irq_domain_add(struct msm_mdss *msm_mdss)\n{\n\tstruct device *dev;\n\tstruct irq_domain *domain;\n\n\tdev = msm_mdss->dev;\n\n\tdomain = irq_domain_add_linear(dev->of_node, 32,\n\t\t\t&msm_mdss_irqdomain_ops, msm_mdss);\n\tif (!domain) {\n\t\tdev_err(dev, \"failed to add irq_domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmsm_mdss->irq_controller.enabled_mask = 0;\n\tmsm_mdss->irq_controller.domain = domain;\n\n\treturn 0;\n}\n\nstatic void msm_mdss_setup_ubwc_dec_20(struct msm_mdss *msm_mdss)\n{\n\tconst struct msm_mdss_data *data = msm_mdss->mdss_data;\n\n\twritel_relaxed(data->ubwc_static, msm_mdss->mmio + UBWC_STATIC);\n}\n\nstatic void msm_mdss_setup_ubwc_dec_30(struct msm_mdss *msm_mdss)\n{\n\tconst struct msm_mdss_data *data = msm_mdss->mdss_data;\n\tu32 value = (data->ubwc_swizzle & 0x1) |\n\t\t    (data->highest_bank_bit & 0x3) << 4 |\n\t\t    (data->macrotile_mode & 0x1) << 12;\n\n\tif (data->ubwc_enc_version == UBWC_3_0)\n\t\tvalue |= BIT(10);\n\n\tif (data->ubwc_enc_version == UBWC_1_0)\n\t\tvalue |= BIT(8);\n\n\twritel_relaxed(value, msm_mdss->mmio + UBWC_STATIC);\n}\n\nstatic void msm_mdss_setup_ubwc_dec_40(struct msm_mdss *msm_mdss)\n{\n\tconst struct msm_mdss_data *data = msm_mdss->mdss_data;\n\tu32 value = (data->ubwc_swizzle & 0x7) |\n\t\t    (data->ubwc_static & 0x1) << 3 |\n\t\t    (data->highest_bank_bit & 0x7) << 4 |\n\t\t    (data->macrotile_mode & 0x1) << 12;\n\n\twritel_relaxed(value, msm_mdss->mmio + UBWC_STATIC);\n\n\tif (data->ubwc_enc_version == UBWC_3_0) {\n\t\twritel_relaxed(1, msm_mdss->mmio + UBWC_CTRL_2);\n\t\twritel_relaxed(0, msm_mdss->mmio + UBWC_PREDICTION_MODE);\n\t} else {\n\t\tif (data->ubwc_dec_version == UBWC_4_3)\n\t\t\twritel_relaxed(3, msm_mdss->mmio + UBWC_CTRL_2);\n\t\telse\n\t\t\twritel_relaxed(2, msm_mdss->mmio + UBWC_CTRL_2);\n\t\twritel_relaxed(1, msm_mdss->mmio + UBWC_PREDICTION_MODE);\n\t}\n}\n\nconst struct msm_mdss_data *msm_mdss_get_mdss_data(struct device *dev)\n{\n\tstruct msm_mdss *mdss;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmdss = dev_get_drvdata(dev);\n\n\treturn mdss->mdss_data;\n}\n\nstatic int msm_mdss_enable(struct msm_mdss *msm_mdss)\n{\n\tint ret;\n\n\t \n\tmsm_mdss_icc_request_bw(msm_mdss, MIN_IB_BW);\n\n\tret = clk_bulk_prepare_enable(msm_mdss->num_clocks, msm_mdss->clocks);\n\tif (ret) {\n\t\tdev_err(msm_mdss->dev, \"clock enable failed, ret:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (msm_mdss->is_mdp5 || !msm_mdss->mdss_data)\n\t\treturn 0;\n\n\t \n\tswitch (msm_mdss->mdss_data->ubwc_dec_version) {\n\tcase 0:  \n\tcase UBWC_1_0:\n\t\t \n\t\tbreak;\n\tcase UBWC_2_0:\n\t\tmsm_mdss_setup_ubwc_dec_20(msm_mdss);\n\t\tbreak;\n\tcase UBWC_3_0:\n\t\tmsm_mdss_setup_ubwc_dec_30(msm_mdss);\n\t\tbreak;\n\tcase UBWC_4_0:\n\tcase UBWC_4_3:\n\t\tmsm_mdss_setup_ubwc_dec_40(msm_mdss);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(msm_mdss->dev, \"Unsupported UBWC decoder version %x\\n\",\n\t\t\tmsm_mdss->mdss_data->ubwc_dec_version);\n\t\tdev_err(msm_mdss->dev, \"HW_REV: 0x%x\\n\",\n\t\t\treadl_relaxed(msm_mdss->mmio + HW_REV));\n\t\tdev_err(msm_mdss->dev, \"UBWC_DEC_HW_VERSION: 0x%x\\n\",\n\t\t\treadl_relaxed(msm_mdss->mmio + UBWC_DEC_HW_VERSION));\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int msm_mdss_disable(struct msm_mdss *msm_mdss)\n{\n\tclk_bulk_disable_unprepare(msm_mdss->num_clocks, msm_mdss->clocks);\n\tmsm_mdss_icc_request_bw(msm_mdss, 0);\n\n\treturn 0;\n}\n\nstatic void msm_mdss_destroy(struct msm_mdss *msm_mdss)\n{\n\tstruct platform_device *pdev = to_platform_device(msm_mdss->dev);\n\tint irq;\n\n\tpm_runtime_suspend(msm_mdss->dev);\n\tpm_runtime_disable(msm_mdss->dev);\n\tirq_domain_remove(msm_mdss->irq_controller.domain);\n\tmsm_mdss->irq_controller.domain = NULL;\n\tirq = platform_get_irq(pdev, 0);\n\tirq_set_chained_handler_and_data(irq, NULL, NULL);\n}\n\nstatic int msm_mdss_reset(struct device *dev)\n{\n\tstruct reset_control *reset;\n\n\treset = reset_control_get_optional_exclusive(dev, NULL);\n\tif (!reset) {\n\t\t \n\t\treturn 0;\n\t} else if (IS_ERR(reset)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(reset),\n\t\t\t\t     \"failed to acquire mdss reset\\n\");\n\t}\n\n\treset_control_assert(reset);\n\t \n\tmsleep(20);\n\treset_control_deassert(reset);\n\n\treset_control_put(reset);\n\n\treturn 0;\n}\n\n \n#define MDP5_MDSS_NUM_CLOCKS 3\nstatic int mdp5_mdss_parse_clock(struct platform_device *pdev, struct clk_bulk_data **clocks)\n{\n\tstruct clk_bulk_data *bulk;\n\tint num_clocks = 0;\n\tint ret;\n\n\tif (!pdev)\n\t\treturn -EINVAL;\n\n\tbulk = devm_kcalloc(&pdev->dev, MDP5_MDSS_NUM_CLOCKS, sizeof(struct clk_bulk_data), GFP_KERNEL);\n\tif (!bulk)\n\t\treturn -ENOMEM;\n\n\tbulk[num_clocks++].id = \"iface\";\n\tbulk[num_clocks++].id = \"bus\";\n\tbulk[num_clocks++].id = \"vsync\";\n\n\tret = devm_clk_bulk_get_optional(&pdev->dev, num_clocks, bulk);\n\tif (ret)\n\t\treturn ret;\n\n\t*clocks = bulk;\n\n\treturn num_clocks;\n}\n\nstatic struct msm_mdss *msm_mdss_init(struct platform_device *pdev, bool is_mdp5)\n{\n\tstruct msm_mdss *msm_mdss;\n\tint ret;\n\tint irq;\n\n\tret = msm_mdss_reset(&pdev->dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmsm_mdss = devm_kzalloc(&pdev->dev, sizeof(*msm_mdss), GFP_KERNEL);\n\tif (!msm_mdss)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmsm_mdss->mmio = devm_platform_ioremap_resource_byname(pdev, is_mdp5 ? \"mdss_phys\" : \"mdss\");\n\tif (IS_ERR(msm_mdss->mmio))\n\t\treturn ERR_CAST(msm_mdss->mmio);\n\n\tdev_dbg(&pdev->dev, \"mapped mdss address space @%pK\\n\", msm_mdss->mmio);\n\n\tret = msm_mdss_parse_data_bus_icc_path(&pdev->dev, msm_mdss);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tret = devm_add_action_or_reset(&pdev->dev, msm_mdss_put_icc_path, msm_mdss);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (is_mdp5)\n\t\tret = mdp5_mdss_parse_clock(pdev, &msm_mdss->clocks);\n\telse\n\t\tret = devm_clk_bulk_get_all(&pdev->dev, &msm_mdss->clocks);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to parse clocks, ret=%d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\tmsm_mdss->num_clocks = ret;\n\tmsm_mdss->is_mdp5 = is_mdp5;\n\n\tmsm_mdss->dev = &pdev->dev;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn ERR_PTR(irq);\n\n\tret = _msm_mdss_irq_domain_add(msm_mdss);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tirq_set_chained_handler_and_data(irq, msm_mdss_irq,\n\t\t\t\t\t msm_mdss);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn msm_mdss;\n}\n\nstatic int __maybe_unused mdss_runtime_suspend(struct device *dev)\n{\n\tstruct msm_mdss *mdss = dev_get_drvdata(dev);\n\n\tDBG(\"\");\n\n\treturn msm_mdss_disable(mdss);\n}\n\nstatic int __maybe_unused mdss_runtime_resume(struct device *dev)\n{\n\tstruct msm_mdss *mdss = dev_get_drvdata(dev);\n\n\tDBG(\"\");\n\n\treturn msm_mdss_enable(mdss);\n}\n\nstatic int __maybe_unused mdss_pm_suspend(struct device *dev)\n{\n\n\tif (pm_runtime_suspended(dev))\n\t\treturn 0;\n\n\treturn mdss_runtime_suspend(dev);\n}\n\nstatic int __maybe_unused mdss_pm_resume(struct device *dev)\n{\n\tif (pm_runtime_suspended(dev))\n\t\treturn 0;\n\n\treturn mdss_runtime_resume(dev);\n}\n\nstatic const struct dev_pm_ops mdss_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(mdss_pm_suspend, mdss_pm_resume)\n\tSET_RUNTIME_PM_OPS(mdss_runtime_suspend, mdss_runtime_resume, NULL)\n};\n\nstatic int mdss_probe(struct platform_device *pdev)\n{\n\tstruct msm_mdss *mdss;\n\tbool is_mdp5 = of_device_is_compatible(pdev->dev.of_node, \"qcom,mdss\");\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tmdss = msm_mdss_init(pdev, is_mdp5);\n\tif (IS_ERR(mdss))\n\t\treturn PTR_ERR(mdss);\n\n\tmdss->mdss_data = of_device_get_match_data(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, mdss);\n\n\t \n\tret = of_platform_populate(dev->of_node, NULL, NULL, dev);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to populate children devices\\n\");\n\t\tmsm_mdss_destroy(mdss);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mdss_remove(struct platform_device *pdev)\n{\n\tstruct msm_mdss *mdss = platform_get_drvdata(pdev);\n\n\tof_platform_depopulate(&pdev->dev);\n\n\tmsm_mdss_destroy(mdss);\n\n\treturn 0;\n}\n\nstatic const struct msm_mdss_data msm8998_data = {\n\t.ubwc_enc_version = UBWC_1_0,\n\t.ubwc_dec_version = UBWC_1_0,\n\t.highest_bank_bit = 2,\n};\n\nstatic const struct msm_mdss_data qcm2290_data = {\n\t \n\t.highest_bank_bit = 0x2,\n};\n\nstatic const struct msm_mdss_data sc7180_data = {\n\t.ubwc_enc_version = UBWC_2_0,\n\t.ubwc_dec_version = UBWC_2_0,\n\t.ubwc_static = 0x1e,\n\t.highest_bank_bit = 0x3,\n};\n\nstatic const struct msm_mdss_data sc7280_data = {\n\t.ubwc_enc_version = UBWC_3_0,\n\t.ubwc_dec_version = UBWC_4_0,\n\t.ubwc_swizzle = 6,\n\t.ubwc_static = 1,\n\t.highest_bank_bit = 1,\n\t.macrotile_mode = 1,\n};\n\nstatic const struct msm_mdss_data sc8180x_data = {\n\t.ubwc_enc_version = UBWC_3_0,\n\t.ubwc_dec_version = UBWC_3_0,\n\t.highest_bank_bit = 3,\n\t.macrotile_mode = 1,\n};\n\nstatic const struct msm_mdss_data sc8280xp_data = {\n\t.ubwc_enc_version = UBWC_4_0,\n\t.ubwc_dec_version = UBWC_4_0,\n\t.ubwc_swizzle = 6,\n\t.ubwc_static = 1,\n\t.highest_bank_bit = 2,\n\t.macrotile_mode = 1,\n};\n\nstatic const struct msm_mdss_data sdm845_data = {\n\t.ubwc_enc_version = UBWC_2_0,\n\t.ubwc_dec_version = UBWC_2_0,\n\t.highest_bank_bit = 2,\n};\n\nstatic const struct msm_mdss_data sm6350_data = {\n\t.ubwc_enc_version = UBWC_2_0,\n\t.ubwc_dec_version = UBWC_2_0,\n\t.ubwc_swizzle = 6,\n\t.ubwc_static = 0x1e,\n\t.highest_bank_bit = 1,\n};\n\nstatic const struct msm_mdss_data sm8150_data = {\n\t.ubwc_enc_version = UBWC_3_0,\n\t.ubwc_dec_version = UBWC_3_0,\n\t.highest_bank_bit = 2,\n};\n\nstatic const struct msm_mdss_data sm6115_data = {\n\t.ubwc_enc_version = UBWC_1_0,\n\t.ubwc_dec_version = UBWC_2_0,\n\t.ubwc_swizzle = 7,\n\t.ubwc_static = 0x11f,\n\t.highest_bank_bit = 0x1,\n};\n\nstatic const struct msm_mdss_data sm6125_data = {\n\t.ubwc_enc_version = UBWC_1_0,\n\t.ubwc_dec_version = UBWC_3_0,\n\t.ubwc_swizzle = 1,\n\t.highest_bank_bit = 1,\n};\n\nstatic const struct msm_mdss_data sm8250_data = {\n\t.ubwc_enc_version = UBWC_4_0,\n\t.ubwc_dec_version = UBWC_4_0,\n\t.ubwc_swizzle = 6,\n\t.ubwc_static = 1,\n\t \n\t.highest_bank_bit = 3,\n\t.macrotile_mode = 1,\n};\n\nstatic const struct msm_mdss_data sm8550_data = {\n\t.ubwc_enc_version = UBWC_4_0,\n\t.ubwc_dec_version = UBWC_4_3,\n\t.ubwc_swizzle = 6,\n\t.ubwc_static = 1,\n\t \n\t.highest_bank_bit = 3,\n\t.macrotile_mode = 1,\n};\nstatic const struct of_device_id mdss_dt_match[] = {\n\t{ .compatible = \"qcom,mdss\" },\n\t{ .compatible = \"qcom,msm8998-mdss\", .data = &msm8998_data },\n\t{ .compatible = \"qcom,qcm2290-mdss\", .data = &qcm2290_data },\n\t{ .compatible = \"qcom,sdm845-mdss\", .data = &sdm845_data },\n\t{ .compatible = \"qcom,sc7180-mdss\", .data = &sc7180_data },\n\t{ .compatible = \"qcom,sc7280-mdss\", .data = &sc7280_data },\n\t{ .compatible = \"qcom,sc8180x-mdss\", .data = &sc8180x_data },\n\t{ .compatible = \"qcom,sc8280xp-mdss\", .data = &sc8280xp_data },\n\t{ .compatible = \"qcom,sm6115-mdss\", .data = &sm6115_data },\n\t{ .compatible = \"qcom,sm6125-mdss\", .data = &sm6125_data },\n\t{ .compatible = \"qcom,sm6350-mdss\", .data = &sm6350_data },\n\t{ .compatible = \"qcom,sm6375-mdss\", .data = &sm6350_data },\n\t{ .compatible = \"qcom,sm8150-mdss\", .data = &sm8150_data },\n\t{ .compatible = \"qcom,sm8250-mdss\", .data = &sm8250_data },\n\t{ .compatible = \"qcom,sm8350-mdss\", .data = &sm8250_data },\n\t{ .compatible = \"qcom,sm8450-mdss\", .data = &sm8250_data },\n\t{ .compatible = \"qcom,sm8550-mdss\", .data = &sm8550_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mdss_dt_match);\n\nstatic struct platform_driver mdss_platform_driver = {\n\t.probe      = mdss_probe,\n\t.remove     = mdss_remove,\n\t.driver     = {\n\t\t.name   = \"msm-mdss\",\n\t\t.of_match_table = mdss_dt_match,\n\t\t.pm     = &mdss_pm_ops,\n\t},\n};\n\nvoid __init msm_mdss_register(void)\n{\n\tplatform_driver_register(&mdss_platform_driver);\n}\n\nvoid __exit msm_mdss_unregister(void)\n{\n\tplatform_driver_unregister(&mdss_platform_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}