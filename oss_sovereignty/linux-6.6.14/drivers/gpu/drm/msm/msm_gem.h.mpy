{
  "module_name": "msm_gem.h",
  "hash_id": "b0dc5d01ff6413b1f6421658cb4d5fc268fab68b8ee518b35820828c0d8ed018",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_gem.h",
  "human_readable_source": " \n \n\n#ifndef __MSM_GEM_H__\n#define __MSM_GEM_H__\n\n#include <linux/kref.h>\n#include <linux/dma-resv.h>\n#include \"drm/gpu_scheduler.h\"\n#include \"msm_drv.h\"\n\n \n#define GEM_WARN_ON(x)  WARN_RATELIMIT(x, \"%s\", __stringify(x))\n\n \n#define MSM_BO_STOLEN        0x10000000     \n#define MSM_BO_MAP_PRIV      0x20000000     \n\nstruct msm_gem_address_space {\n\tconst char *name;\n\t \n\tstruct drm_mm mm;\n\tspinlock_t lock;  \n\tstruct msm_mmu *mmu;\n\tstruct kref kref;\n\n\t \n\tstruct pid *pid;\n\n\t \n\tint faults;\n\n\t \n\tuint64_t va_start;\n\n\t \n\tuint64_t va_size;\n};\n\nstruct msm_gem_address_space *\nmsm_gem_address_space_get(struct msm_gem_address_space *aspace);\n\nvoid msm_gem_address_space_put(struct msm_gem_address_space *aspace);\n\nstruct msm_gem_address_space *\nmsm_gem_address_space_create(struct msm_mmu *mmu, const char *name,\n\t\tu64 va_start, u64 size);\n\nstruct msm_fence_context;\n\nstruct msm_gem_vma {\n\tstruct drm_mm_node node;\n\tuint64_t iova;\n\tstruct msm_gem_address_space *aspace;\n\tstruct list_head list;     \n\tbool mapped;\n};\n\nstruct msm_gem_vma *msm_gem_vma_new(struct msm_gem_address_space *aspace);\nint msm_gem_vma_init(struct msm_gem_vma *vma, int size,\n\t\tu64 range_start, u64 range_end);\nvoid msm_gem_vma_purge(struct msm_gem_vma *vma);\nint msm_gem_vma_map(struct msm_gem_vma *vma, int prot, struct sg_table *sgt, int size);\nvoid msm_gem_vma_close(struct msm_gem_vma *vma);\n\nstruct msm_gem_object {\n\tstruct drm_gem_object base;\n\n\tuint32_t flags;\n\n\t \n\tuint8_t madv;\n\n\t \n\tuint8_t vmap_count;\n\n\t \n\tstruct list_head node;\n\n\tstruct page **pages;\n\tstruct sg_table *sgt;\n\tvoid *vaddr;\n\n\tstruct list_head vmas;     \n\n\t \n\tstruct drm_mm_node *vram_node;\n\n\tchar name[32];  \n\n\t \n\tint pin_count;\n};\n#define to_msm_bo(x) container_of(x, struct msm_gem_object, base)\n\nuint64_t msm_gem_mmap_offset(struct drm_gem_object *obj);\nint msm_gem_pin_vma_locked(struct drm_gem_object *obj, struct msm_gem_vma *vma);\nvoid msm_gem_unpin_locked(struct drm_gem_object *obj);\nvoid msm_gem_unpin_active(struct drm_gem_object *obj);\nstruct msm_gem_vma *msm_gem_get_vma_locked(struct drm_gem_object *obj,\n\t\t\t\t\t   struct msm_gem_address_space *aspace);\nint msm_gem_get_iova(struct drm_gem_object *obj,\n\t\tstruct msm_gem_address_space *aspace, uint64_t *iova);\nint msm_gem_set_iova(struct drm_gem_object *obj,\n\t\tstruct msm_gem_address_space *aspace, uint64_t iova);\nint msm_gem_get_and_pin_iova_range(struct drm_gem_object *obj,\n\t\tstruct msm_gem_address_space *aspace, uint64_t *iova,\n\t\tu64 range_start, u64 range_end);\nint msm_gem_get_and_pin_iova(struct drm_gem_object *obj,\n\t\tstruct msm_gem_address_space *aspace, uint64_t *iova);\nvoid msm_gem_unpin_iova(struct drm_gem_object *obj,\n\t\tstruct msm_gem_address_space *aspace);\nvoid msm_gem_pin_obj_locked(struct drm_gem_object *obj);\nstruct page **msm_gem_pin_pages(struct drm_gem_object *obj);\nvoid msm_gem_unpin_pages(struct drm_gem_object *obj);\nint msm_gem_dumb_create(struct drm_file *file, struct drm_device *dev,\n\t\tstruct drm_mode_create_dumb *args);\nint msm_gem_dumb_map_offset(struct drm_file *file, struct drm_device *dev,\n\t\tuint32_t handle, uint64_t *offset);\nvoid *msm_gem_get_vaddr_locked(struct drm_gem_object *obj);\nvoid *msm_gem_get_vaddr(struct drm_gem_object *obj);\nvoid *msm_gem_get_vaddr_active(struct drm_gem_object *obj);\nvoid msm_gem_put_vaddr_locked(struct drm_gem_object *obj);\nvoid msm_gem_put_vaddr(struct drm_gem_object *obj);\nint msm_gem_madvise(struct drm_gem_object *obj, unsigned madv);\nbool msm_gem_active(struct drm_gem_object *obj);\nint msm_gem_cpu_prep(struct drm_gem_object *obj, uint32_t op, ktime_t *timeout);\nint msm_gem_cpu_fini(struct drm_gem_object *obj);\nint msm_gem_new_handle(struct drm_device *dev, struct drm_file *file,\n\t\tuint32_t size, uint32_t flags, uint32_t *handle, char *name);\nstruct drm_gem_object *msm_gem_new(struct drm_device *dev,\n\t\tuint32_t size, uint32_t flags);\nvoid *msm_gem_kernel_new(struct drm_device *dev, uint32_t size,\n\t\tuint32_t flags, struct msm_gem_address_space *aspace,\n\t\tstruct drm_gem_object **bo, uint64_t *iova);\nvoid msm_gem_kernel_put(struct drm_gem_object *bo,\n\t\tstruct msm_gem_address_space *aspace);\nstruct drm_gem_object *msm_gem_import(struct drm_device *dev,\n\t\tstruct dma_buf *dmabuf, struct sg_table *sgt);\n__printf(2, 3)\nvoid msm_gem_object_set_name(struct drm_gem_object *bo, const char *fmt, ...);\n\n#ifdef CONFIG_DEBUG_FS\nstruct msm_gem_stats {\n\tstruct {\n\t\tunsigned count;\n\t\tsize_t size;\n\t} all, active, resident, purgeable, purged;\n};\n\nvoid msm_gem_describe(struct drm_gem_object *obj, struct seq_file *m,\n\t\tstruct msm_gem_stats *stats);\nvoid msm_gem_describe_objects(struct list_head *list, struct seq_file *m);\n#endif\n\nstatic inline void\nmsm_gem_lock(struct drm_gem_object *obj)\n{\n\tdma_resv_lock(obj->resv, NULL);\n}\n\nstatic inline int\nmsm_gem_lock_interruptible(struct drm_gem_object *obj)\n{\n\treturn dma_resv_lock_interruptible(obj->resv, NULL);\n}\n\nstatic inline void\nmsm_gem_unlock(struct drm_gem_object *obj)\n{\n\tdma_resv_unlock(obj->resv);\n}\n\nstatic inline void\nmsm_gem_assert_locked(struct drm_gem_object *obj)\n{\n\t \n\tlockdep_assert_once(\n\t\t(kref_read(&obj->refcount) == 0) ||\n\t\t(lockdep_is_held(&obj->resv->lock.base) != LOCK_STATE_NOT_HELD)\n\t);\n}\n\n \nstatic inline bool is_unpurgeable(struct msm_gem_object *msm_obj)\n{\n\treturn msm_obj->base.import_attach || msm_obj->pin_count;\n}\n\nstatic inline bool is_purgeable(struct msm_gem_object *msm_obj)\n{\n\treturn (msm_obj->madv == MSM_MADV_DONTNEED) && msm_obj->sgt &&\n\t\t\t!is_unpurgeable(msm_obj);\n}\n\nstatic inline bool is_vunmapable(struct msm_gem_object *msm_obj)\n{\n\tmsm_gem_assert_locked(&msm_obj->base);\n\treturn (msm_obj->vmap_count == 0) && msm_obj->vaddr;\n}\n\nstatic inline bool is_unevictable(struct msm_gem_object *msm_obj)\n{\n\treturn is_unpurgeable(msm_obj) || msm_obj->vaddr;\n}\n\nvoid msm_gem_purge(struct drm_gem_object *obj);\nvoid msm_gem_evict(struct drm_gem_object *obj);\nvoid msm_gem_vunmap(struct drm_gem_object *obj);\n\n \nstruct msm_gem_submit {\n\tstruct drm_sched_job base;\n\tstruct kref ref;\n\tstruct drm_device *dev;\n\tstruct msm_gpu *gpu;\n\tstruct msm_gem_address_space *aspace;\n\tstruct list_head node;    \n\tstruct ww_acquire_ctx ticket;\n\tuint32_t seqno;\t\t \n\n\t \n\tstruct dma_fence *hw_fence;\n\n\t \n\tstruct dma_fence *user_fence;\n\n\tint fence_id;        \n\tstruct msm_gpu_submitqueue *queue;\n\tstruct pid *pid;     \n\tbool fault_dumped;   \n\tbool valid;          \n\tbool in_rb;          \n\tstruct msm_ringbuffer *ring;\n\tunsigned int nr_cmds;\n\tunsigned int nr_bos;\n\tu32 ident;\t    \n\tstruct {\n\t\tuint32_t type;\n\t\tuint32_t size;   \n\t\tuint64_t iova;\n\t\tuint32_t offset; \n\t\tuint32_t idx;    \n\t\tuint32_t nr_relocs;\n\t\tstruct drm_msm_gem_submit_reloc *relocs;\n\t} *cmd;   \n\tstruct {\n \n#define BO_VALID\t0x8000\t \n#define BO_LOCKED\t0x4000\t \n#define BO_PINNED\t0x2000\t \n\t\tuint32_t flags;\n\t\tunion {\n\t\t\tstruct drm_gem_object *obj;\n\t\t\tuint32_t handle;\n\t\t};\n\t\tuint64_t iova;\n\t} bos[];\n};\n\nstatic inline struct msm_gem_submit *to_msm_submit(struct drm_sched_job *job)\n{\n\treturn container_of(job, struct msm_gem_submit, base);\n}\n\nvoid __msm_gem_submit_destroy(struct kref *kref);\n\nstatic inline void msm_gem_submit_get(struct msm_gem_submit *submit)\n{\n\tkref_get(&submit->ref);\n}\n\nstatic inline void msm_gem_submit_put(struct msm_gem_submit *submit)\n{\n\tkref_put(&submit->ref, __msm_gem_submit_destroy);\n}\n\nvoid msm_submit_retire(struct msm_gem_submit *submit);\n\n \nstatic inline bool\nshould_dump(struct msm_gem_submit *submit, int idx)\n{\n\textern bool rd_full;\n\treturn rd_full || (submit->bos[idx].flags & MSM_SUBMIT_BO_DUMP);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}