{
  "module_name": "msm_drv.h",
  "hash_id": "f4180f1c88aa402e18d552732dc1f53063e93e1c9a8c2d6f207574110eb5402d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_drv.h",
  "human_readable_source": " \n \n\n#ifndef __MSM_DRV_H__\n#define __MSM_DRV_H__\n\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/cpufreq.h>\n#include <linux/devfreq.h>\n#include <linux/module.h>\n#include <linux/component.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/iommu.h>\n#include <linux/types.h>\n#include <linux/of_graph.h>\n#include <linux/of_device.h>\n#include <linux/sizes.h>\n#include <linux/kthread.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/display/drm_dsc.h>\n#include <drm/msm_drm.h>\n#include <drm/drm_gem.h>\n\n#ifdef CONFIG_FAULT_INJECTION\nextern struct fault_attr fail_gem_alloc;\nextern struct fault_attr fail_gem_iova;\n#else\n#  define should_fail(attr, size) 0\n#endif\n\nstruct msm_kms;\nstruct msm_gpu;\nstruct msm_mmu;\nstruct msm_mdss;\nstruct msm_rd_state;\nstruct msm_perf_state;\nstruct msm_gem_submit;\nstruct msm_fence_context;\nstruct msm_gem_address_space;\nstruct msm_gem_vma;\nstruct msm_disp_state;\n\n#define MAX_CRTCS      8\n#define MAX_BRIDGES    8\n\n#define FRAC_16_16(mult, div)    (((mult) << 16) / (div))\n\nenum msm_dp_controller {\n\tMSM_DP_CONTROLLER_0,\n\tMSM_DP_CONTROLLER_1,\n\tMSM_DP_CONTROLLER_2,\n\tMSM_DP_CONTROLLER_3,\n\tMSM_DP_CONTROLLER_COUNT,\n};\n\nenum msm_dsi_controller {\n\tMSM_DSI_CONTROLLER_0,\n\tMSM_DSI_CONTROLLER_1,\n\tMSM_DSI_CONTROLLER_COUNT,\n};\n\n#define MSM_GPU_MAX_RINGS 4\n#define MAX_H_TILES_PER_DISPLAY 2\n\n \nenum msm_event_wait {\n\tMSM_ENC_COMMIT_DONE = 0,\n\tMSM_ENC_TX_COMPLETE,\n\tMSM_ENC_VBLANK,\n};\n\n \nstruct msm_display_topology {\n\tu32 num_lm;\n\tu32 num_intf;\n\tu32 num_dspp;\n\tu32 num_dsc;\n};\n\n \nstruct msm_drm_thread {\n\tstruct drm_device *dev;\n\tstruct kthread_worker *worker;\n};\n\nstruct msm_drm_private {\n\n\tstruct drm_device *dev;\n\n\tstruct msm_kms *kms;\n\tint (*kms_init)(struct drm_device *dev);\n\n\t \n\tstruct platform_device *gpu_pdev;\n\n\t \n\tstruct hdmi *hdmi;\n\n\t \n\tstruct msm_dsi *dsi[MSM_DSI_CONTROLLER_COUNT];\n\n\tstruct msm_dp *dp[MSM_DP_CONTROLLER_COUNT];\n\n\t \n\tstruct msm_gpu *gpu;\n\n\t \n\tbool is_a2xx;\n\tbool has_cached_coherent;\n\n\tstruct msm_rd_state *rd;        \n\tstruct msm_rd_state *hangrd;    \n\tstruct msm_perf_state *perf;\n\n\t \n\tstruct list_head objects;\n\tstruct mutex obj_lock;\n\n\t \n\tstruct {\n\t\t \n\t\tstruct drm_gem_lru unbacked;\n\n\t\t \n\t\tstruct drm_gem_lru pinned;\n\n\t\t \n\t\tstruct drm_gem_lru willneed;\n\n\t\t \n\t\tstruct drm_gem_lru dontneed;\n\n\t\t \n\t\tstruct mutex lock;\n\t} lru;\n\n\tstruct workqueue_struct *wq;\n\n\tunsigned int num_crtcs;\n\n\tstruct msm_drm_thread event_thread[MAX_CRTCS];\n\n\tunsigned int num_bridges;\n\tstruct drm_bridge *bridges[MAX_BRIDGES];\n\n\t \n\tstruct {\n\t\tunsigned long size;\n\t\tdma_addr_t paddr;\n\t\t \n\t\tstruct drm_mm mm;\n\t\tspinlock_t lock;  \n\t} vram;\n\n\tstruct notifier_block vmap_notifier;\n\tstruct shrinker shrinker;\n\n\tstruct drm_atomic_state *pm_state;\n\n\t \n\tunsigned int hangcheck_period;\n\n\t \n\tstruct devfreq_simple_ondemand_data gpu_devfreq_config;\n\n\t \n\tbool gpu_clamp_to_idle;\n\n\t \n\tbool disable_err_irq;\n};\n\nstruct msm_format {\n\tuint32_t pixel_format;\n};\n\nstruct msm_pending_timer;\n\nint msm_atomic_init_pending_timer(struct msm_pending_timer *timer,\n\t\tstruct msm_kms *kms, int crtc_idx);\nvoid msm_atomic_destroy_pending_timer(struct msm_pending_timer *timer);\nvoid msm_atomic_commit_tail(struct drm_atomic_state *state);\nint msm_atomic_check(struct drm_device *dev, struct drm_atomic_state *state);\nstruct drm_atomic_state *msm_atomic_state_alloc(struct drm_device *dev);\nvoid msm_atomic_state_clear(struct drm_atomic_state *state);\nvoid msm_atomic_state_free(struct drm_atomic_state *state);\n\nint msm_crtc_enable_vblank(struct drm_crtc *crtc);\nvoid msm_crtc_disable_vblank(struct drm_crtc *crtc);\n\nint msm_register_mmu(struct drm_device *dev, struct msm_mmu *mmu);\nvoid msm_unregister_mmu(struct drm_device *dev, struct msm_mmu *mmu);\n\nstruct msm_gem_address_space *msm_kms_init_aspace(struct drm_device *dev);\nbool msm_use_mmu(struct drm_device *dev);\n\nint msm_ioctl_gem_submit(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file);\n\n#ifdef CONFIG_DEBUG_FS\nunsigned long msm_gem_shrinker_shrink(struct drm_device *dev, unsigned long nr_to_scan);\n#endif\n\nvoid msm_gem_shrinker_init(struct drm_device *dev);\nvoid msm_gem_shrinker_cleanup(struct drm_device *dev);\n\nstruct sg_table *msm_gem_prime_get_sg_table(struct drm_gem_object *obj);\nint msm_gem_prime_vmap(struct drm_gem_object *obj, struct iosys_map *map);\nvoid msm_gem_prime_vunmap(struct drm_gem_object *obj, struct iosys_map *map);\nstruct drm_gem_object *msm_gem_prime_import_sg_table(struct drm_device *dev,\n\t\tstruct dma_buf_attachment *attach, struct sg_table *sg);\nint msm_gem_prime_pin(struct drm_gem_object *obj);\nvoid msm_gem_prime_unpin(struct drm_gem_object *obj);\n\nint msm_framebuffer_prepare(struct drm_framebuffer *fb,\n\t\tstruct msm_gem_address_space *aspace, bool needs_dirtyfb);\nvoid msm_framebuffer_cleanup(struct drm_framebuffer *fb,\n\t\tstruct msm_gem_address_space *aspace, bool needed_dirtyfb);\nuint32_t msm_framebuffer_iova(struct drm_framebuffer *fb,\n\t\tstruct msm_gem_address_space *aspace, int plane);\nstruct drm_gem_object *msm_framebuffer_bo(struct drm_framebuffer *fb, int plane);\nconst struct msm_format *msm_framebuffer_format(struct drm_framebuffer *fb);\nstruct drm_framebuffer *msm_framebuffer_create(struct drm_device *dev,\n\t\tstruct drm_file *file, const struct drm_mode_fb_cmd2 *mode_cmd);\nstruct drm_framebuffer * msm_alloc_stolen_fb(struct drm_device *dev,\n\t\tint w, int h, int p, uint32_t format);\n\n#ifdef CONFIG_DRM_FBDEV_EMULATION\nvoid msm_fbdev_setup(struct drm_device *dev);\n#else\nstatic inline void msm_fbdev_setup(struct drm_device *dev)\n{\n}\n#endif\n\nstruct hdmi;\n#ifdef CONFIG_DRM_MSM_HDMI\nint msm_hdmi_modeset_init(struct hdmi *hdmi, struct drm_device *dev,\n\t\tstruct drm_encoder *encoder);\nvoid __init msm_hdmi_register(void);\nvoid __exit msm_hdmi_unregister(void);\n#else\nstatic inline int msm_hdmi_modeset_init(struct hdmi *hdmi, struct drm_device *dev,\n\t\tstruct drm_encoder *encoder)\n{\n\treturn -EINVAL;\n}\nstatic inline void __init msm_hdmi_register(void) {}\nstatic inline void __exit msm_hdmi_unregister(void) {}\n#endif\n\nstruct msm_dsi;\n#ifdef CONFIG_DRM_MSM_DSI\nint dsi_dev_attach(struct platform_device *pdev);\nvoid dsi_dev_detach(struct platform_device *pdev);\nvoid __init msm_dsi_register(void);\nvoid __exit msm_dsi_unregister(void);\nint msm_dsi_modeset_init(struct msm_dsi *msm_dsi, struct drm_device *dev,\n\t\t\t struct drm_encoder *encoder);\nvoid msm_dsi_snapshot(struct msm_disp_state *disp_state, struct msm_dsi *msm_dsi);\nbool msm_dsi_is_cmd_mode(struct msm_dsi *msm_dsi);\nbool msm_dsi_is_bonded_dsi(struct msm_dsi *msm_dsi);\nbool msm_dsi_is_master_dsi(struct msm_dsi *msm_dsi);\nstruct drm_dsc_config *msm_dsi_get_dsc_config(struct msm_dsi *msm_dsi);\n#else\nstatic inline void __init msm_dsi_register(void)\n{\n}\nstatic inline void __exit msm_dsi_unregister(void)\n{\n}\nstatic inline int msm_dsi_modeset_init(struct msm_dsi *msm_dsi,\n\t\t\t\t       struct drm_device *dev,\n\t\t\t\t       struct drm_encoder *encoder)\n{\n\treturn -EINVAL;\n}\nstatic inline void msm_dsi_snapshot(struct msm_disp_state *disp_state, struct msm_dsi *msm_dsi)\n{\n}\nstatic inline bool msm_dsi_is_cmd_mode(struct msm_dsi *msm_dsi)\n{\n\treturn false;\n}\nstatic inline bool msm_dsi_is_bonded_dsi(struct msm_dsi *msm_dsi)\n{\n\treturn false;\n}\nstatic inline bool msm_dsi_is_master_dsi(struct msm_dsi *msm_dsi)\n{\n\treturn false;\n}\n\nstatic inline struct drm_dsc_config *msm_dsi_get_dsc_config(struct msm_dsi *msm_dsi)\n{\n\treturn NULL;\n}\n#endif\n\n#ifdef CONFIG_DRM_MSM_DP\nint __init msm_dp_register(void);\nvoid __exit msm_dp_unregister(void);\nint msm_dp_modeset_init(struct msm_dp *dp_display, struct drm_device *dev,\n\t\t\t struct drm_encoder *encoder);\nvoid msm_dp_irq_postinstall(struct msm_dp *dp_display);\nvoid msm_dp_snapshot(struct msm_disp_state *disp_state, struct msm_dp *dp_display);\n\nvoid msm_dp_debugfs_init(struct msm_dp *dp_display, struct drm_minor *minor);\nbool msm_dp_wide_bus_available(const struct msm_dp *dp_display);\n\n#else\nstatic inline int __init msm_dp_register(void)\n{\n\treturn -EINVAL;\n}\nstatic inline void __exit msm_dp_unregister(void)\n{\n}\nstatic inline int msm_dp_modeset_init(struct msm_dp *dp_display,\n\t\t\t\t       struct drm_device *dev,\n\t\t\t\t       struct drm_encoder *encoder)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void msm_dp_irq_postinstall(struct msm_dp *dp_display)\n{\n}\n\nstatic inline void msm_dp_snapshot(struct msm_disp_state *disp_state, struct msm_dp *dp_display)\n{\n}\n\nstatic inline void msm_dp_debugfs_init(struct msm_dp *dp_display,\n\t\tstruct drm_minor *minor)\n{\n}\n\nstatic inline bool msm_dp_wide_bus_available(const struct msm_dp *dp_display)\n{\n\treturn false;\n}\n\n#endif\n\n#ifdef CONFIG_DRM_MSM_MDP4\nvoid msm_mdp4_register(void);\nvoid msm_mdp4_unregister(void);\n#else\nstatic inline void msm_mdp4_register(void) {}\nstatic inline void msm_mdp4_unregister(void) {}\n#endif\n\n#ifdef CONFIG_DRM_MSM_MDP5\nvoid msm_mdp_register(void);\nvoid msm_mdp_unregister(void);\n#else\nstatic inline void msm_mdp_register(void) {}\nstatic inline void msm_mdp_unregister(void) {}\n#endif\n\n#ifdef CONFIG_DRM_MSM_DPU\nvoid msm_dpu_register(void);\nvoid msm_dpu_unregister(void);\n#else\nstatic inline void msm_dpu_register(void) {}\nstatic inline void msm_dpu_unregister(void) {}\n#endif\n\n#ifdef CONFIG_DRM_MSM_MDSS\nvoid msm_mdss_register(void);\nvoid msm_mdss_unregister(void);\n#else\nstatic inline void msm_mdss_register(void) {}\nstatic inline void msm_mdss_unregister(void) {}\n#endif\n\n#ifdef CONFIG_DEBUG_FS\nvoid msm_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m);\nint msm_debugfs_late_init(struct drm_device *dev);\nint msm_rd_debugfs_init(struct drm_minor *minor);\nvoid msm_rd_debugfs_cleanup(struct msm_drm_private *priv);\n__printf(3, 4)\nvoid msm_rd_dump_submit(struct msm_rd_state *rd, struct msm_gem_submit *submit,\n\t\tconst char *fmt, ...);\nint msm_perf_debugfs_init(struct drm_minor *minor);\nvoid msm_perf_debugfs_cleanup(struct msm_drm_private *priv);\n#else\nstatic inline int msm_debugfs_late_init(struct drm_device *dev) { return 0; }\n__printf(3, 4)\nstatic inline void msm_rd_dump_submit(struct msm_rd_state *rd,\n\t\t\tstruct msm_gem_submit *submit,\n\t\t\tconst char *fmt, ...) {}\nstatic inline void msm_rd_debugfs_cleanup(struct msm_drm_private *priv) {}\nstatic inline void msm_perf_debugfs_cleanup(struct msm_drm_private *priv) {}\n#endif\n\nstruct clk *msm_clk_get(struct platform_device *pdev, const char *name);\n\nstruct clk *msm_clk_bulk_get_clock(struct clk_bulk_data *bulk, int count,\n\tconst char *name);\nvoid __iomem *msm_ioremap(struct platform_device *pdev, const char *name);\nvoid __iomem *msm_ioremap_size(struct platform_device *pdev, const char *name,\n\t\tphys_addr_t *size);\nvoid __iomem *msm_ioremap_quiet(struct platform_device *pdev, const char *name);\n\nstruct icc_path *msm_icc_get(struct device *dev, const char *name);\n\n#define msm_writel(data, addr) writel((data), (addr))\n#define msm_readl(addr) readl((addr))\n\nstatic inline void msm_rmw(void __iomem *addr, u32 mask, u32 or)\n{\n\tu32 val = msm_readl(addr);\n\n\tval &= ~mask;\n\tmsm_writel(val | or, addr);\n}\n\n \nstruct msm_hrtimer_work {\n\tstruct hrtimer timer;\n\tstruct kthread_work work;\n\tstruct kthread_worker *worker;\n};\n\nvoid msm_hrtimer_queue_work(struct msm_hrtimer_work *work,\n\t\t\t    ktime_t wakeup_time,\n\t\t\t    enum hrtimer_mode mode);\nvoid msm_hrtimer_work_init(struct msm_hrtimer_work *work,\n\t\t\t   struct kthread_worker *worker,\n\t\t\t   kthread_work_func_t fn,\n\t\t\t   clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode);\n\n#define DBG(fmt, ...) DRM_DEBUG_DRIVER(fmt\"\\n\", ##__VA_ARGS__)\n#define VERB(fmt, ...) if (0) DRM_DEBUG_DRIVER(fmt\"\\n\", ##__VA_ARGS__)\n\nstatic inline int align_pitch(int width, int bpp)\n{\n\tint bytespp = (bpp + 7) / 8;\n\t \n\treturn bytespp * ALIGN(width, 32);\n}\n\n \n#define INVALID_IDX(idx) ({BUG(); 0;})\n#define fui(x)                ({BUG(); 0;})\n#define _mesa_float_to_half(x) ({BUG(); 0;})\n\n\n#define FIELD(val, name) (((val) & name ## __MASK) >> name ## __SHIFT)\n\n \n#define COND(bool, val) ((bool) ? (val) : 0)\n\nstatic inline unsigned long timeout_to_jiffies(const ktime_t *timeout)\n{\n\tktime_t now = ktime_get();\n\ts64 remaining_jiffies;\n\n\tif (ktime_compare(*timeout, now) < 0) {\n\t\tremaining_jiffies = 0;\n\t} else {\n\t\tktime_t rem = ktime_sub(*timeout, now);\n\t\tremaining_jiffies = ktime_divns(rem, NSEC_PER_SEC / HZ);\n\t}\n\n\treturn clamp(remaining_jiffies, 1LL, (s64)INT_MAX);\n}\n\n \n\nextern const struct component_master_ops msm_drm_ops;\n\nint msm_pm_prepare(struct device *dev);\nvoid msm_pm_complete(struct device *dev);\n\nint msm_drv_probe(struct device *dev,\n\tint (*kms_init)(struct drm_device *dev));\nvoid msm_drv_shutdown(struct platform_device *pdev);\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}