{
  "module_name": "msm_atomic.c",
  "hash_id": "a95ec54f425a13fe89c8432beab04c93ee6c148c3870b2a7603999a4b7b75955",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_atomic.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_vblank.h>\n\n#include \"msm_atomic_trace.h\"\n#include \"msm_drv.h\"\n#include \"msm_gem.h\"\n#include \"msm_kms.h\"\n\n \n\nstatic void vblank_get(struct msm_kms *kms, unsigned crtc_mask)\n{\n\tstruct drm_crtc *crtc;\n\n\tfor_each_crtc_mask(kms->dev, crtc, crtc_mask) {\n\t\tif (!crtc->state->active)\n\t\t\tcontinue;\n\t\tdrm_crtc_vblank_get(crtc);\n\t}\n}\n\nstatic void vblank_put(struct msm_kms *kms, unsigned crtc_mask)\n{\n\tstruct drm_crtc *crtc;\n\n\tfor_each_crtc_mask(kms->dev, crtc, crtc_mask) {\n\t\tif (!crtc->state->active)\n\t\t\tcontinue;\n\t\tdrm_crtc_vblank_put(crtc);\n\t}\n}\n\nstatic void lock_crtcs(struct msm_kms *kms, unsigned int crtc_mask)\n{\n\tint crtc_index;\n\tstruct drm_crtc *crtc;\n\n\tfor_each_crtc_mask(kms->dev, crtc, crtc_mask) {\n\t\tcrtc_index = drm_crtc_index(crtc);\n\t\tmutex_lock_nested(&kms->commit_lock[crtc_index], crtc_index);\n\t}\n}\n\nstatic void unlock_crtcs(struct msm_kms *kms, unsigned int crtc_mask)\n{\n\tstruct drm_crtc *crtc;\n\n\tfor_each_crtc_mask_reverse(kms->dev, crtc, crtc_mask)\n\t\tmutex_unlock(&kms->commit_lock[drm_crtc_index(crtc)]);\n}\n\nstatic void msm_atomic_async_commit(struct msm_kms *kms, int crtc_idx)\n{\n\tunsigned crtc_mask = BIT(crtc_idx);\n\n\ttrace_msm_atomic_async_commit_start(crtc_mask);\n\n\tlock_crtcs(kms, crtc_mask);\n\n\tif (!(kms->pending_crtc_mask & crtc_mask)) {\n\t\tunlock_crtcs(kms, crtc_mask);\n\t\tgoto out;\n\t}\n\n\tkms->pending_crtc_mask &= ~crtc_mask;\n\n\tkms->funcs->enable_commit(kms);\n\n\tvblank_get(kms, crtc_mask);\n\n\t \n\ttrace_msm_atomic_flush_commit(crtc_mask);\n\tkms->funcs->flush_commit(kms, crtc_mask);\n\n\t \n\ttrace_msm_atomic_wait_flush_start(crtc_mask);\n\tkms->funcs->wait_flush(kms, crtc_mask);\n\ttrace_msm_atomic_wait_flush_finish(crtc_mask);\n\n\tvblank_put(kms, crtc_mask);\n\n\tkms->funcs->complete_commit(kms, crtc_mask);\n\tunlock_crtcs(kms, crtc_mask);\n\tkms->funcs->disable_commit(kms);\n\nout:\n\ttrace_msm_atomic_async_commit_finish(crtc_mask);\n}\n\nstatic void msm_atomic_pending_work(struct kthread_work *work)\n{\n\tstruct msm_pending_timer *timer = container_of(work,\n\t\t\tstruct msm_pending_timer, work.work);\n\n\tmsm_atomic_async_commit(timer->kms, timer->crtc_idx);\n}\n\nint msm_atomic_init_pending_timer(struct msm_pending_timer *timer,\n\t\tstruct msm_kms *kms, int crtc_idx)\n{\n\ttimer->kms = kms;\n\ttimer->crtc_idx = crtc_idx;\n\n\ttimer->worker = kthread_create_worker(0, \"atomic-worker-%d\", crtc_idx);\n\tif (IS_ERR(timer->worker)) {\n\t\tint ret = PTR_ERR(timer->worker);\n\t\ttimer->worker = NULL;\n\t\treturn ret;\n\t}\n\tsched_set_fifo(timer->worker->task);\n\n\tmsm_hrtimer_work_init(&timer->work, timer->worker,\n\t\t\t      msm_atomic_pending_work,\n\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\n\treturn 0;\n}\n\nvoid msm_atomic_destroy_pending_timer(struct msm_pending_timer *timer)\n{\n\tif (timer->worker)\n\t\tkthread_destroy_worker(timer->worker);\n}\n\nstatic bool can_do_async(struct drm_atomic_state *state,\n\t\tstruct drm_crtc **async_crtc)\n{\n\tstruct drm_connector_state *connector_state;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc;\n\tint i, num_crtcs = 0;\n\n\tif (!(state->legacy_cursor_update || state->async_update))\n\t\treturn false;\n\n\t \n\tfor_each_new_connector_in_state(state, connector, connector_state, i)\n\t\treturn false;\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (drm_atomic_crtc_needs_modeset(crtc_state))\n\t\t\treturn false;\n\t\tif (!crtc_state->active)\n\t\t\treturn false;\n\t\tif (++num_crtcs > 1)\n\t\t\treturn false;\n\t\t*async_crtc = crtc;\n\t}\n\n\treturn true;\n}\n\n \nstatic unsigned get_crtc_mask(struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc;\n\tunsigned i, mask = 0;\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i)\n\t\tmask |= drm_crtc_mask(crtc);\n\n\treturn mask;\n}\n\nint msm_atomic_check(struct drm_device *dev, struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\tint i;\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t      new_crtc_state, i) {\n\t\tif ((old_crtc_state->ctm && !new_crtc_state->ctm) ||\n\t\t    (!old_crtc_state->ctm && new_crtc_state->ctm)) {\n\t\t\tnew_crtc_state->mode_changed = true;\n\t\t\tstate->allow_modeset = true;\n\t\t}\n\t}\n\n\treturn drm_atomic_helper_check(dev, state);\n}\n\nvoid msm_atomic_commit_tail(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct msm_kms *kms = priv->kms;\n\tstruct drm_crtc *async_crtc = NULL;\n\tunsigned crtc_mask = get_crtc_mask(state);\n\tbool async = can_do_async(state, &async_crtc);\n\n\ttrace_msm_atomic_commit_tail_start(async, crtc_mask);\n\n\tkms->funcs->enable_commit(kms);\n\n\t \n\tlock_crtcs(kms, crtc_mask);\n\ttrace_msm_atomic_wait_flush_start(crtc_mask);\n\tkms->funcs->wait_flush(kms, crtc_mask);\n\ttrace_msm_atomic_wait_flush_finish(crtc_mask);\n\n\t \n\tif (kms->funcs->prepare_commit)\n\t\tkms->funcs->prepare_commit(kms, state);\n\n\t \n\tdrm_atomic_helper_commit_modeset_disables(dev, state);\n\tdrm_atomic_helper_commit_planes(dev, state, 0);\n\tdrm_atomic_helper_commit_modeset_enables(dev, state);\n\n\tif (async) {\n\t\tstruct msm_pending_timer *timer =\n\t\t\t&kms->pending_timers[drm_crtc_index(async_crtc)];\n\n\t\t \n\t\tWARN_ON(crtc_mask != drm_crtc_mask(async_crtc));\n\n\t\t \n\t\tif (!(kms->pending_crtc_mask & crtc_mask)) {\n\t\t\tktime_t vsync_time, wakeup_time;\n\n\t\t\tkms->pending_crtc_mask |= crtc_mask;\n\n\t\t\tif (drm_crtc_next_vblank_start(async_crtc, &vsync_time))\n\t\t\t\tgoto fallback;\n\n\t\t\twakeup_time = ktime_sub(vsync_time, ms_to_ktime(1));\n\n\t\t\tmsm_hrtimer_queue_work(&timer->work, wakeup_time,\n\t\t\t\t\tHRTIMER_MODE_ABS);\n\t\t}\n\n\t\tkms->funcs->disable_commit(kms);\n\t\tunlock_crtcs(kms, crtc_mask);\n\t\t \n\t\tdrm_atomic_helper_commit_hw_done(state);\n\t\tdrm_atomic_helper_cleanup_planes(dev, state);\n\n\t\ttrace_msm_atomic_commit_tail_finish(async, crtc_mask);\n\n\t\treturn;\n\t}\n\nfallback:\n\t \n\tkms->pending_crtc_mask &= ~crtc_mask;\n\n\tvblank_get(kms, crtc_mask);\n\n\t \n\ttrace_msm_atomic_flush_commit(crtc_mask);\n\tkms->funcs->flush_commit(kms, crtc_mask);\n\tunlock_crtcs(kms, crtc_mask);\n\t \n\ttrace_msm_atomic_wait_flush_start(crtc_mask);\n\tkms->funcs->wait_flush(kms, crtc_mask);\n\ttrace_msm_atomic_wait_flush_finish(crtc_mask);\n\n\tvblank_put(kms, crtc_mask);\n\n\tlock_crtcs(kms, crtc_mask);\n\tkms->funcs->complete_commit(kms, crtc_mask);\n\tunlock_crtcs(kms, crtc_mask);\n\tkms->funcs->disable_commit(kms);\n\n\tdrm_atomic_helper_commit_hw_done(state);\n\tdrm_atomic_helper_cleanup_planes(dev, state);\n\n\ttrace_msm_atomic_commit_tail_finish(async, crtc_mask);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}