{
  "module_name": "msm_gem_vma.c",
  "hash_id": "70ad822fae07d676b4a94ba252a1e1833c2393e83edfae18209a5b8c3a4ecefa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_gem_vma.c",
  "human_readable_source": "\n \n\n#include \"msm_drv.h\"\n#include \"msm_fence.h\"\n#include \"msm_gem.h\"\n#include \"msm_mmu.h\"\n\nstatic void\nmsm_gem_address_space_destroy(struct kref *kref)\n{\n\tstruct msm_gem_address_space *aspace = container_of(kref,\n\t\t\tstruct msm_gem_address_space, kref);\n\n\tdrm_mm_takedown(&aspace->mm);\n\tif (aspace->mmu)\n\t\taspace->mmu->funcs->destroy(aspace->mmu);\n\tput_pid(aspace->pid);\n\tkfree(aspace);\n}\n\n\nvoid msm_gem_address_space_put(struct msm_gem_address_space *aspace)\n{\n\tif (aspace)\n\t\tkref_put(&aspace->kref, msm_gem_address_space_destroy);\n}\n\nstruct msm_gem_address_space *\nmsm_gem_address_space_get(struct msm_gem_address_space *aspace)\n{\n\tif (!IS_ERR_OR_NULL(aspace))\n\t\tkref_get(&aspace->kref);\n\n\treturn aspace;\n}\n\n \nvoid msm_gem_vma_purge(struct msm_gem_vma *vma)\n{\n\tstruct msm_gem_address_space *aspace = vma->aspace;\n\tunsigned size = vma->node.size;\n\n\t \n\tif (!vma->mapped)\n\t\treturn;\n\n\taspace->mmu->funcs->unmap(aspace->mmu, vma->iova, size);\n\n\tvma->mapped = false;\n}\n\n \nint\nmsm_gem_vma_map(struct msm_gem_vma *vma, int prot,\n\t\tstruct sg_table *sgt, int size)\n{\n\tstruct msm_gem_address_space *aspace = vma->aspace;\n\tint ret;\n\n\tif (GEM_WARN_ON(!vma->iova))\n\t\treturn -EINVAL;\n\n\tif (vma->mapped)\n\t\treturn 0;\n\n\tvma->mapped = true;\n\n\tif (!aspace)\n\t\treturn 0;\n\n\t \n\tret = aspace->mmu->funcs->map(aspace->mmu, vma->iova, sgt, size, prot);\n\n\tif (ret) {\n\t\tvma->mapped = false;\n\t}\n\n\treturn ret;\n}\n\n \nvoid msm_gem_vma_close(struct msm_gem_vma *vma)\n{\n\tstruct msm_gem_address_space *aspace = vma->aspace;\n\n\tGEM_WARN_ON(vma->mapped);\n\n\tspin_lock(&aspace->lock);\n\tif (vma->iova)\n\t\tdrm_mm_remove_node(&vma->node);\n\tspin_unlock(&aspace->lock);\n\n\tvma->iova = 0;\n\n\tmsm_gem_address_space_put(aspace);\n}\n\nstruct msm_gem_vma *msm_gem_vma_new(struct msm_gem_address_space *aspace)\n{\n\tstruct msm_gem_vma *vma;\n\n\tvma = kzalloc(sizeof(*vma), GFP_KERNEL);\n\tif (!vma)\n\t\treturn NULL;\n\n\tvma->aspace = aspace;\n\n\treturn vma;\n}\n\n \nint msm_gem_vma_init(struct msm_gem_vma *vma, int size,\n\t\tu64 range_start, u64 range_end)\n{\n\tstruct msm_gem_address_space *aspace = vma->aspace;\n\tint ret;\n\n\tif (GEM_WARN_ON(!aspace))\n\t\treturn -EINVAL;\n\n\tif (GEM_WARN_ON(vma->iova))\n\t\treturn -EBUSY;\n\n\tspin_lock(&aspace->lock);\n\tret = drm_mm_insert_node_in_range(&aspace->mm, &vma->node,\n\t\t\t\t\t  size, PAGE_SIZE, 0,\n\t\t\t\t\t  range_start, range_end, 0);\n\tspin_unlock(&aspace->lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tvma->iova = vma->node.start;\n\tvma->mapped = false;\n\n\tkref_get(&aspace->kref);\n\n\treturn 0;\n}\n\nstruct msm_gem_address_space *\nmsm_gem_address_space_create(struct msm_mmu *mmu, const char *name,\n\t\tu64 va_start, u64 size)\n{\n\tstruct msm_gem_address_space *aspace;\n\n\tif (IS_ERR(mmu))\n\t\treturn ERR_CAST(mmu);\n\n\taspace = kzalloc(sizeof(*aspace), GFP_KERNEL);\n\tif (!aspace)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&aspace->lock);\n\taspace->name = name;\n\taspace->mmu = mmu;\n\taspace->va_start = va_start;\n\taspace->va_size  = size;\n\n\tdrm_mm_init(&aspace->mm, va_start, size);\n\n\tkref_init(&aspace->kref);\n\n\treturn aspace;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}