{
  "module_name": "msm_fbdev.c",
  "hash_id": "6f718916db5d5b647e0030554a1810308be1b0a9d66e1d1a815378bfa0dd9f8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_fbdev.c",
  "human_readable_source": "\n \n\n#include <linux/fb.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_prime.h>\n\n#include \"msm_drv.h\"\n#include \"msm_gem.h\"\n#include \"msm_kms.h\"\n\nstatic bool fbdev = true;\nMODULE_PARM_DESC(fbdev, \"Enable fbdev compat layer\");\nmodule_param(fbdev, bool, 0600);\n\n \n\nFB_GEN_DEFAULT_DEFERRED_SYSMEM_OPS(msm_fbdev,\n\t\t\t\t   drm_fb_helper_damage_range,\n\t\t\t\t   drm_fb_helper_damage_area)\n\nstatic int msm_fbdev_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct drm_fb_helper *helper = (struct drm_fb_helper *)info->par;\n\tstruct drm_gem_object *bo = msm_framebuffer_bo(helper->fb, 0);\n\n\treturn drm_gem_prime_mmap(bo, vma);\n}\n\nstatic void msm_fbdev_fb_destroy(struct fb_info *info)\n{\n\tstruct drm_fb_helper *helper = (struct drm_fb_helper *)info->par;\n\tstruct drm_framebuffer *fb = helper->fb;\n\tstruct drm_gem_object *bo = msm_framebuffer_bo(fb, 0);\n\n\tDBG();\n\n\tdrm_fb_helper_fini(helper);\n\n\t \n\tmsm_gem_put_vaddr(bo);\n\tdrm_framebuffer_remove(fb);\n\n\tdrm_client_release(&helper->client);\n\tdrm_fb_helper_unprepare(helper);\n\tkfree(helper);\n}\n\nstatic const struct fb_ops msm_fb_ops = {\n\t.owner = THIS_MODULE,\n\t__FB_DEFAULT_DEFERRED_OPS_RDWR(msm_fbdev),\n\tDRM_FB_HELPER_DEFAULT_OPS,\n\t__FB_DEFAULT_DEFERRED_OPS_DRAW(msm_fbdev),\n\t.fb_mmap = msm_fbdev_mmap,\n\t.fb_destroy = msm_fbdev_fb_destroy,\n};\n\nstatic int msm_fbdev_create(struct drm_fb_helper *helper,\n\t\tstruct drm_fb_helper_surface_size *sizes)\n{\n\tstruct drm_device *dev = helper->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_gem_object *bo;\n\tstruct fb_info *fbi = NULL;\n\tuint64_t paddr;\n\tuint32_t format;\n\tint ret, pitch;\n\n\tformat = drm_mode_legacy_fb_format(sizes->surface_bpp, sizes->surface_depth);\n\n\tDBG(\"create fbdev: %dx%d@%d (%dx%d)\", sizes->surface_width,\n\t\t\tsizes->surface_height, sizes->surface_bpp,\n\t\t\tsizes->fb_width, sizes->fb_height);\n\n\tpitch = align_pitch(sizes->surface_width, sizes->surface_bpp);\n\tfb = msm_alloc_stolen_fb(dev, sizes->surface_width,\n\t\t\tsizes->surface_height, pitch, format);\n\n\tif (IS_ERR(fb)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to allocate fb\\n\");\n\t\treturn PTR_ERR(fb);\n\t}\n\n\tbo = msm_framebuffer_bo(fb, 0);\n\n\t \n\tret = msm_gem_get_and_pin_iova(bo, priv->kms->aspace, &paddr);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to get buffer obj iova: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tfbi = drm_fb_helper_alloc_info(helper);\n\tif (IS_ERR(fbi)) {\n\t\tDRM_DEV_ERROR(dev->dev, \"failed to allocate fb info\\n\");\n\t\tret = PTR_ERR(fbi);\n\t\tgoto fail;\n\t}\n\n\tDBG(\"fbi=%p, dev=%p\", fbi, dev);\n\n\thelper->fb = fb;\n\n\tfbi->fbops = &msm_fb_ops;\n\n\tdrm_fb_helper_fill_info(fbi, helper, sizes);\n\n\tfbi->screen_buffer = msm_gem_get_vaddr(bo);\n\tif (IS_ERR(fbi->screen_buffer)) {\n\t\tret = PTR_ERR(fbi->screen_buffer);\n\t\tgoto fail;\n\t}\n\tfbi->screen_size = bo->size;\n\tfbi->fix.smem_start = paddr;\n\tfbi->fix.smem_len = bo->size;\n\n\tDBG(\"par=%p, %dx%d\", fbi->par, fbi->var.xres, fbi->var.yres);\n\tDBG(\"allocated %dx%d fb\", fb->width, fb->height);\n\n\treturn 0;\n\nfail:\n\tdrm_framebuffer_remove(fb);\n\treturn ret;\n}\n\nstatic int msm_fbdev_fb_dirty(struct drm_fb_helper *helper,\n\t\t\t      struct drm_clip_rect *clip)\n{\n\tstruct drm_device *dev = helper->dev;\n\tint ret;\n\n\t \n\tif (!(clip->x1 < clip->x2 && clip->y1 < clip->y2))\n\t\treturn 0;\n\n\tif (helper->fb->funcs->dirty) {\n\t\tret = helper->fb->funcs->dirty(helper->fb, NULL, 0, 0, clip, 1);\n\t\tif (drm_WARN_ONCE(dev, ret, \"Dirty helper failed: ret=%d\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_fb_helper_funcs msm_fb_helper_funcs = {\n\t.fb_probe = msm_fbdev_create,\n\t.fb_dirty = msm_fbdev_fb_dirty,\n};\n\n \n\nstatic void msm_fbdev_client_unregister(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);\n\n\tif (fb_helper->info) {\n\t\tdrm_fb_helper_unregister_info(fb_helper);\n\t} else {\n\t\tdrm_client_release(&fb_helper->client);\n\t\tdrm_fb_helper_unprepare(fb_helper);\n\t\tkfree(fb_helper);\n\t}\n}\n\nstatic int msm_fbdev_client_restore(struct drm_client_dev *client)\n{\n\tdrm_fb_helper_lastclose(client->dev);\n\n\treturn 0;\n}\n\nstatic int msm_fbdev_client_hotplug(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);\n\tstruct drm_device *dev = client->dev;\n\tint ret;\n\n\tif (dev->fb_helper)\n\t\treturn drm_fb_helper_hotplug_event(dev->fb_helper);\n\n\tret = drm_fb_helper_init(dev, fb_helper);\n\tif (ret)\n\t\tgoto err_drm_err;\n\n\tif (!drm_drv_uses_atomic_modeset(dev))\n\t\tdrm_helper_disable_unused_functions(dev);\n\n\tret = drm_fb_helper_initial_config(fb_helper);\n\tif (ret)\n\t\tgoto err_drm_fb_helper_fini;\n\n\treturn 0;\n\nerr_drm_fb_helper_fini:\n\tdrm_fb_helper_fini(fb_helper);\nerr_drm_err:\n\tdrm_err(dev, \"Failed to setup fbdev emulation (ret=%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct drm_client_funcs msm_fbdev_client_funcs = {\n\t.owner\t\t= THIS_MODULE,\n\t.unregister\t= msm_fbdev_client_unregister,\n\t.restore\t= msm_fbdev_client_restore,\n\t.hotplug\t= msm_fbdev_client_hotplug,\n};\n\n \nvoid msm_fbdev_setup(struct drm_device *dev)\n{\n\tstruct drm_fb_helper *helper;\n\tint ret;\n\n\tif (!fbdev)\n\t\treturn;\n\n\tdrm_WARN(dev, !dev->registered, \"Device has not been registered.\\n\");\n\tdrm_WARN(dev, dev->fb_helper, \"fb_helper is already set!\\n\");\n\n\thelper = kzalloc(sizeof(*helper), GFP_KERNEL);\n\tif (!helper)\n\t\treturn;\n\tdrm_fb_helper_prepare(dev, helper, 32, &msm_fb_helper_funcs);\n\n\tret = drm_client_init(dev, &helper->client, \"fbdev\", &msm_fbdev_client_funcs);\n\tif (ret) {\n\t\tdrm_err(dev, \"Failed to register client: %d\\n\", ret);\n\t\tgoto err_drm_fb_helper_unprepare;\n\t}\n\n\tdrm_client_register(&helper->client);\n\n\treturn;\n\nerr_drm_fb_helper_unprepare:\n\tdrm_fb_helper_unprepare(helper);\n\tkfree(helper);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}