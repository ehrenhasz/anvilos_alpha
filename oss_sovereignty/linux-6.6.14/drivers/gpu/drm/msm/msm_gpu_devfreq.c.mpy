{
  "module_name": "msm_gpu_devfreq.c",
  "hash_id": "c9b25a56f3572c4fb9c342feda8cddc38c774784e632bd0f30a15264a7a2c9d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_gpu_devfreq.c",
  "human_readable_source": "\n \n\n#include \"msm_gpu.h\"\n#include \"msm_gpu_trace.h\"\n\n#include <linux/devfreq.h>\n#include <linux/devfreq_cooling.h>\n#include <linux/math64.h>\n#include <linux/units.h>\n\n \n\nstatic int msm_devfreq_target(struct device *dev, unsigned long *freq,\n\t\tu32 flags)\n{\n\tstruct msm_gpu *gpu = dev_to_gpu(dev);\n\tstruct msm_gpu_devfreq *df = &gpu->devfreq;\n\tstruct dev_pm_opp *opp;\n\n\t \n\topp = devfreq_recommended_opp(dev, freq, flags);\n\tif (IS_ERR(opp))\n\t\treturn PTR_ERR(opp);\n\n\ttrace_msm_gpu_freq_change(dev_pm_opp_get_freq(opp));\n\n\t \n\tif (df->idle_freq) {\n\t\tdf->idle_freq = *freq;\n\t\tdev_pm_opp_put(opp);\n\t\treturn 0;\n\t}\n\n\tif (gpu->funcs->gpu_set_freq) {\n\t\tmutex_lock(&df->lock);\n\t\tgpu->funcs->gpu_set_freq(gpu, opp, df->suspended);\n\t\tmutex_unlock(&df->lock);\n\t} else {\n\t\tdev_pm_opp_set_rate(dev, *freq);\n\t}\n\n\tdev_pm_opp_put(opp);\n\n\treturn 0;\n}\n\nstatic unsigned long get_freq(struct msm_gpu *gpu)\n{\n\tstruct msm_gpu_devfreq *df = &gpu->devfreq;\n\n\t \n\tif (df->idle_freq)\n\t\treturn df->idle_freq;\n\n\tif (gpu->funcs->gpu_get_freq)\n\t\treturn gpu->funcs->gpu_get_freq(gpu);\n\n\treturn clk_get_rate(gpu->core_clk);\n}\n\nstatic int msm_devfreq_get_dev_status(struct device *dev,\n\t\tstruct devfreq_dev_status *status)\n{\n\tstruct msm_gpu *gpu = dev_to_gpu(dev);\n\tstruct msm_gpu_devfreq *df = &gpu->devfreq;\n\tu64 busy_cycles, busy_time;\n\tunsigned long sample_rate;\n\tktime_t time;\n\n\tmutex_lock(&df->lock);\n\n\tstatus->current_frequency = get_freq(gpu);\n\ttime = ktime_get();\n\tstatus->total_time = ktime_us_delta(time, df->time);\n\tdf->time = time;\n\n\tif (df->suspended) {\n\t\tmutex_unlock(&df->lock);\n\t\tstatus->busy_time = 0;\n\t\treturn 0;\n\t}\n\n\tbusy_cycles = gpu->funcs->gpu_busy(gpu, &sample_rate);\n\tbusy_time = busy_cycles - df->busy_cycles;\n\tdf->busy_cycles = busy_cycles;\n\n\tmutex_unlock(&df->lock);\n\n\tbusy_time *= USEC_PER_SEC;\n\tbusy_time = div64_ul(busy_time, sample_rate);\n\tif (WARN_ON(busy_time > ~0LU))\n\t\tbusy_time = ~0LU;\n\n\tstatus->busy_time = busy_time;\n\n\treturn 0;\n}\n\nstatic int msm_devfreq_get_cur_freq(struct device *dev, unsigned long *freq)\n{\n\t*freq = get_freq(dev_to_gpu(dev));\n\n\treturn 0;\n}\n\nstatic struct devfreq_dev_profile msm_devfreq_profile = {\n\t.timer = DEVFREQ_TIMER_DELAYED,\n\t.polling_ms = 50,\n\t.target = msm_devfreq_target,\n\t.get_dev_status = msm_devfreq_get_dev_status,\n\t.get_cur_freq = msm_devfreq_get_cur_freq,\n};\n\nstatic void msm_devfreq_boost_work(struct kthread_work *work);\nstatic void msm_devfreq_idle_work(struct kthread_work *work);\n\nstatic bool has_devfreq(struct msm_gpu *gpu)\n{\n\tstruct msm_gpu_devfreq *df = &gpu->devfreq;\n\treturn !!df->devfreq;\n}\n\nvoid msm_devfreq_init(struct msm_gpu *gpu)\n{\n\tstruct msm_gpu_devfreq *df = &gpu->devfreq;\n\tstruct msm_drm_private *priv = gpu->dev->dev_private;\n\n\t \n\tif (!gpu->funcs->gpu_busy)\n\t\treturn;\n\n\t \n\tpriv->gpu_devfreq_config.upthreshold = 50;\n\tpriv->gpu_devfreq_config.downdifferential = 10;\n\n\tmutex_init(&df->lock);\n\n\tdev_pm_qos_add_request(&gpu->pdev->dev, &df->boost_freq,\n\t\t\t       DEV_PM_QOS_MIN_FREQUENCY, 0);\n\n\tmsm_devfreq_profile.initial_freq = gpu->fast_rate;\n\n\t \n\tmsm_devfreq_profile.freq_table = NULL;\n\tmsm_devfreq_profile.max_state = 0;\n\n\tdf->devfreq = devm_devfreq_add_device(&gpu->pdev->dev,\n\t\t\t&msm_devfreq_profile, DEVFREQ_GOV_SIMPLE_ONDEMAND,\n\t\t\t&priv->gpu_devfreq_config);\n\n\tif (IS_ERR(df->devfreq)) {\n\t\tDRM_DEV_ERROR(&gpu->pdev->dev, \"Couldn't initialize GPU devfreq\\n\");\n\t\tdev_pm_qos_remove_request(&df->boost_freq);\n\t\tdf->devfreq = NULL;\n\t\treturn;\n\t}\n\n\tdevfreq_suspend_device(df->devfreq);\n\n\tgpu->cooling = of_devfreq_cooling_register(gpu->pdev->dev.of_node, df->devfreq);\n\tif (IS_ERR(gpu->cooling)) {\n\t\tDRM_DEV_ERROR(&gpu->pdev->dev,\n\t\t\t\t\"Couldn't register GPU cooling device\\n\");\n\t\tgpu->cooling = NULL;\n\t}\n\n\tmsm_hrtimer_work_init(&df->boost_work, gpu->worker, msm_devfreq_boost_work,\n\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tmsm_hrtimer_work_init(&df->idle_work, gpu->worker, msm_devfreq_idle_work,\n\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n}\n\nstatic void cancel_idle_work(struct msm_gpu_devfreq *df)\n{\n\thrtimer_cancel(&df->idle_work.timer);\n\tkthread_cancel_work_sync(&df->idle_work.work);\n}\n\nstatic void cancel_boost_work(struct msm_gpu_devfreq *df)\n{\n\thrtimer_cancel(&df->boost_work.timer);\n\tkthread_cancel_work_sync(&df->boost_work.work);\n}\n\nvoid msm_devfreq_cleanup(struct msm_gpu *gpu)\n{\n\tstruct msm_gpu_devfreq *df = &gpu->devfreq;\n\n\tif (!has_devfreq(gpu))\n\t\treturn;\n\n\tdevfreq_cooling_unregister(gpu->cooling);\n\tdev_pm_qos_remove_request(&df->boost_freq);\n}\n\nvoid msm_devfreq_resume(struct msm_gpu *gpu)\n{\n\tstruct msm_gpu_devfreq *df = &gpu->devfreq;\n\tunsigned long sample_rate;\n\n\tif (!has_devfreq(gpu))\n\t\treturn;\n\n\tmutex_lock(&df->lock);\n\tdf->busy_cycles = gpu->funcs->gpu_busy(gpu, &sample_rate);\n\tdf->time = ktime_get();\n\tdf->suspended = false;\n\tmutex_unlock(&df->lock);\n\n\tdevfreq_resume_device(df->devfreq);\n}\n\nvoid msm_devfreq_suspend(struct msm_gpu *gpu)\n{\n\tstruct msm_gpu_devfreq *df = &gpu->devfreq;\n\n\tif (!has_devfreq(gpu))\n\t\treturn;\n\n\tmutex_lock(&df->lock);\n\tdf->suspended = true;\n\tmutex_unlock(&df->lock);\n\n\tdevfreq_suspend_device(df->devfreq);\n\n\tcancel_idle_work(df);\n\tcancel_boost_work(df);\n}\n\nstatic void msm_devfreq_boost_work(struct kthread_work *work)\n{\n\tstruct msm_gpu_devfreq *df = container_of(work,\n\t\t\tstruct msm_gpu_devfreq, boost_work.work);\n\n\tdev_pm_qos_update_request(&df->boost_freq, 0);\n}\n\nvoid msm_devfreq_boost(struct msm_gpu *gpu, unsigned factor)\n{\n\tstruct msm_gpu_devfreq *df = &gpu->devfreq;\n\tuint64_t freq;\n\n\tif (!has_devfreq(gpu))\n\t\treturn;\n\n\tfreq = get_freq(gpu);\n\tfreq *= factor;\n\n\t \n\tdo_div(freq, HZ_PER_KHZ);\n\n\tdev_pm_qos_update_request(&df->boost_freq, freq);\n\n\tmsm_hrtimer_queue_work(&df->boost_work,\n\t\t\t       ms_to_ktime(msm_devfreq_profile.polling_ms),\n\t\t\t       HRTIMER_MODE_REL);\n}\n\nvoid msm_devfreq_active(struct msm_gpu *gpu)\n{\n\tstruct msm_gpu_devfreq *df = &gpu->devfreq;\n\tunsigned int idle_time;\n\tunsigned long target_freq;\n\n\tif (!has_devfreq(gpu))\n\t\treturn;\n\n\t \n\tcancel_idle_work(df);\n\n\t \n\tmutex_lock(&df->devfreq->lock);\n\n\ttarget_freq = df->idle_freq;\n\n\tidle_time = ktime_to_ms(ktime_sub(ktime_get(), df->idle_time));\n\n\tdf->idle_freq = 0;\n\n\t \n\tif (target_freq)\n\t\tmsm_devfreq_target(&gpu->pdev->dev, &target_freq, 0);\n\n\tmutex_unlock(&df->devfreq->lock);\n\n\t \n\tif (idle_time > msm_devfreq_profile.polling_ms) {\n\t\tmsm_devfreq_boost(gpu, 2);\n\t}\n}\n\n\nstatic void msm_devfreq_idle_work(struct kthread_work *work)\n{\n\tstruct msm_gpu_devfreq *df = container_of(work,\n\t\t\tstruct msm_gpu_devfreq, idle_work.work);\n\tstruct msm_gpu *gpu = container_of(df, struct msm_gpu, devfreq);\n\tstruct msm_drm_private *priv = gpu->dev->dev_private;\n\tunsigned long idle_freq, target_freq = 0;\n\n\t \n\tmutex_lock(&df->devfreq->lock);\n\n\tidle_freq = get_freq(gpu);\n\n\tif (priv->gpu_clamp_to_idle)\n\t\tmsm_devfreq_target(&gpu->pdev->dev, &target_freq, 0);\n\n\tdf->idle_time = ktime_get();\n\tdf->idle_freq = idle_freq;\n\n\tmutex_unlock(&df->devfreq->lock);\n}\n\nvoid msm_devfreq_idle(struct msm_gpu *gpu)\n{\n\tstruct msm_gpu_devfreq *df = &gpu->devfreq;\n\n\tif (!has_devfreq(gpu))\n\t\treturn;\n\n\tmsm_hrtimer_queue_work(&df->idle_work, ms_to_ktime(1),\n\t\t\t       HRTIMER_MODE_REL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}