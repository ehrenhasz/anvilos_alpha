{
  "module_name": "a6xx_gpu.h",
  "hash_id": "0b4104c57581a46ba0d7d4d8674189561f1ad0f5c773f1e0cb303c3b1e393164",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/adreno/a6xx_gpu.h",
  "human_readable_source": " \n \n\n#ifndef __A6XX_GPU_H__\n#define __A6XX_GPU_H__\n\n\n#include \"adreno_gpu.h\"\n#include \"a6xx.xml.h\"\n\n#include \"a6xx_gmu.h\"\n\nextern bool hang_debug;\n\nstruct a6xx_gpu {\n\tstruct adreno_gpu base;\n\n\tstruct drm_gem_object *sqe_bo;\n\tuint64_t sqe_iova;\n\n\tstruct msm_ringbuffer *cur_ring;\n\n\tstruct a6xx_gmu gmu;\n\n\tstruct drm_gem_object *shadow_bo;\n\tuint64_t shadow_iova;\n\tuint32_t *shadow;\n\n\tbool has_whereami;\n\n\tvoid __iomem *llc_mmio;\n\tvoid *llc_slice;\n\tvoid *htw_llc_slice;\n\tbool have_mmu500;\n\tbool hung;\n};\n\n#define to_a6xx_gpu(x) container_of(x, struct a6xx_gpu, base)\n\n \n#define A6XX_PROTECT_NORDWR(_reg, _len) \\\n\t((1 << 31) | \\\n\t(((_len) & 0x3FFF) << 18) | ((_reg) & 0x3FFFF))\n\n \n#define A6XX_PROTECT_RDONLY(_reg, _len) \\\n\t((((_len) & 0x3FFF) << 18) | ((_reg) & 0x3FFFF))\n\nstatic inline bool a6xx_has_gbif(struct adreno_gpu *gpu)\n{\n\tif(adreno_is_a630(gpu))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline void a6xx_llc_rmw(struct a6xx_gpu *a6xx_gpu, u32 reg, u32 mask, u32 or)\n{\n\treturn msm_rmw(a6xx_gpu->llc_mmio + (reg << 2), mask, or);\n}\n\nstatic inline u32 a6xx_llc_read(struct a6xx_gpu *a6xx_gpu, u32 reg)\n{\n\treturn msm_readl(a6xx_gpu->llc_mmio + (reg << 2));\n}\n\nstatic inline void a6xx_llc_write(struct a6xx_gpu *a6xx_gpu, u32 reg, u32 value)\n{\n\tmsm_writel(value, a6xx_gpu->llc_mmio + (reg << 2));\n}\n\n#define shadowptr(_a6xx_gpu, _ring) ((_a6xx_gpu)->shadow_iova + \\\n\t\t((_ring)->id * sizeof(uint32_t)))\n\nint a6xx_gmu_resume(struct a6xx_gpu *gpu);\nint a6xx_gmu_stop(struct a6xx_gpu *gpu);\n\nint a6xx_gmu_wait_for_idle(struct a6xx_gmu *gmu);\n\nbool a6xx_gmu_isidle(struct a6xx_gmu *gmu);\n\nint a6xx_gmu_set_oob(struct a6xx_gmu *gmu, enum a6xx_gmu_oob_state state);\nvoid a6xx_gmu_clear_oob(struct a6xx_gmu *gmu, enum a6xx_gmu_oob_state state);\n\nint a6xx_gmu_init(struct a6xx_gpu *a6xx_gpu, struct device_node *node);\nint a6xx_gmu_wrapper_init(struct a6xx_gpu *a6xx_gpu, struct device_node *node);\nvoid a6xx_gmu_remove(struct a6xx_gpu *a6xx_gpu);\n\nvoid a6xx_gmu_set_freq(struct msm_gpu *gpu, struct dev_pm_opp *opp,\n\t\t       bool suspended);\nunsigned long a6xx_gmu_get_freq(struct msm_gpu *gpu);\n\nvoid a6xx_show(struct msm_gpu *gpu, struct msm_gpu_state *state,\n\t\tstruct drm_printer *p);\n\nstruct msm_gpu_state *a6xx_gpu_state_get(struct msm_gpu *gpu);\nint a6xx_gpu_state_put(struct msm_gpu_state *state);\n\nvoid a6xx_bus_clear_pending_transactions(struct adreno_gpu *adreno_gpu, bool gx_off);\nvoid a6xx_gpu_sw_reset(struct msm_gpu *gpu, bool assert);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}