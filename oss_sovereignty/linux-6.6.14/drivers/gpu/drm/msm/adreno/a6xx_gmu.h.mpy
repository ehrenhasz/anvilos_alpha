{
  "module_name": "a6xx_gmu.h",
  "hash_id": "46190736c58e0e0d8b2fb6f4602aaae3e641e0f9e793b7ddc6ec26daa225d667",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/adreno/a6xx_gmu.h",
  "human_readable_source": " \n \n\n#ifndef _A6XX_GMU_H_\n#define _A6XX_GMU_H_\n\n#include <linux/completion.h>\n#include <linux/iopoll.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include \"msm_drv.h\"\n#include \"a6xx_hfi.h\"\n\nstruct a6xx_gmu_bo {\n\tstruct drm_gem_object *obj;\n\tvoid *virt;\n\tsize_t size;\n\tu64 iova;\n};\n\n \n\n \n#define GMU_WARM_BOOT 0\n\n \n#define GMU_COLD_BOOT 1\n\n \n\n \n#define GMU_IDLE_STATE_ACTIVE 0\n\n \n#define GMU_IDLE_STATE_SPTP 2\n\n \n#define GMU_IDLE_STATE_IFPC 3\n\nstruct a6xx_gmu {\n\tstruct device *dev;\n\n\t \n\tstruct mutex lock;\n\n\tstruct msm_gem_address_space *aspace;\n\n\tvoid __iomem *mmio;\n\tvoid __iomem *rscc;\n\n\tint hfi_irq;\n\tint gmu_irq;\n\n\tstruct device *gxpd;\n\tstruct device *cxpd;\n\n\tint idle_level;\n\n\tstruct a6xx_gmu_bo hfi;\n\tstruct a6xx_gmu_bo debug;\n\tstruct a6xx_gmu_bo icache;\n\tstruct a6xx_gmu_bo dcache;\n\tstruct a6xx_gmu_bo dummy;\n\tstruct a6xx_gmu_bo log;\n\n\tint nr_clocks;\n\tstruct clk_bulk_data *clocks;\n\tstruct clk *core_clk;\n\tstruct clk *hub_clk;\n\n\t \n\tint current_perf_index;\n\n\tint nr_gpu_freqs;\n\tunsigned long gpu_freqs[16];\n\tu32 gx_arc_votes[16];\n\n\tint nr_gmu_freqs;\n\tunsigned long gmu_freqs[4];\n\tu32 cx_arc_votes[4];\n\n\tunsigned long freq;\n\n\tstruct a6xx_hfi_queue queues[2];\n\n\tbool initialized;\n\tbool hung;\n\tbool legacy;  \n\n\t \n\tstruct notifier_block pd_nb;\n\tstruct completion pd_gate;\n};\n\nstatic inline u32 gmu_read(struct a6xx_gmu *gmu, u32 offset)\n{\n\treturn msm_readl(gmu->mmio + (offset << 2));\n}\n\nstatic inline void gmu_write(struct a6xx_gmu *gmu, u32 offset, u32 value)\n{\n\tmsm_writel(value, gmu->mmio + (offset << 2));\n}\n\nstatic inline void\ngmu_write_bulk(struct a6xx_gmu *gmu, u32 offset, const u32 *data, u32 size)\n{\n\tmemcpy_toio(gmu->mmio + (offset << 2), data, size);\n\twmb();\n}\n\nstatic inline void gmu_rmw(struct a6xx_gmu *gmu, u32 reg, u32 mask, u32 or)\n{\n\tu32 val = gmu_read(gmu, reg);\n\n\tval &= ~mask;\n\n\tgmu_write(gmu, reg, val | or);\n}\n\nstatic inline u64 gmu_read64(struct a6xx_gmu *gmu, u32 lo, u32 hi)\n{\n\tu64 val;\n\n\tval = (u64) msm_readl(gmu->mmio + (lo << 2));\n\tval |= ((u64) msm_readl(gmu->mmio + (hi << 2)) << 32);\n\n\treturn val;\n}\n\n#define gmu_poll_timeout(gmu, addr, val, cond, interval, timeout) \\\n\treadl_poll_timeout((gmu)->mmio + ((addr) << 2), val, cond, \\\n\t\tinterval, timeout)\n\nstatic inline u32 gmu_read_rscc(struct a6xx_gmu *gmu, u32 offset)\n{\n\treturn msm_readl(gmu->rscc + (offset << 2));\n}\n\nstatic inline void gmu_write_rscc(struct a6xx_gmu *gmu, u32 offset, u32 value)\n{\n\tmsm_writel(value, gmu->rscc + (offset << 2));\n}\n\n#define gmu_poll_timeout_rscc(gmu, addr, val, cond, interval, timeout) \\\n\treadl_poll_timeout((gmu)->rscc + ((addr) << 2), val, cond, \\\n\t\tinterval, timeout)\n\n \n\nenum a6xx_gmu_oob_state {\n\t \n\tGMU_OOB_BOOT_SLUMBER = 0,\n\t \n\tGMU_OOB_GPU_SET,\n\t \n\tGMU_OOB_DCVS_SET,\n\t \n\tGMU_OOB_PERFCOUNTER_SET,\n};\n\nvoid a6xx_hfi_init(struct a6xx_gmu *gmu);\nint a6xx_hfi_start(struct a6xx_gmu *gmu, int boot_state);\nvoid a6xx_hfi_stop(struct a6xx_gmu *gmu);\nint a6xx_hfi_send_prep_slumber(struct a6xx_gmu *gmu);\nint a6xx_hfi_set_freq(struct a6xx_gmu *gmu, int index);\n\nbool a6xx_gmu_gx_is_on(struct a6xx_gmu *gmu);\nbool a6xx_gmu_sptprac_is_on(struct a6xx_gmu *gmu);\nvoid a6xx_sptprac_disable(struct a6xx_gmu *gmu);\nint a6xx_sptprac_enable(struct a6xx_gmu *gmu);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}