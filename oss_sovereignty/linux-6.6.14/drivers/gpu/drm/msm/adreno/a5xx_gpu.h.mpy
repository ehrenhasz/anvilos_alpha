{
  "module_name": "a5xx_gpu.h",
  "hash_id": "a220cc321f5f29db32b50438e1f3d314ad4d0c886a26928c43e76de2912878f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/adreno/a5xx_gpu.h",
  "human_readable_source": " \n \n#ifndef __A5XX_GPU_H__\n#define __A5XX_GPU_H__\n\n#include \"adreno_gpu.h\"\n\n \n#undef ROP_COPY\n#undef ROP_XOR\n\n#include \"a5xx.xml.h\"\n\nstruct a5xx_gpu {\n\tstruct adreno_gpu base;\n\n\tstruct drm_gem_object *pm4_bo;\n\tuint64_t pm4_iova;\n\n\tstruct drm_gem_object *pfp_bo;\n\tuint64_t pfp_iova;\n\n\tstruct drm_gem_object *gpmu_bo;\n\tuint64_t gpmu_iova;\n\tuint32_t gpmu_dwords;\n\n\tuint32_t lm_leakage;\n\n\tstruct msm_ringbuffer *cur_ring;\n\tstruct msm_ringbuffer *next_ring;\n\n\tstruct drm_gem_object *preempt_bo[MSM_GPU_MAX_RINGS];\n\tstruct drm_gem_object *preempt_counters_bo[MSM_GPU_MAX_RINGS];\n\tstruct a5xx_preempt_record *preempt[MSM_GPU_MAX_RINGS];\n\tuint64_t preempt_iova[MSM_GPU_MAX_RINGS];\n\n\tatomic_t preempt_state;\n\tstruct timer_list preempt_timer;\n\n\tstruct drm_gem_object *shadow_bo;\n\tuint64_t shadow_iova;\n\tuint32_t *shadow;\n\n\t \n\tbool has_whereami;\n};\n\n#define to_a5xx_gpu(x) container_of(x, struct a5xx_gpu, base)\n\n#ifdef CONFIG_DEBUG_FS\nvoid a5xx_debugfs_init(struct msm_gpu *gpu, struct drm_minor *minor);\n#endif\n\n \n\nenum preempt_state {\n\tPREEMPT_NONE = 0,\n\tPREEMPT_START,\n\tPREEMPT_ABORT,\n\tPREEMPT_TRIGGERED,\n\tPREEMPT_FAULTED,\n\tPREEMPT_PENDING,\n};\n\n \nstruct a5xx_preempt_record {\n\tuint32_t magic;\n\tuint32_t info;\n\tuint32_t data;\n\tuint32_t cntl;\n\tuint32_t rptr;\n\tuint32_t wptr;\n\tuint64_t rptr_addr;\n\tuint64_t rbase;\n\tuint64_t counter;\n};\n\n \n#define A5XX_PREEMPT_RECORD_MAGIC 0x27C4BAFCUL\n\n \n#define A5XX_PREEMPT_RECORD_SIZE (64 * 1024)\n\n \n#define A5XX_PREEMPT_COUNTER_SIZE (16 * 4)\n\n\nint a5xx_power_init(struct msm_gpu *gpu);\nvoid a5xx_gpmu_ucode_init(struct msm_gpu *gpu);\n\nstatic inline int spin_usecs(struct msm_gpu *gpu, uint32_t usecs,\n\t\tuint32_t reg, uint32_t mask, uint32_t value)\n{\n\twhile (usecs--) {\n\t\tudelay(1);\n\t\tif ((gpu_read(gpu, reg) & mask) == value)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n#define shadowptr(a5xx_gpu, ring) ((a5xx_gpu)->shadow_iova + \\\n\t\t((ring)->id * sizeof(uint32_t)))\n\nbool a5xx_idle(struct msm_gpu *gpu, struct msm_ringbuffer *ring);\nvoid a5xx_set_hwcg(struct msm_gpu *gpu, bool state);\n\nvoid a5xx_preempt_init(struct msm_gpu *gpu);\nvoid a5xx_preempt_hw_init(struct msm_gpu *gpu);\nvoid a5xx_preempt_trigger(struct msm_gpu *gpu);\nvoid a5xx_preempt_irq(struct msm_gpu *gpu);\nvoid a5xx_preempt_fini(struct msm_gpu *gpu);\n\nvoid a5xx_flush(struct msm_gpu *gpu, struct msm_ringbuffer *ring, bool sync);\n\n \nstatic inline bool a5xx_in_preempt(struct a5xx_gpu *a5xx_gpu)\n{\n\tint preempt_state = atomic_read(&a5xx_gpu->preempt_state);\n\n\treturn !(preempt_state == PREEMPT_NONE ||\n\t\t\tpreempt_state == PREEMPT_ABORT);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}