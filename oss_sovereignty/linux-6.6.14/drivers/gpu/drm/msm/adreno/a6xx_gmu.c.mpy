{
  "module_name": "a6xx_gmu.c",
  "hash_id": "1c4e48e10a42ef018ada45496b9c8f836aedf39117afab6e83e4b26575c518c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/adreno/a6xx_gmu.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interconnect.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_opp.h>\n#include <soc/qcom/cmd-db.h>\n#include <drm/drm_gem.h>\n\n#include \"a6xx_gpu.h\"\n#include \"a6xx_gmu.xml.h\"\n#include \"msm_gem.h\"\n#include \"msm_gpu_trace.h\"\n#include \"msm_mmu.h\"\n\nstatic void a6xx_gmu_fault(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_gpu *a6xx_gpu = container_of(gmu, struct a6xx_gpu, gmu);\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tstruct msm_gpu *gpu = &adreno_gpu->base;\n\n\t \n\tgmu->hung = true;\n\n\t \n\tdel_timer(&gpu->hangcheck_timer);\n\n\t \n\tkthread_queue_work(gpu->worker, &gpu->recover_work);\n}\n\nstatic irqreturn_t a6xx_gmu_irq(int irq, void *data)\n{\n\tstruct a6xx_gmu *gmu = data;\n\tu32 status;\n\n\tstatus = gmu_read(gmu, REG_A6XX_GMU_AO_HOST_INTERRUPT_STATUS);\n\tgmu_write(gmu, REG_A6XX_GMU_AO_HOST_INTERRUPT_CLR, status);\n\n\tif (status & A6XX_GMU_AO_HOST_INTERRUPT_STATUS_WDOG_BITE) {\n\t\tdev_err_ratelimited(gmu->dev, \"GMU watchdog expired\\n\");\n\n\t\ta6xx_gmu_fault(gmu);\n\t}\n\n\tif (status &  A6XX_GMU_AO_HOST_INTERRUPT_STATUS_HOST_AHB_BUS_ERROR)\n\t\tdev_err_ratelimited(gmu->dev, \"GMU AHB bus error\\n\");\n\n\tif (status & A6XX_GMU_AO_HOST_INTERRUPT_STATUS_FENCE_ERR)\n\t\tdev_err_ratelimited(gmu->dev, \"GMU fence error: 0x%x\\n\",\n\t\t\tgmu_read(gmu, REG_A6XX_GMU_AHB_FENCE_STATUS));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t a6xx_hfi_irq(int irq, void *data)\n{\n\tstruct a6xx_gmu *gmu = data;\n\tu32 status;\n\n\tstatus = gmu_read(gmu, REG_A6XX_GMU_GMU2HOST_INTR_INFO);\n\tgmu_write(gmu, REG_A6XX_GMU_GMU2HOST_INTR_CLR, status);\n\n\tif (status & A6XX_GMU_GMU2HOST_INTR_INFO_CM3_FAULT) {\n\t\tdev_err_ratelimited(gmu->dev, \"GMU firmware fault\\n\");\n\n\t\ta6xx_gmu_fault(gmu);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nbool a6xx_gmu_sptprac_is_on(struct a6xx_gmu *gmu)\n{\n\tu32 val;\n\n\t \n\tif (!gmu->initialized)\n\t\treturn false;\n\n\tval = gmu_read(gmu, REG_A6XX_GMU_SPTPRAC_PWR_CLK_STATUS);\n\n\treturn !(val &\n\t\t(A6XX_GMU_SPTPRAC_PWR_CLK_STATUS_SPTPRAC_GDSC_POWER_OFF |\n\t\tA6XX_GMU_SPTPRAC_PWR_CLK_STATUS_SP_CLOCK_OFF));\n}\n\n \nbool a6xx_gmu_gx_is_on(struct a6xx_gmu *gmu)\n{\n\tu32 val;\n\n\t \n\tif (!gmu->initialized)\n\t\treturn false;\n\n\tval = gmu_read(gmu, REG_A6XX_GMU_SPTPRAC_PWR_CLK_STATUS);\n\n\treturn !(val &\n\t\t(A6XX_GMU_SPTPRAC_PWR_CLK_STATUS_GX_HM_GDSC_POWER_OFF |\n\t\tA6XX_GMU_SPTPRAC_PWR_CLK_STATUS_GX_HM_CLK_OFF));\n}\n\nvoid a6xx_gmu_set_freq(struct msm_gpu *gpu, struct dev_pm_opp *opp,\n\t\t       bool suspended)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\tu32 perf_index;\n\tunsigned long gpu_freq;\n\tint ret = 0;\n\n\tgpu_freq = dev_pm_opp_get_freq(opp);\n\n\tif (gpu_freq == gmu->freq)\n\t\treturn;\n\n\tfor (perf_index = 0; perf_index < gmu->nr_gpu_freqs - 1; perf_index++)\n\t\tif (gpu_freq == gmu->gpu_freqs[perf_index])\n\t\t\tbreak;\n\n\tgmu->current_perf_index = perf_index;\n\tgmu->freq = gmu->gpu_freqs[perf_index];\n\n\ttrace_msm_gmu_freq_change(gmu->freq, perf_index);\n\n\t \n\tif (suspended)\n\t\treturn;\n\n\tif (!gmu->legacy) {\n\t\ta6xx_hfi_set_freq(gmu, perf_index);\n\t\tdev_pm_opp_set_opp(&gpu->pdev->dev, opp);\n\t\treturn;\n\t}\n\n\tgmu_write(gmu, REG_A6XX_GMU_DCVS_ACK_OPTION, 0);\n\n\tgmu_write(gmu, REG_A6XX_GMU_DCVS_PERF_SETTING,\n\t\t\t((3 & 0xf) << 28) | perf_index);\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_DCVS_BW_SETTING, 0xff);\n\n\t \n\ta6xx_gmu_set_oob(gmu, GMU_OOB_DCVS_SET);\n\ta6xx_gmu_clear_oob(gmu, GMU_OOB_DCVS_SET);\n\n\tret = gmu_read(gmu, REG_A6XX_GMU_DCVS_RETURN);\n\tif (ret)\n\t\tdev_err(gmu->dev, \"GMU set GPU frequency error: %d\\n\", ret);\n\n\tdev_pm_opp_set_opp(&gpu->pdev->dev, opp);\n}\n\nunsigned long a6xx_gmu_get_freq(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\n\treturn  gmu->freq;\n}\n\nstatic bool a6xx_gmu_check_idle_level(struct a6xx_gmu *gmu)\n{\n\tu32 val;\n\tint local = gmu->idle_level;\n\n\t \n\tif (gmu->idle_level == GMU_IDLE_STATE_SPTP)\n\t\tlocal = GMU_IDLE_STATE_IFPC;\n\n\tval = gmu_read(gmu, REG_A6XX_GPU_GMU_CX_GMU_RPMH_POWER_STATE);\n\n\tif (val == local) {\n\t\tif (gmu->idle_level != GMU_IDLE_STATE_IFPC ||\n\t\t\t!a6xx_gmu_gx_is_on(gmu))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nint a6xx_gmu_wait_for_idle(struct a6xx_gmu *gmu)\n{\n\treturn spin_until(a6xx_gmu_check_idle_level(gmu));\n}\n\nstatic int a6xx_gmu_start(struct a6xx_gmu *gmu)\n{\n\tint ret;\n\tu32 val;\n\tu32 mask, reset_val;\n\n\tval = gmu_read(gmu, REG_A6XX_GMU_CM3_DTCM_START + 0xff8);\n\tif (val <= 0x20010004) {\n\t\tmask = 0xffffffff;\n\t\treset_val = 0xbabeface;\n\t} else {\n\t\tmask = 0x1ff;\n\t\treset_val = 0x100;\n\t}\n\n\tgmu_write(gmu, REG_A6XX_GMU_CM3_SYSRESET, 1);\n\n\t \n\tgmu_write(gmu, REG_A6XX_GPU_GMU_CX_GMU_PWR_COL_CP_RESP, 0);\n\n\tgmu_write(gmu, REG_A6XX_GMU_CM3_SYSRESET, 0);\n\n\tret = gmu_poll_timeout(gmu, REG_A6XX_GMU_CM3_FW_INIT_RESULT, val,\n\t\t(val & mask) == reset_val, 100, 10000);\n\n\tif (ret)\n\t\tDRM_DEV_ERROR(gmu->dev, \"GMU firmware initialization timed out\\n\");\n\n\treturn ret;\n}\n\nstatic int a6xx_gmu_hfi_start(struct a6xx_gmu *gmu)\n{\n\tu32 val;\n\tint ret;\n\n\tgmu_write(gmu, REG_A6XX_GMU_HFI_CTRL_INIT, 1);\n\n\tret = gmu_poll_timeout(gmu, REG_A6XX_GMU_HFI_CTRL_STATUS, val,\n\t\tval & 1, 100, 10000);\n\tif (ret)\n\t\tDRM_DEV_ERROR(gmu->dev, \"Unable to start the HFI queues\\n\");\n\n\treturn ret;\n}\n\nstruct a6xx_gmu_oob_bits {\n\tint set, ack, set_new, ack_new, clear, clear_new;\n\tconst char *name;\n};\n\n \nstatic const struct a6xx_gmu_oob_bits a6xx_gmu_oob_bits[] = {\n\t[GMU_OOB_GPU_SET] = {\n\t\t.name = \"GPU_SET\",\n\t\t.set = 16,\n\t\t.ack = 24,\n\t\t.set_new = 30,\n\t\t.ack_new = 31,\n\t\t.clear = 24,\n\t\t.clear_new = 31,\n\t},\n\n\t[GMU_OOB_PERFCOUNTER_SET] = {\n\t\t.name = \"PERFCOUNTER\",\n\t\t.set = 17,\n\t\t.ack = 25,\n\t\t.set_new = 28,\n\t\t.ack_new = 30,\n\t\t.clear = 25,\n\t\t.clear_new = 29,\n\t},\n\n\t[GMU_OOB_BOOT_SLUMBER] = {\n\t\t.name = \"BOOT_SLUMBER\",\n\t\t.set = 22,\n\t\t.ack = 30,\n\t\t.clear = 30,\n\t},\n\n\t[GMU_OOB_DCVS_SET] = {\n\t\t.name = \"GPU_DCVS\",\n\t\t.set = 23,\n\t\t.ack = 31,\n\t\t.clear = 31,\n\t},\n};\n\n \nint a6xx_gmu_set_oob(struct a6xx_gmu *gmu, enum a6xx_gmu_oob_state state)\n{\n\tint ret;\n\tu32 val;\n\tint request, ack;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&gmu->lock));\n\n\tif (state >= ARRAY_SIZE(a6xx_gmu_oob_bits))\n\t\treturn -EINVAL;\n\n\tif (gmu->legacy) {\n\t\trequest = a6xx_gmu_oob_bits[state].set;\n\t\tack = a6xx_gmu_oob_bits[state].ack;\n\t} else {\n\t\trequest = a6xx_gmu_oob_bits[state].set_new;\n\t\tack = a6xx_gmu_oob_bits[state].ack_new;\n\t\tif (!request || !ack) {\n\t\t\tDRM_DEV_ERROR(gmu->dev,\n\t\t\t\t      \"Invalid non-legacy GMU request %s\\n\",\n\t\t\t\t      a6xx_gmu_oob_bits[state].name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_HOST2GMU_INTR_SET, 1 << request);\n\n\t \n\tret = gmu_poll_timeout(gmu, REG_A6XX_GMU_GMU2HOST_INTR_INFO, val,\n\t\tval & (1 << ack), 100, 10000);\n\n\tif (ret)\n\t\tDRM_DEV_ERROR(gmu->dev,\n\t\t\t\"Timeout waiting for GMU OOB set %s: 0x%x\\n\",\n\t\t\t\ta6xx_gmu_oob_bits[state].name,\n\t\t\t\tgmu_read(gmu, REG_A6XX_GMU_GMU2HOST_INTR_INFO));\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_GMU2HOST_INTR_CLR, 1 << ack);\n\n\treturn ret;\n}\n\n \nvoid a6xx_gmu_clear_oob(struct a6xx_gmu *gmu, enum a6xx_gmu_oob_state state)\n{\n\tint bit;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&gmu->lock));\n\n\tif (state >= ARRAY_SIZE(a6xx_gmu_oob_bits))\n\t\treturn;\n\n\tif (gmu->legacy)\n\t\tbit = a6xx_gmu_oob_bits[state].clear;\n\telse\n\t\tbit = a6xx_gmu_oob_bits[state].clear_new;\n\n\tgmu_write(gmu, REG_A6XX_GMU_HOST2GMU_INTR_SET, 1 << bit);\n}\n\n \nint a6xx_sptprac_enable(struct a6xx_gmu *gmu)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!gmu->legacy)\n\t\treturn 0;\n\n\tgmu_write(gmu, REG_A6XX_GMU_GX_SPTPRAC_POWER_CONTROL, 0x778000);\n\n\tret = gmu_poll_timeout(gmu, REG_A6XX_GMU_SPTPRAC_PWR_CLK_STATUS, val,\n\t\t(val & 0x38) == 0x28, 1, 100);\n\n\tif (ret) {\n\t\tDRM_DEV_ERROR(gmu->dev, \"Unable to power on SPTPRAC: 0x%x\\n\",\n\t\t\tgmu_read(gmu, REG_A6XX_GMU_SPTPRAC_PWR_CLK_STATUS));\n\t}\n\n\treturn 0;\n}\n\n \nvoid a6xx_sptprac_disable(struct a6xx_gmu *gmu)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!gmu->legacy)\n\t\treturn;\n\n\t \n\tgmu_rmw(gmu, REG_A6XX_GPU_CC_GX_GDSCR, 0, (1 << 11));\n\n\tgmu_write(gmu, REG_A6XX_GMU_GX_SPTPRAC_POWER_CONTROL, 0x778001);\n\n\tret = gmu_poll_timeout(gmu, REG_A6XX_GMU_SPTPRAC_PWR_CLK_STATUS, val,\n\t\t(val & 0x04), 100, 10000);\n\n\tif (ret)\n\t\tDRM_DEV_ERROR(gmu->dev, \"failed to power off SPTPRAC: 0x%x\\n\",\n\t\t\tgmu_read(gmu, REG_A6XX_GMU_SPTPRAC_PWR_CLK_STATUS));\n}\n\n \nstatic int a6xx_gmu_gfx_rail_on(struct a6xx_gmu *gmu)\n{\n\tu32 vote;\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_BOOT_SLUMBER_OPTION, 0);\n\n\t \n\tvote = gmu->gx_arc_votes[gmu->nr_gpu_freqs - 1];\n\n\tgmu_write(gmu, REG_A6XX_GMU_GX_VOTE_IDX, vote & 0xff);\n\tgmu_write(gmu, REG_A6XX_GMU_MX_VOTE_IDX, (vote >> 8) & 0xff);\n\n\t \n\treturn a6xx_gmu_set_oob(gmu, GMU_OOB_BOOT_SLUMBER);\n}\n\n \nstatic int a6xx_gmu_notify_slumber(struct a6xx_gmu *gmu)\n{\n\tint ret;\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_CX_GMU_POWER_COUNTER_ENABLE, 0);\n\n\t \n\tif (gmu->idle_level < GMU_IDLE_STATE_SPTP)\n\t\ta6xx_sptprac_disable(gmu);\n\n\tif (!gmu->legacy) {\n\t\tret = a6xx_hfi_send_prep_slumber(gmu);\n\t\tgoto out;\n\t}\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_BOOT_SLUMBER_OPTION, 1);\n\n\tret = a6xx_gmu_set_oob(gmu, GMU_OOB_BOOT_SLUMBER);\n\ta6xx_gmu_clear_oob(gmu, GMU_OOB_BOOT_SLUMBER);\n\n\tif (!ret) {\n\t\t \n\t\tif (gmu_read(gmu, REG_A6XX_GPU_GMU_CX_GMU_RPMH_POWER_STATE)\n\t\t\t!= 0x0f) {\n\t\t\tDRM_DEV_ERROR(gmu->dev, \"The GMU did not go into slumber\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t}\n\t}\n\nout:\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_AO_AHB_FENCE_CTRL, 0);\n\treturn ret;\n}\n\nstatic int a6xx_rpmh_start(struct a6xx_gmu *gmu)\n{\n\tint ret;\n\tu32 val;\n\n\tgmu_write(gmu, REG_A6XX_GMU_RSCC_CONTROL_REQ, 1 << 1);\n\t \n\twmb();\n\n\tret = gmu_poll_timeout(gmu, REG_A6XX_GMU_RSCC_CONTROL_ACK, val,\n\t\tval & (1 << 1), 100, 10000);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(gmu->dev, \"Unable to power on the GPU RSC\\n\");\n\t\treturn ret;\n\t}\n\n\tret = gmu_poll_timeout_rscc(gmu, REG_A6XX_RSCC_SEQ_BUSY_DRV0, val,\n\t\t!val, 100, 10000);\n\n\tif (ret) {\n\t\tDRM_DEV_ERROR(gmu->dev, \"GPU RSC sequence stuck while waking up the GPU\\n\");\n\t\treturn ret;\n\t}\n\n\tgmu_write(gmu, REG_A6XX_GMU_RSCC_CONTROL_REQ, 0);\n\n\treturn 0;\n}\n\nstatic void a6xx_rpmh_stop(struct a6xx_gmu *gmu)\n{\n\tint ret;\n\tu32 val;\n\n\tgmu_write(gmu, REG_A6XX_GMU_RSCC_CONTROL_REQ, 1);\n\n\tret = gmu_poll_timeout_rscc(gmu, REG_A6XX_GPU_RSCC_RSC_STATUS0_DRV0,\n\t\tval, val & (1 << 16), 100, 10000);\n\tif (ret)\n\t\tDRM_DEV_ERROR(gmu->dev, \"Unable to power off the GPU RSC\\n\");\n\n\tgmu_write(gmu, REG_A6XX_GMU_RSCC_CONTROL_REQ, 0);\n}\n\nstatic inline void pdc_write(void __iomem *ptr, u32 offset, u32 value)\n{\n\tmsm_writel(value, ptr + (offset << 2));\n}\n\nstatic void __iomem *a6xx_gmu_get_mmio(struct platform_device *pdev,\n\t\tconst char *name);\n\nstatic void a6xx_gmu_rpmh_init(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_gpu *a6xx_gpu = container_of(gmu, struct a6xx_gpu, gmu);\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tstruct platform_device *pdev = to_platform_device(gmu->dev);\n\tvoid __iomem *pdcptr = a6xx_gmu_get_mmio(pdev, \"gmu_pdc\");\n\tvoid __iomem *seqptr = NULL;\n\tuint32_t pdc_address_offset;\n\tbool pdc_in_aop = false;\n\n\tif (IS_ERR(pdcptr))\n\t\tgoto err;\n\n\tif (adreno_is_a650(adreno_gpu) || adreno_is_a660_family(adreno_gpu))\n\t\tpdc_in_aop = true;\n\telse if (adreno_is_a618(adreno_gpu) || adreno_is_a640_family(adreno_gpu))\n\t\tpdc_address_offset = 0x30090;\n\telse if (adreno_is_a619(adreno_gpu))\n\t\tpdc_address_offset = 0x300a0;\n\telse\n\t\tpdc_address_offset = 0x30080;\n\n\tif (!pdc_in_aop) {\n\t\tseqptr = a6xx_gmu_get_mmio(pdev, \"gmu_pdc_seq\");\n\t\tif (IS_ERR(seqptr))\n\t\t\tgoto err;\n\t}\n\n\t \n\tgmu_write_rscc(gmu, REG_A6XX_GPU_RSCC_RSC_STATUS0_DRV0, BIT(24));\n\n\t \n\tgmu_write_rscc(gmu, REG_A6XX_RSCC_PDC_SLAVE_ID_DRV0, 1);\n\tgmu_write_rscc(gmu, REG_A6XX_RSCC_HIDDEN_TCS_CMD0_DATA, 0);\n\tgmu_write_rscc(gmu, REG_A6XX_RSCC_HIDDEN_TCS_CMD0_ADDR, 0);\n\tgmu_write_rscc(gmu, REG_A6XX_RSCC_HIDDEN_TCS_CMD0_DATA + 2, 0);\n\tgmu_write_rscc(gmu, REG_A6XX_RSCC_HIDDEN_TCS_CMD0_ADDR + 2, 0);\n\tgmu_write_rscc(gmu, REG_A6XX_RSCC_HIDDEN_TCS_CMD0_DATA + 4, 0x80000000);\n\tgmu_write_rscc(gmu, REG_A6XX_RSCC_HIDDEN_TCS_CMD0_ADDR + 4, 0);\n\tgmu_write_rscc(gmu, REG_A6XX_RSCC_OVERRIDE_START_ADDR, 0);\n\tgmu_write_rscc(gmu, REG_A6XX_RSCC_PDC_SEQ_START_ADDR, 0x4520);\n\tgmu_write_rscc(gmu, REG_A6XX_RSCC_PDC_MATCH_VALUE_LO, 0x4510);\n\tgmu_write_rscc(gmu, REG_A6XX_RSCC_PDC_MATCH_VALUE_HI, 0x4514);\n\n\t \n\tif (adreno_is_a650_family(adreno_gpu)) {\n\t\tgmu_write_rscc(gmu, REG_A6XX_RSCC_SEQ_MEM_0_DRV0, 0xeaaae5a0);\n\t\tgmu_write_rscc(gmu, REG_A6XX_RSCC_SEQ_MEM_0_DRV0 + 1, 0xe1a1ebab);\n\t\tgmu_write_rscc(gmu, REG_A6XX_RSCC_SEQ_MEM_0_DRV0 + 2, 0xa2e0a581);\n\t\tgmu_write_rscc(gmu, REG_A6XX_RSCC_SEQ_MEM_0_DRV0 + 3, 0xecac82e2);\n\t\tgmu_write_rscc(gmu, REG_A6XX_RSCC_SEQ_MEM_0_DRV0 + 4, 0x0020edad);\n\t} else {\n\t\tgmu_write_rscc(gmu, REG_A6XX_RSCC_SEQ_MEM_0_DRV0, 0xa7a506a0);\n\t\tgmu_write_rscc(gmu, REG_A6XX_RSCC_SEQ_MEM_0_DRV0 + 1, 0xa1e6a6e7);\n\t\tgmu_write_rscc(gmu, REG_A6XX_RSCC_SEQ_MEM_0_DRV0 + 2, 0xa2e081e1);\n\t\tgmu_write_rscc(gmu, REG_A6XX_RSCC_SEQ_MEM_0_DRV0 + 3, 0xe9a982e2);\n\t\tgmu_write_rscc(gmu, REG_A6XX_RSCC_SEQ_MEM_0_DRV0 + 4, 0x0020e8a8);\n\t}\n\n\tif (pdc_in_aop)\n\t\tgoto setup_pdc;\n\n\t \n\tpdc_write(seqptr, REG_A6XX_PDC_GPU_SEQ_MEM_0, 0xfebea1e1);\n\tpdc_write(seqptr, REG_A6XX_PDC_GPU_SEQ_MEM_0 + 1, 0xa5a4a3a2);\n\tpdc_write(seqptr, REG_A6XX_PDC_GPU_SEQ_MEM_0 + 2, 0x8382a6e0);\n\tpdc_write(seqptr, REG_A6XX_PDC_GPU_SEQ_MEM_0 + 3, 0xbce3e284);\n\tpdc_write(seqptr, REG_A6XX_PDC_GPU_SEQ_MEM_0 + 4, 0x002081fc);\n\n\t \n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CMD_ENABLE_BANK, 7);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CMD_WAIT_FOR_CMPL_BANK, 0);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CONTROL, 0);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CMD0_MSGID, 0x10108);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CMD0_ADDR, 0x30010);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CMD0_DATA, 1);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CMD0_MSGID + 4, 0x10108);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CMD0_ADDR + 4, 0x30000);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CMD0_DATA + 4, 0x0);\n\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CMD0_MSGID + 8, 0x10108);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CMD0_ADDR + 8, pdc_address_offset);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS1_CMD0_DATA + 8, 0x0);\n\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD_ENABLE_BANK, 7);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD_WAIT_FOR_CMPL_BANK, 0);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CONTROL, 0);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD0_MSGID, 0x10108);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD0_ADDR, 0x30010);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD0_DATA, 2);\n\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD0_MSGID + 4, 0x10108);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD0_ADDR + 4, 0x30000);\n\tif (adreno_is_a618(adreno_gpu) || adreno_is_a619(adreno_gpu) ||\n\t\t\tadreno_is_a650_family(adreno_gpu))\n\t\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD0_DATA + 4, 0x2);\n\telse\n\t\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD0_DATA + 4, 0x3);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD0_MSGID + 8, 0x10108);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD0_ADDR + 8, pdc_address_offset);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_TCS3_CMD0_DATA + 8, 0x3);\n\n\t \nsetup_pdc:\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_SEQ_START_ADDR, 0);\n\tpdc_write(pdcptr, REG_A6XX_PDC_GPU_ENABLE_PDC, 0x80000001);\n\n\t \n\twmb();\n\n\ta6xx_rpmh_stop(gmu);\n\nerr:\n\tif (!IS_ERR_OR_NULL(pdcptr))\n\t\tiounmap(pdcptr);\n\tif (!IS_ERR_OR_NULL(seqptr))\n\t\tiounmap(seqptr);\n}\n\n \n\n#define GMU_PWR_COL_HYST 0x000a1680\n\n \nstatic void a6xx_gmu_power_config(struct a6xx_gmu *gmu)\n{\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_SYS_BUS_CONFIG, 0x1);\n\tgmu_write(gmu, REG_A6XX_GMU_ICACHE_CONFIG, 0x1);\n\tgmu_write(gmu, REG_A6XX_GMU_DCACHE_CONFIG, 0x1);\n\n\tgmu_write(gmu, REG_A6XX_GMU_PWR_COL_INTER_FRAME_CTRL, 0x9c40400);\n\n\tswitch (gmu->idle_level) {\n\tcase GMU_IDLE_STATE_IFPC:\n\t\tgmu_write(gmu, REG_A6XX_GMU_PWR_COL_INTER_FRAME_HYST,\n\t\t\tGMU_PWR_COL_HYST);\n\t\tgmu_rmw(gmu, REG_A6XX_GMU_PWR_COL_INTER_FRAME_CTRL, 0,\n\t\t\tA6XX_GMU_PWR_COL_INTER_FRAME_CTRL_IFPC_ENABLE |\n\t\t\tA6XX_GMU_PWR_COL_INTER_FRAME_CTRL_HM_POWER_COLLAPSE_ENABLE);\n\t\tfallthrough;\n\tcase GMU_IDLE_STATE_SPTP:\n\t\tgmu_write(gmu, REG_A6XX_GMU_PWR_COL_SPTPRAC_HYST,\n\t\t\tGMU_PWR_COL_HYST);\n\t\tgmu_rmw(gmu, REG_A6XX_GMU_PWR_COL_INTER_FRAME_CTRL, 0,\n\t\t\tA6XX_GMU_PWR_COL_INTER_FRAME_CTRL_IFPC_ENABLE |\n\t\t\tA6XX_GMU_PWR_COL_INTER_FRAME_CTRL_SPTPRAC_POWER_CONTROL_ENABLE);\n\t}\n\n\t \n\tgmu_rmw(gmu, REG_A6XX_GMU_RPMH_CTRL, 0,\n\t\tA6XX_GMU_RPMH_CTRL_RPMH_INTERFACE_ENABLE |\n\t\tA6XX_GMU_RPMH_CTRL_LLC_VOTE_ENABLE |\n\t\tA6XX_GMU_RPMH_CTRL_DDR_VOTE_ENABLE |\n\t\tA6XX_GMU_RPMH_CTRL_MX_VOTE_ENABLE |\n\t\tA6XX_GMU_RPMH_CTRL_CX_VOTE_ENABLE |\n\t\tA6XX_GMU_RPMH_CTRL_GFX_VOTE_ENABLE);\n}\n\nstruct block_header {\n\tu32 addr;\n\tu32 size;\n\tu32 type;\n\tu32 value;\n\tu32 data[];\n};\n\nstatic bool fw_block_mem(struct a6xx_gmu_bo *bo, const struct block_header *blk)\n{\n\tif (!in_range(blk->addr, bo->iova, bo->size))\n\t\treturn false;\n\n\tmemcpy(bo->virt + blk->addr - bo->iova, blk->data, blk->size);\n\treturn true;\n}\n\nstatic int a6xx_gmu_fw_load(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_gpu *a6xx_gpu = container_of(gmu, struct a6xx_gpu, gmu);\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tconst struct firmware *fw_image = adreno_gpu->fw[ADRENO_FW_GMU];\n\tconst struct block_header *blk;\n\tu32 reg_offset;\n\n\tu32 itcm_base = 0x00000000;\n\tu32 dtcm_base = 0x00040000;\n\n\tif (adreno_is_a650_family(adreno_gpu))\n\t\tdtcm_base = 0x10004000;\n\n\tif (gmu->legacy) {\n\t\t \n\t\tif (fw_image->size > 0x8000) {\n\t\t\tDRM_DEV_ERROR(gmu->dev,\n\t\t\t\t\"GMU firmware is bigger than the available region\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgmu_write_bulk(gmu, REG_A6XX_GMU_CM3_ITCM_START,\n\t\t\t       (u32*) fw_image->data, fw_image->size);\n\t\treturn 0;\n\t}\n\n\n\tfor (blk = (const struct block_header *) fw_image->data;\n\t     (const u8*) blk < fw_image->data + fw_image->size;\n\t     blk = (const struct block_header *) &blk->data[blk->size >> 2]) {\n\t\tif (blk->size == 0)\n\t\t\tcontinue;\n\n\t\tif (in_range(blk->addr, itcm_base, SZ_16K)) {\n\t\t\treg_offset = (blk->addr - itcm_base) >> 2;\n\t\t\tgmu_write_bulk(gmu,\n\t\t\t\tREG_A6XX_GMU_CM3_ITCM_START + reg_offset,\n\t\t\t\tblk->data, blk->size);\n\t\t} else if (in_range(blk->addr, dtcm_base, SZ_16K)) {\n\t\t\treg_offset = (blk->addr - dtcm_base) >> 2;\n\t\t\tgmu_write_bulk(gmu,\n\t\t\t\tREG_A6XX_GMU_CM3_DTCM_START + reg_offset,\n\t\t\t\tblk->data, blk->size);\n\t\t} else if (!fw_block_mem(&gmu->icache, blk) &&\n\t\t\t   !fw_block_mem(&gmu->dcache, blk) &&\n\t\t\t   !fw_block_mem(&gmu->dummy, blk)) {\n\t\t\tDRM_DEV_ERROR(gmu->dev,\n\t\t\t\t\"failed to match fw block (addr=%.8x size=%d data[0]=%.8x)\\n\",\n\t\t\t\tblk->addr, blk->size, blk->data[0]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int a6xx_gmu_fw_start(struct a6xx_gmu *gmu, unsigned int state)\n{\n\tstruct a6xx_gpu *a6xx_gpu = container_of(gmu, struct a6xx_gpu, gmu);\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tint ret;\n\tu32 chipid;\n\n\tif (adreno_is_a650_family(adreno_gpu)) {\n\t\tgmu_write(gmu, REG_A6XX_GPU_GMU_CX_GMU_CX_FALNEXT_INTF, 1);\n\t\tgmu_write(gmu, REG_A6XX_GPU_GMU_CX_GMU_CX_FAL_INTF, 1);\n\t}\n\n\tif (state == GMU_WARM_BOOT) {\n\t\tret = a6xx_rpmh_start(gmu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tif (WARN(!adreno_gpu->fw[ADRENO_FW_GMU],\n\t\t\t\"GMU firmware is not loaded\\n\"))\n\t\t\treturn -ENOENT;\n\n\t\t \n\t\tgmu_write(gmu, REG_A6XX_GMU_GENERAL_7, 1);\n\n\t\tret = a6xx_rpmh_start(gmu);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = a6xx_gmu_fw_load(gmu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tgmu_write(gmu, REG_A6XX_GMU_CM3_FW_INIT_RESULT, 0);\n\tgmu_write(gmu, REG_A6XX_GMU_CM3_BOOT_CONFIG, 0x02);\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_HFI_QTBL_ADDR, gmu->hfi.iova);\n\tgmu_write(gmu, REG_A6XX_GMU_HFI_QTBL_INFO, 1);\n\n\tgmu_write(gmu, REG_A6XX_GMU_AHB_FENCE_RANGE_0,\n\t\t(1 << 31) | (0xa << 18) | (0xa0));\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_CM3_CFG, 0x4052);\n\n\t \n\tchipid  = adreno_gpu->chip_id & 0xffff0000;\n\tchipid |= (adreno_gpu->chip_id << 4) & 0xf000;  \n\tchipid |= (adreno_gpu->chip_id << 8) & 0x0f00;  \n\n\tgmu_write(gmu, REG_A6XX_GMU_HFI_SFR_ADDR, chipid);\n\n\tgmu_write(gmu, REG_A6XX_GPU_GMU_CX_GMU_PWR_COL_CP_MSG,\n\t\t  gmu->log.iova | (gmu->log.size / SZ_4K - 1));\n\n\t \n\ta6xx_gmu_power_config(gmu);\n\n\tret = a6xx_gmu_start(gmu);\n\tif (ret)\n\t\treturn ret;\n\n\tif (gmu->legacy) {\n\t\tret = a6xx_gmu_gfx_rail_on(gmu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (gmu->idle_level < GMU_IDLE_STATE_SPTP) {\n\t\tret = a6xx_sptprac_enable(gmu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = a6xx_gmu_hfi_start(gmu);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twmb();\n\n\treturn 0;\n}\n\n#define A6XX_HFI_IRQ_MASK \\\n\t(A6XX_GMU_GMU2HOST_INTR_INFO_CM3_FAULT)\n\n#define A6XX_GMU_IRQ_MASK \\\n\t(A6XX_GMU_AO_HOST_INTERRUPT_STATUS_WDOG_BITE | \\\n\t A6XX_GMU_AO_HOST_INTERRUPT_STATUS_HOST_AHB_BUS_ERROR | \\\n\t A6XX_GMU_AO_HOST_INTERRUPT_STATUS_FENCE_ERR)\n\nstatic void a6xx_gmu_irq_disable(struct a6xx_gmu *gmu)\n{\n\tdisable_irq(gmu->gmu_irq);\n\tdisable_irq(gmu->hfi_irq);\n\n\tgmu_write(gmu, REG_A6XX_GMU_AO_HOST_INTERRUPT_MASK, ~0);\n\tgmu_write(gmu, REG_A6XX_GMU_GMU2HOST_INTR_MASK, ~0);\n}\n\nstatic void a6xx_gmu_rpmh_off(struct a6xx_gmu *gmu)\n{\n\tu32 val;\n\n\t \n\tgmu_poll_timeout_rscc(gmu, REG_A6XX_RSCC_TCS0_DRV0_STATUS, val,\n\t\t(val & 1), 100, 10000);\n\tgmu_poll_timeout_rscc(gmu, REG_A6XX_RSCC_TCS1_DRV0_STATUS, val,\n\t\t(val & 1), 100, 10000);\n\tgmu_poll_timeout_rscc(gmu, REG_A6XX_RSCC_TCS2_DRV0_STATUS, val,\n\t\t(val & 1), 100, 10000);\n\tgmu_poll_timeout_rscc(gmu, REG_A6XX_RSCC_TCS3_DRV0_STATUS, val,\n\t\t(val & 1), 100, 1000);\n}\n\n \nstatic void a6xx_gmu_force_off(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_gpu *a6xx_gpu = container_of(gmu, struct a6xx_gpu, gmu);\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tstruct msm_gpu *gpu = &adreno_gpu->base;\n\n\t \n\tgmu_write(&a6xx_gpu->gmu, REG_A6XX_GMU_GMU_PWR_COL_KEEPALIVE, 0);\n\n\t \n\ta6xx_hfi_stop(gmu);\n\n\t \n\ta6xx_gmu_irq_disable(gmu);\n\n\t \n\ta6xx_sptprac_disable(gmu);\n\n\t \n\ta6xx_gmu_rpmh_off(gmu);\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_AHB_FENCE_STATUS_CLR, 0x7);\n\tgmu_write(gmu, REG_A6XX_GMU_AO_AHB_FENCE_CTRL, 0);\n\n\t \n\twmb();\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_CM3_SYSRESET, 1);\n\n\ta6xx_bus_clear_pending_transactions(adreno_gpu, true);\n\n\t \n\ta6xx_gpu_sw_reset(gpu, true);\n}\n\nstatic void a6xx_gmu_set_initial_freq(struct msm_gpu *gpu, struct a6xx_gmu *gmu)\n{\n\tstruct dev_pm_opp *gpu_opp;\n\tunsigned long gpu_freq = gmu->gpu_freqs[gmu->current_perf_index];\n\n\tgpu_opp = dev_pm_opp_find_freq_exact(&gpu->pdev->dev, gpu_freq, true);\n\tif (IS_ERR(gpu_opp))\n\t\treturn;\n\n\tgmu->freq = 0;  \n\ta6xx_gmu_set_freq(gpu, gpu_opp, false);\n\tdev_pm_opp_put(gpu_opp);\n}\n\nstatic void a6xx_gmu_set_initial_bw(struct msm_gpu *gpu, struct a6xx_gmu *gmu)\n{\n\tstruct dev_pm_opp *gpu_opp;\n\tunsigned long gpu_freq = gmu->gpu_freqs[gmu->current_perf_index];\n\n\tgpu_opp = dev_pm_opp_find_freq_exact(&gpu->pdev->dev, gpu_freq, true);\n\tif (IS_ERR(gpu_opp))\n\t\treturn;\n\n\tdev_pm_opp_set_opp(&gpu->pdev->dev, gpu_opp);\n\tdev_pm_opp_put(gpu_opp);\n}\n\nint a6xx_gmu_resume(struct a6xx_gpu *a6xx_gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tstruct msm_gpu *gpu = &adreno_gpu->base;\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\tint status, ret;\n\n\tif (WARN(!gmu->initialized, \"The GMU is not set up yet\\n\"))\n\t\treturn -EINVAL;\n\n\tgmu->hung = false;\n\n\t \n\tpm_runtime_get_sync(gmu->dev);\n\n\t \n\tif (!IS_ERR_OR_NULL(gmu->gxpd))\n\t\tpm_runtime_get_sync(gmu->gxpd);\n\n\t \n\tclk_set_rate(gmu->core_clk, 200000000);\n\tclk_set_rate(gmu->hub_clk, 150000000);\n\tret = clk_bulk_prepare_enable(gmu->nr_clocks, gmu->clocks);\n\tif (ret) {\n\t\tpm_runtime_put(gmu->gxpd);\n\t\tpm_runtime_put(gmu->dev);\n\t\treturn ret;\n\t}\n\n\t \n\ta6xx_gmu_set_initial_bw(gpu, gmu);\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_AO_HOST_INTERRUPT_CLR, ~0);\n\tgmu_write(gmu, REG_A6XX_GMU_AO_HOST_INTERRUPT_MASK, ~A6XX_GMU_IRQ_MASK);\n\tenable_irq(gmu->gmu_irq);\n\n\t \n\tstatus = gmu_read(gmu, REG_A6XX_GMU_GENERAL_7) == 1 ?\n\t\tGMU_WARM_BOOT : GMU_COLD_BOOT;\n\n\t \n\tif (!gmu->legacy)\n\t\tstatus = GMU_COLD_BOOT;\n\n\tret = a6xx_gmu_fw_start(gmu, status);\n\tif (ret)\n\t\tgoto out;\n\n\tret = a6xx_hfi_start(gmu, status);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_GMU2HOST_INTR_CLR, ~0);\n\tgmu_write(gmu, REG_A6XX_GMU_GMU2HOST_INTR_MASK, ~A6XX_HFI_IRQ_MASK);\n\tenable_irq(gmu->hfi_irq);\n\n\t \n\ta6xx_gmu_set_initial_freq(gpu, gmu);\n\nout:\n\t \n\tif (ret) {\n\t\tdisable_irq(gmu->gmu_irq);\n\t\ta6xx_rpmh_stop(gmu);\n\t\tpm_runtime_put(gmu->gxpd);\n\t\tpm_runtime_put(gmu->dev);\n\t}\n\n\treturn ret;\n}\n\nbool a6xx_gmu_isidle(struct a6xx_gmu *gmu)\n{\n\tu32 reg;\n\n\tif (!gmu->initialized)\n\t\treturn true;\n\n\treg = gmu_read(gmu, REG_A6XX_GPU_GMU_AO_GPU_CX_BUSY_STATUS);\n\n\tif (reg &  A6XX_GPU_GMU_AO_GPU_CX_BUSY_STATUS_GPUBUSYIGNAHB)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void a6xx_gmu_shutdown(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_gpu *a6xx_gpu = container_of(gmu, struct a6xx_gpu, gmu);\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tu32 val;\n\n\t \n\tval = gmu_read(gmu, REG_A6XX_GPU_GMU_CX_GMU_RPMH_POWER_STATE);\n\n\tif (val != 0xf) {\n\t\tint ret = a6xx_gmu_wait_for_idle(gmu);\n\n\t\t \n\t\tif (ret) {\n\t\t\ta6xx_gmu_force_off(gmu);\n\t\t\treturn;\n\t\t}\n\n\t\ta6xx_bus_clear_pending_transactions(adreno_gpu, a6xx_gpu->hung);\n\n\t\t \n\t\tret = a6xx_gmu_notify_slumber(gmu);\n\t\tif (ret) {\n\t\t\ta6xx_gmu_force_off(gmu);\n\t\t\treturn;\n\t\t}\n\n\t\tret = gmu_poll_timeout(gmu,\n\t\t\tREG_A6XX_GPU_GMU_AO_GPU_CX_BUSY_STATUS, val,\n\t\t\t!(val & A6XX_GPU_GMU_AO_GPU_CX_BUSY_STATUS_GPUBUSYIGNAHB),\n\t\t\t100, 10000);\n\n\t\t \n\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(gmu->dev,\n\t\t\t\t\"Unable to slumber GMU: status = 0%x/0%x\\n\",\n\t\t\t\tgmu_read(gmu,\n\t\t\t\t\tREG_A6XX_GPU_GMU_AO_GPU_CX_BUSY_STATUS),\n\t\t\t\tgmu_read(gmu,\n\t\t\t\t\tREG_A6XX_GPU_GMU_AO_GPU_CX_BUSY_STATUS2));\n\t}\n\n\t \n\ta6xx_hfi_stop(gmu);\n\n\t \n\ta6xx_gmu_irq_disable(gmu);\n\n\t \n\ta6xx_rpmh_stop(gmu);\n}\n\n\nint a6xx_gmu_stop(struct a6xx_gpu *a6xx_gpu)\n{\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\tstruct msm_gpu *gpu = &a6xx_gpu->base.base;\n\n\tif (!pm_runtime_active(gmu->dev))\n\t\treturn 0;\n\n\t \n\tif (gmu->hung)\n\t\ta6xx_gmu_force_off(gmu);\n\telse\n\t\ta6xx_gmu_shutdown(gmu);\n\n\t \n\tdev_pm_opp_set_opp(&gpu->pdev->dev, NULL);\n\n\t \n\tif (!IS_ERR_OR_NULL(gmu->gxpd))\n\t\tpm_runtime_put_sync(gmu->gxpd);\n\n\tclk_bulk_disable_unprepare(gmu->nr_clocks, gmu->clocks);\n\n\tpm_runtime_put_sync(gmu->dev);\n\n\treturn 0;\n}\n\nstatic void a6xx_gmu_memory_free(struct a6xx_gmu *gmu)\n{\n\tmsm_gem_kernel_put(gmu->hfi.obj, gmu->aspace);\n\tmsm_gem_kernel_put(gmu->debug.obj, gmu->aspace);\n\tmsm_gem_kernel_put(gmu->icache.obj, gmu->aspace);\n\tmsm_gem_kernel_put(gmu->dcache.obj, gmu->aspace);\n\tmsm_gem_kernel_put(gmu->dummy.obj, gmu->aspace);\n\tmsm_gem_kernel_put(gmu->log.obj, gmu->aspace);\n\n\tgmu->aspace->mmu->funcs->detach(gmu->aspace->mmu);\n\tmsm_gem_address_space_put(gmu->aspace);\n}\n\nstatic int a6xx_gmu_memory_alloc(struct a6xx_gmu *gmu, struct a6xx_gmu_bo *bo,\n\t\tsize_t size, u64 iova, const char *name)\n{\n\tstruct a6xx_gpu *a6xx_gpu = container_of(gmu, struct a6xx_gpu, gmu);\n\tstruct drm_device *dev = a6xx_gpu->base.base.dev;\n\tuint32_t flags = MSM_BO_WC;\n\tu64 range_start, range_end;\n\tint ret;\n\n\tsize = PAGE_ALIGN(size);\n\tif (!iova) {\n\t\t \n\t\trange_start = 0x60000000 + PAGE_SIZE;  \n\t\trange_end = 0x80000000;\n\t} else {\n\t\t \n\t\trange_start = iova;\n\t\trange_end = iova + size;\n\t\t \n\t\tflags |= MSM_BO_MAP_PRIV;\n\t}\n\n\tbo->obj = msm_gem_new(dev, size, flags);\n\tif (IS_ERR(bo->obj))\n\t\treturn PTR_ERR(bo->obj);\n\n\tret = msm_gem_get_and_pin_iova_range(bo->obj, gmu->aspace, &bo->iova,\n\t\t\t\t\t     range_start, range_end);\n\tif (ret) {\n\t\tdrm_gem_object_put(bo->obj);\n\t\treturn ret;\n\t}\n\n\tbo->virt = msm_gem_get_vaddr(bo->obj);\n\tbo->size = size;\n\n\tmsm_gem_object_set_name(bo->obj, name);\n\n\treturn 0;\n}\n\nstatic int a6xx_gmu_memory_probe(struct a6xx_gmu *gmu)\n{\n\tstruct msm_mmu *mmu;\n\n\tmmu = msm_iommu_new(gmu->dev, 0);\n\tif (!mmu)\n\t\treturn -ENODEV;\n\tif (IS_ERR(mmu))\n\t\treturn PTR_ERR(mmu);\n\n\tgmu->aspace = msm_gem_address_space_create(mmu, \"gmu\", 0x0, 0x80000000);\n\tif (IS_ERR(gmu->aspace))\n\t\treturn PTR_ERR(gmu->aspace);\n\n\treturn 0;\n}\n\n \nstatic unsigned int a6xx_gmu_get_arc_level(struct device *dev,\n\t\t\t\t\t   unsigned long freq)\n{\n\tstruct dev_pm_opp *opp;\n\tunsigned int val;\n\n\tif (!freq)\n\t\treturn 0;\n\n\topp = dev_pm_opp_find_freq_exact(dev, freq, true);\n\tif (IS_ERR(opp))\n\t\treturn 0;\n\n\tval = dev_pm_opp_get_level(opp);\n\n\tdev_pm_opp_put(opp);\n\n\treturn val;\n}\n\nstatic int a6xx_gmu_rpmh_arc_votes_init(struct device *dev, u32 *votes,\n\t\tunsigned long *freqs, int freqs_count, const char *id)\n{\n\tint i, j;\n\tconst u16 *pri, *sec;\n\tsize_t pri_count, sec_count;\n\n\tpri = cmd_db_read_aux_data(id, &pri_count);\n\tif (IS_ERR(pri))\n\t\treturn PTR_ERR(pri);\n\t \n\tpri_count >>= 1;\n\tif (!pri_count)\n\t\treturn -EINVAL;\n\n\tsec = cmd_db_read_aux_data(\"mx.lvl\", &sec_count);\n\tif (IS_ERR(sec))\n\t\treturn PTR_ERR(sec);\n\n\tsec_count >>= 1;\n\tif (!sec_count)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < freqs_count; i++) {\n\t\tu8 pindex = 0, sindex = 0;\n\t\tunsigned int level = a6xx_gmu_get_arc_level(dev, freqs[i]);\n\n\t\t \n\t\tfor (j = 0; j < pri_count; j++) {\n\t\t\tif (pri[j] >= level) {\n\t\t\t\tpindex = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (j == pri_count) {\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"Level %u not found in the RPMh list\\n\",\n\t\t\t\t      level);\n\t\t\tDRM_DEV_ERROR(dev, \"Available levels:\\n\");\n\t\t\tfor (j = 0; j < pri_count; j++)\n\t\t\t\tDRM_DEV_ERROR(dev, \"  %u\\n\", pri[j]);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\n\t\tfor (j = 0; j < sec_count; j++) {\n\t\t\tif (sec[j] >= level) {\n\t\t\t\tsindex = j;\n\t\t\t\tbreak;\n\t\t\t} else if (sec[j]) {\n\t\t\t\tsindex = j;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tvotes[i] = ((pri[pindex] & 0xffff) << 16) |\n\t\t\t(sindex << 8) | pindex;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int a6xx_gmu_rpmh_votes_init(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_gpu *a6xx_gpu = container_of(gmu, struct a6xx_gpu, gmu);\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tstruct msm_gpu *gpu = &adreno_gpu->base;\n\tint ret;\n\n\t \n\tret = a6xx_gmu_rpmh_arc_votes_init(&gpu->pdev->dev, gmu->gx_arc_votes,\n\t\tgmu->gpu_freqs, gmu->nr_gpu_freqs, \"gfx.lvl\");\n\n\t \n\tret |= a6xx_gmu_rpmh_arc_votes_init(gmu->dev, gmu->cx_arc_votes,\n\t\tgmu->gmu_freqs, gmu->nr_gmu_freqs, \"cx.lvl\");\n\n\treturn ret;\n}\n\nstatic int a6xx_gmu_build_freq_table(struct device *dev, unsigned long *freqs,\n\t\tu32 size)\n{\n\tint count = dev_pm_opp_get_opp_count(dev);\n\tstruct dev_pm_opp *opp;\n\tint i, index = 0;\n\tunsigned long freq = 1;\n\n\t \n\n\tif (WARN(count + 1 > size,\n\t\t\"The GMU frequency table is being truncated\\n\"))\n\t\tcount = size - 1;\n\n\t \n\tfreqs[index++] = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\topp = dev_pm_opp_find_freq_ceil(dev, &freq);\n\t\tif (IS_ERR(opp))\n\t\t\tbreak;\n\n\t\tdev_pm_opp_put(opp);\n\t\tfreqs[index++] = freq++;\n\t}\n\n\treturn index;\n}\n\nstatic int a6xx_gmu_pwrlevels_probe(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_gpu *a6xx_gpu = container_of(gmu, struct a6xx_gpu, gmu);\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tstruct msm_gpu *gpu = &adreno_gpu->base;\n\n\tint ret = 0;\n\n\t \n\tret = devm_pm_opp_of_add_table(gmu->dev);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(gmu->dev, \"Unable to set the OPP table for the GMU\\n\");\n\t\treturn ret;\n\t}\n\n\tgmu->nr_gmu_freqs = a6xx_gmu_build_freq_table(gmu->dev,\n\t\tgmu->gmu_freqs, ARRAY_SIZE(gmu->gmu_freqs));\n\n\t \n\tgmu->nr_gpu_freqs = a6xx_gmu_build_freq_table(&gpu->pdev->dev,\n\t\tgmu->gpu_freqs, ARRAY_SIZE(gmu->gpu_freqs));\n\n\tgmu->current_perf_index = gmu->nr_gpu_freqs - 1;\n\n\t \n\treturn a6xx_gmu_rpmh_votes_init(gmu);\n}\n\nstatic int a6xx_gmu_clocks_probe(struct a6xx_gmu *gmu)\n{\n\tint ret = devm_clk_bulk_get_all(gmu->dev, &gmu->clocks);\n\n\tif (ret < 1)\n\t\treturn ret;\n\n\tgmu->nr_clocks = ret;\n\n\tgmu->core_clk = msm_clk_bulk_get_clock(gmu->clocks,\n\t\tgmu->nr_clocks, \"gmu\");\n\n\tgmu->hub_clk = msm_clk_bulk_get_clock(gmu->clocks,\n\t\tgmu->nr_clocks, \"hub\");\n\n\treturn 0;\n}\n\nstatic void __iomem *a6xx_gmu_get_mmio(struct platform_device *pdev,\n\t\tconst char *name)\n{\n\tvoid __iomem *ret;\n\tstruct resource *res = platform_get_resource_byname(pdev,\n\t\t\tIORESOURCE_MEM, name);\n\n\tif (!res) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"Unable to find the %s registers\\n\", name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tret = ioremap(res->start, resource_size(res));\n\tif (!ret) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"Unable to map the %s registers\\n\", name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn ret;\n}\n\nstatic int a6xx_gmu_get_irq(struct a6xx_gmu *gmu, struct platform_device *pdev,\n\t\tconst char *name, irq_handler_t handler)\n{\n\tint irq, ret;\n\n\tirq = platform_get_irq_byname(pdev, name);\n\n\tret = request_irq(irq, handler, IRQF_TRIGGER_HIGH, name, gmu);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(&pdev->dev, \"Unable to get interrupt %s %d\\n\",\n\t\t\t      name, ret);\n\t\treturn ret;\n\t}\n\n\tdisable_irq(irq);\n\n\treturn irq;\n}\n\nvoid a6xx_gmu_remove(struct a6xx_gpu *a6xx_gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\tstruct platform_device *pdev = to_platform_device(gmu->dev);\n\n\tmutex_lock(&gmu->lock);\n\tif (!gmu->initialized) {\n\t\tmutex_unlock(&gmu->lock);\n\t\treturn;\n\t}\n\n\tgmu->initialized = false;\n\n\tmutex_unlock(&gmu->lock);\n\n\tpm_runtime_force_suspend(gmu->dev);\n\n\t \n\tdev_pm_domain_detach(gmu->cxpd, false);\n\n\tif (!IS_ERR_OR_NULL(gmu->gxpd)) {\n\t\tpm_runtime_disable(gmu->gxpd);\n\t\tdev_pm_domain_detach(gmu->gxpd, false);\n\t}\n\n\tiounmap(gmu->mmio);\n\tif (platform_get_resource_byname(pdev, IORESOURCE_MEM, \"rscc\"))\n\t\tiounmap(gmu->rscc);\n\tgmu->mmio = NULL;\n\tgmu->rscc = NULL;\n\n\tif (!adreno_has_gmu_wrapper(adreno_gpu)) {\n\t\ta6xx_gmu_memory_free(gmu);\n\n\t\tfree_irq(gmu->gmu_irq, gmu);\n\t\tfree_irq(gmu->hfi_irq, gmu);\n\t}\n\n\t \n\tput_device(gmu->dev);\n}\n\nstatic int cxpd_notifier_cb(struct notifier_block *nb,\n\t\t\tunsigned long action, void *data)\n{\n\tstruct a6xx_gmu *gmu = container_of(nb, struct a6xx_gmu, pd_nb);\n\n\tif (action == GENPD_NOTIFY_OFF)\n\t\tcomplete_all(&gmu->pd_gate);\n\n\treturn 0;\n}\n\nint a6xx_gmu_wrapper_init(struct a6xx_gpu *a6xx_gpu, struct device_node *node)\n{\n\tstruct platform_device *pdev = of_find_device_by_node(node);\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\tint ret;\n\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tgmu->dev = &pdev->dev;\n\n\tof_dma_configure(gmu->dev, node, true);\n\n\tpm_runtime_enable(gmu->dev);\n\n\t \n\tgmu->legacy = true;\n\n\t \n\tgmu->mmio = a6xx_gmu_get_mmio(pdev, \"gmu\");\n\tif (IS_ERR(gmu->mmio)) {\n\t\tret = PTR_ERR(gmu->mmio);\n\t\tgoto err_mmio;\n\t}\n\n\tgmu->cxpd = dev_pm_domain_attach_by_name(gmu->dev, \"cx\");\n\tif (IS_ERR(gmu->cxpd)) {\n\t\tret = PTR_ERR(gmu->cxpd);\n\t\tgoto err_mmio;\n\t}\n\n\tif (!device_link_add(gmu->dev, gmu->cxpd, DL_FLAG_PM_RUNTIME)) {\n\t\tret = -ENODEV;\n\t\tgoto detach_cxpd;\n\t}\n\n\tinit_completion(&gmu->pd_gate);\n\tcomplete_all(&gmu->pd_gate);\n\tgmu->pd_nb.notifier_call = cxpd_notifier_cb;\n\n\t \n\tgmu->gxpd = dev_pm_domain_attach_by_name(gmu->dev, \"gx\");\n\tif (IS_ERR(gmu->gxpd)) {\n\t\tret = PTR_ERR(gmu->gxpd);\n\t\tgoto err_mmio;\n\t}\n\n\tgmu->initialized = true;\n\n\treturn 0;\n\ndetach_cxpd:\n\tdev_pm_domain_detach(gmu->cxpd, false);\n\nerr_mmio:\n\tiounmap(gmu->mmio);\n\n\t \n\tput_device(gmu->dev);\n\n\treturn ret;\n}\n\nint a6xx_gmu_init(struct a6xx_gpu *a6xx_gpu, struct device_node *node)\n{\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\tstruct platform_device *pdev = of_find_device_by_node(node);\n\tint ret;\n\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tgmu->dev = &pdev->dev;\n\n\tof_dma_configure(gmu->dev, node, true);\n\n\t \n\tgmu->idle_level = GMU_IDLE_STATE_ACTIVE;\n\n\tpm_runtime_enable(gmu->dev);\n\n\t \n\tret = a6xx_gmu_clocks_probe(gmu);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tret = a6xx_gmu_memory_probe(gmu);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\n\t \n\tgmu->dummy.size = SZ_4K;\n\tif (adreno_is_a660_family(adreno_gpu)) {\n\t\tret = a6xx_gmu_memory_alloc(gmu, &gmu->debug, SZ_4K * 7,\n\t\t\t\t\t    0x60400000, \"debug\");\n\t\tif (ret)\n\t\t\tgoto err_memory;\n\n\t\tgmu->dummy.size = SZ_8K;\n\t}\n\n\t \n\tret = a6xx_gmu_memory_alloc(gmu, &gmu->dummy, gmu->dummy.size,\n\t\t\t\t    0x60000000, \"dummy\");\n\tif (ret)\n\t\tgoto err_memory;\n\n\t \n\tif (adreno_is_a650_family(adreno_gpu)) {\n\t\tret = a6xx_gmu_memory_alloc(gmu, &gmu->icache,\n\t\t\tSZ_16M - SZ_16K, 0x04000, \"icache\");\n\t\tif (ret)\n\t\t\tgoto err_memory;\n\t \n\t} else if (adreno_is_a640_family(adreno_gpu)) {\n\t\tret = a6xx_gmu_memory_alloc(gmu, &gmu->icache,\n\t\t\tSZ_256K - SZ_16K, 0x04000, \"icache\");\n\t\tif (ret)\n\t\t\tgoto err_memory;\n\n\t\tret = a6xx_gmu_memory_alloc(gmu, &gmu->dcache,\n\t\t\tSZ_256K - SZ_16K, 0x44000, \"dcache\");\n\t\tif (ret)\n\t\t\tgoto err_memory;\n\t} else if (adreno_is_a630_family(adreno_gpu)) {\n\t\t \n\t\tgmu->legacy = true;\n\n\t\t \n\t\tret = a6xx_gmu_memory_alloc(gmu, &gmu->debug, SZ_16K, 0, \"debug\");\n\t\tif (ret)\n\t\t\tgoto err_memory;\n\t}\n\n\t \n\tret = a6xx_gmu_memory_alloc(gmu, &gmu->log, SZ_16K, 0, \"log\");\n\tif (ret)\n\t\tgoto err_memory;\n\n\t \n\tret = a6xx_gmu_memory_alloc(gmu, &gmu->hfi, SZ_16K, 0, \"hfi\");\n\tif (ret)\n\t\tgoto err_memory;\n\n\t \n\tgmu->mmio = a6xx_gmu_get_mmio(pdev, \"gmu\");\n\tif (IS_ERR(gmu->mmio)) {\n\t\tret = PTR_ERR(gmu->mmio);\n\t\tgoto err_memory;\n\t}\n\n\tif (adreno_is_a650_family(adreno_gpu)) {\n\t\tgmu->rscc = a6xx_gmu_get_mmio(pdev, \"rscc\");\n\t\tif (IS_ERR(gmu->rscc)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_mmio;\n\t\t}\n\t} else {\n\t\tgmu->rscc = gmu->mmio + 0x23000;\n\t}\n\n\t \n\tgmu->hfi_irq = a6xx_gmu_get_irq(gmu, pdev, \"hfi\", a6xx_hfi_irq);\n\tgmu->gmu_irq = a6xx_gmu_get_irq(gmu, pdev, \"gmu\", a6xx_gmu_irq);\n\n\tif (gmu->hfi_irq < 0 || gmu->gmu_irq < 0) {\n\t\tret = -ENODEV;\n\t\tgoto err_mmio;\n\t}\n\n\tgmu->cxpd = dev_pm_domain_attach_by_name(gmu->dev, \"cx\");\n\tif (IS_ERR(gmu->cxpd)) {\n\t\tret = PTR_ERR(gmu->cxpd);\n\t\tgoto err_mmio;\n\t}\n\n\tif (!device_link_add(gmu->dev, gmu->cxpd,\n\t\t\t\t\tDL_FLAG_PM_RUNTIME)) {\n\t\tret = -ENODEV;\n\t\tgoto detach_cxpd;\n\t}\n\n\tinit_completion(&gmu->pd_gate);\n\tcomplete_all(&gmu->pd_gate);\n\tgmu->pd_nb.notifier_call = cxpd_notifier_cb;\n\n\t \n\tgmu->gxpd = dev_pm_domain_attach_by_name(gmu->dev, \"gx\");\n\n\t \n\ta6xx_gmu_pwrlevels_probe(gmu);\n\n\t \n\ta6xx_hfi_init(gmu);\n\n\t \n\ta6xx_gmu_rpmh_init(gmu);\n\n\tgmu->initialized = true;\n\n\treturn 0;\n\ndetach_cxpd:\n\tdev_pm_domain_detach(gmu->cxpd, false);\n\nerr_mmio:\n\tiounmap(gmu->mmio);\n\tif (platform_get_resource_byname(pdev, IORESOURCE_MEM, \"rscc\"))\n\t\tiounmap(gmu->rscc);\n\tfree_irq(gmu->gmu_irq, gmu);\n\tfree_irq(gmu->hfi_irq, gmu);\n\nerr_memory:\n\ta6xx_gmu_memory_free(gmu);\nerr_put_device:\n\t \n\tput_device(gmu->dev);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}