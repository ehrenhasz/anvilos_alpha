{
  "module_name": "a6xx_gpu.c",
  "hash_id": "244d5af07a7244cd296b92fd1cf0ecd321d5f76cd4ae0c9beb48f3294a5ca4b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/adreno/a6xx_gpu.c",
  "human_readable_source": "\n \n\n\n#include \"msm_gem.h\"\n#include \"msm_mmu.h\"\n#include \"msm_gpu_trace.h\"\n#include \"a6xx_gpu.h\"\n#include \"a6xx_gmu.xml.h\"\n\n#include <linux/bitfield.h>\n#include <linux/devfreq.h>\n#include <linux/pm_domain.h>\n#include <linux/soc/qcom/llcc-qcom.h>\n\n#define GPU_PAS_ID 13\n\nstatic inline bool _a6xx_check_idle(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\n\t \n\tif (!adreno_has_gmu_wrapper(adreno_gpu) && !a6xx_gmu_isidle(&a6xx_gpu->gmu))\n\t\treturn false;\n\n\t \n\tif (gpu_read(gpu, REG_A6XX_RBBM_STATUS) &\n\t\t\t~A6XX_RBBM_STATUS_CP_AHB_BUSY_CX_MASTER)\n\t\treturn false;\n\n\treturn !(gpu_read(gpu, REG_A6XX_RBBM_INT_0_STATUS) &\n\t\tA6XX_RBBM_INT_0_MASK_RBBM_HANG_DETECT);\n}\n\nstatic bool a6xx_idle(struct msm_gpu *gpu, struct msm_ringbuffer *ring)\n{\n\t \n\tif (!adreno_idle(gpu, ring))\n\t\treturn false;\n\n\tif (spin_until(_a6xx_check_idle(gpu))) {\n\t\tDRM_ERROR(\"%s: %ps: timeout waiting for GPU to idle: status %8.8X irq %8.8X rptr/wptr %d/%d\\n\",\n\t\t\tgpu->name, __builtin_return_address(0),\n\t\t\tgpu_read(gpu, REG_A6XX_RBBM_STATUS),\n\t\t\tgpu_read(gpu, REG_A6XX_RBBM_INT_0_STATUS),\n\t\t\tgpu_read(gpu, REG_A6XX_CP_RB_RPTR),\n\t\t\tgpu_read(gpu, REG_A6XX_CP_RB_WPTR));\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void update_shadow_rptr(struct msm_gpu *gpu, struct msm_ringbuffer *ring)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\n\t \n\tif (a6xx_gpu->has_whereami && !adreno_gpu->base.hw_apriv) {\n\t\tOUT_PKT7(ring, CP_WHERE_AM_I, 2);\n\t\tOUT_RING(ring, lower_32_bits(shadowptr(a6xx_gpu, ring)));\n\t\tOUT_RING(ring, upper_32_bits(shadowptr(a6xx_gpu, ring)));\n\t}\n}\n\nstatic void a6xx_flush(struct msm_gpu *gpu, struct msm_ringbuffer *ring)\n{\n\tuint32_t wptr;\n\tunsigned long flags;\n\n\tupdate_shadow_rptr(gpu, ring);\n\n\tspin_lock_irqsave(&ring->preempt_lock, flags);\n\n\t \n\tring->cur = ring->next;\n\n\t \n\twptr = get_wptr(ring);\n\n\tspin_unlock_irqrestore(&ring->preempt_lock, flags);\n\n\t \n\tmb();\n\n\tgpu_write(gpu, REG_A6XX_CP_RB_WPTR, wptr);\n}\n\nstatic void get_stats_counter(struct msm_ringbuffer *ring, u32 counter,\n\t\tu64 iova)\n{\n\tOUT_PKT7(ring, CP_REG_TO_MEM, 3);\n\tOUT_RING(ring, CP_REG_TO_MEM_0_REG(counter) |\n\t\tCP_REG_TO_MEM_0_CNT(2) |\n\t\tCP_REG_TO_MEM_0_64B);\n\tOUT_RING(ring, lower_32_bits(iova));\n\tOUT_RING(ring, upper_32_bits(iova));\n}\n\nstatic void a6xx_set_pagetable(struct a6xx_gpu *a6xx_gpu,\n\t\tstruct msm_ringbuffer *ring, struct msm_file_private *ctx)\n{\n\tbool sysprof = refcount_read(&a6xx_gpu->base.base.sysprof_active) > 1;\n\tphys_addr_t ttbr;\n\tu32 asid;\n\tu64 memptr = rbmemptr(ring, ttbr0);\n\n\tif (ctx->seqno == a6xx_gpu->base.base.cur_ctx_seqno)\n\t\treturn;\n\n\tif (msm_iommu_pagetable_params(ctx->aspace->mmu, &ttbr, &asid))\n\t\treturn;\n\n\tif (!sysprof) {\n\t\t \n\t\tOUT_PKT7(ring, CP_SET_PROTECTED_MODE, 1);\n\t\tOUT_RING(ring, 0);\n\n\t\tOUT_PKT4(ring, REG_A6XX_RBBM_PERFCTR_SRAM_INIT_CMD, 1);\n\t\tOUT_RING(ring, 1);\n\t}\n\n\t \n\tOUT_PKT7(ring, CP_SMMU_TABLE_UPDATE, 4);\n\tOUT_RING(ring, CP_SMMU_TABLE_UPDATE_0_TTBR0_LO(lower_32_bits(ttbr)));\n\n\tOUT_RING(ring,\n\t\tCP_SMMU_TABLE_UPDATE_1_TTBR0_HI(upper_32_bits(ttbr)) |\n\t\tCP_SMMU_TABLE_UPDATE_1_ASID(asid));\n\tOUT_RING(ring, CP_SMMU_TABLE_UPDATE_2_CONTEXTIDR(0));\n\tOUT_RING(ring, CP_SMMU_TABLE_UPDATE_3_CONTEXTBANK(0));\n\n\t \n\tOUT_PKT7(ring, CP_MEM_WRITE, 4);\n\tOUT_RING(ring, CP_MEM_WRITE_0_ADDR_LO(lower_32_bits(memptr)));\n\tOUT_RING(ring, CP_MEM_WRITE_1_ADDR_HI(upper_32_bits(memptr)));\n\tOUT_RING(ring, lower_32_bits(ttbr));\n\tOUT_RING(ring, (asid << 16) | upper_32_bits(ttbr));\n\n\t \n\n\tOUT_PKT7(ring, CP_EVENT_WRITE, 1);\n\tOUT_RING(ring, CACHE_INVALIDATE);\n\n\tif (!sysprof) {\n\t\t \n\t\tOUT_PKT7(ring, CP_WAIT_REG_MEM, 6);\n\t\tOUT_RING(ring, CP_WAIT_REG_MEM_0_FUNCTION(WRITE_EQ));\n\t\tOUT_RING(ring, CP_WAIT_REG_MEM_1_POLL_ADDR_LO(\n\t\t\t\tREG_A6XX_RBBM_PERFCTR_SRAM_INIT_STATUS));\n\t\tOUT_RING(ring, CP_WAIT_REG_MEM_2_POLL_ADDR_HI(0));\n\t\tOUT_RING(ring, CP_WAIT_REG_MEM_3_REF(0x1));\n\t\tOUT_RING(ring, CP_WAIT_REG_MEM_4_MASK(0x1));\n\t\tOUT_RING(ring, CP_WAIT_REG_MEM_5_DELAY_LOOP_CYCLES(0));\n\n\t\t \n\t\tOUT_PKT7(ring, CP_SET_PROTECTED_MODE, 1);\n\t\tOUT_RING(ring, 1);\n\t}\n}\n\nstatic void a6xx_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit)\n{\n\tunsigned int index = submit->seqno % MSM_GPU_SUBMIT_STATS_COUNT;\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tstruct msm_ringbuffer *ring = submit->ring;\n\tunsigned int i, ibs = 0;\n\n\ta6xx_set_pagetable(a6xx_gpu, ring, submit->queue->ctx);\n\n\tget_stats_counter(ring, REG_A6XX_RBBM_PERFCTR_CP(0),\n\t\trbmemptr_stats(ring, index, cpcycles_start));\n\n\t \n\tget_stats_counter(ring, REG_A6XX_CP_ALWAYS_ON_COUNTER,\n\t\trbmemptr_stats(ring, index, alwayson_start));\n\n\t \n\tOUT_PKT7(ring, CP_EVENT_WRITE, 1);\n\tOUT_RING(ring, CP_EVENT_WRITE_0_EVENT(PC_CCU_INVALIDATE_DEPTH));\n\n\tOUT_PKT7(ring, CP_EVENT_WRITE, 1);\n\tOUT_RING(ring, CP_EVENT_WRITE_0_EVENT(PC_CCU_INVALIDATE_COLOR));\n\n\t \n\tfor (i = 0; i < submit->nr_cmds; i++) {\n\t\tswitch (submit->cmd[i].type) {\n\t\tcase MSM_SUBMIT_CMD_IB_TARGET_BUF:\n\t\t\tbreak;\n\t\tcase MSM_SUBMIT_CMD_CTX_RESTORE_BUF:\n\t\t\tif (gpu->cur_ctx_seqno == submit->queue->ctx->seqno)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase MSM_SUBMIT_CMD_BUF:\n\t\t\tOUT_PKT7(ring, CP_INDIRECT_BUFFER_PFE, 3);\n\t\t\tOUT_RING(ring, lower_32_bits(submit->cmd[i].iova));\n\t\t\tOUT_RING(ring, upper_32_bits(submit->cmd[i].iova));\n\t\t\tOUT_RING(ring, submit->cmd[i].size);\n\t\t\tibs++;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif ((ibs % 32) == 0)\n\t\t\tupdate_shadow_rptr(gpu, ring);\n\t}\n\n\tget_stats_counter(ring, REG_A6XX_RBBM_PERFCTR_CP(0),\n\t\trbmemptr_stats(ring, index, cpcycles_end));\n\tget_stats_counter(ring, REG_A6XX_CP_ALWAYS_ON_COUNTER,\n\t\trbmemptr_stats(ring, index, alwayson_end));\n\n\t \n\tOUT_PKT4(ring, REG_A6XX_CP_SCRATCH_REG(2), 1);\n\tOUT_RING(ring, submit->seqno);\n\n\t \n\tOUT_PKT7(ring, CP_EVENT_WRITE, 4);\n\tOUT_RING(ring, CP_EVENT_WRITE_0_EVENT(CACHE_FLUSH_TS) |\n\t\tCP_EVENT_WRITE_0_IRQ);\n\tOUT_RING(ring, lower_32_bits(rbmemptr(ring, fence)));\n\tOUT_RING(ring, upper_32_bits(rbmemptr(ring, fence)));\n\tOUT_RING(ring, submit->seqno);\n\n\ttrace_msm_gpu_submit_flush(submit,\n\t\tgpu_read64(gpu, REG_A6XX_CP_ALWAYS_ON_COUNTER));\n\n\ta6xx_flush(gpu, ring);\n}\n\nconst struct adreno_reglist a612_hwcg[] = {\n\t{REG_A6XX_RBBM_CLOCK_CNTL_SP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_SP0, 0x02222220},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_SP0, 0x00000081},\n\t{REG_A6XX_RBBM_CLOCK_HYST_SP0, 0x0000f3cf},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_TP0, 0x00022222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY2_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY3_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY4_TP0, 0x00011111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST2_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST3_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST4_TP0, 0x00077777},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RB0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RB0, 0x01202222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU0, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU0, 0x00040f00},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RAC, 0x05522022},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RAC, 0x00005555},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_RAC, 0x00000011},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RAC, 0x00445044},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TSE_RAS_RBBM, 0x04222222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_GPC, 0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ_2, 0x00000002},\n\t{REG_A6XX_RBBM_CLOCK_MODE_HLSQ, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TSE_RAS_RBBM, 0x00004000},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GPC, 0x00000200},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TSE_RAS_RBBM, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_VFD, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GPC, 0x04104004},\n\t{REG_A6XX_RBBM_CLOCK_HYST_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_UCHE, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_HYST_UCHE, 0x00000004},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_UCHE, 0x00000002},\n\t{REG_A6XX_RBBM_ISDB_CNT, 0x00000182},\n\t{REG_A6XX_RBBM_RAC_THRESHOLD_CNT, 0x00000000},\n\t{REG_A6XX_RBBM_SP_HYST_CNT, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_GMU_GX, 0x00000222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GMU_GX, 0x00000111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GMU_GX, 0x00000555},\n\t{},\n};\n\n \nconst struct adreno_reglist a615_hwcg[] = {\n\t{REG_A6XX_RBBM_CLOCK_CNTL_SP0,  0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_SP0, 0x02222220},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_SP0, 0x00000080},\n\t{REG_A6XX_RBBM_CLOCK_HYST_SP0,  0x0000F3CF},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TP0,  0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TP1,  0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_TP1, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_TP1, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_TP0, 0x00022222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_TP1, 0x00022222},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TP0,  0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TP1,  0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST2_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST2_TP1, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST3_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST3_TP1, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST4_TP0, 0x00077777},\n\t{REG_A6XX_RBBM_CLOCK_HYST4_TP1, 0x00077777},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TP1, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY2_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY2_TP1, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY3_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY3_TP1, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY4_TP0, 0x00011111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY4_TP1, 0x00011111},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_UCHE,  0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_UCHE, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_UCHE, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_UCHE, 0x00222222},\n\t{REG_A6XX_RBBM_CLOCK_HYST_UCHE,  0x00000004},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_UCHE, 0x00000002},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RB0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RB0, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU0, 0x00002020},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU1, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU2, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU3, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU0, 0x00040F00},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU1, 0x00040F00},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU2, 0x00040F00},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU3, 0x00040F00},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RAC, 0x05022022},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RAC, 0x00005555},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_RAC, 0x00000011},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RAC, 0x00445044},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TSE_RAS_RBBM, 0x04222222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_GPC, 0x00222222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TSE_RAS_RBBM, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GPC, 0x04104004},\n\t{REG_A6XX_RBBM_CLOCK_HYST_VFD, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TSE_RAS_RBBM, 0x00004000},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GPC, 0x00000200},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ_2, 0x00000002},\n\t{REG_A6XX_RBBM_CLOCK_MODE_HLSQ, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_GMU_GX, 0x00000222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GMU_GX, 0x00000111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GMU_GX, 0x00000555},\n\t{},\n};\n\nconst struct adreno_reglist a630_hwcg[] = {\n\t{REG_A6XX_RBBM_CLOCK_CNTL_SP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_SP1, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_SP2, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_SP3, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_SP0, 0x02022220},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_SP1, 0x02022220},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_SP2, 0x02022220},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_SP3, 0x02022220},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_SP0, 0x00000080},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_SP1, 0x00000080},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_SP2, 0x00000080},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_SP3, 0x00000080},\n\t{REG_A6XX_RBBM_CLOCK_HYST_SP0, 0x0000f3cf},\n\t{REG_A6XX_RBBM_CLOCK_HYST_SP1, 0x0000f3cf},\n\t{REG_A6XX_RBBM_CLOCK_HYST_SP2, 0x0000f3cf},\n\t{REG_A6XX_RBBM_CLOCK_HYST_SP3, 0x0000f3cf},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TP0, 0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TP1, 0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TP2, 0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TP3, 0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_TP1, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_TP2, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_TP3, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_TP1, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_TP2, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_TP3, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_TP0, 0x00022222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_TP1, 0x00022222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_TP2, 0x00022222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_TP3, 0x00022222},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TP1, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TP2, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TP3, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST2_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST2_TP1, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST2_TP2, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST2_TP3, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST3_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST3_TP1, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST3_TP2, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST3_TP3, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST4_TP0, 0x00077777},\n\t{REG_A6XX_RBBM_CLOCK_HYST4_TP1, 0x00077777},\n\t{REG_A6XX_RBBM_CLOCK_HYST4_TP2, 0x00077777},\n\t{REG_A6XX_RBBM_CLOCK_HYST4_TP3, 0x00077777},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TP1, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TP2, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TP3, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY2_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY2_TP1, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY2_TP2, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY2_TP3, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY3_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY3_TP1, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY3_TP2, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY3_TP3, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY4_TP0, 0x00011111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY4_TP1, 0x00011111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY4_TP2, 0x00011111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY4_TP3, 0x00011111},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_UCHE, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_UCHE, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_UCHE, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_UCHE, 0x00222222},\n\t{REG_A6XX_RBBM_CLOCK_HYST_UCHE, 0x00000004},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_UCHE, 0x00000002},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RB0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RB1, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RB2, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RB3, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RB0, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RB1, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RB2, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RB3, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU0, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU1, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU2, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU3, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU0, 0x00040f00},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU1, 0x00040f00},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU2, 0x00040f00},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU3, 0x00040f00},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RAC, 0x05022022},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RAC, 0x00005555},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_RAC, 0x00000011},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RAC, 0x00445044},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TSE_RAS_RBBM, 0x04222222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_GPC, 0x00222222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TSE_RAS_RBBM, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GPC, 0x04104004},\n\t{REG_A6XX_RBBM_CLOCK_HYST_VFD, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TSE_RAS_RBBM, 0x00004000},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GPC, 0x00000200},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ_2, 0x00000002},\n\t{REG_A6XX_RBBM_CLOCK_MODE_HLSQ, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_GMU_GX, 0x00000222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GMU_GX, 0x00000111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GMU_GX, 0x00000555},\n\t{},\n};\n\nconst struct adreno_reglist a640_hwcg[] = {\n\t{REG_A6XX_RBBM_CLOCK_CNTL_SP0, 0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_SP0, 0x02222220},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_SP0, 0x00000080},\n\t{REG_A6XX_RBBM_CLOCK_HYST_SP0, 0x0000F3CF},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TP0, 0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_TP0, 0x00022222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY2_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY3_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY4_TP0, 0x00011111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST2_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST3_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST4_TP0, 0x00077777},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RB0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RB0, 0x01002222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU0, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU0, 0x00040F00},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RAC, 0x05222022},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RAC, 0x00005555},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_RAC, 0x00000011},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RAC, 0x00445044},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TSE_RAS_RBBM, 0x04222222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_GPC, 0x00222222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ_2, 0x00000002},\n\t{REG_A6XX_RBBM_CLOCK_MODE_HLSQ, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TSE_RAS_RBBM, 0x00004000},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GPC, 0x00000200},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TSE_RAS_RBBM, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_VFD, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GPC, 0x04104004},\n\t{REG_A6XX_RBBM_CLOCK_HYST_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TEX_FCHE, 0x00000222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TEX_FCHE, 0x00000111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TEX_FCHE, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_UCHE, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_HYST_UCHE, 0x00000004},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_UCHE, 0x00000002},\n\t{REG_A6XX_RBBM_ISDB_CNT, 0x00000182},\n\t{REG_A6XX_RBBM_RAC_THRESHOLD_CNT, 0x00000000},\n\t{REG_A6XX_RBBM_SP_HYST_CNT, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_GMU_GX, 0x00000222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GMU_GX, 0x00000111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GMU_GX, 0x00000555},\n\t{},\n};\n\nconst struct adreno_reglist a650_hwcg[] = {\n\t{REG_A6XX_RBBM_CLOCK_CNTL_SP0, 0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_SP0, 0x02222220},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_SP0, 0x00000080},\n\t{REG_A6XX_RBBM_CLOCK_HYST_SP0, 0x0000F3CF},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TP0, 0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_TP0, 0x00022222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY2_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY3_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY4_TP0, 0x00011111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST2_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST3_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST4_TP0, 0x00077777},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RB0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RB0, 0x01002222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU0, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU0, 0x00040F00},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RAC, 0x25222022},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RAC, 0x00005555},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_RAC, 0x00000011},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RAC, 0x00445044},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TSE_RAS_RBBM, 0x04222222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_GPC, 0x00222222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ_2, 0x00000002},\n\t{REG_A6XX_RBBM_CLOCK_MODE_HLSQ, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TSE_RAS_RBBM, 0x00004000},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GPC, 0x00000200},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TSE_RAS_RBBM, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_VFD, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GPC, 0x04104004},\n\t{REG_A6XX_RBBM_CLOCK_HYST_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TEX_FCHE, 0x00000222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TEX_FCHE, 0x00000111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TEX_FCHE, 0x00000777},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_UCHE, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_HYST_UCHE, 0x00000004},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_UCHE, 0x00000002},\n\t{REG_A6XX_RBBM_ISDB_CNT, 0x00000182},\n\t{REG_A6XX_RBBM_RAC_THRESHOLD_CNT, 0x00000000},\n\t{REG_A6XX_RBBM_SP_HYST_CNT, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_GMU_GX, 0x00000222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GMU_GX, 0x00000111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GMU_GX, 0x00000555},\n\t{},\n};\n\nconst struct adreno_reglist a660_hwcg[] = {\n\t{REG_A6XX_RBBM_CLOCK_CNTL_SP0, 0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_SP0, 0x02222220},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_SP0, 0x00000080},\n\t{REG_A6XX_RBBM_CLOCK_HYST_SP0, 0x0000F3CF},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_TP0, 0x00022222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY2_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY3_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY4_TP0, 0x00011111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST2_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST3_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST4_TP0, 0x00077777},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RB0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RB0, 0x01002222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU0, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU0, 0x00040F00},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RAC, 0x25222022},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RAC, 0x00005555},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_RAC, 0x00000011},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RAC, 0x00445044},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TSE_RAS_RBBM, 0x04222222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_GPC, 0x00222222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ_2, 0x00000002},\n\t{REG_A6XX_RBBM_CLOCK_MODE_HLSQ, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TSE_RAS_RBBM, 0x00004000},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GPC, 0x00000200},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TSE_RAS_RBBM, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_VFD, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GPC, 0x04104004},\n\t{REG_A6XX_RBBM_CLOCK_HYST_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TEX_FCHE, 0x00000222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TEX_FCHE, 0x00000111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TEX_FCHE, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_UCHE, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_HYST_UCHE, 0x00000004},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_UCHE, 0x00000002},\n\t{REG_A6XX_RBBM_ISDB_CNT, 0x00000182},\n\t{REG_A6XX_RBBM_RAC_THRESHOLD_CNT, 0x00000000},\n\t{REG_A6XX_RBBM_SP_HYST_CNT, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_GMU_GX, 0x00000222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GMU_GX, 0x00000111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GMU_GX, 0x00000555},\n\t{},\n};\n\nconst struct adreno_reglist a690_hwcg[] = {\n\t{REG_A6XX_RBBM_CLOCK_CNTL_SP0, 0x02222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_SP0, 0x02222220},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_SP0, 0x00000080},\n\t{REG_A6XX_RBBM_CLOCK_HYST_SP0, 0x0000F3CF},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL3_TP0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL4_TP0, 0x00022222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY2_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY3_TP0, 0x11111111},\n\t{REG_A6XX_RBBM_CLOCK_DELAY4_TP0, 0x00011111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST2_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST3_TP0, 0x77777777},\n\t{REG_A6XX_RBBM_CLOCK_HYST4_TP0, 0x00077777},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RB0, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RB0, 0x01002222},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_CCU0, 0x00002220},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RB_CCU0, 0x00040F00},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_RAC, 0x25222022},\n\t{REG_A6XX_RBBM_CLOCK_CNTL2_RAC, 0x00005555},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_RAC, 0x00000011},\n\t{REG_A6XX_RBBM_CLOCK_HYST_RAC, 0x00445044},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TSE_RAS_RBBM, 0x04222222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_MODE_GPC, 0x00222222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ_2, 0x00000002},\n\t{REG_A6XX_RBBM_CLOCK_MODE_HLSQ, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TSE_RAS_RBBM, 0x00004000},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_VFD, 0x00002222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GPC, 0x00000200},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TSE_RAS_RBBM, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_VFD, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GPC, 0x04104004},\n\t{REG_A6XX_RBBM_CLOCK_HYST_HLSQ, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_TEX_FCHE, 0x00000222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_TEX_FCHE, 0x00000111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_TEX_FCHE, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_UCHE, 0x22222222},\n\t{REG_A6XX_RBBM_CLOCK_HYST_UCHE, 0x00000004},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_UCHE, 0x00000002},\n\t{REG_A6XX_RBBM_CLOCK_CNTL, 0x8AA8AA82},\n\t{REG_A6XX_RBBM_ISDB_CNT, 0x00000182},\n\t{REG_A6XX_RBBM_RAC_THRESHOLD_CNT, 0x00000000},\n\t{REG_A6XX_RBBM_SP_HYST_CNT, 0x00000000},\n\t{REG_A6XX_RBBM_CLOCK_CNTL_GMU_GX, 0x00000222},\n\t{REG_A6XX_RBBM_CLOCK_DELAY_GMU_GX, 0x00000111},\n\t{REG_A6XX_RBBM_CLOCK_HYST_GMU_GX, 0x00000555},\n\t{REG_A6XX_GPU_GMU_AO_GMU_CGC_MODE_CNTL, 0x20200},\n\t{REG_A6XX_GPU_GMU_AO_GMU_CGC_DELAY_CNTL, 0x10111},\n\t{REG_A6XX_GPU_GMU_AO_GMU_CGC_HYST_CNTL, 0x5555},\n\t{}\n};\n\nstatic void a6xx_set_hwcg(struct msm_gpu *gpu, bool state)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\tconst struct adreno_reglist *reg;\n\tunsigned int i;\n\tu32 val, clock_cntl_on;\n\n\tif (!adreno_gpu->info->hwcg)\n\t\treturn;\n\n\tif (adreno_is_a630(adreno_gpu))\n\t\tclock_cntl_on = 0x8aa8aa02;\n\telse if (adreno_is_a610(adreno_gpu))\n\t\tclock_cntl_on = 0xaaa8aa82;\n\telse\n\t\tclock_cntl_on = 0x8aa8aa82;\n\n\tval = gpu_read(gpu, REG_A6XX_RBBM_CLOCK_CNTL);\n\n\t \n\tif ((!state && !val) || (state && (val == clock_cntl_on)))\n\t\treturn;\n\n\t \n\tif (!adreno_is_a610(adreno_gpu))\n\t\tgmu_rmw(gmu, REG_A6XX_GPU_GMU_GX_SPTPRAC_CLOCK_CONTROL, 1, 0);\n\n\tfor (i = 0; (reg = &adreno_gpu->info->hwcg[i], reg->offset); i++)\n\t\tgpu_write(gpu, reg->offset, state ? reg->value : 0);\n\n\t \n\tif (!adreno_is_a610(adreno_gpu))\n\t\tgmu_rmw(gmu, REG_A6XX_GPU_GMU_GX_SPTPRAC_CLOCK_CONTROL, 0, 1);\n\n\tgpu_write(gpu, REG_A6XX_RBBM_CLOCK_CNTL, state ? clock_cntl_on : 0);\n}\n\n \nstatic const u32 a6xx_protect[] = {\n\tA6XX_PROTECT_RDONLY(0x00000, 0x04ff),\n\tA6XX_PROTECT_RDONLY(0x00501, 0x0005),\n\tA6XX_PROTECT_RDONLY(0x0050b, 0x02f4),\n\tA6XX_PROTECT_NORDWR(0x0050e, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x00510, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x00534, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x00800, 0x0082),\n\tA6XX_PROTECT_NORDWR(0x008a0, 0x0008),\n\tA6XX_PROTECT_NORDWR(0x008ab, 0x0024),\n\tA6XX_PROTECT_RDONLY(0x008de, 0x00ae),\n\tA6XX_PROTECT_NORDWR(0x00900, 0x004d),\n\tA6XX_PROTECT_NORDWR(0x0098d, 0x0272),\n\tA6XX_PROTECT_NORDWR(0x00e00, 0x0001),\n\tA6XX_PROTECT_NORDWR(0x00e03, 0x000c),\n\tA6XX_PROTECT_NORDWR(0x03c00, 0x00c3),\n\tA6XX_PROTECT_RDONLY(0x03cc4, 0x1fff),\n\tA6XX_PROTECT_NORDWR(0x08630, 0x01cf),\n\tA6XX_PROTECT_NORDWR(0x08e00, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x08e08, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x08e50, 0x001f),\n\tA6XX_PROTECT_NORDWR(0x09624, 0x01db),\n\tA6XX_PROTECT_NORDWR(0x09e70, 0x0001),\n\tA6XX_PROTECT_NORDWR(0x09e78, 0x0187),\n\tA6XX_PROTECT_NORDWR(0x0a630, 0x01cf),\n\tA6XX_PROTECT_NORDWR(0x0ae02, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x0ae50, 0x032f),\n\tA6XX_PROTECT_NORDWR(0x0b604, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x0be02, 0x0001),\n\tA6XX_PROTECT_NORDWR(0x0be20, 0x17df),\n\tA6XX_PROTECT_NORDWR(0x0f000, 0x0bff),\n\tA6XX_PROTECT_RDONLY(0x0fc00, 0x1fff),\n\tA6XX_PROTECT_NORDWR(0x11c00, 0x0000),  \n};\n\n \nstatic const u32 a650_protect[] = {\n\tA6XX_PROTECT_RDONLY(0x00000, 0x04ff),\n\tA6XX_PROTECT_RDONLY(0x00501, 0x0005),\n\tA6XX_PROTECT_RDONLY(0x0050b, 0x02f4),\n\tA6XX_PROTECT_NORDWR(0x0050e, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x00510, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x00534, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x00800, 0x0082),\n\tA6XX_PROTECT_NORDWR(0x008a0, 0x0008),\n\tA6XX_PROTECT_NORDWR(0x008ab, 0x0024),\n\tA6XX_PROTECT_RDONLY(0x008de, 0x00ae),\n\tA6XX_PROTECT_NORDWR(0x00900, 0x004d),\n\tA6XX_PROTECT_NORDWR(0x0098d, 0x0272),\n\tA6XX_PROTECT_NORDWR(0x00e00, 0x0001),\n\tA6XX_PROTECT_NORDWR(0x00e03, 0x000c),\n\tA6XX_PROTECT_NORDWR(0x03c00, 0x00c3),\n\tA6XX_PROTECT_RDONLY(0x03cc4, 0x1fff),\n\tA6XX_PROTECT_NORDWR(0x08630, 0x01cf),\n\tA6XX_PROTECT_NORDWR(0x08e00, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x08e08, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x08e50, 0x001f),\n\tA6XX_PROTECT_NORDWR(0x08e80, 0x027f),\n\tA6XX_PROTECT_NORDWR(0x09624, 0x01db),\n\tA6XX_PROTECT_NORDWR(0x09e60, 0x0011),\n\tA6XX_PROTECT_NORDWR(0x09e78, 0x0187),\n\tA6XX_PROTECT_NORDWR(0x0a630, 0x01cf),\n\tA6XX_PROTECT_NORDWR(0x0ae02, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x0ae50, 0x032f),\n\tA6XX_PROTECT_NORDWR(0x0b604, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x0b608, 0x0007),\n\tA6XX_PROTECT_NORDWR(0x0be02, 0x0001),\n\tA6XX_PROTECT_NORDWR(0x0be20, 0x17df),\n\tA6XX_PROTECT_NORDWR(0x0f000, 0x0bff),\n\tA6XX_PROTECT_RDONLY(0x0fc00, 0x1fff),\n\tA6XX_PROTECT_NORDWR(0x18400, 0x1fff),\n\tA6XX_PROTECT_NORDWR(0x1a800, 0x1fff),\n\tA6XX_PROTECT_NORDWR(0x1f400, 0x0443),\n\tA6XX_PROTECT_RDONLY(0x1f844, 0x007b),\n\tA6XX_PROTECT_NORDWR(0x1f887, 0x001b),\n\tA6XX_PROTECT_NORDWR(0x1f8c0, 0x0000),  \n};\n\n \nstatic const u32 a660_protect[] = {\n\tA6XX_PROTECT_RDONLY(0x00000, 0x04ff),\n\tA6XX_PROTECT_RDONLY(0x00501, 0x0005),\n\tA6XX_PROTECT_RDONLY(0x0050b, 0x02f4),\n\tA6XX_PROTECT_NORDWR(0x0050e, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x00510, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x00534, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x00800, 0x0082),\n\tA6XX_PROTECT_NORDWR(0x008a0, 0x0008),\n\tA6XX_PROTECT_NORDWR(0x008ab, 0x0024),\n\tA6XX_PROTECT_RDONLY(0x008de, 0x00ae),\n\tA6XX_PROTECT_NORDWR(0x00900, 0x004d),\n\tA6XX_PROTECT_NORDWR(0x0098d, 0x0272),\n\tA6XX_PROTECT_NORDWR(0x00e00, 0x0001),\n\tA6XX_PROTECT_NORDWR(0x00e03, 0x000c),\n\tA6XX_PROTECT_NORDWR(0x03c00, 0x00c3),\n\tA6XX_PROTECT_RDONLY(0x03cc4, 0x1fff),\n\tA6XX_PROTECT_NORDWR(0x08630, 0x01cf),\n\tA6XX_PROTECT_NORDWR(0x08e00, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x08e08, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x08e50, 0x001f),\n\tA6XX_PROTECT_NORDWR(0x08e80, 0x027f),\n\tA6XX_PROTECT_NORDWR(0x09624, 0x01db),\n\tA6XX_PROTECT_NORDWR(0x09e60, 0x0011),\n\tA6XX_PROTECT_NORDWR(0x09e78, 0x0187),\n\tA6XX_PROTECT_NORDWR(0x0a630, 0x01cf),\n\tA6XX_PROTECT_NORDWR(0x0ae02, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x0ae50, 0x012f),\n\tA6XX_PROTECT_NORDWR(0x0b604, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x0b608, 0x0006),\n\tA6XX_PROTECT_NORDWR(0x0be02, 0x0001),\n\tA6XX_PROTECT_NORDWR(0x0be20, 0x015f),\n\tA6XX_PROTECT_NORDWR(0x0d000, 0x05ff),\n\tA6XX_PROTECT_NORDWR(0x0f000, 0x0bff),\n\tA6XX_PROTECT_RDONLY(0x0fc00, 0x1fff),\n\tA6XX_PROTECT_NORDWR(0x18400, 0x1fff),\n\tA6XX_PROTECT_NORDWR(0x1a400, 0x1fff),\n\tA6XX_PROTECT_NORDWR(0x1f400, 0x0443),\n\tA6XX_PROTECT_RDONLY(0x1f844, 0x007b),\n\tA6XX_PROTECT_NORDWR(0x1f860, 0x0000),\n\tA6XX_PROTECT_NORDWR(0x1f887, 0x001b),\n\tA6XX_PROTECT_NORDWR(0x1f8c0, 0x0000),  \n};\n\n \nstatic const u32 a690_protect[] = {\n\tA6XX_PROTECT_RDONLY(0x00000, 0x004ff),\n\tA6XX_PROTECT_RDONLY(0x00501, 0x00001),\n\tA6XX_PROTECT_RDONLY(0x0050b, 0x002f4),\n\tA6XX_PROTECT_NORDWR(0x0050e, 0x00000),\n\tA6XX_PROTECT_NORDWR(0x00510, 0x00000),\n\tA6XX_PROTECT_NORDWR(0x00534, 0x00000),\n\tA6XX_PROTECT_NORDWR(0x00800, 0x00082),\n\tA6XX_PROTECT_NORDWR(0x008a0, 0x00008),\n\tA6XX_PROTECT_NORDWR(0x008ab, 0x00024),\n\tA6XX_PROTECT_RDONLY(0x008de, 0x000ae),\n\tA6XX_PROTECT_NORDWR(0x00900, 0x0004d),\n\tA6XX_PROTECT_NORDWR(0x0098d, 0x00272),\n\tA6XX_PROTECT_NORDWR(0x00e00, 0x00001),\n\tA6XX_PROTECT_NORDWR(0x00e03, 0x0000c),\n\tA6XX_PROTECT_NORDWR(0x03c00, 0x000c3),\n\tA6XX_PROTECT_RDONLY(0x03cc4, 0x01fff),\n\tA6XX_PROTECT_NORDWR(0x08630, 0x001cf),\n\tA6XX_PROTECT_NORDWR(0x08e00, 0x00000),\n\tA6XX_PROTECT_NORDWR(0x08e08, 0x00007),\n\tA6XX_PROTECT_NORDWR(0x08e50, 0x0001f),\n\tA6XX_PROTECT_NORDWR(0x08e80, 0x0027f),\n\tA6XX_PROTECT_NORDWR(0x09624, 0x001db),\n\tA6XX_PROTECT_NORDWR(0x09e60, 0x00011),\n\tA6XX_PROTECT_NORDWR(0x09e78, 0x00187),\n\tA6XX_PROTECT_NORDWR(0x0a630, 0x001cf),\n\tA6XX_PROTECT_NORDWR(0x0ae02, 0x00000),\n\tA6XX_PROTECT_NORDWR(0x0ae50, 0x0012f),\n\tA6XX_PROTECT_NORDWR(0x0b604, 0x00000),\n\tA6XX_PROTECT_NORDWR(0x0b608, 0x00006),\n\tA6XX_PROTECT_NORDWR(0x0be02, 0x00001),\n\tA6XX_PROTECT_NORDWR(0x0be20, 0x0015f),\n\tA6XX_PROTECT_NORDWR(0x0d000, 0x005ff),\n\tA6XX_PROTECT_NORDWR(0x0f000, 0x00bff),\n\tA6XX_PROTECT_RDONLY(0x0fc00, 0x01fff),\n\tA6XX_PROTECT_NORDWR(0x11c00, 0x00000),  \n};\n\nstatic void a6xx_set_cp_protect(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tconst u32 *regs = a6xx_protect;\n\tunsigned i, count, count_max;\n\n\tif (adreno_is_a650(adreno_gpu)) {\n\t\tregs = a650_protect;\n\t\tcount = ARRAY_SIZE(a650_protect);\n\t\tcount_max = 48;\n\t\tBUILD_BUG_ON(ARRAY_SIZE(a650_protect) > 48);\n\t} else if (adreno_is_a690(adreno_gpu)) {\n\t\tregs = a690_protect;\n\t\tcount = ARRAY_SIZE(a690_protect);\n\t\tcount_max = 48;\n\t\tBUILD_BUG_ON(ARRAY_SIZE(a690_protect) > 48);\n\t} else if (adreno_is_a660_family(adreno_gpu)) {\n\t\tregs = a660_protect;\n\t\tcount = ARRAY_SIZE(a660_protect);\n\t\tcount_max = 48;\n\t\tBUILD_BUG_ON(ARRAY_SIZE(a660_protect) > 48);\n\t} else {\n\t\tregs = a6xx_protect;\n\t\tcount = ARRAY_SIZE(a6xx_protect);\n\t\tcount_max = 32;\n\t\tBUILD_BUG_ON(ARRAY_SIZE(a6xx_protect) > 32);\n\t}\n\n\t \n\tgpu_write(gpu, REG_A6XX_CP_PROTECT_CNTL,\n\t\t  A6XX_CP_PROTECT_CNTL_ACCESS_PROT_EN |\n\t\t  A6XX_CP_PROTECT_CNTL_ACCESS_FAULT_ON_VIOL_EN |\n\t\t  A6XX_CP_PROTECT_CNTL_LAST_SPAN_INF_RANGE);\n\n\tfor (i = 0; i < count - 1; i++) {\n\t\t \n\t\tif (regs[i])\n\t\t\tgpu_write(gpu, REG_A6XX_CP_PROTECT(i), regs[i]);\n\t}\n\t \n\tgpu_write(gpu, REG_A6XX_CP_PROTECT(count_max - 1), regs[i]);\n}\n\nstatic void a6xx_set_ubwc_config(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\t \n\tu32 rgb565_predicator = 0;\n\t \n\tu32 uavflagprd_inv = 0;\n\t \n\tu32 min_acc_len = 0;\n\t \n\tu32 ubwc_mode = 0;\n\t \n\tu32 hbb_hi = 0;\n\tu32 hbb_lo = 2;\n\t \n\tu32 amsbc = 0;\n\n\tif (adreno_is_a610(adreno_gpu)) {\n\t\t \n\t\thbb_lo = 1;\n\t\tmin_acc_len = 1;\n\t\tubwc_mode = 1;\n\t}\n\n\t \n\tif (adreno_is_a618(adreno_gpu))\n\t\treturn;\n\n\tif (adreno_is_a619_holi(adreno_gpu))\n\t\thbb_lo = 0;\n\n\tif (adreno_is_a640_family(adreno_gpu))\n\t\tamsbc = 1;\n\n\tif (adreno_is_a650(adreno_gpu) || adreno_is_a660(adreno_gpu)) {\n\t\t \n\t\thbb_lo = 3;\n\t\tamsbc = 1;\n\t\trgb565_predicator = 1;\n\t\tuavflagprd_inv = 2;\n\t}\n\n\tif (adreno_is_a690(adreno_gpu)) {\n\t\thbb_lo = 2;\n\t\tamsbc = 1;\n\t\trgb565_predicator = 1;\n\t\tuavflagprd_inv = 2;\n\t}\n\n\tif (adreno_is_7c3(adreno_gpu)) {\n\t\thbb_lo = 1;\n\t\tamsbc = 1;\n\t\trgb565_predicator = 1;\n\t\tuavflagprd_inv = 2;\n\t}\n\n\tgpu_write(gpu, REG_A6XX_RB_NC_MODE_CNTL,\n\t\t  rgb565_predicator << 11 | hbb_hi << 10 | amsbc << 4 |\n\t\t  min_acc_len << 3 | hbb_lo << 1 | ubwc_mode);\n\n\tgpu_write(gpu, REG_A6XX_TPL1_NC_MODE_CNTL, hbb_hi << 4 |\n\t\t  min_acc_len << 3 | hbb_lo << 1 | ubwc_mode);\n\n\tgpu_write(gpu, REG_A6XX_SP_NC_MODE_CNTL, hbb_hi << 10 |\n\t\t  uavflagprd_inv << 4 | min_acc_len << 3 |\n\t\t  hbb_lo << 1 | ubwc_mode);\n\n\tgpu_write(gpu, REG_A6XX_UCHE_MODE_CNTL, min_acc_len << 23 | hbb_lo << 21);\n}\n\nstatic int a6xx_cp_init(struct msm_gpu *gpu)\n{\n\tstruct msm_ringbuffer *ring = gpu->rb[0];\n\n\tOUT_PKT7(ring, CP_ME_INIT, 8);\n\n\tOUT_RING(ring, 0x0000002f);\n\n\t \n\tOUT_RING(ring, 0x00000003);\n\n\t \n\tOUT_RING(ring, 0x20000000);\n\n\t \n\tOUT_RING(ring, 0x00000000);\n\tOUT_RING(ring, 0x00000000);\n\n\t \n\tOUT_RING(ring, 0x00000000);\n\n\t \n\tOUT_RING(ring, 0x00000000);\n\tOUT_RING(ring, 0x00000000);\n\n\ta6xx_flush(gpu, ring);\n\treturn a6xx_idle(gpu, ring) ? 0 : -EINVAL;\n}\n\n \nstatic bool a6xx_ucode_check_version(struct a6xx_gpu *a6xx_gpu,\n\t\tstruct drm_gem_object *obj)\n{\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tstruct msm_gpu *gpu = &adreno_gpu->base;\n\tconst char *sqe_name = adreno_gpu->info->fw[ADRENO_FW_SQE];\n\tu32 *buf = msm_gem_get_vaddr(obj);\n\tbool ret = false;\n\n\tif (IS_ERR(buf))\n\t\treturn false;\n\n\t \n\tif (!strcmp(sqe_name, \"a630_sqe.fw\")) {\n\t\t \n\t\tif ((((buf[0] & 0xf) == 0xa) && (buf[2] & 0xf) >= 1) ||\n\t\t\t(buf[0] & 0xfff) >= 0x190) {\n\t\t\ta6xx_gpu->has_whereami = true;\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDRM_DEV_ERROR(&gpu->pdev->dev,\n\t\t\t\"a630 SQE ucode is too old. Have version %x need at least %x\\n\",\n\t\t\tbuf[0] & 0xfff, 0x190);\n\t} else if (!strcmp(sqe_name, \"a650_sqe.fw\")) {\n\t\tif ((buf[0] & 0xfff) >= 0x095) {\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDRM_DEV_ERROR(&gpu->pdev->dev,\n\t\t\t\"a650 SQE ucode is too old. Have version %x need at least %x\\n\",\n\t\t\tbuf[0] & 0xfff, 0x095);\n\t} else if (!strcmp(sqe_name, \"a660_sqe.fw\")) {\n\t\tret = true;\n\t} else {\n\t\tDRM_DEV_ERROR(&gpu->pdev->dev,\n\t\t\t\"unknown GPU, add it to a6xx_ucode_check_version()!!\\n\");\n\t}\nout:\n\tmsm_gem_put_vaddr(obj);\n\treturn ret;\n}\n\nstatic int a6xx_ucode_load(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\n\tif (!a6xx_gpu->sqe_bo) {\n\t\ta6xx_gpu->sqe_bo = adreno_fw_create_bo(gpu,\n\t\t\tadreno_gpu->fw[ADRENO_FW_SQE], &a6xx_gpu->sqe_iova);\n\n\t\tif (IS_ERR(a6xx_gpu->sqe_bo)) {\n\t\t\tint ret = PTR_ERR(a6xx_gpu->sqe_bo);\n\n\t\t\ta6xx_gpu->sqe_bo = NULL;\n\t\t\tDRM_DEV_ERROR(&gpu->pdev->dev,\n\t\t\t\t\"Could not allocate SQE ucode: %d\\n\", ret);\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tmsm_gem_object_set_name(a6xx_gpu->sqe_bo, \"sqefw\");\n\t\tif (!a6xx_ucode_check_version(a6xx_gpu, a6xx_gpu->sqe_bo)) {\n\t\t\tmsm_gem_unpin_iova(a6xx_gpu->sqe_bo, gpu->aspace);\n\t\t\tdrm_gem_object_put(a6xx_gpu->sqe_bo);\n\n\t\t\ta6xx_gpu->sqe_bo = NULL;\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\t \n\tif ((adreno_gpu->base.hw_apriv || a6xx_gpu->has_whereami) &&\n\t    !a6xx_gpu->shadow_bo) {\n\t\ta6xx_gpu->shadow = msm_gem_kernel_new(gpu->dev,\n\t\t\t\t\t\t      sizeof(u32) * gpu->nr_rings,\n\t\t\t\t\t\t      MSM_BO_WC | MSM_BO_MAP_PRIV,\n\t\t\t\t\t\t      gpu->aspace, &a6xx_gpu->shadow_bo,\n\t\t\t\t\t\t      &a6xx_gpu->shadow_iova);\n\n\t\tif (IS_ERR(a6xx_gpu->shadow))\n\t\t\treturn PTR_ERR(a6xx_gpu->shadow);\n\n\t\tmsm_gem_object_set_name(a6xx_gpu->shadow_bo, \"shadow\");\n\t}\n\n\treturn 0;\n}\n\nstatic int a6xx_zap_shader_init(struct msm_gpu *gpu)\n{\n\tstatic bool loaded;\n\tint ret;\n\n\tif (loaded)\n\t\treturn 0;\n\n\tret = adreno_zap_shader_load(gpu, GPU_PAS_ID);\n\n\tloaded = !ret;\n\treturn ret;\n}\n\n#define A6XX_INT_MASK (A6XX_RBBM_INT_0_MASK_CP_AHB_ERROR | \\\n\t  A6XX_RBBM_INT_0_MASK_RBBM_ATB_ASYNCFIFO_OVERFLOW | \\\n\t  A6XX_RBBM_INT_0_MASK_CP_HW_ERROR | \\\n\t  A6XX_RBBM_INT_0_MASK_CP_IB2 | \\\n\t  A6XX_RBBM_INT_0_MASK_CP_IB1 | \\\n\t  A6XX_RBBM_INT_0_MASK_CP_RB | \\\n\t  A6XX_RBBM_INT_0_MASK_CP_CACHE_FLUSH_TS | \\\n\t  A6XX_RBBM_INT_0_MASK_RBBM_ATB_BUS_OVERFLOW | \\\n\t  A6XX_RBBM_INT_0_MASK_RBBM_HANG_DETECT | \\\n\t  A6XX_RBBM_INT_0_MASK_UCHE_OOB_ACCESS | \\\n\t  A6XX_RBBM_INT_0_MASK_UCHE_TRAP_INTR)\n\nstatic int hw_init(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\tint ret;\n\n\tif (!adreno_has_gmu_wrapper(adreno_gpu)) {\n\t\t \n\t\tret = a6xx_gmu_set_oob(&a6xx_gpu->gmu, GMU_OOB_GPU_SET);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (adreno_is_a619_holi(adreno_gpu)) {\n\t\tgpu_write(gpu, REG_A6XX_GBIF_HALT, 0);\n\t\tgpu_write(gpu, REG_A6XX_RBBM_GPR0_CNTL, 0);\n\t\t \n\t\tmb();\n\t} else if (a6xx_has_gbif(adreno_gpu)) {\n\t\tgpu_write(gpu, REG_A6XX_GBIF_HALT, 0);\n\t\tgpu_write(gpu, REG_A6XX_RBBM_GBIF_HALT, 0);\n\t\t \n\t\tmb();\n\t}\n\n\tgpu_write(gpu, REG_A6XX_RBBM_SECVID_TSB_CNTL, 0);\n\n\tif (adreno_is_a619_holi(adreno_gpu))\n\t\ta6xx_sptprac_enable(gmu);\n\n\t \n\tgpu_write64(gpu, REG_A6XX_RBBM_SECVID_TSB_TRUSTED_BASE, 0x00000000);\n\tgpu_write(gpu, REG_A6XX_RBBM_SECVID_TSB_TRUSTED_SIZE, 0x00000000);\n\n\t \n\tgpu_write(gpu, REG_A6XX_CP_ADDR_MODE_CNTL, 0x1);\n\tgpu_write(gpu, REG_A6XX_VSC_ADDR_MODE_CNTL, 0x1);\n\tgpu_write(gpu, REG_A6XX_GRAS_ADDR_MODE_CNTL, 0x1);\n\tgpu_write(gpu, REG_A6XX_RB_ADDR_MODE_CNTL, 0x1);\n\tgpu_write(gpu, REG_A6XX_PC_ADDR_MODE_CNTL, 0x1);\n\tgpu_write(gpu, REG_A6XX_HLSQ_ADDR_MODE_CNTL, 0x1);\n\tgpu_write(gpu, REG_A6XX_VFD_ADDR_MODE_CNTL, 0x1);\n\tgpu_write(gpu, REG_A6XX_VPC_ADDR_MODE_CNTL, 0x1);\n\tgpu_write(gpu, REG_A6XX_UCHE_ADDR_MODE_CNTL, 0x1);\n\tgpu_write(gpu, REG_A6XX_SP_ADDR_MODE_CNTL, 0x1);\n\tgpu_write(gpu, REG_A6XX_TPL1_ADDR_MODE_CNTL, 0x1);\n\tgpu_write(gpu, REG_A6XX_RBBM_SECVID_TSB_ADDR_MODE_CNTL, 0x1);\n\n\t \n\ta6xx_set_hwcg(gpu, true);\n\n\t \n\tif (adreno_is_a610(adreno_gpu) ||\n\t    adreno_is_a640_family(adreno_gpu) ||\n\t    adreno_is_a650_family(adreno_gpu)) {\n\t\tgpu_write(gpu, REG_A6XX_GBIF_QSB_SIDE0, 0x00071620);\n\t\tgpu_write(gpu, REG_A6XX_GBIF_QSB_SIDE1, 0x00071620);\n\t\tgpu_write(gpu, REG_A6XX_GBIF_QSB_SIDE2, 0x00071620);\n\t\tgpu_write(gpu, REG_A6XX_GBIF_QSB_SIDE3, 0x00071620);\n\t\tgpu_write(gpu, REG_A6XX_RBBM_GBIF_CLIENT_QOS_CNTL, 0x3);\n\t} else {\n\t\tgpu_write(gpu, REG_A6XX_RBBM_VBIF_CLIENT_QOS_CNTL, 0x3);\n\t}\n\n\tif (adreno_is_a630(adreno_gpu))\n\t\tgpu_write(gpu, REG_A6XX_VBIF_GATE_OFF_WRREQ_EN, 0x00000009);\n\n\t \n\tgpu_write(gpu, REG_A6XX_RBBM_PERFCTR_GPU_BUSY_MASKED, 0xffffffff);\n\n\t \n\tgpu_write64(gpu, REG_A6XX_UCHE_WRITE_RANGE_MAX, 0x0001ffffffffffc0llu);\n\tgpu_write64(gpu, REG_A6XX_UCHE_TRAP_BASE, 0x0001fffffffff000llu);\n\tgpu_write64(gpu, REG_A6XX_UCHE_WRITE_THRU_BASE, 0x0001fffffffff000llu);\n\n\tif (!adreno_is_a650_family(adreno_gpu)) {\n\t\t \n\t\tgpu_write64(gpu, REG_A6XX_UCHE_GMEM_RANGE_MIN, 0x00100000);\n\n\t\tgpu_write64(gpu, REG_A6XX_UCHE_GMEM_RANGE_MAX,\n\t\t\t0x00100000 + adreno_gpu->info->gmem - 1);\n\t}\n\n\tgpu_write(gpu, REG_A6XX_UCHE_FILTER_CNTL, 0x804);\n\tgpu_write(gpu, REG_A6XX_UCHE_CACHE_WAYS, 0x4);\n\n\tif (adreno_is_a640_family(adreno_gpu) || adreno_is_a650_family(adreno_gpu)) {\n\t\tgpu_write(gpu, REG_A6XX_CP_ROQ_THRESHOLDS_2, 0x02000140);\n\t\tgpu_write(gpu, REG_A6XX_CP_ROQ_THRESHOLDS_1, 0x8040362c);\n\t} else if (adreno_is_a610(adreno_gpu)) {\n\t\tgpu_write(gpu, REG_A6XX_CP_ROQ_THRESHOLDS_2, 0x00800060);\n\t\tgpu_write(gpu, REG_A6XX_CP_ROQ_THRESHOLDS_1, 0x40201b16);\n\t} else {\n\t\tgpu_write(gpu, REG_A6XX_CP_ROQ_THRESHOLDS_2, 0x010000c0);\n\t\tgpu_write(gpu, REG_A6XX_CP_ROQ_THRESHOLDS_1, 0x8040362c);\n\t}\n\n\tif (adreno_is_a660_family(adreno_gpu))\n\t\tgpu_write(gpu, REG_A6XX_CP_LPAC_PROG_FIFO_SIZE, 0x00000020);\n\n\t \n\tif (adreno_is_a610(adreno_gpu)) {\n\t\tgpu_write(gpu, REG_A6XX_CP_MEM_POOL_SIZE, 48);\n\t\tgpu_write(gpu, REG_A6XX_CP_MEM_POOL_DBG_ADDR, 47);\n\t} else\n\t\tgpu_write(gpu, REG_A6XX_CP_MEM_POOL_SIZE, 128);\n\n\t \n\tif (adreno_is_a650(adreno_gpu) || adreno_is_a660(adreno_gpu) || adreno_is_a690(adreno_gpu))\n\t\tgpu_write(gpu, REG_A6XX_PC_DBG_ECO_CNTL, 0x00300200);\n\telse if (adreno_is_a640_family(adreno_gpu) || adreno_is_7c3(adreno_gpu))\n\t\tgpu_write(gpu, REG_A6XX_PC_DBG_ECO_CNTL, 0x00200200);\n\telse if (adreno_is_a650(adreno_gpu) || adreno_is_a660(adreno_gpu))\n\t\tgpu_write(gpu, REG_A6XX_PC_DBG_ECO_CNTL, 0x00300200);\n\telse if (adreno_is_a619(adreno_gpu))\n\t\tgpu_write(gpu, REG_A6XX_PC_DBG_ECO_CNTL, 0x00018000);\n\telse if (adreno_is_a610(adreno_gpu))\n\t\tgpu_write(gpu, REG_A6XX_PC_DBG_ECO_CNTL, 0x00080000);\n\telse\n\t\tgpu_write(gpu, REG_A6XX_PC_DBG_ECO_CNTL, 0x00180000);\n\n\t \n\tgpu_write(gpu, REG_A6XX_CP_AHB_CNTL, 0x1);\n\n\t \n\tgpu_write(gpu, REG_A6XX_RBBM_PERFCTR_CNTL, 0x1);\n\n\t \n\tgpu_write(gpu, REG_A6XX_CP_PERFCTR_CP_SEL(0), PERF_CP_ALWAYS_COUNT);\n\n\ta6xx_set_ubwc_config(gpu);\n\n\t \n\tif (adreno_is_a619(adreno_gpu))\n\t\tgpu_write(gpu, REG_A6XX_RBBM_INTERFACE_HANG_INT_CNTL, (1 << 30) | 0x3fffff);\n\telse if (adreno_is_a610(adreno_gpu))\n\t\tgpu_write(gpu, REG_A6XX_RBBM_INTERFACE_HANG_INT_CNTL, (1 << 30) | 0x3ffff);\n\telse\n\t\tgpu_write(gpu, REG_A6XX_RBBM_INTERFACE_HANG_INT_CNTL, (1 << 30) | 0x1fffff);\n\n\tgpu_write(gpu, REG_A6XX_UCHE_CLIENT_PF, 1);\n\n\t \n\tif (adreno_is_a650_family(adreno_gpu)) {\n\t\tgpu_write(gpu, REG_A6XX_TPL1_BICUBIC_WEIGHTS_TABLE_0, 0);\n\t\tgpu_write(gpu, REG_A6XX_TPL1_BICUBIC_WEIGHTS_TABLE_1,\n\t\t\t0x3fe05ff4);\n\t\tgpu_write(gpu, REG_A6XX_TPL1_BICUBIC_WEIGHTS_TABLE_2,\n\t\t\t0x3fa0ebee);\n\t\tgpu_write(gpu, REG_A6XX_TPL1_BICUBIC_WEIGHTS_TABLE_3,\n\t\t\t0x3f5193ed);\n\t\tgpu_write(gpu, REG_A6XX_TPL1_BICUBIC_WEIGHTS_TABLE_4,\n\t\t\t0x3f0243f0);\n\t}\n\n\t \n\tgmu_write(gmu, REG_A6XX_GPU_GMU_AO_GPU_CX_BUSY_MASK, 0xff000000);\n\n\t \n\tgmu_rmw(gmu, REG_A6XX_GMU_CX_GMU_POWER_COUNTER_SELECT_0, 0xff, BIT(5));\n\tgmu_write(gmu, REG_A6XX_GMU_CX_GMU_POWER_COUNTER_ENABLE, 1);\n\n\t \n\ta6xx_set_cp_protect(gpu);\n\n\tif (adreno_is_a660_family(adreno_gpu)) {\n\t\tgpu_write(gpu, REG_A6XX_CP_CHICKEN_DBG, 0x1);\n\t\tgpu_write(gpu, REG_A6XX_RBBM_GBIF_CLIENT_QOS_CNTL, 0x0);\n\t}\n\n\t \n\tif (adreno_is_a660(adreno_gpu))\n\t\tgpu_write(gpu, REG_A6XX_UCHE_CMDQ_CONFIG, 0x66906);\n\n\t \n\tif (gpu->hw_apriv) {\n\t\tgpu_write(gpu, REG_A6XX_CP_APRIV_CNTL,\n\t\t\t(1 << 6) | (1 << 5) | (1 << 3) | (1 << 2) | (1 << 1));\n\t}\n\n\t \n\tgpu_write(gpu, REG_A6XX_RBBM_INT_0_MASK, A6XX_INT_MASK);\n\n\tret = adreno_hw_init(gpu);\n\tif (ret)\n\t\tgoto out;\n\n\tgpu_write64(gpu, REG_A6XX_CP_SQE_INSTR_BASE, a6xx_gpu->sqe_iova);\n\n\t \n\tgpu_write64(gpu, REG_A6XX_CP_RB_BASE, gpu->rb[0]->iova);\n\n\t \n\tif (adreno_gpu->base.hw_apriv)\n\t\tgpu_write(gpu, REG_A6XX_CP_RB_CNTL, MSM_GPU_RB_CNTL_DEFAULT);\n\telse\n\t\tgpu_write(gpu, REG_A6XX_CP_RB_CNTL,\n\t\t\tMSM_GPU_RB_CNTL_DEFAULT | AXXX_CP_RB_CNTL_NO_UPDATE);\n\n\t \n\tif (a6xx_gpu->shadow_bo) {\n\t\tgpu_write64(gpu, REG_A6XX_CP_RB_RPTR_ADDR,\n\t\t\tshadowptr(a6xx_gpu, gpu->rb[0]));\n\t}\n\n\t \n\ta6xx_gpu->cur_ring = gpu->rb[0];\n\n\tgpu->cur_ctx_seqno = 0;\n\n\t \n\tgpu_write(gpu, REG_A6XX_CP_SQE_CNTL, 1);\n\n\tret = a6xx_cp_init(gpu);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = a6xx_zap_shader_init(gpu);\n\tif (!ret) {\n\t\tOUT_PKT7(gpu->rb[0], CP_SET_SECURE_MODE, 1);\n\t\tOUT_RING(gpu->rb[0], 0x00000000);\n\n\t\ta6xx_flush(gpu, gpu->rb[0]);\n\t\tif (!a6xx_idle(gpu, gpu->rb[0]))\n\t\t\treturn -EINVAL;\n\t} else if (ret == -ENODEV) {\n\t\t \n\t\tdev_warn_once(gpu->dev->dev,\n\t\t\t\"Zap shader not enabled - using SECVID_TRUST_CNTL instead\\n\");\n\t\tgpu_write(gpu, REG_A6XX_RBBM_SECVID_TRUST_CNTL, 0x0);\n\t\tret = 0;\n\t} else {\n\t\treturn ret;\n\t}\n\nout:\n\tif (adreno_has_gmu_wrapper(adreno_gpu))\n\t\treturn ret;\n\t \n\ta6xx_gmu_clear_oob(&a6xx_gpu->gmu, GMU_OOB_GPU_SET);\n\n\tif (a6xx_gpu->gmu.legacy) {\n\t\t \n\t\ta6xx_gmu_clear_oob(&a6xx_gpu->gmu, GMU_OOB_BOOT_SLUMBER);\n\t}\n\n\treturn ret;\n}\n\nstatic int a6xx_hw_init(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tint ret;\n\n\tmutex_lock(&a6xx_gpu->gmu.lock);\n\tret = hw_init(gpu);\n\tmutex_unlock(&a6xx_gpu->gmu.lock);\n\n\treturn ret;\n}\n\nstatic void a6xx_dump(struct msm_gpu *gpu)\n{\n\tDRM_DEV_INFO(&gpu->pdev->dev, \"status:   %08x\\n\",\n\t\t\tgpu_read(gpu, REG_A6XX_RBBM_STATUS));\n\tadreno_dump(gpu);\n}\n\nstatic void a6xx_recover(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\tint i, active_submits;\n\n\tadreno_dump_info(gpu);\n\n\tfor (i = 0; i < 8; i++)\n\t\tDRM_DEV_INFO(&gpu->pdev->dev, \"CP_SCRATCH_REG%d: %u\\n\", i,\n\t\t\tgpu_read(gpu, REG_A6XX_CP_SCRATCH_REG(i)));\n\n\tif (hang_debug)\n\t\ta6xx_dump(gpu);\n\n\t \n\ta6xx_gpu->hung = true;\n\n\t \n\tgpu_write(gpu, REG_A6XX_CP_SQE_CNTL, 3);\n\n\tpm_runtime_dont_use_autosuspend(&gpu->pdev->dev);\n\n\t \n\tmutex_lock(&gpu->active_lock);\n\tactive_submits = gpu->active_submits;\n\n\t \n\tgpu->active_submits = 0;\n\n\tif (adreno_has_gmu_wrapper(adreno_gpu)) {\n\t\t \n\t\ta6xx_bus_clear_pending_transactions(adreno_gpu, true);\n\n\t\t \n\t\ta6xx_gpu_sw_reset(gpu, true);\n\t\ta6xx_gpu_sw_reset(gpu, false);\n\t}\n\n\treinit_completion(&gmu->pd_gate);\n\tdev_pm_genpd_add_notifier(gmu->cxpd, &gmu->pd_nb);\n\tdev_pm_genpd_synced_poweroff(gmu->cxpd);\n\n\t \n\tif (active_submits)\n\t\tpm_runtime_put(&gpu->pdev->dev);\n\n\t \n\tpm_runtime_put_sync(&gpu->pdev->dev);\n\n\tif (!wait_for_completion_timeout(&gmu->pd_gate, msecs_to_jiffies(1000)))\n\t\tDRM_DEV_ERROR(&gpu->pdev->dev, \"cx gdsc didn't collapse\\n\");\n\n\tdev_pm_genpd_remove_notifier(gmu->cxpd);\n\n\tpm_runtime_use_autosuspend(&gpu->pdev->dev);\n\n\tif (active_submits)\n\t\tpm_runtime_get(&gpu->pdev->dev);\n\n\tpm_runtime_get_sync(&gpu->pdev->dev);\n\n\tgpu->active_submits = active_submits;\n\tmutex_unlock(&gpu->active_lock);\n\n\tmsm_gpu_hw_init(gpu);\n\ta6xx_gpu->hung = false;\n}\n\nstatic const char *a6xx_uche_fault_block(struct msm_gpu *gpu, u32 mid)\n{\n\tstatic const char *uche_clients[7] = {\n\t\t\"VFD\", \"SP\", \"VSC\", \"VPC\", \"HLSQ\", \"PC\", \"LRZ\",\n\t};\n\tu32 val;\n\n\tif (mid < 1 || mid > 3)\n\t\treturn \"UNKNOWN\";\n\n\t \n\tval = gpu_read(gpu, REG_A6XX_UCHE_CLIENT_PF);\n\n\t \n\tif (mid == 3)\n\t\treturn uche_clients[val & 7];\n\n\t \n\tif (mid == 2)\n\t\treturn ((val & 7) == 0) ? \"TP\" : \"TP|VFD\";\n\n\t \n\treturn \"UCHE\";\n}\n\nstatic const char *a6xx_fault_block(struct msm_gpu *gpu, u32 id)\n{\n\tif (id == 0)\n\t\treturn \"CP\";\n\telse if (id == 4)\n\t\treturn \"CCU\";\n\telse if (id == 6)\n\t\treturn \"CDP Prefetch\";\n\n\treturn a6xx_uche_fault_block(gpu, id);\n}\n\nstatic int a6xx_fault_handler(void *arg, unsigned long iova, int flags, void *data)\n{\n\tstruct msm_gpu *gpu = arg;\n\tstruct adreno_smmu_fault_info *info = data;\n\tconst char *block = \"unknown\";\n\n\tu32 scratch[] = {\n\t\t\tgpu_read(gpu, REG_A6XX_CP_SCRATCH_REG(4)),\n\t\t\tgpu_read(gpu, REG_A6XX_CP_SCRATCH_REG(5)),\n\t\t\tgpu_read(gpu, REG_A6XX_CP_SCRATCH_REG(6)),\n\t\t\tgpu_read(gpu, REG_A6XX_CP_SCRATCH_REG(7)),\n\t};\n\n\tif (info)\n\t\tblock = a6xx_fault_block(gpu, info->fsynr1 & 0xff);\n\n\treturn adreno_fault_handler(gpu, iova, flags, info, block, scratch);\n}\n\nstatic void a6xx_cp_hw_err_irq(struct msm_gpu *gpu)\n{\n\tu32 status = gpu_read(gpu, REG_A6XX_CP_INTERRUPT_STATUS);\n\n\tif (status & A6XX_CP_INT_CP_OPCODE_ERROR) {\n\t\tu32 val;\n\n\t\tgpu_write(gpu, REG_A6XX_CP_SQE_STAT_ADDR, 1);\n\t\tval = gpu_read(gpu, REG_A6XX_CP_SQE_STAT_DATA);\n\t\tdev_err_ratelimited(&gpu->pdev->dev,\n\t\t\t\"CP | opcode error | possible opcode=0x%8.8X\\n\",\n\t\t\tval);\n\t}\n\n\tif (status & A6XX_CP_INT_CP_UCODE_ERROR)\n\t\tdev_err_ratelimited(&gpu->pdev->dev,\n\t\t\t\"CP ucode error interrupt\\n\");\n\n\tif (status & A6XX_CP_INT_CP_HW_FAULT_ERROR)\n\t\tdev_err_ratelimited(&gpu->pdev->dev, \"CP | HW fault | status=0x%8.8X\\n\",\n\t\t\tgpu_read(gpu, REG_A6XX_CP_HW_FAULT));\n\n\tif (status & A6XX_CP_INT_CP_REGISTER_PROTECTION_ERROR) {\n\t\tu32 val = gpu_read(gpu, REG_A6XX_CP_PROTECT_STATUS);\n\n\t\tdev_err_ratelimited(&gpu->pdev->dev,\n\t\t\t\"CP | protected mode error | %s | addr=0x%8.8X | status=0x%8.8X\\n\",\n\t\t\tval & (1 << 20) ? \"READ\" : \"WRITE\",\n\t\t\t(val & 0x3ffff), val);\n\t}\n\n\tif (status & A6XX_CP_INT_CP_AHB_ERROR)\n\t\tdev_err_ratelimited(&gpu->pdev->dev, \"CP AHB error interrupt\\n\");\n\n\tif (status & A6XX_CP_INT_CP_VSD_PARITY_ERROR)\n\t\tdev_err_ratelimited(&gpu->pdev->dev, \"CP VSD decoder parity error\\n\");\n\n\tif (status & A6XX_CP_INT_CP_ILLEGAL_INSTR_ERROR)\n\t\tdev_err_ratelimited(&gpu->pdev->dev, \"CP illegal instruction error\\n\");\n\n}\n\nstatic void a6xx_fault_detect_irq(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tstruct msm_ringbuffer *ring = gpu->funcs->active_ring(gpu);\n\n\t \n\tif (gpu_read(gpu, REG_A6XX_RBBM_STATUS3) & A6XX_RBBM_STATUS3_SMMU_STALLED_ON_FAULT)\n\t\treturn;\n\n\t \n\tif (!adreno_has_gmu_wrapper(adreno_gpu))\n\t\tgmu_write(&a6xx_gpu->gmu, REG_A6XX_GMU_GMU_PWR_COL_KEEPALIVE, 1);\n\n\tDRM_DEV_ERROR(&gpu->pdev->dev,\n\t\t\"gpu fault ring %d fence %x status %8.8X rb %4.4x/%4.4x ib1 %16.16llX/%4.4x ib2 %16.16llX/%4.4x\\n\",\n\t\tring ? ring->id : -1, ring ? ring->fctx->last_fence : 0,\n\t\tgpu_read(gpu, REG_A6XX_RBBM_STATUS),\n\t\tgpu_read(gpu, REG_A6XX_CP_RB_RPTR),\n\t\tgpu_read(gpu, REG_A6XX_CP_RB_WPTR),\n\t\tgpu_read64(gpu, REG_A6XX_CP_IB1_BASE),\n\t\tgpu_read(gpu, REG_A6XX_CP_IB1_REM_SIZE),\n\t\tgpu_read64(gpu, REG_A6XX_CP_IB2_BASE),\n\t\tgpu_read(gpu, REG_A6XX_CP_IB2_REM_SIZE));\n\n\t \n\tdel_timer(&gpu->hangcheck_timer);\n\n\tkthread_queue_work(gpu->worker, &gpu->recover_work);\n}\n\nstatic irqreturn_t a6xx_irq(struct msm_gpu *gpu)\n{\n\tstruct msm_drm_private *priv = gpu->dev->dev_private;\n\tu32 status = gpu_read(gpu, REG_A6XX_RBBM_INT_0_STATUS);\n\n\tgpu_write(gpu, REG_A6XX_RBBM_INT_CLEAR_CMD, status);\n\n\tif (priv->disable_err_irq)\n\t\tstatus &= A6XX_RBBM_INT_0_MASK_CP_CACHE_FLUSH_TS;\n\n\tif (status & A6XX_RBBM_INT_0_MASK_RBBM_HANG_DETECT)\n\t\ta6xx_fault_detect_irq(gpu);\n\n\tif (status & A6XX_RBBM_INT_0_MASK_CP_AHB_ERROR)\n\t\tdev_err_ratelimited(&gpu->pdev->dev, \"CP | AHB bus error\\n\");\n\n\tif (status & A6XX_RBBM_INT_0_MASK_CP_HW_ERROR)\n\t\ta6xx_cp_hw_err_irq(gpu);\n\n\tif (status & A6XX_RBBM_INT_0_MASK_RBBM_ATB_ASYNCFIFO_OVERFLOW)\n\t\tdev_err_ratelimited(&gpu->pdev->dev, \"RBBM | ATB ASYNC overflow\\n\");\n\n\tif (status & A6XX_RBBM_INT_0_MASK_RBBM_ATB_BUS_OVERFLOW)\n\t\tdev_err_ratelimited(&gpu->pdev->dev, \"RBBM | ATB bus overflow\\n\");\n\n\tif (status & A6XX_RBBM_INT_0_MASK_UCHE_OOB_ACCESS)\n\t\tdev_err_ratelimited(&gpu->pdev->dev, \"UCHE | Out of bounds access\\n\");\n\n\tif (status & A6XX_RBBM_INT_0_MASK_CP_CACHE_FLUSH_TS)\n\t\tmsm_gpu_retire(gpu);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void a6xx_llc_deactivate(struct a6xx_gpu *a6xx_gpu)\n{\n\tllcc_slice_deactivate(a6xx_gpu->llc_slice);\n\tllcc_slice_deactivate(a6xx_gpu->htw_llc_slice);\n}\n\nstatic void a6xx_llc_activate(struct a6xx_gpu *a6xx_gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\tstruct msm_gpu *gpu = &adreno_gpu->base;\n\tu32 cntl1_regval = 0;\n\n\tif (IS_ERR(a6xx_gpu->llc_mmio))\n\t\treturn;\n\n\tif (!llcc_slice_activate(a6xx_gpu->llc_slice)) {\n\t\tu32 gpu_scid = llcc_get_slice_id(a6xx_gpu->llc_slice);\n\n\t\tgpu_scid &= 0x1f;\n\t\tcntl1_regval = (gpu_scid << 0) | (gpu_scid << 5) | (gpu_scid << 10) |\n\t\t\t       (gpu_scid << 15) | (gpu_scid << 20);\n\n\t\t \n\t\tif (adreno_is_a660_family(adreno_gpu))\n\t\t\tgpu_rmw(gpu, REG_A6XX_GBIF_SCACHE_CNTL0, (0x1f << 10) |\n\t\t\t\t(1 << 8), (gpu_scid << 10) | (1 << 8));\n\t}\n\n\t \n\tif (!llcc_slice_activate(a6xx_gpu->htw_llc_slice)) {\n\t\tif (!a6xx_gpu->have_mmu500) {\n\t\t\tu32 gpuhtw_scid = llcc_get_slice_id(a6xx_gpu->htw_llc_slice);\n\n\t\t\tgpuhtw_scid &= 0x1f;\n\t\t\tcntl1_regval |= FIELD_PREP(GENMASK(29, 25), gpuhtw_scid);\n\t\t}\n\t}\n\n\tif (!cntl1_regval)\n\t\treturn;\n\n\t \n\tif (!a6xx_gpu->have_mmu500) {\n\t\ta6xx_llc_write(a6xx_gpu,\n\t\t\tREG_A6XX_CX_MISC_SYSTEM_CACHE_CNTL_1, cntl1_regval);\n\n\t\t \n\t\ta6xx_llc_rmw(a6xx_gpu,\n\t\t\tREG_A6XX_CX_MISC_SYSTEM_CACHE_CNTL_0, 0xF, 0x03);\n\t\treturn;\n\t}\n\n\tgpu_rmw(gpu, REG_A6XX_GBIF_SCACHE_CNTL1, GENMASK(24, 0), cntl1_regval);\n}\n\nstatic void a6xx_llc_slices_destroy(struct a6xx_gpu *a6xx_gpu)\n{\n\t \n\tif (adreno_has_gmu_wrapper(&a6xx_gpu->base))\n\t\treturn;\n\n\tllcc_slice_putd(a6xx_gpu->llc_slice);\n\tllcc_slice_putd(a6xx_gpu->htw_llc_slice);\n}\n\nstatic void a6xx_llc_slices_init(struct platform_device *pdev,\n\t\tstruct a6xx_gpu *a6xx_gpu)\n{\n\tstruct device_node *phandle;\n\n\t \n\tif (adreno_has_gmu_wrapper(&a6xx_gpu->base))\n\t\treturn;\n\n\t \n\tphandle = of_parse_phandle(pdev->dev.of_node, \"iommus\", 0);\n\ta6xx_gpu->have_mmu500 = (phandle &&\n\t\tof_device_is_compatible(phandle, \"arm,mmu-500\"));\n\tof_node_put(phandle);\n\n\tif (a6xx_gpu->have_mmu500)\n\t\ta6xx_gpu->llc_mmio = NULL;\n\telse\n\t\ta6xx_gpu->llc_mmio = msm_ioremap(pdev, \"cx_mem\");\n\n\ta6xx_gpu->llc_slice = llcc_slice_getd(LLCC_GPU);\n\ta6xx_gpu->htw_llc_slice = llcc_slice_getd(LLCC_GPUHTW);\n\n\tif (IS_ERR_OR_NULL(a6xx_gpu->llc_slice) && IS_ERR_OR_NULL(a6xx_gpu->htw_llc_slice))\n\t\ta6xx_gpu->llc_mmio = ERR_PTR(-EINVAL);\n}\n\n#define GBIF_CLIENT_HALT_MASK\t\tBIT(0)\n#define GBIF_ARB_HALT_MASK\t\tBIT(1)\n#define VBIF_XIN_HALT_CTRL0_MASK\tGENMASK(3, 0)\n#define VBIF_RESET_ACK_MASK\t\t0xF0\n#define GPR0_GBIF_HALT_REQUEST\t\t0x1E0\n\nvoid a6xx_bus_clear_pending_transactions(struct adreno_gpu *adreno_gpu, bool gx_off)\n{\n\tstruct msm_gpu *gpu = &adreno_gpu->base;\n\n\tif (adreno_is_a619_holi(adreno_gpu)) {\n\t\tgpu_write(gpu, REG_A6XX_RBBM_GPR0_CNTL, GPR0_GBIF_HALT_REQUEST);\n\t\tspin_until((gpu_read(gpu, REG_A6XX_RBBM_VBIF_GX_RESET_STATUS) &\n\t\t\t\t(VBIF_RESET_ACK_MASK)) == VBIF_RESET_ACK_MASK);\n\t} else if (!a6xx_has_gbif(adreno_gpu)) {\n\t\tgpu_write(gpu, REG_A6XX_VBIF_XIN_HALT_CTRL0, VBIF_XIN_HALT_CTRL0_MASK);\n\t\tspin_until((gpu_read(gpu, REG_A6XX_VBIF_XIN_HALT_CTRL1) &\n\t\t\t\t(VBIF_XIN_HALT_CTRL0_MASK)) == VBIF_XIN_HALT_CTRL0_MASK);\n\t\tgpu_write(gpu, REG_A6XX_VBIF_XIN_HALT_CTRL0, 0);\n\n\t\treturn;\n\t}\n\n\tif (gx_off) {\n\t\t \n\t\tgpu_write(gpu, REG_A6XX_RBBM_GBIF_HALT, 1);\n\t\tspin_until(gpu_read(gpu, REG_A6XX_RBBM_GBIF_HALT_ACK) & 1);\n\t}\n\n\t \n\tgpu_write(gpu, REG_A6XX_GBIF_HALT, GBIF_CLIENT_HALT_MASK);\n\tspin_until((gpu_read(gpu, REG_A6XX_GBIF_HALT_ACK) &\n\t\t\t(GBIF_CLIENT_HALT_MASK)) == GBIF_CLIENT_HALT_MASK);\n\n\t \n\tgpu_write(gpu, REG_A6XX_GBIF_HALT, GBIF_ARB_HALT_MASK);\n\tspin_until((gpu_read(gpu,  REG_A6XX_GBIF_HALT_ACK) &\n\t\t\t(GBIF_ARB_HALT_MASK)) == GBIF_ARB_HALT_MASK);\n\n\t \n\tgpu_write(gpu, REG_A6XX_GBIF_HALT, 0x0);\n}\n\nvoid a6xx_gpu_sw_reset(struct msm_gpu *gpu, bool assert)\n{\n\t \n\tif (adreno_is_a610(to_adreno_gpu(gpu)))\n\t\treturn;\n\n\tgpu_write(gpu, REG_A6XX_RBBM_SW_RESET_CMD, assert);\n\t \n\tgpu_read(gpu, REG_A6XX_RBBM_SW_RESET_CMD);\n\tudelay(1);\n\n\t \n\tif (assert)\n\t\tudelay(100);\n}\n\nstatic int a6xx_gmu_pm_resume(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tint ret;\n\n\tgpu->needs_hw_init = true;\n\n\ttrace_msm_gpu_resume(0);\n\n\tmutex_lock(&a6xx_gpu->gmu.lock);\n\tret = a6xx_gmu_resume(a6xx_gpu);\n\tmutex_unlock(&a6xx_gpu->gmu.lock);\n\tif (ret)\n\t\treturn ret;\n\n\tmsm_devfreq_resume(gpu);\n\n\ta6xx_llc_activate(a6xx_gpu);\n\n\treturn ret;\n}\n\nstatic int a6xx_pm_resume(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\tunsigned long freq = gpu->fast_rate;\n\tstruct dev_pm_opp *opp;\n\tint ret;\n\n\tgpu->needs_hw_init = true;\n\n\ttrace_msm_gpu_resume(0);\n\n\tmutex_lock(&a6xx_gpu->gmu.lock);\n\n\topp = dev_pm_opp_find_freq_ceil(&gpu->pdev->dev, &freq);\n\tif (IS_ERR(opp)) {\n\t\tret = PTR_ERR(opp);\n\t\tgoto err_set_opp;\n\t}\n\tdev_pm_opp_put(opp);\n\n\t \n\tdev_pm_opp_set_opp(&gpu->pdev->dev, opp);\n\n\tpm_runtime_resume_and_get(gmu->dev);\n\tpm_runtime_resume_and_get(gmu->gxpd);\n\n\tret = clk_bulk_prepare_enable(gpu->nr_clocks, gpu->grp_clks);\n\tif (ret)\n\t\tgoto err_bulk_clk;\n\n\tif (adreno_is_a619_holi(adreno_gpu))\n\t\ta6xx_sptprac_enable(gmu);\n\n\t \n\tif (ret) {\nerr_bulk_clk:\n\t\tpm_runtime_put(gmu->gxpd);\n\t\tpm_runtime_put(gmu->dev);\n\t\tdev_pm_opp_set_opp(&gpu->pdev->dev, NULL);\n\t}\nerr_set_opp:\n\tmutex_unlock(&a6xx_gpu->gmu.lock);\n\n\tif (!ret)\n\t\tmsm_devfreq_resume(gpu);\n\n\treturn ret;\n}\n\nstatic int a6xx_gmu_pm_suspend(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tint i, ret;\n\n\ttrace_msm_gpu_suspend(0);\n\n\ta6xx_llc_deactivate(a6xx_gpu);\n\n\tmsm_devfreq_suspend(gpu);\n\n\tmutex_lock(&a6xx_gpu->gmu.lock);\n\tret = a6xx_gmu_stop(a6xx_gpu);\n\tmutex_unlock(&a6xx_gpu->gmu.lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (a6xx_gpu->shadow_bo)\n\t\tfor (i = 0; i < gpu->nr_rings; i++)\n\t\t\ta6xx_gpu->shadow[i] = 0;\n\n\tgpu->suspend_count++;\n\n\treturn 0;\n}\n\nstatic int a6xx_pm_suspend(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tstruct a6xx_gmu *gmu = &a6xx_gpu->gmu;\n\tint i;\n\n\ttrace_msm_gpu_suspend(0);\n\n\tmsm_devfreq_suspend(gpu);\n\n\tmutex_lock(&a6xx_gpu->gmu.lock);\n\n\t \n\ta6xx_bus_clear_pending_transactions(adreno_gpu, true);\n\n\tif (adreno_is_a619_holi(adreno_gpu))\n\t\ta6xx_sptprac_disable(gmu);\n\n\tclk_bulk_disable_unprepare(gpu->nr_clocks, gpu->grp_clks);\n\n\tpm_runtime_put_sync(gmu->gxpd);\n\tdev_pm_opp_set_opp(&gpu->pdev->dev, NULL);\n\tpm_runtime_put_sync(gmu->dev);\n\n\tmutex_unlock(&a6xx_gpu->gmu.lock);\n\n\tif (a6xx_gpu->shadow_bo)\n\t\tfor (i = 0; i < gpu->nr_rings; i++)\n\t\t\ta6xx_gpu->shadow[i] = 0;\n\n\tgpu->suspend_count++;\n\n\treturn 0;\n}\n\nstatic int a6xx_gmu_get_timestamp(struct msm_gpu *gpu, uint64_t *value)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\n\tmutex_lock(&a6xx_gpu->gmu.lock);\n\n\t \n\ta6xx_gmu_set_oob(&a6xx_gpu->gmu, GMU_OOB_PERFCOUNTER_SET);\n\n\t*value = gpu_read64(gpu, REG_A6XX_CP_ALWAYS_ON_COUNTER);\n\n\ta6xx_gmu_clear_oob(&a6xx_gpu->gmu, GMU_OOB_PERFCOUNTER_SET);\n\n\tmutex_unlock(&a6xx_gpu->gmu.lock);\n\n\treturn 0;\n}\n\nstatic int a6xx_get_timestamp(struct msm_gpu *gpu, uint64_t *value)\n{\n\t*value = gpu_read64(gpu, REG_A6XX_CP_ALWAYS_ON_COUNTER);\n\treturn 0;\n}\n\nstatic struct msm_ringbuffer *a6xx_active_ring(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\n\treturn a6xx_gpu->cur_ring;\n}\n\nstatic void a6xx_destroy(struct msm_gpu *gpu)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\n\tif (a6xx_gpu->sqe_bo) {\n\t\tmsm_gem_unpin_iova(a6xx_gpu->sqe_bo, gpu->aspace);\n\t\tdrm_gem_object_put(a6xx_gpu->sqe_bo);\n\t}\n\n\tif (a6xx_gpu->shadow_bo) {\n\t\tmsm_gem_unpin_iova(a6xx_gpu->shadow_bo, gpu->aspace);\n\t\tdrm_gem_object_put(a6xx_gpu->shadow_bo);\n\t}\n\n\ta6xx_llc_slices_destroy(a6xx_gpu);\n\n\ta6xx_gmu_remove(a6xx_gpu);\n\n\tadreno_gpu_cleanup(adreno_gpu);\n\n\tkfree(a6xx_gpu);\n}\n\nstatic u64 a6xx_gpu_busy(struct msm_gpu *gpu, unsigned long *out_sample_rate)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tu64 busy_cycles;\n\n\t \n\t*out_sample_rate = 19200000;\n\n\tbusy_cycles = gmu_read64(&a6xx_gpu->gmu,\n\t\t\tREG_A6XX_GMU_CX_GMU_POWER_COUNTER_XOCLK_0_L,\n\t\t\tREG_A6XX_GMU_CX_GMU_POWER_COUNTER_XOCLK_0_H);\n\n\treturn busy_cycles;\n}\n\nstatic void a6xx_gpu_set_freq(struct msm_gpu *gpu, struct dev_pm_opp *opp,\n\t\t\t      bool suspended)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\n\tmutex_lock(&a6xx_gpu->gmu.lock);\n\ta6xx_gmu_set_freq(gpu, opp, suspended);\n\tmutex_unlock(&a6xx_gpu->gmu.lock);\n}\n\nstatic struct msm_gem_address_space *\na6xx_create_address_space(struct msm_gpu *gpu, struct platform_device *pdev)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\tunsigned long quirks = 0;\n\n\t \n\tif (!IS_ERR_OR_NULL(a6xx_gpu->htw_llc_slice) &&\n\t    !device_iommu_capable(&pdev->dev, IOMMU_CAP_CACHE_COHERENCY))\n\t\tquirks |= IO_PGTABLE_QUIRK_ARM_OUTER_WBWA;\n\n\treturn adreno_iommu_create_address_space(gpu, pdev, quirks);\n}\n\nstatic struct msm_gem_address_space *\na6xx_create_private_address_space(struct msm_gpu *gpu)\n{\n\tstruct msm_mmu *mmu;\n\n\tmmu = msm_iommu_pagetable_create(gpu->aspace->mmu);\n\n\tif (IS_ERR(mmu))\n\t\treturn ERR_CAST(mmu);\n\n\treturn msm_gem_address_space_create(mmu,\n\t\t\"gpu\", 0x100000000ULL,\n\t\tadreno_private_address_space_size(gpu));\n}\n\nstatic uint32_t a6xx_get_rptr(struct msm_gpu *gpu, struct msm_ringbuffer *ring)\n{\n\tstruct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);\n\tstruct a6xx_gpu *a6xx_gpu = to_a6xx_gpu(adreno_gpu);\n\n\tif (adreno_gpu->base.hw_apriv || a6xx_gpu->has_whereami)\n\t\treturn a6xx_gpu->shadow[ring->id];\n\n\treturn ring->memptrs->rptr = gpu_read(gpu, REG_A6XX_CP_RB_RPTR);\n}\n\nstatic bool a6xx_progress(struct msm_gpu *gpu, struct msm_ringbuffer *ring)\n{\n\tstruct msm_cp_state cp_state = {\n\t\t.ib1_base = gpu_read64(gpu, REG_A6XX_CP_IB1_BASE),\n\t\t.ib2_base = gpu_read64(gpu, REG_A6XX_CP_IB2_BASE),\n\t\t.ib1_rem  = gpu_read(gpu, REG_A6XX_CP_IB1_REM_SIZE),\n\t\t.ib2_rem  = gpu_read(gpu, REG_A6XX_CP_IB2_REM_SIZE),\n\t};\n\tbool progress;\n\n\t \n\tcp_state.ib1_rem += gpu_read(gpu, REG_A6XX_CP_ROQ_AVAIL_IB1) >> 16;\n\tcp_state.ib2_rem += gpu_read(gpu, REG_A6XX_CP_ROQ_AVAIL_IB2) >> 16;\n\n\tprogress = !!memcmp(&cp_state, &ring->last_cp_state, sizeof(cp_state));\n\n\tring->last_cp_state = cp_state;\n\n\treturn progress;\n}\n\nstatic u32 fuse_to_supp_hw(const struct adreno_info *info, u32 fuse)\n{\n\tif (!info->speedbins)\n\t\treturn UINT_MAX;\n\n\tfor (int i = 0; info->speedbins[i].fuse != SHRT_MAX; i++)\n\t\tif (info->speedbins[i].fuse == fuse)\n\t\t\treturn BIT(info->speedbins[i].speedbin);\n\n\treturn UINT_MAX;\n}\n\nstatic int a6xx_set_supported_hw(struct device *dev, const struct adreno_info *info)\n{\n\tu32 supp_hw;\n\tu32 speedbin;\n\tint ret;\n\n\tret = adreno_read_speedbin(dev, &speedbin);\n\t \n\tif (ret == -ENOENT) {\n\t\treturn 0;\n\t} else if (ret) {\n\t\tdev_err_probe(dev, ret,\n\t\t\t      \"failed to read speed-bin. Some OPPs may not be supported by hardware\\n\");\n\t\treturn ret;\n\t}\n\n\tsupp_hw = fuse_to_supp_hw(info, speedbin);\n\n\tif (supp_hw == UINT_MAX) {\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t\"missing support for speed-bin: %u. Some OPPs may not be supported by hardware\\n\",\n\t\t\tspeedbin);\n\t\tsupp_hw = BIT(0);  \n\t}\n\n\tret = devm_pm_opp_set_supported_hw(dev, &supp_hw, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct adreno_gpu_funcs funcs = {\n\t.base = {\n\t\t.get_param = adreno_get_param,\n\t\t.set_param = adreno_set_param,\n\t\t.hw_init = a6xx_hw_init,\n\t\t.ucode_load = a6xx_ucode_load,\n\t\t.pm_suspend = a6xx_gmu_pm_suspend,\n\t\t.pm_resume = a6xx_gmu_pm_resume,\n\t\t.recover = a6xx_recover,\n\t\t.submit = a6xx_submit,\n\t\t.active_ring = a6xx_active_ring,\n\t\t.irq = a6xx_irq,\n\t\t.destroy = a6xx_destroy,\n#if defined(CONFIG_DRM_MSM_GPU_STATE)\n\t\t.show = a6xx_show,\n#endif\n\t\t.gpu_busy = a6xx_gpu_busy,\n\t\t.gpu_get_freq = a6xx_gmu_get_freq,\n\t\t.gpu_set_freq = a6xx_gpu_set_freq,\n#if defined(CONFIG_DRM_MSM_GPU_STATE)\n\t\t.gpu_state_get = a6xx_gpu_state_get,\n\t\t.gpu_state_put = a6xx_gpu_state_put,\n#endif\n\t\t.create_address_space = a6xx_create_address_space,\n\t\t.create_private_address_space = a6xx_create_private_address_space,\n\t\t.get_rptr = a6xx_get_rptr,\n\t\t.progress = a6xx_progress,\n\t},\n\t.get_timestamp = a6xx_gmu_get_timestamp,\n};\n\nstatic const struct adreno_gpu_funcs funcs_gmuwrapper = {\n\t.base = {\n\t\t.get_param = adreno_get_param,\n\t\t.set_param = adreno_set_param,\n\t\t.hw_init = a6xx_hw_init,\n\t\t.ucode_load = a6xx_ucode_load,\n\t\t.pm_suspend = a6xx_pm_suspend,\n\t\t.pm_resume = a6xx_pm_resume,\n\t\t.recover = a6xx_recover,\n\t\t.submit = a6xx_submit,\n\t\t.active_ring = a6xx_active_ring,\n\t\t.irq = a6xx_irq,\n\t\t.destroy = a6xx_destroy,\n#if defined(CONFIG_DRM_MSM_GPU_STATE)\n\t\t.show = a6xx_show,\n#endif\n\t\t.gpu_busy = a6xx_gpu_busy,\n#if defined(CONFIG_DRM_MSM_GPU_STATE)\n\t\t.gpu_state_get = a6xx_gpu_state_get,\n\t\t.gpu_state_put = a6xx_gpu_state_put,\n#endif\n\t\t.create_address_space = a6xx_create_address_space,\n\t\t.create_private_address_space = a6xx_create_private_address_space,\n\t\t.get_rptr = a6xx_get_rptr,\n\t\t.progress = a6xx_progress,\n\t},\n\t.get_timestamp = a6xx_get_timestamp,\n};\n\nstruct msm_gpu *a6xx_gpu_init(struct drm_device *dev)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct platform_device *pdev = priv->gpu_pdev;\n\tstruct adreno_platform_config *config = pdev->dev.platform_data;\n\tstruct device_node *node;\n\tstruct a6xx_gpu *a6xx_gpu;\n\tstruct adreno_gpu *adreno_gpu;\n\tstruct msm_gpu *gpu;\n\tint ret;\n\n\ta6xx_gpu = kzalloc(sizeof(*a6xx_gpu), GFP_KERNEL);\n\tif (!a6xx_gpu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tadreno_gpu = &a6xx_gpu->base;\n\tgpu = &adreno_gpu->base;\n\n\tmutex_init(&a6xx_gpu->gmu.lock);\n\n\tadreno_gpu->registers = NULL;\n\n\t \n\tnode = of_parse_phandle(pdev->dev.of_node, \"qcom,gmu\", 0);\n\t \n\tBUG_ON(!node);\n\n\tadreno_gpu->gmu_is_wrapper = of_device_is_compatible(node, \"qcom,adreno-gmu-wrapper\");\n\n\tadreno_gpu->base.hw_apriv =\n\t\t!!(config->info->quirks & ADRENO_QUIRK_HAS_HW_APRIV);\n\n\ta6xx_llc_slices_init(pdev, a6xx_gpu);\n\n\tret = a6xx_set_supported_hw(&pdev->dev, config->info);\n\tif (ret) {\n\t\ta6xx_destroy(&(a6xx_gpu->base.base));\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (adreno_has_gmu_wrapper(adreno_gpu))\n\t\tret = adreno_gpu_init(dev, pdev, adreno_gpu, &funcs_gmuwrapper, 1);\n\telse\n\t\tret = adreno_gpu_init(dev, pdev, adreno_gpu, &funcs, 1);\n\tif (ret) {\n\t\ta6xx_destroy(&(a6xx_gpu->base.base));\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tif (adreno_is_a618(adreno_gpu) || adreno_is_7c3(adreno_gpu))\n\t\tpriv->gpu_clamp_to_idle = true;\n\n\tif (adreno_has_gmu_wrapper(adreno_gpu))\n\t\tret = a6xx_gmu_wrapper_init(a6xx_gpu, node);\n\telse\n\t\tret = a6xx_gmu_init(a6xx_gpu, node);\n\tof_node_put(node);\n\tif (ret) {\n\t\ta6xx_destroy(&(a6xx_gpu->base.base));\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (gpu->aspace)\n\t\tmsm_mmu_set_fault_handler(gpu->aspace->mmu, gpu,\n\t\t\t\ta6xx_fault_handler);\n\n\treturn gpu;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}