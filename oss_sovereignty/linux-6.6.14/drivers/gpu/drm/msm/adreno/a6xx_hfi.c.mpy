{
  "module_name": "a6xx_hfi.c",
  "hash_id": "027ef6e7c97cc35e29e8921f48487d7363c001327100c043bedff906367cc276",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/adreno/a6xx_hfi.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/circ_buf.h>\n#include <linux/list.h>\n\n#include \"a6xx_gmu.h\"\n#include \"a6xx_gmu.xml.h\"\n#include \"a6xx_gpu.h\"\n\n#define HFI_MSG_ID(val) [val] = #val\n\nstatic const char * const a6xx_hfi_msg_id[] = {\n\tHFI_MSG_ID(HFI_H2F_MSG_INIT),\n\tHFI_MSG_ID(HFI_H2F_MSG_FW_VERSION),\n\tHFI_MSG_ID(HFI_H2F_MSG_BW_TABLE),\n\tHFI_MSG_ID(HFI_H2F_MSG_PERF_TABLE),\n\tHFI_MSG_ID(HFI_H2F_MSG_TEST),\n\tHFI_MSG_ID(HFI_H2F_MSG_START),\n\tHFI_MSG_ID(HFI_H2F_MSG_CORE_FW_START),\n\tHFI_MSG_ID(HFI_H2F_MSG_GX_BW_PERF_VOTE),\n\tHFI_MSG_ID(HFI_H2F_MSG_PREPARE_SLUMBER),\n};\n\nstatic int a6xx_hfi_queue_read(struct a6xx_gmu *gmu,\n\tstruct a6xx_hfi_queue *queue, u32 *data, u32 dwords)\n{\n\tstruct a6xx_hfi_queue_header *header = queue->header;\n\tu32 i, hdr, index = header->read_index;\n\n\tif (header->read_index == header->write_index) {\n\t\theader->rx_request = 1;\n\t\treturn 0;\n\t}\n\n\thdr = queue->data[index];\n\n\tqueue->history[(queue->history_idx++) % HFI_HISTORY_SZ] = index;\n\n\t \n\n\tBUG_ON(HFI_HEADER_SIZE(hdr) > dwords);\n\n\tfor (i = 0; i < HFI_HEADER_SIZE(hdr); i++) {\n\t\tdata[i] = queue->data[index];\n\t\tindex = (index + 1) % header->size;\n\t}\n\n\tif (!gmu->legacy)\n\t\tindex = ALIGN(index, 4) % header->size;\n\n\theader->read_index = index;\n\treturn HFI_HEADER_SIZE(hdr);\n}\n\nstatic int a6xx_hfi_queue_write(struct a6xx_gmu *gmu,\n\tstruct a6xx_hfi_queue *queue, u32 *data, u32 dwords)\n{\n\tstruct a6xx_hfi_queue_header *header = queue->header;\n\tu32 i, space, index = header->write_index;\n\n\tspin_lock(&queue->lock);\n\n\tspace = CIRC_SPACE(header->write_index, header->read_index,\n\t\theader->size);\n\tif (space < dwords) {\n\t\theader->dropped++;\n\t\tspin_unlock(&queue->lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tqueue->history[(queue->history_idx++) % HFI_HISTORY_SZ] = index;\n\n\tfor (i = 0; i < dwords; i++) {\n\t\tqueue->data[index] = data[i];\n\t\tindex = (index + 1) % header->size;\n\t}\n\n\t \n\tif (!gmu->legacy) {\n\t\tfor (; index % 4; index = (index + 1) % header->size)\n\t\t\tqueue->data[index] = 0xfafafafa;\n\t}\n\n\theader->write_index = index;\n\tspin_unlock(&queue->lock);\n\n\tgmu_write(gmu, REG_A6XX_GMU_HOST2GMU_INTR_SET, 0x01);\n\treturn 0;\n}\n\nstatic int a6xx_hfi_wait_for_ack(struct a6xx_gmu *gmu, u32 id, u32 seqnum,\n\t\tu32 *payload, u32 payload_size)\n{\n\tstruct a6xx_hfi_queue *queue = &gmu->queues[HFI_RESPONSE_QUEUE];\n\tu32 val;\n\tint ret;\n\n\t \n\tret = gmu_poll_timeout(gmu, REG_A6XX_GMU_GMU2HOST_INTR_INFO, val,\n\t\tval & A6XX_GMU_GMU2HOST_INTR_INFO_MSGQ, 100, 5000);\n\n\tif (ret) {\n\t\tDRM_DEV_ERROR(gmu->dev,\n\t\t\t\"Message %s id %d timed out waiting for response\\n\",\n\t\t\ta6xx_hfi_msg_id[id], seqnum);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tgmu_write(gmu, REG_A6XX_GMU_GMU2HOST_INTR_CLR,\n\t\tA6XX_GMU_GMU2HOST_INTR_INFO_MSGQ);\n\n\tfor (;;) {\n\t\tstruct a6xx_hfi_msg_response resp;\n\n\t\t \n\t\tret = a6xx_hfi_queue_read(gmu, queue, (u32 *) &resp,\n\t\t\tsizeof(resp) >> 2);\n\n\t\t \n\t\tif (!ret) {\n\t\t\tDRM_DEV_ERROR(gmu->dev,\n\t\t\t\t\"The HFI response queue is unexpectedly empty\\n\");\n\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (HFI_HEADER_ID(resp.header) == HFI_F2H_MSG_ERROR) {\n\t\t\tstruct a6xx_hfi_msg_error *error =\n\t\t\t\t(struct a6xx_hfi_msg_error *) &resp;\n\n\t\t\tDRM_DEV_ERROR(gmu->dev, \"GMU firmware error %d\\n\",\n\t\t\t\terror->code);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (seqnum != HFI_HEADER_SEQNUM(resp.ret_header)) {\n\t\t\tDRM_DEV_ERROR(gmu->dev,\n\t\t\t\t\"Unexpected message id %d on the response queue\\n\",\n\t\t\t\tHFI_HEADER_SEQNUM(resp.ret_header));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (resp.error) {\n\t\t\tDRM_DEV_ERROR(gmu->dev,\n\t\t\t\t\"Message %s id %d returned error %d\\n\",\n\t\t\t\ta6xx_hfi_msg_id[id], seqnum, resp.error);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (payload && payload_size)\n\t\t\tmemcpy(payload, resp.payload,\n\t\t\t\tmin_t(u32, payload_size, sizeof(resp.payload)));\n\n\t\treturn 0;\n\t}\n}\n\nstatic int a6xx_hfi_send_msg(struct a6xx_gmu *gmu, int id,\n\t\tvoid *data, u32 size, u32 *payload, u32 payload_size)\n{\n\tstruct a6xx_hfi_queue *queue = &gmu->queues[HFI_COMMAND_QUEUE];\n\tint ret, dwords = size >> 2;\n\tu32 seqnum;\n\n\tseqnum = atomic_inc_return(&queue->seqnum) % 0xfff;\n\n\t \n\t*((u32 *) data) = (seqnum << 20) | (HFI_MSG_CMD << 16) |\n\t\t(dwords << 8) | id;\n\n\tret = a6xx_hfi_queue_write(gmu, queue, data, dwords);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(gmu->dev, \"Unable to send message %s id %d\\n\",\n\t\t\ta6xx_hfi_msg_id[id], seqnum);\n\t\treturn ret;\n\t}\n\n\treturn a6xx_hfi_wait_for_ack(gmu, id, seqnum, payload, payload_size);\n}\n\nstatic int a6xx_hfi_send_gmu_init(struct a6xx_gmu *gmu, int boot_state)\n{\n\tstruct a6xx_hfi_msg_gmu_init_cmd msg = { 0 };\n\n\tmsg.dbg_buffer_addr = (u32) gmu->debug.iova;\n\tmsg.dbg_buffer_size = (u32) gmu->debug.size;\n\tmsg.boot_state = boot_state;\n\n\treturn a6xx_hfi_send_msg(gmu, HFI_H2F_MSG_INIT, &msg, sizeof(msg),\n\t\tNULL, 0);\n}\n\nstatic int a6xx_hfi_get_fw_version(struct a6xx_gmu *gmu, u32 *version)\n{\n\tstruct a6xx_hfi_msg_fw_version msg = { 0 };\n\n\t \n\tmsg.supported_version = (1 << 28) | (1 << 19) | (1 << 17);\n\n\treturn a6xx_hfi_send_msg(gmu, HFI_H2F_MSG_FW_VERSION, &msg, sizeof(msg),\n\t\tversion, sizeof(*version));\n}\n\nstatic int a6xx_hfi_send_perf_table_v1(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_hfi_msg_perf_table_v1 msg = { 0 };\n\tint i;\n\n\tmsg.num_gpu_levels = gmu->nr_gpu_freqs;\n\tmsg.num_gmu_levels = gmu->nr_gmu_freqs;\n\n\tfor (i = 0; i < gmu->nr_gpu_freqs; i++) {\n\t\tmsg.gx_votes[i].vote = gmu->gx_arc_votes[i];\n\t\tmsg.gx_votes[i].freq = gmu->gpu_freqs[i] / 1000;\n\t}\n\n\tfor (i = 0; i < gmu->nr_gmu_freqs; i++) {\n\t\tmsg.cx_votes[i].vote = gmu->cx_arc_votes[i];\n\t\tmsg.cx_votes[i].freq = gmu->gmu_freqs[i] / 1000;\n\t}\n\n\treturn a6xx_hfi_send_msg(gmu, HFI_H2F_MSG_PERF_TABLE, &msg, sizeof(msg),\n\t\tNULL, 0);\n}\n\nstatic int a6xx_hfi_send_perf_table(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_hfi_msg_perf_table msg = { 0 };\n\tint i;\n\n\tmsg.num_gpu_levels = gmu->nr_gpu_freqs;\n\tmsg.num_gmu_levels = gmu->nr_gmu_freqs;\n\n\tfor (i = 0; i < gmu->nr_gpu_freqs; i++) {\n\t\tmsg.gx_votes[i].vote = gmu->gx_arc_votes[i];\n\t\tmsg.gx_votes[i].acd = 0xffffffff;\n\t\tmsg.gx_votes[i].freq = gmu->gpu_freqs[i] / 1000;\n\t}\n\n\tfor (i = 0; i < gmu->nr_gmu_freqs; i++) {\n\t\tmsg.cx_votes[i].vote = gmu->cx_arc_votes[i];\n\t\tmsg.cx_votes[i].freq = gmu->gmu_freqs[i] / 1000;\n\t}\n\n\treturn a6xx_hfi_send_msg(gmu, HFI_H2F_MSG_PERF_TABLE, &msg, sizeof(msg),\n\t\tNULL, 0);\n}\n\nstatic void a618_build_bw_table(struct a6xx_hfi_msg_bw_table *msg)\n{\n\t \n\tmsg->bw_level_num = 1;\n\n\tmsg->ddr_cmds_num = 3;\n\tmsg->ddr_wait_bitmask = 0x01;\n\n\tmsg->ddr_cmds_addrs[0] = 0x50000;\n\tmsg->ddr_cmds_addrs[1] = 0x5003c;\n\tmsg->ddr_cmds_addrs[2] = 0x5000c;\n\n\tmsg->ddr_cmds_data[0][0] =  0x40000000;\n\tmsg->ddr_cmds_data[0][1] =  0x40000000;\n\tmsg->ddr_cmds_data[0][2] =  0x40000000;\n\n\t \n\tmsg->cnoc_cmds_num = 1;\n\tmsg->cnoc_wait_bitmask = 0x01;\n\n\tmsg->cnoc_cmds_addrs[0] = 0x5007c;\n\tmsg->cnoc_cmds_data[0][0] =  0x40000000;\n\tmsg->cnoc_cmds_data[1][0] =  0x60000001;\n}\n\nstatic void a619_build_bw_table(struct a6xx_hfi_msg_bw_table *msg)\n{\n\tmsg->bw_level_num = 13;\n\n\tmsg->ddr_cmds_num = 3;\n\tmsg->ddr_wait_bitmask = 0x0;\n\n\tmsg->ddr_cmds_addrs[0] = 0x50000;\n\tmsg->ddr_cmds_addrs[1] = 0x50004;\n\tmsg->ddr_cmds_addrs[2] = 0x50080;\n\n\tmsg->ddr_cmds_data[0][0]  = 0x40000000;\n\tmsg->ddr_cmds_data[0][1]  = 0x40000000;\n\tmsg->ddr_cmds_data[0][2]  = 0x40000000;\n\tmsg->ddr_cmds_data[1][0]  = 0x6000030c;\n\tmsg->ddr_cmds_data[1][1]  = 0x600000db;\n\tmsg->ddr_cmds_data[1][2]  = 0x60000008;\n\tmsg->ddr_cmds_data[2][0]  = 0x60000618;\n\tmsg->ddr_cmds_data[2][1]  = 0x600001b6;\n\tmsg->ddr_cmds_data[2][2]  = 0x60000008;\n\tmsg->ddr_cmds_data[3][0]  = 0x60000925;\n\tmsg->ddr_cmds_data[3][1]  = 0x60000291;\n\tmsg->ddr_cmds_data[3][2]  = 0x60000008;\n\tmsg->ddr_cmds_data[4][0]  = 0x60000dc1;\n\tmsg->ddr_cmds_data[4][1]  = 0x600003dc;\n\tmsg->ddr_cmds_data[4][2]  = 0x60000008;\n\tmsg->ddr_cmds_data[5][0]  = 0x600010ad;\n\tmsg->ddr_cmds_data[5][1]  = 0x600004ae;\n\tmsg->ddr_cmds_data[5][2]  = 0x60000008;\n\tmsg->ddr_cmds_data[6][0]  = 0x600014c3;\n\tmsg->ddr_cmds_data[6][1]  = 0x600005d4;\n\tmsg->ddr_cmds_data[6][2]  = 0x60000008;\n\tmsg->ddr_cmds_data[7][0]  = 0x6000176a;\n\tmsg->ddr_cmds_data[7][1]  = 0x60000693;\n\tmsg->ddr_cmds_data[7][2]  = 0x60000008;\n\tmsg->ddr_cmds_data[8][0]  = 0x60001f01;\n\tmsg->ddr_cmds_data[8][1]  = 0x600008b5;\n\tmsg->ddr_cmds_data[8][2]  = 0x60000008;\n\tmsg->ddr_cmds_data[9][0]  = 0x60002940;\n\tmsg->ddr_cmds_data[9][1]  = 0x60000b95;\n\tmsg->ddr_cmds_data[9][2]  = 0x60000008;\n\tmsg->ddr_cmds_data[10][0] = 0x60002f68;\n\tmsg->ddr_cmds_data[10][1] = 0x60000d50;\n\tmsg->ddr_cmds_data[10][2] = 0x60000008;\n\tmsg->ddr_cmds_data[11][0] = 0x60003700;\n\tmsg->ddr_cmds_data[11][1] = 0x60000f71;\n\tmsg->ddr_cmds_data[11][2] = 0x60000008;\n\tmsg->ddr_cmds_data[12][0] = 0x60003fce;\n\tmsg->ddr_cmds_data[12][1] = 0x600011ea;\n\tmsg->ddr_cmds_data[12][2] = 0x60000008;\n\n\tmsg->cnoc_cmds_num = 1;\n\tmsg->cnoc_wait_bitmask = 0x0;\n\n\tmsg->cnoc_cmds_addrs[0] = 0x50054;\n\n\tmsg->cnoc_cmds_data[0][0] = 0x40000000;\n}\n\nstatic void a640_build_bw_table(struct a6xx_hfi_msg_bw_table *msg)\n{\n\t \n\tmsg->bw_level_num = 1;\n\n\tmsg->ddr_cmds_num = 3;\n\tmsg->ddr_wait_bitmask = 0x01;\n\n\tmsg->ddr_cmds_addrs[0] = 0x50000;\n\tmsg->ddr_cmds_addrs[1] = 0x5003c;\n\tmsg->ddr_cmds_addrs[2] = 0x5000c;\n\n\tmsg->ddr_cmds_data[0][0] =  0x40000000;\n\tmsg->ddr_cmds_data[0][1] =  0x40000000;\n\tmsg->ddr_cmds_data[0][2] =  0x40000000;\n\n\t \n\tmsg->cnoc_cmds_num = 3;\n\tmsg->cnoc_wait_bitmask = 0x01;\n\n\tmsg->cnoc_cmds_addrs[0] = 0x50034;\n\tmsg->cnoc_cmds_addrs[1] = 0x5007c;\n\tmsg->cnoc_cmds_addrs[2] = 0x5004c;\n\n\tmsg->cnoc_cmds_data[0][0] =  0x40000000;\n\tmsg->cnoc_cmds_data[0][1] =  0x00000000;\n\tmsg->cnoc_cmds_data[0][2] =  0x40000000;\n\n\tmsg->cnoc_cmds_data[1][0] =  0x60000001;\n\tmsg->cnoc_cmds_data[1][1] =  0x20000001;\n\tmsg->cnoc_cmds_data[1][2] =  0x60000001;\n}\n\nstatic void a650_build_bw_table(struct a6xx_hfi_msg_bw_table *msg)\n{\n\t \n\tmsg->bw_level_num = 1;\n\n\tmsg->ddr_cmds_num = 3;\n\tmsg->ddr_wait_bitmask = 0x01;\n\n\tmsg->ddr_cmds_addrs[0] = 0x50000;\n\tmsg->ddr_cmds_addrs[1] = 0x50004;\n\tmsg->ddr_cmds_addrs[2] = 0x5007c;\n\n\tmsg->ddr_cmds_data[0][0] =  0x40000000;\n\tmsg->ddr_cmds_data[0][1] =  0x40000000;\n\tmsg->ddr_cmds_data[0][2] =  0x40000000;\n\n\t \n\tmsg->cnoc_cmds_num = 1;\n\tmsg->cnoc_wait_bitmask = 0x01;\n\n\tmsg->cnoc_cmds_addrs[0] = 0x500a4;\n\tmsg->cnoc_cmds_data[0][0] =  0x40000000;\n\tmsg->cnoc_cmds_data[1][0] =  0x60000001;\n}\n\nstatic void a690_build_bw_table(struct a6xx_hfi_msg_bw_table *msg)\n{\n\t \n\tmsg->bw_level_num = 1;\n\n\tmsg->ddr_cmds_num = 3;\n\tmsg->ddr_wait_bitmask = 0x01;\n\n\tmsg->ddr_cmds_addrs[0] = 0x50004;\n\tmsg->ddr_cmds_addrs[1] = 0x50000;\n\tmsg->ddr_cmds_addrs[2] = 0x500ac;\n\n\tmsg->ddr_cmds_data[0][0] =  0x40000000;\n\tmsg->ddr_cmds_data[0][1] =  0x40000000;\n\tmsg->ddr_cmds_data[0][2] =  0x40000000;\n\n\t \n\tmsg->cnoc_cmds_num = 1;\n\tmsg->cnoc_wait_bitmask = 0x01;\n\n\tmsg->cnoc_cmds_addrs[0] = 0x5003c;\n\tmsg->cnoc_cmds_data[0][0] =  0x40000000;\n\tmsg->cnoc_cmds_data[1][0] =  0x60000001;\n}\n\nstatic void a660_build_bw_table(struct a6xx_hfi_msg_bw_table *msg)\n{\n\t \n\tmsg->bw_level_num = 1;\n\n\tmsg->ddr_cmds_num = 3;\n\tmsg->ddr_wait_bitmask = 0x01;\n\n\tmsg->ddr_cmds_addrs[0] = 0x50004;\n\tmsg->ddr_cmds_addrs[1] = 0x500a0;\n\tmsg->ddr_cmds_addrs[2] = 0x50000;\n\n\tmsg->ddr_cmds_data[0][0] =  0x40000000;\n\tmsg->ddr_cmds_data[0][1] =  0x40000000;\n\tmsg->ddr_cmds_data[0][2] =  0x40000000;\n\n\t \n\tmsg->cnoc_cmds_num = 1;\n\tmsg->cnoc_wait_bitmask = 0x01;\n\n\tmsg->cnoc_cmds_addrs[0] = 0x50070;\n\tmsg->cnoc_cmds_data[0][0] =  0x40000000;\n\tmsg->cnoc_cmds_data[1][0] =  0x60000001;\n}\n\nstatic void adreno_7c3_build_bw_table(struct a6xx_hfi_msg_bw_table *msg)\n{\n\t \n\tmsg->bw_level_num = 1;\n\n\tmsg->ddr_cmds_num = 3;\n\tmsg->ddr_wait_bitmask = 0x07;\n\n\tmsg->ddr_cmds_addrs[0] = 0x50004;\n\tmsg->ddr_cmds_addrs[1] = 0x50000;\n\tmsg->ddr_cmds_addrs[2] = 0x50088;\n\n\tmsg->ddr_cmds_data[0][0] =  0x40000000;\n\tmsg->ddr_cmds_data[0][1] =  0x40000000;\n\tmsg->ddr_cmds_data[0][2] =  0x40000000;\n\n\t \n\tmsg->cnoc_cmds_num = 1;\n\tmsg->cnoc_wait_bitmask = 0x01;\n\n\tmsg->cnoc_cmds_addrs[0] = 0x5006c;\n\tmsg->cnoc_cmds_data[0][0] =  0x40000000;\n\tmsg->cnoc_cmds_data[1][0] =  0x60000001;\n}\nstatic void a6xx_build_bw_table(struct a6xx_hfi_msg_bw_table *msg)\n{\n\t \n\tmsg->bw_level_num = 1;\n\n\tmsg->ddr_cmds_num = 3;\n\tmsg->ddr_wait_bitmask = 0x07;\n\n\tmsg->ddr_cmds_addrs[0] = 0x50000;\n\tmsg->ddr_cmds_addrs[1] = 0x5005c;\n\tmsg->ddr_cmds_addrs[2] = 0x5000c;\n\n\tmsg->ddr_cmds_data[0][0] =  0x40000000;\n\tmsg->ddr_cmds_data[0][1] =  0x40000000;\n\tmsg->ddr_cmds_data[0][2] =  0x40000000;\n\n\t \n\n\tmsg->cnoc_cmds_num = 3;\n\tmsg->cnoc_wait_bitmask = 0x05;\n\n\tmsg->cnoc_cmds_addrs[0] = 0x50034;\n\tmsg->cnoc_cmds_addrs[1] = 0x5007c;\n\tmsg->cnoc_cmds_addrs[2] = 0x5004c;\n\n\tmsg->cnoc_cmds_data[0][0] =  0x40000000;\n\tmsg->cnoc_cmds_data[0][1] =  0x00000000;\n\tmsg->cnoc_cmds_data[0][2] =  0x40000000;\n\n\tmsg->cnoc_cmds_data[1][0] =  0x60000001;\n\tmsg->cnoc_cmds_data[1][1] =  0x20000001;\n\tmsg->cnoc_cmds_data[1][2] =  0x60000001;\n}\n\n\nstatic int a6xx_hfi_send_bw_table(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_hfi_msg_bw_table msg = { 0 };\n\tstruct a6xx_gpu *a6xx_gpu = container_of(gmu, struct a6xx_gpu, gmu);\n\tstruct adreno_gpu *adreno_gpu = &a6xx_gpu->base;\n\n\tif (adreno_is_a618(adreno_gpu))\n\t\ta618_build_bw_table(&msg);\n\telse if (adreno_is_a619(adreno_gpu))\n\t\ta619_build_bw_table(&msg);\n\telse if (adreno_is_a640_family(adreno_gpu))\n\t\ta640_build_bw_table(&msg);\n\telse if (adreno_is_a650(adreno_gpu))\n\t\ta650_build_bw_table(&msg);\n\telse if (adreno_is_7c3(adreno_gpu))\n\t\tadreno_7c3_build_bw_table(&msg);\n\telse if (adreno_is_a660(adreno_gpu))\n\t\ta660_build_bw_table(&msg);\n\telse if (adreno_is_a690(adreno_gpu))\n\t\ta690_build_bw_table(&msg);\n\telse\n\t\ta6xx_build_bw_table(&msg);\n\n\treturn a6xx_hfi_send_msg(gmu, HFI_H2F_MSG_BW_TABLE, &msg, sizeof(msg),\n\t\tNULL, 0);\n}\n\nstatic int a6xx_hfi_send_test(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_hfi_msg_test msg = { 0 };\n\n\treturn a6xx_hfi_send_msg(gmu, HFI_H2F_MSG_TEST, &msg, sizeof(msg),\n\t\tNULL, 0);\n}\n\nstatic int a6xx_hfi_send_start(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_hfi_msg_start msg = { 0 };\n\n\treturn a6xx_hfi_send_msg(gmu, HFI_H2F_MSG_START, &msg, sizeof(msg),\n\t\tNULL, 0);\n}\n\nstatic int a6xx_hfi_send_core_fw_start(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_hfi_msg_core_fw_start msg = { 0 };\n\n\treturn a6xx_hfi_send_msg(gmu, HFI_H2F_MSG_CORE_FW_START, &msg,\n\t\tsizeof(msg), NULL, 0);\n}\n\nint a6xx_hfi_set_freq(struct a6xx_gmu *gmu, int index)\n{\n\tstruct a6xx_hfi_gx_bw_perf_vote_cmd msg = { 0 };\n\n\tmsg.ack_type = 1;  \n\tmsg.freq = index;\n\tmsg.bw = 0;  \n\n\treturn a6xx_hfi_send_msg(gmu, HFI_H2F_MSG_GX_BW_PERF_VOTE, &msg,\n\t\tsizeof(msg), NULL, 0);\n}\n\nint a6xx_hfi_send_prep_slumber(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_hfi_prep_slumber_cmd msg = { 0 };\n\n\t \n\n\treturn a6xx_hfi_send_msg(gmu, HFI_H2F_MSG_PREPARE_SLUMBER, &msg,\n\t\tsizeof(msg), NULL, 0);\n}\n\nstatic int a6xx_hfi_start_v1(struct a6xx_gmu *gmu, int boot_state)\n{\n\tint ret;\n\n\tret = a6xx_hfi_send_gmu_init(gmu, boot_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = a6xx_hfi_get_fw_version(gmu, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = a6xx_hfi_send_perf_table_v1(gmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = a6xx_hfi_send_bw_table(gmu);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ta6xx_hfi_send_test(gmu);\n\n\treturn 0;\n}\n\nint a6xx_hfi_start(struct a6xx_gmu *gmu, int boot_state)\n{\n\tint ret;\n\n\tif (gmu->legacy)\n\t\treturn a6xx_hfi_start_v1(gmu, boot_state);\n\n\n\tret = a6xx_hfi_send_perf_table(gmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = a6xx_hfi_send_bw_table(gmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = a6xx_hfi_send_core_fw_start(gmu);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = a6xx_hfi_send_start(gmu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nvoid a6xx_hfi_stop(struct a6xx_gmu *gmu)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(gmu->queues); i++) {\n\t\tstruct a6xx_hfi_queue *queue = &gmu->queues[i];\n\n\t\tif (!queue->header)\n\t\t\tcontinue;\n\n\t\tif (queue->header->read_index != queue->header->write_index)\n\t\t\tDRM_DEV_ERROR(gmu->dev, \"HFI queue %d is not empty\\n\", i);\n\n\t\tqueue->header->read_index = 0;\n\t\tqueue->header->write_index = 0;\n\n\t\tmemset(&queue->history, 0xff, sizeof(queue->history));\n\t\tqueue->history_idx = 0;\n\t}\n}\n\nstatic void a6xx_hfi_queue_init(struct a6xx_hfi_queue *queue,\n\t\tstruct a6xx_hfi_queue_header *header, void *virt, u64 iova,\n\t\tu32 id)\n{\n\tspin_lock_init(&queue->lock);\n\tqueue->header = header;\n\tqueue->data = virt;\n\tatomic_set(&queue->seqnum, 0);\n\n\tmemset(&queue->history, 0xff, sizeof(queue->history));\n\tqueue->history_idx = 0;\n\n\t \n\theader->iova = iova;\n\theader->type =  10 << 8 | id;\n\theader->status = 1;\n\theader->size = SZ_4K >> 2;\n\theader->msg_size = 0;\n\theader->dropped = 0;\n\theader->rx_watermark = 1;\n\theader->tx_watermark = 1;\n\theader->rx_request = 1;\n\theader->tx_request = 0;\n\theader->read_index = 0;\n\theader->write_index = 0;\n}\n\nvoid a6xx_hfi_init(struct a6xx_gmu *gmu)\n{\n\tstruct a6xx_gmu_bo *hfi = &gmu->hfi;\n\tstruct a6xx_hfi_queue_table_header *table = hfi->virt;\n\tstruct a6xx_hfi_queue_header *headers = hfi->virt + sizeof(*table);\n\tu64 offset;\n\tint table_size;\n\n\t \n\ttable_size = sizeof(*table);\n\ttable_size += (ARRAY_SIZE(gmu->queues) *\n\t\tsizeof(struct a6xx_hfi_queue_header));\n\n\ttable->version = 0;\n\ttable->size = table_size;\n\t \n\ttable->qhdr0_offset = sizeof(*table) >> 2;\n\ttable->qhdr_size = sizeof(struct a6xx_hfi_queue_header) >> 2;\n\ttable->num_queues = ARRAY_SIZE(gmu->queues);\n\ttable->active_queues = ARRAY_SIZE(gmu->queues);\n\n\t \n\toffset = SZ_4K;\n\ta6xx_hfi_queue_init(&gmu->queues[0], &headers[0], hfi->virt + offset,\n\t\thfi->iova + offset, 0);\n\n\t \n\toffset += SZ_4K;\n\ta6xx_hfi_queue_init(&gmu->queues[1], &headers[1], hfi->virt + offset,\n\t\thfi->iova + offset, gmu->legacy ? 4 : 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}