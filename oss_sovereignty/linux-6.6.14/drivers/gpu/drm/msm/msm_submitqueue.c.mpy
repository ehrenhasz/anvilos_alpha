{
  "module_name": "msm_submitqueue.c",
  "hash_id": "12d6c88903a785def3a2bbfc93201cd718c982bac739944c61a6c3786f730a0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_submitqueue.c",
  "human_readable_source": "\n \n\n#include <linux/kref.h>\n#include <linux/uaccess.h>\n\n#include \"msm_gpu.h\"\n\nint msm_file_private_set_sysprof(struct msm_file_private *ctx,\n\t\t\t\t struct msm_gpu *gpu, int sysprof)\n{\n\t \n\n\tswitch (sysprof) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase 2:\n\t\tpm_runtime_get_sync(&gpu->pdev->dev);\n\t\tfallthrough;\n\tcase 1:\n\t\trefcount_inc(&gpu->sysprof_active);\n\t\tfallthrough;\n\tcase 0:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (ctx->sysprof) {\n\tcase 2:\n\t\tpm_runtime_put_autosuspend(&gpu->pdev->dev);\n\t\tfallthrough;\n\tcase 1:\n\t\trefcount_dec(&gpu->sysprof_active);\n\t\tfallthrough;\n\tcase 0:\n\t\tbreak;\n\t}\n\n\tctx->sysprof = sysprof;\n\n\treturn 0;\n}\n\nvoid __msm_file_private_destroy(struct kref *kref)\n{\n\tstruct msm_file_private *ctx = container_of(kref,\n\t\tstruct msm_file_private, ref);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctx->entities); i++) {\n\t\tif (!ctx->entities[i])\n\t\t\tcontinue;\n\n\t\tdrm_sched_entity_destroy(ctx->entities[i]);\n\t\tkfree(ctx->entities[i]);\n\t}\n\n\tmsm_gem_address_space_put(ctx->aspace);\n\tkfree(ctx->comm);\n\tkfree(ctx->cmdline);\n\tkfree(ctx);\n}\n\nvoid msm_submitqueue_destroy(struct kref *kref)\n{\n\tstruct msm_gpu_submitqueue *queue = container_of(kref,\n\t\tstruct msm_gpu_submitqueue, ref);\n\n\tidr_destroy(&queue->fence_idr);\n\n\tmsm_file_private_put(queue->ctx);\n\n\tkfree(queue);\n}\n\nstruct msm_gpu_submitqueue *msm_submitqueue_get(struct msm_file_private *ctx,\n\t\tu32 id)\n{\n\tstruct msm_gpu_submitqueue *entry;\n\n\tif (!ctx)\n\t\treturn NULL;\n\n\tread_lock(&ctx->queuelock);\n\n\tlist_for_each_entry(entry, &ctx->submitqueues, node) {\n\t\tif (entry->id == id) {\n\t\t\tkref_get(&entry->ref);\n\t\t\tread_unlock(&ctx->queuelock);\n\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\tread_unlock(&ctx->queuelock);\n\treturn NULL;\n}\n\nvoid msm_submitqueue_close(struct msm_file_private *ctx)\n{\n\tstruct msm_gpu_submitqueue *entry, *tmp;\n\n\tif (!ctx)\n\t\treturn;\n\n\t \n\tlist_for_each_entry_safe(entry, tmp, &ctx->submitqueues, node) {\n\t\tlist_del(&entry->node);\n\t\tmsm_submitqueue_put(entry);\n\t}\n}\n\nstatic struct drm_sched_entity *\nget_sched_entity(struct msm_file_private *ctx, struct msm_ringbuffer *ring,\n\t\t unsigned ring_nr, enum drm_sched_priority sched_prio)\n{\n\tstatic DEFINE_MUTEX(entity_lock);\n\tunsigned idx = (ring_nr * NR_SCHED_PRIORITIES) + sched_prio;\n\n\t \n\tif (WARN_ON(idx >= ARRAY_SIZE(ctx->entities)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmutex_lock(&entity_lock);\n\n\tif (!ctx->entities[idx]) {\n\t\tstruct drm_sched_entity *entity;\n\t\tstruct drm_gpu_scheduler *sched = &ring->sched;\n\t\tint ret;\n\n\t\tentity = kzalloc(sizeof(*ctx->entities[idx]), GFP_KERNEL);\n\n\t\tret = drm_sched_entity_init(entity, sched_prio, &sched, 1, NULL);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&entity_lock);\n\t\t\tkfree(entity);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tctx->entities[idx] = entity;\n\t}\n\n\tmutex_unlock(&entity_lock);\n\n\treturn ctx->entities[idx];\n}\n\nint msm_submitqueue_create(struct drm_device *drm, struct msm_file_private *ctx,\n\t\tu32 prio, u32 flags, u32 *id)\n{\n\tstruct msm_drm_private *priv = drm->dev_private;\n\tstruct msm_gpu_submitqueue *queue;\n\tenum drm_sched_priority sched_prio;\n\tunsigned ring_nr;\n\tint ret;\n\n\tif (!ctx)\n\t\treturn -ENODEV;\n\n\tif (!priv->gpu)\n\t\treturn -ENODEV;\n\n\tret = msm_gpu_convert_priority(priv->gpu, prio, &ring_nr, &sched_prio);\n\tif (ret)\n\t\treturn ret;\n\n\tqueue = kzalloc(sizeof(*queue), GFP_KERNEL);\n\n\tif (!queue)\n\t\treturn -ENOMEM;\n\n\tkref_init(&queue->ref);\n\tqueue->flags = flags;\n\tqueue->ring_nr = ring_nr;\n\n\tqueue->entity = get_sched_entity(ctx, priv->gpu->rb[ring_nr],\n\t\t\t\t\t ring_nr, sched_prio);\n\tif (IS_ERR(queue->entity)) {\n\t\tret = PTR_ERR(queue->entity);\n\t\tkfree(queue);\n\t\treturn ret;\n\t}\n\n\twrite_lock(&ctx->queuelock);\n\n\tqueue->ctx = msm_file_private_get(ctx);\n\tqueue->id = ctx->queueid++;\n\n\tif (id)\n\t\t*id = queue->id;\n\n\tidr_init(&queue->fence_idr);\n\tspin_lock_init(&queue->idr_lock);\n\tmutex_init(&queue->lock);\n\n\tlist_add_tail(&queue->node, &ctx->submitqueues);\n\n\twrite_unlock(&ctx->queuelock);\n\n\treturn 0;\n}\n\n \nint msm_submitqueue_init(struct drm_device *drm, struct msm_file_private *ctx)\n{\n\tstruct msm_drm_private *priv = drm->dev_private;\n\tint default_prio, max_priority;\n\n\tif (!priv->gpu)\n\t\treturn -ENODEV;\n\n\tmax_priority = (priv->gpu->nr_rings * NR_SCHED_PRIORITIES) - 1;\n\n\t \n\tdefault_prio = DIV_ROUND_UP(max_priority, 2);\n\n\treturn msm_submitqueue_create(drm, ctx, default_prio, 0, NULL);\n}\n\nstatic int msm_submitqueue_query_faults(struct msm_gpu_submitqueue *queue,\n\t\tstruct drm_msm_submitqueue_query *args)\n{\n\tsize_t size = min_t(size_t, args->len, sizeof(queue->faults));\n\tint ret;\n\n\t \n\tif (!args->len) {\n\t\targs->len = sizeof(queue->faults);\n\t\treturn 0;\n\t}\n\n\t \n\targs->len = size;\n\n\tret = copy_to_user(u64_to_user_ptr(args->data), &queue->faults, size);\n\n\treturn ret ? -EFAULT : 0;\n}\n\nint msm_submitqueue_query(struct drm_device *drm, struct msm_file_private *ctx,\n\t\tstruct drm_msm_submitqueue_query *args)\n{\n\tstruct msm_gpu_submitqueue *queue;\n\tint ret = -EINVAL;\n\n\tif (args->pad)\n\t\treturn -EINVAL;\n\n\tqueue = msm_submitqueue_get(ctx, args->id);\n\tif (!queue)\n\t\treturn -ENOENT;\n\n\tif (args->param == MSM_SUBMITQUEUE_PARAM_FAULTS)\n\t\tret = msm_submitqueue_query_faults(queue, args);\n\n\tmsm_submitqueue_put(queue);\n\n\treturn ret;\n}\n\nint msm_submitqueue_remove(struct msm_file_private *ctx, u32 id)\n{\n\tstruct msm_gpu_submitqueue *entry;\n\n\tif (!ctx)\n\t\treturn 0;\n\n\t \n\tif (!id)\n\t\treturn -ENOENT;\n\n\twrite_lock(&ctx->queuelock);\n\n\tlist_for_each_entry(entry, &ctx->submitqueues, node) {\n\t\tif (entry->id == id) {\n\t\t\tlist_del(&entry->node);\n\t\t\twrite_unlock(&ctx->queuelock);\n\n\t\t\tmsm_submitqueue_put(entry);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twrite_unlock(&ctx->queuelock);\n\treturn -ENOENT;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}