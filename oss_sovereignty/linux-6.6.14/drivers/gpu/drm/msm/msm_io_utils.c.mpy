{
  "module_name": "msm_io_utils.c",
  "hash_id": "43d5ba1278c73087429598f231235cdf3848b2f8e39d0edade241f0e08415425",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_io_utils.c",
  "human_readable_source": "\n \n\n#include <linux/interconnect.h>\n#include <linux/io.h>\n\n#include \"msm_drv.h\"\n\n \n\nstruct clk *msm_clk_bulk_get_clock(struct clk_bulk_data *bulk, int count,\n\t\tconst char *name)\n{\n\tint i;\n\tchar n[32];\n\n\tsnprintf(n, sizeof(n), \"%s_clk\", name);\n\n\tfor (i = 0; bulk && i < count; i++) {\n\t\tif (!strcmp(bulk[i].id, name) || !strcmp(bulk[i].id, n))\n\t\t\treturn bulk[i].clk;\n\t}\n\n\n\treturn NULL;\n}\n\nstruct clk *msm_clk_get(struct platform_device *pdev, const char *name)\n{\n\tstruct clk *clk;\n\tchar name2[32];\n\n\tclk = devm_clk_get(&pdev->dev, name);\n\tif (!IS_ERR(clk) || PTR_ERR(clk) == -EPROBE_DEFER)\n\t\treturn clk;\n\n\tsnprintf(name2, sizeof(name2), \"%s_clk\", name);\n\n\tclk = devm_clk_get(&pdev->dev, name2);\n\tif (!IS_ERR(clk))\n\t\tdev_warn(&pdev->dev, \"Using legacy clk name binding.  Use \"\n\t\t\t\t\"\\\"%s\\\" instead of \\\"%s\\\"\\n\", name, name2);\n\n\treturn clk;\n}\n\nstatic void __iomem *_msm_ioremap(struct platform_device *pdev, const char *name,\n\t\t\t\t  bool quiet, phys_addr_t *psize)\n{\n\tstruct resource *res;\n\tunsigned long size;\n\tvoid __iomem *ptr;\n\n\tif (name)\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\n\telse\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tif (!res) {\n\t\tif (!quiet)\n\t\t\tDRM_DEV_ERROR(&pdev->dev, \"failed to get memory resource: %s\\n\", name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsize = resource_size(res);\n\n\tptr = devm_ioremap(&pdev->dev, res->start, size);\n\tif (!ptr) {\n\t\tif (!quiet)\n\t\t\tDRM_DEV_ERROR(&pdev->dev, \"failed to ioremap: %s\\n\", name);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (psize)\n\t\t*psize = size;\n\n\treturn ptr;\n}\n\nvoid __iomem *msm_ioremap(struct platform_device *pdev, const char *name)\n{\n\treturn _msm_ioremap(pdev, name, false, NULL);\n}\n\nvoid __iomem *msm_ioremap_quiet(struct platform_device *pdev, const char *name)\n{\n\treturn _msm_ioremap(pdev, name, true, NULL);\n}\n\nvoid __iomem *msm_ioremap_size(struct platform_device *pdev, const char *name,\n\t\t\t  phys_addr_t *psize)\n{\n\treturn _msm_ioremap(pdev, name, false, psize);\n}\n\nstatic enum hrtimer_restart msm_hrtimer_worktimer(struct hrtimer *t)\n{\n\tstruct msm_hrtimer_work *work = container_of(t,\n\t\t\tstruct msm_hrtimer_work, timer);\n\n\tkthread_queue_work(work->worker, &work->work);\n\n\treturn HRTIMER_NORESTART;\n}\n\nvoid msm_hrtimer_queue_work(struct msm_hrtimer_work *work,\n\t\t\t    ktime_t wakeup_time,\n\t\t\t    enum hrtimer_mode mode)\n{\n\thrtimer_start(&work->timer, wakeup_time, mode);\n}\n\nvoid msm_hrtimer_work_init(struct msm_hrtimer_work *work,\n\t\t\t   struct kthread_worker *worker,\n\t\t\t   kthread_work_func_t fn,\n\t\t\t   clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\thrtimer_init(&work->timer, clock_id, mode);\n\twork->timer.function = msm_hrtimer_worktimer;\n\twork->worker = worker;\n\tkthread_init_work(&work->work, fn);\n}\n\nstruct icc_path *msm_icc_get(struct device *dev, const char *name)\n{\n\tstruct device *mdss_dev = dev->parent;\n\tstruct icc_path *path;\n\n\tpath = of_icc_get(dev, name);\n\tif (path)\n\t\treturn path;\n\n\t \n\treturn of_icc_get(mdss_dev, name);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}