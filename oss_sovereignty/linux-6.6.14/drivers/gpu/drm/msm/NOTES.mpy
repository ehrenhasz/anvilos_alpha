{
  "module_name": "NOTES",
  "hash_id": "b3e8c224fb980ec1c6a756198bc15e71d5b559adf0ac5802594a3154a577fa7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/NOTES",
  "human_readable_source": "NOTES about msm drm/kms driver:\n\nIn the current snapdragon SoC's, we have (at least) 3 different\ndisplay controller blocks at play:\n + MDP3 - ?? seems to be what is on geeksphone peak device\n + MDP4 - S3 (APQ8060, touchpad), S4-pro (APQ8064, nexus4 & ifc6410)\n + MDP5 - snapdragon 800\n\n(I don't have a completely clear picture on which display controller\nmaps to which part #)\n\nPlus a handful of blocks around them for HDMI/DSI/etc output.\n\nAnd on gpu side of things:\n + zero, one, or two 2d cores (z180)\n + and either a2xx or a3xx 3d core.\n\nBut, HDMI/DSI/etc blocks seem like they can be shared across multiple\ndisplay controller blocks.  And I for sure don't want to have to deal\nwith N different kms devices from xf86-video-freedreno.  Plus, it\nseems like we can do some clever tricks like use GPU to trigger\npageflip after rendering completes (ie. have the kms/crtc code build\nup gpu cmdstream to update scanout and write FLUSH register after).\n\nSo, the approach is one drm driver, with some modularity.  Different\n'struct msm_kms' implementations, depending on display controller.\nAnd one or more 'struct msm_gpu' for the various different gpu sub-\nmodules.\n\n(Second part is not implemented yet.  So far this is just basic KMS\ndriver, and not exposing any custom ioctls to userspace for now.)\n\nThe kms module provides the plane, crtc, and encoder objects, and\nloads whatever connectors are appropriate.\n\nFor MDP4, the mapping is:\n\n  plane   -> PIPE{RGBn,VGn}              \\\n  crtc    -> OVLP{n} + DMA{P,S,E} (??)   |-> MDP \"device\"\n  encoder -> DTV/LCDC/DSI (within MDP4)  /\n  connector -> HDMI/DSI/etc              --> other device(s)\n\nSince the irq's that drm core mostly cares about are vblank/framedone,\nwe'll let msm_mdp4_kms provide the irq install/uninstall/etc functions\nand treat the MDP4 block's irq as \"the\" irq.  Even though the connectors\nmay have their own irqs which they install themselves.  For this reason\nthe display controller is the \"master\" device.\n\nFor MDP5, the mapping is:\n\n  plane   -> PIPE{RGBn,VIGn}             \\\n  crtc    -> LM (layer mixer)            |-> MDP \"device\"\n  encoder -> INTF                        /\n  connector -> HDMI/DSI/eDP/etc          --> other device(s)\n\nUnlike MDP4, it appears we can get by with a single encoder, rather\nthan needing a different implementation for DTV, DSI, etc.  (Ie. the\nregister interface is same, just different bases.)\n\nAlso unlike MDP4, with MDP5 all the IRQs for other blocks (HDMI, DSI,\netc) are routed through MDP.\n\nAnd finally, MDP5 has this \"Shared Memory Pool\" (called \"SMP\"), from\nwhich blocks need to be allocated to the active pipes based on fetch\nstride.\n\nEach connector probably ends up being a separate device, just for the\nlogistics of finding/mapping io region, irq, etc.  Idealy we would\nhave a better way than just stashing the platform device in a global\n(ie. like DT super-node.. but I don't have any snapdragon hw yet that\nis using DT).\n\nNote that so far I've not been able to get any docs on the hw, and it\nseems that access to such docs would prevent me from working on the\nfreedreno gallium driver.  So there may be some mistakes in register\nnames (I had to invent a few, since no sufficient hint was given in\nthe downstream android fbdev driver), bitfield sizes, etc.  My current\nstate of understanding the registers is given in the envytools rnndb\nfiles at:\n\n  https://github.com/freedreno/envytools/tree/master/rnndb\n  (the mdp4/hdmi/dsi directories)\n\nThese files are used both for a parser tool (in the same tree) to\nparse logged register reads/writes (both from downstream android fbdev\ndriver, and this driver with register logging enabled), as well as to\ngenerate the register level headers.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}