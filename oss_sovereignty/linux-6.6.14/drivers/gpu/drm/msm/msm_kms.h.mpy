{
  "module_name": "msm_kms.h",
  "hash_id": "995f54454d82ac6bd20a09567d0404caea0bfc7ae6a9b9f6af8b89428d8ee63b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_kms.h",
  "human_readable_source": " \n \n\n#ifndef __MSM_KMS_H__\n#define __MSM_KMS_H__\n\n#include <linux/clk.h>\n#include <linux/regulator/consumer.h>\n\n#include \"msm_drv.h\"\n\n#define MAX_PLANE\t4\n\n \nstruct msm_kms_funcs {\n\t \n\tint (*hw_init)(struct msm_kms *kms);\n\t \n\tvoid (*irq_preinstall)(struct msm_kms *kms);\n\tint (*irq_postinstall)(struct msm_kms *kms);\n\tvoid (*irq_uninstall)(struct msm_kms *kms);\n\tirqreturn_t (*irq)(struct msm_kms *kms);\n\tint (*enable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);\n\tvoid (*disable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);\n\n\t \n\n\t \n\tvoid (*enable_commit)(struct msm_kms *kms);\n\tvoid (*disable_commit)(struct msm_kms *kms);\n\n\t \n\tvoid (*prepare_commit)(struct msm_kms *kms, struct drm_atomic_state *state);\n\n\t \n\tvoid (*flush_commit)(struct msm_kms *kms, unsigned crtc_mask);\n\n\t \n\tvoid (*wait_flush)(struct msm_kms *kms, unsigned crtc_mask);\n\n\t \n\tvoid (*complete_commit)(struct msm_kms *kms, unsigned crtc_mask);\n\n\t \n\n\t \n\tconst struct msm_format *(*get_format)(struct msm_kms *kms,\n\t\t\t\t\tconst uint32_t format,\n\t\t\t\t\tconst uint64_t modifiers);\n\t \n\tint (*check_modified_format)(const struct msm_kms *kms,\n\t\t\tconst struct msm_format *msm_fmt,\n\t\t\tconst struct drm_mode_fb_cmd2 *cmd,\n\t\t\tstruct drm_gem_object **bos);\n\n\t \n\tlong (*round_pixclk)(struct msm_kms *kms, unsigned long rate,\n\t\t\tstruct drm_encoder *encoder);\n\tint (*set_split_display)(struct msm_kms *kms,\n\t\t\tstruct drm_encoder *encoder,\n\t\t\tstruct drm_encoder *slave_encoder,\n\t\t\tbool is_cmd_mode);\n\t \n\tvoid (*destroy)(struct msm_kms *kms);\n\n\t \n\tvoid (*snapshot)(struct msm_disp_state *disp_state, struct msm_kms *kms);\n\n#ifdef CONFIG_DEBUG_FS\n\t \n\tint (*debugfs_init)(struct msm_kms *kms, struct drm_minor *minor);\n#endif\n};\n\nstruct msm_kms;\n\n \nstruct msm_pending_timer {\n\tstruct msm_hrtimer_work work;\n\tstruct kthread_worker *worker;\n\tstruct msm_kms *kms;\n\tunsigned crtc_idx;\n};\n\nstruct msm_kms {\n\tconst struct msm_kms_funcs *funcs;\n\tstruct drm_device *dev;\n\n\t \n\tint irq;\n\tbool irq_requested;\n\n\t \n\tstruct msm_gem_address_space *aspace;\n\n\t \n\tstruct kthread_worker *dump_worker;\n\tstruct kthread_work dump_work;\n\tstruct mutex dump_mutex;\n\n\t \n\tstruct mutex commit_lock[MAX_CRTCS];\n\tunsigned pending_crtc_mask;\n\tstruct msm_pending_timer pending_timers[MAX_CRTCS];\n};\n\nstatic inline int msm_kms_init(struct msm_kms *kms,\n\t\tconst struct msm_kms_funcs *funcs)\n{\n\tunsigned i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(kms->commit_lock); i++)\n\t\tmutex_init(&kms->commit_lock[i]);\n\n\tkms->funcs = funcs;\n\n\tfor (i = 0; i < ARRAY_SIZE(kms->pending_timers); i++) {\n\t\tret = msm_atomic_init_pending_timer(&kms->pending_timers[i], kms, i);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline void msm_kms_destroy(struct msm_kms *kms)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < ARRAY_SIZE(kms->pending_timers); i++)\n\t\tmsm_atomic_destroy_pending_timer(&kms->pending_timers[i]);\n}\n\n#define for_each_crtc_mask(dev, crtc, crtc_mask) \\\n\tdrm_for_each_crtc(crtc, dev) \\\n\t\tfor_each_if (drm_crtc_mask(crtc) & (crtc_mask))\n\n#define for_each_crtc_mask_reverse(dev, crtc, crtc_mask) \\\n\tdrm_for_each_crtc_reverse(crtc, dev) \\\n\t\tfor_each_if (drm_crtc_mask(crtc) & (crtc_mask))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}