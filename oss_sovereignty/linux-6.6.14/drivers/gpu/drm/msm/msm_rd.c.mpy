{
  "module_name": "msm_rd.c",
  "hash_id": "89514438cfc5d3d511aba51fe95ac2ef48970ced1021441a26e93dabd4b34b85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/msm/msm_rd.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/circ_buf.h>\n#include <linux/debugfs.h>\n#include <linux/kfifo.h>\n#include <linux/uaccess.h>\n#include <linux/wait.h>\n\n#include <drm/drm_file.h>\n\n#include \"msm_drv.h\"\n#include \"msm_gpu.h\"\n#include \"msm_gem.h\"\n\nbool rd_full = false;\nMODULE_PARM_DESC(rd_full, \"If true, $debugfs/.../rd will snapshot all buffer contents\");\nmodule_param_named(rd_full, rd_full, bool, 0600);\n\n#ifdef CONFIG_DEBUG_FS\n\nenum rd_sect_type {\n\tRD_NONE,\n\tRD_TEST,        \n\tRD_CMD,         \n\tRD_GPUADDR,     \n\tRD_CONTEXT,     \n\tRD_CMDSTREAM,   \n\tRD_CMDSTREAM_ADDR,  \n\tRD_PARAM,       \n\tRD_FLUSH,       \n\tRD_PROGRAM,     \n\tRD_VERT_SHADER,\n\tRD_FRAG_SHADER,\n\tRD_BUFFER_CONTENTS,\n\tRD_GPU_ID,\n\tRD_CHIP_ID,\n};\n\n#define BUF_SZ 512   \n\n \n#define circ_count(circ) \\\n\t(CIRC_CNT((circ)->head, (circ)->tail, BUF_SZ))\n#define circ_count_to_end(circ) \\\n\t(CIRC_CNT_TO_END((circ)->head, (circ)->tail, BUF_SZ))\n \n#define circ_space(circ) \\\n\t(CIRC_SPACE((circ)->head, (circ)->tail, BUF_SZ))\n#define circ_space_to_end(circ) \\\n\t(CIRC_SPACE_TO_END((circ)->head, (circ)->tail, BUF_SZ))\n\nstruct msm_rd_state {\n\tstruct drm_device *dev;\n\n\tbool open;\n\n\t \n\tstruct mutex read_lock, write_lock;\n\n\twait_queue_head_t fifo_event;\n\tstruct circ_buf fifo;\n\n\tchar buf[BUF_SZ];\n};\n\nstatic void rd_write(struct msm_rd_state *rd, const void *buf, int sz)\n{\n\tstruct circ_buf *fifo = &rd->fifo;\n\tconst char *ptr = buf;\n\n\twhile (sz > 0) {\n\t\tchar *fptr = &fifo->buf[fifo->head];\n\t\tint n;\n\n\t\twait_event(rd->fifo_event, circ_space(&rd->fifo) > 0 || !rd->open);\n\t\tif (!rd->open)\n\t\t\treturn;\n\n\t\t \n\t\tn = min(sz, circ_space_to_end(&rd->fifo));\n\t\tmemcpy(fptr, ptr, n);\n\n\t\tsmp_store_release(&fifo->head, (fifo->head + n) & (BUF_SZ - 1));\n\t\tsz  -= n;\n\t\tptr += n;\n\n\t\twake_up_all(&rd->fifo_event);\n\t}\n}\n\nstatic void rd_write_section(struct msm_rd_state *rd,\n\t\tenum rd_sect_type type, const void *buf, int sz)\n{\n\trd_write(rd, &type, 4);\n\trd_write(rd, &sz, 4);\n\trd_write(rd, buf, sz);\n}\n\nstatic ssize_t rd_read(struct file *file, char __user *buf,\n\t\tsize_t sz, loff_t *ppos)\n{\n\tstruct msm_rd_state *rd = file->private_data;\n\tstruct circ_buf *fifo = &rd->fifo;\n\tconst char *fptr = &fifo->buf[fifo->tail];\n\tint n = 0, ret = 0;\n\n\tmutex_lock(&rd->read_lock);\n\n\tret = wait_event_interruptible(rd->fifo_event,\n\t\t\tcirc_count(&rd->fifo) > 0);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tn = min_t(int, sz, circ_count_to_end(&rd->fifo));\n\tif (copy_to_user(buf, fptr, n)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsmp_store_release(&fifo->tail, (fifo->tail + n) & (BUF_SZ - 1));\n\t*ppos += n;\n\n\twake_up_all(&rd->fifo_event);\n\nout:\n\tmutex_unlock(&rd->read_lock);\n\tif (ret)\n\t\treturn ret;\n\treturn n;\n}\n\nstatic int rd_open(struct inode *inode, struct file *file)\n{\n\tstruct msm_rd_state *rd = inode->i_private;\n\tstruct drm_device *dev = rd->dev;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct msm_gpu *gpu = priv->gpu;\n\tuint64_t val;\n\tuint32_t gpu_id;\n\tuint32_t zero = 0;\n\tint ret = 0;\n\n\tif (!gpu)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&gpu->lock);\n\n\tif (rd->open) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tfile->private_data = rd;\n\trd->open = true;\n\n\t \n\trd->fifo.head = rd->fifo.tail = 0;\n\n\t \n\tgpu->funcs->get_param(gpu, NULL, MSM_PARAM_GPU_ID, &val, &zero);\n\tgpu_id = val;\n\n\trd_write_section(rd, RD_GPU_ID, &gpu_id, sizeof(gpu_id));\n\n\tgpu->funcs->get_param(gpu, NULL, MSM_PARAM_CHIP_ID, &val, &zero);\n\trd_write_section(rd, RD_CHIP_ID, &val, sizeof(val));\n\nout:\n\tmutex_unlock(&gpu->lock);\n\treturn ret;\n}\n\nstatic int rd_release(struct inode *inode, struct file *file)\n{\n\tstruct msm_rd_state *rd = inode->i_private;\n\n\trd->open = false;\n\twake_up_all(&rd->fifo_event);\n\n\treturn 0;\n}\n\n\nstatic const struct file_operations rd_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rd_open,\n\t.read = rd_read,\n\t.llseek = no_llseek,\n\t.release = rd_release,\n};\n\n\nstatic void rd_cleanup(struct msm_rd_state *rd)\n{\n\tif (!rd)\n\t\treturn;\n\n\tmutex_destroy(&rd->read_lock);\n\tmutex_destroy(&rd->write_lock);\n\tkfree(rd);\n}\n\nstatic struct msm_rd_state *rd_init(struct drm_minor *minor, const char *name)\n{\n\tstruct msm_rd_state *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trd->dev = minor->dev;\n\trd->fifo.buf = rd->buf;\n\n\tmutex_init(&rd->read_lock);\n\tmutex_init(&rd->write_lock);\n\n\tinit_waitqueue_head(&rd->fifo_event);\n\n\tdebugfs_create_file(name, S_IFREG | S_IRUGO, minor->debugfs_root, rd,\n\t\t\t    &rd_debugfs_fops);\n\n\treturn rd;\n}\n\nint msm_rd_debugfs_init(struct drm_minor *minor)\n{\n\tstruct msm_drm_private *priv = minor->dev->dev_private;\n\tstruct msm_rd_state *rd;\n\tint ret;\n\n\t \n\tif (priv->rd)\n\t\treturn 0;\n\n\trd = rd_init(minor, \"rd\");\n\tif (IS_ERR(rd)) {\n\t\tret = PTR_ERR(rd);\n\t\tgoto fail;\n\t}\n\n\tpriv->rd = rd;\n\n\trd = rd_init(minor, \"hangrd\");\n\tif (IS_ERR(rd)) {\n\t\tret = PTR_ERR(rd);\n\t\tgoto fail;\n\t}\n\n\tpriv->hangrd = rd;\n\n\treturn 0;\n\nfail:\n\tmsm_rd_debugfs_cleanup(priv);\n\treturn ret;\n}\n\nvoid msm_rd_debugfs_cleanup(struct msm_drm_private *priv)\n{\n\trd_cleanup(priv->rd);\n\tpriv->rd = NULL;\n\n\trd_cleanup(priv->hangrd);\n\tpriv->hangrd = NULL;\n}\n\nstatic void snapshot_buf(struct msm_rd_state *rd,\n\t\tstruct msm_gem_submit *submit, int idx,\n\t\tuint64_t iova, uint32_t size, bool full)\n{\n\tstruct drm_gem_object *obj = submit->bos[idx].obj;\n\tunsigned offset = 0;\n\tconst char *buf;\n\n\tif (iova) {\n\t\toffset = iova - submit->bos[idx].iova;\n\t} else {\n\t\tiova = submit->bos[idx].iova;\n\t\tsize = obj->size;\n\t}\n\n\t \n\trd_write_section(rd, RD_GPUADDR,\n\t\t\t(uint32_t[3]){ iova, size, iova >> 32 }, 12);\n\n\tif (!full)\n\t\treturn;\n\n\t \n\tif (!(submit->bos[idx].flags & MSM_SUBMIT_BO_READ))\n\t\treturn;\n\n\tbuf = msm_gem_get_vaddr_active(obj);\n\tif (IS_ERR(buf))\n\t\treturn;\n\n\tbuf += offset;\n\n\trd_write_section(rd, RD_BUFFER_CONTENTS, buf, size);\n\n\tmsm_gem_put_vaddr_locked(obj);\n}\n\n \nvoid msm_rd_dump_submit(struct msm_rd_state *rd, struct msm_gem_submit *submit,\n\t\tconst char *fmt, ...)\n{\n\tstruct task_struct *task;\n\tchar msg[256];\n\tint i, n;\n\n\tif (!rd->open)\n\t\treturn;\n\n\tmutex_lock(&rd->write_lock);\n\n\tif (fmt) {\n\t\tva_list args;\n\n\t\tva_start(args, fmt);\n\t\tn = vscnprintf(msg, sizeof(msg), fmt, args);\n\t\tva_end(args);\n\n\t\trd_write_section(rd, RD_CMD, msg, ALIGN(n, 4));\n\t}\n\n\trcu_read_lock();\n\ttask = pid_task(submit->pid, PIDTYPE_PID);\n\tif (task) {\n\t\tn = scnprintf(msg, sizeof(msg), \"%.*s/%d: fence=%u\",\n\t\t\t\tTASK_COMM_LEN, task->comm,\n\t\t\t\tpid_nr(submit->pid), submit->seqno);\n\t} else {\n\t\tn = scnprintf(msg, sizeof(msg), \"???/%d: fence=%u\",\n\t\t\t\tpid_nr(submit->pid), submit->seqno);\n\t}\n\trcu_read_unlock();\n\n\trd_write_section(rd, RD_CMD, msg, ALIGN(n, 4));\n\n\tfor (i = 0; i < submit->nr_bos; i++)\n\t\tsnapshot_buf(rd, submit, i, 0, 0, should_dump(submit, i));\n\n\tfor (i = 0; i < submit->nr_cmds; i++) {\n\t\tuint32_t szd  = submit->cmd[i].size;  \n\n\t\t \n\t\tif (!should_dump(submit, i)) {\n\t\t\tsnapshot_buf(rd, submit, submit->cmd[i].idx,\n\t\t\t\t\tsubmit->cmd[i].iova, szd * 4, true);\n\t\t}\n\t}\n\n\tfor (i = 0; i < submit->nr_cmds; i++) {\n\t\tuint64_t iova = submit->cmd[i].iova;\n\t\tuint32_t szd  = submit->cmd[i].size;  \n\n\t\tswitch (submit->cmd[i].type) {\n\t\tcase MSM_SUBMIT_CMD_IB_TARGET_BUF:\n\t\t\t \n\t\t\tbreak;\n\t\tcase MSM_SUBMIT_CMD_CTX_RESTORE_BUF:\n\t\tcase MSM_SUBMIT_CMD_BUF:\n\t\t\trd_write_section(rd, RD_CMDSTREAM_ADDR,\n\t\t\t\t(uint32_t[3]){ iova, szd, iova >> 32 }, 12);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&rd->write_lock);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}