{
  "module_name": "vbox_irq.c",
  "hash_id": "46e4ca165a5d9eb714e7164dfd77ec3bb8427a9d427109c36a211f3d4e90d29d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vboxvideo/vbox_irq.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"vbox_drv.h\"\n#include \"vboxvideo.h\"\n\nstatic void vbox_clear_irq(void)\n{\n\toutl((u32)~0, VGA_PORT_HGSMI_HOST);\n}\n\nstatic u32 vbox_get_flags(struct vbox_private *vbox)\n{\n\treturn readl(vbox->guest_heap + HOST_FLAGS_OFFSET);\n}\n\nvoid vbox_report_hotplug(struct vbox_private *vbox)\n{\n\tschedule_work(&vbox->hotplug_work);\n}\n\nstatic irqreturn_t vbox_irq_handler(int irq, void *arg)\n{\n\tstruct drm_device *dev = (struct drm_device *)arg;\n\tstruct vbox_private *vbox = to_vbox_dev(dev);\n\tu32 host_flags = vbox_get_flags(vbox);\n\n\tif (!(host_flags & HGSMIHOSTFLAGS_IRQ))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (host_flags &\n\t    (HGSMIHOSTFLAGS_HOTPLUG | HGSMIHOSTFLAGS_CURSOR_CAPABILITIES) &&\n\t    !(host_flags & HGSMIHOSTFLAGS_VSYNC))\n\t\tvbox_report_hotplug(vbox);\n\n\tvbox_clear_irq();\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void validate_or_set_position_hints(struct vbox_private *vbox)\n{\n\tstruct vbva_modehint *hintsi, *hintsj;\n\tbool valid = true;\n\tu16 currentx = 0;\n\tint i, j;\n\n\tfor (i = 0; i < vbox->num_crtcs; ++i) {\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\thintsi = &vbox->last_mode_hints[i];\n\t\t\thintsj = &vbox->last_mode_hints[j];\n\n\t\t\tif (hintsi->enabled && hintsj->enabled) {\n\t\t\t\tif (hintsi->dx >= 0xffff ||\n\t\t\t\t    hintsi->dy >= 0xffff ||\n\t\t\t\t    hintsj->dx >= 0xffff ||\n\t\t\t\t    hintsj->dy >= 0xffff ||\n\t\t\t\t    (hintsi->dx <\n\t\t\t\t\thintsj->dx + (hintsj->cx & 0x8fff) &&\n\t\t\t\t     hintsi->dx + (hintsi->cx & 0x8fff) >\n\t\t\t\t\thintsj->dx) ||\n\t\t\t\t    (hintsi->dy <\n\t\t\t\t\thintsj->dy + (hintsj->cy & 0x8fff) &&\n\t\t\t\t     hintsi->dy + (hintsi->cy & 0x8fff) >\n\t\t\t\t\thintsj->dy))\n\t\t\t\t\tvalid = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (!valid)\n\t\tfor (i = 0; i < vbox->num_crtcs; ++i) {\n\t\t\tif (vbox->last_mode_hints[i].enabled) {\n\t\t\t\tvbox->last_mode_hints[i].dx = currentx;\n\t\t\t\tvbox->last_mode_hints[i].dy = 0;\n\t\t\t\tcurrentx +=\n\t\t\t\t    vbox->last_mode_hints[i].cx & 0x8fff;\n\t\t\t}\n\t\t}\n}\n\n \nstatic void vbox_update_mode_hints(struct vbox_private *vbox)\n{\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_device *dev = &vbox->ddev;\n\tstruct drm_connector *connector;\n\tstruct vbox_connector *vbox_conn;\n\tstruct vbva_modehint *hints;\n\tu16 flags;\n\tbool disconnected;\n\tunsigned int crtc_id;\n\tint ret;\n\n\tret = hgsmi_get_mode_hints(vbox->guest_pool, vbox->num_crtcs,\n\t\t\t\t   vbox->last_mode_hints);\n\tif (ret) {\n\t\tDRM_ERROR(\"vboxvideo: hgsmi_get_mode_hints failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tvalidate_or_set_position_hints(vbox);\n\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tvbox_conn = to_vbox_connector(connector);\n\n\t\thints = &vbox->last_mode_hints[vbox_conn->vbox_crtc->crtc_id];\n\t\tif (hints->magic != VBVAMODEHINT_MAGIC)\n\t\t\tcontinue;\n\n\t\tdisconnected = !(hints->enabled);\n\t\tcrtc_id = vbox_conn->vbox_crtc->crtc_id;\n\t\tvbox_conn->mode_hint.width = hints->cx;\n\t\tvbox_conn->mode_hint.height = hints->cy;\n\t\tvbox_conn->vbox_crtc->x_hint = hints->dx;\n\t\tvbox_conn->vbox_crtc->y_hint = hints->dy;\n\t\tvbox_conn->mode_hint.disconnected = disconnected;\n\n\t\tif (vbox_conn->vbox_crtc->disconnected == disconnected)\n\t\t\tcontinue;\n\n\t\tif (disconnected)\n\t\t\tflags = VBVA_SCREEN_F_ACTIVE | VBVA_SCREEN_F_DISABLED;\n\t\telse\n\t\t\tflags = VBVA_SCREEN_F_ACTIVE | VBVA_SCREEN_F_BLANK;\n\n\t\thgsmi_process_display_info(vbox->guest_pool, crtc_id, 0, 0, 0,\n\t\t\t\t\t   hints->cx * 4, hints->cx,\n\t\t\t\t\t   hints->cy, 0, flags);\n\n\t\tvbox_conn->vbox_crtc->disconnected = disconnected;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n}\n\nstatic void vbox_hotplug_worker(struct work_struct *work)\n{\n\tstruct vbox_private *vbox = container_of(work, struct vbox_private,\n\t\t\t\t\t\t hotplug_work);\n\n\tvbox_update_mode_hints(vbox);\n\tdrm_kms_helper_hotplug_event(&vbox->ddev);\n}\n\nint vbox_irq_init(struct vbox_private *vbox)\n{\n\tstruct drm_device *dev = &vbox->ddev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tINIT_WORK(&vbox->hotplug_work, vbox_hotplug_worker);\n\tvbox_update_mode_hints(vbox);\n\n\t \n\treturn request_irq(pdev->irq, vbox_irq_handler, IRQF_SHARED, dev->driver->name, dev);\n}\n\nvoid vbox_irq_fini(struct vbox_private *vbox)\n{\n\tstruct drm_device *dev = &vbox->ddev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tfree_irq(pdev->irq, dev);\n\tflush_work(&vbox->hotplug_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}