{
  "module_name": "hgsmi_base.c",
  "hash_id": "7b5722363c02e0553be1ac6ace2085262bd13b7525de7c49d8b3e9ba3b8a523f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vboxvideo/hgsmi_base.c",
  "human_readable_source": "\n \n\n#include <linux/vbox_err.h>\n#include \"vbox_drv.h\"\n#include \"vboxvideo_guest.h\"\n#include \"vboxvideo_vbe.h\"\n#include \"hgsmi_channels.h\"\n#include \"hgsmi_ch_setup.h\"\n\n \nint hgsmi_report_flags_location(struct gen_pool *ctx, u32 location)\n{\n\tstruct hgsmi_buffer_location *p;\n\n\tp = hgsmi_buffer_alloc(ctx, sizeof(*p), HGSMI_CH_HGSMI,\n\t\t\t       HGSMI_CC_HOST_FLAGS_LOCATION);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->buf_location = location;\n\tp->buf_len = sizeof(struct hgsmi_host_flags);\n\n\thgsmi_buffer_submit(ctx, p);\n\thgsmi_buffer_free(ctx, p);\n\n\treturn 0;\n}\n\n \nint hgsmi_send_caps_info(struct gen_pool *ctx, u32 caps)\n{\n\tstruct vbva_caps *p;\n\n\tp = hgsmi_buffer_alloc(ctx, sizeof(*p), HGSMI_CH_VBVA, VBVA_INFO_CAPS);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->rc = VERR_NOT_IMPLEMENTED;\n\tp->caps = caps;\n\n\thgsmi_buffer_submit(ctx, p);\n\n\tWARN_ON_ONCE(p->rc < 0);\n\n\thgsmi_buffer_free(ctx, p);\n\n\treturn 0;\n}\n\nint hgsmi_test_query_conf(struct gen_pool *ctx)\n{\n\tu32 value = 0;\n\tint ret;\n\n\tret = hgsmi_query_conf(ctx, U32_MAX, &value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn value == U32_MAX ? 0 : -EIO;\n}\n\n \nint hgsmi_query_conf(struct gen_pool *ctx, u32 index, u32 *value_ret)\n{\n\tstruct vbva_conf32 *p;\n\n\tp = hgsmi_buffer_alloc(ctx, sizeof(*p), HGSMI_CH_VBVA,\n\t\t\t       VBVA_QUERY_CONF32);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->index = index;\n\tp->value = U32_MAX;\n\n\thgsmi_buffer_submit(ctx, p);\n\n\t*value_ret = p->value;\n\n\thgsmi_buffer_free(ctx, p);\n\n\treturn 0;\n}\n\n \nint hgsmi_update_pointer_shape(struct gen_pool *ctx, u32 flags,\n\t\t\t       u32 hot_x, u32 hot_y, u32 width, u32 height,\n\t\t\t       u8 *pixels, u32 len)\n{\n\tstruct vbva_mouse_pointer_shape *p;\n\tu32 pixel_len = 0;\n\tint rc;\n\n\tif (flags & VBOX_MOUSE_POINTER_SHAPE) {\n\t\t \n\t\tpixel_len = ((((width + 7) / 8) * height + 3) & ~3) +\n\t\t\t width * 4 * height;\n\t\tif (pixel_len > len)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tflags |= VBOX_MOUSE_POINTER_VISIBLE;\n\t}\n\n\tp = hgsmi_buffer_alloc(ctx, sizeof(*p) + pixel_len, HGSMI_CH_VBVA,\n\t\t\t       VBVA_MOUSE_POINTER_SHAPE);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->result = VINF_SUCCESS;\n\tp->flags = flags;\n\tp->hot_X = hot_x;\n\tp->hot_y = hot_y;\n\tp->width = width;\n\tp->height = height;\n\tif (pixel_len)\n\t\tmemcpy(p->data, pixels, pixel_len);\n\n\thgsmi_buffer_submit(ctx, p);\n\n\tswitch (p->result) {\n\tcase VINF_SUCCESS:\n\t\trc = 0;\n\t\tbreak;\n\tcase VERR_NO_MEMORY:\n\t\trc = -ENOMEM;\n\t\tbreak;\n\tcase VERR_NOT_SUPPORTED:\n\t\trc = -EBUSY;\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\n\thgsmi_buffer_free(ctx, p);\n\n\treturn rc;\n}\n\n \nint hgsmi_cursor_position(struct gen_pool *ctx, bool report_position,\n\t\t\t  u32 x, u32 y, u32 *x_host, u32 *y_host)\n{\n\tstruct vbva_cursor_position *p;\n\n\tp = hgsmi_buffer_alloc(ctx, sizeof(*p), HGSMI_CH_VBVA,\n\t\t\t       VBVA_CURSOR_POSITION);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->report_position = report_position;\n\tp->x = x;\n\tp->y = y;\n\n\thgsmi_buffer_submit(ctx, p);\n\n\t*x_host = p->x;\n\t*y_host = p->y;\n\n\thgsmi_buffer_free(ctx, p);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}