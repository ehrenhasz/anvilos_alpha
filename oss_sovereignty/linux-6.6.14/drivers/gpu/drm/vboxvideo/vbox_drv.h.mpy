{
  "module_name": "vbox_drv.h",
  "hash_id": "3b11bb819daa0ab719368ebbec76b4aa69a8c025de77f23545b115ab014fedce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vboxvideo/vbox_drv.h",
  "human_readable_source": " \n \n#ifndef __VBOX_DRV_H__\n#define __VBOX_DRV_H__\n\n#include <linux/genalloc.h>\n#include <linux/io.h>\n#include <linux/irqreturn.h>\n#include <linux/string.h>\n\n#include <drm/drm_encoder.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_vram_helper.h>\n\n#include \"vboxvideo_guest.h\"\n#include \"vboxvideo_vbe.h\"\n#include \"hgsmi_ch_setup.h\"\n\n#define DRIVER_NAME         \"vboxvideo\"\n#define DRIVER_DESC         \"Oracle VM VirtualBox Graphics Card\"\n#define DRIVER_DATE         \"20130823\"\n\n#define DRIVER_MAJOR        1\n#define DRIVER_MINOR        0\n#define DRIVER_PATCHLEVEL   0\n\n#define VBOX_MAX_CURSOR_WIDTH  64\n#define VBOX_MAX_CURSOR_HEIGHT 64\n#define CURSOR_PIXEL_COUNT (VBOX_MAX_CURSOR_WIDTH * VBOX_MAX_CURSOR_HEIGHT)\n#define CURSOR_DATA_SIZE (CURSOR_PIXEL_COUNT * 4 + CURSOR_PIXEL_COUNT / 8)\n\n#define VBOX_MAX_SCREENS  32\n\n#define GUEST_HEAP_OFFSET(vbox) ((vbox)->full_vram_size - \\\n\t\t\t\t VBVA_ADAPTER_INFORMATION_SIZE)\n#define GUEST_HEAP_SIZE   VBVA_ADAPTER_INFORMATION_SIZE\n#define GUEST_HEAP_USABLE_SIZE (VBVA_ADAPTER_INFORMATION_SIZE - \\\n\t\t\t\tsizeof(struct hgsmi_host_flags))\n#define HOST_FLAGS_OFFSET GUEST_HEAP_USABLE_SIZE\n\nstruct vbox_private {\n\t \n\tstruct drm_device ddev;\n\n\tu8 __iomem *guest_heap;\n\tu8 __iomem *vbva_buffers;\n\tstruct gen_pool *guest_pool;\n\tstruct vbva_buf_ctx *vbva_info;\n\tbool any_pitch;\n\tu32 num_crtcs;\n\t \n\tu32 full_vram_size;\n\t \n\tu32 available_vram_size;\n\t \n\tstruct vbva_modehint *last_mode_hints;\n\n\tint fb_mtrr;\n\n\tstruct mutex hw_mutex;  \n\tstruct work_struct hotplug_work;\n\tu32 input_mapping_width;\n\tu32 input_mapping_height;\n\t \n\tbool single_framebuffer;\n\tu8 cursor_data[CURSOR_DATA_SIZE];\n};\n\n#undef CURSOR_PIXEL_COUNT\n#undef CURSOR_DATA_SIZE\n\nstruct vbox_connector {\n\tstruct drm_connector base;\n\tchar name[32];\n\tstruct vbox_crtc *vbox_crtc;\n\tstruct {\n\t\tu32 width;\n\t\tu32 height;\n\t\tbool disconnected;\n\t} mode_hint;\n};\n\nstruct vbox_crtc {\n\tstruct drm_crtc base;\n\tbool disconnected;\n\tunsigned int crtc_id;\n\tu32 fb_offset;\n\tbool cursor_enabled;\n\tu32 x_hint;\n\tu32 y_hint;\n\t \n\tu32 width;\n\tu32 height;\n\tu32 x;\n\tu32 y;\n};\n\nstruct vbox_encoder {\n\tstruct drm_encoder base;\n};\n\n#define to_vbox_crtc(x) container_of(x, struct vbox_crtc, base)\n#define to_vbox_connector(x) container_of(x, struct vbox_connector, base)\n#define to_vbox_encoder(x) container_of(x, struct vbox_encoder, base)\n#define to_vbox_dev(x) container_of(x, struct vbox_private, ddev)\n\nbool vbox_check_supported(u16 id);\nint vbox_hw_init(struct vbox_private *vbox);\nvoid vbox_hw_fini(struct vbox_private *vbox);\n\nint vbox_mode_init(struct vbox_private *vbox);\nvoid vbox_mode_fini(struct vbox_private *vbox);\n\nvoid vbox_report_caps(struct vbox_private *vbox);\n\nint vbox_mm_init(struct vbox_private *vbox);\n\n \nint vbox_irq_init(struct vbox_private *vbox);\nvoid vbox_irq_fini(struct vbox_private *vbox);\nvoid vbox_report_hotplug(struct vbox_private *vbox);\n\n \nvoid *hgsmi_buffer_alloc(struct gen_pool *guest_pool, size_t size,\n\t\t\t u8 channel, u16 channel_info);\nvoid hgsmi_buffer_free(struct gen_pool *guest_pool, void *buf);\nint hgsmi_buffer_submit(struct gen_pool *guest_pool, void *buf);\n\nstatic inline void vbox_write_ioport(u16 index, u16 data)\n{\n\toutw(index, VBE_DISPI_IOPORT_INDEX);\n\toutw(data, VBE_DISPI_IOPORT_DATA);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}