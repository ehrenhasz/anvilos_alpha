{
  "module_name": "vbox_mode.c",
  "hash_id": "0728f389bfb75d8b7601d3fa85a718a6856469f0fb4dc0e6026e67748a13927a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vboxvideo/vbox_mode.c",
  "human_readable_source": "\n \n\n#include <linux/iosys-map.h>\n#include <linux/export.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"hgsmi_channels.h\"\n#include \"vbox_drv.h\"\n#include \"vboxvideo.h\"\n\n \nstatic void vbox_do_modeset(struct drm_crtc *crtc)\n{\n\tstruct drm_framebuffer *fb = crtc->primary->state->fb;\n\tstruct vbox_crtc *vbox_crtc = to_vbox_crtc(crtc);\n\tstruct vbox_private *vbox;\n\tint width, height, bpp, pitch;\n\tu16 flags;\n\ts32 x_offset, y_offset;\n\n\tvbox = to_vbox_dev(crtc->dev);\n\twidth = vbox_crtc->width ? vbox_crtc->width : 640;\n\theight = vbox_crtc->height ? vbox_crtc->height : 480;\n\tbpp = fb ? fb->format->cpp[0] * 8 : 32;\n\tpitch = fb ? fb->pitches[0] : width * bpp / 8;\n\tx_offset = vbox->single_framebuffer ? vbox_crtc->x : vbox_crtc->x_hint;\n\ty_offset = vbox->single_framebuffer ? vbox_crtc->y : vbox_crtc->y_hint;\n\n\t \n\tif (vbox_crtc->crtc_id == 0 && fb &&\n\t    vbox_crtc->fb_offset / pitch < 0xffff - crtc->y &&\n\t    vbox_crtc->fb_offset % (bpp / 8) == 0) {\n\t\tvbox_write_ioport(VBE_DISPI_INDEX_XRES, width);\n\t\tvbox_write_ioport(VBE_DISPI_INDEX_YRES, height);\n\t\tvbox_write_ioport(VBE_DISPI_INDEX_VIRT_WIDTH, pitch * 8 / bpp);\n\t\tvbox_write_ioport(VBE_DISPI_INDEX_BPP, bpp);\n\t\tvbox_write_ioport(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_ENABLED);\n\t\tvbox_write_ioport(VBE_DISPI_INDEX_X_OFFSET,\n\t\t\tvbox_crtc->fb_offset % pitch / bpp * 8 + vbox_crtc->x);\n\t\tvbox_write_ioport(VBE_DISPI_INDEX_Y_OFFSET,\n\t\t\t\t  vbox_crtc->fb_offset / pitch + vbox_crtc->y);\n\t}\n\n\tflags = VBVA_SCREEN_F_ACTIVE;\n\tflags |= (fb && crtc->state->enable) ? 0 : VBVA_SCREEN_F_BLANK;\n\tflags |= vbox_crtc->disconnected ? VBVA_SCREEN_F_DISABLED : 0;\n\thgsmi_process_display_info(vbox->guest_pool, vbox_crtc->crtc_id,\n\t\t\t\t   x_offset, y_offset,\n\t\t\t\t   vbox_crtc->x * bpp / 8 +\n\t\t\t\t\t\t\tvbox_crtc->y * pitch,\n\t\t\t\t   pitch, width, height, bpp, flags);\n}\n\nstatic int vbox_set_view(struct drm_crtc *crtc)\n{\n\tstruct vbox_crtc *vbox_crtc = to_vbox_crtc(crtc);\n\tstruct vbox_private *vbox = to_vbox_dev(crtc->dev);\n\tstruct vbva_infoview *p;\n\n\t \n\tp = hgsmi_buffer_alloc(vbox->guest_pool, sizeof(*p),\n\t\t\t       HGSMI_CH_VBVA, VBVA_INFO_VIEW);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->view_index = vbox_crtc->crtc_id;\n\tp->view_offset = vbox_crtc->fb_offset;\n\tp->view_size = vbox->available_vram_size - vbox_crtc->fb_offset +\n\t\t       vbox_crtc->crtc_id * VBVA_MIN_BUFFER_SIZE;\n\tp->max_screen_size = vbox->available_vram_size - vbox_crtc->fb_offset;\n\n\thgsmi_buffer_submit(vbox->guest_pool, p);\n\thgsmi_buffer_free(vbox->guest_pool, p);\n\n\treturn 0;\n}\n\n \nstatic bool vbox_set_up_input_mapping(struct vbox_private *vbox)\n{\n\tstruct drm_crtc *crtci;\n\tstruct drm_connector *connectori;\n\tstruct drm_framebuffer *fb, *fb1 = NULL;\n\tbool single_framebuffer = true;\n\tbool old_single_framebuffer = vbox->single_framebuffer;\n\tu16 width = 0, height = 0;\n\n\t \n\tlist_for_each_entry(crtci, &vbox->ddev.mode_config.crtc_list, head) {\n\t\tfb = crtci->primary->state->fb;\n\t\tif (!fb)\n\t\t\tcontinue;\n\n\t\tif (!fb1) {\n\t\t\tfb1 = fb;\n\t\t\tif (fb1 == vbox->ddev.fb_helper->fb)\n\t\t\t\tbreak;\n\t\t} else if (fb != fb1) {\n\t\t\tsingle_framebuffer = false;\n\t\t}\n\t}\n\tif (!fb1)\n\t\treturn false;\n\n\tif (single_framebuffer) {\n\t\tvbox->single_framebuffer = true;\n\t\tvbox->input_mapping_width = fb1->width;\n\t\tvbox->input_mapping_height = fb1->height;\n\t\treturn old_single_framebuffer != vbox->single_framebuffer;\n\t}\n\t \n\tlist_for_each_entry(connectori, &vbox->ddev.mode_config.connector_list,\n\t\t\t    head) {\n\t\tstruct vbox_connector *vbox_connector =\n\t\t    to_vbox_connector(connectori);\n\t\tstruct vbox_crtc *vbox_crtc = vbox_connector->vbox_crtc;\n\n\t\twidth = max_t(u16, width, vbox_crtc->x_hint +\n\t\t\t\t\t  vbox_connector->mode_hint.width);\n\t\theight = max_t(u16, height, vbox_crtc->y_hint +\n\t\t\t\t\t    vbox_connector->mode_hint.height);\n\t}\n\n\tvbox->single_framebuffer = false;\n\tvbox->input_mapping_width = width;\n\tvbox->input_mapping_height = height;\n\n\treturn old_single_framebuffer != vbox->single_framebuffer;\n}\n\nstatic void vbox_crtc_set_base_and_mode(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_framebuffer *fb,\n\t\t\t\t\tint x, int y)\n{\n\tstruct drm_gem_vram_object *gbo = drm_gem_vram_of_gem(fb->obj[0]);\n\tstruct vbox_private *vbox = to_vbox_dev(crtc->dev);\n\tstruct vbox_crtc *vbox_crtc = to_vbox_crtc(crtc);\n\tbool needs_modeset = drm_atomic_crtc_needs_modeset(crtc->state);\n\n\tmutex_lock(&vbox->hw_mutex);\n\n\tif (crtc->state->enable) {\n\t\tvbox_crtc->width = crtc->state->mode.hdisplay;\n\t\tvbox_crtc->height = crtc->state->mode.vdisplay;\n\t}\n\n\tvbox_crtc->x = x;\n\tvbox_crtc->y = y;\n\tvbox_crtc->fb_offset = drm_gem_vram_offset(gbo);\n\n\t \n\tif (needs_modeset && vbox_set_up_input_mapping(vbox)) {\n\t\tstruct drm_crtc *crtci;\n\n\t\tlist_for_each_entry(crtci, &vbox->ddev.mode_config.crtc_list,\n\t\t\t\t    head) {\n\t\t\tif (crtci == crtc)\n\t\t\t\tcontinue;\n\t\t\tvbox_do_modeset(crtci);\n\t\t}\n\t}\n\n\tvbox_set_view(crtc);\n\tvbox_do_modeset(crtc);\n\n\tif (needs_modeset)\n\t\thgsmi_update_input_mapping(vbox->guest_pool, 0, 0,\n\t\t\t\t\t   vbox->input_mapping_width,\n\t\t\t\t\t   vbox->input_mapping_height);\n\n\tmutex_unlock(&vbox->hw_mutex);\n}\n\nstatic void vbox_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n}\n\nstatic void vbox_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n}\n\nstatic void vbox_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n}\n\nstatic const struct drm_crtc_helper_funcs vbox_crtc_helper_funcs = {\n\t.atomic_enable = vbox_crtc_atomic_enable,\n\t.atomic_disable = vbox_crtc_atomic_disable,\n\t.atomic_flush = vbox_crtc_atomic_flush,\n};\n\nstatic void vbox_crtc_destroy(struct drm_crtc *crtc)\n{\n\tdrm_crtc_cleanup(crtc);\n\tkfree(crtc);\n}\n\nstatic const struct drm_crtc_funcs vbox_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t \n\t.destroy = vbox_crtc_destroy,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n};\n\nstatic int vbox_primary_atomic_check(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_crtc_state *crtc_state = NULL;\n\n\tif (new_state->crtc) {\n\t\tcrtc_state = drm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t\t\tnew_state->crtc);\n\t\tif (WARN_ON(!crtc_state))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn drm_atomic_helper_check_plane_state(new_state, crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   false, true);\n}\n\nstatic void vbox_primary_atomic_update(struct drm_plane *plane,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_crtc *crtc = new_state->crtc;\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct vbox_private *vbox = to_vbox_dev(fb->dev);\n\tstruct drm_mode_rect *clips;\n\tuint32_t num_clips, i;\n\n\tvbox_crtc_set_base_and_mode(crtc, fb,\n\t\t\t\t    new_state->src_x >> 16,\n\t\t\t\t    new_state->src_y >> 16);\n\n\t \n\n\tclips = drm_plane_get_damage_clips(new_state);\n\tnum_clips = drm_plane_get_damage_clips_count(new_state);\n\n\tif (!num_clips)\n\t\treturn;\n\n\tmutex_lock(&vbox->hw_mutex);\n\n\tfor (i = 0; i < num_clips; ++i, ++clips) {\n\t\tstruct vbva_cmd_hdr cmd_hdr;\n\t\tunsigned int crtc_id = to_vbox_crtc(crtc)->crtc_id;\n\n\t\tcmd_hdr.x = (s16)clips->x1;\n\t\tcmd_hdr.y = (s16)clips->y1;\n\t\tcmd_hdr.w = (u16)clips->x2 - clips->x1;\n\t\tcmd_hdr.h = (u16)clips->y2 - clips->y1;\n\n\t\tif (!vbva_buffer_begin_update(&vbox->vbva_info[crtc_id],\n\t\t\t\t\t      vbox->guest_pool))\n\t\t\tcontinue;\n\n\t\tvbva_write(&vbox->vbva_info[crtc_id], vbox->guest_pool,\n\t\t\t   &cmd_hdr, sizeof(cmd_hdr));\n\t\tvbva_buffer_end_update(&vbox->vbva_info[crtc_id]);\n\t}\n\n\tmutex_unlock(&vbox->hw_mutex);\n}\n\nstatic void vbox_primary_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_crtc *crtc = old_state->crtc;\n\n\t \n\tvbox_crtc_set_base_and_mode(crtc, old_state->fb,\n\t\t\t\t    old_state->src_x >> 16,\n\t\t\t\t    old_state->src_y >> 16);\n}\n\nstatic int vbox_cursor_atomic_check(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_crtc_state *crtc_state = NULL;\n\tu32 width = new_state->crtc_w;\n\tu32 height = new_state->crtc_h;\n\tint ret;\n\n\tif (new_state->crtc) {\n\t\tcrtc_state = drm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t\t\tnew_state->crtc);\n\t\tif (WARN_ON(!crtc_state))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = drm_atomic_helper_check_plane_state(new_state, crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  true, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!new_state->fb)\n\t\treturn 0;\n\n\tif (width > VBOX_MAX_CURSOR_WIDTH || height > VBOX_MAX_CURSOR_HEIGHT ||\n\t    width == 0 || height == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic void copy_cursor_image(u8 *src, u8 *dst, u32 width, u32 height,\n\t\t\t      size_t mask_size)\n{\n\tsize_t line_size = (width + 7) / 8;\n\tu32 i, j;\n\n\tmemcpy(dst + mask_size, src, width * height * 4);\n\tfor (i = 0; i < height; ++i)\n\t\tfor (j = 0; j < width; ++j)\n\t\t\tif (((u32 *)src)[i * width + j] > 0xf0000000)\n\t\t\t\tdst[i * line_size + j / 8] |= (0x80 >> (j % 8));\n}\n\nstatic void vbox_cursor_atomic_update(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct vbox_private *vbox =\n\t\tcontainer_of(plane->dev, struct vbox_private, ddev);\n\tstruct vbox_crtc *vbox_crtc = to_vbox_crtc(new_state->crtc);\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tu32 width = new_state->crtc_w;\n\tu32 height = new_state->crtc_h;\n\tstruct drm_shadow_plane_state *shadow_plane_state =\n\t\tto_drm_shadow_plane_state(new_state);\n\tstruct iosys_map map = shadow_plane_state->data[0];\n\tu8 *src = map.vaddr;  \n\tsize_t data_size, mask_size;\n\tu32 flags;\n\n\t \n\tif (fb == old_state->fb)\n\t\treturn;\n\n\tmutex_lock(&vbox->hw_mutex);\n\n\tvbox_crtc->cursor_enabled = true;\n\n\t \n\tmask_size = ((width + 7) / 8 * height + 3) & ~3;\n\tdata_size = width * height * 4 + mask_size;\n\n\tcopy_cursor_image(src, vbox->cursor_data, width, height, mask_size);\n\n\tflags = VBOX_MOUSE_POINTER_VISIBLE | VBOX_MOUSE_POINTER_SHAPE |\n\t\tVBOX_MOUSE_POINTER_ALPHA;\n\thgsmi_update_pointer_shape(vbox->guest_pool, flags,\n\t\t\t\t   min_t(u32, max(fb->hot_x, 0), width),\n\t\t\t\t   min_t(u32, max(fb->hot_y, 0), height),\n\t\t\t\t   width, height, vbox->cursor_data, data_size);\n\n\tmutex_unlock(&vbox->hw_mutex);\n}\n\nstatic void vbox_cursor_atomic_disable(struct drm_plane *plane,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct vbox_private *vbox =\n\t\tcontainer_of(plane->dev, struct vbox_private, ddev);\n\tstruct vbox_crtc *vbox_crtc = to_vbox_crtc(old_state->crtc);\n\tbool cursor_enabled = false;\n\tstruct drm_crtc *crtci;\n\n\tmutex_lock(&vbox->hw_mutex);\n\n\tvbox_crtc->cursor_enabled = false;\n\n\tlist_for_each_entry(crtci, &vbox->ddev.mode_config.crtc_list, head) {\n\t\tif (to_vbox_crtc(crtci)->cursor_enabled)\n\t\t\tcursor_enabled = true;\n\t}\n\n\tif (!cursor_enabled)\n\t\thgsmi_update_pointer_shape(vbox->guest_pool, 0, 0, 0,\n\t\t\t\t\t   0, 0, NULL, 0);\n\n\tmutex_unlock(&vbox->hw_mutex);\n}\n\nstatic const u32 vbox_cursor_plane_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic const struct drm_plane_helper_funcs vbox_cursor_helper_funcs = {\n\t.atomic_check\t= vbox_cursor_atomic_check,\n\t.atomic_update\t= vbox_cursor_atomic_update,\n\t.atomic_disable\t= vbox_cursor_atomic_disable,\n\tDRM_GEM_SHADOW_PLANE_HELPER_FUNCS,\n};\n\nstatic const struct drm_plane_funcs vbox_cursor_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy\t= drm_plane_helper_destroy,\n\tDRM_GEM_SHADOW_PLANE_FUNCS,\n};\n\nstatic const u32 vbox_primary_plane_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic const struct drm_plane_helper_funcs vbox_primary_helper_funcs = {\n\t.atomic_check = vbox_primary_atomic_check,\n\t.atomic_update = vbox_primary_atomic_update,\n\t.atomic_disable = vbox_primary_atomic_disable,\n\tDRM_GEM_VRAM_PLANE_HELPER_FUNCS,\n};\n\nstatic const struct drm_plane_funcs vbox_primary_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy\t= drm_plane_helper_destroy,\n\t.reset\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n};\n\nstatic struct drm_plane *vbox_create_plane(struct vbox_private *vbox,\n\t\t\t\t\t   unsigned int possible_crtcs,\n\t\t\t\t\t   enum drm_plane_type type)\n{\n\tconst struct drm_plane_helper_funcs *helper_funcs = NULL;\n\tconst struct drm_plane_funcs *funcs;\n\tstruct drm_plane *plane;\n\tconst u32 *formats;\n\tint num_formats;\n\tint err;\n\n\tif (type == DRM_PLANE_TYPE_PRIMARY) {\n\t\tfuncs = &vbox_primary_plane_funcs;\n\t\tformats = vbox_primary_plane_formats;\n\t\thelper_funcs = &vbox_primary_helper_funcs;\n\t\tnum_formats = ARRAY_SIZE(vbox_primary_plane_formats);\n\t} else if (type == DRM_PLANE_TYPE_CURSOR) {\n\t\tfuncs = &vbox_cursor_plane_funcs;\n\t\tformats = vbox_cursor_plane_formats;\n\t\thelper_funcs = &vbox_cursor_helper_funcs;\n\t\tnum_formats = ARRAY_SIZE(vbox_cursor_plane_formats);\n\t} else {\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tplane = kzalloc(sizeof(*plane), GFP_KERNEL);\n\tif (!plane)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = drm_universal_plane_init(&vbox->ddev, plane, possible_crtcs,\n\t\t\t\t       funcs, formats, num_formats,\n\t\t\t\t       NULL, type, NULL);\n\tif (err)\n\t\tgoto free_plane;\n\n\tdrm_plane_helper_add(plane, helper_funcs);\n\n\treturn plane;\n\nfree_plane:\n\tkfree(plane);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct vbox_crtc *vbox_crtc_init(struct drm_device *dev, unsigned int i)\n{\n\tstruct vbox_private *vbox =\n\t\tcontainer_of(dev, struct vbox_private, ddev);\n\tstruct drm_plane *cursor = NULL;\n\tstruct vbox_crtc *vbox_crtc;\n\tstruct drm_plane *primary;\n\tu32 caps = 0;\n\tint ret;\n\n\tret = hgsmi_query_conf(vbox->guest_pool,\n\t\t\t       VBOX_VBVA_CONF32_CURSOR_CAPABILITIES, &caps);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tvbox_crtc = kzalloc(sizeof(*vbox_crtc), GFP_KERNEL);\n\tif (!vbox_crtc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tprimary = vbox_create_plane(vbox, 1 << i, DRM_PLANE_TYPE_PRIMARY);\n\tif (IS_ERR(primary)) {\n\t\tret = PTR_ERR(primary);\n\t\tgoto free_mem;\n\t}\n\n\tif ((caps & VBOX_VBVA_CURSOR_CAPABILITY_HARDWARE)) {\n\t\tcursor = vbox_create_plane(vbox, 1 << i, DRM_PLANE_TYPE_CURSOR);\n\t\tif (IS_ERR(cursor)) {\n\t\t\tret = PTR_ERR(cursor);\n\t\t\tgoto clean_primary;\n\t\t}\n\t} else {\n\t\tDRM_WARN(\"VirtualBox host is too old, no cursor support\\n\");\n\t}\n\n\tvbox_crtc->crtc_id = i;\n\n\tret = drm_crtc_init_with_planes(dev, &vbox_crtc->base, primary, cursor,\n\t\t\t\t\t&vbox_crtc_funcs, NULL);\n\tif (ret)\n\t\tgoto clean_cursor;\n\n\tdrm_mode_crtc_set_gamma_size(&vbox_crtc->base, 256);\n\tdrm_crtc_helper_add(&vbox_crtc->base, &vbox_crtc_helper_funcs);\n\n\treturn vbox_crtc;\n\nclean_cursor:\n\tif (cursor) {\n\t\tdrm_plane_cleanup(cursor);\n\t\tkfree(cursor);\n\t}\nclean_primary:\n\tdrm_plane_cleanup(primary);\n\tkfree(primary);\nfree_mem:\n\tkfree(vbox_crtc);\n\treturn ERR_PTR(ret);\n}\n\nstatic void vbox_encoder_destroy(struct drm_encoder *encoder)\n{\n\tdrm_encoder_cleanup(encoder);\n\tkfree(encoder);\n}\n\nstatic const struct drm_encoder_funcs vbox_enc_funcs = {\n\t.destroy = vbox_encoder_destroy,\n};\n\nstatic struct drm_encoder *vbox_encoder_init(struct drm_device *dev,\n\t\t\t\t\t     unsigned int i)\n{\n\tstruct vbox_encoder *vbox_encoder;\n\n\tvbox_encoder = kzalloc(sizeof(*vbox_encoder), GFP_KERNEL);\n\tif (!vbox_encoder)\n\t\treturn NULL;\n\n\tdrm_encoder_init(dev, &vbox_encoder->base, &vbox_enc_funcs,\n\t\t\t DRM_MODE_ENCODER_DAC, NULL);\n\n\tvbox_encoder->base.possible_crtcs = 1 << i;\n\treturn &vbox_encoder->base;\n}\n\n \nstatic void vbox_set_edid(struct drm_connector *connector, int width,\n\t\t\t  int height)\n{\n\tenum { EDID_SIZE = 128 };\n\tunsigned char edid[EDID_SIZE] = {\n\t\t0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,\t \n\t\t0x58, 0x58,\t \n\t\t0x00, 0x00,\t \n\t\t0x00, 0x00, 0x00, 0x00,\t \n\t\t0x01,\t\t \n\t\t0x00,\t\t \n\t\t0x01, 0x03,\t \n\t\t0x80,\t\t \n\t\t0x00,\t\t \n\t\t0x00,\t\t \n\t\t0x78,\t\t \n\t\t0xEE,\t\t \n\t\t\t\t \n\t\t0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26, 0x0F, 0x50, 0x54,\n\t\t \n\t\t0x00, 0x00, 0x00,\t \n\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n\t\t    0x01, 0x01,\n\t\t0x01, 0x01, 0x01, 0x01,\t \n\t\t0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x00, 0x02, 0x02,\n\t\t    0x02, 0x02,\n\t\t \n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t \n\t\t0x00, 0x00, 0x00, 0xFD, 0x00,\n\t\t0x00, 0xC8, 0x00, 0xC8, 0x64, 0x00, 0x0A, 0x20, 0x20, 0x20,\n\t\t    0x20, 0x20,\n\t\t \n\t\t0x20,\n\t\t \n\t\t0x00, 0x00, 0x00, 0xFC, 0x00,\n\t\t'V', 'B', 'O', 'X', ' ', 'm', 'o', 'n', 'i', 't', 'o', 'r',\n\t\t'\\n',\n\t\t \n\t\t0x00, 0x00, 0x00, 0x10, 0x00,\n\t\t0x0A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t0x20,\n\t\t0x00,\t\t \n\t\t0x00\t\t \n\t};\n\tint clock = (width + 6) * (height + 6) * 60 / 10000;\n\tunsigned int i, sum = 0;\n\n\tedid[12] = width & 0xff;\n\tedid[13] = width >> 8;\n\tedid[14] = height & 0xff;\n\tedid[15] = height >> 8;\n\tedid[54] = clock & 0xff;\n\tedid[55] = clock >> 8;\n\tedid[56] = width & 0xff;\n\tedid[58] = (width >> 4) & 0xf0;\n\tedid[59] = height & 0xff;\n\tedid[61] = (height >> 4) & 0xf0;\n\tfor (i = 0; i < EDID_SIZE - 1; ++i)\n\t\tsum += edid[i];\n\tedid[EDID_SIZE - 1] = (0x100 - (sum & 0xFF)) & 0xFF;\n\tdrm_connector_update_edid_property(connector, (struct edid *)edid);\n}\n\nstatic int vbox_get_modes(struct drm_connector *connector)\n{\n\tstruct vbox_connector *vbox_connector = NULL;\n\tstruct drm_display_mode *mode = NULL;\n\tstruct vbox_private *vbox = NULL;\n\tunsigned int num_modes = 0;\n\tint preferred_width, preferred_height;\n\n\tvbox_connector = to_vbox_connector(connector);\n\tvbox = to_vbox_dev(connector->dev);\n\n\thgsmi_report_flags_location(vbox->guest_pool, GUEST_HEAP_OFFSET(vbox) +\n\t\t\t\t    HOST_FLAGS_OFFSET);\n\tif (vbox_connector->vbox_crtc->crtc_id == 0)\n\t\tvbox_report_caps(vbox);\n\n\tnum_modes = drm_add_modes_noedid(connector, 2560, 1600);\n\tpreferred_width = vbox_connector->mode_hint.width ?\n\t\t\t  vbox_connector->mode_hint.width : 1024;\n\tpreferred_height = vbox_connector->mode_hint.height ?\n\t\t\t   vbox_connector->mode_hint.height : 768;\n\tmode = drm_cvt_mode(connector->dev, preferred_width, preferred_height,\n\t\t\t    60, false, false, false);\n\tif (mode) {\n\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\t\tdrm_mode_probed_add(connector, mode);\n\t\t++num_modes;\n\t}\n\tvbox_set_edid(connector, preferred_width, preferred_height);\n\n\tif (vbox_connector->vbox_crtc->x_hint != -1)\n\t\tdrm_object_property_set_value(&connector->base,\n\t\t\tvbox->ddev.mode_config.suggested_x_property,\n\t\t\tvbox_connector->vbox_crtc->x_hint);\n\telse\n\t\tdrm_object_property_set_value(&connector->base,\n\t\t\tvbox->ddev.mode_config.suggested_x_property, 0);\n\n\tif (vbox_connector->vbox_crtc->y_hint != -1)\n\t\tdrm_object_property_set_value(&connector->base,\n\t\t\tvbox->ddev.mode_config.suggested_y_property,\n\t\t\tvbox_connector->vbox_crtc->y_hint);\n\telse\n\t\tdrm_object_property_set_value(&connector->base,\n\t\t\tvbox->ddev.mode_config.suggested_y_property, 0);\n\n\treturn num_modes;\n}\n\nstatic void vbox_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n\tkfree(connector);\n}\n\nstatic enum drm_connector_status\nvbox_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct vbox_connector *vbox_connector;\n\n\tvbox_connector = to_vbox_connector(connector);\n\n\treturn vbox_connector->mode_hint.disconnected ?\n\t    connector_status_disconnected : connector_status_connected;\n}\n\nstatic int vbox_fill_modes(struct drm_connector *connector, u32 max_x,\n\t\t\t   u32 max_y)\n{\n\tstruct vbox_connector *vbox_connector;\n\tstruct drm_device *dev;\n\tstruct drm_display_mode *mode, *iterator;\n\n\tvbox_connector = to_vbox_connector(connector);\n\tdev = vbox_connector->base.dev;\n\tlist_for_each_entry_safe(mode, iterator, &connector->modes, head) {\n\t\tlist_del(&mode->head);\n\t\tdrm_mode_destroy(dev, mode);\n\t}\n\n\treturn drm_helper_probe_single_connector_modes(connector, max_x, max_y);\n}\n\nstatic const struct drm_connector_helper_funcs vbox_connector_helper_funcs = {\n\t.get_modes = vbox_get_modes,\n};\n\nstatic const struct drm_connector_funcs vbox_connector_funcs = {\n\t.detect = vbox_connector_detect,\n\t.fill_modes = vbox_fill_modes,\n\t.destroy = vbox_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int vbox_connector_init(struct drm_device *dev,\n\t\t\t       struct vbox_crtc *vbox_crtc,\n\t\t\t       struct drm_encoder *encoder)\n{\n\tstruct vbox_connector *vbox_connector;\n\tstruct drm_connector *connector;\n\n\tvbox_connector = kzalloc(sizeof(*vbox_connector), GFP_KERNEL);\n\tif (!vbox_connector)\n\t\treturn -ENOMEM;\n\n\tconnector = &vbox_connector->base;\n\tvbox_connector->vbox_crtc = vbox_crtc;\n\n\tdrm_connector_init(dev, connector, &vbox_connector_funcs,\n\t\t\t   DRM_MODE_CONNECTOR_VGA);\n\tdrm_connector_helper_add(connector, &vbox_connector_helper_funcs);\n\n\tconnector->interlace_allowed = 0;\n\tconnector->doublescan_allowed = 0;\n\n\tdrm_mode_create_suggested_offset_properties(dev);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.suggested_x_property, 0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.suggested_y_property, 0);\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\treturn 0;\n}\n\nstatic const struct drm_mode_config_funcs vbox_mode_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.mode_valid = drm_vram_helper_mode_valid,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nint vbox_mode_init(struct vbox_private *vbox)\n{\n\tstruct drm_device *dev = &vbox->ddev;\n\tstruct drm_encoder *encoder;\n\tstruct vbox_crtc *vbox_crtc;\n\tunsigned int i;\n\tint ret;\n\n\tdrm_mode_config_init(dev);\n\n\tdev->mode_config.funcs = (void *)&vbox_mode_funcs;\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tdev->mode_config.preferred_depth = 24;\n\tdev->mode_config.max_width = VBE_DISPI_MAX_XRES;\n\tdev->mode_config.max_height = VBE_DISPI_MAX_YRES;\n\n\tfor (i = 0; i < vbox->num_crtcs; ++i) {\n\t\tvbox_crtc = vbox_crtc_init(dev, i);\n\t\tif (IS_ERR(vbox_crtc)) {\n\t\t\tret = PTR_ERR(vbox_crtc);\n\t\t\tgoto err_drm_mode_cleanup;\n\t\t}\n\t\tencoder = vbox_encoder_init(dev, i);\n\t\tif (!encoder) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_drm_mode_cleanup;\n\t\t}\n\t\tret = vbox_connector_init(dev, vbox_crtc, encoder);\n\t\tif (ret)\n\t\t\tgoto err_drm_mode_cleanup;\n\t}\n\n\tdrm_mode_config_reset(dev);\n\treturn 0;\n\nerr_drm_mode_cleanup:\n\tdrm_mode_config_cleanup(dev);\n\treturn ret;\n}\n\nvoid vbox_mode_fini(struct vbox_private *vbox)\n{\n\tdrm_mode_config_cleanup(&vbox->ddev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}