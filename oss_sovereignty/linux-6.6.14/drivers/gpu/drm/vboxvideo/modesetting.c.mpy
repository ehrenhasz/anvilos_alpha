{
  "module_name": "modesetting.c",
  "hash_id": "148189135bff8c2aea56347a39d5ec3b939c7a12d5aaa177a22c3191aa6ad4b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vboxvideo/modesetting.c",
  "human_readable_source": "\n \n\n#include <linux/vbox_err.h>\n#include \"vbox_drv.h\"\n#include \"vboxvideo_guest.h\"\n#include \"vboxvideo_vbe.h\"\n#include \"hgsmi_channels.h\"\n\n \nvoid hgsmi_process_display_info(struct gen_pool *ctx, u32 display,\n\t\t\t\ts32 origin_x, s32 origin_y, u32 start_offset,\n\t\t\t\tu32 pitch, u32 width, u32 height,\n\t\t\t\tu16 bpp, u16 flags)\n{\n\tstruct vbva_infoscreen *p;\n\n\tp = hgsmi_buffer_alloc(ctx, sizeof(*p), HGSMI_CH_VBVA,\n\t\t\t       VBVA_INFO_SCREEN);\n\tif (!p)\n\t\treturn;\n\n\tp->view_index = display;\n\tp->origin_x = origin_x;\n\tp->origin_y = origin_y;\n\tp->start_offset = start_offset;\n\tp->line_size = pitch;\n\tp->width = width;\n\tp->height = height;\n\tp->bits_per_pixel = bpp;\n\tp->flags = flags;\n\n\thgsmi_buffer_submit(ctx, p);\n\thgsmi_buffer_free(ctx, p);\n}\n\n \nint hgsmi_update_input_mapping(struct gen_pool *ctx, s32 origin_x, s32 origin_y,\n\t\t\t       u32 width, u32 height)\n{\n\tstruct vbva_report_input_mapping *p;\n\n\tp = hgsmi_buffer_alloc(ctx, sizeof(*p), HGSMI_CH_VBVA,\n\t\t\t       VBVA_REPORT_INPUT_MAPPING);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->x = origin_x;\n\tp->y = origin_y;\n\tp->cx = width;\n\tp->cy = height;\n\n\thgsmi_buffer_submit(ctx, p);\n\thgsmi_buffer_free(ctx, p);\n\n\treturn 0;\n}\n\n \nint hgsmi_get_mode_hints(struct gen_pool *ctx, unsigned int screens,\n\t\t\t struct vbva_modehint *hints)\n{\n\tstruct vbva_query_mode_hints *p;\n\tsize_t size;\n\n\tif (WARN_ON(!hints))\n\t\treturn -EINVAL;\n\n\tsize = screens * sizeof(struct vbva_modehint);\n\tp = hgsmi_buffer_alloc(ctx, sizeof(*p) + size, HGSMI_CH_VBVA,\n\t\t\t       VBVA_QUERY_MODE_HINTS);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->hints_queried_count = screens;\n\tp->hint_structure_guest_size = sizeof(struct vbva_modehint);\n\tp->rc = VERR_NOT_SUPPORTED;\n\n\thgsmi_buffer_submit(ctx, p);\n\n\tif (p->rc < 0) {\n\t\thgsmi_buffer_free(ctx, p);\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(hints, ((u8 *)p) + sizeof(struct vbva_query_mode_hints), size);\n\thgsmi_buffer_free(ctx, p);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}