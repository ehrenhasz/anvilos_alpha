{
  "module_name": "vbox_main.c",
  "hash_id": "81b68afe9755b1ab328fa45f4e3af14f92f92f0c8d12952e3e825d557678d1d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vboxvideo/vbox_main.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/vbox_err.h>\n\n#include <drm/drm_damage_helper.h>\n\n#include \"vbox_drv.h\"\n#include \"vboxvideo_guest.h\"\n#include \"vboxvideo_vbe.h\"\n\nvoid vbox_report_caps(struct vbox_private *vbox)\n{\n\tu32 caps = VBVACAPS_DISABLE_CURSOR_INTEGRATION |\n\t\t   VBVACAPS_IRQ | VBVACAPS_USE_VBVA_ONLY;\n\n\t \n\thgsmi_send_caps_info(vbox->guest_pool, caps);\n\tcaps |= VBVACAPS_VIDEO_MODE_HINTS;\n\thgsmi_send_caps_info(vbox->guest_pool, caps);\n}\n\nstatic int vbox_accel_init(struct vbox_private *vbox)\n{\n\tstruct pci_dev *pdev = to_pci_dev(vbox->ddev.dev);\n\tstruct vbva_buffer *vbva;\n\tunsigned int i;\n\n\tvbox->vbva_info = devm_kcalloc(vbox->ddev.dev, vbox->num_crtcs,\n\t\t\t\t       sizeof(*vbox->vbva_info), GFP_KERNEL);\n\tif (!vbox->vbva_info)\n\t\treturn -ENOMEM;\n\n\t \n\tvbox->available_vram_size -= vbox->num_crtcs * VBVA_MIN_BUFFER_SIZE;\n\n\tvbox->vbva_buffers = pci_iomap_range(pdev, 0,\n\t\t\t\t\t     vbox->available_vram_size,\n\t\t\t\t\t     vbox->num_crtcs *\n\t\t\t\t\t     VBVA_MIN_BUFFER_SIZE);\n\tif (!vbox->vbva_buffers)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < vbox->num_crtcs; ++i) {\n\t\tvbva_setup_buffer_context(&vbox->vbva_info[i],\n\t\t\t\t\t  vbox->available_vram_size +\n\t\t\t\t\t  i * VBVA_MIN_BUFFER_SIZE,\n\t\t\t\t\t  VBVA_MIN_BUFFER_SIZE);\n\t\tvbva = (void __force *)vbox->vbva_buffers +\n\t\t\ti * VBVA_MIN_BUFFER_SIZE;\n\t\tif (!vbva_enable(&vbox->vbva_info[i],\n\t\t\t\t vbox->guest_pool, vbva, i)) {\n\t\t\t \n\t\t\tDRM_ERROR(\"vboxvideo: vbva_enable failed\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void vbox_accel_fini(struct vbox_private *vbox)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < vbox->num_crtcs; ++i)\n\t\tvbva_disable(&vbox->vbva_info[i], vbox->guest_pool, i);\n}\n\n \nstatic bool have_hgsmi_mode_hints(struct vbox_private *vbox)\n{\n\tu32 have_hints, have_cursor;\n\tint ret;\n\n\tret = hgsmi_query_conf(vbox->guest_pool,\n\t\t\t       VBOX_VBVA_CONF32_MODE_HINT_REPORTING,\n\t\t\t       &have_hints);\n\tif (ret)\n\t\treturn false;\n\n\tret = hgsmi_query_conf(vbox->guest_pool,\n\t\t\t       VBOX_VBVA_CONF32_GUEST_CURSOR_REPORTING,\n\t\t\t       &have_cursor);\n\tif (ret)\n\t\treturn false;\n\n\treturn have_hints == VINF_SUCCESS && have_cursor == VINF_SUCCESS;\n}\n\nbool vbox_check_supported(u16 id)\n{\n\tu16 dispi_id;\n\n\tvbox_write_ioport(VBE_DISPI_INDEX_ID, id);\n\tdispi_id = inw(VBE_DISPI_IOPORT_DATA);\n\n\treturn dispi_id == id;\n}\n\nint vbox_hw_init(struct vbox_private *vbox)\n{\n\tstruct pci_dev *pdev = to_pci_dev(vbox->ddev.dev);\n\tint ret = -ENOMEM;\n\n\tvbox->full_vram_size = inl(VBE_DISPI_IOPORT_DATA);\n\tvbox->any_pitch = vbox_check_supported(VBE_DISPI_ID_ANYX);\n\n\tDRM_INFO(\"VRAM %08x\\n\", vbox->full_vram_size);\n\n\t \n\tvbox->guest_heap =\n\t    pci_iomap_range(pdev, 0, GUEST_HEAP_OFFSET(vbox),\n\t\t\t    GUEST_HEAP_SIZE);\n\tif (!vbox->guest_heap)\n\t\treturn -ENOMEM;\n\n\t \n\tvbox->guest_pool = devm_gen_pool_create(vbox->ddev.dev, 4, -1,\n\t\t\t\t\t\t\"vboxvideo-accel\");\n\tif (IS_ERR(vbox->guest_pool))\n\t\treturn PTR_ERR(vbox->guest_pool);\n\n\tret = gen_pool_add_virt(vbox->guest_pool,\n\t\t\t\t(unsigned long)vbox->guest_heap,\n\t\t\t\tGUEST_HEAP_OFFSET(vbox),\n\t\t\t\tGUEST_HEAP_USABLE_SIZE, -1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hgsmi_test_query_conf(vbox->guest_pool);\n\tif (ret) {\n\t\tDRM_ERROR(\"vboxvideo: hgsmi_test_query_conf failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tvbox->available_vram_size = GUEST_HEAP_OFFSET(vbox);\n\t \n\thgsmi_query_conf(vbox->guest_pool, VBOX_VBVA_CONF32_MONITOR_COUNT,\n\t\t\t &vbox->num_crtcs);\n\tvbox->num_crtcs = clamp_t(u32, vbox->num_crtcs, 1, VBOX_MAX_SCREENS);\n\n\tif (!have_hgsmi_mode_hints(vbox)) {\n\t\tret = -ENOTSUPP;\n\t\treturn ret;\n\t}\n\n\tvbox->last_mode_hints = devm_kcalloc(vbox->ddev.dev, vbox->num_crtcs,\n\t\t\t\t\t     sizeof(struct vbva_modehint),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!vbox->last_mode_hints)\n\t\treturn -ENOMEM;\n\n\tret = vbox_accel_init(vbox);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nvoid vbox_hw_fini(struct vbox_private *vbox)\n{\n\tvbox_accel_fini(vbox);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}