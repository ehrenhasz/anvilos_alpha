{
  "module_name": "lima_device.c",
  "hash_id": "137e0ef050fe22e864e10863721379ffa867b6940c4dc5f42a4417eed4c0fb37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/lima/lima_device.c",
  "human_readable_source": "\n \n\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n\n#include \"lima_device.h\"\n#include \"lima_gp.h\"\n#include \"lima_pp.h\"\n#include \"lima_mmu.h\"\n#include \"lima_pmu.h\"\n#include \"lima_l2_cache.h\"\n#include \"lima_dlbu.h\"\n#include \"lima_bcast.h\"\n#include \"lima_vm.h\"\n\nstruct lima_ip_desc {\n\tchar *name;\n\tchar *irq_name;\n\tbool must_have[lima_gpu_num];\n\tint offset[lima_gpu_num];\n\n\tint (*init)(struct lima_ip *ip);\n\tvoid (*fini)(struct lima_ip *ip);\n\tint (*resume)(struct lima_ip *ip);\n\tvoid (*suspend)(struct lima_ip *ip);\n};\n\n#define LIMA_IP_DESC(ipname, mst0, mst1, off0, off1, func, irq) \\\n\t[lima_ip_##ipname] = { \\\n\t\t.name = #ipname, \\\n\t\t.irq_name = irq, \\\n\t\t.must_have = { \\\n\t\t\t[lima_gpu_mali400] = mst0, \\\n\t\t\t[lima_gpu_mali450] = mst1, \\\n\t\t}, \\\n\t\t.offset = { \\\n\t\t\t[lima_gpu_mali400] = off0, \\\n\t\t\t[lima_gpu_mali450] = off1, \\\n\t\t}, \\\n\t\t.init = lima_##func##_init, \\\n\t\t.fini = lima_##func##_fini, \\\n\t\t.resume = lima_##func##_resume, \\\n\t\t.suspend = lima_##func##_suspend, \\\n\t}\n\nstatic struct lima_ip_desc lima_ip_desc[lima_ip_num] = {\n\tLIMA_IP_DESC(pmu,         false, false, 0x02000, 0x02000, pmu,      \"pmu\"),\n\tLIMA_IP_DESC(l2_cache0,   true,  true,  0x01000, 0x10000, l2_cache, NULL),\n\tLIMA_IP_DESC(l2_cache1,   false, true,  -1,      0x01000, l2_cache, NULL),\n\tLIMA_IP_DESC(l2_cache2,   false, false, -1,      0x11000, l2_cache, NULL),\n\tLIMA_IP_DESC(gp,          true,  true,  0x00000, 0x00000, gp,       \"gp\"),\n\tLIMA_IP_DESC(pp0,         true,  true,  0x08000, 0x08000, pp,       \"pp0\"),\n\tLIMA_IP_DESC(pp1,         false, false, 0x0A000, 0x0A000, pp,       \"pp1\"),\n\tLIMA_IP_DESC(pp2,         false, false, 0x0C000, 0x0C000, pp,       \"pp2\"),\n\tLIMA_IP_DESC(pp3,         false, false, 0x0E000, 0x0E000, pp,       \"pp3\"),\n\tLIMA_IP_DESC(pp4,         false, false, -1,      0x28000, pp,       \"pp4\"),\n\tLIMA_IP_DESC(pp5,         false, false, -1,      0x2A000, pp,       \"pp5\"),\n\tLIMA_IP_DESC(pp6,         false, false, -1,      0x2C000, pp,       \"pp6\"),\n\tLIMA_IP_DESC(pp7,         false, false, -1,      0x2E000, pp,       \"pp7\"),\n\tLIMA_IP_DESC(gpmmu,       true,  true,  0x03000, 0x03000, mmu,      \"gpmmu\"),\n\tLIMA_IP_DESC(ppmmu0,      true,  true,  0x04000, 0x04000, mmu,      \"ppmmu0\"),\n\tLIMA_IP_DESC(ppmmu1,      false, false, 0x05000, 0x05000, mmu,      \"ppmmu1\"),\n\tLIMA_IP_DESC(ppmmu2,      false, false, 0x06000, 0x06000, mmu,      \"ppmmu2\"),\n\tLIMA_IP_DESC(ppmmu3,      false, false, 0x07000, 0x07000, mmu,      \"ppmmu3\"),\n\tLIMA_IP_DESC(ppmmu4,      false, false, -1,      0x1C000, mmu,      \"ppmmu4\"),\n\tLIMA_IP_DESC(ppmmu5,      false, false, -1,      0x1D000, mmu,      \"ppmmu5\"),\n\tLIMA_IP_DESC(ppmmu6,      false, false, -1,      0x1E000, mmu,      \"ppmmu6\"),\n\tLIMA_IP_DESC(ppmmu7,      false, false, -1,      0x1F000, mmu,      \"ppmmu7\"),\n\tLIMA_IP_DESC(dlbu,        false, true,  -1,      0x14000, dlbu,     NULL),\n\tLIMA_IP_DESC(bcast,       false, true,  -1,      0x13000, bcast,    NULL),\n\tLIMA_IP_DESC(pp_bcast,    false, true,  -1,      0x16000, pp_bcast, \"pp\"),\n\tLIMA_IP_DESC(ppmmu_bcast, false, true,  -1,      0x15000, mmu,      NULL),\n};\n\nconst char *lima_ip_name(struct lima_ip *ip)\n{\n\treturn lima_ip_desc[ip->id].name;\n}\n\nstatic int lima_clk_enable(struct lima_device *dev)\n{\n\tint err;\n\n\terr = clk_prepare_enable(dev->clk_bus);\n\tif (err)\n\t\treturn err;\n\n\terr = clk_prepare_enable(dev->clk_gpu);\n\tif (err)\n\t\tgoto error_out0;\n\n\tif (dev->reset) {\n\t\terr = reset_control_deassert(dev->reset);\n\t\tif (err) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"reset controller deassert failed %d\\n\", err);\n\t\t\tgoto error_out1;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_out1:\n\tclk_disable_unprepare(dev->clk_gpu);\nerror_out0:\n\tclk_disable_unprepare(dev->clk_bus);\n\treturn err;\n}\n\nstatic void lima_clk_disable(struct lima_device *dev)\n{\n\tif (dev->reset)\n\t\treset_control_assert(dev->reset);\n\tclk_disable_unprepare(dev->clk_gpu);\n\tclk_disable_unprepare(dev->clk_bus);\n}\n\nstatic int lima_clk_init(struct lima_device *dev)\n{\n\tint err;\n\n\tdev->clk_bus = devm_clk_get(dev->dev, \"bus\");\n\tif (IS_ERR(dev->clk_bus)) {\n\t\terr = PTR_ERR(dev->clk_bus);\n\t\tif (err != -EPROBE_DEFER)\n\t\t\tdev_err(dev->dev, \"get bus clk failed %d\\n\", err);\n\t\tdev->clk_bus = NULL;\n\t\treturn err;\n\t}\n\n\tdev->clk_gpu = devm_clk_get(dev->dev, \"core\");\n\tif (IS_ERR(dev->clk_gpu)) {\n\t\terr = PTR_ERR(dev->clk_gpu);\n\t\tif (err != -EPROBE_DEFER)\n\t\t\tdev_err(dev->dev, \"get core clk failed %d\\n\", err);\n\t\tdev->clk_gpu = NULL;\n\t\treturn err;\n\t}\n\n\tdev->reset = devm_reset_control_array_get_optional_shared(dev->dev);\n\tif (IS_ERR(dev->reset)) {\n\t\terr = PTR_ERR(dev->reset);\n\t\tif (err != -EPROBE_DEFER)\n\t\t\tdev_err(dev->dev, \"get reset controller failed %d\\n\",\n\t\t\t\terr);\n\t\tdev->reset = NULL;\n\t\treturn err;\n\t}\n\n\treturn lima_clk_enable(dev);\n}\n\nstatic void lima_clk_fini(struct lima_device *dev)\n{\n\tlima_clk_disable(dev);\n}\n\nstatic int lima_regulator_enable(struct lima_device *dev)\n{\n\tint ret;\n\n\tif (!dev->regulator)\n\t\treturn 0;\n\n\tret = regulator_enable(dev->regulator);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"failed to enable regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void lima_regulator_disable(struct lima_device *dev)\n{\n\tif (dev->regulator)\n\t\tregulator_disable(dev->regulator);\n}\n\nstatic int lima_regulator_init(struct lima_device *dev)\n{\n\tint ret;\n\n\tdev->regulator = devm_regulator_get_optional(dev->dev, \"mali\");\n\tif (IS_ERR(dev->regulator)) {\n\t\tret = PTR_ERR(dev->regulator);\n\t\tdev->regulator = NULL;\n\t\tif (ret == -ENODEV)\n\t\t\treturn 0;\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev->dev, \"failed to get regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn lima_regulator_enable(dev);\n}\n\nstatic void lima_regulator_fini(struct lima_device *dev)\n{\n\tlima_regulator_disable(dev);\n}\n\nstatic int lima_init_ip(struct lima_device *dev, int index)\n{\n\tstruct platform_device *pdev = to_platform_device(dev->dev);\n\tstruct lima_ip_desc *desc = lima_ip_desc + index;\n\tstruct lima_ip *ip = dev->ip + index;\n\tconst char *irq_name = desc->irq_name;\n\tint offset = desc->offset[dev->id];\n\tbool must = desc->must_have[dev->id];\n\tint err;\n\n\tif (offset < 0)\n\t\treturn 0;\n\n\tip->dev = dev;\n\tip->id = index;\n\tip->iomem = dev->iomem + offset;\n\tif (irq_name) {\n\t\terr = must ? platform_get_irq_byname(pdev, irq_name) :\n\t\t\t     platform_get_irq_byname_optional(pdev, irq_name);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tip->irq = err;\n\t}\n\n\terr = desc->init(ip);\n\tif (!err) {\n\t\tip->present = true;\n\t\treturn 0;\n\t}\n\nout:\n\treturn must ? err : 0;\n}\n\nstatic void lima_fini_ip(struct lima_device *ldev, int index)\n{\n\tstruct lima_ip_desc *desc = lima_ip_desc + index;\n\tstruct lima_ip *ip = ldev->ip + index;\n\n\tif (ip->present)\n\t\tdesc->fini(ip);\n}\n\nstatic int lima_resume_ip(struct lima_device *ldev, int index)\n{\n\tstruct lima_ip_desc *desc = lima_ip_desc + index;\n\tstruct lima_ip *ip = ldev->ip + index;\n\tint ret = 0;\n\n\tif (ip->present)\n\t\tret = desc->resume(ip);\n\n\treturn ret;\n}\n\nstatic void lima_suspend_ip(struct lima_device *ldev, int index)\n{\n\tstruct lima_ip_desc *desc = lima_ip_desc + index;\n\tstruct lima_ip *ip = ldev->ip + index;\n\n\tif (ip->present)\n\t\tdesc->suspend(ip);\n}\n\nstatic int lima_init_gp_pipe(struct lima_device *dev)\n{\n\tstruct lima_sched_pipe *pipe = dev->pipe + lima_pipe_gp;\n\tint err;\n\n\tpipe->ldev = dev;\n\n\terr = lima_sched_pipe_init(pipe, \"gp\");\n\tif (err)\n\t\treturn err;\n\n\tpipe->l2_cache[pipe->num_l2_cache++] = dev->ip + lima_ip_l2_cache0;\n\tpipe->mmu[pipe->num_mmu++] = dev->ip + lima_ip_gpmmu;\n\tpipe->processor[pipe->num_processor++] = dev->ip + lima_ip_gp;\n\n\terr = lima_gp_pipe_init(dev);\n\tif (err) {\n\t\tlima_sched_pipe_fini(pipe);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void lima_fini_gp_pipe(struct lima_device *dev)\n{\n\tstruct lima_sched_pipe *pipe = dev->pipe + lima_pipe_gp;\n\n\tlima_gp_pipe_fini(dev);\n\tlima_sched_pipe_fini(pipe);\n}\n\nstatic int lima_init_pp_pipe(struct lima_device *dev)\n{\n\tstruct lima_sched_pipe *pipe = dev->pipe + lima_pipe_pp;\n\tint err, i;\n\n\tpipe->ldev = dev;\n\n\terr = lima_sched_pipe_init(pipe, \"pp\");\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < LIMA_SCHED_PIPE_MAX_PROCESSOR; i++) {\n\t\tstruct lima_ip *pp = dev->ip + lima_ip_pp0 + i;\n\t\tstruct lima_ip *ppmmu = dev->ip + lima_ip_ppmmu0 + i;\n\t\tstruct lima_ip *l2_cache;\n\n\t\tif (dev->id == lima_gpu_mali400)\n\t\t\tl2_cache = dev->ip + lima_ip_l2_cache0;\n\t\telse\n\t\t\tl2_cache = dev->ip + lima_ip_l2_cache1 + (i >> 2);\n\n\t\tif (pp->present && ppmmu->present && l2_cache->present) {\n\t\t\tpipe->mmu[pipe->num_mmu++] = ppmmu;\n\t\t\tpipe->processor[pipe->num_processor++] = pp;\n\t\t\tif (!pipe->l2_cache[i >> 2])\n\t\t\t\tpipe->l2_cache[pipe->num_l2_cache++] = l2_cache;\n\t\t}\n\t}\n\n\tif (dev->ip[lima_ip_bcast].present) {\n\t\tpipe->bcast_processor = dev->ip + lima_ip_pp_bcast;\n\t\tpipe->bcast_mmu = dev->ip + lima_ip_ppmmu_bcast;\n\t}\n\n\terr = lima_pp_pipe_init(dev);\n\tif (err) {\n\t\tlima_sched_pipe_fini(pipe);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void lima_fini_pp_pipe(struct lima_device *dev)\n{\n\tstruct lima_sched_pipe *pipe = dev->pipe + lima_pipe_pp;\n\n\tlima_pp_pipe_fini(dev);\n\tlima_sched_pipe_fini(pipe);\n}\n\nint lima_device_init(struct lima_device *ldev)\n{\n\tstruct platform_device *pdev = to_platform_device(ldev->dev);\n\tint err, i;\n\n\tdma_set_coherent_mask(ldev->dev, DMA_BIT_MASK(32));\n\tdma_set_max_seg_size(ldev->dev, UINT_MAX);\n\n\terr = lima_clk_init(ldev);\n\tif (err)\n\t\treturn err;\n\n\terr = lima_regulator_init(ldev);\n\tif (err)\n\t\tgoto err_out0;\n\n\tldev->empty_vm = lima_vm_create(ldev);\n\tif (!ldev->empty_vm) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out1;\n\t}\n\n\tldev->va_start = 0;\n\tif (ldev->id == lima_gpu_mali450) {\n\t\tldev->va_end = LIMA_VA_RESERVE_START;\n\t\tldev->dlbu_cpu = dma_alloc_wc(\n\t\t\tldev->dev, LIMA_PAGE_SIZE,\n\t\t\t&ldev->dlbu_dma, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!ldev->dlbu_cpu) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out2;\n\t\t}\n\t} else\n\t\tldev->va_end = LIMA_VA_RESERVE_END;\n\n\tldev->iomem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ldev->iomem)) {\n\t\tdev_err(ldev->dev, \"fail to ioremap iomem\\n\");\n\t\terr = PTR_ERR(ldev->iomem);\n\t\tgoto err_out3;\n\t}\n\n\tfor (i = 0; i < lima_ip_num; i++) {\n\t\terr = lima_init_ip(ldev, i);\n\t\tif (err)\n\t\t\tgoto err_out4;\n\t}\n\n\terr = lima_init_gp_pipe(ldev);\n\tif (err)\n\t\tgoto err_out4;\n\n\terr = lima_init_pp_pipe(ldev);\n\tif (err)\n\t\tgoto err_out5;\n\n\tldev->dump.magic = LIMA_DUMP_MAGIC;\n\tldev->dump.version_major = LIMA_DUMP_MAJOR;\n\tldev->dump.version_minor = LIMA_DUMP_MINOR;\n\tINIT_LIST_HEAD(&ldev->error_task_list);\n\tmutex_init(&ldev->error_task_list_lock);\n\n\tdev_info(ldev->dev, \"bus rate = %lu\\n\", clk_get_rate(ldev->clk_bus));\n\tdev_info(ldev->dev, \"mod rate = %lu\", clk_get_rate(ldev->clk_gpu));\n\n\treturn 0;\n\nerr_out5:\n\tlima_fini_gp_pipe(ldev);\nerr_out4:\n\twhile (--i >= 0)\n\t\tlima_fini_ip(ldev, i);\nerr_out3:\n\tif (ldev->dlbu_cpu)\n\t\tdma_free_wc(ldev->dev, LIMA_PAGE_SIZE,\n\t\t\t    ldev->dlbu_cpu, ldev->dlbu_dma);\nerr_out2:\n\tlima_vm_put(ldev->empty_vm);\nerr_out1:\n\tlima_regulator_fini(ldev);\nerr_out0:\n\tlima_clk_fini(ldev);\n\treturn err;\n}\n\nvoid lima_device_fini(struct lima_device *ldev)\n{\n\tint i;\n\tstruct lima_sched_error_task *et, *tmp;\n\n\tlist_for_each_entry_safe(et, tmp, &ldev->error_task_list, list) {\n\t\tlist_del(&et->list);\n\t\tkvfree(et);\n\t}\n\tmutex_destroy(&ldev->error_task_list_lock);\n\n\tlima_fini_pp_pipe(ldev);\n\tlima_fini_gp_pipe(ldev);\n\n\tfor (i = lima_ip_num - 1; i >= 0; i--)\n\t\tlima_fini_ip(ldev, i);\n\n\tif (ldev->dlbu_cpu)\n\t\tdma_free_wc(ldev->dev, LIMA_PAGE_SIZE,\n\t\t\t    ldev->dlbu_cpu, ldev->dlbu_dma);\n\n\tlima_vm_put(ldev->empty_vm);\n\n\tlima_regulator_fini(ldev);\n\n\tlima_clk_fini(ldev);\n}\n\nint lima_device_resume(struct device *dev)\n{\n\tstruct lima_device *ldev = dev_get_drvdata(dev);\n\tint i, err;\n\n\terr = lima_clk_enable(ldev);\n\tif (err) {\n\t\tdev_err(dev, \"resume clk fail %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = lima_regulator_enable(ldev);\n\tif (err) {\n\t\tdev_err(dev, \"resume regulator fail %d\\n\", err);\n\t\tgoto err_out0;\n\t}\n\n\tfor (i = 0; i < lima_ip_num; i++) {\n\t\terr = lima_resume_ip(ldev, i);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"resume ip %d fail\\n\", i);\n\t\t\tgoto err_out1;\n\t\t}\n\t}\n\n\terr = lima_devfreq_resume(&ldev->devfreq);\n\tif (err) {\n\t\tdev_err(dev, \"devfreq resume fail\\n\");\n\t\tgoto err_out1;\n\t}\n\n\treturn 0;\n\nerr_out1:\n\twhile (--i >= 0)\n\t\tlima_suspend_ip(ldev, i);\n\tlima_regulator_disable(ldev);\nerr_out0:\n\tlima_clk_disable(ldev);\n\treturn err;\n}\n\nint lima_device_suspend(struct device *dev)\n{\n\tstruct lima_device *ldev = dev_get_drvdata(dev);\n\tint i, err;\n\n\t \n\tfor (i = 0; i < lima_pipe_num; i++) {\n\t\tif (atomic_read(&ldev->pipe[i].base.hw_rq_count))\n\t\t\treturn -EBUSY;\n\t}\n\n\terr = lima_devfreq_suspend(&ldev->devfreq);\n\tif (err) {\n\t\tdev_err(dev, \"devfreq suspend fail\\n\");\n\t\treturn err;\n\t}\n\n\tfor (i = lima_ip_num - 1; i >= 0; i--)\n\t\tlima_suspend_ip(ldev, i);\n\n\tlima_regulator_disable(ldev);\n\n\tlima_clk_disable(ldev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}