{
  "module_name": "lima_gem.c",
  "hash_id": "7335a14c4feaaa7038a8c859c1e4e23008705f381c9e905beeffd8559d7f95d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/lima/lima_gem.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/iosys-map.h>\n#include <linux/sync_file.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/dma-mapping.h>\n\n#include <drm/drm_file.h>\n#include <drm/drm_syncobj.h>\n#include <drm/drm_utils.h>\n\n#include <drm/lima_drm.h>\n\n#include \"lima_drv.h\"\n#include \"lima_gem.h\"\n#include \"lima_vm.h\"\n\nint lima_heap_alloc(struct lima_bo *bo, struct lima_vm *vm)\n{\n\tstruct page **pages;\n\tstruct address_space *mapping = bo->base.base.filp->f_mapping;\n\tstruct device *dev = bo->base.base.dev->dev;\n\tsize_t old_size = bo->heap_size;\n\tsize_t new_size = bo->heap_size ? bo->heap_size * 2 :\n\t\t(lima_heap_init_nr_pages << PAGE_SHIFT);\n\tstruct sg_table sgt;\n\tint i, ret;\n\n\tif (bo->heap_size >= bo->base.base.size)\n\t\treturn -ENOSPC;\n\n\tnew_size = min(new_size, bo->base.base.size);\n\n\tdma_resv_lock(bo->base.base.resv, NULL);\n\n\tif (bo->base.pages) {\n\t\tpages = bo->base.pages;\n\t} else {\n\t\tpages = kvmalloc_array(bo->base.base.size >> PAGE_SHIFT,\n\t\t\t\t       sizeof(*pages), GFP_KERNEL | __GFP_ZERO);\n\t\tif (!pages) {\n\t\t\tdma_resv_unlock(bo->base.base.resv);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tbo->base.pages = pages;\n\t\tbo->base.pages_use_count = 1;\n\n\t\tmapping_set_unevictable(mapping);\n\t}\n\n\tfor (i = old_size >> PAGE_SHIFT; i < new_size >> PAGE_SHIFT; i++) {\n\t\tstruct page *page = shmem_read_mapping_page(mapping, i);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tdma_resv_unlock(bo->base.base.resv);\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tdma_resv_unlock(bo->base.base.resv);\n\n\tret = sg_alloc_table_from_pages(&sgt, pages, i, 0,\n\t\t\t\t\tnew_size, GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bo->base.sgt) {\n\t\tdma_unmap_sgtable(dev, bo->base.sgt, DMA_BIDIRECTIONAL, 0);\n\t\tsg_free_table(bo->base.sgt);\n\t} else {\n\t\tbo->base.sgt = kmalloc(sizeof(*bo->base.sgt), GFP_KERNEL);\n\t\tif (!bo->base.sgt) {\n\t\t\tsg_free_table(&sgt);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tret = dma_map_sgtable(dev, &sgt, DMA_BIDIRECTIONAL, 0);\n\tif (ret) {\n\t\tsg_free_table(&sgt);\n\t\tkfree(bo->base.sgt);\n\t\tbo->base.sgt = NULL;\n\t\treturn ret;\n\t}\n\n\t*bo->base.sgt = sgt;\n\n\tif (vm) {\n\t\tret = lima_vm_map_bo(vm, bo, old_size >> PAGE_SHIFT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tbo->heap_size = new_size;\n\treturn 0;\n}\n\nint lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,\n\t\t\t   u32 size, u32 flags, u32 *handle)\n{\n\tint err;\n\tgfp_t mask;\n\tstruct drm_gem_shmem_object *shmem;\n\tstruct drm_gem_object *obj;\n\tstruct lima_bo *bo;\n\tbool is_heap = flags & LIMA_BO_FLAG_HEAP;\n\n\tshmem = drm_gem_shmem_create(dev, size);\n\tif (IS_ERR(shmem))\n\t\treturn PTR_ERR(shmem);\n\n\tobj = &shmem->base;\n\n\t \n\tmask = mapping_gfp_mask(obj->filp->f_mapping);\n\tmask &= ~__GFP_HIGHMEM;\n\tmask |= __GFP_DMA32;\n\tmapping_set_gfp_mask(obj->filp->f_mapping, mask);\n\n\tif (is_heap) {\n\t\tbo = to_lima_bo(obj);\n\t\terr = lima_heap_alloc(bo, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tstruct sg_table *sgt = drm_gem_shmem_get_pages_sgt(shmem);\n\n\t\tif (IS_ERR(sgt)) {\n\t\t\terr = PTR_ERR(sgt);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = drm_gem_handle_create(file, obj, handle);\n\nout:\n\t \n\tdrm_gem_object_put(obj);\n\n\treturn err;\n}\n\nstatic void lima_gem_free_object(struct drm_gem_object *obj)\n{\n\tstruct lima_bo *bo = to_lima_bo(obj);\n\n\tif (!list_empty(&bo->va))\n\t\tdev_err(obj->dev->dev, \"lima gem free bo still has va\\n\");\n\n\tdrm_gem_shmem_free(&bo->base);\n}\n\nstatic int lima_gem_object_open(struct drm_gem_object *obj, struct drm_file *file)\n{\n\tstruct lima_bo *bo = to_lima_bo(obj);\n\tstruct lima_drm_priv *priv = to_lima_drm_priv(file);\n\tstruct lima_vm *vm = priv->vm;\n\n\treturn lima_vm_bo_add(vm, bo, true);\n}\n\nstatic void lima_gem_object_close(struct drm_gem_object *obj, struct drm_file *file)\n{\n\tstruct lima_bo *bo = to_lima_bo(obj);\n\tstruct lima_drm_priv *priv = to_lima_drm_priv(file);\n\tstruct lima_vm *vm = priv->vm;\n\n\tlima_vm_bo_del(vm, bo);\n}\n\nstatic int lima_gem_pin(struct drm_gem_object *obj)\n{\n\tstruct lima_bo *bo = to_lima_bo(obj);\n\n\tif (bo->heap_size)\n\t\treturn -EINVAL;\n\n\treturn drm_gem_shmem_pin(&bo->base);\n}\n\nstatic int lima_gem_vmap(struct drm_gem_object *obj, struct iosys_map *map)\n{\n\tstruct lima_bo *bo = to_lima_bo(obj);\n\n\tif (bo->heap_size)\n\t\treturn -EINVAL;\n\n\treturn drm_gem_shmem_vmap(&bo->base, map);\n}\n\nstatic int lima_gem_mmap(struct drm_gem_object *obj, struct vm_area_struct *vma)\n{\n\tstruct lima_bo *bo = to_lima_bo(obj);\n\n\tif (bo->heap_size)\n\t\treturn -EINVAL;\n\n\treturn drm_gem_shmem_mmap(&bo->base, vma);\n}\n\nstatic const struct drm_gem_object_funcs lima_gem_funcs = {\n\t.free = lima_gem_free_object,\n\t.open = lima_gem_object_open,\n\t.close = lima_gem_object_close,\n\t.print_info = drm_gem_shmem_object_print_info,\n\t.pin = lima_gem_pin,\n\t.unpin = drm_gem_shmem_object_unpin,\n\t.get_sg_table = drm_gem_shmem_object_get_sg_table,\n\t.vmap = lima_gem_vmap,\n\t.vunmap = drm_gem_shmem_object_vunmap,\n\t.mmap = lima_gem_mmap,\n\t.vm_ops = &drm_gem_shmem_vm_ops,\n};\n\nstruct drm_gem_object *lima_gem_create_object(struct drm_device *dev, size_t size)\n{\n\tstruct lima_bo *bo;\n\n\tbo = kzalloc(sizeof(*bo), GFP_KERNEL);\n\tif (!bo)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&bo->lock);\n\tINIT_LIST_HEAD(&bo->va);\n\tbo->base.map_wc = true;\n\tbo->base.base.funcs = &lima_gem_funcs;\n\n\treturn &bo->base.base;\n}\n\nint lima_gem_get_info(struct drm_file *file, u32 handle, u32 *va, u64 *offset)\n{\n\tstruct drm_gem_object *obj;\n\tstruct lima_bo *bo;\n\tstruct lima_drm_priv *priv = to_lima_drm_priv(file);\n\tstruct lima_vm *vm = priv->vm;\n\n\tobj = drm_gem_object_lookup(file, handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tbo = to_lima_bo(obj);\n\n\t*va = lima_vm_get_va(vm, bo);\n\n\t*offset = drm_vma_node_offset_addr(&obj->vma_node);\n\n\tdrm_gem_object_put(obj);\n\treturn 0;\n}\n\nstatic int lima_gem_sync_bo(struct lima_sched_task *task, struct lima_bo *bo,\n\t\t\t    bool write, bool explicit)\n{\n\tint err;\n\n\terr = dma_resv_reserve_fences(lima_bo_resv(bo), 1);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (explicit)\n\t\treturn 0;\n\n\treturn drm_sched_job_add_implicit_dependencies(&task->base,\n\t\t\t\t\t\t       &bo->base.base,\n\t\t\t\t\t\t       write);\n}\n\nstatic int lima_gem_add_deps(struct drm_file *file, struct lima_submit *submit)\n{\n\tint i, err;\n\n\tfor (i = 0; i < ARRAY_SIZE(submit->in_sync); i++) {\n\t\tif (!submit->in_sync[i])\n\t\t\tcontinue;\n\n\t\terr = drm_sched_job_add_syncobj_dependency(&submit->task->base, file,\n\t\t\t\t\t\t\t   submit->in_sync[i], 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint lima_gem_submit(struct drm_file *file, struct lima_submit *submit)\n{\n\tint i, err = 0;\n\tstruct ww_acquire_ctx ctx;\n\tstruct lima_drm_priv *priv = to_lima_drm_priv(file);\n\tstruct lima_vm *vm = priv->vm;\n\tstruct drm_syncobj *out_sync = NULL;\n\tstruct dma_fence *fence;\n\tstruct lima_bo **bos = submit->lbos;\n\n\tif (submit->out_sync) {\n\t\tout_sync = drm_syncobj_find(file, submit->out_sync);\n\t\tif (!out_sync)\n\t\t\treturn -ENOENT;\n\t}\n\n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct lima_bo *bo;\n\n\t\tobj = drm_gem_object_lookup(file, submit->bos[i].handle);\n\t\tif (!obj) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_out0;\n\t\t}\n\n\t\tbo = to_lima_bo(obj);\n\n\t\t \n\t\terr = lima_vm_bo_add(vm, bo, false);\n\t\tif (err) {\n\t\t\tdrm_gem_object_put(obj);\n\t\t\tgoto err_out0;\n\t\t}\n\n\t\tbos[i] = bo;\n\t}\n\n\terr = drm_gem_lock_reservations((struct drm_gem_object **)bos,\n\t\t\t\t\tsubmit->nr_bos, &ctx);\n\tif (err)\n\t\tgoto err_out0;\n\n\terr = lima_sched_task_init(\n\t\tsubmit->task, submit->ctx->context + submit->pipe,\n\t\tbos, submit->nr_bos, vm);\n\tif (err)\n\t\tgoto err_out1;\n\n\terr = lima_gem_add_deps(file, submit);\n\tif (err)\n\t\tgoto err_out2;\n\n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\terr = lima_gem_sync_bo(\n\t\t\tsubmit->task, bos[i],\n\t\t\tsubmit->bos[i].flags & LIMA_SUBMIT_BO_WRITE,\n\t\t\tsubmit->flags & LIMA_SUBMIT_FLAG_EXPLICIT_FENCE);\n\t\tif (err)\n\t\t\tgoto err_out2;\n\t}\n\n\tfence = lima_sched_context_queue_task(submit->task);\n\n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\tdma_resv_add_fence(lima_bo_resv(bos[i]), fence,\n\t\t\t\t   submit->bos[i].flags & LIMA_SUBMIT_BO_WRITE ?\n\t\t\t\t   DMA_RESV_USAGE_WRITE : DMA_RESV_USAGE_READ);\n\t}\n\n\tdrm_gem_unlock_reservations((struct drm_gem_object **)bos,\n\t\t\t\t    submit->nr_bos, &ctx);\n\n\tfor (i = 0; i < submit->nr_bos; i++)\n\t\tdrm_gem_object_put(&bos[i]->base.base);\n\n\tif (out_sync) {\n\t\tdrm_syncobj_replace_fence(out_sync, fence);\n\t\tdrm_syncobj_put(out_sync);\n\t}\n\n\tdma_fence_put(fence);\n\n\treturn 0;\n\nerr_out2:\n\tlima_sched_task_fini(submit->task);\nerr_out1:\n\tdrm_gem_unlock_reservations((struct drm_gem_object **)bos,\n\t\t\t\t    submit->nr_bos, &ctx);\nerr_out0:\n\tfor (i = 0; i < submit->nr_bos; i++) {\n\t\tif (!bos[i])\n\t\t\tbreak;\n\t\tlima_vm_bo_del(vm, bos[i]);\n\t\tdrm_gem_object_put(&bos[i]->base.base);\n\t}\n\tif (out_sync)\n\t\tdrm_syncobj_put(out_sync);\n\treturn err;\n}\n\nint lima_gem_wait(struct drm_file *file, u32 handle, u32 op, s64 timeout_ns)\n{\n\tbool write = op & LIMA_GEM_WAIT_WRITE;\n\tlong ret, timeout;\n\n\tif (!op)\n\t\treturn 0;\n\n\ttimeout = drm_timeout_abs_to_jiffies(timeout_ns);\n\n\tret = drm_gem_dma_resv_wait(file, handle, write, timeout);\n\tif (ret == -ETIME)\n\t\tret = timeout ? -ETIMEDOUT : -EBUSY;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}