{
  "module_name": "lima_pp.c",
  "hash_id": "ccdc2a79248870e2641f569542019352e462d4bdf31cb4084e9d9cd8d6a40b36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/lima/lima_pp.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n\n#include <drm/lima_drm.h>\n\n#include \"lima_device.h\"\n#include \"lima_pp.h\"\n#include \"lima_dlbu.h\"\n#include \"lima_bcast.h\"\n#include \"lima_vm.h\"\n#include \"lima_regs.h\"\n\n#define pp_write(reg, data) writel(data, ip->iomem + reg)\n#define pp_read(reg) readl(ip->iomem + reg)\n\nstatic void lima_pp_handle_irq(struct lima_ip *ip, u32 state)\n{\n\tstruct lima_device *dev = ip->dev;\n\tstruct lima_sched_pipe *pipe = dev->pipe + lima_pipe_pp;\n\n\tif (state & LIMA_PP_IRQ_MASK_ERROR) {\n\t\tu32 status = pp_read(LIMA_PP_STATUS);\n\n\t\tdev_err(dev->dev, \"pp error irq state=%x status=%x\\n\",\n\t\t\tstate, status);\n\n\t\tpipe->error = true;\n\n\t\t \n\t\tpp_write(LIMA_PP_INT_MASK, 0);\n\t}\n\n\tpp_write(LIMA_PP_INT_CLEAR, state);\n}\n\nstatic irqreturn_t lima_pp_irq_handler(int irq, void *data)\n{\n\tstruct lima_ip *ip = data;\n\tstruct lima_device *dev = ip->dev;\n\tstruct lima_sched_pipe *pipe = dev->pipe + lima_pipe_pp;\n\tu32 state = pp_read(LIMA_PP_INT_STATUS);\n\n\t \n\tif (!state)\n\t\treturn IRQ_NONE;\n\n\tlima_pp_handle_irq(ip, state);\n\n\tif (atomic_dec_and_test(&pipe->task))\n\t\tlima_sched_pipe_task_done(pipe);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t lima_pp_bcast_irq_handler(int irq, void *data)\n{\n\tint i;\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct lima_ip *pp_bcast = data;\n\tstruct lima_device *dev = pp_bcast->dev;\n\tstruct lima_sched_pipe *pipe = dev->pipe + lima_pipe_pp;\n\tstruct drm_lima_m450_pp_frame *frame;\n\n\t \n\tif (!pipe->current_task)\n\t\treturn IRQ_NONE;\n\n\tframe = pipe->current_task->frame;\n\n\tfor (i = 0; i < frame->num_pp; i++) {\n\t\tstruct lima_ip *ip = pipe->processor[i];\n\t\tu32 status, state;\n\n\t\tif (pipe->done & (1 << i))\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = pp_read(LIMA_PP_STATUS);\n\t\tstate = pp_read(LIMA_PP_INT_STATUS);\n\n\t\tif (state) {\n\t\t\tlima_pp_handle_irq(ip, state);\n\t\t\tret = IRQ_HANDLED;\n\t\t} else {\n\t\t\tif (status & LIMA_PP_STATUS_RENDERING_ACTIVE)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tpipe->done |= (1 << i);\n\t\tif (atomic_dec_and_test(&pipe->task))\n\t\t\tlima_sched_pipe_task_done(pipe);\n\t}\n\n\treturn ret;\n}\n\nstatic void lima_pp_soft_reset_async(struct lima_ip *ip)\n{\n\tif (ip->data.async_reset)\n\t\treturn;\n\n\tpp_write(LIMA_PP_INT_MASK, 0);\n\tpp_write(LIMA_PP_INT_RAWSTAT, LIMA_PP_IRQ_MASK_ALL);\n\tpp_write(LIMA_PP_CTRL, LIMA_PP_CTRL_SOFT_RESET);\n\tip->data.async_reset = true;\n}\n\nstatic int lima_pp_soft_reset_poll(struct lima_ip *ip)\n{\n\treturn !(pp_read(LIMA_PP_STATUS) & LIMA_PP_STATUS_RENDERING_ACTIVE) &&\n\t\tpp_read(LIMA_PP_INT_RAWSTAT) == LIMA_PP_IRQ_RESET_COMPLETED;\n}\n\nstatic int lima_pp_soft_reset_async_wait_one(struct lima_ip *ip)\n{\n\tstruct lima_device *dev = ip->dev;\n\tint ret;\n\n\tret = lima_poll_timeout(ip, lima_pp_soft_reset_poll, 0, 100);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"pp %s reset time out\\n\", lima_ip_name(ip));\n\t\treturn ret;\n\t}\n\n\tpp_write(LIMA_PP_INT_CLEAR, LIMA_PP_IRQ_MASK_ALL);\n\tpp_write(LIMA_PP_INT_MASK, LIMA_PP_IRQ_MASK_USED);\n\treturn 0;\n}\n\nstatic int lima_pp_soft_reset_async_wait(struct lima_ip *ip)\n{\n\tint i, err = 0;\n\n\tif (!ip->data.async_reset)\n\t\treturn 0;\n\n\tif (ip->id == lima_ip_pp_bcast) {\n\t\tstruct lima_device *dev = ip->dev;\n\t\tstruct lima_sched_pipe *pipe = dev->pipe + lima_pipe_pp;\n\t\tstruct drm_lima_m450_pp_frame *frame = pipe->current_task->frame;\n\n\t\tfor (i = 0; i < frame->num_pp; i++)\n\t\t\terr |= lima_pp_soft_reset_async_wait_one(pipe->processor[i]);\n\t} else\n\t\terr = lima_pp_soft_reset_async_wait_one(ip);\n\n\tip->data.async_reset = false;\n\treturn err;\n}\n\nstatic void lima_pp_write_frame(struct lima_ip *ip, u32 *frame, u32 *wb)\n{\n\tint i, j, n = 0;\n\n\tfor (i = 0; i < LIMA_PP_FRAME_REG_NUM; i++)\n\t\twritel(frame[i], ip->iomem + LIMA_PP_FRAME + i * 4);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tfor (j = 0; j < LIMA_PP_WB_REG_NUM; j++)\n\t\t\twritel(wb[n++], ip->iomem + LIMA_PP_WB(i) + j * 4);\n\t}\n}\n\nstatic int lima_pp_hard_reset_poll(struct lima_ip *ip)\n{\n\tpp_write(LIMA_PP_PERF_CNT_0_LIMIT, 0xC01A0000);\n\treturn pp_read(LIMA_PP_PERF_CNT_0_LIMIT) == 0xC01A0000;\n}\n\nstatic int lima_pp_hard_reset(struct lima_ip *ip)\n{\n\tstruct lima_device *dev = ip->dev;\n\tint ret;\n\n\tpp_write(LIMA_PP_PERF_CNT_0_LIMIT, 0xC0FFE000);\n\tpp_write(LIMA_PP_INT_MASK, 0);\n\tpp_write(LIMA_PP_CTRL, LIMA_PP_CTRL_FORCE_RESET);\n\tret = lima_poll_timeout(ip, lima_pp_hard_reset_poll, 10, 100);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"pp hard reset timeout\\n\");\n\t\treturn ret;\n\t}\n\n\tpp_write(LIMA_PP_PERF_CNT_0_LIMIT, 0);\n\tpp_write(LIMA_PP_INT_CLEAR, LIMA_PP_IRQ_MASK_ALL);\n\tpp_write(LIMA_PP_INT_MASK, LIMA_PP_IRQ_MASK_USED);\n\treturn 0;\n}\n\nstatic void lima_pp_print_version(struct lima_ip *ip)\n{\n\tu32 version, major, minor;\n\tchar *name;\n\n\tversion = pp_read(LIMA_PP_VERSION);\n\tmajor = (version >> 8) & 0xFF;\n\tminor = version & 0xFF;\n\tswitch (version >> 16) {\n\tcase 0xC807:\n\t    name = \"mali200\";\n\t\tbreak;\n\tcase 0xCE07:\n\t\tname = \"mali300\";\n\t\tbreak;\n\tcase 0xCD07:\n\t\tname = \"mali400\";\n\t\tbreak;\n\tcase 0xCF07:\n\t\tname = \"mali450\";\n\t\tbreak;\n\tdefault:\n\t\tname = \"unknown\";\n\t\tbreak;\n\t}\n\tdev_info(ip->dev->dev, \"%s - %s version major %d minor %d\\n\",\n\t\t lima_ip_name(ip), name, major, minor);\n}\n\nstatic int lima_pp_hw_init(struct lima_ip *ip)\n{\n\tip->data.async_reset = false;\n\tlima_pp_soft_reset_async(ip);\n\treturn lima_pp_soft_reset_async_wait(ip);\n}\n\nint lima_pp_resume(struct lima_ip *ip)\n{\n\treturn lima_pp_hw_init(ip);\n}\n\nvoid lima_pp_suspend(struct lima_ip *ip)\n{\n\n}\n\nint lima_pp_init(struct lima_ip *ip)\n{\n\tstruct lima_device *dev = ip->dev;\n\tint err;\n\n\tlima_pp_print_version(ip);\n\n\terr = lima_pp_hw_init(ip);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_request_irq(dev->dev, ip->irq, lima_pp_irq_handler,\n\t\t\t       IRQF_SHARED, lima_ip_name(ip), ip);\n\tif (err) {\n\t\tdev_err(dev->dev, \"pp %s fail to request irq\\n\",\n\t\t\tlima_ip_name(ip));\n\t\treturn err;\n\t}\n\n\tdev->pp_version = pp_read(LIMA_PP_VERSION);\n\n\treturn 0;\n}\n\nvoid lima_pp_fini(struct lima_ip *ip)\n{\n\n}\n\nint lima_pp_bcast_resume(struct lima_ip *ip)\n{\n\t \n\tip->data.async_reset = false;\n\treturn 0;\n}\n\nvoid lima_pp_bcast_suspend(struct lima_ip *ip)\n{\n\n}\n\nint lima_pp_bcast_init(struct lima_ip *ip)\n{\n\tstruct lima_device *dev = ip->dev;\n\tint err;\n\n\terr = devm_request_irq(dev->dev, ip->irq, lima_pp_bcast_irq_handler,\n\t\t\t       IRQF_SHARED, lima_ip_name(ip), ip);\n\tif (err) {\n\t\tdev_err(dev->dev, \"pp %s fail to request irq\\n\",\n\t\t\tlima_ip_name(ip));\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid lima_pp_bcast_fini(struct lima_ip *ip)\n{\n\n}\n\nstatic int lima_pp_task_validate(struct lima_sched_pipe *pipe,\n\t\t\t\t struct lima_sched_task *task)\n{\n\tu32 num_pp;\n\n\tif (pipe->bcast_processor) {\n\t\tstruct drm_lima_m450_pp_frame *f = task->frame;\n\n\t\tnum_pp = f->num_pp;\n\n\t\tif (f->_pad)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tstruct drm_lima_m400_pp_frame *f = task->frame;\n\n\t\tnum_pp = f->num_pp;\n\t}\n\n\tif (num_pp == 0 || num_pp > pipe->num_processor)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void lima_pp_task_run(struct lima_sched_pipe *pipe,\n\t\t\t     struct lima_sched_task *task)\n{\n\tif (pipe->bcast_processor) {\n\t\tstruct drm_lima_m450_pp_frame *frame = task->frame;\n\t\tstruct lima_device *dev = pipe->bcast_processor->dev;\n\t\tstruct lima_ip *ip = pipe->bcast_processor;\n\t\tint i;\n\n\t\tpipe->done = 0;\n\t\tatomic_set(&pipe->task, frame->num_pp);\n\n\t\tif (frame->use_dlbu) {\n\t\t\tlima_dlbu_enable(dev, frame->num_pp);\n\n\t\t\tframe->frame[LIMA_PP_FRAME >> 2] = LIMA_VA_RESERVE_DLBU;\n\t\t\tlima_dlbu_set_reg(dev->ip + lima_ip_dlbu, frame->dlbu_regs);\n\t\t} else\n\t\t\tlima_dlbu_disable(dev);\n\n\t\tlima_bcast_enable(dev, frame->num_pp);\n\n\t\tlima_pp_soft_reset_async_wait(ip);\n\n\t\tlima_pp_write_frame(ip, frame->frame, frame->wb);\n\n\t\tfor (i = 0; i < frame->num_pp; i++) {\n\t\t\tstruct lima_ip *ip = pipe->processor[i];\n\n\t\t\tpp_write(LIMA_PP_STACK, frame->fragment_stack_address[i]);\n\t\t\tif (!frame->use_dlbu)\n\t\t\t\tpp_write(LIMA_PP_FRAME, frame->plbu_array_address[i]);\n\t\t}\n\n\t\tpp_write(LIMA_PP_CTRL, LIMA_PP_CTRL_START_RENDERING);\n\t} else {\n\t\tstruct drm_lima_m400_pp_frame *frame = task->frame;\n\t\tint i;\n\n\t\tatomic_set(&pipe->task, frame->num_pp);\n\n\t\tfor (i = 0; i < frame->num_pp; i++) {\n\t\t\tstruct lima_ip *ip = pipe->processor[i];\n\n\t\t\tframe->frame[LIMA_PP_FRAME >> 2] =\n\t\t\t\tframe->plbu_array_address[i];\n\t\t\tframe->frame[LIMA_PP_STACK >> 2] =\n\t\t\t\tframe->fragment_stack_address[i];\n\n\t\t\tlima_pp_soft_reset_async_wait(ip);\n\n\t\t\tlima_pp_write_frame(ip, frame->frame, frame->wb);\n\n\t\t\tpp_write(LIMA_PP_CTRL, LIMA_PP_CTRL_START_RENDERING);\n\t\t}\n\t}\n}\n\nstatic void lima_pp_task_fini(struct lima_sched_pipe *pipe)\n{\n\tif (pipe->bcast_processor)\n\t\tlima_pp_soft_reset_async(pipe->bcast_processor);\n\telse {\n\t\tint i;\n\n\t\tfor (i = 0; i < pipe->num_processor; i++)\n\t\t\tlima_pp_soft_reset_async(pipe->processor[i]);\n\t}\n}\n\nstatic void lima_pp_task_error(struct lima_sched_pipe *pipe)\n{\n\tint i;\n\n\tfor (i = 0; i < pipe->num_processor; i++) {\n\t\tstruct lima_ip *ip = pipe->processor[i];\n\n\t\tdev_err(ip->dev->dev, \"pp task error %d int_state=%x status=%x\\n\",\n\t\t\ti, pp_read(LIMA_PP_INT_STATUS), pp_read(LIMA_PP_STATUS));\n\n\t\tlima_pp_hard_reset(ip);\n\t}\n}\n\nstatic void lima_pp_task_mmu_error(struct lima_sched_pipe *pipe)\n{\n\tif (atomic_dec_and_test(&pipe->task))\n\t\tlima_sched_pipe_task_done(pipe);\n}\n\nstatic struct kmem_cache *lima_pp_task_slab;\nstatic int lima_pp_task_slab_refcnt;\n\nint lima_pp_pipe_init(struct lima_device *dev)\n{\n\tint frame_size;\n\tstruct lima_sched_pipe *pipe = dev->pipe + lima_pipe_pp;\n\n\tif (dev->id == lima_gpu_mali400)\n\t\tframe_size = sizeof(struct drm_lima_m400_pp_frame);\n\telse\n\t\tframe_size = sizeof(struct drm_lima_m450_pp_frame);\n\n\tif (!lima_pp_task_slab) {\n\t\tlima_pp_task_slab = kmem_cache_create_usercopy(\n\t\t\t\"lima_pp_task\", sizeof(struct lima_sched_task) + frame_size,\n\t\t\t0, SLAB_HWCACHE_ALIGN, sizeof(struct lima_sched_task),\n\t\t\tframe_size, NULL);\n\t\tif (!lima_pp_task_slab)\n\t\t\treturn -ENOMEM;\n\t}\n\tlima_pp_task_slab_refcnt++;\n\n\tpipe->frame_size = frame_size;\n\tpipe->task_slab = lima_pp_task_slab;\n\n\tpipe->task_validate = lima_pp_task_validate;\n\tpipe->task_run = lima_pp_task_run;\n\tpipe->task_fini = lima_pp_task_fini;\n\tpipe->task_error = lima_pp_task_error;\n\tpipe->task_mmu_error = lima_pp_task_mmu_error;\n\n\treturn 0;\n}\n\nvoid lima_pp_pipe_fini(struct lima_device *dev)\n{\n\tif (!--lima_pp_task_slab_refcnt) {\n\t\tkmem_cache_destroy(lima_pp_task_slab);\n\t\tlima_pp_task_slab = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}