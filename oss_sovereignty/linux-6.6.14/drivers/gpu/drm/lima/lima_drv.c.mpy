{
  "module_name": "lima_drv.c",
  "hash_id": "eb31c9d8e9dbf501ebdf3c060ad746de17f583f76193f4eb8d555bf54ab6659b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/lima/lima_drv.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_prime.h>\n#include <drm/lima_drm.h>\n\n#include \"lima_device.h\"\n#include \"lima_drv.h\"\n#include \"lima_gem.h\"\n#include \"lima_vm.h\"\n\nint lima_sched_timeout_ms;\nuint lima_heap_init_nr_pages = 8;\nuint lima_max_error_tasks;\nuint lima_job_hang_limit;\n\nMODULE_PARM_DESC(sched_timeout_ms, \"task run timeout in ms\");\nmodule_param_named(sched_timeout_ms, lima_sched_timeout_ms, int, 0444);\n\nMODULE_PARM_DESC(heap_init_nr_pages, \"heap buffer init number of pages\");\nmodule_param_named(heap_init_nr_pages, lima_heap_init_nr_pages, uint, 0444);\n\nMODULE_PARM_DESC(max_error_tasks, \"max number of error tasks to save\");\nmodule_param_named(max_error_tasks, lima_max_error_tasks, uint, 0644);\n\nMODULE_PARM_DESC(job_hang_limit, \"number of times to allow a job to hang before dropping it (default 0)\");\nmodule_param_named(job_hang_limit, lima_job_hang_limit, uint, 0444);\n\nstatic int lima_ioctl_get_param(struct drm_device *dev, void *data, struct drm_file *file)\n{\n\tstruct drm_lima_get_param *args = data;\n\tstruct lima_device *ldev = to_lima_dev(dev);\n\n\tif (args->pad)\n\t\treturn -EINVAL;\n\n\tswitch (args->param) {\n\tcase DRM_LIMA_PARAM_GPU_ID:\n\t\tswitch (ldev->id) {\n\t\tcase lima_gpu_mali400:\n\t\t\targs->value = DRM_LIMA_PARAM_GPU_ID_MALI400;\n\t\t\tbreak;\n\t\tcase lima_gpu_mali450:\n\t\t\targs->value = DRM_LIMA_PARAM_GPU_ID_MALI450;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targs->value = DRM_LIMA_PARAM_GPU_ID_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase DRM_LIMA_PARAM_NUM_PP:\n\t\targs->value = ldev->pipe[lima_pipe_pp].num_processor;\n\t\tbreak;\n\n\tcase DRM_LIMA_PARAM_GP_VERSION:\n\t\targs->value = ldev->gp_version;\n\t\tbreak;\n\n\tcase DRM_LIMA_PARAM_PP_VERSION:\n\t\targs->value = ldev->pp_version;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int lima_ioctl_gem_create(struct drm_device *dev, void *data, struct drm_file *file)\n{\n\tstruct drm_lima_gem_create *args = data;\n\n\tif (args->pad)\n\t\treturn -EINVAL;\n\n\tif (args->flags & ~(LIMA_BO_FLAG_HEAP))\n\t\treturn -EINVAL;\n\n\tif (args->size == 0)\n\t\treturn -EINVAL;\n\n\treturn lima_gem_create_handle(dev, file, args->size, args->flags, &args->handle);\n}\n\nstatic int lima_ioctl_gem_info(struct drm_device *dev, void *data, struct drm_file *file)\n{\n\tstruct drm_lima_gem_info *args = data;\n\n\treturn lima_gem_get_info(file, args->handle, &args->va, &args->offset);\n}\n\nstatic int lima_ioctl_gem_submit(struct drm_device *dev, void *data, struct drm_file *file)\n{\n\tstruct drm_lima_gem_submit *args = data;\n\tstruct lima_device *ldev = to_lima_dev(dev);\n\tstruct lima_drm_priv *priv = file->driver_priv;\n\tstruct drm_lima_gem_submit_bo *bos;\n\tstruct lima_sched_pipe *pipe;\n\tstruct lima_sched_task *task;\n\tstruct lima_ctx *ctx;\n\tstruct lima_submit submit = {0};\n\tsize_t size;\n\tint err = 0;\n\n\tif (args->pipe >= lima_pipe_num || args->nr_bos == 0)\n\t\treturn -EINVAL;\n\n\tif (args->flags & ~(LIMA_SUBMIT_FLAG_EXPLICIT_FENCE))\n\t\treturn -EINVAL;\n\n\tpipe = ldev->pipe + args->pipe;\n\tif (args->frame_size != pipe->frame_size)\n\t\treturn -EINVAL;\n\n\tbos = kvcalloc(args->nr_bos, sizeof(*submit.bos) + sizeof(*submit.lbos), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\tsize = args->nr_bos * sizeof(*submit.bos);\n\tif (copy_from_user(bos, u64_to_user_ptr(args->bos), size)) {\n\t\terr = -EFAULT;\n\t\tgoto out0;\n\t}\n\n\ttask = kmem_cache_zalloc(pipe->task_slab, GFP_KERNEL);\n\tif (!task) {\n\t\terr = -ENOMEM;\n\t\tgoto out0;\n\t}\n\n\ttask->frame = task + 1;\n\tif (copy_from_user(task->frame, u64_to_user_ptr(args->frame), args->frame_size)) {\n\t\terr = -EFAULT;\n\t\tgoto out1;\n\t}\n\n\terr = pipe->task_validate(pipe, task);\n\tif (err)\n\t\tgoto out1;\n\n\tctx = lima_ctx_get(&priv->ctx_mgr, args->ctx);\n\tif (!ctx) {\n\t\terr = -ENOENT;\n\t\tgoto out1;\n\t}\n\n\tsubmit.pipe = args->pipe;\n\tsubmit.bos = bos;\n\tsubmit.lbos = (void *)bos + size;\n\tsubmit.nr_bos = args->nr_bos;\n\tsubmit.task = task;\n\tsubmit.ctx = ctx;\n\tsubmit.flags = args->flags;\n\tsubmit.in_sync[0] = args->in_sync[0];\n\tsubmit.in_sync[1] = args->in_sync[1];\n\tsubmit.out_sync = args->out_sync;\n\n\terr = lima_gem_submit(file, &submit);\n\n\tlima_ctx_put(ctx);\nout1:\n\tif (err)\n\t\tkmem_cache_free(pipe->task_slab, task);\nout0:\n\tkvfree(bos);\n\treturn err;\n}\n\nstatic int lima_ioctl_gem_wait(struct drm_device *dev, void *data, struct drm_file *file)\n{\n\tstruct drm_lima_gem_wait *args = data;\n\n\tif (args->op & ~(LIMA_GEM_WAIT_READ|LIMA_GEM_WAIT_WRITE))\n\t\treturn -EINVAL;\n\n\treturn lima_gem_wait(file, args->handle, args->op, args->timeout_ns);\n}\n\nstatic int lima_ioctl_ctx_create(struct drm_device *dev, void *data, struct drm_file *file)\n{\n\tstruct drm_lima_ctx_create *args = data;\n\tstruct lima_drm_priv *priv = file->driver_priv;\n\tstruct lima_device *ldev = to_lima_dev(dev);\n\n\tif (args->_pad)\n\t\treturn -EINVAL;\n\n\treturn lima_ctx_create(ldev, &priv->ctx_mgr, &args->id);\n}\n\nstatic int lima_ioctl_ctx_free(struct drm_device *dev, void *data, struct drm_file *file)\n{\n\tstruct drm_lima_ctx_create *args = data;\n\tstruct lima_drm_priv *priv = file->driver_priv;\n\n\tif (args->_pad)\n\t\treturn -EINVAL;\n\n\treturn lima_ctx_free(&priv->ctx_mgr, args->id);\n}\n\nstatic int lima_drm_driver_open(struct drm_device *dev, struct drm_file *file)\n{\n\tint err;\n\tstruct lima_drm_priv *priv;\n\tstruct lima_device *ldev = to_lima_dev(dev);\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->vm = lima_vm_create(ldev);\n\tif (!priv->vm) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out0;\n\t}\n\n\tlima_ctx_mgr_init(&priv->ctx_mgr);\n\n\tfile->driver_priv = priv;\n\treturn 0;\n\nerr_out0:\n\tkfree(priv);\n\treturn err;\n}\n\nstatic void lima_drm_driver_postclose(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct lima_drm_priv *priv = file->driver_priv;\n\n\tlima_ctx_mgr_fini(&priv->ctx_mgr);\n\tlima_vm_put(priv->vm);\n\tkfree(priv);\n}\n\nstatic const struct drm_ioctl_desc lima_drm_driver_ioctls[] = {\n\tDRM_IOCTL_DEF_DRV(LIMA_GET_PARAM, lima_ioctl_get_param, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(LIMA_GEM_CREATE, lima_ioctl_gem_create, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(LIMA_GEM_INFO, lima_ioctl_gem_info, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(LIMA_GEM_SUBMIT, lima_ioctl_gem_submit, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(LIMA_GEM_WAIT, lima_ioctl_gem_wait, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(LIMA_CTX_CREATE, lima_ioctl_ctx_create, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(LIMA_CTX_FREE, lima_ioctl_ctx_free, DRM_RENDER_ALLOW),\n};\n\nDEFINE_DRM_GEM_FOPS(lima_drm_driver_fops);\n\n \n\nstatic const struct drm_driver lima_drm_driver = {\n\t.driver_features    = DRIVER_RENDER | DRIVER_GEM | DRIVER_SYNCOBJ,\n\t.open               = lima_drm_driver_open,\n\t.postclose          = lima_drm_driver_postclose,\n\t.ioctls             = lima_drm_driver_ioctls,\n\t.num_ioctls         = ARRAY_SIZE(lima_drm_driver_ioctls),\n\t.fops               = &lima_drm_driver_fops,\n\t.name               = \"lima\",\n\t.desc               = \"lima DRM\",\n\t.date               = \"20191231\",\n\t.major              = 1,\n\t.minor              = 1,\n\t.patchlevel         = 0,\n\n\t.gem_create_object  = lima_gem_create_object,\n\t.gem_prime_import_sg_table = drm_gem_shmem_prime_import_sg_table,\n};\n\nstruct lima_block_reader {\n\tvoid *dst;\n\tsize_t base;\n\tsize_t count;\n\tsize_t off;\n\tssize_t read;\n};\n\nstatic bool lima_read_block(struct lima_block_reader *reader,\n\t\t\t    void *src, size_t src_size)\n{\n\tsize_t max_off = reader->base + src_size;\n\n\tif (reader->off < max_off) {\n\t\tsize_t size = min_t(size_t, max_off - reader->off,\n\t\t\t\t    reader->count);\n\n\t\tmemcpy(reader->dst, src + (reader->off - reader->base), size);\n\n\t\treader->dst += size;\n\t\treader->off += size;\n\t\treader->read += size;\n\t\treader->count -= size;\n\t}\n\n\treader->base = max_off;\n\n\treturn !!reader->count;\n}\n\nstatic ssize_t lima_error_state_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *attr, char *buf,\n\t\t\t\t     loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct lima_device *ldev = dev_get_drvdata(dev);\n\tstruct lima_sched_error_task *et;\n\tstruct lima_block_reader reader = {\n\t\t.dst = buf,\n\t\t.count = count,\n\t\t.off = off,\n\t};\n\n\tmutex_lock(&ldev->error_task_list_lock);\n\n\tif (lima_read_block(&reader, &ldev->dump, sizeof(ldev->dump))) {\n\t\tlist_for_each_entry(et, &ldev->error_task_list, list) {\n\t\t\tif (!lima_read_block(&reader, et->data, et->size))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&ldev->error_task_list_lock);\n\treturn reader.read;\n}\n\nstatic ssize_t lima_error_state_write(struct file *file, struct kobject *kobj,\n\t\t\t\t      struct bin_attribute *attr, char *buf,\n\t\t\t\t      loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct lima_device *ldev = dev_get_drvdata(dev);\n\tstruct lima_sched_error_task *et, *tmp;\n\n\tmutex_lock(&ldev->error_task_list_lock);\n\n\tlist_for_each_entry_safe(et, tmp, &ldev->error_task_list, list) {\n\t\tlist_del(&et->list);\n\t\tkvfree(et);\n\t}\n\n\tldev->dump.size = 0;\n\tldev->dump.num_tasks = 0;\n\n\tmutex_unlock(&ldev->error_task_list_lock);\n\n\treturn count;\n}\n\nstatic const struct bin_attribute lima_error_state_attr = {\n\t.attr.name = \"error\",\n\t.attr.mode = 0600,\n\t.size = 0,\n\t.read = lima_error_state_read,\n\t.write = lima_error_state_write,\n};\n\nstatic int lima_pdev_probe(struct platform_device *pdev)\n{\n\tstruct lima_device *ldev;\n\tstruct drm_device *ddev;\n\tint err;\n\n\terr = lima_sched_slab_init();\n\tif (err)\n\t\treturn err;\n\n\tldev = devm_kzalloc(&pdev->dev, sizeof(*ldev), GFP_KERNEL);\n\tif (!ldev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out0;\n\t}\n\n\tldev->dev = &pdev->dev;\n\tldev->id = (enum lima_gpu_id)of_device_get_match_data(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, ldev);\n\n\t \n\tddev = drm_dev_alloc(&lima_drm_driver, &pdev->dev);\n\tif (IS_ERR(ddev)) {\n\t\terr = PTR_ERR(ddev);\n\t\tgoto err_out0;\n\t}\n\n\tddev->dev_private = ldev;\n\tldev->ddev = ddev;\n\n\terr = lima_device_init(ldev);\n\tif (err)\n\t\tgoto err_out1;\n\n\terr = lima_devfreq_init(ldev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Fatal error during devfreq init\\n\");\n\t\tgoto err_out2;\n\t}\n\n\tpm_runtime_set_active(ldev->dev);\n\tpm_runtime_mark_last_busy(ldev->dev);\n\tpm_runtime_set_autosuspend_delay(ldev->dev, 200);\n\tpm_runtime_use_autosuspend(ldev->dev);\n\tpm_runtime_enable(ldev->dev);\n\n\t \n\terr = drm_dev_register(ddev, 0);\n\tif (err < 0)\n\t\tgoto err_out3;\n\n\tif (sysfs_create_bin_file(&ldev->dev->kobj, &lima_error_state_attr))\n\t\tdev_warn(ldev->dev, \"fail to create error state sysfs\\n\");\n\n\treturn 0;\n\nerr_out3:\n\tpm_runtime_disable(ldev->dev);\n\tlima_devfreq_fini(ldev);\nerr_out2:\n\tlima_device_fini(ldev);\nerr_out1:\n\tdrm_dev_put(ddev);\nerr_out0:\n\tlima_sched_slab_fini();\n\treturn err;\n}\n\nstatic void lima_pdev_remove(struct platform_device *pdev)\n{\n\tstruct lima_device *ldev = platform_get_drvdata(pdev);\n\tstruct drm_device *ddev = ldev->ddev;\n\n\tsysfs_remove_bin_file(&ldev->dev->kobj, &lima_error_state_attr);\n\n\tdrm_dev_unregister(ddev);\n\n\t \n\tpm_runtime_set_autosuspend_delay(ldev->dev, -1);\n\tpm_runtime_disable(ldev->dev);\n\n\tlima_devfreq_fini(ldev);\n\tlima_device_fini(ldev);\n\n\tdrm_dev_put(ddev);\n\tlima_sched_slab_fini();\n}\n\nstatic const struct of_device_id dt_match[] = {\n\t{ .compatible = \"arm,mali-400\", .data = (void *)lima_gpu_mali400 },\n\t{ .compatible = \"arm,mali-450\", .data = (void *)lima_gpu_mali450 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, dt_match);\n\nstatic const struct dev_pm_ops lima_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(lima_device_suspend, lima_device_resume, NULL)\n};\n\nstatic struct platform_driver lima_platform_driver = {\n\t.probe      = lima_pdev_probe,\n\t.remove_new = lima_pdev_remove,\n\t.driver     = {\n\t\t.name   = \"lima\",\n\t\t.pm\t= &lima_pm_ops,\n\t\t.of_match_table = dt_match,\n\t},\n};\n\nmodule_platform_driver(lima_platform_driver);\n\nMODULE_AUTHOR(\"Lima Project Developers\");\nMODULE_DESCRIPTION(\"Lima DRM Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}