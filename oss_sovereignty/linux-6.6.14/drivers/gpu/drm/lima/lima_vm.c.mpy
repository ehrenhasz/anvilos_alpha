{
  "module_name": "lima_vm.c",
  "hash_id": "5bffe94097e0e9e72cd6844fb6b565a600865a5cf438976877317dc8d738a68c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/lima/lima_vm.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n\n#include \"lima_device.h\"\n#include \"lima_vm.h\"\n#include \"lima_gem.h\"\n#include \"lima_regs.h\"\n\nstruct lima_bo_va {\n\tstruct list_head list;\n\tunsigned int ref_count;\n\n\tstruct drm_mm_node node;\n\n\tstruct lima_vm *vm;\n};\n\n#define LIMA_VM_PD_SHIFT 22\n#define LIMA_VM_PT_SHIFT 12\n#define LIMA_VM_PB_SHIFT (LIMA_VM_PD_SHIFT + LIMA_VM_NUM_PT_PER_BT_SHIFT)\n#define LIMA_VM_BT_SHIFT LIMA_VM_PT_SHIFT\n\n#define LIMA_VM_PT_MASK ((1 << LIMA_VM_PD_SHIFT) - 1)\n#define LIMA_VM_BT_MASK ((1 << LIMA_VM_PB_SHIFT) - 1)\n\n#define LIMA_PDE(va) (va >> LIMA_VM_PD_SHIFT)\n#define LIMA_PTE(va) ((va & LIMA_VM_PT_MASK) >> LIMA_VM_PT_SHIFT)\n#define LIMA_PBE(va) (va >> LIMA_VM_PB_SHIFT)\n#define LIMA_BTE(va) ((va & LIMA_VM_BT_MASK) >> LIMA_VM_BT_SHIFT)\n\n\nstatic void lima_vm_unmap_range(struct lima_vm *vm, u32 start, u32 end)\n{\n\tu32 addr;\n\n\tfor (addr = start; addr <= end; addr += LIMA_PAGE_SIZE) {\n\t\tu32 pbe = LIMA_PBE(addr);\n\t\tu32 bte = LIMA_BTE(addr);\n\n\t\tvm->bts[pbe].cpu[bte] = 0;\n\t}\n}\n\nstatic int lima_vm_map_page(struct lima_vm *vm, dma_addr_t pa, u32 va)\n{\n\tu32 pbe = LIMA_PBE(va);\n\tu32 bte = LIMA_BTE(va);\n\n\tif (!vm->bts[pbe].cpu) {\n\t\tdma_addr_t pts;\n\t\tu32 *pd;\n\t\tint j;\n\n\t\tvm->bts[pbe].cpu = dma_alloc_wc(\n\t\t\tvm->dev->dev, LIMA_PAGE_SIZE << LIMA_VM_NUM_PT_PER_BT_SHIFT,\n\t\t\t&vm->bts[pbe].dma, GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);\n\t\tif (!vm->bts[pbe].cpu)\n\t\t\treturn -ENOMEM;\n\n\t\tpts = vm->bts[pbe].dma;\n\t\tpd = vm->pd.cpu + (pbe << LIMA_VM_NUM_PT_PER_BT_SHIFT);\n\t\tfor (j = 0; j < LIMA_VM_NUM_PT_PER_BT; j++) {\n\t\t\tpd[j] = pts | LIMA_VM_FLAG_PRESENT;\n\t\t\tpts += LIMA_PAGE_SIZE;\n\t\t}\n\t}\n\n\tvm->bts[pbe].cpu[bte] = pa | LIMA_VM_FLAGS_CACHE;\n\n\treturn 0;\n}\n\nstatic struct lima_bo_va *\nlima_vm_bo_find(struct lima_vm *vm, struct lima_bo *bo)\n{\n\tstruct lima_bo_va *bo_va, *ret = NULL;\n\n\tlist_for_each_entry(bo_va, &bo->va, list) {\n\t\tif (bo_va->vm == vm) {\n\t\t\tret = bo_va;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint lima_vm_bo_add(struct lima_vm *vm, struct lima_bo *bo, bool create)\n{\n\tstruct lima_bo_va *bo_va;\n\tstruct sg_dma_page_iter sg_iter;\n\tint offset = 0, err;\n\n\tmutex_lock(&bo->lock);\n\n\tbo_va = lima_vm_bo_find(vm, bo);\n\tif (bo_va) {\n\t\tbo_va->ref_count++;\n\t\tmutex_unlock(&bo->lock);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!create) {\n\t\tmutex_unlock(&bo->lock);\n\t\treturn -ENOENT;\n\t}\n\n\tbo_va = kzalloc(sizeof(*bo_va), GFP_KERNEL);\n\tif (!bo_va) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out0;\n\t}\n\n\tbo_va->vm = vm;\n\tbo_va->ref_count = 1;\n\n\tmutex_lock(&vm->lock);\n\n\terr = drm_mm_insert_node(&vm->mm, &bo_va->node, lima_bo_size(bo));\n\tif (err)\n\t\tgoto err_out1;\n\n\tfor_each_sgtable_dma_page(bo->base.sgt, &sg_iter, 0) {\n\t\terr = lima_vm_map_page(vm, sg_page_iter_dma_address(&sg_iter),\n\t\t\t\t       bo_va->node.start + offset);\n\t\tif (err)\n\t\t\tgoto err_out2;\n\n\t\toffset += PAGE_SIZE;\n\t}\n\n\tmutex_unlock(&vm->lock);\n\n\tlist_add_tail(&bo_va->list, &bo->va);\n\n\tmutex_unlock(&bo->lock);\n\treturn 0;\n\nerr_out2:\n\tif (offset)\n\t\tlima_vm_unmap_range(vm, bo_va->node.start, bo_va->node.start + offset - 1);\n\tdrm_mm_remove_node(&bo_va->node);\nerr_out1:\n\tmutex_unlock(&vm->lock);\n\tkfree(bo_va);\nerr_out0:\n\tmutex_unlock(&bo->lock);\n\treturn err;\n}\n\nvoid lima_vm_bo_del(struct lima_vm *vm, struct lima_bo *bo)\n{\n\tstruct lima_bo_va *bo_va;\n\tu32 size;\n\n\tmutex_lock(&bo->lock);\n\n\tbo_va = lima_vm_bo_find(vm, bo);\n\tif (--bo_va->ref_count > 0) {\n\t\tmutex_unlock(&bo->lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&vm->lock);\n\n\tsize = bo->heap_size ? bo->heap_size : bo_va->node.size;\n\tlima_vm_unmap_range(vm, bo_va->node.start,\n\t\t\t    bo_va->node.start + size - 1);\n\n\tdrm_mm_remove_node(&bo_va->node);\n\n\tmutex_unlock(&vm->lock);\n\n\tlist_del(&bo_va->list);\n\n\tmutex_unlock(&bo->lock);\n\n\tkfree(bo_va);\n}\n\nu32 lima_vm_get_va(struct lima_vm *vm, struct lima_bo *bo)\n{\n\tstruct lima_bo_va *bo_va;\n\tu32 ret;\n\n\tmutex_lock(&bo->lock);\n\n\tbo_va = lima_vm_bo_find(vm, bo);\n\tret = bo_va->node.start;\n\n\tmutex_unlock(&bo->lock);\n\n\treturn ret;\n}\n\nstruct lima_vm *lima_vm_create(struct lima_device *dev)\n{\n\tstruct lima_vm *vm;\n\n\tvm = kzalloc(sizeof(*vm), GFP_KERNEL);\n\tif (!vm)\n\t\treturn NULL;\n\n\tvm->dev = dev;\n\tmutex_init(&vm->lock);\n\tkref_init(&vm->refcount);\n\n\tvm->pd.cpu = dma_alloc_wc(dev->dev, LIMA_PAGE_SIZE, &vm->pd.dma,\n\t\t\t\t  GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);\n\tif (!vm->pd.cpu)\n\t\tgoto err_out0;\n\n\tif (dev->dlbu_cpu) {\n\t\tint err = lima_vm_map_page(\n\t\t\tvm, dev->dlbu_dma, LIMA_VA_RESERVE_DLBU);\n\t\tif (err)\n\t\t\tgoto err_out1;\n\t}\n\n\tdrm_mm_init(&vm->mm, dev->va_start, dev->va_end - dev->va_start);\n\n\treturn vm;\n\nerr_out1:\n\tdma_free_wc(dev->dev, LIMA_PAGE_SIZE, vm->pd.cpu, vm->pd.dma);\nerr_out0:\n\tkfree(vm);\n\treturn NULL;\n}\n\nvoid lima_vm_release(struct kref *kref)\n{\n\tstruct lima_vm *vm = container_of(kref, struct lima_vm, refcount);\n\tint i;\n\n\tdrm_mm_takedown(&vm->mm);\n\n\tfor (i = 0; i < LIMA_VM_NUM_BT; i++) {\n\t\tif (vm->bts[i].cpu)\n\t\t\tdma_free_wc(vm->dev->dev, LIMA_PAGE_SIZE << LIMA_VM_NUM_PT_PER_BT_SHIFT,\n\t\t\t\t    vm->bts[i].cpu, vm->bts[i].dma);\n\t}\n\n\tif (vm->pd.cpu)\n\t\tdma_free_wc(vm->dev->dev, LIMA_PAGE_SIZE, vm->pd.cpu, vm->pd.dma);\n\n\tkfree(vm);\n}\n\nvoid lima_vm_print(struct lima_vm *vm)\n{\n\tint i, j, k;\n\tu32 *pd, *pt;\n\n\tif (!vm->pd.cpu)\n\t\treturn;\n\n\tpd = vm->pd.cpu;\n\tfor (i = 0; i < LIMA_VM_NUM_BT; i++) {\n\t\tif (!vm->bts[i].cpu)\n\t\t\tcontinue;\n\n\t\tpt = vm->bts[i].cpu;\n\t\tfor (j = 0; j < LIMA_VM_NUM_PT_PER_BT; j++) {\n\t\t\tint idx = (i << LIMA_VM_NUM_PT_PER_BT_SHIFT) + j;\n\n\t\t\tprintk(KERN_INFO \"lima vm pd %03x:%08x\\n\", idx, pd[idx]);\n\n\t\t\tfor (k = 0; k < LIMA_PAGE_ENT_NUM; k++) {\n\t\t\t\tu32 pte = *pt++;\n\n\t\t\t\tif (pte)\n\t\t\t\t\tprintk(KERN_INFO \"  pt %03x:%08x\\n\", k, pte);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint lima_vm_map_bo(struct lima_vm *vm, struct lima_bo *bo, int pageoff)\n{\n\tstruct lima_bo_va *bo_va;\n\tstruct sg_dma_page_iter sg_iter;\n\tint offset = 0, err;\n\tu32 base;\n\n\tmutex_lock(&bo->lock);\n\n\tbo_va = lima_vm_bo_find(vm, bo);\n\tif (!bo_va) {\n\t\terr = -ENOENT;\n\t\tgoto err_out0;\n\t}\n\n\tmutex_lock(&vm->lock);\n\n\tbase = bo_va->node.start + (pageoff << PAGE_SHIFT);\n\tfor_each_sgtable_dma_page(bo->base.sgt, &sg_iter, pageoff) {\n\t\terr = lima_vm_map_page(vm, sg_page_iter_dma_address(&sg_iter),\n\t\t\t\t       base + offset);\n\t\tif (err)\n\t\t\tgoto err_out1;\n\n\t\toffset += PAGE_SIZE;\n\t}\n\n\tmutex_unlock(&vm->lock);\n\n\tmutex_unlock(&bo->lock);\n\treturn 0;\n\nerr_out1:\n\tif (offset)\n\t\tlima_vm_unmap_range(vm, base, base + offset - 1);\n\tmutex_unlock(&vm->lock);\nerr_out0:\n\tmutex_unlock(&bo->lock);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}