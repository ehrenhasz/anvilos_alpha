{
  "module_name": "lima_gp.c",
  "hash_id": "50ddee3c8fad80bd077e03d4eef2f27035117a5f474a139e0c2aa7427b2faa90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/lima/lima_gp.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n\n#include <drm/lima_drm.h>\n\n#include \"lima_device.h\"\n#include \"lima_gp.h\"\n#include \"lima_regs.h\"\n#include \"lima_gem.h\"\n#include \"lima_vm.h\"\n\n#define gp_write(reg, data) writel(data, ip->iomem + reg)\n#define gp_read(reg) readl(ip->iomem + reg)\n\nstatic irqreturn_t lima_gp_irq_handler(int irq, void *data)\n{\n\tstruct lima_ip *ip = data;\n\tstruct lima_device *dev = ip->dev;\n\tstruct lima_sched_pipe *pipe = dev->pipe + lima_pipe_gp;\n\tstruct lima_sched_task *task = pipe->current_task;\n\tu32 state = gp_read(LIMA_GP_INT_STAT);\n\tu32 status = gp_read(LIMA_GP_STATUS);\n\tbool done = false;\n\n\t \n\tif (!state)\n\t\treturn IRQ_NONE;\n\n\tif (state & LIMA_GP_IRQ_MASK_ERROR) {\n\t\tif ((state & LIMA_GP_IRQ_MASK_ERROR) ==\n\t\t    LIMA_GP_IRQ_PLBU_OUT_OF_MEM) {\n\t\t\tdev_dbg(dev->dev, \"gp out of heap irq status=%x\\n\",\n\t\t\t\tstatus);\n\t\t} else {\n\t\t\tdev_err(dev->dev, \"gp error irq state=%x status=%x\\n\",\n\t\t\t\tstate, status);\n\t\t\tif (task)\n\t\t\t\ttask->recoverable = false;\n\t\t}\n\n\t\t \n\t\tgp_write(LIMA_GP_INT_MASK, 0);\n\n\t\tpipe->error = true;\n\t\tdone = true;\n\t} else {\n\t\tbool valid = state & (LIMA_GP_IRQ_VS_END_CMD_LST |\n\t\t\t\t      LIMA_GP_IRQ_PLBU_END_CMD_LST);\n\t\tbool active = status & (LIMA_GP_STATUS_VS_ACTIVE |\n\t\t\t\t\tLIMA_GP_STATUS_PLBU_ACTIVE);\n\t\tdone = valid && !active;\n\t\tpipe->error = false;\n\t}\n\n\tgp_write(LIMA_GP_INT_CLEAR, state);\n\n\tif (done)\n\t\tlima_sched_pipe_task_done(pipe);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void lima_gp_soft_reset_async(struct lima_ip *ip)\n{\n\tif (ip->data.async_reset)\n\t\treturn;\n\n\tgp_write(LIMA_GP_INT_MASK, 0);\n\tgp_write(LIMA_GP_INT_CLEAR, LIMA_GP_IRQ_RESET_COMPLETED);\n\tgp_write(LIMA_GP_CMD, LIMA_GP_CMD_SOFT_RESET);\n\tip->data.async_reset = true;\n}\n\nstatic int lima_gp_soft_reset_async_wait(struct lima_ip *ip)\n{\n\tstruct lima_device *dev = ip->dev;\n\tint err;\n\tu32 v;\n\n\tif (!ip->data.async_reset)\n\t\treturn 0;\n\n\terr = readl_poll_timeout(ip->iomem + LIMA_GP_INT_RAWSTAT, v,\n\t\t\t\t v & LIMA_GP_IRQ_RESET_COMPLETED,\n\t\t\t\t 0, 100);\n\tif (err) {\n\t\tdev_err(dev->dev, \"gp soft reset time out\\n\");\n\t\treturn err;\n\t}\n\n\tgp_write(LIMA_GP_INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);\n\tgp_write(LIMA_GP_INT_MASK, LIMA_GP_IRQ_MASK_USED);\n\n\tip->data.async_reset = false;\n\treturn 0;\n}\n\nstatic int lima_gp_task_validate(struct lima_sched_pipe *pipe,\n\t\t\t\t struct lima_sched_task *task)\n{\n\tstruct drm_lima_gp_frame *frame = task->frame;\n\tu32 *f = frame->frame;\n\t(void)pipe;\n\n\tif (f[LIMA_GP_VSCL_START_ADDR >> 2] >\n\t    f[LIMA_GP_VSCL_END_ADDR >> 2] ||\n\t    f[LIMA_GP_PLBUCL_START_ADDR >> 2] >\n\t    f[LIMA_GP_PLBUCL_END_ADDR >> 2] ||\n\t    f[LIMA_GP_PLBU_ALLOC_START_ADDR >> 2] >\n\t    f[LIMA_GP_PLBU_ALLOC_END_ADDR >> 2])\n\t\treturn -EINVAL;\n\n\tif (f[LIMA_GP_VSCL_START_ADDR >> 2] ==\n\t    f[LIMA_GP_VSCL_END_ADDR >> 2] &&\n\t    f[LIMA_GP_PLBUCL_START_ADDR >> 2] ==\n\t    f[LIMA_GP_PLBUCL_END_ADDR >> 2])\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void lima_gp_task_run(struct lima_sched_pipe *pipe,\n\t\t\t     struct lima_sched_task *task)\n{\n\tstruct lima_ip *ip = pipe->processor[0];\n\tstruct drm_lima_gp_frame *frame = task->frame;\n\tu32 *f = frame->frame;\n\tu32 cmd = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < task->num_bos; i++) {\n\t\tstruct lima_bo *bo = task->bos[i];\n\n\t\tif (bo->heap_size &&\n\t\t    lima_vm_get_va(task->vm, bo) ==\n\t\t    f[LIMA_GP_PLBU_ALLOC_START_ADDR >> 2]) {\n\t\t\tf[LIMA_GP_PLBU_ALLOC_END_ADDR >> 2] =\n\t\t\t\tf[LIMA_GP_PLBU_ALLOC_START_ADDR >> 2] +\n\t\t\t\tbo->heap_size;\n\t\t\ttask->recoverable = true;\n\t\t\ttask->heap = bo;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (f[LIMA_GP_VSCL_START_ADDR >> 2] !=\n\t    f[LIMA_GP_VSCL_END_ADDR >> 2])\n\t\tcmd |= LIMA_GP_CMD_START_VS;\n\tif (f[LIMA_GP_PLBUCL_START_ADDR >> 2] !=\n\t    f[LIMA_GP_PLBUCL_END_ADDR >> 2])\n\t\tcmd |= LIMA_GP_CMD_START_PLBU;\n\n\t \n\tlima_gp_soft_reset_async_wait(ip);\n\n\tfor (i = 0; i < LIMA_GP_FRAME_REG_NUM; i++)\n\t\twritel(f[i], ip->iomem + LIMA_GP_VSCL_START_ADDR + i * 4);\n\n\tgp_write(LIMA_GP_CMD, LIMA_GP_CMD_UPDATE_PLBU_ALLOC);\n\tgp_write(LIMA_GP_CMD, cmd);\n}\n\nstatic int lima_gp_hard_reset_poll(struct lima_ip *ip)\n{\n\tgp_write(LIMA_GP_PERF_CNT_0_LIMIT, 0xC01A0000);\n\treturn gp_read(LIMA_GP_PERF_CNT_0_LIMIT) == 0xC01A0000;\n}\n\nstatic int lima_gp_hard_reset(struct lima_ip *ip)\n{\n\tstruct lima_device *dev = ip->dev;\n\tint ret;\n\n\tgp_write(LIMA_GP_PERF_CNT_0_LIMIT, 0xC0FFE000);\n\tgp_write(LIMA_GP_INT_MASK, 0);\n\tgp_write(LIMA_GP_CMD, LIMA_GP_CMD_RESET);\n\tret = lima_poll_timeout(ip, lima_gp_hard_reset_poll, 10, 100);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"gp hard reset timeout\\n\");\n\t\treturn ret;\n\t}\n\n\tgp_write(LIMA_GP_PERF_CNT_0_LIMIT, 0);\n\tgp_write(LIMA_GP_INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);\n\tgp_write(LIMA_GP_INT_MASK, LIMA_GP_IRQ_MASK_USED);\n\treturn 0;\n}\n\nstatic void lima_gp_task_fini(struct lima_sched_pipe *pipe)\n{\n\tlima_gp_soft_reset_async(pipe->processor[0]);\n}\n\nstatic void lima_gp_task_error(struct lima_sched_pipe *pipe)\n{\n\tstruct lima_ip *ip = pipe->processor[0];\n\n\tdev_err(ip->dev->dev, \"gp task error int_state=%x status=%x\\n\",\n\t\tgp_read(LIMA_GP_INT_STAT), gp_read(LIMA_GP_STATUS));\n\n\tlima_gp_hard_reset(ip);\n}\n\nstatic void lima_gp_task_mmu_error(struct lima_sched_pipe *pipe)\n{\n\tlima_sched_pipe_task_done(pipe);\n}\n\nstatic int lima_gp_task_recover(struct lima_sched_pipe *pipe)\n{\n\tstruct lima_ip *ip = pipe->processor[0];\n\tstruct lima_sched_task *task = pipe->current_task;\n\tstruct drm_lima_gp_frame *frame = task->frame;\n\tu32 *f = frame->frame;\n\tsize_t fail_size =\n\t\tf[LIMA_GP_PLBU_ALLOC_END_ADDR >> 2] -\n\t\tf[LIMA_GP_PLBU_ALLOC_START_ADDR >> 2];\n\n\tif (fail_size == task->heap->heap_size) {\n\t\tint ret;\n\n\t\tret = lima_heap_alloc(task->heap, task->vm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tgp_write(LIMA_GP_INT_MASK, LIMA_GP_IRQ_MASK_USED);\n\t \n\tgp_write(LIMA_GP_PLBU_ALLOC_START_ADDR,\n\t\t f[LIMA_GP_PLBU_ALLOC_END_ADDR >> 2]);\n\tf[LIMA_GP_PLBU_ALLOC_END_ADDR >> 2] =\n\t\tf[LIMA_GP_PLBU_ALLOC_START_ADDR >> 2] + task->heap->heap_size;\n\tgp_write(LIMA_GP_PLBU_ALLOC_END_ADDR,\n\t\t f[LIMA_GP_PLBU_ALLOC_END_ADDR >> 2]);\n\tgp_write(LIMA_GP_CMD, LIMA_GP_CMD_UPDATE_PLBU_ALLOC);\n\treturn 0;\n}\n\nstatic void lima_gp_print_version(struct lima_ip *ip)\n{\n\tu32 version, major, minor;\n\tchar *name;\n\n\tversion = gp_read(LIMA_GP_VERSION);\n\tmajor = (version >> 8) & 0xFF;\n\tminor = version & 0xFF;\n\tswitch (version >> 16) {\n\tcase 0xA07:\n\t    name = \"mali200\";\n\t\tbreak;\n\tcase 0xC07:\n\t\tname = \"mali300\";\n\t\tbreak;\n\tcase 0xB07:\n\t\tname = \"mali400\";\n\t\tbreak;\n\tcase 0xD07:\n\t\tname = \"mali450\";\n\t\tbreak;\n\tdefault:\n\t\tname = \"unknown\";\n\t\tbreak;\n\t}\n\tdev_info(ip->dev->dev, \"%s - %s version major %d minor %d\\n\",\n\t\t lima_ip_name(ip), name, major, minor);\n}\n\nstatic struct kmem_cache *lima_gp_task_slab;\nstatic int lima_gp_task_slab_refcnt;\n\nstatic int lima_gp_hw_init(struct lima_ip *ip)\n{\n\tip->data.async_reset = false;\n\tlima_gp_soft_reset_async(ip);\n\treturn lima_gp_soft_reset_async_wait(ip);\n}\n\nint lima_gp_resume(struct lima_ip *ip)\n{\n\treturn lima_gp_hw_init(ip);\n}\n\nvoid lima_gp_suspend(struct lima_ip *ip)\n{\n\n}\n\nint lima_gp_init(struct lima_ip *ip)\n{\n\tstruct lima_device *dev = ip->dev;\n\tint err;\n\n\tlima_gp_print_version(ip);\n\n\terr = lima_gp_hw_init(ip);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_request_irq(dev->dev, ip->irq, lima_gp_irq_handler,\n\t\t\t       IRQF_SHARED, lima_ip_name(ip), ip);\n\tif (err) {\n\t\tdev_err(dev->dev, \"gp %s fail to request irq\\n\",\n\t\t\tlima_ip_name(ip));\n\t\treturn err;\n\t}\n\n\tdev->gp_version = gp_read(LIMA_GP_VERSION);\n\n\treturn 0;\n}\n\nvoid lima_gp_fini(struct lima_ip *ip)\n{\n\n}\n\nint lima_gp_pipe_init(struct lima_device *dev)\n{\n\tint frame_size = sizeof(struct drm_lima_gp_frame);\n\tstruct lima_sched_pipe *pipe = dev->pipe + lima_pipe_gp;\n\n\tif (!lima_gp_task_slab) {\n\t\tlima_gp_task_slab = kmem_cache_create_usercopy(\n\t\t\t\"lima_gp_task\", sizeof(struct lima_sched_task) + frame_size,\n\t\t\t0, SLAB_HWCACHE_ALIGN, sizeof(struct lima_sched_task),\n\t\t\tframe_size, NULL);\n\t\tif (!lima_gp_task_slab)\n\t\t\treturn -ENOMEM;\n\t}\n\tlima_gp_task_slab_refcnt++;\n\n\tpipe->frame_size = frame_size;\n\tpipe->task_slab = lima_gp_task_slab;\n\n\tpipe->task_validate = lima_gp_task_validate;\n\tpipe->task_run = lima_gp_task_run;\n\tpipe->task_fini = lima_gp_task_fini;\n\tpipe->task_error = lima_gp_task_error;\n\tpipe->task_mmu_error = lima_gp_task_mmu_error;\n\tpipe->task_recover = lima_gp_task_recover;\n\n\treturn 0;\n}\n\nvoid lima_gp_pipe_fini(struct lima_device *dev)\n{\n\tif (!--lima_gp_task_slab_refcnt) {\n\t\tkmem_cache_destroy(lima_gp_task_slab);\n\t\tlima_gp_task_slab = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}