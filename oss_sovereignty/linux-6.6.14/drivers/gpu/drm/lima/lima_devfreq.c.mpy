{
  "module_name": "lima_devfreq.c",
  "hash_id": "67b175f5d8dd0598952a181a3d2ad02bcfac81330c2a202faccf3154e39b0c55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/lima/lima_devfreq.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/devfreq.h>\n#include <linux/devfreq_cooling.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/property.h>\n\n#include \"lima_device.h\"\n#include \"lima_devfreq.h\"\n\nstatic void lima_devfreq_update_utilization(struct lima_devfreq *devfreq)\n{\n\tktime_t now, last;\n\n\tnow = ktime_get();\n\tlast = devfreq->time_last_update;\n\n\tif (devfreq->busy_count > 0)\n\t\tdevfreq->busy_time += ktime_sub(now, last);\n\telse\n\t\tdevfreq->idle_time += ktime_sub(now, last);\n\n\tdevfreq->time_last_update = now;\n}\n\nstatic int lima_devfreq_target(struct device *dev, unsigned long *freq,\n\t\t\t       u32 flags)\n{\n\tstruct dev_pm_opp *opp;\n\n\topp = devfreq_recommended_opp(dev, freq, flags);\n\tif (IS_ERR(opp))\n\t\treturn PTR_ERR(opp);\n\tdev_pm_opp_put(opp);\n\n\treturn dev_pm_opp_set_rate(dev, *freq);\n}\n\nstatic void lima_devfreq_reset(struct lima_devfreq *devfreq)\n{\n\tdevfreq->busy_time = 0;\n\tdevfreq->idle_time = 0;\n\tdevfreq->time_last_update = ktime_get();\n}\n\nstatic int lima_devfreq_get_dev_status(struct device *dev,\n\t\t\t\t       struct devfreq_dev_status *status)\n{\n\tstruct lima_device *ldev = dev_get_drvdata(dev);\n\tstruct lima_devfreq *devfreq = &ldev->devfreq;\n\tunsigned long irqflags;\n\n\tstatus->current_frequency = clk_get_rate(ldev->clk_gpu);\n\n\tspin_lock_irqsave(&devfreq->lock, irqflags);\n\n\tlima_devfreq_update_utilization(devfreq);\n\n\tstatus->total_time = ktime_to_ns(ktime_add(devfreq->busy_time,\n\t\t\t\t\t\t   devfreq->idle_time));\n\tstatus->busy_time = ktime_to_ns(devfreq->busy_time);\n\n\tlima_devfreq_reset(devfreq);\n\n\tspin_unlock_irqrestore(&devfreq->lock, irqflags);\n\n\tdev_dbg(ldev->dev, \"busy %lu total %lu %lu %% freq %lu MHz\\n\",\n\t\tstatus->busy_time, status->total_time,\n\t\tstatus->busy_time / (status->total_time / 100),\n\t\tstatus->current_frequency / 1000 / 1000);\n\n\treturn 0;\n}\n\nstatic struct devfreq_dev_profile lima_devfreq_profile = {\n\t.timer = DEVFREQ_TIMER_DELAYED,\n\t.polling_ms = 50,  \n\t.target = lima_devfreq_target,\n\t.get_dev_status = lima_devfreq_get_dev_status,\n};\n\nvoid lima_devfreq_fini(struct lima_device *ldev)\n{\n\tstruct lima_devfreq *devfreq = &ldev->devfreq;\n\n\tif (devfreq->cooling) {\n\t\tdevfreq_cooling_unregister(devfreq->cooling);\n\t\tdevfreq->cooling = NULL;\n\t}\n\n\tif (devfreq->devfreq) {\n\t\tdevm_devfreq_remove_device(ldev->dev, devfreq->devfreq);\n\t\tdevfreq->devfreq = NULL;\n\t}\n}\n\nint lima_devfreq_init(struct lima_device *ldev)\n{\n\tstruct thermal_cooling_device *cooling;\n\tstruct device *dev = ldev->dev;\n\tstruct devfreq *devfreq;\n\tstruct lima_devfreq *ldevfreq = &ldev->devfreq;\n\tstruct dev_pm_opp *opp;\n\tunsigned long cur_freq;\n\tint ret;\n\tconst char *regulator_names[] = { \"mali\", NULL };\n\n\tif (!device_property_present(dev, \"operating-points-v2\"))\n\t\t \n\t\treturn 0;\n\n\tspin_lock_init(&ldevfreq->lock);\n\n\t \n\tret = devm_pm_opp_set_clkname(dev, \"core\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_pm_opp_set_regulators(dev, regulator_names);\n\tif (ret) {\n\t\t \n\t\tif (ret != -ENODEV)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_pm_opp_of_add_table(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tlima_devfreq_reset(ldevfreq);\n\n\tcur_freq = clk_get_rate(ldev->clk_gpu);\n\n\topp = devfreq_recommended_opp(dev, &cur_freq, 0);\n\tif (IS_ERR(opp))\n\t\treturn PTR_ERR(opp);\n\n\tlima_devfreq_profile.initial_freq = cur_freq;\n\tdev_pm_opp_put(opp);\n\n\t \n\tldevfreq->gov_data.upthreshold = 30;\n\tldevfreq->gov_data.downdifferential = 5;\n\n\tdevfreq = devm_devfreq_add_device(dev, &lima_devfreq_profile,\n\t\t\t\t\t  DEVFREQ_GOV_SIMPLE_ONDEMAND,\n\t\t\t\t\t  &ldevfreq->gov_data);\n\tif (IS_ERR(devfreq)) {\n\t\tdev_err(dev, \"Couldn't initialize GPU devfreq\\n\");\n\t\treturn PTR_ERR(devfreq);\n\t}\n\n\tldevfreq->devfreq = devfreq;\n\n\tcooling = of_devfreq_cooling_register(dev->of_node, devfreq);\n\tif (IS_ERR(cooling))\n\t\tdev_info(dev, \"Failed to register cooling device\\n\");\n\telse\n\t\tldevfreq->cooling = cooling;\n\n\treturn 0;\n}\n\nvoid lima_devfreq_record_busy(struct lima_devfreq *devfreq)\n{\n\tunsigned long irqflags;\n\n\tif (!devfreq->devfreq)\n\t\treturn;\n\n\tspin_lock_irqsave(&devfreq->lock, irqflags);\n\n\tlima_devfreq_update_utilization(devfreq);\n\n\tdevfreq->busy_count++;\n\n\tspin_unlock_irqrestore(&devfreq->lock, irqflags);\n}\n\nvoid lima_devfreq_record_idle(struct lima_devfreq *devfreq)\n{\n\tunsigned long irqflags;\n\n\tif (!devfreq->devfreq)\n\t\treturn;\n\n\tspin_lock_irqsave(&devfreq->lock, irqflags);\n\n\tlima_devfreq_update_utilization(devfreq);\n\n\tWARN_ON(--devfreq->busy_count < 0);\n\n\tspin_unlock_irqrestore(&devfreq->lock, irqflags);\n}\n\nint lima_devfreq_resume(struct lima_devfreq *devfreq)\n{\n\tunsigned long irqflags;\n\n\tif (!devfreq->devfreq)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&devfreq->lock, irqflags);\n\n\tlima_devfreq_reset(devfreq);\n\n\tspin_unlock_irqrestore(&devfreq->lock, irqflags);\n\n\treturn devfreq_resume_device(devfreq->devfreq);\n}\n\nint lima_devfreq_suspend(struct lima_devfreq *devfreq)\n{\n\tif (!devfreq->devfreq)\n\t\treturn 0;\n\n\treturn devfreq_suspend_device(devfreq->devfreq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}