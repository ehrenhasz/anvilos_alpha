{
  "module_name": "aspeed_gfx_drv.c",
  "hash_id": "672ee4df37df9a85dc126f7e4dea7674a8a93aece3b6b1ba2a4e73ad155f4727",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/aspeed/aspeed_gfx_drv.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/irq.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_device.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_drv.h>\n\n#include \"aspeed_gfx.h\"\n\n \n\nstruct aspeed_gfx_config {\n\tu32 dac_reg;\t\t \n\tu32 int_clear_reg;\t \n\tu32 vga_scratch_reg;\t \n\tu32 throd_val;\t\t \n\tu32 scan_line_max;\t \n};\n\nstatic const struct aspeed_gfx_config ast2400_config = {\n\t.dac_reg = 0x2c,\n\t.int_clear_reg = 0x60,\n\t.vga_scratch_reg = 0x50,\n\t.throd_val = CRT_THROD_LOW(0x1e) | CRT_THROD_HIGH(0x12),\n\t.scan_line_max = 64,\n};\n\nstatic const struct aspeed_gfx_config ast2500_config = {\n\t.dac_reg = 0x2c,\n\t.int_clear_reg = 0x60,\n\t.vga_scratch_reg = 0x50,\n\t.throd_val = CRT_THROD_LOW(0x24) | CRT_THROD_HIGH(0x3c),\n\t.scan_line_max = 128,\n};\n\nstatic const struct aspeed_gfx_config ast2600_config = {\n\t.dac_reg = 0xc0,\n\t.int_clear_reg = 0x68,\n\t.vga_scratch_reg = 0x50,\n\t.throd_val = CRT_THROD_LOW(0x50) | CRT_THROD_HIGH(0x70),\n\t.scan_line_max = 128,\n};\n\nstatic const struct of_device_id aspeed_gfx_match[] = {\n\t{ .compatible = \"aspeed,ast2400-gfx\", .data = &ast2400_config },\n\t{ .compatible = \"aspeed,ast2500-gfx\", .data = &ast2500_config },\n\t{ .compatible = \"aspeed,ast2600-gfx\", .data = &ast2600_config },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, aspeed_gfx_match);\n\nstatic const struct drm_mode_config_funcs aspeed_gfx_mode_config_funcs = {\n\t.fb_create\t\t= drm_gem_fb_create,\n\t.atomic_check\t\t= drm_atomic_helper_check,\n\t.atomic_commit\t\t= drm_atomic_helper_commit,\n};\n\nstatic int aspeed_gfx_setup_mode_config(struct drm_device *drm)\n{\n\tint ret;\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm->mode_config.min_width = 0;\n\tdrm->mode_config.min_height = 0;\n\tdrm->mode_config.max_width = 800;\n\tdrm->mode_config.max_height = 600;\n\tdrm->mode_config.funcs = &aspeed_gfx_mode_config_funcs;\n\n\treturn ret;\n}\n\nstatic irqreturn_t aspeed_gfx_irq_handler(int irq, void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct aspeed_gfx *priv = to_aspeed_gfx(drm);\n\tu32 reg;\n\n\treg = readl(priv->base + CRT_CTRL1);\n\n\tif (reg & CRT_CTRL_VERTICAL_INTR_STS) {\n\t\tdrm_crtc_handle_vblank(&priv->pipe.crtc);\n\t\twritel(reg, priv->base + priv->int_clr_reg);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int aspeed_gfx_load(struct drm_device *drm)\n{\n\tstruct platform_device *pdev = to_platform_device(drm->dev);\n\tstruct aspeed_gfx *priv = to_aspeed_gfx(drm);\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct aspeed_gfx_config *config;\n\tconst struct of_device_id *match;\n\tstruct resource *res;\n\tint ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->base = devm_ioremap_resource(drm->dev, res);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tmatch = of_match_device(aspeed_gfx_match, &pdev->dev);\n\tif (!match)\n\t\treturn -EINVAL;\n\tconfig = match->data;\n\n\tpriv->dac_reg = config->dac_reg;\n\tpriv->int_clr_reg = config->int_clear_reg;\n\tpriv->vga_scratch_reg = config->vga_scratch_reg;\n\tpriv->throd_val = config->throd_val;\n\tpriv->scan_line_max = config->scan_line_max;\n\n\tpriv->scu = syscon_regmap_lookup_by_phandle(np, \"syscon\");\n\tif (IS_ERR(priv->scu)) {\n\t\tpriv->scu = syscon_regmap_lookup_by_compatible(\"aspeed,ast2500-scu\");\n\t\tif (IS_ERR(priv->scu)) {\n\t\t\tdev_err(&pdev->dev, \"failed to find SCU regmap\\n\");\n\t\t\treturn PTR_ERR(priv->scu);\n\t\t}\n\t}\n\n\tret = of_reserved_mem_device_init(drm->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to initialize reserved mem: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = dma_set_mask_and_coherent(drm->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to set DMA mask: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(priv->rst)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"missing or invalid reset controller device tree entry\");\n\t\treturn PTR_ERR(priv->rst);\n\t}\n\treset_control_deassert(priv->rst);\n\n\tpriv->clk = devm_clk_get(drm->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"missing or invalid clk device tree entry\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\tclk_prepare_enable(priv->clk);\n\n\t \n\twritel(0, priv->base + CRT_CTRL1);\n\twritel(0, priv->base + CRT_CTRL2);\n\n\tret = aspeed_gfx_setup_mode_config(drm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = drm_vblank_init(drm, 1);\n\tif (ret < 0) {\n\t\tdev_err(drm->dev, \"Failed to initialise vblank\\n\");\n\t\treturn ret;\n\t}\n\n\tret = aspeed_gfx_create_output(drm);\n\tif (ret < 0) {\n\t\tdev_err(drm->dev, \"Failed to create outputs\\n\");\n\t\treturn ret;\n\t}\n\n\tret = aspeed_gfx_create_pipe(drm);\n\tif (ret < 0) {\n\t\tdev_err(drm->dev, \"Cannot setup simple display pipe\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(drm->dev, platform_get_irq(pdev, 0),\n\t\t\t       aspeed_gfx_irq_handler, 0, \"aspeed gfx\", drm);\n\tif (ret < 0) {\n\t\tdev_err(drm->dev, \"Failed to install IRQ handler\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_mode_config_reset(drm);\n\n\treturn 0;\n}\n\nstatic void aspeed_gfx_unload(struct drm_device *drm)\n{\n\tdrm_kms_helper_poll_fini(drm);\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(fops);\n\nstatic const struct drm_driver aspeed_gfx_driver = {\n\t.driver_features        = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\tDRM_GEM_DMA_DRIVER_OPS,\n\t.fops = &fops,\n\t.name = \"aspeed-gfx-drm\",\n\t.desc = \"ASPEED GFX DRM\",\n\t.date = \"20180319\",\n\t.major = 1,\n\t.minor = 0,\n};\n\nstatic ssize_t dac_mux_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct aspeed_gfx *priv = dev_get_drvdata(dev);\n\tu32 val;\n\tint rc;\n\n\trc = kstrtou32(buf, 0, &val);\n\tif (rc)\n\t\treturn rc;\n\n\tif (val > 3)\n\t\treturn -EINVAL;\n\n\trc = regmap_update_bits(priv->scu, priv->dac_reg, 0x30000, val << 16);\n\tif (rc < 0)\n\t\treturn 0;\n\n\treturn count;\n}\n\nstatic ssize_t dac_mux_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aspeed_gfx *priv = dev_get_drvdata(dev);\n\tu32 reg;\n\tint rc;\n\n\trc = regmap_read(priv->scu, priv->dac_reg, &reg);\n\tif (rc)\n\t\treturn rc;\n\n\treturn sprintf(buf, \"%u\\n\", (reg >> 16) & 0x3);\n}\nstatic DEVICE_ATTR_RW(dac_mux);\n\nstatic ssize_t\nvga_pw_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aspeed_gfx *priv = dev_get_drvdata(dev);\n\tu32 reg;\n\tint rc;\n\n\trc = regmap_read(priv->scu, priv->vga_scratch_reg, &reg);\n\tif (rc)\n\t\treturn rc;\n\n\treturn sprintf(buf, \"%u\\n\", reg);\n}\nstatic DEVICE_ATTR_RO(vga_pw);\n\nstatic struct attribute *aspeed_sysfs_entries[] = {\n\t&dev_attr_vga_pw.attr,\n\t&dev_attr_dac_mux.attr,\n\tNULL,\n};\n\nstatic struct attribute_group aspeed_sysfs_attr_group = {\n\t.attrs = aspeed_sysfs_entries,\n};\n\nstatic int aspeed_gfx_probe(struct platform_device *pdev)\n{\n\tstruct aspeed_gfx *priv;\n\tint ret;\n\n\tpriv = devm_drm_dev_alloc(&pdev->dev, &aspeed_gfx_driver,\n\t\t\t\t  struct aspeed_gfx, drm);\n\tif (IS_ERR(priv))\n\t\treturn PTR_ERR(priv);\n\n\tret = aspeed_gfx_load(&priv->drm);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = sysfs_create_group(&pdev->dev.kobj, &aspeed_sysfs_attr_group);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_dev_register(&priv->drm, 0);\n\tif (ret)\n\t\tgoto err_unload;\n\n\tdrm_fbdev_dma_setup(&priv->drm, 32);\n\treturn 0;\n\nerr_unload:\n\tsysfs_remove_group(&pdev->dev.kobj, &aspeed_sysfs_attr_group);\n\taspeed_gfx_unload(&priv->drm);\n\n\treturn ret;\n}\n\nstatic void aspeed_gfx_remove(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\n\tsysfs_remove_group(&pdev->dev.kobj, &aspeed_sysfs_attr_group);\n\tdrm_dev_unregister(drm);\n\taspeed_gfx_unload(drm);\n\tdrm_atomic_helper_shutdown(drm);\n}\n\nstatic void aspeed_gfx_shutdown(struct platform_device *pdev)\n{\n\tdrm_atomic_helper_shutdown(platform_get_drvdata(pdev));\n}\n\nstatic struct platform_driver aspeed_gfx_platform_driver = {\n\t.probe\t\t= aspeed_gfx_probe,\n\t.remove_new\t= aspeed_gfx_remove,\n\t.shutdown\t= aspeed_gfx_shutdown,\n\t.driver = {\n\t\t.name = \"aspeed_gfx\",\n\t\t.of_match_table = aspeed_gfx_match,\n\t},\n};\n\ndrm_module_platform_driver(aspeed_gfx_platform_driver);\n\nMODULE_AUTHOR(\"Joel Stanley <joel@jms.id.au>\");\nMODULE_DESCRIPTION(\"ASPEED BMC DRM/KMS driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}