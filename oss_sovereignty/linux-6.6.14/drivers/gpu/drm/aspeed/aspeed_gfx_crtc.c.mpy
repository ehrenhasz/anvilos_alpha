{
  "module_name": "aspeed_gfx_crtc.c",
  "hash_id": "f1e3a77c60acdfa9fef79d06c8dcc6150aa9240256f6530d9f27c2c9f798c4e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/aspeed/aspeed_gfx_crtc.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"aspeed_gfx.h\"\n\nstatic struct aspeed_gfx *\ndrm_pipe_to_aspeed_gfx(struct drm_simple_display_pipe *pipe)\n{\n\treturn container_of(pipe, struct aspeed_gfx, pipe);\n}\n\nstatic int aspeed_gfx_set_pixel_fmt(struct aspeed_gfx *priv, u32 *bpp)\n{\n\tstruct drm_crtc *crtc = &priv->pipe.crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tconst u32 format = crtc->primary->state->fb->format->format;\n\tu32 ctrl1;\n\n\tctrl1 = readl(priv->base + CRT_CTRL1);\n\tctrl1 &= ~CRT_CTRL_COLOR_MASK;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_RGB565:\n\t\tdev_dbg(drm->dev, \"Setting up RGB565 mode\\n\");\n\t\tctrl1 |= CRT_CTRL_COLOR_RGB565;\n\t\t*bpp = 16;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tdev_dbg(drm->dev, \"Setting up XRGB8888 mode\\n\");\n\t\tctrl1 |= CRT_CTRL_COLOR_XRGB8888;\n\t\t*bpp = 32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(drm->dev, \"Unhandled pixel format %08x\\n\", format);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(ctrl1, priv->base + CRT_CTRL1);\n\n\treturn 0;\n}\n\nstatic void aspeed_gfx_enable_controller(struct aspeed_gfx *priv)\n{\n\tu32 ctrl1 = readl(priv->base + CRT_CTRL1);\n\tu32 ctrl2 = readl(priv->base + CRT_CTRL2);\n\n\t \n\tregmap_update_bits(priv->scu, priv->dac_reg, BIT(16), BIT(16));\n\n\twritel(ctrl1 | CRT_CTRL_EN, priv->base + CRT_CTRL1);\n\twritel(ctrl2 | CRT_CTRL_DAC_EN, priv->base + CRT_CTRL2);\n}\n\nstatic void aspeed_gfx_disable_controller(struct aspeed_gfx *priv)\n{\n\tu32 ctrl1 = readl(priv->base + CRT_CTRL1);\n\tu32 ctrl2 = readl(priv->base + CRT_CTRL2);\n\n\twritel(ctrl1 & ~CRT_CTRL_EN, priv->base + CRT_CTRL1);\n\twritel(ctrl2 & ~CRT_CTRL_DAC_EN, priv->base + CRT_CTRL2);\n\n\tregmap_update_bits(priv->scu, priv->dac_reg, BIT(16), 0);\n}\n\nstatic void aspeed_gfx_crtc_mode_set_nofb(struct aspeed_gfx *priv)\n{\n\tstruct drm_display_mode *m = &priv->pipe.crtc.state->adjusted_mode;\n\tu32 ctrl1, d_offset, t_count, bpp;\n\tint err;\n\n\terr = aspeed_gfx_set_pixel_fmt(priv, &bpp);\n\tif (err)\n\t\treturn;\n\n#if 0\n\t \n\tclk_set_rate(priv->pixel_clk, m->crtc_clock * 1000);\n#endif\n\n\tctrl1 = readl(priv->base + CRT_CTRL1);\n\tctrl1 &= ~(CRT_CTRL_INTERLACED |\n\t\t\tCRT_CTRL_HSYNC_NEGATIVE |\n\t\t\tCRT_CTRL_VSYNC_NEGATIVE);\n\n\tif (m->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tctrl1 |= CRT_CTRL_INTERLACED;\n\n\tif (!(m->flags & DRM_MODE_FLAG_PHSYNC))\n\t\tctrl1 |= CRT_CTRL_HSYNC_NEGATIVE;\n\n\tif (!(m->flags & DRM_MODE_FLAG_PVSYNC))\n\t\tctrl1 |= CRT_CTRL_VSYNC_NEGATIVE;\n\n\twritel(ctrl1, priv->base + CRT_CTRL1);\n\n\t \n\twritel(CRT_H_TOTAL(m->htotal - 1) | CRT_H_DE(m->hdisplay - 1),\n\t\t\tpriv->base + CRT_HORIZ0);\n\twritel(CRT_H_RS_START(m->hsync_start - 1) | CRT_H_RS_END(m->hsync_end),\n\t\t\tpriv->base + CRT_HORIZ1);\n\n\n\t \n\twritel(CRT_V_TOTAL(m->vtotal - 1) | CRT_V_DE(m->vdisplay - 1),\n\t\t\tpriv->base + CRT_VERT0);\n\twritel(CRT_V_RS_START(m->vsync_start) | CRT_V_RS_END(m->vsync_end),\n\t\t\tpriv->base + CRT_VERT1);\n\n\t \n\td_offset = m->hdisplay * bpp / 8;\n\tt_count = DIV_ROUND_UP(m->hdisplay * bpp, priv->scan_line_max);\n\n\twritel(CRT_DISP_OFFSET(d_offset) | CRT_TERM_COUNT(t_count),\n\t\t\tpriv->base + CRT_OFFSET);\n\n\t \n\twritel(priv->throd_val, priv->base + CRT_THROD);\n}\n\nstatic void aspeed_gfx_pipe_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t      struct drm_crtc_state *crtc_state,\n\t\t\t      struct drm_plane_state *plane_state)\n{\n\tstruct aspeed_gfx *priv = drm_pipe_to_aspeed_gfx(pipe);\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\n\taspeed_gfx_crtc_mode_set_nofb(priv);\n\taspeed_gfx_enable_controller(priv);\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void aspeed_gfx_pipe_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct aspeed_gfx *priv = drm_pipe_to_aspeed_gfx(pipe);\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\n\tdrm_crtc_vblank_off(crtc);\n\taspeed_gfx_disable_controller(priv);\n}\n\nstatic void aspeed_gfx_pipe_update(struct drm_simple_display_pipe *pipe,\n\t\t\t\t   struct drm_plane_state *plane_state)\n{\n\tstruct aspeed_gfx *priv = drm_pipe_to_aspeed_gfx(pipe);\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_framebuffer *fb = pipe->plane.state->fb;\n\tstruct drm_pending_vblank_event *event;\n\tstruct drm_gem_dma_object *gem;\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tevent = crtc->state->event;\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t}\n\tspin_unlock_irq(&crtc->dev->event_lock);\n\n\tif (!fb)\n\t\treturn;\n\n\tgem = drm_fb_dma_get_gem_obj(fb, 0);\n\tif (!gem)\n\t\treturn;\n\twritel(gem->dma_addr, priv->base + CRT_ADDR);\n}\n\nstatic int aspeed_gfx_enable_vblank(struct drm_simple_display_pipe *pipe)\n{\n\tstruct aspeed_gfx *priv = drm_pipe_to_aspeed_gfx(pipe);\n\tu32 reg = readl(priv->base + CRT_CTRL1);\n\n\t \n\twritel(reg | CRT_CTRL_VERTICAL_INTR_STS, priv->base + CRT_CTRL1);\n\n\treg |= CRT_CTRL_VERTICAL_INTR_EN;\n\twritel(reg, priv->base + CRT_CTRL1);\n\n\treturn 0;\n}\n\nstatic void aspeed_gfx_disable_vblank(struct drm_simple_display_pipe *pipe)\n{\n\tstruct aspeed_gfx *priv = drm_pipe_to_aspeed_gfx(pipe);\n\tu32 reg = readl(priv->base + CRT_CTRL1);\n\n\treg &= ~CRT_CTRL_VERTICAL_INTR_EN;\n\twritel(reg, priv->base + CRT_CTRL1);\n\n\t \n\twritel(reg | CRT_CTRL_VERTICAL_INTR_STS, priv->base + CRT_CTRL1);\n}\n\nstatic const struct drm_simple_display_pipe_funcs aspeed_gfx_funcs = {\n\t.enable\t\t= aspeed_gfx_pipe_enable,\n\t.disable\t= aspeed_gfx_pipe_disable,\n\t.update\t\t= aspeed_gfx_pipe_update,\n\t.enable_vblank\t= aspeed_gfx_enable_vblank,\n\t.disable_vblank\t= aspeed_gfx_disable_vblank,\n};\n\nstatic const uint32_t aspeed_gfx_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB565,\n};\n\nint aspeed_gfx_create_pipe(struct drm_device *drm)\n{\n\tstruct aspeed_gfx *priv = to_aspeed_gfx(drm);\n\n\treturn drm_simple_display_pipe_init(drm, &priv->pipe, &aspeed_gfx_funcs,\n\t\t\t\t\t    aspeed_gfx_formats,\n\t\t\t\t\t    ARRAY_SIZE(aspeed_gfx_formats),\n\t\t\t\t\t    NULL,\n\t\t\t\t\t    &priv->connector);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}