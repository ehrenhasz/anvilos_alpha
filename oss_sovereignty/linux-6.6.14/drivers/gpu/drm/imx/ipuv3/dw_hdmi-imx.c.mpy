{
  "module_name": "dw_hdmi-imx.c",
  "hash_id": "c7f4b15681a688b1218f7d5d45150efbd1d5b643670423dc0be4db64d27ce72e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/ipuv3/dw_hdmi-imx.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <video/imx-ipu-v3.h>\n\n#include <drm/bridge/dw_hdmi.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_of.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"imx-drm.h\"\n\nstruct imx_hdmi;\n\nstruct imx_hdmi_encoder {\n\tstruct drm_encoder encoder;\n\tstruct imx_hdmi *hdmi;\n};\n\nstruct imx_hdmi {\n\tstruct device *dev;\n\tstruct drm_bridge *bridge;\n\tstruct dw_hdmi *hdmi;\n\tstruct regmap *regmap;\n};\n\nstatic inline struct imx_hdmi *enc_to_imx_hdmi(struct drm_encoder *e)\n{\n\treturn container_of(e, struct imx_hdmi_encoder, encoder)->hdmi;\n}\n\nstatic const struct dw_hdmi_mpll_config imx_mpll_cfg[] = {\n\t{\n\t\t45250000, {\n\t\t\t{ 0x01e0, 0x0000 },\n\t\t\t{ 0x21e1, 0x0000 },\n\t\t\t{ 0x41e2, 0x0000 }\n\t\t},\n\t}, {\n\t\t92500000, {\n\t\t\t{ 0x0140, 0x0005 },\n\t\t\t{ 0x2141, 0x0005 },\n\t\t\t{ 0x4142, 0x0005 },\n\t},\n\t}, {\n\t\t148500000, {\n\t\t\t{ 0x00a0, 0x000a },\n\t\t\t{ 0x20a1, 0x000a },\n\t\t\t{ 0x40a2, 0x000a },\n\t\t},\n\t}, {\n\t\t216000000, {\n\t\t\t{ 0x00a0, 0x000a },\n\t\t\t{ 0x2001, 0x000f },\n\t\t\t{ 0x4002, 0x000f },\n\t\t},\n\t}, {\n\t\t~0UL, {\n\t\t\t{ 0x0000, 0x0000 },\n\t\t\t{ 0x0000, 0x0000 },\n\t\t\t{ 0x0000, 0x0000 },\n\t\t},\n\t}\n};\n\nstatic const struct dw_hdmi_curr_ctrl imx_cur_ctr[] = {\n\t \n\t{\n\t\t54000000, { 0x091c, 0x091c, 0x06dc },\n\t}, {\n\t\t58400000, { 0x091c, 0x06dc, 0x06dc },\n\t}, {\n\t\t72000000, { 0x06dc, 0x06dc, 0x091c },\n\t}, {\n\t\t74250000, { 0x06dc, 0x0b5c, 0x091c },\n\t}, {\n\t\t118800000, { 0x091c, 0x091c, 0x06dc },\n\t}, {\n\t\t216000000, { 0x06dc, 0x0b5c, 0x091c },\n\t}, {\n\t\t~0UL, { 0x0000, 0x0000, 0x0000 },\n\t},\n};\n\n \nstatic const struct dw_hdmi_phy_config imx_phy_config[] = {\n\t \n\t{ 216000000, 0x800d, 0x0005, 0x01ad},\n\t{ ~0UL,      0x0000, 0x0000, 0x0000}\n};\n\nstatic void dw_hdmi_imx_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct imx_hdmi *hdmi = enc_to_imx_hdmi(encoder);\n\tint mux = drm_of_encoder_active_port_id(hdmi->dev->of_node, encoder);\n\n\tregmap_update_bits(hdmi->regmap, IOMUXC_GPR3,\n\t\t\t   IMX6Q_GPR3_HDMI_MUX_CTL_MASK,\n\t\t\t   mux << IMX6Q_GPR3_HDMI_MUX_CTL_SHIFT);\n}\n\nstatic int dw_hdmi_imx_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t\t    struct drm_connector_state *conn_state)\n{\n\tstruct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc_state);\n\n\timx_crtc_state->bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\timx_crtc_state->di_hsync_pin = 2;\n\timx_crtc_state->di_vsync_pin = 3;\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_helper_funcs dw_hdmi_imx_encoder_helper_funcs = {\n\t.enable     = dw_hdmi_imx_encoder_enable,\n\t.atomic_check = dw_hdmi_imx_atomic_check,\n};\n\nstatic enum drm_mode_status\nimx6q_hdmi_mode_valid(struct dw_hdmi *hdmi, void *data,\n\t\t      const struct drm_display_info *info,\n\t\t      const struct drm_display_mode *mode)\n{\n\tif (mode->clock < 13500)\n\t\treturn MODE_CLOCK_LOW;\n\t \n\tif (mode->clock > 216000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic enum drm_mode_status\nimx6dl_hdmi_mode_valid(struct dw_hdmi *hdmi, void *data,\n\t\t       const struct drm_display_info *info,\n\t\t       const struct drm_display_mode *mode)\n{\n\tif (mode->clock < 13500)\n\t\treturn MODE_CLOCK_LOW;\n\t \n\tif (mode->clock > 216000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic struct dw_hdmi_plat_data imx6q_hdmi_drv_data = {\n\t.mpll_cfg   = imx_mpll_cfg,\n\t.cur_ctr    = imx_cur_ctr,\n\t.phy_config = imx_phy_config,\n\t.mode_valid = imx6q_hdmi_mode_valid,\n};\n\nstatic struct dw_hdmi_plat_data imx6dl_hdmi_drv_data = {\n\t.mpll_cfg = imx_mpll_cfg,\n\t.cur_ctr  = imx_cur_ctr,\n\t.phy_config = imx_phy_config,\n\t.mode_valid = imx6dl_hdmi_mode_valid,\n};\n\nstatic const struct of_device_id dw_hdmi_imx_dt_ids[] = {\n\t{ .compatible = \"fsl,imx6q-hdmi\",\n\t  .data = &imx6q_hdmi_drv_data\n\t}, {\n\t  .compatible = \"fsl,imx6dl-hdmi\",\n\t  .data = &imx6dl_hdmi_drv_data\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dw_hdmi_imx_dt_ids);\n\nstatic int dw_hdmi_imx_bind(struct device *dev, struct device *master,\n\t\t\t    void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct imx_hdmi_encoder *hdmi_encoder;\n\tstruct drm_encoder *encoder;\n\tint ret;\n\n\thdmi_encoder = drmm_simple_encoder_alloc(drm, struct imx_hdmi_encoder,\n\t\t\t\t\t\t encoder, DRM_MODE_ENCODER_TMDS);\n\tif (IS_ERR(hdmi_encoder))\n\t\treturn PTR_ERR(hdmi_encoder);\n\n\thdmi_encoder->hdmi = dev_get_drvdata(dev);\n\tencoder = &hdmi_encoder->encoder;\n\n\tret = imx_drm_encoder_parse_of(drm, encoder, dev->of_node);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_encoder_helper_add(encoder, &dw_hdmi_imx_encoder_helper_funcs);\n\n\treturn drm_bridge_attach(encoder, hdmi_encoder->hdmi->bridge, NULL, 0);\n}\n\nstatic const struct component_ops dw_hdmi_imx_ops = {\n\t.bind\t= dw_hdmi_imx_bind,\n};\n\nstatic int dw_hdmi_imx_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *match = of_match_node(dw_hdmi_imx_dt_ids, np);\n\tstruct imx_hdmi *hdmi;\n\tint ret;\n\n\thdmi = devm_kzalloc(&pdev->dev, sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, hdmi);\n\thdmi->dev = &pdev->dev;\n\n\thdmi->regmap = syscon_regmap_lookup_by_phandle(np, \"gpr\");\n\tif (IS_ERR(hdmi->regmap)) {\n\t\tdev_err(hdmi->dev, \"Unable to get gpr\\n\");\n\t\treturn PTR_ERR(hdmi->regmap);\n\t}\n\n\thdmi->hdmi = dw_hdmi_probe(pdev, match->data);\n\tif (IS_ERR(hdmi->hdmi))\n\t\treturn PTR_ERR(hdmi->hdmi);\n\n\thdmi->bridge = of_drm_find_bridge(np);\n\tif (!hdmi->bridge) {\n\t\tdev_err(hdmi->dev, \"Unable to find bridge\\n\");\n\t\tdw_hdmi_remove(hdmi->hdmi);\n\t\treturn -ENODEV;\n\t}\n\n\tret = component_add(&pdev->dev, &dw_hdmi_imx_ops);\n\tif (ret)\n\t\tdw_hdmi_remove(hdmi->hdmi);\n\n\treturn ret;\n}\n\nstatic int dw_hdmi_imx_remove(struct platform_device *pdev)\n{\n\tstruct imx_hdmi *hdmi = platform_get_drvdata(pdev);\n\n\tcomponent_del(&pdev->dev, &dw_hdmi_imx_ops);\n\tdw_hdmi_remove(hdmi->hdmi);\n\n\treturn 0;\n}\n\nstatic struct platform_driver dw_hdmi_imx_platform_driver = {\n\t.probe  = dw_hdmi_imx_probe,\n\t.remove = dw_hdmi_imx_remove,\n\t.driver = {\n\t\t.name = \"dwhdmi-imx\",\n\t\t.of_match_table = dw_hdmi_imx_dt_ids,\n\t},\n};\n\nmodule_platform_driver(dw_hdmi_imx_platform_driver);\n\nMODULE_AUTHOR(\"Andy Yan <andy.yan@rock-chips.com>\");\nMODULE_AUTHOR(\"Yakir Yang <ykk@rock-chips.com>\");\nMODULE_DESCRIPTION(\"IMX6 Specific DW-HDMI Driver Extension\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:dwhdmi-imx\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}