{
  "module_name": "parallel-display.c",
  "hash_id": "b340adfb52eafe36452651eceb5d9559c945912a69e9a1c0a185b9debe253cc5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/ipuv3/parallel-display.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/videodev2.h>\n\n#include <video/of_display_timing.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"imx-drm.h\"\n\nstruct imx_parallel_display_encoder {\n\tstruct drm_connector connector;\n\tstruct drm_encoder encoder;\n\tstruct drm_bridge bridge;\n\tstruct imx_parallel_display *pd;\n};\n\nstruct imx_parallel_display {\n\tstruct device *dev;\n\tvoid *edid;\n\tu32 bus_format;\n\tu32 bus_flags;\n\tstruct drm_display_mode mode;\n\tstruct drm_panel *panel;\n\tstruct drm_bridge *next_bridge;\n};\n\nstatic inline struct imx_parallel_display *con_to_imxpd(struct drm_connector *c)\n{\n\treturn container_of(c, struct imx_parallel_display_encoder, connector)->pd;\n}\n\nstatic inline struct imx_parallel_display *bridge_to_imxpd(struct drm_bridge *b)\n{\n\treturn container_of(b, struct imx_parallel_display_encoder, bridge)->pd;\n}\n\nstatic int imx_pd_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct imx_parallel_display *imxpd = con_to_imxpd(connector);\n\tstruct device_node *np = imxpd->dev->of_node;\n\tint num_modes;\n\n\tnum_modes = drm_panel_get_modes(imxpd->panel, connector);\n\tif (num_modes > 0)\n\t\treturn num_modes;\n\n\tif (imxpd->edid) {\n\t\tdrm_connector_update_edid_property(connector, imxpd->edid);\n\t\tnum_modes = drm_add_edid_modes(connector, imxpd->edid);\n\t}\n\n\tif (np) {\n\t\tstruct drm_display_mode *mode = drm_mode_create(connector->dev);\n\t\tint ret;\n\n\t\tif (!mode)\n\t\t\treturn -EINVAL;\n\n\t\tret = of_get_drm_display_mode(np, &imxpd->mode,\n\t\t\t\t\t      &imxpd->bus_flags,\n\t\t\t\t\t      OF_USE_NATIVE_MODE);\n\t\tif (ret) {\n\t\t\tdrm_mode_destroy(connector->dev, mode);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdrm_mode_copy(mode, &imxpd->mode);\n\t\tmode->type |= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tnum_modes++;\n\t}\n\n\treturn num_modes;\n}\n\nstatic void imx_pd_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct imx_parallel_display *imxpd = bridge_to_imxpd(bridge);\n\n\tdrm_panel_prepare(imxpd->panel);\n\tdrm_panel_enable(imxpd->panel);\n}\n\nstatic void imx_pd_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct imx_parallel_display *imxpd = bridge_to_imxpd(bridge);\n\n\tdrm_panel_disable(imxpd->panel);\n\tdrm_panel_unprepare(imxpd->panel);\n}\n\nstatic const u32 imx_pd_bus_fmts[] = {\n\tMEDIA_BUS_FMT_RGB888_1X24,\n\tMEDIA_BUS_FMT_BGR888_1X24,\n\tMEDIA_BUS_FMT_GBR888_1X24,\n\tMEDIA_BUS_FMT_RGB666_1X18,\n\tMEDIA_BUS_FMT_RGB666_1X24_CPADHI,\n\tMEDIA_BUS_FMT_RGB565_1X16,\n};\n\nstatic u32 *\nimx_pd_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t struct drm_bridge_state *bridge_state,\n\t\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t\t struct drm_connector_state *conn_state,\n\t\t\t\t\t unsigned int *num_output_fmts)\n{\n\tstruct drm_display_info *di = &conn_state->connector->display_info;\n\tstruct imx_parallel_display *imxpd = bridge_to_imxpd(bridge);\n\tu32 *output_fmts;\n\n\tif (!imxpd->bus_format && !di->num_bus_formats) {\n\t\t*num_output_fmts = ARRAY_SIZE(imx_pd_bus_fmts);\n\t\treturn kmemdup(imx_pd_bus_fmts, sizeof(imx_pd_bus_fmts),\n\t\t\t       GFP_KERNEL);\n\t}\n\n\t*num_output_fmts = 1;\n\toutput_fmts = kmalloc(sizeof(*output_fmts), GFP_KERNEL);\n\tif (!output_fmts)\n\t\treturn NULL;\n\n\tif (!imxpd->bus_format && di->num_bus_formats)\n\t\toutput_fmts[0] = di->bus_formats[0];\n\telse\n\t\toutput_fmts[0] = imxpd->bus_format;\n\n\treturn output_fmts;\n}\n\nstatic bool imx_pd_format_supported(u32 output_fmt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx_pd_bus_fmts); i++) {\n\t\tif (imx_pd_bus_fmts[i] == output_fmt)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u32 *\nimx_pd_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state,\n\t\t\t\t\tu32 output_fmt,\n\t\t\t\t\tunsigned int *num_input_fmts)\n{\n\tstruct imx_parallel_display *imxpd = bridge_to_imxpd(bridge);\n\tu32 *input_fmts;\n\n\t \n\tif (output_fmt == MEDIA_BUS_FMT_FIXED)\n\t\toutput_fmt = imxpd->bus_format ? : MEDIA_BUS_FMT_RGB888_1X24;\n\n\t \n\tif ((imxpd->bus_format && imxpd->bus_format != output_fmt) ||\n\t    !imx_pd_format_supported(output_fmt)) {\n\t\t*num_input_fmts = 0;\n\t\treturn NULL;\n\t}\n\n\t*num_input_fmts = 1;\n\tinput_fmts = kmalloc(sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tinput_fmts[0] = output_fmt;\n\treturn input_fmts;\n}\n\nstatic int imx_pd_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t      struct drm_bridge_state *bridge_state,\n\t\t\t\t      struct drm_crtc_state *crtc_state,\n\t\t\t\t      struct drm_connector_state *conn_state)\n{\n\tstruct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc_state);\n\tstruct drm_display_info *di = &conn_state->connector->display_info;\n\tstruct imx_parallel_display *imxpd = bridge_to_imxpd(bridge);\n\tstruct drm_bridge_state *next_bridge_state = NULL;\n\tstruct drm_bridge *next_bridge;\n\tu32 bus_flags, bus_fmt;\n\n\tnext_bridge = drm_bridge_get_next_bridge(bridge);\n\tif (next_bridge)\n\t\tnext_bridge_state = drm_atomic_get_new_bridge_state(crtc_state->state,\n\t\t\t\t\t\t\t\t    next_bridge);\n\n\tif (next_bridge_state)\n\t\tbus_flags = next_bridge_state->input_bus_cfg.flags;\n\telse if (di->num_bus_formats)\n\t\tbus_flags = di->bus_flags;\n\telse\n\t\tbus_flags = imxpd->bus_flags;\n\n\tbus_fmt = bridge_state->input_bus_cfg.format;\n\tif (!imx_pd_format_supported(bus_fmt))\n\t\treturn -EINVAL;\n\n\tbridge_state->output_bus_cfg.flags = bus_flags;\n\tbridge_state->input_bus_cfg.flags = bus_flags;\n\timx_crtc_state->bus_flags = bus_flags;\n\timx_crtc_state->bus_format = bridge_state->input_bus_cfg.format;\n\timx_crtc_state->di_hsync_pin = 2;\n\timx_crtc_state->di_vsync_pin = 3;\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_funcs imx_pd_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = imx_drm_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_connector_helper_funcs imx_pd_connector_helper_funcs = {\n\t.get_modes = imx_pd_connector_get_modes,\n};\n\nstatic const struct drm_bridge_funcs imx_pd_bridge_funcs = {\n\t.enable = imx_pd_bridge_enable,\n\t.disable = imx_pd_bridge_disable,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_check = imx_pd_bridge_atomic_check,\n\t.atomic_get_input_bus_fmts = imx_pd_bridge_atomic_get_input_bus_fmts,\n\t.atomic_get_output_bus_fmts = imx_pd_bridge_atomic_get_output_bus_fmts,\n};\n\nstatic int imx_pd_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct imx_parallel_display *imxpd = dev_get_drvdata(dev);\n\tstruct imx_parallel_display_encoder *imxpd_encoder;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct drm_bridge *bridge;\n\tint ret;\n\n\timxpd_encoder = drmm_simple_encoder_alloc(drm, struct imx_parallel_display_encoder,\n\t\t\t\t\t\t  encoder, DRM_MODE_ENCODER_NONE);\n\tif (IS_ERR(imxpd_encoder))\n\t\treturn PTR_ERR(imxpd_encoder);\n\n\timxpd_encoder->pd = imxpd;\n\tconnector = &imxpd_encoder->connector;\n\tencoder = &imxpd_encoder->encoder;\n\tbridge = &imxpd_encoder->bridge;\n\n\tret = imx_drm_encoder_parse_of(drm, encoder, imxpd->dev->of_node);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tconnector->dpms = DRM_MODE_DPMS_OFF;\n\n\tbridge->funcs = &imx_pd_bridge_funcs;\n\tdrm_bridge_attach(encoder, bridge, NULL, 0);\n\n\tif (imxpd->next_bridge) {\n\t\tret = drm_bridge_attach(encoder, imxpd->next_bridge, bridge, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tdrm_connector_helper_add(connector,\n\t\t\t\t\t &imx_pd_connector_helper_funcs);\n\t\tdrm_connector_init(drm, connector, &imx_pd_connector_funcs,\n\t\t\t\t   DRM_MODE_CONNECTOR_DPI);\n\n\t\tdrm_connector_attach_encoder(connector, encoder);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct component_ops imx_pd_ops = {\n\t.bind\t= imx_pd_bind,\n};\n\nstatic int imx_pd_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst u8 *edidp;\n\tstruct imx_parallel_display *imxpd;\n\tint edid_len;\n\tint ret;\n\tu32 bus_format = 0;\n\tconst char *fmt;\n\n\timxpd = devm_kzalloc(dev, sizeof(*imxpd), GFP_KERNEL);\n\tif (!imxpd)\n\t\treturn -ENOMEM;\n\n\t \n\tret = drm_of_find_panel_or_bridge(np, 1, 0, &imxpd->panel,\n\t\t\t\t\t  &imxpd->next_bridge);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\n\tedidp = of_get_property(np, \"edid\", &edid_len);\n\tif (edidp)\n\t\timxpd->edid = devm_kmemdup(dev, edidp, edid_len, GFP_KERNEL);\n\n\tret = of_property_read_string(np, \"interface-pix-fmt\", &fmt);\n\tif (!ret) {\n\t\tif (!strcmp(fmt, \"rgb24\"))\n\t\t\tbus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\t\telse if (!strcmp(fmt, \"rgb565\"))\n\t\t\tbus_format = MEDIA_BUS_FMT_RGB565_1X16;\n\t\telse if (!strcmp(fmt, \"bgr666\"))\n\t\t\tbus_format = MEDIA_BUS_FMT_RGB666_1X18;\n\t\telse if (!strcmp(fmt, \"lvds666\"))\n\t\t\tbus_format = MEDIA_BUS_FMT_RGB666_1X24_CPADHI;\n\t}\n\timxpd->bus_format = bus_format;\n\n\timxpd->dev = dev;\n\n\tplatform_set_drvdata(pdev, imxpd);\n\n\treturn component_add(dev, &imx_pd_ops);\n}\n\nstatic int imx_pd_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &imx_pd_ops);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id imx_pd_dt_ids[] = {\n\t{ .compatible = \"fsl,imx-parallel-display\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_pd_dt_ids);\n\nstatic struct platform_driver imx_pd_driver = {\n\t.probe\t\t= imx_pd_probe,\n\t.remove\t\t= imx_pd_remove,\n\t.driver\t\t= {\n\t\t.of_match_table = imx_pd_dt_ids,\n\t\t.name\t= \"imx-parallel-display\",\n\t},\n};\n\nmodule_platform_driver(imx_pd_driver);\n\nMODULE_DESCRIPTION(\"i.MX parallel display driver\");\nMODULE_AUTHOR(\"Sascha Hauer, Pengutronix\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:imx-parallel-display\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}