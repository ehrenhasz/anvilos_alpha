{
  "module_name": "imx-drm-core.c",
  "hash_id": "cc8a7ac54dedd4436268fc13c8e5ec5ccd90f4c550e9963ae8acf48beac36f69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/ipuv3/imx-drm-core.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/device.h>\n#include <linux/dma-buf.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <video/imx-ipu-v3.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"imx-drm.h\"\n#include \"ipuv3-plane.h\"\n\n#define MAX_CRTC\t4\n\nstatic int legacyfb_depth = 16;\nmodule_param(legacyfb_depth, int, 0444);\n\nDEFINE_DRM_GEM_DMA_FOPS(imx_drm_driver_fops);\n\nvoid imx_drm_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n}\nEXPORT_SYMBOL_GPL(imx_drm_connector_destroy);\n\nstatic int imx_drm_atomic_check(struct drm_device *dev,\n\t\t\t\tstruct drm_atomic_state *state)\n{\n\tint ret;\n\n\tret = drm_atomic_helper_check(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = drm_atomic_helper_check_modeset(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ipu_planes_assign_pre(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = imx_drm_atomic_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state, *new_plane_state;\n\tbool plane_disabling = false;\n\tint i;\n\n\tdrm_atomic_helper_commit_modeset_disables(dev, state);\n\n\tdrm_atomic_helper_commit_planes(dev, state,\n\t\t\t\tDRM_PLANE_COMMIT_ACTIVE_ONLY |\n\t\t\t\tDRM_PLANE_COMMIT_NO_DISABLE_AFTER_MODESET);\n\n\tdrm_atomic_helper_commit_modeset_enables(dev, state);\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\tif (drm_atomic_plane_disabling(old_plane_state, new_plane_state))\n\t\t\tplane_disabling = true;\n\t}\n\n\t \n\tdrm_atomic_helper_wait_for_flip_done(dev, state);\n\n\tif (plane_disabling) {\n\t\tfor_each_old_plane_in_state(state, plane, old_plane_state, i)\n\t\t\tipu_plane_disable_deferred(plane);\n\n\t}\n\n\tdrm_atomic_helper_commit_hw_done(state);\n}\n\nstatic const struct drm_mode_config_helper_funcs imx_drm_mode_config_helpers = {\n\t.atomic_commit_tail = imx_drm_atomic_commit_tail,\n};\n\n\nint imx_drm_encoder_parse_of(struct drm_device *drm,\n\tstruct drm_encoder *encoder, struct device_node *np)\n{\n\tuint32_t crtc_mask = drm_of_find_possible_crtcs(drm, np);\n\n\t \n\tif (crtc_mask == 0)\n\t\treturn -EPROBE_DEFER;\n\n\tencoder->possible_crtcs = crtc_mask;\n\n\t \n\tencoder->possible_clones = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(imx_drm_encoder_parse_of);\n\nstatic const struct drm_ioctl_desc imx_drm_ioctls[] = {\n\t \n};\n\nstatic int imx_drm_dumb_create(struct drm_file *file_priv,\n\t\t\t       struct drm_device *drm,\n\t\t\t       struct drm_mode_create_dumb *args)\n{\n\tu32 width = args->width;\n\tint ret;\n\n\targs->width = ALIGN(width, 8);\n\n\tret = drm_gem_dma_dumb_create(file_priv, drm, args);\n\tif (ret)\n\t\treturn ret;\n\n\targs->width = width;\n\treturn ret;\n}\n\nstatic const struct drm_driver imx_drm_driver = {\n\t.driver_features\t= DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\tDRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(imx_drm_dumb_create),\n\t.ioctls\t\t\t= imx_drm_ioctls,\n\t.num_ioctls\t\t= ARRAY_SIZE(imx_drm_ioctls),\n\t.fops\t\t\t= &imx_drm_driver_fops,\n\t.name\t\t\t= \"imx-drm\",\n\t.desc\t\t\t= \"i.MX DRM graphics\",\n\t.date\t\t\t= \"20120507\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n\t.patchlevel\t\t= 0,\n};\n\nstatic int compare_of(struct device *dev, void *data)\n{\n\tstruct device_node *np = data;\n\n\t \n\tif (strcmp(dev->driver->name, \"imx-ipuv3-crtc\") == 0) {\n\t\tstruct ipu_client_platformdata *pdata = dev->platform_data;\n\n\t\treturn pdata->of_node == np;\n\t}\n\n\t \n\tif (of_node_name_eq(np, \"lvds-channel\")) {\n\t\tnp = of_get_parent(np);\n\t\tof_node_put(np);\n\t}\n\n\treturn dev->of_node == np;\n}\n\nstatic int imx_drm_bind(struct device *dev)\n{\n\tstruct drm_device *drm;\n\tint ret;\n\n\tdrm = drm_dev_alloc(&imx_drm_driver, dev);\n\tif (IS_ERR(drm))\n\t\treturn PTR_ERR(drm);\n\n\t \n\tdrm->mode_config.min_width = 1;\n\tdrm->mode_config.min_height = 1;\n\tdrm->mode_config.max_width = 4096;\n\tdrm->mode_config.max_height = 4096;\n\tdrm->mode_config.funcs = &imx_drm_mode_config_funcs;\n\tdrm->mode_config.helper_private = &imx_drm_mode_config_helpers;\n\tdrm->mode_config.normalize_zpos = true;\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\tgoto err_kms;\n\n\tret = drm_vblank_init(drm, MAX_CRTC);\n\tif (ret)\n\t\tgoto err_kms;\n\n\tdev_set_drvdata(dev, drm);\n\n\t \n\tret = component_bind_all(dev, drm);\n\tif (ret)\n\t\tgoto err_kms;\n\n\tdrm_mode_config_reset(drm);\n\n\t \n\tif (legacyfb_depth != 16 && legacyfb_depth != 32) {\n\t\tdev_warn(dev, \"Invalid legacyfb_depth.  Defaulting to 16bpp\\n\");\n\t\tlegacyfb_depth = 16;\n\t}\n\n\tdrm_kms_helper_poll_init(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\tgoto err_poll_fini;\n\n\tdrm_fbdev_dma_setup(drm, legacyfb_depth);\n\n\treturn 0;\n\nerr_poll_fini:\n\tdrm_kms_helper_poll_fini(drm);\n\tcomponent_unbind_all(drm->dev, drm);\nerr_kms:\n\tdrm_dev_put(drm);\n\n\treturn ret;\n}\n\nstatic void imx_drm_unbind(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\tdrm_dev_unregister(drm);\n\n\tdrm_kms_helper_poll_fini(drm);\n\n\tcomponent_unbind_all(drm->dev, drm);\n\n\tdrm_dev_put(drm);\n\n\tdev_set_drvdata(dev, NULL);\n}\n\nstatic const struct component_master_ops imx_drm_ops = {\n\t.bind = imx_drm_bind,\n\t.unbind = imx_drm_unbind,\n};\n\nstatic int imx_drm_platform_probe(struct platform_device *pdev)\n{\n\tint ret = drm_of_component_probe(&pdev->dev, compare_of, &imx_drm_ops);\n\n\tif (!ret)\n\t\tret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\n\treturn ret;\n}\n\nstatic int imx_drm_platform_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &imx_drm_ops);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int imx_drm_suspend(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_suspend(drm_dev);\n}\n\nstatic int imx_drm_resume(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_resume(drm_dev);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(imx_drm_pm_ops, imx_drm_suspend, imx_drm_resume);\n\nstatic const struct of_device_id imx_drm_dt_ids[] = {\n\t{ .compatible = \"fsl,imx-display-subsystem\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, imx_drm_dt_ids);\n\nstatic struct platform_driver imx_drm_pdrv = {\n\t.probe\t\t= imx_drm_platform_probe,\n\t.remove\t\t= imx_drm_platform_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"imx-drm\",\n\t\t.pm\t= &imx_drm_pm_ops,\n\t\t.of_match_table = imx_drm_dt_ids,\n\t},\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&imx_drm_pdrv,\n\t&ipu_drm_driver,\n};\n\nstatic int __init imx_drm_init(void)\n{\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\treturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n}\nmodule_init(imx_drm_init);\n\nstatic void __exit imx_drm_exit(void)\n{\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n}\nmodule_exit(imx_drm_exit);\n\nMODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\");\nMODULE_DESCRIPTION(\"i.MX drm driver core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}