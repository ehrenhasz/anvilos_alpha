{
  "module_name": "ipuv3-plane.c",
  "hash_id": "a07d101413df354fb804433948cc2381573fb9a3f37128b2784bcbe0d37043e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/ipuv3/ipuv3-plane.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_managed.h>\n\n#include <video/imx-ipu-v3.h>\n\n#include \"imx-drm.h\"\n#include \"ipuv3-plane.h\"\n\nstruct ipu_plane_state {\n\tstruct drm_plane_state base;\n\tbool use_pre;\n};\n\nstatic inline struct ipu_plane_state *\nto_ipu_plane_state(struct drm_plane_state *p)\n{\n\treturn container_of(p, struct ipu_plane_state, base);\n}\n\nstatic unsigned int ipu_src_rect_width(const struct drm_plane_state *state)\n{\n\treturn ALIGN(drm_rect_width(&state->src) >> 16, 8);\n}\n\nstatic inline struct ipu_plane *to_ipu_plane(struct drm_plane *p)\n{\n\treturn container_of(p, struct ipu_plane, base);\n}\n\nstatic const uint32_t ipu_plane_all_formats[] = {\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_BGRA5551,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YVU420,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YVU422,\n\tDRM_FORMAT_YUV444,\n\tDRM_FORMAT_YVU444,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV16,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB565_A8,\n\tDRM_FORMAT_BGR565_A8,\n\tDRM_FORMAT_RGB888_A8,\n\tDRM_FORMAT_BGR888_A8,\n\tDRM_FORMAT_RGBX8888_A8,\n\tDRM_FORMAT_BGRX8888_A8,\n};\n\nstatic const uint32_t ipu_plane_rgb_formats[] = {\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_BGRA5551,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB565_A8,\n\tDRM_FORMAT_BGR565_A8,\n\tDRM_FORMAT_RGB888_A8,\n\tDRM_FORMAT_BGR888_A8,\n\tDRM_FORMAT_RGBX8888_A8,\n\tDRM_FORMAT_BGRX8888_A8,\n};\n\nstatic const uint64_t ipu_format_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic const uint64_t pre_format_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_VIVANTE_TILED,\n\tDRM_FORMAT_MOD_VIVANTE_SUPER_TILED,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nint ipu_plane_irq(struct ipu_plane *ipu_plane)\n{\n\treturn ipu_idmac_channel_irq(ipu_plane->ipu, ipu_plane->ipu_ch,\n\t\t\t\t     IPU_IRQ_EOF);\n}\n\nstatic inline unsigned long\ndrm_plane_state_to_eba(struct drm_plane_state *state, int plane)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_gem_dma_object *dma_obj;\n\tint x = state->src.x1 >> 16;\n\tint y = state->src.y1 >> 16;\n\n\tdma_obj = drm_fb_dma_get_gem_obj(fb, plane);\n\tBUG_ON(!dma_obj);\n\n\treturn dma_obj->dma_addr + fb->offsets[plane] + fb->pitches[plane] * y +\n\t       fb->format->cpp[plane] * x;\n}\n\nstatic inline unsigned long\ndrm_plane_state_to_ubo(struct drm_plane_state *state)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_gem_dma_object *dma_obj;\n\tunsigned long eba = drm_plane_state_to_eba(state, 0);\n\tint x = state->src.x1 >> 16;\n\tint y = state->src.y1 >> 16;\n\n\tdma_obj = drm_fb_dma_get_gem_obj(fb, 1);\n\tBUG_ON(!dma_obj);\n\n\tx /= fb->format->hsub;\n\ty /= fb->format->vsub;\n\n\treturn dma_obj->dma_addr + fb->offsets[1] + fb->pitches[1] * y +\n\t       fb->format->cpp[1] * x - eba;\n}\n\nstatic inline unsigned long\ndrm_plane_state_to_vbo(struct drm_plane_state *state)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_gem_dma_object *dma_obj;\n\tunsigned long eba = drm_plane_state_to_eba(state, 0);\n\tint x = state->src.x1 >> 16;\n\tint y = state->src.y1 >> 16;\n\n\tdma_obj = drm_fb_dma_get_gem_obj(fb, 2);\n\tBUG_ON(!dma_obj);\n\n\tx /= fb->format->hsub;\n\ty /= fb->format->vsub;\n\n\treturn dma_obj->dma_addr + fb->offsets[2] + fb->pitches[2] * y +\n\t       fb->format->cpp[2] * x - eba;\n}\n\nstatic void ipu_plane_put_resources(struct drm_device *dev, void *ptr)\n{\n\tstruct ipu_plane *ipu_plane = ptr;\n\n\tif (!IS_ERR_OR_NULL(ipu_plane->dp))\n\t\tipu_dp_put(ipu_plane->dp);\n\tif (!IS_ERR_OR_NULL(ipu_plane->dmfc))\n\t\tipu_dmfc_put(ipu_plane->dmfc);\n\tif (!IS_ERR_OR_NULL(ipu_plane->ipu_ch))\n\t\tipu_idmac_put(ipu_plane->ipu_ch);\n\tif (!IS_ERR_OR_NULL(ipu_plane->alpha_ch))\n\t\tipu_idmac_put(ipu_plane->alpha_ch);\n}\n\nstatic int ipu_plane_get_resources(struct drm_device *dev,\n\t\t\t\t   struct ipu_plane *ipu_plane)\n{\n\tint ret;\n\tint alpha_ch;\n\n\tipu_plane->ipu_ch = ipu_idmac_get(ipu_plane->ipu, ipu_plane->dma);\n\tif (IS_ERR(ipu_plane->ipu_ch)) {\n\t\tret = PTR_ERR(ipu_plane->ipu_ch);\n\t\tDRM_ERROR(\"failed to get idmac channel: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = drmm_add_action_or_reset(dev, ipu_plane_put_resources, ipu_plane);\n\tif (ret)\n\t\treturn ret;\n\n\talpha_ch = ipu_channel_alpha_channel(ipu_plane->dma);\n\tif (alpha_ch >= 0) {\n\t\tipu_plane->alpha_ch = ipu_idmac_get(ipu_plane->ipu, alpha_ch);\n\t\tif (IS_ERR(ipu_plane->alpha_ch)) {\n\t\t\tret = PTR_ERR(ipu_plane->alpha_ch);\n\t\t\tDRM_ERROR(\"failed to get alpha idmac channel %d: %d\\n\",\n\t\t\t\t  alpha_ch, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tipu_plane->dmfc = ipu_dmfc_get(ipu_plane->ipu, ipu_plane->dma);\n\tif (IS_ERR(ipu_plane->dmfc)) {\n\t\tret = PTR_ERR(ipu_plane->dmfc);\n\t\tDRM_ERROR(\"failed to get dmfc: ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ipu_plane->dp_flow >= 0) {\n\t\tipu_plane->dp = ipu_dp_get(ipu_plane->ipu, ipu_plane->dp_flow);\n\t\tif (IS_ERR(ipu_plane->dp)) {\n\t\t\tret = PTR_ERR(ipu_plane->dp);\n\t\t\tDRM_ERROR(\"failed to get dp flow: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool ipu_plane_separate_alpha(struct ipu_plane *ipu_plane)\n{\n\tswitch (ipu_plane->base.state->fb->format->format) {\n\tcase DRM_FORMAT_RGB565_A8:\n\tcase DRM_FORMAT_BGR565_A8:\n\tcase DRM_FORMAT_RGB888_A8:\n\tcase DRM_FORMAT_BGR888_A8:\n\tcase DRM_FORMAT_RGBX8888_A8:\n\tcase DRM_FORMAT_BGRX8888_A8:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void ipu_plane_enable(struct ipu_plane *ipu_plane)\n{\n\tif (ipu_plane->dp)\n\t\tipu_dp_enable(ipu_plane->ipu);\n\tipu_dmfc_enable_channel(ipu_plane->dmfc);\n\tipu_idmac_enable_channel(ipu_plane->ipu_ch);\n\tif (ipu_plane_separate_alpha(ipu_plane))\n\t\tipu_idmac_enable_channel(ipu_plane->alpha_ch);\n\tif (ipu_plane->dp)\n\t\tipu_dp_enable_channel(ipu_plane->dp);\n}\n\nvoid ipu_plane_disable(struct ipu_plane *ipu_plane, bool disable_dp_channel)\n{\n\tint ret;\n\n\tDRM_DEBUG_KMS(\"[%d] %s\\n\", __LINE__, __func__);\n\n\tret = ipu_idmac_wait_busy(ipu_plane->ipu_ch, 50);\n\tif (ret == -ETIMEDOUT) {\n\t\tDRM_ERROR(\"[PLANE:%d] IDMAC timeout\\n\",\n\t\t\t  ipu_plane->base.base.id);\n\t}\n\n\tif (ipu_plane->dp && disable_dp_channel)\n\t\tipu_dp_disable_channel(ipu_plane->dp, false);\n\tipu_idmac_disable_channel(ipu_plane->ipu_ch);\n\tif (ipu_plane->alpha_ch)\n\t\tipu_idmac_disable_channel(ipu_plane->alpha_ch);\n\tipu_dmfc_disable_channel(ipu_plane->dmfc);\n\tif (ipu_plane->dp)\n\t\tipu_dp_disable(ipu_plane->ipu);\n\tif (ipu_prg_present(ipu_plane->ipu))\n\t\tipu_prg_channel_disable(ipu_plane->ipu_ch);\n}\n\nvoid ipu_plane_disable_deferred(struct drm_plane *plane)\n{\n\tstruct ipu_plane *ipu_plane = to_ipu_plane(plane);\n\n\tif (ipu_plane->disabling) {\n\t\tipu_plane->disabling = false;\n\t\tipu_plane_disable(ipu_plane, false);\n\t}\n}\n\nstatic void ipu_plane_state_reset(struct drm_plane *plane)\n{\n\tstruct ipu_plane_state *ipu_state;\n\n\tif (plane->state) {\n\t\tipu_state = to_ipu_plane_state(plane->state);\n\t\t__drm_atomic_helper_plane_destroy_state(plane->state);\n\t\tkfree(ipu_state);\n\t\tplane->state = NULL;\n\t}\n\n\tipu_state = kzalloc(sizeof(*ipu_state), GFP_KERNEL);\n\n\tif (ipu_state)\n\t\t__drm_atomic_helper_plane_reset(plane, &ipu_state->base);\n}\n\nstatic struct drm_plane_state *\nipu_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct ipu_plane_state *state;\n\n\tif (WARN_ON(!plane->state))\n\t\treturn NULL;\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_plane_duplicate_state(plane, &state->base);\n\n\treturn &state->base;\n}\n\nstatic void ipu_plane_destroy_state(struct drm_plane *plane,\n\t\t\t\t    struct drm_plane_state *state)\n{\n\tstruct ipu_plane_state *ipu_state = to_ipu_plane_state(state);\n\n\t__drm_atomic_helper_plane_destroy_state(state);\n\tkfree(ipu_state);\n}\n\nstatic bool ipu_plane_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t\t   uint32_t format, uint64_t modifier)\n{\n\tstruct ipu_soc *ipu = to_ipu_plane(plane)->ipu;\n\n\t \n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\treturn true;\n\n\t \n\treturn ipu_prg_format_supported(ipu, format, modifier);\n}\n\nstatic const struct drm_plane_funcs ipu_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.reset\t\t= ipu_plane_state_reset,\n\t.atomic_duplicate_state\t= ipu_plane_duplicate_state,\n\t.atomic_destroy_state\t= ipu_plane_destroy_state,\n\t.format_mod_supported = ipu_plane_format_mod_supported,\n};\n\nstatic int ipu_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_crtc_state *crtc_state;\n\tstruct device *dev = plane->dev->dev;\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct drm_framebuffer *old_fb = old_state->fb;\n\tunsigned long eba, ubo, vbo, old_ubo, old_vbo, alpha_eba;\n\tbool can_position = (plane->type == DRM_PLANE_TYPE_OVERLAY);\n\tint ret;\n\n\t \n\tif (!fb)\n\t\treturn 0;\n\n\tif (WARN_ON(!new_state->crtc))\n\t\treturn -EINVAL;\n\n\tcrtc_state =\n\t\tdrm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t   new_state->crtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn -EINVAL;\n\n\tret = drm_atomic_helper_check_plane_state(new_state, crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  can_position, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!crtc_state->enable)\n\t\treturn 0;\n\n\tswitch (plane->type) {\n\tcase DRM_PLANE_TYPE_PRIMARY:\n\t\t \n\t\tif (drm_rect_width(&new_state->dst) < 13)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase DRM_PLANE_TYPE_OVERLAY:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"Unsupported plane type %d\\n\", plane->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (drm_rect_height(&new_state->dst) < 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (old_fb &&\n\t    (drm_rect_width(&new_state->dst) != drm_rect_width(&old_state->dst) ||\n\t     drm_rect_height(&new_state->dst) != drm_rect_height(&old_state->dst) ||\n\t     fb->format != old_fb->format))\n\t\tcrtc_state->mode_changed = true;\n\n\teba = drm_plane_state_to_eba(new_state, 0);\n\n\tif (eba & 0x7)\n\t\treturn -EINVAL;\n\n\tif (fb->pitches[0] < 1 || fb->pitches[0] > 16384)\n\t\treturn -EINVAL;\n\n\tif (old_fb && fb->pitches[0] != old_fb->pitches[0])\n\t\tcrtc_state->mode_changed = true;\n\n\tif (ALIGN(fb->width, 8) * fb->format->cpp[0] >\n\t    fb->pitches[0] + fb->offsets[0]) {\n\t\tdev_warn(dev, \"pitch is not big enough for 8 pixels alignment\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_YUV420:\n\tcase DRM_FORMAT_YVU420:\n\tcase DRM_FORMAT_YUV422:\n\tcase DRM_FORMAT_YVU422:\n\tcase DRM_FORMAT_YUV444:\n\tcase DRM_FORMAT_YVU444:\n\t\t \n\t\tvbo = drm_plane_state_to_vbo(new_state);\n\n\t\tif (vbo & 0x7 || vbo > 0xfffff8)\n\t\t\treturn -EINVAL;\n\n\t\tif (old_fb && (fb->format == old_fb->format)) {\n\t\t\told_vbo = drm_plane_state_to_vbo(old_state);\n\t\t\tif (vbo != old_vbo)\n\t\t\t\tcrtc_state->mode_changed = true;\n\t\t}\n\n\t\tif (fb->pitches[1] != fb->pitches[2])\n\t\t\treturn -EINVAL;\n\n\t\tfallthrough;\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV16:\n\t\tubo = drm_plane_state_to_ubo(new_state);\n\n\t\tif (ubo & 0x7 || ubo > 0xfffff8)\n\t\t\treturn -EINVAL;\n\n\t\tif (old_fb && (fb->format == old_fb->format)) {\n\t\t\told_ubo = drm_plane_state_to_ubo(old_state);\n\t\t\tif (ubo != old_ubo)\n\t\t\t\tcrtc_state->mode_changed = true;\n\t\t}\n\n\t\tif (fb->pitches[1] < 1 || fb->pitches[1] > 16384)\n\t\t\treturn -EINVAL;\n\n\t\tif (old_fb && old_fb->pitches[1] != fb->pitches[1])\n\t\t\tcrtc_state->mode_changed = true;\n\n\t\t \n\t\tif (((new_state->src.x1 >> 16) & (fb->format->hsub - 1)) ||\n\t\t    ((new_state->src.y1 >> 16) & (fb->format->vsub - 1)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565_A8:\n\tcase DRM_FORMAT_BGR565_A8:\n\tcase DRM_FORMAT_RGB888_A8:\n\tcase DRM_FORMAT_BGR888_A8:\n\tcase DRM_FORMAT_RGBX8888_A8:\n\tcase DRM_FORMAT_BGRX8888_A8:\n\t\talpha_eba = drm_plane_state_to_eba(new_state, 1);\n\t\tif (alpha_eba & 0x7)\n\t\t\treturn -EINVAL;\n\n\t\tif (fb->pitches[1] < 1 || fb->pitches[1] > 16384)\n\t\t\treturn -EINVAL;\n\n\t\tif (old_fb && old_fb->pitches[1] != fb->pitches[1])\n\t\t\tcrtc_state->mode_changed = true;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void ipu_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct ipu_plane *ipu_plane = to_ipu_plane(plane);\n\n\tif (ipu_plane->dp)\n\t\tipu_dp_disable_channel(ipu_plane->dp, true);\n\tipu_plane->disabling = true;\n}\n\nstatic int ipu_chan_assign_axi_id(int ipu_chan)\n{\n\tswitch (ipu_chan) {\n\tcase IPUV3_CHANNEL_MEM_BG_SYNC:\n\t\treturn 1;\n\tcase IPUV3_CHANNEL_MEM_FG_SYNC:\n\t\treturn 2;\n\tcase IPUV3_CHANNEL_MEM_DC_SYNC:\n\t\treturn 3;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void ipu_calculate_bursts(u32 width, u32 cpp, u32 stride,\n\t\t\t\t u8 *burstsize, u8 *num_bursts)\n{\n\tconst unsigned int width_bytes = width * cpp;\n\tunsigned int npb, bursts;\n\n\t \n\tfor (npb = 64 / cpp; npb > 0; --npb) {\n\t\tif (round_up(width_bytes, npb * cpp) <= stride)\n\t\t\tbreak;\n\t}\n\t*burstsize = npb;\n\n\t \n\tfor (bursts = 8; bursts > 1; bursts /= 2) {\n\t\tif (round_up(width_bytes, npb * cpp * bursts) <= stride)\n\t\t\tbreak;\n\t}\n\t*num_bursts = bursts;\n}\n\nstatic void ipu_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct ipu_plane *ipu_plane = to_ipu_plane(plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct ipu_plane_state *ipu_state = to_ipu_plane_state(new_state);\n\tstruct drm_crtc_state *crtc_state = new_state->crtc->state;\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct drm_rect *dst = &new_state->dst;\n\tunsigned long eba, ubo, vbo;\n\tunsigned long alpha_eba = 0;\n\tenum ipu_color_space ics;\n\tunsigned int axi_id = 0;\n\tconst struct drm_format_info *info;\n\tu8 burstsize, num_bursts;\n\tu32 width, height;\n\tint active;\n\n\tif (ipu_plane->dp_flow == IPU_DP_FLOW_SYNC_FG)\n\t\tipu_dp_set_window_pos(ipu_plane->dp, dst->x1, dst->y1);\n\n\tswitch (ipu_plane->dp_flow) {\n\tcase IPU_DP_FLOW_SYNC_BG:\n\t\tif (new_state->normalized_zpos == 1) {\n\t\t\tipu_dp_set_global_alpha(ipu_plane->dp,\n\t\t\t\t\t\t!fb->format->has_alpha, 0xff,\n\t\t\t\t\t\ttrue);\n\t\t} else {\n\t\t\tipu_dp_set_global_alpha(ipu_plane->dp, true, 0, true);\n\t\t}\n\t\tbreak;\n\tcase IPU_DP_FLOW_SYNC_FG:\n\t\tif (new_state->normalized_zpos == 1) {\n\t\t\tipu_dp_set_global_alpha(ipu_plane->dp,\n\t\t\t\t\t\t!fb->format->has_alpha, 0xff,\n\t\t\t\t\t\tfalse);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (ipu_plane->dp_flow == IPU_DP_FLOW_SYNC_BG)\n\t\twidth = ipu_src_rect_width(new_state);\n\telse\n\t\twidth = drm_rect_width(&new_state->src) >> 16;\n\theight = drm_rect_height(&new_state->src) >> 16;\n\n\teba = drm_plane_state_to_eba(new_state, 0);\n\n\t \n\tif (ipu_state->use_pre) {\n\t\taxi_id = ipu_chan_assign_axi_id(ipu_plane->dma);\n\t\tipu_prg_channel_configure(ipu_plane->ipu_ch, axi_id, width,\n\t\t\t\t\t  height, fb->pitches[0],\n\t\t\t\t\t  fb->format->format, fb->modifier,\n\t\t\t\t\t  &eba);\n\t}\n\n\tif (!old_state->fb ||\n\t    old_state->fb->format->format != fb->format->format ||\n\t    old_state->color_encoding != new_state->color_encoding ||\n\t    old_state->color_range != new_state->color_range) {\n\t\tics = ipu_drm_fourcc_to_colorspace(fb->format->format);\n\t\tswitch (ipu_plane->dp_flow) {\n\t\tcase IPU_DP_FLOW_SYNC_BG:\n\t\t\tipu_dp_setup_channel(ipu_plane->dp, new_state->color_encoding,\n\t\t\t\t\t     new_state->color_range, ics,\n\t\t\t\t\t     IPUV3_COLORSPACE_RGB);\n\t\t\tbreak;\n\t\tcase IPU_DP_FLOW_SYNC_FG:\n\t\t\tipu_dp_setup_channel(ipu_plane->dp, new_state->color_encoding,\n\t\t\t\t\t     new_state->color_range, ics,\n\t\t\t\t\t     IPUV3_COLORSPACE_UNKNOWN);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (old_state->fb && !drm_atomic_crtc_needs_modeset(crtc_state)) {\n\t\t \n\t\tif (ipu_state->use_pre)\n\t\t\treturn;\n\t\tactive = ipu_idmac_get_current_buffer(ipu_plane->ipu_ch);\n\t\tipu_cpmem_set_buffer(ipu_plane->ipu_ch, !active, eba);\n\t\tipu_idmac_select_buffer(ipu_plane->ipu_ch, !active);\n\t\tif (ipu_plane_separate_alpha(ipu_plane)) {\n\t\t\tactive = ipu_idmac_get_current_buffer(ipu_plane->alpha_ch);\n\t\t\tipu_cpmem_set_buffer(ipu_plane->alpha_ch, !active,\n\t\t\t\t\t     alpha_eba);\n\t\t\tipu_idmac_select_buffer(ipu_plane->alpha_ch, !active);\n\t\t}\n\t\treturn;\n\t}\n\n\tics = ipu_drm_fourcc_to_colorspace(fb->format->format);\n\tswitch (ipu_plane->dp_flow) {\n\tcase IPU_DP_FLOW_SYNC_BG:\n\t\tipu_dp_setup_channel(ipu_plane->dp, DRM_COLOR_YCBCR_BT601,\n\t\t\t\t     DRM_COLOR_YCBCR_LIMITED_RANGE, ics,\n\t\t\t\t     IPUV3_COLORSPACE_RGB);\n\t\tbreak;\n\tcase IPU_DP_FLOW_SYNC_FG:\n\t\tipu_dp_setup_channel(ipu_plane->dp, DRM_COLOR_YCBCR_BT601,\n\t\t\t\t     DRM_COLOR_YCBCR_LIMITED_RANGE, ics,\n\t\t\t\t     IPUV3_COLORSPACE_UNKNOWN);\n\t\tbreak;\n\t}\n\n\tipu_dmfc_config_wait4eot(ipu_plane->dmfc, width);\n\n\tinfo = drm_format_info(fb->format->format);\n\tipu_calculate_bursts(width, info->cpp[0], fb->pitches[0],\n\t\t\t     &burstsize, &num_bursts);\n\n\tipu_cpmem_zero(ipu_plane->ipu_ch);\n\tipu_cpmem_set_resolution(ipu_plane->ipu_ch, width, height);\n\tipu_cpmem_set_fmt(ipu_plane->ipu_ch, fb->format->format);\n\tipu_cpmem_set_burstsize(ipu_plane->ipu_ch, burstsize);\n\tipu_cpmem_set_high_priority(ipu_plane->ipu_ch);\n\tipu_idmac_enable_watermark(ipu_plane->ipu_ch, true);\n\tipu_idmac_set_double_buffer(ipu_plane->ipu_ch, 1);\n\tipu_cpmem_set_stride(ipu_plane->ipu_ch, fb->pitches[0]);\n\tipu_cpmem_set_axi_id(ipu_plane->ipu_ch, axi_id);\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_YUV420:\n\tcase DRM_FORMAT_YVU420:\n\tcase DRM_FORMAT_YUV422:\n\tcase DRM_FORMAT_YVU422:\n\tcase DRM_FORMAT_YUV444:\n\tcase DRM_FORMAT_YVU444:\n\t\tubo = drm_plane_state_to_ubo(new_state);\n\t\tvbo = drm_plane_state_to_vbo(new_state);\n\t\tif (fb->format->format == DRM_FORMAT_YVU420 ||\n\t\t    fb->format->format == DRM_FORMAT_YVU422 ||\n\t\t    fb->format->format == DRM_FORMAT_YVU444)\n\t\t\tswap(ubo, vbo);\n\n\t\tipu_cpmem_set_yuv_planar_full(ipu_plane->ipu_ch,\n\t\t\t\t\t      fb->pitches[1], ubo, vbo);\n\n\t\tdev_dbg(ipu_plane->base.dev->dev,\n\t\t\t\"phy = %lu %lu %lu, x = %d, y = %d\", eba, ubo, vbo,\n\t\t\tnew_state->src.x1 >> 16, new_state->src.y1 >> 16);\n\t\tbreak;\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV16:\n\t\tubo = drm_plane_state_to_ubo(new_state);\n\n\t\tipu_cpmem_set_yuv_planar_full(ipu_plane->ipu_ch,\n\t\t\t\t\t      fb->pitches[1], ubo, ubo);\n\n\t\tdev_dbg(ipu_plane->base.dev->dev,\n\t\t\t\"phy = %lu %lu, x = %d, y = %d\", eba, ubo,\n\t\t\tnew_state->src.x1 >> 16, new_state->src.y1 >> 16);\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565_A8:\n\tcase DRM_FORMAT_BGR565_A8:\n\tcase DRM_FORMAT_RGB888_A8:\n\tcase DRM_FORMAT_BGR888_A8:\n\tcase DRM_FORMAT_RGBX8888_A8:\n\tcase DRM_FORMAT_BGRX8888_A8:\n\t\talpha_eba = drm_plane_state_to_eba(new_state, 1);\n\t\tnum_bursts = 0;\n\n\t\tdev_dbg(ipu_plane->base.dev->dev, \"phys = %lu %lu, x = %d, y = %d\",\n\t\t\teba, alpha_eba, new_state->src.x1 >> 16,\n\t\t\tnew_state->src.y1 >> 16);\n\n\t\tipu_cpmem_set_burstsize(ipu_plane->ipu_ch, 16);\n\n\t\tipu_cpmem_zero(ipu_plane->alpha_ch);\n\t\tipu_cpmem_set_resolution(ipu_plane->alpha_ch, width, height);\n\t\tipu_cpmem_set_format_passthrough(ipu_plane->alpha_ch, 8);\n\t\tipu_cpmem_set_high_priority(ipu_plane->alpha_ch);\n\t\tipu_idmac_set_double_buffer(ipu_plane->alpha_ch, 1);\n\t\tipu_cpmem_set_stride(ipu_plane->alpha_ch, fb->pitches[1]);\n\t\tipu_cpmem_set_burstsize(ipu_plane->alpha_ch, 16);\n\t\tipu_cpmem_set_buffer(ipu_plane->alpha_ch, 0, alpha_eba);\n\t\tipu_cpmem_set_buffer(ipu_plane->alpha_ch, 1, alpha_eba);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(ipu_plane->base.dev->dev, \"phys = %lu, x = %d, y = %d\",\n\t\t\teba, new_state->src.x1 >> 16, new_state->src.y1 >> 16);\n\t\tbreak;\n\t}\n\tipu_cpmem_set_buffer(ipu_plane->ipu_ch, 0, eba);\n\tipu_cpmem_set_buffer(ipu_plane->ipu_ch, 1, eba);\n\tipu_idmac_lock_enable(ipu_plane->ipu_ch, num_bursts);\n\tipu_plane_enable(ipu_plane);\n}\n\nstatic const struct drm_plane_helper_funcs ipu_plane_helper_funcs = {\n\t.atomic_check = ipu_plane_atomic_check,\n\t.atomic_disable = ipu_plane_atomic_disable,\n\t.atomic_update = ipu_plane_atomic_update,\n};\n\nbool ipu_plane_atomic_update_pending(struct drm_plane *plane)\n{\n\tstruct ipu_plane *ipu_plane = to_ipu_plane(plane);\n\tstruct drm_plane_state *state = plane->state;\n\tstruct ipu_plane_state *ipu_state = to_ipu_plane_state(state);\n\n\t \n\tif (!state->crtc)\n\t\treturn false;\n\n\tif (ipu_state->use_pre)\n\t\treturn ipu_prg_channel_configure_pending(ipu_plane->ipu_ch);\n\n\t \n\treturn false;\n}\nint ipu_planes_assign_pre(struct drm_device *dev,\n\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state, *crtc_state;\n\tstruct drm_plane_state *plane_state;\n\tstruct ipu_plane_state *ipu_state;\n\tstruct ipu_plane *ipu_plane;\n\tstruct drm_plane *plane;\n\tstruct drm_crtc *crtc;\n\tint available_pres = ipu_prg_max_active_channels();\n\tint ret, i;\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, crtc_state, i) {\n\t\tret = drm_atomic_add_affected_planes(state, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor_each_new_plane_in_state(state, plane, plane_state, i) {\n\t\tipu_state = to_ipu_plane_state(plane_state);\n\t\tipu_plane = to_ipu_plane(plane);\n\n\t\tif (!plane_state->fb) {\n\t\t\tipu_state->use_pre = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(plane_state->fb->flags & DRM_MODE_FB_MODIFIERS) ||\n\t\t    plane_state->fb->modifier == DRM_FORMAT_MOD_LINEAR)\n\t\t\tcontinue;\n\n\t\tif (!ipu_prg_present(ipu_plane->ipu) || !available_pres)\n\t\t\treturn -EINVAL;\n\n\t\tif (!ipu_prg_format_supported(ipu_plane->ipu,\n\t\t\t\t\t      plane_state->fb->format->format,\n\t\t\t\t\t      plane_state->fb->modifier))\n\t\t\treturn -EINVAL;\n\n\t\tipu_state->use_pre = true;\n\t\tavailable_pres--;\n\t}\n\n\tfor_each_new_plane_in_state(state, plane, plane_state, i) {\n\t\tipu_state = to_ipu_plane_state(plane_state);\n\t\tipu_plane = to_ipu_plane(plane);\n\n\t\tif (!plane_state->fb) {\n\t\t\tipu_state->use_pre = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((plane_state->fb->flags & DRM_MODE_FB_MODIFIERS) &&\n\t\t    plane_state->fb->modifier != DRM_FORMAT_MOD_LINEAR)\n\t\t\tcontinue;\n\n\t\t \n\t\tplane_state->fb->modifier = DRM_FORMAT_MOD_LINEAR;\n\n\t\tif (ipu_prg_present(ipu_plane->ipu) && available_pres &&\n\t\t    ipu_prg_format_supported(ipu_plane->ipu,\n\t\t\t\t\t     plane_state->fb->format->format,\n\t\t\t\t\t     plane_state->fb->modifier)) {\n\t\t\tipu_state->use_pre = true;\n\t\t\tavailable_pres--;\n\t\t} else {\n\t\t\tipu_state->use_pre = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct ipu_plane *ipu_plane_init(struct drm_device *dev, struct ipu_soc *ipu,\n\t\t\t\t int dma, int dp, unsigned int possible_crtcs,\n\t\t\t\t enum drm_plane_type type)\n{\n\tstruct ipu_plane *ipu_plane;\n\tconst uint64_t *modifiers = ipu_format_modifiers;\n\tunsigned int zpos = (type == DRM_PLANE_TYPE_PRIMARY) ? 0 : 1;\n\tunsigned int format_count;\n\tconst uint32_t *formats;\n\tint ret;\n\n\tDRM_DEBUG_KMS(\"channel %d, dp flow %d, possible_crtcs=0x%x\\n\",\n\t\t      dma, dp, possible_crtcs);\n\n\tif (dp == IPU_DP_FLOW_SYNC_BG || dp == IPU_DP_FLOW_SYNC_FG) {\n\t\tformats = ipu_plane_all_formats;\n\t\tformat_count = ARRAY_SIZE(ipu_plane_all_formats);\n\t} else {\n\t\tformats = ipu_plane_rgb_formats;\n\t\tformat_count = ARRAY_SIZE(ipu_plane_rgb_formats);\n\t}\n\n\tif (ipu_prg_present(ipu))\n\t\tmodifiers = pre_format_modifiers;\n\n\tipu_plane = drmm_universal_plane_alloc(dev, struct ipu_plane, base,\n\t\t\t\t\t       possible_crtcs, &ipu_plane_funcs,\n\t\t\t\t\t       formats, format_count, modifiers,\n\t\t\t\t\t       type, NULL);\n\tif (IS_ERR(ipu_plane)) {\n\t\tDRM_ERROR(\"failed to allocate and initialize %s plane\\n\",\n\t\t\t  zpos ? \"overlay\" : \"primary\");\n\t\treturn ipu_plane;\n\t}\n\n\tipu_plane->ipu = ipu;\n\tipu_plane->dma = dma;\n\tipu_plane->dp_flow = dp;\n\n\tdrm_plane_helper_add(&ipu_plane->base, &ipu_plane_helper_funcs);\n\n\tif (dp == IPU_DP_FLOW_SYNC_BG || dp == IPU_DP_FLOW_SYNC_FG)\n\t\tret = drm_plane_create_zpos_property(&ipu_plane->base, zpos, 0,\n\t\t\t\t\t\t     1);\n\telse\n\t\tret = drm_plane_create_zpos_immutable_property(&ipu_plane->base,\n\t\t\t\t\t\t\t       0);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = drm_plane_create_color_properties(&ipu_plane->base,\n\t\t\tBIT(DRM_COLOR_YCBCR_BT601) |\n\t\t\tBIT(DRM_COLOR_YCBCR_BT709),\n\t\t\tBIT(DRM_COLOR_YCBCR_LIMITED_RANGE),\n\t\t\tDRM_COLOR_YCBCR_BT601,\n\t\t\tDRM_COLOR_YCBCR_LIMITED_RANGE);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = ipu_plane_get_resources(dev, ipu_plane);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to get %s plane resources: %pe\\n\",\n\t\t\t  zpos ? \"overlay\" : \"primary\", &ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn ipu_plane;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}