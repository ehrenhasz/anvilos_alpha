{
  "module_name": "imx-tve.c",
  "hash_id": "3e2a65b4e69afcf10ee8b69da98760a263104fe5666d0a6a1383fadb9b425b4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/ipuv3/imx-tve.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/videodev2.h>\n\n#include <video/imx-ipu-v3.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"imx-drm.h\"\n\n#define TVE_COM_CONF_REG\t0x00\n#define TVE_TVDAC0_CONT_REG\t0x28\n#define TVE_TVDAC1_CONT_REG\t0x2c\n#define TVE_TVDAC2_CONT_REG\t0x30\n#define TVE_CD_CONT_REG\t\t0x34\n#define TVE_INT_CONT_REG\t0x64\n#define TVE_STAT_REG\t\t0x68\n#define TVE_TST_MODE_REG\t0x6c\n#define TVE_MV_CONT_REG\t\t0xdc\n\n \n#define TVE_SYNC_CH_2_EN\tBIT(22)\n#define TVE_SYNC_CH_1_EN\tBIT(21)\n#define TVE_SYNC_CH_0_EN\tBIT(20)\n#define TVE_TV_OUT_MODE_MASK\t(0x7 << 12)\n#define TVE_TV_OUT_DISABLE\t(0x0 << 12)\n#define TVE_TV_OUT_CVBS_0\t(0x1 << 12)\n#define TVE_TV_OUT_CVBS_2\t(0x2 << 12)\n#define TVE_TV_OUT_CVBS_0_2\t(0x3 << 12)\n#define TVE_TV_OUT_SVIDEO_0_1\t(0x4 << 12)\n#define TVE_TV_OUT_SVIDEO_0_1_CVBS2_2\t(0x5 << 12)\n#define TVE_TV_OUT_YPBPR\t(0x6 << 12)\n#define TVE_TV_OUT_RGB\t\t(0x7 << 12)\n#define TVE_TV_STAND_MASK\t(0xf << 8)\n#define TVE_TV_STAND_HD_1080P30\t(0xc << 8)\n#define TVE_P2I_CONV_EN\t\tBIT(7)\n#define TVE_INP_VIDEO_FORM\tBIT(6)\n#define TVE_INP_YCBCR_422\t(0x0 << 6)\n#define TVE_INP_YCBCR_444\t(0x1 << 6)\n#define TVE_DATA_SOURCE_MASK\t(0x3 << 4)\n#define TVE_DATA_SOURCE_BUS1\t(0x0 << 4)\n#define TVE_DATA_SOURCE_BUS2\t(0x1 << 4)\n#define TVE_DATA_SOURCE_EXT\t(0x2 << 4)\n#define TVE_DATA_SOURCE_TESTGEN\t(0x3 << 4)\n#define TVE_IPU_CLK_EN_OFS\t3\n#define TVE_IPU_CLK_EN\t\tBIT(3)\n#define TVE_DAC_SAMP_RATE_OFS\t1\n#define TVE_DAC_SAMP_RATE_WIDTH\t2\n#define TVE_DAC_SAMP_RATE_MASK\t(0x3 << 1)\n#define TVE_DAC_FULL_RATE\t(0x0 << 1)\n#define TVE_DAC_DIV2_RATE\t(0x1 << 1)\n#define TVE_DAC_DIV4_RATE\t(0x2 << 1)\n#define TVE_EN\t\t\tBIT(0)\n\n \n#define TVE_TVDAC_GAIN_MASK\t(0x3f << 0)\n\n \n#define TVE_CD_CH_2_SM_EN\tBIT(22)\n#define TVE_CD_CH_1_SM_EN\tBIT(21)\n#define TVE_CD_CH_0_SM_EN\tBIT(20)\n#define TVE_CD_CH_2_LM_EN\tBIT(18)\n#define TVE_CD_CH_1_LM_EN\tBIT(17)\n#define TVE_CD_CH_0_LM_EN\tBIT(16)\n#define TVE_CD_CH_2_REF_LVL\tBIT(10)\n#define TVE_CD_CH_1_REF_LVL\tBIT(9)\n#define TVE_CD_CH_0_REF_LVL\tBIT(8)\n#define TVE_CD_EN\t\tBIT(0)\n\n \n#define TVE_FRAME_END_IEN\tBIT(13)\n#define TVE_CD_MON_END_IEN\tBIT(2)\n#define TVE_CD_SM_IEN\t\tBIT(1)\n#define TVE_CD_LM_IEN\t\tBIT(0)\n\n \n#define TVE_TVDAC_TEST_MODE_MASK\t(0x7 << 0)\n\n#define IMX_TVE_DAC_VOLTAGE\t2750000\n\nenum {\n\tTVE_MODE_TVOUT,\n\tTVE_MODE_VGA,\n};\n\nstruct imx_tve_encoder {\n\tstruct drm_connector connector;\n\tstruct drm_encoder encoder;\n\tstruct imx_tve *tve;\n};\n\nstruct imx_tve {\n\tstruct device *dev;\n\tint mode;\n\tint di_hsync_pin;\n\tint di_vsync_pin;\n\n\tstruct regmap *regmap;\n\tstruct regulator *dac_reg;\n\tstruct i2c_adapter *ddc;\n\tstruct clk *clk;\n\tstruct clk *di_sel_clk;\n\tstruct clk_hw clk_hw_di;\n\tstruct clk *di_clk;\n};\n\nstatic inline struct imx_tve *con_to_tve(struct drm_connector *c)\n{\n\treturn container_of(c, struct imx_tve_encoder, connector)->tve;\n}\n\nstatic inline struct imx_tve *enc_to_tve(struct drm_encoder *e)\n{\n\treturn container_of(e, struct imx_tve_encoder, encoder)->tve;\n}\n\nstatic void tve_enable(struct imx_tve *tve)\n{\n\tclk_prepare_enable(tve->clk);\n\tregmap_update_bits(tve->regmap, TVE_COM_CONF_REG, TVE_EN, TVE_EN);\n\n\t \n\tregmap_write(tve->regmap, TVE_STAT_REG, 0xffffffff);\n\n\t \n\tif (tve->mode == TVE_MODE_VGA)\n\t\tregmap_write(tve->regmap, TVE_INT_CONT_REG, 0);\n\telse\n\t\tregmap_write(tve->regmap, TVE_INT_CONT_REG,\n\t\t\t     TVE_CD_SM_IEN |\n\t\t\t     TVE_CD_LM_IEN |\n\t\t\t     TVE_CD_MON_END_IEN);\n}\n\nstatic void tve_disable(struct imx_tve *tve)\n{\n\tregmap_update_bits(tve->regmap, TVE_COM_CONF_REG, TVE_EN, 0);\n\tclk_disable_unprepare(tve->clk);\n}\n\nstatic int tve_setup_tvout(struct imx_tve *tve)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int tve_setup_vga(struct imx_tve *tve)\n{\n\tunsigned int mask;\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(tve->regmap, TVE_TVDAC0_CONT_REG,\n\t\t\t\t TVE_TVDAC_GAIN_MASK, 0x0a);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(tve->regmap, TVE_TVDAC1_CONT_REG,\n\t\t\t\t TVE_TVDAC_GAIN_MASK, 0x0a);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(tve->regmap, TVE_TVDAC2_CONT_REG,\n\t\t\t\t TVE_TVDAC_GAIN_MASK, 0x0a);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmask = TVE_DATA_SOURCE_MASK | TVE_INP_VIDEO_FORM;\n\tval  = TVE_DATA_SOURCE_BUS2 | TVE_INP_YCBCR_444;\n\tmask |= TVE_TV_STAND_MASK       | TVE_P2I_CONV_EN;\n\tval  |= TVE_TV_STAND_HD_1080P30 | 0;\n\tmask |= TVE_TV_OUT_MODE_MASK | TVE_SYNC_CH_0_EN;\n\tval  |= TVE_TV_OUT_RGB       | TVE_SYNC_CH_0_EN;\n\tret = regmap_update_bits(tve->regmap, TVE_COM_CONF_REG, mask, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(tve->regmap, TVE_TST_MODE_REG,\n\t\t\t\t TVE_TVDAC_TEST_MODE_MASK, 1);\n}\n\nstatic int imx_tve_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct imx_tve *tve = con_to_tve(connector);\n\tstruct edid *edid;\n\tint ret = 0;\n\n\tif (!tve->ddc)\n\t\treturn 0;\n\n\tedid = drm_get_edid(connector, tve->ddc);\n\tif (edid) {\n\t\tdrm_connector_update_edid_property(connector, edid);\n\t\tret = drm_add_edid_modes(connector, edid);\n\t\tkfree(edid);\n\t}\n\n\treturn ret;\n}\n\nstatic enum drm_mode_status\nimx_tve_connector_mode_valid(struct drm_connector *connector,\n\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct imx_tve *tve = con_to_tve(connector);\n\tunsigned long rate;\n\n\t \n\trate = clk_round_rate(tve->clk, 2000UL * mode->clock) / 2000;\n\tif (rate == mode->clock)\n\t\treturn MODE_OK;\n\n\t \n\trate = clk_round_rate(tve->clk, 1000UL * mode->clock) / 1000;\n\tif (rate == mode->clock)\n\t\treturn MODE_OK;\n\n\tdev_warn(tve->dev, \"ignoring mode %dx%d\\n\",\n\t\t mode->hdisplay, mode->vdisplay);\n\n\treturn MODE_BAD;\n}\n\nstatic void imx_tve_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t     struct drm_display_mode *orig_mode,\n\t\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct imx_tve *tve = enc_to_tve(encoder);\n\tunsigned long rounded_rate;\n\tunsigned long rate;\n\tint div = 1;\n\tint ret;\n\n\t \n\trate = 2000UL * mode->clock;\n\tclk_set_rate(tve->clk, rate);\n\trounded_rate = clk_get_rate(tve->clk);\n\tif (rounded_rate >= rate)\n\t\tdiv = 2;\n\tclk_set_rate(tve->di_clk, rounded_rate / div);\n\n\tret = clk_set_parent(tve->di_sel_clk, tve->di_clk);\n\tif (ret < 0) {\n\t\tdev_err(tve->dev, \"failed to set di_sel parent to tve_di: %d\\n\",\n\t\t\tret);\n\t}\n\n\tregmap_update_bits(tve->regmap, TVE_COM_CONF_REG,\n\t\t\t   TVE_IPU_CLK_EN, TVE_IPU_CLK_EN);\n\n\tif (tve->mode == TVE_MODE_VGA)\n\t\tret = tve_setup_vga(tve);\n\telse\n\t\tret = tve_setup_tvout(tve);\n\tif (ret)\n\t\tdev_err(tve->dev, \"failed to set configuration: %d\\n\", ret);\n}\n\nstatic void imx_tve_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct imx_tve *tve = enc_to_tve(encoder);\n\n\ttve_enable(tve);\n}\n\nstatic void imx_tve_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct imx_tve *tve = enc_to_tve(encoder);\n\n\ttve_disable(tve);\n}\n\nstatic int imx_tve_atomic_check(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc_state);\n\tstruct imx_tve *tve = enc_to_tve(encoder);\n\n\timx_crtc_state->bus_format = MEDIA_BUS_FMT_GBR888_1X24;\n\timx_crtc_state->di_hsync_pin = tve->di_hsync_pin;\n\timx_crtc_state->di_vsync_pin = tve->di_vsync_pin;\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_funcs imx_tve_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = imx_drm_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_connector_helper_funcs imx_tve_connector_helper_funcs = {\n\t.get_modes = imx_tve_connector_get_modes,\n\t.mode_valid = imx_tve_connector_mode_valid,\n};\n\nstatic const struct drm_encoder_helper_funcs imx_tve_encoder_helper_funcs = {\n\t.mode_set = imx_tve_encoder_mode_set,\n\t.enable = imx_tve_encoder_enable,\n\t.disable = imx_tve_encoder_disable,\n\t.atomic_check = imx_tve_atomic_check,\n};\n\nstatic irqreturn_t imx_tve_irq_handler(int irq, void *data)\n{\n\tstruct imx_tve *tve = data;\n\tunsigned int val;\n\n\tregmap_read(tve->regmap, TVE_STAT_REG, &val);\n\n\t \n\tregmap_write(tve->regmap, TVE_STAT_REG, 0xffffffff);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned long clk_tve_di_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct imx_tve *tve = container_of(hw, struct imx_tve, clk_hw_di);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(tve->regmap, TVE_COM_CONF_REG, &val);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tswitch (val & TVE_DAC_SAMP_RATE_MASK) {\n\tcase TVE_DAC_DIV4_RATE:\n\t\treturn parent_rate / 4;\n\tcase TVE_DAC_DIV2_RATE:\n\t\treturn parent_rate / 2;\n\tcase TVE_DAC_FULL_RATE:\n\tdefault:\n\t\treturn parent_rate;\n\t}\n\n\treturn 0;\n}\n\nstatic long clk_tve_di_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long *prate)\n{\n\tunsigned long div;\n\n\tdiv = *prate / rate;\n\tif (div >= 4)\n\t\treturn *prate / 4;\n\telse if (div >= 2)\n\t\treturn *prate / 2;\n\treturn *prate;\n}\n\nstatic int clk_tve_di_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct imx_tve *tve = container_of(hw, struct imx_tve, clk_hw_di);\n\tunsigned long div;\n\tu32 val;\n\tint ret;\n\n\tdiv = parent_rate / rate;\n\tif (div >= 4)\n\t\tval = TVE_DAC_DIV4_RATE;\n\telse if (div >= 2)\n\t\tval = TVE_DAC_DIV2_RATE;\n\telse\n\t\tval = TVE_DAC_FULL_RATE;\n\n\tret = regmap_update_bits(tve->regmap, TVE_COM_CONF_REG,\n\t\t\t\t TVE_DAC_SAMP_RATE_MASK, val);\n\n\tif (ret < 0) {\n\t\tdev_err(tve->dev, \"failed to set divider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_tve_di_ops = {\n\t.round_rate = clk_tve_di_round_rate,\n\t.set_rate = clk_tve_di_set_rate,\n\t.recalc_rate = clk_tve_di_recalc_rate,\n};\n\nstatic int tve_clk_init(struct imx_tve *tve, void __iomem *base)\n{\n\tconst char *tve_di_parent[1];\n\tstruct clk_init_data init = {\n\t\t.name = \"tve_di\",\n\t\t.ops = &clk_tve_di_ops,\n\t\t.num_parents = 1,\n\t\t.flags = 0,\n\t};\n\n\ttve_di_parent[0] = __clk_get_name(tve->clk);\n\tinit.parent_names = (const char **)&tve_di_parent;\n\n\ttve->clk_hw_di.init = &init;\n\ttve->di_clk = devm_clk_register(tve->dev, &tve->clk_hw_di);\n\tif (IS_ERR(tve->di_clk)) {\n\t\tdev_err(tve->dev, \"failed to register TVE output clock: %ld\\n\",\n\t\t\tPTR_ERR(tve->di_clk));\n\t\treturn PTR_ERR(tve->di_clk);\n\t}\n\n\treturn 0;\n}\n\nstatic void imx_tve_disable_regulator(void *data)\n{\n\tstruct imx_tve *tve = data;\n\n\tregulator_disable(tve->dac_reg);\n}\n\nstatic bool imx_tve_readable_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg % 4 == 0) && (reg <= 0xdc);\n}\n\nstatic struct regmap_config tve_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\n\t.readable_reg = imx_tve_readable_reg,\n\n\t.fast_io = true,\n\n\t.max_register = 0xdc,\n};\n\nstatic const char * const imx_tve_modes[] = {\n\t[TVE_MODE_TVOUT]  = \"tvout\",\n\t[TVE_MODE_VGA] = \"vga\",\n};\n\nstatic int of_get_tve_mode(struct device_node *np)\n{\n\tconst char *bm;\n\tint ret, i;\n\n\tret = of_property_read_string(np, \"fsl,tve-mode\", &bm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx_tve_modes); i++)\n\t\tif (!strcasecmp(bm, imx_tve_modes[i]))\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int imx_tve_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct imx_tve *tve = dev_get_drvdata(dev);\n\tstruct imx_tve_encoder *tvee;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tint encoder_type;\n\tint ret;\n\n\tencoder_type = tve->mode == TVE_MODE_VGA ?\n\t\t       DRM_MODE_ENCODER_DAC : DRM_MODE_ENCODER_TVDAC;\n\n\ttvee = drmm_simple_encoder_alloc(drm, struct imx_tve_encoder, encoder,\n\t\t\t\t\t encoder_type);\n\tif (IS_ERR(tvee))\n\t\treturn PTR_ERR(tvee);\n\n\ttvee->tve = tve;\n\tencoder = &tvee->encoder;\n\tconnector = &tvee->connector;\n\n\tret = imx_drm_encoder_parse_of(drm, encoder, tve->dev->of_node);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_encoder_helper_add(encoder, &imx_tve_encoder_helper_funcs);\n\n\tdrm_connector_helper_add(connector, &imx_tve_connector_helper_funcs);\n\tret = drm_connector_init_with_ddc(drm, connector,\n\t\t\t\t\t  &imx_tve_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_VGA, tve->ddc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn drm_connector_attach_encoder(connector, encoder);\n}\n\nstatic const struct component_ops imx_tve_ops = {\n\t.bind\t= imx_tve_bind,\n};\n\nstatic int imx_tve_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *ddc_node;\n\tstruct imx_tve *tve;\n\tvoid __iomem *base;\n\tunsigned int val;\n\tint irq;\n\tint ret;\n\n\ttve = devm_kzalloc(dev, sizeof(*tve), GFP_KERNEL);\n\tif (!tve)\n\t\treturn -ENOMEM;\n\n\ttve->dev = dev;\n\n\tddc_node = of_parse_phandle(np, \"ddc-i2c-bus\", 0);\n\tif (ddc_node) {\n\t\ttve->ddc = of_find_i2c_adapter_by_node(ddc_node);\n\t\tof_node_put(ddc_node);\n\t}\n\n\ttve->mode = of_get_tve_mode(np);\n\tif (tve->mode != TVE_MODE_VGA) {\n\t\tdev_err(dev, \"only VGA mode supported, currently\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tve->mode == TVE_MODE_VGA) {\n\t\tret = of_property_read_u32(np, \"fsl,hsync-pin\",\n\t\t\t\t\t   &tve->di_hsync_pin);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to get hsync pin\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = of_property_read_u32(np, \"fsl,vsync-pin\",\n\t\t\t\t\t   &tve->di_vsync_pin);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to get vsync pin\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\ttve_regmap_config.lock_arg = tve;\n\ttve->regmap = devm_regmap_init_mmio_clk(dev, \"tve\", base,\n\t\t\t\t\t\t&tve_regmap_config);\n\tif (IS_ERR(tve->regmap)) {\n\t\tdev_err(dev, \"failed to init regmap: %ld\\n\",\n\t\t\tPTR_ERR(tve->regmap));\n\t\treturn PTR_ERR(tve->regmap);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\timx_tve_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\t\"imx-tve\", tve);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to request irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttve->dac_reg = devm_regulator_get(dev, \"dac\");\n\tif (!IS_ERR(tve->dac_reg)) {\n\t\tif (regulator_get_voltage(tve->dac_reg) != IMX_TVE_DAC_VOLTAGE)\n\t\t\tdev_warn(dev, \"dac voltage is not %d uV\\n\", IMX_TVE_DAC_VOLTAGE);\n\t\tret = regulator_enable(tve->dac_reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = devm_add_action_or_reset(dev, imx_tve_disable_regulator, tve);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\ttve->clk = devm_clk_get(dev, \"tve\");\n\tif (IS_ERR(tve->clk)) {\n\t\tdev_err(dev, \"failed to get high speed tve clock: %ld\\n\",\n\t\t\tPTR_ERR(tve->clk));\n\t\treturn PTR_ERR(tve->clk);\n\t}\n\n\t \n\ttve->di_sel_clk = devm_clk_get(dev, \"di_sel\");\n\tif (IS_ERR(tve->di_sel_clk)) {\n\t\tdev_err(dev, \"failed to get ipu di mux clock: %ld\\n\",\n\t\t\tPTR_ERR(tve->di_sel_clk));\n\t\treturn PTR_ERR(tve->di_sel_clk);\n\t}\n\n\tret = tve_clk_init(tve, base);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(tve->regmap, TVE_COM_CONF_REG, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read configuration register: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tif (val != 0x00100000) {\n\t\tdev_err(dev, \"configuration register default value indicates this is not a TVEv2\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = regmap_write(tve->regmap, TVE_CD_CONT_REG, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, tve);\n\n\treturn component_add(dev, &imx_tve_ops);\n}\n\nstatic int imx_tve_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &imx_tve_ops);\n\treturn 0;\n}\n\nstatic const struct of_device_id imx_tve_dt_ids[] = {\n\t{ .compatible = \"fsl,imx53-tve\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_tve_dt_ids);\n\nstatic struct platform_driver imx_tve_driver = {\n\t.probe\t\t= imx_tve_probe,\n\t.remove\t\t= imx_tve_remove,\n\t.driver\t\t= {\n\t\t.of_match_table = imx_tve_dt_ids,\n\t\t.name\t= \"imx-tve\",\n\t},\n};\n\nmodule_platform_driver(imx_tve_driver);\n\nMODULE_DESCRIPTION(\"i.MX Television Encoder driver\");\nMODULE_AUTHOR(\"Philipp Zabel, Pengutronix\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:imx-tve\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}