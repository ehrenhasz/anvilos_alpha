{
  "module_name": "ipuv3-crtc.c",
  "hash_id": "3c3ba770072854a578e6a5e99ce451a3e82b029dbd8cf591423215806e1a1ea6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/ipuv3/ipuv3-crtc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <video/imx-ipu-v3.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"imx-drm.h\"\n#include \"ipuv3-plane.h\"\n\n#define DRIVER_DESC\t\t\"i.MX IPUv3 Graphics\"\n\nstruct ipu_crtc {\n\tstruct device\t\t*dev;\n\tstruct drm_crtc\t\tbase;\n\n\t \n\tstruct ipu_plane\t*plane[2];\n\n\tstruct ipu_dc\t\t*dc;\n\tstruct ipu_di\t\t*di;\n\tint\t\t\tirq;\n\tstruct drm_pending_vblank_event *event;\n};\n\nstatic inline struct ipu_crtc *to_ipu_crtc(struct drm_crtc *crtc)\n{\n\treturn container_of(crtc, struct ipu_crtc, base);\n}\n\nstatic void ipu_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\n\tstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\n\n\tipu_prg_enable(ipu);\n\tipu_dc_enable(ipu);\n\tipu_dc_enable_channel(ipu_crtc->dc);\n\tipu_di_enable(ipu_crtc->di);\n}\n\nstatic void ipu_crtc_disable_planes(struct ipu_crtc *ipu_crtc,\n\t\t\t\t    struct drm_crtc_state *old_crtc_state)\n{\n\tbool disable_partial = false;\n\tbool disable_full = false;\n\tstruct drm_plane *plane;\n\n\tdrm_atomic_crtc_state_for_each_plane(plane, old_crtc_state) {\n\t\tif (plane == &ipu_crtc->plane[0]->base)\n\t\t\tdisable_full = true;\n\t\tif (ipu_crtc->plane[1] && plane == &ipu_crtc->plane[1]->base)\n\t\t\tdisable_partial = true;\n\t}\n\n\tif (disable_partial)\n\t\tipu_plane_disable(ipu_crtc->plane[1], true);\n\tif (disable_full)\n\t\tipu_plane_disable(ipu_crtc->plane[0], true);\n}\n\nstatic void ipu_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t      crtc);\n\tstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\n\tstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\n\n\tipu_dc_disable_channel(ipu_crtc->dc);\n\tipu_di_disable(ipu_crtc->di);\n\t \n\tipu_crtc_disable_planes(ipu_crtc, old_crtc_state);\n\tipu_dc_disable(ipu);\n\tipu_prg_disable(ipu);\n\n\tdrm_crtc_vblank_off(crtc);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (crtc->state->event && !crtc->state->active) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nstatic void imx_drm_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct imx_crtc_state *state;\n\n\tif (crtc->state)\n\t\t__drm_atomic_helper_crtc_destroy_state(crtc->state);\n\n\tkfree(to_imx_crtc_state(crtc->state));\n\tcrtc->state = NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &state->base);\n}\n\nstatic struct drm_crtc_state *imx_drm_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct imx_crtc_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);\n\n\tWARN_ON(state->base.crtc != crtc);\n\tstate->base.crtc = crtc;\n\n\treturn &state->base;\n}\n\nstatic void imx_drm_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_crtc_state *state)\n{\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\tkfree(to_imx_crtc_state(state));\n}\n\nstatic int ipu_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\n\n\tenable_irq(ipu_crtc->irq);\n\n\treturn 0;\n}\n\nstatic void ipu_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\n\n\tdisable_irq_nosync(ipu_crtc->irq);\n}\n\nstatic const struct drm_crtc_funcs ipu_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = imx_drm_crtc_reset,\n\t.atomic_duplicate_state = imx_drm_crtc_duplicate_state,\n\t.atomic_destroy_state = imx_drm_crtc_destroy_state,\n\t.enable_vblank = ipu_enable_vblank,\n\t.disable_vblank = ipu_disable_vblank,\n};\n\nstatic irqreturn_t ipu_irq_handler(int irq, void *dev_id)\n{\n\tstruct ipu_crtc *ipu_crtc = dev_id;\n\tstruct drm_crtc *crtc = &ipu_crtc->base;\n\tunsigned long flags;\n\tint i;\n\n\tdrm_crtc_handle_vblank(crtc);\n\n\tif (ipu_crtc->event) {\n\t\tfor (i = 0; i < ARRAY_SIZE(ipu_crtc->plane); i++) {\n\t\t\tstruct ipu_plane *plane = ipu_crtc->plane[i];\n\n\t\t\tif (!plane)\n\t\t\t\tcontinue;\n\n\t\t\tif (ipu_plane_atomic_update_pending(&plane->base))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(ipu_crtc->plane)) {\n\t\t\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\t\t\tdrm_crtc_send_vblank_event(crtc, ipu_crtc->event);\n\t\t\tipu_crtc->event = NULL;\n\t\t\tdrm_crtc_vblank_put(crtc);\n\t\t\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool ipu_crtc_mode_fixup(struct drm_crtc *crtc,\n\t\t\t\t  const struct drm_display_mode *mode,\n\t\t\t\t  struct drm_display_mode *adjusted_mode)\n{\n\tstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\n\tstruct videomode vm;\n\tint ret;\n\n\tdrm_display_mode_to_videomode(adjusted_mode, &vm);\n\n\tret = ipu_di_adjust_videomode(ipu_crtc->di, &vm);\n\tif (ret)\n\t\treturn false;\n\n\tif ((vm.vsync_len == 0) || (vm.hsync_len == 0))\n\t\treturn false;\n\n\tdrm_display_mode_from_videomode(&vm, adjusted_mode);\n\n\treturn true;\n}\n\nstatic int ipu_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tu32 primary_plane_mask = drm_plane_mask(crtc->primary);\n\n\tif (crtc_state->active && (primary_plane_mask & crtc_state->plane_mask) == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void ipu_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void ipu_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (crtc->state->event) {\n\t\tstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\n\n\t\tWARN_ON(drm_crtc_vblank_get(crtc));\n\t\tipu_crtc->event = crtc->state->event;\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nstatic void ipu_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_encoder *encoder;\n\tstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc->state);\n\tstruct ipu_di_signal_cfg sig_cfg = {};\n\tunsigned long encoder_types = 0;\n\n\tdev_dbg(ipu_crtc->dev, \"%s: mode->hdisplay: %d\\n\", __func__,\n\t\t\tmode->hdisplay);\n\tdev_dbg(ipu_crtc->dev, \"%s: mode->vdisplay: %d\\n\", __func__,\n\t\t\tmode->vdisplay);\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tif (encoder->crtc == crtc)\n\t\t\tencoder_types |= BIT(encoder->encoder_type);\n\t}\n\n\tdev_dbg(ipu_crtc->dev, \"%s: attached to encoder types 0x%lx\\n\",\n\t\t__func__, encoder_types);\n\n\t \n\tif (encoder_types & (BIT(DRM_MODE_ENCODER_DAC) |\n\t\t\t     BIT(DRM_MODE_ENCODER_LVDS)))\n\t\tsig_cfg.clkflags = IPU_DI_CLKMODE_SYNC | IPU_DI_CLKMODE_EXT;\n\telse if (encoder_types & BIT(DRM_MODE_ENCODER_TVDAC))\n\t\tsig_cfg.clkflags = IPU_DI_CLKMODE_EXT;\n\telse\n\t\tsig_cfg.clkflags = 0;\n\n\tsig_cfg.enable_pol = !(imx_crtc_state->bus_flags & DRM_BUS_FLAG_DE_LOW);\n\t \n\tsig_cfg.clk_pol = !!(imx_crtc_state->bus_flags &\n\t\t\t     DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE);\n\tsig_cfg.bus_format = imx_crtc_state->bus_format;\n\tsig_cfg.v_to_h_sync = 0;\n\tsig_cfg.hsync_pin = imx_crtc_state->di_hsync_pin;\n\tsig_cfg.vsync_pin = imx_crtc_state->di_vsync_pin;\n\n\tdrm_display_mode_to_videomode(mode, &sig_cfg.mode);\n\tif (!IS_ALIGNED(sig_cfg.mode.hactive, 8)) {\n\t\tunsigned int new_hactive = ALIGN(sig_cfg.mode.hactive, 8);\n\n\t\tdev_warn(ipu_crtc->dev, \"8-pixel align hactive %d -> %d\\n\",\n\t\t\t sig_cfg.mode.hactive, new_hactive);\n\n\t\tsig_cfg.mode.hfront_porch -= new_hactive - sig_cfg.mode.hactive;\n\t\tsig_cfg.mode.hactive = new_hactive;\n\t}\n\n\tipu_dc_init_sync(ipu_crtc->dc, ipu_crtc->di,\n\t\t\t mode->flags & DRM_MODE_FLAG_INTERLACE,\n\t\t\t imx_crtc_state->bus_format, sig_cfg.mode.hactive);\n\tipu_di_init_sync_panel(ipu_crtc->di, &sig_cfg);\n}\n\nstatic const struct drm_crtc_helper_funcs ipu_helper_funcs = {\n\t.mode_fixup = ipu_crtc_mode_fixup,\n\t.mode_set_nofb = ipu_crtc_mode_set_nofb,\n\t.atomic_check = ipu_crtc_atomic_check,\n\t.atomic_begin = ipu_crtc_atomic_begin,\n\t.atomic_flush = ipu_crtc_atomic_flush,\n\t.atomic_disable = ipu_crtc_atomic_disable,\n\t.atomic_enable = ipu_crtc_atomic_enable,\n};\n\nstatic void ipu_put_resources(struct drm_device *dev, void *ptr)\n{\n\tstruct ipu_crtc *ipu_crtc = ptr;\n\n\tif (!IS_ERR_OR_NULL(ipu_crtc->dc))\n\t\tipu_dc_put(ipu_crtc->dc);\n\tif (!IS_ERR_OR_NULL(ipu_crtc->di))\n\t\tipu_di_put(ipu_crtc->di);\n}\n\nstatic int ipu_get_resources(struct drm_device *dev, struct ipu_crtc *ipu_crtc,\n\t\t\t     struct ipu_client_platformdata *pdata)\n{\n\tstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\n\tint ret;\n\n\tipu_crtc->dc = ipu_dc_get(ipu, pdata->dc);\n\tif (IS_ERR(ipu_crtc->dc))\n\t\treturn PTR_ERR(ipu_crtc->dc);\n\n\tret = drmm_add_action_or_reset(dev, ipu_put_resources, ipu_crtc);\n\tif (ret)\n\t\treturn ret;\n\n\tipu_crtc->di = ipu_di_get(ipu, pdata->di);\n\tif (IS_ERR(ipu_crtc->di))\n\t\treturn PTR_ERR(ipu_crtc->di);\n\n\treturn 0;\n}\n\nstatic int ipu_drm_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct ipu_client_platformdata *pdata = dev->platform_data;\n\tstruct ipu_soc *ipu = dev_get_drvdata(dev->parent);\n\tstruct drm_device *drm = data;\n\tstruct ipu_plane *primary_plane;\n\tstruct ipu_crtc *ipu_crtc;\n\tstruct drm_crtc *crtc;\n\tint dp = -EINVAL;\n\tint ret;\n\n\tif (pdata->dp >= 0)\n\t\tdp = IPU_DP_FLOW_SYNC_BG;\n\tprimary_plane = ipu_plane_init(drm, ipu, pdata->dma[0], dp, 0,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY);\n\tif (IS_ERR(primary_plane))\n\t\treturn PTR_ERR(primary_plane);\n\n\tipu_crtc = drmm_crtc_alloc_with_planes(drm, struct ipu_crtc, base,\n\t\t\t\t\t       &primary_plane->base, NULL,\n\t\t\t\t\t       &ipu_crtc_funcs, NULL);\n\tif (IS_ERR(ipu_crtc))\n\t\treturn PTR_ERR(ipu_crtc);\n\n\tipu_crtc->dev = dev;\n\tipu_crtc->plane[0] = primary_plane;\n\n\tcrtc = &ipu_crtc->base;\n\tcrtc->port = pdata->of_node;\n\tdrm_crtc_helper_add(crtc, &ipu_helper_funcs);\n\n\tret = ipu_get_resources(drm, ipu_crtc, pdata);\n\tif (ret) {\n\t\tdev_err(ipu_crtc->dev, \"getting resources failed with %d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (pdata->dp >= 0 && pdata->dma[1] > 0) {\n\t\tipu_crtc->plane[1] = ipu_plane_init(drm, ipu, pdata->dma[1],\n\t\t\t\t\t\tIPU_DP_FLOW_SYNC_FG,\n\t\t\t\t\t\tdrm_crtc_mask(&ipu_crtc->base),\n\t\t\t\t\t\tDRM_PLANE_TYPE_OVERLAY);\n\t\tif (IS_ERR(ipu_crtc->plane[1]))\n\t\t\tipu_crtc->plane[1] = NULL;\n\t}\n\n\tipu_crtc->irq = ipu_plane_irq(ipu_crtc->plane[0]);\n\tret = devm_request_irq(ipu_crtc->dev, ipu_crtc->irq, ipu_irq_handler, 0,\n\t\t\t\"imx_drm\", ipu_crtc);\n\tif (ret < 0) {\n\t\tdev_err(ipu_crtc->dev, \"irq request failed with %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\t \n\tdisable_irq(ipu_crtc->irq);\n\n\treturn 0;\n}\n\nstatic const struct component_ops ipu_crtc_ops = {\n\t.bind = ipu_drm_bind,\n};\n\nstatic int ipu_drm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tif (!dev->platform_data)\n\t\treturn -EINVAL;\n\n\tret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\treturn component_add(dev, &ipu_crtc_ops);\n}\n\nstatic int ipu_drm_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &ipu_crtc_ops);\n\treturn 0;\n}\n\nstruct platform_driver ipu_drm_driver = {\n\t.driver = {\n\t\t.name = \"imx-ipuv3-crtc\",\n\t},\n\t.probe = ipu_drm_probe,\n\t.remove = ipu_drm_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}