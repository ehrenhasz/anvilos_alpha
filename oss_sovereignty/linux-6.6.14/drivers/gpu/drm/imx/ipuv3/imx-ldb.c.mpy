{
  "module_name": "imx-ldb.c",
  "hash_id": "023aecf84ba2fff72e3f4f6c470dfc1969dc42efed14b2bd8161d517c2427b10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/ipuv3/imx-ldb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/i2c.h>\n#include <linux/media-bus-format.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/regmap.h>\n#include <linux/videodev2.h>\n\n#include <video/of_display_timing.h>\n#include <video/of_videomode.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"imx-drm.h\"\n\n#define DRIVER_NAME \"imx-ldb\"\n\n#define LDB_CH0_MODE_EN_TO_DI0\t\t(1 << 0)\n#define LDB_CH0_MODE_EN_TO_DI1\t\t(3 << 0)\n#define LDB_CH0_MODE_EN_MASK\t\t(3 << 0)\n#define LDB_CH1_MODE_EN_TO_DI0\t\t(1 << 2)\n#define LDB_CH1_MODE_EN_TO_DI1\t\t(3 << 2)\n#define LDB_CH1_MODE_EN_MASK\t\t(3 << 2)\n#define LDB_SPLIT_MODE_EN\t\t(1 << 4)\n#define LDB_DATA_WIDTH_CH0_24\t\t(1 << 5)\n#define LDB_BIT_MAP_CH0_JEIDA\t\t(1 << 6)\n#define LDB_DATA_WIDTH_CH1_24\t\t(1 << 7)\n#define LDB_BIT_MAP_CH1_JEIDA\t\t(1 << 8)\n#define LDB_DI0_VS_POL_ACT_LOW\t\t(1 << 9)\n#define LDB_DI1_VS_POL_ACT_LOW\t\t(1 << 10)\n#define LDB_BGREF_RMODE_INT\t\t(1 << 15)\n\nstruct imx_ldb_channel;\n\nstruct imx_ldb_encoder {\n\tstruct drm_connector connector;\n\tstruct drm_encoder encoder;\n\tstruct imx_ldb_channel *channel;\n};\n\nstruct imx_ldb;\n\nstruct imx_ldb_channel {\n\tstruct imx_ldb *ldb;\n\n\t \n\tstruct drm_panel *panel;\n\tstruct drm_bridge *bridge;\n\n\tstruct device_node *child;\n\tstruct i2c_adapter *ddc;\n\tint chno;\n\tvoid *edid;\n\tstruct drm_display_mode mode;\n\tint mode_valid;\n\tu32 bus_format;\n\tu32 bus_flags;\n};\n\nstatic inline struct imx_ldb_channel *con_to_imx_ldb_ch(struct drm_connector *c)\n{\n\treturn container_of(c, struct imx_ldb_encoder, connector)->channel;\n}\n\nstatic inline struct imx_ldb_channel *enc_to_imx_ldb_ch(struct drm_encoder *e)\n{\n\treturn container_of(e, struct imx_ldb_encoder, encoder)->channel;\n}\n\nstruct bus_mux {\n\tint reg;\n\tint shift;\n\tint mask;\n};\n\nstruct imx_ldb {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct imx_ldb_channel channel[2];\n\tstruct clk *clk[2];  \n\tstruct clk *clk_sel[4];  \n\tstruct clk *clk_parent[4];  \n\tstruct clk *clk_pll[2];  \n\tu32 ldb_ctrl;\n\tconst struct bus_mux *lvds_mux;\n};\n\nstatic void imx_ldb_ch_set_bus_format(struct imx_ldb_channel *imx_ldb_ch,\n\t\t\t\t      u32 bus_format)\n{\n\tstruct imx_ldb *ldb = imx_ldb_ch->ldb;\n\tint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\n\n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\t\tif (imx_ldb_ch->chno == 0 || dual)\n\t\t\tldb->ldb_ctrl |= LDB_DATA_WIDTH_CH0_24;\n\t\tif (imx_ldb_ch->chno == 1 || dual)\n\t\t\tldb->ldb_ctrl |= LDB_DATA_WIDTH_CH1_24;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\t\tif (imx_ldb_ch->chno == 0 || dual)\n\t\t\tldb->ldb_ctrl |= LDB_DATA_WIDTH_CH0_24 |\n\t\t\t\t\t LDB_BIT_MAP_CH0_JEIDA;\n\t\tif (imx_ldb_ch->chno == 1 || dual)\n\t\t\tldb->ldb_ctrl |= LDB_DATA_WIDTH_CH1_24 |\n\t\t\t\t\t LDB_BIT_MAP_CH1_JEIDA;\n\t\tbreak;\n\t}\n}\n\nstatic int imx_ldb_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct imx_ldb_channel *imx_ldb_ch = con_to_imx_ldb_ch(connector);\n\tint num_modes;\n\n\tnum_modes = drm_panel_get_modes(imx_ldb_ch->panel, connector);\n\tif (num_modes > 0)\n\t\treturn num_modes;\n\n\tif (!imx_ldb_ch->edid && imx_ldb_ch->ddc)\n\t\timx_ldb_ch->edid = drm_get_edid(connector, imx_ldb_ch->ddc);\n\n\tif (imx_ldb_ch->edid) {\n\t\tdrm_connector_update_edid_property(connector,\n\t\t\t\t\t\t\timx_ldb_ch->edid);\n\t\tnum_modes = drm_add_edid_modes(connector, imx_ldb_ch->edid);\n\t}\n\n\tif (imx_ldb_ch->mode_valid) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_duplicate(connector->dev, &imx_ldb_ch->mode);\n\t\tif (!mode)\n\t\t\treturn -EINVAL;\n\t\tmode->type |= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tnum_modes++;\n\t}\n\n\treturn num_modes;\n}\n\nstatic void imx_ldb_set_clock(struct imx_ldb *ldb, int mux, int chno,\n\t\tunsigned long serial_clk, unsigned long di_clk)\n{\n\tint ret;\n\n\tdev_dbg(ldb->dev, \"%s: now: %ld want: %ld\\n\", __func__,\n\t\t\tclk_get_rate(ldb->clk_pll[chno]), serial_clk);\n\tclk_set_rate(ldb->clk_pll[chno], serial_clk);\n\n\tdev_dbg(ldb->dev, \"%s after: %ld\\n\", __func__,\n\t\t\tclk_get_rate(ldb->clk_pll[chno]));\n\n\tdev_dbg(ldb->dev, \"%s: now: %ld want: %ld\\n\", __func__,\n\t\t\tclk_get_rate(ldb->clk[chno]),\n\t\t\t(long int)di_clk);\n\tclk_set_rate(ldb->clk[chno], di_clk);\n\n\tdev_dbg(ldb->dev, \"%s after: %ld\\n\", __func__,\n\t\t\tclk_get_rate(ldb->clk[chno]));\n\n\t \n\tret = clk_set_parent(ldb->clk_sel[mux], ldb->clk[chno]);\n\tif (ret)\n\t\tdev_err(ldb->dev,\n\t\t\t\"unable to set di%d parent clock to ldb_di%d\\n\", mux,\n\t\t\tchno);\n}\n\nstatic void imx_ldb_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\n\tstruct imx_ldb *ldb = imx_ldb_ch->ldb;\n\tint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\n\tint mux = drm_of_encoder_active_port_id(imx_ldb_ch->child, encoder);\n\n\tif (mux < 0 || mux >= ARRAY_SIZE(ldb->clk_sel)) {\n\t\tdev_warn(ldb->dev, \"%s: invalid mux %d\\n\", __func__, mux);\n\t\treturn;\n\t}\n\n\tdrm_panel_prepare(imx_ldb_ch->panel);\n\n\tif (dual) {\n\t\tclk_set_parent(ldb->clk_sel[mux], ldb->clk[0]);\n\t\tclk_set_parent(ldb->clk_sel[mux], ldb->clk[1]);\n\n\t\tclk_prepare_enable(ldb->clk[0]);\n\t\tclk_prepare_enable(ldb->clk[1]);\n\t} else {\n\t\tclk_set_parent(ldb->clk_sel[mux], ldb->clk[imx_ldb_ch->chno]);\n\t}\n\n\tif (imx_ldb_ch == &ldb->channel[0] || dual) {\n\t\tldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\n\t\tif (mux == 0 || ldb->lvds_mux)\n\t\t\tldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI0;\n\t\telse if (mux == 1)\n\t\t\tldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI1;\n\t}\n\tif (imx_ldb_ch == &ldb->channel[1] || dual) {\n\t\tldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\n\t\tif (mux == 1 || ldb->lvds_mux)\n\t\t\tldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI1;\n\t\telse if (mux == 0)\n\t\t\tldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI0;\n\t}\n\n\tif (ldb->lvds_mux) {\n\t\tconst struct bus_mux *lvds_mux = NULL;\n\n\t\tif (imx_ldb_ch == &ldb->channel[0])\n\t\t\tlvds_mux = &ldb->lvds_mux[0];\n\t\telse if (imx_ldb_ch == &ldb->channel[1])\n\t\t\tlvds_mux = &ldb->lvds_mux[1];\n\n\t\tregmap_update_bits(ldb->regmap, lvds_mux->reg, lvds_mux->mask,\n\t\t\t\t   mux << lvds_mux->shift);\n\t}\n\n\tregmap_write(ldb->regmap, IOMUXC_GPR2, ldb->ldb_ctrl);\n\n\tdrm_panel_enable(imx_ldb_ch->panel);\n}\n\nstatic void\nimx_ldb_encoder_atomic_mode_set(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\tstruct drm_connector_state *connector_state)\n{\n\tstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\n\tstruct drm_display_mode *mode = &crtc_state->adjusted_mode;\n\tstruct imx_ldb *ldb = imx_ldb_ch->ldb;\n\tint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\n\tunsigned long serial_clk;\n\tunsigned long di_clk = mode->clock * 1000;\n\tint mux = drm_of_encoder_active_port_id(imx_ldb_ch->child, encoder);\n\tu32 bus_format = imx_ldb_ch->bus_format;\n\n\tif (mux < 0 || mux >= ARRAY_SIZE(ldb->clk_sel)) {\n\t\tdev_warn(ldb->dev, \"%s: invalid mux %d\\n\", __func__, mux);\n\t\treturn;\n\t}\n\n\tif (mode->clock > 170000) {\n\t\tdev_warn(ldb->dev,\n\t\t\t \"%s: mode exceeds 170 MHz pixel clock\\n\", __func__);\n\t}\n\tif (mode->clock > 85000 && !dual) {\n\t\tdev_warn(ldb->dev,\n\t\t\t \"%s: mode exceeds 85 MHz pixel clock\\n\", __func__);\n\t}\n\n\tif (!IS_ALIGNED(mode->hdisplay, 8)) {\n\t\tdev_warn(ldb->dev,\n\t\t\t \"%s: hdisplay does not align to 8 byte\\n\", __func__);\n\t}\n\n\tif (dual) {\n\t\tserial_clk = 3500UL * mode->clock;\n\t\timx_ldb_set_clock(ldb, mux, 0, serial_clk, di_clk);\n\t\timx_ldb_set_clock(ldb, mux, 1, serial_clk, di_clk);\n\t} else {\n\t\tserial_clk = 7000UL * mode->clock;\n\t\timx_ldb_set_clock(ldb, mux, imx_ldb_ch->chno, serial_clk,\n\t\t\t\t  di_clk);\n\t}\n\n\t \n\tif (imx_ldb_ch == &ldb->channel[0] || dual) {\n\t\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\t\tldb->ldb_ctrl |= LDB_DI0_VS_POL_ACT_LOW;\n\t\telse if (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\tldb->ldb_ctrl &= ~LDB_DI0_VS_POL_ACT_LOW;\n\t}\n\tif (imx_ldb_ch == &ldb->channel[1] || dual) {\n\t\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\t\tldb->ldb_ctrl |= LDB_DI1_VS_POL_ACT_LOW;\n\t\telse if (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\tldb->ldb_ctrl &= ~LDB_DI1_VS_POL_ACT_LOW;\n\t}\n\n\tif (!bus_format) {\n\t\tstruct drm_connector *connector = connector_state->connector;\n\t\tstruct drm_display_info *di = &connector->display_info;\n\n\t\tif (di->num_bus_formats)\n\t\t\tbus_format = di->bus_formats[0];\n\t}\n\timx_ldb_ch_set_bus_format(imx_ldb_ch, bus_format);\n}\n\nstatic void imx_ldb_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\n\tstruct imx_ldb *ldb = imx_ldb_ch->ldb;\n\tint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\n\tint mux, ret;\n\n\tdrm_panel_disable(imx_ldb_ch->panel);\n\n\tif (imx_ldb_ch == &ldb->channel[0] || dual)\n\t\tldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\n\tif (imx_ldb_ch == &ldb->channel[1] || dual)\n\t\tldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\n\n\tregmap_write(ldb->regmap, IOMUXC_GPR2, ldb->ldb_ctrl);\n\n\tif (dual) {\n\t\tclk_disable_unprepare(ldb->clk[0]);\n\t\tclk_disable_unprepare(ldb->clk[1]);\n\t}\n\n\tif (ldb->lvds_mux) {\n\t\tconst struct bus_mux *lvds_mux = NULL;\n\n\t\tif (imx_ldb_ch == &ldb->channel[0])\n\t\t\tlvds_mux = &ldb->lvds_mux[0];\n\t\telse if (imx_ldb_ch == &ldb->channel[1])\n\t\t\tlvds_mux = &ldb->lvds_mux[1];\n\n\t\tregmap_read(ldb->regmap, lvds_mux->reg, &mux);\n\t\tmux &= lvds_mux->mask;\n\t\tmux >>= lvds_mux->shift;\n\t} else {\n\t\tmux = (imx_ldb_ch == &ldb->channel[0]) ? 0 : 1;\n\t}\n\n\t \n\tret = clk_set_parent(ldb->clk_sel[mux], ldb->clk_parent[mux]);\n\tif (ret)\n\t\tdev_err(ldb->dev,\n\t\t\t\"unable to set di%d parent clock to original parent\\n\",\n\t\t\tmux);\n\n\tdrm_panel_unprepare(imx_ldb_ch->panel);\n}\n\nstatic int imx_ldb_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc_state);\n\tstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\n\tstruct drm_display_info *di = &conn_state->connector->display_info;\n\tu32 bus_format = imx_ldb_ch->bus_format;\n\n\t \n\tif (!bus_format && di->num_bus_formats) {\n\t\tbus_format = di->bus_formats[0];\n\t\timx_crtc_state->bus_flags = di->bus_flags;\n\t} else {\n\t\tbus_format = imx_ldb_ch->bus_format;\n\t\timx_crtc_state->bus_flags = imx_ldb_ch->bus_flags;\n\t}\n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\timx_crtc_state->bus_format = MEDIA_BUS_FMT_RGB666_1X18;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\t\timx_crtc_state->bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\timx_crtc_state->di_hsync_pin = 2;\n\timx_crtc_state->di_vsync_pin = 3;\n\n\treturn 0;\n}\n\n\nstatic const struct drm_connector_funcs imx_ldb_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = imx_drm_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_connector_helper_funcs imx_ldb_connector_helper_funcs = {\n\t.get_modes = imx_ldb_connector_get_modes,\n};\n\nstatic const struct drm_encoder_helper_funcs imx_ldb_encoder_helper_funcs = {\n\t.atomic_mode_set = imx_ldb_encoder_atomic_mode_set,\n\t.enable = imx_ldb_encoder_enable,\n\t.disable = imx_ldb_encoder_disable,\n\t.atomic_check = imx_ldb_encoder_atomic_check,\n};\n\nstatic int imx_ldb_get_clk(struct imx_ldb *ldb, int chno)\n{\n\tchar clkname[16];\n\n\tsnprintf(clkname, sizeof(clkname), \"di%d\", chno);\n\tldb->clk[chno] = devm_clk_get(ldb->dev, clkname);\n\tif (IS_ERR(ldb->clk[chno]))\n\t\treturn PTR_ERR(ldb->clk[chno]);\n\n\tsnprintf(clkname, sizeof(clkname), \"di%d_pll\", chno);\n\tldb->clk_pll[chno] = devm_clk_get(ldb->dev, clkname);\n\n\treturn PTR_ERR_OR_ZERO(ldb->clk_pll[chno]);\n}\n\nstatic int imx_ldb_register(struct drm_device *drm,\n\tstruct imx_ldb_channel *imx_ldb_ch)\n{\n\tstruct imx_ldb *ldb = imx_ldb_ch->ldb;\n\tstruct imx_ldb_encoder *ldb_encoder;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tint ret;\n\n\tldb_encoder = drmm_simple_encoder_alloc(drm, struct imx_ldb_encoder,\n\t\t\t\t\t\tencoder, DRM_MODE_ENCODER_LVDS);\n\tif (IS_ERR(ldb_encoder))\n\t\treturn PTR_ERR(ldb_encoder);\n\n\tldb_encoder->channel = imx_ldb_ch;\n\tconnector = &ldb_encoder->connector;\n\tencoder = &ldb_encoder->encoder;\n\n\tret = imx_drm_encoder_parse_of(drm, encoder, imx_ldb_ch->child);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx_ldb_get_clk(ldb, imx_ldb_ch->chno);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ldb->ldb_ctrl & LDB_SPLIT_MODE_EN) {\n\t\tret = imx_ldb_get_clk(ldb, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdrm_encoder_helper_add(encoder, &imx_ldb_encoder_helper_funcs);\n\n\tif (imx_ldb_ch->bridge) {\n\t\tret = drm_bridge_attach(encoder, imx_ldb_ch->bridge, NULL, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tdrm_connector_helper_add(connector,\n\t\t\t\t\t &imx_ldb_connector_helper_funcs);\n\t\tdrm_connector_init_with_ddc(drm, connector,\n\t\t\t\t\t    &imx_ldb_connector_funcs,\n\t\t\t\t\t    DRM_MODE_CONNECTOR_LVDS,\n\t\t\t\t\t    imx_ldb_ch->ddc);\n\t\tdrm_connector_attach_encoder(connector, encoder);\n\t}\n\n\treturn 0;\n}\n\nstruct imx_ldb_bit_mapping {\n\tu32 bus_format;\n\tu32 datawidth;\n\tconst char * const mapping;\n};\n\nstatic const struct imx_ldb_bit_mapping imx_ldb_bit_mappings[] = {\n\t{ MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,  18, \"spwg\" },\n\t{ MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,  24, \"spwg\" },\n\t{ MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA, 24, \"jeida\" },\n};\n\nstatic u32 of_get_bus_format(struct device *dev, struct device_node *np)\n{\n\tconst char *bm;\n\tu32 datawidth = 0;\n\tint ret, i;\n\n\tret = of_property_read_string(np, \"fsl,data-mapping\", &bm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tof_property_read_u32(np, \"fsl,data-width\", &datawidth);\n\n\tfor (i = 0; i < ARRAY_SIZE(imx_ldb_bit_mappings); i++) {\n\t\tif (!strcasecmp(bm, imx_ldb_bit_mappings[i].mapping) &&\n\t\t    datawidth == imx_ldb_bit_mappings[i].datawidth)\n\t\t\treturn imx_ldb_bit_mappings[i].bus_format;\n\t}\n\n\tdev_err(dev, \"invalid data mapping: %d-bit \\\"%s\\\"\\n\", datawidth, bm);\n\n\treturn -ENOENT;\n}\n\nstatic struct bus_mux imx6q_lvds_mux[2] = {\n\t{\n\t\t.reg = IOMUXC_GPR3,\n\t\t.shift = 6,\n\t\t.mask = IMX6Q_GPR3_LVDS0_MUX_CTL_MASK,\n\t}, {\n\t\t.reg = IOMUXC_GPR3,\n\t\t.shift = 8,\n\t\t.mask = IMX6Q_GPR3_LVDS1_MUX_CTL_MASK,\n\t}\n};\n\n \nstatic const struct of_device_id imx_ldb_dt_ids[] = {\n\t{ .compatible = \"fsl,imx6q-ldb\", .data = imx6q_lvds_mux, },\n\t{ .compatible = \"fsl,imx53-ldb\", .data = NULL, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, imx_ldb_dt_ids);\n\nstatic int imx_ldb_panel_ddc(struct device *dev,\n\t\tstruct imx_ldb_channel *channel, struct device_node *child)\n{\n\tstruct device_node *ddc_node;\n\tconst u8 *edidp;\n\tint ret;\n\n\tddc_node = of_parse_phandle(child, \"ddc-i2c-bus\", 0);\n\tif (ddc_node) {\n\t\tchannel->ddc = of_find_i2c_adapter_by_node(ddc_node);\n\t\tof_node_put(ddc_node);\n\t\tif (!channel->ddc) {\n\t\t\tdev_warn(dev, \"failed to get ddc i2c adapter\\n\");\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\t}\n\n\tif (!channel->ddc) {\n\t\tint edid_len;\n\n\t\t \n\t\tdev_dbg(dev, \"no ddc available\\n\");\n\n\t\tedidp = of_get_property(child, \"edid\", &edid_len);\n\t\tif (edidp) {\n\t\t\tchannel->edid = kmemdup(edidp, edid_len, GFP_KERNEL);\n\t\t\tif (!channel->edid)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!channel->panel) {\n\t\t\t \n\t\t\tret = of_get_drm_display_mode(child,\n\t\t\t\t\t\t      &channel->mode,\n\t\t\t\t\t\t      &channel->bus_flags,\n\t\t\t\t\t\t      OF_USE_NATIVE_MODE);\n\t\t\tif (!ret)\n\t\t\t\tchannel->mode_valid = 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int imx_ldb_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct imx_ldb *imx_ldb = dev_get_drvdata(dev);\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct imx_ldb_channel *channel = &imx_ldb->channel[i];\n\n\t\tif (!channel->ldb)\n\t\t\tcontinue;\n\n\t\tret = imx_ldb_register(drm, channel);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct component_ops imx_ldb_ops = {\n\t.bind\t= imx_ldb_bind,\n};\n\nstatic int imx_ldb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct of_device_id *of_id = of_match_device(imx_ldb_dt_ids, dev);\n\tstruct device_node *child;\n\tstruct imx_ldb *imx_ldb;\n\tint dual;\n\tint ret;\n\tint i;\n\n\timx_ldb = devm_kzalloc(dev, sizeof(*imx_ldb), GFP_KERNEL);\n\tif (!imx_ldb)\n\t\treturn -ENOMEM;\n\n\timx_ldb->regmap = syscon_regmap_lookup_by_phandle(np, \"gpr\");\n\tif (IS_ERR(imx_ldb->regmap)) {\n\t\tdev_err(dev, \"failed to get parent regmap\\n\");\n\t\treturn PTR_ERR(imx_ldb->regmap);\n\t}\n\n\t \n\tregmap_write(imx_ldb->regmap, IOMUXC_GPR2, 0);\n\n\timx_ldb->dev = dev;\n\n\tif (of_id)\n\t\timx_ldb->lvds_mux = of_id->data;\n\n\tdual = of_property_read_bool(np, \"fsl,dual-channel\");\n\tif (dual)\n\t\timx_ldb->ldb_ctrl |= LDB_SPLIT_MODE_EN;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tchar clkname[16];\n\n\t\tsprintf(clkname, \"di%d_sel\", i);\n\t\timx_ldb->clk_sel[i] = devm_clk_get(imx_ldb->dev, clkname);\n\t\tif (IS_ERR(imx_ldb->clk_sel[i])) {\n\t\t\tret = PTR_ERR(imx_ldb->clk_sel[i]);\n\t\t\timx_ldb->clk_sel[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\timx_ldb->clk_parent[i] = clk_get_parent(imx_ldb->clk_sel[i]);\n\t}\n\tif (i == 0)\n\t\treturn ret;\n\n\tfor_each_child_of_node(np, child) {\n\t\tstruct imx_ldb_channel *channel;\n\t\tint bus_format;\n\n\t\tret = of_property_read_u32(child, \"reg\", &i);\n\t\tif (ret || i < 0 || i > 1) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_child;\n\t\t}\n\n\t\tif (!of_device_is_available(child))\n\t\t\tcontinue;\n\n\t\tif (dual && i > 0) {\n\t\t\tdev_warn(dev, \"dual-channel mode, ignoring second output\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tchannel = &imx_ldb->channel[i];\n\t\tchannel->ldb = imx_ldb;\n\t\tchannel->chno = i;\n\n\t\t \n\t\tret = drm_of_find_panel_or_bridge(child,\n\t\t\t\t\t\t  imx_ldb->lvds_mux ? 4 : 2, 0,\n\t\t\t\t\t\t  &channel->panel, &channel->bridge);\n\t\tif (ret && ret != -ENODEV)\n\t\t\tgoto free_child;\n\n\t\t \n\t\tif (!channel->bridge) {\n\t\t\tret = imx_ldb_panel_ddc(dev, channel, child);\n\t\t\tif (ret)\n\t\t\t\tgoto free_child;\n\t\t}\n\n\t\tbus_format = of_get_bus_format(dev, child);\n\t\tif (bus_format == -EINVAL) {\n\t\t\t \n\t\t\tif (channel->panel && channel->panel->funcs &&\n\t\t\t    channel->panel->funcs->get_modes)\n\t\t\t\tbus_format = 0;\n\t\t}\n\t\tif (bus_format < 0) {\n\t\t\tdev_err(dev, \"could not determine data mapping: %d\\n\",\n\t\t\t\tbus_format);\n\t\t\tret = bus_format;\n\t\t\tgoto free_child;\n\t\t}\n\t\tchannel->bus_format = bus_format;\n\t\tchannel->child = child;\n\t}\n\n\tplatform_set_drvdata(pdev, imx_ldb);\n\n\treturn component_add(&pdev->dev, &imx_ldb_ops);\n\nfree_child:\n\tof_node_put(child);\n\treturn ret;\n}\n\nstatic int imx_ldb_remove(struct platform_device *pdev)\n{\n\tstruct imx_ldb *imx_ldb = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct imx_ldb_channel *channel = &imx_ldb->channel[i];\n\n\t\tkfree(channel->edid);\n\t\ti2c_put_adapter(channel->ddc);\n\t}\n\n\tcomponent_del(&pdev->dev, &imx_ldb_ops);\n\treturn 0;\n}\n\nstatic struct platform_driver imx_ldb_driver = {\n\t.probe\t\t= imx_ldb_probe,\n\t.remove\t\t= imx_ldb_remove,\n\t.driver\t\t= {\n\t\t.of_match_table = imx_ldb_dt_ids,\n\t\t.name\t= DRIVER_NAME,\n\t},\n};\n\nmodule_platform_driver(imx_ldb_driver);\n\nMODULE_DESCRIPTION(\"i.MX LVDS driver\");\nMODULE_AUTHOR(\"Sascha Hauer, Pengutronix\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}