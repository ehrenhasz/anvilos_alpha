{
  "module_name": "dcss-crtc.c",
  "hash_id": "aeb3b34a155b30cd748dd05dcf2481ee1fcf686a1d278d2c7f6f1ee47c7fba5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/dcss/dcss-crtc.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_vblank.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"dcss-dev.h\"\n#include \"dcss-kms.h\"\n\nstatic int dcss_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct dcss_crtc *dcss_crtc = container_of(crtc, struct dcss_crtc,\n\t\t\t\t\t\t   base);\n\tstruct dcss_dev *dcss = crtc->dev->dev_private;\n\n\tdcss_dtg_vblank_irq_enable(dcss->dtg, true);\n\n\tdcss_dtg_ctxld_kick_irq_enable(dcss->dtg, true);\n\n\tenable_irq(dcss_crtc->irq);\n\n\treturn 0;\n}\n\nstatic void dcss_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct dcss_crtc *dcss_crtc = container_of(crtc, struct dcss_crtc,\n\t\t\t\t\t\t   base);\n\tstruct dcss_dev *dcss = dcss_crtc->base.dev->dev_private;\n\n\tdisable_irq_nosync(dcss_crtc->irq);\n\n\tdcss_dtg_vblank_irq_enable(dcss->dtg, false);\n\n\tif (dcss_crtc->disable_ctxld_kick_irq)\n\t\tdcss_dtg_ctxld_kick_irq_enable(dcss->dtg, false);\n}\n\nstatic const struct drm_crtc_funcs dcss_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.destroy = drm_crtc_cleanup,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank = dcss_enable_vblank,\n\t.disable_vblank = dcss_disable_vblank,\n};\n\nstatic void dcss_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void dcss_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct dcss_crtc *dcss_crtc = container_of(crtc, struct dcss_crtc,\n\t\t\t\t\t\t   base);\n\tstruct dcss_dev *dcss = dcss_crtc->base.dev->dev_private;\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (crtc->state->event) {\n\t\tWARN_ON(drm_crtc_vblank_get(crtc));\n\t\tdrm_crtc_arm_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&crtc->dev->event_lock);\n\n\tif (dcss_dtg_is_enabled(dcss->dtg))\n\t\tdcss_ctxld_enable(dcss->ctxld);\n}\n\nstatic void dcss_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t      crtc);\n\tstruct dcss_crtc *dcss_crtc = container_of(crtc, struct dcss_crtc,\n\t\t\t\t\t\t   base);\n\tstruct dcss_dev *dcss = dcss_crtc->base.dev->dev_private;\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct drm_display_mode *old_mode = &old_crtc_state->adjusted_mode;\n\tstruct videomode vm;\n\n\tdrm_display_mode_to_videomode(mode, &vm);\n\n\tpm_runtime_get_sync(dcss->dev);\n\n\tvm.pixelclock = mode->crtc_clock * 1000;\n\n\tdcss_ss_subsam_set(dcss->ss);\n\tdcss_dtg_css_set(dcss->dtg);\n\n\tif (!drm_mode_equal(mode, old_mode) || !old_crtc_state->active) {\n\t\tdcss_dtg_sync_set(dcss->dtg, &vm);\n\t\tdcss_ss_sync_set(dcss->ss, &vm,\n\t\t\t\t mode->flags & DRM_MODE_FLAG_PHSYNC,\n\t\t\t\t mode->flags & DRM_MODE_FLAG_PVSYNC);\n\t}\n\n\tdcss_enable_dtg_and_ss(dcss);\n\n\tdcss_ctxld_enable(dcss->ctxld);\n\n\t \n\tdcss_crtc->disable_ctxld_kick_irq = true;\n}\n\nstatic void dcss_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t      crtc);\n\tstruct dcss_crtc *dcss_crtc = container_of(crtc, struct dcss_crtc,\n\t\t\t\t\t\t   base);\n\tstruct dcss_dev *dcss = dcss_crtc->base.dev->dev_private;\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct drm_display_mode *old_mode = &old_crtc_state->adjusted_mode;\n\n\tdrm_atomic_helper_disable_planes_on_crtc(old_crtc_state, false);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (crtc->state->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&crtc->dev->event_lock);\n\n\tdcss_dtg_ctxld_kick_irq_enable(dcss->dtg, true);\n\n\treinit_completion(&dcss->disable_completion);\n\n\tdcss_disable_dtg_and_ss(dcss);\n\n\tdcss_ctxld_enable(dcss->ctxld);\n\n\tif (!drm_mode_equal(mode, old_mode) || !crtc->state->active)\n\t\tif (!wait_for_completion_timeout(&dcss->disable_completion,\n\t\t\t\t\t\t msecs_to_jiffies(100)))\n\t\t\tdev_err(dcss->dev, \"Shutting off DTG timed out.\\n\");\n\n\t \n\tdcss_crtc->disable_ctxld_kick_irq = false;\n\n\tdrm_crtc_vblank_off(crtc);\n\n\tpm_runtime_mark_last_busy(dcss->dev);\n\tpm_runtime_put_autosuspend(dcss->dev);\n}\n\nstatic const struct drm_crtc_helper_funcs dcss_helper_funcs = {\n\t.atomic_begin = dcss_crtc_atomic_begin,\n\t.atomic_flush = dcss_crtc_atomic_flush,\n\t.atomic_enable = dcss_crtc_atomic_enable,\n\t.atomic_disable = dcss_crtc_atomic_disable,\n};\n\nstatic irqreturn_t dcss_crtc_irq_handler(int irq, void *dev_id)\n{\n\tstruct dcss_crtc *dcss_crtc = dev_id;\n\tstruct dcss_dev *dcss = dcss_crtc->base.dev->dev_private;\n\n\tif (!dcss_dtg_vblank_irq_valid(dcss->dtg))\n\t\treturn IRQ_NONE;\n\n\tif (dcss_ctxld_is_flushed(dcss->ctxld))\n\t\tdrm_crtc_handle_vblank(&dcss_crtc->base);\n\n\tdcss_dtg_vblank_irq_clear(dcss->dtg);\n\n\treturn IRQ_HANDLED;\n}\n\nint dcss_crtc_init(struct dcss_crtc *crtc, struct drm_device *drm)\n{\n\tstruct dcss_dev *dcss = drm->dev_private;\n\tstruct platform_device *pdev = to_platform_device(dcss->dev);\n\tint ret;\n\n\tcrtc->plane[0] = dcss_plane_init(drm, drm_crtc_mask(&crtc->base),\n\t\t\t\t\t DRM_PLANE_TYPE_PRIMARY, 0);\n\tif (IS_ERR(crtc->plane[0]))\n\t\treturn PTR_ERR(crtc->plane[0]);\n\n\tcrtc->base.port = dcss->of_port;\n\n\tdrm_crtc_helper_add(&crtc->base, &dcss_helper_funcs);\n\tret = drm_crtc_init_with_planes(drm, &crtc->base, &crtc->plane[0]->base,\n\t\t\t\t\tNULL, &dcss_crtc_funcs, NULL);\n\tif (ret) {\n\t\tdev_err(dcss->dev, \"failed to init crtc\\n\");\n\t\treturn ret;\n\t}\n\n\tcrtc->irq = platform_get_irq_byname(pdev, \"vblank\");\n\tif (crtc->irq < 0)\n\t\treturn crtc->irq;\n\n\tret = request_irq(crtc->irq, dcss_crtc_irq_handler,\n\t\t\t  0, \"dcss_drm\", crtc);\n\tif (ret) {\n\t\tdev_err(dcss->dev, \"irq request failed with %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdisable_irq(crtc->irq);\n\n\treturn 0;\n}\n\nvoid dcss_crtc_deinit(struct dcss_crtc *crtc, struct drm_device *drm)\n{\n\tfree_irq(crtc->irq, crtc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}