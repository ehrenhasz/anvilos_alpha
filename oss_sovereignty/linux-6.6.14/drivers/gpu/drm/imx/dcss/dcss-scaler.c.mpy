{
  "module_name": "dcss-scaler.c",
  "hash_id": "2fcdbf9ec9d22efcfc3b2c7b6d79e13c366f832781522c26d083460e8f13cb30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/dcss/dcss-scaler.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/slab.h>\n\n#include \"dcss-dev.h\"\n\n#define DCSS_SCALER_CTRL\t\t\t0x00\n#define   SCALER_EN\t\t\t\tBIT(0)\n#define   REPEAT_EN\t\t\t\tBIT(4)\n#define   SCALE2MEM_EN\t\t\t\tBIT(8)\n#define   MEM2OFIFO_EN\t\t\t\tBIT(12)\n#define DCSS_SCALER_OFIFO_CTRL\t\t\t0x04\n#define   OFIFO_LOW_THRES_POS\t\t\t0\n#define   OFIFO_LOW_THRES_MASK\t\t\tGENMASK(9, 0)\n#define   OFIFO_HIGH_THRES_POS\t\t\t16\n#define   OFIFO_HIGH_THRES_MASK\t\t\tGENMASK(25, 16)\n#define   UNDERRUN_DETECT_CLR\t\t\tBIT(26)\n#define   LOW_THRES_DETECT_CLR\t\t\tBIT(27)\n#define   HIGH_THRES_DETECT_CLR\t\t\tBIT(28)\n#define   UNDERRUN_DETECT_EN\t\t\tBIT(29)\n#define   LOW_THRES_DETECT_EN\t\t\tBIT(30)\n#define   HIGH_THRES_DETECT_EN\t\t\tBIT(31)\n#define DCSS_SCALER_SDATA_CTRL\t\t\t0x08\n#define   YUV_EN\t\t\t\tBIT(0)\n#define   RTRAM_8LINES\t\t\t\tBIT(1)\n#define   Y_UV_BYTE_SWAP\t\t\tBIT(4)\n#define   A2R10G10B10_FORMAT_POS\t\t8\n#define   A2R10G10B10_FORMAT_MASK\t\tGENMASK(11, 8)\n#define DCSS_SCALER_BIT_DEPTH\t\t\t0x0C\n#define   LUM_BIT_DEPTH_POS\t\t\t0\n#define   LUM_BIT_DEPTH_MASK\t\t\tGENMASK(1, 0)\n#define   CHR_BIT_DEPTH_POS\t\t\t4\n#define   CHR_BIT_DEPTH_MASK\t\t\tGENMASK(5, 4)\n#define DCSS_SCALER_SRC_FORMAT\t\t\t0x10\n#define DCSS_SCALER_DST_FORMAT\t\t\t0x14\n#define   FORMAT_MASK\t\t\t\tGENMASK(1, 0)\n#define DCSS_SCALER_SRC_LUM_RES\t\t\t0x18\n#define DCSS_SCALER_SRC_CHR_RES\t\t\t0x1C\n#define DCSS_SCALER_DST_LUM_RES\t\t\t0x20\n#define DCSS_SCALER_DST_CHR_RES\t\t\t0x24\n#define   WIDTH_POS\t\t\t\t0\n#define   WIDTH_MASK\t\t\t\tGENMASK(11, 0)\n#define   HEIGHT_POS\t\t\t\t16\n#define   HEIGHT_MASK\t\t\t\tGENMASK(27, 16)\n#define DCSS_SCALER_V_LUM_START\t\t\t0x48\n#define   V_START_MASK\t\t\t\tGENMASK(15, 0)\n#define DCSS_SCALER_V_LUM_INC\t\t\t0x4C\n#define   V_INC_MASK\t\t\t\tGENMASK(15, 0)\n#define DCSS_SCALER_H_LUM_START\t\t\t0x50\n#define   H_START_MASK\t\t\t\tGENMASK(18, 0)\n#define DCSS_SCALER_H_LUM_INC\t\t\t0x54\n#define   H_INC_MASK\t\t\t\tGENMASK(15, 0)\n#define DCSS_SCALER_V_CHR_START\t\t\t0x58\n#define DCSS_SCALER_V_CHR_INC\t\t\t0x5C\n#define DCSS_SCALER_H_CHR_START\t\t\t0x60\n#define DCSS_SCALER_H_CHR_INC\t\t\t0x64\n#define DCSS_SCALER_COEF_VLUM\t\t\t0x80\n#define DCSS_SCALER_COEF_HLUM\t\t\t0x140\n#define DCSS_SCALER_COEF_VCHR\t\t\t0x200\n#define DCSS_SCALER_COEF_HCHR\t\t\t0x300\n\nstruct dcss_scaler_ch {\n\tvoid __iomem *base_reg;\n\tu32 base_ofs;\n\tstruct dcss_scaler *scl;\n\n\tu32 sdata_ctrl;\n\tu32 scaler_ctrl;\n\n\tbool scaler_ctrl_chgd;\n\n\tu32 c_vstart;\n\tu32 c_hstart;\n\n\tbool use_nn_interpolation;\n};\n\nstruct dcss_scaler {\n\tstruct device *dev;\n\n\tstruct dcss_ctxld *ctxld;\n\tu32 ctx_id;\n\n\tstruct dcss_scaler_ch ch[3];\n};\n\n \n#define PSC_FRAC_BITS 30\n#define PSC_FRAC_SCALE BIT(PSC_FRAC_BITS)\n#define PSC_BITS_FOR_PHASE 4\n#define PSC_NUM_PHASES 16\n#define PSC_STORED_PHASES (PSC_NUM_PHASES / 2 + 1)\n#define PSC_NUM_TAPS 7\n#define PSC_NUM_TAPS_RGBA 5\n#define PSC_COEFF_PRECISION 10\n#define PSC_PHASE_FRACTION_BITS 13\n#define PSC_PHASE_MASK (PSC_NUM_PHASES - 1)\n#define PSC_Q_FRACTION 19\n#define PSC_Q_ROUND_OFFSET (1 << (PSC_Q_FRACTION - 1))\n\n \nstatic int mult_q(int A, int B)\n{\n\tint result;\n\ts64 temp;\n\n\ttemp = (int64_t)A * (int64_t)B;\n\ttemp += PSC_Q_ROUND_OFFSET;\n\tresult = (int)(temp >> PSC_Q_FRACTION);\n\treturn result;\n}\n\n \nstatic int div_q(int A, int B)\n{\n\tint result;\n\ts64 temp;\n\n\ttemp = (int64_t)A << PSC_Q_FRACTION;\n\tif ((temp >= 0 && B >= 0) || (temp < 0 && B < 0))\n\t\ttemp += B / 2;\n\telse\n\t\ttemp -= B / 2;\n\n\tresult = (int)(temp / B);\n\treturn result;\n}\n\n \nstatic int exp_approx_q(int x)\n{\n\tint sum = 1 << PSC_Q_FRACTION;\n\tint term = 1 << PSC_Q_FRACTION;\n\n\tterm = mult_q(term, div_q(x, 1 << PSC_Q_FRACTION));\n\tsum += term;\n\tterm = mult_q(term, div_q(x, 2 << PSC_Q_FRACTION));\n\tsum += term;\n\tterm = mult_q(term, div_q(x, 3 << PSC_Q_FRACTION));\n\tsum += term;\n\tterm = mult_q(term, div_q(x, 4 << PSC_Q_FRACTION));\n\tsum += term;\n\n\treturn sum;\n}\n\n \nstatic void dcss_scaler_gaussian_filter(int fc_q, bool use_5_taps,\n\t\t\t\t\tbool phase0_identity,\n\t\t\t\t\tint coef[][PSC_NUM_TAPS])\n{\n\tint sigma_q, g0_q, g1_q, g2_q;\n\tint tap_cnt1, tap_cnt2, tap_idx, phase_cnt;\n\tint mid;\n\tint phase;\n\tint i;\n\tint taps;\n\n\tif (use_5_taps)\n\t\tfor (phase = 0; phase < PSC_STORED_PHASES; phase++) {\n\t\t\tcoef[phase][0] = 0;\n\t\t\tcoef[phase][PSC_NUM_TAPS - 1] = 0;\n\t\t}\n\n\t \n\ttaps = use_5_taps ? PSC_NUM_TAPS_RGBA : PSC_NUM_TAPS;\n\tmid = (PSC_NUM_PHASES * taps) / 2 - 1;\n\tphase_cnt = (PSC_NUM_PHASES * (PSC_NUM_TAPS + 1)) / 2;\n\ttap_cnt1 = (PSC_NUM_PHASES * PSC_NUM_TAPS) / 2;\n\ttap_cnt2 = (PSC_NUM_PHASES * PSC_NUM_TAPS) / 2;\n\n\t \n\tsigma_q = div_q(PSC_Q_ROUND_OFFSET, fc_q);\n\tg0_q = 1 << PSC_Q_FRACTION;\n\tg1_q = exp_approx_q(div_q(-PSC_Q_ROUND_OFFSET,\n\t\t\t\t  mult_q(sigma_q, sigma_q)));\n\tg2_q = mult_q(g1_q, g1_q);\n\tcoef[phase_cnt & PSC_PHASE_MASK][tap_cnt1 >> PSC_BITS_FOR_PHASE] = g0_q;\n\n\tfor (i = 0; i < mid; i++) {\n\t\tphase_cnt++;\n\t\ttap_cnt1--;\n\t\ttap_cnt2++;\n\n\t\tg0_q = mult_q(g0_q, g1_q);\n\t\tg1_q = mult_q(g1_q, g2_q);\n\n\t\tif ((phase_cnt & PSC_PHASE_MASK) <= 8) {\n\t\t\ttap_idx = tap_cnt1 >> PSC_BITS_FOR_PHASE;\n\t\t\tcoef[phase_cnt & PSC_PHASE_MASK][tap_idx] = g0_q;\n\t\t}\n\t\tif (((-phase_cnt) & PSC_PHASE_MASK) <= 8) {\n\t\t\ttap_idx = tap_cnt2 >> PSC_BITS_FOR_PHASE;\n\t\t\tcoef[(-phase_cnt) & PSC_PHASE_MASK][tap_idx] = g0_q;\n\t\t}\n\t}\n\n\tphase_cnt++;\n\ttap_cnt1--;\n\tcoef[phase_cnt & PSC_PHASE_MASK][tap_cnt1 >> PSC_BITS_FOR_PHASE] = 0;\n\n\t \n\tif (phase0_identity)\n\t\tfor (i = 0; i < PSC_NUM_TAPS; i++)\n\t\t\tcoef[0][i] = i == (PSC_NUM_TAPS >> 1) ?\n\t\t\t\t\t\t(1 << PSC_COEFF_PRECISION) : 0;\n\n\t \n\tfor (phase = 0; phase < PSC_STORED_PHASES; phase++) {\n\t\tint sum = 0;\n\t\ts64 ll_temp;\n\n\t\tfor (i = 0; i < PSC_NUM_TAPS; i++)\n\t\t\tsum += coef[phase][i];\n\t\tfor (i = 0; i < PSC_NUM_TAPS; i++) {\n\t\t\tll_temp = coef[phase][i];\n\t\t\tll_temp <<= PSC_COEFF_PRECISION;\n\t\t\tll_temp += sum >> 1;\n\t\t\tll_temp /= sum;\n\t\t\tcoef[phase][i] = (int)ll_temp;\n\t\t}\n\t}\n}\n\nstatic void dcss_scaler_nearest_neighbor_filter(bool use_5_taps,\n\t\t\t\t\t\tint coef[][PSC_NUM_TAPS])\n{\n\tint i, j;\n\n\tfor (i = 0; i < PSC_STORED_PHASES; i++)\n\t\tfor (j = 0; j < PSC_NUM_TAPS; j++)\n\t\t\tcoef[i][j] = j == PSC_NUM_TAPS >> 1 ?\n\t\t\t\t\t\t(1 << PSC_COEFF_PRECISION) : 0;\n}\n\n \nstatic void dcss_scaler_filter_design(int src_length, int dst_length,\n\t\t\t\t      bool use_5_taps, bool phase0_identity,\n\t\t\t\t      int coef[][PSC_NUM_TAPS],\n\t\t\t\t      bool nn_interpolation)\n{\n\tint fc_q;\n\n\t \n\tif (dst_length >= src_length)\n\t\tfc_q = div_q(1, PSC_NUM_PHASES);\n\telse\n\t\tfc_q = div_q(dst_length, src_length * PSC_NUM_PHASES);\n\n\tif (nn_interpolation)\n\t\tdcss_scaler_nearest_neighbor_filter(use_5_taps, coef);\n\telse\n\t\t \n\t\tdcss_scaler_gaussian_filter(fc_q, use_5_taps, phase0_identity, coef);\n}\n\nstatic void dcss_scaler_write(struct dcss_scaler_ch *ch, u32 val, u32 ofs)\n{\n\tstruct dcss_scaler *scl = ch->scl;\n\n\tdcss_ctxld_write(scl->ctxld, scl->ctx_id, val, ch->base_ofs + ofs);\n}\n\nstatic int dcss_scaler_ch_init_all(struct dcss_scaler *scl,\n\t\t\t\t   unsigned long scaler_base)\n{\n\tstruct dcss_scaler_ch *ch;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tch = &scl->ch[i];\n\n\t\tch->base_ofs = scaler_base + i * 0x400;\n\n\t\tch->base_reg = ioremap(ch->base_ofs, SZ_4K);\n\t\tif (!ch->base_reg) {\n\t\t\tdev_err(scl->dev, \"scaler: unable to remap ch base\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tch->scl = scl;\n\t}\n\n\treturn 0;\n}\n\nint dcss_scaler_init(struct dcss_dev *dcss, unsigned long scaler_base)\n{\n\tstruct dcss_scaler *scaler;\n\n\tscaler = kzalloc(sizeof(*scaler), GFP_KERNEL);\n\tif (!scaler)\n\t\treturn -ENOMEM;\n\n\tdcss->scaler = scaler;\n\tscaler->dev = dcss->dev;\n\tscaler->ctxld = dcss->ctxld;\n\tscaler->ctx_id = CTX_SB_HP;\n\n\tif (dcss_scaler_ch_init_all(scaler, scaler_base)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (scaler->ch[i].base_reg)\n\t\t\t\tiounmap(scaler->ch[i].base_reg);\n\t\t}\n\n\t\tkfree(scaler);\n\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid dcss_scaler_exit(struct dcss_scaler *scl)\n{\n\tint ch_no;\n\n\tfor (ch_no = 0; ch_no < 3; ch_no++) {\n\t\tstruct dcss_scaler_ch *ch = &scl->ch[ch_no];\n\n\t\tdcss_writel(0, ch->base_reg + DCSS_SCALER_CTRL);\n\n\t\tif (ch->base_reg)\n\t\t\tiounmap(ch->base_reg);\n\t}\n\n\tkfree(scl);\n}\n\nvoid dcss_scaler_ch_enable(struct dcss_scaler *scl, int ch_num, bool en)\n{\n\tstruct dcss_scaler_ch *ch = &scl->ch[ch_num];\n\tu32 scaler_ctrl;\n\n\tscaler_ctrl = en ? SCALER_EN | REPEAT_EN : 0;\n\n\tif (en)\n\t\tdcss_scaler_write(ch, ch->sdata_ctrl, DCSS_SCALER_SDATA_CTRL);\n\n\tif (ch->scaler_ctrl != scaler_ctrl)\n\t\tch->scaler_ctrl_chgd = true;\n\n\tch->scaler_ctrl = scaler_ctrl;\n}\n\nstatic void dcss_scaler_yuv_enable(struct dcss_scaler_ch *ch, bool en)\n{\n\tch->sdata_ctrl &= ~YUV_EN;\n\tch->sdata_ctrl |= en ? YUV_EN : 0;\n}\n\nstatic void dcss_scaler_rtr_8lines_enable(struct dcss_scaler_ch *ch, bool en)\n{\n\tch->sdata_ctrl &= ~RTRAM_8LINES;\n\tch->sdata_ctrl |= en ? RTRAM_8LINES : 0;\n}\n\nstatic void dcss_scaler_bit_depth_set(struct dcss_scaler_ch *ch, int depth)\n{\n\tu32 val;\n\n\tval = depth == 30 ? 2 : 0;\n\n\tdcss_scaler_write(ch,\n\t\t\t  ((val << CHR_BIT_DEPTH_POS) & CHR_BIT_DEPTH_MASK) |\n\t\t\t  ((val << LUM_BIT_DEPTH_POS) & LUM_BIT_DEPTH_MASK),\n\t\t\t  DCSS_SCALER_BIT_DEPTH);\n}\n\nenum buffer_format {\n\tBUF_FMT_YUV420,\n\tBUF_FMT_YUV422,\n\tBUF_FMT_ARGB8888_YUV444,\n};\n\nenum chroma_location {\n\tPSC_LOC_HORZ_0_VERT_1_OVER_4 = 0,\n\tPSC_LOC_HORZ_1_OVER_4_VERT_1_OVER_4 = 1,\n\tPSC_LOC_HORZ_0_VERT_0 = 2,\n\tPSC_LOC_HORZ_1_OVER_4_VERT_0 = 3,\n\tPSC_LOC_HORZ_0_VERT_1_OVER_2 = 4,\n\tPSC_LOC_HORZ_1_OVER_4_VERT_1_OVER_2 = 5\n};\n\nstatic void dcss_scaler_format_set(struct dcss_scaler_ch *ch,\n\t\t\t\t   enum buffer_format src_fmt,\n\t\t\t\t   enum buffer_format dst_fmt)\n{\n\tdcss_scaler_write(ch, src_fmt, DCSS_SCALER_SRC_FORMAT);\n\tdcss_scaler_write(ch, dst_fmt, DCSS_SCALER_DST_FORMAT);\n}\n\nstatic void dcss_scaler_res_set(struct dcss_scaler_ch *ch,\n\t\t\t\tint src_xres, int src_yres,\n\t\t\t\tint dst_xres, int dst_yres,\n\t\t\t\tu32 pix_format, enum buffer_format dst_format)\n{\n\tu32 lsrc_xres, lsrc_yres, csrc_xres, csrc_yres;\n\tu32 ldst_xres, ldst_yres, cdst_xres, cdst_yres;\n\tbool src_is_444 = true;\n\n\tlsrc_xres = src_xres;\n\tcsrc_xres = src_xres;\n\tlsrc_yres = src_yres;\n\tcsrc_yres = src_yres;\n\tldst_xres = dst_xres;\n\tcdst_xres = dst_xres;\n\tldst_yres = dst_yres;\n\tcdst_yres = dst_yres;\n\n\tif (pix_format == DRM_FORMAT_UYVY || pix_format == DRM_FORMAT_VYUY ||\n\t    pix_format == DRM_FORMAT_YUYV || pix_format == DRM_FORMAT_YVYU) {\n\t\tcsrc_xres >>= 1;\n\t\tsrc_is_444 = false;\n\t} else if (pix_format == DRM_FORMAT_NV12 ||\n\t\t   pix_format == DRM_FORMAT_NV21) {\n\t\tcsrc_xres >>= 1;\n\t\tcsrc_yres >>= 1;\n\t\tsrc_is_444 = false;\n\t}\n\n\tif (dst_format == BUF_FMT_YUV422)\n\t\tcdst_xres >>= 1;\n\n\t \n\tif (src_is_444 && dst_format == BUF_FMT_YUV422) {\n\t\tlsrc_yres--;\n\t\tcsrc_yres--;\n\t}\n\n\tdcss_scaler_write(ch, (((lsrc_yres - 1) << HEIGHT_POS) & HEIGHT_MASK) |\n\t\t\t       (((lsrc_xres - 1) << WIDTH_POS) & WIDTH_MASK),\n\t\t\t  DCSS_SCALER_SRC_LUM_RES);\n\tdcss_scaler_write(ch, (((csrc_yres - 1) << HEIGHT_POS) & HEIGHT_MASK) |\n\t\t\t       (((csrc_xres - 1) << WIDTH_POS) & WIDTH_MASK),\n\t\t\t  DCSS_SCALER_SRC_CHR_RES);\n\tdcss_scaler_write(ch, (((ldst_yres - 1) << HEIGHT_POS) & HEIGHT_MASK) |\n\t\t\t       (((ldst_xres - 1) << WIDTH_POS) & WIDTH_MASK),\n\t\t\t  DCSS_SCALER_DST_LUM_RES);\n\tdcss_scaler_write(ch, (((cdst_yres - 1) << HEIGHT_POS) & HEIGHT_MASK) |\n\t\t\t       (((cdst_xres - 1) << WIDTH_POS) & WIDTH_MASK),\n\t\t\t  DCSS_SCALER_DST_CHR_RES);\n}\n\n#define downscale_fp(factor, fp_pos)\t\t((factor) << (fp_pos))\n#define upscale_fp(factor, fp_pos)\t\t((1 << (fp_pos)) / (factor))\n\nstruct dcss_scaler_factors {\n\tint downscale;\n\tint upscale;\n};\n\nstatic const struct dcss_scaler_factors dcss_scaler_factors[] = {\n\t{3, 8}, {5, 8}, {5, 8},\n};\n\nstatic void dcss_scaler_fractions_set(struct dcss_scaler_ch *ch,\n\t\t\t\t      int src_xres, int src_yres,\n\t\t\t\t      int dst_xres, int dst_yres,\n\t\t\t\t      u32 src_format, u32 dst_format,\n\t\t\t\t      enum chroma_location src_chroma_loc)\n{\n\tint src_c_xres, src_c_yres, dst_c_xres, dst_c_yres;\n\tu32 l_vinc, l_hinc, c_vinc, c_hinc;\n\tu32 c_vstart, c_hstart;\n\n\tsrc_c_xres = src_xres;\n\tsrc_c_yres = src_yres;\n\tdst_c_xres = dst_xres;\n\tdst_c_yres = dst_yres;\n\n\tc_vstart = 0;\n\tc_hstart = 0;\n\n\t \n\tif (src_format == BUF_FMT_YUV420) {\n\t\t \n\t\tswitch (src_chroma_loc) {\n\t\tcase PSC_LOC_HORZ_0_VERT_1_OVER_4:\n\t\tcase PSC_LOC_HORZ_1_OVER_4_VERT_1_OVER_4:\n\t\t\t \n\t\t\tc_vstart -= (1 << (PSC_PHASE_FRACTION_BITS - 2));\n\t\t\tbreak;\n\t\tcase PSC_LOC_HORZ_0_VERT_1_OVER_2:\n\t\tcase PSC_LOC_HORZ_1_OVER_4_VERT_1_OVER_2:\n\t\t\t \n\t\t\tc_vstart -= (1 << (PSC_PHASE_FRACTION_BITS - 1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tswitch (src_chroma_loc) {\n\t\tcase PSC_LOC_HORZ_1_OVER_4_VERT_1_OVER_4:\n\t\tcase PSC_LOC_HORZ_1_OVER_4_VERT_0:\n\t\tcase PSC_LOC_HORZ_1_OVER_4_VERT_1_OVER_2:\n\t\t\t \n\t\t\tc_hstart -= (1 << (PSC_PHASE_FRACTION_BITS - 2));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (src_format == BUF_FMT_YUV420) {\n\t\tsrc_c_xres >>= 1;\n\t\tsrc_c_yres >>= 1;\n\t} else if (src_format == BUF_FMT_YUV422) {\n\t\tsrc_c_xres >>= 1;\n\t}\n\n\tif (dst_format == BUF_FMT_YUV422)\n\t\tdst_c_xres >>= 1;\n\n\tl_vinc = ((src_yres << 13) + (dst_yres >> 1)) / dst_yres;\n\tc_vinc = ((src_c_yres << 13) + (dst_c_yres >> 1)) / dst_c_yres;\n\tl_hinc = ((src_xres << 13) + (dst_xres >> 1)) / dst_xres;\n\tc_hinc = ((src_c_xres << 13) + (dst_c_xres >> 1)) / dst_c_xres;\n\n\t \n\tch->c_vstart = c_vstart;\n\tch->c_hstart = c_hstart;\n\n\tdcss_scaler_write(ch, 0, DCSS_SCALER_V_LUM_START);\n\tdcss_scaler_write(ch, l_vinc, DCSS_SCALER_V_LUM_INC);\n\n\tdcss_scaler_write(ch, 0, DCSS_SCALER_H_LUM_START);\n\tdcss_scaler_write(ch, l_hinc, DCSS_SCALER_H_LUM_INC);\n\n\tdcss_scaler_write(ch, c_vstart, DCSS_SCALER_V_CHR_START);\n\tdcss_scaler_write(ch, c_vinc, DCSS_SCALER_V_CHR_INC);\n\n\tdcss_scaler_write(ch, c_hstart, DCSS_SCALER_H_CHR_START);\n\tdcss_scaler_write(ch, c_hinc, DCSS_SCALER_H_CHR_INC);\n}\n\nint dcss_scaler_get_min_max_ratios(struct dcss_scaler *scl, int ch_num,\n\t\t\t\t   int *min, int *max)\n{\n\t*min = upscale_fp(dcss_scaler_factors[ch_num].upscale, 16);\n\t*max = downscale_fp(dcss_scaler_factors[ch_num].downscale, 16);\n\n\treturn 0;\n}\n\nstatic void dcss_scaler_program_5_coef_set(struct dcss_scaler_ch *ch,\n\t\t\t\t\t   int base_addr,\n\t\t\t\t\t   int coef[][PSC_NUM_TAPS])\n{\n\tint i, phase;\n\n\tfor (i = 0; i < PSC_STORED_PHASES; i++) {\n\t\tdcss_scaler_write(ch, ((coef[i][1] & 0xfff) << 16 |\n\t\t\t\t       (coef[i][2] & 0xfff) << 4  |\n\t\t\t\t       (coef[i][3] & 0xf00) >> 8),\n\t\t\t\t  base_addr + i * sizeof(u32));\n\t\tdcss_scaler_write(ch, ((coef[i][3] & 0x0ff) << 20 |\n\t\t\t\t       (coef[i][4] & 0xfff) << 8  |\n\t\t\t\t       (coef[i][5] & 0xff0) >> 4),\n\t\t\t\t  base_addr + 0x40 + i * sizeof(u32));\n\t\tdcss_scaler_write(ch, ((coef[i][5] & 0x00f) << 24),\n\t\t\t\t  base_addr + 0x80 + i * sizeof(u32));\n\t}\n\n\t \n\tfor (phase = (PSC_NUM_PHASES >> 1) - 1;\n\t\t\ti < PSC_NUM_PHASES; i++, phase--) {\n\t\tdcss_scaler_write(ch, ((coef[phase][5] & 0xfff) << 16 |\n\t\t\t\t       (coef[phase][4] & 0xfff) << 4  |\n\t\t\t\t       (coef[phase][3] & 0xf00) >> 8),\n\t\t\t\t  base_addr + i * sizeof(u32));\n\t\tdcss_scaler_write(ch, ((coef[phase][3] & 0x0ff) << 20 |\n\t\t\t\t       (coef[phase][2] & 0xfff) << 8  |\n\t\t\t\t       (coef[phase][1] & 0xff0) >> 4),\n\t\t\t\t  base_addr + 0x40 + i * sizeof(u32));\n\t\tdcss_scaler_write(ch, ((coef[phase][1] & 0x00f) << 24),\n\t\t\t\t  base_addr + 0x80 + i * sizeof(u32));\n\t}\n}\n\nstatic void dcss_scaler_program_7_coef_set(struct dcss_scaler_ch *ch,\n\t\t\t\t\t   int base_addr,\n\t\t\t\t\t   int coef[][PSC_NUM_TAPS])\n{\n\tint i, phase;\n\n\tfor (i = 0; i < PSC_STORED_PHASES; i++) {\n\t\tdcss_scaler_write(ch, ((coef[i][0] & 0xfff) << 16 |\n\t\t\t\t       (coef[i][1] & 0xfff) << 4  |\n\t\t\t\t       (coef[i][2] & 0xf00) >> 8),\n\t\t\t\t  base_addr + i * sizeof(u32));\n\t\tdcss_scaler_write(ch, ((coef[i][2] & 0x0ff) << 20 |\n\t\t\t\t       (coef[i][3] & 0xfff) << 8  |\n\t\t\t\t       (coef[i][4] & 0xff0) >> 4),\n\t\t\t\t  base_addr + 0x40 + i * sizeof(u32));\n\t\tdcss_scaler_write(ch, ((coef[i][4] & 0x00f) << 24 |\n\t\t\t\t       (coef[i][5] & 0xfff) << 12 |\n\t\t\t\t       (coef[i][6] & 0xfff)),\n\t\t\t\t  base_addr + 0x80 + i * sizeof(u32));\n\t}\n\n\t \n\tfor (phase = (PSC_NUM_PHASES >> 1) - 1;\n\t\t\ti < PSC_NUM_PHASES; i++, phase--) {\n\t\tdcss_scaler_write(ch, ((coef[phase][6] & 0xfff) << 16 |\n\t\t\t\t       (coef[phase][5] & 0xfff) << 4  |\n\t\t\t\t       (coef[phase][4] & 0xf00) >> 8),\n\t\t\t\t  base_addr + i * sizeof(u32));\n\t\tdcss_scaler_write(ch, ((coef[phase][4] & 0x0ff) << 20 |\n\t\t\t\t       (coef[phase][3] & 0xfff) << 8  |\n\t\t\t\t       (coef[phase][2] & 0xff0) >> 4),\n\t\t\t\t  base_addr + 0x40 + i * sizeof(u32));\n\t\tdcss_scaler_write(ch, ((coef[phase][2] & 0x00f) << 24 |\n\t\t\t\t       (coef[phase][1] & 0xfff) << 12 |\n\t\t\t\t       (coef[phase][0] & 0xfff)),\n\t\t\t\t  base_addr + 0x80 + i * sizeof(u32));\n\t}\n}\n\nstatic void dcss_scaler_yuv_coef_set(struct dcss_scaler_ch *ch,\n\t\t\t\t     enum buffer_format src_format,\n\t\t\t\t     enum buffer_format dst_format,\n\t\t\t\t     bool use_5_taps,\n\t\t\t\t     int src_xres, int src_yres, int dst_xres,\n\t\t\t\t     int dst_yres)\n{\n\tint coef[PSC_STORED_PHASES][PSC_NUM_TAPS];\n\tbool program_5_taps = use_5_taps ||\n\t\t\t      (dst_format == BUF_FMT_YUV422 &&\n\t\t\t       src_format == BUF_FMT_ARGB8888_YUV444);\n\n\t \n\tdcss_scaler_filter_design(src_xres, dst_xres, false,\n\t\t\t\t  src_xres == dst_xres, coef,\n\t\t\t\t  ch->use_nn_interpolation);\n\tdcss_scaler_program_7_coef_set(ch, DCSS_SCALER_COEF_HLUM, coef);\n\n\t \n\tdcss_scaler_filter_design(src_yres, dst_yres, program_5_taps,\n\t\t\t\t  src_yres == dst_yres, coef,\n\t\t\t\t  ch->use_nn_interpolation);\n\n\tif (program_5_taps)\n\t\tdcss_scaler_program_5_coef_set(ch, DCSS_SCALER_COEF_VLUM, coef);\n\telse\n\t\tdcss_scaler_program_7_coef_set(ch, DCSS_SCALER_COEF_VLUM, coef);\n\n\t \n\tif (src_format != BUF_FMT_ARGB8888_YUV444)\n\t\tsrc_xres >>= 1;\n\tif (src_format == BUF_FMT_YUV420)\n\t\tsrc_yres >>= 1;\n\tif (dst_format != BUF_FMT_ARGB8888_YUV444)\n\t\tdst_xres >>= 1;\n\tif (dst_format == BUF_FMT_YUV420)  \n\t\tdst_yres >>= 1;\n\n\t \n\tdcss_scaler_filter_design(src_xres, dst_xres, false,\n\t\t\t\t  (src_xres == dst_xres) && (ch->c_hstart == 0),\n\t\t\t\t  coef, ch->use_nn_interpolation);\n\n\tdcss_scaler_program_7_coef_set(ch, DCSS_SCALER_COEF_HCHR, coef);\n\n\t \n\tdcss_scaler_filter_design(src_yres, dst_yres, program_5_taps,\n\t\t\t\t  (src_yres == dst_yres) && (ch->c_vstart == 0),\n\t\t\t\t  coef, ch->use_nn_interpolation);\n\tif (program_5_taps)\n\t\tdcss_scaler_program_5_coef_set(ch, DCSS_SCALER_COEF_VCHR, coef);\n\telse\n\t\tdcss_scaler_program_7_coef_set(ch, DCSS_SCALER_COEF_VCHR, coef);\n}\n\nstatic void dcss_scaler_rgb_coef_set(struct dcss_scaler_ch *ch,\n\t\t\t\t     int src_xres, int src_yres, int dst_xres,\n\t\t\t\t     int dst_yres)\n{\n\tint coef[PSC_STORED_PHASES][PSC_NUM_TAPS];\n\n\t \n\tdcss_scaler_filter_design(src_xres, dst_xres, false,\n\t\t\t\t  src_xres == dst_xres, coef,\n\t\t\t\t  ch->use_nn_interpolation);\n\tdcss_scaler_program_7_coef_set(ch, DCSS_SCALER_COEF_HLUM, coef);\n\n\t \n\tdcss_scaler_filter_design(src_yres, dst_yres, false,\n\t\t\t\t  src_yres == dst_yres, coef,\n\t\t\t\t  ch->use_nn_interpolation);\n\tdcss_scaler_program_7_coef_set(ch, DCSS_SCALER_COEF_VLUM, coef);\n}\n\nstatic void dcss_scaler_set_rgb10_order(struct dcss_scaler_ch *ch,\n\t\t\t\t\tconst struct drm_format_info *format)\n{\n\tu32 a2r10g10b10_format;\n\n\tif (format->is_yuv)\n\t\treturn;\n\n\tch->sdata_ctrl &= ~A2R10G10B10_FORMAT_MASK;\n\n\tif (format->depth != 30)\n\t\treturn;\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_XRGB2101010:\n\t\ta2r10g10b10_format = 0;\n\t\tbreak;\n\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\t\ta2r10g10b10_format = 5;\n\t\tbreak;\n\n\tcase DRM_FORMAT_RGBA1010102:\n\tcase DRM_FORMAT_RGBX1010102:\n\t\ta2r10g10b10_format = 6;\n\t\tbreak;\n\n\tcase DRM_FORMAT_BGRA1010102:\n\tcase DRM_FORMAT_BGRX1010102:\n\t\ta2r10g10b10_format = 11;\n\t\tbreak;\n\n\tdefault:\n\t\ta2r10g10b10_format = 0;\n\t\tbreak;\n\t}\n\n\tch->sdata_ctrl |= a2r10g10b10_format << A2R10G10B10_FORMAT_POS;\n}\n\nvoid dcss_scaler_set_filter(struct dcss_scaler *scl, int ch_num,\n\t\t\t    enum drm_scaling_filter scaling_filter)\n{\n\tstruct dcss_scaler_ch *ch = &scl->ch[ch_num];\n\n\tch->use_nn_interpolation = scaling_filter == DRM_SCALING_FILTER_NEAREST_NEIGHBOR;\n}\n\nvoid dcss_scaler_setup(struct dcss_scaler *scl, int ch_num,\n\t\t       const struct drm_format_info *format,\n\t\t       int src_xres, int src_yres, int dst_xres, int dst_yres,\n\t\t       u32 vrefresh_hz)\n{\n\tstruct dcss_scaler_ch *ch = &scl->ch[ch_num];\n\tunsigned int pixel_depth = 0;\n\tbool rtr_8line_en = false;\n\tbool use_5_taps = false;\n\tenum buffer_format src_format = BUF_FMT_ARGB8888_YUV444;\n\tenum buffer_format dst_format = BUF_FMT_ARGB8888_YUV444;\n\tu32 pix_format = format->format;\n\n\tif (format->is_yuv) {\n\t\tdcss_scaler_yuv_enable(ch, true);\n\n\t\tif (pix_format == DRM_FORMAT_NV12 ||\n\t\t    pix_format == DRM_FORMAT_NV21) {\n\t\t\trtr_8line_en = true;\n\t\t\tsrc_format = BUF_FMT_YUV420;\n\t\t} else if (pix_format == DRM_FORMAT_UYVY ||\n\t\t\t   pix_format == DRM_FORMAT_VYUY ||\n\t\t\t   pix_format == DRM_FORMAT_YUYV ||\n\t\t\t   pix_format == DRM_FORMAT_YVYU) {\n\t\t\tsrc_format = BUF_FMT_YUV422;\n\t\t}\n\n\t\tuse_5_taps = !rtr_8line_en;\n\t} else {\n\t\tdcss_scaler_yuv_enable(ch, false);\n\n\t\tpixel_depth = format->depth;\n\t}\n\n\tdcss_scaler_fractions_set(ch, src_xres, src_yres, dst_xres,\n\t\t\t\t  dst_yres, src_format, dst_format,\n\t\t\t\t  PSC_LOC_HORZ_0_VERT_1_OVER_4);\n\n\tif (format->is_yuv)\n\t\tdcss_scaler_yuv_coef_set(ch, src_format, dst_format,\n\t\t\t\t\t use_5_taps, src_xres, src_yres,\n\t\t\t\t\t dst_xres, dst_yres);\n\telse\n\t\tdcss_scaler_rgb_coef_set(ch, src_xres, src_yres,\n\t\t\t\t\t dst_xres, dst_yres);\n\n\tdcss_scaler_rtr_8lines_enable(ch, rtr_8line_en);\n\tdcss_scaler_bit_depth_set(ch, pixel_depth);\n\tdcss_scaler_set_rgb10_order(ch, format);\n\tdcss_scaler_format_set(ch, src_format, dst_format);\n\tdcss_scaler_res_set(ch, src_xres, src_yres, dst_xres, dst_yres,\n\t\t\t    pix_format, dst_format);\n}\n\n \nvoid dcss_scaler_write_sclctrl(struct dcss_scaler *scl)\n{\n\tint chnum;\n\n\tdcss_ctxld_assert_locked(scl->ctxld);\n\n\tfor (chnum = 0; chnum < 3; chnum++) {\n\t\tstruct dcss_scaler_ch *ch = &scl->ch[chnum];\n\n\t\tif (ch->scaler_ctrl_chgd) {\n\t\t\tdcss_ctxld_write_irqsafe(scl->ctxld, scl->ctx_id,\n\t\t\t\t\t\t ch->scaler_ctrl,\n\t\t\t\t\t\t ch->base_ofs +\n\t\t\t\t\t\t DCSS_SCALER_CTRL);\n\t\t\tch->scaler_ctrl_chgd = false;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}