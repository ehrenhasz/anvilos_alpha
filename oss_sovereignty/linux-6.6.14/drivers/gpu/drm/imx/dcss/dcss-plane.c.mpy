{
  "module_name": "dcss-plane.c",
  "hash_id": "2a632ac1df0d9fd8c068c9229277f50926b00c28d708b8d33c7e6f43aa1cab71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/dcss/dcss-plane.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n\n#include \"dcss-dev.h\"\n#include \"dcss-kms.h\"\n\nstatic const u32 dcss_common_formats[] = {\n\t \n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_RGBX1010102,\n\tDRM_FORMAT_BGRX1010102,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_RGBA1010102,\n\tDRM_FORMAT_BGRA1010102,\n};\n\nstatic const u64 dcss_video_format_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID,\n};\n\nstatic const u64 dcss_graphics_format_modifiers[] = {\n\tDRM_FORMAT_MOD_VIVANTE_TILED,\n\tDRM_FORMAT_MOD_VIVANTE_SUPER_TILED,\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID,\n};\n\nstatic inline struct dcss_plane *to_dcss_plane(struct drm_plane *p)\n{\n\treturn container_of(p, struct dcss_plane, base);\n}\n\nstatic inline bool dcss_plane_fb_is_linear(const struct drm_framebuffer *fb)\n{\n\treturn ((fb->flags & DRM_MODE_FB_MODIFIERS) == 0) ||\n\t       ((fb->flags & DRM_MODE_FB_MODIFIERS) != 0 &&\n\t\tfb->modifier == DRM_FORMAT_MOD_LINEAR);\n}\n\nstatic void dcss_plane_destroy(struct drm_plane *plane)\n{\n\tstruct dcss_plane *dcss_plane = container_of(plane, struct dcss_plane,\n\t\t\t\t\t\t     base);\n\n\tdrm_plane_cleanup(plane);\n\tkfree(dcss_plane);\n}\n\nstatic bool dcss_plane_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t\t    u32 format,\n\t\t\t\t\t    u64 modifier)\n{\n\tswitch (plane->type) {\n\tcase DRM_PLANE_TYPE_PRIMARY:\n\t\tswitch (format) {\n\t\tcase DRM_FORMAT_ARGB8888:\n\t\tcase DRM_FORMAT_XRGB8888:\n\t\tcase DRM_FORMAT_ARGB2101010:\n\t\t\treturn modifier == DRM_FORMAT_MOD_LINEAR ||\n\t\t\t       modifier == DRM_FORMAT_MOD_VIVANTE_TILED ||\n\t\t\t       modifier == DRM_FORMAT_MOD_VIVANTE_SUPER_TILED;\n\t\tdefault:\n\t\t\treturn modifier == DRM_FORMAT_MOD_LINEAR;\n\t\t}\n\t\tbreak;\n\tcase DRM_PLANE_TYPE_OVERLAY:\n\t\treturn modifier == DRM_FORMAT_MOD_LINEAR;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct drm_plane_funcs dcss_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.destroy\t\t= dcss_plane_destroy,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n\t.format_mod_supported\t= dcss_plane_format_mod_supported,\n};\n\nstatic bool dcss_plane_can_rotate(const struct drm_format_info *format,\n\t\t\t\t  bool mod_present, u64 modifier,\n\t\t\t\t  unsigned int rotation)\n{\n\tbool linear_format = !mod_present || modifier == DRM_FORMAT_MOD_LINEAR;\n\tu32 supported_rotation = DRM_MODE_ROTATE_0;\n\n\tif (!format->is_yuv && linear_format)\n\t\tsupported_rotation = DRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180 |\n\t\t\t\t     DRM_MODE_REFLECT_MASK;\n\telse if (!format->is_yuv &&\n\t\t (modifier == DRM_FORMAT_MOD_VIVANTE_TILED ||\n\t\t  modifier == DRM_FORMAT_MOD_VIVANTE_SUPER_TILED))\n\t\tsupported_rotation = DRM_MODE_ROTATE_MASK |\n\t\t\t\t     DRM_MODE_REFLECT_MASK;\n\telse if (format->is_yuv && linear_format &&\n\t\t (format->format == DRM_FORMAT_NV12 ||\n\t\t  format->format == DRM_FORMAT_NV21))\n\t\tsupported_rotation = DRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180 |\n\t\t\t\t     DRM_MODE_REFLECT_MASK;\n\n\treturn !!(rotation & supported_rotation);\n}\n\nstatic bool dcss_plane_is_source_size_allowed(u16 src_w, u16 src_h, u32 pix_fmt)\n{\n\tif (src_w < 64 &&\n\t    (pix_fmt == DRM_FORMAT_NV12 || pix_fmt == DRM_FORMAT_NV21))\n\t\treturn false;\n\telse if (src_w < 32 &&\n\t\t (pix_fmt == DRM_FORMAT_UYVY || pix_fmt == DRM_FORMAT_VYUY ||\n\t\t  pix_fmt == DRM_FORMAT_YUYV || pix_fmt == DRM_FORMAT_YVYU))\n\t\treturn false;\n\n\treturn src_w >= 16 && src_h >= 8;\n}\n\nstatic int dcss_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct dcss_plane *dcss_plane = to_dcss_plane(plane);\n\tstruct dcss_dev *dcss = plane->dev->dev_private;\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tbool is_primary_plane = plane->type == DRM_PLANE_TYPE_PRIMARY;\n\tstruct drm_gem_dma_object *dma_obj;\n\tstruct drm_crtc_state *crtc_state;\n\tint hdisplay, vdisplay;\n\tint min, max;\n\tint ret;\n\n\tif (!fb || !new_plane_state->crtc)\n\t\treturn 0;\n\n\tdma_obj = drm_fb_dma_get_gem_obj(fb, 0);\n\tWARN_ON(!dma_obj);\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t\tnew_plane_state->crtc);\n\n\thdisplay = crtc_state->adjusted_mode.hdisplay;\n\tvdisplay = crtc_state->adjusted_mode.vdisplay;\n\n\tif (!dcss_plane_is_source_size_allowed(new_plane_state->src_w >> 16,\n\t\t\t\t\t       new_plane_state->src_h >> 16,\n\t\t\t\t\t       fb->format->format)) {\n\t\tDRM_DEBUG_KMS(\"Source plane size is not allowed!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdcss_scaler_get_min_max_ratios(dcss->scaler, dcss_plane->ch_num,\n\t\t\t\t       &min, &max);\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,\n\t\t\t\t\t\t  min, max, !is_primary_plane,\n\t\t\t\t\t\t  false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!new_plane_state->visible)\n\t\treturn 0;\n\n\tif (!dcss_plane_can_rotate(fb->format,\n\t\t\t\t   !!(fb->flags & DRM_MODE_FB_MODIFIERS),\n\t\t\t\t   fb->modifier,\n\t\t\t\t   new_plane_state->rotation)) {\n\t\tDRM_DEBUG_KMS(\"requested rotation is not allowed!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((new_plane_state->crtc_x < 0 || new_plane_state->crtc_y < 0 ||\n\t     new_plane_state->crtc_x + new_plane_state->crtc_w > hdisplay ||\n\t     new_plane_state->crtc_y + new_plane_state->crtc_h > vdisplay) &&\n\t    !dcss_plane_fb_is_linear(fb)) {\n\t\tDRM_DEBUG_KMS(\"requested cropping operation is not allowed!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((fb->flags & DRM_MODE_FB_MODIFIERS) &&\n\t    !plane->funcs->format_mod_supported(plane,\n\t\t\t\tfb->format->format,\n\t\t\t\tfb->modifier)) {\n\t\tDRM_DEBUG_KMS(\"Invalid modifier: %llx\", fb->modifier);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void dcss_plane_atomic_set_base(struct dcss_plane *dcss_plane)\n{\n\tstruct drm_plane *plane = &dcss_plane->base;\n\tstruct drm_plane_state *state = plane->state;\n\tstruct dcss_dev *dcss = plane->dev->dev_private;\n\tstruct drm_framebuffer *fb = state->fb;\n\tconst struct drm_format_info *format = fb->format;\n\tstruct drm_gem_dma_object *dma_obj = drm_fb_dma_get_gem_obj(fb, 0);\n\tunsigned long p1_ba = 0, p2_ba = 0;\n\n\tif (!format->is_yuv ||\n\t    format->format == DRM_FORMAT_NV12 ||\n\t    format->format == DRM_FORMAT_NV21)\n\t\tp1_ba = dma_obj->dma_addr + fb->offsets[0] +\n\t\t\tfb->pitches[0] * (state->src.y1 >> 16) +\n\t\t\tformat->char_per_block[0] * (state->src.x1 >> 16);\n\telse if (format->format == DRM_FORMAT_UYVY ||\n\t\t format->format == DRM_FORMAT_VYUY ||\n\t\t format->format == DRM_FORMAT_YUYV ||\n\t\t format->format == DRM_FORMAT_YVYU)\n\t\tp1_ba = dma_obj->dma_addr + fb->offsets[0] +\n\t\t\tfb->pitches[0] * (state->src.y1 >> 16) +\n\t\t\t2 * format->char_per_block[0] * (state->src.x1 >> 17);\n\n\tif (format->format == DRM_FORMAT_NV12 ||\n\t    format->format == DRM_FORMAT_NV21)\n\t\tp2_ba = dma_obj->dma_addr + fb->offsets[1] +\n\t\t\t(((fb->pitches[1] >> 1) * (state->src.y1 >> 17) +\n\t\t\t(state->src.x1 >> 17)) << 1);\n\n\tdcss_dpr_addr_set(dcss->dpr, dcss_plane->ch_num, p1_ba, p2_ba,\n\t\t\t  fb->pitches[0]);\n}\n\nstatic bool dcss_plane_needs_setup(struct drm_plane_state *state,\n\t\t\t\t   struct drm_plane_state *old_state)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_framebuffer *old_fb = old_state->fb;\n\n\treturn state->crtc_x != old_state->crtc_x ||\n\t       state->crtc_y != old_state->crtc_y ||\n\t       state->crtc_w != old_state->crtc_w ||\n\t       state->crtc_h != old_state->crtc_h ||\n\t       state->src_x  != old_state->src_x  ||\n\t       state->src_y  != old_state->src_y  ||\n\t       state->src_w  != old_state->src_w  ||\n\t       state->src_h  != old_state->src_h  ||\n\t       fb->format->format != old_fb->format->format ||\n\t       fb->modifier  != old_fb->modifier ||\n\t       state->rotation != old_state->rotation ||\n\t       state->scaling_filter != old_state->scaling_filter;\n}\n\nstatic void dcss_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct dcss_plane *dcss_plane = to_dcss_plane(plane);\n\tstruct dcss_dev *dcss = plane->dev->dev_private;\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct drm_crtc_state *crtc_state;\n\tbool modifiers_present;\n\tu32 src_w, src_h, dst_w, dst_h;\n\tstruct drm_rect src, dst;\n\tbool enable = true;\n\tbool is_rotation_90_or_270;\n\n\tif (!fb || !new_state->crtc || !new_state->visible)\n\t\treturn;\n\n\tcrtc_state = new_state->crtc->state;\n\tmodifiers_present = !!(fb->flags & DRM_MODE_FB_MODIFIERS);\n\n\tif (old_state->fb && !drm_atomic_crtc_needs_modeset(crtc_state) &&\n\t    !dcss_plane_needs_setup(new_state, old_state)) {\n\t\tdcss_plane_atomic_set_base(dcss_plane);\n\t\treturn;\n\t}\n\n\tsrc = plane->state->src;\n\tdst = plane->state->dst;\n\n\t \n\tsrc_w = drm_rect_width(&src) >> 16;\n\tsrc_h = drm_rect_height(&src) >> 16;\n\tdst_w = drm_rect_width(&dst);\n\tdst_h = drm_rect_height(&dst);\n\n\tif (plane->type == DRM_PLANE_TYPE_OVERLAY &&\n\t    modifiers_present && fb->modifier == DRM_FORMAT_MOD_LINEAR)\n\t\tmodifiers_present = false;\n\n\tdcss_dpr_format_set(dcss->dpr, dcss_plane->ch_num,\n\t\t\t    new_state->fb->format,\n\t\t\t    modifiers_present ? fb->modifier :\n\t\t\t\t\t\tDRM_FORMAT_MOD_LINEAR);\n\tdcss_dpr_set_res(dcss->dpr, dcss_plane->ch_num, src_w, src_h);\n\tdcss_dpr_set_rotation(dcss->dpr, dcss_plane->ch_num,\n\t\t\t      new_state->rotation);\n\n\tdcss_plane_atomic_set_base(dcss_plane);\n\n\tis_rotation_90_or_270 = new_state->rotation & (DRM_MODE_ROTATE_90 |\n\t\t\t\t\t\t   DRM_MODE_ROTATE_270);\n\n\tdcss_scaler_set_filter(dcss->scaler, dcss_plane->ch_num,\n\t\t\t       new_state->scaling_filter);\n\n\tdcss_scaler_setup(dcss->scaler, dcss_plane->ch_num,\n\t\t\t  new_state->fb->format,\n\t\t\t  is_rotation_90_or_270 ? src_h : src_w,\n\t\t\t  is_rotation_90_or_270 ? src_w : src_h,\n\t\t\t  dst_w, dst_h,\n\t\t\t  drm_mode_vrefresh(&crtc_state->mode));\n\n\tdcss_dtg_plane_pos_set(dcss->dtg, dcss_plane->ch_num,\n\t\t\t       dst.x1, dst.y1, dst_w, dst_h);\n\tdcss_dtg_plane_alpha_set(dcss->dtg, dcss_plane->ch_num,\n\t\t\t\t fb->format, new_state->alpha >> 8);\n\n\tif (!dcss_plane->ch_num && (new_state->alpha >> 8) == 0)\n\t\tenable = false;\n\n\tdcss_dpr_enable(dcss->dpr, dcss_plane->ch_num, enable);\n\tdcss_scaler_ch_enable(dcss->scaler, dcss_plane->ch_num, enable);\n\n\tif (!enable)\n\t\tdcss_dtg_plane_pos_set(dcss->dtg, dcss_plane->ch_num,\n\t\t\t\t       0, 0, 0, 0);\n\n\tdcss_dtg_ch_enable(dcss->dtg, dcss_plane->ch_num, enable);\n}\n\nstatic void dcss_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct dcss_plane *dcss_plane = to_dcss_plane(plane);\n\tstruct dcss_dev *dcss = plane->dev->dev_private;\n\n\tdcss_dpr_enable(dcss->dpr, dcss_plane->ch_num, false);\n\tdcss_scaler_ch_enable(dcss->scaler, dcss_plane->ch_num, false);\n\tdcss_dtg_plane_pos_set(dcss->dtg, dcss_plane->ch_num, 0, 0, 0, 0);\n\tdcss_dtg_ch_enable(dcss->dtg, dcss_plane->ch_num, false);\n}\n\nstatic const struct drm_plane_helper_funcs dcss_plane_helper_funcs = {\n\t.atomic_check = dcss_plane_atomic_check,\n\t.atomic_update = dcss_plane_atomic_update,\n\t.atomic_disable = dcss_plane_atomic_disable,\n};\n\nstruct dcss_plane *dcss_plane_init(struct drm_device *drm,\n\t\t\t\t   unsigned int possible_crtcs,\n\t\t\t\t   enum drm_plane_type type,\n\t\t\t\t   unsigned int zpos)\n{\n\tstruct dcss_plane *dcss_plane;\n\tconst u64 *format_modifiers = dcss_video_format_modifiers;\n\tint ret;\n\n\tif (zpos > 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdcss_plane = kzalloc(sizeof(*dcss_plane), GFP_KERNEL);\n\tif (!dcss_plane) {\n\t\tDRM_ERROR(\"failed to allocate plane\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (type == DRM_PLANE_TYPE_PRIMARY)\n\t\tformat_modifiers = dcss_graphics_format_modifiers;\n\n\tret = drm_universal_plane_init(drm, &dcss_plane->base, possible_crtcs,\n\t\t\t\t       &dcss_plane_funcs, dcss_common_formats,\n\t\t\t\t       ARRAY_SIZE(dcss_common_formats),\n\t\t\t\t       format_modifiers, type, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to initialize plane\\n\");\n\t\tkfree(dcss_plane);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrm_plane_helper_add(&dcss_plane->base, &dcss_plane_helper_funcs);\n\n\tret = drm_plane_create_zpos_immutable_property(&dcss_plane->base, zpos);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdrm_plane_create_scaling_filter_property(&dcss_plane->base,\n\t\t\t\t\tBIT(DRM_SCALING_FILTER_DEFAULT) |\n\t\t\t\t\tBIT(DRM_SCALING_FILTER_NEAREST_NEIGHBOR));\n\n\tdrm_plane_create_rotation_property(&dcss_plane->base,\n\t\t\t\t\t   DRM_MODE_ROTATE_0,\n\t\t\t\t\t   DRM_MODE_ROTATE_0   |\n\t\t\t\t\t   DRM_MODE_ROTATE_90  |\n\t\t\t\t\t   DRM_MODE_ROTATE_180 |\n\t\t\t\t\t   DRM_MODE_ROTATE_270 |\n\t\t\t\t\t   DRM_MODE_REFLECT_X  |\n\t\t\t\t\t   DRM_MODE_REFLECT_Y);\n\n\tdcss_plane->ch_num = zpos;\n\n\treturn dcss_plane;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}