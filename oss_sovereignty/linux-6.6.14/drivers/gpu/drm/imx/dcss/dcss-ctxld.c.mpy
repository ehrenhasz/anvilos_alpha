{
  "module_name": "dcss-ctxld.c",
  "hash_id": "25a3de074b63ab7683c7e68145efef70da623e3e5191c9d0378cb9c127b0a77e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/dcss/dcss-ctxld.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"dcss-dev.h\"\n\n#define DCSS_CTXLD_CONTROL_STATUS\t0x0\n#define   CTXLD_ENABLE\t\t\tBIT(0)\n#define   ARB_SEL\t\t\tBIT(1)\n#define   RD_ERR_EN\t\t\tBIT(2)\n#define   DB_COMP_EN\t\t\tBIT(3)\n#define   SB_HP_COMP_EN\t\t\tBIT(4)\n#define   SB_LP_COMP_EN\t\t\tBIT(5)\n#define   DB_PEND_SB_REC_EN\t\tBIT(6)\n#define   SB_PEND_DISP_ACTIVE_EN\tBIT(7)\n#define   AHB_ERR_EN\t\t\tBIT(8)\n#define   RD_ERR\t\t\tBIT(16)\n#define   DB_COMP\t\t\tBIT(17)\n#define   SB_HP_COMP\t\t\tBIT(18)\n#define   SB_LP_COMP\t\t\tBIT(19)\n#define   DB_PEND_SB_REC\t\tBIT(20)\n#define   SB_PEND_DISP_ACTIVE\t\tBIT(21)\n#define   AHB_ERR\t\t\tBIT(22)\n#define DCSS_CTXLD_DB_BASE_ADDR\t\t0x10\n#define DCSS_CTXLD_DB_COUNT\t\t0x14\n#define DCSS_CTXLD_SB_BASE_ADDR\t\t0x18\n#define DCSS_CTXLD_SB_COUNT\t\t0x1C\n#define   SB_HP_COUNT_POS\t\t0\n#define   SB_HP_COUNT_MASK\t\t0xffff\n#define   SB_LP_COUNT_POS\t\t16\n#define   SB_LP_COUNT_MASK\t\t0xffff0000\n#define DCSS_AHB_ERR_ADDR\t\t0x20\n\n#define CTXLD_IRQ_COMPLETION\t\t(DB_COMP | SB_HP_COMP | SB_LP_COMP)\n#define CTXLD_IRQ_ERROR\t\t\t(RD_ERR | DB_PEND_SB_REC | AHB_ERR)\n\n \n#define CTXLD_DB_CTX_ENTRIES\t\t1024\t \n#define CTXLD_SB_LP_CTX_ENTRIES\t\t10240\t \n#define CTXLD_SB_HP_CTX_ENTRIES\t\t20000\t \n#define CTXLD_SB_CTX_ENTRIES\t\t(CTXLD_SB_LP_CTX_ENTRIES + \\\n\t\t\t\t\t CTXLD_SB_HP_CTX_ENTRIES)\n\n \nstatic u16 dcss_ctxld_ctx_size[3] = {\n\tCTXLD_DB_CTX_ENTRIES,\n\tCTXLD_SB_HP_CTX_ENTRIES,\n\tCTXLD_SB_LP_CTX_ENTRIES\n};\n\n \nstruct dcss_ctxld_item {\n\tu32 val;\n\tu32 ofs;\n};\n\n#define CTX_ITEM_SIZE\t\t\tsizeof(struct dcss_ctxld_item)\n\nstruct dcss_ctxld {\n\tstruct device *dev;\n\tvoid __iomem *ctxld_reg;\n\tint irq;\n\tbool irq_en;\n\n\tstruct dcss_ctxld_item *db[2];\n\tstruct dcss_ctxld_item *sb_hp[2];\n\tstruct dcss_ctxld_item *sb_lp[2];\n\n\tdma_addr_t db_paddr[2];\n\tdma_addr_t sb_paddr[2];\n\n\tu16 ctx_size[2][3];  \n\tu8 current_ctx;\n\n\tbool in_use;\n\tbool armed;\n\n\tspinlock_t lock;  \n};\n\nstatic irqreturn_t dcss_ctxld_irq_handler(int irq, void *data)\n{\n\tstruct dcss_ctxld *ctxld = data;\n\tstruct dcss_dev *dcss = dcss_drv_dev_to_dcss(ctxld->dev);\n\tu32 irq_status;\n\n\tirq_status = dcss_readl(ctxld->ctxld_reg + DCSS_CTXLD_CONTROL_STATUS);\n\n\tif (irq_status & CTXLD_IRQ_COMPLETION &&\n\t    !(irq_status & CTXLD_ENABLE) && ctxld->in_use) {\n\t\tctxld->in_use = false;\n\n\t\tif (dcss && dcss->disable_callback)\n\t\t\tdcss->disable_callback(dcss);\n\t} else if (irq_status & CTXLD_IRQ_ERROR) {\n\t\t \n\t\tdev_err(ctxld->dev, \"ctxld: error encountered: %08x\\n\",\n\t\t\tirq_status);\n\t\tdev_err(ctxld->dev, \"ctxld: db=%d, sb_hp=%d, sb_lp=%d\\n\",\n\t\t\tctxld->ctx_size[ctxld->current_ctx ^ 1][CTX_DB],\n\t\t\tctxld->ctx_size[ctxld->current_ctx ^ 1][CTX_SB_HP],\n\t\t\tctxld->ctx_size[ctxld->current_ctx ^ 1][CTX_SB_LP]);\n\t}\n\n\tdcss_clr(irq_status & (CTXLD_IRQ_ERROR | CTXLD_IRQ_COMPLETION),\n\t\t ctxld->ctxld_reg + DCSS_CTXLD_CONTROL_STATUS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dcss_ctxld_irq_config(struct dcss_ctxld *ctxld,\n\t\t\t\t struct platform_device *pdev)\n{\n\tint ret;\n\n\tctxld->irq = platform_get_irq_byname(pdev, \"ctxld\");\n\tif (ctxld->irq < 0)\n\t\treturn ctxld->irq;\n\n\tret = request_irq(ctxld->irq, dcss_ctxld_irq_handler,\n\t\t\t  0, \"dcss_ctxld\", ctxld);\n\tif (ret) {\n\t\tdev_err(ctxld->dev, \"ctxld: irq request failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tctxld->irq_en = true;\n\n\treturn 0;\n}\n\nstatic void dcss_ctxld_hw_cfg(struct dcss_ctxld *ctxld)\n{\n\tdcss_writel(RD_ERR_EN | SB_HP_COMP_EN |\n\t\t    DB_PEND_SB_REC_EN | AHB_ERR_EN | RD_ERR | AHB_ERR,\n\t\t    ctxld->ctxld_reg + DCSS_CTXLD_CONTROL_STATUS);\n}\n\nstatic void dcss_ctxld_free_ctx(struct dcss_ctxld *ctxld)\n{\n\tstruct dcss_ctxld_item *ctx;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (ctxld->db[i]) {\n\t\t\tdma_free_coherent(ctxld->dev,\n\t\t\t\t\t  CTXLD_DB_CTX_ENTRIES * sizeof(*ctx),\n\t\t\t\t\t  ctxld->db[i], ctxld->db_paddr[i]);\n\t\t\tctxld->db[i] = NULL;\n\t\t\tctxld->db_paddr[i] = 0;\n\t\t}\n\n\t\tif (ctxld->sb_hp[i]) {\n\t\t\tdma_free_coherent(ctxld->dev,\n\t\t\t\t\t  CTXLD_SB_CTX_ENTRIES * sizeof(*ctx),\n\t\t\t\t\t  ctxld->sb_hp[i], ctxld->sb_paddr[i]);\n\t\t\tctxld->sb_hp[i] = NULL;\n\t\t\tctxld->sb_paddr[i] = 0;\n\t\t}\n\t}\n}\n\nstatic int dcss_ctxld_alloc_ctx(struct dcss_ctxld *ctxld)\n{\n\tstruct dcss_ctxld_item *ctx;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tctx = dma_alloc_coherent(ctxld->dev,\n\t\t\t\t\t CTXLD_DB_CTX_ENTRIES * sizeof(*ctx),\n\t\t\t\t\t &ctxld->db_paddr[i], GFP_KERNEL);\n\t\tif (!ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tctxld->db[i] = ctx;\n\n\t\tctx = dma_alloc_coherent(ctxld->dev,\n\t\t\t\t\t CTXLD_SB_CTX_ENTRIES * sizeof(*ctx),\n\t\t\t\t\t &ctxld->sb_paddr[i], GFP_KERNEL);\n\t\tif (!ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tctxld->sb_hp[i] = ctx;\n\t\tctxld->sb_lp[i] = ctx + CTXLD_SB_HP_CTX_ENTRIES;\n\t}\n\n\treturn 0;\n}\n\nint dcss_ctxld_init(struct dcss_dev *dcss, unsigned long ctxld_base)\n{\n\tstruct dcss_ctxld *ctxld;\n\tint ret;\n\n\tctxld = kzalloc(sizeof(*ctxld), GFP_KERNEL);\n\tif (!ctxld)\n\t\treturn -ENOMEM;\n\n\tdcss->ctxld = ctxld;\n\tctxld->dev = dcss->dev;\n\n\tspin_lock_init(&ctxld->lock);\n\n\tret = dcss_ctxld_alloc_ctx(ctxld);\n\tif (ret) {\n\t\tdev_err(dcss->dev, \"ctxld: cannot allocate context memory.\\n\");\n\t\tgoto err;\n\t}\n\n\tctxld->ctxld_reg = ioremap(ctxld_base, SZ_4K);\n\tif (!ctxld->ctxld_reg) {\n\t\tdev_err(dcss->dev, \"ctxld: unable to remap ctxld base\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = dcss_ctxld_irq_config(ctxld, to_platform_device(dcss->dev));\n\tif (ret)\n\t\tgoto err_irq;\n\n\tdcss_ctxld_hw_cfg(ctxld);\n\n\treturn 0;\n\nerr_irq:\n\tiounmap(ctxld->ctxld_reg);\n\nerr:\n\tdcss_ctxld_free_ctx(ctxld);\n\tkfree(ctxld);\n\n\treturn ret;\n}\n\nvoid dcss_ctxld_exit(struct dcss_ctxld *ctxld)\n{\n\tfree_irq(ctxld->irq, ctxld);\n\n\tif (ctxld->ctxld_reg)\n\t\tiounmap(ctxld->ctxld_reg);\n\n\tdcss_ctxld_free_ctx(ctxld);\n\tkfree(ctxld);\n}\n\nstatic int dcss_ctxld_enable_locked(struct dcss_ctxld *ctxld)\n{\n\tint curr_ctx = ctxld->current_ctx;\n\tu32 db_base, sb_base, sb_count;\n\tu32 sb_hp_cnt, sb_lp_cnt, db_cnt;\n\tstruct dcss_dev *dcss = dcss_drv_dev_to_dcss(ctxld->dev);\n\n\tif (!dcss)\n\t\treturn 0;\n\n\tdcss_dpr_write_sysctrl(dcss->dpr);\n\n\tdcss_scaler_write_sclctrl(dcss->scaler);\n\n\tsb_hp_cnt = ctxld->ctx_size[curr_ctx][CTX_SB_HP];\n\tsb_lp_cnt = ctxld->ctx_size[curr_ctx][CTX_SB_LP];\n\tdb_cnt = ctxld->ctx_size[curr_ctx][CTX_DB];\n\n\t \n\tif (sb_lp_cnt &&\n\t    ctxld->sb_lp[curr_ctx] != ctxld->sb_hp[curr_ctx] + sb_hp_cnt) {\n\t\tstruct dcss_ctxld_item *sb_lp_adjusted;\n\n\t\tsb_lp_adjusted = ctxld->sb_hp[curr_ctx] + sb_hp_cnt;\n\n\t\tmemcpy(sb_lp_adjusted, ctxld->sb_lp[curr_ctx],\n\t\t       sb_lp_cnt * CTX_ITEM_SIZE);\n\t}\n\n\tdb_base = db_cnt ? ctxld->db_paddr[curr_ctx] : 0;\n\n\tdcss_writel(db_base, ctxld->ctxld_reg + DCSS_CTXLD_DB_BASE_ADDR);\n\tdcss_writel(db_cnt, ctxld->ctxld_reg + DCSS_CTXLD_DB_COUNT);\n\n\tif (sb_hp_cnt)\n\t\tsb_count = ((sb_hp_cnt << SB_HP_COUNT_POS) & SB_HP_COUNT_MASK) |\n\t\t\t   ((sb_lp_cnt << SB_LP_COUNT_POS) & SB_LP_COUNT_MASK);\n\telse\n\t\tsb_count = (sb_lp_cnt << SB_HP_COUNT_POS) & SB_HP_COUNT_MASK;\n\n\tsb_base = sb_count ? ctxld->sb_paddr[curr_ctx] : 0;\n\n\tdcss_writel(sb_base, ctxld->ctxld_reg + DCSS_CTXLD_SB_BASE_ADDR);\n\tdcss_writel(sb_count, ctxld->ctxld_reg + DCSS_CTXLD_SB_COUNT);\n\n\t \n\tdcss_set(CTXLD_ENABLE, ctxld->ctxld_reg + DCSS_CTXLD_CONTROL_STATUS);\n\n\tctxld->in_use = true;\n\n\t \n\tctxld->current_ctx ^= 1;\n\n\tctxld->ctx_size[ctxld->current_ctx][CTX_DB] = 0;\n\tctxld->ctx_size[ctxld->current_ctx][CTX_SB_HP] = 0;\n\tctxld->ctx_size[ctxld->current_ctx][CTX_SB_LP] = 0;\n\n\treturn 0;\n}\n\nint dcss_ctxld_enable(struct dcss_ctxld *ctxld)\n{\n\tspin_lock_irq(&ctxld->lock);\n\tctxld->armed = true;\n\tspin_unlock_irq(&ctxld->lock);\n\n\treturn 0;\n}\n\nvoid dcss_ctxld_kick(struct dcss_ctxld *ctxld)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctxld->lock, flags);\n\tif (ctxld->armed && !ctxld->in_use) {\n\t\tctxld->armed = false;\n\t\tdcss_ctxld_enable_locked(ctxld);\n\t}\n\tspin_unlock_irqrestore(&ctxld->lock, flags);\n}\n\nvoid dcss_ctxld_write_irqsafe(struct dcss_ctxld *ctxld, u32 ctx_id, u32 val,\n\t\t\t      u32 reg_ofs)\n{\n\tint curr_ctx = ctxld->current_ctx;\n\tstruct dcss_ctxld_item *ctx[] = {\n\t\t[CTX_DB] = ctxld->db[curr_ctx],\n\t\t[CTX_SB_HP] = ctxld->sb_hp[curr_ctx],\n\t\t[CTX_SB_LP] = ctxld->sb_lp[curr_ctx]\n\t};\n\tint item_idx = ctxld->ctx_size[curr_ctx][ctx_id];\n\n\tif (item_idx + 1 > dcss_ctxld_ctx_size[ctx_id]) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tctx[ctx_id][item_idx].val = val;\n\tctx[ctx_id][item_idx].ofs = reg_ofs;\n\tctxld->ctx_size[curr_ctx][ctx_id] += 1;\n}\n\nvoid dcss_ctxld_write(struct dcss_ctxld *ctxld, u32 ctx_id,\n\t\t      u32 val, u32 reg_ofs)\n{\n\tspin_lock_irq(&ctxld->lock);\n\tdcss_ctxld_write_irqsafe(ctxld, ctx_id, val, reg_ofs);\n\tspin_unlock_irq(&ctxld->lock);\n}\n\nbool dcss_ctxld_is_flushed(struct dcss_ctxld *ctxld)\n{\n\treturn ctxld->ctx_size[ctxld->current_ctx][CTX_DB] == 0 &&\n\t\tctxld->ctx_size[ctxld->current_ctx][CTX_SB_HP] == 0 &&\n\t\tctxld->ctx_size[ctxld->current_ctx][CTX_SB_LP] == 0;\n}\n\nint dcss_ctxld_resume(struct dcss_ctxld *ctxld)\n{\n\tdcss_ctxld_hw_cfg(ctxld);\n\n\tif (!ctxld->irq_en) {\n\t\tenable_irq(ctxld->irq);\n\t\tctxld->irq_en = true;\n\t}\n\n\treturn 0;\n}\n\nint dcss_ctxld_suspend(struct dcss_ctxld *ctxld)\n{\n\tint ret = 0;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(500);\n\n\tif (!dcss_ctxld_is_flushed(ctxld)) {\n\t\tdcss_ctxld_kick(ctxld);\n\n\t\twhile (!time_after(jiffies, timeout) && ctxld->in_use)\n\t\t\tmsleep(20);\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\tspin_lock_irq(&ctxld->lock);\n\n\tif (ctxld->irq_en) {\n\t\tdisable_irq_nosync(ctxld->irq);\n\t\tctxld->irq_en = false;\n\t}\n\n\t \n\tctxld->current_ctx = 0;\n\tctxld->ctx_size[0][CTX_DB] = 0;\n\tctxld->ctx_size[0][CTX_SB_HP] = 0;\n\tctxld->ctx_size[0][CTX_SB_LP] = 0;\n\n\tspin_unlock_irq(&ctxld->lock);\n\n\treturn ret;\n}\n\nvoid dcss_ctxld_assert_locked(struct dcss_ctxld *ctxld)\n{\n\tlockdep_assert_held(&ctxld->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}