{
  "module_name": "dcss-kms.c",
  "hash_id": "c48a5a829cd6d44b185a5d397850ad0d58cc7b5a7c1c9c95a24ca4d82ab45ee5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/dcss/dcss-kms.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"dcss-dev.h\"\n#include \"dcss-kms.h\"\n\nDEFINE_DRM_GEM_DMA_FOPS(dcss_cma_fops);\n\nstatic const struct drm_mode_config_funcs dcss_drm_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic const struct drm_driver dcss_kms_driver = {\n\t.driver_features\t= DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\tDRM_GEM_DMA_DRIVER_OPS,\n\t.fops\t\t\t= &dcss_cma_fops,\n\t.name\t\t\t= \"imx-dcss\",\n\t.desc\t\t\t= \"i.MX8MQ Display Subsystem\",\n\t.date\t\t\t= \"20190917\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n\t.patchlevel\t\t= 0,\n};\n\nstatic const struct drm_mode_config_helper_funcs dcss_mode_config_helpers = {\n\t.atomic_commit_tail = drm_atomic_helper_commit_tail_rpm,\n};\n\nstatic void dcss_kms_mode_config_init(struct dcss_kms_dev *kms)\n{\n\tstruct drm_mode_config *config = &kms->base.mode_config;\n\n\tdrm_mode_config_init(&kms->base);\n\n\tconfig->min_width = 1;\n\tconfig->min_height = 1;\n\tconfig->max_width = 4096;\n\tconfig->max_height = 4096;\n\tconfig->normalize_zpos = true;\n\n\tconfig->funcs = &dcss_drm_mode_config_funcs;\n\tconfig->helper_private = &dcss_mode_config_helpers;\n}\n\nstatic const struct drm_encoder_funcs dcss_kms_simple_encoder_funcs = {\n\t.destroy = drm_encoder_cleanup,\n};\n\nstatic int dcss_kms_bridge_connector_init(struct dcss_kms_dev *kms)\n{\n\tstruct drm_device *ddev = &kms->base;\n\tstruct drm_encoder *encoder = &kms->encoder;\n\tstruct drm_crtc *crtc = (struct drm_crtc *)&kms->crtc;\n\tstruct drm_panel *panel;\n\tstruct drm_bridge *bridge;\n\tint ret;\n\n\tret = drm_of_find_panel_or_bridge(ddev->dev->of_node, 0, 0,\n\t\t\t\t\t  &panel, &bridge);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!bridge) {\n\t\tdev_err(ddev->dev, \"No bridge found %d.\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\tret = drm_encoder_init(&kms->base, encoder,\n\t\t\t       &dcss_kms_simple_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_NONE, NULL);\n\tif (ret) {\n\t\tdev_err(ddev->dev, \"Failed initializing encoder %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = drm_bridge_attach(encoder, bridge, NULL,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tkms->connector = drm_bridge_connector_init(ddev, encoder);\n\tif (IS_ERR(kms->connector)) {\n\t\tdev_err(ddev->dev, \"Unable to create bridge connector.\\n\");\n\t\treturn PTR_ERR(kms->connector);\n\t}\n\n\tdrm_connector_attach_encoder(kms->connector, encoder);\n\n\treturn 0;\n}\n\nstruct dcss_kms_dev *dcss_kms_attach(struct dcss_dev *dcss)\n{\n\tstruct dcss_kms_dev *kms;\n\tstruct drm_device *drm;\n\tstruct dcss_crtc *crtc;\n\tint ret;\n\n\tkms = devm_drm_dev_alloc(dcss->dev, &dcss_kms_driver,\n\t\t\t\t struct dcss_kms_dev, base);\n\tif (IS_ERR(kms))\n\t\treturn kms;\n\n\tdrm = &kms->base;\n\tcrtc = &kms->crtc;\n\n\tdrm->dev_private = dcss;\n\n\tdcss_kms_mode_config_init(kms);\n\n\tret = drm_vblank_init(drm, 1);\n\tif (ret)\n\t\tgoto cleanup_mode_config;\n\n\tret = dcss_kms_bridge_connector_init(kms);\n\tif (ret)\n\t\tgoto cleanup_mode_config;\n\n\tret = dcss_crtc_init(crtc, drm);\n\tif (ret)\n\t\tgoto cleanup_mode_config;\n\n\tdrm_mode_config_reset(drm);\n\n\tdrm_kms_helper_poll_init(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\tgoto cleanup_crtc;\n\n\tdrm_fbdev_dma_setup(drm, 32);\n\n\treturn kms;\n\ncleanup_crtc:\n\tdrm_kms_helper_poll_fini(drm);\n\tdcss_crtc_deinit(crtc, drm);\n\ncleanup_mode_config:\n\tdrm_mode_config_cleanup(drm);\n\tdrm->dev_private = NULL;\n\n\treturn ERR_PTR(ret);\n}\n\nvoid dcss_kms_detach(struct dcss_kms_dev *kms)\n{\n\tstruct drm_device *drm = &kms->base;\n\n\tdrm_dev_unregister(drm);\n\tdrm_kms_helper_poll_fini(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tdrm_crtc_vblank_off(&kms->crtc.base);\n\tdrm_mode_config_cleanup(drm);\n\tdcss_crtc_deinit(&kms->crtc, drm);\n\tdrm->dev_private = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}