{
  "module_name": "dcss-dpr.c",
  "hash_id": "410bfa18d53699c8ab83c3f48ae06e975bc0db2ea584b8060af9f557f1a7c470",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/dcss/dcss-dpr.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/slab.h>\n\n#include \"dcss-dev.h\"\n\n#define DCSS_DPR_SYSTEM_CTRL0\t\t\t0x000\n#define   RUN_EN\t\t\t\tBIT(0)\n#define   SOFT_RESET\t\t\t\tBIT(1)\n#define   REPEAT_EN\t\t\t\tBIT(2)\n#define   SHADOW_LOAD_EN\t\t\tBIT(3)\n#define   SW_SHADOW_LOAD_SEL\t\t\tBIT(4)\n#define   BCMD2AXI_MSTR_ID_CTRL\t\t\tBIT(16)\n#define DCSS_DPR_IRQ_MASK\t\t\t0x020\n#define DCSS_DPR_IRQ_MASK_STATUS\t\t0x030\n#define DCSS_DPR_IRQ_NONMASK_STATUS\t\t0x040\n#define   IRQ_DPR_CTRL_DONE\t\t\tBIT(0)\n#define   IRQ_DPR_RUN\t\t\t\tBIT(1)\n#define   IRQ_DPR_SHADOW_LOADED\t\t\tBIT(2)\n#define   IRQ_AXI_READ_ERR\t\t\tBIT(3)\n#define   DPR2RTR_YRGB_FIFO_OVFL\t\tBIT(4)\n#define   DPR2RTR_UV_FIFO_OVFL\t\t\tBIT(5)\n#define   DPR2RTR_FIFO_LD_BUF_RDY_YRGB_ERR\tBIT(6)\n#define   DPR2RTR_FIFO_LD_BUF_RDY_UV_ERR\tBIT(7)\n#define DCSS_DPR_MODE_CTRL0\t\t\t0x050\n#define   RTR_3BUF_EN\t\t\t\tBIT(0)\n#define   RTR_4LINE_BUF_EN\t\t\tBIT(1)\n#define   TILE_TYPE_POS\t\t\t\t2\n#define   TILE_TYPE_MASK\t\t\tGENMASK(4, 2)\n#define   YUV_EN\t\t\t\tBIT(6)\n#define   COMP_2PLANE_EN\t\t\tBIT(7)\n#define   PIX_SIZE_POS\t\t\t\t8\n#define   PIX_SIZE_MASK\t\t\t\tGENMASK(9, 8)\n#define   PIX_LUMA_UV_SWAP\t\t\tBIT(10)\n#define   PIX_UV_SWAP\t\t\t\tBIT(11)\n#define   B_COMP_SEL_POS\t\t\t12\n#define   B_COMP_SEL_MASK\t\t\tGENMASK(13, 12)\n#define   G_COMP_SEL_POS\t\t\t14\n#define   G_COMP_SEL_MASK\t\t\tGENMASK(15, 14)\n#define   R_COMP_SEL_POS\t\t\t16\n#define   R_COMP_SEL_MASK\t\t\tGENMASK(17, 16)\n#define   A_COMP_SEL_POS\t\t\t18\n#define   A_COMP_SEL_MASK\t\t\tGENMASK(19, 18)\n#define DCSS_DPR_FRAME_CTRL0\t\t\t0x070\n#define   HFLIP_EN\t\t\t\tBIT(0)\n#define   VFLIP_EN\t\t\t\tBIT(1)\n#define   ROT_ENC_POS\t\t\t\t2\n#define   ROT_ENC_MASK\t\t\t\tGENMASK(3, 2)\n#define   ROT_FLIP_ORDER_EN\t\t\tBIT(4)\n#define   PITCH_POS\t\t\t\t16\n#define   PITCH_MASK\t\t\t\tGENMASK(31, 16)\n#define DCSS_DPR_FRAME_1P_CTRL0\t\t\t0x090\n#define DCSS_DPR_FRAME_1P_PIX_X_CTRL\t\t0x0A0\n#define DCSS_DPR_FRAME_1P_PIX_Y_CTRL\t\t0x0B0\n#define DCSS_DPR_FRAME_1P_BASE_ADDR\t\t0x0C0\n#define DCSS_DPR_FRAME_2P_CTRL0\t\t\t0x0E0\n#define DCSS_DPR_FRAME_2P_PIX_X_CTRL\t\t0x0F0\n#define DCSS_DPR_FRAME_2P_PIX_Y_CTRL\t\t0x100\n#define DCSS_DPR_FRAME_2P_BASE_ADDR\t\t0x110\n#define DCSS_DPR_STATUS_CTRL0\t\t\t0x130\n#define   STATUS_MUX_SEL_MASK\t\t\tGENMASK(2, 0)\n#define   STATUS_SRC_SEL_POS\t\t\t16\n#define   STATUS_SRC_SEL_MASK\t\t\tGENMASK(18, 16)\n#define DCSS_DPR_STATUS_CTRL1\t\t\t0x140\n#define DCSS_DPR_RTRAM_CTRL0\t\t\t0x200\n#define   NUM_ROWS_ACTIVE\t\t\tBIT(0)\n#define   THRES_HIGH_POS\t\t\t1\n#define   THRES_HIGH_MASK\t\t\tGENMASK(3, 1)\n#define   THRES_LOW_POS\t\t\t\t4\n#define   THRES_LOW_MASK\t\t\tGENMASK(6, 4)\n#define   ABORT_SEL\t\t\t\tBIT(7)\n\nenum dcss_tile_type {\n\tTILE_LINEAR = 0,\n\tTILE_GPU_STANDARD,\n\tTILE_GPU_SUPER,\n\tTILE_VPU_YUV420,\n\tTILE_VPU_VP9,\n};\n\nenum dcss_pix_size {\n\tPIX_SIZE_8,\n\tPIX_SIZE_16,\n\tPIX_SIZE_32,\n};\n\nstruct dcss_dpr_ch {\n\tstruct dcss_dpr *dpr;\n\tvoid __iomem *base_reg;\n\tu32 base_ofs;\n\n\tstruct drm_format_info format;\n\tenum dcss_pix_size pix_size;\n\tenum dcss_tile_type tile;\n\tbool rtram_4line_en;\n\tbool rtram_3buf_en;\n\n\tu32 frame_ctrl;\n\tu32 mode_ctrl;\n\tu32 sys_ctrl;\n\tu32 rtram_ctrl;\n\n\tbool sys_ctrl_chgd;\n\n\tint ch_num;\n\tint irq;\n};\n\nstruct dcss_dpr {\n\tstruct device *dev;\n\tstruct dcss_ctxld *ctxld;\n\tu32  ctx_id;\n\n\tstruct dcss_dpr_ch ch[3];\n};\n\nstatic void dcss_dpr_write(struct dcss_dpr_ch *ch, u32 val, u32 ofs)\n{\n\tstruct dcss_dpr *dpr = ch->dpr;\n\n\tdcss_ctxld_write(dpr->ctxld, dpr->ctx_id, val, ch->base_ofs + ofs);\n}\n\nstatic int dcss_dpr_ch_init_all(struct dcss_dpr *dpr, unsigned long dpr_base)\n{\n\tstruct dcss_dpr_ch *ch;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tch = &dpr->ch[i];\n\n\t\tch->base_ofs = dpr_base + i * 0x1000;\n\n\t\tch->base_reg = ioremap(ch->base_ofs, SZ_4K);\n\t\tif (!ch->base_reg) {\n\t\t\tdev_err(dpr->dev, \"dpr: unable to remap ch %d base\\n\",\n\t\t\t\ti);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tch->dpr = dpr;\n\t\tch->ch_num = i;\n\n\t\tdcss_writel(0xff, ch->base_reg + DCSS_DPR_IRQ_MASK);\n\t}\n\n\treturn 0;\n}\n\nint dcss_dpr_init(struct dcss_dev *dcss, unsigned long dpr_base)\n{\n\tstruct dcss_dpr *dpr;\n\n\tdpr = kzalloc(sizeof(*dpr), GFP_KERNEL);\n\tif (!dpr)\n\t\treturn -ENOMEM;\n\n\tdcss->dpr = dpr;\n\tdpr->dev = dcss->dev;\n\tdpr->ctxld = dcss->ctxld;\n\tdpr->ctx_id = CTX_SB_HP;\n\n\tif (dcss_dpr_ch_init_all(dpr, dpr_base)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (dpr->ch[i].base_reg)\n\t\t\t\tiounmap(dpr->ch[i].base_reg);\n\t\t}\n\n\t\tkfree(dpr);\n\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid dcss_dpr_exit(struct dcss_dpr *dpr)\n{\n\tint ch_no;\n\n\t \n\tfor (ch_no = 0; ch_no < 3; ch_no++) {\n\t\tstruct dcss_dpr_ch *ch = &dpr->ch[ch_no];\n\n\t\tdcss_writel(0, ch->base_reg + DCSS_DPR_SYSTEM_CTRL0);\n\n\t\tif (ch->base_reg)\n\t\t\tiounmap(ch->base_reg);\n\t}\n\n\tkfree(dpr);\n}\n\nstatic u32 dcss_dpr_x_pix_wide_adjust(struct dcss_dpr_ch *ch, u32 pix_wide,\n\t\t\t\t      u32 pix_format)\n{\n\tu8 pix_in_64byte_map[3][5] = {\n\t\t \n\t\t{   64,       8,       8,          8,     16},  \n\t\t{   32,       8,       8,          8,      8},  \n\t\t{   16,       4,       4,          8,      8},  \n\t};\n\tu32 offset;\n\tu32 div_64byte_mod, pix_in_64byte;\n\n\tpix_in_64byte = pix_in_64byte_map[ch->pix_size][ch->tile];\n\n\tdiv_64byte_mod = pix_wide % pix_in_64byte;\n\toffset = (div_64byte_mod == 0) ? 0 : (pix_in_64byte - div_64byte_mod);\n\n\treturn pix_wide + offset;\n}\n\nstatic u32 dcss_dpr_y_pix_high_adjust(struct dcss_dpr_ch *ch, u32 pix_high,\n\t\t\t\t      u32 pix_format)\n{\n\tu8 num_rows_buf = ch->rtram_4line_en ? 4 : 8;\n\tu32 offset, pix_y_mod;\n\n\tpix_y_mod = pix_high % num_rows_buf;\n\toffset = pix_y_mod ? (num_rows_buf - pix_y_mod) : 0;\n\n\treturn pix_high + offset;\n}\n\nvoid dcss_dpr_set_res(struct dcss_dpr *dpr, int ch_num, u32 xres, u32 yres)\n{\n\tstruct dcss_dpr_ch *ch = &dpr->ch[ch_num];\n\tu32 pix_format = ch->format.format;\n\tu32 gap = DCSS_DPR_FRAME_2P_BASE_ADDR - DCSS_DPR_FRAME_1P_BASE_ADDR;\n\tint plane, max_planes = 1;\n\tu32 pix_x_wide, pix_y_high;\n\n\tif (pix_format == DRM_FORMAT_NV12 ||\n\t    pix_format == DRM_FORMAT_NV21)\n\t\tmax_planes = 2;\n\n\tfor (plane = 0; plane < max_planes; plane++) {\n\t\tyres = plane == 1 ? yres >> 1 : yres;\n\n\t\tpix_x_wide = dcss_dpr_x_pix_wide_adjust(ch, xres, pix_format);\n\t\tpix_y_high = dcss_dpr_y_pix_high_adjust(ch, yres, pix_format);\n\n\t\tdcss_dpr_write(ch, pix_x_wide,\n\t\t\t       DCSS_DPR_FRAME_1P_PIX_X_CTRL + plane * gap);\n\t\tdcss_dpr_write(ch, pix_y_high,\n\t\t\t       DCSS_DPR_FRAME_1P_PIX_Y_CTRL + plane * gap);\n\n\t\tdcss_dpr_write(ch, 2, DCSS_DPR_FRAME_1P_CTRL0 + plane * gap);\n\t}\n}\n\nvoid dcss_dpr_addr_set(struct dcss_dpr *dpr, int ch_num, u32 luma_base_addr,\n\t\t       u32 chroma_base_addr, u16 pitch)\n{\n\tstruct dcss_dpr_ch *ch = &dpr->ch[ch_num];\n\n\tdcss_dpr_write(ch, luma_base_addr, DCSS_DPR_FRAME_1P_BASE_ADDR);\n\n\tdcss_dpr_write(ch, chroma_base_addr, DCSS_DPR_FRAME_2P_BASE_ADDR);\n\n\tch->frame_ctrl &= ~PITCH_MASK;\n\tch->frame_ctrl |= (((u32)pitch << PITCH_POS) & PITCH_MASK);\n}\n\nstatic void dcss_dpr_argb_comp_sel(struct dcss_dpr_ch *ch, int a_sel, int r_sel,\n\t\t\t\t   int g_sel, int b_sel)\n{\n\tu32 sel;\n\n\tsel = ((a_sel << A_COMP_SEL_POS) & A_COMP_SEL_MASK) |\n\t      ((r_sel << R_COMP_SEL_POS) & R_COMP_SEL_MASK) |\n\t      ((g_sel << G_COMP_SEL_POS) & G_COMP_SEL_MASK) |\n\t      ((b_sel << B_COMP_SEL_POS) & B_COMP_SEL_MASK);\n\n\tch->mode_ctrl &= ~(A_COMP_SEL_MASK | R_COMP_SEL_MASK |\n\t\t\t   G_COMP_SEL_MASK | B_COMP_SEL_MASK);\n\tch->mode_ctrl |= sel;\n}\n\nstatic void dcss_dpr_pix_size_set(struct dcss_dpr_ch *ch,\n\t\t\t\t  const struct drm_format_info *format)\n{\n\tu32 val;\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV21:\n\t\tval = PIX_SIZE_8;\n\t\tbreak;\n\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_VYUY:\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_YVYU:\n\t\tval = PIX_SIZE_16;\n\t\tbreak;\n\n\tdefault:\n\t\tval = PIX_SIZE_32;\n\t\tbreak;\n\t}\n\n\tch->pix_size = val;\n\n\tch->mode_ctrl &= ~PIX_SIZE_MASK;\n\tch->mode_ctrl |= ((val << PIX_SIZE_POS) & PIX_SIZE_MASK);\n}\n\nstatic void dcss_dpr_uv_swap(struct dcss_dpr_ch *ch, bool swap)\n{\n\tch->mode_ctrl &= ~PIX_UV_SWAP;\n\tch->mode_ctrl |= (swap ? PIX_UV_SWAP : 0);\n}\n\nstatic void dcss_dpr_y_uv_swap(struct dcss_dpr_ch *ch, bool swap)\n{\n\tch->mode_ctrl &= ~PIX_LUMA_UV_SWAP;\n\tch->mode_ctrl |= (swap ? PIX_LUMA_UV_SWAP : 0);\n}\n\nstatic void dcss_dpr_2plane_en(struct dcss_dpr_ch *ch, bool en)\n{\n\tch->mode_ctrl &= ~COMP_2PLANE_EN;\n\tch->mode_ctrl |= (en ? COMP_2PLANE_EN : 0);\n}\n\nstatic void dcss_dpr_yuv_en(struct dcss_dpr_ch *ch, bool en)\n{\n\tch->mode_ctrl &= ~YUV_EN;\n\tch->mode_ctrl |= (en ? YUV_EN : 0);\n}\n\nvoid dcss_dpr_enable(struct dcss_dpr *dpr, int ch_num, bool en)\n{\n\tstruct dcss_dpr_ch *ch = &dpr->ch[ch_num];\n\tu32 sys_ctrl;\n\n\tsys_ctrl = (en ? REPEAT_EN | RUN_EN : 0);\n\n\tif (en) {\n\t\tdcss_dpr_write(ch, ch->mode_ctrl, DCSS_DPR_MODE_CTRL0);\n\t\tdcss_dpr_write(ch, ch->frame_ctrl, DCSS_DPR_FRAME_CTRL0);\n\t\tdcss_dpr_write(ch, ch->rtram_ctrl, DCSS_DPR_RTRAM_CTRL0);\n\t}\n\n\tif (ch->sys_ctrl != sys_ctrl)\n\t\tch->sys_ctrl_chgd = true;\n\n\tch->sys_ctrl = sys_ctrl;\n}\n\nstruct rgb_comp_sel {\n\tu32 drm_format;\n\tint a_sel;\n\tint r_sel;\n\tint g_sel;\n\tint b_sel;\n};\n\nstatic struct rgb_comp_sel comp_sel_map[] = {\n\t{DRM_FORMAT_ARGB8888, 3, 2, 1, 0},\n\t{DRM_FORMAT_XRGB8888, 3, 2, 1, 0},\n\t{DRM_FORMAT_ABGR8888, 3, 0, 1, 2},\n\t{DRM_FORMAT_XBGR8888, 3, 0, 1, 2},\n\t{DRM_FORMAT_RGBA8888, 0, 3, 2, 1},\n\t{DRM_FORMAT_RGBX8888, 0, 3, 2, 1},\n\t{DRM_FORMAT_BGRA8888, 0, 1, 2, 3},\n\t{DRM_FORMAT_BGRX8888, 0, 1, 2, 3},\n};\n\nstatic int to_comp_sel(u32 pix_fmt, int *a_sel, int *r_sel, int *g_sel,\n\t\t       int *b_sel)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(comp_sel_map); i++) {\n\t\tif (comp_sel_map[i].drm_format == pix_fmt) {\n\t\t\t*a_sel = comp_sel_map[i].a_sel;\n\t\t\t*r_sel = comp_sel_map[i].r_sel;\n\t\t\t*g_sel = comp_sel_map[i].g_sel;\n\t\t\t*b_sel = comp_sel_map[i].b_sel;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic void dcss_dpr_rtram_set(struct dcss_dpr_ch *ch, u32 pix_format)\n{\n\tu32 val, mask;\n\n\tswitch (pix_format) {\n\tcase DRM_FORMAT_NV21:\n\tcase DRM_FORMAT_NV12:\n\t\tch->rtram_3buf_en = true;\n\t\tch->rtram_4line_en = false;\n\t\tbreak;\n\n\tdefault:\n\t\tch->rtram_3buf_en = true;\n\t\tch->rtram_4line_en = true;\n\t\tbreak;\n\t}\n\n\tval = (ch->rtram_4line_en ? RTR_4LINE_BUF_EN : 0);\n\tval |= (ch->rtram_3buf_en ? RTR_3BUF_EN : 0);\n\tmask = RTR_4LINE_BUF_EN | RTR_3BUF_EN;\n\n\tch->mode_ctrl &= ~mask;\n\tch->mode_ctrl |= (val & mask);\n\n\tval = (ch->rtram_4line_en ? 0 : NUM_ROWS_ACTIVE);\n\tval |= (3 << THRES_LOW_POS) & THRES_LOW_MASK;\n\tval |= (4 << THRES_HIGH_POS) & THRES_HIGH_MASK;\n\tmask = THRES_LOW_MASK | THRES_HIGH_MASK | NUM_ROWS_ACTIVE;\n\n\tch->rtram_ctrl &= ~mask;\n\tch->rtram_ctrl |= (val & mask);\n}\n\nstatic void dcss_dpr_setup_components(struct dcss_dpr_ch *ch,\n\t\t\t\t      const struct drm_format_info *format)\n{\n\tint a_sel, r_sel, g_sel, b_sel;\n\tbool uv_swap, y_uv_swap;\n\n\tswitch (format->format) {\n\tcase DRM_FORMAT_YVYU:\n\t\tuv_swap = true;\n\t\ty_uv_swap = true;\n\t\tbreak;\n\n\tcase DRM_FORMAT_VYUY:\n\tcase DRM_FORMAT_NV21:\n\t\tuv_swap = true;\n\t\ty_uv_swap = false;\n\t\tbreak;\n\n\tcase DRM_FORMAT_YUYV:\n\t\tuv_swap = false;\n\t\ty_uv_swap = true;\n\t\tbreak;\n\n\tdefault:\n\t\tuv_swap = false;\n\t\ty_uv_swap = false;\n\t\tbreak;\n\t}\n\n\tdcss_dpr_uv_swap(ch, uv_swap);\n\n\tdcss_dpr_y_uv_swap(ch, y_uv_swap);\n\n\tif (!format->is_yuv) {\n\t\tif (!to_comp_sel(format->format, &a_sel, &r_sel,\n\t\t\t\t &g_sel, &b_sel)) {\n\t\t\tdcss_dpr_argb_comp_sel(ch, a_sel, r_sel, g_sel, b_sel);\n\t\t} else {\n\t\t\tdcss_dpr_argb_comp_sel(ch, 3, 2, 1, 0);\n\t\t}\n\t} else {\n\t\tdcss_dpr_argb_comp_sel(ch, 0, 0, 0, 0);\n\t}\n}\n\nstatic void dcss_dpr_tile_set(struct dcss_dpr_ch *ch, uint64_t modifier)\n{\n\tswitch (ch->ch_num) {\n\tcase 0:\n\t\tswitch (modifier) {\n\t\tcase DRM_FORMAT_MOD_LINEAR:\n\t\t\tch->tile = TILE_LINEAR;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_MOD_VIVANTE_TILED:\n\t\t\tch->tile = TILE_GPU_STANDARD;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_MOD_VIVANTE_SUPER_TILED:\n\t\t\tch->tile = TILE_GPU_SUPER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tch->tile = TILE_LINEAR;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tch->mode_ctrl &= ~TILE_TYPE_MASK;\n\tch->mode_ctrl |= ((ch->tile << TILE_TYPE_POS) & TILE_TYPE_MASK);\n}\n\nvoid dcss_dpr_format_set(struct dcss_dpr *dpr, int ch_num,\n\t\t\t const struct drm_format_info *format, u64 modifier)\n{\n\tstruct dcss_dpr_ch *ch = &dpr->ch[ch_num];\n\n\tch->format = *format;\n\n\tdcss_dpr_yuv_en(ch, format->is_yuv);\n\n\tdcss_dpr_pix_size_set(ch, format);\n\n\tdcss_dpr_setup_components(ch, format);\n\n\tdcss_dpr_2plane_en(ch, format->num_planes == 2);\n\n\tdcss_dpr_rtram_set(ch, format->format);\n\n\tdcss_dpr_tile_set(ch, modifier);\n}\n\n \nvoid dcss_dpr_write_sysctrl(struct dcss_dpr *dpr)\n{\n\tint chnum;\n\n\tdcss_ctxld_assert_locked(dpr->ctxld);\n\n\tfor (chnum = 0; chnum < 3; chnum++) {\n\t\tstruct dcss_dpr_ch *ch = &dpr->ch[chnum];\n\n\t\tif (ch->sys_ctrl_chgd) {\n\t\t\tdcss_ctxld_write_irqsafe(dpr->ctxld, dpr->ctx_id,\n\t\t\t\t\t\t ch->sys_ctrl,\n\t\t\t\t\t\t ch->base_ofs +\n\t\t\t\t\t\t DCSS_DPR_SYSTEM_CTRL0);\n\t\t\tch->sys_ctrl_chgd = false;\n\t\t}\n\t}\n}\n\nvoid dcss_dpr_set_rotation(struct dcss_dpr *dpr, int ch_num, u32 rotation)\n{\n\tstruct dcss_dpr_ch *ch = &dpr->ch[ch_num];\n\n\tch->frame_ctrl &= ~(HFLIP_EN | VFLIP_EN | ROT_ENC_MASK);\n\n\tch->frame_ctrl |= rotation & DRM_MODE_REFLECT_X ? HFLIP_EN : 0;\n\tch->frame_ctrl |= rotation & DRM_MODE_REFLECT_Y ? VFLIP_EN : 0;\n\n\tif (rotation & DRM_MODE_ROTATE_90)\n\t\tch->frame_ctrl |= 1 << ROT_ENC_POS;\n\telse if (rotation & DRM_MODE_ROTATE_180)\n\t\tch->frame_ctrl |= 2 << ROT_ENC_POS;\n\telse if (rotation & DRM_MODE_ROTATE_270)\n\t\tch->frame_ctrl |= 3 << ROT_ENC_POS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}