{
  "module_name": "dcss-dev.c",
  "hash_id": "421b372a29ca3bc2ba71fa57a23defbca2bd47db85db342abaca7e561af102b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/dcss/dcss-dev.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_device.h>\n#include <drm/drm_modeset_helper.h>\n\n#include \"dcss-dev.h\"\n#include \"dcss-kms.h\"\n\nstatic void dcss_clocks_enable(struct dcss_dev *dcss)\n{\n\tclk_prepare_enable(dcss->axi_clk);\n\tclk_prepare_enable(dcss->apb_clk);\n\tclk_prepare_enable(dcss->rtrm_clk);\n\tclk_prepare_enable(dcss->dtrc_clk);\n\tclk_prepare_enable(dcss->pix_clk);\n}\n\nstatic void dcss_clocks_disable(struct dcss_dev *dcss)\n{\n\tclk_disable_unprepare(dcss->pix_clk);\n\tclk_disable_unprepare(dcss->dtrc_clk);\n\tclk_disable_unprepare(dcss->rtrm_clk);\n\tclk_disable_unprepare(dcss->apb_clk);\n\tclk_disable_unprepare(dcss->axi_clk);\n}\n\nstatic void dcss_disable_dtg_and_ss_cb(void *data)\n{\n\tstruct dcss_dev *dcss = data;\n\n\tdcss->disable_callback = NULL;\n\n\tdcss_ss_shutoff(dcss->ss);\n\tdcss_dtg_shutoff(dcss->dtg);\n\n\tcomplete(&dcss->disable_completion);\n}\n\nvoid dcss_disable_dtg_and_ss(struct dcss_dev *dcss)\n{\n\tdcss->disable_callback = dcss_disable_dtg_and_ss_cb;\n}\n\nvoid dcss_enable_dtg_and_ss(struct dcss_dev *dcss)\n{\n\tif (dcss->disable_callback)\n\t\tdcss->disable_callback = NULL;\n\n\tdcss_dtg_enable(dcss->dtg);\n\tdcss_ss_enable(dcss->ss);\n}\n\nstatic int dcss_submodules_init(struct dcss_dev *dcss)\n{\n\tint ret = 0;\n\tu32 base_addr = dcss->start_addr;\n\tconst struct dcss_type_data *devtype = dcss->devtype;\n\n\tdcss_clocks_enable(dcss);\n\n\tret = dcss_blkctl_init(dcss, base_addr + devtype->blkctl_ofs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dcss_ctxld_init(dcss, base_addr + devtype->ctxld_ofs);\n\tif (ret)\n\t\tgoto ctxld_err;\n\n\tret = dcss_dtg_init(dcss, base_addr + devtype->dtg_ofs);\n\tif (ret)\n\t\tgoto dtg_err;\n\n\tret = dcss_ss_init(dcss, base_addr + devtype->ss_ofs);\n\tif (ret)\n\t\tgoto ss_err;\n\n\tret = dcss_dpr_init(dcss, base_addr + devtype->dpr_ofs);\n\tif (ret)\n\t\tgoto dpr_err;\n\n\tret = dcss_scaler_init(dcss, base_addr + devtype->scaler_ofs);\n\tif (ret)\n\t\tgoto scaler_err;\n\n\tdcss_clocks_disable(dcss);\n\n\treturn 0;\n\nscaler_err:\n\tdcss_dpr_exit(dcss->dpr);\n\ndpr_err:\n\tdcss_ss_exit(dcss->ss);\n\nss_err:\n\tdcss_dtg_exit(dcss->dtg);\n\ndtg_err:\n\tdcss_ctxld_exit(dcss->ctxld);\n\nctxld_err:\n\tdcss_blkctl_exit(dcss->blkctl);\n\n\tdcss_clocks_disable(dcss);\n\n\treturn ret;\n}\n\nstatic void dcss_submodules_stop(struct dcss_dev *dcss)\n{\n\tdcss_clocks_enable(dcss);\n\tdcss_scaler_exit(dcss->scaler);\n\tdcss_dpr_exit(dcss->dpr);\n\tdcss_ss_exit(dcss->ss);\n\tdcss_dtg_exit(dcss->dtg);\n\tdcss_ctxld_exit(dcss->ctxld);\n\tdcss_blkctl_exit(dcss->blkctl);\n\tdcss_clocks_disable(dcss);\n}\n\nstatic int dcss_clks_init(struct dcss_dev *dcss)\n{\n\tint i;\n\tstruct {\n\t\tconst char *id;\n\t\tstruct clk **clk;\n\t} clks[] = {\n\t\t{\"apb\",   &dcss->apb_clk},\n\t\t{\"axi\",   &dcss->axi_clk},\n\t\t{\"pix\",   &dcss->pix_clk},\n\t\t{\"rtrm\",  &dcss->rtrm_clk},\n\t\t{\"dtrc\",  &dcss->dtrc_clk},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(clks); i++) {\n\t\t*clks[i].clk = devm_clk_get(dcss->dev, clks[i].id);\n\t\tif (IS_ERR(*clks[i].clk)) {\n\t\t\tdev_err(dcss->dev, \"failed to get %s clock\\n\",\n\t\t\t\tclks[i].id);\n\t\t\treturn PTR_ERR(*clks[i].clk);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void dcss_clks_release(struct dcss_dev *dcss)\n{\n\tdevm_clk_put(dcss->dev, dcss->dtrc_clk);\n\tdevm_clk_put(dcss->dev, dcss->rtrm_clk);\n\tdevm_clk_put(dcss->dev, dcss->pix_clk);\n\tdevm_clk_put(dcss->dev, dcss->axi_clk);\n\tdevm_clk_put(dcss->dev, dcss->apb_clk);\n}\n\nstruct dcss_dev *dcss_dev_create(struct device *dev, bool hdmi_output)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret;\n\tstruct resource *res;\n\tstruct dcss_dev *dcss;\n\tconst struct dcss_type_data *devtype;\n\n\tdevtype = of_device_get_match_data(dev);\n\tif (!devtype) {\n\t\tdev_err(dev, \"no device match found\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"cannot get memory resource\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdcss = kzalloc(sizeof(*dcss), GFP_KERNEL);\n\tif (!dcss)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdcss->dev = dev;\n\tdcss->devtype = devtype;\n\tdcss->hdmi_output = hdmi_output;\n\n\tret = dcss_clks_init(dcss);\n\tif (ret) {\n\t\tdev_err(dev, \"clocks initialization failed\\n\");\n\t\tgoto err;\n\t}\n\n\tdcss->of_port = of_graph_get_port_by_id(dev->of_node, 0);\n\tif (!dcss->of_port) {\n\t\tdev_err(dev, \"no port@0 node in %pOF\\n\", dev->of_node);\n\t\tret = -ENODEV;\n\t\tgoto clks_err;\n\t}\n\n\tdcss->start_addr = res->start;\n\n\tret = dcss_submodules_init(dcss);\n\tif (ret) {\n\t\tof_node_put(dcss->of_port);\n\t\tdev_err(dev, \"submodules initialization failed\\n\");\n\t\tgoto clks_err;\n\t}\n\n\tinit_completion(&dcss->disable_completion);\n\n\tpm_runtime_set_autosuspend_delay(dev, 100);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_allow(dev);\n\tpm_runtime_enable(dev);\n\n\treturn dcss;\n\nclks_err:\n\tdcss_clks_release(dcss);\n\nerr:\n\tkfree(dcss);\n\n\treturn ERR_PTR(ret);\n}\n\nvoid dcss_dev_destroy(struct dcss_dev *dcss)\n{\n\tif (!pm_runtime_suspended(dcss->dev)) {\n\t\tdcss_ctxld_suspend(dcss->ctxld);\n\t\tdcss_clocks_disable(dcss);\n\t}\n\n\tof_node_put(dcss->of_port);\n\n\tpm_runtime_disable(dcss->dev);\n\n\tdcss_submodules_stop(dcss);\n\n\tdcss_clks_release(dcss);\n\n\tkfree(dcss);\n}\n\nstatic int dcss_dev_suspend(struct device *dev)\n{\n\tstruct dcss_dev *dcss = dcss_drv_dev_to_dcss(dev);\n\tstruct drm_device *ddev = dcss_drv_dev_to_drm(dev);\n\tint ret;\n\n\tdrm_mode_config_helper_suspend(ddev);\n\n\tif (pm_runtime_suspended(dev))\n\t\treturn 0;\n\n\tret = dcss_ctxld_suspend(dcss->ctxld);\n\tif (ret)\n\t\treturn ret;\n\n\tdcss_clocks_disable(dcss);\n\n\treturn 0;\n}\n\nstatic int dcss_dev_resume(struct device *dev)\n{\n\tstruct dcss_dev *dcss = dcss_drv_dev_to_dcss(dev);\n\tstruct drm_device *ddev = dcss_drv_dev_to_drm(dev);\n\n\tif (pm_runtime_suspended(dev)) {\n\t\tdrm_mode_config_helper_resume(ddev);\n\t\treturn 0;\n\t}\n\n\tdcss_clocks_enable(dcss);\n\n\tdcss_blkctl_cfg(dcss->blkctl);\n\n\tdcss_ctxld_resume(dcss->ctxld);\n\n\tdrm_mode_config_helper_resume(ddev);\n\n\treturn 0;\n}\n\nstatic int dcss_dev_runtime_suspend(struct device *dev)\n{\n\tstruct dcss_dev *dcss = dcss_drv_dev_to_dcss(dev);\n\tint ret;\n\n\tret = dcss_ctxld_suspend(dcss->ctxld);\n\tif (ret)\n\t\treturn ret;\n\n\tdcss_clocks_disable(dcss);\n\n\treturn 0;\n}\n\nstatic int dcss_dev_runtime_resume(struct device *dev)\n{\n\tstruct dcss_dev *dcss = dcss_drv_dev_to_dcss(dev);\n\n\tdcss_clocks_enable(dcss);\n\n\tdcss_blkctl_cfg(dcss->blkctl);\n\n\tdcss_ctxld_resume(dcss->ctxld);\n\n\treturn 0;\n}\n\nEXPORT_GPL_DEV_PM_OPS(dcss_dev_pm_ops) = {\n\tRUNTIME_PM_OPS(dcss_dev_runtime_suspend, dcss_dev_runtime_resume, NULL)\n\tSYSTEM_SLEEP_PM_OPS(dcss_dev_suspend, dcss_dev_resume)\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}