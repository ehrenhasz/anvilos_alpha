{
  "module_name": "dcss-dtg.c",
  "hash_id": "fab6e740f284a61e8230152344b4c798d5331f25140eccc3421fdd75761b9a06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/dcss/dcss-dtg.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"dcss-dev.h\"\n\n#define DCSS_DTG_TC_CONTROL_STATUS\t\t\t0x00\n#define   CH3_EN\t\t\t\t\tBIT(0)\n#define   CH2_EN\t\t\t\t\tBIT(1)\n#define   CH1_EN\t\t\t\t\tBIT(2)\n#define   OVL_DATA_MODE\t\t\t\t\tBIT(3)\n#define   BLENDER_VIDEO_ALPHA_SEL\t\t\tBIT(7)\n#define   DTG_START\t\t\t\t\tBIT(8)\n#define   DBY_MODE_EN\t\t\t\t\tBIT(9)\n#define   CH1_ALPHA_SEL\t\t\t\t\tBIT(10)\n#define   CSS_PIX_COMP_SWAP_POS\t\t\t\t12\n#define   CSS_PIX_COMP_SWAP_MASK\t\t\tGENMASK(14, 12)\n#define   DEFAULT_FG_ALPHA_POS\t\t\t\t24\n#define   DEFAULT_FG_ALPHA_MASK\t\t\t\tGENMASK(31, 24)\n#define DCSS_DTG_TC_DTG\t\t\t\t\t0x04\n#define DCSS_DTG_TC_DISP_TOP\t\t\t\t0x08\n#define DCSS_DTG_TC_DISP_BOT\t\t\t\t0x0C\n#define DCSS_DTG_TC_CH1_TOP\t\t\t\t0x10\n#define DCSS_DTG_TC_CH1_BOT\t\t\t\t0x14\n#define DCSS_DTG_TC_CH2_TOP\t\t\t\t0x18\n#define DCSS_DTG_TC_CH2_BOT\t\t\t\t0x1C\n#define DCSS_DTG_TC_CH3_TOP\t\t\t\t0x20\n#define DCSS_DTG_TC_CH3_BOT\t\t\t\t0x24\n#define   TC_X_POS\t\t\t\t\t0\n#define   TC_X_MASK\t\t\t\t\tGENMASK(12, 0)\n#define   TC_Y_POS\t\t\t\t\t16\n#define   TC_Y_MASK\t\t\t\t\tGENMASK(28, 16)\n#define DCSS_DTG_TC_CTXLD\t\t\t\t0x28\n#define   TC_CTXLD_DB_Y_POS\t\t\t\t0\n#define   TC_CTXLD_DB_Y_MASK\t\t\t\tGENMASK(12, 0)\n#define   TC_CTXLD_SB_Y_POS\t\t\t\t16\n#define   TC_CTXLD_SB_Y_MASK\t\t\t\tGENMASK(28, 16)\n#define DCSS_DTG_TC_CH1_BKRND\t\t\t\t0x2C\n#define DCSS_DTG_TC_CH2_BKRND\t\t\t\t0x30\n#define   BKRND_R_Y_COMP_POS\t\t\t\t20\n#define   BKRND_R_Y_COMP_MASK\t\t\t\tGENMASK(29, 20)\n#define   BKRND_G_U_COMP_POS\t\t\t\t10\n#define   BKRND_G_U_COMP_MASK\t\t\t\tGENMASK(19, 10)\n#define   BKRND_B_V_COMP_POS\t\t\t\t0\n#define   BKRND_B_V_COMP_MASK\t\t\t\tGENMASK(9, 0)\n#define DCSS_DTG_BLENDER_DBY_RANGEINV\t\t\t0x38\n#define DCSS_DTG_BLENDER_DBY_RANGEMIN\t\t\t0x3C\n#define DCSS_DTG_BLENDER_DBY_BDP\t\t\t0x40\n#define DCSS_DTG_BLENDER_BKRND_I\t\t\t0x44\n#define DCSS_DTG_BLENDER_BKRND_P\t\t\t0x48\n#define DCSS_DTG_BLENDER_BKRND_T\t\t\t0x4C\n#define DCSS_DTG_LINE0_INT\t\t\t\t0x50\n#define DCSS_DTG_LINE1_INT\t\t\t\t0x54\n#define DCSS_DTG_BG_ALPHA_DEFAULT\t\t\t0x58\n#define DCSS_DTG_INT_STATUS\t\t\t\t0x5C\n#define DCSS_DTG_INT_CONTROL\t\t\t\t0x60\n#define DCSS_DTG_TC_CH3_BKRND\t\t\t\t0x64\n#define DCSS_DTG_INT_MASK\t\t\t\t0x68\n#define   LINE0_IRQ\t\t\t\t\tBIT(0)\n#define   LINE1_IRQ\t\t\t\t\tBIT(1)\n#define   LINE2_IRQ\t\t\t\t\tBIT(2)\n#define   LINE3_IRQ\t\t\t\t\tBIT(3)\n#define DCSS_DTG_LINE2_INT\t\t\t\t0x6C\n#define DCSS_DTG_LINE3_INT\t\t\t\t0x70\n#define DCSS_DTG_DBY_OL\t\t\t\t\t0x74\n#define DCSS_DTG_DBY_BL\t\t\t\t\t0x78\n#define DCSS_DTG_DBY_EL\t\t\t\t\t0x7C\n\nstruct dcss_dtg {\n\tstruct device *dev;\n\tstruct dcss_ctxld *ctxld;\n\tvoid __iomem *base_reg;\n\tu32 base_ofs;\n\n\tu32 ctx_id;\n\n\tbool in_use;\n\n\tu32 dis_ulc_x;\n\tu32 dis_ulc_y;\n\n\tu32 control_status;\n\tu32 alpha;\n\tu32 alpha_cfg;\n\n\tint ctxld_kick_irq;\n\tbool ctxld_kick_irq_en;\n};\n\nstatic void dcss_dtg_write(struct dcss_dtg *dtg, u32 val, u32 ofs)\n{\n\tif (!dtg->in_use)\n\t\tdcss_writel(val, dtg->base_reg + ofs);\n\n\tdcss_ctxld_write(dtg->ctxld, dtg->ctx_id,\n\t\t\t val, dtg->base_ofs + ofs);\n}\n\nstatic irqreturn_t dcss_dtg_irq_handler(int irq, void *data)\n{\n\tstruct dcss_dtg *dtg = data;\n\tu32 status;\n\n\tstatus = dcss_readl(dtg->base_reg + DCSS_DTG_INT_STATUS);\n\n\tif (!(status & LINE0_IRQ))\n\t\treturn IRQ_NONE;\n\n\tdcss_ctxld_kick(dtg->ctxld);\n\n\tdcss_writel(status & LINE0_IRQ, dtg->base_reg + DCSS_DTG_INT_CONTROL);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dcss_dtg_irq_config(struct dcss_dtg *dtg,\n\t\t\t       struct platform_device *pdev)\n{\n\tint ret;\n\n\tdtg->ctxld_kick_irq = platform_get_irq_byname(pdev, \"ctxld_kick\");\n\tif (dtg->ctxld_kick_irq < 0)\n\t\treturn dtg->ctxld_kick_irq;\n\n\tdcss_update(0, LINE0_IRQ | LINE1_IRQ,\n\t\t    dtg->base_reg + DCSS_DTG_INT_MASK);\n\n\tret = request_irq(dtg->ctxld_kick_irq, dcss_dtg_irq_handler,\n\t\t\t  0, \"dcss_ctxld_kick\", dtg);\n\tif (ret) {\n\t\tdev_err(dtg->dev, \"dtg: irq request failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tdisable_irq(dtg->ctxld_kick_irq);\n\n\tdtg->ctxld_kick_irq_en = false;\n\n\treturn 0;\n}\n\nint dcss_dtg_init(struct dcss_dev *dcss, unsigned long dtg_base)\n{\n\tint ret = 0;\n\tstruct dcss_dtg *dtg;\n\n\tdtg = kzalloc(sizeof(*dtg), GFP_KERNEL);\n\tif (!dtg)\n\t\treturn -ENOMEM;\n\n\tdcss->dtg = dtg;\n\tdtg->dev = dcss->dev;\n\tdtg->ctxld = dcss->ctxld;\n\n\tdtg->base_reg = ioremap(dtg_base, SZ_4K);\n\tif (!dtg->base_reg) {\n\t\tdev_err(dcss->dev, \"dtg: unable to remap dtg base\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_ioremap;\n\t}\n\n\tdtg->base_ofs = dtg_base;\n\tdtg->ctx_id = CTX_DB;\n\n\tdtg->alpha = 255;\n\n\tdtg->control_status |= OVL_DATA_MODE | BLENDER_VIDEO_ALPHA_SEL |\n\t\t((dtg->alpha << DEFAULT_FG_ALPHA_POS) & DEFAULT_FG_ALPHA_MASK);\n\n\tret = dcss_dtg_irq_config(dtg, to_platform_device(dcss->dev));\n\tif (ret)\n\t\tgoto err_irq;\n\n\treturn 0;\n\nerr_irq:\n\tiounmap(dtg->base_reg);\n\nerr_ioremap:\n\tkfree(dtg);\n\n\treturn ret;\n}\n\nvoid dcss_dtg_exit(struct dcss_dtg *dtg)\n{\n\tfree_irq(dtg->ctxld_kick_irq, dtg);\n\n\tif (dtg->base_reg)\n\t\tiounmap(dtg->base_reg);\n\n\tkfree(dtg);\n}\n\nvoid dcss_dtg_sync_set(struct dcss_dtg *dtg, struct videomode *vm)\n{\n\tstruct dcss_dev *dcss = dcss_drv_dev_to_dcss(dtg->dev);\n\tu16 dtg_lrc_x, dtg_lrc_y;\n\tu16 dis_ulc_x, dis_ulc_y;\n\tu16 dis_lrc_x, dis_lrc_y;\n\tu32 sb_ctxld_trig, db_ctxld_trig;\n\tu32 pixclock = vm->pixelclock;\n\tu32 actual_clk;\n\n\tdtg_lrc_x = vm->hfront_porch + vm->hback_porch + vm->hsync_len +\n\t\t    vm->hactive - 1;\n\tdtg_lrc_y = vm->vfront_porch + vm->vback_porch + vm->vsync_len +\n\t\t    vm->vactive - 1;\n\tdis_ulc_x = vm->hsync_len + vm->hback_porch - 1;\n\tdis_ulc_y = vm->vsync_len + vm->vfront_porch + vm->vback_porch - 1;\n\tdis_lrc_x = vm->hsync_len + vm->hback_porch + vm->hactive - 1;\n\tdis_lrc_y = vm->vsync_len + vm->vfront_porch + vm->vback_porch +\n\t\t    vm->vactive - 1;\n\n\tclk_disable_unprepare(dcss->pix_clk);\n\tclk_set_rate(dcss->pix_clk, vm->pixelclock);\n\tclk_prepare_enable(dcss->pix_clk);\n\n\tactual_clk = clk_get_rate(dcss->pix_clk);\n\tif (pixclock != actual_clk) {\n\t\tdev_info(dtg->dev,\n\t\t\t \"Pixel clock set to %u kHz instead of %u kHz.\\n\",\n\t\t\t (actual_clk / 1000), (pixclock / 1000));\n\t}\n\n\tdcss_dtg_write(dtg, ((dtg_lrc_y << TC_Y_POS) | dtg_lrc_x),\n\t\t       DCSS_DTG_TC_DTG);\n\tdcss_dtg_write(dtg, ((dis_ulc_y << TC_Y_POS) | dis_ulc_x),\n\t\t       DCSS_DTG_TC_DISP_TOP);\n\tdcss_dtg_write(dtg, ((dis_lrc_y << TC_Y_POS) | dis_lrc_x),\n\t\t       DCSS_DTG_TC_DISP_BOT);\n\n\tdtg->dis_ulc_x = dis_ulc_x;\n\tdtg->dis_ulc_y = dis_ulc_y;\n\n\tsb_ctxld_trig = ((0 * dis_lrc_y / 100) << TC_CTXLD_SB_Y_POS) &\n\t\t\t\t\t\t\tTC_CTXLD_SB_Y_MASK;\n\tdb_ctxld_trig = ((99 * dis_lrc_y / 100) << TC_CTXLD_DB_Y_POS) &\n\t\t\t\t\t\t\tTC_CTXLD_DB_Y_MASK;\n\n\tdcss_dtg_write(dtg, sb_ctxld_trig | db_ctxld_trig, DCSS_DTG_TC_CTXLD);\n\n\t \n\tdcss_dtg_write(dtg, 0, DCSS_DTG_LINE1_INT);\n\n\t \n\tdcss_dtg_write(dtg, ((90 * dis_lrc_y) / 100) << 16, DCSS_DTG_LINE0_INT);\n}\n\nvoid dcss_dtg_plane_pos_set(struct dcss_dtg *dtg, int ch_num,\n\t\t\t    int px, int py, int pw, int ph)\n{\n\tu16 p_ulc_x, p_ulc_y;\n\tu16 p_lrc_x, p_lrc_y;\n\n\tp_ulc_x = dtg->dis_ulc_x + px;\n\tp_ulc_y = dtg->dis_ulc_y + py;\n\tp_lrc_x = p_ulc_x + pw;\n\tp_lrc_y = p_ulc_y + ph;\n\n\tif (!px && !py && !pw && !ph) {\n\t\tdcss_dtg_write(dtg, 0, DCSS_DTG_TC_CH1_TOP + 0x8 * ch_num);\n\t\tdcss_dtg_write(dtg, 0, DCSS_DTG_TC_CH1_BOT + 0x8 * ch_num);\n\t} else {\n\t\tdcss_dtg_write(dtg, ((p_ulc_y << TC_Y_POS) | p_ulc_x),\n\t\t\t       DCSS_DTG_TC_CH1_TOP + 0x8 * ch_num);\n\t\tdcss_dtg_write(dtg, ((p_lrc_y << TC_Y_POS) | p_lrc_x),\n\t\t\t       DCSS_DTG_TC_CH1_BOT + 0x8 * ch_num);\n\t}\n}\n\nbool dcss_dtg_global_alpha_changed(struct dcss_dtg *dtg, int ch_num, int alpha)\n{\n\tif (ch_num)\n\t\treturn false;\n\n\treturn alpha != dtg->alpha;\n}\n\nvoid dcss_dtg_plane_alpha_set(struct dcss_dtg *dtg, int ch_num,\n\t\t\t      const struct drm_format_info *format, int alpha)\n{\n\t \n\tif (ch_num)\n\t\treturn;\n\n\t \n\tif (!format->has_alpha || alpha != 255)\n\t\tdtg->alpha_cfg = (alpha << DEFAULT_FG_ALPHA_POS) & DEFAULT_FG_ALPHA_MASK;\n\telse  \n\t\tdtg->alpha_cfg = CH1_ALPHA_SEL;\n\n\tdtg->alpha = alpha;\n}\n\nvoid dcss_dtg_css_set(struct dcss_dtg *dtg)\n{\n\tdtg->control_status |=\n\t\t\t(0x5 << CSS_PIX_COMP_SWAP_POS) & CSS_PIX_COMP_SWAP_MASK;\n}\n\nvoid dcss_dtg_enable(struct dcss_dtg *dtg)\n{\n\tdtg->control_status |= DTG_START;\n\n\tdtg->control_status &= ~(CH1_ALPHA_SEL | DEFAULT_FG_ALPHA_MASK);\n\tdtg->control_status |= dtg->alpha_cfg;\n\n\tdcss_dtg_write(dtg, dtg->control_status, DCSS_DTG_TC_CONTROL_STATUS);\n\n\tdtg->in_use = true;\n}\n\nvoid dcss_dtg_shutoff(struct dcss_dtg *dtg)\n{\n\tdtg->control_status &= ~DTG_START;\n\n\tdcss_writel(dtg->control_status,\n\t\t    dtg->base_reg + DCSS_DTG_TC_CONTROL_STATUS);\n\n\tdtg->in_use = false;\n}\n\nbool dcss_dtg_is_enabled(struct dcss_dtg *dtg)\n{\n\treturn dtg->in_use;\n}\n\nvoid dcss_dtg_ch_enable(struct dcss_dtg *dtg, int ch_num, bool en)\n{\n\tu32 ch_en_map[] = {CH1_EN, CH2_EN, CH3_EN};\n\tu32 control_status;\n\n\tcontrol_status = dtg->control_status & ~ch_en_map[ch_num];\n\tcontrol_status |= en ? ch_en_map[ch_num] : 0;\n\n\tcontrol_status &= ~(CH1_ALPHA_SEL | DEFAULT_FG_ALPHA_MASK);\n\tcontrol_status |= dtg->alpha_cfg;\n\n\tif (dtg->control_status != control_status)\n\t\tdcss_dtg_write(dtg, control_status, DCSS_DTG_TC_CONTROL_STATUS);\n\n\tdtg->control_status = control_status;\n}\n\nvoid dcss_dtg_vblank_irq_enable(struct dcss_dtg *dtg, bool en)\n{\n\tu32 status;\n\tu32 mask = en ? LINE1_IRQ : 0;\n\n\tif (en) {\n\t\tstatus = dcss_readl(dtg->base_reg + DCSS_DTG_INT_STATUS);\n\t\tdcss_writel(status & LINE1_IRQ,\n\t\t\t    dtg->base_reg + DCSS_DTG_INT_CONTROL);\n\t}\n\n\tdcss_update(mask, LINE1_IRQ, dtg->base_reg + DCSS_DTG_INT_MASK);\n}\n\nvoid dcss_dtg_ctxld_kick_irq_enable(struct dcss_dtg *dtg, bool en)\n{\n\tu32 status;\n\tu32 mask = en ? LINE0_IRQ : 0;\n\n\tif (en) {\n\t\tstatus = dcss_readl(dtg->base_reg + DCSS_DTG_INT_STATUS);\n\n\t\tif (!dtg->ctxld_kick_irq_en) {\n\t\t\tdcss_writel(status & LINE0_IRQ,\n\t\t\t\t    dtg->base_reg + DCSS_DTG_INT_CONTROL);\n\t\t\tenable_irq(dtg->ctxld_kick_irq);\n\t\t\tdtg->ctxld_kick_irq_en = true;\n\t\t\tdcss_update(mask, LINE0_IRQ,\n\t\t\t\t    dtg->base_reg + DCSS_DTG_INT_MASK);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (!dtg->ctxld_kick_irq_en)\n\t\treturn;\n\n\tdisable_irq_nosync(dtg->ctxld_kick_irq);\n\tdtg->ctxld_kick_irq_en = false;\n\n\tdcss_update(mask, LINE0_IRQ, dtg->base_reg + DCSS_DTG_INT_MASK);\n}\n\nvoid dcss_dtg_vblank_irq_clear(struct dcss_dtg *dtg)\n{\n\tdcss_update(LINE1_IRQ, LINE1_IRQ, dtg->base_reg + DCSS_DTG_INT_CONTROL);\n}\n\nbool dcss_dtg_vblank_irq_valid(struct dcss_dtg *dtg)\n{\n\treturn !!(dcss_readl(dtg->base_reg + DCSS_DTG_INT_STATUS) & LINE1_IRQ);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}