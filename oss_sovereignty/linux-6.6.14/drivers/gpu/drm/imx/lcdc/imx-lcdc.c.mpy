{
  "module_name": "imx-lcdc.c",
  "hash_id": "c19d57f50fc1b3bca6fa41b7c15565940cc617cdb917c44d9d13e611976787b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/imx/lcdc/imx-lcdc.c",
  "human_readable_source": "\n\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_vblank.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#define IMX21LCDC_LSSAR         0x0000  \n#define IMX21LCDC_LSR           0x0004  \n#define IMX21LCDC_LVPWR         0x0008  \n#define IMX21LCDC_LCPR          0x000C  \n#define IMX21LCDC_LCWHB         0x0010  \n#define IMX21LCDC_LCCMR         0x0014  \n#define IMX21LCDC_LPCR          0x0018  \n#define IMX21LCDC_LHCR          0x001C  \n#define IMX21LCDC_LVCR          0x0020  \n#define IMX21LCDC_LPOR          0x0024  \n#define IMX21LCDC_LSCR          0x0028  \n#define IMX21LCDC_LPCCR         0x002C  \n#define IMX21LCDC_LDCR          0x0030  \n#define IMX21LCDC_LRMCR         0x0034  \n#define IMX21LCDC_LICR          0x0038  \n#define IMX21LCDC_LIER          0x003C  \n#define IMX21LCDC_LISR          0x0040  \n#define IMX21LCDC_LGWSAR        0x0050  \n#define IMX21LCDC_LGWSR         0x0054  \n#define IMX21LCDC_LGWVPWR       0x0058  \n#define IMX21LCDC_LGWPOR        0x005C  \n#define IMX21LCDC_LGWPR         0x0060  \n#define IMX21LCDC_LGWCR         0x0064  \n#define IMX21LCDC_LGWDCR        0x0068  \n#define IMX21LCDC_LAUSCR        0x0080  \n#define IMX21LCDC_LAUSCCR       0x0084  \n#define IMX21LCDC_BGLUT         0x0800  \n#define IMX21LCDC_GWLUT         0x0C00  \n\n#define IMX21LCDC_LCPR_CC0 BIT(30)  \n#define IMX21LCDC_LCPR_CC1 BIT(31)  \n\n \n#define IMX21LCDC_LHCR_HWIDTH\t\tGENMASK(31, 26)\n#define IMX21LCDC_LHCR_HFPORCH\t\tGENMASK(15, 8)\t\t \n#define IMX21LCDC_LHCR_HBPORCH\t\tGENMASK(7, 0)\t\t \n\n#define IMX21LCDC_LVCR_VWIDTH\t\tGENMASK(31, 26)\n#define IMX21LCDC_LVCR_VFPORCH\t\tGENMASK(15, 8)\t\t \n#define IMX21LCDC_LVCR_VBPORCH\t\tGENMASK(7, 0)\t\t \n\n#define IMX21LCDC_LSR_XMAX\t\tGENMASK(25, 20)\n#define IMX21LCDC_LSR_YMAX\t\tGENMASK(9, 0)\n\n \n#define IMX21LCDC_LPCR_PCD\t\tGENMASK(5, 0)\n#define IMX21LCDC_LPCR_SHARP\t\tBIT(6)\n#define IMX21LCDC_LPCR_SCLKSEL\t\tBIT(7)\n#define IMX21LCDC_LPCR_ACD\t\tGENMASK(14, 8)\n#define IMX21LCDC_LPCR_ACDSEL\t\tBIT(15)\n#define IMX21LCDC_LPCR_REV_VS\t\tBIT(16)\n#define IMX21LCDC_LPCR_SWAP_SEL\t\tBIT(17)\n#define IMX21LCDC_LPCR_END_SEL\t\tBIT(18)\n#define IMX21LCDC_LPCR_SCLKIDLE\t\tBIT(19)\n#define IMX21LCDC_LPCR_OEPOL\t\tBIT(20)\n#define IMX21LCDC_LPCR_CLKPOL\t\tBIT(21)\n#define IMX21LCDC_LPCR_LPPOL\t\tBIT(22)\n#define IMX21LCDC_LPCR_FLMPOL\t\tBIT(23)\n#define IMX21LCDC_LPCR_PIXPOL\t\tBIT(24)\n#define IMX21LCDC_LPCR_BPIX\t\tGENMASK(27, 25)\n#define IMX21LCDC_LPCR_PBSIZ\t\tGENMASK(29, 28)\n#define IMX21LCDC_LPCR_COLOR\t\tBIT(30)\n#define IMX21LCDC_LPCR_TFT\t\tBIT(31)\n\n#define INTR_EOF BIT(1)  \n\n#define BPP_RGB565\t0x05\n#define BPP_XRGB8888\t0x07\n\n#define LCDC_MIN_XRES 64\n#define LCDC_MIN_YRES 64\n\n#define LCDC_MAX_XRES 1024\n#define LCDC_MAX_YRES 1024\n\nstruct imx_lcdc {\n\tstruct drm_device drm;\n\tstruct drm_simple_display_pipe pipe;\n\tstruct drm_connector *connector;\n\tvoid __iomem *base;\n\n\tstruct clk *clk_ipg;\n\tstruct clk *clk_ahb;\n\tstruct clk *clk_per;\n};\n\nstatic const u32 imx_lcdc_formats[] = {\n\tDRM_FORMAT_RGB565, DRM_FORMAT_XRGB8888,\n};\n\nstatic inline struct imx_lcdc *imx_lcdc_from_drmdev(struct drm_device *drm)\n{\n\treturn container_of(drm, struct imx_lcdc, drm);\n}\n\nstatic unsigned int imx_lcdc_get_format(unsigned int drm_format)\n{\n\tswitch (drm_format) {\n\tdefault:\n\t\tDRM_WARN(\"Format not supported - fallback to XRGB8888\\n\");\n\t\tfallthrough;\n\n\tcase DRM_FORMAT_XRGB8888:\n\t\treturn BPP_XRGB8888;\n\n\tcase DRM_FORMAT_RGB565:\n\t\treturn BPP_RGB565;\n\t}\n}\n\nstatic void imx_lcdc_update_hw_registers(struct drm_simple_display_pipe *pipe,\n\t\t\t\t\t struct drm_plane_state *old_state,\n\t\t\t\t\t bool mode_set)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_plane_state *new_state = pipe->plane.state;\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct imx_lcdc *lcdc = imx_lcdc_from_drmdev(pipe->crtc.dev);\n\tu32 lpcr, lvcr, lhcr;\n\tu32 framesize;\n\tdma_addr_t addr;\n\n\taddr = drm_fb_dma_get_gem_addr(fb, new_state, 0);\n\t \n\twritel(addr, lcdc->base + IMX21LCDC_LSSAR);\n\n\tif (!mode_set)\n\t\treturn;\n\n\t \n\tif (old_state && old_state->crtc && old_state->crtc->enabled)\n\t\tclk_disable_unprepare(lcdc->clk_per);\n\n\t \n\tframesize = FIELD_PREP(IMX21LCDC_LSR_XMAX, crtc->mode.hdisplay >> 4) |\n\t\tFIELD_PREP(IMX21LCDC_LSR_YMAX, crtc->mode.vdisplay);\n\twritel(framesize, lcdc->base + IMX21LCDC_LSR);\n\n\t \n\tlhcr = FIELD_PREP(IMX21LCDC_LHCR_HFPORCH, crtc->mode.hsync_start - crtc->mode.hdisplay - 1) |\n\t\tFIELD_PREP(IMX21LCDC_LHCR_HWIDTH, crtc->mode.hsync_end - crtc->mode.hsync_start - 1) |\n\t\tFIELD_PREP(IMX21LCDC_LHCR_HBPORCH, crtc->mode.htotal - crtc->mode.hsync_end - 3);\n\twritel(lhcr, lcdc->base + IMX21LCDC_LHCR);\n\n\t \n\tlvcr = FIELD_PREP(IMX21LCDC_LVCR_VFPORCH, crtc->mode.vsync_start - crtc->mode.vdisplay) |\n\t\tFIELD_PREP(IMX21LCDC_LVCR_VWIDTH, crtc->mode.vsync_end - crtc->mode.vsync_start) |\n\t\tFIELD_PREP(IMX21LCDC_LVCR_VBPORCH, crtc->mode.vtotal - crtc->mode.vsync_end);\n\twritel(lvcr, lcdc->base + IMX21LCDC_LVCR);\n\n\tlpcr = readl(lcdc->base + IMX21LCDC_LPCR);\n\tlpcr &= ~IMX21LCDC_LPCR_BPIX;\n\tlpcr |= FIELD_PREP(IMX21LCDC_LPCR_BPIX, imx_lcdc_get_format(fb->format->format));\n\twritel(lpcr, lcdc->base + IMX21LCDC_LPCR);\n\n\t \n\twritel(new_state->fb->pitches[0] / 4, lcdc->base + IMX21LCDC_LVPWR);\n\n\t \n\tif (new_state->crtc->enabled)\n\t\tclk_prepare_enable(lcdc->clk_per);\n}\n\nstatic void imx_lcdc_pipe_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t struct drm_plane_state *plane_state)\n{\n\tint ret;\n\tint clk_div;\n\tint bpp;\n\tstruct imx_lcdc *lcdc = imx_lcdc_from_drmdev(pipe->crtc.dev);\n\tstruct drm_display_mode *mode = &pipe->crtc.mode;\n\tstruct drm_display_info *disp_info = &lcdc->connector->display_info;\n\tconst int hsync_pol = (mode->flags & DRM_MODE_FLAG_PHSYNC) ? 0 : 1;\n\tconst int vsync_pol = (mode->flags & DRM_MODE_FLAG_PVSYNC) ? 0 : 1;\n\tconst int data_enable_pol =\n\t\t(disp_info->bus_flags & DRM_BUS_FLAG_DE_HIGH) ? 0 : 1;\n\tconst int clk_pol =\n\t\t(disp_info->bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE) ? 0 : 1;\n\n\tclk_div = DIV_ROUND_CLOSEST_ULL(clk_get_rate(lcdc->clk_per),\n\t\t\t\t\tmode->clock * 1000);\n\tbpp = imx_lcdc_get_format(plane_state->fb->format->format);\n\n\twritel(FIELD_PREP(IMX21LCDC_LPCR_PCD, clk_div - 1) |\n\t       FIELD_PREP(IMX21LCDC_LPCR_LPPOL, hsync_pol) |\n\t       FIELD_PREP(IMX21LCDC_LPCR_FLMPOL, vsync_pol) |\n\t       FIELD_PREP(IMX21LCDC_LPCR_OEPOL, data_enable_pol) |\n\t       FIELD_PREP(IMX21LCDC_LPCR_TFT, 1) |\n\t       FIELD_PREP(IMX21LCDC_LPCR_COLOR, 1) |\n\t       FIELD_PREP(IMX21LCDC_LPCR_PBSIZ, 3) |\n\t       FIELD_PREP(IMX21LCDC_LPCR_BPIX, bpp) |\n\t       FIELD_PREP(IMX21LCDC_LPCR_SCLKSEL, 1) |\n\t       FIELD_PREP(IMX21LCDC_LPCR_PIXPOL, 0) |\n\t       FIELD_PREP(IMX21LCDC_LPCR_CLKPOL, clk_pol),\n\t       lcdc->base + IMX21LCDC_LPCR);\n\n\t \n\twritel(0x00000000, lcdc->base + IMX21LCDC_LPOR);\n\n\t \n\twritel(readl(lcdc->base + IMX21LCDC_LCPR) & ~(IMX21LCDC_LCPR_CC0 | IMX21LCDC_LCPR_CC1),\n\t       lcdc->base + IMX21LCDC_LCPR);\n\n\tret = clk_prepare_enable(lcdc->clk_ipg);\n\tif (ret) {\n\t\tdev_err(pipe->crtc.dev->dev, \"Cannot enable ipg clock: %pe\\n\", ERR_PTR(ret));\n\t\treturn;\n\t}\n\tret = clk_prepare_enable(lcdc->clk_ahb);\n\tif (ret) {\n\t\tdev_err(pipe->crtc.dev->dev, \"Cannot enable ahb clock: %pe\\n\", ERR_PTR(ret));\n\n\t\tclk_disable_unprepare(lcdc->clk_ipg);\n\n\t\treturn;\n\t}\n\n\timx_lcdc_update_hw_registers(pipe, NULL, true);\n\n\t \n\twritel(INTR_EOF, lcdc->base + IMX21LCDC_LIER);\n}\n\nstatic void imx_lcdc_pipe_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct imx_lcdc *lcdc = imx_lcdc_from_drmdev(pipe->crtc.dev);\n\tstruct drm_crtc *crtc = &lcdc->pipe.crtc;\n\tstruct drm_pending_vblank_event *event;\n\n\tclk_disable_unprepare(lcdc->clk_ahb);\n\tclk_disable_unprepare(lcdc->clk_ipg);\n\n\tif (pipe->crtc.enabled)\n\t\tclk_disable_unprepare(lcdc->clk_per);\n\n\tspin_lock_irq(&lcdc->drm.event_lock);\n\tevent = crtc->state->event;\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t}\n\tspin_unlock_irq(&lcdc->drm.event_lock);\n\n\t \n\twritel(0, lcdc->base + IMX21LCDC_LIER);\n}\n\nstatic int imx_lcdc_pipe_check(struct drm_simple_display_pipe *pipe,\n\t\t\t       struct drm_plane_state *plane_state,\n\t\t\t       struct drm_crtc_state *crtc_state)\n{\n\tconst struct drm_display_mode *mode = &crtc_state->mode;\n\tconst struct drm_display_mode *old_mode = &pipe->crtc.state->mode;\n\n\tif (mode->hdisplay < LCDC_MIN_XRES || mode->hdisplay > LCDC_MAX_XRES ||\n\t    mode->vdisplay < LCDC_MIN_YRES || mode->vdisplay > LCDC_MAX_YRES ||\n\t    mode->hdisplay % 0x10) {  \n\t\tdrm_err(pipe->crtc.dev, \"unsupported display mode (%u x %u)\\n\",\n\t\t\tmode->hdisplay, mode->vdisplay);\n\t\treturn -EINVAL;\n\t}\n\n\tcrtc_state->mode_changed =\n\t\told_mode->hdisplay != mode->hdisplay ||\n\t\told_mode->vdisplay != mode->vdisplay;\n\n\treturn 0;\n}\n\nstatic void imx_lcdc_pipe_update(struct drm_simple_display_pipe *pipe,\n\t\t\t\t struct drm_plane_state *old_state)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_pending_vblank_event *event = crtc->state->event;\n\tstruct drm_plane_state *new_state = pipe->plane.state;\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct drm_framebuffer *old_fb = old_state->fb;\n\tstruct drm_crtc *old_crtc = old_state->crtc;\n\tbool mode_changed = false;\n\n\tif (old_fb && old_fb->format != fb->format)\n\t\tmode_changed = true;\n\telse if (old_crtc != crtc)\n\t\tmode_changed = true;\n\n\timx_lcdc_update_hw_registers(pipe, old_state, mode_changed);\n\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\n\t\tif (crtc->state->active && drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n}\n\nstatic const struct drm_simple_display_pipe_funcs imx_lcdc_pipe_funcs = {\n\t.enable = imx_lcdc_pipe_enable,\n\t.disable = imx_lcdc_pipe_disable,\n\t.check = imx_lcdc_pipe_check,\n\t.update = imx_lcdc_pipe_update,\n};\n\nstatic const struct drm_mode_config_funcs imx_lcdc_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic const struct drm_mode_config_helper_funcs imx_lcdc_mode_config_helpers = {\n\t.atomic_commit_tail = drm_atomic_helper_commit_tail_rpm,\n};\n\nDEFINE_DRM_GEM_DMA_FOPS(imx_lcdc_drm_fops);\n\nstatic struct drm_driver imx_lcdc_drm_driver = {\n\t.driver_features = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops = &imx_lcdc_drm_fops,\n\tDRM_GEM_DMA_DRIVER_OPS_VMAP,\n\t.name = \"imx-lcdc\",\n\t.desc = \"i.MX LCDC driver\",\n\t.date = \"20200716\",\n};\n\nstatic const struct of_device_id imx_lcdc_of_dev_id[] = {\n\t{\n\t\t.compatible = \"fsl,imx21-lcdc\",\n\t},\n\t{\n\t\t.compatible = \"fsl,imx25-lcdc\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_lcdc_of_dev_id);\n\nstatic irqreturn_t imx_lcdc_irq_handler(int irq, void *arg)\n{\n\tstruct imx_lcdc *lcdc = arg;\n\tstruct drm_crtc *crtc = &lcdc->pipe.crtc;\n\tunsigned int status;\n\n\tstatus = readl(lcdc->base + IMX21LCDC_LISR);\n\n\tif (status & INTR_EOF) {\n\t\tdrm_crtc_handle_vblank(crtc);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int imx_lcdc_probe(struct platform_device *pdev)\n{\n\tstruct imx_lcdc *lcdc;\n\tstruct drm_device *drm;\n\tstruct drm_bridge *bridge;\n\tint irq;\n\tint ret;\n\tstruct device *dev = &pdev->dev;\n\n\tlcdc = devm_drm_dev_alloc(dev, &imx_lcdc_drm_driver,\n\t\t\t\t  struct imx_lcdc, drm);\n\tif (IS_ERR(lcdc))\n\t\treturn PTR_ERR(lcdc);\n\n\tdrm = &lcdc->drm;\n\n\tlcdc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(lcdc->base))\n\t\treturn dev_err_probe(dev, PTR_ERR(lcdc->base), \"Cannot get IO memory\\n\");\n\n\tbridge = devm_drm_of_get_bridge(dev, dev->of_node, 0, 0);\n\tif (IS_ERR(bridge))\n\t\treturn dev_err_probe(dev, PTR_ERR(bridge), \"Failed to find bridge\\n\");\n\n\t \n\tlcdc->clk_ipg = devm_clk_get(dev, \"ipg\");\n\tif (IS_ERR(lcdc->clk_ipg))\n\t\treturn dev_err_probe(dev, PTR_ERR(lcdc->clk_ipg), \"Failed to get %s clk\\n\", \"ipg\");\n\n\tlcdc->clk_ahb = devm_clk_get(dev, \"ahb\");\n\tif (IS_ERR(lcdc->clk_ahb))\n\t\treturn dev_err_probe(dev, PTR_ERR(lcdc->clk_ahb), \"Failed to get %s clk\\n\", \"ahb\");\n\n\tlcdc->clk_per = devm_clk_get(dev, \"per\");\n\tif (IS_ERR(lcdc->clk_per))\n\t\treturn dev_err_probe(dev, PTR_ERR(lcdc->clk_per), \"Failed to get %s clk\\n\", \"per\");\n\n\tret = dma_set_mask_and_coherent(drm->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Cannot set DMA Mask\\n\");\n\n\t \n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Cannot initialize mode configuration structure\\n\");\n\n\t \n\tret = drm_simple_display_pipe_init(drm, &lcdc->pipe,\n\t\t\t\t\t   &imx_lcdc_pipe_funcs,\n\t\t\t\t\t   imx_lcdc_formats,\n\t\t\t\t\t   ARRAY_SIZE(imx_lcdc_formats), NULL, NULL);\n\tif (ret < 0)\n\t\treturn dev_err_probe(drm->dev, ret, \"Cannot setup simple display pipe\\n\");\n\n\tret = drm_vblank_init(drm, drm->mode_config.num_crtc);\n\tif (ret < 0)\n\t\treturn dev_err_probe(drm->dev, ret, \"Failed to initialize vblank\\n\");\n\n\tret = drm_bridge_attach(&lcdc->pipe.encoder, bridge, NULL, DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret)\n\t\treturn dev_err_probe(drm->dev, ret, \"Cannot attach bridge\\n\");\n\n\tlcdc->connector = drm_bridge_connector_init(drm, &lcdc->pipe.encoder);\n\tif (IS_ERR(lcdc->connector))\n\t\treturn dev_err_probe(drm->dev, PTR_ERR(lcdc->connector), \"Cannot init bridge connector\\n\");\n\n\tdrm_connector_attach_encoder(lcdc->connector, &lcdc->pipe.encoder);\n\n\t \n\n\tret = clk_prepare_enable(lcdc->clk_ipg);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Cannot enable ipg clock\\n\");\n\tclk_disable_unprepare(lcdc->clk_ipg);\n\n\tret = clk_prepare_enable(lcdc->clk_per);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Cannot enable per clock\\n\");\n\tclk_disable_unprepare(lcdc->clk_per);\n\n\tret = clk_prepare_enable(lcdc->clk_ahb);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Cannot enable ahb clock\\n\");\n\tclk_disable_unprepare(lcdc->clk_ahb);\n\n\tdrm->mode_config.min_width = LCDC_MIN_XRES;\n\tdrm->mode_config.max_width = LCDC_MAX_XRES;\n\tdrm->mode_config.min_height = LCDC_MIN_YRES;\n\tdrm->mode_config.max_height = LCDC_MAX_YRES;\n\tdrm->mode_config.preferred_depth = 16;\n\tdrm->mode_config.funcs = &imx_lcdc_mode_config_funcs;\n\tdrm->mode_config.helper_private = &imx_lcdc_mode_config_helpers;\n\n\tdrm_mode_config_reset(drm);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(dev, irq, imx_lcdc_irq_handler, 0, \"imx-lcdc\", lcdc);\n\tif (ret < 0)\n\t\treturn dev_err_probe(drm->dev, ret, \"Failed to install IRQ handler\\n\");\n\n\tplatform_set_drvdata(pdev, drm);\n\n\tret = drm_dev_register(&lcdc->drm, 0);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Cannot register device\\n\");\n\n\tdrm_fbdev_generic_setup(drm, 0);\n\n\treturn 0;\n}\n\nstatic int imx_lcdc_remove(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\n\tdrm_dev_unregister(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\n\treturn 0;\n}\n\nstatic void imx_lcdc_shutdown(struct platform_device *pdev)\n{\n\tdrm_atomic_helper_shutdown(platform_get_drvdata(pdev));\n}\n\nstatic struct platform_driver imx_lcdc_driver = {\n\t.driver = {\n\t\t.name = \"imx-lcdc\",\n\t\t.of_match_table = imx_lcdc_of_dev_id,\n\t},\n\t.probe = imx_lcdc_probe,\n\t.remove = imx_lcdc_remove,\n\t.shutdown = imx_lcdc_shutdown,\n};\nmodule_platform_driver(imx_lcdc_driver);\n\nMODULE_AUTHOR(\"Marian Cichy <M.Cichy@pengutronix.de>\");\nMODULE_DESCRIPTION(\"Freescale i.MX LCDC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}