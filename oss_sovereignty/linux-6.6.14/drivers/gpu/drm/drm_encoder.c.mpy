{
  "module_name": "drm_encoder.c",
  "hash_id": "566f4cf2ed6153c37a64bfb6697224da6eb2d732b6eb806c5bb62b043abf48b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_encoder.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n\n \nstatic const struct drm_prop_enum_list drm_encoder_enum_list[] = {\n\t{ DRM_MODE_ENCODER_NONE, \"None\" },\n\t{ DRM_MODE_ENCODER_DAC, \"DAC\" },\n\t{ DRM_MODE_ENCODER_TMDS, \"TMDS\" },\n\t{ DRM_MODE_ENCODER_LVDS, \"LVDS\" },\n\t{ DRM_MODE_ENCODER_TVDAC, \"TV\" },\n\t{ DRM_MODE_ENCODER_VIRTUAL, \"Virtual\" },\n\t{ DRM_MODE_ENCODER_DSI, \"DSI\" },\n\t{ DRM_MODE_ENCODER_DPMST, \"DP MST\" },\n\t{ DRM_MODE_ENCODER_DPI, \"DPI\" },\n};\n\nint drm_encoder_register_all(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder;\n\tint ret = 0;\n\n\tdrm_for_each_encoder(encoder, dev) {\n\t\tif (encoder->funcs && encoder->funcs->late_register)\n\t\t\tret = encoder->funcs->late_register(encoder);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid drm_encoder_unregister_all(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder;\n\n\tdrm_for_each_encoder(encoder, dev) {\n\t\tif (encoder->funcs && encoder->funcs->early_unregister)\n\t\t\tencoder->funcs->early_unregister(encoder);\n\t}\n}\n\n__printf(5, 0)\nstatic int __drm_encoder_init(struct drm_device *dev,\n\t\t\t      struct drm_encoder *encoder,\n\t\t\t      const struct drm_encoder_funcs *funcs,\n\t\t\t      int encoder_type, const char *name, va_list ap)\n{\n\tint ret;\n\n\t \n\tif (WARN_ON(dev->mode_config.num_encoder >= 32))\n\t\treturn -EINVAL;\n\n\tret = drm_mode_object_add(dev, &encoder->base, DRM_MODE_OBJECT_ENCODER);\n\tif (ret)\n\t\treturn ret;\n\n\tencoder->dev = dev;\n\tencoder->encoder_type = encoder_type;\n\tencoder->funcs = funcs;\n\tif (name) {\n\t\tencoder->name = kvasprintf(GFP_KERNEL, name, ap);\n\t} else {\n\t\tencoder->name = kasprintf(GFP_KERNEL, \"%s-%d\",\n\t\t\t\t\t  drm_encoder_enum_list[encoder_type].name,\n\t\t\t\t\t  encoder->base.id);\n\t}\n\tif (!encoder->name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\tINIT_LIST_HEAD(&encoder->bridge_chain);\n\tlist_add_tail(&encoder->head, &dev->mode_config.encoder_list);\n\tencoder->index = dev->mode_config.num_encoder++;\n\nout_put:\n\tif (ret)\n\t\tdrm_mode_object_unregister(dev, &encoder->base);\n\n\treturn ret;\n}\n\n \nint drm_encoder_init(struct drm_device *dev,\n\t\t     struct drm_encoder *encoder,\n\t\t     const struct drm_encoder_funcs *funcs,\n\t\t     int encoder_type, const char *name, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tWARN_ON(!funcs->destroy);\n\n\tva_start(ap, name);\n\tret = __drm_encoder_init(dev, encoder, funcs, encoder_type, name, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_encoder_init);\n\n \nvoid drm_encoder_cleanup(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_bridge *bridge, *next;\n\n\t \n\n\tlist_for_each_entry_safe(bridge, next, &encoder->bridge_chain,\n\t\t\t\t chain_node)\n\t\tdrm_bridge_detach(bridge);\n\n\tdrm_mode_object_unregister(dev, &encoder->base);\n\tkfree(encoder->name);\n\tlist_del(&encoder->head);\n\tdev->mode_config.num_encoder--;\n\n\tmemset(encoder, 0, sizeof(*encoder));\n}\nEXPORT_SYMBOL(drm_encoder_cleanup);\n\nstatic void drmm_encoder_alloc_release(struct drm_device *dev, void *ptr)\n{\n\tstruct drm_encoder *encoder = ptr;\n\n\tif (WARN_ON(!encoder->dev))\n\t\treturn;\n\n\tdrm_encoder_cleanup(encoder);\n}\n\n__printf(5, 0)\nstatic int __drmm_encoder_init(struct drm_device *dev,\n\t\t\t       struct drm_encoder *encoder,\n\t\t\t       const struct drm_encoder_funcs *funcs,\n\t\t\t       int encoder_type,\n\t\t\t       const char *name,\n\t\t\t       va_list args)\n{\n\tint ret;\n\n\tif (drm_WARN_ON(dev, funcs && funcs->destroy))\n\t\treturn -EINVAL;\n\n\tret = __drm_encoder_init(dev, encoder, funcs, encoder_type, name, args);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drmm_add_action_or_reset(dev, drmm_encoder_alloc_release, encoder);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nvoid *__drmm_encoder_alloc(struct drm_device *dev, size_t size, size_t offset,\n\t\t\t   const struct drm_encoder_funcs *funcs,\n\t\t\t   int encoder_type, const char *name, ...)\n{\n\tvoid *container;\n\tstruct drm_encoder *encoder;\n\tva_list ap;\n\tint ret;\n\n\tcontainer = drmm_kzalloc(dev, size, GFP_KERNEL);\n\tif (!container)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tencoder = container + offset;\n\n\tva_start(ap, name);\n\tret = __drmm_encoder_init(dev, encoder, funcs, encoder_type, name, ap);\n\tva_end(ap);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn container;\n}\nEXPORT_SYMBOL(__drmm_encoder_alloc);\n\n \nint drmm_encoder_init(struct drm_device *dev, struct drm_encoder *encoder,\n\t\t      const struct drm_encoder_funcs *funcs,\n\t\t      int encoder_type, const char *name, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, name);\n\tret = __drmm_encoder_init(dev, encoder, funcs, encoder_type, name, ap);\n\tva_end(ap);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drmm_encoder_init);\n\nstatic struct drm_crtc *drm_encoder_get_crtc(struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_device *dev = encoder->dev;\n\tbool uses_atomic = false;\n\tstruct drm_connector_list_iter conn_iter;\n\n\t \n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (!connector->state)\n\t\t\tcontinue;\n\n\t\tuses_atomic = true;\n\n\t\tif (connector->state->best_encoder != encoder)\n\t\t\tcontinue;\n\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\treturn connector->state->crtc;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t \n\tif (uses_atomic)\n\t\treturn NULL;\n\n\treturn encoder->crtc;\n}\n\nint drm_mode_getencoder(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_mode_get_encoder *enc_resp = data;\n\tstruct drm_encoder *encoder;\n\tstruct drm_crtc *crtc;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tencoder = drm_encoder_find(dev, file_priv, enc_resp->encoder_id);\n\tif (!encoder)\n\t\treturn -ENOENT;\n\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\tcrtc = drm_encoder_get_crtc(encoder);\n\tif (crtc && drm_lease_held(file_priv, crtc->base.id))\n\t\tenc_resp->crtc_id = crtc->base.id;\n\telse\n\t\tenc_resp->crtc_id = 0;\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\n\tenc_resp->encoder_type = encoder->encoder_type;\n\tenc_resp->encoder_id = encoder->base.id;\n\tenc_resp->possible_crtcs = drm_lease_filter_crtcs(file_priv,\n\t\t\t\t\t\t\t  encoder->possible_crtcs);\n\tenc_resp->possible_clones = encoder->possible_clones;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}