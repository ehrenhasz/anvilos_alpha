{
  "module_name": "hibmc_drm_drv.c",
  "hash_id": "dea463e352f0853a7c34b59d34026e69463541460d943d2bfd4bfcfd3bb651df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/hisilicon/hibmc/hibmc_drm_drv.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_vram_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_module.h>\n#include <drm/drm_vblank.h>\n\n#include \"hibmc_drm_drv.h\"\n#include \"hibmc_drm_regs.h\"\n\nDEFINE_DRM_GEM_FOPS(hibmc_fops);\n\nstatic irqreturn_t hibmc_interrupt(int irq, void *arg)\n{\n\tstruct drm_device *dev = (struct drm_device *)arg;\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(dev);\n\tu32 status;\n\n\tstatus = readl(priv->mmio + HIBMC_RAW_INTERRUPT);\n\n\tif (status & HIBMC_RAW_INTERRUPT_VBLANK(1)) {\n\t\twritel(HIBMC_RAW_INTERRUPT_VBLANK(1),\n\t\t       priv->mmio + HIBMC_RAW_INTERRUPT);\n\t\tdrm_handle_vblank(dev, 0);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int hibmc_dumb_create(struct drm_file *file, struct drm_device *dev,\n\t\t\t     struct drm_mode_create_dumb *args)\n{\n\treturn drm_gem_vram_fill_create_dumb(file, dev, 0, 128, args);\n}\n\nstatic const struct drm_driver hibmc_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops\t\t\t= &hibmc_fops,\n\t.name\t\t\t= \"hibmc\",\n\t.date\t\t\t= \"20160828\",\n\t.desc\t\t\t= \"hibmc drm driver\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n\t.debugfs_init\t\t= drm_vram_mm_debugfs_init,\n\t.dumb_create            = hibmc_dumb_create,\n\t.dumb_map_offset        = drm_gem_ttm_dumb_map_offset,\n};\n\nstatic int __maybe_unused hibmc_pm_suspend(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_suspend(drm_dev);\n}\n\nstatic int  __maybe_unused hibmc_pm_resume(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_resume(drm_dev);\n}\n\nstatic const struct dev_pm_ops hibmc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(hibmc_pm_suspend,\n\t\t\t\thibmc_pm_resume)\n};\n\nstatic const struct drm_mode_config_funcs hibmc_mode_funcs = {\n\t.mode_valid = drm_vram_helper_mode_valid,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n\t.fb_create = drm_gem_fb_create,\n};\n\nstatic int hibmc_kms_init(struct hibmc_drm_private *priv)\n{\n\tstruct drm_device *dev = &priv->dev;\n\tint ret;\n\n\tret = drmm_mode_config_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tdev->mode_config.max_width = 1920;\n\tdev->mode_config.max_height = 1200;\n\n\tdev->mode_config.preferred_depth = 24;\n\tdev->mode_config.prefer_shadow = 1;\n\n\tdev->mode_config.funcs = (void *)&hibmc_mode_funcs;\n\n\tret = hibmc_de_init(priv);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to init de: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hibmc_vdac_init(priv);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to init vdac: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nvoid hibmc_set_power_mode(struct hibmc_drm_private *priv, u32 power_mode)\n{\n\tu32 control_value = 0;\n\tvoid __iomem   *mmio = priv->mmio;\n\tu32 input = 1;\n\n\tif (power_mode > HIBMC_PW_MODE_CTL_MODE_SLEEP)\n\t\treturn;\n\n\tif (power_mode == HIBMC_PW_MODE_CTL_MODE_SLEEP)\n\t\tinput = 0;\n\n\tcontrol_value = readl(mmio + HIBMC_POWER_MODE_CTRL);\n\tcontrol_value &= ~(HIBMC_PW_MODE_CTL_MODE_MASK |\n\t\t\t   HIBMC_PW_MODE_CTL_OSC_INPUT_MASK);\n\tcontrol_value |= HIBMC_FIELD(HIBMC_PW_MODE_CTL_MODE, power_mode);\n\tcontrol_value |= HIBMC_FIELD(HIBMC_PW_MODE_CTL_OSC_INPUT, input);\n\twritel(control_value, mmio + HIBMC_POWER_MODE_CTRL);\n}\n\nvoid hibmc_set_current_gate(struct hibmc_drm_private *priv, unsigned int gate)\n{\n\tu32 gate_reg;\n\tu32 mode;\n\tvoid __iomem   *mmio = priv->mmio;\n\n\t \n\tmode = (readl(mmio + HIBMC_POWER_MODE_CTRL) &\n\t\tHIBMC_PW_MODE_CTL_MODE_MASK) >> HIBMC_PW_MODE_CTL_MODE_SHIFT;\n\n\tswitch (mode) {\n\tcase HIBMC_PW_MODE_CTL_MODE_MODE0:\n\t\tgate_reg = HIBMC_MODE0_GATE;\n\t\tbreak;\n\n\tcase HIBMC_PW_MODE_CTL_MODE_MODE1:\n\t\tgate_reg = HIBMC_MODE1_GATE;\n\t\tbreak;\n\n\tdefault:\n\t\tgate_reg = HIBMC_MODE0_GATE;\n\t\tbreak;\n\t}\n\twritel(gate, mmio + gate_reg);\n}\n\nstatic void hibmc_hw_config(struct hibmc_drm_private *priv)\n{\n\tu32 reg;\n\n\t \n\thibmc_set_power_mode(priv, HIBMC_PW_MODE_CTL_MODE_MODE0);\n\n\t \n\treg = readl(priv->mmio + HIBMC_CURRENT_GATE);\n\treg &= ~HIBMC_CURR_GATE_DISPLAY_MASK;\n\treg &= ~HIBMC_CURR_GATE_LOCALMEM_MASK;\n\treg |= HIBMC_CURR_GATE_DISPLAY(1);\n\treg |= HIBMC_CURR_GATE_LOCALMEM(1);\n\n\thibmc_set_current_gate(priv, reg);\n\n\t \n\treg = readl(priv->mmio + HIBMC_MISC_CTRL);\n\treg &= ~HIBMC_MSCCTL_LOCALMEM_RESET_MASK;\n\treg |= HIBMC_MSCCTL_LOCALMEM_RESET(0);\n\twritel(reg, priv->mmio + HIBMC_MISC_CTRL);\n\n\treg &= ~HIBMC_MSCCTL_LOCALMEM_RESET_MASK;\n\treg |= HIBMC_MSCCTL_LOCALMEM_RESET(1);\n\n\twritel(reg, priv->mmio + HIBMC_MISC_CTRL);\n}\n\nstatic int hibmc_hw_map(struct hibmc_drm_private *priv)\n{\n\tstruct drm_device *dev = &priv->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tresource_size_t ioaddr, iosize;\n\n\tioaddr = pci_resource_start(pdev, 1);\n\tiosize = pci_resource_len(pdev, 1);\n\tpriv->mmio = devm_ioremap(dev->dev, ioaddr, iosize);\n\tif (!priv->mmio) {\n\t\tdrm_err(dev, \"Cannot map mmio region\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int hibmc_hw_init(struct hibmc_drm_private *priv)\n{\n\tint ret;\n\n\tret = hibmc_hw_map(priv);\n\tif (ret)\n\t\treturn ret;\n\n\thibmc_hw_config(priv);\n\n\treturn 0;\n}\n\nstatic int hibmc_unload(struct drm_device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tdrm_atomic_helper_shutdown(dev);\n\n\tfree_irq(pdev->irq, dev);\n\n\tpci_disable_msi(to_pci_dev(dev->dev));\n\n\treturn 0;\n}\n\nstatic int hibmc_load(struct drm_device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(dev);\n\tint ret;\n\n\tret = hibmc_hw_init(priv);\n\tif (ret)\n\t\tgoto err;\n\n\tret = drmm_vram_helper_init(dev, pci_resource_start(pdev, 0),\n\t\t\t\t    pci_resource_len(pdev, 0));\n\tif (ret) {\n\t\tdrm_err(dev, \"Error initializing VRAM MM; %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = hibmc_kms_init(priv);\n\tif (ret)\n\t\tgoto err;\n\n\tret = drm_vblank_init(dev, dev->mode_config.num_crtc);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to initialize vblank: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = pci_enable_msi(pdev);\n\tif (ret) {\n\t\tdrm_warn(dev, \"enabling MSI failed: %d\\n\", ret);\n\t} else {\n\t\t \n\t\tret = request_irq(pdev->irq, hibmc_interrupt, IRQF_SHARED,\n\t\t\t\t  dev->driver->name, dev);\n\t\tif (ret)\n\t\t\tdrm_warn(dev, \"install irq failed: %d\\n\", ret);\n\t}\n\n\t \n\tdrm_mode_config_reset(dev);\n\n\treturn 0;\n\nerr:\n\thibmc_unload(dev);\n\tdrm_err(dev, \"failed to initialize drm driver: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int hibmc_pci_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tstruct hibmc_drm_private *priv;\n\tstruct drm_device *dev;\n\tint ret;\n\n\tret = drm_aperture_remove_conflicting_pci_framebuffers(pdev, &hibmc_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv = devm_drm_dev_alloc(&pdev->dev, &hibmc_driver,\n\t\t\t\t  struct hibmc_drm_private, dev);\n\tif (IS_ERR(priv)) {\n\t\tDRM_ERROR(\"failed to allocate drm_device\\n\");\n\t\treturn PTR_ERR(priv);\n\t}\n\n\tdev = &priv->dev;\n\tpci_set_drvdata(pdev, dev);\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to enable pci device: %d\\n\", ret);\n\t\tgoto err_return;\n\t}\n\n\tret = hibmc_load(dev);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to load hibmc: %d\\n\", ret);\n\t\tgoto err_return;\n\t}\n\n\tret = drm_dev_register(dev, 0);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to register drv for userspace access: %d\\n\",\n\t\t\t  ret);\n\t\tgoto err_unload;\n\t}\n\n\tdrm_fbdev_generic_setup(dev, 32);\n\n\treturn 0;\n\nerr_unload:\n\thibmc_unload(dev);\nerr_return:\n\treturn ret;\n}\n\nstatic void hibmc_pci_remove(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\n\tdrm_dev_unregister(dev);\n\thibmc_unload(dev);\n}\n\nstatic const struct pci_device_id hibmc_pci_table[] = {\n\t{ PCI_VDEVICE(HUAWEI, 0x1711) },\n\t{0,}\n};\n\nstatic struct pci_driver hibmc_pci_driver = {\n\t.name =\t\t\"hibmc-drm\",\n\t.id_table =\thibmc_pci_table,\n\t.probe =\thibmc_pci_probe,\n\t.remove =\thibmc_pci_remove,\n\t.driver.pm =    &hibmc_pm_ops,\n};\n\ndrm_module_pci_driver(hibmc_pci_driver);\n\nMODULE_DEVICE_TABLE(pci, hibmc_pci_table);\nMODULE_AUTHOR(\"RongrongZou <zourongrong@huawei.com>\");\nMODULE_DESCRIPTION(\"DRM Driver for Hisilicon Hibmc\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}