{
  "module_name": "hibmc_drm_de.c",
  "hash_id": "2c9394ac17a9c429fd5d7986e4049b8288b06a27585801991d4fe19b1d918eab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/hisilicon/hibmc/hibmc_drm_de.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_vram_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"hibmc_drm_drv.h\"\n#include \"hibmc_drm_regs.h\"\n\nstruct hibmc_display_panel_pll {\n\tu64 M;\n\tu64 N;\n\tu64 OD;\n\tu64 POD;\n};\n\nstruct hibmc_dislay_pll_config {\n\tu64 hdisplay;\n\tu64 vdisplay;\n\tu32 pll1_config_value;\n\tu32 pll2_config_value;\n};\n\nstatic const struct hibmc_dislay_pll_config hibmc_pll_table[] = {\n\t{640, 480, CRT_PLL1_HS_25MHZ, CRT_PLL2_HS_25MHZ},\n\t{800, 600, CRT_PLL1_HS_40MHZ, CRT_PLL2_HS_40MHZ},\n\t{1024, 768, CRT_PLL1_HS_65MHZ, CRT_PLL2_HS_65MHZ},\n\t{1152, 864, CRT_PLL1_HS_80MHZ_1152, CRT_PLL2_HS_80MHZ},\n\t{1280, 768, CRT_PLL1_HS_80MHZ, CRT_PLL2_HS_80MHZ},\n\t{1280, 720, CRT_PLL1_HS_74MHZ, CRT_PLL2_HS_74MHZ},\n\t{1280, 960, CRT_PLL1_HS_108MHZ, CRT_PLL2_HS_108MHZ},\n\t{1280, 1024, CRT_PLL1_HS_108MHZ, CRT_PLL2_HS_108MHZ},\n\t{1440, 900, CRT_PLL1_HS_106MHZ, CRT_PLL2_HS_106MHZ},\n\t{1600, 900, CRT_PLL1_HS_108MHZ, CRT_PLL2_HS_108MHZ},\n\t{1600, 1200, CRT_PLL1_HS_162MHZ, CRT_PLL2_HS_162MHZ},\n\t{1920, 1080, CRT_PLL1_HS_148MHZ, CRT_PLL2_HS_148MHZ},\n\t{1920, 1200, CRT_PLL1_HS_193MHZ, CRT_PLL2_HS_193MHZ},\n};\n\nstatic int hibmc_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tu32 src_w = new_plane_state->src_w >> 16;\n\tu32 src_h = new_plane_state->src_h >> 16;\n\n\tif (!crtc || !fb)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\tif (src_w != new_plane_state->crtc_w || src_h != new_plane_state->crtc_h) {\n\t\tdrm_dbg_atomic(plane->dev, \"scale not support\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_plane_state->crtc_x < 0 || new_plane_state->crtc_y < 0) {\n\t\tdrm_dbg_atomic(plane->dev, \"crtc_x/y of drm_plane state is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!crtc_state->enable)\n\t\treturn 0;\n\n\tif (new_plane_state->crtc_x + new_plane_state->crtc_w >\n\t    crtc_state->adjusted_mode.hdisplay ||\n\t    new_plane_state->crtc_y + new_plane_state->crtc_h >\n\t    crtc_state->adjusted_mode.vdisplay) {\n\t\tdrm_dbg_atomic(plane->dev, \"visible portion of plane is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_plane_state->fb->pitches[0] % 128 != 0) {\n\t\tdrm_dbg_atomic(plane->dev, \"wrong stride with 128-byte aligned\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void hibmc_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tu32 reg;\n\ts64 gpu_addr = 0;\n\tu32 line_l;\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(plane->dev);\n\tstruct drm_gem_vram_object *gbo;\n\n\tif (!new_state->fb)\n\t\treturn;\n\n\tgbo = drm_gem_vram_of_gem(new_state->fb->obj[0]);\n\n\tgpu_addr = drm_gem_vram_offset(gbo);\n\tif (WARN_ON_ONCE(gpu_addr < 0))\n\t\treturn;  \n\n\twritel(gpu_addr, priv->mmio + HIBMC_CRT_FB_ADDRESS);\n\n\treg = new_state->fb->width * (new_state->fb->format->cpp[0]);\n\n\tline_l = new_state->fb->pitches[0];\n\twritel(HIBMC_FIELD(HIBMC_CRT_FB_WIDTH_WIDTH, reg) |\n\t       HIBMC_FIELD(HIBMC_CRT_FB_WIDTH_OFFS, line_l),\n\t       priv->mmio + HIBMC_CRT_FB_WIDTH);\n\n\t \n\treg = readl(priv->mmio + HIBMC_CRT_DISP_CTL);\n\treg &= ~HIBMC_CRT_DISP_CTL_FORMAT_MASK;\n\treg |= HIBMC_FIELD(HIBMC_CRT_DISP_CTL_FORMAT,\n\t\t\t   new_state->fb->format->cpp[0] * 8 / 16);\n\twritel(reg, priv->mmio + HIBMC_CRT_DISP_CTL);\n}\n\nstatic const u32 channel_formats1[] = {\n\tDRM_FORMAT_RGB565, DRM_FORMAT_BGR565, DRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGR888, DRM_FORMAT_XRGB8888, DRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGBA8888, DRM_FORMAT_BGRA8888, DRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888\n};\n\nstatic const struct drm_plane_funcs hibmc_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n};\n\nstatic const struct drm_plane_helper_funcs hibmc_plane_helper_funcs = {\n\tDRM_GEM_VRAM_PLANE_HELPER_FUNCS,\n\t.atomic_check = hibmc_plane_atomic_check,\n\t.atomic_update = hibmc_plane_atomic_update,\n};\n\nstatic void hibmc_crtc_dpms(struct drm_crtc *crtc, u32 dpms)\n{\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(crtc->dev);\n\tu32 reg;\n\n\treg = readl(priv->mmio + HIBMC_CRT_DISP_CTL);\n\treg &= ~HIBMC_CRT_DISP_CTL_DPMS_MASK;\n\treg |= HIBMC_FIELD(HIBMC_CRT_DISP_CTL_DPMS, dpms);\n\treg &= ~HIBMC_CRT_DISP_CTL_TIMING_MASK;\n\tif (dpms == HIBMC_CRT_DPMS_ON)\n\t\treg |= HIBMC_CRT_DISP_CTL_TIMING(1);\n\twritel(reg, priv->mmio + HIBMC_CRT_DISP_CTL);\n}\n\nstatic void hibmc_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tu32 reg;\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(crtc->dev);\n\n\thibmc_set_power_mode(priv, HIBMC_PW_MODE_CTL_MODE_MODE0);\n\n\t \n\treg = readl(priv->mmio + HIBMC_CURRENT_GATE);\n\treg &= ~HIBMC_CURR_GATE_LOCALMEM_MASK;\n\treg &= ~HIBMC_CURR_GATE_DISPLAY_MASK;\n\treg |= HIBMC_CURR_GATE_LOCALMEM(1);\n\treg |= HIBMC_CURR_GATE_DISPLAY(1);\n\thibmc_set_current_gate(priv, reg);\n\tdrm_crtc_vblank_on(crtc);\n\thibmc_crtc_dpms(crtc, HIBMC_CRT_DPMS_ON);\n}\n\nstatic void hibmc_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tu32 reg;\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(crtc->dev);\n\n\thibmc_crtc_dpms(crtc, HIBMC_CRT_DPMS_OFF);\n\tdrm_crtc_vblank_off(crtc);\n\n\thibmc_set_power_mode(priv, HIBMC_PW_MODE_CTL_MODE_SLEEP);\n\n\t \n\treg = readl(priv->mmio + HIBMC_CURRENT_GATE);\n\treg &= ~HIBMC_CURR_GATE_LOCALMEM_MASK;\n\treg &= ~HIBMC_CURR_GATE_DISPLAY_MASK;\n\treg |= HIBMC_CURR_GATE_LOCALMEM(0);\n\treg |= HIBMC_CURR_GATE_DISPLAY(0);\n\thibmc_set_current_gate(priv, reg);\n}\n\nstatic enum drm_mode_status\nhibmc_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t      const struct drm_display_mode *mode)\n{\n\tsize_t i = 0;\n\tint vrefresh = drm_mode_vrefresh(mode);\n\n\tif (vrefresh < 59 || vrefresh > 61)\n\t\treturn MODE_NOCLOCK;\n\n\tfor (i = 0; i < ARRAY_SIZE(hibmc_pll_table); i++) {\n\t\tif (hibmc_pll_table[i].hdisplay == mode->hdisplay &&\n\t\t    hibmc_pll_table[i].vdisplay == mode->vdisplay)\n\t\t\treturn MODE_OK;\n\t}\n\n\treturn MODE_BAD;\n}\n\nstatic u32 format_pll_reg(void)\n{\n\tu32 pllreg = 0;\n\tstruct hibmc_display_panel_pll pll = {0};\n\n\t \n\tpllreg |= HIBMC_FIELD(HIBMC_PLL_CTRL_BYPASS, 0);\n\tpllreg |= HIBMC_FIELD(HIBMC_PLL_CTRL_POWER, 1);\n\tpllreg |= HIBMC_FIELD(HIBMC_PLL_CTRL_INPUT, 0);\n\tpllreg |= HIBMC_FIELD(HIBMC_PLL_CTRL_POD, pll.POD);\n\tpllreg |= HIBMC_FIELD(HIBMC_PLL_CTRL_OD, pll.OD);\n\tpllreg |= HIBMC_FIELD(HIBMC_PLL_CTRL_N, pll.N);\n\tpllreg |= HIBMC_FIELD(HIBMC_PLL_CTRL_M, pll.M);\n\n\treturn pllreg;\n}\n\nstatic void set_vclock_hisilicon(struct drm_device *dev, u64 pll)\n{\n\tu32 val;\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(dev);\n\n\tval = readl(priv->mmio + CRT_PLL1_HS);\n\tval &= ~(CRT_PLL1_HS_OUTER_BYPASS(1));\n\twritel(val, priv->mmio + CRT_PLL1_HS);\n\n\tval = CRT_PLL1_HS_INTER_BYPASS(1) | CRT_PLL1_HS_POWERON(1);\n\twritel(val, priv->mmio + CRT_PLL1_HS);\n\n\twritel(pll, priv->mmio + CRT_PLL1_HS);\n\n\tusleep_range(1000, 2000);\n\n\tval = pll & ~(CRT_PLL1_HS_POWERON(1));\n\twritel(val, priv->mmio + CRT_PLL1_HS);\n\n\tusleep_range(1000, 2000);\n\n\tval &= ~(CRT_PLL1_HS_INTER_BYPASS(1));\n\twritel(val, priv->mmio + CRT_PLL1_HS);\n\n\tusleep_range(1000, 2000);\n\n\tval |= CRT_PLL1_HS_OUTER_BYPASS(1);\n\twritel(val, priv->mmio + CRT_PLL1_HS);\n}\n\nstatic void get_pll_config(u64 x, u64 y, u32 *pll1, u32 *pll2)\n{\n\tsize_t i;\n\tsize_t count = ARRAY_SIZE(hibmc_pll_table);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (hibmc_pll_table[i].hdisplay == x &&\n\t\t    hibmc_pll_table[i].vdisplay == y) {\n\t\t\t*pll1 = hibmc_pll_table[i].pll1_config_value;\n\t\t\t*pll2 = hibmc_pll_table[i].pll2_config_value;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\t*pll1 = CRT_PLL1_HS_25MHZ;\n\t*pll2 = CRT_PLL2_HS_25MHZ;\n}\n\n \nstatic u32 display_ctrl_adjust(struct drm_device *dev,\n\t\t\t       struct drm_display_mode *mode,\n\t\t\t       u32 ctrl)\n{\n\tu64 x, y;\n\tu32 pll1;  \n\tu32 pll2;  \n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(dev);\n\n\tx = mode->hdisplay;\n\ty = mode->vdisplay;\n\n\tget_pll_config(x, y, &pll1, &pll2);\n\twritel(pll2, priv->mmio + CRT_PLL2_HS);\n\tset_vclock_hisilicon(dev, pll1);\n\n\t \n\twritel(HIBMC_FIELD(HIBMC_CRT_AUTO_CENTERING_TL_TOP, 0) |\n\t       HIBMC_FIELD(HIBMC_CRT_AUTO_CENTERING_TL_LEFT, 0),\n\t       priv->mmio + HIBMC_CRT_AUTO_CENTERING_TL);\n\n\twritel(HIBMC_FIELD(HIBMC_CRT_AUTO_CENTERING_BR_BOTTOM, y - 1) |\n\t       HIBMC_FIELD(HIBMC_CRT_AUTO_CENTERING_BR_RIGHT, x - 1),\n\t       priv->mmio + HIBMC_CRT_AUTO_CENTERING_BR);\n\n\t \n\n\t \n\tctrl &= ~HIBMC_CRT_DISP_CTL_CRTSELECT_MASK;\n\tctrl &= ~HIBMC_CRT_DISP_CTL_CLOCK_PHASE_MASK;\n\n\tctrl |= HIBMC_CRT_DISP_CTL_CRTSELECT(HIBMC_CRTSELECT_CRT);\n\n\t \n\tctrl |= HIBMC_CRT_DISP_CTL_CLOCK_PHASE(0);\n\n\twritel(ctrl, priv->mmio + HIBMC_CRT_DISP_CTL);\n\n\treturn ctrl;\n}\n\nstatic void hibmc_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tu32 val;\n\tstruct drm_display_mode *mode = &crtc->state->mode;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(dev);\n\tu32 width = mode->hsync_end - mode->hsync_start;\n\tu32 height = mode->vsync_end - mode->vsync_start;\n\n\twritel(format_pll_reg(), priv->mmio + HIBMC_CRT_PLL_CTRL);\n\twritel(HIBMC_FIELD(HIBMC_CRT_HORZ_TOTAL_TOTAL, mode->htotal - 1) |\n\t       HIBMC_FIELD(HIBMC_CRT_HORZ_TOTAL_DISP_END, mode->hdisplay - 1),\n\t       priv->mmio + HIBMC_CRT_HORZ_TOTAL);\n\n\twritel(HIBMC_FIELD(HIBMC_CRT_HORZ_SYNC_WIDTH, width) |\n\t       HIBMC_FIELD(HIBMC_CRT_HORZ_SYNC_START, mode->hsync_start - 1),\n\t       priv->mmio + HIBMC_CRT_HORZ_SYNC);\n\n\twritel(HIBMC_FIELD(HIBMC_CRT_VERT_TOTAL_TOTAL, mode->vtotal - 1) |\n\t       HIBMC_FIELD(HIBMC_CRT_VERT_TOTAL_DISP_END, mode->vdisplay - 1),\n\t       priv->mmio + HIBMC_CRT_VERT_TOTAL);\n\n\twritel(HIBMC_FIELD(HIBMC_CRT_VERT_SYNC_HEIGHT, height) |\n\t       HIBMC_FIELD(HIBMC_CRT_VERT_SYNC_START, mode->vsync_start - 1),\n\t       priv->mmio + HIBMC_CRT_VERT_SYNC);\n\n\tval = HIBMC_FIELD(HIBMC_CRT_DISP_CTL_VSYNC_PHASE, 0);\n\tval |= HIBMC_FIELD(HIBMC_CRT_DISP_CTL_HSYNC_PHASE, 0);\n\tval |= HIBMC_CRT_DISP_CTL_TIMING(1);\n\tval |= HIBMC_CRT_DISP_CTL_PLANE(1);\n\n\tdisplay_ctrl_adjust(dev, mode, val);\n}\n\nstatic void hibmc_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tu32 reg;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(dev);\n\n\thibmc_set_power_mode(priv, HIBMC_PW_MODE_CTL_MODE_MODE0);\n\n\t \n\treg = readl(priv->mmio + HIBMC_CURRENT_GATE);\n\treg &= ~HIBMC_CURR_GATE_DISPLAY_MASK;\n\treg &= ~HIBMC_CURR_GATE_LOCALMEM_MASK;\n\treg |= HIBMC_CURR_GATE_DISPLAY(1);\n\treg |= HIBMC_CURR_GATE_LOCALMEM(1);\n\thibmc_set_current_gate(priv, reg);\n\n\t \n}\n\nstatic void hibmc_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\tif (crtc->state->event)\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\tcrtc->state->event = NULL;\n\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n}\n\nstatic int hibmc_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(crtc->dev);\n\n\twritel(HIBMC_RAW_INTERRUPT_EN_VBLANK(1),\n\t       priv->mmio + HIBMC_RAW_INTERRUPT_EN);\n\n\treturn 0;\n}\n\nstatic void hibmc_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(crtc->dev);\n\n\twritel(HIBMC_RAW_INTERRUPT_EN_VBLANK(0),\n\t       priv->mmio + HIBMC_RAW_INTERRUPT_EN);\n}\n\nstatic void hibmc_crtc_load_lut(struct drm_crtc *crtc)\n{\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(crtc->dev);\n\tvoid __iomem   *mmio = priv->mmio;\n\tu16 *r, *g, *b;\n\tu32 reg;\n\tu32 i;\n\n\tr = crtc->gamma_store;\n\tg = r + crtc->gamma_size;\n\tb = g + crtc->gamma_size;\n\n\tfor (i = 0; i < crtc->gamma_size; i++) {\n\t\tu32 offset = i << 2;\n\t\tu8 red = *r++ >> 8;\n\t\tu8 green = *g++ >> 8;\n\t\tu8 blue = *b++ >> 8;\n\t\tu32 rgb = (red << 16) | (green << 8) | blue;\n\n\t\twritel(rgb, mmio + HIBMC_CRT_PALETTE + offset);\n\t}\n\n\treg = readl(priv->mmio + HIBMC_CRT_DISP_CTL);\n\treg |= HIBMC_FIELD(HIBMC_CTL_DISP_CTL_GAMMA, 1);\n\twritel(reg, priv->mmio + HIBMC_CRT_DISP_CTL);\n}\n\nstatic int hibmc_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,\n\t\t\t\tu16 *blue, uint32_t size,\n\t\t\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\thibmc_crtc_load_lut(crtc);\n\n\treturn 0;\n}\n\nstatic const struct drm_crtc_funcs hibmc_crtc_funcs = {\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.set_config = drm_atomic_helper_set_config,\n\t.destroy = drm_crtc_cleanup,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state =  drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank = hibmc_crtc_enable_vblank,\n\t.disable_vblank = hibmc_crtc_disable_vblank,\n\t.gamma_set = hibmc_crtc_gamma_set,\n};\n\nstatic const struct drm_crtc_helper_funcs hibmc_crtc_helper_funcs = {\n\t.mode_set_nofb\t= hibmc_crtc_mode_set_nofb,\n\t.atomic_begin\t= hibmc_crtc_atomic_begin,\n\t.atomic_flush\t= hibmc_crtc_atomic_flush,\n\t.atomic_enable\t= hibmc_crtc_atomic_enable,\n\t.atomic_disable\t= hibmc_crtc_atomic_disable,\n\t.mode_valid = hibmc_crtc_mode_valid,\n};\n\nint hibmc_de_init(struct hibmc_drm_private *priv)\n{\n\tstruct drm_device *dev = &priv->dev;\n\tstruct drm_crtc *crtc = &priv->crtc;\n\tstruct drm_plane *plane = &priv->primary_plane;\n\tint ret;\n\n\tret = drm_universal_plane_init(dev, plane, 1, &hibmc_plane_funcs,\n\t\t\t\t       channel_formats1,\n\t\t\t\t       ARRAY_SIZE(channel_formats1),\n\t\t\t\t       NULL,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY,\n\t\t\t\t       NULL);\n\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to init plane: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_plane_helper_add(plane, &hibmc_plane_helper_funcs);\n\n\tret = drm_crtc_init_with_planes(dev, crtc, plane,\n\t\t\t\t\tNULL, &hibmc_crtc_funcs, NULL);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to init crtc: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = drm_mode_crtc_set_gamma_size(crtc, 256);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to set gamma size: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdrm_crtc_helper_add(crtc, &hibmc_crtc_helper_funcs);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}