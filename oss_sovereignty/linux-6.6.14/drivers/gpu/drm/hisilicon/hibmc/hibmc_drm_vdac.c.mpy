{
  "module_name": "hibmc_drm_vdac.c",
  "hash_id": "31237c3ab1729dcabf0f507d638396487d3e9ab29632114bdcc0a0fee9fb72ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/hisilicon/hibmc/hibmc_drm_vdac.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_print.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"hibmc_drm_drv.h\"\n#include \"hibmc_drm_regs.h\"\n\nstatic int hibmc_connector_get_modes(struct drm_connector *connector)\n{\n\tint count;\n\tvoid *edid;\n\tstruct hibmc_connector *hibmc_connector = to_hibmc_connector(connector);\n\n\tedid = drm_get_edid(connector, &hibmc_connector->adapter);\n\tif (edid) {\n\t\tdrm_connector_update_edid_property(connector, edid);\n\t\tcount = drm_add_edid_modes(connector, edid);\n\t\tif (count)\n\t\t\tgoto out;\n\t}\n\n\tcount = drm_add_modes_noedid(connector,\n\t\t\t\t     connector->dev->mode_config.max_width,\n\t\t\t\t     connector->dev->mode_config.max_height);\n\tdrm_set_preferred_mode(connector, 1024, 768);\n\nout:\n\tkfree(edid);\n\treturn count;\n}\n\nstatic void hibmc_connector_destroy(struct drm_connector *connector)\n{\n\tstruct hibmc_connector *hibmc_connector = to_hibmc_connector(connector);\n\n\ti2c_del_adapter(&hibmc_connector->adapter);\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_helper_funcs\n\thibmc_connector_helper_funcs = {\n\t.get_modes = hibmc_connector_get_modes,\n};\n\nstatic const struct drm_connector_funcs hibmc_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = hibmc_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic void hibmc_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t   struct drm_display_mode *mode,\n\t\t\t\t   struct drm_display_mode *adj_mode)\n{\n\tu32 reg;\n\tstruct drm_device *dev = encoder->dev;\n\tstruct hibmc_drm_private *priv = to_hibmc_drm_private(dev);\n\n\treg = readl(priv->mmio + HIBMC_DISPLAY_CONTROL_HISILE);\n\treg |= HIBMC_DISPLAY_CONTROL_FPVDDEN(1);\n\treg |= HIBMC_DISPLAY_CONTROL_PANELDATE(1);\n\treg |= HIBMC_DISPLAY_CONTROL_FPEN(1);\n\treg |= HIBMC_DISPLAY_CONTROL_VBIASEN(1);\n\twritel(reg, priv->mmio + HIBMC_DISPLAY_CONTROL_HISILE);\n}\n\nstatic const struct drm_encoder_helper_funcs hibmc_encoder_helper_funcs = {\n\t.mode_set = hibmc_encoder_mode_set,\n};\n\nint hibmc_vdac_init(struct hibmc_drm_private *priv)\n{\n\tstruct drm_device *dev = &priv->dev;\n\tstruct hibmc_connector *hibmc_connector = &priv->connector;\n\tstruct drm_encoder *encoder = &priv->encoder;\n\tstruct drm_crtc *crtc = &priv->crtc;\n\tstruct drm_connector *connector = &hibmc_connector->base;\n\tint ret;\n\n\tret = hibmc_ddc_create(dev, hibmc_connector);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to create ddc: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_DAC);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to init encoder: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_encoder_helper_add(encoder, &hibmc_encoder_helper_funcs);\n\n\tret = drm_connector_init_with_ddc(dev, connector,\n\t\t\t\t\t  &hibmc_connector_funcs,\n\t\t\t\t\t  DRM_MODE_CONNECTOR_VGA,\n\t\t\t\t\t  &hibmc_connector->adapter);\n\tif (ret) {\n\t\tdrm_err(dev, \"failed to init connector: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_connector_helper_add(connector, &hibmc_connector_helper_funcs);\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}