{
  "module_name": "dw_drm_dsi.c",
  "hash_id": "89419e076862a6dfa59a5c1b6397b934ab929c82342df6f4f883bead7b6cb5de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/hisilicon/kirin/dw_drm_dsi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/delay.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_device.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"dw_dsi_reg.h\"\n\n#define MAX_TX_ESC_CLK\t\t10\n#define ROUND(x, y)\t\t((x) / (y) + \\\n\t\t\t\t((x) % (y) * 10 / (y) >= 5 ? 1 : 0))\n#define PHY_REF_CLK_RATE\t19200000\n#define PHY_REF_CLK_PERIOD_PS\t(1000000000 / (PHY_REF_CLK_RATE / 1000))\n\n#define encoder_to_dsi(encoder) \\\n\tcontainer_of(encoder, struct dw_dsi, encoder)\n#define host_to_dsi(host) \\\n\tcontainer_of(host, struct dw_dsi, host)\n\nstruct mipi_phy_params {\n\tu32 clk_t_lpx;\n\tu32 clk_t_hs_prepare;\n\tu32 clk_t_hs_zero;\n\tu32 clk_t_hs_trial;\n\tu32 clk_t_wakeup;\n\tu32 data_t_lpx;\n\tu32 data_t_hs_prepare;\n\tu32 data_t_hs_zero;\n\tu32 data_t_hs_trial;\n\tu32 data_t_ta_go;\n\tu32 data_t_ta_get;\n\tu32 data_t_wakeup;\n\tu32 hstx_ckg_sel;\n\tu32 pll_fbd_div5f;\n\tu32 pll_fbd_div1f;\n\tu32 pll_fbd_2p;\n\tu32 pll_enbwt;\n\tu32 pll_fbd_p;\n\tu32 pll_fbd_s;\n\tu32 pll_pre_div1p;\n\tu32 pll_pre_p;\n\tu32 pll_vco_750M;\n\tu32 pll_lpf_rs;\n\tu32 pll_lpf_cs;\n\tu32 clklp2hs_time;\n\tu32 clkhs2lp_time;\n\tu32 lp2hs_time;\n\tu32 hs2lp_time;\n\tu32 clk_to_data_delay;\n\tu32 data_to_clk_delay;\n\tu32 lane_byte_clk_kHz;\n\tu32 clk_division;\n};\n\nstruct dsi_hw_ctx {\n\tvoid __iomem *base;\n\tstruct clk *pclk;\n};\n\nstruct dw_dsi {\n\tstruct drm_encoder encoder;\n\tstruct device *dev;\n\tstruct mipi_dsi_host host;\n\tstruct drm_display_mode cur_mode;\n\tstruct dsi_hw_ctx *ctx;\n\tstruct mipi_phy_params phy;\n\n\tu32 lanes;\n\tenum mipi_dsi_pixel_format format;\n\tunsigned long mode_flags;\n\tbool enable;\n};\n\nstruct dsi_data {\n\tstruct dw_dsi dsi;\n\tstruct dsi_hw_ctx ctx;\n};\n\nstruct dsi_phy_range {\n\tu32 min_range_kHz;\n\tu32 max_range_kHz;\n\tu32 pll_vco_750M;\n\tu32 hstx_ckg_sel;\n};\n\nstatic const struct dsi_phy_range dphy_range_info[] = {\n\t{   46875,    62500,   1,    7 },\n\t{   62500,    93750,   0,    7 },\n\t{   93750,   125000,   1,    6 },\n\t{  125000,   187500,   0,    6 },\n\t{  187500,   250000,   1,    5 },\n\t{  250000,   375000,   0,    5 },\n\t{  375000,   500000,   1,    4 },\n\t{  500000,   750000,   0,    4 },\n\t{  750000,  1000000,   1,    0 },\n\t{ 1000000,  1500000,   0,    0 }\n};\n\nstatic u32 dsi_calc_phy_rate(u32 req_kHz, struct mipi_phy_params *phy)\n{\n\tu32 ref_clk_ps = PHY_REF_CLK_PERIOD_PS;\n\tu32 tmp_kHz = req_kHz;\n\tu32 i = 0;\n\tu32 q_pll = 1;\n\tu32 m_pll = 0;\n\tu32 n_pll = 0;\n\tu32 r_pll = 1;\n\tu32 m_n = 0;\n\tu32 m_n_int = 0;\n\tu32 f_kHz = 0;\n\tu64 temp;\n\n\t \n\tdo {\n\t\tf_kHz = tmp_kHz;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(dphy_range_info); i++)\n\t\t\tif (f_kHz >= dphy_range_info[i].min_range_kHz &&\n\t\t\t    f_kHz <= dphy_range_info[i].max_range_kHz)\n\t\t\t\tbreak;\n\n\t\tif (i == ARRAY_SIZE(dphy_range_info)) {\n\t\t\tDRM_ERROR(\"%dkHz out of range\\n\", f_kHz);\n\t\t\treturn 0;\n\t\t}\n\n\t\tphy->pll_vco_750M = dphy_range_info[i].pll_vco_750M;\n\t\tphy->hstx_ckg_sel = dphy_range_info[i].hstx_ckg_sel;\n\n\t\tif (phy->hstx_ckg_sel <= 7 &&\n\t\t    phy->hstx_ckg_sel >= 4)\n\t\t\tq_pll = 0x10 >> (7 - phy->hstx_ckg_sel);\n\n\t\ttemp = f_kHz * (u64)q_pll * (u64)ref_clk_ps;\n\t\tm_n_int = temp / (u64)1000000000;\n\t\tm_n = (temp % (u64)1000000000) / (u64)100000000;\n\n\t\tif (m_n_int % 2 == 0) {\n\t\t\tif (m_n * 6 >= 50) {\n\t\t\t\tn_pll = 2;\n\t\t\t\tm_pll = (m_n_int + 1) * n_pll;\n\t\t\t} else if (m_n * 6 >= 30) {\n\t\t\t\tn_pll = 3;\n\t\t\t\tm_pll = m_n_int * n_pll + 2;\n\t\t\t} else {\n\t\t\t\tn_pll = 1;\n\t\t\t\tm_pll = m_n_int * n_pll;\n\t\t\t}\n\t\t} else {\n\t\t\tif (m_n * 6 >= 50) {\n\t\t\t\tn_pll = 1;\n\t\t\t\tm_pll = (m_n_int + 1) * n_pll;\n\t\t\t} else if (m_n * 6 >= 30) {\n\t\t\t\tn_pll = 1;\n\t\t\t\tm_pll = (m_n_int + 1) * n_pll;\n\t\t\t} else if (m_n * 6 >= 10) {\n\t\t\t\tn_pll = 3;\n\t\t\t\tm_pll = m_n_int * n_pll + 1;\n\t\t\t} else {\n\t\t\t\tn_pll = 2;\n\t\t\t\tm_pll = m_n_int * n_pll;\n\t\t\t}\n\t\t}\n\n\t\tif (n_pll == 1) {\n\t\t\tphy->pll_fbd_p = 0;\n\t\t\tphy->pll_pre_div1p = 1;\n\t\t} else {\n\t\t\tphy->pll_fbd_p = n_pll;\n\t\t\tphy->pll_pre_div1p = 0;\n\t\t}\n\n\t\tif (phy->pll_fbd_2p <= 7 && phy->pll_fbd_2p >= 4)\n\t\t\tr_pll = 0x10 >> (7 - phy->pll_fbd_2p);\n\n\t\tif (m_pll == 2) {\n\t\t\tphy->pll_pre_p = 0;\n\t\t\tphy->pll_fbd_s = 0;\n\t\t\tphy->pll_fbd_div1f = 0;\n\t\t\tphy->pll_fbd_div5f = 1;\n\t\t} else if (m_pll >= 2 * 2 * r_pll && m_pll <= 2 * 4 * r_pll) {\n\t\t\tphy->pll_pre_p = m_pll / (2 * r_pll);\n\t\t\tphy->pll_fbd_s = 0;\n\t\t\tphy->pll_fbd_div1f = 1;\n\t\t\tphy->pll_fbd_div5f = 0;\n\t\t} else if (m_pll >= 2 * 5 * r_pll && m_pll <= 2 * 150 * r_pll) {\n\t\t\tif (((m_pll / (2 * r_pll)) % 2) == 0) {\n\t\t\t\tphy->pll_pre_p =\n\t\t\t\t\t(m_pll / (2 * r_pll)) / 2 - 1;\n\t\t\t\tphy->pll_fbd_s =\n\t\t\t\t\t(m_pll / (2 * r_pll)) % 2 + 2;\n\t\t\t} else {\n\t\t\t\tphy->pll_pre_p =\n\t\t\t\t\t(m_pll / (2 * r_pll)) / 2;\n\t\t\t\tphy->pll_fbd_s =\n\t\t\t\t\t(m_pll / (2 * r_pll)) % 2;\n\t\t\t}\n\t\t\tphy->pll_fbd_div1f = 0;\n\t\t\tphy->pll_fbd_div5f = 0;\n\t\t} else {\n\t\t\tphy->pll_pre_p = 0;\n\t\t\tphy->pll_fbd_s = 0;\n\t\t\tphy->pll_fbd_div1f = 0;\n\t\t\tphy->pll_fbd_div5f = 1;\n\t\t}\n\n\t\tf_kHz = (u64)1000000000 * (u64)m_pll /\n\t\t\t((u64)ref_clk_ps * (u64)n_pll * (u64)q_pll);\n\n\t\tif (f_kHz >= req_kHz)\n\t\t\tbreak;\n\n\t\ttmp_kHz += 10;\n\n\t} while (true);\n\n\treturn f_kHz;\n}\n\nstatic void dsi_get_phy_params(u32 phy_req_kHz,\n\t\t\t       struct mipi_phy_params *phy)\n{\n\tu32 ref_clk_ps = PHY_REF_CLK_PERIOD_PS;\n\tu32 phy_rate_kHz;\n\tu32 ui;\n\n\tmemset(phy, 0, sizeof(*phy));\n\n\tphy_rate_kHz = dsi_calc_phy_rate(phy_req_kHz, phy);\n\tif (!phy_rate_kHz)\n\t\treturn;\n\n\tui = 1000000 / phy_rate_kHz;\n\n\tphy->clk_t_lpx = ROUND(50, 8 * ui);\n\tphy->clk_t_hs_prepare = ROUND(133, 16 * ui) - 1;\n\n\tphy->clk_t_hs_zero = ROUND(262, 8 * ui);\n\tphy->clk_t_hs_trial = 2 * (ROUND(60, 8 * ui) - 1);\n\tphy->clk_t_wakeup = ROUND(1000000, (ref_clk_ps / 1000) - 1);\n\tif (phy->clk_t_wakeup > 0xff)\n\t\tphy->clk_t_wakeup = 0xff;\n\tphy->data_t_wakeup = phy->clk_t_wakeup;\n\tphy->data_t_lpx = phy->clk_t_lpx;\n\tphy->data_t_hs_prepare = ROUND(125 + 10 * ui, 16 * ui) - 1;\n\tphy->data_t_hs_zero = ROUND(105 + 6 * ui, 8 * ui);\n\tphy->data_t_hs_trial = 2 * (ROUND(60 + 4 * ui, 8 * ui) - 1);\n\tphy->data_t_ta_go = 3;\n\tphy->data_t_ta_get = 4;\n\n\tphy->pll_enbwt = 1;\n\tphy->clklp2hs_time = ROUND(407, 8 * ui) + 12;\n\tphy->clkhs2lp_time = ROUND(105 + 12 * ui, 8 * ui);\n\tphy->lp2hs_time = ROUND(240 + 12 * ui, 8 * ui) + 1;\n\tphy->hs2lp_time = phy->clkhs2lp_time;\n\tphy->clk_to_data_delay = 1 + phy->clklp2hs_time;\n\tphy->data_to_clk_delay = ROUND(60 + 52 * ui, 8 * ui) +\n\t\t\t\tphy->clkhs2lp_time;\n\n\tphy->lane_byte_clk_kHz = phy_rate_kHz / 8;\n\tphy->clk_division =\n\t\tDIV_ROUND_UP(phy->lane_byte_clk_kHz, MAX_TX_ESC_CLK);\n}\n\nstatic u32 dsi_get_dpi_color_coding(enum mipi_dsi_pixel_format format)\n{\n\tu32 val;\n\n\t \n\tswitch (format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\tval = DSI_24BITS_1;\n\t\tbreak;\n\tdefault:\n\t\tval = DSI_24BITS_1;\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\n \nstatic void dsi_phy_tst_set(void __iomem *base, u32 reg, u32 val)\n{\n\tu32 reg_write = 0x10000 + reg;\n\n\t \n\twritel(reg_write, base + PHY_TST_CTRL1);\n\twritel(0x02, base + PHY_TST_CTRL0);\n\twritel(0x00, base + PHY_TST_CTRL0);\n\n\t \n\twritel(val, base + PHY_TST_CTRL1);\n\twritel(0x02, base + PHY_TST_CTRL0);\n\twritel(0x00, base + PHY_TST_CTRL0);\n}\n\nstatic void dsi_set_phy_timer(void __iomem *base,\n\t\t\t      struct mipi_phy_params *phy,\n\t\t\t      u32 lanes)\n{\n\tu32 val;\n\n\t \n\tval = (lanes - 1) | (PHY_STOP_WAIT_TIME << 8);\n\twritel(val, base + PHY_IF_CFG);\n\n\t \n\tval = readl(base + CLKMGR_CFG) | phy->clk_division;\n\twritel(val, base + CLKMGR_CFG);\n\n\t \n\tdw_update_bits(base + PHY_TMR_CFG, 24, MASK(8), phy->hs2lp_time);\n\tdw_update_bits(base + PHY_TMR_CFG, 16, MASK(8), phy->lp2hs_time);\n\tdw_update_bits(base + PHY_TMR_LPCLK_CFG, 16, MASK(10),\n\t\t       phy->clkhs2lp_time);\n\tdw_update_bits(base + PHY_TMR_LPCLK_CFG, 0, MASK(10),\n\t\t       phy->clklp2hs_time);\n\tdw_update_bits(base + CLK_DATA_TMR_CFG, 8, MASK(8),\n\t\t       phy->data_to_clk_delay);\n\tdw_update_bits(base + CLK_DATA_TMR_CFG, 0, MASK(8),\n\t\t       phy->clk_to_data_delay);\n}\n\nstatic void dsi_set_mipi_phy(void __iomem *base,\n\t\t\t     struct mipi_phy_params *phy,\n\t\t\t     u32 lanes)\n{\n\tu32 delay_count;\n\tu32 val;\n\tu32 i;\n\n\t \n\tdsi_set_phy_timer(base, phy, lanes);\n\n\t \n\twritel(0, base + PHY_RSTZ);\n\twritel(0, base + PHY_TST_CTRL0);\n\twritel(1, base + PHY_TST_CTRL0);\n\twritel(0, base + PHY_TST_CTRL0);\n\n\t \n\tdsi_phy_tst_set(base, CLK_TLPX, phy->clk_t_lpx);\n\tdsi_phy_tst_set(base, CLK_THS_PREPARE, phy->clk_t_hs_prepare);\n\tdsi_phy_tst_set(base, CLK_THS_ZERO, phy->clk_t_hs_zero);\n\tdsi_phy_tst_set(base, CLK_THS_TRAIL, phy->clk_t_hs_trial);\n\tdsi_phy_tst_set(base, CLK_TWAKEUP, phy->clk_t_wakeup);\n\n\t \n\tfor (i = 0; i < lanes; i++) {\n\t\tdsi_phy_tst_set(base, DATA_TLPX(i), phy->data_t_lpx);\n\t\tdsi_phy_tst_set(base, DATA_THS_PREPARE(i),\n\t\t\t\tphy->data_t_hs_prepare);\n\t\tdsi_phy_tst_set(base, DATA_THS_ZERO(i), phy->data_t_hs_zero);\n\t\tdsi_phy_tst_set(base, DATA_THS_TRAIL(i), phy->data_t_hs_trial);\n\t\tdsi_phy_tst_set(base, DATA_TTA_GO(i), phy->data_t_ta_go);\n\t\tdsi_phy_tst_set(base, DATA_TTA_GET(i), phy->data_t_ta_get);\n\t\tdsi_phy_tst_set(base, DATA_TWAKEUP(i), phy->data_t_wakeup);\n\t}\n\n\t \n\tdsi_phy_tst_set(base, PHY_CFG_I, phy->hstx_ckg_sel);\n\tval = (phy->pll_fbd_div5f << 5) + (phy->pll_fbd_div1f << 4) +\n\t\t\t\t(phy->pll_fbd_2p << 1) + phy->pll_enbwt;\n\tdsi_phy_tst_set(base, PHY_CFG_PLL_I, val);\n\tdsi_phy_tst_set(base, PHY_CFG_PLL_II, phy->pll_fbd_p);\n\tdsi_phy_tst_set(base, PHY_CFG_PLL_III, phy->pll_fbd_s);\n\tval = (phy->pll_pre_div1p << 7) + phy->pll_pre_p;\n\tdsi_phy_tst_set(base, PHY_CFG_PLL_IV, val);\n\tval = (5 << 5) + (phy->pll_vco_750M << 4) + (phy->pll_lpf_rs << 2) +\n\t\tphy->pll_lpf_cs;\n\tdsi_phy_tst_set(base, PHY_CFG_PLL_V, val);\n\n\twritel(PHY_ENABLECLK, base + PHY_RSTZ);\n\tudelay(1);\n\twritel(PHY_ENABLECLK | PHY_UNSHUTDOWNZ, base + PHY_RSTZ);\n\tudelay(1);\n\twritel(PHY_ENABLECLK | PHY_UNRSTZ | PHY_UNSHUTDOWNZ, base + PHY_RSTZ);\n\tusleep_range(1000, 1500);\n\n\t \n\tdelay_count = 100;\n\twhile (delay_count) {\n\t\tval = readl(base +  PHY_STATUS);\n\t\tif ((BIT(0) | BIT(2)) & val)\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t\tdelay_count--;\n\t}\n\n\tif (!delay_count)\n\t\tDRM_INFO(\"phylock and phystopstateclklane is not ready.\\n\");\n}\n\nstatic void dsi_set_mode_timing(void __iomem *base,\n\t\t\t\tu32 lane_byte_clk_kHz,\n\t\t\t\tstruct drm_display_mode *mode,\n\t\t\t\tenum mipi_dsi_pixel_format format)\n{\n\tu32 hfp, hbp, hsw, vfp, vbp, vsw;\n\tu32 hline_time;\n\tu32 hsa_time;\n\tu32 hbp_time;\n\tu32 pixel_clk_kHz;\n\tint htot, vtot;\n\tu32 val;\n\tu64 tmp;\n\n\tval = dsi_get_dpi_color_coding(format);\n\twritel(val, base + DPI_COLOR_CODING);\n\n\tval = (mode->flags & DRM_MODE_FLAG_NHSYNC ? 1 : 0) << 2;\n\tval |= (mode->flags & DRM_MODE_FLAG_NVSYNC ? 1 : 0) << 1;\n\twritel(val, base +  DPI_CFG_POL);\n\n\t \n\tpixel_clk_kHz = mode->clock;\n\thtot = mode->htotal;\n\tvtot = mode->vtotal;\n\thfp = mode->hsync_start - mode->hdisplay;\n\thbp = mode->htotal - mode->hsync_end;\n\thsw = mode->hsync_end - mode->hsync_start;\n\tvfp = mode->vsync_start - mode->vdisplay;\n\tvbp = mode->vtotal - mode->vsync_end;\n\tvsw = mode->vsync_end - mode->vsync_start;\n\tif (vsw > 15) {\n\t\tDRM_DEBUG_DRIVER(\"vsw exceeded 15\\n\");\n\t\tvsw = 15;\n\t}\n\n\thsa_time = (hsw * lane_byte_clk_kHz) / pixel_clk_kHz;\n\thbp_time = (hbp * lane_byte_clk_kHz) / pixel_clk_kHz;\n\ttmp = (u64)htot * (u64)lane_byte_clk_kHz;\n\thline_time = DIV_ROUND_UP(tmp, pixel_clk_kHz);\n\n\t \n\twritel(hsa_time, base + VID_HSA_TIME);\n\twritel(hbp_time, base + VID_HBP_TIME);\n\twritel(hline_time, base + VID_HLINE_TIME);\n\n\twritel(vsw, base + VID_VSA_LINES);\n\twritel(vbp, base + VID_VBP_LINES);\n\twritel(vfp, base + VID_VFP_LINES);\n\twritel(mode->vdisplay, base + VID_VACTIVE_LINES);\n\twritel(mode->hdisplay, base + VID_PKT_SIZE);\n\n\tDRM_DEBUG_DRIVER(\"htot=%d, hfp=%d, hbp=%d, hsw=%d\\n\",\n\t\t\t htot, hfp, hbp, hsw);\n\tDRM_DEBUG_DRIVER(\"vtol=%d, vfp=%d, vbp=%d, vsw=%d\\n\",\n\t\t\t vtot, vfp, vbp, vsw);\n\tDRM_DEBUG_DRIVER(\"hsa_time=%d, hbp_time=%d, hline_time=%d\\n\",\n\t\t\t hsa_time, hbp_time, hline_time);\n}\n\nstatic void dsi_set_video_mode(void __iomem *base, unsigned long flags)\n{\n\tu32 val;\n\tu32 mode_mask = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |\n\t\tMIPI_DSI_MODE_VIDEO_SYNC_PULSE;\n\tu32 non_burst_sync_pulse = MIPI_DSI_MODE_VIDEO |\n\t\tMIPI_DSI_MODE_VIDEO_SYNC_PULSE;\n\tu32 non_burst_sync_event = MIPI_DSI_MODE_VIDEO;\n\n\t \n\tif ((flags & mode_mask) == non_burst_sync_pulse)\n\t\tval = DSI_NON_BURST_SYNC_PULSES;\n\telse if ((flags & mode_mask) == non_burst_sync_event)\n\t\tval = DSI_NON_BURST_SYNC_EVENTS;\n\telse\n\t\tval = DSI_BURST_SYNC_PULSES_1;\n\twritel(val, base + VID_MODE_CFG);\n\n\twritel(PHY_TXREQUESTCLKHS, base + LPCLK_CTRL);\n\twritel(DSI_VIDEO_MODE, base + MODE_CFG);\n}\n\nstatic void dsi_mipi_init(struct dw_dsi *dsi)\n{\n\tstruct dsi_hw_ctx *ctx = dsi->ctx;\n\tstruct mipi_phy_params *phy = &dsi->phy;\n\tstruct drm_display_mode *mode = &dsi->cur_mode;\n\tu32 bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);\n\tvoid __iomem *base = ctx->base;\n\tu32 dphy_req_kHz;\n\n\t \n\tdphy_req_kHz = mode->clock * bpp / dsi->lanes;\n\tdsi_get_phy_params(dphy_req_kHz, phy);\n\n\t \n\twritel(RESET, base + PWR_UP);\n\n\t \n\tdsi_set_mipi_phy(base, phy, dsi->lanes);\n\n\t \n\tdsi_set_mode_timing(base, phy->lane_byte_clk_kHz, mode, dsi->format);\n\n\t \n\tdsi_set_video_mode(base, dsi->mode_flags);\n\n\t \n\twritel(POWERUP, base + PWR_UP);\n\n\tDRM_DEBUG_DRIVER(\"lanes=%d, pixel_clk=%d kHz, bytes_freq=%d kHz\\n\",\n\t\t\t dsi->lanes, mode->clock, phy->lane_byte_clk_kHz);\n}\n\nstatic void dsi_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct dw_dsi *dsi = encoder_to_dsi(encoder);\n\tstruct dsi_hw_ctx *ctx = dsi->ctx;\n\tvoid __iomem *base = ctx->base;\n\n\tif (!dsi->enable)\n\t\treturn;\n\n\twritel(0, base + PWR_UP);\n\twritel(0, base + LPCLK_CTRL);\n\twritel(0, base + PHY_RSTZ);\n\tclk_disable_unprepare(ctx->pclk);\n\n\tdsi->enable = false;\n}\n\nstatic void dsi_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct dw_dsi *dsi = encoder_to_dsi(encoder);\n\tstruct dsi_hw_ctx *ctx = dsi->ctx;\n\tint ret;\n\n\tif (dsi->enable)\n\t\treturn;\n\n\tret = clk_prepare_enable(ctx->pclk);\n\tif (ret) {\n\t\tDRM_ERROR(\"fail to enable pclk: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tdsi_mipi_init(dsi);\n\n\tdsi->enable = true;\n}\n\nstatic enum drm_mode_status dsi_encoder_phy_mode_valid(\n\t\t\t\t\tstruct drm_encoder *encoder,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct dw_dsi *dsi = encoder_to_dsi(encoder);\n\tstruct mipi_phy_params phy;\n\tu32 bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);\n\tu32 req_kHz, act_kHz, lane_byte_clk_kHz;\n\n\t \n\tmemset(&phy, 0, sizeof(phy));\n\treq_kHz = mode->clock * bpp / dsi->lanes;\n\tact_kHz = dsi_calc_phy_rate(req_kHz, &phy);\n\tlane_byte_clk_kHz = act_kHz / 8;\n\n\tDRM_DEBUG_DRIVER(\"Checking mode %ix%i-%i@%i clock: %i...\",\n\t\t\tmode->hdisplay, mode->vdisplay, bpp,\n\t\t\tdrm_mode_vrefresh(mode), mode->clock);\n\n\t \n\tif (mode->clock/dsi->lanes == lane_byte_clk_kHz/3) {\n\t\tDRM_DEBUG_DRIVER(\"OK!\\n\");\n\t\treturn MODE_OK;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"BAD!\\n\");\n\treturn MODE_BAD;\n}\n\nstatic enum drm_mode_status dsi_encoder_mode_valid(struct drm_encoder *encoder,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n\n{\n\tconst struct drm_crtc_helper_funcs *crtc_funcs = NULL;\n\tstruct drm_crtc *crtc = NULL;\n\tstruct drm_display_mode adj_mode;\n\tenum drm_mode_status ret;\n\n\t \n\tdrm_for_each_crtc(crtc, encoder->dev) {\n\t\t \n\t\tdrm_mode_init(&adj_mode, mode);\n\n\t\tcrtc_funcs = crtc->helper_private;\n\t\tif (crtc_funcs && crtc_funcs->mode_fixup)\n\t\t\tif (!crtc_funcs->mode_fixup(crtc, mode, &adj_mode))\n\t\t\t\treturn MODE_BAD;\n\n\t\tret = dsi_encoder_phy_mode_valid(encoder, &adj_mode);\n\t\tif (ret != MODE_OK)\n\t\t\treturn ret;\n\t}\n\treturn MODE_OK;\n}\n\nstatic void dsi_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t struct drm_display_mode *mode,\n\t\t\t\t struct drm_display_mode *adj_mode)\n{\n\tstruct dw_dsi *dsi = encoder_to_dsi(encoder);\n\n\tdrm_mode_copy(&dsi->cur_mode, adj_mode);\n}\n\nstatic int dsi_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t\t    struct drm_connector_state *conn_state)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct drm_encoder_helper_funcs dw_encoder_helper_funcs = {\n\t.atomic_check\t= dsi_encoder_atomic_check,\n\t.mode_valid\t= dsi_encoder_mode_valid,\n\t.mode_set\t= dsi_encoder_mode_set,\n\t.enable\t\t= dsi_encoder_enable,\n\t.disable\t= dsi_encoder_disable\n};\n\nstatic int dw_drm_encoder_init(struct device *dev,\n\t\t\t       struct drm_device *drm_dev,\n\t\t\t       struct drm_encoder *encoder)\n{\n\tint ret;\n\tu32 crtc_mask = drm_of_find_possible_crtcs(drm_dev, dev->of_node);\n\n\tif (!crtc_mask) {\n\t\tDRM_ERROR(\"failed to find crtc mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tencoder->possible_crtcs = crtc_mask;\n\tret = drm_simple_encoder_init(drm_dev, encoder, DRM_MODE_ENCODER_DSI);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to init dsi encoder\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_encoder_helper_add(encoder, &dw_encoder_helper_funcs);\n\n\treturn 0;\n}\n\nstatic const struct component_ops dsi_ops;\nstatic int dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t   struct mipi_dsi_device *mdsi)\n{\n\tstruct dw_dsi *dsi = host_to_dsi(host);\n\tstruct device *dev = host->dev;\n\tint ret;\n\n\tif (mdsi->lanes < 1 || mdsi->lanes > 4) {\n\t\tDRM_ERROR(\"dsi device params invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdsi->lanes = mdsi->lanes;\n\tdsi->format = mdsi->format;\n\tdsi->mode_flags = mdsi->mode_flags;\n\n\tret = component_add(dev, &dsi_ops);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t   struct mipi_dsi_device *mdsi)\n{\n\tstruct device *dev = host->dev;\n\n\tcomponent_del(dev, &dsi_ops);\n\n\treturn 0;\n}\n\nstatic const struct mipi_dsi_host_ops dsi_host_ops = {\n\t.attach = dsi_host_attach,\n\t.detach = dsi_host_detach,\n};\n\nstatic int dsi_host_init(struct device *dev, struct dw_dsi *dsi)\n{\n\tstruct mipi_dsi_host *host = &dsi->host;\n\tint ret;\n\n\thost->dev = dev;\n\thost->ops = &dsi_host_ops;\n\tret = mipi_dsi_host_register(host);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to register dsi host\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_bridge_init(struct drm_device *dev, struct dw_dsi *dsi)\n{\n\tstruct drm_encoder *encoder = &dsi->encoder;\n\tstruct drm_bridge *bridge;\n\tstruct device_node *np = dsi->dev->of_node;\n\tint ret;\n\n\t \n\tret = drm_of_find_panel_or_bridge(np, 1, 0, NULL, &bridge);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn drm_bridge_attach(encoder, bridge, NULL, 0);\n}\n\nstatic int dsi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct dsi_data *ddata = dev_get_drvdata(dev);\n\tstruct dw_dsi *dsi = &ddata->dsi;\n\tstruct drm_device *drm_dev = data;\n\tint ret;\n\n\tret = dw_drm_encoder_init(dev, drm_dev, &dsi->encoder);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dsi_bridge_init(drm_dev, dsi);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void dsi_unbind(struct device *dev, struct device *master, void *data)\n{\n\t \n}\n\nstatic const struct component_ops dsi_ops = {\n\t.bind\t= dsi_bind,\n\t.unbind\t= dsi_unbind,\n};\n\nstatic int dsi_parse_dt(struct platform_device *pdev, struct dw_dsi *dsi)\n{\n\tstruct dsi_hw_ctx *ctx = dsi->ctx;\n\tstruct resource *res;\n\n\tctx->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(ctx->pclk)) {\n\t\tDRM_ERROR(\"failed to get pclk clock\\n\");\n\t\treturn PTR_ERR(ctx->pclk);\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tctx->base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(ctx->base)) {\n\t\tDRM_ERROR(\"failed to remap dsi io region\\n\");\n\t\treturn PTR_ERR(ctx->base);\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_probe(struct platform_device *pdev)\n{\n\tstruct dsi_data *data;\n\tstruct dw_dsi *dsi;\n\tstruct dsi_hw_ctx *ctx;\n\tint ret;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tDRM_ERROR(\"failed to allocate dsi data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdsi = &data->dsi;\n\tctx = &data->ctx;\n\tdsi->ctx = ctx;\n\tdsi->dev = &pdev->dev;\n\n\tret = dsi_parse_dt(pdev, dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tret = dsi_host_init(&pdev->dev, dsi);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void dsi_remove(struct platform_device *pdev)\n{\n\tstruct dsi_data *data = platform_get_drvdata(pdev);\n\tstruct dw_dsi *dsi = &data->dsi;\n\n\tmipi_dsi_host_unregister(&dsi->host);\n}\n\nstatic const struct of_device_id dsi_of_match[] = {\n\t{.compatible = \"hisilicon,hi6220-dsi\"},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, dsi_of_match);\n\nstatic struct platform_driver dsi_driver = {\n\t.probe = dsi_probe,\n\t.remove_new = dsi_remove,\n\t.driver = {\n\t\t.name = \"dw-dsi\",\n\t\t.of_match_table = dsi_of_match,\n\t},\n};\n\nmodule_platform_driver(dsi_driver);\n\nMODULE_AUTHOR(\"Xinliang Liu <xinliang.liu@linaro.org>\");\nMODULE_AUTHOR(\"Xinliang Liu <z.liuxinliang@hisilicon.com>\");\nMODULE_AUTHOR(\"Xinwei Kong <kong.kongxinwei@hisilicon.com>\");\nMODULE_DESCRIPTION(\"DesignWare MIPI DSI Host Controller v1.02 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}