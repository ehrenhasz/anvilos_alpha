{
  "module_name": "kirin_drm_ade.c",
  "hash_id": "a1bc11ffc0c519b06c15091c63a50eafe5c28cc9f04c774944cf9740f1f47176",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/hisilicon/kirin/kirin_drm_ade.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <video/display_timing.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n\n#include \"kirin_drm_drv.h\"\n#include \"kirin_ade_reg.h\"\n\n#define OUT_OVLY\tADE_OVLY2  \n#define ADE_DEBUG\t1\n\n\nstruct ade_hw_ctx {\n\tvoid __iomem  *base;\n\tstruct regmap *noc_regmap;\n\tstruct clk *ade_core_clk;\n\tstruct clk *media_noc_clk;\n\tstruct clk *ade_pix_clk;\n\tstruct reset_control *reset;\n\tbool power_on;\n\tint irq;\n\n\tstruct drm_crtc *crtc;\n};\n\nstatic const struct kirin_format ade_formats[] = {\n\t \n\t{ DRM_FORMAT_RGB565, ADE_RGB_565 },\n\t{ DRM_FORMAT_BGR565, ADE_BGR_565 },\n\t \n\t{ DRM_FORMAT_RGB888, ADE_RGB_888 },\n\t{ DRM_FORMAT_BGR888, ADE_BGR_888 },\n\t \n\t{ DRM_FORMAT_XRGB8888, ADE_XRGB_8888 },\n\t{ DRM_FORMAT_XBGR8888, ADE_XBGR_8888 },\n\t{ DRM_FORMAT_RGBA8888, ADE_RGBA_8888 },\n\t{ DRM_FORMAT_BGRA8888, ADE_BGRA_8888 },\n\t{ DRM_FORMAT_ARGB8888, ADE_ARGB_8888 },\n\t{ DRM_FORMAT_ABGR8888, ADE_ABGR_8888 },\n};\n\nstatic const u32 channel_formats[] = {\n\t \n\tDRM_FORMAT_RGB565, DRM_FORMAT_BGR565, DRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGR888, DRM_FORMAT_XRGB8888, DRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGBA8888, DRM_FORMAT_BGRA8888, DRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888\n};\n\n \nstatic u32 ade_get_format(u32 pixel_format)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ade_formats); i++)\n\t\tif (ade_formats[i].pixel_format == pixel_format)\n\t\t\treturn ade_formats[i].hw_format;\n\n\t \n\tDRM_ERROR(\"Not found pixel format!!fourcc_format= %d\\n\",\n\t\t  pixel_format);\n\treturn ADE_FORMAT_UNSUPPORT;\n}\n\nstatic void ade_update_reload_bit(void __iomem *base, u32 bit_num, u32 val)\n{\n\tu32 bit_ofst, reg_num;\n\n\tbit_ofst = bit_num % 32;\n\treg_num = bit_num / 32;\n\n\tade_update_bits(base + ADE_RELOAD_DIS(reg_num), bit_ofst,\n\t\t\tMASK(1), !!val);\n}\n\nstatic u32 ade_read_reload_bit(void __iomem *base, u32 bit_num)\n{\n\tu32 tmp, bit_ofst, reg_num;\n\n\tbit_ofst = bit_num % 32;\n\treg_num = bit_num / 32;\n\n\ttmp = readl(base + ADE_RELOAD_DIS(reg_num));\n\treturn !!(BIT(bit_ofst) & tmp);\n}\n\nstatic void ade_init(struct ade_hw_ctx *ctx)\n{\n\tvoid __iomem *base = ctx->base;\n\n\t \n\tade_update_bits(base + ADE_CTRL1, AUTO_CLK_GATE_EN_OFST,\n\t\t\tAUTO_CLK_GATE_EN, ADE_ENABLE);\n\t \n\twritel(0, base + ADE_OVLY1_TRANS_CFG);\n\twritel(0, base + ADE_OVLY_CTL);\n\twritel(0, base + ADE_OVLYX_CTL(OUT_OVLY));\n\t \n\twritel(MASK(32), base + ADE_SOFT_RST_SEL(0));\n\twritel(MASK(32), base + ADE_SOFT_RST_SEL(1));\n\twritel(MASK(32), base + ADE_RELOAD_DIS(0));\n\twritel(MASK(32), base + ADE_RELOAD_DIS(1));\n\t \n\tade_update_bits(base + ADE_CTRL, FRM_END_START_OFST,\n\t\t\tFRM_END_START_MASK, REG_EFFECTIVE_IN_ADEEN_FRMEND);\n}\n\nstatic bool ade_crtc_mode_fixup(struct drm_crtc *crtc,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct kirin_crtc *kcrtc = to_kirin_crtc(crtc);\n\tstruct ade_hw_ctx *ctx = kcrtc->hw_ctx;\n\n\tadjusted_mode->clock =\n\t\tclk_round_rate(ctx->ade_pix_clk, mode->clock * 1000) / 1000;\n\treturn true;\n}\n\n\nstatic void ade_set_pix_clk(struct ade_hw_ctx *ctx,\n\t\t\t    struct drm_display_mode *mode,\n\t\t\t    struct drm_display_mode *adj_mode)\n{\n\tu32 clk_Hz = mode->clock * 1000;\n\tint ret;\n\n\t \n\tret = clk_set_rate(ctx->ade_pix_clk, clk_Hz);\n\tif (ret)\n\t\tDRM_ERROR(\"failed to set pixel clk %dHz (%d)\\n\", clk_Hz, ret);\n\tadj_mode->clock = clk_get_rate(ctx->ade_pix_clk) / 1000;\n}\n\nstatic void ade_ldi_set_mode(struct ade_hw_ctx *ctx,\n\t\t\t     struct drm_display_mode *mode,\n\t\t\t     struct drm_display_mode *adj_mode)\n{\n\tvoid __iomem *base = ctx->base;\n\tu32 width = mode->hdisplay;\n\tu32 height = mode->vdisplay;\n\tu32 hfp, hbp, hsw, vfp, vbp, vsw;\n\tu32 plr_flags;\n\n\tplr_flags = (mode->flags & DRM_MODE_FLAG_NVSYNC) ? FLAG_NVSYNC : 0;\n\tplr_flags |= (mode->flags & DRM_MODE_FLAG_NHSYNC) ? FLAG_NHSYNC : 0;\n\thfp = mode->hsync_start - mode->hdisplay;\n\thbp = mode->htotal - mode->hsync_end;\n\thsw = mode->hsync_end - mode->hsync_start;\n\tvfp = mode->vsync_start - mode->vdisplay;\n\tvbp = mode->vtotal - mode->vsync_end;\n\tvsw = mode->vsync_end - mode->vsync_start;\n\tif (vsw > 15) {\n\t\tDRM_DEBUG_DRIVER(\"vsw exceeded 15\\n\");\n\t\tvsw = 15;\n\t}\n\n\twritel((hbp << HBP_OFST) | hfp, base + LDI_HRZ_CTRL0);\n\t  \n\twritel(hsw - 1, base + LDI_HRZ_CTRL1);\n\twritel((vbp << VBP_OFST) | vfp, base + LDI_VRT_CTRL0);\n\t  \n\twritel(vsw - 1, base + LDI_VRT_CTRL1);\n\t  \n\twritel(((height - 1) << VSIZE_OFST) | (width - 1),\n\t       base + LDI_DSP_SIZE);\n\twritel(plr_flags, base + LDI_PLR_CTRL);\n\n\t \n\twritel(((width - 1) << OUTPUT_XSIZE_OFST) | (height - 1),\n\t       base + ADE_OVLY_OUTPUT_SIZE(OUT_OVLY));\n\n\t \n\twritel(CTRAN_BYPASS_ON, base + ADE_CTRAN_DIS(ADE_CTRAN6));\n\t  \n\twritel(width * height - 1, base + ADE_CTRAN_IMAGE_SIZE(ADE_CTRAN6));\n\tade_update_reload_bit(base, CTRAN_OFST + ADE_CTRAN6, 0);\n\n\tade_set_pix_clk(ctx, mode, adj_mode);\n\n\tDRM_DEBUG_DRIVER(\"set mode: %dx%d\\n\", width, height);\n}\n\nstatic int ade_power_up(struct ade_hw_ctx *ctx)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(ctx->media_noc_clk);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to enable media_noc_clk (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(ctx->reset);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to deassert reset\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(ctx->ade_core_clk);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to enable ade_core_clk (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tade_init(ctx);\n\tctx->power_on = true;\n\treturn 0;\n}\n\nstatic void ade_power_down(struct ade_hw_ctx *ctx)\n{\n\tvoid __iomem *base = ctx->base;\n\n\twritel(ADE_DISABLE, base + LDI_CTRL);\n\t \n\twritel(DSI_PCLK_OFF, base + LDI_HDMI_DSI_GT);\n\n\tclk_disable_unprepare(ctx->ade_core_clk);\n\treset_control_assert(ctx->reset);\n\tclk_disable_unprepare(ctx->media_noc_clk);\n\tctx->power_on = false;\n}\n\nstatic void ade_set_medianoc_qos(struct ade_hw_ctx *ctx)\n{\n\tstruct regmap *map = ctx->noc_regmap;\n\n\tregmap_update_bits(map, ADE0_QOSGENERATOR_MODE,\n\t\t\t   QOSGENERATOR_MODE_MASK, BYPASS_MODE);\n\tregmap_update_bits(map, ADE0_QOSGENERATOR_EXTCONTROL,\n\t\t\t   SOCKET_QOS_EN, SOCKET_QOS_EN);\n\n\tregmap_update_bits(map, ADE1_QOSGENERATOR_MODE,\n\t\t\t   QOSGENERATOR_MODE_MASK, BYPASS_MODE);\n\tregmap_update_bits(map, ADE1_QOSGENERATOR_EXTCONTROL,\n\t\t\t   SOCKET_QOS_EN, SOCKET_QOS_EN);\n}\n\nstatic int ade_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct kirin_crtc *kcrtc = to_kirin_crtc(crtc);\n\tstruct ade_hw_ctx *ctx = kcrtc->hw_ctx;\n\tvoid __iomem *base = ctx->base;\n\n\tif (!ctx->power_on)\n\t\t(void)ade_power_up(ctx);\n\n\tade_update_bits(base + LDI_INT_EN, FRAME_END_INT_EN_OFST,\n\t\t\tMASK(1), 1);\n\n\treturn 0;\n}\n\nstatic void ade_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct kirin_crtc *kcrtc = to_kirin_crtc(crtc);\n\tstruct ade_hw_ctx *ctx = kcrtc->hw_ctx;\n\tvoid __iomem *base = ctx->base;\n\n\tif (!ctx->power_on) {\n\t\tDRM_ERROR(\"power is down! vblank disable fail\\n\");\n\t\treturn;\n\t}\n\n\tade_update_bits(base + LDI_INT_EN, FRAME_END_INT_EN_OFST,\n\t\t\tMASK(1), 0);\n}\n\nstatic irqreturn_t ade_irq_handler(int irq, void *data)\n{\n\tstruct ade_hw_ctx *ctx = data;\n\tstruct drm_crtc *crtc = ctx->crtc;\n\tvoid __iomem *base = ctx->base;\n\tu32 status;\n\n\tstatus = readl(base + LDI_MSK_INT);\n\tDRM_DEBUG_VBL(\"LDI IRQ: status=0x%X\\n\", status);\n\n\t \n\tif (status & BIT(FRAME_END_INT_EN_OFST)) {\n\t\tade_update_bits(base + LDI_INT_CLR, FRAME_END_INT_EN_OFST,\n\t\t\t\tMASK(1), 1);\n\t\tdrm_crtc_handle_vblank(crtc);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ade_display_enable(struct ade_hw_ctx *ctx)\n{\n\tvoid __iomem *base = ctx->base;\n\tu32 out_fmt = LDI_OUT_RGB_888;\n\n\t \n\twritel(ADE_ENABLE, base + ADE_OVLYX_CTL(OUT_OVLY));\n\tade_update_reload_bit(base, OVLY_OFST + OUT_OVLY, 0);\n\n\t \n\twritel(DISP_SRC_OVLY2, base + ADE_DISP_SRC_CFG);\n\n\t \n\twritel(ADE_ENABLE, base + ADE_EN);\n\t \n\twritel(NORMAL_MODE, base + LDI_WORK_MODE);\n\twritel((out_fmt << BPP_OFST) | DATA_GATE_EN | LDI_EN,\n\t       base + LDI_CTRL);\n\t \n\twritel(DSI_PCLK_ON, base + LDI_HDMI_DSI_GT);\n}\n\n#if ADE_DEBUG\nstatic void ade_rdma_dump_regs(void __iomem *base, u32 ch)\n{\n\tu32 reg_ctrl, reg_addr, reg_size, reg_stride, reg_space, reg_en;\n\tu32 val;\n\n\treg_ctrl = RD_CH_CTRL(ch);\n\treg_addr = RD_CH_ADDR(ch);\n\treg_size = RD_CH_SIZE(ch);\n\treg_stride = RD_CH_STRIDE(ch);\n\treg_space = RD_CH_SPACE(ch);\n\treg_en = RD_CH_EN(ch);\n\n\tval = ade_read_reload_bit(base, RDMA_OFST + ch);\n\tDRM_DEBUG_DRIVER(\"[rdma%d]: reload(%d)\\n\", ch + 1, val);\n\tval = readl(base + reg_ctrl);\n\tDRM_DEBUG_DRIVER(\"[rdma%d]: reg_ctrl(0x%08x)\\n\", ch + 1, val);\n\tval = readl(base + reg_addr);\n\tDRM_DEBUG_DRIVER(\"[rdma%d]: reg_addr(0x%08x)\\n\", ch + 1, val);\n\tval = readl(base + reg_size);\n\tDRM_DEBUG_DRIVER(\"[rdma%d]: reg_size(0x%08x)\\n\", ch + 1, val);\n\tval = readl(base + reg_stride);\n\tDRM_DEBUG_DRIVER(\"[rdma%d]: reg_stride(0x%08x)\\n\", ch + 1, val);\n\tval = readl(base + reg_space);\n\tDRM_DEBUG_DRIVER(\"[rdma%d]: reg_space(0x%08x)\\n\", ch + 1, val);\n\tval = readl(base + reg_en);\n\tDRM_DEBUG_DRIVER(\"[rdma%d]: reg_en(0x%08x)\\n\", ch + 1, val);\n}\n\nstatic void ade_clip_dump_regs(void __iomem *base, u32 ch)\n{\n\tu32 val;\n\n\tval = ade_read_reload_bit(base, CLIP_OFST + ch);\n\tDRM_DEBUG_DRIVER(\"[clip%d]: reload(%d)\\n\", ch + 1, val);\n\tval = readl(base + ADE_CLIP_DISABLE(ch));\n\tDRM_DEBUG_DRIVER(\"[clip%d]: reg_clip_disable(0x%08x)\\n\", ch + 1, val);\n\tval = readl(base + ADE_CLIP_SIZE0(ch));\n\tDRM_DEBUG_DRIVER(\"[clip%d]: reg_clip_size0(0x%08x)\\n\", ch + 1, val);\n\tval = readl(base + ADE_CLIP_SIZE1(ch));\n\tDRM_DEBUG_DRIVER(\"[clip%d]: reg_clip_size1(0x%08x)\\n\", ch + 1, val);\n}\n\nstatic void ade_compositor_routing_dump_regs(void __iomem *base, u32 ch)\n{\n\tu8 ovly_ch = 0;  \n\tu32 val;\n\n\tval = readl(base + ADE_OVLY_CH_XY0(ovly_ch));\n\tDRM_DEBUG_DRIVER(\"[overlay ch%d]: reg_ch_xy0(0x%08x)\\n\", ovly_ch, val);\n\tval = readl(base + ADE_OVLY_CH_XY1(ovly_ch));\n\tDRM_DEBUG_DRIVER(\"[overlay ch%d]: reg_ch_xy1(0x%08x)\\n\", ovly_ch, val);\n\tval = readl(base + ADE_OVLY_CH_CTL(ovly_ch));\n\tDRM_DEBUG_DRIVER(\"[overlay ch%d]: reg_ch_ctl(0x%08x)\\n\", ovly_ch, val);\n}\n\nstatic void ade_dump_overlay_compositor_regs(void __iomem *base, u32 comp)\n{\n\tu32 val;\n\n\tval = ade_read_reload_bit(base, OVLY_OFST + comp);\n\tDRM_DEBUG_DRIVER(\"[overlay%d]: reload(%d)\\n\", comp + 1, val);\n\twritel(ADE_ENABLE, base + ADE_OVLYX_CTL(comp));\n\tDRM_DEBUG_DRIVER(\"[overlay%d]: reg_ctl(0x%08x)\\n\", comp + 1, val);\n\tval = readl(base + ADE_OVLY_CTL);\n\tDRM_DEBUG_DRIVER(\"ovly_ctl(0x%08x)\\n\", val);\n}\n\nstatic void ade_dump_regs(void __iomem *base)\n{\n\tu32 i;\n\n\t \n\tfor (i = 0; i < ADE_CH_NUM; i++) {\n\t\t \n\t\tade_rdma_dump_regs(base, i);\n\n\t\t \n\t\tade_clip_dump_regs(base, i);\n\n\t\t \n\t\tade_compositor_routing_dump_regs(base, i);\n\t}\n\n\t \n\tade_dump_overlay_compositor_regs(base, OUT_OVLY);\n}\n#else\nstatic void ade_dump_regs(void __iomem *base) { }\n#endif\n\nstatic void ade_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct kirin_crtc *kcrtc = to_kirin_crtc(crtc);\n\tstruct ade_hw_ctx *ctx = kcrtc->hw_ctx;\n\tint ret;\n\n\tif (kcrtc->enable)\n\t\treturn;\n\n\tif (!ctx->power_on) {\n\t\tret = ade_power_up(ctx);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tade_set_medianoc_qos(ctx);\n\tade_display_enable(ctx);\n\tade_dump_regs(ctx->base);\n\tdrm_crtc_vblank_on(crtc);\n\tkcrtc->enable = true;\n}\n\nstatic void ade_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct kirin_crtc *kcrtc = to_kirin_crtc(crtc);\n\tstruct ade_hw_ctx *ctx = kcrtc->hw_ctx;\n\n\tif (!kcrtc->enable)\n\t\treturn;\n\n\tdrm_crtc_vblank_off(crtc);\n\tade_power_down(ctx);\n\tkcrtc->enable = false;\n}\n\nstatic void ade_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct kirin_crtc *kcrtc = to_kirin_crtc(crtc);\n\tstruct ade_hw_ctx *ctx = kcrtc->hw_ctx;\n\tstruct drm_display_mode *mode = &crtc->state->mode;\n\tstruct drm_display_mode *adj_mode = &crtc->state->adjusted_mode;\n\n\tif (!ctx->power_on)\n\t\t(void)ade_power_up(ctx);\n\tade_ldi_set_mode(ctx, mode, adj_mode);\n}\n\nstatic void ade_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct kirin_crtc *kcrtc = to_kirin_crtc(crtc);\n\tstruct ade_hw_ctx *ctx = kcrtc->hw_ctx;\n\tstruct drm_display_mode *mode = &crtc->state->mode;\n\tstruct drm_display_mode *adj_mode = &crtc->state->adjusted_mode;\n\n\tif (!ctx->power_on)\n\t\t(void)ade_power_up(ctx);\n\tade_ldi_set_mode(ctx, mode, adj_mode);\n}\n\nstatic void ade_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n\n{\n\tstruct kirin_crtc *kcrtc = to_kirin_crtc(crtc);\n\tstruct ade_hw_ctx *ctx = kcrtc->hw_ctx;\n\tstruct drm_pending_vblank_event *event = crtc->state->event;\n\tvoid __iomem *base = ctx->base;\n\n\t \n\tif (kcrtc->enable) {\n\t\tade_dump_regs(base);\n\t\t \n\t\twritel(ADE_ENABLE, base + ADE_EN);\n\t}\n\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n}\n\nstatic const struct drm_crtc_helper_funcs ade_crtc_helper_funcs = {\n\t.mode_fixup\t= ade_crtc_mode_fixup,\n\t.mode_set_nofb\t= ade_crtc_mode_set_nofb,\n\t.atomic_begin\t= ade_crtc_atomic_begin,\n\t.atomic_flush\t= ade_crtc_atomic_flush,\n\t.atomic_enable\t= ade_crtc_atomic_enable,\n\t.atomic_disable\t= ade_crtc_atomic_disable,\n};\n\nstatic const struct drm_crtc_funcs ade_crtc_funcs = {\n\t.destroy\t= drm_crtc_cleanup,\n\t.set_config\t= drm_atomic_helper_set_config,\n\t.page_flip\t= drm_atomic_helper_page_flip,\n\t.reset\t\t= drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank\t= ade_crtc_enable_vblank,\n\t.disable_vblank\t= ade_crtc_disable_vblank,\n};\n\nstatic void ade_rdma_set(void __iomem *base, struct drm_framebuffer *fb,\n\t\t\t u32 ch, u32 y, u32 in_h, u32 fmt)\n{\n\tstruct drm_gem_dma_object *obj = drm_fb_dma_get_gem_obj(fb, 0);\n\tu32 reg_ctrl, reg_addr, reg_size, reg_stride, reg_space, reg_en;\n\tu32 stride = fb->pitches[0];\n\tu32 addr = (u32) obj->dma_addr + y * stride;\n\n\tDRM_DEBUG_DRIVER(\"rdma%d: (y=%d, height=%d), stride=%d, paddr=0x%x\\n\",\n\t\t\t ch + 1, y, in_h, stride, (u32) obj->dma_addr);\n\tDRM_DEBUG_DRIVER(\"addr=0x%x, fb:%dx%d, pixel_format=%d(%p4cc)\\n\",\n\t\t\t addr, fb->width, fb->height, fmt,\n\t\t\t &fb->format->format);\n\n\t \n\treg_ctrl = RD_CH_CTRL(ch);\n\treg_addr = RD_CH_ADDR(ch);\n\treg_size = RD_CH_SIZE(ch);\n\treg_stride = RD_CH_STRIDE(ch);\n\treg_space = RD_CH_SPACE(ch);\n\treg_en = RD_CH_EN(ch);\n\n\t \n\twritel((fmt << 16) & 0x1f0000, base + reg_ctrl);\n\twritel(addr, base + reg_addr);\n\twritel((in_h << 16) | stride, base + reg_size);\n\twritel(stride, base + reg_stride);\n\twritel(in_h * stride, base + reg_space);\n\twritel(ADE_ENABLE, base + reg_en);\n\tade_update_reload_bit(base, RDMA_OFST + ch, 0);\n}\n\nstatic void ade_rdma_disable(void __iomem *base, u32 ch)\n{\n\tu32 reg_en;\n\n\t \n\treg_en = RD_CH_EN(ch);\n\twritel(0, base + reg_en);\n\tade_update_reload_bit(base, RDMA_OFST + ch, 1);\n}\n\nstatic void ade_clip_set(void __iomem *base, u32 ch, u32 fb_w, u32 x,\n\t\t\t u32 in_w, u32 in_h)\n{\n\tu32 disable_val;\n\tu32 clip_left;\n\tu32 clip_right;\n\n\t \n\tif (fb_w == in_w) {  \n\t\tdisable_val = 1;\n\t\tclip_left = 0;\n\t\tclip_right = 0;\n\t} else {\n\t\tdisable_val = 0;\n\t\tclip_left = x;\n\t\tclip_right = fb_w - (x + in_w) - 1;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"clip%d: clip_left=%d, clip_right=%d\\n\",\n\t\t\t ch + 1, clip_left, clip_right);\n\n\twritel(disable_val, base + ADE_CLIP_DISABLE(ch));\n\twritel((fb_w - 1) << 16 | (in_h - 1), base + ADE_CLIP_SIZE0(ch));\n\twritel(clip_left << 16 | clip_right, base + ADE_CLIP_SIZE1(ch));\n\tade_update_reload_bit(base, CLIP_OFST + ch, 0);\n}\n\nstatic void ade_clip_disable(void __iomem *base, u32 ch)\n{\n\twritel(1, base + ADE_CLIP_DISABLE(ch));\n\tade_update_reload_bit(base, CLIP_OFST + ch, 1);\n}\n\nstatic bool has_Alpha_channel(int format)\n{\n\tswitch (format) {\n\tcase ADE_ARGB_8888:\n\tcase ADE_ABGR_8888:\n\tcase ADE_RGBA_8888:\n\tcase ADE_BGRA_8888:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void ade_get_blending_params(u32 fmt, u8 glb_alpha, u8 *alp_mode,\n\t\t\t\t    u8 *alp_sel, u8 *under_alp_sel)\n{\n\tbool has_alpha = has_Alpha_channel(fmt);\n\n\t \n\tif (has_alpha && glb_alpha < 255)\n\t\t*alp_mode = ADE_ALP_PIXEL_AND_GLB;\n\telse if (has_alpha)\n\t\t*alp_mode = ADE_ALP_PIXEL;\n\telse\n\t\t*alp_mode = ADE_ALP_GLOBAL;\n\n\t \n\t*alp_sel = ADE_ALP_MUL_COEFF_3;  \n\t*under_alp_sel = ADE_ALP_MUL_COEFF_2;  \n}\n\nstatic void ade_compositor_routing_set(void __iomem *base, u8 ch,\n\t\t\t\t       u32 x0, u32 y0,\n\t\t\t\t       u32 in_w, u32 in_h, u32 fmt)\n{\n\tu8 ovly_ch = 0;  \n\tu8 glb_alpha = 255;\n\tu32 x1 = x0 + in_w - 1;\n\tu32 y1 = y0 + in_h - 1;\n\tu32 val;\n\tu8 alp_sel;\n\tu8 under_alp_sel;\n\tu8 alp_mode;\n\n\tade_get_blending_params(fmt, glb_alpha, &alp_mode, &alp_sel,\n\t\t\t\t&under_alp_sel);\n\n\t \n\twritel(x0 << 16 | y0, base + ADE_OVLY_CH_XY0(ovly_ch));\n\twritel(x1 << 16 | y1, base + ADE_OVLY_CH_XY1(ovly_ch));\n\tval = (ch + 1) << CH_SEL_OFST | BIT(CH_EN_OFST) |\n\t\talp_sel << CH_ALP_SEL_OFST |\n\t\tunder_alp_sel << CH_UNDER_ALP_SEL_OFST |\n\t\tglb_alpha << CH_ALP_GBL_OFST |\n\t\talp_mode << CH_ALP_MODE_OFST;\n\twritel(val, base + ADE_OVLY_CH_CTL(ovly_ch));\n\t \n\tade_update_bits(base + ADE_OVLY_CTL, CH_OVLY_SEL_OFST(ovly_ch),\n\t\t\tCH_OVLY_SEL_MASK, CH_OVLY_SEL_VAL(OUT_OVLY));\n}\n\nstatic void ade_compositor_routing_disable(void __iomem *base, u32 ch)\n{\n\tu8 ovly_ch = 0;  \n\n\t \n\tade_update_bits(base + ADE_OVLY_CH_CTL(ovly_ch), CH_EN_OFST,\n\t\t\tMASK(1), 0);\n\t \n\tade_update_bits(base + ADE_OVLY_CTL, CH_OVLY_SEL_OFST(ovly_ch),\n\t\t\tCH_OVLY_SEL_MASK, 0);\n}\n\n \nstatic void ade_update_channel(struct kirin_plane *kplane,\n\t\t\t       struct drm_framebuffer *fb, int crtc_x,\n\t\t\t       int crtc_y, unsigned int crtc_w,\n\t\t\t       unsigned int crtc_h, u32 src_x,\n\t\t\t       u32 src_y, u32 src_w, u32 src_h)\n{\n\tstruct ade_hw_ctx *ctx = kplane->hw_ctx;\n\tvoid __iomem *base = ctx->base;\n\tu32 fmt = ade_get_format(fb->format->format);\n\tu32 ch = kplane->ch;\n\tu32 in_w;\n\tu32 in_h;\n\n\tDRM_DEBUG_DRIVER(\"channel%d: src:(%d, %d)-%dx%d, crtc:(%d, %d)-%dx%d\",\n\t\t\t ch + 1, src_x, src_y, src_w, src_h,\n\t\t\t crtc_x, crtc_y, crtc_w, crtc_h);\n\n\t \n\tin_w = src_w;\n\tin_h = src_h;\n\tade_rdma_set(base, fb, ch, src_y, in_h, fmt);\n\n\t \n\tade_clip_set(base, ch, fb->width, src_x, in_w, in_h);\n\n\t \n\n\t \n\n\t \n\tade_compositor_routing_set(base, ch, crtc_x, crtc_y, in_w, in_h, fmt);\n}\n\nstatic void ade_disable_channel(struct kirin_plane *kplane)\n{\n\tstruct ade_hw_ctx *ctx = kplane->hw_ctx;\n\tvoid __iomem *base = ctx->base;\n\tu32 ch = kplane->ch;\n\n\tDRM_DEBUG_DRIVER(\"disable channel%d\\n\", ch + 1);\n\n\t \n\tade_rdma_disable(base, ch);\n\n\t \n\tade_clip_disable(base, ch);\n\n\t \n\tade_compositor_routing_disable(base, ch);\n}\n\nstatic int ade_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tu32 src_x = new_plane_state->src_x >> 16;\n\tu32 src_y = new_plane_state->src_y >> 16;\n\tu32 src_w = new_plane_state->src_w >> 16;\n\tu32 src_h = new_plane_state->src_h >> 16;\n\tint crtc_x = new_plane_state->crtc_x;\n\tint crtc_y = new_plane_state->crtc_y;\n\tu32 crtc_w = new_plane_state->crtc_w;\n\tu32 crtc_h = new_plane_state->crtc_h;\n\tu32 fmt;\n\n\tif (!crtc || !fb)\n\t\treturn 0;\n\n\tfmt = ade_get_format(fb->format->format);\n\tif (fmt == ADE_FORMAT_UNSUPPORT)\n\t\treturn -EINVAL;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\tif (src_w != crtc_w || src_h != crtc_h) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (src_x + src_w > fb->width ||\n\t    src_y + src_h > fb->height)\n\t\treturn -EINVAL;\n\n\tif (crtc_x < 0 || crtc_y < 0)\n\t\treturn -EINVAL;\n\n\tif (crtc_x + crtc_w > crtc_state->adjusted_mode.hdisplay ||\n\t    crtc_y + crtc_h > crtc_state->adjusted_mode.vdisplay)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void ade_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct kirin_plane *kplane = to_kirin_plane(plane);\n\n\tade_update_channel(kplane, new_state->fb, new_state->crtc_x,\n\t\t\t   new_state->crtc_y,\n\t\t\t   new_state->crtc_w, new_state->crtc_h,\n\t\t\t   new_state->src_x >> 16, new_state->src_y >> 16,\n\t\t\t   new_state->src_w >> 16, new_state->src_h >> 16);\n}\n\nstatic void ade_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct kirin_plane *kplane = to_kirin_plane(plane);\n\n\tade_disable_channel(kplane);\n}\n\nstatic const struct drm_plane_helper_funcs ade_plane_helper_funcs = {\n\t.atomic_check = ade_plane_atomic_check,\n\t.atomic_update = ade_plane_atomic_update,\n\t.atomic_disable = ade_plane_atomic_disable,\n};\n\nstatic struct drm_plane_funcs ade_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n};\n\nstatic void *ade_hw_ctx_alloc(struct platform_device *pdev,\n\t\t\t      struct drm_crtc *crtc)\n{\n\tstruct resource *res;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct ade_hw_ctx *ctx = NULL;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tDRM_ERROR(\"failed to alloc ade_hw_ctx\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tctx->base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(ctx->base)) {\n\t\tDRM_ERROR(\"failed to remap ade io base\\n\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tctx->reset = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(ctx->reset))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tctx->noc_regmap =\n\t\tsyscon_regmap_lookup_by_phandle(np, \"hisilicon,noc-syscon\");\n\tif (IS_ERR(ctx->noc_regmap)) {\n\t\tDRM_ERROR(\"failed to get noc regmap\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tctx->irq = platform_get_irq(pdev, 0);\n\tif (ctx->irq < 0) {\n\t\tDRM_ERROR(\"failed to get irq\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tctx->ade_core_clk = devm_clk_get(dev, \"clk_ade_core\");\n\tif (IS_ERR(ctx->ade_core_clk)) {\n\t\tDRM_ERROR(\"failed to parse clk ADE_CORE\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tctx->media_noc_clk = devm_clk_get(dev, \"clk_codec_jpeg\");\n\tif (IS_ERR(ctx->media_noc_clk)) {\n\t\tDRM_ERROR(\"failed to parse clk CODEC_JPEG\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tctx->ade_pix_clk = devm_clk_get(dev, \"clk_ade_pix\");\n\tif (IS_ERR(ctx->ade_pix_clk)) {\n\t\tDRM_ERROR(\"failed to parse clk ADE_PIX\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\t \n\tret = devm_request_irq(dev, ctx->irq, ade_irq_handler,\n\t\t\t       IRQF_SHARED, dev->driver->name, ctx);\n\tif (ret)\n\t\treturn ERR_PTR(-EIO);\n\n\tctx->crtc = crtc;\n\n\treturn ctx;\n}\n\nstatic void ade_hw_ctx_cleanup(void *hw_ctx)\n{\n}\n\nstatic const struct drm_mode_config_funcs ade_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n\n};\n\nDEFINE_DRM_GEM_DMA_FOPS(ade_fops);\n\nstatic const struct drm_driver ade_driver = {\n\t.driver_features = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.fops = &ade_fops,\n\tDRM_GEM_DMA_DRIVER_OPS,\n\t.name = \"kirin\",\n\t.desc = \"Hisilicon Kirin620 SoC DRM Driver\",\n\t.date = \"20150718\",\n\t.major = 1,\n\t.minor = 0,\n};\n\nstruct kirin_drm_data ade_driver_data = {\n\t.num_planes = ADE_CH_NUM,\n\t.prim_plane = ADE_CH1,\n\t.channel_formats = channel_formats,\n\t.channel_formats_cnt = ARRAY_SIZE(channel_formats),\n\t.config_max_width = 2048,\n\t.config_max_height = 2048,\n\t.driver = &ade_driver,\n\t.crtc_helper_funcs = &ade_crtc_helper_funcs,\n\t.crtc_funcs = &ade_crtc_funcs,\n\t.plane_helper_funcs = &ade_plane_helper_funcs,\n\t.plane_funcs = &ade_plane_funcs,\n\t.mode_config_funcs = &ade_mode_config_funcs,\n\n\t.alloc_hw_ctx = ade_hw_ctx_alloc,\n\t.cleanup_hw_ctx = ade_hw_ctx_cleanup,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}