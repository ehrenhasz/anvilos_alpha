{
  "module_name": "kirin_drm_drv.c",
  "hash_id": "d9f783581dbf62fc35ee0aa79f9fec96ab8a9231ca97e5b844742415f0ce8c25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/hisilicon/kirin/kirin_drm_drv.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"kirin_drm_drv.h\"\n\n#define KIRIN_MAX_PLANE\t2\n\nstruct kirin_drm_private {\n\tstruct kirin_crtc crtc;\n\tstruct kirin_plane planes[KIRIN_MAX_PLANE];\n\tvoid *hw_ctx;\n};\n\nstatic int kirin_drm_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,\n\t\t\t       struct drm_plane *plane,\n\t\t\t       const struct kirin_drm_data *driver_data)\n{\n\tstruct device_node *port;\n\tint ret;\n\n\t \n\tport = of_get_child_by_name(dev->dev->of_node, \"port\");\n\tif (!port) {\n\t\tDRM_ERROR(\"no port node found in %pOF\\n\", dev->dev->of_node);\n\t\treturn -EINVAL;\n\t}\n\tof_node_put(port);\n\tcrtc->port = port;\n\n\tret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,\n\t\t\t\t\tdriver_data->crtc_funcs, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to init crtc.\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_helper_add(crtc, driver_data->crtc_helper_funcs);\n\n\treturn 0;\n}\n\nstatic int kirin_drm_plane_init(struct drm_device *dev, struct drm_plane *plane,\n\t\t\t\tenum drm_plane_type type,\n\t\t\t\tconst struct kirin_drm_data *data)\n{\n\tint ret = 0;\n\n\tret = drm_universal_plane_init(dev, plane, 1, data->plane_funcs,\n\t\t\t\t       data->channel_formats,\n\t\t\t\t       data->channel_formats_cnt,\n\t\t\t\t       NULL, type, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"fail to init plane, ch=%d\\n\", 0);\n\t\treturn ret;\n\t}\n\n\tdrm_plane_helper_add(plane, data->plane_helper_funcs);\n\n\treturn 0;\n}\n\nstatic void kirin_drm_private_cleanup(struct drm_device *dev)\n{\n\tstruct kirin_drm_private *kirin_priv = dev->dev_private;\n\tstruct kirin_drm_data *data;\n\n\tdata = (struct kirin_drm_data *)of_device_get_match_data(dev->dev);\n\tif (data->cleanup_hw_ctx)\n\t\tdata->cleanup_hw_ctx(kirin_priv->hw_ctx);\n\n\tdevm_kfree(dev->dev, kirin_priv);\n\tdev->dev_private = NULL;\n}\n\nstatic int kirin_drm_private_init(struct drm_device *dev,\n\t\t\t\t  const struct kirin_drm_data *driver_data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev->dev);\n\tstruct kirin_drm_private *kirin_priv;\n\tstruct drm_plane *prim_plane;\n\tenum drm_plane_type type;\n\tvoid *ctx;\n\tint ret;\n\tu32 ch;\n\n\tkirin_priv = devm_kzalloc(dev->dev, sizeof(*kirin_priv), GFP_KERNEL);\n\tif (!kirin_priv) {\n\t\tDRM_ERROR(\"failed to alloc kirin_drm_private\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tctx = driver_data->alloc_hw_ctx(pdev, &kirin_priv->crtc.base);\n\tif (IS_ERR(ctx)) {\n\t\tDRM_ERROR(\"failed to initialize kirin_priv hw ctx\\n\");\n\t\treturn -EINVAL;\n\t}\n\tkirin_priv->hw_ctx = ctx;\n\n\t \n\tfor (ch = 0; ch < driver_data->num_planes; ch++) {\n\t\tif (ch == driver_data->prim_plane)\n\t\t\ttype = DRM_PLANE_TYPE_PRIMARY;\n\t\telse\n\t\t\ttype = DRM_PLANE_TYPE_OVERLAY;\n\t\tret = kirin_drm_plane_init(dev, &kirin_priv->planes[ch].base,\n\t\t\t\t\t   type, driver_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tkirin_priv->planes[ch].ch = ch;\n\t\tkirin_priv->planes[ch].hw_ctx = ctx;\n\t}\n\n\t \n\tprim_plane = &kirin_priv->planes[driver_data->prim_plane].base;\n\tret = kirin_drm_crtc_init(dev, &kirin_priv->crtc.base,\n\t\t\t\t  prim_plane, driver_data);\n\tif (ret)\n\t\treturn ret;\n\tkirin_priv->crtc.hw_ctx = ctx;\n\tdev->dev_private = kirin_priv;\n\n\treturn 0;\n}\n\nstatic int kirin_drm_kms_init(struct drm_device *dev,\n\t\t\t      const struct kirin_drm_data *driver_data)\n{\n\tint ret;\n\n\t \n\tdrm_mode_config_init(dev);\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tdev->mode_config.max_width = driver_data->config_max_width;\n\tdev->mode_config.max_height = driver_data->config_max_width;\n\tdev->mode_config.funcs = driver_data->mode_config_funcs;\n\n\t \n\tret = kirin_drm_private_init(dev, driver_data);\n\tif (ret)\n\t\tgoto err_mode_config_cleanup;\n\n\t \n\tret = component_bind_all(dev->dev, dev);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to bind all component.\\n\");\n\t\tgoto err_private_cleanup;\n\t}\n\n\t \n\tret = drm_vblank_init(dev, dev->mode_config.num_crtc);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to initialize vblank.\\n\");\n\t\tgoto err_unbind_all;\n\t}\n\n\t \n\tdrm_mode_config_reset(dev);\n\n\t \n\tdrm_kms_helper_poll_init(dev);\n\n\treturn 0;\n\nerr_unbind_all:\n\tcomponent_unbind_all(dev->dev, dev);\nerr_private_cleanup:\n\tkirin_drm_private_cleanup(dev);\nerr_mode_config_cleanup:\n\tdrm_mode_config_cleanup(dev);\n\treturn ret;\n}\n\nstatic int kirin_drm_kms_cleanup(struct drm_device *dev)\n{\n\tdrm_kms_helper_poll_fini(dev);\n\tkirin_drm_private_cleanup(dev);\n\tdrm_mode_config_cleanup(dev);\n\n\treturn 0;\n}\n\nstatic int kirin_drm_bind(struct device *dev)\n{\n\tstruct kirin_drm_data *driver_data;\n\tstruct drm_device *drm_dev;\n\tint ret;\n\n\tdriver_data = (struct kirin_drm_data *)of_device_get_match_data(dev);\n\tif (!driver_data)\n\t\treturn -EINVAL;\n\n\tdrm_dev = drm_dev_alloc(driver_data->driver, dev);\n\tif (IS_ERR(drm_dev))\n\t\treturn PTR_ERR(drm_dev);\n\tdev_set_drvdata(dev, drm_dev);\n\n\t \n\tret = kirin_drm_kms_init(drm_dev, driver_data);\n\tif (ret)\n\t\tgoto err_drm_dev_put;\n\n\tret = drm_dev_register(drm_dev, 0);\n\tif (ret)\n\t\tgoto err_kms_cleanup;\n\n\tdrm_fbdev_generic_setup(drm_dev, 32);\n\n\treturn 0;\n\nerr_kms_cleanup:\n\tkirin_drm_kms_cleanup(drm_dev);\nerr_drm_dev_put:\n\tdrm_dev_put(drm_dev);\n\n\treturn ret;\n}\n\nstatic void kirin_drm_unbind(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\tdrm_dev_unregister(drm_dev);\n\tkirin_drm_kms_cleanup(drm_dev);\n\tdrm_dev_put(drm_dev);\n}\n\nstatic const struct component_master_ops kirin_drm_ops = {\n\t.bind = kirin_drm_bind,\n\t.unbind = kirin_drm_unbind,\n};\n\nstatic int kirin_drm_platform_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct component_match *match = NULL;\n\tstruct device_node *remote;\n\n\tremote = of_graph_get_remote_node(np, 0, 0);\n\tif (!remote)\n\t\treturn -ENODEV;\n\n\tdrm_of_component_match_add(dev, &match, component_compare_of, remote);\n\tof_node_put(remote);\n\n\treturn component_master_add_with_match(dev, &kirin_drm_ops, match);\n}\n\nstatic void kirin_drm_platform_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &kirin_drm_ops);\n}\n\nstatic const struct of_device_id kirin_drm_dt_ids[] = {\n\t{ .compatible = \"hisilicon,hi6220-ade\",\n\t  .data = &ade_driver_data,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, kirin_drm_dt_ids);\n\nstatic struct platform_driver kirin_drm_platform_driver = {\n\t.probe = kirin_drm_platform_probe,\n\t.remove_new = kirin_drm_platform_remove,\n\t.driver = {\n\t\t.name = \"kirin-drm\",\n\t\t.of_match_table = kirin_drm_dt_ids,\n\t},\n};\n\ndrm_module_platform_driver(kirin_drm_platform_driver);\n\nMODULE_AUTHOR(\"Xinliang Liu <xinliang.liu@linaro.org>\");\nMODULE_AUTHOR(\"Xinliang Liu <z.liuxinliang@hisilicon.com>\");\nMODULE_AUTHOR(\"Xinwei Kong <kong.kongxinwei@hisilicon.com>\");\nMODULE_DESCRIPTION(\"hisilicon Kirin SoCs' DRM master driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}