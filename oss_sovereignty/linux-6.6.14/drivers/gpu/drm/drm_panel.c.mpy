{
  "module_name": "drm_panel.c",
  "hash_id": "256a7a5951daa311b6f8c33f9f39d81e8bbd52b280ed47aae33d3c50168e8ea5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_panel.c",
  "human_readable_source": " \n\n#include <linux/backlight.h>\n#include <linux/err.h>\n#include <linux/module.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n\nstatic DEFINE_MUTEX(panel_lock);\nstatic LIST_HEAD(panel_list);\n\n \n\n \nvoid drm_panel_init(struct drm_panel *panel, struct device *dev,\n\t\t    const struct drm_panel_funcs *funcs, int connector_type)\n{\n\tINIT_LIST_HEAD(&panel->list);\n\tINIT_LIST_HEAD(&panel->followers);\n\tmutex_init(&panel->follower_lock);\n\tpanel->dev = dev;\n\tpanel->funcs = funcs;\n\tpanel->connector_type = connector_type;\n}\nEXPORT_SYMBOL(drm_panel_init);\n\n \nvoid drm_panel_add(struct drm_panel *panel)\n{\n\tmutex_lock(&panel_lock);\n\tlist_add_tail(&panel->list, &panel_list);\n\tmutex_unlock(&panel_lock);\n}\nEXPORT_SYMBOL(drm_panel_add);\n\n \nvoid drm_panel_remove(struct drm_panel *panel)\n{\n\tmutex_lock(&panel_lock);\n\tlist_del_init(&panel->list);\n\tmutex_unlock(&panel_lock);\n}\nEXPORT_SYMBOL(drm_panel_remove);\n\n \nint drm_panel_prepare(struct drm_panel *panel)\n{\n\tstruct drm_panel_follower *follower;\n\tint ret;\n\n\tif (!panel)\n\t\treturn -EINVAL;\n\n\tif (panel->prepared) {\n\t\tdev_warn(panel->dev, \"Skipping prepare of already prepared panel\\n\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&panel->follower_lock);\n\n\tif (panel->funcs && panel->funcs->prepare) {\n\t\tret = panel->funcs->prepare(panel);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t}\n\tpanel->prepared = true;\n\n\tlist_for_each_entry(follower, &panel->followers, list) {\n\t\tret = follower->funcs->panel_prepared(follower);\n\t\tif (ret < 0)\n\t\t\tdev_info(panel->dev, \"%ps failed: %d\\n\",\n\t\t\t\t follower->funcs->panel_prepared, ret);\n\t}\n\n\tret = 0;\nexit:\n\tmutex_unlock(&panel->follower_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_panel_prepare);\n\n \nint drm_panel_unprepare(struct drm_panel *panel)\n{\n\tstruct drm_panel_follower *follower;\n\tint ret;\n\n\tif (!panel)\n\t\treturn -EINVAL;\n\n\tif (!panel->prepared) {\n\t\tdev_warn(panel->dev, \"Skipping unprepare of already unprepared panel\\n\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&panel->follower_lock);\n\n\tlist_for_each_entry(follower, &panel->followers, list) {\n\t\tret = follower->funcs->panel_unpreparing(follower);\n\t\tif (ret < 0)\n\t\t\tdev_info(panel->dev, \"%ps failed: %d\\n\",\n\t\t\t\t follower->funcs->panel_unpreparing, ret);\n\t}\n\n\tif (panel->funcs && panel->funcs->unprepare) {\n\t\tret = panel->funcs->unprepare(panel);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t}\n\tpanel->prepared = false;\n\n\tret = 0;\nexit:\n\tmutex_unlock(&panel->follower_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_panel_unprepare);\n\n \nint drm_panel_enable(struct drm_panel *panel)\n{\n\tint ret;\n\n\tif (!panel)\n\t\treturn -EINVAL;\n\n\tif (panel->enabled) {\n\t\tdev_warn(panel->dev, \"Skipping enable of already enabled panel\\n\");\n\t\treturn 0;\n\t}\n\n\tif (panel->funcs && panel->funcs->enable) {\n\t\tret = panel->funcs->enable(panel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tpanel->enabled = true;\n\n\tret = backlight_enable(panel->backlight);\n\tif (ret < 0)\n\t\tDRM_DEV_INFO(panel->dev, \"failed to enable backlight: %d\\n\",\n\t\t\t     ret);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_panel_enable);\n\n \nint drm_panel_disable(struct drm_panel *panel)\n{\n\tint ret;\n\n\tif (!panel)\n\t\treturn -EINVAL;\n\n\tif (!panel->enabled) {\n\t\tdev_warn(panel->dev, \"Skipping disable of already disabled panel\\n\");\n\t\treturn 0;\n\t}\n\n\tret = backlight_disable(panel->backlight);\n\tif (ret < 0)\n\t\tDRM_DEV_INFO(panel->dev, \"failed to disable backlight: %d\\n\",\n\t\t\t     ret);\n\n\tif (panel->funcs && panel->funcs->disable) {\n\t\tret = panel->funcs->disable(panel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tpanel->enabled = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_panel_disable);\n\n \nint drm_panel_get_modes(struct drm_panel *panel,\n\t\t\tstruct drm_connector *connector)\n{\n\tif (!panel)\n\t\treturn -EINVAL;\n\n\tif (panel->funcs && panel->funcs->get_modes)\n\t\treturn panel->funcs->get_modes(panel, connector);\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL(drm_panel_get_modes);\n\n#ifdef CONFIG_OF\n \nstruct drm_panel *of_drm_find_panel(const struct device_node *np)\n{\n\tstruct drm_panel *panel;\n\n\tif (!of_device_is_available(np))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmutex_lock(&panel_lock);\n\n\tlist_for_each_entry(panel, &panel_list, list) {\n\t\tif (panel->dev->of_node == np) {\n\t\t\tmutex_unlock(&panel_lock);\n\t\t\treturn panel;\n\t\t}\n\t}\n\n\tmutex_unlock(&panel_lock);\n\treturn ERR_PTR(-EPROBE_DEFER);\n}\nEXPORT_SYMBOL(of_drm_find_panel);\n\n \nint of_drm_get_panel_orientation(const struct device_node *np,\n\t\t\t\t enum drm_panel_orientation *orientation)\n{\n\tint rotation, ret;\n\n\tret = of_property_read_u32(np, \"rotation\", &rotation);\n\tif (ret == -EINVAL) {\n\t\t \n\t\t*orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;\n\t\treturn 0;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (rotation == 0)\n\t\t*orientation = DRM_MODE_PANEL_ORIENTATION_NORMAL;\n\telse if (rotation == 90)\n\t\t*orientation = DRM_MODE_PANEL_ORIENTATION_RIGHT_UP;\n\telse if (rotation == 180)\n\t\t*orientation = DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP;\n\telse if (rotation == 270)\n\t\t*orientation = DRM_MODE_PANEL_ORIENTATION_LEFT_UP;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(of_drm_get_panel_orientation);\n#endif\n\n \nbool drm_is_panel_follower(struct device *dev)\n{\n\t \n\treturn of_property_read_bool(dev->of_node, \"panel\");\n}\nEXPORT_SYMBOL(drm_is_panel_follower);\n\n \nint drm_panel_add_follower(struct device *follower_dev,\n\t\t\t   struct drm_panel_follower *follower)\n{\n\tstruct device_node *panel_np;\n\tstruct drm_panel *panel;\n\tint ret;\n\n\tpanel_np = of_parse_phandle(follower_dev->of_node, \"panel\", 0);\n\tif (!panel_np)\n\t\treturn -ENODEV;\n\n\tpanel = of_drm_find_panel(panel_np);\n\tof_node_put(panel_np);\n\tif (IS_ERR(panel))\n\t\treturn PTR_ERR(panel);\n\n\tget_device(panel->dev);\n\tfollower->panel = panel;\n\n\tmutex_lock(&panel->follower_lock);\n\n\tlist_add_tail(&follower->list, &panel->followers);\n\tif (panel->prepared) {\n\t\tret = follower->funcs->panel_prepared(follower);\n\t\tif (ret < 0)\n\t\t\tdev_info(panel->dev, \"%ps failed: %d\\n\",\n\t\t\t\t follower->funcs->panel_prepared, ret);\n\t}\n\n\tmutex_unlock(&panel->follower_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_panel_add_follower);\n\n \nvoid drm_panel_remove_follower(struct drm_panel_follower *follower)\n{\n\tstruct drm_panel *panel = follower->panel;\n\tint ret;\n\n\tmutex_lock(&panel->follower_lock);\n\n\tif (panel->prepared) {\n\t\tret = follower->funcs->panel_unpreparing(follower);\n\t\tif (ret < 0)\n\t\t\tdev_info(panel->dev, \"%ps failed: %d\\n\",\n\t\t\t\t follower->funcs->panel_unpreparing, ret);\n\t}\n\tlist_del_init(&follower->list);\n\n\tmutex_unlock(&panel->follower_lock);\n\n\tput_device(panel->dev);\n}\nEXPORT_SYMBOL(drm_panel_remove_follower);\n\nstatic void drm_panel_remove_follower_void(void *follower)\n{\n\tdrm_panel_remove_follower(follower);\n}\n\n \nint devm_drm_panel_add_follower(struct device *follower_dev,\n\t\t\t\tstruct drm_panel_follower *follower)\n{\n\tint ret;\n\n\tret = drm_panel_add_follower(follower_dev, follower);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(follower_dev,\n\t\t\t\t\tdrm_panel_remove_follower_void, follower);\n}\nEXPORT_SYMBOL(devm_drm_panel_add_follower);\n\n#if IS_REACHABLE(CONFIG_BACKLIGHT_CLASS_DEVICE)\n \nint drm_panel_of_backlight(struct drm_panel *panel)\n{\n\tstruct backlight_device *backlight;\n\n\tif (!panel || !panel->dev)\n\t\treturn -EINVAL;\n\n\tbacklight = devm_of_find_backlight(panel->dev);\n\n\tif (IS_ERR(backlight))\n\t\treturn PTR_ERR(backlight);\n\n\tpanel->backlight = backlight;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_panel_of_backlight);\n#endif\n\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_DESCRIPTION(\"DRM panel infrastructure\");\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}