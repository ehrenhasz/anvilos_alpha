{
  "module_name": "tilcdc_drv.c",
  "hash_id": "22fdc4bbeea2c308573315e984d2849d9ea0b039b5ad9d6a9fd0b6faf842f11b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tilcdc/tilcdc_drv.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/component.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_mm.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n\n#include \"tilcdc_drv.h\"\n#include \"tilcdc_external.h\"\n#include \"tilcdc_panel.h\"\n#include \"tilcdc_regs.h\"\n\nstatic LIST_HEAD(module_list);\n\nstatic const u32 tilcdc_rev1_formats[] = { DRM_FORMAT_RGB565 };\n\nstatic const u32 tilcdc_straight_formats[] = { DRM_FORMAT_RGB565,\n\t\t\t\t\t       DRM_FORMAT_BGR888,\n\t\t\t\t\t       DRM_FORMAT_XBGR8888 };\n\nstatic const u32 tilcdc_crossed_formats[] = { DRM_FORMAT_BGR565,\n\t\t\t\t\t      DRM_FORMAT_RGB888,\n\t\t\t\t\t      DRM_FORMAT_XRGB8888 };\n\nstatic const u32 tilcdc_legacy_formats[] = { DRM_FORMAT_RGB565,\n\t\t\t\t\t     DRM_FORMAT_RGB888,\n\t\t\t\t\t     DRM_FORMAT_XRGB8888 };\n\nvoid tilcdc_module_init(struct tilcdc_module *mod, const char *name,\n\t\tconst struct tilcdc_module_ops *funcs)\n{\n\tmod->name = name;\n\tmod->funcs = funcs;\n\tINIT_LIST_HEAD(&mod->list);\n\tlist_add(&mod->list, &module_list);\n}\n\nvoid tilcdc_module_cleanup(struct tilcdc_module *mod)\n{\n\tlist_del(&mod->list);\n}\n\nstatic int tilcdc_atomic_check(struct drm_device *dev,\n\t\t\t       struct drm_atomic_state *state)\n{\n\tint ret;\n\n\tret = drm_atomic_helper_check_modeset(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_atomic_helper_check_planes(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = drm_atomic_helper_check_modeset(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic const struct drm_mode_config_funcs mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = tilcdc_atomic_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic void modeset_init(struct drm_device *dev)\n{\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tstruct tilcdc_module *mod;\n\n\tlist_for_each_entry(mod, &module_list, list) {\n\t\tDBG(\"loading module: %s\", mod->name);\n\t\tmod->funcs->modeset_init(mod, dev);\n\t}\n\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tdev->mode_config.max_width = priv->max_width;\n\tdev->mode_config.max_height = 2048;\n\tdev->mode_config.funcs = &mode_config_funcs;\n}\n\n#ifdef CONFIG_CPU_FREQ\nstatic int cpufreq_transition(struct notifier_block *nb,\n\t\t\t\t     unsigned long val, void *data)\n{\n\tstruct tilcdc_drm_private *priv = container_of(nb,\n\t\t\tstruct tilcdc_drm_private, freq_transition);\n\n\tif (val == CPUFREQ_POSTCHANGE)\n\t\ttilcdc_crtc_update_clk(priv->crtc);\n\n\treturn 0;\n}\n#endif\n\nstatic irqreturn_t tilcdc_irq(int irq, void *arg)\n{\n\tstruct drm_device *dev = arg;\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\n\treturn tilcdc_crtc_irq(priv->crtc);\n}\n\nstatic int tilcdc_irq_install(struct drm_device *dev, unsigned int irq)\n{\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tint ret;\n\n\tret = request_irq(irq, tilcdc_irq, 0, dev->driver->name, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->irq_enabled = true;\n\n\treturn 0;\n}\n\nstatic void tilcdc_irq_uninstall(struct drm_device *dev)\n{\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\n\tif (!priv->irq_enabled)\n\t\treturn;\n\n\tfree_irq(priv->irq, dev);\n\tpriv->irq_enabled = false;\n}\n\n \n\nstatic void tilcdc_fini(struct drm_device *dev)\n{\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\n#ifdef CONFIG_CPU_FREQ\n\tif (priv->freq_transition.notifier_call)\n\t\tcpufreq_unregister_notifier(&priv->freq_transition,\n\t\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n#endif\n\n\tif (priv->crtc)\n\t\ttilcdc_crtc_shutdown(priv->crtc);\n\n\tif (priv->is_registered)\n\t\tdrm_dev_unregister(dev);\n\n\tdrm_kms_helper_poll_fini(dev);\n\tdrm_atomic_helper_shutdown(dev);\n\ttilcdc_irq_uninstall(dev);\n\tdrm_mode_config_cleanup(dev);\n\n\tif (priv->clk)\n\t\tclk_put(priv->clk);\n\n\tif (priv->mmio)\n\t\tiounmap(priv->mmio);\n\n\tif (priv->wq)\n\t\tdestroy_workqueue(priv->wq);\n\n\tdev->dev_private = NULL;\n\n\tpm_runtime_disable(dev->dev);\n\n\tdrm_dev_put(dev);\n}\n\nstatic int tilcdc_init(const struct drm_driver *ddrv, struct device *dev)\n{\n\tstruct drm_device *ddev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct device_node *node = dev->of_node;\n\tstruct tilcdc_drm_private *priv;\n\tstruct resource *res;\n\tu32 bpp = 0;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tddev = drm_dev_alloc(ddrv, dev);\n\tif (IS_ERR(ddev))\n\t\treturn PTR_ERR(ddev);\n\n\tddev->dev_private = priv;\n\tplatform_set_drvdata(pdev, ddev);\n\tdrm_mode_config_init(ddev);\n\n\tpriv->is_componentized =\n\t\ttilcdc_get_external_components(dev, NULL) > 0;\n\n\tpriv->wq = alloc_ordered_workqueue(\"tilcdc\", 0);\n\tif (!priv->wq) {\n\t\tret = -ENOMEM;\n\t\tgoto init_failed;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"failed to get memory resource\\n\");\n\t\tret = -EINVAL;\n\t\tgoto init_failed;\n\t}\n\n\tpriv->mmio = ioremap(res->start, resource_size(res));\n\tif (!priv->mmio) {\n\t\tdev_err(dev, \"failed to ioremap\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto init_failed;\n\t}\n\n\tpriv->clk = clk_get(dev, \"fck\");\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"failed to get functional clock\\n\");\n\t\tret = -ENODEV;\n\t\tgoto init_failed;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\t \n\tpm_runtime_get_sync(dev);\n\tswitch (tilcdc_read(ddev, LCDC_PID_REG)) {\n\tcase 0x4c100102:\n\t\tpriv->rev = 1;\n\t\tbreak;\n\tcase 0x4f200800:\n\tcase 0x4f201000:\n\t\tpriv->rev = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"Unknown PID Reg value 0x%08x, \"\n\t\t\t\"defaulting to LCD revision 1\\n\",\n\t\t\ttilcdc_read(ddev, LCDC_PID_REG));\n\t\tpriv->rev = 1;\n\t\tbreak;\n\t}\n\n\tpm_runtime_put_sync(dev);\n\n\tif (priv->rev == 1) {\n\t\tDBG(\"Revision 1 LCDC supports only RGB565 format\");\n\t\tpriv->pixelformats = tilcdc_rev1_formats;\n\t\tpriv->num_pixelformats = ARRAY_SIZE(tilcdc_rev1_formats);\n\t\tbpp = 16;\n\t} else {\n\t\tconst char *str = \"\\0\";\n\n\t\tof_property_read_string(node, \"blue-and-red-wiring\", &str);\n\t\tif (0 == strcmp(str, \"crossed\")) {\n\t\t\tDBG(\"Configured for crossed blue and red wires\");\n\t\t\tpriv->pixelformats = tilcdc_crossed_formats;\n\t\t\tpriv->num_pixelformats =\n\t\t\t\tARRAY_SIZE(tilcdc_crossed_formats);\n\t\t\tbpp = 32;  \n\t\t} else if (0 == strcmp(str, \"straight\")) {\n\t\t\tDBG(\"Configured for straight blue and red wires\");\n\t\t\tpriv->pixelformats = tilcdc_straight_formats;\n\t\t\tpriv->num_pixelformats =\n\t\t\t\tARRAY_SIZE(tilcdc_straight_formats);\n\t\t\tbpp = 16;  \n\t\t} else {\n\t\t\tDBG(\"Blue and red wiring '%s' unknown, use legacy mode\",\n\t\t\t    str);\n\t\t\tpriv->pixelformats = tilcdc_legacy_formats;\n\t\t\tpriv->num_pixelformats =\n\t\t\t\tARRAY_SIZE(tilcdc_legacy_formats);\n\t\t\tbpp = 16;  \n\t\t}\n\t}\n\n\tif (of_property_read_u32(node, \"max-bandwidth\", &priv->max_bandwidth))\n\t\tpriv->max_bandwidth = TILCDC_DEFAULT_MAX_BANDWIDTH;\n\n\tDBG(\"Maximum Bandwidth Value %d\", priv->max_bandwidth);\n\n\tif (of_property_read_u32(node, \"max-width\", &priv->max_width)) {\n\t\tif (priv->rev == 1)\n\t\t\tpriv->max_width = TILCDC_DEFAULT_MAX_WIDTH_V1;\n\t\telse\n\t\t\tpriv->max_width = TILCDC_DEFAULT_MAX_WIDTH_V2;\n\t}\n\n\tDBG(\"Maximum Horizontal Pixel Width Value %dpixels\", priv->max_width);\n\n\tif (of_property_read_u32(node, \"max-pixelclock\",\n\t\t\t\t &priv->max_pixelclock))\n\t\tpriv->max_pixelclock = TILCDC_DEFAULT_MAX_PIXELCLOCK;\n\n\tDBG(\"Maximum Pixel Clock Value %dKHz\", priv->max_pixelclock);\n\n\tret = tilcdc_crtc_create(ddev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to create crtc\\n\");\n\t\tgoto init_failed;\n\t}\n\tmodeset_init(ddev);\n\n#ifdef CONFIG_CPU_FREQ\n\tpriv->freq_transition.notifier_call = cpufreq_transition;\n\tret = cpufreq_register_notifier(&priv->freq_transition,\n\t\t\tCPUFREQ_TRANSITION_NOTIFIER);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register cpufreq notifier\\n\");\n\t\tpriv->freq_transition.notifier_call = NULL;\n\t\tgoto init_failed;\n\t}\n#endif\n\n\tif (priv->is_componentized) {\n\t\tret = component_bind_all(dev, ddev);\n\t\tif (ret < 0)\n\t\t\tgoto init_failed;\n\n\t\tret = tilcdc_add_component_encoder(ddev);\n\t\tif (ret < 0)\n\t\t\tgoto init_failed;\n\t} else {\n\t\tret = tilcdc_attach_external_device(ddev);\n\t\tif (ret)\n\t\t\tgoto init_failed;\n\t}\n\n\tif (!priv->external_connector &&\n\t    ((priv->num_encoders == 0) || (priv->num_connectors == 0))) {\n\t\tdev_err(dev, \"no encoders/connectors found\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto init_failed;\n\t}\n\n\tret = drm_vblank_init(ddev, 1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to initialize vblank\\n\");\n\t\tgoto init_failed;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto init_failed;\n\tpriv->irq = ret;\n\n\tret = tilcdc_irq_install(ddev, priv->irq);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to install IRQ handler\\n\");\n\t\tgoto init_failed;\n\t}\n\n\tdrm_mode_config_reset(ddev);\n\n\tdrm_kms_helper_poll_init(ddev);\n\n\tret = drm_dev_register(ddev, 0);\n\tif (ret)\n\t\tgoto init_failed;\n\tpriv->is_registered = true;\n\n\tdrm_fbdev_dma_setup(ddev, bpp);\n\treturn 0;\n\ninit_failed:\n\ttilcdc_fini(ddev);\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn ret;\n}\n\n#if defined(CONFIG_DEBUG_FS)\nstatic const struct {\n\tconst char *name;\n\tuint8_t  rev;\n\tuint8_t  save;\n\tuint32_t reg;\n} registers[] =\t\t{\n#define REG(rev, save, reg) { #reg, rev, save, reg }\n\t\t \n\t\tREG(1, false, LCDC_PID_REG),\n\t\tREG(1, true,  LCDC_CTRL_REG),\n\t\tREG(1, false, LCDC_STAT_REG),\n\t\tREG(1, true,  LCDC_RASTER_CTRL_REG),\n\t\tREG(1, true,  LCDC_RASTER_TIMING_0_REG),\n\t\tREG(1, true,  LCDC_RASTER_TIMING_1_REG),\n\t\tREG(1, true,  LCDC_RASTER_TIMING_2_REG),\n\t\tREG(1, true,  LCDC_DMA_CTRL_REG),\n\t\tREG(1, true,  LCDC_DMA_FB_BASE_ADDR_0_REG),\n\t\tREG(1, true,  LCDC_DMA_FB_CEILING_ADDR_0_REG),\n\t\tREG(1, true,  LCDC_DMA_FB_BASE_ADDR_1_REG),\n\t\tREG(1, true,  LCDC_DMA_FB_CEILING_ADDR_1_REG),\n\t\t \n\t\tREG(2, false, LCDC_RAW_STAT_REG),\n\t\tREG(2, false, LCDC_MASKED_STAT_REG),\n\t\tREG(2, true, LCDC_INT_ENABLE_SET_REG),\n\t\tREG(2, false, LCDC_INT_ENABLE_CLR_REG),\n\t\tREG(2, false, LCDC_END_OF_INT_IND_REG),\n\t\tREG(2, true,  LCDC_CLK_ENABLE_REG),\n#undef REG\n};\n\n#endif\n\n#ifdef CONFIG_DEBUG_FS\nstatic int tilcdc_regs_show(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tunsigned i;\n\n\tpm_runtime_get_sync(dev->dev);\n\n\tseq_printf(m, \"revision: %d\\n\", priv->rev);\n\n\tfor (i = 0; i < ARRAY_SIZE(registers); i++)\n\t\tif (priv->rev >= registers[i].rev)\n\t\t\tseq_printf(m, \"%s:\\t %08x\\n\", registers[i].name,\n\t\t\t\t\ttilcdc_read(dev, registers[i].reg));\n\n\tpm_runtime_put_sync(dev->dev);\n\n\treturn 0;\n}\n\nstatic int tilcdc_mm_show(struct seq_file *m, void *arg)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\tdrm_mm_print(&dev->vma_offset_manager->vm_addr_space_mm, &p);\n\treturn 0;\n}\n\nstatic struct drm_info_list tilcdc_debugfs_list[] = {\n\t\t{ \"regs\", tilcdc_regs_show, 0, NULL },\n\t\t{ \"mm\",   tilcdc_mm_show,   0, NULL },\n};\n\nstatic void tilcdc_debugfs_init(struct drm_minor *minor)\n{\n\tstruct tilcdc_module *mod;\n\n\tdrm_debugfs_create_files(tilcdc_debugfs_list,\n\t\t\t\t ARRAY_SIZE(tilcdc_debugfs_list),\n\t\t\t\t minor->debugfs_root, minor);\n\n\tlist_for_each_entry(mod, &module_list, list)\n\t\tif (mod->funcs->debugfs_init)\n\t\t\tmod->funcs->debugfs_init(mod, minor);\n}\n#endif\n\nDEFINE_DRM_GEM_DMA_FOPS(fops);\n\nstatic const struct drm_driver tilcdc_driver = {\n\t.driver_features    = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\tDRM_GEM_DMA_DRIVER_OPS,\n#ifdef CONFIG_DEBUG_FS\n\t.debugfs_init       = tilcdc_debugfs_init,\n#endif\n\t.fops               = &fops,\n\t.name               = \"tilcdc\",\n\t.desc               = \"TI LCD Controller DRM\",\n\t.date               = \"20121205\",\n\t.major              = 1,\n\t.minor              = 0,\n};\n\n \n\nstatic int tilcdc_pm_suspend(struct device *dev)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tret = drm_mode_config_helper_suspend(ddev);\n\n\t \n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn ret;\n}\n\nstatic int tilcdc_pm_resume(struct device *dev)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\n\t \n\tpinctrl_pm_select_default_state(dev);\n\treturn  drm_mode_config_helper_resume(ddev);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tilcdc_pm_ops,\n\t\t\t\ttilcdc_pm_suspend, tilcdc_pm_resume);\n\n \nstatic int tilcdc_bind(struct device *dev)\n{\n\treturn tilcdc_init(&tilcdc_driver, dev);\n}\n\nstatic void tilcdc_unbind(struct device *dev)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\n\t \n\tif (!ddev->dev_private)\n\t\treturn;\n\n\ttilcdc_fini(ddev);\n\tdev_set_drvdata(dev, NULL);\n}\n\nstatic const struct component_master_ops tilcdc_comp_ops = {\n\t.bind = tilcdc_bind,\n\t.unbind = tilcdc_unbind,\n};\n\nstatic int tilcdc_pdev_probe(struct platform_device *pdev)\n{\n\tstruct component_match *match = NULL;\n\tint ret;\n\n\t \n\tif (!pdev->dev.of_node) {\n\t\tdev_err(&pdev->dev, \"device-tree data is missing\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = tilcdc_get_external_components(&pdev->dev, &match);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret == 0)\n\t\treturn tilcdc_init(&tilcdc_driver, &pdev->dev);\n\telse\n\t\treturn component_master_add_with_match(&pdev->dev,\n\t\t\t\t\t\t       &tilcdc_comp_ops,\n\t\t\t\t\t\t       match);\n}\n\nstatic int tilcdc_pdev_remove(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = tilcdc_get_external_components(&pdev->dev, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret == 0)\n\t\ttilcdc_fini(platform_get_drvdata(pdev));\n\telse\n\t\tcomponent_master_del(&pdev->dev, &tilcdc_comp_ops);\n\n\treturn 0;\n}\n\nstatic void tilcdc_pdev_shutdown(struct platform_device *pdev)\n{\n\tdrm_atomic_helper_shutdown(platform_get_drvdata(pdev));\n}\n\nstatic const struct of_device_id tilcdc_of_match[] = {\n\t\t{ .compatible = \"ti,am33xx-tilcdc\", },\n\t\t{ .compatible = \"ti,da850-tilcdc\", },\n\t\t{ },\n};\nMODULE_DEVICE_TABLE(of, tilcdc_of_match);\n\nstatic struct platform_driver tilcdc_platform_driver = {\n\t.probe      = tilcdc_pdev_probe,\n\t.remove     = tilcdc_pdev_remove,\n\t.shutdown   = tilcdc_pdev_shutdown,\n\t.driver     = {\n\t\t.name   = \"tilcdc\",\n\t\t.pm     = pm_sleep_ptr(&tilcdc_pm_ops),\n\t\t.of_match_table = tilcdc_of_match,\n\t},\n};\n\nstatic int __init tilcdc_drm_init(void)\n{\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\tDBG(\"init\");\n\ttilcdc_panel_init();\n\treturn platform_driver_register(&tilcdc_platform_driver);\n}\n\nstatic void __exit tilcdc_drm_fini(void)\n{\n\tDBG(\"fini\");\n\tplatform_driver_unregister(&tilcdc_platform_driver);\n\ttilcdc_panel_fini();\n}\n\nmodule_init(tilcdc_drm_init);\nmodule_exit(tilcdc_drm_fini);\n\nMODULE_AUTHOR(\"Rob Clark <robdclark@gmail.com\");\nMODULE_DESCRIPTION(\"TI LCD Controller DRM Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}