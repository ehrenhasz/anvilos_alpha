{
  "module_name": "tilcdc_panel.c",
  "hash_id": "7f67d75144d5d7e94f0a0f75207b204ee8b2c9a4e073f34e9db2c949a2dcfecf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tilcdc/tilcdc_panel.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/gpio/consumer.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n\n#include <video/display_timing.h>\n#include <video/of_display_timing.h>\n#include <video/videomode.h>\n\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"tilcdc_drv.h\"\n#include \"tilcdc_panel.h\"\n\nstruct panel_module {\n\tstruct tilcdc_module base;\n\tstruct tilcdc_panel_info *info;\n\tstruct display_timings *timings;\n\tstruct backlight_device *backlight;\n\tstruct gpio_desc *enable_gpio;\n};\n#define to_panel_module(x) container_of(x, struct panel_module, base)\n\n\n \n\nstruct panel_encoder {\n\tstruct drm_encoder base;\n\tstruct panel_module *mod;\n};\n#define to_panel_encoder(x) container_of(x, struct panel_encoder, base)\n\nstatic void panel_encoder_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct panel_encoder *panel_encoder = to_panel_encoder(encoder);\n\tstruct backlight_device *backlight = panel_encoder->mod->backlight;\n\tstruct gpio_desc *gpio = panel_encoder->mod->enable_gpio;\n\n\tif (backlight) {\n\t\tbacklight->props.power = mode == DRM_MODE_DPMS_ON ?\n\t\t\t\t\t FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;\n\t\tbacklight_update_status(backlight);\n\t}\n\n\tif (gpio)\n\t\tgpiod_set_value_cansleep(gpio,\n\t\t\t\t\t mode == DRM_MODE_DPMS_ON ? 1 : 0);\n}\n\nstatic void panel_encoder_prepare(struct drm_encoder *encoder)\n{\n\tpanel_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);\n}\n\nstatic void panel_encoder_commit(struct drm_encoder *encoder)\n{\n\tpanel_encoder_dpms(encoder, DRM_MODE_DPMS_ON);\n}\n\nstatic void panel_encoder_mode_set(struct drm_encoder *encoder,\n\t\tstruct drm_display_mode *mode,\n\t\tstruct drm_display_mode *adjusted_mode)\n{\n\t \n}\n\nstatic const struct drm_encoder_helper_funcs panel_encoder_helper_funcs = {\n\t\t.dpms           = panel_encoder_dpms,\n\t\t.prepare        = panel_encoder_prepare,\n\t\t.commit         = panel_encoder_commit,\n\t\t.mode_set       = panel_encoder_mode_set,\n};\n\nstatic struct drm_encoder *panel_encoder_create(struct drm_device *dev,\n\t\tstruct panel_module *mod)\n{\n\tstruct panel_encoder *panel_encoder;\n\tstruct drm_encoder *encoder;\n\tint ret;\n\n\tpanel_encoder = devm_kzalloc(dev->dev, sizeof(*panel_encoder),\n\t\t\t\t     GFP_KERNEL);\n\tif (!panel_encoder)\n\t\treturn NULL;\n\n\tpanel_encoder->mod = mod;\n\n\tencoder = &panel_encoder->base;\n\tencoder->possible_crtcs = 1;\n\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_LVDS);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tdrm_encoder_helper_add(encoder, &panel_encoder_helper_funcs);\n\n\treturn encoder;\n\nfail:\n\tdrm_encoder_cleanup(encoder);\n\treturn NULL;\n}\n\n \n\nstruct panel_connector {\n\tstruct drm_connector base;\n\n\tstruct drm_encoder *encoder;   \n\tstruct panel_module *mod;\n};\n#define to_panel_connector(x) container_of(x, struct panel_connector, base)\n\n\nstatic void panel_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n}\n\nstatic int panel_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct panel_connector *panel_connector = to_panel_connector(connector);\n\tstruct display_timings *timings = panel_connector->mod->timings;\n\tint i;\n\n\tfor (i = 0; i < timings->num_timings; i++) {\n\t\tstruct drm_display_mode *mode;\n\t\tstruct videomode vm;\n\n\t\tif (videomode_from_timings(timings, &vm, i))\n\t\t\tbreak;\n\n\t\tmode = drm_mode_create(dev);\n\t\tif (!mode)\n\t\t\tbreak;\n\n\t\tdrm_display_mode_from_videomode(&vm, mode);\n\n\t\tmode->type = DRM_MODE_TYPE_DRIVER;\n\n\t\tif (timings->native_mode == i)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_set_name(mode);\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\treturn i;\n}\n\nstatic struct drm_encoder *panel_connector_best_encoder(\n\t\tstruct drm_connector *connector)\n{\n\tstruct panel_connector *panel_connector = to_panel_connector(connector);\n\treturn panel_connector->encoder;\n}\n\nstatic const struct drm_connector_funcs panel_connector_funcs = {\n\t.destroy            = panel_connector_destroy,\n\t.fill_modes         = drm_helper_probe_single_connector_modes,\n\t.reset              = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_connector_helper_funcs panel_connector_helper_funcs = {\n\t.get_modes          = panel_connector_get_modes,\n\t.best_encoder       = panel_connector_best_encoder,\n};\n\nstatic struct drm_connector *panel_connector_create(struct drm_device *dev,\n\t\tstruct panel_module *mod, struct drm_encoder *encoder)\n{\n\tstruct panel_connector *panel_connector;\n\tstruct drm_connector *connector;\n\tint ret;\n\n\tpanel_connector = devm_kzalloc(dev->dev, sizeof(*panel_connector),\n\t\t\t\t       GFP_KERNEL);\n\tif (!panel_connector)\n\t\treturn NULL;\n\n\tpanel_connector->encoder = encoder;\n\tpanel_connector->mod = mod;\n\n\tconnector = &panel_connector->base;\n\n\tdrm_connector_init(dev, connector, &panel_connector_funcs,\n\t\t\tDRM_MODE_CONNECTOR_LVDS);\n\tdrm_connector_helper_add(connector, &panel_connector_helper_funcs);\n\n\tconnector->interlace_allowed = 0;\n\tconnector->doublescan_allowed = 0;\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret)\n\t\tgoto fail;\n\n\treturn connector;\n\nfail:\n\tpanel_connector_destroy(connector);\n\treturn NULL;\n}\n\n \n\nstatic int panel_modeset_init(struct tilcdc_module *mod, struct drm_device *dev)\n{\n\tstruct panel_module *panel_mod = to_panel_module(mod);\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\n\tencoder = panel_encoder_create(dev, panel_mod);\n\tif (!encoder)\n\t\treturn -ENOMEM;\n\n\tconnector = panel_connector_create(dev, panel_mod, encoder);\n\tif (!connector)\n\t\treturn -ENOMEM;\n\n\tpriv->encoders[priv->num_encoders++] = encoder;\n\tpriv->connectors[priv->num_connectors++] = connector;\n\n\ttilcdc_crtc_set_panel_info(priv->crtc,\n\t\t\t\t   to_panel_encoder(encoder)->mod->info);\n\n\treturn 0;\n}\n\nstatic const struct tilcdc_module_ops panel_module_ops = {\n\t\t.modeset_init = panel_modeset_init,\n};\n\n \n\n \nstatic struct tilcdc_panel_info *of_get_panel_info(struct device_node *np)\n{\n\tstruct device_node *info_np;\n\tstruct tilcdc_panel_info *info;\n\tint ret = 0;\n\n\tif (!np) {\n\t\tpr_err(\"%s: no devicenode given\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinfo_np = of_get_child_by_name(np, \"panel-info\");\n\tif (!info_np) {\n\t\tpr_err(\"%s: could not find panel-info node\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\tgoto put_node;\n\n\tret |= of_property_read_u32(info_np, \"ac-bias\", &info->ac_bias);\n\tret |= of_property_read_u32(info_np, \"ac-bias-intrpt\", &info->ac_bias_intrpt);\n\tret |= of_property_read_u32(info_np, \"dma-burst-sz\", &info->dma_burst_sz);\n\tret |= of_property_read_u32(info_np, \"bpp\", &info->bpp);\n\tret |= of_property_read_u32(info_np, \"fdd\", &info->fdd);\n\tret |= of_property_read_u32(info_np, \"sync-edge\", &info->sync_edge);\n\tret |= of_property_read_u32(info_np, \"sync-ctrl\", &info->sync_ctrl);\n\tret |= of_property_read_u32(info_np, \"raster-order\", &info->raster_order);\n\tret |= of_property_read_u32(info_np, \"fifo-th\", &info->fifo_th);\n\n\t \n\tinfo->tft_alt_mode      = of_property_read_bool(info_np, \"tft-alt-mode\");\n\tinfo->invert_pxl_clk    = of_property_read_bool(info_np, \"invert-pxl-clk\");\n\n\tif (ret) {\n\t\tpr_err(\"%s: error reading panel-info properties\\n\", __func__);\n\t\tkfree(info);\n\t\tinfo = NULL;\n\t}\n\nput_node:\n\tof_node_put(info_np);\n\treturn info;\n}\n\nstatic int panel_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct backlight_device *backlight;\n\tstruct panel_module *panel_mod;\n\tstruct tilcdc_module *mod;\n\tstruct pinctrl *pinctrl;\n\tint ret;\n\n\t \n\tif (!node) {\n\t\tdev_err(&pdev->dev, \"device-tree data is missing\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpanel_mod = devm_kzalloc(&pdev->dev, sizeof(*panel_mod), GFP_KERNEL);\n\tif (!panel_mod)\n\t\treturn -ENOMEM;\n\n\tbacklight = devm_of_find_backlight(&pdev->dev);\n\tif (IS_ERR(backlight))\n\t\treturn PTR_ERR(backlight);\n\tpanel_mod->backlight = backlight;\n\n\tpanel_mod->enable_gpio = devm_gpiod_get_optional(&pdev->dev, \"enable\",\n\t\t\t\t\t\t\t GPIOD_OUT_LOW);\n\tif (IS_ERR(panel_mod->enable_gpio)) {\n\t\tret = PTR_ERR(panel_mod->enable_gpio);\n\t\tdev_err(&pdev->dev, \"failed to request enable GPIO\\n\");\n\t\tgoto fail_backlight;\n\t}\n\n\tif (panel_mod->enable_gpio)\n\t\tdev_info(&pdev->dev, \"found enable GPIO\\n\");\n\n\tmod = &panel_mod->base;\n\tpdev->dev.platform_data = mod;\n\n\ttilcdc_module_init(mod, \"panel\", &panel_module_ops);\n\n\tpinctrl = devm_pinctrl_get_select_default(&pdev->dev);\n\tif (IS_ERR(pinctrl))\n\t\tdev_warn(&pdev->dev, \"pins are not configured\\n\");\n\n\tpanel_mod->timings = of_get_display_timings(node);\n\tif (!panel_mod->timings) {\n\t\tdev_err(&pdev->dev, \"could not get panel timings\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail_free;\n\t}\n\n\tpanel_mod->info = of_get_panel_info(node);\n\tif (!panel_mod->info) {\n\t\tdev_err(&pdev->dev, \"could not get panel info\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail_timings;\n\t}\n\n\treturn 0;\n\nfail_timings:\n\tdisplay_timings_release(panel_mod->timings);\n\nfail_free:\n\ttilcdc_module_cleanup(mod);\n\nfail_backlight:\n\tif (panel_mod->backlight)\n\t\tput_device(&panel_mod->backlight->dev);\n\treturn ret;\n}\n\nstatic void panel_remove(struct platform_device *pdev)\n{\n\tstruct tilcdc_module *mod = dev_get_platdata(&pdev->dev);\n\tstruct panel_module *panel_mod = to_panel_module(mod);\n\tstruct backlight_device *backlight = panel_mod->backlight;\n\n\tif (backlight)\n\t\tput_device(&backlight->dev);\n\n\tdisplay_timings_release(panel_mod->timings);\n\n\ttilcdc_module_cleanup(mod);\n\tkfree(panel_mod->info);\n}\n\nstatic const struct of_device_id panel_of_match[] = {\n\t\t{ .compatible = \"ti,tilcdc,panel\", },\n\t\t{ },\n};\n\nstatic struct platform_driver panel_driver = {\n\t.probe = panel_probe,\n\t.remove_new = panel_remove,\n\t.driver = {\n\t\t.name = \"tilcdc-panel\",\n\t\t.of_match_table = panel_of_match,\n\t},\n};\n\nint __init tilcdc_panel_init(void)\n{\n\treturn platform_driver_register(&panel_driver);\n}\n\nvoid __exit tilcdc_panel_fini(void)\n{\n\tplatform_driver_unregister(&panel_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}