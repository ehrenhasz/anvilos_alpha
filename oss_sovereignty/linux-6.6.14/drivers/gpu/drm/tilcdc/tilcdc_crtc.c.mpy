{
  "module_name": "tilcdc_crtc.c",
  "hash_id": "1a33427358b306707c550e787baab4b4368cbdc0bf8081d619b84ae7b001204d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tilcdc/tilcdc_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/of_graph.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n\n#include \"tilcdc_drv.h\"\n#include \"tilcdc_regs.h\"\n\n#define TILCDC_VBLANK_SAFETY_THRESHOLD_US\t1000\n#define TILCDC_PALETTE_SIZE\t\t\t32\n#define TILCDC_PALETTE_FIRST_ENTRY\t\t0x4000\n\nstruct tilcdc_crtc {\n\tstruct drm_crtc base;\n\n\tstruct drm_plane primary;\n\tconst struct tilcdc_panel_info *info;\n\tstruct drm_pending_vblank_event *event;\n\tstruct mutex enable_lock;\n\tbool enabled;\n\tbool shutdown;\n\twait_queue_head_t frame_done_wq;\n\tbool frame_done;\n\tspinlock_t irq_lock;\n\n\tunsigned int lcd_fck_rate;\n\n\tktime_t last_vblank;\n\tunsigned int hvtotal_us;\n\n\tstruct drm_framebuffer *next_fb;\n\n\t \n\tbool simulate_vesa_sync;\n\n\tint sync_lost_count;\n\tbool frame_intact;\n\tstruct work_struct recover_work;\n\n\tdma_addr_t palette_dma_handle;\n\tu16 *palette_base;\n\tstruct completion palette_loaded;\n};\n#define to_tilcdc_crtc(x) container_of(x, struct tilcdc_crtc, base)\n\nstatic void set_scanout(struct drm_crtc *crtc, struct drm_framebuffer *fb)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tstruct drm_gem_dma_object *gem;\n\tdma_addr_t start, end;\n\tu64 dma_base_and_ceiling;\n\n\tgem = drm_fb_dma_get_gem_obj(fb, 0);\n\n\tstart = gem->dma_addr + fb->offsets[0] +\n\t\tcrtc->y * fb->pitches[0] +\n\t\tcrtc->x * fb->format->cpp[0];\n\n\tend = start + (crtc->mode.vdisplay * fb->pitches[0]);\n\n\t \n\tif (priv->rev == 1)\n\t\tend -= 1;\n\n\tdma_base_and_ceiling = (u64)end << 32 | start;\n\ttilcdc_write64(dev, LCDC_DMA_FB_BASE_ADDR_0_REG, dma_base_and_ceiling);\n}\n\n \nstatic void tilcdc_crtc_load_palette(struct drm_crtc *crtc)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tint ret;\n\n\treinit_completion(&tilcdc_crtc->palette_loaded);\n\n\t \n\ttilcdc_write(dev, LCDC_DMA_FB_BASE_ADDR_0_REG,\n\t\t     tilcdc_crtc->palette_dma_handle);\n\ttilcdc_write(dev, LCDC_DMA_FB_CEILING_ADDR_0_REG,\n\t\t     (u32) tilcdc_crtc->palette_dma_handle +\n\t\t     TILCDC_PALETTE_SIZE - 1);\n\n\t \n\ttilcdc_write_mask(dev, LCDC_RASTER_CTRL_REG,\n\t\t\t  LCDC_PALETTE_LOAD_MODE(PALETTE_ONLY),\n\t\t\t  LCDC_PALETTE_LOAD_MODE_MASK);\n\n\t \n\tif (priv->rev == 1)\n\t\ttilcdc_set(dev, LCDC_RASTER_CTRL_REG, LCDC_V1_PL_INT_ENA);\n\telse\n\t\ttilcdc_write(dev, LCDC_INT_ENABLE_SET_REG, LCDC_V2_PL_INT_ENA);\n\n\t \n\ttilcdc_clear_irqstatus(dev, 0xffffffff);\n\ttilcdc_set(dev, LCDC_RASTER_CTRL_REG, LCDC_RASTER_ENABLE);\n\n\tret = wait_for_completion_timeout(&tilcdc_crtc->palette_loaded,\n\t\t\t\t\t  msecs_to_jiffies(50));\n\tif (ret == 0)\n\t\tdev_err(dev->dev, \"%s: Palette loading timeout\", __func__);\n\n\t \n\ttilcdc_clear(dev, LCDC_RASTER_CTRL_REG, LCDC_RASTER_ENABLE);\n\tif (priv->rev == 1)\n\t\ttilcdc_clear(dev, LCDC_RASTER_CTRL_REG, LCDC_V1_PL_INT_ENA);\n\telse\n\t\ttilcdc_write(dev, LCDC_INT_ENABLE_CLR_REG, LCDC_V2_PL_INT_ENA);\n}\n\nstatic void tilcdc_crtc_enable_irqs(struct drm_device *dev)\n{\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\n\ttilcdc_clear_irqstatus(dev, 0xffffffff);\n\n\tif (priv->rev == 1) {\n\t\ttilcdc_set(dev, LCDC_RASTER_CTRL_REG,\n\t\t\tLCDC_V1_SYNC_LOST_INT_ENA | LCDC_V1_FRAME_DONE_INT_ENA |\n\t\t\tLCDC_V1_UNDERFLOW_INT_ENA);\n\t} else {\n\t\ttilcdc_write(dev, LCDC_INT_ENABLE_SET_REG,\n\t\t\tLCDC_V2_UNDERFLOW_INT_ENA |\n\t\t\tLCDC_FRAME_DONE | LCDC_SYNC_LOST);\n\t}\n}\n\nstatic void tilcdc_crtc_disable_irqs(struct drm_device *dev)\n{\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\n\t \n\tif (priv->rev == 1) {\n\t\ttilcdc_clear(dev, LCDC_RASTER_CTRL_REG,\n\t\t\tLCDC_V1_SYNC_LOST_INT_ENA | LCDC_V1_FRAME_DONE_INT_ENA |\n\t\t\tLCDC_V1_UNDERFLOW_INT_ENA | LCDC_V1_PL_INT_ENA);\n\t\ttilcdc_clear(dev, LCDC_DMA_CTRL_REG,\n\t\t\tLCDC_V1_END_OF_FRAME_INT_ENA);\n\t} else {\n\t\ttilcdc_write(dev, LCDC_INT_ENABLE_CLR_REG,\n\t\t\tLCDC_V2_UNDERFLOW_INT_ENA | LCDC_V2_PL_INT_ENA |\n\t\t\tLCDC_V2_END_OF_FRAME0_INT_ENA |\n\t\t\tLCDC_FRAME_DONE | LCDC_SYNC_LOST);\n\t}\n}\n\nstatic void reset(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\n\tif (priv->rev != 2)\n\t\treturn;\n\n\ttilcdc_set(dev, LCDC_CLK_RESET_REG, LCDC_CLK_MAIN_RESET);\n\tusleep_range(250, 1000);\n\ttilcdc_clear(dev, LCDC_CLK_RESET_REG, LCDC_CLK_MAIN_RESET);\n}\n\n \nstatic unsigned int tilcdc_pclk_diff(unsigned long rate,\n\t\t\t\t     unsigned long real_rate)\n{\n\tint r = rate / 100, rr = real_rate / 100;\n\n\treturn (unsigned int)(abs(((rr - r) * 100) / r));\n}\n\nstatic void tilcdc_crtc_set_clk(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\tunsigned long clk_rate, real_pclk_rate, pclk_rate;\n\tunsigned int clkdiv;\n\tint ret;\n\n\tclkdiv = 2;  \n\n\t \n\tpclk_rate = crtc->mode.clock * 1000;\n\n\tret = clk_set_rate(priv->clk, pclk_rate * clkdiv);\n\tclk_rate = clk_get_rate(priv->clk);\n\treal_pclk_rate = clk_rate / clkdiv;\n\tif (ret < 0 || tilcdc_pclk_diff(pclk_rate, real_pclk_rate) > 5) {\n\t\t \n\t\tif (!clk_rate) {\n\t\t\t \n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"failed to set the pixel clock - unable to read current lcdc clock rate\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tclkdiv = DIV_ROUND_CLOSEST(clk_rate, pclk_rate);\n\n\t\t \n\t\treal_pclk_rate = clk_rate / clkdiv;\n\n\t\tif (tilcdc_pclk_diff(pclk_rate, real_pclk_rate) > 5) {\n\t\t\tdev_warn(dev->dev,\n\t\t\t\t \"effective pixel clock rate (%luHz) differs from the requested rate (%luHz)\\n\",\n\t\t\t\t real_pclk_rate, pclk_rate);\n\t\t}\n\t}\n\n\ttilcdc_crtc->lcd_fck_rate = clk_rate;\n\n\tDBG(\"lcd_clk=%u, mode clock=%d, div=%u\",\n\t    tilcdc_crtc->lcd_fck_rate, crtc->mode.clock, clkdiv);\n\n\t \n\ttilcdc_write(dev, LCDC_CTRL_REG, LCDC_CLK_DIVISOR(clkdiv) |\n\t\t     LCDC_RASTER_MODE);\n\n\tif (priv->rev == 2)\n\t\ttilcdc_set(dev, LCDC_CLK_ENABLE_REG,\n\t\t\t\tLCDC_V2_DMA_CLK_EN | LCDC_V2_LIDD_CLK_EN |\n\t\t\t\tLCDC_V2_CORE_CLK_EN);\n}\n\nstatic uint tilcdc_mode_hvtotal(const struct drm_display_mode *mode)\n{\n\treturn (uint) div_u64(1000llu * mode->htotal * mode->vtotal,\n\t\t\t      mode->clock);\n}\n\nstatic void tilcdc_crtc_set_mode(struct drm_crtc *crtc)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tconst struct tilcdc_panel_info *info = tilcdc_crtc->info;\n\tuint32_t reg, hbp, hfp, hsw, vbp, vfp, vsw;\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct drm_framebuffer *fb = crtc->primary->state->fb;\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\tif (WARN_ON(!fb))\n\t\treturn;\n\n\t \n\treg = tilcdc_read(dev, LCDC_DMA_CTRL_REG) & ~0x00000770;\n\tswitch (info->dma_burst_sz) {\n\tcase 1:\n\t\treg |= LCDC_DMA_BURST_SIZE(LCDC_DMA_BURST_1);\n\t\tbreak;\n\tcase 2:\n\t\treg |= LCDC_DMA_BURST_SIZE(LCDC_DMA_BURST_2);\n\t\tbreak;\n\tcase 4:\n\t\treg |= LCDC_DMA_BURST_SIZE(LCDC_DMA_BURST_4);\n\t\tbreak;\n\tcase 8:\n\t\treg |= LCDC_DMA_BURST_SIZE(LCDC_DMA_BURST_8);\n\t\tbreak;\n\tcase 16:\n\t\treg |= LCDC_DMA_BURST_SIZE(LCDC_DMA_BURST_16);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"invalid burst size\\n\");\n\t\treturn;\n\t}\n\treg |= (info->fifo_th << 8);\n\ttilcdc_write(dev, LCDC_DMA_CTRL_REG, reg);\n\n\t \n\thbp = mode->htotal - mode->hsync_end;\n\thfp = mode->hsync_start - mode->hdisplay;\n\thsw = mode->hsync_end - mode->hsync_start;\n\tvbp = mode->vtotal - mode->vsync_end;\n\tvfp = mode->vsync_start - mode->vdisplay;\n\tvsw = mode->vsync_end - mode->vsync_start;\n\n\tDBG(\"%dx%d, hbp=%u, hfp=%u, hsw=%u, vbp=%u, vfp=%u, vsw=%u\",\n\t    mode->hdisplay, mode->vdisplay, hbp, hfp, hsw, vbp, vfp, vsw);\n\n\t \n\treg = tilcdc_read(dev, LCDC_RASTER_TIMING_2_REG) & ~0x000fff00;\n\treg |= LCDC_AC_BIAS_FREQUENCY(info->ac_bias) |\n\t\tLCDC_AC_BIAS_TRANSITIONS_PER_INT(info->ac_bias_intrpt);\n\n\t \n\tif (priv->rev == 2) {\n\t\t \n\t\treg &= ~0x78000033;\n\t\treg |= ((hfp-1) & 0x300) >> 8;\n\t\treg |= ((hbp-1) & 0x300) >> 4;\n\t\treg |= ((hsw-1) & 0x3c0) << 21;\n\t}\n\ttilcdc_write(dev, LCDC_RASTER_TIMING_2_REG, reg);\n\n\treg = (((mode->hdisplay >> 4) - 1) << 4) |\n\t\t(((hbp-1) & 0xff) << 24) |\n\t\t(((hfp-1) & 0xff) << 16) |\n\t\t(((hsw-1) & 0x3f) << 10);\n\tif (priv->rev == 2)\n\t\treg |= (((mode->hdisplay >> 4) - 1) & 0x40) >> 3;\n\ttilcdc_write(dev, LCDC_RASTER_TIMING_0_REG, reg);\n\n\treg = ((mode->vdisplay - 1) & 0x3ff) |\n\t\t((vbp & 0xff) << 24) |\n\t\t((vfp & 0xff) << 16) |\n\t\t(((vsw-1) & 0x3f) << 10);\n\ttilcdc_write(dev, LCDC_RASTER_TIMING_1_REG, reg);\n\n\t \n\tif (priv->rev == 2) {\n\t\tif ((mode->vdisplay - 1) & 0x400) {\n\t\t\ttilcdc_set(dev, LCDC_RASTER_TIMING_2_REG,\n\t\t\t\tLCDC_LPP_B10);\n\t\t} else {\n\t\t\ttilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG,\n\t\t\t\tLCDC_LPP_B10);\n\t\t}\n\t}\n\n\t \n\treg = tilcdc_read(dev, LCDC_RASTER_CTRL_REG) &\n\t\t~(LCDC_TFT_MODE | LCDC_MONO_8BIT_MODE | LCDC_MONOCHROME_MODE |\n\t\t  LCDC_V2_TFT_24BPP_MODE | LCDC_V2_TFT_24BPP_UNPACK |\n\t\t  0x000ff000  );\n\treg |= LCDC_TFT_MODE;  \n\tif (info->tft_alt_mode)\n\t\treg |= LCDC_TFT_ALT_ENABLE;\n\tif (priv->rev == 2) {\n\t\tswitch (fb->format->format) {\n\t\tcase DRM_FORMAT_BGR565:\n\t\tcase DRM_FORMAT_RGB565:\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_XBGR8888:\n\t\tcase DRM_FORMAT_XRGB8888:\n\t\t\treg |= LCDC_V2_TFT_24BPP_UNPACK;\n\t\t\tfallthrough;\n\t\tcase DRM_FORMAT_BGR888:\n\t\tcase DRM_FORMAT_RGB888:\n\t\t\treg |= LCDC_V2_TFT_24BPP_MODE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev->dev, \"invalid pixel format\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\treg |= info->fdd << 12;\n\ttilcdc_write(dev, LCDC_RASTER_CTRL_REG, reg);\n\n\tif (info->invert_pxl_clk)\n\t\ttilcdc_set(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_PIXEL_CLOCK);\n\telse\n\t\ttilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_PIXEL_CLOCK);\n\n\tif (info->sync_ctrl)\n\t\ttilcdc_set(dev, LCDC_RASTER_TIMING_2_REG, LCDC_SYNC_CTRL);\n\telse\n\t\ttilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG, LCDC_SYNC_CTRL);\n\n\tif (info->sync_edge)\n\t\ttilcdc_set(dev, LCDC_RASTER_TIMING_2_REG, LCDC_SYNC_EDGE);\n\telse\n\t\ttilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG, LCDC_SYNC_EDGE);\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\ttilcdc_set(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_HSYNC);\n\telse\n\t\ttilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_HSYNC);\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\ttilcdc_set(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_VSYNC);\n\telse\n\t\ttilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_VSYNC);\n\n\tif (info->raster_order)\n\t\ttilcdc_set(dev, LCDC_RASTER_CTRL_REG, LCDC_RASTER_ORDER);\n\telse\n\t\ttilcdc_clear(dev, LCDC_RASTER_CTRL_REG, LCDC_RASTER_ORDER);\n\n\ttilcdc_crtc_set_clk(crtc);\n\n\ttilcdc_crtc_load_palette(crtc);\n\n\tset_scanout(crtc, fb);\n\n\tdrm_mode_copy(&crtc->hwmode, &crtc->state->adjusted_mode);\n\n\ttilcdc_crtc->hvtotal_us =\n\t\ttilcdc_mode_hvtotal(&crtc->hwmode);\n}\n\nstatic void tilcdc_crtc_enable(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\tunsigned long flags;\n\n\tmutex_lock(&tilcdc_crtc->enable_lock);\n\tif (tilcdc_crtc->enabled || tilcdc_crtc->shutdown) {\n\t\tmutex_unlock(&tilcdc_crtc->enable_lock);\n\t\treturn;\n\t}\n\n\tpm_runtime_get_sync(dev->dev);\n\n\treset(crtc);\n\n\ttilcdc_crtc_set_mode(crtc);\n\n\ttilcdc_crtc_enable_irqs(dev);\n\n\ttilcdc_clear(dev, LCDC_DMA_CTRL_REG, LCDC_DUAL_FRAME_BUFFER_ENABLE);\n\ttilcdc_write_mask(dev, LCDC_RASTER_CTRL_REG,\n\t\t\t  LCDC_PALETTE_LOAD_MODE(DATA_ONLY),\n\t\t\t  LCDC_PALETTE_LOAD_MODE_MASK);\n\n\t \n\tspin_lock_irqsave(&tilcdc_crtc->irq_lock, flags);\n\ttilcdc_crtc->last_vblank = ktime_get();\n\ttilcdc_set(dev, LCDC_RASTER_CTRL_REG, LCDC_RASTER_ENABLE);\n\tspin_unlock_irqrestore(&tilcdc_crtc->irq_lock, flags);\n\n\tdrm_crtc_vblank_on(crtc);\n\n\ttilcdc_crtc->enabled = true;\n\tmutex_unlock(&tilcdc_crtc->enable_lock);\n}\n\nstatic void tilcdc_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\ttilcdc_crtc_enable(crtc);\n}\n\nstatic void tilcdc_crtc_off(struct drm_crtc *crtc, bool shutdown)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tint ret;\n\n\tmutex_lock(&tilcdc_crtc->enable_lock);\n\tif (shutdown)\n\t\ttilcdc_crtc->shutdown = true;\n\tif (!tilcdc_crtc->enabled) {\n\t\tmutex_unlock(&tilcdc_crtc->enable_lock);\n\t\treturn;\n\t}\n\ttilcdc_crtc->frame_done = false;\n\ttilcdc_clear(dev, LCDC_RASTER_CTRL_REG, LCDC_RASTER_ENABLE);\n\n\t \n\tret = wait_event_timeout(tilcdc_crtc->frame_done_wq,\n\t\t\t\t tilcdc_crtc->frame_done,\n\t\t\t\t msecs_to_jiffies(500));\n\tif (ret == 0)\n\t\tdev_err(dev->dev, \"%s: timeout waiting for framedone\\n\",\n\t\t\t__func__);\n\n\tdrm_crtc_vblank_off(crtc);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\n\tif (crtc->state->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\n\tspin_unlock_irq(&crtc->dev->event_lock);\n\n\ttilcdc_crtc_disable_irqs(dev);\n\n\tpm_runtime_put_sync(dev->dev);\n\n\ttilcdc_crtc->enabled = false;\n\tmutex_unlock(&tilcdc_crtc->enable_lock);\n}\n\nstatic void tilcdc_crtc_disable(struct drm_crtc *crtc)\n{\n\ttilcdc_crtc_off(crtc, false);\n}\n\nstatic void tilcdc_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\ttilcdc_crtc_disable(crtc);\n}\n\nstatic void tilcdc_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tif (!crtc->state->event)\n\t\treturn;\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\tcrtc->state->event = NULL;\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nvoid tilcdc_crtc_shutdown(struct drm_crtc *crtc)\n{\n\ttilcdc_crtc_off(crtc, true);\n}\n\nstatic bool tilcdc_crtc_is_on(struct drm_crtc *crtc)\n{\n\treturn crtc->state && crtc->state->enable && crtc->state->active;\n}\n\nstatic void tilcdc_crtc_recover_work(struct work_struct *work)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc =\n\t\tcontainer_of(work, struct tilcdc_crtc, recover_work);\n\tstruct drm_crtc *crtc = &tilcdc_crtc->base;\n\n\tdev_info(crtc->dev->dev, \"%s: Reset CRTC\", __func__);\n\n\tdrm_modeset_lock(&crtc->mutex, NULL);\n\n\tif (!tilcdc_crtc_is_on(crtc))\n\t\tgoto out;\n\n\ttilcdc_crtc_disable(crtc);\n\ttilcdc_crtc_enable(crtc);\nout:\n\tdrm_modeset_unlock(&crtc->mutex);\n}\n\nstatic void tilcdc_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct tilcdc_drm_private *priv = crtc->dev->dev_private;\n\n\ttilcdc_crtc_shutdown(crtc);\n\n\tflush_workqueue(priv->wq);\n\n\tof_node_put(crtc->port);\n\tdrm_crtc_cleanup(crtc);\n}\n\nint tilcdc_crtc_update_fb(struct drm_crtc *crtc,\n\t\tstruct drm_framebuffer *fb,\n\t\tstruct drm_pending_vblank_event *event)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\n\tif (tilcdc_crtc->event) {\n\t\tdev_err(dev->dev, \"already pending page flip!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\ttilcdc_crtc->event = event;\n\n\tmutex_lock(&tilcdc_crtc->enable_lock);\n\n\tif (tilcdc_crtc->enabled) {\n\t\tunsigned long flags;\n\t\tktime_t next_vblank;\n\t\ts64 tdiff;\n\n\t\tspin_lock_irqsave(&tilcdc_crtc->irq_lock, flags);\n\n\t\tnext_vblank = ktime_add_us(tilcdc_crtc->last_vblank,\n\t\t\t\t\t   tilcdc_crtc->hvtotal_us);\n\t\ttdiff = ktime_to_us(ktime_sub(next_vblank, ktime_get()));\n\n\t\tif (tdiff < TILCDC_VBLANK_SAFETY_THRESHOLD_US)\n\t\t\ttilcdc_crtc->next_fb = fb;\n\t\telse\n\t\t\tset_scanout(crtc, fb);\n\n\t\tspin_unlock_irqrestore(&tilcdc_crtc->irq_lock, flags);\n\t}\n\n\tmutex_unlock(&tilcdc_crtc->enable_lock);\n\n\treturn 0;\n}\n\nstatic bool tilcdc_crtc_mode_fixup(struct drm_crtc *crtc,\n\t\tconst struct drm_display_mode *mode,\n\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\n\tif (!tilcdc_crtc->simulate_vesa_sync)\n\t\treturn true;\n\n\t \n\tadjusted_mode->hskew = mode->hsync_end - mode->hsync_start;\n\tadjusted_mode->flags |= DRM_MODE_FLAG_HSKEW;\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC) {\n\t\tadjusted_mode->flags |= DRM_MODE_FLAG_PHSYNC;\n\t\tadjusted_mode->flags &= ~DRM_MODE_FLAG_NHSYNC;\n\t} else {\n\t\tadjusted_mode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tadjusted_mode->flags &= ~DRM_MODE_FLAG_PHSYNC;\n\t}\n\n\treturn true;\n}\n\nstatic int tilcdc_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\t \n\tif (!crtc_state->active)\n\t\treturn 0;\n\n\tif (state->planes[0].ptr != crtc->primary ||\n\t    state->planes[0].state == NULL ||\n\t    state->planes[0].state->crtc != crtc) {\n\t\tdev_dbg(crtc->dev->dev, \"CRTC primary plane must be present\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tilcdc_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tilcdc_crtc->irq_lock, flags);\n\n\ttilcdc_clear_irqstatus(dev, LCDC_END_OF_FRAME0);\n\n\tif (priv->rev == 1)\n\t\ttilcdc_set(dev, LCDC_DMA_CTRL_REG,\n\t\t\t   LCDC_V1_END_OF_FRAME_INT_ENA);\n\telse\n\t\ttilcdc_set(dev, LCDC_INT_ENABLE_SET_REG,\n\t\t\t   LCDC_V2_END_OF_FRAME0_INT_ENA);\n\n\tspin_unlock_irqrestore(&tilcdc_crtc->irq_lock, flags);\n\n\treturn 0;\n}\n\nstatic void tilcdc_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tilcdc_crtc->irq_lock, flags);\n\n\tif (priv->rev == 1)\n\t\ttilcdc_clear(dev, LCDC_DMA_CTRL_REG,\n\t\t\t     LCDC_V1_END_OF_FRAME_INT_ENA);\n\telse\n\t\ttilcdc_clear(dev, LCDC_INT_ENABLE_SET_REG,\n\t\t\t     LCDC_V2_END_OF_FRAME0_INT_ENA);\n\n\tspin_unlock_irqrestore(&tilcdc_crtc->irq_lock, flags);\n}\n\nstatic void tilcdc_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tint ret;\n\n\tdrm_atomic_helper_crtc_reset(crtc);\n\n\t \n\tpm_runtime_get_sync(dev->dev);\n\tif (tilcdc_read(dev, LCDC_RASTER_CTRL_REG) & LCDC_RASTER_ENABLE) {\n\t\t \n\t\ttilcdc_write(dev, LCDC_INT_ENABLE_SET_REG, LCDC_FRAME_DONE);\n\t\ttilcdc_clear_irqstatus(dev, 0xffffffff);\n\n\t\ttilcdc_crtc->frame_done = false;\n\t\ttilcdc_clear(dev, LCDC_RASTER_CTRL_REG, LCDC_RASTER_ENABLE);\n\n\t\tret = wait_event_timeout(tilcdc_crtc->frame_done_wq,\n\t\t\t\t\t tilcdc_crtc->frame_done,\n\t\t\t\t\t msecs_to_jiffies(500));\n\t\tif (ret == 0)\n\t\t\tdev_err(dev->dev, \"%s: timeout waiting for framedone\\n\",\n\t\t\t\t__func__);\n\t}\n\tpm_runtime_put_sync(dev->dev);\n}\n\nstatic const struct drm_crtc_funcs tilcdc_crtc_funcs = {\n\t.destroy        = tilcdc_crtc_destroy,\n\t.set_config     = drm_atomic_helper_set_config,\n\t.page_flip      = drm_atomic_helper_page_flip,\n\t.reset\t\t= tilcdc_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank\t= tilcdc_crtc_enable_vblank,\n\t.disable_vblank\t= tilcdc_crtc_disable_vblank,\n};\n\nstatic enum drm_mode_status\ntilcdc_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t       const struct drm_display_mode *mode)\n{\n\tstruct tilcdc_drm_private *priv = crtc->dev->dev_private;\n\tunsigned int bandwidth;\n\tuint32_t hbp, hfp, hsw, vbp, vfp, vsw;\n\n\t \n\tif (mode->hdisplay > priv->max_width)\n\t\treturn MODE_VIRTUAL_X;\n\n\t \n\tif (mode->hdisplay & 0xf)\n\t\treturn MODE_VIRTUAL_X;\n\n\tif (mode->vdisplay > 2048)\n\t\treturn MODE_VIRTUAL_Y;\n\n\tDBG(\"Processing mode %dx%d@%d with pixel clock %d\",\n\t\tmode->hdisplay, mode->vdisplay,\n\t\tdrm_mode_vrefresh(mode), mode->clock);\n\n\thbp = mode->htotal - mode->hsync_end;\n\thfp = mode->hsync_start - mode->hdisplay;\n\thsw = mode->hsync_end - mode->hsync_start;\n\tvbp = mode->vtotal - mode->vsync_end;\n\tvfp = mode->vsync_start - mode->vdisplay;\n\tvsw = mode->vsync_end - mode->vsync_start;\n\n\tif ((hbp-1) & ~0x3ff) {\n\t\tDBG(\"Pruning mode: Horizontal Back Porch out of range\");\n\t\treturn MODE_HBLANK_WIDE;\n\t}\n\n\tif ((hfp-1) & ~0x3ff) {\n\t\tDBG(\"Pruning mode: Horizontal Front Porch out of range\");\n\t\treturn MODE_HBLANK_WIDE;\n\t}\n\n\tif ((hsw-1) & ~0x3ff) {\n\t\tDBG(\"Pruning mode: Horizontal Sync Width out of range\");\n\t\treturn MODE_HSYNC_WIDE;\n\t}\n\n\tif (vbp & ~0xff) {\n\t\tDBG(\"Pruning mode: Vertical Back Porch out of range\");\n\t\treturn MODE_VBLANK_WIDE;\n\t}\n\n\tif (vfp & ~0xff) {\n\t\tDBG(\"Pruning mode: Vertical Front Porch out of range\");\n\t\treturn MODE_VBLANK_WIDE;\n\t}\n\n\tif ((vsw-1) & ~0x3f) {\n\t\tDBG(\"Pruning mode: Vertical Sync Width out of range\");\n\t\treturn MODE_VSYNC_WIDE;\n\t}\n\n\t \n\tif (mode->clock > priv->max_pixelclock) {\n\t\tDBG(\"Pruning mode: pixel clock too high\");\n\t\treturn MODE_CLOCK_HIGH;\n\t}\n\n\t \n\tif (mode->hdisplay > priv->max_width)\n\t\treturn MODE_BAD_WIDTH;\n\n\t \n\tbandwidth = mode->hdisplay * mode->vdisplay *\n\t\tdrm_mode_vrefresh(mode);\n\tif (bandwidth > priv->max_bandwidth) {\n\t\tDBG(\"Pruning mode: exceeds defined bandwidth limit\");\n\t\treturn MODE_BAD;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_crtc_helper_funcs tilcdc_crtc_helper_funcs = {\n\t.mode_valid\t= tilcdc_crtc_mode_valid,\n\t.mode_fixup\t= tilcdc_crtc_mode_fixup,\n\t.atomic_check\t= tilcdc_crtc_atomic_check,\n\t.atomic_enable\t= tilcdc_crtc_atomic_enable,\n\t.atomic_disable\t= tilcdc_crtc_atomic_disable,\n\t.atomic_flush\t= tilcdc_crtc_atomic_flush,\n};\n\nvoid tilcdc_crtc_set_panel_info(struct drm_crtc *crtc,\n\t\tconst struct tilcdc_panel_info *info)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\ttilcdc_crtc->info = info;\n}\n\nvoid tilcdc_crtc_set_simulate_vesa_sync(struct drm_crtc *crtc,\n\t\t\t\t\tbool simulate_vesa_sync)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\n\ttilcdc_crtc->simulate_vesa_sync = simulate_vesa_sync;\n}\n\nvoid tilcdc_crtc_update_clk(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\n\tdrm_modeset_lock(&crtc->mutex, NULL);\n\tif (tilcdc_crtc->lcd_fck_rate != clk_get_rate(priv->clk)) {\n\t\tif (tilcdc_crtc_is_on(crtc)) {\n\t\t\tpm_runtime_get_sync(dev->dev);\n\t\t\ttilcdc_crtc_disable(crtc);\n\n\t\t\ttilcdc_crtc_set_clk(crtc);\n\n\t\t\ttilcdc_crtc_enable(crtc);\n\t\t\tpm_runtime_put_sync(dev->dev);\n\t\t}\n\t}\n\tdrm_modeset_unlock(&crtc->mutex);\n}\n\n#define SYNC_LOST_COUNT_LIMIT 50\n\nirqreturn_t tilcdc_crtc_irq(struct drm_crtc *crtc)\n{\n\tstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tuint32_t stat, reg;\n\n\tstat = tilcdc_read_irqstatus(dev);\n\ttilcdc_clear_irqstatus(dev, stat);\n\n\tif (stat & LCDC_END_OF_FRAME0) {\n\t\tbool skip_event = false;\n\t\tktime_t now;\n\n\t\tnow = ktime_get();\n\n\t\tspin_lock(&tilcdc_crtc->irq_lock);\n\n\t\ttilcdc_crtc->last_vblank = now;\n\n\t\tif (tilcdc_crtc->next_fb) {\n\t\t\tset_scanout(crtc, tilcdc_crtc->next_fb);\n\t\t\ttilcdc_crtc->next_fb = NULL;\n\t\t\tskip_event = true;\n\t\t}\n\n\t\tspin_unlock(&tilcdc_crtc->irq_lock);\n\n\t\tdrm_crtc_handle_vblank(crtc);\n\n\t\tif (!skip_event) {\n\t\t\tstruct drm_pending_vblank_event *event;\n\n\t\t\tspin_lock(&dev->event_lock);\n\n\t\t\tevent = tilcdc_crtc->event;\n\t\t\ttilcdc_crtc->event = NULL;\n\t\t\tif (event)\n\t\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\n\t\t\tspin_unlock(&dev->event_lock);\n\t\t}\n\n\t\tif (tilcdc_crtc->frame_intact)\n\t\t\ttilcdc_crtc->sync_lost_count = 0;\n\t\telse\n\t\t\ttilcdc_crtc->frame_intact = true;\n\t}\n\n\tif (stat & LCDC_FIFO_UNDERFLOW)\n\t\tdev_err_ratelimited(dev->dev, \"%s(0x%08x): FIFO underflow\",\n\t\t\t\t    __func__, stat);\n\n\tif (stat & LCDC_PL_LOAD_DONE) {\n\t\tcomplete(&tilcdc_crtc->palette_loaded);\n\t\tif (priv->rev == 1)\n\t\t\ttilcdc_clear(dev, LCDC_RASTER_CTRL_REG,\n\t\t\t\t     LCDC_V1_PL_INT_ENA);\n\t\telse\n\t\t\ttilcdc_write(dev, LCDC_INT_ENABLE_CLR_REG,\n\t\t\t\t     LCDC_V2_PL_INT_ENA);\n\t}\n\n\tif (stat & LCDC_SYNC_LOST) {\n\t\tdev_err_ratelimited(dev->dev, \"%s(0x%08x): Sync lost\",\n\t\t\t\t    __func__, stat);\n\t\ttilcdc_crtc->frame_intact = false;\n\t\tif (priv->rev == 1) {\n\t\t\treg = tilcdc_read(dev, LCDC_RASTER_CTRL_REG);\n\t\t\tif (reg & LCDC_RASTER_ENABLE) {\n\t\t\t\ttilcdc_clear(dev, LCDC_RASTER_CTRL_REG,\n\t\t\t\t\t     LCDC_RASTER_ENABLE);\n\t\t\t\ttilcdc_set(dev, LCDC_RASTER_CTRL_REG,\n\t\t\t\t\t   LCDC_RASTER_ENABLE);\n\t\t\t}\n\t\t} else {\n\t\t\tif (tilcdc_crtc->sync_lost_count++ >\n\t\t\t    SYNC_LOST_COUNT_LIMIT) {\n\t\t\t\tdev_err(dev->dev,\n\t\t\t\t\t\"%s(0x%08x): Sync lost flood detected, recovering\",\n\t\t\t\t\t__func__, stat);\n\t\t\t\tqueue_work(system_wq,\n\t\t\t\t\t   &tilcdc_crtc->recover_work);\n\t\t\t\ttilcdc_write(dev, LCDC_INT_ENABLE_CLR_REG,\n\t\t\t\t\t     LCDC_SYNC_LOST);\n\t\t\t\ttilcdc_crtc->sync_lost_count = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stat & LCDC_FRAME_DONE) {\n\t\ttilcdc_crtc->frame_done = true;\n\t\twake_up(&tilcdc_crtc->frame_done_wq);\n\t\t \n\t\tif (priv->rev == 1)\n\t\t\ttilcdc_clear(dev, LCDC_RASTER_CTRL_REG,\n\t\t\t\t     LCDC_V1_FRAME_DONE_INT_ENA);\n\t}\n\n\t \n\tif (priv->rev == 2) {\n\t\t \n\t\ttilcdc_write(dev, LCDC_END_OF_INT_IND_REG, 0);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nint tilcdc_crtc_create(struct drm_device *dev)\n{\n\tstruct tilcdc_drm_private *priv = dev->dev_private;\n\tstruct tilcdc_crtc *tilcdc_crtc;\n\tstruct drm_crtc *crtc;\n\tint ret;\n\n\ttilcdc_crtc = devm_kzalloc(dev->dev, sizeof(*tilcdc_crtc), GFP_KERNEL);\n\tif (!tilcdc_crtc)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&tilcdc_crtc->palette_loaded);\n\ttilcdc_crtc->palette_base = dmam_alloc_coherent(dev->dev,\n\t\t\t\t\tTILCDC_PALETTE_SIZE,\n\t\t\t\t\t&tilcdc_crtc->palette_dma_handle,\n\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!tilcdc_crtc->palette_base)\n\t\treturn -ENOMEM;\n\t*tilcdc_crtc->palette_base = TILCDC_PALETTE_FIRST_ENTRY;\n\n\tcrtc = &tilcdc_crtc->base;\n\n\tret = tilcdc_plane_init(dev, &tilcdc_crtc->primary);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tmutex_init(&tilcdc_crtc->enable_lock);\n\n\tinit_waitqueue_head(&tilcdc_crtc->frame_done_wq);\n\n\tspin_lock_init(&tilcdc_crtc->irq_lock);\n\tINIT_WORK(&tilcdc_crtc->recover_work, tilcdc_crtc_recover_work);\n\n\tret = drm_crtc_init_with_planes(dev, crtc,\n\t\t\t\t\t&tilcdc_crtc->primary,\n\t\t\t\t\tNULL,\n\t\t\t\t\t&tilcdc_crtc_funcs,\n\t\t\t\t\t\"tilcdc crtc\");\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tdrm_crtc_helper_add(crtc, &tilcdc_crtc_helper_funcs);\n\n\tif (priv->is_componentized) {\n\t\tcrtc->port = of_graph_get_port_by_id(dev->dev->of_node, 0);\n\t\tif (!crtc->port) {  \n\t\t\tdev_err(dev->dev, \"Port node not found in %pOF\\n\",\n\t\t\t\tdev->dev->of_node);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tpriv->crtc = crtc;\n\treturn 0;\n\nfail:\n\ttilcdc_crtc_destroy(crtc);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}