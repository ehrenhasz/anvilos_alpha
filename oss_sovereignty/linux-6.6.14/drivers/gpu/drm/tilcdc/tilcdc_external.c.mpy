{
  "module_name": "tilcdc_external.c",
  "hash_id": "f71f5208bd31749d6a2d5683556b3fd11529ad932cf01d662c88351063cd6246",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tilcdc/tilcdc_external.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/of_graph.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_of.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"tilcdc_drv.h\"\n#include \"tilcdc_external.h\"\n\nstatic const struct tilcdc_panel_info panel_info_tda998x = {\n\t\t.ac_bias                = 255,\n\t\t.ac_bias_intrpt         = 0,\n\t\t.dma_burst_sz           = 16,\n\t\t.bpp                    = 16,\n\t\t.fdd                    = 0x80,\n\t\t.tft_alt_mode           = 0,\n\t\t.invert_pxl_clk\t\t= 1,\n\t\t.sync_edge              = 1,\n\t\t.sync_ctrl              = 1,\n\t\t.raster_order           = 0,\n};\n\nstatic const struct tilcdc_panel_info panel_info_default = {\n\t\t.ac_bias                = 255,\n\t\t.ac_bias_intrpt         = 0,\n\t\t.dma_burst_sz           = 16,\n\t\t.bpp                    = 16,\n\t\t.fdd                    = 0x80,\n\t\t.tft_alt_mode           = 0,\n\t\t.sync_edge              = 0,\n\t\t.sync_ctrl              = 1,\n\t\t.raster_order           = 0,\n};\n\nstatic\nstruct drm_connector *tilcdc_encoder_find_connector(struct drm_device *ddev,\n\t\t\t\t\t\t    struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector;\n\n\tlist_for_each_entry(connector, &ddev->mode_config.connector_list, head) {\n\t\tif (drm_connector_has_possible_encoder(connector, encoder))\n\t\t\treturn connector;\n\t}\n\n\tdev_err(ddev->dev, \"No connector found for %s encoder (id %d)\\n\",\n\t\tencoder->name, encoder->base.id);\n\n\treturn NULL;\n}\n\nint tilcdc_add_component_encoder(struct drm_device *ddev)\n{\n\tstruct tilcdc_drm_private *priv = ddev->dev_private;\n\tstruct drm_encoder *encoder = NULL, *iter;\n\n\tlist_for_each_entry(iter, &ddev->mode_config.encoder_list, head)\n\t\tif (iter->possible_crtcs & (1 << priv->crtc->index)) {\n\t\t\tencoder = iter;\n\t\t\tbreak;\n\t\t}\n\n\tif (!encoder) {\n\t\tdev_err(ddev->dev, \"%s: No suitable encoder found\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->external_connector =\n\t\ttilcdc_encoder_find_connector(ddev, encoder);\n\n\tif (!priv->external_connector)\n\t\treturn -ENODEV;\n\n\t \n\ttilcdc_crtc_set_simulate_vesa_sync(priv->crtc, true);\n\ttilcdc_crtc_set_panel_info(priv->crtc, &panel_info_tda998x);\n\n\treturn 0;\n}\n\nstatic\nint tilcdc_attach_bridge(struct drm_device *ddev, struct drm_bridge *bridge)\n{\n\tstruct tilcdc_drm_private *priv = ddev->dev_private;\n\tint ret;\n\n\tpriv->external_encoder->possible_crtcs = BIT(0);\n\n\tret = drm_bridge_attach(priv->external_encoder, bridge, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\ttilcdc_crtc_set_panel_info(priv->crtc, &panel_info_default);\n\n\tpriv->external_connector =\n\t\ttilcdc_encoder_find_connector(ddev, priv->external_encoder);\n\tif (!priv->external_connector)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nint tilcdc_attach_external_device(struct drm_device *ddev)\n{\n\tstruct tilcdc_drm_private *priv = ddev->dev_private;\n\tstruct drm_bridge *bridge;\n\tstruct drm_panel *panel;\n\tint ret;\n\n\tret = drm_of_find_panel_or_bridge(ddev->dev->of_node, 0, 0,\n\t\t\t\t\t  &panel, &bridge);\n\tif (ret == -ENODEV)\n\t\treturn 0;\n\telse if (ret)\n\t\treturn ret;\n\n\tpriv->external_encoder = devm_kzalloc(ddev->dev,\n\t\t\t\t\t      sizeof(*priv->external_encoder),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!priv->external_encoder)\n\t\treturn -ENOMEM;\n\n\tret = drm_simple_encoder_init(ddev, priv->external_encoder,\n\t\t\t\t      DRM_MODE_ENCODER_NONE);\n\tif (ret) {\n\t\tdev_err(ddev->dev, \"drm_encoder_init() failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (panel) {\n\t\tbridge = devm_drm_panel_bridge_add_typed(ddev->dev, panel,\n\t\t\t\t\t\t\t DRM_MODE_CONNECTOR_DPI);\n\t\tif (IS_ERR(bridge)) {\n\t\t\tret = PTR_ERR(bridge);\n\t\t\tgoto err_encoder_cleanup;\n\t\t}\n\t}\n\n\tret = tilcdc_attach_bridge(ddev, bridge);\n\tif (ret)\n\t\tgoto err_encoder_cleanup;\n\n\treturn 0;\n\nerr_encoder_cleanup:\n\tdrm_encoder_cleanup(priv->external_encoder);\n\treturn ret;\n}\n\nstatic int dev_match_of(struct device *dev, void *data)\n{\n\treturn dev->of_node == data;\n}\n\nint tilcdc_get_external_components(struct device *dev,\n\t\t\t\t   struct component_match **match)\n{\n\tstruct device_node *node;\n\n\tnode = of_graph_get_remote_node(dev->of_node, 0, 0);\n\n\tif (!of_device_is_compatible(node, \"nxp,tda998x\")) {\n\t\tof_node_put(node);\n\t\treturn 0;\n\t}\n\n\tif (match)\n\t\tdrm_of_component_match_add(dev, match, dev_match_of, node);\n\tof_node_put(node);\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}