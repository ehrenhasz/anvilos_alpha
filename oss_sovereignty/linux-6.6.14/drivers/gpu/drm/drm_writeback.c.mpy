{
  "module_name": "drm_writeback.c",
  "hash_id": "76a0ae09bd30d7edaf485a0999d1269296f62793327fd2e1c501533213d9d1ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_writeback.c",
  "human_readable_source": "\n \n\n#include <linux/dma-fence.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_property.h>\n#include <drm/drm_writeback.h>\n\n \n\n#define fence_to_wb_connector(x) container_of(x->lock, \\\n\t\t\t\t\t      struct drm_writeback_connector, \\\n\t\t\t\t\t      fence_lock)\n\nstatic const char *drm_writeback_fence_get_driver_name(struct dma_fence *fence)\n{\n\tstruct drm_writeback_connector *wb_connector =\n\t\tfence_to_wb_connector(fence);\n\n\treturn wb_connector->base.dev->driver->name;\n}\n\nstatic const char *\ndrm_writeback_fence_get_timeline_name(struct dma_fence *fence)\n{\n\tstruct drm_writeback_connector *wb_connector =\n\t\tfence_to_wb_connector(fence);\n\n\treturn wb_connector->timeline_name;\n}\n\nstatic bool drm_writeback_fence_enable_signaling(struct dma_fence *fence)\n{\n\treturn true;\n}\n\nstatic const struct dma_fence_ops drm_writeback_fence_ops = {\n\t.get_driver_name = drm_writeback_fence_get_driver_name,\n\t.get_timeline_name = drm_writeback_fence_get_timeline_name,\n\t.enable_signaling = drm_writeback_fence_enable_signaling,\n};\n\nstatic int create_writeback_properties(struct drm_device *dev)\n{\n\tstruct drm_property *prop;\n\n\tif (!dev->mode_config.writeback_fb_id_property) {\n\t\tprop = drm_property_create_object(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\t\t\t  \"WRITEBACK_FB_ID\",\n\t\t\t\t\t\t  DRM_MODE_OBJECT_FB);\n\t\tif (!prop)\n\t\t\treturn -ENOMEM;\n\t\tdev->mode_config.writeback_fb_id_property = prop;\n\t}\n\n\tif (!dev->mode_config.writeback_pixel_formats_property) {\n\t\tprop = drm_property_create(dev, DRM_MODE_PROP_BLOB |\n\t\t\t\t\t   DRM_MODE_PROP_ATOMIC |\n\t\t\t\t\t   DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t\t   \"WRITEBACK_PIXEL_FORMATS\", 0);\n\t\tif (!prop)\n\t\t\treturn -ENOMEM;\n\t\tdev->mode_config.writeback_pixel_formats_property = prop;\n\t}\n\n\tif (!dev->mode_config.writeback_out_fence_ptr_property) {\n\t\tprop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,\n\t\t\t\t\t\t \"WRITEBACK_OUT_FENCE_PTR\", 0,\n\t\t\t\t\t\t U64_MAX);\n\t\tif (!prop)\n\t\t\treturn -ENOMEM;\n\t\tdev->mode_config.writeback_out_fence_ptr_property = prop;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_funcs drm_writeback_encoder_funcs = {\n\t.destroy = drm_encoder_cleanup,\n};\n\n \nint drm_writeback_connector_init(struct drm_device *dev,\n\t\t\t\t struct drm_writeback_connector *wb_connector,\n\t\t\t\t const struct drm_connector_funcs *con_funcs,\n\t\t\t\t const struct drm_encoder_helper_funcs *enc_helper_funcs,\n\t\t\t\t const u32 *formats, int n_formats,\n\t\t\t\t u32 possible_crtcs)\n{\n\tint ret = 0;\n\n\tdrm_encoder_helper_add(&wb_connector->encoder, enc_helper_funcs);\n\n\twb_connector->encoder.possible_crtcs = possible_crtcs;\n\n\tret = drm_encoder_init(dev, &wb_connector->encoder,\n\t\t\t       &drm_writeback_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_VIRTUAL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_writeback_connector_init_with_encoder(dev, wb_connector, &wb_connector->encoder,\n\t\t\tcon_funcs, formats, n_formats);\n\n\tif (ret)\n\t\tdrm_encoder_cleanup(&wb_connector->encoder);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_writeback_connector_init);\n\n \nint drm_writeback_connector_init_with_encoder(struct drm_device *dev,\n\t\tstruct drm_writeback_connector *wb_connector, struct drm_encoder *enc,\n\t\tconst struct drm_connector_funcs *con_funcs, const u32 *formats,\n\t\tint n_formats)\n{\n\tstruct drm_property_blob *blob;\n\tstruct drm_connector *connector = &wb_connector->base;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tint ret = create_writeback_properties(dev);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tblob = drm_property_create_blob(dev, n_formats * sizeof(*formats),\n\t\t\t\t\tformats);\n\tif (IS_ERR(blob))\n\t\treturn PTR_ERR(blob);\n\n\n\tconnector->interlace_allowed = 0;\n\n\tret = drm_connector_init(dev, connector, con_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_WRITEBACK);\n\tif (ret)\n\t\tgoto connector_fail;\n\n\tret = drm_connector_attach_encoder(connector, enc);\n\tif (ret)\n\t\tgoto attach_fail;\n\n\tINIT_LIST_HEAD(&wb_connector->job_queue);\n\tspin_lock_init(&wb_connector->job_lock);\n\n\twb_connector->fence_context = dma_fence_context_alloc(1);\n\tspin_lock_init(&wb_connector->fence_lock);\n\tsnprintf(wb_connector->timeline_name,\n\t\t sizeof(wb_connector->timeline_name),\n\t\t \"CONNECTOR:%d-%s\", connector->base.id, connector->name);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->writeback_out_fence_ptr_property, 0);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->writeback_fb_id_property, 0);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->writeback_pixel_formats_property,\n\t\t\t\t   blob->base.id);\n\twb_connector->pixel_formats_blob_ptr = blob;\n\n\treturn 0;\n\nattach_fail:\n\tdrm_connector_cleanup(connector);\nconnector_fail:\n\tdrm_property_blob_put(blob);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_writeback_connector_init_with_encoder);\n\nint drm_writeback_set_fb(struct drm_connector_state *conn_state,\n\t\t\t struct drm_framebuffer *fb)\n{\n\tWARN_ON(conn_state->connector->connector_type != DRM_MODE_CONNECTOR_WRITEBACK);\n\n\tif (!conn_state->writeback_job) {\n\t\tconn_state->writeback_job =\n\t\t\tkzalloc(sizeof(*conn_state->writeback_job), GFP_KERNEL);\n\t\tif (!conn_state->writeback_job)\n\t\t\treturn -ENOMEM;\n\n\t\tconn_state->writeback_job->connector =\n\t\t\tdrm_connector_to_writeback(conn_state->connector);\n\t}\n\n\tdrm_framebuffer_assign(&conn_state->writeback_job->fb, fb);\n\treturn 0;\n}\n\nint drm_writeback_prepare_job(struct drm_writeback_job *job)\n{\n\tstruct drm_writeback_connector *connector = job->connector;\n\tconst struct drm_connector_helper_funcs *funcs =\n\t\tconnector->base.helper_private;\n\tint ret;\n\n\tif (funcs->prepare_writeback_job) {\n\t\tret = funcs->prepare_writeback_job(connector, job);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tjob->prepared = true;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_writeback_prepare_job);\n\n \nvoid drm_writeback_queue_job(struct drm_writeback_connector *wb_connector,\n\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct drm_writeback_job *job;\n\tunsigned long flags;\n\n\tjob = conn_state->writeback_job;\n\tconn_state->writeback_job = NULL;\n\n\tspin_lock_irqsave(&wb_connector->job_lock, flags);\n\tlist_add_tail(&job->list_entry, &wb_connector->job_queue);\n\tspin_unlock_irqrestore(&wb_connector->job_lock, flags);\n}\nEXPORT_SYMBOL(drm_writeback_queue_job);\n\nvoid drm_writeback_cleanup_job(struct drm_writeback_job *job)\n{\n\tstruct drm_writeback_connector *connector = job->connector;\n\tconst struct drm_connector_helper_funcs *funcs =\n\t\tconnector->base.helper_private;\n\n\tif (job->prepared && funcs->cleanup_writeback_job)\n\t\tfuncs->cleanup_writeback_job(connector, job);\n\n\tif (job->fb)\n\t\tdrm_framebuffer_put(job->fb);\n\n\tif (job->out_fence)\n\t\tdma_fence_put(job->out_fence);\n\n\tkfree(job);\n}\nEXPORT_SYMBOL(drm_writeback_cleanup_job);\n\n \nstatic void cleanup_work(struct work_struct *work)\n{\n\tstruct drm_writeback_job *job = container_of(work,\n\t\t\t\t\t\t     struct drm_writeback_job,\n\t\t\t\t\t\t     cleanup_work);\n\n\tdrm_writeback_cleanup_job(job);\n}\n\n \nvoid\ndrm_writeback_signal_completion(struct drm_writeback_connector *wb_connector,\n\t\t\t\tint status)\n{\n\tunsigned long flags;\n\tstruct drm_writeback_job *job;\n\tstruct dma_fence *out_fence;\n\n\tspin_lock_irqsave(&wb_connector->job_lock, flags);\n\tjob = list_first_entry_or_null(&wb_connector->job_queue,\n\t\t\t\t       struct drm_writeback_job,\n\t\t\t\t       list_entry);\n\tif (job)\n\t\tlist_del(&job->list_entry);\n\n\tspin_unlock_irqrestore(&wb_connector->job_lock, flags);\n\n\tif (WARN_ON(!job))\n\t\treturn;\n\n\tout_fence = job->out_fence;\n\tif (out_fence) {\n\t\tif (status)\n\t\t\tdma_fence_set_error(out_fence, status);\n\t\tdma_fence_signal(out_fence);\n\t\tdma_fence_put(out_fence);\n\t\tjob->out_fence = NULL;\n\t}\n\n\tINIT_WORK(&job->cleanup_work, cleanup_work);\n\tqueue_work(system_long_wq, &job->cleanup_work);\n}\nEXPORT_SYMBOL(drm_writeback_signal_completion);\n\nstruct dma_fence *\ndrm_writeback_get_out_fence(struct drm_writeback_connector *wb_connector)\n{\n\tstruct dma_fence *fence;\n\n\tif (WARN_ON(wb_connector->base.connector_type !=\n\t\t    DRM_MODE_CONNECTOR_WRITEBACK))\n\t\treturn NULL;\n\n\tfence = kzalloc(sizeof(*fence), GFP_KERNEL);\n\tif (!fence)\n\t\treturn NULL;\n\n\tdma_fence_init(fence, &drm_writeback_fence_ops,\n\t\t       &wb_connector->fence_lock, wb_connector->fence_context,\n\t\t       ++wb_connector->fence_seqno);\n\n\treturn fence;\n}\nEXPORT_SYMBOL(drm_writeback_get_out_fence);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}