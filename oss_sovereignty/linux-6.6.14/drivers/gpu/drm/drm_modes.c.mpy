{
  "module_name": "drm_modes.c",
  "hash_id": "2f48dc7b085ab001ee6c618d7ad78fac0e172b283da093b09a1963d92058913e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_modes.c",
  "human_readable_source": " \n\n#include <linux/ctype.h>\n#include <linux/export.h>\n#include <linux/fb.h>  \n#include <linux/list.h>\n#include <linux/list_sort.h>\n#include <linux/of.h>\n\n#include <video/of_display_timing.h>\n#include <video/of_videomode.h>\n#include <video/videomode.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n\n \nvoid drm_mode_debug_printmodeline(const struct drm_display_mode *mode)\n{\n\tDRM_DEBUG_KMS(\"Modeline \" DRM_MODE_FMT \"\\n\", DRM_MODE_ARG(mode));\n}\nEXPORT_SYMBOL(drm_mode_debug_printmodeline);\n\n \nstruct drm_display_mode *drm_mode_create(struct drm_device *dev)\n{\n\tstruct drm_display_mode *nmode;\n\n\tnmode = kzalloc(sizeof(struct drm_display_mode), GFP_KERNEL);\n\tif (!nmode)\n\t\treturn NULL;\n\n\treturn nmode;\n}\nEXPORT_SYMBOL(drm_mode_create);\n\n \nvoid drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode)\n{\n\tif (!mode)\n\t\treturn;\n\n\tkfree(mode);\n}\nEXPORT_SYMBOL(drm_mode_destroy);\n\n \nvoid drm_mode_probed_add(struct drm_connector *connector,\n\t\t\t struct drm_display_mode *mode)\n{\n\tWARN_ON(!mutex_is_locked(&connector->dev->mode_config.mutex));\n\n\tlist_add_tail(&mode->head, &connector->probed_modes);\n}\nEXPORT_SYMBOL(drm_mode_probed_add);\n\nenum drm_mode_analog {\n\tDRM_MODE_ANALOG_NTSC,  \n\tDRM_MODE_ANALOG_PAL,  \n};\n\n \n#define NTSC_LINE_DURATION_NS\t\t63556U\n#define NTSC_LINES_NUMBER\t\t525\n\n#define NTSC_HBLK_DURATION_TYP_NS\t10900U\n#define NTSC_HBLK_DURATION_MIN_NS\t(NTSC_HBLK_DURATION_TYP_NS - 200)\n#define NTSC_HBLK_DURATION_MAX_NS\t(NTSC_HBLK_DURATION_TYP_NS + 200)\n\n#define NTSC_HACT_DURATION_TYP_NS\t(NTSC_LINE_DURATION_NS - NTSC_HBLK_DURATION_TYP_NS)\n#define NTSC_HACT_DURATION_MIN_NS\t(NTSC_LINE_DURATION_NS - NTSC_HBLK_DURATION_MAX_NS)\n#define NTSC_HACT_DURATION_MAX_NS\t(NTSC_LINE_DURATION_NS - NTSC_HBLK_DURATION_MIN_NS)\n\n#define NTSC_HFP_DURATION_TYP_NS\t1500\n#define NTSC_HFP_DURATION_MIN_NS\t1270\n#define NTSC_HFP_DURATION_MAX_NS\t2220\n\n#define NTSC_HSLEN_DURATION_TYP_NS\t4700\n#define NTSC_HSLEN_DURATION_MIN_NS\t(NTSC_HSLEN_DURATION_TYP_NS - 100)\n#define NTSC_HSLEN_DURATION_MAX_NS\t(NTSC_HSLEN_DURATION_TYP_NS + 100)\n\n#define NTSC_HBP_DURATION_TYP_NS\t4700\n\n \n#define NTSC_HBP_DURATION_MIN_NS\t(NTSC_HBP_DURATION_TYP_NS - 100)\n#define NTSC_HBP_DURATION_MAX_NS\t(NTSC_HBP_DURATION_TYP_NS + 100)\n\n#define PAL_LINE_DURATION_NS\t\t64000U\n#define PAL_LINES_NUMBER\t\t625\n\n#define PAL_HACT_DURATION_TYP_NS\t51950U\n#define PAL_HACT_DURATION_MIN_NS\t(PAL_HACT_DURATION_TYP_NS - 100)\n#define PAL_HACT_DURATION_MAX_NS\t(PAL_HACT_DURATION_TYP_NS + 400)\n\n#define PAL_HBLK_DURATION_TYP_NS\t(PAL_LINE_DURATION_NS - PAL_HACT_DURATION_TYP_NS)\n#define PAL_HBLK_DURATION_MIN_NS\t(PAL_LINE_DURATION_NS - PAL_HACT_DURATION_MAX_NS)\n#define PAL_HBLK_DURATION_MAX_NS\t(PAL_LINE_DURATION_NS - PAL_HACT_DURATION_MIN_NS)\n\n#define PAL_HFP_DURATION_TYP_NS\t\t1650\n#define PAL_HFP_DURATION_MIN_NS\t\t(PAL_HFP_DURATION_TYP_NS - 100)\n#define PAL_HFP_DURATION_MAX_NS\t\t(PAL_HFP_DURATION_TYP_NS + 400)\n\n#define PAL_HSLEN_DURATION_TYP_NS\t4700\n#define PAL_HSLEN_DURATION_MIN_NS\t(PAL_HSLEN_DURATION_TYP_NS - 200)\n#define PAL_HSLEN_DURATION_MAX_NS\t(PAL_HSLEN_DURATION_TYP_NS + 200)\n\n#define PAL_HBP_DURATION_TYP_NS\t\t5700\n#define PAL_HBP_DURATION_MIN_NS\t\t(PAL_HBP_DURATION_TYP_NS - 200)\n#define PAL_HBP_DURATION_MAX_NS\t\t(PAL_HBP_DURATION_TYP_NS + 200)\n\nstruct analog_param_field {\n\tunsigned int even, odd;\n};\n\n#define PARAM_FIELD(_odd, _even)\t\t\\\n\t{ .even = _even, .odd = _odd }\n\nstruct analog_param_range {\n\tunsigned int\tmin, typ, max;\n};\n\n#define PARAM_RANGE(_min, _typ, _max)\t\t\\\n\t{ .min = _min, .typ = _typ, .max = _max }\n\nstruct analog_parameters {\n\tunsigned int\t\t\tnum_lines;\n\tunsigned int\t\t\tline_duration_ns;\n\n\tstruct analog_param_range\thact_ns;\n\tstruct analog_param_range\thfp_ns;\n\tstruct analog_param_range\thslen_ns;\n\tstruct analog_param_range\thbp_ns;\n\tstruct analog_param_range\thblk_ns;\n\n\tunsigned int\t\t\tbt601_hfp;\n\n\tstruct analog_param_field\tvfp_lines;\n\tstruct analog_param_field\tvslen_lines;\n\tstruct analog_param_field\tvbp_lines;\n};\n\n#define TV_MODE_PARAMETER(_mode, _lines, _line_dur, _hact, _hfp,\t\\\n\t\t\t  _hslen, _hbp, _hblk, _bt601_hfp, _vfp,\t\\\n\t\t\t  _vslen, _vbp)\t\t\t\t\t\\\n\t[_mode] = {\t\t\t\t\t\t\t\\\n\t\t.num_lines = _lines,\t\t\t\t\t\\\n\t\t.line_duration_ns = _line_dur,\t\t\t\t\\\n\t\t.hact_ns = _hact,\t\t\t\t\t\\\n\t\t.hfp_ns = _hfp,\t\t\t\t\t\t\\\n\t\t.hslen_ns = _hslen,\t\t\t\t\t\\\n\t\t.hbp_ns = _hbp,\t\t\t\t\t\t\\\n\t\t.hblk_ns = _hblk,\t\t\t\t\t\\\n\t\t.bt601_hfp = _bt601_hfp,\t\t\t\t\\\n\t\t.vfp_lines = _vfp,\t\t\t\t\t\\\n\t\t.vslen_lines = _vslen,\t\t\t\t\t\\\n\t\t.vbp_lines = _vbp,\t\t\t\t\t\\\n\t}\n\nstatic const struct analog_parameters tv_modes_parameters[] = {\n\tTV_MODE_PARAMETER(DRM_MODE_ANALOG_NTSC,\n\t\t\t  NTSC_LINES_NUMBER,\n\t\t\t  NTSC_LINE_DURATION_NS,\n\t\t\t  PARAM_RANGE(NTSC_HACT_DURATION_MIN_NS,\n\t\t\t\t      NTSC_HACT_DURATION_TYP_NS,\n\t\t\t\t      NTSC_HACT_DURATION_MAX_NS),\n\t\t\t  PARAM_RANGE(NTSC_HFP_DURATION_MIN_NS,\n\t\t\t\t      NTSC_HFP_DURATION_TYP_NS,\n\t\t\t\t      NTSC_HFP_DURATION_MAX_NS),\n\t\t\t  PARAM_RANGE(NTSC_HSLEN_DURATION_MIN_NS,\n\t\t\t\t      NTSC_HSLEN_DURATION_TYP_NS,\n\t\t\t\t      NTSC_HSLEN_DURATION_MAX_NS),\n\t\t\t  PARAM_RANGE(NTSC_HBP_DURATION_MIN_NS,\n\t\t\t\t      NTSC_HBP_DURATION_TYP_NS,\n\t\t\t\t      NTSC_HBP_DURATION_MAX_NS),\n\t\t\t  PARAM_RANGE(NTSC_HBLK_DURATION_MIN_NS,\n\t\t\t\t      NTSC_HBLK_DURATION_TYP_NS,\n\t\t\t\t      NTSC_HBLK_DURATION_MAX_NS),\n\t\t\t  16,\n\t\t\t  PARAM_FIELD(3, 3),\n\t\t\t  PARAM_FIELD(3, 3),\n\t\t\t  PARAM_FIELD(16, 17)),\n\tTV_MODE_PARAMETER(DRM_MODE_ANALOG_PAL,\n\t\t\t  PAL_LINES_NUMBER,\n\t\t\t  PAL_LINE_DURATION_NS,\n\t\t\t  PARAM_RANGE(PAL_HACT_DURATION_MIN_NS,\n\t\t\t\t      PAL_HACT_DURATION_TYP_NS,\n\t\t\t\t      PAL_HACT_DURATION_MAX_NS),\n\t\t\t  PARAM_RANGE(PAL_HFP_DURATION_MIN_NS,\n\t\t\t\t      PAL_HFP_DURATION_TYP_NS,\n\t\t\t\t      PAL_HFP_DURATION_MAX_NS),\n\t\t\t  PARAM_RANGE(PAL_HSLEN_DURATION_MIN_NS,\n\t\t\t\t      PAL_HSLEN_DURATION_TYP_NS,\n\t\t\t\t      PAL_HSLEN_DURATION_MAX_NS),\n\t\t\t  PARAM_RANGE(PAL_HBP_DURATION_MIN_NS,\n\t\t\t\t      PAL_HBP_DURATION_TYP_NS,\n\t\t\t\t      PAL_HBP_DURATION_MAX_NS),\n\t\t\t  PARAM_RANGE(PAL_HBLK_DURATION_MIN_NS,\n\t\t\t\t      PAL_HBLK_DURATION_TYP_NS,\n\t\t\t\t      PAL_HBLK_DURATION_MAX_NS),\n\t\t\t  12,\n\n\t\t\t   \n\t\t\t  PARAM_FIELD(3, 2),\n\n\t\t\t   \n\t\t\t  PARAM_FIELD(3, 3),\n\n\t\t\t   \n\t\t\t  PARAM_FIELD(19, 20)),\n};\n\nstatic int fill_analog_mode(struct drm_device *dev,\n\t\t\t    struct drm_display_mode *mode,\n\t\t\t    const struct analog_parameters *params,\n\t\t\t    unsigned long pixel_clock_hz,\n\t\t\t    unsigned int hactive,\n\t\t\t    unsigned int vactive,\n\t\t\t    bool interlace)\n{\n\tunsigned long pixel_duration_ns = NSEC_PER_SEC / pixel_clock_hz;\n\tunsigned int htotal, vtotal;\n\tunsigned int max_hact, hact_duration_ns;\n\tunsigned int hblk, hblk_duration_ns;\n\tunsigned int hfp, hfp_duration_ns;\n\tunsigned int hslen, hslen_duration_ns;\n\tunsigned int hbp, hbp_duration_ns;\n\tunsigned int porches, porches_duration_ns;\n\tunsigned int vfp, vfp_min;\n\tunsigned int vbp, vbp_min;\n\tunsigned int vslen;\n\tbool bt601 = false;\n\tint porches_rem;\n\tu64 result;\n\n\tdrm_dbg_kms(dev,\n\t\t    \"Generating a %ux%u%c, %u-line mode with a %lu kHz clock\\n\",\n\t\t    hactive, vactive,\n\t\t    interlace ? 'i' : 'p',\n\t\t    params->num_lines,\n\t\t    pixel_clock_hz / 1000);\n\n\tmax_hact = params->hact_ns.max / pixel_duration_ns;\n\tif (pixel_clock_hz == 13500000 && hactive > max_hact && hactive <= 720) {\n\t\tdrm_dbg_kms(dev, \"Trying to generate a BT.601 mode. Disabling checks.\\n\");\n\t\tbt601 = true;\n\t}\n\n\t \n\tresult = (u64)params->line_duration_ns * pixel_clock_hz;\n\tdo_div(result, NSEC_PER_SEC);\n\thtotal = result;\n\n\tdrm_dbg_kms(dev, \"Total Horizontal Number of Pixels: %u\\n\", htotal);\n\n\thact_duration_ns = hactive * pixel_duration_ns;\n\tif (!bt601 &&\n\t    (hact_duration_ns < params->hact_ns.min ||\n\t     hact_duration_ns > params->hact_ns.max)) {\n\t\tDRM_ERROR(\"Invalid horizontal active area duration: %uns (min: %u, max %u)\\n\",\n\t\t\t  hact_duration_ns, params->hact_ns.min, params->hact_ns.max);\n\t\treturn -EINVAL;\n\t}\n\n\thblk = htotal - hactive;\n\tdrm_dbg_kms(dev, \"Horizontal Blanking Period: %u\\n\", hblk);\n\n\thblk_duration_ns = hblk * pixel_duration_ns;\n\tif (!bt601 &&\n\t    (hblk_duration_ns < params->hblk_ns.min ||\n\t     hblk_duration_ns > params->hblk_ns.max)) {\n\t\tDRM_ERROR(\"Invalid horizontal blanking duration: %uns (min: %u, max %u)\\n\",\n\t\t\t  hblk_duration_ns, params->hblk_ns.min, params->hblk_ns.max);\n\t\treturn -EINVAL;\n\t}\n\n\thslen = DIV_ROUND_UP(params->hslen_ns.typ, pixel_duration_ns);\n\tdrm_dbg_kms(dev, \"Horizontal Sync Period: %u\\n\", hslen);\n\n\thslen_duration_ns = hslen * pixel_duration_ns;\n\tif (!bt601 &&\n\t    (hslen_duration_ns < params->hslen_ns.min ||\n\t     hslen_duration_ns > params->hslen_ns.max)) {\n\t\tDRM_ERROR(\"Invalid horizontal sync duration: %uns (min: %u, max %u)\\n\",\n\t\t\t  hslen_duration_ns, params->hslen_ns.min, params->hslen_ns.max);\n\t\treturn -EINVAL;\n\t}\n\n\tporches = hblk - hslen;\n\tdrm_dbg_kms(dev, \"Remaining horizontal pixels for both porches: %u\\n\", porches);\n\n\tporches_duration_ns = porches * pixel_duration_ns;\n\tif (!bt601 &&\n\t    (porches_duration_ns > (params->hfp_ns.max + params->hbp_ns.max) ||\n\t     porches_duration_ns < (params->hfp_ns.min + params->hbp_ns.min))) {\n\t\tDRM_ERROR(\"Invalid horizontal porches duration: %uns\\n\", porches_duration_ns);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bt601) {\n\t\thfp = params->bt601_hfp;\n\t} else {\n\t\tunsigned int hfp_min = DIV_ROUND_UP(params->hfp_ns.min,\n\t\t\t\t\t\t    pixel_duration_ns);\n\t\tunsigned int hbp_min = DIV_ROUND_UP(params->hbp_ns.min,\n\t\t\t\t\t\t    pixel_duration_ns);\n\t\tint porches_rem = porches - hfp_min - hbp_min;\n\n\t\thfp = hfp_min + DIV_ROUND_UP(porches_rem, 2);\n\t}\n\n\tdrm_dbg_kms(dev, \"Horizontal Front Porch: %u\\n\", hfp);\n\n\thfp_duration_ns = hfp * pixel_duration_ns;\n\tif (!bt601 &&\n\t    (hfp_duration_ns < params->hfp_ns.min ||\n\t     hfp_duration_ns > params->hfp_ns.max)) {\n\t\tDRM_ERROR(\"Invalid horizontal front porch duration: %uns (min: %u, max %u)\\n\",\n\t\t\t  hfp_duration_ns, params->hfp_ns.min, params->hfp_ns.max);\n\t\treturn -EINVAL;\n\t}\n\n\thbp = porches - hfp;\n\tdrm_dbg_kms(dev, \"Horizontal Back Porch: %u\\n\", hbp);\n\n\thbp_duration_ns = hbp * pixel_duration_ns;\n\tif (!bt601 &&\n\t    (hbp_duration_ns < params->hbp_ns.min ||\n\t     hbp_duration_ns > params->hbp_ns.max)) {\n\t\tDRM_ERROR(\"Invalid horizontal back porch duration: %uns (min: %u, max %u)\\n\",\n\t\t\t  hbp_duration_ns, params->hbp_ns.min, params->hbp_ns.max);\n\t\treturn -EINVAL;\n\t}\n\n\tif (htotal != (hactive + hfp + hslen + hbp))\n\t\treturn -EINVAL;\n\n\tmode->clock = pixel_clock_hz / 1000;\n\tmode->hdisplay = hactive;\n\tmode->hsync_start = mode->hdisplay + hfp;\n\tmode->hsync_end = mode->hsync_start + hslen;\n\tmode->htotal = mode->hsync_end + hbp;\n\n\tif (interlace) {\n\t\tvfp_min = params->vfp_lines.even + params->vfp_lines.odd;\n\t\tvbp_min = params->vbp_lines.even + params->vbp_lines.odd;\n\t\tvslen = params->vslen_lines.even + params->vslen_lines.odd;\n\t} else {\n\t\t \n\t\tvfp_min = params->vfp_lines.odd;\n\t\tvbp_min = params->vbp_lines.odd;\n\t\tvslen = params->vslen_lines.odd;\n\t}\n\n\tdrm_dbg_kms(dev, \"Vertical Sync Period: %u\\n\", vslen);\n\n\tporches = params->num_lines - vactive - vslen;\n\tdrm_dbg_kms(dev, \"Remaining vertical pixels for both porches: %u\\n\", porches);\n\n\tporches_rem = porches - vfp_min - vbp_min;\n\tvfp = vfp_min + (porches_rem / 2);\n\tdrm_dbg_kms(dev, \"Vertical Front Porch: %u\\n\", vfp);\n\n\tvbp = porches - vfp;\n\tdrm_dbg_kms(dev, \"Vertical Back Porch: %u\\n\", vbp);\n\n\tvtotal = vactive + vfp + vslen + vbp;\n\tif (params->num_lines != vtotal) {\n\t\tDRM_ERROR(\"Invalid vertical total: %upx (expected %upx)\\n\",\n\t\t\t  vtotal, params->num_lines);\n\t\treturn -EINVAL;\n\t}\n\n\tmode->vdisplay = vactive;\n\tmode->vsync_start = mode->vdisplay + vfp;\n\tmode->vsync_end = mode->vsync_start + vslen;\n\tmode->vtotal = mode->vsync_end + vbp;\n\n\tif (mode->vtotal != params->num_lines)\n\t\treturn -EINVAL;\n\n\tmode->type = DRM_MODE_TYPE_DRIVER;\n\tmode->flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC;\n\tif (interlace)\n\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\n\tdrm_mode_set_name(mode);\n\n\tdrm_dbg_kms(dev, \"Generated mode \" DRM_MODE_FMT \"\\n\", DRM_MODE_ARG(mode));\n\n\treturn 0;\n}\n\n \nstruct drm_display_mode *drm_analog_tv_mode(struct drm_device *dev,\n\t\t\t\t\t    enum drm_connector_tv_mode tv_mode,\n\t\t\t\t\t    unsigned long pixel_clock_hz,\n\t\t\t\t\t    unsigned int hdisplay,\n\t\t\t\t\t    unsigned int vdisplay,\n\t\t\t\t\t    bool interlace)\n{\n\tstruct drm_display_mode *mode;\n\tenum drm_mode_analog analog;\n\tint ret;\n\n\tswitch (tv_mode) {\n\tcase DRM_MODE_TV_MODE_NTSC:\n\t\tfallthrough;\n\tcase DRM_MODE_TV_MODE_NTSC_443:\n\t\tfallthrough;\n\tcase DRM_MODE_TV_MODE_NTSC_J:\n\t\tfallthrough;\n\tcase DRM_MODE_TV_MODE_PAL_M:\n\t\tanalog = DRM_MODE_ANALOG_NTSC;\n\t\tbreak;\n\n\tcase DRM_MODE_TV_MODE_PAL:\n\t\tfallthrough;\n\tcase DRM_MODE_TV_MODE_PAL_N:\n\t\tfallthrough;\n\tcase DRM_MODE_TV_MODE_SECAM:\n\t\tanalog = DRM_MODE_ANALOG_PAL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tmode = drm_mode_create(dev);\n\tif (!mode)\n\t\treturn NULL;\n\n\tret = fill_analog_mode(dev, mode,\n\t\t\t       &tv_modes_parameters[analog],\n\t\t\t       pixel_clock_hz, hdisplay, vdisplay, interlace);\n\tif (ret)\n\t\tgoto err_free_mode;\n\n\treturn mode;\n\nerr_free_mode:\n\tdrm_mode_destroy(dev, mode);\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_analog_tv_mode);\n\n \nstruct drm_display_mode *drm_cvt_mode(struct drm_device *dev, int hdisplay,\n\t\t\t\t      int vdisplay, int vrefresh,\n\t\t\t\t      bool reduced, bool interlaced, bool margins)\n{\n#define HV_FACTOR\t\t\t1000\n\t \n#define\tCVT_MARGIN_PERCENTAGE\t\t18\n\t \n#define\tCVT_H_GRANULARITY\t\t8\n\t \n#define\tCVT_MIN_V_PORCH\t\t\t3\n\t \n#define\tCVT_MIN_V_BPORCH\t\t6\n\t \n#define CVT_CLOCK_STEP\t\t\t250\n\tstruct drm_display_mode *drm_mode;\n\tunsigned int vfieldrate, hperiod;\n\tint hdisplay_rnd, hmargin, vdisplay_rnd, vmargin, vsync;\n\tint interlace;\n\tu64 tmp;\n\n\tif (!hdisplay || !vdisplay)\n\t\treturn NULL;\n\n\t \n\tdrm_mode = drm_mode_create(dev);\n\tif (!drm_mode)\n\t\treturn NULL;\n\n\t \n\tif (!vrefresh)\n\t\tvrefresh = 60;\n\n\t \n\tif (interlaced)\n\t\tvfieldrate = vrefresh * 2;\n\telse\n\t\tvfieldrate = vrefresh;\n\n\t \n\thdisplay_rnd = hdisplay - (hdisplay % CVT_H_GRANULARITY);\n\n\t \n\thmargin = 0;\n\tif (margins) {\n\t\thmargin = hdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;\n\t\thmargin -= hmargin % CVT_H_GRANULARITY;\n\t}\n\t \n\tdrm_mode->hdisplay = hdisplay_rnd + 2 * hmargin;\n\n\t \n\tif (interlaced)\n\t\tvdisplay_rnd = vdisplay / 2;\n\telse\n\t\tvdisplay_rnd = vdisplay;\n\n\t \n\tvmargin = 0;\n\tif (margins)\n\t\tvmargin = vdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;\n\n\tdrm_mode->vdisplay = vdisplay + 2 * vmargin;\n\n\t \n\tif (interlaced)\n\t\tinterlace = 1;\n\telse\n\t\tinterlace = 0;\n\n\t \n\tif (!(vdisplay % 3) && ((vdisplay * 4 / 3) == hdisplay))\n\t\tvsync = 4;\n\telse if (!(vdisplay % 9) && ((vdisplay * 16 / 9) == hdisplay))\n\t\tvsync = 5;\n\telse if (!(vdisplay % 10) && ((vdisplay * 16 / 10) == hdisplay))\n\t\tvsync = 6;\n\telse if (!(vdisplay % 4) && ((vdisplay * 5 / 4) == hdisplay))\n\t\tvsync = 7;\n\telse if (!(vdisplay % 9) && ((vdisplay * 15 / 9) == hdisplay))\n\t\tvsync = 7;\n\telse  \n\t\tvsync = 10;\n\n\tif (!reduced) {\n\t\t \n\t\t \n\t\tint tmp1, tmp2;\n#define CVT_MIN_VSYNC_BP\t550\n\t\t \n#define CVT_HSYNC_PERCENTAGE\t8\n\t\tunsigned int hblank_percentage;\n\t\tint vsyncandback_porch, __maybe_unused vback_porch, hblank;\n\n\t\t \n\t\ttmp1 = HV_FACTOR * 1000000  -\n\t\t\t\tCVT_MIN_VSYNC_BP * HV_FACTOR * vfieldrate;\n\t\ttmp2 = (vdisplay_rnd + 2 * vmargin + CVT_MIN_V_PORCH) * 2 +\n\t\t\t\tinterlace;\n\t\thperiod = tmp1 * 2 / (tmp2 * vfieldrate);\n\n\t\ttmp1 = CVT_MIN_VSYNC_BP * HV_FACTOR / hperiod + 1;\n\t\t \n\t\tif (tmp1 < (vsync + CVT_MIN_V_PORCH))\n\t\t\tvsyncandback_porch = vsync + CVT_MIN_V_PORCH;\n\t\telse\n\t\t\tvsyncandback_porch = tmp1;\n\t\t \n\t\tvback_porch = vsyncandback_porch - vsync;\n\t\tdrm_mode->vtotal = vdisplay_rnd + 2 * vmargin +\n\t\t\t\tvsyncandback_porch + CVT_MIN_V_PORCH;\n\t\t \n\t\t \n#define CVT_M_FACTOR\t600\n\t\t \n#define CVT_C_FACTOR\t40\n\t\t \n#define CVT_K_FACTOR\t128\n\t\t \n#define CVT_J_FACTOR\t20\n#define CVT_M_PRIME\t(CVT_M_FACTOR * CVT_K_FACTOR / 256)\n#define CVT_C_PRIME\t((CVT_C_FACTOR - CVT_J_FACTOR) * CVT_K_FACTOR / 256 + \\\n\t\t\t CVT_J_FACTOR)\n\t\t \n\t\thblank_percentage = CVT_C_PRIME * HV_FACTOR - CVT_M_PRIME *\n\t\t\t\t\thperiod / 1000;\n\t\t \n\t\tif (hblank_percentage < 20 * HV_FACTOR)\n\t\t\thblank_percentage = 20 * HV_FACTOR;\n\t\thblank = drm_mode->hdisplay * hblank_percentage /\n\t\t\t (100 * HV_FACTOR - hblank_percentage);\n\t\thblank -= hblank % (2 * CVT_H_GRANULARITY);\n\t\t \n\t\tdrm_mode->htotal = drm_mode->hdisplay + hblank;\n\t\tdrm_mode->hsync_end = drm_mode->hdisplay + hblank / 2;\n\t\tdrm_mode->hsync_start = drm_mode->hsync_end -\n\t\t\t(drm_mode->htotal * CVT_HSYNC_PERCENTAGE) / 100;\n\t\tdrm_mode->hsync_start += CVT_H_GRANULARITY -\n\t\t\tdrm_mode->hsync_start % CVT_H_GRANULARITY;\n\t\t \n\t\tdrm_mode->vsync_start = drm_mode->vdisplay + CVT_MIN_V_PORCH;\n\t\tdrm_mode->vsync_end = drm_mode->vsync_start + vsync;\n\t} else {\n\t\t \n\t\t \n#define CVT_RB_MIN_VBLANK\t460\n\t\t \n#define CVT_RB_H_SYNC\t\t32\n\t\t \n#define CVT_RB_H_BLANK\t\t160\n\t\t \n#define CVT_RB_VFPORCH\t\t3\n\t\tint vbilines;\n\t\tint tmp1, tmp2;\n\t\t \n\t\ttmp1 = HV_FACTOR * 1000000 -\n\t\t\tCVT_RB_MIN_VBLANK * HV_FACTOR * vfieldrate;\n\t\ttmp2 = vdisplay_rnd + 2 * vmargin;\n\t\thperiod = tmp1 / (tmp2 * vfieldrate);\n\t\t \n\t\tvbilines = CVT_RB_MIN_VBLANK * HV_FACTOR / hperiod + 1;\n\t\t \n\t\tif (vbilines < (CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH))\n\t\t\tvbilines = CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH;\n\t\t \n\t\tdrm_mode->vtotal = vdisplay_rnd + 2 * vmargin + vbilines;\n\t\t \n\t\tdrm_mode->htotal = drm_mode->hdisplay + CVT_RB_H_BLANK;\n\t\t \n\t\tdrm_mode->hsync_end = drm_mode->hdisplay + CVT_RB_H_BLANK / 2;\n\t\tdrm_mode->hsync_start = drm_mode->hsync_end - CVT_RB_H_SYNC;\n\t\t \n\t\tdrm_mode->vsync_start = drm_mode->vdisplay + CVT_RB_VFPORCH;\n\t\tdrm_mode->vsync_end = drm_mode->vsync_start + vsync;\n\t}\n\t \n\ttmp = drm_mode->htotal;  \n\ttmp *= HV_FACTOR * 1000;\n\tdo_div(tmp, hperiod);\n\ttmp -= drm_mode->clock % CVT_CLOCK_STEP;\n\tdrm_mode->clock = tmp;\n\t \n\t \n\tif (interlaced) {\n\t\tdrm_mode->vtotal *= 2;\n\t\tdrm_mode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t}\n\t \n\tdrm_mode_set_name(drm_mode);\n\tif (reduced)\n\t\tdrm_mode->flags |= (DRM_MODE_FLAG_PHSYNC |\n\t\t\t\t\tDRM_MODE_FLAG_NVSYNC);\n\telse\n\t\tdrm_mode->flags |= (DRM_MODE_FLAG_PVSYNC |\n\t\t\t\t\tDRM_MODE_FLAG_NHSYNC);\n\n\treturn drm_mode;\n}\nEXPORT_SYMBOL(drm_cvt_mode);\n\n \nstruct drm_display_mode *\ndrm_gtf_mode_complex(struct drm_device *dev, int hdisplay, int vdisplay,\n\t\t     int vrefresh, bool interlaced, int margins,\n\t\t     int GTF_M, int GTF_2C, int GTF_K, int GTF_2J)\n{\t \n#define\tGTF_MARGIN_PERCENTAGE\t\t18\n\t \n#define\tGTF_CELL_GRAN\t\t\t8\n\t \n#define\tGTF_MIN_V_PORCH\t\t\t1\n\t \n#define V_SYNC_RQD\t\t\t3\n\t \n#define H_SYNC_PERCENT\t\t\t8\n\t \n#define MIN_VSYNC_PLUS_BP\t\t550\n\t \n#define GTF_C_PRIME\t((((GTF_2C - GTF_2J) * GTF_K / 256) + GTF_2J) / 2)\n#define GTF_M_PRIME\t(GTF_K * GTF_M / 256)\n\tstruct drm_display_mode *drm_mode;\n\tunsigned int hdisplay_rnd, vdisplay_rnd, vfieldrate_rqd;\n\tint top_margin, bottom_margin;\n\tint interlace;\n\tunsigned int hfreq_est;\n\tint vsync_plus_bp, __maybe_unused vback_porch;\n\tunsigned int vtotal_lines, __maybe_unused vfieldrate_est;\n\tunsigned int __maybe_unused hperiod;\n\tunsigned int vfield_rate, __maybe_unused vframe_rate;\n\tint left_margin, right_margin;\n\tunsigned int total_active_pixels, ideal_duty_cycle;\n\tunsigned int hblank, total_pixels, pixel_freq;\n\tint hsync, hfront_porch, vodd_front_porch_lines;\n\tunsigned int tmp1, tmp2;\n\n\tif (!hdisplay || !vdisplay)\n\t\treturn NULL;\n\n\tdrm_mode = drm_mode_create(dev);\n\tif (!drm_mode)\n\t\treturn NULL;\n\n\t \n\thdisplay_rnd = (hdisplay + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;\n\thdisplay_rnd = hdisplay_rnd * GTF_CELL_GRAN;\n\n\t \n\tif (interlaced)\n\t\tvdisplay_rnd = vdisplay / 2;\n\telse\n\t\tvdisplay_rnd = vdisplay;\n\n\t \n\tif (interlaced)\n\t\tvfieldrate_rqd = vrefresh * 2;\n\telse\n\t\tvfieldrate_rqd = vrefresh;\n\n\t \n\ttop_margin = 0;\n\tif (margins)\n\t\ttop_margin = (vdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /\n\t\t\t\t1000;\n\t \n\tbottom_margin = top_margin;\n\n\t \n\tif (interlaced)\n\t\tinterlace = 1;\n\telse\n\t\tinterlace = 0;\n\n\t \n\t{\n\t\ttmp1 = (1000000  - MIN_VSYNC_PLUS_BP * vfieldrate_rqd) / 500;\n\t\ttmp2 = (vdisplay_rnd + 2 * top_margin + GTF_MIN_V_PORCH) *\n\t\t\t\t2 + interlace;\n\t\thfreq_est = (tmp2 * 1000 * vfieldrate_rqd) / tmp1;\n\t}\n\n\t \n\t \n\tvsync_plus_bp = MIN_VSYNC_PLUS_BP * hfreq_est / 1000;\n\tvsync_plus_bp = (vsync_plus_bp + 500) / 1000;\n\t \n\tvback_porch = vsync_plus_bp - V_SYNC_RQD;\n\t \n\tvtotal_lines = vdisplay_rnd + top_margin + bottom_margin +\n\t\t\tvsync_plus_bp + GTF_MIN_V_PORCH;\n\t \n\tvfieldrate_est = hfreq_est / vtotal_lines;\n\t \n\thperiod = 1000000 / (vfieldrate_rqd * vtotal_lines);\n\n\t \n\tvfield_rate = hfreq_est / vtotal_lines;\n\t \n\tif (interlaced)\n\t\tvframe_rate = vfield_rate / 2;\n\telse\n\t\tvframe_rate = vfield_rate;\n\t \n\tif (margins)\n\t\tleft_margin = (hdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /\n\t\t\t\t1000;\n\telse\n\t\tleft_margin = 0;\n\n\t \n\tright_margin = left_margin;\n\t \n\ttotal_active_pixels = hdisplay_rnd + left_margin + right_margin;\n\t \n\tideal_duty_cycle = GTF_C_PRIME * 1000 -\n\t\t\t\t(GTF_M_PRIME * 1000000 / hfreq_est);\n\t \n\thblank = total_active_pixels * ideal_duty_cycle /\n\t\t\t(100000 - ideal_duty_cycle);\n\thblank = (hblank + GTF_CELL_GRAN) / (2 * GTF_CELL_GRAN);\n\thblank = hblank * 2 * GTF_CELL_GRAN;\n\t \n\ttotal_pixels = total_active_pixels + hblank;\n\t \n\tpixel_freq = total_pixels * hfreq_est / 1000;\n\t \n\t \n\thsync = H_SYNC_PERCENT * total_pixels / 100;\n\thsync = (hsync + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;\n\thsync = hsync * GTF_CELL_GRAN;\n\t \n\thfront_porch = hblank / 2 - hsync;\n\t \n\tvodd_front_porch_lines = GTF_MIN_V_PORCH ;\n\n\t \n\tdrm_mode->hdisplay = hdisplay_rnd;\n\tdrm_mode->hsync_start = hdisplay_rnd + hfront_porch;\n\tdrm_mode->hsync_end = drm_mode->hsync_start + hsync;\n\tdrm_mode->htotal = total_pixels;\n\tdrm_mode->vdisplay = vdisplay_rnd;\n\tdrm_mode->vsync_start = vdisplay_rnd + vodd_front_porch_lines;\n\tdrm_mode->vsync_end = drm_mode->vsync_start + V_SYNC_RQD;\n\tdrm_mode->vtotal = vtotal_lines;\n\n\tdrm_mode->clock = pixel_freq;\n\n\tif (interlaced) {\n\t\tdrm_mode->vtotal *= 2;\n\t\tdrm_mode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t}\n\n\tdrm_mode_set_name(drm_mode);\n\tif (GTF_M == 600 && GTF_2C == 80 && GTF_K == 128 && GTF_2J == 40)\n\t\tdrm_mode->flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC;\n\telse\n\t\tdrm_mode->flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC;\n\n\treturn drm_mode;\n}\nEXPORT_SYMBOL(drm_gtf_mode_complex);\n\n \nstruct drm_display_mode *\ndrm_gtf_mode(struct drm_device *dev, int hdisplay, int vdisplay, int vrefresh,\n\t     bool interlaced, int margins)\n{\n\treturn drm_gtf_mode_complex(dev, hdisplay, vdisplay, vrefresh,\n\t\t\t\t    interlaced, margins,\n\t\t\t\t    600, 40 * 2, 128, 20 * 2);\n}\nEXPORT_SYMBOL(drm_gtf_mode);\n\n#ifdef CONFIG_VIDEOMODE_HELPERS\n \nvoid drm_display_mode_from_videomode(const struct videomode *vm,\n\t\t\t\t     struct drm_display_mode *dmode)\n{\n\tdmode->hdisplay = vm->hactive;\n\tdmode->hsync_start = dmode->hdisplay + vm->hfront_porch;\n\tdmode->hsync_end = dmode->hsync_start + vm->hsync_len;\n\tdmode->htotal = dmode->hsync_end + vm->hback_porch;\n\n\tdmode->vdisplay = vm->vactive;\n\tdmode->vsync_start = dmode->vdisplay + vm->vfront_porch;\n\tdmode->vsync_end = dmode->vsync_start + vm->vsync_len;\n\tdmode->vtotal = dmode->vsync_end + vm->vback_porch;\n\n\tdmode->clock = vm->pixelclock / 1000;\n\n\tdmode->flags = 0;\n\tif (vm->flags & DISPLAY_FLAGS_HSYNC_HIGH)\n\t\tdmode->flags |= DRM_MODE_FLAG_PHSYNC;\n\telse if (vm->flags & DISPLAY_FLAGS_HSYNC_LOW)\n\t\tdmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\tif (vm->flags & DISPLAY_FLAGS_VSYNC_HIGH)\n\t\tdmode->flags |= DRM_MODE_FLAG_PVSYNC;\n\telse if (vm->flags & DISPLAY_FLAGS_VSYNC_LOW)\n\t\tdmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\tif (vm->flags & DISPLAY_FLAGS_INTERLACED)\n\t\tdmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\tif (vm->flags & DISPLAY_FLAGS_DOUBLESCAN)\n\t\tdmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\tif (vm->flags & DISPLAY_FLAGS_DOUBLECLK)\n\t\tdmode->flags |= DRM_MODE_FLAG_DBLCLK;\n\tdrm_mode_set_name(dmode);\n}\nEXPORT_SYMBOL_GPL(drm_display_mode_from_videomode);\n\n \nvoid drm_display_mode_to_videomode(const struct drm_display_mode *dmode,\n\t\t\t\t   struct videomode *vm)\n{\n\tvm->hactive = dmode->hdisplay;\n\tvm->hfront_porch = dmode->hsync_start - dmode->hdisplay;\n\tvm->hsync_len = dmode->hsync_end - dmode->hsync_start;\n\tvm->hback_porch = dmode->htotal - dmode->hsync_end;\n\n\tvm->vactive = dmode->vdisplay;\n\tvm->vfront_porch = dmode->vsync_start - dmode->vdisplay;\n\tvm->vsync_len = dmode->vsync_end - dmode->vsync_start;\n\tvm->vback_porch = dmode->vtotal - dmode->vsync_end;\n\n\tvm->pixelclock = dmode->clock * 1000;\n\n\tvm->flags = 0;\n\tif (dmode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tvm->flags |= DISPLAY_FLAGS_HSYNC_HIGH;\n\telse if (dmode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tvm->flags |= DISPLAY_FLAGS_HSYNC_LOW;\n\tif (dmode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tvm->flags |= DISPLAY_FLAGS_VSYNC_HIGH;\n\telse if (dmode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tvm->flags |= DISPLAY_FLAGS_VSYNC_LOW;\n\tif (dmode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tvm->flags |= DISPLAY_FLAGS_INTERLACED;\n\tif (dmode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\tvm->flags |= DISPLAY_FLAGS_DOUBLESCAN;\n\tif (dmode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tvm->flags |= DISPLAY_FLAGS_DOUBLECLK;\n}\nEXPORT_SYMBOL_GPL(drm_display_mode_to_videomode);\n\n \nvoid drm_bus_flags_from_videomode(const struct videomode *vm, u32 *bus_flags)\n{\n\t*bus_flags = 0;\n\tif (vm->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)\n\t\t*bus_flags |= DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;\n\tif (vm->flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)\n\t\t*bus_flags |= DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;\n\n\tif (vm->flags & DISPLAY_FLAGS_SYNC_POSEDGE)\n\t\t*bus_flags |= DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE;\n\tif (vm->flags & DISPLAY_FLAGS_SYNC_NEGEDGE)\n\t\t*bus_flags |= DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE;\n\n\tif (vm->flags & DISPLAY_FLAGS_DE_LOW)\n\t\t*bus_flags |= DRM_BUS_FLAG_DE_LOW;\n\tif (vm->flags & DISPLAY_FLAGS_DE_HIGH)\n\t\t*bus_flags |= DRM_BUS_FLAG_DE_HIGH;\n}\nEXPORT_SYMBOL_GPL(drm_bus_flags_from_videomode);\n\n#ifdef CONFIG_OF\n \nint of_get_drm_display_mode(struct device_node *np,\n\t\t\t    struct drm_display_mode *dmode, u32 *bus_flags,\n\t\t\t    int index)\n{\n\tstruct videomode vm;\n\tint ret;\n\n\tret = of_get_videomode(np, &vm, index);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_display_mode_from_videomode(&vm, dmode);\n\tif (bus_flags)\n\t\tdrm_bus_flags_from_videomode(&vm, bus_flags);\n\n\tpr_debug(\"%pOF: got %dx%d display mode\\n\",\n\t\tnp, vm.hactive, vm.vactive);\n\tdrm_mode_debug_printmodeline(dmode);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_get_drm_display_mode);\n\n \nint of_get_drm_panel_display_mode(struct device_node *np,\n\t\t\t\t  struct drm_display_mode *dmode, u32 *bus_flags)\n{\n\tu32 width_mm = 0, height_mm = 0;\n\tstruct display_timing timing;\n\tstruct videomode vm;\n\tint ret;\n\n\tret = of_get_display_timing(np, \"panel-timing\", &timing);\n\tif (ret)\n\t\treturn ret;\n\n\tvideomode_from_timing(&timing, &vm);\n\n\tmemset(dmode, 0, sizeof(*dmode));\n\tdrm_display_mode_from_videomode(&vm, dmode);\n\tif (bus_flags)\n\t\tdrm_bus_flags_from_videomode(&vm, bus_flags);\n\n\tret = of_property_read_u32(np, \"width-mm\", &width_mm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u32(np, \"height-mm\", &height_mm);\n\tif (ret)\n\t\treturn ret;\n\n\tdmode->width_mm = width_mm;\n\tdmode->height_mm = height_mm;\n\n\tdrm_mode_debug_printmodeline(dmode);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_get_drm_panel_display_mode);\n#endif  \n#endif  \n\n \nvoid drm_mode_set_name(struct drm_display_mode *mode)\n{\n\tbool interlaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);\n\n\tsnprintf(mode->name, DRM_DISPLAY_MODE_LEN, \"%dx%d%s\",\n\t\t mode->hdisplay, mode->vdisplay,\n\t\t interlaced ? \"i\" : \"\");\n}\nEXPORT_SYMBOL(drm_mode_set_name);\n\n \nint drm_mode_vrefresh(const struct drm_display_mode *mode)\n{\n\tunsigned int num, den;\n\n\tif (mode->htotal == 0 || mode->vtotal == 0)\n\t\treturn 0;\n\n\tnum = mode->clock;\n\tden = mode->htotal * mode->vtotal;\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tnum *= 2;\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\tden *= 2;\n\tif (mode->vscan > 1)\n\t\tden *= mode->vscan;\n\n\treturn DIV_ROUND_CLOSEST_ULL(mul_u32_u32(num, 1000), den);\n}\nEXPORT_SYMBOL(drm_mode_vrefresh);\n\n \nvoid drm_mode_get_hv_timing(const struct drm_display_mode *mode,\n\t\t\t    int *hdisplay, int *vdisplay)\n{\n\tstruct drm_display_mode adjusted;\n\n\tdrm_mode_init(&adjusted, mode);\n\n\tdrm_mode_set_crtcinfo(&adjusted, CRTC_STEREO_DOUBLE_ONLY);\n\t*hdisplay = adjusted.crtc_hdisplay;\n\t*vdisplay = adjusted.crtc_vdisplay;\n}\nEXPORT_SYMBOL(drm_mode_get_hv_timing);\n\n \nvoid drm_mode_set_crtcinfo(struct drm_display_mode *p, int adjust_flags)\n{\n\tif (!p)\n\t\treturn;\n\n\tp->crtc_clock = p->clock;\n\tp->crtc_hdisplay = p->hdisplay;\n\tp->crtc_hsync_start = p->hsync_start;\n\tp->crtc_hsync_end = p->hsync_end;\n\tp->crtc_htotal = p->htotal;\n\tp->crtc_hskew = p->hskew;\n\tp->crtc_vdisplay = p->vdisplay;\n\tp->crtc_vsync_start = p->vsync_start;\n\tp->crtc_vsync_end = p->vsync_end;\n\tp->crtc_vtotal = p->vtotal;\n\n\tif (p->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tif (adjust_flags & CRTC_INTERLACE_HALVE_V) {\n\t\t\tp->crtc_vdisplay /= 2;\n\t\t\tp->crtc_vsync_start /= 2;\n\t\t\tp->crtc_vsync_end /= 2;\n\t\t\tp->crtc_vtotal /= 2;\n\t\t}\n\t}\n\n\tif (!(adjust_flags & CRTC_NO_DBLSCAN)) {\n\t\tif (p->flags & DRM_MODE_FLAG_DBLSCAN) {\n\t\t\tp->crtc_vdisplay *= 2;\n\t\t\tp->crtc_vsync_start *= 2;\n\t\t\tp->crtc_vsync_end *= 2;\n\t\t\tp->crtc_vtotal *= 2;\n\t\t}\n\t}\n\n\tif (!(adjust_flags & CRTC_NO_VSCAN)) {\n\t\tif (p->vscan > 1) {\n\t\t\tp->crtc_vdisplay *= p->vscan;\n\t\t\tp->crtc_vsync_start *= p->vscan;\n\t\t\tp->crtc_vsync_end *= p->vscan;\n\t\t\tp->crtc_vtotal *= p->vscan;\n\t\t}\n\t}\n\n\tif (adjust_flags & CRTC_STEREO_DOUBLE) {\n\t\tunsigned int layout = p->flags & DRM_MODE_FLAG_3D_MASK;\n\n\t\tswitch (layout) {\n\t\tcase DRM_MODE_FLAG_3D_FRAME_PACKING:\n\t\t\tp->crtc_clock *= 2;\n\t\t\tp->crtc_vdisplay += p->crtc_vtotal;\n\t\t\tp->crtc_vsync_start += p->crtc_vtotal;\n\t\t\tp->crtc_vsync_end += p->crtc_vtotal;\n\t\t\tp->crtc_vtotal += p->crtc_vtotal;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp->crtc_vblank_start = min(p->crtc_vsync_start, p->crtc_vdisplay);\n\tp->crtc_vblank_end = max(p->crtc_vsync_end, p->crtc_vtotal);\n\tp->crtc_hblank_start = min(p->crtc_hsync_start, p->crtc_hdisplay);\n\tp->crtc_hblank_end = max(p->crtc_hsync_end, p->crtc_htotal);\n}\nEXPORT_SYMBOL(drm_mode_set_crtcinfo);\n\n \nvoid drm_mode_copy(struct drm_display_mode *dst, const struct drm_display_mode *src)\n{\n\tstruct list_head head = dst->head;\n\n\t*dst = *src;\n\tdst->head = head;\n}\nEXPORT_SYMBOL(drm_mode_copy);\n\n \nvoid drm_mode_init(struct drm_display_mode *dst, const struct drm_display_mode *src)\n{\n\tmemset(dst, 0, sizeof(*dst));\n\tdrm_mode_copy(dst, src);\n}\nEXPORT_SYMBOL(drm_mode_init);\n\n \nstruct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,\n\t\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct drm_display_mode *nmode;\n\n\tnmode = drm_mode_create(dev);\n\tif (!nmode)\n\t\treturn NULL;\n\n\tdrm_mode_copy(nmode, mode);\n\n\treturn nmode;\n}\nEXPORT_SYMBOL(drm_mode_duplicate);\n\nstatic bool drm_mode_match_timings(const struct drm_display_mode *mode1,\n\t\t\t\t   const struct drm_display_mode *mode2)\n{\n\treturn mode1->hdisplay == mode2->hdisplay &&\n\t\tmode1->hsync_start == mode2->hsync_start &&\n\t\tmode1->hsync_end == mode2->hsync_end &&\n\t\tmode1->htotal == mode2->htotal &&\n\t\tmode1->hskew == mode2->hskew &&\n\t\tmode1->vdisplay == mode2->vdisplay &&\n\t\tmode1->vsync_start == mode2->vsync_start &&\n\t\tmode1->vsync_end == mode2->vsync_end &&\n\t\tmode1->vtotal == mode2->vtotal &&\n\t\tmode1->vscan == mode2->vscan;\n}\n\nstatic bool drm_mode_match_clock(const struct drm_display_mode *mode1,\n\t\t\t\t  const struct drm_display_mode *mode2)\n{\n\t \n\tif (mode1->clock && mode2->clock)\n\t\treturn KHZ2PICOS(mode1->clock) == KHZ2PICOS(mode2->clock);\n\telse\n\t\treturn mode1->clock == mode2->clock;\n}\n\nstatic bool drm_mode_match_flags(const struct drm_display_mode *mode1,\n\t\t\t\t const struct drm_display_mode *mode2)\n{\n\treturn (mode1->flags & ~DRM_MODE_FLAG_3D_MASK) ==\n\t\t(mode2->flags & ~DRM_MODE_FLAG_3D_MASK);\n}\n\nstatic bool drm_mode_match_3d_flags(const struct drm_display_mode *mode1,\n\t\t\t\t    const struct drm_display_mode *mode2)\n{\n\treturn (mode1->flags & DRM_MODE_FLAG_3D_MASK) ==\n\t\t(mode2->flags & DRM_MODE_FLAG_3D_MASK);\n}\n\nstatic bool drm_mode_match_aspect_ratio(const struct drm_display_mode *mode1,\n\t\t\t\t\tconst struct drm_display_mode *mode2)\n{\n\treturn mode1->picture_aspect_ratio == mode2->picture_aspect_ratio;\n}\n\n \nbool drm_mode_match(const struct drm_display_mode *mode1,\n\t\t    const struct drm_display_mode *mode2,\n\t\t    unsigned int match_flags)\n{\n\tif (!mode1 && !mode2)\n\t\treturn true;\n\n\tif (!mode1 || !mode2)\n\t\treturn false;\n\n\tif (match_flags & DRM_MODE_MATCH_TIMINGS &&\n\t    !drm_mode_match_timings(mode1, mode2))\n\t\treturn false;\n\n\tif (match_flags & DRM_MODE_MATCH_CLOCK &&\n\t    !drm_mode_match_clock(mode1, mode2))\n\t\treturn false;\n\n\tif (match_flags & DRM_MODE_MATCH_FLAGS &&\n\t    !drm_mode_match_flags(mode1, mode2))\n\t\treturn false;\n\n\tif (match_flags & DRM_MODE_MATCH_3D_FLAGS &&\n\t    !drm_mode_match_3d_flags(mode1, mode2))\n\t\treturn false;\n\n\tif (match_flags & DRM_MODE_MATCH_ASPECT_RATIO &&\n\t    !drm_mode_match_aspect_ratio(mode1, mode2))\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_mode_match);\n\n \nbool drm_mode_equal(const struct drm_display_mode *mode1,\n\t\t    const struct drm_display_mode *mode2)\n{\n\treturn drm_mode_match(mode1, mode2,\n\t\t\t      DRM_MODE_MATCH_TIMINGS |\n\t\t\t      DRM_MODE_MATCH_CLOCK |\n\t\t\t      DRM_MODE_MATCH_FLAGS |\n\t\t\t      DRM_MODE_MATCH_3D_FLAGS|\n\t\t\t      DRM_MODE_MATCH_ASPECT_RATIO);\n}\nEXPORT_SYMBOL(drm_mode_equal);\n\n \nbool drm_mode_equal_no_clocks(const struct drm_display_mode *mode1,\n\t\t\t      const struct drm_display_mode *mode2)\n{\n\treturn drm_mode_match(mode1, mode2,\n\t\t\t      DRM_MODE_MATCH_TIMINGS |\n\t\t\t      DRM_MODE_MATCH_FLAGS |\n\t\t\t      DRM_MODE_MATCH_3D_FLAGS);\n}\nEXPORT_SYMBOL(drm_mode_equal_no_clocks);\n\n \nbool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,\n\t\t\t\t\tconst struct drm_display_mode *mode2)\n{\n\treturn drm_mode_match(mode1, mode2,\n\t\t\t      DRM_MODE_MATCH_TIMINGS |\n\t\t\t      DRM_MODE_MATCH_FLAGS);\n}\nEXPORT_SYMBOL(drm_mode_equal_no_clocks_no_stereo);\n\nstatic enum drm_mode_status\ndrm_mode_validate_basic(const struct drm_display_mode *mode)\n{\n\tif (mode->type & ~DRM_MODE_TYPE_ALL)\n\t\treturn MODE_BAD;\n\n\tif (mode->flags & ~DRM_MODE_FLAG_ALL)\n\t\treturn MODE_BAD;\n\n\tif ((mode->flags & DRM_MODE_FLAG_3D_MASK) > DRM_MODE_FLAG_3D_MAX)\n\t\treturn MODE_BAD;\n\n\tif (mode->clock == 0)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (mode->hdisplay == 0 ||\n\t    mode->hsync_start < mode->hdisplay ||\n\t    mode->hsync_end < mode->hsync_start ||\n\t    mode->htotal < mode->hsync_end)\n\t\treturn MODE_H_ILLEGAL;\n\n\tif (mode->vdisplay == 0 ||\n\t    mode->vsync_start < mode->vdisplay ||\n\t    mode->vsync_end < mode->vsync_start ||\n\t    mode->vtotal < mode->vsync_end)\n\t\treturn MODE_V_ILLEGAL;\n\n\treturn MODE_OK;\n}\n\n \nenum drm_mode_status\ndrm_mode_validate_driver(struct drm_device *dev,\n\t\t\tconst struct drm_display_mode *mode)\n{\n\tenum drm_mode_status status;\n\n\tstatus = drm_mode_validate_basic(mode);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\tif (dev->mode_config.funcs->mode_valid)\n\t\treturn dev->mode_config.funcs->mode_valid(dev, mode);\n\telse\n\t\treturn MODE_OK;\n}\nEXPORT_SYMBOL(drm_mode_validate_driver);\n\n \nenum drm_mode_status\ndrm_mode_validate_size(const struct drm_display_mode *mode,\n\t\t       int maxX, int maxY)\n{\n\tif (maxX > 0 && mode->hdisplay > maxX)\n\t\treturn MODE_VIRTUAL_X;\n\n\tif (maxY > 0 && mode->vdisplay > maxY)\n\t\treturn MODE_VIRTUAL_Y;\n\n\treturn MODE_OK;\n}\nEXPORT_SYMBOL(drm_mode_validate_size);\n\n \nenum drm_mode_status\ndrm_mode_validate_ycbcr420(const struct drm_display_mode *mode,\n\t\t\t   struct drm_connector *connector)\n{\n\tif (!connector->ycbcr_420_allowed &&\n\t    drm_mode_is_420_only(&connector->display_info, mode))\n\t\treturn MODE_NO_420;\n\n\treturn MODE_OK;\n}\nEXPORT_SYMBOL(drm_mode_validate_ycbcr420);\n\n#define MODE_STATUS(status) [MODE_ ## status + 3] = #status\n\nstatic const char * const drm_mode_status_names[] = {\n\tMODE_STATUS(OK),\n\tMODE_STATUS(HSYNC),\n\tMODE_STATUS(VSYNC),\n\tMODE_STATUS(H_ILLEGAL),\n\tMODE_STATUS(V_ILLEGAL),\n\tMODE_STATUS(BAD_WIDTH),\n\tMODE_STATUS(NOMODE),\n\tMODE_STATUS(NO_INTERLACE),\n\tMODE_STATUS(NO_DBLESCAN),\n\tMODE_STATUS(NO_VSCAN),\n\tMODE_STATUS(MEM),\n\tMODE_STATUS(VIRTUAL_X),\n\tMODE_STATUS(VIRTUAL_Y),\n\tMODE_STATUS(MEM_VIRT),\n\tMODE_STATUS(NOCLOCK),\n\tMODE_STATUS(CLOCK_HIGH),\n\tMODE_STATUS(CLOCK_LOW),\n\tMODE_STATUS(CLOCK_RANGE),\n\tMODE_STATUS(BAD_HVALUE),\n\tMODE_STATUS(BAD_VVALUE),\n\tMODE_STATUS(BAD_VSCAN),\n\tMODE_STATUS(HSYNC_NARROW),\n\tMODE_STATUS(HSYNC_WIDE),\n\tMODE_STATUS(HBLANK_NARROW),\n\tMODE_STATUS(HBLANK_WIDE),\n\tMODE_STATUS(VSYNC_NARROW),\n\tMODE_STATUS(VSYNC_WIDE),\n\tMODE_STATUS(VBLANK_NARROW),\n\tMODE_STATUS(VBLANK_WIDE),\n\tMODE_STATUS(PANEL),\n\tMODE_STATUS(INTERLACE_WIDTH),\n\tMODE_STATUS(ONE_WIDTH),\n\tMODE_STATUS(ONE_HEIGHT),\n\tMODE_STATUS(ONE_SIZE),\n\tMODE_STATUS(NO_REDUCED),\n\tMODE_STATUS(NO_STEREO),\n\tMODE_STATUS(NO_420),\n\tMODE_STATUS(STALE),\n\tMODE_STATUS(BAD),\n\tMODE_STATUS(ERROR),\n};\n\n#undef MODE_STATUS\n\nconst char *drm_get_mode_status_name(enum drm_mode_status status)\n{\n\tint index = status + 3;\n\n\tif (WARN_ON(index < 0 || index >= ARRAY_SIZE(drm_mode_status_names)))\n\t\treturn \"\";\n\n\treturn drm_mode_status_names[index];\n}\n\n \nvoid drm_mode_prune_invalid(struct drm_device *dev,\n\t\t\t    struct list_head *mode_list, bool verbose)\n{\n\tstruct drm_display_mode *mode, *t;\n\n\tlist_for_each_entry_safe(mode, t, mode_list, head) {\n\t\tif (mode->status != MODE_OK) {\n\t\t\tlist_del(&mode->head);\n\t\t\tif (mode->type & DRM_MODE_TYPE_USERDEF) {\n\t\t\t\tdrm_warn(dev, \"User-defined mode not supported: \"\n\t\t\t\t\t DRM_MODE_FMT \"\\n\", DRM_MODE_ARG(mode));\n\t\t\t}\n\t\t\tif (verbose) {\n\t\t\t\tdrm_mode_debug_printmodeline(mode);\n\t\t\t\tDRM_DEBUG_KMS(\"Not using %s mode: %s\\n\",\n\t\t\t\t\t      mode->name,\n\t\t\t\t\t      drm_get_mode_status_name(mode->status));\n\t\t\t}\n\t\t\tdrm_mode_destroy(dev, mode);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(drm_mode_prune_invalid);\n\n \nstatic int drm_mode_compare(void *priv, const struct list_head *lh_a,\n\t\t\t    const struct list_head *lh_b)\n{\n\tstruct drm_display_mode *a = list_entry(lh_a, struct drm_display_mode, head);\n\tstruct drm_display_mode *b = list_entry(lh_b, struct drm_display_mode, head);\n\tint diff;\n\n\tdiff = ((b->type & DRM_MODE_TYPE_PREFERRED) != 0) -\n\t\t((a->type & DRM_MODE_TYPE_PREFERRED) != 0);\n\tif (diff)\n\t\treturn diff;\n\tdiff = b->hdisplay * b->vdisplay - a->hdisplay * a->vdisplay;\n\tif (diff)\n\t\treturn diff;\n\n\tdiff = drm_mode_vrefresh(b) - drm_mode_vrefresh(a);\n\tif (diff)\n\t\treturn diff;\n\n\tdiff = b->clock - a->clock;\n\treturn diff;\n}\n\n \nvoid drm_mode_sort(struct list_head *mode_list)\n{\n\tlist_sort(NULL, mode_list, drm_mode_compare);\n}\nEXPORT_SYMBOL(drm_mode_sort);\n\n \nvoid drm_connector_list_update(struct drm_connector *connector)\n{\n\tstruct drm_display_mode *pmode, *pt;\n\n\tWARN_ON(!mutex_is_locked(&connector->dev->mode_config.mutex));\n\n\tlist_for_each_entry_safe(pmode, pt, &connector->probed_modes, head) {\n\t\tstruct drm_display_mode *mode;\n\t\tbool found_it = false;\n\n\t\t \n\t\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\t\tif (!drm_mode_equal(pmode, mode))\n\t\t\t\tcontinue;\n\n\t\t\tfound_it = true;\n\n\t\t\t \n\t\t\tif (mode->status == MODE_STALE) {\n\t\t\t\tdrm_mode_copy(mode, pmode);\n\t\t\t} else if ((mode->type & DRM_MODE_TYPE_PREFERRED) == 0 &&\n\t\t\t\t   (pmode->type & DRM_MODE_TYPE_PREFERRED) != 0) {\n\t\t\t\tpmode->type |= mode->type;\n\t\t\t\tdrm_mode_copy(mode, pmode);\n\t\t\t} else {\n\t\t\t\tmode->type |= pmode->type;\n\t\t\t}\n\n\t\t\tlist_del(&pmode->head);\n\t\t\tdrm_mode_destroy(connector->dev, pmode);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!found_it) {\n\t\t\tlist_move_tail(&pmode->head, &connector->modes);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(drm_connector_list_update);\n\nstatic int drm_mode_parse_cmdline_bpp(const char *str, char **end_ptr,\n\t\t\t\t      struct drm_cmdline_mode *mode)\n{\n\tunsigned int bpp;\n\n\tif (str[0] != '-')\n\t\treturn -EINVAL;\n\n\tstr++;\n\tbpp = simple_strtol(str, end_ptr, 10);\n\tif (*end_ptr == str)\n\t\treturn -EINVAL;\n\n\tmode->bpp = bpp;\n\tmode->bpp_specified = true;\n\n\treturn 0;\n}\n\nstatic int drm_mode_parse_cmdline_refresh(const char *str, char **end_ptr,\n\t\t\t\t\t  struct drm_cmdline_mode *mode)\n{\n\tunsigned int refresh;\n\n\tif (str[0] != '@')\n\t\treturn -EINVAL;\n\n\tstr++;\n\trefresh = simple_strtol(str, end_ptr, 10);\n\tif (*end_ptr == str)\n\t\treturn -EINVAL;\n\n\tmode->refresh = refresh;\n\tmode->refresh_specified = true;\n\n\treturn 0;\n}\n\nstatic int drm_mode_parse_cmdline_extra(const char *str, int length,\n\t\t\t\t\tbool freestanding,\n\t\t\t\t\tconst struct drm_connector *connector,\n\t\t\t\t\tstruct drm_cmdline_mode *mode)\n{\n\tint i;\n\n\tfor (i = 0; i < length; i++) {\n\t\tswitch (str[i]) {\n\t\tcase 'i':\n\t\t\tif (freestanding)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmode->interlace = true;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (freestanding)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmode->margins = true;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (mode->force != DRM_FORCE_UNSPECIFIED)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif ((connector->connector_type != DRM_MODE_CONNECTOR_DVII) &&\n\t\t\t    (connector->connector_type != DRM_MODE_CONNECTOR_HDMIB))\n\t\t\t\tmode->force = DRM_FORCE_ON;\n\t\t\telse\n\t\t\t\tmode->force = DRM_FORCE_ON_DIGITAL;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (mode->force != DRM_FORCE_UNSPECIFIED)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmode->force = DRM_FORCE_OFF;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif (mode->force != DRM_FORCE_UNSPECIFIED)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmode->force = DRM_FORCE_ON;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int drm_mode_parse_cmdline_res_mode(const char *str, unsigned int length,\n\t\t\t\t\t   bool extras,\n\t\t\t\t\t   const struct drm_connector *connector,\n\t\t\t\t\t   struct drm_cmdline_mode *mode)\n{\n\tconst char *str_start = str;\n\tbool rb = false, cvt = false;\n\tint xres = 0, yres = 0;\n\tint remaining, i;\n\tchar *end_ptr;\n\n\txres = simple_strtol(str, &end_ptr, 10);\n\tif (end_ptr == str)\n\t\treturn -EINVAL;\n\n\tif (end_ptr[0] != 'x')\n\t\treturn -EINVAL;\n\tend_ptr++;\n\n\tstr = end_ptr;\n\tyres = simple_strtol(str, &end_ptr, 10);\n\tif (end_ptr == str)\n\t\treturn -EINVAL;\n\n\tremaining = length - (end_ptr - str_start);\n\tif (remaining < 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < remaining; i++) {\n\t\tswitch (end_ptr[i]) {\n\t\tcase 'M':\n\t\t\tcvt = true;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trb = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (extras) {\n\t\t\t\tint ret = drm_mode_parse_cmdline_extra(end_ptr + i,\n\t\t\t\t\t\t\t\t       1,\n\t\t\t\t\t\t\t\t       false,\n\t\t\t\t\t\t\t\t       connector,\n\t\t\t\t\t\t\t\t       mode);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tmode->xres = xres;\n\tmode->yres = yres;\n\tmode->cvt = cvt;\n\tmode->rb = rb;\n\n\treturn 0;\n}\n\nstatic int drm_mode_parse_cmdline_int(const char *delim, unsigned int *int_ret)\n{\n\tconst char *value;\n\tchar *endp;\n\n\t \n\tif (*delim != '=')\n\t\treturn -EINVAL;\n\n\tvalue = delim + 1;\n\t*int_ret = simple_strtol(value, &endp, 10);\n\n\t \n\tif (endp == value)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int drm_mode_parse_panel_orientation(const char *delim,\n\t\t\t\t\t    struct drm_cmdline_mode *mode)\n{\n\tconst char *value;\n\n\tif (*delim != '=')\n\t\treturn -EINVAL;\n\n\tvalue = delim + 1;\n\tdelim = strchr(value, ',');\n\tif (!delim)\n\t\tdelim = value + strlen(value);\n\n\tif (!strncmp(value, \"normal\", delim - value))\n\t\tmode->panel_orientation = DRM_MODE_PANEL_ORIENTATION_NORMAL;\n\telse if (!strncmp(value, \"upside_down\", delim - value))\n\t\tmode->panel_orientation = DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP;\n\telse if (!strncmp(value, \"left_side_up\", delim - value))\n\t\tmode->panel_orientation = DRM_MODE_PANEL_ORIENTATION_LEFT_UP;\n\telse if (!strncmp(value, \"right_side_up\", delim - value))\n\t\tmode->panel_orientation = DRM_MODE_PANEL_ORIENTATION_RIGHT_UP;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int drm_mode_parse_tv_mode(const char *delim,\n\t\t\t\t  struct drm_cmdline_mode *mode)\n{\n\tconst char *value;\n\tint ret;\n\n\tif (*delim != '=')\n\t\treturn -EINVAL;\n\n\tvalue = delim + 1;\n\tdelim = strchr(value, ',');\n\tif (!delim)\n\t\tdelim = value + strlen(value);\n\n\tret = drm_get_tv_mode_from_name(value, delim - value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmode->tv_mode_specified = true;\n\tmode->tv_mode = ret;\n\n\treturn 0;\n}\n\nstatic int drm_mode_parse_cmdline_options(const char *str,\n\t\t\t\t\t  bool freestanding,\n\t\t\t\t\t  const struct drm_connector *connector,\n\t\t\t\t\t  struct drm_cmdline_mode *mode)\n{\n\tunsigned int deg, margin, rotation = 0;\n\tconst char *delim, *option, *sep;\n\n\toption = str;\n\tdo {\n\t\tdelim = strchr(option, '=');\n\t\tif (!delim) {\n\t\t\tdelim = strchr(option, ',');\n\n\t\t\tif (!delim)\n\t\t\t\tdelim = option + strlen(option);\n\t\t}\n\n\t\tif (!strncmp(option, \"rotate\", delim - option)) {\n\t\t\tif (drm_mode_parse_cmdline_int(delim, &deg))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tswitch (deg) {\n\t\t\tcase 0:\n\t\t\t\trotation |= DRM_MODE_ROTATE_0;\n\t\t\t\tbreak;\n\n\t\t\tcase 90:\n\t\t\t\trotation |= DRM_MODE_ROTATE_90;\n\t\t\t\tbreak;\n\n\t\t\tcase 180:\n\t\t\t\trotation |= DRM_MODE_ROTATE_180;\n\t\t\t\tbreak;\n\n\t\t\tcase 270:\n\t\t\t\trotation |= DRM_MODE_ROTATE_270;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (!strncmp(option, \"reflect_x\", delim - option)) {\n\t\t\trotation |= DRM_MODE_REFLECT_X;\n\t\t} else if (!strncmp(option, \"reflect_y\", delim - option)) {\n\t\t\trotation |= DRM_MODE_REFLECT_Y;\n\t\t} else if (!strncmp(option, \"margin_right\", delim - option)) {\n\t\t\tif (drm_mode_parse_cmdline_int(delim, &margin))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmode->tv_margins.right = margin;\n\t\t} else if (!strncmp(option, \"margin_left\", delim - option)) {\n\t\t\tif (drm_mode_parse_cmdline_int(delim, &margin))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmode->tv_margins.left = margin;\n\t\t} else if (!strncmp(option, \"margin_top\", delim - option)) {\n\t\t\tif (drm_mode_parse_cmdline_int(delim, &margin))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmode->tv_margins.top = margin;\n\t\t} else if (!strncmp(option, \"margin_bottom\", delim - option)) {\n\t\t\tif (drm_mode_parse_cmdline_int(delim, &margin))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmode->tv_margins.bottom = margin;\n\t\t} else if (!strncmp(option, \"panel_orientation\", delim - option)) {\n\t\t\tif (drm_mode_parse_panel_orientation(delim, mode))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(option, \"tv_mode\", delim - option)) {\n\t\t\tif (drm_mode_parse_tv_mode(delim, mode))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsep = strchr(delim, ',');\n\t\toption = sep + 1;\n\t} while (sep);\n\n\tif (rotation && freestanding)\n\t\treturn -EINVAL;\n\n\tif (!(rotation & DRM_MODE_ROTATE_MASK))\n\t\trotation |= DRM_MODE_ROTATE_0;\n\n\t \n\tif (!is_power_of_2(rotation & DRM_MODE_ROTATE_MASK))\n\t\treturn -EINVAL;\n\n\tmode->rotation_reflection = rotation;\n\n\treturn 0;\n}\n\nstruct drm_named_mode {\n\tconst char *name;\n\tunsigned int pixel_clock_khz;\n\tunsigned int xres;\n\tunsigned int yres;\n\tunsigned int flags;\n\tunsigned int tv_mode;\n};\n\n#define NAMED_MODE(_name, _pclk, _x, _y, _flags, _mode)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\\\n\t\t.pixel_clock_khz = _pclk,\t\t\\\n\t\t.xres = _x,\t\t\t\t\\\n\t\t.yres = _y,\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\\\n\t\t.tv_mode = _mode,\t\t\t\\\n\t}\n\nstatic const struct drm_named_mode drm_named_modes[] = {\n\tNAMED_MODE(\"NTSC\", 13500, 720, 480, DRM_MODE_FLAG_INTERLACE, DRM_MODE_TV_MODE_NTSC),\n\tNAMED_MODE(\"NTSC-J\", 13500, 720, 480, DRM_MODE_FLAG_INTERLACE, DRM_MODE_TV_MODE_NTSC_J),\n\tNAMED_MODE(\"PAL\", 13500, 720, 576, DRM_MODE_FLAG_INTERLACE, DRM_MODE_TV_MODE_PAL),\n\tNAMED_MODE(\"PAL-M\", 13500, 720, 480, DRM_MODE_FLAG_INTERLACE, DRM_MODE_TV_MODE_PAL_M),\n};\n\nstatic int drm_mode_parse_cmdline_named_mode(const char *name,\n\t\t\t\t\t     unsigned int name_end,\n\t\t\t\t\t     struct drm_cmdline_mode *cmdline_mode)\n{\n\tunsigned int i;\n\n\tif (!name_end)\n\t\treturn 0;\n\n\t \n\tif (isdigit(name[0]))\n\t\treturn 0;\n\n\t \n\tif (strnchr(name, name_end, '='))\n\t\treturn 0;\n\n\t \n\tif (name_end == 1 &&\n\t    (name[0] == 'd' || name[0] == 'D' || name[0] == 'e'))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(drm_named_modes); i++) {\n\t\tconst struct drm_named_mode *mode = &drm_named_modes[i];\n\t\tint ret;\n\n\t\tret = str_has_prefix(name, mode->name);\n\t\tif (ret != name_end)\n\t\t\tcontinue;\n\n\t\tstrscpy(cmdline_mode->name, mode->name, sizeof(cmdline_mode->name));\n\t\tcmdline_mode->pixel_clock = mode->pixel_clock_khz;\n\t\tcmdline_mode->xres = mode->xres;\n\t\tcmdline_mode->yres = mode->yres;\n\t\tcmdline_mode->interlace = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);\n\t\tcmdline_mode->tv_mode = mode->tv_mode;\n\t\tcmdline_mode->tv_mode_specified = true;\n\t\tcmdline_mode->specified = true;\n\n\t\treturn 1;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nbool drm_mode_parse_command_line_for_connector(const char *mode_option,\n\t\t\t\t\t       const struct drm_connector *connector,\n\t\t\t\t\t       struct drm_cmdline_mode *mode)\n{\n\tconst char *name;\n\tbool freestanding = false, parse_extras = false;\n\tunsigned int bpp_off = 0, refresh_off = 0, options_off = 0;\n\tunsigned int mode_end = 0;\n\tconst char *bpp_ptr = NULL, *refresh_ptr = NULL, *extra_ptr = NULL;\n\tconst char *options_ptr = NULL;\n\tchar *bpp_end_ptr = NULL, *refresh_end_ptr = NULL;\n\tint len, ret;\n\n\tmemset(mode, 0, sizeof(*mode));\n\tmode->panel_orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;\n\n\tif (!mode_option)\n\t\treturn false;\n\n\tname = mode_option;\n\n\t \n\toptions_ptr = strchr(name, ',');\n\tif (options_ptr)\n\t\toptions_off = options_ptr - name;\n\telse\n\t\toptions_off = strlen(name);\n\n\t \n\tbpp_ptr = strnchr(name, options_off, '-');\n\twhile (bpp_ptr && !isdigit(bpp_ptr[1]))\n\t\tbpp_ptr = strnchr(bpp_ptr + 1, options_off, '-');\n\tif (bpp_ptr)\n\t\tbpp_off = bpp_ptr - name;\n\n\trefresh_ptr = strnchr(name, options_off, '@');\n\tif (refresh_ptr)\n\t\trefresh_off = refresh_ptr - name;\n\n\t \n\tif (bpp_ptr) {\n\t\tmode_end = bpp_off;\n\t} else if (refresh_ptr) {\n\t\tmode_end = refresh_off;\n\t} else if (options_ptr) {\n\t\tmode_end = options_off;\n\t\tparse_extras = true;\n\t} else {\n\t\tmode_end = strlen(name);\n\t\tparse_extras = true;\n\t}\n\n\tif (!mode_end)\n\t\treturn false;\n\n\tret = drm_mode_parse_cmdline_named_mode(name, mode_end, mode);\n\tif (ret < 0)\n\t\treturn false;\n\n\t \n\tif (ret && refresh_ptr)\n\t\treturn false;\n\n\t \n\tif (!mode->specified && isdigit(name[0])) {\n\t\tret = drm_mode_parse_cmdline_res_mode(name, mode_end,\n\t\t\t\t\t\t      parse_extras,\n\t\t\t\t\t\t      connector,\n\t\t\t\t\t\t      mode);\n\t\tif (ret)\n\t\t\treturn false;\n\n\t\tmode->specified = true;\n\t}\n\n\t \n\tif (!mode->specified) {\n\t\tunsigned int len = strlen(mode_option);\n\n\t\tif (bpp_ptr || refresh_ptr)\n\t\t\treturn false;  \n\n\t\tif (len == 1 || (len >= 2 && mode_option[1] == ','))\n\t\t\textra_ptr = mode_option;\n\t\telse\n\t\t\toptions_ptr = mode_option - 1;\n\n\t\tfreestanding = true;\n\t}\n\n\tif (bpp_ptr) {\n\t\tret = drm_mode_parse_cmdline_bpp(bpp_ptr, &bpp_end_ptr, mode);\n\t\tif (ret)\n\t\t\treturn false;\n\n\t\tmode->bpp_specified = true;\n\t}\n\n\tif (refresh_ptr) {\n\t\tret = drm_mode_parse_cmdline_refresh(refresh_ptr,\n\t\t\t\t\t\t     &refresh_end_ptr, mode);\n\t\tif (ret)\n\t\t\treturn false;\n\n\t\tmode->refresh_specified = true;\n\t}\n\n\t \n\tif (bpp_ptr && refresh_ptr)\n\t\textra_ptr = max(bpp_end_ptr, refresh_end_ptr);\n\telse if (bpp_ptr)\n\t\textra_ptr = bpp_end_ptr;\n\telse if (refresh_ptr)\n\t\textra_ptr = refresh_end_ptr;\n\n\tif (extra_ptr) {\n\t\tif (options_ptr)\n\t\t\tlen = options_ptr - extra_ptr;\n\t\telse\n\t\t\tlen = strlen(extra_ptr);\n\n\t\tret = drm_mode_parse_cmdline_extra(extra_ptr, len, freestanding,\n\t\t\t\t\t\t   connector, mode);\n\t\tif (ret)\n\t\t\treturn false;\n\t}\n\n\tif (options_ptr) {\n\t\tret = drm_mode_parse_cmdline_options(options_ptr + 1,\n\t\t\t\t\t\t     freestanding,\n\t\t\t\t\t\t     connector, mode);\n\t\tif (ret)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_mode_parse_command_line_for_connector);\n\nstatic struct drm_display_mode *drm_named_mode(struct drm_device *dev,\n\t\t\t\t\t       struct drm_cmdline_mode *cmd)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(drm_named_modes); i++) {\n\t\tconst struct drm_named_mode *named_mode = &drm_named_modes[i];\n\n\t\tif (strcmp(cmd->name, named_mode->name))\n\t\t\tcontinue;\n\n\t\tif (!cmd->tv_mode_specified)\n\t\t\tcontinue;\n\n\t\treturn drm_analog_tv_mode(dev,\n\t\t\t\t\t  named_mode->tv_mode,\n\t\t\t\t\t  named_mode->pixel_clock_khz * 1000,\n\t\t\t\t\t  named_mode->xres,\n\t\t\t\t\t  named_mode->yres,\n\t\t\t\t\t  named_mode->flags & DRM_MODE_FLAG_INTERLACE);\n\t}\n\n\treturn NULL;\n}\n\n \nstruct drm_display_mode *\ndrm_mode_create_from_cmdline_mode(struct drm_device *dev,\n\t\t\t\t  struct drm_cmdline_mode *cmd)\n{\n\tstruct drm_display_mode *mode;\n\n\tif (cmd->xres == 0 || cmd->yres == 0)\n\t\treturn NULL;\n\n\tif (strlen(cmd->name))\n\t\tmode = drm_named_mode(dev, cmd);\n\telse if (cmd->cvt)\n\t\tmode = drm_cvt_mode(dev,\n\t\t\t\t    cmd->xres, cmd->yres,\n\t\t\t\t    cmd->refresh_specified ? cmd->refresh : 60,\n\t\t\t\t    cmd->rb, cmd->interlace,\n\t\t\t\t    cmd->margins);\n\telse\n\t\tmode = drm_gtf_mode(dev,\n\t\t\t\t    cmd->xres, cmd->yres,\n\t\t\t\t    cmd->refresh_specified ? cmd->refresh : 60,\n\t\t\t\t    cmd->interlace,\n\t\t\t\t    cmd->margins);\n\tif (!mode)\n\t\treturn NULL;\n\n\tmode->type |= DRM_MODE_TYPE_USERDEF;\n\t \n\tif (cmd->xres == 1366)\n\t\tdrm_mode_fixup_1366x768(mode);\n\tdrm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);\n\treturn mode;\n}\nEXPORT_SYMBOL(drm_mode_create_from_cmdline_mode);\n\n \nvoid drm_mode_convert_to_umode(struct drm_mode_modeinfo *out,\n\t\t\t       const struct drm_display_mode *in)\n{\n\tout->clock = in->clock;\n\tout->hdisplay = in->hdisplay;\n\tout->hsync_start = in->hsync_start;\n\tout->hsync_end = in->hsync_end;\n\tout->htotal = in->htotal;\n\tout->hskew = in->hskew;\n\tout->vdisplay = in->vdisplay;\n\tout->vsync_start = in->vsync_start;\n\tout->vsync_end = in->vsync_end;\n\tout->vtotal = in->vtotal;\n\tout->vscan = in->vscan;\n\tout->vrefresh = drm_mode_vrefresh(in);\n\tout->flags = in->flags;\n\tout->type = in->type;\n\n\tswitch (in->picture_aspect_ratio) {\n\tcase HDMI_PICTURE_ASPECT_4_3:\n\t\tout->flags |= DRM_MODE_FLAG_PIC_AR_4_3;\n\t\tbreak;\n\tcase HDMI_PICTURE_ASPECT_16_9:\n\t\tout->flags |= DRM_MODE_FLAG_PIC_AR_16_9;\n\t\tbreak;\n\tcase HDMI_PICTURE_ASPECT_64_27:\n\t\tout->flags |= DRM_MODE_FLAG_PIC_AR_64_27;\n\t\tbreak;\n\tcase HDMI_PICTURE_ASPECT_256_135:\n\t\tout->flags |= DRM_MODE_FLAG_PIC_AR_256_135;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid aspect ratio (0%x) on mode\\n\",\n\t\t     in->picture_aspect_ratio);\n\t\tfallthrough;\n\tcase HDMI_PICTURE_ASPECT_NONE:\n\t\tout->flags |= DRM_MODE_FLAG_PIC_AR_NONE;\n\t\tbreak;\n\t}\n\n\tstrncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);\n\tout->name[DRM_DISPLAY_MODE_LEN-1] = 0;\n}\n\n \nint drm_mode_convert_umode(struct drm_device *dev,\n\t\t\t   struct drm_display_mode *out,\n\t\t\t   const struct drm_mode_modeinfo *in)\n{\n\tif (in->clock > INT_MAX || in->vrefresh > INT_MAX)\n\t\treturn -ERANGE;\n\n\tout->clock = in->clock;\n\tout->hdisplay = in->hdisplay;\n\tout->hsync_start = in->hsync_start;\n\tout->hsync_end = in->hsync_end;\n\tout->htotal = in->htotal;\n\tout->hskew = in->hskew;\n\tout->vdisplay = in->vdisplay;\n\tout->vsync_start = in->vsync_start;\n\tout->vsync_end = in->vsync_end;\n\tout->vtotal = in->vtotal;\n\tout->vscan = in->vscan;\n\tout->flags = in->flags;\n\t \n\tout->type = in->type & DRM_MODE_TYPE_ALL;\n\tstrncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);\n\tout->name[DRM_DISPLAY_MODE_LEN-1] = 0;\n\n\t \n\tout->flags &= ~DRM_MODE_FLAG_PIC_AR_MASK;\n\n\tswitch (in->flags & DRM_MODE_FLAG_PIC_AR_MASK) {\n\tcase DRM_MODE_FLAG_PIC_AR_4_3:\n\t\tout->picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3;\n\t\tbreak;\n\tcase DRM_MODE_FLAG_PIC_AR_16_9:\n\t\tout->picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9;\n\t\tbreak;\n\tcase DRM_MODE_FLAG_PIC_AR_64_27:\n\t\tout->picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27;\n\t\tbreak;\n\tcase DRM_MODE_FLAG_PIC_AR_256_135:\n\t\tout->picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135;\n\t\tbreak;\n\tcase DRM_MODE_FLAG_PIC_AR_NONE:\n\t\tout->picture_aspect_ratio = HDMI_PICTURE_ASPECT_NONE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tout->status = drm_mode_validate_driver(dev, out);\n\tif (out->status != MODE_OK)\n\t\treturn -EINVAL;\n\n\tdrm_mode_set_crtcinfo(out, CRTC_INTERLACE_HALVE_V);\n\n\treturn 0;\n}\n\n \nbool drm_mode_is_420_only(const struct drm_display_info *display,\n\t\t\t  const struct drm_display_mode *mode)\n{\n\tu8 vic = drm_match_cea_mode(mode);\n\n\treturn test_bit(vic, display->hdmi.y420_vdb_modes);\n}\nEXPORT_SYMBOL(drm_mode_is_420_only);\n\n \nbool drm_mode_is_420_also(const struct drm_display_info *display,\n\t\t\t  const struct drm_display_mode *mode)\n{\n\tu8 vic = drm_match_cea_mode(mode);\n\n\treturn test_bit(vic, display->hdmi.y420_cmdb_modes);\n}\nEXPORT_SYMBOL(drm_mode_is_420_also);\n \nbool drm_mode_is_420(const struct drm_display_info *display,\n\t\t     const struct drm_display_mode *mode)\n{\n\treturn drm_mode_is_420_only(display, mode) ||\n\t\tdrm_mode_is_420_also(display, mode);\n}\nEXPORT_SYMBOL(drm_mode_is_420);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}