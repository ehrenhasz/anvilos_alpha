{
  "module_name": "drm_irq.c",
  "hash_id": "82cc5a6ee2e97be101a02a296d98372f3ed5bec6af0d50be8a566e8223ac5531",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_irq.c",
  "human_readable_source": " \n\n \n\n\n#include <linux/export.h>\n#include <linux/interrupt.h>\t \n#include <linux/pci.h>\n#include <linux/vgaarb.h>\n\n#include <drm/drm.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_legacy.h>\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n\n#include \"drm_internal.h\"\n\nstatic int drm_legacy_irq_install(struct drm_device *dev, int irq)\n{\n\tint ret;\n\tunsigned long sh_flags = 0;\n\n\tif (irq == 0)\n\t\treturn -EINVAL;\n\n\tif (dev->irq_enabled)\n\t\treturn -EBUSY;\n\tdev->irq_enabled = true;\n\n\tDRM_DEBUG(\"irq=%d\\n\", irq);\n\n\t \n\tif (dev->driver->irq_preinstall)\n\t\tdev->driver->irq_preinstall(dev);\n\n\t \n\tif (dev_is_pci(dev->dev))\n\t\tsh_flags = IRQF_SHARED;\n\n\tret = request_irq(irq, dev->driver->irq_handler,\n\t\t\t  sh_flags, dev->driver->name, dev);\n\n\tif (ret < 0) {\n\t\tdev->irq_enabled = false;\n\t\treturn ret;\n\t}\n\n\t \n\tif (dev->driver->irq_postinstall)\n\t\tret = dev->driver->irq_postinstall(dev);\n\n\tif (ret < 0) {\n\t\tdev->irq_enabled = false;\n\t\tif (drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\t\tvga_client_unregister(to_pci_dev(dev->dev));\n\t\tfree_irq(irq, dev);\n\t} else {\n\t\tdev->irq = irq;\n\t}\n\n\treturn ret;\n}\n\nint drm_legacy_irq_uninstall(struct drm_device *dev)\n{\n\tunsigned long irqflags;\n\tbool irq_enabled;\n\tint i;\n\n\tirq_enabled = dev->irq_enabled;\n\tdev->irq_enabled = false;\n\n\t \n\tif (drm_dev_has_vblank(dev)) {\n\t\tspin_lock_irqsave(&dev->vbl_lock, irqflags);\n\t\tfor (i = 0; i < dev->num_crtcs; i++) {\n\t\t\tstruct drm_vblank_crtc *vblank = &dev->vblank[i];\n\n\t\t\tif (!vblank->enabled)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON(drm_core_check_feature(dev, DRIVER_MODESET));\n\n\t\t\tdrm_vblank_disable_and_save(dev, i);\n\t\t\twake_up(&vblank->queue);\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\n\t}\n\n\tif (!irq_enabled)\n\t\treturn -EINVAL;\n\n\tDRM_DEBUG(\"irq=%d\\n\", dev->irq);\n\n\tif (drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\tvga_client_unregister(to_pci_dev(dev->dev));\n\n\tif (dev->driver->irq_uninstall)\n\t\tdev->driver->irq_uninstall(dev);\n\n\tfree_irq(dev->irq, dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_legacy_irq_uninstall);\n\nint drm_legacy_irq_control(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file_priv)\n{\n\tstruct drm_control *ctl = data;\n\tint ret = 0, irq;\n\tstruct pci_dev *pdev;\n\n\t \n\n\tif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\n\t\treturn 0;\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn 0;\n\t \n\tif (WARN_ON(!dev_is_pci(dev->dev)))\n\t\treturn -EINVAL;\n\n\tswitch (ctl->func) {\n\tcase DRM_INST_HANDLER:\n\t\tpdev = to_pci_dev(dev->dev);\n\t\tirq = pdev->irq;\n\n\t\tif (dev->if_version < DRM_IF_VERSION(1, 2) &&\n\t\t    ctl->irq != irq)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&dev->struct_mutex);\n\t\tret = drm_legacy_irq_install(dev, irq);\n\t\tmutex_unlock(&dev->struct_mutex);\n\n\t\treturn ret;\n\tcase DRM_UNINST_HANDLER:\n\t\tmutex_lock(&dev->struct_mutex);\n\t\tret = drm_legacy_irq_uninstall(dev);\n\t\tmutex_unlock(&dev->struct_mutex);\n\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}