{
  "module_name": "kmb_dsi.c",
  "hash_id": "a7f862f72e917ee8115ae4b7c41f27297f3f68e6f7edd174f87a3fba16bbe0cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/kmb/kmb_dsi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"kmb_dsi.h\"\n#include \"kmb_regs.h\"\n\nstatic struct mipi_dsi_host *dsi_host;\nstatic struct mipi_dsi_device *dsi_device;\nstatic struct drm_bridge *adv_bridge;\n\n \n#define IMG_HEIGHT_LINES  1080\n#define IMG_WIDTH_PX      1920\n#define MIPI_TX_ACTIVE_LANES 4\n\nstatic struct mipi_tx_frame_section_cfg mipi_tx_frame0_sect_cfg = {\n\t.width_pixels = IMG_WIDTH_PX,\n\t.height_lines = IMG_HEIGHT_LINES,\n\t.data_type = DSI_LP_DT_PPS_RGB888_24B,\n\t.data_mode = MIPI_DATA_MODE1,\n\t.dma_packed = 0\n};\n\nstatic struct mipi_tx_frame_cfg mipitx_frame0_cfg = {\n\t.sections[0] = &mipi_tx_frame0_sect_cfg,\n\t.sections[1] = NULL,\n\t.sections[2] = NULL,\n\t.sections[3] = NULL,\n\t.vsync_width = 5,\n\t.v_backporch = 36,\n\t.v_frontporch = 4,\n\t.hsync_width = 44,\n\t.h_backporch = 148,\n\t.h_frontporch = 88\n};\n\nstatic const struct mipi_tx_dsi_cfg mipitx_dsi_cfg = {\n\t.hfp_blank_en = 0,\n\t.eotp_en = 0,\n\t.lpm_last_vfp_line = 0,\n\t.lpm_first_vsa_line = 0,\n\t.sync_pulse_eventn = DSI_VIDEO_MODE_NO_BURST_EVENT,\n\t.hfp_blanking = SEND_BLANK_PACKET,\n\t.hbp_blanking = SEND_BLANK_PACKET,\n\t.hsa_blanking = SEND_BLANK_PACKET,\n\t.v_blanking = SEND_BLANK_PACKET,\n};\n\nstatic struct mipi_ctrl_cfg mipi_tx_init_cfg = {\n\t.active_lanes = MIPI_TX_ACTIVE_LANES,\n\t.lane_rate_mbps = MIPI_TX_LANE_DATA_RATE_MBPS,\n\t.ref_clk_khz = MIPI_TX_REF_CLK_KHZ,\n\t.cfg_clk_khz = MIPI_TX_CFG_CLK_KHZ,\n\t.tx_ctrl_cfg = {\n\t\t\t.frames[0] = &mipitx_frame0_cfg,\n\t\t\t.frames[1] = NULL,\n\t\t\t.frames[2] = NULL,\n\t\t\t.frames[3] = NULL,\n\t\t\t.tx_dsi_cfg = &mipitx_dsi_cfg,\n\t\t\t.line_sync_pkt_en = 0,\n\t\t\t.line_counter_active = 0,\n\t\t\t.frame_counter_active = 0,\n\t\t\t.tx_always_use_hact = 1,\n\t\t\t.tx_hact_wait_stop = 1,\n\t\t\t}\n};\n\nstruct  mipi_hs_freq_range_cfg {\n\tu16 default_bit_rate_mbps;\n\tu8 hsfreqrange_code;\n};\n\nstruct vco_params {\n\tu32 freq;\n\tu32 range;\n\tu32 divider;\n};\n\nstatic const struct vco_params vco_table[] = {\n\t{52, 0x3f, 8},\n\t{80, 0x39, 8},\n\t{105, 0x2f, 4},\n\t{160, 0x29, 4},\n\t{210, 0x1f, 2},\n\t{320, 0x19, 2},\n\t{420, 0x0f, 1},\n\t{630, 0x09, 1},\n\t{1100, 0x03, 1},\n\t{0xffff, 0x01, 1},\n};\n\nstatic const struct mipi_hs_freq_range_cfg\nmipi_hs_freq_range[MIPI_DPHY_DEFAULT_BIT_RATES] = {\n\t{.default_bit_rate_mbps = 80, .hsfreqrange_code = 0x00},\n\t{.default_bit_rate_mbps = 90, .hsfreqrange_code = 0x10},\n\t{.default_bit_rate_mbps = 100, .hsfreqrange_code = 0x20},\n\t{.default_bit_rate_mbps = 110, .hsfreqrange_code = 0x30},\n\t{.default_bit_rate_mbps = 120, .hsfreqrange_code = 0x01},\n\t{.default_bit_rate_mbps = 130, .hsfreqrange_code = 0x11},\n\t{.default_bit_rate_mbps = 140, .hsfreqrange_code = 0x21},\n\t{.default_bit_rate_mbps = 150, .hsfreqrange_code = 0x31},\n\t{.default_bit_rate_mbps = 160, .hsfreqrange_code = 0x02},\n\t{.default_bit_rate_mbps = 170, .hsfreqrange_code = 0x12},\n\t{.default_bit_rate_mbps = 180, .hsfreqrange_code = 0x22},\n\t{.default_bit_rate_mbps = 190, .hsfreqrange_code = 0x32},\n\t{.default_bit_rate_mbps = 205, .hsfreqrange_code = 0x03},\n\t{.default_bit_rate_mbps = 220, .hsfreqrange_code = 0x13},\n\t{.default_bit_rate_mbps = 235, .hsfreqrange_code = 0x23},\n\t{.default_bit_rate_mbps = 250, .hsfreqrange_code = 0x33},\n\t{.default_bit_rate_mbps = 275, .hsfreqrange_code = 0x04},\n\t{.default_bit_rate_mbps = 300, .hsfreqrange_code = 0x14},\n\t{.default_bit_rate_mbps = 325, .hsfreqrange_code = 0x25},\n\t{.default_bit_rate_mbps = 350, .hsfreqrange_code = 0x35},\n\t{.default_bit_rate_mbps = 400, .hsfreqrange_code = 0x05},\n\t{.default_bit_rate_mbps = 450, .hsfreqrange_code = 0x16},\n\t{.default_bit_rate_mbps = 500, .hsfreqrange_code = 0x26},\n\t{.default_bit_rate_mbps = 550, .hsfreqrange_code = 0x37},\n\t{.default_bit_rate_mbps = 600, .hsfreqrange_code = 0x07},\n\t{.default_bit_rate_mbps = 650, .hsfreqrange_code = 0x18},\n\t{.default_bit_rate_mbps = 700, .hsfreqrange_code = 0x28},\n\t{.default_bit_rate_mbps = 750, .hsfreqrange_code = 0x39},\n\t{.default_bit_rate_mbps = 800, .hsfreqrange_code = 0x09},\n\t{.default_bit_rate_mbps = 850, .hsfreqrange_code = 0x19},\n\t{.default_bit_rate_mbps = 900, .hsfreqrange_code = 0x29},\n\t{.default_bit_rate_mbps = 1000, .hsfreqrange_code = 0x0A},\n\t{.default_bit_rate_mbps = 1050, .hsfreqrange_code = 0x1A},\n\t{.default_bit_rate_mbps = 1100, .hsfreqrange_code = 0x2A},\n\t{.default_bit_rate_mbps = 1150, .hsfreqrange_code = 0x3B},\n\t{.default_bit_rate_mbps = 1200, .hsfreqrange_code = 0x0B},\n\t{.default_bit_rate_mbps = 1250, .hsfreqrange_code = 0x1B},\n\t{.default_bit_rate_mbps = 1300, .hsfreqrange_code = 0x2B},\n\t{.default_bit_rate_mbps = 1350, .hsfreqrange_code = 0x3C},\n\t{.default_bit_rate_mbps = 1400, .hsfreqrange_code = 0x0C},\n\t{.default_bit_rate_mbps = 1450, .hsfreqrange_code = 0x1C},\n\t{.default_bit_rate_mbps = 1500, .hsfreqrange_code = 0x2C},\n\t{.default_bit_rate_mbps = 1550, .hsfreqrange_code = 0x3D},\n\t{.default_bit_rate_mbps = 1600, .hsfreqrange_code = 0x0D},\n\t{.default_bit_rate_mbps = 1650, .hsfreqrange_code = 0x1D},\n\t{.default_bit_rate_mbps = 1700, .hsfreqrange_code = 0x2E},\n\t{.default_bit_rate_mbps = 1750, .hsfreqrange_code = 0x3E},\n\t{.default_bit_rate_mbps = 1800, .hsfreqrange_code = 0x0E},\n\t{.default_bit_rate_mbps = 1850, .hsfreqrange_code = 0x1E},\n\t{.default_bit_rate_mbps = 1900, .hsfreqrange_code = 0x2F},\n\t{.default_bit_rate_mbps = 1950, .hsfreqrange_code = 0x3F},\n\t{.default_bit_rate_mbps = 2000, .hsfreqrange_code = 0x0F},\n\t{.default_bit_rate_mbps = 2050, .hsfreqrange_code = 0x40},\n\t{.default_bit_rate_mbps = 2100, .hsfreqrange_code = 0x41},\n\t{.default_bit_rate_mbps = 2150, .hsfreqrange_code = 0x42},\n\t{.default_bit_rate_mbps = 2200, .hsfreqrange_code = 0x43},\n\t{.default_bit_rate_mbps = 2250, .hsfreqrange_code = 0x44},\n\t{.default_bit_rate_mbps = 2300, .hsfreqrange_code = 0x45},\n\t{.default_bit_rate_mbps = 2350, .hsfreqrange_code = 0x46},\n\t{.default_bit_rate_mbps = 2400, .hsfreqrange_code = 0x47},\n\t{.default_bit_rate_mbps = 2450, .hsfreqrange_code = 0x48},\n\t{.default_bit_rate_mbps = 2500, .hsfreqrange_code = 0x49}\n};\n\nstatic void kmb_dsi_clk_disable(struct kmb_dsi *kmb_dsi)\n{\n\tclk_disable_unprepare(kmb_dsi->clk_mipi);\n\tclk_disable_unprepare(kmb_dsi->clk_mipi_ecfg);\n\tclk_disable_unprepare(kmb_dsi->clk_mipi_cfg);\n}\n\nvoid kmb_dsi_host_unregister(struct kmb_dsi *kmb_dsi)\n{\n\tkmb_dsi_clk_disable(kmb_dsi);\n\tmipi_dsi_host_unregister(kmb_dsi->host);\n}\n\n \nstatic ssize_t kmb_dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t     const struct mipi_dsi_msg *msg)\n{\n\treturn 0;\n}\n\nstatic int kmb_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t       struct mipi_dsi_device *dev)\n{\n\treturn 0;\n}\n\nstatic int kmb_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t       struct mipi_dsi_device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct mipi_dsi_host_ops kmb_dsi_host_ops = {\n\t.attach = kmb_dsi_host_attach,\n\t.detach = kmb_dsi_host_detach,\n\t.transfer = kmb_dsi_host_transfer,\n};\n\nint kmb_dsi_host_bridge_init(struct device *dev)\n{\n\tstruct device_node *encoder_node, *dsi_out;\n\n\t \n\tif (!dsi_host) {\n\t\tdsi_host = kzalloc(sizeof(*dsi_host), GFP_KERNEL);\n\t\tif (!dsi_host)\n\t\t\treturn -ENOMEM;\n\n\t\tdsi_host->ops = &kmb_dsi_host_ops;\n\n\t\tif (!dsi_device) {\n\t\t\tdsi_device = kzalloc(sizeof(*dsi_device), GFP_KERNEL);\n\t\t\tif (!dsi_device) {\n\t\t\t\tkfree(dsi_host);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tdsi_host->dev = dev;\n\t\tmipi_dsi_host_register(dsi_host);\n\t}\n\n\t \n\tdsi_out = of_graph_get_endpoint_by_regs(dev->of_node, 0, 1);\n\tif (!dsi_out) {\n\t\tDRM_ERROR(\"Failed to get dsi_out node info from DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\tencoder_node = of_graph_get_remote_port_parent(dsi_out);\n\tif (!encoder_node) {\n\t\tof_node_put(dsi_out);\n\t\tDRM_ERROR(\"Failed to get bridge info from DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tadv_bridge = of_drm_find_bridge(encoder_node);\n\tof_node_put(dsi_out);\n\tof_node_put(encoder_node);\n\tif (!adv_bridge) {\n\t\tDRM_DEBUG(\"Wait for external bridge driver DT\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 mipi_get_datatype_params(u32 data_type, u32 data_mode,\n\t\t\t\t    struct mipi_data_type_params *params)\n{\n\tstruct mipi_data_type_params data_type_param;\n\n\tswitch (data_type) {\n\tcase DSI_LP_DT_PPS_YCBCR420_12B:\n\t\tdata_type_param.size_constraint_pixels = 2;\n\t\tdata_type_param.size_constraint_bytes = 3;\n\t\tswitch (data_mode) {\n\t\t\t \n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tdata_type_param.pixels_per_pclk = 2;\n\t\t\tdata_type_param.bits_per_pclk = 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"DSI: Invalid data_mode %d\\n\", data_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DSI_LP_DT_PPS_YCBCR422_16B:\n\t\tdata_type_param.size_constraint_pixels = 2;\n\t\tdata_type_param.size_constraint_bytes = 4;\n\t\tswitch (data_mode) {\n\t\t\t \n\t\tcase 2:\n\t\t\tdata_type_param.pixels_per_pclk = 1;\n\t\t\tdata_type_param.bits_per_pclk = 16;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdata_type_param.pixels_per_pclk = 2;\n\t\t\tdata_type_param.bits_per_pclk = 32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"DSI: Invalid data_mode %d\\n\", data_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DSI_LP_DT_LPPS_YCBCR422_20B:\n\tcase DSI_LP_DT_PPS_YCBCR422_24B:\n\t\tdata_type_param.size_constraint_pixels = 2;\n\t\tdata_type_param.size_constraint_bytes = 6;\n\t\tswitch (data_mode) {\n\t\t\t \n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tdata_type_param.pixels_per_pclk = 1;\n\t\t\tdata_type_param.bits_per_pclk = 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"DSI: Invalid data_mode %d\\n\", data_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DSI_LP_DT_PPS_RGB565_16B:\n\t\tdata_type_param.size_constraint_pixels = 1;\n\t\tdata_type_param.size_constraint_bytes = 2;\n\t\tswitch (data_mode) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tdata_type_param.pixels_per_pclk = 1;\n\t\t\tdata_type_param.bits_per_pclk = 16;\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tdata_type_param.pixels_per_pclk = 2;\n\t\t\tdata_type_param.bits_per_pclk = 32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"DSI: Invalid data_mode %d\\n\", data_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DSI_LP_DT_PPS_RGB666_18B:\n\t\tdata_type_param.size_constraint_pixels = 4;\n\t\tdata_type_param.size_constraint_bytes = 9;\n\t\tdata_type_param.bits_per_pclk = 18;\n\t\tdata_type_param.pixels_per_pclk = 1;\n\t\tbreak;\n\tcase DSI_LP_DT_LPPS_RGB666_18B:\n\tcase DSI_LP_DT_PPS_RGB888_24B:\n\t\tdata_type_param.size_constraint_pixels = 1;\n\t\tdata_type_param.size_constraint_bytes = 3;\n\t\tdata_type_param.bits_per_pclk = 24;\n\t\tdata_type_param.pixels_per_pclk = 1;\n\t\tbreak;\n\tcase DSI_LP_DT_PPS_RGB101010_30B:\n\t\tdata_type_param.size_constraint_pixels = 4;\n\t\tdata_type_param.size_constraint_bytes = 15;\n\t\tdata_type_param.bits_per_pclk = 30;\n\t\tdata_type_param.pixels_per_pclk = 1;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"DSI: Invalid data_type %d\\n\", data_type);\n\t\treturn -EINVAL;\n\t}\n\n\t*params = data_type_param;\n\treturn 0;\n}\n\nstatic u32 compute_wc(u32 width_px, u8 size_constr_p, u8 size_constr_b)\n{\n\t \n\treturn (((width_px / size_constr_p) * size_constr_b) & 0xffff);\n}\n\nstatic u32 compute_unpacked_bytes(u32 wc, u8 bits_per_pclk)\n{\n\t \n\treturn ((wc * 8) / bits_per_pclk) * 4;\n}\n\nstatic u32 mipi_tx_fg_section_cfg_regs(struct kmb_dsi *kmb_dsi,\n\t\t\t\t       u8 frame_id, u8 section,\n\t\t\t\t       u32 height_lines, u32 unpacked_bytes,\n\t\t\t\t       struct mipi_tx_frame_sect_phcfg *ph_cfg)\n{\n\tu32 cfg = 0;\n\tu32 ctrl_no = MIPI_CTRL6;\n\tu32 reg_adr;\n\n\t \n\t \n\tcfg = (ph_cfg->wc & MIPI_TX_SECT_WC_MASK) << 0;\n\n\t \n\tcfg |= ((ph_cfg->data_type & MIPI_TX_SECT_DT_MASK)\n\t\t<< MIPI_TX_SECT_DT_SHIFT);\n\n\t \n\tcfg |= ((ph_cfg->vchannel & MIPI_TX_SECT_VC_MASK)\n\t\t<< MIPI_TX_SECT_VC_SHIFT);\n\n\t \n\tcfg |= ((ph_cfg->data_mode & MIPI_TX_SECT_DM_MASK)\n\t\t<< MIPI_TX_SECT_DM_SHIFT);\n\tif (ph_cfg->dma_packed)\n\t\tcfg |= MIPI_TX_SECT_DMA_PACKED;\n\n\tdev_dbg(kmb_dsi->dev,\n\t\t\"ctrl=%d frame_id=%d section=%d cfg=%x packed=%d\\n\",\n\t\t  ctrl_no, frame_id, section, cfg, ph_cfg->dma_packed);\n\tkmb_write_mipi(kmb_dsi,\n\t\t       (MIPI_TXm_HS_FGn_SECTo_PH(ctrl_no, frame_id, section)),\n\t\t       cfg);\n\n\t \n\n\t \n\treg_adr =\n\t    MIPI_TXm_HS_FGn_SECT_UNPACKED_BYTES0(ctrl_no,\n\t\t\t\t\t\t frame_id) + (section / 2) * 4;\n\tkmb_write_bits_mipi(kmb_dsi, reg_adr, (section % 2) * 16, 16,\n\t\t\t    unpacked_bytes);\n\tdev_dbg(kmb_dsi->dev,\n\t\t\"unpacked_bytes = %d, wordcount = %d\\n\", unpacked_bytes,\n\t\t  ph_cfg->wc);\n\n\t \n\treg_adr = MIPI_TXm_HS_FGn_SECTo_LINE_CFG(ctrl_no, frame_id, section);\n\tkmb_write_mipi(kmb_dsi, reg_adr, height_lines);\n\treturn 0;\n}\n\nstatic u32 mipi_tx_fg_section_cfg(struct kmb_dsi *kmb_dsi,\n\t\t\t\t  u8 frame_id, u8 section,\n\t\t\t\t  struct mipi_tx_frame_section_cfg *frame_scfg,\n\t\t\t\t  u32 *bits_per_pclk, u32 *wc)\n{\n\tu32 ret = 0;\n\tu32 unpacked_bytes;\n\tstruct mipi_data_type_params data_type_parameters;\n\tstruct mipi_tx_frame_sect_phcfg ph_cfg;\n\n\tret = mipi_get_datatype_params(frame_scfg->data_type,\n\t\t\t\t       frame_scfg->data_mode,\n\t\t\t\t       &data_type_parameters);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (frame_scfg->width_pixels %\n\t    data_type_parameters.size_constraint_pixels != 0)\n\t\treturn -EINVAL;\n\n\t*wc = compute_wc(frame_scfg->width_pixels,\n\t\t\t data_type_parameters.size_constraint_pixels,\n\t\t\t data_type_parameters.size_constraint_bytes);\n\tunpacked_bytes = compute_unpacked_bytes(*wc,\n\t\t\t\t\t\tdata_type_parameters.bits_per_pclk);\n\tph_cfg.wc = *wc;\n\tph_cfg.data_mode = frame_scfg->data_mode;\n\tph_cfg.data_type = frame_scfg->data_type;\n\tph_cfg.dma_packed = frame_scfg->dma_packed;\n\tph_cfg.vchannel = frame_id;\n\n\tmipi_tx_fg_section_cfg_regs(kmb_dsi, frame_id, section,\n\t\t\t\t    frame_scfg->height_lines,\n\t\t\t\t    unpacked_bytes, &ph_cfg);\n\n\t \n\t*bits_per_pclk = data_type_parameters.bits_per_pclk;\n\n\treturn 0;\n}\n\n#define CLK_DIFF_LOW 50\n#define CLK_DIFF_HI 60\n#define SYSCLK_500  500\n\nstatic void mipi_tx_fg_cfg_regs(struct kmb_dsi *kmb_dsi, u8 frame_gen,\n\t\t\t\tstruct mipi_tx_frame_timing_cfg *fg_cfg)\n{\n\tu32 sysclk;\n\tu32 ppl_llp_ratio;\n\tu32 ctrl_no = MIPI_CTRL6, reg_adr, val, offset;\n\n\t \n\tif (kmb_dsi->sys_clk_mhz == SYSCLK_500) {\n\t\tsysclk = kmb_dsi->sys_clk_mhz - CLK_DIFF_LOW;\n\t} else {\n\t\t \n\t\tsysclk = kmb_dsi->sys_clk_mhz - CLK_DIFF_HI;\n\t}\n\n\t \n\n\t \n\tppl_llp_ratio = ((fg_cfg->bpp / 8) * sysclk * 1000) /\n\t    ((fg_cfg->lane_rate_mbps / 8) * fg_cfg->active_lanes);\n\n\tdev_dbg(kmb_dsi->dev, \"ppl_llp_ratio=%d\\n\", ppl_llp_ratio);\n\tdev_dbg(kmb_dsi->dev, \"bpp=%d sysclk=%d lane-rate=%d active-lanes=%d\\n\",\n\t\tfg_cfg->bpp, sysclk, fg_cfg->lane_rate_mbps,\n\t\t fg_cfg->active_lanes);\n\n\t \n\treg_adr = MIPI_TXm_HS_FGn_NUM_LINES(ctrl_no, frame_gen);\n\tkmb_write_mipi(kmb_dsi, reg_adr, fg_cfg->v_active);\n\n\t \n\toffset = (frame_gen % 2) * 16;\n\treg_adr = MIPI_TXm_HS_VSYNC_WIDTHn(ctrl_no, frame_gen / 2);\n\tkmb_write_bits_mipi(kmb_dsi, reg_adr, offset, 16, fg_cfg->vsync_width);\n\n\t \n\treg_adr = MIPI_TXm_HS_V_BACKPORCHESn(ctrl_no, frame_gen / 2);\n\tkmb_write_bits_mipi(kmb_dsi, reg_adr, offset, 16, fg_cfg->v_backporch);\n\n\t \n\treg_adr = MIPI_TXm_HS_V_FRONTPORCHESn(ctrl_no, frame_gen / 2);\n\tkmb_write_bits_mipi(kmb_dsi, reg_adr, offset, 16, fg_cfg->v_frontporch);\n\n\t \n\treg_adr = MIPI_TXm_HS_V_ACTIVEn(ctrl_no, frame_gen / 2);\n\tkmb_write_bits_mipi(kmb_dsi, reg_adr, offset, 16, fg_cfg->v_active);\n\n\t \n\treg_adr = MIPI_TXm_HS_HSYNC_WIDTHn(ctrl_no, frame_gen);\n\tkmb_write_mipi(kmb_dsi, reg_adr,\n\t\t       (fg_cfg->hsync_width * ppl_llp_ratio) / 1000);\n\n\t \n\treg_adr = MIPI_TXm_HS_H_BACKPORCHn(ctrl_no, frame_gen);\n\tkmb_write_mipi(kmb_dsi, reg_adr,\n\t\t       (fg_cfg->h_backporch * ppl_llp_ratio) / 1000);\n\n\t \n\treg_adr = MIPI_TXm_HS_H_FRONTPORCHn(ctrl_no, frame_gen);\n\tkmb_write_mipi(kmb_dsi, reg_adr,\n\t\t       (fg_cfg->h_frontporch * ppl_llp_ratio) / 1000);\n\n\t \n\treg_adr = MIPI_TXm_HS_H_ACTIVEn(ctrl_no, frame_gen);\n\n\t \n\tval = (fg_cfg->h_active * sysclk * 1000) /\n\t    ((fg_cfg->lane_rate_mbps / 8) * fg_cfg->active_lanes);\n\tval /= 1000;\n\tkmb_write_mipi(kmb_dsi, reg_adr, val);\n\n\t \n\treg_adr = MIPI_TXm_HS_LLP_HSYNC_WIDTHn(ctrl_no, frame_gen);\n\tkmb_write_mipi(kmb_dsi, reg_adr, fg_cfg->hsync_width * (fg_cfg->bpp / 8));\n\n\t \n\treg_adr = MIPI_TXm_HS_LLP_H_BACKPORCHn(ctrl_no, frame_gen);\n\tkmb_write_mipi(kmb_dsi, reg_adr, fg_cfg->h_backporch * (fg_cfg->bpp / 8));\n\n\t \n\treg_adr = MIPI_TXm_HS_LLP_H_FRONTPORCHn(ctrl_no, frame_gen);\n\tkmb_write_mipi(kmb_dsi, reg_adr,\n\t\t       fg_cfg->h_frontporch * (fg_cfg->bpp / 8));\n}\n\nstatic void mipi_tx_fg_cfg(struct kmb_dsi *kmb_dsi, u8 frame_gen,\n\t\t\t   u8 active_lanes, u32 bpp, u32 wc,\n\t\t\t   u32 lane_rate_mbps, struct mipi_tx_frame_cfg *fg_cfg)\n{\n\tu32 i, fg_num_lines = 0;\n\tstruct mipi_tx_frame_timing_cfg fg_t_cfg;\n\n\t \n\tfor (i = 0; i < MIPI_TX_FRAME_GEN_SECTIONS; i++) {\n\t\tif (fg_cfg->sections[i])\n\t\t\tfg_num_lines += fg_cfg->sections[i]->height_lines;\n\t}\n\n\tfg_t_cfg.bpp = bpp;\n\tfg_t_cfg.lane_rate_mbps = lane_rate_mbps;\n\tfg_t_cfg.hsync_width = fg_cfg->hsync_width;\n\tfg_t_cfg.h_backporch = fg_cfg->h_backporch;\n\tfg_t_cfg.h_frontporch = fg_cfg->h_frontporch;\n\tfg_t_cfg.h_active = wc;\n\tfg_t_cfg.vsync_width = fg_cfg->vsync_width;\n\tfg_t_cfg.v_backporch = fg_cfg->v_backporch;\n\tfg_t_cfg.v_frontporch = fg_cfg->v_frontporch;\n\tfg_t_cfg.v_active = fg_num_lines;\n\tfg_t_cfg.active_lanes = active_lanes;\n\n\t \n\tmipi_tx_fg_cfg_regs(kmb_dsi, frame_gen, &fg_t_cfg);\n}\n\nstatic void mipi_tx_multichannel_fifo_cfg(struct kmb_dsi *kmb_dsi,\n\t\t\t\t\t  u8 active_lanes, u8 vchannel_id)\n{\n\tu32 fifo_size, fifo_rthreshold;\n\tu32 ctrl_no = MIPI_CTRL6;\n\n\t \n\tkmb_write_mipi(kmb_dsi, MIPI_TX_HS_MC_FIFO_CTRL_EN, 0);\n\tkmb_write_mipi(kmb_dsi, MIPI_TX_HS_MC_FIFO_CHAN_ALLOC0, 0);\n\tkmb_write_mipi(kmb_dsi, MIPI_TX_HS_MC_FIFO_CHAN_ALLOC1, 0);\n\tkmb_write_mipi(kmb_dsi, MIPI_TX_HS_MC_FIFO_RTHRESHOLD0, 0);\n\tkmb_write_mipi(kmb_dsi, MIPI_TX_HS_MC_FIFO_RTHRESHOLD1, 0);\n\n\tfifo_size = ((active_lanes > MIPI_D_LANES_PER_DPHY) ?\n\t\t     MIPI_CTRL_4LANE_MAX_MC_FIFO_LOC :\n\t\t     MIPI_CTRL_2LANE_MAX_MC_FIFO_LOC) - 1;\n\n\t \n\tSET_MC_FIFO_CHAN_ALLOC(kmb_dsi, ctrl_no, vchannel_id, fifo_size);\n\n\t \n\tfifo_rthreshold = ((fifo_size) * 8) & BIT_MASK_16;\n\tSET_MC_FIFO_RTHRESHOLD(kmb_dsi, ctrl_no, vchannel_id, fifo_rthreshold);\n\n\t \n\tkmb_set_bit_mipi(kmb_dsi, MIPI_TXm_HS_MC_FIFO_CTRL_EN(ctrl_no),\n\t\t\t vchannel_id);\n}\n\nstatic void mipi_tx_ctrl_cfg(struct kmb_dsi *kmb_dsi, u8 fg_id,\n\t\t\t     struct mipi_ctrl_cfg *ctrl_cfg)\n{\n\tu32 sync_cfg = 0, ctrl = 0, fg_en;\n\tu32 ctrl_no = MIPI_CTRL6;\n\n\t \n\tif (ctrl_cfg->tx_ctrl_cfg.line_sync_pkt_en)\n\t\tsync_cfg |= LINE_SYNC_PKT_ENABLE;\n\tif (ctrl_cfg->tx_ctrl_cfg.frame_counter_active)\n\t\tsync_cfg |= FRAME_COUNTER_ACTIVE;\n\tif (ctrl_cfg->tx_ctrl_cfg.line_counter_active)\n\t\tsync_cfg |= LINE_COUNTER_ACTIVE;\n\tif (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->v_blanking)\n\t\tsync_cfg |= DSI_V_BLANKING;\n\tif (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->hsa_blanking)\n\t\tsync_cfg |= DSI_HSA_BLANKING;\n\tif (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->hbp_blanking)\n\t\tsync_cfg |= DSI_HBP_BLANKING;\n\tif (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->hfp_blanking)\n\t\tsync_cfg |= DSI_HFP_BLANKING;\n\tif (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->sync_pulse_eventn)\n\t\tsync_cfg |= DSI_SYNC_PULSE_EVENTN;\n\tif (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->lpm_first_vsa_line)\n\t\tsync_cfg |= DSI_LPM_FIRST_VSA_LINE;\n\tif (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->lpm_last_vfp_line)\n\t\tsync_cfg |= DSI_LPM_LAST_VFP_LINE;\n\n\t \n\tfg_en = 1 << fg_id;\n\tsync_cfg |= FRAME_GEN_EN(fg_en);\n\n\tif (ctrl_cfg->tx_ctrl_cfg.tx_always_use_hact)\n\t\tsync_cfg |= ALWAYS_USE_HACT(fg_en);\n\tif (ctrl_cfg->tx_ctrl_cfg.tx_hact_wait_stop)\n\t\tsync_cfg |= HACT_WAIT_STOP(fg_en);\n\n\tdev_dbg(kmb_dsi->dev, \"sync_cfg=%d fg_en=%d\\n\", sync_cfg, fg_en);\n\n\t \n\n\t \n\tctrl = HS_CTRL_EN | TX_SOURCE;\n\tctrl |= LCD_VC(fg_id);\n\tctrl |= ACTIVE_LANES(ctrl_cfg->active_lanes - 1);\n\tif (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->eotp_en)\n\t\tctrl |= DSI_EOTP_EN;\n\tif (ctrl_cfg->tx_ctrl_cfg.tx_dsi_cfg->hfp_blank_en)\n\t\tctrl |= DSI_CMD_HFP_EN;\n\n\t \n\tctrl |= HSEXIT_CNT(0x43);\n\n\tkmb_write_mipi(kmb_dsi, MIPI_TXm_HS_SYNC_CFG(ctrl_no), sync_cfg);\n\tkmb_write_mipi(kmb_dsi, MIPI_TXm_HS_CTRL(ctrl_no), ctrl);\n}\n\nstatic u32 mipi_tx_init_cntrl(struct kmb_dsi *kmb_dsi,\n\t\t\t      struct mipi_ctrl_cfg *ctrl_cfg)\n{\n\tu32 ret = 0;\n\tu8 active_vchannels = 0;\n\tu8 frame_id, sect;\n\tu32 bits_per_pclk = 0;\n\tu32 word_count = 0;\n\tstruct mipi_tx_frame_cfg *frame;\n\n\t \n\n\tfor (frame_id = 0; frame_id < 4; frame_id++) {\n\t\tframe = ctrl_cfg->tx_ctrl_cfg.frames[frame_id];\n\n\t\t \n\t\tif (!frame)\n\t\t\tcontinue;\n\n\t\t \n\t\t \n\t\tfor (sect = 0; sect < MIPI_CTRL_VIRTUAL_CHANNELS; sect++) {\n\t\t\tif (!frame->sections[sect])\n\t\t\t\tcontinue;\n\n\t\t\tret = mipi_tx_fg_section_cfg(kmb_dsi, frame_id, sect,\n\t\t\t\t\t\t     frame->sections[sect],\n\t\t\t\t\t\t     &bits_per_pclk,\n\t\t\t\t\t\t     &word_count);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tmipi_tx_fg_cfg(kmb_dsi, frame_id, ctrl_cfg->active_lanes,\n\t\t\t       bits_per_pclk, word_count,\n\t\t\t       ctrl_cfg->lane_rate_mbps, frame);\n\n\t\tactive_vchannels++;\n\n\t\t \n\t\tbreak;\n\t}\n\n\tif (active_vchannels == 0)\n\t\treturn -EINVAL;\n\t \n\tmipi_tx_multichannel_fifo_cfg(kmb_dsi, ctrl_cfg->active_lanes, frame_id);\n\n\t \n\tmipi_tx_ctrl_cfg(kmb_dsi, frame_id, ctrl_cfg);\n\n\treturn ret;\n}\n\nstatic void test_mode_send(struct kmb_dsi *kmb_dsi, u32 dphy_no,\n\t\t\t   u32 test_code, u32 test_data)\n{\n\t \n\n\t \n\tSET_DPHY_TEST_CTRL1_CLK(kmb_dsi, dphy_no);\n\n\t \n\tSET_TEST_DIN0_3(kmb_dsi, dphy_no, test_code);\n\n\t \n\tSET_DPHY_TEST_CTRL1_EN(kmb_dsi, dphy_no);\n\n\t \n\tCLR_DPHY_TEST_CTRL1_CLK(kmb_dsi, dphy_no);\n\n\t \n\tCLR_DPHY_TEST_CTRL1_EN(kmb_dsi, dphy_no);\n\n\tif (test_code) {\n\t\t \n\n\t\t \n\t\tCLR_DPHY_TEST_CTRL1_EN(kmb_dsi, dphy_no);\n\n\t\t \n\t\tCLR_DPHY_TEST_CTRL1_CLK(kmb_dsi, dphy_no);\n\n\t\t \n\t\tkmb_write_mipi(kmb_dsi,\n\t\t\t       DPHY_TEST_DIN0_3 + ((dphy_no / 0x4) * 0x4),\n\t\t\t       test_data << ((dphy_no % 4) * 8));\n\n\t\t \n\t\tSET_DPHY_TEST_CTRL1_CLK(kmb_dsi, dphy_no);\n\t}\n}\n\nstatic inline void\n\tset_test_mode_src_osc_freq_target_low_bits(struct kmb_dsi *kmb_dsi,\n\t\t\t\t\t\t   u32 dphy_no,\n\t\t\t\t\t\t   u32 freq)\n{\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_SLEW_RATE_DDL_CYCLES,\n\t\t       (freq & 0x7f));\n}\n\nstatic inline void\n\tset_test_mode_src_osc_freq_target_hi_bits(struct kmb_dsi *kmb_dsi,\n\t\t\t\t\t\t  u32 dphy_no,\n\t\t\t\t\t\t  u32 freq)\n{\n\tu32 data;\n\n\t \n\tdata = ((freq >> 6) & 0x1f) | (1 << 7);\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_SLEW_RATE_DDL_CYCLES, data);\n}\n\nstatic void mipi_tx_get_vco_params(struct vco_params *vco)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vco_table); i++) {\n\t\tif (vco->freq < vco_table[i].freq) {\n\t\t\t*vco = vco_table[i];\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN_ONCE(1, \"Invalid vco freq = %u for PLL setup\\n\", vco->freq);\n}\n\nstatic void mipi_tx_pll_setup(struct kmb_dsi *kmb_dsi, u32 dphy_no,\n\t\t\t      u32 ref_clk_mhz, u32 target_freq_mhz)\n{\n\tu32 best_n = 0, best_m = 0;\n\tu32 n = 0, m = 0, div = 0, delta, freq = 0, t_freq;\n\tu32 best_freq_delta = 3000;\n\n\t \n\tstruct vco_params vco_p = {\n\t\t.range = 0,\n\t\t.divider = 1,\n\t};\n\n\tvco_p.freq = target_freq_mhz;\n\tmipi_tx_get_vco_params(&vco_p);\n\n\t \n\tfor (n = PLL_N_MIN; n <= PLL_N_MAX; n++) {\n\t\t \n\t\tdiv = ((ref_clk_mhz * 1000) + n) / (n + 1);\n\n\t\t \n\t\tif ((div < 2000 || div > 8000))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (m = PLL_M_MIN; m <= PLL_M_MAX; m++) {\n\t\t\t \n\t\t\tfreq = div * (m + 2);\n\t\t\tfreq /= 1000;\n\n\t\t\t \n\t\t\tif (freq > PLL_FVCO_MAX)\n\t\t\t\tcontinue;\n\n\t\t\tdelta = abs(freq - target_freq_mhz);\n\n\t\t\t \n\t\t\tif (delta < best_freq_delta) {\n\t\t\t\tbest_n = n;\n\t\t\t\tbest_m = m;\n\t\t\t\tbest_freq_delta = delta;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_VCO_CTRL, (vco_p.range\n\t\t\t\t\t\t\t\t| (1 << 6)));\n\n\t \n\tdev_dbg(kmb_dsi->dev, \"m = %d n = %d\\n\", best_m, best_n);\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_INPUT_DIVIDER,\n\t\t       (best_n & 0x0f));\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_FEEDBACK_DIVIDER,\n\t\t       (best_m & 0x1f));\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_FEEDBACK_DIVIDER,\n\t\t       ((best_m >> 5) & 0x1f) | PLL_FEEDBACK_DIVIDER_HIGH);\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_OUTPUT_CLK_SEL,\n\t\t       (PLL_N_OVR_EN | PLL_M_OVR_EN));\n\n\t \n\n\t \n\tt_freq = target_freq_mhz * vco_p.divider;\n\ttest_mode_send(kmb_dsi, dphy_no,\n\t\t       TEST_CODE_PLL_PROPORTIONAL_CHARGE_PUMP_CTRL,\n\t\t       ((t_freq > 1150) ? 0x0C : 0x0B));\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_INTEGRAL_CHARGE_PUMP_CTRL,\n\t\t       0x00);\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_GMP_CTRL, 0x10);\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_CHARGE_PUMP_BIAS, 0x10);\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_PHASE_ERR_CTRL, 0x02);\n\n\t \n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_LOCK_FILTER, 0x60);\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_UNLOCK_FILTER, 0x03);\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_PLL_LOCK_DETECTOR, 0x02);\n}\n\nstatic void set_slewrate_gt_1500(struct kmb_dsi *kmb_dsi, u32 dphy_no)\n{\n\tu32 test_code = 0, test_data = 0;\n\t \n\ttest_code = TEST_CODE_SLEW_RATE_OVERRIDE_CTRL;\n\ttest_data = 0x02;\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n\n\t \n\ttest_code = TEST_CODE_SLEW_RATE_DDL_LOOP_CTRL;\n\ttest_data = 0x00;\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n}\n\nstatic void set_slewrate_gt_1000(struct kmb_dsi *kmb_dsi, u32 dphy_no)\n{\n\tu32 test_code = 0, test_data = 0;\n\n\t \n\n\t \n\ttest_code = TEST_CODE_SLEW_RATE_OVERRIDE_CTRL;\n\ttest_data = (0x03 | (1 << 6));\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n\n\t \n\ttest_code = TEST_CODE_SLEW_RATE_DDL_LOOP_CTRL;\n\ttest_data = 0x01;\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n\n\t \n\ttest_code = TEST_CODE_SLEW_RATE_DDL_CYCLES;\n\ttest_data = (0x72f & 0x7f);\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n\n\t \n\ttest_code = TEST_CODE_SLEW_RATE_DDL_CYCLES;\n\ttest_data = ((0x72f >> 6) & 0x1f) | (1 << 7);\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n}\n\nstatic void set_slewrate_lt_1000(struct kmb_dsi *kmb_dsi, u32 dphy_no)\n{\n\tu32 test_code = 0, test_data = 0;\n\n\t \n\n\t \n\ttest_code = TEST_CODE_SLEW_RATE_OVERRIDE_CTRL;\n\ttest_data = (0x03 | (1 << 6));\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n\n\t \n\ttest_code = TEST_CODE_SLEW_RATE_DDL_LOOP_CTRL;\n\ttest_data = 0x01;\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n\n\t \n\ttest_code = TEST_CODE_SLEW_RATE_DDL_CYCLES;\n\ttest_data = (0x523 & 0x7f);\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n\n\t \n\ttest_code = TEST_CODE_SLEW_RATE_DDL_CYCLES;\n\ttest_data = ((0x523 >> 6) & 0x1f) | (1 << 7);\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n}\n\nstatic void setup_pll(struct kmb_dsi *kmb_dsi, u32 dphy_no,\n\t\t      struct mipi_ctrl_cfg *cfg)\n{\n\tu32 test_code = 0, test_data = 0;\n\n\t \n\ttest_code = TEST_CODE_PLL_ANALOG_PROG;\n\ttest_data = 0x01;\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n\n\t \n\tmipi_tx_pll_setup(kmb_dsi, dphy_no, cfg->ref_clk_khz / 1000,\n\t\t\t  cfg->lane_rate_mbps / 2);\n\n\t \n\tkmb_write_bits_mipi(kmb_dsi, DPHY_INIT_CTRL1, PLL_CLKSEL_0, 2, 0x01);\n\n\t \n\tkmb_set_bit_mipi(kmb_dsi, DPHY_INIT_CTRL1, PLL_SHADOW_CTRL);\n}\n\nstatic void set_lane_data_rate(struct kmb_dsi *kmb_dsi, u32 dphy_no,\n\t\t\t       struct mipi_ctrl_cfg *cfg)\n{\n\tu32 i, test_code = 0, test_data = 0;\n\n\tfor (i = 0; i < MIPI_DPHY_DEFAULT_BIT_RATES; i++) {\n\t\tif (mipi_hs_freq_range[i].default_bit_rate_mbps <\n\t\t    cfg->lane_rate_mbps)\n\t\t\tcontinue;\n\n\t\t \n\t\t \n\t\ttest_code = TEST_CODE_HS_FREQ_RANGE_CFG;\n\t\ttest_data = (mipi_hs_freq_range[i].hsfreqrange_code & 0x7f) |\n\t\t    (1 << 7);\n\t\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n\t\tbreak;\n\t}\n}\n\nstatic void dphy_init_sequence(struct kmb_dsi *kmb_dsi,\n\t\t\t       struct mipi_ctrl_cfg *cfg, u32 dphy_no,\n\t\t\t       int active_lanes, enum dphy_mode mode)\n{\n\tu32 test_code = 0, test_data = 0, val;\n\n\t \n\t \n\tCLR_DPHY_INIT_CTRL0(kmb_dsi, dphy_no, RESETZ);\n\n\t \n\tCLR_DPHY_INIT_CTRL0(kmb_dsi, dphy_no, SHUTDOWNZ);\n\tval = kmb_read_mipi(kmb_dsi, DPHY_INIT_CTRL0);\n\n\t \n\tCLR_DPHY_TEST_CTRL0(kmb_dsi, dphy_no);\n\tndelay(15);\n\tSET_DPHY_TEST_CTRL0(kmb_dsi, dphy_no);\n\tndelay(15);\n\tCLR_DPHY_TEST_CTRL0(kmb_dsi, dphy_no);\n\tndelay(15);\n\n\t \n\ttest_code = TEST_CODE_MULTIPLE_PHY_CTRL;\n\n\t \n\tif (mode == MIPI_DPHY_MASTER)\n\t\ttest_data = 0x01;\n\telse\n\t\ttest_data = 0x00;\n\n\t \n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n\n\t \n\tset_lane_data_rate(kmb_dsi, dphy_no, cfg);\n\n\t \n\tif (cfg->lane_rate_mbps > 1500)\n\t\tset_slewrate_gt_1500(kmb_dsi, dphy_no);\n\telse if (cfg->lane_rate_mbps > 1000)\n\t\tset_slewrate_gt_1000(kmb_dsi, dphy_no);\n\telse\n\t\tset_slewrate_lt_1000(kmb_dsi, dphy_no);\n\n\t \n\tval = (((cfg->cfg_clk_khz / 1000) - 17) * 4) & 0x3f;\n\tSET_DPHY_FREQ_CTRL0_3(kmb_dsi, dphy_no, val);\n\n\t \n\tkmb_set_bit_mipi(kmb_dsi, DPHY_CFG_CLK_EN, dphy_no);\n\n\t \n\tif (mode == MIPI_DPHY_MASTER)\n\t\tsetup_pll(kmb_dsi, dphy_no, cfg);\n\n\t \n\ttest_code = 0x0;\n\ttest_data = 0x0;\n\ttest_mode_send(kmb_dsi, dphy_no, test_code, test_data);\n\n\t \n\tkmb_write_bits_mipi(kmb_dsi, DPHY_INIT_CTRL2, 0, 9, 0x03f);\n\tndelay(15);\n\n\t \n\tkmb_set_bit_mipi(kmb_dsi, DPHY_INIT_CTRL2, 12 + dphy_no);\n\n\t \n\tkmb_write_bits_mipi(kmb_dsi, DPHY_ENABLE, dphy_no * 2, 2,\n\t\t\t    ((1 << active_lanes) - 1));\n\n\tndelay(15);\n\n\t \n\t \n\tSET_DPHY_INIT_CTRL0(kmb_dsi, dphy_no, SHUTDOWNZ);\n\tndelay(15);\n\n\t \n\tSET_DPHY_INIT_CTRL0(kmb_dsi, dphy_no, RESETZ);\n}\n\nstatic void dphy_wait_fsm(struct kmb_dsi *kmb_dsi, u32 dphy_no,\n\t\t\t  enum dphy_tx_fsm fsm_state)\n{\n\tenum dphy_tx_fsm val = DPHY_TX_POWERDWN;\n\tint i = 0;\n\tint status = 1;\n\n\tdo {\n\t\ttest_mode_send(kmb_dsi, dphy_no, TEST_CODE_FSM_CONTROL, 0x80);\n\n\t\tval = GET_TEST_DOUT4_7(kmb_dsi, dphy_no);\n\t\ti++;\n\t\tif (i > TIMEOUT) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (val != fsm_state);\n\n\tdev_dbg(kmb_dsi->dev, \"%s: dphy %d val = %x\", __func__, dphy_no, val);\n\tdev_dbg(kmb_dsi->dev, \"* DPHY %d WAIT_FSM %s *\",\n\t\tdphy_no, status ? \"SUCCESS\" : \"FAILED\");\n}\n\nstatic void wait_init_done(struct kmb_dsi *kmb_dsi, u32 dphy_no,\n\t\t\t   u32 active_lanes)\n{\n\tu32 stopstatedata = 0;\n\tu32 data_lanes = (1 << active_lanes) - 1;\n\tint i = 0;\n\tint status = 1;\n\n\tdo {\n\t\tstopstatedata = GET_STOPSTATE_DATA(kmb_dsi, dphy_no)\n\t\t\t\t& data_lanes;\n\n\t\t \n\t\ti++;\n\n\t\tif (i > TIMEOUT) {\n\t\t\tstatus = 0;\n\t\t\tdev_dbg(kmb_dsi->dev,\n\t\t\t\t\"! WAIT_INIT_DONE: TIMING OUT!(err_stat=%d)\",\n\t\t\t\tkmb_read_mipi(kmb_dsi, MIPI_DPHY_ERR_STAT6_7));\n\t\t\tbreak;\n\t\t}\n\t} while (stopstatedata != data_lanes);\n\n\tdev_dbg(kmb_dsi->dev, \"* DPHY %d INIT - %s *\",\n\t\tdphy_no, status ? \"SUCCESS\" : \"FAILED\");\n}\n\nstatic void wait_pll_lock(struct kmb_dsi *kmb_dsi, u32 dphy_no)\n{\n\tint i = 0;\n\tint status = 1;\n\n\tdo {\n\t\t \n\t\ti++;\n\t\tif (i > TIMEOUT) {\n\t\t\tstatus = 0;\n\t\t\tdev_dbg(kmb_dsi->dev, \"%s: timing out\", __func__);\n\t\t\tbreak;\n\t\t}\n\t} while (!GET_PLL_LOCK(kmb_dsi, dphy_no));\n\n\tdev_dbg(kmb_dsi->dev, \"* PLL Locked for DPHY %d - %s *\",\n\t\tdphy_no, status ? \"SUCCESS\" : \"FAILED\");\n}\n\nstatic u32 mipi_tx_init_dphy(struct kmb_dsi *kmb_dsi,\n\t\t\t     struct mipi_ctrl_cfg *cfg)\n{\n\tu32 dphy_no = MIPI_DPHY6;\n\n\t \n\tif (cfg->active_lanes > MIPI_DPHY_D_LANES) {\n\t\t \n\t\t \n\n\t\tdphy_init_sequence(kmb_dsi, cfg, dphy_no + 1,\n\t\t\t\t   (cfg->active_lanes - MIPI_DPHY_D_LANES),\n\t\t\t\t   MIPI_DPHY_SLAVE);\n\t\tdphy_wait_fsm(kmb_dsi, dphy_no + 1, DPHY_TX_LOCK);\n\n\t\t \n\t\tdphy_init_sequence(kmb_dsi, cfg, dphy_no, MIPI_DPHY_D_LANES,\n\t\t\t\t   MIPI_DPHY_MASTER);\n\n\t\t \n\t\twait_init_done(kmb_dsi, dphy_no, MIPI_DPHY_D_LANES);\n\t\twait_init_done(kmb_dsi, dphy_no + 1,\n\t\t\t       cfg->active_lanes - MIPI_DPHY_D_LANES);\n\t\twait_pll_lock(kmb_dsi, dphy_no);\n\t\twait_pll_lock(kmb_dsi, dphy_no + 1);\n\t\tdphy_wait_fsm(kmb_dsi, dphy_no, DPHY_TX_IDLE);\n\t} else {\t\t \n\t\tdphy_init_sequence(kmb_dsi, cfg, dphy_no, cfg->active_lanes,\n\t\t\t\t   MIPI_DPHY_MASTER);\n\t\tdphy_wait_fsm(kmb_dsi, dphy_no, DPHY_TX_IDLE);\n\t\twait_init_done(kmb_dsi, dphy_no, cfg->active_lanes);\n\t\twait_pll_lock(kmb_dsi, dphy_no);\n\t}\n\n\treturn 0;\n}\n\nstatic void connect_lcd_to_mipi(struct kmb_dsi *kmb_dsi,\n\t\t\t\tstruct drm_atomic_state *old_state)\n{\n\tstruct regmap *msscam;\n\n\tmsscam = syscon_regmap_lookup_by_compatible(\"intel,keembay-msscam\");\n\tif (IS_ERR(msscam)) {\n\t\tdev_dbg(kmb_dsi->dev, \"failed to get msscam syscon\");\n\t\treturn;\n\t}\n\tdrm_atomic_bridge_chain_enable(adv_bridge, old_state);\n\t \n\tregmap_write(msscam, MSS_MIPI_CIF_CFG, 0);\n\n\t \n\tregmap_write(msscam, MSS_LCD_MIPI_CFG, 1);\n\t \n\tregmap_write(msscam, MSS_LOOPBACK_CFG, 1);\n}\n\nint kmb_dsi_mode_set(struct kmb_dsi *kmb_dsi, struct drm_display_mode *mode,\n\t\t     int sys_clk_mhz, struct drm_atomic_state *old_state)\n{\n\tu64 data_rate;\n\n\tkmb_dsi->sys_clk_mhz = sys_clk_mhz;\n\tmipi_tx_init_cfg.active_lanes = MIPI_TX_ACTIVE_LANES;\n\n\tmipi_tx_frame0_sect_cfg.width_pixels = mode->crtc_hdisplay;\n\tmipi_tx_frame0_sect_cfg.height_lines = mode->crtc_vdisplay;\n\tmipitx_frame0_cfg.vsync_width =\n\t\tmode->crtc_vsync_end - mode->crtc_vsync_start;\n\tmipitx_frame0_cfg.v_backporch =\n\t\tmode->crtc_vtotal - mode->crtc_vsync_end;\n\tmipitx_frame0_cfg.v_frontporch =\n\t\tmode->crtc_vsync_start - mode->crtc_vdisplay;\n\tmipitx_frame0_cfg.hsync_width =\n\t\tmode->crtc_hsync_end - mode->crtc_hsync_start;\n\tmipitx_frame0_cfg.h_backporch =\n\t\tmode->crtc_htotal - mode->crtc_hsync_end;\n\tmipitx_frame0_cfg.h_frontporch =\n\t\tmode->crtc_hsync_start - mode->crtc_hdisplay;\n\n\t \n\tdata_rate = ((((u32)mode->crtc_vtotal *\t(u32)mode->crtc_htotal) *\n\t\t\t(u32)(drm_mode_vrefresh(mode)) *\n\t\t\tMIPI_TX_BPP) / mipi_tx_init_cfg.active_lanes) /\t1000000;\n\n\tdev_dbg(kmb_dsi->dev, \"data_rate=%u active_lanes=%d\\n\",\n\t\t(u32)data_rate, mipi_tx_init_cfg.active_lanes);\n\n\t \n\tif (data_rate < 800) {\n\t\tmipi_tx_init_cfg.active_lanes = 2;\n\t\tmipi_tx_init_cfg.lane_rate_mbps = data_rate * 2;\n\t} else {\n\t\tmipi_tx_init_cfg.lane_rate_mbps = data_rate;\n\t}\n\n\t \n\tmipi_tx_init_cntrl(kmb_dsi, &mipi_tx_init_cfg);\n\n\t \n\tmipi_tx_init_dphy(kmb_dsi, &mipi_tx_init_cfg);\n\n\tconnect_lcd_to_mipi(kmb_dsi, old_state);\n\tdev_info(kmb_dsi->dev, \"mipi hw initialized\");\n\n\treturn 0;\n}\n\nstruct kmb_dsi *kmb_dsi_init(struct platform_device *pdev)\n{\n\tstruct kmb_dsi *kmb_dsi;\n\tstruct device *dev = get_device(&pdev->dev);\n\n\tkmb_dsi = devm_kzalloc(dev, sizeof(*kmb_dsi), GFP_KERNEL);\n\tif (!kmb_dsi) {\n\t\tdev_err(dev, \"failed to allocate kmb_dsi\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tkmb_dsi->host = dsi_host;\n\tkmb_dsi->host->ops = &kmb_dsi_host_ops;\n\n\tdsi_device->host = kmb_dsi->host;\n\tkmb_dsi->device = dsi_device;\n\n\treturn kmb_dsi;\n}\n\nint kmb_dsi_encoder_init(struct drm_device *dev, struct kmb_dsi *kmb_dsi)\n{\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tint ret = 0;\n\n\tencoder = &kmb_dsi->base;\n\tencoder->possible_crtcs = 1;\n\tencoder->possible_clones = 0;\n\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_DSI);\n\tif (ret) {\n\t\tdev_err(kmb_dsi->dev, \"Failed to init encoder %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = drm_bridge_attach(encoder, adv_bridge, NULL,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret) {\n\t\tdrm_encoder_cleanup(encoder);\n\t\treturn ret;\n\t}\n\tdrm_info(dev, \"Bridge attached : SUCCESS\");\n\tconnector = drm_bridge_connector_init(dev, encoder);\n\tif (IS_ERR(connector)) {\n\t\tDRM_ERROR(\"Unable to create bridge connector\");\n\t\tdrm_encoder_cleanup(encoder);\n\t\treturn PTR_ERR(connector);\n\t}\n\tdrm_connector_attach_encoder(connector, encoder);\n\treturn 0;\n}\n\nint kmb_dsi_map_mmio(struct kmb_dsi *kmb_dsi)\n{\n\tstruct resource *res;\n\tstruct device *dev = kmb_dsi->dev;\n\n\tres = platform_get_resource_byname(kmb_dsi->pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"mipi\");\n\tif (!res) {\n\t\tdev_err(dev, \"failed to get resource for mipi\");\n\t\treturn -ENOMEM;\n\t}\n\tkmb_dsi->mipi_mmio = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(kmb_dsi->mipi_mmio)) {\n\t\tdev_err(dev, \"failed to ioremap mipi registers\");\n\t\treturn PTR_ERR(kmb_dsi->mipi_mmio);\n\t}\n\treturn 0;\n}\n\nstatic int kmb_dsi_clk_enable(struct kmb_dsi *kmb_dsi)\n{\n\tint ret;\n\tstruct device *dev = kmb_dsi->dev;\n\n\tret = clk_prepare_enable(kmb_dsi->clk_mipi);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable MIPI clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(kmb_dsi->clk_mipi_ecfg);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable MIPI_ECFG clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(kmb_dsi->clk_mipi_cfg);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable MIPI_CFG clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"SUCCESS : enabled MIPI clocks\\n\");\n\treturn 0;\n}\n\nint kmb_dsi_clk_init(struct kmb_dsi *kmb_dsi)\n{\n\tstruct device *dev = kmb_dsi->dev;\n\tunsigned long clk;\n\n\tkmb_dsi->clk_mipi = devm_clk_get(dev, \"clk_mipi\");\n\tif (IS_ERR(kmb_dsi->clk_mipi)) {\n\t\tdev_err(dev, \"devm_clk_get() failed clk_mipi\\n\");\n\t\treturn PTR_ERR(kmb_dsi->clk_mipi);\n\t}\n\n\tkmb_dsi->clk_mipi_ecfg = devm_clk_get(dev, \"clk_mipi_ecfg\");\n\tif (IS_ERR(kmb_dsi->clk_mipi_ecfg)) {\n\t\tdev_err(dev, \"devm_clk_get() failed clk_mipi_ecfg\\n\");\n\t\treturn PTR_ERR(kmb_dsi->clk_mipi_ecfg);\n\t}\n\n\tkmb_dsi->clk_mipi_cfg = devm_clk_get(dev, \"clk_mipi_cfg\");\n\tif (IS_ERR(kmb_dsi->clk_mipi_cfg)) {\n\t\tdev_err(dev, \"devm_clk_get() failed clk_mipi_cfg\\n\");\n\t\treturn PTR_ERR(kmb_dsi->clk_mipi_cfg);\n\t}\n\t \n\tclk_set_rate(kmb_dsi->clk_mipi, KMB_MIPI_DEFAULT_CLK);\n\tif (clk_get_rate(kmb_dsi->clk_mipi) != KMB_MIPI_DEFAULT_CLK) {\n\t\tdev_err(dev, \"failed to set to clk_mipi to %d\\n\",\n\t\t\tKMB_MIPI_DEFAULT_CLK);\n\t\treturn -1;\n\t}\n\tdev_dbg(dev, \"clk_mipi = %ld\\n\", clk_get_rate(kmb_dsi->clk_mipi));\n\n\tclk = clk_get_rate(kmb_dsi->clk_mipi_ecfg);\n\tif (clk != KMB_MIPI_DEFAULT_CFG_CLK) {\n\t\t \n\t\tclk_set_rate(kmb_dsi->clk_mipi_ecfg, KMB_MIPI_DEFAULT_CFG_CLK);\n\t\tclk = clk_get_rate(kmb_dsi->clk_mipi_ecfg);\n\t\tif (clk != KMB_MIPI_DEFAULT_CFG_CLK) {\n\t\t\tdev_err(dev, \"failed to set to clk_mipi_ecfg to %d\\n\",\n\t\t\t\tKMB_MIPI_DEFAULT_CFG_CLK);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tclk = clk_get_rate(kmb_dsi->clk_mipi_cfg);\n\tif (clk != KMB_MIPI_DEFAULT_CFG_CLK) {\n\t\t \n\t\tclk_set_rate(kmb_dsi->clk_mipi_cfg, 24000000);\n\t\tclk = clk_get_rate(kmb_dsi->clk_mipi_cfg);\n\t\tif (clk != KMB_MIPI_DEFAULT_CFG_CLK) {\n\t\t\tdev_err(dev, \"failed to set clk_mipi_cfg to %d\\n\",\n\t\t\t\tKMB_MIPI_DEFAULT_CFG_CLK);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn kmb_dsi_clk_enable(kmb_dsi);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}