{
  "module_name": "kmb_drv.c",
  "hash_id": "5557722ccd7fdf6a021b7ba07fbed30a0716f87ae3d7c298af1af4621dbcfff9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/kmb/kmb_drv.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/of_platform.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"kmb_drv.h\"\n#include \"kmb_dsi.h\"\n#include \"kmb_regs.h\"\n\nstatic int kmb_display_clk_enable(struct kmb_drm_private *kmb)\n{\n\tint ret = 0;\n\n\tret = clk_prepare_enable(kmb->kmb_clk.clk_lcd);\n\tif (ret) {\n\t\tdrm_err(&kmb->drm, \"Failed to enable LCD clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tDRM_INFO(\"SUCCESS : enabled LCD clocks\\n\");\n\treturn 0;\n}\n\nstatic int kmb_initialize_clocks(struct kmb_drm_private *kmb, struct device *dev)\n{\n\tint ret = 0;\n\tstruct regmap *msscam;\n\n\tkmb->kmb_clk.clk_lcd = devm_clk_get(dev, \"clk_lcd\");\n\tif (IS_ERR(kmb->kmb_clk.clk_lcd)) {\n\t\tdrm_err(&kmb->drm, \"clk_get() failed clk_lcd\\n\");\n\t\treturn PTR_ERR(kmb->kmb_clk.clk_lcd);\n\t}\n\n\tkmb->kmb_clk.clk_pll0 = devm_clk_get(dev, \"clk_pll0\");\n\tif (IS_ERR(kmb->kmb_clk.clk_pll0)) {\n\t\tdrm_err(&kmb->drm, \"clk_get() failed clk_pll0 \");\n\t\treturn PTR_ERR(kmb->kmb_clk.clk_pll0);\n\t}\n\tkmb->sys_clk_mhz = clk_get_rate(kmb->kmb_clk.clk_pll0) / 1000000;\n\tdrm_info(&kmb->drm, \"system clk = %d Mhz\", kmb->sys_clk_mhz);\n\n\tret =  kmb_dsi_clk_init(kmb->kmb_dsi);\n\n\t \n\tclk_set_rate(kmb->kmb_clk.clk_lcd, KMB_LCD_DEFAULT_CLK);\n\tif (clk_get_rate(kmb->kmb_clk.clk_lcd) != KMB_LCD_DEFAULT_CLK) {\n\t\tdrm_err(&kmb->drm, \"failed to set to clk_lcd to %d\\n\",\n\t\t\tKMB_LCD_DEFAULT_CLK);\n\t\treturn -1;\n\t}\n\tdrm_dbg(&kmb->drm, \"clk_lcd = %ld\\n\", clk_get_rate(kmb->kmb_clk.clk_lcd));\n\n\tret = kmb_display_clk_enable(kmb);\n\tif (ret)\n\t\treturn ret;\n\n\tmsscam = syscon_regmap_lookup_by_compatible(\"intel,keembay-msscam\");\n\tif (IS_ERR(msscam)) {\n\t\tdrm_err(&kmb->drm, \"failed to get msscam syscon\");\n\t\treturn -1;\n\t}\n\n\t \n\tregmap_update_bits(msscam, MSS_CAM_CLK_CTRL, 0x1fff, 0x1fff);\n\tregmap_update_bits(msscam, MSS_CAM_RSTN_CTRL, 0xffffffff, 0xffffffff);\n\treturn 0;\n}\n\nstatic void kmb_display_clk_disable(struct kmb_drm_private *kmb)\n{\n\tclk_disable_unprepare(kmb->kmb_clk.clk_lcd);\n}\n\nstatic void __iomem *kmb_map_mmio(struct drm_device *drm,\n\t\t\t\t  struct platform_device *pdev,\n\t\t\t\t  char *name)\n{\n\tstruct resource *res;\n\tvoid __iomem *mem;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\n\tif (!res) {\n\t\tdrm_err(drm, \"failed to get resource for %s\", name);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmem = devm_ioremap_resource(drm->dev, res);\n\tif (IS_ERR(mem))\n\t\tdrm_err(drm, \"failed to ioremap %s registers\", name);\n\treturn mem;\n}\n\nstatic int kmb_hw_init(struct drm_device *drm, unsigned long flags)\n{\n\tstruct kmb_drm_private *kmb = to_kmb(drm);\n\tstruct platform_device *pdev = to_platform_device(drm->dev);\n\tint irq_lcd;\n\tint ret = 0;\n\n\t \n\tkmb->lcd_mmio = kmb_map_mmio(drm, pdev, \"lcd\");\n\tif (IS_ERR(kmb->lcd_mmio)) {\n\t\tdrm_err(&kmb->drm, \"failed to map LCD registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = kmb_dsi_map_mmio(kmb->kmb_dsi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tkmb_initialize_clocks(kmb, &pdev->dev);\n\n\t \n\n\t \n\tirq_lcd = platform_get_irq(pdev, 0);\n\tif (irq_lcd < 0) {\n\t\tret = irq_lcd;\n\t\tdrm_err(&kmb->drm, \"irq_lcd not found\");\n\t\tgoto setup_fail;\n\t}\n\n\t \n\tret = of_reserved_mem_device_init(drm->dev);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\n\tspin_lock_init(&kmb->irq_lock);\n\n\tkmb->irq_lcd = irq_lcd;\n\n\treturn 0;\n\n setup_fail:\n\tof_reserved_mem_device_release(drm->dev);\n\n\treturn ret;\n}\n\nstatic const struct drm_mode_config_funcs kmb_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int kmb_setup_mode_config(struct drm_device *drm)\n{\n\tint ret;\n\tstruct kmb_drm_private *kmb = to_kmb(drm);\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn ret;\n\tdrm->mode_config.min_width = KMB_FB_MIN_WIDTH;\n\tdrm->mode_config.min_height = KMB_FB_MIN_HEIGHT;\n\tdrm->mode_config.max_width = KMB_FB_MAX_WIDTH;\n\tdrm->mode_config.max_height = KMB_FB_MAX_HEIGHT;\n\tdrm->mode_config.preferred_depth = 24;\n\tdrm->mode_config.funcs = &kmb_mode_config_funcs;\n\n\tret = kmb_setup_crtc(drm);\n\tif (ret < 0) {\n\t\tdrm_err(drm, \"failed to create crtc\\n\");\n\t\treturn ret;\n\t}\n\tret = kmb_dsi_encoder_init(drm, kmb->kmb_dsi);\n\t \n\tkmb->crtc.port = of_graph_get_port_by_id(drm->dev->of_node, 0);\n\tret = drm_vblank_init(drm, drm->mode_config.num_crtc);\n\tif (ret < 0) {\n\t\tdrm_err(drm, \"failed to initialize vblank\\n\");\n\t\tpm_runtime_disable(drm->dev);\n\t\treturn ret;\n\t}\n\n\tdrm_mode_config_reset(drm);\n\treturn 0;\n}\n\nstatic irqreturn_t handle_lcd_irq(struct drm_device *dev)\n{\n\tunsigned long status, val, val1;\n\tint plane_id, dma0_state, dma1_state;\n\tstruct kmb_drm_private *kmb = to_kmb(dev);\n\tu32 ctrl = 0;\n\n\tstatus = kmb_read_lcd(kmb, LCD_INT_STATUS);\n\n\tspin_lock(&kmb->irq_lock);\n\tif (status & LCD_INT_EOF) {\n\t\tkmb_write_lcd(kmb, LCD_INT_CLEAR, LCD_INT_EOF);\n\n\t\t \n\t\tfor (plane_id = LAYER_0;\n\t\t\t\tplane_id < KMB_MAX_PLANES; plane_id++) {\n\t\t\tif (kmb->plane_status[plane_id].disable) {\n\t\t\t\tkmb_clr_bitmask_lcd(kmb,\n\t\t\t\t\t\t    LCD_LAYERn_DMA_CFG\n\t\t\t\t\t\t    (plane_id),\n\t\t\t\t\t\t    LCD_DMA_LAYER_ENABLE);\n\n\t\t\t\tkmb_clr_bitmask_lcd(kmb, LCD_CONTROL,\n\t\t\t\t\t\t    kmb->plane_status[plane_id].ctrl);\n\n\t\t\t\tctrl = kmb_read_lcd(kmb, LCD_CONTROL);\n\t\t\t\tif (!(ctrl & (LCD_CTRL_VL1_ENABLE |\n\t\t\t\t    LCD_CTRL_VL2_ENABLE |\n\t\t\t\t    LCD_CTRL_GL1_ENABLE |\n\t\t\t\t    LCD_CTRL_GL2_ENABLE))) {\n\t\t\t\t\t \n\t\t\t\t\tkmb_clr_bitmask_lcd(kmb, LCD_CONTROL,\n\t\t\t\t\t\t\t    LCD_CTRL_PIPELINE_DMA);\n\t\t\t\t}\n\n\t\t\t\tkmb->plane_status[plane_id].disable = false;\n\t\t\t}\n\t\t}\n\t\tif (kmb->kmb_under_flow) {\n\t\t\t \n\t\t\tdma0_state = (kmb->layer_no == 0) ?\n\t\t\t    LCD_VIDEO0_DMA0_STATE : LCD_VIDEO1_DMA0_STATE;\n\t\t\tdma1_state = (kmb->layer_no == 0) ?\n\t\t\t    LCD_VIDEO0_DMA1_STATE : LCD_VIDEO1_DMA1_STATE;\n\n\t\t\tdo {\n\t\t\t\tkmb_write_lcd(kmb, LCD_FIFO_FLUSH, 1);\n\t\t\t\tval = kmb_read_lcd(kmb, dma0_state)\n\t\t\t\t    & LCD_DMA_STATE_ACTIVE;\n\t\t\t\tval1 = kmb_read_lcd(kmb, dma1_state)\n\t\t\t\t    & LCD_DMA_STATE_ACTIVE;\n\t\t\t} while ((val || val1));\n\t\t\t \n\t\t\tkmb_clr_bitmask_lcd(kmb,\n\t\t\t\t\t    LCD_LAYERn_DMA_CFG(kmb->layer_no),\n\t\t\t\t\t    LCD_DMA_LAYER_ENABLE);\n\t\t\tkmb_write_lcd(kmb, LCD_FIFO_FLUSH, 1);\n\t\t\tkmb->kmb_flush_done = 1;\n\t\t\tkmb->kmb_under_flow = 0;\n\t\t}\n\t}\n\n\tif (status & LCD_INT_LINE_CMP) {\n\t\t \n\t\tkmb_write_lcd(kmb, LCD_INT_CLEAR, LCD_INT_LINE_CMP);\n\t}\n\n\tif (status & LCD_INT_VERT_COMP) {\n\t\t \n\t\tval = kmb_read_lcd(kmb, LCD_VSTATUS);\n\t\tval = (val & LCD_VSTATUS_VERTICAL_STATUS_MASK);\n\t\tswitch (val) {\n\t\tcase LCD_VSTATUS_COMPARE_VSYNC:\n\t\t\t \n\t\t\tkmb_write_lcd(kmb, LCD_INT_CLEAR, LCD_INT_VERT_COMP);\n\t\t\tif (kmb->kmb_flush_done) {\n\t\t\t\tkmb_set_bitmask_lcd(kmb,\n\t\t\t\t\t\t    LCD_LAYERn_DMA_CFG\n\t\t\t\t\t\t    (kmb->layer_no),\n\t\t\t\t\t\t    LCD_DMA_LAYER_ENABLE);\n\t\t\t\tkmb->kmb_flush_done = 0;\n\t\t\t}\n\t\t\tdrm_crtc_handle_vblank(&kmb->crtc);\n\t\t\tbreak;\n\t\tcase LCD_VSTATUS_COMPARE_BACKPORCH:\n\t\tcase LCD_VSTATUS_COMPARE_ACTIVE:\n\t\tcase LCD_VSTATUS_COMPARE_FRONT_PORCH:\n\t\t\tkmb_write_lcd(kmb, LCD_INT_CLEAR, LCD_INT_VERT_COMP);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (status & LCD_INT_DMA_ERR) {\n\t\tval =\n\t\t    (status & LCD_INT_DMA_ERR &\n\t\t     kmb_read_lcd(kmb, LCD_INT_ENABLE));\n\t\t \n\t\tif (val & (LAYER0_DMA_FIFO_UNDERFLOW |\n\t\t\t   LAYER0_DMA_CB_FIFO_UNDERFLOW |\n\t\t\t   LAYER0_DMA_CR_FIFO_UNDERFLOW)) {\n\t\t\tkmb->kmb_under_flow++;\n\t\t\tdrm_info(&kmb->drm,\n\t\t\t\t \"!LAYER0:VL0 DMA UNDERFLOW val = 0x%lx,under_flow=%d\",\n\t\t\t     val, kmb->kmb_under_flow);\n\t\t\t \n\t\t\tkmb_clr_bitmask_lcd(kmb, LCD_INT_ENABLE,\n\t\t\t\t\t    LAYER0_DMA_FIFO_UNDERFLOW |\n\t\t\t\t\t    LAYER0_DMA_CB_FIFO_UNDERFLOW |\n\t\t\t\t\t    LAYER0_DMA_CR_FIFO_UNDERFLOW);\n\t\t\tkmb_set_bitmask_lcd(kmb, LCD_INT_CLEAR,\n\t\t\t\t\t    LAYER0_DMA_CB_FIFO_UNDERFLOW |\n\t\t\t\t\t    LAYER0_DMA_FIFO_UNDERFLOW |\n\t\t\t\t\t    LAYER0_DMA_CR_FIFO_UNDERFLOW);\n\t\t\t \n\t\t\tkmb_clr_bitmask_lcd(kmb, LCD_LAYERn_DMA_CFG(0),\n\t\t\t\t\t    LCD_DMA_LAYER_CONT_PING_PONG_UPDATE);\n\n\t\t\tkmb->layer_no = 0;\n\t\t}\n\n\t\tif (val & LAYER0_DMA_FIFO_OVERFLOW)\n\t\t\tdrm_dbg(&kmb->drm,\n\t\t\t\t\"LAYER0:VL0 DMA OVERFLOW val = 0x%lx\", val);\n\t\tif (val & LAYER0_DMA_CB_FIFO_OVERFLOW)\n\t\t\tdrm_dbg(&kmb->drm,\n\t\t\t\t\"LAYER0:VL0 DMA CB OVERFLOW val = 0x%lx\", val);\n\t\tif (val & LAYER0_DMA_CR_FIFO_OVERFLOW)\n\t\t\tdrm_dbg(&kmb->drm,\n\t\t\t\t\"LAYER0:VL0 DMA CR OVERFLOW val = 0x%lx\", val);\n\n\t\t \n\t\tif (val & (LAYER1_DMA_FIFO_UNDERFLOW |\n\t\t\t   LAYER1_DMA_CB_FIFO_UNDERFLOW |\n\t\t\t   LAYER1_DMA_CR_FIFO_UNDERFLOW)) {\n\t\t\tkmb->kmb_under_flow++;\n\t\t\tdrm_info(&kmb->drm,\n\t\t\t\t \"!LAYER1:VL1 DMA UNDERFLOW val = 0x%lx, under_flow=%d\",\n\t\t\t     val, kmb->kmb_under_flow);\n\t\t\t \n\t\t\tkmb_clr_bitmask_lcd(kmb, LCD_INT_ENABLE,\n\t\t\t\t\t    LAYER1_DMA_FIFO_UNDERFLOW |\n\t\t\t\t\t    LAYER1_DMA_CB_FIFO_UNDERFLOW |\n\t\t\t\t\t    LAYER1_DMA_CR_FIFO_UNDERFLOW);\n\t\t\tkmb_set_bitmask_lcd(kmb, LCD_INT_CLEAR,\n\t\t\t\t\t    LAYER1_DMA_CB_FIFO_UNDERFLOW |\n\t\t\t\t\t    LAYER1_DMA_FIFO_UNDERFLOW |\n\t\t\t\t\t    LAYER1_DMA_CR_FIFO_UNDERFLOW);\n\t\t\t \n\t\t\tkmb_clr_bitmask_lcd(kmb, LCD_LAYERn_DMA_CFG(1),\n\t\t\t\t\t    LCD_DMA_LAYER_CONT_PING_PONG_UPDATE);\n\t\t\tkmb->layer_no = 1;\n\t\t}\n\n\t\t \n\t\tif (val & LAYER1_DMA_FIFO_OVERFLOW)\n\t\t\tdrm_dbg(&kmb->drm,\n\t\t\t\t\"LAYER1:VL1 DMA OVERFLOW val = 0x%lx\", val);\n\t\tif (val & LAYER1_DMA_CB_FIFO_OVERFLOW)\n\t\t\tdrm_dbg(&kmb->drm,\n\t\t\t\t\"LAYER1:VL1 DMA CB OVERFLOW val = 0x%lx\", val);\n\t\tif (val & LAYER1_DMA_CR_FIFO_OVERFLOW)\n\t\t\tdrm_dbg(&kmb->drm,\n\t\t\t\t\"LAYER1:VL1 DMA CR OVERFLOW val = 0x%lx\", val);\n\n\t\t \n\t\tif (val & LAYER2_DMA_FIFO_UNDERFLOW)\n\t\t\tdrm_dbg(&kmb->drm,\n\t\t\t\t\"LAYER2:GL0 DMA UNDERFLOW val = 0x%lx\", val);\n\t\tif (val & LAYER2_DMA_FIFO_OVERFLOW)\n\t\t\tdrm_dbg(&kmb->drm,\n\t\t\t\t\"LAYER2:GL0 DMA OVERFLOW val = 0x%lx\", val);\n\n\t\t \n\t\tif (val & LAYER3_DMA_FIFO_UNDERFLOW)\n\t\t\tdrm_dbg(&kmb->drm,\n\t\t\t\t\"LAYER3:GL1 DMA UNDERFLOW val = 0x%lx\", val);\n\t\tif (val & LAYER3_DMA_FIFO_OVERFLOW)\n\t\t\tdrm_dbg(&kmb->drm,\n\t\t\t\t\"LAYER3:GL1 DMA OVERFLOW val = 0x%lx\", val);\n\t}\n\n\tspin_unlock(&kmb->irq_lock);\n\n\tif (status & LCD_INT_LAYER) {\n\t\t \n\t\tkmb_write_lcd(kmb, LCD_INT_CLEAR, LCD_INT_LAYER);\n\t}\n\n\t \n\tkmb_set_bitmask_lcd(kmb, LCD_INT_CLEAR, 1);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t kmb_isr(int irq, void *arg)\n{\n\tstruct drm_device *dev = (struct drm_device *)arg;\n\n\thandle_lcd_irq(dev);\n\treturn IRQ_HANDLED;\n}\n\nstatic void kmb_irq_reset(struct drm_device *drm)\n{\n\tkmb_write_lcd(to_kmb(drm), LCD_INT_CLEAR, 0xFFFF);\n\tkmb_write_lcd(to_kmb(drm), LCD_INT_ENABLE, 0);\n}\n\nstatic int kmb_irq_install(struct drm_device *drm, unsigned int irq)\n{\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\tkmb_irq_reset(drm);\n\n\treturn request_irq(irq, kmb_isr, 0, drm->driver->name, drm);\n}\n\nstatic void kmb_irq_uninstall(struct drm_device *drm)\n{\n\tstruct kmb_drm_private *kmb = to_kmb(drm);\n\n\tkmb_irq_reset(drm);\n\tfree_irq(kmb->irq_lcd, drm);\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(fops);\n\nstatic const struct drm_driver kmb_driver = {\n\t.driver_features = DRIVER_GEM |\n\t    DRIVER_MODESET | DRIVER_ATOMIC,\n\t \n\t.fops = &fops,\n\tDRM_GEM_DMA_DRIVER_OPS_VMAP,\n\t.name = \"kmb-drm\",\n\t.desc = \"KEEMBAY DISPLAY DRIVER\",\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n};\n\nstatic int kmb_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct kmb_drm_private *kmb = to_kmb(drm);\n\n\tdrm_dev_unregister(drm);\n\tdrm_kms_helper_poll_fini(drm);\n\tof_node_put(kmb->crtc.port);\n\tkmb->crtc.port = NULL;\n\tpm_runtime_get_sync(drm->dev);\n\tkmb_irq_uninstall(drm);\n\tpm_runtime_put_sync(drm->dev);\n\tpm_runtime_disable(drm->dev);\n\n\tof_reserved_mem_device_release(drm->dev);\n\n\t \n\tkmb_display_clk_disable(kmb);\n\n\tdev_set_drvdata(dev, NULL);\n\n\t \n\tkmb_dsi_host_unregister(kmb->kmb_dsi);\n\tdrm_atomic_helper_shutdown(drm);\n\treturn 0;\n}\n\nstatic int kmb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = get_device(&pdev->dev);\n\tstruct kmb_drm_private *kmb;\n\tint ret = 0;\n\tstruct device_node *dsi_in;\n\tstruct device_node *dsi_node;\n\tstruct platform_device *dsi_pdev;\n\n\t \n\tdsi_in = of_graph_get_endpoint_by_regs(dev->of_node, 0, 0);\n\tif (!dsi_in) {\n\t\tDRM_ERROR(\"Failed to get dsi_in node info from DT\");\n\t\treturn -EINVAL;\n\t}\n\tdsi_node = of_graph_get_remote_port_parent(dsi_in);\n\tif (!dsi_node) {\n\t\tof_node_put(dsi_in);\n\t\tDRM_ERROR(\"Failed to get dsi node from DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdsi_pdev = of_find_device_by_node(dsi_node);\n\tif (!dsi_pdev) {\n\t\tof_node_put(dsi_in);\n\t\tof_node_put(dsi_node);\n\t\tDRM_ERROR(\"Failed to get dsi platform device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tof_node_put(dsi_in);\n\tof_node_put(dsi_node);\n\tret = kmb_dsi_host_bridge_init(get_device(&dsi_pdev->dev));\n\n\tif (ret == -EPROBE_DEFER) {\n\t\treturn -EPROBE_DEFER;\n\t} else if (ret) {\n\t\tDRM_ERROR(\"probe failed to initialize DSI host bridge\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tkmb = devm_drm_dev_alloc(dev, &kmb_driver,\n\t\t\t\t struct kmb_drm_private, drm);\n\tif (IS_ERR(kmb))\n\t\treturn PTR_ERR(kmb);\n\n\tdev_set_drvdata(dev, &kmb->drm);\n\n\t \n\tkmb->kmb_dsi = kmb_dsi_init(dsi_pdev);\n\tif (IS_ERR(kmb->kmb_dsi)) {\n\t\tdrm_err(&kmb->drm, \"failed to initialize DSI\\n\");\n\t\tret = PTR_ERR(kmb->kmb_dsi);\n\t\tgoto err_free1;\n\t}\n\n\tkmb->kmb_dsi->dev = &dsi_pdev->dev;\n\tkmb->kmb_dsi->pdev = dsi_pdev;\n\tret = kmb_hw_init(&kmb->drm, 0);\n\tif (ret)\n\t\tgoto err_free1;\n\n\tret = kmb_setup_mode_config(&kmb->drm);\n\tif (ret)\n\t\tgoto err_free;\n\n\tret = kmb_irq_install(&kmb->drm, kmb->irq_lcd);\n\tif (ret < 0) {\n\t\tdrm_err(&kmb->drm, \"failed to install IRQ handler\\n\");\n\t\tgoto err_irq;\n\t}\n\n\tdrm_kms_helper_poll_init(&kmb->drm);\n\n\t \n\tret = drm_dev_register(&kmb->drm, 0);\n\tif (ret)\n\t\tgoto err_register;\n\n\tdrm_fbdev_dma_setup(&kmb->drm, 0);\n\n\treturn 0;\n\n err_register:\n\tdrm_kms_helper_poll_fini(&kmb->drm);\n err_irq:\n\tpm_runtime_disable(kmb->drm.dev);\n err_free:\n\tdrm_crtc_cleanup(&kmb->crtc);\n\tdrm_mode_config_cleanup(&kmb->drm);\n err_free1:\n\tdev_set_drvdata(dev, NULL);\n\tkmb_dsi_host_unregister(kmb->kmb_dsi);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id kmb_of_match[] = {\n\t{.compatible = \"intel,keembay-display\"},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, kmb_of_match);\n\nstatic int __maybe_unused kmb_pm_suspend(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct kmb_drm_private *kmb = to_kmb(drm);\n\n\tdrm_kms_helper_poll_disable(drm);\n\n\tkmb->state = drm_atomic_helper_suspend(drm);\n\tif (IS_ERR(kmb->state)) {\n\t\tdrm_kms_helper_poll_enable(drm);\n\t\treturn PTR_ERR(kmb->state);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused kmb_pm_resume(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct kmb_drm_private *kmb = drm ? to_kmb(drm) : NULL;\n\n\tif (!kmb)\n\t\treturn 0;\n\n\tdrm_atomic_helper_resume(drm, kmb->state);\n\tdrm_kms_helper_poll_enable(drm);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(kmb_pm_ops, kmb_pm_suspend, kmb_pm_resume);\n\nstatic struct platform_driver kmb_platform_driver = {\n\t.probe = kmb_probe,\n\t.remove = kmb_remove,\n\t.driver = {\n\t\t.name = \"kmb-drm\",\n\t\t.pm = &kmb_pm_ops,\n\t\t.of_match_table = kmb_of_match,\n\t},\n};\n\ndrm_module_platform_driver(kmb_platform_driver);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_DESCRIPTION(\"Keembay Display driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}