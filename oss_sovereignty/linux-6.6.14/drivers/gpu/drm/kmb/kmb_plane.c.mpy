{
  "module_name": "kmb_plane.c",
  "hash_id": "7e903020e0cb81204f436b6af27440c361b7612930e45247cbba8941451b3a0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/kmb/kmb_plane.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_managed.h>\n\n#include \"kmb_drv.h\"\n#include \"kmb_plane.h\"\n#include \"kmb_regs.h\"\n\nconst u32 layer_irqs[] = {\n\tLCD_INT_VL0,\n\tLCD_INT_VL1,\n\tLCD_INT_GL0,\n\tLCD_INT_GL1\n};\n\n \nstatic const u32 csc_coef_lcd[] = {\n\t1024, 0, 1436,\n\t1024, -352, -731,\n\t1024, 1814, 0,\n\t-179, 125, -226\n};\n\n \nstatic const u32 kmb_formats_g[] = {\n\tDRM_FORMAT_RGB332,\n\tDRM_FORMAT_XRGB4444, DRM_FORMAT_XBGR4444,\n\tDRM_FORMAT_ARGB4444, DRM_FORMAT_ABGR4444,\n\tDRM_FORMAT_XRGB1555, DRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_ARGB1555, DRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_RGB565, DRM_FORMAT_BGR565,\n\tDRM_FORMAT_RGB888, DRM_FORMAT_BGR888,\n\tDRM_FORMAT_XRGB8888, DRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888, DRM_FORMAT_ABGR8888,\n};\n\n \nstatic const u32 kmb_formats_v[] = {\n\t \n\tDRM_FORMAT_RGB332,\n\tDRM_FORMAT_XRGB4444, DRM_FORMAT_XBGR4444,\n\tDRM_FORMAT_ARGB4444, DRM_FORMAT_ABGR4444,\n\tDRM_FORMAT_XRGB1555, DRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_ARGB1555, DRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_RGB565, DRM_FORMAT_BGR565,\n\tDRM_FORMAT_RGB888, DRM_FORMAT_BGR888,\n\tDRM_FORMAT_XRGB8888, DRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888, DRM_FORMAT_ABGR8888,\n\t \n\tDRM_FORMAT_YUV420, DRM_FORMAT_YVU420,\n\tDRM_FORMAT_YUV422, DRM_FORMAT_YVU422,\n\tDRM_FORMAT_YUV444, DRM_FORMAT_YVU444,\n\tDRM_FORMAT_NV12, DRM_FORMAT_NV21,\n};\n\nstatic unsigned int check_pixel_format(struct drm_plane *plane, u32 format)\n{\n\tstruct kmb_drm_private *kmb;\n\tstruct kmb_plane *kmb_plane = to_kmb_plane(plane);\n\tint i;\n\tint plane_id = kmb_plane->id;\n\tstruct disp_cfg init_disp_cfg;\n\n\tkmb = to_kmb(plane->dev);\n\tinit_disp_cfg = kmb->init_disp_cfg[plane_id];\n\t \n\tif (init_disp_cfg.format && init_disp_cfg.format != format) {\n\t\tdrm_dbg(&kmb->drm, \"Cannot change format after initial plane configuration\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < plane->format_count; i++) {\n\t\tif (plane->format_types[i] == format)\n\t\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int kmb_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct kmb_drm_private *kmb;\n\tstruct kmb_plane *kmb_plane = to_kmb_plane(plane);\n\tint plane_id = kmb_plane->id;\n\tstruct disp_cfg init_disp_cfg;\n\tstruct drm_framebuffer *fb;\n\tint ret;\n\tstruct drm_crtc_state *crtc_state;\n\tbool can_position;\n\n\tkmb = to_kmb(plane->dev);\n\tinit_disp_cfg = kmb->init_disp_cfg[plane_id];\n\tfb = new_plane_state->fb;\n\tif (!fb || !new_plane_state->crtc)\n\t\treturn 0;\n\n\tret = check_pixel_format(plane, fb->format->format);\n\tif (ret)\n\t\treturn ret;\n\n\tif (new_plane_state->crtc_w > KMB_FB_MAX_WIDTH ||\n\t    new_plane_state->crtc_h > KMB_FB_MAX_HEIGHT ||\n\t    new_plane_state->crtc_w < KMB_FB_MIN_WIDTH ||\n\t    new_plane_state->crtc_h < KMB_FB_MIN_HEIGHT)\n\t\treturn -EINVAL;\n\n\t \n\tif ((init_disp_cfg.width && init_disp_cfg.height) &&\n\t    (init_disp_cfg.width != fb->width ||\n\t    init_disp_cfg.height != fb->height)) {\n\t\tdrm_dbg(&kmb->drm, \"Cannot change plane height or width after initial configuration\");\n\t\treturn -EINVAL;\n\t}\n\tcan_position = (plane->type == DRM_PLANE_TYPE_OVERLAY);\n\tcrtc_state =\n\t\tdrm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t   new_plane_state->crtc);\n\treturn drm_atomic_helper_check_plane_state(new_plane_state,\n\t\t\t\t\t\t   crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   can_position, true);\n}\n\nstatic void kmb_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct kmb_plane *kmb_plane = to_kmb_plane(plane);\n\tint plane_id = kmb_plane->id;\n\tstruct kmb_drm_private *kmb;\n\n\tkmb = to_kmb(plane->dev);\n\n\tif (WARN_ON(plane_id >= KMB_MAX_PLANES))\n\t\treturn;\n\n\tswitch (plane_id) {\n\tcase LAYER_0:\n\t\tkmb->plane_status[plane_id].ctrl = LCD_CTRL_VL1_ENABLE;\n\t\tbreak;\n\tcase LAYER_1:\n\t\tkmb->plane_status[plane_id].ctrl = LCD_CTRL_VL2_ENABLE;\n\t\tbreak;\n\t}\n\n\tkmb->plane_status[plane_id].disable = true;\n}\n\nstatic unsigned int get_pixel_format(u32 format)\n{\n\tunsigned int val = 0;\n\n\tswitch (format) {\n\t\t \n\tcase DRM_FORMAT_YUV444:\n\t\tval = LCD_LAYER_FORMAT_YCBCR444PLAN | LCD_LAYER_PLANAR_STORAGE;\n\t\tbreak;\n\tcase DRM_FORMAT_YVU444:\n\t\tval = LCD_LAYER_FORMAT_YCBCR444PLAN | LCD_LAYER_PLANAR_STORAGE\n\t\t    | LCD_LAYER_CRCB_ORDER;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV422:\n\t\tval = LCD_LAYER_FORMAT_YCBCR422PLAN | LCD_LAYER_PLANAR_STORAGE;\n\t\tbreak;\n\tcase DRM_FORMAT_YVU422:\n\t\tval = LCD_LAYER_FORMAT_YCBCR422PLAN | LCD_LAYER_PLANAR_STORAGE\n\t\t    | LCD_LAYER_CRCB_ORDER;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV420:\n\t\tval = LCD_LAYER_FORMAT_YCBCR420PLAN | LCD_LAYER_PLANAR_STORAGE;\n\t\tbreak;\n\tcase DRM_FORMAT_YVU420:\n\t\tval = LCD_LAYER_FORMAT_YCBCR420PLAN | LCD_LAYER_PLANAR_STORAGE\n\t\t    | LCD_LAYER_CRCB_ORDER;\n\t\tbreak;\n\tcase DRM_FORMAT_NV12:\n\t\tval = LCD_LAYER_FORMAT_NV12 | LCD_LAYER_PLANAR_STORAGE;\n\t\tbreak;\n\tcase DRM_FORMAT_NV21:\n\t\tval = LCD_LAYER_FORMAT_NV12 | LCD_LAYER_PLANAR_STORAGE\n\t\t    | LCD_LAYER_CRCB_ORDER;\n\t\tbreak;\n\t\t \n\t\t \n\tcase DRM_FORMAT_RGB332:\n\t\tval = LCD_LAYER_FORMAT_RGB332 | LCD_LAYER_BGR_ORDER;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR4444:\n\t\tval = LCD_LAYER_FORMAT_RGBX4444;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB4444:\n\t\tval = LCD_LAYER_FORMAT_RGBA4444 | LCD_LAYER_BGR_ORDER;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR4444:\n\t\tval = LCD_LAYER_FORMAT_RGBA4444;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\t\tval = LCD_LAYER_FORMAT_XRGB1555 | LCD_LAYER_BGR_ORDER;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR1555:\n\t\tval = LCD_LAYER_FORMAT_XRGB1555;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB1555:\n\t\tval = LCD_LAYER_FORMAT_RGBA1555 | LCD_LAYER_BGR_ORDER;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR1555:\n\t\tval = LCD_LAYER_FORMAT_RGBA1555;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tval = LCD_LAYER_FORMAT_RGB565 | LCD_LAYER_BGR_ORDER;\n\t\tbreak;\n\tcase DRM_FORMAT_BGR565:\n\t\tval = LCD_LAYER_FORMAT_RGB565;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\t\tval = LCD_LAYER_FORMAT_RGB888 | LCD_LAYER_BGR_ORDER;\n\t\tbreak;\n\tcase DRM_FORMAT_BGR888:\n\t\tval = LCD_LAYER_FORMAT_RGB888;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tval = LCD_LAYER_FORMAT_RGBX8888 | LCD_LAYER_BGR_ORDER;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\t\tval = LCD_LAYER_FORMAT_RGBX8888;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\t\tval = LCD_LAYER_FORMAT_RGBA8888 | LCD_LAYER_BGR_ORDER;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR8888:\n\t\tval = LCD_LAYER_FORMAT_RGBA8888;\n\t\tbreak;\n\t}\n\tDRM_INFO_ONCE(\"%s : %d format=0x%x val=0x%x\\n\",\n\t\t      __func__, __LINE__, format, val);\n\treturn val;\n}\n\nstatic unsigned int get_bits_per_pixel(const struct drm_format_info *format)\n{\n\tu32 bpp = 0;\n\tunsigned int val = 0;\n\n\tif (format->num_planes > 1) {\n\t\tval = LCD_LAYER_8BPP;\n\t\treturn val;\n\t}\n\n\tbpp += 8 * format->cpp[0];\n\n\tswitch (bpp) {\n\tcase 8:\n\t\tval = LCD_LAYER_8BPP;\n\t\tbreak;\n\tcase 16:\n\t\tval = LCD_LAYER_16BPP;\n\t\tbreak;\n\tcase 24:\n\t\tval = LCD_LAYER_24BPP;\n\t\tbreak;\n\tcase 32:\n\t\tval = LCD_LAYER_32BPP;\n\t\tbreak;\n\t}\n\n\tDRM_DEBUG(\"bpp=%d val=0x%x\\n\", bpp, val);\n\treturn val;\n}\n\nstatic void config_csc(struct kmb_drm_private *kmb, int plane_id)\n{\n\t \n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_COEFF11(plane_id), csc_coef_lcd[0]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_COEFF12(plane_id), csc_coef_lcd[1]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_COEFF13(plane_id), csc_coef_lcd[2]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_COEFF21(plane_id), csc_coef_lcd[3]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_COEFF22(plane_id), csc_coef_lcd[4]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_COEFF23(plane_id), csc_coef_lcd[5]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_COEFF31(plane_id), csc_coef_lcd[6]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_COEFF32(plane_id), csc_coef_lcd[7]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_COEFF33(plane_id), csc_coef_lcd[8]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_OFF1(plane_id), csc_coef_lcd[9]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_OFF2(plane_id), csc_coef_lcd[10]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_CSC_OFF3(plane_id), csc_coef_lcd[11]);\n}\n\nstatic void kmb_plane_set_alpha(struct kmb_drm_private *kmb,\n\t\t\t\tconst struct drm_plane_state *state,\n\t\t\t\tunsigned char plane_id,\n\t\t\t\tunsigned int *val)\n{\n\tu16 plane_alpha = state->alpha;\n\tu16 pixel_blend_mode = state->pixel_blend_mode;\n\tint has_alpha = state->fb->format->has_alpha;\n\n\tif (plane_alpha != DRM_BLEND_ALPHA_OPAQUE)\n\t\t*val |= LCD_LAYER_ALPHA_STATIC;\n\n\tif (has_alpha) {\n\t\tswitch (pixel_blend_mode) {\n\t\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\t\t\tbreak;\n\t\tcase DRM_MODE_BLEND_PREMULTI:\n\t\t\t*val |= LCD_LAYER_ALPHA_EMBED | LCD_LAYER_ALPHA_PREMULT;\n\t\t\tbreak;\n\t\tcase DRM_MODE_BLEND_COVERAGE:\n\t\t\t*val |= LCD_LAYER_ALPHA_EMBED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"Missing pixel blend mode case (%s == %ld)\\n\",\n\t\t\t\t  __stringify(pixel_blend_mode),\n\t\t\t\t  (long)pixel_blend_mode);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (plane_alpha == DRM_BLEND_ALPHA_OPAQUE && !has_alpha) {\n\t\t*val &= LCD_LAYER_ALPHA_DISABLED;\n\t\treturn;\n\t}\n\n\tkmb_write_lcd(kmb, LCD_LAYERn_ALPHA(plane_id), plane_alpha);\n}\n\nstatic void kmb_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_framebuffer *fb;\n\tstruct kmb_drm_private *kmb;\n\tunsigned int width;\n\tunsigned int height;\n\tunsigned int dma_len;\n\tstruct kmb_plane *kmb_plane;\n\tunsigned int dma_cfg;\n\tunsigned int ctrl = 0, val = 0, out_format = 0;\n\tunsigned int src_w, src_h, crtc_x, crtc_y;\n\tunsigned char plane_id;\n\tint num_planes;\n\tstatic dma_addr_t addr[MAX_SUB_PLANES];\n\tstruct disp_cfg *init_disp_cfg;\n\n\tif (!plane || !new_plane_state || !old_plane_state)\n\t\treturn;\n\n\tfb = new_plane_state->fb;\n\tif (!fb)\n\t\treturn;\n\n\tnum_planes = fb->format->num_planes;\n\tkmb_plane = to_kmb_plane(plane);\n\n\tkmb = to_kmb(plane->dev);\n\tplane_id = kmb_plane->id;\n\n\tspin_lock_irq(&kmb->irq_lock);\n\tif (kmb->kmb_under_flow || kmb->kmb_flush_done) {\n\t\tspin_unlock_irq(&kmb->irq_lock);\n\t\tdrm_dbg(&kmb->drm, \"plane_update:underflow!!!! returning\");\n\t\treturn;\n\t}\n\tspin_unlock_irq(&kmb->irq_lock);\n\n\tinit_disp_cfg = &kmb->init_disp_cfg[plane_id];\n\tsrc_w = new_plane_state->src_w >> 16;\n\tsrc_h = new_plane_state->src_h >> 16;\n\tcrtc_x = new_plane_state->crtc_x;\n\tcrtc_y = new_plane_state->crtc_y;\n\n\tdrm_dbg(&kmb->drm,\n\t\t\"src_w=%d src_h=%d, fb->format->format=0x%x fb->flags=0x%x\\n\",\n\t\t  src_w, src_h, fb->format->format, fb->flags);\n\n\twidth = fb->width;\n\theight = fb->height;\n\tdma_len = (width * height * fb->format->cpp[0]);\n\tdrm_dbg(&kmb->drm, \"dma_len=%d \", dma_len);\n\tkmb_write_lcd(kmb, LCD_LAYERn_DMA_LEN(plane_id), dma_len);\n\tkmb_write_lcd(kmb, LCD_LAYERn_DMA_LEN_SHADOW(plane_id), dma_len);\n\tkmb_write_lcd(kmb, LCD_LAYERn_DMA_LINE_VSTRIDE(plane_id),\n\t\t      fb->pitches[0]);\n\tkmb_write_lcd(kmb, LCD_LAYERn_DMA_LINE_WIDTH(plane_id),\n\t\t      (width * fb->format->cpp[0]));\n\n\taddr[Y_PLANE] = drm_fb_dma_get_gem_addr(fb, new_plane_state, 0);\n\tkmb_write_lcd(kmb, LCD_LAYERn_DMA_START_ADDR(plane_id),\n\t\t      addr[Y_PLANE] + fb->offsets[0]);\n\tval = get_pixel_format(fb->format->format);\n\tval |= get_bits_per_pixel(fb->format);\n\t \n\tif (num_planes > 1) {\n\t\tkmb_write_lcd(kmb, LCD_LAYERn_DMA_CB_LINE_VSTRIDE(plane_id),\n\t\t\t      width * fb->format->cpp[0]);\n\t\tkmb_write_lcd(kmb, LCD_LAYERn_DMA_CB_LINE_WIDTH(plane_id),\n\t\t\t      (width * fb->format->cpp[0]));\n\n\t\taddr[U_PLANE] = drm_fb_dma_get_gem_addr(fb, new_plane_state,\n\t\t\t\t\t\t\tU_PLANE);\n\t\t \n\t\tif (num_planes == 3 && (val & LCD_LAYER_CRCB_ORDER))\n\t\t\tkmb_write_lcd(kmb,\n\t\t\t\t      LCD_LAYERn_DMA_START_CR_ADR(plane_id),\n\t\t\t\t\taddr[U_PLANE]);\n\t\telse\n\t\t\tkmb_write_lcd(kmb,\n\t\t\t\t      LCD_LAYERn_DMA_START_CB_ADR(plane_id),\n\t\t\t\t\taddr[U_PLANE]);\n\n\t\tif (num_planes == 3) {\n\t\t\tkmb_write_lcd(kmb,\n\t\t\t\t      LCD_LAYERn_DMA_CR_LINE_VSTRIDE(plane_id),\n\t\t\t\t      ((width) * fb->format->cpp[0]));\n\n\t\t\tkmb_write_lcd(kmb,\n\t\t\t\t      LCD_LAYERn_DMA_CR_LINE_WIDTH(plane_id),\n\t\t\t\t      ((width) * fb->format->cpp[0]));\n\n\t\t\taddr[V_PLANE] = drm_fb_dma_get_gem_addr(fb,\n\t\t\t\t\t\t\t\tnew_plane_state,\n\t\t\t\t\t\t\t\tV_PLANE);\n\n\t\t\t \n\t\t\tif (val & LCD_LAYER_CRCB_ORDER)\n\t\t\t\tkmb_write_lcd(kmb,\n\t\t\t\t\t      LCD_LAYERn_DMA_START_CB_ADR(plane_id),\n\t\t\t\t\t      addr[V_PLANE]);\n\t\t\telse\n\t\t\t\tkmb_write_lcd(kmb,\n\t\t\t\t\t      LCD_LAYERn_DMA_START_CR_ADR(plane_id),\n\t\t\t\t\t      addr[V_PLANE]);\n\t\t}\n\t}\n\n\tkmb_write_lcd(kmb, LCD_LAYERn_WIDTH(plane_id), src_w - 1);\n\tkmb_write_lcd(kmb, LCD_LAYERn_HEIGHT(plane_id), src_h - 1);\n\tkmb_write_lcd(kmb, LCD_LAYERn_COL_START(plane_id), crtc_x);\n\tkmb_write_lcd(kmb, LCD_LAYERn_ROW_START(plane_id), crtc_y);\n\n\tval |= LCD_LAYER_FIFO_100;\n\n\tif (val & LCD_LAYER_PLANAR_STORAGE) {\n\t\tval |= LCD_LAYER_CSC_EN;\n\n\t\t \n\t\tconfig_csc(kmb, plane_id);\n\t}\n\n\tkmb_plane_set_alpha(kmb, plane->state, plane_id, &val);\n\n\tkmb_write_lcd(kmb, LCD_LAYERn_CFG(plane_id), val);\n\n\t \n\tctrl = kmb_read_lcd(kmb, LCD_CONTROL);\n\n\t \n\tctrl &= ~LCD_CTRL_ALPHA_ALL;\n\tctrl |= LCD_CTRL_ALPHA_BOTTOM_VL1 |\n\t\tLCD_CTRL_ALPHA_BLEND_VL2;\n\n\tctrl &= ~LCD_CTRL_ALPHA_BLEND_BKGND_DISABLE;\n\n\tswitch (plane_id) {\n\tcase LAYER_0:\n\t\tctrl |= LCD_CTRL_VL1_ENABLE;\n\t\tbreak;\n\tcase LAYER_1:\n\t\tctrl |= LCD_CTRL_VL2_ENABLE;\n\t\tbreak;\n\tcase LAYER_2:\n\t\tctrl |= LCD_CTRL_GL1_ENABLE;\n\t\tbreak;\n\tcase LAYER_3:\n\t\tctrl |= LCD_CTRL_GL2_ENABLE;\n\t\tbreak;\n\t}\n\n\tctrl |= LCD_CTRL_PROGRESSIVE | LCD_CTRL_TIM_GEN_ENABLE\n\t    | LCD_CTRL_CONTINUOUS | LCD_CTRL_OUTPUT_ENABLED;\n\n\t \n\tctrl |= LCD_CTRL_VHSYNC_IDLE_LVL;\n\n\tkmb_write_lcd(kmb, LCD_CONTROL, ctrl);\n\n\t \n\tkmb_set_bitmask_lcd(kmb, LCD_CONTROL, LCD_CTRL_PIPELINE_DMA);\n\n\t \n\tout_format |= LCD_OUTF_FORMAT_RGB888;\n\n\t \n\t \n\tout_format |= LCD_OUTF_MIPI_RGB_MODE;\n\tkmb_write_lcd(kmb, LCD_OUT_FORMAT_CFG, out_format);\n\n\tdma_cfg = LCD_DMA_LAYER_ENABLE | LCD_DMA_LAYER_VSTRIDE_EN |\n\t    LCD_DMA_LAYER_CONT_UPDATE | LCD_DMA_LAYER_AXI_BURST_16;\n\n\t \n\tkmb_write_lcd(kmb, LCD_LAYERn_DMA_CFG(plane_id), dma_cfg);\n\n\t \n\tif (!init_disp_cfg->width ||\n\t    !init_disp_cfg->height ||\n\t    !init_disp_cfg->format) {\n\t\tinit_disp_cfg->width = width;\n\t\tinit_disp_cfg->height = height;\n\t\tinit_disp_cfg->format = fb->format->format;\n\t}\n\n\tdrm_dbg(&kmb->drm, \"dma_cfg=0x%x LCD_DMA_CFG=0x%x\\n\", dma_cfg,\n\t\tkmb_read_lcd(kmb, LCD_LAYERn_DMA_CFG(plane_id)));\n\n\tkmb_set_bitmask_lcd(kmb, LCD_INT_CLEAR, LCD_INT_EOF |\n\t\t\tLCD_INT_DMA_ERR);\n\tkmb_set_bitmask_lcd(kmb, LCD_INT_ENABLE, LCD_INT_EOF |\n\t\t\tLCD_INT_DMA_ERR);\n}\n\nstatic const struct drm_plane_helper_funcs kmb_plane_helper_funcs = {\n\t.atomic_check = kmb_plane_atomic_check,\n\t.atomic_update = kmb_plane_atomic_update,\n\t.atomic_disable = kmb_plane_atomic_disable\n};\n\nvoid kmb_plane_destroy(struct drm_plane *plane)\n{\n\tstruct kmb_plane *kmb_plane = to_kmb_plane(plane);\n\n\tdrm_plane_cleanup(plane);\n\tkfree(kmb_plane);\n}\n\nstatic const struct drm_plane_funcs kmb_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = kmb_plane_destroy,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n};\n\nstruct kmb_plane *kmb_plane_init(struct drm_device *drm)\n{\n\tstruct kmb_drm_private *kmb = to_kmb(drm);\n\tstruct kmb_plane *plane = NULL;\n\tstruct kmb_plane *primary = NULL;\n\tint i = 0;\n\tint ret = 0;\n\tenum drm_plane_type plane_type;\n\tconst u32 *plane_formats;\n\tint num_plane_formats;\n\tunsigned int blend_caps = BIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\t  BIT(DRM_MODE_BLEND_PREMULTI)   |\n\t\t\t\t  BIT(DRM_MODE_BLEND_COVERAGE);\n\n\tfor (i = 0; i < KMB_MAX_PLANES; i++) {\n\t\tplane = drmm_kzalloc(drm, sizeof(*plane), GFP_KERNEL);\n\n\t\tif (!plane) {\n\t\t\tdrm_err(drm, \"Failed to allocate plane\\n\");\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tplane_type = (i == 0) ? DRM_PLANE_TYPE_PRIMARY :\n\t\t    DRM_PLANE_TYPE_OVERLAY;\n\t\tif (i < 2) {\n\t\t\tplane_formats = kmb_formats_v;\n\t\t\tnum_plane_formats = ARRAY_SIZE(kmb_formats_v);\n\t\t} else {\n\t\t\tplane_formats = kmb_formats_g;\n\t\t\tnum_plane_formats = ARRAY_SIZE(kmb_formats_g);\n\t\t}\n\n\t\tret = drm_universal_plane_init(drm, &plane->base_plane,\n\t\t\t\t\t       POSSIBLE_CRTCS, &kmb_plane_funcs,\n\t\t\t\t\t       plane_formats, num_plane_formats,\n\t\t\t\t\t       NULL, plane_type, \"plane %d\", i);\n\t\tif (ret < 0) {\n\t\t\tdrm_err(drm, \"drm_universal_plane_init failed (ret=%d)\",\n\t\t\t\tret);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tdrm_dbg(drm, \"%s : %d i=%d type=%d\",\n\t\t\t__func__, __LINE__,\n\t\t\t  i, plane_type);\n\t\tdrm_plane_create_alpha_property(&plane->base_plane);\n\n\t\tdrm_plane_create_blend_mode_property(&plane->base_plane,\n\t\t\t\t\t\t     blend_caps);\n\n\t\tdrm_plane_create_zpos_immutable_property(&plane->base_plane, i);\n\n\t\tdrm_plane_helper_add(&plane->base_plane,\n\t\t\t\t     &kmb_plane_helper_funcs);\n\n\t\tif (plane_type == DRM_PLANE_TYPE_PRIMARY) {\n\t\t\tprimary = plane;\n\t\t\tkmb->plane = plane;\n\t\t}\n\t\tdrm_dbg(drm, \"%s : %d primary=%p\\n\", __func__, __LINE__,\n\t\t\t&primary->base_plane);\n\t\tplane->id = i;\n\t}\n\n\t \n\tkmb_clr_bitmask_lcd(kmb, LCD_CONTROL, LCD_CTRL_PIPELINE_DMA);\n\n\treturn primary;\ncleanup:\n\tdrmm_kfree(drm, plane);\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}