{
  "module_name": "kmb_crtc.c",
  "hash_id": "51c90e4cdd43d4f1673c6fca7a842b52b27ec66b4cb7e8caab3a160680d03542",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/kmb/kmb_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_modeset_helper_vtables.h>\n\n#include \"kmb_drv.h\"\n#include \"kmb_dsi.h\"\n#include \"kmb_plane.h\"\n#include \"kmb_regs.h\"\n\nstruct kmb_crtc_timing {\n\tu32 vfront_porch;\n\tu32 vback_porch;\n\tu32 vsync_len;\n\tu32 hfront_porch;\n\tu32 hback_porch;\n\tu32 hsync_len;\n};\n\nstatic int kmb_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct kmb_drm_private *kmb = to_kmb(dev);\n\n\t \n\tkmb_write_lcd(kmb, LCD_INT_CLEAR, LCD_INT_VERT_COMP);\n\t \n\tkmb_write_lcd(kmb, LCD_VSTATUS_COMPARE,\n\t\t      LCD_VSTATUS_COMPARE_VSYNC);\n\t \n\tkmb_set_bitmask_lcd(kmb, LCD_INT_ENABLE,\n\t\t\t    LCD_INT_VERT_COMP);\n\treturn 0;\n}\n\nstatic void kmb_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct kmb_drm_private *kmb = to_kmb(dev);\n\n\t \n\tkmb_write_lcd(kmb, LCD_INT_CLEAR, LCD_INT_VERT_COMP);\n\t \n\tkmb_clr_bitmask_lcd(kmb, LCD_INT_ENABLE,\n\t\t\t    LCD_INT_VERT_COMP);\n}\n\nstatic const struct drm_crtc_funcs kmb_crtc_funcs = {\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank = kmb_crtc_enable_vblank,\n\t.disable_vblank = kmb_crtc_disable_vblank,\n};\n\nstatic void kmb_crtc_set_mode(struct drm_crtc *crtc,\n\t\t\t      struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_display_mode *m = &crtc->state->adjusted_mode;\n\tstruct kmb_crtc_timing vm;\n\tstruct kmb_drm_private *kmb = to_kmb(dev);\n\tunsigned int val = 0;\n\n\t \n\tkmb_dsi_mode_set(kmb->kmb_dsi, m, kmb->sys_clk_mhz, old_state);\n\tdrm_info(dev,\n\t\t \"vfp= %d vbp= %d vsync_len=%d hfp=%d hbp=%d hsync_len=%d\\n\",\n\t\t m->crtc_vsync_start - m->crtc_vdisplay,\n\t\t m->crtc_vtotal - m->crtc_vsync_end,\n\t\t m->crtc_vsync_end - m->crtc_vsync_start,\n\t\t m->crtc_hsync_start - m->crtc_hdisplay,\n\t\t m->crtc_htotal - m->crtc_hsync_end,\n\t\t m->crtc_hsync_end - m->crtc_hsync_start);\n\tval = kmb_read_lcd(kmb, LCD_INT_ENABLE);\n\tkmb_clr_bitmask_lcd(kmb, LCD_INT_ENABLE, val);\n\tkmb_set_bitmask_lcd(kmb, LCD_INT_CLEAR, ~0x0);\n\tvm.vfront_porch = 2;\n\tvm.vback_porch = 2;\n\tvm.vsync_len = 8;\n\tvm.hfront_porch = 0;\n\tvm.hback_porch = 0;\n\tvm.hsync_len = 28;\n\n\tdrm_dbg(dev, \"%s : %dactive height= %d vbp=%d vfp=%d vsync-w=%d h-active=%d h-bp=%d h-fp=%d hsync-l=%d\",\n\t\t__func__, __LINE__,\n\t\t\tm->crtc_vdisplay, vm.vback_porch, vm.vfront_porch,\n\t\t\tvm.vsync_len, m->crtc_hdisplay, vm.hback_porch,\n\t\t\tvm.hfront_porch, vm.hsync_len);\n\tkmb_write_lcd(kmb, LCD_V_ACTIVEHEIGHT,\n\t\t      m->crtc_vdisplay - 1);\n\tkmb_write_lcd(kmb, LCD_V_BACKPORCH, vm.vback_porch);\n\tkmb_write_lcd(kmb, LCD_V_FRONTPORCH, vm.vfront_porch);\n\tkmb_write_lcd(kmb, LCD_VSYNC_WIDTH, vm.vsync_len - 1);\n\tkmb_write_lcd(kmb, LCD_H_ACTIVEWIDTH,\n\t\t      m->crtc_hdisplay - 1);\n\tkmb_write_lcd(kmb, LCD_H_BACKPORCH, vm.hback_porch);\n\tkmb_write_lcd(kmb, LCD_H_FRONTPORCH, vm.hfront_porch);\n\tkmb_write_lcd(kmb, LCD_HSYNC_WIDTH, vm.hsync_len - 1);\n\t \n\tkmb_write_lcd(kmb, LCD_VSYNC_START, 0);\n\tkmb_write_lcd(kmb, LCD_VSYNC_END, 0);\n\t \n\tkmb_write_lcd(kmb, LCD_BG_COLOUR_LS, 0x4);\n\tif (m->flags == DRM_MODE_FLAG_INTERLACE) {\n\t\tkmb_write_lcd(kmb,\n\t\t\t      LCD_VSYNC_WIDTH_EVEN, vm.vsync_len - 1);\n\t\tkmb_write_lcd(kmb,\n\t\t\t      LCD_V_BACKPORCH_EVEN, vm.vback_porch);\n\t\tkmb_write_lcd(kmb,\n\t\t\t      LCD_V_FRONTPORCH_EVEN, vm.vfront_porch);\n\t\tkmb_write_lcd(kmb, LCD_V_ACTIVEHEIGHT_EVEN,\n\t\t\t      m->crtc_vdisplay - 1);\n\t\t \n\t\tkmb_write_lcd(kmb, LCD_VSYNC_START_EVEN, 10);\n\t\tkmb_write_lcd(kmb, LCD_VSYNC_END_EVEN, 10);\n\t}\n\tkmb_write_lcd(kmb, LCD_TIMING_GEN_TRIG, 1);\n\tkmb_set_bitmask_lcd(kmb, LCD_CONTROL, LCD_CTRL_ENABLE);\n\tkmb_set_bitmask_lcd(kmb, LCD_INT_ENABLE, val);\n}\n\nstatic void kmb_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct kmb_drm_private *kmb = crtc_to_kmb_priv(crtc);\n\n\tclk_prepare_enable(kmb->kmb_clk.clk_lcd);\n\tkmb_crtc_set_mode(crtc, state);\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void kmb_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct kmb_drm_private *kmb = crtc_to_kmb_priv(crtc);\n\tstruct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state, crtc);\n\n\t \n\tdrm_atomic_helper_disable_planes_on_crtc(old_state, false);\n\n\tdrm_crtc_vblank_off(crtc);\n\tclk_disable_unprepare(kmb->kmb_clk.clk_lcd);\n}\n\nstatic void kmb_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct kmb_drm_private *kmb = to_kmb(dev);\n\n\tkmb_clr_bitmask_lcd(kmb, LCD_INT_ENABLE,\n\t\t\t    LCD_INT_VERT_COMP);\n}\n\nstatic void kmb_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct kmb_drm_private *kmb = to_kmb(dev);\n\n\tkmb_set_bitmask_lcd(kmb, LCD_INT_ENABLE,\n\t\t\t    LCD_INT_VERT_COMP);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (crtc->state->event) {\n\t\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, crtc->state->event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t}\n\tcrtc->state->event = NULL;\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nstatic enum drm_mode_status\n\t\tkmb_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tint refresh;\n\tstruct drm_device *dev = crtc->dev;\n\tint vfp = mode->vsync_start - mode->vdisplay;\n\n\tif (mode->vdisplay < KMB_CRTC_MAX_HEIGHT) {\n\t\tdrm_dbg(dev, \"height = %d less than %d\",\n\t\t\tmode->vdisplay, KMB_CRTC_MAX_HEIGHT);\n\t\treturn MODE_BAD_VVALUE;\n\t}\n\tif (mode->hdisplay < KMB_CRTC_MAX_WIDTH) {\n\t\tdrm_dbg(dev, \"width = %d less than %d\",\n\t\t\tmode->hdisplay, KMB_CRTC_MAX_WIDTH);\n\t\treturn MODE_BAD_HVALUE;\n\t}\n\trefresh = drm_mode_vrefresh(mode);\n\tif (refresh < KMB_MIN_VREFRESH || refresh > KMB_MAX_VREFRESH) {\n\t\tdrm_dbg(dev, \"refresh = %d less than %d or greater than %d\",\n\t\t\trefresh, KMB_MIN_VREFRESH, KMB_MAX_VREFRESH);\n\t\treturn MODE_BAD;\n\t}\n\n\tif (vfp < KMB_CRTC_MIN_VFP) {\n\t\tdrm_dbg(dev, \"vfp = %d less than %d\", vfp, KMB_CRTC_MIN_VFP);\n\t\treturn MODE_BAD;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_crtc_helper_funcs kmb_crtc_helper_funcs = {\n\t.atomic_begin = kmb_crtc_atomic_begin,\n\t.atomic_enable = kmb_crtc_atomic_enable,\n\t.atomic_disable = kmb_crtc_atomic_disable,\n\t.atomic_flush = kmb_crtc_atomic_flush,\n\t.mode_valid = kmb_crtc_mode_valid,\n};\n\nint kmb_setup_crtc(struct drm_device *drm)\n{\n\tstruct kmb_drm_private *kmb = to_kmb(drm);\n\tstruct kmb_plane *primary;\n\tint ret;\n\n\tprimary = kmb_plane_init(drm);\n\tif (IS_ERR(primary))\n\t\treturn PTR_ERR(primary);\n\n\tret = drm_crtc_init_with_planes(drm, &kmb->crtc, &primary->base_plane,\n\t\t\t\t\tNULL, &kmb_crtc_funcs, NULL);\n\tif (ret) {\n\t\tkmb_plane_destroy(&primary->base_plane);\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_helper_add(&kmb->crtc, &kmb_crtc_helper_funcs);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}