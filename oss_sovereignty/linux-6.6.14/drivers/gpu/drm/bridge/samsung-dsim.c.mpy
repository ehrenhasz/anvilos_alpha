{
  "module_name": "samsung-dsim.c",
  "hash_id": "bfdede31b0cefd49dd94f48f686eaf27d10afc173223f19cf4c2d1e1d9593e3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/samsung-dsim.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/media-bus-format.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/bridge/samsung-dsim.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n\n \n#define NEQV(a, b) (!(a) ^ !(b))\n\n \n#define DSIM_STOP_STATE_DAT(x)\t\t(((x) & 0xf) << 0)\n#define DSIM_STOP_STATE_CLK\t\tBIT(8)\n#define DSIM_TX_READY_HS_CLK\t\tBIT(10)\n#define DSIM_PLL_STABLE\t\t\tBIT(31)\n\n \n#define DSIM_FUNCRST\t\t\tBIT(16)\n#define DSIM_SWRST\t\t\tBIT(0)\n\n \n#define DSIM_LPDR_TIMEOUT(x)\t\t((x) << 0)\n#define DSIM_BTA_TIMEOUT(x)\t\t((x) << 16)\n\n \n#define DSIM_ESC_PRESCALER(x)\t\t(((x) & 0xffff) << 0)\n#define DSIM_ESC_PRESCALER_MASK\t\t(0xffff << 0)\n#define DSIM_LANE_ESC_CLK_EN_CLK\tBIT(19)\n#define DSIM_LANE_ESC_CLK_EN_DATA(x)\t(((x) & 0xf) << 20)\n#define DSIM_LANE_ESC_CLK_EN_DATA_MASK\t(0xf << 20)\n#define DSIM_BYTE_CLKEN\t\t\tBIT(24)\n#define DSIM_BYTE_CLK_SRC(x)\t\t(((x) & 0x3) << 25)\n#define DSIM_BYTE_CLK_SRC_MASK\t\t(0x3 << 25)\n#define DSIM_PLL_BYPASS\t\t\tBIT(27)\n#define DSIM_ESC_CLKEN\t\t\tBIT(28)\n#define DSIM_TX_REQUEST_HSCLK\t\tBIT(31)\n\n \n#define DSIM_LANE_EN_CLK\t\tBIT(0)\n#define DSIM_LANE_EN(x)\t\t\t(((x) & 0xf) << 1)\n#define DSIM_NUM_OF_DATA_LANE(x)\t(((x) & 0x3) << 5)\n#define DSIM_SUB_PIX_FORMAT(x)\t\t(((x) & 0x7) << 8)\n#define DSIM_MAIN_PIX_FORMAT_MASK\t(0x7 << 12)\n#define DSIM_MAIN_PIX_FORMAT_RGB888\t(0x7 << 12)\n#define DSIM_MAIN_PIX_FORMAT_RGB666\t(0x6 << 12)\n#define DSIM_MAIN_PIX_FORMAT_RGB666_P\t(0x5 << 12)\n#define DSIM_MAIN_PIX_FORMAT_RGB565\t(0x4 << 12)\n#define DSIM_SUB_VC\t\t\t(((x) & 0x3) << 16)\n#define DSIM_MAIN_VC\t\t\t(((x) & 0x3) << 18)\n#define DSIM_HSA_DISABLE_MODE\t\tBIT(20)\n#define DSIM_HBP_DISABLE_MODE\t\tBIT(21)\n#define DSIM_HFP_DISABLE_MODE\t\tBIT(22)\n \n#define DSIM_HSE_DISABLE_MODE\t\tBIT(23)\n#define DSIM_AUTO_MODE\t\t\tBIT(24)\n#define DSIM_VIDEO_MODE\t\t\tBIT(25)\n#define DSIM_BURST_MODE\t\t\tBIT(26)\n#define DSIM_SYNC_INFORM\t\tBIT(27)\n#define DSIM_EOT_DISABLE\t\tBIT(28)\n#define DSIM_MFLUSH_VS\t\t\tBIT(29)\n \n#define DSIM_CLKLANE_STOP\t\tBIT(30)\n\n \n#define DSIM_TX_TRIGGER_RST\t\tBIT(4)\n#define DSIM_TX_LPDT_LP\t\t\tBIT(6)\n#define DSIM_CMD_LPDT_LP\t\tBIT(7)\n#define DSIM_FORCE_BTA\t\t\tBIT(16)\n#define DSIM_FORCE_STOP_STATE\t\tBIT(20)\n#define DSIM_STOP_STATE_CNT(x)\t\t(((x) & 0x7ff) << 21)\n#define DSIM_STOP_STATE_CNT_MASK\t(0x7ff << 21)\n\n \n#define DSIM_MAIN_STAND_BY\t\tBIT(31)\n#define DSIM_MAIN_VRESOL(x, num_bits)\t(((x) & ((1 << (num_bits)) - 1)) << 16)\n#define DSIM_MAIN_HRESOL(x, num_bits)\t(((x) & ((1 << (num_bits)) - 1)) << 0)\n\n \n#define DSIM_CMD_ALLOW(x)\t\t((x) << 28)\n#define DSIM_STABLE_VFP(x)\t\t((x) << 16)\n#define DSIM_MAIN_VBP(x)\t\t((x) << 0)\n#define DSIM_CMD_ALLOW_MASK\t\t(0xf << 28)\n#define DSIM_STABLE_VFP_MASK\t\t(0x7ff << 16)\n#define DSIM_MAIN_VBP_MASK\t\t(0x7ff << 0)\n\n \n#define DSIM_MAIN_HFP(x)\t\t((x) << 16)\n#define DSIM_MAIN_HBP(x)\t\t((x) << 0)\n#define DSIM_MAIN_HFP_MASK\t\t((0xffff) << 16)\n#define DSIM_MAIN_HBP_MASK\t\t((0xffff) << 0)\n\n \n#define DSIM_MAIN_VSA(x)\t\t((x) << 22)\n#define DSIM_MAIN_HSA(x)\t\t((x) << 0)\n#define DSIM_MAIN_VSA_MASK\t\t((0x3ff) << 22)\n#define DSIM_MAIN_HSA_MASK\t\t((0xffff) << 0)\n\n \n#define DSIM_SUB_STANDY(x)\t\t((x) << 31)\n#define DSIM_SUB_VRESOL(x)\t\t((x) << 16)\n#define DSIM_SUB_HRESOL(x)\t\t((x) << 0)\n#define DSIM_SUB_STANDY_MASK\t\t((0x1) << 31)\n#define DSIM_SUB_VRESOL_MASK\t\t((0x7ff) << 16)\n#define DSIM_SUB_HRESOL_MASK\t\t((0x7ff) << 0)\n\n \n#define DSIM_INT_PLL_STABLE\t\tBIT(31)\n#define DSIM_INT_SW_RST_RELEASE\t\tBIT(30)\n#define DSIM_INT_SFR_FIFO_EMPTY\t\tBIT(29)\n#define DSIM_INT_SFR_HDR_FIFO_EMPTY\tBIT(28)\n#define DSIM_INT_BTA\t\t\tBIT(25)\n#define DSIM_INT_FRAME_DONE\t\tBIT(24)\n#define DSIM_INT_RX_TIMEOUT\t\tBIT(21)\n#define DSIM_INT_BTA_TIMEOUT\t\tBIT(20)\n#define DSIM_INT_RX_DONE\t\tBIT(18)\n#define DSIM_INT_RX_TE\t\t\tBIT(17)\n#define DSIM_INT_RX_ACK\t\t\tBIT(16)\n#define DSIM_INT_RX_ECC_ERR\t\tBIT(15)\n#define DSIM_INT_RX_CRC_ERR\t\tBIT(14)\n\n \n#define DSIM_RX_DATA_FULL\t\tBIT(25)\n#define DSIM_RX_DATA_EMPTY\t\tBIT(24)\n#define DSIM_SFR_HEADER_FULL\t\tBIT(23)\n#define DSIM_SFR_HEADER_EMPTY\t\tBIT(22)\n#define DSIM_SFR_PAYLOAD_FULL\t\tBIT(21)\n#define DSIM_SFR_PAYLOAD_EMPTY\t\tBIT(20)\n#define DSIM_I80_HEADER_FULL\t\tBIT(19)\n#define DSIM_I80_HEADER_EMPTY\t\tBIT(18)\n#define DSIM_I80_PAYLOAD_FULL\t\tBIT(17)\n#define DSIM_I80_PAYLOAD_EMPTY\t\tBIT(16)\n#define DSIM_SD_HEADER_FULL\t\tBIT(15)\n#define DSIM_SD_HEADER_EMPTY\t\tBIT(14)\n#define DSIM_SD_PAYLOAD_FULL\t\tBIT(13)\n#define DSIM_SD_PAYLOAD_EMPTY\t\tBIT(12)\n#define DSIM_MD_HEADER_FULL\t\tBIT(11)\n#define DSIM_MD_HEADER_EMPTY\t\tBIT(10)\n#define DSIM_MD_PAYLOAD_FULL\t\tBIT(9)\n#define DSIM_MD_PAYLOAD_EMPTY\t\tBIT(8)\n#define DSIM_RX_FIFO\t\t\tBIT(4)\n#define DSIM_SFR_FIFO\t\t\tBIT(3)\n#define DSIM_I80_FIFO\t\t\tBIT(2)\n#define DSIM_SD_FIFO\t\t\tBIT(1)\n#define DSIM_MD_FIFO\t\t\tBIT(0)\n\n \n#define DSIM_AFC_EN\t\t\tBIT(14)\n#define DSIM_AFC_CTL(x)\t\t\t(((x) & 0x7) << 5)\n\n \n#define DSIM_PLL_DPDNSWAP_CLK\t\t(1 << 25)\n#define DSIM_PLL_DPDNSWAP_DAT\t\t(1 << 24)\n#define DSIM_FREQ_BAND(x)\t\t((x) << 24)\n#define DSIM_PLL_EN\t\t\tBIT(23)\n#define DSIM_PLL_P(x, offset)\t\t((x) << (offset))\n#define DSIM_PLL_M(x)\t\t\t((x) << 4)\n#define DSIM_PLL_S(x)\t\t\t((x) << 1)\n\n \n#define DSIM_PHYCTRL_ULPS_EXIT(x)\t(((x) & 0x1ff) << 0)\n#define DSIM_PHYCTRL_B_DPHYCTL_VREG_LP\tBIT(30)\n#define DSIM_PHYCTRL_B_DPHYCTL_SLEW_UP\tBIT(14)\n\n \n#define DSIM_PHYTIMING_LPX(x)\t\t((x) << 8)\n#define DSIM_PHYTIMING_HS_EXIT(x)\t((x) << 0)\n\n \n#define DSIM_PHYTIMING1_CLK_PREPARE(x)\t((x) << 24)\n#define DSIM_PHYTIMING1_CLK_ZERO(x)\t((x) << 16)\n#define DSIM_PHYTIMING1_CLK_POST(x)\t((x) << 8)\n#define DSIM_PHYTIMING1_CLK_TRAIL(x)\t((x) << 0)\n\n \n#define DSIM_PHYTIMING2_HS_PREPARE(x)\t((x) << 16)\n#define DSIM_PHYTIMING2_HS_ZERO(x)\t((x) << 8)\n#define DSIM_PHYTIMING2_HS_TRAIL(x)\t((x) << 0)\n\n#define DSI_MAX_BUS_WIDTH\t\t4\n#define DSI_NUM_VIRTUAL_CHANNELS\t4\n#define DSI_TX_FIFO_SIZE\t\t2048\n#define DSI_RX_FIFO_SIZE\t\t256\n#define DSI_XFER_TIMEOUT_MS\t\t100\n#define DSI_RX_FIFO_EMPTY\t\t0x30800002\n\n#define OLD_SCLK_MIPI_CLK_NAME\t\t\"pll_clk\"\n\n#define PS_TO_CYCLE(ps, hz) DIV64_U64_ROUND_CLOSEST(((ps) * (hz)), 1000000000000ULL)\n\nstatic const char *const clk_names[5] = {\n\t\"bus_clk\",\n\t\"sclk_mipi\",\n\t\"phyclk_mipidphy0_bitclkdiv8\",\n\t\"phyclk_mipidphy0_rxclkesc0\",\n\t\"sclk_rgb_vclk_to_dsim0\"\n};\n\nenum samsung_dsim_transfer_type {\n\tEXYNOS_DSI_TX,\n\tEXYNOS_DSI_RX,\n};\n\nenum reg_idx {\n\tDSIM_STATUS_REG,\t \n\tDSIM_SWRST_REG,\t\t \n\tDSIM_CLKCTRL_REG,\t \n\tDSIM_TIMEOUT_REG,\t \n\tDSIM_CONFIG_REG,\t \n\tDSIM_ESCMODE_REG,\t \n\tDSIM_MDRESOL_REG,\n\tDSIM_MVPORCH_REG,\t \n\tDSIM_MHPORCH_REG,\t \n\tDSIM_MSYNC_REG,\t\t \n\tDSIM_INTSRC_REG,\t \n\tDSIM_INTMSK_REG,\t \n\tDSIM_PKTHDR_REG,\t \n\tDSIM_PAYLOAD_REG,\t \n\tDSIM_RXFIFO_REG,\t \n\tDSIM_FIFOCTRL_REG,\t \n\tDSIM_PLLCTRL_REG,\t \n\tDSIM_PHYCTRL_REG,\n\tDSIM_PHYTIMING_REG,\n\tDSIM_PHYTIMING1_REG,\n\tDSIM_PHYTIMING2_REG,\n\tNUM_REGS\n};\n\nstatic const unsigned int exynos_reg_ofs[] = {\n\t[DSIM_STATUS_REG] =  0x00,\n\t[DSIM_SWRST_REG] =  0x04,\n\t[DSIM_CLKCTRL_REG] =  0x08,\n\t[DSIM_TIMEOUT_REG] =  0x0c,\n\t[DSIM_CONFIG_REG] =  0x10,\n\t[DSIM_ESCMODE_REG] =  0x14,\n\t[DSIM_MDRESOL_REG] =  0x18,\n\t[DSIM_MVPORCH_REG] =  0x1c,\n\t[DSIM_MHPORCH_REG] =  0x20,\n\t[DSIM_MSYNC_REG] =  0x24,\n\t[DSIM_INTSRC_REG] =  0x2c,\n\t[DSIM_INTMSK_REG] =  0x30,\n\t[DSIM_PKTHDR_REG] =  0x34,\n\t[DSIM_PAYLOAD_REG] =  0x38,\n\t[DSIM_RXFIFO_REG] =  0x3c,\n\t[DSIM_FIFOCTRL_REG] =  0x44,\n\t[DSIM_PLLCTRL_REG] =  0x4c,\n\t[DSIM_PHYCTRL_REG] =  0x5c,\n\t[DSIM_PHYTIMING_REG] =  0x64,\n\t[DSIM_PHYTIMING1_REG] =  0x68,\n\t[DSIM_PHYTIMING2_REG] =  0x6c,\n};\n\nstatic const unsigned int exynos5433_reg_ofs[] = {\n\t[DSIM_STATUS_REG] = 0x04,\n\t[DSIM_SWRST_REG] = 0x0C,\n\t[DSIM_CLKCTRL_REG] = 0x10,\n\t[DSIM_TIMEOUT_REG] = 0x14,\n\t[DSIM_CONFIG_REG] = 0x18,\n\t[DSIM_ESCMODE_REG] = 0x1C,\n\t[DSIM_MDRESOL_REG] = 0x20,\n\t[DSIM_MVPORCH_REG] = 0x24,\n\t[DSIM_MHPORCH_REG] = 0x28,\n\t[DSIM_MSYNC_REG] = 0x2C,\n\t[DSIM_INTSRC_REG] = 0x34,\n\t[DSIM_INTMSK_REG] = 0x38,\n\t[DSIM_PKTHDR_REG] = 0x3C,\n\t[DSIM_PAYLOAD_REG] = 0x40,\n\t[DSIM_RXFIFO_REG] = 0x44,\n\t[DSIM_FIFOCTRL_REG] = 0x4C,\n\t[DSIM_PLLCTRL_REG] = 0x94,\n\t[DSIM_PHYCTRL_REG] = 0xA4,\n\t[DSIM_PHYTIMING_REG] = 0xB4,\n\t[DSIM_PHYTIMING1_REG] = 0xB8,\n\t[DSIM_PHYTIMING2_REG] = 0xBC,\n};\n\nenum reg_value_idx {\n\tRESET_TYPE,\n\tPLL_TIMER,\n\tSTOP_STATE_CNT,\n\tPHYCTRL_ULPS_EXIT,\n\tPHYCTRL_VREG_LP,\n\tPHYCTRL_SLEW_UP,\n\tPHYTIMING_LPX,\n\tPHYTIMING_HS_EXIT,\n\tPHYTIMING_CLK_PREPARE,\n\tPHYTIMING_CLK_ZERO,\n\tPHYTIMING_CLK_POST,\n\tPHYTIMING_CLK_TRAIL,\n\tPHYTIMING_HS_PREPARE,\n\tPHYTIMING_HS_ZERO,\n\tPHYTIMING_HS_TRAIL\n};\n\nstatic const unsigned int reg_values[] = {\n\t[RESET_TYPE] = DSIM_SWRST,\n\t[PLL_TIMER] = 500,\n\t[STOP_STATE_CNT] = 0xf,\n\t[PHYCTRL_ULPS_EXIT] = DSIM_PHYCTRL_ULPS_EXIT(0x0af),\n\t[PHYCTRL_VREG_LP] = 0,\n\t[PHYCTRL_SLEW_UP] = 0,\n\t[PHYTIMING_LPX] = DSIM_PHYTIMING_LPX(0x06),\n\t[PHYTIMING_HS_EXIT] = DSIM_PHYTIMING_HS_EXIT(0x0b),\n\t[PHYTIMING_CLK_PREPARE] = DSIM_PHYTIMING1_CLK_PREPARE(0x07),\n\t[PHYTIMING_CLK_ZERO] = DSIM_PHYTIMING1_CLK_ZERO(0x27),\n\t[PHYTIMING_CLK_POST] = DSIM_PHYTIMING1_CLK_POST(0x0d),\n\t[PHYTIMING_CLK_TRAIL] = DSIM_PHYTIMING1_CLK_TRAIL(0x08),\n\t[PHYTIMING_HS_PREPARE] = DSIM_PHYTIMING2_HS_PREPARE(0x09),\n\t[PHYTIMING_HS_ZERO] = DSIM_PHYTIMING2_HS_ZERO(0x0d),\n\t[PHYTIMING_HS_TRAIL] = DSIM_PHYTIMING2_HS_TRAIL(0x0b),\n};\n\nstatic const unsigned int exynos5422_reg_values[] = {\n\t[RESET_TYPE] = DSIM_SWRST,\n\t[PLL_TIMER] = 500,\n\t[STOP_STATE_CNT] = 0xf,\n\t[PHYCTRL_ULPS_EXIT] = DSIM_PHYCTRL_ULPS_EXIT(0xaf),\n\t[PHYCTRL_VREG_LP] = 0,\n\t[PHYCTRL_SLEW_UP] = 0,\n\t[PHYTIMING_LPX] = DSIM_PHYTIMING_LPX(0x08),\n\t[PHYTIMING_HS_EXIT] = DSIM_PHYTIMING_HS_EXIT(0x0d),\n\t[PHYTIMING_CLK_PREPARE] = DSIM_PHYTIMING1_CLK_PREPARE(0x09),\n\t[PHYTIMING_CLK_ZERO] = DSIM_PHYTIMING1_CLK_ZERO(0x30),\n\t[PHYTIMING_CLK_POST] = DSIM_PHYTIMING1_CLK_POST(0x0e),\n\t[PHYTIMING_CLK_TRAIL] = DSIM_PHYTIMING1_CLK_TRAIL(0x0a),\n\t[PHYTIMING_HS_PREPARE] = DSIM_PHYTIMING2_HS_PREPARE(0x0c),\n\t[PHYTIMING_HS_ZERO] = DSIM_PHYTIMING2_HS_ZERO(0x11),\n\t[PHYTIMING_HS_TRAIL] = DSIM_PHYTIMING2_HS_TRAIL(0x0d),\n};\n\nstatic const unsigned int exynos5433_reg_values[] = {\n\t[RESET_TYPE] = DSIM_FUNCRST,\n\t[PLL_TIMER] = 22200,\n\t[STOP_STATE_CNT] = 0xa,\n\t[PHYCTRL_ULPS_EXIT] = DSIM_PHYCTRL_ULPS_EXIT(0x190),\n\t[PHYCTRL_VREG_LP] = DSIM_PHYCTRL_B_DPHYCTL_VREG_LP,\n\t[PHYCTRL_SLEW_UP] = DSIM_PHYCTRL_B_DPHYCTL_SLEW_UP,\n\t[PHYTIMING_LPX] = DSIM_PHYTIMING_LPX(0x07),\n\t[PHYTIMING_HS_EXIT] = DSIM_PHYTIMING_HS_EXIT(0x0c),\n\t[PHYTIMING_CLK_PREPARE] = DSIM_PHYTIMING1_CLK_PREPARE(0x09),\n\t[PHYTIMING_CLK_ZERO] = DSIM_PHYTIMING1_CLK_ZERO(0x2d),\n\t[PHYTIMING_CLK_POST] = DSIM_PHYTIMING1_CLK_POST(0x0e),\n\t[PHYTIMING_CLK_TRAIL] = DSIM_PHYTIMING1_CLK_TRAIL(0x09),\n\t[PHYTIMING_HS_PREPARE] = DSIM_PHYTIMING2_HS_PREPARE(0x0b),\n\t[PHYTIMING_HS_ZERO] = DSIM_PHYTIMING2_HS_ZERO(0x10),\n\t[PHYTIMING_HS_TRAIL] = DSIM_PHYTIMING2_HS_TRAIL(0x0c),\n};\n\nstatic const unsigned int imx8mm_dsim_reg_values[] = {\n\t[RESET_TYPE] = DSIM_SWRST,\n\t[PLL_TIMER] = 500,\n\t[STOP_STATE_CNT] = 0xf,\n\t[PHYCTRL_ULPS_EXIT] = DSIM_PHYCTRL_ULPS_EXIT(0xaf),\n\t[PHYCTRL_VREG_LP] = 0,\n\t[PHYCTRL_SLEW_UP] = 0,\n\t[PHYTIMING_LPX] = DSIM_PHYTIMING_LPX(0x06),\n\t[PHYTIMING_HS_EXIT] = DSIM_PHYTIMING_HS_EXIT(0x0b),\n\t[PHYTIMING_CLK_PREPARE] = DSIM_PHYTIMING1_CLK_PREPARE(0x07),\n\t[PHYTIMING_CLK_ZERO] = DSIM_PHYTIMING1_CLK_ZERO(0x26),\n\t[PHYTIMING_CLK_POST] = DSIM_PHYTIMING1_CLK_POST(0x0d),\n\t[PHYTIMING_CLK_TRAIL] = DSIM_PHYTIMING1_CLK_TRAIL(0x08),\n\t[PHYTIMING_HS_PREPARE] = DSIM_PHYTIMING2_HS_PREPARE(0x08),\n\t[PHYTIMING_HS_ZERO] = DSIM_PHYTIMING2_HS_ZERO(0x0d),\n\t[PHYTIMING_HS_TRAIL] = DSIM_PHYTIMING2_HS_TRAIL(0x0b),\n};\n\nstatic const struct samsung_dsim_driver_data exynos3_dsi_driver_data = {\n\t.reg_ofs = exynos_reg_ofs,\n\t.plltmr_reg = 0x50,\n\t.has_freqband = 1,\n\t.has_clklane_stop = 1,\n\t.num_clks = 2,\n\t.max_freq = 1000,\n\t.wait_for_reset = 1,\n\t.num_bits_resol = 11,\n\t.pll_p_offset = 13,\n\t.reg_values = reg_values,\n\t.m_min = 41,\n\t.m_max = 125,\n\t.min_freq = 500,\n\t.has_broken_fifoctrl_emptyhdr = 1,\n};\n\nstatic const struct samsung_dsim_driver_data exynos4_dsi_driver_data = {\n\t.reg_ofs = exynos_reg_ofs,\n\t.plltmr_reg = 0x50,\n\t.has_freqband = 1,\n\t.has_clklane_stop = 1,\n\t.num_clks = 2,\n\t.max_freq = 1000,\n\t.wait_for_reset = 1,\n\t.num_bits_resol = 11,\n\t.pll_p_offset = 13,\n\t.reg_values = reg_values,\n\t.m_min = 41,\n\t.m_max = 125,\n\t.min_freq = 500,\n\t.has_broken_fifoctrl_emptyhdr = 1,\n};\n\nstatic const struct samsung_dsim_driver_data exynos5_dsi_driver_data = {\n\t.reg_ofs = exynos_reg_ofs,\n\t.plltmr_reg = 0x58,\n\t.num_clks = 2,\n\t.max_freq = 1000,\n\t.wait_for_reset = 1,\n\t.num_bits_resol = 11,\n\t.pll_p_offset = 13,\n\t.reg_values = reg_values,\n\t.m_min = 41,\n\t.m_max = 125,\n\t.min_freq = 500,\n};\n\nstatic const struct samsung_dsim_driver_data exynos5433_dsi_driver_data = {\n\t.reg_ofs = exynos5433_reg_ofs,\n\t.plltmr_reg = 0xa0,\n\t.has_clklane_stop = 1,\n\t.num_clks = 5,\n\t.max_freq = 1500,\n\t.wait_for_reset = 0,\n\t.num_bits_resol = 12,\n\t.pll_p_offset = 13,\n\t.reg_values = exynos5433_reg_values,\n\t.m_min = 41,\n\t.m_max = 125,\n\t.min_freq = 500,\n};\n\nstatic const struct samsung_dsim_driver_data exynos5422_dsi_driver_data = {\n\t.reg_ofs = exynos5433_reg_ofs,\n\t.plltmr_reg = 0xa0,\n\t.has_clklane_stop = 1,\n\t.num_clks = 2,\n\t.max_freq = 1500,\n\t.wait_for_reset = 1,\n\t.num_bits_resol = 12,\n\t.pll_p_offset = 13,\n\t.reg_values = exynos5422_reg_values,\n\t.m_min = 41,\n\t.m_max = 125,\n\t.min_freq = 500,\n};\n\nstatic const struct samsung_dsim_driver_data imx8mm_dsi_driver_data = {\n\t.reg_ofs = exynos5433_reg_ofs,\n\t.plltmr_reg = 0xa0,\n\t.has_clklane_stop = 1,\n\t.num_clks = 2,\n\t.max_freq = 2100,\n\t.wait_for_reset = 0,\n\t.num_bits_resol = 12,\n\t \n\t.pll_p_offset = 14,\n\t.reg_values = imx8mm_dsim_reg_values,\n\t.m_min = 64,\n\t.m_max = 1023,\n\t.min_freq = 1050,\n};\n\nstatic const struct samsung_dsim_driver_data *\nsamsung_dsim_types[DSIM_TYPE_COUNT] = {\n\t[DSIM_TYPE_EXYNOS3250] = &exynos3_dsi_driver_data,\n\t[DSIM_TYPE_EXYNOS4210] = &exynos4_dsi_driver_data,\n\t[DSIM_TYPE_EXYNOS5410] = &exynos5_dsi_driver_data,\n\t[DSIM_TYPE_EXYNOS5422] = &exynos5422_dsi_driver_data,\n\t[DSIM_TYPE_EXYNOS5433] = &exynos5433_dsi_driver_data,\n\t[DSIM_TYPE_IMX8MM] = &imx8mm_dsi_driver_data,\n\t[DSIM_TYPE_IMX8MP] = &imx8mm_dsi_driver_data,\n};\n\nstatic inline struct samsung_dsim *host_to_dsi(struct mipi_dsi_host *h)\n{\n\treturn container_of(h, struct samsung_dsim, dsi_host);\n}\n\nstatic inline struct samsung_dsim *bridge_to_dsi(struct drm_bridge *b)\n{\n\treturn container_of(b, struct samsung_dsim, bridge);\n}\n\nstatic inline void samsung_dsim_write(struct samsung_dsim *dsi,\n\t\t\t\t      enum reg_idx idx, u32 val)\n{\n\twritel(val, dsi->reg_base + dsi->driver_data->reg_ofs[idx]);\n}\n\nstatic inline u32 samsung_dsim_read(struct samsung_dsim *dsi, enum reg_idx idx)\n{\n\treturn readl(dsi->reg_base + dsi->driver_data->reg_ofs[idx]);\n}\n\nstatic void samsung_dsim_wait_for_reset(struct samsung_dsim *dsi)\n{\n\tif (wait_for_completion_timeout(&dsi->completed, msecs_to_jiffies(300)))\n\t\treturn;\n\n\tdev_err(dsi->dev, \"timeout waiting for reset\\n\");\n}\n\nstatic void samsung_dsim_reset(struct samsung_dsim *dsi)\n{\n\tu32 reset_val = dsi->driver_data->reg_values[RESET_TYPE];\n\n\treinit_completion(&dsi->completed);\n\tsamsung_dsim_write(dsi, DSIM_SWRST_REG, reset_val);\n}\n\n#ifndef MHZ\n#define MHZ\t(1000 * 1000)\n#endif\n\nstatic unsigned long samsung_dsim_pll_find_pms(struct samsung_dsim *dsi,\n\t\t\t\t\t       unsigned long fin,\n\t\t\t\t\t       unsigned long fout,\n\t\t\t\t\t       u8 *p, u16 *m, u8 *s)\n{\n\tconst struct samsung_dsim_driver_data *driver_data = dsi->driver_data;\n\tunsigned long best_freq = 0;\n\tu32 min_delta = 0xffffffff;\n\tu8 p_min, p_max;\n\tu8 _p, best_p;\n\tu16 _m, best_m;\n\tu8 _s, best_s;\n\n\tp_min = DIV_ROUND_UP(fin, (12 * MHZ));\n\tp_max = fin / (6 * MHZ);\n\n\tfor (_p = p_min; _p <= p_max; ++_p) {\n\t\tfor (_s = 0; _s <= 5; ++_s) {\n\t\t\tu64 tmp;\n\t\t\tu32 delta;\n\n\t\t\ttmp = (u64)fout * (_p << _s);\n\t\t\tdo_div(tmp, fin);\n\t\t\t_m = tmp;\n\t\t\tif (_m < driver_data->m_min || _m > driver_data->m_max)\n\t\t\t\tcontinue;\n\n\t\t\ttmp = (u64)_m * fin;\n\t\t\tdo_div(tmp, _p);\n\t\t\tif (tmp < driver_data->min_freq  * MHZ ||\n\t\t\t    tmp > driver_data->max_freq * MHZ)\n\t\t\t\tcontinue;\n\n\t\t\ttmp = (u64)_m * fin;\n\t\t\tdo_div(tmp, _p << _s);\n\n\t\t\tdelta = abs(fout - tmp);\n\t\t\tif (delta < min_delta) {\n\t\t\t\tbest_p = _p;\n\t\t\t\tbest_m = _m;\n\t\t\t\tbest_s = _s;\n\t\t\t\tmin_delta = delta;\n\t\t\t\tbest_freq = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (best_freq) {\n\t\t*p = best_p;\n\t\t*m = best_m;\n\t\t*s = best_s;\n\t}\n\n\treturn best_freq;\n}\n\nstatic unsigned long samsung_dsim_set_pll(struct samsung_dsim *dsi,\n\t\t\t\t\t  unsigned long freq)\n{\n\tconst struct samsung_dsim_driver_data *driver_data = dsi->driver_data;\n\tunsigned long fin, fout;\n\tint timeout;\n\tu8 p, s;\n\tu16 m;\n\tu32 reg;\n\n\tfin = dsi->pll_clk_rate;\n\tfout = samsung_dsim_pll_find_pms(dsi, fin, freq, &p, &m, &s);\n\tif (!fout) {\n\t\tdev_err(dsi->dev,\n\t\t\t\"failed to find PLL PMS for requested frequency\\n\");\n\t\treturn 0;\n\t}\n\tdev_dbg(dsi->dev, \"PLL freq %lu, (p %d, m %d, s %d)\\n\", fout, p, m, s);\n\n\twritel(driver_data->reg_values[PLL_TIMER],\n\t       dsi->reg_base + driver_data->plltmr_reg);\n\n\treg = DSIM_PLL_EN | DSIM_PLL_P(p, driver_data->pll_p_offset) |\n\t      DSIM_PLL_M(m) | DSIM_PLL_S(s);\n\n\tif (driver_data->has_freqband) {\n\t\tstatic const unsigned long freq_bands[] = {\n\t\t\t100 * MHZ, 120 * MHZ, 160 * MHZ, 200 * MHZ,\n\t\t\t270 * MHZ, 320 * MHZ, 390 * MHZ, 450 * MHZ,\n\t\t\t510 * MHZ, 560 * MHZ, 640 * MHZ, 690 * MHZ,\n\t\t\t770 * MHZ, 870 * MHZ, 950 * MHZ,\n\t\t};\n\t\tint band;\n\n\t\tfor (band = 0; band < ARRAY_SIZE(freq_bands); ++band)\n\t\t\tif (fout < freq_bands[band])\n\t\t\t\tbreak;\n\n\t\tdev_dbg(dsi->dev, \"band %d\\n\", band);\n\n\t\treg |= DSIM_FREQ_BAND(band);\n\t}\n\n\tif (dsi->swap_dn_dp_clk)\n\t\treg |= DSIM_PLL_DPDNSWAP_CLK;\n\tif (dsi->swap_dn_dp_data)\n\t\treg |= DSIM_PLL_DPDNSWAP_DAT;\n\n\tsamsung_dsim_write(dsi, DSIM_PLLCTRL_REG, reg);\n\n\ttimeout = 1000;\n\tdo {\n\t\tif (timeout-- == 0) {\n\t\t\tdev_err(dsi->dev, \"PLL failed to stabilize\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treg = samsung_dsim_read(dsi, DSIM_STATUS_REG);\n\t} while ((reg & DSIM_PLL_STABLE) == 0);\n\n\tdsi->hs_clock = fout;\n\n\treturn fout;\n}\n\nstatic int samsung_dsim_enable_clock(struct samsung_dsim *dsi)\n{\n\tunsigned long hs_clk, byte_clk, esc_clk, pix_clk;\n\tunsigned long esc_div;\n\tu32 reg;\n\tstruct drm_display_mode *m = &dsi->mode;\n\tint bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);\n\n\t \n\tpix_clk = m->clock * 1000;\n\n\t \n\tif (dsi->burst_clk_rate)\n\t\ths_clk = samsung_dsim_set_pll(dsi, dsi->burst_clk_rate);\n\telse\n\t\ths_clk = samsung_dsim_set_pll(dsi, DIV_ROUND_UP(pix_clk * bpp, dsi->lanes));\n\n\tif (!hs_clk) {\n\t\tdev_err(dsi->dev, \"failed to configure DSI PLL\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tbyte_clk = hs_clk / 8;\n\tesc_div = DIV_ROUND_UP(byte_clk, dsi->esc_clk_rate);\n\tesc_clk = byte_clk / esc_div;\n\n\tif (esc_clk > 20 * MHZ) {\n\t\t++esc_div;\n\t\tesc_clk = byte_clk / esc_div;\n\t}\n\n\tdev_dbg(dsi->dev, \"hs_clk = %lu, byte_clk = %lu, esc_clk = %lu\\n\",\n\t\ths_clk, byte_clk, esc_clk);\n\n\treg = samsung_dsim_read(dsi, DSIM_CLKCTRL_REG);\n\treg &= ~(DSIM_ESC_PRESCALER_MASK | DSIM_LANE_ESC_CLK_EN_CLK\n\t\t\t| DSIM_LANE_ESC_CLK_EN_DATA_MASK | DSIM_PLL_BYPASS\n\t\t\t| DSIM_BYTE_CLK_SRC_MASK);\n\treg |= DSIM_ESC_CLKEN | DSIM_BYTE_CLKEN\n\t\t\t| DSIM_ESC_PRESCALER(esc_div)\n\t\t\t| DSIM_LANE_ESC_CLK_EN_CLK\n\t\t\t| DSIM_LANE_ESC_CLK_EN_DATA(BIT(dsi->lanes) - 1)\n\t\t\t| DSIM_BYTE_CLK_SRC(0)\n\t\t\t| DSIM_TX_REQUEST_HSCLK;\n\tsamsung_dsim_write(dsi, DSIM_CLKCTRL_REG, reg);\n\n\treturn 0;\n}\n\nstatic void samsung_dsim_set_phy_ctrl(struct samsung_dsim *dsi)\n{\n\tconst struct samsung_dsim_driver_data *driver_data = dsi->driver_data;\n\tconst unsigned int *reg_values = driver_data->reg_values;\n\tu32 reg;\n\tstruct phy_configure_opts_mipi_dphy cfg;\n\tint clk_prepare, lpx, clk_zero, clk_post, clk_trail;\n\tint hs_exit, hs_prepare, hs_zero, hs_trail;\n\tunsigned long long byte_clock = dsi->hs_clock / 8;\n\n\tif (driver_data->has_freqband)\n\t\treturn;\n\n\tphy_mipi_dphy_get_default_config_for_hsclk(dsi->hs_clock,\n\t\t\t\t\t\t   dsi->lanes, &cfg);\n\n\t \n\n\tlpx = PS_TO_CYCLE(cfg.lpx, byte_clock);\n\ths_exit = PS_TO_CYCLE(cfg.hs_exit, byte_clock);\n\tclk_prepare = PS_TO_CYCLE(cfg.clk_prepare, byte_clock);\n\tclk_zero = PS_TO_CYCLE(cfg.clk_zero, byte_clock);\n\tclk_post = PS_TO_CYCLE(cfg.clk_post, byte_clock);\n\tclk_trail = PS_TO_CYCLE(cfg.clk_trail, byte_clock);\n\ths_prepare = PS_TO_CYCLE(cfg.hs_prepare, byte_clock);\n\ths_zero = PS_TO_CYCLE(cfg.hs_zero, byte_clock);\n\ths_trail = PS_TO_CYCLE(cfg.hs_trail, byte_clock);\n\n\t \n\treg = reg_values[PHYCTRL_ULPS_EXIT] | reg_values[PHYCTRL_VREG_LP] |\n\t\treg_values[PHYCTRL_SLEW_UP];\n\n\tsamsung_dsim_write(dsi, DSIM_PHYCTRL_REG, reg);\n\n\t \n\n\treg  = DSIM_PHYTIMING_LPX(lpx) | DSIM_PHYTIMING_HS_EXIT(hs_exit);\n\n\tsamsung_dsim_write(dsi, DSIM_PHYTIMING_REG, reg);\n\n\t \n\n\treg = DSIM_PHYTIMING1_CLK_PREPARE(clk_prepare)\t|\n\t      DSIM_PHYTIMING1_CLK_ZERO(clk_zero)\t|\n\t      DSIM_PHYTIMING1_CLK_POST(clk_post)\t|\n\t      DSIM_PHYTIMING1_CLK_TRAIL(clk_trail);\n\n\tsamsung_dsim_write(dsi, DSIM_PHYTIMING1_REG, reg);\n\n\t \n\n\treg = DSIM_PHYTIMING2_HS_PREPARE(hs_prepare) |\n\t      DSIM_PHYTIMING2_HS_ZERO(hs_zero) |\n\t      DSIM_PHYTIMING2_HS_TRAIL(hs_trail);\n\n\tsamsung_dsim_write(dsi, DSIM_PHYTIMING2_REG, reg);\n}\n\nstatic void samsung_dsim_disable_clock(struct samsung_dsim *dsi)\n{\n\tu32 reg;\n\n\treg = samsung_dsim_read(dsi, DSIM_CLKCTRL_REG);\n\treg &= ~(DSIM_LANE_ESC_CLK_EN_CLK | DSIM_LANE_ESC_CLK_EN_DATA_MASK\n\t\t\t| DSIM_ESC_CLKEN | DSIM_BYTE_CLKEN);\n\tsamsung_dsim_write(dsi, DSIM_CLKCTRL_REG, reg);\n\n\treg = samsung_dsim_read(dsi, DSIM_PLLCTRL_REG);\n\treg &= ~DSIM_PLL_EN;\n\tsamsung_dsim_write(dsi, DSIM_PLLCTRL_REG, reg);\n}\n\nstatic void samsung_dsim_enable_lane(struct samsung_dsim *dsi, u32 lane)\n{\n\tu32 reg = samsung_dsim_read(dsi, DSIM_CONFIG_REG);\n\n\treg |= (DSIM_NUM_OF_DATA_LANE(dsi->lanes - 1) | DSIM_LANE_EN_CLK |\n\t\t\tDSIM_LANE_EN(lane));\n\tsamsung_dsim_write(dsi, DSIM_CONFIG_REG, reg);\n}\n\nstatic int samsung_dsim_init_link(struct samsung_dsim *dsi)\n{\n\tconst struct samsung_dsim_driver_data *driver_data = dsi->driver_data;\n\tint timeout;\n\tu32 reg;\n\tu32 lanes_mask;\n\n\t \n\treg = samsung_dsim_read(dsi, DSIM_FIFOCTRL_REG);\n\treg &= ~0x1f;\n\tsamsung_dsim_write(dsi, DSIM_FIFOCTRL_REG, reg);\n\n\tusleep_range(9000, 11000);\n\n\treg |= 0x1f;\n\tsamsung_dsim_write(dsi, DSIM_FIFOCTRL_REG, reg);\n\tusleep_range(9000, 11000);\n\n\t \n\treg = 0;\n\n\t \n\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO) {\n\t\treg |= DSIM_VIDEO_MODE;\n\n\t\t \n\t\tif (!(dsi->mode_flags & MIPI_DSI_MODE_VSYNC_FLUSH))\n\t\t\treg |= DSIM_MFLUSH_VS;\n\t\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\t\treg |= DSIM_SYNC_INFORM;\n\t\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)\n\t\t\treg |= DSIM_BURST_MODE;\n\t\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_AUTO_VERT)\n\t\t\treg |= DSIM_AUTO_MODE;\n\t\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HSE)\n\t\t\treg |= DSIM_HSE_DISABLE_MODE;\n\t\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_NO_HFP)\n\t\t\treg |= DSIM_HFP_DISABLE_MODE;\n\t\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_NO_HBP)\n\t\t\treg |= DSIM_HBP_DISABLE_MODE;\n\t\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_NO_HSA)\n\t\t\treg |= DSIM_HSA_DISABLE_MODE;\n\t}\n\n\tif (dsi->mode_flags & MIPI_DSI_MODE_NO_EOT_PACKET)\n\t\treg |= DSIM_EOT_DISABLE;\n\n\tswitch (dsi->format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\treg |= DSIM_MAIN_PIX_FORMAT_RGB888;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\treg |= DSIM_MAIN_PIX_FORMAT_RGB666;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\treg |= DSIM_MAIN_PIX_FORMAT_RGB666_P;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB565:\n\t\treg |= DSIM_MAIN_PIX_FORMAT_RGB565;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dsi->dev, \"invalid pixel format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (driver_data->has_clklane_stop &&\n\t    dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)\n\t\treg |= DSIM_CLKLANE_STOP;\n\tsamsung_dsim_write(dsi, DSIM_CONFIG_REG, reg);\n\n\tlanes_mask = BIT(dsi->lanes) - 1;\n\tsamsung_dsim_enable_lane(dsi, lanes_mask);\n\n\t \n\ttimeout = 100;\n\tdo {\n\t\tif (timeout-- == 0) {\n\t\t\tdev_err(dsi->dev, \"waiting for bus lanes timed out\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treg = samsung_dsim_read(dsi, DSIM_STATUS_REG);\n\t\tif ((reg & DSIM_STOP_STATE_DAT(lanes_mask))\n\t\t    != DSIM_STOP_STATE_DAT(lanes_mask))\n\t\t\tcontinue;\n\t} while (!(reg & (DSIM_STOP_STATE_CLK | DSIM_TX_READY_HS_CLK)));\n\n\treg = samsung_dsim_read(dsi, DSIM_ESCMODE_REG);\n\treg &= ~DSIM_STOP_STATE_CNT_MASK;\n\treg |= DSIM_STOP_STATE_CNT(driver_data->reg_values[STOP_STATE_CNT]);\n\n\tif (!samsung_dsim_hw_is_exynos(dsi->plat_data->hw_type))\n\t\treg |= DSIM_FORCE_STOP_STATE;\n\n\tsamsung_dsim_write(dsi, DSIM_ESCMODE_REG, reg);\n\n\treg = DSIM_BTA_TIMEOUT(0xff) | DSIM_LPDR_TIMEOUT(0xffff);\n\tsamsung_dsim_write(dsi, DSIM_TIMEOUT_REG, reg);\n\n\treturn 0;\n}\n\nstatic void samsung_dsim_set_display_mode(struct samsung_dsim *dsi)\n{\n\tstruct drm_display_mode *m = &dsi->mode;\n\tunsigned int num_bits_resol = dsi->driver_data->num_bits_resol;\n\tu32 reg;\n\n\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO) {\n\t\tint byte_clk_khz = dsi->hs_clock / 1000 / 8;\n\t\tint hfp = (m->hsync_start - m->hdisplay) * byte_clk_khz / m->clock;\n\t\tint hbp = (m->htotal - m->hsync_end) * byte_clk_khz / m->clock;\n\t\tint hsa = (m->hsync_end - m->hsync_start) * byte_clk_khz / m->clock;\n\n\t\t \n\t\thfp = max(hfp - 6, 0);\n\t\thbp = max(hbp - 6, 0);\n\t\thsa = max(hsa - 6, 0);\n\n\t\tdev_dbg(dsi->dev, \"calculated hfp: %u, hbp: %u, hsa: %u\",\n\t\t\thfp, hbp, hsa);\n\n\t\treg = DSIM_CMD_ALLOW(0xf)\n\t\t\t| DSIM_STABLE_VFP(m->vsync_start - m->vdisplay)\n\t\t\t| DSIM_MAIN_VBP(m->vtotal - m->vsync_end);\n\t\tsamsung_dsim_write(dsi, DSIM_MVPORCH_REG, reg);\n\n\t\treg = DSIM_MAIN_HFP(hfp) | DSIM_MAIN_HBP(hbp);\n\t\tsamsung_dsim_write(dsi, DSIM_MHPORCH_REG, reg);\n\n\t\treg = DSIM_MAIN_VSA(m->vsync_end - m->vsync_start)\n\t\t\t| DSIM_MAIN_HSA(hsa);\n\t\tsamsung_dsim_write(dsi, DSIM_MSYNC_REG, reg);\n\t}\n\treg =  DSIM_MAIN_HRESOL(m->hdisplay, num_bits_resol) |\n\t\tDSIM_MAIN_VRESOL(m->vdisplay, num_bits_resol);\n\n\tsamsung_dsim_write(dsi, DSIM_MDRESOL_REG, reg);\n\n\tdev_dbg(dsi->dev, \"LCD size = %dx%d\\n\", m->hdisplay, m->vdisplay);\n}\n\nstatic void samsung_dsim_set_display_enable(struct samsung_dsim *dsi, bool enable)\n{\n\tu32 reg;\n\n\treg = samsung_dsim_read(dsi, DSIM_MDRESOL_REG);\n\tif (enable)\n\t\treg |= DSIM_MAIN_STAND_BY;\n\telse\n\t\treg &= ~DSIM_MAIN_STAND_BY;\n\tsamsung_dsim_write(dsi, DSIM_MDRESOL_REG, reg);\n}\n\nstatic int samsung_dsim_wait_for_hdr_fifo(struct samsung_dsim *dsi)\n{\n\tint timeout = 2000;\n\n\tdo {\n\t\tu32 reg = samsung_dsim_read(dsi, DSIM_FIFOCTRL_REG);\n\n\t\tif (!dsi->driver_data->has_broken_fifoctrl_emptyhdr) {\n\t\t\tif (reg & DSIM_SFR_HEADER_EMPTY)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!(reg & DSIM_SFR_HEADER_FULL)) {\n\t\t\t\t \n\t\t\t\tif (!cond_resched())\n\t\t\t\t\tusleep_range(950, 1050);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (!cond_resched())\n\t\t\tusleep_range(950, 1050);\n\t} while (--timeout);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void samsung_dsim_set_cmd_lpm(struct samsung_dsim *dsi, bool lpm)\n{\n\tu32 v = samsung_dsim_read(dsi, DSIM_ESCMODE_REG);\n\n\tif (lpm)\n\t\tv |= DSIM_CMD_LPDT_LP;\n\telse\n\t\tv &= ~DSIM_CMD_LPDT_LP;\n\n\tsamsung_dsim_write(dsi, DSIM_ESCMODE_REG, v);\n}\n\nstatic void samsung_dsim_force_bta(struct samsung_dsim *dsi)\n{\n\tu32 v = samsung_dsim_read(dsi, DSIM_ESCMODE_REG);\n\n\tv |= DSIM_FORCE_BTA;\n\tsamsung_dsim_write(dsi, DSIM_ESCMODE_REG, v);\n}\n\nstatic void samsung_dsim_send_to_fifo(struct samsung_dsim *dsi,\n\t\t\t\t      struct samsung_dsim_transfer *xfer)\n{\n\tstruct device *dev = dsi->dev;\n\tstruct mipi_dsi_packet *pkt = &xfer->packet;\n\tconst u8 *payload = pkt->payload + xfer->tx_done;\n\tu16 length = pkt->payload_length - xfer->tx_done;\n\tbool first = !xfer->tx_done;\n\tu32 reg;\n\n\tdev_dbg(dev, \"< xfer %pK: tx len %u, done %u, rx len %u, done %u\\n\",\n\t\txfer, length, xfer->tx_done, xfer->rx_len, xfer->rx_done);\n\n\tif (length > DSI_TX_FIFO_SIZE)\n\t\tlength = DSI_TX_FIFO_SIZE;\n\n\txfer->tx_done += length;\n\n\t \n\twhile (length >= 4) {\n\t\treg = get_unaligned_le32(payload);\n\t\tsamsung_dsim_write(dsi, DSIM_PAYLOAD_REG, reg);\n\t\tpayload += 4;\n\t\tlength -= 4;\n\t}\n\n\treg = 0;\n\tswitch (length) {\n\tcase 3:\n\t\treg |= payload[2] << 16;\n\t\tfallthrough;\n\tcase 2:\n\t\treg |= payload[1] << 8;\n\t\tfallthrough;\n\tcase 1:\n\t\treg |= payload[0];\n\t\tsamsung_dsim_write(dsi, DSIM_PAYLOAD_REG, reg);\n\t\tbreak;\n\t}\n\n\t \n\tif (!first)\n\t\treturn;\n\n\treg = get_unaligned_le32(pkt->header);\n\tif (samsung_dsim_wait_for_hdr_fifo(dsi)) {\n\t\tdev_err(dev, \"waiting for header FIFO timed out\\n\");\n\t\treturn;\n\t}\n\n\tif (NEQV(xfer->flags & MIPI_DSI_MSG_USE_LPM,\n\t\t dsi->state & DSIM_STATE_CMD_LPM)) {\n\t\tsamsung_dsim_set_cmd_lpm(dsi, xfer->flags & MIPI_DSI_MSG_USE_LPM);\n\t\tdsi->state ^= DSIM_STATE_CMD_LPM;\n\t}\n\n\tsamsung_dsim_write(dsi, DSIM_PKTHDR_REG, reg);\n\n\tif (xfer->flags & MIPI_DSI_MSG_REQ_ACK)\n\t\tsamsung_dsim_force_bta(dsi);\n}\n\nstatic void samsung_dsim_read_from_fifo(struct samsung_dsim *dsi,\n\t\t\t\t\tstruct samsung_dsim_transfer *xfer)\n{\n\tu8 *payload = xfer->rx_payload + xfer->rx_done;\n\tbool first = !xfer->rx_done;\n\tstruct device *dev = dsi->dev;\n\tu16 length;\n\tu32 reg;\n\n\tif (first) {\n\t\treg = samsung_dsim_read(dsi, DSIM_RXFIFO_REG);\n\n\t\tswitch (reg & 0x3f) {\n\t\tcase MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE:\n\t\tcase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE:\n\t\t\tif (xfer->rx_len >= 2) {\n\t\t\t\tpayload[1] = reg >> 16;\n\t\t\t\t++xfer->rx_done;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE:\n\t\tcase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE:\n\t\t\tpayload[0] = reg >> 8;\n\t\t\t++xfer->rx_done;\n\t\t\txfer->rx_len = xfer->rx_done;\n\t\t\txfer->result = 0;\n\t\t\tgoto clear_fifo;\n\t\tcase MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT:\n\t\t\tdev_err(dev, \"DSI Error Report: 0x%04x\\n\", (reg >> 8) & 0xffff);\n\t\t\txfer->result = 0;\n\t\t\tgoto clear_fifo;\n\t\t}\n\n\t\tlength = (reg >> 8) & 0xffff;\n\t\tif (length > xfer->rx_len) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"response too long (%u > %u bytes), stripping\\n\",\n\t\t\t\txfer->rx_len, length);\n\t\t\tlength = xfer->rx_len;\n\t\t} else if (length < xfer->rx_len) {\n\t\t\txfer->rx_len = length;\n\t\t}\n\t}\n\n\tlength = xfer->rx_len - xfer->rx_done;\n\txfer->rx_done += length;\n\n\t \n\twhile (length >= 4) {\n\t\treg = samsung_dsim_read(dsi, DSIM_RXFIFO_REG);\n\t\tpayload[0] = (reg >>  0) & 0xff;\n\t\tpayload[1] = (reg >>  8) & 0xff;\n\t\tpayload[2] = (reg >> 16) & 0xff;\n\t\tpayload[3] = (reg >> 24) & 0xff;\n\t\tpayload += 4;\n\t\tlength -= 4;\n\t}\n\n\tif (length) {\n\t\treg = samsung_dsim_read(dsi, DSIM_RXFIFO_REG);\n\t\tswitch (length) {\n\t\tcase 3:\n\t\t\tpayload[2] = (reg >> 16) & 0xff;\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tpayload[1] = (reg >> 8) & 0xff;\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\tpayload[0] = reg & 0xff;\n\t\t}\n\t}\n\n\tif (xfer->rx_done == xfer->rx_len)\n\t\txfer->result = 0;\n\nclear_fifo:\n\tlength = DSI_RX_FIFO_SIZE / 4;\n\tdo {\n\t\treg = samsung_dsim_read(dsi, DSIM_RXFIFO_REG);\n\t\tif (reg == DSI_RX_FIFO_EMPTY)\n\t\t\tbreak;\n\t} while (--length);\n}\n\nstatic void samsung_dsim_transfer_start(struct samsung_dsim *dsi)\n{\n\tunsigned long flags;\n\tstruct samsung_dsim_transfer *xfer;\n\tbool start = false;\n\nagain:\n\tspin_lock_irqsave(&dsi->transfer_lock, flags);\n\n\tif (list_empty(&dsi->transfer_list)) {\n\t\tspin_unlock_irqrestore(&dsi->transfer_lock, flags);\n\t\treturn;\n\t}\n\n\txfer = list_first_entry(&dsi->transfer_list,\n\t\t\t\tstruct samsung_dsim_transfer, list);\n\n\tspin_unlock_irqrestore(&dsi->transfer_lock, flags);\n\n\tif (xfer->packet.payload_length &&\n\t    xfer->tx_done == xfer->packet.payload_length)\n\t\t \n\t\treturn;\n\n\tsamsung_dsim_send_to_fifo(dsi, xfer);\n\n\tif (xfer->packet.payload_length || xfer->rx_len)\n\t\treturn;\n\n\txfer->result = 0;\n\tcomplete(&xfer->completed);\n\n\tspin_lock_irqsave(&dsi->transfer_lock, flags);\n\n\tlist_del_init(&xfer->list);\n\tstart = !list_empty(&dsi->transfer_list);\n\n\tspin_unlock_irqrestore(&dsi->transfer_lock, flags);\n\n\tif (start)\n\t\tgoto again;\n}\n\nstatic bool samsung_dsim_transfer_finish(struct samsung_dsim *dsi)\n{\n\tstruct samsung_dsim_transfer *xfer;\n\tunsigned long flags;\n\tbool start = true;\n\n\tspin_lock_irqsave(&dsi->transfer_lock, flags);\n\n\tif (list_empty(&dsi->transfer_list)) {\n\t\tspin_unlock_irqrestore(&dsi->transfer_lock, flags);\n\t\treturn false;\n\t}\n\n\txfer = list_first_entry(&dsi->transfer_list,\n\t\t\t\tstruct samsung_dsim_transfer, list);\n\n\tspin_unlock_irqrestore(&dsi->transfer_lock, flags);\n\n\tdev_dbg(dsi->dev,\n\t\t\"> xfer %pK, tx_len %zu, tx_done %u, rx_len %u, rx_done %u\\n\",\n\t\txfer, xfer->packet.payload_length, xfer->tx_done, xfer->rx_len,\n\t\txfer->rx_done);\n\n\tif (xfer->tx_done != xfer->packet.payload_length)\n\t\treturn true;\n\n\tif (xfer->rx_done != xfer->rx_len)\n\t\tsamsung_dsim_read_from_fifo(dsi, xfer);\n\n\tif (xfer->rx_done != xfer->rx_len)\n\t\treturn true;\n\n\tspin_lock_irqsave(&dsi->transfer_lock, flags);\n\n\tlist_del_init(&xfer->list);\n\tstart = !list_empty(&dsi->transfer_list);\n\n\tspin_unlock_irqrestore(&dsi->transfer_lock, flags);\n\n\tif (!xfer->rx_len)\n\t\txfer->result = 0;\n\tcomplete(&xfer->completed);\n\n\treturn start;\n}\n\nstatic void samsung_dsim_remove_transfer(struct samsung_dsim *dsi,\n\t\t\t\t\t struct samsung_dsim_transfer *xfer)\n{\n\tunsigned long flags;\n\tbool start;\n\n\tspin_lock_irqsave(&dsi->transfer_lock, flags);\n\n\tif (!list_empty(&dsi->transfer_list) &&\n\t    xfer == list_first_entry(&dsi->transfer_list,\n\t\t\t\t     struct samsung_dsim_transfer, list)) {\n\t\tlist_del_init(&xfer->list);\n\t\tstart = !list_empty(&dsi->transfer_list);\n\t\tspin_unlock_irqrestore(&dsi->transfer_lock, flags);\n\t\tif (start)\n\t\t\tsamsung_dsim_transfer_start(dsi);\n\t\treturn;\n\t}\n\n\tlist_del_init(&xfer->list);\n\n\tspin_unlock_irqrestore(&dsi->transfer_lock, flags);\n}\n\nstatic int samsung_dsim_transfer(struct samsung_dsim *dsi,\n\t\t\t\t struct samsung_dsim_transfer *xfer)\n{\n\tunsigned long flags;\n\tbool stopped;\n\n\txfer->tx_done = 0;\n\txfer->rx_done = 0;\n\txfer->result = -ETIMEDOUT;\n\tinit_completion(&xfer->completed);\n\n\tspin_lock_irqsave(&dsi->transfer_lock, flags);\n\n\tstopped = list_empty(&dsi->transfer_list);\n\tlist_add_tail(&xfer->list, &dsi->transfer_list);\n\n\tspin_unlock_irqrestore(&dsi->transfer_lock, flags);\n\n\tif (stopped)\n\t\tsamsung_dsim_transfer_start(dsi);\n\n\twait_for_completion_timeout(&xfer->completed,\n\t\t\t\t    msecs_to_jiffies(DSI_XFER_TIMEOUT_MS));\n\tif (xfer->result == -ETIMEDOUT) {\n\t\tstruct mipi_dsi_packet *pkt = &xfer->packet;\n\n\t\tsamsung_dsim_remove_transfer(dsi, xfer);\n\t\tdev_err(dsi->dev, \"xfer timed out: %*ph %*ph\\n\", 4, pkt->header,\n\t\t\t(int)pkt->payload_length, pkt->payload);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\treturn xfer->result;\n}\n\nstatic irqreturn_t samsung_dsim_irq(int irq, void *dev_id)\n{\n\tstruct samsung_dsim *dsi = dev_id;\n\tu32 status;\n\n\tstatus = samsung_dsim_read(dsi, DSIM_INTSRC_REG);\n\tif (!status) {\n\t\tstatic unsigned long j;\n\n\t\tif (printk_timed_ratelimit(&j, 500))\n\t\t\tdev_warn(dsi->dev, \"spurious interrupt\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\tsamsung_dsim_write(dsi, DSIM_INTSRC_REG, status);\n\n\tif (status & DSIM_INT_SW_RST_RELEASE) {\n\t\tunsigned long mask = ~(DSIM_INT_RX_DONE |\n\t\t\t\t       DSIM_INT_SFR_FIFO_EMPTY |\n\t\t\t\t       DSIM_INT_SFR_HDR_FIFO_EMPTY |\n\t\t\t\t       DSIM_INT_RX_ECC_ERR |\n\t\t\t\t       DSIM_INT_SW_RST_RELEASE);\n\t\tsamsung_dsim_write(dsi, DSIM_INTMSK_REG, mask);\n\t\tcomplete(&dsi->completed);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!(status & (DSIM_INT_RX_DONE | DSIM_INT_SFR_FIFO_EMPTY |\n\t\t\tDSIM_INT_PLL_STABLE)))\n\t\treturn IRQ_HANDLED;\n\n\tif (samsung_dsim_transfer_finish(dsi))\n\t\tsamsung_dsim_transfer_start(dsi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void samsung_dsim_enable_irq(struct samsung_dsim *dsi)\n{\n\tenable_irq(dsi->irq);\n\n\tif (dsi->te_gpio)\n\t\tenable_irq(gpiod_to_irq(dsi->te_gpio));\n}\n\nstatic void samsung_dsim_disable_irq(struct samsung_dsim *dsi)\n{\n\tif (dsi->te_gpio)\n\t\tdisable_irq(gpiod_to_irq(dsi->te_gpio));\n\n\tdisable_irq(dsi->irq);\n}\n\nstatic void samsung_dsim_set_stop_state(struct samsung_dsim *dsi, bool enable)\n{\n\tu32 reg = samsung_dsim_read(dsi, DSIM_ESCMODE_REG);\n\n\tif (enable)\n\t\treg |= DSIM_FORCE_STOP_STATE;\n\telse\n\t\treg &= ~DSIM_FORCE_STOP_STATE;\n\n\tsamsung_dsim_write(dsi, DSIM_ESCMODE_REG, reg);\n}\n\nstatic int samsung_dsim_init(struct samsung_dsim *dsi)\n{\n\tconst struct samsung_dsim_driver_data *driver_data = dsi->driver_data;\n\n\tif (dsi->state & DSIM_STATE_INITIALIZED)\n\t\treturn 0;\n\n\tsamsung_dsim_reset(dsi);\n\tsamsung_dsim_enable_irq(dsi);\n\n\tif (driver_data->reg_values[RESET_TYPE] == DSIM_FUNCRST)\n\t\tsamsung_dsim_enable_lane(dsi, BIT(dsi->lanes) - 1);\n\n\tsamsung_dsim_enable_clock(dsi);\n\tif (driver_data->wait_for_reset)\n\t\tsamsung_dsim_wait_for_reset(dsi);\n\tsamsung_dsim_set_phy_ctrl(dsi);\n\tsamsung_dsim_init_link(dsi);\n\n\tdsi->state |= DSIM_STATE_INITIALIZED;\n\n\treturn 0;\n}\n\nstatic void samsung_dsim_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t\t   struct drm_bridge_state *old_bridge_state)\n{\n\tstruct samsung_dsim *dsi = bridge_to_dsi(bridge);\n\tint ret;\n\n\tif (dsi->state & DSIM_STATE_ENABLED)\n\t\treturn;\n\n\tret = pm_runtime_resume_and_get(dsi->dev);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"failed to enable DSI device.\\n\");\n\t\treturn;\n\t}\n\n\tdsi->state |= DSIM_STATE_ENABLED;\n\n\t \n\tif (!samsung_dsim_hw_is_exynos(dsi->plat_data->hw_type)) {\n\t\tret = samsung_dsim_init(dsi);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tsamsung_dsim_set_display_mode(dsi);\n\t\tsamsung_dsim_set_display_enable(dsi, true);\n\t}\n}\n\nstatic void samsung_dsim_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t       struct drm_bridge_state *old_bridge_state)\n{\n\tstruct samsung_dsim *dsi = bridge_to_dsi(bridge);\n\n\tif (samsung_dsim_hw_is_exynos(dsi->plat_data->hw_type)) {\n\t\tsamsung_dsim_set_display_mode(dsi);\n\t\tsamsung_dsim_set_display_enable(dsi, true);\n\t} else {\n\t\tsamsung_dsim_set_stop_state(dsi, false);\n\t}\n\n\tdsi->state |= DSIM_STATE_VIDOUT_AVAILABLE;\n}\n\nstatic void samsung_dsim_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct samsung_dsim *dsi = bridge_to_dsi(bridge);\n\n\tif (!(dsi->state & DSIM_STATE_ENABLED))\n\t\treturn;\n\n\tif (!samsung_dsim_hw_is_exynos(dsi->plat_data->hw_type))\n\t\tsamsung_dsim_set_stop_state(dsi, true);\n\n\tdsi->state &= ~DSIM_STATE_VIDOUT_AVAILABLE;\n}\n\nstatic void samsung_dsim_atomic_post_disable(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct samsung_dsim *dsi = bridge_to_dsi(bridge);\n\n\tsamsung_dsim_set_display_enable(dsi, false);\n\n\tdsi->state &= ~DSIM_STATE_ENABLED;\n\tpm_runtime_put_sync(dsi->dev);\n}\n\n \nstatic const u32 samsung_dsim_pixel_output_fmts[] = {\n\tMEDIA_BUS_FMT_YUYV10_1X20,\n\tMEDIA_BUS_FMT_YUYV12_1X24,\n\tMEDIA_BUS_FMT_UYVY8_1X16,\n\tMEDIA_BUS_FMT_RGB101010_1X30,\n\tMEDIA_BUS_FMT_RGB121212_1X36,\n\tMEDIA_BUS_FMT_RGB565_1X16,\n\tMEDIA_BUS_FMT_RGB666_1X18,\n\tMEDIA_BUS_FMT_RGB888_1X24,\n};\n\nstatic bool samsung_dsim_pixel_output_fmt_supported(u32 fmt)\n{\n\tint i;\n\n\tif (fmt == MEDIA_BUS_FMT_FIXED)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(samsung_dsim_pixel_output_fmts); i++) {\n\t\tif (samsung_dsim_pixel_output_fmts[i] == fmt)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u32 *\nsamsung_dsim_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t       struct drm_bridge_state *bridge_state,\n\t\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t\t       struct drm_connector_state *conn_state,\n\t\t\t\t       u32 output_fmt,\n\t\t\t\t       unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\tinput_fmts = kmalloc(sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tif (!samsung_dsim_pixel_output_fmt_supported(output_fmt))\n\t\t \n\t\toutput_fmt = MEDIA_BUS_FMT_RGB888_1X24;\n\n\tinput_fmts[0] = output_fmt;\n\t*num_input_fmts = 1;\n\n\treturn input_fmts;\n}\n\nstatic int samsung_dsim_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct samsung_dsim *dsi = bridge_to_dsi(bridge);\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;\n\n\t \n\tif (dsi->plat_data->hw_type == DSIM_TYPE_IMX8MM) {\n\t\tadjusted_mode->flags |= (DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC);\n\t\tadjusted_mode->flags &= ~(DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC);\n\t} else if (dsi->plat_data->hw_type == DSIM_TYPE_IMX8MP) {\n\t\tadjusted_mode->flags &= ~(DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC);\n\t\tadjusted_mode->flags |= (DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC);\n\t}\n\n\treturn 0;\n}\n\nstatic void samsung_dsim_mode_set(struct drm_bridge *bridge,\n\t\t\t\t  const struct drm_display_mode *mode,\n\t\t\t\t  const struct drm_display_mode *adjusted_mode)\n{\n\tstruct samsung_dsim *dsi = bridge_to_dsi(bridge);\n\n\tdrm_mode_copy(&dsi->mode, adjusted_mode);\n}\n\nstatic int samsung_dsim_attach(struct drm_bridge *bridge,\n\t\t\t       enum drm_bridge_attach_flags flags)\n{\n\tstruct samsung_dsim *dsi = bridge_to_dsi(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, dsi->out_bridge, bridge,\n\t\t\t\t flags);\n}\n\nstatic const struct drm_bridge_funcs samsung_dsim_bridge_funcs = {\n\t.atomic_duplicate_state\t\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset\t\t\t= drm_atomic_helper_bridge_reset,\n\t.atomic_get_input_bus_fmts\t= samsung_dsim_atomic_get_input_bus_fmts,\n\t.atomic_check\t\t\t= samsung_dsim_atomic_check,\n\t.atomic_pre_enable\t\t= samsung_dsim_atomic_pre_enable,\n\t.atomic_enable\t\t\t= samsung_dsim_atomic_enable,\n\t.atomic_disable\t\t\t= samsung_dsim_atomic_disable,\n\t.atomic_post_disable\t\t= samsung_dsim_atomic_post_disable,\n\t.mode_set\t\t\t= samsung_dsim_mode_set,\n\t.attach\t\t\t\t= samsung_dsim_attach,\n};\n\nstatic irqreturn_t samsung_dsim_te_irq_handler(int irq, void *dev_id)\n{\n\tstruct samsung_dsim *dsi = (struct samsung_dsim *)dev_id;\n\tconst struct samsung_dsim_plat_data *pdata = dsi->plat_data;\n\n\tif (pdata->host_ops && pdata->host_ops->te_irq_handler)\n\t\treturn pdata->host_ops->te_irq_handler(dsi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int samsung_dsim_register_te_irq(struct samsung_dsim *dsi, struct device *dev)\n{\n\tint te_gpio_irq;\n\tint ret;\n\n\tdsi->te_gpio = devm_gpiod_get_optional(dev, \"te\", GPIOD_IN);\n\tif (!dsi->te_gpio)\n\t\treturn 0;\n\telse if (IS_ERR(dsi->te_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(dsi->te_gpio), \"failed to get te GPIO\\n\");\n\n\tte_gpio_irq = gpiod_to_irq(dsi->te_gpio);\n\n\tret = request_threaded_irq(te_gpio_irq, samsung_dsim_te_irq_handler, NULL,\n\t\t\t\t   IRQF_TRIGGER_RISING | IRQF_NO_AUTOEN, \"TE\", dsi);\n\tif (ret) {\n\t\tdev_err(dsi->dev, \"request interrupt failed with %d\\n\", ret);\n\t\tgpiod_put(dsi->te_gpio);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int samsung_dsim_host_attach(struct mipi_dsi_host *host,\n\t\t\t\t    struct mipi_dsi_device *device)\n{\n\tstruct samsung_dsim *dsi = host_to_dsi(host);\n\tconst struct samsung_dsim_plat_data *pdata = dsi->plat_data;\n\tstruct device *dev = dsi->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *remote;\n\tstruct drm_panel *panel;\n\tint ret;\n\n\t \n\tfor_each_available_child_of_node(np, remote) {\n\t\tif (of_node_name_eq(remote, \"port\") ||\n\t\t    of_node_name_eq(remote, \"ports\"))\n\t\t\tcontinue;\n\n\t\tgoto of_find_panel_or_bridge;\n\t}\n\n\t \n\tif (!of_graph_is_present(np))\n\t\treturn -ENODEV;\n\n\tremote = of_graph_get_remote_node(np, 1, 0);\n\nof_find_panel_or_bridge:\n\tif (!remote)\n\t\treturn -ENODEV;\n\n\tpanel = of_drm_find_panel(remote);\n\tif (!IS_ERR(panel)) {\n\t\tdsi->out_bridge = devm_drm_panel_bridge_add(dev, panel);\n\t} else {\n\t\tdsi->out_bridge = of_drm_find_bridge(remote);\n\t\tif (!dsi->out_bridge)\n\t\t\tdsi->out_bridge = ERR_PTR(-EINVAL);\n\t}\n\n\tof_node_put(remote);\n\n\tif (IS_ERR(dsi->out_bridge)) {\n\t\tret = PTR_ERR(dsi->out_bridge);\n\t\tDRM_DEV_ERROR(dev, \"failed to find the bridge: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tDRM_DEV_INFO(dev, \"Attached %s device\\n\", device->name);\n\n\tdrm_bridge_add(&dsi->bridge);\n\n\t \n\tif (!(device->mode_flags & MIPI_DSI_MODE_VIDEO)) {\n\t\tret = samsung_dsim_register_te_irq(dsi, &device->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (pdata->host_ops && pdata->host_ops->attach) {\n\t\tret = pdata->host_ops->attach(dsi, device);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdsi->lanes = device->lanes;\n\tdsi->format = device->format;\n\tdsi->mode_flags = device->mode_flags;\n\n\treturn 0;\n}\n\nstatic void samsung_dsim_unregister_te_irq(struct samsung_dsim *dsi)\n{\n\tif (dsi->te_gpio) {\n\t\tfree_irq(gpiod_to_irq(dsi->te_gpio), dsi);\n\t\tgpiod_put(dsi->te_gpio);\n\t}\n}\n\nstatic int samsung_dsim_host_detach(struct mipi_dsi_host *host,\n\t\t\t\t    struct mipi_dsi_device *device)\n{\n\tstruct samsung_dsim *dsi = host_to_dsi(host);\n\tconst struct samsung_dsim_plat_data *pdata = dsi->plat_data;\n\n\tdsi->out_bridge = NULL;\n\n\tif (pdata->host_ops && pdata->host_ops->detach)\n\t\tpdata->host_ops->detach(dsi, device);\n\n\tsamsung_dsim_unregister_te_irq(dsi);\n\n\tdrm_bridge_remove(&dsi->bridge);\n\n\treturn 0;\n}\n\nstatic ssize_t samsung_dsim_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t\t  const struct mipi_dsi_msg *msg)\n{\n\tstruct samsung_dsim *dsi = host_to_dsi(host);\n\tstruct samsung_dsim_transfer xfer;\n\tint ret;\n\n\tif (!(dsi->state & DSIM_STATE_ENABLED))\n\t\treturn -EINVAL;\n\n\tret = samsung_dsim_init(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tsamsung_dsim_set_stop_state(dsi, false);\n\n\tret = mipi_dsi_create_packet(&xfer.packet, msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\txfer.rx_len = msg->rx_len;\n\txfer.rx_payload = msg->rx_buf;\n\txfer.flags = msg->flags;\n\n\tret = samsung_dsim_transfer(dsi, &xfer);\n\treturn (ret < 0) ? ret : xfer.rx_done;\n}\n\nstatic const struct mipi_dsi_host_ops samsung_dsim_ops = {\n\t.attach = samsung_dsim_host_attach,\n\t.detach = samsung_dsim_host_detach,\n\t.transfer = samsung_dsim_host_transfer,\n};\n\nstatic int samsung_dsim_of_read_u32(const struct device_node *np,\n\t\t\t\t    const char *propname, u32 *out_value, bool optional)\n{\n\tint ret = of_property_read_u32(np, propname, out_value);\n\n\tif (ret < 0 && !optional)\n\t\tpr_err(\"%pOF: failed to get '%s' property\\n\", np, propname);\n\n\treturn ret;\n}\n\nstatic int samsung_dsim_parse_dt(struct samsung_dsim *dsi)\n{\n\tstruct device *dev = dsi->dev;\n\tstruct device_node *node = dev->of_node;\n\tu32 lane_polarities[5] = { 0 };\n\tstruct device_node *endpoint;\n\tint i, nr_lanes, ret;\n\tstruct clk *pll_clk;\n\n\tret = samsung_dsim_of_read_u32(node, \"samsung,pll-clock-frequency\",\n\t\t\t\t       &dsi->pll_clk_rate, 1);\n\t \n\tif (ret < 0) {\n\t\tdev_dbg(dev, \"Using sclk_mipi for pll clock frequency\\n\");\n\t\tpll_clk = devm_clk_get(dev, \"sclk_mipi\");\n\t\tif (!IS_ERR(pll_clk))\n\t\t\tdsi->pll_clk_rate = clk_get_rate(pll_clk);\n\t\telse\n\t\t\treturn PTR_ERR(pll_clk);\n\t}\n\n\t \n\tret = samsung_dsim_of_read_u32(node, \"samsung,burst-clock-frequency\",\n\t\t\t\t       &dsi->burst_clk_rate, 1);\n\tif (ret < 0) {\n\t\tdev_dbg(dev, \"Using pixel clock for HS clock frequency\\n\");\n\t\tdsi->burst_clk_rate = 0;\n\t}\n\n\tret = samsung_dsim_of_read_u32(node, \"samsung,esc-clock-frequency\",\n\t\t\t\t       &dsi->esc_clk_rate, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tendpoint = of_graph_get_endpoint_by_regs(node, 1, -1);\n\tnr_lanes = of_property_count_u32_elems(endpoint, \"data-lanes\");\n\tif (nr_lanes > 0 && nr_lanes <= 4) {\n\t\t \n\t\tof_property_read_u32_array(endpoint, \"lane-polarities\",\n\t\t\t\t\t   lane_polarities, nr_lanes + 1);\n\t\tfor (i = 1; i <= nr_lanes; i++) {\n\t\t\tif (lane_polarities[1] != lane_polarities[i])\n\t\t\t\tDRM_DEV_ERROR(dsi->dev, \"Data lanes polarities do not match\");\n\t\t}\n\t\tif (lane_polarities[0])\n\t\t\tdsi->swap_dn_dp_clk = true;\n\t\tif (lane_polarities[1])\n\t\t\tdsi->swap_dn_dp_data = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int generic_dsim_register_host(struct samsung_dsim *dsi)\n{\n\treturn mipi_dsi_host_register(&dsi->dsi_host);\n}\n\nstatic void generic_dsim_unregister_host(struct samsung_dsim *dsi)\n{\n\tmipi_dsi_host_unregister(&dsi->dsi_host);\n}\n\nstatic const struct samsung_dsim_host_ops generic_dsim_host_ops = {\n\t.register_host = generic_dsim_register_host,\n\t.unregister_host = generic_dsim_unregister_host,\n};\n\nstatic const struct drm_bridge_timings samsung_dsim_bridge_timings_de_high = {\n\t.input_bus_flags = DRM_BUS_FLAG_DE_HIGH,\n};\n\nstatic const struct drm_bridge_timings samsung_dsim_bridge_timings_de_low = {\n\t.input_bus_flags = DRM_BUS_FLAG_DE_LOW,\n};\n\nint samsung_dsim_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct samsung_dsim *dsi;\n\tint ret, i;\n\n\tdsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&dsi->completed);\n\tspin_lock_init(&dsi->transfer_lock);\n\tINIT_LIST_HEAD(&dsi->transfer_list);\n\n\tdsi->dsi_host.ops = &samsung_dsim_ops;\n\tdsi->dsi_host.dev = dev;\n\n\tdsi->dev = dev;\n\tdsi->plat_data = of_device_get_match_data(dev);\n\tdsi->driver_data = samsung_dsim_types[dsi->plat_data->hw_type];\n\n\tdsi->supplies[0].supply = \"vddcore\";\n\tdsi->supplies[1].supply = \"vddio\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(dsi->supplies),\n\t\t\t\t      dsi->supplies);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get regulators\\n\");\n\n\tdsi->clks = devm_kcalloc(dev, dsi->driver_data->num_clks,\n\t\t\t\t sizeof(*dsi->clks), GFP_KERNEL);\n\tif (!dsi->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < dsi->driver_data->num_clks; i++) {\n\t\tdsi->clks[i] = devm_clk_get(dev, clk_names[i]);\n\t\tif (IS_ERR(dsi->clks[i])) {\n\t\t\tif (strcmp(clk_names[i], \"sclk_mipi\") == 0) {\n\t\t\t\tdsi->clks[i] = devm_clk_get(dev, OLD_SCLK_MIPI_CLK_NAME);\n\t\t\t\tif (!IS_ERR(dsi->clks[i]))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdev_info(dev, \"failed to get the clock: %s\\n\", clk_names[i]);\n\t\t\treturn PTR_ERR(dsi->clks[i]);\n\t\t}\n\t}\n\n\tdsi->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dsi->reg_base))\n\t\treturn PTR_ERR(dsi->reg_base);\n\n\tdsi->phy = devm_phy_optional_get(dev, \"dsim\");\n\tif (IS_ERR(dsi->phy)) {\n\t\tdev_info(dev, \"failed to get dsim phy\\n\");\n\t\treturn PTR_ERR(dsi->phy);\n\t}\n\n\tdsi->irq = platform_get_irq(pdev, 0);\n\tif (dsi->irq < 0)\n\t\treturn dsi->irq;\n\n\tret = devm_request_threaded_irq(dev, dsi->irq, NULL,\n\t\t\t\t\tsamsung_dsim_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\tdev_name(dev), dsi);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request dsi irq\\n\");\n\t\treturn ret;\n\t}\n\n\tret = samsung_dsim_parse_dt(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, dsi);\n\n\tpm_runtime_enable(dev);\n\n\tdsi->bridge.funcs = &samsung_dsim_bridge_funcs;\n\tdsi->bridge.of_node = dev->of_node;\n\tdsi->bridge.type = DRM_MODE_CONNECTOR_DSI;\n\n\t \n\tif (dsi->plat_data->hw_type == DSIM_TYPE_IMX8MM)\n\t\tdsi->bridge.timings = &samsung_dsim_bridge_timings_de_low;\n\telse\n\t\tdsi->bridge.timings = &samsung_dsim_bridge_timings_de_high;\n\n\tif (dsi->plat_data->host_ops && dsi->plat_data->host_ops->register_host)\n\t\tret = dsi->plat_data->host_ops->register_host(dsi);\n\n\tif (ret)\n\t\tgoto err_disable_runtime;\n\n\treturn 0;\n\nerr_disable_runtime:\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(samsung_dsim_probe);\n\nint samsung_dsim_remove(struct platform_device *pdev)\n{\n\tstruct samsung_dsim *dsi = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (dsi->plat_data->host_ops && dsi->plat_data->host_ops->unregister_host)\n\t\tdsi->plat_data->host_ops->unregister_host(dsi);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(samsung_dsim_remove);\n\nstatic int __maybe_unused samsung_dsim_suspend(struct device *dev)\n{\n\tstruct samsung_dsim *dsi = dev_get_drvdata(dev);\n\tconst struct samsung_dsim_driver_data *driver_data = dsi->driver_data;\n\tint ret, i;\n\n\tusleep_range(10000, 20000);\n\n\tif (dsi->state & DSIM_STATE_INITIALIZED) {\n\t\tdsi->state &= ~DSIM_STATE_INITIALIZED;\n\n\t\tsamsung_dsim_disable_clock(dsi);\n\n\t\tsamsung_dsim_disable_irq(dsi);\n\t}\n\n\tdsi->state &= ~DSIM_STATE_CMD_LPM;\n\n\tphy_power_off(dsi->phy);\n\n\tfor (i = driver_data->num_clks - 1; i > -1; i--)\n\t\tclk_disable_unprepare(dsi->clks[i]);\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(dsi->supplies), dsi->supplies);\n\tif (ret < 0)\n\t\tdev_err(dsi->dev, \"cannot disable regulators %d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused samsung_dsim_resume(struct device *dev)\n{\n\tstruct samsung_dsim *dsi = dev_get_drvdata(dev);\n\tconst struct samsung_dsim_driver_data *driver_data = dsi->driver_data;\n\tint ret, i;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(dsi->supplies), dsi->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"cannot enable regulators %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < driver_data->num_clks; i++) {\n\t\tret = clk_prepare_enable(dsi->clks[i]);\n\t\tif (ret < 0)\n\t\t\tgoto err_clk;\n\t}\n\n\tret = phy_power_on(dsi->phy);\n\tif (ret < 0) {\n\t\tdev_err(dsi->dev, \"cannot enable phy %d\\n\", ret);\n\t\tgoto err_clk;\n\t}\n\n\treturn 0;\n\nerr_clk:\n\twhile (--i > -1)\n\t\tclk_disable_unprepare(dsi->clks[i]);\n\tregulator_bulk_disable(ARRAY_SIZE(dsi->supplies), dsi->supplies);\n\n\treturn ret;\n}\n\nconst struct dev_pm_ops samsung_dsim_pm_ops = {\n\tSET_RUNTIME_PM_OPS(samsung_dsim_suspend, samsung_dsim_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\nEXPORT_SYMBOL_GPL(samsung_dsim_pm_ops);\n\nstatic const struct samsung_dsim_plat_data samsung_dsim_imx8mm_pdata = {\n\t.hw_type = DSIM_TYPE_IMX8MM,\n\t.host_ops = &generic_dsim_host_ops,\n};\n\nstatic const struct samsung_dsim_plat_data samsung_dsim_imx8mp_pdata = {\n\t.hw_type = DSIM_TYPE_IMX8MP,\n\t.host_ops = &generic_dsim_host_ops,\n};\n\nstatic const struct of_device_id samsung_dsim_of_match[] = {\n\t{\n\t\t.compatible = \"fsl,imx8mm-mipi-dsim\",\n\t\t.data = &samsung_dsim_imx8mm_pdata,\n\t},\n\t{\n\t\t.compatible = \"fsl,imx8mp-mipi-dsim\",\n\t\t.data = &samsung_dsim_imx8mp_pdata,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, samsung_dsim_of_match);\n\nstatic struct platform_driver samsung_dsim_driver = {\n\t.probe = samsung_dsim_probe,\n\t.remove = samsung_dsim_remove,\n\t.driver = {\n\t\t   .name = \"samsung-dsim\",\n\t\t   .pm = &samsung_dsim_pm_ops,\n\t\t   .of_match_table = samsung_dsim_of_match,\n\t},\n};\n\nmodule_platform_driver(samsung_dsim_driver);\n\nMODULE_AUTHOR(\"Jagan Teki <jagan@amarulasolutions.com>\");\nMODULE_DESCRIPTION(\"Samsung MIPI DSIM controller bridge\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}