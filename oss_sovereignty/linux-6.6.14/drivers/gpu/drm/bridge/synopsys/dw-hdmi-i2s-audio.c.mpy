{
  "module_name": "dw-hdmi-i2s-audio.c",
  "hash_id": "3e82714642897480e5cd2d885c773a4e21c3c7641a2a016db9efe9535883ff76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/synopsys/dw-hdmi-i2s-audio.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n\n#include <drm/bridge/dw_hdmi.h>\n#include <drm/drm_crtc.h>\n\n#include <sound/hdmi-codec.h>\n\n#include \"dw-hdmi.h\"\n#include \"dw-hdmi-audio.h\"\n\n#define DRIVER_NAME \"dw-hdmi-i2s-audio\"\n\nstatic inline void hdmi_write(struct dw_hdmi_i2s_audio_data *audio,\n\t\t\t      u8 val, int offset)\n{\n\tstruct dw_hdmi *hdmi = audio->hdmi;\n\n\taudio->write(hdmi, val, offset);\n}\n\nstatic inline u8 hdmi_read(struct dw_hdmi_i2s_audio_data *audio, int offset)\n{\n\tstruct dw_hdmi *hdmi = audio->hdmi;\n\n\treturn audio->read(hdmi, offset);\n}\n\nstatic int dw_hdmi_i2s_hw_params(struct device *dev, void *data,\n\t\t\t\t struct hdmi_codec_daifmt *fmt,\n\t\t\t\t struct hdmi_codec_params *hparms)\n{\n\tstruct dw_hdmi_i2s_audio_data *audio = data;\n\tstruct dw_hdmi *hdmi = audio->hdmi;\n\tu8 conf0 = 0;\n\tu8 conf1 = 0;\n\tu8 inputclkfs = 0;\n\n\t \n\tif (fmt->bit_clk_provider | fmt->frame_clk_provider) {\n\t\tdev_err(dev, \"unsupported clock settings\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thdmi_write(audio, HDMI_AUD_CONF0_SW_RESET, HDMI_AUD_CONF0);\n\thdmi_write(audio, (u8)~HDMI_MC_SWRSTZ_I2SSWRST_REQ, HDMI_MC_SWRSTZ);\n\n\tinputclkfs\t= HDMI_AUD_INPUTCLKFS_64FS;\n\tconf0\t\t= (HDMI_AUD_CONF0_I2S_SELECT | HDMI_AUD_CONF0_I2S_EN0);\n\n\t \n\tswitch (hparms->channels) {\n\tcase 7 ... 8:\n\t\tconf0 |= HDMI_AUD_CONF0_I2S_EN3;\n\t\tfallthrough;\n\tcase 5 ... 6:\n\t\tconf0 |= HDMI_AUD_CONF0_I2S_EN2;\n\t\tfallthrough;\n\tcase 3 ... 4:\n\t\tconf0 |= HDMI_AUD_CONF0_I2S_EN1;\n\t\t \n\t}\n\n\tswitch (hparms->sample_width) {\n\tcase 16:\n\t\tconf1 = HDMI_AUD_CONF1_WIDTH_16;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tconf1 = HDMI_AUD_CONF1_WIDTH_24;\n\t\tbreak;\n\t}\n\n\tswitch (fmt->fmt) {\n\tcase HDMI_I2S:\n\t\tconf1 |= HDMI_AUD_CONF1_MODE_I2S;\n\t\tbreak;\n\tcase HDMI_RIGHT_J:\n\t\tconf1 |= HDMI_AUD_CONF1_MODE_RIGHT_J;\n\t\tbreak;\n\tcase HDMI_LEFT_J:\n\t\tconf1 |= HDMI_AUD_CONF1_MODE_LEFT_J;\n\t\tbreak;\n\tcase HDMI_DSP_A:\n\t\tconf1 |= HDMI_AUD_CONF1_MODE_BURST_1;\n\t\tbreak;\n\tcase HDMI_DSP_B:\n\t\tconf1 |= HDMI_AUD_CONF1_MODE_BURST_2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdw_hdmi_set_sample_rate(hdmi, hparms->sample_rate);\n\tdw_hdmi_set_channel_status(hdmi, hparms->iec.status);\n\tdw_hdmi_set_channel_count(hdmi, hparms->channels);\n\tdw_hdmi_set_channel_allocation(hdmi, hparms->cea.channel_allocation);\n\n\thdmi_write(audio, inputclkfs, HDMI_AUD_INPUTCLKFS);\n\thdmi_write(audio, conf0, HDMI_AUD_CONF0);\n\thdmi_write(audio, conf1, HDMI_AUD_CONF1);\n\n\treturn 0;\n}\n\nstatic int dw_hdmi_i2s_audio_startup(struct device *dev, void *data)\n{\n\tstruct dw_hdmi_i2s_audio_data *audio = data;\n\tstruct dw_hdmi *hdmi = audio->hdmi;\n\n\tdw_hdmi_audio_enable(hdmi);\n\n\treturn 0;\n}\n\nstatic void dw_hdmi_i2s_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct dw_hdmi_i2s_audio_data *audio = data;\n\tstruct dw_hdmi *hdmi = audio->hdmi;\n\n\tdw_hdmi_audio_disable(hdmi);\n}\n\nstatic int dw_hdmi_i2s_get_eld(struct device *dev, void *data, uint8_t *buf,\n\t\t\t       size_t len)\n{\n\tstruct dw_hdmi_i2s_audio_data *audio = data;\n\tu8 *eld;\n\n\teld = audio->get_eld(audio->hdmi);\n\tif (eld)\n\t\tmemcpy(buf, eld, min_t(size_t, MAX_ELD_BYTES, len));\n\telse\n\t\t \n\t\tmemset(buf, 0, len);\n\n\treturn 0;\n}\n\nstatic int dw_hdmi_i2s_get_dai_id(struct snd_soc_component *component,\n\t\t\t\t  struct device_node *endpoint)\n{\n\tstruct of_endpoint of_ep;\n\tint ret;\n\n\tret = of_graph_parse_endpoint(endpoint, &of_ep);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (of_ep.port == 2)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int dw_hdmi_i2s_hook_plugged_cb(struct device *dev, void *data,\n\t\t\t\t       hdmi_codec_plugged_cb fn,\n\t\t\t\t       struct device *codec_dev)\n{\n\tstruct dw_hdmi_i2s_audio_data *audio = data;\n\tstruct dw_hdmi *hdmi = audio->hdmi;\n\n\treturn dw_hdmi_set_plugged_cb(hdmi, fn, codec_dev);\n}\n\nstatic const struct hdmi_codec_ops dw_hdmi_i2s_ops = {\n\t.hw_params\t= dw_hdmi_i2s_hw_params,\n\t.audio_startup  = dw_hdmi_i2s_audio_startup,\n\t.audio_shutdown\t= dw_hdmi_i2s_audio_shutdown,\n\t.get_eld\t= dw_hdmi_i2s_get_eld,\n\t.get_dai_id\t= dw_hdmi_i2s_get_dai_id,\n\t.hook_plugged_cb = dw_hdmi_i2s_hook_plugged_cb,\n};\n\nstatic int snd_dw_hdmi_probe(struct platform_device *pdev)\n{\n\tstruct dw_hdmi_i2s_audio_data *audio = pdev->dev.platform_data;\n\tstruct platform_device_info pdevinfo;\n\tstruct hdmi_codec_pdata pdata;\n\tstruct platform_device *platform;\n\n\tmemset(&pdata, 0, sizeof(pdata));\n\tpdata.ops\t\t= &dw_hdmi_i2s_ops;\n\tpdata.i2s\t\t= 1;\n\tpdata.max_i2s_channels\t= 8;\n\tpdata.data\t\t= audio;\n\n\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\tpdevinfo.parent\t\t= pdev->dev.parent;\n\tpdevinfo.id\t\t= PLATFORM_DEVID_AUTO;\n\tpdevinfo.name\t\t= HDMI_CODEC_DRV_NAME;\n\tpdevinfo.data\t\t= &pdata;\n\tpdevinfo.size_data\t= sizeof(pdata);\n\tpdevinfo.dma_mask\t= DMA_BIT_MASK(32);\n\n\tplatform = platform_device_register_full(&pdevinfo);\n\tif (IS_ERR(platform))\n\t\treturn PTR_ERR(platform);\n\n\tdev_set_drvdata(&pdev->dev, platform);\n\n\treturn 0;\n}\n\nstatic void snd_dw_hdmi_remove(struct platform_device *pdev)\n{\n\tstruct platform_device *platform = dev_get_drvdata(&pdev->dev);\n\n\tplatform_device_unregister(platform);\n}\n\nstatic struct platform_driver snd_dw_hdmi_driver = {\n\t.probe\t= snd_dw_hdmi_probe,\n\t.remove_new = snd_dw_hdmi_remove,\n\t.driver\t= {\n\t\t.name = DRIVER_NAME,\n\t},\n};\nmodule_platform_driver(snd_dw_hdmi_driver);\n\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\nMODULE_DESCRIPTION(\"Synopsis Designware HDMI I2S ALSA SoC interface\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}