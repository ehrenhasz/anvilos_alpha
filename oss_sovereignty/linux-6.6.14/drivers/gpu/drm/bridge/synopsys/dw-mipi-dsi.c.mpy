{
  "module_name": "dw-mipi-dsi.c",
  "hash_id": "d7ae56de4609bf0a40aae7007e08d2b698cba5a7d3d285fb5adabb3d79618310",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/debugfs.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/bridge/dw_mipi_dsi.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n\n#define HWVER_131\t\t\t0x31333100\t \n\n#define DSI_VERSION\t\t\t0x00\n#define VERSION\t\t\t\tGENMASK(31, 8)\n\n#define DSI_PWR_UP\t\t\t0x04\n#define RESET\t\t\t\t0\n#define POWERUP\t\t\t\tBIT(0)\n\n#define DSI_CLKMGR_CFG\t\t\t0x08\n#define TO_CLK_DIVISION(div)\t\t(((div) & 0xff) << 8)\n#define TX_ESC_CLK_DIVISION(div)\t((div) & 0xff)\n\n#define DSI_DPI_VCID\t\t\t0x0c\n#define DPI_VCID(vcid)\t\t\t((vcid) & 0x3)\n\n#define DSI_DPI_COLOR_CODING\t\t0x10\n#define LOOSELY18_EN\t\t\tBIT(8)\n#define DPI_COLOR_CODING_16BIT_1\t0x0\n#define DPI_COLOR_CODING_16BIT_2\t0x1\n#define DPI_COLOR_CODING_16BIT_3\t0x2\n#define DPI_COLOR_CODING_18BIT_1\t0x3\n#define DPI_COLOR_CODING_18BIT_2\t0x4\n#define DPI_COLOR_CODING_24BIT\t\t0x5\n\n#define DSI_DPI_CFG_POL\t\t\t0x14\n#define COLORM_ACTIVE_LOW\t\tBIT(4)\n#define SHUTD_ACTIVE_LOW\t\tBIT(3)\n#define HSYNC_ACTIVE_LOW\t\tBIT(2)\n#define VSYNC_ACTIVE_LOW\t\tBIT(1)\n#define DATAEN_ACTIVE_LOW\t\tBIT(0)\n\n#define DSI_DPI_LP_CMD_TIM\t\t0x18\n#define OUTVACT_LPCMD_TIME(p)\t\t(((p) & 0xff) << 16)\n#define INVACT_LPCMD_TIME(p)\t\t((p) & 0xff)\n\n#define DSI_DBI_VCID\t\t\t0x1c\n#define DSI_DBI_CFG\t\t\t0x20\n#define DSI_DBI_PARTITIONING_EN\t\t0x24\n#define DSI_DBI_CMDSIZE\t\t\t0x28\n\n#define DSI_PCKHDL_CFG\t\t\t0x2c\n#define CRC_RX_EN\t\t\tBIT(4)\n#define ECC_RX_EN\t\t\tBIT(3)\n#define BTA_EN\t\t\t\tBIT(2)\n#define EOTP_RX_EN\t\t\tBIT(1)\n#define EOTP_TX_EN\t\t\tBIT(0)\n\n#define DSI_GEN_VCID\t\t\t0x30\n\n#define DSI_MODE_CFG\t\t\t0x34\n#define ENABLE_VIDEO_MODE\t\t0\n#define ENABLE_CMD_MODE\t\t\tBIT(0)\n\n#define DSI_VID_MODE_CFG\t\t0x38\n#define ENABLE_LOW_POWER\t\t(0x3f << 8)\n#define ENABLE_LOW_POWER_MASK\t\t(0x3f << 8)\n#define VID_MODE_TYPE_NON_BURST_SYNC_PULSES\t0x0\n#define VID_MODE_TYPE_NON_BURST_SYNC_EVENTS\t0x1\n#define VID_MODE_TYPE_BURST\t\t\t0x2\n#define VID_MODE_TYPE_MASK\t\t\t0x3\n#define ENABLE_LOW_POWER_CMD\t\tBIT(15)\n#define VID_MODE_VPG_ENABLE\t\tBIT(16)\n#define VID_MODE_VPG_MODE\t\tBIT(20)\n#define VID_MODE_VPG_HORIZONTAL\t\tBIT(24)\n\n#define DSI_VID_PKT_SIZE\t\t0x3c\n#define VID_PKT_SIZE(p)\t\t\t((p) & 0x3fff)\n\n#define DSI_VID_NUM_CHUNKS\t\t0x40\n#define VID_NUM_CHUNKS(c)\t\t((c) & 0x1fff)\n\n#define DSI_VID_NULL_SIZE\t\t0x44\n#define VID_NULL_SIZE(b)\t\t((b) & 0x1fff)\n\n#define DSI_VID_HSA_TIME\t\t0x48\n#define DSI_VID_HBP_TIME\t\t0x4c\n#define DSI_VID_HLINE_TIME\t\t0x50\n#define DSI_VID_VSA_LINES\t\t0x54\n#define DSI_VID_VBP_LINES\t\t0x58\n#define DSI_VID_VFP_LINES\t\t0x5c\n#define DSI_VID_VACTIVE_LINES\t\t0x60\n#define DSI_EDPI_CMD_SIZE\t\t0x64\n\n#define DSI_CMD_MODE_CFG\t\t0x68\n#define MAX_RD_PKT_SIZE_LP\t\tBIT(24)\n#define DCS_LW_TX_LP\t\t\tBIT(19)\n#define DCS_SR_0P_TX_LP\t\t\tBIT(18)\n#define DCS_SW_1P_TX_LP\t\t\tBIT(17)\n#define DCS_SW_0P_TX_LP\t\t\tBIT(16)\n#define GEN_LW_TX_LP\t\t\tBIT(14)\n#define GEN_SR_2P_TX_LP\t\t\tBIT(13)\n#define GEN_SR_1P_TX_LP\t\t\tBIT(12)\n#define GEN_SR_0P_TX_LP\t\t\tBIT(11)\n#define GEN_SW_2P_TX_LP\t\t\tBIT(10)\n#define GEN_SW_1P_TX_LP\t\t\tBIT(9)\n#define GEN_SW_0P_TX_LP\t\t\tBIT(8)\n#define ACK_RQST_EN\t\t\tBIT(1)\n#define TEAR_FX_EN\t\t\tBIT(0)\n\n#define CMD_MODE_ALL_LP\t\t\t(MAX_RD_PKT_SIZE_LP | \\\n\t\t\t\t\t DCS_LW_TX_LP | \\\n\t\t\t\t\t DCS_SR_0P_TX_LP | \\\n\t\t\t\t\t DCS_SW_1P_TX_LP | \\\n\t\t\t\t\t DCS_SW_0P_TX_LP | \\\n\t\t\t\t\t GEN_LW_TX_LP | \\\n\t\t\t\t\t GEN_SR_2P_TX_LP | \\\n\t\t\t\t\t GEN_SR_1P_TX_LP | \\\n\t\t\t\t\t GEN_SR_0P_TX_LP | \\\n\t\t\t\t\t GEN_SW_2P_TX_LP | \\\n\t\t\t\t\t GEN_SW_1P_TX_LP | \\\n\t\t\t\t\t GEN_SW_0P_TX_LP)\n\n#define DSI_GEN_HDR\t\t\t0x6c\n#define DSI_GEN_PLD_DATA\t\t0x70\n\n#define DSI_CMD_PKT_STATUS\t\t0x74\n#define GEN_RD_CMD_BUSY\t\t\tBIT(6)\n#define GEN_PLD_R_FULL\t\t\tBIT(5)\n#define GEN_PLD_R_EMPTY\t\t\tBIT(4)\n#define GEN_PLD_W_FULL\t\t\tBIT(3)\n#define GEN_PLD_W_EMPTY\t\t\tBIT(2)\n#define GEN_CMD_FULL\t\t\tBIT(1)\n#define GEN_CMD_EMPTY\t\t\tBIT(0)\n\n#define DSI_TO_CNT_CFG\t\t\t0x78\n#define HSTX_TO_CNT(p)\t\t\t(((p) & 0xffff) << 16)\n#define LPRX_TO_CNT(p)\t\t\t((p) & 0xffff)\n\n#define DSI_HS_RD_TO_CNT\t\t0x7c\n#define DSI_LP_RD_TO_CNT\t\t0x80\n#define DSI_HS_WR_TO_CNT\t\t0x84\n#define DSI_LP_WR_TO_CNT\t\t0x88\n#define DSI_BTA_TO_CNT\t\t\t0x8c\n\n#define DSI_LPCLK_CTRL\t\t\t0x94\n#define AUTO_CLKLANE_CTRL\t\tBIT(1)\n#define PHY_TXREQUESTCLKHS\t\tBIT(0)\n\n#define DSI_PHY_TMR_LPCLK_CFG\t\t0x98\n#define PHY_CLKHS2LP_TIME(lbcc)\t\t(((lbcc) & 0x3ff) << 16)\n#define PHY_CLKLP2HS_TIME(lbcc)\t\t((lbcc) & 0x3ff)\n\n#define DSI_PHY_TMR_CFG\t\t\t0x9c\n#define PHY_HS2LP_TIME(lbcc)\t\t(((lbcc) & 0xff) << 24)\n#define PHY_LP2HS_TIME(lbcc)\t\t(((lbcc) & 0xff) << 16)\n#define MAX_RD_TIME(lbcc)\t\t((lbcc) & 0x7fff)\n#define PHY_HS2LP_TIME_V131(lbcc)\t(((lbcc) & 0x3ff) << 16)\n#define PHY_LP2HS_TIME_V131(lbcc)\t((lbcc) & 0x3ff)\n\n#define DSI_PHY_RSTZ\t\t\t0xa0\n#define PHY_DISFORCEPLL\t\t\t0\n#define PHY_ENFORCEPLL\t\t\tBIT(3)\n#define PHY_DISABLECLK\t\t\t0\n#define PHY_ENABLECLK\t\t\tBIT(2)\n#define PHY_RSTZ\t\t\t0\n#define PHY_UNRSTZ\t\t\tBIT(1)\n#define PHY_SHUTDOWNZ\t\t\t0\n#define PHY_UNSHUTDOWNZ\t\t\tBIT(0)\n\n#define DSI_PHY_IF_CFG\t\t\t0xa4\n#define PHY_STOP_WAIT_TIME(cycle)\t(((cycle) & 0xff) << 8)\n#define N_LANES(n)\t\t\t(((n) - 1) & 0x3)\n\n#define DSI_PHY_ULPS_CTRL\t\t0xa8\n#define DSI_PHY_TX_TRIGGERS\t\t0xac\n\n#define DSI_PHY_STATUS\t\t\t0xb0\n#define PHY_STOP_STATE_CLK_LANE\t\tBIT(2)\n#define PHY_LOCK\t\t\tBIT(0)\n\n#define DSI_PHY_TST_CTRL0\t\t0xb4\n#define PHY_TESTCLK\t\t\tBIT(1)\n#define PHY_UNTESTCLK\t\t\t0\n#define PHY_TESTCLR\t\t\tBIT(0)\n#define PHY_UNTESTCLR\t\t\t0\n\n#define DSI_PHY_TST_CTRL1\t\t0xb8\n#define PHY_TESTEN\t\t\tBIT(16)\n#define PHY_UNTESTEN\t\t\t0\n#define PHY_TESTDOUT(n)\t\t\t(((n) & 0xff) << 8)\n#define PHY_TESTDIN(n)\t\t\t((n) & 0xff)\n\n#define DSI_INT_ST0\t\t\t0xbc\n#define DSI_INT_ST1\t\t\t0xc0\n#define DSI_INT_MSK0\t\t\t0xc4\n#define DSI_INT_MSK1\t\t\t0xc8\n\n#define DSI_PHY_TMR_RD_CFG\t\t0xf4\n#define MAX_RD_TIME_V131(lbcc)\t\t((lbcc) & 0x7fff)\n\n#define PHY_STATUS_TIMEOUT_US\t\t10000\n#define CMD_PKT_STATUS_TIMEOUT_US\t20000\n\n#ifdef CONFIG_DEBUG_FS\n#define VPG_DEFS(name, dsi) \\\n\t((void __force *)&((*dsi).vpg_defs.name))\n\n#define REGISTER(name, mask, dsi) \\\n\t{ #name, VPG_DEFS(name, dsi), mask, dsi }\n\nstruct debugfs_entries {\n\tconst char\t\t\t\t*name;\n\tbool\t\t\t\t\t*reg;\n\tu32\t\t\t\t\tmask;\n\tstruct dw_mipi_dsi\t\t\t*dsi;\n};\n#endif  \n\nstruct dw_mipi_dsi {\n\tstruct drm_bridge bridge;\n\tstruct mipi_dsi_host dsi_host;\n\tstruct drm_bridge *panel_bridge;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\n\tstruct clk *pclk;\n\n\tunsigned int lane_mbps;  \n\tu32 channel;\n\tu32 lanes;\n\tu32 format;\n\tunsigned long mode_flags;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *debugfs;\n\tstruct debugfs_entries *debugfs_vpg;\n\tstruct {\n\t\tbool vpg;\n\t\tbool vpg_horizontal;\n\t\tbool vpg_ber_pattern;\n\t} vpg_defs;\n#endif  \n\n\tstruct dw_mipi_dsi *master;  \n\tstruct dw_mipi_dsi *slave;  \n\n\tstruct drm_display_mode mode;\n\tconst struct dw_mipi_dsi_plat_data *plat_data;\n};\n\n \nstatic inline bool dw_mipi_is_dual_mode(struct dw_mipi_dsi *dsi)\n{\n\treturn dsi->slave || dsi->master;\n}\n\n \nstatic void dw_mipi_dsi_wait_for_two_frames(const struct drm_display_mode *mode)\n{\n\tint refresh, two_frames;\n\n\trefresh = drm_mode_vrefresh(mode);\n\ttwo_frames = DIV_ROUND_UP(MSEC_PER_SEC, refresh) * 2;\n\tmsleep(two_frames);\n}\n\nstatic inline struct dw_mipi_dsi *host_to_dsi(struct mipi_dsi_host *host)\n{\n\treturn container_of(host, struct dw_mipi_dsi, dsi_host);\n}\n\nstatic inline struct dw_mipi_dsi *bridge_to_dsi(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct dw_mipi_dsi, bridge);\n}\n\nstatic inline void dsi_write(struct dw_mipi_dsi *dsi, u32 reg, u32 val)\n{\n\twritel(val, dsi->base + reg);\n}\n\nstatic inline u32 dsi_read(struct dw_mipi_dsi *dsi, u32 reg)\n{\n\treturn readl(dsi->base + reg);\n}\n\nstatic int dw_mipi_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t\t   struct mipi_dsi_device *device)\n{\n\tstruct dw_mipi_dsi *dsi = host_to_dsi(host);\n\tconst struct dw_mipi_dsi_plat_data *pdata = dsi->plat_data;\n\tstruct drm_bridge *bridge;\n\tint ret;\n\n\tif (device->lanes > dsi->plat_data->max_data_lanes) {\n\t\tdev_err(dsi->dev, \"the number of data lanes(%u) is too many\\n\",\n\t\t\tdevice->lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tdsi->lanes = device->lanes;\n\tdsi->channel = device->channel;\n\tdsi->format = device->format;\n\tdsi->mode_flags = device->mode_flags;\n\n\tbridge = devm_drm_of_get_bridge(dsi->dev, dsi->dev->of_node, 1, 0);\n\tif (IS_ERR(bridge))\n\t\treturn PTR_ERR(bridge);\n\n\tbridge->pre_enable_prev_first = true;\n\tdsi->panel_bridge = bridge;\n\n\tdrm_bridge_add(&dsi->bridge);\n\n\tif (pdata->host_ops && pdata->host_ops->attach) {\n\t\tret = pdata->host_ops->attach(pdata->priv_data, device);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dw_mipi_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t\t   struct mipi_dsi_device *device)\n{\n\tstruct dw_mipi_dsi *dsi = host_to_dsi(host);\n\tconst struct dw_mipi_dsi_plat_data *pdata = dsi->plat_data;\n\tint ret;\n\n\tif (pdata->host_ops && pdata->host_ops->detach) {\n\t\tret = pdata->host_ops->detach(pdata->priv_data, device);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tdrm_of_panel_bridge_remove(host->dev->of_node, 1, 0);\n\n\tdrm_bridge_remove(&dsi->bridge);\n\n\treturn 0;\n}\n\nstatic void dw_mipi_message_config(struct dw_mipi_dsi *dsi,\n\t\t\t\t   const struct mipi_dsi_msg *msg)\n{\n\tbool lpm = msg->flags & MIPI_DSI_MSG_USE_LPM;\n\tu32 val = 0;\n\n\t \n\tdsi_write(dsi, DSI_DPI_LP_CMD_TIM, OUTVACT_LPCMD_TIME(16)\n\t\t  | INVACT_LPCMD_TIME(4));\n\n\tif (msg->flags & MIPI_DSI_MSG_REQ_ACK)\n\t\tval |= ACK_RQST_EN;\n\tif (lpm)\n\t\tval |= CMD_MODE_ALL_LP;\n\n\tdsi_write(dsi, DSI_CMD_MODE_CFG, val);\n\n\tval = dsi_read(dsi, DSI_VID_MODE_CFG);\n\tif (lpm)\n\t\tval |= ENABLE_LOW_POWER_CMD;\n\telse\n\t\tval &= ~ENABLE_LOW_POWER_CMD;\n\tdsi_write(dsi, DSI_VID_MODE_CFG, val);\n}\n\nstatic int dw_mipi_dsi_gen_pkt_hdr_write(struct dw_mipi_dsi *dsi, u32 hdr_val)\n{\n\tint ret;\n\tu32 val, mask;\n\n\tret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,\n\t\t\t\t val, !(val & GEN_CMD_FULL), 1000,\n\t\t\t\t CMD_PKT_STATUS_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dsi->dev, \"failed to get available command FIFO\\n\");\n\t\treturn ret;\n\t}\n\n\tdsi_write(dsi, DSI_GEN_HDR, hdr_val);\n\n\tmask = GEN_CMD_EMPTY | GEN_PLD_W_EMPTY;\n\tret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,\n\t\t\t\t val, (val & mask) == mask,\n\t\t\t\t 1000, CMD_PKT_STATUS_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dsi->dev, \"failed to write command FIFO\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dw_mipi_dsi_write(struct dw_mipi_dsi *dsi,\n\t\t\t     const struct mipi_dsi_packet *packet)\n{\n\tconst u8 *tx_buf = packet->payload;\n\tint len = packet->payload_length, pld_data_bytes = sizeof(u32), ret;\n\t__le32 word;\n\tu32 val;\n\n\twhile (len) {\n\t\tif (len < pld_data_bytes) {\n\t\t\tword = 0;\n\t\t\tmemcpy(&word, tx_buf, len);\n\t\t\tdsi_write(dsi, DSI_GEN_PLD_DATA, le32_to_cpu(word));\n\t\t\tlen = 0;\n\t\t} else {\n\t\t\tmemcpy(&word, tx_buf, pld_data_bytes);\n\t\t\tdsi_write(dsi, DSI_GEN_PLD_DATA, le32_to_cpu(word));\n\t\t\ttx_buf += pld_data_bytes;\n\t\t\tlen -= pld_data_bytes;\n\t\t}\n\n\t\tret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,\n\t\t\t\t\t val, !(val & GEN_PLD_W_FULL), 1000,\n\t\t\t\t\t CMD_PKT_STATUS_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(dsi->dev,\n\t\t\t\t\"failed to get available write payload FIFO\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tword = 0;\n\tmemcpy(&word, packet->header, sizeof(packet->header));\n\treturn dw_mipi_dsi_gen_pkt_hdr_write(dsi, le32_to_cpu(word));\n}\n\nstatic int dw_mipi_dsi_read(struct dw_mipi_dsi *dsi,\n\t\t\t    const struct mipi_dsi_msg *msg)\n{\n\tint i, j, ret, len = msg->rx_len;\n\tu8 *buf = msg->rx_buf;\n\tu32 val;\n\n\t \n\tret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,\n\t\t\t\t val, !(val & GEN_RD_CMD_BUSY),\n\t\t\t\t 1000, CMD_PKT_STATUS_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dsi->dev, \"Timeout during read operation\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < len; i += 4) {\n\t\t \n\t\tret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,\n\t\t\t\t\t val, !(val & GEN_PLD_R_EMPTY),\n\t\t\t\t\t 1000, CMD_PKT_STATUS_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(dsi->dev, \"Read payload FIFO is empty\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tval = dsi_read(dsi, DSI_GEN_PLD_DATA);\n\t\tfor (j = 0; j < 4 && j + i < len; j++)\n\t\t\tbuf[i + j] = val >> (8 * j);\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t dw_mipi_dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t\t const struct mipi_dsi_msg *msg)\n{\n\tstruct dw_mipi_dsi *dsi = host_to_dsi(host);\n\tstruct mipi_dsi_packet packet;\n\tint ret, nb_bytes;\n\n\tret = mipi_dsi_create_packet(&packet, msg);\n\tif (ret) {\n\t\tdev_err(dsi->dev, \"failed to create packet: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdw_mipi_message_config(dsi, msg);\n\tif (dsi->slave)\n\t\tdw_mipi_message_config(dsi->slave, msg);\n\n\tret = dw_mipi_dsi_write(dsi, &packet);\n\tif (ret)\n\t\treturn ret;\n\tif (dsi->slave) {\n\t\tret = dw_mipi_dsi_write(dsi->slave, &packet);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (msg->rx_buf && msg->rx_len) {\n\t\tret = dw_mipi_dsi_read(dsi, msg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tnb_bytes = msg->rx_len;\n\t} else {\n\t\tnb_bytes = packet.size;\n\t}\n\n\treturn nb_bytes;\n}\n\nstatic const struct mipi_dsi_host_ops dw_mipi_dsi_host_ops = {\n\t.attach = dw_mipi_dsi_host_attach,\n\t.detach = dw_mipi_dsi_host_detach,\n\t.transfer = dw_mipi_dsi_host_transfer,\n};\n\nstatic void dw_mipi_dsi_video_mode_config(struct dw_mipi_dsi *dsi)\n{\n\tu32 val;\n\n\t \n\tval = ENABLE_LOW_POWER;\n\n\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)\n\t\tval |= VID_MODE_TYPE_BURST;\n\telse if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\tval |= VID_MODE_TYPE_NON_BURST_SYNC_PULSES;\n\telse\n\t\tval |= VID_MODE_TYPE_NON_BURST_SYNC_EVENTS;\n\n#ifdef CONFIG_DEBUG_FS\n\tif (dsi->vpg_defs.vpg) {\n\t\tval |= VID_MODE_VPG_ENABLE;\n\t\tval |= dsi->vpg_defs.vpg_horizontal ?\n\t\t       VID_MODE_VPG_HORIZONTAL : 0;\n\t\tval |= dsi->vpg_defs.vpg_ber_pattern ? VID_MODE_VPG_MODE : 0;\n\t}\n#endif  \n\n\tdsi_write(dsi, DSI_VID_MODE_CFG, val);\n}\n\nstatic void dw_mipi_dsi_set_mode(struct dw_mipi_dsi *dsi,\n\t\t\t\t unsigned long mode_flags)\n{\n\tu32 val;\n\n\tdsi_write(dsi, DSI_PWR_UP, RESET);\n\n\tif (mode_flags & MIPI_DSI_MODE_VIDEO) {\n\t\tdsi_write(dsi, DSI_MODE_CFG, ENABLE_VIDEO_MODE);\n\t\tdw_mipi_dsi_video_mode_config(dsi);\n\t} else {\n\t\tdsi_write(dsi, DSI_MODE_CFG, ENABLE_CMD_MODE);\n\t}\n\n\tval = PHY_TXREQUESTCLKHS;\n\tif (dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)\n\t\tval |= AUTO_CLKLANE_CTRL;\n\tdsi_write(dsi, DSI_LPCLK_CTRL, val);\n\n\tdsi_write(dsi, DSI_PWR_UP, POWERUP);\n}\n\nstatic void dw_mipi_dsi_disable(struct dw_mipi_dsi *dsi)\n{\n\tdsi_write(dsi, DSI_PWR_UP, RESET);\n\tdsi_write(dsi, DSI_PHY_RSTZ, PHY_RSTZ);\n}\n\nstatic void dw_mipi_dsi_init(struct dw_mipi_dsi *dsi)\n{\n\tconst struct dw_mipi_dsi_phy_ops *phy_ops = dsi->plat_data->phy_ops;\n\tunsigned int esc_rate;  \n\tu32 esc_clk_division;\n\tint ret;\n\n\t \n\tif (phy_ops->get_esc_clk_rate) {\n\t\tret = phy_ops->get_esc_clk_rate(dsi->plat_data->priv_data,\n\t\t\t\t\t\t&esc_rate);\n\t\tif (ret)\n\t\t\tDRM_DEBUG_DRIVER(\"Phy get_esc_clk_rate() failed\\n\");\n\t} else\n\t\tesc_rate = 20;  \n\n\t \n\tesc_clk_division = (dsi->lane_mbps >> 3) / esc_rate + 1;\n\n\tdsi_write(dsi, DSI_PWR_UP, RESET);\n\n\t \n\tdsi_write(dsi, DSI_CLKMGR_CFG, TO_CLK_DIVISION(10) |\n\t\t  TX_ESC_CLK_DIVISION(esc_clk_division));\n}\n\nstatic void dw_mipi_dsi_dpi_config(struct dw_mipi_dsi *dsi,\n\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tu32 val = 0, color = 0;\n\n\tswitch (dsi->format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\tcolor = DPI_COLOR_CODING_24BIT;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\tcolor = DPI_COLOR_CODING_18BIT_2 | LOOSELY18_EN;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\tcolor = DPI_COLOR_CODING_18BIT_1;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB565:\n\t\tcolor = DPI_COLOR_CODING_16BIT_1;\n\t\tbreak;\n\t}\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tval |= VSYNC_ACTIVE_LOW;\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tval |= HSYNC_ACTIVE_LOW;\n\n\tdsi_write(dsi, DSI_DPI_VCID, DPI_VCID(dsi->channel));\n\tdsi_write(dsi, DSI_DPI_COLOR_CODING, color);\n\tdsi_write(dsi, DSI_DPI_CFG_POL, val);\n}\n\nstatic void dw_mipi_dsi_packet_handler_config(struct dw_mipi_dsi *dsi)\n{\n\tdsi_write(dsi, DSI_PCKHDL_CFG, CRC_RX_EN | ECC_RX_EN | BTA_EN);\n}\n\nstatic void dw_mipi_dsi_video_packet_config(struct dw_mipi_dsi *dsi,\n\t\t\t\t\t    const struct drm_display_mode *mode)\n{\n\t \n\n\tdsi_write(dsi, DSI_VID_PKT_SIZE,\n\t\t       dw_mipi_is_dual_mode(dsi) ?\n\t\t\t\tVID_PKT_SIZE(mode->hdisplay / 2) :\n\t\t\t\tVID_PKT_SIZE(mode->hdisplay));\n}\n\nstatic void dw_mipi_dsi_command_mode_config(struct dw_mipi_dsi *dsi)\n{\n\t \n\tdsi_write(dsi, DSI_TO_CNT_CFG, HSTX_TO_CNT(1000) | LPRX_TO_CNT(1000));\n\t \n\tdsi_write(dsi, DSI_BTA_TO_CNT, 0xd00);\n\tdsi_write(dsi, DSI_MODE_CFG, ENABLE_CMD_MODE);\n}\n\n \nstatic u32 dw_mipi_dsi_get_hcomponent_lbcc(struct dw_mipi_dsi *dsi,\n\t\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t\t   u32 hcomponent)\n{\n\tu32 frac, lbcc;\n\n\tlbcc = hcomponent * dsi->lane_mbps * MSEC_PER_SEC / 8;\n\n\tfrac = lbcc % mode->clock;\n\tlbcc = lbcc / mode->clock;\n\tif (frac)\n\t\tlbcc++;\n\n\treturn lbcc;\n}\n\nstatic void dw_mipi_dsi_line_timer_config(struct dw_mipi_dsi *dsi,\n\t\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tu32 htotal, hsa, hbp, lbcc;\n\n\thtotal = mode->htotal;\n\thsa = mode->hsync_end - mode->hsync_start;\n\thbp = mode->htotal - mode->hsync_end;\n\n\t \n\tlbcc = dw_mipi_dsi_get_hcomponent_lbcc(dsi, mode, htotal);\n\tdsi_write(dsi, DSI_VID_HLINE_TIME, lbcc);\n\n\tlbcc = dw_mipi_dsi_get_hcomponent_lbcc(dsi, mode, hsa);\n\tdsi_write(dsi, DSI_VID_HSA_TIME, lbcc);\n\n\tlbcc = dw_mipi_dsi_get_hcomponent_lbcc(dsi, mode, hbp);\n\tdsi_write(dsi, DSI_VID_HBP_TIME, lbcc);\n}\n\nstatic void dw_mipi_dsi_vertical_timing_config(struct dw_mipi_dsi *dsi,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tu32 vactive, vsa, vfp, vbp;\n\n\tvactive = mode->vdisplay;\n\tvsa = mode->vsync_end - mode->vsync_start;\n\tvfp = mode->vsync_start - mode->vdisplay;\n\tvbp = mode->vtotal - mode->vsync_end;\n\n\tdsi_write(dsi, DSI_VID_VACTIVE_LINES, vactive);\n\tdsi_write(dsi, DSI_VID_VSA_LINES, vsa);\n\tdsi_write(dsi, DSI_VID_VFP_LINES, vfp);\n\tdsi_write(dsi, DSI_VID_VBP_LINES, vbp);\n}\n\nstatic void dw_mipi_dsi_dphy_timing_config(struct dw_mipi_dsi *dsi)\n{\n\tconst struct dw_mipi_dsi_phy_ops *phy_ops = dsi->plat_data->phy_ops;\n\tstruct dw_mipi_dsi_dphy_timing timing;\n\tu32 hw_version;\n\tint ret;\n\n\tret = phy_ops->get_timing(dsi->plat_data->priv_data,\n\t\t\t\t  dsi->lane_mbps, &timing);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dsi->dev, \"Retrieving phy timings failed\\n\");\n\n\t \n\n\thw_version = dsi_read(dsi, DSI_VERSION) & VERSION;\n\n\tif (hw_version >= HWVER_131) {\n\t\tdsi_write(dsi, DSI_PHY_TMR_CFG,\n\t\t\t  PHY_HS2LP_TIME_V131(timing.data_hs2lp) |\n\t\t\t  PHY_LP2HS_TIME_V131(timing.data_lp2hs));\n\t\tdsi_write(dsi, DSI_PHY_TMR_RD_CFG, MAX_RD_TIME_V131(10000));\n\t} else {\n\t\tdsi_write(dsi, DSI_PHY_TMR_CFG,\n\t\t\t  PHY_HS2LP_TIME(timing.data_hs2lp) |\n\t\t\t  PHY_LP2HS_TIME(timing.data_lp2hs) |\n\t\t\t  MAX_RD_TIME(10000));\n\t}\n\n\tdsi_write(dsi, DSI_PHY_TMR_LPCLK_CFG,\n\t\t  PHY_CLKHS2LP_TIME(timing.clk_hs2lp) |\n\t\t  PHY_CLKLP2HS_TIME(timing.clk_lp2hs));\n}\n\nstatic void dw_mipi_dsi_dphy_interface_config(struct dw_mipi_dsi *dsi)\n{\n\t \n\tdsi_write(dsi, DSI_PHY_IF_CFG, PHY_STOP_WAIT_TIME(0x20) |\n\t\t  N_LANES(dsi->lanes));\n}\n\nstatic void dw_mipi_dsi_dphy_init(struct dw_mipi_dsi *dsi)\n{\n\t \n\tdsi_write(dsi, DSI_PHY_RSTZ, PHY_DISFORCEPLL | PHY_DISABLECLK\n\t\t  | PHY_RSTZ | PHY_SHUTDOWNZ);\n\tdsi_write(dsi, DSI_PHY_TST_CTRL0, PHY_UNTESTCLR);\n\tdsi_write(dsi, DSI_PHY_TST_CTRL0, PHY_TESTCLR);\n\tdsi_write(dsi, DSI_PHY_TST_CTRL0, PHY_UNTESTCLR);\n}\n\nstatic void dw_mipi_dsi_dphy_enable(struct dw_mipi_dsi *dsi)\n{\n\tu32 val;\n\tint ret;\n\n\tdsi_write(dsi, DSI_PHY_RSTZ, PHY_ENFORCEPLL | PHY_ENABLECLK |\n\t\t  PHY_UNRSTZ | PHY_UNSHUTDOWNZ);\n\n\tret = readl_poll_timeout(dsi->base + DSI_PHY_STATUS, val,\n\t\t\t\t val & PHY_LOCK, 1000, PHY_STATUS_TIMEOUT_US);\n\tif (ret)\n\t\tDRM_DEBUG_DRIVER(\"failed to wait phy lock state\\n\");\n\n\tret = readl_poll_timeout(dsi->base + DSI_PHY_STATUS,\n\t\t\t\t val, val & PHY_STOP_STATE_CLK_LANE, 1000,\n\t\t\t\t PHY_STATUS_TIMEOUT_US);\n\tif (ret)\n\t\tDRM_DEBUG_DRIVER(\"failed to wait phy clk lane stop state\\n\");\n}\n\nstatic void dw_mipi_dsi_clear_err(struct dw_mipi_dsi *dsi)\n{\n\tdsi_read(dsi, DSI_INT_ST0);\n\tdsi_read(dsi, DSI_INT_ST1);\n\tdsi_write(dsi, DSI_INT_MSK0, 0);\n\tdsi_write(dsi, DSI_INT_MSK1, 0);\n}\n\nstatic void dw_mipi_dsi_bridge_post_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t\t   struct drm_bridge_state *old_bridge_state)\n{\n\tstruct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);\n\tconst struct dw_mipi_dsi_phy_ops *phy_ops = dsi->plat_data->phy_ops;\n\n\t \n\tdw_mipi_dsi_set_mode(dsi, 0);\n\n\tif (phy_ops->power_off)\n\t\tphy_ops->power_off(dsi->plat_data->priv_data);\n\n\tif (dsi->slave) {\n\t\tdw_mipi_dsi_disable(dsi->slave);\n\t\tclk_disable_unprepare(dsi->slave->pclk);\n\t\tpm_runtime_put(dsi->slave->dev);\n\t}\n\tdw_mipi_dsi_disable(dsi);\n\n\tclk_disable_unprepare(dsi->pclk);\n\tpm_runtime_put(dsi->dev);\n}\n\nstatic unsigned int dw_mipi_dsi_get_lanes(struct dw_mipi_dsi *dsi)\n{\n\t \n\tif (dsi->master)\n\t\treturn dsi->master->lanes + dsi->lanes;\n\n\t \n\tif (dsi->slave)\n\t\treturn dsi->lanes + dsi->slave->lanes;\n\n\t \n\treturn dsi->lanes;\n}\n\nstatic void dw_mipi_dsi_mode_set(struct dw_mipi_dsi *dsi,\n\t\t\t\t const struct drm_display_mode *adjusted_mode)\n{\n\tconst struct dw_mipi_dsi_phy_ops *phy_ops = dsi->plat_data->phy_ops;\n\tvoid *priv_data = dsi->plat_data->priv_data;\n\tint ret;\n\tu32 lanes = dw_mipi_dsi_get_lanes(dsi);\n\n\tclk_prepare_enable(dsi->pclk);\n\n\tret = phy_ops->get_lane_mbps(priv_data, adjusted_mode, dsi->mode_flags,\n\t\t\t\t     lanes, dsi->format, &dsi->lane_mbps);\n\tif (ret)\n\t\tDRM_DEBUG_DRIVER(\"Phy get_lane_mbps() failed\\n\");\n\n\tpm_runtime_get_sync(dsi->dev);\n\tdw_mipi_dsi_init(dsi);\n\tdw_mipi_dsi_dpi_config(dsi, adjusted_mode);\n\tdw_mipi_dsi_packet_handler_config(dsi);\n\tdw_mipi_dsi_video_mode_config(dsi);\n\tdw_mipi_dsi_video_packet_config(dsi, adjusted_mode);\n\tdw_mipi_dsi_command_mode_config(dsi);\n\tdw_mipi_dsi_line_timer_config(dsi, adjusted_mode);\n\tdw_mipi_dsi_vertical_timing_config(dsi, adjusted_mode);\n\n\tdw_mipi_dsi_dphy_init(dsi);\n\tdw_mipi_dsi_dphy_timing_config(dsi);\n\tdw_mipi_dsi_dphy_interface_config(dsi);\n\n\tdw_mipi_dsi_clear_err(dsi);\n\n\tret = phy_ops->init(priv_data);\n\tif (ret)\n\t\tDRM_DEBUG_DRIVER(\"Phy init() failed\\n\");\n\n\tdw_mipi_dsi_dphy_enable(dsi);\n\n\tdw_mipi_dsi_wait_for_two_frames(adjusted_mode);\n\n\t \n\tdw_mipi_dsi_set_mode(dsi, 0);\n\n\tif (phy_ops->power_on)\n\t\tphy_ops->power_on(dsi->plat_data->priv_data);\n}\n\nstatic void dw_mipi_dsi_bridge_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t\t\t struct drm_bridge_state *old_bridge_state)\n{\n\tstruct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);\n\n\t \n\tdw_mipi_dsi_mode_set(dsi, &dsi->mode);\n\tif (dsi->slave)\n\t\tdw_mipi_dsi_mode_set(dsi->slave, &dsi->mode);\n}\n\nstatic void dw_mipi_dsi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\t\tconst struct drm_display_mode *adjusted_mode)\n{\n\tstruct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);\n\n\t \n\tdrm_mode_copy(&dsi->mode, adjusted_mode);\n}\n\nstatic void dw_mipi_dsi_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);\n\n\t \n\tdw_mipi_dsi_set_mode(dsi, MIPI_DSI_MODE_VIDEO);\n\tif (dsi->slave)\n\t\tdw_mipi_dsi_set_mode(dsi->slave, MIPI_DSI_MODE_VIDEO);\n}\n\nstatic enum drm_mode_status\ndw_mipi_dsi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t      const struct drm_display_info *info,\n\t\t\t      const struct drm_display_mode *mode)\n{\n\tstruct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);\n\tconst struct dw_mipi_dsi_plat_data *pdata = dsi->plat_data;\n\tenum drm_mode_status mode_status = MODE_OK;\n\n\tif (pdata->mode_valid)\n\t\tmode_status = pdata->mode_valid(pdata->priv_data, mode,\n\t\t\t\t\t\tdsi->mode_flags,\n\t\t\t\t\t\tdw_mipi_dsi_get_lanes(dsi),\n\t\t\t\t\t\tdsi->format);\n\n\treturn mode_status;\n}\n\nstatic int dw_mipi_dsi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\tstruct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);\n\n\tif (!bridge->encoder) {\n\t\tDRM_ERROR(\"Parent encoder object not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tbridge->encoder->encoder_type = DRM_MODE_ENCODER_DSI;\n\n\t \n\treturn drm_bridge_attach(bridge->encoder, dsi->panel_bridge, bridge,\n\t\t\t\t flags);\n}\n\nstatic const struct drm_bridge_funcs dw_mipi_dsi_bridge_funcs = {\n\t.atomic_duplicate_state\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset\t\t= drm_atomic_helper_bridge_reset,\n\t.atomic_pre_enable\t= dw_mipi_dsi_bridge_atomic_pre_enable,\n\t.atomic_enable\t\t= dw_mipi_dsi_bridge_atomic_enable,\n\t.atomic_post_disable\t= dw_mipi_dsi_bridge_post_atomic_disable,\n\t.mode_set\t\t= dw_mipi_dsi_bridge_mode_set,\n\t.mode_valid\t\t= dw_mipi_dsi_bridge_mode_valid,\n\t.attach\t\t\t= dw_mipi_dsi_bridge_attach,\n};\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic int dw_mipi_dsi_debugfs_write(void *data, u64 val)\n{\n\tstruct debugfs_entries *vpg = data;\n\tstruct dw_mipi_dsi *dsi;\n\tu32 mode_cfg;\n\n\tif (!vpg)\n\t\treturn -ENODEV;\n\n\tdsi = vpg->dsi;\n\n\t*vpg->reg = (bool)val;\n\n\tmode_cfg = dsi_read(dsi, DSI_VID_MODE_CFG);\n\n\tif (*vpg->reg)\n\t\tmode_cfg |= vpg->mask;\n\telse\n\t\tmode_cfg &= ~vpg->mask;\n\n\tdsi_write(dsi, DSI_VID_MODE_CFG, mode_cfg);\n\n\treturn 0;\n}\n\nstatic int dw_mipi_dsi_debugfs_show(void *data, u64 *val)\n{\n\tstruct debugfs_entries *vpg = data;\n\n\tif (!vpg)\n\t\treturn -ENODEV;\n\n\t*val = *vpg->reg;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x32, dw_mipi_dsi_debugfs_show,\n\t\t\t dw_mipi_dsi_debugfs_write, \"%llu\\n\");\n\nstatic void debugfs_create_files(void *data)\n{\n\tstruct dw_mipi_dsi *dsi = data;\n\tstruct debugfs_entries debugfs[] = {\n\t\tREGISTER(vpg, VID_MODE_VPG_ENABLE, dsi),\n\t\tREGISTER(vpg_horizontal, VID_MODE_VPG_HORIZONTAL, dsi),\n\t\tREGISTER(vpg_ber_pattern, VID_MODE_VPG_MODE, dsi),\n\t};\n\tint i;\n\n\tdsi->debugfs_vpg = kmemdup(debugfs, sizeof(debugfs), GFP_KERNEL);\n\tif (!dsi->debugfs_vpg)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(debugfs); i++)\n\t\tdebugfs_create_file(dsi->debugfs_vpg[i].name, 0644,\n\t\t\t\t    dsi->debugfs, &dsi->debugfs_vpg[i],\n\t\t\t\t    &fops_x32);\n}\n\nstatic void dw_mipi_dsi_debugfs_init(struct dw_mipi_dsi *dsi)\n{\n\tdsi->debugfs = debugfs_create_dir(dev_name(dsi->dev), NULL);\n\tif (IS_ERR(dsi->debugfs)) {\n\t\tdev_err(dsi->dev, \"failed to create debugfs root\\n\");\n\t\treturn;\n\t}\n\n\tdebugfs_create_files(dsi);\n}\n\nstatic void dw_mipi_dsi_debugfs_remove(struct dw_mipi_dsi *dsi)\n{\n\tdebugfs_remove_recursive(dsi->debugfs);\n\tkfree(dsi->debugfs_vpg);\n}\n\n#else\n\nstatic void dw_mipi_dsi_debugfs_init(struct dw_mipi_dsi *dsi) { }\nstatic void dw_mipi_dsi_debugfs_remove(struct dw_mipi_dsi *dsi) { }\n\n#endif  \n\nstatic struct dw_mipi_dsi *\n__dw_mipi_dsi_probe(struct platform_device *pdev,\n\t\t    const struct dw_mipi_dsi_plat_data *plat_data)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct reset_control *apb_rst;\n\tstruct dw_mipi_dsi *dsi;\n\tint ret;\n\n\tdsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdsi->dev = dev;\n\tdsi->plat_data = plat_data;\n\n\tif (!plat_data->phy_ops->init || !plat_data->phy_ops->get_lane_mbps ||\n\t    !plat_data->phy_ops->get_timing) {\n\t\tDRM_ERROR(\"Phy not properly configured\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tif (!plat_data->base) {\n\t\tdsi->base = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(dsi->base))\n\t\t\treturn ERR_PTR(-ENODEV);\n\n\t} else {\n\t\tdsi->base = plat_data->base;\n\t}\n\n\tdsi->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(dsi->pclk)) {\n\t\tret = PTR_ERR(dsi->pclk);\n\t\tdev_err(dev, \"Unable to get pclk: %d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tapb_rst = devm_reset_control_get_optional_exclusive(dev, \"apb\");\n\tif (IS_ERR(apb_rst)) {\n\t\tret = PTR_ERR(apb_rst);\n\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Unable to get reset control: %d\\n\", ret);\n\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (apb_rst) {\n\t\tret = clk_prepare_enable(dsi->pclk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: Failed to enable pclk\\n\", __func__);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\treset_control_assert(apb_rst);\n\t\tusleep_range(10, 20);\n\t\treset_control_deassert(apb_rst);\n\n\t\tclk_disable_unprepare(dsi->pclk);\n\t}\n\n\tdw_mipi_dsi_debugfs_init(dsi);\n\tpm_runtime_enable(dev);\n\n\tdsi->dsi_host.ops = &dw_mipi_dsi_host_ops;\n\tdsi->dsi_host.dev = dev;\n\tret = mipi_dsi_host_register(&dsi->dsi_host);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register MIPI host: %d\\n\", ret);\n\t\tpm_runtime_disable(dev);\n\t\tdw_mipi_dsi_debugfs_remove(dsi);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdsi->bridge.driver_private = dsi;\n\tdsi->bridge.funcs = &dw_mipi_dsi_bridge_funcs;\n#ifdef CONFIG_OF\n\tdsi->bridge.of_node = pdev->dev.of_node;\n#endif\n\n\treturn dsi;\n}\n\nstatic void __dw_mipi_dsi_remove(struct dw_mipi_dsi *dsi)\n{\n\tmipi_dsi_host_unregister(&dsi->dsi_host);\n\n\tpm_runtime_disable(dsi->dev);\n\tdw_mipi_dsi_debugfs_remove(dsi);\n}\n\nvoid dw_mipi_dsi_set_slave(struct dw_mipi_dsi *dsi, struct dw_mipi_dsi *slave)\n{\n\t \n\tdsi->slave = slave;\n\tdsi->slave->master = dsi;\n\n\t \n\tdsi->slave->lanes = dsi->lanes;\n\tdsi->slave->channel = dsi->channel;\n\tdsi->slave->format = dsi->format;\n\tdsi->slave->mode_flags = dsi->mode_flags;\n}\nEXPORT_SYMBOL_GPL(dw_mipi_dsi_set_slave);\n\n \nstruct dw_mipi_dsi *\ndw_mipi_dsi_probe(struct platform_device *pdev,\n\t\t  const struct dw_mipi_dsi_plat_data *plat_data)\n{\n\treturn __dw_mipi_dsi_probe(pdev, plat_data);\n}\nEXPORT_SYMBOL_GPL(dw_mipi_dsi_probe);\n\nvoid dw_mipi_dsi_remove(struct dw_mipi_dsi *dsi)\n{\n\t__dw_mipi_dsi_remove(dsi);\n}\nEXPORT_SYMBOL_GPL(dw_mipi_dsi_remove);\n\n \nint dw_mipi_dsi_bind(struct dw_mipi_dsi *dsi, struct drm_encoder *encoder)\n{\n\treturn drm_bridge_attach(encoder, &dsi->bridge, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(dw_mipi_dsi_bind);\n\nvoid dw_mipi_dsi_unbind(struct dw_mipi_dsi *dsi)\n{\n}\nEXPORT_SYMBOL_GPL(dw_mipi_dsi_unbind);\n\nMODULE_AUTHOR(\"Chris Zhong <zyw@rock-chips.com>\");\nMODULE_AUTHOR(\"Philippe Cornu <philippe.cornu@st.com>\");\nMODULE_DESCRIPTION(\"DW MIPI DSI host controller driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:dw-mipi-dsi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}