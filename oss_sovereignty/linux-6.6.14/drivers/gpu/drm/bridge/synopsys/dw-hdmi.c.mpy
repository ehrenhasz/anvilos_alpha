{
  "module_name": "dw-hdmi.c",
  "hash_id": "c2c81f2f1c2f30c78fe9dec008ae39aaf9d7e73aad73846c9843d4d770e185bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/hdmi.h>\n#include <linux/i2c.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/regmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/spinlock.h>\n\n#include <media/cec-notifier.h>\n\n#include <uapi/linux/media-bus-format.h>\n#include <uapi/linux/videodev2.h>\n\n#include <drm/bridge/dw_hdmi.h>\n#include <drm/display/drm_hdmi_helper.h>\n#include <drm/display/drm_scdc_helper.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"dw-hdmi-audio.h\"\n#include \"dw-hdmi-cec.h\"\n#include \"dw-hdmi.h\"\n\n#define DDC_CI_ADDR\t\t0x37\n#define DDC_SEGMENT_ADDR\t0x30\n\n#define HDMI_EDID_LEN\t\t512\n\n \n#define SCDC_MIN_SOURCE_VERSION\t0x1\n\n#define HDMI14_MAX_TMDSCLK\t340000000\n\nstatic const u16 csc_coeff_default[3][4] = {\n\t{ 0x2000, 0x0000, 0x0000, 0x0000 },\n\t{ 0x0000, 0x2000, 0x0000, 0x0000 },\n\t{ 0x0000, 0x0000, 0x2000, 0x0000 }\n};\n\nstatic const u16 csc_coeff_rgb_out_eitu601[3][4] = {\n\t{ 0x2000, 0x6926, 0x74fd, 0x010e },\n\t{ 0x2000, 0x2cdd, 0x0000, 0x7e9a },\n\t{ 0x2000, 0x0000, 0x38b4, 0x7e3b }\n};\n\nstatic const u16 csc_coeff_rgb_out_eitu709[3][4] = {\n\t{ 0x2000, 0x7106, 0x7a02, 0x00a7 },\n\t{ 0x2000, 0x3264, 0x0000, 0x7e6d },\n\t{ 0x2000, 0x0000, 0x3b61, 0x7e25 }\n};\n\nstatic const u16 csc_coeff_rgb_in_eitu601[3][4] = {\n\t{ 0x2591, 0x1322, 0x074b, 0x0000 },\n\t{ 0x6535, 0x2000, 0x7acc, 0x0200 },\n\t{ 0x6acd, 0x7534, 0x2000, 0x0200 }\n};\n\nstatic const u16 csc_coeff_rgb_in_eitu709[3][4] = {\n\t{ 0x2dc5, 0x0d9b, 0x049e, 0x0000 },\n\t{ 0x62f0, 0x2000, 0x7d11, 0x0200 },\n\t{ 0x6756, 0x78ab, 0x2000, 0x0200 }\n};\n\nstatic const u16 csc_coeff_rgb_full_to_rgb_limited[3][4] = {\n\t{ 0x1b7c, 0x0000, 0x0000, 0x0020 },\n\t{ 0x0000, 0x1b7c, 0x0000, 0x0020 },\n\t{ 0x0000, 0x0000, 0x1b7c, 0x0020 }\n};\n\nstruct hdmi_vmode {\n\tbool mdataenablepolarity;\n\n\tunsigned int mpixelclock;\n\tunsigned int mpixelrepetitioninput;\n\tunsigned int mpixelrepetitionoutput;\n\tunsigned int mtmdsclock;\n};\n\nstruct hdmi_data_info {\n\tunsigned int enc_in_bus_format;\n\tunsigned int enc_out_bus_format;\n\tunsigned int enc_in_encoding;\n\tunsigned int enc_out_encoding;\n\tunsigned int pix_repet_factor;\n\tunsigned int hdcp_enable;\n\tstruct hdmi_vmode video_mode;\n\tbool rgb_limited_range;\n};\n\nstruct dw_hdmi_i2c {\n\tstruct i2c_adapter\tadap;\n\n\tstruct mutex\t\tlock;\t \n\tstruct completion\tcmp;\n\tu8\t\t\tstat;\n\n\tu8\t\t\tslave_reg;\n\tbool\t\t\tis_regaddr;\n\tbool\t\t\tis_segment;\n};\n\nstruct dw_hdmi_phy_data {\n\tenum dw_hdmi_phy_type type;\n\tconst char *name;\n\tunsigned int gen;\n\tbool has_svsret;\n\tint (*configure)(struct dw_hdmi *hdmi,\n\t\t\t const struct dw_hdmi_plat_data *pdata,\n\t\t\t unsigned long mpixelclock);\n};\n\nstruct dw_hdmi {\n\tstruct drm_connector connector;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\n\tunsigned int version;\n\n\tstruct platform_device *audio;\n\tstruct platform_device *cec;\n\tstruct device *dev;\n\tstruct clk *isfr_clk;\n\tstruct clk *iahb_clk;\n\tstruct clk *cec_clk;\n\tstruct dw_hdmi_i2c *i2c;\n\n\tstruct hdmi_data_info hdmi_data;\n\tconst struct dw_hdmi_plat_data *plat_data;\n\n\tint vic;\n\n\tu8 edid[HDMI_EDID_LEN];\n\n\tstruct {\n\t\tconst struct dw_hdmi_phy_ops *ops;\n\t\tconst char *name;\n\t\tvoid *data;\n\t\tbool enabled;\n\t} phy;\n\n\tstruct drm_display_mode previous_mode;\n\n\tstruct i2c_adapter *ddc;\n\tvoid __iomem *regs;\n\tbool sink_is_hdmi;\n\tbool sink_has_audio;\n\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *default_state;\n\tstruct pinctrl_state *unwedge_state;\n\n\tstruct mutex mutex;\t\t \n\tenum drm_connector_force force;\t \n\tstruct drm_connector *curr_conn; \n\tbool disabled;\t\t\t \n\tbool bridge_is_on;\t\t \n\tbool rxsense;\t\t\t \n\tu8 phy_mask;\t\t\t \n\tu8 mc_clkdis;\t\t\t \n\n\tspinlock_t audio_lock;\n\tstruct mutex audio_mutex;\n\tunsigned int sample_non_pcm;\n\tunsigned int sample_width;\n\tunsigned int sample_rate;\n\tunsigned int channels;\n\tunsigned int audio_cts;\n\tunsigned int audio_n;\n\tbool audio_enable;\n\n\tunsigned int reg_shift;\n\tstruct regmap *regm;\n\tvoid (*enable_audio)(struct dw_hdmi *hdmi);\n\tvoid (*disable_audio)(struct dw_hdmi *hdmi);\n\n\tstruct mutex cec_notifier_mutex;\n\tstruct cec_notifier *cec_notifier;\n\n\thdmi_codec_plugged_cb plugged_cb;\n\tstruct device *codec_dev;\n\tenum drm_connector_status last_connector_result;\n};\n\n#define HDMI_IH_PHY_STAT0_RX_SENSE \\\n\t(HDMI_IH_PHY_STAT0_RX_SENSE0 | HDMI_IH_PHY_STAT0_RX_SENSE1 | \\\n\t HDMI_IH_PHY_STAT0_RX_SENSE2 | HDMI_IH_PHY_STAT0_RX_SENSE3)\n\n#define HDMI_PHY_RX_SENSE \\\n\t(HDMI_PHY_RX_SENSE0 | HDMI_PHY_RX_SENSE1 | \\\n\t HDMI_PHY_RX_SENSE2 | HDMI_PHY_RX_SENSE3)\n\nstatic inline void hdmi_writeb(struct dw_hdmi *hdmi, u8 val, int offset)\n{\n\tregmap_write(hdmi->regm, offset << hdmi->reg_shift, val);\n}\n\nstatic inline u8 hdmi_readb(struct dw_hdmi *hdmi, int offset)\n{\n\tunsigned int val = 0;\n\n\tregmap_read(hdmi->regm, offset << hdmi->reg_shift, &val);\n\n\treturn val;\n}\n\nstatic void handle_plugged_change(struct dw_hdmi *hdmi, bool plugged)\n{\n\tif (hdmi->plugged_cb && hdmi->codec_dev)\n\t\thdmi->plugged_cb(hdmi->codec_dev, plugged);\n}\n\nint dw_hdmi_set_plugged_cb(struct dw_hdmi *hdmi, hdmi_codec_plugged_cb fn,\n\t\t\t   struct device *codec_dev)\n{\n\tbool plugged;\n\n\tmutex_lock(&hdmi->mutex);\n\thdmi->plugged_cb = fn;\n\thdmi->codec_dev = codec_dev;\n\tplugged = hdmi->last_connector_result == connector_status_connected;\n\thandle_plugged_change(hdmi, plugged);\n\tmutex_unlock(&hdmi->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_set_plugged_cb);\n\nstatic void hdmi_modb(struct dw_hdmi *hdmi, u8 data, u8 mask, unsigned reg)\n{\n\tregmap_update_bits(hdmi->regm, reg << hdmi->reg_shift, mask, data);\n}\n\nstatic void hdmi_mask_writeb(struct dw_hdmi *hdmi, u8 data, unsigned int reg,\n\t\t\t     u8 shift, u8 mask)\n{\n\thdmi_modb(hdmi, data << shift, mask, reg);\n}\n\nstatic void dw_hdmi_i2c_init(struct dw_hdmi *hdmi)\n{\n\thdmi_writeb(hdmi, HDMI_PHY_I2CM_INT_ADDR_DONE_POL,\n\t\t    HDMI_PHY_I2CM_INT_ADDR);\n\n\thdmi_writeb(hdmi, HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL |\n\t\t    HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL,\n\t\t    HDMI_PHY_I2CM_CTLINT_ADDR);\n\n\t \n\thdmi_writeb(hdmi, 0x00, HDMI_I2CM_SOFTRSTZ);\n\n\t \n\thdmi_writeb(hdmi, 0x00, HDMI_I2CM_DIV);\n\n\t \n\thdmi_writeb(hdmi, HDMI_I2CM_INT_DONE_POL, HDMI_I2CM_INT);\n\thdmi_writeb(hdmi, HDMI_I2CM_CTLINT_NAC_POL | HDMI_I2CM_CTLINT_ARB_POL,\n\t\t    HDMI_I2CM_CTLINT);\n\n\t \n\thdmi_writeb(hdmi, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,\n\t\t    HDMI_IH_I2CM_STAT0);\n\n\t \n\thdmi_writeb(hdmi, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,\n\t\t    HDMI_IH_MUTE_I2CM_STAT0);\n}\n\nstatic bool dw_hdmi_i2c_unwedge(struct dw_hdmi *hdmi)\n{\n\t \n\tif (!hdmi->unwedge_state)\n\t\treturn false;\n\n\tdev_info(hdmi->dev, \"Attempting to unwedge stuck i2c bus\\n\");\n\n\t \n\tpinctrl_select_state(hdmi->pinctrl, hdmi->unwedge_state);\n\tmsleep(10);\n\tpinctrl_select_state(hdmi->pinctrl, hdmi->default_state);\n\n\treturn true;\n}\n\nstatic int dw_hdmi_i2c_wait(struct dw_hdmi *hdmi)\n{\n\tstruct dw_hdmi_i2c *i2c = hdmi->i2c;\n\tint stat;\n\n\tstat = wait_for_completion_timeout(&i2c->cmp, HZ / 10);\n\tif (!stat) {\n\t\t \n\t\tif (!dw_hdmi_i2c_unwedge(hdmi))\n\t\t\treturn -EAGAIN;\n\n\t\t \n\t\tstat = wait_for_completion_timeout(&i2c->cmp, HZ / 10);\n\t\tif (!stat)\n\t\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (i2c->stat & HDMI_IH_I2CM_STAT0_ERROR)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int dw_hdmi_i2c_read(struct dw_hdmi *hdmi,\n\t\t\t    unsigned char *buf, unsigned int length)\n{\n\tstruct dw_hdmi_i2c *i2c = hdmi->i2c;\n\tint ret;\n\n\tif (!i2c->is_regaddr) {\n\t\tdev_dbg(hdmi->dev, \"set read register address to 0\\n\");\n\t\ti2c->slave_reg = 0x00;\n\t\ti2c->is_regaddr = true;\n\t}\n\n\twhile (length--) {\n\t\treinit_completion(&i2c->cmp);\n\n\t\thdmi_writeb(hdmi, i2c->slave_reg++, HDMI_I2CM_ADDRESS);\n\t\tif (i2c->is_segment)\n\t\t\thdmi_writeb(hdmi, HDMI_I2CM_OPERATION_READ_EXT,\n\t\t\t\t    HDMI_I2CM_OPERATION);\n\t\telse\n\t\t\thdmi_writeb(hdmi, HDMI_I2CM_OPERATION_READ,\n\t\t\t\t    HDMI_I2CM_OPERATION);\n\n\t\tret = dw_hdmi_i2c_wait(hdmi);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*buf++ = hdmi_readb(hdmi, HDMI_I2CM_DATAI);\n\t}\n\ti2c->is_segment = false;\n\n\treturn 0;\n}\n\nstatic int dw_hdmi_i2c_write(struct dw_hdmi *hdmi,\n\t\t\t     unsigned char *buf, unsigned int length)\n{\n\tstruct dw_hdmi_i2c *i2c = hdmi->i2c;\n\tint ret;\n\n\tif (!i2c->is_regaddr) {\n\t\t \n\t\ti2c->slave_reg = buf[0];\n\t\tlength--;\n\t\tbuf++;\n\t\ti2c->is_regaddr = true;\n\t}\n\n\twhile (length--) {\n\t\treinit_completion(&i2c->cmp);\n\n\t\thdmi_writeb(hdmi, *buf++, HDMI_I2CM_DATAO);\n\t\thdmi_writeb(hdmi, i2c->slave_reg++, HDMI_I2CM_ADDRESS);\n\t\thdmi_writeb(hdmi, HDMI_I2CM_OPERATION_WRITE,\n\t\t\t    HDMI_I2CM_OPERATION);\n\n\t\tret = dw_hdmi_i2c_wait(hdmi);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dw_hdmi_i2c_xfer(struct i2c_adapter *adap,\n\t\t\t    struct i2c_msg *msgs, int num)\n{\n\tstruct dw_hdmi *hdmi = i2c_get_adapdata(adap);\n\tstruct dw_hdmi_i2c *i2c = hdmi->i2c;\n\tu8 addr = msgs[0].addr;\n\tint i, ret = 0;\n\n\tif (addr == DDC_CI_ADDR)\n\t\t \n\t\treturn -EOPNOTSUPP;\n\n\tdev_dbg(hdmi->dev, \"xfer: num: %d, addr: %#x\\n\", num, addr);\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (msgs[i].len == 0) {\n\t\t\tdev_dbg(hdmi->dev,\n\t\t\t\t\"unsupported transfer %d/%d, no data\\n\",\n\t\t\t\ti + 1, num);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tmutex_lock(&i2c->lock);\n\n\t \n\thdmi_writeb(hdmi, 0x00, HDMI_IH_MUTE_I2CM_STAT0);\n\n\t \n\thdmi_writeb(hdmi, addr, HDMI_I2CM_SLAVE);\n\n\t \n\ti2c->is_regaddr = false;\n\n\t \n\ti2c->is_segment = false;\n\n\tfor (i = 0; i < num; i++) {\n\t\tdev_dbg(hdmi->dev, \"xfer: num: %d/%d, len: %d, flags: %#x\\n\",\n\t\t\ti + 1, num, msgs[i].len, msgs[i].flags);\n\t\tif (msgs[i].addr == DDC_SEGMENT_ADDR && msgs[i].len == 1) {\n\t\t\ti2c->is_segment = true;\n\t\t\thdmi_writeb(hdmi, DDC_SEGMENT_ADDR, HDMI_I2CM_SEGADDR);\n\t\t\thdmi_writeb(hdmi, *msgs[i].buf, HDMI_I2CM_SEGPTR);\n\t\t} else {\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\tret = dw_hdmi_i2c_read(hdmi, msgs[i].buf,\n\t\t\t\t\t\t       msgs[i].len);\n\t\t\telse\n\t\t\t\tret = dw_hdmi_i2c_write(hdmi, msgs[i].buf,\n\t\t\t\t\t\t\tmsgs[i].len);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tret = num;\n\n\t \n\thdmi_writeb(hdmi, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,\n\t\t    HDMI_IH_MUTE_I2CM_STAT0);\n\n\tmutex_unlock(&i2c->lock);\n\n\treturn ret;\n}\n\nstatic u32 dw_hdmi_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm dw_hdmi_algorithm = {\n\t.master_xfer\t= dw_hdmi_i2c_xfer,\n\t.functionality\t= dw_hdmi_i2c_func,\n};\n\nstatic struct i2c_adapter *dw_hdmi_i2c_adapter(struct dw_hdmi *hdmi)\n{\n\tstruct i2c_adapter *adap;\n\tstruct dw_hdmi_i2c *i2c;\n\tint ret;\n\n\ti2c = devm_kzalloc(hdmi->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&i2c->lock);\n\tinit_completion(&i2c->cmp);\n\n\tadap = &i2c->adap;\n\tadap->class = I2C_CLASS_DDC;\n\tadap->owner = THIS_MODULE;\n\tadap->dev.parent = hdmi->dev;\n\tadap->algo = &dw_hdmi_algorithm;\n\tstrscpy(adap->name, \"DesignWare HDMI\", sizeof(adap->name));\n\ti2c_set_adapdata(adap, hdmi);\n\n\tret = i2c_add_adapter(adap);\n\tif (ret) {\n\t\tdev_warn(hdmi->dev, \"cannot add %s I2C adapter\\n\", adap->name);\n\t\tdevm_kfree(hdmi->dev, i2c);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\thdmi->i2c = i2c;\n\n\tdev_info(hdmi->dev, \"registered %s I2C bus driver\\n\", adap->name);\n\n\treturn adap;\n}\n\nstatic void hdmi_set_cts_n(struct dw_hdmi *hdmi, unsigned int cts,\n\t\t\t   unsigned int n)\n{\n\t \n\thdmi_modb(hdmi, 0, HDMI_AUD_CTS3_CTS_MANUAL, HDMI_AUD_CTS3);\n\n\t \n\thdmi_modb(hdmi, 0, HDMI_AUD_CTS3_N_SHIFT_MASK, HDMI_AUD_CTS3);\n\n\t \n\tif (cts)\n\t\thdmi_writeb(hdmi, ((cts >> 16) &\n\t\t\t\t   HDMI_AUD_CTS3_AUDCTS19_16_MASK) |\n\t\t\t\t  HDMI_AUD_CTS3_CTS_MANUAL,\n\t\t\t    HDMI_AUD_CTS3);\n\telse\n\t\thdmi_writeb(hdmi, 0, HDMI_AUD_CTS3);\n\thdmi_writeb(hdmi, (cts >> 8) & 0xff, HDMI_AUD_CTS2);\n\thdmi_writeb(hdmi, cts & 0xff, HDMI_AUD_CTS1);\n\n\thdmi_writeb(hdmi, (n >> 16) & 0x0f, HDMI_AUD_N3);\n\thdmi_writeb(hdmi, (n >> 8) & 0xff, HDMI_AUD_N2);\n\thdmi_writeb(hdmi, n & 0xff, HDMI_AUD_N1);\n}\n\nstatic unsigned int hdmi_compute_n(unsigned int freq, unsigned long pixel_clk)\n{\n\tunsigned int n = (128 * freq) / 1000;\n\tunsigned int mult = 1;\n\n\twhile (freq > 48000) {\n\t\tmult *= 2;\n\t\tfreq /= 2;\n\t}\n\n\tswitch (freq) {\n\tcase 32000:\n\t\tif (pixel_clk == 25175000)\n\t\t\tn = 4576;\n\t\telse if (pixel_clk == 27027000)\n\t\t\tn = 4096;\n\t\telse if (pixel_clk == 74176000 || pixel_clk == 148352000)\n\t\t\tn = 11648;\n\t\telse if (pixel_clk == 297000000)\n\t\t\tn = 3072;\n\t\telse\n\t\t\tn = 4096;\n\t\tn *= mult;\n\t\tbreak;\n\n\tcase 44100:\n\t\tif (pixel_clk == 25175000)\n\t\t\tn = 7007;\n\t\telse if (pixel_clk == 74176000)\n\t\t\tn = 17836;\n\t\telse if (pixel_clk == 148352000)\n\t\t\tn = 8918;\n\t\telse if (pixel_clk == 297000000)\n\t\t\tn = 4704;\n\t\telse\n\t\t\tn = 6272;\n\t\tn *= mult;\n\t\tbreak;\n\n\tcase 48000:\n\t\tif (pixel_clk == 25175000)\n\t\t\tn = 6864;\n\t\telse if (pixel_clk == 27027000)\n\t\t\tn = 6144;\n\t\telse if (pixel_clk == 74176000)\n\t\t\tn = 11648;\n\t\telse if (pixel_clk == 148352000)\n\t\t\tn = 5824;\n\t\telse if (pixel_clk == 297000000)\n\t\t\tn = 5120;\n\t\telse\n\t\t\tn = 6144;\n\t\tn *= mult;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn n;\n}\n\n \nvoid dw_hdmi_set_channel_status(struct dw_hdmi *hdmi,\n\t\t\t\tu8 *channel_status)\n{\n\t \n\thdmi_writeb(hdmi, channel_status[3], HDMI_FC_AUDSCHNLS7);\n\thdmi_writeb(hdmi, channel_status[4], HDMI_FC_AUDSCHNLS8);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_set_channel_status);\n\nstatic void hdmi_set_clk_regenerator(struct dw_hdmi *hdmi,\n\tunsigned long pixel_clk, unsigned int sample_rate)\n{\n\tunsigned long ftdms = pixel_clk;\n\tunsigned int n, cts;\n\tu8 config3;\n\tu64 tmp;\n\n\tn = hdmi_compute_n(sample_rate, pixel_clk);\n\n\tconfig3 = hdmi_readb(hdmi, HDMI_CONFIG3_ID);\n\n\t \n\tif ((config3 & HDMI_CONFIG3_AHBAUDDMA) || (config3 & HDMI_CONFIG3_GPAUD)) {\n\t\t \n\t\ttmp = (u64)ftdms * n;\n\t\tdo_div(tmp, 128 * sample_rate);\n\t\tcts = tmp;\n\n\t\tdev_dbg(hdmi->dev, \"%s: fs=%uHz ftdms=%lu.%03luMHz N=%d cts=%d\\n\",\n\t\t\t__func__, sample_rate,\n\t\t\tftdms / 1000000, (ftdms / 1000) % 1000,\n\t\t\tn, cts);\n\t} else {\n\t\tcts = 0;\n\t}\n\n\tspin_lock_irq(&hdmi->audio_lock);\n\thdmi->audio_n = n;\n\thdmi->audio_cts = cts;\n\thdmi_set_cts_n(hdmi, cts, hdmi->audio_enable ? n : 0);\n\tspin_unlock_irq(&hdmi->audio_lock);\n}\n\nstatic void hdmi_init_clk_regenerator(struct dw_hdmi *hdmi)\n{\n\tmutex_lock(&hdmi->audio_mutex);\n\thdmi_set_clk_regenerator(hdmi, 74250000, hdmi->sample_rate);\n\tmutex_unlock(&hdmi->audio_mutex);\n}\n\nstatic void hdmi_clk_regenerator_update_pixel_clock(struct dw_hdmi *hdmi)\n{\n\tmutex_lock(&hdmi->audio_mutex);\n\thdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,\n\t\t\t\t hdmi->sample_rate);\n\tmutex_unlock(&hdmi->audio_mutex);\n}\n\nvoid dw_hdmi_set_sample_width(struct dw_hdmi *hdmi, unsigned int width)\n{\n\tmutex_lock(&hdmi->audio_mutex);\n\thdmi->sample_width = width;\n\tmutex_unlock(&hdmi->audio_mutex);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_set_sample_width);\n\nvoid dw_hdmi_set_sample_non_pcm(struct dw_hdmi *hdmi, unsigned int non_pcm)\n{\n\tmutex_lock(&hdmi->audio_mutex);\n\thdmi->sample_non_pcm = non_pcm;\n\tmutex_unlock(&hdmi->audio_mutex);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_set_sample_non_pcm);\n\nvoid dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate)\n{\n\tmutex_lock(&hdmi->audio_mutex);\n\thdmi->sample_rate = rate;\n\thdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,\n\t\t\t\t hdmi->sample_rate);\n\tmutex_unlock(&hdmi->audio_mutex);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_set_sample_rate);\n\nvoid dw_hdmi_set_channel_count(struct dw_hdmi *hdmi, unsigned int cnt)\n{\n\tu8 layout;\n\n\tmutex_lock(&hdmi->audio_mutex);\n\thdmi->channels = cnt;\n\n\t \n\tif (cnt > 2)\n\t\tlayout = HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT1;\n\telse\n\t\tlayout = HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT0;\n\n\thdmi_modb(hdmi, layout, HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK,\n\t\t  HDMI_FC_AUDSCONF);\n\n\t \n\thdmi_modb(hdmi, (cnt - 1) << HDMI_FC_AUDICONF0_CC_OFFSET,\n\t\t  HDMI_FC_AUDICONF0_CC_MASK, HDMI_FC_AUDICONF0);\n\n\tmutex_unlock(&hdmi->audio_mutex);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_set_channel_count);\n\nvoid dw_hdmi_set_channel_allocation(struct dw_hdmi *hdmi, unsigned int ca)\n{\n\tmutex_lock(&hdmi->audio_mutex);\n\n\thdmi_writeb(hdmi, ca, HDMI_FC_AUDICONF2);\n\n\tmutex_unlock(&hdmi->audio_mutex);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_set_channel_allocation);\n\nstatic void hdmi_enable_audio_clk(struct dw_hdmi *hdmi, bool enable)\n{\n\tif (enable)\n\t\thdmi->mc_clkdis &= ~HDMI_MC_CLKDIS_AUDCLK_DISABLE;\n\telse\n\t\thdmi->mc_clkdis |= HDMI_MC_CLKDIS_AUDCLK_DISABLE;\n\thdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);\n}\n\nstatic u8 *hdmi_audio_get_eld(struct dw_hdmi *hdmi)\n{\n\tif (!hdmi->curr_conn)\n\t\treturn NULL;\n\n\treturn hdmi->curr_conn->eld;\n}\n\nstatic void dw_hdmi_gp_audio_enable(struct dw_hdmi *hdmi)\n{\n\tconst struct dw_hdmi_plat_data *pdata = hdmi->plat_data;\n\tint sample_freq = 0x2, org_sample_freq = 0xD;\n\tint ch_mask = BIT(hdmi->channels) - 1;\n\n\tswitch (hdmi->sample_rate) {\n\tcase 32000:\n\t\tsample_freq = 0x03;\n\t\torg_sample_freq = 0x0C;\n\t\tbreak;\n\tcase 44100:\n\t\tsample_freq = 0x00;\n\t\torg_sample_freq = 0x0F;\n\t\tbreak;\n\tcase 48000:\n\t\tsample_freq = 0x02;\n\t\torg_sample_freq = 0x0D;\n\t\tbreak;\n\tcase 88200:\n\t\tsample_freq = 0x08;\n\t\torg_sample_freq = 0x07;\n\t\tbreak;\n\tcase 96000:\n\t\tsample_freq = 0x0A;\n\t\torg_sample_freq = 0x05;\n\t\tbreak;\n\tcase 176400:\n\t\tsample_freq = 0x0C;\n\t\torg_sample_freq = 0x03;\n\t\tbreak;\n\tcase 192000:\n\t\tsample_freq = 0x0E;\n\t\torg_sample_freq = 0x01;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\thdmi_set_cts_n(hdmi, hdmi->audio_cts, hdmi->audio_n);\n\thdmi_enable_audio_clk(hdmi, true);\n\n\thdmi_writeb(hdmi, 0x1, HDMI_FC_AUDSCHNLS0);\n\thdmi_writeb(hdmi, hdmi->channels, HDMI_FC_AUDSCHNLS2);\n\thdmi_writeb(hdmi, 0x22, HDMI_FC_AUDSCHNLS3);\n\thdmi_writeb(hdmi, 0x22, HDMI_FC_AUDSCHNLS4);\n\thdmi_writeb(hdmi, 0x11, HDMI_FC_AUDSCHNLS5);\n\thdmi_writeb(hdmi, 0x11, HDMI_FC_AUDSCHNLS6);\n\thdmi_writeb(hdmi, (0x3 << 4) | sample_freq, HDMI_FC_AUDSCHNLS7);\n\thdmi_writeb(hdmi, (org_sample_freq << 4) | 0xb, HDMI_FC_AUDSCHNLS8);\n\n\thdmi_writeb(hdmi, ch_mask, HDMI_GP_CONF1);\n\thdmi_writeb(hdmi, 0x02, HDMI_GP_CONF2);\n\thdmi_writeb(hdmi, 0x01, HDMI_GP_CONF0);\n\n\thdmi_modb(hdmi,  0x3, 0x3, HDMI_FC_DATAUTO3);\n\n\t \n\tif (hdmi->sample_rate == 192000 && hdmi->channels == 8 &&\n\t    hdmi->sample_width == 32 && hdmi->sample_non_pcm)\n\t\thdmi_modb(hdmi, 0x01, 0x01, HDMI_GP_CONF2);\n\n\tif (pdata->enable_audio)\n\t\tpdata->enable_audio(hdmi,\n\t\t\t\t    hdmi->channels,\n\t\t\t\t    hdmi->sample_width,\n\t\t\t\t    hdmi->sample_rate,\n\t\t\t\t    hdmi->sample_non_pcm);\n}\n\nstatic void dw_hdmi_gp_audio_disable(struct dw_hdmi *hdmi)\n{\n\tconst struct dw_hdmi_plat_data *pdata = hdmi->plat_data;\n\n\thdmi_set_cts_n(hdmi, hdmi->audio_cts, 0);\n\n\thdmi_modb(hdmi,  0, 0x3, HDMI_FC_DATAUTO3);\n\tif (pdata->disable_audio)\n\t\tpdata->disable_audio(hdmi);\n\n\thdmi_enable_audio_clk(hdmi, false);\n}\n\nstatic void dw_hdmi_ahb_audio_enable(struct dw_hdmi *hdmi)\n{\n\thdmi_set_cts_n(hdmi, hdmi->audio_cts, hdmi->audio_n);\n}\n\nstatic void dw_hdmi_ahb_audio_disable(struct dw_hdmi *hdmi)\n{\n\thdmi_set_cts_n(hdmi, hdmi->audio_cts, 0);\n}\n\nstatic void dw_hdmi_i2s_audio_enable(struct dw_hdmi *hdmi)\n{\n\thdmi_set_cts_n(hdmi, hdmi->audio_cts, hdmi->audio_n);\n\thdmi_enable_audio_clk(hdmi, true);\n}\n\nstatic void dw_hdmi_i2s_audio_disable(struct dw_hdmi *hdmi)\n{\n\thdmi_enable_audio_clk(hdmi, false);\n}\n\nvoid dw_hdmi_audio_enable(struct dw_hdmi *hdmi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hdmi->audio_lock, flags);\n\thdmi->audio_enable = true;\n\tif (hdmi->enable_audio)\n\t\thdmi->enable_audio(hdmi);\n\tspin_unlock_irqrestore(&hdmi->audio_lock, flags);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_audio_enable);\n\nvoid dw_hdmi_audio_disable(struct dw_hdmi *hdmi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hdmi->audio_lock, flags);\n\thdmi->audio_enable = false;\n\tif (hdmi->disable_audio)\n\t\thdmi->disable_audio(hdmi);\n\tspin_unlock_irqrestore(&hdmi->audio_lock, flags);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_audio_disable);\n\nstatic bool hdmi_bus_fmt_is_rgb(unsigned int bus_format)\n{\n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\tcase MEDIA_BUS_FMT_RGB101010_1X30:\n\tcase MEDIA_BUS_FMT_RGB121212_1X36:\n\tcase MEDIA_BUS_FMT_RGB161616_1X48:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool hdmi_bus_fmt_is_yuv444(unsigned int bus_format)\n{\n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_YUV8_1X24:\n\tcase MEDIA_BUS_FMT_YUV10_1X30:\n\tcase MEDIA_BUS_FMT_YUV12_1X36:\n\tcase MEDIA_BUS_FMT_YUV16_1X48:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool hdmi_bus_fmt_is_yuv422(unsigned int bus_format)\n{\n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_UYVY10_1X20:\n\tcase MEDIA_BUS_FMT_UYVY12_1X24:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool hdmi_bus_fmt_is_yuv420(unsigned int bus_format)\n{\n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_UYYVYY8_0_5X24:\n\tcase MEDIA_BUS_FMT_UYYVYY10_0_5X30:\n\tcase MEDIA_BUS_FMT_UYYVYY12_0_5X36:\n\tcase MEDIA_BUS_FMT_UYYVYY16_0_5X48:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int hdmi_bus_fmt_color_depth(unsigned int bus_format)\n{\n\tswitch (bus_format) {\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\tcase MEDIA_BUS_FMT_YUV8_1X24:\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_UYYVYY8_0_5X24:\n\t\treturn 8;\n\n\tcase MEDIA_BUS_FMT_RGB101010_1X30:\n\tcase MEDIA_BUS_FMT_YUV10_1X30:\n\tcase MEDIA_BUS_FMT_UYVY10_1X20:\n\tcase MEDIA_BUS_FMT_UYYVYY10_0_5X30:\n\t\treturn 10;\n\n\tcase MEDIA_BUS_FMT_RGB121212_1X36:\n\tcase MEDIA_BUS_FMT_YUV12_1X36:\n\tcase MEDIA_BUS_FMT_UYVY12_1X24:\n\tcase MEDIA_BUS_FMT_UYYVYY12_0_5X36:\n\t\treturn 12;\n\n\tcase MEDIA_BUS_FMT_RGB161616_1X48:\n\tcase MEDIA_BUS_FMT_YUV16_1X48:\n\tcase MEDIA_BUS_FMT_UYYVYY16_0_5X48:\n\t\treturn 16;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic void hdmi_video_sample(struct dw_hdmi *hdmi)\n{\n\tint color_format = 0;\n\tu8 val;\n\n\tswitch (hdmi->hdmi_data.enc_in_bus_format) {\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\tcolor_format = 0x01;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB101010_1X30:\n\t\tcolor_format = 0x03;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB121212_1X36:\n\t\tcolor_format = 0x05;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB161616_1X48:\n\t\tcolor_format = 0x07;\n\t\tbreak;\n\n\tcase MEDIA_BUS_FMT_YUV8_1X24:\n\tcase MEDIA_BUS_FMT_UYYVYY8_0_5X24:\n\t\tcolor_format = 0x09;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUV10_1X30:\n\tcase MEDIA_BUS_FMT_UYYVYY10_0_5X30:\n\t\tcolor_format = 0x0B;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUV12_1X36:\n\tcase MEDIA_BUS_FMT_UYYVYY12_0_5X36:\n\t\tcolor_format = 0x0D;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUV16_1X48:\n\tcase MEDIA_BUS_FMT_UYYVYY16_0_5X48:\n\t\tcolor_format = 0x0F;\n\t\tbreak;\n\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tcolor_format = 0x16;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY10_1X20:\n\t\tcolor_format = 0x14;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY12_1X24:\n\t\tcolor_format = 0x12;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tval = HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE |\n\t\t((color_format << HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET) &\n\t\tHDMI_TX_INVID0_VIDEO_MAPPING_MASK);\n\thdmi_writeb(hdmi, val, HDMI_TX_INVID0);\n\n\t \n\tval = HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE |\n\t\tHDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE |\n\t\tHDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE;\n\thdmi_writeb(hdmi, val, HDMI_TX_INSTUFFING);\n\thdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA0);\n\thdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA1);\n\thdmi_writeb(hdmi, 0x0, HDMI_TX_RCRDATA0);\n\thdmi_writeb(hdmi, 0x0, HDMI_TX_RCRDATA1);\n\thdmi_writeb(hdmi, 0x0, HDMI_TX_BCBDATA0);\n\thdmi_writeb(hdmi, 0x0, HDMI_TX_BCBDATA1);\n}\n\nstatic int is_color_space_conversion(struct dw_hdmi *hdmi)\n{\n\tstruct hdmi_data_info *hdmi_data = &hdmi->hdmi_data;\n\tbool is_input_rgb, is_output_rgb;\n\n\tis_input_rgb = hdmi_bus_fmt_is_rgb(hdmi_data->enc_in_bus_format);\n\tis_output_rgb = hdmi_bus_fmt_is_rgb(hdmi_data->enc_out_bus_format);\n\n\treturn (is_input_rgb != is_output_rgb) ||\n\t       (is_input_rgb && is_output_rgb && hdmi_data->rgb_limited_range);\n}\n\nstatic int is_color_space_decimation(struct dw_hdmi *hdmi)\n{\n\tif (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))\n\t\treturn 0;\n\n\tif (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_in_bus_format) ||\n\t    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_in_bus_format))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int is_color_space_interpolation(struct dw_hdmi *hdmi)\n{\n\tif (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_in_bus_format))\n\t\treturn 0;\n\n\tif (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format) ||\n\t    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic bool is_csc_needed(struct dw_hdmi *hdmi)\n{\n\treturn is_color_space_conversion(hdmi) ||\n\t       is_color_space_decimation(hdmi) ||\n\t       is_color_space_interpolation(hdmi);\n}\n\nstatic void dw_hdmi_update_csc_coeffs(struct dw_hdmi *hdmi)\n{\n\tconst u16 (*csc_coeff)[3][4] = &csc_coeff_default;\n\tbool is_input_rgb, is_output_rgb;\n\tunsigned i;\n\tu32 csc_scale = 1;\n\n\tis_input_rgb = hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_in_bus_format);\n\tis_output_rgb = hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format);\n\n\tif (!is_input_rgb && is_output_rgb) {\n\t\tif (hdmi->hdmi_data.enc_out_encoding == V4L2_YCBCR_ENC_601)\n\t\t\tcsc_coeff = &csc_coeff_rgb_out_eitu601;\n\t\telse\n\t\t\tcsc_coeff = &csc_coeff_rgb_out_eitu709;\n\t} else if (is_input_rgb && !is_output_rgb) {\n\t\tif (hdmi->hdmi_data.enc_out_encoding == V4L2_YCBCR_ENC_601)\n\t\t\tcsc_coeff = &csc_coeff_rgb_in_eitu601;\n\t\telse\n\t\t\tcsc_coeff = &csc_coeff_rgb_in_eitu709;\n\t\tcsc_scale = 0;\n\t} else if (is_input_rgb && is_output_rgb &&\n\t\t   hdmi->hdmi_data.rgb_limited_range) {\n\t\tcsc_coeff = &csc_coeff_rgb_full_to_rgb_limited;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(csc_coeff_default[0]); i++) {\n\t\tu16 coeff_a = (*csc_coeff)[0][i];\n\t\tu16 coeff_b = (*csc_coeff)[1][i];\n\t\tu16 coeff_c = (*csc_coeff)[2][i];\n\n\t\thdmi_writeb(hdmi, coeff_a & 0xff, HDMI_CSC_COEF_A1_LSB + i * 2);\n\t\thdmi_writeb(hdmi, coeff_a >> 8, HDMI_CSC_COEF_A1_MSB + i * 2);\n\t\thdmi_writeb(hdmi, coeff_b & 0xff, HDMI_CSC_COEF_B1_LSB + i * 2);\n\t\thdmi_writeb(hdmi, coeff_b >> 8, HDMI_CSC_COEF_B1_MSB + i * 2);\n\t\thdmi_writeb(hdmi, coeff_c & 0xff, HDMI_CSC_COEF_C1_LSB + i * 2);\n\t\thdmi_writeb(hdmi, coeff_c >> 8, HDMI_CSC_COEF_C1_MSB + i * 2);\n\t}\n\n\thdmi_modb(hdmi, csc_scale, HDMI_CSC_SCALE_CSCSCALE_MASK,\n\t\t  HDMI_CSC_SCALE);\n}\n\nstatic void hdmi_video_csc(struct dw_hdmi *hdmi)\n{\n\tint color_depth = 0;\n\tint interpolation = HDMI_CSC_CFG_INTMODE_DISABLE;\n\tint decimation = 0;\n\n\t \n\tif (is_color_space_interpolation(hdmi))\n\t\tinterpolation = HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1;\n\telse if (is_color_space_decimation(hdmi))\n\t\tdecimation = HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3;\n\n\tswitch (hdmi_bus_fmt_color_depth(hdmi->hdmi_data.enc_out_bus_format)) {\n\tcase 8:\n\t\tcolor_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP;\n\t\tbreak;\n\tcase 10:\n\t\tcolor_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP;\n\t\tbreak;\n\tcase 12:\n\t\tcolor_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP;\n\t\tbreak;\n\tcase 16:\n\t\tcolor_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\thdmi_writeb(hdmi, interpolation | decimation, HDMI_CSC_CFG);\n\thdmi_modb(hdmi, color_depth, HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK,\n\t\t  HDMI_CSC_SCALE);\n\n\tdw_hdmi_update_csc_coeffs(hdmi);\n}\n\n \nstatic void hdmi_video_packetize(struct dw_hdmi *hdmi)\n{\n\tunsigned int color_depth = 0;\n\tunsigned int remap_size = HDMI_VP_REMAP_YCC422_16bit;\n\tunsigned int output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_PP;\n\tstruct hdmi_data_info *hdmi_data = &hdmi->hdmi_data;\n\tu8 val, vp_conf;\n\tu8 clear_gcp_auto = 0;\n\n\n\tif (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format) ||\n\t    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format) ||\n\t    hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format)) {\n\t\tswitch (hdmi_bus_fmt_color_depth(\n\t\t\t\t\thdmi->hdmi_data.enc_out_bus_format)) {\n\t\tcase 8:\n\t\t\tcolor_depth = 4;\n\t\t\toutput_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;\n\t\t\tclear_gcp_auto = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tcolor_depth = 5;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tcolor_depth = 6;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tcolor_depth = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutput_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;\n\t\t}\n\t} else if (hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format)) {\n\t\tswitch (hdmi_bus_fmt_color_depth(\n\t\t\t\t\thdmi->hdmi_data.enc_out_bus_format)) {\n\t\tcase 0:\n\t\tcase 8:\n\t\t\tremap_size = HDMI_VP_REMAP_YCC422_16bit;\n\t\t\tclear_gcp_auto = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tremap_size = HDMI_VP_REMAP_YCC422_20bit;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tremap_size = HDMI_VP_REMAP_YCC422_24bit;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\toutput_select = HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422;\n\t} else {\n\t\treturn;\n\t}\n\n\t \n\tval = ((color_depth << HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET) &\n\t\tHDMI_VP_PR_CD_COLOR_DEPTH_MASK) |\n\t\t((hdmi_data->pix_repet_factor <<\n\t\tHDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET) &\n\t\tHDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK);\n\thdmi_writeb(hdmi, val, HDMI_VP_PR_CD);\n\n\t \n\tval = hdmi_readb(hdmi, HDMI_FC_DATAUTO3);\n\tif (clear_gcp_auto == 1)\n\t\tval &= ~HDMI_FC_DATAUTO3_GCP_AUTO;\n\telse\n\t\tval |= HDMI_FC_DATAUTO3_GCP_AUTO;\n\thdmi_writeb(hdmi, val, HDMI_FC_DATAUTO3);\n\n\thdmi_modb(hdmi, HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE,\n\t\t  HDMI_VP_STUFF_PR_STUFFING_MASK, HDMI_VP_STUFF);\n\n\t \n\tif (hdmi_data->pix_repet_factor > 1) {\n\t\tvp_conf = HDMI_VP_CONF_PR_EN_ENABLE |\n\t\t\t  HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER;\n\t} else {  \n\t\tvp_conf = HDMI_VP_CONF_PR_EN_DISABLE |\n\t\t\t  HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER;\n\t}\n\n\thdmi_modb(hdmi, vp_conf,\n\t\t  HDMI_VP_CONF_PR_EN_MASK |\n\t\t  HDMI_VP_CONF_BYPASS_SELECT_MASK, HDMI_VP_CONF);\n\n\thdmi_modb(hdmi, 1 << HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET,\n\t\t  HDMI_VP_STUFF_IDEFAULT_PHASE_MASK, HDMI_VP_STUFF);\n\n\thdmi_writeb(hdmi, remap_size, HDMI_VP_REMAP);\n\n\tif (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_PP) {\n\t\tvp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |\n\t\t\t  HDMI_VP_CONF_PP_EN_ENABLE |\n\t\t\t  HDMI_VP_CONF_YCC422_EN_DISABLE;\n\t} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422) {\n\t\tvp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |\n\t\t\t  HDMI_VP_CONF_PP_EN_DISABLE |\n\t\t\t  HDMI_VP_CONF_YCC422_EN_ENABLE;\n\t} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS) {\n\t\tvp_conf = HDMI_VP_CONF_BYPASS_EN_ENABLE |\n\t\t\t  HDMI_VP_CONF_PP_EN_DISABLE |\n\t\t\t  HDMI_VP_CONF_YCC422_EN_DISABLE;\n\t} else {\n\t\treturn;\n\t}\n\n\thdmi_modb(hdmi, vp_conf,\n\t\t  HDMI_VP_CONF_BYPASS_EN_MASK | HDMI_VP_CONF_PP_EN_ENMASK |\n\t\t  HDMI_VP_CONF_YCC422_EN_MASK, HDMI_VP_CONF);\n\n\thdmi_modb(hdmi, HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE |\n\t\t\tHDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE,\n\t\t  HDMI_VP_STUFF_PP_STUFFING_MASK |\n\t\t  HDMI_VP_STUFF_YCC422_STUFFING_MASK, HDMI_VP_STUFF);\n\n\thdmi_modb(hdmi, output_select, HDMI_VP_CONF_OUTPUT_SELECTOR_MASK,\n\t\t  HDMI_VP_CONF);\n}\n\n \n\nstatic inline void hdmi_phy_test_clear(struct dw_hdmi *hdmi,\n\t\t\t\t       unsigned char bit)\n{\n\thdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTCLR_OFFSET,\n\t\t  HDMI_PHY_TST0_TSTCLR_MASK, HDMI_PHY_TST0);\n}\n\nstatic bool hdmi_phy_wait_i2c_done(struct dw_hdmi *hdmi, int msec)\n{\n\tu32 val;\n\n\twhile ((val = hdmi_readb(hdmi, HDMI_IH_I2CMPHY_STAT0) & 0x3) == 0) {\n\t\tif (msec-- == 0)\n\t\t\treturn false;\n\t\tudelay(1000);\n\t}\n\thdmi_writeb(hdmi, val, HDMI_IH_I2CMPHY_STAT0);\n\n\treturn true;\n}\n\nvoid dw_hdmi_phy_i2c_write(struct dw_hdmi *hdmi, unsigned short data,\n\t\t\t   unsigned char addr)\n{\n\thdmi_writeb(hdmi, 0xFF, HDMI_IH_I2CMPHY_STAT0);\n\thdmi_writeb(hdmi, addr, HDMI_PHY_I2CM_ADDRESS_ADDR);\n\thdmi_writeb(hdmi, (unsigned char)(data >> 8),\n\t\t    HDMI_PHY_I2CM_DATAO_1_ADDR);\n\thdmi_writeb(hdmi, (unsigned char)(data >> 0),\n\t\t    HDMI_PHY_I2CM_DATAO_0_ADDR);\n\thdmi_writeb(hdmi, HDMI_PHY_I2CM_OPERATION_ADDR_WRITE,\n\t\t    HDMI_PHY_I2CM_OPERATION_ADDR);\n\thdmi_phy_wait_i2c_done(hdmi, 1000);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_phy_i2c_write);\n\n \nstatic bool dw_hdmi_support_scdc(struct dw_hdmi *hdmi,\n\t\t\t\t const struct drm_display_info *display)\n{\n\t \n\tif (hdmi->version < 0x200a)\n\t\treturn false;\n\n\t \n\tif (!hdmi->ddc)\n\t\treturn false;\n\n\t \n\tif (!display->hdmi.scdc.supported ||\n\t    !display->hdmi.scdc.scrambling.supported)\n\t\treturn false;\n\n\t \n\tif (!display->hdmi.scdc.scrambling.low_rates &&\n\t    display->max_tmds_clock <= 340000)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nvoid dw_hdmi_set_high_tmds_clock_ratio(struct dw_hdmi *hdmi,\n\t\t\t\t       const struct drm_display_info *display)\n{\n\tunsigned long mtmdsclock = hdmi->hdmi_data.video_mode.mtmdsclock;\n\n\t \n\tif (dw_hdmi_support_scdc(hdmi, display)) {\n\t\tif (mtmdsclock > HDMI14_MAX_TMDSCLK)\n\t\t\tdrm_scdc_set_high_tmds_clock_ratio(hdmi->curr_conn, 1);\n\t\telse\n\t\t\tdrm_scdc_set_high_tmds_clock_ratio(hdmi->curr_conn, 0);\n\t}\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_set_high_tmds_clock_ratio);\n\nstatic void dw_hdmi_phy_enable_powerdown(struct dw_hdmi *hdmi, bool enable)\n{\n\thdmi_mask_writeb(hdmi, !enable, HDMI_PHY_CONF0,\n\t\t\t HDMI_PHY_CONF0_PDZ_OFFSET,\n\t\t\t HDMI_PHY_CONF0_PDZ_MASK);\n}\n\nstatic void dw_hdmi_phy_enable_tmds(struct dw_hdmi *hdmi, u8 enable)\n{\n\thdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\n\t\t\t HDMI_PHY_CONF0_ENTMDS_OFFSET,\n\t\t\t HDMI_PHY_CONF0_ENTMDS_MASK);\n}\n\nstatic void dw_hdmi_phy_enable_svsret(struct dw_hdmi *hdmi, u8 enable)\n{\n\thdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\n\t\t\t HDMI_PHY_CONF0_SVSRET_OFFSET,\n\t\t\t HDMI_PHY_CONF0_SVSRET_MASK);\n}\n\nvoid dw_hdmi_phy_gen2_pddq(struct dw_hdmi *hdmi, u8 enable)\n{\n\thdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\n\t\t\t HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET,\n\t\t\t HDMI_PHY_CONF0_GEN2_PDDQ_MASK);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_phy_gen2_pddq);\n\nvoid dw_hdmi_phy_gen2_txpwron(struct dw_hdmi *hdmi, u8 enable)\n{\n\thdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\n\t\t\t HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET,\n\t\t\t HDMI_PHY_CONF0_GEN2_TXPWRON_MASK);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_phy_gen2_txpwron);\n\nstatic void dw_hdmi_phy_sel_data_en_pol(struct dw_hdmi *hdmi, u8 enable)\n{\n\thdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\n\t\t\t HDMI_PHY_CONF0_SELDATAENPOL_OFFSET,\n\t\t\t HDMI_PHY_CONF0_SELDATAENPOL_MASK);\n}\n\nstatic void dw_hdmi_phy_sel_interface_control(struct dw_hdmi *hdmi, u8 enable)\n{\n\thdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\n\t\t\t HDMI_PHY_CONF0_SELDIPIF_OFFSET,\n\t\t\t HDMI_PHY_CONF0_SELDIPIF_MASK);\n}\n\nvoid dw_hdmi_phy_gen1_reset(struct dw_hdmi *hdmi)\n{\n\t \n\thdmi_writeb(hdmi, 0, HDMI_MC_PHYRSTZ);\n\thdmi_writeb(hdmi, HDMI_MC_PHYRSTZ_PHYRSTZ, HDMI_MC_PHYRSTZ);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_phy_gen1_reset);\n\nvoid dw_hdmi_phy_gen2_reset(struct dw_hdmi *hdmi)\n{\n\t \n\thdmi_writeb(hdmi, HDMI_MC_PHYRSTZ_PHYRSTZ, HDMI_MC_PHYRSTZ);\n\thdmi_writeb(hdmi, 0, HDMI_MC_PHYRSTZ);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_phy_gen2_reset);\n\nvoid dw_hdmi_phy_i2c_set_addr(struct dw_hdmi *hdmi, u8 address)\n{\n\thdmi_phy_test_clear(hdmi, 1);\n\thdmi_writeb(hdmi, address, HDMI_PHY_I2CM_SLAVE_ADDR);\n\thdmi_phy_test_clear(hdmi, 0);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_phy_i2c_set_addr);\n\nstatic void dw_hdmi_phy_power_off(struct dw_hdmi *hdmi)\n{\n\tconst struct dw_hdmi_phy_data *phy = hdmi->phy.data;\n\tunsigned int i;\n\tu16 val;\n\n\tif (phy->gen == 1) {\n\t\tdw_hdmi_phy_enable_tmds(hdmi, 0);\n\t\tdw_hdmi_phy_enable_powerdown(hdmi, true);\n\t\treturn;\n\t}\n\n\tdw_hdmi_phy_gen2_txpwron(hdmi, 0);\n\n\t \n\tfor (i = 0; i < 5; ++i) {\n\t\tval = hdmi_readb(hdmi, HDMI_PHY_STAT0);\n\t\tif (!(val & HDMI_PHY_TX_PHY_LOCK))\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (val & HDMI_PHY_TX_PHY_LOCK)\n\t\tdev_warn(hdmi->dev, \"PHY failed to power down\\n\");\n\telse\n\t\tdev_dbg(hdmi->dev, \"PHY powered down in %u iterations\\n\", i);\n\n\tdw_hdmi_phy_gen2_pddq(hdmi, 1);\n}\n\nstatic int dw_hdmi_phy_power_on(struct dw_hdmi *hdmi)\n{\n\tconst struct dw_hdmi_phy_data *phy = hdmi->phy.data;\n\tunsigned int i;\n\tu8 val;\n\n\tif (phy->gen == 1) {\n\t\tdw_hdmi_phy_enable_powerdown(hdmi, false);\n\n\t\t \n\t\tdw_hdmi_phy_enable_tmds(hdmi, 0);\n\t\tdw_hdmi_phy_enable_tmds(hdmi, 1);\n\t\treturn 0;\n\t}\n\n\tdw_hdmi_phy_gen2_txpwron(hdmi, 1);\n\tdw_hdmi_phy_gen2_pddq(hdmi, 0);\n\n\t \n\tfor (i = 0; i < 5; ++i) {\n\t\tval = hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_TX_PHY_LOCK;\n\t\tif (val)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (!val) {\n\t\tdev_err(hdmi->dev, \"PHY PLL failed to lock\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_dbg(hdmi->dev, \"PHY PLL locked %u iterations\\n\", i);\n\treturn 0;\n}\n\n \nstatic int hdmi_phy_configure_dwc_hdmi_3d_tx(struct dw_hdmi *hdmi,\n\t\tconst struct dw_hdmi_plat_data *pdata,\n\t\tunsigned long mpixelclock)\n{\n\tconst struct dw_hdmi_mpll_config *mpll_config = pdata->mpll_cfg;\n\tconst struct dw_hdmi_curr_ctrl *curr_ctrl = pdata->cur_ctr;\n\tconst struct dw_hdmi_phy_config *phy_config = pdata->phy_config;\n\n\t \n\n\t \n\tfor (; mpll_config->mpixelclock != ~0UL; mpll_config++)\n\t\tif (mpixelclock <= mpll_config->mpixelclock)\n\t\t\tbreak;\n\n\tfor (; curr_ctrl->mpixelclock != ~0UL; curr_ctrl++)\n\t\tif (mpixelclock <= curr_ctrl->mpixelclock)\n\t\t\tbreak;\n\n\tfor (; phy_config->mpixelclock != ~0UL; phy_config++)\n\t\tif (mpixelclock <= phy_config->mpixelclock)\n\t\t\tbreak;\n\n\tif (mpll_config->mpixelclock == ~0UL ||\n\t    curr_ctrl->mpixelclock == ~0UL ||\n\t    phy_config->mpixelclock == ~0UL)\n\t\treturn -EINVAL;\n\n\tdw_hdmi_phy_i2c_write(hdmi, mpll_config->res[0].cpce,\n\t\t\t      HDMI_3D_TX_PHY_CPCE_CTRL);\n\tdw_hdmi_phy_i2c_write(hdmi, mpll_config->res[0].gmp,\n\t\t\t      HDMI_3D_TX_PHY_GMPCTRL);\n\tdw_hdmi_phy_i2c_write(hdmi, curr_ctrl->curr[0],\n\t\t\t      HDMI_3D_TX_PHY_CURRCTRL);\n\n\tdw_hdmi_phy_i2c_write(hdmi, 0, HDMI_3D_TX_PHY_PLLPHBYCTRL);\n\tdw_hdmi_phy_i2c_write(hdmi, HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_FB_CLK,\n\t\t\t      HDMI_3D_TX_PHY_MSM_CTRL);\n\n\tdw_hdmi_phy_i2c_write(hdmi, phy_config->term, HDMI_3D_TX_PHY_TXTERM);\n\tdw_hdmi_phy_i2c_write(hdmi, phy_config->sym_ctr,\n\t\t\t      HDMI_3D_TX_PHY_CKSYMTXCTRL);\n\tdw_hdmi_phy_i2c_write(hdmi, phy_config->vlev_ctr,\n\t\t\t      HDMI_3D_TX_PHY_VLEVCTRL);\n\n\t \n\tdw_hdmi_phy_i2c_write(hdmi, HDMI_3D_TX_PHY_CKCALCTRL_OVERRIDE,\n\t\t\t      HDMI_3D_TX_PHY_CKCALCTRL);\n\n\treturn 0;\n}\n\nstatic int hdmi_phy_configure(struct dw_hdmi *hdmi,\n\t\t\t      const struct drm_display_info *display)\n{\n\tconst struct dw_hdmi_phy_data *phy = hdmi->phy.data;\n\tconst struct dw_hdmi_plat_data *pdata = hdmi->plat_data;\n\tunsigned long mpixelclock = hdmi->hdmi_data.video_mode.mpixelclock;\n\tunsigned long mtmdsclock = hdmi->hdmi_data.video_mode.mtmdsclock;\n\tint ret;\n\n\tdw_hdmi_phy_power_off(hdmi);\n\n\tdw_hdmi_set_high_tmds_clock_ratio(hdmi, display);\n\n\t \n\tif (phy->has_svsret)\n\t\tdw_hdmi_phy_enable_svsret(hdmi, 1);\n\n\tdw_hdmi_phy_gen2_reset(hdmi);\n\n\thdmi_writeb(hdmi, HDMI_MC_HEACPHY_RST_ASSERT, HDMI_MC_HEACPHY_RST);\n\n\tdw_hdmi_phy_i2c_set_addr(hdmi, HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2);\n\n\t \n\tif (pdata->configure_phy)\n\t\tret = pdata->configure_phy(hdmi, pdata->priv_data, mpixelclock);\n\telse\n\t\tret = phy->configure(hdmi, pdata, mpixelclock);\n\tif (ret) {\n\t\tdev_err(hdmi->dev, \"PHY configuration failed (clock %lu)\\n\",\n\t\t\tmpixelclock);\n\t\treturn ret;\n\t}\n\n\t \n\tif (mtmdsclock > HDMI14_MAX_TMDSCLK)\n\t\tmsleep(100);\n\n\treturn dw_hdmi_phy_power_on(hdmi);\n}\n\nstatic int dw_hdmi_phy_init(struct dw_hdmi *hdmi, void *data,\n\t\t\t    const struct drm_display_info *display,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tdw_hdmi_phy_sel_data_en_pol(hdmi, 1);\n\t\tdw_hdmi_phy_sel_interface_control(hdmi, 0);\n\n\t\tret = hdmi_phy_configure(hdmi, display);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dw_hdmi_phy_disable(struct dw_hdmi *hdmi, void *data)\n{\n\tdw_hdmi_phy_power_off(hdmi);\n}\n\nenum drm_connector_status dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi,\n\t\t\t\t\t       void *data)\n{\n\treturn hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_HPD ?\n\t\tconnector_status_connected : connector_status_disconnected;\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_phy_read_hpd);\n\nvoid dw_hdmi_phy_update_hpd(struct dw_hdmi *hdmi, void *data,\n\t\t\t    bool force, bool disabled, bool rxsense)\n{\n\tu8 old_mask = hdmi->phy_mask;\n\n\tif (force || disabled || !rxsense)\n\t\thdmi->phy_mask |= HDMI_PHY_RX_SENSE;\n\telse\n\t\thdmi->phy_mask &= ~HDMI_PHY_RX_SENSE;\n\n\tif (old_mask != hdmi->phy_mask)\n\t\thdmi_writeb(hdmi, hdmi->phy_mask, HDMI_PHY_MASK0);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_phy_update_hpd);\n\nvoid dw_hdmi_phy_setup_hpd(struct dw_hdmi *hdmi, void *data)\n{\n\t \n\thdmi_writeb(hdmi, HDMI_PHY_HPD | HDMI_PHY_RX_SENSE, HDMI_PHY_POL0);\n\thdmi_writeb(hdmi, HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE,\n\t\t    HDMI_IH_PHY_STAT0);\n\n\t \n\thdmi_writeb(hdmi, hdmi->phy_mask, HDMI_PHY_MASK0);\n\n\t \n\thdmi_writeb(hdmi, HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE,\n\t\t    HDMI_IH_PHY_STAT0);\n\thdmi_writeb(hdmi, ~(HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE),\n\t\t    HDMI_IH_MUTE_PHY_STAT0);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_phy_setup_hpd);\n\nstatic const struct dw_hdmi_phy_ops dw_hdmi_synopsys_phy_ops = {\n\t.init = dw_hdmi_phy_init,\n\t.disable = dw_hdmi_phy_disable,\n\t.read_hpd = dw_hdmi_phy_read_hpd,\n\t.update_hpd = dw_hdmi_phy_update_hpd,\n\t.setup_hpd = dw_hdmi_phy_setup_hpd,\n};\n\n \n\nstatic void hdmi_tx_hdcp_config(struct dw_hdmi *hdmi)\n{\n\tu8 de;\n\n\tif (hdmi->hdmi_data.video_mode.mdataenablepolarity)\n\t\tde = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH;\n\telse\n\t\tde = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW;\n\n\t \n\thdmi_modb(hdmi, HDMI_A_HDCPCFG0_RXDETECT_DISABLE,\n\t\t  HDMI_A_HDCPCFG0_RXDETECT_MASK, HDMI_A_HDCPCFG0);\n\n\thdmi_modb(hdmi, de, HDMI_A_VIDPOLCFG_DATAENPOL_MASK, HDMI_A_VIDPOLCFG);\n\n\thdmi_modb(hdmi, HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE,\n\t\t  HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK, HDMI_A_HDCPCFG1);\n}\n\nstatic void hdmi_config_AVI(struct dw_hdmi *hdmi,\n\t\t\t    const struct drm_connector *connector,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct hdmi_avi_infoframe frame;\n\tu8 val;\n\n\t \n\tdrm_hdmi_avi_infoframe_from_display_mode(&frame, connector, mode);\n\n\tif (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format)) {\n\t\tdrm_hdmi_avi_infoframe_quant_range(&frame, connector, mode,\n\t\t\t\t\t\t   hdmi->hdmi_data.rgb_limited_range ?\n\t\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_LIMITED :\n\t\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_FULL);\n\t} else {\n\t\tframe.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;\n\t\tframe.ycc_quantization_range =\n\t\t\tHDMI_YCC_QUANTIZATION_RANGE_LIMITED;\n\t}\n\n\tif (hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format))\n\t\tframe.colorspace = HDMI_COLORSPACE_YUV444;\n\telse if (hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))\n\t\tframe.colorspace = HDMI_COLORSPACE_YUV422;\n\telse if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format))\n\t\tframe.colorspace = HDMI_COLORSPACE_YUV420;\n\telse\n\t\tframe.colorspace = HDMI_COLORSPACE_RGB;\n\n\t \n\tif (!hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format)) {\n\t\tswitch (hdmi->hdmi_data.enc_out_encoding) {\n\t\tcase V4L2_YCBCR_ENC_601:\n\t\t\tif (hdmi->hdmi_data.enc_in_encoding == V4L2_YCBCR_ENC_XV601)\n\t\t\t\tframe.colorimetry = HDMI_COLORIMETRY_EXTENDED;\n\t\t\telse\n\t\t\t\tframe.colorimetry = HDMI_COLORIMETRY_ITU_601;\n\t\t\tframe.extended_colorimetry =\n\t\t\t\t\tHDMI_EXTENDED_COLORIMETRY_XV_YCC_601;\n\t\t\tbreak;\n\t\tcase V4L2_YCBCR_ENC_709:\n\t\t\tif (hdmi->hdmi_data.enc_in_encoding == V4L2_YCBCR_ENC_XV709)\n\t\t\t\tframe.colorimetry = HDMI_COLORIMETRY_EXTENDED;\n\t\t\telse\n\t\t\t\tframe.colorimetry = HDMI_COLORIMETRY_ITU_709;\n\t\t\tframe.extended_colorimetry =\n\t\t\t\t\tHDMI_EXTENDED_COLORIMETRY_XV_YCC_709;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tframe.colorimetry = HDMI_COLORIMETRY_ITU_601;\n\t\t\tframe.extended_colorimetry =\n\t\t\t\t\tHDMI_EXTENDED_COLORIMETRY_XV_YCC_601;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tframe.colorimetry = HDMI_COLORIMETRY_NONE;\n\t\tframe.extended_colorimetry =\n\t\t\tHDMI_EXTENDED_COLORIMETRY_XV_YCC_601;\n\t}\n\n\t \n\n\t \n\tval = (frame.scan_mode & 3) << 4 | (frame.colorspace & 3);\n\tif (frame.active_aspect & 15)\n\t\tval |= HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT;\n\tif (frame.top_bar || frame.bottom_bar)\n\t\tval |= HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR;\n\tif (frame.left_bar || frame.right_bar)\n\t\tval |= HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR;\n\thdmi_writeb(hdmi, val, HDMI_FC_AVICONF0);\n\n\t \n\tval = ((frame.colorimetry & 0x3) << 6) |\n\t      ((frame.picture_aspect & 0x3) << 4) |\n\t      (frame.active_aspect & 0xf);\n\thdmi_writeb(hdmi, val, HDMI_FC_AVICONF1);\n\n\t \n\tval = ((frame.extended_colorimetry & 0x7) << 4) |\n\t      ((frame.quantization_range & 0x3) << 2) |\n\t      (frame.nups & 0x3);\n\tif (frame.itc)\n\t\tval |= HDMI_FC_AVICONF2_IT_CONTENT_VALID;\n\thdmi_writeb(hdmi, val, HDMI_FC_AVICONF2);\n\n\t \n\tval = frame.video_code & 0x7f;\n\thdmi_writeb(hdmi, val, HDMI_FC_AVIVID);\n\n\t \n\tval = (((hdmi->hdmi_data.video_mode.mpixelrepetitioninput + 1) <<\n\t\tHDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET) &\n\t\tHDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK) |\n\t\t((hdmi->hdmi_data.video_mode.mpixelrepetitionoutput <<\n\t\tHDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET) &\n\t\tHDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK);\n\thdmi_writeb(hdmi, val, HDMI_FC_PRCONF);\n\n\t \n\tval = ((frame.ycc_quantization_range & 0x3) << 2) |\n\t      (frame.content_type & 0x3);\n\thdmi_writeb(hdmi, val, HDMI_FC_AVICONF3);\n\n\t \n\thdmi_writeb(hdmi, frame.top_bar & 0xff, HDMI_FC_AVIETB0);\n\thdmi_writeb(hdmi, (frame.top_bar >> 8) & 0xff, HDMI_FC_AVIETB1);\n\thdmi_writeb(hdmi, frame.bottom_bar & 0xff, HDMI_FC_AVISBB0);\n\thdmi_writeb(hdmi, (frame.bottom_bar >> 8) & 0xff, HDMI_FC_AVISBB1);\n\thdmi_writeb(hdmi, frame.left_bar & 0xff, HDMI_FC_AVIELB0);\n\thdmi_writeb(hdmi, (frame.left_bar >> 8) & 0xff, HDMI_FC_AVIELB1);\n\thdmi_writeb(hdmi, frame.right_bar & 0xff, HDMI_FC_AVISRB0);\n\thdmi_writeb(hdmi, (frame.right_bar >> 8) & 0xff, HDMI_FC_AVISRB1);\n}\n\nstatic void hdmi_config_vendor_specific_infoframe(struct dw_hdmi *hdmi,\n\t\t\t\t\t\t  const struct drm_connector *connector,\n\t\t\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tstruct hdmi_vendor_infoframe frame;\n\tu8 buffer[10];\n\tssize_t err;\n\n\terr = drm_hdmi_vendor_infoframe_from_display_mode(&frame, connector,\n\t\t\t\t\t\t\t  mode);\n\tif (err < 0)\n\t\t \n\t\treturn;\n\n\terr = hdmi_vendor_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"Failed to pack vendor infoframe: %zd\\n\",\n\t\t\terr);\n\t\treturn;\n\t}\n\thdmi_mask_writeb(hdmi, 0, HDMI_FC_DATAUTO0, HDMI_FC_DATAUTO0_VSD_OFFSET,\n\t\t\tHDMI_FC_DATAUTO0_VSD_MASK);\n\n\t \n\thdmi_writeb(hdmi, buffer[2], HDMI_FC_VSDSIZE);\n\n\t \n\thdmi_writeb(hdmi, buffer[4], HDMI_FC_VSDIEEEID0);\n\thdmi_writeb(hdmi, buffer[5], HDMI_FC_VSDIEEEID1);\n\thdmi_writeb(hdmi, buffer[6], HDMI_FC_VSDIEEEID2);\n\n\t \n\thdmi_writeb(hdmi, buffer[7], HDMI_FC_VSDPAYLOAD0);\n\thdmi_writeb(hdmi, buffer[8], HDMI_FC_VSDPAYLOAD1);\n\n\tif (frame.s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF)\n\t\thdmi_writeb(hdmi, buffer[9], HDMI_FC_VSDPAYLOAD2);\n\n\t \n\thdmi_writeb(hdmi, 1, HDMI_FC_DATAUTO1);\n\n\t \n\thdmi_writeb(hdmi, 0x11, HDMI_FC_DATAUTO2);\n\n\t \n\thdmi_mask_writeb(hdmi, 1, HDMI_FC_DATAUTO0, HDMI_FC_DATAUTO0_VSD_OFFSET,\n\t\t\tHDMI_FC_DATAUTO0_VSD_MASK);\n}\n\nstatic void hdmi_config_drm_infoframe(struct dw_hdmi *hdmi,\n\t\t\t\t      const struct drm_connector *connector)\n{\n\tconst struct drm_connector_state *conn_state = connector->state;\n\tstruct hdmi_drm_infoframe frame;\n\tu8 buffer[30];\n\tssize_t err;\n\tint i;\n\n\tif (!hdmi->plat_data->use_drm_infoframe)\n\t\treturn;\n\n\thdmi_modb(hdmi, HDMI_FC_PACKET_TX_EN_DRM_DISABLE,\n\t\t  HDMI_FC_PACKET_TX_EN_DRM_MASK, HDMI_FC_PACKET_TX_EN);\n\n\terr = drm_hdmi_infoframe_set_hdr_metadata(&frame, conn_state);\n\tif (err < 0)\n\t\treturn;\n\n\terr = hdmi_drm_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"Failed to pack drm infoframe: %zd\\n\", err);\n\t\treturn;\n\t}\n\n\thdmi_writeb(hdmi, frame.version, HDMI_FC_DRM_HB0);\n\thdmi_writeb(hdmi, frame.length, HDMI_FC_DRM_HB1);\n\n\tfor (i = 0; i < frame.length; i++)\n\t\thdmi_writeb(hdmi, buffer[4 + i], HDMI_FC_DRM_PB0 + i);\n\n\thdmi_writeb(hdmi, 1, HDMI_FC_DRM_UP);\n\thdmi_modb(hdmi, HDMI_FC_PACKET_TX_EN_DRM_ENABLE,\n\t\t  HDMI_FC_PACKET_TX_EN_DRM_MASK, HDMI_FC_PACKET_TX_EN);\n}\n\nstatic void hdmi_av_composer(struct dw_hdmi *hdmi,\n\t\t\t     const struct drm_display_info *display,\n\t\t\t     const struct drm_display_mode *mode)\n{\n\tu8 inv_val, bytes;\n\tconst struct drm_hdmi_info *hdmi_info = &display->hdmi;\n\tstruct hdmi_vmode *vmode = &hdmi->hdmi_data.video_mode;\n\tint hblank, vblank, h_de_hs, v_de_vs, hsync_len, vsync_len;\n\tunsigned int vdisplay, hdisplay;\n\n\tvmode->mpixelclock = mode->clock * 1000;\n\n\tdev_dbg(hdmi->dev, \"final pixclk = %d\\n\", vmode->mpixelclock);\n\n\tvmode->mtmdsclock = vmode->mpixelclock;\n\n\tif (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format)) {\n\t\tswitch (hdmi_bus_fmt_color_depth(\n\t\t\t\thdmi->hdmi_data.enc_out_bus_format)) {\n\t\tcase 16:\n\t\t\tvmode->mtmdsclock = vmode->mpixelclock * 2;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tvmode->mtmdsclock = vmode->mpixelclock * 3 / 2;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tvmode->mtmdsclock = vmode->mpixelclock * 5 / 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format))\n\t\tvmode->mtmdsclock /= 2;\n\n\tdev_dbg(hdmi->dev, \"final tmdsclock = %d\\n\", vmode->mtmdsclock);\n\n\t \n\tinv_val = (hdmi->hdmi_data.hdcp_enable ||\n\t\t   (dw_hdmi_support_scdc(hdmi, display) &&\n\t\t    (vmode->mtmdsclock > HDMI14_MAX_TMDSCLK ||\n\t\t     hdmi_info->scdc.scrambling.low_rates)) ?\n\t\tHDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE :\n\t\tHDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE);\n\n\tinv_val |= mode->flags & DRM_MODE_FLAG_PVSYNC ?\n\t\tHDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH :\n\t\tHDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW;\n\n\tinv_val |= mode->flags & DRM_MODE_FLAG_PHSYNC ?\n\t\tHDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH :\n\t\tHDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW;\n\n\tinv_val |= (vmode->mdataenablepolarity ?\n\t\tHDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH :\n\t\tHDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW);\n\n\tif (hdmi->vic == 39)\n\t\tinv_val |= HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH;\n\telse\n\t\tinv_val |= mode->flags & DRM_MODE_FLAG_INTERLACE ?\n\t\t\tHDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH :\n\t\t\tHDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW;\n\n\tinv_val |= mode->flags & DRM_MODE_FLAG_INTERLACE ?\n\t\tHDMI_FC_INVIDCONF_IN_I_P_INTERLACED :\n\t\tHDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE;\n\n\tinv_val |= hdmi->sink_is_hdmi ?\n\t\tHDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE :\n\t\tHDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE;\n\n\thdmi_writeb(hdmi, inv_val, HDMI_FC_INVIDCONF);\n\n\thdisplay = mode->hdisplay;\n\thblank = mode->htotal - mode->hdisplay;\n\th_de_hs = mode->hsync_start - mode->hdisplay;\n\thsync_len = mode->hsync_end - mode->hsync_start;\n\n\t \n\tif (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format)) {\n\t\thdisplay /= 2;\n\t\thblank /= 2;\n\t\th_de_hs /= 2;\n\t\thsync_len /= 2;\n\t}\n\n\tvdisplay = mode->vdisplay;\n\tvblank = mode->vtotal - mode->vdisplay;\n\tv_de_vs = mode->vsync_start - mode->vdisplay;\n\tvsync_len = mode->vsync_end - mode->vsync_start;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tvdisplay /= 2;\n\t\tvblank /= 2;\n\t\tv_de_vs /= 2;\n\t\tvsync_len /= 2;\n\t}\n\n\t \n\tif (dw_hdmi_support_scdc(hdmi, display)) {\n\t\tif (vmode->mtmdsclock > HDMI14_MAX_TMDSCLK ||\n\t\t    hdmi_info->scdc.scrambling.low_rates) {\n\t\t\t \n\t\t\tdrm_scdc_readb(hdmi->ddc, SCDC_SINK_VERSION,\n\t\t\t\t       &bytes);\n\t\t\tdrm_scdc_writeb(hdmi->ddc, SCDC_SOURCE_VERSION,\n\t\t\t\tmin_t(u8, bytes, SCDC_MIN_SOURCE_VERSION));\n\n\t\t\t \n\t\t\tdrm_scdc_set_scrambling(hdmi->curr_conn, 1);\n\n\t\t\t \n\t\t\thdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ,\n\t\t\t\t    HDMI_MC_SWRSTZ);\n\t\t\thdmi_writeb(hdmi, 1, HDMI_FC_SCRAMBLER_CTRL);\n\t\t} else {\n\t\t\thdmi_writeb(hdmi, 0, HDMI_FC_SCRAMBLER_CTRL);\n\t\t\thdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ,\n\t\t\t\t    HDMI_MC_SWRSTZ);\n\t\t\tdrm_scdc_set_scrambling(hdmi->curr_conn, 0);\n\t\t}\n\t}\n\n\t \n\thdmi_writeb(hdmi, hdisplay >> 8, HDMI_FC_INHACTV1);\n\thdmi_writeb(hdmi, hdisplay, HDMI_FC_INHACTV0);\n\n\t \n\thdmi_writeb(hdmi, vdisplay >> 8, HDMI_FC_INVACTV1);\n\thdmi_writeb(hdmi, vdisplay, HDMI_FC_INVACTV0);\n\n\t \n\thdmi_writeb(hdmi, hblank >> 8, HDMI_FC_INHBLANK1);\n\thdmi_writeb(hdmi, hblank, HDMI_FC_INHBLANK0);\n\n\t \n\thdmi_writeb(hdmi, vblank, HDMI_FC_INVBLANK);\n\n\t \n\thdmi_writeb(hdmi, h_de_hs >> 8, HDMI_FC_HSYNCINDELAY1);\n\thdmi_writeb(hdmi, h_de_hs, HDMI_FC_HSYNCINDELAY0);\n\n\t \n\thdmi_writeb(hdmi, v_de_vs, HDMI_FC_VSYNCINDELAY);\n\n\t \n\thdmi_writeb(hdmi, hsync_len >> 8, HDMI_FC_HSYNCINWIDTH1);\n\thdmi_writeb(hdmi, hsync_len, HDMI_FC_HSYNCINWIDTH0);\n\n\t \n\thdmi_writeb(hdmi, vsync_len, HDMI_FC_VSYNCINWIDTH);\n}\n\n \nstatic void dw_hdmi_enable_video_path(struct dw_hdmi *hdmi)\n{\n\t \n\thdmi_writeb(hdmi, 12, HDMI_FC_CTRLDUR);\n\thdmi_writeb(hdmi, 32, HDMI_FC_EXCTRLDUR);\n\thdmi_writeb(hdmi, 1, HDMI_FC_EXCTRLSPAC);\n\n\t \n\thdmi_writeb(hdmi, 0x0B, HDMI_FC_CH0PREAM);\n\thdmi_writeb(hdmi, 0x16, HDMI_FC_CH1PREAM);\n\thdmi_writeb(hdmi, 0x21, HDMI_FC_CH2PREAM);\n\n\t \n\thdmi->mc_clkdis |= HDMI_MC_CLKDIS_HDCPCLK_DISABLE |\n\t\t\t   HDMI_MC_CLKDIS_CSCCLK_DISABLE |\n\t\t\t   HDMI_MC_CLKDIS_AUDCLK_DISABLE |\n\t\t\t   HDMI_MC_CLKDIS_PREPCLK_DISABLE |\n\t\t\t   HDMI_MC_CLKDIS_TMDSCLK_DISABLE;\n\thdmi->mc_clkdis &= ~HDMI_MC_CLKDIS_PIXELCLK_DISABLE;\n\thdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);\n\n\thdmi->mc_clkdis &= ~HDMI_MC_CLKDIS_TMDSCLK_DISABLE;\n\thdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);\n\n\t \n\tif (is_csc_needed(hdmi)) {\n\t\thdmi->mc_clkdis &= ~HDMI_MC_CLKDIS_CSCCLK_DISABLE;\n\t\thdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);\n\n\t\thdmi_writeb(hdmi, HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH,\n\t\t\t    HDMI_MC_FLOWCTRL);\n\t} else {\n\t\thdmi->mc_clkdis |= HDMI_MC_CLKDIS_CSCCLK_DISABLE;\n\t\thdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);\n\n\t\thdmi_writeb(hdmi, HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS,\n\t\t\t    HDMI_MC_FLOWCTRL);\n\t}\n}\n\n \nstatic void dw_hdmi_clear_overflow(struct dw_hdmi *hdmi)\n{\n\tunsigned int count;\n\tunsigned int i;\n\tu8 val;\n\n\t \n\n\tswitch (hdmi->version) {\n\tcase 0x130a:\n\t\tcount = 4;\n\t\tbreak;\n\tdefault:\n\t\tcount = 1;\n\t\tbreak;\n\t}\n\n\t \n\thdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ, HDMI_MC_SWRSTZ);\n\n\tval = hdmi_readb(hdmi, HDMI_FC_INVIDCONF);\n\tfor (i = 0; i < count; i++)\n\t\thdmi_writeb(hdmi, val, HDMI_FC_INVIDCONF);\n}\n\nstatic void hdmi_disable_overflow_interrupts(struct dw_hdmi *hdmi)\n{\n\thdmi_writeb(hdmi, HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK,\n\t\t    HDMI_IH_MUTE_FC_STAT2);\n}\n\nstatic int dw_hdmi_setup(struct dw_hdmi *hdmi,\n\t\t\t const struct drm_connector *connector,\n\t\t\t const struct drm_display_mode *mode)\n{\n\tint ret;\n\n\thdmi_disable_overflow_interrupts(hdmi);\n\n\thdmi->vic = drm_match_cea_mode(mode);\n\n\tif (!hdmi->vic) {\n\t\tdev_dbg(hdmi->dev, \"Non-CEA mode used in HDMI\\n\");\n\t} else {\n\t\tdev_dbg(hdmi->dev, \"CEA mode used vic=%d\\n\", hdmi->vic);\n\t}\n\n\tif ((hdmi->vic == 6) || (hdmi->vic == 7) ||\n\t    (hdmi->vic == 21) || (hdmi->vic == 22) ||\n\t    (hdmi->vic == 2) || (hdmi->vic == 3) ||\n\t    (hdmi->vic == 17) || (hdmi->vic == 18))\n\t\thdmi->hdmi_data.enc_out_encoding = V4L2_YCBCR_ENC_601;\n\telse\n\t\thdmi->hdmi_data.enc_out_encoding = V4L2_YCBCR_ENC_709;\n\n\thdmi->hdmi_data.video_mode.mpixelrepetitionoutput = 0;\n\thdmi->hdmi_data.video_mode.mpixelrepetitioninput = 0;\n\n\tif (hdmi->hdmi_data.enc_in_bus_format == MEDIA_BUS_FMT_FIXED)\n\t\thdmi->hdmi_data.enc_in_bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\n\t \n\tif (hdmi->plat_data->input_bus_encoding)\n\t\thdmi->hdmi_data.enc_in_encoding =\n\t\t\thdmi->plat_data->input_bus_encoding;\n\telse\n\t\thdmi->hdmi_data.enc_in_encoding = V4L2_YCBCR_ENC_DEFAULT;\n\n\tif (hdmi->hdmi_data.enc_out_bus_format == MEDIA_BUS_FMT_FIXED)\n\t\thdmi->hdmi_data.enc_out_bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\n\thdmi->hdmi_data.rgb_limited_range = hdmi->sink_is_hdmi &&\n\t\tdrm_default_rgb_quant_range(mode) ==\n\t\tHDMI_QUANTIZATION_RANGE_LIMITED;\n\n\thdmi->hdmi_data.pix_repet_factor = 0;\n\thdmi->hdmi_data.hdcp_enable = 0;\n\thdmi->hdmi_data.video_mode.mdataenablepolarity = true;\n\n\t \n\thdmi_av_composer(hdmi, &connector->display_info, mode);\n\n\t \n\tret = hdmi->phy.ops->init(hdmi, hdmi->phy.data,\n\t\t\t\t  &connector->display_info,\n\t\t\t\t  &hdmi->previous_mode);\n\tif (ret)\n\t\treturn ret;\n\thdmi->phy.enabled = true;\n\n\t \n\tdw_hdmi_enable_video_path(hdmi);\n\n\tif (hdmi->sink_has_audio) {\n\t\tdev_dbg(hdmi->dev, \"sink has audio support\\n\");\n\n\t\t \n\t\thdmi_clk_regenerator_update_pixel_clock(hdmi);\n\t\thdmi_enable_audio_clk(hdmi, hdmi->audio_enable);\n\t}\n\n\t \n\tif (hdmi->sink_is_hdmi) {\n\t\tdev_dbg(hdmi->dev, \"%s HDMI mode\\n\", __func__);\n\n\t\t \n\t\thdmi_config_AVI(hdmi, connector, mode);\n\t\thdmi_config_vendor_specific_infoframe(hdmi, connector, mode);\n\t\thdmi_config_drm_infoframe(hdmi, connector);\n\t} else {\n\t\tdev_dbg(hdmi->dev, \"%s DVI mode\\n\", __func__);\n\t}\n\n\thdmi_video_packetize(hdmi);\n\thdmi_video_csc(hdmi);\n\thdmi_video_sample(hdmi);\n\thdmi_tx_hdcp_config(hdmi);\n\n\tdw_hdmi_clear_overflow(hdmi);\n\n\treturn 0;\n}\n\nstatic void initialize_hdmi_ih_mutes(struct dw_hdmi *hdmi)\n{\n\tu8 ih_mute;\n\n\t \n\tih_mute = hdmi_readb(hdmi, HDMI_IH_MUTE) |\n\t\t  HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |\n\t\t  HDMI_IH_MUTE_MUTE_ALL_INTERRUPT;\n\n\thdmi_writeb(hdmi, ih_mute, HDMI_IH_MUTE);\n\n\t \n\thdmi_writeb(hdmi, 0xff, HDMI_VP_MASK);\n\thdmi_writeb(hdmi, 0xff, HDMI_FC_MASK0);\n\thdmi_writeb(hdmi, 0xff, HDMI_FC_MASK1);\n\thdmi_writeb(hdmi, 0xff, HDMI_FC_MASK2);\n\thdmi_writeb(hdmi, 0xff, HDMI_PHY_MASK0);\n\thdmi_writeb(hdmi, 0xff, HDMI_PHY_I2CM_INT_ADDR);\n\thdmi_writeb(hdmi, 0xff, HDMI_PHY_I2CM_CTLINT_ADDR);\n\thdmi_writeb(hdmi, 0xff, HDMI_AUD_INT);\n\thdmi_writeb(hdmi, 0xff, HDMI_AUD_SPDIFINT);\n\thdmi_writeb(hdmi, 0xff, HDMI_AUD_HBR_MASK);\n\thdmi_writeb(hdmi, 0xff, HDMI_GP_MASK);\n\thdmi_writeb(hdmi, 0xff, HDMI_A_APIINTMSK);\n\thdmi_writeb(hdmi, 0xff, HDMI_I2CM_INT);\n\thdmi_writeb(hdmi, 0xff, HDMI_I2CM_CTLINT);\n\n\t \n\thdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT0);\n\thdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT1);\n\thdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT2);\n\thdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_AS_STAT0);\n\thdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_PHY_STAT0);\n\thdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_I2CM_STAT0);\n\thdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_CEC_STAT0);\n\thdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_VP_STAT0);\n\thdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_I2CMPHY_STAT0);\n\thdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_AHBDMAAUD_STAT0);\n\n\t \n\tih_mute &= ~(HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |\n\t\t    HDMI_IH_MUTE_MUTE_ALL_INTERRUPT);\n\thdmi_writeb(hdmi, ih_mute, HDMI_IH_MUTE);\n}\n\nstatic void dw_hdmi_poweron(struct dw_hdmi *hdmi)\n{\n\thdmi->bridge_is_on = true;\n\n\t \n\tdw_hdmi_setup(hdmi, hdmi->curr_conn, &hdmi->previous_mode);\n}\n\nstatic void dw_hdmi_poweroff(struct dw_hdmi *hdmi)\n{\n\tif (hdmi->phy.enabled) {\n\t\thdmi->phy.ops->disable(hdmi, hdmi->phy.data);\n\t\thdmi->phy.enabled = false;\n\t}\n\n\thdmi->bridge_is_on = false;\n}\n\nstatic void dw_hdmi_update_power(struct dw_hdmi *hdmi)\n{\n\tint force = hdmi->force;\n\n\tif (hdmi->disabled) {\n\t\tforce = DRM_FORCE_OFF;\n\t} else if (force == DRM_FORCE_UNSPECIFIED) {\n\t\tif (hdmi->rxsense)\n\t\t\tforce = DRM_FORCE_ON;\n\t\telse\n\t\t\tforce = DRM_FORCE_OFF;\n\t}\n\n\tif (force == DRM_FORCE_OFF) {\n\t\tif (hdmi->bridge_is_on)\n\t\t\tdw_hdmi_poweroff(hdmi);\n\t} else {\n\t\tif (!hdmi->bridge_is_on)\n\t\t\tdw_hdmi_poweron(hdmi);\n\t}\n}\n\n \nstatic void dw_hdmi_update_phy_mask(struct dw_hdmi *hdmi)\n{\n\tif (hdmi->phy.ops->update_hpd)\n\t\thdmi->phy.ops->update_hpd(hdmi, hdmi->phy.data,\n\t\t\t\t\t  hdmi->force, hdmi->disabled,\n\t\t\t\t\t  hdmi->rxsense);\n}\n\nstatic enum drm_connector_status dw_hdmi_detect(struct dw_hdmi *hdmi)\n{\n\tenum drm_connector_status result;\n\n\tresult = hdmi->phy.ops->read_hpd(hdmi, hdmi->phy.data);\n\thdmi->last_connector_result = result;\n\n\treturn result;\n}\n\nstatic struct edid *dw_hdmi_get_edid(struct dw_hdmi *hdmi,\n\t\t\t\t     struct drm_connector *connector)\n{\n\tstruct edid *edid;\n\n\tif (!hdmi->ddc)\n\t\treturn NULL;\n\n\tedid = drm_get_edid(connector, hdmi->ddc);\n\tif (!edid) {\n\t\tdev_dbg(hdmi->dev, \"failed to get edid\\n\");\n\t\treturn NULL;\n\t}\n\n\tdev_dbg(hdmi->dev, \"got edid: width[%d] x height[%d]\\n\",\n\t\tedid->width_cm, edid->height_cm);\n\n\thdmi->sink_is_hdmi = drm_detect_hdmi_monitor(edid);\n\thdmi->sink_has_audio = drm_detect_monitor_audio(edid);\n\n\treturn edid;\n}\n\n \n\nstatic enum drm_connector_status\ndw_hdmi_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct dw_hdmi *hdmi = container_of(connector, struct dw_hdmi,\n\t\t\t\t\t     connector);\n\treturn dw_hdmi_detect(hdmi);\n}\n\nstatic int dw_hdmi_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct dw_hdmi *hdmi = container_of(connector, struct dw_hdmi,\n\t\t\t\t\t     connector);\n\tstruct edid *edid;\n\tint ret;\n\n\tedid = dw_hdmi_get_edid(hdmi, connector);\n\tif (!edid)\n\t\treturn 0;\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tcec_notifier_set_phys_addr_from_edid(hdmi->cec_notifier, edid);\n\tret = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\treturn ret;\n}\n\nstatic int dw_hdmi_connector_atomic_check(struct drm_connector *connector,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *old_state =\n\t\tdrm_atomic_get_old_connector_state(state, connector);\n\tstruct drm_connector_state *new_state =\n\t\tdrm_atomic_get_new_connector_state(state, connector);\n\tstruct drm_crtc *crtc = new_state->crtc;\n\tstruct drm_crtc_state *crtc_state;\n\n\tif (!crtc)\n\t\treturn 0;\n\n\tif (!drm_connector_atomic_hdr_metadata_equal(old_state, new_state)) {\n\t\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tcrtc_state->mode_changed = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void dw_hdmi_connector_force(struct drm_connector *connector)\n{\n\tstruct dw_hdmi *hdmi = container_of(connector, struct dw_hdmi,\n\t\t\t\t\t     connector);\n\n\tmutex_lock(&hdmi->mutex);\n\thdmi->force = connector->force;\n\tdw_hdmi_update_power(hdmi);\n\tdw_hdmi_update_phy_mask(hdmi);\n\tmutex_unlock(&hdmi->mutex);\n}\n\nstatic const struct drm_connector_funcs dw_hdmi_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = dw_hdmi_connector_detect,\n\t.destroy = drm_connector_cleanup,\n\t.force = dw_hdmi_connector_force,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_connector_helper_funcs dw_hdmi_connector_helper_funcs = {\n\t.get_modes = dw_hdmi_connector_get_modes,\n\t.atomic_check = dw_hdmi_connector_atomic_check,\n};\n\nstatic int dw_hdmi_connector_create(struct dw_hdmi *hdmi)\n{\n\tstruct drm_connector *connector = &hdmi->connector;\n\tstruct cec_connector_info conn_info;\n\tstruct cec_notifier *notifier;\n\n\tif (hdmi->version >= 0x200a)\n\t\tconnector->ycbcr_420_allowed =\n\t\t\thdmi->plat_data->ycbcr_420_allowed;\n\telse\n\t\tconnector->ycbcr_420_allowed = false;\n\n\tconnector->interlace_allowed = 1;\n\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tdrm_connector_helper_add(connector, &dw_hdmi_connector_helper_funcs);\n\n\tdrm_connector_init_with_ddc(hdmi->bridge.dev, connector,\n\t\t\t\t    &dw_hdmi_connector_funcs,\n\t\t\t\t    DRM_MODE_CONNECTOR_HDMIA,\n\t\t\t\t    hdmi->ddc);\n\n\t \n\tdrm_atomic_helper_connector_reset(connector);\n\n\tdrm_connector_attach_max_bpc_property(connector, 8, 16);\n\n\tif (hdmi->version >= 0x200a && hdmi->plat_data->use_drm_infoframe)\n\t\tdrm_connector_attach_hdr_output_metadata_property(connector);\n\n\tdrm_connector_attach_encoder(connector, hdmi->bridge.encoder);\n\n\tcec_fill_conn_info_from_drm(&conn_info, connector);\n\n\tnotifier = cec_notifier_conn_register(hdmi->dev, NULL, &conn_info);\n\tif (!notifier)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&hdmi->cec_notifier_mutex);\n\thdmi->cec_notifier = notifier;\n\tmutex_unlock(&hdmi->cec_notifier_mutex);\n\n\treturn 0;\n}\n\n \n\n \n\n \n#define MAX_OUTPUT_SEL_FORMATS\t11\n\nstatic u32 *dw_hdmi_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state,\n\t\t\t\t\tunsigned int *num_output_fmts)\n{\n\tstruct drm_connector *conn = conn_state->connector;\n\tstruct drm_display_info *info = &conn->display_info;\n\tstruct drm_display_mode *mode = &crtc_state->mode;\n\tu8 max_bpc = conn_state->max_requested_bpc;\n\tbool is_hdmi2_sink = info->hdmi.scdc.supported ||\n\t\t\t     (info->color_formats & DRM_COLOR_FORMAT_YCBCR420);\n\tu32 *output_fmts;\n\tunsigned int i = 0;\n\n\t*num_output_fmts = 0;\n\n\toutput_fmts = kcalloc(MAX_OUTPUT_SEL_FORMATS, sizeof(*output_fmts),\n\t\t\t      GFP_KERNEL);\n\tif (!output_fmts)\n\t\treturn NULL;\n\n\t \n\tif (list_is_singular(&bridge->encoder->bridge_chain) ||\n\t    list_is_first(&bridge->chain_node, &bridge->encoder->bridge_chain)) {\n\t\t*num_output_fmts = 1;\n\t\toutput_fmts[0] = MEDIA_BUS_FMT_FIXED;\n\n\t\treturn output_fmts;\n\t}\n\n\t \n\tif (conn->ycbcr_420_allowed &&\n\t    (drm_mode_is_420_only(info, mode) ||\n\t     (is_hdmi2_sink && drm_mode_is_420_also(info, mode)))) {\n\n\t\t \n\t\tif (max_bpc >= 16 && info->bpc == 16 &&\n\t\t    (info->hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_48))\n\t\t\toutput_fmts[i++] = MEDIA_BUS_FMT_UYYVYY16_0_5X48;\n\n\t\tif (max_bpc >= 12 && info->bpc >= 12 &&\n\t\t    (info->hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_36))\n\t\t\toutput_fmts[i++] = MEDIA_BUS_FMT_UYYVYY12_0_5X36;\n\n\t\tif (max_bpc >= 10 && info->bpc >= 10 &&\n\t\t    (info->hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_30))\n\t\t\toutput_fmts[i++] = MEDIA_BUS_FMT_UYYVYY10_0_5X30;\n\n\t\t \n\t\toutput_fmts[i++] = MEDIA_BUS_FMT_UYYVYY8_0_5X24;\n\n\t\tif (drm_mode_is_420_only(info, mode)) {\n\t\t\t*num_output_fmts = i;\n\t\t\treturn output_fmts;\n\t\t}\n\t}\n\n\t \n\n\t \n\toutput_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;\n\n\tif (max_bpc >= 16 && info->bpc == 16) {\n\t\tif (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)\n\t\t\toutput_fmts[i++] = MEDIA_BUS_FMT_YUV16_1X48;\n\n\t\toutput_fmts[i++] = MEDIA_BUS_FMT_RGB161616_1X48;\n\t}\n\n\tif (max_bpc >= 12 && info->bpc >= 12) {\n\t\tif (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)\n\t\t\toutput_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;\n\n\t\tif (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)\n\t\t\toutput_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;\n\n\t\toutput_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;\n\t}\n\n\tif (max_bpc >= 10 && info->bpc >= 10) {\n\t\tif (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)\n\t\t\toutput_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;\n\n\t\tif (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)\n\t\t\toutput_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;\n\n\t\toutput_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;\n\t}\n\n\tif (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)\n\t\toutput_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;\n\n\tif (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)\n\t\toutput_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;\n\n\t*num_output_fmts = i;\n\n\treturn output_fmts;\n}\n\n \n\n \n#define MAX_INPUT_SEL_FORMATS\t3\n\nstatic u32 *dw_hdmi_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state,\n\t\t\t\t\tu32 output_fmt,\n\t\t\t\t\tunsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\tunsigned int i = 0;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tswitch (output_fmt) {\n\t \n\tcase MEDIA_BUS_FMT_FIXED:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\t \n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUV8_1X24:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\n\t \n\tcase MEDIA_BUS_FMT_RGB101010_1X30:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUV10_1X30:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY10_1X20:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;\n\t\tbreak;\n\n\t \n\tcase MEDIA_BUS_FMT_RGB121212_1X36:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUV12_1X36:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY12_1X24:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;\n\t\tbreak;\n\n\t \n\tcase MEDIA_BUS_FMT_RGB161616_1X48:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB161616_1X48;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_YUV16_1X48;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUV16_1X48:\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_YUV16_1X48;\n\t\tinput_fmts[i++] = MEDIA_BUS_FMT_RGB161616_1X48;\n\t\tbreak;\n\n\t \n\tcase MEDIA_BUS_FMT_UYYVYY8_0_5X24:\n\tcase MEDIA_BUS_FMT_UYYVYY10_0_5X30:\n\tcase MEDIA_BUS_FMT_UYYVYY12_0_5X36:\n\tcase MEDIA_BUS_FMT_UYYVYY16_0_5X48:\n\t\tinput_fmts[i++] = output_fmt;\n\t\tbreak;\n\t}\n\n\t*num_input_fmts = i;\n\n\tif (*num_input_fmts == 0) {\n\t\tkfree(input_fmts);\n\t\tinput_fmts = NULL;\n\t}\n\n\treturn input_fmts;\n}\n\nstatic int dw_hdmi_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t       struct drm_bridge_state *bridge_state,\n\t\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct dw_hdmi *hdmi = bridge->driver_private;\n\n\thdmi->hdmi_data.enc_out_bus_format =\n\t\t\tbridge_state->output_bus_cfg.format;\n\n\thdmi->hdmi_data.enc_in_bus_format =\n\t\t\tbridge_state->input_bus_cfg.format;\n\n\tdev_dbg(hdmi->dev, \"input format 0x%04x, output format 0x%04x\\n\",\n\t\tbridge_state->input_bus_cfg.format,\n\t\tbridge_state->output_bus_cfg.format);\n\n\treturn 0;\n}\n\nstatic int dw_hdmi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct dw_hdmi *hdmi = bridge->driver_private;\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)\n\t\treturn drm_bridge_attach(bridge->encoder, hdmi->next_bridge,\n\t\t\t\t\t bridge, flags);\n\n\treturn dw_hdmi_connector_create(hdmi);\n}\n\nstatic void dw_hdmi_bridge_detach(struct drm_bridge *bridge)\n{\n\tstruct dw_hdmi *hdmi = bridge->driver_private;\n\n\tmutex_lock(&hdmi->cec_notifier_mutex);\n\tcec_notifier_conn_unregister(hdmi->cec_notifier);\n\thdmi->cec_notifier = NULL;\n\tmutex_unlock(&hdmi->cec_notifier_mutex);\n}\n\nstatic enum drm_mode_status\ndw_hdmi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t  const struct drm_display_info *info,\n\t\t\t  const struct drm_display_mode *mode)\n{\n\tstruct dw_hdmi *hdmi = bridge->driver_private;\n\tconst struct dw_hdmi_plat_data *pdata = hdmi->plat_data;\n\tenum drm_mode_status mode_status = MODE_OK;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\treturn MODE_BAD;\n\n\tif (pdata->mode_valid)\n\t\tmode_status = pdata->mode_valid(hdmi, pdata->priv_data, info,\n\t\t\t\t\t\tmode);\n\n\treturn mode_status;\n}\n\nstatic void dw_hdmi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t    const struct drm_display_mode *orig_mode,\n\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct dw_hdmi *hdmi = bridge->driver_private;\n\n\tmutex_lock(&hdmi->mutex);\n\n\t \n\tdrm_mode_copy(&hdmi->previous_mode, mode);\n\n\tmutex_unlock(&hdmi->mutex);\n}\n\nstatic void dw_hdmi_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_bridge_state *old_state)\n{\n\tstruct dw_hdmi *hdmi = bridge->driver_private;\n\n\tmutex_lock(&hdmi->mutex);\n\thdmi->disabled = true;\n\thdmi->curr_conn = NULL;\n\tdw_hdmi_update_power(hdmi);\n\tdw_hdmi_update_phy_mask(hdmi);\n\thandle_plugged_change(hdmi, false);\n\tmutex_unlock(&hdmi->mutex);\n}\n\nstatic void dw_hdmi_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\t struct drm_bridge_state *old_state)\n{\n\tstruct dw_hdmi *hdmi = bridge->driver_private;\n\tstruct drm_atomic_state *state = old_state->base.state;\n\tstruct drm_connector *connector;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\n\tmutex_lock(&hdmi->mutex);\n\thdmi->disabled = false;\n\thdmi->curr_conn = connector;\n\tdw_hdmi_update_power(hdmi);\n\tdw_hdmi_update_phy_mask(hdmi);\n\thandle_plugged_change(hdmi, true);\n\tmutex_unlock(&hdmi->mutex);\n}\n\nstatic enum drm_connector_status dw_hdmi_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct dw_hdmi *hdmi = bridge->driver_private;\n\n\treturn dw_hdmi_detect(hdmi);\n}\n\nstatic struct edid *dw_hdmi_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_connector *connector)\n{\n\tstruct dw_hdmi *hdmi = bridge->driver_private;\n\n\treturn dw_hdmi_get_edid(hdmi, connector);\n}\n\nstatic const struct drm_bridge_funcs dw_hdmi_bridge_funcs = {\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.attach = dw_hdmi_bridge_attach,\n\t.detach = dw_hdmi_bridge_detach,\n\t.atomic_check = dw_hdmi_bridge_atomic_check,\n\t.atomic_get_output_bus_fmts = dw_hdmi_bridge_atomic_get_output_bus_fmts,\n\t.atomic_get_input_bus_fmts = dw_hdmi_bridge_atomic_get_input_bus_fmts,\n\t.atomic_enable = dw_hdmi_bridge_atomic_enable,\n\t.atomic_disable = dw_hdmi_bridge_atomic_disable,\n\t.mode_set = dw_hdmi_bridge_mode_set,\n\t.mode_valid = dw_hdmi_bridge_mode_valid,\n\t.detect = dw_hdmi_bridge_detect,\n\t.get_edid = dw_hdmi_bridge_get_edid,\n};\n\n \n\nstatic irqreturn_t dw_hdmi_i2c_irq(struct dw_hdmi *hdmi)\n{\n\tstruct dw_hdmi_i2c *i2c = hdmi->i2c;\n\tunsigned int stat;\n\n\tstat = hdmi_readb(hdmi, HDMI_IH_I2CM_STAT0);\n\tif (!stat)\n\t\treturn IRQ_NONE;\n\n\thdmi_writeb(hdmi, stat, HDMI_IH_I2CM_STAT0);\n\n\ti2c->stat = stat;\n\n\tcomplete(&i2c->cmp);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t dw_hdmi_hardirq(int irq, void *dev_id)\n{\n\tstruct dw_hdmi *hdmi = dev_id;\n\tu8 intr_stat;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (hdmi->i2c)\n\t\tret = dw_hdmi_i2c_irq(hdmi);\n\n\tintr_stat = hdmi_readb(hdmi, HDMI_IH_PHY_STAT0);\n\tif (intr_stat) {\n\t\thdmi_writeb(hdmi, ~0, HDMI_IH_MUTE_PHY_STAT0);\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\treturn ret;\n}\n\nvoid dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense)\n{\n\tmutex_lock(&hdmi->mutex);\n\n\tif (!hdmi->force) {\n\t\t \n\t\tif (!rx_sense)\n\t\t\thdmi->rxsense = false;\n\n\t\t \n\t\tif (hpd)\n\t\t\thdmi->rxsense = true;\n\n\t\tdw_hdmi_update_power(hdmi);\n\t\tdw_hdmi_update_phy_mask(hdmi);\n\t}\n\tmutex_unlock(&hdmi->mutex);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_setup_rx_sense);\n\nstatic irqreturn_t dw_hdmi_irq(int irq, void *dev_id)\n{\n\tstruct dw_hdmi *hdmi = dev_id;\n\tu8 intr_stat, phy_int_pol, phy_pol_mask, phy_stat;\n\tenum drm_connector_status status = connector_status_unknown;\n\n\tintr_stat = hdmi_readb(hdmi, HDMI_IH_PHY_STAT0);\n\tphy_int_pol = hdmi_readb(hdmi, HDMI_PHY_POL0);\n\tphy_stat = hdmi_readb(hdmi, HDMI_PHY_STAT0);\n\n\tphy_pol_mask = 0;\n\tif (intr_stat & HDMI_IH_PHY_STAT0_HPD)\n\t\tphy_pol_mask |= HDMI_PHY_HPD;\n\tif (intr_stat & HDMI_IH_PHY_STAT0_RX_SENSE0)\n\t\tphy_pol_mask |= HDMI_PHY_RX_SENSE0;\n\tif (intr_stat & HDMI_IH_PHY_STAT0_RX_SENSE1)\n\t\tphy_pol_mask |= HDMI_PHY_RX_SENSE1;\n\tif (intr_stat & HDMI_IH_PHY_STAT0_RX_SENSE2)\n\t\tphy_pol_mask |= HDMI_PHY_RX_SENSE2;\n\tif (intr_stat & HDMI_IH_PHY_STAT0_RX_SENSE3)\n\t\tphy_pol_mask |= HDMI_PHY_RX_SENSE3;\n\n\tif (phy_pol_mask)\n\t\thdmi_modb(hdmi, ~phy_int_pol, phy_pol_mask, HDMI_PHY_POL0);\n\n\t \n\tif (intr_stat &\n\t    (HDMI_IH_PHY_STAT0_RX_SENSE | HDMI_IH_PHY_STAT0_HPD)) {\n\t\tdw_hdmi_setup_rx_sense(hdmi,\n\t\t\t\t       phy_stat & HDMI_PHY_HPD,\n\t\t\t\t       phy_stat & HDMI_PHY_RX_SENSE);\n\n\t\tif ((phy_stat & (HDMI_PHY_RX_SENSE | HDMI_PHY_HPD)) == 0) {\n\t\t\tmutex_lock(&hdmi->cec_notifier_mutex);\n\t\t\tcec_notifier_phys_addr_invalidate(hdmi->cec_notifier);\n\t\t\tmutex_unlock(&hdmi->cec_notifier_mutex);\n\t\t}\n\n\t\tif (phy_stat & HDMI_PHY_HPD)\n\t\t\tstatus = connector_status_connected;\n\n\t\tif (!(phy_stat & (HDMI_PHY_HPD | HDMI_PHY_RX_SENSE)))\n\t\t\tstatus = connector_status_disconnected;\n\t}\n\n\tif (status != connector_status_unknown) {\n\t\tdev_dbg(hdmi->dev, \"EVENT=%s\\n\",\n\t\t\tstatus == connector_status_connected ?\n\t\t\t\"plugin\" : \"plugout\");\n\n\t\tif (hdmi->bridge.dev) {\n\t\t\tdrm_helper_hpd_irq_event(hdmi->bridge.dev);\n\t\t\tdrm_bridge_hpd_notify(&hdmi->bridge, status);\n\t\t}\n\t}\n\n\thdmi_writeb(hdmi, intr_stat, HDMI_IH_PHY_STAT0);\n\thdmi_writeb(hdmi, ~(HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE),\n\t\t    HDMI_IH_MUTE_PHY_STAT0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct dw_hdmi_phy_data dw_hdmi_phys[] = {\n\t{\n\t\t.type = DW_HDMI_PHY_DWC_HDMI_TX_PHY,\n\t\t.name = \"DWC HDMI TX PHY\",\n\t\t.gen = 1,\n\t}, {\n\t\t.type = DW_HDMI_PHY_DWC_MHL_PHY_HEAC,\n\t\t.name = \"DWC MHL PHY + HEAC PHY\",\n\t\t.gen = 2,\n\t\t.has_svsret = true,\n\t\t.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,\n\t}, {\n\t\t.type = DW_HDMI_PHY_DWC_MHL_PHY,\n\t\t.name = \"DWC MHL PHY\",\n\t\t.gen = 2,\n\t\t.has_svsret = true,\n\t\t.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,\n\t}, {\n\t\t.type = DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY_HEAC,\n\t\t.name = \"DWC HDMI 3D TX PHY + HEAC PHY\",\n\t\t.gen = 2,\n\t\t.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,\n\t}, {\n\t\t.type = DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY,\n\t\t.name = \"DWC HDMI 3D TX PHY\",\n\t\t.gen = 2,\n\t\t.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,\n\t}, {\n\t\t.type = DW_HDMI_PHY_DWC_HDMI20_TX_PHY,\n\t\t.name = \"DWC HDMI 2.0 TX PHY\",\n\t\t.gen = 2,\n\t\t.has_svsret = true,\n\t\t.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,\n\t}, {\n\t\t.type = DW_HDMI_PHY_VENDOR_PHY,\n\t\t.name = \"Vendor PHY\",\n\t}\n};\n\nstatic int dw_hdmi_detect_phy(struct dw_hdmi *hdmi)\n{\n\tunsigned int i;\n\tu8 phy_type;\n\n\tphy_type = hdmi->plat_data->phy_force_vendor ?\n\t\t\t\tDW_HDMI_PHY_VENDOR_PHY :\n\t\t\t\thdmi_readb(hdmi, HDMI_CONFIG2_ID);\n\n\tif (phy_type == DW_HDMI_PHY_VENDOR_PHY) {\n\t\t \n\t\tif (!hdmi->plat_data->phy_ops || !hdmi->plat_data->phy_name) {\n\t\t\tdev_err(hdmi->dev,\n\t\t\t\t\"Vendor HDMI PHY not supported by glue layer\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\thdmi->phy.ops = hdmi->plat_data->phy_ops;\n\t\thdmi->phy.data = hdmi->plat_data->phy_data;\n\t\thdmi->phy.name = hdmi->plat_data->phy_name;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dw_hdmi_phys); ++i) {\n\t\tif (dw_hdmi_phys[i].type == phy_type) {\n\t\t\thdmi->phy.ops = &dw_hdmi_synopsys_phy_ops;\n\t\t\thdmi->phy.name = dw_hdmi_phys[i].name;\n\t\t\thdmi->phy.data = (void *)&dw_hdmi_phys[i];\n\n\t\t\tif (!dw_hdmi_phys[i].configure &&\n\t\t\t    !hdmi->plat_data->configure_phy) {\n\t\t\t\tdev_err(hdmi->dev, \"%s requires platform support\\n\",\n\t\t\t\t\thdmi->phy.name);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(hdmi->dev, \"Unsupported HDMI PHY type (%02x)\\n\", phy_type);\n\treturn -ENODEV;\n}\n\nstatic void dw_hdmi_cec_enable(struct dw_hdmi *hdmi)\n{\n\tmutex_lock(&hdmi->mutex);\n\thdmi->mc_clkdis &= ~HDMI_MC_CLKDIS_CECCLK_DISABLE;\n\thdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);\n\tmutex_unlock(&hdmi->mutex);\n}\n\nstatic void dw_hdmi_cec_disable(struct dw_hdmi *hdmi)\n{\n\tmutex_lock(&hdmi->mutex);\n\thdmi->mc_clkdis |= HDMI_MC_CLKDIS_CECCLK_DISABLE;\n\thdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);\n\tmutex_unlock(&hdmi->mutex);\n}\n\nstatic const struct dw_hdmi_cec_ops dw_hdmi_cec_ops = {\n\t.write = hdmi_writeb,\n\t.read = hdmi_readb,\n\t.enable = dw_hdmi_cec_enable,\n\t.disable = dw_hdmi_cec_disable,\n};\n\nstatic const struct regmap_config hdmi_regmap_8bit_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 8,\n\t.reg_stride\t= 1,\n\t.max_register\t= HDMI_I2CM_FS_SCL_LCNT_0_ADDR,\n};\n\nstatic const struct regmap_config hdmi_regmap_32bit_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= HDMI_I2CM_FS_SCL_LCNT_0_ADDR << 2,\n};\n\nstatic void dw_hdmi_init_hw(struct dw_hdmi *hdmi)\n{\n\tinitialize_hdmi_ih_mutes(hdmi);\n\n\t \n\tdw_hdmi_i2c_init(hdmi);\n\n\tif (hdmi->phy.ops->setup_hpd)\n\t\thdmi->phy.ops->setup_hpd(hdmi, hdmi->phy.data);\n}\n\n \n\nstatic int dw_hdmi_parse_dt(struct dw_hdmi *hdmi)\n{\n\tstruct device_node *endpoint;\n\tstruct device_node *remote;\n\n\tif (!hdmi->plat_data->output_port)\n\t\treturn 0;\n\n\tendpoint = of_graph_get_endpoint_by_regs(hdmi->dev->of_node,\n\t\t\t\t\t\t hdmi->plat_data->output_port,\n\t\t\t\t\t\t -1);\n\tif (!endpoint) {\n\t\t \n\t\tdev_err(hdmi->dev, \"Missing endpoint in port@%u\\n\",\n\t\t\thdmi->plat_data->output_port);\n\t\treturn -ENODEV;\n\t}\n\n\tremote = of_graph_get_remote_port_parent(endpoint);\n\tof_node_put(endpoint);\n\tif (!remote) {\n\t\tdev_err(hdmi->dev, \"Endpoint in port@%u unconnected\\n\",\n\t\t\thdmi->plat_data->output_port);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!of_device_is_available(remote)) {\n\t\tdev_err(hdmi->dev, \"port@%u remote device is disabled\\n\",\n\t\t\thdmi->plat_data->output_port);\n\t\tof_node_put(remote);\n\t\treturn -ENODEV;\n\t}\n\n\thdmi->next_bridge = of_drm_find_bridge(remote);\n\tof_node_put(remote);\n\tif (!hdmi->next_bridge)\n\t\treturn -EPROBE_DEFER;\n\n\treturn 0;\n}\n\nbool dw_hdmi_bus_fmt_is_420(struct dw_hdmi *hdmi)\n{\n\treturn hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_bus_fmt_is_420);\n\nstruct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,\n\t\t\t      const struct dw_hdmi_plat_data *plat_data)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct platform_device_info pdevinfo;\n\tstruct device_node *ddc_node;\n\tstruct dw_hdmi_cec_data cec;\n\tstruct dw_hdmi *hdmi;\n\tstruct resource *iores = NULL;\n\tint irq;\n\tint ret;\n\tu32 val = 1;\n\tu8 prod_id0;\n\tu8 prod_id1;\n\tu8 config0;\n\tu8 config3;\n\n\thdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thdmi->plat_data = plat_data;\n\thdmi->dev = dev;\n\thdmi->sample_rate = 48000;\n\thdmi->channels = 2;\n\thdmi->disabled = true;\n\thdmi->rxsense = true;\n\thdmi->phy_mask = (u8)~(HDMI_PHY_HPD | HDMI_PHY_RX_SENSE);\n\thdmi->mc_clkdis = 0x7f;\n\thdmi->last_connector_result = connector_status_disconnected;\n\n\tmutex_init(&hdmi->mutex);\n\tmutex_init(&hdmi->audio_mutex);\n\tmutex_init(&hdmi->cec_notifier_mutex);\n\tspin_lock_init(&hdmi->audio_lock);\n\n\tret = dw_hdmi_parse_dt(hdmi);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tddc_node = of_parse_phandle(np, \"ddc-i2c-bus\", 0);\n\tif (ddc_node) {\n\t\thdmi->ddc = of_get_i2c_adapter_by_node(ddc_node);\n\t\tof_node_put(ddc_node);\n\t\tif (!hdmi->ddc) {\n\t\t\tdev_dbg(hdmi->dev, \"failed to read ddc node\\n\");\n\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t\t}\n\n\t} else {\n\t\tdev_dbg(hdmi->dev, \"no ddc property found\\n\");\n\t}\n\n\tif (!plat_data->regm) {\n\t\tconst struct regmap_config *reg_config;\n\n\t\tof_property_read_u32(np, \"reg-io-width\", &val);\n\t\tswitch (val) {\n\t\tcase 4:\n\t\t\treg_config = &hdmi_regmap_32bit_config;\n\t\t\thdmi->reg_shift = 2;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\treg_config = &hdmi_regmap_8bit_config;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"reg-io-width must be 1 or 4\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tiores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\thdmi->regs = devm_ioremap_resource(dev, iores);\n\t\tif (IS_ERR(hdmi->regs)) {\n\t\t\tret = PTR_ERR(hdmi->regs);\n\t\t\tgoto err_res;\n\t\t}\n\n\t\thdmi->regm = devm_regmap_init_mmio(dev, hdmi->regs, reg_config);\n\t\tif (IS_ERR(hdmi->regm)) {\n\t\t\tdev_err(dev, \"Failed to configure regmap\\n\");\n\t\t\tret = PTR_ERR(hdmi->regm);\n\t\t\tgoto err_res;\n\t\t}\n\t} else {\n\t\thdmi->regm = plat_data->regm;\n\t}\n\n\thdmi->isfr_clk = devm_clk_get(hdmi->dev, \"isfr\");\n\tif (IS_ERR(hdmi->isfr_clk)) {\n\t\tret = PTR_ERR(hdmi->isfr_clk);\n\t\tdev_err(hdmi->dev, \"Unable to get HDMI isfr clk: %d\\n\", ret);\n\t\tgoto err_res;\n\t}\n\n\tret = clk_prepare_enable(hdmi->isfr_clk);\n\tif (ret) {\n\t\tdev_err(hdmi->dev, \"Cannot enable HDMI isfr clock: %d\\n\", ret);\n\t\tgoto err_res;\n\t}\n\n\thdmi->iahb_clk = devm_clk_get(hdmi->dev, \"iahb\");\n\tif (IS_ERR(hdmi->iahb_clk)) {\n\t\tret = PTR_ERR(hdmi->iahb_clk);\n\t\tdev_err(hdmi->dev, \"Unable to get HDMI iahb clk: %d\\n\", ret);\n\t\tgoto err_isfr;\n\t}\n\n\tret = clk_prepare_enable(hdmi->iahb_clk);\n\tif (ret) {\n\t\tdev_err(hdmi->dev, \"Cannot enable HDMI iahb clock: %d\\n\", ret);\n\t\tgoto err_isfr;\n\t}\n\n\thdmi->cec_clk = devm_clk_get(hdmi->dev, \"cec\");\n\tif (PTR_ERR(hdmi->cec_clk) == -ENOENT) {\n\t\thdmi->cec_clk = NULL;\n\t} else if (IS_ERR(hdmi->cec_clk)) {\n\t\tret = PTR_ERR(hdmi->cec_clk);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(hdmi->dev, \"Cannot get HDMI cec clock: %d\\n\",\n\t\t\t\tret);\n\n\t\thdmi->cec_clk = NULL;\n\t\tgoto err_iahb;\n\t} else {\n\t\tret = clk_prepare_enable(hdmi->cec_clk);\n\t\tif (ret) {\n\t\t\tdev_err(hdmi->dev, \"Cannot enable HDMI cec clock: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_iahb;\n\t\t}\n\t}\n\n\t \n\thdmi->version = (hdmi_readb(hdmi, HDMI_DESIGN_ID) << 8)\n\t\t      | (hdmi_readb(hdmi, HDMI_REVISION_ID) << 0);\n\tprod_id0 = hdmi_readb(hdmi, HDMI_PRODUCT_ID0);\n\tprod_id1 = hdmi_readb(hdmi, HDMI_PRODUCT_ID1);\n\n\tif (prod_id0 != HDMI_PRODUCT_ID0_HDMI_TX ||\n\t    (prod_id1 & ~HDMI_PRODUCT_ID1_HDCP) != HDMI_PRODUCT_ID1_HDMI_TX) {\n\t\tdev_err(dev, \"Unsupported HDMI controller (%04x:%02x:%02x)\\n\",\n\t\t\thdmi->version, prod_id0, prod_id1);\n\t\tret = -ENODEV;\n\t\tgoto err_iahb;\n\t}\n\n\tret = dw_hdmi_detect_phy(hdmi);\n\tif (ret < 0)\n\t\tgoto err_iahb;\n\n\tdev_info(dev, \"Detected HDMI TX controller v%x.%03x %s HDCP (%s)\\n\",\n\t\t hdmi->version >> 12, hdmi->version & 0xfff,\n\t\t prod_id1 & HDMI_PRODUCT_ID1_HDCP ? \"with\" : \"without\",\n\t\t hdmi->phy.name);\n\n\tdw_hdmi_init_hw(hdmi);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_iahb;\n\t}\n\n\tret = devm_request_threaded_irq(dev, irq, dw_hdmi_hardirq,\n\t\t\t\t\tdw_hdmi_irq, IRQF_SHARED,\n\t\t\t\t\tdev_name(dev), hdmi);\n\tif (ret)\n\t\tgoto err_iahb;\n\n\t \n\thdmi_init_clk_regenerator(hdmi);\n\n\t \n\tif (!hdmi->ddc) {\n\t\t \n\t\thdmi->pinctrl = devm_pinctrl_get(dev);\n\t\tif (!IS_ERR(hdmi->pinctrl)) {\n\t\t\thdmi->unwedge_state =\n\t\t\t\tpinctrl_lookup_state(hdmi->pinctrl, \"unwedge\");\n\t\t\thdmi->default_state =\n\t\t\t\tpinctrl_lookup_state(hdmi->pinctrl, \"default\");\n\n\t\t\tif (IS_ERR(hdmi->default_state) ||\n\t\t\t    IS_ERR(hdmi->unwedge_state)) {\n\t\t\t\tif (!IS_ERR(hdmi->unwedge_state))\n\t\t\t\t\tdev_warn(dev,\n\t\t\t\t\t\t \"Unwedge requires default pinctrl\\n\");\n\t\t\t\thdmi->default_state = NULL;\n\t\t\t\thdmi->unwedge_state = NULL;\n\t\t\t}\n\t\t}\n\n\t\thdmi->ddc = dw_hdmi_i2c_adapter(hdmi);\n\t\tif (IS_ERR(hdmi->ddc))\n\t\t\thdmi->ddc = NULL;\n\t}\n\n\thdmi->bridge.driver_private = hdmi;\n\thdmi->bridge.funcs = &dw_hdmi_bridge_funcs;\n\thdmi->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID\n\t\t\t | DRM_BRIDGE_OP_HPD;\n\thdmi->bridge.interlace_allowed = true;\n\thdmi->bridge.ddc = hdmi->ddc;\n#ifdef CONFIG_OF\n\thdmi->bridge.of_node = pdev->dev.of_node;\n#endif\n\n\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\tpdevinfo.parent = dev;\n\tpdevinfo.id = PLATFORM_DEVID_AUTO;\n\n\tconfig0 = hdmi_readb(hdmi, HDMI_CONFIG0_ID);\n\tconfig3 = hdmi_readb(hdmi, HDMI_CONFIG3_ID);\n\n\tif (iores && config3 & HDMI_CONFIG3_AHBAUDDMA) {\n\t\tstruct dw_hdmi_audio_data audio;\n\n\t\taudio.phys = iores->start;\n\t\taudio.base = hdmi->regs;\n\t\taudio.irq = irq;\n\t\taudio.hdmi = hdmi;\n\t\taudio.get_eld = hdmi_audio_get_eld;\n\t\thdmi->enable_audio = dw_hdmi_ahb_audio_enable;\n\t\thdmi->disable_audio = dw_hdmi_ahb_audio_disable;\n\n\t\tpdevinfo.name = \"dw-hdmi-ahb-audio\";\n\t\tpdevinfo.data = &audio;\n\t\tpdevinfo.size_data = sizeof(audio);\n\t\tpdevinfo.dma_mask = DMA_BIT_MASK(32);\n\t\thdmi->audio = platform_device_register_full(&pdevinfo);\n\t} else if (config0 & HDMI_CONFIG0_I2S) {\n\t\tstruct dw_hdmi_i2s_audio_data audio;\n\n\t\taudio.hdmi\t= hdmi;\n\t\taudio.get_eld\t= hdmi_audio_get_eld;\n\t\taudio.write\t= hdmi_writeb;\n\t\taudio.read\t= hdmi_readb;\n\t\thdmi->enable_audio = dw_hdmi_i2s_audio_enable;\n\t\thdmi->disable_audio = dw_hdmi_i2s_audio_disable;\n\n\t\tpdevinfo.name = \"dw-hdmi-i2s-audio\";\n\t\tpdevinfo.data = &audio;\n\t\tpdevinfo.size_data = sizeof(audio);\n\t\tpdevinfo.dma_mask = DMA_BIT_MASK(32);\n\t\thdmi->audio = platform_device_register_full(&pdevinfo);\n\t} else if (iores && config3 & HDMI_CONFIG3_GPAUD) {\n\t\tstruct dw_hdmi_audio_data audio;\n\n\t\taudio.phys = iores->start;\n\t\taudio.base = hdmi->regs;\n\t\taudio.irq = irq;\n\t\taudio.hdmi = hdmi;\n\t\taudio.get_eld = hdmi_audio_get_eld;\n\n\t\thdmi->enable_audio = dw_hdmi_gp_audio_enable;\n\t\thdmi->disable_audio = dw_hdmi_gp_audio_disable;\n\n\t\tpdevinfo.name = \"dw-hdmi-gp-audio\";\n\t\tpdevinfo.id = PLATFORM_DEVID_NONE;\n\t\tpdevinfo.data = &audio;\n\t\tpdevinfo.size_data = sizeof(audio);\n\t\tpdevinfo.dma_mask = DMA_BIT_MASK(32);\n\t\thdmi->audio = platform_device_register_full(&pdevinfo);\n\t}\n\n\tif (!plat_data->disable_cec && (config0 & HDMI_CONFIG0_CEC)) {\n\t\tcec.hdmi = hdmi;\n\t\tcec.ops = &dw_hdmi_cec_ops;\n\t\tcec.irq = irq;\n\n\t\tpdevinfo.name = \"dw-hdmi-cec\";\n\t\tpdevinfo.data = &cec;\n\t\tpdevinfo.size_data = sizeof(cec);\n\t\tpdevinfo.dma_mask = 0;\n\n\t\thdmi->cec = platform_device_register_full(&pdevinfo);\n\t}\n\n\tdrm_bridge_add(&hdmi->bridge);\n\n\treturn hdmi;\n\nerr_iahb:\n\tclk_disable_unprepare(hdmi->iahb_clk);\n\tclk_disable_unprepare(hdmi->cec_clk);\nerr_isfr:\n\tclk_disable_unprepare(hdmi->isfr_clk);\nerr_res:\n\ti2c_put_adapter(hdmi->ddc);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_probe);\n\nvoid dw_hdmi_remove(struct dw_hdmi *hdmi)\n{\n\tdrm_bridge_remove(&hdmi->bridge);\n\n\tif (hdmi->audio && !IS_ERR(hdmi->audio))\n\t\tplatform_device_unregister(hdmi->audio);\n\tif (!IS_ERR(hdmi->cec))\n\t\tplatform_device_unregister(hdmi->cec);\n\n\t \n\thdmi_writeb(hdmi, ~0, HDMI_IH_MUTE_PHY_STAT0);\n\n\tclk_disable_unprepare(hdmi->iahb_clk);\n\tclk_disable_unprepare(hdmi->isfr_clk);\n\tclk_disable_unprepare(hdmi->cec_clk);\n\n\tif (hdmi->i2c)\n\t\ti2c_del_adapter(&hdmi->i2c->adap);\n\telse\n\t\ti2c_put_adapter(hdmi->ddc);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_remove);\n\n \nstruct dw_hdmi *dw_hdmi_bind(struct platform_device *pdev,\n\t\t\t     struct drm_encoder *encoder,\n\t\t\t     const struct dw_hdmi_plat_data *plat_data)\n{\n\tstruct dw_hdmi *hdmi;\n\tint ret;\n\n\thdmi = dw_hdmi_probe(pdev, plat_data);\n\tif (IS_ERR(hdmi))\n\t\treturn hdmi;\n\n\tret = drm_bridge_attach(encoder, &hdmi->bridge, NULL, 0);\n\tif (ret) {\n\t\tdw_hdmi_remove(hdmi);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hdmi;\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_bind);\n\nvoid dw_hdmi_unbind(struct dw_hdmi *hdmi)\n{\n\tdw_hdmi_remove(hdmi);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_unbind);\n\nvoid dw_hdmi_resume(struct dw_hdmi *hdmi)\n{\n\tdw_hdmi_init_hw(hdmi);\n}\nEXPORT_SYMBOL_GPL(dw_hdmi_resume);\n\nMODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\");\nMODULE_AUTHOR(\"Andy Yan <andy.yan@rock-chips.com>\");\nMODULE_AUTHOR(\"Yakir Yang <ykk@rock-chips.com>\");\nMODULE_AUTHOR(\"Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>\");\nMODULE_DESCRIPTION(\"DW HDMI transmitter driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:dw-hdmi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}