{
  "module_name": "dw-hdmi-ahb-audio.c",
  "hash_id": "591fdd0352172c3722adbc9f6c392b300cf9525f335712648c20d90f4d96fe0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <drm/bridge/dw_hdmi.h>\n#include <drm/drm_edid.h>\n\n#include <sound/asoundef.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_drm_eld.h>\n#include <sound/pcm_iec958.h>\n\n#include \"dw-hdmi-audio.h\"\n\n#define DRIVER_NAME \"dw-hdmi-ahb-audio\"\n\n \nenum {\n\tHDMI_AHB_DMA_CONF0_SW_FIFO_RST = BIT(7),\n\tHDMI_AHB_DMA_CONF0_EN_HLOCK = BIT(3),\n\tHDMI_AHB_DMA_START_START = BIT(0),\n\tHDMI_AHB_DMA_STOP_STOP = BIT(0),\n\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR = BIT(5),\n\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST = BIT(4),\n\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY = BIT(3),\n\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE = BIT(2),\n\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL = BIT(1),\n\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY = BIT(0),\n\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL =\n\t\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR |\n\t\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST |\n\t\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY |\n\t\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE |\n\t\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL |\n\t\tHDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY,\n\tHDMI_IH_AHBDMAAUD_STAT0_ERROR = BIT(5),\n\tHDMI_IH_AHBDMAAUD_STAT0_LOST = BIT(4),\n\tHDMI_IH_AHBDMAAUD_STAT0_RETRY = BIT(3),\n\tHDMI_IH_AHBDMAAUD_STAT0_DONE = BIT(2),\n\tHDMI_IH_AHBDMAAUD_STAT0_BUFFFULL = BIT(1),\n\tHDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY = BIT(0),\n\tHDMI_IH_AHBDMAAUD_STAT0_ALL =\n\t\tHDMI_IH_AHBDMAAUD_STAT0_ERROR |\n\t\tHDMI_IH_AHBDMAAUD_STAT0_LOST |\n\t\tHDMI_IH_AHBDMAAUD_STAT0_RETRY |\n\t\tHDMI_IH_AHBDMAAUD_STAT0_DONE |\n\t\tHDMI_IH_AHBDMAAUD_STAT0_BUFFFULL |\n\t\tHDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY,\n\tHDMI_AHB_DMA_CONF0_INCR16 = 2 << 1,\n\tHDMI_AHB_DMA_CONF0_INCR8 = 1 << 1,\n\tHDMI_AHB_DMA_CONF0_INCR4 = 0,\n\tHDMI_AHB_DMA_CONF0_BURST_MODE = BIT(0),\n\tHDMI_AHB_DMA_MASK_DONE = BIT(7),\n\n\tHDMI_REVISION_ID = 0x0001,\n\tHDMI_IH_AHBDMAAUD_STAT0 = 0x0109,\n\tHDMI_IH_MUTE_AHBDMAAUD_STAT0 = 0x0189,\n\tHDMI_AHB_DMA_CONF0 = 0x3600,\n\tHDMI_AHB_DMA_START = 0x3601,\n\tHDMI_AHB_DMA_STOP = 0x3602,\n\tHDMI_AHB_DMA_THRSLD = 0x3603,\n\tHDMI_AHB_DMA_STRADDR0 = 0x3604,\n\tHDMI_AHB_DMA_STPADDR0 = 0x3608,\n\tHDMI_AHB_DMA_MASK = 0x3614,\n\tHDMI_AHB_DMA_POL = 0x3615,\n\tHDMI_AHB_DMA_CONF1 = 0x3616,\n\tHDMI_AHB_DMA_BUFFPOL = 0x361a,\n};\n\nstruct dw_hdmi_channel_conf {\n\tu8 conf1;\n\tu8 ca;\n};\n\n \nstatic struct dw_hdmi_channel_conf default_hdmi_channel_config[7] = {\n\t{ 0x03, 0x00 },\t \n\t{ 0x0b, 0x02 },\t \n\t{ 0x33, 0x08 },\t \n\t{ 0x37, 0x09 },\t \n\t{ 0x3f, 0x0b },\t \n\t{ 0x7f, 0x0f },\t \n\t{ 0xff, 0x13 },\t \n};\n\nstruct snd_dw_hdmi {\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\tspinlock_t lock;\n\tstruct dw_hdmi_audio_data data;\n\tstruct snd_pcm_substream *substream;\n\tvoid (*reformat)(struct snd_dw_hdmi *, size_t, size_t);\n\tvoid *buf_src;\n\tvoid *buf_dst;\n\tdma_addr_t buf_addr;\n\tunsigned buf_offset;\n\tunsigned buf_period;\n\tunsigned buf_size;\n\tunsigned channels;\n\tu8 revision;\n\tu8 iec_offset;\n\tu8 cs[192][8];\n};\n\nstatic void dw_hdmi_writel(u32 val, void __iomem *ptr)\n{\n\twriteb_relaxed(val, ptr);\n\twriteb_relaxed(val >> 8, ptr + 1);\n\twriteb_relaxed(val >> 16, ptr + 2);\n\twriteb_relaxed(val >> 24, ptr + 3);\n}\n\n \nstatic void dw_hdmi_reformat_iec958(struct snd_dw_hdmi *dw,\n\tsize_t offset, size_t bytes)\n{\n\tu32 *src = dw->buf_src + offset;\n\tu32 *dst = dw->buf_dst + offset;\n\tu32 *end = dw->buf_src + offset + bytes;\n\n\tdo {\n\t\tu32 b, sample = *src++;\n\n\t\tb = (sample & 8) << (28 - 3);\n\n\t\tsample >>= 4;\n\n\t\t*dst++ = sample | b;\n\t} while (src < end);\n}\n\nstatic u32 parity(u32 sample)\n{\n\tsample ^= sample >> 16;\n\tsample ^= sample >> 8;\n\tsample ^= sample >> 4;\n\tsample ^= sample >> 2;\n\tsample ^= sample >> 1;\n\treturn (sample & 1) << 27;\n}\n\nstatic void dw_hdmi_reformat_s24(struct snd_dw_hdmi *dw,\n\tsize_t offset, size_t bytes)\n{\n\tu32 *src = dw->buf_src + offset;\n\tu32 *dst = dw->buf_dst + offset;\n\tu32 *end = dw->buf_src + offset + bytes;\n\n\tdo {\n\t\tunsigned i;\n\t\tu8 *cs;\n\n\t\tcs = dw->cs[dw->iec_offset++];\n\t\tif (dw->iec_offset >= 192)\n\t\t\tdw->iec_offset = 0;\n\n\t\ti = dw->channels;\n\t\tdo {\n\t\t\tu32 sample = *src++;\n\n\t\t\tsample &= ~0xff000000;\n\t\t\tsample |= *cs++ << 24;\n\t\t\tsample |= parity(sample & ~0xf8000000);\n\n\t\t\t*dst++ = sample;\n\t\t} while (--i);\n\t} while (src < end);\n}\n\nstatic void dw_hdmi_create_cs(struct snd_dw_hdmi *dw,\n\tstruct snd_pcm_runtime *runtime)\n{\n\tu8 cs[4];\n\tunsigned ch, i, j;\n\n\tsnd_pcm_create_iec958_consumer(runtime, cs, sizeof(cs));\n\n\tmemset(dw->cs, 0, sizeof(dw->cs));\n\n\tfor (ch = 0; ch < 8; ch++) {\n\t\tcs[2] &= ~IEC958_AES2_CON_CHANNEL;\n\t\tcs[2] |= (ch + 1) << 4;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cs); i++) {\n\t\t\tunsigned c = cs[i];\n\n\t\t\tfor (j = 0; j < 8; j++, c >>= 1)\n\t\t\t\tdw->cs[i * 8 + j][ch] = (c & 1) << 2;\n\t\t}\n\t}\n\tdw->cs[0][0] |= BIT(4);\n}\n\nstatic void dw_hdmi_start_dma(struct snd_dw_hdmi *dw)\n{\n\tvoid __iomem *base = dw->data.base;\n\tunsigned offset = dw->buf_offset;\n\tunsigned period = dw->buf_period;\n\tu32 start, stop;\n\n\tdw->reformat(dw, offset, period);\n\n\t \n\twriteb_relaxed(HDMI_IH_AHBDMAAUD_STAT0_ALL,\n\t\t       base + HDMI_IH_AHBDMAAUD_STAT0);\n\n\tstart = dw->buf_addr + offset;\n\tstop = start + period - 1;\n\n\t \n\tdw_hdmi_writel(start, base + HDMI_AHB_DMA_STRADDR0);\n\tdw_hdmi_writel(stop, base + HDMI_AHB_DMA_STPADDR0);\n\n\twriteb_relaxed((u8)~HDMI_AHB_DMA_MASK_DONE, base + HDMI_AHB_DMA_MASK);\n\twriteb(HDMI_AHB_DMA_START_START, base + HDMI_AHB_DMA_START);\n\n\toffset += period;\n\tif (offset >= dw->buf_size)\n\t\toffset = 0;\n\tdw->buf_offset = offset;\n}\n\nstatic void dw_hdmi_stop_dma(struct snd_dw_hdmi *dw)\n{\n\t \n\twriteb_relaxed(~0, dw->data.base + HDMI_AHB_DMA_MASK);\n\twriteb_relaxed(HDMI_AHB_DMA_STOP_STOP, dw->data.base + HDMI_AHB_DMA_STOP);\n}\n\nstatic irqreturn_t snd_dw_hdmi_irq(int irq, void *data)\n{\n\tstruct snd_dw_hdmi *dw = data;\n\tstruct snd_pcm_substream *substream;\n\tunsigned stat;\n\n\tstat = readb_relaxed(dw->data.base + HDMI_IH_AHBDMAAUD_STAT0);\n\tif (!stat)\n\t\treturn IRQ_NONE;\n\n\twriteb_relaxed(stat, dw->data.base + HDMI_IH_AHBDMAAUD_STAT0);\n\n\tsubstream = dw->substream;\n\tif (stat & HDMI_IH_AHBDMAAUD_STAT0_DONE && substream) {\n\t\tsnd_pcm_period_elapsed(substream);\n\n\t\tspin_lock(&dw->lock);\n\t\tif (dw->substream)\n\t\t\tdw_hdmi_start_dma(dw);\n\t\tspin_unlock(&dw->lock);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct snd_pcm_hardware dw_hdmi_hw = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\t.formats = SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE |\n\t\t   SNDRV_PCM_FMTBIT_S24_LE,\n\t.rates = SNDRV_PCM_RATE_32000 |\n\t\t SNDRV_PCM_RATE_44100 |\n\t\t SNDRV_PCM_RATE_48000 |\n\t\t SNDRV_PCM_RATE_88200 |\n\t\t SNDRV_PCM_RATE_96000 |\n\t\t SNDRV_PCM_RATE_176400 |\n\t\t SNDRV_PCM_RATE_192000,\n\t.channels_min = 2,\n\t.channels_max = 8,\n\t.buffer_bytes_max = 1024 * 1024,\n\t.period_bytes_min = 256,\n\t.period_bytes_max = 8192,\t \n\t.periods_min = 2,\n\t.periods_max = 16,\n\t.fifo_size = 0,\n};\n\nstatic int dw_hdmi_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_dw_hdmi *dw = substream->private_data;\n\tvoid __iomem *base = dw->data.base;\n\tu8 *eld;\n\tint ret;\n\n\truntime->hw = dw_hdmi_hw;\n\n\teld = dw->data.get_eld(dw->data.hdmi);\n\tif (eld) {\n\t\tret = snd_pcm_hw_constraint_eld(runtime, eld);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = snd_pcm_limit_hw_rates(runtime);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t\t   0, substream->dma_buffer.bytes);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\twriteb_relaxed(HDMI_AHB_DMA_CONF0_SW_FIFO_RST,\n\t\t       base + HDMI_AHB_DMA_CONF0);\n\n\t \n\twriteb_relaxed(~0, base + HDMI_AHB_DMA_POL);\n\twriteb_relaxed(~0, base + HDMI_AHB_DMA_BUFFPOL);\n\n\t \n\twriteb_relaxed(~0, base + HDMI_AHB_DMA_MASK);\n\twriteb_relaxed(~0, base + HDMI_IH_AHBDMAAUD_STAT0);\n\n\tret = request_irq(dw->data.irq, snd_dw_hdmi_irq, IRQF_SHARED,\n\t\t\t  \"dw-hdmi-audio\", dw);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twriteb_relaxed(HDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL &\n\t\t       ~HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE,\n\t\t       base + HDMI_IH_MUTE_AHBDMAAUD_STAT0);\n\n\treturn 0;\n}\n\nstatic int dw_hdmi_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dw_hdmi *dw = substream->private_data;\n\n\t \n\twriteb_relaxed(HDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL,\n\t\t       dw->data.base + HDMI_IH_MUTE_AHBDMAAUD_STAT0);\n\n\tfree_irq(dw->data.irq, dw);\n\n\treturn 0;\n}\n\nstatic int dw_hdmi_hw_free(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_lib_free_vmalloc_buffer(substream);\n}\n\nstatic int dw_hdmi_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params)\n{\n\t \n\treturn snd_pcm_lib_alloc_vmalloc_buffer(substream,\n\t\t\t\t\t\tparams_buffer_bytes(params));\n}\n\nstatic int dw_hdmi_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_dw_hdmi *dw = substream->private_data;\n\tu8 threshold, conf0, conf1, ca;\n\n\t \n\tswitch (dw->revision) {\n\tcase 0x0a:\n\t\tconf0 = HDMI_AHB_DMA_CONF0_BURST_MODE |\n\t\t\tHDMI_AHB_DMA_CONF0_INCR4;\n\t\tif (runtime->channels == 2)\n\t\t\tthreshold = 126;\n\t\telse\n\t\t\tthreshold = 124;\n\t\tbreak;\n\tcase 0x1a:\n\t\tconf0 = HDMI_AHB_DMA_CONF0_BURST_MODE |\n\t\t\tHDMI_AHB_DMA_CONF0_INCR8;\n\t\tthreshold = 128;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tdw_hdmi_set_sample_rate(dw->data.hdmi, runtime->rate);\n\n\t \n\truntime->hw.fifo_size = threshold * 32;\n\n\tconf0 |= HDMI_AHB_DMA_CONF0_EN_HLOCK;\n\tconf1 = default_hdmi_channel_config[runtime->channels - 2].conf1;\n\tca = default_hdmi_channel_config[runtime->channels - 2].ca;\n\n\twriteb_relaxed(threshold, dw->data.base + HDMI_AHB_DMA_THRSLD);\n\twriteb_relaxed(conf0, dw->data.base + HDMI_AHB_DMA_CONF0);\n\twriteb_relaxed(conf1, dw->data.base + HDMI_AHB_DMA_CONF1);\n\n\tdw_hdmi_set_channel_count(dw->data.hdmi, runtime->channels);\n\tdw_hdmi_set_channel_allocation(dw->data.hdmi, ca);\n\n\tswitch (runtime->format) {\n\tcase SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:\n\t\tdw->reformat = dw_hdmi_reformat_iec958;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tdw_hdmi_create_cs(dw, runtime);\n\t\tdw->reformat = dw_hdmi_reformat_s24;\n\t\tbreak;\n\t}\n\tdw->iec_offset = 0;\n\tdw->channels = runtime->channels;\n\tdw->buf_src  = runtime->dma_area;\n\tdw->buf_dst  = substream->dma_buffer.area;\n\tdw->buf_addr = substream->dma_buffer.addr;\n\tdw->buf_period = snd_pcm_lib_period_bytes(substream);\n\tdw->buf_size = snd_pcm_lib_buffer_bytes(substream);\n\n\treturn 0;\n}\n\nstatic int dw_hdmi_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_dw_hdmi *dw = substream->private_data;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tspin_lock_irqsave(&dw->lock, flags);\n\t\tdw->buf_offset = 0;\n\t\tdw->substream = substream;\n\t\tdw_hdmi_start_dma(dw);\n\t\tdw_hdmi_audio_enable(dw->data.hdmi);\n\t\tspin_unlock_irqrestore(&dw->lock, flags);\n\t\tsubstream->runtime->delay = substream->runtime->period_size;\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tspin_lock_irqsave(&dw->lock, flags);\n\t\tdw->substream = NULL;\n\t\tdw_hdmi_stop_dma(dw);\n\t\tdw_hdmi_audio_disable(dw->data.hdmi);\n\t\tspin_unlock_irqrestore(&dw->lock, flags);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic snd_pcm_uframes_t dw_hdmi_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_dw_hdmi *dw = substream->private_data;\n\n\t \n\treturn bytes_to_frames(runtime, dw->buf_offset);\n}\n\nstatic const struct snd_pcm_ops snd_dw_hdmi_ops = {\n\t.open = dw_hdmi_open,\n\t.close = dw_hdmi_close,\n\t.ioctl = snd_pcm_lib_ioctl,\n\t.hw_params = dw_hdmi_hw_params,\n\t.hw_free = dw_hdmi_hw_free,\n\t.prepare = dw_hdmi_prepare,\n\t.trigger = dw_hdmi_trigger,\n\t.pointer = dw_hdmi_pointer,\n\t.page = snd_pcm_lib_get_vmalloc_page,\n};\n\nstatic int snd_dw_hdmi_probe(struct platform_device *pdev)\n{\n\tconst struct dw_hdmi_audio_data *data = pdev->dev.platform_data;\n\tstruct device *dev = pdev->dev.parent;\n\tstruct snd_dw_hdmi *dw;\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\tunsigned revision;\n\tint ret;\n\n\twriteb_relaxed(HDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL,\n\t\t       data->base + HDMI_IH_MUTE_AHBDMAAUD_STAT0);\n\trevision = readb_relaxed(data->base + HDMI_REVISION_ID);\n\tif (revision != 0x0a && revision != 0x1a) {\n\t\tdev_err(dev, \"dw-hdmi-audio: unknown revision 0x%02x\\n\",\n\t\t\trevision);\n\t\treturn -ENXIO;\n\t}\n\n\tret = snd_card_new(dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\n\t\t\t      THIS_MODULE, sizeof(struct snd_dw_hdmi), &card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstrscpy(card->driver, DRIVER_NAME, sizeof(card->driver));\n\tstrscpy(card->shortname, \"DW-HDMI\", sizeof(card->shortname));\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s rev 0x%02x, irq %d\", card->shortname, revision,\n\t\t data->irq);\n\n\tdw = card->private_data;\n\tdw->card = card;\n\tdw->data = *data;\n\tdw->revision = revision;\n\n\tspin_lock_init(&dw->lock);\n\n\tret = snd_pcm_new(card, \"DW HDMI\", 0, 1, 0, &pcm);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdw->pcm = pcm;\n\tpcm->private_data = dw;\n\tstrscpy(pcm->name, DRIVER_NAME, sizeof(pcm->name));\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_dw_hdmi_ops);\n\n\t \n\tsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\tdev, 128 * 1024, 1024 * 1024);\n\n\tret = snd_card_register(card);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tplatform_set_drvdata(pdev, dw);\n\n\treturn 0;\n\nerr:\n\tsnd_card_free(card);\n\treturn ret;\n}\n\nstatic void snd_dw_hdmi_remove(struct platform_device *pdev)\n{\n\tstruct snd_dw_hdmi *dw = platform_get_drvdata(pdev);\n\n\tsnd_card_free(dw->card);\n}\n\n#if defined(CONFIG_PM_SLEEP) && defined(IS_NOT_BROKEN)\n \nstatic int snd_dw_hdmi_suspend(struct device *dev)\n{\n\tstruct snd_dw_hdmi *dw = dev_get_drvdata(dev);\n\n\tsnd_power_change_state(dw->card, SNDRV_CTL_POWER_D3cold);\n\n\treturn 0;\n}\n\nstatic int snd_dw_hdmi_resume(struct device *dev)\n{\n\tstruct snd_dw_hdmi *dw = dev_get_drvdata(dev);\n\n\tsnd_power_change_state(dw->card, SNDRV_CTL_POWER_D0);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_dw_hdmi_pm, snd_dw_hdmi_suspend,\n\t\t\t snd_dw_hdmi_resume);\n#define PM_OPS &snd_dw_hdmi_pm\n#else\n#define PM_OPS NULL\n#endif\n\nstatic struct platform_driver snd_dw_hdmi_driver = {\n\t.probe\t= snd_dw_hdmi_probe,\n\t.remove_new = snd_dw_hdmi_remove,\n\t.driver\t= {\n\t\t.name = DRIVER_NAME,\n\t\t.pm = PM_OPS,\n\t},\n};\n\nmodule_platform_driver(snd_dw_hdmi_driver);\n\nMODULE_AUTHOR(\"Russell King <rmk+kernel@armlinux.org.uk>\");\nMODULE_DESCRIPTION(\"Synopsis Designware HDMI AHB ALSA interface\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}