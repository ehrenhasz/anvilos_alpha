{
  "module_name": "dw-hdmi-cec.c",
  "hash_id": "605659f7f9b8e4b22c3c077c9207aa2838f4d48edd7a81a9f2ee88969290811e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/synopsys/dw-hdmi-cec.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <drm/drm_edid.h>\n\n#include <media/cec.h>\n#include <media/cec-notifier.h>\n\n#include \"dw-hdmi-cec.h\"\n\nenum {\n\tHDMI_IH_CEC_STAT0\t= 0x0106,\n\tHDMI_IH_MUTE_CEC_STAT0\t= 0x0186,\n\n\tHDMI_CEC_CTRL\t\t= 0x7d00,\n\tCEC_CTRL_START\t\t= BIT(0),\n\tCEC_CTRL_FRAME_TYP\t= 3 << 1,\n\tCEC_CTRL_RETRY\t\t= 0 << 1,\n\tCEC_CTRL_NORMAL\t\t= 1 << 1,\n\tCEC_CTRL_IMMED\t\t= 2 << 1,\n\n\tHDMI_CEC_STAT\t\t= 0x7d01,\n\tCEC_STAT_DONE\t\t= BIT(0),\n\tCEC_STAT_EOM\t\t= BIT(1),\n\tCEC_STAT_NACK\t\t= BIT(2),\n\tCEC_STAT_ARBLOST\t= BIT(3),\n\tCEC_STAT_ERROR_INIT\t= BIT(4),\n\tCEC_STAT_ERROR_FOLL\t= BIT(5),\n\tCEC_STAT_WAKEUP\t\t= BIT(6),\n\n\tHDMI_CEC_MASK\t\t= 0x7d02,\n\tHDMI_CEC_POLARITY\t= 0x7d03,\n\tHDMI_CEC_INT\t\t= 0x7d04,\n\tHDMI_CEC_ADDR_L\t\t= 0x7d05,\n\tHDMI_CEC_ADDR_H\t\t= 0x7d06,\n\tHDMI_CEC_TX_CNT\t\t= 0x7d07,\n\tHDMI_CEC_RX_CNT\t\t= 0x7d08,\n\tHDMI_CEC_TX_DATA0\t= 0x7d10,\n\tHDMI_CEC_RX_DATA0\t= 0x7d20,\n\tHDMI_CEC_LOCK\t\t= 0x7d30,\n\tHDMI_CEC_WKUPCTRL\t= 0x7d31,\n};\n\nstruct dw_hdmi_cec {\n\tstruct dw_hdmi *hdmi;\n\tconst struct dw_hdmi_cec_ops *ops;\n\tu32 addresses;\n\tstruct cec_adapter *adap;\n\tstruct cec_msg rx_msg;\n\tunsigned int tx_status;\n\tbool tx_done;\n\tbool rx_done;\n\tstruct cec_notifier *notify;\n\tint irq;\n\n\tu8 regs_polarity;\n\tu8 regs_mask;\n\tu8 regs_mute_stat0;\n};\n\nstatic void dw_hdmi_write(struct dw_hdmi_cec *cec, u8 val, int offset)\n{\n\tcec->ops->write(cec->hdmi, val, offset);\n}\n\nstatic u8 dw_hdmi_read(struct dw_hdmi_cec *cec, int offset)\n{\n\treturn cec->ops->read(cec->hdmi, offset);\n}\n\nstatic int dw_hdmi_cec_log_addr(struct cec_adapter *adap, u8 logical_addr)\n{\n\tstruct dw_hdmi_cec *cec = cec_get_drvdata(adap);\n\n\tif (logical_addr == CEC_LOG_ADDR_INVALID)\n\t\tcec->addresses = 0;\n\telse\n\t\tcec->addresses |= BIT(logical_addr) | BIT(15);\n\n\tdw_hdmi_write(cec, cec->addresses & 255, HDMI_CEC_ADDR_L);\n\tdw_hdmi_write(cec, cec->addresses >> 8, HDMI_CEC_ADDR_H);\n\n\treturn 0;\n}\n\nstatic int dw_hdmi_cec_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\tu32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct dw_hdmi_cec *cec = cec_get_drvdata(adap);\n\tunsigned int i, ctrl;\n\n\tswitch (signal_free_time) {\n\tcase CEC_SIGNAL_FREE_TIME_RETRY:\n\t\tctrl = CEC_CTRL_RETRY;\n\t\tbreak;\n\tcase CEC_SIGNAL_FREE_TIME_NEW_INITIATOR:\n\tdefault:\n\t\tctrl = CEC_CTRL_NORMAL;\n\t\tbreak;\n\tcase CEC_SIGNAL_FREE_TIME_NEXT_XFER:\n\t\tctrl = CEC_CTRL_IMMED;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < msg->len; i++)\n\t\tdw_hdmi_write(cec, msg->msg[i], HDMI_CEC_TX_DATA0 + i);\n\n\tdw_hdmi_write(cec, msg->len, HDMI_CEC_TX_CNT);\n\tdw_hdmi_write(cec, ctrl | CEC_CTRL_START, HDMI_CEC_CTRL);\n\n\treturn 0;\n}\n\nstatic irqreturn_t dw_hdmi_cec_hardirq(int irq, void *data)\n{\n\tstruct cec_adapter *adap = data;\n\tstruct dw_hdmi_cec *cec = cec_get_drvdata(adap);\n\tunsigned int stat = dw_hdmi_read(cec, HDMI_IH_CEC_STAT0);\n\tirqreturn_t ret = IRQ_HANDLED;\n\n\tif (stat == 0)\n\t\treturn IRQ_NONE;\n\n\tdw_hdmi_write(cec, stat, HDMI_IH_CEC_STAT0);\n\n\tif (stat & CEC_STAT_ERROR_INIT) {\n\t\tcec->tx_status = CEC_TX_STATUS_ERROR;\n\t\tcec->tx_done = true;\n\t\tret = IRQ_WAKE_THREAD;\n\t} else if (stat & CEC_STAT_DONE) {\n\t\tcec->tx_status = CEC_TX_STATUS_OK;\n\t\tcec->tx_done = true;\n\t\tret = IRQ_WAKE_THREAD;\n\t} else if (stat & CEC_STAT_NACK) {\n\t\tcec->tx_status = CEC_TX_STATUS_NACK;\n\t\tcec->tx_done = true;\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\tif (stat & CEC_STAT_EOM) {\n\t\tunsigned int len, i;\n\n\t\tlen = dw_hdmi_read(cec, HDMI_CEC_RX_CNT);\n\t\tif (len > sizeof(cec->rx_msg.msg))\n\t\t\tlen = sizeof(cec->rx_msg.msg);\n\n\t\tfor (i = 0; i < len; i++)\n\t\t\tcec->rx_msg.msg[i] =\n\t\t\t\tdw_hdmi_read(cec, HDMI_CEC_RX_DATA0 + i);\n\n\t\tdw_hdmi_write(cec, 0, HDMI_CEC_LOCK);\n\n\t\tcec->rx_msg.len = len;\n\t\tsmp_wmb();\n\t\tcec->rx_done = true;\n\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t dw_hdmi_cec_thread(int irq, void *data)\n{\n\tstruct cec_adapter *adap = data;\n\tstruct dw_hdmi_cec *cec = cec_get_drvdata(adap);\n\n\tif (cec->tx_done) {\n\t\tcec->tx_done = false;\n\t\tcec_transmit_attempt_done(adap, cec->tx_status);\n\t}\n\tif (cec->rx_done) {\n\t\tcec->rx_done = false;\n\t\tsmp_rmb();\n\t\tcec_received_msg(adap, &cec->rx_msg);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int dw_hdmi_cec_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct dw_hdmi_cec *cec = cec_get_drvdata(adap);\n\n\tif (!enable) {\n\t\tdw_hdmi_write(cec, ~0, HDMI_CEC_MASK);\n\t\tdw_hdmi_write(cec, ~0, HDMI_IH_MUTE_CEC_STAT0);\n\t\tdw_hdmi_write(cec, 0, HDMI_CEC_POLARITY);\n\n\t\tcec->ops->disable(cec->hdmi);\n\t} else {\n\t\tunsigned int irqs;\n\n\t\tdw_hdmi_write(cec, 0, HDMI_CEC_CTRL);\n\t\tdw_hdmi_write(cec, ~0, HDMI_IH_CEC_STAT0);\n\t\tdw_hdmi_write(cec, 0, HDMI_CEC_LOCK);\n\n\t\tdw_hdmi_cec_log_addr(cec->adap, CEC_LOG_ADDR_INVALID);\n\n\t\tcec->ops->enable(cec->hdmi);\n\n\t\tirqs = CEC_STAT_ERROR_INIT | CEC_STAT_NACK | CEC_STAT_EOM |\n\t\t       CEC_STAT_DONE;\n\t\tdw_hdmi_write(cec, irqs, HDMI_CEC_POLARITY);\n\t\tdw_hdmi_write(cec, ~irqs, HDMI_CEC_MASK);\n\t\tdw_hdmi_write(cec, ~irqs, HDMI_IH_MUTE_CEC_STAT0);\n\t}\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops dw_hdmi_cec_ops = {\n\t.adap_enable = dw_hdmi_cec_enable,\n\t.adap_log_addr = dw_hdmi_cec_log_addr,\n\t.adap_transmit = dw_hdmi_cec_transmit,\n};\n\nstatic void dw_hdmi_cec_del(void *data)\n{\n\tstruct dw_hdmi_cec *cec = data;\n\n\tcec_delete_adapter(cec->adap);\n}\n\nstatic int dw_hdmi_cec_probe(struct platform_device *pdev)\n{\n\tstruct dw_hdmi_cec_data *data = dev_get_platdata(&pdev->dev);\n\tstruct dw_hdmi_cec *cec;\n\tint ret;\n\n\tif (!data)\n\t\treturn -ENXIO;\n\n\t \n\tcec = devm_kzalloc(&pdev->dev, sizeof(*cec), GFP_KERNEL);\n\tif (!cec)\n\t\treturn -ENOMEM;\n\n\tcec->irq = data->irq;\n\tcec->ops = data->ops;\n\tcec->hdmi = data->hdmi;\n\n\tplatform_set_drvdata(pdev, cec);\n\n\tdw_hdmi_write(cec, 0, HDMI_CEC_TX_CNT);\n\tdw_hdmi_write(cec, ~0, HDMI_CEC_MASK);\n\tdw_hdmi_write(cec, ~0, HDMI_IH_MUTE_CEC_STAT0);\n\tdw_hdmi_write(cec, 0, HDMI_CEC_POLARITY);\n\n\tcec->adap = cec_allocate_adapter(&dw_hdmi_cec_ops, cec, \"dw_hdmi\",\n\t\t\t\t\t CEC_CAP_DEFAULTS |\n\t\t\t\t\t CEC_CAP_CONNECTOR_INFO,\n\t\t\t\t\t CEC_MAX_LOG_ADDRS);\n\tif (IS_ERR(cec->adap))\n\t\treturn PTR_ERR(cec->adap);\n\n\t \n\tcec->adap->owner = THIS_MODULE;\n\n\tret = devm_add_action_or_reset(&pdev->dev, dw_hdmi_cec_del, cec);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_threaded_irq(&pdev->dev, cec->irq,\n\t\t\t\t\tdw_hdmi_cec_hardirq,\n\t\t\t\t\tdw_hdmi_cec_thread, IRQF_SHARED,\n\t\t\t\t\t\"dw-hdmi-cec\", cec->adap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcec->notify = cec_notifier_cec_adap_register(pdev->dev.parent,\n\t\t\t\t\t\t     NULL, cec->adap);\n\tif (!cec->notify)\n\t\treturn -ENOMEM;\n\n\tret = cec_register_adapter(cec->adap, pdev->dev.parent);\n\tif (ret < 0) {\n\t\tcec_notifier_cec_adap_unregister(cec->notify, cec->adap);\n\t\treturn ret;\n\t}\n\n\t \n\tdevm_remove_action(&pdev->dev, dw_hdmi_cec_del, cec);\n\n\treturn 0;\n}\n\nstatic void dw_hdmi_cec_remove(struct platform_device *pdev)\n{\n\tstruct dw_hdmi_cec *cec = platform_get_drvdata(pdev);\n\n\tcec_notifier_cec_adap_unregister(cec->notify, cec->adap);\n\tcec_unregister_adapter(cec->adap);\n}\n\nstatic int __maybe_unused dw_hdmi_cec_resume(struct device *dev)\n{\n\tstruct dw_hdmi_cec *cec = dev_get_drvdata(dev);\n\n\t \n\tdw_hdmi_write(cec, cec->addresses & 255, HDMI_CEC_ADDR_L);\n\tdw_hdmi_write(cec, cec->addresses >> 8, HDMI_CEC_ADDR_H);\n\n\t \n\tdw_hdmi_write(cec, cec->regs_polarity, HDMI_CEC_POLARITY);\n\tdw_hdmi_write(cec, cec->regs_mask, HDMI_CEC_MASK);\n\tdw_hdmi_write(cec, cec->regs_mute_stat0, HDMI_IH_MUTE_CEC_STAT0);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dw_hdmi_cec_suspend(struct device *dev)\n{\n\tstruct dw_hdmi_cec *cec = dev_get_drvdata(dev);\n\n\t \n\t cec->regs_polarity = dw_hdmi_read(cec, HDMI_CEC_POLARITY);\n\t cec->regs_mask = dw_hdmi_read(cec, HDMI_CEC_MASK);\n\t cec->regs_mute_stat0 = dw_hdmi_read(cec, HDMI_IH_MUTE_CEC_STAT0);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dw_hdmi_cec_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dw_hdmi_cec_suspend, dw_hdmi_cec_resume)\n};\n\nstatic struct platform_driver dw_hdmi_cec_driver = {\n\t.probe\t= dw_hdmi_cec_probe,\n\t.remove_new = dw_hdmi_cec_remove,\n\t.driver = {\n\t\t.name = \"dw-hdmi-cec\",\n\t\t.pm = &dw_hdmi_cec_pm,\n\t},\n};\nmodule_platform_driver(dw_hdmi_cec_driver);\n\nMODULE_AUTHOR(\"Russell King <rmk+kernel@armlinux.org.uk>\");\nMODULE_DESCRIPTION(\"Synopsys Designware HDMI CEC driver for i.MX\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(PLATFORM_MODULE_PREFIX \"dw-hdmi-cec\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}