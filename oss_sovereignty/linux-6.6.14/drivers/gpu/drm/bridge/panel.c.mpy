{
  "module_name": "panel.c",
  "hash_id": "6ee0658edb227f9b6eaa314b1fcf811e27ff44f4922eec35b313cdda341f5ca9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/panel.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\nstruct panel_bridge {\n\tstruct drm_bridge bridge;\n\tstruct drm_connector connector;\n\tstruct drm_panel *panel;\n\tu32 connector_type;\n};\n\nstatic inline struct panel_bridge *\ndrm_bridge_to_panel_bridge(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct panel_bridge, bridge);\n}\n\nstatic inline struct panel_bridge *\ndrm_connector_to_panel_bridge(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct panel_bridge, connector);\n}\n\nstatic int panel_bridge_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct panel_bridge *panel_bridge =\n\t\tdrm_connector_to_panel_bridge(connector);\n\n\treturn drm_panel_get_modes(panel_bridge->panel, connector);\n}\n\nstatic const struct drm_connector_helper_funcs\npanel_bridge_connector_helper_funcs = {\n\t.get_modes = panel_bridge_connector_get_modes,\n};\n\nstatic const struct drm_connector_funcs panel_bridge_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int panel_bridge_attach(struct drm_bridge *bridge,\n\t\t\t       enum drm_bridge_attach_flags flags)\n{\n\tstruct panel_bridge *panel_bridge = drm_bridge_to_panel_bridge(bridge);\n\tstruct drm_connector *connector = &panel_bridge->connector;\n\tint ret;\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)\n\t\treturn 0;\n\n\tif (!bridge->encoder) {\n\t\tDRM_ERROR(\"Missing encoder\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrm_connector_helper_add(connector,\n\t\t\t\t &panel_bridge_connector_helper_funcs);\n\n\tret = drm_connector_init(bridge->dev, connector,\n\t\t\t\t &panel_bridge_connector_funcs,\n\t\t\t\t panel_bridge->connector_type);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize connector\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_panel_bridge_set_orientation(connector, bridge);\n\n\tdrm_connector_attach_encoder(&panel_bridge->connector,\n\t\t\t\t\t  bridge->encoder);\n\n\tif (bridge->dev->registered) {\n\t\tif (connector->funcs->reset)\n\t\t\tconnector->funcs->reset(connector);\n\t\tdrm_connector_register(connector);\n\t}\n\n\treturn 0;\n}\n\nstatic void panel_bridge_detach(struct drm_bridge *bridge)\n{\n\tstruct panel_bridge *panel_bridge = drm_bridge_to_panel_bridge(bridge);\n\tstruct drm_connector *connector = &panel_bridge->connector;\n\n\t \n\tif (connector->dev)\n\t\tdrm_connector_cleanup(connector);\n}\n\nstatic void panel_bridge_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct panel_bridge *panel_bridge = drm_bridge_to_panel_bridge(bridge);\n\tstruct drm_atomic_state *atomic_state = old_bridge_state->base.state;\n\tstruct drm_encoder *encoder = bridge->encoder;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\n\tcrtc = drm_atomic_get_new_crtc_for_encoder(atomic_state, encoder);\n\tif (!crtc)\n\t\treturn;\n\n\told_crtc_state = drm_atomic_get_old_crtc_state(atomic_state, crtc);\n\tif (old_crtc_state && old_crtc_state->self_refresh_active)\n\t\treturn;\n\n\tdrm_panel_prepare(panel_bridge->panel);\n}\n\nstatic void panel_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct panel_bridge *panel_bridge = drm_bridge_to_panel_bridge(bridge);\n\tstruct drm_atomic_state *atomic_state = old_bridge_state->base.state;\n\tstruct drm_encoder *encoder = bridge->encoder;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\n\tcrtc = drm_atomic_get_new_crtc_for_encoder(atomic_state, encoder);\n\tif (!crtc)\n\t\treturn;\n\n\told_crtc_state = drm_atomic_get_old_crtc_state(atomic_state, crtc);\n\tif (old_crtc_state && old_crtc_state->self_refresh_active)\n\t\treturn;\n\n\tdrm_panel_enable(panel_bridge->panel);\n}\n\nstatic void panel_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct panel_bridge *panel_bridge = drm_bridge_to_panel_bridge(bridge);\n\tstruct drm_atomic_state *atomic_state = old_bridge_state->base.state;\n\tstruct drm_encoder *encoder = bridge->encoder;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\n\tcrtc = drm_atomic_get_old_crtc_for_encoder(atomic_state, encoder);\n\tif (!crtc)\n\t\treturn;\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(atomic_state, crtc);\n\tif (new_crtc_state && new_crtc_state->self_refresh_active)\n\t\treturn;\n\n\tdrm_panel_disable(panel_bridge->panel);\n}\n\nstatic void panel_bridge_atomic_post_disable(struct drm_bridge *bridge,\n\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct panel_bridge *panel_bridge = drm_bridge_to_panel_bridge(bridge);\n\tstruct drm_atomic_state *atomic_state = old_bridge_state->base.state;\n\tstruct drm_encoder *encoder = bridge->encoder;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\n\tcrtc = drm_atomic_get_old_crtc_for_encoder(atomic_state, encoder);\n\tif (!crtc)\n\t\treturn;\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(atomic_state, crtc);\n\tif (new_crtc_state && new_crtc_state->self_refresh_active)\n\t\treturn;\n\n\tdrm_panel_unprepare(panel_bridge->panel);\n}\n\nstatic int panel_bridge_get_modes(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_connector *connector)\n{\n\tstruct panel_bridge *panel_bridge = drm_bridge_to_panel_bridge(bridge);\n\n\treturn drm_panel_get_modes(panel_bridge->panel, connector);\n}\n\nstatic void panel_bridge_debugfs_init(struct drm_bridge *bridge,\n\t\t\t\t      struct dentry *root)\n{\n\tstruct panel_bridge *panel_bridge = drm_bridge_to_panel_bridge(bridge);\n\tstruct drm_panel *panel = panel_bridge->panel;\n\n\troot = debugfs_create_dir(\"panel\", root);\n\tif (panel->funcs->debugfs_init)\n\t\tpanel->funcs->debugfs_init(panel, root);\n}\n\nstatic const struct drm_bridge_funcs panel_bridge_bridge_funcs = {\n\t.attach = panel_bridge_attach,\n\t.detach = panel_bridge_detach,\n\t.atomic_pre_enable = panel_bridge_atomic_pre_enable,\n\t.atomic_enable = panel_bridge_atomic_enable,\n\t.atomic_disable = panel_bridge_atomic_disable,\n\t.atomic_post_disable = panel_bridge_atomic_post_disable,\n\t.get_modes = panel_bridge_get_modes,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_get_input_bus_fmts = drm_atomic_helper_bridge_propagate_bus_fmt,\n\t.debugfs_init = panel_bridge_debugfs_init,\n};\n\n \nbool drm_bridge_is_panel(const struct drm_bridge *bridge)\n{\n\treturn bridge->funcs == &panel_bridge_bridge_funcs;\n}\nEXPORT_SYMBOL(drm_bridge_is_panel);\n\n \nstruct drm_bridge *drm_panel_bridge_add(struct drm_panel *panel)\n{\n\tif (WARN_ON(panel->connector_type == DRM_MODE_CONNECTOR_Unknown))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn drm_panel_bridge_add_typed(panel, panel->connector_type);\n}\nEXPORT_SYMBOL(drm_panel_bridge_add);\n\n \nstruct drm_bridge *drm_panel_bridge_add_typed(struct drm_panel *panel,\n\t\t\t\t\t      u32 connector_type)\n{\n\tstruct panel_bridge *panel_bridge;\n\n\tif (!panel)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpanel_bridge = devm_kzalloc(panel->dev, sizeof(*panel_bridge),\n\t\t\t\t    GFP_KERNEL);\n\tif (!panel_bridge)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpanel_bridge->connector_type = connector_type;\n\tpanel_bridge->panel = panel;\n\n\tpanel_bridge->bridge.funcs = &panel_bridge_bridge_funcs;\n#ifdef CONFIG_OF\n\tpanel_bridge->bridge.of_node = panel->dev->of_node;\n#endif\n\tpanel_bridge->bridge.ops = DRM_BRIDGE_OP_MODES;\n\tpanel_bridge->bridge.type = connector_type;\n\n\tdrm_bridge_add(&panel_bridge->bridge);\n\n\treturn &panel_bridge->bridge;\n}\nEXPORT_SYMBOL(drm_panel_bridge_add_typed);\n\n \nvoid drm_panel_bridge_remove(struct drm_bridge *bridge)\n{\n\tstruct panel_bridge *panel_bridge;\n\n\tif (!bridge)\n\t\treturn;\n\n\tif (bridge->funcs != &panel_bridge_bridge_funcs)\n\t\treturn;\n\n\tpanel_bridge = drm_bridge_to_panel_bridge(bridge);\n\n\tdrm_bridge_remove(bridge);\n\tdevm_kfree(panel_bridge->panel->dev, bridge);\n}\nEXPORT_SYMBOL(drm_panel_bridge_remove);\n\n \nint drm_panel_bridge_set_orientation(struct drm_connector *connector,\n\t\t\t\t     struct drm_bridge *bridge)\n{\n\tstruct panel_bridge *panel_bridge;\n\n\tpanel_bridge = drm_bridge_to_panel_bridge(bridge);\n\n\treturn drm_connector_set_orientation_from_panel(connector,\n\t\t\t\t\t\t\tpanel_bridge->panel);\n}\nEXPORT_SYMBOL(drm_panel_bridge_set_orientation);\n\nstatic void devm_drm_panel_bridge_release(struct device *dev, void *res)\n{\n\tstruct drm_bridge **bridge = res;\n\n\tdrm_panel_bridge_remove(*bridge);\n}\n\n \nstruct drm_bridge *devm_drm_panel_bridge_add(struct device *dev,\n\t\t\t\t\t     struct drm_panel *panel)\n{\n\tif (WARN_ON(panel->connector_type == DRM_MODE_CONNECTOR_Unknown))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn devm_drm_panel_bridge_add_typed(dev, panel,\n\t\t\t\t\t       panel->connector_type);\n}\nEXPORT_SYMBOL(devm_drm_panel_bridge_add);\n\n \nstruct drm_bridge *devm_drm_panel_bridge_add_typed(struct device *dev,\n\t\t\t\t\t\t   struct drm_panel *panel,\n\t\t\t\t\t\t   u32 connector_type)\n{\n\tstruct drm_bridge **ptr, *bridge;\n\n\tptr = devres_alloc(devm_drm_panel_bridge_release, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbridge = drm_panel_bridge_add_typed(panel, connector_type);\n\tif (IS_ERR(bridge)) {\n\t\tdevres_free(ptr);\n\t\treturn bridge;\n\t}\n\n\tbridge->pre_enable_prev_first = panel->prepare_prev_first;\n\n\t*ptr = bridge;\n\tdevres_add(dev, ptr);\n\n\treturn bridge;\n}\nEXPORT_SYMBOL(devm_drm_panel_bridge_add_typed);\n\nstatic void drmm_drm_panel_bridge_release(struct drm_device *drm, void *ptr)\n{\n\tstruct drm_bridge *bridge = ptr;\n\n\tdrm_panel_bridge_remove(bridge);\n}\n\n \nstruct drm_bridge *drmm_panel_bridge_add(struct drm_device *drm,\n\t\t\t\t\t struct drm_panel *panel)\n{\n\tstruct drm_bridge *bridge;\n\tint ret;\n\n\tbridge = drm_panel_bridge_add_typed(panel, panel->connector_type);\n\tif (IS_ERR(bridge))\n\t\treturn bridge;\n\n\tret = drmm_add_action_or_reset(drm, drmm_drm_panel_bridge_release,\n\t\t\t\t       bridge);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tbridge->pre_enable_prev_first = panel->prepare_prev_first;\n\n\treturn bridge;\n}\nEXPORT_SYMBOL(drmm_panel_bridge_add);\n\n \nstruct drm_connector *drm_panel_bridge_connector(struct drm_bridge *bridge)\n{\n\tstruct panel_bridge *panel_bridge;\n\n\tpanel_bridge = drm_bridge_to_panel_bridge(bridge);\n\n\treturn &panel_bridge->connector;\n}\nEXPORT_SYMBOL(drm_panel_bridge_connector);\n\n#ifdef CONFIG_OF\n \nstruct drm_bridge *devm_drm_of_get_bridge(struct device *dev,\n\t\t\t\t\t  struct device_node *np,\n\t\t\t\t\t  u32 port, u32 endpoint)\n{\n\tstruct drm_bridge *bridge;\n\tstruct drm_panel *panel;\n\tint ret;\n\n\tret = drm_of_find_panel_or_bridge(np, port, endpoint,\n\t\t\t\t\t  &panel, &bridge);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (panel)\n\t\tbridge = devm_drm_panel_bridge_add(dev, panel);\n\n\treturn bridge;\n}\nEXPORT_SYMBOL(devm_drm_of_get_bridge);\n\n \nstruct drm_bridge *drmm_of_get_bridge(struct drm_device *drm,\n\t\t\t\t      struct device_node *np,\n\t\t\t\t      u32 port, u32 endpoint)\n{\n\tstruct drm_bridge *bridge;\n\tstruct drm_panel *panel;\n\tint ret;\n\n\tret = drm_of_find_panel_or_bridge(np, port, endpoint,\n\t\t\t\t\t  &panel, &bridge);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (panel)\n\t\tbridge = drmm_panel_bridge_add(drm, panel);\n\n\treturn bridge;\n}\nEXPORT_SYMBOL(drmm_of_get_bridge);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}