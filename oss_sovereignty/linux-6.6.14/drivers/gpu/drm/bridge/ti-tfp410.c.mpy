{
  "module_name": "ti-tfp410.c",
  "hash_id": "1198dc44f6f413f92019effc6b73c5c8ce12eb5c59858efb78cb7f2a805fd4fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/ti-tfp410.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#define HOTPLUG_DEBOUNCE_MS\t\t1100\n\nstruct tfp410 {\n\tstruct drm_bridge\tbridge;\n\tstruct drm_connector\tconnector;\n\n\tu32\t\t\tbus_format;\n\tstruct delayed_work\thpd_work;\n\tstruct gpio_desc\t*powerdown;\n\n\tstruct drm_bridge_timings timings;\n\tstruct drm_bridge\t*next_bridge;\n\n\tstruct device *dev;\n};\n\nstatic inline struct tfp410 *\ndrm_bridge_to_tfp410(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct tfp410, bridge);\n}\n\nstatic inline struct tfp410 *\ndrm_connector_to_tfp410(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct tfp410, connector);\n}\n\nstatic int tfp410_get_modes(struct drm_connector *connector)\n{\n\tstruct tfp410 *dvi = drm_connector_to_tfp410(connector);\n\tstruct edid *edid;\n\tint ret;\n\n\tif (dvi->next_bridge->ops & DRM_BRIDGE_OP_EDID) {\n\t\tedid = drm_bridge_get_edid(dvi->next_bridge, connector);\n\t\tif (!edid)\n\t\t\tDRM_INFO(\"EDID read failed. Fallback to standard modes\\n\");\n\t} else {\n\t\tedid = NULL;\n\t}\n\n\tif (!edid) {\n\t\t \n\t\tret = drm_add_modes_noedid(connector, 1920, 1200);\n\t\tdrm_set_preferred_mode(connector, 1024, 768);\n\t\treturn ret;\n\t}\n\n\tdrm_connector_update_edid_property(connector, edid);\n\n\tret = drm_add_edid_modes(connector, edid);\n\n\tkfree(edid);\n\n\treturn ret;\n}\n\nstatic const struct drm_connector_helper_funcs tfp410_con_helper_funcs = {\n\t.get_modes\t= tfp410_get_modes,\n};\n\nstatic enum drm_connector_status\ntfp410_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct tfp410 *dvi = drm_connector_to_tfp410(connector);\n\n\treturn drm_bridge_detect(dvi->next_bridge);\n}\n\nstatic const struct drm_connector_funcs tfp410_con_funcs = {\n\t.detect\t\t\t= tfp410_connector_detect,\n\t.fill_modes\t\t= drm_helper_probe_single_connector_modes,\n\t.destroy\t\t= drm_connector_cleanup,\n\t.reset\t\t\t= drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_connector_destroy_state,\n};\n\nstatic void tfp410_hpd_work_func(struct work_struct *work)\n{\n\tstruct tfp410 *dvi;\n\n\tdvi = container_of(work, struct tfp410, hpd_work.work);\n\n\tif (dvi->bridge.dev)\n\t\tdrm_helper_hpd_irq_event(dvi->bridge.dev);\n}\n\nstatic void tfp410_hpd_callback(void *arg, enum drm_connector_status status)\n{\n\tstruct tfp410 *dvi = arg;\n\n\tmod_delayed_work(system_wq, &dvi->hpd_work,\n\t\t\t msecs_to_jiffies(HOTPLUG_DEBOUNCE_MS));\n}\n\nstatic int tfp410_attach(struct drm_bridge *bridge,\n\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct tfp410 *dvi = drm_bridge_to_tfp410(bridge);\n\tint ret;\n\n\tret = drm_bridge_attach(bridge->encoder, dvi->next_bridge, bridge,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)\n\t\treturn 0;\n\n\tif (!bridge->encoder) {\n\t\tdev_err(dvi->dev, \"Missing encoder\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dvi->next_bridge->ops & DRM_BRIDGE_OP_DETECT)\n\t\tdvi->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\telse\n\t\tdvi->connector.polled = DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT;\n\n\tif (dvi->next_bridge->ops & DRM_BRIDGE_OP_HPD) {\n\t\tINIT_DELAYED_WORK(&dvi->hpd_work, tfp410_hpd_work_func);\n\t\tdrm_bridge_hpd_enable(dvi->next_bridge, tfp410_hpd_callback,\n\t\t\t\t      dvi);\n\t}\n\n\tdrm_connector_helper_add(&dvi->connector,\n\t\t\t\t &tfp410_con_helper_funcs);\n\tret = drm_connector_init_with_ddc(bridge->dev, &dvi->connector,\n\t\t\t\t\t  &tfp410_con_funcs,\n\t\t\t\t\t  dvi->next_bridge->type,\n\t\t\t\t\t  dvi->next_bridge->ddc);\n\tif (ret) {\n\t\tdev_err(dvi->dev, \"drm_connector_init_with_ddc() failed: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tdrm_display_info_set_bus_formats(&dvi->connector.display_info,\n\t\t\t\t\t &dvi->bus_format, 1);\n\n\tdrm_connector_attach_encoder(&dvi->connector, bridge->encoder);\n\n\treturn 0;\n}\n\nstatic void tfp410_detach(struct drm_bridge *bridge)\n{\n\tstruct tfp410 *dvi = drm_bridge_to_tfp410(bridge);\n\n\tif (dvi->connector.dev && dvi->next_bridge->ops & DRM_BRIDGE_OP_HPD) {\n\t\tdrm_bridge_hpd_disable(dvi->next_bridge);\n\t\tcancel_delayed_work_sync(&dvi->hpd_work);\n\t}\n}\n\nstatic void tfp410_enable(struct drm_bridge *bridge)\n{\n\tstruct tfp410 *dvi = drm_bridge_to_tfp410(bridge);\n\n\tgpiod_set_value_cansleep(dvi->powerdown, 0);\n}\n\nstatic void tfp410_disable(struct drm_bridge *bridge)\n{\n\tstruct tfp410 *dvi = drm_bridge_to_tfp410(bridge);\n\n\tgpiod_set_value_cansleep(dvi->powerdown, 1);\n}\n\nstatic enum drm_mode_status tfp410_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t\t      const struct drm_display_info *info,\n\t\t\t\t\t      const struct drm_display_mode *mode)\n{\n\tif (mode->clock < 25000)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (mode->clock > 165000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic u32 *tfp410_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t      struct drm_bridge_state *bridge_state,\n\t\t\t\t      struct drm_crtc_state *crtc_state,\n\t\t\t\t      struct drm_connector_state *conn_state,\n\t\t\t\t      u32 output_fmt,\n\t\t\t\t      unsigned int *num_input_fmts)\n{\n\tstruct tfp410 *dvi = drm_bridge_to_tfp410(bridge);\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kzalloc(sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\t*num_input_fmts = 1;\n\tinput_fmts[0] = dvi->bus_format;\n\n\treturn input_fmts;\n}\n\nstatic int tfp410_atomic_check(struct drm_bridge *bridge,\n\t\t\t       struct drm_bridge_state *bridge_state,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct tfp410 *dvi = drm_bridge_to_tfp410(bridge);\n\n\t \n\tbridge_state->input_bus_cfg.flags = dvi->timings.input_bus_flags;\n\n\treturn 0;\n}\n\nstatic const struct drm_bridge_funcs tfp410_bridge_funcs = {\n\t.attach\t\t= tfp410_attach,\n\t.detach\t\t= tfp410_detach,\n\t.enable\t\t= tfp410_enable,\n\t.disable\t= tfp410_disable,\n\t.mode_valid\t= tfp410_mode_valid,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_get_input_bus_fmts = tfp410_get_input_bus_fmts,\n\t.atomic_check = tfp410_atomic_check,\n};\n\nstatic const struct drm_bridge_timings tfp410_default_timings = {\n\t.input_bus_flags = DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE\n\t\t\t | DRM_BUS_FLAG_DE_HIGH,\n\t.setup_time_ps = 1200,\n\t.hold_time_ps = 1300,\n};\n\nstatic int tfp410_parse_timings(struct tfp410 *dvi, bool i2c)\n{\n\tstruct drm_bridge_timings *timings = &dvi->timings;\n\tstruct device_node *ep;\n\tu32 pclk_sample = 0;\n\tu32 bus_width = 24;\n\tu32 deskew = 0;\n\n\t \n\t*timings = tfp410_default_timings;\n\n\tif (i2c)\n\t\t \n\t\treturn 0;\n\n\t \n\tep = of_graph_get_endpoint_by_regs(dvi->dev->of_node, 0, 0);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\t \n\tof_property_read_u32(ep, \"pclk-sample\", &pclk_sample);\n\tof_property_read_u32(ep, \"bus-width\", &bus_width);\n\tof_node_put(ep);\n\n\ttimings->input_bus_flags = DRM_BUS_FLAG_DE_HIGH;\n\n\tswitch (pclk_sample) {\n\tcase 0:\n\t\ttimings->input_bus_flags |= DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE\n\t\t\t\t\t |  DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE;\n\t\tbreak;\n\tcase 1:\n\t\ttimings->input_bus_flags |= DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE\n\t\t\t\t\t |  DRM_BUS_FLAG_SYNC_SAMPLE_POSEDGE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (bus_width) {\n\tcase 12:\n\t\tdvi->bus_format = MEDIA_BUS_FMT_RGB888_2X12_LE;\n\t\tbreak;\n\tcase 24:\n\t\tdvi->bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tof_property_read_u32(dvi->dev->of_node, \"ti,deskew\", &deskew);\n\tif (deskew > 7)\n\t\treturn -EINVAL;\n\n\ttimings->setup_time_ps = 1200 - 350 * ((s32)deskew - 4);\n\ttimings->hold_time_ps = max(0, 1300 + 350 * ((s32)deskew - 4));\n\n\treturn 0;\n}\n\nstatic int tfp410_init(struct device *dev, bool i2c)\n{\n\tstruct device_node *node;\n\tstruct tfp410 *dvi;\n\tint ret;\n\n\tif (!dev->of_node) {\n\t\tdev_err(dev, \"device-tree data is missing\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tdvi = devm_kzalloc(dev, sizeof(*dvi), GFP_KERNEL);\n\tif (!dvi)\n\t\treturn -ENOMEM;\n\n\tdvi->dev = dev;\n\tdev_set_drvdata(dev, dvi);\n\n\tdvi->bridge.funcs = &tfp410_bridge_funcs;\n\tdvi->bridge.of_node = dev->of_node;\n\tdvi->bridge.timings = &dvi->timings;\n\tdvi->bridge.type = DRM_MODE_CONNECTOR_DVID;\n\n\tret = tfp410_parse_timings(dvi, i2c);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnode = of_graph_get_remote_node(dev->of_node, 1, -1);\n\tif (!node)\n\t\treturn -ENODEV;\n\n\tdvi->next_bridge = of_drm_find_bridge(node);\n\tof_node_put(node);\n\n\tif (!dvi->next_bridge)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tdvi->powerdown = devm_gpiod_get_optional(dev, \"powerdown\",\n\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\tif (IS_ERR(dvi->powerdown)) {\n\t\tdev_err(dev, \"failed to parse powerdown gpio\\n\");\n\t\treturn PTR_ERR(dvi->powerdown);\n\t}\n\n\t \n\tdrm_bridge_add(&dvi->bridge);\n\n\treturn 0;\n}\n\nstatic void tfp410_fini(struct device *dev)\n{\n\tstruct tfp410 *dvi = dev_get_drvdata(dev);\n\n\tdrm_bridge_remove(&dvi->bridge);\n}\n\nstatic int tfp410_probe(struct platform_device *pdev)\n{\n\treturn tfp410_init(&pdev->dev, false);\n}\n\nstatic void tfp410_remove(struct platform_device *pdev)\n{\n\ttfp410_fini(&pdev->dev);\n}\n\nstatic const struct of_device_id tfp410_match[] = {\n\t{ .compatible = \"ti,tfp410\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tfp410_match);\n\nstatic struct platform_driver tfp410_platform_driver = {\n\t.probe\t= tfp410_probe,\n\t.remove_new = tfp410_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"tfp410-bridge\",\n\t\t.of_match_table\t= tfp410_match,\n\t},\n};\n\n#if IS_ENABLED(CONFIG_I2C)\n \nstatic int tfp410_i2c_probe(struct i2c_client *client)\n{\n\tint reg;\n\n\tif (!client->dev.of_node ||\n\t    of_property_read_u32(client->dev.of_node, \"reg\", &reg)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Can't get i2c reg property from device-tree\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn tfp410_init(&client->dev, true);\n}\n\nstatic void tfp410_i2c_remove(struct i2c_client *client)\n{\n\ttfp410_fini(&client->dev);\n}\n\nstatic const struct i2c_device_id tfp410_i2c_ids[] = {\n\t{ \"tfp410\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tfp410_i2c_ids);\n\nstatic struct i2c_driver tfp410_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"tfp410\",\n\t\t.of_match_table = tfp410_match,\n\t},\n\t.id_table\t= tfp410_i2c_ids,\n\t.probe\t\t= tfp410_i2c_probe,\n\t.remove\t\t= tfp410_i2c_remove,\n};\n#endif  \n\nstatic struct {\n\tuint i2c:1;\n\tuint platform:1;\n}  tfp410_registered_driver;\n\nstatic int __init tfp410_module_init(void)\n{\n\tint ret;\n\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&tfp410_i2c_driver);\n\tif (ret)\n\t\tpr_err(\"%s: registering i2c driver failed: %d\",\n\t\t       __func__, ret);\n\telse\n\t\ttfp410_registered_driver.i2c = 1;\n#endif\n\n\tret = platform_driver_register(&tfp410_platform_driver);\n\tif (ret)\n\t\tpr_err(\"%s: registering platform driver failed: %d\",\n\t\t       __func__, ret);\n\telse\n\t\ttfp410_registered_driver.platform = 1;\n\n\tif (tfp410_registered_driver.i2c ||\n\t    tfp410_registered_driver.platform)\n\t\treturn 0;\n\n\treturn ret;\n}\nmodule_init(tfp410_module_init);\n\nstatic void __exit tfp410_module_exit(void)\n{\n#if IS_ENABLED(CONFIG_I2C)\n\tif (tfp410_registered_driver.i2c)\n\t\ti2c_del_driver(&tfp410_i2c_driver);\n#endif\n\tif (tfp410_registered_driver.platform)\n\t\tplatform_driver_unregister(&tfp410_platform_driver);\n}\nmodule_exit(tfp410_module_exit);\n\nMODULE_AUTHOR(\"Jyri Sarha <jsarha@ti.com>\");\nMODULE_DESCRIPTION(\"TI TFP410 DVI bridge driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}