{
  "module_name": "chipone-icn6211.c",
  "hash_id": "997be9e69e43f826a78a5af86a52f7c37dfb308fa8ba7a00611c47f7fea83ec5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/chipone-icn6211.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n#include <drm/drm_mipi_dsi.h>\n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#define VENDOR_ID\t\t0x00\n#define DEVICE_ID_H\t\t0x01\n#define DEVICE_ID_L\t\t0x02\n#define VERSION_ID\t\t0x03\n#define FIRMWARE_VERSION\t0x08\n#define CONFIG_FINISH\t\t0x09\n#define PD_CTRL(n)\t\t(0x0a + ((n) & 0x3))  \n#define RST_CTRL(n)\t\t(0x0e + ((n) & 0x1))  \n#define SYS_CTRL(n)\t\t(0x10 + ((n) & 0x7))  \n#define SYS_CTRL_1_CLK_PHASE_MSK\tGENMASK(5, 4)\n#define CLK_PHASE_0\t\t\t0\n#define CLK_PHASE_1_4\t\t\t1\n#define CLK_PHASE_1_2\t\t\t2\n#define CLK_PHASE_3_4\t\t\t3\n#define RGB_DRV(n)\t\t(0x18 + ((n) & 0x3))  \n#define RGB_DLY(n)\t\t(0x1c + ((n) & 0x1))  \n#define RGB_TEST_CTRL\t\t0x1e\n#define ATE_PLL_EN\t\t0x1f\n#define HACTIVE_LI\t\t0x20\n#define VACTIVE_LI\t\t0x21\n#define VACTIVE_HACTIVE_HI\t0x22\n#define HFP_LI\t\t\t0x23\n#define HSYNC_LI\t\t0x24\n#define HBP_LI\t\t\t0x25\n#define HFP_HSW_HBP_HI\t\t0x26\n#define HFP_HSW_HBP_HI_HFP(n)\t\t(((n) & 0x300) >> 4)\n#define HFP_HSW_HBP_HI_HS(n)\t\t(((n) & 0x300) >> 6)\n#define HFP_HSW_HBP_HI_HBP(n)\t\t(((n) & 0x300) >> 8)\n#define VFP\t\t\t0x27\n#define VSYNC\t\t\t0x28\n#define VBP\t\t\t0x29\n#define BIST_POL\t\t0x2a\n#define BIST_POL_BIST_MODE(n)\t\t(((n) & 0xf) << 4)\n#define BIST_POL_BIST_GEN\t\tBIT(3)\n#define BIST_POL_HSYNC_POL\t\tBIT(2)\n#define BIST_POL_VSYNC_POL\t\tBIT(1)\n#define BIST_POL_DE_POL\t\t\tBIT(0)\n#define BIST_RED\t\t0x2b\n#define BIST_GREEN\t\t0x2c\n#define BIST_BLUE\t\t0x2d\n#define BIST_CHESS_X\t\t0x2e\n#define BIST_CHESS_Y\t\t0x2f\n#define BIST_CHESS_XY_H\t\t0x30\n#define BIST_FRAME_TIME_L\t0x31\n#define BIST_FRAME_TIME_H\t0x32\n#define FIFO_MAX_ADDR_LOW\t0x33\n#define SYNC_EVENT_DLY\t\t0x34\n#define HSW_MIN\t\t\t0x35\n#define HFP_MIN\t\t\t0x36\n#define LOGIC_RST_NUM\t\t0x37\n#define OSC_CTRL(n)\t\t(0x48 + ((n) & 0x7))  \n#define BG_CTRL\t\t\t0x4e\n#define LDO_PLL\t\t\t0x4f\n#define PLL_CTRL(n)\t\t(0x50 + ((n) & 0xf))  \n#define PLL_CTRL_6_EXTERNAL\t\t0x90\n#define PLL_CTRL_6_MIPI_CLK\t\t0x92\n#define PLL_CTRL_6_INTERNAL\t\t0x93\n#define PLL_REM(n)\t\t(0x60 + ((n) & 0x3))  \n#define PLL_DIV(n)\t\t(0x63 + ((n) & 0x3))  \n#define PLL_FRAC(n)\t\t(0x66 + ((n) & 0x3))  \n#define PLL_INT(n)\t\t(0x69 + ((n) & 0x1))  \n#define PLL_REF_DIV\t\t0x6b\n#define PLL_REF_DIV_P(n)\t\t((n) & 0xf)\n#define PLL_REF_DIV_Pe\t\t\tBIT(4)\n#define PLL_REF_DIV_S(n)\t\t(((n) & 0x7) << 5)\n#define PLL_SSC_P(n)\t\t(0x6c + ((n) & 0x3))  \n#define PLL_SSC_STEP(n)\t\t(0x6f + ((n) & 0x3))  \n#define PLL_SSC_OFFSET(n)\t(0x72 + ((n) & 0x3))  \n#define GPIO_OEN\t\t0x79\n#define MIPI_CFG_PW\t\t0x7a\n#define MIPI_CFG_PW_CONFIG_DSI\t\t0xc1\n#define MIPI_CFG_PW_CONFIG_I2C\t\t0x3e\n#define GPIO_SEL(n)\t\t(0x7b + ((n) & 0x1))  \n#define IRQ_SEL\t\t\t0x7d\n#define DBG_SEL\t\t\t0x7e\n#define DBG_SIGNAL\t\t0x7f\n#define MIPI_ERR_VECTOR_L\t0x80\n#define MIPI_ERR_VECTOR_H\t0x81\n#define MIPI_ERR_VECTOR_EN_L\t0x82\n#define MIPI_ERR_VECTOR_EN_H\t0x83\n#define MIPI_MAX_SIZE_L\t\t0x84\n#define MIPI_MAX_SIZE_H\t\t0x85\n#define DSI_CTRL\t\t0x86\n#define DSI_CTRL_UNKNOWN\t\t0x28\n#define DSI_CTRL_DSI_LANES(n)\t\t((n) & 0x3)\n#define MIPI_PN_SWAP\t\t0x87\n#define MIPI_PN_SWAP_CLK\t\tBIT(4)\n#define MIPI_PN_SWAP_D(n)\t\tBIT((n) & 0x3)\n#define MIPI_SOT_SYNC_BIT(n)\t(0x88 + ((n) & 0x1))  \n#define MIPI_ULPS_CTRL\t\t0x8a\n#define MIPI_CLK_CHK_VAR\t0x8e\n#define MIPI_CLK_CHK_INI\t0x8f\n#define MIPI_T_TERM_EN\t\t0x90\n#define MIPI_T_HS_SETTLE\t0x91\n#define MIPI_T_TA_SURE_PRE\t0x92\n#define MIPI_T_LPX_SET\t\t0x94\n#define MIPI_T_CLK_MISS\t\t0x95\n#define MIPI_INIT_TIME_L\t0x96\n#define MIPI_INIT_TIME_H\t0x97\n#define MIPI_T_CLK_TERM_EN\t0x99\n#define MIPI_T_CLK_SETTLE\t0x9a\n#define MIPI_TO_HS_RX_L\t\t0x9e\n#define MIPI_TO_HS_RX_H\t\t0x9f\n#define MIPI_PHY(n)\t\t(0xa0 + ((n) & 0x7))  \n#define MIPI_PD_RX\t\t0xb0\n#define MIPI_PD_TERM\t\t0xb1\n#define MIPI_PD_HSRX\t\t0xb2\n#define MIPI_PD_LPTX\t\t0xb3\n#define MIPI_PD_LPRX\t\t0xb4\n#define MIPI_PD_CK_LANE\t\t0xb5\n#define MIPI_FORCE_0\t\t0xb6\n#define MIPI_RST_CTRL\t\t0xb7\n#define MIPI_RST_NUM\t\t0xb8\n#define MIPI_DBG_SET(n)\t\t(0xc0 + ((n) & 0xf))  \n#define MIPI_DBG_SEL\t\t0xe0\n#define MIPI_DBG_DATA\t\t0xe1\n#define MIPI_ATE_TEST_SEL\t0xe2\n#define MIPI_ATE_STATUS(n)\t(0xe3 + ((n) & 0x1))  \n\nstruct chipone {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct i2c_client *client;\n\tstruct drm_bridge bridge;\n\tstruct drm_display_mode mode;\n\tstruct drm_bridge *panel_bridge;\n\tstruct mipi_dsi_device *dsi;\n\tstruct gpio_desc *enable_gpio;\n\tstruct regulator *vdd1;\n\tstruct regulator *vdd2;\n\tstruct regulator *vdd3;\n\tstruct clk *refclk;\n\tunsigned long refclk_rate;\n\tbool interface_i2c;\n};\n\nstatic const struct regmap_range chipone_dsi_readable_ranges[] = {\n\tregmap_reg_range(VENDOR_ID, VERSION_ID),\n\tregmap_reg_range(FIRMWARE_VERSION, PLL_SSC_OFFSET(3)),\n\tregmap_reg_range(GPIO_OEN, MIPI_ULPS_CTRL),\n\tregmap_reg_range(MIPI_CLK_CHK_VAR, MIPI_T_TA_SURE_PRE),\n\tregmap_reg_range(MIPI_T_LPX_SET, MIPI_INIT_TIME_H),\n\tregmap_reg_range(MIPI_T_CLK_TERM_EN, MIPI_T_CLK_SETTLE),\n\tregmap_reg_range(MIPI_TO_HS_RX_L, MIPI_PHY(5)),\n\tregmap_reg_range(MIPI_PD_RX, MIPI_RST_NUM),\n\tregmap_reg_range(MIPI_DBG_SET(0), MIPI_DBG_SET(9)),\n\tregmap_reg_range(MIPI_DBG_SEL, MIPI_ATE_STATUS(1)),\n};\n\nstatic const struct regmap_access_table chipone_dsi_readable_table = {\n\t.yes_ranges = chipone_dsi_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(chipone_dsi_readable_ranges),\n};\n\nstatic const struct regmap_range chipone_dsi_writeable_ranges[] = {\n\tregmap_reg_range(CONFIG_FINISH, PLL_SSC_OFFSET(3)),\n\tregmap_reg_range(GPIO_OEN, MIPI_ULPS_CTRL),\n\tregmap_reg_range(MIPI_CLK_CHK_VAR, MIPI_T_TA_SURE_PRE),\n\tregmap_reg_range(MIPI_T_LPX_SET, MIPI_INIT_TIME_H),\n\tregmap_reg_range(MIPI_T_CLK_TERM_EN, MIPI_T_CLK_SETTLE),\n\tregmap_reg_range(MIPI_TO_HS_RX_L, MIPI_PHY(5)),\n\tregmap_reg_range(MIPI_PD_RX, MIPI_RST_NUM),\n\tregmap_reg_range(MIPI_DBG_SET(0), MIPI_DBG_SET(9)),\n\tregmap_reg_range(MIPI_DBG_SEL, MIPI_ATE_STATUS(1)),\n};\n\nstatic const struct regmap_access_table chipone_dsi_writeable_table = {\n\t.yes_ranges = chipone_dsi_writeable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(chipone_dsi_writeable_ranges),\n};\n\nstatic const struct regmap_config chipone_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.rd_table = &chipone_dsi_readable_table,\n\t.wr_table = &chipone_dsi_writeable_table,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = MIPI_ATE_STATUS(1),\n};\n\nstatic int chipone_dsi_read(void *context,\n\t\t\t    const void *reg, size_t reg_size,\n\t\t\t    void *val, size_t val_size)\n{\n\tstruct mipi_dsi_device *dsi = context;\n\tconst u16 reg16 = (val_size << 8) | *(u8 *)reg;\n\tint ret;\n\n\tret = mipi_dsi_generic_read(dsi, &reg16, 2, val, val_size);\n\n\treturn ret == val_size ? 0 : -EINVAL;\n}\n\nstatic int chipone_dsi_write(void *context, const void *data, size_t count)\n{\n\tstruct mipi_dsi_device *dsi = context;\n\n\treturn mipi_dsi_generic_write(dsi, data, 2);\n}\n\nstatic const struct regmap_bus chipone_dsi_regmap_bus = {\n\t.read\t\t\t\t= chipone_dsi_read,\n\t.write\t\t\t\t= chipone_dsi_write,\n\t.reg_format_endian_default\t= REGMAP_ENDIAN_NATIVE,\n\t.val_format_endian_default\t= REGMAP_ENDIAN_NATIVE,\n};\n\nstatic inline struct chipone *bridge_to_chipone(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct chipone, bridge);\n}\n\nstatic void chipone_readb(struct chipone *icn, u8 reg, u8 *val)\n{\n\tint ret, pval;\n\n\tret = regmap_read(icn->regmap, reg, &pval);\n\n\t*val = ret ? 0 : pval & 0xff;\n}\n\nstatic int chipone_writeb(struct chipone *icn, u8 reg, u8 val)\n{\n\treturn regmap_write(icn->regmap, reg, val);\n}\n\nstatic void chipone_configure_pll(struct chipone *icn,\n\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tunsigned int best_p = 0, best_m = 0, best_s = 0;\n\tunsigned int mode_clock = mode->clock * 1000;\n\tunsigned int delta, min_delta = 0xffffffff;\n\tunsigned int freq_p, freq_s, freq_out;\n\tunsigned int p_min, p_max;\n\tunsigned int p, m, s;\n\tunsigned int fin;\n\tbool best_p_pot;\n\tu8 ref_div;\n\n\t \n\tif (icn->refclk)\n\t\tfin = icn->refclk_rate;\n\telse\n\t\tfin = icn->dsi->hs_rate / 4;  \n\n\t \n\tp_min = clamp(DIV_ROUND_UP(fin, 20000000), 1U, 31U);\n\tp_max = clamp(fin / 5000000, 1U, 31U);\n\n\tfor (p = p_min; p < p_max; p++) {\t \n\t\tif (p > 16 && p & 1)\t\t \n\t\t\tcontinue;\n\t\tfreq_p = fin / p;\n\t\tif (freq_p == 0)\t\t \n\t\t\tbreak;\n\n\t\tfor (s = 0; s < 0x7; s++) {\t \n\t\t\tfreq_s = freq_p / BIT(s + 1);\n\t\t\tif (freq_s == 0)\t \n\t\t\t\tbreak;\n\n\t\t\tm = mode_clock / freq_s;\n\n\t\t\t \n\t\t\tif (m > 0xff)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tfreq_out = (fin * m) / p;\n\t\t\tif (freq_out > 1000000000)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tfreq_out /= BIT(s + 1);\n\n\t\t\tdelta = abs(mode_clock - freq_out);\n\t\t\tif (delta < min_delta) {\n\t\t\t\tbest_p = p;\n\t\t\t\tbest_m = m;\n\t\t\t\tbest_s = s;\n\t\t\t\tmin_delta = delta;\n\t\t\t}\n\t\t}\n\t}\n\n\tbest_p_pot = !(best_p & 1);\n\n\tdev_dbg(icn->dev,\n\t\t\"PLL: P[3:0]=%d P[4]=2*%d M=%d S[7:5]=2^%d delta=%d => DSI f_in(%s)=%d Hz ; DPI f_out=%d Hz\\n\",\n\t\tbest_p >> best_p_pot, best_p_pot, best_m, best_s + 1,\n\t\tmin_delta, icn->refclk ? \"EXT\" : \"DSI\", fin,\n\t\t(fin * best_m) / (best_p << (best_s + 1)));\n\n\tref_div = PLL_REF_DIV_P(best_p >> best_p_pot) | PLL_REF_DIV_S(best_s);\n\tif (best_p_pot)\t \n\t\tref_div |= PLL_REF_DIV_Pe;\n\n\t \n\tchipone_writeb(icn, PLL_CTRL(6),\n\t\t       icn->refclk ? PLL_CTRL_6_EXTERNAL : PLL_CTRL_6_MIPI_CLK);\n\tchipone_writeb(icn, PLL_REF_DIV, ref_div);\n\tchipone_writeb(icn, PLL_INT(0), best_m);\n}\n\nstatic void chipone_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *old_bridge_state)\n{\n\tstruct chipone *icn = bridge_to_chipone(bridge);\n\tstruct drm_atomic_state *state = old_bridge_state->base.state;\n\tstruct drm_display_mode *mode = &icn->mode;\n\tconst struct drm_bridge_state *bridge_state;\n\tu16 hfp, hbp, hsync;\n\tu32 bus_flags;\n\tu8 pol, sys_ctrl_1, id[4];\n\n\tchipone_readb(icn, VENDOR_ID, id);\n\tchipone_readb(icn, DEVICE_ID_H, id + 1);\n\tchipone_readb(icn, DEVICE_ID_L, id + 2);\n\tchipone_readb(icn, VERSION_ID, id + 3);\n\n\tdev_dbg(icn->dev,\n\t\t\"Chip IDs: Vendor=0x%02x Device=0x%02x:0x%02x Version=0x%02x\\n\",\n\t\tid[0], id[1], id[2], id[3]);\n\n\tif (id[0] != 0xc1 || id[1] != 0x62 || id[2] != 0x11) {\n\t\tdev_dbg(icn->dev, \"Invalid Chip IDs, aborting configuration\\n\");\n\t\treturn;\n\t}\n\n\t \n\tbridge_state = drm_atomic_get_new_bridge_state(state, bridge);\n\tbus_flags = bridge_state->output_bus_cfg.flags;\n\n\tif (icn->interface_i2c)\n\t\tchipone_writeb(icn, MIPI_CFG_PW, MIPI_CFG_PW_CONFIG_I2C);\n\telse\n\t\tchipone_writeb(icn, MIPI_CFG_PW, MIPI_CFG_PW_CONFIG_DSI);\n\n\tchipone_writeb(icn, HACTIVE_LI, mode->hdisplay & 0xff);\n\n\tchipone_writeb(icn, VACTIVE_LI, mode->vdisplay & 0xff);\n\n\t \n\tchipone_writeb(icn, VACTIVE_HACTIVE_HI,\n\t\t       ((mode->hdisplay >> 8) & 0xf) |\n\t\t       (((mode->vdisplay >> 8) & 0xf) << 4));\n\n\thfp = mode->hsync_start - mode->hdisplay;\n\thsync = mode->hsync_end - mode->hsync_start;\n\thbp = mode->htotal - mode->hsync_end;\n\n\tchipone_writeb(icn, HFP_LI, hfp & 0xff);\n\tchipone_writeb(icn, HSYNC_LI, hsync & 0xff);\n\tchipone_writeb(icn, HBP_LI, hbp & 0xff);\n\t \n\tchipone_writeb(icn, HFP_HSW_HBP_HI,\n\t\t       HFP_HSW_HBP_HI_HFP(hfp) |\n\t\t       HFP_HSW_HBP_HI_HS(hsync) |\n\t\t       HFP_HSW_HBP_HI_HBP(hbp));\n\n\tchipone_writeb(icn, VFP, mode->vsync_start - mode->vdisplay);\n\n\tchipone_writeb(icn, VSYNC, mode->vsync_end - mode->vsync_start);\n\n\tchipone_writeb(icn, VBP, mode->vtotal - mode->vsync_end);\n\n\t \n\tchipone_writeb(icn, SYNC_EVENT_DLY, 0x80);\n\tchipone_writeb(icn, HFP_MIN, hfp & 0xff);\n\n\t \n\tchipone_writeb(icn, DSI_CTRL,\n\t\t       DSI_CTRL_UNKNOWN | DSI_CTRL_DSI_LANES(icn->dsi->lanes - 1));\n\n\tchipone_writeb(icn, MIPI_PD_CK_LANE, 0xa0);\n\tchipone_writeb(icn, PLL_CTRL(12), 0xff);\n\tchipone_writeb(icn, MIPI_PN_SWAP, 0x00);\n\n\t \n\tpol = ((mode->flags & DRM_MODE_FLAG_PHSYNC) ? BIST_POL_HSYNC_POL : 0) |\n\t      ((mode->flags & DRM_MODE_FLAG_PVSYNC) ? BIST_POL_VSYNC_POL : 0) |\n\t      ((bus_flags & DRM_BUS_FLAG_DE_HIGH) ? BIST_POL_DE_POL : 0);\n\tchipone_writeb(icn, BIST_POL, pol);\n\n\t \n\tchipone_configure_pll(icn, mode);\n\n\tchipone_writeb(icn, SYS_CTRL(0), 0x40);\n\tsys_ctrl_1 = 0x88;\n\n\tif (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE)\n\t\tsys_ctrl_1 |= FIELD_PREP(SYS_CTRL_1_CLK_PHASE_MSK, CLK_PHASE_0);\n\telse\n\t\tsys_ctrl_1 |= FIELD_PREP(SYS_CTRL_1_CLK_PHASE_MSK, CLK_PHASE_1_2);\n\n\tchipone_writeb(icn, SYS_CTRL(1), sys_ctrl_1);\n\n\t \n\tchipone_writeb(icn, MIPI_FORCE_0, 0x20);\n\tchipone_writeb(icn, PLL_CTRL(1), 0x20);\n\tchipone_writeb(icn, CONFIG_FINISH, 0x10);\n\n\tusleep_range(10000, 11000);\n}\n\nstatic void chipone_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t      struct drm_bridge_state *old_bridge_state)\n{\n\tstruct chipone *icn = bridge_to_chipone(bridge);\n\tint ret;\n\n\tif (icn->vdd1) {\n\t\tret = regulator_enable(icn->vdd1);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(icn->dev,\n\t\t\t\t      \"failed to enable VDD1 regulator: %d\\n\", ret);\n\t}\n\n\tif (icn->vdd2) {\n\t\tret = regulator_enable(icn->vdd2);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(icn->dev,\n\t\t\t\t      \"failed to enable VDD2 regulator: %d\\n\", ret);\n\t}\n\n\tif (icn->vdd3) {\n\t\tret = regulator_enable(icn->vdd3);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(icn->dev,\n\t\t\t\t      \"failed to enable VDD3 regulator: %d\\n\", ret);\n\t}\n\n\tret = clk_prepare_enable(icn->refclk);\n\tif (ret)\n\t\tDRM_DEV_ERROR(icn->dev,\n\t\t\t      \"failed to enable RECLK clock: %d\\n\", ret);\n\n\tgpiod_set_value(icn->enable_gpio, 1);\n\n\tusleep_range(10000, 11000);\n}\n\nstatic void chipone_atomic_post_disable(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct chipone *icn = bridge_to_chipone(bridge);\n\n\tclk_disable_unprepare(icn->refclk);\n\n\tif (icn->vdd1)\n\t\tregulator_disable(icn->vdd1);\n\n\tif (icn->vdd2)\n\t\tregulator_disable(icn->vdd2);\n\n\tif (icn->vdd3)\n\t\tregulator_disable(icn->vdd3);\n\n\tgpiod_set_value(icn->enable_gpio, 0);\n}\n\nstatic void chipone_mode_set(struct drm_bridge *bridge,\n\t\t\t     const struct drm_display_mode *mode,\n\t\t\t     const struct drm_display_mode *adjusted_mode)\n{\n\tstruct chipone *icn = bridge_to_chipone(bridge);\n\n\tdrm_mode_copy(&icn->mode, adjusted_mode);\n};\n\nstatic int chipone_dsi_attach(struct chipone *icn)\n{\n\tstruct mipi_dsi_device *dsi = icn->dsi;\n\tstruct device *dev = icn->dev;\n\tint dsi_lanes, ret;\n\n\tdsi_lanes = drm_of_get_data_lanes_count_ep(dev->of_node, 0, 0, 1, 4);\n\n\t \n\tif (dsi_lanes < 0)\n\t\ticn->dsi->lanes = 4;\n\telse\n\t\ticn->dsi->lanes = dsi_lanes;\n\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |\n\t\t\t  MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_NO_EOT_PACKET;\n\tdsi->hs_rate = 500000000;\n\tdsi->lp_rate = 16000000;\n\n\tret = mipi_dsi_attach(dsi);\n\tif (ret < 0)\n\t\tdev_err(icn->dev, \"failed to attach dsi\\n\");\n\n\treturn ret;\n}\n\nstatic int chipone_dsi_host_attach(struct chipone *icn)\n{\n\tstruct device *dev = icn->dev;\n\tstruct device_node *host_node;\n\tstruct device_node *endpoint;\n\tstruct mipi_dsi_device *dsi;\n\tstruct mipi_dsi_host *host;\n\tint ret = 0;\n\n\tconst struct mipi_dsi_device_info info = {\n\t\t.type = \"chipone\",\n\t\t.channel = 0,\n\t\t.node = NULL,\n\t};\n\n\tendpoint = of_graph_get_endpoint_by_regs(dev->of_node, 0, 0);\n\thost_node = of_graph_get_remote_port_parent(endpoint);\n\tof_node_put(endpoint);\n\n\tif (!host_node)\n\t\treturn -EINVAL;\n\n\thost = of_find_mipi_dsi_host_by_node(host_node);\n\tof_node_put(host_node);\n\tif (!host) {\n\t\tdev_err(dev, \"failed to find dsi host\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tdsi = mipi_dsi_device_register_full(host, &info);\n\tif (IS_ERR(dsi)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(dsi),\n\t\t\t\t     \"failed to create dsi device\\n\");\n\t}\n\n\ticn->dsi = dsi;\n\n\tret = chipone_dsi_attach(icn);\n\tif (ret < 0)\n\t\tmipi_dsi_device_unregister(dsi);\n\n\treturn ret;\n}\n\nstatic int chipone_attach(struct drm_bridge *bridge, enum drm_bridge_attach_flags flags)\n{\n\tstruct chipone *icn = bridge_to_chipone(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, icn->panel_bridge, bridge, flags);\n}\n\n#define MAX_INPUT_SEL_FORMATS\t1\n\nstatic u32 *\nchipone_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *bridge_state,\n\t\t\t\t  struct drm_crtc_state *crtc_state,\n\t\t\t\t  struct drm_connector_state *conn_state,\n\t\t\t\t  u32 output_fmt,\n\t\t\t\t  unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\t \n\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t*num_input_fmts = 1;\n\n\treturn input_fmts;\n}\n\nstatic const struct drm_bridge_funcs chipone_bridge_funcs = {\n\t.atomic_duplicate_state\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset\t\t= drm_atomic_helper_bridge_reset,\n\t.atomic_pre_enable\t= chipone_atomic_pre_enable,\n\t.atomic_enable\t\t= chipone_atomic_enable,\n\t.atomic_post_disable\t= chipone_atomic_post_disable,\n\t.mode_set\t\t= chipone_mode_set,\n\t.attach\t\t\t= chipone_attach,\n\t.atomic_get_input_bus_fmts = chipone_atomic_get_input_bus_fmts,\n};\n\nstatic int chipone_parse_dt(struct chipone *icn)\n{\n\tstruct device *dev = icn->dev;\n\tint ret;\n\n\ticn->refclk = devm_clk_get_optional(dev, \"refclk\");\n\tif (IS_ERR(icn->refclk)) {\n\t\tret = PTR_ERR(icn->refclk);\n\t\tDRM_DEV_ERROR(dev, \"failed to get REFCLK clock: %d\\n\", ret);\n\t\treturn ret;\n\t} else if (icn->refclk) {\n\t\ticn->refclk_rate = clk_get_rate(icn->refclk);\n\t\tif (icn->refclk_rate < 10000000 || icn->refclk_rate > 154000000) {\n\t\t\tDRM_DEV_ERROR(dev, \"REFCLK out of range: %ld Hz\\n\",\n\t\t\t\t      icn->refclk_rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ticn->vdd1 = devm_regulator_get_optional(dev, \"vdd1\");\n\tif (IS_ERR(icn->vdd1)) {\n\t\tret = PTR_ERR(icn->vdd1);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\ticn->vdd1 = NULL;\n\t\tDRM_DEV_DEBUG(dev, \"failed to get VDD1 regulator: %d\\n\", ret);\n\t}\n\n\ticn->vdd2 = devm_regulator_get_optional(dev, \"vdd2\");\n\tif (IS_ERR(icn->vdd2)) {\n\t\tret = PTR_ERR(icn->vdd2);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\ticn->vdd2 = NULL;\n\t\tDRM_DEV_DEBUG(dev, \"failed to get VDD2 regulator: %d\\n\", ret);\n\t}\n\n\ticn->vdd3 = devm_regulator_get_optional(dev, \"vdd3\");\n\tif (IS_ERR(icn->vdd3)) {\n\t\tret = PTR_ERR(icn->vdd3);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\ticn->vdd3 = NULL;\n\t\tDRM_DEV_DEBUG(dev, \"failed to get VDD3 regulator: %d\\n\", ret);\n\t}\n\n\ticn->enable_gpio = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(icn->enable_gpio)) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get enable GPIO\\n\");\n\t\treturn PTR_ERR(icn->enable_gpio);\n\t}\n\n\ticn->panel_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 1, 0);\n\tif (IS_ERR(icn->panel_bridge))\n\t\treturn PTR_ERR(icn->panel_bridge);\n\n\treturn 0;\n}\n\nstatic int chipone_common_probe(struct device *dev, struct chipone **icnr)\n{\n\tstruct chipone *icn;\n\tint ret;\n\n\ticn = devm_kzalloc(dev, sizeof(struct chipone), GFP_KERNEL);\n\tif (!icn)\n\t\treturn -ENOMEM;\n\n\ticn->dev = dev;\n\n\tret = chipone_parse_dt(icn);\n\tif (ret)\n\t\treturn ret;\n\n\ticn->bridge.funcs = &chipone_bridge_funcs;\n\ticn->bridge.type = DRM_MODE_CONNECTOR_DPI;\n\ticn->bridge.of_node = dev->of_node;\n\n\t*icnr = icn;\n\n\treturn ret;\n}\n\nstatic int chipone_dsi_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct device *dev = &dsi->dev;\n\tstruct chipone *icn;\n\tint ret;\n\n\tret = chipone_common_probe(dev, &icn);\n\tif (ret)\n\t\treturn ret;\n\n\ticn->regmap = devm_regmap_init(dev, &chipone_dsi_regmap_bus,\n\t\t\t\t       dsi, &chipone_regmap_config);\n\tif (IS_ERR(icn->regmap))\n\t\treturn PTR_ERR(icn->regmap);\n\n\ticn->interface_i2c = false;\n\ticn->dsi = dsi;\n\n\tmipi_dsi_set_drvdata(dsi, icn);\n\n\tdrm_bridge_add(&icn->bridge);\n\n\tret = chipone_dsi_attach(icn);\n\tif (ret)\n\t\tdrm_bridge_remove(&icn->bridge);\n\n\treturn ret;\n}\n\nstatic int chipone_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct chipone *icn;\n\tint ret;\n\n\tret = chipone_common_probe(dev, &icn);\n\tif (ret)\n\t\treturn ret;\n\n\ticn->regmap = devm_regmap_init_i2c(client, &chipone_regmap_config);\n\tif (IS_ERR(icn->regmap))\n\t\treturn PTR_ERR(icn->regmap);\n\n\ticn->interface_i2c = true;\n\ticn->client = client;\n\tdev_set_drvdata(dev, icn);\n\ti2c_set_clientdata(client, icn);\n\n\tdrm_bridge_add(&icn->bridge);\n\n\treturn chipone_dsi_host_attach(icn);\n}\n\nstatic void chipone_dsi_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct chipone *icn = mipi_dsi_get_drvdata(dsi);\n\n\tmipi_dsi_detach(dsi);\n\tdrm_bridge_remove(&icn->bridge);\n}\n\nstatic const struct of_device_id chipone_of_match[] = {\n\t{ .compatible = \"chipone,icn6211\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, chipone_of_match);\n\nstatic struct mipi_dsi_driver chipone_dsi_driver = {\n\t.probe = chipone_dsi_probe,\n\t.remove = chipone_dsi_remove,\n\t.driver = {\n\t\t.name = \"chipone-icn6211\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = chipone_of_match,\n\t},\n};\n\nstatic struct i2c_device_id chipone_i2c_id[] = {\n\t{ \"chipone,icn6211\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, chipone_i2c_id);\n\nstatic struct i2c_driver chipone_i2c_driver = {\n\t.probe = chipone_i2c_probe,\n\t.id_table = chipone_i2c_id,\n\t.driver = {\n\t\t.name = \"chipone-icn6211-i2c\",\n\t\t.of_match_table = chipone_of_match,\n\t},\n};\n\nstatic int __init chipone_init(void)\n{\n\tif (IS_ENABLED(CONFIG_DRM_MIPI_DSI))\n\t\tmipi_dsi_driver_register(&chipone_dsi_driver);\n\n\treturn i2c_add_driver(&chipone_i2c_driver);\n}\nmodule_init(chipone_init);\n\nstatic void __exit chipone_exit(void)\n{\n\ti2c_del_driver(&chipone_i2c_driver);\n\n\tif (IS_ENABLED(CONFIG_DRM_MIPI_DSI))\n\t\tmipi_dsi_driver_unregister(&chipone_dsi_driver);\n}\nmodule_exit(chipone_exit);\n\nMODULE_AUTHOR(\"Jagan Teki <jagan@amarulasolutions.com>\");\nMODULE_DESCRIPTION(\"Chipone ICN6211 MIPI-DSI to RGB Converter Bridge\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}