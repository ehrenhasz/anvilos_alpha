{
  "module_name": "tc358764.c",
  "hash_id": "43967c8c5e78a9e4a98959449ec4a49953951e8baf35af9f61b924be2f4b25be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/tc358764.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n\n#define FLD_MASK(start, end)    (((1 << ((start) - (end) + 1)) - 1) << (end))\n#define FLD_VAL(val, start, end) (((val) << (end)) & FLD_MASK(start, end))\n\n \n#define PPI_STARTPPI\t\t0x0104  \n#define PPI_LPTXTIMECNT\t\t0x0114  \n#define PPI_LANEENABLE\t\t0x0134  \n#define PPI_TX_RX_TA\t\t0x013C  \n#define PPI_D0S_CLRSIPOCOUNT\t0x0164  \n#define PPI_D1S_CLRSIPOCOUNT\t0x0168  \n#define PPI_D2S_CLRSIPOCOUNT\t0x016C  \n#define PPI_D3S_CLRSIPOCOUNT\t0x0170  \n#define PPI_START_FUNCTION\t1\n\n \n#define DSI_STARTDSI\t\t0x0204  \n#define DSI_LANEENABLE\t\t0x0210  \n#define DSI_RX_START\t\t1\n\n \n#define VP_CTRL\t\t\t0x0450  \n#define VP_CTRL_MSF\t\tBIT(0)  \n#define VP_CTRL_VTGEN\t\tBIT(4)  \n#define VP_CTRL_EVTMODE\t\tBIT(5)  \n#define VP_CTRL_RGB888\t\tBIT(8)  \n#define VP_CTRL_VSDELAY(v)\tFLD_VAL(v, 31, 20)  \n#define VP_CTRL_HSPOL\t\tBIT(17)  \n#define VP_CTRL_DEPOL\t\tBIT(18)  \n#define VP_CTRL_VSPOL\t\tBIT(19)  \n#define VP_HTIM1\t\t0x0454  \n#define VP_HTIM1_HBP(v)\t\tFLD_VAL(v, 24, 16)\n#define VP_HTIM1_HSYNC(v)\tFLD_VAL(v, 8, 0)\n#define VP_HTIM2\t\t0x0458  \n#define VP_HTIM2_HFP(v)\t\tFLD_VAL(v, 24, 16)\n#define VP_HTIM2_HACT(v)\tFLD_VAL(v, 10, 0)\n#define VP_VTIM1\t\t0x045C  \n#define VP_VTIM1_VBP(v)\t\tFLD_VAL(v, 23, 16)\n#define VP_VTIM1_VSYNC(v)\tFLD_VAL(v, 7, 0)\n#define VP_VTIM2\t\t0x0460  \n#define VP_VTIM2_VFP(v)\t\tFLD_VAL(v, 23, 16)\n#define VP_VTIM2_VACT(v)\tFLD_VAL(v, 10, 0)\n#define VP_VFUEN\t\t0x0464  \n\n \n#define LV_MX0003\t\t0x0480  \n#define LV_MX0407\t\t0x0484  \n#define LV_MX0811\t\t0x0488  \n#define LV_MX1215\t\t0x048C  \n#define LV_MX1619\t\t0x0490  \n#define LV_MX2023\t\t0x0494  \n#define LV_MX2427\t\t0x0498  \n#define LV_MX(b0, b1, b2, b3)\t(FLD_VAL(b0, 4, 0) | FLD_VAL(b1, 12, 8) | \\\n\t\t\t\tFLD_VAL(b2, 20, 16) | FLD_VAL(b3, 28, 24))\n\n \nenum {\n\tLVI_R0,\n\tLVI_R1,\n\tLVI_R2,\n\tLVI_R3,\n\tLVI_R4,\n\tLVI_R5,\n\tLVI_R6,\n\tLVI_R7,\n\tLVI_G0,\n\tLVI_G1,\n\tLVI_G2,\n\tLVI_G3,\n\tLVI_G4,\n\tLVI_G5,\n\tLVI_G6,\n\tLVI_G7,\n\tLVI_B0,\n\tLVI_B1,\n\tLVI_B2,\n\tLVI_B3,\n\tLVI_B4,\n\tLVI_B5,\n\tLVI_B6,\n\tLVI_B7,\n\tLVI_HS,\n\tLVI_VS,\n\tLVI_DE,\n\tLVI_L0\n};\n\n#define LV_CFG\t\t\t0x049C  \n#define LV_PHY0\t\t\t0x04A0  \n#define LV_PHY0_RST(v)\t\tFLD_VAL(v, 22, 22)  \n#define LV_PHY0_IS(v)\t\tFLD_VAL(v, 15, 14)\n#define LV_PHY0_ND(v)\t\tFLD_VAL(v, 4, 0)  \n#define LV_PHY0_PRBS_ON(v)\tFLD_VAL(v, 20, 16)  \n\n \n#define SYS_RST\t\t\t0x0504  \n#define SYS_ID\t\t\t0x0580  \n\n#define SYS_RST_I2CS\t\tBIT(0)  \n#define SYS_RST_I2CM\t\tBIT(1)  \n#define SYS_RST_LCD\t\tBIT(2)  \n#define SYS_RST_BM\t\tBIT(3)  \n#define SYS_RST_DSIRX\t\tBIT(4)  \n#define SYS_RST_REG\t\tBIT(5)  \n\n#define LPX_PERIOD\t\t2\n#define TTA_SURE\t\t3\n#define TTA_GET\t\t\t0x20000\n\n \n#define LANEENABLE_CLEN\t\tBIT(0)\n#define LANEENABLE_L0EN\t\tBIT(1)\n#define LANEENABLE_L1EN\t\tBIT(2)\n#define LANEENABLE_L2EN\t\tBIT(3)\n#define LANEENABLE_L3EN\t\tBIT(4)\n\n \n#define LV_CFG_LVEN\t\tBIT(0)\n#define LV_CFG_LVDLINK\t\tBIT(1)\n#define LV_CFG_CLKPOL1\t\tBIT(2)\n#define LV_CFG_CLKPOL2\t\tBIT(3)\n\nstatic const char * const tc358764_supplies[] = {\n\t\"vddc\", \"vddio\", \"vddlvds\"\n};\n\nstruct tc358764 {\n\tstruct device *dev;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(tc358764_supplies)];\n\tstruct gpio_desc *gpio_reset;\n\tint error;\n};\n\nstatic int tc358764_clear_error(struct tc358764 *ctx)\n{\n\tint ret = ctx->error;\n\n\tctx->error = 0;\n\treturn ret;\n}\n\nstatic void tc358764_read(struct tc358764 *ctx, u16 addr, u32 *val)\n{\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\n\tssize_t ret;\n\n\tif (ctx->error)\n\t\treturn;\n\n\tcpu_to_le16s(&addr);\n\tret = mipi_dsi_generic_read(dsi, &addr, sizeof(addr), val, sizeof(*val));\n\tif (ret >= 0)\n\t\tle32_to_cpus(val);\n\n\tdev_dbg(ctx->dev, \"read: addr=0x%04x data=0x%08x\\n\", addr, *val);\n}\n\nstatic void tc358764_write(struct tc358764 *ctx, u16 addr, u32 val)\n{\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\n\tssize_t ret;\n\tu8 data[6];\n\n\tif (ctx->error)\n\t\treturn;\n\n\tdata[0] = addr;\n\tdata[1] = addr >> 8;\n\tdata[2] = val;\n\tdata[3] = val >> 8;\n\tdata[4] = val >> 16;\n\tdata[5] = val >> 24;\n\n\tret = mipi_dsi_generic_write(dsi, data, sizeof(data));\n\tif (ret < 0)\n\t\tctx->error = ret;\n}\n\nstatic inline struct tc358764 *bridge_to_tc358764(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct tc358764, bridge);\n}\n\nstatic int tc358764_init(struct tc358764 *ctx)\n{\n\tu32 v = 0;\n\n\ttc358764_read(ctx, SYS_ID, &v);\n\tif (ctx->error)\n\t\treturn tc358764_clear_error(ctx);\n\tdev_info(ctx->dev, \"ID: %#x\\n\", v);\n\n\t \n\ttc358764_write(ctx, PPI_TX_RX_TA, TTA_GET | TTA_SURE);\n\ttc358764_write(ctx, PPI_LPTXTIMECNT, LPX_PERIOD);\n\ttc358764_write(ctx, PPI_D0S_CLRSIPOCOUNT, 5);\n\ttc358764_write(ctx, PPI_D1S_CLRSIPOCOUNT, 5);\n\ttc358764_write(ctx, PPI_D2S_CLRSIPOCOUNT, 5);\n\ttc358764_write(ctx, PPI_D3S_CLRSIPOCOUNT, 5);\n\n\t \n\ttc358764_write(ctx, PPI_LANEENABLE, LANEENABLE_L3EN | LANEENABLE_L2EN |\n\t\t       LANEENABLE_L1EN | LANEENABLE_L0EN | LANEENABLE_CLEN);\n\ttc358764_write(ctx, DSI_LANEENABLE, LANEENABLE_L3EN | LANEENABLE_L2EN |\n\t\t       LANEENABLE_L1EN | LANEENABLE_L0EN | LANEENABLE_CLEN);\n\n\t \n\ttc358764_write(ctx, PPI_STARTPPI, PPI_START_FUNCTION);\n\ttc358764_write(ctx, DSI_STARTDSI, DSI_RX_START);\n\n\t \n\ttc358764_write(ctx, VP_CTRL, VP_CTRL_VSDELAY(15) | VP_CTRL_RGB888 |\n\t\t       VP_CTRL_EVTMODE | VP_CTRL_HSPOL | VP_CTRL_VSPOL);\n\n\t \n\ttc358764_write(ctx, LV_PHY0, LV_PHY0_RST(1) |\n\t\t       LV_PHY0_PRBS_ON(4) | LV_PHY0_IS(2) | LV_PHY0_ND(6));\n\ttc358764_write(ctx, LV_PHY0, LV_PHY0_PRBS_ON(4) | LV_PHY0_IS(2) |\n\t\t       LV_PHY0_ND(6));\n\n\t \n\ttc358764_write(ctx, SYS_RST, SYS_RST_LCD);\n\n\t \n\ttc358764_write(ctx, LV_MX0003, LV_MX(LVI_R0, LVI_R1, LVI_R2, LVI_R3));\n\ttc358764_write(ctx, LV_MX0407, LV_MX(LVI_R4, LVI_R7, LVI_R5, LVI_G0));\n\ttc358764_write(ctx, LV_MX0811, LV_MX(LVI_G1, LVI_G2, LVI_G6, LVI_G7));\n\ttc358764_write(ctx, LV_MX1215, LV_MX(LVI_G3, LVI_G4, LVI_G5, LVI_B0));\n\ttc358764_write(ctx, LV_MX1619, LV_MX(LVI_B6, LVI_B7, LVI_B1, LVI_B2));\n\ttc358764_write(ctx, LV_MX2023, LV_MX(LVI_B3, LVI_B4, LVI_B5, LVI_L0));\n\ttc358764_write(ctx, LV_MX2427, LV_MX(LVI_HS, LVI_VS, LVI_DE, LVI_R6));\n\ttc358764_write(ctx, LV_CFG, LV_CFG_CLKPOL2 | LV_CFG_CLKPOL1 |\n\t\t       LV_CFG_LVEN);\n\n\treturn tc358764_clear_error(ctx);\n}\n\nstatic void tc358764_reset(struct tc358764 *ctx)\n{\n\tgpiod_set_value(ctx->gpio_reset, 1);\n\tusleep_range(1000, 2000);\n\tgpiod_set_value(ctx->gpio_reset, 0);\n\tusleep_range(1000, 2000);\n}\n\nstatic void tc358764_post_disable(struct drm_bridge *bridge)\n{\n\tstruct tc358764 *ctx = bridge_to_tc358764(bridge);\n\tint ret;\n\n\ttc358764_reset(ctx);\n\tusleep_range(10000, 15000);\n\tret = regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n\tif (ret < 0)\n\t\tdev_err(ctx->dev, \"error disabling regulators (%d)\\n\", ret);\n}\n\nstatic void tc358764_pre_enable(struct drm_bridge *bridge)\n{\n\tstruct tc358764 *ctx = bridge_to_tc358764(bridge);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n\tif (ret < 0)\n\t\tdev_err(ctx->dev, \"error enabling regulators (%d)\\n\", ret);\n\tusleep_range(10000, 15000);\n\ttc358764_reset(ctx);\n\tret = tc358764_init(ctx);\n\tif (ret < 0)\n\t\tdev_err(ctx->dev, \"error initializing bridge (%d)\\n\", ret);\n}\n\nstatic int tc358764_attach(struct drm_bridge *bridge,\n\t\t\t   enum drm_bridge_attach_flags flags)\n{\n\tstruct tc358764 *ctx = bridge_to_tc358764(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, ctx->next_bridge, bridge, flags);\n}\n\nstatic const struct drm_bridge_funcs tc358764_bridge_funcs = {\n\t.post_disable = tc358764_post_disable,\n\t.pre_enable = tc358764_pre_enable,\n\t.attach = tc358764_attach,\n};\n\nstatic int tc358764_parse_dt(struct tc358764 *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\n\tctx->gpio_reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->gpio_reset)) {\n\t\tdev_err(dev, \"no reset GPIO pin provided\\n\");\n\t\treturn PTR_ERR(ctx->gpio_reset);\n\t}\n\n\tctx->next_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 1, 0);\n\tif (IS_ERR(ctx->next_bridge))\n\t\treturn PTR_ERR(ctx->next_bridge);\n\n\treturn 0;\n}\n\nstatic int tc358764_configure_regulators(struct tc358764 *ctx)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctx->supplies); ++i)\n\t\tctx->supplies[i].supply = tc358764_supplies[i];\n\n\tret = devm_regulator_bulk_get(ctx->dev, ARRAY_SIZE(ctx->supplies),\n\t\t\t\t      ctx->supplies);\n\tif (ret < 0)\n\t\tdev_err(ctx->dev, \"failed to get regulators: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int tc358764_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct device *dev = &dsi->dev;\n\tstruct tc358764 *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(struct tc358764), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tmipi_dsi_set_drvdata(dsi, ctx);\n\n\tctx->dev = dev;\n\n\tdsi->lanes = 4;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST\n\t\t| MIPI_DSI_MODE_VIDEO_AUTO_VERT | MIPI_DSI_MODE_LPM;\n\n\tret = tc358764_parse_dt(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tc358764_configure_regulators(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctx->bridge.funcs = &tc358764_bridge_funcs;\n\tctx->bridge.of_node = dev->of_node;\n\tctx->bridge.pre_enable_prev_first = true;\n\n\tdrm_bridge_add(&ctx->bridge);\n\n\tret = mipi_dsi_attach(dsi);\n\tif (ret < 0) {\n\t\tdrm_bridge_remove(&ctx->bridge);\n\t\tdev_err(dev, \"failed to attach dsi\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic void tc358764_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct tc358764 *ctx = mipi_dsi_get_drvdata(dsi);\n\n\tmipi_dsi_detach(dsi);\n\tdrm_bridge_remove(&ctx->bridge);\n}\n\nstatic const struct of_device_id tc358764_of_match[] = {\n\t{ .compatible = \"toshiba,tc358764\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tc358764_of_match);\n\nstatic struct mipi_dsi_driver tc358764_driver = {\n\t.probe = tc358764_probe,\n\t.remove = tc358764_remove,\n\t.driver = {\n\t\t.name = \"tc358764\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = tc358764_of_match,\n\t},\n};\nmodule_mipi_dsi_driver(tc358764_driver);\n\nMODULE_AUTHOR(\"Andrzej Hajda <a.hajda@samsung.com>\");\nMODULE_AUTHOR(\"Maciej Purski <m.purski@samsung.com>\");\nMODULE_DESCRIPTION(\"MIPI-DSI based Driver for TC358764 DSI/LVDS Bridge\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}