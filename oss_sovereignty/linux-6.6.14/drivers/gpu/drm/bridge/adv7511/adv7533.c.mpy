{
  "module_name": "adv7533.c",
  "hash_id": "d3b24f7667a7c32d08cbc939fea33253d342cc0703816c1617bd6f63613250a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/adv7511/adv7533.c",
  "human_readable_source": "\n \n\n#include <linux/of_graph.h>\n\n#include \"adv7511.h\"\n\nstatic const struct reg_sequence adv7533_fixed_registers[] = {\n\t{ 0x16, 0x20 },\n\t{ 0x9a, 0xe0 },\n\t{ 0xba, 0x70 },\n\t{ 0xde, 0x82 },\n\t{ 0xe4, 0x40 },\n\t{ 0xe5, 0x80 },\n};\n\nstatic const struct reg_sequence adv7533_cec_fixed_registers[] = {\n\t{ 0x15, 0xd0 },\n\t{ 0x17, 0xd0 },\n\t{ 0x24, 0x20 },\n\t{ 0x57, 0x11 },\n\t{ 0x05, 0xc8 },\n};\n\nstatic void adv7511_dsi_config_timing_gen(struct adv7511 *adv)\n{\n\tstruct mipi_dsi_device *dsi = adv->dsi;\n\tstruct drm_display_mode *mode = &adv->curr_mode;\n\tunsigned int hsw, hfp, hbp, vsw, vfp, vbp;\n\tstatic const u8 clock_div_by_lanes[] = { 6, 4, 3 };\t \n\n\thsw = mode->hsync_end - mode->hsync_start;\n\thfp = mode->hsync_start - mode->hdisplay;\n\thbp = mode->htotal - mode->hsync_end;\n\tvsw = mode->vsync_end - mode->vsync_start;\n\tvfp = mode->vsync_start - mode->vdisplay;\n\tvbp = mode->vtotal - mode->vsync_end;\n\n\t \n\tregmap_write(adv->regmap_cec, 0x16,\n\t\t     clock_div_by_lanes[dsi->lanes - 2] << 3);\n\n\t \n\tregmap_write(adv->regmap_cec, 0x28, mode->htotal >> 4);\n\tregmap_write(adv->regmap_cec, 0x29, (mode->htotal << 4) & 0xff);\n\tregmap_write(adv->regmap_cec, 0x2a, hsw >> 4);\n\tregmap_write(adv->regmap_cec, 0x2b, (hsw << 4) & 0xff);\n\tregmap_write(adv->regmap_cec, 0x2c, hfp >> 4);\n\tregmap_write(adv->regmap_cec, 0x2d, (hfp << 4) & 0xff);\n\tregmap_write(adv->regmap_cec, 0x2e, hbp >> 4);\n\tregmap_write(adv->regmap_cec, 0x2f, (hbp << 4) & 0xff);\n\n\t \n\tregmap_write(adv->regmap_cec, 0x30, mode->vtotal >> 4);\n\tregmap_write(adv->regmap_cec, 0x31, (mode->vtotal << 4) & 0xff);\n\tregmap_write(adv->regmap_cec, 0x32, vsw >> 4);\n\tregmap_write(adv->regmap_cec, 0x33, (vsw << 4) & 0xff);\n\tregmap_write(adv->regmap_cec, 0x34, vfp >> 4);\n\tregmap_write(adv->regmap_cec, 0x35, (vfp << 4) & 0xff);\n\tregmap_write(adv->regmap_cec, 0x36, vbp >> 4);\n\tregmap_write(adv->regmap_cec, 0x37, (vbp << 4) & 0xff);\n}\n\nvoid adv7533_dsi_power_on(struct adv7511 *adv)\n{\n\tstruct mipi_dsi_device *dsi = adv->dsi;\n\n\tif (adv->use_timing_gen)\n\t\tadv7511_dsi_config_timing_gen(adv);\n\n\t \n\tregmap_write(adv->regmap_cec, 0x1c, dsi->lanes << 4);\n\n\tif (adv->use_timing_gen) {\n\t\t \n\t\tregmap_write(adv->regmap_cec, 0x27, 0xcb);\n\t\tregmap_write(adv->regmap_cec, 0x27, 0x8b);\n\t\tregmap_write(adv->regmap_cec, 0x27, 0xcb);\n\t} else {\n\t\t \n\t\tregmap_write(adv->regmap_cec, 0x27, 0x0b);\n\t}\n\n\t \n\tregmap_write(adv->regmap_cec, 0x03, 0x89);\n\t \n\tregmap_write(adv->regmap_cec, 0x55, 0x00);\n\n\tregmap_register_patch(adv->regmap_cec, adv7533_cec_fixed_registers,\n\t\t\t      ARRAY_SIZE(adv7533_cec_fixed_registers));\n}\n\nvoid adv7533_dsi_power_off(struct adv7511 *adv)\n{\n\t \n\tregmap_write(adv->regmap_cec, 0x03, 0x0b);\n\t \n\tregmap_write(adv->regmap_cec, 0x27, 0x0b);\n}\n\nenum drm_mode_status adv7533_mode_valid(struct adv7511 *adv,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tunsigned long max_lane_freq;\n\tstruct mipi_dsi_device *dsi = adv->dsi;\n\tu8 bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);\n\n\t \n\tif (mode->clock > (adv->type == ADV7533 ? 80000 : 148500))\n\t\treturn MODE_CLOCK_HIGH;\n\n\t \n\tmax_lane_freq = (adv->type == ADV7533 ? 800000 : 891000);\n\n\tif (mode->clock * bpp > max_lane_freq * adv->num_dsi_lanes)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nint adv7533_patch_registers(struct adv7511 *adv)\n{\n\treturn regmap_register_patch(adv->regmap,\n\t\t\t\t     adv7533_fixed_registers,\n\t\t\t\t     ARRAY_SIZE(adv7533_fixed_registers));\n}\n\nint adv7533_patch_cec_registers(struct adv7511 *adv)\n{\n\treturn regmap_register_patch(adv->regmap_cec,\n\t\t\t\t    adv7533_cec_fixed_registers,\n\t\t\t\t    ARRAY_SIZE(adv7533_cec_fixed_registers));\n}\n\nint adv7533_attach_dsi(struct adv7511 *adv)\n{\n\tstruct device *dev = &adv->i2c_main->dev;\n\tstruct mipi_dsi_host *host;\n\tstruct mipi_dsi_device *dsi;\n\tint ret = 0;\n\tconst struct mipi_dsi_device_info info = { .type = \"adv7533\",\n\t\t\t\t\t\t   .channel = 0,\n\t\t\t\t\t\t   .node = NULL,\n\t\t\t\t\t\t };\n\n\thost = of_find_mipi_dsi_host_by_node(adv->host_node);\n\tif (!host)\n\t\treturn dev_err_probe(dev, -EPROBE_DEFER,\n\t\t\t\t     \"failed to find dsi host\\n\");\n\n\tdsi = devm_mipi_dsi_device_register_full(dev, host, &info);\n\tif (IS_ERR(dsi))\n\t\treturn dev_err_probe(dev, PTR_ERR(dsi),\n\t\t\t\t     \"failed to create dsi device\\n\");\n\n\tadv->dsi = dsi;\n\n\tdsi->lanes = adv->num_dsi_lanes;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |\n\t\t\t  MIPI_DSI_MODE_NO_EOT_PACKET | MIPI_DSI_MODE_VIDEO_HSE;\n\n\tret = devm_mipi_dsi_attach(dev, dsi);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"failed to attach dsi to host\\n\");\n\n\treturn 0;\n}\n\nint adv7533_parse_dt(struct device_node *np, struct adv7511 *adv)\n{\n\tu32 num_lanes;\n\n\tof_property_read_u32(np, \"adi,dsi-lanes\", &num_lanes);\n\n\tif (num_lanes < 1 || num_lanes > 4)\n\t\treturn -EINVAL;\n\n\tadv->num_dsi_lanes = num_lanes;\n\n\tadv->host_node = of_graph_get_remote_node(np, 0, 0);\n\tif (!adv->host_node)\n\t\treturn -ENODEV;\n\n\tof_node_put(adv->host_node);\n\n\tadv->use_timing_gen = !of_property_read_bool(np,\n\t\t\t\t\t\t\"adi,disable-timing-generator\");\n\n\t \n\tadv->rgb = true;\n\tadv->embedded_sync = false;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}