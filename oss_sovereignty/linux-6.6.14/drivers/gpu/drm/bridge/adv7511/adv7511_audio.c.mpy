{
  "module_name": "adv7511_audio.c",
  "hash_id": "9f1862f99cf8e6aea483746d28ede39452c66efb2c235a3047b748355e28c154",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/adv7511/adv7511_audio.c",
  "human_readable_source": "\n \n\n#include <sound/core.h>\n#include <sound/hdmi-codec.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <linux/of_graph.h>\n\n#include \"adv7511.h\"\n\nstatic void adv7511_calc_cts_n(unsigned int f_tmds, unsigned int fs,\n\t\t\t       unsigned int *cts, unsigned int *n)\n{\n\tswitch (fs) {\n\tcase 32000:\n\tcase 48000:\n\tcase 96000:\n\tcase 192000:\n\t\t*n = fs * 128 / 1000;\n\t\tbreak;\n\tcase 44100:\n\tcase 88200:\n\tcase 176400:\n\t\t*n = fs * 128 / 900;\n\t\tbreak;\n\t}\n\n\t*cts = ((f_tmds * *n) / (128 * fs)) * 1000;\n}\n\nstatic int adv7511_update_cts_n(struct adv7511 *adv7511)\n{\n\tunsigned int cts = 0;\n\tunsigned int n = 0;\n\n\tadv7511_calc_cts_n(adv7511->f_tmds, adv7511->f_audio, &cts, &n);\n\n\tregmap_write(adv7511->regmap, ADV7511_REG_N0, (n >> 16) & 0xf);\n\tregmap_write(adv7511->regmap, ADV7511_REG_N1, (n >> 8) & 0xff);\n\tregmap_write(adv7511->regmap, ADV7511_REG_N2, n & 0xff);\n\n\tregmap_write(adv7511->regmap, ADV7511_REG_CTS_MANUAL0,\n\t\t     (cts >> 16) & 0xf);\n\tregmap_write(adv7511->regmap, ADV7511_REG_CTS_MANUAL1,\n\t\t     (cts >> 8) & 0xff);\n\tregmap_write(adv7511->regmap, ADV7511_REG_CTS_MANUAL2,\n\t\t     cts & 0xff);\n\n\treturn 0;\n}\n\nstatic int adv7511_hdmi_hw_params(struct device *dev, void *data,\n\t\t\t\t  struct hdmi_codec_daifmt *fmt,\n\t\t\t\t  struct hdmi_codec_params *hparms)\n{\n\tstruct adv7511 *adv7511 = dev_get_drvdata(dev);\n\tunsigned int audio_source, i2s_format = 0;\n\tunsigned int invert_clock;\n\tunsigned int rate;\n\tunsigned int len;\n\n\tswitch (hparms->sample_rate) {\n\tcase 32000:\n\t\trate = ADV7511_SAMPLE_FREQ_32000;\n\t\tbreak;\n\tcase 44100:\n\t\trate = ADV7511_SAMPLE_FREQ_44100;\n\t\tbreak;\n\tcase 48000:\n\t\trate = ADV7511_SAMPLE_FREQ_48000;\n\t\tbreak;\n\tcase 88200:\n\t\trate = ADV7511_SAMPLE_FREQ_88200;\n\t\tbreak;\n\tcase 96000:\n\t\trate = ADV7511_SAMPLE_FREQ_96000;\n\t\tbreak;\n\tcase 176400:\n\t\trate = ADV7511_SAMPLE_FREQ_176400;\n\t\tbreak;\n\tcase 192000:\n\t\trate = ADV7511_SAMPLE_FREQ_192000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (hparms->sample_width) {\n\tcase 16:\n\t\tlen = ADV7511_I2S_SAMPLE_LEN_16;\n\t\tbreak;\n\tcase 18:\n\t\tlen = ADV7511_I2S_SAMPLE_LEN_18;\n\t\tbreak;\n\tcase 20:\n\t\tlen = ADV7511_I2S_SAMPLE_LEN_20;\n\t\tbreak;\n\tcase 32:\n\t\tif (fmt->bit_fmt != SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE)\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tcase 24:\n\t\tlen = ADV7511_I2S_SAMPLE_LEN_24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt->fmt) {\n\tcase HDMI_I2S:\n\t\taudio_source = ADV7511_AUDIO_SOURCE_I2S;\n\t\ti2s_format = ADV7511_I2S_FORMAT_I2S;\n\t\tif (fmt->bit_fmt == SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE)\n\t\t\ti2s_format = ADV7511_I2S_IEC958_DIRECT;\n\t\tbreak;\n\tcase HDMI_RIGHT_J:\n\t\taudio_source = ADV7511_AUDIO_SOURCE_I2S;\n\t\ti2s_format = ADV7511_I2S_FORMAT_RIGHT_J;\n\t\tbreak;\n\tcase HDMI_LEFT_J:\n\t\taudio_source = ADV7511_AUDIO_SOURCE_I2S;\n\t\ti2s_format = ADV7511_I2S_FORMAT_LEFT_J;\n\t\tbreak;\n\tcase HDMI_SPDIF:\n\t\taudio_source = ADV7511_AUDIO_SOURCE_SPDIF;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tinvert_clock = fmt->bit_clk_inv;\n\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_SOURCE, 0x70,\n\t\t\t   audio_source << 4);\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CONFIG, BIT(6),\n\t\t\t   invert_clock << 6);\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_I2S_CONFIG, 0x03,\n\t\t\t   i2s_format);\n\n\tadv7511->audio_source = audio_source;\n\n\tadv7511->f_audio = hparms->sample_rate;\n\n\tadv7511_update_cts_n(adv7511);\n\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CFG3,\n\t\t\t   ADV7511_AUDIO_CFG3_LEN_MASK, len);\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_I2C_FREQ_ID_CFG,\n\t\t\t   ADV7511_I2C_FREQ_ID_CFG_RATE_MASK, rate << 4);\n\tregmap_write(adv7511->regmap, 0x73, 0x1);\n\n\treturn 0;\n}\n\nstatic int audio_startup(struct device *dev, void *data)\n{\n\tstruct adv7511 *adv7511 = dev_get_drvdata(dev);\n\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CONFIG,\n\t\t\t\tBIT(7), 0);\n\n\t \n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_INFOFRAME_UPDATE,\n\t\t\t\tBIT(5), BIT(5));\n\t \n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,\n\t\t\t\tBIT(5), BIT(5));\n\t \n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,\n\t\t\t\tBIT(6), BIT(6));\n\t \n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CFG1,\n\t\t\t\tBIT(5), BIT(5));\n\t \n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,\n\t\t\t\tBIT(3), BIT(3));\n\t \n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_GC(0),\n\t\t\t\tBIT(7) | BIT(6), BIT(7));\n\t \n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_GC(1),\n\t\t\t\tBIT(5), 0);\n\t \n\tif (adv7511->audio_source == ADV7511_AUDIO_SOURCE_SPDIF)\n\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CONFIG,\n\t\t\t\t   BIT(7), BIT(7));\n\n\treturn 0;\n}\n\nstatic void audio_shutdown(struct device *dev, void *data)\n{\n\tstruct adv7511 *adv7511 = dev_get_drvdata(dev);\n\n\tif (adv7511->audio_source == ADV7511_AUDIO_SOURCE_SPDIF)\n\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CONFIG,\n\t\t\t\t   BIT(7), 0);\n}\n\nstatic int adv7511_hdmi_i2s_get_dai_id(struct snd_soc_component *component,\n\t\t\t\t\tstruct device_node *endpoint)\n{\n\tstruct of_endpoint of_ep;\n\tint ret;\n\n\tret = of_graph_parse_endpoint(endpoint, &of_ep);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (of_ep.port == 2)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic const struct hdmi_codec_ops adv7511_codec_ops = {\n\t.hw_params\t= adv7511_hdmi_hw_params,\n\t.audio_shutdown = audio_shutdown,\n\t.audio_startup\t= audio_startup,\n\t.get_dai_id\t= adv7511_hdmi_i2s_get_dai_id,\n};\n\nstatic const struct hdmi_codec_pdata codec_data = {\n\t.ops = &adv7511_codec_ops,\n\t.max_i2s_channels = 2,\n\t.i2s = 1,\n\t.spdif = 1,\n};\n\nint adv7511_audio_init(struct device *dev, struct adv7511 *adv7511)\n{\n\tadv7511->audio_pdev = platform_device_register_data(dev,\n\t\t\t\t\tHDMI_CODEC_DRV_NAME,\n\t\t\t\t\tPLATFORM_DEVID_AUTO,\n\t\t\t\t\t&codec_data,\n\t\t\t\t\tsizeof(codec_data));\n\treturn PTR_ERR_OR_ZERO(adv7511->audio_pdev);\n}\n\nvoid adv7511_audio_exit(struct adv7511 *adv7511)\n{\n\tif (adv7511->audio_pdev) {\n\t\tplatform_device_unregister(adv7511->audio_pdev);\n\t\tadv7511->audio_pdev = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}