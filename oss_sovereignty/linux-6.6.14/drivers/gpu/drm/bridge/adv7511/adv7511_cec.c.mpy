{
  "module_name": "adv7511_cec.c",
  "hash_id": "096e844af1f801808df95dd06c417365a4d359bf0f14140fbd165112f847e3c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/adv7511/adv7511_cec.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n\n#include <media/cec.h>\n\n#include \"adv7511.h\"\n\nstatic const u8 ADV7511_REG_CEC_RX_FRAME_HDR[] = {\n\tADV7511_REG_CEC_RX1_FRAME_HDR,\n\tADV7511_REG_CEC_RX2_FRAME_HDR,\n\tADV7511_REG_CEC_RX3_FRAME_HDR,\n};\n\nstatic const u8 ADV7511_REG_CEC_RX_FRAME_LEN[] = {\n\tADV7511_REG_CEC_RX1_FRAME_LEN,\n\tADV7511_REG_CEC_RX2_FRAME_LEN,\n\tADV7511_REG_CEC_RX3_FRAME_LEN,\n};\n\n#define ADV7511_INT1_CEC_MASK \\\n\t(ADV7511_INT1_CEC_TX_READY | ADV7511_INT1_CEC_TX_ARBIT_LOST | \\\n\t ADV7511_INT1_CEC_TX_RETRY_TIMEOUT | ADV7511_INT1_CEC_RX_READY1 | \\\n\t ADV7511_INT1_CEC_RX_READY2 | ADV7511_INT1_CEC_RX_READY3)\n\nstatic void adv_cec_tx_raw_status(struct adv7511 *adv7511, u8 tx_raw_status)\n{\n\tunsigned int offset = adv7511->reg_cec_offset;\n\tunsigned int val;\n\n\tif (regmap_read(adv7511->regmap_cec,\n\t\t\tADV7511_REG_CEC_TX_ENABLE + offset, &val))\n\t\treturn;\n\n\tif ((val & 0x01) == 0)\n\t\treturn;\n\n\tif (tx_raw_status & ADV7511_INT1_CEC_TX_ARBIT_LOST) {\n\t\tcec_transmit_attempt_done(adv7511->cec_adap,\n\t\t\t\t\t  CEC_TX_STATUS_ARB_LOST);\n\t\treturn;\n\t}\n\tif (tx_raw_status & ADV7511_INT1_CEC_TX_RETRY_TIMEOUT) {\n\t\tu8 status;\n\t\tu8 err_cnt = 0;\n\t\tu8 nack_cnt = 0;\n\t\tu8 low_drive_cnt = 0;\n\t\tunsigned int cnt;\n\n\t\t \n\t\tstatus = CEC_TX_STATUS_MAX_RETRIES;\n\t\tif (regmap_read(adv7511->regmap_cec,\n\t\t\t    ADV7511_REG_CEC_TX_LOW_DRV_CNT + offset, &cnt)) {\n\t\t\terr_cnt = 1;\n\t\t\tstatus |= CEC_TX_STATUS_ERROR;\n\t\t} else {\n\t\t\tnack_cnt = cnt & 0xf;\n\t\t\tif (nack_cnt)\n\t\t\t\tstatus |= CEC_TX_STATUS_NACK;\n\t\t\tlow_drive_cnt = cnt >> 4;\n\t\t\tif (low_drive_cnt)\n\t\t\t\tstatus |= CEC_TX_STATUS_LOW_DRIVE;\n\t\t}\n\t\tcec_transmit_done(adv7511->cec_adap, status,\n\t\t\t\t  0, nack_cnt, low_drive_cnt, err_cnt);\n\t\treturn;\n\t}\n\tif (tx_raw_status & ADV7511_INT1_CEC_TX_READY) {\n\t\tcec_transmit_attempt_done(adv7511->cec_adap, CEC_TX_STATUS_OK);\n\t\treturn;\n\t}\n}\n\nstatic void adv7511_cec_rx(struct adv7511 *adv7511, int rx_buf)\n{\n\tunsigned int offset = adv7511->reg_cec_offset;\n\tstruct cec_msg msg = {};\n\tunsigned int len;\n\tunsigned int val;\n\tu8 i;\n\n\tif (regmap_read(adv7511->regmap_cec,\n\t\t\tADV7511_REG_CEC_RX_FRAME_LEN[rx_buf] + offset, &len))\n\t\treturn;\n\n\tmsg.len = len & 0x1f;\n\n\tif (msg.len > 16)\n\t\tmsg.len = 16;\n\n\tif (!msg.len)\n\t\treturn;\n\n\tfor (i = 0; i < msg.len; i++) {\n\t\tregmap_read(adv7511->regmap_cec,\n\t\t\t    i + ADV7511_REG_CEC_RX_FRAME_HDR[rx_buf] + offset,\n\t\t\t    &val);\n\t\tmsg.msg[i] = val;\n\t}\n\n\t \n\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t   ADV7511_REG_CEC_RX_BUFFERS + offset, BIT(rx_buf),\n\t\t\t   BIT(rx_buf));\n\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t   ADV7511_REG_CEC_RX_BUFFERS + offset, BIT(rx_buf), 0);\n\n\tcec_received_msg(adv7511->cec_adap, &msg);\n}\n\nvoid adv7511_cec_irq_process(struct adv7511 *adv7511, unsigned int irq1)\n{\n\tunsigned int offset = adv7511->reg_cec_offset;\n\tconst u32 irq_tx_mask = ADV7511_INT1_CEC_TX_READY |\n\t\t\t\tADV7511_INT1_CEC_TX_ARBIT_LOST |\n\t\t\t\tADV7511_INT1_CEC_TX_RETRY_TIMEOUT;\n\tconst u32 irq_rx_mask = ADV7511_INT1_CEC_RX_READY1 |\n\t\t\t\tADV7511_INT1_CEC_RX_READY2 |\n\t\t\t\tADV7511_INT1_CEC_RX_READY3;\n\tunsigned int rx_status;\n\tint rx_order[3] = { -1, -1, -1 };\n\tint i;\n\n\tif (irq1 & irq_tx_mask)\n\t\tadv_cec_tx_raw_status(adv7511, irq1);\n\n\tif (!(irq1 & irq_rx_mask))\n\t\treturn;\n\n\tif (regmap_read(adv7511->regmap_cec,\n\t\t\tADV7511_REG_CEC_RX_STATUS + offset, &rx_status))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned int timestamp = (rx_status >> (2 * i)) & 0x3;\n\n\t\tif (timestamp)\n\t\t\trx_order[timestamp - 1] = i;\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tint rx_buf = rx_order[i];\n\n\t\tif (rx_buf < 0)\n\t\t\tbreak;\n\n\t\tadv7511_cec_rx(adv7511, rx_buf);\n\t}\n}\n\nstatic int adv7511_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct adv7511 *adv7511 = cec_get_drvdata(adap);\n\tunsigned int offset = adv7511->reg_cec_offset;\n\n\tif (adv7511->i2c_cec == NULL)\n\t\treturn -EIO;\n\n\tif (!adv7511->cec_enabled_adap && enable) {\n\t\t \n\t\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t\t   ADV7511_REG_CEC_CLK_DIV + offset,\n\t\t\t\t   0x03, 0x01);\n\t\t \n\t\tregmap_write(adv7511->regmap_cec,\n\t\t\t     ADV7511_REG_CEC_RX_BUFFERS + offset, 0x0f);\n\t\tregmap_write(adv7511->regmap_cec,\n\t\t\t     ADV7511_REG_CEC_RX_BUFFERS + offset, 0x08);\n\t\t \n\t\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t\t   ADV7511_REG_CEC_TX_ENABLE + offset, 1, 0);\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tregmap_update_bits(adv7511->regmap,\n\t\t\t\t   ADV7511_REG_INT_ENABLE(1), 0x3f,\n\t\t\t\t   ADV7511_INT1_CEC_MASK);\n\t} else if (adv7511->cec_enabled_adap && !enable) {\n\t\tregmap_update_bits(adv7511->regmap,\n\t\t\t\t   ADV7511_REG_INT_ENABLE(1), 0x3f, 0);\n\t\t \n\t\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t\t   ADV7511_REG_CEC_LOG_ADDR_MASK + offset,\n\t\t\t\t   0x70, 0x00);\n\t\t \n\t\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t\t   ADV7511_REG_CEC_CLK_DIV + offset,\n\t\t\t\t   0x03, 0x00);\n\t\tadv7511->cec_valid_addrs = 0;\n\t}\n\tadv7511->cec_enabled_adap = enable;\n\treturn 0;\n}\n\nstatic int adv7511_cec_adap_log_addr(struct cec_adapter *adap, u8 addr)\n{\n\tstruct adv7511 *adv7511 = cec_get_drvdata(adap);\n\tunsigned int offset = adv7511->reg_cec_offset;\n\tunsigned int i, free_idx = ADV7511_MAX_ADDRS;\n\n\tif (!adv7511->cec_enabled_adap)\n\t\treturn addr == CEC_LOG_ADDR_INVALID ? 0 : -EIO;\n\n\tif (addr == CEC_LOG_ADDR_INVALID) {\n\t\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t\t   ADV7511_REG_CEC_LOG_ADDR_MASK + offset,\n\t\t\t\t   0x70, 0);\n\t\tadv7511->cec_valid_addrs = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ADV7511_MAX_ADDRS; i++) {\n\t\tbool is_valid = adv7511->cec_valid_addrs & (1 << i);\n\n\t\tif (free_idx == ADV7511_MAX_ADDRS && !is_valid)\n\t\t\tfree_idx = i;\n\t\tif (is_valid && adv7511->cec_addr[i] == addr)\n\t\t\treturn 0;\n\t}\n\tif (i == ADV7511_MAX_ADDRS) {\n\t\ti = free_idx;\n\t\tif (i == ADV7511_MAX_ADDRS)\n\t\t\treturn -ENXIO;\n\t}\n\tadv7511->cec_addr[i] = addr;\n\tadv7511->cec_valid_addrs |= 1 << i;\n\n\tswitch (i) {\n\tcase 0:\n\t\t \n\t\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t\t   ADV7511_REG_CEC_LOG_ADDR_MASK + offset,\n\t\t\t\t   0x10, 0x10);\n\t\t \n\t\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t\t   ADV7511_REG_CEC_LOG_ADDR_0_1 + offset,\n\t\t\t\t   0x0f, addr);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t\t   ADV7511_REG_CEC_LOG_ADDR_MASK + offset,\n\t\t\t\t   0x20, 0x20);\n\t\t \n\t\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t\t   ADV7511_REG_CEC_LOG_ADDR_0_1 + offset,\n\t\t\t\t   0xf0, addr << 4);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t\t   ADV7511_REG_CEC_LOG_ADDR_MASK + offset,\n\t\t\t\t   0x40, 0x40);\n\t\t \n\t\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t\t   ADV7511_REG_CEC_LOG_ADDR_2 + offset,\n\t\t\t\t   0x0f, addr);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int adv7511_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t     u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct adv7511 *adv7511 = cec_get_drvdata(adap);\n\tunsigned int offset = adv7511->reg_cec_offset;\n\tu8 len = msg->len;\n\tunsigned int i;\n\n\t \n\tregmap_update_bits(adv7511->regmap_cec,\n\t\t\t   ADV7511_REG_CEC_TX_RETRY + offset,\n\t\t\t   0x70, max(1, attempts - 1) << 4);\n\n\t \n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_INT(1), 0x38, 0x38);\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\tregmap_write(adv7511->regmap_cec,\n\t\t\t     i + ADV7511_REG_CEC_TX_FRAME_HDR + offset,\n\t\t\t     msg->msg[i]);\n\n\t \n\tregmap_write(adv7511->regmap_cec,\n\t\t     ADV7511_REG_CEC_TX_FRAME_LEN + offset, len);\n\t \n\tregmap_write(adv7511->regmap_cec,\n\t\t     ADV7511_REG_CEC_TX_ENABLE + offset, 0x01);\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops adv7511_cec_adap_ops = {\n\t.adap_enable = adv7511_cec_adap_enable,\n\t.adap_log_addr = adv7511_cec_adap_log_addr,\n\t.adap_transmit = adv7511_cec_adap_transmit,\n};\n\nstatic int adv7511_cec_parse_dt(struct device *dev, struct adv7511 *adv7511)\n{\n\tadv7511->cec_clk = devm_clk_get(dev, \"cec\");\n\tif (IS_ERR(adv7511->cec_clk)) {\n\t\tint ret = PTR_ERR(adv7511->cec_clk);\n\n\t\tadv7511->cec_clk = NULL;\n\t\treturn ret;\n\t}\n\tclk_prepare_enable(adv7511->cec_clk);\n\tadv7511->cec_clk_freq = clk_get_rate(adv7511->cec_clk);\n\treturn 0;\n}\n\nint adv7511_cec_init(struct device *dev, struct adv7511 *adv7511)\n{\n\tunsigned int offset = adv7511->reg_cec_offset;\n\tint ret = adv7511_cec_parse_dt(dev, adv7511);\n\n\tif (ret)\n\t\tgoto err_cec_parse_dt;\n\n\tadv7511->cec_adap = cec_allocate_adapter(&adv7511_cec_adap_ops,\n\t\tadv7511, dev_name(dev), CEC_CAP_DEFAULTS, ADV7511_MAX_ADDRS);\n\tif (IS_ERR(adv7511->cec_adap)) {\n\t\tret = PTR_ERR(adv7511->cec_adap);\n\t\tgoto err_cec_alloc;\n\t}\n\n\tregmap_write(adv7511->regmap, ADV7511_REG_CEC_CTRL, 0);\n\t \n\tregmap_write(adv7511->regmap_cec,\n\t\t     ADV7511_REG_CEC_SOFT_RESET + offset, 0x01);\n\tregmap_write(adv7511->regmap_cec,\n\t\t     ADV7511_REG_CEC_SOFT_RESET + offset, 0x00);\n\n\t \n\tregmap_write(adv7511->regmap_cec,\n\t\t     ADV7511_REG_CEC_RX_BUFFERS + offset, 0x08);\n\n\tregmap_write(adv7511->regmap_cec,\n\t\t     ADV7511_REG_CEC_CLK_DIV + offset,\n\t\t     ((adv7511->cec_clk_freq / 750000) - 1) << 2);\n\n\tret = cec_register_adapter(adv7511->cec_adap, dev);\n\tif (ret)\n\t\tgoto err_cec_register;\n\treturn 0;\n\nerr_cec_register:\n\tcec_delete_adapter(adv7511->cec_adap);\n\tadv7511->cec_adap = NULL;\nerr_cec_alloc:\n\tdev_info(dev, \"Initializing CEC failed with error %d, disabling CEC\\n\",\n\t\t ret);\nerr_cec_parse_dt:\n\tregmap_write(adv7511->regmap, ADV7511_REG_CEC_CTRL,\n\t\t     ADV7511_CEC_CTRL_POWER_DOWN);\n\treturn ret == -EPROBE_DEFER ? ret : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}